
vmd2_3.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000d6  00800200  0000fce2  0000fd96  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000fce2  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000950  008002d6  008002d6  0000fe6c  2**0
                  ALLOC
  3 .eeprom       00000140  00810000  00810000  0000fe6c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .debug_aranges 00000020  00000000  00000000  0000ffac  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 00002e7b  00000000  00000000  0000ffcc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000f48a  00000000  00000000  00012e47  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000713  00000000  00000000  000222d1  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000879f  00000000  00000000  000229e4  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000012a0  00000000  00000000  0002b184  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000036ef  00000000  00000000  0002c424  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000084bd  00000000  00000000  0002fb13  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000f48  00000000  00000000  00037fd0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 3f 18 	jmp	0x307e	; 0x307e <__ctors_end>
       4:	0c 94 60 18 	jmp	0x30c0	; 0x30c0 <__bad_interrupt>
       8:	0c 94 60 18 	jmp	0x30c0	; 0x30c0 <__bad_interrupt>
       c:	0c 94 60 18 	jmp	0x30c0	; 0x30c0 <__bad_interrupt>
      10:	0c 94 60 18 	jmp	0x30c0	; 0x30c0 <__bad_interrupt>
      14:	0c 94 60 18 	jmp	0x30c0	; 0x30c0 <__bad_interrupt>
      18:	0c 94 60 18 	jmp	0x30c0	; 0x30c0 <__bad_interrupt>
      1c:	0c 94 60 18 	jmp	0x30c0	; 0x30c0 <__bad_interrupt>
      20:	0c 94 60 18 	jmp	0x30c0	; 0x30c0 <__bad_interrupt>
      24:	0c 94 60 18 	jmp	0x30c0	; 0x30c0 <__bad_interrupt>
      28:	0c 94 60 18 	jmp	0x30c0	; 0x30c0 <__bad_interrupt>
      2c:	0c 94 60 18 	jmp	0x30c0	; 0x30c0 <__bad_interrupt>
      30:	0c 94 60 18 	jmp	0x30c0	; 0x30c0 <__bad_interrupt>
      34:	0c 94 0b 28 	jmp	0x5016	; 0x5016 <__vector_13>
      38:	0c 94 60 18 	jmp	0x30c0	; 0x30c0 <__bad_interrupt>
      3c:	0c 94 60 18 	jmp	0x30c0	; 0x30c0 <__bad_interrupt>
      40:	0c 94 60 18 	jmp	0x30c0	; 0x30c0 <__bad_interrupt>
      44:	0c 94 af 1c 	jmp	0x395e	; 0x395e <__vector_17>
      48:	0c 94 d8 25 	jmp	0x4bb0	; 0x4bb0 <__vector_18>
      4c:	0c 94 60 18 	jmp	0x30c0	; 0x30c0 <__bad_interrupt>
      50:	0c 94 60 18 	jmp	0x30c0	; 0x30c0 <__bad_interrupt>
      54:	0c 94 d9 27 	jmp	0x4fb2	; 0x4fb2 <__vector_21>
      58:	0c 94 60 18 	jmp	0x30c0	; 0x30c0 <__bad_interrupt>
      5c:	0c 94 60 18 	jmp	0x30c0	; 0x30c0 <__bad_interrupt>
      60:	0c 94 60 18 	jmp	0x30c0	; 0x30c0 <__bad_interrupt>
      64:	0c 94 3e 39 	jmp	0x727c	; 0x727c <__vector_25>
      68:	0c 94 92 39 	jmp	0x7324	; 0x7324 <__vector_26>
      6c:	0c 94 68 39 	jmp	0x72d0	; 0x72d0 <__vector_27>
      70:	0c 94 60 18 	jmp	0x30c0	; 0x30c0 <__bad_interrupt>
      74:	0c 94 60 18 	jmp	0x30c0	; 0x30c0 <__bad_interrupt>
      78:	0c 94 60 18 	jmp	0x30c0	; 0x30c0 <__bad_interrupt>
      7c:	0c 94 60 18 	jmp	0x30c0	; 0x30c0 <__bad_interrupt>
      80:	0c 94 60 18 	jmp	0x30c0	; 0x30c0 <__bad_interrupt>
      84:	0c 94 60 18 	jmp	0x30c0	; 0x30c0 <__bad_interrupt>
      88:	0c 94 60 18 	jmp	0x30c0	; 0x30c0 <__bad_interrupt>
      8c:	0c 94 60 18 	jmp	0x30c0	; 0x30c0 <__bad_interrupt>
      90:	0c 94 bc 39 	jmp	0x7378	; 0x7378 <__vector_36>
      94:	0c 94 10 3a 	jmp	0x7420	; 0x7420 <__vector_37>
      98:	0c 94 e6 39 	jmp	0x73cc	; 0x73cc <__vector_38>
      9c:	0c 94 60 18 	jmp	0x30c0	; 0x30c0 <__bad_interrupt>
      a0:	0c 94 60 18 	jmp	0x30c0	; 0x30c0 <__bad_interrupt>
      a4:	0c 94 60 18 	jmp	0x30c0	; 0x30c0 <__bad_interrupt>
      a8:	0c 94 3f 28 	jmp	0x507e	; 0x507e <__vector_42>
      ac:	0c 94 60 18 	jmp	0x30c0	; 0x30c0 <__bad_interrupt>
      b0:	0c 94 60 18 	jmp	0x30c0	; 0x30c0 <__bad_interrupt>
      b4:	0c 94 60 18 	jmp	0x30c0	; 0x30c0 <__bad_interrupt>
      b8:	0c 94 60 18 	jmp	0x30c0	; 0x30c0 <__bad_interrupt>
      bc:	0c 94 60 18 	jmp	0x30c0	; 0x30c0 <__bad_interrupt>
      c0:	0c 94 60 18 	jmp	0x30c0	; 0x30c0 <__bad_interrupt>
      c4:	0c 94 60 18 	jmp	0x30c0	; 0x30c0 <__bad_interrupt>
      c8:	0c 94 60 18 	jmp	0x30c0	; 0x30c0 <__bad_interrupt>
      cc:	0c 94 8a 3a 	jmp	0x7514	; 0x7514 <__vector_51>
      d0:	0c 94 3a 3a 	jmp	0x7474	; 0x7474 <__vector_52>
      d4:	0c 94 62 3a 	jmp	0x74c4	; 0x74c4 <__vector_53>
      d8:	0c 94 60 18 	jmp	0x30c0	; 0x30c0 <__bad_interrupt>
      dc:	0c 94 60 18 	jmp	0x30c0	; 0x30c0 <__bad_interrupt>
      e0:	0c 94 60 18 	jmp	0x30c0	; 0x30c0 <__bad_interrupt>
      e4:	b9 4f       	sbci	r27, 0xF9	; 249
      e6:	df 4f       	sbci	r29, 0xFF	; 255
      e8:	f0 4f       	sbci	r31, 0xF0	; 240
      ea:	03 50       	subi	r16, 0x03	; 3
      ec:	b9 4f       	sbci	r27, 0xF9	; 249
      ee:	df 4f       	sbci	r29, 0xFF	; 255
      f0:	43 4f       	sbci	r20, 0xF3	; 243
      f2:	17 50       	subi	r17, 0x07	; 7
      f4:	27 50       	subi	r18, 0x07	; 7
      f6:	37 50       	subi	r19, 0x07	; 7
      f8:	4a 50       	subi	r20, 0x0A	; 10
      fa:	17 50       	subi	r17, 0x07	; 7
      fc:	27 50       	subi	r18, 0x07	; 7
      fe:	5d 50       	subi	r21, 0x0D	; 13
     100:	5d 50       	subi	r21, 0x0D	; 13
     102:	43 4f       	sbci	r20, 0xF3	; 243
     104:	43 4f       	sbci	r20, 0xF3	; 243
     106:	43 4f       	sbci	r20, 0xF3	; 243
     108:	43 4f       	sbci	r20, 0xF3	; 243
     10a:	43 4f       	sbci	r20, 0xF3	; 243
     10c:	43 4f       	sbci	r20, 0xF3	; 243
     10e:	43 4f       	sbci	r20, 0xF3	; 243
     110:	43 4f       	sbci	r20, 0xF3	; 243
     112:	43 4f       	sbci	r20, 0xF3	; 243
     114:	43 4f       	sbci	r20, 0xF3	; 243
     116:	43 4f       	sbci	r20, 0xF3	; 243
     118:	43 4f       	sbci	r20, 0xF3	; 243
     11a:	43 4f       	sbci	r20, 0xF3	; 243
     11c:	43 4f       	sbci	r20, 0xF3	; 243
     11e:	6b 50       	subi	r22, 0x0B	; 11
     120:	79 50       	subi	r23, 0x09	; 9
     122:	88 50       	subi	r24, 0x08	; 8
     124:	99 50       	subi	r25, 0x09	; 9
     126:	89 53       	subi	r24, 0x39	; 57
     128:	a8 53       	subi	r26, 0x38	; 56
     12a:	c9 53       	subi	r28, 0x39	; 57
     12c:	ec 53       	subi	r30, 0x3C	; 60
     12e:	89 53       	subi	r24, 0x39	; 57
     130:	a8 53       	subi	r26, 0x38	; 56
     132:	4b 53       	subi	r20, 0x3B	; 59
     134:	11 54       	subi	r17, 0x41	; 65
     136:	2f 54       	subi	r18, 0x4F	; 79
     138:	4e 54       	subi	r20, 0x4E	; 78
     13a:	70 54       	subi	r23, 0x40	; 64
     13c:	11 54       	subi	r17, 0x41	; 65
     13e:	2f 54       	subi	r18, 0x4F	; 79
     140:	93 54       	subi	r25, 0x43	; 67
     142:	93 54       	subi	r25, 0x43	; 67
     144:	4b 53       	subi	r20, 0x3B	; 59
     146:	9b 54       	subi	r25, 0x4B	; 75
     148:	14 53       	subi	r17, 0x34	; 52
     14a:	d2 54       	subi	r29, 0x42	; 66
     14c:	09 55       	subi	r16, 0x59	; 89
     14e:	9b 54       	subi	r25, 0x4B	; 75
     150:	14 53       	subi	r17, 0x34	; 52
     152:	4b 53       	subi	r20, 0x3B	; 59
     154:	4b 53       	subi	r20, 0x3B	; 59
     156:	4b 53       	subi	r20, 0x3B	; 59
     158:	46 55       	subi	r20, 0x56	; 86
     15a:	70 55       	subi	r23, 0x50	; 80
     15c:	46 55       	subi	r20, 0x56	; 86
     15e:	70 55       	subi	r23, 0x50	; 80
     160:	89 53       	subi	r24, 0x39	; 57
     162:	a8 53       	subi	r26, 0x38	; 56
     164:	9a 55       	subi	r25, 0x5A	; 90
     166:	ab 55       	subi	r26, 0x5B	; 91
     168:	c2 55       	subi	r28, 0x52	; 82
     16a:	67 53       	subi	r22, 0x37	; 55
     16c:	a2 58       	subi	r26, 0x82	; 130
     16e:	a2 58       	subi	r26, 0x82	; 130
     170:	59 58       	subi	r21, 0x89	; 137
     172:	59 58       	subi	r21, 0x89	; 137
     174:	a2 58       	subi	r26, 0x82	; 130
     176:	a2 58       	subi	r26, 0x82	; 130
     178:	65 57       	subi	r22, 0x75	; 117
     17a:	a2 58       	subi	r26, 0x82	; 130
     17c:	a2 58       	subi	r26, 0x82	; 130
     17e:	59 58       	subi	r21, 0x89	; 137
     180:	59 58       	subi	r21, 0x89	; 137
     182:	a2 58       	subi	r26, 0x82	; 130
     184:	a2 58       	subi	r26, 0x82	; 130
     186:	35 58       	subi	r19, 0x85	; 133
     188:	35 58       	subi	r19, 0x85	; 133
     18a:	65 57       	subi	r22, 0x75	; 117
     18c:	1d 58       	subi	r17, 0x8D	; 141
     18e:	1d 58       	subi	r17, 0x8D	; 141
     190:	1d 58       	subi	r17, 0x8D	; 141
     192:	1d 58       	subi	r17, 0x8D	; 141
     194:	1d 58       	subi	r17, 0x8D	; 141
     196:	1d 58       	subi	r17, 0x8D	; 141
     198:	65 57       	subi	r22, 0x75	; 117
     19a:	65 57       	subi	r22, 0x75	; 117
     19c:	65 57       	subi	r22, 0x75	; 117
     19e:	1d 58       	subi	r17, 0x8D	; 141
     1a0:	1d 58       	subi	r17, 0x8D	; 141
     1a2:	1d 58       	subi	r17, 0x8D	; 141
     1a4:	1d 58       	subi	r17, 0x8D	; 141
     1a6:	ff 57       	subi	r31, 0x7F	; 127
     1a8:	ff 57       	subi	r31, 0x7F	; 127
     1aa:	e2 57       	subi	r30, 0x72	; 114
     1ac:	e2 57       	subi	r30, 0x72	; 114
     1ae:	aa 57       	subi	r26, 0x7A	; 122
     1b0:	aa 57       	subi	r26, 0x7A	; 122
     1b2:	8a 5b       	subi	r24, 0xBA	; 186
     1b4:	81 5b       	subi	r24, 0xB1	; 177
     1b6:	79 5b       	subi	r23, 0xB9	; 185
     1b8:	6e 5b       	subi	r22, 0xBE	; 190
     1ba:	68 5b       	subi	r22, 0xB8	; 184
     1bc:	5f 5b       	subi	r21, 0xBF	; 191
     1be:	56 5b       	subi	r21, 0xB6	; 182
     1c0:	50 5b       	subi	r21, 0xB0	; 176
     1c2:	48 5b       	subi	r20, 0xB8	; 184
     1c4:	42 5b       	subi	r20, 0xB2	; 178
     1c6:	3a 5b       	subi	r19, 0xBA	; 186
     1c8:	34 5b       	subi	r19, 0xB4	; 180
     1ca:	2c 5b       	subi	r18, 0xBC	; 188
     1cc:	50 5b       	subi	r21, 0xB0	; 176
     1ce:	34 5b       	subi	r19, 0xB4	; 180
     1d0:	23 5b       	subi	r18, 0xB3	; 179
     1d2:	1c 5b       	subi	r17, 0xBC	; 188
     1d4:	15 5b       	subi	r17, 0xB5	; 181
     1d6:	0e 5b       	subi	r16, 0xBE	; 190
     1d8:	07 5b       	subi	r16, 0xB7	; 183
     1da:	00 5b       	subi	r16, 0xB0	; 176
     1dc:	f9 5a       	subi	r31, 0xA9	; 169
     1de:	1c 5b       	subi	r17, 0xBC	; 188
     1e0:	00 5b       	subi	r16, 0xB0	; 176
     1e2:	f0 5a       	subi	r31, 0xA0	; 160
     1e4:	e9 5a       	subi	r30, 0xA9	; 169
     1e6:	db 5a       	subi	r29, 0xAB	; 171
     1e8:	d4 5a       	subi	r29, 0xA4	; 164
     1ea:	c6 5a       	subi	r28, 0xA6	; 166
     1ec:	a6 5a       	subi	r26, 0xA6	; 166
     1ee:	b5 5a       	subi	r27, 0xA5	; 165
     1f0:	7f 5a       	subi	r23, 0xAF	; 175
     1f2:	32 5a       	subi	r19, 0xA2	; 162
     1f4:	7a 5a       	subi	r23, 0xAA	; 170
     1f6:	6c 5a       	subi	r22, 0xAC	; 172
     1f8:	59 62       	ori	r21, 0x29	; 41
     1fa:	4b 62       	ori	r20, 0x2B	; 43
     1fc:	3f 62       	ori	r19, 0x2F	; 47
     1fe:	eb 60       	ori	r30, 0x0B	; 11
     200:	1f 61       	ori	r17, 0x1F	; 31
     202:	8f 62       	ori	r24, 0x2F	; 47
     204:	76 61       	ori	r23, 0x16	; 22
     206:	31 62       	ori	r19, 0x21	; 33
     208:	25 62       	ori	r18, 0x25	; 37
     20a:	17 62       	ori	r17, 0x27	; 39
     20c:	0b 62       	ori	r16, 0x2B	; 43
     20e:	fd 61       	ori	r31, 0x1D	; 29
     210:	f1 61       	ori	r31, 0x11	; 17
     212:	e3 61       	ori	r30, 0x13	; 19
     214:	d8 61       	ori	r29, 0x18	; 24
     216:	fc 62       	ori	r31, 0x2C	; 44
     218:	84 60       	ori	r24, 0x04	; 4
     21a:	84 60       	ori	r24, 0x04	; 4
     21c:	84 60       	ori	r24, 0x04	; 4
     21e:	84 60       	ori	r24, 0x04	; 4
     220:	84 60       	ori	r24, 0x04	; 4
     222:	84 60       	ori	r24, 0x04	; 4
     224:	84 60       	ori	r24, 0x04	; 4
     226:	84 60       	ori	r24, 0x04	; 4
     228:	84 60       	ori	r24, 0x04	; 4
     22a:	84 60       	ori	r24, 0x04	; 4
     22c:	84 60       	ori	r24, 0x04	; 4
     22e:	84 60       	ori	r24, 0x04	; 4
     230:	84 60       	ori	r24, 0x04	; 4
     232:	84 60       	ori	r24, 0x04	; 4
     234:	84 60       	ori	r24, 0x04	; 4
     236:	84 60       	ori	r24, 0x04	; 4
     238:	84 60       	ori	r24, 0x04	; 4
     23a:	84 60       	ori	r24, 0x04	; 4
     23c:	84 60       	ori	r24, 0x04	; 4
     23e:	84 60       	ori	r24, 0x04	; 4
     240:	f0 62       	ori	r31, 0x20	; 32
     242:	e2 62       	ori	r30, 0x22	; 34
     244:	d6 62       	ori	r29, 0x26	; 38
     246:	6e 63       	ori	r22, 0x3E	; 62
     248:	5d 63       	ori	r21, 0x3D	; 61
     24a:	ae 62       	ori	r26, 0x2E	; 46
     24c:	9d 62       	ori	r25, 0x2D	; 45
     24e:	97 63       	ori	r25, 0x37	; 55
     250:	86 63       	ori	r24, 0x36	; 54
     252:	ab 63       	ori	r26, 0x3B	; 59
     254:	c1 62       	ori	r28, 0x21	; 33
     256:	c2 61       	ori	r28, 0x12	; 18
     258:	b0 61       	ori	r27, 0x10	; 16
     25a:	7a 63       	ori	r23, 0x3A	; 58
     25c:	a2 61       	ori	r26, 0x12	; 18
     25e:	f9 65       	ori	r31, 0x59	; 89
     260:	eb 65       	ori	r30, 0x5B	; 91
     262:	df 65       	ori	r29, 0x5F	; 95
     264:	d1 65       	ori	r29, 0x51	; 81
     266:	44 66       	ori	r20, 0x64	; 100
     268:	05 66       	ori	r16, 0x65	; 101
     26a:	50 66       	ori	r21, 0x60	; 96
     26c:	02 65       	ori	r16, 0x52	; 82
     26e:	11 67       	ori	r17, 0x71	; 113
     270:	06 67       	ori	r16, 0x76	; 118
     272:	ac 65       	ori	r26, 0x5C	; 92
     274:	6a 65       	ori	r22, 0x5A	; 90
     276:	e3 66       	ori	r30, 0x63	; 99
     278:	d0 66       	ori	r29, 0x60	; 96
     27a:	f0 66       	ori	r31, 0x60	; 96
     27c:	cc 61       	ori	r28, 0x1C	; 28
     27e:	a8 64       	ori	r26, 0x48	; 72
     280:	9c 64       	ori	r25, 0x4C	; 76
     282:	8a 64       	ori	r24, 0x4A	; 74
     284:	84 60       	ori	r24, 0x04	; 4
     286:	84 60       	ori	r24, 0x04	; 4
     288:	4c 64       	ori	r20, 0x4C	; 76
     28a:	42 64       	ori	r20, 0x42	; 66
     28c:	eb 63       	ori	r30, 0x3B	; 59
     28e:	dd 63       	ori	r29, 0x3D	; 61
     290:	bc 63       	ori	r27, 0x3C	; 60
     292:	ba 65       	ori	r27, 0x5A	; 90
     294:	f7 64       	ori	r31, 0x47	; 71
     296:	e6 64       	ori	r30, 0x46	; 70
     298:	b6 64       	ori	r27, 0x46	; 70
     29a:	1c 65       	ori	r17, 0x5C	; 92
     29c:	10 65       	ori	r17, 0x50	; 80
     29e:	2d 65       	ori	r18, 0x5D	; 93
     2a0:	88 61       	ori	r24, 0x18	; 24
     2a2:	58 61       	ori	r21, 0x18	; 24
     2a4:	4a 61       	ori	r20, 0x1A	; 26
     2a6:	2d 61       	ori	r18, 0x1D	; 29
     2a8:	9a 6e       	ori	r25, 0xEA	; 234
     2aa:	a1 6e       	ori	r26, 0xE1	; 225
     2ac:	8d 6e       	ori	r24, 0xED	; 237
     2ae:	94 6e       	ori	r25, 0xE4	; 228
     2b0:	83 6e       	ori	r24, 0xE3	; 227
     2b2:	89 6e       	ori	r24, 0xE9	; 233
     2b4:	76 6e       	ori	r23, 0xE6	; 230
     2b6:	7c 6e       	ori	r23, 0xEC	; 236
     2b8:	a8 6e       	ori	r26, 0xE8	; 232
     2ba:	72 6e       	ori	r23, 0xE2	; 226
     2bc:	5a 6e       	ori	r21, 0xEA	; 234
     2be:	2c 6f       	ori	r18, 0xFC	; 252
     2c0:	14 6f       	ori	r17, 0xF4	; 244
     2c2:	08 6f       	ori	r16, 0xF8	; 248
     2c4:	f0 6e       	ori	r31, 0xE0	; 224
     2c6:	d4 6e       	ori	r29, 0xE4	; 228
     2c8:	b0 6e       	ori	r27, 0xE0	; 224

000002ca <__c.1790>:
     2ca:	6e 61 6e 00                                         nan.

000002ce <__c.1788>:
     2ce:	69 6e 66 00                                         inf.

000002d2 <__c.2085>:
     2d2:	63 64 69 6e 6f 70 73 75 78 58 5b 65 66 67 45 46     cdinopsuxX[efgEF
     2e2:	47 00                                               G.

000002e4 <pstr_an>:
     2e4:	61 6e 00                                            an.

000002e7 <pstr_nfinity>:
     2e7:	6e 66 69 6e 69 74 79 00                             nfinity.

000002ef <pwr_m10>:
     2ef:	cd cc cc 3d 0a d7 23 3c 17 b7 d1 38 77 cc 2b 32     ...=..#<...8w.+2
     2ff:	95 95 e6 24 1f b1 4f 0a                             ...$..O.

00000307 <pwr_p10>:
     307:	00 00 20 41 00 00 c8 42 00 40 1c 46 20 bc be 4c     .. A...B.@.F ..L
     317:	ca 1b 0e 5a ae c5 9d 74                             ...Z...t

0000031f <DaysMonth>:
     31f:	00 1f 1c 1f 1e 1f 1e 1f 1f 1e 1f 1e 1f              .............

0000032c <Modbus_Map>:
     32c:	70 07 20 00 f8 09 20 00 13 0b 04 00 f7 07 50 00     p. ... .......P.

0000033c <BR_Tbl>:
     33c:	42 03 ff a0 01 fb cf 00 7d 67 00 3f 44 00 2a 33     B.......}g.?D.*3
     34c:	00 1f 22 00 1b 19 00 1b 10 00 1b                    .."........

00000357 <GSM_SIMCOM_SIM900R>:
     357:	53 49 4d 43 4f 4d 5f 53 49 4d 39 30 30 52 00        SIMCOM_SIM900R.

00000366 <GSM_SIMCOM_SIM800>:
     366:	53 49 4d 43 4f 4d 5f 53 49 4d 38 30 30 00           SIMCOM_SIM800.

00000374 <GSM_SIMCOM_SIM800C>:
     374:	53 49 4d 43 4f 4d 5f 53 49 4d 38 30 30 43 00        SIMCOM_SIM800C.

00000383 <URC_RDY>:
     383:	52 44 59 00                                         RDY.

00000387 <URC_CFUN>:
     387:	2b 43 46 55 4e 3a 20 31 00                          +CFUN: 1.

00000390 <URC_CPIN_READY>:
     390:	2b 43 50 49 4e 3a 20 52 45 41 44 59 00              +CPIN: READY.

0000039d <URC_CALL_READY>:
     39d:	43 61 6c 6c 20 52 65 61 64 79 00                    Call Ready.

000003a8 <URC_SMS_READY>:
     3a8:	53 4d 53 20 52 65 61 64 79 00                       SMS Ready.

000003b2 <URC_REMOTE_IP>:
     3b2:	52 45 4d 4f 54 45 20 49 50 00                       REMOTE IP.

000003bc <URC_CONNECT>:
     3bc:	43 4f 4e 4e 45 43 54 00                             CONNECT.

000003c4 <URC_RECEIVE>:
     3c4:	2b 52 45 43 45 49 56 45 2c 00                       +RECEIVE,.

000003ce <URC_CLOSED>:
     3ce:	2c 20 43 4c 4f 53 45 44 00                          , CLOSED.

000003d7 <URC_PDPDEACT>:
     3d7:	2b 50 44 50 20 44 45 41 43 54 00                    +PDP DEACT.

000003e2 <URC_NO_CARRIER>:
     3e2:	4e 4f 20 43 41 52 52 49 45 52 00                    NO CARRIER.

000003ed <RESP_OK>:
     3ed:	4f 4b 00                                            OK.

000003f0 <RESP_CONNECT>:
     3f0:	43 4f 4e 4e 45 43 54 00                             CONNECT.

000003f8 <RESP_CONNECT_OK>:
     3f8:	78 2c 20 43 4f 4e 4e 45 43 54 20 4f 4b 00           x, CONNECT OK.

00000406 <RESP_SERVER_OK>:
     406:	53 45 52 56 45 52 20 4f 4b 00                       SERVER OK.

00000410 <RESP_SERVER_CLOSE>:
     410:	53 45 52 56 45 52 20 43 4c 4f 53 45 00              SERVER CLOSE.

0000041d <RESP_Invitation>:
     41d:	3e 00                                               >.

0000041f <RESP_SEND_OK>:
     41f:	78 2c 20 53 45 4e 44 20 4f 4b 00                    x, SEND OK.

0000042a <RESP_CLOSE_OK>:
     42a:	43 4c 4f 53 45 20 4f 4b 00                          CLOSE OK.

00000433 <RESP_CLOSE_OK_FAST>:
     433:	78 2c 20 43 4c 4f 53 45 20 4f 4b 00                 x, CLOSE OK.

0000043f <RESP_CSQ>:
     43f:	2b 43 53 51 3a 00                                   +CSQ:.

00000445 <RESP_SHUT_OK>:
     445:	53 48 55 54 20 4f 4b 00                             SHUT OK.

0000044d <ESC_SEQ>:
     44d:	2b 2b 2b 00                                         +++.

00000451 <IDENTIFICATION>:
     451:	49 44 45 4e 54 49 46 49 43 41 54 49 4f 4e 00        IDENTIFICATION.

00000460 <AT_AT>:
     460:	41 54 00                                            AT.

00000463 <AT_IPR9600>:
     463:	41 54 2b 49 50 52 3d 39 36 30 30 00                 AT+IPR=9600.

0000046f <AT_W>:
     46f:	41 54 26 57 00                                      AT&W.

00000474 <AT_E0>:
     474:	41 54 45 30 00                                      ATE0.

00000479 <AT_CLCC1>:
     479:	41 54 2b 43 4c 43 43 3d 31 00                       AT+CLCC=1.

00000483 <AT_DDET101>:
     483:	41 54 2b 44 44 45 54 3d 31 2c 30 2c 31 00           AT+DDET=1,0,1.

00000491 <AT_CGMM>:
     491:	41 54 2b 43 47 4d 4d 00                             AT+CGMM.

00000499 <AT_CCID>:
     499:	41 54 2b 43 43 49 44 00                             AT+CCID.

000004a1 <AT_IFC>:
     4a1:	41 54 2b 49 46 43 3d 32 2c 32 00                    AT+IFC=2,2.

000004ac <ATD101>:
     4ac:	41 54 44 2a 31 30 31 23 00                          ATD*101#.

000004b5 <ATD_PLUS>:
     4b5:	41 54 44 2b 00                                      ATD+.

000004ba <AT_CUSD101>:
     4ba:	41 54 2b 43 55 53 44 3d 31 2c 22 00                 AT+CUSD=1,".

000004c6 <AT_CMGF>:
     4c6:	41 54 2b 43 4d 47 46 3d 31 00                       AT+CMGF=1.

000004d0 <AT_CSMP>:
     4d0:	41 54 2b 43 53 4d 50 3d 31 37 2c 31 36 37 2c 30     AT+CSMP=17,167,0
     4e0:	2c 30 00                                            ,0.

000004e3 <AT_CMGS>:
     4e3:	41 54 2b 43 4d 47 53 3d 22 2b 00                    AT+CMGS="+.

000004ee <AT_CIPMODE_0>:
     4ee:	41 54 2b 43 49 50 4d 4f 44 45 3d 30 00              AT+CIPMODE=0.

000004fb <AT_CIPMODE_1>:
     4fb:	41 54 2b 43 49 50 4d 4f 44 45 3d 31 00              AT+CIPMODE=1.

00000508 <AT_CIPMUX_0>:
     508:	41 54 2b 43 49 50 4d 55 58 3d 30 00                 AT+CIPMUX=0.

00000514 <AT_CIPMUX_1>:
     514:	41 54 2b 43 49 50 4d 55 58 3d 31 00                 AT+CIPMUX=1.

00000520 <AT_CGATT>:
     520:	41 54 2b 43 47 41 54 54 3d 31 00                    AT+CGATT=1.

0000052b <AT_CIPCSGP>:
     52b:	41 54 2b 43 49 50 43 53 47 50 3d 31 2c 22 00        AT+CIPCSGP=1,".

0000053a <AT_CSTT>:
     53a:	41 54 2b 43 53 54 54 00                             AT+CSTT.

00000542 <AT_CIICR>:
     542:	41 54 2b 43 49 49 43 52 00                          AT+CIICR.

0000054b <AT_CIFSR>:
     54b:	41 54 2b 43 49 46 53 52 00                          AT+CIFSR.

00000554 <AT_CIPTKA>:
     554:	41 54 2b 43 49 50 54 4b 41 3d 31 2c 33 30 2c 33     AT+CIPTKA=1,30,3
     564:	30 2c 31 00                                         0,1.

00000568 <AT_CIPSTART>:
     568:	41 54 2b 43 49 50 53 54 41 52 54 3d 22 55 44 50     AT+CIPSTART="UDP
     578:	22 2c 00                                            ",.

0000057b <AT_CIPSTART_TCP_CLIENT>:
     57b:	41 54 2b 43 49 50 53 54 41 52 54 3d 22 54 43 50     AT+CIPSTART="TCP
     58b:	22 2c 00                                            ",.

0000058e <AT_CIPSERVER>:
     58e:	41 54 2b 43 49 50 53 45 52 56 45 52 3d 31 2c 00     AT+CIPSERVER=1,.

0000059e <AT_SERVERCLOSE>:
     59e:	41 54 2b 43 49 50 53 45 52 56 45 52 3d 30 00        AT+CIPSERVER=0.

000005ad <AT_CIPSEND>:
     5ad:	41 54 2b 43 49 50 53 45 4e 44 3d 00                 AT+CIPSEND=.

000005b9 <AT_CIPCLOSE_1>:
     5b9:	41 54 2b 43 49 50 43 4c 4f 53 45 3d 78 2c 31 00     AT+CIPCLOSE=x,1.

000005c9 <AT_CIPCLOSE>:
     5c9:	41 54 2b 43 49 50 43 4c 4f 53 45 3d 31 00           AT+CIPCLOSE=1.

000005d7 <AT_CIPSHUT>:
     5d7:	41 54 2b 43 49 50 53 48 55 54 00                    AT+CIPSHUT.

000005e2 <AT_CGATT_0>:
     5e2:	41 54 2b 43 47 41 54 54 3d 30 00                    AT+CGATT=0.

000005ed <AT_CSQ>:
     5ed:	41 54 2b 43 53 51 00                                AT+CSQ.

000005f4 <ATO>:
     5f4:	41 54 4f 00                                         ATO.

000005f8 <Symbols_P>:
     5f8:	30 31 32 33 34 35 36 37 38 39 61 62 63 64 65 66     0123456789abcdef
     608:	67 68 69 6a 6b 6c 6d 6e 6f 70 71 72 73 74 75 76     ghijklmnopqrstuv
     618:	77 78 79 7a 41 42 43 44 45 46 47 48 49 4a 4b 4c     wxyzABCDEFGHIJKL
     628:	4d 4e 4f 50 51 52 53 54 55 56 57 58 59 5a e0 e1     MNOPQRSTUVWXYZ..
     638:	e2 e3 e4 e5 b8 ba e6 e7 e8 b3 bf e9 ea eb ec ed     ................
     648:	ee ef f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 fa fb fc fd     ................
     658:	fe ff c0 c1 c2 c3 c4 c5 a8 aa c6 c7 c8 b2 af c9     ................
     668:	ca cb cc cd ce cf d0 d1 d2 d3 d4 d5 d6 d7 d8 d9     ................
     678:	da db dc dd de df 20 2b 2d 3d 3c 3e 24 25 26 2e     ...... +-=<>$%&.
     688:	2c 3f 21 27 40 3a 28 29 22 7c 2a 23 2f 00           ,?!'@:()"|*#/.

00000696 <OnlyDigits_P>:
     696:	30 31 32 33 34 35 36 37 38 39 00                    0123456789.

000006a1 <Digits_P>:
     6a1:	30 31 32 33 34 35 36 37 38 39 65 2b 2d 2e 00        0123456789e+-..

000006b0 <ThermFami>:
     6b0:	00 00 00 00 00 00                                   ......

000006b6 <TermisLim>:
     6b6:	00 00 00 00 0c fe 08 07 0c fe 08 07 0c fe 70 17     ..............p.
     6c6:	0c fe 70 17 0c fe 70 17 0c fe 70 17 0c fe 08 07     ..p...p...p.....

000006d6 <TermocLim>:
     6d6:	00 00 00 00 30 f8 e0 2e 70 17 50 46 30 f8 4c 1d     ....0...p.PF0.L.
     6e6:	30 f8 70 17                                         0.p.

000006ea <Fail_Str>:
     6ea:	d1 e1 ee e9 20 00                                   .... .

000006f0 <Norm_Str>:
     6f0:	cd ee f0 ec e0 00                                   ......

000006f6 <DI_NO_Str>:
     6f6:	ed e5 f2 20 00                                      ... .

000006fb <DI_OK_Str>:
     6fb:	ed ee f0 ec 00                                      .....

00000700 <DI_Sta_Tbl>:
     700:	f6 06 fb 06                                         ....

00000704 <DI_Op_Str>:
     704:	f0 e0 e7 ec 00                                      .....

00000709 <DI_Cl_Str>:
     709:	e7 e0 ec ea 00                                      .....

0000070e <DI_Tbl>:
     70e:	04 07 09 07                                         ....

00000712 <DI_Inv_Cl_Str>:
     712:	ed 2e e7 2e 00                                      .....

00000717 <DI_Inv_Op_Str>:
     717:	ed 2e f0 2e 00                                      .....

0000071c <DI_Inv_Tbl>:
     71c:	12 07 17 07                                         ....

00000720 <DO_Op_Str>:
     720:	e2 fb ea eb 00                                      .....

00000725 <DO_Cl_Str>:
     725:	e2 ea eb 20 00                                      ... .

0000072a <DO_Tbl>:
     72a:	20 07 25 07                                          .%.

0000072e <F_ADC_3>:
     72e:	07 6a 07 00 00 00                                   .j....

00000734 <F_ADC_4>:
     734:	07 dd 08 00 00 00                                   ......

0000073a <F_ADC_5>:
     73a:	07 af 06 00 00 00                                   ......

00000740 <List_ADC_Err>:
     740:	20 2d 2d 2d 20 41 44 43 20 65 72 72 6f 72 73 20      --- ADC errors 
     750:	2d 2d 2d 20 00 00 00 00 00 00 00 20 52 65 61 64     --- ....... Read
     760:	20 66 61 69 6c 3a 20 20 20 20 7b 7b 7b 7b 7b 00      fail:    {{{{{.
     770:	2e 07 00 00 00 00 20 43 61 6c 69 62 72 20 66 61     ...... Calibr fa
     780:	69 6c 3a 20 20 7b 7b 7b 7b 7b 00 34 07 00 00 00     il:  {{{{{.4....
     790:	00 20 43 61 6c 69 62 72 20 62 72 65 61 6b 3a 20     . Calibr break: 
     7a0:	7b 7b 7b 7b 7b 00 3a 07 00 00 00 00                 {{{{{.:.....

000007ac <Menu_ADC_Err>:
     7ac:	40 07 04 03 00 00 00 00 00 00 00 00 00 00 00 00     @...............
     7bc:	00 00 00 00                                         ....

000007c0 <F_ADC_1>:
     7c0:	1d 1c 0b 3a 24 00                                   ...:$.

000007c6 <F_ADC_2>:
     7c6:	00 ab 06 00 00 00 00 c4 08 00 00 00                 ............

000007d2 <List_ADC>:
     7d2:	20 d0 e5 e6 e8 ec 3a 20 7b 7b 7b 7b 7b 7b 7b 7b      .....: {{{{{{{{
     7e2:	7b 7b 7b 7b 00 c0 07 00 00 00 00 20 c2 f0 e5 ec     {{{{....... ....
     7f2:	ff 3a 7b 7b 30 ec f1 20 ca e0 ed e0 eb 3a 7b 00     .:{{0.. .....:{.
     802:	c6 07 00 00 00 00 20 2d 20 ca e0 ed e0 eb fb 20     ...... - ...... 
     812:	2d 20 20 20 20 20 20 20 20 20 00 00 00 00 00 5b     -         .....[
     822:	23 20 2d 20 ca e0 eb e8 e1 f0 ee e2 ea e0 20 2d     # - .......... -
     832:	20 20 20 20 20 00 00 00 00 00 ff 23 20 2d 20 ce          ......# - .
     842:	f8 e8 e1 ea e8 20 2d 20 20 20 20 20 20 20 20 20     ..... -         
     852:	00 00 00 00 00 ac 07                                .......

00000859 <MenuADC>:
     859:	d2 07 05 02 00 00 00 00 00 00 00 00 00 00 00 00     ................
     869:	00 00 00 00                                         ....

0000086d <MsgErr21>:
     86d:	20 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f      _______________
     87d:	5f 5f 5f 20 00 00 00 20 49 6e 74 65 72 6e 61 6c     ___ ... Internal
     88d:	20 65 72 72 6f 72 20 32 31 3a 20 00 00 00 20 20      error 21: ...  
     89d:	20 20 20 20 41 44 43 20 6f 66 66 20 20 20 20 20         ADC off     
     8ad:	20 20 00 00 00 20 20 20 20 20 20 20 20 20 20 20       ...           
     8bd:	20 20 20 20 20 20 20 20 20 00 00 00 00 00 00 00              .......
	...

000008cf <Therm_Off_Str>:
     8cf:	20 20 20 78 20 20 20 00                                x   .

000008d7 <ADC_Off_Str>:
     8d7:	2d 2d 2d 2d 2d 2d 2d 00                             -------.

000008df <ThermTbl>:
     8df:	cf 08 d7 08                                         ....

000008e3 <ThermOff_Str>:
     8e3:	ce f2 ea eb 2e 00                                   ......

000008e9 <TSM100_Str>:
     8e9:	d2 d1 cc 31 30 30 00                                ...100.

000008f0 <TSM50_Str>:
     8f0:	d2 d1 cc 35 30 00                                   ...50.

000008f6 <TSP100_Str>:
     8f6:	d2 d1 cf 31 30 30 00                                ...100.

000008fd <TSP50_Str>:
     8fd:	d2 d1 cf 35 30 00                                   ...50.

00000903 <Pt100_Str>:
     903:	50 74 31 30 30 00                                   Pt100.

00000909 <Gr21_Str>:
     909:	c3 f0 32 31 00                                      ..21.

0000090e <Gr23_Str>:
     90e:	c3 f0 32 33 00                                      ..23.

00000913 <RTD_Name_List>:
     913:	e3 08 e9 08 f0 08 f6 08 fd 08 03 09 09 09 0e 09     ................

00000923 <TC_K_Str>:
     923:	54 58 41 00                                         TXA.

00000927 <TC_B_Str>:
     927:	54 cf d0 00                                         T...

0000092b <TC_J_Str>:
     92b:	54 c6 ca 00                                         T...

0000092f <TC_L_Str>:
     92f:	54 58 ca 00                                         TX..

00000933 <TC_Name_List>:
     933:	e3 08 23 09 27 09 2b 09 2f 09                       ..#.'.+./.

0000093d <NoPariStr>:
     93d:	ed e5 f2 00                                         ....

00000941 <EvenPariStr>:
     941:	f7 e5 f2 ed fb e9 00                                .......

00000948 <OddPariStr>:
     948:	ed e5 f7 e5 f2 ed fb e9 00                          .........

00000951 <MBPariTbl>:
     951:	3d 09 41 09 48 09                                   =.A.H.

00000957 <BR_Str1200>:
     957:	31 32 30 30 00                                      1200.

0000095c <BR_Str2400>:
     95c:	32 34 30 30 00                                      2400.

00000961 <BR_Str4800>:
     961:	34 38 30 30 00                                      4800.

00000966 <BR_Str9600>:
     966:	39 36 30 30 00                                      9600.

0000096b <BR_Str14400>:
     96b:	31 34 34 30 30 00                                   14400.

00000971 <BR_Str19200>:
     971:	31 39 32 30 30 00                                   19200.

00000977 <BR_Str28800>:
     977:	32 38 38 30 30 00                                   28800.

0000097d <BR_Str38400>:
     97d:	33 38 34 30 30 00                                   38400.

00000983 <BR_Str57600>:
     983:	35 37 36 30 30 00                                   57600.

00000989 <BaudTbl>:
     989:	57 09 5c 09 61 09 66 09 6b 09 71 09 77 09 7d 09     W.\.a.f.k.q.w.}.
     999:	83 09                                               ..

0000099b <F_MB0_Pari>:
     99b:	1e 04 00 00 00 00 00 02 00 00 00 6d 6c 51 09 00     ...........mlQ..

000009ab <F_MB0_Stopbits>:
     9ab:	01 05 00 01 00 00 00 02 00 00 00 6d 6c 00 00 00     ...........ml...

000009bb <F_MB0_Baud>:
     9bb:	1e 06 00 00 00 00 00 08 00 00 00 f6 6b 89 09 00     ............k...

000009cb <MB0_CPT_04>:
     9cb:	0b e8 08 00 00 00 0b f0 08 00 00 00                 ............

000009d7 <MB0_CPT_15>:
     9d7:	0b ea 08 00 00 00 0b f2 08 00 00 00                 ............

000009e3 <MB0_CPT_26>:
     9e3:	0b ec 08 00 00 00 0b f4 08 00 00 00                 ............

000009ef <MB0_CPT_37>:
     9ef:	0b ee 08 00 00 00 0b f6 08 00 00 00                 ............

000009fb <List_MB0_CPT>:
     9fb:	43 50 31 3a 7b 7b 7b 7b 7b 20 20 43 50 35 3a 7b     CP1:{{{{{  CP5:{
     a0b:	7b 7b 7b 7b 00 cb 09 00 00 00 00 43 50 32 3a 7b     {{{{.......CP2:{
     a1b:	7b 7b 7b 7b 20 20 43 50 36 3a 7b 7b 7b 7b 7b 00     {{{{  CP6:{{{{{.
     a2b:	d7 09 00 00 00 00 43 50 33 3a 7b 7b 7b 7b 7b 20     ......CP3:{{{{{ 
     a3b:	20 43 50 37 3a 7b 7b 7b 7b 7b 00 e3 09 00 00 00      CP7:{{{{{......
     a4b:	00 43 50 34 3a 7b 7b 7b 7b 7b 20 20 43 50 38 3a     .CP4:{{{{{  CP8:
     a5b:	7b 7b 7b 7b 7b 00 ef 09 00 00 00 00                 {{{{{.......

00000a67 <M_MB0_CPT>:
     a67:	fb 09 04 03 00 00 00 00 00 00 00 00 3b 3f 00 00     ............;?..
     a77:	00 00 00 00                                         ....

00000a7b <L_MB0>:
     a7b:	20 2d 2d 2d 2d 20 4d 6f 64 62 75 73 20 30 20 2d      ---- Modbus 0 -
     a8b:	2d 2d 2d 20 00 00 00 00 00 00 00 20 d1 f7 e5 f2     --- ....... ....
     a9b:	f7 e8 ea e8 20 28 f1 e1 f0 ee f1 3a 2d 3e 29 00     .... (.....:->).
     aab:	00 00 00 00 67 0a 20 cf e0 f0 e8 f2 e5 f2 3a 20     ....g. .......: 
     abb:	7d 7d 7d 7d 7d 7d 7d 7d 20 20 00 00 00 9b 09 00     }}}}}}}}  ......
     acb:	00 20 d1 f2 ee ef 2d e1 e8 f2 fb 3a 20 7d 20 20     . ....-....: }  
     adb:	20 20 20 20 20 00 00 00 ab 09 00 00 20 42 41 55          ....... BAU
     aeb:	44 3a 20 7d 7d 7d 7d 7d 62 70 73 20 20 20 20 20     D: }}}}}bps     
     afb:	00 00 00 bb 09 00 00                                .......

00000b02 <MenuModbus0>:
     b02:	7b 0a 05 01 00 00 00 00 00 00 00 00 00 00 00 00     {...............
     b12:	00 00 00 00                                         ....

00000b16 <List_Modbus>:
     b16:	20 4d 6f 64 62 75 73 20 30 20 20 20 20 20 20 20      Modbus 0       
     b26:	20 20 20 20 00 00 00 00 00 02 0b 20 20 20 20 58         .......    X
     b36:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 00                    .
     b46:	00 00 00 00 00 00 20 20 20 20 58 20 20 20 20 20     ......    X     
     b56:	20 20 20 20 20 20 20 20 20 20 00 00 00 00 00 00               ......
     b66:	00 20 20 20 20 58 20 20 20 20 20 20 20 20 20 20     .    X          
     b76:	20 20 20 20 20 00 00 00 00 00 00 00                      .......

00000b82 <MenuModbus>:
     b82:	16 0b 04 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     b92:	00 00 00 00                                         ....

00000b96 <N_Str>:
     b96:	cd e5 f2 00                                         ....

00000b9a <Y_Str>:
     b9a:	c4 e0 00                                            ...

00000b9d <YN_Tbl>:
     b9d:	96 0b 9a 0b                                         ....

00000ba1 <F_SummerTime>:
     ba1:	1e 03 00 00 00 00 00 01 00 00 00 00 00 9d 0b 00     ................

00000bb1 <F_WDay>:
     bb1:	00 4f 06 00 00 00                                   .O....

00000bb7 <F_DateTime>:
     bb7:	04 11 0b 01 00 00 00 1f 00 00 00 17 23 00 00 00     ............#...
     bc7:	04 7f 07 01 00 00 00 0c 00 00 00 21 23 00 00 00     ...........!#...
     bd7:	04 d6 05 00 00 00 00 63 00 00 00 2b 23 00 00 00     .......c...+#...
     be7:	04 b9 05 00 00 00 00 17 00 00 00 0d 23 00 00 00     ............#...
     bf7:	04 49 06 00 00 00 00 3b 00 00 00 03 23 00 00 00     .I.....;....#...
     c07:	04 ae 06 00 00 00 00 3b 00 00 00 f9 22 00 00 00     .......;...."...

00000c17 <GSM_CNTL_AUTO_Str>:
     c17:	61 75 74 6f 20 20 00                                auto  .

00000c1e <GSM_CNTL_MANUAL_Str>:
     c1e:	6d 61 6e 75 61 6c 00                                manual.

00000c25 <GSM_CNTL_CONFIG_Str>:
     c25:	63 6f 6e 66 69 67 00                                config.

00000c2c <GSM_ControlList>:
     c2c:	17 0c 1e 0c 25 0c                                   ....%.

00000c32 <GSM_Not_Recognize_Str>:
     c32:	6e 6f 74 20 72 65 63 6f 67 00                       not recog.

00000c3c <GSM_SIMCOM_SIM900R_Str>:
     c3c:	53 49 4d 39 30 30 52 20 20 00                       SIM900R  .

00000c46 <GSM_SIMCOM_SIM800_Str>:
     c46:	53 49 4d 38 30 30 20 20 20 00                       SIM800   .

00000c50 <GSM_ModemList>:
     c50:	32 0c 3c 0c 46 0c                                   2.<.F.

00000c56 <MenuGSM_Modem_State>:
     c56:	1d eb 06 50 0c 00 00 ad 06 00 00 00                 ...P........

00000c62 <MenuGSM_State>:
     c62:	00 ad 06 00 00 00                                   ......

00000c68 <MenuGSM_GSM_Cont>:
     c68:	1d 84 07 00 00 00 00 02 00 00 00 4a 3f 2c 0c 00     ...........J?,..

00000c78 <MenuGSM_GSM_MyIP>:
     c78:	00 e3 08 00 00 00 00 e4 08 00 00 00 00 e5 08 00     ................
     c88:	00 00 00 e6 08 00 00 00                             ........

00000c90 <MenuGSM_ClientIP>:
     c90:	00 fc 0a 00 00 00 00 fd 0a 00 00 00 00 fe 0a 00     ................
     ca0:	00 00 00 ff 0a 00 00 00                             ........

00000ca8 <MenuGSM_ActiveCon>:
     ca8:	00 d0 02 00 00 00                                   ......

00000cae <MenuGSM_FIFOMax>:
     cae:	00 cb 08 00 00 00                                   ......

00000cb4 <MenuGSM_APN1>:
     cb4:	22 09 00 00 00 00 00 06 00 00 00 00 00 00 00 00     "...............

00000cc4 <MenuGSM_APN2>:
     cc4:	22 1d 00 00 00 00 00 06 00 00 00 00 00 00 00 00     "...............

00000cd4 <MenuGSM_APN_USER_NAME>:
     cd4:	22 59 00 00 00 00 00 06 00 00 00 00 00 00 00 00     "Y..............

00000ce4 <MenuGSM_APN_PASSWORD>:
     ce4:	22 6d 00 00 00 00 00 06 00 00 00 00 00 00 00 00     "m..............

00000cf4 <MenuGSM_IPUDP1>:
     cf4:	01 81 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     d04:	01 82 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     d14:	01 83 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     d24:	01 84 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00000d34 <MenuGSM_IPUDP2>:
     d34:	01 85 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     d44:	01 86 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     d54:	01 87 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     d64:	01 88 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00000d74 <MenuGSM_IPUDP3>:
     d74:	01 89 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     d84:	01 8a 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     d94:	01 8b 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     da4:	01 8c 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00000db4 <MenuGSM_IPUDP4>:
     db4:	01 8d 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     dc4:	01 8e 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     dd4:	01 8f 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     de4:	01 90 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00000df4 <MenuGSM_PortUDP1>:
     df4:	08 a1 00 00 00 00 00 ff ff 00 00 00 00 00 00 00     ................

00000e04 <MenuGSM_PortUDP2>:
     e04:	08 a3 00 00 00 00 00 ff ff 00 00 00 00 00 00 00     ................

00000e14 <MenuGSM_PortUDP3>:
     e14:	08 a5 00 00 00 00 00 ff ff 00 00 00 00 00 00 00     ................

00000e24 <MenuGSM_PortUDP4>:
     e24:	08 a7 00 00 00 00 00 ff ff 00 00 00 00 00 00 00     ................

00000e34 <MenuGSM_IPTCP1>:
     e34:	01 b3 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     e44:	01 b4 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     e54:	01 b5 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     e64:	01 b6 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00000e74 <MenuGSM_IPTCP2>:
     e74:	01 b7 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     e84:	01 b8 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     e94:	01 b9 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     ea4:	01 ba 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00000eb4 <MenuGSM_IPTCP3>:
     eb4:	01 bb 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     ec4:	01 bc 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     ed4:	01 bd 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     ee4:	01 be 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00000ef4 <MenuGSM_IPTCP4>:
     ef4:	01 bf 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     f04:	01 c0 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     f14:	01 c1 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     f24:	01 c2 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00000f34 <MenuGSM_TCPPort>:
     f34:	08 b1 00 00 00 00 00 ff ff 00 00 00 00 00 00 00     ................

00000f44 <MenuGSM_TCPTimeout>:
     f44:	08 c3 00 64 00 00 00 ff ff 00 00 00 00 00 00 02     ...d............

00000f54 <MenuGSM_SMS>:
     f54:	01 13 01 00 00 00 00 01 00 00 00 00 00 00 00 00     ................

00000f64 <MenuGSM_VegaSN>:
     f64:	08 07 00 00 00 00 00 ff ff 00 00 00 00 00 00 00     ................

00000f74 <ListGSM>:
     f74:	20 cc ee e4 e5 ec 20 7b 7b 7b 7b 7b 7b 7b 7b 7b      ..... {{{{{{{{{
     f84:	20 7b 7b 7b 00 56 0c 00 00 00 00 20 43 6f 6e 74      {{{.V..... Cont
     f94:	72 6f 6c 20 6d 6f 64 65 3a 7d 7d 7d 7d 7d 7d 00     rol mode:}}}}}}.
     fa4:	00 00 68 0c 00 00 20 4d 79 49 50 7b 7b 7b 2e 7b     ..h... MyIP{{{.{
     fb4:	7b 7b 2e 7b 7b 7b 2e 7b 7b 7b 00 78 0c 00 00 00     {{.{{{.{{{.x....
     fc4:	00 20 43 6c 49 50 7b 7b 7b 2e 7b 7b 7b 2e 7b 7b     . ClIP{{{.{{{.{{
     fd4:	7b 2e 7b 7b 7b 00 90 0c 00 00 00 00 20 41 63 74     {.{{{....... Act
     fe4:	69 76 65 20 63 6f 6e 65 63 74 69 6f 6e 7b 7b 7b     ive conection{{{
     ff4:	00 a8 0c 00 00 00 00 20 46 49 46 4f 3a 6d 61 78     ....... FIFO:max
    1004:	20 7b 7b 2f 37 30 62 79 74 65 20 00 ae 0c 00 00      {{/70byte .....
    1014:	00 00 20 2d 2d 2d 2d 2d 2d 2d 41 50 4e 2d 2d 2d     .. -------APN---
    1024:	2d 2d 2d 2d 2d 2d 00 00 00 00 00 00 00 20 7d 7d     ------....... }}
    1034:	7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d     }}}}}}}}}}}}}}}}
    1044:	7d 00 00 00 b4 0c 00 00 20 7d 7d 7d 7d 7d 7d 7d     }....... }}}}}}}
    1054:	7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 00 00 00 c4     }}}}}}}}}}}}....
    1064:	0c 00 00 20 2d 2d 2d 41 50 4e 2d 55 53 45 52 20     ... ---APN-USER 
    1074:	4e 41 4d 45 2d 2d 2d 00 00 00 00 00 00 00 20 7d     NAME---....... }
    1084:	7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d     }}}}}}}}}}}}}}}}
    1094:	7d 7d 00 00 00 d4 0c 00 00 20 2d 2d 2d 41 50 4e     }}....... ---APN
    10a4:	2d 50 41 53 53 57 4f 52 44 2d 2d 2d 2d 00 00 00     -PASSWORD----...
    10b4:	00 00 00 00 20 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d     .... }}}}}}}}}}}
    10c4:	7d 7d 7d 7d 7d 7d 7d 7d 00 00 00 e4 0c 00 00 20     }}}}}}}}....... 
    10d4:	2d 2d 53 65 6e 64 20 55 44 50 20 74 6f 20 49 50     --Send UDP to IP
    10e4:	2d 2d 2d 00 00 00 00 00 00 00 20 49 50 31 3a 7d     ---....... IP1:}
    10f4:	7d 7d 2e 7d 7d 7d 2e 7d 7d 7d 2e 7d 7d 7d 00 00     }}.}}}.}}}.}}}..
    1104:	00 f4 0c 00 00 20 49 50 32 3a 7d 7d 7d 2e 7d 7d     ..... IP2:}}}.}}
    1114:	7d 2e 7d 7d 7d 2e 7d 7d 7d 00 00 00 34 0d 00 00     }.}}}.}}}...4...
    1124:	20 49 50 33 3a 7d 7d 7d 2e 7d 7d 7d 2e 7d 7d 7d      IP3:}}}.}}}.}}}
    1134:	2e 7d 7d 7d 00 00 00 74 0d 00 00 20 49 50 34 3a     .}}}...t... IP4:
    1144:	7d 7d 7d 2e 7d 7d 7d 2e 7d 7d 7d 2e 7d 7d 7d 00     }}}.}}}.}}}.}}}.
    1154:	00 00 b4 0d 00 00 20 2d 2d 2d 2d 20 55 44 50 20     ...... ---- UDP 
    1164:	50 6f 72 74 20 2d 2d 2d 2d 2d 00 00 00 00 00 00     Port -----......
    1174:	00 20 49 50 31 20 50 6f 72 74 3a 7d 7d 7d 7d 7d     . IP1 Port:}}}}}
    1184:	20 20 20 20 20 00 00 00 f4 0d 00 00 20 49 50 32          ....... IP2
    1194:	20 50 6f 72 74 3a 7d 7d 7d 7d 7d 20 20 20 20 20      Port:}}}}}     
    11a4:	00 00 00 04 0e 00 00 20 49 50 33 20 50 6f 72 74     ....... IP3 Port
    11b4:	3a 7d 7d 7d 7d 7d 20 20 20 20 20 00 00 00 14 0e     :}}}}}     .....
    11c4:	00 00 20 49 50 34 20 50 6f 72 74 3a 7d 7d 7d 7d     .. IP4 Port:}}}}
    11d4:	7d 20 20 20 20 20 00 00 00 24 0e 00 00 20 2d 20     }     ...$... - 
    11e4:	54 43 50 20 49 50 20 46 69 72 65 77 61 6c 6c 2d     TCP IP Firewall-
    11f4:	2d 00 00 00 00 00 00 00 20 49 50 31 3a 7d 7d 7d     -....... IP1:}}}
    1204:	2e 7d 7d 7d 2e 7d 7d 7d 2e 7d 7d 7d 00 00 00 34     .}}}.}}}.}}}...4
    1214:	0e 00 00 20 49 50 32 3a 7d 7d 7d 2e 7d 7d 7d 2e     ... IP2:}}}.}}}.
    1224:	7d 7d 7d 2e 7d 7d 7d 00 00 00 74 0e 00 00 20 49     }}}.}}}...t... I
    1234:	50 33 3a 7d 7d 7d 2e 7d 7d 7d 2e 7d 7d 7d 2e 7d     P3:}}}.}}}.}}}.}
    1244:	7d 7d 00 00 00 b4 0e 00 00 20 49 50 34 3a 7d 7d     }}....... IP4:}}
    1254:	7d 2e 7d 7d 7d 2e 7d 7d 7d 2e 7d 7d 7d 00 00 00     }.}}}.}}}.}}}...
    1264:	f4 0e 00 00 20 54 43 50 53 65 72 76 65 72 50 6f     .... TCPServerPo
    1274:	72 74 3a 7d 7d 7d 7d 7d 00 00 00 34 0f 00 00 20     rt:}}}}}...4... 
    1284:	54 69 6d 65 6f 75 74 20 54 43 50 3a 7d 7d 7d 7d     Timeout TCP:}}}}
    1294:	7d 7d 63 00 00 00 44 0f 00 00 20 2d 2d 2d 2d 2d     }}c...D... -----
    12a4:	2d 2d 20 53 4d 53 20 2d 2d 2d 2d 2d 2d 2d 00 00     -- SMS -------..
    12b4:	00 00 00 00 00 20 d0 e0 f1 f1 fb eb ea e0 20 53     ..... ........ S
    12c4:	4d 53 3a 20 20 20 7d 7d 7d 00 00 00 54 0f 00 00     MS:   }}}...T...
    12d4:	20 2d 2d 49 64 65 6e 74 69 66 69 63 61 74 69 6f      --Identificatio
    12e4:	6e 2d 2d 2d 00 00 00 00 00 00 00 20 56 65 67 61     n---....... Vega
    12f4:	20 53 2f 4e 3a 20 20 20 20 20 7d 7d 7d 7d 7d 00      S/N:     }}}}}.
    1304:	00 00 64 0f 00 00                                   ..d...

0000130a <MenuGSM>:
    130a:	74 0f 22 00 00 00 00 00 00 00 00 00 00 00 00 00     t.".............
    131a:	00 00 00 00                                         ....

0000131e <Mem_OK_Tbl>:
    131e:	f0 06 ea 06                                         ....

00001322 <F_Ok_Flash>:
    1322:	1f c9 08 1e 13 00                                   ......

00001328 <F_Ok_EEPROM>:
    1328:	1f c9 08 1e 13 01                                   ......

0000132e <Msg_EEWarning>:
    132e:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    133e:	20 20 20 20 00 00 00 20 cf e5 f0 e5 e4 20 ef f0         ... ..... ..
    134e:	ee e4 ee eb e6 e5 ed e8 e5 ec 20 00 00 00 f0 e0     .......... .....
    135e:	e1 ee f2 fb 20 ef f0 ee e2 e5 f0 fc f2 e5 20 e2     .... ......... .
    136e:	f1 e5 00 00 00 20 20 20 20 20 20 ed e0 f1 f2 f0     .....      .....
    137e:	ee e9 ea e8 20 20 20 20 20 00 00 00 00 00 00 00     ....     .......
	...

00001390 <Msg_NoBackUp>:
    1390:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    13a0:	20 20 20 20 00 00 00 d1 ee f5 f0 e0 ed b8 ed ed         ............
    13b0:	fb f5 20 ed e0 f1 f2 f0 ee e5 ea 00 00 00 20 20     .. ...........  
    13c0:	20 20 ed e5 20 ee e1 ed e0 f0 f3 e6 e5 ed ee 20       .. .......... 
    13d0:	20 20 00 00 00 20 20 20 20 20 20 20 20 20 20 20       ...           
    13e0:	20 20 20 20 20 20 20 20 20 00 00 00 00 00 00 00              .......
	...

000013f2 <Menu_ConfirmationSave_List>:
    13f2:	d1 ee f5 f0 e0 ed e8 f2 fc 20 ed e0 f1 f2 f0 ee     ......... ......
    1402:	e9 ea e8 3f 00 00 00 00 00 00 00 20 20 20 c4 e0     ...?.......   ..
    1412:	20 2d 20 ea ed ee ef ea e0 20 c2 d5 ce c4 20 00      - ...... .... .
    1422:	00 00 00 00 00 00 20 20 cd e5 f2 20 2d 20 ea ed     ......  ... - ..
    1432:	ee ef ea e0 20 c2 db d5 ce c4 00 00 00 00 00 00     .... ...........
    1442:	00 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20     .               
    1452:	20 20 20 20 20 00 00 00 00 00 00 00                      .......

0000145e <Menu_ConfirmationSave>:
    145e:	f2 13 04 03 00 00 00 00 00 00 00 00 6c 3f 00 00     ............l?..
    146e:	00 00 00 00                                         ....

00001472 <Menu_ConfirmationRest_List>:
    1472:	c2 ee f1 f2 e0 ed ee e2 2e 20 ed e0 f1 f2 f0 ee     ......... ......
    1482:	e9 ea e8 3f 00 00 00 00 00 00 00 20 20 20 c4 e0     ...?.......   ..
    1492:	20 2d 20 ea ed ee ef ea e0 20 c2 d5 ce c4 20 00      - ...... .... .
    14a2:	00 00 00 00 00 00 20 20 cd e5 f2 20 2d 20 ea ed     ......  ... - ..
    14b2:	ee ef ea e0 20 c2 db d5 ce c4 00 00 00 00 00 00     .... ...........
    14c2:	00 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20     .               
    14d2:	20 20 20 20 20 00 00 00 00 00 00 00                      .......

000014de <Menu_ConfirmationRestore>:
    14de:	72 14 04 03 00 00 00 00 00 00 00 00 61 3f 00 00     r...........a?..
    14ee:	00 00 00 00                                         ....

000014f2 <NoBackUp_Str>:
    14f2:	2d 2d 00                                            --.

000014f5 <BackUp_Tbl>:
    14f5:	f2 14                                               ..

000014f7 <Menu_BackUp_IField>:
    14f7:	05 00 00 f5 14 00 05 01 00 f5 14 00 05 02 00 f5     ................
    1507:	14 00                                               ..

00001509 <Menu_BackUp_List>:
    1509:	d3 f1 f2 ed 2f d0 e5 e7 e5 f0 e2 ed e0 ff 20 ea     ..../......... .
    1519:	ee ef e8 ff 00 00 00 00 00 00 00 20 d1 ee f5 f0     ........... ....
    1529:	e0 ed e8 f2 fc 20 20 20 20 20 20 20 20 20 20 00     .....          .
    1539:	00 00 00 00 5e 14 20 c2 ee f1 f2 e0 ed ee e2 3a     ....^. ........:
    1549:	7b 7b 2e 7b 7b 2e 32 30 7b 7b 00 f7 14 00 00 00     {{.{{.20{{......
    1559:	00 20 d1 ee f1 f2 2e 45 45 50 52 4f 4d 3a 20 7b     . .....EEPROM: {
    1569:	7b 7b 7b 7b 20 00 28 13 00 00 00 00                 {{{{ .(.....

00001575 <Menu_BackUp>:
    1575:	09 15 04 01 00 00 00 00 00 00 00 00 7b 70 00 00     ............{p..
    1585:	00 00 00 00                                         ....

00001589 <ListMem>:
    1589:	20 2d 2d 2d 2d 2d 20 4d 65 6d 6f 72 79 20 2d 2d      ----- Memory --
    1599:	2d 2d 2d 20 00 00 00 00 00 00 00 20 46 6c 61 73     --- ....... Flas
    15a9:	68 3a 20 20 7b 7b 7b 7b 7b 20 20 20 20 20 20 00     h:  {{{{{      .
    15b9:	22 13 00 00 00 00 20 45 45 50 52 4f 4d 3a 20 7b     "..... EEPROM: {
    15c9:	7b 7b 7b 7b 20 20 20 20 20 20 00 28 13 00 00 00     {{{{      .(....
    15d9:	00 20 52 65 73 65 74 20 45 45 50 52 4f 4d 20 66     . Reset EEPROM f
    15e9:	61 69 6c 20 20 00 00 00 00 00 00 00 20 42 61 63     ail  ....... Bac
    15f9:	6b 55 70 20 45 45 50 52 4f 4d 20 20 20 20 20 20     kUp EEPROM      
    1609:	00 00 00 00 00 75 15                                .....u.

00001610 <MenuMem>:
    1610:	89 15 05 01 00 00 00 00 00 00 00 00 e7 4a 00 00     .............J..
    1620:	00 00 00 00                                         ....

00001624 <MsgErr11>:
    1624:	20 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f      _______________
    1634:	5f 5f 5f 20 00 00 00 20 49 6e 74 65 72 6e 61 6c     ___ ... Internal
    1644:	20 65 72 72 6f 72 20 31 31 3a 20 00 00 00 20 20      error 11: ...  
    1654:	20 20 20 46 6c 61 73 68 20 66 61 69 6c 20 20 20        Flash fail   
    1664:	20 20 00 00 00 20 20 20 20 20 20 20 20 20 20 20       ...           
    1674:	20 20 20 20 20 20 20 20 20 00 00 00 00 00 00 00              .......
	...

00001686 <MsgErr12>:
    1686:	20 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f      _______________
    1696:	5f 5f 5f 20 00 00 00 20 49 6e 74 65 72 6e 61 6c     ___ ... Internal
    16a6:	20 65 72 72 6f 72 20 31 32 3a 20 00 00 00 20 20      error 12: ...  
    16b6:	20 20 45 45 50 52 4f 4d 20 66 61 69 6c 20 20 20       EEPROM fail   
    16c6:	20 20 00 00 00 20 20 20 20 20 20 20 20 20 20 20       ...           
    16d6:	20 20 20 20 20 20 20 20 20 00 00 00 00 00 00 00              .......
	...

000016e8 <MsgErr13>:
    16e8:	20 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f      _______________
    16f8:	5f 5f 5f 20 00 00 00 20 49 6e 74 65 72 6e 61 6c     ___ ... Internal
    1708:	20 65 72 72 6f 72 20 31 33 3a 20 00 00 00 20 54      error 13: ... T
    1718:	6f 74 61 6c 20 6d 65 6d 6f 72 79 20 66 61 69 6c     otal memory fail
    1728:	20 20 00 00 00 20 20 20 20 20 20 20 20 20 20 20       ...           
    1738:	20 20 20 20 20 20 20 20 20 00 00 00 00 00 00 00              .......
	...

0000174a <MsgErrMemo>:
    174a:	00 00 24 16 86 16 e8 16                             ..$.....

00001752 <F_ScanCycle>:
    1752:	00 64 07 00 00 00                                   .d....

00001758 <F_ScanCyclePerSec>:
    1758:	07 81 07 00 00 00                                   ......

0000175e <F_MaxScanCycle>:
    175e:	00 a9 06 00 00 00                                   ......

00001764 <ListScanCycle>:
    1764:	20 2d 2d 2d 20 53 63 61 6e 20 43 79 63 6c 65 20      --- Scan Cycle 
    1774:	2d 2d 2d 20 00 00 00 00 00 00 00 20 53 63 61 6e     --- ....... Scan
    1784:	43 79 63 6c 65 3a 20 20 20 7b 7b 7b 30 6d 73 00     Cycle:   {{{0ms.
    1794:	52 17 00 00 00 00 20 53 63 61 6e 43 79 63 6c 50     R..... ScanCyclP
    17a4:	65 72 53 65 63 3a 7b 7b 7b 7b 00 58 17 00 00 00     erSec:{{{{.X....
    17b4:	00 20 4d 61 78 53 63 61 6e 43 79 63 6c 65 3a 7b     . MaxScanCycle:{
    17c4:	7b 7b 30 6d 73 00 5e 17 00 00 00 00                 {{0ms.^.....

000017d0 <MenuScanCycle>:
    17d0:	64 17 04 01 00 00 00 00 00 00 00 00 4e 3f 00 00     d...........N?..
    17e0:	00 00 00 00                                         ....

000017e4 <F_WT>:
    17e4:	0b 1d 0c 00 00 00 04 a8 06 00 00 00                 ............

000017f0 <sec10_Str>:
    17f0:	31 30 20 f1 e5 ea 00                                10 ....

000017f7 <sec30_Str>:
    17f7:	33 30 20 f1 e5 ea 00                                30 ....

000017fe <min1_Str>:
    17fe:	31 20 ec e8 ed 20 00                                1 ... .

00001805 <min3_Str>:
    1805:	33 20 ec e8 ed 20 00                                3 ... .

0000180c <min10_Str>:
    180c:	31 30 20 ec e8 ed 00                                10 ....

00001813 <BCKLT_Tbl>:
    1813:	f0 17 f7 17 fe 17 05 18 0c 18                       ..........

0000181d <F_Backlight>:
    181d:	1e 31 01 00 00 00 00 04 00 00 00 00 00 13 18 00     .1..............

0000182d <F_IonT>:
    182d:	08 2f 01 00 00 00 00 ff 03 00 00 00 00 00 00 00     ./..............

0000183d <F_Menu_EMICounter>:
    183d:	10 f0 06 00 00 00                                   ......

00001843 <ListSyst>:
    1843:	20 2d 20 d1 eb f3 e6 e5 e1 ed ee e5 20 ec e5 ed      - ......... ...
    1853:	fe 20 2d 20 00 00 00 00 00 00 00 20 c4 e8 f1 ea     . - ....... ....
    1863:	f0 e5 f2 ed fb e5 20 e2 f5 ee e4 fb 20 20 20 00     ...... .....   .
    1873:	00 00 00 00 62 1e 20 c4 e8 f1 ea f0 e5 f2 ed fb     ....b. .........
    1883:	e5 20 e2 fb f5 ee e4 fb 20 20 00 00 00 00 00 26     . ......  .....&
    1893:	21 20 c0 ed e0 eb ee e3 ee e2 fb e5 20 e2 f5 ee     ! .......... ...
    18a3:	e4 fb 20 20 20 00 00 00 00 00 d6 21 20 c0 ed e0     ..   ......! ...
    18b3:	eb ee e3 ee e2 fb e5 20 e2 fb f5 ee e4 fb 20 20     ....... ......  
    18c3:	00 00 00 00 00 96 22 20 c0 d6 cf 20 20 20 20 20     ......" ...     
    18d3:	20 20 20 20 20 20 20 20 20 20 20 00 00 00 00 00                .....
    18e3:	59 08 20 d2 e5 f0 ec ee e4 e0 f2 f7 e8 ea e8 20     Y. ............ 
    18f3:	20 20 20 20 20 20 00 00 00 00 00 2a 29 20 4d 6f           .....*) Mo
    1903:	64 62 75 73 20 20 20 20 20 20 20 20 20 20 20 20     dbus            
    1913:	20 00 00 00 00 00 82 0b 20 cc ee e4 e5 ec 20 20      ....... .....  
    1923:	20 20 20 20 20 20 20 20 20 20 20 20 00 00 00 00                 ....
    1933:	00 0a 13 20 7b 20 7d 7d 2e 7d 7d 2e 7d 7d 20 7d     ... { }}.}}.}} }
    1943:	7d 3a 7d 7d 3a 7d 7d 00 b1 0b b7 0b 00 00 20 c0     }:}}:}}....... .
    1953:	e2 f2 ee cf e5 f0 e5 f5 cb e5 f2 ed c2 f0 3a 7d     ..............:}
    1963:	7d 7d 00 00 00 a1 0b 00 00 20 cd e0 f0 e0 e1 ee     }}....... ......
    1973:	f2 ea e0 3a 7b 7b 7b 7b 7b f7 7b 7b ec 00 e4 17     ...:{{{{{.{{....
    1983:	00 00 00 00 20 d1 ee f1 f2 ee ff ed e8 e5 20 ef     .... ......... .
    1993:	e0 ec ff f2 e8 20 20 20 00 00 00 00 00 10 16 20     .....   ....... 
    19a3:	53 63 61 6e 20 43 79 63 6c 65 3a 20 20 7b 7b 7b     Scan Cycle:  {{{
    19b3:	30 6d 73 00 52 17 00 00 d0 17 20 cf ee f0 ee e3     0ms.R..... .....
    19c3:	20 e8 ee ed ee e4 2e 3a 20 20 7d 7d 7d 7d 00 00      ......:  }}}}..
    19d3:	00 2d 18 00 00 20 cf ee e4 f1 e2 e5 f2 ea e0 c6     .-... ..........
    19e3:	ca c8 3a 7d 7d 7d 7d 7d 7d 00 00 00 1d 18 00 00     ..:}}}}}}.......
    19f3:	20 d1 f7 b8 f2 2e dd cc cd 3a 7b 7b 7b 7b 7b 7b      ........:{{{{{{
    1a03:	7b 7b 7b 7b 00 3d 18 00 00 00 00                    {{{{.=.....

00001a0e <MenuSyst>:
    1a0e:	43 18 11 01 00 00 00 00 00 00 00 00 00 00 00 00     C...............
    1a1e:	00 00 00 00                                         ....

00001a22 <MsgErr41>:
    1a22:	20 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f      _______________
    1a32:	5f 5f 5f 20 00 00 00 20 49 6e 74 65 72 6e 61 6c     ___ ... Internal
    1a42:	20 65 72 72 6f 72 20 34 31 3a 20 00 00 00 54 69      error 41: ...Ti
    1a52:	6d 65 72 20 61 6c 6c 6f 63 61 74 69 6f 6e 20 65     mer allocation e
    1a62:	72 72 00 00 00 20 20 20 20 20 20 20 20 20 20 20     rr...           
    1a72:	20 20 20 20 20 20 20 20 20 00 00 00 00 00 00 00              .......
	...

00001a84 <F_DI1>:
    1a84:	1f f6 06 0e 07 00 1f fc 06 00 07 00                 ............

00001a90 <F_DI2>:
    1a90:	1f f6 06 0e 07 01 1f fc 06 00 07 01                 ............

00001a9c <F_DI3>:
    1a9c:	1f f6 06 0e 07 02 1f fc 06 00 07 02                 ............

00001aa8 <F_DI4>:
    1aa8:	1f f6 06 0e 07 03 1f fc 06 00 07 03                 ............

00001ab4 <F_DI5>:
    1ab4:	1f f6 06 0e 07 04 1f fc 06 00 07 04                 ............

00001ac0 <F_DI6>:
    1ac0:	1f f6 06 0e 07 05 1f fc 06 00 07 05                 ............

00001acc <F_DI7>:
    1acc:	1f f6 06 0e 07 06 1f fc 06 00 07 06                 ............

00001ad8 <F_DI8>:
    1ad8:	1f f6 06 0e 07 07 1f fc 06 00 07 07                 ............

00001ae4 <F_DI9>:
    1ae4:	1f f6 06 0e 07 08 1f fc 06 00 07 08                 ............

00001af0 <F_DI10>:
    1af0:	1f f6 06 0e 07 09 1f fc 06 00 07 09                 ............

00001afc <F_DI11>:
    1afc:	1f f6 06 0e 07 0a 1f fc 06 00 07 0a                 ............

00001b08 <F_DI12>:
    1b08:	1f f6 06 0e 07 0b 1f fc 06 00 07 0b                 ............

00001b14 <F_DI13>:
    1b14:	1f f6 06 0e 07 0c 1f fc 06 00 07 0c                 ............

00001b20 <F_DI14>:
    1b20:	1f f6 06 0e 07 0d 1f fc 06 00 07 0d                 ............

00001b2c <F_DI15>:
    1b2c:	1f f6 06 0e 07 0e 1f fc 06 00 07 0e                 ............

00001b38 <F_DI16>:
    1b38:	1f f6 06 0e 07 0f 1f fc 06 00 07 0f                 ............

00001b44 <F_DI17>:
    1b44:	1f f6 06 0e 07 10 1f fc 06 00 07 10                 ............

00001b50 <F_DI18>:
    1b50:	1f f6 06 0e 07 11 1f fc 06 00 07 11                 ............

00001b5c <F_DII1>:
    1b5c:	20 14 01 00 00 00 00 00 00 00 00 00 00 1c 07 00      ...............

00001b6c <F_DII2>:
    1b6c:	20 14 01 00 00 00 00 00 00 00 00 00 00 1c 07 01      ...............

00001b7c <F_DII3>:
    1b7c:	20 14 01 00 00 00 00 00 00 00 00 00 00 1c 07 02      ...............

00001b8c <F_DII4>:
    1b8c:	20 14 01 00 00 00 00 00 00 00 00 00 00 1c 07 03      ...............

00001b9c <F_DII5>:
    1b9c:	20 14 01 00 00 00 00 00 00 00 00 00 00 1c 07 04      ...............

00001bac <F_DII6>:
    1bac:	20 14 01 00 00 00 00 00 00 00 00 00 00 1c 07 05      ...............

00001bbc <F_DII7>:
    1bbc:	20 14 01 00 00 00 00 00 00 00 00 00 00 1c 07 06      ...............

00001bcc <F_DII8>:
    1bcc:	20 14 01 00 00 00 00 00 00 00 00 00 00 1c 07 07      ...............

00001bdc <F_DII9>:
    1bdc:	20 14 01 00 00 00 00 00 00 00 00 00 00 1c 07 08      ...............

00001bec <F_DII10>:
    1bec:	20 14 01 00 00 00 00 00 00 00 00 00 00 1c 07 09      ...............

00001bfc <F_DII11>:
    1bfc:	20 14 01 00 00 00 00 00 00 00 00 00 00 1c 07 0a      ...............

00001c0c <F_DII12>:
    1c0c:	20 14 01 00 00 00 00 00 00 00 00 00 00 1c 07 0b      ...............

00001c1c <F_DII13>:
    1c1c:	20 14 01 00 00 00 00 00 00 00 00 00 00 1c 07 0c      ...............

00001c2c <F_DII14>:
    1c2c:	20 14 01 00 00 00 00 00 00 00 00 00 00 1c 07 0d      ...............

00001c3c <F_DII15>:
    1c3c:	20 14 01 00 00 00 00 00 00 00 00 00 00 1c 07 0e      ...............

00001c4c <F_DII16>:
    1c4c:	20 14 01 00 00 00 00 00 00 00 00 00 00 1c 07 0f      ...............

00001c5c <F_DII17>:
    1c5c:	20 14 01 00 00 00 00 00 00 00 00 00 00 1c 07 10      ...............

00001c6c <F_DII18>:
    1c6c:	20 14 01 00 00 00 00 00 00 00 00 00 00 1c 07 11      ...............

00001c7c <ListDI>:
    1c7c:	20 4e 31 3a 20 20 7b 7b 7b 7b 20 7d 7d 7d 7d 20      N1:  {{{{ }}}} 
    1c8c:	7b 7b 7b 7b 00 84 1a 5c 1b 00 00 20 4e 32 3a 20     {{{{...\... N2: 
    1c9c:	20 7b 7b 7b 7b 20 7d 7d 7d 7d 20 7b 7b 7b 7b 00      {{{{ }}}} {{{{.
    1cac:	90 1a 6c 1b 00 00 20 4e 33 3a 20 20 7b 7b 7b 7b     ..l... N3:  {{{{
    1cbc:	20 7d 7d 7d 7d 20 7b 7b 7b 7b 00 9c 1a 7c 1b 00      }}}} {{{{...|..
    1ccc:	00 20 4e 34 3a 20 20 7b 7b 7b 7b 20 7d 7d 7d 7d     . N4:  {{{{ }}}}
    1cdc:	20 7b 7b 7b 7b 00 a8 1a 8c 1b 00 00 20 4e 35 3a      {{{{....... N5:
    1cec:	20 20 7b 7b 7b 7b 20 7d 7d 7d 7d 20 7b 7b 7b 7b       {{{{ }}}} {{{{
    1cfc:	00 b4 1a 9c 1b 00 00 20 4e 36 3a 20 20 7b 7b 7b     ....... N6:  {{{
    1d0c:	7b 20 7d 7d 7d 7d 20 7b 7b 7b 7b 00 c0 1a ac 1b     { }}}} {{{{.....
    1d1c:	00 00 20 4e 37 3a 20 20 7b 7b 7b 7b 20 7d 7d 7d     .. N7:  {{{{ }}}
    1d2c:	7d 20 7b 7b 7b 7b 00 cc 1a bc 1b 00 00 20 4e 38     } {{{{....... N8
    1d3c:	3a 20 20 7b 7b 7b 7b 20 7d 7d 7d 7d 20 7b 7b 7b     :  {{{{ }}}} {{{
    1d4c:	7b 00 d8 1a cc 1b 00 00 20 4e 39 3a 20 20 7b 7b     {....... N9:  {{
    1d5c:	7b 7b 20 7d 7d 7d 7d 20 7b 7b 7b 7b 00 e4 1a dc     {{ }}}} {{{{....
    1d6c:	1b 00 00 20 4e 31 30 3a 20 7b 7b 7b 7b 20 7d 7d     ... N10: {{{{ }}
    1d7c:	7d 7d 20 7b 7b 7b 7b 00 f0 1a ec 1b 00 00 20 4e     }} {{{{....... N
    1d8c:	31 31 3a 20 7b 7b 7b 7b 20 7d 7d 7d 7d 20 7b 7b     11: {{{{ }}}} {{
    1d9c:	7b 7b 00 fc 1a fc 1b 00 00 20 4e 31 32 3a 20 7b     {{....... N12: {
    1dac:	7b 7b 7b 20 7d 7d 7d 7d 20 7b 7b 7b 7b 00 08 1b     {{{ }}}} {{{{...
    1dbc:	0c 1c 00 00 20 4e 31 33 3a 20 7b 7b 7b 7b 20 7d     .... N13: {{{{ }
    1dcc:	7d 7d 7d 20 7b 7b 7b 7b 00 14 1b 1c 1c 00 00 20     }}} {{{{....... 
    1ddc:	4e 31 34 3a 20 7b 7b 7b 7b 20 7d 7d 7d 7d 20 7b     N14: {{{{ }}}} {
    1dec:	7b 7b 7b 00 20 1b 2c 1c 00 00 20 4e 31 35 3a 20     {{{. .,... N15: 
    1dfc:	7b 7b 7b 7b 20 7d 7d 7d 7d 20 7b 7b 7b 7b 00 2c     {{{{ }}}} {{{{.,
    1e0c:	1b 3c 1c 00 00 20 4e 31 36 3a 20 7b 7b 7b 7b 20     .<... N16: {{{{ 
    1e1c:	7d 7d 7d 7d 20 7b 7b 7b 7b 00 38 1b 4c 1c 00 00     }}}} {{{{.8.L...
    1e2c:	20 4e 31 37 3a 20 7b 7b 7b 7b 20 7d 7d 7d 7d 20      N17: {{{{ }}}} 
    1e3c:	7b 7b 7b 7b 00 44 1b 5c 1c 00 00 20 4e 31 38 3a     {{{{.D.\... N18:
    1e4c:	20 7b 7b 7b 7b 20 7d 7d 7d 7d 20 7b 7b 7b 7b 00      {{{{ }}}} {{{{.
    1e5c:	50 1b 6c 1c 00 00                                   P.l...

00001e62 <MenuDI>:
    1e62:	7c 1c 12 00 00 00 00 00 00 00 00 00 00 00 00 00     |...............
    1e72:	00 00 00 00                                         ....

00001e76 <F_DO1>:
    1e76:	1f 91 07 00 00 00 00 00 00 00 00 00 00 2a 07 00     .............*..

00001e86 <F_DO2>:
    1e86:	1f 91 07 00 00 00 00 00 00 00 00 00 00 2a 07 01     .............*..

00001e96 <F_DO3>:
    1e96:	1f 91 07 00 00 00 00 00 00 00 00 00 00 2a 07 02     .............*..

00001ea6 <F_DO4>:
    1ea6:	1f 91 07 00 00 00 00 00 00 00 00 00 00 2a 07 03     .............*..

00001eb6 <F_DO5>:
    1eb6:	1f 91 07 00 00 00 00 00 00 00 00 00 00 2a 07 04     .............*..

00001ec6 <F_DO6>:
    1ec6:	1f 91 07 00 00 00 00 00 00 00 00 00 00 2a 07 05     .............*..

00001ed6 <F_DO7>:
    1ed6:	1f 91 07 00 00 00 00 00 00 00 00 00 00 2a 07 06     .............*..

00001ee6 <F_DO8>:
    1ee6:	1f 91 07 00 00 00 00 00 00 00 00 00 00 2a 07 07     .............*..

00001ef6 <F_DO9>:
    1ef6:	1f 91 07 00 00 00 00 00 00 00 00 00 00 2a 07 08     .............*..

00001f06 <F_DO10>:
    1f06:	1f 91 07 00 00 00 00 00 00 00 00 00 00 2a 07 09     .............*..

00001f16 <F_DO11>:
    1f16:	1f 91 07 00 00 00 00 00 00 00 00 00 00 2a 07 0a     .............*..

00001f26 <F_DO12>:
    1f26:	1f 91 07 00 00 00 00 00 00 00 00 00 00 2a 07 0b     .............*..

00001f36 <F_DO13>:
    1f36:	1f 91 07 00 00 00 00 00 00 00 00 00 00 2a 07 0c     .............*..

00001f46 <F_DO14>:
    1f46:	1f 91 07 00 00 00 00 00 00 00 00 00 00 2a 07 0d     .............*..

00001f56 <F_DO15>:
    1f56:	1f 91 07 00 00 00 00 00 00 00 00 00 00 2a 07 0e     .............*..

00001f66 <F_DO16>:
    1f66:	1f 91 07 00 00 00 00 00 00 00 00 00 00 2a 07 0f     .............*..

00001f76 <ListDO>:
    1f76:	20 c2 fb f5 ee e4 20 4e 31 3a 20 20 20 20 20 7d      ..... N1:     }
    1f86:	7d 7d 7d 20 00 00 00 76 1e 00 00 20 c2 fb f5 ee     }}} ...v... ....
    1f96:	e4 20 4e 32 3a 20 20 20 20 20 7d 7d 7d 7d 20 00     . N2:     }}}} .
    1fa6:	00 00 86 1e 00 00 20 c2 fb f5 ee e4 20 4e 33 3a     ...... ..... N3:
    1fb6:	20 20 20 20 20 7d 7d 7d 7d 20 00 00 00 96 1e 00          }}}} ......
    1fc6:	00 20 c2 fb f5 ee e4 20 4e 34 3a 20 20 20 20 20     . ..... N4:     
    1fd6:	7d 7d 7d 7d 20 00 00 00 a6 1e 00 00 20 c2 fb f5     }}}} ....... ...
    1fe6:	ee e4 20 4e 35 3a 20 20 20 20 20 7d 7d 7d 7d 20     .. N5:     }}}} 
    1ff6:	00 00 00 b6 1e 00 00 20 c2 fb f5 ee e4 20 4e 36     ....... ..... N6
    2006:	3a 20 20 20 20 20 7d 7d 7d 7d 20 00 00 00 c6 1e     :     }}}} .....
    2016:	00 00 20 c2 fb f5 ee e4 20 4e 37 3a 20 20 20 20     .. ..... N7:    
    2026:	20 7d 7d 7d 7d 20 00 00 00 d6 1e 00 00 20 c2 fb      }}}} ....... ..
    2036:	f5 ee e4 20 4e 38 3a 20 20 20 20 20 7d 7d 7d 7d     ... N8:     }}}}
    2046:	20 00 00 00 e6 1e 00 00 20 c2 fb f5 ee e4 20 4e      ....... ..... N
    2056:	39 3a 20 20 20 20 20 7d 7d 7d 7d 20 00 00 00 f6     9:     }}}} ....
    2066:	1e 00 00 20 c2 fb f5 ee e4 20 4e 31 30 3a 20 20     ... ..... N10:  
    2076:	20 20 7d 7d 7d 7d 20 00 00 00 06 1f 00 00 20 c2       }}}} ....... .
    2086:	fb f5 ee e4 20 4e 31 31 3a 20 20 20 20 7d 7d 7d     .... N11:    }}}
    2096:	7d 20 00 00 00 16 1f 00 00 20 c2 fb f5 ee e4 20     } ....... ..... 
    20a6:	4e 31 32 3a 20 20 20 20 7d 7d 7d 7d 20 00 00 00     N12:    }}}} ...
    20b6:	26 1f 00 00 20 c2 fb f5 ee e4 20 4e 31 33 3a 20     &... ..... N13: 
    20c6:	20 20 20 7d 7d 7d 7d 20 00 00 00 36 1f 00 00 20        }}}} ...6... 
    20d6:	c2 fb f5 ee e4 20 4e 31 34 3a 20 20 20 20 7d 7d     ..... N14:    }}
    20e6:	7d 7d 20 00 00 00 46 1f 00 00 20 c2 fb f5 ee e4     }} ...F... .....
    20f6:	20 4e 31 35 3a 20 20 20 20 7d 7d 7d 7d 20 00 00      N15:    }}}} ..
    2106:	00 56 1f 00 00 20 c2 fb f5 ee e4 20 4e 31 36 3a     .V... ..... N16:
    2116:	20 20 20 20 7d 7d 7d 7d 20 00 00 00 66 1f 00 00         }}}} ...f...

00002126 <MenuDO>:
    2126:	76 1f 10 00 00 00 00 00 00 00 00 00 00 00 00 00     v...............
    2136:	00 00 00 00                                         ....

0000213a <F_AI12>:
    213a:	0b 00 0b 00 00 00 0b 02 0b 00 00 00                 ............

00002146 <F_AI34>:
    2146:	0b 04 0b 00 00 00 0b 06 0b 00 00 00                 ............

00002152 <F_AI56>:
    2152:	0b 08 0b 00 00 00 0b 0a 0b 00 00 00                 ............

0000215e <F_AI78>:
    215e:	0b 0c 0b 00 00 00 0b 0e 0b 00 00 00                 ............

0000216a <ListAI>:
    216a:	20 4e 31 3a 20 7b 7b 7b 7b 7b 20 4e 32 3a 20 7b      N1: {{{{{ N2: {
    217a:	7b 7b 7b 7b 00 3a 21 00 00 00 00 20 4e 33 3a 20     {{{{.:!.... N3: 
    218a:	7b 7b 7b 7b 7b 20 4e 34 3a 20 7b 7b 7b 7b 7b 00     {{{{{ N4: {{{{{.
    219a:	46 21 00 00 00 00 20 4e 35 3a 20 7b 7b 7b 7b 7b     F!.... N5: {{{{{
    21aa:	20 4e 36 3a 20 7b 7b 7b 7b 7b 00 52 21 00 00 00      N6: {{{{{.R!...
    21ba:	00 20 4e 37 3a 20 7b 7b 7b 7b 7b 20 4e 38 3a 20     . N7: {{{{{ N8: 
    21ca:	7b 7b 7b 7b 7b 00 5e 21 00 00 00 00                 {{{{{.^!....

000021d6 <MenuAI>:
    21d6:	6a 21 04 03 00 00 00 00 00 00 00 00 00 00 00 00     j!..............
    21e6:	00 00 00 00                                         ....

000021ea <F_AO1>:
    21ea:	0e 85 07 00 00 00 00 ff 03 00 00 00 00 00 00 00     ................

000021fa <F_AO2>:
    21fa:	0e 87 07 00 00 00 00 ff 03 00 00 00 00 00 00 00     ................

0000220a <F_AO3>:
    220a:	0e 89 07 00 00 00 00 ff 03 00 00 00 00 00 00 00     ................

0000221a <F_AO4>:
    221a:	0e 8b 07 00 00 00 00 ff 03 00 00 00 00 00 00 00     ................

0000222a <ListAO>:
    222a:	20 c2 fb f5 ee e4 20 4e 31 3a 20 20 20 20 20 7d      ..... N1:     }
    223a:	7d 7d 7d 7d 00 00 00 ea 21 00 00 20 c2 fb f5 ee     }}}}....!.. ....
    224a:	e4 20 4e 32 3a 20 20 20 20 20 7d 7d 7d 7d 7d 00     . N2:     }}}}}.
    225a:	00 00 fa 21 00 00 20 c2 fb f5 ee e4 20 4e 33 3a     ...!.. ..... N3:
    226a:	20 20 20 20 20 7d 7d 7d 7d 7d 00 00 00 0a 22 00          }}}}}....".
    227a:	00 20 c2 fb f5 ee e4 20 4e 34 3a 20 20 20 20 20     . ..... N4:     
    228a:	7d 7d 7d 7d 7d 00 00 00 1a 22 00 00                 }}}}}...."..

00002296 <MenuAO>:
    2296:	2a 22 04 00 00 00 00 00 00 00 00 00 00 00 00 00     *"..............
    22a6:	00 00 00 00                                         ....

000022aa <F_ADC12>:
    22aa:	07 cd 08 00 00 00 07 cf 08 00 00 00                 ............

000022b6 <F_ADC34>:
    22b6:	07 d1 08 00 00 00 07 d3 08 00 00 00                 ............

000022c2 <F_ADC56>:
    22c2:	07 d5 08 00 00 00 07 d7 08 00 00 00                 ............

000022ce <F_ADC_Ref>:
    22ce:	07 d9 08 00 00 00                                   ......

000022d4 <List_ADC_Chan>:
    22d4:	20 2d 2d 2d 20 ca e0 ed e0 eb fb 20 c0 d6 cf 20      --- ...... ... 
    22e4:	2d 2d 2d 20 00 00 00 00 00 00 00 20 4e 31 3a 20     --- ....... N1: 
    22f4:	7b 7b 7b 7b 7b 20 4e 32 3a 20 7b 7b 7b 7b 7b 00     {{{{{ N2: {{{{{.
    2304:	aa 22 00 00 00 00 20 4e 33 3a 20 7b 7b 7b 7b 7b     .".... N3: {{{{{
    2314:	20 4e 34 3a 20 7b 7b 7b 7b 7b 00 b6 22 00 00 00      N4: {{{{{.."...
    2324:	00 20 4e 35 3a 20 7b 7b 7b 7b 7b 20 4e 36 3a 20     . N5: {{{{{ N6: 
    2334:	7b 7b 7b 7b 7b 00 c2 22 00 00 00 00 20 ce ef ee     {{{{{..".... ...
    2344:	f0 ed 2e 20 ea e0 ed e0 eb 3a 20 7b 7b 7b 7b 7b     ... .....: {{{{{
    2354:	00 ce 22 00 00 00 00                                .."....

0000235b <Menu_ADC_Ch>:
    235b:	d4 22 05 01 00 00 00 00 00 00 00 00 00 00 00 00     ."..............
    236b:	00 00 00 00                                         ....

0000236f <F_ADC_Zero>:
    236f:	00 21 0c 00 00 00 04 20 0c 00 00 00 04 1f 0c 00     .!..... ........
	...

00002381 <F_ADC_Full>:
    2381:	00 24 0c 00 00 00 04 23 0c 00 00 00 04 22 0c 00     .$.....#....."..
	...

00002393 <List_ADC_Cali>:
    2393:	20 2d 2d 2d 20 ca e0 eb e8 e1 f0 ee e2 ea e0 20      --- .......... 
    23a3:	2d 2d 2d 20 00 00 00 00 00 00 00 20 5a 65 72 6f     --- ....... Zero
    23b3:	3a 20 20 7b 7b 7b 20 7b 7b 7b 20 7b 7b 7b 20 00     :  {{{ {{{ {{{ .
    23c3:	6f 23 00 00 00 00 20 46 75 6c 6c 3a 20 20 7b 7b     o#.... Full:  {{
    23d3:	7b 20 7b 7b 7b 20 7b 7b 7b 20 00 81 23 00 00 00     { {{{ {{{ ..#...
    23e3:	00 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20     .               
    23f3:	20 20 20 20 20 00 00 00 00 00 00 00                      .......

000023ff <Menu_ADC_Cali>:
    23ff:	93 23 04 03 00 00 00 00 00 00 00 00 00 00 00 00     .#..............
    240f:	00 00 00 00                                         ....

00002413 <ADC_Rt_Str>:
    2413:	52 65 73 65 74 00                                   Reset.

00002419 <ADC_I1_Str>:
    2419:	49 6e 69 74 69 61 6c 69 73 61 74 00                 Initialisat.

00002425 <ADC_C1_Str>:
    2425:	43 61 6c 69 62 72 61 74 69 6f 6e 00                 Calibration.

00002431 <ADC_Re_Str>:
    2431:	52 65 61 64 00                                      Read.

00002436 <ADC_Of_Str>:
    2436:	4f 66 66 00                                         Off.

0000243a <ADC_Tbl>:
    243a:	13 24 19 24 25 24 31 24 36 24                       .$.$%$1$6$

00002444 <F_Therm1>:
    2444:	09 3d 06 df 08 01                                   .=....

0000244a <F_Therm2>:
    244a:	09 3f 06 df 08 01                                   .?....

00002450 <F_Therm3>:
    2450:	09 41 06 df 08 01                                   .A....

00002456 <F_Therm4>:
    2456:	09 43 06 df 08 01                                   .C....

0000245c <F_Therm5>:
    245c:	09 45 06 df 08 01                                   .E....

00002462 <F_Therm6>:
    2462:	09 47 06 df 08 01                                   .G....

00002468 <F_Thermis1>:
    2468:	1e 17 01 00 00 00 00 07 00 00 00 00 00 13 09 00     ................

00002478 <F_Thermis2>:
    2478:	1e 18 01 00 00 00 00 07 00 00 00 00 00 13 09 00     ................

00002488 <F_Thermis3>:
    2488:	1e 19 01 00 00 00 00 07 00 00 00 00 00 13 09 00     ................

00002498 <F_Thermis4>:
    2498:	1e 1a 01 00 00 00 00 07 00 00 00 00 00 13 09 00     ................

000024a8 <F_Thermis5>:
    24a8:	1e 1b 01 00 00 00 00 07 00 00 00 00 00 13 09 00     ................

000024b8 <F_Thermis6>:
    24b8:	1e 1c 01 00 00 00 00 07 00 00 00 00 00 13 09 00     ................

000024c8 <F_ThermisD1>:
    24c8:	03 1d 01 80 ff ff ff 7f 00 00 00 00 00 00 00 01     ................

000024d8 <F_ThermisD2>:
    24d8:	03 20 01 80 ff ff ff 7f 00 00 00 00 00 00 00 01     . ..............

000024e8 <F_ThermisD3>:
    24e8:	03 23 01 80 ff ff ff 7f 00 00 00 00 00 00 00 01     .#..............

000024f8 <F_ThermisD4>:
    24f8:	03 26 01 80 ff ff ff 7f 00 00 00 00 00 00 00 01     .&..............

00002508 <F_ThermisD5>:
    2508:	03 29 01 80 ff ff ff 7f 00 00 00 00 00 00 00 01     .)..............

00002518 <F_ThermisD6>:
    2518:	03 2c 01 80 ff ff ff 7f 00 00 00 00 00 00 00 01     .,..............

00002528 <F_ThermisA1>:
    2528:	08 1e 01 84 03 00 00 4c 04 00 00 00 00 00 00 03     .......L........

00002538 <F_ThermisA2>:
    2538:	08 21 01 84 03 00 00 4c 04 00 00 00 00 00 00 03     .!.....L........

00002548 <F_ThermisA3>:
    2548:	08 24 01 84 03 00 00 4c 04 00 00 00 00 00 00 03     .$.....L........

00002558 <F_ThermisA4>:
    2558:	08 27 01 84 03 00 00 4c 04 00 00 00 00 00 00 03     .'.....L........

00002568 <F_ThermisA5>:
    2568:	08 2a 01 84 03 00 00 4c 04 00 00 00 00 00 00 03     .*.....L........

00002578 <F_ThermisA6>:
    2578:	08 2d 01 84 03 00 00 4c 04 00 00 00 00 00 00 03     .-.....L........

00002588 <ListTherm1>:
    2588:	20 ca e0 ed e0 eb 20 4e 31 3a 20 7b 7b 7b 7b 7b      ..... N1: {{{{{
    2598:	7b 7b 7c 43 00 44 24 00 00 00 00 20 d2 e5 f0 ec     {{|C.D$.... ....
    25a8:	ee e4 e0 f2 f7 e8 ea 3a 20 7d 7d 7d 7d 7d 7d 00     .......: }}}}}}.
    25b8:	00 00 68 24 00 00 20 d1 e4 e2 e8 e3 3a 20 20 20     ..h$.. .....:   
    25c8:	20 20 20 7d 7d 7d 7d 7d 7c 43 00 00 00 c8 24 00        }}}}}|C....$.
    25d8:	00 20 ca ee fd f4 f4 e8 f6 e8 e5 ed f2 3a 20 20     . ...........:  
    25e8:	7d 7d 7d 7d 7d 00 00 00 28 25 00 00                 }}}}}...(%..

000025f4 <MenuTherm1>:
    25f4:	88 25 04 01 00 00 00 00 00 00 00 00 00 00 00 00     .%..............
    2604:	00 00 00 00                                         ....

00002608 <ListTherm2>:
    2608:	20 ca e0 ed e0 eb 20 4e 32 3a 20 7b 7b 7b 7b 7b      ..... N2: {{{{{
    2618:	7b 7b 7c 43 00 4a 24 00 00 00 00 20 d2 e5 f0 ec     {{|C.J$.... ....
    2628:	ee e4 e0 f2 f7 e8 ea 3a 20 7d 7d 7d 7d 7d 7d 00     .......: }}}}}}.
    2638:	00 00 78 24 00 00 20 d1 e4 e2 e8 e3 3a 20 20 20     ..x$.. .....:   
    2648:	20 20 20 7d 7d 7d 7d 7d 7c 43 00 00 00 d8 24 00        }}}}}|C....$.
    2658:	00 20 ca ee fd f4 f4 e8 f6 e8 e5 ed f2 3a 20 20     . ...........:  
    2668:	7d 7d 7d 7d 7d 00 00 00 38 25 00 00                 }}}}}...8%..

00002674 <MenuTherm2>:
    2674:	08 26 04 01 00 00 00 00 00 00 00 00 00 00 00 00     .&..............
    2684:	00 00 00 00                                         ....

00002688 <ListTherm3>:
    2688:	20 ca e0 ed e0 eb 20 4e 33 3a 20 7b 7b 7b 7b 7b      ..... N3: {{{{{
    2698:	7b 7b 7c 43 00 50 24 00 00 00 00 20 d2 e5 f0 ec     {{|C.P$.... ....
    26a8:	ee e4 e0 f2 f7 e8 ea 3a 20 7d 7d 7d 7d 7d 7d 00     .......: }}}}}}.
    26b8:	00 00 88 24 00 00 20 d1 e4 e2 e8 e3 3a 20 20 20     ...$.. .....:   
    26c8:	20 20 20 7d 7d 7d 7d 7d 7c 43 00 00 00 e8 24 00        }}}}}|C....$.
    26d8:	00 20 ca ee fd f4 f4 e8 f6 e8 e5 ed f2 3a 20 20     . ...........:  
    26e8:	7d 7d 7d 7d 7d 00 00 00 48 25 00 00                 }}}}}...H%..

000026f4 <MenuTherm3>:
    26f4:	88 26 04 01 00 00 00 00 00 00 00 00 00 00 00 00     .&..............
    2704:	00 00 00 00                                         ....

00002708 <ListTherm4>:
    2708:	20 ca e0 ed e0 eb 20 4e 34 3a 20 7b 7b 7b 7b 7b      ..... N4: {{{{{
    2718:	7b 7b 7c 43 00 56 24 00 00 00 00 20 d2 e5 f0 ec     {{|C.V$.... ....
    2728:	ee e4 e0 f2 f7 e8 ea 3a 20 7d 7d 7d 7d 7d 7d 00     .......: }}}}}}.
    2738:	00 00 98 24 00 00 20 d1 e4 e2 e8 e3 3a 20 20 20     ...$.. .....:   
    2748:	20 20 20 7d 7d 7d 7d 7d 7c 43 00 00 00 f8 24 00        }}}}}|C....$.
    2758:	00 20 ca ee fd f4 f4 e8 f6 e8 e5 ed f2 3a 20 20     . ...........:  
    2768:	7d 7d 7d 7d 7d 00 00 00 58 25 00 00                 }}}}}...X%..

00002774 <MenuTherm4>:
    2774:	08 27 04 01 00 00 00 00 00 00 00 00 00 00 00 00     .'..............
    2784:	00 00 00 00                                         ....

00002788 <ListTherm5>:
    2788:	20 ca e0 ed e0 eb 20 4e 35 3a 20 7b 7b 7b 7b 7b      ..... N5: {{{{{
    2798:	7b 7b 7c 43 00 5c 24 00 00 00 00 20 d2 e5 f0 ec     {{|C.\$.... ....
    27a8:	ee e4 e0 f2 f7 e8 ea 3a 20 7d 7d 7d 7d 7d 7d 00     .......: }}}}}}.
    27b8:	00 00 a8 24 00 00 20 d1 e4 e2 e8 e3 3a 20 20 20     ...$.. .....:   
    27c8:	20 20 20 7d 7d 7d 7d 7d 7c 43 00 00 00 08 25 00        }}}}}|C....%.
    27d8:	00 20 ca ee fd f4 f4 e8 f6 e8 e5 ed f2 3a 20 20     . ...........:  
    27e8:	7d 7d 7d 7d 7d 00 00 00 68 25 00 00                 }}}}}...h%..

000027f4 <MenuTherm5>:
    27f4:	88 27 04 01 00 00 00 00 00 00 00 00 00 00 00 00     .'..............
    2804:	00 00 00 00                                         ....

00002808 <ListTherm6>:
    2808:	20 ca e0 ed e0 eb 20 4e 36 3a 20 7b 7b 7b 7b 7b      ..... N6: {{{{{
    2818:	7b 7b 7c 43 00 62 24 00 00 00 00 20 d2 e5 f0 ec     {{|C.b$.... ....
    2828:	ee e4 e0 f2 f7 e8 ea 3a 20 7d 7d 7d 7d 7d 7d 00     .......: }}}}}}.
    2838:	00 00 b8 24 00 00 20 d1 e4 e2 e8 e3 3a 20 20 20     ...$.. .....:   
    2848:	20 20 20 7d 7d 7d 7d 7d 7c 43 00 00 00 18 25 00        }}}}}|C....%.
    2858:	00 20 ca ee fd f4 f4 e8 f6 e8 e5 ed f2 3a 20 20     . ...........:  
    2868:	7d 7d 7d 7d 7d 00 00 00 78 25 00 00                 }}}}}...x%..

00002874 <MenuTherm6>:
    2874:	08 28 04 01 00 00 00 00 00 00 00 00 00 00 00 00     .(..............
    2884:	00 00 00 00                                         ....

00002888 <List_Therm>:
    2888:	20 ca e0 ed e0 eb 20 4e 31 3a 20 7b 7b 7b 7b 7b      ..... N1: {{{{{
    2898:	7b 7b 7c 43 00 44 24 00 00 f4 25 20 ca e0 ed e0     {{|C.D$...% ....
    28a8:	eb 20 4e 32 3a 20 7b 7b 7b 7b 7b 7b 7b 7c 43 00     . N2: {{{{{{{|C.
    28b8:	4a 24 00 00 74 26 20 ca e0 ed e0 eb 20 4e 33 3a     J$..t& ..... N3:
    28c8:	20 7b 7b 7b 7b 7b 7b 7b 7c 43 00 50 24 00 00 f4      {{{{{{{|C.P$...
    28d8:	26 20 ca e0 ed e0 eb 20 4e 34 3a 20 7b 7b 7b 7b     & ..... N4: {{{{
    28e8:	7b 7b 7b 7c 43 00 56 24 00 00 74 27 20 ca e0 ed     {{{|C.V$..t' ...
    28f8:	e0 eb 20 4e 35 3a 20 7b 7b 7b 7b 7b 7b 7b 7c 43     .. N5: {{{{{{{|C
    2908:	00 5c 24 00 00 f4 27 20 ca e0 ed e0 eb 20 4e 36     .\$...' ..... N6
    2918:	3a 20 7b 7b 7b 7b 7b 7b 7b 7c 43 00 62 24 00 00     : {{{{{{{|C.b$..
    2928:	74 28                                               t(

0000292a <MenuTherm>:
    292a:	88 28 06 00 00 00 00 00 00 00 00 00 00 00 00 00     .(..............
    293a:	00 00 00 00                                         ....

0000293e <MB_Master_List>:
    293e:	00 00 00                                            ...

00002941 <MenuModem>:
    2941:	74 0f 22 00 a6 29 00 00 00 00 00 00 00 00 00 00     t."..)..........
    2951:	00 00 00 00                                         ....

00002955 <Menu0List>:
    2955:	20 2d 47 53 4d 2d f1 e8 e3 ed e0 eb e8 e7 e0 f2      -GSM-..........
    2965:	ee f0 2d 20 00 00 00 00 00 a6 29 20 d1 eb f3 e6     ..- ......) ....
    2975:	e5 e1 ed ee e5 20 20 20 20 20 20 20 20 20 20 00     .....          .
    2985:	00 00 00 00 0e 1a 20 cc ee e4 e5 ec 20 20 20 20     ...... .....    
    2995:	20 20 20 20 20 20 20 20 20 20 00 00 00 00 00 41               .....A
    29a5:	29                                                  )

000029a6 <Menu0>:
    29a6:	55 29 03 00 a6 29 00 00 00 00 00 00 00 00 00 00     U)...)..........
    29b6:	00 00 00 00                                         ....

000029ba <KeyAct.9284>:
    29ba:	00 00 58 3f 60 3f 14 56 6c 51 be 59 63 59           ..X?`?.VlQ.YcY

000029c8 <MaxThermType>:
    29c8:	07 02                                               ..

000029ca <TerLimType>:
    29ca:	b6 06 d6 06                                         ....

000029ce <TSM100Tbl>:
    29ce:	00 00 e1 f6 91 08 30 f8 0e 28 18 fc a2 37 0c fe     ......0..(...7..
    29de:	ea 46 00 00 49 65 e8 03 a6 83 d0 07 ff ff f4 17     .F..Ie..........

000029ee <TSM50Tbl>:
    29ee:	00 00 df f6 46 04 30 f8 13 0c 24 fa fe 13 18 fc     ....F.0...$.....
    29fe:	c6 1b 0c fe 6b 23 00 00 03 2b f4 01 9a 32 e8 03     ....k#...+...2..
    2a0e:	30 3a dc 05 c9 41 d0 07 ff ff bd 38                 0:...A.....8

00002a1a <TSP100Tbl>:
    2a1a:	00 00 f6 f5 c2 38 0c fe e2 46 00 00 b6 62 e8 03     .....8...F...b..
    2a2a:	96 7d d0 07 ae 97 b8 0b ea b0 a0 0f 54 c9 88 13     .}..........T...
    2a3a:	e2 e0 70 17 ff ff 97 1e                             ..p.....

00002a42 <TSP50Tbl>:
    2a42:	00 00 1f f6 5f 1c 0c fe 56 31 e8 03 d0 3e d0 07     ...._...V1...>..
    2a52:	d2 4b b8 0b 70 58 a0 0f aa 64 88 13 6c 70 70 17     .K..pX...d..lpp.
    2a62:	ff ff 0e 47                                         ...G

00002a66 <Pt100Tbl>:
    2a66:	00 00 20 f6 fe 38 0c fe 48 62 e8 03 c4 7c d0 07     .. ..8..Hb...|..
    2a76:	6e 96 b8 0b 50 af a0 0f 56 c7 88 13 94 de 70 17     n...P...V.....p.
    2a86:	f6 f4 58 1b ff ff 8b 1f                             ..X.....

00002a8e <Gr21Tbl>:
    2a8e:	00 00 1e f6 1c 1a 0c fe 64 2d e8 03 c6 39 d0 07     ........d-...9..
    2a9e:	c4 45 b8 0b 68 51 a0 0f 9e 5c 88 13 7a 67 70 17     .E..hQ...\..zgp.
    2aae:	ff ff ce 4f                                         ...O

00002ab2 <Gr23Tbl>:
    2ab2:	00 00 d5 f6 7d 1d 0c fe 8b 25 00 00 8f 2d f4 01     ....}....%...-..
    2ac2:	92 35 e8 03 95 3d dc 05 63 42 08 07 ff ff 3e 35     .5...=..cB....>5

00002ad2 <TC_B_Tbl>:
    2ad2:	00 00 90 01 99 01 dc 05 7c 07 b8 0b 8e 15 88 13     ........|.......
    2ae2:	1b 1f 70 17 30 2a 58 1b c4 36 40 1f b6 44 28 23     ..p.0*X..6@..D(#
    2af2:	f2 53 10 27 5a 64 f8 2a d0 75 e0 2e 40 88 c8 32     .S.'Zd.*.u..@..2
    2b02:	78 9b b0 36 50 af 98 3a 82 c3 80 3e d2 d7 68 42     x..6P..:...>..hB
    2b12:	ff ff 38 4a                                         ..8J

00002b16 <Mux.8733>:
    2b16:	06 00 07 00 00 08 01 08 02 08 03 08 04 08 05 08     ................

00002b26 <M.8658>:
    2b26:	00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f     ................

00002b36 <DI_M>:
    2b36:	07 01 08 01 06 01 40 00 07 01 08 01 06 01 80 00     ......@.........
    2b46:	04 01 05 01 03 01 80 00 21 00 22 00 20 00 01 00     ........!.". ...
    2b56:	21 00 22 00 20 00 02 00 21 00 22 00 20 00 04 00     !.". ...!.". ...
    2b66:	21 00 22 00 20 00 08 00 21 00 22 00 20 00 10 00     !.". ...!.". ...
    2b76:	21 00 22 00 20 00 20 00 21 00 22 00 20 00 40 00     !.". . .!.". .@.
    2b86:	21 00 22 00 20 00 80 00 33 00 34 00 32 00 04 00     !.". ...3.4.2...
    2b96:	04 01 05 01 03 01 40 00 04 01 05 01 03 01 20 00     ......@....... .
    2ba6:	04 01 05 01 03 01 10 00 04 01 05 01 03 01 08 00     ................
    2bb6:	04 01 05 01 03 01 02 01 04 01 05 01 03 01 04 01     ................

00002bc6 <__c.6106>:
    2bc6:	2b 50 44 50 00                                      +PDP.

00002bcb <__c.6104>:
    2bcb:	43 4c 4f 53 00                                      CLOS.

00002bd0 <__c.6102>:
    2bd0:	50 4f 53 54 00                                      POST.

00002bd5 <__c.6099>:
    2bd5:	47 45 54 20 00                                      GET .

00002bda <__c.6097>:
    2bda:	0d 0a 00                                            ...

00002bdd <__c.6093>:
    2bdd:	2b 43 53 51 3a 20 25 68 68 75 2c 25 68 68 75 00     +CSQ: %hhu,%hhu.

00002bed <__c.6046>:
    2bed:	25 68 68 75 2c 20 43 4c 4f 53 45 44 00              %hhu, CLOSED.

00002bfa <__c.6040>:
    2bfa:	4f 4b 00                                            OK.

00002bfd <__c.6033>:
    2bfd:	25 68 68 75 20 25 68 68 75 20 25 68 68 75 20 25     %hhu %hhu %hhu %
    2c0d:	68 68 75 00                                         hhu.

00002c11 <MB_Port>:
    2c11:	ce 00 c8 00 c9 00 ca 00 cd 00 cc 00 51 1d 57 1d     ............Q.W.
    2c21:	5b 1d 5c 1d                                         [.\.

00002c25 <MB_Role>:
	...

00002c26 <MB_Timer>:
    2c26:	46 00 47 00 56 27 b2 00 b3 00 60 27 a4 00 a8 00     F.G.V'....`'....
    2c36:	6c 27                                               l'

00002c38 <CGRAM_LCD>:
    2c38:	00 04 06 1f 06 04 00 00 06 09 09 06 00 00 00 00     ................
    2c48:	00 08 08 0e 0f 1f 0f 06 00 00 0e 11 1c 11 0e 00     ................
    2c58:	0e 11 10 1c 10 11 0e 00 0a 00 0c 04 04 04 0e 00     ................
    2c68:	0a 0e 04 04 04 04 0e 00 00 00 00 00 00 00 00 00     ................

00002c78 <Win2LCD>:
    2c78:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    2c88:	00 02 ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    2c98:	20 21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f      !"#$%&'()*+,-./
    2ca8:	30 31 32 33 34 35 36 37 38 39 3a 3b 3c 3d 3e 3f     0123456789:;<=>?
    2cb8:	40 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e 4f     @ABCDEFGHIJKLMNO
    2cc8:	50 51 52 53 54 55 56 57 58 59 5a 5b 5c 5d 5e 5f     PQRSTUVWXYZ[\]^_
    2cd8:	60 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e 6f     `abcdefghijklmno
    2ce8:	70 71 72 73 74 75 76 77 78 79 7a 7b 01 7d e9 7f     pqrstuvwxyz{.}..
    2cf8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    2d08:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    2d18:	ff ff ff ff ff ff ff d9 a2 ff 04 ff ff ff ff 06     ................
    2d28:	ff ff 49 69 ff ff ff da b5 ff 03 ff ff ff ff 05     ..Ii............
    2d38:	41 a0 42 a1 e0 45 a3 a4 a5 a6 4b a7 4d 48 4f a8     A.B..E....K.MHO.
    2d48:	50 43 54 a9 aa 58 e1 ab ac e2 ad ae 62 af b0 b1     PCT..X......b...
    2d58:	61 b2 b3 b4 e3 65 b6 b7 b8 b9 ba bb bc bd 6f be     a....e........o.
    2d68:	70 63 bf 79 e4 78 e5 c0 c1 e6 c2 c3 c4 c5 c6 c7     pc.y.x..........

00002d78 <LineAddr.3690>:
    2d78:	80 c0 94 d4                                         ....

00002d7c <Mux>:
    2d7c:	00 01 02 03 04 05 06                                .......

00002d83 <aCRCLo.1496>:
    2d83:	00 c0 c1 01 c3 03 02 c2 c6 06 07 c7 05 c5 c4 04     ................
    2d93:	cc 0c 0d cd 0f cf ce 0e 0a ca cb 0b c9 09 08 c8     ................
    2da3:	d8 18 19 d9 1b db da 1a 1e de df 1f dd 1d 1c dc     ................
    2db3:	14 d4 d5 15 d7 17 16 d6 d2 12 13 d3 11 d1 d0 10     ................
    2dc3:	f0 30 31 f1 33 f3 f2 32 36 f6 f7 37 f5 35 34 f4     .01.3..26..7.54.
    2dd3:	3c fc fd 3d ff 3f 3e fe fa 3a 3b fb 39 f9 f8 38     <..=.?>..:;.9..8
    2de3:	28 e8 e9 29 eb 2b 2a ea ee 2e 2f ef 2d ed ec 2c     (..).+*.../.-..,
    2df3:	e4 24 25 e5 27 e7 e6 26 22 e2 e3 23 e1 21 20 e0     .$%.'..&"..#.! .
    2e03:	a0 60 61 a1 63 a3 a2 62 66 a6 a7 67 a5 65 64 a4     .`a.c..bf..g.ed.
    2e13:	6c ac ad 6d af 6f 6e ae aa 6a 6b ab 69 a9 a8 68     l..m.on..jk.i..h
    2e23:	78 b8 b9 79 bb 7b 7a ba be 7e 7f bf 7d bd bc 7c     x..y.{z..~..}..|
    2e33:	b4 74 75 b5 77 b7 b6 76 72 b2 b3 73 b1 71 70 b0     .tu.w..vr..s.qp.
    2e43:	50 90 91 51 93 53 52 92 96 56 57 97 55 95 94 54     P..Q.SR..VW.U..T
    2e53:	9c 5c 5d 9d 5f 9f 9e 5e 5a 9a 9b 5b 99 59 58 98     .\]._..^Z..[.YX.
    2e63:	88 48 49 89 4b 8b 8a 4a 4e 8e 8f 4f 8d 4d 4c 8c     .HI.K..JN..O.ML.
    2e73:	44 84 85 45 87 47 46 86 82 42 43 83 41 81 80 40     D..E.GF..BC.A..@

00002e83 <aCRCHi.1495>:
    2e83:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    2e93:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    2ea3:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    2eb3:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    2ec3:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    2ed3:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    2ee3:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    2ef3:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    2f03:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    2f13:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    2f23:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    2f33:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    2f43:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    2f53:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    2f63:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    2f73:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    2f83:	00 40 7a 10 f3 5a 00 a0 72 4e 18 09 00 10 a5 d4     .@z..Z..rN......
    2f93:	e8 00 00 e8 76 48 17 00 00 e4 0b 54 02 00 00 ca     ....vH.....T....
    2fa3:	9a 3b 00 00 00 e1 f5 05 00 00 80 96 98 00 00 00     .;..............
    2fb3:	40 42 0f 00 00 00 a0 86 01 00 00 00 10 27 00 00     @B...........'..
    2fc3:	00 00 e8 03 00 00 00 00 64 00 00 00 00 00 0a 00     ........d.......
    2fd3:	00 00 00 00 01 00 00 00 00 00 2c 76 d8 88 dc 67     ..........,v...g
    2fe3:	4f 08 23 df c1 df ae 59 e1 b1 b7 96 e5 e3 e4 53     O.#....Y.......S
    2ff3:	c6 3a e6 51 99 76 96 e8 e6 c2 84 26 eb 89 8c 9b     .:.Q.v.....&....
    3003:	62 ed 40 7c 6f fc ef bc 9c 9f 40 f2 ba a5 6f a5     b.@|o.....@...o.
    3013:	f4 90 05 5a 2a f7 5c 93 6b 6c f9 67 6d c1 1b fc     ...Z*.\.kl.gm...
    3023:	e0 e4 0d 47 fe f5 20 e6 b5 00 d0 ed 90 2e 03 00     ...G.. .........
    3033:	94 35 77 05 00 80 84 1e 08 00 00 20 4e 0a 00 00     .5w........ N...
    3043:	00 c8 0c 33 33 33 33 0f 98 6e 12 83 11 41 ef 8d     ...3333..n...A..
    3053:	21 14 89 3b e6 55 16 cf fe e6 db 18 d1 84 4b 38     !..;.U........K8
    3063:	1b f7 7c 1d 90 1d a4 bb e4 24 20 32 84 72 5e 22     ..|......$ 2.r^"
    3073:	81 00 c9 f1 24 ec a1 e5 3d 27 00                    ....$...='.

0000307e <__ctors_end>:
    307e:	11 24       	eor	r1, r1
    3080:	1f be       	out	0x3f, r1	; 63
    3082:	cf ef       	ldi	r28, 0xFF	; 255
    3084:	d1 e2       	ldi	r29, 0x21	; 33
    3086:	de bf       	out	0x3e, r29	; 62
    3088:	cd bf       	out	0x3d, r28	; 61
    308a:	00 e0       	ldi	r16, 0x00	; 0
    308c:	0c bf       	out	0x3c, r16	; 60

0000308e <__do_copy_data>:
    308e:	12 e0       	ldi	r17, 0x02	; 2
    3090:	a0 e0       	ldi	r26, 0x00	; 0
    3092:	b2 e0       	ldi	r27, 0x02	; 2
    3094:	e2 ee       	ldi	r30, 0xE2	; 226
    3096:	fc ef       	ldi	r31, 0xFC	; 252
    3098:	00 e0       	ldi	r16, 0x00	; 0
    309a:	0b bf       	out	0x3b, r16	; 59
    309c:	02 c0       	rjmp	.+4      	; 0x30a2 <__do_copy_data+0x14>
    309e:	07 90       	elpm	r0, Z+
    30a0:	0d 92       	st	X+, r0
    30a2:	a6 3d       	cpi	r26, 0xD6	; 214
    30a4:	b1 07       	cpc	r27, r17
    30a6:	d9 f7       	brne	.-10     	; 0x309e <__do_copy_data+0x10>

000030a8 <__do_clear_bss>:
    30a8:	1c e0       	ldi	r17, 0x0C	; 12
    30aa:	a6 ed       	ldi	r26, 0xD6	; 214
    30ac:	b2 e0       	ldi	r27, 0x02	; 2
    30ae:	01 c0       	rjmp	.+2      	; 0x30b2 <.do_clear_bss_start>

000030b0 <.do_clear_bss_loop>:
    30b0:	1d 92       	st	X+, r1

000030b2 <.do_clear_bss_start>:
    30b2:	a6 32       	cpi	r26, 0x26	; 38
    30b4:	b1 07       	cpc	r27, r17
    30b6:	e1 f7       	brne	.-8      	; 0x30b0 <.do_clear_bss_loop>
    30b8:	0e 94 ac 6f 	call	0xdf58	; 0xdf58 <main>
    30bc:	0c 94 84 79 	jmp	0xf308	; 0xf308 <exit>

000030c0 <__bad_interrupt>:
    30c0:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000030c4 <rrb>:
#include <stdint.h>

// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
rrb(const uint8_t *addr)
{
    30c4:	fc 01       	movw	r30, r24
	return *addr;
}
    30c6:	80 81       	ld	r24, Z
    30c8:	08 95       	ret

000030ca <prb>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    30ca:	fc 01       	movw	r30, r24
    30cc:	84 91       	lpm	r24, Z+
}
    30ce:	08 95       	ret

000030d0 <prw>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    30d0:	fc 01       	movw	r30, r24
    30d2:	25 91       	lpm	r18, Z+
    30d4:	34 91       	lpm	r19, Z+
}
    30d6:	c9 01       	movw	r24, r18
    30d8:	08 95       	ret

000030da <prd>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    30da:	fc 01       	movw	r30, r24
    30dc:	25 91       	lpm	r18, Z+
    30de:	35 91       	lpm	r19, Z+
    30e0:	45 91       	lpm	r20, Z+
    30e2:	54 91       	lpm	r21, Z+
}
    30e4:	b9 01       	movw	r22, r18
    30e6:	ca 01       	movw	r24, r20
    30e8:	08 95       	ret

000030ea <prb_f>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#if FLASHEND>0xFFFF
uint8_t
prb_f(const prog_uint8_t *addr)
{
	return pgm_read_byte_far((uint16_t)addr+0x10000);
    30ea:	a0 e0       	ldi	r26, 0x00	; 0
    30ec:	b0 e0       	ldi	r27, 0x00	; 0
    30ee:	80 50       	subi	r24, 0x00	; 0
    30f0:	90 40       	sbci	r25, 0x00	; 0
    30f2:	af 4f       	sbci	r26, 0xFF	; 255
    30f4:	bf 4f       	sbci	r27, 0xFF	; 255
}
    30f6:	ab bf       	out	0x3b, r26	; 59
    30f8:	fc 01       	movw	r30, r24
    30fa:	87 91       	elpm	r24, Z+
    30fc:	08 95       	ret

000030fe <prc>:

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    30fe:	fc 01       	movw	r30, r24
    3100:	84 91       	lpm	r24, Z+
}
    3102:	08 95       	ret

00003104 <prp>:

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    3104:	fc 01       	movw	r30, r24
    3106:	25 91       	lpm	r18, Z+
    3108:	34 91       	lpm	r19, Z+
}
    310a:	c9 01       	movw	r24, r18
    310c:	08 95       	ret

0000310e <CRC_Seed>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
CRC_Seed(uint8_t (*GetByte)(const uint8_t*), const uint8_t *Block, uint32_t Sz, uint16_t Seed)
{
    310e:	6f 92       	push	r6
    3110:	7f 92       	push	r7
    3112:	8f 92       	push	r8
    3114:	9f 92       	push	r9
    3116:	af 92       	push	r10
    3118:	bf 92       	push	r11
    311a:	cf 92       	push	r12
    311c:	df 92       	push	r13
    311e:	ef 92       	push	r14
    3120:	ff 92       	push	r15
    3122:	0f 93       	push	r16
    3124:	1f 93       	push	r17
    3126:	cf 93       	push	r28
    3128:	df 93       	push	r29
    312a:	3c 01       	movw	r6, r24
    312c:	eb 01       	movw	r28, r22
    312e:	49 01       	movw	r8, r18
    3130:	5a 01       	movw	r10, r20
    3132:	c1 2e       	mov	r12, r17
		0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54,
		0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98,
		0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
		0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 0x40
	};
	uint8_t CRCHi=Seed>>8, CRCLo=Seed;
    3134:	d0 2e       	mov	r13, r16
	for (uint32_t i=0; i<Sz; i++) {
    3136:	21 15       	cp	r18, r1
    3138:	31 05       	cpc	r19, r1
    313a:	41 05       	cpc	r20, r1
    313c:	51 05       	cpc	r21, r1
    313e:	f9 f0       	breq	.+62     	; 0x317e <CRC_Seed+0x70>
    3140:	ee 24       	eor	r14, r14
    3142:	ff 24       	eor	r15, r15
    3144:	87 01       	movw	r16, r14
		uint8_t j = CRCLo^GetByte(Block+i);
    3146:	ce 01       	movw	r24, r28
    3148:	8e 0d       	add	r24, r14
    314a:	9f 1d       	adc	r25, r15
    314c:	f3 01       	movw	r30, r6
    314e:	19 95       	eicall
		CRCLo = CRCHi^prb(aCRCHi+j);
    3150:	d8 26       	eor	r13, r24
    3152:	2d 2d       	mov	r18, r13
    3154:	30 e0       	ldi	r19, 0x00	; 0

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    3156:	c9 01       	movw	r24, r18
    3158:	8d 57       	subi	r24, 0x7D	; 125
    315a:	91 4d       	sbci	r25, 0xD1	; 209
    315c:	fc 01       	movw	r30, r24
    315e:	d4 90       	lpm	r13, Z+
		0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 0x40
	};
	uint8_t CRCHi=Seed>>8, CRCLo=Seed;
	for (uint32_t i=0; i<Sz; i++) {
		uint8_t j = CRCLo^GetByte(Block+i);
		CRCLo = CRCHi^prb(aCRCHi+j);
    3160:	dc 24       	eor	r13, r12

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    3162:	2d 57       	subi	r18, 0x7D	; 125
    3164:	32 4d       	sbci	r19, 0xD2	; 210
    3166:	f9 01       	movw	r30, r18
    3168:	c4 90       	lpm	r12, Z+
		0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98,
		0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
		0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 0x40
	};
	uint8_t CRCHi=Seed>>8, CRCLo=Seed;
	for (uint32_t i=0; i<Sz; i++) {
    316a:	08 94       	sec
    316c:	e1 1c       	adc	r14, r1
    316e:	f1 1c       	adc	r15, r1
    3170:	01 1d       	adc	r16, r1
    3172:	11 1d       	adc	r17, r1
    3174:	e8 14       	cp	r14, r8
    3176:	f9 04       	cpc	r15, r9
    3178:	0a 05       	cpc	r16, r10
    317a:	1b 05       	cpc	r17, r11
    317c:	20 f3       	brcs	.-56     	; 0x3146 <CRC_Seed+0x38>
    317e:	9c 2d       	mov	r25, r12
    3180:	80 e0       	ldi	r24, 0x00	; 0
    3182:	2d 2d       	mov	r18, r13
    3184:	30 e0       	ldi	r19, 0x00	; 0
    3186:	28 2b       	or	r18, r24
    3188:	39 2b       	or	r19, r25
		uint8_t j = CRCLo^GetByte(Block+i);
		CRCLo = CRCHi^prb(aCRCHi+j);
		CRCHi = prb(aCRCLo+j);
	}
	return CRCHi<<8|CRCLo;
}
    318a:	c9 01       	movw	r24, r18
    318c:	df 91       	pop	r29
    318e:	cf 91       	pop	r28
    3190:	1f 91       	pop	r17
    3192:	0f 91       	pop	r16
    3194:	ff 90       	pop	r15
    3196:	ef 90       	pop	r14
    3198:	df 90       	pop	r13
    319a:	cf 90       	pop	r12
    319c:	bf 90       	pop	r11
    319e:	af 90       	pop	r10
    31a0:	9f 90       	pop	r9
    31a2:	8f 90       	pop	r8
    31a4:	7f 90       	pop	r7
    31a6:	6f 90       	pop	r6
    31a8:	08 95       	ret

000031aa <CRC>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
CRC(uint8_t (*GetByte)(const uint8_t*), const uint8_t *Block, uint32_t Sz)
{
    31aa:	0f 93       	push	r16
    31ac:	1f 93       	push	r17
	return CRC_Seed(GetByte, Block, Sz, 0xFFFF);
    31ae:	0f ef       	ldi	r16, 0xFF	; 255
    31b0:	1f ef       	ldi	r17, 0xFF	; 255
    31b2:	0e 94 87 18 	call	0x310e	; 0x310e <CRC_Seed>
}
    31b6:	1f 91       	pop	r17
    31b8:	0f 91       	pop	r16
    31ba:	08 95       	ret

000031bc <CRC_Flash_calc>:

// ~~~~~~~~~~~~~~~~~
static uint16_t
CRC_Flash_calc(void)
{
    31bc:	0f 93       	push	r16
    31be:	1f 93       	push	r17
	#if FLASHEND<0xFFFF
		return CRC(prb, NULL, (uint32_t)FLASHEND+1);
	#else
		return CRC_Seed(prb_f, NULL, FLASHEND-0xFFFF, CRC(prb, NULL, 0x10000));
    31c0:	85 e6       	ldi	r24, 0x65	; 101
    31c2:	98 e1       	ldi	r25, 0x18	; 24
    31c4:	60 e0       	ldi	r22, 0x00	; 0
    31c6:	70 e0       	ldi	r23, 0x00	; 0
    31c8:	20 e0       	ldi	r18, 0x00	; 0
    31ca:	30 e0       	ldi	r19, 0x00	; 0
    31cc:	41 e0       	ldi	r20, 0x01	; 1
    31ce:	50 e0       	ldi	r21, 0x00	; 0
    31d0:	0e 94 d5 18 	call	0x31aa	; 0x31aa <CRC>
    31d4:	8c 01       	movw	r16, r24
    31d6:	85 e7       	ldi	r24, 0x75	; 117
    31d8:	98 e1       	ldi	r25, 0x18	; 24
    31da:	60 e0       	ldi	r22, 0x00	; 0
    31dc:	70 e0       	ldi	r23, 0x00	; 0
    31de:	20 e0       	ldi	r18, 0x00	; 0
    31e0:	30 e0       	ldi	r19, 0x00	; 0
    31e2:	43 e0       	ldi	r20, 0x03	; 3
    31e4:	50 e0       	ldi	r21, 0x00	; 0
    31e6:	0e 94 87 18 	call	0x310e	; 0x310e <CRC_Seed>
	#endif
}
    31ea:	1f 91       	pop	r17
    31ec:	0f 91       	pop	r16
    31ee:	08 95       	ret

000031f0 <CRC_EEPROM_calc>:

// ~~~~~~~~~~~~~~~~~~
static uint16_t
CRC_EEPROM_calc(void)
{
    31f0:	cf 92       	push	r12
    31f2:	df 92       	push	r13
    31f4:	ef 92       	push	r14
    31f6:	ff 92       	push	r15
    31f8:	0f 93       	push	r16
    31fa:	1f 93       	push	r17
	return
    31fc:	98 e7       	ldi	r25, 0x78	; 120
    31fe:	c9 2e       	mov	r12, r25
    3200:	9d e4       	ldi	r25, 0x4D	; 77
    3202:	d9 2e       	mov	r13, r25
    3204:	88 e3       	ldi	r24, 0x38	; 56
    3206:	e8 2e       	mov	r14, r24
    3208:	81 e0       	ldi	r24, 0x01	; 1
    320a:	f8 2e       	mov	r15, r24
    320c:	97 01       	movw	r18, r14
    320e:	40 e0       	ldi	r20, 0x00	; 0
    3210:	50 e0       	ldi	r21, 0x00	; 0
    3212:	c6 01       	movw	r24, r12
    3214:	60 e0       	ldi	r22, 0x00	; 0
    3216:	70 e0       	ldi	r23, 0x00	; 0
    3218:	0e 94 d5 18 	call	0x31aa	; 0x31aa <CRC>
    321c:	8c 01       	movw	r16, r24
    321e:	2b ef       	ldi	r18, 0xFB	; 251
    3220:	3f e0       	ldi	r19, 0x0F	; 15
    3222:	2e 19       	sub	r18, r14
    3224:	3f 09       	sbc	r19, r15
    3226:	40 e0       	ldi	r20, 0x00	; 0
    3228:	50 e0       	ldi	r21, 0x00	; 0
    322a:	c6 01       	movw	r24, r12
    322c:	65 e0       	ldi	r22, 0x05	; 5
    322e:	70 e0       	ldi	r23, 0x00	; 0
    3230:	e6 0e       	add	r14, r22
    3232:	f7 1e       	adc	r15, r23
    3234:	b7 01       	movw	r22, r14
    3236:	0e 94 87 18 	call	0x310e	; 0x310e <CRC_Seed>
		CRC_Seed(erb, (uint8_t*)&MemCheck_stor+sizeof(MemCheck_stor), E2END-((uint16_t)&MemCheck_stor-1)-sizeof(MemCheck_stor),
			CRC(erb, NULL, (uint16_t)&MemCheck_stor));
}
    323a:	1f 91       	pop	r17
    323c:	0f 91       	pop	r16
    323e:	ff 90       	pop	r15
    3240:	ef 90       	pop	r14
    3242:	df 90       	pop	r13
    3244:	cf 90       	pop	r12
    3246:	08 95       	ret

00003248 <InterruInit>:
InterruInit(void)
{
	#ifdef PMIC
		PMIC.CTRL = (uint8_t)(~PMIC_RREN_bm &~PMIC_IVSEL_bm) |PMIC_HILVLEN_bm |PMIC_MEDLVLEN_bm |PMIC_LOLVLEN_bm;
	#endif
	sei();
    3248:	78 94       	sei
}
    324a:	08 95       	ret

0000324c <IntOff>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    324c:	8f b7       	in	r24, 0x3f	; 63
    324e:	80 78       	andi	r24, 0x80	; 128
    3250:	80 93 e6 02 	sts	0x02E6, r24
	cli();
    3254:	f8 94       	cli
	return interru_enub_flg;
}
    3256:	08 95       	ret

00003258 <IntOn>:

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3258:	80 91 e6 02 	lds	r24, 0x02E6
    325c:	88 23       	and	r24, r24
    325e:	09 f0       	breq	.+2      	; 0x3262 <IntOn+0xa>
		sei();
    3260:	78 94       	sei
	return interru_enub_flg;
}
    3262:	08 95       	ret

00003264 <WdtOn>:

// ~~~~~~~~
void
WdtOn(void)
{
	wdt_reset();
    3264:	a8 95       	wdr
	wdt_enable(WDTO_2S);
    3266:	2f e0       	ldi	r18, 0x0F	; 15
    3268:	88 e1       	ldi	r24, 0x18	; 24
    326a:	90 e0       	ldi	r25, 0x00	; 0
    326c:	0f b6       	in	r0, 0x3f	; 63
    326e:	f8 94       	cli
    3270:	a8 95       	wdr
    3272:	80 93 60 00 	sts	0x0060, r24
    3276:	0f be       	out	0x3f, r0	; 63
    3278:	20 93 60 00 	sts	0x0060, r18
}
    327c:	08 95       	ret

0000327e <Timer8_ISR_Alloc>:

// ~~~~~~~~~~~~~~
uint8_t
Timer8_ISR_Alloc(void)
{
	uint8_t N = VacantTimer8_ISR;
    327e:	80 91 d6 02 	lds	r24, 0x02D6
	VacantTimer8_ISR++;
    3282:	8f 5f       	subi	r24, 0xFF	; 255
    3284:	80 93 d6 02 	sts	0x02D6, r24
    3288:	81 50       	subi	r24, 0x01	; 1
	return N;
}
    328a:	08 95       	ret

0000328c <Timer8Alloc>:

uint8_t
Timer8Alloc(void)
{
	uint8_t N = VacantTimer8;
    328c:	80 91 c9 02 	lds	r24, 0x02C9
	VacantTimer8++;
    3290:	8f 5f       	subi	r24, 0xFF	; 255
    3292:	80 93 c9 02 	sts	0x02C9, r24
    3296:	81 50       	subi	r24, 0x01	; 1
	return N;
}
    3298:	08 95       	ret

0000329a <Timer16Alloc>:

// ~~~~~~~~~~~~~~~
uint8_t
Timer16Alloc(void)
{
	uint8_t N = VacantTimer16;
    329a:	80 91 ca 02 	lds	r24, 0x02CA
	VacantTimer16++;
    329e:	8f 5f       	subi	r24, 0xFF	; 255
    32a0:	80 93 ca 02 	sts	0x02CA, r24
    32a4:	81 50       	subi	r24, 0x01	; 1
	return N;
}
    32a6:	08 95       	ret

000032a8 <Timer32Alloc>:

// ~~~~~~~~~~~~~~~
uint8_t
Timer32Alloc(void)
{
	uint8_t N = VacantTimer32;
    32a8:	80 91 cb 02 	lds	r24, 0x02CB
	VacantTimer32++;
    32ac:	8f 5f       	subi	r24, 0xFF	; 255
    32ae:	80 93 cb 02 	sts	0x02CB, r24
    32b2:	81 50       	subi	r24, 0x01	; 1
	return N;
}
    32b4:	08 95       	ret

000032b6 <Timer8_ISR_AppAlloc>:
// ~~~~~~~~~~~~~~

uint8_t
Timer8_ISR_AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    32b6:	88 23       	and	r24, r24
    32b8:	39 f0       	breq	.+14     	; 0x32c8 <Timer8_ISR_AppAlloc+0x12>
	uint8_t N = VacantTimer8_ISR;
    32ba:	90 91 d6 02 	lds	r25, 0x02D6
	VacantTimer8_ISR+=n;
    32be:	89 0f       	add	r24, r25
    32c0:	80 93 d6 02 	sts	0x02D6, r24
	return N;
}
    32c4:	89 2f       	mov	r24, r25
    32c6:	08 95       	ret
// ~~~~~~~~~~~~~~

uint8_t
Timer8_ISR_AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    32c8:	90 e0       	ldi	r25, 0x00	; 0
	uint8_t N = VacantTimer8_ISR;
	VacantTimer8_ISR+=n;
	return N;
}
    32ca:	89 2f       	mov	r24, r25
    32cc:	08 95       	ret

000032ce <Timer8AppAlloc>:

uint8_t
Timer8AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    32ce:	88 23       	and	r24, r24
    32d0:	39 f0       	breq	.+14     	; 0x32e0 <Timer8AppAlloc+0x12>
	uint8_t N = VacantTimer8;
    32d2:	90 91 c9 02 	lds	r25, 0x02C9
	VacantTimer8+=n;
    32d6:	89 0f       	add	r24, r25
    32d8:	80 93 c9 02 	sts	0x02C9, r24
	return N;
}
    32dc:	89 2f       	mov	r24, r25
    32de:	08 95       	ret
}

uint8_t
Timer8AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    32e0:	90 e0       	ldi	r25, 0x00	; 0
	uint8_t N = VacantTimer8;
	VacantTimer8+=n;
	return N;
}
    32e2:	89 2f       	mov	r24, r25
    32e4:	08 95       	ret

000032e6 <Timer16AppAlloc>:

// ~~~~~~~~~~~~~~~
uint8_t
Timer16AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    32e6:	88 23       	and	r24, r24
    32e8:	39 f0       	breq	.+14     	; 0x32f8 <Timer16AppAlloc+0x12>
	uint8_t N = VacantTimer16;
    32ea:	90 91 ca 02 	lds	r25, 0x02CA
	VacantTimer16+=n;
    32ee:	89 0f       	add	r24, r25
    32f0:	80 93 ca 02 	sts	0x02CA, r24
	return N;
}
    32f4:	89 2f       	mov	r24, r25
    32f6:	08 95       	ret

// ~~~~~~~~~~~~~~~
uint8_t
Timer16AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    32f8:	90 e0       	ldi	r25, 0x00	; 0
	uint8_t N = VacantTimer16;
	VacantTimer16+=n;
	return N;
}
    32fa:	89 2f       	mov	r24, r25
    32fc:	08 95       	ret

000032fe <Timer32AppAlloc>:

// ~~~~~~~~~~~~~~~
uint8_t
Timer32AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    32fe:	88 23       	and	r24, r24
    3300:	39 f0       	breq	.+14     	; 0x3310 <Timer32AppAlloc+0x12>
	uint8_t N = VacantTimer32;
    3302:	90 91 cb 02 	lds	r25, 0x02CB
	VacantTimer32+=n;
    3306:	89 0f       	add	r24, r25
    3308:	80 93 cb 02 	sts	0x02CB, r24
	return N;
}
    330c:	89 2f       	mov	r24, r25
    330e:	08 95       	ret

// ~~~~~~~~~~~~~~~
uint8_t
Timer32AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    3310:	90 e0       	ldi	r25, 0x00	; 0
	uint8_t N = VacantTimer32;
	VacantTimer32+=n;
	return N;
}
    3312:	89 2f       	mov	r24, r25
    3314:	08 95       	ret

00003316 <Timer8_ISR_SysAlloc>:

// ~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer8_ISR_SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys_ISR;
    3316:	90 91 d7 02 	lds	r25, 0x02D7
	VacantTimer8Sys_ISR += n;
    331a:	89 0f       	add	r24, r25
    331c:	80 93 d7 02 	sts	0x02D7, r24
	return N;
}
    3320:	89 2f       	mov	r24, r25
    3322:	08 95       	ret

00003324 <Timer8SysAlloc>:

uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    3324:	90 91 cc 02 	lds	r25, 0x02CC
	VacantTimer8Sys += n;
    3328:	89 0f       	add	r24, r25
    332a:	80 93 cc 02 	sts	0x02CC, r24
	return N;
}
    332e:	89 2f       	mov	r24, r25
    3330:	08 95       	ret

00003332 <Timer16SysAlloc>:

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    3332:	90 91 cd 02 	lds	r25, 0x02CD
	VacantTimer16Sys += n;
    3336:	89 0f       	add	r24, r25
    3338:	80 93 cd 02 	sts	0x02CD, r24
	return N;
}
    333c:	89 2f       	mov	r24, r25
    333e:	08 95       	ret

00003340 <Timer32SysAlloc>:

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer32SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer32Sys;
    3340:	90 91 ce 02 	lds	r25, 0x02CE
	VacantTimer32Sys += n;
    3344:	89 0f       	add	r24, r25
    3346:	80 93 ce 02 	sts	0x02CE, r24
	return N;
}
    334a:	89 2f       	mov	r24, r25
    334c:	08 95       	ret

0000334e <StartTimer8_ISR>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
StartTimer8_ISR(uint8_t TimerN, uint8_t Timeout)
{
    334e:	98 2f       	mov	r25, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3350:	3f b7       	in	r19, 0x3f	; 63
    3352:	30 78       	andi	r19, 0x80	; 128
    3354:	30 93 e6 02 	sts	0x02E6, r19
	cli();
    3358:	f8 94       	cli
	IntOff();
	if ((Timer8_ISR[TimerN]=Timeout)>0)
    335a:	48 2f       	mov	r20, r24
    335c:	50 e0       	ldi	r21, 0x00	; 0
    335e:	fa 01       	movw	r30, r20
    3360:	e9 51       	subi	r30, 0x19	; 25
    3362:	fd 4f       	sbci	r31, 0xFD	; 253
    3364:	60 83       	st	Z, r22
    3366:	80 81       	ld	r24, Z
    3368:	88 23       	and	r24, r24
    336a:	c1 f0       	breq	.+48     	; 0x339c <StartTimer8_ISR+0x4e>
		Timer8_ISR_Flg[TimerN/8] &=~(1<<TimerN%8);
    336c:	96 95       	lsr	r25
    336e:	96 95       	lsr	r25
    3370:	96 95       	lsr	r25
    3372:	e9 2f       	mov	r30, r25
    3374:	f0 e0       	ldi	r31, 0x00	; 0
    3376:	e9 55       	subi	r30, 0x59	; 89
    3378:	fb 4f       	sbci	r31, 0xFB	; 251
    337a:	20 81       	ld	r18, Z
    337c:	47 70       	andi	r20, 0x07	; 7
    337e:	50 70       	andi	r21, 0x00	; 0
    3380:	81 e0       	ldi	r24, 0x01	; 1
    3382:	90 e0       	ldi	r25, 0x00	; 0
    3384:	02 c0       	rjmp	.+4      	; 0x338a <StartTimer8_ISR+0x3c>
    3386:	88 0f       	add	r24, r24
    3388:	99 1f       	adc	r25, r25
    338a:	4a 95       	dec	r20
    338c:	e2 f7       	brpl	.-8      	; 0x3386 <StartTimer8_ISR+0x38>
    338e:	80 95       	com	r24
    3390:	82 23       	and	r24, r18
    3392:	80 83       	st	Z, r24

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3394:	33 23       	and	r19, r19
    3396:	09 f0       	breq	.+2      	; 0x339a <StartTimer8_ISR+0x4c>
		sei();
    3398:	78 94       	sei
    339a:	08 95       	ret
	else
		Timer8_ISR_Flg[TimerN/8] |=(1<<TimerN%8);
    339c:	96 95       	lsr	r25
    339e:	96 95       	lsr	r25
    33a0:	96 95       	lsr	r25
    33a2:	e9 2f       	mov	r30, r25
    33a4:	f0 e0       	ldi	r31, 0x00	; 0
    33a6:	e9 55       	subi	r30, 0x59	; 89
    33a8:	fb 4f       	sbci	r31, 0xFB	; 251
    33aa:	20 81       	ld	r18, Z
    33ac:	47 70       	andi	r20, 0x07	; 7
    33ae:	50 70       	andi	r21, 0x00	; 0
    33b0:	81 e0       	ldi	r24, 0x01	; 1
    33b2:	90 e0       	ldi	r25, 0x00	; 0
    33b4:	02 c0       	rjmp	.+4      	; 0x33ba <StartTimer8_ISR+0x6c>
    33b6:	88 0f       	add	r24, r24
    33b8:	99 1f       	adc	r25, r25
    33ba:	4a 95       	dec	r20
    33bc:	e2 f7       	brpl	.-8      	; 0x33b6 <StartTimer8_ISR+0x68>
    33be:	28 2b       	or	r18, r24
    33c0:	20 83       	st	Z, r18
    33c2:	e8 cf       	rjmp	.-48     	; 0x3394 <StartTimer8_ISR+0x46>

000033c4 <StartTimer8>:
}


void
StartTimer8(uint8_t TimerN, uint8_t Timeout)
{
    33c4:	98 2f       	mov	r25, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    33c6:	3f b7       	in	r19, 0x3f	; 63
    33c8:	30 78       	andi	r19, 0x80	; 128
    33ca:	30 93 e6 02 	sts	0x02E6, r19
	cli();
    33ce:	f8 94       	cli
	IntOff();
	if ((Timer8[TimerN]=Timeout)>0)
    33d0:	48 2f       	mov	r20, r24
    33d2:	50 e0       	ldi	r21, 0x00	; 0
    33d4:	fa 01       	movw	r30, r20
    33d6:	e1 51       	subi	r30, 0x11	; 17
    33d8:	fd 4f       	sbci	r31, 0xFD	; 253
    33da:	60 83       	st	Z, r22
    33dc:	80 81       	ld	r24, Z
    33de:	88 23       	and	r24, r24
    33e0:	c1 f0       	breq	.+48     	; 0x3412 <StartTimer8+0x4e>
		Timer8Flg[TimerN/8] &=~(1<<TimerN%8);
    33e2:	96 95       	lsr	r25
    33e4:	96 95       	lsr	r25
    33e6:	96 95       	lsr	r25
    33e8:	e9 2f       	mov	r30, r25
    33ea:	f0 e0       	ldi	r31, 0x00	; 0
    33ec:	e7 55       	subi	r30, 0x57	; 87
    33ee:	fb 4f       	sbci	r31, 0xFB	; 251
    33f0:	20 81       	ld	r18, Z
    33f2:	47 70       	andi	r20, 0x07	; 7
    33f4:	50 70       	andi	r21, 0x00	; 0
    33f6:	81 e0       	ldi	r24, 0x01	; 1
    33f8:	90 e0       	ldi	r25, 0x00	; 0
    33fa:	02 c0       	rjmp	.+4      	; 0x3400 <StartTimer8+0x3c>
    33fc:	88 0f       	add	r24, r24
    33fe:	99 1f       	adc	r25, r25
    3400:	4a 95       	dec	r20
    3402:	e2 f7       	brpl	.-8      	; 0x33fc <StartTimer8+0x38>
    3404:	80 95       	com	r24
    3406:	82 23       	and	r24, r18
    3408:	80 83       	st	Z, r24

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    340a:	33 23       	and	r19, r19
    340c:	09 f0       	breq	.+2      	; 0x3410 <StartTimer8+0x4c>
		sei();
    340e:	78 94       	sei
    3410:	08 95       	ret
	else
		Timer8Flg[TimerN/8] |=(1<<TimerN%8);
    3412:	96 95       	lsr	r25
    3414:	96 95       	lsr	r25
    3416:	96 95       	lsr	r25
    3418:	e9 2f       	mov	r30, r25
    341a:	f0 e0       	ldi	r31, 0x00	; 0
    341c:	e7 55       	subi	r30, 0x57	; 87
    341e:	fb 4f       	sbci	r31, 0xFB	; 251
    3420:	20 81       	ld	r18, Z
    3422:	47 70       	andi	r20, 0x07	; 7
    3424:	50 70       	andi	r21, 0x00	; 0
    3426:	81 e0       	ldi	r24, 0x01	; 1
    3428:	90 e0       	ldi	r25, 0x00	; 0
    342a:	02 c0       	rjmp	.+4      	; 0x3430 <StartTimer8+0x6c>
    342c:	88 0f       	add	r24, r24
    342e:	99 1f       	adc	r25, r25
    3430:	4a 95       	dec	r20
    3432:	e2 f7       	brpl	.-8      	; 0x342c <StartTimer8+0x68>
    3434:	28 2b       	or	r18, r24
    3436:	20 83       	st	Z, r18
    3438:	e8 cf       	rjmp	.-48     	; 0x340a <StartTimer8+0x46>

0000343a <StartTimer16>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
StartTimer16(uint8_t TimerN, uint16_t Timeout)
{
    343a:	28 2f       	mov	r18, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    343c:	3f b7       	in	r19, 0x3f	; 63
    343e:	30 78       	andi	r19, 0x80	; 128
    3440:	30 93 e6 02 	sts	0x02E6, r19
	cli();
    3444:	f8 94       	cli
	IntOff();
	if ((Timer16[TimerN]=Timeout)>0)
    3446:	48 2f       	mov	r20, r24
    3448:	50 e0       	ldi	r21, 0x00	; 0
    344a:	fa 01       	movw	r30, r20
    344c:	ee 0f       	add	r30, r30
    344e:	ff 1f       	adc	r31, r31
    3450:	e9 5b       	subi	r30, 0xB9	; 185
    3452:	fc 4f       	sbci	r31, 0xFC	; 252
    3454:	71 83       	std	Z+1, r23	; 0x01
    3456:	60 83       	st	Z, r22
    3458:	80 81       	ld	r24, Z
    345a:	91 81       	ldd	r25, Z+1	; 0x01
    345c:	89 2b       	or	r24, r25
    345e:	c1 f0       	breq	.+48     	; 0x3490 <StartTimer16+0x56>
		Timer16Flg[TimerN/8] &=~(1<<TimerN%8);
    3460:	26 95       	lsr	r18
    3462:	26 95       	lsr	r18
    3464:	26 95       	lsr	r18
    3466:	e2 2f       	mov	r30, r18
    3468:	f0 e0       	ldi	r31, 0x00	; 0
    346a:	eb 54       	subi	r30, 0x4B	; 75
    346c:	fb 4f       	sbci	r31, 0xFB	; 251
    346e:	20 81       	ld	r18, Z
    3470:	47 70       	andi	r20, 0x07	; 7
    3472:	50 70       	andi	r21, 0x00	; 0
    3474:	81 e0       	ldi	r24, 0x01	; 1
    3476:	90 e0       	ldi	r25, 0x00	; 0
    3478:	02 c0       	rjmp	.+4      	; 0x347e <StartTimer16+0x44>
    347a:	88 0f       	add	r24, r24
    347c:	99 1f       	adc	r25, r25
    347e:	4a 95       	dec	r20
    3480:	e2 f7       	brpl	.-8      	; 0x347a <StartTimer16+0x40>
    3482:	80 95       	com	r24
    3484:	82 23       	and	r24, r18
    3486:	80 83       	st	Z, r24

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3488:	33 23       	and	r19, r19
    348a:	09 f0       	breq	.+2      	; 0x348e <StartTimer16+0x54>
		sei();
    348c:	78 94       	sei
    348e:	08 95       	ret
	else
		Timer16Flg[TimerN/8] |=(1<<TimerN%8);
    3490:	26 95       	lsr	r18
    3492:	26 95       	lsr	r18
    3494:	26 95       	lsr	r18
    3496:	e2 2f       	mov	r30, r18
    3498:	f0 e0       	ldi	r31, 0x00	; 0
    349a:	eb 54       	subi	r30, 0x4B	; 75
    349c:	fb 4f       	sbci	r31, 0xFB	; 251
    349e:	20 81       	ld	r18, Z
    34a0:	47 70       	andi	r20, 0x07	; 7
    34a2:	50 70       	andi	r21, 0x00	; 0
    34a4:	81 e0       	ldi	r24, 0x01	; 1
    34a6:	90 e0       	ldi	r25, 0x00	; 0
    34a8:	02 c0       	rjmp	.+4      	; 0x34ae <StartTimer16+0x74>
    34aa:	88 0f       	add	r24, r24
    34ac:	99 1f       	adc	r25, r25
    34ae:	4a 95       	dec	r20
    34b0:	e2 f7       	brpl	.-8      	; 0x34aa <StartTimer16+0x70>
    34b2:	28 2b       	or	r18, r24
    34b4:	20 83       	st	Z, r18
    34b6:	e8 cf       	rjmp	.-48     	; 0x3488 <StartTimer16+0x4e>

000034b8 <StartTimer32>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
StartTimer32(uint8_t TimerN, uint32_t Timeout)
{
    34b8:	cf 93       	push	r28
    34ba:	df 93       	push	r29
    34bc:	28 2f       	mov	r18, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    34be:	3f b7       	in	r19, 0x3f	; 63
    34c0:	30 78       	andi	r19, 0x80	; 128
    34c2:	30 93 e6 02 	sts	0x02E6, r19
	cli();
    34c6:	f8 94       	cli
	IntOff();
	if ((Timer32[TimerN]=Timeout)>0)
    34c8:	c8 2f       	mov	r28, r24
    34ca:	d0 e0       	ldi	r29, 0x00	; 0
    34cc:	fe 01       	movw	r30, r28
    34ce:	ee 0f       	add	r30, r30
    34d0:	ff 1f       	adc	r31, r31
    34d2:	ee 0f       	add	r30, r30
    34d4:	ff 1f       	adc	r31, r31
    34d6:	e9 5f       	subi	r30, 0xF9	; 249
    34d8:	fb 4f       	sbci	r31, 0xFB	; 251
    34da:	40 83       	st	Z, r20
    34dc:	51 83       	std	Z+1, r21	; 0x01
    34de:	62 83       	std	Z+2, r22	; 0x02
    34e0:	73 83       	std	Z+3, r23	; 0x03
    34e2:	80 81       	ld	r24, Z
    34e4:	91 81       	ldd	r25, Z+1	; 0x01
    34e6:	a2 81       	ldd	r26, Z+2	; 0x02
    34e8:	b3 81       	ldd	r27, Z+3	; 0x03
    34ea:	00 97       	sbiw	r24, 0x00	; 0
    34ec:	a1 05       	cpc	r26, r1
    34ee:	b1 05       	cpc	r27, r1
    34f0:	d1 f0       	breq	.+52     	; 0x3526 <StartTimer32+0x6e>
		Timer32Flg[TimerN/8] &=~(1<<TimerN%8);
    34f2:	26 95       	lsr	r18
    34f4:	26 95       	lsr	r18
    34f6:	26 95       	lsr	r18
    34f8:	e2 2f       	mov	r30, r18
    34fa:	f0 e0       	ldi	r31, 0x00	; 0
    34fc:	ee 53       	subi	r30, 0x3E	; 62
    34fe:	fb 4f       	sbci	r31, 0xFB	; 251
    3500:	20 81       	ld	r18, Z
    3502:	c7 70       	andi	r28, 0x07	; 7
    3504:	d0 70       	andi	r29, 0x00	; 0
    3506:	81 e0       	ldi	r24, 0x01	; 1
    3508:	90 e0       	ldi	r25, 0x00	; 0
    350a:	02 c0       	rjmp	.+4      	; 0x3510 <StartTimer32+0x58>
    350c:	88 0f       	add	r24, r24
    350e:	99 1f       	adc	r25, r25
    3510:	ca 95       	dec	r28
    3512:	e2 f7       	brpl	.-8      	; 0x350c <StartTimer32+0x54>
    3514:	80 95       	com	r24
    3516:	82 23       	and	r24, r18
    3518:	80 83       	st	Z, r24

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    351a:	33 23       	and	r19, r19
    351c:	09 f0       	breq	.+2      	; 0x3520 <StartTimer32+0x68>
		sei();
    351e:	78 94       	sei
	else
		Timer32Flg[TimerN/8] |=(1<<TimerN%8);
	IntOn();
}
    3520:	df 91       	pop	r29
    3522:	cf 91       	pop	r28
    3524:	08 95       	ret
{
	IntOff();
	if ((Timer32[TimerN]=Timeout)>0)
		Timer32Flg[TimerN/8] &=~(1<<TimerN%8);
	else
		Timer32Flg[TimerN/8] |=(1<<TimerN%8);
    3526:	26 95       	lsr	r18
    3528:	26 95       	lsr	r18
    352a:	26 95       	lsr	r18
    352c:	e2 2f       	mov	r30, r18
    352e:	f0 e0       	ldi	r31, 0x00	; 0
    3530:	ee 53       	subi	r30, 0x3E	; 62
    3532:	fb 4f       	sbci	r31, 0xFB	; 251
    3534:	20 81       	ld	r18, Z
    3536:	c7 70       	andi	r28, 0x07	; 7
    3538:	d0 70       	andi	r29, 0x00	; 0
    353a:	81 e0       	ldi	r24, 0x01	; 1
    353c:	90 e0       	ldi	r25, 0x00	; 0
    353e:	02 c0       	rjmp	.+4      	; 0x3544 <StartTimer32+0x8c>
    3540:	88 0f       	add	r24, r24
    3542:	99 1f       	adc	r25, r25
    3544:	ca 95       	dec	r28
    3546:	e2 f7       	brpl	.-8      	; 0x3540 <StartTimer32+0x88>
    3548:	28 2b       	or	r18, r24
    354a:	20 83       	st	Z, r18
    354c:	e6 cf       	rjmp	.-52     	; 0x351a <StartTimer32+0x62>

0000354e <StopTimer8_ISR>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    354e:	4f b7       	in	r20, 0x3f	; 63
    3550:	40 78       	andi	r20, 0x80	; 128
    3552:	40 93 e6 02 	sts	0x02E6, r20
	cli();
    3556:	f8 94       	cli
// ~~~~~~~~~~~~~~~~~~~~~~~
void
StopTimer8_ISR(uint8_t TimerN)
{
	IntOff();
	Timer8_ISR_Flg[TimerN/8] |=(1<<TimerN%8);
    3558:	e8 2f       	mov	r30, r24
    355a:	e6 95       	lsr	r30
    355c:	e6 95       	lsr	r30
    355e:	e6 95       	lsr	r30
    3560:	f0 e0       	ldi	r31, 0x00	; 0
    3562:	e9 55       	subi	r30, 0x59	; 89
    3564:	fb 4f       	sbci	r31, 0xFB	; 251
    3566:	90 81       	ld	r25, Z
    3568:	87 70       	andi	r24, 0x07	; 7
    356a:	21 e0       	ldi	r18, 0x01	; 1
    356c:	30 e0       	ldi	r19, 0x00	; 0
    356e:	02 c0       	rjmp	.+4      	; 0x3574 <StopTimer8_ISR+0x26>
    3570:	22 0f       	add	r18, r18
    3572:	33 1f       	adc	r19, r19
    3574:	8a 95       	dec	r24
    3576:	e2 f7       	brpl	.-8      	; 0x3570 <StopTimer8_ISR+0x22>
    3578:	92 2b       	or	r25, r18
    357a:	90 83       	st	Z, r25

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    357c:	44 23       	and	r20, r20
    357e:	09 f0       	breq	.+2      	; 0x3582 <StopTimer8_ISR+0x34>
		sei();
    3580:	78 94       	sei
    3582:	08 95       	ret

00003584 <StopTimer8>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3584:	4f b7       	in	r20, 0x3f	; 63
    3586:	40 78       	andi	r20, 0x80	; 128
    3588:	40 93 e6 02 	sts	0x02E6, r20
	cli();
    358c:	f8 94       	cli

void
StopTimer8(uint8_t TimerN)
{
	IntOff();
	Timer8Flg[TimerN/8] |=(1<<TimerN%8);
    358e:	e8 2f       	mov	r30, r24
    3590:	e6 95       	lsr	r30
    3592:	e6 95       	lsr	r30
    3594:	e6 95       	lsr	r30
    3596:	f0 e0       	ldi	r31, 0x00	; 0
    3598:	e7 55       	subi	r30, 0x57	; 87
    359a:	fb 4f       	sbci	r31, 0xFB	; 251
    359c:	90 81       	ld	r25, Z
    359e:	87 70       	andi	r24, 0x07	; 7
    35a0:	21 e0       	ldi	r18, 0x01	; 1
    35a2:	30 e0       	ldi	r19, 0x00	; 0
    35a4:	02 c0       	rjmp	.+4      	; 0x35aa <StopTimer8+0x26>
    35a6:	22 0f       	add	r18, r18
    35a8:	33 1f       	adc	r19, r19
    35aa:	8a 95       	dec	r24
    35ac:	e2 f7       	brpl	.-8      	; 0x35a6 <StopTimer8+0x22>
    35ae:	92 2b       	or	r25, r18
    35b0:	90 83       	st	Z, r25

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    35b2:	44 23       	and	r20, r20
    35b4:	09 f0       	breq	.+2      	; 0x35b8 <StopTimer8+0x34>
		sei();
    35b6:	78 94       	sei
    35b8:	08 95       	ret

000035ba <StopTimer16>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    35ba:	4f b7       	in	r20, 0x3f	; 63
    35bc:	40 78       	andi	r20, 0x80	; 128
    35be:	40 93 e6 02 	sts	0x02E6, r20
	cli();
    35c2:	f8 94       	cli
// ~~~~~~~~~~~~~~~~~~~~~~~~
void
StopTimer16(uint8_t TimerN)
{
	IntOff();
	Timer16Flg[TimerN/8] |=1<<TimerN%8;
    35c4:	e8 2f       	mov	r30, r24
    35c6:	e6 95       	lsr	r30
    35c8:	e6 95       	lsr	r30
    35ca:	e6 95       	lsr	r30
    35cc:	f0 e0       	ldi	r31, 0x00	; 0
    35ce:	eb 54       	subi	r30, 0x4B	; 75
    35d0:	fb 4f       	sbci	r31, 0xFB	; 251
    35d2:	90 81       	ld	r25, Z
    35d4:	87 70       	andi	r24, 0x07	; 7
    35d6:	21 e0       	ldi	r18, 0x01	; 1
    35d8:	30 e0       	ldi	r19, 0x00	; 0
    35da:	02 c0       	rjmp	.+4      	; 0x35e0 <StopTimer16+0x26>
    35dc:	22 0f       	add	r18, r18
    35de:	33 1f       	adc	r19, r19
    35e0:	8a 95       	dec	r24
    35e2:	e2 f7       	brpl	.-8      	; 0x35dc <StopTimer16+0x22>
    35e4:	92 2b       	or	r25, r18
    35e6:	90 83       	st	Z, r25

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    35e8:	44 23       	and	r20, r20
    35ea:	09 f0       	breq	.+2      	; 0x35ee <StopTimer16+0x34>
		sei();
    35ec:	78 94       	sei
    35ee:	08 95       	ret

000035f0 <StopTimer32>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    35f0:	4f b7       	in	r20, 0x3f	; 63
    35f2:	40 78       	andi	r20, 0x80	; 128
    35f4:	40 93 e6 02 	sts	0x02E6, r20
	cli();
    35f8:	f8 94       	cli
// ~~~~~~~~~~~~~~~~~~~~~~~~
void
StopTimer32(uint8_t TimerN)
{
	IntOff();
	Timer32Flg[TimerN/8] |=1<<TimerN%8;
    35fa:	e8 2f       	mov	r30, r24
    35fc:	e6 95       	lsr	r30
    35fe:	e6 95       	lsr	r30
    3600:	e6 95       	lsr	r30
    3602:	f0 e0       	ldi	r31, 0x00	; 0
    3604:	ee 53       	subi	r30, 0x3E	; 62
    3606:	fb 4f       	sbci	r31, 0xFB	; 251
    3608:	90 81       	ld	r25, Z
    360a:	87 70       	andi	r24, 0x07	; 7
    360c:	21 e0       	ldi	r18, 0x01	; 1
    360e:	30 e0       	ldi	r19, 0x00	; 0
    3610:	02 c0       	rjmp	.+4      	; 0x3616 <StopTimer32+0x26>
    3612:	22 0f       	add	r18, r18
    3614:	33 1f       	adc	r19, r19
    3616:	8a 95       	dec	r24
    3618:	e2 f7       	brpl	.-8      	; 0x3612 <StopTimer32+0x22>
    361a:	92 2b       	or	r25, r18
    361c:	90 83       	st	Z, r25

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    361e:	44 23       	and	r20, r20
    3620:	09 f0       	breq	.+2      	; 0x3624 <StopTimer32+0x34>
		sei();
    3622:	78 94       	sei
    3624:	08 95       	ret

00003626 <Timer8Stopp_ISR>:
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer8Stopp_ISR(uint8_t TimerN)
{
	return (Timer8_ISR_Flg[TimerN/8] &(1<<TimerN%8)) && Timer8_ISR[TimerN]==0;
    3626:	e8 2f       	mov	r30, r24
    3628:	e6 95       	lsr	r30
    362a:	e6 95       	lsr	r30
    362c:	e6 95       	lsr	r30
    362e:	f0 e0       	ldi	r31, 0x00	; 0
    3630:	e9 55       	subi	r30, 0x59	; 89
    3632:	fb 4f       	sbci	r31, 0xFB	; 251
    3634:	20 81       	ld	r18, Z
    3636:	e8 2f       	mov	r30, r24
    3638:	f0 e0       	ldi	r31, 0x00	; 0
    363a:	30 e0       	ldi	r19, 0x00	; 0
    363c:	cf 01       	movw	r24, r30
    363e:	87 70       	andi	r24, 0x07	; 7
    3640:	90 70       	andi	r25, 0x00	; 0
    3642:	02 c0       	rjmp	.+4      	; 0x3648 <Timer8Stopp_ISR+0x22>
    3644:	35 95       	asr	r19
    3646:	27 95       	ror	r18
    3648:	8a 95       	dec	r24
    364a:	e2 f7       	brpl	.-8      	; 0x3644 <Timer8Stopp_ISR+0x1e>
    364c:	20 fd       	sbrc	r18, 0
    364e:	02 c0       	rjmp	.+4      	; 0x3654 <Timer8Stopp_ISR+0x2e>
    3650:	80 e0       	ldi	r24, 0x00	; 0
    3652:	08 95       	ret
    3654:	e9 51       	subi	r30, 0x19	; 25
    3656:	fd 4f       	sbci	r31, 0xFD	; 253
    3658:	90 81       	ld	r25, Z
    365a:	99 23       	and	r25, r25
    365c:	19 f4       	brne	.+6      	; 0x3664 <Timer8Stopp_ISR+0x3e>
    365e:	81 e0       	ldi	r24, 0x01	; 1
    3660:	89 27       	eor	r24, r25
}
    3662:	08 95       	ret
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer8Stopp_ISR(uint8_t TimerN)
{
	return (Timer8_ISR_Flg[TimerN/8] &(1<<TimerN%8)) && Timer8_ISR[TimerN]==0;
    3664:	91 e0       	ldi	r25, 0x01	; 1
    3666:	81 e0       	ldi	r24, 0x01	; 1
    3668:	89 27       	eor	r24, r25
}
    366a:	08 95       	ret

0000366c <Timer8Stopp>:

// ~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer8Stopp(uint8_t TimerN)
{
	return (Timer8Flg[TimerN/8] &(1<<TimerN%8)) && Timer8[TimerN]==0;
    366c:	e8 2f       	mov	r30, r24
    366e:	e6 95       	lsr	r30
    3670:	e6 95       	lsr	r30
    3672:	e6 95       	lsr	r30
    3674:	f0 e0       	ldi	r31, 0x00	; 0
    3676:	e7 55       	subi	r30, 0x57	; 87
    3678:	fb 4f       	sbci	r31, 0xFB	; 251
    367a:	20 81       	ld	r18, Z
    367c:	e8 2f       	mov	r30, r24
    367e:	f0 e0       	ldi	r31, 0x00	; 0
    3680:	30 e0       	ldi	r19, 0x00	; 0
    3682:	cf 01       	movw	r24, r30
    3684:	87 70       	andi	r24, 0x07	; 7
    3686:	90 70       	andi	r25, 0x00	; 0
    3688:	02 c0       	rjmp	.+4      	; 0x368e <Timer8Stopp+0x22>
    368a:	35 95       	asr	r19
    368c:	27 95       	ror	r18
    368e:	8a 95       	dec	r24
    3690:	e2 f7       	brpl	.-8      	; 0x368a <Timer8Stopp+0x1e>
    3692:	20 fd       	sbrc	r18, 0
    3694:	02 c0       	rjmp	.+4      	; 0x369a <Timer8Stopp+0x2e>
    3696:	80 e0       	ldi	r24, 0x00	; 0
    3698:	08 95       	ret
    369a:	e1 51       	subi	r30, 0x11	; 17
    369c:	fd 4f       	sbci	r31, 0xFD	; 253
    369e:	90 81       	ld	r25, Z
    36a0:	99 23       	and	r25, r25
    36a2:	19 f4       	brne	.+6      	; 0x36aa <Timer8Stopp+0x3e>
    36a4:	81 e0       	ldi	r24, 0x01	; 1
    36a6:	89 27       	eor	r24, r25
}
    36a8:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer8Stopp(uint8_t TimerN)
{
	return (Timer8Flg[TimerN/8] &(1<<TimerN%8)) && Timer8[TimerN]==0;
    36aa:	91 e0       	ldi	r25, 0x01	; 1
    36ac:	81 e0       	ldi	r24, 0x01	; 1
    36ae:	89 27       	eor	r24, r25
}
    36b0:	08 95       	ret

000036b2 <Timer16Stopp>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    36b2:	4f b7       	in	r20, 0x3f	; 63
    36b4:	40 78       	andi	r20, 0x80	; 128
    36b6:	40 93 e6 02 	sts	0x02E6, r20
	cli();
    36ba:	f8 94       	cli
// ~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16Stopp(uint8_t TimerN)
{
	IntOff();
	uint8_t T_S = (Timer16Flg[TimerN/8] &(1<<TimerN%8)) && Timer16[TimerN]==0;
    36bc:	e8 2f       	mov	r30, r24
    36be:	e6 95       	lsr	r30
    36c0:	e6 95       	lsr	r30
    36c2:	e6 95       	lsr	r30
    36c4:	f0 e0       	ldi	r31, 0x00	; 0
    36c6:	eb 54       	subi	r30, 0x4B	; 75
    36c8:	fb 4f       	sbci	r31, 0xFB	; 251
    36ca:	20 81       	ld	r18, Z
    36cc:	e8 2f       	mov	r30, r24
    36ce:	f0 e0       	ldi	r31, 0x00	; 0
    36d0:	30 e0       	ldi	r19, 0x00	; 0
    36d2:	cf 01       	movw	r24, r30
    36d4:	87 70       	andi	r24, 0x07	; 7
    36d6:	90 70       	andi	r25, 0x00	; 0
    36d8:	02 c0       	rjmp	.+4      	; 0x36de <Timer16Stopp+0x2c>
    36da:	35 95       	asr	r19
    36dc:	27 95       	ror	r18
    36de:	8a 95       	dec	r24
    36e0:	e2 f7       	brpl	.-8      	; 0x36da <Timer16Stopp+0x28>
    36e2:	20 fd       	sbrc	r18, 0
    36e4:	06 c0       	rjmp	.+12     	; 0x36f2 <Timer16Stopp+0x40>
    36e6:	20 e0       	ldi	r18, 0x00	; 0

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    36e8:	44 23       	and	r20, r20
    36ea:	09 f0       	breq	.+2      	; 0x36ee <Timer16Stopp+0x3c>
		sei();
    36ec:	78 94       	sei
	IntOn();
	return T_S;
}
    36ee:	82 2f       	mov	r24, r18
    36f0:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16Stopp(uint8_t TimerN)
{
	IntOff();
	uint8_t T_S = (Timer16Flg[TimerN/8] &(1<<TimerN%8)) && Timer16[TimerN]==0;
    36f2:	ee 0f       	add	r30, r30
    36f4:	ff 1f       	adc	r31, r31
    36f6:	e9 5b       	subi	r30, 0xB9	; 185
    36f8:	fc 4f       	sbci	r31, 0xFC	; 252
    36fa:	80 81       	ld	r24, Z
    36fc:	91 81       	ldd	r25, Z+1	; 0x01
    36fe:	20 e0       	ldi	r18, 0x00	; 0
    3700:	89 2b       	or	r24, r25
    3702:	19 f4       	brne	.+6      	; 0x370a <Timer16Stopp+0x58>
    3704:	81 e0       	ldi	r24, 0x01	; 1
    3706:	28 27       	eor	r18, r24
    3708:	ef cf       	rjmp	.-34     	; 0x36e8 <Timer16Stopp+0x36>
    370a:	21 e0       	ldi	r18, 0x01	; 1
    370c:	81 e0       	ldi	r24, 0x01	; 1
    370e:	28 27       	eor	r18, r24
    3710:	eb cf       	rjmp	.-42     	; 0x36e8 <Timer16Stopp+0x36>

00003712 <Timer32Stopp>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3712:	4f b7       	in	r20, 0x3f	; 63
    3714:	40 78       	andi	r20, 0x80	; 128
    3716:	40 93 e6 02 	sts	0x02E6, r20
	cli();
    371a:	f8 94       	cli
// ~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer32Stopp(uint8_t TimerN)
{
	IntOff();
	uint8_t T_S = (Timer32Flg[TimerN/8] &(1<<TimerN%8)) && Timer32[TimerN]==0;
    371c:	e8 2f       	mov	r30, r24
    371e:	e6 95       	lsr	r30
    3720:	e6 95       	lsr	r30
    3722:	e6 95       	lsr	r30
    3724:	f0 e0       	ldi	r31, 0x00	; 0
    3726:	ee 53       	subi	r30, 0x3E	; 62
    3728:	fb 4f       	sbci	r31, 0xFB	; 251
    372a:	20 81       	ld	r18, Z
    372c:	e8 2f       	mov	r30, r24
    372e:	f0 e0       	ldi	r31, 0x00	; 0
    3730:	30 e0       	ldi	r19, 0x00	; 0
    3732:	cf 01       	movw	r24, r30
    3734:	87 70       	andi	r24, 0x07	; 7
    3736:	90 70       	andi	r25, 0x00	; 0
    3738:	02 c0       	rjmp	.+4      	; 0x373e <Timer32Stopp+0x2c>
    373a:	35 95       	asr	r19
    373c:	27 95       	ror	r18
    373e:	8a 95       	dec	r24
    3740:	e2 f7       	brpl	.-8      	; 0x373a <Timer32Stopp+0x28>
    3742:	20 fd       	sbrc	r18, 0
    3744:	06 c0       	rjmp	.+12     	; 0x3752 <Timer32Stopp+0x40>
    3746:	20 e0       	ldi	r18, 0x00	; 0

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3748:	44 23       	and	r20, r20
    374a:	09 f0       	breq	.+2      	; 0x374e <Timer32Stopp+0x3c>
		sei();
    374c:	78 94       	sei
	IntOn();
	return T_S;
}
    374e:	82 2f       	mov	r24, r18
    3750:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer32Stopp(uint8_t TimerN)
{
	IntOff();
	uint8_t T_S = (Timer32Flg[TimerN/8] &(1<<TimerN%8)) && Timer32[TimerN]==0;
    3752:	ee 0f       	add	r30, r30
    3754:	ff 1f       	adc	r31, r31
    3756:	ee 0f       	add	r30, r30
    3758:	ff 1f       	adc	r31, r31
    375a:	e9 5f       	subi	r30, 0xF9	; 249
    375c:	fb 4f       	sbci	r31, 0xFB	; 251
    375e:	80 81       	ld	r24, Z
    3760:	91 81       	ldd	r25, Z+1	; 0x01
    3762:	a2 81       	ldd	r26, Z+2	; 0x02
    3764:	b3 81       	ldd	r27, Z+3	; 0x03
    3766:	20 e0       	ldi	r18, 0x00	; 0
    3768:	00 97       	sbiw	r24, 0x00	; 0
    376a:	a1 05       	cpc	r26, r1
    376c:	b1 05       	cpc	r27, r1
    376e:	19 f4       	brne	.+6      	; 0x3776 <Timer32Stopp+0x64>
    3770:	81 e0       	ldi	r24, 0x01	; 1
    3772:	28 27       	eor	r18, r24
    3774:	e9 cf       	rjmp	.-46     	; 0x3748 <Timer32Stopp+0x36>
    3776:	21 e0       	ldi	r18, 0x01	; 1
    3778:	81 e0       	ldi	r24, 0x01	; 1
    377a:	28 27       	eor	r18, r24
    377c:	e5 cf       	rjmp	.-54     	; 0x3748 <Timer32Stopp+0x36>

0000377e <ResetTimer8_ISR>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    377e:	5f b7       	in	r21, 0x3f	; 63
    3780:	50 78       	andi	r21, 0x80	; 128
    3782:	50 93 e6 02 	sts	0x02E6, r21
	cli();
    3786:	f8 94       	cli
//~~~~~~~~~~~~~~~~~~~~~~~~~
void
ResetTimer8_ISR(uint8_t TimerN)
{
	IntOff();
	Timer8_ISR_Flg[TimerN/8] |=(1<<TimerN%8);
    3788:	e8 2f       	mov	r30, r24
    378a:	e6 95       	lsr	r30
    378c:	e6 95       	lsr	r30
    378e:	e6 95       	lsr	r30
    3790:	f0 e0       	ldi	r31, 0x00	; 0
    3792:	e9 55       	subi	r30, 0x59	; 89
    3794:	fb 4f       	sbci	r31, 0xFB	; 251
    3796:	40 81       	ld	r20, Z
    3798:	a8 2f       	mov	r26, r24
    379a:	b0 e0       	ldi	r27, 0x00	; 0
    379c:	9d 01       	movw	r18, r26
    379e:	27 70       	andi	r18, 0x07	; 7
    37a0:	30 70       	andi	r19, 0x00	; 0
    37a2:	81 e0       	ldi	r24, 0x01	; 1
    37a4:	90 e0       	ldi	r25, 0x00	; 0
    37a6:	02 c0       	rjmp	.+4      	; 0x37ac <ResetTimer8_ISR+0x2e>
    37a8:	88 0f       	add	r24, r24
    37aa:	99 1f       	adc	r25, r25
    37ac:	2a 95       	dec	r18
    37ae:	e2 f7       	brpl	.-8      	; 0x37a8 <ResetTimer8_ISR+0x2a>
    37b0:	48 2b       	or	r20, r24
    37b2:	40 83       	st	Z, r20

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    37b4:	55 23       	and	r21, r21
    37b6:	09 f0       	breq	.+2      	; 0x37ba <ResetTimer8_ISR+0x3c>
		sei();
    37b8:	78 94       	sei
	IntOn();
	Timer8_ISR[TimerN] = 0;
    37ba:	a9 51       	subi	r26, 0x19	; 25
    37bc:	bd 4f       	sbci	r27, 0xFD	; 253
    37be:	1c 92       	st	X, r1
}
    37c0:	08 95       	ret

000037c2 <ResetTimer8>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    37c2:	5f b7       	in	r21, 0x3f	; 63
    37c4:	50 78       	andi	r21, 0x80	; 128
    37c6:	50 93 e6 02 	sts	0x02E6, r21
	cli();
    37ca:	f8 94       	cli

void
ResetTimer8(uint8_t TimerN)
{
	IntOff();
	Timer8Flg[TimerN/8] |=(1<<TimerN%8);
    37cc:	e8 2f       	mov	r30, r24
    37ce:	e6 95       	lsr	r30
    37d0:	e6 95       	lsr	r30
    37d2:	e6 95       	lsr	r30
    37d4:	f0 e0       	ldi	r31, 0x00	; 0
    37d6:	e7 55       	subi	r30, 0x57	; 87
    37d8:	fb 4f       	sbci	r31, 0xFB	; 251
    37da:	40 81       	ld	r20, Z
    37dc:	a8 2f       	mov	r26, r24
    37de:	b0 e0       	ldi	r27, 0x00	; 0
    37e0:	9d 01       	movw	r18, r26
    37e2:	27 70       	andi	r18, 0x07	; 7
    37e4:	30 70       	andi	r19, 0x00	; 0
    37e6:	81 e0       	ldi	r24, 0x01	; 1
    37e8:	90 e0       	ldi	r25, 0x00	; 0
    37ea:	02 c0       	rjmp	.+4      	; 0x37f0 <ResetTimer8+0x2e>
    37ec:	88 0f       	add	r24, r24
    37ee:	99 1f       	adc	r25, r25
    37f0:	2a 95       	dec	r18
    37f2:	e2 f7       	brpl	.-8      	; 0x37ec <ResetTimer8+0x2a>
    37f4:	48 2b       	or	r20, r24
    37f6:	40 83       	st	Z, r20

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    37f8:	55 23       	and	r21, r21
    37fa:	09 f0       	breq	.+2      	; 0x37fe <ResetTimer8+0x3c>
		sei();
    37fc:	78 94       	sei
	IntOn();
	Timer8[TimerN] = 0;
    37fe:	a1 51       	subi	r26, 0x11	; 17
    3800:	bd 4f       	sbci	r27, 0xFD	; 253
    3802:	1c 92       	st	X, r1
}
    3804:	08 95       	ret

00003806 <ResetTimer16>:

//~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ResetTimer16(uint8_t TimerN)
{
    3806:	e8 2f       	mov	r30, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3808:	5f b7       	in	r21, 0x3f	; 63
    380a:	50 78       	andi	r21, 0x80	; 128
    380c:	50 93 e6 02 	sts	0x02E6, r21
	cli();
    3810:	f8 94       	cli
	IntOff();
	Timer16Flg[TimerN/8] |=1<<TimerN%8;
    3812:	a8 2f       	mov	r26, r24
    3814:	a6 95       	lsr	r26
    3816:	a6 95       	lsr	r26
    3818:	a6 95       	lsr	r26
    381a:	b0 e0       	ldi	r27, 0x00	; 0
    381c:	ab 54       	subi	r26, 0x4B	; 75
    381e:	bb 4f       	sbci	r27, 0xFB	; 251
    3820:	4c 91       	ld	r20, X
    3822:	f0 e0       	ldi	r31, 0x00	; 0
    3824:	9f 01       	movw	r18, r30
    3826:	27 70       	andi	r18, 0x07	; 7
    3828:	30 70       	andi	r19, 0x00	; 0
    382a:	81 e0       	ldi	r24, 0x01	; 1
    382c:	90 e0       	ldi	r25, 0x00	; 0
    382e:	02 c0       	rjmp	.+4      	; 0x3834 <ResetTimer16+0x2e>
    3830:	88 0f       	add	r24, r24
    3832:	99 1f       	adc	r25, r25
    3834:	2a 95       	dec	r18
    3836:	e2 f7       	brpl	.-8      	; 0x3830 <ResetTimer16+0x2a>
    3838:	48 2b       	or	r20, r24
    383a:	4c 93       	st	X, r20
	Timer16[TimerN] = 0;
    383c:	ee 0f       	add	r30, r30
    383e:	ff 1f       	adc	r31, r31
    3840:	e9 5b       	subi	r30, 0xB9	; 185
    3842:	fc 4f       	sbci	r31, 0xFC	; 252
    3844:	11 82       	std	Z+1, r1	; 0x01
    3846:	10 82       	st	Z, r1

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3848:	55 23       	and	r21, r21
    384a:	09 f0       	breq	.+2      	; 0x384e <ResetTimer16+0x48>
		sei();
    384c:	78 94       	sei
    384e:	08 95       	ret

00003850 <ResetTimer32>:
}

//~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ResetTimer32(uint8_t TimerN)
{
    3850:	e8 2f       	mov	r30, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3852:	5f b7       	in	r21, 0x3f	; 63
    3854:	50 78       	andi	r21, 0x80	; 128
    3856:	50 93 e6 02 	sts	0x02E6, r21
	cli();
    385a:	f8 94       	cli
	IntOff();
	Timer32Flg[TimerN/8] |=1<<TimerN%8;
    385c:	a8 2f       	mov	r26, r24
    385e:	a6 95       	lsr	r26
    3860:	a6 95       	lsr	r26
    3862:	a6 95       	lsr	r26
    3864:	b0 e0       	ldi	r27, 0x00	; 0
    3866:	ae 53       	subi	r26, 0x3E	; 62
    3868:	bb 4f       	sbci	r27, 0xFB	; 251
    386a:	4c 91       	ld	r20, X
    386c:	f0 e0       	ldi	r31, 0x00	; 0
    386e:	9f 01       	movw	r18, r30
    3870:	27 70       	andi	r18, 0x07	; 7
    3872:	30 70       	andi	r19, 0x00	; 0
    3874:	81 e0       	ldi	r24, 0x01	; 1
    3876:	90 e0       	ldi	r25, 0x00	; 0
    3878:	02 c0       	rjmp	.+4      	; 0x387e <ResetTimer32+0x2e>
    387a:	88 0f       	add	r24, r24
    387c:	99 1f       	adc	r25, r25
    387e:	2a 95       	dec	r18
    3880:	e2 f7       	brpl	.-8      	; 0x387a <ResetTimer32+0x2a>
    3882:	48 2b       	or	r20, r24
    3884:	4c 93       	st	X, r20
	Timer32[TimerN] = 0;
    3886:	ee 0f       	add	r30, r30
    3888:	ff 1f       	adc	r31, r31
    388a:	ee 0f       	add	r30, r30
    388c:	ff 1f       	adc	r31, r31
    388e:	e9 5f       	subi	r30, 0xF9	; 249
    3890:	fb 4f       	sbci	r31, 0xFB	; 251
    3892:	10 82       	st	Z, r1
    3894:	11 82       	std	Z+1, r1	; 0x01
    3896:	12 82       	std	Z+2, r1	; 0x02
    3898:	13 82       	std	Z+3, r1	; 0x03

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    389a:	55 23       	and	r21, r21
    389c:	09 f0       	breq	.+2      	; 0x38a0 <ResetTimer32+0x50>
		sei();
    389e:	78 94       	sei
    38a0:	08 95       	ret

000038a2 <GetTimer8_ISR>:

// ~~~~~~~~~~~~~~~~~~~~~~
uint8_t
GetTimer8_ISR(uint8_t TimerN)
{
	return Timer8_ISR[TimerN];
    38a2:	e7 ee       	ldi	r30, 0xE7	; 231
    38a4:	f2 e0       	ldi	r31, 0x02	; 2
    38a6:	e8 0f       	add	r30, r24
    38a8:	f1 1d       	adc	r31, r1
    38aa:	80 81       	ld	r24, Z
}
    38ac:	08 95       	ret

000038ae <GetTimer8>:
uint8_t
GetTimer8(uint8_t TimerN)
{
	return Timer8[TimerN];
    38ae:	ef ee       	ldi	r30, 0xEF	; 239
    38b0:	f2 e0       	ldi	r31, 0x02	; 2
    38b2:	e8 0f       	add	r30, r24
    38b4:	f1 1d       	adc	r31, r1
    38b6:	80 81       	ld	r24, Z
}
    38b8:	08 95       	ret

000038ba <GetTimer16>:

// ~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
GetTimer16(uint8_t TimerN)
{
    38ba:	e8 2f       	mov	r30, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    38bc:	8f b7       	in	r24, 0x3f	; 63
    38be:	80 78       	andi	r24, 0x80	; 128
    38c0:	80 93 e6 02 	sts	0x02E6, r24
	cli();
    38c4:	f8 94       	cli
	IntOff();
	uint16_t Time = Timer16[TimerN];
    38c6:	f0 e0       	ldi	r31, 0x00	; 0
    38c8:	ee 0f       	add	r30, r30
    38ca:	ff 1f       	adc	r31, r31
    38cc:	e9 5b       	subi	r30, 0xB9	; 185
    38ce:	fc 4f       	sbci	r31, 0xFC	; 252
    38d0:	01 90       	ld	r0, Z+
    38d2:	f0 81       	ld	r31, Z
    38d4:	e0 2d       	mov	r30, r0

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    38d6:	88 23       	and	r24, r24
    38d8:	09 f0       	breq	.+2      	; 0x38dc <GetTimer16+0x22>
		sei();
    38da:	78 94       	sei
	IntOn();
	return Time;
}
    38dc:	cf 01       	movw	r24, r30
    38de:	08 95       	ret

000038e0 <GetTimer32>:

// ~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
GetTimer32(uint8_t TimerN)
{
    38e0:	e8 2f       	mov	r30, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    38e2:	8f b7       	in	r24, 0x3f	; 63
    38e4:	80 78       	andi	r24, 0x80	; 128
    38e6:	80 93 e6 02 	sts	0x02E6, r24
	cli();
    38ea:	f8 94       	cli
	IntOff();
	uint32_t Time = Timer32[TimerN];
    38ec:	f0 e0       	ldi	r31, 0x00	; 0
    38ee:	ee 0f       	add	r30, r30
    38f0:	ff 1f       	adc	r31, r31
    38f2:	ee 0f       	add	r30, r30
    38f4:	ff 1f       	adc	r31, r31
    38f6:	e9 5f       	subi	r30, 0xF9	; 249
    38f8:	fb 4f       	sbci	r31, 0xFB	; 251
    38fa:	20 81       	ld	r18, Z
    38fc:	31 81       	ldd	r19, Z+1	; 0x01
    38fe:	42 81       	ldd	r20, Z+2	; 0x02
    3900:	53 81       	ldd	r21, Z+3	; 0x03

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3902:	88 23       	and	r24, r24
    3904:	09 f0       	breq	.+2      	; 0x3908 <GetTimer32+0x28>
		sei();
    3906:	78 94       	sei
	IntOn();
	return Time;
}
    3908:	b9 01       	movw	r22, r18
    390a:	ca 01       	movw	r24, r20
    390c:	08 95       	ret

0000390e <TimerAllocError>:
// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t TimerAllocError(void){
	return ( (VacantTimer8Sys >=  Timer8TotNumber) || (VacantTimer16Sys >=  Timer16TotNumber) || (VacantTimer32Sys >=  Timer32TotNumber) ||
    390e:	80 91 cc 02 	lds	r24, 0x02CC
    3912:	88 35       	cpi	r24, 0x58	; 88
    3914:	a8 f4       	brcc	.+42     	; 0x3940 <TimerAllocError+0x32>
    3916:	80 91 cd 02 	lds	r24, 0x02CD
    391a:	80 36       	cpi	r24, 0x60	; 96
    391c:	88 f4       	brcc	.+34     	; 0x3940 <TimerAllocError+0x32>
    391e:	80 91 ce 02 	lds	r24, 0x02CE
    3922:	88 32       	cpi	r24, 0x28	; 40
    3924:	68 f4       	brcc	.+26     	; 0x3940 <TimerAllocError+0x32>
    3926:	80 91 c9 02 	lds	r24, 0x02C9
    392a:	80 34       	cpi	r24, 0x40	; 64
    392c:	48 f4       	brcc	.+18     	; 0x3940 <TimerAllocError+0x32>
    392e:	80 91 ca 02 	lds	r24, 0x02CA
    3932:	88 34       	cpi	r24, 0x48	; 72
    3934:	28 f4       	brcc	.+10     	; 0x3940 <TimerAllocError+0x32>
    3936:	90 e0       	ldi	r25, 0x00	; 0
    3938:	80 91 cb 02 	lds	r24, 0x02CB
    393c:	80 32       	cpi	r24, 0x20	; 32
    393e:	08 f0       	brcs	.+2      	; 0x3942 <TimerAllocError+0x34>
    3940:	91 e0       	ldi	r25, 0x01	; 1
		 Timer8AllocErr() || Timer16AllocErr() || Timer32AllocErr() );
}
    3942:	89 2f       	mov	r24, r25
    3944:	08 95       	ret

00003946 <ScanCycleInit>:
}

uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    3946:	80 91 cc 02 	lds	r24, 0x02CC
	VacantTimer8Sys += n;
    394a:	8f 5f       	subi	r24, 0xFF	; 255
    394c:	80 93 cc 02 	sts	0x02CC, r24
    3950:	81 50       	subi	r24, 0x01	; 1

// ~~~~~~~~~~~~~~~~
void
ScanCycleInit(void)
{
	TD_Scan = Timer8SysAlloc(1);
    3952:	80 93 c8 04 	sts	0x04C8, r24
	StartTimer8(TD_Scan, 0xFF);
    3956:	6f ef       	ldi	r22, 0xFF	; 255
    3958:	0e 94 e2 19 	call	0x33c4	; 0x33c4 <StartTimer8>
}
    395c:	08 95       	ret

0000395e <__vector_17>:
#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
	ISR(TIMER1_COMPA_vect)
#elif defined (__AVR_ATxmega128A1__)
	ISR(TCC0_OVF_vect)
#endif
{
    395e:	1f 92       	push	r1
    3960:	0f 92       	push	r0
    3962:	0f b6       	in	r0, 0x3f	; 63
    3964:	0f 92       	push	r0
    3966:	0b b6       	in	r0, 0x3b	; 59
    3968:	0f 92       	push	r0
    396a:	11 24       	eor	r1, r1
    396c:	2f 93       	push	r18
    396e:	4f 93       	push	r20
    3970:	5f 93       	push	r21
    3972:	6f 93       	push	r22
    3974:	7f 93       	push	r23
    3976:	8f 93       	push	r24
    3978:	9f 93       	push	r25
    397a:	af 93       	push	r26
    397c:	bf 93       	push	r27
    397e:	ef 93       	push	r30
    3980:	ff 93       	push	r31
	TickCounter++;
    3982:	80 91 c9 04 	lds	r24, 0x04C9
    3986:	8f 5f       	subi	r24, 0xFF	; 255
    3988:	80 93 c9 04 	sts	0x04C9, r24
    398c:	40 e0       	ldi	r20, 0x00	; 0
    398e:	50 e0       	ldi	r21, 0x00	; 0
	uint8_t i;
	for (i=0; i<Timer8_ISR_TotNumber; i++)
			if (!(Timer8_ISR_Flg[i/8] &(1<<i%8)) && --Timer8_ISR[i]==0)
				Timer8_ISR_Flg[i/8] |=(1<<i%8);
    3990:	a1 e0       	ldi	r26, 0x01	; 1
    3992:	b0 e0       	ldi	r27, 0x00	; 0
#endif
{
	TickCounter++;
	uint8_t i;
	for (i=0; i<Timer8_ISR_TotNumber; i++)
			if (!(Timer8_ISR_Flg[i/8] &(1<<i%8)) && --Timer8_ISR[i]==0)
    3994:	80 91 a7 04 	lds	r24, 0x04A7
    3998:	ba 01       	movw	r22, r20
    399a:	67 70       	andi	r22, 0x07	; 7
    399c:	70 70       	andi	r23, 0x00	; 0
    399e:	90 e0       	ldi	r25, 0x00	; 0
    39a0:	06 2e       	mov	r0, r22
    39a2:	02 c0       	rjmp	.+4      	; 0x39a8 <__vector_17+0x4a>
    39a4:	95 95       	asr	r25
    39a6:	87 95       	ror	r24
    39a8:	0a 94       	dec	r0
    39aa:	e2 f7       	brpl	.-8      	; 0x39a4 <__vector_17+0x46>
    39ac:	80 fd       	sbrc	r24, 0
    39ae:	14 c0       	rjmp	.+40     	; 0x39d8 <__vector_17+0x7a>
    39b0:	fa 01       	movw	r30, r20
    39b2:	e9 51       	subi	r30, 0x19	; 25
    39b4:	fd 4f       	sbci	r31, 0xFD	; 253
    39b6:	80 81       	ld	r24, Z
    39b8:	81 50       	subi	r24, 0x01	; 1
    39ba:	80 83       	st	Z, r24
    39bc:	80 81       	ld	r24, Z
    39be:	88 23       	and	r24, r24
    39c0:	59 f4       	brne	.+22     	; 0x39d8 <__vector_17+0x7a>
				Timer8_ISR_Flg[i/8] |=(1<<i%8);
    39c2:	20 91 a7 04 	lds	r18, 0x04A7
    39c6:	cd 01       	movw	r24, r26
    39c8:	02 c0       	rjmp	.+4      	; 0x39ce <__vector_17+0x70>
    39ca:	88 0f       	add	r24, r24
    39cc:	99 1f       	adc	r25, r25
    39ce:	6a 95       	dec	r22
    39d0:	e2 f7       	brpl	.-8      	; 0x39ca <__vector_17+0x6c>
    39d2:	28 2b       	or	r18, r24
    39d4:	20 93 a7 04 	sts	0x04A7, r18
    39d8:	4f 5f       	subi	r20, 0xFF	; 255
    39da:	5f 4f       	sbci	r21, 0xFF	; 255
	ISR(TCC0_OVF_vect)
#endif
{
	TickCounter++;
	uint8_t i;
	for (i=0; i<Timer8_ISR_TotNumber; i++)
    39dc:	48 30       	cpi	r20, 0x08	; 8
    39de:	51 05       	cpc	r21, r1
    39e0:	c9 f6       	brne	.-78     	; 0x3994 <__vector_17+0x36>
				Timer8_ISR_Flg[i/8] |=(1<<i%8);

	#ifdef HIGH_SPEED_COUNTER
		HSC_Process();
	#endif
}
    39e2:	ff 91       	pop	r31
    39e4:	ef 91       	pop	r30
    39e6:	bf 91       	pop	r27
    39e8:	af 91       	pop	r26
    39ea:	9f 91       	pop	r25
    39ec:	8f 91       	pop	r24
    39ee:	7f 91       	pop	r23
    39f0:	6f 91       	pop	r22
    39f2:	5f 91       	pop	r21
    39f4:	4f 91       	pop	r20
    39f6:	2f 91       	pop	r18
    39f8:	0f 90       	pop	r0
    39fa:	0b be       	out	0x3b, r0	; 59
    39fc:	0f 90       	pop	r0
    39fe:	0f be       	out	0x3f, r0	; 63
    3a00:	0f 90       	pop	r0
    3a02:	1f 90       	pop	r1
    3a04:	18 95       	reti

00003a06 <TimeCycle>:
// ~~~~~~~~~~~~
void
TimeCycle(void)
{
	// WDT
	wdt_reset();
    3a06:	a8 95       	wdr

	// Scan cycle
	ScanCount++;
    3a08:	80 91 68 07 	lds	r24, 0x0768
    3a0c:	90 91 69 07 	lds	r25, 0x0769
    3a10:	01 96       	adiw	r24, 0x01	; 1
    3a12:	90 93 69 07 	sts	0x0769, r25
    3a16:	80 93 68 07 	sts	0x0768, r24
	if ((ScanCycle=0xFF-Timer8[TD_Scan])>MaxScanCycle)
    3a1a:	90 91 c8 04 	lds	r25, 0x04C8
    3a1e:	e9 2f       	mov	r30, r25
    3a20:	f0 e0       	ldi	r31, 0x00	; 0
    3a22:	e1 51       	subi	r30, 0x11	; 17
    3a24:	fd 4f       	sbci	r31, 0xFD	; 253
    3a26:	e0 81       	ld	r30, Z
    3a28:	e0 95       	com	r30
    3a2a:	e0 93 64 07 	sts	0x0764, r30
    3a2e:	80 91 a9 06 	lds	r24, 0x06A9
    3a32:	8e 17       	cp	r24, r30
    3a34:	10 f4       	brcc	.+4      	; 0x3a3a <TimeCycle+0x34>
		MaxScanCycle = ScanCycle;
    3a36:	e0 93 a9 06 	sts	0x06A9, r30
	StartTimer8(TD_Scan, 0xFF);
    3a3a:	89 2f       	mov	r24, r25
    3a3c:	6f ef       	ldi	r22, 0xFF	; 255
    3a3e:	0e 94 e2 19 	call	0x33c4	; 0x33c4 <StartTimer8>
}
    3a42:	08 95       	ret

00003a44 <MaxScanCycle_Clear>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
void
MaxScanCycle_Clear(void)
{
	MaxScanCycle = 0;
    3a44:	10 92 a9 06 	sts	0x06A9, r1
}
    3a48:	08 95       	ret

00003a4a <Delay_ms>:

// ~~~~~~~~~~~~~~~~~~~~
void
Delay_ms(uint8_t Delay)
{
	while (Delay--)
    3a4a:	88 23       	and	r24, r24
    3a4c:	39 f0       	breq	.+14     	; 0x3a5c <Delay_ms+0x12>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3a4e:	20 ea       	ldi	r18, 0xA0	; 160
    3a50:	3f e0       	ldi	r19, 0x0F	; 15
    3a52:	f9 01       	movw	r30, r18
    3a54:	31 97       	sbiw	r30, 0x01	; 1
    3a56:	f1 f7       	brne	.-4      	; 0x3a54 <Delay_ms+0xa>
    3a58:	81 50       	subi	r24, 0x01	; 1
    3a5a:	d9 f7       	brne	.-10     	; 0x3a52 <Delay_ms+0x8>
    3a5c:	08 95       	ret

00003a5e <Delay_us>:
{
	/*uint8_t i;
	for(i=Delay/Delay_us_Max; i; i--)
		_delay_us(Delay_us_Max);*/
	//_delay_us(Delay%Delay_us_Max);
	Delay *= .8;	// By trial
    3a5e:	a0 e0       	ldi	r26, 0x00	; 0
    3a60:	b0 e0       	ldi	r27, 0x00	; 0
    3a62:	bc 01       	movw	r22, r24
    3a64:	cd 01       	movw	r24, r26
    3a66:	0e 94 93 78 	call	0xf126	; 0xf126 <__floatunsisf>
    3a6a:	2d ec       	ldi	r18, 0xCD	; 205
    3a6c:	3c ec       	ldi	r19, 0xCC	; 204
    3a6e:	4c e4       	ldi	r20, 0x4C	; 76
    3a70:	5f e3       	ldi	r21, 0x3F	; 63
    3a72:	0e 94 d0 78 	call	0xf1a0	; 0xf1a0 <__mulsf3>
    3a76:	0e 94 68 7d 	call	0xfad0	; 0xfad0 <__fixunssfsi>
    3a7a:	cb 01       	movw	r24, r22
	while (Delay--)
    3a7c:	67 2b       	or	r22, r23
    3a7e:	31 f0       	breq	.+12     	; 0x3a8c <Delay_us+0x2e>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3a80:	35 e0       	ldi	r19, 0x05	; 5
    3a82:	23 2f       	mov	r18, r19
    3a84:	2a 95       	dec	r18
    3a86:	f1 f7       	brne	.-4      	; 0x3a84 <Delay_us+0x26>
    3a88:	01 97       	sbiw	r24, 0x01	; 1
    3a8a:	d9 f7       	brne	.-10     	; 0x3a82 <Delay_us+0x24>
    3a8c:	08 95       	ret

00003a8e <MB_PLC_Init>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#if defined vmd2_3
	void MB_PLC_Init(void)
	{
		// RS485
		DDRE |=(1<<PE2); PORTE &=~(1<<PE2);
    3a8e:	6a 9a       	sbi	0x0d, 2	; 13
    3a90:	72 98       	cbi	0x0e, 2	; 14
		DDRD |=(1<<PD4); PORTD &=~(1<<PD4);
    3a92:	54 9a       	sbi	0x0a, 4	; 10
    3a94:	5c 98       	cbi	0x0b, 4	; 11
	#ifndef GSM
		DDRL |=(1<<PL5); PORTL &=~(1<<PL5);
	#endif
	}
    3a96:	08 95       	ret

00003a98 <RS485_0>:
	void RS485_0(void) {PORTE ^=(1<<PE2);}
    3a98:	8e b1       	in	r24, 0x0e	; 14
    3a9a:	94 e0       	ldi	r25, 0x04	; 4
    3a9c:	89 27       	eor	r24, r25
    3a9e:	8e b9       	out	0x0e, r24	; 14
    3aa0:	08 95       	ret

00003aa2 <RS485_1>:
	void RS485_1(void) {PORTD ^=(1<<PD4);}
    3aa2:	8b b1       	in	r24, 0x0b	; 11
    3aa4:	90 e1       	ldi	r25, 0x10	; 16
    3aa6:	89 27       	eor	r24, r25
    3aa8:	8b b9       	out	0x0b, r24	; 11
    3aaa:	08 95       	ret

00003aac <MB_LED0>:
	}
	void RS485_0(void) {PORTE ^=(1<<PE2);}
	void RS485_1(void) {PORTC ^=(1<<PC0);}
#endif

void MB_LED0(void) {}
    3aac:	08 95       	ret

00003aae <MB_LED1>:
void MB_LED1(void) {}
    3aae:	08 95       	ret

00003ab0 <MB_LED2>:
void MB_LED2(void) {}
    3ab0:	08 95       	ret

00003ab2 <MB_LED_Err_On_0>:

void MB_LED_Err_On_0(void)	{}
    3ab2:	08 95       	ret

00003ab4 <MB_LED_Err_Off_0>:
void MB_LED_Err_Off_0(void)	{}
    3ab4:	08 95       	ret

00003ab6 <MB_LED_Err_On_1>:
void MB_LED_Err_On_1(void)	{}
    3ab6:	08 95       	ret

00003ab8 <MB_LED_Err_Off_1>:
void MB_LED_Err_Off_1(void)	{}	
    3ab8:	08 95       	ret

00003aba <MB_LED_Err_On_2>:
void MB_LED_Err_On_2(void)	{}
    3aba:	08 95       	ret

00003abc <MB_LED_Err_Off_2>:
void MB_LED_Err_Off_2(void)	{}
    3abc:	08 95       	ret

00003abe <PWM_Init>:

// ~~~~~~~~~~~
void
PWM_Init(void)
{
	TCCR3A = (1<<COM3A1) | (0<<COM3A0) | (1<<COM3B1) | (0<<COM3B0) | (0<<COM3C1) | (0<<COM3C0) | (1<<WGM31) | (0<<WGM30);
    3abe:	32 ea       	ldi	r19, 0xA2	; 162
    3ac0:	30 93 90 00 	sts	0x0090, r19
	TCCR3B = (0<<CS32) | (0<<CS31) | (1<<CS30) | (1<<WGM33) | (1<<WGM32);	// Fpwm = 244Hz
    3ac4:	29 e1       	ldi	r18, 0x19	; 25
    3ac6:	20 93 91 00 	sts	0x0091, r18
	ICR3 = PWM_PERIOD_TC3;
    3aca:	8f ef       	ldi	r24, 0xFF	; 255
    3acc:	9f ef       	ldi	r25, 0xFF	; 255
    3ace:	90 93 97 00 	sts	0x0097, r25
    3ad2:	80 93 96 00 	sts	0x0096, r24
	DDRE |= (1<<PE3) | (1<<PE4);
    3ad6:	8d b1       	in	r24, 0x0d	; 13
    3ad8:	88 61       	ori	r24, 0x18	; 24
    3ada:	8d b9       	out	0x0d, r24	; 13

	TCCR5A = (1<<COM5A1) | (0<<COM5A0) | (1<<COM5B1) | (0<<COM5B0) | (0<<COM5C1) | (0<<COM5C0) | (1<<WGM51) | (0<<WGM50);
    3adc:	30 93 20 01 	sts	0x0120, r19
	TCCR5B = (0<<CS52) | (0<<CS51) | (1<<CS50) | (1<<WGM53) | (1<<WGM52);	// Fpwm = 244Hz
    3ae0:	20 93 21 01 	sts	0x0121, r18
	ICR5 = PWM_PERIOD_TC5;
    3ae4:	8e e7       	ldi	r24, 0x7E	; 126
    3ae6:	9c e0       	ldi	r25, 0x0C	; 12
    3ae8:	90 93 27 01 	sts	0x0127, r25
    3aec:	80 93 26 01 	sts	0x0126, r24
	DDRL |= (1<<PL3) | (1<<PL4);
    3af0:	ea e0       	ldi	r30, 0x0A	; 10
    3af2:	f1 e0       	ldi	r31, 0x01	; 1
    3af4:	80 81       	ld	r24, Z
    3af6:	88 61       	ori	r24, 0x18	; 24
    3af8:	80 83       	st	Z, r24
}
    3afa:	08 95       	ret

00003afc <PWM_Out>:
void
PWM_Out(void)
{
	uint16_t Buf;

	Buf = Coef_AO_PWM_TC3*DAC_Output[0];
    3afc:	60 91 85 07 	lds	r22, 0x0785
    3b00:	70 91 86 07 	lds	r23, 0x0786
    3b04:	80 e0       	ldi	r24, 0x00	; 0
    3b06:	90 e0       	ldi	r25, 0x00	; 0
    3b08:	0e 94 93 78 	call	0xf126	; 0xf126 <__floatunsisf>
    3b0c:	28 e8       	ldi	r18, 0x88	; 136
    3b0e:	3f e1       	ldi	r19, 0x1F	; 31
    3b10:	40 e8       	ldi	r20, 0x80	; 128
    3b12:	52 e4       	ldi	r21, 0x42	; 66
    3b14:	0e 94 d0 78 	call	0xf1a0	; 0xf1a0 <__mulsf3>
    3b18:	0e 94 68 7d 	call	0xfad0	; 0xfad0 <__fixunssfsi>
    3b1c:	26 2f       	mov	r18, r22

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3b1e:	9f b7       	in	r25, 0x3f	; 63
	cli();
    3b20:	f8 94       	cli
	IntOff();
	OCR3AH = Buf>>8;
    3b22:	70 93 99 00 	sts	0x0099, r23
	OCR3AL = Buf;
    3b26:	20 93 98 00 	sts	0x0098, r18

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3b2a:	97 ff       	sbrs	r25, 7
    3b2c:	01 c0       	rjmp	.+2      	; 0x3b30 <PWM_Out+0x34>
		sei();
    3b2e:	78 94       	sei
	IntOn();

	Buf = Coef_AO_PWM_TC3*DAC_Output[1];
    3b30:	60 91 87 07 	lds	r22, 0x0787
    3b34:	70 91 88 07 	lds	r23, 0x0788
    3b38:	80 e0       	ldi	r24, 0x00	; 0
    3b3a:	90 e0       	ldi	r25, 0x00	; 0
    3b3c:	0e 94 93 78 	call	0xf126	; 0xf126 <__floatunsisf>
    3b40:	28 e8       	ldi	r18, 0x88	; 136
    3b42:	3f e1       	ldi	r19, 0x1F	; 31
    3b44:	40 e8       	ldi	r20, 0x80	; 128
    3b46:	52 e4       	ldi	r21, 0x42	; 66
    3b48:	0e 94 d0 78 	call	0xf1a0	; 0xf1a0 <__mulsf3>
    3b4c:	0e 94 68 7d 	call	0xfad0	; 0xfad0 <__fixunssfsi>
    3b50:	26 2f       	mov	r18, r22

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3b52:	9f b7       	in	r25, 0x3f	; 63
	cli();
    3b54:	f8 94       	cli
	IntOff();
	OCR3BH = Buf>>8;
    3b56:	70 93 9b 00 	sts	0x009B, r23
	OCR3BL = Buf;
    3b5a:	20 93 9a 00 	sts	0x009A, r18

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3b5e:	97 ff       	sbrs	r25, 7
    3b60:	01 c0       	rjmp	.+2      	; 0x3b64 <PWM_Out+0x68>
		sei();
    3b62:	78 94       	sei
	IntOn();


	Buf = Coef_AO_PWM_TC5*DAC_Output[2];
    3b64:	60 91 89 07 	lds	r22, 0x0789
    3b68:	70 91 8a 07 	lds	r23, 0x078A
    3b6c:	80 e0       	ldi	r24, 0x00	; 0
    3b6e:	90 e0       	ldi	r25, 0x00	; 0
    3b70:	0e 94 93 78 	call	0xf126	; 0xf126 <__floatunsisf>
    3b74:	25 e0       	ldi	r18, 0x05	; 5
    3b76:	32 e1       	ldi	r19, 0x12	; 18
    3b78:	48 e4       	ldi	r20, 0x48	; 72
    3b7a:	50 e4       	ldi	r21, 0x40	; 64
    3b7c:	0e 94 d0 78 	call	0xf1a0	; 0xf1a0 <__mulsf3>
    3b80:	0e 94 68 7d 	call	0xfad0	; 0xfad0 <__fixunssfsi>
    3b84:	26 2f       	mov	r18, r22

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3b86:	9f b7       	in	r25, 0x3f	; 63
	cli();
    3b88:	f8 94       	cli
	IntOff();
	OCR5AH = Buf>>8;
    3b8a:	70 93 29 01 	sts	0x0129, r23
	OCR5AL = Buf;
    3b8e:	20 93 28 01 	sts	0x0128, r18

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3b92:	97 ff       	sbrs	r25, 7
    3b94:	01 c0       	rjmp	.+2      	; 0x3b98 <PWM_Out+0x9c>
		sei();
    3b96:	78 94       	sei
	IntOn();

	Buf = Coef_AO_PWM_TC5*DAC_Output[3];
    3b98:	60 91 8b 07 	lds	r22, 0x078B
    3b9c:	70 91 8c 07 	lds	r23, 0x078C
    3ba0:	80 e0       	ldi	r24, 0x00	; 0
    3ba2:	90 e0       	ldi	r25, 0x00	; 0
    3ba4:	0e 94 93 78 	call	0xf126	; 0xf126 <__floatunsisf>
    3ba8:	25 e0       	ldi	r18, 0x05	; 5
    3baa:	32 e1       	ldi	r19, 0x12	; 18
    3bac:	48 e4       	ldi	r20, 0x48	; 72
    3bae:	50 e4       	ldi	r21, 0x40	; 64
    3bb0:	0e 94 d0 78 	call	0xf1a0	; 0xf1a0 <__mulsf3>
    3bb4:	0e 94 68 7d 	call	0xfad0	; 0xfad0 <__fixunssfsi>
    3bb8:	26 2f       	mov	r18, r22

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3bba:	8f b7       	in	r24, 0x3f	; 63
    3bbc:	80 78       	andi	r24, 0x80	; 128
    3bbe:	80 93 e6 02 	sts	0x02E6, r24
	cli();
    3bc2:	f8 94       	cli
	IntOff();
	OCR5BH = Buf>>8;
    3bc4:	70 93 2b 01 	sts	0x012B, r23
	OCR5BL = Buf;
    3bc8:	20 93 2a 01 	sts	0x012A, r18

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3bcc:	88 23       	and	r24, r24
    3bce:	09 f0       	breq	.+2      	; 0x3bd2 <PWM_Out+0xd6>
		sei();
    3bd0:	78 94       	sei
    3bd2:	08 95       	ret

00003bd4 <ADC_In>:
}

// ~~~~~~~~~
uint8_t
ADC_In(void)
{
    3bd4:	1f 93       	push	r17

// ~~~~~~~~~~~~~~~
inline static void
ADC_Select(void)
{
	SPCR |=(1<<CPOL);
    3bd6:	8c b5       	in	r24, 0x2c	; 44
    3bd8:	88 60       	ori	r24, 0x08	; 8
    3bda:	8c bd       	out	0x2c, r24	; 44
	#ifdef CS_ADC
		cli();
    3bdc:	f8 94       	cli
		PortCS_ADC &=~CS_ADC;
    3bde:	80 91 02 01 	lds	r24, 0x0102
    3be2:	87 7f       	andi	r24, 0xF7	; 247
    3be4:	80 93 02 01 	sts	0x0102, r24
		sei();
    3be8:	78 94       	sei
ADC_In(void)
{
	uint8_t Chan = ADC_Reg;
	ADC_Select();

	switch(ADC_Phase) {
    3bea:	80 91 1c 0b 	lds	r24, 0x0B1C
    3bee:	81 30       	cpi	r24, 0x01	; 1
    3bf0:	09 f4       	brne	.+2      	; 0x3bf4 <ADC_In+0x20>
    3bf2:	ec c0       	rjmp	.+472    	; 0x3dcc <ADC_In+0x1f8>
    3bf4:	81 30       	cpi	r24, 0x01	; 1
    3bf6:	30 f5       	brcc	.+76     	; 0x3c44 <ADC_In+0x70>

// ~~~~~~~~~~~~~~~
inline static void
ADC_Rst(void)
{
	cli();
    3bf8:	f8 94       	cli
	PortRESET_PER &=~RESET_PER;
    3bfa:	80 91 02 01 	lds	r24, 0x0102
    3bfe:	8f 7e       	andi	r24, 0xEF	; 239
    3c00:	80 93 02 01 	sts	0x0102, r24
	sei();
    3c04:	78 94       	sei
    3c06:	85 e0       	ldi	r24, 0x05	; 5
    3c08:	8a 95       	dec	r24
    3c0a:	f1 f7       	brne	.-4      	; 0x3c08 <ADC_In+0x34>
	_delay_us(1);							// 100 ns needs
	cli();
    3c0c:	f8 94       	cli
	PortRESET_PER |=RESET_PER;
    3c0e:	80 91 02 01 	lds	r24, 0x0102
    3c12:	80 61       	ori	r24, 0x10	; 16
    3c14:	80 93 02 01 	sts	0x0102, r24
	sei();
    3c18:	78 94       	sei
	StartTimer8_ISR(TD_ADC, 4);		// 16 ms needs
    3c1a:	80 91 ef 06 	lds	r24, 0x06EF
    3c1e:	64 e0       	ldi	r22, 0x04	; 4
	WaitSPI();
	SPDR = SR;
	WaitSPI();
	SPDR = SetpVal(CaliMode) &~ADC_FSYNC;
	WaitSPI();
	StartTimer8_ISR(TD_ADC, 36);
    3c20:	0e 94 a7 19 	call	0x334e	; 0x334e <StartTimer8_ISR>
	ADC_Phase++;
    3c24:	80 91 1c 0b 	lds	r24, 0x0B1C
    3c28:	8f 5f       	subi	r24, 0xFF	; 255
    3c2a:	80 93 1c 0b 	sts	0x0B1C, r24
    3c2e:	17 e0       	ldi	r17, 0x07	; 7
// ~~~~~~~~~~~~~~~
inline static void
ADC_Desel(void)
{
	#ifdef CS_ADC
		cli();
    3c30:	f8 94       	cli
		PortCS_ADC |=CS_ADC;
    3c32:	80 91 02 01 	lds	r24, 0x0102
    3c36:	88 60       	ori	r24, 0x08	; 8
    3c38:	80 93 02 01 	sts	0x0102, r24
		sei();
    3c3c:	78 94       	sei
			IntOn();
		}
	#endif

	return Chan;
}
    3c3e:	81 2f       	mov	r24, r17
    3c40:	1f 91       	pop	r17
    3c42:	08 95       	ret
ADC_In(void)
{
	uint8_t Chan = ADC_Reg;
	ADC_Select();

	switch(ADC_Phase) {
    3c44:	82 30       	cpi	r24, 0x02	; 2
    3c46:	09 f4       	brne	.+2      	; 0x3c4a <ADC_In+0x76>
    3c48:	d2 c0       	rjmp	.+420    	; 0x3dee <ADC_In+0x21a>
    3c4a:	83 30       	cpi	r24, 0x03	; 3
    3c4c:	11 f0       	breq	.+4      	; 0x3c52 <ADC_In+0x7e>
				StartTimer8_ISR(TD_ADC, ADC10ms);
			}
		}
		else if(Timer8Stopp_ISR(TD_ADC)) {
			ADC_ReadFail++;
			ADC_Phase = RST;
    3c4e:	17 e0       	ldi	r17, 0x07	; 7
    3c50:	ef cf       	rjmp	.-34     	; 0x3c30 <ADC_In+0x5c>
		default:
			SPDR = ADC_IN1(Reg);
			break;
		}
	#else
		SPDR = ADC_IN1(Reg);
    3c52:	88 e0       	ldi	r24, 0x08	; 8
    3c54:	8e bd       	out	0x2e, r24	; 46

// ~~~~~~~~~~~
static void
WaitADC2(void)
{
	WaitSPI();
    3c56:	0d b4       	in	r0, 0x2d	; 45
    3c58:	07 fe       	sbrs	r0, 7
    3c5a:	fd cf       	rjmp	.-6      	; 0x3c56 <ADC_In+0x82>
	SPDR = 0;
    3c5c:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    3c5e:	0d b4       	in	r0, 0x2d	; 45
    3c60:	07 fe       	sbrs	r0, 7
    3c62:	fd cf       	rjmp	.-6      	; 0x3c5e <ADC_In+0x8a>
			StartTimer8_ISR(TD_ADC, ADC10ms);
		break;
	case READ:
		ADC_IN(CommReg);
		WaitADC2();
		if(!(SPDR &ADC_DRDY)) {
    3c64:	0e b4       	in	r0, 0x2e	; 46
    3c66:	07 fc       	sbrc	r0, 7
    3c68:	da c0       	rjmp	.+436    	; 0x3e1e <ADC_In+0x24a>
		default:
			SPDR = ADC_IN1(Reg);
			break;
		}
	#else
		SPDR = ADC_IN1(Reg);
    3c6a:	88 e3       	ldi	r24, 0x38	; 56
    3c6c:	8e bd       	out	0x2e, r24	; 46

// ~~~~~~~~~~~
static void
WaitADC2(void)
{
	WaitSPI();
    3c6e:	0d b4       	in	r0, 0x2d	; 45
    3c70:	07 fe       	sbrs	r0, 7
    3c72:	fd cf       	rjmp	.-6      	; 0x3c6e <ADC_In+0x9a>
	SPDR = 0;
    3c74:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    3c76:	0d b4       	in	r0, 0x2d	; 45
    3c78:	07 fe       	sbrs	r0, 7
    3c7a:	fd cf       	rjmp	.-6      	; 0x3c76 <ADC_In+0xa2>
		WaitADC2();
		if(!(SPDR &ADC_DRDY)) {
			uint16_t Buf;
			ADC_IN(DataReg);
			WaitADC2();
			Buf = SPDR<<8;
    3c7c:	3e b5       	in	r19, 0x2e	; 46

// ~~~~~~~~~~~
static void
WaitADC1(void)
{
	SPDR = 0;
    3c7e:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    3c80:	0d b4       	in	r0, 0x2d	; 45
    3c82:	07 fe       	sbrs	r0, 7
    3c84:	fd cf       	rjmp	.-6      	; 0x3c80 <ADC_In+0xac>
			uint16_t Buf;
			ADC_IN(DataReg);
			WaitADC2();
			Buf = SPDR<<8;
			WaitADC1();
			Buf += SPDR;
    3c86:	2e b5       	in	r18, 0x2e	; 46
		WaitADC2();
		if(!(SPDR &ADC_DRDY)) {
			uint16_t Buf;
			ADC_IN(DataReg);
			WaitADC2();
			Buf = SPDR<<8;
    3c88:	93 2f       	mov	r25, r19
    3c8a:	80 e0       	ldi	r24, 0x00	; 0
			WaitADC1();
			Buf += SPDR;
    3c8c:	ac 01       	movw	r20, r24
    3c8e:	42 0f       	add	r20, r18
    3c90:	51 1d       	adc	r21, r1
    3c92:	9a 01       	movw	r18, r20
			#ifdef ADC_Ref_Chan
				if (ADC_Chan==sizeof(Mux)-1 && ADC_Input[sizeof(Mux)-1]!=0 && (Buf<ADC_Ref-ADC_Ref_d || Buf>ADC_Ref+ADC_Ref_d)) {
    3c94:	10 91 c4 08 	lds	r17, 0x08C4
    3c98:	16 30       	cpi	r17, 0x06	; 6
    3c9a:	09 f4       	brne	.+2      	; 0x3c9e <ADC_In+0xca>
    3c9c:	19 c1       	rjmp	.+562    	; 0x3ed0 <ADC_In+0x2fc>
		default:
			SPDR = ADC_IN1(Reg);
			break;
		}
	#else
		SPDR = ADC_IN1(Reg);
    3c9e:	80 e1       	ldi	r24, 0x10	; 16
    3ca0:	8e bd       	out	0x2e, r24	; 46
{
	Scale *Scl;
	int8_t i;

	ADC_IN(SetpReg);
	WaitSPI();
    3ca2:	0d b4       	in	r0, 0x2d	; 45
    3ca4:	07 fe       	sbrs	r0, 7
    3ca6:	fd cf       	rjmp	.-6      	; 0x3ca2 <ADC_In+0xce>
	SPDR = SetpVal(NormMode) |ADC_FSYNC;
    3ca8:	87 e0       	ldi	r24, 0x07	; 7
    3caa:	8e bd       	out	0x2e, r24	; 46
	WaitSPI();
    3cac:	0d b4       	in	r0, 0x2d	; 45
    3cae:	07 fe       	sbrs	r0, 7
    3cb0:	fd cf       	rjmp	.-6      	; 0x3cac <ADC_In+0xd8>
	ADC_Time = ADC10ms-Timer8_ISR[TD_ADC];
    3cb2:	40 91 ef 06 	lds	r20, 0x06EF
    3cb6:	e4 2f       	mov	r30, r20
    3cb8:	f0 e0       	ldi	r31, 0x00	; 0
    3cba:	e9 51       	subi	r30, 0x19	; 25
    3cbc:	fd 4f       	sbci	r31, 0xFD	; 253
    3cbe:	90 81       	ld	r25, Z
    3cc0:	84 e1       	ldi	r24, 0x14	; 20
    3cc2:	89 1b       	sub	r24, r25
    3cc4:	80 93 ab 06 	sts	0x06AB, r24
		default:
			SPDR = ADC_IN1(Reg);
			break;
		}
	#else
		SPDR = ADC_IN1(Reg);
    3cc8:	88 e6       	ldi	r24, 0x68	; 104
    3cca:	8e bd       	out	0x2e, r24	; 46

// ~~~~~~~~~~~
static void
WaitADC2(void)
{
	WaitSPI();
    3ccc:	0d b4       	in	r0, 0x2d	; 45
    3cce:	07 fe       	sbrs	r0, 7
    3cd0:	fd cf       	rjmp	.-6      	; 0x3ccc <ADC_In+0xf8>
	SPDR = 0;
    3cd2:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    3cd4:	0d b4       	in	r0, 0x2d	; 45
    3cd6:	07 fe       	sbrs	r0, 7
    3cd8:	fd cf       	rjmp	.-6      	; 0x3cd4 <ADC_In+0x100>
    3cda:	e1 e2       	ldi	r30, 0x21	; 33
    3cdc:	fc e0       	ldi	r31, 0x0C	; 12
		Scl=&ADC_Scale1;
	#endif
	ADC_IN(ZeroReg);
	WaitADC2();
	for(i=2; i>=0; i--) {
		Scl->Zero[i] = SPDR;
    3cde:	8e b5       	in	r24, 0x2e	; 46
    3ce0:	80 83       	st	Z, r24

// ~~~~~~~~~~~
static void
WaitADC1(void)
{
	SPDR = 0;
    3ce2:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    3ce4:	0d b4       	in	r0, 0x2d	; 45
    3ce6:	07 fe       	sbrs	r0, 7
    3ce8:	fd cf       	rjmp	.-6      	; 0x3ce4 <ADC_In+0x110>
    3cea:	31 97       	sbiw	r30, 0x01	; 1
	#else
		Scl=&ADC_Scale1;
	#endif
	ADC_IN(ZeroReg);
	WaitADC2();
	for(i=2; i>=0; i--) {
    3cec:	8c e0       	ldi	r24, 0x0C	; 12
    3cee:	ee 31       	cpi	r30, 0x1E	; 30
    3cf0:	f8 07       	cpc	r31, r24
    3cf2:	a9 f7       	brne	.-22     	; 0x3cde <ADC_In+0x10a>

// ~~~~~~~~~~~
static void
WaitADC1(void)
{
	SPDR = 0;
    3cf4:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    3cf6:	0d b4       	in	r0, 0x2d	; 45
    3cf8:	07 fe       	sbrs	r0, 7
    3cfa:	fd cf       	rjmp	.-6      	; 0x3cf6 <ADC_In+0x122>
		default:
			SPDR = ADC_IN1(Reg);
			break;
		}
	#else
		SPDR = ADC_IN1(Reg);
    3cfc:	88 e7       	ldi	r24, 0x78	; 120
    3cfe:	8e bd       	out	0x2e, r24	; 46

// ~~~~~~~~~~~
static void
WaitADC2(void)
{
	WaitSPI();
    3d00:	0d b4       	in	r0, 0x2d	; 45
    3d02:	07 fe       	sbrs	r0, 7
    3d04:	fd cf       	rjmp	.-6      	; 0x3d00 <ADC_In+0x12c>
	SPDR = 0;
    3d06:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    3d08:	0d b4       	in	r0, 0x2d	; 45
    3d0a:	07 fe       	sbrs	r0, 7
    3d0c:	fd cf       	rjmp	.-6      	; 0x3d08 <ADC_In+0x134>
    3d0e:	e4 e2       	ldi	r30, 0x24	; 36
    3d10:	fc e0       	ldi	r31, 0x0C	; 12
	}
	WaitADC1();
	ADC_IN(FullReg);
	WaitADC2();
	for(i=2; i>=0; i--) {
		Scl->Full[i] = SPDR;
    3d12:	8e b5       	in	r24, 0x2e	; 46
    3d14:	80 83       	st	Z, r24

// ~~~~~~~~~~~
static void
WaitADC1(void)
{
	SPDR = 0;
    3d16:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    3d18:	0d b4       	in	r0, 0x2d	; 45
    3d1a:	07 fe       	sbrs	r0, 7
    3d1c:	fd cf       	rjmp	.-6      	; 0x3d18 <ADC_In+0x144>
    3d1e:	31 97       	sbiw	r30, 0x01	; 1
		WaitADC1();
	}
	WaitADC1();
	ADC_IN(FullReg);
	WaitADC2();
	for(i=2; i>=0; i--) {
    3d20:	5c e0       	ldi	r21, 0x0C	; 12
    3d22:	e1 32       	cpi	r30, 0x21	; 33
    3d24:	f5 07       	cpc	r31, r21
    3d26:	a9 f7       	brne	.-22     	; 0x3d12 <ADC_In+0x13e>

// ~~~~~~~~~~~
static void
WaitADC1(void)
{
	SPDR = 0;
    3d28:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    3d2a:	0d b4       	in	r0, 0x2d	; 45
    3d2c:	07 fe       	sbrs	r0, 7
    3d2e:	fd cf       	rjmp	.-6      	; 0x3d2a <ADC_In+0x156>
	for(i=2; i>=0; i--) {
		Scl->Full[i] = SPDR;
		WaitADC1();
	}
	WaitADC1();
	return Scl->Zero[2]<25 || Scl->Zero[2]>27 || Scl->Full[2]<200 || Scl->Full[2]>203;
    3d30:	80 91 21 0c 	lds	r24, 0x0C21
    3d34:	89 51       	subi	r24, 0x19	; 25
    3d36:	83 30       	cpi	r24, 0x03	; 3
    3d38:	08 f0       	brcs	.+2      	; 0x3d3c <ADC_In+0x168>
    3d3a:	85 c0       	rjmp	.+266    	; 0x3e46 <ADC_In+0x272>
    3d3c:	80 91 24 0c 	lds	r24, 0x0C24
    3d40:	88 3c       	cpi	r24, 0xC8	; 200
    3d42:	08 f4       	brcc	.+2      	; 0x3d46 <ADC_In+0x172>
    3d44:	80 c0       	rjmp	.+256    	; 0x3e46 <ADC_In+0x272>
    3d46:	8c 3c       	cpi	r24, 0xCC	; 204
    3d48:	08 f0       	brcs	.+2      	; 0x3d4c <ADC_In+0x178>
    3d4a:	7d c0       	rjmp	.+250    	; 0x3e46 <ADC_In+0x272>
			if(ADC_Check()) {
				ADC_Break++;
				ADC_Phase = RST;
			}
			else {
				ADC_Input[ADC_Chan] = Buf;
    3d4c:	e1 2f       	mov	r30, r17
    3d4e:	f0 e0       	ldi	r31, 0x00	; 0
    3d50:	ee 0f       	add	r30, r30
    3d52:	ff 1f       	adc	r31, r31
    3d54:	e3 53       	subi	r30, 0x33	; 51
    3d56:	f7 4f       	sbci	r31, 0xF7	; 247
    3d58:	31 83       	std	Z+1, r19	; 0x01
    3d5a:	20 83       	st	Z, r18

// ~~~~~~~~~~~~~~~
inline static void
SetMux(void)
{
	if(++ADC_Chan == ADC_Reg)
    3d5c:	81 2f       	mov	r24, r17
    3d5e:	8f 5f       	subi	r24, 0xFF	; 255
    3d60:	80 93 c4 08 	sts	0x08C4, r24
    3d64:	87 30       	cpi	r24, 0x07	; 7
    3d66:	11 f4       	brne	.+4      	; 0x3d6c <ADC_In+0x198>
		ADC_Chan = 0;
    3d68:	10 92 c4 08 	sts	0x08C4, r1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    3d6c:	e0 91 c4 08 	lds	r30, 0x08C4
    3d70:	f0 e0       	ldi	r31, 0x00	; 0
    3d72:	e4 58       	subi	r30, 0x84	; 132
    3d74:	f2 4d       	sbci	r31, 0xD2	; 210
    3d76:	94 91       	lpm	r25, Z+
		#if ADC_Reg>8
			if(ADC_Chan>=sizeof(Mux))
				return;
		#endif
		uint8_t Addr = prb(Mux+ADC_Chan);
		cli();
    3d78:	f8 94       	cli
		if (Addr/4){
    3d7a:	94 30       	cpi	r25, 0x04	; 4
    3d7c:	08 f4       	brcc	.+2      	; 0x3d80 <ADC_In+0x1ac>
    3d7e:	ca c0       	rjmp	.+404    	; 0x3f14 <ADC_In+0x340>
			Port_INH|=INH;
    3d80:	77 9a       	sbi	0x0e, 7	; 14
			#ifdef Port_INH2
				Port_INH2 &=~INH2;
    3d82:	80 91 02 01 	lds	r24, 0x0102
    3d86:	8b 7f       	andi	r24, 0xFB	; 251
    3d88:	80 93 02 01 	sts	0x0102, r24
			Port_INH &=~INH;
			#ifdef Port_INH2
				Port_INH2|=INH2;
			#endif
		}
		if (Addr%4/2)	Port_TER_B	|=TER_B;	else Port_TER_B	&=~TER_B;
    3d8c:	29 2f       	mov	r18, r25
    3d8e:	30 e0       	ldi	r19, 0x00	; 0
    3d90:	c9 01       	movw	r24, r18
    3d92:	83 70       	andi	r24, 0x03	; 3
    3d94:	90 70       	andi	r25, 0x00	; 0
    3d96:	01 96       	adiw	r24, 0x01	; 1
    3d98:	03 97       	sbiw	r24, 0x03	; 3
    3d9a:	08 f4       	brcc	.+2      	; 0x3d9e <ADC_In+0x1ca>
    3d9c:	b9 c0       	rjmp	.+370    	; 0x3f10 <ADC_In+0x33c>
    3d9e:	76 9a       	sbi	0x0e, 6	; 14
		if (Addr%2)		Port_TER_A	|=TER_A;	else Port_TER_A	&=~TER_A;
    3da0:	20 ff       	sbrs	r18, 0
    3da2:	b4 c0       	rjmp	.+360    	; 0x3f0c <ADC_In+0x338>
    3da4:	75 9a       	sbi	0x0e, 5	; 14
		sei();
    3da6:	78 94       	sei
    3da8:	85 e5       	ldi	r24, 0x55	; 85
    3daa:	8a 95       	dec	r24
    3dac:	f1 f7       	brne	.-4      	; 0x3daa <ADC_In+0x1d6>
		default:
			SPDR = ADC_IN1(Reg);
			break;
		}
	#else
		SPDR = ADC_IN1(Reg);
    3dae:	80 e1       	ldi	r24, 0x10	; 16
    3db0:	8e bd       	out	0x2e, r24	; 46
			else {
				ADC_Input[ADC_Chan] = Buf;
				Chan = ADC_Chan;
				SetMux();
				ADC_IN(SetpReg);
				WaitSPI();
    3db2:	0d b4       	in	r0, 0x2d	; 45
    3db4:	07 fe       	sbrs	r0, 7
    3db6:	fd cf       	rjmp	.-6      	; 0x3db2 <ADC_In+0x1de>
				SPDR = SetpVal(NormMode) &~ADC_FSYNC;
    3db8:	86 e0       	ldi	r24, 0x06	; 6
    3dba:	8e bd       	out	0x2e, r24	; 46
				WaitSPI();
    3dbc:	0d b4       	in	r0, 0x2d	; 45
    3dbe:	07 fe       	sbrs	r0, 7
    3dc0:	fd cf       	rjmp	.-6      	; 0x3dbc <ADC_In+0x1e8>
				StartTimer8_ISR(TD_ADC, ADC10ms);
    3dc2:	84 2f       	mov	r24, r20
    3dc4:	64 e1       	ldi	r22, 0x14	; 20
    3dc6:	0e 94 a7 19 	call	0x334e	; 0x334e <StartTimer8_ISR>
    3dca:	32 cf       	rjmp	.-412    	; 0x3c30 <ADC_In+0x5c>

// ~~~~~~~~~~~~~~~
inline static void
ADC_Init1(void)
{
	if(!Timer8Stopp_ISR(TD_ADC))
    3dcc:	80 91 ef 06 	lds	r24, 0x06EF
    3dd0:	0e 94 13 1b 	call	0x3626	; 0x3626 <Timer8Stopp_ISR>
    3dd4:	88 23       	and	r24, r24
    3dd6:	09 f4       	brne	.+2      	; 0x3dda <ADC_In+0x206>
    3dd8:	3a cf       	rjmp	.-396    	; 0x3c4e <ADC_In+0x7a>
    3dda:	81 e0       	ldi	r24, 0x01	; 1
		return;
	uint8_t i = 0;
	while(i++<8) {	// 4 x 0xFF needs
		SPDR = 0xFF;
    3ddc:	9f ef       	ldi	r25, 0xFF	; 255
    3dde:	9e bd       	out	0x2e, r25	; 46
		WaitSPI();
    3de0:	0d b4       	in	r0, 0x2d	; 45
    3de2:	07 fe       	sbrs	r0, 7
    3de4:	fd cf       	rjmp	.-6      	; 0x3de0 <ADC_In+0x20c>
ADC_Init1(void)
{
	if(!Timer8Stopp_ISR(TD_ADC))
		return;
	uint8_t i = 0;
	while(i++<8) {	// 4 x 0xFF needs
    3de6:	88 30       	cpi	r24, 0x08	; 8
    3de8:	d9 f1       	breq	.+118    	; 0x3e60 <ADC_In+0x28c>
    3dea:	8f 5f       	subi	r24, 0xFF	; 255
    3dec:	f8 cf       	rjmp	.-16     	; 0x3dde <ADC_In+0x20a>
// ~~~~~~~~~~~~~~~
static void
Calibr(uint8_t CR)
{
	static uint8_t Try;
	SPDR = CR;
    3dee:	88 e0       	ldi	r24, 0x08	; 8
    3df0:	8e bd       	out	0x2e, r24	; 46

// ~~~~~~~~~~~
static void
WaitADC2(void)
{
	WaitSPI();
    3df2:	0d b4       	in	r0, 0x2d	; 45
    3df4:	07 fe       	sbrs	r0, 7
    3df6:	fd cf       	rjmp	.-6      	; 0x3df2 <ADC_In+0x21e>
	SPDR = 0;
    3df8:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    3dfa:	0d b4       	in	r0, 0x2d	; 45
    3dfc:	07 fe       	sbrs	r0, 7
    3dfe:	fd cf       	rjmp	.-6      	; 0x3dfa <ADC_In+0x226>
Calibr(uint8_t CR)
{
	static uint8_t Try;
	SPDR = CR;
	WaitADC2();
	if(!(SPDR &ADC_DRDY)) {
    3e00:	0e b4       	in	r0, 0x2e	; 46
    3e02:	07 fc       	sbrc	r0, 7
    3e04:	45 c0       	rjmp	.+138    	; 0x3e90 <ADC_In+0x2bc>
		Try = 0;
    3e06:	10 92 e4 02 	sts	0x02E4, r1
		ADC_Phase++;
    3e0a:	83 e0       	ldi	r24, 0x03	; 3
    3e0c:	80 93 1c 0b 	sts	0x0B1C, r24
		break;
	case CALI3:
		Calibr(ADC_IN3(CommReg));
#endif
		if (ADC_Phase==READ)
			StartTimer8_ISR(TD_ADC, ADC10ms);
    3e10:	80 91 ef 06 	lds	r24, 0x06EF
    3e14:	64 e1       	ldi	r22, 0x14	; 20
    3e16:	0e 94 a7 19 	call	0x334e	; 0x334e <StartTimer8_ISR>
    3e1a:	17 e0       	ldi	r17, 0x07	; 7
    3e1c:	09 cf       	rjmp	.-494    	; 0x3c30 <ADC_In+0x5c>
				SPDR = SetpVal(NormMode) &~ADC_FSYNC;
				WaitSPI();
				StartTimer8_ISR(TD_ADC, ADC10ms);
			}
		}
		else if(Timer8Stopp_ISR(TD_ADC)) {
    3e1e:	80 91 ef 06 	lds	r24, 0x06EF
    3e22:	0e 94 13 1b 	call	0x3626	; 0x3626 <Timer8Stopp_ISR>
    3e26:	88 23       	and	r24, r24
    3e28:	09 f4       	brne	.+2      	; 0x3e2c <ADC_In+0x258>
    3e2a:	11 cf       	rjmp	.-478    	; 0x3c4e <ADC_In+0x7a>
			ADC_ReadFail++;
    3e2c:	80 91 6a 07 	lds	r24, 0x076A
    3e30:	90 91 6b 07 	lds	r25, 0x076B
    3e34:	01 96       	adiw	r24, 0x01	; 1
    3e36:	90 93 6b 07 	sts	0x076B, r25
    3e3a:	80 93 6a 07 	sts	0x076A, r24
			ADC_Phase = RST;
    3e3e:	10 92 1c 0b 	sts	0x0B1C, r1
    3e42:	17 e0       	ldi	r17, 0x07	; 7
    3e44:	f5 ce       	rjmp	.-534    	; 0x3c30 <ADC_In+0x5c>
					ADC_Chan--;
				}
				else
			#endif
			if(ADC_Check()) {
				ADC_Break++;
    3e46:	80 91 af 06 	lds	r24, 0x06AF
    3e4a:	90 91 b0 06 	lds	r25, 0x06B0
    3e4e:	01 96       	adiw	r24, 0x01	; 1
    3e50:	90 93 b0 06 	sts	0x06B0, r25
    3e54:	80 93 af 06 	sts	0x06AF, r24
				ADC_Phase = RST;
    3e58:	10 92 1c 0b 	sts	0x0B1C, r1
    3e5c:	17 e0       	ldi	r17, 0x07	; 7
    3e5e:	e8 ce       	rjmp	.-560    	; 0x3c30 <ADC_In+0x5c>

// ~~~~~~~~~~~~~~~~~~~~~~~~~
static void
Init(uint8_t CR, uint8_t SR)
{
	SPDR = CR;
    3e60:	80 e2       	ldi	r24, 0x20	; 32
    3e62:	8e bd       	out	0x2e, r24	; 46
	WaitSPI();
    3e64:	0d b4       	in	r0, 0x2d	; 45
    3e66:	07 fe       	sbrs	r0, 7
    3e68:	fd cf       	rjmp	.-6      	; 0x3e64 <ADC_In+0x290>
	SPDR=ClckVal;
    3e6a:	84 e0       	ldi	r24, 0x04	; 4
    3e6c:	8e bd       	out	0x2e, r24	; 46
	WaitSPI();
    3e6e:	0d b4       	in	r0, 0x2d	; 45
    3e70:	07 fe       	sbrs	r0, 7
    3e72:	fd cf       	rjmp	.-6      	; 0x3e6e <ADC_In+0x29a>
	SPDR = SR;
    3e74:	80 e1       	ldi	r24, 0x10	; 16
    3e76:	8e bd       	out	0x2e, r24	; 46
	WaitSPI();
    3e78:	0d b4       	in	r0, 0x2d	; 45
    3e7a:	07 fe       	sbrs	r0, 7
    3e7c:	fd cf       	rjmp	.-6      	; 0x3e78 <ADC_In+0x2a4>
	SPDR = SetpVal(CaliMode) &~ADC_FSYNC;
    3e7e:	86 e4       	ldi	r24, 0x46	; 70
    3e80:	8e bd       	out	0x2e, r24	; 46
	WaitSPI();
    3e82:	0d b4       	in	r0, 0x2d	; 45
    3e84:	07 fe       	sbrs	r0, 7
    3e86:	fd cf       	rjmp	.-6      	; 0x3e82 <ADC_In+0x2ae>
	StartTimer8_ISR(TD_ADC, 36);
    3e88:	80 91 ef 06 	lds	r24, 0x06EF
    3e8c:	64 e2       	ldi	r22, 0x24	; 36
    3e8e:	c8 ce       	rjmp	.-624    	; 0x3c20 <ADC_In+0x4c>
	WaitADC2();
	if(!(SPDR &ADC_DRDY)) {
		Try = 0;
		ADC_Phase++;
	}
	else if(Timer8Stopp_ISR(TD_ADC)) {
    3e90:	80 91 ef 06 	lds	r24, 0x06EF
    3e94:	0e 94 13 1b 	call	0x3626	; 0x3626 <Timer8Stopp_ISR>
    3e98:	88 23       	and	r24, r24
    3e9a:	99 f0       	breq	.+38     	; 0x3ec2 <ADC_In+0x2ee>
		ADC_Fail++;
    3e9c:	80 91 dd 08 	lds	r24, 0x08DD
    3ea0:	90 91 de 08 	lds	r25, 0x08DE
    3ea4:	01 96       	adiw	r24, 0x01	; 1
    3ea6:	90 93 de 08 	sts	0x08DE, r25
    3eaa:	80 93 dd 08 	sts	0x08DD, r24
		ADC_Phase = ++Try<27 ? RST : ADC_OFF;
    3eae:	80 91 e4 02 	lds	r24, 0x02E4
    3eb2:	8f 5f       	subi	r24, 0xFF	; 255
    3eb4:	80 93 e4 02 	sts	0x02E4, r24
    3eb8:	8b 31       	cpi	r24, 0x1B	; 27
    3eba:	98 f1       	brcs	.+102    	; 0x3f22 <ADC_In+0x34e>
    3ebc:	84 e0       	ldi	r24, 0x04	; 4
    3ebe:	80 93 1c 0b 	sts	0x0B1C, r24
		Init(ADC_IN3(ClckReg), ADC_IN3(SetpReg));
		break;
	case CALI3:
		Calibr(ADC_IN3(CommReg));
#endif
		if (ADC_Phase==READ)
    3ec2:	80 91 1c 0b 	lds	r24, 0x0B1C
    3ec6:	83 30       	cpi	r24, 0x03	; 3
    3ec8:	09 f4       	brne	.+2      	; 0x3ecc <ADC_In+0x2f8>
    3eca:	a2 cf       	rjmp	.-188    	; 0x3e10 <ADC_In+0x23c>
				StartTimer8_ISR(TD_ADC, ADC10ms);
			}
		}
		else if(Timer8Stopp_ISR(TD_ADC)) {
			ADC_ReadFail++;
			ADC_Phase = RST;
    3ecc:	17 e0       	ldi	r17, 0x07	; 7
    3ece:	b0 ce       	rjmp	.-672    	; 0x3c30 <ADC_In+0x5c>
			WaitADC2();
			Buf = SPDR<<8;
			WaitADC1();
			Buf += SPDR;
			#ifdef ADC_Ref_Chan
				if (ADC_Chan==sizeof(Mux)-1 && ADC_Input[sizeof(Mux)-1]!=0 && (Buf<ADC_Ref-ADC_Ref_d || Buf>ADC_Ref+ADC_Ref_d)) {
    3ed0:	80 91 d9 08 	lds	r24, 0x08D9
    3ed4:	90 91 da 08 	lds	r25, 0x08DA
    3ed8:	89 2b       	or	r24, r25
    3eda:	09 f4       	brne	.+2      	; 0x3ede <ADC_In+0x30a>
    3edc:	e0 ce       	rjmp	.-576    	; 0x3c9e <ADC_In+0xca>
    3ede:	ca 01       	movw	r24, r20
    3ee0:	80 58       	subi	r24, 0x80	; 128
    3ee2:	9e 43       	sbci	r25, 0x3E	; 62
    3ee4:	81 5a       	subi	r24, 0xA1	; 161
    3ee6:	9f 40       	sbci	r25, 0x0F	; 15
    3ee8:	08 f4       	brcc	.+2      	; 0x3eec <ADC_In+0x318>
    3eea:	d9 ce       	rjmp	.-590    	; 0x3c9e <ADC_In+0xca>
					ADC_Break++;
    3eec:	80 91 af 06 	lds	r24, 0x06AF
    3ef0:	90 91 b0 06 	lds	r25, 0x06B0
    3ef4:	01 96       	adiw	r24, 0x01	; 1
    3ef6:	90 93 b0 06 	sts	0x06B0, r25
    3efa:	80 93 af 06 	sts	0x06AF, r24
					ADC_Phase = RST;
    3efe:	10 92 1c 0b 	sts	0x0B1C, r1
					ADC_Chan--;
    3f02:	85 e0       	ldi	r24, 0x05	; 5
    3f04:	80 93 c4 08 	sts	0x08C4, r24
    3f08:	17 e0       	ldi	r17, 0x07	; 7
    3f0a:	92 ce       	rjmp	.-732    	; 0x3c30 <ADC_In+0x5c>
			#ifdef Port_INH2
				Port_INH2|=INH2;
			#endif
		}
		if (Addr%4/2)	Port_TER_B	|=TER_B;	else Port_TER_B	&=~TER_B;
		if (Addr%2)		Port_TER_A	|=TER_A;	else Port_TER_A	&=~TER_A;
    3f0c:	75 98       	cbi	0x0e, 5	; 14
    3f0e:	4b cf       	rjmp	.-362    	; 0x3da6 <ADC_In+0x1d2>
			Port_INH &=~INH;
			#ifdef Port_INH2
				Port_INH2|=INH2;
			#endif
		}
		if (Addr%4/2)	Port_TER_B	|=TER_B;	else Port_TER_B	&=~TER_B;
    3f10:	76 98       	cbi	0x0e, 6	; 14
    3f12:	46 cf       	rjmp	.-372    	; 0x3da0 <ADC_In+0x1cc>
			#ifdef Port_INH2
				Port_INH2 &=~INH2;
			#endif
		}
		else{
			Port_INH &=~INH;
    3f14:	77 98       	cbi	0x0e, 7	; 14
			#ifdef Port_INH2
				Port_INH2|=INH2;
    3f16:	80 91 02 01 	lds	r24, 0x0102
    3f1a:	84 60       	ori	r24, 0x04	; 4
    3f1c:	80 93 02 01 	sts	0x0102, r24
    3f20:	35 cf       	rjmp	.-406    	; 0x3d8c <ADC_In+0x1b8>
		Try = 0;
		ADC_Phase++;
	}
	else if(Timer8Stopp_ISR(TD_ADC)) {
		ADC_Fail++;
		ADC_Phase = ++Try<27 ? RST : ADC_OFF;
    3f22:	80 e0       	ldi	r24, 0x00	; 0
    3f24:	cc cf       	rjmp	.-104    	; 0x3ebe <ADC_In+0x2ea>

00003f26 <SPI_Init>:
// Total
// ~~~~~~~~~~~
void
SPI_Init(void)
{
	cli();
    3f26:	f8 94       	cli
	#if defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		DDRB = (DDRB &~(1<<DDB3)) |(1<<DDB2) |(1<<DDB1) |(1<<DDB0);
    3f28:	84 b1       	in	r24, 0x04	; 4
    3f2a:	80 7f       	andi	r24, 0xF0	; 240
    3f2c:	87 60       	ori	r24, 0x07	; 7
    3f2e:	84 b9       	out	0x04, r24	; 4
		PORTB |=1<<PB3;
    3f30:	2b 9a       	sbi	0x05, 3	; 5
	#elif defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
		DDRB = (DDRB &~(1<<DDB6)) |(1<<DDB5) |(1<<DDB7) |(1<<DDB4);
		PORTB |=1<<PB6;
	#endif
	SPCR = (uint8_t)((~(1<<SPIE) |(1<<SPE)) &~(1<<DORD)) |(1<<MSTR) |(1<<CPHA) |(1<<SPR1) |(1<<SPR0);
    3f32:	8f e5       	ldi	r24, 0x5F	; 95
    3f34:	8c bd       	out	0x2c, r24	; 44
	sei();
    3f36:	78 94       	sei
		PortCS_DAC_2 |=CS_DAC_2;
		sei();
	#endif

	#ifndef ADC_Miss
		cli();
    3f38:	f8 94       	cli
		#ifdef CS_ADC
			DDR_CS_ADC |=CS_ADC;
    3f3a:	80 91 01 01 	lds	r24, 0x0101
    3f3e:	88 60       	ori	r24, 0x08	; 8
    3f40:	80 93 01 01 	sts	0x0101, r24
			PortCS_ADC |=CS_ADC;
    3f44:	80 91 02 01 	lds	r24, 0x0102
    3f48:	88 60       	ori	r24, 0x08	; 8
    3f4a:	80 93 02 01 	sts	0x0102, r24
		#endif
		DDR_RESET_PER |=RESET_PER;
    3f4e:	80 91 01 01 	lds	r24, 0x0101
    3f52:	80 61       	ori	r24, 0x10	; 16
    3f54:	80 93 01 01 	sts	0x0101, r24
		#ifdef ADC_Mux
			DDR_INH |=INH;
    3f58:	6f 9a       	sbi	0x0d, 7	; 13
			#ifdef DDR_INH2			
				DDR_INH2 |=INH2;
    3f5a:	80 91 01 01 	lds	r24, 0x0101
    3f5e:	84 60       	ori	r24, 0x04	; 4
    3f60:	80 93 01 01 	sts	0x0101, r24
			#endif
			DDR_TER_A |=TER_A;
    3f64:	6d 9a       	sbi	0x0d, 5	; 13
			DDR_TER_B |=TER_B;
    3f66:	6e 9a       	sbi	0x0d, 6	; 13
		#endif
		sei();
    3f68:	78 94       	sei

// ~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer8_ISR_SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys_ISR;
    3f6a:	80 91 d7 02 	lds	r24, 0x02D7
	VacantTimer8Sys_ISR += n;
    3f6e:	8f 5f       	subi	r24, 0xFF	; 255
    3f70:	80 93 d7 02 	sts	0x02D7, r24
    3f74:	81 50       	subi	r24, 0x01	; 1

		TD_ADC = Timer8_ISR_SysAlloc(1);
    3f76:	80 93 ef 06 	sts	0x06EF, r24


		ADC_Chan = ADC_Reg-1;		// Ignore 1-st measurement after calibration
    3f7a:	86 e0       	ldi	r24, 0x06	; 6
    3f7c:	80 93 c4 08 	sts	0x08C4, r24

		while(ADC_In()==ADC_Reg && ADC_OK);
    3f80:	0e 94 ea 1d 	call	0x3bd4	; 0x3bd4 <ADC_In>
    3f84:	87 30       	cpi	r24, 0x07	; 7
    3f86:	91 f4       	brne	.+36     	; 0x3fac <SPI_Init+0x86>
    3f88:	80 91 dd 08 	lds	r24, 0x08DD
    3f8c:	90 91 de 08 	lds	r25, 0x08DE
    3f90:	89 2b       	or	r24, r25
    3f92:	61 f4       	brne	.+24     	; 0x3fac <SPI_Init+0x86>
    3f94:	80 91 6a 07 	lds	r24, 0x076A
    3f98:	90 91 6b 07 	lds	r25, 0x076B
    3f9c:	89 2b       	or	r24, r25
    3f9e:	31 f4       	brne	.+12     	; 0x3fac <SPI_Init+0x86>
    3fa0:	80 91 af 06 	lds	r24, 0x06AF
    3fa4:	90 91 b0 06 	lds	r25, 0x06B0
    3fa8:	89 2b       	or	r24, r25
    3faa:	51 f3       	breq	.-44     	; 0x3f80 <SPI_Init+0x5a>
    3fac:	08 95       	ret

00003fae <Pow10>:
#include <string.h>

// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
    3fae:	48 2f       	mov	r20, r24
	uint16_t Pow = 1;
	while(Exp--)
    3fb0:	88 23       	and	r24, r24
    3fb2:	89 f0       	breq	.+34     	; 0x3fd6 <Pow10+0x28>
    3fb4:	21 e0       	ldi	r18, 0x01	; 1
    3fb6:	30 e0       	ldi	r19, 0x00	; 0
		Pow *= 10;
    3fb8:	c9 01       	movw	r24, r18
    3fba:	88 0f       	add	r24, r24
    3fbc:	99 1f       	adc	r25, r25
    3fbe:	22 0f       	add	r18, r18
    3fc0:	33 1f       	adc	r19, r19
    3fc2:	22 0f       	add	r18, r18
    3fc4:	33 1f       	adc	r19, r19
    3fc6:	22 0f       	add	r18, r18
    3fc8:	33 1f       	adc	r19, r19
    3fca:	28 0f       	add	r18, r24
    3fcc:	39 1f       	adc	r19, r25
    3fce:	41 50       	subi	r20, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    3fd0:	99 f7       	brne	.-26     	; 0x3fb8 <Pow10+0xa>
		Pow *= 10;
	return Pow;
}
    3fd2:	c9 01       	movw	r24, r18
    3fd4:	08 95       	ret
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    3fd6:	21 e0       	ldi	r18, 0x01	; 1
    3fd8:	30 e0       	ldi	r19, 0x00	; 0
    3fda:	fb cf       	rjmp	.-10     	; 0x3fd2 <Pow10+0x24>

00003fdc <PowL10>:
	return Pow;
}
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
    3fdc:	1f 93       	push	r17
    3fde:	18 2f       	mov	r17, r24
	uint32_t Pow = 1;
	while(Exp--)
    3fe0:	88 23       	and	r24, r24
    3fe2:	a1 f0       	breq	.+40     	; 0x400c <PowL10+0x30>
    3fe4:	21 e0       	ldi	r18, 0x01	; 1
    3fe6:	30 e0       	ldi	r19, 0x00	; 0
    3fe8:	40 e0       	ldi	r20, 0x00	; 0
    3fea:	50 e0       	ldi	r21, 0x00	; 0
		Pow *= 10;
    3fec:	ca 01       	movw	r24, r20
    3fee:	b9 01       	movw	r22, r18
    3ff0:	2a e0       	ldi	r18, 0x0A	; 10
    3ff2:	30 e0       	ldi	r19, 0x00	; 0
    3ff4:	40 e0       	ldi	r20, 0x00	; 0
    3ff6:	50 e0       	ldi	r21, 0x00	; 0
    3ff8:	0e 94 e0 7d 	call	0xfbc0	; 0xfbc0 <__mulsi3>
    3ffc:	9b 01       	movw	r18, r22
    3ffe:	ac 01       	movw	r20, r24
    4000:	11 50       	subi	r17, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
	uint32_t Pow = 1;
	while(Exp--)
    4002:	a1 f7       	brne	.-24     	; 0x3fec <PowL10+0x10>
		Pow *= 10;
	return Pow;
}
    4004:	b9 01       	movw	r22, r18
    4006:	ca 01       	movw	r24, r20
    4008:	1f 91       	pop	r17
    400a:	08 95       	ret
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
	uint32_t Pow = 1;
	while(Exp--)
    400c:	21 e0       	ldi	r18, 0x01	; 1
    400e:	30 e0       	ldi	r19, 0x00	; 0
    4010:	40 e0       	ldi	r20, 0x00	; 0
    4012:	50 e0       	ldi	r21, 0x00	; 0
    4014:	f7 cf       	rjmp	.-18     	; 0x4004 <PowL10+0x28>

00004016 <Log10>:
	return Pow;
}
// ~~~~~~~~~~~~~~~~~
uint8_t
Log10(uint32_t Numb)
{
    4016:	1f 93       	push	r17
	uint8_t Pos;
	for(Pos=0; Numb/=10; Pos++);
    4018:	2a e0       	ldi	r18, 0x0A	; 10
    401a:	30 e0       	ldi	r19, 0x00	; 0
    401c:	40 e0       	ldi	r20, 0x00	; 0
    401e:	50 e0       	ldi	r21, 0x00	; 0
    4020:	0e 94 32 7e 	call	0xfc64	; 0xfc64 <__udivmodsi4>
    4024:	c9 01       	movw	r24, r18
    4026:	da 01       	movw	r26, r20
    4028:	bc 01       	movw	r22, r24
    402a:	cd 01       	movw	r24, r26
    402c:	61 15       	cp	r22, r1
    402e:	71 05       	cpc	r23, r1
    4030:	81 05       	cpc	r24, r1
    4032:	91 05       	cpc	r25, r1
    4034:	a1 f0       	breq	.+40     	; 0x405e <Log10+0x48>
    4036:	10 e0       	ldi	r17, 0x00	; 0
    4038:	1f 5f       	subi	r17, 0xFF	; 255
    403a:	2a e0       	ldi	r18, 0x0A	; 10
    403c:	30 e0       	ldi	r19, 0x00	; 0
    403e:	40 e0       	ldi	r20, 0x00	; 0
    4040:	50 e0       	ldi	r21, 0x00	; 0
    4042:	0e 94 32 7e 	call	0xfc64	; 0xfc64 <__udivmodsi4>
    4046:	c9 01       	movw	r24, r18
    4048:	da 01       	movw	r26, r20
    404a:	bc 01       	movw	r22, r24
    404c:	cd 01       	movw	r24, r26
    404e:	61 15       	cp	r22, r1
    4050:	71 05       	cpc	r23, r1
    4052:	81 05       	cpc	r24, r1
    4054:	91 05       	cpc	r25, r1
    4056:	81 f7       	brne	.-32     	; 0x4038 <Log10+0x22>
	return Pos;
}
    4058:	81 2f       	mov	r24, r17
    405a:	1f 91       	pop	r17
    405c:	08 95       	ret
// ~~~~~~~~~~~~~~~~~
uint8_t
Log10(uint32_t Numb)
{
	uint8_t Pos;
	for(Pos=0; Numb/=10; Pos++);
    405e:	10 e0       	ldi	r17, 0x00	; 0
    4060:	fb cf       	rjmp	.-10     	; 0x4058 <Log10+0x42>

00004062 <CodBCD>:
// ~~~~~~~~~~~~~~~~~~~~

// ~~~~~~~~~~~~~~~~~~~
uint8_t
CodBCD(uint8_t Number)
{
    4062:	28 2f       	mov	r18, r24
    4064:	6a e0       	ldi	r22, 0x0A	; 10
    4066:	0e 94 ff 7d 	call	0xfbfe	; 0xfbfe <__udivmodqi4>
    406a:	38 2f       	mov	r19, r24
    406c:	32 95       	swap	r19
    406e:	30 7f       	andi	r19, 0xF0	; 240
    4070:	82 2f       	mov	r24, r18
    4072:	0e 94 ff 7d 	call	0xfbfe	; 0xfbfe <__udivmodqi4>
	return (Number/10<<4)+Number%10;
}
    4076:	83 2f       	mov	r24, r19
    4078:	89 0f       	add	r24, r25
    407a:	08 95       	ret

0000407c <DecodBCD>:

// ~~~~~~~~~~~~~~~~~~
uint8_t
DecodBCD(uint8_t BCD)
{
    407c:	28 2f       	mov	r18, r24
    407e:	22 95       	swap	r18
    4080:	2f 70       	andi	r18, 0x0F	; 15
    4082:	9a e0       	ldi	r25, 0x0A	; 10
    4084:	29 9f       	mul	r18, r25
    4086:	90 01       	movw	r18, r0
    4088:	11 24       	eor	r1, r1
    408a:	8f 70       	andi	r24, 0x0F	; 15
	return 10*(BCD>>4)+(BCD&0x0F);
}
    408c:	82 0f       	add	r24, r18
    408e:	08 95       	ret

00004090 <LineFunc>:
} uLineGraph;

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
int16_t
LineFunc(const LineGraph *LG, int32_t x)
{
    4090:	2f 92       	push	r2
    4092:	3f 92       	push	r3
    4094:	4f 92       	push	r4
    4096:	5f 92       	push	r5
    4098:	6f 92       	push	r6
    409a:	7f 92       	push	r7
    409c:	8f 92       	push	r8
    409e:	9f 92       	push	r9
    40a0:	af 92       	push	r10
    40a2:	bf 92       	push	r11
    40a4:	cf 92       	push	r12
    40a6:	df 92       	push	r13
    40a8:	ef 92       	push	r14
    40aa:	ff 92       	push	r15
    40ac:	0f 93       	push	r16
    40ae:	1f 93       	push	r17
    40b0:	cf 93       	push	r28
    40b2:	df 93       	push	r29
    40b4:	ec 01       	movw	r28, r24
    40b6:	7a 01       	movw	r14, r20
    40b8:	8b 01       	movw	r16, r22
	int16_t y;
	if (LG->x1==LG->x2)
    40ba:	28 80       	ld	r2, Y
    40bc:	39 80       	ldd	r3, Y+1	; 0x01
    40be:	4a 80       	ldd	r4, Y+2	; 0x02
    40c0:	5b 80       	ldd	r5, Y+3	; 0x03
    40c2:	6c 81       	ldd	r22, Y+4	; 0x04
    40c4:	7d 81       	ldd	r23, Y+5	; 0x05
    40c6:	8e 81       	ldd	r24, Y+6	; 0x06
    40c8:	9f 81       	ldd	r25, Y+7	; 0x07
    40ca:	26 16       	cp	r2, r22
    40cc:	37 06       	cpc	r3, r23
    40ce:	48 06       	cpc	r4, r24
    40d0:	59 06       	cpc	r5, r25
    40d2:	09 f4       	brne	.+2      	; 0x40d6 <LineFunc+0x46>
    40d4:	58 c0       	rjmp	.+176    	; 0x4186 <LineFunc+0xf6>
		y = LG->y1;
	else {
		float x1=LG->x1, x2=LG->x2, y1=LG->y1, y2=LG->y2;
    40d6:	0e 94 95 78 	call	0xf12a	; 0xf12a <__floatsisf>
    40da:	5b 01       	movw	r10, r22
    40dc:	6c 01       	movw	r12, r24
    40de:	6a 85       	ldd	r22, Y+10	; 0x0a
    40e0:	7b 85       	ldd	r23, Y+11	; 0x0b
    40e2:	88 27       	eor	r24, r24
    40e4:	77 fd       	sbrc	r23, 7
    40e6:	80 95       	com	r24
    40e8:	98 2f       	mov	r25, r24
    40ea:	0e 94 95 78 	call	0xf12a	; 0xf12a <__floatsisf>
    40ee:	3b 01       	movw	r6, r22
    40f0:	4c 01       	movw	r8, r24
		y = (x-x2)*(y2-y1)/(x2-x1)+y2;
    40f2:	c8 01       	movw	r24, r16
    40f4:	b7 01       	movw	r22, r14
    40f6:	0e 94 95 78 	call	0xf12a	; 0xf12a <__floatsisf>
    40fa:	a6 01       	movw	r20, r12
    40fc:	95 01       	movw	r18, r10
    40fe:	0e 94 96 7c 	call	0xf92c	; 0xf92c <__subsf3>
    4102:	7b 01       	movw	r14, r22
    4104:	8c 01       	movw	r16, r24
    4106:	68 85       	ldd	r22, Y+8	; 0x08
    4108:	79 85       	ldd	r23, Y+9	; 0x09
    410a:	88 27       	eor	r24, r24
    410c:	77 fd       	sbrc	r23, 7
    410e:	80 95       	com	r24
    4110:	98 2f       	mov	r25, r24
    4112:	0e 94 95 78 	call	0xf12a	; 0xf12a <__floatsisf>
    4116:	9b 01       	movw	r18, r22
    4118:	ac 01       	movw	r20, r24
    411a:	c4 01       	movw	r24, r8
    411c:	b3 01       	movw	r22, r6
    411e:	0e 94 96 7c 	call	0xf92c	; 0xf92c <__subsf3>
    4122:	9b 01       	movw	r18, r22
    4124:	ac 01       	movw	r20, r24
    4126:	c8 01       	movw	r24, r16
    4128:	b7 01       	movw	r22, r14
    412a:	0e 94 d0 78 	call	0xf1a0	; 0xf1a0 <__mulsf3>
    412e:	7b 01       	movw	r14, r22
    4130:	8c 01       	movw	r16, r24
    4132:	c2 01       	movw	r24, r4
    4134:	b1 01       	movw	r22, r2
    4136:	0e 94 95 78 	call	0xf12a	; 0xf12a <__floatsisf>
    413a:	9b 01       	movw	r18, r22
    413c:	ac 01       	movw	r20, r24
    413e:	c6 01       	movw	r24, r12
    4140:	b5 01       	movw	r22, r10
    4142:	0e 94 96 7c 	call	0xf92c	; 0xf92c <__subsf3>
    4146:	9b 01       	movw	r18, r22
    4148:	ac 01       	movw	r20, r24
    414a:	c8 01       	movw	r24, r16
    414c:	b7 01       	movw	r22, r14
    414e:	0e 94 fb 7c 	call	0xf9f6	; 0xf9f6 <__divsf3>
    4152:	a4 01       	movw	r20, r8
    4154:	93 01       	movw	r18, r6
    4156:	0e 94 97 7c 	call	0xf92e	; 0xf92e <__addsf3>
    415a:	0e 94 63 7d 	call	0xfac6	; 0xfac6 <__fixsfsi>
    415e:	cb 01       	movw	r24, r22
	}
	return y;
}
    4160:	df 91       	pop	r29
    4162:	cf 91       	pop	r28
    4164:	1f 91       	pop	r17
    4166:	0f 91       	pop	r16
    4168:	ff 90       	pop	r15
    416a:	ef 90       	pop	r14
    416c:	df 90       	pop	r13
    416e:	cf 90       	pop	r12
    4170:	bf 90       	pop	r11
    4172:	af 90       	pop	r10
    4174:	9f 90       	pop	r9
    4176:	8f 90       	pop	r8
    4178:	7f 90       	pop	r7
    417a:	6f 90       	pop	r6
    417c:	5f 90       	pop	r5
    417e:	4f 90       	pop	r4
    4180:	3f 90       	pop	r3
    4182:	2f 90       	pop	r2
    4184:	08 95       	ret
int16_t
LineFunc(const LineGraph *LG, int32_t x)
{
	int16_t y;
	if (LG->x1==LG->x2)
		y = LG->y1;
    4186:	88 85       	ldd	r24, Y+8	; 0x08
    4188:	99 85       	ldd	r25, Y+9	; 0x09
    418a:	ea cf       	rjmp	.-44     	; 0x4160 <LineFunc+0xd0>

0000418c <uLineFunc>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
int16_t
uLineFunc(const uLineGraph *LG, uint32_t x)
{
    418c:	2f 92       	push	r2
    418e:	3f 92       	push	r3
    4190:	4f 92       	push	r4
    4192:	5f 92       	push	r5
    4194:	6f 92       	push	r6
    4196:	7f 92       	push	r7
    4198:	8f 92       	push	r8
    419a:	9f 92       	push	r9
    419c:	af 92       	push	r10
    419e:	bf 92       	push	r11
    41a0:	cf 92       	push	r12
    41a2:	df 92       	push	r13
    41a4:	ef 92       	push	r14
    41a6:	ff 92       	push	r15
    41a8:	0f 93       	push	r16
    41aa:	1f 93       	push	r17
    41ac:	cf 93       	push	r28
    41ae:	df 93       	push	r29
    41b0:	ec 01       	movw	r28, r24
    41b2:	7a 01       	movw	r14, r20
    41b4:	8b 01       	movw	r16, r22
	int16_t y;
	if (LG->x1==LG->x2)
    41b6:	28 80       	ld	r2, Y
    41b8:	39 80       	ldd	r3, Y+1	; 0x01
    41ba:	4a 80       	ldd	r4, Y+2	; 0x02
    41bc:	5b 80       	ldd	r5, Y+3	; 0x03
    41be:	6c 81       	ldd	r22, Y+4	; 0x04
    41c0:	7d 81       	ldd	r23, Y+5	; 0x05
    41c2:	8e 81       	ldd	r24, Y+6	; 0x06
    41c4:	9f 81       	ldd	r25, Y+7	; 0x07
    41c6:	26 16       	cp	r2, r22
    41c8:	37 06       	cpc	r3, r23
    41ca:	48 06       	cpc	r4, r24
    41cc:	59 06       	cpc	r5, r25
    41ce:	09 f4       	brne	.+2      	; 0x41d2 <uLineFunc+0x46>
    41d0:	58 c0       	rjmp	.+176    	; 0x4282 <uLineFunc+0xf6>
		y = LG->y1;
	else {
		float x1=LG->x1, x2=LG->x2, y1=LG->y1, y2=LG->y2;
    41d2:	0e 94 93 78 	call	0xf126	; 0xf126 <__floatunsisf>
    41d6:	5b 01       	movw	r10, r22
    41d8:	6c 01       	movw	r12, r24
    41da:	6a 85       	ldd	r22, Y+10	; 0x0a
    41dc:	7b 85       	ldd	r23, Y+11	; 0x0b
    41de:	88 27       	eor	r24, r24
    41e0:	77 fd       	sbrc	r23, 7
    41e2:	80 95       	com	r24
    41e4:	98 2f       	mov	r25, r24
    41e6:	0e 94 95 78 	call	0xf12a	; 0xf12a <__floatsisf>
    41ea:	3b 01       	movw	r6, r22
    41ec:	4c 01       	movw	r8, r24
		y = (x-x2)*(y2-y1)/(x2-x1)+y2;
    41ee:	c8 01       	movw	r24, r16
    41f0:	b7 01       	movw	r22, r14
    41f2:	0e 94 93 78 	call	0xf126	; 0xf126 <__floatunsisf>
    41f6:	a6 01       	movw	r20, r12
    41f8:	95 01       	movw	r18, r10
    41fa:	0e 94 96 7c 	call	0xf92c	; 0xf92c <__subsf3>
    41fe:	7b 01       	movw	r14, r22
    4200:	8c 01       	movw	r16, r24
    4202:	68 85       	ldd	r22, Y+8	; 0x08
    4204:	79 85       	ldd	r23, Y+9	; 0x09
    4206:	88 27       	eor	r24, r24
    4208:	77 fd       	sbrc	r23, 7
    420a:	80 95       	com	r24
    420c:	98 2f       	mov	r25, r24
    420e:	0e 94 95 78 	call	0xf12a	; 0xf12a <__floatsisf>
    4212:	9b 01       	movw	r18, r22
    4214:	ac 01       	movw	r20, r24
    4216:	c4 01       	movw	r24, r8
    4218:	b3 01       	movw	r22, r6
    421a:	0e 94 96 7c 	call	0xf92c	; 0xf92c <__subsf3>
    421e:	9b 01       	movw	r18, r22
    4220:	ac 01       	movw	r20, r24
    4222:	c8 01       	movw	r24, r16
    4224:	b7 01       	movw	r22, r14
    4226:	0e 94 d0 78 	call	0xf1a0	; 0xf1a0 <__mulsf3>
    422a:	7b 01       	movw	r14, r22
    422c:	8c 01       	movw	r16, r24
    422e:	c2 01       	movw	r24, r4
    4230:	b1 01       	movw	r22, r2
    4232:	0e 94 93 78 	call	0xf126	; 0xf126 <__floatunsisf>
    4236:	9b 01       	movw	r18, r22
    4238:	ac 01       	movw	r20, r24
    423a:	c6 01       	movw	r24, r12
    423c:	b5 01       	movw	r22, r10
    423e:	0e 94 96 7c 	call	0xf92c	; 0xf92c <__subsf3>
    4242:	9b 01       	movw	r18, r22
    4244:	ac 01       	movw	r20, r24
    4246:	c8 01       	movw	r24, r16
    4248:	b7 01       	movw	r22, r14
    424a:	0e 94 fb 7c 	call	0xf9f6	; 0xf9f6 <__divsf3>
    424e:	a4 01       	movw	r20, r8
    4250:	93 01       	movw	r18, r6
    4252:	0e 94 97 7c 	call	0xf92e	; 0xf92e <__addsf3>
    4256:	0e 94 63 7d 	call	0xfac6	; 0xfac6 <__fixsfsi>
    425a:	cb 01       	movw	r24, r22
	}
	return y;
}
    425c:	df 91       	pop	r29
    425e:	cf 91       	pop	r28
    4260:	1f 91       	pop	r17
    4262:	0f 91       	pop	r16
    4264:	ff 90       	pop	r15
    4266:	ef 90       	pop	r14
    4268:	df 90       	pop	r13
    426a:	cf 90       	pop	r12
    426c:	bf 90       	pop	r11
    426e:	af 90       	pop	r10
    4270:	9f 90       	pop	r9
    4272:	8f 90       	pop	r8
    4274:	7f 90       	pop	r7
    4276:	6f 90       	pop	r6
    4278:	5f 90       	pop	r5
    427a:	4f 90       	pop	r4
    427c:	3f 90       	pop	r3
    427e:	2f 90       	pop	r2
    4280:	08 95       	ret
int16_t
uLineFunc(const uLineGraph *LG, uint32_t x)
{
	int16_t y;
	if (LG->x1==LG->x2)
		y = LG->y1;
    4282:	88 85       	ldd	r24, Y+8	; 0x08
    4284:	99 85       	ldd	r25, Y+9	; 0x09
    4286:	ea cf       	rjmp	.-44     	; 0x425c <uLineFunc+0xd0>

00004288 <PGM_uBrokLine>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
int16_t
PGM_uBrokLine(PGM_uDataPoint *Brok, uint16_t x)
{
    4288:	af 92       	push	r10
    428a:	bf 92       	push	r11
    428c:	cf 92       	push	r12
    428e:	df 92       	push	r13
    4290:	ef 92       	push	r14
    4292:	ff 92       	push	r15
    4294:	0f 93       	push	r16
    4296:	1f 93       	push	r17
    4298:	df 93       	push	r29
    429a:	cf 93       	push	r28
    429c:	cd b7       	in	r28, 0x3d	; 61
    429e:	de b7       	in	r29, 0x3e	; 62
    42a0:	2c 97       	sbiw	r28, 0x0c	; 12
    42a2:	0f b6       	in	r0, 0x3f	; 63
    42a4:	f8 94       	cli
    42a6:	de bf       	out	0x3e, r29	; 62
    42a8:	0f be       	out	0x3f, r0	; 63
    42aa:	cd bf       	out	0x3d, r28	; 61
    42ac:	dc 01       	movw	r26, r24

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    42ae:	fc 01       	movw	r30, r24
    42b0:	85 91       	lpm	r24, Z+
    42b2:	94 91       	lpm	r25, Z+
	uLineGraph Segm;
	Segm.x2 = prw(&Brok->x);
    42b4:	7c 01       	movw	r14, r24
    42b6:	00 e0       	ldi	r16, 0x00	; 0
    42b8:	10 e0       	ldi	r17, 0x00	; 0
    42ba:	5b 01       	movw	r10, r22
    42bc:	cc 24       	eor	r12, r12
    42be:	dd 24       	eor	r13, r13
	do {
		Segm.x1 = Segm.x2;
		Segm.x2 = prw(&(++Brok)->x);
    42c0:	cd 01       	movw	r24, r26
    42c2:	04 96       	adiw	r24, 0x04	; 4
    42c4:	fc 01       	movw	r30, r24
    42c6:	25 91       	lpm	r18, Z+
    42c8:	34 91       	lpm	r19, Z+
    42ca:	ad 01       	movw	r20, r26
    42cc:	b7 01       	movw	r22, r14
    42ce:	f8 01       	movw	r30, r16
    42d0:	dc 01       	movw	r26, r24
    42d2:	79 01       	movw	r14, r18
    42d4:	00 e0       	ldi	r16, 0x00	; 0
    42d6:	10 e0       	ldi	r17, 0x00	; 0
	} while(x>Segm.x2);
    42d8:	ea 14       	cp	r14, r10
    42da:	fb 04       	cpc	r15, r11
    42dc:	0c 05       	cpc	r16, r12
    42de:	1d 05       	cpc	r17, r13
    42e0:	78 f3       	brcs	.-34     	; 0x42c0 <PGM_uBrokLine+0x38>
    42e2:	ca 01       	movw	r24, r20
    42e4:	9b 01       	movw	r18, r22
    42e6:	af 01       	movw	r20, r30
    42e8:	69 83       	std	Y+1, r22	; 0x01
    42ea:	3a 83       	std	Y+2, r19	; 0x02
    42ec:	eb 83       	std	Y+3, r30	; 0x03
    42ee:	5c 83       	std	Y+4, r21	; 0x04
    42f0:	ed 82       	std	Y+5, r14	; 0x05
    42f2:	fe 82       	std	Y+6, r15	; 0x06
    42f4:	0f 83       	std	Y+7, r16	; 0x07
    42f6:	18 87       	std	Y+8, r17	; 0x08
    42f8:	fc 01       	movw	r30, r24
    42fa:	32 96       	adiw	r30, 0x02	; 2
    42fc:	85 91       	lpm	r24, Z+
    42fe:	94 91       	lpm	r25, Z+
	Segm.y1 = (int16_t)prw(&(Brok-1)->y);
    4300:	9a 87       	std	Y+10, r25	; 0x0a
    4302:	89 87       	std	Y+9, r24	; 0x09
    4304:	fd 01       	movw	r30, r26
    4306:	32 96       	adiw	r30, 0x02	; 2
    4308:	85 91       	lpm	r24, Z+
    430a:	94 91       	lpm	r25, Z+
	Segm.y2 = (int16_t)prw(&Brok->y);
    430c:	9c 87       	std	Y+12, r25	; 0x0c
    430e:	8b 87       	std	Y+11, r24	; 0x0b
	return uLineFunc(&Segm, x);
    4310:	ce 01       	movw	r24, r28
    4312:	01 96       	adiw	r24, 0x01	; 1
    4314:	b6 01       	movw	r22, r12
    4316:	a5 01       	movw	r20, r10
    4318:	0e 94 c6 20 	call	0x418c	; 0x418c <uLineFunc>
}
    431c:	2c 96       	adiw	r28, 0x0c	; 12
    431e:	0f b6       	in	r0, 0x3f	; 63
    4320:	f8 94       	cli
    4322:	de bf       	out	0x3e, r29	; 62
    4324:	0f be       	out	0x3f, r0	; 63
    4326:	cd bf       	out	0x3d, r28	; 61
    4328:	cf 91       	pop	r28
    432a:	df 91       	pop	r29
    432c:	1f 91       	pop	r17
    432e:	0f 91       	pop	r16
    4330:	ff 90       	pop	r15
    4332:	ef 90       	pop	r14
    4334:	df 90       	pop	r13
    4336:	cf 90       	pop	r12
    4338:	bf 90       	pop	r11
    433a:	af 90       	pop	r10
    433c:	08 95       	ret

0000433e <InterBrokLine>:
	uint8_t WiAbsc, int16_t (*TblAbsc)[WiAbsc], uint8_t Absc,
	uint8_t WiOrdi, int16_t (*TblOrdi)[WiOrdi], uint8_t Ordi,
	uint8_t Len,
	int16_t x
)
{
    433e:	2f 92       	push	r2
    4340:	3f 92       	push	r3
    4342:	4f 92       	push	r4
    4344:	5f 92       	push	r5
    4346:	6f 92       	push	r6
    4348:	7f 92       	push	r7
    434a:	8f 92       	push	r8
    434c:	9f 92       	push	r9
    434e:	af 92       	push	r10
    4350:	bf 92       	push	r11
    4352:	cf 92       	push	r12
    4354:	df 92       	push	r13
    4356:	ef 92       	push	r14
    4358:	ff 92       	push	r15
    435a:	0f 93       	push	r16
    435c:	1f 93       	push	r17
    435e:	df 93       	push	r29
    4360:	cf 93       	push	r28
    4362:	cd b7       	in	r28, 0x3d	; 61
    4364:	de b7       	in	r29, 0x3e	; 62
    4366:	2e 97       	sbiw	r28, 0x0e	; 14
    4368:	0f b6       	in	r0, 0x3f	; 63
    436a:	f8 94       	cli
    436c:	de bf       	out	0x3e, r29	; 62
    436e:	0f be       	out	0x3f, r0	; 63
    4370:	cd bf       	out	0x3d, r28	; 61
    4372:	2b 01       	movw	r4, r22
    4374:	2d 87       	std	Y+13, r18	; 0x0d
    4376:	18 01       	movw	r2, r16
    4378:	ee 86       	std	Y+14, r14	; 0x0e
    437a:	7c 2d       	mov	r23, r12
	LineGraph Segm;
	uint8_t i = 0;
	Segm.x2=TblAbsc[0][Absc];
    437c:	c4 2e       	mov	r12, r20
    437e:	dd 24       	eor	r13, r13
    4380:	cc 0c       	add	r12, r12
    4382:	dd 1c       	adc	r13, r13
    4384:	f2 01       	movw	r30, r4
    4386:	ec 0d       	add	r30, r12
    4388:	fd 1d       	adc	r31, r13
    438a:	20 81       	ld	r18, Z
    438c:	31 81       	ldd	r19, Z+1	; 0x01
    438e:	79 01       	movw	r14, r18
    4390:	00 27       	eor	r16, r16
    4392:	f7 fc       	sbrc	r15, 7
    4394:	00 95       	com	r16
    4396:	10 2f       	mov	r17, r16
    4398:	ed 82       	std	Y+5, r14	; 0x05
    439a:	fe 82       	std	Y+6, r15	; 0x06
    439c:	0f 83       	std	Y+7, r16	; 0x07
    439e:	18 87       	std	Y+8, r17	; 0x08
    43a0:	a8 2f       	mov	r26, r24
    43a2:	b0 e0       	ldi	r27, 0x00	; 0
    43a4:	aa 0f       	add	r26, r26
    43a6:	bb 1f       	adc	r27, r27
    43a8:	35 01       	movw	r6, r10
    43aa:	88 24       	eor	r8, r8
    43ac:	77 fc       	sbrc	r7, 7
    43ae:	80 94       	com	r8
    43b0:	98 2c       	mov	r9, r8
    43b2:	60 e0       	ldi	r22, 0x00	; 0
    43b4:	02 c0       	rjmp	.+4      	; 0x43ba <InterBrokLine+0x7c>
	do {
		Segm.x1 = Segm.x2;
		Segm.x2 = TblAbsc[++i][Absc];
	} while(x>Segm.x2 && i<Len);
    43b6:	79 01       	movw	r14, r18
    43b8:	8a 01       	movw	r16, r20
	LineGraph Segm;
	uint8_t i = 0;
	Segm.x2=TblAbsc[0][Absc];
	do {
		Segm.x1 = Segm.x2;
		Segm.x2 = TblAbsc[++i][Absc];
    43ba:	6f 5f       	subi	r22, 0xFF	; 255
    43bc:	a6 2e       	mov	r10, r22
    43be:	bb 24       	eor	r11, r11
    43c0:	aa 9e       	mul	r10, r26
    43c2:	f0 01       	movw	r30, r0
    43c4:	ab 9e       	mul	r10, r27
    43c6:	f0 0d       	add	r31, r0
    43c8:	ba 9e       	mul	r11, r26
    43ca:	f0 0d       	add	r31, r0
    43cc:	11 24       	eor	r1, r1
    43ce:	e4 0d       	add	r30, r4
    43d0:	f5 1d       	adc	r31, r5
    43d2:	ec 0d       	add	r30, r12
    43d4:	fd 1d       	adc	r31, r13
    43d6:	80 81       	ld	r24, Z
    43d8:	91 81       	ldd	r25, Z+1	; 0x01
    43da:	9c 01       	movw	r18, r24
    43dc:	44 27       	eor	r20, r20
    43de:	37 fd       	sbrc	r19, 7
    43e0:	40 95       	com	r20
    43e2:	54 2f       	mov	r21, r20
	} while(x>Segm.x2 && i<Len);
    43e4:	26 15       	cp	r18, r6
    43e6:	37 05       	cpc	r19, r7
    43e8:	48 05       	cpc	r20, r8
    43ea:	59 05       	cpc	r21, r9
    43ec:	14 f4       	brge	.+4      	; 0x43f2 <InterBrokLine+0xb4>
    43ee:	67 17       	cp	r22, r23
    43f0:	10 f3       	brcs	.-60     	; 0x43b6 <InterBrokLine+0x78>
    43f2:	e9 82       	std	Y+1, r14	; 0x01
    43f4:	fa 82       	std	Y+2, r15	; 0x02
    43f6:	0b 83       	std	Y+3, r16	; 0x03
    43f8:	1c 83       	std	Y+4, r17	; 0x04
    43fa:	2d 83       	std	Y+5, r18	; 0x05
    43fc:	3e 83       	std	Y+6, r19	; 0x06
    43fe:	4f 83       	std	Y+7, r20	; 0x07
    4400:	58 87       	std	Y+8, r21	; 0x08
	Segm.y1 = TblOrdi[i-1][Ordi];
    4402:	8d 85       	ldd	r24, Y+13	; 0x0d
    4404:	28 2f       	mov	r18, r24
    4406:	30 e0       	ldi	r19, 0x00	; 0
    4408:	22 0f       	add	r18, r18
    440a:	33 1f       	adc	r19, r19
    440c:	8e 85       	ldd	r24, Y+14	; 0x0e
    440e:	a8 2f       	mov	r26, r24
    4410:	b0 e0       	ldi	r27, 0x00	; 0
    4412:	08 94       	sec
    4414:	a1 08       	sbc	r10, r1
    4416:	b1 08       	sbc	r11, r1
    4418:	a2 9e       	mul	r10, r18
    441a:	f0 01       	movw	r30, r0
    441c:	a3 9e       	mul	r10, r19
    441e:	f0 0d       	add	r31, r0
    4420:	b2 9e       	mul	r11, r18
    4422:	f0 0d       	add	r31, r0
    4424:	11 24       	eor	r1, r1
    4426:	08 94       	sec
    4428:	a1 1c       	adc	r10, r1
    442a:	b1 1c       	adc	r11, r1
    442c:	e2 0d       	add	r30, r2
    442e:	f3 1d       	adc	r31, r3
    4430:	aa 0f       	add	r26, r26
    4432:	bb 1f       	adc	r27, r27
    4434:	ea 0f       	add	r30, r26
    4436:	fb 1f       	adc	r31, r27
    4438:	80 81       	ld	r24, Z
    443a:	91 81       	ldd	r25, Z+1	; 0x01
    443c:	9a 87       	std	Y+10, r25	; 0x0a
    443e:	89 87       	std	Y+9, r24	; 0x09
	Segm.y2 = TblOrdi[i][Ordi];
    4440:	a2 9e       	mul	r10, r18
    4442:	c0 01       	movw	r24, r0
    4444:	a3 9e       	mul	r10, r19
    4446:	90 0d       	add	r25, r0
    4448:	b2 9e       	mul	r11, r18
    444a:	90 0d       	add	r25, r0
    444c:	11 24       	eor	r1, r1
    444e:	82 0d       	add	r24, r2
    4450:	93 1d       	adc	r25, r3
    4452:	a8 0f       	add	r26, r24
    4454:	b9 1f       	adc	r27, r25
    4456:	8d 91       	ld	r24, X+
    4458:	9c 91       	ld	r25, X
    445a:	9c 87       	std	Y+12, r25	; 0x0c
    445c:	8b 87       	std	Y+11, r24	; 0x0b
	return LineFunc(&Segm, x);
    445e:	ce 01       	movw	r24, r28
    4460:	01 96       	adiw	r24, 0x01	; 1
    4462:	b4 01       	movw	r22, r8
    4464:	a3 01       	movw	r20, r6
    4466:	0e 94 48 20 	call	0x4090	; 0x4090 <LineFunc>
}
    446a:	2e 96       	adiw	r28, 0x0e	; 14
    446c:	0f b6       	in	r0, 0x3f	; 63
    446e:	f8 94       	cli
    4470:	de bf       	out	0x3e, r29	; 62
    4472:	0f be       	out	0x3f, r0	; 63
    4474:	cd bf       	out	0x3d, r28	; 61
    4476:	cf 91       	pop	r28
    4478:	df 91       	pop	r29
    447a:	1f 91       	pop	r17
    447c:	0f 91       	pop	r16
    447e:	ff 90       	pop	r15
    4480:	ef 90       	pop	r14
    4482:	df 90       	pop	r13
    4484:	cf 90       	pop	r12
    4486:	bf 90       	pop	r11
    4488:	af 90       	pop	r10
    448a:	9f 90       	pop	r9
    448c:	8f 90       	pop	r8
    448e:	7f 90       	pop	r7
    4490:	6f 90       	pop	r6
    4492:	5f 90       	pop	r5
    4494:	4f 90       	pop	r4
    4496:	3f 90       	pop	r3
    4498:	2f 90       	pop	r2
    449a:	08 95       	ret

0000449c <TWI_Init>:
}

uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    449c:	90 91 cc 02 	lds	r25, 0x02CC
	VacantTimer8Sys += n;
    44a0:	89 2f       	mov	r24, r25
    44a2:	8f 5f       	subi	r24, 0xFF	; 255

// ~~~~~~~~~~~
void
TWI_Init(void)
{
	TD_TWI_Poll = Timer8SysAlloc(1);
    44a4:	90 93 ca 04 	sts	0x04CA, r25
    44a8:	8f 5f       	subi	r24, 0xFF	; 255
    44aa:	80 93 cc 02 	sts	0x02CC, r24
    44ae:	81 50       	subi	r24, 0x01	; 1
	TD_TWI_Timeout = Timer8SysAlloc(1);
    44b0:	80 93 cb 04 	sts	0x04CB, r24

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    44b4:	80 91 cd 02 	lds	r24, 0x02CD
	VacantTimer16Sys += n;
    44b8:	8f 5f       	subi	r24, 0xFF	; 255
    44ba:	80 93 cd 02 	sts	0x02CD, r24
    44be:	81 50       	subi	r24, 0x01	; 1
	TD_RTC_Check = Timer16SysAlloc(1);
    44c0:	80 93 cc 04 	sts	0x04CC, r24
	StartTimer16(TD_RTC_Check, 300);
    44c4:	6c e2       	ldi	r22, 0x2C	; 44
    44c6:	71 e0       	ldi	r23, 0x01	; 1
    44c8:	0e 94 1d 1a 	call	0x343a	; 0x343a <StartTimer16>
	TWBR = 144;	//50
    44cc:	80 e9       	ldi	r24, 0x90	; 144
    44ce:	80 93 b8 00 	sts	0x00B8, r24
}
    44d2:	08 95       	ret

000044d4 <TWI_Error>:
// ~~~~~~~~~~~
void
TWI_Error(void)
{
	TWI_Error_Counter++;
    44d4:	80 91 97 08 	lds	r24, 0x0897
    44d8:	90 91 98 08 	lds	r25, 0x0898
    44dc:	01 96       	adiw	r24, 0x01	; 1
    44de:	90 93 98 08 	sts	0x0898, r25
    44e2:	80 93 97 08 	sts	0x0897, r24
	//StopTWI();
	PowerOffTWI();
    44e6:	10 92 bc 00 	sts	0x00BC, r1
	TWI_Phase = PCF_START;
    44ea:	10 92 77 07 	sts	0x0777, r1
	StartTimer8(TD_TWI_Poll, 49);
    44ee:	80 91 ca 04 	lds	r24, 0x04CA
    44f2:	61 e3       	ldi	r22, 0x31	; 49
    44f4:	0e 94 e2 19 	call	0x33c4	; 0x33c4 <StartTimer8>
}
    44f8:	08 95       	ret

000044fa <WriteRTC>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
WriteRTC(uint8_t Addr, uint8_t Dat)
{
    44fa:	bf 92       	push	r11
    44fc:	cf 92       	push	r12
    44fe:	df 92       	push	r13
    4500:	ef 92       	push	r14
    4502:	ff 92       	push	r15
    4504:	0f 93       	push	r16
    4506:	1f 93       	push	r17
/*	if (!(TWCR &(1<<TWINT))){ //Wait for the end of current TWI operation and isuue STOP
		_delay_us(100);
		StopTWI();
		_delay_us(50);
	}*/
	PowerOffTWI();
    4508:	4c eb       	ldi	r20, 0xBC	; 188
    450a:	c4 2e       	mov	r12, r20
    450c:	d1 2c       	mov	r13, r1
    450e:	f6 01       	movw	r30, r12
    4510:	10 82       	st	Z, r1
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    4512:	e0 e9       	ldi	r30, 0x90	; 144
    4514:	f1 e0       	ldi	r31, 0x01	; 1
    4516:	31 97       	sbiw	r30, 0x01	; 1
    4518:	f1 f7       	brne	.-4      	; 0x4516 <WriteRTC+0x1c>
	_delay_us(100);
	//_delay_us(150);_delay_us(150);
	StartTWI();
    451a:	94 ea       	ldi	r25, 0xA4	; 164
    451c:	f6 01       	movw	r30, r12
    451e:	90 83       	st	Z, r25
    4520:	08 e5       	ldi	r16, 0x58	; 88
    4522:	12 e0       	ldi	r17, 0x02	; 2
    4524:	f8 01       	movw	r30, r16
    4526:	31 97       	sbiw	r30, 0x01	; 1
    4528:	f1 f7       	brne	.-4      	; 0x4526 <WriteRTC+0x2c>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = SLA_W(PCF_SLA);
    452a:	f8 01       	movw	r30, r16
    452c:	31 97       	sbiw	r30, 0x01	; 1
    452e:	f1 f7       	brne	.-4      	; 0x452c <WriteRTC+0x32>
    4530:	3b eb       	ldi	r19, 0xBB	; 187
    4532:	e3 2e       	mov	r14, r19
    4534:	f1 2c       	mov	r15, r1
    4536:	90 ed       	ldi	r25, 0xD0	; 208
    4538:	f7 01       	movw	r30, r14
    453a:	90 83       	st	Z, r25
    453c:	90 81       	ld	r25, Z
    453e:	90 83       	st	Z, r25
	RunTWI();
    4540:	24 e8       	ldi	r18, 0x84	; 132
    4542:	b2 2e       	mov	r11, r18
    4544:	f6 01       	movw	r30, r12
    4546:	b0 82       	st	Z, r11
    4548:	f8 01       	movw	r30, r16
    454a:	31 97       	sbiw	r30, 0x01	; 1
    454c:	f1 f7       	brne	.-4      	; 0x454a <WriteRTC+0x50>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = AddrSec+Addr;
    454e:	f8 01       	movw	r30, r16
    4550:	31 97       	sbiw	r30, 0x01	; 1
    4552:	f1 f7       	brne	.-4      	; 0x4550 <WriteRTC+0x56>
    4554:	f7 01       	movw	r30, r14
    4556:	80 83       	st	Z, r24
	RunTWI();
    4558:	f6 01       	movw	r30, r12
    455a:	b0 82       	st	Z, r11
    455c:	c8 01       	movw	r24, r16
    455e:	01 97       	sbiw	r24, 0x01	; 1
    4560:	f1 f7       	brne	.-4      	; 0x455e <WriteRTC+0x64>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = CodBCD(Dat);
    4562:	c8 01       	movw	r24, r16
    4564:	01 97       	sbiw	r24, 0x01	; 1
    4566:	f1 f7       	brne	.-4      	; 0x4564 <WriteRTC+0x6a>
    4568:	86 2f       	mov	r24, r22
    456a:	0e 94 31 20 	call	0x4062	; 0x4062 <CodBCD>
    456e:	f7 01       	movw	r30, r14
    4570:	80 83       	st	Z, r24
	RunTWI();
    4572:	f6 01       	movw	r30, r12
    4574:	b0 82       	st	Z, r11
    4576:	c8 01       	movw	r24, r16
    4578:	01 97       	sbiw	r24, 0x01	; 1
    457a:	f1 f7       	brne	.-4      	; 0x4578 <WriteRTC+0x7e>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	StopTWI();
    457c:	c8 01       	movw	r24, r16
    457e:	01 97       	sbiw	r24, 0x01	; 1
    4580:	f1 f7       	brne	.-4      	; 0x457e <WriteRTC+0x84>
    4582:	84 e9       	ldi	r24, 0x94	; 148
    4584:	80 83       	st	Z, r24
	TWI_Phase = PCF_START;
    4586:	10 92 77 07 	sts	0x0777, r1
}
    458a:	1f 91       	pop	r17
    458c:	0f 91       	pop	r16
    458e:	ff 90       	pop	r15
    4590:	ef 90       	pop	r14
    4592:	df 90       	pop	r13
    4594:	cf 90       	pop	r12
    4596:	bf 90       	pop	r11
    4598:	08 95       	ret

0000459a <SetWeekday>:
*/

// ~~~~~~~~~~~~~~~
// 31.12.00 was Su
uint8_t SetWeekday(uint8_t Year, uint8_t Month, uint8_t MDay)
{
    459a:	a6 2f       	mov	r26, r22
	uint8_t DayCount;
	uint8_t LastYear = Year-1;
    459c:	b8 2f       	mov	r27, r24
    459e:	b1 50       	subi	r27, 0x01	; 1

	DayCount = (LastYear+LastYear/4);
    45a0:	5b 2f       	mov	r21, r27
    45a2:	56 95       	lsr	r21
    45a4:	56 95       	lsr	r21
    45a6:	5b 0f       	add	r21, r27
	for (uint8_t i=1; i<Month; DayCount+=prb(DaysMonth+i++)%7);
    45a8:	62 30       	cpi	r22, 0x02	; 2
    45aa:	88 f0       	brcs	.+34     	; 0x45ce <SetWeekday+0x34>
    45ac:	e0 e2       	ldi	r30, 0x20	; 32
    45ae:	f3 e0       	ldi	r31, 0x03	; 3
    45b0:	a2 50       	subi	r26, 0x02	; 2
    45b2:	2a 2f       	mov	r18, r26
    45b4:	30 e0       	ldi	r19, 0x00	; 0
    45b6:	ae 5f       	subi	r26, 0xFE	; 254
    45b8:	2f 5d       	subi	r18, 0xDF	; 223
    45ba:	3c 4f       	sbci	r19, 0xFC	; 252

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    45bc:	84 91       	lpm	r24, Z+
    45be:	67 e0       	ldi	r22, 0x07	; 7
    45c0:	0e 94 ff 7d 	call	0xfbfe	; 0xfbfe <__udivmodqi4>
    45c4:	59 0f       	add	r21, r25
    45c6:	31 96       	adiw	r30, 0x01	; 1
    45c8:	e2 17       	cp	r30, r18
    45ca:	f3 07       	cpc	r31, r19
    45cc:	b9 f7       	brne	.-18     	; 0x45bc <SetWeekday+0x22>
    45ce:	25 2f       	mov	r18, r21
	if (LastYear%4==3 && Month>2)
    45d0:	b3 70       	andi	r27, 0x03	; 3
    45d2:	b3 30       	cpi	r27, 0x03	; 3
    45d4:	51 f0       	breq	.+20     	; 0x45ea <SetWeekday+0x50>
		DayCount++;
    45d6:	84 2f       	mov	r24, r20
    45d8:	67 e0       	ldi	r22, 0x07	; 7
    45da:	0e 94 ff 7d 	call	0xfbfe	; 0xfbfe <__udivmodqi4>
    45de:	82 2f       	mov	r24, r18
    45e0:	89 0f       	add	r24, r25
    45e2:	0e 94 ff 7d 	call	0xfbfe	; 0xfbfe <__udivmodqi4>
	DayCount += MDay%7;
	return DayCount%7;
}
    45e6:	89 2f       	mov	r24, r25
    45e8:	08 95       	ret
	uint8_t DayCount;
	uint8_t LastYear = Year-1;

	DayCount = (LastYear+LastYear/4);
	for (uint8_t i=1; i<Month; DayCount+=prb(DaysMonth+i++)%7);
	if (LastYear%4==3 && Month>2)
    45ea:	a3 30       	cpi	r26, 0x03	; 3
    45ec:	a0 f3       	brcs	.-24     	; 0x45d6 <SetWeekday+0x3c>
		DayCount++;
    45ee:	2f 5f       	subi	r18, 0xFF	; 255
    45f0:	f2 cf       	rjmp	.-28     	; 0x45d6 <SetWeekday+0x3c>

000045f2 <SetSec>:
}
// ~~~~~~~~~
void
SetSec(void)
{
	WriteRTC(0, Tm_Sec);
    45f2:	80 e0       	ldi	r24, 0x00	; 0
    45f4:	60 91 ae 06 	lds	r22, 0x06AE
    45f8:	0e 94 7d 22 	call	0x44fa	; 0x44fa <WriteRTC>
	TrueTime_Sec = Tm_Sec;
    45fc:	80 91 ae 06 	lds	r24, 0x06AE
    4600:	80 93 c6 08 	sts	0x08C6, r24
}
    4604:	08 95       	ret

00004606 <SetMin>:

// ~~~~~~~~~
void
SetMin(void)
{
	WriteRTC(1, Tm_Min);
    4606:	81 e0       	ldi	r24, 0x01	; 1
    4608:	60 91 49 06 	lds	r22, 0x0649
    460c:	0e 94 7d 22 	call	0x44fa	; 0x44fa <WriteRTC>
	TrueTime_Min = Tm_Min;
    4610:	80 91 49 06 	lds	r24, 0x0649
    4614:	80 93 c8 08 	sts	0x08C8, r24
}
    4618:	08 95       	ret

0000461a <SetHour>:

// ~~~~~~~~~~
void
SetHour(void)
{
	WriteRTC(2,  Tm_Hour);
    461a:	82 e0       	ldi	r24, 0x02	; 2
    461c:	60 91 b9 05 	lds	r22, 0x05B9
    4620:	0e 94 7d 22 	call	0x44fa	; 0x44fa <WriteRTC>
	TrueTime_Hour = Tm_Hour;
    4624:	80 91 b9 05 	lds	r24, 0x05B9
    4628:	80 93 d0 05 	sts	0x05D0, r24
}
    462c:	08 95       	ret

0000462e <SetMDay>:
// ~~~~~~~~~~
void
SetMDay(void)
{
	WriteRTC(4,  Tm_MDay);
    462e:	84 e0       	ldi	r24, 0x04	; 4
    4630:	60 91 11 0b 	lds	r22, 0x0B11
    4634:	0e 94 7d 22 	call	0x44fa	; 0x44fa <WriteRTC>
	TrueTime_MDay = Tm_MDay;
    4638:	80 91 11 0b 	lds	r24, 0x0B11
    463c:	80 93 4e 06 	sts	0x064E, r24
}
    4640:	08 95       	ret

00004642 <SetMon>:
// ~~~~~~~~~
void
SetMon(void)
{
	WriteRTC(5, Tm_Mon);
    4642:	85 e0       	ldi	r24, 0x05	; 5
    4644:	60 91 7f 07 	lds	r22, 0x077F
    4648:	0e 94 7d 22 	call	0x44fa	; 0x44fa <WriteRTC>
	TrueTime_Mon = Tm_Mon;
    464c:	80 91 7f 07 	lds	r24, 0x077F
    4650:	80 93 c7 08 	sts	0x08C7, r24
}
    4654:	08 95       	ret

00004656 <SetYear>:
// ~~~~~~~~~~~~~
void
SetYear(void)
{
	WriteRTC(6, Tm_Year);
    4656:	86 e0       	ldi	r24, 0x06	; 6
    4658:	60 91 d6 05 	lds	r22, 0x05D6
    465c:	0e 94 7d 22 	call	0x44fa	; 0x44fa <WriteRTC>
	TrueTime_Year = Tm_Year;
    4660:	80 91 d6 05 	lds	r24, 0x05D6
    4664:	80 93 75 07 	sts	0x0775, r24
}
    4668:	08 95       	ret

0000466a <SetDateTime>:
// ~~~~~~~~~~~~~
void
SetDateTime(uint8_t Year, uint8_t Month, uint8_t Day, uint8_t WDay, uint8_t Hour, uint8_t Min, uint8_t Sec){
    466a:	5f 92       	push	r5
    466c:	6f 92       	push	r6
    466e:	7f 92       	push	r7
    4670:	8f 92       	push	r8
    4672:	9f 92       	push	r9
    4674:	af 92       	push	r10
    4676:	bf 92       	push	r11
    4678:	cf 92       	push	r12
    467a:	df 92       	push	r13
    467c:	ef 92       	push	r14
    467e:	ff 92       	push	r15
    4680:	0f 93       	push	r16
    4682:	1f 93       	push	r17
    4684:	58 2e       	mov	r5, r24
    4686:	66 2e       	mov	r6, r22
    4688:	74 2e       	mov	r7, r20
    468a:	f2 2e       	mov	r15, r18
    468c:	8c 2d       	mov	r24, r12
	PowerOffTWI();
    468e:	7c eb       	ldi	r23, 0xBC	; 188
    4690:	87 2e       	mov	r8, r23
    4692:	91 2c       	mov	r9, r1
    4694:	f4 01       	movw	r30, r8
    4696:	10 82       	st	Z, r1
    4698:	e0 e9       	ldi	r30, 0x90	; 144
    469a:	f1 e0       	ldi	r31, 0x01	; 1
    469c:	31 97       	sbiw	r30, 0x01	; 1
    469e:	f1 f7       	brne	.-4      	; 0x469c <SetDateTime+0x32>
	_delay_us(100);
	//_delay_us(150);_delay_us(150);
	StartTWI();
    46a0:	94 ea       	ldi	r25, 0xA4	; 164
    46a2:	f4 01       	movw	r30, r8
    46a4:	90 83       	st	Z, r25
    46a6:	68 e5       	ldi	r22, 0x58	; 88
    46a8:	c6 2e       	mov	r12, r22
    46aa:	62 e0       	ldi	r22, 0x02	; 2
    46ac:	d6 2e       	mov	r13, r22
    46ae:	f6 01       	movw	r30, r12
    46b0:	31 97       	sbiw	r30, 0x01	; 1
    46b2:	f1 f7       	brne	.-4      	; 0x46b0 <SetDateTime+0x46>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = SLA_W(PCF_SLA);
    46b4:	f6 01       	movw	r30, r12
    46b6:	31 97       	sbiw	r30, 0x01	; 1
    46b8:	f1 f7       	brne	.-4      	; 0x46b6 <SetDateTime+0x4c>
    46ba:	5b eb       	ldi	r21, 0xBB	; 187
    46bc:	a5 2e       	mov	r10, r21
    46be:	b1 2c       	mov	r11, r1
    46c0:	90 ed       	ldi	r25, 0xD0	; 208
    46c2:	f5 01       	movw	r30, r10
    46c4:	90 83       	st	Z, r25
    46c6:	90 81       	ld	r25, Z
    46c8:	90 83       	st	Z, r25
	RunTWI();
    46ca:	14 e8       	ldi	r17, 0x84	; 132
    46cc:	f4 01       	movw	r30, r8
    46ce:	10 83       	st	Z, r17
    46d0:	f6 01       	movw	r30, r12
    46d2:	31 97       	sbiw	r30, 0x01	; 1
    46d4:	f1 f7       	brne	.-4      	; 0x46d2 <SetDateTime+0x68>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = AddrSec;
    46d6:	f6 01       	movw	r30, r12
    46d8:	31 97       	sbiw	r30, 0x01	; 1
    46da:	f1 f7       	brne	.-4      	; 0x46d8 <SetDateTime+0x6e>
    46dc:	f5 01       	movw	r30, r10
    46de:	10 82       	st	Z, r1
	RunTWI();
    46e0:	f4 01       	movw	r30, r8
    46e2:	10 83       	st	Z, r17
    46e4:	f6 01       	movw	r30, r12
    46e6:	31 97       	sbiw	r30, 0x01	; 1
    46e8:	f1 f7       	brne	.-4      	; 0x46e6 <SetDateTime+0x7c>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = CodBCD(Sec);
    46ea:	f6 01       	movw	r30, r12
    46ec:	31 97       	sbiw	r30, 0x01	; 1
    46ee:	f1 f7       	brne	.-4      	; 0x46ec <SetDateTime+0x82>
    46f0:	0e 94 31 20 	call	0x4062	; 0x4062 <CodBCD>
    46f4:	f5 01       	movw	r30, r10
    46f6:	80 83       	st	Z, r24
	RunTWI();
    46f8:	f4 01       	movw	r30, r8
    46fa:	10 83       	st	Z, r17
    46fc:	c6 01       	movw	r24, r12
    46fe:	01 97       	sbiw	r24, 0x01	; 1
    4700:	f1 f7       	brne	.-4      	; 0x46fe <SetDateTime+0x94>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = CodBCD(Min);
    4702:	c6 01       	movw	r24, r12
    4704:	01 97       	sbiw	r24, 0x01	; 1
    4706:	f1 f7       	brne	.-4      	; 0x4704 <SetDateTime+0x9a>
    4708:	8e 2d       	mov	r24, r14
    470a:	0e 94 31 20 	call	0x4062	; 0x4062 <CodBCD>
    470e:	f5 01       	movw	r30, r10
    4710:	80 83       	st	Z, r24
	RunTWI();
    4712:	f4 01       	movw	r30, r8
    4714:	10 83       	st	Z, r17
    4716:	c6 01       	movw	r24, r12
    4718:	01 97       	sbiw	r24, 0x01	; 1
    471a:	f1 f7       	brne	.-4      	; 0x4718 <SetDateTime+0xae>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = CodBCD(Hour);
    471c:	c6 01       	movw	r24, r12
    471e:	01 97       	sbiw	r24, 0x01	; 1
    4720:	f1 f7       	brne	.-4      	; 0x471e <SetDateTime+0xb4>
    4722:	80 2f       	mov	r24, r16
    4724:	0e 94 31 20 	call	0x4062	; 0x4062 <CodBCD>
    4728:	f5 01       	movw	r30, r10
    472a:	80 83       	st	Z, r24
	RunTWI();
    472c:	f4 01       	movw	r30, r8
    472e:	10 83       	st	Z, r17
    4730:	c6 01       	movw	r24, r12
    4732:	01 97       	sbiw	r24, 0x01	; 1
    4734:	f1 f7       	brne	.-4      	; 0x4732 <SetDateTime+0xc8>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = WDay;
    4736:	c6 01       	movw	r24, r12
    4738:	01 97       	sbiw	r24, 0x01	; 1
    473a:	f1 f7       	brne	.-4      	; 0x4738 <SetDateTime+0xce>
    473c:	f5 01       	movw	r30, r10
    473e:	f0 82       	st	Z, r15
	RunTWI();
    4740:	f4 01       	movw	r30, r8
    4742:	10 83       	st	Z, r17
    4744:	c6 01       	movw	r24, r12
    4746:	01 97       	sbiw	r24, 0x01	; 1
    4748:	f1 f7       	brne	.-4      	; 0x4746 <SetDateTime+0xdc>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = CodBCD(Day);
    474a:	c6 01       	movw	r24, r12
    474c:	01 97       	sbiw	r24, 0x01	; 1
    474e:	f1 f7       	brne	.-4      	; 0x474c <SetDateTime+0xe2>
    4750:	87 2d       	mov	r24, r7
    4752:	0e 94 31 20 	call	0x4062	; 0x4062 <CodBCD>
    4756:	f5 01       	movw	r30, r10
    4758:	80 83       	st	Z, r24
	RunTWI();
    475a:	f4 01       	movw	r30, r8
    475c:	10 83       	st	Z, r17
    475e:	c6 01       	movw	r24, r12
    4760:	01 97       	sbiw	r24, 0x01	; 1
    4762:	f1 f7       	brne	.-4      	; 0x4760 <SetDateTime+0xf6>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = CodBCD(Month);
    4764:	c6 01       	movw	r24, r12
    4766:	01 97       	sbiw	r24, 0x01	; 1
    4768:	f1 f7       	brne	.-4      	; 0x4766 <SetDateTime+0xfc>
    476a:	86 2d       	mov	r24, r6
    476c:	0e 94 31 20 	call	0x4062	; 0x4062 <CodBCD>
    4770:	f5 01       	movw	r30, r10
    4772:	80 83       	st	Z, r24
	RunTWI();
    4774:	f4 01       	movw	r30, r8
    4776:	10 83       	st	Z, r17
    4778:	c6 01       	movw	r24, r12
    477a:	01 97       	sbiw	r24, 0x01	; 1
    477c:	f1 f7       	brne	.-4      	; 0x477a <SetDateTime+0x110>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = CodBCD(Year);
    477e:	c6 01       	movw	r24, r12
    4780:	01 97       	sbiw	r24, 0x01	; 1
    4782:	f1 f7       	brne	.-4      	; 0x4780 <SetDateTime+0x116>
    4784:	85 2d       	mov	r24, r5
    4786:	0e 94 31 20 	call	0x4062	; 0x4062 <CodBCD>
    478a:	f5 01       	movw	r30, r10
    478c:	80 83       	st	Z, r24
	RunTWI();
    478e:	f4 01       	movw	r30, r8
    4790:	10 83       	st	Z, r17
    4792:	c6 01       	movw	r24, r12
    4794:	01 97       	sbiw	r24, 0x01	; 1
    4796:	f1 f7       	brne	.-4      	; 0x4794 <SetDateTime+0x12a>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	StopTWI();
    4798:	c6 01       	movw	r24, r12
    479a:	01 97       	sbiw	r24, 0x01	; 1
    479c:	f1 f7       	brne	.-4      	; 0x479a <SetDateTime+0x130>
    479e:	84 e9       	ldi	r24, 0x94	; 148
    47a0:	80 83       	st	Z, r24
	TWI_Phase = PCF_START;
    47a2:	10 92 77 07 	sts	0x0777, r1
}
    47a6:	1f 91       	pop	r17
    47a8:	0f 91       	pop	r16
    47aa:	ff 90       	pop	r15
    47ac:	ef 90       	pop	r14
    47ae:	df 90       	pop	r13
    47b0:	cf 90       	pop	r12
    47b2:	bf 90       	pop	r11
    47b4:	af 90       	pop	r10
    47b6:	9f 90       	pop	r9
    47b8:	8f 90       	pop	r8
    47ba:	7f 90       	pop	r7
    47bc:	6f 90       	pop	r6
    47be:	5f 90       	pop	r5
    47c0:	08 95       	ret

000047c2 <RTC_Ready>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t RTC_Ready(void){
    47c2:	90 e0       	ldi	r25, 0x00	; 0
    47c4:	80 91 77 07 	lds	r24, 0x0777
    47c8:	88 23       	and	r24, r24
    47ca:	09 f4       	brne	.+2      	; 0x47ce <RTC_Ready+0xc>
    47cc:	91 e0       	ldi	r25, 0x01	; 1
	if(TWI_Phase == PCF_START) return 1;
	else return 0;
}
    47ce:	89 2f       	mov	r24, r25
    47d0:	08 95       	ret

000047d2 <RTC_GetTrueTime>:
void RTC_GetTrueTime(void){
	TrueTime_Sec = Tm_Sec;
    47d2:	80 91 ae 06 	lds	r24, 0x06AE
    47d6:	80 93 c6 08 	sts	0x08C6, r24
	TrueTime_Min = Tm_Min;
    47da:	80 91 49 06 	lds	r24, 0x0649
    47de:	80 93 c8 08 	sts	0x08C8, r24
	TrueTime_Hour = Tm_Hour;
    47e2:	80 91 b9 05 	lds	r24, 0x05B9
    47e6:	80 93 d0 05 	sts	0x05D0, r24
	TrueTime_MDay = Tm_MDay;
    47ea:	40 91 11 0b 	lds	r20, 0x0B11
    47ee:	40 93 4e 06 	sts	0x064E, r20
	TrueTime_Mon = Tm_Mon;
    47f2:	60 91 7f 07 	lds	r22, 0x077F
    47f6:	60 93 c7 08 	sts	0x08C7, r22
	TrueTime_Year = Tm_Year;
    47fa:	80 91 d6 05 	lds	r24, 0x05D6
    47fe:	80 93 75 07 	sts	0x0775, r24
	TrueTime_WDay = SetWeekday(TrueTime_Year, TrueTime_Mon, TrueTime_MDay);
    4802:	0e 94 cd 22 	call	0x459a	; 0x459a <SetWeekday>
    4806:	80 93 10 0b 	sts	0x0B10, r24
}
    480a:	08 95       	ret

0000480c <RTC_SetTrueTime>:
void RTC_SetTrueTime(uint8_t Year, uint8_t Month, uint8_t Day, uint8_t WDay, uint8_t Hour, uint8_t Min, uint8_t Sec){
    480c:	8f 92       	push	r8
    480e:	9f 92       	push	r9
    4810:	af 92       	push	r10
    4812:	bf 92       	push	r11
    4814:	cf 92       	push	r12
    4816:	df 92       	push	r13
    4818:	ef 92       	push	r14
    481a:	ff 92       	push	r15
    481c:	0f 93       	push	r16
    481e:	1f 93       	push	r17
    4820:	88 2e       	mov	r8, r24
    4822:	a6 2e       	mov	r10, r22
    4824:	b4 2e       	mov	r11, r20
    4826:	92 2e       	mov	r9, r18
    4828:	d0 2e       	mov	r13, r16
    482a:	fe 2c       	mov	r15, r14
    482c:	1c 2d       	mov	r17, r12
	SetDateTime(Year, Month, Day, WDay, Hour, Min, Sec);
    482e:	0e 94 35 23 	call	0x466a	; 0x466a <SetDateTime>
	TrueTime_Sec = Sec;
    4832:	10 93 c6 08 	sts	0x08C6, r17
	TrueTime_Min = Min;
    4836:	f0 92 c8 08 	sts	0x08C8, r15
	TrueTime_Hour = Hour;
    483a:	d0 92 d0 05 	sts	0x05D0, r13
	TrueTime_MDay = Day;
    483e:	b0 92 4e 06 	sts	0x064E, r11
	TrueTime_Mon = Month;
    4842:	a0 92 c7 08 	sts	0x08C7, r10
	TrueTime_Year = Year;
    4846:	80 92 75 07 	sts	0x0775, r8
	TrueTime_WDay = WDay;
    484a:	90 92 10 0b 	sts	0x0B10, r9
}
    484e:	1f 91       	pop	r17
    4850:	0f 91       	pop	r16
    4852:	ff 90       	pop	r15
    4854:	ef 90       	pop	r14
    4856:	df 90       	pop	r13
    4858:	cf 90       	pop	r12
    485a:	bf 90       	pop	r11
    485c:	af 90       	pop	r10
    485e:	9f 90       	pop	r9
    4860:	8f 90       	pop	r8
    4862:	08 95       	ret

00004864 <RTC_Check>:

//  3 

uint8_t RTC_Check(void){

	if( (Tm_Year == TrueTime_Year)  && (Tm_Mon == TrueTime_Mon) && (Tm_MDay == TrueTime_MDay) &&
    4864:	50 91 d6 05 	lds	r21, 0x05D6
    4868:	40 91 75 07 	lds	r20, 0x0775
    486c:	54 17       	cp	r21, r20
    486e:	59 f1       	breq	.+86     	; 0x48c6 <RTC_Check+0x62>
    4870:	90 91 c6 08 	lds	r25, 0x08C6
			(Tm_Hour == TrueTime_Hour) && (Tm_Min == TrueTime_Min) && (Tm_Sec == TrueTime_Sec) ) return 1;

	if(TrueTime_Sec>55){
    4874:	98 33       	cpi	r25, 0x38	; 56
    4876:	58 f0       	brcs	.+22     	; 0x488e <RTC_Check+0x2a>
		if(TrueTime_Min == 59){
    4878:	80 91 c8 08 	lds	r24, 0x08C8
    487c:	8b 33       	cpi	r24, 0x3B	; 59
    487e:	09 f4       	brne	.+2      	; 0x4882 <RTC_Check+0x1e>
    4880:	5a c0       	rjmp	.+180    	; 0x4936 <RTC_Check+0xd2>
			else{
				if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ) return 1;
			}
		}
		else{
			if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ||
    4882:	54 17       	cp	r21, r20
    4884:	09 f4       	brne	.+2      	; 0x4888 <RTC_Check+0x24>
    4886:	40 c0       	rjmp	.+128    	; 0x4908 <RTC_Check+0xa4>
				(Tm_Hour != TrueTime_Hour) ) return 1;		
		}
	}
	else{
		if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ||
    4888:	21 e0       	ldi	r18, 0x01	; 1
			(Tm_Hour != TrueTime_Hour) || (Tm_Min != TrueTime_Min) ) return 1;
	}
	
	return 0;
}
    488a:	82 2f       	mov	r24, r18
    488c:	08 95       	ret
			if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ||
				(Tm_Hour != TrueTime_Hour) ) return 1;		
		}
	}
	else{
		if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ||
    488e:	54 17       	cp	r21, r20
    4890:	d9 f7       	brne	.-10     	; 0x4888 <RTC_Check+0x24>
    4892:	90 91 7f 07 	lds	r25, 0x077F
    4896:	80 91 c7 08 	lds	r24, 0x08C7
    489a:	98 17       	cp	r25, r24
    489c:	a9 f7       	brne	.-22     	; 0x4888 <RTC_Check+0x24>
    489e:	90 91 11 0b 	lds	r25, 0x0B11
    48a2:	80 91 4e 06 	lds	r24, 0x064E
    48a6:	98 17       	cp	r25, r24
    48a8:	79 f7       	brne	.-34     	; 0x4888 <RTC_Check+0x24>
    48aa:	90 91 b9 05 	lds	r25, 0x05B9
    48ae:	80 91 d0 05 	lds	r24, 0x05D0
    48b2:	98 17       	cp	r25, r24
    48b4:	49 f7       	brne	.-46     	; 0x4888 <RTC_Check+0x24>
    48b6:	20 e0       	ldi	r18, 0x00	; 0
    48b8:	90 91 49 06 	lds	r25, 0x0649
    48bc:	80 91 c8 08 	lds	r24, 0x08C8
    48c0:	98 17       	cp	r25, r24
    48c2:	11 f7       	brne	.-60     	; 0x4888 <RTC_Check+0x24>
    48c4:	e2 cf       	rjmp	.-60     	; 0x488a <RTC_Check+0x26>

//  3 

uint8_t RTC_Check(void){

	if( (Tm_Year == TrueTime_Year)  && (Tm_Mon == TrueTime_Mon) && (Tm_MDay == TrueTime_MDay) &&
    48c6:	90 91 7f 07 	lds	r25, 0x077F
    48ca:	80 91 c7 08 	lds	r24, 0x08C7
    48ce:	98 17       	cp	r25, r24
    48d0:	79 f6       	brne	.-98     	; 0x4870 <RTC_Check+0xc>
    48d2:	90 91 11 0b 	lds	r25, 0x0B11
    48d6:	80 91 4e 06 	lds	r24, 0x064E
    48da:	98 17       	cp	r25, r24
    48dc:	49 f6       	brne	.-110    	; 0x4870 <RTC_Check+0xc>
    48de:	90 91 b9 05 	lds	r25, 0x05B9
    48e2:	80 91 d0 05 	lds	r24, 0x05D0
    48e6:	98 17       	cp	r25, r24
    48e8:	19 f6       	brne	.-122    	; 0x4870 <RTC_Check+0xc>
    48ea:	90 91 49 06 	lds	r25, 0x0649
    48ee:	80 91 c8 08 	lds	r24, 0x08C8
    48f2:	98 17       	cp	r25, r24
    48f4:	09 f0       	breq	.+2      	; 0x48f8 <RTC_Check+0x94>
    48f6:	bc cf       	rjmp	.-136    	; 0x4870 <RTC_Check+0xc>
    48f8:	80 91 ae 06 	lds	r24, 0x06AE
    48fc:	90 91 c6 08 	lds	r25, 0x08C6
    4900:	89 17       	cp	r24, r25
    4902:	09 f0       	breq	.+2      	; 0x4906 <RTC_Check+0xa2>
    4904:	b7 cf       	rjmp	.-146    	; 0x4874 <RTC_Check+0x10>
    4906:	c0 cf       	rjmp	.-128    	; 0x4888 <RTC_Check+0x24>
			else{
				if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ) return 1;
			}
		}
		else{
			if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ||
    4908:	90 91 7f 07 	lds	r25, 0x077F
    490c:	80 91 c7 08 	lds	r24, 0x08C7
    4910:	98 17       	cp	r25, r24
    4912:	09 f0       	breq	.+2      	; 0x4916 <RTC_Check+0xb2>
    4914:	b9 cf       	rjmp	.-142    	; 0x4888 <RTC_Check+0x24>
    4916:	90 91 11 0b 	lds	r25, 0x0B11
    491a:	80 91 4e 06 	lds	r24, 0x064E
    491e:	98 17       	cp	r25, r24
    4920:	09 f0       	breq	.+2      	; 0x4924 <RTC_Check+0xc0>
    4922:	b2 cf       	rjmp	.-156    	; 0x4888 <RTC_Check+0x24>
    4924:	20 e0       	ldi	r18, 0x00	; 0
    4926:	90 91 b9 05 	lds	r25, 0x05B9
    492a:	80 91 d0 05 	lds	r24, 0x05D0
    492e:	98 17       	cp	r25, r24
    4930:	09 f0       	breq	.+2      	; 0x4934 <RTC_Check+0xd0>
    4932:	aa cf       	rjmp	.-172    	; 0x4888 <RTC_Check+0x24>
    4934:	aa cf       	rjmp	.-172    	; 0x488a <RTC_Check+0x26>
	if( (Tm_Year == TrueTime_Year)  && (Tm_Mon == TrueTime_Mon) && (Tm_MDay == TrueTime_MDay) &&
			(Tm_Hour == TrueTime_Hour) && (Tm_Min == TrueTime_Min) && (Tm_Sec == TrueTime_Sec) ) return 1;

	if(TrueTime_Sec>55){
		if(TrueTime_Min == 59){
			if(TrueTime_Hour == 23){
    4936:	80 91 d0 05 	lds	r24, 0x05D0
    493a:	87 31       	cpi	r24, 0x17	; 23
    493c:	99 f0       	breq	.+38     	; 0x4964 <RTC_Check+0x100>
				else{
					if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) ) return 1;
				}
			}
			else{
				if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ) return 1;
    493e:	54 17       	cp	r21, r20
    4940:	09 f0       	breq	.+2      	; 0x4944 <RTC_Check+0xe0>
    4942:	a2 cf       	rjmp	.-188    	; 0x4888 <RTC_Check+0x24>
    4944:	90 91 7f 07 	lds	r25, 0x077F
    4948:	80 91 c7 08 	lds	r24, 0x08C7
    494c:	98 17       	cp	r25, r24
    494e:	09 f0       	breq	.+2      	; 0x4952 <RTC_Check+0xee>
    4950:	9b cf       	rjmp	.-202    	; 0x4888 <RTC_Check+0x24>
    4952:	20 e0       	ldi	r18, 0x00	; 0
    4954:	90 91 11 0b 	lds	r25, 0x0B11
    4958:	80 91 4e 06 	lds	r24, 0x064E
    495c:	98 17       	cp	r25, r24
    495e:	09 f0       	breq	.+2      	; 0x4962 <RTC_Check+0xfe>
    4960:	93 cf       	rjmp	.-218    	; 0x4888 <RTC_Check+0x24>
    4962:	93 cf       	rjmp	.-218    	; 0x488a <RTC_Check+0x26>
			(Tm_Hour == TrueTime_Hour) && (Tm_Min == TrueTime_Min) && (Tm_Sec == TrueTime_Sec) ) return 1;

	if(TrueTime_Sec>55){
		if(TrueTime_Min == 59){
			if(TrueTime_Hour == 23){
				if(TrueTime_MDay >= 28){
    4964:	80 91 4e 06 	lds	r24, 0x064E
    4968:	8c 31       	cpi	r24, 0x1C	; 28
    496a:	48 f0       	brcs	.+18     	; 0x497e <RTC_Check+0x11a>
					if(TrueTime_Mon == 12){
    496c:	80 91 c7 08 	lds	r24, 0x08C7
    4970:	8c 30       	cpi	r24, 0x0C	; 12
    4972:	89 f0       	breq	.+34     	; 0x4996 <RTC_Check+0x132>
						if( ((TrueTime_Year+1) == Tm_Year) || (TrueTime_Year==Tm_Year) || ((TrueTime_Year==99) && (Tm_Year==0)) ) return 0;
    4974:	20 e0       	ldi	r18, 0x00	; 0
    4976:	54 17       	cp	r21, r20
    4978:	09 f0       	breq	.+2      	; 0x497c <RTC_Check+0x118>
    497a:	86 cf       	rjmp	.-244    	; 0x4888 <RTC_Check+0x24>
    497c:	86 cf       	rjmp	.-244    	; 0x488a <RTC_Check+0x26>
					else{
						if(Tm_Year!= TrueTime_Year) return 1;
					}
				}
				else{
					if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) ) return 1;
    497e:	54 17       	cp	r21, r20
    4980:	09 f0       	breq	.+2      	; 0x4984 <RTC_Check+0x120>
    4982:	82 cf       	rjmp	.-252    	; 0x4888 <RTC_Check+0x24>
    4984:	20 e0       	ldi	r18, 0x00	; 0
    4986:	90 91 7f 07 	lds	r25, 0x077F
    498a:	80 91 c7 08 	lds	r24, 0x08C7
    498e:	98 17       	cp	r25, r24
    4990:	09 f0       	breq	.+2      	; 0x4994 <RTC_Check+0x130>
    4992:	7a cf       	rjmp	.-268    	; 0x4888 <RTC_Check+0x24>
    4994:	7a cf       	rjmp	.-268    	; 0x488a <RTC_Check+0x26>
	if(TrueTime_Sec>55){
		if(TrueTime_Min == 59){
			if(TrueTime_Hour == 23){
				if(TrueTime_MDay >= 28){
					if(TrueTime_Mon == 12){
						if( ((TrueTime_Year+1) == Tm_Year) || (TrueTime_Year==Tm_Year) || ((TrueTime_Year==99) && (Tm_Year==0)) ) return 0;
    4996:	84 2f       	mov	r24, r20
    4998:	90 e0       	ldi	r25, 0x00	; 0
    499a:	01 96       	adiw	r24, 0x01	; 1
    499c:	25 2f       	mov	r18, r21
    499e:	30 e0       	ldi	r19, 0x00	; 0
    49a0:	82 17       	cp	r24, r18
    49a2:	93 07       	cpc	r25, r19
    49a4:	61 f0       	breq	.+24     	; 0x49be <RTC_Check+0x15a>
    49a6:	54 17       	cp	r21, r20
    49a8:	51 f0       	breq	.+20     	; 0x49be <RTC_Check+0x15a>
    49aa:	43 36       	cpi	r20, 0x63	; 99
    49ac:	09 f0       	breq	.+2      	; 0x49b0 <RTC_Check+0x14c>
    49ae:	6c cf       	rjmp	.-296    	; 0x4888 <RTC_Check+0x24>
    49b0:	20 e0       	ldi	r18, 0x00	; 0
    49b2:	55 23       	and	r21, r21
    49b4:	09 f4       	brne	.+2      	; 0x49b8 <RTC_Check+0x154>
    49b6:	21 e0       	ldi	r18, 0x01	; 1
    49b8:	81 e0       	ldi	r24, 0x01	; 1
    49ba:	28 27       	eor	r18, r24
    49bc:	66 cf       	rjmp	.-308    	; 0x488a <RTC_Check+0x26>
			if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ||
				(Tm_Hour != TrueTime_Hour) ) return 1;		
		}
	}
	else{
		if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ||
    49be:	20 e0       	ldi	r18, 0x00	; 0
    49c0:	64 cf       	rjmp	.-312    	; 0x488a <RTC_Check+0x26>

000049c2 <GSM_PWRCNTRL_Config>:
#endif

//  gsm_sim900r.h   PWRCNTRL
#ifdef vmd2_3
	void GSM_PWRCNTRL_Config(void){
		cli();
    49c2:	f8 94       	cli
		DDRL|=(1<<PL5);
    49c4:	ea e0       	ldi	r30, 0x0A	; 10
    49c6:	f1 e0       	ldi	r31, 0x01	; 1
    49c8:	80 81       	ld	r24, Z
    49ca:	80 62       	ori	r24, 0x20	; 32
    49cc:	80 83       	st	Z, r24
		sei();
    49ce:	78 94       	sei
	}
    49d0:	08 95       	ret

000049d2 <GSM_PWRCNTRL_OFF>:
	void GSM_PWRCNTRL_OFF(void){
		cli();
    49d2:	f8 94       	cli
		PORTL|=(1<<PL5);
    49d4:	eb e0       	ldi	r30, 0x0B	; 11
    49d6:	f1 e0       	ldi	r31, 0x01	; 1
    49d8:	80 81       	ld	r24, Z
    49da:	80 62       	ori	r24, 0x20	; 32
    49dc:	80 83       	st	Z, r24
		sei();
    49de:	78 94       	sei
	}
    49e0:	08 95       	ret

000049e2 <GSM_PWRCNTRL_ON>:
	void GSM_PWRCNTRL_ON(void){
		cli();
    49e2:	f8 94       	cli
		PORTL &= ~(1<<PL5);
    49e4:	eb e0       	ldi	r30, 0x0B	; 11
    49e6:	f1 e0       	ldi	r31, 0x01	; 1
    49e8:	80 81       	ld	r24, Z
    49ea:	8f 7d       	andi	r24, 0xDF	; 223
    49ec:	80 83       	st	Z, r24
		sei();
    49ee:	78 94       	sei
	}
    49f0:	08 95       	ret

000049f2 <GSM_CTS_RTS_Config>:

	void GSM_CTS_RTS_Config(void){
		cli();
    49f2:	f8 94       	cli
		//TS
		DDRB &=~(1<<PB6);
    49f4:	26 98       	cbi	0x04, 6	; 4
		PORTB |=(1<<PB6);	//pull'up
    49f6:	2e 9a       	sbi	0x05, 6	; 5
		//RTS
		DDRG |= (1<<PG5);
    49f8:	9d 9a       	sbi	0x13, 5	; 19
		PORTG &= ~(1<<PG5);
    49fa:	a5 98       	cbi	0x14, 5	; 20
		sei();
    49fc:	78 94       	sei
	}
    49fe:	08 95       	ret

00004a00 <GSM_CTS_State>:
	uint8_t GSM_CTS_State(void){
		return PINB & (1<<PB6);
    4a00:	83 b1       	in	r24, 0x03	; 3
	}
    4a02:	80 74       	andi	r24, 0x40	; 64
    4a04:	08 95       	ret

00004a06 <GSM_RTS_OFF>:
	void GSM_RTS_OFF(void){
		cli();
    4a06:	f8 94       	cli
		PORTG &= ~(1<<PG5);
    4a08:	a5 98       	cbi	0x14, 5	; 20
		sei();
    4a0a:	78 94       	sei
	}
    4a0c:	08 95       	ret

00004a0e <GSM_RTS_ON>:
	void GSM_RTS_ON(void){
		cli();
    4a0e:	f8 94       	cli
		PORTG |= (1<<PG5);
    4a10:	a5 9a       	sbi	0x14, 5	; 20
		sei();
    4a12:	78 94       	sei
	}
    4a14:	08 95       	ret

00004a16 <LED_Init>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    4a16:	8f b7       	in	r24, 0x3f	; 63
    4a18:	80 78       	andi	r24, 0x80	; 128
    4a1a:	80 93 e6 02 	sts	0x02E6, r24
	cli();
    4a1e:	f8 94       	cli
//~~~~~~~~~~~~
void
LED_Init(void)
{
	IntOff();
	DDR_LED |=PinLED;
    4a20:	83 9a       	sbi	0x10, 3	; 16
	LED_Rst();
    4a22:	8b 98       	cbi	0x11, 3	; 17

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    4a24:	88 23       	and	r24, r24
    4a26:	09 f0       	breq	.+2      	; 0x4a2a <LED_Init+0x14>
		sei();
    4a28:	78 94       	sei
    4a2a:	08 95       	ret

00004a2c <LED_On>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    4a2c:	8f b7       	in	r24, 0x3f	; 63
    4a2e:	80 78       	andi	r24, 0x80	; 128
    4a30:	80 93 e6 02 	sts	0x02E6, r24
	cli();
    4a34:	f8 94       	cli
// ~~~~~~~~~
void
LED_On(void)
{
	IntOff();
	LED_Set();
    4a36:	8b 9a       	sbi	0x11, 3	; 17

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    4a38:	88 23       	and	r24, r24
    4a3a:	09 f0       	breq	.+2      	; 0x4a3e <LED_On+0x12>
		sei();
    4a3c:	78 94       	sei
    4a3e:	08 95       	ret

00004a40 <LED_Off>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    4a40:	8f b7       	in	r24, 0x3f	; 63
    4a42:	80 78       	andi	r24, 0x80	; 128
    4a44:	80 93 e6 02 	sts	0x02E6, r24
	cli();
    4a48:	f8 94       	cli
// ~~~~~~~~~~
void
LED_Off(void)
{
	IntOff();
	LED_Rst();
    4a4a:	8b 98       	cbi	0x11, 3	; 17

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    4a4c:	88 23       	and	r24, r24
    4a4e:	09 f0       	breq	.+2      	; 0x4a52 <LED_Off+0x12>
		sei();
    4a50:	78 94       	sei
    4a52:	08 95       	ret

00004a54 <LED_Toggle>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    4a54:	8f b7       	in	r24, 0x3f	; 63
    4a56:	80 78       	andi	r24, 0x80	; 128
    4a58:	80 93 e6 02 	sts	0x02E6, r24
	cli();
    4a5c:	f8 94       	cli
// ~~~~~~~~~~~~~
uint8_t
LED_Toggle(void)
{
	IntOff();
	LED_Inv();
    4a5e:	91 b3       	in	r25, 0x11	; 17
    4a60:	28 e0       	ldi	r18, 0x08	; 8
    4a62:	92 27       	eor	r25, r18
    4a64:	91 bb       	out	0x11, r25	; 17

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    4a66:	88 23       	and	r24, r24
    4a68:	09 f0       	breq	.+2      	; 0x4a6c <LED_Toggle+0x18>
		sei();
    4a6a:	78 94       	sei
	IntOn();
	return PortLED &PinLED;
    4a6c:	81 b3       	in	r24, 0x11	; 17
}
    4a6e:	88 70       	andi	r24, 0x08	; 8
    4a70:	08 95       	ret

00004a72 <Send>:
#ifdef Port_LCD_DB0	//8-bit width data bus
	// ~~~~~~~~~~~~~~
	static void
	Send(uint8_t Val)
	{
		if (Val &(1<<0)) Port_LCD_DB0 |=DB0; else Port_LCD_DB0 &=~DB0;
    4a72:	98 2f       	mov	r25, r24
    4a74:	80 ff       	sbrs	r24, 0
    4a76:	23 c0       	rjmp	.+70     	; 0x4abe <Send+0x4c>
    4a78:	41 9a       	sbi	0x08, 1	; 8
		if (Val &(1<<1)) Port_LCD_DB1 |=DB1; else Port_LCD_DB1 &=~DB1;
    4a7a:	91 ff       	sbrs	r25, 1
    4a7c:	23 c0       	rjmp	.+70     	; 0x4ac4 <Send+0x52>
    4a7e:	40 9a       	sbi	0x08, 0	; 8
		if (Val &(1<<2)) Port_LCD_DB2 |=DB2; else Port_LCD_DB2 &=~DB2;
    4a80:	92 ff       	sbrs	r25, 2
    4a82:	23 c0       	rjmp	.+70     	; 0x4aca <Send+0x58>
    4a84:	a1 9a       	sbi	0x14, 1	; 20
		if (Val &(1<<3)) Port_LCD_DB3 |=DB3; else Port_LCD_DB3 &=~DB3;
    4a86:	93 ff       	sbrs	r25, 3
    4a88:	23 c0       	rjmp	.+70     	; 0x4ad0 <Send+0x5e>
    4a8a:	a0 9a       	sbi	0x14, 0	; 20
		if (Val &(1<<4)) Port_LCD_DB4 |=DB4; else Port_LCD_DB4 &=~DB4;
    4a8c:	94 ff       	sbrs	r25, 4
    4a8e:	23 c0       	rjmp	.+70     	; 0x4ad6 <Send+0x64>
    4a90:	5f 9a       	sbi	0x0b, 7	; 11
		if (Val &(1<<5)) Port_LCD_DB5 |=DB5; else Port_LCD_DB5 &=~DB5;
    4a92:	95 ff       	sbrs	r25, 5
    4a94:	23 c0       	rjmp	.+70     	; 0x4adc <Send+0x6a>
    4a96:	5e 9a       	sbi	0x0b, 6	; 11
		if (Val &(1<<6)) Port_LCD_DB6 |=DB6; else Port_LCD_DB6 &=~DB6;
    4a98:	96 ff       	sbrs	r25, 6
    4a9a:	23 c0       	rjmp	.+70     	; 0x4ae2 <Send+0x70>
    4a9c:	5d 9a       	sbi	0x0b, 5	; 11
		if (Val &(1<<7)) Port_LCD_DB7 |=DB7; else Port_LCD_DB7 &=~DB7;
    4a9e:	87 fd       	sbrc	r24, 7
    4aa0:	23 c0       	rjmp	.+70     	; 0x4ae8 <Send+0x76>
    4aa2:	80 91 0b 01 	lds	r24, 0x010B
    4aa6:	8f 77       	andi	r24, 0x7F	; 127
    4aa8:	80 93 0b 01 	sts	0x010B, r24

		Port_LCD_E |=LCD_E;
    4aac:	42 9a       	sbi	0x08, 2	; 8
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    4aae:	85 e0       	ldi	r24, 0x05	; 5
    4ab0:	98 2f       	mov	r25, r24
    4ab2:	9a 95       	dec	r25
    4ab4:	f1 f7       	brne	.-4      	; 0x4ab2 <Send+0x40>
		_delay_us(1);		// 450 ns needs
		Port_LCD_E &=~LCD_E;
    4ab6:	42 98       	cbi	0x08, 2	; 8
    4ab8:	8a 95       	dec	r24
    4aba:	f1 f7       	brne	.-4      	; 0x4ab8 <Send+0x46>
		_delay_us(1);		// 10 ns needs
	}
    4abc:	08 95       	ret
#ifdef Port_LCD_DB0	//8-bit width data bus
	// ~~~~~~~~~~~~~~
	static void
	Send(uint8_t Val)
	{
		if (Val &(1<<0)) Port_LCD_DB0 |=DB0; else Port_LCD_DB0 &=~DB0;
    4abe:	41 98       	cbi	0x08, 1	; 8
		if (Val &(1<<1)) Port_LCD_DB1 |=DB1; else Port_LCD_DB1 &=~DB1;
    4ac0:	91 fd       	sbrc	r25, 1
    4ac2:	dd cf       	rjmp	.-70     	; 0x4a7e <Send+0xc>
    4ac4:	40 98       	cbi	0x08, 0	; 8
		if (Val &(1<<2)) Port_LCD_DB2 |=DB2; else Port_LCD_DB2 &=~DB2;
    4ac6:	92 fd       	sbrc	r25, 2
    4ac8:	dd cf       	rjmp	.-70     	; 0x4a84 <Send+0x12>
    4aca:	a1 98       	cbi	0x14, 1	; 20
		if (Val &(1<<3)) Port_LCD_DB3 |=DB3; else Port_LCD_DB3 &=~DB3;
    4acc:	93 fd       	sbrc	r25, 3
    4ace:	dd cf       	rjmp	.-70     	; 0x4a8a <Send+0x18>
    4ad0:	a0 98       	cbi	0x14, 0	; 20
		if (Val &(1<<4)) Port_LCD_DB4 |=DB4; else Port_LCD_DB4 &=~DB4;
    4ad2:	94 fd       	sbrc	r25, 4
    4ad4:	dd cf       	rjmp	.-70     	; 0x4a90 <Send+0x1e>
    4ad6:	5f 98       	cbi	0x0b, 7	; 11
		if (Val &(1<<5)) Port_LCD_DB5 |=DB5; else Port_LCD_DB5 &=~DB5;
    4ad8:	95 fd       	sbrc	r25, 5
    4ada:	dd cf       	rjmp	.-70     	; 0x4a96 <Send+0x24>
    4adc:	5e 98       	cbi	0x0b, 6	; 11
		if (Val &(1<<6)) Port_LCD_DB6 |=DB6; else Port_LCD_DB6 &=~DB6;
    4ade:	96 fd       	sbrc	r25, 6
    4ae0:	dd cf       	rjmp	.-70     	; 0x4a9c <Send+0x2a>
    4ae2:	5d 98       	cbi	0x0b, 5	; 11
		if (Val &(1<<7)) Port_LCD_DB7 |=DB7; else Port_LCD_DB7 &=~DB7;
    4ae4:	87 ff       	sbrs	r24, 7
    4ae6:	dd cf       	rjmp	.-70     	; 0x4aa2 <Send+0x30>
    4ae8:	80 91 0b 01 	lds	r24, 0x010B
    4aec:	80 68       	ori	r24, 0x80	; 128
    4aee:	80 93 0b 01 	sts	0x010B, r24
    4af2:	dc cf       	rjmp	.-72     	; 0x4aac <Send+0x3a>

00004af4 <Send_I>:
#endif
// ~~~~~~~~~~~~~~~~
static void
Send_I(uint8_t Val)
{
	Send(Val);
    4af4:	0e 94 39 25 	call	0x4a72	; 0x4a72 <Send>
	Delay_us(LCD_Delay);
    4af8:	82 e3       	ldi	r24, 0x32	; 50
    4afa:	90 e0       	ldi	r25, 0x00	; 0
    4afc:	0e 94 2f 1d 	call	0x3a5e	; 0x3a5e <Delay_us>
}
    4b00:	08 95       	ret

00004b02 <LCD_FuncSet0>:

// ~~~~~~~~~~~
static void
LCD_FuncSet0(void)
{
	Port_LCD_DB4  |=DB4;
    4b02:	5f 9a       	sbi	0x0b, 7	; 11
	Port_LCD_DB5  |=DB5;
    4b04:	5e 9a       	sbi	0x0b, 6	; 11
	Port_LCD_DB6 &=~DB6;
    4b06:	5d 98       	cbi	0x0b, 5	; 11
	Port_LCD_DB7 &=~DB7;
    4b08:	eb e0       	ldi	r30, 0x0B	; 11
    4b0a:	f1 e0       	ldi	r31, 0x01	; 1
    4b0c:	80 81       	ld	r24, Z
    4b0e:	8f 77       	andi	r24, 0x7F	; 127
    4b10:	80 83       	st	Z, r24
}
    4b12:	08 95       	ret

00004b14 <LCD_Rdy>:
}

// ~~~~~~~~~~
uint8_t
LCD_Rdy(void)
{
    4b14:	1f 93       	push	r17
	uint8_t Rdy = Timer8Stopp(TD_LCD);
    4b16:	10 91 cf 04 	lds	r17, 0x04CF
    4b1a:	81 2f       	mov	r24, r17
    4b1c:	0e 94 36 1b 	call	0x366c	; 0x366c <Timer8Stopp>
	Rdy = Rdy && !(TIMSK_LCD &(1<<OCIE1B));
    4b20:	88 23       	and	r24, r24
    4b22:	29 f0       	breq	.+10     	; 0x4b2e <LCD_Rdy+0x1a>
    4b24:	80 91 6f 00 	lds	r24, 0x006F
    4b28:	82 ff       	sbrs	r24, 2
    4b2a:	03 c0       	rjmp	.+6      	; 0x4b32 <LCD_Rdy+0x1e>
    4b2c:	80 e0       	ldi	r24, 0x00	; 0
	if (Rdy)
		StartTimer8(TD_LCD, 6);
	return Rdy;
}
    4b2e:	1f 91       	pop	r17
    4b30:	08 95       	ret
LCD_Rdy(void)
{
	uint8_t Rdy = Timer8Stopp(TD_LCD);
	Rdy = Rdy && !(TIMSK_LCD &(1<<OCIE1B));
	if (Rdy)
		StartTimer8(TD_LCD, 6);
    4b32:	81 2f       	mov	r24, r17
    4b34:	66 e0       	ldi	r22, 0x06	; 6
    4b36:	0e 94 e2 19 	call	0x33c4	; 0x33c4 <StartTimer8>
    4b3a:	81 e0       	ldi	r24, 0x01	; 1
	return Rdy;
}
    4b3c:	1f 91       	pop	r17
    4b3e:	08 95       	ret

00004b40 <LCD_Out>:
LCD_Out(void)
{
	static uint8_t N;
	uint16_t LCD_delay = 100;	//50us

	if( (N>=20) && !LCD_Rst_Flg ){
    4b40:	90 91 e3 02 	lds	r25, 0x02E3
    4b44:	94 31       	cpi	r25, 0x14	; 20
    4b46:	20 f0       	brcs	.+8      	; 0x4b50 <LCD_Out+0x10>
    4b48:	80 91 ce 04 	lds	r24, 0x04CE
    4b4c:	88 23       	and	r24, r24
    4b4e:	19 f1       	breq	.+70     	; 0x4b96 <LCD_Out+0x56>
		LCD_Rst0();
		LCD_Rst_Flg = 1;
		LCD_delay = 10000;	//5ms
	}
	else {
		N++;
    4b50:	9f 5f       	subi	r25, 0xFF	; 255
    4b52:	90 93 e3 02 	sts	0x02E3, r25
    4b56:	24 e6       	ldi	r18, 0x64	; 100
    4b58:	30 e0       	ldi	r19, 0x00	; 0
	}

	cli();
    4b5a:	f8 94       	cli
	LCD_delay = TCNT1 + LCD_delay;
    4b5c:	80 91 84 00 	lds	r24, 0x0084
    4b60:	90 91 85 00 	lds	r25, 0x0085
    4b64:	82 0f       	add	r24, r18
    4b66:	93 1f       	adc	r25, r19
	if(LCD_delay >= 20000) OCR1B = LCD_delay - 20000;
    4b68:	2e e4       	ldi	r18, 0x4E	; 78
    4b6a:	80 32       	cpi	r24, 0x20	; 32
    4b6c:	92 07       	cpc	r25, r18
    4b6e:	60 f4       	brcc	.+24     	; 0x4b88 <LCD_Out+0x48>
	else OCR1B = LCD_delay;
    4b70:	90 93 8b 00 	sts	0x008B, r25
    4b74:	80 93 8a 00 	sts	0x008A, r24
	TIFR_LCD |= (1<<OCF1B);
    4b78:	b2 9a       	sbi	0x16, 2	; 22
	TIMSK_LCD |= (1<<OCIE1B);
    4b7a:	80 91 6f 00 	lds	r24, 0x006F
    4b7e:	84 60       	ori	r24, 0x04	; 4
    4b80:	80 93 6f 00 	sts	0x006F, r24
	sei();
    4b84:	78 94       	sei
}
    4b86:	08 95       	ret
		N++;
	}

	cli();
	LCD_delay = TCNT1 + LCD_delay;
	if(LCD_delay >= 20000) OCR1B = LCD_delay - 20000;
    4b88:	80 52       	subi	r24, 0x20	; 32
    4b8a:	9e 44       	sbci	r25, 0x4E	; 78
    4b8c:	90 93 8b 00 	sts	0x008B, r25
    4b90:	80 93 8a 00 	sts	0x008A, r24
    4b94:	f1 cf       	rjmp	.-30     	; 0x4b78 <LCD_Out+0x38>
{
	static uint8_t N;
	uint16_t LCD_delay = 100;	//50us

	if( (N>=20) && !LCD_Rst_Flg ){
		N = 0;
    4b96:	10 92 e3 02 	sts	0x02E3, r1
#endif
// ~~~~~~~~~~~
static void
LCD_Rst0(void)
{
	cli();
    4b9a:	f8 94       	cli
	Port_LCD_RS &=~LCD_RS;
    4b9c:	44 98       	cbi	0x08, 4	; 8
	LCD_FuncSet0();
    4b9e:	0e 94 81 25 	call	0x4b02	; 0x4b02 <LCD_FuncSet0>
	sei();
    4ba2:	78 94       	sei
	uint16_t LCD_delay = 100;	//50us

	if( (N>=20) && !LCD_Rst_Flg ){
		N = 0;
		LCD_Rst0();
		LCD_Rst_Flg = 1;
    4ba4:	81 e0       	ldi	r24, 0x01	; 1
    4ba6:	80 93 ce 04 	sts	0x04CE, r24
    4baa:	20 e1       	ldi	r18, 0x10	; 16
    4bac:	37 e2       	ldi	r19, 0x27	; 39
    4bae:	d5 cf       	rjmp	.-86     	; 0x4b5a <LCD_Out+0x1a>

00004bb0 <__vector_18>:
	sei();
}

// ~~~~~~~~~~~~~~~~~~~~~~
// 40 us needs
ISR(TIMER1_COMPB_vect){
    4bb0:	1f 92       	push	r1
    4bb2:	0f 92       	push	r0
    4bb4:	0f b6       	in	r0, 0x3f	; 63
    4bb6:	0f 92       	push	r0
    4bb8:	0b b6       	in	r0, 0x3b	; 59
    4bba:	0f 92       	push	r0
    4bbc:	11 24       	eor	r1, r1
    4bbe:	ff 92       	push	r15
    4bc0:	0f 93       	push	r16
    4bc2:	1f 93       	push	r17
    4bc4:	2f 93       	push	r18
    4bc6:	3f 93       	push	r19
    4bc8:	4f 93       	push	r20
    4bca:	5f 93       	push	r21
    4bcc:	6f 93       	push	r22
    4bce:	7f 93       	push	r23
    4bd0:	8f 93       	push	r24
    4bd2:	9f 93       	push	r25
    4bd4:	af 93       	push	r26
    4bd6:	bf 93       	push	r27
    4bd8:	ef 93       	push	r30
    4bda:	ff 93       	push	r31

	uint16_t LCD_delay = 100;	//50us

	if (LCD_Rst_Flg) {
    4bdc:	80 91 ce 04 	lds	r24, 0x04CE
    4be0:	88 23       	and	r24, r24
    4be2:	f1 f0       	breq	.+60     	; 0x4c20 <__vector_18+0x70>
		switch(LCD_Rst_Flg){
    4be4:	10 91 ce 04 	lds	r17, 0x04CE
    4be8:	15 30       	cpi	r17, 0x05	; 5
    4bea:	09 f4       	brne	.+2      	; 0x4bee <__vector_18+0x3e>
    4bec:	b5 c0       	rjmp	.+362    	; 0x4d58 <__vector_18+0x1a8>
    4bee:	16 30       	cpi	r17, 0x06	; 6
    4bf0:	08 f4       	brcc	.+2      	; 0x4bf4 <__vector_18+0x44>
    4bf2:	a1 c0       	rjmp	.+322    	; 0x4d36 <__vector_18+0x186>
    4bf4:	17 30       	cpi	r17, 0x07	; 7
    4bf6:	09 f4       	brne	.+2      	; 0x4bfa <__vector_18+0x4a>
    4bf8:	15 c1       	rjmp	.+554    	; 0x4e24 <__vector_18+0x274>
    4bfa:	17 30       	cpi	r17, 0x07	; 7
    4bfc:	08 f0       	brcs	.+2      	; 0x4c00 <__vector_18+0x50>
    4bfe:	dc c0       	rjmp	.+440    	; 0x4db8 <__vector_18+0x208>
				break;
			case 5:
				Send(0b00001100);	//; Display on, cursor off, blink off	
				break;
			case 6:
				Send(0b00000110);	//; cursor shift right, no display shift
    4c00:	86 e0       	ldi	r24, 0x06	; 6
    4c02:	0e 94 39 25 	call	0x4a72	; 0x4a72 <Send>
				#endif
				Port_LCD_RS |=LCD_RS;
			default:
				LCD_Rst_Flg = 255;
		}
		if(LCD_Rst_Flg==1) LCD_delay = 400;	//200us
    4c06:	80 91 ce 04 	lds	r24, 0x04CE
    4c0a:	81 30       	cpi	r24, 0x01	; 1
    4c0c:	09 f4       	brne	.+2      	; 0x4c10 <__vector_18+0x60>
    4c0e:	a1 c0       	rjmp	.+322    	; 0x4d52 <__vector_18+0x1a2>
    4c10:	24 e6       	ldi	r18, 0x64	; 100
    4c12:	30 e0       	ldi	r19, 0x00	; 0

		LCD_Rst_Flg++;
    4c14:	80 91 ce 04 	lds	r24, 0x04CE
    4c18:	8f 5f       	subi	r24, 0xFF	; 255
    4c1a:	80 93 ce 04 	sts	0x04CE, r24
    4c1e:	5f c0       	rjmp	.+190    	; 0x4cde <__vector_18+0x12e>
	else {
		static uint8_t X, Y;
		static prog_uint8_t LineAddr[] = {128, 192, 148, 212};
		unsigned char cursor_symb;
		
		if (X<LCDXSz) {
    4c20:	10 91 e0 02 	lds	r17, 0x02E0
    4c24:	14 31       	cpi	r17, 0x14	; 20
    4c26:	08 f0       	brcs	.+2      	; 0x4c2a <__vector_18+0x7a>
    4c28:	45 c0       	rjmp	.+138    	; 0x4cb4 <__vector_18+0x104>
			if((X>=CurrX)&&(X<(CurrX+StrSize))&&(Y==CurrLCD)){
    4c2a:	80 91 b1 06 	lds	r24, 0x06B1
    4c2e:	18 17       	cp	r17, r24
    4c30:	08 f4       	brcc	.+2      	; 0x4c34 <__vector_18+0x84>
    4c32:	96 c0       	rjmp	.+300    	; 0x4d60 <__vector_18+0x1b0>
    4c34:	61 2f       	mov	r22, r17
    4c36:	70 e0       	ldi	r23, 0x00	; 0
    4c38:	20 91 a4 06 	lds	r18, 0x06A4
    4c3c:	90 e0       	ldi	r25, 0x00	; 0
    4c3e:	82 0f       	add	r24, r18
    4c40:	91 1d       	adc	r25, r1
    4c42:	68 17       	cp	r22, r24
    4c44:	79 07       	cpc	r23, r25
    4c46:	0c f4       	brge	.+2      	; 0x4c4a <__vector_18+0x9a>
    4c48:	e4 c0       	rjmp	.+456    	; 0x4e12 <__vector_18+0x262>
    4c4a:	e0 91 df 02 	lds	r30, 0x02DF
    4c4e:	20 e0       	ldi	r18, 0x00	; 0
			else
			{
				cursor_symb=0;
			}

			Send(
    4c50:	4e 2f       	mov	r20, r30
    4c52:	50 e0       	ldi	r21, 0x00	; 0
    4c54:	90 91 ca 08 	lds	r25, 0x08CA
    4c58:	89 2f       	mov	r24, r25
    4c5a:	88 50       	subi	r24, 0x08	; 8
    4c5c:	83 30       	cpi	r24, 0x03	; 3
    4c5e:	18 f0       	brcs	.+6      	; 0x4c66 <__vector_18+0xb6>
    4c60:	9e 30       	cpi	r25, 0x0E	; 14
    4c62:	08 f4       	brcc	.+2      	; 0x4c66 <__vector_18+0xb6>
    4c64:	91 c0       	rjmp	.+290    	; 0x4d88 <__vector_18+0x1d8>
    4c66:	22 23       	and	r18, r18
    4c68:	09 f4       	brne	.+2      	; 0x4c6c <__vector_18+0xbc>
    4c6a:	8e c0       	rjmp	.+284    	; 0x4d88 <__vector_18+0x1d8>
    4c6c:	80 91 d3 02 	lds	r24, 0x02D3
    4c70:	8f 3f       	cpi	r24, 0xFF	; 255
    4c72:	09 f4       	brne	.+2      	; 0x4c76 <__vector_18+0xc6>
    4c74:	89 c0       	rjmp	.+274    	; 0x4d88 <__vector_18+0x1d8>
    4c76:	e2 2f       	mov	r30, r18
    4c78:	f0 e0       	ldi	r31, 0x00	; 0
    4c7a:	e8 58       	subi	r30, 0x88	; 136
    4c7c:	f3 4d       	sbci	r31, 0xD3	; 211
    4c7e:	24 91       	lpm	r18, Z+
    4c80:	fa 01       	movw	r30, r20
    4c82:	ee 0f       	add	r30, r30
    4c84:	ff 1f       	adc	r31, r31
    4c86:	ee 0f       	add	r30, r30
    4c88:	ff 1f       	adc	r31, r31
    4c8a:	cf 01       	movw	r24, r30
    4c8c:	88 0f       	add	r24, r24
    4c8e:	99 1f       	adc	r25, r25
    4c90:	88 0f       	add	r24, r24
    4c92:	99 1f       	adc	r25, r25
    4c94:	e8 0f       	add	r30, r24
    4c96:	f9 1f       	adc	r31, r25
    4c98:	e6 0f       	add	r30, r22
    4c9a:	f7 1f       	adc	r31, r23
    4c9c:	eb 5b       	subi	r30, 0xBB	; 187
    4c9e:	f7 4f       	sbci	r31, 0xF7	; 247
    4ca0:	20 83       	st	Z, r18
    4ca2:	82 2f       	mov	r24, r18
    4ca4:	0e 94 39 25 	call	0x4a72	; 0x4a72 <Send>
				#ifndef QslRD
					*((uint8_t*)RMON+Y*LCDXSz+X) =
				#endif
			#endif
				(((Blink>=8 && Blink<=10 )|| Blink>=14)&&cursor_symb&&(CurrField!=255))?prb(Win2LCD+(unsigned char)cursor_symb):(prb(Win2LCD+(unsigned char)LCD_Buf[Y][X])));
				X++;
    4ca8:	1f 5f       	subi	r17, 0xFF	; 255
    4caa:	10 93 e0 02 	sts	0x02E0, r17
    4cae:	24 e6       	ldi	r18, 0x64	; 100
    4cb0:	30 e0       	ldi	r19, 0x00	; 0
    4cb2:	15 c0       	rjmp	.+42     	; 0x4cde <__vector_18+0x12e>
		}
		else {
			X = 0;
    4cb4:	10 92 e0 02 	sts	0x02E0, r1
			if (++Y==LCDYSz) {
    4cb8:	e0 91 df 02 	lds	r30, 0x02DF
    4cbc:	ef 5f       	subi	r30, 0xFF	; 255
    4cbe:	e0 93 df 02 	sts	0x02DF, r30
    4cc2:	e4 30       	cpi	r30, 0x04	; 4
    4cc4:	09 f4       	brne	.+2      	; 0x4cc8 <__vector_18+0x118>
    4cc6:	51 c0       	rjmp	.+162    	; 0x4d6a <__vector_18+0x1ba>
				Y = 0;
				TIMSK_LCD &= ~(1<<OCIE1B);	//stop Output CompareB interrups
			}
			Port_LCD_RS &=~LCD_RS;
    4cc8:	44 98       	cbi	0x08, 4	; 8
    4cca:	f0 e0       	ldi	r31, 0x00	; 0
    4ccc:	e8 58       	subi	r30, 0x88	; 136
    4cce:	f2 4d       	sbci	r31, 0xD2	; 210
    4cd0:	e4 91       	lpm	r30, Z+
			Send(prb(LineAddr+Y));
    4cd2:	8e 2f       	mov	r24, r30
    4cd4:	0e 94 39 25 	call	0x4a72	; 0x4a72 <Send>
			Port_LCD_RS |=LCD_RS;
    4cd8:	44 9a       	sbi	0x08, 4	; 8
    4cda:	24 e6       	ldi	r18, 0x64	; 100
    4cdc:	30 e0       	ldi	r19, 0x00	; 0
		}
	}
	LCD_delay = TCNT1 + LCD_delay;
    4cde:	80 91 84 00 	lds	r24, 0x0084
    4ce2:	90 91 85 00 	lds	r25, 0x0085
    4ce6:	82 0f       	add	r24, r18
    4ce8:	93 1f       	adc	r25, r19
	if(LCD_delay >= 20000) OCR1B = LCD_delay - 20000;
    4cea:	2e e4       	ldi	r18, 0x4E	; 78
    4cec:	80 32       	cpi	r24, 0x20	; 32
    4cee:	92 07       	cpc	r25, r18
    4cf0:	d8 f4       	brcc	.+54     	; 0x4d28 <__vector_18+0x178>
	else OCR1B = LCD_delay;
    4cf2:	90 93 8b 00 	sts	0x008B, r25
    4cf6:	80 93 8a 00 	sts	0x008A, r24
	TIFR_LCD |= (1<<OCF1B);
    4cfa:	b2 9a       	sbi	0x16, 2	; 22
}
    4cfc:	ff 91       	pop	r31
    4cfe:	ef 91       	pop	r30
    4d00:	bf 91       	pop	r27
    4d02:	af 91       	pop	r26
    4d04:	9f 91       	pop	r25
    4d06:	8f 91       	pop	r24
    4d08:	7f 91       	pop	r23
    4d0a:	6f 91       	pop	r22
    4d0c:	5f 91       	pop	r21
    4d0e:	4f 91       	pop	r20
    4d10:	3f 91       	pop	r19
    4d12:	2f 91       	pop	r18
    4d14:	1f 91       	pop	r17
    4d16:	0f 91       	pop	r16
    4d18:	ff 90       	pop	r15
    4d1a:	0f 90       	pop	r0
    4d1c:	0b be       	out	0x3b, r0	; 59
    4d1e:	0f 90       	pop	r0
    4d20:	0f be       	out	0x3f, r0	; 63
    4d22:	0f 90       	pop	r0
    4d24:	1f 90       	pop	r1
    4d26:	18 95       	reti
			Send(prb(LineAddr+Y));
			Port_LCD_RS |=LCD_RS;
		}
	}
	LCD_delay = TCNT1 + LCD_delay;
	if(LCD_delay >= 20000) OCR1B = LCD_delay - 20000;
    4d28:	80 52       	subi	r24, 0x20	; 32
    4d2a:	9e 44       	sbci	r25, 0x4E	; 78
    4d2c:	90 93 8b 00 	sts	0x008B, r25
    4d30:	80 93 8a 00 	sts	0x008A, r24
    4d34:	e2 cf       	rjmp	.-60     	; 0x4cfa <__vector_18+0x14a>
ISR(TIMER1_COMPB_vect){

	uint16_t LCD_delay = 100;	//50us

	if (LCD_Rst_Flg) {
		switch(LCD_Rst_Flg){
    4d36:	12 30       	cpi	r17, 0x02	; 2
    4d38:	21 f1       	breq	.+72     	; 0x4d82 <__vector_18+0x1d2>
    4d3a:	13 30       	cpi	r17, 0x03	; 3
    4d3c:	f8 f4       	brcc	.+62     	; 0x4d7c <__vector_18+0x1cc>
    4d3e:	11 30       	cpi	r17, 0x01	; 1
    4d40:	01 f1       	breq	.+64     	; 0x4d82 <__vector_18+0x1d2>
				#else
					Send(0b00000010);	//RETURN HOME					
				#endif
				Port_LCD_RS |=LCD_RS;
			default:
				LCD_Rst_Flg = 255;
    4d42:	8f ef       	ldi	r24, 0xFF	; 255
    4d44:	80 93 ce 04 	sts	0x04CE, r24
		}
		if(LCD_Rst_Flg==1) LCD_delay = 400;	//200us
    4d48:	80 91 ce 04 	lds	r24, 0x04CE
    4d4c:	81 30       	cpi	r24, 0x01	; 1
    4d4e:	09 f0       	breq	.+2      	; 0x4d52 <__vector_18+0x1a2>
    4d50:	5f cf       	rjmp	.-322    	; 0x4c10 <__vector_18+0x60>
    4d52:	20 e9       	ldi	r18, 0x90	; 144
    4d54:	31 e0       	ldi	r19, 0x01	; 1
    4d56:	5e cf       	rjmp	.-324    	; 0x4c14 <__vector_18+0x64>
				#else
					Send(0b00101000);	//; 4-bits DL, 2 lines, 5x7 dots
				#endif
				break;
			case 5:
				Send(0b00001100);	//; Display on, cursor off, blink off	
    4d58:	8c e0       	ldi	r24, 0x0C	; 12
    4d5a:	0e 94 39 25 	call	0x4a72	; 0x4a72 <Send>
    4d5e:	53 cf       	rjmp	.-346    	; 0x4c06 <__vector_18+0x56>
    4d60:	61 2f       	mov	r22, r17
    4d62:	70 e0       	ldi	r23, 0x00	; 0
    4d64:	e0 91 df 02 	lds	r30, 0x02DF
    4d68:	72 cf       	rjmp	.-284    	; 0x4c4e <__vector_18+0x9e>
				X++;
		}
		else {
			X = 0;
			if (++Y==LCDYSz) {
				Y = 0;
    4d6a:	10 92 df 02 	sts	0x02DF, r1
				TIMSK_LCD &= ~(1<<OCIE1B);	//stop Output CompareB interrups
    4d6e:	80 91 6f 00 	lds	r24, 0x006F
    4d72:	8b 7f       	andi	r24, 0xFB	; 251
    4d74:	80 93 6f 00 	sts	0x006F, r24
    4d78:	e0 e0       	ldi	r30, 0x00	; 0
    4d7a:	a6 cf       	rjmp	.-180    	; 0x4cc8 <__vector_18+0x118>
ISR(TIMER1_COMPB_vect){

	uint16_t LCD_delay = 100;	//50us

	if (LCD_Rst_Flg) {
		switch(LCD_Rst_Flg){
    4d7c:	13 30       	cpi	r17, 0x03	; 3
    4d7e:	09 f0       	breq	.+2      	; 0x4d82 <__vector_18+0x1d2>
    4d80:	56 c0       	rjmp	.+172    	; 0x4e2e <__vector_18+0x27e>
			case 2:
				LCD_FuncSet0();
				break;
			case 3:
				#ifdef Port_LCD_DB0	
					LCD_FuncSet0();
    4d82:	0e 94 81 25 	call	0x4b02	; 0x4b02 <LCD_FuncSet0>
    4d86:	3f cf       	rjmp	.-386    	; 0x4c06 <__vector_18+0x56>
			else
			{
				cursor_symb=0;
			}

			Send(
    4d88:	ca 01       	movw	r24, r20
    4d8a:	88 0f       	add	r24, r24
    4d8c:	99 1f       	adc	r25, r25
    4d8e:	84 0f       	add	r24, r20
    4d90:	95 1f       	adc	r25, r21
    4d92:	fc 01       	movw	r30, r24
    4d94:	ee 0f       	add	r30, r30
    4d96:	ff 1f       	adc	r31, r31
    4d98:	ee 0f       	add	r30, r30
    4d9a:	ff 1f       	adc	r31, r31
    4d9c:	ee 0f       	add	r30, r30
    4d9e:	ff 1f       	adc	r31, r31
    4da0:	e8 1b       	sub	r30, r24
    4da2:	f9 0b       	sbc	r31, r25
    4da4:	e6 0f       	add	r30, r22
    4da6:	f7 1f       	adc	r31, r23
    4da8:	e0 5b       	subi	r30, 0xB0	; 176
    4daa:	f9 4f       	sbci	r31, 0xF9	; 249
    4dac:	e0 81       	ld	r30, Z
    4dae:	f0 e0       	ldi	r31, 0x00	; 0
    4db0:	e8 58       	subi	r30, 0x88	; 136
    4db2:	f3 4d       	sbci	r31, 0xD3	; 211
    4db4:	24 91       	lpm	r18, Z+
    4db6:	64 cf       	rjmp	.-312    	; 0x4c80 <__vector_18+0xd0>
ISR(TIMER1_COMPB_vect){

	uint16_t LCD_delay = 100;	//50us

	if (LCD_Rst_Flg) {
		switch(LCD_Rst_Flg){
    4db8:	18 30       	cpi	r17, 0x08	; 8
    4dba:	49 f0       	breq	.+18     	; 0x4dce <__vector_18+0x21e>
    4dbc:	19 30       	cpi	r17, 0x09	; 9
    4dbe:	09 f0       	breq	.+2      	; 0x4dc2 <__vector_18+0x212>
    4dc0:	c0 cf       	rjmp	.-128    	; 0x4d42 <__vector_18+0x192>
						else{i=0;LCD_Rst_Flg = 8;}
					}
				}
				break;
			case 9:
				Port_LCD_RS &=~LCD_RS;
    4dc2:	44 98       	cbi	0x08, 4	; 8
				#ifdef NOT_USE_LCD_RETURN_HOME_CMD
					Send(128);			//     
				#else
					Send(0b00000010);	//RETURN HOME					
    4dc4:	82 e0       	ldi	r24, 0x02	; 2
    4dc6:	0e 94 39 25 	call	0x4a72	; 0x4a72 <Send>
				#endif
				Port_LCD_RS |=LCD_RS;
    4dca:	44 9a       	sbi	0x08, 4	; 8
    4dcc:	ba cf       	rjmp	.-140    	; 0x4d42 <__vector_18+0x192>
				Send(0b01000000);	//;    CG RAM   0.
				Port_LCD_RS |=LCD_RS;
				break;
			case 8:{
					static uint8_t i,j;
					LCD_Rst_Flg = 7;
    4dce:	87 e0       	ldi	r24, 0x07	; 7
    4dd0:	80 93 ce 04 	sts	0x04CE, r24
					Send(prb(CGRAM_LCD[i]+j));
    4dd4:	f0 90 e2 02 	lds	r15, 0x02E2
    4dd8:	00 91 e1 02 	lds	r16, 0x02E1
    4ddc:	ef 2d       	mov	r30, r15
    4dde:	f0 e0       	ldi	r31, 0x00	; 0
    4de0:	ee 0f       	add	r30, r30
    4de2:	ff 1f       	adc	r31, r31
    4de4:	ee 0f       	add	r30, r30
    4de6:	ff 1f       	adc	r31, r31
    4de8:	ee 0f       	add	r30, r30
    4dea:	ff 1f       	adc	r31, r31
    4dec:	e0 0f       	add	r30, r16
    4dee:	f1 1d       	adc	r31, r1
    4df0:	e8 5c       	subi	r30, 0xC8	; 200
    4df2:	f3 4d       	sbci	r31, 0xD3	; 211
    4df4:	e4 91       	lpm	r30, Z+
    4df6:	8e 2f       	mov	r24, r30
    4df8:	0e 94 39 25 	call	0x4a72	; 0x4a72 <Send>
					if(j<7) j++;
    4dfc:	07 30       	cpi	r16, 0x07	; 7
    4dfe:	f0 f0       	brcs	.+60     	; 0x4e3c <__vector_18+0x28c>
					else{
						j=0;
    4e00:	10 92 e1 02 	sts	0x02E1, r1
						if(i<7)i++;
    4e04:	26 e0       	ldi	r18, 0x06	; 6
    4e06:	2f 15       	cp	r18, r15
    4e08:	e8 f0       	brcs	.+58     	; 0x4e44 <__vector_18+0x294>
    4e0a:	f3 94       	inc	r15
    4e0c:	f0 92 e2 02 	sts	0x02E2, r15
    4e10:	fa ce       	rjmp	.-524    	; 0x4c06 <__vector_18+0x56>
		static uint8_t X, Y;
		static prog_uint8_t LineAddr[] = {128, 192, 148, 212};
		unsigned char cursor_symb;
		
		if (X<LCDXSz) {
			if((X>=CurrX)&&(X<(CurrX+StrSize))&&(Y==CurrLCD)){
    4e12:	e0 91 df 02 	lds	r30, 0x02DF
    4e16:	80 91 9a 08 	lds	r24, 0x089A
    4e1a:	e8 17       	cp	r30, r24
    4e1c:	09 f0       	breq	.+2      	; 0x4e20 <__vector_18+0x270>
    4e1e:	17 cf       	rjmp	.-466    	; 0x4c4e <__vector_18+0x9e>
    4e20:	2f e5       	ldi	r18, 0x5F	; 95
    4e22:	16 cf       	rjmp	.-468    	; 0x4c50 <__vector_18+0xa0>
				break;
			case 6:
				Send(0b00000110);	//; cursor shift right, no display shift
				break;
			case 7:
				Send(0b01000000);	//;    CG RAM   0.
    4e24:	80 e4       	ldi	r24, 0x40	; 64
    4e26:	0e 94 39 25 	call	0x4a72	; 0x4a72 <Send>
				Port_LCD_RS |=LCD_RS;
    4e2a:	44 9a       	sbi	0x08, 4	; 8
    4e2c:	ec ce       	rjmp	.-552    	; 0x4c06 <__vector_18+0x56>
ISR(TIMER1_COMPB_vect){

	uint16_t LCD_delay = 100;	//50us

	if (LCD_Rst_Flg) {
		switch(LCD_Rst_Flg){
    4e2e:	14 30       	cpi	r17, 0x04	; 4
    4e30:	09 f0       	breq	.+2      	; 0x4e34 <__vector_18+0x284>
    4e32:	87 cf       	rjmp	.-242    	; 0x4d42 <__vector_18+0x192>
					LCD_FuncSet1();
				#endif
				break;
			case 4:
				#ifdef Port_LCD_DB0	
					Send(0b00111000);	//; 8-bits DL, 2 lines, 5x7 dots
    4e34:	88 e3       	ldi	r24, 0x38	; 56
    4e36:	0e 94 39 25 	call	0x4a72	; 0x4a72 <Send>
    4e3a:	e5 ce       	rjmp	.-566    	; 0x4c06 <__vector_18+0x56>
				break;
			case 8:{
					static uint8_t i,j;
					LCD_Rst_Flg = 7;
					Send(prb(CGRAM_LCD[i]+j));
					if(j<7) j++;
    4e3c:	0f 5f       	subi	r16, 0xFF	; 255
    4e3e:	00 93 e1 02 	sts	0x02E1, r16
    4e42:	e1 ce       	rjmp	.-574    	; 0x4c06 <__vector_18+0x56>
					else{
						j=0;
						if(i<7)i++;
						else{i=0;LCD_Rst_Flg = 8;}
    4e44:	10 92 e2 02 	sts	0x02E2, r1
    4e48:	10 93 ce 04 	sts	0x04CE, r17
    4e4c:	dc ce       	rjmp	.-584    	; 0x4c06 <__vector_18+0x56>

00004e4e <LCDBackLightOn>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    4e4e:	9f b7       	in	r25, 0x3f	; 63
    4e50:	90 78       	andi	r25, 0x80	; 128
    4e52:	90 93 e6 02 	sts	0x02E6, r25
	cli();
    4e56:	f8 94       	cli
	void LCDBackLightOn(void){
		IntOff();	
		#ifdef BACKLIGHT_INVERSION
			PORT_BACKLIGHT &= ~BACKLIGHT;
		#else
			PORT_BACKLIGHT |= BACKLIGHT;
    4e58:	80 91 0b 01 	lds	r24, 0x010B
    4e5c:	80 64       	ori	r24, 0x40	; 64
    4e5e:	80 93 0b 01 	sts	0x010B, r24

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    4e62:	99 23       	and	r25, r25
    4e64:	09 f0       	breq	.+2      	; 0x4e68 <LCDBackLightOn+0x1a>
		sei();
    4e66:	78 94       	sei
    4e68:	08 95       	ret

00004e6a <LCDBackLightOff>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    4e6a:	9f b7       	in	r25, 0x3f	; 63
    4e6c:	90 78       	andi	r25, 0x80	; 128
    4e6e:	90 93 e6 02 	sts	0x02E6, r25
	cli();
    4e72:	f8 94       	cli
	void LCDBackLightOff(void){
		IntOff();	
		#ifdef BACKLIGHT_INVERSION
			PORT_BACKLIGHT |= BACKLIGHT;
		#else
			PORT_BACKLIGHT &= ~BACKLIGHT;
    4e74:	80 91 0b 01 	lds	r24, 0x010B
    4e78:	8f 7b       	andi	r24, 0xBF	; 191
    4e7a:	80 93 0b 01 	sts	0x010B, r24

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    4e7e:	99 23       	and	r25, r25
    4e80:	09 f0       	breq	.+2      	; 0x4e84 <LCDBackLightOff+0x1a>
		sei();
    4e82:	78 94       	sei
    4e84:	08 95       	ret

00004e86 <LCDBackLightControl>:
				StartTimer16(TD_BackLight, 3000);
				break;			
		}
	}
	void LCDBackLightControl(void){
		switch(BackLightMode){
    4e86:	80 91 4a 06 	lds	r24, 0x064A
    4e8a:	81 30       	cpi	r24, 0x01	; 1
    4e8c:	29 f0       	breq	.+10     	; 0x4e98 <LCDBackLightControl+0x12>
    4e8e:	82 30       	cpi	r24, 0x02	; 2
    4e90:	61 f0       	breq	.+24     	; 0x4eaa <LCDBackLightControl+0x24>
		case 1: if(Timer16Stopp(TD_BackLight)) LCDBackLightOff();
			break;
		case 2:
			break;
		default: LCDBackLightOn();
    4e92:	0e 94 27 27 	call	0x4e4e	; 0x4e4e <LCDBackLightOn>
    4e96:	08 95       	ret
				break;			
		}
	}
	void LCDBackLightControl(void){
		switch(BackLightMode){
		case 1: if(Timer16Stopp(TD_BackLight)) LCDBackLightOff();
    4e98:	80 91 d0 04 	lds	r24, 0x04D0
    4e9c:	0e 94 59 1b 	call	0x36b2	; 0x36b2 <Timer16Stopp>
    4ea0:	88 23       	and	r24, r24
    4ea2:	c9 f3       	breq	.-14     	; 0x4e96 <LCDBackLightControl+0x10>
    4ea4:	0e 94 35 27 	call	0x4e6a	; 0x4e6a <LCDBackLightOff>
    4ea8:	08 95       	ret
    4eaa:	08 95       	ret

00004eac <StartTimer0>:
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
		TCCR0  = ((((1<<WGM01) &~(1<<WGM00)  &~(1<<COM01)  &~(1<<COM00)) |(1<<CS02)) &~(1<<CS01)) |(1<<CS00);
	#elif defined (__AVR_ATmega128__)
		TCCR0  =   ((1<<WGM01) &~(1<<WGM00)  &~(1<<COM01)  &~(1<<COM00)) |(1<<CS02)   |(1<<CS01)  |(1<<CS00);
	#elif defined (__AVR_ATmega1280__)  || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TCCR0A =    (1<<WGM01) &~(1<<WGM00)  &~(1<<COM0A1) &~(1<<COM0A0) &~(1<<COM0B1) &~(1<<COM0B0);
    4eac:	82 e0       	ldi	r24, 0x02	; 2
    4eae:	84 bd       	out	0x24, r24	; 36
		TCCR0B = ((~(1<<WGM02)                                           |(1<<CS02)) &~(1<<CS01)) |(1<<CS00);
    4eb0:	85 ef       	ldi	r24, 0xF5	; 245
    4eb2:	85 bd       	out	0x25, r24	; 37
	#endif
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__)
		TIMSK |=(1<<OCIE0);
	#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TIMSK0 |=(1<<OCIE0A);
    4eb4:	ee e6       	ldi	r30, 0x6E	; 110
    4eb6:	f0 e0       	ldi	r31, 0x00	; 0
    4eb8:	80 81       	ld	r24, Z
    4eba:	82 60       	ori	r24, 0x02	; 2
    4ebc:	80 83       	st	Z, r24
	#endif
}
    4ebe:	08 95       	ret

00004ec0 <StartTimer2>:
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
		TCCR2  =   ((1<<WGM21) &~(1<<WGM20)  &~(1<<COM21)  &~(1<<COM20)) |(1<<CS22)   |(1<<CS21)  |(1<<CS20);
	#elif defined (__AVR_ATmega128__)
		TCCR2  = ((((1<<WGM21) &~(1<<WGM20)  &~(1<<COM21)  &~(1<<COM20)) |(1<<CS22)) &~(1<<CS21)) |(1<<CS20);
	#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TCCR2A =    (1<<WGM21) &~(1<<WGM20)  &~(1<<COM2A1) &~(1<<COM2A0) &~(1<<COM2B1) &~(1<<COM2B0);
    4ec0:	82 e0       	ldi	r24, 0x02	; 2
    4ec2:	80 93 b0 00 	sts	0x00B0, r24
		TCCR2B =   ~(1<<WGM22)                                           |(1<<CS22)   |(1<<CS21)  |(1<<CS20);
    4ec6:	87 ef       	ldi	r24, 0xF7	; 247
    4ec8:	80 93 b1 00 	sts	0x00B1, r24
	#endif
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__)
		TIMSK |=(1<<OCIE2);
	#elif  defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TIMSK2 |=(1<<OCIE2A);
    4ecc:	e0 e7       	ldi	r30, 0x70	; 112
    4ece:	f0 e0       	ldi	r31, 0x00	; 0
    4ed0:	80 81       	ld	r24, Z
    4ed2:	82 60       	ori	r24, 0x02	; 2
    4ed4:	80 83       	st	Z, r24
	#endif
}
    4ed6:	08 95       	ret

00004ed8 <StartTimer4>:
#if defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
	//static void
	void
	StartTimer4(void)
	{
		TCCR4A = 0;
    4ed8:	10 92 a0 00 	sts	0x00A0, r1
		TCCR4B = (1<<WGM42) | (1<<CS42) | (0<<CS41) | (1<<CS40);	// clk/1024
    4edc:	8d e0       	ldi	r24, 0x0D	; 13
    4ede:	80 93 a1 00 	sts	0x00A1, r24
		TIMSK4 |=(1<<OCIE4A);
    4ee2:	e2 e7       	ldi	r30, 0x72	; 114
    4ee4:	f0 e0       	ldi	r31, 0x00	; 0
    4ee6:	80 81       	ld	r24, Z
    4ee8:	82 60       	ori	r24, 0x02	; 2
    4eea:	80 83       	st	Z, r24
	}
    4eec:	08 95       	ret

00004eee <MB_Timer_ISR>:
// ~~~

// ~~~~~~~~~~~~~~~~~~~
static void
MB_Timer_ISR(tc_t *tc)
{
    4eee:	bc 01       	movw	r22, r24

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    4ef0:	e6 e2       	ldi	r30, 0x26	; 38
    4ef2:	fc e2       	ldi	r31, 0x2C	; 44
    4ef4:	85 91       	lpm	r24, Z+
    4ef6:	94 91       	lpm	r25, Z+
	#if defined (__AVR_ATxmega128A1__)
		tc->INTCTRLA = (tc->INTCTRLA &~TC1_OVFINTLVL_gm) |TC_OVFINTLVL_OFF_gc;
		tc->CTRLA = TC_CLKSEL_OFF_gc;
	#endif
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Timer[MB_N]tc_f)!=tc; MB_N++);
    4ef8:	68 17       	cp	r22, r24
    4efa:	79 07       	cpc	r23, r25
    4efc:	09 f4       	brne	.+2      	; 0x4f00 <MB_Timer_ISR+0x12>
    4efe:	54 c0       	rjmp	.+168    	; 0x4fa8 <MB_Timer_ISR+0xba>
    4f00:	20 e0       	ldi	r18, 0x00	; 0
    4f02:	2f 5f       	subi	r18, 0xFF	; 255
    4f04:	42 2f       	mov	r20, r18
    4f06:	50 e0       	ldi	r21, 0x00	; 0
    4f08:	fa 01       	movw	r30, r20
    4f0a:	ee 0f       	add	r30, r30
    4f0c:	ff 1f       	adc	r31, r31
    4f0e:	e4 0f       	add	r30, r20
    4f10:	f5 1f       	adc	r31, r21
    4f12:	ee 0f       	add	r30, r30
    4f14:	ff 1f       	adc	r31, r31
    4f16:	ea 5d       	subi	r30, 0xDA	; 218
    4f18:	f3 4d       	sbci	r31, 0xD3	; 211
    4f1a:	85 91       	lpm	r24, Z+
    4f1c:	94 91       	lpm	r25, Z+
    4f1e:	68 17       	cp	r22, r24
    4f20:	79 07       	cpc	r23, r25
    4f22:	79 f7       	brne	.-34     	; 0x4f02 <MB_Timer_ISR+0x14>
    4f24:	fa 01       	movw	r30, r20

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    4f26:	eb 5d       	subi	r30, 0xDB	; 219
    4f28:	f3 4d       	sbci	r31, 0xD3	; 211
    4f2a:	84 91       	lpm	r24, Z+

	
	switch (prb(MB_Role+MB_N)){
    4f2c:	88 23       	and	r24, r24
    4f2e:	f9 f4       	brne	.+62     	; 0x4f6e <MB_Timer_ISR+0x80>
	case Role_Slave:
		if(MB_Frame[MB_N][0]==MB_NativeAddr[MB_N]){	// Slave     -   MB_TimerFlag
    4f30:	f4 2f       	mov	r31, r20
    4f32:	ee 27       	eor	r30, r30
    4f34:	e3 5e       	subi	r30, 0xE3	; 227
    4f36:	f4 4f       	sbci	r31, 0xF4	; 244
    4f38:	da 01       	movw	r26, r20
    4f3a:	a8 52       	subi	r26, 0x28	; 40
    4f3c:	ba 4f       	sbci	r27, 0xFA	; 250
    4f3e:	90 81       	ld	r25, Z
    4f40:	8c 91       	ld	r24, X
    4f42:	98 17       	cp	r25, r24
    4f44:	21 f1       	breq	.+72     	; 0x4f8e <MB_Timer_ISR+0xa0>
			MB_TimerFlag |= (1<<MB_N);
		}
		else{
			MB_State[MB_N] = MB_Idle;
    4f46:	fa 01       	movw	r30, r20
    4f48:	e6 54       	subi	r30, 0x46	; 70
    4f4a:	fa 4f       	sbci	r31, 0xFA	; 250
    4f4c:	81 e0       	ldi	r24, 0x01	; 1
    4f4e:	80 83       	st	Z, r24
			MB_CPT[MB_N][0]++;
    4f50:	fa 01       	movw	r30, r20
    4f52:	e2 95       	swap	r30
    4f54:	f2 95       	swap	r31
    4f56:	f0 7f       	andi	r31, 0xF0	; 240
    4f58:	fe 27       	eor	r31, r30
    4f5a:	e0 7f       	andi	r30, 0xF0	; 240
    4f5c:	fe 27       	eor	r31, r30
    4f5e:	e8 51       	subi	r30, 0x18	; 24
    4f60:	f7 4f       	sbci	r31, 0xF7	; 247
    4f62:	80 81       	ld	r24, Z
    4f64:	91 81       	ldd	r25, Z+1	; 0x01
    4f66:	01 96       	adiw	r24, 0x01	; 1
    4f68:	91 83       	std	Z+1, r25	; 0x01
    4f6a:	80 83       	st	Z, r24
    4f6c:	08 95       	ret
	#endif
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Timer[MB_N]tc_f)!=tc; MB_N++);

	
	switch (prb(MB_Role+MB_N)){
    4f6e:	81 30       	cpi	r24, 0x01	; 1
    4f70:	09 f0       	breq	.+2      	; 0x4f74 <MB_Timer_ISR+0x86>
    4f72:	08 95       	ret
			MB_State[MB_N] = MB_Idle;
			MB_CPT[MB_N][0]++;
		}
		break;
	case Role_Master:
		MB_TimerFlag |= (1<<MB_N);
    4f74:	20 91 dc 08 	lds	r18, 0x08DC
    4f78:	81 e0       	ldi	r24, 0x01	; 1
    4f7a:	90 e0       	ldi	r25, 0x00	; 0
    4f7c:	02 c0       	rjmp	.+4      	; 0x4f82 <MB_Timer_ISR+0x94>
    4f7e:	88 0f       	add	r24, r24
    4f80:	99 1f       	adc	r25, r25
    4f82:	4a 95       	dec	r20
    4f84:	e2 f7       	brpl	.-8      	; 0x4f7e <MB_Timer_ISR+0x90>
    4f86:	28 2b       	or	r18, r24
    4f88:	20 93 dc 08 	sts	0x08DC, r18
    4f8c:	08 95       	ret

	
	switch (prb(MB_Role+MB_N)){
	case Role_Slave:
		if(MB_Frame[MB_N][0]==MB_NativeAddr[MB_N]){	// Slave     -   MB_TimerFlag
			MB_TimerFlag |= (1<<MB_N);
    4f8e:	20 91 dc 08 	lds	r18, 0x08DC
    4f92:	81 e0       	ldi	r24, 0x01	; 1
    4f94:	90 e0       	ldi	r25, 0x00	; 0
    4f96:	02 c0       	rjmp	.+4      	; 0x4f9c <MB_Timer_ISR+0xae>
    4f98:	88 0f       	add	r24, r24
    4f9a:	99 1f       	adc	r25, r25
    4f9c:	4a 95       	dec	r20
    4f9e:	e2 f7       	brpl	.-8      	; 0x4f98 <MB_Timer_ISR+0xaa>
    4fa0:	28 2b       	or	r18, r24
    4fa2:	20 93 dc 08 	sts	0x08DC, r18
    4fa6:	08 95       	ret
	#if defined (__AVR_ATxmega128A1__)
		tc->INTCTRLA = (tc->INTCTRLA &~TC1_OVFINTLVL_gm) |TC_OVFINTLVL_OFF_gc;
		tc->CTRLA = TC_CLKSEL_OFF_gc;
	#endif
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Timer[MB_N]tc_f)!=tc; MB_N++);
    4fa8:	40 e0       	ldi	r20, 0x00	; 0
    4faa:	50 e0       	ldi	r21, 0x00	; 0
    4fac:	e0 e0       	ldi	r30, 0x00	; 0
    4fae:	f0 e0       	ldi	r31, 0x00	; 0
    4fb0:	ba cf       	rjmp	.-140    	; 0x4f26 <MB_Timer_ISR+0x38>

00004fb2 <__vector_21>:
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#elif  defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) ||defined (__AVR_ATmega2561__)
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ISR(TIMER0_COMPA_vect)
{
    4fb2:	1f 92       	push	r1
    4fb4:	0f 92       	push	r0
    4fb6:	0f b6       	in	r0, 0x3f	; 63
    4fb8:	0f 92       	push	r0
    4fba:	0b b6       	in	r0, 0x3b	; 59
    4fbc:	0f 92       	push	r0
    4fbe:	11 24       	eor	r1, r1
    4fc0:	2f 93       	push	r18
    4fc2:	3f 93       	push	r19
    4fc4:	4f 93       	push	r20
    4fc6:	5f 93       	push	r21
    4fc8:	6f 93       	push	r22
    4fca:	7f 93       	push	r23
    4fcc:	8f 93       	push	r24
    4fce:	9f 93       	push	r25
    4fd0:	af 93       	push	r26
    4fd2:	bf 93       	push	r27
    4fd4:	ef 93       	push	r30
    4fd6:	ff 93       	push	r31
	TCCR0B &=~(1<<CS02) &~(1<<CS01) &~(1<<CS00);
    4fd8:	85 b5       	in	r24, 0x25	; 37
    4fda:	88 7f       	andi	r24, 0xF8	; 248
    4fdc:	85 bd       	out	0x25, r24	; 37
	TIMSK0 &=~(1<<OCIE0A);
    4fde:	ee e6       	ldi	r30, 0x6E	; 110
    4fe0:	f0 e0       	ldi	r31, 0x00	; 0
    4fe2:	80 81       	ld	r24, Z
    4fe4:	8d 7f       	andi	r24, 0xFD	; 253
    4fe6:	80 83       	st	Z, r24
	MB_Timer_ISR(&TCNT0);
    4fe8:	86 e4       	ldi	r24, 0x46	; 70
    4fea:	90 e0       	ldi	r25, 0x00	; 0
    4fec:	0e 94 77 27 	call	0x4eee	; 0x4eee <MB_Timer_ISR>
}
    4ff0:	ff 91       	pop	r31
    4ff2:	ef 91       	pop	r30
    4ff4:	bf 91       	pop	r27
    4ff6:	af 91       	pop	r26
    4ff8:	9f 91       	pop	r25
    4ffa:	8f 91       	pop	r24
    4ffc:	7f 91       	pop	r23
    4ffe:	6f 91       	pop	r22
    5000:	5f 91       	pop	r21
    5002:	4f 91       	pop	r20
    5004:	3f 91       	pop	r19
    5006:	2f 91       	pop	r18
    5008:	0f 90       	pop	r0
    500a:	0b be       	out	0x3b, r0	; 59
    500c:	0f 90       	pop	r0
    500e:	0f be       	out	0x3f, r0	; 63
    5010:	0f 90       	pop	r0
    5012:	1f 90       	pop	r1
    5014:	18 95       	reti

00005016 <__vector_13>:

// ~~~~~~~~~~~~~~~~~~~
ISR(TIMER2_COMPA_vect)
{
    5016:	1f 92       	push	r1
    5018:	0f 92       	push	r0
    501a:	0f b6       	in	r0, 0x3f	; 63
    501c:	0f 92       	push	r0
    501e:	0b b6       	in	r0, 0x3b	; 59
    5020:	0f 92       	push	r0
    5022:	11 24       	eor	r1, r1
    5024:	2f 93       	push	r18
    5026:	3f 93       	push	r19
    5028:	4f 93       	push	r20
    502a:	5f 93       	push	r21
    502c:	6f 93       	push	r22
    502e:	7f 93       	push	r23
    5030:	8f 93       	push	r24
    5032:	9f 93       	push	r25
    5034:	af 93       	push	r26
    5036:	bf 93       	push	r27
    5038:	ef 93       	push	r30
    503a:	ff 93       	push	r31
	TCCR2B &=~(1<<CS22) &~(1<<CS21) &~(1<<CS20);
    503c:	e1 eb       	ldi	r30, 0xB1	; 177
    503e:	f0 e0       	ldi	r31, 0x00	; 0
    5040:	80 81       	ld	r24, Z
    5042:	88 7f       	andi	r24, 0xF8	; 248
    5044:	80 83       	st	Z, r24
	TIMSK2 &=~(1<<OCIE2A);
    5046:	e0 e7       	ldi	r30, 0x70	; 112
    5048:	f0 e0       	ldi	r31, 0x00	; 0
    504a:	80 81       	ld	r24, Z
    504c:	8d 7f       	andi	r24, 0xFD	; 253
    504e:	80 83       	st	Z, r24
	MB_Timer_ISR(&TCNT2);
    5050:	82 eb       	ldi	r24, 0xB2	; 178
    5052:	90 e0       	ldi	r25, 0x00	; 0
    5054:	0e 94 77 27 	call	0x4eee	; 0x4eee <MB_Timer_ISR>
}
    5058:	ff 91       	pop	r31
    505a:	ef 91       	pop	r30
    505c:	bf 91       	pop	r27
    505e:	af 91       	pop	r26
    5060:	9f 91       	pop	r25
    5062:	8f 91       	pop	r24
    5064:	7f 91       	pop	r23
    5066:	6f 91       	pop	r22
    5068:	5f 91       	pop	r21
    506a:	4f 91       	pop	r20
    506c:	3f 91       	pop	r19
    506e:	2f 91       	pop	r18
    5070:	0f 90       	pop	r0
    5072:	0b be       	out	0x3b, r0	; 59
    5074:	0f 90       	pop	r0
    5076:	0f be       	out	0x3f, r0	; 63
    5078:	0f 90       	pop	r0
    507a:	1f 90       	pop	r1
    507c:	18 95       	reti

0000507e <__vector_42>:
// ~~~~~~~~~~~~~~~~~~~
ISR(TIMER4_COMPA_vect)
{
    507e:	1f 92       	push	r1
    5080:	0f 92       	push	r0
    5082:	0f b6       	in	r0, 0x3f	; 63
    5084:	0f 92       	push	r0
    5086:	0b b6       	in	r0, 0x3b	; 59
    5088:	0f 92       	push	r0
    508a:	11 24       	eor	r1, r1
    508c:	2f 93       	push	r18
    508e:	3f 93       	push	r19
    5090:	4f 93       	push	r20
    5092:	5f 93       	push	r21
    5094:	6f 93       	push	r22
    5096:	7f 93       	push	r23
    5098:	8f 93       	push	r24
    509a:	9f 93       	push	r25
    509c:	af 93       	push	r26
    509e:	bf 93       	push	r27
    50a0:	ef 93       	push	r30
    50a2:	ff 93       	push	r31
	TCCR4B &=~(1<<CS42) &~(1<<CS41) &~(1<<CS40);
    50a4:	e1 ea       	ldi	r30, 0xA1	; 161
    50a6:	f0 e0       	ldi	r31, 0x00	; 0
    50a8:	80 81       	ld	r24, Z
    50aa:	88 7f       	andi	r24, 0xF8	; 248
    50ac:	80 83       	st	Z, r24
	TIMSK4 &=~(1<<OCIE4A);
    50ae:	e2 e7       	ldi	r30, 0x72	; 114
    50b0:	f0 e0       	ldi	r31, 0x00	; 0
    50b2:	80 81       	ld	r24, Z
    50b4:	8d 7f       	andi	r24, 0xFD	; 253
    50b6:	80 83       	st	Z, r24
	MB_Timer_ISR((uint8_t*)&TCNT4);
    50b8:	84 ea       	ldi	r24, 0xA4	; 164
    50ba:	90 e0       	ldi	r25, 0x00	; 0
    50bc:	0e 94 77 27 	call	0x4eee	; 0x4eee <MB_Timer_ISR>
}
    50c0:	ff 91       	pop	r31
    50c2:	ef 91       	pop	r30
    50c4:	bf 91       	pop	r27
    50c6:	af 91       	pop	r26
    50c8:	9f 91       	pop	r25
    50ca:	8f 91       	pop	r24
    50cc:	7f 91       	pop	r23
    50ce:	6f 91       	pop	r22
    50d0:	5f 91       	pop	r21
    50d2:	4f 91       	pop	r20
    50d4:	3f 91       	pop	r19
    50d6:	2f 91       	pop	r18
    50d8:	0f 90       	pop	r0
    50da:	0b be       	out	0x3b, r0	; 59
    50dc:	0f 90       	pop	r0
    50de:	0f be       	out	0x3f, r0	; 63
    50e0:	0f 90       	pop	r0
    50e2:	1f 90       	pop	r1
    50e4:	18 95       	reti

000050e6 <MBRecept>:
		#endif
		MB_Err &=(1<<MB_N);
		return;
	}
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		Buf = USART_Reg(MB_N, ucsra);
    50e6:	68 2f       	mov	r22, r24
    50e8:	70 e0       	ldi	r23, 0x00	; 0

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    50ea:	9b 01       	movw	r18, r22
    50ec:	22 0f       	add	r18, r18
    50ee:	33 1f       	adc	r19, r19
    50f0:	cb 01       	movw	r24, r22
    50f2:	88 0f       	add	r24, r24
    50f4:	99 1f       	adc	r25, r25
    50f6:	88 0f       	add	r24, r24
    50f8:	99 1f       	adc	r25, r25
    50fa:	88 0f       	add	r24, r24
    50fc:	99 1f       	adc	r25, r25
    50fe:	28 0f       	add	r18, r24
    5100:	39 1f       	adc	r19, r25
    5102:	22 0f       	add	r18, r18
    5104:	33 1f       	adc	r19, r19
    5106:	2d 5e       	subi	r18, 0xED	; 237
    5108:	33 4d       	sbci	r19, 0xD3	; 211
    510a:	f9 01       	movw	r30, r18
    510c:	a5 91       	lpm	r26, Z+
    510e:	b4 91       	lpm	r27, Z+
    5110:	3c 91       	ld	r19, X
		MB_Frame[MB_N][MB_Frame_Sz[MB_N]++] = USART_Reg(MB_N, udr);
    5112:	ab 01       	movw	r20, r22
    5114:	41 50       	subi	r20, 0x01	; 1
    5116:	59 4f       	sbci	r21, 0xF9	; 249
    5118:	fa 01       	movw	r30, r20
    511a:	20 81       	ld	r18, Z
    511c:	cb 01       	movw	r24, r22
    511e:	88 0f       	add	r24, r24
    5120:	99 1f       	adc	r25, r25
    5122:	88 0f       	add	r24, r24
    5124:	99 1f       	adc	r25, r25
    5126:	fc 01       	movw	r30, r24
    5128:	ee 0f       	add	r30, r30
    512a:	ff 1f       	adc	r31, r31
    512c:	ee 0f       	add	r30, r30
    512e:	ff 1f       	adc	r31, r31
    5130:	e8 0f       	add	r30, r24
    5132:	f9 1f       	adc	r31, r25
    5134:	ef 5e       	subi	r30, 0xEF	; 239
    5136:	f3 4d       	sbci	r31, 0xD3	; 211
    5138:	a5 91       	lpm	r26, Z+
    513a:	b4 91       	lpm	r27, Z+
    513c:	f6 2f       	mov	r31, r22
    513e:	ee 27       	eor	r30, r30
    5140:	e2 0f       	add	r30, r18
    5142:	f1 1d       	adc	r31, r1
    5144:	e3 5e       	subi	r30, 0xE3	; 227
    5146:	f4 4f       	sbci	r31, 0xF4	; 244
    5148:	8c 91       	ld	r24, X
    514a:	80 83       	st	Z, r24
    514c:	2f 5f       	subi	r18, 0xFF	; 255
    514e:	fa 01       	movw	r30, r20
    5150:	20 83       	st	Z, r18
	#elif defined (__AVR_ATxmega128A1__)
		USART_t *usart = prp(&MB_Port[MB_N].usart);
		Buf = usart->STATUS;
		MB_Frame[MB_N][MB_Frame_Sz[MB_N]++] = usart->DATA;
	#endif
	if (Buf &(1<<3))
    5152:	23 2f       	mov	r18, r19
    5154:	30 e0       	ldi	r19, 0x00	; 0
    5156:	23 ff       	sbrs	r18, 3
    5158:	0e c0       	rjmp	.+28     	; 0x5176 <MBRecept+0x90>
		MB_CPT[MB_N][7]++;
    515a:	fb 01       	movw	r30, r22
    515c:	e2 95       	swap	r30
    515e:	f2 95       	swap	r31
    5160:	f0 7f       	andi	r31, 0xF0	; 240
    5162:	fe 27       	eor	r31, r30
    5164:	e0 7f       	andi	r30, 0xF0	; 240
    5166:	fe 27       	eor	r31, r30
    5168:	e8 51       	subi	r30, 0x18	; 24
    516a:	f7 4f       	sbci	r31, 0xF7	; 247
    516c:	86 85       	ldd	r24, Z+14	; 0x0e
    516e:	97 85       	ldd	r25, Z+15	; 0x0f
    5170:	01 96       	adiw	r24, 0x01	; 1
    5172:	97 87       	std	Z+15, r25	; 0x0f
    5174:	86 87       	std	Z+14, r24	; 0x0e
	if (Buf &((1<<4) |(1<<3) |(1<<2)))
    5176:	2c 71       	andi	r18, 0x1C	; 28
    5178:	30 70       	andi	r19, 0x00	; 0
    517a:	23 2b       	or	r18, r19
    517c:	61 f0       	breq	.+24     	; 0x5196 <MBRecept+0xb0>
		MB_Err |=(1<<MB_N);
    517e:	81 e0       	ldi	r24, 0x01	; 1
    5180:	90 e0       	ldi	r25, 0x00	; 0
    5182:	02 c0       	rjmp	.+4      	; 0x5188 <MBRecept+0xa2>
    5184:	88 0f       	add	r24, r24
    5186:	99 1f       	adc	r25, r25
    5188:	6a 95       	dec	r22
    518a:	e2 f7       	brpl	.-8      	; 0x5184 <MBRecept+0x9e>
    518c:	20 91 d1 04 	lds	r18, 0x04D1
    5190:	28 2b       	or	r18, r24
    5192:	20 93 d1 04 	sts	0x04D1, r18
    5196:	08 95       	ret

00005198 <MB_Transm>:
}

// ~~~~~~~~~~~~~~~~~~~~
void
MB_Transm(uint8_t MB_N)
{
    5198:	af 92       	push	r10
    519a:	bf 92       	push	r11
    519c:	cf 92       	push	r12
    519e:	df 92       	push	r13
    51a0:	ef 92       	push	r14
    51a2:	ff 92       	push	r15
    51a4:	0f 93       	push	r16
    51a6:	1f 93       	push	r17
	MB_State[MB_N] = MB_Trans;
    51a8:	e8 2e       	mov	r14, r24
    51aa:	ff 24       	eor	r15, r15
    51ac:	f7 01       	movw	r30, r14
    51ae:	e6 54       	subi	r30, 0x46	; 70
    51b0:	fa 4f       	sbci	r31, 0xFA	; 250
    51b2:	83 e0       	ldi	r24, 0x03	; 3
    51b4:	80 83       	st	Z, r24
    51b6:	57 01       	movw	r10, r14
    51b8:	aa 0c       	add	r10, r10
    51ba:	bb 1c       	adc	r11, r11
    51bc:	aa 0c       	add	r10, r10
    51be:	bb 1c       	adc	r11, r11
    51c0:	85 01       	movw	r16, r10
    51c2:	00 0f       	add	r16, r16
    51c4:	11 1f       	adc	r17, r17
    51c6:	00 0f       	add	r16, r16
    51c8:	11 1f       	adc	r17, r17
    51ca:	0a 0d       	add	r16, r10
    51cc:	1b 1d       	adc	r17, r11
    51ce:	04 5f       	subi	r16, 0xF4	; 244
    51d0:	1f 4f       	sbci	r17, 0xFF	; 255
    51d2:	81 e1       	ldi	r24, 0x11	; 17
    51d4:	c8 2e       	mov	r12, r24
    51d6:	8c e2       	ldi	r24, 0x2C	; 44
    51d8:	d8 2e       	mov	r13, r24
    51da:	c6 01       	movw	r24, r12
    51dc:	80 0f       	add	r24, r16
    51de:	91 1f       	adc	r25, r17
    51e0:	0c 50       	subi	r16, 0x0C	; 12
    51e2:	10 40       	sbci	r17, 0x00	; 0
    51e4:	fc 01       	movw	r30, r24
    51e6:	25 91       	lpm	r18, Z+
    51e8:	34 91       	lpm	r19, Z+
	USART_Func(MB_N, RS485);
    51ea:	f9 01       	movw	r30, r18
    51ec:	19 95       	eicall
    51ee:	f6 01       	movw	r30, r12
    51f0:	e0 0f       	add	r30, r16
    51f2:	f1 1f       	adc	r31, r17
    51f4:	a5 91       	lpm	r26, Z+
    51f6:	b4 91       	lpm	r27, Z+
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		//USART_Reg(MB_N, ucsrb) |=(1<<6);
		USART_Reg(MB_N, udr) = MB_Frame[MB_N][0];
    51f8:	fe 2d       	mov	r31, r14
    51fa:	ee 27       	eor	r30, r30
    51fc:	e3 5e       	subi	r30, 0xE3	; 227
    51fe:	f4 4f       	sbci	r31, 0xF4	; 244
    5200:	80 81       	ld	r24, Z
    5202:	8c 93       	st	X, r24
    5204:	97 01       	movw	r18, r14
    5206:	22 0f       	add	r18, r18
    5208:	33 1f       	adc	r19, r19
    520a:	c7 01       	movw	r24, r14
    520c:	88 0f       	add	r24, r24
    520e:	99 1f       	adc	r25, r25
    5210:	88 0f       	add	r24, r24
    5212:	99 1f       	adc	r25, r25
    5214:	88 0f       	add	r24, r24
    5216:	99 1f       	adc	r25, r25
    5218:	28 0f       	add	r18, r24
    521a:	39 1f       	adc	r19, r25
    521c:	2f 5f       	subi	r18, 0xFF	; 255
    521e:	3f 4f       	sbci	r19, 0xFF	; 255
    5220:	22 0f       	add	r18, r18
    5222:	33 1f       	adc	r19, r19
    5224:	2c 0d       	add	r18, r12
    5226:	3d 1d       	adc	r19, r13
    5228:	f9 01       	movw	r30, r18
    522a:	a5 91       	lpm	r26, Z+
    522c:	b4 91       	lpm	r27, Z+

		USART_Reg(MB_N, ucsra) |=(1<<6);	//Clear TxC pending interrupt		
    522e:	8c 91       	ld	r24, X
    5230:	80 64       	ori	r24, 0x40	; 64
    5232:	8c 93       	st	X, r24
    5234:	c5 01       	movw	r24, r10
    5236:	8e 0d       	add	r24, r14
    5238:	9f 1d       	adc	r25, r15
    523a:	01 96       	adiw	r24, 0x01	; 1
    523c:	88 0f       	add	r24, r24
    523e:	99 1f       	adc	r25, r25
    5240:	88 0f       	add	r24, r24
    5242:	99 1f       	adc	r25, r25
    5244:	8c 0d       	add	r24, r12
    5246:	9d 1d       	adc	r25, r13
    5248:	fc 01       	movw	r30, r24
    524a:	a5 91       	lpm	r26, Z+
    524c:	b4 91       	lpm	r27, Z+
		USART_Reg(MB_N, ucsrb) |=(1<<5);
    524e:	8c 91       	ld	r24, X
    5250:	80 62       	ori	r24, 0x20	; 32
    5252:	8c 93       	st	X, r24
	#elif defined (__AVR_ATxmega128A1__)
		USART_t *usart = prp(&MB_Port[MB_N].usart);
		usart->CTRLA = (usart->CTRLA &~USART_TXCINTLVL_gm) |USART_TXCINTLVL_HI_gc;
		usart->DATA = MB_Frame[MB_N][0];
	#endif
}
    5254:	1f 91       	pop	r17
    5256:	0f 91       	pop	r16
    5258:	ff 90       	pop	r15
    525a:	ef 90       	pop	r14
    525c:	df 90       	pop	r13
    525e:	cf 90       	pop	r12
    5260:	bf 90       	pop	r11
    5262:	af 90       	pop	r10
    5264:	08 95       	ret

00005266 <Modbus_RX>:

// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_RX(usart_t *usart)
{
    5266:	cf 93       	push	r28
    5268:	df 93       	push	r29
    526a:	dc 01       	movw	r26, r24
    526c:	e1 e1       	ldi	r30, 0x11	; 17
    526e:	fc e2       	ldi	r31, 0x2C	; 44
    5270:	85 91       	lpm	r24, Z+
    5272:	94 91       	lpm	r25, Z+
// ~~~~~~~~~~~~~~~~~~~~~~
static uint8_t
MB_Port_N(usart_t *usart)
{
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Port[MB_N].usart_field)!=usart; MB_N++);
    5274:	a8 17       	cp	r26, r24
    5276:	b9 07       	cpc	r27, r25
    5278:	09 f4       	brne	.+2      	; 0x527c <Modbus_RX+0x16>
    527a:	6e c0       	rjmp	.+220    	; 0x5358 <Modbus_RX+0xf2>
    527c:	30 e0       	ldi	r19, 0x00	; 0
    527e:	3f 5f       	subi	r19, 0xFF	; 255
    5280:	c3 2f       	mov	r28, r19
    5282:	d0 e0       	ldi	r29, 0x00	; 0
    5284:	ce 01       	movw	r24, r28
    5286:	88 0f       	add	r24, r24
    5288:	99 1f       	adc	r25, r25
    528a:	88 0f       	add	r24, r24
    528c:	99 1f       	adc	r25, r25
    528e:	fc 01       	movw	r30, r24
    5290:	ee 0f       	add	r30, r30
    5292:	ff 1f       	adc	r31, r31
    5294:	ee 0f       	add	r30, r30
    5296:	ff 1f       	adc	r31, r31
    5298:	e8 0f       	add	r30, r24
    529a:	f9 1f       	adc	r31, r25
    529c:	ef 5e       	subi	r30, 0xEF	; 239
    529e:	f3 4d       	sbci	r31, 0xD3	; 211
    52a0:	85 91       	lpm	r24, Z+
    52a2:	94 91       	lpm	r25, Z+
    52a4:	a8 17       	cp	r26, r24
    52a6:	b9 07       	cpc	r27, r25
    52a8:	51 f7       	brne	.-44     	; 0x527e <Modbus_RX+0x18>
// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_RX(usart_t *usart)
{
	uint8_t MB_N = MB_Port_N(usart);
	switch (MB_State[MB_N]) {
    52aa:	fe 01       	movw	r30, r28
    52ac:	e6 54       	subi	r30, 0x46	; 70
    52ae:	fa 4f       	sbci	r31, 0xFA	; 250
    52b0:	80 81       	ld	r24, Z
    52b2:	82 30       	cpi	r24, 0x02	; 2
    52b4:	19 f1       	breq	.+70     	; 0x52fc <Modbus_RX+0x96>
    52b6:	83 30       	cpi	r24, 0x03	; 3
    52b8:	28 f0       	brcs	.+10     	; 0x52c4 <Modbus_RX+0x5e>
    52ba:	86 30       	cpi	r24, 0x06	; 6
    52bc:	d8 f0       	brcs	.+54     	; 0x52f4 <Modbus_RX+0x8e>
	case MB_Trans: case MB_Proc: 
	case MB_NoReply: // MB_NoReply    MB_Recept ..  MB_M_Cycle   MB_Trans
		usart_data(usart);
		break;
	}
}
    52be:	df 91       	pop	r29
    52c0:	cf 91       	pop	r28
    52c2:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_RX(usart_t *usart)
{
	uint8_t MB_N = MB_Port_N(usart);
	switch (MB_State[MB_N]) {
    52c4:	88 23       	and	r24, r24
    52c6:	f1 f4       	brne	.+60     	; 0x5304 <Modbus_RX+0x9e>
	case MB_Initi:
		MB_Frame[MB_N][0] = usart_data(usart);
    52c8:	8c 91       	ld	r24, X
    52ca:	fc 2f       	mov	r31, r28
    52cc:	ee 27       	eor	r30, r30
    52ce:	e3 5e       	subi	r30, 0xE3	; 227
    52d0:	f4 4f       	sbci	r31, 0xF4	; 244
    52d2:	80 83       	st	Z, r24
    52d4:	ce 01       	movw	r24, r28
    52d6:	88 0f       	add	r24, r24
    52d8:	99 1f       	adc	r25, r25
    52da:	8c 0f       	add	r24, r28
    52dc:	9d 1f       	adc	r25, r29
    52de:	88 0f       	add	r24, r24
    52e0:	99 1f       	adc	r25, r25
    52e2:	8a 5d       	subi	r24, 0xDA	; 218
    52e4:	93 4d       	sbci	r25, 0xD3	; 211
    52e6:	fc 01       	movw	r30, r24
    52e8:	a5 91       	lpm	r26, Z+
    52ea:	b4 91       	lpm	r27, Z+
		break;
	case MB_Recept:
		/*if(TCNT2>=prb(&(BR_Tbl+MB_BitRate_RAM[MB_N])->Time15))
			MB_Err &=(1<<MB_N);*/
		MBRecept(MB_N);
		MB_ClearTimer(MB_N);
    52ec:	1c 92       	st	X, r1
	case MB_Trans: case MB_Proc: 
	case MB_NoReply: // MB_NoReply    MB_Recept ..  MB_M_Cycle   MB_Trans
		usart_data(usart);
		break;
	}
}
    52ee:	df 91       	pop	r29
    52f0:	cf 91       	pop	r28
    52f2:	08 95       	ret
		MBRecept(MB_N);
		MB_ClearTimer(MB_N);
		break;
	case MB_Trans: case MB_Proc: 
	case MB_NoReply: // MB_NoReply    MB_Recept ..  MB_M_Cycle   MB_Trans
		usart_data(usart);
    52f4:	8c 91       	ld	r24, X
		break;
	}
}
    52f6:	df 91       	pop	r29
    52f8:	cf 91       	pop	r28
    52fa:	08 95       	ret
		MB_StartTimer(MB_N);
		break;
	case MB_Recept:
		/*if(TCNT2>=prb(&(BR_Tbl+MB_BitRate_RAM[MB_N])->Time15))
			MB_Err &=(1<<MB_N);*/
		MBRecept(MB_N);
    52fc:	83 2f       	mov	r24, r19
    52fe:	0e 94 73 28 	call	0x50e6	; 0x50e6 <MBRecept>
    5302:	e8 cf       	rjmp	.-48     	; 0x52d4 <Modbus_RX+0x6e>
// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_RX(usart_t *usart)
{
	uint8_t MB_N = MB_Port_N(usart);
	switch (MB_State[MB_N]) {
    5304:	81 30       	cpi	r24, 0x01	; 1
    5306:	d9 f6       	brne	.-74     	; 0x52be <Modbus_RX+0x58>
	case MB_Initi:
		MB_Frame[MB_N][0] = usart_data(usart);
		MB_ClearTimer(MB_N);
		break;
	case MB_Idle: 
		MB_State[MB_N] = MB_Recept;
    5308:	82 e0       	ldi	r24, 0x02	; 2
    530a:	80 83       	st	Z, r24
		MB_Err &=~(1<<MB_N);
    530c:	81 e0       	ldi	r24, 0x01	; 1
    530e:	90 e0       	ldi	r25, 0x00	; 0
    5310:	0c 2e       	mov	r0, r28
    5312:	02 c0       	rjmp	.+4      	; 0x5318 <Modbus_RX+0xb2>
    5314:	88 0f       	add	r24, r24
    5316:	99 1f       	adc	r25, r25
    5318:	0a 94       	dec	r0
    531a:	e2 f7       	brpl	.-8      	; 0x5314 <Modbus_RX+0xae>
    531c:	80 95       	com	r24
    531e:	20 91 d1 04 	lds	r18, 0x04D1
    5322:	28 23       	and	r18, r24
    5324:	20 93 d1 04 	sts	0x04D1, r18
		MB_Frame_Sz[MB_N] = 0;
    5328:	fe 01       	movw	r30, r28
    532a:	e1 50       	subi	r30, 0x01	; 1
    532c:	f9 4f       	sbci	r31, 0xF9	; 249
    532e:	10 82       	st	Z, r1
		MBRecept(MB_N);
    5330:	83 2f       	mov	r24, r19
    5332:	0e 94 73 28 	call	0x50e6	; 0x50e6 <MBRecept>
    5336:	ce 01       	movw	r24, r28
    5338:	88 0f       	add	r24, r24
    533a:	99 1f       	adc	r25, r25
    533c:	8c 0f       	add	r24, r28
    533e:	9d 1f       	adc	r25, r29
    5340:	88 0f       	add	r24, r24
    5342:	99 1f       	adc	r25, r25
    5344:	86 5d       	subi	r24, 0xD6	; 214
    5346:	93 4d       	sbci	r25, 0xD3	; 211
    5348:	fc 01       	movw	r30, r24
    534a:	25 91       	lpm	r18, Z+
    534c:	34 91       	lpm	r19, Z+
		MB_StartTimer(MB_N);
    534e:	f9 01       	movw	r30, r18
    5350:	19 95       	eicall
	case MB_Trans: case MB_Proc: 
	case MB_NoReply: // MB_NoReply    MB_Recept ..  MB_M_Cycle   MB_Trans
		usart_data(usart);
		break;
	}
}
    5352:	df 91       	pop	r29
    5354:	cf 91       	pop	r28
    5356:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~
static uint8_t
MB_Port_N(usart_t *usart)
{
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Port[MB_N].usart_field)!=usart; MB_N++);
    5358:	30 e0       	ldi	r19, 0x00	; 0
    535a:	c0 e0       	ldi	r28, 0x00	; 0
    535c:	d0 e0       	ldi	r29, 0x00	; 0
    535e:	a5 cf       	rjmp	.-182    	; 0x52aa <Modbus_RX+0x44>

00005360 <CommErr>:
}

// ~~~~~~~~~~~~~~~~~~
uint8_t
CommErr(uint8_t MB_N)
{
    5360:	0f 93       	push	r16
    5362:	1f 93       	push	r17
    5364:	cf 93       	push	r28
    5366:	df 93       	push	r29
    5368:	38 2f       	mov	r19, r24
	uint8_t Sz = MB_Frame_Sz[MB_N]-2;
    536a:	c8 2f       	mov	r28, r24
    536c:	d0 e0       	ldi	r29, 0x00	; 0
    536e:	fe 01       	movw	r30, r28
    5370:	e1 50       	subi	r30, 0x01	; 1
    5372:	f9 4f       	sbci	r31, 0xF9	; 249
    5374:	20 81       	ld	r18, Z
	uint8_t Err = MB_Err &(1<<MB_N) || MB_Frame_Sz[MB_N]<3 || *(uint16_t*)(MB_Frame[MB_N]+Sz)!=CRC(rrb, MB_Frame[MB_N], Sz);
    5376:	80 91 d1 04 	lds	r24, 0x04D1
    537a:	90 e0       	ldi	r25, 0x00	; 0
    537c:	03 2e       	mov	r0, r19
    537e:	02 c0       	rjmp	.+4      	; 0x5384 <CommErr+0x24>
    5380:	95 95       	asr	r25
    5382:	87 95       	ror	r24
    5384:	0a 94       	dec	r0
    5386:	e2 f7       	brpl	.-8      	; 0x5380 <CommErr+0x20>
    5388:	80 ff       	sbrs	r24, 0
    538a:	29 c0       	rjmp	.+82     	; 0x53de <CommErr+0x7e>
	if (Err) {
		MB_CPT[MB_N][1]++;
    538c:	fe 01       	movw	r30, r28
    538e:	ee 0f       	add	r30, r30
    5390:	ff 1f       	adc	r31, r31
    5392:	ee 0f       	add	r30, r30
    5394:	ff 1f       	adc	r31, r31
    5396:	ee 0f       	add	r30, r30
    5398:	ff 1f       	adc	r31, r31
    539a:	ee 0f       	add	r30, r30
    539c:	ff 1f       	adc	r31, r31
    539e:	e6 51       	subi	r30, 0x16	; 22
    53a0:	f7 4f       	sbci	r31, 0xF7	; 247
    53a2:	80 81       	ld	r24, Z
    53a4:	91 81       	ldd	r25, Z+1	; 0x01
    53a6:	01 96       	adiw	r24, 0x01	; 1
    53a8:	91 83       	std	Z+1, r25	; 0x01
    53aa:	80 83       	st	Z, r24
    53ac:	ce 01       	movw	r24, r28
    53ae:	88 0f       	add	r24, r24
    53b0:	99 1f       	adc	r25, r25
    53b2:	88 0f       	add	r24, r24
    53b4:	99 1f       	adc	r25, r25
    53b6:	9c 01       	movw	r18, r24
    53b8:	22 0f       	add	r18, r18
    53ba:	33 1f       	adc	r19, r19
    53bc:	22 0f       	add	r18, r18
    53be:	33 1f       	adc	r19, r19
    53c0:	28 0f       	add	r18, r24
    53c2:	39 1f       	adc	r19, r25
    53c4:	2f 5d       	subi	r18, 0xDF	; 223
    53c6:	33 4d       	sbci	r19, 0xD3	; 211
    53c8:	f9 01       	movw	r30, r18
    53ca:	85 91       	lpm	r24, Z+
    53cc:	94 91       	lpm	r25, Z+
		USART_Func(MB_N, LED_Err_On);
    53ce:	fc 01       	movw	r30, r24
    53d0:	19 95       	eicall
    53d2:	81 e0       	ldi	r24, 0x01	; 1
	else {
		MB_CPT[MB_N][0]++;
		USART_Func(MB_N, LED_Err_Off);
	}
	return Err;
}
    53d4:	df 91       	pop	r29
    53d6:	cf 91       	pop	r28
    53d8:	1f 91       	pop	r17
    53da:	0f 91       	pop	r16
    53dc:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~
uint8_t
CommErr(uint8_t MB_N)
{
	uint8_t Sz = MB_Frame_Sz[MB_N]-2;
	uint8_t Err = MB_Err &(1<<MB_N) || MB_Frame_Sz[MB_N]<3 || *(uint16_t*)(MB_Frame[MB_N]+Sz)!=CRC(rrb, MB_Frame[MB_N], Sz);
    53de:	23 30       	cpi	r18, 0x03	; 3
    53e0:	a8 f2       	brcs	.-86     	; 0x538c <CommErr+0x2c>

// ~~~~~~~~~~~~~~~~~~
uint8_t
CommErr(uint8_t MB_N)
{
	uint8_t Sz = MB_Frame_Sz[MB_N]-2;
    53e2:	22 50       	subi	r18, 0x02	; 2
	uint8_t Err = MB_Err &(1<<MB_N) || MB_Frame_Sz[MB_N]<3 || *(uint16_t*)(MB_Frame[MB_N]+Sz)!=CRC(rrb, MB_Frame[MB_N], Sz);
    53e4:	73 2f       	mov	r23, r19
    53e6:	60 e0       	ldi	r22, 0x00	; 0
    53e8:	fb 01       	movw	r30, r22
    53ea:	e2 0f       	add	r30, r18
    53ec:	f1 1d       	adc	r31, r1
    53ee:	e3 5e       	subi	r30, 0xE3	; 227
    53f0:	f4 4f       	sbci	r31, 0xF4	; 244
    53f2:	00 81       	ld	r16, Z
    53f4:	11 81       	ldd	r17, Z+1	; 0x01
    53f6:	63 5e       	subi	r22, 0xE3	; 227
    53f8:	74 4f       	sbci	r23, 0xF4	; 244
    53fa:	30 e0       	ldi	r19, 0x00	; 0
    53fc:	40 e0       	ldi	r20, 0x00	; 0
    53fe:	50 e0       	ldi	r21, 0x00	; 0
    5400:	82 e6       	ldi	r24, 0x62	; 98
    5402:	98 e1       	ldi	r25, 0x18	; 24
    5404:	0e 94 d5 18 	call	0x31aa	; 0x31aa <CRC>
    5408:	08 17       	cp	r16, r24
    540a:	19 07       	cpc	r17, r25
    540c:	09 f0       	breq	.+2      	; 0x5410 <CommErr+0xb0>
    540e:	be cf       	rjmp	.-132    	; 0x538c <CommErr+0x2c>
	if (Err) {
		MB_CPT[MB_N][1]++;
		USART_Func(MB_N, LED_Err_On);
	}
	else {
		MB_CPT[MB_N][0]++;
    5410:	fe 01       	movw	r30, r28
    5412:	e2 95       	swap	r30
    5414:	f2 95       	swap	r31
    5416:	f0 7f       	andi	r31, 0xF0	; 240
    5418:	fe 27       	eor	r31, r30
    541a:	e0 7f       	andi	r30, 0xF0	; 240
    541c:	fe 27       	eor	r31, r30
    541e:	e8 51       	subi	r30, 0x18	; 24
    5420:	f7 4f       	sbci	r31, 0xF7	; 247
    5422:	80 81       	ld	r24, Z
    5424:	91 81       	ldd	r25, Z+1	; 0x01
    5426:	01 96       	adiw	r24, 0x01	; 1
    5428:	91 83       	std	Z+1, r25	; 0x01
    542a:	80 83       	st	Z, r24
    542c:	ce 01       	movw	r24, r28
    542e:	88 0f       	add	r24, r24
    5430:	99 1f       	adc	r25, r25
    5432:	88 0f       	add	r24, r24
    5434:	99 1f       	adc	r25, r25
    5436:	9c 01       	movw	r18, r24
    5438:	22 0f       	add	r18, r18
    543a:	33 1f       	adc	r19, r19
    543c:	22 0f       	add	r18, r18
    543e:	33 1f       	adc	r19, r19
    5440:	28 0f       	add	r18, r24
    5442:	39 1f       	adc	r19, r25
    5444:	2d 5d       	subi	r18, 0xDD	; 221
    5446:	33 4d       	sbci	r19, 0xD3	; 211
    5448:	f9 01       	movw	r30, r18
    544a:	85 91       	lpm	r24, Z+
    544c:	94 91       	lpm	r25, Z+
		USART_Func(MB_N, LED_Err_Off);
    544e:	fc 01       	movw	r30, r24
    5450:	19 95       	eicall
    5452:	80 e0       	ldi	r24, 0x00	; 0
    5454:	bf cf       	rjmp	.-130    	; 0x53d4 <CommErr+0x74>

00005456 <SetCRC_MB>:
}

// ~~~~~~~~~~~~~~~~~~~~
void
SetCRC_MB(uint8_t MB_N)
{
    5456:	df 92       	push	r13
    5458:	ef 92       	push	r14
    545a:	ff 92       	push	r15
    545c:	0f 93       	push	r16
    545e:	1f 93       	push	r17
	uint8_t Sz = MB_Frame_Sz[MB_N]-2;
    5460:	ef ef       	ldi	r30, 0xFF	; 255
    5462:	f6 e0       	ldi	r31, 0x06	; 6
    5464:	e8 0f       	add	r30, r24
    5466:	f1 1d       	adc	r31, r1
    5468:	d0 80       	ld	r13, Z
    546a:	9e ef       	ldi	r25, 0xFE	; 254
    546c:	d9 0e       	add	r13, r25
	*(uint16_t*)(MB_Frame[MB_N]+Sz) = CRC(rrb, MB_Frame[MB_N], Sz);
    546e:	18 2f       	mov	r17, r24
    5470:	00 e0       	ldi	r16, 0x00	; 0
    5472:	8d e1       	ldi	r24, 0x1D	; 29
    5474:	e8 2e       	mov	r14, r24
    5476:	8b e0       	ldi	r24, 0x0B	; 11
    5478:	f8 2e       	mov	r15, r24
    547a:	b7 01       	movw	r22, r14
    547c:	60 0f       	add	r22, r16
    547e:	71 1f       	adc	r23, r17
    5480:	2d 2d       	mov	r18, r13
    5482:	30 e0       	ldi	r19, 0x00	; 0
    5484:	40 e0       	ldi	r20, 0x00	; 0
    5486:	50 e0       	ldi	r21, 0x00	; 0
    5488:	82 e6       	ldi	r24, 0x62	; 98
    548a:	98 e1       	ldi	r25, 0x18	; 24
    548c:	0e 94 d5 18 	call	0x31aa	; 0x31aa <CRC>
    5490:	0d 0d       	add	r16, r13
    5492:	11 1d       	adc	r17, r1
    5494:	e0 0e       	add	r14, r16
    5496:	f1 1e       	adc	r15, r17
    5498:	f7 01       	movw	r30, r14
    549a:	91 83       	std	Z+1, r25	; 0x01
    549c:	80 83       	st	Z, r24
}
    549e:	1f 91       	pop	r17
    54a0:	0f 91       	pop	r16
    54a2:	ff 90       	pop	r15
    54a4:	ef 90       	pop	r14
    54a6:	df 90       	pop	r13
    54a8:	08 95       	ret

000054aa <MB_FrameReg>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
MB_FrameReg(uint8_t MB_N, uint8_t i)
{
	return MB_Frame[MB_N][i]<<8 | MB_Frame[MB_N][i+1];
    54aa:	70 e0       	ldi	r23, 0x00	; 0
    54ac:	ad e1       	ldi	r26, 0x1D	; 29
    54ae:	bb e0       	ldi	r27, 0x0B	; 11
    54b0:	f8 2f       	mov	r31, r24
    54b2:	e0 e0       	ldi	r30, 0x00	; 0
    54b4:	ea 0f       	add	r30, r26
    54b6:	fb 1f       	adc	r31, r27
    54b8:	e6 0f       	add	r30, r22
    54ba:	f7 1f       	adc	r31, r23
    54bc:	41 81       	ldd	r20, Z+1	; 0x01
    54be:	50 e0       	ldi	r21, 0x00	; 0
    54c0:	38 2f       	mov	r19, r24
    54c2:	20 e0       	ldi	r18, 0x00	; 0
    54c4:	26 0f       	add	r18, r22
    54c6:	37 1f       	adc	r19, r23
    54c8:	a2 0f       	add	r26, r18
    54ca:	b3 1f       	adc	r27, r19
    54cc:	9c 91       	ld	r25, X
    54ce:	80 e0       	ldi	r24, 0x00	; 0
    54d0:	48 2b       	or	r20, r24
    54d2:	59 2b       	or	r21, r25
}
    54d4:	ca 01       	movw	r24, r20
    54d6:	08 95       	ret

000054d8 <MB_CPT_Clear>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~
void
MB_CPT_Clear(uint8_t MB_N)
{
    54d8:	90 e0       	ldi	r25, 0x00	; 0
    54da:	20 e0       	ldi	r18, 0x00	; 0
    54dc:	30 e0       	ldi	r19, 0x00	; 0
    54de:	88 0f       	add	r24, r24
    54e0:	99 1f       	adc	r25, r25
    54e2:	88 0f       	add	r24, r24
    54e4:	99 1f       	adc	r25, r25
    54e6:	88 0f       	add	r24, r24
    54e8:	99 1f       	adc	r25, r25
	for (uint8_t i=0; i<8; MB_CPT[MB_N][i++]=0);
    54ea:	fc 01       	movw	r30, r24
    54ec:	e2 0f       	add	r30, r18
    54ee:	f3 1f       	adc	r31, r19
    54f0:	ee 0f       	add	r30, r30
    54f2:	ff 1f       	adc	r31, r31
    54f4:	e8 51       	subi	r30, 0x18	; 24
    54f6:	f7 4f       	sbci	r31, 0xF7	; 247
    54f8:	11 82       	std	Z+1, r1	; 0x01
    54fa:	10 82       	st	Z, r1
    54fc:	2f 5f       	subi	r18, 0xFF	; 255
    54fe:	3f 4f       	sbci	r19, 0xFF	; 255
    5500:	28 30       	cpi	r18, 0x08	; 8
    5502:	31 05       	cpc	r19, r1
    5504:	91 f7       	brne	.-28     	; 0x54ea <MB_CPT_Clear+0x12>
}
    5506:	08 95       	ret

00005508 <MB_S_Timer_ISR>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_S_Timer_ISR(uint8_t MB_N)
{
    5508:	2f 92       	push	r2
    550a:	3f 92       	push	r3
    550c:	4f 92       	push	r4
    550e:	5f 92       	push	r5
    5510:	6f 92       	push	r6
    5512:	7f 92       	push	r7
    5514:	8f 92       	push	r8
    5516:	9f 92       	push	r9
    5518:	af 92       	push	r10
    551a:	bf 92       	push	r11
    551c:	cf 92       	push	r12
    551e:	df 92       	push	r13
    5520:	ef 92       	push	r14
    5522:	ff 92       	push	r15
    5524:	0f 93       	push	r16
    5526:	1f 93       	push	r17
    5528:	df 93       	push	r29
    552a:	cf 93       	push	r28
    552c:	cd b7       	in	r28, 0x3d	; 61
    552e:	de b7       	in	r29, 0x3e	; 62
    5530:	29 97       	sbiw	r28, 0x09	; 9
    5532:	0f b6       	in	r0, 0x3f	; 63
    5534:	f8 94       	cli
    5536:	de bf       	out	0x3e, r29	; 62
    5538:	0f be       	out	0x3f, r0	; 63
    553a:	cd bf       	out	0x3d, r28	; 61
    553c:	d8 2e       	mov	r13, r24
	switch (MB_State[MB_N]) {
    553e:	28 2f       	mov	r18, r24
    5540:	30 e0       	ldi	r19, 0x00	; 0
    5542:	39 87       	std	Y+9, r19	; 0x09
    5544:	28 87       	std	Y+8, r18	; 0x08
    5546:	89 01       	movw	r16, r18
    5548:	06 54       	subi	r16, 0x46	; 70
    554a:	1a 4f       	sbci	r17, 0xFA	; 250
    554c:	d8 01       	movw	r26, r16
    554e:	8c 91       	ld	r24, X
    5550:	88 23       	and	r24, r24
    5552:	b9 f1       	breq	.+110    	; 0x55c2 <MB_S_Timer_ISR+0xba>
    5554:	82 30       	cpi	r24, 0x02	; 2
    5556:	c9 f0       	breq	.+50     	; 0x558a <MB_S_Timer_ISR+0x82>
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
		MB_S_CtrlProc(MB_N);
		break;
	}
}
    5558:	29 96       	adiw	r28, 0x09	; 9
    555a:	0f b6       	in	r0, 0x3f	; 63
    555c:	f8 94       	cli
    555e:	de bf       	out	0x3e, r29	; 62
    5560:	0f be       	out	0x3f, r0	; 63
    5562:	cd bf       	out	0x3d, r28	; 61
    5564:	cf 91       	pop	r28
    5566:	df 91       	pop	r29
    5568:	1f 91       	pop	r17
    556a:	0f 91       	pop	r16
    556c:	ff 90       	pop	r15
    556e:	ef 90       	pop	r14
    5570:	df 90       	pop	r13
    5572:	cf 90       	pop	r12
    5574:	bf 90       	pop	r11
    5576:	af 90       	pop	r10
    5578:	9f 90       	pop	r9
    557a:	8f 90       	pop	r8
    557c:	7f 90       	pop	r7
    557e:	6f 90       	pop	r6
    5580:	5f 90       	pop	r5
    5582:	4f 90       	pop	r4
    5584:	3f 90       	pop	r3
    5586:	2f 90       	pop	r2
    5588:	08 95       	ret
	switch (MB_State[MB_N]) {
	case MB_Initi:
		MB_State[MB_N] = MB_Idle;
		break;
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
    558a:	84 e0       	ldi	r24, 0x04	; 4
    558c:	d8 01       	movw	r26, r16
    558e:	8c 93       	st	X, r24

// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
MB_S_CtrlProc(uint8_t MB_N)
{
	if (CommErr(MB_N)) {
    5590:	8d 2d       	mov	r24, r13
    5592:	0e 94 b0 29 	call	0x5360	; 0x5360 <CommErr>
    5596:	88 23       	and	r24, r24
    5598:	a1 f4       	brne	.+40     	; 0x55c2 <MB_S_Timer_ISR+0xba>
		MB_State[MB_N] = MB_Idle;
		return;
	}
	if (MB_Frame[MB_N][0]!=0 && MB_Frame[MB_N][0]!=MB_NativeAddr[MB_N]) {
    559a:	28 85       	ldd	r18, Y+8	; 0x08
    559c:	39 85       	ldd	r19, Y+9	; 0x09
    559e:	f2 2e       	mov	r15, r18
    55a0:	ee 24       	eor	r14, r14
    55a2:	f7 01       	movw	r30, r14
    55a4:	e3 5e       	subi	r30, 0xE3	; 227
    55a6:	f4 4f       	sbci	r31, 0xF4	; 244
    55a8:	90 81       	ld	r25, Z
    55aa:	99 23       	and	r25, r25
    55ac:	71 f0       	breq	.+28     	; 0x55ca <MB_S_Timer_ISR+0xc2>
    55ae:	f9 01       	movw	r30, r18
    55b0:	e8 52       	subi	r30, 0x28	; 40
    55b2:	fa 4f       	sbci	r31, 0xFA	; 250
    55b4:	80 81       	ld	r24, Z
    55b6:	98 17       	cp	r25, r24
    55b8:	41 f0       	breq	.+16     	; 0x55ca <MB_S_Timer_ISR+0xc2>
		MB_State[MB_N] = MB_Idle;
    55ba:	81 e0       	ldi	r24, 0x01	; 1
    55bc:	d8 01       	movw	r26, r16
    55be:	8c 93       	st	X, r24
    55c0:	cb cf       	rjmp	.-106    	; 0x5558 <MB_S_Timer_ISR+0x50>
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
MB_S_CtrlProc(uint8_t MB_N)
{
	if (CommErr(MB_N)) {
		MB_State[MB_N] = MB_Idle;
    55c2:	81 e0       	ldi	r24, 0x01	; 1
    55c4:	f8 01       	movw	r30, r16
    55c6:	80 83       	st	Z, r24
    55c8:	c7 cf       	rjmp	.-114    	; 0x5558 <MB_S_Timer_ISR+0x50>
    55ca:	28 84       	ldd	r2, Y+8	; 0x08
    55cc:	39 84       	ldd	r3, Y+9	; 0x09
    55ce:	22 0c       	add	r2, r2
    55d0:	33 1c       	adc	r3, r3
    55d2:	22 0c       	add	r2, r2
    55d4:	33 1c       	adc	r3, r3
    55d6:	51 01       	movw	r10, r2
    55d8:	aa 0c       	add	r10, r10
    55da:	bb 1c       	adc	r11, r11
    55dc:	aa 0c       	add	r10, r10
    55de:	bb 1c       	adc	r11, r11
    55e0:	a2 0c       	add	r10, r2
    55e2:	b3 1c       	adc	r11, r3
    55e4:	ef e1       	ldi	r30, 0x1F	; 31
    55e6:	fc e2       	ldi	r31, 0x2C	; 44
    55e8:	ae 0e       	add	r10, r30
    55ea:	bf 1e       	adc	r11, r31
    55ec:	f5 01       	movw	r30, r10
    55ee:	25 91       	lpm	r18, Z+
    55f0:	34 91       	lpm	r19, Z+
	}
	if (MB_Frame[MB_N][0]!=0 && MB_Frame[MB_N][0]!=MB_NativeAddr[MB_N]) {
		MB_State[MB_N] = MB_Idle;
		return;
	}
	USART_Func(MB_N, LED);
    55f2:	f9 01       	movw	r30, r18
    55f4:	19 95       	eicall
	MB_CPT[MB_N][3]++;
    55f6:	68 84       	ldd	r6, Y+8	; 0x08
    55f8:	79 84       	ldd	r7, Y+9	; 0x09
    55fa:	62 94       	swap	r6
    55fc:	72 94       	swap	r7
    55fe:	b0 ef       	ldi	r27, 0xF0	; 240
    5600:	7b 22       	and	r7, r27
    5602:	76 24       	eor	r7, r6
    5604:	6b 22       	and	r6, r27
    5606:	76 24       	eor	r7, r6
    5608:	f3 01       	movw	r30, r6
    560a:	e8 51       	subi	r30, 0x18	; 24
    560c:	f7 4f       	sbci	r31, 0xF7	; 247
    560e:	86 81       	ldd	r24, Z+6	; 0x06
    5610:	97 81       	ldd	r25, Z+7	; 0x07
    5612:	01 96       	adiw	r24, 0x01	; 1
    5614:	97 83       	std	Z+7, r25	; 0x07
    5616:	86 83       	std	Z+6, r24	; 0x06

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
MB_FrameReg(uint8_t MB_N, uint8_t i)
{
	return MB_Frame[MB_N][i]<<8 | MB_Frame[MB_N][i+1];
    5618:	68 85       	ldd	r22, Y+8	; 0x08
    561a:	79 85       	ldd	r23, Y+9	; 0x09
    561c:	76 95       	lsr	r23
    561e:	76 2f       	mov	r23, r22
    5620:	66 27       	eor	r22, r22
    5622:	77 95       	ror	r23
    5624:	67 95       	ror	r22
    5626:	db 01       	movw	r26, r22
    5628:	aa 0f       	add	r26, r26
    562a:	bb 1f       	adc	r27, r27
    562c:	a1 5e       	subi	r26, 0xE1	; 225
    562e:	b4 4f       	sbci	r27, 0xF4	; 244
    5630:	9c 91       	ld	r25, X
    5632:	80 e0       	ldi	r24, 0x00	; 0
    5634:	a7 01       	movw	r20, r14
    5636:	43 5e       	subi	r20, 0xE3	; 227
    5638:	54 4f       	sbci	r21, 0xF4	; 244
    563a:	fa 01       	movw	r30, r20
    563c:	23 81       	ldd	r18, Z+3	; 0x03
    563e:	82 2e       	mov	r8, r18
    5640:	99 24       	eor	r9, r9
    5642:	88 2a       	or	r8, r24
    5644:	99 2a       	or	r9, r25
inline static uint8_t
Process(uint8_t MB_N)
{
	uint8_t Err;
	uint16_t StartAddr = MB_FrameReg(MB_N, 2);
	switch (MB_Frame[MB_N][1]) {
    5646:	31 81       	ldd	r19, Z+1	; 0x01
    5648:	35 30       	cpi	r19, 0x05	; 5
    564a:	08 f0       	brcs	.+2      	; 0x564e <MB_S_Timer_ISR+0x146>
    564c:	52 c0       	rjmp	.+164    	; 0x56f2 <MB_S_Timer_ISR+0x1ea>
    564e:	33 30       	cpi	r19, 0x03	; 3
    5650:	08 f4       	brcc	.+2      	; 0x5654 <MB_S_Timer_ISR+0x14c>
    5652:	72 c0       	rjmp	.+228    	; 0x5738 <MB_S_Timer_ISR+0x230>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_ReadReg(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame[MB_N][0]==0)
    5654:	fa 01       	movw	r30, r20
    5656:	80 81       	ld	r24, Z
    5658:	88 23       	and	r24, r24
    565a:	09 f4       	brne	.+2      	; 0x565e <MB_S_Timer_ISR+0x156>
    565c:	5c c0       	rjmp	.+184    	; 0x5716 <MB_S_Timer_ISR+0x20e>
		return 0xFF;
	if (MB_Frame_Sz[MB_N]!=8)
    565e:	2f ef       	ldi	r18, 0xFF	; 255
    5660:	42 2e       	mov	r4, r18
    5662:	26 e0       	ldi	r18, 0x06	; 6
    5664:	52 2e       	mov	r5, r18
    5666:	88 85       	ldd	r24, Y+8	; 0x08
    5668:	99 85       	ldd	r25, Y+9	; 0x09
    566a:	48 0e       	add	r4, r24
    566c:	59 1e       	adc	r5, r25
    566e:	f2 01       	movw	r30, r4
    5670:	80 81       	ld	r24, Z
    5672:	88 30       	cpi	r24, 0x08	; 8
    5674:	09 f4       	brne	.+2      	; 0x5678 <MB_S_Timer_ISR+0x170>
    5676:	27 c2       	rjmp	.+1102   	; 0x5ac6 <MB_S_Timer_ISR+0x5be>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_PresetSingle(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame_Sz[MB_N]!=8)
		return MB_Frame[MB_N][2]=IllegData;
    5678:	83 e0       	ldi	r24, 0x03	; 3
    567a:	8c 93       	st	X, r24
    567c:	93 e0       	ldi	r25, 0x03	; 3
		break;
	default:
		Err = MB_Frame[MB_N][2] = IllegFunc;
		break;
	}
	if (MB_Frame[MB_N][0]) {
    567e:	f7 01       	movw	r30, r14
    5680:	e3 5e       	subi	r30, 0xE3	; 227
    5682:	f4 4f       	sbci	r31, 0xF4	; 244
    5684:	80 81       	ld	r24, Z
    5686:	88 23       	and	r24, r24
    5688:	81 f0       	breq	.+32     	; 0x56aa <MB_S_Timer_ISR+0x1a2>
		if (Err) {
    568a:	99 23       	and	r25, r25
    568c:	49 f0       	breq	.+18     	; 0x56a0 <MB_S_Timer_ISR+0x198>
			MB_Frame[MB_N][1] |=(1<<7);
    568e:	81 81       	ldd	r24, Z+1	; 0x01
    5690:	80 68       	ori	r24, 0x80	; 128
    5692:	81 83       	std	Z+1, r24	; 0x01
			MB_Frame_Sz[MB_N] = 5;
    5694:	e8 85       	ldd	r30, Y+8	; 0x08
    5696:	f9 85       	ldd	r31, Y+9	; 0x09
    5698:	e1 50       	subi	r30, 0x01	; 1
    569a:	f9 4f       	sbci	r31, 0xF9	; 249
    569c:	85 e0       	ldi	r24, 0x05	; 5
    569e:	80 83       	st	Z, r24
		}
		SetCRC_MB(MB_N);
    56a0:	8d 2d       	mov	r24, r13
    56a2:	9d 83       	std	Y+5, r25	; 0x05
    56a4:	0e 94 2b 2a 	call	0x5456	; 0x5456 <SetCRC_MB>
    56a8:	9d 81       	ldd	r25, Y+5	; 0x05
		MB_State[MB_N] = MB_Idle;
		return;
	}
	USART_Func(MB_N, LED);
	MB_CPT[MB_N][3]++;
	if (Process(MB_N))
    56aa:	99 23       	and	r25, r25
    56ac:	a1 f5       	brne	.+104    	; 0x5716 <MB_S_Timer_ISR+0x20e>
		MB_CPT[MB_N][2]++;
	if (MB_Frame[MB_N][0])
    56ae:	2d e1       	ldi	r18, 0x1D	; 29
    56b0:	3b e0       	ldi	r19, 0x0B	; 11
    56b2:	e2 0e       	add	r14, r18
    56b4:	f3 1e       	adc	r15, r19
    56b6:	d7 01       	movw	r26, r14
    56b8:	8c 91       	ld	r24, X
    56ba:	88 23       	and	r24, r24
    56bc:	c9 f5       	brne	.+114    	; 0x5730 <MB_S_Timer_ISR+0x228>
		MB_Transm(MB_N);
	else {
		MB_CPT[MB_N][4]++;
    56be:	e8 85       	ldd	r30, Y+8	; 0x08
    56c0:	f9 85       	ldd	r31, Y+9	; 0x09
    56c2:	ee 0f       	add	r30, r30
    56c4:	ff 1f       	adc	r31, r31
    56c6:	ee 0f       	add	r30, r30
    56c8:	ff 1f       	adc	r31, r31
    56ca:	ee 0f       	add	r30, r30
    56cc:	ff 1f       	adc	r31, r31
    56ce:	ee 0f       	add	r30, r30
    56d0:	ff 1f       	adc	r31, r31
    56d2:	e0 51       	subi	r30, 0x10	; 16
    56d4:	f7 4f       	sbci	r31, 0xF7	; 247
    56d6:	80 81       	ld	r24, Z
    56d8:	91 81       	ldd	r25, Z+1	; 0x01
    56da:	01 96       	adiw	r24, 0x01	; 1
    56dc:	91 83       	std	Z+1, r25	; 0x01
    56de:	80 83       	st	Z, r24
		MB_State[MB_N] = MB_Idle;
    56e0:	81 e0       	ldi	r24, 0x01	; 1
    56e2:	f8 01       	movw	r30, r16
    56e4:	80 83       	st	Z, r24
    56e6:	f5 01       	movw	r30, r10
    56e8:	85 91       	lpm	r24, Z+
    56ea:	94 91       	lpm	r25, Z+
		USART_Func(MB_N, LED);
    56ec:	fc 01       	movw	r30, r24
    56ee:	19 95       	eicall
    56f0:	33 cf       	rjmp	.-410    	; 0x5558 <MB_S_Timer_ISR+0x50>
inline static uint8_t
Process(uint8_t MB_N)
{
	uint8_t Err;
	uint16_t StartAddr = MB_FrameReg(MB_N, 2);
	switch (MB_Frame[MB_N][1]) {
    56f2:	3f 30       	cpi	r19, 0x0F	; 15
    56f4:	09 f4       	brne	.+2      	; 0x56f8 <MB_S_Timer_ISR+0x1f0>
    56f6:	1e c1       	rjmp	.+572    	; 0x5934 <MB_S_Timer_ISR+0x42c>
    56f8:	30 31       	cpi	r19, 0x10	; 16
    56fa:	09 f4       	brne	.+2      	; 0x56fe <MB_S_Timer_ISR+0x1f6>
    56fc:	fc c0       	rjmp	.+504    	; 0x58f6 <MB_S_Timer_ISR+0x3ee>
    56fe:	36 30       	cpi	r19, 0x06	; 6
    5700:	09 f4       	brne	.+2      	; 0x5704 <MB_S_Timer_ISR+0x1fc>
    5702:	bd c0       	rjmp	.+378    	; 0x587e <MB_S_Timer_ISR+0x376>
		break;
	case 0x10:
		Err = MB_S_Preset(MB_N, StartAddr);
		break;
	default:
		Err = MB_Frame[MB_N][2] = IllegFunc;
    5704:	66 0f       	add	r22, r22
    5706:	77 1f       	adc	r23, r23
    5708:	61 5e       	subi	r22, 0xE1	; 225
    570a:	74 4f       	sbci	r23, 0xF4	; 244
    570c:	81 e0       	ldi	r24, 0x01	; 1
    570e:	fb 01       	movw	r30, r22
    5710:	80 83       	st	Z, r24
    5712:	91 e0       	ldi	r25, 0x01	; 1
    5714:	b4 cf       	rjmp	.-152    	; 0x567e <MB_S_Timer_ISR+0x176>
		return;
	}
	USART_Func(MB_N, LED);
	MB_CPT[MB_N][3]++;
	if (Process(MB_N))
		MB_CPT[MB_N][2]++;
    5716:	f1 01       	movw	r30, r2
    5718:	ee 0f       	add	r30, r30
    571a:	ff 1f       	adc	r31, r31
    571c:	ee 0f       	add	r30, r30
    571e:	ff 1f       	adc	r31, r31
    5720:	e4 51       	subi	r30, 0x14	; 20
    5722:	f7 4f       	sbci	r31, 0xF7	; 247
    5724:	80 81       	ld	r24, Z
    5726:	91 81       	ldd	r25, Z+1	; 0x01
    5728:	01 96       	adiw	r24, 0x01	; 1
    572a:	91 83       	std	Z+1, r25	; 0x01
    572c:	80 83       	st	Z, r24
    572e:	bf cf       	rjmp	.-130    	; 0x56ae <MB_S_Timer_ISR+0x1a6>
	if (MB_Frame[MB_N][0])
		MB_Transm(MB_N);
    5730:	8d 2d       	mov	r24, r13
    5732:	0e 94 cc 28 	call	0x5198	; 0x5198 <MB_Transm>
    5736:	10 cf       	rjmp	.-480    	; 0x5558 <MB_S_Timer_ISR+0x50>
inline static uint8_t
Process(uint8_t MB_N)
{
	uint8_t Err;
	uint16_t StartAddr = MB_FrameReg(MB_N, 2);
	switch (MB_Frame[MB_N][1]) {
    5738:	31 30       	cpi	r19, 0x01	; 1
    573a:	20 f3       	brcs	.-56     	; 0x5704 <MB_S_Timer_ISR+0x1fc>
*/
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_ReadDiscr(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame[MB_N][0]==0)
    573c:	fa 01       	movw	r30, r20
    573e:	80 81       	ld	r24, Z
    5740:	88 23       	and	r24, r24
    5742:	49 f3       	breq	.-46     	; 0x5716 <MB_S_Timer_ISR+0x20e>
		return 0xFF;
	if (MB_Frame_Sz[MB_N]!=8)
    5744:	ef ef       	ldi	r30, 0xFF	; 255
    5746:	4e 2e       	mov	r4, r30
    5748:	e6 e0       	ldi	r30, 0x06	; 6
    574a:	5e 2e       	mov	r5, r30
    574c:	88 85       	ldd	r24, Y+8	; 0x08
    574e:	99 85       	ldd	r25, Y+9	; 0x09
    5750:	48 0e       	add	r4, r24
    5752:	59 1e       	adc	r5, r25
    5754:	f2 01       	movw	r30, r4
    5756:	80 81       	ld	r24, Z
    5758:	88 30       	cpi	r24, 0x08	; 8
    575a:	09 f0       	breq	.+2      	; 0x575e <MB_S_Timer_ISR+0x256>
    575c:	8d cf       	rjmp	.-230    	; 0x5678 <MB_S_Timer_ISR+0x170>
    575e:	88 85       	ldd	r24, Y+8	; 0x08
    5760:	99 85       	ldd	r25, Y+9	; 0x09
    5762:	f8 2f       	mov	r31, r24
    5764:	ee 27       	eor	r30, r30
    5766:	ef 5d       	subi	r30, 0xDF	; 223
    5768:	f4 4f       	sbci	r31, 0xF4	; 244
    576a:	90 81       	ld	r25, Z
    576c:	80 e0       	ldi	r24, 0x00	; 0
    576e:	da 01       	movw	r26, r20
    5770:	15 96       	adiw	r26, 0x05	; 5
    5772:	2c 91       	ld	r18, X
    5774:	a2 2f       	mov	r26, r18
    5776:	b0 e0       	ldi	r27, 0x00	; 0
    5778:	a8 2b       	or	r26, r24
    577a:	b9 2b       	or	r27, r25
		return MB_Frame[MB_N][2]=IllegData;
	uint16_t Qt = MB_FrameReg(MB_N, 4);
	if (StartAddr+Qt>(MB_Frame[MB_N][1]==1?prw(&Modbus_Map[MB_N].Coil_Qt):prw(&Modbus_Map[MB_N].Input_Qt)))
    577c:	31 30       	cpi	r19, 0x01	; 1
    577e:	09 f4       	brne	.+2      	; 0x5782 <MB_S_Timer_ISR+0x27a>
    5780:	44 c2       	rjmp	.+1160   	; 0x5c0a <MB_S_Timer_ISR+0x702>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    5782:	f3 01       	movw	r30, r6
    5784:	ee 5c       	subi	r30, 0xCE	; 206
    5786:	fc 4f       	sbci	r31, 0xFC	; 252
    5788:	45 91       	lpm	r20, Z+
    578a:	54 91       	lpm	r21, Z+
    578c:	cd 01       	movw	r24, r26
    578e:	88 0d       	add	r24, r8
    5790:	99 1d       	adc	r25, r9
    5792:	48 17       	cp	r20, r24
    5794:	59 07       	cpc	r21, r25
    5796:	08 f4       	brcc	.+2      	; 0x579a <MB_S_Timer_ISR+0x292>
    5798:	8d c1       	rjmp	.+794    	; 0x5ab4 <MB_S_Timer_ISR+0x5ac>
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
    579a:	31 30       	cpi	r19, 0x01	; 1
    579c:	09 f4       	brne	.+2      	; 0x57a0 <MB_S_Timer_ISR+0x298>
    579e:	4a c2       	rjmp	.+1172   	; 0x5c34 <MB_S_Timer_ISR+0x72c>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    57a0:	f1 01       	movw	r30, r2
    57a2:	ee 0f       	add	r30, r30
    57a4:	ff 1f       	adc	r31, r31
    57a6:	ee 0f       	add	r30, r30
    57a8:	ff 1f       	adc	r31, r31
    57aa:	e0 5d       	subi	r30, 0xD0	; 208
    57ac:	fc 4f       	sbci	r31, 0xFC	; 252
    57ae:	85 91       	lpm	r24, Z+
    57b0:	94 91       	lpm	r25, Z+
    57b2:	28 2f       	mov	r18, r24
    57b4:	89 2f       	mov	r24, r25
    57b6:	62 2e       	mov	r6, r18
    57b8:	78 2e       	mov	r7, r24
	MB_Frame[MB_N][2] = Qt/8+(Qt%8>0);
    57ba:	20 e0       	ldi	r18, 0x00	; 0
    57bc:	cd 01       	movw	r24, r26
    57be:	87 70       	andi	r24, 0x07	; 7
    57c0:	90 70       	andi	r25, 0x00	; 0
    57c2:	89 2b       	or	r24, r25
    57c4:	09 f0       	breq	.+2      	; 0x57c8 <MB_S_Timer_ISR+0x2c0>
    57c6:	21 e0       	ldi	r18, 0x01	; 1
    57c8:	cd 01       	movw	r24, r26
    57ca:	96 95       	lsr	r25
    57cc:	87 95       	ror	r24
    57ce:	96 95       	lsr	r25
    57d0:	87 95       	ror	r24
    57d2:	96 95       	lsr	r25
    57d4:	87 95       	ror	r24
    57d6:	82 0f       	add	r24, r18
    57d8:	66 0f       	add	r22, r22
    57da:	77 1f       	adc	r23, r23
    57dc:	61 5e       	subi	r22, 0xE1	; 225
    57de:	74 4f       	sbci	r23, 0xF4	; 244
    57e0:	fb 01       	movw	r30, r22
    57e2:	80 83       	st	Z, r24
	MB_Frame_Sz[MB_N] = MB_Frame[MB_N][2]+5;
    57e4:	8b 5f       	subi	r24, 0xFB	; 251
    57e6:	f2 01       	movw	r30, r4
    57e8:	80 83       	st	Z, r24
	for (uint8_t i=0; i<Qt; i++) {
    57ea:	10 97       	sbiw	r26, 0x00	; 0
    57ec:	09 f4       	brne	.+2      	; 0x57f0 <MB_S_Timer_ISR+0x2e8>
    57ee:	22 c1       	rjmp	.+580    	; 0x5a34 <MB_S_Timer_ISR+0x52c>
    57f0:	60 e0       	ldi	r22, 0x00	; 0
    57f2:	20 e0       	ldi	r18, 0x00	; 0
    57f4:	30 e0       	ldi	r19, 0x00	; 0
    57f6:	80 e0       	ldi	r24, 0x00	; 0
    57f8:	90 e0       	ldi	r25, 0x00	; 0
		uint16_t j = StartAddr+i;
		uint8_t Byte=3+i/8, Bit=1<<i%8;
    57fa:	e1 e0       	ldi	r30, 0x01	; 1
    57fc:	4e 2e       	mov	r4, r30
    57fe:	51 2c       	mov	r5, r1
    5800:	10 c0       	rjmp	.+32     	; 0x5822 <MB_S_Timer_ISR+0x31a>
		if (Discr[j/8] &(1<<j%8))
			MB_Frame[MB_N][Byte] |=Bit;
    5802:	f7 01       	movw	r30, r14
    5804:	e4 0f       	add	r30, r20
    5806:	f1 1d       	adc	r31, r1
    5808:	e3 5e       	subi	r30, 0xE3	; 227
    580a:	f4 4f       	sbci	r31, 0xF4	; 244
    580c:	80 81       	ld	r24, Z
    580e:	85 2b       	or	r24, r21
    5810:	80 83       	st	Z, r24
	if (StartAddr+Qt>(MB_Frame[MB_N][1]==1?prw(&Modbus_Map[MB_N].Coil_Qt):prw(&Modbus_Map[MB_N].Input_Qt)))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
	MB_Frame[MB_N][2] = Qt/8+(Qt%8>0);
	MB_Frame_Sz[MB_N] = MB_Frame[MB_N][2]+5;
	for (uint8_t i=0; i<Qt; i++) {
    5812:	6f 5f       	subi	r22, 0xFF	; 255
    5814:	86 2f       	mov	r24, r22
    5816:	90 e0       	ldi	r25, 0x00	; 0
    5818:	9c 01       	movw	r18, r24
    581a:	8a 17       	cp	r24, r26
    581c:	9b 07       	cpc	r25, r27
    581e:	08 f0       	brcs	.+2      	; 0x5822 <MB_S_Timer_ISR+0x31a>
    5820:	09 c1       	rjmp	.+530    	; 0x5a34 <MB_S_Timer_ISR+0x52c>
		uint16_t j = StartAddr+i;
    5822:	28 0d       	add	r18, r8
    5824:	39 1d       	adc	r19, r9
		uint8_t Byte=3+i/8, Bit=1<<i%8;
    5826:	46 2f       	mov	r20, r22
    5828:	46 95       	lsr	r20
    582a:	46 95       	lsr	r20
    582c:	46 95       	lsr	r20
    582e:	4d 5f       	subi	r20, 0xFD	; 253
    5830:	87 70       	andi	r24, 0x07	; 7
    5832:	90 70       	andi	r25, 0x00	; 0
    5834:	f2 01       	movw	r30, r4
    5836:	02 c0       	rjmp	.+4      	; 0x583c <MB_S_Timer_ISR+0x334>
    5838:	ee 0f       	add	r30, r30
    583a:	ff 1f       	adc	r31, r31
    583c:	8a 95       	dec	r24
    583e:	e2 f7       	brpl	.-8      	; 0x5838 <MB_S_Timer_ISR+0x330>
    5840:	5e 2f       	mov	r21, r30
		if (Discr[j/8] &(1<<j%8))
    5842:	f9 01       	movw	r30, r18
    5844:	f6 95       	lsr	r31
    5846:	e7 95       	ror	r30
    5848:	f6 95       	lsr	r31
    584a:	e7 95       	ror	r30
    584c:	f6 95       	lsr	r31
    584e:	e7 95       	ror	r30
    5850:	e6 0d       	add	r30, r6
    5852:	f7 1d       	adc	r31, r7
    5854:	80 81       	ld	r24, Z
    5856:	90 e0       	ldi	r25, 0x00	; 0
    5858:	27 70       	andi	r18, 0x07	; 7
    585a:	30 70       	andi	r19, 0x00	; 0
    585c:	02 c0       	rjmp	.+4      	; 0x5862 <MB_S_Timer_ISR+0x35a>
    585e:	95 95       	asr	r25
    5860:	87 95       	ror	r24
    5862:	2a 95       	dec	r18
    5864:	e2 f7       	brpl	.-8      	; 0x585e <MB_S_Timer_ISR+0x356>
    5866:	80 fd       	sbrc	r24, 0
    5868:	cc cf       	rjmp	.-104    	; 0x5802 <MB_S_Timer_ISR+0x2fa>
			MB_Frame[MB_N][Byte] |=Bit;
		else
			MB_Frame[MB_N][Byte] &=~Bit;
    586a:	f7 01       	movw	r30, r14
    586c:	e4 0f       	add	r30, r20
    586e:	f1 1d       	adc	r31, r1
    5870:	e3 5e       	subi	r30, 0xE3	; 227
    5872:	f4 4f       	sbci	r31, 0xF4	; 244
    5874:	50 95       	com	r21
    5876:	80 81       	ld	r24, Z
    5878:	58 23       	and	r21, r24
    587a:	50 83       	st	Z, r21
    587c:	ca cf       	rjmp	.-108    	; 0x5812 <MB_S_Timer_ISR+0x30a>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_PresetSingle(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame_Sz[MB_N]!=8)
    587e:	68 85       	ldd	r22, Y+8	; 0x08
    5880:	79 85       	ldd	r23, Y+9	; 0x09
    5882:	61 50       	subi	r22, 0x01	; 1
    5884:	79 4f       	sbci	r23, 0xF9	; 249
    5886:	fb 01       	movw	r30, r22
    5888:	c0 80       	ld	r12, Z
    588a:	f8 e0       	ldi	r31, 0x08	; 8
    588c:	cf 16       	cp	r12, r31
    588e:	09 f0       	breq	.+2      	; 0x5892 <MB_S_Timer_ISR+0x38a>
    5890:	f3 ce       	rjmp	.-538    	; 0x5678 <MB_S_Timer_ISR+0x170>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    5892:	f3 01       	movw	r30, r6
    5894:	ea 5c       	subi	r30, 0xCA	; 202
    5896:	fc 4f       	sbci	r31, 0xFC	; 252
    5898:	25 91       	lpm	r18, Z+
    589a:	34 91       	lpm	r19, Z+
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+1>prw(&Modbus_Map[MB_N].HoldReg_Qt))
    589c:	c4 01       	movw	r24, r8
    589e:	01 96       	adiw	r24, 0x01	; 1
    58a0:	28 17       	cp	r18, r24
    58a2:	39 07       	cpc	r19, r25
    58a4:	08 f4       	brcc	.+2      	; 0x58a8 <MB_S_Timer_ISR+0x3a0>
    58a6:	02 c1       	rjmp	.+516    	; 0x5aac <MB_S_Timer_ISR+0x5a4>
		return MB_Frame[MB_N][2]=IllegAddr;
	MB_Frame_Sz[MB_N] = 8;
    58a8:	db 01       	movw	r26, r22
    58aa:	cc 92       	st	X, r12

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    58ac:	e8 85       	ldd	r30, Y+8	; 0x08
    58ae:	f9 85       	ldd	r31, Y+9	; 0x09
    58b0:	ee 0f       	add	r30, r30
    58b2:	ff 1f       	adc	r31, r31
    58b4:	ee 0f       	add	r30, r30
    58b6:	ff 1f       	adc	r31, r31
    58b8:	ee 0f       	add	r30, r30
    58ba:	ff 1f       	adc	r31, r31
    58bc:	ee 0f       	add	r30, r30
    58be:	ff 1f       	adc	r31, r31
    58c0:	ec 5c       	subi	r30, 0xCC	; 204
    58c2:	fc 4f       	sbci	r31, 0xFC	; 252
    58c4:	85 91       	lpm	r24, Z+
    58c6:	94 91       	lpm	r25, Z+
	*((uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+StartAddr) = MB_FrameReg(MB_N, 4);
    58c8:	88 0c       	add	r8, r8
    58ca:	99 1c       	adc	r9, r9
    58cc:	88 0e       	add	r8, r24
    58ce:	99 1e       	adc	r9, r25
    58d0:	28 85       	ldd	r18, Y+8	; 0x08
    58d2:	39 85       	ldd	r19, Y+9	; 0x09
    58d4:	f2 2f       	mov	r31, r18
    58d6:	ee 27       	eor	r30, r30
    58d8:	ef 5d       	subi	r30, 0xDF	; 223
    58da:	f4 4f       	sbci	r31, 0xF4	; 244
    58dc:	90 81       	ld	r25, Z
    58de:	80 e0       	ldi	r24, 0x00	; 0
    58e0:	da 01       	movw	r26, r20
    58e2:	15 96       	adiw	r26, 0x05	; 5
    58e4:	2c 91       	ld	r18, X
    58e6:	30 e0       	ldi	r19, 0x00	; 0
    58e8:	82 2b       	or	r24, r18
    58ea:	93 2b       	or	r25, r19
    58ec:	f4 01       	movw	r30, r8
    58ee:	91 83       	std	Z+1, r25	; 0x01
    58f0:	80 83       	st	Z, r24
    58f2:	90 e0       	ldi	r25, 0x00	; 0
    58f4:	c4 ce       	rjmp	.-632    	; 0x567e <MB_S_Timer_ISR+0x176>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_Preset(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][6]+9 || MB_Frame[MB_N][5]*2!=MB_Frame[MB_N][6])
    58f6:	fa 01       	movw	r30, r20
    58f8:	86 81       	ldd	r24, Z+6	; 0x06
    58fa:	28 2f       	mov	r18, r24
    58fc:	30 e0       	ldi	r19, 0x00	; 0
    58fe:	3f 83       	std	Y+7, r19	; 0x07
    5900:	2e 83       	std	Y+6, r18	; 0x06
    5902:	8f ef       	ldi	r24, 0xFF	; 255
    5904:	48 2e       	mov	r4, r24
    5906:	86 e0       	ldi	r24, 0x06	; 6
    5908:	58 2e       	mov	r5, r24
    590a:	88 85       	ldd	r24, Y+8	; 0x08
    590c:	99 85       	ldd	r25, Y+9	; 0x09
    590e:	48 0e       	add	r4, r24
    5910:	59 1e       	adc	r5, r25
    5912:	f2 01       	movw	r30, r4
    5914:	80 81       	ld	r24, Z
    5916:	90 e0       	ldi	r25, 0x00	; 0
    5918:	27 5f       	subi	r18, 0xF7	; 247
    591a:	3f 4f       	sbci	r19, 0xFF	; 255
    591c:	82 17       	cp	r24, r18
    591e:	93 07       	cpc	r25, r19
    5920:	99 f1       	breq	.+102    	; 0x5988 <MB_S_Timer_ISR+0x480>
		return MB_Frame[MB_N][2]=IllegData;
    5922:	66 0f       	add	r22, r22
    5924:	77 1f       	adc	r23, r23
    5926:	61 5e       	subi	r22, 0xE1	; 225
    5928:	74 4f       	sbci	r23, 0xF4	; 244
    592a:	83 e0       	ldi	r24, 0x03	; 3
    592c:	db 01       	movw	r26, r22
    592e:	8c 93       	st	X, r24
    5930:	93 e0       	ldi	r25, 0x03	; 3
    5932:	a5 ce       	rjmp	.-694    	; 0x567e <MB_S_Timer_ISR+0x176>
    5934:	28 85       	ldd	r18, Y+8	; 0x08
    5936:	39 85       	ldd	r19, Y+9	; 0x09
    5938:	f2 2f       	mov	r31, r18
    593a:	ee 27       	eor	r30, r30
    593c:	ef 5d       	subi	r30, 0xDF	; 223
    593e:	f4 4f       	sbci	r31, 0xF4	; 244
    5940:	e0 81       	ld	r30, Z
    5942:	da 01       	movw	r26, r20
    5944:	15 96       	adiw	r26, 0x05	; 5
    5946:	fc 91       	ld	r31, X
    5948:	15 97       	sbiw	r26, 0x05	; 5
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_Force(uint8_t MB_N, uint16_t StartAddr)
{
	uint16_t Qt = MB_FrameReg(MB_N, 4);
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][6]+9 || Qt/8+(Qt%8>0)!=MB_Frame[MB_N][6])
    594a:	16 96       	adiw	r26, 0x06	; 6
    594c:	2c 91       	ld	r18, X
    594e:	af ef       	ldi	r26, 0xFF	; 255
    5950:	4a 2e       	mov	r4, r26
    5952:	a6 e0       	ldi	r26, 0x06	; 6
    5954:	5a 2e       	mov	r5, r26
    5956:	88 85       	ldd	r24, Y+8	; 0x08
    5958:	99 85       	ldd	r25, Y+9	; 0x09
    595a:	48 0e       	add	r4, r24
    595c:	59 1e       	adc	r5, r25
    595e:	d2 01       	movw	r26, r4
    5960:	8c 91       	ld	r24, X
    5962:	90 e0       	ldi	r25, 0x00	; 0
    5964:	42 2f       	mov	r20, r18
    5966:	50 e0       	ldi	r21, 0x00	; 0
    5968:	9a 01       	movw	r18, r20
    596a:	27 5f       	subi	r18, 0xF7	; 247
    596c:	3f 4f       	sbci	r19, 0xFF	; 255
    596e:	82 17       	cp	r24, r18
    5970:	93 07       	cpc	r25, r19
    5972:	09 f4       	brne	.+2      	; 0x5976 <MB_S_Timer_ISR+0x46e>
    5974:	61 c0       	rjmp	.+194    	; 0x5a38 <MB_S_Timer_ISR+0x530>
		return MB_Frame[MB_N][2]=IllegData;
    5976:	66 0f       	add	r22, r22
    5978:	77 1f       	adc	r23, r23
    597a:	61 5e       	subi	r22, 0xE1	; 225
    597c:	74 4f       	sbci	r23, 0xF4	; 244
    597e:	83 e0       	ldi	r24, 0x03	; 3
    5980:	fb 01       	movw	r30, r22
    5982:	80 83       	st	Z, r24
    5984:	93 e0       	ldi	r25, 0x03	; 3
    5986:	7b ce       	rjmp	.-778    	; 0x567e <MB_S_Timer_ISR+0x176>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_Preset(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][6]+9 || MB_Frame[MB_N][5]*2!=MB_Frame[MB_N][6])
    5988:	9a 01       	movw	r18, r20
    598a:	2b 5f       	subi	r18, 0xFB	; 251
    598c:	3f 4f       	sbci	r19, 0xFF	; 255
    598e:	3c 83       	std	Y+4, r19	; 0x04
    5990:	2b 83       	std	Y+3, r18	; 0x03
    5992:	fa 01       	movw	r30, r20
    5994:	c5 80       	ldd	r12, Z+5	; 0x05
    5996:	2c 2d       	mov	r18, r12
    5998:	30 e0       	ldi	r19, 0x00	; 0
    599a:	c9 01       	movw	r24, r18
    599c:	88 0f       	add	r24, r24
    599e:	99 1f       	adc	r25, r25
    59a0:	ee 81       	ldd	r30, Y+6	; 0x06
    59a2:	ff 81       	ldd	r31, Y+7	; 0x07
    59a4:	e8 17       	cp	r30, r24
    59a6:	f9 07       	cpc	r31, r25
    59a8:	09 f0       	breq	.+2      	; 0x59ac <MB_S_Timer_ISR+0x4a4>
    59aa:	bb cf       	rjmp	.-138    	; 0x5922 <MB_S_Timer_ISR+0x41a>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    59ac:	f3 01       	movw	r30, r6
    59ae:	ea 5c       	subi	r30, 0xCA	; 202
    59b0:	fc 4f       	sbci	r31, 0xFC	; 252
    59b2:	85 91       	lpm	r24, Z+
    59b4:	94 91       	lpm	r25, Z+
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+MB_Frame[MB_N][5]>prw(&Modbus_Map[MB_N].HoldReg_Qt))
    59b6:	28 0d       	add	r18, r8
    59b8:	39 1d       	adc	r19, r9
    59ba:	82 17       	cp	r24, r18
    59bc:	93 07       	cpc	r25, r19
    59be:	08 f4       	brcc	.+2      	; 0x59c2 <MB_S_Timer_ISR+0x4ba>
    59c0:	75 c0       	rjmp	.+234    	; 0x5aac <MB_S_Timer_ISR+0x5a4>
		return MB_Frame[MB_N][2]=IllegAddr;
	MB_Frame_Sz[MB_N] = 8;
    59c2:	88 e0       	ldi	r24, 0x08	; 8
    59c4:	f2 01       	movw	r30, r4
    59c6:	80 83       	st	Z, r24

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    59c8:	e8 85       	ldd	r30, Y+8	; 0x08
    59ca:	f9 85       	ldd	r31, Y+9	; 0x09
    59cc:	ee 0f       	add	r30, r30
    59ce:	ff 1f       	adc	r31, r31
    59d0:	ee 0f       	add	r30, r30
    59d2:	ff 1f       	adc	r31, r31
    59d4:	ee 0f       	add	r30, r30
    59d6:	ff 1f       	adc	r31, r31
    59d8:	ee 0f       	add	r30, r30
    59da:	ff 1f       	adc	r31, r31
    59dc:	ec 5c       	subi	r30, 0xCC	; 204
    59de:	fc 4f       	sbci	r31, 0xFC	; 252
    59e0:	45 90       	lpm	r4, Z+
    59e2:	54 90       	lpm	r5, Z+
	uint16_t *HoldReg = prp(&Modbus_Map[MB_N].HoldReg);
	for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    59e4:	cc 20       	and	r12, r12
    59e6:	31 f1       	breq	.+76     	; 0x5a34 <MB_S_Timer_ISR+0x52c>
    59e8:	60 e0       	ldi	r22, 0x00	; 0
    59ea:	6b 80       	ldd	r6, Y+3	; 0x03
    59ec:	7c 80       	ldd	r7, Y+4	; 0x04
    59ee:	a6 2f       	mov	r26, r22
    59f0:	b0 e0       	ldi	r27, 0x00	; 0
    59f2:	cd 01       	movw	r24, r26
    59f4:	88 0f       	add	r24, r24
    59f6:	99 1f       	adc	r25, r25
    59f8:	89 5f       	subi	r24, 0xF9	; 249
    59fa:	28 2f       	mov	r18, r24
    59fc:	30 e0       	ldi	r19, 0x00	; 0
		uint8_t j = i*2;
		HoldReg[StartAddr+i] = MB_FrameReg(MB_N, 7+j);
    59fe:	a8 0d       	add	r26, r8
    5a00:	b9 1d       	adc	r27, r9
    5a02:	aa 0f       	add	r26, r26
    5a04:	bb 1f       	adc	r27, r27
    5a06:	a4 0d       	add	r26, r4
    5a08:	b5 1d       	adc	r27, r5
    5a0a:	fa 01       	movw	r30, r20
    5a0c:	e2 0f       	add	r30, r18
    5a0e:	f3 1f       	adc	r31, r19
    5a10:	81 81       	ldd	r24, Z+1	; 0x01
    5a12:	90 e0       	ldi	r25, 0x00	; 0
    5a14:	2e 0d       	add	r18, r14
    5a16:	3f 1d       	adc	r19, r15
    5a18:	23 5e       	subi	r18, 0xE3	; 227
    5a1a:	34 4f       	sbci	r19, 0xF4	; 244
    5a1c:	f9 01       	movw	r30, r18
    5a1e:	30 81       	ld	r19, Z
    5a20:	20 e0       	ldi	r18, 0x00	; 0
    5a22:	82 2b       	or	r24, r18
    5a24:	93 2b       	or	r25, r19
    5a26:	8d 93       	st	X+, r24
    5a28:	9c 93       	st	X, r25
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+MB_Frame[MB_N][5]>prw(&Modbus_Map[MB_N].HoldReg_Qt))
		return MB_Frame[MB_N][2]=IllegAddr;
	MB_Frame_Sz[MB_N] = 8;
	uint16_t *HoldReg = prp(&Modbus_Map[MB_N].HoldReg);
	for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    5a2a:	6f 5f       	subi	r22, 0xFF	; 255
    5a2c:	d3 01       	movw	r26, r6
    5a2e:	8c 91       	ld	r24, X
    5a30:	68 17       	cp	r22, r24
    5a32:	e8 f2       	brcs	.-70     	; 0x59ee <MB_S_Timer_ISR+0x4e6>
		break;
	case 0x10:
		Err = MB_S_Preset(MB_N, StartAddr);
		break;
	default:
		Err = MB_Frame[MB_N][2] = IllegFunc;
    5a34:	90 e0       	ldi	r25, 0x00	; 0
    5a36:	23 ce       	rjmp	.-954    	; 0x567e <MB_S_Timer_ISR+0x176>
    5a38:	9e 2f       	mov	r25, r30
    5a3a:	80 e0       	ldi	r24, 0x00	; 0
    5a3c:	af 2f       	mov	r26, r31
    5a3e:	b0 e0       	ldi	r27, 0x00	; 0
    5a40:	a8 2b       	or	r26, r24
    5a42:	b9 2b       	or	r27, r25
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_Force(uint8_t MB_N, uint16_t StartAddr)
{
	uint16_t Qt = MB_FrameReg(MB_N, 4);
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][6]+9 || Qt/8+(Qt%8>0)!=MB_Frame[MB_N][6])
    5a44:	20 e0       	ldi	r18, 0x00	; 0
    5a46:	30 e0       	ldi	r19, 0x00	; 0
    5a48:	cd 01       	movw	r24, r26
    5a4a:	87 70       	andi	r24, 0x07	; 7
    5a4c:	90 70       	andi	r25, 0x00	; 0
    5a4e:	89 2b       	or	r24, r25
    5a50:	11 f0       	breq	.+4      	; 0x5a56 <MB_S_Timer_ISR+0x54e>
    5a52:	21 e0       	ldi	r18, 0x01	; 1
    5a54:	30 e0       	ldi	r19, 0x00	; 0
    5a56:	cd 01       	movw	r24, r26
    5a58:	96 95       	lsr	r25
    5a5a:	87 95       	ror	r24
    5a5c:	96 95       	lsr	r25
    5a5e:	87 95       	ror	r24
    5a60:	96 95       	lsr	r25
    5a62:	87 95       	ror	r24
    5a64:	28 0f       	add	r18, r24
    5a66:	39 1f       	adc	r19, r25
    5a68:	24 17       	cp	r18, r20
    5a6a:	35 07       	cpc	r19, r21
    5a6c:	09 f0       	breq	.+2      	; 0x5a70 <MB_S_Timer_ISR+0x568>
    5a6e:	83 cf       	rjmp	.-250    	; 0x5976 <MB_S_Timer_ISR+0x46e>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    5a70:	e8 85       	ldd	r30, Y+8	; 0x08
    5a72:	f9 85       	ldd	r31, Y+9	; 0x09
    5a74:	ee 0f       	add	r30, r30
    5a76:	ff 1f       	adc	r31, r31
    5a78:	ee 0f       	add	r30, r30
    5a7a:	ff 1f       	adc	r31, r31
    5a7c:	ee 0f       	add	r30, r30
    5a7e:	ff 1f       	adc	r31, r31
    5a80:	ee 0f       	add	r30, r30
    5a82:	ff 1f       	adc	r31, r31
    5a84:	e2 5d       	subi	r30, 0xD2	; 210
    5a86:	fc 4f       	sbci	r31, 0xFC	; 252
    5a88:	25 91       	lpm	r18, Z+
    5a8a:	34 91       	lpm	r19, Z+
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+Qt > prw(&Modbus_Map[MB_N].Coil_Qt))
    5a8c:	cd 01       	movw	r24, r26
    5a8e:	88 0d       	add	r24, r8
    5a90:	99 1d       	adc	r25, r9
    5a92:	28 17       	cp	r18, r24
    5a94:	39 07       	cpc	r19, r25
    5a96:	08 f0       	brcs	.+2      	; 0x5a9a <MB_S_Timer_ISR+0x592>
    5a98:	5d c0       	rjmp	.+186    	; 0x5b54 <MB_S_Timer_ISR+0x64c>
		return MB_Frame[MB_N][2]=IllegAddr;
    5a9a:	66 0f       	add	r22, r22
    5a9c:	77 1f       	adc	r23, r23
    5a9e:	61 5e       	subi	r22, 0xE1	; 225
    5aa0:	74 4f       	sbci	r23, 0xF4	; 244
    5aa2:	82 e0       	ldi	r24, 0x02	; 2
    5aa4:	db 01       	movw	r26, r22
    5aa6:	8c 93       	st	X, r24
    5aa8:	92 e0       	ldi	r25, 0x02	; 2
    5aaa:	e9 cd       	rjmp	.-1070   	; 0x567e <MB_S_Timer_ISR+0x176>
MB_S_Preset(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][6]+9 || MB_Frame[MB_N][5]*2!=MB_Frame[MB_N][6])
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+MB_Frame[MB_N][5]>prw(&Modbus_Map[MB_N].HoldReg_Qt))
		return MB_Frame[MB_N][2]=IllegAddr;
    5aac:	82 e0       	ldi	r24, 0x02	; 2
    5aae:	8c 93       	st	X, r24
    5ab0:	92 e0       	ldi	r25, 0x02	; 2
    5ab2:	e5 cd       	rjmp	.-1078   	; 0x567e <MB_S_Timer_ISR+0x176>
	if (MB_Frame[MB_N][0]==0)
		return 0xFF;
	if (MB_Frame_Sz[MB_N]!=8)
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+MB_Frame[MB_N][5]>(MB_Frame[MB_N][1]==3?prw(&Modbus_Map[MB_N].HoldReg_Qt):prw(&Modbus_Map[MB_N].InReg_Qt)))
		return MB_Frame[MB_N][2]=IllegAddr;
    5ab4:	66 0f       	add	r22, r22
    5ab6:	77 1f       	adc	r23, r23
    5ab8:	61 5e       	subi	r22, 0xE1	; 225
    5aba:	74 4f       	sbci	r23, 0xF4	; 244
    5abc:	82 e0       	ldi	r24, 0x02	; 2
    5abe:	fb 01       	movw	r30, r22
    5ac0:	80 83       	st	Z, r24
    5ac2:	92 e0       	ldi	r25, 0x02	; 2
    5ac4:	dc cd       	rjmp	.-1096   	; 0x567e <MB_S_Timer_ISR+0x176>
{
	if (MB_Frame[MB_N][0]==0)
		return 0xFF;
	if (MB_Frame_Sz[MB_N]!=8)
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+MB_Frame[MB_N][5]>(MB_Frame[MB_N][1]==3?prw(&Modbus_Map[MB_N].HoldReg_Qt):prw(&Modbus_Map[MB_N].InReg_Qt)))
    5ac6:	da 01       	movw	r26, r20
    5ac8:	15 96       	adiw	r26, 0x05	; 5
    5aca:	8c 91       	ld	r24, X
    5acc:	33 30       	cpi	r19, 0x03	; 3
    5ace:	09 f4       	brne	.+2      	; 0x5ad2 <MB_S_Timer_ISR+0x5ca>
    5ad0:	ab c0       	rjmp	.+342    	; 0x5c28 <MB_S_Timer_ISR+0x720>
    5ad2:	f3 01       	movw	r30, r6
    5ad4:	e6 5c       	subi	r30, 0xC6	; 198
    5ad6:	fc 4f       	sbci	r31, 0xFC	; 252
    5ad8:	45 91       	lpm	r20, Z+
    5ada:	54 91       	lpm	r21, Z+
    5adc:	a8 2f       	mov	r26, r24
    5ade:	b0 e0       	ldi	r27, 0x00	; 0
    5ae0:	c4 01       	movw	r24, r8
    5ae2:	8a 0f       	add	r24, r26
    5ae4:	9b 1f       	adc	r25, r27
    5ae6:	48 17       	cp	r20, r24
    5ae8:	59 07       	cpc	r21, r25
    5aea:	20 f3       	brcs	.-56     	; 0x5ab4 <MB_S_Timer_ISR+0x5ac>
		return MB_Frame[MB_N][2]=IllegAddr;
	uint16_t *Reg = (uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg)) + StartAddr;
    5aec:	33 30       	cpi	r19, 0x03	; 3
    5aee:	09 f4       	brne	.+2      	; 0x5af2 <MB_S_Timer_ISR+0x5ea>
    5af0:	a9 c0       	rjmp	.+338    	; 0x5c44 <MB_S_Timer_ISR+0x73c>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5af2:	f3 01       	movw	r30, r6
    5af4:	e8 5c       	subi	r30, 0xC8	; 200
    5af6:	fc 4f       	sbci	r31, 0xFC	; 252
    5af8:	85 91       	lpm	r24, Z+
    5afa:	94 91       	lpm	r25, Z+
    5afc:	94 01       	movw	r18, r8
    5afe:	22 0f       	add	r18, r18
    5b00:	33 1f       	adc	r19, r19
    5b02:	28 0f       	add	r18, r24
    5b04:	39 1f       	adc	r19, r25
	MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][2] = MB_Frame[MB_N][5]*2) + 5;
    5b06:	cd 01       	movw	r24, r26
    5b08:	88 0f       	add	r24, r24
    5b0a:	99 1f       	adc	r25, r25
    5b0c:	66 0f       	add	r22, r22
    5b0e:	77 1f       	adc	r23, r23
    5b10:	61 5e       	subi	r22, 0xE1	; 225
    5b12:	74 4f       	sbci	r23, 0xF4	; 244
    5b14:	db 01       	movw	r26, r22
    5b16:	8c 93       	st	X, r24
    5b18:	8b 5f       	subi	r24, 0xFB	; 251
    5b1a:	f2 01       	movw	r30, r4
    5b1c:	80 83       	st	Z, r24
	uint8_t Qt = MB_Frame[MB_N][5];
    5b1e:	f7 01       	movw	r30, r14
    5b20:	e3 5e       	subi	r30, 0xE3	; 227
    5b22:	f4 4f       	sbci	r31, 0xF4	; 244
    5b24:	45 81       	ldd	r20, Z+5	; 0x05
	for (uint8_t i=0; i<Qt; i++) {
    5b26:	44 23       	and	r20, r20
    5b28:	09 f4       	brne	.+2      	; 0x5b2c <MB_S_Timer_ISR+0x624>
    5b2a:	84 cf       	rjmp	.-248    	; 0x5a34 <MB_S_Timer_ISR+0x52c>
    5b2c:	d9 01       	movw	r26, r18
    5b2e:	90 e0       	ldi	r25, 0x00	; 0
		uint8_t j = i*2;
		MB_Frame[MB_N][3+j] = Reg[i]>>8;
    5b30:	9f 01       	movw	r18, r30
    5b32:	89 2f       	mov	r24, r25
    5b34:	88 0f       	add	r24, r24
    5b36:	f9 01       	movw	r30, r18
    5b38:	e8 0f       	add	r30, r24
    5b3a:	f1 1d       	adc	r31, r1
    5b3c:	11 96       	adiw	r26, 0x01	; 1
    5b3e:	8c 91       	ld	r24, X
    5b40:	11 97       	sbiw	r26, 0x01	; 1
    5b42:	83 83       	std	Z+3, r24	; 0x03
		MB_Frame[MB_N][4+j] = Reg[i];
    5b44:	8c 91       	ld	r24, X
    5b46:	84 83       	std	Z+4, r24	; 0x04
	if (StartAddr+MB_Frame[MB_N][5]>(MB_Frame[MB_N][1]==3?prw(&Modbus_Map[MB_N].HoldReg_Qt):prw(&Modbus_Map[MB_N].InReg_Qt)))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint16_t *Reg = (uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg)) + StartAddr;
	MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][2] = MB_Frame[MB_N][5]*2) + 5;
	uint8_t Qt = MB_Frame[MB_N][5];
	for (uint8_t i=0; i<Qt; i++) {
    5b48:	9f 5f       	subi	r25, 0xFF	; 255
    5b4a:	12 96       	adiw	r26, 0x02	; 2
    5b4c:	94 17       	cp	r25, r20
    5b4e:	88 f3       	brcs	.-30     	; 0x5b32 <MB_S_Timer_ISR+0x62a>
		break;
	case 0x10:
		Err = MB_S_Preset(MB_N, StartAddr);
		break;
	default:
		Err = MB_Frame[MB_N][2] = IllegFunc;
    5b50:	90 e0       	ldi	r25, 0x00	; 0
    5b52:	95 cd       	rjmp	.-1238   	; 0x567e <MB_S_Timer_ISR+0x176>
    5b54:	93 01       	movw	r18, r6
    5b56:	24 5d       	subi	r18, 0xD4	; 212
    5b58:	3c 4f       	sbci	r19, 0xFC	; 252
    5b5a:	f9 01       	movw	r30, r18
    5b5c:	85 91       	lpm	r24, Z+
    5b5e:	94 91       	lpm	r25, Z+
    5b60:	9a 83       	std	Y+2, r25	; 0x02
    5b62:	89 83       	std	Y+1, r24	; 0x01
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][6]+9 || Qt/8+(Qt%8>0)!=MB_Frame[MB_N][6])
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+Qt > prw(&Modbus_Map[MB_N].Coil_Qt))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Coil = prp(&Modbus_Map[MB_N].Coil);
	MB_Frame_Sz[MB_N] = 8;
    5b64:	88 e0       	ldi	r24, 0x08	; 8
    5b66:	f2 01       	movw	r30, r4
    5b68:	80 83       	st	Z, r24
	for (uint8_t i=0; i<Qt; i++) {
    5b6a:	10 97       	sbiw	r26, 0x00	; 0
    5b6c:	09 f4       	brne	.+2      	; 0x5b70 <MB_S_Timer_ISR+0x668>
    5b6e:	62 cf       	rjmp	.-316    	; 0x5a34 <MB_S_Timer_ISR+0x52c>
    5b70:	cc 24       	eor	r12, r12
    5b72:	80 e0       	ldi	r24, 0x00	; 0
    5b74:	90 e0       	ldi	r25, 0x00	; 0
    5b76:	20 e0       	ldi	r18, 0x00	; 0
    5b78:	30 e0       	ldi	r19, 0x00	; 0
		uint16_t j = StartAddr+i;
		uint16_t Byte=j/8, Bit=1<<j%8;
    5b7a:	e1 e0       	ldi	r30, 0x01	; 1
    5b7c:	4e 2e       	mov	r4, r30
    5b7e:	51 2c       	mov	r5, r1
		if (MB_Frame[MB_N][7+i/8] &(1<<i%8))
    5b80:	7d e1       	ldi	r23, 0x1D	; 29
    5b82:	67 2e       	mov	r6, r23
    5b84:	7b e0       	ldi	r23, 0x0B	; 11
    5b86:	77 2e       	mov	r7, r23
    5b88:	6e 0c       	add	r6, r14
    5b8a:	7f 1c       	adc	r7, r15
    5b8c:	10 c0       	rjmp	.+32     	; 0x5bae <MB_S_Timer_ISR+0x6a6>
			Coil[Byte] |=Bit;
    5b8e:	29 81       	ldd	r18, Y+1	; 0x01
    5b90:	3a 81       	ldd	r19, Y+2	; 0x02
    5b92:	24 0f       	add	r18, r20
    5b94:	35 1f       	adc	r19, r21
    5b96:	f9 01       	movw	r30, r18
    5b98:	80 81       	ld	r24, Z
    5b9a:	86 2b       	or	r24, r22
    5b9c:	80 83       	st	Z, r24
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+Qt > prw(&Modbus_Map[MB_N].Coil_Qt))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Coil = prp(&Modbus_Map[MB_N].Coil);
	MB_Frame_Sz[MB_N] = 8;
	for (uint8_t i=0; i<Qt; i++) {
    5b9e:	c3 94       	inc	r12
    5ba0:	2c 2d       	mov	r18, r12
    5ba2:	30 e0       	ldi	r19, 0x00	; 0
    5ba4:	c9 01       	movw	r24, r18
    5ba6:	2a 17       	cp	r18, r26
    5ba8:	3b 07       	cpc	r19, r27
    5baa:	08 f0       	brcs	.+2      	; 0x5bae <MB_S_Timer_ISR+0x6a6>
    5bac:	43 cf       	rjmp	.-378    	; 0x5a34 <MB_S_Timer_ISR+0x52c>
		uint16_t j = StartAddr+i;
    5bae:	88 0d       	add	r24, r8
    5bb0:	99 1d       	adc	r25, r9
		uint16_t Byte=j/8, Bit=1<<j%8;
    5bb2:	ac 01       	movw	r20, r24
    5bb4:	56 95       	lsr	r21
    5bb6:	47 95       	ror	r20
    5bb8:	56 95       	lsr	r21
    5bba:	47 95       	ror	r20
    5bbc:	56 95       	lsr	r21
    5bbe:	47 95       	ror	r20
    5bc0:	87 70       	andi	r24, 0x07	; 7
    5bc2:	90 70       	andi	r25, 0x00	; 0
    5bc4:	b2 01       	movw	r22, r4
    5bc6:	02 c0       	rjmp	.+4      	; 0x5bcc <MB_S_Timer_ISR+0x6c4>
    5bc8:	66 0f       	add	r22, r22
    5bca:	77 1f       	adc	r23, r23
    5bcc:	8a 95       	dec	r24
    5bce:	e2 f7       	brpl	.-8      	; 0x5bc8 <MB_S_Timer_ISR+0x6c0>
		if (MB_Frame[MB_N][7+i/8] &(1<<i%8))
    5bd0:	8c 2d       	mov	r24, r12
    5bd2:	86 95       	lsr	r24
    5bd4:	86 95       	lsr	r24
    5bd6:	86 95       	lsr	r24
    5bd8:	f3 01       	movw	r30, r6
    5bda:	e8 0f       	add	r30, r24
    5bdc:	f1 1d       	adc	r31, r1
    5bde:	87 81       	ldd	r24, Z+7	; 0x07
    5be0:	90 e0       	ldi	r25, 0x00	; 0
    5be2:	27 70       	andi	r18, 0x07	; 7
    5be4:	30 70       	andi	r19, 0x00	; 0
    5be6:	02 c0       	rjmp	.+4      	; 0x5bec <MB_S_Timer_ISR+0x6e4>
    5be8:	95 95       	asr	r25
    5bea:	87 95       	ror	r24
    5bec:	2a 95       	dec	r18
    5bee:	e2 f7       	brpl	.-8      	; 0x5be8 <MB_S_Timer_ISR+0x6e0>
    5bf0:	80 fd       	sbrc	r24, 0
    5bf2:	cd cf       	rjmp	.-102    	; 0x5b8e <MB_S_Timer_ISR+0x686>
			Coil[Byte] |=Bit;
		else
			Coil[Byte] &=~Bit;
    5bf4:	29 81       	ldd	r18, Y+1	; 0x01
    5bf6:	3a 81       	ldd	r19, Y+2	; 0x02
    5bf8:	24 0f       	add	r18, r20
    5bfa:	35 1f       	adc	r19, r21
    5bfc:	96 2f       	mov	r25, r22
    5bfe:	90 95       	com	r25
    5c00:	f9 01       	movw	r30, r18
    5c02:	80 81       	ld	r24, Z
    5c04:	89 23       	and	r24, r25
    5c06:	80 83       	st	Z, r24
    5c08:	ca cf       	rjmp	.-108    	; 0x5b9e <MB_S_Timer_ISR+0x696>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    5c0a:	e8 85       	ldd	r30, Y+8	; 0x08
    5c0c:	f9 85       	ldd	r31, Y+9	; 0x09
    5c0e:	ee 0f       	add	r30, r30
    5c10:	ff 1f       	adc	r31, r31
    5c12:	ee 0f       	add	r30, r30
    5c14:	ff 1f       	adc	r31, r31
    5c16:	ee 0f       	add	r30, r30
    5c18:	ff 1f       	adc	r31, r31
    5c1a:	ee 0f       	add	r30, r30
    5c1c:	ff 1f       	adc	r31, r31
    5c1e:	e2 5d       	subi	r30, 0xD2	; 210
    5c20:	fc 4f       	sbci	r31, 0xFC	; 252
    5c22:	45 91       	lpm	r20, Z+
    5c24:	54 91       	lpm	r21, Z+
    5c26:	b2 cd       	rjmp	.-1180   	; 0x578c <MB_S_Timer_ISR+0x284>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5c28:	f3 01       	movw	r30, r6
    5c2a:	ea 5c       	subi	r30, 0xCA	; 202
    5c2c:	fc 4f       	sbci	r31, 0xFC	; 252
    5c2e:	45 91       	lpm	r20, Z+
    5c30:	54 91       	lpm	r21, Z+
    5c32:	54 cf       	rjmp	.-344    	; 0x5adc <MB_S_Timer_ISR+0x5d4>
    5c34:	f3 01       	movw	r30, r6
    5c36:	e4 5d       	subi	r30, 0xD4	; 212
    5c38:	fc 4f       	sbci	r31, 0xFC	; 252
    5c3a:	85 91       	lpm	r24, Z+
    5c3c:	94 91       	lpm	r25, Z+
    5c3e:	28 2f       	mov	r18, r24
    5c40:	89 2f       	mov	r24, r25
    5c42:	b9 cd       	rjmp	.-1166   	; 0x57b6 <MB_S_Timer_ISR+0x2ae>
    5c44:	e8 85       	ldd	r30, Y+8	; 0x08
    5c46:	f9 85       	ldd	r31, Y+9	; 0x09
    5c48:	ee 0f       	add	r30, r30
    5c4a:	ff 1f       	adc	r31, r31
    5c4c:	ee 0f       	add	r30, r30
    5c4e:	ff 1f       	adc	r31, r31
    5c50:	ee 0f       	add	r30, r30
    5c52:	ff 1f       	adc	r31, r31
    5c54:	ee 0f       	add	r30, r30
    5c56:	ff 1f       	adc	r31, r31
    5c58:	ec 5c       	subi	r30, 0xCC	; 204
    5c5a:	fc 4f       	sbci	r31, 0xFC	; 252
    5c5c:	85 91       	lpm	r24, Z+
    5c5e:	94 91       	lpm	r25, Z+
    5c60:	4d cf       	rjmp	.-358    	; 0x5afc <MB_S_Timer_ISR+0x5f4>

00005c62 <MB_S_Tx>:
    5c62:	94 e1       	ldi	r25, 0x14	; 20
    5c64:	89 9f       	mul	r24, r25
    5c66:	c0 01       	movw	r24, r0
    5c68:	11 24       	eor	r1, r1
    5c6a:	81 5e       	subi	r24, 0xE1	; 225
    5c6c:	93 4d       	sbci	r25, 0xD3	; 211
    5c6e:	fc 01       	movw	r30, r24
    5c70:	25 91       	lpm	r18, Z+
    5c72:	34 91       	lpm	r19, Z+

// ~~~~~~~~~~~~~~~~~~
void
MB_S_Tx(uint8_t MB_N)
{
	USART_Func(MB_N, LED);
    5c74:	f9 01       	movw	r30, r18
    5c76:	19 95       	eicall
}
    5c78:	08 95       	ret

00005c7a <MB_Slave_Off>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
MB_Slave_Off(uint8_t MB_N, uint8_t S_N)
{
    5c7a:	21 e0       	ldi	r18, 0x01	; 1
    5c7c:	30 e0       	ldi	r19, 0x00	; 0
    5c7e:	40 e0       	ldi	r20, 0x00	; 0
    5c80:	50 e0       	ldi	r21, 0x00	; 0
    5c82:	04 c0       	rjmp	.+8      	; 0x5c8c <MB_Slave_Off+0x12>
    5c84:	22 0f       	add	r18, r18
    5c86:	33 1f       	adc	r19, r19
    5c88:	44 1f       	adc	r20, r20
    5c8a:	55 1f       	adc	r21, r21
    5c8c:	6a 95       	dec	r22
    5c8e:	d2 f7       	brpl	.-12     	; 0x5c84 <MB_Slave_Off+0xa>
    5c90:	e8 2f       	mov	r30, r24
    5c92:	f0 e0       	ldi	r31, 0x00	; 0
    5c94:	ee 0f       	add	r30, r30
    5c96:	ff 1f       	adc	r31, r31
    5c98:	ee 0f       	add	r30, r30
    5c9a:	ff 1f       	adc	r31, r31
    5c9c:	e1 52       	subi	r30, 0x21	; 33
    5c9e:	f7 4f       	sbci	r31, 0xF7	; 247
    5ca0:	80 81       	ld	r24, Z
    5ca2:	91 81       	ldd	r25, Z+1	; 0x01
    5ca4:	a2 81       	ldd	r26, Z+2	; 0x02
    5ca6:	b3 81       	ldd	r27, Z+3	; 0x03
    5ca8:	28 23       	and	r18, r24
    5caa:	39 23       	and	r19, r25
    5cac:	4a 23       	and	r20, r26
    5cae:	5b 23       	and	r21, r27
	return SlaveOff[MB_N] &((uint32_t)1<<S_N);
}
    5cb0:	b9 01       	movw	r22, r18
    5cb2:	ca 01       	movw	r24, r20
    5cb4:	08 95       	ret

00005cb6 <GetReg>:
}

// ~~~~~~~~~~~~~~~~~
static uint16_t*
GetReg(uint8_t MB_N)
{
    5cb6:	98 2f       	mov	r25, r24
	return MB_SingleState[MB_N]!=MB_SingleExec?(uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+prw(&GetQuery(MB_N)->AllocAddr):MB_SingleQuery[MB_N].Buf;
    5cb8:	a8 2f       	mov	r26, r24
    5cba:	b0 e0       	ldi	r27, 0x00	; 0
    5cbc:	fd 01       	movw	r30, r26
    5cbe:	e9 55       	subi	r30, 0x59	; 89
    5cc0:	f9 4f       	sbci	r31, 0xF9	; 249
    5cc2:	80 81       	ld	r24, Z
    5cc4:	82 30       	cpi	r24, 0x02	; 2
    5cc6:	09 f4       	brne	.+2      	; 0x5cca <GetReg+0x14>
    5cc8:	39 c0       	rjmp	.+114    	; 0x5d3c <GetReg+0x86>
    5cca:	fd 01       	movw	r30, r26
    5ccc:	ee 0f       	add	r30, r30
    5cce:	ff 1f       	adc	r31, r31
    5cd0:	ee 0f       	add	r30, r30
    5cd2:	ff 1f       	adc	r31, r31
    5cd4:	ee 0f       	add	r30, r30
    5cd6:	ff 1f       	adc	r31, r31
    5cd8:	ee 0f       	add	r30, r30
    5cda:	ff 1f       	adc	r31, r31
    5cdc:	ec 5c       	subi	r30, 0xCC	; 204
    5cde:	fc 4f       	sbci	r31, 0xFC	; 252
    5ce0:	45 91       	lpm	r20, Z+
    5ce2:	54 91       	lpm	r21, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    5ce4:	83 e0       	ldi	r24, 0x03	; 3
    5ce6:	98 9f       	mul	r25, r24
    5ce8:	f0 01       	movw	r30, r0
    5cea:	11 24       	eor	r1, r1
    5cec:	e2 5c       	subi	r30, 0xC2	; 194
    5cee:	f6 4d       	sbci	r31, 0xD6	; 214
    5cf0:	25 91       	lpm	r18, Z+
    5cf2:	34 91       	lpm	r19, Z+
    5cf4:	fd 01       	movw	r30, r26
    5cf6:	e4 5b       	subi	r30, 0xB4	; 180
    5cf8:	f9 4f       	sbci	r31, 0xF9	; 249
    5cfa:	80 81       	ld	r24, Z
    5cfc:	90 e0       	ldi	r25, 0x00	; 0
    5cfe:	88 0f       	add	r24, r24
    5d00:	99 1f       	adc	r25, r25
    5d02:	88 0f       	add	r24, r24
    5d04:	99 1f       	adc	r25, r25
    5d06:	28 0f       	add	r18, r24
    5d08:	39 1f       	adc	r19, r25
    5d0a:	2f 5f       	subi	r18, 0xFF	; 255
    5d0c:	3f 4f       	sbci	r19, 0xFF	; 255
    5d0e:	f9 01       	movw	r30, r18
    5d10:	65 91       	lpm	r22, Z+
    5d12:	74 91       	lpm	r23, Z+
    5d14:	a3 5b       	subi	r26, 0xB3	; 179
    5d16:	b9 4f       	sbci	r27, 0xF9	; 249
    5d18:	8c 91       	ld	r24, X
    5d1a:	27 e0       	ldi	r18, 0x07	; 7
    5d1c:	82 9f       	mul	r24, r18
    5d1e:	c0 01       	movw	r24, r0
    5d20:	11 24       	eor	r1, r1
    5d22:	68 0f       	add	r22, r24
    5d24:	79 1f       	adc	r23, r25
    5d26:	6b 5f       	subi	r22, 0xFB	; 251
    5d28:	7f 4f       	sbci	r23, 0xFF	; 255
    5d2a:	fb 01       	movw	r30, r22
    5d2c:	85 91       	lpm	r24, Z+
    5d2e:	94 91       	lpm	r25, Z+
    5d30:	88 0f       	add	r24, r24
    5d32:	99 1f       	adc	r25, r25
    5d34:	48 0f       	add	r20, r24
    5d36:	59 1f       	adc	r21, r25
}
    5d38:	ca 01       	movw	r24, r20
    5d3a:	08 95       	ret

// ~~~~~~~~~~~~~~~~~
static uint16_t*
GetReg(uint8_t MB_N)
{
	return MB_SingleState[MB_N]!=MB_SingleExec?(uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+prw(&GetQuery(MB_N)->AllocAddr):MB_SingleQuery[MB_N].Buf;
    5d3c:	aa 0f       	add	r26, r26
    5d3e:	bb 1f       	adc	r27, r27
    5d40:	aa 0f       	add	r26, r26
    5d42:	bb 1f       	adc	r27, r27
    5d44:	aa 0f       	add	r26, r26
    5d46:	bb 1f       	adc	r27, r27
    5d48:	ae 52       	subi	r26, 0x2E	; 46
    5d4a:	bb 4f       	sbci	r27, 0xFB	; 251
    5d4c:	16 96       	adiw	r26, 0x06	; 6
    5d4e:	4d 91       	ld	r20, X+
    5d50:	5c 91       	ld	r21, X
    5d52:	17 97       	sbiw	r26, 0x07	; 7
}
    5d54:	ca 01       	movw	r24, r20
    5d56:	08 95       	ret

00005d58 <FormData>:

// ~~~~~~~~~~~~~~~~~~~
static void
FormData(uint8_t MB_N)
{
    5d58:	cf 92       	push	r12
    5d5a:	df 92       	push	r13
    5d5c:	ef 92       	push	r14
    5d5e:	ff 92       	push	r15
    5d60:	0f 93       	push	r16
    5d62:	1f 93       	push	r17
    5d64:	cf 93       	push	r28
    5d66:	df 93       	push	r29
    5d68:	e8 2e       	mov	r14, r24
	uint16_t Qt;
	uint16_t *Reg;
	switch (MB_Frame[MB_N][1]) {
    5d6a:	c8 2f       	mov	r28, r24
    5d6c:	d0 e0       	ldi	r29, 0x00	; 0
    5d6e:	7c 2f       	mov	r23, r28
    5d70:	66 27       	eor	r22, r22
    5d72:	8b 01       	movw	r16, r22
    5d74:	03 5e       	subi	r16, 0xE3	; 227
    5d76:	14 4f       	sbci	r17, 0xF4	; 244
    5d78:	f8 01       	movw	r30, r16
    5d7a:	81 81       	ldd	r24, Z+1	; 0x01
    5d7c:	86 30       	cpi	r24, 0x06	; 6
    5d7e:	09 f4       	brne	.+2      	; 0x5d82 <FormData+0x2a>
    5d80:	4b c0       	rjmp	.+150    	; 0x5e18 <FormData+0xc0>
    5d82:	87 30       	cpi	r24, 0x07	; 7
    5d84:	88 f0       	brcs	.+34     	; 0x5da8 <FormData+0x50>
    5d86:	8f 30       	cpi	r24, 0x0F	; 15
    5d88:	09 f4       	brne	.+2      	; 0x5d8c <FormData+0x34>
    5d8a:	5b c0       	rjmp	.+182    	; 0x5e42 <FormData+0xea>
    5d8c:	80 31       	cpi	r24, 0x10	; 16
    5d8e:	a1 f0       	breq	.+40     	; 0x5db8 <FormData+0x60>
			MB_Frame[MB_N][7+j] = Reg[i]>>8;
			MB_Frame[MB_N][8+j] = Reg[i];
		}
		break;
	}
	SetCRC_MB(MB_N);
    5d90:	8e 2d       	mov	r24, r14
    5d92:	0e 94 2b 2a 	call	0x5456	; 0x5456 <SetCRC_MB>
}
    5d96:	df 91       	pop	r29
    5d98:	cf 91       	pop	r28
    5d9a:	1f 91       	pop	r17
    5d9c:	0f 91       	pop	r16
    5d9e:	ff 90       	pop	r15
    5da0:	ef 90       	pop	r14
    5da2:	df 90       	pop	r13
    5da4:	cf 90       	pop	r12
    5da6:	08 95       	ret
static void
FormData(uint8_t MB_N)
{
	uint16_t Qt;
	uint16_t *Reg;
	switch (MB_Frame[MB_N][1]) {
    5da8:	81 50       	subi	r24, 0x01	; 1
    5daa:	84 30       	cpi	r24, 0x04	; 4
    5dac:	88 f7       	brcc	.-30     	; 0x5d90 <FormData+0x38>
	case 1: case 2: case 3: case 4:
		MB_Frame_Sz[MB_N] = 8;
    5dae:	c1 50       	subi	r28, 0x01	; 1
    5db0:	d9 4f       	sbci	r29, 0xF9	; 249
    5db2:	88 e0       	ldi	r24, 0x08	; 8
    5db4:	88 83       	st	Y, r24
    5db6:	ec cf       	rjmp	.-40     	; 0x5d90 <FormData+0x38>
			else
				MB_Frame[MB_N][Byte] &=~Bit;
		}
		break;
	case 0x10:
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = MB_Frame[MB_N][5]*2) + 9;
    5db8:	55 e0       	ldi	r21, 0x05	; 5
    5dba:	c5 2e       	mov	r12, r21
    5dbc:	d1 2c       	mov	r13, r1
    5dbe:	c0 0e       	add	r12, r16
    5dc0:	d1 1e       	adc	r13, r17
    5dc2:	f8 01       	movw	r30, r16
    5dc4:	85 81       	ldd	r24, Z+5	; 0x05
    5dc6:	90 e0       	ldi	r25, 0x00	; 0
    5dc8:	88 0f       	add	r24, r24
    5dca:	99 1f       	adc	r25, r25
    5dcc:	86 83       	std	Z+6, r24	; 0x06
    5dce:	c1 50       	subi	r28, 0x01	; 1
    5dd0:	d9 4f       	sbci	r29, 0xF9	; 249
    5dd2:	87 5f       	subi	r24, 0xF7	; 247
    5dd4:	88 83       	st	Y, r24
		Reg = GetReg(MB_N);
    5dd6:	8e 2d       	mov	r24, r14
    5dd8:	0e 94 5b 2e 	call	0x5cb6	; 0x5cb6 <GetReg>
    5ddc:	bc 01       	movw	r22, r24
		for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    5dde:	f8 01       	movw	r30, r16
    5de0:	85 81       	ldd	r24, Z+5	; 0x05
    5de2:	88 23       	and	r24, r24
    5de4:	a9 f2       	breq	.-86     	; 0x5d90 <FormData+0x38>
    5de6:	20 e0       	ldi	r18, 0x00	; 0
			uint8_t j = i*2;
			MB_Frame[MB_N][7+j] = Reg[i]>>8;
    5de8:	a8 01       	movw	r20, r16
		}
		break;
	case 0x10:
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = MB_Frame[MB_N][5]*2) + 9;
		Reg = GetReg(MB_N);
		for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    5dea:	e6 01       	movw	r28, r12
			uint8_t j = i*2;
			MB_Frame[MB_N][7+j] = Reg[i]>>8;
    5dec:	82 2f       	mov	r24, r18
    5dee:	90 e0       	ldi	r25, 0x00	; 0
    5df0:	88 0f       	add	r24, r24
    5df2:	99 1f       	adc	r25, r25
    5df4:	fb 01       	movw	r30, r22
    5df6:	e8 0f       	add	r30, r24
    5df8:	f9 1f       	adc	r31, r25
    5dfa:	da 01       	movw	r26, r20
    5dfc:	a8 0f       	add	r26, r24
    5dfe:	b1 1d       	adc	r27, r1
    5e00:	81 81       	ldd	r24, Z+1	; 0x01
    5e02:	17 96       	adiw	r26, 0x07	; 7
    5e04:	8c 93       	st	X, r24
    5e06:	17 97       	sbiw	r26, 0x07	; 7
			MB_Frame[MB_N][8+j] = Reg[i];
    5e08:	80 81       	ld	r24, Z
    5e0a:	18 96       	adiw	r26, 0x08	; 8
    5e0c:	8c 93       	st	X, r24
		}
		break;
	case 0x10:
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = MB_Frame[MB_N][5]*2) + 9;
		Reg = GetReg(MB_N);
		for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    5e0e:	2f 5f       	subi	r18, 0xFF	; 255
    5e10:	88 81       	ld	r24, Y
    5e12:	28 17       	cp	r18, r24
    5e14:	58 f3       	brcs	.-42     	; 0x5dec <FormData+0x94>
    5e16:	bc cf       	rjmp	.-136    	; 0x5d90 <FormData+0x38>
		MB_Frame_Sz[MB_N] = 8;
		MB_Frame[MB_N][5] = 0;
		break;
	*/
	case 6:
		MB_Frame_Sz[MB_N] = 8;
    5e18:	fe 01       	movw	r30, r28
    5e1a:	e1 50       	subi	r30, 0x01	; 1
    5e1c:	f9 4f       	sbci	r31, 0xF9	; 249
    5e1e:	88 e0       	ldi	r24, 0x08	; 8
    5e20:	80 83       	st	Z, r24
		Reg = GetReg(MB_N);
    5e22:	8e 2d       	mov	r24, r14
    5e24:	0e 94 5b 2e 	call	0x5cb6	; 0x5cb6 <GetReg>
    5e28:	dc 01       	movw	r26, r24
		MB_Frame[MB_N][4] = *Reg>>8;
    5e2a:	fc 2f       	mov	r31, r28
    5e2c:	ee 27       	eor	r30, r30
    5e2e:	ef 5d       	subi	r30, 0xDF	; 223
    5e30:	f4 4f       	sbci	r31, 0xF4	; 244
    5e32:	11 96       	adiw	r26, 0x01	; 1
    5e34:	8c 91       	ld	r24, X
    5e36:	11 97       	sbiw	r26, 0x01	; 1
    5e38:	80 83       	st	Z, r24
		MB_Frame[MB_N][5] = *Reg;
    5e3a:	8c 91       	ld	r24, X
    5e3c:	f8 01       	movw	r30, r16
    5e3e:	85 83       	std	Z+5, r24	; 0x05
    5e40:	a7 cf       	rjmp	.-178    	; 0x5d90 <FormData+0x38>
    5e42:	fc 2f       	mov	r31, r28
    5e44:	ee 27       	eor	r30, r30
    5e46:	ef 5d       	subi	r30, 0xDF	; 223
    5e48:	f4 4f       	sbci	r31, 0xF4	; 244
    5e4a:	90 81       	ld	r25, Z
    5e4c:	80 e0       	ldi	r24, 0x00	; 0
    5e4e:	f8 01       	movw	r30, r16
    5e50:	25 81       	ldd	r18, Z+5	; 0x05
    5e52:	02 2f       	mov	r16, r18
    5e54:	10 e0       	ldi	r17, 0x00	; 0
    5e56:	08 2b       	or	r16, r24
    5e58:	19 2b       	or	r17, r25
		break;
	case 0x0F:
		Qt = MB_FrameReg(MB_N, 4);
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = Qt/8 + (Qt%8>0)) + 9;
    5e5a:	98 01       	movw	r18, r16
    5e5c:	36 95       	lsr	r19
    5e5e:	27 95       	ror	r18
    5e60:	36 95       	lsr	r19
    5e62:	27 95       	ror	r18
    5e64:	36 95       	lsr	r19
    5e66:	27 95       	ror	r18
    5e68:	40 e0       	ldi	r20, 0x00	; 0
    5e6a:	c8 01       	movw	r24, r16
    5e6c:	87 70       	andi	r24, 0x07	; 7
    5e6e:	90 70       	andi	r25, 0x00	; 0
    5e70:	89 2b       	or	r24, r25
    5e72:	09 f0       	breq	.+2      	; 0x5e76 <FormData+0x11e>
    5e74:	8b c0       	rjmp	.+278    	; 0x5f8c <FormData+0x234>
    5e76:	84 2f       	mov	r24, r20
    5e78:	82 0f       	add	r24, r18
    5e7a:	fb 01       	movw	r30, r22
    5e7c:	e3 5e       	subi	r30, 0xE3	; 227
    5e7e:	f4 4f       	sbci	r31, 0xF4	; 244
    5e80:	86 83       	std	Z+6, r24	; 0x06
    5e82:	de 01       	movw	r26, r28
    5e84:	a1 50       	subi	r26, 0x01	; 1
    5e86:	b9 4f       	sbci	r27, 0xF9	; 249
    5e88:	87 5f       	subi	r24, 0xF7	; 247
    5e8a:	8c 93       	st	X, r24
		MB_Frame[MB_N][7+Qt/8] = 0;
    5e8c:	e2 0f       	add	r30, r18
    5e8e:	f3 1f       	adc	r31, r19
    5e90:	17 82       	std	Z+7, r1	; 0x07
		uint8_t *Discr;
		uint8_t Pin;
		if (MB_SingleState[MB_N]!=MB_SingleExec) {
    5e92:	fe 01       	movw	r30, r28
    5e94:	e9 55       	subi	r30, 0x59	; 89
    5e96:	f9 4f       	sbci	r31, 0xF9	; 249
    5e98:	80 81       	ld	r24, Z
    5e9a:	82 30       	cpi	r24, 0x02	; 2
    5e9c:	09 f4       	brne	.+2      	; 0x5ea0 <FormData+0x148>
    5e9e:	78 c0       	rjmp	.+240    	; 0x5f90 <FormData+0x238>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5ea0:	fe 01       	movw	r30, r28
    5ea2:	e2 95       	swap	r30
    5ea4:	f2 95       	swap	r31
    5ea6:	f0 7f       	andi	r31, 0xF0	; 240
    5ea8:	fe 27       	eor	r31, r30
    5eaa:	e0 7f       	andi	r30, 0xF0	; 240
    5eac:	fe 27       	eor	r31, r30
    5eae:	e4 5d       	subi	r30, 0xD4	; 212
    5eb0:	fc 4f       	sbci	r31, 0xFC	; 252
			Discr = prp(&Modbus_Map[MB_N].Coil);
    5eb2:	a5 91       	lpm	r26, Z+
    5eb4:	b4 91       	lpm	r27, Z+
    5eb6:	83 e0       	ldi	r24, 0x03	; 3
    5eb8:	e8 9e       	mul	r14, r24
    5eba:	f0 01       	movw	r30, r0
    5ebc:	11 24       	eor	r1, r1
    5ebe:	e2 5c       	subi	r30, 0xC2	; 194
    5ec0:	f6 4d       	sbci	r31, 0xD6	; 214
    5ec2:	25 91       	lpm	r18, Z+
    5ec4:	34 91       	lpm	r19, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    5ec6:	fe 01       	movw	r30, r28
    5ec8:	e4 5b       	subi	r30, 0xB4	; 180
    5eca:	f9 4f       	sbci	r31, 0xF9	; 249
    5ecc:	80 81       	ld	r24, Z
    5ece:	90 e0       	ldi	r25, 0x00	; 0
    5ed0:	88 0f       	add	r24, r24
    5ed2:	99 1f       	adc	r25, r25
    5ed4:	88 0f       	add	r24, r24
    5ed6:	99 1f       	adc	r25, r25
    5ed8:	28 0f       	add	r18, r24
    5eda:	39 1f       	adc	r19, r25
    5edc:	2f 5f       	subi	r18, 0xFF	; 255
    5ede:	3f 4f       	sbci	r19, 0xFF	; 255
    5ee0:	f9 01       	movw	r30, r18
    5ee2:	45 91       	lpm	r20, Z+
    5ee4:	54 91       	lpm	r21, Z+
    5ee6:	c3 5b       	subi	r28, 0xB3	; 179
    5ee8:	d9 4f       	sbci	r29, 0xF9	; 249
    5eea:	88 81       	ld	r24, Y
    5eec:	27 e0       	ldi	r18, 0x07	; 7
    5eee:	82 9f       	mul	r24, r18
    5ef0:	c0 01       	movw	r24, r0
    5ef2:	11 24       	eor	r1, r1
    5ef4:	48 0f       	add	r20, r24
    5ef6:	59 1f       	adc	r21, r25
    5ef8:	4b 5f       	subi	r20, 0xFB	; 251
    5efa:	5f 4f       	sbci	r21, 0xFF	; 255
    5efc:	fa 01       	movw	r30, r20
    5efe:	85 91       	lpm	r24, Z+
    5f00:	94 91       	lpm	r25, Z+
			Pin = prw(&GetQuery(MB_N)->AllocAddr);
    5f02:	f8 2e       	mov	r15, r24
		}
		else {
			Discr = MB_SingleQuery[MB_N].Buf;
			Pin = 0;
		}
		for (uint8_t i=0; i<Qt; i++) {
    5f04:	01 15       	cp	r16, r1
    5f06:	11 05       	cpc	r17, r1
    5f08:	09 f4       	brne	.+2      	; 0x5f0c <FormData+0x1b4>
    5f0a:	42 cf       	rjmp	.-380    	; 0x5d90 <FormData+0x38>
    5f0c:	50 e0       	ldi	r21, 0x00	; 0
    5f0e:	80 e0       	ldi	r24, 0x00	; 0
    5f10:	90 e0       	ldi	r25, 0x00	; 0
			uint8_t j = Pin+i;
			uint8_t Byte=7+i/8, Bit=1<<i%8;
    5f12:	c1 e0       	ldi	r28, 0x01	; 1
    5f14:	d0 e0       	ldi	r29, 0x00	; 0
    5f16:	0f c0       	rjmp	.+30     	; 0x5f36 <FormData+0x1de>
			if (Discr[j/8] &(1<<j%8))
				MB_Frame[MB_N][Byte] |=Bit;
    5f18:	fb 01       	movw	r30, r22
    5f1a:	e3 0f       	add	r30, r19
    5f1c:	f1 1d       	adc	r31, r1
    5f1e:	e3 5e       	subi	r30, 0xE3	; 227
    5f20:	f4 4f       	sbci	r31, 0xF4	; 244
    5f22:	80 81       	ld	r24, Z
    5f24:	84 2b       	or	r24, r20
    5f26:	80 83       	st	Z, r24
		}
		else {
			Discr = MB_SingleQuery[MB_N].Buf;
			Pin = 0;
		}
		for (uint8_t i=0; i<Qt; i++) {
    5f28:	5f 5f       	subi	r21, 0xFF	; 255
    5f2a:	85 2f       	mov	r24, r21
    5f2c:	90 e0       	ldi	r25, 0x00	; 0
    5f2e:	80 17       	cp	r24, r16
    5f30:	91 07       	cpc	r25, r17
    5f32:	08 f0       	brcs	.+2      	; 0x5f36 <FormData+0x1de>
    5f34:	2d cf       	rjmp	.-422    	; 0x5d90 <FormData+0x38>
    5f36:	25 2f       	mov	r18, r21
    5f38:	2f 0d       	add	r18, r15
			uint8_t j = Pin+i;
			uint8_t Byte=7+i/8, Bit=1<<i%8;
    5f3a:	35 2f       	mov	r19, r21
    5f3c:	36 95       	lsr	r19
    5f3e:	36 95       	lsr	r19
    5f40:	36 95       	lsr	r19
    5f42:	39 5f       	subi	r19, 0xF9	; 249
    5f44:	87 70       	andi	r24, 0x07	; 7
    5f46:	90 70       	andi	r25, 0x00	; 0
    5f48:	fe 01       	movw	r30, r28
    5f4a:	02 c0       	rjmp	.+4      	; 0x5f50 <FormData+0x1f8>
    5f4c:	ee 0f       	add	r30, r30
    5f4e:	ff 1f       	adc	r31, r31
    5f50:	8a 95       	dec	r24
    5f52:	e2 f7       	brpl	.-8      	; 0x5f4c <FormData+0x1f4>
    5f54:	4e 2f       	mov	r20, r30
			if (Discr[j/8] &(1<<j%8))
    5f56:	82 2f       	mov	r24, r18
    5f58:	86 95       	lsr	r24
    5f5a:	86 95       	lsr	r24
    5f5c:	86 95       	lsr	r24
    5f5e:	fd 01       	movw	r30, r26
    5f60:	e8 0f       	add	r30, r24
    5f62:	f1 1d       	adc	r31, r1
    5f64:	80 81       	ld	r24, Z
    5f66:	90 e0       	ldi	r25, 0x00	; 0
    5f68:	27 70       	andi	r18, 0x07	; 7
    5f6a:	02 c0       	rjmp	.+4      	; 0x5f70 <FormData+0x218>
    5f6c:	95 95       	asr	r25
    5f6e:	87 95       	ror	r24
    5f70:	2a 95       	dec	r18
    5f72:	e2 f7       	brpl	.-8      	; 0x5f6c <FormData+0x214>
    5f74:	80 fd       	sbrc	r24, 0
    5f76:	d0 cf       	rjmp	.-96     	; 0x5f18 <FormData+0x1c0>
				MB_Frame[MB_N][Byte] |=Bit;
			else
				MB_Frame[MB_N][Byte] &=~Bit;
    5f78:	fb 01       	movw	r30, r22
    5f7a:	e3 0f       	add	r30, r19
    5f7c:	f1 1d       	adc	r31, r1
    5f7e:	e3 5e       	subi	r30, 0xE3	; 227
    5f80:	f4 4f       	sbci	r31, 0xF4	; 244
    5f82:	40 95       	com	r20
    5f84:	80 81       	ld	r24, Z
    5f86:	48 23       	and	r20, r24
    5f88:	40 83       	st	Z, r20
    5f8a:	ce cf       	rjmp	.-100    	; 0x5f28 <FormData+0x1d0>
		MB_Frame[MB_N][4] = *Reg>>8;
		MB_Frame[MB_N][5] = *Reg;
		break;
	case 0x0F:
		Qt = MB_FrameReg(MB_N, 4);
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = Qt/8 + (Qt%8>0)) + 9;
    5f8c:	41 e0       	ldi	r20, 0x01	; 1
    5f8e:	73 cf       	rjmp	.-282    	; 0x5e76 <FormData+0x11e>
		if (MB_SingleState[MB_N]!=MB_SingleExec) {
			Discr = prp(&Modbus_Map[MB_N].Coil);
			Pin = prw(&GetQuery(MB_N)->AllocAddr);
		}
		else {
			Discr = MB_SingleQuery[MB_N].Buf;
    5f90:	cc 0f       	add	r28, r28
    5f92:	dd 1f       	adc	r29, r29
    5f94:	cc 0f       	add	r28, r28
    5f96:	dd 1f       	adc	r29, r29
    5f98:	cc 0f       	add	r28, r28
    5f9a:	dd 1f       	adc	r29, r29
    5f9c:	ce 52       	subi	r28, 0x2E	; 46
    5f9e:	db 4f       	sbci	r29, 0xFB	; 251
    5fa0:	ae 81       	ldd	r26, Y+6	; 0x06
    5fa2:	bf 81       	ldd	r27, Y+7	; 0x07
    5fa4:	ff 24       	eor	r15, r15
    5fa6:	ae cf       	rjmp	.-164    	; 0x5f04 <FormData+0x1ac>

00005fa8 <FormQuery>:
}

// ~~~~~~~~~~~~~~~~~~~~
static void
FormQuery(uint8_t MB_N)
{
    5fa8:	cf 93       	push	r28
    5faa:	df 93       	push	r29

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5fac:	93 e0       	ldi	r25, 0x03	; 3
    5fae:	89 9f       	mul	r24, r25
    5fb0:	f0 01       	movw	r30, r0
    5fb2:	11 24       	eor	r1, r1
    5fb4:	e2 5c       	subi	r30, 0xC2	; 194
    5fb6:	f6 4d       	sbci	r31, 0xD6	; 214
    5fb8:	65 91       	lpm	r22, Z+
    5fba:	74 91       	lpm	r23, Z+

// ~~~~~~~~~~~~~~~~~~~
static MB_Slave*
GetSlave(uint8_t MB_N)
{
	return (MB_Slave*)prp(&(MB_Master_List+MB_N)->SlaveList)+CurrSlave[MB_N];
    5fbc:	48 2f       	mov	r20, r24
    5fbe:	50 e0       	ldi	r21, 0x00	; 0
    5fc0:	fa 01       	movw	r30, r20
    5fc2:	e4 5b       	subi	r30, 0xB4	; 180
    5fc4:	f9 4f       	sbci	r31, 0xF9	; 249
    5fc6:	20 81       	ld	r18, Z
    5fc8:	30 e0       	ldi	r19, 0x00	; 0
    5fca:	22 0f       	add	r18, r18
    5fcc:	33 1f       	adc	r19, r19
    5fce:	22 0f       	add	r18, r18
    5fd0:	33 1f       	adc	r19, r19
    5fd2:	62 0f       	add	r22, r18
    5fd4:	73 1f       	adc	r23, r19
    5fd6:	fb 01       	movw	r30, r22
    5fd8:	31 96       	adiw	r30, 0x01	; 1
    5fda:	c5 91       	lpm	r28, Z+
    5fdc:	d4 91       	lpm	r29, Z+
// ~~~~~~~~~~~~~~~~~~~~
static void
FormQuery(uint8_t MB_N)
{
	MB_Slave *Slave = GetSlave(MB_N);
	MB_Query *Query = (MB_Query*)prp(&Slave->QueryList)+CurrQuery[MB_N];
    5fde:	fa 01       	movw	r30, r20
    5fe0:	e3 5b       	subi	r30, 0xB3	; 179
    5fe2:	f9 4f       	sbci	r31, 0xF9	; 249
    5fe4:	20 81       	ld	r18, Z
    5fe6:	97 e0       	ldi	r25, 0x07	; 7
    5fe8:	29 9f       	mul	r18, r25
    5fea:	90 01       	movw	r18, r0
    5fec:	11 24       	eor	r1, r1
    5fee:	c2 0f       	add	r28, r18
    5ff0:	d3 1f       	adc	r29, r19

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    5ff2:	fb 01       	movw	r30, r22
    5ff4:	94 91       	lpm	r25, Z+

	MB_Frame[MB_N][0] = prb(&Slave->Addr);
    5ff6:	2d e1       	ldi	r18, 0x1D	; 29
    5ff8:	3b e0       	ldi	r19, 0x0B	; 11
    5ffa:	b4 2f       	mov	r27, r20
    5ffc:	aa 27       	eor	r26, r26
    5ffe:	a2 0f       	add	r26, r18
    6000:	b3 1f       	adc	r27, r19
    6002:	9c 93       	st	X, r25
    6004:	fe 01       	movw	r30, r28
    6006:	94 91       	lpm	r25, Z+
	MB_Frame[MB_N][1] = prb(&Query->Func);
    6008:	11 96       	adiw	r26, 0x01	; 1
    600a:	9c 93       	st	X, r25
    600c:	11 97       	sbiw	r26, 0x01	; 1
	MB_Frame[MB_N][2] = prb((uint8_t*)&Query->StartAddr+1);
    600e:	be 01       	movw	r22, r28
    6010:	6f 5f       	subi	r22, 0xFF	; 255
    6012:	7f 4f       	sbci	r23, 0xFF	; 255
    6014:	6f 5f       	subi	r22, 0xFF	; 255
    6016:	7f 4f       	sbci	r23, 0xFF	; 255
    6018:	fb 01       	movw	r30, r22
    601a:	94 91       	lpm	r25, Z+
    601c:	61 50       	subi	r22, 0x01	; 1
    601e:	70 40       	sbci	r23, 0x00	; 0
    6020:	fd 01       	movw	r30, r26
    6022:	92 83       	std	Z+2, r25	; 0x02
    6024:	fb 01       	movw	r30, r22
    6026:	94 91       	lpm	r25, Z+
	MB_Frame[MB_N][3] = prb((uint8_t*)&Query->StartAddr);
    6028:	13 96       	adiw	r26, 0x03	; 3
    602a:	9c 93       	st	X, r25
    602c:	13 97       	sbiw	r26, 0x03	; 3
    602e:	24 96       	adiw	r28, 0x04	; 4
    6030:	fe 01       	movw	r30, r28
    6032:	94 91       	lpm	r25, Z+
	MB_Frame[MB_N][4] = prb((uint8_t*)&Query->Qt+1);
    6034:	fd 01       	movw	r30, r26
    6036:	94 83       	std	Z+4, r25	; 0x04
    6038:	21 97       	sbiw	r28, 0x01	; 1
    603a:	fe 01       	movw	r30, r28
    603c:	94 91       	lpm	r25, Z+
	MB_Frame[MB_N][5] = prb((uint8_t*)&Query->Qt);
    603e:	15 96       	adiw	r26, 0x05	; 5
    6040:	9c 93       	st	X, r25

	FormData(MB_N);
    6042:	0e 94 ac 2e 	call	0x5d58	; 0x5d58 <FormData>
}
    6046:	df 91       	pop	r29
    6048:	cf 91       	pop	r28
    604a:	08 95       	ret

0000604c <FormSingle>:

// ~~~~~~~~~~~~~~~~~~~~~
static void
FormSingle(uint8_t MB_N)
{
    604c:	1f 93       	push	r17
    604e:	cf 93       	push	r28
    6050:	df 93       	push	r29
	MB_Frame[MB_N][0] = MB_SingleQuery[MB_N].Addr;
    6052:	a8 2f       	mov	r26, r24
    6054:	b0 e0       	ldi	r27, 0x00	; 0
    6056:	6d e1       	ldi	r22, 0x1D	; 29
    6058:	7b e0       	ldi	r23, 0x0B	; 11
    605a:	5a 2f       	mov	r21, r26
    605c:	44 27       	eor	r20, r20
    605e:	46 0f       	add	r20, r22
    6060:	57 1f       	adc	r21, r23
    6062:	22 ed       	ldi	r18, 0xD2	; 210
    6064:	34 e0       	ldi	r19, 0x04	; 4
    6066:	fd 01       	movw	r30, r26
    6068:	ee 0f       	add	r30, r30
    606a:	ff 1f       	adc	r31, r31
    606c:	ee 0f       	add	r30, r30
    606e:	ff 1f       	adc	r31, r31
    6070:	ee 0f       	add	r30, r30
    6072:	ff 1f       	adc	r31, r31
    6074:	e2 0f       	add	r30, r18
    6076:	f3 1f       	adc	r31, r19
    6078:	90 81       	ld	r25, Z
    607a:	ea 01       	movw	r28, r20
    607c:	98 83       	st	Y, r25
	MB_Frame[MB_N][1] = MB_SingleQuery[MB_N].Func;
    607e:	91 81       	ldd	r25, Z+1	; 0x01
    6080:	99 83       	std	Y+1, r25	; 0x01
	MB_Frame[MB_N][2] = MB_SingleQuery[MB_N].StartAddr>>8;
    6082:	fd 01       	movw	r30, r26
    6084:	ee 0f       	add	r30, r30
    6086:	ff 1f       	adc	r31, r31
    6088:	ee 0f       	add	r30, r30
    608a:	ff 1f       	adc	r31, r31
    608c:	ee 0f       	add	r30, r30
    608e:	ff 1f       	adc	r31, r31
    6090:	32 96       	adiw	r30, 0x02	; 2
    6092:	e2 0f       	add	r30, r18
    6094:	f3 1f       	adc	r31, r19
    6096:	10 81       	ld	r17, Z
    6098:	91 81       	ldd	r25, Z+1	; 0x01
    609a:	fa 01       	movw	r30, r20
    609c:	92 83       	std	Z+2, r25	; 0x02
	MB_Frame[MB_N][3] = MB_SingleQuery[MB_N].StartAddr;
    609e:	1b 83       	std	Y+3, r17	; 0x03
	MB_Frame[MB_N][4] = MB_SingleQuery[MB_N].Qt>>8;
    60a0:	fd 01       	movw	r30, r26
    60a2:	ee 0f       	add	r30, r30
    60a4:	ff 1f       	adc	r31, r31
    60a6:	ee 0f       	add	r30, r30
    60a8:	ff 1f       	adc	r31, r31
    60aa:	ee 0f       	add	r30, r30
    60ac:	ff 1f       	adc	r31, r31
    60ae:	34 96       	adiw	r30, 0x04	; 4
    60b0:	e2 0f       	add	r30, r18
    60b2:	f3 1f       	adc	r31, r19
    60b4:	10 81       	ld	r17, Z
    60b6:	91 81       	ldd	r25, Z+1	; 0x01
    60b8:	9c 83       	std	Y+4, r25	; 0x04
	MB_Frame[MB_N][5] = MB_SingleQuery[MB_N].Qt;
    60ba:	1d 83       	std	Y+5, r17	; 0x05
	
	MB_SingleState[MB_N] = MB_SingleExec;
    60bc:	a9 55       	subi	r26, 0x59	; 89
    60be:	b9 4f       	sbci	r27, 0xF9	; 249
    60c0:	92 e0       	ldi	r25, 0x02	; 2
    60c2:	9c 93       	st	X, r25
	FormData(MB_N);
    60c4:	0e 94 ac 2e 	call	0x5d58	; 0x5d58 <FormData>
}
    60c8:	df 91       	pop	r29
    60ca:	cf 91       	pop	r28
    60cc:	1f 91       	pop	r17
    60ce:	08 95       	ret

000060d0 <NextSlave>:

// ~~~~~~~~~~~~~~~~~~~~
static uint8_t
NextSlave(uint8_t MB_N)
{
    60d0:	2f 92       	push	r2
    60d2:	3f 92       	push	r3
    60d4:	4f 92       	push	r4
    60d6:	5f 92       	push	r5
    60d8:	6f 92       	push	r6
    60da:	7f 92       	push	r7
    60dc:	8f 92       	push	r8
    60de:	9f 92       	push	r9
    60e0:	af 92       	push	r10
    60e2:	bf 92       	push	r11
    60e4:	cf 92       	push	r12
    60e6:	df 92       	push	r13
    60e8:	ef 92       	push	r14
    60ea:	ff 92       	push	r15
    60ec:	0f 93       	push	r16
    60ee:	1f 93       	push	r17
    60f0:	df 93       	push	r29
    60f2:	cf 93       	push	r28
    60f4:	00 d0       	rcall	.+0      	; 0x60f6 <NextSlave+0x26>
    60f6:	00 d0       	rcall	.+0      	; 0x60f8 <NextSlave+0x28>
    60f8:	cd b7       	in	r28, 0x3d	; 61
    60fa:	de b7       	in	r29, 0x3e	; 62
    60fc:	68 2e       	mov	r6, r24
    60fe:	e3 e0       	ldi	r30, 0x03	; 3
    6100:	8e 9f       	mul	r24, r30
    6102:	f0 01       	movw	r30, r0
    6104:	11 24       	eor	r1, r1
    6106:	e0 5c       	subi	r30, 0xC0	; 192
    6108:	f6 4d       	sbci	r31, 0xD6	; 214
    610a:	04 91       	lpm	r16, Z+
    610c:	c8 2e       	mov	r12, r24
    610e:	dd 24       	eor	r13, r13
    6110:	a6 01       	movw	r20, r12
    6112:	44 5b       	subi	r20, 0xB4	; 180
    6114:	59 4f       	sbci	r21, 0xF9	; 249
    6116:	5e 83       	std	Y+6, r21	; 0x06
    6118:	4d 83       	std	Y+5, r20	; 0x05
    611a:	fa 01       	movw	r30, r20
    611c:	20 81       	ld	r18, Z
    611e:	16 01       	movw	r2, r12
    6120:	22 0c       	add	r2, r2
    6122:	33 1c       	adc	r3, r3
    6124:	22 0c       	add	r2, r2
    6126:	33 1c       	adc	r3, r3
    6128:	f1 01       	movw	r30, r2
    612a:	e4 52       	subi	r30, 0x24	; 36
    612c:	fb 4f       	sbci	r31, 0xFB	; 251
    612e:	80 80       	ld	r8, Z
    6130:	91 80       	ldd	r9, Z+1	; 0x01
    6132:	a2 80       	ldd	r10, Z+2	; 0x02
    6134:	b3 80       	ldd	r11, Z+3	; 0x03
	do
		if (++CurrSlave[MB_N]==SlaveQt) {
			CurrSlave[MB_N] = 0;
			Over = 1;

			if ((MB_Master_Cycle[MB_N]=0xFFFF-GetTimer16(TD_MB_Cycle+MB_N))>MB_Master_MaxCycle[MB_N])
    6136:	70 90 e0 04 	lds	r7, 0x04E0
    613a:	f2 e0       	ldi	r31, 0x02	; 2
    613c:	7f 0e       	add	r7, r31
    613e:	47 2d       	mov	r20, r7
    6140:	48 0f       	add	r20, r24
    6142:	4a 83       	std	Y+2, r20	; 0x02
    6144:	5e ef       	ldi	r21, 0xFE	; 254
    6146:	75 0e       	add	r7, r21
// ~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
GetTimer16(uint8_t TimerN)
{
	IntOff();
	uint16_t Time = Timer16[TimerN];
    6148:	e4 2e       	mov	r14, r20
    614a:	ff 24       	eor	r15, r15
    614c:	19 82       	std	Y+1, r1	; 0x01
    614e:	10 e0       	ldi	r17, 0x00	; 0
    6150:	ee 0c       	add	r14, r14
    6152:	ff 1c       	adc	r15, r15
    6154:	87 e4       	ldi	r24, 0x47	; 71
    6156:	93 e0       	ldi	r25, 0x03	; 3
    6158:	e8 0e       	add	r14, r24
    615a:	f9 1e       	adc	r15, r25
    615c:	c6 01       	movw	r24, r12
    615e:	88 0f       	add	r24, r24
    6160:	99 1f       	adc	r25, r25
    6162:	fc 01       	movw	r30, r24
    6164:	e4 59       	subi	r30, 0x94	; 148
    6166:	f8 4f       	sbci	r31, 0xF8	; 248
    6168:	fc 83       	std	Y+4, r31	; 0x04
    616a:	eb 83       	std	Y+3, r30	; 0x03
    616c:	f6 eb       	ldi	r31, 0xB6	; 182
    616e:	4f 2e       	mov	r4, r31
    6170:	f6 e0       	ldi	r31, 0x06	; 6
    6172:	5f 2e       	mov	r5, r31
    6174:	48 0e       	add	r4, r24
    6176:	59 1e       	adc	r5, r25
    6178:	14 c0       	rjmp	.+40     	; 0x61a2 <NextSlave+0xd2>
				MB_Master_MaxCycle[MB_N] = MB_Master_Cycle[MB_N];
			StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
		}
	while (SlaveSkip[MB_N] &((uint32_t)1<<CurrSlave[MB_N]) && ++i<SlaveQt);
    617a:	ed 81       	ldd	r30, Y+5	; 0x05
    617c:	fe 81       	ldd	r31, Y+6	; 0x06
    617e:	20 81       	ld	r18, Z
    6180:	d5 01       	movw	r26, r10
    6182:	c4 01       	movw	r24, r8
    6184:	02 2e       	mov	r0, r18
    6186:	04 c0       	rjmp	.+8      	; 0x6190 <NextSlave+0xc0>
    6188:	b6 95       	lsr	r27
    618a:	a7 95       	ror	r26
    618c:	97 95       	ror	r25
    618e:	87 95       	ror	r24
    6190:	0a 94       	dec	r0
    6192:	d2 f7       	brpl	.-12     	; 0x6188 <NextSlave+0xb8>
    6194:	81 70       	andi	r24, 0x01	; 1
    6196:	90 70       	andi	r25, 0x00	; 0
    6198:	88 23       	and	r24, r24
    619a:	61 f1       	breq	.+88     	; 0x61f4 <NextSlave+0x124>
    619c:	1f 5f       	subi	r17, 0xFF	; 255
    619e:	10 17       	cp	r17, r16
    61a0:	48 f5       	brcc	.+82     	; 0x61f4 <NextSlave+0x124>
{
	uint8_t Over = 0;
	uint8_t i = 0;
	uint8_t SlaveQt = prb(&(MB_Master_List+MB_N)->SlaveQt);
	do
		if (++CurrSlave[MB_N]==SlaveQt) {
    61a2:	82 2f       	mov	r24, r18
    61a4:	8f 5f       	subi	r24, 0xFF	; 255
    61a6:	ed 81       	ldd	r30, Y+5	; 0x05
    61a8:	fe 81       	ldd	r31, Y+6	; 0x06
    61aa:	80 83       	st	Z, r24
    61ac:	80 17       	cp	r24, r16
    61ae:	29 f7       	brne	.-54     	; 0x617a <NextSlave+0xaa>
			CurrSlave[MB_N] = 0;
    61b0:	10 82       	st	Z, r1

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    61b2:	8f b7       	in	r24, 0x3f	; 63
    61b4:	80 78       	andi	r24, 0x80	; 128
    61b6:	80 93 e6 02 	sts	0x02E6, r24
	cli();
    61ba:	f8 94       	cli
    61bc:	f7 01       	movw	r30, r14
    61be:	20 81       	ld	r18, Z
    61c0:	31 81       	ldd	r19, Z+1	; 0x01

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    61c2:	88 23       	and	r24, r24
    61c4:	09 f0       	breq	.+2      	; 0x61c8 <NextSlave+0xf8>
		sei();
    61c6:	78 94       	sei
			Over = 1;

			if ((MB_Master_Cycle[MB_N]=0xFFFF-GetTimer16(TD_MB_Cycle+MB_N))>MB_Master_MaxCycle[MB_N])
    61c8:	20 95       	com	r18
    61ca:	30 95       	com	r19
    61cc:	eb 81       	ldd	r30, Y+3	; 0x03
    61ce:	fc 81       	ldd	r31, Y+4	; 0x04
    61d0:	31 83       	std	Z+1, r19	; 0x01
    61d2:	20 83       	st	Z, r18
    61d4:	f2 01       	movw	r30, r4
    61d6:	80 81       	ld	r24, Z
    61d8:	91 81       	ldd	r25, Z+1	; 0x01
    61da:	82 17       	cp	r24, r18
    61dc:	93 07       	cpc	r25, r19
    61de:	10 f4       	brcc	.+4      	; 0x61e4 <NextSlave+0x114>
				MB_Master_MaxCycle[MB_N] = MB_Master_Cycle[MB_N];
    61e0:	31 83       	std	Z+1, r19	; 0x01
    61e2:	20 83       	st	Z, r18
			StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
    61e4:	8a 81       	ldd	r24, Y+2	; 0x02
    61e6:	6f ef       	ldi	r22, 0xFF	; 255
    61e8:	7f ef       	ldi	r23, 0xFF	; 255
    61ea:	0e 94 1d 1a 	call	0x343a	; 0x343a <StartTimer16>
    61ee:	f1 e0       	ldi	r31, 0x01	; 1
    61f0:	f9 83       	std	Y+1, r31	; 0x01
    61f2:	c3 cf       	rjmp	.-122    	; 0x617a <NextSlave+0xaa>
		}
	while (SlaveSkip[MB_N] &((uint32_t)1<<CurrSlave[MB_N]) && ++i<SlaveQt);
	if (i==SlaveQt) {
    61f4:	10 17       	cp	r17, r16
    61f6:	01 f1       	breq	.+64     	; 0x6238 <NextSlave+0x168>
		SlavesOn(MB_N);
		if (++CurrSlave[MB_N]==SlaveQt)
			CurrSlave[MB_N] = 0;
	}
	CurrQuery[MB_N] = 0;
    61f8:	4d e4       	ldi	r20, 0x4D	; 77
    61fa:	56 e0       	ldi	r21, 0x06	; 6
    61fc:	c4 0e       	add	r12, r20
    61fe:	d5 1e       	adc	r13, r21
    6200:	f6 01       	movw	r30, r12
    6202:	10 82       	st	Z, r1
	return Over;
}
    6204:	89 81       	ldd	r24, Y+1	; 0x01
    6206:	26 96       	adiw	r28, 0x06	; 6
    6208:	0f b6       	in	r0, 0x3f	; 63
    620a:	f8 94       	cli
    620c:	de bf       	out	0x3e, r29	; 62
    620e:	0f be       	out	0x3f, r0	; 63
    6210:	cd bf       	out	0x3d, r28	; 61
    6212:	cf 91       	pop	r28
    6214:	df 91       	pop	r29
    6216:	1f 91       	pop	r17
    6218:	0f 91       	pop	r16
    621a:	ff 90       	pop	r15
    621c:	ef 90       	pop	r14
    621e:	df 90       	pop	r13
    6220:	cf 90       	pop	r12
    6222:	bf 90       	pop	r11
    6224:	af 90       	pop	r10
    6226:	9f 90       	pop	r9
    6228:	8f 90       	pop	r8
    622a:	7f 90       	pop	r7
    622c:	6f 90       	pop	r6
    622e:	5f 90       	pop	r5
    6230:	4f 90       	pop	r4
    6232:	3f 90       	pop	r3
    6234:	2f 90       	pop	r2
    6236:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~
static void
SlavesOn(uint8_t MB_N)
{
	SlaveSkip[MB_N] = 0;
    6238:	4c ed       	ldi	r20, 0xDC	; 220
    623a:	54 e0       	ldi	r21, 0x04	; 4
    623c:	24 0e       	add	r2, r20
    623e:	35 1e       	adc	r3, r21
    6240:	f1 01       	movw	r30, r2
    6242:	10 82       	st	Z, r1
    6244:	11 82       	std	Z+1, r1	; 0x01
    6246:	12 82       	std	Z+2, r1	; 0x02
    6248:	13 82       	std	Z+3, r1	; 0x03
	StartTimer16(TD_MB_SlaveOff+MB_N, 100*MB_M_TimeOff[MB_N]);
    624a:	73 94       	inc	r7
    624c:	f6 01       	movw	r30, r12
    624e:	e9 52       	subi	r30, 0x29	; 41
    6250:	fa 4f       	sbci	r31, 0xFA	; 250
    6252:	60 81       	ld	r22, Z
    6254:	84 e6       	ldi	r24, 0x64	; 100
    6256:	68 9f       	mul	r22, r24
    6258:	b0 01       	movw	r22, r0
    625a:	11 24       	eor	r1, r1
    625c:	87 2d       	mov	r24, r7
    625e:	86 0d       	add	r24, r6
    6260:	0e 94 1d 1a 	call	0x343a	; 0x343a <StartTimer16>
			StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
		}
	while (SlaveSkip[MB_N] &((uint32_t)1<<CurrSlave[MB_N]) && ++i<SlaveQt);
	if (i==SlaveQt) {
		SlavesOn(MB_N);
		if (++CurrSlave[MB_N]==SlaveQt)
    6264:	ed 81       	ldd	r30, Y+5	; 0x05
    6266:	fe 81       	ldd	r31, Y+6	; 0x06
    6268:	80 81       	ld	r24, Z
    626a:	8f 5f       	subi	r24, 0xFF	; 255
    626c:	80 83       	st	Z, r24
    626e:	18 17       	cp	r17, r24
    6270:	19 f6       	brne	.-122    	; 0x61f8 <NextSlave+0x128>
			CurrSlave[MB_N] = 0;
    6272:	10 82       	st	Z, r1
    6274:	c1 cf       	rjmp	.-126    	; 0x61f8 <NextSlave+0x128>

00006276 <FailSlave>:
}

// ~~~~~~~~~~~~~~~~~~~~
static uint8_t
FailSlave(uint8_t MB_N)
{
    6276:	ef 92       	push	r14
    6278:	ff 92       	push	r15
    627a:	1f 93       	push	r17
    627c:	cf 93       	push	r28
    627e:	df 93       	push	r29
    6280:	18 2f       	mov	r17, r24
	uint8_t Over = 0;
	if (MB_SingleState[MB_N]==MB_SingleExec)
    6282:	68 2f       	mov	r22, r24
    6284:	70 e0       	ldi	r23, 0x00	; 0
    6286:	fb 01       	movw	r30, r22
    6288:	e9 55       	subi	r30, 0x59	; 89
    628a:	f9 4f       	sbci	r31, 0xF9	; 249
    628c:	80 81       	ld	r24, Z
    628e:	82 30       	cpi	r24, 0x02	; 2
    6290:	19 f1       	breq	.+70     	; 0x62d8 <FailSlave+0x62>
		MB_SingleState[MB_N] = MB_SingleIdle;
	else{
		MB_CPT[MB_N][4]++;	// -    
    6292:	fb 01       	movw	r30, r22
    6294:	ee 0f       	add	r30, r30
    6296:	ff 1f       	adc	r31, r31
    6298:	ee 0f       	add	r30, r30
    629a:	ff 1f       	adc	r31, r31
    629c:	ee 0f       	add	r30, r30
    629e:	ff 1f       	adc	r31, r31
    62a0:	ee 0f       	add	r30, r30
    62a2:	ff 1f       	adc	r31, r31
    62a4:	e0 51       	subi	r30, 0x10	; 16
    62a6:	f7 4f       	sbci	r31, 0xF7	; 247
    62a8:	80 81       	ld	r24, Z
    62aa:	91 81       	ldd	r25, Z+1	; 0x01
    62ac:	01 96       	adiw	r24, 0x01	; 1
    62ae:	91 83       	std	Z+1, r25	; 0x01
    62b0:	80 83       	st	Z, r24
		if (++Try[MB_N]==MB_M_Try[MB_N]) {
    62b2:	eb 01       	movw	r28, r22
    62b4:	c5 52       	subi	r28, 0x25	; 37
    62b6:	db 4f       	sbci	r29, 0xFB	; 251
    62b8:	88 81       	ld	r24, Y
    62ba:	8f 5f       	subi	r24, 0xFF	; 255
    62bc:	88 83       	st	Y, r24
    62be:	fb 01       	movw	r30, r22
    62c0:	eb 50       	subi	r30, 0x0B	; 11
    62c2:	f9 4f       	sbci	r31, 0xF9	; 249
    62c4:	90 81       	ld	r25, Z
    62c6:	89 17       	cp	r24, r25
    62c8:	79 f0       	breq	.+30     	; 0x62e8 <FailSlave+0x72>
    62ca:	80 e0       	ldi	r24, 0x00	; 0
			Try[MB_N] = 0;
			Over = NextSlave(MB_N);
		}
	}
	return Over;
}
    62cc:	df 91       	pop	r29
    62ce:	cf 91       	pop	r28
    62d0:	1f 91       	pop	r17
    62d2:	ff 90       	pop	r15
    62d4:	ef 90       	pop	r14
    62d6:	08 95       	ret
static uint8_t
FailSlave(uint8_t MB_N)
{
	uint8_t Over = 0;
	if (MB_SingleState[MB_N]==MB_SingleExec)
		MB_SingleState[MB_N] = MB_SingleIdle;
    62d8:	10 82       	st	Z, r1
    62da:	80 e0       	ldi	r24, 0x00	; 0
			Try[MB_N] = 0;
			Over = NextSlave(MB_N);
		}
	}
	return Over;
}
    62dc:	df 91       	pop	r29
    62de:	cf 91       	pop	r28
    62e0:	1f 91       	pop	r17
    62e2:	ff 90       	pop	r15
    62e4:	ef 90       	pop	r14
    62e6:	08 95       	ret
	if (MB_SingleState[MB_N]==MB_SingleExec)
		MB_SingleState[MB_N] = MB_SingleIdle;
	else{
		MB_CPT[MB_N][4]++;	// -    
		if (++Try[MB_N]==MB_M_Try[MB_N]) {
			uint32_t S_N = (uint32_t)1<<CurrSlave[MB_N];
    62e8:	fb 01       	movw	r30, r22
    62ea:	e4 5b       	subi	r30, 0xB4	; 180
    62ec:	f9 4f       	sbci	r31, 0xF9	; 249
    62ee:	21 e0       	ldi	r18, 0x01	; 1
    62f0:	30 e0       	ldi	r19, 0x00	; 0
    62f2:	40 e0       	ldi	r20, 0x00	; 0
    62f4:	50 e0       	ldi	r21, 0x00	; 0
    62f6:	00 80       	ld	r0, Z
    62f8:	04 c0       	rjmp	.+8      	; 0x6302 <FailSlave+0x8c>
    62fa:	22 0f       	add	r18, r18
    62fc:	33 1f       	adc	r19, r19
    62fe:	44 1f       	adc	r20, r20
    6300:	55 1f       	adc	r21, r21
    6302:	0a 94       	dec	r0
    6304:	d2 f7       	brpl	.-12     	; 0x62fa <FailSlave+0x84>
			SlaveOff[MB_N] |=S_N;
    6306:	7b 01       	movw	r14, r22
    6308:	ee 0c       	add	r14, r14
    630a:	ff 1c       	adc	r15, r15
    630c:	ee 0c       	add	r14, r14
    630e:	ff 1c       	adc	r15, r15
    6310:	b7 01       	movw	r22, r14
    6312:	61 52       	subi	r22, 0x21	; 33
    6314:	77 4f       	sbci	r23, 0xF7	; 247
    6316:	fb 01       	movw	r30, r22
    6318:	80 81       	ld	r24, Z
    631a:	91 81       	ldd	r25, Z+1	; 0x01
    631c:	a2 81       	ldd	r26, Z+2	; 0x02
    631e:	b3 81       	ldd	r27, Z+3	; 0x03
    6320:	82 2b       	or	r24, r18
    6322:	93 2b       	or	r25, r19
    6324:	a4 2b       	or	r26, r20
    6326:	b5 2b       	or	r27, r21
    6328:	80 83       	st	Z, r24
    632a:	91 83       	std	Z+1, r25	; 0x01
    632c:	a2 83       	std	Z+2, r26	; 0x02
    632e:	b3 83       	std	Z+3, r27	; 0x03
			SlaveSkip[MB_N] |=S_N;
    6330:	f7 01       	movw	r30, r14
    6332:	e4 52       	subi	r30, 0x24	; 36
    6334:	fb 4f       	sbci	r31, 0xFB	; 251
    6336:	80 81       	ld	r24, Z
    6338:	91 81       	ldd	r25, Z+1	; 0x01
    633a:	a2 81       	ldd	r26, Z+2	; 0x02
    633c:	b3 81       	ldd	r27, Z+3	; 0x03
    633e:	28 2b       	or	r18, r24
    6340:	39 2b       	or	r19, r25
    6342:	4a 2b       	or	r20, r26
    6344:	5b 2b       	or	r21, r27
    6346:	20 83       	st	Z, r18
    6348:	31 83       	std	Z+1, r19	; 0x01
    634a:	42 83       	std	Z+2, r20	; 0x02
    634c:	53 83       	std	Z+3, r21	; 0x03
			Try[MB_N] = 0;
    634e:	18 82       	st	Y, r1
			Over = NextSlave(MB_N);
    6350:	81 2f       	mov	r24, r17
    6352:	0e 94 68 30 	call	0x60d0	; 0x60d0 <NextSlave>
		}
	}
	return Over;
}
    6356:	df 91       	pop	r29
    6358:	cf 91       	pop	r28
    635a:	1f 91       	pop	r17
    635c:	ff 90       	pop	r15
    635e:	ef 90       	pop	r14
    6360:	08 95       	ret

00006362 <MB_M_Timer_ISR>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_M_Timer_ISR(uint8_t MB_N)
{
    6362:	4f 92       	push	r4
    6364:	5f 92       	push	r5
    6366:	6f 92       	push	r6
    6368:	7f 92       	push	r7
    636a:	8f 92       	push	r8
    636c:	9f 92       	push	r9
    636e:	af 92       	push	r10
    6370:	bf 92       	push	r11
    6372:	cf 92       	push	r12
    6374:	df 92       	push	r13
    6376:	ef 92       	push	r14
    6378:	ff 92       	push	r15
    637a:	0f 93       	push	r16
    637c:	1f 93       	push	r17
    637e:	cf 93       	push	r28
    6380:	df 93       	push	r29
    6382:	18 2f       	mov	r17, r24
	switch (MB_State[MB_N]) {
    6384:	c8 2f       	mov	r28, r24
    6386:	d0 e0       	ldi	r29, 0x00	; 0
    6388:	fe 01       	movw	r30, r28
    638a:	e6 54       	subi	r30, 0x46	; 70
    638c:	fa 4f       	sbci	r31, 0xFA	; 250
    638e:	80 81       	ld	r24, Z
    6390:	88 23       	and	r24, r24
    6392:	f9 f4       	brne	.+62     	; 0x63d2 <MB_M_Timer_ISR+0x70>
	case MB_Initi:
		StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
    6394:	80 91 e0 04 	lds	r24, 0x04E0
    6398:	8e 5f       	subi	r24, 0xFE	; 254
    639a:	81 0f       	add	r24, r17
    639c:	6f ef       	ldi	r22, 0xFF	; 255
    639e:	7f ef       	ldi	r23, 0xFF	; 255
    63a0:	0e 94 1d 1a 	call	0x343a	; 0x343a <StartTimer16>
		FormQuery(MB_N);
    63a4:	81 2f       	mov	r24, r17
    63a6:	0e 94 d4 2f 	call	0x5fa8	; 0x5fa8 <FormQuery>
		MB_Transm(MB_N);
    63aa:	81 2f       	mov	r24, r17
    63ac:	0e 94 cc 28 	call	0x5198	; 0x5198 <MB_Transm>
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
		MB_M_CtrlProc(MB_N);
		break;
	}
}
    63b0:	df 91       	pop	r29
    63b2:	cf 91       	pop	r28
    63b4:	1f 91       	pop	r17
    63b6:	0f 91       	pop	r16
    63b8:	ff 90       	pop	r15
    63ba:	ef 90       	pop	r14
    63bc:	df 90       	pop	r13
    63be:	cf 90       	pop	r12
    63c0:	bf 90       	pop	r11
    63c2:	af 90       	pop	r10
    63c4:	9f 90       	pop	r9
    63c6:	8f 90       	pop	r8
    63c8:	7f 90       	pop	r7
    63ca:	6f 90       	pop	r6
    63cc:	5f 90       	pop	r5
    63ce:	4f 90       	pop	r4
    63d0:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_M_Timer_ISR(uint8_t MB_N)
{
	switch (MB_State[MB_N]) {
    63d2:	82 30       	cpi	r24, 0x02	; 2
    63d4:	69 f7       	brne	.-38     	; 0x63b0 <MB_M_Timer_ISR+0x4e>
		StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
		FormQuery(MB_N);
		MB_Transm(MB_N);
		break;
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
    63d6:	84 e0       	ldi	r24, 0x04	; 4
    63d8:	80 83       	st	Z, r24
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
MB_M_CtrlProc(uint8_t MB_N)
{
	uint8_t Over = 0;
	LastProcSingle = MB_SingleState[MB_N]==MB_SingleExec;
    63da:	e7 ea       	ldi	r30, 0xA7	; 167
    63dc:	ae 2e       	mov	r10, r30
    63de:	e6 e0       	ldi	r30, 0x06	; 6
    63e0:	be 2e       	mov	r11, r30
    63e2:	ac 0e       	add	r10, r28
    63e4:	bd 1e       	adc	r11, r29
    63e6:	d5 01       	movw	r26, r10
    63e8:	8c 91       	ld	r24, X
    63ea:	90 e0       	ldi	r25, 0x00	; 0
    63ec:	82 30       	cpi	r24, 0x02	; 2
    63ee:	09 f4       	brne	.+2      	; 0x63f2 <MB_M_Timer_ISR+0x90>
    63f0:	4e c0       	rjmp	.+156    	; 0x648e <MB_M_Timer_ISR+0x12c>
    63f2:	90 93 da 04 	sts	0x04DA, r25
	if (CommErr(MB_N))
    63f6:	81 2f       	mov	r24, r17
    63f8:	0e 94 b0 29 	call	0x5360	; 0x5360 <CommErr>
    63fc:	88 23       	and	r24, r24
    63fe:	91 f5       	brne	.+100    	; 0x6464 <MB_M_Timer_ISR+0x102>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6400:	7e 01       	movw	r14, r28
    6402:	ee 0c       	add	r14, r14
    6404:	ff 1c       	adc	r15, r15
    6406:	ee 0c       	add	r14, r14
    6408:	ff 1c       	adc	r15, r15
    640a:	c7 01       	movw	r24, r14
    640c:	88 0f       	add	r24, r24
    640e:	99 1f       	adc	r25, r25
    6410:	88 0f       	add	r24, r24
    6412:	99 1f       	adc	r25, r25
    6414:	8e 0d       	add	r24, r14
    6416:	9f 1d       	adc	r25, r15
    6418:	81 5e       	subi	r24, 0xE1	; 225
    641a:	93 4d       	sbci	r25, 0xD3	; 211
    641c:	fc 01       	movw	r30, r24
    641e:	25 91       	lpm	r18, Z+
    6420:	34 91       	lpm	r19, Z+
		Over = FailSlave(MB_N);
	else {
		USART_Func(MB_N, LED);
    6422:	f9 01       	movw	r30, r18
    6424:	19 95       	eicall
		MB_Slave *Slave;
		MB_Query *Query;
		uint8_t Addr, Func;
		if (LastProcSingle) {
    6426:	80 91 da 04 	lds	r24, 0x04DA
    642a:	88 23       	and	r24, r24
    642c:	91 f1       	breq	.+100    	; 0x6492 <MB_M_Timer_ISR+0x130>
			Addr = MB_SingleQuery[MB_N].Addr;
    642e:	fe 01       	movw	r30, r28
    6430:	ee 0f       	add	r30, r30
    6432:	ff 1f       	adc	r31, r31
    6434:	ee 0f       	add	r30, r30
    6436:	ff 1f       	adc	r31, r31
    6438:	ee 0f       	add	r30, r30
    643a:	ff 1f       	adc	r31, r31
    643c:	ee 52       	subi	r30, 0x2E	; 46
    643e:	fb 4f       	sbci	r31, 0xFB	; 251
    6440:	20 81       	ld	r18, Z
			Func = MB_SingleQuery[MB_N].Func;
    6442:	91 81       	ldd	r25, Z+1	; 0x01
    6444:	40 e0       	ldi	r20, 0x00	; 0
    6446:	50 e0       	ldi	r21, 0x00	; 0
    6448:	60 e0       	ldi	r22, 0x00	; 0
    644a:	70 e0       	ldi	r23, 0x00	; 0
			Slave = GetSlave(MB_N);
			Query = (MB_Query*)prp(&Slave->QueryList)+CurrQuery[MB_N];
			Addr = prb(&Slave->Addr);
			Func = prb(&Query->Func);
		}
		if (MB_Frame[MB_N][0]!=Addr || MB_Frame[MB_N][1]!=Func)
    644c:	dc 2e       	mov	r13, r28
    644e:	cc 24       	eor	r12, r12
    6450:	f6 01       	movw	r30, r12
    6452:	e3 5e       	subi	r30, 0xE3	; 227
    6454:	f4 4f       	sbci	r31, 0xF4	; 244
    6456:	80 81       	ld	r24, Z
    6458:	82 17       	cp	r24, r18
    645a:	21 f4       	brne	.+8      	; 0x6464 <MB_M_Timer_ISR+0x102>
    645c:	a1 81       	ldd	r26, Z+1	; 0x01
    645e:	a9 17       	cp	r26, r25
    6460:	09 f4       	brne	.+2      	; 0x6464 <MB_M_Timer_ISR+0x102>
    6462:	3d c0       	rjmp	.+122    	; 0x64de <MB_M_Timer_ISR+0x17c>
				Err = MB_M_Force(MB_N, Query);
				break;
			}
			if (Err) {
				MB_CPT[MB_N][2]++;
				Over = FailSlave(MB_N);
    6464:	81 2f       	mov	r24, r17
    6466:	0e 94 3b 31 	call	0x6276	; 0x6276 <FailSlave>
    646a:	98 2f       	mov	r25, r24
			}
		}
		/*if (Over)
			USART_Func(MB_N, LED);*/
	}
	StartTimer16(TD_MB_Idle+MB_N, Over?MB_M_Period[MB_N]:MB_M_Pause_Min);
    646c:	80 91 e0 04 	lds	r24, 0x04E0
    6470:	81 0f       	add	r24, r17
    6472:	99 23       	and	r25, r25
    6474:	49 f0       	breq	.+18     	; 0x6488 <MB_M_Timer_ISR+0x126>
    6476:	cc 0f       	add	r28, r28
    6478:	dd 1f       	adc	r29, r29
    647a:	cb 55       	subi	r28, 0x5B	; 91
    647c:	d9 4f       	sbci	r29, 0xF9	; 249
    647e:	68 81       	ld	r22, Y
    6480:	79 81       	ldd	r23, Y+1	; 0x01
    6482:	0e 94 1d 1a 	call	0x343a	; 0x343a <StartTimer16>
    6486:	94 cf       	rjmp	.-216    	; 0x63b0 <MB_M_Timer_ISR+0x4e>
    6488:	65 e0       	ldi	r22, 0x05	; 5
    648a:	70 e0       	ldi	r23, 0x00	; 0
    648c:	fa cf       	rjmp	.-12     	; 0x6482 <MB_M_Timer_ISR+0x120>
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
MB_M_CtrlProc(uint8_t MB_N)
{
	uint8_t Over = 0;
	LastProcSingle = MB_SingleState[MB_N]==MB_SingleExec;
    648e:	91 e0       	ldi	r25, 0x01	; 1
    6490:	b0 cf       	rjmp	.-160    	; 0x63f2 <MB_M_Timer_ISR+0x90>
    6492:	83 e0       	ldi	r24, 0x03	; 3
    6494:	18 9f       	mul	r17, r24
    6496:	f0 01       	movw	r30, r0
    6498:	11 24       	eor	r1, r1
    649a:	e2 5c       	subi	r30, 0xC2	; 194
    649c:	f6 4d       	sbci	r31, 0xD6	; 214
    649e:	65 91       	lpm	r22, Z+
    64a0:	74 91       	lpm	r23, Z+

// ~~~~~~~~~~~~~~~~~~~
static MB_Slave*
GetSlave(uint8_t MB_N)
{
	return (MB_Slave*)prp(&(MB_Master_List+MB_N)->SlaveList)+CurrSlave[MB_N];
    64a2:	fe 01       	movw	r30, r28
    64a4:	e4 5b       	subi	r30, 0xB4	; 180
    64a6:	f9 4f       	sbci	r31, 0xF9	; 249
    64a8:	80 81       	ld	r24, Z
    64aa:	90 e0       	ldi	r25, 0x00	; 0
    64ac:	88 0f       	add	r24, r24
    64ae:	99 1f       	adc	r25, r25
    64b0:	88 0f       	add	r24, r24
    64b2:	99 1f       	adc	r25, r25
    64b4:	68 0f       	add	r22, r24
    64b6:	79 1f       	adc	r23, r25
    64b8:	fb 01       	movw	r30, r22
    64ba:	31 96       	adiw	r30, 0x01	; 1
    64bc:	45 91       	lpm	r20, Z+
    64be:	54 91       	lpm	r21, Z+
			Addr = MB_SingleQuery[MB_N].Addr;
			Func = MB_SingleQuery[MB_N].Func;
		}
		else {
			Slave = GetSlave(MB_N);
			Query = (MB_Query*)prp(&Slave->QueryList)+CurrQuery[MB_N];
    64c0:	fe 01       	movw	r30, r28
    64c2:	e3 5b       	subi	r30, 0xB3	; 179
    64c4:	f9 4f       	sbci	r31, 0xF9	; 249
    64c6:	80 81       	ld	r24, Z
    64c8:	27 e0       	ldi	r18, 0x07	; 7
    64ca:	82 9f       	mul	r24, r18
    64cc:	c0 01       	movw	r24, r0
    64ce:	11 24       	eor	r1, r1
    64d0:	48 0f       	add	r20, r24
    64d2:	59 1f       	adc	r21, r25

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    64d4:	fb 01       	movw	r30, r22
    64d6:	24 91       	lpm	r18, Z+
		}
		if (MB_Frame[MB_N][0]!=Addr || MB_Frame[MB_N][1]!=Func)
			Over = FailSlave(MB_N);
		else {
			uint8_t Err;
			switch (Func) {
    64d8:	fa 01       	movw	r30, r20
    64da:	94 91       	lpm	r25, Z+
    64dc:	b7 cf       	rjmp	.-146    	; 0x644c <MB_M_Timer_ISR+0xea>
    64de:	95 30       	cpi	r25, 0x05	; 5
    64e0:	18 f5       	brcc	.+70     	; 0x6528 <MB_M_Timer_ISR+0x1c6>
    64e2:	93 30       	cpi	r25, 0x03	; 3
    64e4:	08 f4       	brcc	.+2      	; 0x64e8 <MB_M_Timer_ISR+0x186>
    64e6:	ad c0       	rjmp	.+346    	; 0x6642 <MB_M_Timer_ISR+0x2e0>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_M_ReadReg(uint8_t MB_N, MB_Query *Query)
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || (LastProcSingle?MB_SingleQuery[MB_N].Qt:prw(&Query->Qt))*2!=MB_Frame[MB_N][2])
    64e8:	fc 2f       	mov	r31, r28
    64ea:	ee 27       	eor	r30, r30
    64ec:	e1 5e       	subi	r30, 0xE1	; 225
    64ee:	f4 4f       	sbci	r31, 0xF4	; 244
    64f0:	b0 81       	ld	r27, Z
    64f2:	fe 01       	movw	r30, r28
    64f4:	e1 50       	subi	r30, 0x01	; 1
    64f6:	f9 4f       	sbci	r31, 0xF9	; 249
    64f8:	80 81       	ld	r24, Z
    64fa:	90 e0       	ldi	r25, 0x00	; 0
    64fc:	8b 2e       	mov	r8, r27
    64fe:	99 24       	eor	r9, r9
    6500:	94 01       	movw	r18, r8
    6502:	2b 5f       	subi	r18, 0xFB	; 251
    6504:	3f 4f       	sbci	r19, 0xFF	; 255
    6506:	82 17       	cp	r24, r18
    6508:	93 07       	cpc	r25, r19
    650a:	09 f4       	brne	.+2      	; 0x650e <MB_M_Timer_ISR+0x1ac>
    650c:	94 c1       	rjmp	.+808    	; 0x6836 <MB_M_Timer_ISR+0x4d4>
			case 0x0F: case 0x10:
				Err = MB_M_Force(MB_N, Query);
				break;
			}
			if (Err) {
				MB_CPT[MB_N][2]++;
    650e:	f7 01       	movw	r30, r14
    6510:	ee 0f       	add	r30, r30
    6512:	ff 1f       	adc	r31, r31
    6514:	ee 0f       	add	r30, r30
    6516:	ff 1f       	adc	r31, r31
    6518:	e4 51       	subi	r30, 0x14	; 20
    651a:	f7 4f       	sbci	r31, 0xF7	; 247
    651c:	80 81       	ld	r24, Z
    651e:	91 81       	ldd	r25, Z+1	; 0x01
    6520:	01 96       	adiw	r24, 0x01	; 1
    6522:	91 83       	std	Z+1, r25	; 0x01
    6524:	80 83       	st	Z, r24
    6526:	9e cf       	rjmp	.-196    	; 0x6464 <MB_M_Timer_ISR+0x102>
		}
		if (MB_Frame[MB_N][0]!=Addr || MB_Frame[MB_N][1]!=Func)
			Over = FailSlave(MB_N);
		else {
			uint8_t Err;
			switch (Func) {
    6528:	96 30       	cpi	r25, 0x06	; 6
    652a:	09 f4       	brne	.+2      	; 0x652e <MB_M_Timer_ISR+0x1cc>
    652c:	18 c1       	rjmp	.+560    	; 0x675e <MB_M_Timer_ISR+0x3fc>
    652e:	96 30       	cpi	r25, 0x06	; 6
    6530:	08 f4       	brcc	.+2      	; 0x6534 <MB_M_Timer_ISR+0x1d2>
    6532:	43 c0       	rjmp	.+134    	; 0x65ba <MB_M_Timer_ISR+0x258>
    6534:	9f 50       	subi	r25, 0x0F	; 15
    6536:	92 30       	cpi	r25, 0x02	; 2
    6538:	08 f0       	brcs	.+2      	; 0x653c <MB_M_Timer_ISR+0x1da>
    653a:	3f c0       	rjmp	.+126    	; 0x65ba <MB_M_Timer_ISR+0x258>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_M_Force(uint8_t MB_N, MB_Query *Query)
{
	uint16_t StartAddr, Qt;
	if (LastProcSingle) {
    653c:	80 91 da 04 	lds	r24, 0x04DA
    6540:	88 23       	and	r24, r24
    6542:	09 f4       	brne	.+2      	; 0x6546 <MB_M_Timer_ISR+0x1e4>
    6544:	4e c1       	rjmp	.+668    	; 0x67e2 <MB_M_Timer_ISR+0x480>
		StartAddr	= MB_SingleQuery[MB_N].StartAddr;
    6546:	f7 01       	movw	r30, r14
    6548:	ee 0f       	add	r30, r30
    654a:	ff 1f       	adc	r31, r31
    654c:	ec 52       	subi	r30, 0x2C	; 44
    654e:	fb 4f       	sbci	r31, 0xFB	; 251
    6550:	80 80       	ld	r8, Z
    6552:	91 80       	ldd	r9, Z+1	; 0x01
		Qt				= MB_SingleQuery[MB_N].Qt;
    6554:	fe 01       	movw	r30, r28
    6556:	ee 0f       	add	r30, r30
    6558:	ff 1f       	adc	r31, r31
    655a:	ee 0f       	add	r30, r30
    655c:	ff 1f       	adc	r31, r31
    655e:	ee 0f       	add	r30, r30
    6560:	ff 1f       	adc	r31, r31
    6562:	ea 52       	subi	r30, 0x2A	; 42
    6564:	fb 4f       	sbci	r31, 0xFB	; 251
    6566:	40 81       	ld	r20, Z
    6568:	51 81       	ldd	r21, Z+1	; 0x01
	}
	else {
		StartAddr	= prw(&Query->StartAddr);
		Qt				= prw(&Query->Qt);
	}
	return MB_Frame_Sz[MB_N]!=8 || MB_FrameReg(MB_N, 2)!=StartAddr || MB_FrameReg(MB_N, 4)!=Qt;
    656a:	fe 01       	movw	r30, r28
    656c:	e1 50       	subi	r30, 0x01	; 1
    656e:	f9 4f       	sbci	r31, 0xF9	; 249
    6570:	80 81       	ld	r24, Z
    6572:	88 30       	cpi	r24, 0x08	; 8
    6574:	61 f6       	brne	.-104    	; 0x650e <MB_M_Timer_ISR+0x1ac>
    6576:	fc 2f       	mov	r31, r28
    6578:	ee 27       	eor	r30, r30
    657a:	e1 5e       	subi	r30, 0xE1	; 225
    657c:	f4 4f       	sbci	r31, 0xF4	; 244
    657e:	30 81       	ld	r19, Z
    6580:	20 e0       	ldi	r18, 0x00	; 0
    6582:	d6 01       	movw	r26, r12
    6584:	a3 5e       	subi	r26, 0xE3	; 227
    6586:	b4 4f       	sbci	r27, 0xF4	; 244
    6588:	13 96       	adiw	r26, 0x03	; 3
    658a:	8c 91       	ld	r24, X
    658c:	13 97       	sbiw	r26, 0x03	; 3
    658e:	90 e0       	ldi	r25, 0x00	; 0
    6590:	28 2b       	or	r18, r24
    6592:	39 2b       	or	r19, r25
    6594:	28 15       	cp	r18, r8
    6596:	39 05       	cpc	r19, r9
    6598:	09 f0       	breq	.+2      	; 0x659c <MB_M_Timer_ISR+0x23a>
    659a:	b9 cf       	rjmp	.-142    	; 0x650e <MB_M_Timer_ISR+0x1ac>
    659c:	fc 2f       	mov	r31, r28
    659e:	ee 27       	eor	r30, r30
    65a0:	ef 5d       	subi	r30, 0xDF	; 223
    65a2:	f4 4f       	sbci	r31, 0xF4	; 244
    65a4:	90 81       	ld	r25, Z
    65a6:	80 e0       	ldi	r24, 0x00	; 0
    65a8:	15 96       	adiw	r26, 0x05	; 5
    65aa:	2c 91       	ld	r18, X
    65ac:	30 e0       	ldi	r19, 0x00	; 0
    65ae:	82 2b       	or	r24, r18
    65b0:	93 2b       	or	r25, r19
    65b2:	84 17       	cp	r24, r20
    65b4:	95 07       	cpc	r25, r21
    65b6:	09 f0       	breq	.+2      	; 0x65ba <MB_M_Timer_ISR+0x258>
    65b8:	aa cf       	rjmp	.-172    	; 0x650e <MB_M_Timer_ISR+0x1ac>
			}
			if (Err) {
				MB_CPT[MB_N][2]++;
				Over = FailSlave(MB_N);
			}
			else if (LastProcSingle)
    65ba:	80 91 da 04 	lds	r24, 0x04DA
    65be:	88 23       	and	r24, r24
    65c0:	41 f0       	breq	.+16     	; 0x65d2 <MB_M_Timer_ISR+0x270>
				MB_SingleState[MB_N] = MB_SingleIdle;
    65c2:	d5 01       	movw	r26, r10
    65c4:	1c 92       	st	X, r1
			}
		}
		/*if (Over)
			USART_Func(MB_N, LED);*/
	}
	StartTimer16(TD_MB_Idle+MB_N, Over?MB_M_Period[MB_N]:MB_M_Pause_Min);
    65c6:	80 91 e0 04 	lds	r24, 0x04E0
    65ca:	81 0f       	add	r24, r17
    65cc:	65 e0       	ldi	r22, 0x05	; 5
    65ce:	70 e0       	ldi	r23, 0x00	; 0
    65d0:	58 cf       	rjmp	.-336    	; 0x6482 <MB_M_Timer_ISR+0x120>
				Over = FailSlave(MB_N);
			}
			else if (LastProcSingle)
				MB_SingleState[MB_N] = MB_SingleIdle;
			else {
				SlaveOff[MB_N] &=~((uint32_t)1<<CurrSlave[MB_N]);
    65d2:	ef ed       	ldi	r30, 0xDF	; 223
    65d4:	f8 e0       	ldi	r31, 0x08	; 8
    65d6:	ee 0e       	add	r14, r30
    65d8:	ff 1e       	adc	r15, r31
    65da:	9e 01       	movw	r18, r28
    65dc:	24 5b       	subi	r18, 0xB4	; 180
    65de:	39 4f       	sbci	r19, 0xF9	; 249
    65e0:	81 e0       	ldi	r24, 0x01	; 1
    65e2:	90 e0       	ldi	r25, 0x00	; 0
    65e4:	a0 e0       	ldi	r26, 0x00	; 0
    65e6:	b0 e0       	ldi	r27, 0x00	; 0
    65e8:	f9 01       	movw	r30, r18
    65ea:	00 80       	ld	r0, Z
    65ec:	04 c0       	rjmp	.+8      	; 0x65f6 <MB_M_Timer_ISR+0x294>
    65ee:	88 0f       	add	r24, r24
    65f0:	99 1f       	adc	r25, r25
    65f2:	aa 1f       	adc	r26, r26
    65f4:	bb 1f       	adc	r27, r27
    65f6:	0a 94       	dec	r0
    65f8:	d2 f7       	brpl	.-12     	; 0x65ee <MB_M_Timer_ISR+0x28c>
    65fa:	80 95       	com	r24
    65fc:	90 95       	com	r25
    65fe:	a0 95       	com	r26
    6600:	b0 95       	com	r27
    6602:	f7 01       	movw	r30, r14
    6604:	20 81       	ld	r18, Z
    6606:	31 81       	ldd	r19, Z+1	; 0x01
    6608:	42 81       	ldd	r20, Z+2	; 0x02
    660a:	53 81       	ldd	r21, Z+3	; 0x03
    660c:	82 23       	and	r24, r18
    660e:	93 23       	and	r25, r19
    6610:	a4 23       	and	r26, r20
    6612:	b5 23       	and	r27, r21
    6614:	80 83       	st	Z, r24
    6616:	91 83       	std	Z+1, r25	; 0x01
    6618:	a2 83       	std	Z+2, r26	; 0x02
    661a:	b3 83       	std	Z+3, r27	; 0x03
				if (++CurrQuery[MB_N]==prb(&Slave->QueryQt))
    661c:	fe 01       	movw	r30, r28
    661e:	e3 5b       	subi	r30, 0xB3	; 179
    6620:	f9 4f       	sbci	r31, 0xF9	; 249
    6622:	80 81       	ld	r24, Z
    6624:	8f 5f       	subi	r24, 0xFF	; 255
    6626:	80 83       	st	Z, r24
    6628:	6d 5f       	subi	r22, 0xFD	; 253
    662a:	7f 4f       	sbci	r23, 0xFF	; 255
    662c:	fb 01       	movw	r30, r22
    662e:	94 91       	lpm	r25, Z+
    6630:	89 17       	cp	r24, r25
    6632:	09 f4       	brne	.+2      	; 0x6636 <MB_M_Timer_ISR+0x2d4>
    6634:	55 c1       	rjmp	.+682    	; 0x68e0 <MB_M_Timer_ISR+0x57e>
    6636:	90 e0       	ldi	r25, 0x00	; 0
					Over = NextSlave(MB_N);
				Try[MB_N] = 0;
    6638:	fe 01       	movw	r30, r28
    663a:	e5 52       	subi	r30, 0x25	; 37
    663c:	fb 4f       	sbci	r31, 0xFB	; 251
    663e:	10 82       	st	Z, r1
    6640:	15 cf       	rjmp	.-470    	; 0x646c <MB_M_Timer_ISR+0x10a>
		}
		if (MB_Frame[MB_N][0]!=Addr || MB_Frame[MB_N][1]!=Func)
			Over = FailSlave(MB_N);
		else {
			uint8_t Err;
			switch (Func) {
    6642:	91 30       	cpi	r25, 0x01	; 1
    6644:	08 f4       	brcc	.+2      	; 0x6648 <MB_M_Timer_ISR+0x2e6>
    6646:	b9 cf       	rjmp	.-142    	; 0x65ba <MB_M_Timer_ISR+0x258>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_M_ReadDiscr(uint8_t MB_N, MB_Query *Query)
{
	uint8_t Qt = LastProcSingle ? MB_SingleQuery[MB_N].Qt : prb((uint8_t*)&Query->Qt);
    6648:	80 91 da 04 	lds	r24, 0x04DA
    664c:	88 23       	and	r24, r24
    664e:	09 f4       	brne	.+2      	; 0x6652 <MB_M_Timer_ISR+0x2f0>
    6650:	eb c0       	rjmp	.+470    	; 0x6828 <MB_M_Timer_ISR+0x4c6>
    6652:	fe 01       	movw	r30, r28
    6654:	ee 0f       	add	r30, r30
    6656:	ff 1f       	adc	r31, r31
    6658:	ee 0f       	add	r30, r30
    665a:	ff 1f       	adc	r31, r31
    665c:	ee 0f       	add	r30, r30
    665e:	ff 1f       	adc	r31, r31
    6660:	ea 52       	subi	r30, 0x2A	; 42
    6662:	fb 4f       	sbci	r31, 0xFB	; 251
    6664:	b0 81       	ld	r27, Z
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || Qt/8+((Qt%8)>0)!=MB_Frame[MB_N][2])
    6666:	fc 2f       	mov	r31, r28
    6668:	ee 27       	eor	r30, r30
    666a:	e1 5e       	subi	r30, 0xE1	; 225
    666c:	f4 4f       	sbci	r31, 0xF4	; 244
    666e:	80 81       	ld	r24, Z
    6670:	88 2e       	mov	r8, r24
    6672:	99 24       	eor	r9, r9
    6674:	fe 01       	movw	r30, r28
    6676:	e1 50       	subi	r30, 0x01	; 1
    6678:	f9 4f       	sbci	r31, 0xF9	; 249
    667a:	80 81       	ld	r24, Z
    667c:	90 e0       	ldi	r25, 0x00	; 0
    667e:	94 01       	movw	r18, r8
    6680:	2b 5f       	subi	r18, 0xFB	; 251
    6682:	3f 4f       	sbci	r19, 0xFF	; 255
    6684:	82 17       	cp	r24, r18
    6686:	93 07       	cpc	r25, r19
    6688:	09 f0       	breq	.+2      	; 0x668c <MB_M_Timer_ISR+0x32a>
    668a:	41 cf       	rjmp	.-382    	; 0x650e <MB_M_Timer_ISR+0x1ac>
    668c:	20 e0       	ldi	r18, 0x00	; 0
    668e:	30 e0       	ldi	r19, 0x00	; 0
    6690:	6b 2e       	mov	r6, r27
    6692:	77 24       	eor	r7, r7
    6694:	c3 01       	movw	r24, r6
    6696:	87 70       	andi	r24, 0x07	; 7
    6698:	90 70       	andi	r25, 0x00	; 0
    669a:	18 16       	cp	r1, r24
    669c:	19 06       	cpc	r1, r25
    669e:	14 f4       	brge	.+4      	; 0x66a4 <MB_M_Timer_ISR+0x342>
    66a0:	21 e0       	ldi	r18, 0x01	; 1
    66a2:	30 e0       	ldi	r19, 0x00	; 0
    66a4:	b6 95       	lsr	r27
    66a6:	b6 95       	lsr	r27
    66a8:	b6 95       	lsr	r27
    66aa:	2b 0f       	add	r18, r27
    66ac:	31 1d       	adc	r19, r1
    66ae:	82 16       	cp	r8, r18
    66b0:	93 06       	cpc	r9, r19
    66b2:	09 f0       	breq	.+2      	; 0x66b6 <MB_M_Timer_ISR+0x354>
    66b4:	2c cf       	rjmp	.-424    	; 0x650e <MB_M_Timer_ISR+0x1ac>
		return 1;
	uint8_t *Discr;
	uint8_t Pin;
	if (LastProcSingle) {
    66b6:	80 91 da 04 	lds	r24, 0x04DA
    66ba:	88 23       	and	r24, r24
    66bc:	09 f4       	brne	.+2      	; 0x66c0 <MB_M_Timer_ISR+0x35e>
    66be:	1d c1       	rjmp	.+570    	; 0x68fa <MB_M_Timer_ISR+0x598>
		Discr = MB_SingleQuery[MB_N].Buf;
    66c0:	fe 01       	movw	r30, r28
    66c2:	ee 0f       	add	r30, r30
    66c4:	ff 1f       	adc	r31, r31
    66c6:	ee 0f       	add	r30, r30
    66c8:	ff 1f       	adc	r31, r31
    66ca:	ee 0f       	add	r30, r30
    66cc:	ff 1f       	adc	r31, r31
    66ce:	ee 52       	subi	r30, 0x2E	; 46
    66d0:	fb 4f       	sbci	r31, 0xFB	; 251
    66d2:	86 80       	ldd	r8, Z+6	; 0x06
    66d4:	97 80       	ldd	r9, Z+7	; 0x07
    66d6:	00 e0       	ldi	r16, 0x00	; 0
	}
	else {
		Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
		Pin = prw(&Query->AllocAddr);
	}
	for (uint16_t i=0; i<Qt; i++) {
    66d8:	61 14       	cp	r6, r1
    66da:	71 04       	cpc	r7, r1
    66dc:	09 f4       	brne	.+2      	; 0x66e0 <MB_M_Timer_ISR+0x37e>
    66de:	6d cf       	rjmp	.-294    	; 0x65ba <MB_M_Timer_ISR+0x258>
    66e0:	40 e0       	ldi	r20, 0x00	; 0
    66e2:	50 e0       	ldi	r21, 0x00	; 0
		uint8_t j = Pin+i;
		uint8_t Byte=j/8, Bit=1<<j%8;
    66e4:	21 e0       	ldi	r18, 0x01	; 1
    66e6:	42 2e       	mov	r4, r18
    66e8:	51 2c       	mov	r5, r1
		if (MB_Frame[MB_N][3+i/8] &(1<<i%8))
    66ea:	8d e1       	ldi	r24, 0x1D	; 29
    66ec:	9b e0       	ldi	r25, 0x0B	; 11
    66ee:	c8 0e       	add	r12, r24
    66f0:	d9 1e       	adc	r13, r25
    66f2:	0c c0       	rjmp	.+24     	; 0x670c <MB_M_Timer_ISR+0x3aa>
			Discr[Byte] |=Bit;
    66f4:	f4 01       	movw	r30, r8
    66f6:	eb 0f       	add	r30, r27
    66f8:	f1 1d       	adc	r31, r1
    66fa:	80 81       	ld	r24, Z
    66fc:	8a 2b       	or	r24, r26
    66fe:	80 83       	st	Z, r24
	}
	else {
		Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
		Pin = prw(&Query->AllocAddr);
	}
	for (uint16_t i=0; i<Qt; i++) {
    6700:	4f 5f       	subi	r20, 0xFF	; 255
    6702:	5f 4f       	sbci	r21, 0xFF	; 255
    6704:	46 15       	cp	r20, r6
    6706:	57 05       	cpc	r21, r7
    6708:	08 f0       	brcs	.+2      	; 0x670c <MB_M_Timer_ISR+0x3aa>
    670a:	57 cf       	rjmp	.-338    	; 0x65ba <MB_M_Timer_ISR+0x258>
    670c:	80 2f       	mov	r24, r16
    670e:	84 0f       	add	r24, r20
		uint8_t j = Pin+i;
		uint8_t Byte=j/8, Bit=1<<j%8;
    6710:	b8 2f       	mov	r27, r24
    6712:	b6 95       	lsr	r27
    6714:	b6 95       	lsr	r27
    6716:	b6 95       	lsr	r27
    6718:	87 70       	andi	r24, 0x07	; 7
    671a:	a4 2d       	mov	r26, r4
    671c:	01 c0       	rjmp	.+2      	; 0x6720 <MB_M_Timer_ISR+0x3be>
    671e:	aa 0f       	add	r26, r26
    6720:	8a 95       	dec	r24
    6722:	ea f7       	brpl	.-6      	; 0x671e <MB_M_Timer_ISR+0x3bc>
		if (MB_Frame[MB_N][3+i/8] &(1<<i%8))
    6724:	fa 01       	movw	r30, r20
    6726:	f6 95       	lsr	r31
    6728:	e7 95       	ror	r30
    672a:	f6 95       	lsr	r31
    672c:	e7 95       	ror	r30
    672e:	f6 95       	lsr	r31
    6730:	e7 95       	ror	r30
    6732:	ec 0d       	add	r30, r12
    6734:	fd 1d       	adc	r31, r13
    6736:	83 81       	ldd	r24, Z+3	; 0x03
    6738:	90 e0       	ldi	r25, 0x00	; 0
    673a:	9a 01       	movw	r18, r20
    673c:	27 70       	andi	r18, 0x07	; 7
    673e:	30 70       	andi	r19, 0x00	; 0
    6740:	02 c0       	rjmp	.+4      	; 0x6746 <MB_M_Timer_ISR+0x3e4>
    6742:	95 95       	asr	r25
    6744:	87 95       	ror	r24
    6746:	2a 95       	dec	r18
    6748:	e2 f7       	brpl	.-8      	; 0x6742 <MB_M_Timer_ISR+0x3e0>
    674a:	80 fd       	sbrc	r24, 0
    674c:	d3 cf       	rjmp	.-90     	; 0x66f4 <MB_M_Timer_ISR+0x392>
			Discr[Byte] |=Bit;
		else
			Discr[Byte] &=~Bit;
    674e:	f4 01       	movw	r30, r8
    6750:	eb 0f       	add	r30, r27
    6752:	f1 1d       	adc	r31, r1
    6754:	a0 95       	com	r26
    6756:	80 81       	ld	r24, Z
    6758:	8a 23       	and	r24, r26
    675a:	80 83       	st	Z, r24
    675c:	d1 cf       	rjmp	.-94     	; 0x6700 <MB_M_Timer_ISR+0x39e>
inline static uint8_t
MB_M_PresetSingle(uint8_t MB_N, MB_Query *Query)
{
	uint16_t StartAddr;
	uint16_t *Reg;
	if (LastProcSingle) {
    675e:	80 91 da 04 	lds	r24, 0x04DA
    6762:	88 23       	and	r24, r24
    6764:	09 f4       	brne	.+2      	; 0x6768 <MB_M_Timer_ISR+0x406>
    6766:	46 c0       	rjmp	.+140    	; 0x67f4 <MB_M_Timer_ISR+0x492>
		StartAddr = MB_SingleQuery[MB_N].StartAddr;
    6768:	f7 01       	movw	r30, r14
    676a:	ee 0f       	add	r30, r30
    676c:	ff 1f       	adc	r31, r31
    676e:	ec 52       	subi	r30, 0x2C	; 44
    6770:	fb 4f       	sbci	r31, 0xFB	; 251
    6772:	80 80       	ld	r8, Z
    6774:	91 80       	ldd	r9, Z+1	; 0x01
		Reg = MB_SingleQuery[MB_N].Buf;
    6776:	fe 01       	movw	r30, r28
    6778:	ee 0f       	add	r30, r30
    677a:	ff 1f       	adc	r31, r31
    677c:	ee 0f       	add	r30, r30
    677e:	ff 1f       	adc	r31, r31
    6780:	ee 0f       	add	r30, r30
    6782:	ff 1f       	adc	r31, r31
    6784:	ee 52       	subi	r30, 0x2E	; 46
    6786:	fb 4f       	sbci	r31, 0xFB	; 251
    6788:	a6 81       	ldd	r26, Z+6	; 0x06
    678a:	b7 81       	ldd	r27, Z+7	; 0x07
	}
	else {
		StartAddr = prw(&Query->StartAddr);
		Reg = (uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+prw(&Query->AllocAddr);
	}
	return MB_Frame_Sz[MB_N]!=8 || MB_FrameReg(MB_N, 2)!=StartAddr || MB_FrameReg(MB_N, 4)!=*Reg;
    678c:	fe 01       	movw	r30, r28
    678e:	e1 50       	subi	r30, 0x01	; 1
    6790:	f9 4f       	sbci	r31, 0xF9	; 249
    6792:	80 81       	ld	r24, Z
    6794:	88 30       	cpi	r24, 0x08	; 8
    6796:	09 f0       	breq	.+2      	; 0x679a <MB_M_Timer_ISR+0x438>
    6798:	ba ce       	rjmp	.-652    	; 0x650e <MB_M_Timer_ISR+0x1ac>
    679a:	fc 2f       	mov	r31, r28
    679c:	ee 27       	eor	r30, r30
    679e:	e1 5e       	subi	r30, 0xE1	; 225
    67a0:	f4 4f       	sbci	r31, 0xF4	; 244
    67a2:	30 81       	ld	r19, Z
    67a4:	20 e0       	ldi	r18, 0x00	; 0
    67a6:	a6 01       	movw	r20, r12
    67a8:	43 5e       	subi	r20, 0xE3	; 227
    67aa:	54 4f       	sbci	r21, 0xF4	; 244
    67ac:	fa 01       	movw	r30, r20
    67ae:	83 81       	ldd	r24, Z+3	; 0x03
    67b0:	90 e0       	ldi	r25, 0x00	; 0
    67b2:	28 2b       	or	r18, r24
    67b4:	39 2b       	or	r19, r25
    67b6:	28 15       	cp	r18, r8
    67b8:	39 05       	cpc	r19, r9
    67ba:	09 f0       	breq	.+2      	; 0x67be <MB_M_Timer_ISR+0x45c>
    67bc:	a8 ce       	rjmp	.-688    	; 0x650e <MB_M_Timer_ISR+0x1ac>
    67be:	fc 2f       	mov	r31, r28
    67c0:	ee 27       	eor	r30, r30
    67c2:	ef 5d       	subi	r30, 0xDF	; 223
    67c4:	f4 4f       	sbci	r31, 0xF4	; 244
    67c6:	30 81       	ld	r19, Z
    67c8:	20 e0       	ldi	r18, 0x00	; 0
    67ca:	fa 01       	movw	r30, r20
    67cc:	85 81       	ldd	r24, Z+5	; 0x05
    67ce:	90 e0       	ldi	r25, 0x00	; 0
    67d0:	28 2b       	or	r18, r24
    67d2:	39 2b       	or	r19, r25
    67d4:	8d 91       	ld	r24, X+
    67d6:	9c 91       	ld	r25, X
    67d8:	28 17       	cp	r18, r24
    67da:	39 07       	cpc	r19, r25
    67dc:	09 f0       	breq	.+2      	; 0x67e0 <MB_M_Timer_ISR+0x47e>
    67de:	97 ce       	rjmp	.-722    	; 0x650e <MB_M_Timer_ISR+0x1ac>
    67e0:	ec ce       	rjmp	.-552    	; 0x65ba <MB_M_Timer_ISR+0x258>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    67e2:	fa 01       	movw	r30, r20
    67e4:	31 96       	adiw	r30, 0x01	; 1
    67e6:	85 90       	lpm	r8, Z+
    67e8:	94 90       	lpm	r9, Z+

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    67ea:	fa 01       	movw	r30, r20
    67ec:	33 96       	adiw	r30, 0x03	; 3
    67ee:	45 91       	lpm	r20, Z+
    67f0:	54 91       	lpm	r21, Z+
    67f2:	bb ce       	rjmp	.-650    	; 0x656a <MB_M_Timer_ISR+0x208>
    67f4:	fa 01       	movw	r30, r20
    67f6:	31 96       	adiw	r30, 0x01	; 1
    67f8:	85 90       	lpm	r8, Z+
    67fa:	94 90       	lpm	r9, Z+
    67fc:	fe 01       	movw	r30, r28
    67fe:	ee 0f       	add	r30, r30
    6800:	ff 1f       	adc	r31, r31
    6802:	ee 0f       	add	r30, r30
    6804:	ff 1f       	adc	r31, r31
    6806:	ee 0f       	add	r30, r30
    6808:	ff 1f       	adc	r31, r31
    680a:	ee 0f       	add	r30, r30
    680c:	ff 1f       	adc	r31, r31
    680e:	ec 5c       	subi	r30, 0xCC	; 204
    6810:	fc 4f       	sbci	r31, 0xFC	; 252
    6812:	a5 91       	lpm	r26, Z+
    6814:	b4 91       	lpm	r27, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    6816:	fa 01       	movw	r30, r20
    6818:	35 96       	adiw	r30, 0x05	; 5
    681a:	85 91       	lpm	r24, Z+
    681c:	94 91       	lpm	r25, Z+
		StartAddr = MB_SingleQuery[MB_N].StartAddr;
		Reg = MB_SingleQuery[MB_N].Buf;
	}
	else {
		StartAddr = prw(&Query->StartAddr);
		Reg = (uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+prw(&Query->AllocAddr);
    681e:	88 0f       	add	r24, r24
    6820:	99 1f       	adc	r25, r25
    6822:	a8 0f       	add	r26, r24
    6824:	b9 1f       	adc	r27, r25
    6826:	b2 cf       	rjmp	.-156    	; 0x678c <MB_M_Timer_ISR+0x42a>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    6828:	4d 5f       	subi	r20, 0xFD	; 253
    682a:	5f 4f       	sbci	r21, 0xFF	; 255
    682c:	fa 01       	movw	r30, r20
    682e:	b4 91       	lpm	r27, Z+
    6830:	43 50       	subi	r20, 0x03	; 3
    6832:	50 40       	sbci	r21, 0x00	; 0
    6834:	18 cf       	rjmp	.-464    	; 0x6666 <MB_M_Timer_ISR+0x304>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_M_ReadReg(uint8_t MB_N, MB_Query *Query)
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || (LastProcSingle?MB_SingleQuery[MB_N].Qt:prw(&Query->Qt))*2!=MB_Frame[MB_N][2])
    6836:	80 91 da 04 	lds	r24, 0x04DA
    683a:	88 23       	and	r24, r24
    683c:	09 f4       	brne	.+2      	; 0x6840 <MB_M_Timer_ISR+0x4de>
    683e:	55 c0       	rjmp	.+170    	; 0x68ea <MB_M_Timer_ISR+0x588>
    6840:	fe 01       	movw	r30, r28
    6842:	ee 0f       	add	r30, r30
    6844:	ff 1f       	adc	r31, r31
    6846:	ee 0f       	add	r30, r30
    6848:	ff 1f       	adc	r31, r31
    684a:	ee 0f       	add	r30, r30
    684c:	ff 1f       	adc	r31, r31
    684e:	ea 52       	subi	r30, 0x2A	; 42
    6850:	fb 4f       	sbci	r31, 0xFB	; 251
    6852:	20 81       	ld	r18, Z
    6854:	31 81       	ldd	r19, Z+1	; 0x01
    6856:	22 0f       	add	r18, r18
    6858:	33 1f       	adc	r19, r19
    685a:	82 16       	cp	r8, r18
    685c:	93 06       	cpc	r9, r19
    685e:	09 f0       	breq	.+2      	; 0x6862 <MB_M_Timer_ISR+0x500>
    6860:	56 ce       	rjmp	.-852    	; 0x650e <MB_M_Timer_ISR+0x1ac>
		return 1;
	uint16_t *Reg = LastProcSingle ?
		MB_SingleQuery[MB_N].Buf
	:
		(uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg))+prw(&Query->AllocAddr);
    6862:	80 91 da 04 	lds	r24, 0x04DA
    6866:	88 23       	and	r24, r24
    6868:	09 f4       	brne	.+2      	; 0x686c <MB_M_Timer_ISR+0x50a>
    686a:	5e c0       	rjmp	.+188    	; 0x6928 <MB_M_Timer_ISR+0x5c6>
    686c:	fe 01       	movw	r30, r28
    686e:	ee 0f       	add	r30, r30
    6870:	ff 1f       	adc	r31, r31
    6872:	ee 0f       	add	r30, r30
    6874:	ff 1f       	adc	r31, r31
    6876:	ee 0f       	add	r30, r30
    6878:	ff 1f       	adc	r31, r31
    687a:	ee 52       	subi	r30, 0x2E	; 46
    687c:	fb 4f       	sbci	r31, 0xFB	; 251
    687e:	26 81       	ldd	r18, Z+6	; 0x06
    6880:	37 81       	ldd	r19, Z+7	; 0x07
	for (int8_t j=MB_Frame[MB_N][2]/2-1; j>=0; j--) {
    6882:	4b 2f       	mov	r20, r27
    6884:	46 95       	lsr	r20
    6886:	41 50       	subi	r20, 0x01	; 1
    6888:	47 fd       	sbrc	r20, 7
    688a:	97 ce       	rjmp	.-722    	; 0x65ba <MB_M_Timer_ISR+0x258>
    688c:	84 2f       	mov	r24, r20
    688e:	99 27       	eor	r25, r25
    6890:	87 fd       	sbrc	r24, 7
    6892:	90 95       	com	r25
    6894:	88 0f       	add	r24, r24
    6896:	99 1f       	adc	r25, r25
    6898:	58 2f       	mov	r21, r24
    689a:	5d 5f       	subi	r21, 0xFD	; 253
    689c:	28 0f       	add	r18, r24
    689e:	39 1f       	adc	r19, r25
		int8_t i = j*2;
		Reg[j] = MB_FrameReg(MB_N, 3+i);
    68a0:	8d e1       	ldi	r24, 0x1D	; 29
    68a2:	88 2e       	mov	r8, r24
    68a4:	8b e0       	ldi	r24, 0x0B	; 11
    68a6:	98 2e       	mov	r9, r24
    68a8:	8c 0c       	add	r8, r12
    68aa:	9d 1c       	adc	r9, r13
    68ac:	e5 2f       	mov	r30, r21
    68ae:	f0 e0       	ldi	r31, 0x00	; 0
    68b0:	d4 01       	movw	r26, r8
    68b2:	ae 0f       	add	r26, r30
    68b4:	bf 1f       	adc	r27, r31
    68b6:	11 96       	adiw	r26, 0x01	; 1
    68b8:	8c 91       	ld	r24, X
    68ba:	90 e0       	ldi	r25, 0x00	; 0
    68bc:	ec 0d       	add	r30, r12
    68be:	fd 1d       	adc	r31, r13
    68c0:	e3 5e       	subi	r30, 0xE3	; 227
    68c2:	f4 4f       	sbci	r31, 0xF4	; 244
    68c4:	f0 81       	ld	r31, Z
    68c6:	e0 e0       	ldi	r30, 0x00	; 0
    68c8:	8e 2b       	or	r24, r30
    68ca:	9f 2b       	or	r25, r31
    68cc:	d9 01       	movw	r26, r18
    68ce:	8d 93       	st	X+, r24
    68d0:	9c 93       	st	X, r25
		return 1;
	uint16_t *Reg = LastProcSingle ?
		MB_SingleQuery[MB_N].Buf
	:
		(uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg))+prw(&Query->AllocAddr);
	for (int8_t j=MB_Frame[MB_N][2]/2-1; j>=0; j--) {
    68d2:	41 50       	subi	r20, 0x01	; 1
    68d4:	52 50       	subi	r21, 0x02	; 2
    68d6:	22 50       	subi	r18, 0x02	; 2
    68d8:	30 40       	sbci	r19, 0x00	; 0
    68da:	47 ff       	sbrs	r20, 7
    68dc:	e7 cf       	rjmp	.-50     	; 0x68ac <MB_M_Timer_ISR+0x54a>
    68de:	6d ce       	rjmp	.-806    	; 0x65ba <MB_M_Timer_ISR+0x258>
			else if (LastProcSingle)
				MB_SingleState[MB_N] = MB_SingleIdle;
			else {
				SlaveOff[MB_N] &=~((uint32_t)1<<CurrSlave[MB_N]);
				if (++CurrQuery[MB_N]==prb(&Slave->QueryQt))
					Over = NextSlave(MB_N);
    68e0:	81 2f       	mov	r24, r17
    68e2:	0e 94 68 30 	call	0x60d0	; 0x60d0 <NextSlave>
    68e6:	98 2f       	mov	r25, r24
    68e8:	a7 ce       	rjmp	.-690    	; 0x6638 <MB_M_Timer_ISR+0x2d6>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    68ea:	ca 01       	movw	r24, r20
    68ec:	03 96       	adiw	r24, 0x03	; 3
    68ee:	fc 01       	movw	r30, r24
    68f0:	25 91       	lpm	r18, Z+
    68f2:	34 91       	lpm	r19, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_M_ReadReg(uint8_t MB_N, MB_Query *Query)
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || (LastProcSingle?MB_SingleQuery[MB_N].Qt:prw(&Query->Qt))*2!=MB_Frame[MB_N][2])
    68f4:	22 0f       	add	r18, r18
    68f6:	33 1f       	adc	r19, r19
    68f8:	b0 cf       	rjmp	.-160    	; 0x685a <MB_M_Timer_ISR+0x4f8>
	if (LastProcSingle) {
		Discr = MB_SingleQuery[MB_N].Buf;
		Pin = 0;
	}
	else {
		Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
    68fa:	a1 30       	cpi	r26, 0x01	; 1
    68fc:	59 f1       	breq	.+86     	; 0x6954 <MB_M_Timer_ISR+0x5f2>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    68fe:	f7 01       	movw	r30, r14
    6900:	ee 0f       	add	r30, r30
    6902:	ff 1f       	adc	r31, r31
    6904:	ee 0f       	add	r30, r30
    6906:	ff 1f       	adc	r31, r31
    6908:	e0 5d       	subi	r30, 0xD0	; 208
    690a:	fc 4f       	sbci	r31, 0xFC	; 252
    690c:	85 91       	lpm	r24, Z+
    690e:	94 91       	lpm	r25, Z+
    6910:	e8 2f       	mov	r30, r24
    6912:	89 2f       	mov	r24, r25
    6914:	2e 2f       	mov	r18, r30
    6916:	38 2f       	mov	r19, r24
    6918:	c9 01       	movw	r24, r18
    691a:	4c 01       	movw	r8, r24

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    691c:	fa 01       	movw	r30, r20
    691e:	35 96       	adiw	r30, 0x05	; 5
    6920:	85 91       	lpm	r24, Z+
    6922:	94 91       	lpm	r25, Z+
		Pin = prw(&Query->AllocAddr);
    6924:	08 2f       	mov	r16, r24
    6926:	d8 ce       	rjmp	.-592    	; 0x66d8 <MB_M_Timer_ISR+0x376>
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || (LastProcSingle?MB_SingleQuery[MB_N].Qt:prw(&Query->Qt))*2!=MB_Frame[MB_N][2])
		return 1;
	uint16_t *Reg = LastProcSingle ?
		MB_SingleQuery[MB_N].Buf
	:
		(uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg))+prw(&Query->AllocAddr);
    6928:	a3 30       	cpi	r26, 0x03	; 3
    692a:	11 f1       	breq	.+68     	; 0x6970 <MB_M_Timer_ISR+0x60e>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    692c:	fe 01       	movw	r30, r28
    692e:	e2 95       	swap	r30
    6930:	f2 95       	swap	r31
    6932:	f0 7f       	andi	r31, 0xF0	; 240
    6934:	fe 27       	eor	r31, r30
    6936:	e0 7f       	andi	r30, 0xF0	; 240
    6938:	fe 27       	eor	r31, r30
    693a:	e8 5c       	subi	r30, 0xC8	; 200
    693c:	fc 4f       	sbci	r31, 0xFC	; 252
    693e:	85 91       	lpm	r24, Z+
    6940:	94 91       	lpm	r25, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    6942:	fa 01       	movw	r30, r20
    6944:	35 96       	adiw	r30, 0x05	; 5
    6946:	25 91       	lpm	r18, Z+
    6948:	34 91       	lpm	r19, Z+
    694a:	22 0f       	add	r18, r18
    694c:	33 1f       	adc	r19, r19
    694e:	28 0f       	add	r18, r24
    6950:	39 1f       	adc	r19, r25
    6952:	97 cf       	rjmp	.-210    	; 0x6882 <MB_M_Timer_ISR+0x520>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6954:	fe 01       	movw	r30, r28
    6956:	e2 95       	swap	r30
    6958:	f2 95       	swap	r31
    695a:	f0 7f       	andi	r31, 0xF0	; 240
    695c:	fe 27       	eor	r31, r30
    695e:	e0 7f       	andi	r30, 0xF0	; 240
    6960:	fe 27       	eor	r31, r30
    6962:	e4 5d       	subi	r30, 0xD4	; 212
    6964:	fc 4f       	sbci	r31, 0xFC	; 252
    6966:	85 91       	lpm	r24, Z+
    6968:	94 91       	lpm	r25, Z+
    696a:	e8 2f       	mov	r30, r24
    696c:	89 2f       	mov	r24, r25
    696e:	d2 cf       	rjmp	.-92     	; 0x6914 <MB_M_Timer_ISR+0x5b2>

// ~~~~~~~~~~~~~~~~~~
void
MB_M_Tx(uint8_t MB_N)
{
	StartTimer16(TD_MB_Idle+MB_N, MB_M_Timeout[MB_N]);
    6970:	fe 01       	movw	r30, r28
    6972:	ee 0f       	add	r30, r30
    6974:	ff 1f       	adc	r31, r31
    6976:	ee 0f       	add	r30, r30
    6978:	ff 1f       	adc	r31, r31
    697a:	ee 0f       	add	r30, r30
    697c:	ff 1f       	adc	r31, r31
    697e:	ee 0f       	add	r30, r30
    6980:	ff 1f       	adc	r31, r31
    6982:	ec 5c       	subi	r30, 0xCC	; 204
    6984:	fc 4f       	sbci	r31, 0xFC	; 252
    6986:	85 91       	lpm	r24, Z+
    6988:	94 91       	lpm	r25, Z+
    698a:	db cf       	rjmp	.-74     	; 0x6942 <MB_M_Timer_ISR+0x5e0>

0000698c <MB_M_Tx>:
    698c:	90 91 e0 04 	lds	r25, 0x04E0
    6990:	eb ed       	ldi	r30, 0xDB	; 219
    6992:	f8 e0       	ldi	r31, 0x08	; 8
    6994:	e8 0f       	add	r30, r24
    6996:	f1 1d       	adc	r31, r1
    6998:	60 81       	ld	r22, Z
    699a:	89 0f       	add	r24, r25
    699c:	70 e0       	ldi	r23, 0x00	; 0
    699e:	0e 94 1d 1a 	call	0x343a	; 0x343a <StartTimer16>
}
    69a2:	08 95       	ret

000069a4 <Modbus_TX>:
}

// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_TX(usart_t *usart)
{
    69a4:	cf 92       	push	r12
    69a6:	df 92       	push	r13
    69a8:	ef 92       	push	r14
    69aa:	ff 92       	push	r15
    69ac:	1f 93       	push	r17
    69ae:	cf 93       	push	r28
    69b0:	df 93       	push	r29
    69b2:	dc 01       	movw	r26, r24
    69b4:	e1 e1       	ldi	r30, 0x11	; 17
    69b6:	fc e2       	ldi	r31, 0x2C	; 44
    69b8:	85 91       	lpm	r24, Z+
    69ba:	94 91       	lpm	r25, Z+
// ~~~~~~~~~~~~~~~~~~~~~~
static uint8_t
MB_Port_N(usart_t *usart)
{
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Port[MB_N].usart_field)!=usart; MB_N++);
    69bc:	a8 17       	cp	r26, r24
    69be:	b9 07       	cpc	r27, r25
    69c0:	09 f4       	brne	.+2      	; 0x69c4 <Modbus_TX+0x20>
    69c2:	c0 c0       	rjmp	.+384    	; 0x6b44 <Modbus_TX+0x1a0>
    69c4:	10 e0       	ldi	r17, 0x00	; 0
    69c6:	1f 5f       	subi	r17, 0xFF	; 255
    69c8:	c1 2f       	mov	r28, r17
    69ca:	d0 e0       	ldi	r29, 0x00	; 0
    69cc:	ce 01       	movw	r24, r28
    69ce:	88 0f       	add	r24, r24
    69d0:	99 1f       	adc	r25, r25
    69d2:	88 0f       	add	r24, r24
    69d4:	99 1f       	adc	r25, r25
    69d6:	fc 01       	movw	r30, r24
    69d8:	ee 0f       	add	r30, r30
    69da:	ff 1f       	adc	r31, r31
    69dc:	ee 0f       	add	r30, r30
    69de:	ff 1f       	adc	r31, r31
    69e0:	e8 0f       	add	r30, r24
    69e2:	f9 1f       	adc	r31, r25
    69e4:	ef 5e       	subi	r30, 0xEF	; 239
    69e6:	f3 4d       	sbci	r31, 0xD3	; 211
    69e8:	85 91       	lpm	r24, Z+
    69ea:	94 91       	lpm	r25, Z+
    69ec:	a8 17       	cp	r26, r24
    69ee:	b9 07       	cpc	r27, r25
    69f0:	51 f7       	brne	.-44     	; 0x69c6 <Modbus_TX+0x22>
void
Modbus_TX(usart_t *usart)
{
	uint8_t MB_N = MB_Port_N(usart);
	static uint8_t Count[Modbus_Qt];
	if (Count[MB_N] == MB_Frame_Sz[MB_N]-2){
    69f2:	2e ed       	ldi	r18, 0xDE	; 222
    69f4:	c2 2e       	mov	r12, r18
    69f6:	22 e0       	ldi	r18, 0x02	; 2
    69f8:	d2 2e       	mov	r13, r18
    69fa:	cc 0e       	add	r12, r28
    69fc:	dd 1e       	adc	r13, r29
    69fe:	f6 01       	movw	r30, r12
    6a00:	50 81       	ld	r21, Z
    6a02:	be 01       	movw	r22, r28
    6a04:	61 50       	subi	r22, 0x01	; 1
    6a06:	79 4f       	sbci	r23, 0xF9	; 249
    6a08:	fb 01       	movw	r30, r22
    6a0a:	40 81       	ld	r20, Z
    6a0c:	25 2f       	mov	r18, r21
    6a0e:	30 e0       	ldi	r19, 0x00	; 0
    6a10:	84 2f       	mov	r24, r20
    6a12:	90 e0       	ldi	r25, 0x00	; 0
    6a14:	02 97       	sbiw	r24, 0x02	; 2
    6a16:	28 17       	cp	r18, r24
    6a18:	39 07       	cpc	r19, r25
    6a1a:	09 f4       	brne	.+2      	; 0x6a1e <Modbus_TX+0x7a>
    6a1c:	55 c0       	rjmp	.+170    	; 0x6ac8 <Modbus_TX+0x124>
		USART_Reg(MB_N, ucsrb) &=~(1<<5);
		USART_Reg(MB_N, ucsrb) |=(1<<6);
		USART_Reg(MB_N, ucsra) |=(1<<6);	//Clear TxC pending interrupt		
	}
	if (++Count[MB_N]<MB_Frame_Sz[MB_N]) {
    6a1e:	25 2f       	mov	r18, r21
    6a20:	2f 5f       	subi	r18, 0xFF	; 255
    6a22:	f6 01       	movw	r30, r12
    6a24:	20 83       	st	Z, r18
    6a26:	24 17       	cp	r18, r20
    6a28:	80 f4       	brcc	.+32     	; 0x6a4a <Modbus_TX+0xa6>
		usart_data(usart) = MB_Frame[MB_N][Count[MB_N]];
    6a2a:	fc 2f       	mov	r31, r28
    6a2c:	ee 27       	eor	r30, r30
    6a2e:	e2 0f       	add	r30, r18
    6a30:	f1 1d       	adc	r31, r1
    6a32:	e3 5e       	subi	r30, 0xE3	; 227
    6a34:	f4 4f       	sbci	r31, 0xF4	; 244
    6a36:	80 81       	ld	r24, Z
    6a38:	8c 93       	st	X, r24
		break;
	case Role_Master:
		MB_M_Tx(MB_N);
		break;
	}
}
    6a3a:	df 91       	pop	r29
    6a3c:	cf 91       	pop	r28
    6a3e:	1f 91       	pop	r17
    6a40:	ff 90       	pop	r15
    6a42:	ef 90       	pop	r14
    6a44:	df 90       	pop	r13
    6a46:	cf 90       	pop	r12
    6a48:	08 95       	ret
    6a4a:	9e 01       	movw	r18, r28
    6a4c:	22 0f       	add	r18, r18
    6a4e:	33 1f       	adc	r19, r19
    6a50:	22 0f       	add	r18, r18
    6a52:	33 1f       	adc	r19, r19
    6a54:	c9 01       	movw	r24, r18
    6a56:	8c 0f       	add	r24, r28
    6a58:	9d 1f       	adc	r25, r29
    6a5a:	88 0f       	add	r24, r24
    6a5c:	99 1f       	adc	r25, r25
    6a5e:	88 0f       	add	r24, r24
    6a60:	99 1f       	adc	r25, r25
    6a62:	8b 5e       	subi	r24, 0xEB	; 235
    6a64:	93 4d       	sbci	r25, 0xD3	; 211
    6a66:	fc 01       	movw	r30, r24
    6a68:	a5 91       	lpm	r26, Z+
    6a6a:	b4 91       	lpm	r27, Z+
	}

	void MB_S_Tx(uint8_t);
	void MB_M_Tx(uint8_t);
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		USART_Reg(MB_N, ucsrb) &=~((1<<6)|(1<<5)); 	// .  USART Data Register Empty Interrupt
    6a6c:	8c 91       	ld	r24, X
    6a6e:	8f 79       	andi	r24, 0x9F	; 159
    6a70:	8c 93       	st	X, r24
    6a72:	79 01       	movw	r14, r18
    6a74:	ee 0c       	add	r14, r14
    6a76:	ff 1c       	adc	r15, r15
    6a78:	ee 0c       	add	r14, r14
    6a7a:	ff 1c       	adc	r15, r15
    6a7c:	e2 0e       	add	r14, r18
    6a7e:	f3 1e       	adc	r15, r19
    6a80:	c7 01       	movw	r24, r14
    6a82:	83 5e       	subi	r24, 0xE3	; 227
    6a84:	93 4d       	sbci	r25, 0xD3	; 211
    6a86:	fc 01       	movw	r30, r24
    6a88:	25 91       	lpm	r18, Z+
    6a8a:	34 91       	lpm	r19, Z+
	#elif defined (__AVR_ATxmega128A1__)
		usart->CTRLA = (usart->CTRLA &~USART_TXCINTLVL_gm) |USART_TXCINTLVL_OFF_gc;
	#endif
	USART_Func(MB_N, RS485);
    6a8c:	f9 01       	movw	r30, r18
    6a8e:	19 95       	eicall
	Count[MB_N] = 0;
    6a90:	f6 01       	movw	r30, r12
    6a92:	10 82       	st	Z, r1
	//StartTime3_5();
	MB_State[MB_N] = MB_Idle;
    6a94:	c6 54       	subi	r28, 0x46	; 70
    6a96:	da 4f       	sbci	r29, 0xFA	; 250
    6a98:	81 e0       	ldi	r24, 0x01	; 1
    6a9a:	88 83       	st	Y, r24

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    6a9c:	e1 2f       	mov	r30, r17
    6a9e:	f0 e0       	ldi	r31, 0x00	; 0
    6aa0:	eb 5d       	subi	r30, 0xDB	; 219
    6aa2:	f3 4d       	sbci	r31, 0xD3	; 211
    6aa4:	84 91       	lpm	r24, Z+
	switch (prb(MB_Role+MB_N)) {
    6aa6:	88 23       	and	r24, r24
    6aa8:	09 f4       	brne	.+2      	; 0x6aac <Modbus_TX+0x108>
    6aaa:	3c c0       	rjmp	.+120    	; 0x6b24 <Modbus_TX+0x180>
    6aac:	81 30       	cpi	r24, 0x01	; 1
    6aae:	09 f0       	breq	.+2      	; 0x6ab2 <Modbus_TX+0x10e>
    6ab0:	c4 cf       	rjmp	.-120    	; 0x6a3a <Modbus_TX+0x96>
	case Role_Slave:
		MB_S_Tx(MB_N);
		break;
	case Role_Master:
		MB_M_Tx(MB_N);
    6ab2:	81 2f       	mov	r24, r17
    6ab4:	0e 94 c6 34 	call	0x698c	; 0x698c <MB_M_Tx>
		break;
	}
}
    6ab8:	df 91       	pop	r29
    6aba:	cf 91       	pop	r28
    6abc:	1f 91       	pop	r17
    6abe:	ff 90       	pop	r15
    6ac0:	ef 90       	pop	r14
    6ac2:	df 90       	pop	r13
    6ac4:	cf 90       	pop	r12
    6ac6:	08 95       	ret

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6ac8:	fe 01       	movw	r30, r28
    6aca:	ee 0f       	add	r30, r30
    6acc:	ff 1f       	adc	r31, r31
    6ace:	ee 0f       	add	r30, r30
    6ad0:	ff 1f       	adc	r31, r31
    6ad2:	ec 0f       	add	r30, r28
    6ad4:	fd 1f       	adc	r31, r29
    6ad6:	ee 0f       	add	r30, r30
    6ad8:	ff 1f       	adc	r31, r31
    6ada:	ee 0f       	add	r30, r30
    6adc:	ff 1f       	adc	r31, r31
    6ade:	eb 5e       	subi	r30, 0xEB	; 235
    6ae0:	f3 4d       	sbci	r31, 0xD3	; 211
    6ae2:	25 91       	lpm	r18, Z+
    6ae4:	34 91       	lpm	r19, Z+
Modbus_TX(usart_t *usart)
{
	uint8_t MB_N = MB_Port_N(usart);
	static uint8_t Count[Modbus_Qt];
	if (Count[MB_N] == MB_Frame_Sz[MB_N]-2){
		USART_Reg(MB_N, ucsrb) &=~(1<<5);
    6ae6:	f9 01       	movw	r30, r18
    6ae8:	80 81       	ld	r24, Z
    6aea:	8f 7d       	andi	r24, 0xDF	; 223
		USART_Reg(MB_N, ucsrb) |=(1<<6);
    6aec:	80 64       	ori	r24, 0x40	; 64
    6aee:	80 83       	st	Z, r24
    6af0:	9e 01       	movw	r18, r28
    6af2:	22 0f       	add	r18, r18
    6af4:	33 1f       	adc	r19, r19
    6af6:	ce 01       	movw	r24, r28
    6af8:	88 0f       	add	r24, r24
    6afa:	99 1f       	adc	r25, r25
    6afc:	88 0f       	add	r24, r24
    6afe:	99 1f       	adc	r25, r25
    6b00:	88 0f       	add	r24, r24
    6b02:	99 1f       	adc	r25, r25
    6b04:	28 0f       	add	r18, r24
    6b06:	39 1f       	adc	r19, r25
    6b08:	22 0f       	add	r18, r18
    6b0a:	33 1f       	adc	r19, r19
    6b0c:	2d 5e       	subi	r18, 0xED	; 237
    6b0e:	33 4d       	sbci	r19, 0xD3	; 211
    6b10:	f9 01       	movw	r30, r18
    6b12:	e5 90       	lpm	r14, Z+
    6b14:	f4 90       	lpm	r15, Z+
		USART_Reg(MB_N, ucsra) |=(1<<6);	//Clear TxC pending interrupt		
    6b16:	f7 01       	movw	r30, r14
    6b18:	80 81       	ld	r24, Z
    6b1a:	80 64       	ori	r24, 0x40	; 64
    6b1c:	80 83       	st	Z, r24
    6b1e:	fb 01       	movw	r30, r22
    6b20:	40 81       	ld	r20, Z
    6b22:	7d cf       	rjmp	.-262    	; 0x6a1e <Modbus_TX+0x7a>
    6b24:	c7 01       	movw	r24, r14
    6b26:	81 5e       	subi	r24, 0xE1	; 225
    6b28:	93 4d       	sbci	r25, 0xD3	; 211
    6b2a:	fc 01       	movw	r30, r24
    6b2c:	25 91       	lpm	r18, Z+
    6b2e:	34 91       	lpm	r19, Z+

// ~~~~~~~~~~~~~~~~~~
void
MB_S_Tx(uint8_t MB_N)
{
	USART_Func(MB_N, LED);
    6b30:	f9 01       	movw	r30, r18
    6b32:	19 95       	eicall
		break;
	case Role_Master:
		MB_M_Tx(MB_N);
		break;
	}
}
    6b34:	df 91       	pop	r29
    6b36:	cf 91       	pop	r28
    6b38:	1f 91       	pop	r17
    6b3a:	ff 90       	pop	r15
    6b3c:	ef 90       	pop	r14
    6b3e:	df 90       	pop	r13
    6b40:	cf 90       	pop	r12
    6b42:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~
static uint8_t
MB_Port_N(usart_t *usart)
{
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Port[MB_N].usart_field)!=usart; MB_N++);
    6b44:	10 e0       	ldi	r17, 0x00	; 0
    6b46:	c0 e0       	ldi	r28, 0x00	; 0
    6b48:	d0 e0       	ldi	r29, 0x00	; 0
    6b4a:	53 cf       	rjmp	.-346    	; 0x69f2 <Modbus_TX+0x4e>

00006b4c <MB_SingleRun>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_SingleRun(uint8_t MB_N, uint8_t Addr, uint8_t Func, uint16_t StartAddr, uint16_t Qt, void *Buf)
{
    6b4c:	df 92       	push	r13
    6b4e:	ef 92       	push	r14
    6b50:	ff 92       	push	r15
    6b52:	0f 93       	push	r16
    6b54:	1f 93       	push	r17
    6b56:	cf 93       	push	r28
    6b58:	df 93       	push	r29
    6b5a:	d8 2e       	mov	r13, r24
    6b5c:	94 2f       	mov	r25, r20
    6b5e:	a9 01       	movw	r20, r18
	if (MB_SingleState[MB_N]!=MB_SingleIdle)
    6b60:	c8 2f       	mov	r28, r24
    6b62:	d0 e0       	ldi	r29, 0x00	; 0
    6b64:	9e 01       	movw	r18, r28
    6b66:	29 55       	subi	r18, 0x59	; 89
    6b68:	39 4f       	sbci	r19, 0xF9	; 249
    6b6a:	f9 01       	movw	r30, r18
    6b6c:	80 81       	ld	r24, Z
    6b6e:	88 23       	and	r24, r24
    6b70:	91 f5       	brne	.+100    	; 0x6bd6 <MB_SingleRun+0x8a>
		return;

	MB_SingleQuery[MB_N].Addr				= Addr;
    6b72:	de 01       	movw	r26, r28
    6b74:	aa 0f       	add	r26, r26
    6b76:	bb 1f       	adc	r27, r27
    6b78:	aa 0f       	add	r26, r26
    6b7a:	bb 1f       	adc	r27, r27
    6b7c:	aa 0f       	add	r26, r26
    6b7e:	bb 1f       	adc	r27, r27
    6b80:	ae 52       	subi	r26, 0x2E	; 46
    6b82:	bb 4f       	sbci	r27, 0xFB	; 251
    6b84:	6c 93       	st	X, r22
	MB_SingleQuery[MB_N].Func				= Func;
    6b86:	11 96       	adiw	r26, 0x01	; 1
    6b88:	9c 93       	st	X, r25
    6b8a:	11 97       	sbiw	r26, 0x01	; 1
	MB_SingleQuery[MB_N].StartAddr	= StartAddr;
    6b8c:	be 01       	movw	r22, r28
    6b8e:	66 0f       	add	r22, r22
    6b90:	77 1f       	adc	r23, r23
    6b92:	66 0f       	add	r22, r22
    6b94:	77 1f       	adc	r23, r23
    6b96:	fb 01       	movw	r30, r22
    6b98:	ee 0f       	add	r30, r30
    6b9a:	ff 1f       	adc	r31, r31
    6b9c:	ec 52       	subi	r30, 0x2C	; 44
    6b9e:	fb 4f       	sbci	r31, 0xFB	; 251
    6ba0:	51 83       	std	Z+1, r21	; 0x01
    6ba2:	40 83       	st	Z, r20
	MB_SingleQuery[MB_N].Qt					= Qt;
    6ba4:	ae 01       	movw	r20, r28
    6ba6:	44 0f       	add	r20, r20
    6ba8:	55 1f       	adc	r21, r21
    6baa:	fa 01       	movw	r30, r20
    6bac:	ee 0f       	add	r30, r30
    6bae:	ff 1f       	adc	r31, r31
    6bb0:	ee 0f       	add	r30, r30
    6bb2:	ff 1f       	adc	r31, r31
    6bb4:	ea 52       	subi	r30, 0x2A	; 42
    6bb6:	fb 4f       	sbci	r31, 0xFB	; 251
    6bb8:	11 83       	std	Z+1, r17	; 0x01
    6bba:	00 83       	st	Z, r16
	MB_SingleQuery[MB_N].Buf				= Buf;
    6bbc:	17 96       	adiw	r26, 0x07	; 7
    6bbe:	fc 92       	st	X, r15
    6bc0:	ee 92       	st	-X, r14
    6bc2:	16 97       	sbiw	r26, 0x06	; 6

	MB_SingleState[MB_N] = MB_SingleStart;
    6bc4:	81 e0       	ldi	r24, 0x01	; 1
    6bc6:	f9 01       	movw	r30, r18
    6bc8:	80 83       	st	Z, r24
	if (MB_State[MB_N]==MB_Proc && !LastProcSingle) {
    6bca:	fe 01       	movw	r30, r28
    6bcc:	e6 54       	subi	r30, 0x46	; 70
    6bce:	fa 4f       	sbci	r31, 0xFA	; 250
    6bd0:	80 81       	ld	r24, Z
    6bd2:	84 30       	cpi	r24, 0x04	; 4
    6bd4:	41 f0       	breq	.+16     	; 0x6be6 <MB_SingleRun+0x9a>
			IntOff();
			MB_Transm(MB_N);
			IntOn();
		}
	}
}
    6bd6:	df 91       	pop	r29
    6bd8:	cf 91       	pop	r28
    6bda:	1f 91       	pop	r17
    6bdc:	0f 91       	pop	r16
    6bde:	ff 90       	pop	r15
    6be0:	ef 90       	pop	r14
    6be2:	df 90       	pop	r13
    6be4:	08 95       	ret
	MB_SingleQuery[MB_N].StartAddr	= StartAddr;
	MB_SingleQuery[MB_N].Qt					= Qt;
	MB_SingleQuery[MB_N].Buf				= Buf;

	MB_SingleState[MB_N] = MB_SingleStart;
	if (MB_State[MB_N]==MB_Proc && !LastProcSingle) {
    6be6:	80 91 da 04 	lds	r24, 0x04DA
    6bea:	88 23       	and	r24, r24
    6bec:	a1 f7       	brne	.-24     	; 0x6bd6 <MB_SingleRun+0x8a>
		uint16_t T = (CurrSlave[MB_N]==0 ? MB_M_Period[MB_N] : MB_M_Timeout[MB_N]) - GetTimer16(TD_MB_Idle+MB_N);
    6bee:	fe 01       	movw	r30, r28
    6bf0:	e4 5b       	subi	r30, 0xB4	; 180
    6bf2:	f9 4f       	sbci	r31, 0xF9	; 249
    6bf4:	80 81       	ld	r24, Z
    6bf6:	88 23       	and	r24, r24
    6bf8:	09 f0       	breq	.+2      	; 0x6bfc <MB_SingleRun+0xb0>
    6bfa:	4d c0       	rjmp	.+154    	; 0x6c96 <MB_SingleRun+0x14a>
    6bfc:	4b 55       	subi	r20, 0x5B	; 91
    6bfe:	59 4f       	sbci	r21, 0xF9	; 249
    6c00:	fa 01       	movw	r30, r20
    6c02:	40 81       	ld	r20, Z
    6c04:	51 81       	ldd	r21, Z+1	; 0x01
    6c06:	20 91 e0 04 	lds	r18, 0x04E0
    6c0a:	2d 0d       	add	r18, r13

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    6c0c:	8f b7       	in	r24, 0x3f	; 63
    6c0e:	80 78       	andi	r24, 0x80	; 128
    6c10:	80 93 e6 02 	sts	0x02E6, r24
	cli();
    6c14:	f8 94       	cli
    6c16:	e2 2f       	mov	r30, r18
    6c18:	f0 e0       	ldi	r31, 0x00	; 0
    6c1a:	ee 0f       	add	r30, r30
    6c1c:	ff 1f       	adc	r31, r31
    6c1e:	e9 5b       	subi	r30, 0xB9	; 185
    6c20:	fc 4f       	sbci	r31, 0xFC	; 252
    6c22:	a0 81       	ld	r26, Z
    6c24:	b1 81       	ldd	r27, Z+1	; 0x01

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    6c26:	88 23       	and	r24, r24
    6c28:	09 f0       	breq	.+2      	; 0x6c2c <MB_SingleRun+0xe0>
		sei();
    6c2a:	78 94       	sei
    6c2c:	ca 01       	movw	r24, r20
    6c2e:	8a 1b       	sub	r24, r26
    6c30:	9b 0b       	sbc	r25, r27
		if (T<MB_M_Pause_Min)
    6c32:	85 30       	cpi	r24, 0x05	; 5
    6c34:	91 05       	cpc	r25, r1
    6c36:	a8 f1       	brcs	.+106    	; 0x6ca2 <MB_SingleRun+0x156>

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    6c38:	8f b7       	in	r24, 0x3f	; 63
    6c3a:	80 78       	andi	r24, 0x80	; 128
    6c3c:	80 93 e6 02 	sts	0x02E6, r24
	cli();
    6c40:	f8 94       	cli
    6c42:	cb 01       	movw	r24, r22
    6c44:	88 0f       	add	r24, r24
    6c46:	99 1f       	adc	r25, r25
    6c48:	88 0f       	add	r24, r24
    6c4a:	99 1f       	adc	r25, r25
    6c4c:	86 0f       	add	r24, r22
    6c4e:	97 1f       	adc	r25, r23
    6c50:	81 5e       	subi	r24, 0xE1	; 225
    6c52:	93 4d       	sbci	r25, 0xD3	; 211
    6c54:	fc 01       	movw	r30, r24
    6c56:	25 91       	lpm	r18, Z+
    6c58:	34 91       	lpm	r19, Z+
			StartTimer16(TD_MB_Idle+MB_N, MB_M_Pause_Min-T);
		else {
			IntOff();
			USART_Func(MB_N, LED);
    6c5a:	f9 01       	movw	r30, r18
    6c5c:	19 95       	eicall

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    6c5e:	80 91 e6 02 	lds	r24, 0x02E6
    6c62:	88 23       	and	r24, r24
    6c64:	09 f0       	breq	.+2      	; 0x6c68 <MB_SingleRun+0x11c>
		sei();
    6c66:	78 94       	sei
			IntOn();
			ResetTimer16(TD_MB_Idle+MB_N);
    6c68:	80 91 e0 04 	lds	r24, 0x04E0
    6c6c:	8d 0d       	add	r24, r13
    6c6e:	0e 94 03 1c 	call	0x3806	; 0x3806 <ResetTimer16>
			FormSingle(MB_N);
    6c72:	8d 2d       	mov	r24, r13
    6c74:	0e 94 26 30 	call	0x604c	; 0x604c <FormSingle>

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    6c78:	8f b7       	in	r24, 0x3f	; 63
    6c7a:	80 78       	andi	r24, 0x80	; 128
    6c7c:	80 93 e6 02 	sts	0x02E6, r24
	cli();
    6c80:	f8 94       	cli
			IntOff();
			MB_Transm(MB_N);
    6c82:	8d 2d       	mov	r24, r13
    6c84:	0e 94 cc 28 	call	0x5198	; 0x5198 <MB_Transm>

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    6c88:	80 91 e6 02 	lds	r24, 0x02E6
    6c8c:	88 23       	and	r24, r24
    6c8e:	09 f4       	brne	.+2      	; 0x6c92 <MB_SingleRun+0x146>
    6c90:	a2 cf       	rjmp	.-188    	; 0x6bd6 <MB_SingleRun+0x8a>
		sei();
    6c92:	78 94       	sei
    6c94:	a0 cf       	rjmp	.-192    	; 0x6bd6 <MB_SingleRun+0x8a>
	MB_SingleQuery[MB_N].Qt					= Qt;
	MB_SingleQuery[MB_N].Buf				= Buf;

	MB_SingleState[MB_N] = MB_SingleStart;
	if (MB_State[MB_N]==MB_Proc && !LastProcSingle) {
		uint16_t T = (CurrSlave[MB_N]==0 ? MB_M_Period[MB_N] : MB_M_Timeout[MB_N]) - GetTimer16(TD_MB_Idle+MB_N);
    6c96:	c5 52       	subi	r28, 0x25	; 37
    6c98:	d7 4f       	sbci	r29, 0xF7	; 247
    6c9a:	88 81       	ld	r24, Y
    6c9c:	48 2f       	mov	r20, r24
    6c9e:	50 e0       	ldi	r21, 0x00	; 0
    6ca0:	b2 cf       	rjmp	.-156    	; 0x6c06 <MB_SingleRun+0xba>
		if (T<MB_M_Pause_Min)
			StartTimer16(TD_MB_Idle+MB_N, MB_M_Pause_Min-T);
    6ca2:	65 e0       	ldi	r22, 0x05	; 5
    6ca4:	70 e0       	ldi	r23, 0x00	; 0
    6ca6:	68 1b       	sub	r22, r24
    6ca8:	79 0b       	sbc	r23, r25
    6caa:	82 2f       	mov	r24, r18
    6cac:	0e 94 1d 1a 	call	0x343a	; 0x343a <StartTimer16>
    6cb0:	92 cf       	rjmp	.-220    	; 0x6bd6 <MB_SingleRun+0x8a>

00006cb2 <MB_Master_MaxCycle_Clear>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_Master_MaxCycle_Clear(uint8_t MB_N)
{
	MB_Master_MaxCycle[MB_N] = 0;
    6cb2:	e8 2f       	mov	r30, r24
    6cb4:	f0 e0       	ldi	r31, 0x00	; 0
    6cb6:	ee 0f       	add	r30, r30
    6cb8:	ff 1f       	adc	r31, r31
    6cba:	ea 54       	subi	r30, 0x4A	; 74
    6cbc:	f9 4f       	sbci	r31, 0xF9	; 249
    6cbe:	11 82       	std	Z+1, r1	; 0x01
    6cc0:	10 82       	st	Z, r1
}
    6cc2:	08 95       	ret

00006cc4 <MB_M_Cycle>:

// ~~~~~~~~~~~~~~~~~~~~~
void
MB_M_Cycle(uint8_t MB_N)
{
    6cc4:	ff 92       	push	r15
    6cc6:	0f 93       	push	r16
    6cc8:	1f 93       	push	r17
    6cca:	cf 93       	push	r28
    6ccc:	df 93       	push	r29
    6cce:	f8 2e       	mov	r15, r24
	if (Timer16Stopp(TD_MB_SlaveOff+MB_N))
    6cd0:	10 91 e0 04 	lds	r17, 0x04E0
    6cd4:	18 0f       	add	r17, r24
    6cd6:	01 2f       	mov	r16, r17
    6cd8:	0f 5f       	subi	r16, 0xFF	; 255
    6cda:	80 2f       	mov	r24, r16
    6cdc:	0e 94 59 1b 	call	0x36b2	; 0x36b2 <Timer16Stopp>
    6ce0:	88 23       	and	r24, r24
    6ce2:	d9 f4       	brne	.+54     	; 0x6d1a <MB_M_Cycle+0x56>
		SlavesOn(MB_N);

	if (Timer16Stopp(TD_MB_Idle+MB_N)){
    6ce4:	81 2f       	mov	r24, r17
    6ce6:	0e 94 59 1b 	call	0x36b2	; 0x36b2 <Timer16Stopp>
    6cea:	88 23       	and	r24, r24
    6cec:	81 f0       	breq	.+32     	; 0x6d0e <MB_M_Cycle+0x4a>
		cli();
    6cee:	f8 94       	cli
		if(MB_State[MB_N] == MB_Idle) MB_State[MB_N] = MB_NoReply;
    6cf0:	cf 2d       	mov	r28, r15
    6cf2:	d0 e0       	ldi	r29, 0x00	; 0
    6cf4:	fe 01       	movw	r30, r28
    6cf6:	e6 54       	subi	r30, 0x46	; 70
    6cf8:	fa 4f       	sbci	r31, 0xFA	; 250
    6cfa:	80 81       	ld	r24, Z
    6cfc:	81 30       	cpi	r24, 0x01	; 1
    6cfe:	29 f1       	breq	.+74     	; 0x6d4a <MB_M_Cycle+0x86>
		sei();
    6d00:	78 94       	sei
	}
	else return;
	
	switch (MB_State[MB_N]) {
    6d02:	80 81       	ld	r24, Z
    6d04:	84 30       	cpi	r24, 0x04	; 4
    6d06:	39 f1       	breq	.+78     	; 0x6d56 <MB_M_Cycle+0x92>
    6d08:	85 30       	cpi	r24, 0x05	; 5
    6d0a:	09 f4       	brne	.+2      	; 0x6d0e <MB_M_Cycle+0x4a>
    6d0c:	52 c0       	rjmp	.+164    	; 0x6db2 <MB_M_Cycle+0xee>
		cli();
		MB_Transm(MB_N);
		sei();
		break;
	}
}
    6d0e:	df 91       	pop	r29
    6d10:	cf 91       	pop	r28
    6d12:	1f 91       	pop	r17
    6d14:	0f 91       	pop	r16
    6d16:	ff 90       	pop	r15
    6d18:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~
static void
SlavesOn(uint8_t MB_N)
{
	SlaveSkip[MB_N] = 0;
    6d1a:	af 2d       	mov	r26, r15
    6d1c:	b0 e0       	ldi	r27, 0x00	; 0
    6d1e:	fd 01       	movw	r30, r26
    6d20:	ee 0f       	add	r30, r30
    6d22:	ff 1f       	adc	r31, r31
    6d24:	ee 0f       	add	r30, r30
    6d26:	ff 1f       	adc	r31, r31
    6d28:	e4 52       	subi	r30, 0x24	; 36
    6d2a:	fb 4f       	sbci	r31, 0xFB	; 251
    6d2c:	10 82       	st	Z, r1
    6d2e:	11 82       	std	Z+1, r1	; 0x01
    6d30:	12 82       	std	Z+2, r1	; 0x02
    6d32:	13 82       	std	Z+3, r1	; 0x03
	StartTimer16(TD_MB_SlaveOff+MB_N, 100*MB_M_TimeOff[MB_N]);
    6d34:	a9 52       	subi	r26, 0x29	; 41
    6d36:	ba 4f       	sbci	r27, 0xFA	; 250
    6d38:	6c 91       	ld	r22, X
    6d3a:	84 e6       	ldi	r24, 0x64	; 100
    6d3c:	68 9f       	mul	r22, r24
    6d3e:	b0 01       	movw	r22, r0
    6d40:	11 24       	eor	r1, r1
    6d42:	80 2f       	mov	r24, r16
    6d44:	0e 94 1d 1a 	call	0x343a	; 0x343a <StartTimer16>
    6d48:	cd cf       	rjmp	.-102    	; 0x6ce4 <MB_M_Cycle+0x20>
	if (Timer16Stopp(TD_MB_SlaveOff+MB_N))
		SlavesOn(MB_N);

	if (Timer16Stopp(TD_MB_Idle+MB_N)){
		cli();
		if(MB_State[MB_N] == MB_Idle) MB_State[MB_N] = MB_NoReply;
    6d4a:	85 e0       	ldi	r24, 0x05	; 5
    6d4c:	80 83       	st	Z, r24
		sei();
    6d4e:	78 94       	sei
	}
	else return;
	
	switch (MB_State[MB_N]) {
    6d50:	80 81       	ld	r24, Z
    6d52:	84 30       	cpi	r24, 0x04	; 4
    6d54:	c9 f6       	brne	.-78     	; 0x6d08 <MB_M_Cycle+0x44>
		cli();
		MB_Transm(MB_N);
		sei();
		break;
	case MB_Proc:
		cli();
    6d56:	f8 94       	cli
    6d58:	ce 01       	movw	r24, r28
    6d5a:	88 0f       	add	r24, r24
    6d5c:	99 1f       	adc	r25, r25
    6d5e:	88 0f       	add	r24, r24
    6d60:	99 1f       	adc	r25, r25
    6d62:	9c 01       	movw	r18, r24
    6d64:	22 0f       	add	r18, r18
    6d66:	33 1f       	adc	r19, r19
    6d68:	22 0f       	add	r18, r18
    6d6a:	33 1f       	adc	r19, r19
    6d6c:	28 0f       	add	r18, r24
    6d6e:	39 1f       	adc	r19, r25
    6d70:	21 5e       	subi	r18, 0xE1	; 225
    6d72:	33 4d       	sbci	r19, 0xD3	; 211
    6d74:	f9 01       	movw	r30, r18
    6d76:	85 91       	lpm	r24, Z+
    6d78:	94 91       	lpm	r25, Z+
		USART_Func(MB_N, LED);
    6d7a:	fc 01       	movw	r30, r24
    6d7c:	19 95       	eicall
		sei();
    6d7e:	78 94       	sei
		switch (MB_SingleState[MB_N]) {
    6d80:	c9 55       	subi	r28, 0x59	; 89
    6d82:	d9 4f       	sbci	r29, 0xF9	; 249
    6d84:	88 81       	ld	r24, Y
    6d86:	88 23       	and	r24, r24
    6d88:	b1 f1       	breq	.+108    	; 0x6df6 <MB_M_Cycle+0x132>
    6d8a:	81 30       	cpi	r24, 0x01	; 1
    6d8c:	81 f1       	breq	.+96     	; 0x6dee <MB_M_Cycle+0x12a>
				FormQuery(MB_N);
			else
				FormSingle(MB_N);
			break;
		}
		StartTimer16(TD_MB_Idle+MB_N, 0xFFFF);	//     
    6d8e:	80 91 e0 04 	lds	r24, 0x04E0
    6d92:	8f 0d       	add	r24, r15
    6d94:	6f ef       	ldi	r22, 0xFF	; 255
    6d96:	7f ef       	ldi	r23, 0xFF	; 255
    6d98:	0e 94 1d 1a 	call	0x343a	; 0x343a <StartTimer16>
		cli();
    6d9c:	f8 94       	cli
		MB_Transm(MB_N);
    6d9e:	8f 2d       	mov	r24, r15
    6da0:	0e 94 cc 28 	call	0x5198	; 0x5198 <MB_Transm>
		sei();
    6da4:	78 94       	sei
		break;
	}
}
    6da6:	df 91       	pop	r29
    6da8:	cf 91       	pop	r28
    6daa:	1f 91       	pop	r17
    6dac:	0f 91       	pop	r16
    6dae:	ff 90       	pop	r15
    6db0:	08 95       	ret
	}
	else return;
	
	switch (MB_State[MB_N]) {
	case MB_NoReply:
		FailSlave(MB_N);
    6db2:	8f 2d       	mov	r24, r15
    6db4:	0e 94 3b 31 	call	0x6276	; 0x6276 <FailSlave>
		switch (MB_SingleState[MB_N]) {
    6db8:	fe 01       	movw	r30, r28
    6dba:	e9 55       	subi	r30, 0x59	; 89
    6dbc:	f9 4f       	sbci	r31, 0xF9	; 249
    6dbe:	e0 81       	ld	r30, Z
    6dc0:	ee 23       	and	r30, r30
    6dc2:	e9 f4       	brne	.+58     	; 0x6dfe <MB_M_Cycle+0x13a>
		case MB_SingleIdle:
			FormQuery(MB_N);
    6dc4:	8f 2d       	mov	r24, r15
    6dc6:	0e 94 d4 2f 	call	0x5fa8	; 0x5fa8 <FormQuery>
		case MB_SingleStart:
			if (Try[MB_N]==0)
				FormSingle(MB_N);
			break;
		}
		StartTimer16(TD_MB_Idle+MB_N, 0xFFFF);	//     
    6dca:	80 91 e0 04 	lds	r24, 0x04E0
    6dce:	8f 0d       	add	r24, r15
    6dd0:	6f ef       	ldi	r22, 0xFF	; 255
    6dd2:	7f ef       	ldi	r23, 0xFF	; 255
    6dd4:	0e 94 1d 1a 	call	0x343a	; 0x343a <StartTimer16>
		cli();
    6dd8:	f8 94       	cli
		MB_Transm(MB_N);
    6dda:	8f 2d       	mov	r24, r15
    6ddc:	0e 94 cc 28 	call	0x5198	; 0x5198 <MB_Transm>
		sei();
    6de0:	78 94       	sei
		cli();
		MB_Transm(MB_N);
		sei();
		break;
	}
}
    6de2:	df 91       	pop	r29
    6de4:	cf 91       	pop	r28
    6de6:	1f 91       	pop	r17
    6de8:	0f 91       	pop	r16
    6dea:	ff 90       	pop	r15
    6dec:	08 95       	ret
		switch (MB_SingleState[MB_N]) {
		case MB_SingleIdle:
			FormQuery(MB_N);
			break;
		case MB_SingleStart:
			if (LastProcSingle)
    6dee:	80 91 da 04 	lds	r24, 0x04DA
    6df2:	88 23       	and	r24, r24
    6df4:	79 f0       	breq	.+30     	; 0x6e14 <MB_M_Cycle+0x150>
				FormQuery(MB_N);
    6df6:	8f 2d       	mov	r24, r15
    6df8:	0e 94 d4 2f 	call	0x5fa8	; 0x5fa8 <FormQuery>
    6dfc:	c8 cf       	rjmp	.-112    	; 0x6d8e <MB_M_Cycle+0xca>
	else return;
	
	switch (MB_State[MB_N]) {
	case MB_NoReply:
		FailSlave(MB_N);
		switch (MB_SingleState[MB_N]) {
    6dfe:	e1 30       	cpi	r30, 0x01	; 1
    6e00:	21 f7       	brne	.-56     	; 0x6dca <MB_M_Cycle+0x106>
		case MB_SingleIdle:
			FormQuery(MB_N);
			break;
		case MB_SingleStart:
			if (Try[MB_N]==0)
    6e02:	c5 52       	subi	r28, 0x25	; 37
    6e04:	db 4f       	sbci	r29, 0xFB	; 251
    6e06:	88 81       	ld	r24, Y
    6e08:	88 23       	and	r24, r24
    6e0a:	f9 f6       	brne	.-66     	; 0x6dca <MB_M_Cycle+0x106>
				FormSingle(MB_N);
    6e0c:	8f 2d       	mov	r24, r15
    6e0e:	0e 94 26 30 	call	0x604c	; 0x604c <FormSingle>
    6e12:	db cf       	rjmp	.-74     	; 0x6dca <MB_M_Cycle+0x106>
			break;
		case MB_SingleStart:
			if (LastProcSingle)
				FormQuery(MB_N);
			else
				FormSingle(MB_N);
    6e14:	8f 2d       	mov	r24, r15
    6e16:	0e 94 26 30 	call	0x604c	; 0x604c <FormSingle>
    6e1a:	b9 cf       	rjmp	.-142    	; 0x6d8e <MB_M_Cycle+0xca>

00006e1c <MB_Cycle>:
}

// ~~~~~~~~~~~
void
MB_Cycle(void)
{
    6e1c:	cf 93       	push	r28
    6e1e:	df 93       	push	r29
	void MB_S_Timer_ISR(uint8_t);
	void MB_M_Timer_ISR(uint8_t);

	for (uint8_t MB_N=0; MB_N<Modbus_Qt; MB_N++){
		if(MB_TimerFlag & (1<<MB_N)){
    6e20:	80 91 dc 08 	lds	r24, 0x08DC
    6e24:	80 fd       	sbrc	r24, 0
    6e26:	0c c0       	rjmp	.+24     	; 0x6e40 <MB_Cycle+0x24>
    6e28:	c5 e2       	ldi	r28, 0x25	; 37
    6e2a:	dc e2       	ldi	r29, 0x2C	; 44

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    6e2c:	fe 01       	movw	r30, r28
    6e2e:	84 91       	lpm	r24, Z+
	}

	void MB_M_Cycle(uint8_t);

	for (uint8_t MB_N=0; MB_N<Modbus_Qt; MB_N++)
		if (prb(MB_Role+MB_N)==Role_Master)
    6e30:	81 30       	cpi	r24, 0x01	; 1
    6e32:	19 f4       	brne	.+6      	; 0x6e3a <MB_Cycle+0x1e>
			MB_M_Cycle(MB_N);
    6e34:	80 e0       	ldi	r24, 0x00	; 0
    6e36:	0e 94 62 36 	call	0x6cc4	; 0x6cc4 <MB_M_Cycle>
}
    6e3a:	df 91       	pop	r29
    6e3c:	cf 91       	pop	r28
    6e3e:	08 95       	ret
	void MB_S_Timer_ISR(uint8_t);
	void MB_M_Timer_ISR(uint8_t);

	for (uint8_t MB_N=0; MB_N<Modbus_Qt; MB_N++){
		if(MB_TimerFlag & (1<<MB_N)){
			cli();
    6e40:	f8 94       	cli
			MB_TimerFlag &= ~(1<<MB_N);
    6e42:	80 91 dc 08 	lds	r24, 0x08DC
    6e46:	8e 7f       	andi	r24, 0xFE	; 254
    6e48:	80 93 dc 08 	sts	0x08DC, r24
			sei();
    6e4c:	78 94       	sei
    6e4e:	c5 e2       	ldi	r28, 0x25	; 37
    6e50:	dc e2       	ldi	r29, 0x2C	; 44
    6e52:	fe 01       	movw	r30, r28
    6e54:	84 91       	lpm	r24, Z+
			switch (prb(MB_Role+MB_N)) {
    6e56:	88 23       	and	r24, r24
    6e58:	21 f4       	brne	.+8      	; 0x6e62 <MB_Cycle+0x46>
			case Role_Slave:
				MB_S_Timer_ISR(MB_N);
    6e5a:	80 e0       	ldi	r24, 0x00	; 0
    6e5c:	0e 94 84 2a 	call	0x5508	; 0x5508 <MB_S_Timer_ISR>
    6e60:	e5 cf       	rjmp	.-54     	; 0x6e2c <MB_Cycle+0x10>
	for (uint8_t MB_N=0; MB_N<Modbus_Qt; MB_N++){
		if(MB_TimerFlag & (1<<MB_N)){
			cli();
			MB_TimerFlag &= ~(1<<MB_N);
			sei();
			switch (prb(MB_Role+MB_N)) {
    6e62:	81 30       	cpi	r24, 0x01	; 1
    6e64:	19 f7       	brne	.-58     	; 0x6e2c <MB_Cycle+0x10>
			case Role_Slave:
				MB_S_Timer_ISR(MB_N);
				break;
			case Role_Master:
				MB_M_Timer_ISR(MB_N);
    6e66:	80 e0       	ldi	r24, 0x00	; 0
    6e68:	0e 94 b1 31 	call	0x6362	; 0x6362 <MB_M_Timer_ISR>
    6e6c:	df cf       	rjmp	.-66     	; 0x6e2c <MB_Cycle+0x10>

00006e6e <SetIP>:
	uint8_t IP3;
	uint8_t IP4;
} IP_Addr;

//~~~~~~~~~~~~~~
void SetIP(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
    6e6e:	0f 93       	push	r16
    6e70:	fc 01       	movw	r30, r24
	IP->IP1 = IP1;
    6e72:	60 83       	st	Z, r22
	IP->IP2 = IP2;
    6e74:	41 83       	std	Z+1, r20	; 0x01
	IP->IP3 = IP3;
    6e76:	22 83       	std	Z+2, r18	; 0x02
	IP->IP4 = IP4;
    6e78:	03 83       	std	Z+3, r16	; 0x03
}
    6e7a:	0f 91       	pop	r16
    6e7c:	08 95       	ret

00006e7e <IP_compare_Const>:
uint8_t IP_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
    6e7e:	0f 93       	push	r16
    6e80:	fc 01       	movw	r30, r24
	if((IP->IP1 == IP1) && (IP->IP2 == IP2) && (IP->IP3 == IP3) && (IP->IP4 == IP4)) return 1;
    6e82:	80 81       	ld	r24, Z
    6e84:	86 17       	cp	r24, r22
    6e86:	21 f0       	breq	.+8      	; 0x6e90 <IP_compare_Const+0x12>
    6e88:	20 e0       	ldi	r18, 0x00	; 0
	else return 0;
}
    6e8a:	82 2f       	mov	r24, r18
    6e8c:	0f 91       	pop	r16
    6e8e:	08 95       	ret
	IP->IP2 = IP2;
	IP->IP3 = IP3;
	IP->IP4 = IP4;
}
uint8_t IP_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	if((IP->IP1 == IP1) && (IP->IP2 == IP2) && (IP->IP3 == IP3) && (IP->IP4 == IP4)) return 1;
    6e90:	81 81       	ldd	r24, Z+1	; 0x01
    6e92:	84 17       	cp	r24, r20
    6e94:	c9 f7       	brne	.-14     	; 0x6e88 <IP_compare_Const+0xa>
    6e96:	82 81       	ldd	r24, Z+2	; 0x02
    6e98:	82 17       	cp	r24, r18
    6e9a:	b1 f7       	brne	.-20     	; 0x6e88 <IP_compare_Const+0xa>
    6e9c:	20 e0       	ldi	r18, 0x00	; 0
    6e9e:	83 81       	ldd	r24, Z+3	; 0x03
    6ea0:	80 13       	cpse	r24, r16
    6ea2:	21 e0       	ldi	r18, 0x01	; 1
    6ea4:	81 e0       	ldi	r24, 0x01	; 1
    6ea6:	28 27       	eor	r18, r24
    6ea8:	f0 cf       	rjmp	.-32     	; 0x6e8a <IP_compare_Const+0xc>

00006eaa <GSM_StartCalling>:
uint8_t numOfCheckBallanceRetry=0;

uint8_t Message[3];  // 
uint8_t GSMBusyState=0; // " " 0 -  , 1 -  
void GSM_StartCalling(uint8_t inputN,uint8_t abonentN){
	Message[0]=1;
    6eaa:	91 e0       	ldi	r25, 0x01	; 1
    6eac:	90 93 ec 06 	sts	0x06EC, r25
	Message[1]=inputN;
    6eb0:	80 93 ed 06 	sts	0x06ED, r24
	Message[2]=abonentN;
    6eb4:	60 93 ee 06 	sts	0x06EE, r22
}
    6eb8:	08 95       	ret

00006eba <InitFIFO>:
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    6eba:	8f ef       	ldi	r24, 0xFF	; 255
    6ebc:	80 93 f4 06 	sts	0x06F4, r24
	GSM_RX_FIFO_End = 255;
    6ec0:	80 93 4b 06 	sts	0x064B, r24
	GSM_RxCharN = 0;
    6ec4:	10 92 12 0b 	sts	0x0B12, r1
	GSM_RX_FIFOOverFlow = 0;
    6ec8:	10 92 c5 08 	sts	0x08C5, r1
	GSM_RX_FIFOMax = 0;
    6ecc:	10 92 cb 08 	sts	0x08CB, r1
}
    6ed0:	08 95       	ret

00006ed2 <GetByteFromFIFO>:
// ~~~~~~~~~~~
void GetByteFromFIFO(uint8_t *ReadBuf, uint8_t *Index, uint8_t ReadBuf_Sz){
    6ed2:	0f 93       	push	r16
    6ed4:	1f 93       	push	r17
    6ed6:	cf 93       	push	r28
    6ed8:	df 93       	push	r29
    6eda:	8c 01       	movw	r16, r24
    6edc:	eb 01       	movw	r28, r22

	//Reset *Index if read buffer overflow
	if(*Index >= ReadBuf_Sz){
    6ede:	88 81       	ld	r24, Y
    6ee0:	84 17       	cp	r24, r20
    6ee2:	08 f0       	brcs	.+2      	; 0x6ee6 <GetByteFromFIFO+0x14>
		*Index = 0;
    6ee4:	18 82       	st	Y, r1
		//TODO  
	}	

	if(GSM_RX_FIFO_Begin > GSM_RX_FIFO_End){
    6ee6:	80 91 f4 06 	lds	r24, 0x06F4
    6eea:	e0 91 4b 06 	lds	r30, 0x064B
    6eee:	e8 17       	cp	r30, r24
    6ef0:	f8 f4       	brcc	.+62     	; 0x6f30 <GetByteFromFIFO+0x5e>
		if((GSM_RX_FIFO_End != 255)&&(GSM_RX_FIFO_End != 255))			
    6ef2:	ef 3f       	cpi	r30, 0xFF	; 255
    6ef4:	61 f0       	breq	.+24     	; 0x6f0e <GetByteFromFIFO+0x3c>
			if(GSM_RX_FIFOMax < (GSM_RX_FIFO_Begin - GSM_RX_FIFO_End))
    6ef6:	20 91 cb 08 	lds	r18, 0x08CB
    6efa:	80 91 f4 06 	lds	r24, 0x06F4
    6efe:	30 e0       	ldi	r19, 0x00	; 0
    6f00:	90 e0       	ldi	r25, 0x00	; 0
    6f02:	8e 1b       	sub	r24, r30
    6f04:	91 09       	sbc	r25, r1
    6f06:	28 17       	cp	r18, r24
    6f08:	39 07       	cpc	r19, r25
    6f0a:	0c f4       	brge	.+2      	; 0x6f0e <GetByteFromFIFO+0x3c>
    6f0c:	46 c0       	rjmp	.+140    	; 0x6f9a <GetByteFromFIFO+0xc8>
				GSM_RX_FIFOMax =  GSM_RX_FIFO_Begin - GSM_RX_FIFO_End;
		GSM_RX_FIFO_End++;
    6f0e:	ef 5f       	subi	r30, 0xFF	; 255
    6f10:	e0 93 4b 06 	sts	0x064B, r30
		ReadBuf[*Index] = GSM_RX_FIFO[GSM_RX_FIFO_End];
    6f14:	88 81       	ld	r24, Y
    6f16:	d8 01       	movw	r26, r16
    6f18:	a8 0f       	add	r26, r24
    6f1a:	b1 1d       	adc	r27, r1
    6f1c:	f0 e0       	ldi	r31, 0x00	; 0
    6f1e:	e7 52       	subi	r30, 0x27	; 39
    6f20:	fa 4f       	sbci	r31, 0xFA	; 250
    6f22:	80 81       	ld	r24, Z
    6f24:	8c 93       	st	X, r24
		*Index=*Index+1;
    6f26:	88 81       	ld	r24, Y
    6f28:	8f 5f       	subi	r24, 0xFF	; 255
    6f2a:	88 83       	st	Y, r24
    6f2c:	e0 91 4b 06 	lds	r30, 0x064B
	}
	if(GSM_RX_FIFO_End > GSM_RX_FIFO_Begin){
    6f30:	80 91 f4 06 	lds	r24, 0x06F4
    6f34:	8e 17       	cp	r24, r30
    6f36:	28 f5       	brcc	.+74     	; 0x6f82 <GetByteFromFIFO+0xb0>
		if((GSM_RX_FIFO_End != 255)&&(GSM_RX_FIFO_End != 255))
    6f38:	ef 3f       	cpi	r30, 0xFF	; 255
    6f3a:	99 f0       	breq	.+38     	; 0x6f62 <GetByteFromFIFO+0x90>
			if(GSM_RX_FIFOMax < (GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End  + GSM_RX_FIFO_Begin))
    6f3c:	20 91 cb 08 	lds	r18, 0x08CB
    6f40:	80 91 f4 06 	lds	r24, 0x06F4
    6f44:	30 e0       	ldi	r19, 0x00	; 0
    6f46:	90 e0       	ldi	r25, 0x00	; 0
    6f48:	8c 59       	subi	r24, 0x9C	; 156
    6f4a:	9f 4f       	sbci	r25, 0xFF	; 255
    6f4c:	8e 1b       	sub	r24, r30
    6f4e:	91 09       	sbc	r25, r1
    6f50:	28 17       	cp	r18, r24
    6f52:	39 07       	cpc	r19, r25
    6f54:	dc f0       	brlt	.+54     	; 0x6f8c <GetByteFromFIFO+0xba>
				GSM_RX_FIFOMax = GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End  + GSM_RX_FIFO_Begin;
		GSM_RX_FIFO_End++;
    6f56:	8e 2f       	mov	r24, r30
    6f58:	8f 5f       	subi	r24, 0xFF	; 255
    6f5a:	80 93 4b 06 	sts	0x064B, r24
		if(GSM_RX_FIFO_End >= GSM_RX_FIFO_SIZE) GSM_RX_FIFO_End = 0;
    6f5e:	84 36       	cpi	r24, 0x64	; 100
    6f60:	10 f0       	brcs	.+4      	; 0x6f66 <GetByteFromFIFO+0x94>
    6f62:	10 92 4b 06 	sts	0x064B, r1
		ReadBuf[*Index] = GSM_RX_FIFO[GSM_RX_FIFO_End];
    6f66:	88 81       	ld	r24, Y
    6f68:	08 0f       	add	r16, r24
    6f6a:	11 1d       	adc	r17, r1
    6f6c:	e0 91 4b 06 	lds	r30, 0x064B
    6f70:	f0 e0       	ldi	r31, 0x00	; 0
    6f72:	e7 52       	subi	r30, 0x27	; 39
    6f74:	fa 4f       	sbci	r31, 0xFA	; 250
    6f76:	80 81       	ld	r24, Z
    6f78:	f8 01       	movw	r30, r16
    6f7a:	80 83       	st	Z, r24
		*Index=*Index+1;
    6f7c:	88 81       	ld	r24, Y
    6f7e:	8f 5f       	subi	r24, 0xFF	; 255
    6f80:	88 83       	st	Y, r24
	}
}
    6f82:	df 91       	pop	r29
    6f84:	cf 91       	pop	r28
    6f86:	1f 91       	pop	r17
    6f88:	0f 91       	pop	r16
    6f8a:	08 95       	ret
		*Index=*Index+1;
	}
	if(GSM_RX_FIFO_End > GSM_RX_FIFO_Begin){
		if((GSM_RX_FIFO_End != 255)&&(GSM_RX_FIFO_End != 255))
			if(GSM_RX_FIFOMax < (GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End  + GSM_RX_FIFO_Begin))
				GSM_RX_FIFOMax = GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End  + GSM_RX_FIFO_Begin;
    6f8c:	80 91 f4 06 	lds	r24, 0x06F4
    6f90:	8c 59       	subi	r24, 0x9C	; 156
    6f92:	8e 1b       	sub	r24, r30
    6f94:	80 93 cb 08 	sts	0x08CB, r24
    6f98:	de cf       	rjmp	.-68     	; 0x6f56 <GetByteFromFIFO+0x84>
	}	

	if(GSM_RX_FIFO_Begin > GSM_RX_FIFO_End){
		if((GSM_RX_FIFO_End != 255)&&(GSM_RX_FIFO_End != 255))			
			if(GSM_RX_FIFOMax < (GSM_RX_FIFO_Begin - GSM_RX_FIFO_End))
				GSM_RX_FIFOMax =  GSM_RX_FIFO_Begin - GSM_RX_FIFO_End;
    6f9a:	80 91 f4 06 	lds	r24, 0x06F4
    6f9e:	8e 1b       	sub	r24, r30
    6fa0:	80 93 cb 08 	sts	0x08CB, r24
    6fa4:	b4 cf       	rjmp	.-152    	; 0x6f0e <GetByteFromFIFO+0x3c>

00006fa6 <GetStringFromFIFO>:
//        
uint8_t GetStringFromFIFO(void){

	uint8_t StrLength = 0;

	while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    6fa6:	90 91 f4 06 	lds	r25, 0x06F4
    6faa:	80 91 4b 06 	lds	r24, 0x064B
    6fae:	98 17       	cp	r25, r24
    6fb0:	39 f1       	breq	.+78     	; 0x7000 <GetStringFromFIFO+0x5a>
		
		GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);
    6fb2:	83 e9       	ldi	r24, 0x93	; 147
    6fb4:	97 e0       	ldi	r25, 0x07	; 7
    6fb6:	62 e1       	ldi	r22, 0x12	; 18
    6fb8:	7b e0       	ldi	r23, 0x0B	; 11
    6fba:	44 e6       	ldi	r20, 0x64	; 100
    6fbc:	0e 94 69 37 	call	0x6ed2	; 0x6ed2 <GetByteFromFIFO>

		//   : xxxxxxxxxxxxxxxx<CR><LF>
		//	'\r' CR - carridge return 0x0D
		//	'\n' LF - line feed 0x0A
		//   xxxxxxxxxxxxxxxx<\0>
		if( (GSM_RxCharN >= 2) && (GSM_RxStr[GSM_RxCharN-2]== '\r') && (GSM_RxStr[GSM_RxCharN-1]== '\n') ){
    6fc0:	80 91 12 0b 	lds	r24, 0x0B12
    6fc4:	82 30       	cpi	r24, 0x02	; 2
    6fc6:	78 f3       	brcs	.-34     	; 0x6fa6 <GetStringFromFIFO>
    6fc8:	e0 91 12 0b 	lds	r30, 0x0B12
    6fcc:	f0 e0       	ldi	r31, 0x00	; 0
    6fce:	ef 56       	subi	r30, 0x6F	; 111
    6fd0:	f8 4f       	sbci	r31, 0xF8	; 248
    6fd2:	80 81       	ld	r24, Z
    6fd4:	8d 30       	cpi	r24, 0x0D	; 13
    6fd6:	39 f7       	brne	.-50     	; 0x6fa6 <GetStringFromFIFO>
    6fd8:	e0 91 12 0b 	lds	r30, 0x0B12
    6fdc:	f0 e0       	ldi	r31, 0x00	; 0
    6fde:	ee 56       	subi	r30, 0x6E	; 110
    6fe0:	f8 4f       	sbci	r31, 0xF8	; 248
    6fe2:	80 81       	ld	r24, Z
    6fe4:	8a 30       	cpi	r24, 0x0A	; 10
    6fe6:	f9 f6       	brne	.-66     	; 0x6fa6 <GetStringFromFIFO>
			GSM_RxStr[GSM_RxCharN-2] = '\0';
    6fe8:	e0 91 12 0b 	lds	r30, 0x0B12
    6fec:	f0 e0       	ldi	r31, 0x00	; 0
    6fee:	ef 56       	subi	r30, 0x6F	; 111
    6ff0:	f8 4f       	sbci	r31, 0xF8	; 248
    6ff2:	10 82       	st	Z, r1
			StrLength = GSM_RxCharN-1;
    6ff4:	80 91 12 0b 	lds	r24, 0x0B12
    6ff8:	81 50       	subi	r24, 0x01	; 1
			GSM_RxCharN = 0;
    6ffa:	10 92 12 0b 	sts	0x0B12, r1
    6ffe:	08 95       	ret
//        
uint8_t GetStringFromFIFO(void){

	uint8_t StrLength = 0;

	while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    7000:	80 e0       	ldi	r24, 0x00	; 0
		}

	}//while
	
	return StrLength;
}
    7002:	08 95       	ret

00007004 <GetStringFromFIFOwithOverflowDetect>:

uint8_t GetStringFromFIFOwithOverflowDetect(void){
    7004:	04 c0       	rjmp	.+8      	; 0x700e <GetStringFromFIFOwithOverflowDetect+0xa>

		//   : xxxxxxxxxxxxxxxx<CR><LF>
		//	'\r' CR - carridge return 0x0D
		//	'\n' LF - line feed 0x0A
		//   xxxxxxxxxxxxxxxx<\0>
		if( ((GSM_RxCharN >= 2) && (GSM_RxStr[GSM_RxCharN-2]== '\r') && (GSM_RxStr[GSM_RxCharN-1]== '\n'))||(GSM_RxCharN==GSM_RXSTR_SIZE-1) ){
    7006:	80 91 12 0b 	lds	r24, 0x0B12
    700a:	83 36       	cpi	r24, 0x63	; 99
    700c:	09 f1       	breq	.+66     	; 0x7050 <GetStringFromFIFOwithOverflowDetect+0x4c>

uint8_t GetStringFromFIFOwithOverflowDetect(void){

	uint8_t StrLength = 0;

	while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    700e:	90 91 f4 06 	lds	r25, 0x06F4
    7012:	80 91 4b 06 	lds	r24, 0x064B
    7016:	98 17       	cp	r25, r24
    7018:	39 f1       	breq	.+78     	; 0x7068 <GetStringFromFIFOwithOverflowDetect+0x64>
		
		GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);
    701a:	83 e9       	ldi	r24, 0x93	; 147
    701c:	97 e0       	ldi	r25, 0x07	; 7
    701e:	62 e1       	ldi	r22, 0x12	; 18
    7020:	7b e0       	ldi	r23, 0x0B	; 11
    7022:	44 e6       	ldi	r20, 0x64	; 100
    7024:	0e 94 69 37 	call	0x6ed2	; 0x6ed2 <GetByteFromFIFO>

		//   : xxxxxxxxxxxxxxxx<CR><LF>
		//	'\r' CR - carridge return 0x0D
		//	'\n' LF - line feed 0x0A
		//   xxxxxxxxxxxxxxxx<\0>
		if( ((GSM_RxCharN >= 2) && (GSM_RxStr[GSM_RxCharN-2]== '\r') && (GSM_RxStr[GSM_RxCharN-1]== '\n'))||(GSM_RxCharN==GSM_RXSTR_SIZE-1) ){
    7028:	80 91 12 0b 	lds	r24, 0x0B12
    702c:	82 30       	cpi	r24, 0x02	; 2
    702e:	58 f3       	brcs	.-42     	; 0x7006 <GetStringFromFIFOwithOverflowDetect+0x2>
    7030:	e0 91 12 0b 	lds	r30, 0x0B12
    7034:	f0 e0       	ldi	r31, 0x00	; 0
    7036:	ef 56       	subi	r30, 0x6F	; 111
    7038:	f8 4f       	sbci	r31, 0xF8	; 248
    703a:	80 81       	ld	r24, Z
    703c:	8d 30       	cpi	r24, 0x0D	; 13
    703e:	19 f7       	brne	.-58     	; 0x7006 <GetStringFromFIFOwithOverflowDetect+0x2>
    7040:	e0 91 12 0b 	lds	r30, 0x0B12
    7044:	f0 e0       	ldi	r31, 0x00	; 0
    7046:	ee 56       	subi	r30, 0x6E	; 110
    7048:	f8 4f       	sbci	r31, 0xF8	; 248
    704a:	80 81       	ld	r24, Z
    704c:	8a 30       	cpi	r24, 0x0A	; 10
    704e:	d9 f6       	brne	.-74     	; 0x7006 <GetStringFromFIFOwithOverflowDetect+0x2>
			GSM_RxStr[GSM_RxCharN-2] = '\0';
    7050:	e0 91 12 0b 	lds	r30, 0x0B12
    7054:	f0 e0       	ldi	r31, 0x00	; 0
    7056:	ef 56       	subi	r30, 0x6F	; 111
    7058:	f8 4f       	sbci	r31, 0xF8	; 248
    705a:	10 82       	st	Z, r1
			StrLength = GSM_RxCharN-1;
    705c:	80 91 12 0b 	lds	r24, 0x0B12
    7060:	81 50       	subi	r24, 0x01	; 1
			GSM_RxCharN = 0;
    7062:	10 92 12 0b 	sts	0x0B12, r1
    7066:	08 95       	ret

uint8_t GetStringFromFIFOwithOverflowDetect(void){

	uint8_t StrLength = 0;

	while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    7068:	80 e0       	ldi	r24, 0x00	; 0
		}

	}//while
	
	return StrLength;
}
    706a:	08 95       	ret

0000706c <ForceEndStringFromFIFO>:
// ~~~~~~~~~~~
//    GSM_RxStr  <CR><LF>
uint8_t ForceEndStringFromFIFO(void){
	uint8_t StrLength;
	if(GSM_RxCharN > GSM_RXSTR_SIZE-1) GSM_RxCharN = GSM_RXSTR_SIZE-1;
    706c:	80 91 12 0b 	lds	r24, 0x0B12
    7070:	84 36       	cpi	r24, 0x64	; 100
    7072:	18 f0       	brcs	.+6      	; 0x707a <ForceEndStringFromFIFO+0xe>
    7074:	83 e6       	ldi	r24, 0x63	; 99
    7076:	80 93 12 0b 	sts	0x0B12, r24
	StrLength = GSM_RxCharN;
    707a:	80 91 12 0b 	lds	r24, 0x0B12
	GSM_RxStr[GSM_RxCharN]='\0';
    707e:	e0 91 12 0b 	lds	r30, 0x0B12
    7082:	f0 e0       	ldi	r31, 0x00	; 0
    7084:	ed 56       	subi	r30, 0x6D	; 109
    7086:	f8 4f       	sbci	r31, 0xF8	; 248
    7088:	10 82       	st	Z, r1
	GSM_RxCharN = 0;
    708a:	10 92 12 0b 	sts	0x0B12, r1
	return StrLength;
}
    708e:	08 95       	ret

00007090 <GetDataFromFIFO>:

// ~~~~~~~~~~~
uint8_t GetDataFromFIFO(const uint8_t Amount){
    7090:	1f 93       	push	r17
    7092:	18 2f       	mov	r17, r24

	while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    7094:	90 91 f4 06 	lds	r25, 0x06F4
    7098:	80 91 4b 06 	lds	r24, 0x064B
    709c:	98 17       	cp	r25, r24
    709e:	81 f0       	breq	.+32     	; 0x70c0 <GetDataFromFIFO+0x30>
		GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);
    70a0:	83 e9       	ldi	r24, 0x93	; 147
    70a2:	97 e0       	ldi	r25, 0x07	; 7
    70a4:	62 e1       	ldi	r22, 0x12	; 18
    70a6:	7b e0       	ldi	r23, 0x0B	; 11
    70a8:	44 e6       	ldi	r20, 0x64	; 100
    70aa:	0e 94 69 37 	call	0x6ed2	; 0x6ed2 <GetByteFromFIFO>
		if(GSM_RxCharN >= Amount){
    70ae:	80 91 12 0b 	lds	r24, 0x0B12
    70b2:	81 17       	cp	r24, r17
    70b4:	78 f3       	brcs	.-34     	; 0x7094 <GetDataFromFIFO+0x4>
			GSM_RxCharN = 0;
    70b6:	10 92 12 0b 	sts	0x0B12, r1
			return Amount;
		}
	}//while
	return GSM_RxCharN;
}
    70ba:	81 2f       	mov	r24, r17
    70bc:	1f 91       	pop	r17
    70be:	08 95       	ret
		if(GSM_RxCharN >= Amount){
			GSM_RxCharN = 0;
			return Amount;
		}
	}//while
	return GSM_RxCharN;
    70c0:	10 91 12 0b 	lds	r17, 0x0B12
}
    70c4:	81 2f       	mov	r24, r17
    70c6:	1f 91       	pop	r17
    70c8:	08 95       	ret

000070ca <GSM_Init>:
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    70ca:	8f ef       	ldi	r24, 0xFF	; 255
    70cc:	80 93 f4 06 	sts	0x06F4, r24
	GSM_RX_FIFO_End = 255;
    70d0:	80 93 4b 06 	sts	0x064B, r24
	GSM_RxCharN = 0;
    70d4:	10 92 12 0b 	sts	0x0B12, r1
	GSM_RX_FIFOOverFlow = 0;
    70d8:	10 92 c5 08 	sts	0x08C5, r1
	GSM_RX_FIFOMax = 0;
    70dc:	10 92 cb 08 	sts	0x08CB, r1
		USART_GSM.BAUDCTRLB = 0x00 + USART_BSCALE0_bm;
		USART_GSM.CTRLA = USART_RXCINTLVL_HI_gc;
		USART_GSM.CTRLB = (1<<USART_RXEN_bp) | (1<<USART_TXEN_bp) | (0<<USART_CLK2X_bp) | (0 << USART_MPCM_bp) | (0 << USART_TXB8_bp);
		USART_GSM.CTRLC = USART_CMODE_ASYNCHRONOUS_gc | USART_PMODE_DISABLED_gc | (0<< USART_SBMODE_bp) | USART_CHSIZE_8BIT_gc;
	#else
		UCSR_GSM_A = ~(1<<U2X_GSM) &~(1<<MPCM_GSM);
    70e0:	8c ef       	ldi	r24, 0xFC	; 252
    70e2:	80 93 d0 00 	sts	0x00D0, r24
		UCSR_GSM_B =  (1<<RXCIE_GSM) | (0<<TXCIE_GSM) | (0<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    70e6:	88 e9       	ldi	r24, 0x98	; 152
    70e8:	80 93 d1 00 	sts	0x00D1, r24
		#if defined (__AVR_ATmega2561__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__)			
			UCSR_GSM_C = (0<<UMSEL_GSM_1) | (0<<UMSEL_GSM_0) | (0<<UPM_GSM_1) | (0<<UPM_GSM_0) | (0<<USBS_GSM) | (1<<UCSZ_GSM_1) | (1<<UCSZ_GSM_0) | (0<<UCPOL_GSM);
    70ec:	86 e0       	ldi	r24, 0x06	; 6
    70ee:	80 93 d2 00 	sts	0x00D2, r24
		#else
			UCSR_GSM_C = ((~(1<<UMSEL_GSM) &~(1<<UPM_GSM_1) &~(1<<UPM_GSM_0) &~(1<<USBS_GSM)) |(1<<UCSZ_GSM_1) |(1<<UCSZ_GSM_0)) &~(1<<UCPOL_GSM);
		#endif
		UBRR_GSM_H = 0x00;
    70f2:	10 92 d5 00 	sts	0x00D5, r1
		UBRR_GSM_L = 0x67;	// 9600
    70f6:	87 e6       	ldi	r24, 0x67	; 103
    70f8:	80 93 d4 00 	sts	0x00D4, r24
#endif

//  gsm_sim900r.h   PWRCNTRL
#ifdef vmd2_3
	void GSM_PWRCNTRL_Config(void){
		cli();
    70fc:	f8 94       	cli
		DDRL|=(1<<PL5);
    70fe:	ea e0       	ldi	r30, 0x0A	; 10
    7100:	f1 e0       	ldi	r31, 0x01	; 1
    7102:	80 81       	ld	r24, Z
    7104:	80 62       	ori	r24, 0x20	; 32
    7106:	80 83       	st	Z, r24
		sei();
    7108:	78 94       	sei
		cli();
		PORTL|=(1<<PL5);
		sei();
	}
	void GSM_PWRCNTRL_ON(void){
		cli();
    710a:	f8 94       	cli
		PORTL &= ~(1<<PL5);
    710c:	eb e0       	ldi	r30, 0x0B	; 11
    710e:	f1 e0       	ldi	r31, 0x01	; 1
    7110:	80 81       	ld	r24, Z
    7112:	8f 7d       	andi	r24, 0xDF	; 223
    7114:	80 83       	st	Z, r24
		sei();
    7116:	78 94       	sei

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    7118:	80 91 cd 02 	lds	r24, 0x02CD
	VacantTimer16Sys += n;
    711c:	98 2f       	mov	r25, r24
    711e:	9f 5f       	subi	r25, 0xFF	; 255
	GSM_PWRCNTRL_ON();
	#ifdef GSM_HW_FLOW_CONTROL
		GSM_CTS_RTS_Config();
	#endif

	TD_GSM = Timer16SysAlloc(1);
    7120:	80 93 e1 04 	sts	0x04E1, r24
    7124:	29 2f       	mov	r18, r25
    7126:	2f 5f       	subi	r18, 0xFF	; 255
	TD_TCP_Connect = Timer16SysAlloc(1);
    7128:	90 93 e2 04 	sts	0x04E2, r25

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer32SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer32Sys;
    712c:	90 91 ce 02 	lds	r25, 0x02CE
	VacantTimer32Sys += n;
    7130:	89 2f       	mov	r24, r25
    7132:	8f 5f       	subi	r24, 0xFF	; 255
	TD_GSM_Reset = Timer32SysAlloc(1);
    7134:	90 93 e3 04 	sts	0x04E3, r25
// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
	VacantTimer16Sys += n;
    7138:	92 2f       	mov	r25, r18
    713a:	9f 5f       	subi	r25, 0xFF	; 255
	TD_5min_timer = Timer16SysAlloc(1);
    713c:	20 93 e4 04 	sts	0x04E4, r18
// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer32SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer32Sys;
	VacantTimer32Sys += n;
    7140:	8f 5f       	subi	r24, 0xFF	; 255
    7142:	80 93 ce 02 	sts	0x02CE, r24
    7146:	81 50       	subi	r24, 0x01	; 1
	TD_1hour_resetGPRS_timer = Timer32SysAlloc(1);
    7148:	80 93 e5 04 	sts	0x04E5, r24
// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
	VacantTimer16Sys += n;
    714c:	89 2f       	mov	r24, r25
    714e:	8f 5f       	subi	r24, 0xFF	; 255
	TD_CheckModem = Timer16SysAlloc(1);
    7150:	90 93 e6 04 	sts	0x04E6, r25
    7154:	9e 5f       	subi	r25, 0xFE	; 254
	TD_CleanFIFO = Timer16SysAlloc(1);
    7156:	80 93 e7 04 	sts	0x04E7, r24
    715a:	8e 5f       	subi	r24, 0xFE	; 254
	TD_data_start_delay = Timer16SysAlloc(1);
    715c:	90 93 e8 04 	sts	0x04E8, r25
    7160:	8f 5f       	subi	r24, 0xFF	; 255
    7162:	80 93 cd 02 	sts	0x02CD, r24
    7166:	81 50       	subi	r24, 0x01	; 1
	TD_timer_after_page_transfer = Timer16SysAlloc(1);
    7168:	80 93 e9 04 	sts	0x04E9, r24

/*	for (uint8_t i=0; i<4; i++)
		GPRS_ServerAddr[i] = erb(GPRS_ServerAddr_EE+i);
*/
	GSM_Control = GSM_CNTL_AUTO;
    716c:	10 92 84 07 	sts	0x0784, r1
	GSM_State = GSM_PowerOn;
    7170:	10 92 ad 06 	sts	0x06AD, r1



}
    7174:	08 95       	ret

00007176 <GSM_RX>:
// ~~~~~~~~~
void
GSM_RX(void)
{
	char Char = UDR_GSM;
    7176:	90 91 d6 00 	lds	r25, 0x00D6

	//---FIFO
	GSM_RX_FIFO_Begin++;
    717a:	80 91 f4 06 	lds	r24, 0x06F4
    717e:	8f 5f       	subi	r24, 0xFF	; 255
    7180:	80 93 f4 06 	sts	0x06F4, r24
	if(GSM_RX_FIFO_Begin >= GSM_RX_FIFO_SIZE) GSM_RX_FIFO_Begin = 0;
    7184:	80 91 f4 06 	lds	r24, 0x06F4
    7188:	84 36       	cpi	r24, 0x64	; 100
    718a:	10 f0       	brcs	.+4      	; 0x7190 <GSM_RX+0x1a>
    718c:	10 92 f4 06 	sts	0x06F4, r1
	GSM_RX_FIFO[GSM_RX_FIFO_Begin] = Char;
    7190:	e0 91 f4 06 	lds	r30, 0x06F4
    7194:	f0 e0       	ldi	r31, 0x00	; 0
    7196:	e7 52       	subi	r30, 0x27	; 39
    7198:	fa 4f       	sbci	r31, 0xFA	; 250
    719a:	90 83       	st	Z, r25
	if(GSM_RX_FIFO_Begin == GSM_RX_FIFO_End){
    719c:	90 91 f4 06 	lds	r25, 0x06F4
    71a0:	80 91 4b 06 	lds	r24, 0x064B
    71a4:	98 13       	cpse	r25, r24
    71a6:	08 95       	ret
		GSM_RX_FIFOOverFlow = 1;
    71a8:	81 e0       	ldi	r24, 0x01	; 1
    71aa:	80 93 c5 08 	sts	0x08C5, r24
		GSM_RX_FIFOMax = GSM_RX_FIFO_SIZE;
    71ae:	84 e6       	ldi	r24, 0x64	; 100
    71b0:	80 93 cb 08 	sts	0x08CB, r24
    71b4:	08 95       	ret

000071b6 <GSM_Wait_Char>:
		else return 1;
	}
	else return 0;
}
// ~~~~~~~~~
uint8_t GSM_Wait_Char(char Char, uint8_t RestoreCMD){
    71b6:	0f 93       	push	r16
    71b8:	1f 93       	push	r17
    71ba:	08 2f       	mov	r16, r24
    71bc:	16 2f       	mov	r17, r22
	if(Timer16Stopp(TD_GSM)){
    71be:	80 91 e1 04 	lds	r24, 0x04E1
    71c2:	0e 94 59 1b 	call	0x36b2	; 0x36b2 <Timer16Stopp>
    71c6:	88 23       	and	r24, r24
    71c8:	39 f0       	breq	.+14     	; 0x71d8 <GSM_Wait_Char+0x22>
		GSM_State = RestoreCMD;
    71ca:	10 93 ad 06 	sts	0x06AD, r17
    71ce:	90 e0       	ldi	r25, 0x00	; 0
	if(GetDataFromFIFO(1)){
		if(GSM_RxStr[0] == Char)	return 1;
		else return 0;
	}
	else return 0;
}
    71d0:	89 2f       	mov	r24, r25
    71d2:	1f 91       	pop	r17
    71d4:	0f 91       	pop	r16
    71d6:	08 95       	ret
	if(Timer16Stopp(TD_GSM)){
		GSM_State = RestoreCMD;
		return 0;
	}
	//   
	if(GetDataFromFIFO(1)){
    71d8:	81 e0       	ldi	r24, 0x01	; 1
    71da:	0e 94 48 38 	call	0x7090	; 0x7090 <GetDataFromFIFO>
    71de:	88 23       	and	r24, r24
    71e0:	39 f0       	breq	.+14     	; 0x71f0 <GSM_Wait_Char+0x3a>
    71e2:	90 e0       	ldi	r25, 0x00	; 0
    71e4:	80 91 93 07 	lds	r24, 0x0793
    71e8:	80 17       	cp	r24, r16
    71ea:	91 f7       	brne	.-28     	; 0x71d0 <GSM_Wait_Char+0x1a>
    71ec:	91 e0       	ldi	r25, 0x01	; 1
    71ee:	f0 cf       	rjmp	.-32     	; 0x71d0 <GSM_Wait_Char+0x1a>
    71f0:	90 e0       	ldi	r25, 0x00	; 0
		if(GSM_RxStr[0] == Char)	return 1;
		else return 0;
	}
	else return 0;
}
    71f2:	89 2f       	mov	r24, r25
    71f4:	1f 91       	pop	r17
    71f6:	0f 91       	pop	r16
    71f8:	08 95       	ret

000071fa <GSM_SendFirstChar>:
// ~~~~~~~~~
void GSM_SendFirstChar(void){

	UDR_GSM = GSM_TxStr[0];
    71fa:	80 91 fc 09 	lds	r24, 0x09FC
    71fe:	80 93 d6 00 	sts	0x00D6, r24
	#ifdef GSM_DEBUG
		GPRS_TerminalProcess(GSM_TxStr[0]);
	#endif

	GSM_TxCharN = 1;
    7202:	81 e0       	ldi	r24, 0x01	; 1
    7204:	80 93 1b 0b 	sts	0x0B1B, r24
	cli();
    7208:	f8 94       	cli
	GSM_Flag &=~(1<<flg_TxCStr);	
    720a:	80 91 cf 02 	lds	r24, 0x02CF
    720e:	8e 7f       	andi	r24, 0xFE	; 254
    7210:	80 93 cf 02 	sts	0x02CF, r24
	sei();
    7214:	78 94       	sei
	cli();
    7216:	f8 94       	cli
	#if defined (__AVR_ATxmega128A1__)
		USART_GSM.CTRLA = USART_RXCINTLVL_HI_gc | USART_DREINTLVL_HI_gc;
	#else
		UCSR_GSM_B =  (1<<RXCIE_GSM) | (0<<TXCIE_GSM) | (1<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    7218:	88 eb       	ldi	r24, 0xB8	; 184
    721a:	80 93 d1 00 	sts	0x00D1, r24
	#endif
	
	sei();	
    721e:	78 94       	sei
}
    7220:	08 95       	ret

00007222 <GSM_DRE>:
		StartTimer16(TD_GSM, Timeout);
	}
}
// ~~~~~~~~~
void GSM_DRE(void){
	if(GSM_TxCharN < GSMTxSz){
    7222:	90 91 1b 0b 	lds	r25, 0x0B1B
    7226:	80 91 6f 07 	lds	r24, 0x076F
    722a:	98 17       	cp	r25, r24
    722c:	20 f0       	brcs	.+8      	; 0x7236 <GSM_DRE+0x14>
	}
	else{
		#if defined (__AVR_ATxmega128A1__)
			USART_GSM.CTRLA = USART_RXCINTLVL_HI_gc | USART_TXCINTLVL_HI_gc;
		#else
			UCSR_GSM_B =  (1<<RXCIE_GSM) | (1<<TXCIE_GSM) | (0<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    722e:	88 ed       	ldi	r24, 0xD8	; 216
    7230:	80 93 d1 00 	sts	0x00D1, r24
    7234:	08 95       	ret
	}
}
// ~~~~~~~~~
void GSM_DRE(void){
	if(GSM_TxCharN < GSMTxSz){
		UDR_GSM = GSM_TxStr[GSM_TxCharN];
    7236:	e0 91 1b 0b 	lds	r30, 0x0B1B
    723a:	f0 e0       	ldi	r31, 0x00	; 0
    723c:	e4 50       	subi	r30, 0x04	; 4
    723e:	f6 4f       	sbci	r31, 0xF6	; 246
    7240:	80 81       	ld	r24, Z
    7242:	80 93 d6 00 	sts	0x00D6, r24
		#ifdef GSM_DEBUG
			GPRS_TerminalProcess(GSM_TxStr[GSM_TxCharN]);
		#endif
		GSM_TxCharN++;
    7246:	80 91 1b 0b 	lds	r24, 0x0B1B
    724a:	8f 5f       	subi	r24, 0xFF	; 255
    724c:	80 93 1b 0b 	sts	0x0B1B, r24
    7250:	08 95       	ret

00007252 <GSM_TX>:
}
// ~~~~~~~~~
void
GSM_TX(void)
{
	GSM_Flag |=(1<<flg_TxCStr);
    7252:	80 91 cf 02 	lds	r24, 0x02CF
    7256:	81 60       	ori	r24, 0x01	; 1
    7258:	80 93 cf 02 	sts	0x02CF, r24
	if(dataSendFlg){
    725c:	80 91 db 02 	lds	r24, 0x02DB
    7260:	88 23       	and	r24, r24
    7262:	21 f0       	breq	.+8      	; 0x726c <GSM_TX+0x1a>
	dataSendFlg=0;
    7264:	10 92 db 02 	sts	0x02DB, r1
	GPRS_FlgSz_Out=0;
    7268:	10 92 67 07 	sts	0x0767, r1
	}
	#if defined (__AVR_ATxmega128A1__)
		USART_GSM.CTRLA = USART_RXCINTLVL_HI_gc;
	#else
		UCSR_GSM_B =  (1<<RXCIE_GSM) | (0<<TXCIE_GSM) | (0<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    726c:	88 e9       	ldi	r24, 0x98	; 152
    726e:	80 93 d1 00 	sts	0x00D1, r24
	#endif
}
    7272:	08 95       	ret

00007274 <GSM_Reset>:
GSM_Reset(void)
{
/*	IntOff();
	GSM_State = GSM_Restart;
	IntOn();*/
}
    7274:	08 95       	ret

00007276 <GSM_GotoNextVega>:

uint8_t GSM_GotoNextVega(void){
 return 0;
}
    7276:	80 e0       	ldi	r24, 0x00	; 0
    7278:	08 95       	ret

0000727a <GPRS_ServerAddr_Save>:
// ~~~~~~~~~~~~~~~~~~~~~~~~
void
GPRS_ServerAddr_Save(void)
{

}
    727a:	08 95       	ret

0000727c <__vector_25>:
#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__)
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	#ifdef vmd2_3
		// ~~~~~~~~~~
		// USART0 - PORT0
		Modbus_ISR(0)
    727c:	1f 92       	push	r1
    727e:	0f 92       	push	r0
    7280:	0f b6       	in	r0, 0x3f	; 63
    7282:	0f 92       	push	r0
    7284:	0b b6       	in	r0, 0x3b	; 59
    7286:	0f 92       	push	r0
    7288:	11 24       	eor	r1, r1
    728a:	2f 93       	push	r18
    728c:	3f 93       	push	r19
    728e:	4f 93       	push	r20
    7290:	5f 93       	push	r21
    7292:	6f 93       	push	r22
    7294:	7f 93       	push	r23
    7296:	8f 93       	push	r24
    7298:	9f 93       	push	r25
    729a:	af 93       	push	r26
    729c:	bf 93       	push	r27
    729e:	ef 93       	push	r30
    72a0:	ff 93       	push	r31
    72a2:	86 ec       	ldi	r24, 0xC6	; 198
    72a4:	90 e0       	ldi	r25, 0x00	; 0
    72a6:	0e 94 33 29 	call	0x5266	; 0x5266 <Modbus_RX>
    72aa:	ff 91       	pop	r31
    72ac:	ef 91       	pop	r30
    72ae:	bf 91       	pop	r27
    72b0:	af 91       	pop	r26
    72b2:	9f 91       	pop	r25
    72b4:	8f 91       	pop	r24
    72b6:	7f 91       	pop	r23
    72b8:	6f 91       	pop	r22
    72ba:	5f 91       	pop	r21
    72bc:	4f 91       	pop	r20
    72be:	3f 91       	pop	r19
    72c0:	2f 91       	pop	r18
    72c2:	0f 90       	pop	r0
    72c4:	0b be       	out	0x3b, r0	; 59
    72c6:	0f 90       	pop	r0
    72c8:	0f be       	out	0x3f, r0	; 63
    72ca:	0f 90       	pop	r0
    72cc:	1f 90       	pop	r1
    72ce:	18 95       	reti

000072d0 <__vector_27>:
    72d0:	1f 92       	push	r1
    72d2:	0f 92       	push	r0
    72d4:	0f b6       	in	r0, 0x3f	; 63
    72d6:	0f 92       	push	r0
    72d8:	0b b6       	in	r0, 0x3b	; 59
    72da:	0f 92       	push	r0
    72dc:	11 24       	eor	r1, r1
    72de:	2f 93       	push	r18
    72e0:	3f 93       	push	r19
    72e2:	4f 93       	push	r20
    72e4:	5f 93       	push	r21
    72e6:	6f 93       	push	r22
    72e8:	7f 93       	push	r23
    72ea:	8f 93       	push	r24
    72ec:	9f 93       	push	r25
    72ee:	af 93       	push	r26
    72f0:	bf 93       	push	r27
    72f2:	ef 93       	push	r30
    72f4:	ff 93       	push	r31
    72f6:	86 ec       	ldi	r24, 0xC6	; 198
    72f8:	90 e0       	ldi	r25, 0x00	; 0
    72fa:	0e 94 d2 34 	call	0x69a4	; 0x69a4 <Modbus_TX>
    72fe:	ff 91       	pop	r31
    7300:	ef 91       	pop	r30
    7302:	bf 91       	pop	r27
    7304:	af 91       	pop	r26
    7306:	9f 91       	pop	r25
    7308:	8f 91       	pop	r24
    730a:	7f 91       	pop	r23
    730c:	6f 91       	pop	r22
    730e:	5f 91       	pop	r21
    7310:	4f 91       	pop	r20
    7312:	3f 91       	pop	r19
    7314:	2f 91       	pop	r18
    7316:	0f 90       	pop	r0
    7318:	0b be       	out	0x3b, r0	; 59
    731a:	0f 90       	pop	r0
    731c:	0f be       	out	0x3f, r0	; 63
    731e:	0f 90       	pop	r0
    7320:	1f 90       	pop	r1
    7322:	18 95       	reti

00007324 <__vector_26>:
    7324:	1f 92       	push	r1
    7326:	0f 92       	push	r0
    7328:	0f b6       	in	r0, 0x3f	; 63
    732a:	0f 92       	push	r0
    732c:	0b b6       	in	r0, 0x3b	; 59
    732e:	0f 92       	push	r0
    7330:	11 24       	eor	r1, r1
    7332:	2f 93       	push	r18
    7334:	3f 93       	push	r19
    7336:	4f 93       	push	r20
    7338:	5f 93       	push	r21
    733a:	6f 93       	push	r22
    733c:	7f 93       	push	r23
    733e:	8f 93       	push	r24
    7340:	9f 93       	push	r25
    7342:	af 93       	push	r26
    7344:	bf 93       	push	r27
    7346:	ef 93       	push	r30
    7348:	ff 93       	push	r31
    734a:	86 ec       	ldi	r24, 0xC6	; 198
    734c:	90 e0       	ldi	r25, 0x00	; 0
    734e:	0e 94 d2 34 	call	0x69a4	; 0x69a4 <Modbus_TX>
    7352:	ff 91       	pop	r31
    7354:	ef 91       	pop	r30
    7356:	bf 91       	pop	r27
    7358:	af 91       	pop	r26
    735a:	9f 91       	pop	r25
    735c:	8f 91       	pop	r24
    735e:	7f 91       	pop	r23
    7360:	6f 91       	pop	r22
    7362:	5f 91       	pop	r21
    7364:	4f 91       	pop	r20
    7366:	3f 91       	pop	r19
    7368:	2f 91       	pop	r18
    736a:	0f 90       	pop	r0
    736c:	0b be       	out	0x3b, r0	; 59
    736e:	0f 90       	pop	r0
    7370:	0f be       	out	0x3f, r0	; 63
    7372:	0f 90       	pop	r0
    7374:	1f 90       	pop	r1
    7376:	18 95       	reti

00007378 <__vector_36>:

		// ~~~~~~~~~~
		// USART1 - PORT1
		Modbus_ISR(1)
    7378:	1f 92       	push	r1
    737a:	0f 92       	push	r0
    737c:	0f b6       	in	r0, 0x3f	; 63
    737e:	0f 92       	push	r0
    7380:	0b b6       	in	r0, 0x3b	; 59
    7382:	0f 92       	push	r0
    7384:	11 24       	eor	r1, r1
    7386:	2f 93       	push	r18
    7388:	3f 93       	push	r19
    738a:	4f 93       	push	r20
    738c:	5f 93       	push	r21
    738e:	6f 93       	push	r22
    7390:	7f 93       	push	r23
    7392:	8f 93       	push	r24
    7394:	9f 93       	push	r25
    7396:	af 93       	push	r26
    7398:	bf 93       	push	r27
    739a:	ef 93       	push	r30
    739c:	ff 93       	push	r31
    739e:	8e ec       	ldi	r24, 0xCE	; 206
    73a0:	90 e0       	ldi	r25, 0x00	; 0
    73a2:	0e 94 33 29 	call	0x5266	; 0x5266 <Modbus_RX>
    73a6:	ff 91       	pop	r31
    73a8:	ef 91       	pop	r30
    73aa:	bf 91       	pop	r27
    73ac:	af 91       	pop	r26
    73ae:	9f 91       	pop	r25
    73b0:	8f 91       	pop	r24
    73b2:	7f 91       	pop	r23
    73b4:	6f 91       	pop	r22
    73b6:	5f 91       	pop	r21
    73b8:	4f 91       	pop	r20
    73ba:	3f 91       	pop	r19
    73bc:	2f 91       	pop	r18
    73be:	0f 90       	pop	r0
    73c0:	0b be       	out	0x3b, r0	; 59
    73c2:	0f 90       	pop	r0
    73c4:	0f be       	out	0x3f, r0	; 63
    73c6:	0f 90       	pop	r0
    73c8:	1f 90       	pop	r1
    73ca:	18 95       	reti

000073cc <__vector_38>:
    73cc:	1f 92       	push	r1
    73ce:	0f 92       	push	r0
    73d0:	0f b6       	in	r0, 0x3f	; 63
    73d2:	0f 92       	push	r0
    73d4:	0b b6       	in	r0, 0x3b	; 59
    73d6:	0f 92       	push	r0
    73d8:	11 24       	eor	r1, r1
    73da:	2f 93       	push	r18
    73dc:	3f 93       	push	r19
    73de:	4f 93       	push	r20
    73e0:	5f 93       	push	r21
    73e2:	6f 93       	push	r22
    73e4:	7f 93       	push	r23
    73e6:	8f 93       	push	r24
    73e8:	9f 93       	push	r25
    73ea:	af 93       	push	r26
    73ec:	bf 93       	push	r27
    73ee:	ef 93       	push	r30
    73f0:	ff 93       	push	r31
    73f2:	8e ec       	ldi	r24, 0xCE	; 206
    73f4:	90 e0       	ldi	r25, 0x00	; 0
    73f6:	0e 94 d2 34 	call	0x69a4	; 0x69a4 <Modbus_TX>
    73fa:	ff 91       	pop	r31
    73fc:	ef 91       	pop	r30
    73fe:	bf 91       	pop	r27
    7400:	af 91       	pop	r26
    7402:	9f 91       	pop	r25
    7404:	8f 91       	pop	r24
    7406:	7f 91       	pop	r23
    7408:	6f 91       	pop	r22
    740a:	5f 91       	pop	r21
    740c:	4f 91       	pop	r20
    740e:	3f 91       	pop	r19
    7410:	2f 91       	pop	r18
    7412:	0f 90       	pop	r0
    7414:	0b be       	out	0x3b, r0	; 59
    7416:	0f 90       	pop	r0
    7418:	0f be       	out	0x3f, r0	; 63
    741a:	0f 90       	pop	r0
    741c:	1f 90       	pop	r1
    741e:	18 95       	reti

00007420 <__vector_37>:
    7420:	1f 92       	push	r1
    7422:	0f 92       	push	r0
    7424:	0f b6       	in	r0, 0x3f	; 63
    7426:	0f 92       	push	r0
    7428:	0b b6       	in	r0, 0x3b	; 59
    742a:	0f 92       	push	r0
    742c:	11 24       	eor	r1, r1
    742e:	2f 93       	push	r18
    7430:	3f 93       	push	r19
    7432:	4f 93       	push	r20
    7434:	5f 93       	push	r21
    7436:	6f 93       	push	r22
    7438:	7f 93       	push	r23
    743a:	8f 93       	push	r24
    743c:	9f 93       	push	r25
    743e:	af 93       	push	r26
    7440:	bf 93       	push	r27
    7442:	ef 93       	push	r30
    7444:	ff 93       	push	r31
    7446:	8e ec       	ldi	r24, 0xCE	; 206
    7448:	90 e0       	ldi	r25, 0x00	; 0
    744a:	0e 94 d2 34 	call	0x69a4	; 0x69a4 <Modbus_TX>
    744e:	ff 91       	pop	r31
    7450:	ef 91       	pop	r30
    7452:	bf 91       	pop	r27
    7454:	af 91       	pop	r26
    7456:	9f 91       	pop	r25
    7458:	8f 91       	pop	r24
    745a:	7f 91       	pop	r23
    745c:	6f 91       	pop	r22
    745e:	5f 91       	pop	r21
    7460:	4f 91       	pop	r20
    7462:	3f 91       	pop	r19
    7464:	2f 91       	pop	r18
    7466:	0f 90       	pop	r0
    7468:	0b be       	out	0x3b, r0	; 59
    746a:	0f 90       	pop	r0
    746c:	0f be       	out	0x3f, r0	; 63
    746e:	0f 90       	pop	r0
    7470:	1f 90       	pop	r1
    7472:	18 95       	reti

00007474 <__vector_52>:

		// USART2 - PORT2 (only GSM)
		#ifdef GSM
			#ifndef SIM300DZ
				ISR(USART2_UDRE_vect) {GSM_DRE();}
    7474:	1f 92       	push	r1
    7476:	0f 92       	push	r0
    7478:	0f b6       	in	r0, 0x3f	; 63
    747a:	0f 92       	push	r0
    747c:	0b b6       	in	r0, 0x3b	; 59
    747e:	0f 92       	push	r0
    7480:	11 24       	eor	r1, r1
    7482:	2f 93       	push	r18
    7484:	3f 93       	push	r19
    7486:	4f 93       	push	r20
    7488:	5f 93       	push	r21
    748a:	6f 93       	push	r22
    748c:	7f 93       	push	r23
    748e:	8f 93       	push	r24
    7490:	9f 93       	push	r25
    7492:	af 93       	push	r26
    7494:	bf 93       	push	r27
    7496:	ef 93       	push	r30
    7498:	ff 93       	push	r31
    749a:	0e 94 11 39 	call	0x7222	; 0x7222 <GSM_DRE>
    749e:	ff 91       	pop	r31
    74a0:	ef 91       	pop	r30
    74a2:	bf 91       	pop	r27
    74a4:	af 91       	pop	r26
    74a6:	9f 91       	pop	r25
    74a8:	8f 91       	pop	r24
    74aa:	7f 91       	pop	r23
    74ac:	6f 91       	pop	r22
    74ae:	5f 91       	pop	r21
    74b0:	4f 91       	pop	r20
    74b2:	3f 91       	pop	r19
    74b4:	2f 91       	pop	r18
    74b6:	0f 90       	pop	r0
    74b8:	0b be       	out	0x3b, r0	; 59
    74ba:	0f 90       	pop	r0
    74bc:	0f be       	out	0x3f, r0	; 63
    74be:	0f 90       	pop	r0
    74c0:	1f 90       	pop	r1
    74c2:	18 95       	reti

000074c4 <__vector_53>:
			#endif
			ISR(USART2_TX_vect) {GSM_TX();}
    74c4:	1f 92       	push	r1
    74c6:	0f 92       	push	r0
    74c8:	0f b6       	in	r0, 0x3f	; 63
    74ca:	0f 92       	push	r0
    74cc:	0b b6       	in	r0, 0x3b	; 59
    74ce:	0f 92       	push	r0
    74d0:	11 24       	eor	r1, r1
    74d2:	2f 93       	push	r18
    74d4:	3f 93       	push	r19
    74d6:	4f 93       	push	r20
    74d8:	5f 93       	push	r21
    74da:	6f 93       	push	r22
    74dc:	7f 93       	push	r23
    74de:	8f 93       	push	r24
    74e0:	9f 93       	push	r25
    74e2:	af 93       	push	r26
    74e4:	bf 93       	push	r27
    74e6:	ef 93       	push	r30
    74e8:	ff 93       	push	r31
    74ea:	0e 94 29 39 	call	0x7252	; 0x7252 <GSM_TX>
    74ee:	ff 91       	pop	r31
    74f0:	ef 91       	pop	r30
    74f2:	bf 91       	pop	r27
    74f4:	af 91       	pop	r26
    74f6:	9f 91       	pop	r25
    74f8:	8f 91       	pop	r24
    74fa:	7f 91       	pop	r23
    74fc:	6f 91       	pop	r22
    74fe:	5f 91       	pop	r21
    7500:	4f 91       	pop	r20
    7502:	3f 91       	pop	r19
    7504:	2f 91       	pop	r18
    7506:	0f 90       	pop	r0
    7508:	0b be       	out	0x3b, r0	; 59
    750a:	0f 90       	pop	r0
    750c:	0f be       	out	0x3f, r0	; 63
    750e:	0f 90       	pop	r0
    7510:	1f 90       	pop	r1
    7512:	18 95       	reti

00007514 <__vector_51>:
			ISR(USART2_RX_vect) {GSM_RX();}
    7514:	1f 92       	push	r1
    7516:	0f 92       	push	r0
    7518:	0f b6       	in	r0, 0x3f	; 63
    751a:	0f 92       	push	r0
    751c:	0b b6       	in	r0, 0x3b	; 59
    751e:	0f 92       	push	r0
    7520:	11 24       	eor	r1, r1
    7522:	2f 93       	push	r18
    7524:	3f 93       	push	r19
    7526:	4f 93       	push	r20
    7528:	5f 93       	push	r21
    752a:	6f 93       	push	r22
    752c:	7f 93       	push	r23
    752e:	8f 93       	push	r24
    7530:	9f 93       	push	r25
    7532:	af 93       	push	r26
    7534:	bf 93       	push	r27
    7536:	ef 93       	push	r30
    7538:	ff 93       	push	r31
    753a:	0e 94 bb 38 	call	0x7176	; 0x7176 <GSM_RX>
    753e:	ff 91       	pop	r31
    7540:	ef 91       	pop	r30
    7542:	bf 91       	pop	r27
    7544:	af 91       	pop	r26
    7546:	9f 91       	pop	r25
    7548:	8f 91       	pop	r24
    754a:	7f 91       	pop	r23
    754c:	6f 91       	pop	r22
    754e:	5f 91       	pop	r21
    7550:	4f 91       	pop	r20
    7552:	3f 91       	pop	r19
    7554:	2f 91       	pop	r18
    7556:	0f 90       	pop	r0
    7558:	0b be       	out	0x3b, r0	; 59
    755a:	0f 90       	pop	r0
    755c:	0f be       	out	0x3f, r0	; 63
    755e:	0f 90       	pop	r0
    7560:	1f 90       	pop	r1
    7562:	18 95       	reti

00007564 <KeypadInit>:
		for (uint8_t str=0; str<sizeof(KeyStr); str++) {
			uint8_t KS = prb(KeyStr+str);
			DDR_Key &=~KS;
			PortKey |=KS;
		}*/
		DDR_KeyROW1 |= KeyROW1;
    7564:	81 9a       	sbi	0x10, 1	; 16
		DDR_KeyROW2 |= KeyROW2;
    7566:	80 9a       	sbi	0x10, 0	; 16
		PortKeyROW1 |= KeyROW1;
    7568:	89 9a       	sbi	0x11, 1	; 17
		PortKeyROW2 |= KeyROW2;
    756a:	88 9a       	sbi	0x11, 0	; 17
		
		DDR_KeySTR1 &= ~KeySTR1;
    756c:	85 98       	cbi	0x10, 5	; 16
		DDR_KeySTR2 &= ~KeySTR2;
    756e:	84 98       	cbi	0x10, 4	; 16
		DDR_KeySTR3 &= ~KeySTR3;
    7570:	82 98       	cbi	0x10, 2	; 16
		PortKeySTR1 |= KeySTR1;
    7572:	8d 9a       	sbi	0x11, 5	; 17
		PortKeySTR2 |= KeySTR2;
    7574:	8c 9a       	sbi	0x11, 4	; 17
		PortKeySTR3 |= KeySTR3;
    7576:	8a 9a       	sbi	0x11, 2	; 17
}

uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    7578:	80 91 cc 02 	lds	r24, 0x02CC
	VacantTimer8Sys += n;
    757c:	8f 5f       	subi	r24, 0xFF	; 255
    757e:	80 93 cc 02 	sts	0x02CC, r24
    7582:	81 50       	subi	r24, 0x01	; 1
		PORTJ.DIRCLR = (1<<7);
		for (uint8_t str=1; str<sizeof(KeyStr); str++)
			PORTK.DIRCLR = prb(KeyStr+str);
		PORTJ.PIN7CTRL = PORTK.PIN0CTRL = PORTK.PIN1CTRL = PORTK.PIN2CTRL = PORTK.PIN3CTRL = PORT_OPC_PULLUP_gc;
	#endif
	TD_Keypad = Timer8SysAlloc(1);
    7584:	80 93 eb 04 	sts	0x04EB, r24
}
    7588:	08 95       	ret

0000758a <KeypadIn>:
	return KeyPressedNonFilter = Key;
}
// ~~~~~~~~~~~
uint8_t
KeypadIn(void)
{
    758a:	0f 93       	push	r16
    758c:	1f 93       	push	r17
			}
		}
		RowOff(KR);
	}*/

	cli(); PortKeyROW1 &= ~KeyROW1; sei();
    758e:	f8 94       	cli
    7590:	89 98       	cbi	0x11, 1	; 17
    7592:	78 94       	sei
    7594:	85 e3       	ldi	r24, 0x35	; 53
    7596:	8a 95       	dec	r24
    7598:	f1 f7       	brne	.-4      	; 0x7596 <KeypadIn+0xc>
	_delay_us(10);		// By trial
	if(!(PIN_KeySTR1 & (KeySTR1))){ Key=2; PresKeysQuant++;} 
    759a:	7d 99       	sbic	0x0f, 5	; 15
    759c:	38 c0       	rjmp	.+112    	; 0x760e <KeypadIn+0x84>
    759e:	91 e0       	ldi	r25, 0x01	; 1
    75a0:	02 e0       	ldi	r16, 0x02	; 2
	if(!(PIN_KeySTR2 & (KeySTR2))){ Key=6; PresKeysQuant++;} 
    75a2:	7c 99       	sbic	0x0f, 4	; 15
    75a4:	02 c0       	rjmp	.+4      	; 0x75aa <KeypadIn+0x20>
    75a6:	9f 5f       	subi	r25, 0xFF	; 255
    75a8:	06 e0       	ldi	r16, 0x06	; 6
	if(!(PIN_KeySTR3 & (KeySTR3))){ Key=4; PresKeysQuant++;} 
    75aa:	7a 99       	sbic	0x0f, 2	; 15
    75ac:	02 c0       	rjmp	.+4      	; 0x75b2 <KeypadIn+0x28>
    75ae:	9f 5f       	subi	r25, 0xFF	; 255
    75b0:	04 e0       	ldi	r16, 0x04	; 4
	cli(); PortKeyROW1 |= KeyROW1; sei();	
    75b2:	f8 94       	cli
    75b4:	89 9a       	sbi	0x11, 1	; 17
    75b6:	78 94       	sei

	cli(); PortKeyROW2 &= ~KeyROW2; sei();
    75b8:	f8 94       	cli
    75ba:	88 98       	cbi	0x11, 0	; 17
    75bc:	78 94       	sei
    75be:	85 e3       	ldi	r24, 0x35	; 53
    75c0:	8a 95       	dec	r24
    75c2:	f1 f7       	brne	.-4      	; 0x75c0 <KeypadIn+0x36>
	_delay_us(10);		// By trial
	if(!(PIN_KeySTR1 & (KeySTR1))){ Key=1; PresKeysQuant++;}
    75c4:	7d 99       	sbic	0x0f, 5	; 15
    75c6:	02 c0       	rjmp	.+4      	; 0x75cc <KeypadIn+0x42>
    75c8:	9f 5f       	subi	r25, 0xFF	; 255
    75ca:	01 e0       	ldi	r16, 0x01	; 1
	if(!(PIN_KeySTR2 & (KeySTR2))){ Key=5; PresKeysQuant++;}
    75cc:	7c 99       	sbic	0x0f, 4	; 15
    75ce:	02 c0       	rjmp	.+4      	; 0x75d4 <KeypadIn+0x4a>
    75d0:	9f 5f       	subi	r25, 0xFF	; 255
    75d2:	05 e0       	ldi	r16, 0x05	; 5
	if(!(PIN_KeySTR3 & (KeySTR3))){ Key=3; PresKeysQuant++;}
    75d4:	7a 99       	sbic	0x0f, 2	; 15
    75d6:	02 c0       	rjmp	.+4      	; 0x75dc <KeypadIn+0x52>
    75d8:	9f 5f       	subi	r25, 0xFF	; 255
    75da:	03 e0       	ldi	r16, 0x03	; 3
	cli(); PortKeyROW2 |= KeyROW2; sei();
    75dc:	f8 94       	cli
    75de:	88 9a       	sbi	0x11, 0	; 17
    75e0:	78 94       	sei
	if(PresKeysQuant!=1) Key = 0;
    75e2:	91 30       	cpi	r25, 0x01	; 1
    75e4:	09 f4       	brne	.+2      	; 0x75e8 <KeypadIn+0x5e>
    75e6:	4a c0       	rjmp	.+148    	; 0x767c <KeypadIn+0xf2>

	return KeyPressedNonFilter = Key;
    75e8:	10 92 c3 08 	sts	0x08C3, r1
    75ec:	00 e0       	ldi	r16, 0x00	; 0
{
	static uint8_t PrevKey;
	uint8_t KeyResult = 0;
	uint8_t Key = KeypadScan();	//   
	if(Key) KeyPressedCounter++;
	if(Key != PrevKey){			//     -   
    75ee:	80 91 dd 02 	lds	r24, 0x02DD
    75f2:	80 17       	cp	r24, r16
    75f4:	11 f0       	breq	.+4      	; 0x75fa <KeypadIn+0x70>
		PrevKey = 0;
    75f6:	10 92 dd 02 	sts	0x02DD, r1
	}
	
	if (Timer8Stopp(TD_Keypad)) {
    75fa:	10 91 eb 04 	lds	r17, 0x04EB
    75fe:	81 2f       	mov	r24, r17
    7600:	0e 94 36 1b 	call	0x366c	; 0x366c <Timer8Stopp>
    7604:	88 23       	and	r24, r24
    7606:	31 f4       	brne	.+12     	; 0x7614 <KeypadIn+0x8a>
					for(I=0;I<=(KeyQuantity/8);I++) *((uint8_t*)RKEY+I) = 0;
				}
		#endif
	}
	return KeyResult;
}
    7608:	1f 91       	pop	r17
    760a:	0f 91       	pop	r16
    760c:	08 95       	ret
		RowOff(KR);
	}*/

	cli(); PortKeyROW1 &= ~KeyROW1; sei();
	_delay_us(10);		// By trial
	if(!(PIN_KeySTR1 & (KeySTR1))){ Key=2; PresKeysQuant++;} 
    760e:	90 e0       	ldi	r25, 0x00	; 0
    7610:	00 e0       	ldi	r16, 0x00	; 0
    7612:	c7 cf       	rjmp	.-114    	; 0x75a2 <KeypadIn+0x18>
	if(Key != PrevKey){			//     -   
		PrevKey = 0;
	}
	
	if (Timer8Stopp(TD_Keypad)) {
		StartTimer8(TD_Keypad, 6);	// By trial keystroke time == 70-180 ms
    7614:	81 2f       	mov	r24, r17
    7616:	66 e0       	ldi	r22, 0x06	; 6
    7618:	0e 94 e2 19 	call	0x33c4	; 0x33c4 <StartTimer8>
		if (Key != PrevKey) {
    761c:	80 91 dd 02 	lds	r24, 0x02DD
    7620:	80 17       	cp	r24, r16
    7622:	09 f4       	brne	.+2      	; 0x7626 <KeypadIn+0x9c>
    7624:	44 c0       	rjmp	.+136    	; 0x76ae <KeypadIn+0x124>
				PrevKey = Key;
    7626:	00 93 dd 02 	sts	0x02DD, r16
				Key = 0;
				KeyStroke = 0;
    762a:	10 92 ea 04 	sts	0x04EA, r1

		#ifdef RKEY
			#ifdef QslRD
				if(!*(uint8_t*)RNUM)
			#endif
				if (KeyResult==0) {
    762e:	40 e0       	ldi	r20, 0x00	; 0
    7630:	50 e0       	ldi	r21, 0x00	; 0
					uint8_t I = 0;
					while (1<<(I++ & 0b00000111) != *((uint8_t*)RKEY+(I>>3)) && I<=KeyQuantity);
    7632:	a1 e0       	ldi	r26, 0x01	; 1
    7634:	b0 e0       	ldi	r27, 0x00	; 0

		#ifdef RKEY
			#ifdef QslRD
				if(!*(uint8_t*)RNUM)
			#endif
				if (KeyResult==0) {
    7636:	e4 2f       	mov	r30, r20
    7638:	64 2f       	mov	r22, r20
    763a:	6f 5f       	subi	r22, 0xFF	; 255
					uint8_t I = 0;
					while (1<<(I++ & 0b00000111) != *((uint8_t*)RKEY+(I>>3)) && I<=KeyQuantity);
    763c:	9a 01       	movw	r18, r20
    763e:	27 70       	andi	r18, 0x07	; 7
    7640:	30 70       	andi	r19, 0x00	; 0
    7642:	cd 01       	movw	r24, r26
    7644:	02 c0       	rjmp	.+4      	; 0x764a <KeypadIn+0xc0>
    7646:	88 0f       	add	r24, r24
    7648:	99 1f       	adc	r25, r25
    764a:	2a 95       	dec	r18
    764c:	e2 f7       	brpl	.-8      	; 0x7646 <KeypadIn+0xbc>
    764e:	9c 01       	movw	r18, r24
    7650:	e6 95       	lsr	r30
    7652:	e6 95       	lsr	r30
    7654:	e6 95       	lsr	r30
    7656:	f0 e0       	ldi	r31, 0x00	; 0
    7658:	ed 58       	subi	r30, 0x8D	; 141
    765a:	f8 4f       	sbci	r31, 0xF8	; 248
    765c:	80 81       	ld	r24, Z
    765e:	90 e0       	ldi	r25, 0x00	; 0
    7660:	28 17       	cp	r18, r24
    7662:	39 07       	cpc	r19, r25
    7664:	b1 f1       	breq	.+108    	; 0x76d2 <KeypadIn+0x148>
    7666:	4f 5f       	subi	r20, 0xFF	; 255
    7668:	5f 4f       	sbci	r21, 0xFF	; 255
    766a:	47 30       	cpi	r20, 0x07	; 7
    766c:	51 05       	cpc	r21, r1
    766e:	19 f7       	brne	.-58     	; 0x7636 <KeypadIn+0xac>
					if (I<=KeyQuantity)
    7670:	80 e0       	ldi	r24, 0x00	; 0
						KeyResult = I;
					for(I=0;I<=(KeyQuantity/8);I++) *((uint8_t*)RKEY+I) = 0;
    7672:	10 92 73 07 	sts	0x0773, r1
				}
		#endif
	}
	return KeyResult;
}
    7676:	1f 91       	pop	r17
    7678:	0f 91       	pop	r16
    767a:	08 95       	ret
	if(!(PIN_KeySTR2 & (KeySTR2))){ Key=5; PresKeysQuant++;}
	if(!(PIN_KeySTR3 & (KeySTR3))){ Key=3; PresKeysQuant++;}
	cli(); PortKeyROW2 |= KeyROW2; sei();
	if(PresKeysQuant!=1) Key = 0;

	return KeyPressedNonFilter = Key;
    767c:	00 93 c3 08 	sts	0x08C3, r16
KeypadIn(void)
{
	static uint8_t PrevKey;
	uint8_t KeyResult = 0;
	uint8_t Key = KeypadScan();	//   
	if(Key) KeyPressedCounter++;
    7680:	00 23       	and	r16, r16
    7682:	09 f4       	brne	.+2      	; 0x7686 <KeypadIn+0xfc>
    7684:	b4 cf       	rjmp	.-152    	; 0x75ee <KeypadIn+0x64>
    7686:	80 91 f0 06 	lds	r24, 0x06F0
    768a:	90 91 f1 06 	lds	r25, 0x06F1
    768e:	a0 91 f2 06 	lds	r26, 0x06F2
    7692:	b0 91 f3 06 	lds	r27, 0x06F3
    7696:	01 96       	adiw	r24, 0x01	; 1
    7698:	a1 1d       	adc	r26, r1
    769a:	b1 1d       	adc	r27, r1
    769c:	80 93 f0 06 	sts	0x06F0, r24
    76a0:	90 93 f1 06 	sts	0x06F1, r25
    76a4:	a0 93 f2 06 	sts	0x06F2, r26
    76a8:	b0 93 f3 06 	sts	0x06F3, r27
    76ac:	a0 cf       	rjmp	.-192    	; 0x75ee <KeypadIn+0x64>
				PrevKey = Key;
				Key = 0;
				KeyStroke = 0;
		}
		else{
			KeyPressed = KeyResult = Key;
    76ae:	00 93 66 07 	sts	0x0766, r16
			if(KeyStroke<0xFF && ++KeyStroke>1 && KeyStroke<=0xF) KeyResult = 0;
    76b2:	90 91 ea 04 	lds	r25, 0x04EA
    76b6:	9f 3f       	cpi	r25, 0xFF	; 255
    76b8:	41 f0       	breq	.+16     	; 0x76ca <KeypadIn+0x140>
    76ba:	9f 5f       	subi	r25, 0xFF	; 255
    76bc:	90 93 ea 04 	sts	0x04EA, r25
    76c0:	92 30       	cpi	r25, 0x02	; 2
    76c2:	18 f0       	brcs	.+6      	; 0x76ca <KeypadIn+0x140>
    76c4:	90 31       	cpi	r25, 0x10	; 16
    76c6:	08 f4       	brcc	.+2      	; 0x76ca <KeypadIn+0x140>
    76c8:	b2 cf       	rjmp	.-156    	; 0x762e <KeypadIn+0xa4>

		#ifdef RKEY
			#ifdef QslRD
				if(!*(uint8_t*)RNUM)
			#endif
				if (KeyResult==0) {
    76ca:	88 23       	and	r24, r24
    76cc:	09 f0       	breq	.+2      	; 0x76d0 <KeypadIn+0x146>
    76ce:	9c cf       	rjmp	.-200    	; 0x7608 <KeypadIn+0x7e>
    76d0:	ae cf       	rjmp	.-164    	; 0x762e <KeypadIn+0xa4>
					uint8_t I = 0;
					while (1<<(I++ & 0b00000111) != *((uint8_t*)RKEY+(I>>3)) && I<=KeyQuantity);
					if (I<=KeyQuantity)
    76d2:	67 30       	cpi	r22, 0x07	; 7
    76d4:	68 f6       	brcc	.-102    	; 0x7670 <KeypadIn+0xe6>
    76d6:	86 2f       	mov	r24, r22
    76d8:	cc cf       	rjmp	.-104    	; 0x7672 <KeypadIn+0xe8>

000076da <InitBufStr>:
static uint8_t Minus;
// ~~~~~~~~~~~
char BufStr[LCDXSz+1];
uint8_t CurrFieldSize;

void InitBufStr(OutField *Field){
    76da:	eb eb       	ldi	r30, 0xBB	; 187
    76dc:	f5 e0       	ldi	r31, 0x05	; 5
	for(uint8_t i =0; i<LCDXSz; i++) BufStr[i]=' ';
    76de:	80 e2       	ldi	r24, 0x20	; 32
    76e0:	81 93       	st	Z+, r24
    76e2:	95 e0       	ldi	r25, 0x05	; 5
    76e4:	ef 3c       	cpi	r30, 0xCF	; 207
    76e6:	f9 07       	cpc	r31, r25
    76e8:	d9 f7       	brne	.-10     	; 0x76e0 <InitBufStr+0x6>
	BufStr[LCDXSz] ='\0';
    76ea:	10 82       	st	Z, r1
	CurrFieldSize = 0;
    76ec:	10 92 74 07 	sts	0x0774, r1
	MultiSymbol = 0;
    76f0:	10 92 ec 04 	sts	0x04EC, r1
}
    76f4:	08 95       	ret

000076f6 <EventFunc>:

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    76f6:	fc 01       	movw	r30, r24
    76f8:	85 91       	lpm	r24, Z+
    76fa:	94 91       	lpm	r25, Z+
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
EventFunc(const MenuEvent *Event)
{
	MenuEvent Func = prp(Event);
	if (Func)
    76fc:	00 97       	sbiw	r24, 0x00	; 0
    76fe:	11 f0       	breq	.+4      	; 0x7704 <EventFunc+0xe>
		Func();
    7700:	fc 01       	movw	r30, r24
    7702:	19 95       	eicall
    7704:	08 95       	ret

00007706 <KeyFunc>:
    7706:	fc 01       	movw	r30, r24
    7708:	85 91       	lpm	r24, Z+
    770a:	94 91       	lpm	r25, Z+
// ~~~~~~~~~~~~~~~~~~~~~~~~
static uint8_t
KeyFunc(const MenuKey *Key)
{
	MenuKey Func=prp(Key);
	return Func && Func()==CustomKey;
    770c:	00 97       	sbiw	r24, 0x00	; 0
    770e:	51 f0       	breq	.+20     	; 0x7724 <KeyFunc+0x1e>
    7710:	fc 01       	movw	r30, r24
    7712:	19 95       	eicall
    7714:	90 e0       	ldi	r25, 0x00	; 0
    7716:	81 30       	cpi	r24, 0x01	; 1
    7718:	09 f0       	breq	.+2      	; 0x771c <KeyFunc+0x16>
    771a:	91 e0       	ldi	r25, 0x01	; 1
    771c:	81 e0       	ldi	r24, 0x01	; 1
    771e:	98 27       	eor	r25, r24
}
    7720:	89 2f       	mov	r24, r25
    7722:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~~~
static uint8_t
KeyFunc(const MenuKey *Key)
{
	MenuKey Func=prp(Key);
	return Func && Func()==CustomKey;
    7724:	90 e0       	ldi	r25, 0x00	; 0
}
    7726:	89 2f       	mov	r24, r25
    7728:	08 95       	ret

0000772a <GotoMenu>:

// ~~~~~~~~~~~~~~~~~~~~~
void
GotoMenu(MenuPage *Menu)
{
    772a:	cf 93       	push	r28
    772c:	df 93       	push	r29
    772e:	ec 01       	movw	r28, r24
	EventFunc(&CurrPage->Exit);
    7730:	80 91 d1 02 	lds	r24, 0x02D1
    7734:	90 91 d2 02 	lds	r25, 0x02D2
    7738:	0a 96       	adiw	r24, 0x0a	; 10
    773a:	0e 94 7b 3b 	call	0x76f6	; 0x76f6 <EventFunc>
    773e:	fe 01       	movw	r30, r28
    7740:	34 96       	adiw	r30, 0x04	; 4
    7742:	85 91       	lpm	r24, Z+
    7744:	94 91       	lpm	r25, Z+
	if(prp(&Menu->OutPage))
    7746:	89 2b       	or	r24, r25
    7748:	c9 f0       	breq	.+50     	; 0x777c <GotoMenu+0x52>
		MenuDepth=0;
    774a:	10 92 6e 07 	sts	0x076E, r1
	else {
		MenuStack[MenuDepth].Page = CurrPage;
		MenuStack[MenuDepth].Line = CurrLine;
		MenuStack[MenuDepth++].LCD = CurrLCD;
	}
	CurrPage = Menu;
    774e:	d0 93 d2 02 	sts	0x02D2, r29
    7752:	c0 93 d1 02 	sts	0x02D1, r28

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    7756:	23 96       	adiw	r28, 0x03	; 3
    7758:	fe 01       	movw	r30, r28
    775a:	84 91       	lpm	r24, Z+
	CurrLine = CurrLCD = GetFix();
    775c:	80 93 9a 08 	sts	0x089A, r24
    7760:	80 93 7d 07 	sts	0x077D, r24
	CurrField = CurrPos = NullPos;
    7764:	8f ef       	ldi	r24, 0xFF	; 255
    7766:	80 93 d4 02 	sts	0x02D4, r24
    776a:	80 93 d3 02 	sts	0x02D3, r24
	EventFunc(&CurrPage->Load);
    776e:	ce 01       	movw	r24, r28
    7770:	03 96       	adiw	r24, 0x03	; 3
    7772:	0e 94 7b 3b 	call	0x76f6	; 0x76f6 <EventFunc>
}
    7776:	df 91       	pop	r29
    7778:	cf 91       	pop	r28
    777a:	08 95       	ret
{
	EventFunc(&CurrPage->Exit);
	if(prp(&Menu->OutPage))
		MenuDepth=0;
	else {
		MenuStack[MenuDepth].Page = CurrPage;
    777c:	20 91 6e 07 	lds	r18, 0x076E
    7780:	e2 2f       	mov	r30, r18
    7782:	f0 e0       	ldi	r31, 0x00	; 0
    7784:	ee 0f       	add	r30, r30
    7786:	ff 1f       	adc	r31, r31
    7788:	ee 0f       	add	r30, r30
    778a:	ff 1f       	adc	r31, r31
    778c:	df 01       	movw	r26, r30
    778e:	a5 56       	subi	r26, 0x65	; 101
    7790:	b7 4f       	sbci	r27, 0xF7	; 247
    7792:	80 91 d1 02 	lds	r24, 0x02D1
    7796:	90 91 d2 02 	lds	r25, 0x02D2
    779a:	11 96       	adiw	r26, 0x01	; 1
    779c:	9c 93       	st	X, r25
    779e:	8e 93       	st	-X, r24
		MenuStack[MenuDepth].Line = CurrLine;
    77a0:	80 91 7d 07 	lds	r24, 0x077D
    77a4:	13 96       	adiw	r26, 0x03	; 3
    77a6:	8c 93       	st	X, r24
		MenuStack[MenuDepth++].LCD = CurrLCD;
    77a8:	e3 56       	subi	r30, 0x63	; 99
    77aa:	f7 4f       	sbci	r31, 0xF7	; 247
    77ac:	80 91 9a 08 	lds	r24, 0x089A
    77b0:	80 83       	st	Z, r24
    77b2:	2f 5f       	subi	r18, 0xFF	; 255
    77b4:	20 93 6e 07 	sts	0x076E, r18
    77b8:	ca cf       	rjmp	.-108    	; 0x774e <GotoMenu+0x24>

000077ba <HideMsg>:

// ~~~~~~~~~~
uint8_t
HideMsg(void)
{
	if (CurrMsg) {
    77ba:	80 91 ed 04 	lds	r24, 0x04ED
    77be:	90 91 ee 04 	lds	r25, 0x04EE
    77c2:	00 97       	sbiw	r24, 0x00	; 0
    77c4:	51 f0       	breq	.+20     	; 0x77da <HideMsg+0x20>
		EventFunc(&CurrMsg->Exit);
    77c6:	80 5a       	subi	r24, 0xA0	; 160
    77c8:	9f 4f       	sbci	r25, 0xFF	; 255
    77ca:	0e 94 7b 3b 	call	0x76f6	; 0x76f6 <EventFunc>
		CurrMsg = NULL;
    77ce:	10 92 ee 04 	sts	0x04EE, r1
    77d2:	10 92 ed 04 	sts	0x04ED, r1
    77d6:	81 e0       	ldi	r24, 0x01	; 1
		return 1;
	}
	else
		return 0;
}
    77d8:	08 95       	ret

// ~~~~~~~~~~
uint8_t
HideMsg(void)
{
	if (CurrMsg) {
    77da:	80 e0       	ldi	r24, 0x00	; 0
    77dc:	08 95       	ret

000077de <ShowMsg>:
}

// ~~~~~~~~~~~~~~~~~~
void
ShowMsg(MsgPage *Msg)
{
    77de:	0f 93       	push	r16
    77e0:	1f 93       	push	r17
    77e2:	8c 01       	movw	r16, r24
	HideMsg();
    77e4:	0e 94 dd 3b 	call	0x77ba	; 0x77ba <HideMsg>
	CurrMsg = Msg;
    77e8:	10 93 ee 04 	sts	0x04EE, r17
    77ec:	00 93 ed 04 	sts	0x04ED, r16
	EventFunc(&CurrMsg->Load);
    77f0:	c8 01       	movw	r24, r16
    77f2:	84 5a       	subi	r24, 0xA4	; 164
    77f4:	9f 4f       	sbci	r25, 0xFF	; 255
    77f6:	0e 94 7b 3b 	call	0x76f6	; 0x76f6 <EventFunc>
}
    77fa:	1f 91       	pop	r17
    77fc:	0f 91       	pop	r16
    77fe:	08 95       	ret

00007800 <MenuInit>:

// ~~~~~~~~~~~
void
MenuInit(void)
{
	CurrLCD = CurrLine = GetFix();
    7800:	e0 91 d1 02 	lds	r30, 0x02D1
    7804:	f0 91 d2 02 	lds	r31, 0x02D2
    7808:	33 96       	adiw	r30, 0x03	; 3
    780a:	84 91       	lpm	r24, Z+
    780c:	80 93 7d 07 	sts	0x077D, r24
    7810:	80 93 9a 08 	sts	0x089A, r24
	#ifdef InitMsg
		ShowMsg(&InitMsg);
	#endif
	EventFunc(&CurrPage->Load);
    7814:	cf 01       	movw	r24, r30
    7816:	03 96       	adiw	r24, 0x03	; 3
    7818:	0e 94 7b 3b 	call	0x76f6	; 0x76f6 <EventFunc>
}
    781c:	08 95       	ret

0000781e <PosBlink>:
}

// ~~~~~~~~~~~~~~~~~~~~~
static void
PosBlink(T_Param *Param, char Cursor)
{
    781e:	fc 01       	movw	r30, r24
	CurrX=Param->Pos+Param->Size-CurrPos-(Param->Prec&&CurrPos>=Param->Prec?2:1)-LCD_Buf[Y1];
    7820:	20 81       	ld	r18, Z
    7822:	33 81       	ldd	r19, Z+3	; 0x03
    7824:	90 91 d4 02 	lds	r25, 0x02D4
    7828:	82 81       	ldd	r24, Z+2	; 0x02
    782a:	88 23       	and	r24, r24
    782c:	11 f0       	breq	.+4      	; 0x7832 <PosBlink+0x14>
    782e:	98 17       	cp	r25, r24
    7830:	a0 f4       	brcc	.+40     	; 0x785a <PosBlink+0x3c>
    7832:	4f ef       	ldi	r20, 0xFF	; 255
    7834:	39 1b       	sub	r19, r25
    7836:	32 0f       	add	r19, r18
    7838:	80 e5       	ldi	r24, 0x50	; 80
    783a:	96 e0       	ldi	r25, 0x06	; 6
    783c:	38 1b       	sub	r19, r24
    783e:	80 91 f7 09 	lds	r24, 0x09F7
    7842:	25 e1       	ldi	r18, 0x15	; 21
    7844:	82 9f       	mul	r24, r18
    7846:	c0 01       	movw	r24, r0
    7848:	11 24       	eor	r1, r1
    784a:	38 1b       	sub	r19, r24
    784c:	34 0f       	add	r19, r20
    784e:	30 93 b1 06 	sts	0x06B1, r19
	StrSize=1;
    7852:	81 e0       	ldi	r24, 0x01	; 1
    7854:	80 93 a4 06 	sts	0x06A4, r24
}
    7858:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~~~
static void
PosBlink(T_Param *Param, char Cursor)
{
	CurrX=Param->Pos+Param->Size-CurrPos-(Param->Prec&&CurrPos>=Param->Prec?2:1)-LCD_Buf[Y1];
    785a:	4e ef       	ldi	r20, 0xFE	; 254
    785c:	eb cf       	rjmp	.-42     	; 0x7834 <PosBlink+0x16>

0000785e <GetCurrFieldSize>:

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    785e:	e0 91 d1 02 	lds	r30, 0x02D1
    7862:	f0 91 d2 02 	lds	r31, 0x02D2
    7866:	45 91       	lpm	r20, Z+
    7868:	54 91       	lpm	r21, Z+
}
// ~~~~~~~~~~~~~~~~~~~~~~~
// Return size of CurrField. Use to determine size of Text, EE_Text OutField vars
uint8_t GetCurrFieldSize(void){
	uint8_t Size;
	MenuLine *Line=GetLine+CurrLine;
    786a:	80 91 7d 07 	lds	r24, 0x077D
    786e:	2b e1       	ldi	r18, 0x1B	; 27
    7870:	82 9f       	mul	r24, r18
    7872:	c0 01       	movw	r24, r0
    7874:	11 24       	eor	r1, r1
    7876:	48 0f       	add	r20, r24
    7878:	59 1f       	adc	r21, r25
		while(prc(CurrStr+X)=='}'){
			X++;
			Size++;
		}
		if(Size){
			if(OF_N == CurrField) return Size;
    787a:	30 91 d3 02 	lds	r19, 0x02D3
    787e:	90 e0       	ldi	r25, 0x00	; 0
    7880:	20 e0       	ldi	r18, 0x00	; 0

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    7882:	fa 01       	movw	r30, r20
    7884:	e9 0f       	add	r30, r25
    7886:	f1 1d       	adc	r31, r1
    7888:	e4 91       	lpm	r30, Z+
	MenuLine *Line=GetLine+CurrLine;
	PGM_P CurrStr=(PGM_P)(Line->Str);
	uint8_t OF_N = 0;
	for(uint8_t X=0; X<LCDXSz; X++){
		Size = 0;
		while(prc(CurrStr+X)=='}'){
    788a:	ed 37       	cpi	r30, 0x7D	; 125
    788c:	71 f4       	brne	.+28     	; 0x78aa <GetCurrFieldSize+0x4c>
			X++;
			Size++;
		}
		if(Size){
			if(OF_N == CurrField) return Size;
    788e:	80 e0       	ldi	r24, 0x00	; 0
	PGM_P CurrStr=(PGM_P)(Line->Str);
	uint8_t OF_N = 0;
	for(uint8_t X=0; X<LCDXSz; X++){
		Size = 0;
		while(prc(CurrStr+X)=='}'){
			X++;
    7890:	9f 5f       	subi	r25, 0xFF	; 255
			Size++;
    7892:	8f 5f       	subi	r24, 0xFF	; 255
    7894:	fa 01       	movw	r30, r20
    7896:	e9 0f       	add	r30, r25
    7898:	f1 1d       	adc	r31, r1
    789a:	e4 91       	lpm	r30, Z+
	MenuLine *Line=GetLine+CurrLine;
	PGM_P CurrStr=(PGM_P)(Line->Str);
	uint8_t OF_N = 0;
	for(uint8_t X=0; X<LCDXSz; X++){
		Size = 0;
		while(prc(CurrStr+X)=='}'){
    789c:	ed 37       	cpi	r30, 0x7D	; 125
    789e:	c1 f3       	breq	.-16     	; 0x7890 <GetCurrFieldSize+0x32>
			X++;
			Size++;
		}
		if(Size){
    78a0:	88 23       	and	r24, r24
    78a2:	19 f0       	breq	.+6      	; 0x78aa <GetCurrFieldSize+0x4c>
			if(OF_N == CurrField) return Size;
    78a4:	23 17       	cp	r18, r19
    78a6:	29 f0       	breq	.+10     	; 0x78b2 <GetCurrFieldSize+0x54>
			OF_N++;
    78a8:	2f 5f       	subi	r18, 0xFF	; 255
uint8_t GetCurrFieldSize(void){
	uint8_t Size;
	MenuLine *Line=GetLine+CurrLine;
	PGM_P CurrStr=(PGM_P)(Line->Str);
	uint8_t OF_N = 0;
	for(uint8_t X=0; X<LCDXSz; X++){
    78aa:	9f 5f       	subi	r25, 0xFF	; 255
    78ac:	94 31       	cpi	r25, 0x14	; 20
    78ae:	48 f3       	brcs	.-46     	; 0x7882 <GetCurrFieldSize+0x24>
		Size = 0;
		while(prc(CurrStr+X)=='}'){
    78b0:	80 e0       	ldi	r24, 0x00	; 0
			if(OF_N == CurrField) return Size;
			OF_N++;
		}
	}
	return 0;
}
    78b2:	08 95       	ret

000078b4 <Inc>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
static int32_t
Inc(int8_t Dir, uint32_t Buf)
{
    78b4:	5f 92       	push	r5
    78b6:	6f 92       	push	r6
    78b8:	7f 92       	push	r7
    78ba:	8f 92       	push	r8
    78bc:	9f 92       	push	r9
    78be:	af 92       	push	r10
    78c0:	bf 92       	push	r11
    78c2:	cf 92       	push	r12
    78c4:	df 92       	push	r13
    78c6:	ef 92       	push	r14
    78c8:	ff 92       	push	r15
    78ca:	0f 93       	push	r16
    78cc:	1f 93       	push	r17
    78ce:	cf 93       	push	r28
    78d0:	df 93       	push	r29
    78d2:	58 2e       	mov	r5, r24
    78d4:	3a 01       	movw	r6, r20
    78d6:	4b 01       	movw	r8, r22
	uint32_t Pos = PowL10(CurrPos);
    78d8:	d0 90 d4 02 	lds	r13, 0x02D4
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
	uint32_t Pow = 1;
	while(Exp--)
    78dc:	dd 20       	and	r13, r13
    78de:	09 f4       	brne	.+2      	; 0x78e2 <Inc+0x2e>
    78e0:	5f c0       	rjmp	.+190    	; 0x79a0 <Inc+0xec>
    78e2:	61 e0       	ldi	r22, 0x01	; 1
    78e4:	e6 2e       	mov	r14, r22
    78e6:	f1 2c       	mov	r15, r1
    78e8:	01 2d       	mov	r16, r1
    78ea:	11 2d       	mov	r17, r1
		Pow *= 10;
    78ec:	c8 01       	movw	r24, r16
    78ee:	b7 01       	movw	r22, r14
    78f0:	2a e0       	ldi	r18, 0x0A	; 10
    78f2:	30 e0       	ldi	r19, 0x00	; 0
    78f4:	40 e0       	ldi	r20, 0x00	; 0
    78f6:	50 e0       	ldi	r21, 0x00	; 0
    78f8:	0e 94 e0 7d 	call	0xfbc0	; 0xfbc0 <__mulsi3>
    78fc:	7b 01       	movw	r14, r22
    78fe:	8c 01       	movw	r16, r24
    7900:	da 94       	dec	r13
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
	uint32_t Pow = 1;
	while(Exp--)
    7902:	a1 f7       	brne	.-24     	; 0x78ec <Inc+0x38>
    7904:	5b 01       	movw	r10, r22
    7906:	6c 01       	movw	r12, r24
	uint8_t Dig=Buf%(Pos*10)/Pos;
	if(Dig==(Dir==1?9:0)) {
    7908:	81 e0       	ldi	r24, 0x01	; 1
    790a:	58 16       	cp	r5, r24
    790c:	09 f4       	brne	.+2      	; 0x7910 <Inc+0x5c>
    790e:	45 c0       	rjmp	.+138    	; 0x799a <Inc+0xe6>
    7910:	c0 e0       	ldi	r28, 0x00	; 0
    7912:	d0 e0       	ldi	r29, 0x00	; 0
    7914:	c8 01       	movw	r24, r16
    7916:	b7 01       	movw	r22, r14
    7918:	2a e0       	ldi	r18, 0x0A	; 10
    791a:	30 e0       	ldi	r19, 0x00	; 0
    791c:	40 e0       	ldi	r20, 0x00	; 0
    791e:	50 e0       	ldi	r21, 0x00	; 0
    7920:	0e 94 e0 7d 	call	0xfbc0	; 0xfbc0 <__mulsi3>
    7924:	9b 01       	movw	r18, r22
    7926:	ac 01       	movw	r20, r24
    7928:	c4 01       	movw	r24, r8
    792a:	b3 01       	movw	r22, r6
    792c:	0e 94 32 7e 	call	0xfc64	; 0xfc64 <__udivmodsi4>
    7930:	a8 01       	movw	r20, r16
    7932:	97 01       	movw	r18, r14
    7934:	0e 94 32 7e 	call	0xfc64	; 0xfc64 <__udivmodsi4>
    7938:	30 e0       	ldi	r19, 0x00	; 0
    793a:	2c 17       	cp	r18, r28
    793c:	3d 07       	cpc	r19, r29
    793e:	99 f4       	brne	.+38     	; 0x7966 <Inc+0xb2>
			Dir = -Dir;
    7940:	51 94       	neg	r5
			Pos *= 9;
    7942:	57 01       	movw	r10, r14
    7944:	68 01       	movw	r12, r16
    7946:	aa 0c       	add	r10, r10
    7948:	bb 1c       	adc	r11, r11
    794a:	cc 1c       	adc	r12, r12
    794c:	dd 1c       	adc	r13, r13
    794e:	aa 0c       	add	r10, r10
    7950:	bb 1c       	adc	r11, r11
    7952:	cc 1c       	adc	r12, r12
    7954:	dd 1c       	adc	r13, r13
    7956:	aa 0c       	add	r10, r10
    7958:	bb 1c       	adc	r11, r11
    795a:	cc 1c       	adc	r12, r12
    795c:	dd 1c       	adc	r13, r13
    795e:	ae 0c       	add	r10, r14
    7960:	bf 1c       	adc	r11, r15
    7962:	c0 1e       	adc	r12, r16
    7964:	d1 1e       	adc	r13, r17
    7966:	65 2d       	mov	r22, r5
    7968:	77 27       	eor	r23, r23
    796a:	67 fd       	sbrc	r22, 7
    796c:	70 95       	com	r23
    796e:	87 2f       	mov	r24, r23
    7970:	97 2f       	mov	r25, r23
    7972:	a6 01       	movw	r20, r12
    7974:	95 01       	movw	r18, r10
    7976:	0e 94 e0 7d 	call	0xfbc0	; 0xfbc0 <__mulsi3>
	}
	return Pos*Dir;
}
    797a:	df 91       	pop	r29
    797c:	cf 91       	pop	r28
    797e:	1f 91       	pop	r17
    7980:	0f 91       	pop	r16
    7982:	ff 90       	pop	r15
    7984:	ef 90       	pop	r14
    7986:	df 90       	pop	r13
    7988:	cf 90       	pop	r12
    798a:	bf 90       	pop	r11
    798c:	af 90       	pop	r10
    798e:	9f 90       	pop	r9
    7990:	8f 90       	pop	r8
    7992:	7f 90       	pop	r7
    7994:	6f 90       	pop	r6
    7996:	5f 90       	pop	r5
    7998:	08 95       	ret
static int32_t
Inc(int8_t Dir, uint32_t Buf)
{
	uint32_t Pos = PowL10(CurrPos);
	uint8_t Dig=Buf%(Pos*10)/Pos;
	if(Dig==(Dir==1?9:0)) {
    799a:	c9 e0       	ldi	r28, 0x09	; 9
    799c:	d0 e0       	ldi	r29, 0x00	; 0
    799e:	ba cf       	rjmp	.-140    	; 0x7914 <Inc+0x60>
    79a0:	e1 e0       	ldi	r30, 0x01	; 1
    79a2:	ee 2e       	mov	r14, r30
    79a4:	f1 2c       	mov	r15, r1
    79a6:	01 2d       	mov	r16, r1
    79a8:	11 2d       	mov	r17, r1
    79aa:	71 e0       	ldi	r23, 0x01	; 1
    79ac:	a7 2e       	mov	r10, r23
    79ae:	b1 2c       	mov	r11, r1
    79b0:	c1 2c       	mov	r12, r1
    79b2:	d1 2c       	mov	r13, r1
    79b4:	a9 cf       	rjmp	.-174    	; 0x7908 <Inc+0x54>

000079b6 <MenuRight>:

// ~~~~~~~~~~~~
void
MenuRight(void)
{
}
    79b6:	08 95       	ret

000079b8 <MenuLeft>:

// ~~~~~~~~~~~~~
void
MenuLeft(void)
{
}
    79b8:	08 95       	ret

000079ba <MenuEnter>:

// ~~~~~~~~~~~~
void
MenuEnter(void)
{
}
    79ba:	08 95       	ret

000079bc <MenuEsc>:

// ~~~~~~~~~~
void
MenuEsc(void)
{
}
    79bc:	08 95       	ret

000079be <DI_State>:
} DigInput;

// ~~~~~~~~~~~~~~~~~~
uint8_t
DI_State(uint8_t D_N)
{
    79be:	28 2f       	mov	r18, r24
    79c0:	86 95       	lsr	r24
    79c2:	86 95       	lsr	r24
    79c4:	86 95       	lsr	r24
    79c6:	e6 ef       	ldi	r30, 0xF6	; 246
    79c8:	f6 e0       	ldi	r31, 0x06	; 6
    79ca:	e8 0f       	add	r30, r24
    79cc:	f1 1d       	adc	r31, r1
    79ce:	80 81       	ld	r24, Z
    79d0:	90 e0       	ldi	r25, 0x00	; 0
    79d2:	27 70       	andi	r18, 0x07	; 7
    79d4:	02 c0       	rjmp	.+4      	; 0x79da <DI_State+0x1c>
    79d6:	95 95       	asr	r25
    79d8:	87 95       	ror	r24
    79da:	2a 95       	dec	r18
    79dc:	e2 f7       	brpl	.-8      	; 0x79d6 <DI_State+0x18>
	return (DigInput.State[D_N/8] &(1<<D_N%8)) != 0;
}
    79de:	81 70       	andi	r24, 0x01	; 1
    79e0:	08 95       	ret

000079e2 <DI_Front>:

// ~~~~~~~~~~~~~~~~~~
uint8_t
DI_Front(uint8_t D_N)
{
    79e2:	e8 2f       	mov	r30, r24
	uint8_t Byte=D_N/8, Bit=1<<D_N%8;
    79e4:	28 2f       	mov	r18, r24
    79e6:	27 70       	andi	r18, 0x07	; 7
    79e8:	81 e0       	ldi	r24, 0x01	; 1
    79ea:	90 e0       	ldi	r25, 0x00	; 0
    79ec:	01 c0       	rjmp	.+2      	; 0x79f0 <DI_Front+0xe>
    79ee:	88 0f       	add	r24, r24
    79f0:	2a 95       	dec	r18
    79f2:	ea f7       	brpl	.-6      	; 0x79ee <DI_Front+0xc>
	uint8_t State = DigInput.State[Byte] &Bit;
    79f4:	e6 95       	lsr	r30
    79f6:	e6 95       	lsr	r30
    79f8:	e6 95       	lsr	r30
    79fa:	f0 e0       	ldi	r31, 0x00	; 0
    79fc:	ea 50       	subi	r30, 0x0A	; 10
    79fe:	f9 4f       	sbci	r31, 0xF9	; 249
    7a00:	90 81       	ld	r25, Z
    7a02:	98 23       	and	r25, r24
	return DigInput.StateOld[Byte] &Bit ? State?NoFront:FallFront : State?RiseFront:NoFront;
    7a04:	23 81       	ldd	r18, Z+3	; 0x03
    7a06:	82 23       	and	r24, r18
    7a08:	21 f0       	breq	.+8      	; 0x7a12 <DI_Front+0x30>
    7a0a:	99 23       	and	r25, r25
    7a0c:	41 f4       	brne	.+16     	; 0x7a1e <DI_Front+0x3c>
    7a0e:	82 e0       	ldi	r24, 0x02	; 2
    7a10:	08 95       	ret
    7a12:	89 2f       	mov	r24, r25
    7a14:	99 23       	and	r25, r25
    7a16:	09 f4       	brne	.+2      	; 0x7a1a <DI_Front+0x38>
}
    7a18:	08 95       	ret
uint8_t
DI_Front(uint8_t D_N)
{
	uint8_t Byte=D_N/8, Bit=1<<D_N%8;
	uint8_t State = DigInput.State[Byte] &Bit;
	return DigInput.StateOld[Byte] &Bit ? State?NoFront:FallFront : State?RiseFront:NoFront;
    7a1a:	81 e0       	ldi	r24, 0x01	; 1
}
    7a1c:	08 95       	ret
uint8_t
DI_Front(uint8_t D_N)
{
	uint8_t Byte=D_N/8, Bit=1<<D_N%8;
	uint8_t State = DigInput.State[Byte] &Bit;
	return DigInput.StateOld[Byte] &Bit ? State?NoFront:FallFront : State?RiseFront:NoFront;
    7a1e:	80 e0       	ldi	r24, 0x00	; 0
    7a20:	08 95       	ret

00007a22 <DI_Status>:
}

// ~~~~~~~~~~~~~~~~~~~
uint8_t
DI_Status(uint8_t D_N)
{
    7a22:	28 2f       	mov	r18, r24
    7a24:	86 95       	lsr	r24
    7a26:	86 95       	lsr	r24
    7a28:	86 95       	lsr	r24
    7a2a:	e6 ef       	ldi	r30, 0xF6	; 246
    7a2c:	f6 e0       	ldi	r31, 0x06	; 6
    7a2e:	e8 0f       	add	r30, r24
    7a30:	f1 1d       	adc	r31, r1
    7a32:	86 81       	ldd	r24, Z+6	; 0x06
    7a34:	90 e0       	ldi	r25, 0x00	; 0
    7a36:	27 70       	andi	r18, 0x07	; 7
    7a38:	02 c0       	rjmp	.+4      	; 0x7a3e <DI_Status+0x1c>
    7a3a:	95 95       	asr	r25
    7a3c:	87 95       	ror	r24
    7a3e:	2a 95       	dec	r18
    7a40:	e2 f7       	brpl	.-8      	; 0x7a3a <DI_Status+0x18>
	return (DigInput.Status[D_N/8] &(1<<D_N%8)) != 0;
}
    7a42:	81 70       	andi	r24, 0x01	; 1
    7a44:	08 95       	ret

00007a46 <DI_Init>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

// ~~~~~~~~~~
void
DI_Init(void)
{
    7a46:	20 e0       	ldi	r18, 0x00	; 0
    7a48:	30 e0       	ldi	r19, 0x00	; 0
// ~~~~~~~~~~~~~~~
static void
DI_Init_Hard(void)
{
	for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
		cli();
    7a4a:	f8 94       	cli

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    7a4c:	a9 01       	movw	r20, r18
    7a4e:	44 0f       	add	r20, r20
    7a50:	55 1f       	adc	r21, r21
    7a52:	44 0f       	add	r20, r20
    7a54:	55 1f       	adc	r21, r21
    7a56:	44 0f       	add	r20, r20
    7a58:	55 1f       	adc	r21, r21
    7a5a:	ca 01       	movw	r24, r20
    7a5c:	8a 5c       	subi	r24, 0xCA	; 202
    7a5e:	94 4d       	sbci	r25, 0xD4	; 212
    7a60:	fc 01       	movw	r30, r24
    7a62:	a5 91       	lpm	r26, Z+
    7a64:	b4 91       	lpm	r27, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    7a66:	44 5c       	subi	r20, 0xC4	; 196
    7a68:	54 4d       	sbci	r21, 0xD4	; 212
    7a6a:	fa 01       	movw	r30, r20
    7a6c:	44 91       	lpm	r20, Z+
		*(uint8_t*)prp(&DI_M[D_N].DDR) &=~prb(&DI_M[D_N].P);
    7a6e:	94 2f       	mov	r25, r20
    7a70:	90 95       	com	r25
    7a72:	8c 91       	ld	r24, X
    7a74:	89 23       	and	r24, r25
    7a76:	8c 93       	st	X, r24

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    7a78:	c9 01       	movw	r24, r18
    7a7a:	88 0f       	add	r24, r24
    7a7c:	99 1f       	adc	r25, r25
    7a7e:	88 0f       	add	r24, r24
    7a80:	99 1f       	adc	r25, r25
    7a82:	88 0f       	add	r24, r24
    7a84:	99 1f       	adc	r25, r25
    7a86:	88 5c       	subi	r24, 0xC8	; 200
    7a88:	94 4d       	sbci	r25, 0xD4	; 212
    7a8a:	fc 01       	movw	r30, r24
    7a8c:	a5 91       	lpm	r26, Z+
    7a8e:	b4 91       	lpm	r27, Z+
		*(uint8_t*)prp(&DI_M[D_N].PORT) |=prb(&DI_M[D_N].P);
    7a90:	8c 91       	ld	r24, X
    7a92:	84 2b       	or	r24, r20
    7a94:	8c 93       	st	X, r24
		sei();
    7a96:	78 94       	sei
    7a98:	2f 5f       	subi	r18, 0xFF	; 255
    7a9a:	3f 4f       	sbci	r19, 0xFF	; 255

// ~~~~~~~~~~~~~~~
static void
DI_Init_Hard(void)
{
	for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
    7a9c:	22 31       	cpi	r18, 0x12	; 18
    7a9e:	31 05       	cpc	r19, r1
    7aa0:	a1 f6       	brne	.-88     	; 0x7a4a <DI_Init+0x4>
{
	DI_Init_Hard();
	#ifdef HSC_Reg
		HSC_Init();
	#endif
}
    7aa2:	08 95       	ret

00007aa4 <DO_State>:
} DigOutput;

// ~~~~~~~~~~~~~~~~~~
uint8_t
DO_State(uint8_t D_N)
{
    7aa4:	90 e0       	ldi	r25, 0x00	; 0
    7aa6:	e8 2f       	mov	r30, r24
    7aa8:	e6 95       	lsr	r30
    7aaa:	e6 95       	lsr	r30
    7aac:	e6 95       	lsr	r30
    7aae:	f0 e0       	ldi	r31, 0x00	; 0
    7ab0:	e3 57       	subi	r30, 0x73	; 115
    7ab2:	f8 4f       	sbci	r31, 0xF8	; 248
    7ab4:	40 81       	ld	r20, Z
    7ab6:	50 e0       	ldi	r21, 0x00	; 0
    7ab8:	87 70       	andi	r24, 0x07	; 7
    7aba:	21 e0       	ldi	r18, 0x01	; 1
    7abc:	30 e0       	ldi	r19, 0x00	; 0
    7abe:	02 c0       	rjmp	.+4      	; 0x7ac4 <DO_State+0x20>
    7ac0:	22 0f       	add	r18, r18
    7ac2:	33 1f       	adc	r19, r19
    7ac4:	8a 95       	dec	r24
    7ac6:	e2 f7       	brpl	.-8      	; 0x7ac0 <DO_State+0x1c>
    7ac8:	42 23       	and	r20, r18
    7aca:	53 23       	and	r21, r19
    7acc:	14 16       	cp	r1, r20
    7ace:	15 06       	cpc	r1, r21
    7ad0:	0c f4       	brge	.+2      	; 0x7ad4 <DO_State+0x30>
    7ad2:	91 e0       	ldi	r25, 0x01	; 1
	return (DigOutput.State[D_N/8] &(1<<D_N%8)) > 0;
}
    7ad4:	89 2f       	mov	r24, r25
    7ad6:	08 95       	ret

00007ad8 <DO_Front>:

// ~~~~~~~~~~~~~~~~~~
uint8_t
DO_Front(uint8_t D_N)
{
    7ad8:	e8 2f       	mov	r30, r24
	uint8_t Byte=D_N/8, Bit=1<<D_N%8;
    7ada:	28 2f       	mov	r18, r24
    7adc:	27 70       	andi	r18, 0x07	; 7
    7ade:	81 e0       	ldi	r24, 0x01	; 1
    7ae0:	90 e0       	ldi	r25, 0x00	; 0
    7ae2:	01 c0       	rjmp	.+2      	; 0x7ae6 <DO_Front+0xe>
    7ae4:	88 0f       	add	r24, r24
    7ae6:	2a 95       	dec	r18
    7ae8:	ea f7       	brpl	.-6      	; 0x7ae4 <DO_Front+0xc>
	uint8_t State = DigOutput.State[Byte] &Bit;
    7aea:	e6 95       	lsr	r30
    7aec:	e6 95       	lsr	r30
    7aee:	e6 95       	lsr	r30
    7af0:	f0 e0       	ldi	r31, 0x00	; 0
    7af2:	e3 57       	subi	r30, 0x73	; 115
    7af4:	f8 4f       	sbci	r31, 0xF8	; 248
    7af6:	90 81       	ld	r25, Z
    7af8:	98 23       	and	r25, r24
	return DigOutput.StateOld[Byte] &Bit ? State?NoFront:FallFront : State?RiseFront:NoFront;
    7afa:	22 81       	ldd	r18, Z+2	; 0x02
    7afc:	82 23       	and	r24, r18
    7afe:	21 f0       	breq	.+8      	; 0x7b08 <DO_Front+0x30>
    7b00:	99 23       	and	r25, r25
    7b02:	41 f4       	brne	.+16     	; 0x7b14 <DO_Front+0x3c>
    7b04:	82 e0       	ldi	r24, 0x02	; 2
    7b06:	08 95       	ret
    7b08:	89 2f       	mov	r24, r25
    7b0a:	99 23       	and	r25, r25
    7b0c:	09 f4       	brne	.+2      	; 0x7b10 <DO_Front+0x38>
}
    7b0e:	08 95       	ret
uint8_t
DO_Front(uint8_t D_N)
{
	uint8_t Byte=D_N/8, Bit=1<<D_N%8;
	uint8_t State = DigOutput.State[Byte] &Bit;
	return DigOutput.StateOld[Byte] &Bit ? State?NoFront:FallFront : State?RiseFront:NoFront;
    7b10:	81 e0       	ldi	r24, 0x01	; 1
}
    7b12:	08 95       	ret
uint8_t
DO_Front(uint8_t D_N)
{
	uint8_t Byte=D_N/8, Bit=1<<D_N%8;
	uint8_t State = DigOutput.State[Byte] &Bit;
	return DigOutput.StateOld[Byte] &Bit ? State?NoFront:FallFront : State?RiseFront:NoFront;
    7b14:	80 e0       	ldi	r24, 0x00	; 0
    7b16:	08 95       	ret

00007b18 <SetDigOut>:

// ~~~~~~~~~~~~~~~~~~~
void
SetDigOut(uint8_t D_N)
{
	DigOutput.Buf[D_N/8] |=(1<<D_N%8);
    7b18:	98 2f       	mov	r25, r24
    7b1a:	96 95       	lsr	r25
    7b1c:	96 95       	lsr	r25
    7b1e:	96 95       	lsr	r25
    7b20:	ed e8       	ldi	r30, 0x8D	; 141
    7b22:	f7 e0       	ldi	r31, 0x07	; 7
    7b24:	e9 0f       	add	r30, r25
    7b26:	f1 1d       	adc	r31, r1
    7b28:	87 70       	andi	r24, 0x07	; 7
    7b2a:	21 e0       	ldi	r18, 0x01	; 1
    7b2c:	30 e0       	ldi	r19, 0x00	; 0
    7b2e:	02 c0       	rjmp	.+4      	; 0x7b34 <SetDigOut+0x1c>
    7b30:	22 0f       	add	r18, r18
    7b32:	33 1f       	adc	r19, r19
    7b34:	8a 95       	dec	r24
    7b36:	e2 f7       	brpl	.-8      	; 0x7b30 <SetDigOut+0x18>
    7b38:	84 81       	ldd	r24, Z+4	; 0x04
    7b3a:	82 2b       	or	r24, r18
    7b3c:	84 83       	std	Z+4, r24	; 0x04
}
    7b3e:	08 95       	ret

00007b40 <ResDigOut>:

// ~~~~~~~~~~~~~~~~~~~
void
ResDigOut(uint8_t D_N)
{
	DigOutput.Buf[D_N/8] &=~(1<<D_N%8);
    7b40:	98 2f       	mov	r25, r24
    7b42:	96 95       	lsr	r25
    7b44:	96 95       	lsr	r25
    7b46:	96 95       	lsr	r25
    7b48:	ed e8       	ldi	r30, 0x8D	; 141
    7b4a:	f7 e0       	ldi	r31, 0x07	; 7
    7b4c:	e9 0f       	add	r30, r25
    7b4e:	f1 1d       	adc	r31, r1
    7b50:	87 70       	andi	r24, 0x07	; 7
    7b52:	21 e0       	ldi	r18, 0x01	; 1
    7b54:	30 e0       	ldi	r19, 0x00	; 0
    7b56:	02 c0       	rjmp	.+4      	; 0x7b5c <ResDigOut+0x1c>
    7b58:	22 0f       	add	r18, r18
    7b5a:	33 1f       	adc	r19, r19
    7b5c:	8a 95       	dec	r24
    7b5e:	e2 f7       	brpl	.-8      	; 0x7b58 <ResDigOut+0x18>
    7b60:	20 95       	com	r18
    7b62:	84 81       	ldd	r24, Z+4	; 0x04
    7b64:	28 23       	and	r18, r24
    7b66:	24 83       	std	Z+4, r18	; 0x04
}
    7b68:	08 95       	ret

00007b6a <TogDigOut>:

// ~~~~~~~~~~~~~~~~~~~
void
TogDigOut(uint8_t D_N)
{
	DigOutput.Buf[D_N/8] ^=(1<<D_N%8);
    7b6a:	98 2f       	mov	r25, r24
    7b6c:	96 95       	lsr	r25
    7b6e:	96 95       	lsr	r25
    7b70:	96 95       	lsr	r25
    7b72:	ed e8       	ldi	r30, 0x8D	; 141
    7b74:	f7 e0       	ldi	r31, 0x07	; 7
    7b76:	e9 0f       	add	r30, r25
    7b78:	f1 1d       	adc	r31, r1
    7b7a:	87 70       	andi	r24, 0x07	; 7
    7b7c:	21 e0       	ldi	r18, 0x01	; 1
    7b7e:	30 e0       	ldi	r19, 0x00	; 0
    7b80:	02 c0       	rjmp	.+4      	; 0x7b86 <TogDigOut+0x1c>
    7b82:	22 0f       	add	r18, r18
    7b84:	33 1f       	adc	r19, r19
    7b86:	8a 95       	dec	r24
    7b88:	e2 f7       	brpl	.-8      	; 0x7b82 <TogDigOut+0x18>
    7b8a:	84 81       	ldd	r24, Z+4	; 0x04
    7b8c:	82 27       	eor	r24, r18
    7b8e:	84 83       	std	Z+4, r24	; 0x04
}
    7b90:	08 95       	ret

00007b92 <SetAllDigOut>:

// ~~~~~~~~~~~~~~~
void
SetAllDigOut(void)
{
	for (uint8_t i=0; i<DO_Reg; DigOutput.Buf[i++]=0xFF);
    7b92:	8f ef       	ldi	r24, 0xFF	; 255
    7b94:	80 93 91 07 	sts	0x0791, r24
    7b98:	80 93 92 07 	sts	0x0792, r24
}
    7b9c:	08 95       	ret

00007b9e <DO_Enable>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    7b9e:	8f b7       	in	r24, 0x3f	; 63
    7ba0:	80 78       	andi	r24, 0x80	; 128
    7ba2:	80 93 e6 02 	sts	0x02E6, r24
	cli();
    7ba6:	f8 94       	cli
void
DO_Enable(void)
{
	#ifdef Enable
		IntOff();
		PortEnable |=Enable;
    7ba8:	46 9a       	sbi	0x08, 6	; 8

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    7baa:	88 23       	and	r24, r24
    7bac:	09 f0       	breq	.+2      	; 0x7bb0 <DO_Enable+0x12>
		sei();
    7bae:	78 94       	sei
    7bb0:	08 95       	ret

00007bb2 <DO_Disable>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    7bb2:	8f b7       	in	r24, 0x3f	; 63
    7bb4:	80 78       	andi	r24, 0x80	; 128
    7bb6:	80 93 e6 02 	sts	0x02E6, r24
	cli();
    7bba:	f8 94       	cli
void
DO_Disable()
{
	#ifdef Enable
		IntOff();
		PortEnable &=~Enable;
    7bbc:	46 98       	cbi	0x08, 6	; 8

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    7bbe:	88 23       	and	r24, r24
    7bc0:	09 f0       	breq	.+2      	; 0x7bc4 <DO_Disable+0x12>
		sei();
    7bc2:	78 94       	sei
    7bc4:	08 95       	ret

00007bc6 <DigitOut>:

// ~~~~~~~~~~~
void
DigitOut(void)
{
	memcpy(DigOutput.StateOld, DigOutput.State, DO_Reg+DO_Reg_Ext);
    7bc6:	90 91 8d 07 	lds	r25, 0x078D
    7bca:	80 91 8e 07 	lds	r24, 0x078E
    7bce:	80 93 90 07 	sts	0x0790, r24
    7bd2:	90 93 8f 07 	sts	0x078F, r25
	memcpy(DigOutput.State, DigOutput.Buf, DO_Reg);
    7bd6:	90 91 91 07 	lds	r25, 0x0791
    7bda:	80 91 92 07 	lds	r24, 0x0792
    7bde:	80 93 8e 07 	sts	0x078E, r24
    7be2:	90 93 8d 07 	sts	0x078D, r25
    7be6:	20 e1       	ldi	r18, 0x10	; 16
    7be8:	35 e0       	ldi	r19, 0x05	; 5
    7bea:	10 c0       	rjmp	.+32     	; 0x7c0c <DigitOut+0x46>
	uint8_t N = DO_Reg*8;
	while (N) {
		uint8_t D_N = prb(M+--N);
		cli();
		if (DigOutput.State[D_N/8] &(1<<D_N%8))
			PortData  |=Data;
    7bec:	47 9a       	sbi	0x08, 7	; 8
		else
			PortData &=~Data;
		sei();
    7bee:	78 94       	sei
    7bf0:	83 2f       	mov	r24, r19
    7bf2:	8a 95       	dec	r24
    7bf4:	f1 f7       	brne	.-4      	; 0x7bf2 <DigitOut+0x2c>
		_delay_us(1);				// 125 ns needs at 5V
		cli();
    7bf6:	f8 94       	cli
		PortClock |=Clock;
    7bf8:	45 9a       	sbi	0x08, 5	; 8
		sei();
    7bfa:	78 94       	sei
    7bfc:	83 2f       	mov	r24, r19
    7bfe:	8a 95       	dec	r24
    7c00:	f1 f7       	brne	.-4      	; 0x7bfe <DigitOut+0x38>
		_delay_us(1);				// 200 ns needs at 5V
		cli();
    7c02:	f8 94       	cli
		PortClock &=~Clock;
    7c04:	45 98       	cbi	0x08, 5	; 8
		sei();
    7c06:	78 94       	sei
DigitOut_Hard(void)
{
	static prog_uint8_t M[DO_Reg*8] = DO_Map;

	uint8_t N = DO_Reg*8;
	while (N) {
    7c08:	22 23       	and	r18, r18
    7c0a:	d1 f0       	breq	.+52     	; 0x7c40 <DigitOut+0x7a>
		uint8_t D_N = prb(M+--N);
    7c0c:	21 50       	subi	r18, 0x01	; 1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    7c0e:	e2 2f       	mov	r30, r18
    7c10:	f0 e0       	ldi	r31, 0x00	; 0
    7c12:	ea 5d       	subi	r30, 0xDA	; 218
    7c14:	f4 4d       	sbci	r31, 0xD4	; 212
    7c16:	e4 91       	lpm	r30, Z+
		cli();
    7c18:	f8 94       	cli
		if (DigOutput.State[D_N/8] &(1<<D_N%8))
    7c1a:	ae 2f       	mov	r26, r30
    7c1c:	a6 95       	lsr	r26
    7c1e:	a6 95       	lsr	r26
    7c20:	a6 95       	lsr	r26
    7c22:	b0 e0       	ldi	r27, 0x00	; 0
    7c24:	a3 57       	subi	r26, 0x73	; 115
    7c26:	b8 4f       	sbci	r27, 0xF8	; 248
    7c28:	8c 91       	ld	r24, X
    7c2a:	90 e0       	ldi	r25, 0x00	; 0
    7c2c:	e7 70       	andi	r30, 0x07	; 7
    7c2e:	02 c0       	rjmp	.+4      	; 0x7c34 <DigitOut+0x6e>
    7c30:	95 95       	asr	r25
    7c32:	87 95       	ror	r24
    7c34:	ea 95       	dec	r30
    7c36:	e2 f7       	brpl	.-8      	; 0x7c30 <DigitOut+0x6a>
    7c38:	80 fd       	sbrc	r24, 0
    7c3a:	d8 cf       	rjmp	.-80     	; 0x7bec <DigitOut+0x26>
			PortData  |=Data;
		else
			PortData &=~Data;
    7c3c:	47 98       	cbi	0x08, 7	; 8
    7c3e:	d7 cf       	rjmp	.-82     	; 0x7bee <DigitOut+0x28>
		_delay_us(1);				// 200 ns needs at 5V
		cli();
		PortClock &=~Clock;
		sei();
	}
	cli();
    7c40:	f8 94       	cli
	PortStrobe |=Strobe;
    7c42:	80 91 05 01 	lds	r24, 0x0105
    7c46:	81 60       	ori	r24, 0x01	; 1
    7c48:	80 93 05 01 	sts	0x0105, r24
	sei();
    7c4c:	78 94       	sei
    7c4e:	85 e0       	ldi	r24, 0x05	; 5
    7c50:	8a 95       	dec	r24
    7c52:	f1 f7       	brne	.-4      	; 0x7c50 <DigitOut+0x8a>
	_delay_us(1);					// 200 ns needs at 5V
	cli();
    7c54:	f8 94       	cli
	PortStrobe &=~Strobe;
    7c56:	80 91 05 01 	lds	r24, 0x0105
    7c5a:	8e 7f       	andi	r24, 0xFE	; 254
    7c5c:	80 93 05 01 	sts	0x0105, r24
	sei();
    7c60:	78 94       	sei
				DigOutput.State[j] = (DigOutput_Ext)[i];
			(DigOutput_Ext)[i+DO_Reg_Ext] = DigOutput.Buf[j];
			IntOn();
		}
	#endif
}
    7c62:	08 95       	ret

00007c64 <DO_Init>:

// ~~~~~~~~~~~~~~~
static void
DO_Init_Hard(void)
{
	cli();
    7c64:	f8 94       	cli
	DDR_Strobe |= Strobe;
    7c66:	e4 e0       	ldi	r30, 0x04	; 4
    7c68:	f1 e0       	ldi	r31, 0x01	; 1
    7c6a:	80 81       	ld	r24, Z
    7c6c:	81 60       	ori	r24, 0x01	; 1
    7c6e:	80 83       	st	Z, r24
	DDR_Data |= Data;
    7c70:	3f 9a       	sbi	0x07, 7	; 7
	DDR_Enable |= Enable;
    7c72:	3e 9a       	sbi	0x07, 6	; 7
	DDR_Clock |=Clock;
    7c74:	3d 9a       	sbi	0x07, 5	; 7
	PortStrobe &=~Strobe;
    7c76:	e5 e0       	ldi	r30, 0x05	; 5
    7c78:	f1 e0       	ldi	r31, 0x01	; 1
    7c7a:	80 81       	ld	r24, Z
    7c7c:	8e 7f       	andi	r24, 0xFE	; 254
    7c7e:	80 83       	st	Z, r24
	PortClock &=~Clock;
    7c80:	45 98       	cbi	0x08, 5	; 8
	sei();
    7c82:	78 94       	sei
// ~~~~~~~~~~
void
DO_Init(void)
{
	DO_Init_Hard();
	DigitOut();		// Clear all
    7c84:	0e 94 e3 3d 	call	0x7bc6	; 0x7bc6 <DigitOut>
	DO_Enable();
    7c88:	0e 94 cf 3d 	call	0x7b9e	; 0x7b9e <DO_Enable>
}
    7c8c:	08 95       	ret

00007c8e <AI_Init>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    7c8e:	e0 91 f8 04 	lds	r30, 0x04F8
    7c92:	f0 e0       	ldi	r31, 0x00	; 0
    7c94:	ee 0f       	add	r30, r30
    7c96:	ff 1f       	adc	r31, r31
    7c98:	ea 5e       	subi	r30, 0xEA	; 234
    7c9a:	f4 4d       	sbci	r31, 0xD4	; 212
    7c9c:	85 91       	lpm	r24, Z+
    7c9e:	94 91       	lpm	r25, Z+
// ~~~~~~~~~~~
static void
SetMuxAI(void)
{
	static prog_uint16_t Mux[] = AI_Mux;
	ADMUX = (uint8_t) prw(Mux+AI_N);
    7ca0:	80 93 7c 00 	sts	0x007C, r24
	#ifdef MUX5
		ADCSRB = (uint8_t) (prw(Mux+AI_N)>>8);
    7ca4:	90 93 7b 00 	sts	0x007B, r25
		#ifdef AN_C
			DDR_AN_C |=AN_C;
		#endif
	#endif
	SetMuxAI();
	ADCSRA = (((((1<<ADEN) |(1<<ADSC)) &~(1<<AD_Mode)) |(1<<ADIF)) &~(1<<ADIE)) |(1<<ADPS2) |(1<<ADPS1) |(1<<ADPS0);
    7ca8:	87 ed       	ldi	r24, 0xD7	; 215
    7caa:	80 93 7a 00 	sts	0x007A, r24
		}
	#endif
	#ifdef InitAI_10ms
		TD_InnADC = Timer8SysAlloc(AI_Reg);
	#endif
}
    7cae:	08 95       	ret

00007cb0 <AnalogIn>:

// ~~~~~~~~~~~
uint8_t
AnalogIn(void)
{
	if (ADCSRA &(1<<ADSC))
    7cb0:	80 91 7a 00 	lds	r24, 0x007A
    7cb4:	86 fd       	sbrc	r24, 6
    7cb6:	2c c0       	rjmp	.+88     	; 0x7d10 <AnalogIn+0x60>
		return AI_Reg;
	AnalogInput[AI_N] = ADCL;
    7cb8:	50 91 f8 04 	lds	r21, 0x04F8
    7cbc:	65 2f       	mov	r22, r21
    7cbe:	20 91 78 00 	lds	r18, 0x0078
	AnalogInput[AI_N] |= ADCH<<8;
    7cc2:	40 91 79 00 	lds	r20, 0x0079
    7cc6:	e5 2f       	mov	r30, r21
    7cc8:	f0 e0       	ldi	r31, 0x00	; 0
    7cca:	ee 0f       	add	r30, r30
    7ccc:	ff 1f       	adc	r31, r31
    7cce:	e0 50       	subi	r30, 0x00	; 0
    7cd0:	f5 4f       	sbci	r31, 0xF5	; 245
    7cd2:	94 2f       	mov	r25, r20
    7cd4:	80 e0       	ldi	r24, 0x00	; 0
    7cd6:	30 e0       	ldi	r19, 0x00	; 0
    7cd8:	82 2b       	or	r24, r18
    7cda:	93 2b       	or	r25, r19
    7cdc:	91 83       	std	Z+1, r25	; 0x01
    7cde:	80 83       	st	Z, r24
		}
		else
			Chan = AI_Reg;
	#endif

	if (++AI_N == AI_Reg)
    7ce0:	5f 5f       	subi	r21, 0xFF	; 255
    7ce2:	50 93 f8 04 	sts	0x04F8, r21
    7ce6:	58 30       	cpi	r21, 0x08	; 8
    7ce8:	b1 f0       	breq	.+44     	; 0x7d16 <AnalogIn+0x66>
    7cea:	e5 2f       	mov	r30, r21
    7cec:	f0 e0       	ldi	r31, 0x00	; 0
    7cee:	ee 0f       	add	r30, r30
    7cf0:	ff 1f       	adc	r31, r31
    7cf2:	ea 5e       	subi	r30, 0xEA	; 234
    7cf4:	f4 4d       	sbci	r31, 0xD4	; 212
    7cf6:	85 91       	lpm	r24, Z+
    7cf8:	94 91       	lpm	r25, Z+
// ~~~~~~~~~~~
static void
SetMuxAI(void)
{
	static prog_uint16_t Mux[] = AI_Mux;
	ADMUX = (uint8_t) prw(Mux+AI_N);
    7cfa:	80 93 7c 00 	sts	0x007C, r24
	#ifdef MUX5
		ADCSRB = (uint8_t) (prw(Mux+AI_N)>>8);
    7cfe:	90 93 7b 00 	sts	0x007B, r25
	#endif

	if (++AI_N == AI_Reg)
		AI_N = 0;
	SetMuxAI();
	ADCSRA |=(1<<ADSC);
    7d02:	80 91 7a 00 	lds	r24, 0x007A
    7d06:	80 64       	ori	r24, 0x40	; 64
    7d08:	80 93 7a 00 	sts	0x007A, r24
			IntOn();
		}
	#endif

	return Chan;
}
    7d0c:	86 2f       	mov	r24, r22
    7d0e:	08 95       	ret

// ~~~~~~~~~~~
uint8_t
AnalogIn(void)
{
	if (ADCSRA &(1<<ADSC))
    7d10:	68 e0       	ldi	r22, 0x08	; 8
			IntOn();
		}
	#endif

	return Chan;
}
    7d12:	86 2f       	mov	r24, r22
    7d14:	08 95       	ret
		else
			Chan = AI_Reg;
	#endif

	if (++AI_N == AI_Reg)
		AI_N = 0;
    7d16:	10 92 f8 04 	sts	0x04F8, r1
    7d1a:	50 e0       	ldi	r21, 0x00	; 0
    7d1c:	e6 cf       	rjmp	.-52     	; 0x7cea <AnalogIn+0x3a>

00007d1e <Thermode>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
int16_t
Thermode(uint8_t T_Fami, uint8_t T_Type, uint16_t Code)
{
	if (T_Type==ThermOff)
    7d1e:	66 23       	and	r22, r22
    7d20:	f9 f0       	breq	.+62     	; 0x7d60 <Thermode+0x42>
		return Therm_Off_Mark;
	if (T_Fami==Thermis)
    7d22:	88 23       	and	r24, r24
    7d24:	91 f4       	brne	.+36     	; 0x7d4a <Thermode+0x2c>
		switch(T_Type) {
    7d26:	64 30       	cpi	r22, 0x04	; 4
    7d28:	d9 f1       	breq	.+118    	; 0x7da0 <Thermode+0x82>
    7d2a:	65 30       	cpi	r22, 0x05	; 5
    7d2c:	60 f5       	brcc	.+88     	; 0x7d86 <Thermode+0x68>
    7d2e:	62 30       	cpi	r22, 0x02	; 2
    7d30:	09 f4       	brne	.+2      	; 0x7d34 <Thermode+0x16>
    7d32:	4b c0       	rjmp	.+150    	; 0x7dca <Thermode+0xac>
    7d34:	63 30       	cpi	r22, 0x03	; 3
    7d36:	d8 f5       	brcc	.+118    	; 0x7dae <Thermode+0x90>
    7d38:	61 30       	cpi	r22, 0x01	; 1
    7d3a:	a1 f4       	brne	.+40     	; 0x7d64 <Thermode+0x46>
		case TSM100:
			return ThermCalc(TSM100);
    7d3c:	8e ec       	ldi	r24, 0xCE	; 206
    7d3e:	99 e2       	ldi	r25, 0x29	; 41
    7d40:	ba 01       	movw	r22, r20
    7d42:	0e 94 44 21 	call	0x4288	; 0x4288 <PGM_uBrokLine>
    7d46:	ac 01       	movw	r20, r24
    7d48:	0d c0       	rjmp	.+26     	; 0x7d64 <Thermode+0x46>
#endif
		default:
			return Code;
		}
	else	// T_Fami==Thermoc
		switch(T_Type) {
    7d4a:	61 30       	cpi	r22, 0x01	; 1
    7d4c:	69 f0       	breq	.+26     	; 0x7d68 <Thermode+0x4a>
    7d4e:	62 30       	cpi	r22, 0x02	; 2
    7d50:	49 f4       	brne	.+18     	; 0x7d64 <Thermode+0x46>
		case TC_K:
			return .1851*Code;
#endif
#if	TerInput==ADC_Input
		case TC_B:
			return ThermCalc(TC_B_);
    7d52:	82 ed       	ldi	r24, 0xD2	; 210
    7d54:	9a e2       	ldi	r25, 0x2A	; 42
    7d56:	ba 01       	movw	r22, r20
    7d58:	0e 94 44 21 	call	0x4288	; 0x4288 <PGM_uBrokLine>
    7d5c:	ac 01       	movw	r20, r24
    7d5e:	02 c0       	rjmp	.+4      	; 0x7d64 <Thermode+0x46>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
int16_t
Thermode(uint8_t T_Fami, uint8_t T_Type, uint16_t Code)
{
	if (T_Type==ThermOff)
    7d60:	40 e0       	ldi	r20, 0x00	; 0
    7d62:	50 e8       	ldi	r21, 0x80	; 128
			return ThermCalc(TC_B_);
#endif
		default:
			return Code;
		}
}
    7d64:	ca 01       	movw	r24, r20
    7d66:	08 95       	ret
			return ThermCalc(TC_J_) + InnerTer;
		case TC_L:
			return ThermCalc(TC_L_) + InnerTer;
#else
		case TC_K:
			return .1851*Code;
    7d68:	ba 01       	movw	r22, r20
    7d6a:	80 e0       	ldi	r24, 0x00	; 0
    7d6c:	90 e0       	ldi	r25, 0x00	; 0
    7d6e:	0e 94 93 78 	call	0xf126	; 0xf126 <__floatunsisf>
    7d72:	2b ed       	ldi	r18, 0xDB	; 219
    7d74:	3a e8       	ldi	r19, 0x8A	; 138
    7d76:	4d e3       	ldi	r20, 0x3D	; 61
    7d78:	5e e3       	ldi	r21, 0x3E	; 62
    7d7a:	0e 94 d0 78 	call	0xf1a0	; 0xf1a0 <__mulsf3>
    7d7e:	0e 94 63 7d 	call	0xfac6	; 0xfac6 <__fixsfsi>
    7d82:	ab 01       	movw	r20, r22
    7d84:	ef cf       	rjmp	.-34     	; 0x7d64 <Thermode+0x46>
Thermode(uint8_t T_Fami, uint8_t T_Type, uint16_t Code)
{
	if (T_Type==ThermOff)
		return Therm_Off_Mark;
	if (T_Fami==Thermis)
		switch(T_Type) {
    7d86:	66 30       	cpi	r22, 0x06	; 6
    7d88:	39 f1       	breq	.+78     	; 0x7dd8 <Thermode+0xba>
    7d8a:	66 30       	cpi	r22, 0x06	; 6
    7d8c:	b8 f0       	brcs	.+46     	; 0x7dbc <Thermode+0x9e>
    7d8e:	67 30       	cpi	r22, 0x07	; 7
    7d90:	49 f7       	brne	.-46     	; 0x7d64 <Thermode+0x46>
			return ThermCalc(Pt100);
#if	TerInput==ADC_Input
		case Gr21:
			return ThermCalc(Gr21);
		case Gr23:
			return ThermCalc(Gr23);
    7d92:	82 eb       	ldi	r24, 0xB2	; 178
    7d94:	9a e2       	ldi	r25, 0x2A	; 42
    7d96:	ba 01       	movw	r22, r20
    7d98:	0e 94 44 21 	call	0x4288	; 0x4288 <PGM_uBrokLine>
    7d9c:	ac 01       	movw	r20, r24
    7d9e:	e2 cf       	rjmp	.-60     	; 0x7d64 <Thermode+0x46>
		case TSM50:
			return ThermCalc(TSM50);
		case TSP100:
			return ThermCalc(TSP100);
		case TSP50:
			return ThermCalc(TSP50);
    7da0:	82 e4       	ldi	r24, 0x42	; 66
    7da2:	9a e2       	ldi	r25, 0x2A	; 42
    7da4:	ba 01       	movw	r22, r20
    7da6:	0e 94 44 21 	call	0x4288	; 0x4288 <PGM_uBrokLine>
    7daa:	ac 01       	movw	r20, r24
    7dac:	db cf       	rjmp	.-74     	; 0x7d64 <Thermode+0x46>
		case TSM100:
			return ThermCalc(TSM100);
		case TSM50:
			return ThermCalc(TSM50);
		case TSP100:
			return ThermCalc(TSP100);
    7dae:	8a e1       	ldi	r24, 0x1A	; 26
    7db0:	9a e2       	ldi	r25, 0x2A	; 42
    7db2:	ba 01       	movw	r22, r20
    7db4:	0e 94 44 21 	call	0x4288	; 0x4288 <PGM_uBrokLine>
    7db8:	ac 01       	movw	r20, r24
    7dba:	d4 cf       	rjmp	.-88     	; 0x7d64 <Thermode+0x46>
		case TSP50:
			return ThermCalc(TSP50);
		case Pt100:
			return ThermCalc(Pt100);
    7dbc:	86 e6       	ldi	r24, 0x66	; 102
    7dbe:	9a e2       	ldi	r25, 0x2A	; 42
    7dc0:	ba 01       	movw	r22, r20
    7dc2:	0e 94 44 21 	call	0x4288	; 0x4288 <PGM_uBrokLine>
    7dc6:	ac 01       	movw	r20, r24
    7dc8:	cd cf       	rjmp	.-102    	; 0x7d64 <Thermode+0x46>
	if (T_Fami==Thermis)
		switch(T_Type) {
		case TSM100:
			return ThermCalc(TSM100);
		case TSM50:
			return ThermCalc(TSM50);
    7dca:	8e ee       	ldi	r24, 0xEE	; 238
    7dcc:	99 e2       	ldi	r25, 0x29	; 41
    7dce:	ba 01       	movw	r22, r20
    7dd0:	0e 94 44 21 	call	0x4288	; 0x4288 <PGM_uBrokLine>
    7dd4:	ac 01       	movw	r20, r24
    7dd6:	c6 cf       	rjmp	.-116    	; 0x7d64 <Thermode+0x46>
			return ThermCalc(TSP50);
		case Pt100:
			return ThermCalc(Pt100);
#if	TerInput==ADC_Input
		case Gr21:
			return ThermCalc(Gr21);
    7dd8:	8e e8       	ldi	r24, 0x8E	; 142
    7dda:	9a e2       	ldi	r25, 0x2A	; 42
    7ddc:	ba 01       	movw	r22, r20
    7dde:	0e 94 44 21 	call	0x4288	; 0x4288 <PGM_uBrokLine>
    7de2:	ac 01       	movw	r20, r24
    7de4:	bf cf       	rjmp	.-130    	; 0x7d64 <Thermode+0x46>

00007de6 <ThermExt>:
			IntOff();
			Temperature[TerReg+i] = (Temperature_Ext)[i];
			IntOn();
		}
	#endif
}
    7de6:	08 95       	ret

00007de8 <Therm_ADC_Off>:

// ~~~~~~~~~~~~~~~~
void
Therm_ADC_Off(void)
{
	for (uint8_t i=0; i<TerReg; Temperature[i++]=ADC_Off_Mark);
    7de8:	81 e0       	ldi	r24, 0x01	; 1
    7dea:	90 e8       	ldi	r25, 0x80	; 128
    7dec:	90 93 3e 06 	sts	0x063E, r25
    7df0:	80 93 3d 06 	sts	0x063D, r24
    7df4:	90 93 40 06 	sts	0x0640, r25
    7df8:	80 93 3f 06 	sts	0x063F, r24
    7dfc:	90 93 42 06 	sts	0x0642, r25
    7e00:	80 93 41 06 	sts	0x0641, r24
    7e04:	90 93 44 06 	sts	0x0644, r25
    7e08:	80 93 43 06 	sts	0x0643, r24
    7e0c:	90 93 46 06 	sts	0x0646, r25
    7e10:	80 93 45 06 	sts	0x0645, r24
    7e14:	90 93 48 06 	sts	0x0648, r25
    7e18:	80 93 47 06 	sts	0x0647, r24
}
    7e1c:	08 95       	ret

00007e1e <ThermWrong>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
ThermWrong(uint8_t T_Fami, uint8_t T_Type, int16_t Ter)
{
	uint8_t TW = ThermNorm;
	if (T_Type!=ThermOff && T_Type<=prb(MaxThermType+T_Fami)) {
    7e1e:	66 23       	and	r22, r22
    7e20:	31 f1       	breq	.+76     	; 0x7e6e <ThermWrong+0x50>
    7e22:	28 2f       	mov	r18, r24
    7e24:	30 e0       	ldi	r19, 0x00	; 0

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    7e26:	f9 01       	movw	r30, r18
    7e28:	e8 53       	subi	r30, 0x38	; 56
    7e2a:	f6 4d       	sbci	r31, 0xD6	; 214
    7e2c:	e4 91       	lpm	r30, Z+
    7e2e:	e6 17       	cp	r30, r22
    7e30:	f0 f0       	brcs	.+60     	; 0x7e6e <ThermWrong+0x50>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    7e32:	f9 01       	movw	r30, r18
    7e34:	ee 0f       	add	r30, r30
    7e36:	ff 1f       	adc	r31, r31
    7e38:	e6 53       	subi	r30, 0x36	; 54
    7e3a:	f6 4d       	sbci	r31, 0xD6	; 214
    7e3c:	25 91       	lpm	r18, Z+
    7e3e:	34 91       	lpm	r19, Z+
		TerLim *T_L = prp(TerLimType+T_Fami);
		if (Ter<(int16_t)prw(&T_L[T_Type].Low))
    7e40:	86 2f       	mov	r24, r22
    7e42:	90 e0       	ldi	r25, 0x00	; 0
    7e44:	88 0f       	add	r24, r24
    7e46:	99 1f       	adc	r25, r25
    7e48:	88 0f       	add	r24, r24
    7e4a:	99 1f       	adc	r25, r25
    7e4c:	28 0f       	add	r18, r24
    7e4e:	39 1f       	adc	r19, r25

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    7e50:	f9 01       	movw	r30, r18
    7e52:	85 91       	lpm	r24, Z+
    7e54:	94 91       	lpm	r25, Z+
    7e56:	48 17       	cp	r20, r24
    7e58:	59 07       	cpc	r21, r25
    7e5a:	5c f0       	brlt	.+22     	; 0x7e72 <ThermWrong+0x54>
    7e5c:	f9 01       	movw	r30, r18
    7e5e:	32 96       	adiw	r30, 0x02	; 2
    7e60:	85 91       	lpm	r24, Z+
    7e62:	94 91       	lpm	r25, Z+
			TW = ThermUnder;
		else if(Ter>(int16_t)prw(&T_L[T_Type].Upp))
    7e64:	84 17       	cp	r24, r20
    7e66:	95 07       	cpc	r25, r21
    7e68:	14 f4       	brge	.+4      	; 0x7e6e <ThermWrong+0x50>
    7e6a:	82 e0       	ldi	r24, 0x02	; 2
    7e6c:	08 95       	ret
    7e6e:	80 e0       	ldi	r24, 0x00	; 0
			TW = ThermOver;
	}
	return TW;
}
    7e70:	08 95       	ret
ThermWrong(uint8_t T_Fami, uint8_t T_Type, int16_t Ter)
{
	uint8_t TW = ThermNorm;
	if (T_Type!=ThermOff && T_Type<=prb(MaxThermType+T_Fami)) {
		TerLim *T_L = prp(TerLimType+T_Fami);
		if (Ter<(int16_t)prw(&T_L[T_Type].Low))
    7e72:	81 e0       	ldi	r24, 0x01	; 1
    7e74:	08 95       	ret

00007e76 <Key_MB0_CPT_Clear>:
	{" BAUD: }}}}}bps     ", NULL, F_MB##N##_Baud}																														\
};																																																					\
MenuPage MenuModbus##N = {SetMenu(L_MB##N), 1};

#if Modbus_Qt == 1
	M_Modbus(0)
    7e76:	80 e0       	ldi	r24, 0x00	; 0
    7e78:	90 e0       	ldi	r25, 0x00	; 0

// ~~~~~~~~~~~~~~~~~~~~~~~
void
MB_CPT_Clear(uint8_t MB_N)
{
	for (uint8_t i=0; i<8; MB_CPT[MB_N][i++]=0);
    7e7a:	fc 01       	movw	r30, r24
    7e7c:	ee 0f       	add	r30, r30
    7e7e:	ff 1f       	adc	r31, r31
    7e80:	e8 51       	subi	r30, 0x18	; 24
    7e82:	f7 4f       	sbci	r31, 0xF7	; 247
    7e84:	11 82       	std	Z+1, r1	; 0x01
    7e86:	10 82       	st	Z, r1
    7e88:	01 96       	adiw	r24, 0x01	; 1
    7e8a:	88 30       	cpi	r24, 0x08	; 8
    7e8c:	91 05       	cpc	r25, r1
    7e8e:	a9 f7       	brne	.-22     	; 0x7e7a <Key_MB0_CPT_Clear+0x4>
    7e90:	81 e0       	ldi	r24, 0x01	; 1
    7e92:	08 95       	ret

00007e94 <ResetGSMState>:
	#ifdef GSM_DEBUG
		MenuPage MenuGSMConsole;
	#endif

	void ResetGSMState(void){
		GSM_State = GSM_ReStart1;
    7e94:	88 e4       	ldi	r24, 0x48	; 72
    7e96:	80 93 ad 06 	sts	0x06AD, r24
	}
    7e9a:	08 95       	ret

00007e9c <Key_MaxScanCycle_Clear>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
InField F_ScanCycle[] = { {Byte, &ScanCycle} };
InField F_ScanCyclePerSec[] = { {Word, &ScanPerSec} }; 
InField F_MaxScanCycle[] = {{Byte, &MaxScanCycle}};

uint8_t Key_MaxScanCycle_Clear(void) {if(CurrLine==3) MaxScanCycle_Clear(); return StandartKey;}
    7e9c:	80 91 7d 07 	lds	r24, 0x077D
    7ea0:	83 30       	cpi	r24, 0x03	; 3
    7ea2:	11 f4       	brne	.+4      	; 0x7ea8 <Key_MaxScanCycle_Clear+0xc>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
void
MaxScanCycle_Clear(void)
{
	MaxScanCycle = 0;
    7ea4:	10 92 a9 06 	sts	0x06A9, r1
    7ea8:	80 e0       	ldi	r24, 0x00	; 0
    7eaa:	08 95       	ret

00007eac <ApplInit>:
void
ApplInit(void)
{
	

}
    7eac:	08 95       	ret

00007eae <ApplCycle>:
// ~~~~~~~~~~~~
void
ApplCycle(void)
{

}
    7eae:	08 95       	ret

00007eb0 <StartKey>:
uint8_t numOfCheckBallanceRetry=0;

uint8_t Message[3];  // 
uint8_t GSMBusyState=0; // " " 0 -  , 1 -  
void GSM_StartCalling(uint8_t inputN,uint8_t abonentN){
	Message[0]=1;
    7eb0:	81 e0       	ldi	r24, 0x01	; 1
    7eb2:	80 93 ec 06 	sts	0x06EC, r24
	Message[1]=inputN;
    7eb6:	10 92 ed 06 	sts	0x06ED, r1
	Message[2]=abonentN;
    7eba:	80 93 ee 06 	sts	0x06EE, r24
// ~~~~~~~~~~~
void
StartKey(void)
{	
	GSM_StartCalling(0,1);
}
    7ebe:	08 95       	ret

00007ec0 <StopKey>:
// ~~~~~~~~~~
void
StopKey(void)
{
	
}
    7ec0:	08 95       	ret

00007ec2 <Menu_ConfirmationRest_Enter>:
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	//		   
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	uint8_t Menu_ConfirmationRest_Enter(){

		eeprom_write_byte((uint8_t*)E2END, 0xBB);
    7ec2:	8f ef       	ldi	r24, 0xFF	; 255
    7ec4:	9f e0       	ldi	r25, 0x0F	; 15
    7ec6:	6b eb       	ldi	r22, 0xBB	; 187
    7ec8:	0e 94 c2 7d 	call	0xfb84	; 0xfb84 <__eewr_byte_m2560>
		eeprom_write_byte(&MemCheck_stor.ReprogFlg, 0);
    7ecc:	8c e3       	ldi	r24, 0x3C	; 60
    7ece:	91 e0       	ldi	r25, 0x01	; 1
    7ed0:	60 e0       	ldi	r22, 0x00	; 0
    7ed2:	0e 94 c2 7d 	call	0xfb84	; 0xfb84 <__eewr_byte_m2560>
    7ed6:	ff cf       	rjmp	.-2      	; 0x7ed6 <Menu_ConfirmationRest_Enter+0x14>

00007ed8 <Menu_ConfirmationSave_Enter>:
	//		   
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	uint8_t Menu_ConfirmationSave_Enter(){

		//  backup-
		eeprom_write_byte((uint8_t*)E2END, 0xAA);
    7ed8:	8f ef       	ldi	r24, 0xFF	; 255
    7eda:	9f e0       	ldi	r25, 0x0F	; 15
    7edc:	6a ea       	ldi	r22, 0xAA	; 170
    7ede:	0e 94 c2 7d 	call	0xfb84	; 0xfb84 <__eewr_byte_m2560>
		eeprom_write_byte(&DateBackUp.Day, Tm_MDay);
    7ee2:	80 e0       	ldi	r24, 0x00	; 0
    7ee4:	90 e0       	ldi	r25, 0x00	; 0
    7ee6:	60 91 11 0b 	lds	r22, 0x0B11
    7eea:	0e 94 c2 7d 	call	0xfb84	; 0xfb84 <__eewr_byte_m2560>
		eeprom_write_byte(&DateBackUp.Month, Tm_Mon);
    7eee:	81 e0       	ldi	r24, 0x01	; 1
    7ef0:	90 e0       	ldi	r25, 0x00	; 0
    7ef2:	60 91 7f 07 	lds	r22, 0x077F
    7ef6:	0e 94 c2 7d 	call	0xfb84	; 0xfb84 <__eewr_byte_m2560>
		#ifdef M41T56
			eeprom_write_byte(&DateBackUp.Year, Tm_Year);
    7efa:	82 e0       	ldi	r24, 0x02	; 2
    7efc:	90 e0       	ldi	r25, 0x00	; 0
    7efe:	60 91 d6 05 	lds	r22, 0x05D6
    7f02:	0e 94 c2 7d 	call	0xfb84	; 0xfb84 <__eewr_byte_m2560>
		#else
			eeprom_write_byte(&DateBackUp.Year, erb(&Tm_Year));
		#endif
		eeprom_write_byte(&MemCheck_stor.ReprogFlg, 0);
    7f06:	8c e3       	ldi	r24, 0x3C	; 60
    7f08:	91 e0       	ldi	r25, 0x01	; 1
    7f0a:	60 e0       	ldi	r22, 0x00	; 0
    7f0c:	0e 94 c2 7d 	call	0xfb84	; 0xfb84 <__eewr_byte_m2560>
    7f10:	ff cf       	rjmp	.-2      	; 0x7f10 <Menu_ConfirmationSave_Enter+0x38>

00007f12 <GSM_SendData>:
	GSMTxSz = Size;
	memcpy(GSM_TxStr, Data_Out, GSMTxSz);
	GSM_SendFirstChar();
}
// ~~~~~~~~~
void GSM_SendData(uint8_t *Data_Out, uint8_t Size){
    7f12:	58 2f       	mov	r21, r24
    7f14:	79 2f       	mov	r23, r25
	GSMTxSz = Size;
    7f16:	60 93 6f 07 	sts	0x076F, r22
	memcpy(GSM_TxStr, Data_Out, GSMTxSz);
    7f1a:	40 91 6f 07 	lds	r20, 0x076F
    7f1e:	2c ef       	ldi	r18, 0xFC	; 252
    7f20:	39 e0       	ldi	r19, 0x09	; 9
    7f22:	c9 01       	movw	r24, r18
    7f24:	65 2f       	mov	r22, r21
    7f26:	50 e0       	ldi	r21, 0x00	; 0
    7f28:	0e 94 c6 7a 	call	0xf58c	; 0xf58c <memcpy>
	GSM_SendFirstChar();
    7f2c:	0e 94 fd 38 	call	0x71fa	; 0x71fa <GSM_SendFirstChar>
}
    7f30:	08 95       	ret

00007f32 <GSM_AddHeaderSendData>:
	GSMTxSz++;
	GSM_SendFirstChar();
}
// ~~~~~~~~~
//   + CntrZ
void GSM_AddHeaderSendData(uint8_t *Data_Out, uint8_t Size){
    7f32:	58 2f       	mov	r21, r24
    7f34:	79 2f       	mov	r23, r25
	GSMTxSz = Size;
    7f36:	60 93 6f 07 	sts	0x076F, r22
	memcpy(GSM_TxStr, Data_Out, GSMTxSz);
    7f3a:	40 91 6f 07 	lds	r20, 0x076F
    7f3e:	2c ef       	ldi	r18, 0xFC	; 252
    7f40:	39 e0       	ldi	r19, 0x09	; 9
    7f42:	c9 01       	movw	r24, r18
    7f44:	65 2f       	mov	r22, r21
    7f46:	50 e0       	ldi	r21, 0x00	; 0
    7f48:	0e 94 c6 7a 	call	0xf58c	; 0xf58c <memcpy>
	GSM_SendFirstChar();
    7f4c:	0e 94 fd 38 	call	0x71fa	; 0x71fa <GSM_SendFirstChar>
}
    7f50:	08 95       	ret

00007f52 <PresicionHanler>:
		ew##ty3((ty2*)Var, Min);						\
	else																	\
		ew##ty3((ty2*)Var, (ty2)Buf)
// ~~~~~~~~~~~~~~~~~~~~~~~
//Change BufStr due to precision for correct sscanf reading BufStr
void PresicionHanler(OutField *Field){
    7f52:	cf 93       	push	r28
    7f54:	df 93       	push	r29

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    7f56:	ec 01       	movw	r28, r24
    7f58:	2f 96       	adiw	r28, 0x0f	; 15
    7f5a:	fe 01       	movw	r30, r28
    7f5c:	84 91       	lpm	r24, Z+
	if(prb(&Field->Prec)){
    7f5e:	88 23       	and	r24, r24
    7f60:	19 f4       	brne	.+6      	; 0x7f68 <PresicionHanler+0x16>
			}
			p++;
		}
	}
	
}
    7f62:	df 91       	pop	r29
    7f64:	cf 91       	pop	r28
    7f66:	08 95       	ret
		ew##ty3((ty2*)Var, (ty2)Buf)
// ~~~~~~~~~~~~~~~~~~~~~~~
//Change BufStr due to precision for correct sscanf reading BufStr
void PresicionHanler(OutField *Field){
	if(prb(&Field->Prec)){
		char *p = strchr(BufStr,'.');	//seek for first decimal point
    7f68:	8b eb       	ldi	r24, 0xBB	; 187
    7f6a:	95 e0       	ldi	r25, 0x05	; 5
    7f6c:	6e e2       	ldi	r22, 0x2E	; 46
    7f6e:	70 e0       	ldi	r23, 0x00	; 0
    7f70:	0e 94 cf 7a 	call	0xf59e	; 0xf59e <strchr>
		if(p==NULL){
    7f74:	00 97       	sbiw	r24, 0x00	; 0
    7f76:	01 f1       	breq	.+64     	; 0x7fb8 <PresicionHanler+0x66>
    7f78:	fe 01       	movw	r30, r28
    7f7a:	24 91       	lpm	r18, Z+
			p = strchr(BufStr,' ');	//else seek for first space
		}
	  	for(uint8_t i=0; i<prb(&Field->Prec); i++){
    7f7c:	22 23       	and	r18, r18
    7f7e:	89 f3       	breq	.-30     	; 0x7f62 <PresicionHanler+0x10>
    7f80:	fc 01       	movw	r30, r24
    7f82:	dc 01       	movw	r26, r24
    7f84:	11 96       	adiw	r26, 0x01	; 1
    7f86:	30 e0       	ldi	r19, 0x00	; 0
			if(*p == '.'){
				if(isdigit(*(p+1))){
					*p= *(p+1);
					*(p+1) = '.';
				}
				else *p='0'; 
    7f88:	60 e3       	ldi	r22, 0x30	; 48
    7f8a:	52 2f       	mov	r21, r18
    7f8c:	07 c0       	rjmp	.+14     	; 0x7f9c <PresicionHanler+0x4a>
		if(p==NULL){
			p = strchr(BufStr,' ');	//else seek for first space
		}
	  	for(uint8_t i=0; i<prb(&Field->Prec); i++){
			if(*p == ' ') *p='0'; 
			if(*p == '.'){
    7f8e:	2e 32       	cpi	r18, 0x2E	; 46
    7f90:	51 f0       	breq	.+20     	; 0x7fa6 <PresicionHanler+0x54>
	if(prb(&Field->Prec)){
		char *p = strchr(BufStr,'.');	//seek for first decimal point
		if(p==NULL){
			p = strchr(BufStr,' ');	//else seek for first space
		}
	  	for(uint8_t i=0; i<prb(&Field->Prec); i++){
    7f92:	3f 5f       	subi	r19, 0xFF	; 255
    7f94:	31 96       	adiw	r30, 0x01	; 1
    7f96:	11 96       	adiw	r26, 0x01	; 1
    7f98:	35 17       	cp	r19, r21
    7f9a:	18 f7       	brcc	.-58     	; 0x7f62 <PresicionHanler+0x10>
			if(*p == ' ') *p='0'; 
    7f9c:	20 81       	ld	r18, Z
    7f9e:	20 32       	cpi	r18, 0x20	; 32
    7fa0:	b1 f7       	brne	.-20     	; 0x7f8e <PresicionHanler+0x3c>
			if(*p == '.'){
				if(isdigit(*(p+1))){
					*p= *(p+1);
					*(p+1) = '.';
				}
				else *p='0'; 
    7fa2:	60 83       	st	Z, r22
    7fa4:	f6 cf       	rjmp	.-20     	; 0x7f92 <PresicionHanler+0x40>
			p = strchr(BufStr,' ');	//else seek for first space
		}
	  	for(uint8_t i=0; i<prb(&Field->Prec); i++){
			if(*p == ' ') *p='0'; 
			if(*p == '.'){
				if(isdigit(*(p+1))){
    7fa6:	4c 91       	ld	r20, X
    7fa8:	84 2f       	mov	r24, r20
    7faa:	90 e0       	ldi	r25, 0x00	; 0
    7fac:	c0 97       	sbiw	r24, 0x30	; 48
    7fae:	0a 97       	sbiw	r24, 0x0a	; 10
    7fb0:	c0 f7       	brcc	.-16     	; 0x7fa2 <PresicionHanler+0x50>
					*p= *(p+1);
    7fb2:	40 83       	st	Z, r20
					*(p+1) = '.';
    7fb4:	2c 93       	st	X, r18
    7fb6:	ed cf       	rjmp	.-38     	; 0x7f92 <PresicionHanler+0x40>
//Change BufStr due to precision for correct sscanf reading BufStr
void PresicionHanler(OutField *Field){
	if(prb(&Field->Prec)){
		char *p = strchr(BufStr,'.');	//seek for first decimal point
		if(p==NULL){
			p = strchr(BufStr,' ');	//else seek for first space
    7fb8:	8b eb       	ldi	r24, 0xBB	; 187
    7fba:	95 e0       	ldi	r25, 0x05	; 5
    7fbc:	60 e2       	ldi	r22, 0x20	; 32
    7fbe:	70 e0       	ldi	r23, 0x00	; 0
    7fc0:	0e 94 cf 7a 	call	0xf59e	; 0xf59e <strchr>
    7fc4:	d9 cf       	rjmp	.-78     	; 0x7f78 <PresicionHanler+0x26>

00007fc6 <GetMultiSymbol>:
	}
	return 0;
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~
//    MultiSymbol   
uint8_t GetMultiSymbol(PGM_P Str_P, char Char){
    7fc6:	1f 93       	push	r17
    7fc8:	18 2f       	mov	r17, r24
	PGM_P ptr_P= strchr_P(Str_P, Char);
    7fca:	70 e0       	ldi	r23, 0x00	; 0
    7fcc:	0e 94 6f 7a 	call	0xf4de	; 0xf4de <strchr_P>
	if(ptr_P) return (uint8_t)(ptr_P - Str_P);
    7fd0:	00 97       	sbiw	r24, 0x00	; 0
    7fd2:	19 f0       	breq	.+6      	; 0x7fda <GetMultiSymbol+0x14>
    7fd4:	81 1b       	sub	r24, r17
	else return 0;
}
    7fd6:	1f 91       	pop	r17
    7fd8:	08 95       	ret
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~
//    MultiSymbol   
uint8_t GetMultiSymbol(PGM_P Str_P, char Char){
	PGM_P ptr_P= strchr_P(Str_P, Char);
	if(ptr_P) return (uint8_t)(ptr_P - Str_P);
    7fda:	80 e0       	ldi	r24, 0x00	; 0
	else return 0;
}
    7fdc:	1f 91       	pop	r17
    7fde:	08 95       	ret

00007fe0 <PutEnum>:
} T_Param;

// ~~~~~~~~~~~~~~~~~~~~
void
PutEnum(T_Param *Param)
{
    7fe0:	0f 93       	push	r16
    7fe2:	1f 93       	push	r17
    7fe4:	cf 93       	push	r28
    7fe6:	df 93       	push	r29
    7fe8:	8c 01       	movw	r16, r24

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    7fea:	dc 01       	movw	r26, r24
    7fec:	14 96       	adiw	r26, 0x04	; 4
    7fee:	ed 91       	ld	r30, X+
    7ff0:	fc 91       	ld	r31, X
    7ff2:	15 97       	sbiw	r26, 0x05	; 5
    7ff4:	65 91       	lpm	r22, Z+
    7ff6:	74 91       	lpm	r23, Z+
	strcpy_P(Param->Pos, prp(Param->Txt));
    7ff8:	8d 91       	ld	r24, X+
    7ffa:	9c 91       	ld	r25, X
    7ffc:	0e 94 83 7a 	call	0xf506	; 0xf506 <strcpy_P>
	for(uint8_t i=strlen(Param->Pos); i<Param->Size; *(Param->Pos+i++)=' ');
    8000:	f8 01       	movw	r30, r16
    8002:	c0 81       	ld	r28, Z
    8004:	d1 81       	ldd	r29, Z+1	; 0x01
    8006:	fe 01       	movw	r30, r28
    8008:	01 90       	ld	r0, Z+
    800a:	00 20       	and	r0, r0
    800c:	e9 f7       	brne	.-6      	; 0x8008 <PutEnum+0x28>
    800e:	31 97       	sbiw	r30, 0x01	; 1
    8010:	ec 1b       	sub	r30, r28
    8012:	d8 01       	movw	r26, r16
    8014:	13 96       	adiw	r26, 0x03	; 3
    8016:	8c 91       	ld	r24, X
    8018:	e8 17       	cp	r30, r24
    801a:	70 f4       	brcc	.+28     	; 0x8038 <PutEnum+0x58>
    801c:	90 e2       	ldi	r25, 0x20	; 32
    801e:	02 c0       	rjmp	.+4      	; 0x8024 <PutEnum+0x44>
    8020:	cd 91       	ld	r28, X+
    8022:	dc 91       	ld	r29, X
    8024:	ce 0f       	add	r28, r30
    8026:	d1 1d       	adc	r29, r1
    8028:	98 83       	st	Y, r25
    802a:	ef 5f       	subi	r30, 0xFF	; 255
    802c:	d8 01       	movw	r26, r16
    802e:	13 96       	adiw	r26, 0x03	; 3
    8030:	8c 91       	ld	r24, X
    8032:	13 97       	sbiw	r26, 0x03	; 3
    8034:	e8 17       	cp	r30, r24
    8036:	a0 f3       	brcs	.-24     	; 0x8020 <PutEnum+0x40>
}
    8038:	df 91       	pop	r29
    803a:	cf 91       	pop	r28
    803c:	1f 91       	pop	r17
    803e:	0f 91       	pop	r16
    8040:	08 95       	ret

00008042 <Put_sbVal>:
}

// ~~~~~~~~~~~~~~~~~~~~~~
void
Put_sbVal(T_Param *Param)
{
    8042:	6f 92       	push	r6
    8044:	7f 92       	push	r7
    8046:	8f 92       	push	r8
    8048:	9f 92       	push	r9
    804a:	af 92       	push	r10
    804c:	bf 92       	push	r11
    804e:	cf 92       	push	r12
    8050:	df 92       	push	r13
    8052:	ef 92       	push	r14
    8054:	ff 92       	push	r15
    8056:	0f 93       	push	r16
    8058:	1f 93       	push	r17
    805a:	df 93       	push	r29
    805c:	cf 93       	push	r28
    805e:	cd b7       	in	r28, 0x3d	; 61
    8060:	de b7       	in	r29, 0x3e	; 62
    8062:	2c 97       	sbiw	r28, 0x0c	; 12
    8064:	0f b6       	in	r0, 0x3f	; 63
    8066:	f8 94       	cli
    8068:	de bf       	out	0x3e, r29	; 62
    806a:	0f be       	out	0x3f, r0	; 63
    806c:	cd bf       	out	0x3d, r28	; 61
    806e:	5c 01       	movw	r10, r24
	char Format[] = "%0+ li.%. u";
    8070:	be 01       	movw	r22, r28
    8072:	6f 5f       	subi	r22, 0xFF	; 255
    8074:	7f 4f       	sbci	r23, 0xFF	; 255
    8076:	db 01       	movw	r26, r22
    8078:	e0 e0       	ldi	r30, 0x00	; 0
    807a:	f2 e0       	ldi	r31, 0x02	; 2
    807c:	8c e0       	ldi	r24, 0x0C	; 12
    807e:	01 90       	ld	r0, Z+
    8080:	0d 92       	st	X+, r0
    8082:	81 50       	subi	r24, 0x01	; 1
    8084:	e1 f7       	brne	.-8      	; 0x807e <Put_sbVal+0x3c>
	Format[3] = '0'+Param->Size;
    8086:	d5 01       	movw	r26, r10
    8088:	13 96       	adiw	r26, 0x03	; 3
    808a:	2c 91       	ld	r18, X
    808c:	13 97       	sbiw	r26, 0x03	; 3
    808e:	20 5d       	subi	r18, 0xD0	; 208
    8090:	2c 83       	std	Y+4, r18	; 0x04
	if(Param->Prec) {
    8092:	12 96       	adiw	r26, 0x02	; 2
    8094:	9c 91       	ld	r25, X
    8096:	99 23       	and	r25, r25
    8098:	09 f4       	brne	.+2      	; 0x809c <Put_sbVal+0x5a>
    809a:	8d c0       	rjmp	.+282    	; 0x81b6 <Put_sbVal+0x174>
		Format[3] -= Param->Prec+1;
    809c:	89 2f       	mov	r24, r25
    809e:	80 95       	com	r24
    80a0:	82 0f       	add	r24, r18
    80a2:	8c 83       	std	Y+4, r24	; 0x04
		Format[9] = '0'+Param->Prec;
    80a4:	90 5d       	subi	r25, 0xD0	; 208
    80a6:	9a 87       	std	Y+10, r25	; 0x0a
    80a8:	90 53       	subi	r25, 0x30	; 48
		int16_t Div=Pow10(Param->Prec);
    80aa:	49 2f       	mov	r20, r25
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    80ac:	21 e0       	ldi	r18, 0x01	; 1
    80ae:	30 e0       	ldi	r19, 0x00	; 0
		Pow *= 10;
    80b0:	c9 01       	movw	r24, r18
    80b2:	88 0f       	add	r24, r24
    80b4:	99 1f       	adc	r25, r25
    80b6:	22 0f       	add	r18, r18
    80b8:	33 1f       	adc	r19, r19
    80ba:	22 0f       	add	r18, r18
    80bc:	33 1f       	adc	r19, r19
    80be:	22 0f       	add	r18, r18
    80c0:	33 1f       	adc	r19, r19
    80c2:	28 0f       	add	r18, r24
    80c4:	39 1f       	adc	r19, r25
    80c6:	41 50       	subi	r20, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    80c8:	99 f7       	brne	.-26     	; 0x80b0 <Put_sbVal+0x6e>
    80ca:	39 01       	movw	r6, r18
    80cc:	88 24       	eor	r8, r8
    80ce:	77 fc       	sbrc	r7, 7
    80d0:	80 94       	com	r8
    80d2:	98 2c       	mov	r9, r8
		sprintf(Param->Pos, Format, sF_Buf/Div, (uint32_t)labs(sF_Buf)%Div);
    80d4:	10 91 f3 04 	lds	r17, 0x04F3
    80d8:	00 91 f4 04 	lds	r16, 0x04F4
    80dc:	f0 90 f5 04 	lds	r15, 0x04F5
    80e0:	e0 90 f6 04 	lds	r14, 0x04F6
    80e4:	ed b7       	in	r30, 0x3d	; 61
    80e6:	fe b7       	in	r31, 0x3e	; 62
    80e8:	3c 97       	sbiw	r30, 0x0c	; 12
    80ea:	0f b6       	in	r0, 0x3f	; 63
    80ec:	f8 94       	cli
    80ee:	fe bf       	out	0x3e, r31	; 62
    80f0:	0f be       	out	0x3f, r0	; 63
    80f2:	ed bf       	out	0x3d, r30	; 61
    80f4:	cd b6       	in	r12, 0x3d	; 61
    80f6:	de b6       	in	r13, 0x3e	; 62
    80f8:	08 94       	sec
    80fa:	c1 1c       	adc	r12, r1
    80fc:	d1 1c       	adc	r13, r1
    80fe:	d5 01       	movw	r26, r10
    8100:	8d 91       	ld	r24, X+
    8102:	9c 91       	ld	r25, X
    8104:	92 83       	std	Z+2, r25	; 0x02
    8106:	81 83       	std	Z+1, r24	; 0x01
    8108:	f6 01       	movw	r30, r12
    810a:	73 83       	std	Z+3, r23	; 0x03
    810c:	62 83       	std	Z+2, r22	; 0x02
    810e:	61 2f       	mov	r22, r17
    8110:	70 2f       	mov	r23, r16
    8112:	8f 2d       	mov	r24, r15
    8114:	9e 2d       	mov	r25, r14
    8116:	a4 01       	movw	r20, r8
    8118:	93 01       	movw	r18, r6
    811a:	0e 94 54 7e 	call	0xfca8	; 0xfca8 <__divmodsi4>
    811e:	d6 01       	movw	r26, r12
    8120:	14 96       	adiw	r26, 0x04	; 4
    8122:	2d 93       	st	X+, r18
    8124:	3d 93       	st	X+, r19
    8126:	4d 93       	st	X+, r20
    8128:	5c 93       	st	X, r21
    812a:	17 97       	sbiw	r26, 0x07	; 7
    812c:	21 2f       	mov	r18, r17
    812e:	30 2f       	mov	r19, r16
    8130:	4f 2d       	mov	r20, r15
    8132:	5e 2d       	mov	r21, r14
    8134:	c9 01       	movw	r24, r18
    8136:	da 01       	movw	r26, r20
    8138:	bc 01       	movw	r22, r24
    813a:	cd 01       	movw	r24, r26
    813c:	97 fd       	sbrc	r25, 7
    813e:	77 c0       	rjmp	.+238    	; 0x822e <Put_sbVal+0x1ec>
    8140:	a4 01       	movw	r20, r8
    8142:	93 01       	movw	r18, r6
    8144:	0e 94 32 7e 	call	0xfc64	; 0xfc64 <__udivmodsi4>
    8148:	f6 01       	movw	r30, r12
    814a:	60 87       	std	Z+8, r22	; 0x08
    814c:	71 87       	std	Z+9, r23	; 0x09
    814e:	82 87       	std	Z+10, r24	; 0x0a
    8150:	93 87       	std	Z+11, r25	; 0x0b
    8152:	0e 94 76 7b 	call	0xf6ec	; 0xf6ec <sprintf>
		if(sF_Buf<0) {
    8156:	8d b7       	in	r24, 0x3d	; 61
    8158:	9e b7       	in	r25, 0x3e	; 62
    815a:	0c 96       	adiw	r24, 0x0c	; 12
    815c:	0f b6       	in	r0, 0x3f	; 63
    815e:	f8 94       	cli
    8160:	9e bf       	out	0x3e, r25	; 62
    8162:	0f be       	out	0x3f, r0	; 63
    8164:	8d bf       	out	0x3d, r24	; 61
    8166:	80 91 f3 04 	lds	r24, 0x04F3
    816a:	90 91 f4 04 	lds	r25, 0x04F4
    816e:	a0 91 f5 04 	lds	r26, 0x04F5
    8172:	b0 91 f6 04 	lds	r27, 0x04F6
    8176:	b7 fd       	sbrc	r27, 7
    8178:	4a c0       	rjmp	.+148    	; 0x820e <Put_sbVal+0x1cc>
	}
	else {
		Format[6] = '\0';
		sprintf(Param->Pos, Format, sF_Buf);
	}
	if(Minus)
    817a:	80 91 f7 04 	lds	r24, 0x04F7
    817e:	88 23       	and	r24, r24
    8180:	29 f0       	breq	.+10     	; 0x818c <Put_sbVal+0x14a>
		*Param->Pos = '-';
    8182:	d5 01       	movw	r26, r10
    8184:	ed 91       	ld	r30, X+
    8186:	fc 91       	ld	r31, X
    8188:	8d e2       	ldi	r24, 0x2D	; 45
    818a:	80 83       	st	Z, r24
}
    818c:	2c 96       	adiw	r28, 0x0c	; 12
    818e:	0f b6       	in	r0, 0x3f	; 63
    8190:	f8 94       	cli
    8192:	de bf       	out	0x3e, r29	; 62
    8194:	0f be       	out	0x3f, r0	; 63
    8196:	cd bf       	out	0x3d, r28	; 61
    8198:	cf 91       	pop	r28
    819a:	df 91       	pop	r29
    819c:	1f 91       	pop	r17
    819e:	0f 91       	pop	r16
    81a0:	ff 90       	pop	r15
    81a2:	ef 90       	pop	r14
    81a4:	df 90       	pop	r13
    81a6:	cf 90       	pop	r12
    81a8:	bf 90       	pop	r11
    81aa:	af 90       	pop	r10
    81ac:	9f 90       	pop	r9
    81ae:	8f 90       	pop	r8
    81b0:	7f 90       	pop	r7
    81b2:	6f 90       	pop	r6
    81b4:	08 95       	ret
				Param->Pos++;
			*Param->Pos = '-';
		}
	}
	else {
		Format[6] = '\0';
    81b6:	1f 82       	std	Y+7, r1	; 0x07
		sprintf(Param->Pos, Format, sF_Buf);
    81b8:	ed b7       	in	r30, 0x3d	; 61
    81ba:	fe b7       	in	r31, 0x3e	; 62
    81bc:	38 97       	sbiw	r30, 0x08	; 8
    81be:	0f b6       	in	r0, 0x3f	; 63
    81c0:	f8 94       	cli
    81c2:	fe bf       	out	0x3e, r31	; 62
    81c4:	0f be       	out	0x3f, r0	; 63
    81c6:	ed bf       	out	0x3d, r30	; 61
    81c8:	31 96       	adiw	r30, 0x01	; 1
    81ca:	d5 01       	movw	r26, r10
    81cc:	8d 91       	ld	r24, X+
    81ce:	9c 91       	ld	r25, X
    81d0:	ad b7       	in	r26, 0x3d	; 61
    81d2:	be b7       	in	r27, 0x3e	; 62
    81d4:	12 96       	adiw	r26, 0x02	; 2
    81d6:	9c 93       	st	X, r25
    81d8:	8e 93       	st	-X, r24
    81da:	11 97       	sbiw	r26, 0x01	; 1
    81dc:	73 83       	std	Z+3, r23	; 0x03
    81de:	62 83       	std	Z+2, r22	; 0x02
    81e0:	80 91 f3 04 	lds	r24, 0x04F3
    81e4:	90 91 f4 04 	lds	r25, 0x04F4
    81e8:	a0 91 f5 04 	lds	r26, 0x04F5
    81ec:	b0 91 f6 04 	lds	r27, 0x04F6
    81f0:	84 83       	std	Z+4, r24	; 0x04
    81f2:	95 83       	std	Z+5, r25	; 0x05
    81f4:	a6 83       	std	Z+6, r26	; 0x06
    81f6:	b7 83       	std	Z+7, r27	; 0x07
    81f8:	0e 94 76 7b 	call	0xf6ec	; 0xf6ec <sprintf>
    81fc:	ed b7       	in	r30, 0x3d	; 61
    81fe:	fe b7       	in	r31, 0x3e	; 62
    8200:	38 96       	adiw	r30, 0x08	; 8
    8202:	0f b6       	in	r0, 0x3f	; 63
    8204:	f8 94       	cli
    8206:	fe bf       	out	0x3e, r31	; 62
    8208:	0f be       	out	0x3f, r0	; 63
    820a:	ed bf       	out	0x3d, r30	; 61
    820c:	b6 cf       	rjmp	.-148    	; 0x817a <Put_sbVal+0x138>
		Format[3] -= Param->Prec+1;
		Format[9] = '0'+Param->Prec;
		int16_t Div=Pow10(Param->Prec);
		sprintf(Param->Pos, Format, sF_Buf/Div, (uint32_t)labs(sF_Buf)%Div);
		if(sF_Buf<0) {
			while(*Param->Pos==' ')
    820e:	d5 01       	movw	r26, r10
    8210:	ed 91       	ld	r30, X+
    8212:	fc 91       	ld	r31, X
    8214:	80 81       	ld	r24, Z
    8216:	80 32       	cpi	r24, 0x20	; 32
    8218:	39 f4       	brne	.+14     	; 0x8228 <Put_sbVal+0x1e6>
				Param->Pos++;
    821a:	31 96       	adiw	r30, 0x01	; 1
    821c:	d5 01       	movw	r26, r10
    821e:	ed 93       	st	X+, r30
    8220:	fc 93       	st	X, r31
		Format[3] -= Param->Prec+1;
		Format[9] = '0'+Param->Prec;
		int16_t Div=Pow10(Param->Prec);
		sprintf(Param->Pos, Format, sF_Buf/Div, (uint32_t)labs(sF_Buf)%Div);
		if(sF_Buf<0) {
			while(*Param->Pos==' ')
    8222:	80 81       	ld	r24, Z
    8224:	80 32       	cpi	r24, 0x20	; 32
    8226:	c9 f3       	breq	.-14     	; 0x821a <Put_sbVal+0x1d8>
				Param->Pos++;
			*Param->Pos = '-';
    8228:	8d e2       	ldi	r24, 0x2D	; 45
    822a:	80 83       	st	Z, r24
    822c:	a6 cf       	rjmp	.-180    	; 0x817a <Put_sbVal+0x138>
	Format[3] = '0'+Param->Size;
	if(Param->Prec) {
		Format[3] -= Param->Prec+1;
		Format[9] = '0'+Param->Prec;
		int16_t Div=Pow10(Param->Prec);
		sprintf(Param->Pos, Format, sF_Buf/Div, (uint32_t)labs(sF_Buf)%Div);
    822e:	90 95       	com	r25
    8230:	80 95       	com	r24
    8232:	70 95       	com	r23
    8234:	61 95       	neg	r22
    8236:	7f 4f       	sbci	r23, 0xFF	; 255
    8238:	8f 4f       	sbci	r24, 0xFF	; 255
    823a:	9f 4f       	sbci	r25, 0xFF	; 255
    823c:	81 cf       	rjmp	.-254    	; 0x8140 <Put_sbVal+0xfe>

0000823e <Put_bVal>:
}

// ~~~~~~~~~~~~~~~~~~~~~
void
Put_bVal(T_Param *Param)
{
    823e:	6f 92       	push	r6
    8240:	7f 92       	push	r7
    8242:	8f 92       	push	r8
    8244:	9f 92       	push	r9
    8246:	af 92       	push	r10
    8248:	bf 92       	push	r11
    824a:	cf 92       	push	r12
    824c:	df 92       	push	r13
    824e:	ef 92       	push	r14
    8250:	ff 92       	push	r15
    8252:	0f 93       	push	r16
    8254:	1f 93       	push	r17
    8256:	df 93       	push	r29
    8258:	cf 93       	push	r28
    825a:	cd b7       	in	r28, 0x3d	; 61
    825c:	de b7       	in	r29, 0x3e	; 62
    825e:	2b 97       	sbiw	r28, 0x0b	; 11
    8260:	0f b6       	in	r0, 0x3f	; 63
    8262:	f8 94       	cli
    8264:	de bf       	out	0x3e, r29	; 62
    8266:	0f be       	out	0x3f, r0	; 63
    8268:	cd bf       	out	0x3d, r28	; 61
    826a:	bc 01       	movw	r22, r24
	char Format[] = "%0 li.%. u";
    826c:	3e 01       	movw	r6, r28
    826e:	08 94       	sec
    8270:	61 1c       	adc	r6, r1
    8272:	71 1c       	adc	r7, r1
    8274:	d3 01       	movw	r26, r6
    8276:	ec e0       	ldi	r30, 0x0C	; 12
    8278:	f2 e0       	ldi	r31, 0x02	; 2
    827a:	8b e0       	ldi	r24, 0x0B	; 11
    827c:	01 90       	ld	r0, Z+
    827e:	0d 92       	st	X+, r0
    8280:	81 50       	subi	r24, 0x01	; 1
    8282:	e1 f7       	brne	.-8      	; 0x827c <Put_bVal+0x3e>
	Format[2] = '0'+Param->Size;
    8284:	db 01       	movw	r26, r22
    8286:	13 96       	adiw	r26, 0x03	; 3
    8288:	2c 91       	ld	r18, X
    828a:	13 97       	sbiw	r26, 0x03	; 3
    828c:	20 5d       	subi	r18, 0xD0	; 208
    828e:	2b 83       	std	Y+3, r18	; 0x03
	if(Param->Prec) {
    8290:	12 96       	adiw	r26, 0x02	; 2
    8292:	9c 91       	ld	r25, X
    8294:	99 23       	and	r25, r25
    8296:	09 f4       	brne	.+2      	; 0x829a <Put_bVal+0x5c>
    8298:	6d c0       	rjmp	.+218    	; 0x8374 <Put_bVal+0x136>
		Format[2] -= Param->Prec+1;
    829a:	89 2f       	mov	r24, r25
    829c:	80 95       	com	r24
    829e:	82 0f       	add	r24, r18
    82a0:	8b 83       	std	Y+3, r24	; 0x03
		Format[8] = '0'+Param->Prec;
    82a2:	90 5d       	subi	r25, 0xD0	; 208
    82a4:	99 87       	std	Y+9, r25	; 0x09
    82a6:	90 53       	subi	r25, 0x30	; 48
		uint16_t Div=Pow10(Param->Prec);
    82a8:	49 2f       	mov	r20, r25
    82aa:	21 e0       	ldi	r18, 0x01	; 1
    82ac:	30 e0       	ldi	r19, 0x00	; 0
		Pow *= 10;
    82ae:	c9 01       	movw	r24, r18
    82b0:	88 0f       	add	r24, r24
    82b2:	99 1f       	adc	r25, r25
    82b4:	22 0f       	add	r18, r18
    82b6:	33 1f       	adc	r19, r19
    82b8:	22 0f       	add	r18, r18
    82ba:	33 1f       	adc	r19, r19
    82bc:	22 0f       	add	r18, r18
    82be:	33 1f       	adc	r19, r19
    82c0:	28 0f       	add	r18, r24
    82c2:	39 1f       	adc	r19, r25
    82c4:	41 50       	subi	r20, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    82c6:	99 f7       	brne	.-26     	; 0x82ae <Put_bVal+0x70>
    82c8:	49 01       	movw	r8, r18
    82ca:	aa 24       	eor	r10, r10
    82cc:	bb 24       	eor	r11, r11
		sprintf(Param->Pos, Format, F_Buf/Div, F_Buf%Div);
    82ce:	c0 90 ef 04 	lds	r12, 0x04EF
    82d2:	d0 90 f0 04 	lds	r13, 0x04F0
    82d6:	e0 90 f1 04 	lds	r14, 0x04F1
    82da:	f0 90 f2 04 	lds	r15, 0x04F2
    82de:	ed b7       	in	r30, 0x3d	; 61
    82e0:	fe b7       	in	r31, 0x3e	; 62
    82e2:	3c 97       	sbiw	r30, 0x0c	; 12
    82e4:	0f b6       	in	r0, 0x3f	; 63
    82e6:	f8 94       	cli
    82e8:	fe bf       	out	0x3e, r31	; 62
    82ea:	0f be       	out	0x3f, r0	; 63
    82ec:	ed bf       	out	0x3d, r30	; 61
    82ee:	0d b7       	in	r16, 0x3d	; 61
    82f0:	1e b7       	in	r17, 0x3e	; 62
    82f2:	0f 5f       	subi	r16, 0xFF	; 255
    82f4:	1f 4f       	sbci	r17, 0xFF	; 255
    82f6:	db 01       	movw	r26, r22
    82f8:	8d 91       	ld	r24, X+
    82fa:	9c 91       	ld	r25, X
    82fc:	92 83       	std	Z+2, r25	; 0x02
    82fe:	81 83       	std	Z+1, r24	; 0x01
    8300:	f8 01       	movw	r30, r16
    8302:	73 82       	std	Z+3, r7	; 0x03
    8304:	62 82       	std	Z+2, r6	; 0x02
    8306:	c7 01       	movw	r24, r14
    8308:	b6 01       	movw	r22, r12
    830a:	a5 01       	movw	r20, r10
    830c:	94 01       	movw	r18, r8
    830e:	0e 94 32 7e 	call	0xfc64	; 0xfc64 <__udivmodsi4>
    8312:	d8 01       	movw	r26, r16
    8314:	14 96       	adiw	r26, 0x04	; 4
    8316:	2d 93       	st	X+, r18
    8318:	3d 93       	st	X+, r19
    831a:	4d 93       	st	X+, r20
    831c:	5c 93       	st	X, r21
    831e:	17 97       	sbiw	r26, 0x07	; 7
    8320:	c7 01       	movw	r24, r14
    8322:	b6 01       	movw	r22, r12
    8324:	a5 01       	movw	r20, r10
    8326:	94 01       	movw	r18, r8
    8328:	0e 94 32 7e 	call	0xfc64	; 0xfc64 <__udivmodsi4>
    832c:	f8 01       	movw	r30, r16
    832e:	60 87       	std	Z+8, r22	; 0x08
    8330:	71 87       	std	Z+9, r23	; 0x09
    8332:	82 87       	std	Z+10, r24	; 0x0a
    8334:	93 87       	std	Z+11, r25	; 0x0b
    8336:	0e 94 76 7b 	call	0xf6ec	; 0xf6ec <sprintf>
    833a:	8d b7       	in	r24, 0x3d	; 61
    833c:	9e b7       	in	r25, 0x3e	; 62
    833e:	0c 96       	adiw	r24, 0x0c	; 12
    8340:	0f b6       	in	r0, 0x3f	; 63
    8342:	f8 94       	cli
    8344:	9e bf       	out	0x3e, r25	; 62
    8346:	0f be       	out	0x3f, r0	; 63
    8348:	8d bf       	out	0x3d, r24	; 61
	}
	else{
		Format[5] = '\0';
		sprintf(Param->Pos, Format, F_Buf);
	}
}
    834a:	2b 96       	adiw	r28, 0x0b	; 11
    834c:	0f b6       	in	r0, 0x3f	; 63
    834e:	f8 94       	cli
    8350:	de bf       	out	0x3e, r29	; 62
    8352:	0f be       	out	0x3f, r0	; 63
    8354:	cd bf       	out	0x3d, r28	; 61
    8356:	cf 91       	pop	r28
    8358:	df 91       	pop	r29
    835a:	1f 91       	pop	r17
    835c:	0f 91       	pop	r16
    835e:	ff 90       	pop	r15
    8360:	ef 90       	pop	r14
    8362:	df 90       	pop	r13
    8364:	cf 90       	pop	r12
    8366:	bf 90       	pop	r11
    8368:	af 90       	pop	r10
    836a:	9f 90       	pop	r9
    836c:	8f 90       	pop	r8
    836e:	7f 90       	pop	r7
    8370:	6f 90       	pop	r6
    8372:	08 95       	ret
		Format[8] = '0'+Param->Prec;
		uint16_t Div=Pow10(Param->Prec);
		sprintf(Param->Pos, Format, F_Buf/Div, F_Buf%Div);
	}
	else{
		Format[5] = '\0';
    8374:	1e 82       	std	Y+6, r1	; 0x06
		sprintf(Param->Pos, Format, F_Buf);
    8376:	ad b7       	in	r26, 0x3d	; 61
    8378:	be b7       	in	r27, 0x3e	; 62
    837a:	18 97       	sbiw	r26, 0x08	; 8
    837c:	0f b6       	in	r0, 0x3f	; 63
    837e:	f8 94       	cli
    8380:	be bf       	out	0x3e, r27	; 62
    8382:	0f be       	out	0x3f, r0	; 63
    8384:	ad bf       	out	0x3d, r26	; 61
    8386:	ed b7       	in	r30, 0x3d	; 61
    8388:	fe b7       	in	r31, 0x3e	; 62
    838a:	31 96       	adiw	r30, 0x01	; 1
    838c:	db 01       	movw	r26, r22
    838e:	8d 91       	ld	r24, X+
    8390:	9c 91       	ld	r25, X
    8392:	ad b7       	in	r26, 0x3d	; 61
    8394:	be b7       	in	r27, 0x3e	; 62
    8396:	12 96       	adiw	r26, 0x02	; 2
    8398:	9c 93       	st	X, r25
    839a:	8e 93       	st	-X, r24
    839c:	11 97       	sbiw	r26, 0x01	; 1
    839e:	73 82       	std	Z+3, r7	; 0x03
    83a0:	62 82       	std	Z+2, r6	; 0x02
    83a2:	80 91 ef 04 	lds	r24, 0x04EF
    83a6:	90 91 f0 04 	lds	r25, 0x04F0
    83aa:	a0 91 f1 04 	lds	r26, 0x04F1
    83ae:	b0 91 f2 04 	lds	r27, 0x04F2
    83b2:	84 83       	std	Z+4, r24	; 0x04
    83b4:	95 83       	std	Z+5, r25	; 0x05
    83b6:	a6 83       	std	Z+6, r26	; 0x06
    83b8:	b7 83       	std	Z+7, r27	; 0x07
    83ba:	0e 94 76 7b 	call	0xf6ec	; 0xf6ec <sprintf>
    83be:	ed b7       	in	r30, 0x3d	; 61
    83c0:	fe b7       	in	r31, 0x3e	; 62
    83c2:	38 96       	adiw	r30, 0x08	; 8
    83c4:	0f b6       	in	r0, 0x3f	; 63
    83c6:	f8 94       	cli
    83c8:	fe bf       	out	0x3e, r31	; 62
    83ca:	0f be       	out	0x3f, r0	; 63
    83cc:	ed bf       	out	0x3d, r30	; 61
    83ce:	bd cf       	rjmp	.-134    	; 0x834a <Put_bVal+0x10c>

000083d0 <Put_TextValAlignLeft>:
	char Format[8];
	//char Format[8] = "%10.10s";
	sprintf(Format,"%%%u.%us", Param->Size, Param->Size);
	sprintf(Param->Pos, Format, Val);
}
void Put_TextValAlignLeft(char* Val, T_Param *Param){
    83d0:	cf 92       	push	r12
    83d2:	df 92       	push	r13
    83d4:	ef 92       	push	r14
    83d6:	ff 92       	push	r15
    83d8:	0f 93       	push	r16
    83da:	1f 93       	push	r17
    83dc:	df 93       	push	r29
    83de:	cf 93       	push	r28
    83e0:	cd b7       	in	r28, 0x3d	; 61
    83e2:	de b7       	in	r29, 0x3e	; 62
    83e4:	29 97       	sbiw	r28, 0x09	; 9
    83e6:	0f b6       	in	r0, 0x3f	; 63
    83e8:	f8 94       	cli
    83ea:	de bf       	out	0x3e, r29	; 62
    83ec:	0f be       	out	0x3f, r0	; 63
    83ee:	cd bf       	out	0x3d, r28	; 61
    83f0:	6c 01       	movw	r12, r24
    83f2:	7b 01       	movw	r14, r22
	char Format[9];
	//char Format[8] = "%10.10s";
	sprintf(Format,"%%-%u.%us", Param->Size, Param->Size);
    83f4:	db 01       	movw	r26, r22
    83f6:	13 96       	adiw	r26, 0x03	; 3
    83f8:	2c 91       	ld	r18, X
    83fa:	ed b7       	in	r30, 0x3d	; 61
    83fc:	fe b7       	in	r31, 0x3e	; 62
    83fe:	38 97       	sbiw	r30, 0x08	; 8
    8400:	0f b6       	in	r0, 0x3f	; 63
    8402:	f8 94       	cli
    8404:	fe bf       	out	0x3e, r31	; 62
    8406:	0f be       	out	0x3f, r0	; 63
    8408:	ed bf       	out	0x3d, r30	; 61
    840a:	31 96       	adiw	r30, 0x01	; 1
    840c:	8e 01       	movw	r16, r28
    840e:	0f 5f       	subi	r16, 0xFF	; 255
    8410:	1f 4f       	sbci	r17, 0xFF	; 255
    8412:	ad b7       	in	r26, 0x3d	; 61
    8414:	be b7       	in	r27, 0x3e	; 62
    8416:	12 96       	adiw	r26, 0x02	; 2
    8418:	1c 93       	st	X, r17
    841a:	0e 93       	st	-X, r16
    841c:	11 97       	sbiw	r26, 0x01	; 1
    841e:	87 e1       	ldi	r24, 0x17	; 23
    8420:	92 e0       	ldi	r25, 0x02	; 2
    8422:	93 83       	std	Z+3, r25	; 0x03
    8424:	82 83       	std	Z+2, r24	; 0x02
    8426:	24 83       	std	Z+4, r18	; 0x04
    8428:	15 82       	std	Z+5, r1	; 0x05
    842a:	26 83       	std	Z+6, r18	; 0x06
    842c:	17 82       	std	Z+7, r1	; 0x07
    842e:	0e 94 76 7b 	call	0xf6ec	; 0xf6ec <sprintf>
	sprintf(Param->Pos, Format, Val);
    8432:	0f 90       	pop	r0
    8434:	0f 90       	pop	r0
    8436:	ed b7       	in	r30, 0x3d	; 61
    8438:	fe b7       	in	r31, 0x3e	; 62
    843a:	31 96       	adiw	r30, 0x01	; 1
    843c:	d7 01       	movw	r26, r14
    843e:	8d 91       	ld	r24, X+
    8440:	9c 91       	ld	r25, X
    8442:	ad b7       	in	r26, 0x3d	; 61
    8444:	be b7       	in	r27, 0x3e	; 62
    8446:	12 96       	adiw	r26, 0x02	; 2
    8448:	9c 93       	st	X, r25
    844a:	8e 93       	st	-X, r24
    844c:	11 97       	sbiw	r26, 0x01	; 1
    844e:	13 83       	std	Z+3, r17	; 0x03
    8450:	02 83       	std	Z+2, r16	; 0x02
    8452:	d5 82       	std	Z+5, r13	; 0x05
    8454:	c4 82       	std	Z+4, r12	; 0x04
    8456:	0e 94 76 7b 	call	0xf6ec	; 0xf6ec <sprintf>
    845a:	ed b7       	in	r30, 0x3d	; 61
    845c:	fe b7       	in	r31, 0x3e	; 62
    845e:	36 96       	adiw	r30, 0x06	; 6
    8460:	0f b6       	in	r0, 0x3f	; 63
    8462:	f8 94       	cli
    8464:	fe bf       	out	0x3e, r31	; 62
    8466:	0f be       	out	0x3f, r0	; 63
    8468:	ed bf       	out	0x3d, r30	; 61
}
    846a:	29 96       	adiw	r28, 0x09	; 9
    846c:	0f b6       	in	r0, 0x3f	; 63
    846e:	f8 94       	cli
    8470:	de bf       	out	0x3e, r29	; 62
    8472:	0f be       	out	0x3f, r0	; 63
    8474:	cd bf       	out	0x3d, r28	; 61
    8476:	cf 91       	pop	r28
    8478:	df 91       	pop	r29
    847a:	1f 91       	pop	r17
    847c:	0f 91       	pop	r16
    847e:	ff 90       	pop	r15
    8480:	ef 90       	pop	r14
    8482:	df 90       	pop	r13
    8484:	cf 90       	pop	r12
    8486:	08 95       	ret

00008488 <Put_TextValAlignRight>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Put_TextVal -  
// if, for example, Filed width =12 -> sprintf(Param->Pos,"%12.12s",Val)
// min and max width = Param->Size and align right
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void Put_TextValAlignRight(char* Val, T_Param *Param){
    8488:	cf 92       	push	r12
    848a:	df 92       	push	r13
    848c:	ef 92       	push	r14
    848e:	ff 92       	push	r15
    8490:	0f 93       	push	r16
    8492:	1f 93       	push	r17
    8494:	df 93       	push	r29
    8496:	cf 93       	push	r28
    8498:	cd b7       	in	r28, 0x3d	; 61
    849a:	de b7       	in	r29, 0x3e	; 62
    849c:	28 97       	sbiw	r28, 0x08	; 8
    849e:	0f b6       	in	r0, 0x3f	; 63
    84a0:	f8 94       	cli
    84a2:	de bf       	out	0x3e, r29	; 62
    84a4:	0f be       	out	0x3f, r0	; 63
    84a6:	cd bf       	out	0x3d, r28	; 61
    84a8:	6c 01       	movw	r12, r24
    84aa:	7b 01       	movw	r14, r22
	char Format[8];
	//char Format[8] = "%10.10s";
	sprintf(Format,"%%%u.%us", Param->Size, Param->Size);
    84ac:	db 01       	movw	r26, r22
    84ae:	13 96       	adiw	r26, 0x03	; 3
    84b0:	2c 91       	ld	r18, X
    84b2:	ed b7       	in	r30, 0x3d	; 61
    84b4:	fe b7       	in	r31, 0x3e	; 62
    84b6:	38 97       	sbiw	r30, 0x08	; 8
    84b8:	0f b6       	in	r0, 0x3f	; 63
    84ba:	f8 94       	cli
    84bc:	fe bf       	out	0x3e, r31	; 62
    84be:	0f be       	out	0x3f, r0	; 63
    84c0:	ed bf       	out	0x3d, r30	; 61
    84c2:	31 96       	adiw	r30, 0x01	; 1
    84c4:	8e 01       	movw	r16, r28
    84c6:	0f 5f       	subi	r16, 0xFF	; 255
    84c8:	1f 4f       	sbci	r17, 0xFF	; 255
    84ca:	ad b7       	in	r26, 0x3d	; 61
    84cc:	be b7       	in	r27, 0x3e	; 62
    84ce:	12 96       	adiw	r26, 0x02	; 2
    84d0:	1c 93       	st	X, r17
    84d2:	0e 93       	st	-X, r16
    84d4:	11 97       	sbiw	r26, 0x01	; 1
    84d6:	81 e2       	ldi	r24, 0x21	; 33
    84d8:	92 e0       	ldi	r25, 0x02	; 2
    84da:	93 83       	std	Z+3, r25	; 0x03
    84dc:	82 83       	std	Z+2, r24	; 0x02
    84de:	24 83       	std	Z+4, r18	; 0x04
    84e0:	15 82       	std	Z+5, r1	; 0x05
    84e2:	26 83       	std	Z+6, r18	; 0x06
    84e4:	17 82       	std	Z+7, r1	; 0x07
    84e6:	0e 94 76 7b 	call	0xf6ec	; 0xf6ec <sprintf>
	sprintf(Param->Pos, Format, Val);
    84ea:	0f 90       	pop	r0
    84ec:	0f 90       	pop	r0
    84ee:	ed b7       	in	r30, 0x3d	; 61
    84f0:	fe b7       	in	r31, 0x3e	; 62
    84f2:	31 96       	adiw	r30, 0x01	; 1
    84f4:	d7 01       	movw	r26, r14
    84f6:	8d 91       	ld	r24, X+
    84f8:	9c 91       	ld	r25, X
    84fa:	ad b7       	in	r26, 0x3d	; 61
    84fc:	be b7       	in	r27, 0x3e	; 62
    84fe:	12 96       	adiw	r26, 0x02	; 2
    8500:	9c 93       	st	X, r25
    8502:	8e 93       	st	-X, r24
    8504:	11 97       	sbiw	r26, 0x01	; 1
    8506:	13 83       	std	Z+3, r17	; 0x03
    8508:	02 83       	std	Z+2, r16	; 0x02
    850a:	d5 82       	std	Z+5, r13	; 0x05
    850c:	c4 82       	std	Z+4, r12	; 0x04
    850e:	0e 94 76 7b 	call	0xf6ec	; 0xf6ec <sprintf>
    8512:	ed b7       	in	r30, 0x3d	; 61
    8514:	fe b7       	in	r31, 0x3e	; 62
    8516:	36 96       	adiw	r30, 0x06	; 6
    8518:	0f b6       	in	r0, 0x3f	; 63
    851a:	f8 94       	cli
    851c:	fe bf       	out	0x3e, r31	; 62
    851e:	0f be       	out	0x3f, r0	; 63
    8520:	ed bf       	out	0x3d, r30	; 61
}
    8522:	28 96       	adiw	r28, 0x08	; 8
    8524:	0f b6       	in	r0, 0x3f	; 63
    8526:	f8 94       	cli
    8528:	de bf       	out	0x3e, r29	; 62
    852a:	0f be       	out	0x3f, r0	; 63
    852c:	cd bf       	out	0x3d, r28	; 61
    852e:	cf 91       	pop	r28
    8530:	df 91       	pop	r29
    8532:	1f 91       	pop	r17
    8534:	0f 91       	pop	r16
    8536:	ff 90       	pop	r15
    8538:	ef 90       	pop	r14
    853a:	df 90       	pop	r13
    853c:	cf 90       	pop	r12
    853e:	08 95       	ret

00008540 <Put_GFVal>:
// Trailing zeros are removed from the fractional part of the result; 
// a decimal point appears only if it is followed by at least one digit.
// Max presicion - 8digits Why???
// Therefore Max Field size - 9
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void Put_GFVal(float Val, T_Param *Param){
    8540:	ef 92       	push	r14
    8542:	ff 92       	push	r15
    8544:	0f 93       	push	r16
    8546:	1f 93       	push	r17
    8548:	df 93       	push	r29
    854a:	cf 93       	push	r28
    854c:	cd b7       	in	r28, 0x3d	; 61
    854e:	de b7       	in	r29, 0x3e	; 62
    8550:	2f 97       	sbiw	r28, 0x0f	; 15
    8552:	0f b6       	in	r0, 0x3f	; 63
    8554:	f8 94       	cli
    8556:	de bf       	out	0x3e, r29	; 62
    8558:	0f be       	out	0x3f, r0	; 63
    855a:	cd bf       	out	0x3d, r28	; 61
    855c:	7b 01       	movw	r14, r22
    855e:	8c 01       	movw	r16, r24
    8560:	9a 01       	movw	r18, r20
	if(Param->Size < 10){
    8562:	da 01       	movw	r26, r20
    8564:	13 96       	adiw	r26, 0x03	; 3
    8566:	8c 91       	ld	r24, X
    8568:	8a 30       	cpi	r24, 0x0A	; 10
    856a:	08 f4       	brcc	.+2      	; 0x856e <Put_GFVal+0x2e>
    856c:	44 c0       	rjmp	.+136    	; 0x85f6 <Put_GFVal+0xb6>
		Format[2] = '0'+Param->Size;
		Format[4] = '0'+Param->Prec;
		sprintf(Param->Pos, Format, Val);
	}
	else{
		char Format[] = "%+1 . g";
    856e:	ae 01       	movw	r20, r28
    8570:	48 5f       	subi	r20, 0xF8	; 248
    8572:	5f 4f       	sbci	r21, 0xFF	; 255
    8574:	da 01       	movw	r26, r20
    8576:	ea e2       	ldi	r30, 0x2A	; 42
    8578:	f2 e0       	ldi	r31, 0x02	; 2
    857a:	88 e0       	ldi	r24, 0x08	; 8
    857c:	01 90       	ld	r0, Z+
    857e:	0d 92       	st	X+, r0
    8580:	81 50       	subi	r24, 0x01	; 1
    8582:	e1 f7       	brne	.-8      	; 0x857c <Put_GFVal+0x3c>
		Format[3] = '0'+Param->Size-10;	
    8584:	d9 01       	movw	r26, r18
    8586:	13 96       	adiw	r26, 0x03	; 3
    8588:	8c 91       	ld	r24, X
    858a:	13 97       	sbiw	r26, 0x03	; 3
    858c:	8a 5d       	subi	r24, 0xDA	; 218
    858e:	8b 87       	std	Y+11, r24	; 0x0b
		Format[5] = '0'+Param->Prec;
    8590:	12 96       	adiw	r26, 0x02	; 2
    8592:	8c 91       	ld	r24, X
    8594:	12 97       	sbiw	r26, 0x02	; 2
    8596:	80 5d       	subi	r24, 0xD0	; 208
    8598:	8d 87       	std	Y+13, r24	; 0x0d
		sprintf(Param->Pos, Format, Val);
    859a:	ed b7       	in	r30, 0x3d	; 61
    859c:	fe b7       	in	r31, 0x3e	; 62
    859e:	38 97       	sbiw	r30, 0x08	; 8
    85a0:	0f b6       	in	r0, 0x3f	; 63
    85a2:	f8 94       	cli
    85a4:	fe bf       	out	0x3e, r31	; 62
    85a6:	0f be       	out	0x3f, r0	; 63
    85a8:	ed bf       	out	0x3d, r30	; 61
    85aa:	31 96       	adiw	r30, 0x01	; 1
    85ac:	8d 91       	ld	r24, X+
    85ae:	9c 91       	ld	r25, X
    85b0:	ad b7       	in	r26, 0x3d	; 61
    85b2:	be b7       	in	r27, 0x3e	; 62
    85b4:	12 96       	adiw	r26, 0x02	; 2
    85b6:	9c 93       	st	X, r25
    85b8:	8e 93       	st	-X, r24
    85ba:	11 97       	sbiw	r26, 0x01	; 1
    85bc:	53 83       	std	Z+3, r21	; 0x03
    85be:	42 83       	std	Z+2, r20	; 0x02
    85c0:	e4 82       	std	Z+4, r14	; 0x04
    85c2:	f5 82       	std	Z+5, r15	; 0x05
    85c4:	06 83       	std	Z+6, r16	; 0x06
    85c6:	17 83       	std	Z+7, r17	; 0x07
    85c8:	0e 94 76 7b 	call	0xf6ec	; 0xf6ec <sprintf>
    85cc:	ed b7       	in	r30, 0x3d	; 61
    85ce:	fe b7       	in	r31, 0x3e	; 62
    85d0:	38 96       	adiw	r30, 0x08	; 8
    85d2:	0f b6       	in	r0, 0x3f	; 63
    85d4:	f8 94       	cli
    85d6:	fe bf       	out	0x3e, r31	; 62
    85d8:	0f be       	out	0x3f, r0	; 63
    85da:	ed bf       	out	0x3d, r30	; 61
	}
}
    85dc:	2f 96       	adiw	r28, 0x0f	; 15
    85de:	0f b6       	in	r0, 0x3f	; 63
    85e0:	f8 94       	cli
    85e2:	de bf       	out	0x3e, r29	; 62
    85e4:	0f be       	out	0x3f, r0	; 63
    85e6:	cd bf       	out	0x3d, r28	; 61
    85e8:	cf 91       	pop	r28
    85ea:	df 91       	pop	r29
    85ec:	1f 91       	pop	r17
    85ee:	0f 91       	pop	r16
    85f0:	ff 90       	pop	r15
    85f2:	ef 90       	pop	r14
    85f4:	08 95       	ret
// Max presicion - 8digits Why???
// Therefore Max Field size - 9
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void Put_GFVal(float Val, T_Param *Param){
	if(Param->Size < 10){
		char Format[] = "%+ . g";
    85f6:	ae 01       	movw	r20, r28
    85f8:	4f 5f       	subi	r20, 0xFF	; 255
    85fa:	5f 4f       	sbci	r21, 0xFF	; 255
    85fc:	da 01       	movw	r26, r20
    85fe:	e2 e3       	ldi	r30, 0x32	; 50
    8600:	f2 e0       	ldi	r31, 0x02	; 2
    8602:	87 e0       	ldi	r24, 0x07	; 7
    8604:	01 90       	ld	r0, Z+
    8606:	0d 92       	st	X+, r0
    8608:	81 50       	subi	r24, 0x01	; 1
    860a:	e1 f7       	brne	.-8      	; 0x8604 <Put_GFVal+0xc4>
		Format[2] = '0'+Param->Size;
    860c:	f9 01       	movw	r30, r18
    860e:	83 81       	ldd	r24, Z+3	; 0x03
    8610:	80 5d       	subi	r24, 0xD0	; 208
    8612:	8b 83       	std	Y+3, r24	; 0x03
		Format[4] = '0'+Param->Prec;
    8614:	82 81       	ldd	r24, Z+2	; 0x02
    8616:	80 5d       	subi	r24, 0xD0	; 208
    8618:	8d 83       	std	Y+5, r24	; 0x05
		sprintf(Param->Pos, Format, Val);
    861a:	8d b7       	in	r24, 0x3d	; 61
    861c:	9e b7       	in	r25, 0x3e	; 62
    861e:	08 97       	sbiw	r24, 0x08	; 8
    8620:	0f b6       	in	r0, 0x3f	; 63
    8622:	f8 94       	cli
    8624:	9e bf       	out	0x3e, r25	; 62
    8626:	0f be       	out	0x3f, r0	; 63
    8628:	8d bf       	out	0x3d, r24	; 61
    862a:	ed b7       	in	r30, 0x3d	; 61
    862c:	fe b7       	in	r31, 0x3e	; 62
    862e:	31 96       	adiw	r30, 0x01	; 1
    8630:	d9 01       	movw	r26, r18
    8632:	bc cf       	rjmp	.-136    	; 0x85ac <Put_GFVal+0x6c>

00008634 <Put_FFVal>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Put_FVal -  The double argument is rounded and converted to decimal notation in the format "[-]ddd.ddd"
// Max presicion - 8digits Why???
// Therefore Max Field size - 9
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void Put_FFVal(float Val, T_Param *Param){
    8634:	ef 92       	push	r14
    8636:	ff 92       	push	r15
    8638:	0f 93       	push	r16
    863a:	1f 93       	push	r17
    863c:	df 93       	push	r29
    863e:	cf 93       	push	r28
    8640:	cd b7       	in	r28, 0x3d	; 61
    8642:	de b7       	in	r29, 0x3e	; 62
    8644:	27 97       	sbiw	r28, 0x07	; 7
    8646:	0f b6       	in	r0, 0x3f	; 63
    8648:	f8 94       	cli
    864a:	de bf       	out	0x3e, r29	; 62
    864c:	0f be       	out	0x3f, r0	; 63
    864e:	cd bf       	out	0x3d, r28	; 61
    8650:	7b 01       	movw	r14, r22
    8652:	8c 01       	movw	r16, r24
    8654:	9a 01       	movw	r18, r20
	char Format[] = "%+ . f";
    8656:	ae 01       	movw	r20, r28
    8658:	4f 5f       	subi	r20, 0xFF	; 255
    865a:	5f 4f       	sbci	r21, 0xFF	; 255
    865c:	da 01       	movw	r26, r20
    865e:	e9 e3       	ldi	r30, 0x39	; 57
    8660:	f2 e0       	ldi	r31, 0x02	; 2
    8662:	87 e0       	ldi	r24, 0x07	; 7
    8664:	01 90       	ld	r0, Z+
    8666:	0d 92       	st	X+, r0
    8668:	81 50       	subi	r24, 0x01	; 1
    866a:	e1 f7       	brne	.-8      	; 0x8664 <Put_FFVal+0x30>
	Format[2] = '0'+Param->Size;
    866c:	d9 01       	movw	r26, r18
    866e:	13 96       	adiw	r26, 0x03	; 3
    8670:	8c 91       	ld	r24, X
    8672:	13 97       	sbiw	r26, 0x03	; 3
    8674:	80 5d       	subi	r24, 0xD0	; 208
    8676:	8b 83       	std	Y+3, r24	; 0x03
	Format[4] = '0'+Param->Prec;	
    8678:	12 96       	adiw	r26, 0x02	; 2
    867a:	8c 91       	ld	r24, X
    867c:	12 97       	sbiw	r26, 0x02	; 2
    867e:	80 5d       	subi	r24, 0xD0	; 208
    8680:	8d 83       	std	Y+5, r24	; 0x05
	sprintf(Param->Pos, Format, Val);
    8682:	ed b7       	in	r30, 0x3d	; 61
    8684:	fe b7       	in	r31, 0x3e	; 62
    8686:	38 97       	sbiw	r30, 0x08	; 8
    8688:	0f b6       	in	r0, 0x3f	; 63
    868a:	f8 94       	cli
    868c:	fe bf       	out	0x3e, r31	; 62
    868e:	0f be       	out	0x3f, r0	; 63
    8690:	ed bf       	out	0x3d, r30	; 61
    8692:	31 96       	adiw	r30, 0x01	; 1
    8694:	8d 91       	ld	r24, X+
    8696:	9c 91       	ld	r25, X
    8698:	ad b7       	in	r26, 0x3d	; 61
    869a:	be b7       	in	r27, 0x3e	; 62
    869c:	12 96       	adiw	r26, 0x02	; 2
    869e:	9c 93       	st	X, r25
    86a0:	8e 93       	st	-X, r24
    86a2:	11 97       	sbiw	r26, 0x01	; 1
    86a4:	53 83       	std	Z+3, r21	; 0x03
    86a6:	42 83       	std	Z+2, r20	; 0x02
    86a8:	e4 82       	std	Z+4, r14	; 0x04
    86aa:	f5 82       	std	Z+5, r15	; 0x05
    86ac:	06 83       	std	Z+6, r16	; 0x06
    86ae:	17 83       	std	Z+7, r17	; 0x07
    86b0:	0e 94 76 7b 	call	0xf6ec	; 0xf6ec <sprintf>
    86b4:	ed b7       	in	r30, 0x3d	; 61
    86b6:	fe b7       	in	r31, 0x3e	; 62
    86b8:	38 96       	adiw	r30, 0x08	; 8
    86ba:	0f b6       	in	r0, 0x3f	; 63
    86bc:	f8 94       	cli
    86be:	fe bf       	out	0x3e, r31	; 62
    86c0:	0f be       	out	0x3f, r0	; 63
    86c2:	ed bf       	out	0x3d, r30	; 61
}
    86c4:	27 96       	adiw	r28, 0x07	; 7
    86c6:	0f b6       	in	r0, 0x3f	; 63
    86c8:	f8 94       	cli
    86ca:	de bf       	out	0x3e, r29	; 62
    86cc:	0f be       	out	0x3f, r0	; 63
    86ce:	cd bf       	out	0x3d, r28	; 61
    86d0:	cf 91       	pop	r28
    86d2:	df 91       	pop	r29
    86d4:	1f 91       	pop	r17
    86d6:	0f 91       	pop	r16
    86d8:	ff 90       	pop	r15
    86da:	ef 90       	pop	r14
    86dc:	08 95       	ret

000086de <Put_zDVal>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Put_zDVal - print unsigned Longint with leading zeroes in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void 
Put_zDVal(uint32_t Val, T_Param *Param)
{
    86de:	2f 92       	push	r2
    86e0:	3f 92       	push	r3
    86e2:	4f 92       	push	r4
    86e4:	5f 92       	push	r5
    86e6:	6f 92       	push	r6
    86e8:	7f 92       	push	r7
    86ea:	8f 92       	push	r8
    86ec:	9f 92       	push	r9
    86ee:	af 92       	push	r10
    86f0:	bf 92       	push	r11
    86f2:	cf 92       	push	r12
    86f4:	df 92       	push	r13
    86f6:	ef 92       	push	r14
    86f8:	ff 92       	push	r15
    86fa:	0f 93       	push	r16
    86fc:	1f 93       	push	r17
    86fe:	df 93       	push	r29
    8700:	cf 93       	push	r28
    8702:	cd b7       	in	r28, 0x3d	; 61
    8704:	de b7       	in	r29, 0x3e	; 62
    8706:	2c 97       	sbiw	r28, 0x0c	; 12
    8708:	0f b6       	in	r0, 0x3f	; 63
    870a:	f8 94       	cli
    870c:	de bf       	out	0x3e, r29	; 62
    870e:	0f be       	out	0x3f, r0	; 63
    8710:	cd bf       	out	0x3d, r28	; 61
    8712:	1b 01       	movw	r2, r22
    8714:	2c 01       	movw	r4, r24
    8716:	3a 01       	movw	r6, r20
	uint32_t Idx = 0xFFFFFFFF-Val;
	if(Param->Txt && Idx<2) {
    8718:	da 01       	movw	r26, r20
    871a:	14 96       	adiw	r26, 0x04	; 4
    871c:	2d 91       	ld	r18, X+
    871e:	3c 91       	ld	r19, X
    8720:	15 97       	sbiw	r26, 0x05	; 5
    8722:	21 15       	cp	r18, r1
    8724:	31 05       	cpc	r19, r1
    8726:	61 f0       	breq	.+24     	; 0x8740 <Put_zDVal+0x62>
// Put_zDVal - print unsigned Longint with leading zeroes in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void 
Put_zDVal(uint32_t Val, T_Param *Param)
{
	uint32_t Idx = 0xFFFFFFFF-Val;
    8728:	dc 01       	movw	r26, r24
    872a:	cb 01       	movw	r24, r22
    872c:	80 95       	com	r24
    872e:	90 95       	com	r25
    8730:	a0 95       	com	r26
    8732:	b0 95       	com	r27
	if(Param->Txt && Idx<2) {
    8734:	82 30       	cpi	r24, 0x02	; 2
    8736:	91 05       	cpc	r25, r1
    8738:	a1 05       	cpc	r26, r1
    873a:	b1 05       	cpc	r27, r1
    873c:	08 f4       	brcc	.+2      	; 0x8740 <Put_zDVal+0x62>
    873e:	e5 c0       	rjmp	.+458    	; 0x890a <Put_zDVal+0x22c>
		Param->Txt += Idx;
		PutEnum(Param);
		return;
	}

	if(Param->Size==10 && Param->Prec==0){
    8740:	d3 01       	movw	r26, r6
    8742:	13 96       	adiw	r26, 0x03	; 3
    8744:	8c 91       	ld	r24, X
    8746:	13 97       	sbiw	r26, 0x03	; 3
    8748:	8a 30       	cpi	r24, 0x0A	; 10
    874a:	09 f4       	brne	.+2      	; 0x874e <Put_zDVal+0x70>
    874c:	72 c0       	rjmp	.+228    	; 0x8832 <Put_zDVal+0x154>
		sprintf(Param->Pos, "%010lu", Val);
		return;
	}
	char Format[] = "%0 lu.%. lu";
    874e:	de 01       	movw	r26, r28
    8750:	11 96       	adiw	r26, 0x01	; 1
    8752:	e7 e4       	ldi	r30, 0x47	; 71
    8754:	f2 e0       	ldi	r31, 0x02	; 2
    8756:	8c e0       	ldi	r24, 0x0C	; 12
    8758:	01 90       	ld	r0, Z+
    875a:	0d 92       	st	X+, r0
    875c:	81 50       	subi	r24, 0x01	; 1
    875e:	e1 f7       	brne	.-8      	; 0x8758 <Put_zDVal+0x7a>
	Format[2] = '0'+Param->Size;
    8760:	d3 01       	movw	r26, r6
    8762:	13 96       	adiw	r26, 0x03	; 3
    8764:	2c 91       	ld	r18, X
    8766:	13 97       	sbiw	r26, 0x03	; 3
    8768:	20 5d       	subi	r18, 0xD0	; 208
    876a:	2b 83       	std	Y+3, r18	; 0x03
	if(Param->Prec) {
    876c:	12 96       	adiw	r26, 0x02	; 2
    876e:	9c 91       	ld	r25, X
    8770:	99 23       	and	r25, r25
    8772:	09 f4       	brne	.+2      	; 0x8776 <Put_zDVal+0x98>
    8774:	a0 c0       	rjmp	.+320    	; 0x88b6 <Put_zDVal+0x1d8>
		Format[2] -= Param->Prec+1;
    8776:	89 2f       	mov	r24, r25
    8778:	80 95       	com	r24
    877a:	82 0f       	add	r24, r18
    877c:	8b 83       	std	Y+3, r24	; 0x03
		Format[8] = '0'+Param->Prec;
    877e:	90 5d       	subi	r25, 0xD0	; 208
    8780:	99 87       	std	Y+9, r25	; 0x09
    8782:	90 53       	subi	r25, 0x30	; 48
		uint32_t Div=PowL10(Param->Prec);
    8784:	09 2f       	mov	r16, r25
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
	uint32_t Pow = 1;
	while(Exp--)
    8786:	61 e0       	ldi	r22, 0x01	; 1
    8788:	86 2e       	mov	r8, r22
    878a:	91 2c       	mov	r9, r1
    878c:	a1 2c       	mov	r10, r1
    878e:	b1 2c       	mov	r11, r1
		Pow *= 10;
    8790:	c5 01       	movw	r24, r10
    8792:	b4 01       	movw	r22, r8
    8794:	2a e0       	ldi	r18, 0x0A	; 10
    8796:	30 e0       	ldi	r19, 0x00	; 0
    8798:	40 e0       	ldi	r20, 0x00	; 0
    879a:	50 e0       	ldi	r21, 0x00	; 0
    879c:	0e 94 e0 7d 	call	0xfbc0	; 0xfbc0 <__mulsi3>
    87a0:	4b 01       	movw	r8, r22
    87a2:	5c 01       	movw	r10, r24
    87a4:	01 50       	subi	r16, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
	uint32_t Pow = 1;
	while(Exp--)
    87a6:	a1 f7       	brne	.-24     	; 0x8790 <Put_zDVal+0xb2>
    87a8:	c2 01       	movw	r24, r4
    87aa:	b1 01       	movw	r22, r2
    87ac:	94 01       	movw	r18, r8
    87ae:	a5 01       	movw	r20, r10
    87b0:	0e 94 32 7e 	call	0xfc64	; 0xfc64 <__udivmodsi4>
    87b4:	f6 2e       	mov	r15, r22
    87b6:	e7 2e       	mov	r14, r23
    87b8:	d8 2e       	mov	r13, r24
    87ba:	c9 2e       	mov	r12, r25
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
    87bc:	ed b7       	in	r30, 0x3d	; 61
    87be:	fe b7       	in	r31, 0x3e	; 62
    87c0:	3c 97       	sbiw	r30, 0x0c	; 12
    87c2:	0f b6       	in	r0, 0x3f	; 63
    87c4:	f8 94       	cli
    87c6:	fe bf       	out	0x3e, r31	; 62
    87c8:	0f be       	out	0x3f, r0	; 63
    87ca:	ed bf       	out	0x3d, r30	; 61
    87cc:	0d b7       	in	r16, 0x3d	; 61
    87ce:	1e b7       	in	r17, 0x3e	; 62
    87d0:	0f 5f       	subi	r16, 0xFF	; 255
    87d2:	1f 4f       	sbci	r17, 0xFF	; 255
    87d4:	d3 01       	movw	r26, r6
    87d6:	8d 91       	ld	r24, X+
    87d8:	9c 91       	ld	r25, X
    87da:	92 83       	std	Z+2, r25	; 0x02
    87dc:	81 83       	std	Z+1, r24	; 0x01
    87de:	81 e0       	ldi	r24, 0x01	; 1
    87e0:	90 e0       	ldi	r25, 0x00	; 0
    87e2:	8c 0f       	add	r24, r28
    87e4:	9d 1f       	adc	r25, r29
    87e6:	f8 01       	movw	r30, r16
    87e8:	93 83       	std	Z+3, r25	; 0x03
    87ea:	82 83       	std	Z+2, r24	; 0x02
    87ec:	c2 01       	movw	r24, r4
    87ee:	b1 01       	movw	r22, r2
    87f0:	a5 01       	movw	r20, r10
    87f2:	94 01       	movw	r18, r8
    87f4:	0e 94 32 7e 	call	0xfc64	; 0xfc64 <__udivmodsi4>
    87f8:	d8 01       	movw	r26, r16
    87fa:	14 96       	adiw	r26, 0x04	; 4
    87fc:	2d 93       	st	X+, r18
    87fe:	3d 93       	st	X+, r19
    8800:	4d 93       	st	X+, r20
    8802:	5c 93       	st	X, r21
    8804:	17 97       	sbiw	r26, 0x07	; 7
    8806:	18 96       	adiw	r26, 0x08	; 8
    8808:	fc 92       	st	X, r15
    880a:	18 97       	sbiw	r26, 0x08	; 8
    880c:	19 96       	adiw	r26, 0x09	; 9
    880e:	ec 92       	st	X, r14
    8810:	19 97       	sbiw	r26, 0x09	; 9
    8812:	1a 96       	adiw	r26, 0x0a	; 10
    8814:	dc 92       	st	X, r13
    8816:	1a 97       	sbiw	r26, 0x0a	; 10
    8818:	1b 96       	adiw	r26, 0x0b	; 11
    881a:	cc 92       	st	X, r12
    881c:	0e 94 76 7b 	call	0xf6ec	; 0xf6ec <sprintf>
    8820:	ed b7       	in	r30, 0x3d	; 61
    8822:	fe b7       	in	r31, 0x3e	; 62
    8824:	3c 96       	adiw	r30, 0x0c	; 12
    8826:	0f b6       	in	r0, 0x3f	; 63
    8828:	f8 94       	cli
    882a:	fe bf       	out	0x3e, r31	; 62
    882c:	0f be       	out	0x3f, r0	; 63
    882e:	ed bf       	out	0x3d, r30	; 61
    8830:	29 c0       	rjmp	.+82     	; 0x8884 <Put_zDVal+0x1a6>
		Param->Txt += Idx;
		PutEnum(Param);
		return;
	}

	if(Param->Size==10 && Param->Prec==0){
    8832:	12 96       	adiw	r26, 0x02	; 2
    8834:	8c 91       	ld	r24, X
    8836:	12 97       	sbiw	r26, 0x02	; 2
    8838:	88 23       	and	r24, r24
    883a:	09 f0       	breq	.+2      	; 0x883e <Put_zDVal+0x160>
    883c:	88 cf       	rjmp	.-240    	; 0x874e <Put_zDVal+0x70>
		sprintf(Param->Pos, "%010lu", Val);
    883e:	ed b7       	in	r30, 0x3d	; 61
    8840:	fe b7       	in	r31, 0x3e	; 62
    8842:	38 97       	sbiw	r30, 0x08	; 8
    8844:	0f b6       	in	r0, 0x3f	; 63
    8846:	f8 94       	cli
    8848:	fe bf       	out	0x3e, r31	; 62
    884a:	0f be       	out	0x3f, r0	; 63
    884c:	ed bf       	out	0x3d, r30	; 61
    884e:	31 96       	adiw	r30, 0x01	; 1
    8850:	8d 91       	ld	r24, X+
    8852:	9c 91       	ld	r25, X
    8854:	ad b7       	in	r26, 0x3d	; 61
    8856:	be b7       	in	r27, 0x3e	; 62
    8858:	12 96       	adiw	r26, 0x02	; 2
    885a:	9c 93       	st	X, r25
    885c:	8e 93       	st	-X, r24
    885e:	11 97       	sbiw	r26, 0x01	; 1
    8860:	80 e4       	ldi	r24, 0x40	; 64
    8862:	92 e0       	ldi	r25, 0x02	; 2
    8864:	93 83       	std	Z+3, r25	; 0x03
    8866:	82 83       	std	Z+2, r24	; 0x02
    8868:	24 82       	std	Z+4, r2	; 0x04
    886a:	35 82       	std	Z+5, r3	; 0x05
    886c:	46 82       	std	Z+6, r4	; 0x06
    886e:	57 82       	std	Z+7, r5	; 0x07
    8870:	0e 94 76 7b 	call	0xf6ec	; 0xf6ec <sprintf>
    8874:	ed b7       	in	r30, 0x3d	; 61
    8876:	fe b7       	in	r31, 0x3e	; 62
    8878:	38 96       	adiw	r30, 0x08	; 8
    887a:	0f b6       	in	r0, 0x3f	; 63
    887c:	f8 94       	cli
    887e:	fe bf       	out	0x3e, r31	; 62
    8880:	0f be       	out	0x3f, r0	; 63
    8882:	ed bf       	out	0x3d, r30	; 61
	}
	else {
		Format[5] = '\0';
		sprintf(Param->Pos, Format, Val);
	}
}
    8884:	2c 96       	adiw	r28, 0x0c	; 12
    8886:	0f b6       	in	r0, 0x3f	; 63
    8888:	f8 94       	cli
    888a:	de bf       	out	0x3e, r29	; 62
    888c:	0f be       	out	0x3f, r0	; 63
    888e:	cd bf       	out	0x3d, r28	; 61
    8890:	cf 91       	pop	r28
    8892:	df 91       	pop	r29
    8894:	1f 91       	pop	r17
    8896:	0f 91       	pop	r16
    8898:	ff 90       	pop	r15
    889a:	ef 90       	pop	r14
    889c:	df 90       	pop	r13
    889e:	cf 90       	pop	r12
    88a0:	bf 90       	pop	r11
    88a2:	af 90       	pop	r10
    88a4:	9f 90       	pop	r9
    88a6:	8f 90       	pop	r8
    88a8:	7f 90       	pop	r7
    88aa:	6f 90       	pop	r6
    88ac:	5f 90       	pop	r5
    88ae:	4f 90       	pop	r4
    88b0:	3f 90       	pop	r3
    88b2:	2f 90       	pop	r2
    88b4:	08 95       	ret
		Format[8] = '0'+Param->Prec;
		uint32_t Div=PowL10(Param->Prec);
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
	}
	else {
		Format[5] = '\0';
    88b6:	1e 82       	std	Y+6, r1	; 0x06
		sprintf(Param->Pos, Format, Val);
    88b8:	8d b7       	in	r24, 0x3d	; 61
    88ba:	9e b7       	in	r25, 0x3e	; 62
    88bc:	08 97       	sbiw	r24, 0x08	; 8
    88be:	0f b6       	in	r0, 0x3f	; 63
    88c0:	f8 94       	cli
    88c2:	9e bf       	out	0x3e, r25	; 62
    88c4:	0f be       	out	0x3f, r0	; 63
    88c6:	8d bf       	out	0x3d, r24	; 61
    88c8:	ed b7       	in	r30, 0x3d	; 61
    88ca:	fe b7       	in	r31, 0x3e	; 62
    88cc:	31 96       	adiw	r30, 0x01	; 1
    88ce:	d3 01       	movw	r26, r6
    88d0:	8d 91       	ld	r24, X+
    88d2:	9c 91       	ld	r25, X
    88d4:	ad b7       	in	r26, 0x3d	; 61
    88d6:	be b7       	in	r27, 0x3e	; 62
    88d8:	12 96       	adiw	r26, 0x02	; 2
    88da:	9c 93       	st	X, r25
    88dc:	8e 93       	st	-X, r24
    88de:	11 97       	sbiw	r26, 0x01	; 1
    88e0:	81 e0       	ldi	r24, 0x01	; 1
    88e2:	90 e0       	ldi	r25, 0x00	; 0
    88e4:	8c 0f       	add	r24, r28
    88e6:	9d 1f       	adc	r25, r29
    88e8:	93 83       	std	Z+3, r25	; 0x03
    88ea:	82 83       	std	Z+2, r24	; 0x02
    88ec:	24 82       	std	Z+4, r2	; 0x04
    88ee:	35 82       	std	Z+5, r3	; 0x05
    88f0:	46 82       	std	Z+6, r4	; 0x06
    88f2:	57 82       	std	Z+7, r5	; 0x07
    88f4:	0e 94 76 7b 	call	0xf6ec	; 0xf6ec <sprintf>
    88f8:	ad b7       	in	r26, 0x3d	; 61
    88fa:	be b7       	in	r27, 0x3e	; 62
    88fc:	18 96       	adiw	r26, 0x08	; 8
    88fe:	0f b6       	in	r0, 0x3f	; 63
    8900:	f8 94       	cli
    8902:	be bf       	out	0x3e, r27	; 62
    8904:	0f be       	out	0x3f, r0	; 63
    8906:	ad bf       	out	0x3d, r26	; 61
    8908:	bd cf       	rjmp	.-134    	; 0x8884 <Put_zDVal+0x1a6>
void 
Put_zDVal(uint32_t Val, T_Param *Param)
{
	uint32_t Idx = 0xFFFFFFFF-Val;
	if(Param->Txt && Idx<2) {
		Param->Txt += Idx;
    890a:	88 0f       	add	r24, r24
    890c:	99 1f       	adc	r25, r25
    890e:	28 0f       	add	r18, r24
    8910:	39 1f       	adc	r19, r25
    8912:	fa 01       	movw	r30, r20
    8914:	35 83       	std	Z+5, r19	; 0x05
    8916:	24 83       	std	Z+4, r18	; 0x04
		PutEnum(Param);
    8918:	ca 01       	movw	r24, r20
    891a:	0e 94 f0 3f 	call	0x7fe0	; 0x7fe0 <PutEnum>
    891e:	b2 cf       	rjmp	.-156    	; 0x8884 <Put_zDVal+0x1a6>

00008920 <Put_sDVal>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Put_sDVal - print signed Longint in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_sDVal(int32_t Val, T_Param *Param)
{
    8920:	cf 92       	push	r12
    8922:	df 92       	push	r13
    8924:	ef 92       	push	r14
    8926:	ff 92       	push	r15
    8928:	0f 93       	push	r16
    892a:	1f 93       	push	r17
    892c:	df 93       	push	r29
    892e:	cf 93       	push	r28
    8930:	cd b7       	in	r28, 0x3d	; 61
    8932:	de b7       	in	r29, 0x3e	; 62
    8934:	2d 97       	sbiw	r28, 0x0d	; 13
    8936:	0f b6       	in	r0, 0x3f	; 63
    8938:	f8 94       	cli
    893a:	de bf       	out	0x3e, r29	; 62
    893c:	0f be       	out	0x3f, r0	; 63
    893e:	cd bf       	out	0x3d, r28	; 61
    8940:	6b 01       	movw	r12, r22
    8942:	7c 01       	movw	r14, r24
    8944:	8a 01       	movw	r16, r20
	uint32_t Idx = 0x80000000+Val;
	if(Param->Txt && Idx<2) {
    8946:	da 01       	movw	r26, r20
    8948:	14 96       	adiw	r26, 0x04	; 4
    894a:	2d 91       	ld	r18, X+
    894c:	3c 91       	ld	r19, X
    894e:	15 97       	sbiw	r26, 0x05	; 5
    8950:	21 15       	cp	r18, r1
    8952:	31 05       	cpc	r19, r1
    8954:	61 f0       	breq	.+24     	; 0x896e <Put_sDVal+0x4e>
// Put_sDVal - print signed Longint in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_sDVal(int32_t Val, T_Param *Param)
{
	uint32_t Idx = 0x80000000+Val;
    8956:	dc 01       	movw	r26, r24
    8958:	cb 01       	movw	r24, r22
    895a:	80 50       	subi	r24, 0x00	; 0
    895c:	90 40       	sbci	r25, 0x00	; 0
    895e:	a0 40       	sbci	r26, 0x00	; 0
    8960:	b0 48       	sbci	r27, 0x80	; 128
	if(Param->Txt && Idx<2) {
    8962:	82 30       	cpi	r24, 0x02	; 2
    8964:	91 05       	cpc	r25, r1
    8966:	a1 05       	cpc	r26, r1
    8968:	b1 05       	cpc	r27, r1
    896a:	08 f4       	brcc	.+2      	; 0x896e <Put_sDVal+0x4e>
    896c:	f7 c0       	rjmp	.+494    	; 0x8b5c <Put_sDVal+0x23c>
		Param->Txt += Idx;
		PutEnum(Param);
		return;
	}
	// standart specificator to print Longint in string
	if(Param->Size>9){
    896e:	d8 01       	movw	r26, r16
    8970:	13 96       	adiw	r26, 0x03	; 3
    8972:	8c 91       	ld	r24, X
    8974:	8a 30       	cpi	r24, 0x0A	; 10
    8976:	f8 f0       	brcs	.+62     	; 0x89b6 <Put_sDVal+0x96>
		char Format[] = "%+1 ld";
    8978:	9e 01       	movw	r18, r28
    897a:	29 5f       	subi	r18, 0xF9	; 249
    897c:	3f 4f       	sbci	r19, 0xFF	; 255
    897e:	d9 01       	movw	r26, r18
    8980:	e3 e5       	ldi	r30, 0x53	; 83
    8982:	f2 e0       	ldi	r31, 0x02	; 2
    8984:	87 e0       	ldi	r24, 0x07	; 7
    8986:	01 90       	ld	r0, Z+
    8988:	0d 92       	st	X+, r0
    898a:	81 50       	subi	r24, 0x01	; 1
    898c:	e1 f7       	brne	.-8      	; 0x8986 <Put_sDVal+0x66>
		Format[3] = '0'+Param->Size%10;
    898e:	f8 01       	movw	r30, r16
    8990:	83 81       	ldd	r24, Z+3	; 0x03
    8992:	6a e0       	ldi	r22, 0x0A	; 10
    8994:	0e 94 ff 7d 	call	0xfbfe	; 0xfbfe <__udivmodqi4>
    8998:	90 5d       	subi	r25, 0xD0	; 208
    899a:	9a 87       	std	Y+10, r25	; 0x0a
		sprintf(Param->Pos, Format, Val);
    899c:	8d b7       	in	r24, 0x3d	; 61
    899e:	9e b7       	in	r25, 0x3e	; 62
    89a0:	08 97       	sbiw	r24, 0x08	; 8
    89a2:	0f b6       	in	r0, 0x3f	; 63
    89a4:	f8 94       	cli
    89a6:	9e bf       	out	0x3e, r25	; 62
    89a8:	0f be       	out	0x3f, r0	; 63
    89aa:	8d bf       	out	0x3d, r24	; 61
    89ac:	ed b7       	in	r30, 0x3d	; 61
    89ae:	fe b7       	in	r31, 0x3e	; 62
    89b0:	31 96       	adiw	r30, 0x01	; 1
    89b2:	d8 01       	movw	r26, r16
    89b4:	1a c0       	rjmp	.+52     	; 0x89ea <Put_sDVal+0xca>
	}
	else{
		char Format[] = "%+ ld";
    89b6:	9e 01       	movw	r18, r28
    89b8:	2f 5f       	subi	r18, 0xFF	; 255
    89ba:	3f 4f       	sbci	r19, 0xFF	; 255
    89bc:	d9 01       	movw	r26, r18
    89be:	ea e5       	ldi	r30, 0x5A	; 90
    89c0:	f2 e0       	ldi	r31, 0x02	; 2
    89c2:	86 e0       	ldi	r24, 0x06	; 6
    89c4:	01 90       	ld	r0, Z+
    89c6:	0d 92       	st	X+, r0
    89c8:	81 50       	subi	r24, 0x01	; 1
    89ca:	e1 f7       	brne	.-8      	; 0x89c4 <Put_sDVal+0xa4>
		Format[2] = '0'+Param->Size;
    89cc:	d8 01       	movw	r26, r16
    89ce:	13 96       	adiw	r26, 0x03	; 3
    89d0:	8c 91       	ld	r24, X
    89d2:	13 97       	sbiw	r26, 0x03	; 3
    89d4:	80 5d       	subi	r24, 0xD0	; 208
    89d6:	8b 83       	std	Y+3, r24	; 0x03
		sprintf(Param->Pos, Format, Val);
    89d8:	ed b7       	in	r30, 0x3d	; 61
    89da:	fe b7       	in	r31, 0x3e	; 62
    89dc:	38 97       	sbiw	r30, 0x08	; 8
    89de:	0f b6       	in	r0, 0x3f	; 63
    89e0:	f8 94       	cli
    89e2:	fe bf       	out	0x3e, r31	; 62
    89e4:	0f be       	out	0x3f, r0	; 63
    89e6:	ed bf       	out	0x3d, r30	; 61
    89e8:	31 96       	adiw	r30, 0x01	; 1
    89ea:	8d 91       	ld	r24, X+
    89ec:	9c 91       	ld	r25, X
    89ee:	ad b7       	in	r26, 0x3d	; 61
    89f0:	be b7       	in	r27, 0x3e	; 62
    89f2:	12 96       	adiw	r26, 0x02	; 2
    89f4:	9c 93       	st	X, r25
    89f6:	8e 93       	st	-X, r24
    89f8:	11 97       	sbiw	r26, 0x01	; 1
    89fa:	33 83       	std	Z+3, r19	; 0x03
    89fc:	22 83       	std	Z+2, r18	; 0x02
    89fe:	c4 82       	std	Z+4, r12	; 0x04
    8a00:	d5 82       	std	Z+5, r13	; 0x05
    8a02:	e6 82       	std	Z+6, r14	; 0x06
    8a04:	f7 82       	std	Z+7, r15	; 0x07
    8a06:	0e 94 76 7b 	call	0xf6ec	; 0xf6ec <sprintf>
    8a0a:	ed b7       	in	r30, 0x3d	; 61
    8a0c:	fe b7       	in	r31, 0x3e	; 62
    8a0e:	38 96       	adiw	r30, 0x08	; 8
    8a10:	0f b6       	in	r0, 0x3f	; 63
    8a12:	f8 94       	cli
    8a14:	fe bf       	out	0x3e, r31	; 62
    8a16:	0f be       	out	0x3f, r0	; 63
    8a18:	ed bf       	out	0x3d, r30	; 61
	}
	//Delete sign if zero
	if(!Val)Param->Pos[Param->Size-2] = ' ';
    8a1a:	c1 14       	cp	r12, r1
    8a1c:	d1 04       	cpc	r13, r1
    8a1e:	e1 04       	cpc	r14, r1
    8a20:	f1 04       	cpc	r15, r1
    8a22:	59 f4       	brne	.+22     	; 0x8a3a <Put_sDVal+0x11a>
    8a24:	d8 01       	movw	r26, r16
    8a26:	13 96       	adiw	r26, 0x03	; 3
    8a28:	8c 91       	ld	r24, X
    8a2a:	13 97       	sbiw	r26, 0x03	; 3
    8a2c:	ed 91       	ld	r30, X+
    8a2e:	fc 91       	ld	r31, X
    8a30:	e8 0f       	add	r30, r24
    8a32:	f1 1d       	adc	r31, r1
    8a34:	32 97       	sbiw	r30, 0x02	; 2
    8a36:	80 e2       	ldi	r24, 0x20	; 32
    8a38:	80 83       	st	Z, r24

	if(Param->Prec){
    8a3a:	f8 01       	movw	r30, r16
    8a3c:	92 81       	ldd	r25, Z+2	; 0x02
    8a3e:	99 23       	and	r25, r25
    8a40:	09 f4       	brne	.+2      	; 0x8a44 <Put_sDVal+0x124>
    8a42:	41 c0       	rjmp	.+130    	; 0x8ac6 <Put_sDVal+0x1a6>
		//Insert decimal point
		for(uint8_t i=0; i< Param->Size - Param->Prec; i++){
    8a44:	83 81       	ldd	r24, Z+3	; 0x03
    8a46:	28 2f       	mov	r18, r24
    8a48:	30 e0       	ldi	r19, 0x00	; 0
    8a4a:	29 1b       	sub	r18, r25
    8a4c:	31 09       	sbc	r19, r1
    8a4e:	12 16       	cp	r1, r18
    8a50:	13 06       	cpc	r1, r19
    8a52:	d4 f4       	brge	.+52     	; 0x8a88 <Put_sDVal+0x168>
    8a54:	40 e0       	ldi	r20, 0x00	; 0
    8a56:	80 e0       	ldi	r24, 0x00	; 0
    8a58:	90 e0       	ldi	r25, 0x00	; 0
			Param->Pos[i] = Param->Pos[i+1];
    8a5a:	d8 01       	movw	r26, r16
    8a5c:	ed 91       	ld	r30, X+
    8a5e:	fc 91       	ld	r31, X
    8a60:	11 97       	sbiw	r26, 0x01	; 1
    8a62:	e8 0f       	add	r30, r24
    8a64:	f9 1f       	adc	r31, r25
    8a66:	81 81       	ldd	r24, Z+1	; 0x01
    8a68:	80 83       	st	Z, r24
	//Delete sign if zero
	if(!Val)Param->Pos[Param->Size-2] = ' ';

	if(Param->Prec){
		//Insert decimal point
		for(uint8_t i=0; i< Param->Size - Param->Prec; i++){
    8a6a:	4f 5f       	subi	r20, 0xFF	; 255
    8a6c:	13 96       	adiw	r26, 0x03	; 3
    8a6e:	8c 91       	ld	r24, X
    8a70:	13 97       	sbiw	r26, 0x03	; 3
    8a72:	28 2f       	mov	r18, r24
    8a74:	30 e0       	ldi	r19, 0x00	; 0
    8a76:	12 96       	adiw	r26, 0x02	; 2
    8a78:	8c 91       	ld	r24, X
    8a7a:	28 1b       	sub	r18, r24
    8a7c:	31 09       	sbc	r19, r1
    8a7e:	84 2f       	mov	r24, r20
    8a80:	90 e0       	ldi	r25, 0x00	; 0
    8a82:	82 17       	cp	r24, r18
    8a84:	93 07       	cpc	r25, r19
    8a86:	4c f3       	brlt	.-46     	; 0x8a5a <Put_sDVal+0x13a>
			Param->Pos[i] = Param->Pos[i+1];
		}
		Param->Pos[Param->Size - Param->Prec-1] = '.';
    8a88:	d8 01       	movw	r26, r16
    8a8a:	ed 91       	ld	r30, X+
    8a8c:	fc 91       	ld	r31, X
    8a8e:	11 97       	sbiw	r26, 0x01	; 1
    8a90:	e2 0f       	add	r30, r18
    8a92:	f3 1f       	adc	r31, r19
    8a94:	31 97       	sbiw	r30, 0x01	; 1
    8a96:	8e e2       	ldi	r24, 0x2E	; 46
    8a98:	80 83       	st	Z, r24
		//Fill zeros and shift sign for correct view
		char c = Param->Pos[Param->Size - Param->Prec-2];
    8a9a:	4d 91       	ld	r20, X+
    8a9c:	5c 91       	ld	r21, X
    8a9e:	11 97       	sbiw	r26, 0x01	; 1
    8aa0:	13 96       	adiw	r26, 0x03	; 3
    8aa2:	9c 91       	ld	r25, X
    8aa4:	13 97       	sbiw	r26, 0x03	; 3
    8aa6:	e9 2f       	mov	r30, r25
    8aa8:	f0 e0       	ldi	r31, 0x00	; 0
    8aaa:	12 96       	adiw	r26, 0x02	; 2
    8aac:	8c 91       	ld	r24, X
    8aae:	e8 1b       	sub	r30, r24
    8ab0:	f1 09       	sbc	r31, r1
    8ab2:	e4 0f       	add	r30, r20
    8ab4:	f5 1f       	adc	r31, r21
    8ab6:	32 97       	sbiw	r30, 0x02	; 2
    8ab8:	e0 81       	ld	r30, Z
		if(c ==' ' || c =='+' || c =='-'){
    8aba:	e0 32       	cpi	r30, 0x20	; 32
    8abc:	99 f0       	breq	.+38     	; 0x8ae4 <Put_sDVal+0x1c4>
    8abe:	eb 32       	cpi	r30, 0x2B	; 43
    8ac0:	89 f0       	breq	.+34     	; 0x8ae4 <Put_sDVal+0x1c4>
    8ac2:	ed 32       	cpi	r30, 0x2D	; 45
    8ac4:	79 f0       	breq	.+30     	; 0x8ae4 <Put_sDVal+0x1c4>
				}
			}
		}
	}

}
    8ac6:	2d 96       	adiw	r28, 0x0d	; 13
    8ac8:	0f b6       	in	r0, 0x3f	; 63
    8aca:	f8 94       	cli
    8acc:	de bf       	out	0x3e, r29	; 62
    8ace:	0f be       	out	0x3f, r0	; 63
    8ad0:	cd bf       	out	0x3d, r28	; 61
    8ad2:	cf 91       	pop	r28
    8ad4:	df 91       	pop	r29
    8ad6:	1f 91       	pop	r17
    8ad8:	0f 91       	pop	r16
    8ada:	ff 90       	pop	r15
    8adc:	ef 90       	pop	r14
    8ade:	df 90       	pop	r13
    8ae0:	cf 90       	pop	r12
    8ae2:	08 95       	ret
		}
		Param->Pos[Param->Size - Param->Prec-1] = '.';
		//Fill zeros and shift sign for correct view
		char c = Param->Pos[Param->Size - Param->Prec-2];
		if(c ==' ' || c =='+' || c =='-'){
			for(uint8_t i=Param->Size-1; i>1; i--){
    8ae4:	e9 2f       	mov	r30, r25
    8ae6:	e1 50       	subi	r30, 0x01	; 1
    8ae8:	e2 30       	cpi	r30, 0x02	; 2
    8aea:	68 f3       	brcs	.-38     	; 0x8ac6 <Put_sDVal+0x1a6>
				if(Param->Pos[i] == ' '|| Param->Pos[i] == '+' || Param->Pos[i] == '-' ) Param->Pos[i]='0';
    8aec:	90 e3       	ldi	r25, 0x30	; 48
    8aee:	09 c0       	rjmp	.+18     	; 0x8b02 <Put_sDVal+0x1e2>
    8af0:	8b 32       	cpi	r24, 0x2B	; 43
    8af2:	79 f0       	breq	.+30     	; 0x8b12 <Put_sDVal+0x1f2>
    8af4:	8d 32       	cpi	r24, 0x2D	; 45
    8af6:	69 f0       	breq	.+26     	; 0x8b12 <Put_sDVal+0x1f2>
				if(Param->Pos[i] == '.'){
    8af8:	8e 32       	cpi	r24, 0x2E	; 46
    8afa:	a9 f0       	breq	.+42     	; 0x8b26 <Put_sDVal+0x206>
		}
		Param->Pos[Param->Size - Param->Prec-1] = '.';
		//Fill zeros and shift sign for correct view
		char c = Param->Pos[Param->Size - Param->Prec-2];
		if(c ==' ' || c =='+' || c =='-'){
			for(uint8_t i=Param->Size-1; i>1; i--){
    8afc:	e1 50       	subi	r30, 0x01	; 1
    8afe:	e2 30       	cpi	r30, 0x02	; 2
    8b00:	10 f3       	brcs	.-60     	; 0x8ac6 <Put_sDVal+0x1a6>
				if(Param->Pos[i] == ' '|| Param->Pos[i] == '+' || Param->Pos[i] == '-' ) Param->Pos[i]='0';
    8b02:	2e 2f       	mov	r18, r30
    8b04:	30 e0       	ldi	r19, 0x00	; 0
    8b06:	da 01       	movw	r26, r20
    8b08:	a2 0f       	add	r26, r18
    8b0a:	b3 1f       	adc	r27, r19
    8b0c:	8c 91       	ld	r24, X
    8b0e:	80 32       	cpi	r24, 0x20	; 32
    8b10:	79 f7       	brne	.-34     	; 0x8af0 <Put_sDVal+0x1d0>
    8b12:	9c 93       	st	X, r25
    8b14:	d8 01       	movw	r26, r16
    8b16:	4d 91       	ld	r20, X+
    8b18:	5c 91       	ld	r21, X
    8b1a:	da 01       	movw	r26, r20
    8b1c:	a2 0f       	add	r26, r18
    8b1e:	b3 1f       	adc	r27, r19
    8b20:	8c 91       	ld	r24, X
				if(Param->Pos[i] == '.'){
    8b22:	8e 32       	cpi	r24, 0x2E	; 46
    8b24:	59 f7       	brne	.-42     	; 0x8afc <Put_sDVal+0x1dc>
					Param->Pos[i-1]='0';
    8b26:	11 97       	sbiw	r26, 0x01	; 1
    8b28:	80 e3       	ldi	r24, 0x30	; 48
    8b2a:	8c 93       	st	X, r24
					if(Val>0)Param->Pos[i-2]='+';
    8b2c:	1c 14       	cp	r1, r12
    8b2e:	1d 04       	cpc	r1, r13
    8b30:	1e 04       	cpc	r1, r14
    8b32:	1f 04       	cpc	r1, r15
    8b34:	44 f4       	brge	.+16     	; 0x8b46 <Put_sDVal+0x226>
    8b36:	d8 01       	movw	r26, r16
    8b38:	ed 91       	ld	r30, X+
    8b3a:	fc 91       	ld	r31, X
    8b3c:	e2 0f       	add	r30, r18
    8b3e:	f3 1f       	adc	r31, r19
    8b40:	32 97       	sbiw	r30, 0x02	; 2
    8b42:	8b e2       	ldi	r24, 0x2B	; 43
    8b44:	80 83       	st	Z, r24
					if(Val<0)Param->Pos[i-2]='-';
    8b46:	f7 fe       	sbrs	r15, 7
    8b48:	be cf       	rjmp	.-132    	; 0x8ac6 <Put_sDVal+0x1a6>
    8b4a:	d8 01       	movw	r26, r16
    8b4c:	ed 91       	ld	r30, X+
    8b4e:	fc 91       	ld	r31, X
    8b50:	e2 0f       	add	r30, r18
    8b52:	f3 1f       	adc	r31, r19
    8b54:	32 97       	sbiw	r30, 0x02	; 2
    8b56:	8d e2       	ldi	r24, 0x2D	; 45
    8b58:	80 83       	st	Z, r24
    8b5a:	b5 cf       	rjmp	.-150    	; 0x8ac6 <Put_sDVal+0x1a6>
void
Put_sDVal(int32_t Val, T_Param *Param)
{
	uint32_t Idx = 0x80000000+Val;
	if(Param->Txt && Idx<2) {
		Param->Txt += Idx;
    8b5c:	88 0f       	add	r24, r24
    8b5e:	99 1f       	adc	r25, r25
    8b60:	28 0f       	add	r18, r24
    8b62:	39 1f       	adc	r19, r25
    8b64:	fa 01       	movw	r30, r20
    8b66:	35 83       	std	Z+5, r19	; 0x05
    8b68:	24 83       	std	Z+4, r18	; 0x04
		PutEnum(Param);
    8b6a:	ca 01       	movw	r24, r20
    8b6c:	0e 94 f0 3f 	call	0x7fe0	; 0x7fe0 <PutEnum>
    8b70:	aa cf       	rjmp	.-172    	; 0x8ac6 <Put_sDVal+0x1a6>

00008b72 <PutDVal>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// PutDVal - print unsigned Longint in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
PutDVal(uint32_t Val, T_Param *Param)
{
    8b72:	2f 92       	push	r2
    8b74:	3f 92       	push	r3
    8b76:	4f 92       	push	r4
    8b78:	5f 92       	push	r5
    8b7a:	6f 92       	push	r6
    8b7c:	7f 92       	push	r7
    8b7e:	8f 92       	push	r8
    8b80:	9f 92       	push	r9
    8b82:	af 92       	push	r10
    8b84:	bf 92       	push	r11
    8b86:	cf 92       	push	r12
    8b88:	df 92       	push	r13
    8b8a:	ef 92       	push	r14
    8b8c:	ff 92       	push	r15
    8b8e:	0f 93       	push	r16
    8b90:	1f 93       	push	r17
    8b92:	df 93       	push	r29
    8b94:	cf 93       	push	r28
    8b96:	cd b7       	in	r28, 0x3d	; 61
    8b98:	de b7       	in	r29, 0x3e	; 62
    8b9a:	2b 97       	sbiw	r28, 0x0b	; 11
    8b9c:	0f b6       	in	r0, 0x3f	; 63
    8b9e:	f8 94       	cli
    8ba0:	de bf       	out	0x3e, r29	; 62
    8ba2:	0f be       	out	0x3f, r0	; 63
    8ba4:	cd bf       	out	0x3d, r28	; 61
    8ba6:	1b 01       	movw	r2, r22
    8ba8:	2c 01       	movw	r4, r24
    8baa:	3a 01       	movw	r6, r20
	uint32_t Idx = 0xFFFFFFFF-Val;
	if(Param->Txt && Idx<2) {
    8bac:	da 01       	movw	r26, r20
    8bae:	14 96       	adiw	r26, 0x04	; 4
    8bb0:	2d 91       	ld	r18, X+
    8bb2:	3c 91       	ld	r19, X
    8bb4:	15 97       	sbiw	r26, 0x05	; 5
    8bb6:	21 15       	cp	r18, r1
    8bb8:	31 05       	cpc	r19, r1
    8bba:	61 f0       	breq	.+24     	; 0x8bd4 <PutDVal+0x62>
// PutDVal - print unsigned Longint in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
PutDVal(uint32_t Val, T_Param *Param)
{
	uint32_t Idx = 0xFFFFFFFF-Val;
    8bbc:	dc 01       	movw	r26, r24
    8bbe:	cb 01       	movw	r24, r22
    8bc0:	80 95       	com	r24
    8bc2:	90 95       	com	r25
    8bc4:	a0 95       	com	r26
    8bc6:	b0 95       	com	r27
	if(Param->Txt && Idx<2) {
    8bc8:	82 30       	cpi	r24, 0x02	; 2
    8bca:	91 05       	cpc	r25, r1
    8bcc:	a1 05       	cpc	r26, r1
    8bce:	b1 05       	cpc	r27, r1
    8bd0:	08 f4       	brcc	.+2      	; 0x8bd4 <PutDVal+0x62>
    8bd2:	e5 c0       	rjmp	.+458    	; 0x8d9e <PutDVal+0x22c>
		Param->Txt += Idx;
		PutEnum(Param);
		return;
	}

	if(Param->Size==10 && Param->Prec==0){
    8bd4:	d3 01       	movw	r26, r6
    8bd6:	13 96       	adiw	r26, 0x03	; 3
    8bd8:	8c 91       	ld	r24, X
    8bda:	13 97       	sbiw	r26, 0x03	; 3
    8bdc:	8a 30       	cpi	r24, 0x0A	; 10
    8bde:	09 f4       	brne	.+2      	; 0x8be2 <PutDVal+0x70>
    8be0:	72 c0       	rjmp	.+228    	; 0x8cc6 <PutDVal+0x154>
		sprintf(Param->Pos, "%10lu", Val);
		return;
	}
	char Format[] = "% lu.%. lu";
    8be2:	de 01       	movw	r26, r28
    8be4:	11 96       	adiw	r26, 0x01	; 1
    8be6:	e6 e6       	ldi	r30, 0x66	; 102
    8be8:	f2 e0       	ldi	r31, 0x02	; 2
    8bea:	8b e0       	ldi	r24, 0x0B	; 11
    8bec:	01 90       	ld	r0, Z+
    8bee:	0d 92       	st	X+, r0
    8bf0:	81 50       	subi	r24, 0x01	; 1
    8bf2:	e1 f7       	brne	.-8      	; 0x8bec <PutDVal+0x7a>
	Format[1] = '0'+Param->Size;
    8bf4:	d3 01       	movw	r26, r6
    8bf6:	13 96       	adiw	r26, 0x03	; 3
    8bf8:	2c 91       	ld	r18, X
    8bfa:	13 97       	sbiw	r26, 0x03	; 3
    8bfc:	20 5d       	subi	r18, 0xD0	; 208
    8bfe:	2a 83       	std	Y+2, r18	; 0x02
	if(Param->Prec) {
    8c00:	12 96       	adiw	r26, 0x02	; 2
    8c02:	9c 91       	ld	r25, X
    8c04:	99 23       	and	r25, r25
    8c06:	09 f4       	brne	.+2      	; 0x8c0a <PutDVal+0x98>
    8c08:	a0 c0       	rjmp	.+320    	; 0x8d4a <PutDVal+0x1d8>
		Format[1] -= Param->Prec+1;
    8c0a:	89 2f       	mov	r24, r25
    8c0c:	80 95       	com	r24
    8c0e:	82 0f       	add	r24, r18
    8c10:	8a 83       	std	Y+2, r24	; 0x02
		Format[7] = '0'+Param->Prec;
    8c12:	90 5d       	subi	r25, 0xD0	; 208
    8c14:	98 87       	std	Y+8, r25	; 0x08
    8c16:	90 53       	subi	r25, 0x30	; 48
		uint32_t Div=PowL10(Param->Prec);
    8c18:	09 2f       	mov	r16, r25
    8c1a:	f1 e0       	ldi	r31, 0x01	; 1
    8c1c:	8f 2e       	mov	r8, r31
    8c1e:	91 2c       	mov	r9, r1
    8c20:	a1 2c       	mov	r10, r1
    8c22:	b1 2c       	mov	r11, r1
		Pow *= 10;
    8c24:	c5 01       	movw	r24, r10
    8c26:	b4 01       	movw	r22, r8
    8c28:	2a e0       	ldi	r18, 0x0A	; 10
    8c2a:	30 e0       	ldi	r19, 0x00	; 0
    8c2c:	40 e0       	ldi	r20, 0x00	; 0
    8c2e:	50 e0       	ldi	r21, 0x00	; 0
    8c30:	0e 94 e0 7d 	call	0xfbc0	; 0xfbc0 <__mulsi3>
    8c34:	4b 01       	movw	r8, r22
    8c36:	5c 01       	movw	r10, r24
    8c38:	01 50       	subi	r16, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
	uint32_t Pow = 1;
	while(Exp--)
    8c3a:	a1 f7       	brne	.-24     	; 0x8c24 <PutDVal+0xb2>
    8c3c:	c2 01       	movw	r24, r4
    8c3e:	b1 01       	movw	r22, r2
    8c40:	94 01       	movw	r18, r8
    8c42:	a5 01       	movw	r20, r10
    8c44:	0e 94 32 7e 	call	0xfc64	; 0xfc64 <__udivmodsi4>
    8c48:	f6 2e       	mov	r15, r22
    8c4a:	e7 2e       	mov	r14, r23
    8c4c:	d8 2e       	mov	r13, r24
    8c4e:	c9 2e       	mov	r12, r25
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
    8c50:	ed b7       	in	r30, 0x3d	; 61
    8c52:	fe b7       	in	r31, 0x3e	; 62
    8c54:	3c 97       	sbiw	r30, 0x0c	; 12
    8c56:	0f b6       	in	r0, 0x3f	; 63
    8c58:	f8 94       	cli
    8c5a:	fe bf       	out	0x3e, r31	; 62
    8c5c:	0f be       	out	0x3f, r0	; 63
    8c5e:	ed bf       	out	0x3d, r30	; 61
    8c60:	0d b7       	in	r16, 0x3d	; 61
    8c62:	1e b7       	in	r17, 0x3e	; 62
    8c64:	0f 5f       	subi	r16, 0xFF	; 255
    8c66:	1f 4f       	sbci	r17, 0xFF	; 255
    8c68:	d3 01       	movw	r26, r6
    8c6a:	8d 91       	ld	r24, X+
    8c6c:	9c 91       	ld	r25, X
    8c6e:	92 83       	std	Z+2, r25	; 0x02
    8c70:	81 83       	std	Z+1, r24	; 0x01
    8c72:	81 e0       	ldi	r24, 0x01	; 1
    8c74:	90 e0       	ldi	r25, 0x00	; 0
    8c76:	8c 0f       	add	r24, r28
    8c78:	9d 1f       	adc	r25, r29
    8c7a:	f8 01       	movw	r30, r16
    8c7c:	93 83       	std	Z+3, r25	; 0x03
    8c7e:	82 83       	std	Z+2, r24	; 0x02
    8c80:	c2 01       	movw	r24, r4
    8c82:	b1 01       	movw	r22, r2
    8c84:	a5 01       	movw	r20, r10
    8c86:	94 01       	movw	r18, r8
    8c88:	0e 94 32 7e 	call	0xfc64	; 0xfc64 <__udivmodsi4>
    8c8c:	d8 01       	movw	r26, r16
    8c8e:	14 96       	adiw	r26, 0x04	; 4
    8c90:	2d 93       	st	X+, r18
    8c92:	3d 93       	st	X+, r19
    8c94:	4d 93       	st	X+, r20
    8c96:	5c 93       	st	X, r21
    8c98:	17 97       	sbiw	r26, 0x07	; 7
    8c9a:	18 96       	adiw	r26, 0x08	; 8
    8c9c:	fc 92       	st	X, r15
    8c9e:	18 97       	sbiw	r26, 0x08	; 8
    8ca0:	19 96       	adiw	r26, 0x09	; 9
    8ca2:	ec 92       	st	X, r14
    8ca4:	19 97       	sbiw	r26, 0x09	; 9
    8ca6:	1a 96       	adiw	r26, 0x0a	; 10
    8ca8:	dc 92       	st	X, r13
    8caa:	1a 97       	sbiw	r26, 0x0a	; 10
    8cac:	1b 96       	adiw	r26, 0x0b	; 11
    8cae:	cc 92       	st	X, r12
    8cb0:	0e 94 76 7b 	call	0xf6ec	; 0xf6ec <sprintf>
    8cb4:	ed b7       	in	r30, 0x3d	; 61
    8cb6:	fe b7       	in	r31, 0x3e	; 62
    8cb8:	3c 96       	adiw	r30, 0x0c	; 12
    8cba:	0f b6       	in	r0, 0x3f	; 63
    8cbc:	f8 94       	cli
    8cbe:	fe bf       	out	0x3e, r31	; 62
    8cc0:	0f be       	out	0x3f, r0	; 63
    8cc2:	ed bf       	out	0x3d, r30	; 61
    8cc4:	29 c0       	rjmp	.+82     	; 0x8d18 <PutDVal+0x1a6>
		Param->Txt += Idx;
		PutEnum(Param);
		return;
	}

	if(Param->Size==10 && Param->Prec==0){
    8cc6:	12 96       	adiw	r26, 0x02	; 2
    8cc8:	8c 91       	ld	r24, X
    8cca:	12 97       	sbiw	r26, 0x02	; 2
    8ccc:	88 23       	and	r24, r24
    8cce:	09 f0       	breq	.+2      	; 0x8cd2 <PutDVal+0x160>
    8cd0:	88 cf       	rjmp	.-240    	; 0x8be2 <PutDVal+0x70>
		sprintf(Param->Pos, "%10lu", Val);
    8cd2:	ed b7       	in	r30, 0x3d	; 61
    8cd4:	fe b7       	in	r31, 0x3e	; 62
    8cd6:	38 97       	sbiw	r30, 0x08	; 8
    8cd8:	0f b6       	in	r0, 0x3f	; 63
    8cda:	f8 94       	cli
    8cdc:	fe bf       	out	0x3e, r31	; 62
    8cde:	0f be       	out	0x3f, r0	; 63
    8ce0:	ed bf       	out	0x3d, r30	; 61
    8ce2:	31 96       	adiw	r30, 0x01	; 1
    8ce4:	8d 91       	ld	r24, X+
    8ce6:	9c 91       	ld	r25, X
    8ce8:	ad b7       	in	r26, 0x3d	; 61
    8cea:	be b7       	in	r27, 0x3e	; 62
    8cec:	12 96       	adiw	r26, 0x02	; 2
    8cee:	9c 93       	st	X, r25
    8cf0:	8e 93       	st	-X, r24
    8cf2:	11 97       	sbiw	r26, 0x01	; 1
    8cf4:	80 e6       	ldi	r24, 0x60	; 96
    8cf6:	92 e0       	ldi	r25, 0x02	; 2
    8cf8:	93 83       	std	Z+3, r25	; 0x03
    8cfa:	82 83       	std	Z+2, r24	; 0x02
    8cfc:	24 82       	std	Z+4, r2	; 0x04
    8cfe:	35 82       	std	Z+5, r3	; 0x05
    8d00:	46 82       	std	Z+6, r4	; 0x06
    8d02:	57 82       	std	Z+7, r5	; 0x07
    8d04:	0e 94 76 7b 	call	0xf6ec	; 0xf6ec <sprintf>
    8d08:	ed b7       	in	r30, 0x3d	; 61
    8d0a:	fe b7       	in	r31, 0x3e	; 62
    8d0c:	38 96       	adiw	r30, 0x08	; 8
    8d0e:	0f b6       	in	r0, 0x3f	; 63
    8d10:	f8 94       	cli
    8d12:	fe bf       	out	0x3e, r31	; 62
    8d14:	0f be       	out	0x3f, r0	; 63
    8d16:	ed bf       	out	0x3d, r30	; 61
	}
	else {
		Format[4] = '\0';
		sprintf(Param->Pos, Format, Val);
	}
}
    8d18:	2b 96       	adiw	r28, 0x0b	; 11
    8d1a:	0f b6       	in	r0, 0x3f	; 63
    8d1c:	f8 94       	cli
    8d1e:	de bf       	out	0x3e, r29	; 62
    8d20:	0f be       	out	0x3f, r0	; 63
    8d22:	cd bf       	out	0x3d, r28	; 61
    8d24:	cf 91       	pop	r28
    8d26:	df 91       	pop	r29
    8d28:	1f 91       	pop	r17
    8d2a:	0f 91       	pop	r16
    8d2c:	ff 90       	pop	r15
    8d2e:	ef 90       	pop	r14
    8d30:	df 90       	pop	r13
    8d32:	cf 90       	pop	r12
    8d34:	bf 90       	pop	r11
    8d36:	af 90       	pop	r10
    8d38:	9f 90       	pop	r9
    8d3a:	8f 90       	pop	r8
    8d3c:	7f 90       	pop	r7
    8d3e:	6f 90       	pop	r6
    8d40:	5f 90       	pop	r5
    8d42:	4f 90       	pop	r4
    8d44:	3f 90       	pop	r3
    8d46:	2f 90       	pop	r2
    8d48:	08 95       	ret
		Format[7] = '0'+Param->Prec;
		uint32_t Div=PowL10(Param->Prec);
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
	}
	else {
		Format[4] = '\0';
    8d4a:	1d 82       	std	Y+5, r1	; 0x05
		sprintf(Param->Pos, Format, Val);
    8d4c:	8d b7       	in	r24, 0x3d	; 61
    8d4e:	9e b7       	in	r25, 0x3e	; 62
    8d50:	08 97       	sbiw	r24, 0x08	; 8
    8d52:	0f b6       	in	r0, 0x3f	; 63
    8d54:	f8 94       	cli
    8d56:	9e bf       	out	0x3e, r25	; 62
    8d58:	0f be       	out	0x3f, r0	; 63
    8d5a:	8d bf       	out	0x3d, r24	; 61
    8d5c:	ed b7       	in	r30, 0x3d	; 61
    8d5e:	fe b7       	in	r31, 0x3e	; 62
    8d60:	31 96       	adiw	r30, 0x01	; 1
    8d62:	d3 01       	movw	r26, r6
    8d64:	8d 91       	ld	r24, X+
    8d66:	9c 91       	ld	r25, X
    8d68:	ad b7       	in	r26, 0x3d	; 61
    8d6a:	be b7       	in	r27, 0x3e	; 62
    8d6c:	12 96       	adiw	r26, 0x02	; 2
    8d6e:	9c 93       	st	X, r25
    8d70:	8e 93       	st	-X, r24
    8d72:	11 97       	sbiw	r26, 0x01	; 1
    8d74:	81 e0       	ldi	r24, 0x01	; 1
    8d76:	90 e0       	ldi	r25, 0x00	; 0
    8d78:	8c 0f       	add	r24, r28
    8d7a:	9d 1f       	adc	r25, r29
    8d7c:	93 83       	std	Z+3, r25	; 0x03
    8d7e:	82 83       	std	Z+2, r24	; 0x02
    8d80:	24 82       	std	Z+4, r2	; 0x04
    8d82:	35 82       	std	Z+5, r3	; 0x05
    8d84:	46 82       	std	Z+6, r4	; 0x06
    8d86:	57 82       	std	Z+7, r5	; 0x07
    8d88:	0e 94 76 7b 	call	0xf6ec	; 0xf6ec <sprintf>
    8d8c:	ad b7       	in	r26, 0x3d	; 61
    8d8e:	be b7       	in	r27, 0x3e	; 62
    8d90:	18 96       	adiw	r26, 0x08	; 8
    8d92:	0f b6       	in	r0, 0x3f	; 63
    8d94:	f8 94       	cli
    8d96:	be bf       	out	0x3e, r27	; 62
    8d98:	0f be       	out	0x3f, r0	; 63
    8d9a:	ad bf       	out	0x3d, r26	; 61
    8d9c:	bd cf       	rjmp	.-134    	; 0x8d18 <PutDVal+0x1a6>
void
PutDVal(uint32_t Val, T_Param *Param)
{
	uint32_t Idx = 0xFFFFFFFF-Val;
	if(Param->Txt && Idx<2) {
		Param->Txt += Idx;
    8d9e:	88 0f       	add	r24, r24
    8da0:	99 1f       	adc	r25, r25
    8da2:	28 0f       	add	r18, r24
    8da4:	39 1f       	adc	r19, r25
    8da6:	fa 01       	movw	r30, r20
    8da8:	35 83       	std	Z+5, r19	; 0x05
    8daa:	24 83       	std	Z+4, r18	; 0x04
		PutEnum(Param);
    8dac:	ca 01       	movw	r24, r20
    8dae:	0e 94 f0 3f 	call	0x7fe0	; 0x7fe0 <PutEnum>
    8db2:	b2 cf       	rjmp	.-156    	; 0x8d18 <PutDVal+0x1a6>

00008db4 <Put_zVal_h>:
	}
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_zVal_h(uint32_t Val, char Type, T_Param *Param)
{
    8db4:	1f 93       	push	r17
    8db6:	17 2f       	mov	r17, r23
    8db8:	58 2f       	mov	r21, r24
    8dba:	79 2f       	mov	r23, r25
    8dbc:	d9 01       	movw	r26, r18
	if(Type=='b') sprintf(Param->Pos, "%02hx", (uint8_t)Val);
    8dbe:	42 36       	cpi	r20, 0x62	; 98
    8dc0:	71 f1       	breq	.+92     	; 0x8e1e <Put_zVal_h+0x6a>
	if(Type=='w') sprintf(Param->Pos, "%04x", (uint16_t)Val);
    8dc2:	47 37       	cpi	r20, 0x77	; 119
    8dc4:	09 f4       	brne	.+2      	; 0x8dc8 <Put_zVal_h+0x14>
    8dc6:	4a c0       	rjmp	.+148    	; 0x8e5c <Put_zVal_h+0xa8>
	if(Type=='l') sprintf(Param->Pos, "%08lx", Val);
    8dc8:	4c 36       	cpi	r20, 0x6C	; 108
    8dca:	11 f0       	breq	.+4      	; 0x8dd0 <Put_zVal_h+0x1c>
}
    8dcc:	1f 91       	pop	r17
    8dce:	08 95       	ret
void
Put_zVal_h(uint32_t Val, char Type, T_Param *Param)
{
	if(Type=='b') sprintf(Param->Pos, "%02hx", (uint8_t)Val);
	if(Type=='w') sprintf(Param->Pos, "%04x", (uint16_t)Val);
	if(Type=='l') sprintf(Param->Pos, "%08lx", Val);
    8dd0:	8d b7       	in	r24, 0x3d	; 61
    8dd2:	9e b7       	in	r25, 0x3e	; 62
    8dd4:	08 97       	sbiw	r24, 0x08	; 8
    8dd6:	0f b6       	in	r0, 0x3f	; 63
    8dd8:	f8 94       	cli
    8dda:	9e bf       	out	0x3e, r25	; 62
    8ddc:	0f be       	out	0x3f, r0	; 63
    8dde:	8d bf       	out	0x3d, r24	; 61
    8de0:	ed b7       	in	r30, 0x3d	; 61
    8de2:	fe b7       	in	r31, 0x3e	; 62
    8de4:	31 96       	adiw	r30, 0x01	; 1
    8de6:	8d 91       	ld	r24, X+
    8de8:	9c 91       	ld	r25, X
    8dea:	ad b7       	in	r26, 0x3d	; 61
    8dec:	be b7       	in	r27, 0x3e	; 62
    8dee:	12 96       	adiw	r26, 0x02	; 2
    8df0:	9c 93       	st	X, r25
    8df2:	8e 93       	st	-X, r24
    8df4:	11 97       	sbiw	r26, 0x01	; 1
    8df6:	8c e7       	ldi	r24, 0x7C	; 124
    8df8:	92 e0       	ldi	r25, 0x02	; 2
    8dfa:	93 83       	std	Z+3, r25	; 0x03
    8dfc:	82 83       	std	Z+2, r24	; 0x02
    8dfe:	64 83       	std	Z+4, r22	; 0x04
    8e00:	15 83       	std	Z+5, r17	; 0x05
    8e02:	56 83       	std	Z+6, r21	; 0x06
    8e04:	77 83       	std	Z+7, r23	; 0x07
    8e06:	0e 94 76 7b 	call	0xf6ec	; 0xf6ec <sprintf>
    8e0a:	8d b7       	in	r24, 0x3d	; 61
    8e0c:	9e b7       	in	r25, 0x3e	; 62
    8e0e:	08 96       	adiw	r24, 0x08	; 8
    8e10:	0f b6       	in	r0, 0x3f	; 63
    8e12:	f8 94       	cli
    8e14:	9e bf       	out	0x3e, r25	; 62
    8e16:	0f be       	out	0x3f, r0	; 63
    8e18:	8d bf       	out	0x3d, r24	; 61
}
    8e1a:	1f 91       	pop	r17
    8e1c:	08 95       	ret
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_zVal_h(uint32_t Val, char Type, T_Param *Param)
{
	if(Type=='b') sprintf(Param->Pos, "%02hx", (uint8_t)Val);
    8e1e:	00 d0       	rcall	.+0      	; 0x8e20 <Put_zVal_h+0x6c>
    8e20:	00 d0       	rcall	.+0      	; 0x8e22 <Put_zVal_h+0x6e>
    8e22:	ed b7       	in	r30, 0x3d	; 61
    8e24:	fe b7       	in	r31, 0x3e	; 62
    8e26:	31 96       	adiw	r30, 0x01	; 1
    8e28:	8d 91       	ld	r24, X+
    8e2a:	9c 91       	ld	r25, X
    8e2c:	ad b7       	in	r26, 0x3d	; 61
    8e2e:	be b7       	in	r27, 0x3e	; 62
    8e30:	12 96       	adiw	r26, 0x02	; 2
    8e32:	9c 93       	st	X, r25
    8e34:	8e 93       	st	-X, r24
    8e36:	11 97       	sbiw	r26, 0x01	; 1
    8e38:	81 e7       	ldi	r24, 0x71	; 113
    8e3a:	92 e0       	ldi	r25, 0x02	; 2
    8e3c:	93 83       	std	Z+3, r25	; 0x03
    8e3e:	82 83       	std	Z+2, r24	; 0x02
    8e40:	64 83       	std	Z+4, r22	; 0x04
    8e42:	15 82       	std	Z+5, r1	; 0x05
    8e44:	0e 94 76 7b 	call	0xf6ec	; 0xf6ec <sprintf>
    8e48:	8d b7       	in	r24, 0x3d	; 61
    8e4a:	9e b7       	in	r25, 0x3e	; 62
    8e4c:	06 96       	adiw	r24, 0x06	; 6
    8e4e:	0f b6       	in	r0, 0x3f	; 63
    8e50:	f8 94       	cli
    8e52:	9e bf       	out	0x3e, r25	; 62
    8e54:	0f be       	out	0x3f, r0	; 63
    8e56:	8d bf       	out	0x3d, r24	; 61
	if(Type=='w') sprintf(Param->Pos, "%04x", (uint16_t)Val);
	if(Type=='l') sprintf(Param->Pos, "%08lx", Val);
}
    8e58:	1f 91       	pop	r17
    8e5a:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_zVal_h(uint32_t Val, char Type, T_Param *Param)
{
	if(Type=='b') sprintf(Param->Pos, "%02hx", (uint8_t)Val);
	if(Type=='w') sprintf(Param->Pos, "%04x", (uint16_t)Val);
    8e5c:	00 d0       	rcall	.+0      	; 0x8e5e <Put_zVal_h+0xaa>
    8e5e:	00 d0       	rcall	.+0      	; 0x8e60 <Put_zVal_h+0xac>
    8e60:	ed b7       	in	r30, 0x3d	; 61
    8e62:	fe b7       	in	r31, 0x3e	; 62
    8e64:	31 96       	adiw	r30, 0x01	; 1
    8e66:	8d 91       	ld	r24, X+
    8e68:	9c 91       	ld	r25, X
    8e6a:	ad b7       	in	r26, 0x3d	; 61
    8e6c:	be b7       	in	r27, 0x3e	; 62
    8e6e:	12 96       	adiw	r26, 0x02	; 2
    8e70:	9c 93       	st	X, r25
    8e72:	8e 93       	st	-X, r24
    8e74:	11 97       	sbiw	r26, 0x01	; 1
    8e76:	87 e7       	ldi	r24, 0x77	; 119
    8e78:	92 e0       	ldi	r25, 0x02	; 2
    8e7a:	93 83       	std	Z+3, r25	; 0x03
    8e7c:	82 83       	std	Z+2, r24	; 0x02
    8e7e:	64 83       	std	Z+4, r22	; 0x04
    8e80:	15 83       	std	Z+5, r17	; 0x05
    8e82:	0e 94 76 7b 	call	0xf6ec	; 0xf6ec <sprintf>
    8e86:	8d b7       	in	r24, 0x3d	; 61
    8e88:	9e b7       	in	r25, 0x3e	; 62
    8e8a:	06 96       	adiw	r24, 0x06	; 6
    8e8c:	0f b6       	in	r0, 0x3f	; 63
    8e8e:	f8 94       	cli
    8e90:	9e bf       	out	0x3e, r25	; 62
    8e92:	0f be       	out	0x3f, r0	; 63
    8e94:	8d bf       	out	0x3d, r24	; 61
	if(Type=='l') sprintf(Param->Pos, "%08lx", Val);
}
    8e96:	1f 91       	pop	r17
    8e98:	08 95       	ret

00008e9a <Put_zVal>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_zVal(uint16_t Val, char Type, T_Param *Param)
{
    8e9a:	af 92       	push	r10
    8e9c:	bf 92       	push	r11
    8e9e:	cf 92       	push	r12
    8ea0:	df 92       	push	r13
    8ea2:	ef 92       	push	r14
    8ea4:	ff 92       	push	r15
    8ea6:	0f 93       	push	r16
    8ea8:	1f 93       	push	r17
    8eaa:	df 93       	push	r29
    8eac:	cf 93       	push	r28
    8eae:	cd b7       	in	r28, 0x3d	; 61
    8eb0:	de b7       	in	r29, 0x3e	; 62
    8eb2:	2a 97       	sbiw	r28, 0x0a	; 10
    8eb4:	0f b6       	in	r0, 0x3f	; 63
    8eb6:	f8 94       	cli
    8eb8:	de bf       	out	0x3e, r29	; 62
    8eba:	0f be       	out	0x3f, r0	; 63
    8ebc:	cd bf       	out	0x3d, r28	; 61
    8ebe:	6c 01       	movw	r12, r24
    8ec0:	7a 01       	movw	r14, r20
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
    8ec2:	67 37       	cpi	r22, 0x77	; 119
    8ec4:	09 f4       	brne	.+2      	; 0x8ec8 <Put_zVal+0x2e>
    8ec6:	79 c0       	rjmp	.+242    	; 0x8fba <Put_zVal+0x120>
    8ec8:	8f ef       	ldi	r24, 0xFF	; 255
    8eca:	90 e0       	ldi	r25, 0x00	; 0
	if(Param->Txt && Idx<2) {
    8ecc:	d7 01       	movw	r26, r14
    8ece:	14 96       	adiw	r26, 0x04	; 4
    8ed0:	2d 91       	ld	r18, X+
    8ed2:	3c 91       	ld	r19, X
    8ed4:	15 97       	sbiw	r26, 0x05	; 5
    8ed6:	21 15       	cp	r18, r1
    8ed8:	31 05       	cpc	r19, r1
    8eda:	31 f0       	breq	.+12     	; 0x8ee8 <Put_zVal+0x4e>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_zVal(uint16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
    8edc:	8c 19       	sub	r24, r12
    8ede:	9d 09       	sbc	r25, r13
	if(Param->Txt && Idx<2) {
    8ee0:	82 30       	cpi	r24, 0x02	; 2
    8ee2:	91 05       	cpc	r25, r1
    8ee4:	08 f4       	brcc	.+2      	; 0x8ee8 <Put_zVal+0x4e>
    8ee6:	8a c0       	rjmp	.+276    	; 0x8ffc <Put_zVal+0x162>
		Param->Txt += Idx;
		PutEnum(Param);
		return;
	}
	char Format[] = "%0 u.%. u";
    8ee8:	5e 01       	movw	r10, r28
    8eea:	08 94       	sec
    8eec:	a1 1c       	adc	r10, r1
    8eee:	b1 1c       	adc	r11, r1
    8ef0:	d5 01       	movw	r26, r10
    8ef2:	e2 e8       	ldi	r30, 0x82	; 130
    8ef4:	f2 e0       	ldi	r31, 0x02	; 2
    8ef6:	8a e0       	ldi	r24, 0x0A	; 10
    8ef8:	01 90       	ld	r0, Z+
    8efa:	0d 92       	st	X+, r0
    8efc:	81 50       	subi	r24, 0x01	; 1
    8efe:	e1 f7       	brne	.-8      	; 0x8ef8 <Put_zVal+0x5e>
	Format[2] = '0'+Param->Size;
    8f00:	f7 01       	movw	r30, r14
    8f02:	23 81       	ldd	r18, Z+3	; 0x03
    8f04:	20 5d       	subi	r18, 0xD0	; 208
    8f06:	2b 83       	std	Y+3, r18	; 0x03
	if(Param->Prec) {
    8f08:	92 81       	ldd	r25, Z+2	; 0x02
    8f0a:	99 23       	and	r25, r25
    8f0c:	09 f4       	brne	.+2      	; 0x8f10 <Put_zVal+0x76>
    8f0e:	58 c0       	rjmp	.+176    	; 0x8fc0 <Put_zVal+0x126>
		Format[2] -= Param->Prec+1;
    8f10:	89 2f       	mov	r24, r25
    8f12:	80 95       	com	r24
    8f14:	82 0f       	add	r24, r18
    8f16:	8b 83       	std	Y+3, r24	; 0x03
		Format[7] = '0'+Param->Prec;
    8f18:	90 5d       	subi	r25, 0xD0	; 208
    8f1a:	98 87       	std	Y+8, r25	; 0x08
    8f1c:	90 53       	subi	r25, 0x30	; 48
		uint16_t Div=Pow10(Param->Prec);
    8f1e:	29 2f       	mov	r18, r25
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    8f20:	01 e0       	ldi	r16, 0x01	; 1
    8f22:	10 e0       	ldi	r17, 0x00	; 0
		Pow *= 10;
    8f24:	c8 01       	movw	r24, r16
    8f26:	88 0f       	add	r24, r24
    8f28:	99 1f       	adc	r25, r25
    8f2a:	00 0f       	add	r16, r16
    8f2c:	11 1f       	adc	r17, r17
    8f2e:	00 0f       	add	r16, r16
    8f30:	11 1f       	adc	r17, r17
    8f32:	00 0f       	add	r16, r16
    8f34:	11 1f       	adc	r17, r17
    8f36:	08 0f       	add	r16, r24
    8f38:	19 1f       	adc	r17, r25
    8f3a:	21 50       	subi	r18, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    8f3c:	99 f7       	brne	.-26     	; 0x8f24 <Put_zVal+0x8a>
    8f3e:	c6 01       	movw	r24, r12
    8f40:	b8 01       	movw	r22, r16
    8f42:	0e 94 0b 7e 	call	0xfc16	; 0xfc16 <__udivmodhi4>
    8f46:	9c 01       	movw	r18, r24
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
    8f48:	8d b7       	in	r24, 0x3d	; 61
    8f4a:	9e b7       	in	r25, 0x3e	; 62
    8f4c:	08 97       	sbiw	r24, 0x08	; 8
    8f4e:	0f b6       	in	r0, 0x3f	; 63
    8f50:	f8 94       	cli
    8f52:	9e bf       	out	0x3e, r25	; 62
    8f54:	0f be       	out	0x3f, r0	; 63
    8f56:	8d bf       	out	0x3d, r24	; 61
    8f58:	ed b7       	in	r30, 0x3d	; 61
    8f5a:	fe b7       	in	r31, 0x3e	; 62
    8f5c:	31 96       	adiw	r30, 0x01	; 1
    8f5e:	d7 01       	movw	r26, r14
    8f60:	8d 91       	ld	r24, X+
    8f62:	9c 91       	ld	r25, X
    8f64:	ad b7       	in	r26, 0x3d	; 61
    8f66:	be b7       	in	r27, 0x3e	; 62
    8f68:	12 96       	adiw	r26, 0x02	; 2
    8f6a:	9c 93       	st	X, r25
    8f6c:	8e 93       	st	-X, r24
    8f6e:	11 97       	sbiw	r26, 0x01	; 1
    8f70:	b3 82       	std	Z+3, r11	; 0x03
    8f72:	a2 82       	std	Z+2, r10	; 0x02
    8f74:	c6 01       	movw	r24, r12
    8f76:	b8 01       	movw	r22, r16
    8f78:	0e 94 0b 7e 	call	0xfc16	; 0xfc16 <__udivmodhi4>
    8f7c:	75 83       	std	Z+5, r23	; 0x05
    8f7e:	64 83       	std	Z+4, r22	; 0x04
    8f80:	26 83       	std	Z+6, r18	; 0x06
    8f82:	37 83       	std	Z+7, r19	; 0x07
    8f84:	0e 94 76 7b 	call	0xf6ec	; 0xf6ec <sprintf>
    8f88:	ed b7       	in	r30, 0x3d	; 61
    8f8a:	fe b7       	in	r31, 0x3e	; 62
    8f8c:	38 96       	adiw	r30, 0x08	; 8
    8f8e:	0f b6       	in	r0, 0x3f	; 63
    8f90:	f8 94       	cli
    8f92:	fe bf       	out	0x3e, r31	; 62
    8f94:	0f be       	out	0x3f, r0	; 63
    8f96:	ed bf       	out	0x3d, r30	; 61
	}
	else {
		Format[4] = '\0';
		sprintf(Param->Pos, Format, Val);
	}
}
    8f98:	2a 96       	adiw	r28, 0x0a	; 10
    8f9a:	0f b6       	in	r0, 0x3f	; 63
    8f9c:	f8 94       	cli
    8f9e:	de bf       	out	0x3e, r29	; 62
    8fa0:	0f be       	out	0x3f, r0	; 63
    8fa2:	cd bf       	out	0x3d, r28	; 61
    8fa4:	cf 91       	pop	r28
    8fa6:	df 91       	pop	r29
    8fa8:	1f 91       	pop	r17
    8faa:	0f 91       	pop	r16
    8fac:	ff 90       	pop	r15
    8fae:	ef 90       	pop	r14
    8fb0:	df 90       	pop	r13
    8fb2:	cf 90       	pop	r12
    8fb4:	bf 90       	pop	r11
    8fb6:	af 90       	pop	r10
    8fb8:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_zVal(uint16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
    8fba:	8f ef       	ldi	r24, 0xFF	; 255
    8fbc:	9f ef       	ldi	r25, 0xFF	; 255
    8fbe:	86 cf       	rjmp	.-244    	; 0x8ecc <Put_zVal+0x32>
		Format[7] = '0'+Param->Prec;
		uint16_t Div=Pow10(Param->Prec);
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
	}
	else {
		Format[4] = '\0';
    8fc0:	1d 82       	std	Y+5, r1	; 0x05
		sprintf(Param->Pos, Format, Val);
    8fc2:	00 d0       	rcall	.+0      	; 0x8fc4 <Put_zVal+0x12a>
    8fc4:	00 d0       	rcall	.+0      	; 0x8fc6 <Put_zVal+0x12c>
    8fc6:	ed b7       	in	r30, 0x3d	; 61
    8fc8:	fe b7       	in	r31, 0x3e	; 62
    8fca:	31 96       	adiw	r30, 0x01	; 1
    8fcc:	d7 01       	movw	r26, r14
    8fce:	8d 91       	ld	r24, X+
    8fd0:	9c 91       	ld	r25, X
    8fd2:	ad b7       	in	r26, 0x3d	; 61
    8fd4:	be b7       	in	r27, 0x3e	; 62
    8fd6:	12 96       	adiw	r26, 0x02	; 2
    8fd8:	9c 93       	st	X, r25
    8fda:	8e 93       	st	-X, r24
    8fdc:	11 97       	sbiw	r26, 0x01	; 1
    8fde:	b3 82       	std	Z+3, r11	; 0x03
    8fe0:	a2 82       	std	Z+2, r10	; 0x02
    8fe2:	d5 82       	std	Z+5, r13	; 0x05
    8fe4:	c4 82       	std	Z+4, r12	; 0x04
    8fe6:	0e 94 76 7b 	call	0xf6ec	; 0xf6ec <sprintf>
    8fea:	ed b7       	in	r30, 0x3d	; 61
    8fec:	fe b7       	in	r31, 0x3e	; 62
    8fee:	36 96       	adiw	r30, 0x06	; 6
    8ff0:	0f b6       	in	r0, 0x3f	; 63
    8ff2:	f8 94       	cli
    8ff4:	fe bf       	out	0x3e, r31	; 62
    8ff6:	0f be       	out	0x3f, r0	; 63
    8ff8:	ed bf       	out	0x3d, r30	; 61
    8ffa:	ce cf       	rjmp	.-100    	; 0x8f98 <Put_zVal+0xfe>
void
Put_zVal(uint16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
	if(Param->Txt && Idx<2) {
		Param->Txt += Idx;
    8ffc:	88 0f       	add	r24, r24
    8ffe:	99 1f       	adc	r25, r25
    9000:	28 0f       	add	r18, r24
    9002:	39 1f       	adc	r19, r25
    9004:	15 96       	adiw	r26, 0x05	; 5
    9006:	3c 93       	st	X, r19
    9008:	2e 93       	st	-X, r18
    900a:	14 97       	sbiw	r26, 0x04	; 4
		PutEnum(Param);
    900c:	c7 01       	movw	r24, r14
    900e:	0e 94 f0 3f 	call	0x7fe0	; 0x7fe0 <PutEnum>
    9012:	c2 cf       	rjmp	.-124    	; 0x8f98 <Put_zVal+0xfe>

00009014 <Put_sVal>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_sVal(int16_t Val, char Type, T_Param *Param)
{
    9014:	af 92       	push	r10
    9016:	bf 92       	push	r11
    9018:	cf 92       	push	r12
    901a:	df 92       	push	r13
    901c:	ef 92       	push	r14
    901e:	ff 92       	push	r15
    9020:	0f 93       	push	r16
    9022:	1f 93       	push	r17
    9024:	df 93       	push	r29
    9026:	cf 93       	push	r28
    9028:	cd b7       	in	r28, 0x3d	; 61
    902a:	de b7       	in	r29, 0x3e	; 62
    902c:	2a 97       	sbiw	r28, 0x0a	; 10
    902e:	0f b6       	in	r0, 0x3f	; 63
    9030:	f8 94       	cli
    9032:	de bf       	out	0x3e, r29	; 62
    9034:	0f be       	out	0x3f, r0	; 63
    9036:	cd bf       	out	0x3d, r28	; 61
    9038:	6c 01       	movw	r12, r24
    903a:	7a 01       	movw	r14, r20
	uint16_t Idx = (Type=='w'?0x8000:0x80)+Val;
    903c:	67 37       	cpi	r22, 0x77	; 119
    903e:	09 f4       	brne	.+2      	; 0x9042 <Put_sVal+0x2e>
    9040:	81 c0       	rjmp	.+258    	; 0x9144 <Put_sVal+0x130>
    9042:	80 e8       	ldi	r24, 0x80	; 128
    9044:	90 e0       	ldi	r25, 0x00	; 0
	if(Param->Txt && Idx<2) {
    9046:	d7 01       	movw	r26, r14
    9048:	14 96       	adiw	r26, 0x04	; 4
    904a:	2d 91       	ld	r18, X+
    904c:	3c 91       	ld	r19, X
    904e:	15 97       	sbiw	r26, 0x05	; 5
    9050:	21 15       	cp	r18, r1
    9052:	31 05       	cpc	r19, r1
    9054:	31 f0       	breq	.+12     	; 0x9062 <Put_sVal+0x4e>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_sVal(int16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0x8000:0x80)+Val;
    9056:	8c 0d       	add	r24, r12
    9058:	9d 1d       	adc	r25, r13
	if(Param->Txt && Idx<2) {
    905a:	82 30       	cpi	r24, 0x02	; 2
    905c:	91 05       	cpc	r25, r1
    905e:	08 f4       	brcc	.+2      	; 0x9062 <Put_sVal+0x4e>
    9060:	ac c0       	rjmp	.+344    	; 0x91ba <Put_sVal+0x1a6>
		Param->Txt += Idx;
		PutEnum(Param);
		return;
	}
	char Format[] = "%+ d.%. u";
    9062:	5e 01       	movw	r10, r28
    9064:	08 94       	sec
    9066:	a1 1c       	adc	r10, r1
    9068:	b1 1c       	adc	r11, r1
    906a:	d5 01       	movw	r26, r10
    906c:	ec e8       	ldi	r30, 0x8C	; 140
    906e:	f2 e0       	ldi	r31, 0x02	; 2
    9070:	8a e0       	ldi	r24, 0x0A	; 10
    9072:	01 90       	ld	r0, Z+
    9074:	0d 92       	st	X+, r0
    9076:	81 50       	subi	r24, 0x01	; 1
    9078:	e1 f7       	brne	.-8      	; 0x9072 <Put_sVal+0x5e>
	if(Val==0)
    907a:	c1 14       	cp	r12, r1
    907c:	d1 04       	cpc	r13, r1
    907e:	09 f4       	brne	.+2      	; 0x9082 <Put_sVal+0x6e>
    9080:	64 c0       	rjmp	.+200    	; 0x914a <Put_sVal+0x136>
		Format[1] = ' ';
	Format[2] = '0'+Param->Size;
    9082:	f7 01       	movw	r30, r14
    9084:	23 81       	ldd	r18, Z+3	; 0x03
    9086:	20 5d       	subi	r18, 0xD0	; 208
    9088:	2b 83       	std	Y+3, r18	; 0x03
	if(Param->Prec) {
    908a:	92 81       	ldd	r25, Z+2	; 0x02
    908c:	99 23       	and	r25, r25
    908e:	09 f4       	brne	.+2      	; 0x9092 <Put_sVal+0x7e>
    9090:	66 c0       	rjmp	.+204    	; 0x915e <Put_sVal+0x14a>
		Format[2] -= Param->Prec+1;
    9092:	89 2f       	mov	r24, r25
    9094:	80 95       	com	r24
    9096:	82 0f       	add	r24, r18
    9098:	8b 83       	std	Y+3, r24	; 0x03
		Format[7] = '0'+Param->Prec;
    909a:	90 5d       	subi	r25, 0xD0	; 208
    909c:	98 87       	std	Y+8, r25	; 0x08
    909e:	90 53       	subi	r25, 0x30	; 48
		int16_t Div=Pow10(Param->Prec);
    90a0:	29 2f       	mov	r18, r25
    90a2:	01 e0       	ldi	r16, 0x01	; 1
    90a4:	10 e0       	ldi	r17, 0x00	; 0
		Pow *= 10;
    90a6:	c8 01       	movw	r24, r16
    90a8:	88 0f       	add	r24, r24
    90aa:	99 1f       	adc	r25, r25
    90ac:	00 0f       	add	r16, r16
    90ae:	11 1f       	adc	r17, r17
    90b0:	00 0f       	add	r16, r16
    90b2:	11 1f       	adc	r17, r17
    90b4:	00 0f       	add	r16, r16
    90b6:	11 1f       	adc	r17, r17
    90b8:	08 0f       	add	r16, r24
    90ba:	19 1f       	adc	r17, r25
    90bc:	21 50       	subi	r18, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    90be:	99 f7       	brne	.-26     	; 0x90a6 <Put_sVal+0x92>
    90c0:	c6 01       	movw	r24, r12
    90c2:	d7 fc       	sbrc	r13, 7
    90c4:	86 c0       	rjmp	.+268    	; 0x91d2 <Put_sVal+0x1be>
    90c6:	b8 01       	movw	r22, r16
    90c8:	0e 94 0b 7e 	call	0xfc16	; 0xfc16 <__udivmodhi4>
    90cc:	9c 01       	movw	r18, r24
		sprintf(Param->Pos, Format, Val/Div, (uint16_t)abs(Val)%Div);
    90ce:	8d b7       	in	r24, 0x3d	; 61
    90d0:	9e b7       	in	r25, 0x3e	; 62
    90d2:	08 97       	sbiw	r24, 0x08	; 8
    90d4:	0f b6       	in	r0, 0x3f	; 63
    90d6:	f8 94       	cli
    90d8:	9e bf       	out	0x3e, r25	; 62
    90da:	0f be       	out	0x3f, r0	; 63
    90dc:	8d bf       	out	0x3d, r24	; 61
    90de:	ed b7       	in	r30, 0x3d	; 61
    90e0:	fe b7       	in	r31, 0x3e	; 62
    90e2:	31 96       	adiw	r30, 0x01	; 1
    90e4:	d7 01       	movw	r26, r14
    90e6:	8d 91       	ld	r24, X+
    90e8:	9c 91       	ld	r25, X
    90ea:	ad b7       	in	r26, 0x3d	; 61
    90ec:	be b7       	in	r27, 0x3e	; 62
    90ee:	12 96       	adiw	r26, 0x02	; 2
    90f0:	9c 93       	st	X, r25
    90f2:	8e 93       	st	-X, r24
    90f4:	11 97       	sbiw	r26, 0x01	; 1
    90f6:	b3 82       	std	Z+3, r11	; 0x03
    90f8:	a2 82       	std	Z+2, r10	; 0x02
    90fa:	c6 01       	movw	r24, r12
    90fc:	b8 01       	movw	r22, r16
    90fe:	0e 94 1f 7e 	call	0xfc3e	; 0xfc3e <__divmodhi4>
    9102:	75 83       	std	Z+5, r23	; 0x05
    9104:	64 83       	std	Z+4, r22	; 0x04
    9106:	26 83       	std	Z+6, r18	; 0x06
    9108:	37 83       	std	Z+7, r19	; 0x07
    910a:	0e 94 76 7b 	call	0xf6ec	; 0xf6ec <sprintf>
		if(Val<0) {
    910e:	ed b7       	in	r30, 0x3d	; 61
    9110:	fe b7       	in	r31, 0x3e	; 62
    9112:	38 96       	adiw	r30, 0x08	; 8
    9114:	0f b6       	in	r0, 0x3f	; 63
    9116:	f8 94       	cli
    9118:	fe bf       	out	0x3e, r31	; 62
    911a:	0f be       	out	0x3f, r0	; 63
    911c:	ed bf       	out	0x3d, r30	; 61
    911e:	d7 fc       	sbrc	r13, 7
    9120:	3c c0       	rjmp	.+120    	; 0x919a <Put_sVal+0x186>
	}
	else {
		Format[4] = '\0';
		sprintf(Param->Pos, Format, Val);
	}
}
    9122:	2a 96       	adiw	r28, 0x0a	; 10
    9124:	0f b6       	in	r0, 0x3f	; 63
    9126:	f8 94       	cli
    9128:	de bf       	out	0x3e, r29	; 62
    912a:	0f be       	out	0x3f, r0	; 63
    912c:	cd bf       	out	0x3d, r28	; 61
    912e:	cf 91       	pop	r28
    9130:	df 91       	pop	r29
    9132:	1f 91       	pop	r17
    9134:	0f 91       	pop	r16
    9136:	ff 90       	pop	r15
    9138:	ef 90       	pop	r14
    913a:	df 90       	pop	r13
    913c:	cf 90       	pop	r12
    913e:	bf 90       	pop	r11
    9140:	af 90       	pop	r10
    9142:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_sVal(int16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0x8000:0x80)+Val;
    9144:	80 e0       	ldi	r24, 0x00	; 0
    9146:	90 e8       	ldi	r25, 0x80	; 128
    9148:	7e cf       	rjmp	.-260    	; 0x9046 <Put_sVal+0x32>
		PutEnum(Param);
		return;
	}
	char Format[] = "%+ d.%. u";
	if(Val==0)
		Format[1] = ' ';
    914a:	80 e2       	ldi	r24, 0x20	; 32
    914c:	8a 83       	std	Y+2, r24	; 0x02
	Format[2] = '0'+Param->Size;
    914e:	f7 01       	movw	r30, r14
    9150:	23 81       	ldd	r18, Z+3	; 0x03
    9152:	20 5d       	subi	r18, 0xD0	; 208
    9154:	2b 83       	std	Y+3, r18	; 0x03
	if(Param->Prec) {
    9156:	92 81       	ldd	r25, Z+2	; 0x02
    9158:	99 23       	and	r25, r25
    915a:	09 f0       	breq	.+2      	; 0x915e <Put_sVal+0x14a>
    915c:	9a cf       	rjmp	.-204    	; 0x9092 <Put_sVal+0x7e>
				Param->Pos++;
			*Param->Pos = '-';
		}
	}
	else {
		Format[4] = '\0';
    915e:	1d 82       	std	Y+5, r1	; 0x05
		sprintf(Param->Pos, Format, Val);
    9160:	00 d0       	rcall	.+0      	; 0x9162 <Put_sVal+0x14e>
    9162:	00 d0       	rcall	.+0      	; 0x9164 <Put_sVal+0x150>
    9164:	ed b7       	in	r30, 0x3d	; 61
    9166:	fe b7       	in	r31, 0x3e	; 62
    9168:	31 96       	adiw	r30, 0x01	; 1
    916a:	d7 01       	movw	r26, r14
    916c:	8d 91       	ld	r24, X+
    916e:	9c 91       	ld	r25, X
    9170:	ad b7       	in	r26, 0x3d	; 61
    9172:	be b7       	in	r27, 0x3e	; 62
    9174:	12 96       	adiw	r26, 0x02	; 2
    9176:	9c 93       	st	X, r25
    9178:	8e 93       	st	-X, r24
    917a:	11 97       	sbiw	r26, 0x01	; 1
    917c:	b3 82       	std	Z+3, r11	; 0x03
    917e:	a2 82       	std	Z+2, r10	; 0x02
    9180:	d5 82       	std	Z+5, r13	; 0x05
    9182:	c4 82       	std	Z+4, r12	; 0x04
    9184:	0e 94 76 7b 	call	0xf6ec	; 0xf6ec <sprintf>
    9188:	ed b7       	in	r30, 0x3d	; 61
    918a:	fe b7       	in	r31, 0x3e	; 62
    918c:	36 96       	adiw	r30, 0x06	; 6
    918e:	0f b6       	in	r0, 0x3f	; 63
    9190:	f8 94       	cli
    9192:	fe bf       	out	0x3e, r31	; 62
    9194:	0f be       	out	0x3f, r0	; 63
    9196:	ed bf       	out	0x3d, r30	; 61
    9198:	c4 cf       	rjmp	.-120    	; 0x9122 <Put_sVal+0x10e>
		Format[2] -= Param->Prec+1;
		Format[7] = '0'+Param->Prec;
		int16_t Div=Pow10(Param->Prec);
		sprintf(Param->Pos, Format, Val/Div, (uint16_t)abs(Val)%Div);
		if(Val<0) {
			while(*Param->Pos==' ')
    919a:	d7 01       	movw	r26, r14
    919c:	ed 91       	ld	r30, X+
    919e:	fc 91       	ld	r31, X
    91a0:	80 81       	ld	r24, Z
    91a2:	80 32       	cpi	r24, 0x20	; 32
    91a4:	39 f4       	brne	.+14     	; 0x91b4 <Put_sVal+0x1a0>
				Param->Pos++;
    91a6:	31 96       	adiw	r30, 0x01	; 1
    91a8:	d7 01       	movw	r26, r14
    91aa:	ed 93       	st	X+, r30
    91ac:	fc 93       	st	X, r31
		Format[2] -= Param->Prec+1;
		Format[7] = '0'+Param->Prec;
		int16_t Div=Pow10(Param->Prec);
		sprintf(Param->Pos, Format, Val/Div, (uint16_t)abs(Val)%Div);
		if(Val<0) {
			while(*Param->Pos==' ')
    91ae:	80 81       	ld	r24, Z
    91b0:	80 32       	cpi	r24, 0x20	; 32
    91b2:	c9 f3       	breq	.-14     	; 0x91a6 <Put_sVal+0x192>
				Param->Pos++;
			*Param->Pos = '-';
    91b4:	8d e2       	ldi	r24, 0x2D	; 45
    91b6:	80 83       	st	Z, r24
    91b8:	b4 cf       	rjmp	.-152    	; 0x9122 <Put_sVal+0x10e>
void
Put_sVal(int16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0x8000:0x80)+Val;
	if(Param->Txt && Idx<2) {
		Param->Txt += Idx;
    91ba:	88 0f       	add	r24, r24
    91bc:	99 1f       	adc	r25, r25
    91be:	28 0f       	add	r18, r24
    91c0:	39 1f       	adc	r19, r25
    91c2:	15 96       	adiw	r26, 0x05	; 5
    91c4:	3c 93       	st	X, r19
    91c6:	2e 93       	st	-X, r18
    91c8:	14 97       	sbiw	r26, 0x04	; 4
		PutEnum(Param);
    91ca:	c7 01       	movw	r24, r14
    91cc:	0e 94 f0 3f 	call	0x7fe0	; 0x7fe0 <PutEnum>
    91d0:	a8 cf       	rjmp	.-176    	; 0x9122 <Put_sVal+0x10e>
    91d2:	88 27       	eor	r24, r24
    91d4:	99 27       	eor	r25, r25
    91d6:	8c 19       	sub	r24, r12
    91d8:	9d 09       	sbc	r25, r13
    91da:	75 cf       	rjmp	.-278    	; 0x90c6 <Put_sVal+0xb2>

000091dc <PutVal>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
PutVal(uint16_t Val, char Type, T_Param *Param)
{
    91dc:	af 92       	push	r10
    91de:	bf 92       	push	r11
    91e0:	cf 92       	push	r12
    91e2:	df 92       	push	r13
    91e4:	ef 92       	push	r14
    91e6:	ff 92       	push	r15
    91e8:	0f 93       	push	r16
    91ea:	1f 93       	push	r17
    91ec:	df 93       	push	r29
    91ee:	cf 93       	push	r28
    91f0:	cd b7       	in	r28, 0x3d	; 61
    91f2:	de b7       	in	r29, 0x3e	; 62
    91f4:	29 97       	sbiw	r28, 0x09	; 9
    91f6:	0f b6       	in	r0, 0x3f	; 63
    91f8:	f8 94       	cli
    91fa:	de bf       	out	0x3e, r29	; 62
    91fc:	0f be       	out	0x3f, r0	; 63
    91fe:	cd bf       	out	0x3d, r28	; 61
    9200:	6c 01       	movw	r12, r24
    9202:	7a 01       	movw	r14, r20
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
    9204:	67 37       	cpi	r22, 0x77	; 119
    9206:	09 f4       	brne	.+2      	; 0x920a <PutVal+0x2e>
    9208:	79 c0       	rjmp	.+242    	; 0x92fc <PutVal+0x120>
    920a:	8f ef       	ldi	r24, 0xFF	; 255
    920c:	90 e0       	ldi	r25, 0x00	; 0
	if(Param->Txt && Idx<2) {
    920e:	d7 01       	movw	r26, r14
    9210:	14 96       	adiw	r26, 0x04	; 4
    9212:	2d 91       	ld	r18, X+
    9214:	3c 91       	ld	r19, X
    9216:	15 97       	sbiw	r26, 0x05	; 5
    9218:	21 15       	cp	r18, r1
    921a:	31 05       	cpc	r19, r1
    921c:	31 f0       	breq	.+12     	; 0x922a <PutVal+0x4e>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
PutVal(uint16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
    921e:	8c 19       	sub	r24, r12
    9220:	9d 09       	sbc	r25, r13
	if(Param->Txt && Idx<2) {
    9222:	82 30       	cpi	r24, 0x02	; 2
    9224:	91 05       	cpc	r25, r1
    9226:	08 f4       	brcc	.+2      	; 0x922a <PutVal+0x4e>
    9228:	8a c0       	rjmp	.+276    	; 0x933e <PutVal+0x162>
		Param->Txt += Idx;
		PutEnum(Param);
		return;
	}
	char Format[] = "% u.%. u";
    922a:	5e 01       	movw	r10, r28
    922c:	08 94       	sec
    922e:	a1 1c       	adc	r10, r1
    9230:	b1 1c       	adc	r11, r1
    9232:	d5 01       	movw	r26, r10
    9234:	e6 e9       	ldi	r30, 0x96	; 150
    9236:	f2 e0       	ldi	r31, 0x02	; 2
    9238:	89 e0       	ldi	r24, 0x09	; 9
    923a:	01 90       	ld	r0, Z+
    923c:	0d 92       	st	X+, r0
    923e:	81 50       	subi	r24, 0x01	; 1
    9240:	e1 f7       	brne	.-8      	; 0x923a <PutVal+0x5e>
	Format[1] = '0'+Param->Size;
    9242:	f7 01       	movw	r30, r14
    9244:	23 81       	ldd	r18, Z+3	; 0x03
    9246:	20 5d       	subi	r18, 0xD0	; 208
    9248:	2a 83       	std	Y+2, r18	; 0x02
	if(Param->Prec) {
    924a:	92 81       	ldd	r25, Z+2	; 0x02
    924c:	99 23       	and	r25, r25
    924e:	09 f4       	brne	.+2      	; 0x9252 <PutVal+0x76>
    9250:	58 c0       	rjmp	.+176    	; 0x9302 <PutVal+0x126>
		Format[1] -= Param->Prec+1;
    9252:	89 2f       	mov	r24, r25
    9254:	80 95       	com	r24
    9256:	82 0f       	add	r24, r18
    9258:	8a 83       	std	Y+2, r24	; 0x02
		Format[6] = '0'+Param->Prec;
    925a:	90 5d       	subi	r25, 0xD0	; 208
    925c:	9f 83       	std	Y+7, r25	; 0x07
    925e:	90 53       	subi	r25, 0x30	; 48
		uint16_t Div=Pow10(Param->Prec);
    9260:	29 2f       	mov	r18, r25
    9262:	01 e0       	ldi	r16, 0x01	; 1
    9264:	10 e0       	ldi	r17, 0x00	; 0
		Pow *= 10;
    9266:	c8 01       	movw	r24, r16
    9268:	88 0f       	add	r24, r24
    926a:	99 1f       	adc	r25, r25
    926c:	00 0f       	add	r16, r16
    926e:	11 1f       	adc	r17, r17
    9270:	00 0f       	add	r16, r16
    9272:	11 1f       	adc	r17, r17
    9274:	00 0f       	add	r16, r16
    9276:	11 1f       	adc	r17, r17
    9278:	08 0f       	add	r16, r24
    927a:	19 1f       	adc	r17, r25
    927c:	21 50       	subi	r18, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    927e:	99 f7       	brne	.-26     	; 0x9266 <PutVal+0x8a>
    9280:	c6 01       	movw	r24, r12
    9282:	b8 01       	movw	r22, r16
    9284:	0e 94 0b 7e 	call	0xfc16	; 0xfc16 <__udivmodhi4>
    9288:	9c 01       	movw	r18, r24
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
    928a:	8d b7       	in	r24, 0x3d	; 61
    928c:	9e b7       	in	r25, 0x3e	; 62
    928e:	08 97       	sbiw	r24, 0x08	; 8
    9290:	0f b6       	in	r0, 0x3f	; 63
    9292:	f8 94       	cli
    9294:	9e bf       	out	0x3e, r25	; 62
    9296:	0f be       	out	0x3f, r0	; 63
    9298:	8d bf       	out	0x3d, r24	; 61
    929a:	ed b7       	in	r30, 0x3d	; 61
    929c:	fe b7       	in	r31, 0x3e	; 62
    929e:	31 96       	adiw	r30, 0x01	; 1
    92a0:	d7 01       	movw	r26, r14
    92a2:	8d 91       	ld	r24, X+
    92a4:	9c 91       	ld	r25, X
    92a6:	ad b7       	in	r26, 0x3d	; 61
    92a8:	be b7       	in	r27, 0x3e	; 62
    92aa:	12 96       	adiw	r26, 0x02	; 2
    92ac:	9c 93       	st	X, r25
    92ae:	8e 93       	st	-X, r24
    92b0:	11 97       	sbiw	r26, 0x01	; 1
    92b2:	b3 82       	std	Z+3, r11	; 0x03
    92b4:	a2 82       	std	Z+2, r10	; 0x02
    92b6:	c6 01       	movw	r24, r12
    92b8:	b8 01       	movw	r22, r16
    92ba:	0e 94 0b 7e 	call	0xfc16	; 0xfc16 <__udivmodhi4>
    92be:	75 83       	std	Z+5, r23	; 0x05
    92c0:	64 83       	std	Z+4, r22	; 0x04
    92c2:	26 83       	std	Z+6, r18	; 0x06
    92c4:	37 83       	std	Z+7, r19	; 0x07
    92c6:	0e 94 76 7b 	call	0xf6ec	; 0xf6ec <sprintf>
    92ca:	ed b7       	in	r30, 0x3d	; 61
    92cc:	fe b7       	in	r31, 0x3e	; 62
    92ce:	38 96       	adiw	r30, 0x08	; 8
    92d0:	0f b6       	in	r0, 0x3f	; 63
    92d2:	f8 94       	cli
    92d4:	fe bf       	out	0x3e, r31	; 62
    92d6:	0f be       	out	0x3f, r0	; 63
    92d8:	ed bf       	out	0x3d, r30	; 61
	}
	else {
		Format[3] = '\0';
		sprintf(Param->Pos, Format, Val);
	}
}
    92da:	29 96       	adiw	r28, 0x09	; 9
    92dc:	0f b6       	in	r0, 0x3f	; 63
    92de:	f8 94       	cli
    92e0:	de bf       	out	0x3e, r29	; 62
    92e2:	0f be       	out	0x3f, r0	; 63
    92e4:	cd bf       	out	0x3d, r28	; 61
    92e6:	cf 91       	pop	r28
    92e8:	df 91       	pop	r29
    92ea:	1f 91       	pop	r17
    92ec:	0f 91       	pop	r16
    92ee:	ff 90       	pop	r15
    92f0:	ef 90       	pop	r14
    92f2:	df 90       	pop	r13
    92f4:	cf 90       	pop	r12
    92f6:	bf 90       	pop	r11
    92f8:	af 90       	pop	r10
    92fa:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
PutVal(uint16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
    92fc:	8f ef       	ldi	r24, 0xFF	; 255
    92fe:	9f ef       	ldi	r25, 0xFF	; 255
    9300:	86 cf       	rjmp	.-244    	; 0x920e <PutVal+0x32>
		Format[6] = '0'+Param->Prec;
		uint16_t Div=Pow10(Param->Prec);
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
	}
	else {
		Format[3] = '\0';
    9302:	1c 82       	std	Y+4, r1	; 0x04
		sprintf(Param->Pos, Format, Val);
    9304:	00 d0       	rcall	.+0      	; 0x9306 <PutVal+0x12a>
    9306:	00 d0       	rcall	.+0      	; 0x9308 <PutVal+0x12c>
    9308:	ed b7       	in	r30, 0x3d	; 61
    930a:	fe b7       	in	r31, 0x3e	; 62
    930c:	31 96       	adiw	r30, 0x01	; 1
    930e:	d7 01       	movw	r26, r14
    9310:	8d 91       	ld	r24, X+
    9312:	9c 91       	ld	r25, X
    9314:	ad b7       	in	r26, 0x3d	; 61
    9316:	be b7       	in	r27, 0x3e	; 62
    9318:	12 96       	adiw	r26, 0x02	; 2
    931a:	9c 93       	st	X, r25
    931c:	8e 93       	st	-X, r24
    931e:	11 97       	sbiw	r26, 0x01	; 1
    9320:	b3 82       	std	Z+3, r11	; 0x03
    9322:	a2 82       	std	Z+2, r10	; 0x02
    9324:	d5 82       	std	Z+5, r13	; 0x05
    9326:	c4 82       	std	Z+4, r12	; 0x04
    9328:	0e 94 76 7b 	call	0xf6ec	; 0xf6ec <sprintf>
    932c:	ed b7       	in	r30, 0x3d	; 61
    932e:	fe b7       	in	r31, 0x3e	; 62
    9330:	36 96       	adiw	r30, 0x06	; 6
    9332:	0f b6       	in	r0, 0x3f	; 63
    9334:	f8 94       	cli
    9336:	fe bf       	out	0x3e, r31	; 62
    9338:	0f be       	out	0x3f, r0	; 63
    933a:	ed bf       	out	0x3d, r30	; 61
    933c:	ce cf       	rjmp	.-100    	; 0x92da <PutVal+0xfe>
void
PutVal(uint16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
	if(Param->Txt && Idx<2) {
		Param->Txt += Idx;
    933e:	88 0f       	add	r24, r24
    9340:	99 1f       	adc	r25, r25
    9342:	28 0f       	add	r18, r24
    9344:	39 1f       	adc	r19, r25
    9346:	15 96       	adiw	r26, 0x05	; 5
    9348:	3c 93       	st	X, r19
    934a:	2e 93       	st	-X, r18
    934c:	14 97       	sbiw	r26, 0x04	; 4
		PutEnum(Param);
    934e:	c7 01       	movw	r24, r14
    9350:	0e 94 f0 3f 	call	0x7fe0	; 0x7fe0 <PutEnum>
    9354:	c2 cf       	rjmp	.-124    	; 0x92da <PutVal+0xfe>

00009356 <GSM_Wait_Response_P>:
//	}
	if(strcmp(GSM_RxStr, Str))return 0;
	else return 1;
}
// ~~~~~~~~~
uint8_t GSM_Wait_Response_P(prog_char *Str_P, uint8_t RestoreCMD){
    9356:	1f 93       	push	r17
    9358:	cf 93       	push	r28
    935a:	df 93       	push	r29
    935c:	ec 01       	movw	r28, r24
    935e:	16 2f       	mov	r17, r22
	
	if(Timer16Stopp(TD_GSM) && RestoreCMD){
    9360:	80 91 e1 04 	lds	r24, 0x04E1
    9364:	0e 94 59 1b 	call	0x36b2	; 0x36b2 <Timer16Stopp>
    9368:	88 23       	and	r24, r24
    936a:	11 f0       	breq	.+4      	; 0x9370 <GSM_Wait_Response_P+0x1a>
    936c:	11 23       	and	r17, r17
    936e:	51 f4       	brne	.+20     	; 0x9384 <GSM_Wait_Response_P+0x2e>
		GSM_State = RestoreCMD;
		return 0;
	}
	//  
	if(GetStringFromFIFO()){
    9370:	0e 94 d3 37 	call	0x6fa6	; 0x6fa6 <GetStringFromFIFO>
    9374:	88 23       	and	r24, r24
    9376:	71 f4       	brne	.+28     	; 0x9394 <GSM_Wait_Response_P+0x3e>
    9378:	20 e0       	ldi	r18, 0x00	; 0
		if(strcmp_P(GSM_RxStr, Str_P)) return 0;
		else return 1;
	}
	else return 0;
}
    937a:	82 2f       	mov	r24, r18
    937c:	df 91       	pop	r29
    937e:	cf 91       	pop	r28
    9380:	1f 91       	pop	r17
    9382:	08 95       	ret
}
// ~~~~~~~~~
uint8_t GSM_Wait_Response_P(prog_char *Str_P, uint8_t RestoreCMD){
	
	if(Timer16Stopp(TD_GSM) && RestoreCMD){
		GSM_State = RestoreCMD;
    9384:	10 93 ad 06 	sts	0x06AD, r17
    9388:	20 e0       	ldi	r18, 0x00	; 0
	if(GetStringFromFIFO()){
		if(strcmp_P(GSM_RxStr, Str_P)) return 0;
		else return 1;
	}
	else return 0;
}
    938a:	82 2f       	mov	r24, r18
    938c:	df 91       	pop	r29
    938e:	cf 91       	pop	r28
    9390:	1f 91       	pop	r17
    9392:	08 95       	ret
		GSM_State = RestoreCMD;
		return 0;
	}
	//  
	if(GetStringFromFIFO()){
		if(strcmp_P(GSM_RxStr, Str_P)) return 0;
    9394:	83 e9       	ldi	r24, 0x93	; 147
    9396:	97 e0       	ldi	r25, 0x07	; 7
    9398:	be 01       	movw	r22, r28
    939a:	0e 94 7a 7a 	call	0xf4f4	; 0xf4f4 <strcmp_P>
    939e:	20 e0       	ldi	r18, 0x00	; 0
    93a0:	89 2b       	or	r24, r25
    93a2:	59 f7       	brne	.-42     	; 0x937a <GSM_Wait_Response_P+0x24>
    93a4:	21 e0       	ldi	r18, 0x01	; 1
		else return 1;
	}
	else return 0;
}
    93a6:	82 2f       	mov	r24, r18
    93a8:	df 91       	pop	r29
    93aa:	cf 91       	pop	r28
    93ac:	1f 91       	pop	r17
    93ae:	08 95       	ret

000093b0 <GSM_SendCR>:
	
	sei();	
}
// ~~~~~~~~~
//   + CR
void GSM_SendCR(prog_char *Str_P){
    93b0:	ef 92       	push	r14
    93b2:	ff 92       	push	r15
    93b4:	0f 93       	push	r16
    93b6:	1f 93       	push	r17
    93b8:	7c 01       	movw	r14, r24
	GSMTxSz = strlen_P(Str_P);
    93ba:	0e 94 8a 7a 	call	0xf514	; 0xf514 <strlen_P>
    93be:	80 93 6f 07 	sts	0x076F, r24
	sprintf_P(GSM_TxStr, Str_P);
    93c2:	00 d0       	rcall	.+0      	; 0x93c4 <GSM_SendCR+0x14>
    93c4:	0f 92       	push	r0
    93c6:	0c ef       	ldi	r16, 0xFC	; 252
    93c8:	19 e0       	ldi	r17, 0x09	; 9
    93ca:	ed b7       	in	r30, 0x3d	; 61
    93cc:	fe b7       	in	r31, 0x3e	; 62
    93ce:	12 83       	std	Z+2, r17	; 0x02
    93d0:	01 83       	std	Z+1, r16	; 0x01
    93d2:	f4 82       	std	Z+4, r15	; 0x04
    93d4:	e3 82       	std	Z+3, r14	; 0x03
    93d6:	0e 94 a7 7b 	call	0xf74e	; 0xf74e <sprintf_P>
	sprintf(GSM_TxStr + GSMTxSz, "\r");
    93da:	80 91 6f 07 	lds	r24, 0x076F
    93de:	08 0f       	add	r16, r24
    93e0:	11 1d       	adc	r17, r1
    93e2:	8d e0       	ldi	r24, 0x0D	; 13
    93e4:	90 e0       	ldi	r25, 0x00	; 0
    93e6:	f8 01       	movw	r30, r16
    93e8:	91 83       	std	Z+1, r25	; 0x01
    93ea:	80 83       	st	Z, r24
	GSMTxSz++;
    93ec:	80 91 6f 07 	lds	r24, 0x076F
    93f0:	8f 5f       	subi	r24, 0xFF	; 255
    93f2:	80 93 6f 07 	sts	0x076F, r24
	GSM_SendFirstChar();
    93f6:	0f 90       	pop	r0
    93f8:	0f 90       	pop	r0
    93fa:	0f 90       	pop	r0
    93fc:	0f 90       	pop	r0
    93fe:	0e 94 fd 38 	call	0x71fa	; 0x71fa <GSM_SendFirstChar>
}
    9402:	1f 91       	pop	r17
    9404:	0f 91       	pop	r16
    9406:	ff 90       	pop	r15
    9408:	ef 90       	pop	r14
    940a:	08 95       	ret

0000940c <GSM_Execute_Command>:
	GSMTxSz = Size;
	memcpy(GSM_TxStr, Data_Out, GSMTxSz);
	GSM_SendFirstChar();
}
// ~~~~~~~~~
void GSM_Execute_Command(prog_char *Str_P, uint16_t Timeout){
    940c:	cf 93       	push	r28
    940e:	df 93       	push	r29
    9410:	9c 01       	movw	r18, r24
    9412:	eb 01       	movw	r28, r22
	if(GSM_Flag & (1<<flg_TxCStr)){
    9414:	80 91 cf 02 	lds	r24, 0x02CF
    9418:	80 ff       	sbrs	r24, 0
    941a:	08 c0       	rjmp	.+16     	; 0x942c <GSM_Execute_Command+0x20>
		GSM_SendCR(Str_P);
    941c:	c9 01       	movw	r24, r18
    941e:	0e 94 d8 49 	call	0x93b0	; 0x93b0 <GSM_SendCR>
		StartTimer16(TD_GSM, Timeout);
    9422:	80 91 e1 04 	lds	r24, 0x04E1
    9426:	be 01       	movw	r22, r28
    9428:	0e 94 1d 1a 	call	0x343a	; 0x343a <StartTimer16>
	}
}
    942c:	df 91       	pop	r29
    942e:	cf 91       	pop	r28
    9430:	08 95       	ret

00009432 <GSM_Wait_Response>:
	#endif

}
// ~~~~~~~~~
//   GetStringFromFIFO()!
uint8_t GSM_Wait_Response(char *Str, uint8_t RestoreCMD){
    9432:	bc 01       	movw	r22, r24
//	if(Timer16Stopp(TD_GSM) && RestoreCMD){
//		GSM_State = RestoreCMD;
//		return 0;
//	}
	if(strcmp(GSM_RxStr, Str))return 0;
    9434:	83 e9       	ldi	r24, 0x93	; 147
    9436:	97 e0       	ldi	r25, 0x07	; 7
    9438:	0e 94 da 7a 	call	0xf5b4	; 0xf5b4 <strcmp>
    943c:	9c 01       	movw	r18, r24
    943e:	80 e0       	ldi	r24, 0x00	; 0
    9440:	23 2b       	or	r18, r19
    9442:	09 f4       	brne	.+2      	; 0x9446 <GSM_Wait_Response+0x14>
    9444:	81 e0       	ldi	r24, 0x01	; 1
	else return 1;
}
    9446:	08 95       	ret

00009448 <DigiFilt>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
DigiFilt(const uint16_t *Array, uint8_t Edge)
{
    9448:	6f 92       	push	r6
    944a:	7f 92       	push	r7
    944c:	8f 92       	push	r8
    944e:	9f 92       	push	r9
    9450:	bf 92       	push	r11
    9452:	cf 92       	push	r12
    9454:	df 92       	push	r13
    9456:	ef 92       	push	r14
    9458:	ff 92       	push	r15
    945a:	0f 93       	push	r16
    945c:	1f 93       	push	r17
    945e:	df 93       	push	r29
    9460:	cf 93       	push	r28
    9462:	cd b7       	in	r28, 0x3d	; 61
    9464:	de b7       	in	r29, 0x3e	; 62
    9466:	28 2f       	mov	r18, r24
    9468:	79 2f       	mov	r23, r25
    946a:	e6 2e       	mov	r14, r22
				Buf[i] = Buf[j];
				Buf[j] = Swap;
			}
	for(i=Edge; i<_Edge; Sum+=Buf[i++]);
	return Sum/(Edge*2);
}
    946c:	6d b6       	in	r6, 0x3d	; 61
    946e:	7e b6       	in	r7, 0x3e	; 62

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
DigiFilt(const uint16_t *Array, uint8_t Edge)
{
	uint8_t Sz = Edge*4;
    9470:	86 2e       	mov	r8, r22
    9472:	99 24       	eor	r9, r9
    9474:	f6 2e       	mov	r15, r22
    9476:	ff 0c       	add	r15, r15
    9478:	ff 0c       	add	r15, r15
	uint8_t _Edge = Sz-Edge;
    947a:	bf 2c       	mov	r11, r15
    947c:	b6 1a       	sub	r11, r22
	uint16_t Buf[Sz];
    947e:	ef 2d       	mov	r30, r15
    9480:	f0 e0       	ldi	r31, 0x00	; 0
    9482:	ee 0f       	add	r30, r30
    9484:	ff 1f       	adc	r31, r31
    9486:	8d b7       	in	r24, 0x3d	; 61
    9488:	9e b7       	in	r25, 0x3e	; 62
    948a:	8e 1b       	sub	r24, r30
    948c:	9f 0b       	sbc	r25, r31
    948e:	0f b6       	in	r0, 0x3f	; 63
    9490:	f8 94       	cli
    9492:	9e bf       	out	0x3e, r25	; 62
    9494:	0f be       	out	0x3f, r0	; 63
    9496:	8d bf       	out	0x3d, r24	; 61
    9498:	0d b7       	in	r16, 0x3d	; 61
    949a:	1e b7       	in	r17, 0x3e	; 62
    949c:	0f 5f       	subi	r16, 0xFF	; 255
    949e:	1f 4f       	sbci	r17, 0xFF	; 255
	uint32_t Sum = 0;
	uint16_t Swap;
	uint8_t i, j;
	memcpy(Buf, Array, Sz*2);
    94a0:	c8 01       	movw	r24, r16
    94a2:	62 2f       	mov	r22, r18
    94a4:	af 01       	movw	r20, r30
    94a6:	0e 94 c6 7a 	call	0xf58c	; 0xf58c <memcpy>
	for(i=0; i<Edge; i++)
    94aa:	ee 20       	and	r14, r14
    94ac:	09 f1       	breq	.+66     	; 0x94f0 <DigiFilt+0xa8>
    94ae:	d8 01       	movw	r26, r16
    94b0:	80 e0       	ldi	r24, 0x00	; 0
		for(j=i+1; j<Sz; j++)
    94b2:	58 2f       	mov	r21, r24
    94b4:	5f 5f       	subi	r21, 0xFF	; 255
    94b6:	5f 15       	cp	r21, r15
    94b8:	b8 f4       	brcc	.+46     	; 0x94e8 <DigiFilt+0xa0>
    94ba:	45 2f       	mov	r20, r21
			if(Buf[j] < Buf[i]) {
    94bc:	e4 2f       	mov	r30, r20
    94be:	f0 e0       	ldi	r31, 0x00	; 0
    94c0:	ee 0f       	add	r30, r30
    94c2:	ff 1f       	adc	r31, r31
    94c4:	e0 0f       	add	r30, r16
    94c6:	f1 1f       	adc	r31, r17
    94c8:	20 81       	ld	r18, Z
    94ca:	31 81       	ldd	r19, Z+1	; 0x01
    94cc:	8d 91       	ld	r24, X+
    94ce:	9c 91       	ld	r25, X
    94d0:	11 97       	sbiw	r26, 0x01	; 1
    94d2:	28 17       	cp	r18, r24
    94d4:	39 07       	cpc	r19, r25
    94d6:	28 f4       	brcc	.+10     	; 0x94e2 <DigiFilt+0x9a>
				Swap = Buf[i];
				Buf[i] = Buf[j];
    94d8:	11 96       	adiw	r26, 0x01	; 1
    94da:	3c 93       	st	X, r19
    94dc:	2e 93       	st	-X, r18
				Buf[j] = Swap;
    94de:	91 83       	std	Z+1, r25	; 0x01
    94e0:	80 83       	st	Z, r24
	uint32_t Sum = 0;
	uint16_t Swap;
	uint8_t i, j;
	memcpy(Buf, Array, Sz*2);
	for(i=0; i<Edge; i++)
		for(j=i+1; j<Sz; j++)
    94e2:	4f 5f       	subi	r20, 0xFF	; 255
    94e4:	4f 15       	cp	r20, r15
    94e6:	50 f3       	brcs	.-44     	; 0x94bc <DigiFilt+0x74>
    94e8:	12 96       	adiw	r26, 0x02	; 2
    94ea:	85 2f       	mov	r24, r21
	uint16_t Buf[Sz];
	uint32_t Sum = 0;
	uint16_t Swap;
	uint8_t i, j;
	memcpy(Buf, Array, Sz*2);
	for(i=0; i<Edge; i++)
    94ec:	5e 15       	cp	r21, r14
    94ee:	08 f3       	brcs	.-62     	; 0x94b2 <DigiFilt+0x6a>
			if(Buf[j] < Buf[i]) {
				Swap = Buf[i];
				Buf[i] = Buf[j];
				Buf[j] = Swap;
			}
	for(i=Sz-1; i>=_Edge; i--)
    94f0:	ef 2d       	mov	r30, r15
    94f2:	e1 50       	subi	r30, 0x01	; 1
    94f4:	eb 15       	cp	r30, r11
    94f6:	10 f1       	brcs	.+68     	; 0x953c <DigiFilt+0xf4>
		for(j=i-1; j>=Edge; j--)
    94f8:	5e 2f       	mov	r21, r30
    94fa:	51 50       	subi	r21, 0x01	; 1
    94fc:	5e 15       	cp	r21, r14
    94fe:	d8 f0       	brcs	.+54     	; 0x9536 <DigiFilt+0xee>
    9500:	f0 e0       	ldi	r31, 0x00	; 0
    9502:	45 2f       	mov	r20, r21
    9504:	ee 0f       	add	r30, r30
    9506:	ff 1f       	adc	r31, r31
			if(Buf[j] > Buf[i]) {
    9508:	e0 0f       	add	r30, r16
    950a:	f1 1f       	adc	r31, r17
    950c:	a4 2f       	mov	r26, r20
    950e:	b0 e0       	ldi	r27, 0x00	; 0
    9510:	aa 0f       	add	r26, r26
    9512:	bb 1f       	adc	r27, r27
    9514:	a0 0f       	add	r26, r16
    9516:	b1 1f       	adc	r27, r17
    9518:	2d 91       	ld	r18, X+
    951a:	3c 91       	ld	r19, X
    951c:	11 97       	sbiw	r26, 0x01	; 1
    951e:	80 81       	ld	r24, Z
    9520:	91 81       	ldd	r25, Z+1	; 0x01
    9522:	82 17       	cp	r24, r18
    9524:	93 07       	cpc	r25, r19
    9526:	20 f4       	brcc	.+8      	; 0x9530 <DigiFilt+0xe8>
				Swap = Buf[i];
				Buf[i] = Buf[j];
    9528:	31 83       	std	Z+1, r19	; 0x01
    952a:	20 83       	st	Z, r18
				Buf[j] = Swap;
    952c:	8d 93       	st	X+, r24
    952e:	9c 93       	st	X, r25
				Swap = Buf[i];
				Buf[i] = Buf[j];
				Buf[j] = Swap;
			}
	for(i=Sz-1; i>=_Edge; i--)
		for(j=i-1; j>=Edge; j--)
    9530:	41 50       	subi	r20, 0x01	; 1
    9532:	4e 15       	cp	r20, r14
    9534:	58 f7       	brcc	.-42     	; 0x950c <DigiFilt+0xc4>
    9536:	e5 2f       	mov	r30, r21
			if(Buf[j] < Buf[i]) {
				Swap = Buf[i];
				Buf[i] = Buf[j];
				Buf[j] = Swap;
			}
	for(i=Sz-1; i>=_Edge; i--)
    9538:	5b 15       	cp	r21, r11
    953a:	f0 f6       	brcc	.-68     	; 0x94f8 <DigiFilt+0xb0>
			if(Buf[j] > Buf[i]) {
				Swap = Buf[i];
				Buf[i] = Buf[j];
				Buf[j] = Swap;
			}
	for(i=Edge; i<_Edge; Sum+=Buf[i++]);
    953c:	eb 14       	cp	r14, r11
    953e:	a0 f5       	brcc	.+104    	; 0x95a8 <DigiFilt+0x160>
    9540:	6e 2d       	mov	r22, r14
    9542:	cc 24       	eor	r12, r12
    9544:	dd 24       	eor	r13, r13
    9546:	76 01       	movw	r14, r12
    9548:	e6 2f       	mov	r30, r22
    954a:	f0 e0       	ldi	r31, 0x00	; 0
    954c:	ee 0f       	add	r30, r30
    954e:	ff 1f       	adc	r31, r31
    9550:	e0 0f       	add	r30, r16
    9552:	f1 1f       	adc	r31, r17
    9554:	80 81       	ld	r24, Z
    9556:	91 81       	ldd	r25, Z+1	; 0x01
    9558:	a0 e0       	ldi	r26, 0x00	; 0
    955a:	b0 e0       	ldi	r27, 0x00	; 0
    955c:	c8 0e       	add	r12, r24
    955e:	d9 1e       	adc	r13, r25
    9560:	ea 1e       	adc	r14, r26
    9562:	fb 1e       	adc	r15, r27
    9564:	6f 5f       	subi	r22, 0xFF	; 255
    9566:	6b 15       	cp	r22, r11
    9568:	78 f3       	brcs	.-34     	; 0x9548 <DigiFilt+0x100>
    956a:	88 0c       	add	r8, r8
    956c:	99 1c       	adc	r9, r9
    956e:	94 01       	movw	r18, r8
    9570:	44 27       	eor	r20, r20
    9572:	37 fd       	sbrc	r19, 7
    9574:	40 95       	com	r20
    9576:	54 2f       	mov	r21, r20
    9578:	c7 01       	movw	r24, r14
    957a:	b6 01       	movw	r22, r12
    957c:	0e 94 32 7e 	call	0xfc64	; 0xfc64 <__udivmodsi4>
    9580:	c9 01       	movw	r24, r18
	return Sum/(Edge*2);
}
    9582:	0f b6       	in	r0, 0x3f	; 63
    9584:	f8 94       	cli
    9586:	7e be       	out	0x3e, r7	; 62
    9588:	0f be       	out	0x3f, r0	; 63
    958a:	6d be       	out	0x3d, r6	; 61
    958c:	cf 91       	pop	r28
    958e:	df 91       	pop	r29
    9590:	1f 91       	pop	r17
    9592:	0f 91       	pop	r16
    9594:	ff 90       	pop	r15
    9596:	ef 90       	pop	r14
    9598:	df 90       	pop	r13
    959a:	cf 90       	pop	r12
    959c:	bf 90       	pop	r11
    959e:	9f 90       	pop	r9
    95a0:	8f 90       	pop	r8
    95a2:	7f 90       	pop	r7
    95a4:	6f 90       	pop	r6
    95a6:	08 95       	ret
			if(Buf[j] > Buf[i]) {
				Swap = Buf[i];
				Buf[i] = Buf[j];
				Buf[j] = Swap;
			}
	for(i=Edge; i<_Edge; Sum+=Buf[i++]);
    95a8:	cc 24       	eor	r12, r12
    95aa:	dd 24       	eor	r13, r13
    95ac:	76 01       	movw	r14, r12
    95ae:	dd cf       	rjmp	.-70     	; 0x956a <DigiFilt+0x122>

000095b0 <MemFailReset>:

// ~~~~~~~~~~~~~~~
void
MemFailReset(void)
{
	if (MemFail &(1<<MemFail_EEPROM)) {
    95b0:	80 91 c9 08 	lds	r24, 0x08C9
    95b4:	81 ff       	sbrs	r24, 1
    95b6:	08 95       	ret
		MemFail &=~(1<<MemFail_EEPROM);
    95b8:	8d 7f       	andi	r24, 0xFD	; 253
    95ba:	80 93 c9 08 	sts	0x08C9, r24
		eeprom_write_word(&MemCheck_stor.CRC_EEPROM_stor, CRC_EEPROM_calc());
    95be:	0e 94 f8 18 	call	0x31f0	; 0x31f0 <CRC_EEPROM_calc>
    95c2:	bc 01       	movw	r22, r24
    95c4:	8a e3       	ldi	r24, 0x3A	; 58
    95c6:	91 e0       	ldi	r25, 0x01	; 1
    95c8:	0e 94 d8 7d 	call	0xfbb0	; 0xfbb0 <__eewr_word_m2560>
    95cc:	08 95       	ret

000095ce <Key_Mem>:
		MenuPage Menu_BackUp = { SetMenu(Menu_BackUp_List), 1, NULL,
				NULL, NULL, NULL, Menu_BackUp_Enter, NULL, NULL, NULL};
#endif

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t Key_Mem(void) {if(CurrLine==3) MemFailReset(); return StandartKey;}
    95ce:	80 91 7d 07 	lds	r24, 0x077D
    95d2:	83 30       	cpi	r24, 0x03	; 3
    95d4:	11 f0       	breq	.+4      	; 0x95da <Key_Mem+0xc>
    95d6:	80 e0       	ldi	r24, 0x00	; 0
    95d8:	08 95       	ret
    95da:	0e 94 d8 4a 	call	0x95b0	; 0x95b0 <MemFailReset>
    95de:	80 e0       	ldi	r24, 0x00	; 0
    95e0:	08 95       	ret

000095e2 <CRC_EEPROM_upd>:
// ~~~~~~~~~~~~~~~~~
// Duration: 48 ms
static void
CRC_EEPROM_upd(void)
{
	if (!(MemFail &(1<<MemFail_EEPROM)))
    95e2:	80 91 c9 08 	lds	r24, 0x08C9
    95e6:	81 fd       	sbrc	r24, 1
    95e8:	08 95       	ret
		eeprom_write_word(&MemCheck_stor.CRC_EEPROM_stor, CRC_EEPROM_calc());
    95ea:	0e 94 f8 18 	call	0x31f0	; 0x31f0 <CRC_EEPROM_calc>
    95ee:	bc 01       	movw	r22, r24
    95f0:	8a e3       	ldi	r24, 0x3A	; 58
    95f2:	91 e0       	ldi	r25, 0x01	; 1
    95f4:	0e 94 d8 7d 	call	0xfbb0	; 0xfbb0 <__eewr_word_m2560>
    95f8:	08 95       	ret

000095fa <ewb>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ewb(uint8_t *addr, uint8_t val)
{
	//IntOff();
	eeprom_write_byte(addr, val);
    95fa:	0e 94 c2 7d 	call	0xfb84	; 0xfb84 <__eewr_byte_m2560>
	CRC_EEPROM_upd();
    95fe:	0e 94 f1 4a 	call	0x95e2	; 0x95e2 <CRC_EEPROM_upd>
	//IntOn();
}
    9602:	08 95       	ret

00009604 <MB_M_TimeOff_Set>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_M_TimeOff_Set(uint8_t MB_N)
{
	ewb(&MB_M_Param_EE[MB_N].TimeOff, MB_M_TimeOff[MB_N]);
    9604:	e8 2f       	mov	r30, r24
    9606:	f0 e0       	ldi	r31, 0x00	; 0
    9608:	cf 01       	movw	r24, r30
    960a:	88 0f       	add	r24, r24
    960c:	99 1f       	adc	r25, r25
    960e:	88 0f       	add	r24, r24
    9610:	99 1f       	adc	r25, r25
    9612:	8e 0f       	add	r24, r30
    9614:	9f 1f       	adc	r25, r31
    9616:	e9 52       	subi	r30, 0x29	; 41
    9618:	fa 4f       	sbci	r31, 0xFA	; 250
    961a:	8a 5c       	subi	r24, 0xCA	; 202
    961c:	9e 4f       	sbci	r25, 0xFE	; 254
    961e:	60 81       	ld	r22, Z
    9620:	0e 94 fd 4a 	call	0x95fa	; 0x95fa <ewb>
}
    9624:	08 95       	ret

00009626 <MB_M_Try_Set>:

// ~~~~~~~~~~~~~~~~~~~~~~~
void
MB_M_Try_Set(uint8_t MB_N)
{
	ewb(&MB_M_Param_EE[MB_N].Try, MB_M_Try[MB_N]);
    9626:	e8 2f       	mov	r30, r24
    9628:	f0 e0       	ldi	r31, 0x00	; 0
    962a:	cf 01       	movw	r24, r30
    962c:	88 0f       	add	r24, r24
    962e:	99 1f       	adc	r25, r25
    9630:	88 0f       	add	r24, r24
    9632:	99 1f       	adc	r25, r25
    9634:	8e 0f       	add	r24, r30
    9636:	9f 1f       	adc	r25, r31
    9638:	eb 50       	subi	r30, 0x0B	; 11
    963a:	f9 4f       	sbci	r31, 0xF9	; 249
    963c:	8b 5c       	subi	r24, 0xCB	; 203
    963e:	9e 4f       	sbci	r25, 0xFE	; 254
    9640:	60 81       	ld	r22, Z
    9642:	0e 94 fd 4a 	call	0x95fa	; 0x95fa <ewb>
}
    9646:	08 95       	ret

00009648 <MB_M_Timeout_Set>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_M_Timeout_Set(uint8_t MB_N)
{
	ewb(&MB_M_Param_EE[MB_N].Timeout, MB_M_Timeout[MB_N]);
    9648:	e8 2f       	mov	r30, r24
    964a:	f0 e0       	ldi	r31, 0x00	; 0
    964c:	cf 01       	movw	r24, r30
    964e:	88 0f       	add	r24, r24
    9650:	99 1f       	adc	r25, r25
    9652:	88 0f       	add	r24, r24
    9654:	99 1f       	adc	r25, r25
    9656:	8e 0f       	add	r24, r30
    9658:	9f 1f       	adc	r25, r31
    965a:	e5 52       	subi	r30, 0x25	; 37
    965c:	f7 4f       	sbci	r31, 0xF7	; 247
    965e:	8c 5c       	subi	r24, 0xCC	; 204
    9660:	9e 4f       	sbci	r25, 0xFE	; 254
    9662:	60 81       	ld	r22, Z
    9664:	0e 94 fd 4a 	call	0x95fa	; 0x95fa <ewb>
}
    9668:	08 95       	ret

0000966a <Set_MB_Addr>:
	static uint8_t EEMEM MB_NativeAddr_EE[Modbus_Qt] = Init_MB_NativeAddr;
	// ~~~~~~~~~~~~~~~~~~~~~~
	void
	Set_MB_Addr(uint8_t MB_N)
	{
		ewb(MB_NativeAddr_EE+MB_N, MB_NativeAddr[MB_N]);
    966a:	e8 2f       	mov	r30, r24
    966c:	f0 e0       	ldi	r31, 0x00	; 0
    966e:	cf 01       	movw	r24, r30
    9670:	89 5c       	subi	r24, 0xC9	; 201
    9672:	9e 4f       	sbci	r25, 0xFE	; 254
    9674:	e8 52       	subi	r30, 0x28	; 40
    9676:	fa 4f       	sbci	r31, 0xFA	; 250
    9678:	60 81       	ld	r22, Z
    967a:	0e 94 fd 4a 	call	0x95fa	; 0x95fa <ewb>
	}
    967e:	08 95       	ret

00009680 <eww>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
eww(uint16_t *addr, uint16_t val)
{
	//IntOff();
	eeprom_write_word(addr, val);
    9680:	0e 94 d8 7d 	call	0xfbb0	; 0xfbb0 <__eewr_word_m2560>
	CRC_EEPROM_upd();
    9684:	0e 94 f1 4a 	call	0x95e2	; 0x95e2 <CRC_EEPROM_upd>
	//IntOn();
}
    9688:	08 95       	ret

0000968a <MB_M_Period_Set>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_M_Period_Set(uint8_t MB_N)
{
	eww(&MB_M_Param_EE[MB_N].Period, MB_M_Period[MB_N]);
    968a:	e8 2f       	mov	r30, r24
    968c:	f0 e0       	ldi	r31, 0x00	; 0
    968e:	cf 01       	movw	r24, r30
    9690:	88 0f       	add	r24, r24
    9692:	99 1f       	adc	r25, r25
    9694:	88 0f       	add	r24, r24
    9696:	99 1f       	adc	r25, r25
    9698:	8e 0f       	add	r24, r30
    969a:	9f 1f       	adc	r25, r31
    969c:	ee 0f       	add	r30, r30
    969e:	ff 1f       	adc	r31, r31
    96a0:	eb 55       	subi	r30, 0x5B	; 91
    96a2:	f9 4f       	sbci	r31, 0xF9	; 249
    96a4:	60 81       	ld	r22, Z
    96a6:	71 81       	ldd	r23, Z+1	; 0x01
    96a8:	8e 5c       	subi	r24, 0xCE	; 206
    96aa:	9e 4f       	sbci	r25, 0xFE	; 254
    96ac:	0e 94 40 4b 	call	0x9680	; 0x9680 <eww>
}
    96b0:	08 95       	ret

000096b2 <OnTimeSave>:

// ~~~~~~~~~~~~~
void
OnTimeSave(void)
{
	ewb(&Timer1min_EE, Timer1min);
    96b2:	8d e3       	ldi	r24, 0x3D	; 61
    96b4:	91 e0       	ldi	r25, 0x01	; 1
    96b6:	60 91 a8 06 	lds	r22, 0x06A8
    96ba:	0e 94 fd 4a 	call	0x95fa	; 0x95fa <ewb>
	eww(&Timer1hour_EE, Timer1hour);
    96be:	60 91 1d 0c 	lds	r22, 0x0C1D
    96c2:	70 91 1e 0c 	lds	r23, 0x0C1E
    96c6:	8e e3       	ldi	r24, 0x3E	; 62
    96c8:	91 e0       	ldi	r25, 0x01	; 1
    96ca:	0e 94 40 4b 	call	0x9680	; 0x9680 <eww>
}
    96ce:	08 95       	ret

000096d0 <TimersInc>:
		HSC_Process();
	#endif
}
void 
TimersInc(void)
{
    96d0:	ef 92       	push	r14
    96d2:	ff 92       	push	r15
    96d4:	0f 93       	push	r16
    96d6:	1f 93       	push	r17
    96d8:	cf 93       	push	r28
    96da:	df 93       	push	r29
	uint8_t i, TickCounterVar;	
	cli();
    96dc:	f8 94       	cli
	TickCounterVar = TickCounter;
    96de:	e0 90 c9 04 	lds	r14, 0x04C9
	TickCounter = 0;
    96e2:	10 92 c9 04 	sts	0x04C9, r1
	sei();
    96e6:	78 94       	sei
	for(uint8_t j=0;j<TickCounterVar;j++){
    96e8:	ee 20       	and	r14, r14
    96ea:	09 f4       	brne	.+2      	; 0x96ee <TimersInc+0x1e>
    96ec:	c8 c0       	rjmp	.+400    	; 0x987e <TimersInc+0x1ae>
    96ee:	ff 24       	eor	r15, r15
		LiveTime++;
	 	for (i=0; i<Timer8TotNumber; i++){
			cli();
			if (!(Timer8Flg[i/8] &(1<<i%8)) && --Timer8[i]==0)
				Timer8Flg[i/8] |=(1<<i%8);
    96f0:	01 e0       	ldi	r16, 0x01	; 1
    96f2:	10 e0       	ldi	r17, 0x00	; 0
	cli();
	TickCounterVar = TickCounter;
	TickCounter = 0;
	sei();
	for(uint8_t j=0;j<TickCounterVar;j++){
		LiveTime++;
    96f4:	80 91 78 07 	lds	r24, 0x0778
    96f8:	90 91 79 07 	lds	r25, 0x0779
    96fc:	a0 91 7a 07 	lds	r26, 0x077A
    9700:	b0 91 7b 07 	lds	r27, 0x077B
    9704:	01 96       	adiw	r24, 0x01	; 1
    9706:	a1 1d       	adc	r26, r1
    9708:	b1 1d       	adc	r27, r1
    970a:	80 93 78 07 	sts	0x0778, r24
    970e:	90 93 79 07 	sts	0x0779, r25
    9712:	a0 93 7a 07 	sts	0x077A, r26
    9716:	b0 93 7b 07 	sts	0x077B, r27
    971a:	40 e0       	ldi	r20, 0x00	; 0
    971c:	50 e0       	ldi	r21, 0x00	; 0
	 	for (i=0; i<Timer8TotNumber; i++){
			cli();
    971e:	f8 94       	cli
			if (!(Timer8Flg[i/8] &(1<<i%8)) && --Timer8[i]==0)
    9720:	84 2f       	mov	r24, r20
    9722:	86 95       	lsr	r24
    9724:	86 95       	lsr	r24
    9726:	86 95       	lsr	r24
    9728:	a8 2f       	mov	r26, r24
    972a:	b0 e0       	ldi	r27, 0x00	; 0
    972c:	a7 55       	subi	r26, 0x57	; 87
    972e:	bb 4f       	sbci	r27, 0xFB	; 251
    9730:	8c 91       	ld	r24, X
    9732:	ba 01       	movw	r22, r20
    9734:	67 70       	andi	r22, 0x07	; 7
    9736:	70 70       	andi	r23, 0x00	; 0
    9738:	90 e0       	ldi	r25, 0x00	; 0
    973a:	06 2e       	mov	r0, r22
    973c:	02 c0       	rjmp	.+4      	; 0x9742 <TimersInc+0x72>
    973e:	95 95       	asr	r25
    9740:	87 95       	ror	r24
    9742:	0a 94       	dec	r0
    9744:	e2 f7       	brpl	.-8      	; 0x973e <TimersInc+0x6e>
    9746:	80 fd       	sbrc	r24, 0
    9748:	12 c0       	rjmp	.+36     	; 0x976e <TimersInc+0x9e>
    974a:	fa 01       	movw	r30, r20
    974c:	e1 51       	subi	r30, 0x11	; 17
    974e:	fd 4f       	sbci	r31, 0xFD	; 253
    9750:	80 81       	ld	r24, Z
    9752:	81 50       	subi	r24, 0x01	; 1
    9754:	80 83       	st	Z, r24
    9756:	80 81       	ld	r24, Z
    9758:	88 23       	and	r24, r24
    975a:	49 f4       	brne	.+18     	; 0x976e <TimersInc+0x9e>
				Timer8Flg[i/8] |=(1<<i%8);
    975c:	2c 91       	ld	r18, X
    975e:	c8 01       	movw	r24, r16
    9760:	02 c0       	rjmp	.+4      	; 0x9766 <TimersInc+0x96>
    9762:	88 0f       	add	r24, r24
    9764:	99 1f       	adc	r25, r25
    9766:	6a 95       	dec	r22
    9768:	e2 f7       	brpl	.-8      	; 0x9762 <TimersInc+0x92>
    976a:	28 2b       	or	r18, r24
    976c:	2c 93       	st	X, r18
			sei();
    976e:	78 94       	sei
    9770:	4f 5f       	subi	r20, 0xFF	; 255
    9772:	5f 4f       	sbci	r21, 0xFF	; 255
	TickCounterVar = TickCounter;
	TickCounter = 0;
	sei();
	for(uint8_t j=0;j<TickCounterVar;j++){
		LiveTime++;
	 	for (i=0; i<Timer8TotNumber; i++){
    9774:	48 35       	cpi	r20, 0x58	; 88
    9776:	51 05       	cpc	r21, r1
    9778:	91 f6       	brne	.-92     	; 0x971e <TimersInc+0x4e>
    977a:	40 e0       	ldi	r20, 0x00	; 0
    977c:	50 e0       	ldi	r21, 0x00	; 0
			if (!(Timer8Flg[i/8] &(1<<i%8)) && --Timer8[i]==0)
				Timer8Flg[i/8] |=(1<<i%8);
			sei();
		}
		for (i=0; i<Timer16TotNumber; i++){
			cli();
    977e:	f8 94       	cli
			if (!(Timer16Flg[i/8] &(1<<i%8)) && --Timer16[i]==0)
    9780:	84 2f       	mov	r24, r20
    9782:	86 95       	lsr	r24
    9784:	86 95       	lsr	r24
    9786:	86 95       	lsr	r24
    9788:	a8 2f       	mov	r26, r24
    978a:	b0 e0       	ldi	r27, 0x00	; 0
    978c:	ab 54       	subi	r26, 0x4B	; 75
    978e:	bb 4f       	sbci	r27, 0xFB	; 251
    9790:	8c 91       	ld	r24, X
    9792:	ba 01       	movw	r22, r20
    9794:	67 70       	andi	r22, 0x07	; 7
    9796:	70 70       	andi	r23, 0x00	; 0
    9798:	90 e0       	ldi	r25, 0x00	; 0
    979a:	06 2e       	mov	r0, r22
    979c:	02 c0       	rjmp	.+4      	; 0x97a2 <TimersInc+0xd2>
    979e:	95 95       	asr	r25
    97a0:	87 95       	ror	r24
    97a2:	0a 94       	dec	r0
    97a4:	e2 f7       	brpl	.-8      	; 0x979e <TimersInc+0xce>
    97a6:	80 fd       	sbrc	r24, 0
    97a8:	17 c0       	rjmp	.+46     	; 0x97d8 <TimersInc+0x108>
    97aa:	fa 01       	movw	r30, r20
    97ac:	ee 0f       	add	r30, r30
    97ae:	ff 1f       	adc	r31, r31
    97b0:	e9 5b       	subi	r30, 0xB9	; 185
    97b2:	fc 4f       	sbci	r31, 0xFC	; 252
    97b4:	80 81       	ld	r24, Z
    97b6:	91 81       	ldd	r25, Z+1	; 0x01
    97b8:	01 97       	sbiw	r24, 0x01	; 1
    97ba:	91 83       	std	Z+1, r25	; 0x01
    97bc:	80 83       	st	Z, r24
    97be:	80 81       	ld	r24, Z
    97c0:	91 81       	ldd	r25, Z+1	; 0x01
    97c2:	89 2b       	or	r24, r25
    97c4:	49 f4       	brne	.+18     	; 0x97d8 <TimersInc+0x108>
				Timer16Flg[i/8] |=(1<<i%8);
    97c6:	2c 91       	ld	r18, X
    97c8:	c8 01       	movw	r24, r16
    97ca:	02 c0       	rjmp	.+4      	; 0x97d0 <TimersInc+0x100>
    97cc:	88 0f       	add	r24, r24
    97ce:	99 1f       	adc	r25, r25
    97d0:	6a 95       	dec	r22
    97d2:	e2 f7       	brpl	.-8      	; 0x97cc <TimersInc+0xfc>
    97d4:	28 2b       	or	r18, r24
    97d6:	2c 93       	st	X, r18
			sei();
    97d8:	78 94       	sei
    97da:	4f 5f       	subi	r20, 0xFF	; 255
    97dc:	5f 4f       	sbci	r21, 0xFF	; 255
			cli();
			if (!(Timer8Flg[i/8] &(1<<i%8)) && --Timer8[i]==0)
				Timer8Flg[i/8] |=(1<<i%8);
			sei();
		}
		for (i=0; i<Timer16TotNumber; i++){
    97de:	40 36       	cpi	r20, 0x60	; 96
    97e0:	51 05       	cpc	r21, r1
    97e2:	69 f6       	brne	.-102    	; 0x977e <TimersInc+0xae>
    97e4:	40 e0       	ldi	r20, 0x00	; 0
    97e6:	50 e0       	ldi	r21, 0x00	; 0
			if (!(Timer16Flg[i/8] &(1<<i%8)) && --Timer16[i]==0)
				Timer16Flg[i/8] |=(1<<i%8);
			sei();
		}
		for (i=0; i<Timer32TotNumber; i++){
			cli();
    97e8:	f8 94       	cli
			if (!(Timer32Flg[i/8] &(1<<i%8)) && --Timer32[i]==0)
    97ea:	84 2f       	mov	r24, r20
    97ec:	86 95       	lsr	r24
    97ee:	86 95       	lsr	r24
    97f0:	86 95       	lsr	r24
    97f2:	c8 2f       	mov	r28, r24
    97f4:	d0 e0       	ldi	r29, 0x00	; 0
    97f6:	ce 53       	subi	r28, 0x3E	; 62
    97f8:	db 4f       	sbci	r29, 0xFB	; 251
    97fa:	88 81       	ld	r24, Y
    97fc:	ba 01       	movw	r22, r20
    97fe:	67 70       	andi	r22, 0x07	; 7
    9800:	70 70       	andi	r23, 0x00	; 0
    9802:	90 e0       	ldi	r25, 0x00	; 0
    9804:	06 2e       	mov	r0, r22
    9806:	02 c0       	rjmp	.+4      	; 0x980c <TimersInc+0x13c>
    9808:	95 95       	asr	r25
    980a:	87 95       	ror	r24
    980c:	0a 94       	dec	r0
    980e:	e2 f7       	brpl	.-8      	; 0x9808 <TimersInc+0x138>
    9810:	80 fd       	sbrc	r24, 0
    9812:	23 c0       	rjmp	.+70     	; 0x985a <TimersInc+0x18a>
    9814:	fa 01       	movw	r30, r20
    9816:	ee 0f       	add	r30, r30
    9818:	ff 1f       	adc	r31, r31
    981a:	ee 0f       	add	r30, r30
    981c:	ff 1f       	adc	r31, r31
    981e:	e9 5f       	subi	r30, 0xF9	; 249
    9820:	fb 4f       	sbci	r31, 0xFB	; 251
    9822:	80 81       	ld	r24, Z
    9824:	91 81       	ldd	r25, Z+1	; 0x01
    9826:	a2 81       	ldd	r26, Z+2	; 0x02
    9828:	b3 81       	ldd	r27, Z+3	; 0x03
    982a:	01 97       	sbiw	r24, 0x01	; 1
    982c:	a1 09       	sbc	r26, r1
    982e:	b1 09       	sbc	r27, r1
    9830:	80 83       	st	Z, r24
    9832:	91 83       	std	Z+1, r25	; 0x01
    9834:	a2 83       	std	Z+2, r26	; 0x02
    9836:	b3 83       	std	Z+3, r27	; 0x03
    9838:	80 81       	ld	r24, Z
    983a:	91 81       	ldd	r25, Z+1	; 0x01
    983c:	a2 81       	ldd	r26, Z+2	; 0x02
    983e:	b3 81       	ldd	r27, Z+3	; 0x03
    9840:	00 97       	sbiw	r24, 0x00	; 0
    9842:	a1 05       	cpc	r26, r1
    9844:	b1 05       	cpc	r27, r1
    9846:	49 f4       	brne	.+18     	; 0x985a <TimersInc+0x18a>
				Timer32Flg[i/8] |=(1<<i%8);	
    9848:	28 81       	ld	r18, Y
    984a:	c8 01       	movw	r24, r16
    984c:	02 c0       	rjmp	.+4      	; 0x9852 <TimersInc+0x182>
    984e:	88 0f       	add	r24, r24
    9850:	99 1f       	adc	r25, r25
    9852:	6a 95       	dec	r22
    9854:	e2 f7       	brpl	.-8      	; 0x984e <TimersInc+0x17e>
    9856:	28 2b       	or	r18, r24
    9858:	28 83       	st	Y, r18
			sei();
    985a:	78 94       	sei
    985c:	4f 5f       	subi	r20, 0xFF	; 255
    985e:	5f 4f       	sbci	r21, 0xFF	; 255
			cli();
			if (!(Timer16Flg[i/8] &(1<<i%8)) && --Timer16[i]==0)
				Timer16Flg[i/8] |=(1<<i%8);
			sei();
		}
		for (i=0; i<Timer32TotNumber; i++){
    9860:	48 32       	cpi	r20, 0x28	; 40
    9862:	51 05       	cpc	r21, r1
    9864:	09 f0       	breq	.+2      	; 0x9868 <TimersInc+0x198>
    9866:	c0 cf       	rjmp	.-128    	; 0x97e8 <TimersInc+0x118>
			sei();
		}

		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		static uint8_t Timer10ms;
		if (++Timer10ms==100) {
    9868:	80 91 e5 02 	lds	r24, 0x02E5
    986c:	8f 5f       	subi	r24, 0xFF	; 255
    986e:	80 93 e5 02 	sts	0x02E5, r24
    9872:	84 36       	cpi	r24, 0x64	; 100
    9874:	59 f0       	breq	.+22     	; 0x988c <TimersInc+0x1bc>
	uint8_t i, TickCounterVar;	
	cli();
	TickCounterVar = TickCounter;
	TickCounter = 0;
	sei();
	for(uint8_t j=0;j<TickCounterVar;j++){
    9876:	f3 94       	inc	r15
    9878:	fe 14       	cp	r15, r14
    987a:	08 f4       	brcc	.+2      	; 0x987e <TimersInc+0x1ae>
    987c:	3b cf       	rjmp	.-394    	; 0x96f4 <TimersInc+0x24>
 			ScanCount = 0;
			RT();
		}
		#endif
	}
}
    987e:	df 91       	pop	r29
    9880:	cf 91       	pop	r28
    9882:	1f 91       	pop	r17
    9884:	0f 91       	pop	r16
    9886:	ff 90       	pop	r15
    9888:	ef 90       	pop	r14
    988a:	08 95       	ret
		}

		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		static uint8_t Timer10ms;
		if (++Timer10ms==100) {
			Timer10ms = 0;
    988c:	10 92 e5 02 	sts	0x02E5, r1
			ScanPerSec = ScanCount;
    9890:	80 91 68 07 	lds	r24, 0x0768
    9894:	90 91 69 07 	lds	r25, 0x0769
    9898:	90 93 82 07 	sts	0x0782, r25
    989c:	80 93 81 07 	sts	0x0781, r24
 			ScanCount = 0;
    98a0:	10 92 69 07 	sts	0x0769, r1
    98a4:	10 92 68 07 	sts	0x0768, r1

// ~~~~~~~~~~~~~~~
inline static void
RT(void)
{
	if (++Timer1s==60) {
    98a8:	80 91 cc 08 	lds	r24, 0x08CC
    98ac:	8f 5f       	subi	r24, 0xFF	; 255
    98ae:	80 93 cc 08 	sts	0x08CC, r24
    98b2:	8c 33       	cpi	r24, 0x3C	; 60
    98b4:	01 f7       	brne	.-64     	; 0x9876 <TimersInc+0x1a6>
		Timer1s = 0;
    98b6:	10 92 cc 08 	sts	0x08CC, r1
		if (++Timer1min==60) {
    98ba:	80 91 a8 06 	lds	r24, 0x06A8
    98be:	8f 5f       	subi	r24, 0xFF	; 255
    98c0:	80 93 a8 06 	sts	0x06A8, r24
    98c4:	8c 33       	cpi	r24, 0x3C	; 60
    98c6:	b9 f6       	brne	.-82     	; 0x9876 <TimersInc+0x1a6>
			Timer1min = 0;
    98c8:	10 92 a8 06 	sts	0x06A8, r1
			++Timer1hour;
    98cc:	80 91 1d 0c 	lds	r24, 0x0C1D
    98d0:	90 91 1e 0c 	lds	r25, 0x0C1E
    98d4:	01 96       	adiw	r24, 0x01	; 1
    98d6:	90 93 1e 0c 	sts	0x0C1E, r25
    98da:	80 93 1d 0c 	sts	0x0C1D, r24
			OnTimeSave();
    98de:	0e 94 59 4b 	call	0x96b2	; 0x96b2 <OnTimeSave>
    98e2:	c9 cf       	rjmp	.-110    	; 0x9876 <TimersInc+0x1a6>

000098e4 <ewbl>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ewbl(const void *src, void *dst, size_t n)
{
	//IntOff();
	eeprom_write_block(src, dst, n);
    98e4:	0e 94 b8 7d 	call	0xfb70	; 0xfb70 <__eewr_block_m2560>
	CRC_EEPROM_upd();
    98e8:	0e 94 f1 4a 	call	0x95e2	; 0x95e2 <CRC_EEPROM_upd>
	//IntOn();
}
    98ec:	08 95       	ret

000098ee <ewd>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ewd(uint32_t *addr, uint32_t val)
{
	//IntOff();
	eeprom_write_dword(addr, val);
    98ee:	0e 94 d0 7d 	call	0xfba0	; 0xfba0 <__eewr_dword_m2560>
	CRC_EEPROM_upd();
    98f2:	0e 94 f1 4a 	call	0x95e2	; 0x95e2 <CRC_EEPROM_upd>
	//IntOn();
}
    98f6:	08 95       	ret

000098f8 <erbl>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    98f8:	0e 94 94 7d 	call	0xfb28	; 0xfb28 <__eerd_block_m2560>
	//IntOn();
}
    98fc:	08 95       	ret

000098fe <erd>:
// ~~~~~~~~~~~~~~~~~~~~~~
uint32_t
erd(const uint32_t *addr)
{
	//IntOff();
	uint32_t word = eeprom_read_dword(addr);
    98fe:	0e 94 ac 7d 	call	0xfb58	; 0xfb58 <__eerd_dword_m2560>
	//IntOn();
	return word;
}
    9902:	08 95       	ret

00009904 <erw>:
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    9904:	0e 94 b2 7d 	call	0xfb64	; 0xfb64 <__eerd_word_m2560>
	//IntOn();
	return word;
}
    9908:	08 95       	ret

0000990a <EE_InterBrokLine>:
	uint8_t WiAbsc, uint16_t (*TblAbsc)[WiAbsc], uint8_t Absc,
	uint8_t WiOrdi, uint16_t (*TblOrdi)[WiOrdi], uint8_t Ordi,
	uint8_t Len,
	int16_t x
)
{
    990a:	2f 92       	push	r2
    990c:	3f 92       	push	r3
    990e:	4f 92       	push	r4
    9910:	5f 92       	push	r5
    9912:	6f 92       	push	r6
    9914:	7f 92       	push	r7
    9916:	8f 92       	push	r8
    9918:	9f 92       	push	r9
    991a:	af 92       	push	r10
    991c:	bf 92       	push	r11
    991e:	cf 92       	push	r12
    9920:	df 92       	push	r13
    9922:	ef 92       	push	r14
    9924:	ff 92       	push	r15
    9926:	0f 93       	push	r16
    9928:	1f 93       	push	r17
    992a:	df 93       	push	r29
    992c:	cf 93       	push	r28
    992e:	cd b7       	in	r28, 0x3d	; 61
    9930:	de b7       	in	r29, 0x3e	; 62
    9932:	2e 97       	sbiw	r28, 0x0e	; 14
    9934:	0f b6       	in	r0, 0x3f	; 63
    9936:	f8 94       	cli
    9938:	de bf       	out	0x3e, r29	; 62
    993a:	0f be       	out	0x3f, r0	; 63
    993c:	cd bf       	out	0x3d, r28	; 61
    993e:	f8 2e       	mov	r15, r24
    9940:	2b 01       	movw	r4, r22
    9942:	2d 87       	std	Y+13, r18	; 0x0d
    9944:	18 01       	movw	r2, r16
    9946:	ee 86       	std	Y+14, r14	; 0x0e
    9948:	0c 2d       	mov	r16, r12
	LineGraph Segm;
	uint8_t i = 0;
	Segm.x2 = (int16_t)erw(TblAbsc[0]+Absc);
    994a:	c4 2e       	mov	r12, r20
    994c:	dd 24       	eor	r13, r13
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    994e:	c6 01       	movw	r24, r12
    9950:	88 0f       	add	r24, r24
    9952:	99 1f       	adc	r25, r25
    9954:	86 0f       	add	r24, r22
    9956:	97 1f       	adc	r25, r23
    9958:	0e 94 b2 7d 	call	0xfb64	; 0xfb64 <__eerd_word_m2560>
    995c:	aa 27       	eor	r26, r26
    995e:	97 fd       	sbrc	r25, 7
    9960:	a0 95       	com	r26
    9962:	ba 2f       	mov	r27, r26
    9964:	8d 83       	std	Y+5, r24	; 0x05
    9966:	9e 83       	std	Y+6, r25	; 0x06
    9968:	af 83       	std	Y+7, r26	; 0x07
    996a:	b8 87       	std	Y+8, r27	; 0x08
    996c:	ef 2c       	mov	r14, r15
    996e:	ff 24       	eor	r15, r15
    9970:	35 01       	movw	r6, r10
    9972:	88 24       	eor	r8, r8
    9974:	77 fc       	sbrc	r7, 7
    9976:	80 94       	com	r8
    9978:	98 2c       	mov	r9, r8
    997a:	10 e0       	ldi	r17, 0x00	; 0
    997c:	9c 01       	movw	r18, r24
    997e:	ad 01       	movw	r20, r26
	do {
		Segm.x1 = Segm.x2;
    9980:	29 83       	std	Y+1, r18	; 0x01
    9982:	3a 83       	std	Y+2, r19	; 0x02
    9984:	4b 83       	std	Y+3, r20	; 0x03
    9986:	5c 83       	std	Y+4, r21	; 0x04
		Segm.x2 = (int16_t)erw(TblAbsc[++i]+Absc);
    9988:	1f 5f       	subi	r17, 0xFF	; 255
    998a:	a1 2e       	mov	r10, r17
    998c:	bb 24       	eor	r11, r11
    998e:	ae 9c       	mul	r10, r14
    9990:	c0 01       	movw	r24, r0
    9992:	af 9c       	mul	r10, r15
    9994:	90 0d       	add	r25, r0
    9996:	be 9c       	mul	r11, r14
    9998:	90 0d       	add	r25, r0
    999a:	11 24       	eor	r1, r1
    999c:	8c 0d       	add	r24, r12
    999e:	9d 1d       	adc	r25, r13
    99a0:	88 0f       	add	r24, r24
    99a2:	99 1f       	adc	r25, r25
    99a4:	84 0d       	add	r24, r4
    99a6:	95 1d       	adc	r25, r5
    99a8:	0e 94 b2 7d 	call	0xfb64	; 0xfb64 <__eerd_word_m2560>
    99ac:	9c 01       	movw	r18, r24
    99ae:	44 27       	eor	r20, r20
    99b0:	37 fd       	sbrc	r19, 7
    99b2:	40 95       	com	r20
    99b4:	54 2f       	mov	r21, r20
    99b6:	2d 83       	std	Y+5, r18	; 0x05
    99b8:	3e 83       	std	Y+6, r19	; 0x06
    99ba:	4f 83       	std	Y+7, r20	; 0x07
    99bc:	58 87       	std	Y+8, r21	; 0x08
	} while(x>Segm.x2 && i<Len);
    99be:	26 15       	cp	r18, r6
    99c0:	37 05       	cpc	r19, r7
    99c2:	48 05       	cpc	r20, r8
    99c4:	59 05       	cpc	r21, r9
    99c6:	14 f4       	brge	.+4      	; 0x99cc <EE_InterBrokLine+0xc2>
    99c8:	10 17       	cp	r17, r16
    99ca:	d0 f2       	brcs	.-76     	; 0x9980 <EE_InterBrokLine+0x76>
	Segm.y1 = (int16_t)erw(TblOrdi[i-1]+Ordi);
    99cc:	8d 85       	ldd	r24, Y+13	; 0x0d
    99ce:	08 2f       	mov	r16, r24
    99d0:	10 e0       	ldi	r17, 0x00	; 0
    99d2:	8e 85       	ldd	r24, Y+14	; 0x0e
    99d4:	e8 2e       	mov	r14, r24
    99d6:	ff 24       	eor	r15, r15
    99d8:	08 94       	sec
    99da:	a1 08       	sbc	r10, r1
    99dc:	b1 08       	sbc	r11, r1
    99de:	a0 9e       	mul	r10, r16
    99e0:	c0 01       	movw	r24, r0
    99e2:	a1 9e       	mul	r10, r17
    99e4:	90 0d       	add	r25, r0
    99e6:	b0 9e       	mul	r11, r16
    99e8:	90 0d       	add	r25, r0
    99ea:	11 24       	eor	r1, r1
    99ec:	08 94       	sec
    99ee:	a1 1c       	adc	r10, r1
    99f0:	b1 1c       	adc	r11, r1
    99f2:	8e 0d       	add	r24, r14
    99f4:	9f 1d       	adc	r25, r15
    99f6:	88 0f       	add	r24, r24
    99f8:	99 1f       	adc	r25, r25
    99fa:	82 0d       	add	r24, r2
    99fc:	93 1d       	adc	r25, r3
    99fe:	0e 94 b2 7d 	call	0xfb64	; 0xfb64 <__eerd_word_m2560>
    9a02:	9a 87       	std	Y+10, r25	; 0x0a
    9a04:	89 87       	std	Y+9, r24	; 0x09
    9a06:	a0 9e       	mul	r10, r16
    9a08:	c0 01       	movw	r24, r0
    9a0a:	a1 9e       	mul	r10, r17
    9a0c:	90 0d       	add	r25, r0
    9a0e:	b0 9e       	mul	r11, r16
    9a10:	90 0d       	add	r25, r0
    9a12:	11 24       	eor	r1, r1
    9a14:	8e 0d       	add	r24, r14
    9a16:	9f 1d       	adc	r25, r15
    9a18:	88 0f       	add	r24, r24
    9a1a:	99 1f       	adc	r25, r25
    9a1c:	82 0d       	add	r24, r2
    9a1e:	93 1d       	adc	r25, r3
    9a20:	0e 94 b2 7d 	call	0xfb64	; 0xfb64 <__eerd_word_m2560>
	Segm.y2 = (int16_t)erw(TblOrdi[i]+Ordi);
    9a24:	9c 87       	std	Y+12, r25	; 0x0c
    9a26:	8b 87       	std	Y+11, r24	; 0x0b
	return LineFunc(&Segm, x);
    9a28:	ce 01       	movw	r24, r28
    9a2a:	01 96       	adiw	r24, 0x01	; 1
    9a2c:	b4 01       	movw	r22, r8
    9a2e:	a3 01       	movw	r20, r6
    9a30:	0e 94 48 20 	call	0x4090	; 0x4090 <LineFunc>
}
    9a34:	2e 96       	adiw	r28, 0x0e	; 14
    9a36:	0f b6       	in	r0, 0x3f	; 63
    9a38:	f8 94       	cli
    9a3a:	de bf       	out	0x3e, r29	; 62
    9a3c:	0f be       	out	0x3f, r0	; 63
    9a3e:	cd bf       	out	0x3d, r28	; 61
    9a40:	cf 91       	pop	r28
    9a42:	df 91       	pop	r29
    9a44:	1f 91       	pop	r17
    9a46:	0f 91       	pop	r16
    9a48:	ff 90       	pop	r15
    9a4a:	ef 90       	pop	r14
    9a4c:	df 90       	pop	r13
    9a4e:	cf 90       	pop	r12
    9a50:	bf 90       	pop	r11
    9a52:	af 90       	pop	r10
    9a54:	9f 90       	pop	r9
    9a56:	8f 90       	pop	r8
    9a58:	7f 90       	pop	r7
    9a5a:	6f 90       	pop	r6
    9a5c:	5f 90       	pop	r5
    9a5e:	4f 90       	pop	r4
    9a60:	3f 90       	pop	r3
    9a62:	2f 90       	pop	r2
    9a64:	08 95       	ret

00009a66 <MemCheck>:
}

// ~~~~~~~~~~~
uint8_t
MemCheck(void)
{
    9a66:	0f 93       	push	r16
    9a68:	1f 93       	push	r17
//	uint8_t T = Timer32Stopp(TD_Mem);
//	if (T) {
//		StartTimer32(TD_Mem, 360000);
		if (!(MemFail &(1<<MemFail_Flash)) && CRC_Flash_calc()!=erw(&MemCheck_stor.CRC_Flash_stor))
    9a6a:	80 91 c9 08 	lds	r24, 0x08C9
    9a6e:	80 ff       	sbrs	r24, 0
    9a70:	17 c0       	rjmp	.+46     	; 0x9aa0 <MemCheck+0x3a>
			MemFail |=(1<<MemFail_Flash);
		if (!(MemFail &(1<<MemFail_EEPROM)) && CRC_EEPROM_calc()!=erw(&MemCheck_stor.CRC_EEPROM_stor))
    9a72:	81 ff       	sbrs	r24, 1
    9a74:	03 c0       	rjmp	.+6      	; 0x9a7c <MemCheck+0x16>
			MemFail |=(1<<MemFail_EEPROM);
//	}
//	return T && MemFail;
	return MemFail;
}
    9a76:	1f 91       	pop	r17
    9a78:	0f 91       	pop	r16
    9a7a:	08 95       	ret
//	uint8_t T = Timer32Stopp(TD_Mem);
//	if (T) {
//		StartTimer32(TD_Mem, 360000);
		if (!(MemFail &(1<<MemFail_Flash)) && CRC_Flash_calc()!=erw(&MemCheck_stor.CRC_Flash_stor))
			MemFail |=(1<<MemFail_Flash);
		if (!(MemFail &(1<<MemFail_EEPROM)) && CRC_EEPROM_calc()!=erw(&MemCheck_stor.CRC_EEPROM_stor))
    9a7c:	0e 94 f8 18 	call	0x31f0	; 0x31f0 <CRC_EEPROM_calc>
    9a80:	8c 01       	movw	r16, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    9a82:	8a e3       	ldi	r24, 0x3A	; 58
    9a84:	91 e0       	ldi	r25, 0x01	; 1
    9a86:	0e 94 b2 7d 	call	0xfb64	; 0xfb64 <__eerd_word_m2560>
//	uint8_t T = Timer32Stopp(TD_Mem);
//	if (T) {
//		StartTimer32(TD_Mem, 360000);
		if (!(MemFail &(1<<MemFail_Flash)) && CRC_Flash_calc()!=erw(&MemCheck_stor.CRC_Flash_stor))
			MemFail |=(1<<MemFail_Flash);
		if (!(MemFail &(1<<MemFail_EEPROM)) && CRC_EEPROM_calc()!=erw(&MemCheck_stor.CRC_EEPROM_stor))
    9a8a:	08 17       	cp	r16, r24
    9a8c:	19 07       	cpc	r17, r25
    9a8e:	d9 f0       	breq	.+54     	; 0x9ac6 <MemCheck+0x60>
			MemFail |=(1<<MemFail_EEPROM);
    9a90:	80 91 c9 08 	lds	r24, 0x08C9
    9a94:	82 60       	ori	r24, 0x02	; 2
    9a96:	80 93 c9 08 	sts	0x08C9, r24
//	}
//	return T && MemFail;
	return MemFail;
}
    9a9a:	1f 91       	pop	r17
    9a9c:	0f 91       	pop	r16
    9a9e:	08 95       	ret
MemCheck(void)
{
//	uint8_t T = Timer32Stopp(TD_Mem);
//	if (T) {
//		StartTimer32(TD_Mem, 360000);
		if (!(MemFail &(1<<MemFail_Flash)) && CRC_Flash_calc()!=erw(&MemCheck_stor.CRC_Flash_stor))
    9aa0:	0e 94 de 18 	call	0x31bc	; 0x31bc <CRC_Flash_calc>
    9aa4:	8c 01       	movw	r16, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    9aa6:	88 e3       	ldi	r24, 0x38	; 56
    9aa8:	91 e0       	ldi	r25, 0x01	; 1
    9aaa:	0e 94 b2 7d 	call	0xfb64	; 0xfb64 <__eerd_word_m2560>
MemCheck(void)
{
//	uint8_t T = Timer32Stopp(TD_Mem);
//	if (T) {
//		StartTimer32(TD_Mem, 360000);
		if (!(MemFail &(1<<MemFail_Flash)) && CRC_Flash_calc()!=erw(&MemCheck_stor.CRC_Flash_stor))
    9aae:	08 17       	cp	r16, r24
    9ab0:	19 07       	cpc	r17, r25
    9ab2:	31 f0       	breq	.+12     	; 0x9ac0 <MemCheck+0x5a>
			MemFail |=(1<<MemFail_Flash);
    9ab4:	80 91 c9 08 	lds	r24, 0x08C9
    9ab8:	81 60       	ori	r24, 0x01	; 1
    9aba:	80 93 c9 08 	sts	0x08C9, r24
    9abe:	d9 cf       	rjmp	.-78     	; 0x9a72 <MemCheck+0xc>
    9ac0:	80 91 c9 08 	lds	r24, 0x08C9
    9ac4:	d6 cf       	rjmp	.-84     	; 0x9a72 <MemCheck+0xc>
    9ac6:	80 91 c9 08 	lds	r24, 0x08C9
    9aca:	d5 cf       	rjmp	.-86     	; 0x9a76 <MemCheck+0x10>

00009acc <MemCheckMsg>:

// ~~~~~~~~~~~~~~
void
MemCheckMsg(void)
{
	if(MemCheck())
    9acc:	0e 94 33 4d 	call	0x9a66	; 0x9a66 <MemCheck>
    9ad0:	88 23       	and	r24, r24
    9ad2:	09 f4       	brne	.+2      	; 0x9ad6 <MemCheckMsg+0xa>
    9ad4:	08 95       	ret

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    9ad6:	80 91 c9 08 	lds	r24, 0x08C9
    9ada:	e8 2f       	mov	r30, r24
    9adc:	f0 e0       	ldi	r31, 0x00	; 0
    9ade:	ee 0f       	add	r30, r30
    9ae0:	ff 1f       	adc	r31, r31
    9ae2:	e6 5b       	subi	r30, 0xB6	; 182
    9ae4:	f8 4e       	sbci	r31, 0xE8	; 232
		ShowMsg(prp(MsgErrMemo+MemFail));
    9ae6:	85 91       	lpm	r24, Z+
    9ae8:	94 91       	lpm	r25, Z+
    9aea:	0e 94 ef 3b 	call	0x77de	; 0x77de <ShowMsg>
    9aee:	08 95       	ret

00009af0 <erb>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    9af0:	0e 94 a4 7d 	call	0xfb48	; 0xfb48 <__eerd_byte_m2560>
	//IntOn();
	return byte;
}
    9af4:	08 95       	ret

00009af6 <ThermChanWrong>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
ThermChanWrong(uint8_t ChanN)
{
    9af6:	ff 92       	push	r15
    9af8:	0f 93       	push	r16
    9afa:	1f 93       	push	r17
	return ThermWrong(prb(ThermFami+ChanN), erb(ThermType+ChanN), Temperature[ChanN]);
    9afc:	08 2f       	mov	r16, r24
    9afe:	10 e0       	ldi	r17, 0x00	; 0

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    9b00:	f8 01       	movw	r30, r16
    9b02:	e0 55       	subi	r30, 0x50	; 80
    9b04:	f9 4f       	sbci	r31, 0xF9	; 249
    9b06:	f4 90       	lpm	r15, Z+
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    9b08:	c8 01       	movw	r24, r16
    9b0a:	89 5e       	subi	r24, 0xE9	; 233
    9b0c:	9e 4f       	sbci	r25, 0xFE	; 254
    9b0e:	0e 94 a4 7d 	call	0xfb48	; 0xfb48 <__eerd_byte_m2560>
    9b12:	68 2f       	mov	r22, r24
    9b14:	00 0f       	add	r16, r16
    9b16:	11 1f       	adc	r17, r17
    9b18:	03 5c       	subi	r16, 0xC3	; 195
    9b1a:	19 4f       	sbci	r17, 0xF9	; 249
    9b1c:	f8 01       	movw	r30, r16
    9b1e:	40 81       	ld	r20, Z
    9b20:	51 81       	ldd	r21, Z+1	; 0x01
    9b22:	8f 2d       	mov	r24, r15
    9b24:	0e 94 0f 3f 	call	0x7e1e	; 0x7e1e <ThermWrong>
}
    9b28:	1f 91       	pop	r17
    9b2a:	0f 91       	pop	r16
    9b2c:	ff 90       	pop	r15
    9b2e:	08 95       	ret

00009b30 <ThermChan>:
}

// ~~~~~~~~~~~~~~~~~~~~~
void
ThermChan(uint8_t ChanN)
{
    9b30:	8f 92       	push	r8
    9b32:	9f 92       	push	r9
    9b34:	af 92       	push	r10
    9b36:	bf 92       	push	r11
    9b38:	cf 92       	push	r12
    9b3a:	df 92       	push	r13
    9b3c:	ef 92       	push	r14
    9b3e:	ff 92       	push	r15
    9b40:	0f 93       	push	r16
    9b42:	1f 93       	push	r17
    9b44:	cf 93       	push	r28
    9b46:	df 93       	push	r29
	if (ChanN>=TerReg)
    9b48:	86 30       	cpi	r24, 0x06	; 6
    9b4a:	08 f0       	brcs	.+2      	; 0x9b4e <ThermChan+0x1e>
    9b4c:	4c c0       	rjmp	.+152    	; 0x9be6 <ThermChan+0xb6>
		return;
    9b4e:	e8 2e       	mov	r14, r24
    9b50:	ff 24       	eor	r15, r15
    9b52:	d7 01       	movw	r26, r14
    9b54:	aa 0f       	add	r26, r26
    9b56:	bb 1f       	adc	r27, r27
    9b58:	a2 95       	swap	r26
    9b5a:	b2 95       	swap	r27
    9b5c:	b0 7f       	andi	r27, 0xF0	; 240
    9b5e:	ba 27       	eor	r27, r26
    9b60:	a0 7f       	andi	r26, 0xF0	; 240
    9b62:	ba 27       	eor	r27, r26
    9b64:	fd 01       	movw	r30, r26
    9b66:	eb 5e       	subi	r30, 0xEB	; 235
    9b68:	fa 4f       	sbci	r31, 0xFA	; 250
    9b6a:	2f e0       	ldi	r18, 0x0F	; 15
	for (uint8_t i=TerFiltLev*4-1; i; i--)
		TerBuf[ChanN][i] = TerBuf[ChanN][i-1];
    9b6c:	80 81       	ld	r24, Z
    9b6e:	91 81       	ldd	r25, Z+1	; 0x01
    9b70:	93 83       	std	Z+3, r25	; 0x03
    9b72:	82 83       	std	Z+2, r24	; 0x02
void
ThermChan(uint8_t ChanN)
{
	if (ChanN>=TerReg)
		return;
	for (uint8_t i=TerFiltLev*4-1; i; i--)
    9b74:	21 50       	subi	r18, 0x01	; 1
    9b76:	32 97       	sbiw	r30, 0x02	; 2
    9b78:	22 23       	and	r18, r18
    9b7a:	c1 f7       	brne	.-16     	; 0x9b6c <ThermChan+0x3c>
		TerBuf[ChanN][i] = TerBuf[ChanN][i-1];
	TerBuf[ChanN][0] = TerInput[ChanN];
    9b7c:	a7 50       	subi	r26, 0x07	; 7
    9b7e:	bb 4f       	sbci	r27, 0xFB	; 251
    9b80:	47 01       	movw	r8, r14
    9b82:	88 0c       	add	r8, r8
    9b84:	99 1c       	adc	r9, r9
    9b86:	f4 01       	movw	r30, r8
    9b88:	e3 53       	subi	r30, 0x33	; 51
    9b8a:	f7 4f       	sbci	r31, 0xF7	; 247
    9b8c:	80 81       	ld	r24, Z
    9b8e:	91 81       	ldd	r25, Z+1	; 0x01
    9b90:	8d 93       	st	X+, r24
    9b92:	9c 93       	st	X, r25

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    9b94:	f7 01       	movw	r30, r14
    9b96:	e0 55       	subi	r30, 0x50	; 80
    9b98:	f9 4f       	sbci	r31, 0xF9	; 249
    9b9a:	c4 90       	lpm	r12, Z+
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    9b9c:	c7 01       	movw	r24, r14
    9b9e:	89 5e       	subi	r24, 0xE9	; 233
    9ba0:	9e 4f       	sbci	r25, 0xFE	; 254
    9ba2:	0e 94 a4 7d 	call	0xfb48	; 0xfb48 <__eerd_byte_m2560>
    9ba6:	18 2f       	mov	r17, r24
	int16_t Ter = Thermode(prb(ThermFami+ChanN), erb(ThermType+ChanN), DigiFilt(TerBuf[ChanN],TerFiltLev));
    9ba8:	c7 01       	movw	r24, r14
    9baa:	88 0f       	add	r24, r24
    9bac:	99 1f       	adc	r25, r25
    9bae:	82 95       	swap	r24
    9bb0:	92 95       	swap	r25
    9bb2:	90 7f       	andi	r25, 0xF0	; 240
    9bb4:	98 27       	eor	r25, r24
    9bb6:	80 7f       	andi	r24, 0xF0	; 240
    9bb8:	98 27       	eor	r25, r24
    9bba:	87 50       	subi	r24, 0x07	; 7
    9bbc:	9b 4f       	sbci	r25, 0xFB	; 251
    9bbe:	64 e0       	ldi	r22, 0x04	; 4
    9bc0:	0e 94 24 4a 	call	0x9448	; 0x9448 <DigiFilt>
    9bc4:	ac 01       	movw	r20, r24
    9bc6:	8c 2d       	mov	r24, r12
    9bc8:	61 2f       	mov	r22, r17
    9bca:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <Thermode>
    9bce:	ec 01       	movw	r28, r24
	if (Ter!=Therm_Off_Mark)
    9bd0:	80 e8       	ldi	r24, 0x80	; 128
    9bd2:	c0 30       	cpi	r28, 0x00	; 0
    9bd4:	d8 07       	cpc	r29, r24
    9bd6:	a1 f4       	brne	.+40     	; 0x9c00 <ThermChan+0xd0>
		Ter = (Ter+(int8_t)erb(&ThermCorr[ChanN].D))*(erw(&ThermCorr[ChanN].A)/1000.0);
	Temperature[ChanN] = Ter;
    9bd8:	ed e3       	ldi	r30, 0x3D	; 61
    9bda:	f6 e0       	ldi	r31, 0x06	; 6
    9bdc:	8e 0e       	add	r8, r30
    9bde:	9f 1e       	adc	r9, r31
    9be0:	f4 01       	movw	r30, r8
    9be2:	d1 83       	std	Z+1, r29	; 0x01
    9be4:	c0 83       	st	Z, r28
}
    9be6:	df 91       	pop	r29
    9be8:	cf 91       	pop	r28
    9bea:	1f 91       	pop	r17
    9bec:	0f 91       	pop	r16
    9bee:	ff 90       	pop	r15
    9bf0:	ef 90       	pop	r14
    9bf2:	df 90       	pop	r13
    9bf4:	cf 90       	pop	r12
    9bf6:	bf 90       	pop	r11
    9bf8:	af 90       	pop	r10
    9bfa:	9f 90       	pop	r9
    9bfc:	8f 90       	pop	r8
    9bfe:	08 95       	ret
    9c00:	64 01       	movw	r12, r8
    9c02:	ce 0c       	add	r12, r14
    9c04:	df 1c       	adc	r13, r15
    9c06:	c6 01       	movw	r24, r12
    9c08:	83 5e       	subi	r24, 0xE3	; 227
    9c0a:	9e 4f       	sbci	r25, 0xFE	; 254
    9c0c:	0e 94 a4 7d 	call	0xfb48	; 0xfb48 <__eerd_byte_m2560>
    9c10:	e8 2e       	mov	r14, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    9c12:	c6 01       	movw	r24, r12
    9c14:	82 5e       	subi	r24, 0xE2	; 226
    9c16:	9e 4f       	sbci	r25, 0xFE	; 254
    9c18:	0e 94 b2 7d 	call	0xfb64	; 0xfb64 <__eerd_word_m2560>
    9c1c:	5c 01       	movw	r10, r24
	for (uint8_t i=TerFiltLev*4-1; i; i--)
		TerBuf[ChanN][i] = TerBuf[ChanN][i-1];
	TerBuf[ChanN][0] = TerInput[ChanN];
	int16_t Ter = Thermode(prb(ThermFami+ChanN), erb(ThermType+ChanN), DigiFilt(TerBuf[ChanN],TerFiltLev));
	if (Ter!=Therm_Off_Mark)
		Ter = (Ter+(int8_t)erb(&ThermCorr[ChanN].D))*(erw(&ThermCorr[ChanN].A)/1000.0);
    9c1e:	ff 24       	eor	r15, r15
    9c20:	e7 fc       	sbrc	r14, 7
    9c22:	f0 94       	com	r15
    9c24:	ec 0e       	add	r14, r28
    9c26:	fd 1e       	adc	r15, r29
    9c28:	00 27       	eor	r16, r16
    9c2a:	f7 fc       	sbrc	r15, 7
    9c2c:	00 95       	com	r16
    9c2e:	10 2f       	mov	r17, r16
    9c30:	c8 01       	movw	r24, r16
    9c32:	b7 01       	movw	r22, r14
    9c34:	0e 94 95 78 	call	0xf12a	; 0xf12a <__floatsisf>
    9c38:	7b 01       	movw	r14, r22
    9c3a:	8c 01       	movw	r16, r24
    9c3c:	cc 24       	eor	r12, r12
    9c3e:	dd 24       	eor	r13, r13
    9c40:	c6 01       	movw	r24, r12
    9c42:	b5 01       	movw	r22, r10
    9c44:	0e 94 93 78 	call	0xf126	; 0xf126 <__floatunsisf>
    9c48:	20 e0       	ldi	r18, 0x00	; 0
    9c4a:	30 e0       	ldi	r19, 0x00	; 0
    9c4c:	4a e7       	ldi	r20, 0x7A	; 122
    9c4e:	54 e4       	ldi	r21, 0x44	; 68
    9c50:	0e 94 fb 7c 	call	0xf9f6	; 0xf9f6 <__divsf3>
    9c54:	9b 01       	movw	r18, r22
    9c56:	ac 01       	movw	r20, r24
    9c58:	c8 01       	movw	r24, r16
    9c5a:	b7 01       	movw	r22, r14
    9c5c:	0e 94 d0 78 	call	0xf1a0	; 0xf1a0 <__mulsf3>
    9c60:	0e 94 63 7d 	call	0xfac6	; 0xfac6 <__fixsfsi>
    9c64:	eb 01       	movw	r28, r22
    9c66:	b8 cf       	rjmp	.-144    	; 0x9bd8 <ThermChan+0xa8>

00009c68 <ThermInit>:
}

// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
ThermInit(uint8_t ChanN)
{
    9c68:	ef 92       	push	r14
    9c6a:	ff 92       	push	r15
    9c6c:	0f 93       	push	r16
    9c6e:	1f 93       	push	r17
    9c70:	cf 93       	push	r28
    9c72:	df 93       	push	r29
    9c74:	f8 2e       	mov	r15, r24
	if (ChanN<TerReg) {
    9c76:	85 e0       	ldi	r24, 0x05	; 5
    9c78:	8f 15       	cp	r24, r15
    9c7a:	68 f1       	brcs	.+90     	; 0x9cd6 <ThermInit+0x6e>
    9c7c:	8f 2d       	mov	r24, r15
    9c7e:	90 e0       	ldi	r25, 0x00	; 0
    9c80:	8c 01       	movw	r16, r24
    9c82:	00 0f       	add	r16, r16
    9c84:	11 1f       	adc	r17, r17
    9c86:	f8 01       	movw	r30, r16
    9c88:	e3 53       	subi	r30, 0x33	; 51
    9c8a:	f7 4f       	sbci	r31, 0xF7	; 247
    9c8c:	c0 81       	ld	r28, Z
    9c8e:	d1 81       	ldd	r29, Z+1	; 0x01
    9c90:	fc 01       	movw	r30, r24
    9c92:	ee 0f       	add	r30, r30
    9c94:	ff 1f       	adc	r31, r31
    9c96:	e2 95       	swap	r30
    9c98:	f2 95       	swap	r31
    9c9a:	f0 7f       	andi	r31, 0xF0	; 240
    9c9c:	fe 27       	eor	r31, r30
    9c9e:	e0 7f       	andi	r30, 0xF0	; 240
    9ca0:	fe 27       	eor	r31, r30
    9ca2:	e7 50       	subi	r30, 0x07	; 7
    9ca4:	fb 4f       	sbci	r31, 0xFB	; 251
    9ca6:	20 e0       	ldi	r18, 0x00	; 0
		for (uint8_t i=0; i<TerFiltLev*4; TerBuf[ChanN][i++]=TerInput[ChanN]);
    9ca8:	c1 93       	st	Z+, r28
    9caa:	d1 93       	st	Z+, r29
    9cac:	2f 5f       	subi	r18, 0xFF	; 255
    9cae:	20 31       	cpi	r18, 0x10	; 16
    9cb0:	d9 f7       	brne	.-10     	; 0x9ca8 <ThermInit+0x40>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    9cb2:	fc 01       	movw	r30, r24
    9cb4:	e0 55       	subi	r30, 0x50	; 80
    9cb6:	f9 4f       	sbci	r31, 0xF9	; 249
    9cb8:	e4 90       	lpm	r14, Z+
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    9cba:	89 5e       	subi	r24, 0xE9	; 233
    9cbc:	9e 4f       	sbci	r25, 0xFE	; 254
    9cbe:	0e 94 a4 7d 	call	0xfb48	; 0xfb48 <__eerd_byte_m2560>
    9cc2:	68 2f       	mov	r22, r24
		Temperature[ChanN] = Thermode(prb(ThermFami+ChanN), erb(ThermType+ChanN), TerInput[ChanN]);
    9cc4:	8e 2d       	mov	r24, r14
    9cc6:	ae 01       	movw	r20, r28
    9cc8:	0e 94 8f 3e 	call	0x7d1e	; 0x7d1e <Thermode>
    9ccc:	03 5c       	subi	r16, 0xC3	; 195
    9cce:	19 4f       	sbci	r17, 0xF9	; 249
    9cd0:	f8 01       	movw	r30, r16
    9cd2:	91 83       	std	Z+1, r25	; 0x01
    9cd4:	80 83       	st	Z, r24
    9cd6:	80 e0       	ldi	r24, 0x00	; 0
    9cd8:	f5 e0       	ldi	r31, 0x05	; 5
    9cda:	ff 12       	cpse	r15, r31
    9cdc:	81 e0       	ldi	r24, 0x01	; 1
	}
	return ChanN!=TerReg-1;
}
    9cde:	df 91       	pop	r29
    9ce0:	cf 91       	pop	r28
    9ce2:	1f 91       	pop	r17
    9ce4:	0f 91       	pop	r16
    9ce6:	ff 90       	pop	r15
    9ce8:	ef 90       	pop	r14
    9cea:	08 95       	ret

00009cec <DigitIn>:
}

// ~~~~~~~~~~
void
DigitIn(void)
{
    9cec:	cf 93       	push	r28
    9cee:	df 93       	push	r29
	memcpy(DigInput.StateOld, DigInput.State, DI_Reg+DI_Reg_Ext);
    9cf0:	e9 ef       	ldi	r30, 0xF9	; 249
    9cf2:	f6 e0       	ldi	r31, 0x06	; 6
    9cf4:	df 01       	movw	r26, r30
    9cf6:	13 97       	sbiw	r26, 0x03	; 3
    9cf8:	83 e0       	ldi	r24, 0x03	; 3
    9cfa:	0d 90       	ld	r0, X+
    9cfc:	01 92       	st	Z+, r0
    9cfe:	81 50       	subi	r24, 0x01	; 1
    9d00:	e1 f7       	brne	.-8      	; 0x9cfa <DigitIn+0xe>
    9d02:	84 e1       	ldi	r24, 0x14	; 20
    9d04:	91 e0       	ldi	r25, 0x01	; 1
    9d06:	0e 94 a4 7d 	call	0xfb48	; 0xfb48 <__eerd_byte_m2560>
	for (uint8_t i=0; i<DI_Reg; i++)
		DigInput.Status[i] = DigInput.State[i]^erb(DI_Invers+i);
    9d0a:	90 91 f6 06 	lds	r25, 0x06F6
    9d0e:	98 27       	eor	r25, r24
    9d10:	90 93 fc 06 	sts	0x06FC, r25
    9d14:	85 e1       	ldi	r24, 0x15	; 21
    9d16:	91 e0       	ldi	r25, 0x01	; 1
    9d18:	0e 94 a4 7d 	call	0xfb48	; 0xfb48 <__eerd_byte_m2560>
    9d1c:	90 91 f7 06 	lds	r25, 0x06F7
    9d20:	98 27       	eor	r25, r24
    9d22:	90 93 fd 06 	sts	0x06FD, r25
    9d26:	86 e1       	ldi	r24, 0x16	; 22
    9d28:	91 e0       	ldi	r25, 0x01	; 1
    9d2a:	0e 94 a4 7d 	call	0xfb48	; 0xfb48 <__eerd_byte_m2560>
    9d2e:	90 91 f8 06 	lds	r25, 0x06F8
    9d32:	98 27       	eor	r25, r24
    9d34:	90 93 fe 06 	sts	0x06FE, r25
    9d38:	40 e0       	ldi	r20, 0x00	; 0
    9d3a:	50 e0       	ldi	r21, 0x00	; 0
#else
	static void
	DigitIn_Hard(void)
	{
		for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
			uint8_t Byte=D_N/8, Bit=1<<D_N%8;
    9d3c:	a1 e0       	ldi	r26, 0x01	; 1
    9d3e:	b0 e0       	ldi	r27, 0x00	; 0
    9d40:	1b c0       	rjmp	.+54     	; 0x9d78 <DigitIn+0x8c>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    9d42:	c9 01       	movw	r24, r18
    9d44:	86 5c       	subi	r24, 0xC6	; 198
    9d46:	94 4d       	sbci	r25, 0xD4	; 212
    9d48:	fc 01       	movw	r30, r24
    9d4a:	c5 91       	lpm	r28, Z+
    9d4c:	d4 91       	lpm	r29, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    9d4e:	24 5c       	subi	r18, 0xC4	; 196
    9d50:	34 4d       	sbci	r19, 0xD4	; 212
    9d52:	f9 01       	movw	r30, r18
    9d54:	84 91       	lpm	r24, Z+
			if(prb(&DI_M[D_N].Inversion)){
				if (*(uint8_t*)prp(&DI_M[D_N].PIN) & prb(&DI_M[D_N].P))
    9d56:	98 81       	ld	r25, Y
    9d58:	89 23       	and	r24, r25
    9d5a:	09 f4       	brne	.+2      	; 0x9d5e <DigitIn+0x72>
    9d5c:	3d c0       	rjmp	.+122    	; 0x9dd8 <DigitIn+0xec>
			}
			else{
				if (*(uint8_t*)prp(&DI_M[D_N].PIN) & prb(&DI_M[D_N].P))
					DigInput.State[Byte] &=~Bit;
				else
					DigInput.State[Byte]  |=Bit;
    9d5e:	e7 2f       	mov	r30, r23
    9d60:	f0 e0       	ldi	r31, 0x00	; 0
    9d62:	ea 50       	subi	r30, 0x0A	; 10
    9d64:	f9 4f       	sbci	r31, 0xF9	; 249
    9d66:	80 81       	ld	r24, Z
    9d68:	86 2b       	or	r24, r22
    9d6a:	80 83       	st	Z, r24
    9d6c:	4f 5f       	subi	r20, 0xFF	; 255
    9d6e:	5f 4f       	sbci	r21, 0xFF	; 255
	void DigitIn_Hard(void);
#else
	static void
	DigitIn_Hard(void)
	{
		for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
    9d70:	42 31       	cpi	r20, 0x12	; 18
    9d72:	51 05       	cpc	r21, r1
    9d74:	09 f4       	brne	.+2      	; 0x9d78 <DigitIn+0x8c>
    9d76:	3e c0       	rjmp	.+124    	; 0x9df4 <DigitIn+0x108>
			uint8_t Byte=D_N/8, Bit=1<<D_N%8;
    9d78:	74 2f       	mov	r23, r20
    9d7a:	76 95       	lsr	r23
    9d7c:	76 95       	lsr	r23
    9d7e:	76 95       	lsr	r23
    9d80:	ca 01       	movw	r24, r20
    9d82:	87 70       	andi	r24, 0x07	; 7
    9d84:	90 70       	andi	r25, 0x00	; 0
    9d86:	9d 01       	movw	r18, r26
    9d88:	02 c0       	rjmp	.+4      	; 0x9d8e <DigitIn+0xa2>
    9d8a:	22 0f       	add	r18, r18
    9d8c:	33 1f       	adc	r19, r19
    9d8e:	8a 95       	dec	r24
    9d90:	e2 f7       	brpl	.-8      	; 0x9d8a <DigitIn+0x9e>
    9d92:	62 2f       	mov	r22, r18
    9d94:	9a 01       	movw	r18, r20
    9d96:	22 0f       	add	r18, r18
    9d98:	33 1f       	adc	r19, r19
    9d9a:	22 0f       	add	r18, r18
    9d9c:	33 1f       	adc	r19, r19
    9d9e:	22 0f       	add	r18, r18
    9da0:	33 1f       	adc	r19, r19
    9da2:	f9 01       	movw	r30, r18
    9da4:	e3 5c       	subi	r30, 0xC3	; 195
    9da6:	f4 4d       	sbci	r31, 0xD4	; 212
    9da8:	e4 91       	lpm	r30, Z+
			if(prb(&DI_M[D_N].Inversion)){
    9daa:	ee 23       	and	r30, r30
    9dac:	09 f0       	breq	.+2      	; 0x9db0 <DigitIn+0xc4>
    9dae:	c9 cf       	rjmp	.-110    	; 0x9d42 <DigitIn+0x56>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    9db0:	ca 01       	movw	r24, r20
    9db2:	88 0f       	add	r24, r24
    9db4:	99 1f       	adc	r25, r25
    9db6:	88 0f       	add	r24, r24
    9db8:	99 1f       	adc	r25, r25
    9dba:	88 0f       	add	r24, r24
    9dbc:	99 1f       	adc	r25, r25
    9dbe:	86 5c       	subi	r24, 0xC6	; 198
    9dc0:	94 4d       	sbci	r25, 0xD4	; 212
    9dc2:	fc 01       	movw	r30, r24
    9dc4:	c5 91       	lpm	r28, Z+
    9dc6:	d4 91       	lpm	r29, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    9dc8:	24 5c       	subi	r18, 0xC4	; 196
    9dca:	34 4d       	sbci	r19, 0xD4	; 212
    9dcc:	f9 01       	movw	r30, r18
    9dce:	84 91       	lpm	r24, Z+
					DigInput.State[Byte] |=Bit;
				else
					DigInput.State[Byte] &=~Bit;
			}
			else{
				if (*(uint8_t*)prp(&DI_M[D_N].PIN) & prb(&DI_M[D_N].P))
    9dd0:	98 81       	ld	r25, Y
    9dd2:	89 23       	and	r24, r25
    9dd4:	09 f4       	brne	.+2      	; 0x9dd8 <DigitIn+0xec>
    9dd6:	c3 cf       	rjmp	.-122    	; 0x9d5e <DigitIn+0x72>
					DigInput.State[Byte] &=~Bit;
    9dd8:	e7 2f       	mov	r30, r23
    9dda:	f0 e0       	ldi	r31, 0x00	; 0
    9ddc:	ea 50       	subi	r30, 0x0A	; 10
    9dde:	f9 4f       	sbci	r31, 0xF9	; 249
    9de0:	60 95       	com	r22
    9de2:	80 81       	ld	r24, Z
    9de4:	68 23       	and	r22, r24
    9de6:	60 83       	st	Z, r22
				else
					DigInput.State[Byte]  |=Bit;
    9de8:	4f 5f       	subi	r20, 0xFF	; 255
    9dea:	5f 4f       	sbci	r21, 0xFF	; 255
	void DigitIn_Hard(void);
#else
	static void
	DigitIn_Hard(void)
	{
		for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
    9dec:	42 31       	cpi	r20, 0x12	; 18
    9dee:	51 05       	cpc	r21, r1
    9df0:	09 f0       	breq	.+2      	; 0x9df4 <DigitIn+0x108>
    9df2:	c2 cf       	rjmp	.-124    	; 0x9d78 <DigitIn+0x8c>
			DigInput.State[j]		= (DigInput_Ext)[i];
			DigInput.Status[j]	= (DigInput_Ext)[i+DI_Reg_Ext];
			IntOn();
		}
	#endif
}
    9df4:	df 91       	pop	r29
    9df6:	cf 91       	pop	r28
    9df8:	08 95       	ret

00009dfa <Field2Buf>:
	else return 0;
}
// ~~~~~~~~~~~~~~~~~~~~~~~
static void
Field2Buf(OutField *Field)
{
    9dfa:	6f 92       	push	r6
    9dfc:	7f 92       	push	r7
    9dfe:	8f 92       	push	r8
    9e00:	9f 92       	push	r9
    9e02:	af 92       	push	r10
    9e04:	bf 92       	push	r11
    9e06:	cf 92       	push	r12
    9e08:	df 92       	push	r13
    9e0a:	ef 92       	push	r14
    9e0c:	ff 92       	push	r15
    9e0e:	0f 93       	push	r16
    9e10:	1f 93       	push	r17
    9e12:	df 93       	push	r29
    9e14:	cf 93       	push	r28
    9e16:	cd b7       	in	r28, 0x3d	; 61
    9e18:	de b7       	in	r29, 0x3e	; 62
    9e1a:	6f 97       	sbiw	r28, 0x1f	; 31
    9e1c:	0f b6       	in	r0, 0x3f	; 63
    9e1e:	f8 94       	cli
    9e20:	de bf       	out	0x3e, r29	; 62
    9e22:	0f be       	out	0x3f, r0	; 63
    9e24:	cd bf       	out	0x3d, r28	; 61
    9e26:	7c 01       	movw	r14, r24

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    9e28:	fc 01       	movw	r30, r24
    9e2a:	31 96       	adiw	r30, 0x01	; 1
    9e2c:	c5 90       	lpm	r12, Z+
    9e2e:	d4 90       	lpm	r13, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    9e30:	bf e0       	ldi	r27, 0x0F	; 15
    9e32:	8b 2e       	mov	r8, r27
    9e34:	91 2c       	mov	r9, r1
    9e36:	88 0e       	add	r8, r24
    9e38:	99 1e       	adc	r9, r25
    9e3a:	f4 01       	movw	r30, r8
    9e3c:	24 91       	lpm	r18, Z+
	void *Var = prp(&Field->Var);
	uint8_t BitN=prb(&Field->Prec), Mask=1<<BitN%8, *BitVar=(uint8_t*)Var+BitN/8;
    9e3e:	32 2f       	mov	r19, r18
    9e40:	37 70       	andi	r19, 0x07	; 7
    9e42:	81 e0       	ldi	r24, 0x01	; 1
    9e44:	90 e0       	ldi	r25, 0x00	; 0
    9e46:	18 2f       	mov	r17, r24
    9e48:	01 c0       	rjmp	.+2      	; 0x9e4c <Field2Buf+0x52>
    9e4a:	11 0f       	add	r17, r17
    9e4c:	3a 95       	dec	r19
    9e4e:	ea f7       	brpl	.-6      	; 0x9e4a <Field2Buf+0x50>
    9e50:	26 95       	lsr	r18
    9e52:	26 95       	lsr	r18
    9e54:	26 95       	lsr	r18
    9e56:	56 01       	movw	r10, r12
    9e58:	a2 0e       	add	r10, r18
    9e5a:	b1 1c       	adc	r11, r1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    9e5c:	a7 e0       	ldi	r26, 0x07	; 7
    9e5e:	6a 2e       	mov	r6, r26
    9e60:	71 2c       	mov	r7, r1
    9e62:	6e 0c       	add	r6, r14
    9e64:	7f 1c       	adc	r7, r15
    9e66:	f3 01       	movw	r30, r6
    9e68:	65 91       	lpm	r22, Z+
    9e6a:	75 91       	lpm	r23, Z+
    9e6c:	85 91       	lpm	r24, Z+
    9e6e:	94 91       	lpm	r25, Z+
	uint8_t Pos=Log10(prd(&Field->Max));
    9e70:	0e 94 0b 20 	call	0x4016	; 0x4016 <Log10>
    9e74:	08 2f       	mov	r16, r24

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    9e76:	f7 01       	movw	r30, r14
    9e78:	84 91       	lpm	r24, Z+
	uint8_t Oldstyle = 0;

	switch(prb(&Field->Type)) {
    9e7a:	e8 2f       	mov	r30, r24
    9e7c:	f0 e0       	ldi	r31, 0x00	; 0
    9e7e:	e1 32       	cpi	r30, 0x21	; 33
    9e80:	f1 05       	cpc	r31, r1
    9e82:	08 f4       	brcc	.+2      	; 0x9e86 <Field2Buf+0x8c>
    9e84:	6e c0       	rjmp	.+220    	; 0x9f62 <Field2Buf+0x168>
		F_Buf = (erb(BitVar) &Mask) > 0;
		Oldstyle = 1;
		break;
	}

	Minus=0;
    9e86:	10 92 f7 04 	sts	0x04F7, r1
	if(Oldstyle) return;

	InitBufStr(Field);
    9e8a:	c7 01       	movw	r24, r14
    9e8c:	0e 94 6d 3b 	call	0x76da	; 0x76da <InitBufStr>
	CurrFieldSize = GetCurrFieldSize();
    9e90:	0e 94 2f 3c 	call	0x785e	; 0x785e <GetCurrFieldSize>
    9e94:	48 2f       	mov	r20, r24
    9e96:	80 93 74 07 	sts	0x0774, r24
	CurrPos = CurrFieldSize - 1;
    9e9a:	41 50       	subi	r20, 0x01	; 1
    9e9c:	40 93 d4 02 	sts	0x02D4, r20
    9ea0:	4f 5f       	subi	r20, 0xFF	; 255
	float fTemp;
	T_Param Param;
	Param.Size = CurrFieldSize;
    9ea2:	48 87       	std	Y+8, r20	; 0x08
	Param.Pos = BufStr;
    9ea4:	8b eb       	ldi	r24, 0xBB	; 187
    9ea6:	95 e0       	ldi	r25, 0x05	; 5
    9ea8:	9e 83       	std	Y+6, r25	; 0x06
    9eaa:	8d 83       	std	Y+5, r24	; 0x05
    9eac:	f4 01       	movw	r30, r8
    9eae:	84 91       	lpm	r24, Z+
	Param.Prec = prb(&Field->Prec);
    9eb0:	8f 83       	std	Y+7, r24	; 0x07
	Param.Txt = NULL;
    9eb2:	1a 86       	std	Y+10, r1	; 0x0a
    9eb4:	19 86       	std	Y+9, r1	; 0x09
    9eb6:	f7 01       	movw	r30, r14
    9eb8:	84 91       	lpm	r24, Z+

	switch(prb(&Field->Type)) {
    9eba:	85 31       	cpi	r24, 0x15	; 21
    9ebc:	09 f4       	brne	.+2      	; 0x9ec0 <Field2Buf+0xc6>
    9ebe:	74 c1       	rjmp	.+744    	; 0xa1a8 <Field2Buf+0x3ae>
    9ec0:	86 31       	cpi	r24, 0x16	; 22
    9ec2:	08 f4       	brcc	.+2      	; 0x9ec6 <Field2Buf+0xcc>
    9ec4:	56 c1       	rjmp	.+684    	; 0xa172 <Field2Buf+0x378>
    9ec6:	8b 31       	cpi	r24, 0x1B	; 27
    9ec8:	09 f4       	brne	.+2      	; 0x9ecc <Field2Buf+0xd2>
    9eca:	fe c1       	rjmp	.+1020   	; 0xa2c8 <Field2Buf+0x4ce>
    9ecc:	8c 31       	cpi	r24, 0x1C	; 28
    9ece:	08 f0       	brcs	.+2      	; 0x9ed2 <Field2Buf+0xd8>
    9ed0:	b7 c1       	rjmp	.+878    	; 0xa240 <Field2Buf+0x446>
    9ed2:	89 31       	cpi	r24, 0x19	; 25
    9ed4:	09 f4       	brne	.+2      	; 0x9ed8 <Field2Buf+0xde>
    9ed6:	92 c1       	rjmp	.+804    	; 0xa1fc <Field2Buf+0x402>
    9ed8:	8a 31       	cpi	r24, 0x1A	; 26
    9eda:	09 f0       	breq	.+2      	; 0x9ede <Field2Buf+0xe4>
    9edc:	5b c0       	rjmp	.+182    	; 0x9f94 <Field2Buf+0x19a>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    9ede:	7e 01       	movw	r14, r28
    9ee0:	08 94       	sec
    9ee2:	e1 1c       	adc	r14, r1
    9ee4:	f1 1c       	adc	r15, r1
    9ee6:	c7 01       	movw	r24, r14
    9ee8:	b6 01       	movw	r22, r12
    9eea:	44 e0       	ldi	r20, 0x04	; 4
    9eec:	50 e0       	ldi	r21, 0x00	; 0
    9eee:	0e 94 94 7d 	call	0xfb28	; 0xfb28 <__eerd_block_m2560>
		Put_FFVal(*(float*)Var, &Param);
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
		break;
	case EE_FFloat:
		erbl(&fTemp, Var, 4);
		Put_FFVal(fTemp, &Param);
    9ef2:	69 81       	ldd	r22, Y+1	; 0x01
    9ef4:	7a 81       	ldd	r23, Y+2	; 0x02
    9ef6:	8b 81       	ldd	r24, Y+3	; 0x03
    9ef8:	9c 81       	ldd	r25, Y+4	; 0x04
    9efa:	8e 01       	movw	r16, r28
    9efc:	0b 5f       	subi	r16, 0xFB	; 251
    9efe:	1f 4f       	sbci	r17, 0xFF	; 255
    9f00:	a8 01       	movw	r20, r16
    9f02:	0e 94 1a 43 	call	0x8634	; 0x8634 <Put_FFVal>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
    9f06:	81 ea       	ldi	r24, 0xA1	; 161
    9f08:	96 e0       	ldi	r25, 0x06	; 6
    9f0a:	60 91 bb 05 	lds	r22, 0x05BB
    9f0e:	0e 94 e3 3f 	call	0x7fc6	; 0x7fc6 <GetMultiSymbol>
    9f12:	80 93 ec 04 	sts	0x04EC, r24
	case GFloat:
		Put_GFVal(*(float*)Var, &Param);
    9f16:	f6 01       	movw	r30, r12
    9f18:	60 81       	ld	r22, Z
    9f1a:	71 81       	ldd	r23, Z+1	; 0x01
    9f1c:	82 81       	ldd	r24, Z+2	; 0x02
    9f1e:	93 81       	ldd	r25, Z+3	; 0x03
    9f20:	a8 01       	movw	r20, r16
    9f22:	0e 94 a0 42 	call	0x8540	; 0x8540 <Put_GFVal>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
    9f26:	81 ea       	ldi	r24, 0xA1	; 161
    9f28:	96 e0       	ldi	r25, 0x06	; 6
    9f2a:	60 91 bb 05 	lds	r22, 0x05BB
    9f2e:	0e 94 e3 3f 	call	0x7fc6	; 0x7fc6 <GetMultiSymbol>
    9f32:	80 93 ec 04 	sts	0x04EC, r24
    9f36:	c7 01       	movw	r24, r14
    9f38:	b6 01       	movw	r22, r12
    9f3a:	44 e0       	ldi	r20, 0x04	; 4
    9f3c:	50 e0       	ldi	r21, 0x00	; 0
    9f3e:	0e 94 94 7d 	call	0xfb28	; 0xfb28 <__eerd_block_m2560>
	case EE_GFloat:
		erbl(&fTemp, Var, 4);
		Put_GFVal(fTemp, &Param);
    9f42:	69 81       	ldd	r22, Y+1	; 0x01
    9f44:	7a 81       	ldd	r23, Y+2	; 0x02
    9f46:	8b 81       	ldd	r24, Y+3	; 0x03
    9f48:	9c 81       	ldd	r25, Y+4	; 0x04
    9f4a:	a8 01       	movw	r20, r16
    9f4c:	0e 94 a0 42 	call	0x8540	; 0x8540 <Put_GFVal>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
    9f50:	81 ea       	ldi	r24, 0xA1	; 161
    9f52:	96 e0       	ldi	r25, 0x06	; 6
    9f54:	60 91 bb 05 	lds	r22, 0x05BB
    9f58:	0e 94 e3 3f 	call	0x7fc6	; 0x7fc6 <GetMultiSymbol>
    9f5c:	80 93 ec 04 	sts	0x04EC, r24
    9f60:	19 c0       	rjmp	.+50     	; 0x9f94 <Field2Buf+0x19a>
	void *Var = prp(&Field->Var);
	uint8_t BitN=prb(&Field->Prec), Mask=1<<BitN%8, *BitVar=(uint8_t*)Var+BitN/8;
	uint8_t Pos=Log10(prd(&Field->Max));
	uint8_t Oldstyle = 0;

	switch(prb(&Field->Type)) {
    9f62:	ee 58       	subi	r30, 0x8E	; 142
    9f64:	ff 4f       	sbci	r31, 0xFF	; 255
    9f66:	ee 0f       	add	r30, r30
    9f68:	ff 1f       	adc	r31, r31
    9f6a:	05 90       	lpm	r0, Z+
    9f6c:	f4 91       	lpm	r31, Z+
    9f6e:	e0 2d       	mov	r30, r0
    9f70:	19 94       	eijmp
	case Byte: case z_Byte:
		F_Buf = *(uint8_t*)Var;
    9f72:	f6 01       	movw	r30, r12
    9f74:	80 81       	ld	r24, Z
    9f76:	90 e0       	ldi	r25, 0x00	; 0
    9f78:	a0 e0       	ldi	r26, 0x00	; 0
    9f7a:	b0 e0       	ldi	r27, 0x00	; 0
    9f7c:	80 93 ef 04 	sts	0x04EF, r24
    9f80:	90 93 f0 04 	sts	0x04F0, r25
    9f84:	a0 93 f1 04 	sts	0x04F1, r26
    9f88:	b0 93 f2 04 	sts	0x04F2, r27
		CurrPos = Pos;
    9f8c:	00 93 d4 02 	sts	0x02D4, r16
		F_Buf = (erb(BitVar) &Mask) > 0;
		Oldstyle = 1;
		break;
	}

	Minus=0;
    9f90:	10 92 f7 04 	sts	0x04F7, r1
				MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[0]);
			else MultiSymbol = GetMultiSymbol(Symbols_P, BufStr[0]);
		}
		break;
	}
}
    9f94:	6f 96       	adiw	r28, 0x1f	; 31
    9f96:	0f b6       	in	r0, 0x3f	; 63
    9f98:	f8 94       	cli
    9f9a:	de bf       	out	0x3e, r29	; 62
    9f9c:	0f be       	out	0x3f, r0	; 63
    9f9e:	cd bf       	out	0x3d, r28	; 61
    9fa0:	cf 91       	pop	r28
    9fa2:	df 91       	pop	r29
    9fa4:	1f 91       	pop	r17
    9fa6:	0f 91       	pop	r16
    9fa8:	ff 90       	pop	r15
    9faa:	ef 90       	pop	r14
    9fac:	df 90       	pop	r13
    9fae:	cf 90       	pop	r12
    9fb0:	bf 90       	pop	r11
    9fb2:	af 90       	pop	r10
    9fb4:	9f 90       	pop	r9
    9fb6:	8f 90       	pop	r8
    9fb8:	7f 90       	pop	r7
    9fba:	6f 90       	pop	r6
    9fbc:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    9fbe:	c6 01       	movw	r24, r12
    9fc0:	0e 94 a4 7d 	call	0xfb48	; 0xfb48 <__eerd_byte_m2560>
		sF_Buf = *(int8_t*)Var;
		CurrPos = Pos+1;
		Oldstyle = 1;
		break;
	case EE_Byte: case z_EE_Byte:
		F_Buf = erb((uint8_t*)Var);
    9fc4:	90 e0       	ldi	r25, 0x00	; 0
    9fc6:	a0 e0       	ldi	r26, 0x00	; 0
    9fc8:	b0 e0       	ldi	r27, 0x00	; 0
    9fca:	80 93 ef 04 	sts	0x04EF, r24
    9fce:	90 93 f0 04 	sts	0x04F0, r25
    9fd2:	a0 93 f1 04 	sts	0x04F1, r26
    9fd6:	b0 93 f2 04 	sts	0x04F2, r27
		CurrPos = Pos;
    9fda:	00 93 d4 02 	sts	0x02D4, r16
    9fde:	d8 cf       	rjmp	.-80     	; 0x9f90 <Field2Buf+0x196>
		F_Buf = *(uint8_t*)Var;
		CurrPos = Pos;
		Oldstyle = 1;
		break;
	case s_Byte:
		sF_Buf = *(int8_t*)Var;
    9fe0:	f6 01       	movw	r30, r12
    9fe2:	80 81       	ld	r24, Z
    9fe4:	99 27       	eor	r25, r25
    9fe6:	87 fd       	sbrc	r24, 7
    9fe8:	90 95       	com	r25
    9fea:	a9 2f       	mov	r26, r25
    9fec:	b9 2f       	mov	r27, r25
    9fee:	80 93 f3 04 	sts	0x04F3, r24
    9ff2:	90 93 f4 04 	sts	0x04F4, r25
    9ff6:	a0 93 f5 04 	sts	0x04F5, r26
    9ffa:	b0 93 f6 04 	sts	0x04F6, r27
		CurrPos = Pos+1;
    9ffe:	0f 5f       	subi	r16, 0xFF	; 255
    a000:	00 93 d4 02 	sts	0x02D4, r16
    a004:	c5 cf       	rjmp	.-118    	; 0x9f90 <Field2Buf+0x196>
    a006:	c6 01       	movw	r24, r12
    a008:	0e 94 a4 7d 	call	0xfb48	; 0xfb48 <__eerd_byte_m2560>
		F_Buf = erb((uint8_t*)Var);
		CurrPos = Pos;
		Oldstyle = 1;
		break;
	case s_EE_Byte:
		sF_Buf = (int8_t)erb((uint8_t*)Var);
    a00c:	99 27       	eor	r25, r25
    a00e:	87 fd       	sbrc	r24, 7
    a010:	90 95       	com	r25
    a012:	a9 2f       	mov	r26, r25
    a014:	b9 2f       	mov	r27, r25
    a016:	80 93 f3 04 	sts	0x04F3, r24
    a01a:	90 93 f4 04 	sts	0x04F4, r25
    a01e:	a0 93 f5 04 	sts	0x04F5, r26
    a022:	b0 93 f6 04 	sts	0x04F6, r27
		CurrPos = Pos+1;
    a026:	0f 5f       	subi	r16, 0xFF	; 255
    a028:	00 93 d4 02 	sts	0x02D4, r16
    a02c:	b1 cf       	rjmp	.-158    	; 0x9f90 <Field2Buf+0x196>
		Oldstyle = 1;
		break;

	case Word: case z_Word:
		F_Buf = *(uint16_t*)Var;
    a02e:	f6 01       	movw	r30, r12
    a030:	80 81       	ld	r24, Z
    a032:	91 81       	ldd	r25, Z+1	; 0x01
    a034:	a0 e0       	ldi	r26, 0x00	; 0
    a036:	b0 e0       	ldi	r27, 0x00	; 0
    a038:	80 93 ef 04 	sts	0x04EF, r24
    a03c:	90 93 f0 04 	sts	0x04F0, r25
    a040:	a0 93 f1 04 	sts	0x04F1, r26
    a044:	b0 93 f2 04 	sts	0x04F2, r27
		CurrPos = Pos;
    a048:	00 93 d4 02 	sts	0x02D4, r16
    a04c:	a1 cf       	rjmp	.-190    	; 0x9f90 <Field2Buf+0x196>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    a04e:	c6 01       	movw	r24, r12
    a050:	0e 94 b2 7d 	call	0xfb64	; 0xfb64 <__eerd_word_m2560>
		Oldstyle = 1;
		break;
	case EE_Word: case z_EE_Word:
		F_Buf = erw((uint16_t*)Var);
    a054:	a0 e0       	ldi	r26, 0x00	; 0
    a056:	b0 e0       	ldi	r27, 0x00	; 0
    a058:	80 93 ef 04 	sts	0x04EF, r24
    a05c:	90 93 f0 04 	sts	0x04F0, r25
    a060:	a0 93 f1 04 	sts	0x04F1, r26
    a064:	b0 93 f2 04 	sts	0x04F2, r27
		CurrPos = Pos;
    a068:	00 93 d4 02 	sts	0x02D4, r16
    a06c:	91 cf       	rjmp	.-222    	; 0x9f90 <Field2Buf+0x196>
		Oldstyle = 1;
		break;
	case s_Word:
		sF_Buf = *(int16_t*)Var;
    a06e:	f6 01       	movw	r30, r12
    a070:	80 81       	ld	r24, Z
    a072:	91 81       	ldd	r25, Z+1	; 0x01
    a074:	aa 27       	eor	r26, r26
    a076:	97 fd       	sbrc	r25, 7
    a078:	a0 95       	com	r26
    a07a:	ba 2f       	mov	r27, r26
    a07c:	80 93 f3 04 	sts	0x04F3, r24
    a080:	90 93 f4 04 	sts	0x04F4, r25
    a084:	a0 93 f5 04 	sts	0x04F5, r26
    a088:	b0 93 f6 04 	sts	0x04F6, r27
		CurrPos = Pos+1;
    a08c:	0f 5f       	subi	r16, 0xFF	; 255
    a08e:	00 93 d4 02 	sts	0x02D4, r16
    a092:	7e cf       	rjmp	.-260    	; 0x9f90 <Field2Buf+0x196>
    a094:	c6 01       	movw	r24, r12
    a096:	0e 94 b2 7d 	call	0xfb64	; 0xfb64 <__eerd_word_m2560>
		Oldstyle = 1;
		break;
	case s_EE_Word:
		sF_Buf = (int16_t)erw((uint16_t*)Var);
    a09a:	aa 27       	eor	r26, r26
    a09c:	97 fd       	sbrc	r25, 7
    a09e:	a0 95       	com	r26
    a0a0:	ba 2f       	mov	r27, r26
    a0a2:	80 93 f3 04 	sts	0x04F3, r24
    a0a6:	90 93 f4 04 	sts	0x04F4, r25
    a0aa:	a0 93 f5 04 	sts	0x04F5, r26
    a0ae:	b0 93 f6 04 	sts	0x04F6, r27
		CurrPos = Pos+1;
    a0b2:	0f 5f       	subi	r16, 0xFF	; 255
    a0b4:	00 93 d4 02 	sts	0x02D4, r16
    a0b8:	6b cf       	rjmp	.-298    	; 0x9f90 <Field2Buf+0x196>
		Oldstyle = 1;
		break;
	case c_Word: case zc_Word:
		F_Buf = *(uint16_t*)Var;
    a0ba:	f6 01       	movw	r30, r12
    a0bc:	80 81       	ld	r24, Z
    a0be:	91 81       	ldd	r25, Z+1	; 0x01
    a0c0:	a0 e0       	ldi	r26, 0x00	; 0
    a0c2:	b0 e0       	ldi	r27, 0x00	; 0
    a0c4:	80 93 ef 04 	sts	0x04EF, r24
    a0c8:	90 93 f0 04 	sts	0x04F0, r25
    a0cc:	a0 93 f1 04 	sts	0x04F1, r26
    a0d0:	b0 93 f2 04 	sts	0x04F2, r27
    a0d4:	5d cf       	rjmp	.-326    	; 0x9f90 <Field2Buf+0x196>
		Oldstyle = 1;
		break;

	case Enum:
		F_Buf = *(uint8_t*)Var;
    a0d6:	f6 01       	movw	r30, r12
    a0d8:	80 81       	ld	r24, Z
    a0da:	90 e0       	ldi	r25, 0x00	; 0
    a0dc:	a0 e0       	ldi	r26, 0x00	; 0
    a0de:	b0 e0       	ldi	r27, 0x00	; 0
    a0e0:	80 93 ef 04 	sts	0x04EF, r24
    a0e4:	90 93 f0 04 	sts	0x04F0, r25
    a0e8:	a0 93 f1 04 	sts	0x04F1, r26
    a0ec:	b0 93 f2 04 	sts	0x04F2, r27
    a0f0:	4f cf       	rjmp	.-354    	; 0x9f90 <Field2Buf+0x196>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    a0f2:	c6 01       	movw	r24, r12
    a0f4:	0e 94 a4 7d 	call	0xfb48	; 0xfb48 <__eerd_byte_m2560>
		Oldstyle = 1;
		break;
	case EE_Enum:
		F_Buf = erb((uint8_t*)Var);
    a0f8:	90 e0       	ldi	r25, 0x00	; 0
    a0fa:	a0 e0       	ldi	r26, 0x00	; 0
    a0fc:	b0 e0       	ldi	r27, 0x00	; 0
    a0fe:	80 93 ef 04 	sts	0x04EF, r24
    a102:	90 93 f0 04 	sts	0x04F0, r25
    a106:	a0 93 f1 04 	sts	0x04F1, r26
    a10a:	b0 93 f2 04 	sts	0x04F2, r27
    a10e:	40 cf       	rjmp	.-384    	; 0x9f90 <Field2Buf+0x196>
		Oldstyle = 1;
		break;
	case Bit:
		F_Buf = (*BitVar &Mask) > 0;
    a110:	20 e0       	ldi	r18, 0x00	; 0
    a112:	30 e0       	ldi	r19, 0x00	; 0
    a114:	40 e0       	ldi	r20, 0x00	; 0
    a116:	50 e0       	ldi	r21, 0x00	; 0
    a118:	f5 01       	movw	r30, r10
    a11a:	80 81       	ld	r24, Z
    a11c:	81 23       	and	r24, r17
    a11e:	21 f5       	brne	.+72     	; 0xa168 <Field2Buf+0x36e>
    a120:	20 93 ef 04 	sts	0x04EF, r18
    a124:	30 93 f0 04 	sts	0x04F0, r19
    a128:	40 93 f1 04 	sts	0x04F1, r20
    a12c:	50 93 f2 04 	sts	0x04F2, r21
    a130:	2f cf       	rjmp	.-418    	; 0x9f90 <Field2Buf+0x196>
    a132:	c5 01       	movw	r24, r10
    a134:	0e 94 a4 7d 	call	0xfb48	; 0xfb48 <__eerd_byte_m2560>
		Oldstyle = 1;
		break;
	case EE_Bit:
		F_Buf = (erb(BitVar) &Mask) > 0;
    a138:	10 92 ef 04 	sts	0x04EF, r1
    a13c:	10 92 f0 04 	sts	0x04F0, r1
    a140:	10 92 f1 04 	sts	0x04F1, r1
    a144:	10 92 f2 04 	sts	0x04F2, r1
    a148:	18 23       	and	r17, r24
    a14a:	09 f4       	brne	.+2      	; 0xa14e <Field2Buf+0x354>
    a14c:	21 cf       	rjmp	.-446    	; 0x9f90 <Field2Buf+0x196>
    a14e:	81 e0       	ldi	r24, 0x01	; 1
    a150:	90 e0       	ldi	r25, 0x00	; 0
    a152:	a0 e0       	ldi	r26, 0x00	; 0
    a154:	b0 e0       	ldi	r27, 0x00	; 0
    a156:	80 93 ef 04 	sts	0x04EF, r24
    a15a:	90 93 f0 04 	sts	0x04F0, r25
    a15e:	a0 93 f1 04 	sts	0x04F1, r26
    a162:	b0 93 f2 04 	sts	0x04F2, r27
    a166:	14 cf       	rjmp	.-472    	; 0x9f90 <Field2Buf+0x196>
	case EE_Enum:
		F_Buf = erb((uint8_t*)Var);
		Oldstyle = 1;
		break;
	case Bit:
		F_Buf = (*BitVar &Mask) > 0;
    a168:	21 e0       	ldi	r18, 0x01	; 1
    a16a:	30 e0       	ldi	r19, 0x00	; 0
    a16c:	40 e0       	ldi	r20, 0x00	; 0
    a16e:	50 e0       	ldi	r21, 0x00	; 0
    a170:	d7 cf       	rjmp	.-82     	; 0xa120 <Field2Buf+0x326>
	Param.Size = CurrFieldSize;
	Param.Pos = BufStr;
	Param.Prec = prb(&Field->Prec);
	Param.Txt = NULL;

	switch(prb(&Field->Type)) {
    a172:	82 31       	cpi	r24, 0x12	; 18
    a174:	51 f1       	breq	.+84     	; 0xa1ca <Field2Buf+0x3d0>
    a176:	83 31       	cpi	r24, 0x13	; 19
    a178:	08 f0       	brcs	.+2      	; 0xa17c <Field2Buf+0x382>
    a17a:	53 c0       	rjmp	.+166    	; 0xa222 <Field2Buf+0x428>
    a17c:	80 31       	cpi	r24, 0x10	; 16
    a17e:	c1 f1       	breq	.+112    	; 0xa1f0 <Field2Buf+0x3f6>
    a180:	81 31       	cpi	r24, 0x11	; 17
    a182:	09 f0       	breq	.+2      	; 0xa186 <Field2Buf+0x38c>
    a184:	07 cf       	rjmp	.-498    	; 0x9f94 <Field2Buf+0x19a>
// ~~~~~~~~~~~~~~~~~~~~~~
uint32_t
erd(const uint32_t *addr)
{
	//IntOff();
	uint32_t word = eeprom_read_dword(addr);
    a186:	c6 01       	movw	r24, r12
    a188:	0e 94 ac 7d 	call	0xfb58	; 0xfb58 <__eerd_dword_m2560>
	case z_Longint:
		Put_zDVal(*(uint32_t*)Var, &Param);
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
		break;
	case EE_Longint: 
		PutDVal(erd((uint32_t*)Var), &Param);
    a18c:	ae 01       	movw	r20, r28
    a18e:	4b 5f       	subi	r20, 0xFB	; 251
    a190:	5f 4f       	sbci	r21, 0xFF	; 255
    a192:	0e 94 b9 45 	call	0x8b72	; 0x8b72 <PutDVal>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
    a196:	81 ea       	ldi	r24, 0xA1	; 161
    a198:	96 e0       	ldi	r25, 0x06	; 6
    a19a:	60 91 bb 05 	lds	r22, 0x05BB
    a19e:	0e 94 e3 3f 	call	0x7fc6	; 0x7fc6 <GetMultiSymbol>
    a1a2:	80 93 ec 04 	sts	0x04EC, r24
    a1a6:	f6 ce       	rjmp	.-532    	; 0x9f94 <Field2Buf+0x19a>
    a1a8:	c6 01       	movw	r24, r12
    a1aa:	0e 94 ac 7d 	call	0xfb58	; 0xfb58 <__eerd_dword_m2560>
		break;
	case z_EE_Longint:
		Put_zDVal(erd((uint32_t*)Var), &Param);
    a1ae:	ae 01       	movw	r20, r28
    a1b0:	4b 5f       	subi	r20, 0xFB	; 251
    a1b2:	5f 4f       	sbci	r21, 0xFF	; 255
    a1b4:	0e 94 6f 43 	call	0x86de	; 0x86de <Put_zDVal>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
    a1b8:	81 ea       	ldi	r24, 0xA1	; 161
    a1ba:	96 e0       	ldi	r25, 0x06	; 6
    a1bc:	60 91 bb 05 	lds	r22, 0x05BB
    a1c0:	0e 94 e3 3f 	call	0x7fc6	; 0x7fc6 <GetMultiSymbol>
    a1c4:	80 93 ec 04 	sts	0x04EC, r24
    a1c8:	e5 ce       	rjmp	.-566    	; 0x9f94 <Field2Buf+0x19a>
		break;
	case s_Longint:
		Put_sDVal(*(int32_t*)Var, &Param);
    a1ca:	f6 01       	movw	r30, r12
    a1cc:	60 81       	ld	r22, Z
    a1ce:	71 81       	ldd	r23, Z+1	; 0x01
    a1d0:	82 81       	ldd	r24, Z+2	; 0x02
    a1d2:	93 81       	ldd	r25, Z+3	; 0x03
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
		break;
	case s_EE_Longint:
		Put_sDVal((int32_t)erd((uint32_t*)Var), &Param);
    a1d4:	ae 01       	movw	r20, r28
    a1d6:	4b 5f       	subi	r20, 0xFB	; 251
    a1d8:	5f 4f       	sbci	r21, 0xFF	; 255
    a1da:	0e 94 90 44 	call	0x8920	; 0x8920 <Put_sDVal>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
    a1de:	81 ea       	ldi	r24, 0xA1	; 161
    a1e0:	96 e0       	ldi	r25, 0x06	; 6
    a1e2:	60 91 bb 05 	lds	r22, 0x05BB
    a1e6:	0e 94 e3 3f 	call	0x7fc6	; 0x7fc6 <GetMultiSymbol>
    a1ea:	80 93 ec 04 	sts	0x04EC, r24
    a1ee:	d2 ce       	rjmp	.-604    	; 0x9f94 <Field2Buf+0x19a>
	Param.Prec = prb(&Field->Prec);
	Param.Txt = NULL;

	switch(prb(&Field->Type)) {
	case Longint:
		PutDVal(*(uint32_t*)Var, &Param);
    a1f0:	f6 01       	movw	r30, r12
    a1f2:	60 81       	ld	r22, Z
    a1f4:	71 81       	ldd	r23, Z+1	; 0x01
    a1f6:	82 81       	ldd	r24, Z+2	; 0x02
    a1f8:	93 81       	ldd	r25, Z+3	; 0x03
    a1fa:	c8 cf       	rjmp	.-112    	; 0xa18c <Field2Buf+0x392>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
		break;


	case FFloat:
		Put_FFVal(*(float*)Var, &Param);
    a1fc:	f6 01       	movw	r30, r12
    a1fe:	60 81       	ld	r22, Z
    a200:	71 81       	ldd	r23, Z+1	; 0x01
    a202:	82 81       	ldd	r24, Z+2	; 0x02
    a204:	93 81       	ldd	r25, Z+3	; 0x03
    a206:	ae 01       	movw	r20, r28
    a208:	4b 5f       	subi	r20, 0xFB	; 251
    a20a:	5f 4f       	sbci	r21, 0xFF	; 255
    a20c:	0e 94 1a 43 	call	0x8634	; 0x8634 <Put_FFVal>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
    a210:	81 ea       	ldi	r24, 0xA1	; 161
    a212:	96 e0       	ldi	r25, 0x06	; 6
    a214:	60 91 bb 05 	lds	r22, 0x05BB
    a218:	0e 94 e3 3f 	call	0x7fc6	; 0x7fc6 <GetMultiSymbol>
    a21c:	80 93 ec 04 	sts	0x04EC, r24
    a220:	b9 ce       	rjmp	.-654    	; 0x9f94 <Field2Buf+0x19a>
	Param.Size = CurrFieldSize;
	Param.Pos = BufStr;
	Param.Prec = prb(&Field->Prec);
	Param.Txt = NULL;

	switch(prb(&Field->Type)) {
    a222:	83 31       	cpi	r24, 0x13	; 19
    a224:	49 f0       	breq	.+18     	; 0xa238 <Field2Buf+0x43e>
    a226:	84 31       	cpi	r24, 0x14	; 20
    a228:	09 f0       	breq	.+2      	; 0xa22c <Field2Buf+0x432>
    a22a:	b4 ce       	rjmp	.-664    	; 0x9f94 <Field2Buf+0x19a>
	case Longint:
		PutDVal(*(uint32_t*)Var, &Param);
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
		break;
	case z_Longint:
		Put_zDVal(*(uint32_t*)Var, &Param);
    a22c:	f6 01       	movw	r30, r12
    a22e:	60 81       	ld	r22, Z
    a230:	71 81       	ldd	r23, Z+1	; 0x01
    a232:	82 81       	ldd	r24, Z+2	; 0x02
    a234:	93 81       	ldd	r25, Z+3	; 0x03
    a236:	bb cf       	rjmp	.-138    	; 0xa1ae <Field2Buf+0x3b4>
    a238:	c6 01       	movw	r24, r12
    a23a:	0e 94 ac 7d 	call	0xfb58	; 0xfb58 <__eerd_dword_m2560>
    a23e:	ca cf       	rjmp	.-108    	; 0xa1d4 <Field2Buf+0x3da>
	Param.Size = CurrFieldSize;
	Param.Pos = BufStr;
	Param.Prec = prb(&Field->Prec);
	Param.Txt = NULL;

	switch(prb(&Field->Type)) {
    a240:	81 32       	cpi	r24, 0x21	; 33
    a242:	69 f0       	breq	.+26     	; 0xa25e <Field2Buf+0x464>
    a244:	82 32       	cpi	r24, 0x22	; 34
    a246:	69 f1       	breq	.+90     	; 0xa2a2 <Field2Buf+0x4a8>
    a248:	8c 31       	cpi	r24, 0x1C	; 28
    a24a:	09 f0       	breq	.+2      	; 0xa24e <Field2Buf+0x454>
    a24c:	a3 ce       	rjmp	.-698    	; 0x9f94 <Field2Buf+0x19a>
    a24e:	8e 01       	movw	r16, r28
    a250:	0b 5f       	subi	r16, 0xFB	; 251
    a252:	1f 4f       	sbci	r17, 0xFF	; 255
    a254:	7e 01       	movw	r14, r28
    a256:	08 94       	sec
    a258:	e1 1c       	adc	r14, r1
    a25a:	f1 1c       	adc	r15, r1
    a25c:	6c ce       	rjmp	.-808    	; 0x9f36 <Field2Buf+0x13c>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
		break;


	case Text:
		Put_TextValAlignLeft((char*)Var, &Param);
    a25e:	c6 01       	movw	r24, r12
		
		break;
	case EE_Text:{
			char TempStr[LCDXSz+1];
			erbl(TempStr, Var, CurrFieldSize);
			Put_TextValAlignLeft(TempStr, &Param);
    a260:	be 01       	movw	r22, r28
    a262:	6b 5f       	subi	r22, 0xFB	; 251
    a264:	7f 4f       	sbci	r23, 0xFF	; 255
    a266:	0e 94 e8 41 	call	0x83d0	; 0x83d0 <Put_TextValAlignLeft>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    a26a:	f7 01       	movw	r30, r14
    a26c:	33 96       	adiw	r30, 0x03	; 3
    a26e:	85 91       	lpm	r24, Z+
    a270:	95 91       	lpm	r25, Z+
    a272:	a5 91       	lpm	r26, Z+
    a274:	b4 91       	lpm	r27, Z+
			if( (prd(&Field->Min) == DIGIT) && (prd(&Field->Max) == DIGIT) )
    a276:	00 97       	sbiw	r24, 0x00	; 0
    a278:	a1 05       	cpc	r26, r1
    a27a:	b1 05       	cpc	r27, r1
    a27c:	49 f4       	brne	.+18     	; 0xa290 <Field2Buf+0x496>
    a27e:	f3 01       	movw	r30, r6
    a280:	85 91       	lpm	r24, Z+
    a282:	95 91       	lpm	r25, Z+
    a284:	a5 91       	lpm	r26, Z+
    a286:	b4 91       	lpm	r27, Z+
    a288:	00 97       	sbiw	r24, 0x00	; 0
    a28a:	a1 05       	cpc	r26, r1
    a28c:	b1 05       	cpc	r27, r1
    a28e:	99 f0       	breq	.+38     	; 0xa2b6 <Field2Buf+0x4bc>
				MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[0]);
			else MultiSymbol = GetMultiSymbol(Symbols_P, BufStr[0]);
    a290:	88 ef       	ldi	r24, 0xF8	; 248
    a292:	95 e0       	ldi	r25, 0x05	; 5
    a294:	60 91 bb 05 	lds	r22, 0x05BB
    a298:	0e 94 e3 3f 	call	0x7fc6	; 0x7fc6 <GetMultiSymbol>
    a29c:	80 93 ec 04 	sts	0x04EC, r24
    a2a0:	79 ce       	rjmp	.-782    	; 0x9f94 <Field2Buf+0x19a>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    a2a2:	8e 01       	movw	r16, r28
    a2a4:	05 5f       	subi	r16, 0xF5	; 245
    a2a6:	1f 4f       	sbci	r17, 0xFF	; 255
    a2a8:	c8 01       	movw	r24, r16
    a2aa:	b6 01       	movw	r22, r12
    a2ac:	50 e0       	ldi	r21, 0x00	; 0
    a2ae:	0e 94 94 7d 	call	0xfb28	; 0xfb28 <__eerd_block_m2560>
		
		break;
	case EE_Text:{
			char TempStr[LCDXSz+1];
			erbl(TempStr, Var, CurrFieldSize);
			Put_TextValAlignLeft(TempStr, &Param);
    a2b2:	c8 01       	movw	r24, r16
    a2b4:	d5 cf       	rjmp	.-86     	; 0xa260 <Field2Buf+0x466>
			if( (prd(&Field->Min) == DIGIT) && (prd(&Field->Max) == DIGIT) )
				MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[0]);
    a2b6:	86 e9       	ldi	r24, 0x96	; 150
    a2b8:	96 e0       	ldi	r25, 0x06	; 6
    a2ba:	60 91 bb 05 	lds	r22, 0x05BB
    a2be:	0e 94 e3 3f 	call	0x7fc6	; 0x7fc6 <GetMultiSymbol>
    a2c2:	80 93 ec 04 	sts	0x04EC, r24
    a2c6:	66 ce       	rjmp	.-820    	; 0x9f94 <Field2Buf+0x19a>
    a2c8:	8e 01       	movw	r16, r28
    a2ca:	0b 5f       	subi	r16, 0xFB	; 251
    a2cc:	1f 4f       	sbci	r17, 0xFF	; 255
    a2ce:	7e 01       	movw	r14, r28
    a2d0:	08 94       	sec
    a2d2:	e1 1c       	adc	r14, r1
    a2d4:	f1 1c       	adc	r15, r1
    a2d6:	1f ce       	rjmp	.-962    	; 0x9f16 <Field2Buf+0x11c>

0000a2d8 <MenuEscLeft>:
}

// ~~~~~~~~~~~~~~
void
MenuEscLeft(void)
{
    a2d8:	0f 93       	push	r16
    a2da:	1f 93       	push	r17
    a2dc:	cf 93       	push	r28
    a2de:	df 93       	push	r29
//	1) Hide current Message
	if(HideMsg()||KeyFunc(&CurrPage->Esc))
    a2e0:	0e 94 dd 3b 	call	0x77ba	; 0x77ba <HideMsg>
    a2e4:	88 23       	and	r24, r24
    a2e6:	29 f0       	breq	.+10     	; 0xa2f2 <MenuEscLeft+0x1a>
		else
			CurrPage=prp(&CurrPage->OutPage);
		CurrLine=CurrLCD=GetFix();
	}
	EventFunc(&CurrPage->Load);
}
    a2e8:	df 91       	pop	r29
    a2ea:	cf 91       	pop	r28
    a2ec:	1f 91       	pop	r17
    a2ee:	0f 91       	pop	r16
    a2f0:	08 95       	ret
// ~~~~~~~~~~~~~~
void
MenuEscLeft(void)
{
//	1) Hide current Message
	if(HideMsg()||KeyFunc(&CurrPage->Esc))
    a2f2:	80 91 d1 02 	lds	r24, 0x02D1
    a2f6:	90 91 d2 02 	lds	r25, 0x02D2
    a2fa:	0e 96       	adiw	r24, 0x0e	; 14
    a2fc:	0e 94 83 3b 	call	0x7706	; 0x7706 <KeyFunc>
    a300:	88 23       	and	r24, r24
    a302:	91 f7       	brne	.-28     	; 0xa2e8 <MenuEscLeft+0x10>
		return;

// 2) Variable
	if(CurrField!=NullPos) {
    a304:	30 91 d3 02 	lds	r19, 0x02D3
    a308:	3f 3f       	cpi	r19, 0xFF	; 255
    a30a:	09 f4       	brne	.+2      	; 0xa30e <MenuEscLeft+0x36>
    a30c:	c8 c0       	rjmp	.+400    	; 0xa49e <MenuEscLeft+0x1c6>
		if(CurrPos!=NullPos) {
    a30e:	40 91 d4 02 	lds	r20, 0x02D4
    a312:	4f 3f       	cpi	r20, 0xFF	; 255
    a314:	09 f4       	brne	.+2      	; 0xa318 <MenuEscLeft+0x40>
    a316:	5a c0       	rjmp	.+180    	; 0xa3cc <MenuEscLeft+0xf4>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    a318:	80 91 d1 02 	lds	r24, 0x02D1
    a31c:	90 91 d2 02 	lds	r25, 0x02D2
    a320:	fc 01       	movw	r30, r24
    a322:	65 91       	lpm	r22, Z+
    a324:	74 91       	lpm	r23, Z+
			OutField *Field=GetField;
    a326:	80 91 7d 07 	lds	r24, 0x077D
    a32a:	2b e1       	ldi	r18, 0x1B	; 27
    a32c:	82 9f       	mul	r24, r18
    a32e:	c0 01       	movw	r24, r0
    a330:	11 24       	eor	r1, r1
    a332:	68 0f       	add	r22, r24
    a334:	79 1f       	adc	r23, r25
    a336:	69 5e       	subi	r22, 0xE9	; 233
    a338:	7f 4f       	sbci	r23, 0xFF	; 255
    a33a:	fb 01       	movw	r30, r22
    a33c:	c5 91       	lpm	r28, Z+
    a33e:	d4 91       	lpm	r29, Z+
    a340:	83 2f       	mov	r24, r19
    a342:	90 e0       	ldi	r25, 0x00	; 0
    a344:	82 95       	swap	r24
    a346:	92 95       	swap	r25
    a348:	90 7f       	andi	r25, 0xF0	; 240
    a34a:	98 27       	eor	r25, r24
    a34c:	80 7f       	andi	r24, 0xF0	; 240
    a34e:	98 27       	eor	r25, r24
    a350:	c8 0f       	add	r28, r24
    a352:	d9 1f       	adc	r29, r25

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    a354:	fe 01       	movw	r30, r28
    a356:	14 91       	lpm	r17, Z+
			uint8_t Type=prb(&Field->Type);
			uint8_t Pos;

			if( (Type == Text) || (Type == EE_Text) ||
    a358:	01 2f       	mov	r16, r17
    a35a:	01 52       	subi	r16, 0x21	; 33
    a35c:	02 30       	cpi	r16, 0x02	; 2
    a35e:	00 f1       	brcs	.+64     	; 0xa3a0 <MenuEscLeft+0xc8>
    a360:	10 31       	cpi	r17, 0x10	; 16
    a362:	f1 f0       	breq	.+60     	; 0xa3a0 <MenuEscLeft+0xc8>
    a364:	11 31       	cpi	r17, 0x11	; 17
    a366:	e1 f0       	breq	.+56     	; 0xa3a0 <MenuEscLeft+0xc8>
    a368:	12 31       	cpi	r17, 0x12	; 18
    a36a:	d1 f0       	breq	.+52     	; 0xa3a0 <MenuEscLeft+0xc8>
    a36c:	13 31       	cpi	r17, 0x13	; 19
    a36e:	c1 f0       	breq	.+48     	; 0xa3a0 <MenuEscLeft+0xc8>
    a370:	14 31       	cpi	r17, 0x14	; 20
    a372:	b1 f0       	breq	.+44     	; 0xa3a0 <MenuEscLeft+0xc8>
    a374:	15 31       	cpi	r17, 0x15	; 21
    a376:	a1 f0       	breq	.+40     	; 0xa3a0 <MenuEscLeft+0xc8>
    a378:	19 31       	cpi	r17, 0x19	; 25
    a37a:	91 f0       	breq	.+36     	; 0xa3a0 <MenuEscLeft+0xc8>
    a37c:	1a 31       	cpi	r17, 0x1A	; 26
    a37e:	81 f0       	breq	.+32     	; 0xa3a0 <MenuEscLeft+0xc8>
    a380:	1b 31       	cpi	r17, 0x1B	; 27
    a382:	71 f0       	breq	.+28     	; 0xa3a0 <MenuEscLeft+0xc8>
    a384:	1c 31       	cpi	r17, 0x1C	; 28
    a386:	61 f0       	breq	.+24     	; 0xa3a0 <MenuEscLeft+0xc8>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    a388:	fe 01       	movw	r30, r28
    a38a:	37 96       	adiw	r30, 0x07	; 7
    a38c:	65 91       	lpm	r22, Z+
    a38e:	75 91       	lpm	r23, Z+
    a390:	85 91       	lpm	r24, Z+
    a392:	94 91       	lpm	r25, Z+
			 (Type == Longint) || (Type == EE_Longint)|| (Type == s_Longint) || (Type == s_EE_Longint) || (Type == z_Longint) || (Type == z_EE_Longint) ||
			 (Type == FFloat) || (Type == EE_FFloat) || (Type == GFloat) || (Type == EE_GFloat) ) 
			 	Pos = CurrFieldSize-1;
			else Pos=Log10(prd(&Field->Max));
    a394:	0e 94 0b 20 	call	0x4016	; 0x4016 <Log10>
    a398:	98 2f       	mov	r25, r24
    a39a:	40 91 d4 02 	lds	r20, 0x02D4
    a39e:	03 c0       	rjmp	.+6      	; 0xa3a6 <MenuEscLeft+0xce>
			uint8_t Pos;

			if( (Type == Text) || (Type == EE_Text) ||
			 (Type == Longint) || (Type == EE_Longint)|| (Type == s_Longint) || (Type == s_EE_Longint) || (Type == z_Longint) || (Type == z_EE_Longint) ||
			 (Type == FFloat) || (Type == EE_FFloat) || (Type == GFloat) || (Type == EE_GFloat) ) 
			 	Pos = CurrFieldSize-1;
    a3a0:	90 91 74 07 	lds	r25, 0x0774
    a3a4:	91 50       	subi	r25, 0x01	; 1
			else Pos=Log10(prd(&Field->Max));

			if(Type==s_Byte || Type==s_EE_Byte || Type==s_Word || Type==s_EE_Word)
    a3a6:	81 2f       	mov	r24, r17
    a3a8:	82 50       	subi	r24, 0x02	; 2
    a3aa:	82 30       	cpi	r24, 0x02	; 2
    a3ac:	b0 f1       	brcs	.+108    	; 0xa41a <MenuEscLeft+0x142>
    a3ae:	19 30       	cpi	r17, 0x09	; 9
    a3b0:	a1 f1       	breq	.+104    	; 0xa41a <MenuEscLeft+0x142>
    a3b2:	1a 30       	cpi	r17, 0x0A	; 10
    a3b4:	91 f1       	breq	.+100    	; 0xa41a <MenuEscLeft+0x142>
				Pos++;
			if(++CurrPos>Pos)
    a3b6:	24 2f       	mov	r18, r20
    a3b8:	2f 5f       	subi	r18, 0xFF	; 255
    a3ba:	20 93 d4 02 	sts	0x02D4, r18
    a3be:	92 17       	cp	r25, r18
    a3c0:	70 f5       	brcc	.+92     	; 0xa41e <MenuEscLeft+0x146>
				CurrPos = NullPos;
    a3c2:	8f ef       	ldi	r24, 0xFF	; 255
    a3c4:	80 93 d4 02 	sts	0x02D4, r24
    a3c8:	30 91 d3 02 	lds	r19, 0x02D3
				}
				return;
			}
		}
		//     
		if(--CurrField!=NullPos)
    a3cc:	31 50       	subi	r19, 0x01	; 1
    a3ce:	30 93 d3 02 	sts	0x02D3, r19
    a3d2:	3f 3f       	cpi	r19, 0xFF	; 255
    a3d4:	09 f4       	brne	.+2      	; 0xa3d8 <MenuEscLeft+0x100>
    a3d6:	88 cf       	rjmp	.-240    	; 0xa2e8 <MenuEscLeft+0x10>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    a3d8:	80 91 d1 02 	lds	r24, 0x02D1
    a3dc:	90 91 d2 02 	lds	r25, 0x02D2
    a3e0:	fc 01       	movw	r30, r24
    a3e2:	45 91       	lpm	r20, Z+
    a3e4:	54 91       	lpm	r21, Z+
			Field2Buf(GetField);
    a3e6:	80 91 7d 07 	lds	r24, 0x077D
    a3ea:	2b e1       	ldi	r18, 0x1B	; 27
    a3ec:	82 9f       	mul	r24, r18
    a3ee:	c0 01       	movw	r24, r0
    a3f0:	11 24       	eor	r1, r1
    a3f2:	48 0f       	add	r20, r24
    a3f4:	59 1f       	adc	r21, r25
    a3f6:	49 5e       	subi	r20, 0xE9	; 233
    a3f8:	5f 4f       	sbci	r21, 0xFF	; 255
    a3fa:	fa 01       	movw	r30, r20
    a3fc:	85 91       	lpm	r24, Z+
    a3fe:	94 91       	lpm	r25, Z+
    a400:	23 2f       	mov	r18, r19
    a402:	30 e0       	ldi	r19, 0x00	; 0
    a404:	22 95       	swap	r18
    a406:	32 95       	swap	r19
    a408:	30 7f       	andi	r19, 0xF0	; 240
    a40a:	32 27       	eor	r19, r18
    a40c:	20 7f       	andi	r18, 0xF0	; 240
    a40e:	32 27       	eor	r19, r18
    a410:	82 0f       	add	r24, r18
    a412:	93 1f       	adc	r25, r19
    a414:	0e 94 fd 4e 	call	0x9dfa	; 0x9dfa <Field2Buf>
    a418:	67 cf       	rjmp	.-306    	; 0xa2e8 <MenuEscLeft+0x10>
			 (Type == FFloat) || (Type == EE_FFloat) || (Type == GFloat) || (Type == EE_GFloat) ) 
			 	Pos = CurrFieldSize-1;
			else Pos=Log10(prd(&Field->Max));

			if(Type==s_Byte || Type==s_EE_Byte || Type==s_Word || Type==s_EE_Word)
				Pos++;
    a41a:	9f 5f       	subi	r25, 0xFF	; 255
    a41c:	cc cf       	rjmp	.-104    	; 0xa3b6 <MenuEscLeft+0xde>
			if(++CurrPos>Pos)
				CurrPos = NullPos;
			else{
				switch(Type){
    a41e:	1d 31       	cpi	r17, 0x1D	; 29
    a420:	40 f1       	brcs	.+80     	; 0xa472 <MenuEscLeft+0x19a>
    a422:	02 30       	cpi	r16, 0x02	; 2
    a424:	08 f0       	brcs	.+2      	; 0xa428 <MenuEscLeft+0x150>
    a426:	60 cf       	rjmp	.-320    	; 0xa2e8 <MenuEscLeft+0x10>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    a428:	fe 01       	movw	r30, r28
    a42a:	33 96       	adiw	r30, 0x03	; 3
    a42c:	85 91       	lpm	r24, Z+
    a42e:	95 91       	lpm	r25, Z+
    a430:	a5 91       	lpm	r26, Z+
    a432:	b4 91       	lpm	r27, Z+
				case Text: case EE_Text:
					if( (prd(&Field->Min) == DIGIT) && (prd(&Field->Max) == DIGIT) )
    a434:	00 97       	sbiw	r24, 0x00	; 0
    a436:	a1 05       	cpc	r26, r1
    a438:	b1 05       	cpc	r27, r1
    a43a:	59 f4       	brne	.+22     	; 0xa452 <MenuEscLeft+0x17a>
    a43c:	fe 01       	movw	r30, r28
    a43e:	37 96       	adiw	r30, 0x07	; 7
    a440:	85 91       	lpm	r24, Z+
    a442:	95 91       	lpm	r25, Z+
    a444:	a5 91       	lpm	r26, Z+
    a446:	b4 91       	lpm	r27, Z+
    a448:	00 97       	sbiw	r24, 0x00	; 0
    a44a:	a1 05       	cpc	r26, r1
    a44c:	b1 05       	cpc	r27, r1
    a44e:	09 f4       	brne	.+2      	; 0xa452 <MenuEscLeft+0x17a>
    a450:	6f c0       	rjmp	.+222    	; 0xa530 <MenuEscLeft+0x258>
						MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[CurrFieldSize - 1 - CurrPos]);
					else MultiSymbol = GetMultiSymbol(Symbols_P, BufStr[CurrFieldSize - 1 - CurrPos]);
    a452:	e0 91 74 07 	lds	r30, 0x0774
    a456:	f0 e0       	ldi	r31, 0x00	; 0
    a458:	31 97       	sbiw	r30, 0x01	; 1
    a45a:	e2 1b       	sub	r30, r18
    a45c:	f1 09       	sbc	r31, r1
    a45e:	e5 54       	subi	r30, 0x45	; 69
    a460:	fa 4f       	sbci	r31, 0xFA	; 250
    a462:	88 ef       	ldi	r24, 0xF8	; 248
    a464:	95 e0       	ldi	r25, 0x05	; 5
    a466:	60 81       	ld	r22, Z
    a468:	0e 94 e3 3f 	call	0x7fc6	; 0x7fc6 <GetMultiSymbol>
    a46c:	80 93 ec 04 	sts	0x04EC, r24
    a470:	3b cf       	rjmp	.-394    	; 0xa2e8 <MenuEscLeft+0x10>
			if(Type==s_Byte || Type==s_EE_Byte || Type==s_Word || Type==s_EE_Word)
				Pos++;
			if(++CurrPos>Pos)
				CurrPos = NullPos;
			else{
				switch(Type){
    a472:	19 31       	cpi	r17, 0x19	; 25
    a474:	20 f4       	brcc	.+8      	; 0xa47e <MenuEscLeft+0x1a6>
    a476:	10 51       	subi	r17, 0x10	; 16
    a478:	16 30       	cpi	r17, 0x06	; 6
    a47a:	08 f0       	brcs	.+2      	; 0xa47e <MenuEscLeft+0x1a6>
    a47c:	35 cf       	rjmp	.-406    	; 0xa2e8 <MenuEscLeft+0x10>
						MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[CurrFieldSize - 1 - CurrPos]);
					else MultiSymbol = GetMultiSymbol(Symbols_P, BufStr[CurrFieldSize - 1 - CurrPos]);
					break;
				case Longint: case z_Longint: case EE_Longint: case z_EE_Longint: case s_Longint: case s_EE_Longint:
				case FFloat: case EE_FFloat: case GFloat: case EE_GFloat:
					MultiSymbol = GetMultiSymbol(Digits_P, BufStr[CurrFieldSize - 1 - CurrPos]);
    a47e:	e0 91 74 07 	lds	r30, 0x0774
    a482:	f0 e0       	ldi	r31, 0x00	; 0
    a484:	31 97       	sbiw	r30, 0x01	; 1
    a486:	e2 1b       	sub	r30, r18
    a488:	f1 09       	sbc	r31, r1
    a48a:	e5 54       	subi	r30, 0x45	; 69
    a48c:	fa 4f       	sbci	r31, 0xFA	; 250
    a48e:	81 ea       	ldi	r24, 0xA1	; 161
    a490:	96 e0       	ldi	r25, 0x06	; 6
    a492:	60 81       	ld	r22, Z
    a494:	0e 94 e3 3f 	call	0x7fc6	; 0x7fc6 <GetMultiSymbol>
    a498:	80 93 ec 04 	sts	0x04EC, r24
    a49c:	25 cf       	rjmp	.-438    	; 0xa2e8 <MenuEscLeft+0x10>
			Field2Buf(GetField);
		return;
	}

// 3) Go to menu
	EventFunc(&CurrPage->Exit);
    a49e:	80 91 d1 02 	lds	r24, 0x02D1
    a4a2:	90 91 d2 02 	lds	r25, 0x02D2
    a4a6:	0a 96       	adiw	r24, 0x0a	; 10
    a4a8:	0e 94 7b 3b 	call	0x76f6	; 0x76f6 <EventFunc>
	if(MenuDepth) {
    a4ac:	e0 91 6e 07 	lds	r30, 0x076E
    a4b0:	ee 23       	and	r30, r30
    a4b2:	21 f1       	breq	.+72     	; 0xa4fc <MenuEscLeft+0x224>
		CurrPage=MenuStack[--MenuDepth].Page;
    a4b4:	e1 50       	subi	r30, 0x01	; 1
    a4b6:	e0 93 6e 07 	sts	0x076E, r30
    a4ba:	f0 e0       	ldi	r31, 0x00	; 0
    a4bc:	ee 0f       	add	r30, r30
    a4be:	ff 1f       	adc	r31, r31
    a4c0:	ee 0f       	add	r30, r30
    a4c2:	ff 1f       	adc	r31, r31
    a4c4:	df 01       	movw	r26, r30
    a4c6:	a5 56       	subi	r26, 0x65	; 101
    a4c8:	b7 4f       	sbci	r27, 0xF7	; 247
    a4ca:	9c 91       	ld	r25, X
    a4cc:	11 96       	adiw	r26, 0x01	; 1
    a4ce:	2c 91       	ld	r18, X
    a4d0:	11 97       	sbiw	r26, 0x01	; 1
    a4d2:	90 93 d1 02 	sts	0x02D1, r25
    a4d6:	20 93 d2 02 	sts	0x02D2, r18
		CurrLine=MenuStack[MenuDepth].Line;
    a4da:	13 96       	adiw	r26, 0x03	; 3
    a4dc:	8c 91       	ld	r24, X
    a4de:	80 93 7d 07 	sts	0x077D, r24
		CurrLCD=MenuStack[MenuDepth].LCD;
    a4e2:	e3 56       	subi	r30, 0x63	; 99
    a4e4:	f7 4f       	sbci	r31, 0xF7	; 247
    a4e6:	80 81       	ld	r24, Z
    a4e8:	80 93 9a 08 	sts	0x089A, r24
    a4ec:	e9 2f       	mov	r30, r25
    a4ee:	f2 2f       	mov	r31, r18
    a4f0:	9f 01       	movw	r18, r30
		}
		else
			CurrPage=prp(&CurrPage->OutPage);
		CurrLine=CurrLCD=GetFix();
	}
	EventFunc(&CurrPage->Load);
    a4f2:	c9 01       	movw	r24, r18
    a4f4:	06 96       	adiw	r24, 0x06	; 6
    a4f6:	0e 94 7b 3b 	call	0x76f6	; 0x76f6 <EventFunc>
    a4fa:	f6 ce       	rjmp	.-532    	; 0xa2e8 <MenuEscLeft+0x10>
		CurrPage=MenuStack[--MenuDepth].Page;
		CurrLine=MenuStack[MenuDepth].Line;
		CurrLCD=MenuStack[MenuDepth].LCD;
	}
	else {
		if(NextPage) {
    a4fc:	e0 91 d1 05 	lds	r30, 0x05D1
    a500:	f0 91 d2 05 	lds	r31, 0x05D2
    a504:	30 97       	sbiw	r30, 0x00	; 0
    a506:	21 f1       	breq	.+72     	; 0xa550 <MenuEscLeft+0x278>
			CurrPage=NextPage;
    a508:	f0 93 d2 02 	sts	0x02D2, r31
    a50c:	e0 93 d1 02 	sts	0x02D1, r30
			NextPage=NULL;
    a510:	10 92 d2 05 	sts	0x05D2, r1
    a514:	10 92 d1 05 	sts	0x05D1, r1
    a518:	9f 01       	movw	r18, r30

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    a51a:	2d 5f       	subi	r18, 0xFD	; 253
    a51c:	3f 4f       	sbci	r19, 0xFF	; 255
    a51e:	f9 01       	movw	r30, r18
    a520:	84 91       	lpm	r24, Z+
    a522:	23 50       	subi	r18, 0x03	; 3
    a524:	30 40       	sbci	r19, 0x00	; 0
		}
		else
			CurrPage=prp(&CurrPage->OutPage);
		CurrLine=CurrLCD=GetFix();
    a526:	80 93 9a 08 	sts	0x089A, r24
    a52a:	80 93 7d 07 	sts	0x077D, r24
    a52e:	e1 cf       	rjmp	.-62     	; 0xa4f2 <MenuEscLeft+0x21a>
				CurrPos = NullPos;
			else{
				switch(Type){
				case Text: case EE_Text:
					if( (prd(&Field->Min) == DIGIT) && (prd(&Field->Max) == DIGIT) )
						MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[CurrFieldSize - 1 - CurrPos]);
    a530:	e0 91 74 07 	lds	r30, 0x0774
    a534:	f0 e0       	ldi	r31, 0x00	; 0
    a536:	31 97       	sbiw	r30, 0x01	; 1
    a538:	e2 1b       	sub	r30, r18
    a53a:	f1 09       	sbc	r31, r1
    a53c:	e5 54       	subi	r30, 0x45	; 69
    a53e:	fa 4f       	sbci	r31, 0xFA	; 250
    a540:	86 e9       	ldi	r24, 0x96	; 150
    a542:	96 e0       	ldi	r25, 0x06	; 6
    a544:	60 81       	ld	r22, Z
    a546:	0e 94 e3 3f 	call	0x7fc6	; 0x7fc6 <GetMultiSymbol>
    a54a:	80 93 ec 04 	sts	0x04EC, r24
    a54e:	cc ce       	rjmp	.-616    	; 0xa2e8 <MenuEscLeft+0x10>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    a550:	80 91 d1 02 	lds	r24, 0x02D1
    a554:	90 91 d2 02 	lds	r25, 0x02D2
    a558:	04 96       	adiw	r24, 0x04	; 4
		if(NextPage) {
			CurrPage=NextPage;
			NextPage=NULL;
		}
		else
			CurrPage=prp(&CurrPage->OutPage);
    a55a:	fc 01       	movw	r30, r24
    a55c:	25 91       	lpm	r18, Z+
    a55e:	34 91       	lpm	r19, Z+
    a560:	30 93 d2 02 	sts	0x02D2, r19
    a564:	20 93 d1 02 	sts	0x02D1, r18
    a568:	d8 cf       	rjmp	.-80     	; 0xa51a <MenuEscLeft+0x242>

0000a56a <Buf2Field>:
// ~~~~~~~~~~~~~~~~~~~~~~~
//       
//     -
static void
Buf2Field(OutField *Field)
{
    a56a:	3f 92       	push	r3
    a56c:	4f 92       	push	r4
    a56e:	5f 92       	push	r5
    a570:	6f 92       	push	r6
    a572:	7f 92       	push	r7
    a574:	8f 92       	push	r8
    a576:	9f 92       	push	r9
    a578:	af 92       	push	r10
    a57a:	bf 92       	push	r11
    a57c:	cf 92       	push	r12
    a57e:	df 92       	push	r13
    a580:	ef 92       	push	r14
    a582:	ff 92       	push	r15
    a584:	0f 93       	push	r16
    a586:	1f 93       	push	r17
    a588:	df 93       	push	r29
    a58a:	cf 93       	push	r28
    a58c:	cd b7       	in	r28, 0x3d	; 61
    a58e:	de b7       	in	r29, 0x3e	; 62
    a590:	6d 97       	sbiw	r28, 0x1d	; 29
    a592:	0f b6       	in	r0, 0x3f	; 63
    a594:	f8 94       	cli
    a596:	de bf       	out	0x3e, r29	; 62
    a598:	0f be       	out	0x3f, r0	; 63
    a59a:	cd bf       	out	0x3d, r28	; 61
    a59c:	6c 01       	movw	r12, r24
    a59e:	fc 01       	movw	r30, r24
    a5a0:	31 96       	adiw	r30, 0x01	; 1
    a5a2:	45 90       	lpm	r4, Z+
    a5a4:	54 90       	lpm	r5, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    a5a6:	2f e0       	ldi	r18, 0x0F	; 15
    a5a8:	30 e0       	ldi	r19, 0x00	; 0
    a5aa:	c2 0e       	add	r12, r18
    a5ac:	d3 1e       	adc	r13, r19
    a5ae:	f6 01       	movw	r30, r12
    a5b0:	24 91       	lpm	r18, Z+
    a5b2:	81 ef       	ldi	r24, 0xF1	; 241
    a5b4:	9f ef       	ldi	r25, 0xFF	; 255
    a5b6:	c8 0e       	add	r12, r24
    a5b8:	d9 1e       	adc	r13, r25
	void *Var = prp(&Field->Var);
	uint8_t BitN=prb(&Field->Prec), Mask=1<<BitN%8, *BitVar=(uint8_t*)Var+BitN/8;
    a5ba:	32 2f       	mov	r19, r18
    a5bc:	37 70       	andi	r19, 0x07	; 7
    a5be:	81 e0       	ldi	r24, 0x01	; 1
    a5c0:	90 e0       	ldi	r25, 0x00	; 0
    a5c2:	38 2e       	mov	r3, r24
    a5c4:	01 c0       	rjmp	.+2      	; 0xa5c8 <Buf2Field+0x5e>
    a5c6:	33 0c       	add	r3, r3
    a5c8:	3a 95       	dec	r19
    a5ca:	ea f7       	brpl	.-6      	; 0xa5c6 <Buf2Field+0x5c>
    a5cc:	26 95       	lsr	r18
    a5ce:	26 95       	lsr	r18
    a5d0:	26 95       	lsr	r18
    a5d2:	32 01       	movw	r6, r4
    a5d4:	62 0e       	add	r6, r18
    a5d6:	71 1c       	adc	r7, r1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    a5d8:	f6 01       	movw	r30, r12
    a5da:	33 96       	adiw	r30, 0x03	; 3
    a5dc:	85 90       	lpm	r8, Z+
    a5de:	95 90       	lpm	r9, Z+
    a5e0:	a5 90       	lpm	r10, Z+
    a5e2:	b4 90       	lpm	r11, Z+
	uint8_t EE_BitVar;
	uint32_t Min=prd(&Field->Min), Max=prd(&Field->Max);

	uint32_t Temp=0;
    a5e4:	f6 01       	movw	r30, r12
    a5e6:	37 96       	adiw	r30, 0x07	; 7
    a5e8:	e5 90       	lpm	r14, Z+
    a5ea:	f5 90       	lpm	r15, Z+
    a5ec:	05 91       	lpm	r16, Z+
    a5ee:	14 91       	lpm	r17, Z+
    a5f0:	19 82       	std	Y+1, r1	; 0x01
    a5f2:	1a 82       	std	Y+2, r1	; 0x02
    a5f4:	1b 82       	std	Y+3, r1	; 0x03
    a5f6:	1c 82       	std	Y+4, r1	; 0x04
	float fTemp=0;
    a5f8:	80 e0       	ldi	r24, 0x00	; 0
    a5fa:	90 e0       	ldi	r25, 0x00	; 0
    a5fc:	a0 e0       	ldi	r26, 0x00	; 0
    a5fe:	b0 e0       	ldi	r27, 0x00	; 0
    a600:	8d 83       	std	Y+5, r24	; 0x05
    a602:	9e 83       	std	Y+6, r25	; 0x06
    a604:	af 83       	std	Y+7, r26	; 0x07
    a606:	b8 87       	std	Y+8, r27	; 0x08

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    a608:	f6 01       	movw	r30, r12
    a60a:	84 91       	lpm	r24, Z+

	switch(prb(&Field->Type)) {
    a60c:	e8 2f       	mov	r30, r24
    a60e:	f0 e0       	ldi	r31, 0x00	; 0
    a610:	e3 32       	cpi	r30, 0x23	; 35
    a612:	f1 05       	cpc	r31, r1
    a614:	08 f0       	brcs	.+2      	; 0xa618 <Buf2Field+0xae>
    a616:	3f c0       	rjmp	.+126    	; 0xa696 <Buf2Field+0x12c>
    a618:	ed 56       	subi	r30, 0x6D	; 109
    a61a:	ff 4f       	sbci	r31, 0xFF	; 255
    a61c:	ee 0f       	add	r30, r30
    a61e:	ff 1f       	adc	r31, r31
    a620:	05 90       	lpm	r0, Z+
    a622:	f4 91       	lpm	r31, Z+
    a624:	e0 2d       	mov	r30, r0
    a626:	19 94       	eijmp
		PresicionHanler(Field);
		sscanf(BufStr,"%lud", (uint32_t*)&Temp);
		SetField32(Temp, uint32_t);
		break;
	case EE_Longint: case z_EE_Longint:
		PresicionHanler(Field);
    a628:	c6 01       	movw	r24, r12
    a62a:	0e 94 a9 3f 	call	0x7f52	; 0x7f52 <PresicionHanler>
		if(sscanf(BufStr,"%lud", (uint32_t*)&Temp) == 1){
    a62e:	00 d0       	rcall	.+0      	; 0xa630 <Buf2Field+0xc6>
    a630:	00 d0       	rcall	.+0      	; 0xa632 <Buf2Field+0xc8>
    a632:	ed b7       	in	r30, 0x3d	; 61
    a634:	fe b7       	in	r31, 0x3e	; 62
    a636:	31 96       	adiw	r30, 0x01	; 1
    a638:	8b eb       	ldi	r24, 0xBB	; 187
    a63a:	95 e0       	ldi	r25, 0x05	; 5
    a63c:	ad b7       	in	r26, 0x3d	; 61
    a63e:	be b7       	in	r27, 0x3e	; 62
    a640:	12 96       	adiw	r26, 0x02	; 2
    a642:	9c 93       	st	X, r25
    a644:	8e 93       	st	-X, r24
    a646:	11 97       	sbiw	r26, 0x01	; 1
    a648:	8f e9       	ldi	r24, 0x9F	; 159
    a64a:	92 e0       	ldi	r25, 0x02	; 2
    a64c:	93 83       	std	Z+3, r25	; 0x03
    a64e:	82 83       	std	Z+2, r24	; 0x02
    a650:	ce 01       	movw	r24, r28
    a652:	01 96       	adiw	r24, 0x01	; 1
    a654:	95 83       	std	Z+5, r25	; 0x05
    a656:	84 83       	std	Z+4, r24	; 0x04
    a658:	0e 94 d8 7b 	call	0xf7b0	; 0xf7b0 <sscanf>
    a65c:	ed b7       	in	r30, 0x3d	; 61
    a65e:	fe b7       	in	r31, 0x3e	; 62
    a660:	36 96       	adiw	r30, 0x06	; 6
    a662:	0f b6       	in	r0, 0x3f	; 63
    a664:	f8 94       	cli
    a666:	fe bf       	out	0x3e, r31	; 62
    a668:	0f be       	out	0x3f, r0	; 63
    a66a:	ed bf       	out	0x3d, r30	; 61
    a66c:	01 97       	sbiw	r24, 0x01	; 1
    a66e:	99 f4       	brne	.+38     	; 0xa696 <Buf2Field+0x12c>
			SetEEField32(Temp, uint32_t, uint32_t, d);
    a670:	49 81       	ldd	r20, Y+1	; 0x01
    a672:	5a 81       	ldd	r21, Y+2	; 0x02
    a674:	6b 81       	ldd	r22, Y+3	; 0x03
    a676:	7c 81       	ldd	r23, Y+4	; 0x04
    a678:	e4 16       	cp	r14, r20
    a67a:	f5 06       	cpc	r15, r21
    a67c:	06 07       	cpc	r16, r22
    a67e:	17 07       	cpc	r17, r23
    a680:	08 f4       	brcc	.+2      	; 0xa684 <Buf2Field+0x11a>
    a682:	cc c2       	rjmp	.+1432   	; 0xac1c <Buf2Field+0x6b2>
    a684:	48 15       	cp	r20, r8
    a686:	59 05       	cpc	r21, r9
    a688:	6a 05       	cpc	r22, r10
    a68a:	7b 05       	cpc	r23, r11
    a68c:	08 f4       	brcc	.+2      	; 0xa690 <Buf2Field+0x126>
    a68e:	f8 c1       	rjmp	.+1008   	; 0xaa80 <Buf2Field+0x516>
		SetField32(Temp, int32_t);
		break;
	case s_EE_Longint:
		PresicionHanler(Field);
		if(sscanf(BufStr,"%ld", (int32_t*)&Temp) == 1){
			SetEEField32(Temp, int32_t, uint32_t, d);
    a690:	c2 01       	movw	r24, r4
    a692:	0e 94 77 4c 	call	0x98ee	; 0x98ee <ewd>
			ewbl(TempStr, Var, Width);
		}
		break;

	}
	EventFunc(&Field->Act);
    a696:	c6 01       	movw	r24, r12
    a698:	0b 96       	adiw	r24, 0x0b	; 11
    a69a:	0e 94 7b 3b 	call	0x76f6	; 0x76f6 <EventFunc>
}
    a69e:	6d 96       	adiw	r28, 0x1d	; 29
    a6a0:	0f b6       	in	r0, 0x3f	; 63
    a6a2:	f8 94       	cli
    a6a4:	de bf       	out	0x3e, r29	; 62
    a6a6:	0f be       	out	0x3f, r0	; 63
    a6a8:	cd bf       	out	0x3d, r28	; 61
    a6aa:	cf 91       	pop	r28
    a6ac:	df 91       	pop	r29
    a6ae:	1f 91       	pop	r17
    a6b0:	0f 91       	pop	r16
    a6b2:	ff 90       	pop	r15
    a6b4:	ef 90       	pop	r14
    a6b6:	df 90       	pop	r13
    a6b8:	cf 90       	pop	r12
    a6ba:	bf 90       	pop	r11
    a6bc:	af 90       	pop	r10
    a6be:	9f 90       	pop	r9
    a6c0:	8f 90       	pop	r8
    a6c2:	7f 90       	pop	r7
    a6c4:	6f 90       	pop	r6
    a6c6:	5f 90       	pop	r5
    a6c8:	4f 90       	pop	r4
    a6ca:	3f 90       	pop	r3
    a6cc:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    a6ce:	8e 01       	movw	r16, r28
    a6d0:	07 5f       	subi	r16, 0xF7	; 247
    a6d2:	1f 4f       	sbci	r17, 0xFF	; 255
    a6d4:	c8 01       	movw	r24, r16
    a6d6:	b2 01       	movw	r22, r4
    a6d8:	45 e1       	ldi	r20, 0x15	; 21
    a6da:	50 e0       	ldi	r21, 0x00	; 0
    a6dc:	0e 94 94 7d 	call	0xfb28	; 0xfb28 <__eerd_block_m2560>
		}
		break;
	case EE_Text:{
			char TempStr[LCDXSz+1];
			erbl(TempStr, Var, LCDXSz+1);
			uint8_t Width = strlen(TempStr);
    a6e0:	d8 01       	movw	r26, r16
    a6e2:	0d 90       	ld	r0, X+
    a6e4:	00 20       	and	r0, r0
    a6e6:	e9 f7       	brne	.-6      	; 0xa6e2 <Buf2Field+0x178>
    a6e8:	7d 01       	movw	r14, r26
    a6ea:	08 94       	sec
    a6ec:	e1 08       	sbc	r14, r1
    a6ee:	f1 08       	sbc	r15, r1
    a6f0:	e0 1a       	sub	r14, r16
    a6f2:	f1 0a       	sbc	r15, r17
			memcpy(TempStr, BufStr, Width);
    a6f4:	2b eb       	ldi	r18, 0xBB	; 187
    a6f6:	35 e0       	ldi	r19, 0x05	; 5
    a6f8:	c8 01       	movw	r24, r16
    a6fa:	b9 01       	movw	r22, r18
    a6fc:	4e 2d       	mov	r20, r14
    a6fe:	50 e0       	ldi	r21, 0x00	; 0
    a700:	0e 94 c6 7a 	call	0xf58c	; 0xf58c <memcpy>
			ewbl(TempStr, Var, Width);
    a704:	c8 01       	movw	r24, r16
    a706:	b2 01       	movw	r22, r4
    a708:	4e 2d       	mov	r20, r14
    a70a:	50 e0       	ldi	r21, 0x00	; 0
    a70c:	0e 94 72 4c 	call	0x98e4	; 0x98e4 <ewbl>
    a710:	c2 cf       	rjmp	.-124    	; 0xa696 <Buf2Field+0x12c>
	uint32_t Temp=0;
	float fTemp=0;

	switch(prb(&Field->Type)) {
	case Byte: case z_Byte: case Enum:
		SetField(F_Buf, uint8_t);
    a712:	20 91 ef 04 	lds	r18, 0x04EF
    a716:	30 91 f0 04 	lds	r19, 0x04F0
    a71a:	40 91 f1 04 	lds	r20, 0x04F1
    a71e:	50 91 f2 04 	lds	r21, 0x04F2
    a722:	8e 2d       	mov	r24, r14
    a724:	90 e0       	ldi	r25, 0x00	; 0
    a726:	a0 e0       	ldi	r26, 0x00	; 0
    a728:	b0 e0       	ldi	r27, 0x00	; 0
    a72a:	82 17       	cp	r24, r18
    a72c:	93 07       	cpc	r25, r19
    a72e:	a4 07       	cpc	r26, r20
    a730:	b5 07       	cpc	r27, r21
    a732:	08 f4       	brcc	.+2      	; 0xa736 <Buf2Field+0x1cc>
    a734:	50 c2       	rjmp	.+1184   	; 0xabd6 <Buf2Field+0x66c>
    a736:	88 2d       	mov	r24, r8
    a738:	90 e0       	ldi	r25, 0x00	; 0
    a73a:	a0 e0       	ldi	r26, 0x00	; 0
    a73c:	b0 e0       	ldi	r27, 0x00	; 0
    a73e:	28 17       	cp	r18, r24
    a740:	39 07       	cpc	r19, r25
    a742:	4a 07       	cpc	r20, r26
    a744:	5b 07       	cpc	r21, r27
    a746:	08 f0       	brcs	.+2      	; 0xa74a <Buf2Field+0x1e0>
    a748:	66 c2       	rjmp	.+1228   	; 0xac16 <Buf2Field+0x6ac>
    a74a:	f2 01       	movw	r30, r4
    a74c:	80 82       	st	Z, r8
    a74e:	a3 cf       	rjmp	.-186    	; 0xa696 <Buf2Field+0x12c>
		break;
	case s_Byte:
		SetField(sF_Buf, int8_t);
		break;
	case EE_Byte: case z_EE_Byte: case EE_Enum:
		SetEEField(F_Buf, uint8_t, uint8_t, b);
    a750:	20 91 ef 04 	lds	r18, 0x04EF
    a754:	30 91 f0 04 	lds	r19, 0x04F0
    a758:	40 91 f1 04 	lds	r20, 0x04F1
    a75c:	50 91 f2 04 	lds	r21, 0x04F2
    a760:	8e 2d       	mov	r24, r14
    a762:	90 e0       	ldi	r25, 0x00	; 0
    a764:	a0 e0       	ldi	r26, 0x00	; 0
    a766:	b0 e0       	ldi	r27, 0x00	; 0
    a768:	82 17       	cp	r24, r18
    a76a:	93 07       	cpc	r25, r19
    a76c:	a4 07       	cpc	r26, r20
    a76e:	b5 07       	cpc	r27, r21
    a770:	08 f4       	brcc	.+2      	; 0xa774 <Buf2Field+0x20a>
    a772:	41 c2       	rjmp	.+1154   	; 0xabf6 <Buf2Field+0x68c>
    a774:	88 2d       	mov	r24, r8
    a776:	90 e0       	ldi	r25, 0x00	; 0
    a778:	a0 e0       	ldi	r26, 0x00	; 0
    a77a:	b0 e0       	ldi	r27, 0x00	; 0
    a77c:	28 17       	cp	r18, r24
    a77e:	39 07       	cpc	r19, r25
    a780:	4a 07       	cpc	r20, r26
    a782:	5b 07       	cpc	r21, r27
    a784:	08 f4       	brcc	.+2      	; 0xa788 <Buf2Field+0x21e>
    a786:	48 c0       	rjmp	.+144    	; 0xa818 <Buf2Field+0x2ae>
		break;
	case s_EE_Byte:
		SetEEField(sF_Buf, int8_t, uint8_t, b);
    a788:	c2 01       	movw	r24, r4
    a78a:	62 2f       	mov	r22, r18
    a78c:	0e 94 fd 4a 	call	0x95fa	; 0x95fa <ewb>
    a790:	82 cf       	rjmp	.-252    	; 0xa696 <Buf2Field+0x12c>
	switch(prb(&Field->Type)) {
	case Byte: case z_Byte: case Enum:
		SetField(F_Buf, uint8_t);
		break;
	case s_Byte:
		SetField(sF_Buf, int8_t);
    a792:	20 91 f3 04 	lds	r18, 0x04F3
    a796:	30 91 f4 04 	lds	r19, 0x04F4
    a79a:	40 91 f5 04 	lds	r20, 0x04F5
    a79e:	50 91 f6 04 	lds	r21, 0x04F6
    a7a2:	8e 2d       	mov	r24, r14
    a7a4:	99 27       	eor	r25, r25
    a7a6:	87 fd       	sbrc	r24, 7
    a7a8:	90 95       	com	r25
    a7aa:	a9 2f       	mov	r26, r25
    a7ac:	b9 2f       	mov	r27, r25
    a7ae:	82 17       	cp	r24, r18
    a7b0:	93 07       	cpc	r25, r19
    a7b2:	a4 07       	cpc	r26, r20
    a7b4:	b5 07       	cpc	r27, r21
    a7b6:	0c f4       	brge	.+2      	; 0xa7ba <Buf2Field+0x250>
    a7b8:	08 c2       	rjmp	.+1040   	; 0xabca <Buf2Field+0x660>
    a7ba:	88 2d       	mov	r24, r8
    a7bc:	99 27       	eor	r25, r25
    a7be:	87 fd       	sbrc	r24, 7
    a7c0:	90 95       	com	r25
    a7c2:	a9 2f       	mov	r26, r25
    a7c4:	b9 2f       	mov	r27, r25
    a7c6:	28 17       	cp	r18, r24
    a7c8:	39 07       	cpc	r19, r25
    a7ca:	4a 07       	cpc	r20, r26
    a7cc:	5b 07       	cpc	r21, r27
    a7ce:	0c f0       	brlt	.+2      	; 0xa7d2 <Buf2Field+0x268>
    a7d0:	17 c2       	rjmp	.+1070   	; 0xac00 <Buf2Field+0x696>
    a7d2:	d2 01       	movw	r26, r4
    a7d4:	8c 92       	st	X, r8
    a7d6:	5f cf       	rjmp	.-322    	; 0xa696 <Buf2Field+0x12c>
		break;
	case EE_Byte: case z_EE_Byte: case EE_Enum:
		SetEEField(F_Buf, uint8_t, uint8_t, b);
		break;
	case s_EE_Byte:
		SetEEField(sF_Buf, int8_t, uint8_t, b);
    a7d8:	20 91 f3 04 	lds	r18, 0x04F3
    a7dc:	30 91 f4 04 	lds	r19, 0x04F4
    a7e0:	40 91 f5 04 	lds	r20, 0x04F5
    a7e4:	50 91 f6 04 	lds	r21, 0x04F6
    a7e8:	8e 2d       	mov	r24, r14
    a7ea:	99 27       	eor	r25, r25
    a7ec:	87 fd       	sbrc	r24, 7
    a7ee:	90 95       	com	r25
    a7f0:	a9 2f       	mov	r26, r25
    a7f2:	b9 2f       	mov	r27, r25
    a7f4:	82 17       	cp	r24, r18
    a7f6:	93 07       	cpc	r25, r19
    a7f8:	a4 07       	cpc	r26, r20
    a7fa:	b5 07       	cpc	r27, r21
    a7fc:	0c f4       	brge	.+2      	; 0xa800 <Buf2Field+0x296>
    a7fe:	fb c1       	rjmp	.+1014   	; 0xabf6 <Buf2Field+0x68c>
    a800:	88 2d       	mov	r24, r8
    a802:	99 27       	eor	r25, r25
    a804:	87 fd       	sbrc	r24, 7
    a806:	90 95       	com	r25
    a808:	a9 2f       	mov	r26, r25
    a80a:	b9 2f       	mov	r27, r25
    a80c:	28 17       	cp	r18, r24
    a80e:	39 07       	cpc	r19, r25
    a810:	4a 07       	cpc	r20, r26
    a812:	5b 07       	cpc	r21, r27
    a814:	0c f0       	brlt	.+2      	; 0xa818 <Buf2Field+0x2ae>
    a816:	b8 cf       	rjmp	.-144    	; 0xa788 <Buf2Field+0x21e>
    a818:	c2 01       	movw	r24, r4
    a81a:	68 2d       	mov	r22, r8
    a81c:	0e 94 fd 4a 	call	0x95fa	; 0x95fa <ewb>
    a820:	3a cf       	rjmp	.-396    	; 0xa696 <Buf2Field+0x12c>
		break;
	case Word: case z_Word:
		SetField(F_Buf, uint16_t);
    a822:	20 91 ef 04 	lds	r18, 0x04EF
    a826:	30 91 f0 04 	lds	r19, 0x04F0
    a82a:	40 91 f1 04 	lds	r20, 0x04F1
    a82e:	50 91 f2 04 	lds	r21, 0x04F2
    a832:	c7 01       	movw	r24, r14
    a834:	a0 e0       	ldi	r26, 0x00	; 0
    a836:	b0 e0       	ldi	r27, 0x00	; 0
    a838:	82 17       	cp	r24, r18
    a83a:	93 07       	cpc	r25, r19
    a83c:	a4 07       	cpc	r26, r20
    a83e:	b5 07       	cpc	r27, r21
    a840:	08 f4       	brcc	.+2      	; 0xa844 <Buf2Field+0x2da>
    a842:	cc c1       	rjmp	.+920    	; 0xabdc <Buf2Field+0x672>
    a844:	c4 01       	movw	r24, r8
    a846:	a0 e0       	ldi	r26, 0x00	; 0
    a848:	b0 e0       	ldi	r27, 0x00	; 0
    a84a:	28 17       	cp	r18, r24
    a84c:	39 07       	cpc	r19, r25
    a84e:	4a 07       	cpc	r20, r26
    a850:	5b 07       	cpc	r21, r27
    a852:	08 f0       	brcs	.+2      	; 0xa856 <Buf2Field+0x2ec>
    a854:	d8 c1       	rjmp	.+944    	; 0xac06 <Buf2Field+0x69c>
    a856:	f2 01       	movw	r30, r4
    a858:	91 82       	std	Z+1, r9	; 0x01
    a85a:	80 82       	st	Z, r8
    a85c:	1c cf       	rjmp	.-456    	; 0xa696 <Buf2Field+0x12c>
		break;
	case EE_Word: case z_EE_Word:
		SetEEField(F_Buf, uint16_t, uint16_t, w);
    a85e:	20 91 ef 04 	lds	r18, 0x04EF
    a862:	30 91 f0 04 	lds	r19, 0x04F0
    a866:	40 91 f1 04 	lds	r20, 0x04F1
    a86a:	50 91 f2 04 	lds	r21, 0x04F2
    a86e:	c7 01       	movw	r24, r14
    a870:	a0 e0       	ldi	r26, 0x00	; 0
    a872:	b0 e0       	ldi	r27, 0x00	; 0
    a874:	82 17       	cp	r24, r18
    a876:	93 07       	cpc	r25, r19
    a878:	a4 07       	cpc	r26, r20
    a87a:	b5 07       	cpc	r27, r21
    a87c:	08 f4       	brcc	.+2      	; 0xa880 <Buf2Field+0x316>
    a87e:	b6 c1       	rjmp	.+876    	; 0xabec <Buf2Field+0x682>
    a880:	c4 01       	movw	r24, r8
    a882:	a0 e0       	ldi	r26, 0x00	; 0
    a884:	b0 e0       	ldi	r27, 0x00	; 0
    a886:	28 17       	cp	r18, r24
    a888:	39 07       	cpc	r19, r25
    a88a:	4a 07       	cpc	r20, r26
    a88c:	5b 07       	cpc	r21, r27
    a88e:	08 f4       	brcc	.+2      	; 0xa892 <Buf2Field+0x328>
    a890:	45 c0       	rjmp	.+138    	; 0xa91c <Buf2Field+0x3b2>
		break;
	case s_Word:
		SetField(sF_Buf, int16_t);
		break;
	case s_EE_Word:
		SetEEField(sF_Buf, int16_t, uint16_t, w);
    a892:	c2 01       	movw	r24, r4
    a894:	b9 01       	movw	r22, r18
    a896:	0e 94 40 4b 	call	0x9680	; 0x9680 <eww>
    a89a:	fd ce       	rjmp	.-518    	; 0xa696 <Buf2Field+0x12c>
		break;
	case EE_Word: case z_EE_Word:
		SetEEField(F_Buf, uint16_t, uint16_t, w);
		break;
	case s_Word:
		SetField(sF_Buf, int16_t);
    a89c:	20 91 f3 04 	lds	r18, 0x04F3
    a8a0:	30 91 f4 04 	lds	r19, 0x04F4
    a8a4:	40 91 f5 04 	lds	r20, 0x04F5
    a8a8:	50 91 f6 04 	lds	r21, 0x04F6
    a8ac:	c7 01       	movw	r24, r14
    a8ae:	aa 27       	eor	r26, r26
    a8b0:	97 fd       	sbrc	r25, 7
    a8b2:	a0 95       	com	r26
    a8b4:	ba 2f       	mov	r27, r26
    a8b6:	82 17       	cp	r24, r18
    a8b8:	93 07       	cpc	r25, r19
    a8ba:	a4 07       	cpc	r26, r20
    a8bc:	b5 07       	cpc	r27, r21
    a8be:	0c f4       	brge	.+2      	; 0xa8c2 <Buf2Field+0x358>
    a8c0:	91 c1       	rjmp	.+802    	; 0xabe4 <Buf2Field+0x67a>
    a8c2:	c4 01       	movw	r24, r8
    a8c4:	aa 27       	eor	r26, r26
    a8c6:	97 fd       	sbrc	r25, 7
    a8c8:	a0 95       	com	r26
    a8ca:	ba 2f       	mov	r27, r26
    a8cc:	28 17       	cp	r18, r24
    a8ce:	39 07       	cpc	r19, r25
    a8d0:	4a 07       	cpc	r20, r26
    a8d2:	5b 07       	cpc	r21, r27
    a8d4:	0c f0       	brlt	.+2      	; 0xa8d8 <Buf2Field+0x36e>
    a8d6:	9b c1       	rjmp	.+822    	; 0xac0e <Buf2Field+0x6a4>
    a8d8:	d2 01       	movw	r26, r4
    a8da:	8d 92       	st	X+, r8
    a8dc:	9c 92       	st	X, r9
    a8de:	db ce       	rjmp	.-586    	; 0xa696 <Buf2Field+0x12c>
		break;
	case s_EE_Word:
		SetEEField(sF_Buf, int16_t, uint16_t, w);
    a8e0:	20 91 f3 04 	lds	r18, 0x04F3
    a8e4:	30 91 f4 04 	lds	r19, 0x04F4
    a8e8:	40 91 f5 04 	lds	r20, 0x04F5
    a8ec:	50 91 f6 04 	lds	r21, 0x04F6
    a8f0:	c7 01       	movw	r24, r14
    a8f2:	aa 27       	eor	r26, r26
    a8f4:	97 fd       	sbrc	r25, 7
    a8f6:	a0 95       	com	r26
    a8f8:	ba 2f       	mov	r27, r26
    a8fa:	82 17       	cp	r24, r18
    a8fc:	93 07       	cpc	r25, r19
    a8fe:	a4 07       	cpc	r26, r20
    a900:	b5 07       	cpc	r27, r21
    a902:	0c f4       	brge	.+2      	; 0xa906 <Buf2Field+0x39c>
    a904:	73 c1       	rjmp	.+742    	; 0xabec <Buf2Field+0x682>
    a906:	c4 01       	movw	r24, r8
    a908:	aa 27       	eor	r26, r26
    a90a:	97 fd       	sbrc	r25, 7
    a90c:	a0 95       	com	r26
    a90e:	ba 2f       	mov	r27, r26
    a910:	28 17       	cp	r18, r24
    a912:	39 07       	cpc	r19, r25
    a914:	4a 07       	cpc	r20, r26
    a916:	5b 07       	cpc	r21, r27
    a918:	0c f0       	brlt	.+2      	; 0xa91c <Buf2Field+0x3b2>
    a91a:	bb cf       	rjmp	.-138    	; 0xa892 <Buf2Field+0x328>
    a91c:	c2 01       	movw	r24, r4
    a91e:	b4 01       	movw	r22, r8
    a920:	0e 94 40 4b 	call	0x9680	; 0x9680 <eww>
    a924:	b8 ce       	rjmp	.-656    	; 0xa696 <Buf2Field+0x12c>
		break;
	case c_Word: case zc_Word:
		*(uint16_t*)Var = F_Buf;
    a926:	80 91 ef 04 	lds	r24, 0x04EF
    a92a:	90 91 f0 04 	lds	r25, 0x04F0
    a92e:	d2 01       	movw	r26, r4
    a930:	8d 93       	st	X+, r24
    a932:	9c 93       	st	X, r25
    a934:	b0 ce       	rjmp	.-672    	; 0xa696 <Buf2Field+0x12c>
		break;


	case Longint: case z_Longint:
		//if(Limit_uByteVar(Temp)) sscanf(BufStr,"%ud", (unsigned short int*)&Temp);
		PresicionHanler(Field);
    a936:	c6 01       	movw	r24, r12
    a938:	0e 94 a9 3f 	call	0x7f52	; 0x7f52 <PresicionHanler>
		sscanf(BufStr,"%lud", (uint32_t*)&Temp);
    a93c:	00 d0       	rcall	.+0      	; 0xa93e <Buf2Field+0x3d4>
    a93e:	00 d0       	rcall	.+0      	; 0xa940 <Buf2Field+0x3d6>
    a940:	ed b7       	in	r30, 0x3d	; 61
    a942:	fe b7       	in	r31, 0x3e	; 62
    a944:	31 96       	adiw	r30, 0x01	; 1
    a946:	8b eb       	ldi	r24, 0xBB	; 187
    a948:	95 e0       	ldi	r25, 0x05	; 5
    a94a:	ad b7       	in	r26, 0x3d	; 61
    a94c:	be b7       	in	r27, 0x3e	; 62
    a94e:	12 96       	adiw	r26, 0x02	; 2
    a950:	9c 93       	st	X, r25
    a952:	8e 93       	st	-X, r24
    a954:	11 97       	sbiw	r26, 0x01	; 1
    a956:	8f e9       	ldi	r24, 0x9F	; 159
    a958:	92 e0       	ldi	r25, 0x02	; 2
    a95a:	93 83       	std	Z+3, r25	; 0x03
    a95c:	82 83       	std	Z+2, r24	; 0x02
    a95e:	ce 01       	movw	r24, r28
    a960:	01 96       	adiw	r24, 0x01	; 1
    a962:	95 83       	std	Z+5, r25	; 0x05
    a964:	84 83       	std	Z+4, r24	; 0x04
    a966:	0e 94 d8 7b 	call	0xf7b0	; 0xf7b0 <sscanf>
		SetField32(Temp, uint32_t);
    a96a:	89 81       	ldd	r24, Y+1	; 0x01
    a96c:	9a 81       	ldd	r25, Y+2	; 0x02
    a96e:	ab 81       	ldd	r26, Y+3	; 0x03
    a970:	bc 81       	ldd	r27, Y+4	; 0x04
    a972:	ed b7       	in	r30, 0x3d	; 61
    a974:	fe b7       	in	r31, 0x3e	; 62
    a976:	36 96       	adiw	r30, 0x06	; 6
    a978:	0f b6       	in	r0, 0x3f	; 63
    a97a:	f8 94       	cli
    a97c:	fe bf       	out	0x3e, r31	; 62
    a97e:	0f be       	out	0x3f, r0	; 63
    a980:	ed bf       	out	0x3d, r30	; 61
    a982:	e8 16       	cp	r14, r24
    a984:	f9 06       	cpc	r15, r25
    a986:	0a 07       	cpc	r16, r26
    a988:	1b 07       	cpc	r17, r27
    a98a:	08 f4       	brcc	.+2      	; 0xa98e <Buf2Field+0x424>
    a98c:	17 c1       	rjmp	.+558    	; 0xabbc <Buf2Field+0x652>
    a98e:	88 15       	cp	r24, r8
    a990:	99 05       	cpc	r25, r9
    a992:	aa 05       	cpc	r26, r10
    a994:	bb 05       	cpc	r27, r11
    a996:	b8 f1       	brcs	.+110    	; 0xaa06 <Buf2Field+0x49c>
		break;
	case s_Longint:
		PresicionHanler(Field);
		//if(Limit_sByteVar(Temp)) sscanf(BufStr,"%hd", (short int*)&Temp);
		sscanf(BufStr,"%ld", (int32_t*)&Temp);
		SetField32(Temp, int32_t);
    a998:	f2 01       	movw	r30, r4
    a99a:	80 83       	st	Z, r24
    a99c:	91 83       	std	Z+1, r25	; 0x01
    a99e:	a2 83       	std	Z+2, r26	; 0x02
    a9a0:	b3 83       	std	Z+3, r27	; 0x03
    a9a2:	79 ce       	rjmp	.-782    	; 0xa696 <Buf2Field+0x12c>
		if(sscanf(BufStr,"%lud", (uint32_t*)&Temp) == 1){
			SetEEField32(Temp, uint32_t, uint32_t, d);
		}		
		break;
	case s_Longint:
		PresicionHanler(Field);
    a9a4:	c6 01       	movw	r24, r12
    a9a6:	0e 94 a9 3f 	call	0x7f52	; 0x7f52 <PresicionHanler>
		//if(Limit_sByteVar(Temp)) sscanf(BufStr,"%hd", (short int*)&Temp);
		sscanf(BufStr,"%ld", (int32_t*)&Temp);
    a9aa:	00 d0       	rcall	.+0      	; 0xa9ac <Buf2Field+0x442>
    a9ac:	00 d0       	rcall	.+0      	; 0xa9ae <Buf2Field+0x444>
    a9ae:	ed b7       	in	r30, 0x3d	; 61
    a9b0:	fe b7       	in	r31, 0x3e	; 62
    a9b2:	31 96       	adiw	r30, 0x01	; 1
    a9b4:	8b eb       	ldi	r24, 0xBB	; 187
    a9b6:	95 e0       	ldi	r25, 0x05	; 5
    a9b8:	ad b7       	in	r26, 0x3d	; 61
    a9ba:	be b7       	in	r27, 0x3e	; 62
    a9bc:	12 96       	adiw	r26, 0x02	; 2
    a9be:	9c 93       	st	X, r25
    a9c0:	8e 93       	st	-X, r24
    a9c2:	11 97       	sbiw	r26, 0x01	; 1
    a9c4:	84 ea       	ldi	r24, 0xA4	; 164
    a9c6:	92 e0       	ldi	r25, 0x02	; 2
    a9c8:	93 83       	std	Z+3, r25	; 0x03
    a9ca:	82 83       	std	Z+2, r24	; 0x02
    a9cc:	ce 01       	movw	r24, r28
    a9ce:	01 96       	adiw	r24, 0x01	; 1
    a9d0:	95 83       	std	Z+5, r25	; 0x05
    a9d2:	84 83       	std	Z+4, r24	; 0x04
    a9d4:	0e 94 d8 7b 	call	0xf7b0	; 0xf7b0 <sscanf>
		SetField32(Temp, int32_t);
    a9d8:	89 81       	ldd	r24, Y+1	; 0x01
    a9da:	9a 81       	ldd	r25, Y+2	; 0x02
    a9dc:	ab 81       	ldd	r26, Y+3	; 0x03
    a9de:	bc 81       	ldd	r27, Y+4	; 0x04
    a9e0:	ed b7       	in	r30, 0x3d	; 61
    a9e2:	fe b7       	in	r31, 0x3e	; 62
    a9e4:	36 96       	adiw	r30, 0x06	; 6
    a9e6:	0f b6       	in	r0, 0x3f	; 63
    a9e8:	f8 94       	cli
    a9ea:	fe bf       	out	0x3e, r31	; 62
    a9ec:	0f be       	out	0x3f, r0	; 63
    a9ee:	ed bf       	out	0x3d, r30	; 61
    a9f0:	e8 16       	cp	r14, r24
    a9f2:	f9 06       	cpc	r15, r25
    a9f4:	0a 07       	cpc	r16, r26
    a9f6:	1b 07       	cpc	r17, r27
    a9f8:	0c f4       	brge	.+2      	; 0xa9fc <Buf2Field+0x492>
    a9fa:	e0 c0       	rjmp	.+448    	; 0xabbc <Buf2Field+0x652>
    a9fc:	88 15       	cp	r24, r8
    a9fe:	99 05       	cpc	r25, r9
    aa00:	aa 05       	cpc	r26, r10
    aa02:	bb 05       	cpc	r27, r11
    aa04:	4c f6       	brge	.-110    	; 0xa998 <Buf2Field+0x42e>
    aa06:	f2 01       	movw	r30, r4
    aa08:	80 82       	st	Z, r8
    aa0a:	91 82       	std	Z+1, r9	; 0x01
    aa0c:	a2 82       	std	Z+2, r10	; 0x02
    aa0e:	b3 82       	std	Z+3, r11	; 0x03
    aa10:	42 ce       	rjmp	.-892    	; 0xa696 <Buf2Field+0x12c>
		break;
	case s_EE_Longint:
		PresicionHanler(Field);
    aa12:	c6 01       	movw	r24, r12
    aa14:	0e 94 a9 3f 	call	0x7f52	; 0x7f52 <PresicionHanler>
		if(sscanf(BufStr,"%ld", (int32_t*)&Temp) == 1){
    aa18:	00 d0       	rcall	.+0      	; 0xaa1a <Buf2Field+0x4b0>
    aa1a:	00 d0       	rcall	.+0      	; 0xaa1c <Buf2Field+0x4b2>
    aa1c:	ed b7       	in	r30, 0x3d	; 61
    aa1e:	fe b7       	in	r31, 0x3e	; 62
    aa20:	31 96       	adiw	r30, 0x01	; 1
    aa22:	8b eb       	ldi	r24, 0xBB	; 187
    aa24:	95 e0       	ldi	r25, 0x05	; 5
    aa26:	ad b7       	in	r26, 0x3d	; 61
    aa28:	be b7       	in	r27, 0x3e	; 62
    aa2a:	12 96       	adiw	r26, 0x02	; 2
    aa2c:	9c 93       	st	X, r25
    aa2e:	8e 93       	st	-X, r24
    aa30:	11 97       	sbiw	r26, 0x01	; 1
    aa32:	84 ea       	ldi	r24, 0xA4	; 164
    aa34:	92 e0       	ldi	r25, 0x02	; 2
    aa36:	93 83       	std	Z+3, r25	; 0x03
    aa38:	82 83       	std	Z+2, r24	; 0x02
    aa3a:	ce 01       	movw	r24, r28
    aa3c:	01 96       	adiw	r24, 0x01	; 1
    aa3e:	95 83       	std	Z+5, r25	; 0x05
    aa40:	84 83       	std	Z+4, r24	; 0x04
    aa42:	0e 94 d8 7b 	call	0xf7b0	; 0xf7b0 <sscanf>
    aa46:	ed b7       	in	r30, 0x3d	; 61
    aa48:	fe b7       	in	r31, 0x3e	; 62
    aa4a:	36 96       	adiw	r30, 0x06	; 6
    aa4c:	0f b6       	in	r0, 0x3f	; 63
    aa4e:	f8 94       	cli
    aa50:	fe bf       	out	0x3e, r31	; 62
    aa52:	0f be       	out	0x3f, r0	; 63
    aa54:	ed bf       	out	0x3d, r30	; 61
    aa56:	01 97       	sbiw	r24, 0x01	; 1
    aa58:	09 f0       	breq	.+2      	; 0xaa5c <Buf2Field+0x4f2>
    aa5a:	1d ce       	rjmp	.-966    	; 0xa696 <Buf2Field+0x12c>
			SetEEField32(Temp, int32_t, uint32_t, d);
    aa5c:	49 81       	ldd	r20, Y+1	; 0x01
    aa5e:	5a 81       	ldd	r21, Y+2	; 0x02
    aa60:	6b 81       	ldd	r22, Y+3	; 0x03
    aa62:	7c 81       	ldd	r23, Y+4	; 0x04
    aa64:	ca 01       	movw	r24, r20
    aa66:	db 01       	movw	r26, r22
    aa68:	e8 16       	cp	r14, r24
    aa6a:	f9 06       	cpc	r15, r25
    aa6c:	0a 07       	cpc	r16, r26
    aa6e:	1b 07       	cpc	r17, r27
    aa70:	0c f4       	brge	.+2      	; 0xaa74 <Buf2Field+0x50a>
    aa72:	d4 c0       	rjmp	.+424    	; 0xac1c <Buf2Field+0x6b2>
    aa74:	88 15       	cp	r24, r8
    aa76:	99 05       	cpc	r25, r9
    aa78:	aa 05       	cpc	r26, r10
    aa7a:	bb 05       	cpc	r27, r11
    aa7c:	0c f0       	brlt	.+2      	; 0xaa80 <Buf2Field+0x516>
    aa7e:	08 ce       	rjmp	.-1008   	; 0xa690 <Buf2Field+0x126>
    aa80:	c2 01       	movw	r24, r4
    aa82:	b5 01       	movw	r22, r10
    aa84:	a4 01       	movw	r20, r8
    aa86:	0e 94 77 4c 	call	0x98ee	; 0x98ee <ewd>
    aa8a:	05 ce       	rjmp	.-1014   	; 0xa696 <Buf2Field+0x12c>
		}
		break;


	case FFloat: case GFloat:
		sscanf(BufStr,"%f", &fTemp);
    aa8c:	00 d0       	rcall	.+0      	; 0xaa8e <Buf2Field+0x524>
    aa8e:	00 d0       	rcall	.+0      	; 0xaa90 <Buf2Field+0x526>
    aa90:	ed b7       	in	r30, 0x3d	; 61
    aa92:	fe b7       	in	r31, 0x3e	; 62
    aa94:	31 96       	adiw	r30, 0x01	; 1
    aa96:	8b eb       	ldi	r24, 0xBB	; 187
    aa98:	95 e0       	ldi	r25, 0x05	; 5
    aa9a:	ad b7       	in	r26, 0x3d	; 61
    aa9c:	be b7       	in	r27, 0x3e	; 62
    aa9e:	12 96       	adiw	r26, 0x02	; 2
    aaa0:	9c 93       	st	X, r25
    aaa2:	8e 93       	st	-X, r24
    aaa4:	11 97       	sbiw	r26, 0x01	; 1
    aaa6:	88 ea       	ldi	r24, 0xA8	; 168
    aaa8:	92 e0       	ldi	r25, 0x02	; 2
    aaaa:	93 83       	std	Z+3, r25	; 0x03
    aaac:	82 83       	std	Z+2, r24	; 0x02
    aaae:	ce 01       	movw	r24, r28
    aab0:	05 96       	adiw	r24, 0x05	; 5
    aab2:	95 83       	std	Z+5, r25	; 0x05
    aab4:	84 83       	std	Z+4, r24	; 0x04
    aab6:	0e 94 d8 7b 	call	0xf7b0	; 0xf7b0 <sscanf>
		*(float*)Var = fTemp;
    aaba:	8d 81       	ldd	r24, Y+5	; 0x05
    aabc:	9e 81       	ldd	r25, Y+6	; 0x06
    aabe:	af 81       	ldd	r26, Y+7	; 0x07
    aac0:	b8 85       	ldd	r27, Y+8	; 0x08
    aac2:	f2 01       	movw	r30, r4
    aac4:	80 83       	st	Z, r24
    aac6:	91 83       	std	Z+1, r25	; 0x01
    aac8:	a2 83       	std	Z+2, r26	; 0x02
    aaca:	b3 83       	std	Z+3, r27	; 0x03
    aacc:	2d b7       	in	r18, 0x3d	; 61
    aace:	3e b7       	in	r19, 0x3e	; 62
    aad0:	2a 5f       	subi	r18, 0xFA	; 250
    aad2:	3f 4f       	sbci	r19, 0xFF	; 255
    aad4:	0f b6       	in	r0, 0x3f	; 63
    aad6:	f8 94       	cli
    aad8:	3e bf       	out	0x3e, r19	; 62
    aada:	0f be       	out	0x3f, r0	; 63
    aadc:	2d bf       	out	0x3d, r18	; 61
    aade:	db cd       	rjmp	.-1098   	; 0xa696 <Buf2Field+0x12c>
		break;
	case EE_FFloat: case EE_GFloat:
		if(sscanf(BufStr,"%f", &fTemp) == 1){
    aae0:	00 d0       	rcall	.+0      	; 0xaae2 <Buf2Field+0x578>
    aae2:	00 d0       	rcall	.+0      	; 0xaae4 <Buf2Field+0x57a>
    aae4:	ed b7       	in	r30, 0x3d	; 61
    aae6:	fe b7       	in	r31, 0x3e	; 62
    aae8:	31 96       	adiw	r30, 0x01	; 1
    aaea:	8b eb       	ldi	r24, 0xBB	; 187
    aaec:	95 e0       	ldi	r25, 0x05	; 5
    aaee:	ad b7       	in	r26, 0x3d	; 61
    aaf0:	be b7       	in	r27, 0x3e	; 62
    aaf2:	12 96       	adiw	r26, 0x02	; 2
    aaf4:	9c 93       	st	X, r25
    aaf6:	8e 93       	st	-X, r24
    aaf8:	11 97       	sbiw	r26, 0x01	; 1
    aafa:	88 ea       	ldi	r24, 0xA8	; 168
    aafc:	92 e0       	ldi	r25, 0x02	; 2
    aafe:	93 83       	std	Z+3, r25	; 0x03
    ab00:	82 83       	std	Z+2, r24	; 0x02
    ab02:	8e 01       	movw	r16, r28
    ab04:	0b 5f       	subi	r16, 0xFB	; 251
    ab06:	1f 4f       	sbci	r17, 0xFF	; 255
    ab08:	15 83       	std	Z+5, r17	; 0x05
    ab0a:	04 83       	std	Z+4, r16	; 0x04
    ab0c:	0e 94 d8 7b 	call	0xf7b0	; 0xf7b0 <sscanf>
    ab10:	ed b7       	in	r30, 0x3d	; 61
    ab12:	fe b7       	in	r31, 0x3e	; 62
    ab14:	36 96       	adiw	r30, 0x06	; 6
    ab16:	0f b6       	in	r0, 0x3f	; 63
    ab18:	f8 94       	cli
    ab1a:	fe bf       	out	0x3e, r31	; 62
    ab1c:	0f be       	out	0x3f, r0	; 63
    ab1e:	ed bf       	out	0x3d, r30	; 61
    ab20:	01 97       	sbiw	r24, 0x01	; 1
    ab22:	09 f0       	breq	.+2      	; 0xab26 <Buf2Field+0x5bc>
    ab24:	b8 cd       	rjmp	.-1168   	; 0xa696 <Buf2Field+0x12c>
			ewbl(&fTemp, (float*)Var, 4);
    ab26:	c8 01       	movw	r24, r16
    ab28:	b2 01       	movw	r22, r4
    ab2a:	44 e0       	ldi	r20, 0x04	; 4
    ab2c:	50 e0       	ldi	r21, 0x00	; 0
    ab2e:	0e 94 72 4c 	call	0x98e4	; 0x98e4 <ewbl>
    ab32:	b1 cd       	rjmp	.-1182   	; 0xa696 <Buf2Field+0x12c>
		}
		break;


	case Bit:
		if(F_Buf)
    ab34:	80 91 ef 04 	lds	r24, 0x04EF
    ab38:	90 91 f0 04 	lds	r25, 0x04F0
    ab3c:	a0 91 f1 04 	lds	r26, 0x04F1
    ab40:	b0 91 f2 04 	lds	r27, 0x04F2
    ab44:	00 97       	sbiw	r24, 0x00	; 0
    ab46:	a1 05       	cpc	r26, r1
    ab48:	b1 05       	cpc	r27, r1
    ab4a:	91 f1       	breq	.+100    	; 0xabb0 <Buf2Field+0x646>
			*BitVar |=Mask;
    ab4c:	d3 01       	movw	r26, r6
    ab4e:	8c 91       	ld	r24, X
    ab50:	83 29       	or	r24, r3
    ab52:	8c 93       	st	X, r24
    ab54:	a0 cd       	rjmp	.-1216   	; 0xa696 <Buf2Field+0x12c>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    ab56:	c3 01       	movw	r24, r6
    ab58:	0e 94 a4 7d 	call	0xfb48	; 0xfb48 <__eerd_byte_m2560>
    ab5c:	28 2f       	mov	r18, r24
		else
			*BitVar &=~Mask;
		break;
	case EE_Bit:
		EE_BitVar=erb(BitVar);
		ewb(BitVar, F_Buf ? EE_BitVar |Mask : EE_BitVar &~Mask);
    ab5e:	80 91 ef 04 	lds	r24, 0x04EF
    ab62:	90 91 f0 04 	lds	r25, 0x04F0
    ab66:	a0 91 f1 04 	lds	r26, 0x04F1
    ab6a:	b0 91 f2 04 	lds	r27, 0x04F2
    ab6e:	00 97       	sbiw	r24, 0x00	; 0
    ab70:	a1 05       	cpc	r26, r1
    ab72:	b1 05       	cpc	r27, r1
    ab74:	d1 f4       	brne	.+52     	; 0xabaa <Buf2Field+0x640>
    ab76:	63 2d       	mov	r22, r3
    ab78:	60 95       	com	r22
    ab7a:	62 23       	and	r22, r18
    ab7c:	c3 01       	movw	r24, r6
    ab7e:	0e 94 fd 4a 	call	0x95fa	; 0x95fa <ewb>
    ab82:	89 cd       	rjmp	.-1262   	; 0xa696 <Buf2Field+0x12c>
		break;


	case Text:{
		//    
		uint8_t Field_width = strlen((char*)Var);
    ab84:	f2 01       	movw	r30, r4
    ab86:	01 90       	ld	r0, Z+
    ab88:	00 20       	and	r0, r0
    ab8a:	e9 f7       	brne	.-6      	; 0xab86 <Buf2Field+0x61c>
    ab8c:	31 97       	sbiw	r30, 0x01	; 1
    ab8e:	4e 2f       	mov	r20, r30
    ab90:	44 19       	sub	r20, r4
		if(Field_width > LCDXSz) Field_width = LCDXSz+1;
    ab92:	45 31       	cpi	r20, 0x15	; 21
    ab94:	e8 f0       	brcs	.+58     	; 0xabd0 <Buf2Field+0x666>
    ab96:	e5 e1       	ldi	r30, 0x15	; 21
    ab98:	f0 e0       	ldi	r31, 0x00	; 0
		memcpy(Var,BufStr,Field_width);
    ab9a:	2b eb       	ldi	r18, 0xBB	; 187
    ab9c:	35 e0       	ldi	r19, 0x05	; 5
    ab9e:	c2 01       	movw	r24, r4
    aba0:	b9 01       	movw	r22, r18
    aba2:	af 01       	movw	r20, r30
    aba4:	0e 94 c6 7a 	call	0xf58c	; 0xf58c <memcpy>
    aba8:	76 cd       	rjmp	.-1300   	; 0xa696 <Buf2Field+0x12c>
		else
			*BitVar &=~Mask;
		break;
	case EE_Bit:
		EE_BitVar=erb(BitVar);
		ewb(BitVar, F_Buf ? EE_BitVar |Mask : EE_BitVar &~Mask);
    abaa:	63 2d       	mov	r22, r3
    abac:	62 2b       	or	r22, r18
    abae:	e6 cf       	rjmp	.-52     	; 0xab7c <Buf2Field+0x612>

	case Bit:
		if(F_Buf)
			*BitVar |=Mask;
		else
			*BitVar &=~Mask;
    abb0:	30 94       	com	r3
    abb2:	f3 01       	movw	r30, r6
    abb4:	80 81       	ld	r24, Z
    abb6:	83 21       	and	r24, r3
    abb8:	80 83       	st	Z, r24
    abba:	6d cd       	rjmp	.-1318   	; 0xa696 <Buf2Field+0x12c>
		break;
	case s_Longint:
		PresicionHanler(Field);
		//if(Limit_sByteVar(Temp)) sscanf(BufStr,"%hd", (short int*)&Temp);
		sscanf(BufStr,"%ld", (int32_t*)&Temp);
		SetField32(Temp, int32_t);
    abbc:	d2 01       	movw	r26, r4
    abbe:	ed 92       	st	X+, r14
    abc0:	fd 92       	st	X+, r15
    abc2:	0d 93       	st	X+, r16
    abc4:	1c 93       	st	X, r17
    abc6:	13 97       	sbiw	r26, 0x03	; 3
    abc8:	66 cd       	rjmp	.-1332   	; 0xa696 <Buf2Field+0x12c>
	switch(prb(&Field->Type)) {
	case Byte: case z_Byte: case Enum:
		SetField(F_Buf, uint8_t);
		break;
	case s_Byte:
		SetField(sF_Buf, int8_t);
    abca:	f2 01       	movw	r30, r4
    abcc:	e0 82       	st	Z, r14
    abce:	63 cd       	rjmp	.-1338   	; 0xa696 <Buf2Field+0x12c>


	case Text:{
		//    
		uint8_t Field_width = strlen((char*)Var);
		if(Field_width > LCDXSz) Field_width = LCDXSz+1;
    abd0:	e4 2f       	mov	r30, r20
    abd2:	f0 e0       	ldi	r31, 0x00	; 0
    abd4:	e2 cf       	rjmp	.-60     	; 0xab9a <Buf2Field+0x630>
	uint32_t Temp=0;
	float fTemp=0;

	switch(prb(&Field->Type)) {
	case Byte: case z_Byte: case Enum:
		SetField(F_Buf, uint8_t);
    abd6:	d2 01       	movw	r26, r4
    abd8:	ec 92       	st	X, r14
    abda:	5d cd       	rjmp	.-1350   	; 0xa696 <Buf2Field+0x12c>
		break;
	case s_EE_Byte:
		SetEEField(sF_Buf, int8_t, uint8_t, b);
		break;
	case Word: case z_Word:
		SetField(F_Buf, uint16_t);
    abdc:	d2 01       	movw	r26, r4
    abde:	ed 92       	st	X+, r14
    abe0:	fc 92       	st	X, r15
    abe2:	59 cd       	rjmp	.-1358   	; 0xa696 <Buf2Field+0x12c>
		break;
	case EE_Word: case z_EE_Word:
		SetEEField(F_Buf, uint16_t, uint16_t, w);
		break;
	case s_Word:
		SetField(sF_Buf, int16_t);
    abe4:	f2 01       	movw	r30, r4
    abe6:	f1 82       	std	Z+1, r15	; 0x01
    abe8:	e0 82       	st	Z, r14
    abea:	55 cd       	rjmp	.-1366   	; 0xa696 <Buf2Field+0x12c>
		break;
	case s_EE_Word:
		SetEEField(sF_Buf, int16_t, uint16_t, w);
    abec:	c2 01       	movw	r24, r4
    abee:	b7 01       	movw	r22, r14
    abf0:	0e 94 40 4b 	call	0x9680	; 0x9680 <eww>
    abf4:	50 cd       	rjmp	.-1376   	; 0xa696 <Buf2Field+0x12c>
		break;
	case EE_Byte: case z_EE_Byte: case EE_Enum:
		SetEEField(F_Buf, uint8_t, uint8_t, b);
		break;
	case s_EE_Byte:
		SetEEField(sF_Buf, int8_t, uint8_t, b);
    abf6:	c2 01       	movw	r24, r4
    abf8:	6e 2d       	mov	r22, r14
    abfa:	0e 94 fd 4a 	call	0x95fa	; 0x95fa <ewb>
    abfe:	4b cd       	rjmp	.-1386   	; 0xa696 <Buf2Field+0x12c>
	switch(prb(&Field->Type)) {
	case Byte: case z_Byte: case Enum:
		SetField(F_Buf, uint8_t);
		break;
	case s_Byte:
		SetField(sF_Buf, int8_t);
    ac00:	f2 01       	movw	r30, r4
    ac02:	20 83       	st	Z, r18
    ac04:	48 cd       	rjmp	.-1392   	; 0xa696 <Buf2Field+0x12c>
		break;
	case s_EE_Byte:
		SetEEField(sF_Buf, int8_t, uint8_t, b);
		break;
	case Word: case z_Word:
		SetField(F_Buf, uint16_t);
    ac06:	d2 01       	movw	r26, r4
    ac08:	2d 93       	st	X+, r18
    ac0a:	3c 93       	st	X, r19
    ac0c:	44 cd       	rjmp	.-1400   	; 0xa696 <Buf2Field+0x12c>
		break;
	case EE_Word: case z_EE_Word:
		SetEEField(F_Buf, uint16_t, uint16_t, w);
		break;
	case s_Word:
		SetField(sF_Buf, int16_t);
    ac0e:	f2 01       	movw	r30, r4
    ac10:	31 83       	std	Z+1, r19	; 0x01
    ac12:	20 83       	st	Z, r18
    ac14:	40 cd       	rjmp	.-1408   	; 0xa696 <Buf2Field+0x12c>
	uint32_t Temp=0;
	float fTemp=0;

	switch(prb(&Field->Type)) {
	case Byte: case z_Byte: case Enum:
		SetField(F_Buf, uint8_t);
    ac16:	d2 01       	movw	r26, r4
    ac18:	2c 93       	st	X, r18
    ac1a:	3d cd       	rjmp	.-1414   	; 0xa696 <Buf2Field+0x12c>
		SetField32(Temp, int32_t);
		break;
	case s_EE_Longint:
		PresicionHanler(Field);
		if(sscanf(BufStr,"%ld", (int32_t*)&Temp) == 1){
			SetEEField32(Temp, int32_t, uint32_t, d);
    ac1c:	c2 01       	movw	r24, r4
    ac1e:	b8 01       	movw	r22, r16
    ac20:	a7 01       	movw	r20, r14
    ac22:	0e 94 77 4c 	call	0x98ee	; 0x98ee <ewd>
    ac26:	37 cd       	rjmp	.-1426   	; 0xa696 <Buf2Field+0x12c>

0000ac28 <MenuEnterRight>:
}

// ~~~~~~~~~~~~~~~~~
void
MenuEnterRight(void)
{
    ac28:	ef 92       	push	r14
    ac2a:	ff 92       	push	r15
    ac2c:	0f 93       	push	r16
    ac2e:	1f 93       	push	r17
    ac30:	cf 93       	push	r28
    ac32:	df 93       	push	r29
//	1) Hide current Message
	if(HideMsg()||KeyFunc(&CurrPage->Enter))
    ac34:	0e 94 dd 3b 	call	0x77ba	; 0x77ba <HideMsg>
    ac38:	88 23       	and	r24, r24
    ac3a:	39 f0       	breq	.+14     	; 0xac4a <MenuEnterRight+0x22>
	if(NextPage || (NextPage=prp(&Line->InnPage))) {
		GotoMenu(NextPage);
		NextPage=NULL;
		return;
	}
}
    ac3c:	df 91       	pop	r29
    ac3e:	cf 91       	pop	r28
    ac40:	1f 91       	pop	r17
    ac42:	0f 91       	pop	r16
    ac44:	ff 90       	pop	r15
    ac46:	ef 90       	pop	r14
    ac48:	08 95       	ret
// ~~~~~~~~~~~~~~~~~
void
MenuEnterRight(void)
{
//	1) Hide current Message
	if(HideMsg()||KeyFunc(&CurrPage->Enter))
    ac4a:	80 91 d1 02 	lds	r24, 0x02D1
    ac4e:	90 91 d2 02 	lds	r25, 0x02D2
    ac52:	0c 96       	adiw	r24, 0x0c	; 12
    ac54:	0e 94 83 3b 	call	0x7706	; 0x7706 <KeyFunc>
    ac58:	88 23       	and	r24, r24
    ac5a:	81 f7       	brne	.-32     	; 0xac3c <MenuEnterRight+0x14>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    ac5c:	40 91 d1 02 	lds	r20, 0x02D1
    ac60:	50 91 d2 02 	lds	r21, 0x02D2
    ac64:	fa 01       	movw	r30, r20
    ac66:	c5 91       	lpm	r28, Z+
    ac68:	d4 91       	lpm	r29, Z+
		return;

	MenuLine *Line=GetLine+CurrLine;
    ac6a:	90 91 7d 07 	lds	r25, 0x077D
    ac6e:	8b e1       	ldi	r24, 0x1B	; 27
    ac70:	98 9f       	mul	r25, r24
    ac72:	b0 01       	movw	r22, r0
    ac74:	11 24       	eor	r1, r1
    ac76:	c6 0f       	add	r28, r22
    ac78:	d7 1f       	adc	r29, r23
    ac7a:	fe 01       	movw	r30, r28
    ac7c:	77 96       	adiw	r30, 0x17	; 23
    ac7e:	e5 90       	lpm	r14, Z+
    ac80:	f4 90       	lpm	r15, Z+
	OutField *Field=prp(&Line->OF_List);

// 2) Variable
	if(Field){
    ac82:	e1 14       	cp	r14, r1
    ac84:	f1 04       	cpc	r15, r1
    ac86:	09 f4       	brne	.+2      	; 0xac8a <MenuEnterRight+0x62>
    ac88:	93 c0       	rjmp	.+294    	; 0xadb0 <MenuEnterRight+0x188>
    ac8a:	10 e0       	ldi	r17, 0x00	; 0
    ac8c:	30 e0       	ldi	r19, 0x00	; 0
    ac8e:	80 e0       	ldi	r24, 0x00	; 0
    ac90:	90 e0       	ldi	r25, 0x00	; 0
    ac92:	05 c0       	rjmp	.+10     	; 0xac9e <MenuEnterRight+0x76>
		uint8_t i=0;
		while(i<LCDXSz) {
			Char1 = Char2;
			Char2 = prc(CurrStr+i++);
			if (Char2=='}' && Char1!='}')
				FieldNumber++;
    ac94:	01 96       	adiw	r24, 0x01	; 1
	// Define variable quantity 
		uint8_t FieldNumber = 0;
		PGM_P CurrStr=(PGM_P)(Line->Str);
		char Char1, Char2=0;
		uint8_t i=0;
		while(i<LCDXSz) {
    ac96:	84 31       	cpi	r24, 0x14	; 20
    ac98:	91 05       	cpc	r25, r1
    ac9a:	71 f0       	breq	.+28     	; 0xacb8 <MenuEnterRight+0x90>
    ac9c:	32 2f       	mov	r19, r18

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    ac9e:	fe 01       	movw	r30, r28
    aca0:	e8 0f       	add	r30, r24
    aca2:	f9 1f       	adc	r31, r25
    aca4:	24 91       	lpm	r18, Z+
			Char1 = Char2;
			Char2 = prc(CurrStr+i++);
			if (Char2=='}' && Char1!='}')
    aca6:	2d 37       	cpi	r18, 0x7D	; 125
    aca8:	a9 f7       	brne	.-22     	; 0xac94 <MenuEnterRight+0x6c>
    acaa:	3d 37       	cpi	r19, 0x7D	; 125
    acac:	99 f3       	breq	.-26     	; 0xac94 <MenuEnterRight+0x6c>
				FieldNumber++;
    acae:	1f 5f       	subi	r17, 0xFF	; 255
    acb0:	01 96       	adiw	r24, 0x01	; 1
	// Define variable quantity 
		uint8_t FieldNumber = 0;
		PGM_P CurrStr=(PGM_P)(Line->Str);
		char Char1, Char2=0;
		uint8_t i=0;
		while(i<LCDXSz) {
    acb2:	84 31       	cpi	r24, 0x14	; 20
    acb4:	91 05       	cpc	r25, r1
    acb6:	91 f7       	brne	.-28     	; 0xac9c <MenuEnterRight+0x74>
			Char2 = prc(CurrStr+i++);
			if (Char2=='}' && Char1!='}')
				FieldNumber++;
		}
		//    Bit (:)   
		if(FieldNumber==1 && prb(&Field->Type)==Bit) {
    acb8:	11 30       	cpi	r17, 0x01	; 1
    acba:	09 f4       	brne	.+2      	; 0xacbe <MenuEnterRight+0x96>
    acbc:	b8 c0       	rjmp	.+368    	; 0xae2e <MenuEnterRight+0x206>
			EventFunc(&Field->Act);
			return;
		}

	//    
		if(CurrPos!=NullPos && --CurrPos!=NullPos){
    acbe:	80 91 d4 02 	lds	r24, 0x02D4
    acc2:	8f 3f       	cpi	r24, 0xFF	; 255
    acc4:	09 f4       	brne	.+2      	; 0xacc8 <MenuEnterRight+0xa0>
    acc6:	4a c0       	rjmp	.+148    	; 0xad5c <MenuEnterRight+0x134>
    acc8:	08 2f       	mov	r16, r24
    acca:	01 50       	subi	r16, 0x01	; 1
    accc:	00 93 d4 02 	sts	0x02D4, r16
    acd0:	0f 3f       	cpi	r16, 0xFF	; 255
    acd2:	09 f4       	brne	.+2      	; 0xacd6 <MenuEnterRight+0xae>
    acd4:	43 c0       	rjmp	.+134    	; 0xad5c <MenuEnterRight+0x134>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    acd6:	fa 01       	movw	r30, r20
    acd8:	45 91       	lpm	r20, Z+
    acda:	54 91       	lpm	r21, Z+
			OutField *Field1=GetField;
    acdc:	46 0f       	add	r20, r22
    acde:	57 1f       	adc	r21, r23
    ace0:	49 5e       	subi	r20, 0xE9	; 233
    ace2:	5f 4f       	sbci	r21, 0xFF	; 255
    ace4:	fa 01       	movw	r30, r20
    ace6:	25 91       	lpm	r18, Z+
    ace8:	34 91       	lpm	r19, Z+
    acea:	80 91 d3 02 	lds	r24, 0x02D3
    acee:	90 e0       	ldi	r25, 0x00	; 0
    acf0:	82 95       	swap	r24
    acf2:	92 95       	swap	r25
    acf4:	90 7f       	andi	r25, 0xF0	; 240
    acf6:	98 27       	eor	r25, r24
    acf8:	80 7f       	andi	r24, 0xF0	; 240
    acfa:	98 27       	eor	r25, r24
    acfc:	28 0f       	add	r18, r24
    acfe:	39 1f       	adc	r19, r25

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    ad00:	f9 01       	movw	r30, r18
    ad02:	84 91       	lpm	r24, Z+
			switch(prb(&Field1->Type)){
    ad04:	8d 31       	cpi	r24, 0x1D	; 29
    ad06:	08 f4       	brcc	.+2      	; 0xad0a <MenuEnterRight+0xe2>
    ad08:	67 c0       	rjmp	.+206    	; 0xadd8 <MenuEnterRight+0x1b0>
    ad0a:	81 52       	subi	r24, 0x21	; 33
    ad0c:	82 30       	cpi	r24, 0x02	; 2
    ad0e:	08 f0       	brcs	.+2      	; 0xad12 <MenuEnterRight+0xea>
    ad10:	95 cf       	rjmp	.-214    	; 0xac3c <MenuEnterRight+0x14>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    ad12:	f9 01       	movw	r30, r18
    ad14:	33 96       	adiw	r30, 0x03	; 3
    ad16:	85 91       	lpm	r24, Z+
    ad18:	95 91       	lpm	r25, Z+
    ad1a:	a5 91       	lpm	r26, Z+
    ad1c:	b4 91       	lpm	r27, Z+
			case Text: case EE_Text:
				if( (prd(&Field1->Min) == DIGIT) && (prd(&Field1->Max) == DIGIT) )
    ad1e:	00 97       	sbiw	r24, 0x00	; 0
    ad20:	a1 05       	cpc	r26, r1
    ad22:	b1 05       	cpc	r27, r1
    ad24:	59 f4       	brne	.+22     	; 0xad3c <MenuEnterRight+0x114>
    ad26:	f9 01       	movw	r30, r18
    ad28:	37 96       	adiw	r30, 0x07	; 7
    ad2a:	85 91       	lpm	r24, Z+
    ad2c:	95 91       	lpm	r25, Z+
    ad2e:	a5 91       	lpm	r26, Z+
    ad30:	b4 91       	lpm	r27, Z+
    ad32:	00 97       	sbiw	r24, 0x00	; 0
    ad34:	a1 05       	cpc	r26, r1
    ad36:	b1 05       	cpc	r27, r1
    ad38:	09 f4       	brne	.+2      	; 0xad3c <MenuEnterRight+0x114>
    ad3a:	a3 c0       	rjmp	.+326    	; 0xae82 <MenuEnterRight+0x25a>
					MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[CurrFieldSize - 1 - CurrPos]);
				else MultiSymbol = GetMultiSymbol(Symbols_P, BufStr[CurrFieldSize - 1 - CurrPos]);
    ad3c:	e0 91 74 07 	lds	r30, 0x0774
    ad40:	f0 e0       	ldi	r31, 0x00	; 0
    ad42:	31 97       	sbiw	r30, 0x01	; 1
    ad44:	e0 1b       	sub	r30, r16
    ad46:	f1 09       	sbc	r31, r1
    ad48:	e5 54       	subi	r30, 0x45	; 69
    ad4a:	fa 4f       	sbci	r31, 0xFA	; 250
    ad4c:	88 ef       	ldi	r24, 0xF8	; 248
    ad4e:	95 e0       	ldi	r25, 0x05	; 5
    ad50:	60 81       	ld	r22, Z
    ad52:	0e 94 e3 3f 	call	0x7fc6	; 0x7fc6 <GetMultiSymbol>
    ad56:	80 93 ec 04 	sts	0x04EC, r24
    ad5a:	70 cf       	rjmp	.-288    	; 0xac3c <MenuEnterRight+0x14>
				break;		
			}
			return;
		}

		if(CurrField!=NullPos) {
    ad5c:	80 91 d3 02 	lds	r24, 0x02D3
    ad60:	8f 3f       	cpi	r24, 0xFF	; 255
    ad62:	81 f0       	breq	.+32     	; 0xad84 <MenuEnterRight+0x15c>
			Buf2Field(Field+CurrField);
    ad64:	90 e0       	ldi	r25, 0x00	; 0
    ad66:	82 95       	swap	r24
    ad68:	92 95       	swap	r25
    ad6a:	90 7f       	andi	r25, 0xF0	; 240
    ad6c:	98 27       	eor	r25, r24
    ad6e:	80 7f       	andi	r24, 0xF0	; 240
    ad70:	98 27       	eor	r25, r24
    ad72:	8e 0d       	add	r24, r14
    ad74:	9f 1d       	adc	r25, r15
    ad76:	0e 94 b5 52 	call	0xa56a	; 0xa56a <Buf2Field>
			if(CurrField==NullPos)
    ad7a:	80 91 d3 02 	lds	r24, 0x02D3
    ad7e:	8f 3f       	cpi	r24, 0xFF	; 255
    ad80:	09 f4       	brne	.+2      	; 0xad84 <MenuEnterRight+0x15c>
    ad82:	5c cf       	rjmp	.-328    	; 0xac3c <MenuEnterRight+0x14>
				return;
		}
		//     
		if(++CurrField==FieldNumber)
    ad84:	8f 5f       	subi	r24, 0xFF	; 255
    ad86:	80 93 d3 02 	sts	0x02D3, r24
    ad8a:	18 17       	cp	r17, r24
    ad8c:	d9 f1       	breq	.+118    	; 0xae04 <MenuEnterRight+0x1dc>
			CurrField=NullPos;
		else
			Field2Buf(Field+CurrField);
    ad8e:	90 e0       	ldi	r25, 0x00	; 0
    ad90:	82 95       	swap	r24
    ad92:	92 95       	swap	r25
    ad94:	90 7f       	andi	r25, 0xF0	; 240
    ad96:	98 27       	eor	r25, r24
    ad98:	80 7f       	andi	r24, 0xF0	; 240
    ad9a:	98 27       	eor	r25, r24
    ad9c:	8e 0d       	add	r24, r14
    ad9e:	9f 1d       	adc	r25, r15
    ada0:	0e 94 fd 4e 	call	0x9dfa	; 0x9dfa <Field2Buf>
    ada4:	40 91 d1 02 	lds	r20, 0x02D1
    ada8:	50 91 d2 02 	lds	r21, 0x02D2
    adac:	90 91 7d 07 	lds	r25, 0x077D

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    adb0:	4e 5f       	subi	r20, 0xFE	; 254
    adb2:	5f 4f       	sbci	r21, 0xFF	; 255
    adb4:	fa 01       	movw	r30, r20
    adb6:	84 91       	lpm	r24, Z+
	}

// 3) Go to menu
	if( CurrLine >= prb(&CurrPage->LineNumber) )
    adb8:	98 17       	cp	r25, r24
    adba:	08 f0       	brcs	.+2      	; 0xadbe <MenuEnterRight+0x196>
    adbc:	3f cf       	rjmp	.-386    	; 0xac3c <MenuEnterRight+0x14>
		return;

	if(NextPage || (NextPage=prp(&Line->InnPage))) {
    adbe:	80 91 d1 05 	lds	r24, 0x05D1
    adc2:	90 91 d2 05 	lds	r25, 0x05D2
    adc6:	00 97       	sbiw	r24, 0x00	; 0
    adc8:	39 f1       	breq	.+78     	; 0xae18 <MenuEnterRight+0x1f0>
		GotoMenu(NextPage);
    adca:	0e 94 95 3b 	call	0x772a	; 0x772a <GotoMenu>
		NextPage=NULL;
    adce:	10 92 d2 05 	sts	0x05D2, r1
    add2:	10 92 d1 05 	sts	0x05D1, r1
    add6:	32 cf       	rjmp	.-412    	; 0xac3c <MenuEnterRight+0x14>
		}

	//    
		if(CurrPos!=NullPos && --CurrPos!=NullPos){
			OutField *Field1=GetField;
			switch(prb(&Field1->Type)){
    add8:	89 31       	cpi	r24, 0x19	; 25
    adda:	20 f4       	brcc	.+8      	; 0xade4 <MenuEnterRight+0x1bc>
    addc:	80 51       	subi	r24, 0x10	; 16
    adde:	86 30       	cpi	r24, 0x06	; 6
    ade0:	08 f0       	brcs	.+2      	; 0xade4 <MenuEnterRight+0x1bc>
    ade2:	2c cf       	rjmp	.-424    	; 0xac3c <MenuEnterRight+0x14>
					MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[CurrFieldSize - 1 - CurrPos]);
				else MultiSymbol = GetMultiSymbol(Symbols_P, BufStr[CurrFieldSize - 1 - CurrPos]);
				break;
			case Longint: case z_Longint: case EE_Longint: case z_EE_Longint: case s_Longint: case s_EE_Longint:
			case FFloat: case EE_FFloat: case GFloat: case EE_GFloat:
				MultiSymbol = GetMultiSymbol(Digits_P, BufStr[CurrFieldSize - 1 - CurrPos]);
    ade4:	e0 91 74 07 	lds	r30, 0x0774
    ade8:	f0 e0       	ldi	r31, 0x00	; 0
    adea:	31 97       	sbiw	r30, 0x01	; 1
    adec:	e0 1b       	sub	r30, r16
    adee:	f1 09       	sbc	r31, r1
    adf0:	e5 54       	subi	r30, 0x45	; 69
    adf2:	fa 4f       	sbci	r31, 0xFA	; 250
    adf4:	81 ea       	ldi	r24, 0xA1	; 161
    adf6:	96 e0       	ldi	r25, 0x06	; 6
    adf8:	60 81       	ld	r22, Z
    adfa:	0e 94 e3 3f 	call	0x7fc6	; 0x7fc6 <GetMultiSymbol>
    adfe:	80 93 ec 04 	sts	0x04EC, r24
    ae02:	1c cf       	rjmp	.-456    	; 0xac3c <MenuEnterRight+0x14>
			if(CurrField==NullPos)
				return;
		}
		//     
		if(++CurrField==FieldNumber)
			CurrField=NullPos;
    ae04:	8f ef       	ldi	r24, 0xFF	; 255
    ae06:	80 93 d3 02 	sts	0x02D3, r24
    ae0a:	40 91 d1 02 	lds	r20, 0x02D1
    ae0e:	50 91 d2 02 	lds	r21, 0x02D2
    ae12:	90 91 7d 07 	lds	r25, 0x077D
    ae16:	cc cf       	rjmp	.-104    	; 0xadb0 <MenuEnterRight+0x188>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    ae18:	fe 01       	movw	r30, r28
    ae1a:	79 96       	adiw	r30, 0x19	; 25
    ae1c:	85 91       	lpm	r24, Z+
    ae1e:	94 91       	lpm	r25, Z+

// 3) Go to menu
	if( CurrLine >= prb(&CurrPage->LineNumber) )
		return;

	if(NextPage || (NextPage=prp(&Line->InnPage))) {
    ae20:	90 93 d2 05 	sts	0x05D2, r25
    ae24:	80 93 d1 05 	sts	0x05D1, r24
    ae28:	00 97       	sbiw	r24, 0x00	; 0
    ae2a:	79 f6       	brne	.-98     	; 0xadca <MenuEnterRight+0x1a2>
    ae2c:	07 cf       	rjmp	.-498    	; 0xac3c <MenuEnterRight+0x14>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    ae2e:	f7 01       	movw	r30, r14
    ae30:	84 91       	lpm	r24, Z+
			Char2 = prc(CurrStr+i++);
			if (Char2=='}' && Char1!='}')
				FieldNumber++;
		}
		//    Bit (:)   
		if(FieldNumber==1 && prb(&Field->Type)==Bit) {
    ae32:	8f 31       	cpi	r24, 0x1F	; 31
    ae34:	09 f0       	breq	.+2      	; 0xae38 <MenuEnterRight+0x210>
    ae36:	43 cf       	rjmp	.-378    	; 0xacbe <MenuEnterRight+0x96>
    ae38:	8f e0       	ldi	r24, 0x0F	; 15
    ae3a:	90 e0       	ldi	r25, 0x00	; 0
    ae3c:	e8 0e       	add	r14, r24
    ae3e:	f9 1e       	adc	r15, r25
    ae40:	f7 01       	movw	r30, r14
    ae42:	24 91       	lpm	r18, Z+
    ae44:	81 ef       	ldi	r24, 0xF1	; 241
    ae46:	9f ef       	ldi	r25, 0xFF	; 255
    ae48:	e8 0e       	add	r14, r24
    ae4a:	f9 1e       	adc	r15, r25

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    ae4c:	c7 01       	movw	r24, r14
    ae4e:	01 96       	adiw	r24, 0x01	; 1
    ae50:	fc 01       	movw	r30, r24
    ae52:	a5 91       	lpm	r26, Z+
    ae54:	b4 91       	lpm	r27, Z+
			uint8_t BitN=prb(&Field->Prec);
			*((uint8_t*)prp(&Field->Var)+BitN/8) ^=(1<<BitN%8);
    ae56:	82 2f       	mov	r24, r18
    ae58:	86 95       	lsr	r24
    ae5a:	86 95       	lsr	r24
    ae5c:	86 95       	lsr	r24
    ae5e:	a8 0f       	add	r26, r24
    ae60:	b1 1d       	adc	r27, r1
    ae62:	27 70       	andi	r18, 0x07	; 7
    ae64:	81 e0       	ldi	r24, 0x01	; 1
    ae66:	90 e0       	ldi	r25, 0x00	; 0
    ae68:	02 c0       	rjmp	.+4      	; 0xae6e <MenuEnterRight+0x246>
    ae6a:	88 0f       	add	r24, r24
    ae6c:	99 1f       	adc	r25, r25
    ae6e:	2a 95       	dec	r18
    ae70:	e2 f7       	brpl	.-8      	; 0xae6a <MenuEnterRight+0x242>
    ae72:	2c 91       	ld	r18, X
    ae74:	28 27       	eor	r18, r24
    ae76:	2c 93       	st	X, r18
			EventFunc(&Field->Act);
    ae78:	c7 01       	movw	r24, r14
    ae7a:	0b 96       	adiw	r24, 0x0b	; 11
    ae7c:	0e 94 7b 3b 	call	0x76f6	; 0x76f6 <EventFunc>
    ae80:	dd ce       	rjmp	.-582    	; 0xac3c <MenuEnterRight+0x14>
		if(CurrPos!=NullPos && --CurrPos!=NullPos){
			OutField *Field1=GetField;
			switch(prb(&Field1->Type)){
			case Text: case EE_Text:
				if( (prd(&Field1->Min) == DIGIT) && (prd(&Field1->Max) == DIGIT) )
					MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[CurrFieldSize - 1 - CurrPos]);
    ae82:	e0 91 74 07 	lds	r30, 0x0774
    ae86:	f0 e0       	ldi	r31, 0x00	; 0
    ae88:	31 97       	sbiw	r30, 0x01	; 1
    ae8a:	e0 1b       	sub	r30, r16
    ae8c:	f1 09       	sbc	r31, r1
    ae8e:	e5 54       	subi	r30, 0x45	; 69
    ae90:	fa 4f       	sbci	r31, 0xFA	; 250
    ae92:	86 e9       	ldi	r24, 0x96	; 150
    ae94:	96 e0       	ldi	r25, 0x06	; 6
    ae96:	60 81       	ld	r22, Z
    ae98:	0e 94 e3 3f 	call	0x7fc6	; 0x7fc6 <GetMultiSymbol>
    ae9c:	80 93 ec 04 	sts	0x04EC, r24
    aea0:	cd ce       	rjmp	.-614    	; 0xac3c <MenuEnterRight+0x14>

0000aea2 <MenuUD>:
	return Pos*Dir;
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
MenuUD(const MenuKey *Key, int8_t Dir, uint8_t LimLine, uint8_t LimLCD, uint8_t LimVar)
{
    aea2:	af 92       	push	r10
    aea4:	bf 92       	push	r11
    aea6:	cf 92       	push	r12
    aea8:	df 92       	push	r13
    aeaa:	ef 92       	push	r14
    aeac:	ff 92       	push	r15
    aeae:	0f 93       	push	r16
    aeb0:	1f 93       	push	r17
    aeb2:	cf 93       	push	r28
    aeb4:	df 93       	push	r29
    aeb6:	fc 01       	movw	r30, r24
    aeb8:	e6 2e       	mov	r14, r22
    aeba:	14 2f       	mov	r17, r20
    aebc:	f2 2e       	mov	r15, r18
	if(CurrMsg || KeyFunc(Key))
    aebe:	80 91 ed 04 	lds	r24, 0x04ED
    aec2:	90 91 ee 04 	lds	r25, 0x04EE
    aec6:	89 2b       	or	r24, r25
    aec8:	59 f0       	breq	.+22     	; 0xaee0 <MenuUD+0x3e>
		else 		{if(--MultiSymbol == 255) MultiSymbol = strlen_P(Digits_P)-1;}
		if(CurrPos!=NullPos)
			BufStr[CurrFieldSize - 1 - CurrPos] = prc(Digits_P + MultiSymbol);
		break;
	}
}
    aeca:	df 91       	pop	r29
    aecc:	cf 91       	pop	r28
    aece:	1f 91       	pop	r17
    aed0:	0f 91       	pop	r16
    aed2:	ff 90       	pop	r15
    aed4:	ef 90       	pop	r14
    aed6:	df 90       	pop	r13
    aed8:	cf 90       	pop	r12
    aeda:	bf 90       	pop	r11
    aedc:	af 90       	pop	r10
    aede:	08 95       	ret
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
MenuUD(const MenuKey *Key, int8_t Dir, uint8_t LimLine, uint8_t LimLCD, uint8_t LimVar)
{
	if(CurrMsg || KeyFunc(Key))
    aee0:	cf 01       	movw	r24, r30
    aee2:	0e 94 83 3b 	call	0x7706	; 0x7706 <KeyFunc>
    aee6:	88 23       	and	r24, r24
    aee8:	81 f7       	brne	.-32     	; 0xaeca <MenuUD+0x28>
		return;
	if(CurrField==NullPos) {
    aeea:	30 91 d3 02 	lds	r19, 0x02D3
    aeee:	3f 3f       	cpi	r19, 0xFF	; 255
    aef0:	09 f4       	brne	.+2      	; 0xaef4 <MenuUD+0x52>
    aef2:	48 c1       	rjmp	.+656    	; 0xb184 <MenuUD+0x2e2>
			if(LimLCD)
				CurrLCD -= Dir;
		}
		return;
	}
	Blink=0;
    aef4:	10 92 ca 08 	sts	0x08CA, r1
    aef8:	80 91 d1 02 	lds	r24, 0x02D1
    aefc:	90 91 d2 02 	lds	r25, 0x02D2
    af00:	fc 01       	movw	r30, r24
    af02:	45 91       	lpm	r20, Z+
    af04:	54 91       	lpm	r21, Z+
	OutField *Field=GetField;
    af06:	80 91 7d 07 	lds	r24, 0x077D
    af0a:	2b e1       	ldi	r18, 0x1B	; 27
    af0c:	82 9f       	mul	r24, r18
    af0e:	c0 01       	movw	r24, r0
    af10:	11 24       	eor	r1, r1
    af12:	48 0f       	add	r20, r24
    af14:	59 1f       	adc	r21, r25
    af16:	49 5e       	subi	r20, 0xE9	; 233
    af18:	5f 4f       	sbci	r21, 0xFF	; 255
    af1a:	fa 01       	movw	r30, r20
    af1c:	c5 91       	lpm	r28, Z+
    af1e:	d4 91       	lpm	r29, Z+
    af20:	83 2f       	mov	r24, r19
    af22:	90 e0       	ldi	r25, 0x00	; 0
    af24:	82 95       	swap	r24
    af26:	92 95       	swap	r25
    af28:	90 7f       	andi	r25, 0xF0	; 240
    af2a:	98 27       	eor	r25, r24
    af2c:	80 7f       	andi	r24, 0xF0	; 240
    af2e:	98 27       	eor	r25, r24
    af30:	c8 0f       	add	r28, r24
    af32:	d9 1f       	adc	r29, r25

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    af34:	fe 01       	movw	r30, r28
    af36:	84 91       	lpm	r24, Z+
	switch(prb(&Field->Type)) {
    af38:	e8 2f       	mov	r30, r24
    af3a:	f0 e0       	ldi	r31, 0x00	; 0
    af3c:	e3 32       	cpi	r30, 0x23	; 35
    af3e:	f1 05       	cpc	r31, r1
    af40:	08 f0       	brcs	.+2      	; 0xaf44 <MenuUD+0xa2>
    af42:	c3 cf       	rjmp	.-122    	; 0xaeca <MenuUD+0x28>
    af44:	ea 54       	subi	r30, 0x4A	; 74
    af46:	ff 4f       	sbci	r31, 0xFF	; 255
    af48:	ee 0f       	add	r30, r30
    af4a:	ff 1f       	adc	r31, r31
    af4c:	05 90       	lpm	r0, Z+
    af4e:	f4 91       	lpm	r31, Z+
    af50:	e0 2d       	mov	r30, r0
    af52:	19 94       	eijmp

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    af54:	fe 01       	movw	r30, r28
    af56:	33 96       	adiw	r30, 0x03	; 3
    af58:	85 91       	lpm	r24, Z+
    af5a:	95 91       	lpm	r25, Z+
    af5c:	a5 91       	lpm	r26, Z+
    af5e:	b4 91       	lpm	r27, Z+
		break;
	case Bit: case EE_Bit:
		F_Buf = !F_Buf;
		break;
	case Text: case EE_Text:
		if( (prd(&Field->Min) == DIGIT) && (prd(&Field->Max) == DIGIT) ){
    af60:	00 97       	sbiw	r24, 0x00	; 0
    af62:	a1 05       	cpc	r26, r1
    af64:	b1 05       	cpc	r27, r1
    af66:	09 f0       	breq	.+2      	; 0xaf6a <MenuUD+0xc8>
    af68:	1e c1       	rjmp	.+572    	; 0xb1a6 <MenuUD+0x304>
    af6a:	fe 01       	movw	r30, r28
    af6c:	37 96       	adiw	r30, 0x07	; 7
    af6e:	85 91       	lpm	r24, Z+
    af70:	95 91       	lpm	r25, Z+
    af72:	a5 91       	lpm	r26, Z+
    af74:	b4 91       	lpm	r27, Z+
    af76:	00 97       	sbiw	r24, 0x00	; 0
    af78:	a1 05       	cpc	r26, r1
    af7a:	b1 05       	cpc	r27, r1
    af7c:	09 f0       	breq	.+2      	; 0xaf80 <MenuUD+0xde>
    af7e:	13 c1       	rjmp	.+550    	; 0xb1a6 <MenuUD+0x304>
			if(Dir==1){	if(++MultiSymbol > 9) MultiSymbol = 0;}
    af80:	31 e0       	ldi	r19, 0x01	; 1
    af82:	e3 16       	cp	r14, r19
    af84:	09 f4       	brne	.+2      	; 0xaf88 <MenuUD+0xe6>
    af86:	92 c1       	rjmp	.+804    	; 0xb2ac <MenuUD+0x40a>
			else{		if(--MultiSymbol == 255) MultiSymbol = 9;}
    af88:	80 91 ec 04 	lds	r24, 0x04EC
    af8c:	81 50       	subi	r24, 0x01	; 1
    af8e:	80 93 ec 04 	sts	0x04EC, r24
    af92:	8f 3f       	cpi	r24, 0xFF	; 255
    af94:	09 f4       	brne	.+2      	; 0xaf98 <MenuUD+0xf6>
    af96:	93 c1       	rjmp	.+806    	; 0xb2be <MenuUD+0x41c>
		}
		else{
			if(Dir==1){	if(++MultiSymbol >= strlen_P(Symbols_P)) MultiSymbol = 0;}
			else{		if(--MultiSymbol == 255) MultiSymbol = strlen_P(Symbols_P)-1;}
		}
		if(CurrPos!=NullPos)
    af98:	90 91 d4 02 	lds	r25, 0x02D4
    af9c:	9f 3f       	cpi	r25, 0xFF	; 255
    af9e:	09 f4       	brne	.+2      	; 0xafa2 <MenuUD+0x100>
    afa0:	94 cf       	rjmp	.-216    	; 0xaeca <MenuUD+0x28>

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    afa2:	80 91 ec 04 	lds	r24, 0x04EC
    afa6:	e8 2f       	mov	r30, r24
    afa8:	f0 e0       	ldi	r31, 0x00	; 0
    afaa:	e8 50       	subi	r30, 0x08	; 8
    afac:	fa 4f       	sbci	r31, 0xFA	; 250
	case Longint: case z_Longint: case EE_Longint: case z_EE_Longint: case s_Longint: case s_EE_Longint:
	case FFloat: case EE_FFloat: case GFloat: case EE_GFloat:
		if(Dir==1)	{if(++MultiSymbol >= strlen_P(Digits_P)) MultiSymbol = 0;}
		else 		{if(--MultiSymbol == 255) MultiSymbol = strlen_P(Digits_P)-1;}
		if(CurrPos!=NullPos)
			BufStr[CurrFieldSize - 1 - CurrPos] = prc(Digits_P + MultiSymbol);
    afae:	84 91       	lpm	r24, Z+
    afb0:	e0 91 74 07 	lds	r30, 0x0774
    afb4:	f0 e0       	ldi	r31, 0x00	; 0
    afb6:	31 97       	sbiw	r30, 0x01	; 1
    afb8:	e9 1b       	sub	r30, r25
    afba:	f1 09       	sbc	r31, r1
    afbc:	e5 54       	subi	r30, 0x45	; 69
    afbe:	fa 4f       	sbci	r31, 0xFA	; 250
    afc0:	80 83       	st	Z, r24
    afc2:	83 cf       	rjmp	.-250    	; 0xaeca <MenuUD+0x28>
	case Enum: case EE_Enum:
		if(LimVar)
			F_Buf += Dir;
		break;
	case Bit: case EE_Bit:
		F_Buf = !F_Buf;
    afc4:	20 e0       	ldi	r18, 0x00	; 0
    afc6:	30 e0       	ldi	r19, 0x00	; 0
    afc8:	40 e0       	ldi	r20, 0x00	; 0
    afca:	50 e0       	ldi	r21, 0x00	; 0
    afcc:	80 91 ef 04 	lds	r24, 0x04EF
    afd0:	90 91 f0 04 	lds	r25, 0x04F0
    afd4:	a0 91 f1 04 	lds	r26, 0x04F1
    afd8:	b0 91 f2 04 	lds	r27, 0x04F2
    afdc:	00 97       	sbiw	r24, 0x00	; 0
    afde:	a1 05       	cpc	r26, r1
    afe0:	b1 05       	cpc	r27, r1
    afe2:	21 f4       	brne	.+8      	; 0xafec <MenuUD+0x14a>
    afe4:	21 e0       	ldi	r18, 0x01	; 1
    afe6:	30 e0       	ldi	r19, 0x00	; 0
    afe8:	40 e0       	ldi	r20, 0x00	; 0
    afea:	50 e0       	ldi	r21, 0x00	; 0
    afec:	20 93 ef 04 	sts	0x04EF, r18
    aff0:	30 93 f0 04 	sts	0x04F0, r19
    aff4:	40 93 f1 04 	sts	0x04F1, r20
    aff8:	50 93 f2 04 	sts	0x04F2, r21
    affc:	66 cf       	rjmp	.-308    	; 0xaeca <MenuUD+0x28>
			Buf2Field(Field);
			Field2Buf(Field);
		}
		break;
	case Enum: case EE_Enum:
		if(LimVar)
    affe:	00 23       	and	r16, r16
    b000:	09 f4       	brne	.+2      	; 0xb004 <MenuUD+0x162>
    b002:	63 cf       	rjmp	.-314    	; 0xaeca <MenuUD+0x28>
			F_Buf += Dir;
    b004:	2e 2d       	mov	r18, r14
    b006:	33 27       	eor	r19, r19
    b008:	27 fd       	sbrc	r18, 7
    b00a:	30 95       	com	r19
    b00c:	43 2f       	mov	r20, r19
    b00e:	53 2f       	mov	r21, r19
    b010:	80 91 ef 04 	lds	r24, 0x04EF
    b014:	90 91 f0 04 	lds	r25, 0x04F0
    b018:	a0 91 f1 04 	lds	r26, 0x04F1
    b01c:	b0 91 f2 04 	lds	r27, 0x04F2
    b020:	82 0f       	add	r24, r18
    b022:	93 1f       	adc	r25, r19
    b024:	a4 1f       	adc	r26, r20
    b026:	b5 1f       	adc	r27, r21
    b028:	80 93 ef 04 	sts	0x04EF, r24
    b02c:	90 93 f0 04 	sts	0x04F0, r25
    b030:	a0 93 f1 04 	sts	0x04F1, r26
    b034:	b0 93 f2 04 	sts	0x04F2, r27
    b038:	48 cf       	rjmp	.-368    	; 0xaeca <MenuUD+0x28>
		if(CurrPos!=NullPos)
			BufStr[CurrFieldSize - 1 - CurrPos] = prc(Symbols_P + MultiSymbol);
		break;
	case Longint: case z_Longint: case EE_Longint: case z_EE_Longint: case s_Longint: case s_EE_Longint:
	case FFloat: case EE_FFloat: case GFloat: case EE_GFloat:
		if(Dir==1)	{if(++MultiSymbol >= strlen_P(Digits_P)) MultiSymbol = 0;}
    b03a:	51 e0       	ldi	r21, 0x01	; 1
    b03c:	e5 16       	cp	r14, r21
    b03e:	09 f4       	brne	.+2      	; 0xb042 <MenuUD+0x1a0>
    b040:	fb c0       	rjmp	.+502    	; 0xb238 <MenuUD+0x396>
		else 		{if(--MultiSymbol == 255) MultiSymbol = strlen_P(Digits_P)-1;}
    b042:	80 91 ec 04 	lds	r24, 0x04EC
    b046:	81 50       	subi	r24, 0x01	; 1
    b048:	80 93 ec 04 	sts	0x04EC, r24
    b04c:	8f 3f       	cpi	r24, 0xFF	; 255
    b04e:	09 f4       	brne	.+2      	; 0xb052 <MenuUD+0x1b0>
    b050:	14 c1       	rjmp	.+552    	; 0xb27a <MenuUD+0x3d8>
		if(CurrPos!=NullPos)
    b052:	90 91 d4 02 	lds	r25, 0x02D4
    b056:	9f 3f       	cpi	r25, 0xFF	; 255
    b058:	09 f4       	brne	.+2      	; 0xb05c <MenuUD+0x1ba>
    b05a:	37 cf       	rjmp	.-402    	; 0xaeca <MenuUD+0x28>
    b05c:	80 91 ec 04 	lds	r24, 0x04EC
    b060:	e8 2f       	mov	r30, r24
    b062:	f0 e0       	ldi	r31, 0x00	; 0
    b064:	ef 55       	subi	r30, 0x5F	; 95
    b066:	f9 4f       	sbci	r31, 0xF9	; 249
    b068:	a2 cf       	rjmp	.-188    	; 0xafae <MenuUD+0x10c>
			sF_Buf += Inc(Dir, sF_Buf);
		else if(sF_Buf<0 || sF_Buf==0 && Minus)
			Minus = (sF_Buf-=Inc(Dir, -sF_Buf))==0;
		break;
	case c_Word: case zc_Word:
		if(LimVar) {
    b06a:	00 23       	and	r16, r16
    b06c:	09 f4       	brne	.+2      	; 0xb070 <MenuUD+0x1ce>
    b06e:	2d cf       	rjmp	.-422    	; 0xaeca <MenuUD+0x28>
			F_Buf += Dir;
    b070:	2e 2d       	mov	r18, r14
    b072:	33 27       	eor	r19, r19
    b074:	27 fd       	sbrc	r18, 7
    b076:	30 95       	com	r19
    b078:	43 2f       	mov	r20, r19
    b07a:	53 2f       	mov	r21, r19
    b07c:	80 91 ef 04 	lds	r24, 0x04EF
    b080:	90 91 f0 04 	lds	r25, 0x04F0
    b084:	a0 91 f1 04 	lds	r26, 0x04F1
    b088:	b0 91 f2 04 	lds	r27, 0x04F2
    b08c:	82 0f       	add	r24, r18
    b08e:	93 1f       	adc	r25, r19
    b090:	a4 1f       	adc	r26, r20
    b092:	b5 1f       	adc	r27, r21
    b094:	80 93 ef 04 	sts	0x04EF, r24
    b098:	90 93 f0 04 	sts	0x04F0, r25
    b09c:	a0 93 f1 04 	sts	0x04F1, r26
    b0a0:	b0 93 f2 04 	sts	0x04F2, r27
			Buf2Field(Field);
    b0a4:	ce 01       	movw	r24, r28
    b0a6:	0e 94 b5 52 	call	0xa56a	; 0xa56a <Buf2Field>
			Field2Buf(Field);
    b0aa:	ce 01       	movw	r24, r28
    b0ac:	0e 94 fd 4e 	call	0x9dfa	; 0x9dfa <Field2Buf>
    b0b0:	0c cf       	rjmp	.-488    	; 0xaeca <MenuUD+0x28>
	case Word: case EE_Word: case z_Word: case z_EE_Word:
		F_Buf += Inc(Dir, F_Buf);
		break;
	case s_Byte: case s_EE_Byte:
	case s_Word: case s_EE_Word:
		if(CurrPos==Log10(prd(&Field->Max))+1) {
    b0b2:	00 91 d4 02 	lds	r16, 0x02D4
    b0b6:	10 e0       	ldi	r17, 0x00	; 0

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    b0b8:	fe 01       	movw	r30, r28
    b0ba:	37 96       	adiw	r30, 0x07	; 7
    b0bc:	65 91       	lpm	r22, Z+
    b0be:	75 91       	lpm	r23, Z+
    b0c0:	85 91       	lpm	r24, Z+
    b0c2:	94 91       	lpm	r25, Z+
    b0c4:	0e 94 0b 20 	call	0x4016	; 0x4016 <Log10>
    b0c8:	90 e0       	ldi	r25, 0x00	; 0
    b0ca:	01 96       	adiw	r24, 0x01	; 1
    b0cc:	08 17       	cp	r16, r24
    b0ce:	19 07       	cpc	r17, r25
    b0d0:	09 f4       	brne	.+2      	; 0xb0d4 <MenuUD+0x232>
    b0d2:	9c c0       	rjmp	.+312    	; 0xb20c <MenuUD+0x36a>
			if(sF_Buf==0)
				Minus = !Minus;
			else
				sF_Buf = -sF_Buf;
		}
		else if(sF_Buf>0 || sF_Buf==0 && !Minus)
    b0d4:	a0 90 f3 04 	lds	r10, 0x04F3
    b0d8:	b0 90 f4 04 	lds	r11, 0x04F4
    b0dc:	c0 90 f5 04 	lds	r12, 0x04F5
    b0e0:	d0 90 f6 04 	lds	r13, 0x04F6
    b0e4:	1a 14       	cp	r1, r10
    b0e6:	1b 04       	cpc	r1, r11
    b0e8:	1c 04       	cpc	r1, r12
    b0ea:	1d 04       	cpc	r1, r13
    b0ec:	0c f4       	brge	.+2      	; 0xb0f0 <MenuUD+0x24e>
    b0ee:	74 c0       	rjmp	.+232    	; 0xb1d8 <MenuUD+0x336>
    b0f0:	a1 14       	cp	r10, r1
    b0f2:	b1 04       	cpc	r11, r1
    b0f4:	c1 04       	cpc	r12, r1
    b0f6:	d1 04       	cpc	r13, r1
    b0f8:	09 f4       	brne	.+2      	; 0xb0fc <MenuUD+0x25a>
    b0fa:	69 c0       	rjmp	.+210    	; 0xb1ce <MenuUD+0x32c>
			sF_Buf += Inc(Dir, sF_Buf);
		else if(sF_Buf<0 || sF_Buf==0 && Minus)
			Minus = (sF_Buf-=Inc(Dir, -sF_Buf))==0;
    b0fc:	44 27       	eor	r20, r20
    b0fe:	55 27       	eor	r21, r21
    b100:	ba 01       	movw	r22, r20
    b102:	4a 19       	sub	r20, r10
    b104:	5b 09       	sbc	r21, r11
    b106:	6c 09       	sbc	r22, r12
    b108:	7d 09       	sbc	r23, r13
    b10a:	8e 2d       	mov	r24, r14
    b10c:	0e 94 5a 3c 	call	0x78b4	; 0x78b4 <Inc>
    b110:	a6 01       	movw	r20, r12
    b112:	95 01       	movw	r18, r10
    b114:	26 1b       	sub	r18, r22
    b116:	37 0b       	sbc	r19, r23
    b118:	48 0b       	sbc	r20, r24
    b11a:	59 0b       	sbc	r21, r25
    b11c:	20 93 f3 04 	sts	0x04F3, r18
    b120:	30 93 f4 04 	sts	0x04F4, r19
    b124:	40 93 f5 04 	sts	0x04F5, r20
    b128:	50 93 f6 04 	sts	0x04F6, r21
    b12c:	10 92 f7 04 	sts	0x04F7, r1
    b130:	21 15       	cp	r18, r1
    b132:	31 05       	cpc	r19, r1
    b134:	41 05       	cpc	r20, r1
    b136:	51 05       	cpc	r21, r1
    b138:	09 f0       	breq	.+2      	; 0xb13c <MenuUD+0x29a>
    b13a:	c7 ce       	rjmp	.-626    	; 0xaeca <MenuUD+0x28>
    b13c:	81 e0       	ldi	r24, 0x01	; 1
    b13e:	80 93 f7 04 	sts	0x04F7, r24
    b142:	c3 ce       	rjmp	.-634    	; 0xaeca <MenuUD+0x28>
	Blink=0;
	OutField *Field=GetField;
	switch(prb(&Field->Type)) {
	case Byte: case EE_Byte: case z_Byte: case z_EE_Byte:
	case Word: case EE_Word: case z_Word: case z_EE_Word:
		F_Buf += Inc(Dir, F_Buf);
    b144:	40 91 ef 04 	lds	r20, 0x04EF
    b148:	50 91 f0 04 	lds	r21, 0x04F0
    b14c:	60 91 f1 04 	lds	r22, 0x04F1
    b150:	70 91 f2 04 	lds	r23, 0x04F2
    b154:	8e 2d       	mov	r24, r14
    b156:	0e 94 5a 3c 	call	0x78b4	; 0x78b4 <Inc>
    b15a:	20 91 ef 04 	lds	r18, 0x04EF
    b15e:	30 91 f0 04 	lds	r19, 0x04F0
    b162:	40 91 f1 04 	lds	r20, 0x04F1
    b166:	50 91 f2 04 	lds	r21, 0x04F2
    b16a:	26 0f       	add	r18, r22
    b16c:	37 1f       	adc	r19, r23
    b16e:	48 1f       	adc	r20, r24
    b170:	59 1f       	adc	r21, r25
    b172:	20 93 ef 04 	sts	0x04EF, r18
    b176:	30 93 f0 04 	sts	0x04F0, r19
    b17a:	40 93 f1 04 	sts	0x04F1, r20
    b17e:	50 93 f2 04 	sts	0x04F2, r21
    b182:	a3 ce       	rjmp	.-698    	; 0xaeca <MenuUD+0x28>
MenuUD(const MenuKey *Key, int8_t Dir, uint8_t LimLine, uint8_t LimLCD, uint8_t LimVar)
{
	if(CurrMsg || KeyFunc(Key))
		return;
	if(CurrField==NullPos) {
		if(LimLine) {
    b184:	11 23       	and	r17, r17
    b186:	09 f4       	brne	.+2      	; 0xb18a <MenuUD+0x2e8>
    b188:	a0 ce       	rjmp	.-704    	; 0xaeca <MenuUD+0x28>
			CurrLine -= Dir;
    b18a:	80 91 7d 07 	lds	r24, 0x077D
    b18e:	8e 19       	sub	r24, r14
    b190:	80 93 7d 07 	sts	0x077D, r24
			if(LimLCD)
    b194:	ff 20       	and	r15, r15
    b196:	09 f4       	brne	.+2      	; 0xb19a <MenuUD+0x2f8>
    b198:	98 ce       	rjmp	.-720    	; 0xaeca <MenuUD+0x28>
				CurrLCD -= Dir;
    b19a:	80 91 9a 08 	lds	r24, 0x089A
    b19e:	8e 19       	sub	r24, r14
    b1a0:	80 93 9a 08 	sts	0x089A, r24
    b1a4:	92 ce       	rjmp	.-732    	; 0xaeca <MenuUD+0x28>
		if( (prd(&Field->Min) == DIGIT) && (prd(&Field->Max) == DIGIT) ){
			if(Dir==1){	if(++MultiSymbol > 9) MultiSymbol = 0;}
			else{		if(--MultiSymbol == 255) MultiSymbol = 9;}
		}
		else{
			if(Dir==1){	if(++MultiSymbol >= strlen_P(Symbols_P)) MultiSymbol = 0;}
    b1a6:	41 e0       	ldi	r20, 0x01	; 1
    b1a8:	e4 16       	cp	r14, r20
    b1aa:	09 f4       	brne	.+2      	; 0xb1ae <MenuUD+0x30c>
    b1ac:	6e c0       	rjmp	.+220    	; 0xb28a <MenuUD+0x3e8>
			else{		if(--MultiSymbol == 255) MultiSymbol = strlen_P(Symbols_P)-1;}
    b1ae:	80 91 ec 04 	lds	r24, 0x04EC
    b1b2:	81 50       	subi	r24, 0x01	; 1
    b1b4:	80 93 ec 04 	sts	0x04EC, r24
    b1b8:	8f 3f       	cpi	r24, 0xFF	; 255
    b1ba:	09 f0       	breq	.+2      	; 0xb1be <MenuUD+0x31c>
    b1bc:	ed ce       	rjmp	.-550    	; 0xaf98 <MenuUD+0xf6>
    b1be:	88 ef       	ldi	r24, 0xF8	; 248
    b1c0:	95 e0       	ldi	r25, 0x05	; 5
    b1c2:	0e 94 8a 7a 	call	0xf514	; 0xf514 <strlen_P>
    b1c6:	81 50       	subi	r24, 0x01	; 1
    b1c8:	80 93 ec 04 	sts	0x04EC, r24
    b1cc:	e5 ce       	rjmp	.-566    	; 0xaf98 <MenuUD+0xf6>
			if(sF_Buf==0)
				Minus = !Minus;
			else
				sF_Buf = -sF_Buf;
		}
		else if(sF_Buf>0 || sF_Buf==0 && !Minus)
    b1ce:	80 91 f7 04 	lds	r24, 0x04F7
    b1d2:	88 23       	and	r24, r24
    b1d4:	09 f0       	breq	.+2      	; 0xb1d8 <MenuUD+0x336>
    b1d6:	92 cf       	rjmp	.-220    	; 0xb0fc <MenuUD+0x25a>
			sF_Buf += Inc(Dir, sF_Buf);
    b1d8:	8e 2d       	mov	r24, r14
    b1da:	b6 01       	movw	r22, r12
    b1dc:	a5 01       	movw	r20, r10
    b1de:	0e 94 5a 3c 	call	0x78b4	; 0x78b4 <Inc>
    b1e2:	20 91 f3 04 	lds	r18, 0x04F3
    b1e6:	30 91 f4 04 	lds	r19, 0x04F4
    b1ea:	40 91 f5 04 	lds	r20, 0x04F5
    b1ee:	50 91 f6 04 	lds	r21, 0x04F6
    b1f2:	26 0f       	add	r18, r22
    b1f4:	37 1f       	adc	r19, r23
    b1f6:	48 1f       	adc	r20, r24
    b1f8:	59 1f       	adc	r21, r25
    b1fa:	20 93 f3 04 	sts	0x04F3, r18
    b1fe:	30 93 f4 04 	sts	0x04F4, r19
    b202:	40 93 f5 04 	sts	0x04F5, r20
    b206:	50 93 f6 04 	sts	0x04F6, r21
    b20a:	5f ce       	rjmp	.-834    	; 0xaeca <MenuUD+0x28>
		F_Buf += Inc(Dir, F_Buf);
		break;
	case s_Byte: case s_EE_Byte:
	case s_Word: case s_EE_Word:
		if(CurrPos==Log10(prd(&Field->Max))+1) {
			if(sF_Buf==0)
    b20c:	20 91 f3 04 	lds	r18, 0x04F3
    b210:	30 91 f4 04 	lds	r19, 0x04F4
    b214:	40 91 f5 04 	lds	r20, 0x04F5
    b218:	50 91 f6 04 	lds	r21, 0x04F6
    b21c:	21 15       	cp	r18, r1
    b21e:	31 05       	cpc	r19, r1
    b220:	41 05       	cpc	r20, r1
    b222:	51 05       	cpc	r21, r1
    b224:	d1 f4       	brne	.+52     	; 0xb25a <MenuUD+0x3b8>
				Minus = !Minus;
    b226:	90 e0       	ldi	r25, 0x00	; 0
    b228:	80 91 f7 04 	lds	r24, 0x04F7
    b22c:	88 23       	and	r24, r24
    b22e:	09 f4       	brne	.+2      	; 0xb232 <MenuUD+0x390>
    b230:	91 e0       	ldi	r25, 0x01	; 1
    b232:	90 93 f7 04 	sts	0x04F7, r25
    b236:	49 ce       	rjmp	.-878    	; 0xaeca <MenuUD+0x28>
		if(CurrPos!=NullPos)
			BufStr[CurrFieldSize - 1 - CurrPos] = prc(Symbols_P + MultiSymbol);
		break;
	case Longint: case z_Longint: case EE_Longint: case z_EE_Longint: case s_Longint: case s_EE_Longint:
	case FFloat: case EE_FFloat: case GFloat: case EE_GFloat:
		if(Dir==1)	{if(++MultiSymbol >= strlen_P(Digits_P)) MultiSymbol = 0;}
    b238:	00 91 ec 04 	lds	r16, 0x04EC
    b23c:	0f 5f       	subi	r16, 0xFF	; 255
    b23e:	00 93 ec 04 	sts	0x04EC, r16
    b242:	81 ea       	ldi	r24, 0xA1	; 161
    b244:	96 e0       	ldi	r25, 0x06	; 6
    b246:	0e 94 8a 7a 	call	0xf514	; 0xf514 <strlen_P>
    b24a:	10 e0       	ldi	r17, 0x00	; 0
    b24c:	08 17       	cp	r16, r24
    b24e:	19 07       	cpc	r17, r25
    b250:	08 f4       	brcc	.+2      	; 0xb254 <MenuUD+0x3b2>
    b252:	ff ce       	rjmp	.-514    	; 0xb052 <MenuUD+0x1b0>
    b254:	10 92 ec 04 	sts	0x04EC, r1
    b258:	fc ce       	rjmp	.-520    	; 0xb052 <MenuUD+0x1b0>
	case s_Word: case s_EE_Word:
		if(CurrPos==Log10(prd(&Field->Max))+1) {
			if(sF_Buf==0)
				Minus = !Minus;
			else
				sF_Buf = -sF_Buf;
    b25a:	88 27       	eor	r24, r24
    b25c:	99 27       	eor	r25, r25
    b25e:	dc 01       	movw	r26, r24
    b260:	82 1b       	sub	r24, r18
    b262:	93 0b       	sbc	r25, r19
    b264:	a4 0b       	sbc	r26, r20
    b266:	b5 0b       	sbc	r27, r21
    b268:	80 93 f3 04 	sts	0x04F3, r24
    b26c:	90 93 f4 04 	sts	0x04F4, r25
    b270:	a0 93 f5 04 	sts	0x04F5, r26
    b274:	b0 93 f6 04 	sts	0x04F6, r27
    b278:	28 ce       	rjmp	.-944    	; 0xaeca <MenuUD+0x28>
			BufStr[CurrFieldSize - 1 - CurrPos] = prc(Symbols_P + MultiSymbol);
		break;
	case Longint: case z_Longint: case EE_Longint: case z_EE_Longint: case s_Longint: case s_EE_Longint:
	case FFloat: case EE_FFloat: case GFloat: case EE_GFloat:
		if(Dir==1)	{if(++MultiSymbol >= strlen_P(Digits_P)) MultiSymbol = 0;}
		else 		{if(--MultiSymbol == 255) MultiSymbol = strlen_P(Digits_P)-1;}
    b27a:	81 ea       	ldi	r24, 0xA1	; 161
    b27c:	96 e0       	ldi	r25, 0x06	; 6
    b27e:	0e 94 8a 7a 	call	0xf514	; 0xf514 <strlen_P>
    b282:	81 50       	subi	r24, 0x01	; 1
    b284:	80 93 ec 04 	sts	0x04EC, r24
    b288:	e4 ce       	rjmp	.-568    	; 0xb052 <MenuUD+0x1b0>
		if( (prd(&Field->Min) == DIGIT) && (prd(&Field->Max) == DIGIT) ){
			if(Dir==1){	if(++MultiSymbol > 9) MultiSymbol = 0;}
			else{		if(--MultiSymbol == 255) MultiSymbol = 9;}
		}
		else{
			if(Dir==1){	if(++MultiSymbol >= strlen_P(Symbols_P)) MultiSymbol = 0;}
    b28a:	00 91 ec 04 	lds	r16, 0x04EC
    b28e:	0f 5f       	subi	r16, 0xFF	; 255
    b290:	00 93 ec 04 	sts	0x04EC, r16
    b294:	88 ef       	ldi	r24, 0xF8	; 248
    b296:	95 e0       	ldi	r25, 0x05	; 5
    b298:	0e 94 8a 7a 	call	0xf514	; 0xf514 <strlen_P>
    b29c:	10 e0       	ldi	r17, 0x00	; 0
    b29e:	08 17       	cp	r16, r24
    b2a0:	19 07       	cpc	r17, r25
    b2a2:	08 f4       	brcc	.+2      	; 0xb2a6 <MenuUD+0x404>
    b2a4:	79 ce       	rjmp	.-782    	; 0xaf98 <MenuUD+0xf6>
    b2a6:	10 92 ec 04 	sts	0x04EC, r1
    b2aa:	76 ce       	rjmp	.-788    	; 0xaf98 <MenuUD+0xf6>
	case Bit: case EE_Bit:
		F_Buf = !F_Buf;
		break;
	case Text: case EE_Text:
		if( (prd(&Field->Min) == DIGIT) && (prd(&Field->Max) == DIGIT) ){
			if(Dir==1){	if(++MultiSymbol > 9) MultiSymbol = 0;}
    b2ac:	80 91 ec 04 	lds	r24, 0x04EC
    b2b0:	8f 5f       	subi	r24, 0xFF	; 255
    b2b2:	80 93 ec 04 	sts	0x04EC, r24
    b2b6:	8a 30       	cpi	r24, 0x0A	; 10
    b2b8:	08 f4       	brcc	.+2      	; 0xb2bc <MenuUD+0x41a>
    b2ba:	6e ce       	rjmp	.-804    	; 0xaf98 <MenuUD+0xf6>
    b2bc:	f4 cf       	rjmp	.-24     	; 0xb2a6 <MenuUD+0x404>
			else{		if(--MultiSymbol == 255) MultiSymbol = 9;}
    b2be:	89 e0       	ldi	r24, 0x09	; 9
    b2c0:	80 93 ec 04 	sts	0x04EC, r24
    b2c4:	69 ce       	rjmp	.-814    	; 0xaf98 <MenuUD+0xf6>

0000b2c6 <MenuDown>:
}

// ~~~~~~~~~~~
void
MenuDown(void)
{
    b2c6:	ef 92       	push	r14
    b2c8:	ff 92       	push	r15
    b2ca:	0f 93       	push	r16
    b2cc:	1f 93       	push	r17
    b2ce:	cf 93       	push	r28
    b2d0:	df 93       	push	r29
	MenuUD(&CurrPage->Down, -1, prb(&CurrPage->LineNumber)-CurrLine>1, CurrLCD<LCDYSz-1, F_Buf>prd(&GetField->Min));
    b2d2:	c0 91 d1 02 	lds	r28, 0x02D1
    b2d6:	d0 91 d2 02 	lds	r29, 0x02D2

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    b2da:	22 96       	adiw	r28, 0x02	; 2
    b2dc:	fe 01       	movw	r30, r28
    b2de:	24 91       	lpm	r18, Z+
    b2e0:	22 97       	sbiw	r28, 0x02	; 2
    b2e2:	40 91 7d 07 	lds	r20, 0x077D

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    b2e6:	fe 01       	movw	r30, r28
    b2e8:	65 91       	lpm	r22, Z+
    b2ea:	74 91       	lpm	r23, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    b2ec:	8b e1       	ldi	r24, 0x1B	; 27
    b2ee:	48 9f       	mul	r20, r24
    b2f0:	c0 01       	movw	r24, r0
    b2f2:	11 24       	eor	r1, r1
    b2f4:	68 0f       	add	r22, r24
    b2f6:	79 1f       	adc	r23, r25
    b2f8:	69 5e       	subi	r22, 0xE9	; 233
    b2fa:	7f 4f       	sbci	r23, 0xFF	; 255
    b2fc:	fb 01       	movw	r30, r22
    b2fe:	a5 91       	lpm	r26, Z+
    b300:	b4 91       	lpm	r27, Z+
    b302:	80 91 d3 02 	lds	r24, 0x02D3
    b306:	90 e0       	ldi	r25, 0x00	; 0
    b308:	82 95       	swap	r24
    b30a:	92 95       	swap	r25
    b30c:	90 7f       	andi	r25, 0xF0	; 240
    b30e:	98 27       	eor	r25, r24
    b310:	80 7f       	andi	r24, 0xF0	; 240
    b312:	98 27       	eor	r25, r24
    b314:	a8 0f       	add	r26, r24
    b316:	b9 1f       	adc	r27, r25
    b318:	13 96       	adiw	r26, 0x03	; 3
    b31a:	fd 01       	movw	r30, r26
    b31c:	e5 90       	lpm	r14, Z+
    b31e:	f5 90       	lpm	r15, Z+
    b320:	05 91       	lpm	r16, Z+
    b322:	14 91       	lpm	r17, Z+
    b324:	fe 01       	movw	r30, r28
    b326:	72 96       	adiw	r30, 0x12	; 18
    b328:	50 e0       	ldi	r21, 0x00	; 0
    b32a:	30 e0       	ldi	r19, 0x00	; 0
    b32c:	24 1b       	sub	r18, r20
    b32e:	31 09       	sbc	r19, r1
    b330:	22 30       	cpi	r18, 0x02	; 2
    b332:	31 05       	cpc	r19, r1
    b334:	0c f0       	brlt	.+2      	; 0xb338 <MenuDown+0x72>
    b336:	51 e0       	ldi	r21, 0x01	; 1
    b338:	20 e0       	ldi	r18, 0x00	; 0
    b33a:	80 91 9a 08 	lds	r24, 0x089A
    b33e:	83 30       	cpi	r24, 0x03	; 3
    b340:	08 f4       	brcc	.+2      	; 0xb344 <MenuDown+0x7e>
    b342:	21 e0       	ldi	r18, 0x01	; 1
    b344:	30 e0       	ldi	r19, 0x00	; 0
    b346:	80 91 ef 04 	lds	r24, 0x04EF
    b34a:	90 91 f0 04 	lds	r25, 0x04F0
    b34e:	a0 91 f1 04 	lds	r26, 0x04F1
    b352:	b0 91 f2 04 	lds	r27, 0x04F2
    b356:	e8 16       	cp	r14, r24
    b358:	f9 06       	cpc	r15, r25
    b35a:	0a 07       	cpc	r16, r26
    b35c:	1b 07       	cpc	r17, r27
    b35e:	08 f4       	brcc	.+2      	; 0xb362 <MenuDown+0x9c>
    b360:	31 e0       	ldi	r19, 0x01	; 1
    b362:	cf 01       	movw	r24, r30
    b364:	6f ef       	ldi	r22, 0xFF	; 255
    b366:	45 2f       	mov	r20, r21
    b368:	03 2f       	mov	r16, r19
    b36a:	0e 94 51 57 	call	0xaea2	; 0xaea2 <MenuUD>
}
    b36e:	df 91       	pop	r29
    b370:	cf 91       	pop	r28
    b372:	1f 91       	pop	r17
    b374:	0f 91       	pop	r16
    b376:	ff 90       	pop	r15
    b378:	ef 90       	pop	r14
    b37a:	08 95       	ret

0000b37c <MenuUp>:
}

// ~~~~~~~~~
void
MenuUp(void)
{
    b37c:	ef 92       	push	r14
    b37e:	ff 92       	push	r15
    b380:	0f 93       	push	r16
    b382:	1f 93       	push	r17
	uint8_t Fix=GetFix();
    b384:	a0 91 d1 02 	lds	r26, 0x02D1
    b388:	b0 91 d2 02 	lds	r27, 0x02D2

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    b38c:	13 96       	adiw	r26, 0x03	; 3
    b38e:	fd 01       	movw	r30, r26
    b390:	34 91       	lpm	r19, Z+
    b392:	13 97       	sbiw	r26, 0x03	; 3
	MenuUD(&CurrPage->Up, 1, CurrLine>Fix, CurrLCD>Fix, F_Buf<prd(&GetField->Max));
    b394:	20 91 7d 07 	lds	r18, 0x077D

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    b398:	fd 01       	movw	r30, r26
    b39a:	45 91       	lpm	r20, Z+
    b39c:	54 91       	lpm	r21, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    b39e:	8b e1       	ldi	r24, 0x1B	; 27
    b3a0:	28 9f       	mul	r18, r24
    b3a2:	c0 01       	movw	r24, r0
    b3a4:	11 24       	eor	r1, r1
    b3a6:	48 0f       	add	r20, r24
    b3a8:	59 1f       	adc	r21, r25
    b3aa:	49 5e       	subi	r20, 0xE9	; 233
    b3ac:	5f 4f       	sbci	r21, 0xFF	; 255
    b3ae:	fa 01       	movw	r30, r20
    b3b0:	65 91       	lpm	r22, Z+
    b3b2:	74 91       	lpm	r23, Z+
    b3b4:	80 91 d3 02 	lds	r24, 0x02D3
    b3b8:	90 e0       	ldi	r25, 0x00	; 0
    b3ba:	82 95       	swap	r24
    b3bc:	92 95       	swap	r25
    b3be:	90 7f       	andi	r25, 0xF0	; 240
    b3c0:	98 27       	eor	r25, r24
    b3c2:	80 7f       	andi	r24, 0xF0	; 240
    b3c4:	98 27       	eor	r25, r24
    b3c6:	68 0f       	add	r22, r24
    b3c8:	79 1f       	adc	r23, r25
    b3ca:	69 5f       	subi	r22, 0xF9	; 249
    b3cc:	7f 4f       	sbci	r23, 0xFF	; 255
    b3ce:	fb 01       	movw	r30, r22
    b3d0:	e5 90       	lpm	r14, Z+
    b3d2:	f5 90       	lpm	r15, Z+
    b3d4:	05 91       	lpm	r16, Z+
    b3d6:	14 91       	lpm	r17, Z+
    b3d8:	fd 01       	movw	r30, r26
    b3da:	70 96       	adiw	r30, 0x10	; 16
    b3dc:	40 e0       	ldi	r20, 0x00	; 0
    b3de:	32 17       	cp	r19, r18
    b3e0:	08 f4       	brcc	.+2      	; 0xb3e4 <MenuUp+0x68>
    b3e2:	41 e0       	ldi	r20, 0x01	; 1
    b3e4:	20 e0       	ldi	r18, 0x00	; 0
    b3e6:	80 91 9a 08 	lds	r24, 0x089A
    b3ea:	38 17       	cp	r19, r24
    b3ec:	08 f4       	brcc	.+2      	; 0xb3f0 <MenuUp+0x74>
    b3ee:	21 e0       	ldi	r18, 0x01	; 1
    b3f0:	30 e0       	ldi	r19, 0x00	; 0
    b3f2:	80 91 ef 04 	lds	r24, 0x04EF
    b3f6:	90 91 f0 04 	lds	r25, 0x04F0
    b3fa:	a0 91 f1 04 	lds	r26, 0x04F1
    b3fe:	b0 91 f2 04 	lds	r27, 0x04F2
    b402:	8e 15       	cp	r24, r14
    b404:	9f 05       	cpc	r25, r15
    b406:	a0 07       	cpc	r26, r16
    b408:	b1 07       	cpc	r27, r17
    b40a:	08 f4       	brcc	.+2      	; 0xb40e <MenuUp+0x92>
    b40c:	31 e0       	ldi	r19, 0x01	; 1
    b40e:	cf 01       	movw	r24, r30
    b410:	61 e0       	ldi	r22, 0x01	; 1
    b412:	03 2f       	mov	r16, r19
    b414:	0e 94 51 57 	call	0xaea2	; 0xaea2 <MenuUD>
}
    b418:	1f 91       	pop	r17
    b41a:	0f 91       	pop	r16
    b41c:	ff 90       	pop	r15
    b41e:	ef 90       	pop	r14
    b420:	08 95       	ret

0000b422 <PutField>:
	sprintf(Param->Pos, Format, Val);
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
PutField(uint8_t Type, void *Var, T_Param *Param)
{
    b422:	af 92       	push	r10
    b424:	bf 92       	push	r11
    b426:	cf 92       	push	r12
    b428:	df 92       	push	r13
    b42a:	ef 92       	push	r14
    b42c:	ff 92       	push	r15
    b42e:	0f 93       	push	r16
    b430:	1f 93       	push	r17
    b432:	df 93       	push	r29
    b434:	cf 93       	push	r28
    b436:	cd b7       	in	r28, 0x3d	; 61
    b438:	de b7       	in	r29, 0x3e	; 62
    b43a:	69 97       	sbiw	r28, 0x19	; 25
    b43c:	0f b6       	in	r0, 0x3f	; 63
    b43e:	f8 94       	cli
    b440:	de bf       	out	0x3e, r29	; 62
    b442:	0f be       	out	0x3f, r0	; 63
    b444:	cd bf       	out	0x3d, r28	; 61
    b446:	db 01       	movw	r26, r22
    b448:	7a 01       	movw	r14, r20
	float fTemp;

	switch(Type) {
    b44a:	e8 2f       	mov	r30, r24
    b44c:	f0 e0       	ldi	r31, 0x00	; 0
    b44e:	e3 32       	cpi	r30, 0x23	; 35
    b450:	f1 05       	cpc	r31, r1
    b452:	88 f5       	brcc	.+98     	; 0xb4b6 <PutField+0x94>
    b454:	e7 52       	subi	r30, 0x27	; 39
    b456:	ff 4f       	sbci	r31, 0xFF	; 255
    b458:	ee 0f       	add	r30, r30
    b45a:	ff 1f       	adc	r31, r31
    b45c:	05 90       	lpm	r0, Z+
    b45e:	f4 91       	lpm	r31, Z+
    b460:	e0 2d       	mov	r30, r0
    b462:	19 94       	eijmp
		break;
	case Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((*((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
		break;
	case EE_Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((erb((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
    b464:	fa 01       	movw	r30, r20
    b466:	a0 80       	ld	r10, Z
    b468:	b1 80       	ldd	r11, Z+1	; 0x01
    b46a:	c4 80       	ldd	r12, Z+4	; 0x04
    b46c:	d5 80       	ldd	r13, Z+5	; 0x05
    b46e:	12 81       	ldd	r17, Z+2	; 0x02
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    b470:	81 2f       	mov	r24, r17
    b472:	86 95       	lsr	r24
    b474:	86 95       	lsr	r24
    b476:	86 95       	lsr	r24
    b478:	9b 01       	movw	r18, r22
    b47a:	28 0f       	add	r18, r24
    b47c:	31 1d       	adc	r19, r1
    b47e:	c9 01       	movw	r24, r18
    b480:	0e 94 a4 7d 	call	0xfb48	; 0xfb48 <__eerd_byte_m2560>
    b484:	17 70       	andi	r17, 0x07	; 7
    b486:	21 e0       	ldi	r18, 0x01	; 1
    b488:	30 e0       	ldi	r19, 0x00	; 0
    b48a:	02 c0       	rjmp	.+4      	; 0xb490 <PutField+0x6e>
    b48c:	22 0f       	add	r18, r18
    b48e:	33 1f       	adc	r19, r19
    b490:	1a 95       	dec	r17
    b492:	e2 f7       	brpl	.-8      	; 0xb48c <PutField+0x6a>
    b494:	90 e0       	ldi	r25, 0x00	; 0
    b496:	28 23       	and	r18, r24
    b498:	39 23       	and	r19, r25
    b49a:	12 16       	cp	r1, r18
    b49c:	13 06       	cpc	r1, r19
    b49e:	0c f0       	brlt	.+2      	; 0xb4a2 <PutField+0x80>
    b4a0:	3f c1       	rjmp	.+638    	; 0xb720 <PutField+0x2fe>
    b4a2:	82 e0       	ldi	r24, 0x02	; 2
    b4a4:	90 e0       	ldi	r25, 0x00	; 0

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    b4a6:	f6 01       	movw	r30, r12
    b4a8:	e8 0f       	add	r30, r24
    b4aa:	f9 1f       	adc	r31, r25
    b4ac:	65 91       	lpm	r22, Z+
    b4ae:	74 91       	lpm	r23, Z+
    b4b0:	c5 01       	movw	r24, r10
    b4b2:	0e 94 83 7a 	call	0xf506	; 0xf506 <strcpy_P>
			erbl(TempStr, Var, Param->Size);
			Put_TextValAlignRight(TempStr, Param);
		}
		break;
	}
}
    b4b6:	69 96       	adiw	r28, 0x19	; 25
    b4b8:	0f b6       	in	r0, 0x3f	; 63
    b4ba:	f8 94       	cli
    b4bc:	de bf       	out	0x3e, r29	; 62
    b4be:	0f be       	out	0x3f, r0	; 63
    b4c0:	cd bf       	out	0x3d, r28	; 61
    b4c2:	cf 91       	pop	r28
    b4c4:	df 91       	pop	r29
    b4c6:	1f 91       	pop	r17
    b4c8:	0f 91       	pop	r16
    b4ca:	ff 90       	pop	r15
    b4cc:	ef 90       	pop	r14
    b4ce:	df 90       	pop	r13
    b4d0:	cf 90       	pop	r12
    b4d2:	bf 90       	pop	r11
    b4d4:	af 90       	pop	r10
    b4d6:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    b4d8:	8e 01       	movw	r16, r28
    b4da:	0b 5f       	subi	r16, 0xFB	; 251
    b4dc:	1f 4f       	sbci	r17, 0xFF	; 255
    b4de:	fa 01       	movw	r30, r20
    b4e0:	43 81       	ldd	r20, Z+3	; 0x03
    b4e2:	c8 01       	movw	r24, r16
    b4e4:	50 e0       	ldi	r21, 0x00	; 0
    b4e6:	0e 94 94 7d 	call	0xfb28	; 0xfb28 <__eerd_block_m2560>
		Put_TextValAlignRight(Var, Param);
		break;
	case EE_Text:{
			char TempStr[LCDXSz+1];
			erbl(TempStr, Var, Param->Size);
			Put_TextValAlignRight(TempStr, Param);
    b4ea:	c8 01       	movw	r24, r16
    b4ec:	b7 01       	movw	r22, r14
    b4ee:	0e 94 44 42 	call	0x8488	; 0x8488 <Put_TextValAlignRight>
    b4f2:	e1 cf       	rjmp	.-62     	; 0xb4b6 <PutField+0x94>
	case EE_Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((erb((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
		break;

	case Text:
		Put_TextValAlignRight(Var, Param);
    b4f4:	cb 01       	movw	r24, r22
    b4f6:	ba 01       	movw	r22, r20
    b4f8:	0e 94 44 42 	call	0x8488	; 0x8488 <Put_TextValAlignRight>
    b4fc:	dc cf       	rjmp	.-72     	; 0xb4b6 <PutField+0x94>
	case EE_Enum:
		Param->Txt += erb((uint8_t*)Var);
		PutEnum(Param);
		break;
	case Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((*((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
    b4fe:	fa 01       	movw	r30, r20
    b500:	00 81       	ld	r16, Z
    b502:	11 81       	ldd	r17, Z+1	; 0x01
    b504:	64 81       	ldd	r22, Z+4	; 0x04
    b506:	75 81       	ldd	r23, Z+5	; 0x05
    b508:	42 81       	ldd	r20, Z+2	; 0x02
    b50a:	84 2f       	mov	r24, r20
    b50c:	86 95       	lsr	r24
    b50e:	86 95       	lsr	r24
    b510:	86 95       	lsr	r24
    b512:	a8 0f       	add	r26, r24
    b514:	b1 1d       	adc	r27, r1
    b516:	2c 91       	ld	r18, X
    b518:	30 e0       	ldi	r19, 0x00	; 0
    b51a:	47 70       	andi	r20, 0x07	; 7
    b51c:	81 e0       	ldi	r24, 0x01	; 1
    b51e:	90 e0       	ldi	r25, 0x00	; 0
    b520:	02 c0       	rjmp	.+4      	; 0xb526 <PutField+0x104>
    b522:	88 0f       	add	r24, r24
    b524:	99 1f       	adc	r25, r25
    b526:	4a 95       	dec	r20
    b528:	e2 f7       	brpl	.-8      	; 0xb522 <PutField+0x100>
    b52a:	28 23       	and	r18, r24
    b52c:	39 23       	and	r19, r25
    b52e:	12 16       	cp	r1, r18
    b530:	13 06       	cpc	r1, r19
    b532:	0c f0       	brlt	.+2      	; 0xb536 <PutField+0x114>
    b534:	f8 c0       	rjmp	.+496    	; 0xb726 <PutField+0x304>
    b536:	82 e0       	ldi	r24, 0x02	; 2
    b538:	90 e0       	ldi	r25, 0x00	; 0

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    b53a:	fb 01       	movw	r30, r22
    b53c:	e8 0f       	add	r30, r24
    b53e:	f9 1f       	adc	r31, r25
    b540:	65 91       	lpm	r22, Z+
    b542:	74 91       	lpm	r23, Z+
    b544:	c8 01       	movw	r24, r16
    b546:	0e 94 83 7a 	call	0xf506	; 0xf506 <strcpy_P>
    b54a:	b5 cf       	rjmp	.-150    	; 0xb4b6 <PutField+0x94>
		Put_GFVal(fTemp, Param);
		break;


	case Enum:
		Param->Txt += *(uint8_t*)Var;
    b54c:	2c 91       	ld	r18, X
    b54e:	30 e0       	ldi	r19, 0x00	; 0
    b550:	22 0f       	add	r18, r18
    b552:	33 1f       	adc	r19, r19
    b554:	f7 01       	movw	r30, r14
    b556:	84 81       	ldd	r24, Z+4	; 0x04
    b558:	95 81       	ldd	r25, Z+5	; 0x05
    b55a:	82 0f       	add	r24, r18
    b55c:	93 1f       	adc	r25, r19
    b55e:	95 83       	std	Z+5, r25	; 0x05
    b560:	84 83       	std	Z+4, r24	; 0x04
		PutEnum(Param);
    b562:	c7 01       	movw	r24, r14
    b564:	0e 94 f0 3f 	call	0x7fe0	; 0x7fe0 <PutEnum>
    b568:	a6 cf       	rjmp	.-180    	; 0xb4b6 <PutField+0x94>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    b56a:	cb 01       	movw	r24, r22
    b56c:	0e 94 a4 7d 	call	0xfb48	; 0xfb48 <__eerd_byte_m2560>
		break;
	case EE_Enum:
		Param->Txt += erb((uint8_t*)Var);
    b570:	90 e0       	ldi	r25, 0x00	; 0
    b572:	88 0f       	add	r24, r24
    b574:	99 1f       	adc	r25, r25
    b576:	f7 01       	movw	r30, r14
    b578:	24 81       	ldd	r18, Z+4	; 0x04
    b57a:	35 81       	ldd	r19, Z+5	; 0x05
    b57c:	28 0f       	add	r18, r24
    b57e:	39 1f       	adc	r19, r25
    b580:	35 83       	std	Z+5, r19	; 0x05
    b582:	24 83       	std	Z+4, r18	; 0x04
		PutEnum(Param);
    b584:	c7 01       	movw	r24, r14
    b586:	0e 94 f0 3f 	call	0x7fe0	; 0x7fe0 <PutEnum>
    b58a:	95 cf       	rjmp	.-214    	; 0xb4b6 <PutField+0x94>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    b58c:	ce 01       	movw	r24, r28
    b58e:	01 96       	adiw	r24, 0x01	; 1
    b590:	44 e0       	ldi	r20, 0x04	; 4
    b592:	50 e0       	ldi	r21, 0x00	; 0
    b594:	0e 94 94 7d 	call	0xfb28	; 0xfb28 <__eerd_block_m2560>
	case GFloat:
		Put_GFVal(*(float*)Var, Param);
		break;			
	case EE_GFloat:
		erbl(&fTemp, Var, 4);
		Put_GFVal(fTemp, Param);
    b598:	69 81       	ldd	r22, Y+1	; 0x01
    b59a:	7a 81       	ldd	r23, Y+2	; 0x02
    b59c:	8b 81       	ldd	r24, Y+3	; 0x03
    b59e:	9c 81       	ldd	r25, Y+4	; 0x04
    b5a0:	a7 01       	movw	r20, r14
    b5a2:	0e 94 a0 42 	call	0x8540	; 0x8540 <Put_GFVal>
    b5a6:	87 cf       	rjmp	.-242    	; 0xb4b6 <PutField+0x94>
	case EE_FFloat:
		erbl(&fTemp, Var, 4);
		Put_FFVal(fTemp, Param);
		break;
	case GFloat:
		Put_GFVal(*(float*)Var, Param);
    b5a8:	6d 91       	ld	r22, X+
    b5aa:	7d 91       	ld	r23, X+
    b5ac:	8d 91       	ld	r24, X+
    b5ae:	9c 91       	ld	r25, X
    b5b0:	0e 94 a0 42 	call	0x8540	; 0x8540 <Put_GFVal>
    b5b4:	80 cf       	rjmp	.-256    	; 0xb4b6 <PutField+0x94>
    b5b6:	ce 01       	movw	r24, r28
    b5b8:	01 96       	adiw	r24, 0x01	; 1
    b5ba:	44 e0       	ldi	r20, 0x04	; 4
    b5bc:	50 e0       	ldi	r21, 0x00	; 0
    b5be:	0e 94 94 7d 	call	0xfb28	; 0xfb28 <__eerd_block_m2560>
	case FFloat:
		Put_FFVal(*(float*)Var, Param);
		break;			
	case EE_FFloat:
		erbl(&fTemp, Var, 4);
		Put_FFVal(fTemp, Param);
    b5c2:	69 81       	ldd	r22, Y+1	; 0x01
    b5c4:	7a 81       	ldd	r23, Y+2	; 0x02
    b5c6:	8b 81       	ldd	r24, Y+3	; 0x03
    b5c8:	9c 81       	ldd	r25, Y+4	; 0x04
    b5ca:	a7 01       	movw	r20, r14
    b5cc:	0e 94 1a 43 	call	0x8634	; 0x8634 <Put_FFVal>
    b5d0:	72 cf       	rjmp	.-284    	; 0xb4b6 <PutField+0x94>
		Put_zDVal(erd((uint32_t*)Var), Param);
		break;

		
	case FFloat:
		Put_FFVal(*(float*)Var, Param);
    b5d2:	6d 91       	ld	r22, X+
    b5d4:	7d 91       	ld	r23, X+
    b5d6:	8d 91       	ld	r24, X+
    b5d8:	9c 91       	ld	r25, X
    b5da:	0e 94 1a 43 	call	0x8634	; 0x8634 <Put_FFVal>
    b5de:	6b cf       	rjmp	.-298    	; 0xb4b6 <PutField+0x94>
		break;
	case zh_Word:
		Put_zVal_h(*(uint16_t*)Var, 'w', Param);
		break;
	case zh_Longint:
		Put_zVal_h(*(uint32_t*)Var, 'l', Param);
    b5e0:	6d 91       	ld	r22, X+
    b5e2:	7d 91       	ld	r23, X+
    b5e4:	8d 91       	ld	r24, X+
    b5e6:	9c 91       	ld	r25, X
    b5e8:	4c e6       	ldi	r20, 0x6C	; 108
    b5ea:	97 01       	movw	r18, r14
    b5ec:	0e 94 da 46 	call	0x8db4	; 0x8db4 <Put_zVal_h>
    b5f0:	62 cf       	rjmp	.-316    	; 0xb4b6 <PutField+0x94>
// ~~~~~~~~~~~~~~~~~~~~~~
uint32_t
erd(const uint32_t *addr)
{
	//IntOff();
	uint32_t word = eeprom_read_dword(addr);
    b5f2:	cb 01       	movw	r24, r22
    b5f4:	0e 94 ac 7d 	call	0xfb58	; 0xfb58 <__eerd_dword_m2560>
		break;
	case z_Longint: case zc_Longint:
		Put_zDVal(*(uint32_t*)Var, Param);
		break;
	case z_EE_Longint:
		Put_zDVal(erd((uint32_t*)Var), Param);
    b5f8:	a7 01       	movw	r20, r14
    b5fa:	0e 94 6f 43 	call	0x86de	; 0x86de <Put_zDVal>
    b5fe:	5b cf       	rjmp	.-330    	; 0xb4b6 <PutField+0x94>
		break;
	case s_EE_Longint:
		Put_sDVal((int32_t)erd((uint32_t*)Var), Param);
		break;
	case z_Longint: case zc_Longint:
		Put_zDVal(*(uint32_t*)Var, Param);
    b600:	6d 91       	ld	r22, X+
    b602:	7d 91       	ld	r23, X+
    b604:	8d 91       	ld	r24, X+
    b606:	9c 91       	ld	r25, X
    b608:	0e 94 6f 43 	call	0x86de	; 0x86de <Put_zDVal>
    b60c:	54 cf       	rjmp	.-344    	; 0xb4b6 <PutField+0x94>
    b60e:	cb 01       	movw	r24, r22
    b610:	0e 94 ac 7d 	call	0xfb58	; 0xfb58 <__eerd_dword_m2560>
		break;
	case s_Longint:
		Put_sDVal(*(int32_t*)Var, Param);
		break;
	case s_EE_Longint:
		Put_sDVal((int32_t)erd((uint32_t*)Var), Param);
    b614:	a7 01       	movw	r20, r14
    b616:	0e 94 90 44 	call	0x8920	; 0x8920 <Put_sDVal>
    b61a:	4d cf       	rjmp	.-358    	; 0xb4b6 <PutField+0x94>
		break;
	case EE_Longint:
		PutDVal(erd((uint32_t*)Var), Param);
		break;
	case s_Longint:
		Put_sDVal(*(int32_t*)Var, Param);
    b61c:	6d 91       	ld	r22, X+
    b61e:	7d 91       	ld	r23, X+
    b620:	8d 91       	ld	r24, X+
    b622:	9c 91       	ld	r25, X
    b624:	0e 94 90 44 	call	0x8920	; 0x8920 <Put_sDVal>
    b628:	46 cf       	rjmp	.-372    	; 0xb4b6 <PutField+0x94>
    b62a:	cb 01       	movw	r24, r22
    b62c:	0e 94 ac 7d 	call	0xfb58	; 0xfb58 <__eerd_dword_m2560>

	case Longint: case c_Longint:
		PutDVal(*(uint32_t*)Var, Param);
		break;
	case EE_Longint:
		PutDVal(erd((uint32_t*)Var), Param);
    b630:	a7 01       	movw	r20, r14
    b632:	0e 94 b9 45 	call	0x8b72	; 0x8b72 <PutDVal>
    b636:	3f cf       	rjmp	.-386    	; 0xb4b6 <PutField+0x94>
		Put_zVal(erw((uint16_t*)Var), 'w', Param);
		break;


	case Longint: case c_Longint:
		PutDVal(*(uint32_t*)Var, Param);
    b638:	6d 91       	ld	r22, X+
    b63a:	7d 91       	ld	r23, X+
    b63c:	8d 91       	ld	r24, X+
    b63e:	9c 91       	ld	r25, X
    b640:	0e 94 b9 45 	call	0x8b72	; 0x8b72 <PutDVal>
    b644:	38 cf       	rjmp	.-400    	; 0xb4b6 <PutField+0x94>

	case zh_Byte:
		Put_zVal_h(*(uint8_t*)Var, 'b', Param);
		break;
	case zh_Word:
		Put_zVal_h(*(uint16_t*)Var, 'w', Param);
    b646:	6d 91       	ld	r22, X+
    b648:	7c 91       	ld	r23, X
    b64a:	80 e0       	ldi	r24, 0x00	; 0
    b64c:	90 e0       	ldi	r25, 0x00	; 0
    b64e:	47 e7       	ldi	r20, 0x77	; 119
    b650:	97 01       	movw	r18, r14
    b652:	0e 94 da 46 	call	0x8db4	; 0x8db4 <Put_zVal_h>
    b656:	2f cf       	rjmp	.-418    	; 0xb4b6 <PutField+0x94>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    b658:	cb 01       	movw	r24, r22
    b65a:	0e 94 b2 7d 	call	0xfb64	; 0xfb64 <__eerd_word_m2560>
		break;
	case z_Word: case zc_Word:
		Put_zVal(*(uint16_t*)Var, 'w', Param);
		break;
	case z_EE_Word:
		Put_zVal(erw((uint16_t*)Var), 'w', Param);
    b65e:	67 e7       	ldi	r22, 0x77	; 119
    b660:	a7 01       	movw	r20, r14
    b662:	0e 94 4d 47 	call	0x8e9a	; 0x8e9a <Put_zVal>
    b666:	27 cf       	rjmp	.-434    	; 0xb4b6 <PutField+0x94>
		break;
	case s_EE_Word:
		Put_sVal((int16_t)erw((uint16_t*)Var), 'w', Param);
		break;
	case z_Word: case zc_Word:
		Put_zVal(*(uint16_t*)Var, 'w', Param);
    b668:	8d 91       	ld	r24, X+
    b66a:	9c 91       	ld	r25, X
    b66c:	67 e7       	ldi	r22, 0x77	; 119
    b66e:	0e 94 4d 47 	call	0x8e9a	; 0x8e9a <Put_zVal>
    b672:	21 cf       	rjmp	.-446    	; 0xb4b6 <PutField+0x94>
    b674:	cb 01       	movw	r24, r22
    b676:	0e 94 b2 7d 	call	0xfb64	; 0xfb64 <__eerd_word_m2560>
		break;
	case s_Word:
		Put_sVal(*(int16_t*)Var, 'w', Param);
		break;
	case s_EE_Word:
		Put_sVal((int16_t)erw((uint16_t*)Var), 'w', Param);
    b67a:	67 e7       	ldi	r22, 0x77	; 119
    b67c:	a7 01       	movw	r20, r14
    b67e:	0e 94 0a 48 	call	0x9014	; 0x9014 <Put_sVal>
    b682:	19 cf       	rjmp	.-462    	; 0xb4b6 <PutField+0x94>
		break;
	case EE_Word:
		PutVal(erw((uint16_t*)Var), 'w', Param);
		break;
	case s_Word:
		Put_sVal(*(int16_t*)Var, 'w', Param);
    b684:	8d 91       	ld	r24, X+
    b686:	9c 91       	ld	r25, X
    b688:	67 e7       	ldi	r22, 0x77	; 119
    b68a:	0e 94 0a 48 	call	0x9014	; 0x9014 <Put_sVal>
    b68e:	13 cf       	rjmp	.-474    	; 0xb4b6 <PutField+0x94>
    b690:	cb 01       	movw	r24, r22
    b692:	0e 94 b2 7d 	call	0xfb64	; 0xfb64 <__eerd_word_m2560>

	case Word: case c_Word:
		PutVal(*(uint16_t*)Var, 'w', Param);
		break;
	case EE_Word:
		PutVal(erw((uint16_t*)Var), 'w', Param);
    b696:	67 e7       	ldi	r22, 0x77	; 119
    b698:	a7 01       	movw	r20, r14
    b69a:	0e 94 ee 48 	call	0x91dc	; 0x91dc <PutVal>
    b69e:	0b cf       	rjmp	.-490    	; 0xb4b6 <PutField+0x94>
	case zh_Longint:
		Put_zVal_h(*(uint32_t*)Var, 'l', Param);
		break;

	case Word: case c_Word:
		PutVal(*(uint16_t*)Var, 'w', Param);
    b6a0:	8d 91       	ld	r24, X+
    b6a2:	9c 91       	ld	r25, X
    b6a4:	67 e7       	ldi	r22, 0x77	; 119
    b6a6:	0e 94 ee 48 	call	0x91dc	; 0x91dc <PutVal>
    b6aa:	05 cf       	rjmp	.-502    	; 0xb4b6 <PutField+0x94>
	case z_EE_Byte:
		Put_zVal(erb((uint8_t*)Var), 'b', Param);
		break;

	case zh_Byte:
		Put_zVal_h(*(uint8_t*)Var, 'b', Param);
    b6ac:	6c 91       	ld	r22, X
    b6ae:	70 e0       	ldi	r23, 0x00	; 0
    b6b0:	80 e0       	ldi	r24, 0x00	; 0
    b6b2:	90 e0       	ldi	r25, 0x00	; 0
    b6b4:	42 e6       	ldi	r20, 0x62	; 98
    b6b6:	97 01       	movw	r18, r14
    b6b8:	0e 94 da 46 	call	0x8db4	; 0x8db4 <Put_zVal_h>
    b6bc:	fc ce       	rjmp	.-520    	; 0xb4b6 <PutField+0x94>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    b6be:	cb 01       	movw	r24, r22
    b6c0:	0e 94 a4 7d 	call	0xfb48	; 0xfb48 <__eerd_byte_m2560>
		break;
	case z_Byte:
		Put_zVal(*(uint8_t*)Var, 'b', Param);
		break;
	case z_EE_Byte:
		Put_zVal(erb((uint8_t*)Var), 'b', Param);
    b6c4:	90 e0       	ldi	r25, 0x00	; 0
    b6c6:	62 e6       	ldi	r22, 0x62	; 98
    b6c8:	a7 01       	movw	r20, r14
    b6ca:	0e 94 4d 47 	call	0x8e9a	; 0x8e9a <Put_zVal>
    b6ce:	f3 ce       	rjmp	.-538    	; 0xb4b6 <PutField+0x94>
		break;
	case s_EE_Byte:
		Put_sVal((int8_t)erb((uint8_t*)Var), 'b', Param);
		break;
	case z_Byte:
		Put_zVal(*(uint8_t*)Var, 'b', Param);
    b6d0:	8c 91       	ld	r24, X
    b6d2:	90 e0       	ldi	r25, 0x00	; 0
    b6d4:	62 e6       	ldi	r22, 0x62	; 98
    b6d6:	0e 94 4d 47 	call	0x8e9a	; 0x8e9a <Put_zVal>
    b6da:	ed ce       	rjmp	.-550    	; 0xb4b6 <PutField+0x94>
    b6dc:	cb 01       	movw	r24, r22
    b6de:	0e 94 a4 7d 	call	0xfb48	; 0xfb48 <__eerd_byte_m2560>
		break;
	case s_Byte:
		Put_sVal(*(int8_t*)Var, 'b', Param);
		break;
	case s_EE_Byte:
		Put_sVal((int8_t)erb((uint8_t*)Var), 'b', Param);
    b6e2:	99 27       	eor	r25, r25
    b6e4:	87 fd       	sbrc	r24, 7
    b6e6:	90 95       	com	r25
    b6e8:	62 e6       	ldi	r22, 0x62	; 98
    b6ea:	a7 01       	movw	r20, r14
    b6ec:	0e 94 0a 48 	call	0x9014	; 0x9014 <Put_sVal>
    b6f0:	e2 ce       	rjmp	.-572    	; 0xb4b6 <PutField+0x94>
		break;
	case EE_Byte:
		PutVal(erb((uint8_t*)Var), 'b', Param);
		break;
	case s_Byte:
		Put_sVal(*(int8_t*)Var, 'b', Param);
    b6f2:	8c 91       	ld	r24, X
    b6f4:	99 27       	eor	r25, r25
    b6f6:	87 fd       	sbrc	r24, 7
    b6f8:	90 95       	com	r25
    b6fa:	62 e6       	ldi	r22, 0x62	; 98
    b6fc:	0e 94 0a 48 	call	0x9014	; 0x9014 <Put_sVal>
    b700:	da ce       	rjmp	.-588    	; 0xb4b6 <PutField+0x94>
    b702:	cb 01       	movw	r24, r22
    b704:	0e 94 a4 7d 	call	0xfb48	; 0xfb48 <__eerd_byte_m2560>
	switch(Type) {
	case Byte:
		PutVal(*(uint8_t*)Var, 'b', Param);
		break;
	case EE_Byte:
		PutVal(erb((uint8_t*)Var), 'b', Param);
    b708:	90 e0       	ldi	r25, 0x00	; 0
    b70a:	62 e6       	ldi	r22, 0x62	; 98
    b70c:	a7 01       	movw	r20, r14
    b70e:	0e 94 ee 48 	call	0x91dc	; 0x91dc <PutVal>
    b712:	d1 ce       	rjmp	.-606    	; 0xb4b6 <PutField+0x94>
{
	float fTemp;

	switch(Type) {
	case Byte:
		PutVal(*(uint8_t*)Var, 'b', Param);
    b714:	8c 91       	ld	r24, X
    b716:	90 e0       	ldi	r25, 0x00	; 0
    b718:	62 e6       	ldi	r22, 0x62	; 98
    b71a:	0e 94 ee 48 	call	0x91dc	; 0x91dc <PutVal>
    b71e:	cb ce       	rjmp	.-618    	; 0xb4b6 <PutField+0x94>
		break;
	case Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((*((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
		break;
	case EE_Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((erb((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
    b720:	80 e0       	ldi	r24, 0x00	; 0
    b722:	90 e0       	ldi	r25, 0x00	; 0
    b724:	c0 ce       	rjmp	.-640    	; 0xb4a6 <PutField+0x84>
	case EE_Enum:
		Param->Txt += erb((uint8_t*)Var);
		PutEnum(Param);
		break;
	case Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((*((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
    b726:	80 e0       	ldi	r24, 0x00	; 0
    b728:	90 e0       	ldi	r25, 0x00	; 0
    b72a:	07 cf       	rjmp	.-498    	; 0xb53a <PutField+0x118>

0000b72c <PutLine>:
	PosBlink(Param,'_');
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
PutLine(uint8_t LineN, uint8_t Y)
{
    b72c:	2f 92       	push	r2
    b72e:	3f 92       	push	r3
    b730:	4f 92       	push	r4
    b732:	5f 92       	push	r5
    b734:	6f 92       	push	r6
    b736:	7f 92       	push	r7
    b738:	8f 92       	push	r8
    b73a:	9f 92       	push	r9
    b73c:	af 92       	push	r10
    b73e:	bf 92       	push	r11
    b740:	cf 92       	push	r12
    b742:	df 92       	push	r13
    b744:	ef 92       	push	r14
    b746:	ff 92       	push	r15
    b748:	0f 93       	push	r16
    b74a:	1f 93       	push	r17
    b74c:	df 93       	push	r29
    b74e:	cf 93       	push	r28
    b750:	cd b7       	in	r28, 0x3d	; 61
    b752:	de b7       	in	r29, 0x3e	; 62
    b754:	60 97       	sbiw	r28, 0x10	; 16
    b756:	0f b6       	in	r0, 0x3f	; 63
    b758:	f8 94       	cli
    b75a:	de bf       	out	0x3e, r29	; 62
    b75c:	0f be       	out	0x3f, r0	; 63
    b75e:	cd bf       	out	0x3d, r28	; 61
    b760:	8f 87       	std	Y+15, r24	; 0x0f
    b762:	68 8b       	std	Y+16, r22	; 0x10

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    b764:	e0 91 d1 02 	lds	r30, 0x02D1
    b768:	f0 91 d2 02 	lds	r31, 0x02D2
    b76c:	e5 90       	lpm	r14, Z+
    b76e:	f4 90       	lpm	r15, Z+
	MenuLine *Line=GetLine+LineN;
    b770:	8b e1       	ldi	r24, 0x1B	; 27
    b772:	2f 85       	ldd	r18, Y+15	; 0x0f
    b774:	28 9f       	mul	r18, r24
    b776:	c0 01       	movw	r24, r0
    b778:	11 24       	eor	r1, r1
    b77a:	e8 0e       	add	r14, r24
    b77c:	f9 1e       	adc	r15, r25
	PGM_P CurrStr=(PGM_P)(Line->Str);
    b77e:	be 2c       	mov	r11, r14
    b780:	af 2c       	mov	r10, r15
    b782:	f7 01       	movw	r30, r14
    b784:	75 96       	adiw	r30, 0x15	; 21
    b786:	c5 90       	lpm	r12, Z+
    b788:	d4 90       	lpm	r13, Z+

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    b78a:	f7 01       	movw	r30, r14
    b78c:	77 96       	adiw	r30, 0x17	; 23
    b78e:	85 91       	lpm	r24, Z+
    b790:	94 91       	lpm	r25, Z+
    b792:	9e 87       	std	Y+14, r25	; 0x0e
    b794:	8d 87       	std	Y+13, r24	; 0x0d
    b796:	87 01       	movw	r16, r14
    b798:	f7 01       	movw	r30, r14
    b79a:	84 91       	lpm	r24, Z+
	uint8_t X;
	uint8_t X0=0;
	uint8_t X1=LCDXSz;
	int8_t Xs = 0;
	//--- ">>" Align right
	if(prc(CurrStr+0) == '>' && prc(CurrStr+1) == '>'){
    b79c:	8e 33       	cpi	r24, 0x3E	; 62
    b79e:	09 f4       	brne	.+2      	; 0xb7a2 <PutLine+0x76>
    b7a0:	a6 c1       	rjmp	.+844    	; 0xbaee <PutLine+0x3c2>
		X0 = LCDXSz - strlen_P(CurrStr) + 2;
		Xs = X0-2;
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';
    b7a2:	40 e0       	ldi	r20, 0x00	; 0
    b7a4:	50 e0       	ldi	r21, 0x00	; 0
    b7a6:	f8 01       	movw	r30, r16
    b7a8:	84 91       	lpm	r24, Z+
	}
	//--- "<<" Align left
	if(prc(CurrStr+0) == '<' && prc(CurrStr+1) == '<'){
    b7aa:	8c 33       	cpi	r24, 0x3C	; 60
    b7ac:	09 f4       	brne	.+2      	; 0xb7b0 <PutLine+0x84>
    b7ae:	8a c1       	rjmp	.+788    	; 0xbac4 <PutLine+0x398>
		X1 = strlen_P(CurrStr) - 2;
    b7b0:	84 e1       	ldi	r24, 0x14	; 20
    b7b2:	98 2e       	mov	r9, r24
    b7b4:	f8 01       	movw	r30, r16
    b7b6:	84 91       	lpm	r24, Z+
		X0 = 0;
		Xs = X0-2;
	}
	//--- "<>" Align center
	if(prc(CurrStr+0) == '<' && prc(CurrStr+1) == '>'){
    b7b8:	8c 33       	cpi	r24, 0x3C	; 60
    b7ba:	09 f4       	brne	.+2      	; 0xb7be <PutLine+0x92>
    b7bc:	56 c1       	rjmp	.+684    	; 0xba6a <PutLine+0x33e>
		Xs = X0-2;
		X1 = X0 + (strlen_P(CurrStr) - 2);
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';		
	}
	//---
	for(X=X0; X<X1; X++){
    b7be:	49 15       	cp	r20, r9
    b7c0:	08 f0       	brcs	.+2      	; 0xb7c4 <PutLine+0x98>
    b7c2:	ac c0       	rjmp	.+344    	; 0xb91c <PutLine+0x1f0>
static void
PutLine(uint8_t LineN, uint8_t Y)
{
	MenuLine *Line=GetLine+LineN;
	PGM_P CurrStr=(PGM_P)(Line->Str);
	InField *IF = prp(&Line->IF_List);
    b7c4:	88 89       	ldd	r24, Y+16	; 0x10
    b7c6:	28 2f       	mov	r18, r24
    b7c8:	30 e0       	ldi	r19, 0x00	; 0
    b7ca:	c9 01       	movw	r24, r18
    b7cc:	88 0f       	add	r24, r24
    b7ce:	99 1f       	adc	r25, r25
    b7d0:	82 0f       	add	r24, r18
    b7d2:	93 1f       	adc	r25, r19
    b7d4:	5c 01       	movw	r10, r24
    b7d6:	aa 0c       	add	r10, r10
    b7d8:	bb 1c       	adc	r11, r11
    b7da:	aa 0c       	add	r10, r10
    b7dc:	bb 1c       	adc	r11, r11
    b7de:	aa 0c       	add	r10, r10
    b7e0:	bb 1c       	adc	r11, r11
    b7e2:	a8 1a       	sub	r10, r24
    b7e4:	b9 0a       	sbc	r11, r25
    b7e6:	25 2e       	mov	r2, r21
    b7e8:	33 24       	eor	r3, r3
    b7ea:	27 fc       	sbrc	r2, 7
    b7ec:	30 94       	com	r3
    b7ee:	04 2f       	mov	r16, r20
    b7f0:	88 24       	eor	r8, r8
		switch(Char=prc(CurrStr+X-Xs)) {
		case '{':
			while((Char=prc(CurrStr + X - Xs + ++Param.Size))=='{');
			Param.Prec = prb(&IF->Prec);
			Param.Txt = prp(&IF->EnumList);
			PutField(prb(&IF->Type), prp(&IF->Var), &Param);
    b7f2:	3e 01       	movw	r6, r28
    b7f4:	08 94       	sec
    b7f6:	61 1c       	adc	r6, r1
    b7f8:	71 1c       	adc	r7, r1
			else
				PutField(prb(&(OF+OF_N)->Type), prp(&(OF+OF_N)->Var), &Param);
			OF_N++;
			break;
		}
		LCD_Buf[Y][X+=Param.Size] = Char;
    b7fa:	25 01       	movw	r4, r10
    b7fc:	11 c0       	rjmp	.+34     	; 0xb820 <PutLine+0xf4>
	for(X=X0; X<X1; X++){
		char Char;
		T_Param Param;
		Param.Pos = LCD_Buf[Y]+X;
		Param.Size = 0;
		switch(Char=prc(CurrStr+X-Xs)) {
    b7fe:	1d 37       	cpi	r17, 0x7D	; 125
    b800:	09 f4       	brne	.+2      	; 0xb804 <PutLine+0xd8>
    b802:	4c c0       	rjmp	.+152    	; 0xb89c <PutLine+0x170>
    b804:	30 e0       	ldi	r19, 0x00	; 0
			else
				PutField(prb(&(OF+OF_N)->Type), prp(&(OF+OF_N)->Var), &Param);
			OF_N++;
			break;
		}
		LCD_Buf[Y][X+=Param.Size] = Char;
    b806:	80 2f       	mov	r24, r16
    b808:	83 0f       	add	r24, r19
    b80a:	f2 01       	movw	r30, r4
    b80c:	e8 0f       	add	r30, r24
    b80e:	f1 1d       	adc	r31, r1
    b810:	e0 5b       	subi	r30, 0xB0	; 176
    b812:	f9 4f       	sbci	r31, 0xF9	; 249
    b814:	10 83       	st	Z, r17
		Xs = X0-2;
		X1 = X0 + (strlen_P(CurrStr) - 2);
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';		
	}
	//---
	for(X=X0; X<X1; X++){
    b816:	08 2f       	mov	r16, r24
    b818:	0f 5f       	subi	r16, 0xFF	; 255
    b81a:	09 15       	cp	r16, r9
    b81c:	08 f0       	brcs	.+2      	; 0xb820 <PutLine+0xf4>
    b81e:	7e c0       	rjmp	.+252    	; 0xb91c <PutLine+0x1f0>
		char Char;
		T_Param Param;
		Param.Pos = LCD_Buf[Y]+X;
    b820:	80 2f       	mov	r24, r16
    b822:	90 e0       	ldi	r25, 0x00	; 0
    b824:	9c 01       	movw	r18, r24
    b826:	2a 0d       	add	r18, r10
    b828:	3b 1d       	adc	r19, r11
    b82a:	20 5b       	subi	r18, 0xB0	; 176
    b82c:	39 4f       	sbci	r19, 0xF9	; 249
    b82e:	3a 83       	std	Y+2, r19	; 0x02
    b830:	29 83       	std	Y+1, r18	; 0x01
		Param.Size = 0;
		switch(Char=prc(CurrStr+X-Xs)) {
    b832:	82 19       	sub	r24, r2
    b834:	93 09       	sbc	r25, r3
    b836:	f7 01       	movw	r30, r14
    b838:	e8 0f       	add	r30, r24
    b83a:	f9 1f       	adc	r31, r25
    b83c:	14 91       	lpm	r17, Z+
    b83e:	1b 37       	cpi	r17, 0x7B	; 123
    b840:	f1 f6       	brne	.-68     	; 0xb7fe <PutLine+0xd2>
    b842:	21 e0       	ldi	r18, 0x01	; 1
    b844:	01 c0       	rjmp	.+2      	; 0xb848 <PutLine+0x11c>
		case '{':
			while((Char=prc(CurrStr + X - Xs + ++Param.Size))=='{');
    b846:	23 2f       	mov	r18, r19
    b848:	fc 01       	movw	r30, r24
    b84a:	e2 0f       	add	r30, r18
    b84c:	f1 1d       	adc	r31, r1
    b84e:	ee 0d       	add	r30, r14
    b850:	ff 1d       	adc	r31, r15
    b852:	14 91       	lpm	r17, Z+
    b854:	32 2f       	mov	r19, r18
    b856:	3f 5f       	subi	r19, 0xFF	; 255
    b858:	1b 37       	cpi	r17, 0x7B	; 123
    b85a:	a9 f3       	breq	.-22     	; 0xb846 <PutLine+0x11a>
    b85c:	2c 83       	std	Y+4, r18	; 0x04

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    b85e:	a5 e0       	ldi	r26, 0x05	; 5
    b860:	b0 e0       	ldi	r27, 0x00	; 0
    b862:	ca 0e       	add	r12, r26
    b864:	db 1e       	adc	r13, r27
    b866:	f6 01       	movw	r30, r12
    b868:	84 91       	lpm	r24, Z+
    b86a:	2b ef       	ldi	r18, 0xFB	; 251
    b86c:	3f ef       	ldi	r19, 0xFF	; 255
    b86e:	c2 0e       	add	r12, r18
    b870:	d3 1e       	adc	r13, r19
			Param.Prec = prb(&IF->Prec);
    b872:	8b 83       	std	Y+3, r24	; 0x03

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    b874:	f6 01       	movw	r30, r12
    b876:	33 96       	adiw	r30, 0x03	; 3
    b878:	85 91       	lpm	r24, Z+
    b87a:	94 91       	lpm	r25, Z+
			Param.Txt = prp(&IF->EnumList);
    b87c:	9e 83       	std	Y+6, r25	; 0x06
    b87e:	8d 83       	std	Y+5, r24	; 0x05

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    b880:	f6 01       	movw	r30, r12
    b882:	84 91       	lpm	r24, Z+

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    b884:	31 96       	adiw	r30, 0x01	; 1
    b886:	65 91       	lpm	r22, Z+
    b888:	74 91       	lpm	r23, Z+
			PutField(prb(&IF->Type), prp(&IF->Var), &Param);
    b88a:	a3 01       	movw	r20, r6
    b88c:	0e 94 11 5a 	call	0xb422	; 0xb422 <PutField>
			IF++;
    b890:	26 e0       	ldi	r18, 0x06	; 6
    b892:	30 e0       	ldi	r19, 0x00	; 0
    b894:	c2 0e       	add	r12, r18
    b896:	d3 1e       	adc	r13, r19
    b898:	3c 81       	ldd	r19, Y+4	; 0x04
    b89a:	b5 cf       	rjmp	.-150    	; 0xb806 <PutLine+0xda>
			break;
    b89c:	21 e0       	ldi	r18, 0x01	; 1
    b89e:	01 c0       	rjmp	.+2      	; 0xb8a2 <PutLine+0x176>
		case '}':
			while((Char=prc(CurrStr+X - Xs + ++Param.Size))=='}');
    b8a0:	23 2f       	mov	r18, r19

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    b8a2:	fc 01       	movw	r30, r24
    b8a4:	e2 0f       	add	r30, r18
    b8a6:	f1 1d       	adc	r31, r1
    b8a8:	ee 0d       	add	r30, r14
    b8aa:	ff 1d       	adc	r31, r15
    b8ac:	14 91       	lpm	r17, Z+
    b8ae:	32 2f       	mov	r19, r18
    b8b0:	3f 5f       	subi	r19, 0xFF	; 255
    b8b2:	1d 37       	cpi	r17, 0x7D	; 125
    b8b4:	a9 f3       	breq	.-22     	; 0xb8a0 <PutLine+0x174>
    b8b6:	2c 83       	std	Y+4, r18	; 0x04
			Y1=Y;
    b8b8:	38 89       	ldd	r19, Y+16	; 0x10
    b8ba:	30 93 f7 09 	sts	0x09F7, r19
			Param.Prec = prb(&(OF+OF_N)->Prec);
    b8be:	48 2d       	mov	r20, r8
    b8c0:	50 e0       	ldi	r21, 0x00	; 0
    b8c2:	42 95       	swap	r20
    b8c4:	52 95       	swap	r21
    b8c6:	50 7f       	andi	r21, 0xF0	; 240
    b8c8:	54 27       	eor	r21, r20
    b8ca:	40 7f       	andi	r20, 0xF0	; 240
    b8cc:	54 27       	eor	r21, r20
    b8ce:	8d 85       	ldd	r24, Y+13	; 0x0d
    b8d0:	9e 85       	ldd	r25, Y+14	; 0x0e
    b8d2:	48 0f       	add	r20, r24
    b8d4:	59 1f       	adc	r21, r25

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    b8d6:	41 5f       	subi	r20, 0xF1	; 241
    b8d8:	5f 4f       	sbci	r21, 0xFF	; 255
    b8da:	fa 01       	movw	r30, r20
    b8dc:	84 91       	lpm	r24, Z+
    b8de:	4f 50       	subi	r20, 0x0F	; 15
    b8e0:	50 40       	sbci	r21, 0x00	; 0
    b8e2:	8b 83       	std	Y+3, r24	; 0x03

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    b8e4:	ca 01       	movw	r24, r20
    b8e6:	0d 96       	adiw	r24, 0x0d	; 13
    b8e8:	fc 01       	movw	r30, r24
    b8ea:	25 91       	lpm	r18, Z+
    b8ec:	34 91       	lpm	r19, Z+
			Param.Txt = prp(&(OF+OF_N)->EnumList);
    b8ee:	3e 83       	std	Y+6, r19	; 0x06
    b8f0:	2d 83       	std	Y+5, r18	; 0x05
			if(LineN==CurrLine && OF_N==CurrField)
    b8f2:	80 91 7d 07 	lds	r24, 0x077D
    b8f6:	ff 85       	ldd	r31, Y+15	; 0x0f
    b8f8:	f8 17       	cp	r31, r24
    b8fa:	29 f4       	brne	.+10     	; 0xb906 <PutLine+0x1da>
    b8fc:	80 91 d3 02 	lds	r24, 0x02D3
    b900:	88 16       	cp	r8, r24
    b902:	09 f4       	brne	.+2      	; 0xb906 <PutLine+0x1da>
    b904:	43 c0       	rjmp	.+134    	; 0xb98c <PutLine+0x260>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    b906:	fa 01       	movw	r30, r20
    b908:	84 91       	lpm	r24, Z+

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    b90a:	31 96       	adiw	r30, 0x01	; 1
    b90c:	65 91       	lpm	r22, Z+
    b90e:	74 91       	lpm	r23, Z+
				}
				else{ 
					PutBuf(prb(&(OF+OF_N)->Type), &Param);
				}			
			else
				PutField(prb(&(OF+OF_N)->Type), prp(&(OF+OF_N)->Var), &Param);
    b910:	a3 01       	movw	r20, r6
    b912:	0e 94 11 5a 	call	0xb422	; 0xb422 <PutField>
    b916:	3c 81       	ldd	r19, Y+4	; 0x04
			OF_N++;
    b918:	83 94       	inc	r8
    b91a:	75 cf       	rjmp	.-278    	; 0xb806 <PutLine+0xda>
		}
		LCD_Buf[Y][X+=Param.Size] = Char;

	}
	X=X1;
	for(;X<LCDXSz; X++) LCD_Buf[Y][X] = ' ';
    b91c:	f3 e1       	ldi	r31, 0x13	; 19
    b91e:	f9 15       	cp	r31, r9
    b920:	e0 f0       	brcs	.+56     	; 0xb95a <PutLine+0x22e>
    b922:	88 89       	ldd	r24, Y+16	; 0x10
    b924:	28 2f       	mov	r18, r24
    b926:	30 e0       	ldi	r19, 0x00	; 0
    b928:	49 2d       	mov	r20, r9
    b92a:	c9 01       	movw	r24, r18
    b92c:	88 0f       	add	r24, r24
    b92e:	99 1f       	adc	r25, r25
    b930:	82 0f       	add	r24, r18
    b932:	93 1f       	adc	r25, r19
    b934:	9c 01       	movw	r18, r24
    b936:	22 0f       	add	r18, r18
    b938:	33 1f       	adc	r19, r19
    b93a:	22 0f       	add	r18, r18
    b93c:	33 1f       	adc	r19, r19
    b93e:	22 0f       	add	r18, r18
    b940:	33 1f       	adc	r19, r19
    b942:	28 1b       	sub	r18, r24
    b944:	39 0b       	sbc	r19, r25
    b946:	80 e2       	ldi	r24, 0x20	; 32
    b948:	f9 01       	movw	r30, r18
    b94a:	e4 0f       	add	r30, r20
    b94c:	f1 1d       	adc	r31, r1
    b94e:	e0 5b       	subi	r30, 0xB0	; 176
    b950:	f9 4f       	sbci	r31, 0xF9	; 249
    b952:	80 83       	st	Z, r24
    b954:	4f 5f       	subi	r20, 0xFF	; 255
    b956:	44 31       	cpi	r20, 0x14	; 20
    b958:	b8 f3       	brcs	.-18     	; 0xb948 <PutLine+0x21c>

}
    b95a:	60 96       	adiw	r28, 0x10	; 16
    b95c:	0f b6       	in	r0, 0x3f	; 63
    b95e:	f8 94       	cli
    b960:	de bf       	out	0x3e, r29	; 62
    b962:	0f be       	out	0x3f, r0	; 63
    b964:	cd bf       	out	0x3d, r28	; 61
    b966:	cf 91       	pop	r28
    b968:	df 91       	pop	r29
    b96a:	1f 91       	pop	r17
    b96c:	0f 91       	pop	r16
    b96e:	ff 90       	pop	r15
    b970:	ef 90       	pop	r14
    b972:	df 90       	pop	r13
    b974:	cf 90       	pop	r12
    b976:	bf 90       	pop	r11
    b978:	af 90       	pop	r10
    b97a:	9f 90       	pop	r9
    b97c:	8f 90       	pop	r8
    b97e:	7f 90       	pop	r7
    b980:	6f 90       	pop	r6
    b982:	5f 90       	pop	r5
    b984:	4f 90       	pop	r4
    b986:	3f 90       	pop	r3
    b988:	2f 90       	pop	r2
    b98a:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    b98c:	fa 01       	movw	r30, r20
    b98e:	84 91       	lpm	r24, Z+
			Y1=Y;
			Param.Prec = prb(&(OF+OF_N)->Prec);
			Param.Txt = prp(&(OF+OF_N)->EnumList);
			if(LineN==CurrLine && OF_N==CurrField)
				//add new
				if( (prb(&(OF+OF_N)->Type) == Text) || (prb(&(OF+OF_N)->Type) == EE_Text ) ||
    b990:	81 32       	cpi	r24, 0x21	; 33
    b992:	61 f1       	breq	.+88     	; 0xb9ec <PutLine+0x2c0>
    b994:	82 32       	cpi	r24, 0x22	; 34
    b996:	51 f1       	breq	.+84     	; 0xb9ec <PutLine+0x2c0>
    b998:	80 31       	cpi	r24, 0x10	; 16
    b99a:	41 f1       	breq	.+80     	; 0xb9ec <PutLine+0x2c0>
    b99c:	84 31       	cpi	r24, 0x14	; 20
    b99e:	31 f1       	breq	.+76     	; 0xb9ec <PutLine+0x2c0>
    b9a0:	81 31       	cpi	r24, 0x11	; 17
    b9a2:	21 f1       	breq	.+72     	; 0xb9ec <PutLine+0x2c0>
    b9a4:	85 31       	cpi	r24, 0x15	; 21
    b9a6:	11 f1       	breq	.+68     	; 0xb9ec <PutLine+0x2c0>
    b9a8:	82 31       	cpi	r24, 0x12	; 18
    b9aa:	01 f1       	breq	.+64     	; 0xb9ec <PutLine+0x2c0>
    b9ac:	83 31       	cpi	r24, 0x13	; 19
    b9ae:	f1 f0       	breq	.+60     	; 0xb9ec <PutLine+0x2c0>
    b9b0:	89 31       	cpi	r24, 0x19	; 25
    b9b2:	e1 f0       	breq	.+56     	; 0xb9ec <PutLine+0x2c0>
    b9b4:	8b 31       	cpi	r24, 0x1B	; 27
    b9b6:	d1 f0       	breq	.+52     	; 0xb9ec <PutLine+0x2c0>
    b9b8:	8a 31       	cpi	r24, 0x1A	; 26
    b9ba:	c1 f0       	breq	.+48     	; 0xb9ec <PutLine+0x2c0>
    b9bc:	8c 31       	cpi	r24, 0x1C	; 28
    b9be:	b1 f0       	breq	.+44     	; 0xb9ec <PutLine+0x2c0>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
PutBuf(uint8_t Type, T_Param *Param)
{
	switch(Type) {
    b9c0:	89 30       	cpi	r24, 0x09	; 9
    b9c2:	08 f0       	brcs	.+2      	; 0xb9c6 <PutLine+0x29a>
    b9c4:	b7 c0       	rjmp	.+366    	; 0xbb34 <PutLine+0x408>
    b9c6:	87 30       	cpi	r24, 0x07	; 7
    b9c8:	08 f0       	brcs	.+2      	; 0xb9cc <PutLine+0x2a0>
    b9ca:	b9 c0       	rjmp	.+370    	; 0xbb3e <PutLine+0x412>
    b9cc:	84 30       	cpi	r24, 0x04	; 4
    b9ce:	08 f0       	brcs	.+2      	; 0xb9d2 <PutLine+0x2a6>
    b9d0:	e5 c0       	rjmp	.+458    	; 0xbb9c <PutLine+0x470>
    b9d2:	82 30       	cpi	r24, 0x02	; 2
    b9d4:	08 f4       	brcc	.+2      	; 0xb9d8 <PutLine+0x2ac>
    b9d6:	b3 c0       	rjmp	.+358    	; 0xbb3e <PutLine+0x412>
		Put_bVal(Param);
		PosBlink(Param,' ');
		break;
	case s_Byte: case s_EE_Byte:
	case s_Word: case s_EE_Word:
		Put_sbVal(Param);
    b9d8:	c3 01       	movw	r24, r6
    b9da:	0e 94 21 40 	call	0x8042	; 0x8042 <Put_sbVal>
		PosBlink(Param,' ');
    b9de:	c3 01       	movw	r24, r6
    b9e0:	60 e2       	ldi	r22, 0x20	; 32
    b9e2:	0e 94 0f 3c 	call	0x781e	; 0x781e <PosBlink>
    b9e6:	3c 81       	ldd	r19, Y+4	; 0x04
				else{ 
					PutBuf(prb(&(OF+OF_N)->Type), &Param);
				}			
			else
				PutField(prb(&(OF+OF_N)->Type), prp(&(OF+OF_N)->Var), &Param);
			OF_N++;
    b9e8:	83 94       	inc	r8
    b9ea:	0d cf       	rjmp	.-486    	; 0xb806 <PutLine+0xda>
// When use BufStr for variable edit
inline static void
PutBufStr(uint8_t Type, T_Param *Param)
{	
	char Format[6];
	sprintf(Format,"%%.%us", Param->Size);
    b9ec:	00 d0       	rcall	.+0      	; 0xb9ee <PutLine+0x2c2>
    b9ee:	00 d0       	rcall	.+0      	; 0xb9f0 <PutLine+0x2c4>
    b9f0:	ed b7       	in	r30, 0x3d	; 61
    b9f2:	fe b7       	in	r31, 0x3e	; 62
    b9f4:	31 96       	adiw	r30, 0x01	; 1
    b9f6:	27 e0       	ldi	r18, 0x07	; 7
    b9f8:	30 e0       	ldi	r19, 0x00	; 0
    b9fa:	2c 0f       	add	r18, r28
    b9fc:	3d 1f       	adc	r19, r29
    b9fe:	ad b7       	in	r26, 0x3d	; 61
    ba00:	be b7       	in	r27, 0x3e	; 62
    ba02:	12 96       	adiw	r26, 0x02	; 2
    ba04:	3c 93       	st	X, r19
    ba06:	2e 93       	st	-X, r18
    ba08:	11 97       	sbiw	r26, 0x01	; 1
    ba0a:	8b ea       	ldi	r24, 0xAB	; 171
    ba0c:	92 e0       	ldi	r25, 0x02	; 2
    ba0e:	93 83       	std	Z+3, r25	; 0x03
    ba10:	82 83       	std	Z+2, r24	; 0x02
    ba12:	8c 81       	ldd	r24, Y+4	; 0x04
    ba14:	84 83       	std	Z+4, r24	; 0x04
    ba16:	15 82       	std	Z+5, r1	; 0x05
    ba18:	0e 94 76 7b 	call	0xf6ec	; 0xf6ec <sprintf>
	sprintf(Param->Pos, Format, BufStr);
    ba1c:	ed b7       	in	r30, 0x3d	; 61
    ba1e:	fe b7       	in	r31, 0x3e	; 62
    ba20:	31 96       	adiw	r30, 0x01	; 1
    ba22:	89 81       	ldd	r24, Y+1	; 0x01
    ba24:	9a 81       	ldd	r25, Y+2	; 0x02
    ba26:	ad b7       	in	r26, 0x3d	; 61
    ba28:	be b7       	in	r27, 0x3e	; 62
    ba2a:	12 96       	adiw	r26, 0x02	; 2
    ba2c:	9c 93       	st	X, r25
    ba2e:	8e 93       	st	-X, r24
    ba30:	11 97       	sbiw	r26, 0x01	; 1
    ba32:	27 e0       	ldi	r18, 0x07	; 7
    ba34:	30 e0       	ldi	r19, 0x00	; 0
    ba36:	2c 0f       	add	r18, r28
    ba38:	3d 1f       	adc	r19, r29
    ba3a:	33 83       	std	Z+3, r19	; 0x03
    ba3c:	22 83       	std	Z+2, r18	; 0x02
    ba3e:	8b eb       	ldi	r24, 0xBB	; 187
    ba40:	95 e0       	ldi	r25, 0x05	; 5
    ba42:	95 83       	std	Z+5, r25	; 0x05
    ba44:	84 83       	std	Z+4, r24	; 0x04
    ba46:	0e 94 76 7b 	call	0xf6ec	; 0xf6ec <sprintf>
	Param->Prec = 0;
    ba4a:	1b 82       	std	Y+3, r1	; 0x03
	PosBlink(Param,'_');
    ba4c:	ad b7       	in	r26, 0x3d	; 61
    ba4e:	be b7       	in	r27, 0x3e	; 62
    ba50:	16 96       	adiw	r26, 0x06	; 6
    ba52:	0f b6       	in	r0, 0x3f	; 63
    ba54:	f8 94       	cli
    ba56:	be bf       	out	0x3e, r27	; 62
    ba58:	0f be       	out	0x3f, r0	; 63
    ba5a:	ad bf       	out	0x3d, r26	; 61
    ba5c:	c3 01       	movw	r24, r6
    ba5e:	6f e5       	ldi	r22, 0x5F	; 95
    ba60:	0e 94 0f 3c 	call	0x781e	; 0x781e <PosBlink>
    ba64:	3c 81       	ldd	r19, Y+4	; 0x04
				else{ 
					PutBuf(prb(&(OF+OF_N)->Type), &Param);
				}			
			else
				PutField(prb(&(OF+OF_N)->Type), prp(&(OF+OF_N)->Var), &Param);
			OF_N++;
    ba66:	83 94       	inc	r8
    ba68:	ce ce       	rjmp	.-612    	; 0xb806 <PutLine+0xda>

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    ba6a:	08 94       	sec
    ba6c:	e1 1c       	adc	r14, r1
    ba6e:	f1 1c       	adc	r15, r1
    ba70:	f7 01       	movw	r30, r14
    ba72:	84 91       	lpm	r24, Z+
    ba74:	08 94       	sec
    ba76:	e1 08       	sbc	r14, r1
    ba78:	f1 08       	sbc	r15, r1
		X1 = strlen_P(CurrStr) - 2;
		X0 = 0;
		Xs = X0-2;
	}
	//--- "<>" Align center
	if(prc(CurrStr+0) == '<' && prc(CurrStr+1) == '>'){
    ba7a:	8e 33       	cpi	r24, 0x3E	; 62
    ba7c:	09 f0       	breq	.+2      	; 0xba80 <PutLine+0x354>
    ba7e:	9f ce       	rjmp	.-706    	; 0xb7be <PutLine+0x92>
		X0 = (LCDXSz - strlen_P(CurrStr) + 2) / 2;
    ba80:	8b 2d       	mov	r24, r11
    ba82:	9a 2d       	mov	r25, r10
    ba84:	0e 94 8a 7a 	call	0xf514	; 0xf514 <strlen_P>
    ba88:	26 e1       	ldi	r18, 0x16	; 22
    ba8a:	30 e0       	ldi	r19, 0x00	; 0
    ba8c:	28 1b       	sub	r18, r24
    ba8e:	39 0b       	sbc	r19, r25
    ba90:	36 95       	lsr	r19
    ba92:	27 95       	ror	r18
    ba94:	42 2f       	mov	r20, r18
		Xs = X0-2;
    ba96:	52 2f       	mov	r21, r18
    ba98:	52 50       	subi	r21, 0x02	; 2
		X1 = X0 + (strlen_P(CurrStr) - 2);
    ba9a:	be ef       	ldi	r27, 0xFE	; 254
    ba9c:	9b 2e       	mov	r9, r27
    ba9e:	98 0e       	add	r9, r24
    baa0:	92 0e       	add	r9, r18
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';		
    baa2:	22 23       	and	r18, r18
    baa4:	09 f4       	brne	.+2      	; 0xbaa8 <PutLine+0x37c>
    baa6:	8b ce       	rjmp	.-746    	; 0xb7be <PutLine+0x92>
    baa8:	85 e1       	ldi	r24, 0x15	; 21
    baaa:	28 89       	ldd	r18, Y+16	; 0x10
    baac:	28 9f       	mul	r18, r24
    baae:	f0 01       	movw	r30, r0
    bab0:	11 24       	eor	r1, r1
    bab2:	e0 5b       	subi	r30, 0xB0	; 176
    bab4:	f9 4f       	sbci	r31, 0xF9	; 249
    bab6:	80 e0       	ldi	r24, 0x00	; 0
    bab8:	90 e2       	ldi	r25, 0x20	; 32
    baba:	91 93       	st	Z+, r25
    babc:	8f 5f       	subi	r24, 0xFF	; 255
    babe:	84 17       	cp	r24, r20
    bac0:	e0 f3       	brcs	.-8      	; 0xbaba <PutLine+0x38e>
    bac2:	7d ce       	rjmp	.-774    	; 0xb7be <PutLine+0x92>
    bac4:	08 94       	sec
    bac6:	e1 1c       	adc	r14, r1
    bac8:	f1 1c       	adc	r15, r1
    baca:	f7 01       	movw	r30, r14
    bacc:	84 91       	lpm	r24, Z+
    bace:	08 94       	sec
    bad0:	e1 08       	sbc	r14, r1
    bad2:	f1 08       	sbc	r15, r1
		X0 = LCDXSz - strlen_P(CurrStr) + 2;
		Xs = X0-2;
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';
	}
	//--- "<<" Align left
	if(prc(CurrStr+0) == '<' && prc(CurrStr+1) == '<'){
    bad4:	8c 33       	cpi	r24, 0x3C	; 60
    bad6:	09 f0       	breq	.+2      	; 0xbada <PutLine+0x3ae>
    bad8:	6b ce       	rjmp	.-810    	; 0xb7b0 <PutLine+0x84>
		X1 = strlen_P(CurrStr) - 2;
    bada:	8b 2d       	mov	r24, r11
    badc:	9a 2d       	mov	r25, r10
    bade:	0e 94 8a 7a 	call	0xf514	; 0xf514 <strlen_P>
    bae2:	9e ef       	ldi	r25, 0xFE	; 254
    bae4:	99 2e       	mov	r9, r25
    bae6:	98 0e       	add	r9, r24
    bae8:	40 e0       	ldi	r20, 0x00	; 0
    baea:	5e ef       	ldi	r21, 0xFE	; 254
    baec:	63 ce       	rjmp	.-826    	; 0xb7b4 <PutLine+0x88>
    baee:	08 94       	sec
    baf0:	e1 1c       	adc	r14, r1
    baf2:	f1 1c       	adc	r15, r1
    baf4:	f7 01       	movw	r30, r14
    baf6:	84 91       	lpm	r24, Z+
    baf8:	08 94       	sec
    bafa:	e1 08       	sbc	r14, r1
    bafc:	f1 08       	sbc	r15, r1
	uint8_t X;
	uint8_t X0=0;
	uint8_t X1=LCDXSz;
	int8_t Xs = 0;
	//--- ">>" Align right
	if(prc(CurrStr+0) == '>' && prc(CurrStr+1) == '>'){
    bafe:	8e 33       	cpi	r24, 0x3E	; 62
    bb00:	09 f0       	breq	.+2      	; 0xbb04 <PutLine+0x3d8>
    bb02:	4f ce       	rjmp	.-866    	; 0xb7a2 <PutLine+0x76>
		X0 = LCDXSz - strlen_P(CurrStr) + 2;
    bb04:	c7 01       	movw	r24, r14
    bb06:	0e 94 8a 7a 	call	0xf514	; 0xf514 <strlen_P>
    bb0a:	46 e1       	ldi	r20, 0x16	; 22
    bb0c:	48 1b       	sub	r20, r24
		Xs = X0-2;
    bb0e:	54 2f       	mov	r21, r20
    bb10:	52 50       	subi	r21, 0x02	; 2
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';
    bb12:	44 23       	and	r20, r20
    bb14:	09 f4       	brne	.+2      	; 0xbb18 <PutLine+0x3ec>
    bb16:	47 ce       	rjmp	.-882    	; 0xb7a6 <PutLine+0x7a>
    bb18:	85 e1       	ldi	r24, 0x15	; 21
    bb1a:	28 89       	ldd	r18, Y+16	; 0x10
    bb1c:	28 9f       	mul	r18, r24
    bb1e:	f0 01       	movw	r30, r0
    bb20:	11 24       	eor	r1, r1
    bb22:	e0 5b       	subi	r30, 0xB0	; 176
    bb24:	f9 4f       	sbci	r31, 0xF9	; 249
    bb26:	80 e0       	ldi	r24, 0x00	; 0
    bb28:	90 e2       	ldi	r25, 0x20	; 32
    bb2a:	91 93       	st	Z+, r25
    bb2c:	8f 5f       	subi	r24, 0xFF	; 255
    bb2e:	84 17       	cp	r24, r20
    bb30:	e0 f3       	brcs	.-8      	; 0xbb2a <PutLine+0x3fe>
    bb32:	39 ce       	rjmp	.-910    	; 0xb7a6 <PutLine+0x7a>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
PutBuf(uint8_t Type, T_Param *Param)
{
	switch(Type) {
    bb34:	8d 30       	cpi	r24, 0x0D	; 13
    bb36:	68 f4       	brcc	.+26     	; 0xbb52 <PutLine+0x426>
    bb38:	8b 30       	cpi	r24, 0x0B	; 11
    bb3a:	08 f4       	brcc	.+2      	; 0xbb3e <PutLine+0x412>
    bb3c:	4d cf       	rjmp	.-358    	; 0xb9d8 <PutLine+0x2ac>
	case Byte: case EE_Byte: case z_Byte: case z_EE_Byte:
	case Word: case EE_Word: case z_Word: case z_EE_Word:
		Put_bVal(Param);
    bb3e:	c3 01       	movw	r24, r6
    bb40:	0e 94 1f 41 	call	0x823e	; 0x823e <Put_bVal>
		PosBlink(Param,' ');
    bb44:	c3 01       	movw	r24, r6
    bb46:	60 e2       	ldi	r22, 0x20	; 32
    bb48:	0e 94 0f 3c 	call	0x781e	; 0x781e <PosBlink>
    bb4c:	3c 81       	ldd	r19, Y+4	; 0x04
				else{ 
					PutBuf(prb(&(OF+OF_N)->Type), &Param);
				}			
			else
				PutField(prb(&(OF+OF_N)->Type), prp(&(OF+OF_N)->Var), &Param);
			OF_N++;
    bb4e:	83 94       	inc	r8
    bb50:	5a ce       	rjmp	.-844    	; 0xb806 <PutLine+0xda>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
PutBuf(uint8_t Type, T_Param *Param)
{
	switch(Type) {
    bb52:	8e 30       	cpi	r24, 0x0E	; 14
    bb54:	b9 f1       	breq	.+110    	; 0xbbc4 <PutLine+0x498>
    bb56:	8e 30       	cpi	r24, 0x0E	; 14
    bb58:	28 f1       	brcs	.+74     	; 0xbba4 <PutLine+0x478>
    bb5a:	8d 51       	subi	r24, 0x1D	; 29
    bb5c:	84 30       	cpi	r24, 0x04	; 4
    bb5e:	08 f0       	brcs	.+2      	; 0xbb62 <PutLine+0x436>
    bb60:	da ce       	rjmp	.-588    	; 0xb916 <PutLine+0x1ea>
	case zc_Word:
		Put_zVal(F_Buf, 'w', Param);
		ValBlink(Param->Pos, Param->Size);
		break;
	case Enum: case EE_Enum: case Bit: case EE_Bit:
		Param->Txt += (uint8_t)F_Buf;
    bb62:	80 91 ef 04 	lds	r24, 0x04EF
    bb66:	90 e0       	ldi	r25, 0x00	; 0
    bb68:	88 0f       	add	r24, r24
    bb6a:	99 1f       	adc	r25, r25
    bb6c:	28 0f       	add	r18, r24
    bb6e:	39 1f       	adc	r19, r25
    bb70:	3e 83       	std	Y+6, r19	; 0x06
    bb72:	2d 83       	std	Y+5, r18	; 0x05
		PutEnum(Param);
    bb74:	c3 01       	movw	r24, r6
    bb76:	0e 94 f0 3f 	call	0x7fe0	; 0x7fe0 <PutEnum>
		ValBlink(Param->Pos, Param->Size);
    bb7a:	3c 81       	ldd	r19, Y+4	; 0x04

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
ValBlink(char *Pos, uint8_t Sz)
{
	CurrX=Pos-LCD_Buf[Y1];
    bb7c:	80 91 f7 09 	lds	r24, 0x09F7
    bb80:	f5 e1       	ldi	r31, 0x15	; 21
    bb82:	8f 9f       	mul	r24, r31
    bb84:	c0 01       	movw	r24, r0
    bb86:	11 24       	eor	r1, r1
    bb88:	80 5b       	subi	r24, 0xB0	; 176
    bb8a:	99 4f       	sbci	r25, 0xF9	; 249
    bb8c:	29 81       	ldd	r18, Y+1	; 0x01
    bb8e:	28 1b       	sub	r18, r24
    bb90:	20 93 b1 06 	sts	0x06B1, r18
	StrSize=Sz; 
    bb94:	30 93 a4 06 	sts	0x06A4, r19
				else{ 
					PutBuf(prb(&(OF+OF_N)->Type), &Param);
				}			
			else
				PutField(prb(&(OF+OF_N)->Type), prp(&(OF+OF_N)->Var), &Param);
			OF_N++;
    bb98:	83 94       	inc	r8
    bb9a:	35 ce       	rjmp	.-918    	; 0xb806 <PutLine+0xda>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
PutBuf(uint8_t Type, T_Param *Param)
{
	switch(Type) {
    bb9c:	86 30       	cpi	r24, 0x06	; 6
    bb9e:	78 f2       	brcs	.-98     	; 0xbb3e <PutLine+0x412>
    bba0:	3c 81       	ldd	r19, Y+4	; 0x04
    bba2:	ba ce       	rjmp	.-652    	; 0xb918 <PutLine+0x1ec>
	case s_Word: case s_EE_Word:
		Put_sbVal(Param);
		PosBlink(Param,' ');
		break;
	case c_Word:
		PutVal(F_Buf, 'w', Param);
    bba4:	80 91 ef 04 	lds	r24, 0x04EF
    bba8:	90 91 f0 04 	lds	r25, 0x04F0
    bbac:	67 e7       	ldi	r22, 0x77	; 119
    bbae:	a3 01       	movw	r20, r6
    bbb0:	0e 94 ee 48 	call	0x91dc	; 0x91dc <PutVal>
		ValBlink(Param->Pos, Param->Size);
    bbb4:	3c 81       	ldd	r19, Y+4	; 0x04

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
ValBlink(char *Pos, uint8_t Sz)
{
	CurrX=Pos-LCD_Buf[Y1];
    bbb6:	80 91 f7 09 	lds	r24, 0x09F7
    bbba:	b5 e1       	ldi	r27, 0x15	; 21
    bbbc:	8b 9f       	mul	r24, r27
    bbbe:	c0 01       	movw	r24, r0
    bbc0:	11 24       	eor	r1, r1
    bbc2:	e2 cf       	rjmp	.-60     	; 0xbb88 <PutLine+0x45c>
	case c_Word:
		PutVal(F_Buf, 'w', Param);
		ValBlink(Param->Pos, Param->Size);
		break;
	case zc_Word:
		Put_zVal(F_Buf, 'w', Param);
    bbc4:	80 91 ef 04 	lds	r24, 0x04EF
    bbc8:	90 91 f0 04 	lds	r25, 0x04F0
    bbcc:	67 e7       	ldi	r22, 0x77	; 119
    bbce:	a3 01       	movw	r20, r6
    bbd0:	0e 94 4d 47 	call	0x8e9a	; 0x8e9a <Put_zVal>
		ValBlink(Param->Pos, Param->Size);
    bbd4:	3c 81       	ldd	r19, Y+4	; 0x04

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
ValBlink(char *Pos, uint8_t Sz)
{
	CurrX=Pos-LCD_Buf[Y1];
    bbd6:	80 91 f7 09 	lds	r24, 0x09F7
    bbda:	e5 e1       	ldi	r30, 0x15	; 21
    bbdc:	8e 9f       	mul	r24, r30
    bbde:	c0 01       	movw	r24, r0
    bbe0:	11 24       	eor	r1, r1
    bbe2:	d2 cf       	rjmp	.-92     	; 0xbb88 <PutLine+0x45c>

0000bbe4 <MenuOut>:
	while(X<LCDXSz)	LCD_Buf[Y][X++] = ' ';
}
// ~~~~~~~~~~
void
MenuOut(void)
{
    bbe4:	2f 92       	push	r2
    bbe6:	3f 92       	push	r3
    bbe8:	4f 92       	push	r4
    bbea:	5f 92       	push	r5
    bbec:	6f 92       	push	r6
    bbee:	7f 92       	push	r7
    bbf0:	8f 92       	push	r8
    bbf2:	9f 92       	push	r9
    bbf4:	af 92       	push	r10
    bbf6:	bf 92       	push	r11
    bbf8:	cf 92       	push	r12
    bbfa:	df 92       	push	r13
    bbfc:	ef 92       	push	r14
    bbfe:	ff 92       	push	r15
    bc00:	0f 93       	push	r16
    bc02:	1f 93       	push	r17
    bc04:	df 93       	push	r29
    bc06:	cf 93       	push	r28
    bc08:	cd b7       	in	r28, 0x3d	; 61
    bc0a:	de b7       	in	r29, 0x3e	; 62
    bc0c:	2a 97       	sbiw	r28, 0x0a	; 10
    bc0e:	0f b6       	in	r0, 0x3f	; 63
    bc10:	f8 94       	cli
    bc12:	de bf       	out	0x3e, r29	; 62
    bc14:	0f be       	out	0x3f, r0	; 63
    bc16:	cd bf       	out	0x3d, r28	; 61
	uint8_t Y;
	if(CurrMsg) {
    bc18:	a0 90 ed 04 	lds	r10, 0x04ED
    bc1c:	b0 90 ee 04 	lds	r11, 0x04EE
    bc20:	a1 14       	cp	r10, r1
    bc22:	b1 04       	cpc	r11, r1
    bc24:	09 f4       	brne	.+2      	; 0xbc28 <MenuOut+0x44>
    bc26:	6a c1       	rjmp	.+724    	; 0xbefc <MenuOut+0x318>
    bc28:	22 24       	eor	r2, r2
    bc2a:	33 24       	eor	r3, r3
    bc2c:	18 86       	std	Y+8, r1	; 0x08
    bc2e:	1f 82       	std	Y+7, r1	; 0x07
	int8_t Xs = 0;
	//--- ">>" Align right
	if(prc(CurrStr+0) == '>' && prc(CurrStr+1) == '>'){
		X0 = LCDXSz - strlen_P(CurrStr) + 2;
		Xs = X0-2;
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';
    bc30:	80 e2       	ldi	r24, 0x20	; 32
    bc32:	48 2e       	mov	r4, r24
	#if TypeLCD==840
		const MsgLine *Line=(MsgLine*)prp(&CurrMsg->LineList)+Y;
	#else
		const MsgLine *Line=CurrMsg->LineList+Y;		
	#endif
	PGM_P CurrStr=(PGM_P)(Line->Str);
    bc34:	91 01       	movw	r18, r2
    bc36:	22 0f       	add	r18, r18
    bc38:	33 1f       	adc	r19, r19
    bc3a:	3a 87       	std	Y+10, r19	; 0x0a
    bc3c:	29 87       	std	Y+9, r18	; 0x09
    bc3e:	49 01       	movw	r8, r18
    bc40:	82 0c       	add	r8, r2
    bc42:	93 1c       	adc	r9, r3
    bc44:	64 01       	movw	r12, r8
    bc46:	cc 0c       	add	r12, r12
    bc48:	dd 1c       	adc	r13, r13
    bc4a:	cc 0c       	add	r12, r12
    bc4c:	dd 1c       	adc	r13, r13
    bc4e:	cc 0c       	add	r12, r12
    bc50:	dd 1c       	adc	r13, r13
    bc52:	96 01       	movw	r18, r12
    bc54:	22 19       	sub	r18, r2
    bc56:	33 09       	sbc	r19, r3
    bc58:	75 01       	movw	r14, r10
    bc5a:	e2 0e       	add	r14, r18
    bc5c:	f3 1e       	adc	r15, r19

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    bc5e:	2b 5e       	subi	r18, 0xEB	; 235
    bc60:	3f 4f       	sbci	r19, 0xFF	; 255
    bc62:	c5 01       	movw	r24, r10
    bc64:	82 0f       	add	r24, r18
    bc66:	93 1f       	adc	r25, r19
    bc68:	25 51       	subi	r18, 0x15	; 21
    bc6a:	30 40       	sbci	r19, 0x00	; 0
    bc6c:	fc 01       	movw	r30, r24
    bc6e:	65 90       	lpm	r6, Z+
    bc70:	74 90       	lpm	r7, Z+

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    bc72:	f7 01       	movw	r30, r14
    bc74:	84 91       	lpm	r24, Z+
	uint8_t X;
	uint8_t X0=0;
	uint8_t X1=LCDXSz;
	int8_t Xs = 0;
	//--- ">>" Align right
	if(prc(CurrStr+0) == '>' && prc(CurrStr+1) == '>'){
    bc76:	8e 33       	cpi	r24, 0x3E	; 62
    bc78:	09 f4       	brne	.+2      	; 0xbc7c <MenuOut+0x98>
    bc7a:	b3 c0       	rjmp	.+358    	; 0xbde2 <MenuOut+0x1fe>
		X0 = LCDXSz - strlen_P(CurrStr) + 2;
		Xs = X0-2;
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';
    bc7c:	90 e0       	ldi	r25, 0x00	; 0
    bc7e:	00 e0       	ldi	r16, 0x00	; 0
    bc80:	f7 01       	movw	r30, r14
    bc82:	84 91       	lpm	r24, Z+
	}
	//--- "<<" Align left
	if(prc(CurrStr+0) == '<' && prc(CurrStr+1) == '<'){
    bc84:	8c 33       	cpi	r24, 0x3C	; 60
    bc86:	09 f4       	brne	.+2      	; 0xbc8a <MenuOut+0xa6>
    bc88:	cd c0       	rjmp	.+410    	; 0xbe24 <MenuOut+0x240>
		X1 = strlen_P(CurrStr) - 2;
    bc8a:	f4 e1       	ldi	r31, 0x14	; 20
    bc8c:	5f 2e       	mov	r5, r31
    bc8e:	f7 01       	movw	r30, r14
    bc90:	84 91       	lpm	r24, Z+
		X0 = 0;
		Xs = X0-2;
	}
	//--- "<>" Align center
	if(prc(CurrStr+0) == '<' && prc(CurrStr+1) == '>'){
    bc92:	8c 33       	cpi	r24, 0x3C	; 60
    bc94:	09 f4       	brne	.+2      	; 0xbc98 <MenuOut+0xb4>
    bc96:	e6 c0       	rjmp	.+460    	; 0xbe64 <MenuOut+0x280>
		X1 = X0 + (strlen_P(CurrStr) - 2);
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';		
	}
	//---

	for(X=X0; X<X1; X++){
    bc98:	05 15       	cp	r16, r5
    bc9a:	08 f0       	brcs	.+2      	; 0xbc9e <MenuOut+0xba>
    bc9c:	73 c0       	rjmp	.+230    	; 0xbd84 <MenuOut+0x1a0>
		const MsgLine *Line=(MsgLine*)prp(&CurrMsg->LineList)+Y;
	#else
		const MsgLine *Line=CurrMsg->LineList+Y;		
	#endif
	PGM_P CurrStr=(PGM_P)(Line->Str);
	InField *IF = prp(&Line->IF_List);
    bc9e:	73 01       	movw	r14, r6
    bca0:	69 2e       	mov	r6, r25
    bca2:	77 24       	eor	r7, r7
    bca4:	67 fc       	sbrc	r6, 7
    bca6:	70 94       	com	r7
    bca8:	29 85       	ldd	r18, Y+9	; 0x09
    bcaa:	3a 85       	ldd	r19, Y+10	; 0x0a
    bcac:	22 0d       	add	r18, r2
    bcae:	33 1d       	adc	r19, r3
    bcb0:	c9 01       	movw	r24, r18
    bcb2:	88 0f       	add	r24, r24
    bcb4:	99 1f       	adc	r25, r25
    bcb6:	88 0f       	add	r24, r24
    bcb8:	99 1f       	adc	r25, r25
    bcba:	88 0f       	add	r24, r24
    bcbc:	99 1f       	adc	r25, r25
    bcbe:	6c 01       	movw	r12, r24
    bcc0:	c2 18       	sub	r12, r2
    bcc2:	d3 08       	sbc	r13, r3
			Param.Txt = prp(&IF->EnumList);
			PutField(prb(&IF->Type), prp(&IF->Var), &Param);
			IF++;
			X += Param.Size;
		}
		LCD_Buf[Y][X] = Char;
    bcc4:	4c 01       	movw	r8, r24
    bcc6:	82 1a       	sub	r8, r18
    bcc8:	93 0a       	sbc	r9, r19
    bcca:	09 c0       	rjmp	.+18     	; 0xbcde <MenuOut+0xfa>
    bccc:	a8 0d       	add	r26, r8
    bcce:	b9 1d       	adc	r27, r9
    bcd0:	a0 5b       	subi	r26, 0xB0	; 176
    bcd2:	b9 4f       	sbci	r27, 0xF9	; 249
    bcd4:	1c 93       	st	X, r17
		X1 = X0 + (strlen_P(CurrStr) - 2);
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';		
	}
	//---

	for(X=X0; X<X1; X++){
    bcd6:	0f 5f       	subi	r16, 0xFF	; 255
    bcd8:	05 15       	cp	r16, r5
    bcda:	08 f0       	brcs	.+2      	; 0xbcde <MenuOut+0xfa>
    bcdc:	4f c0       	rjmp	.+158    	; 0xbd7c <MenuOut+0x198>
		char Char;
		if((Char=prc(CurrStr+X-Xs))=='{') {
    bcde:	a0 2f       	mov	r26, r16
    bce0:	b0 e0       	ldi	r27, 0x00	; 0
    bce2:	9d 01       	movw	r18, r26
    bce4:	26 19       	sub	r18, r6
    bce6:	37 09       	sbc	r19, r7
    bce8:	f6 01       	movw	r30, r12
    bcea:	e2 0f       	add	r30, r18
    bcec:	f3 1f       	adc	r31, r19
    bcee:	ea 0d       	add	r30, r10
    bcf0:	fb 1d       	adc	r31, r11
    bcf2:	14 91       	lpm	r17, Z+
    bcf4:	1b 37       	cpi	r17, 0x7B	; 123
    bcf6:	51 f7       	brne	.-44     	; 0xbccc <MenuOut+0xe8>
			T_Param Param;
			Param.Pos = LCD_Buf[Y]+X;
    bcf8:	8f 81       	ldd	r24, Y+7	; 0x07
    bcfa:	98 85       	ldd	r25, Y+8	; 0x08
    bcfc:	a8 0f       	add	r26, r24
    bcfe:	b9 1f       	adc	r27, r25
    bd00:	a0 5b       	subi	r26, 0xB0	; 176
    bd02:	b9 4f       	sbci	r27, 0xF9	; 249
    bd04:	ba 83       	std	Y+2, r27	; 0x02
    bd06:	a9 83       	std	Y+1, r26	; 0x01
    bd08:	81 e0       	ldi	r24, 0x01	; 1
    bd0a:	f9 01       	movw	r30, r18
    bd0c:	e8 0f       	add	r30, r24
    bd0e:	f1 1d       	adc	r31, r1
    bd10:	ec 0d       	add	r30, r12
    bd12:	fd 1d       	adc	r31, r13
    bd14:	ea 0d       	add	r30, r10
    bd16:	fb 1d       	adc	r31, r11
    bd18:	14 91       	lpm	r17, Z+
    bd1a:	98 2f       	mov	r25, r24
    bd1c:	8f 5f       	subi	r24, 0xFF	; 255
			Param.Size = 0;
			while((Char=prc(CurrStr+X-Xs+ ++Param.Size))=='{');
    bd1e:	1b 37       	cpi	r17, 0x7B	; 123
    bd20:	a1 f3       	breq	.-24     	; 0xbd0a <MenuOut+0x126>
    bd22:	9c 83       	std	Y+4, r25	; 0x04

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    bd24:	e5 e0       	ldi	r30, 0x05	; 5
    bd26:	f0 e0       	ldi	r31, 0x00	; 0
    bd28:	ee 0e       	add	r14, r30
    bd2a:	ff 1e       	adc	r15, r31
    bd2c:	f7 01       	movw	r30, r14
    bd2e:	84 91       	lpm	r24, Z+
    bd30:	2b ef       	ldi	r18, 0xFB	; 251
    bd32:	3f ef       	ldi	r19, 0xFF	; 255
    bd34:	e2 0e       	add	r14, r18
    bd36:	f3 1e       	adc	r15, r19
			Param.Prec = prb(&IF->Prec);
    bd38:	8b 83       	std	Y+3, r24	; 0x03

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    bd3a:	f7 01       	movw	r30, r14
    bd3c:	33 96       	adiw	r30, 0x03	; 3
    bd3e:	85 91       	lpm	r24, Z+
    bd40:	94 91       	lpm	r25, Z+
			Param.Txt = prp(&IF->EnumList);
    bd42:	9e 83       	std	Y+6, r25	; 0x06
    bd44:	8d 83       	std	Y+5, r24	; 0x05

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    bd46:	f7 01       	movw	r30, r14
    bd48:	84 91       	lpm	r24, Z+

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    bd4a:	31 96       	adiw	r30, 0x01	; 1
    bd4c:	65 91       	lpm	r22, Z+
    bd4e:	74 91       	lpm	r23, Z+
			PutField(prb(&IF->Type), prp(&IF->Var), &Param);
    bd50:	ae 01       	movw	r20, r28
    bd52:	4f 5f       	subi	r20, 0xFF	; 255
    bd54:	5f 4f       	sbci	r21, 0xFF	; 255
    bd56:	0e 94 11 5a 	call	0xb422	; 0xb422 <PutField>
			IF++;
    bd5a:	26 e0       	ldi	r18, 0x06	; 6
    bd5c:	30 e0       	ldi	r19, 0x00	; 0
    bd5e:	e2 0e       	add	r14, r18
    bd60:	f3 1e       	adc	r15, r19
			X += Param.Size;
    bd62:	8c 81       	ldd	r24, Y+4	; 0x04
    bd64:	08 0f       	add	r16, r24
    bd66:	a0 2f       	mov	r26, r16
    bd68:	b0 e0       	ldi	r27, 0x00	; 0
		}
		LCD_Buf[Y][X] = Char;
    bd6a:	a8 0d       	add	r26, r8
    bd6c:	b9 1d       	adc	r27, r9
    bd6e:	a0 5b       	subi	r26, 0xB0	; 176
    bd70:	b9 4f       	sbci	r27, 0xF9	; 249
    bd72:	1c 93       	st	X, r17
		X1 = X0 + (strlen_P(CurrStr) - 2);
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';		
	}
	//---

	for(X=X0; X<X1; X++){
    bd74:	0f 5f       	subi	r16, 0xFF	; 255
    bd76:	05 15       	cp	r16, r5
    bd78:	08 f4       	brcc	.+2      	; 0xbd7c <MenuOut+0x198>
    bd7a:	b1 cf       	rjmp	.-158    	; 0xbcde <MenuOut+0xfa>
    bd7c:	a0 90 ed 04 	lds	r10, 0x04ED
    bd80:	b0 90 ee 04 	lds	r11, 0x04EE
			X += Param.Size;
		}
		LCD_Buf[Y][X] = Char;
	}
	X=X1;
	for(;X<LCDXSz; X++) LCD_Buf[Y][X] = ' ';
    bd84:	33 e1       	ldi	r19, 0x13	; 19
    bd86:	35 15       	cp	r19, r5
    bd88:	08 f0       	brcs	.+2      	; 0xbd8c <MenuOut+0x1a8>
    bd8a:	9f c0       	rjmp	.+318    	; 0xbeca <MenuOut+0x2e6>
    bd8c:	08 94       	sec
    bd8e:	21 1c       	adc	r2, r1
    bd90:	31 1c       	adc	r3, r1
    bd92:	ef 81       	ldd	r30, Y+7	; 0x07
    bd94:	f8 85       	ldd	r31, Y+8	; 0x08
    bd96:	75 96       	adiw	r30, 0x15	; 21
    bd98:	f8 87       	std	Y+8, r31	; 0x08
    bd9a:	ef 83       	std	Y+7, r30	; 0x07
void
MenuOut(void)
{
	uint8_t Y;
	if(CurrMsg) {
		for(Y=0; Y<LCDYSz; PutMsgLine(Y++));
    bd9c:	f4 e0       	ldi	r31, 0x04	; 4
    bd9e:	2f 16       	cp	r2, r31
    bda0:	31 04       	cpc	r3, r1
    bda2:	09 f0       	breq	.+2      	; 0xbda6 <MenuOut+0x1c2>
    bda4:	47 cf       	rjmp	.-370    	; 0xbc34 <MenuOut+0x50>
		EventFunc(&CurrMsg->Run);
    bda6:	c5 01       	movw	r24, r10
    bda8:	82 5a       	subi	r24, 0xA2	; 162
    bdaa:	9f 4f       	sbci	r25, 0xFF	; 255
    bdac:	0e 94 7b 3b 	call	0x76f6	; 0x76f6 <EventFunc>
	if(prb(&CurrPage->LineNumber)>LCDYSz || Fix<LCDYSz-1 || prp(&(GetLine+CurrLine)->OF_List))
		LCD_Buf[CurrLCD][0] = CharCursor;
	if(++Blink>16)
		Blink=0;
	EventFunc(&CurrPage->Run);
}
    bdb0:	2a 96       	adiw	r28, 0x0a	; 10
    bdb2:	0f b6       	in	r0, 0x3f	; 63
    bdb4:	f8 94       	cli
    bdb6:	de bf       	out	0x3e, r29	; 62
    bdb8:	0f be       	out	0x3f, r0	; 63
    bdba:	cd bf       	out	0x3d, r28	; 61
    bdbc:	cf 91       	pop	r28
    bdbe:	df 91       	pop	r29
    bdc0:	1f 91       	pop	r17
    bdc2:	0f 91       	pop	r16
    bdc4:	ff 90       	pop	r15
    bdc6:	ef 90       	pop	r14
    bdc8:	df 90       	pop	r13
    bdca:	cf 90       	pop	r12
    bdcc:	bf 90       	pop	r11
    bdce:	af 90       	pop	r10
    bdd0:	9f 90       	pop	r9
    bdd2:	8f 90       	pop	r8
    bdd4:	7f 90       	pop	r7
    bdd6:	6f 90       	pop	r6
    bdd8:	5f 90       	pop	r5
    bdda:	4f 90       	pop	r4
    bddc:	3f 90       	pop	r3
    bdde:	2f 90       	pop	r2
    bde0:	08 95       	ret

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    bde2:	f9 01       	movw	r30, r18
    bde4:	31 96       	adiw	r30, 0x01	; 1
    bde6:	ea 0d       	add	r30, r10
    bde8:	fb 1d       	adc	r31, r11
    bdea:	e4 91       	lpm	r30, Z+
	uint8_t X;
	uint8_t X0=0;
	uint8_t X1=LCDXSz;
	int8_t Xs = 0;
	//--- ">>" Align right
	if(prc(CurrStr+0) == '>' && prc(CurrStr+1) == '>'){
    bdec:	ee 33       	cpi	r30, 0x3E	; 62
    bdee:	09 f0       	breq	.+2      	; 0xbdf2 <MenuOut+0x20e>
    bdf0:	45 cf       	rjmp	.-374    	; 0xbc7c <MenuOut+0x98>
		X0 = LCDXSz - strlen_P(CurrStr) + 2;
    bdf2:	c7 01       	movw	r24, r14
    bdf4:	0e 94 8a 7a 	call	0xf514	; 0xf514 <strlen_P>
    bdf8:	06 e1       	ldi	r16, 0x16	; 22
    bdfa:	08 1b       	sub	r16, r24
		Xs = X0-2;
    bdfc:	90 2f       	mov	r25, r16
    bdfe:	92 50       	subi	r25, 0x02	; 2
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';
    be00:	00 23       	and	r16, r16
    be02:	09 f4       	brne	.+2      	; 0xbe06 <MenuOut+0x222>
    be04:	3d cf       	rjmp	.-390    	; 0xbc80 <MenuOut+0x9c>
    be06:	f6 01       	movw	r30, r12
    be08:	e8 19       	sub	r30, r8
    be0a:	f9 09       	sbc	r31, r9
    be0c:	e0 5b       	subi	r30, 0xB0	; 176
    be0e:	f9 4f       	sbci	r31, 0xF9	; 249
    be10:	80 e0       	ldi	r24, 0x00	; 0
    be12:	41 92       	st	Z+, r4
    be14:	8f 5f       	subi	r24, 0xFF	; 255
    be16:	80 17       	cp	r24, r16
    be18:	e0 f3       	brcs	.-8      	; 0xbe12 <MenuOut+0x22e>
    be1a:	f7 01       	movw	r30, r14
    be1c:	84 91       	lpm	r24, Z+
	}
	//--- "<<" Align left
	if(prc(CurrStr+0) == '<' && prc(CurrStr+1) == '<'){
    be1e:	8c 33       	cpi	r24, 0x3C	; 60
    be20:	09 f0       	breq	.+2      	; 0xbe24 <MenuOut+0x240>
    be22:	33 cf       	rjmp	.-410    	; 0xbc8a <MenuOut+0xa6>
    be24:	e9 85       	ldd	r30, Y+9	; 0x09
    be26:	fa 85       	ldd	r31, Y+10	; 0x0a
    be28:	e2 0d       	add	r30, r2
    be2a:	f3 1d       	adc	r31, r3
    be2c:	ee 0f       	add	r30, r30
    be2e:	ff 1f       	adc	r31, r31
    be30:	ee 0f       	add	r30, r30
    be32:	ff 1f       	adc	r31, r31
    be34:	ee 0f       	add	r30, r30
    be36:	ff 1f       	adc	r31, r31
    be38:	e2 19       	sub	r30, r2
    be3a:	f3 09       	sbc	r31, r3
    be3c:	31 96       	adiw	r30, 0x01	; 1
    be3e:	ea 0d       	add	r30, r10
    be40:	fb 1d       	adc	r31, r11
    be42:	e4 91       	lpm	r30, Z+
    be44:	ec 33       	cpi	r30, 0x3C	; 60
    be46:	09 f0       	breq	.+2      	; 0xbe4a <MenuOut+0x266>
    be48:	20 cf       	rjmp	.-448    	; 0xbc8a <MenuOut+0xa6>
		X1 = strlen_P(CurrStr) - 2;
    be4a:	c7 01       	movw	r24, r14
    be4c:	0e 94 8a 7a 	call	0xf514	; 0xf514 <strlen_P>
    be50:	ae ef       	ldi	r26, 0xFE	; 254
    be52:	5a 2e       	mov	r5, r26
    be54:	58 0e       	add	r5, r24
    be56:	9e ef       	ldi	r25, 0xFE	; 254
    be58:	00 e0       	ldi	r16, 0x00	; 0
    be5a:	f7 01       	movw	r30, r14
    be5c:	84 91       	lpm	r24, Z+
		X0 = 0;
		Xs = X0-2;
	}
	//--- "<>" Align center
	if(prc(CurrStr+0) == '<' && prc(CurrStr+1) == '>'){
    be5e:	8c 33       	cpi	r24, 0x3C	; 60
    be60:	09 f0       	breq	.+2      	; 0xbe64 <MenuOut+0x280>
    be62:	1a cf       	rjmp	.-460    	; 0xbc98 <MenuOut+0xb4>
    be64:	89 84       	ldd	r8, Y+9	; 0x09
    be66:	9a 84       	ldd	r9, Y+10	; 0x0a
    be68:	82 0c       	add	r8, r2
    be6a:	93 1c       	adc	r9, r3
    be6c:	64 01       	movw	r12, r8
    be6e:	cc 0c       	add	r12, r12
    be70:	dd 1c       	adc	r13, r13
    be72:	cc 0c       	add	r12, r12
    be74:	dd 1c       	adc	r13, r13
    be76:	cc 0c       	add	r12, r12
    be78:	dd 1c       	adc	r13, r13
    be7a:	f6 01       	movw	r30, r12
    be7c:	e2 19       	sub	r30, r2
    be7e:	f3 09       	sbc	r31, r3
    be80:	31 96       	adiw	r30, 0x01	; 1
    be82:	ea 0d       	add	r30, r10
    be84:	fb 1d       	adc	r31, r11
    be86:	e4 91       	lpm	r30, Z+
    be88:	ee 33       	cpi	r30, 0x3E	; 62
    be8a:	09 f0       	breq	.+2      	; 0xbe8e <MenuOut+0x2aa>
    be8c:	05 cf       	rjmp	.-502    	; 0xbc98 <MenuOut+0xb4>
		X0 = (LCDXSz - strlen_P(CurrStr) + 2) / 2;
    be8e:	c7 01       	movw	r24, r14
    be90:	0e 94 8a 7a 	call	0xf514	; 0xf514 <strlen_P>
    be94:	26 e1       	ldi	r18, 0x16	; 22
    be96:	30 e0       	ldi	r19, 0x00	; 0
    be98:	28 1b       	sub	r18, r24
    be9a:	39 0b       	sbc	r19, r25
    be9c:	36 95       	lsr	r19
    be9e:	27 95       	ror	r18
    bea0:	02 2f       	mov	r16, r18
		Xs = X0-2;
    bea2:	92 2f       	mov	r25, r18
    bea4:	92 50       	subi	r25, 0x02	; 2
		X1 = X0 + (strlen_P(CurrStr) - 2);
    bea6:	6e ef       	ldi	r22, 0xFE	; 254
    bea8:	56 2e       	mov	r5, r22
    beaa:	58 0e       	add	r5, r24
    beac:	52 0e       	add	r5, r18
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';		
    beae:	22 23       	and	r18, r18
    beb0:	09 f4       	brne	.+2      	; 0xbeb4 <MenuOut+0x2d0>
    beb2:	f2 ce       	rjmp	.-540    	; 0xbc98 <MenuOut+0xb4>
    beb4:	f6 01       	movw	r30, r12
    beb6:	e8 19       	sub	r30, r8
    beb8:	f9 09       	sbc	r31, r9
    beba:	e0 5b       	subi	r30, 0xB0	; 176
    bebc:	f9 4f       	sbci	r31, 0xF9	; 249
    bebe:	80 e0       	ldi	r24, 0x00	; 0
    bec0:	41 92       	st	Z+, r4
    bec2:	8f 5f       	subi	r24, 0xFF	; 255
    bec4:	80 17       	cp	r24, r16
    bec6:	e0 f3       	brcs	.-8      	; 0xbec0 <MenuOut+0x2dc>
    bec8:	e7 ce       	rjmp	.-562    	; 0xbc98 <MenuOut+0xb4>
			X += Param.Size;
		}
		LCD_Buf[Y][X] = Char;
	}
	X=X1;
	for(;X<LCDXSz; X++) LCD_Buf[Y][X] = ' ';
    beca:	89 85       	ldd	r24, Y+9	; 0x09
    becc:	9a 85       	ldd	r25, Y+10	; 0x0a
    bece:	82 0d       	add	r24, r2
    bed0:	93 1d       	adc	r25, r3
    bed2:	9c 01       	movw	r18, r24
    bed4:	22 0f       	add	r18, r18
    bed6:	33 1f       	adc	r19, r19
    bed8:	22 0f       	add	r18, r18
    beda:	33 1f       	adc	r19, r19
    bedc:	22 0f       	add	r18, r18
    bede:	33 1f       	adc	r19, r19
    bee0:	28 1b       	sub	r18, r24
    bee2:	39 0b       	sbc	r19, r25
    bee4:	f9 01       	movw	r30, r18
    bee6:	e5 0d       	add	r30, r5
    bee8:	f1 1d       	adc	r31, r1
    beea:	e0 5b       	subi	r30, 0xB0	; 176
    beec:	f9 4f       	sbci	r31, 0xF9	; 249
    beee:	40 82       	st	Z, r4
    bef0:	53 94       	inc	r5
    bef2:	83 e1       	ldi	r24, 0x13	; 19
    bef4:	85 15       	cp	r24, r5
    bef6:	08 f4       	brcc	.+2      	; 0xbefa <MenuOut+0x316>
    bef8:	49 cf       	rjmp	.-366    	; 0xbd8c <MenuOut+0x1a8>
    befa:	f4 cf       	rjmp	.-24     	; 0xbee4 <MenuOut+0x300>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    befc:	40 91 d1 02 	lds	r20, 0x02D1
    bf00:	50 91 d2 02 	lds	r21, 0x02D2
    bf04:	4d 5f       	subi	r20, 0xFD	; 253
    bf06:	5f 4f       	sbci	r21, 0xFF	; 255
    bf08:	fa 01       	movw	r30, r20
    bf0a:	e4 90       	lpm	r14, Z+
    bf0c:	43 50       	subi	r20, 0x03	; 3
    bf0e:	50 40       	sbci	r21, 0x00	; 0
		for(Y=0; Y<LCDYSz; PutMsgLine(Y++));
		EventFunc(&CurrMsg->Run);
		return;
	}
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
    bf10:	c0 90 7d 07 	lds	r12, 0x077D
    bf14:	d0 90 9a 08 	lds	r13, 0x089A
	for(Y=0; Y<Fix; Y++)
    bf18:	ee 20       	and	r14, r14
    bf1a:	09 f4       	brne	.+2      	; 0xbf1e <MenuOut+0x33a>
    bf1c:	a6 c0       	rjmp	.+332    	; 0xc06a <MenuOut+0x486>
    bf1e:	00 e0       	ldi	r16, 0x00	; 0
    bf20:	10 e0       	ldi	r17, 0x00	; 0
// ~~~~~~~~~~~~~~~~~~
inline static void
PutBlankLine(uint8_t Y)
{
	uint8_t X=0;
	while(X<LCDXSz)	LCD_Buf[Y][X++] = ' ';
    bf22:	80 e2       	ldi	r24, 0x20	; 32
    bf24:	f8 2e       	mov	r15, r24
    bf26:	4e 5f       	subi	r20, 0xFE	; 254
    bf28:	5f 4f       	sbci	r21, 0xFF	; 255
    bf2a:	fa 01       	movw	r30, r20
    bf2c:	84 91       	lpm	r24, Z+
    bf2e:	42 50       	subi	r20, 0x02	; 2
    bf30:	50 40       	sbci	r21, 0x00	; 0
		return;
	}
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
    bf32:	08 17       	cp	r16, r24
    bf34:	08 f4       	brcc	.+2      	; 0xbf38 <MenuOut+0x354>
    bf36:	69 c0       	rjmp	.+210    	; 0xc00a <MenuOut+0x426>
    bf38:	c8 01       	movw	r24, r16
    bf3a:	88 0f       	add	r24, r24
    bf3c:	99 1f       	adc	r25, r25
    bf3e:	80 0f       	add	r24, r16
    bf40:	91 1f       	adc	r25, r17
    bf42:	fc 01       	movw	r30, r24
    bf44:	ee 0f       	add	r30, r30
    bf46:	ff 1f       	adc	r31, r31
    bf48:	ee 0f       	add	r30, r30
    bf4a:	ff 1f       	adc	r31, r31
    bf4c:	ee 0f       	add	r30, r30
    bf4e:	ff 1f       	adc	r31, r31
    bf50:	e8 1b       	sub	r30, r24
    bf52:	f9 0b       	sbc	r31, r25
    bf54:	e0 5b       	subi	r30, 0xB0	; 176
    bf56:	f9 4f       	sbci	r31, 0xF9	; 249
    bf58:	80 e0       	ldi	r24, 0x00	; 0
// ~~~~~~~~~~~~~~~~~~
inline static void
PutBlankLine(uint8_t Y)
{
	uint8_t X=0;
	while(X<LCDXSz)	LCD_Buf[Y][X++] = ' ';
    bf5a:	f1 92       	st	Z+, r15
    bf5c:	8f 5f       	subi	r24, 0xFF	; 255
    bf5e:	84 31       	cpi	r24, 0x14	; 20
    bf60:	e1 f7       	brne	.-8      	; 0xbf5a <MenuOut+0x376>
	}
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Y, Y);
    bf62:	0f 5f       	subi	r16, 0xFF	; 255
    bf64:	1f 4f       	sbci	r17, 0xFF	; 255
		EventFunc(&CurrMsg->Run);
		return;
	}
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
    bf66:	0e 15       	cp	r16, r14
    bf68:	f0 f2       	brcs	.-68     	; 0xbf26 <MenuOut+0x342>
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Y, Y);
	for(; Y<LCDYSz; Y++)
    bf6a:	f3 e0       	ldi	r31, 0x03	; 3
    bf6c:	fe 15       	cp	r31, r14
    bf6e:	f0 f0       	brcs	.+60     	; 0xbfac <MenuOut+0x3c8>
    bf70:	1e 2d       	mov	r17, r14
		EventFunc(&CurrMsg->Run);
		return;
	}
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
    bf72:	fc 2c       	mov	r15, r12
    bf74:	fd 18       	sub	r15, r13
    bf76:	f1 0e       	add	r15, r17
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Y, Y);
	for(; Y<LCDYSz; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
    bf78:	95 e1       	ldi	r25, 0x15	; 21
    bf7a:	d9 2e       	mov	r13, r25
// ~~~~~~~~~~~~~~~~~~
inline static void
PutBlankLine(uint8_t Y)
{
	uint8_t X=0;
	while(X<LCDXSz)	LCD_Buf[Y][X++] = ' ';
    bf7c:	00 e2       	ldi	r16, 0x20	; 32
    bf7e:	4e 5f       	subi	r20, 0xFE	; 254
    bf80:	5f 4f       	sbci	r21, 0xFF	; 255
    bf82:	fa 01       	movw	r30, r20
    bf84:	84 91       	lpm	r24, Z+
    bf86:	42 50       	subi	r20, 0x02	; 2
    bf88:	50 40       	sbci	r21, 0x00	; 0
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Y, Y);
	for(; Y<LCDYSz; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
    bf8a:	18 17       	cp	r17, r24
    bf8c:	08 f4       	brcc	.+2      	; 0xbf90 <MenuOut+0x3ac>
    bf8e:	4b c0       	rjmp	.+150    	; 0xc026 <MenuOut+0x442>
    bf90:	1d 9d       	mul	r17, r13
    bf92:	f0 01       	movw	r30, r0
    bf94:	11 24       	eor	r1, r1
    bf96:	e0 5b       	subi	r30, 0xB0	; 176
    bf98:	f9 4f       	sbci	r31, 0xF9	; 249
    bf9a:	80 e0       	ldi	r24, 0x00	; 0
// ~~~~~~~~~~~~~~~~~~
inline static void
PutBlankLine(uint8_t Y)
{
	uint8_t X=0;
	while(X<LCDXSz)	LCD_Buf[Y][X++] = ' ';
    bf9c:	01 93       	st	Z+, r16
    bf9e:	8f 5f       	subi	r24, 0xFF	; 255
    bfa0:	84 31       	cpi	r24, 0x14	; 20
    bfa2:	e1 f7       	brne	.-8      	; 0xbf9c <MenuOut+0x3b8>
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Y, Y);
	for(; Y<LCDYSz; Y++)
    bfa4:	1f 5f       	subi	r17, 0xFF	; 255
    bfa6:	f3 94       	inc	r15
    bfa8:	14 30       	cpi	r17, 0x04	; 4
    bfaa:	48 f3       	brcs	.-46     	; 0xbf7e <MenuOut+0x39a>
    bfac:	4e 5f       	subi	r20, 0xFE	; 254
    bfae:	5f 4f       	sbci	r21, 0xFF	; 255
    bfb0:	fa 01       	movw	r30, r20
    bfb2:	84 91       	lpm	r24, Z+
    bfb4:	42 50       	subi	r20, 0x02	; 2
    bfb6:	50 40       	sbci	r21, 0x00	; 0
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Dist+Y, Y);
	if(prb(&CurrPage->LineNumber)>LCDYSz || Fix<LCDYSz-1 || prp(&(GetLine+CurrLine)->OF_List))
    bfb8:	85 30       	cpi	r24, 0x05	; 5
    bfba:	20 f4       	brcc	.+8      	; 0xbfc4 <MenuOut+0x3e0>
    bfbc:	f2 e0       	ldi	r31, 0x02	; 2
    bfbe:	fe 15       	cp	r31, r14
    bfc0:	08 f4       	brcc	.+2      	; 0xbfc4 <MenuOut+0x3e0>
    bfc2:	3f c0       	rjmp	.+126    	; 0xc042 <MenuOut+0x45e>
		LCD_Buf[CurrLCD][0] = CharCursor;
    bfc4:	80 91 9a 08 	lds	r24, 0x089A
    bfc8:	90 e0       	ldi	r25, 0x00	; 0
    bfca:	9c 01       	movw	r18, r24
    bfcc:	22 0f       	add	r18, r18
    bfce:	33 1f       	adc	r19, r19
    bfd0:	28 0f       	add	r18, r24
    bfd2:	39 1f       	adc	r19, r25
    bfd4:	f9 01       	movw	r30, r18
    bfd6:	ee 0f       	add	r30, r30
    bfd8:	ff 1f       	adc	r31, r31
    bfda:	ee 0f       	add	r30, r30
    bfdc:	ff 1f       	adc	r31, r31
    bfde:	ee 0f       	add	r30, r30
    bfe0:	ff 1f       	adc	r31, r31
    bfe2:	e2 1b       	sub	r30, r18
    bfe4:	f3 0b       	sbc	r31, r19
    bfe6:	e0 5b       	subi	r30, 0xB0	; 176
    bfe8:	f9 4f       	sbci	r31, 0xF9	; 249
    bfea:	80 e1       	ldi	r24, 0x10	; 16
    bfec:	80 83       	st	Z, r24
	if(++Blink>16)
    bfee:	80 91 ca 08 	lds	r24, 0x08CA
    bff2:	8f 5f       	subi	r24, 0xFF	; 255
    bff4:	80 93 ca 08 	sts	0x08CA, r24
    bff8:	81 31       	cpi	r24, 0x11	; 17
    bffa:	10 f0       	brcs	.+4      	; 0xc000 <MenuOut+0x41c>
		Blink=0;
    bffc:	10 92 ca 08 	sts	0x08CA, r1
	EventFunc(&CurrPage->Run);
    c000:	ca 01       	movw	r24, r20
    c002:	08 96       	adiw	r24, 0x08	; 8
    c004:	0e 94 7b 3b 	call	0x76f6	; 0x76f6 <EventFunc>
    c008:	d3 ce       	rjmp	.-602    	; 0xbdb0 <MenuOut+0x1cc>
	}
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Y, Y);
    c00a:	80 2f       	mov	r24, r16
    c00c:	60 2f       	mov	r22, r16
    c00e:	0e 94 96 5b 	call	0xb72c	; 0xb72c <PutLine>
    c012:	40 91 d1 02 	lds	r20, 0x02D1
    c016:	50 91 d2 02 	lds	r21, 0x02D2
    c01a:	0f 5f       	subi	r16, 0xFF	; 255
    c01c:	1f 4f       	sbci	r17, 0xFF	; 255
		EventFunc(&CurrMsg->Run);
		return;
	}
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
    c01e:	0e 15       	cp	r16, r14
    c020:	08 f4       	brcc	.+2      	; 0xc024 <MenuOut+0x440>
    c022:	81 cf       	rjmp	.-254    	; 0xbf26 <MenuOut+0x342>
    c024:	a2 cf       	rjmp	.-188    	; 0xbf6a <MenuOut+0x386>
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Y, Y);
	for(; Y<LCDYSz; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Dist+Y, Y);
    c026:	8f 2d       	mov	r24, r15
    c028:	61 2f       	mov	r22, r17
    c02a:	0e 94 96 5b 	call	0xb72c	; 0xb72c <PutLine>
    c02e:	40 91 d1 02 	lds	r20, 0x02D1
    c032:	50 91 d2 02 	lds	r21, 0x02D2
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Y, Y);
	for(; Y<LCDYSz; Y++)
    c036:	1f 5f       	subi	r17, 0xFF	; 255
    c038:	f3 94       	inc	r15
    c03a:	14 30       	cpi	r17, 0x04	; 4
    c03c:	08 f4       	brcc	.+2      	; 0xc040 <MenuOut+0x45c>
    c03e:	9f cf       	rjmp	.-194    	; 0xbf7e <MenuOut+0x39a>
    c040:	b5 cf       	rjmp	.-150    	; 0xbfac <MenuOut+0x3c8>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    c042:	fa 01       	movw	r30, r20
    c044:	65 91       	lpm	r22, Z+
    c046:	74 91       	lpm	r23, Z+
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Dist+Y, Y);
	if(prb(&CurrPage->LineNumber)>LCDYSz || Fix<LCDYSz-1 || prp(&(GetLine+CurrLine)->OF_List))
    c048:	80 91 7d 07 	lds	r24, 0x077D
    c04c:	2b e1       	ldi	r18, 0x1B	; 27
    c04e:	82 9f       	mul	r24, r18
    c050:	c0 01       	movw	r24, r0
    c052:	11 24       	eor	r1, r1
    c054:	68 0f       	add	r22, r24
    c056:	79 1f       	adc	r23, r25
    c058:	69 5e       	subi	r22, 0xE9	; 233
    c05a:	7f 4f       	sbci	r23, 0xFF	; 255
    c05c:	fb 01       	movw	r30, r22
    c05e:	85 91       	lpm	r24, Z+
    c060:	94 91       	lpm	r25, Z+
    c062:	89 2b       	or	r24, r25
    c064:	09 f0       	breq	.+2      	; 0xc068 <MenuOut+0x484>
    c066:	ae cf       	rjmp	.-164    	; 0xbfc4 <MenuOut+0x3e0>
    c068:	c2 cf       	rjmp	.-124    	; 0xbfee <MenuOut+0x40a>
		EventFunc(&CurrMsg->Run);
		return;
	}
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
    c06a:	10 e0       	ldi	r17, 0x00	; 0
    c06c:	82 cf       	rjmp	.-252    	; 0xbf72 <MenuOut+0x38e>

0000c06e <LCD_Sweep>:

// ~~~~~~~~~~~~
static void
LCD_Sweep(void)
{
	if(LCD_Rdy()) {
    c06e:	0e 94 8a 25 	call	0x4b14	; 0x4b14 <LCD_Rdy>
    c072:	88 23       	and	r24, r24
    c074:	09 f4       	brne	.+2      	; 0xc078 <LCD_Sweep+0xa>
    c076:	08 95       	ret
		MenuOut();
    c078:	0e 94 f2 5d 	call	0xbbe4	; 0xbbe4 <MenuOut>
		LCD_Out();
    c07c:	0e 94 a0 25 	call	0x4b40	; 0x4b40 <LCD_Out>
    c080:	08 95       	ret

0000c082 <strcpy_EE>:
	}//while
	return GSM_RxCharN;
}
// ~~~~~~~~~~~
//    EEPROM   RAM     '\0'    EEPROM
uint8_t strcpy_EE(char* str_RAM, uint8_t* str_EE){
    c082:	cf 92       	push	r12
    c084:	df 92       	push	r13
    c086:	ef 92       	push	r14
    c088:	ff 92       	push	r15
    c08a:	1f 93       	push	r17
    c08c:	cf 93       	push	r28
    c08e:	df 93       	push	r29
    c090:	6c 01       	movw	r12, r24
    c092:	7b 01       	movw	r14, r22
    c094:	10 e0       	ldi	r17, 0x00	; 0
    c096:	06 c0       	rjmp	.+12     	; 0xc0a4 <strcpy_EE+0x22>
	uint8_t i=0;
	while( (erb(&str_EE[i])!='\0') && (erb(&str_EE[i])!=' ') ){
    c098:	80 32       	cpi	r24, 0x20	; 32
    c09a:	69 f0       	breq	.+26     	; 0xc0b6 <strcpy_EE+0x34>
		str_RAM[i] = (char)erb(&str_EE[i]);
    c09c:	cc 0d       	add	r28, r12
    c09e:	dd 1d       	adc	r29, r13
    c0a0:	88 83       	st	Y, r24
		i++;
    c0a2:	1f 5f       	subi	r17, 0xFF	; 255
}
// ~~~~~~~~~~~
//    EEPROM   RAM     '\0'    EEPROM
uint8_t strcpy_EE(char* str_RAM, uint8_t* str_EE){
	uint8_t i=0;
	while( (erb(&str_EE[i])!='\0') && (erb(&str_EE[i])!=' ') ){
    c0a4:	c1 2f       	mov	r28, r17
    c0a6:	d0 e0       	ldi	r29, 0x00	; 0
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    c0a8:	c7 01       	movw	r24, r14
    c0aa:	8c 0f       	add	r24, r28
    c0ac:	9d 1f       	adc	r25, r29
    c0ae:	0e 94 a4 7d 	call	0xfb48	; 0xfb48 <__eerd_byte_m2560>
    c0b2:	88 23       	and	r24, r24
    c0b4:	89 f7       	brne	.-30     	; 0xc098 <strcpy_EE+0x16>
		str_RAM[i] = (char)erb(&str_EE[i]);
		i++;
	}
	return i;	
}
    c0b6:	81 2f       	mov	r24, r17
    c0b8:	df 91       	pop	r29
    c0ba:	cf 91       	pop	r28
    c0bc:	1f 91       	pop	r17
    c0be:	ff 90       	pop	r15
    c0c0:	ef 90       	pop	r14
    c0c2:	df 90       	pop	r13
    c0c4:	cf 90       	pop	r12
    c0c6:	08 95       	ret

0000c0c8 <GSM_Cycle>:
	}//switch
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
void
GSM_Cycle(void)
{
    c0c8:	7f 92       	push	r7
    c0ca:	8f 92       	push	r8
    c0cc:	9f 92       	push	r9
    c0ce:	af 92       	push	r10
    c0d0:	bf 92       	push	r11
    c0d2:	cf 92       	push	r12
    c0d4:	df 92       	push	r13
    c0d6:	ef 92       	push	r14
    c0d8:	ff 92       	push	r15
    c0da:	0f 93       	push	r16
    c0dc:	1f 93       	push	r17
    c0de:	df 93       	push	r29
    c0e0:	cf 93       	push	r28
    c0e2:	cd b7       	in	r28, 0x3d	; 61
    c0e4:	de b7       	in	r29, 0x3e	; 62
    c0e6:	65 97       	sbiw	r28, 0x15	; 21
    c0e8:	0f b6       	in	r0, 0x3f	; 63
    c0ea:	f8 94       	cli
    c0ec:	de bf       	out	0x3e, r29	; 62
    c0ee:	0f be       	out	0x3f, r0	; 63
    c0f0:	cd bf       	out	0x3d, r28	; 61
	switch(GSM_Control){
    c0f2:	80 91 84 07 	lds	r24, 0x0784
    c0f6:	88 23       	and	r24, r24
    c0f8:	d9 f4       	brne	.+54     	; 0xc130 <GSM_Cycle+0x68>
uint8_t counter=0;

// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Auto(){

	switch(GSM_State){
    c0fa:	80 91 ad 06 	lds	r24, 0x06AD
    c0fe:	e8 2f       	mov	r30, r24
    c100:	f0 e0       	ldi	r31, 0x00	; 0
    c102:	e8 35       	cpi	r30, 0x58	; 88
    c104:	f1 05       	cpc	r31, r1
    c106:	50 f1       	brcs	.+84     	; 0xc15c <GSM_Cycle+0x94>
			break;	
		case GSM_CNTL_CONFIG:
			GSM_Config();
			break;								
	}
}
    c108:	65 96       	adiw	r28, 0x15	; 21
    c10a:	0f b6       	in	r0, 0x3f	; 63
    c10c:	f8 94       	cli
    c10e:	de bf       	out	0x3e, r29	; 62
    c110:	0f be       	out	0x3f, r0	; 63
    c112:	cd bf       	out	0x3d, r28	; 61
    c114:	cf 91       	pop	r28
    c116:	df 91       	pop	r29
    c118:	1f 91       	pop	r17
    c11a:	0f 91       	pop	r16
    c11c:	ff 90       	pop	r15
    c11e:	ef 90       	pop	r14
    c120:	df 90       	pop	r13
    c122:	cf 90       	pop	r12
    c124:	bf 90       	pop	r11
    c126:	af 90       	pop	r10
    c128:	9f 90       	pop	r9
    c12a:	8f 90       	pop	r8
    c12c:	7f 90       	pop	r7
    c12e:	08 95       	ret
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
void
GSM_Cycle(void)
{
	switch(GSM_Control){
    c130:	82 30       	cpi	r24, 0x02	; 2
    c132:	51 f7       	brne	.-44     	; 0xc108 <GSM_Cycle+0x40>
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Manual(){}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Config(){
	switch(GSM_State){
    c134:	80 91 ad 06 	lds	r24, 0x06AD
    c138:	84 30       	cpi	r24, 0x04	; 4
    c13a:	09 f4       	brne	.+2      	; 0xc13e <GSM_Cycle+0x76>
    c13c:	a3 c6       	rjmp	.+3398   	; 0xce84 <GSM_Cycle+0xdbc>
    c13e:	85 30       	cpi	r24, 0x05	; 5
    c140:	a8 f0       	brcs	.+42     	; 0xc16c <GSM_Cycle+0xa4>
    c142:	86 30       	cpi	r24, 0x06	; 6
    c144:	09 f4       	brne	.+2      	; 0xc148 <GSM_Cycle+0x80>
    c146:	b2 c6       	rjmp	.+3428   	; 0xceac <GSM_Cycle+0xde4>
    c148:	86 30       	cpi	r24, 0x06	; 6
    c14a:	30 f1       	brcs	.+76     	; 0xc198 <GSM_Cycle+0xd0>
    c14c:	87 30       	cpi	r24, 0x07	; 7
    c14e:	09 f4       	brne	.+2      	; 0xc152 <GSM_Cycle+0x8a>
    c150:	8c c6       	rjmp	.+3352   	; 0xce6a <GSM_Cycle+0xda2>
    c152:	88 30       	cpi	r24, 0x08	; 8
    c154:	c9 f2       	breq	.-78     	; 0xc108 <GSM_Cycle+0x40>
			if(Timer16Stopp(TD_GSM)) GSM_State++;
			break;
		case GSM_FINISH:			
			break;
		default:
			GSM_State = GSM_CFG_START;
    c156:	10 92 ad 06 	sts	0x06AD, r1
    c15a:	d6 cf       	rjmp	.-84     	; 0xc108 <GSM_Cycle+0x40>
uint8_t counter=0;

// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Auto(){

	switch(GSM_State){
    c15c:	e4 50       	subi	r30, 0x04	; 4
    c15e:	ff 4f       	sbci	r31, 0xFF	; 255
    c160:	ee 0f       	add	r30, r30
    c162:	ff 1f       	adc	r31, r31
    c164:	05 90       	lpm	r0, Z+
    c166:	f4 91       	lpm	r31, Z+
    c168:	e0 2d       	mov	r30, r0
    c16a:	19 94       	eijmp
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Manual(){}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Config(){
	switch(GSM_State){
    c16c:	81 30       	cpi	r24, 0x01	; 1
    c16e:	09 f4       	brne	.+2      	; 0xc172 <GSM_Cycle+0xaa>
    c170:	6a c6       	rjmp	.+3284   	; 0xce46 <GSM_Cycle+0xd7e>
    c172:	81 30       	cpi	r24, 0x01	; 1
    c174:	e8 f0       	brcs	.+58     	; 0xc1b0 <GSM_Cycle+0xe8>
    c176:	82 30       	cpi	r24, 0x02	; 2
    c178:	09 f4       	brne	.+2      	; 0xc17c <GSM_Cycle+0xb4>
    c17a:	ac c6       	rjmp	.+3416   	; 0xced4 <GSM_Cycle+0xe0c>
    c17c:	83 30       	cpi	r24, 0x03	; 3
    c17e:	59 f7       	brne	.-42     	; 0xc156 <GSM_Cycle+0x8e>
			break;
		case GSM_CFG_WAIT_AT_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_CFG_SEND_AT)) GSM_State++;
			break;
		case GSM_CFG_SEND_IPR:
			GSM_Execute_Command(AT_IPR9600, 100); GSM_State++;
    c180:	83 e6       	ldi	r24, 0x63	; 99
    c182:	94 e0       	ldi	r25, 0x04	; 4
    c184:	64 e6       	ldi	r22, 0x64	; 100
    c186:	70 e0       	ldi	r23, 0x00	; 0
    c188:	0e 94 06 4a 	call	0x940c	; 0x940c <GSM_Execute_Command>
    c18c:	80 91 ad 06 	lds	r24, 0x06AD
    c190:	8f 5f       	subi	r24, 0xFF	; 255
    c192:	80 93 ad 06 	sts	0x06AD, r24
    c196:	b8 cf       	rjmp	.-144    	; 0xc108 <GSM_Cycle+0x40>
				StartTimer16(TD_GSM,200);
				GSM_State++;
			}
			break;
		case GSM_CFG_SEND_ATW:
			GSM_Execute_Command(AT_W, 100); GSM_State++;
    c198:	8f e6       	ldi	r24, 0x6F	; 111
    c19a:	94 e0       	ldi	r25, 0x04	; 4
    c19c:	64 e6       	ldi	r22, 0x64	; 100
    c19e:	70 e0       	ldi	r23, 0x00	; 0
    c1a0:	0e 94 06 4a 	call	0x940c	; 0x940c <GSM_Execute_Command>
    c1a4:	80 91 ad 06 	lds	r24, 0x06AD
    c1a8:	8f 5f       	subi	r24, 0xFF	; 255
    c1aa:	80 93 ad 06 	sts	0x06AD, r24
    c1ae:	ac cf       	rjmp	.-168    	; 0xc108 <GSM_Cycle+0x40>
inline static void GSM_Manual(){}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Config(){
	switch(GSM_State){
		case GSM_CFG_START:
			StartTimer16(TD_GSM,200);
    c1b0:	80 91 e1 04 	lds	r24, 0x04E1
    c1b4:	68 ec       	ldi	r22, 0xC8	; 200
    c1b6:	70 e0       	ldi	r23, 0x00	; 0
    c1b8:	0e 94 1d 1a 	call	0x343a	; 0x343a <StartTimer16>
		cli();
		PORTL|=(1<<PL5);
		sei();
	}
	void GSM_PWRCNTRL_ON(void){
		cli();
    c1bc:	f8 94       	cli
		PORTL &= ~(1<<PL5);
    c1be:	80 91 0b 01 	lds	r24, 0x010B
    c1c2:	8f 7d       	andi	r24, 0xDF	; 223
    c1c4:	80 93 0b 01 	sts	0x010B, r24
		sei();
    c1c8:	78 94       	sei
			GSM_PWRCNTRL_ON();
			GSM_State++;
    c1ca:	80 91 ad 06 	lds	r24, 0x06AD
    c1ce:	8f 5f       	subi	r24, 0xFF	; 255
    c1d0:	80 93 ad 06 	sts	0x06AD, r24
    c1d4:	99 cf       	rjmp	.-206    	; 0xc108 <GSM_Cycle+0x40>
			break;
		case GSM_SEND_CGMM:
			GSM_Execute_Command(AT_CGMM,5000*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CGMM_READ:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
    c1d6:	80 91 e1 04 	lds	r24, 0x04E1
    c1da:	0e 94 59 1b 	call	0x36b2	; 0x36b2 <Timer16Stopp>
    c1de:	88 23       	and	r24, r24
    c1e0:	19 f0       	breq	.+6      	; 0xc1e8 <GSM_Cycle+0x120>
    c1e2:	88 e4       	ldi	r24, 0x48	; 72
    c1e4:	80 93 ad 06 	sts	0x06AD, r24
			if(GetStringFromFIFO()){
    c1e8:	0e 94 d3 37 	call	0x6fa6	; 0x6fa6 <GetStringFromFIFO>
    c1ec:	88 23       	and	r24, r24
    c1ee:	39 f1       	breq	.+78     	; 0xc23e <GSM_Cycle+0x176>
				if(!strcmp_P(GSM_RxStr, GSM_SIMCOM_SIM900R)) GSM_Modem = SIMCOM_SIM900R;
    c1f0:	83 e9       	ldi	r24, 0x93	; 147
    c1f2:	97 e0       	ldi	r25, 0x07	; 7
    c1f4:	67 e5       	ldi	r22, 0x57	; 87
    c1f6:	73 e0       	ldi	r23, 0x03	; 3
    c1f8:	0e 94 7a 7a 	call	0xf4f4	; 0xf4f4 <strcmp_P>
    c1fc:	89 2b       	or	r24, r25
    c1fe:	19 f4       	brne	.+6      	; 0xc206 <GSM_Cycle+0x13e>
    c200:	81 e0       	ldi	r24, 0x01	; 1
    c202:	80 93 eb 06 	sts	0x06EB, r24
				if(!strcmp_P(GSM_RxStr, GSM_SIMCOM_SIM800)) GSM_Modem = SIMCOM_SIM800;
    c206:	83 e9       	ldi	r24, 0x93	; 147
    c208:	97 e0       	ldi	r25, 0x07	; 7
    c20a:	66 e6       	ldi	r22, 0x66	; 102
    c20c:	73 e0       	ldi	r23, 0x03	; 3
    c20e:	0e 94 7a 7a 	call	0xf4f4	; 0xf4f4 <strcmp_P>
    c212:	89 2b       	or	r24, r25
    c214:	19 f4       	brne	.+6      	; 0xc21c <GSM_Cycle+0x154>
    c216:	82 e0       	ldi	r24, 0x02	; 2
    c218:	80 93 eb 06 	sts	0x06EB, r24
				if(!strcmp_P(GSM_RxStr, GSM_SIMCOM_SIM800C)) GSM_Modem = SIMCOM_SIM800;
    c21c:	83 e9       	ldi	r24, 0x93	; 147
    c21e:	97 e0       	ldi	r25, 0x07	; 7
    c220:	64 e7       	ldi	r22, 0x74	; 116
    c222:	73 e0       	ldi	r23, 0x03	; 3
    c224:	0e 94 7a 7a 	call	0xf4f4	; 0xf4f4 <strcmp_P>
    c228:	89 2b       	or	r24, r25
    c22a:	11 f4       	brne	.+4      	; 0xc230 <GSM_Cycle+0x168>
    c22c:	0c 94 f3 69 	jmp	0xd3e6	; 0xd3e6 <GSM_Cycle+0x131e>
				//Add here new model GSM-modem
				if(GSM_Modem != NOT_RECOGNIZED) GSM_State = GSM_WAIT_CALL_READY;
    c230:	80 91 eb 06 	lds	r24, 0x06EB
    c234:	88 23       	and	r24, r24
    c236:	19 f0       	breq	.+6      	; 0xc23e <GSM_Cycle+0x176>
    c238:	86 e0       	ldi	r24, 0x06	; 6
    c23a:	80 93 ad 06 	sts	0x06AD, r24
			}
		case GSM_WAIT_CFUN:
			if(GSM_Wait_Response_P(URC_CFUN, GSM_ReStart1)) GSM_State++;
    c23e:	87 e8       	ldi	r24, 0x87	; 135
    c240:	93 e0       	ldi	r25, 0x03	; 3
    c242:	68 e4       	ldi	r22, 0x48	; 72
    c244:	0e 94 ab 49 	call	0x9356	; 0x9356 <GSM_Wait_Response_P>
    c248:	88 23       	and	r24, r24
    c24a:	09 f4       	brne	.+2      	; 0xc24e <GSM_Cycle+0x186>
    c24c:	5d cf       	rjmp	.-326    	; 0xc108 <GSM_Cycle+0x40>
    c24e:	80 91 ad 06 	lds	r24, 0x06AD
    c252:	8f 5f       	subi	r24, 0xFF	; 255
    c254:	80 93 ad 06 	sts	0x06AD, r24
    c258:	57 cf       	rjmp	.-338    	; 0xc108 <GSM_Cycle+0x40>
		case GSM_WAIT_R2D_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;

		case GSM_WAIT_R2D_CONNECT:
			if(GSM_Wait_Response_P(RESP_CONNECT, GSM_ReStart1)){ 				
    c25a:	80 ef       	ldi	r24, 0xF0	; 240
    c25c:	93 e0       	ldi	r25, 0x03	; 3
    c25e:	68 e4       	ldi	r22, 0x48	; 72
    c260:	0e 94 ab 49 	call	0x9356	; 0x9356 <GSM_Wait_Response_P>
    c264:	88 23       	and	r24, r24
    c266:	09 f4       	brne	.+2      	; 0xc26a <GSM_Cycle+0x1a2>
    c268:	4f cf       	rjmp	.-354    	; 0xc108 <GSM_Cycle+0x40>
				GSM_State=GSM_ProtocolMode;
    c26a:	80 e5       	ldi	r24, 0x50	; 80
    c26c:	80 93 ad 06 	sts	0x06AD, r24
				StartTimer16(TD_timer_after_page_transfer,100);
    c270:	80 91 e9 04 	lds	r24, 0x04E9
    c274:	64 e6       	ldi	r22, 0x64	; 100
    c276:	70 e0       	ldi	r23, 0x00	; 0
    c278:	0e 94 1d 1a 	call	0x343a	; 0x343a <StartTimer16>
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    c27c:	8f ef       	ldi	r24, 0xFF	; 255
    c27e:	80 93 f4 06 	sts	0x06F4, r24
	GSM_RX_FIFO_End = 255;
    c282:	80 93 4b 06 	sts	0x064B, r24
	GSM_RxCharN = 0;
    c286:	10 92 12 0b 	sts	0x0B12, r1
	GSM_RX_FIFOOverFlow = 0;
    c28a:	10 92 c5 08 	sts	0x08C5, r1
	GSM_RX_FIFOMax = 0;
    c28e:	10 92 cb 08 	sts	0x08CB, r1
    c292:	3a cf       	rjmp	.-396    	; 0xc108 <GSM_Cycle+0x40>
			GSM_State=GSM_WAIT_R2D_CONNECT;
		
			break;

		case GSM_WAIT_R2D_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    c294:	8d ee       	ldi	r24, 0xED	; 237
    c296:	93 e0       	ldi	r25, 0x03	; 3
    c298:	68 e4       	ldi	r22, 0x48	; 72
    c29a:	0e 94 ab 49 	call	0x9356	; 0x9356 <GSM_Wait_Response_P>
    c29e:	88 23       	and	r24, r24
    c2a0:	09 f4       	brne	.+2      	; 0xc2a4 <GSM_Cycle+0x1dc>
    c2a2:	32 cf       	rjmp	.-412    	; 0xc108 <GSM_Cycle+0x40>
    c2a4:	80 91 ad 06 	lds	r24, 0x06AD
    c2a8:	8f 5f       	subi	r24, 0xFF	; 255
    c2aa:	80 93 ad 06 	sts	0x06AD, r24
    c2ae:	2c cf       	rjmp	.-424    	; 0xc108 <GSM_Cycle+0x40>
			break;

		//----  data mode
		case GSM_Return2dataMode:

			CommandModeDestination=0;
    c2b0:	10 92 65 07 	sts	0x0765, r1
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    c2b4:	8f ef       	ldi	r24, 0xFF	; 255
    c2b6:	80 93 f4 06 	sts	0x06F4, r24
	GSM_RX_FIFO_End = 255;
    c2ba:	80 93 4b 06 	sts	0x064B, r24
	GSM_RxCharN = 0;
    c2be:	10 92 12 0b 	sts	0x0B12, r1
	GSM_RX_FIFOOverFlow = 0;
    c2c2:	10 92 c5 08 	sts	0x08C5, r1
	GSM_RX_FIFOMax = 0;
    c2c6:	10 92 cb 08 	sts	0x08CB, r1
    c2ca:	e3 e9       	ldi	r30, 0x93	; 147
    c2cc:	f7 e0       	ldi	r31, 0x07	; 7

			CommandModeDestination=0;
			InitFIFO();
			for(int i=0;i<GSM_RXSTR_SIZE;i++)
			{
				GSM_RxStr[i]=0;	
    c2ce:	11 92       	st	Z+, r1
		//----  data mode
		case GSM_Return2dataMode:

			CommandModeDestination=0;
			InitFIFO();
			for(int i=0;i<GSM_RXSTR_SIZE;i++)
    c2d0:	b7 e0       	ldi	r27, 0x07	; 7
    c2d2:	e7 3f       	cpi	r30, 0xF7	; 247
    c2d4:	fb 07       	cpc	r31, r27
    c2d6:	d9 f7       	brne	.-10     	; 0xc2ce <GSM_Cycle+0x206>
			{
				GSM_RxStr[i]=0;	
			}
			GSM_Execute_Command(ATO, 600*GSM_DEBUG_DELAY); //GSM_State++;
    c2d8:	84 ef       	ldi	r24, 0xF4	; 244
    c2da:	95 e0       	ldi	r25, 0x05	; 5
    c2dc:	68 e5       	ldi	r22, 0x58	; 88
    c2de:	72 e0       	ldi	r23, 0x02	; 2
    c2e0:	0e 94 06 4a 	call	0x940c	; 0x940c <GSM_Execute_Command>
			GSM_State=GSM_WAIT_R2D_CONNECT;
    c2e4:	87 e5       	ldi	r24, 0x57	; 87
    c2e6:	80 93 ad 06 	sts	0x06AD, r24
    c2ea:	0e cf       	rjmp	.-484    	; 0xc108 <GSM_Cycle+0x40>
		case GSM_WAIT_CPIN_READY:
			if(GSM_Wait_Response_P(URC_CPIN_READY, GSM_ReStart1)) GSM_State++;
			break;

		case GSM_WAIT_CALL_READY:
			if(GSM_Wait_Response_P(URC_CALL_READY, GSM_ReStart1)){
    c2ec:	8d e9       	ldi	r24, 0x9D	; 157
    c2ee:	93 e0       	ldi	r25, 0x03	; 3
    c2f0:	68 e4       	ldi	r22, 0x48	; 72
    c2f2:	0e 94 ab 49 	call	0x9356	; 0x9356 <GSM_Wait_Response_P>
    c2f6:	88 23       	and	r24, r24
    c2f8:	09 f4       	brne	.+2      	; 0xc2fc <GSM_Cycle+0x234>
    c2fa:	06 cf       	rjmp	.-500    	; 0xc108 <GSM_Cycle+0x40>
				if(GSM_Modem == SIMCOM_SIM800) GSM_State = GSM_WAIT_SMS_READY;
    c2fc:	80 91 eb 06 	lds	r24, 0x06EB
    c300:	82 30       	cpi	r24, 0x02	; 2
    c302:	11 f4       	brne	.+4      	; 0xc308 <GSM_Cycle+0x240>
    c304:	0c 94 ee 69 	jmp	0xd3dc	; 0xd3dc <GSM_Cycle+0x1314>
				else GSM_State = GSM_SEND_E0;
    c308:	88 e0       	ldi	r24, 0x08	; 8
    c30a:	80 93 ad 06 	sts	0x06AD, r24
    c30e:	fc ce       	rjmp	.-520    	; 0xc108 <GSM_Cycle+0x40>
				StartTimer16(TD_GSM,1000);	// min 500ms after +++
				GSM_State++;
			}
			break;
		case GSM_WAIT_D2C_SWITCH_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) {
    c310:	8d ee       	ldi	r24, 0xED	; 237
    c312:	93 e0       	ldi	r25, 0x03	; 3
    c314:	68 e4       	ldi	r22, 0x48	; 72
    c316:	0e 94 ab 49 	call	0x9356	; 0x9356 <GSM_Wait_Response_P>
    c31a:	88 23       	and	r24, r24
    c31c:	09 f4       	brne	.+2      	; 0xc320 <GSM_Cycle+0x258>
    c31e:	f4 ce       	rjmp	.-536    	; 0xc108 <GSM_Cycle+0x40>

				switch(CommandModeDestination){
    c320:	80 91 65 07 	lds	r24, 0x0765
    c324:	82 30       	cpi	r24, 0x02	; 2
    c326:	11 f4       	brne	.+4      	; 0xc32c <GSM_Cycle+0x264>
    c328:	0c 94 f8 69 	jmp	0xd3f0	; 0xd3f0 <GSM_Cycle+0x1328>
    c32c:	83 30       	cpi	r24, 0x03	; 3
    c32e:	10 f0       	brcs	.+4      	; 0xc334 <GSM_Cycle+0x26c>
    c330:	0c 94 c9 69 	jmp	0xd392	; 0xd392 <GSM_Cycle+0x12ca>
    c334:	81 30       	cpi	r24, 0x01	; 1
    c336:	11 f4       	brne	.+4      	; 0xc33c <GSM_Cycle+0x274>
    c338:	0c 94 ff 69 	jmp	0xd3fe	; 0xd3fe <GSM_Cycle+0x1336>
						break;
					case 5:	
						GSM_State = GSM_SEND_CSQ;
						counter=0;	
						break;
					default:GSM_State = GSM_Return2dataMode;
    c33c:	85 e5       	ldi	r24, 0x55	; 85
    c33e:	80 93 ad 06 	sts	0x06AD, r24
    c342:	e2 ce       	rjmp	.-572    	; 0xc108 <GSM_Cycle+0x40>

		case GSM_SEND_CIPTKA:
			GSM_Execute_Command(AT_CIPTKA, 1000*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CIPTKA_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    c344:	8d ee       	ldi	r24, 0xED	; 237
    c346:	93 e0       	ldi	r25, 0x03	; 3
    c348:	68 e4       	ldi	r22, 0x48	; 72
    c34a:	0e 94 ab 49 	call	0x9356	; 0x9356 <GSM_Wait_Response_P>
    c34e:	88 23       	and	r24, r24
    c350:	09 f4       	brne	.+2      	; 0xc354 <GSM_Cycle+0x28c>
    c352:	da ce       	rjmp	.-588    	; 0xc108 <GSM_Cycle+0x40>
    c354:	80 91 ad 06 	lds	r24, 0x06AD
    c358:	8f 5f       	subi	r24, 0xFF	; 255
    c35a:	80 93 ad 06 	sts	0x06AD, r24
    c35e:	d4 ce       	rjmp	.-600    	; 0xc108 <GSM_Cycle+0x40>
				StartTimer16(TD_GSM, 300*GSM_DEBUG_DELAY);
			}
			GSM_State++;
			break;
		case GSM_WAIT_CIPCSGP_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    c360:	8d ee       	ldi	r24, 0xED	; 237
    c362:	93 e0       	ldi	r25, 0x03	; 3
    c364:	68 e4       	ldi	r22, 0x48	; 72
    c366:	0e 94 ab 49 	call	0x9356	; 0x9356 <GSM_Wait_Response_P>
    c36a:	88 23       	and	r24, r24
    c36c:	09 f4       	brne	.+2      	; 0xc370 <GSM_Cycle+0x2a8>
    c36e:	cc ce       	rjmp	.-616    	; 0xc108 <GSM_Cycle+0x40>
			 if(GSM_Modem == SIMCOM_SIM800)GSM_State++;
    c370:	80 91 eb 06 	lds	r24, 0x06EB
    c374:	82 30       	cpi	r24, 0x02	; 2
    c376:	11 f4       	brne	.+4      	; 0xc37c <GSM_Cycle+0x2b4>
    c378:	0c 94 d7 69 	jmp	0xd3ae	; 0xd3ae <GSM_Cycle+0x12e6>
			 else GSM_State=GSM_SEND_CSTT;
    c37c:	83 e3       	ldi	r24, 0x33	; 51
    c37e:	80 93 ad 06 	sts	0x06AD, r24
    c382:	c2 ce       	rjmp	.-636    	; 0xc108 <GSM_Cycle+0x40>
			if(GSM_Wait_Response_P(RESP_OK, GSM_SEND_CGATT)) GSM_State++;
			break;

		case GSM_SEND_CIPCSGP:
			//GSM_Execute_Command(AT_CIPCSGP, 300*GSM_DEBUG_DELAY); GSM_State++;
			if(GSM_Flag & (1<<flg_TxCStr)){
    c384:	80 91 cf 02 	lds	r24, 0x02CF
    c388:	80 fd       	sbrc	r24, 0
    c38a:	5e c7       	rjmp	.+3772   	; 0xd248 <GSM_Cycle+0x1180>
				GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn_psw);
				sprintf(GSM_TxStr + GSMTxSz, "\"\r");	GSMTxSz = GSMTxSz+2;
				GSM_SendFirstChar();
				StartTimer16(TD_GSM, 300*GSM_DEBUG_DELAY);
			}
			GSM_State++;
    c38c:	80 91 ad 06 	lds	r24, 0x06AD
    c390:	8f 5f       	subi	r24, 0xFF	; 255
    c392:	80 93 ad 06 	sts	0x06AD, r24
    c396:	b8 ce       	rjmp	.-656    	; 0xc108 <GSM_Cycle+0x40>
		//------------------------


		//------------------------
		case GSM_CIPSHUT_:
			GSM_Execute_Command(AT_CIPSHUT, 1000*GSM_DEBUG_DELAY); GSM_State++;
    c398:	87 ed       	ldi	r24, 0xD7	; 215
    c39a:	95 e0       	ldi	r25, 0x05	; 5
    c39c:	68 ee       	ldi	r22, 0xE8	; 232
    c39e:	73 e0       	ldi	r23, 0x03	; 3
    c3a0:	0e 94 06 4a 	call	0x940c	; 0x940c <GSM_Execute_Command>
    c3a4:	80 91 ad 06 	lds	r24, 0x06AD
    c3a8:	8f 5f       	subi	r24, 0xFF	; 255
    c3aa:	80 93 ad 06 	sts	0x06AD, r24
    c3ae:	ac ce       	rjmp	.-680    	; 0xc108 <GSM_Cycle+0x40>
			break;
		case GSM_WAIT_DDET101_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;
		case GSM_WAIT_MESSAGE:
			if(Message[0]==1)
    c3b0:	80 91 ec 06 	lds	r24, 0x06EC
    c3b4:	81 30       	cpi	r24, 0x01	; 1
    c3b6:	09 f0       	breq	.+2      	; 0xc3ba <GSM_Cycle+0x2f2>
    c3b8:	a7 ce       	rjmp	.-690    	; 0xc108 <GSM_Cycle+0x40>
			{
				Message[0]=0;
    c3ba:	10 92 ec 06 	sts	0x06EC, r1
				GSM_State = GSM_SEND_ATD;
    c3be:	8f e0       	ldi	r24, 0x0F	; 15
    c3c0:	80 93 ad 06 	sts	0x06AD, r24
    c3c4:	a1 ce       	rjmp	.-702    	; 0xc108 <GSM_Cycle+0x40>
			break;
		case GSM_SEND_DDET101:
			GSM_Execute_Command(AT_DDET101,100*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_DDET101_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    c3c6:	8d ee       	ldi	r24, 0xED	; 237
    c3c8:	93 e0       	ldi	r25, 0x03	; 3
    c3ca:	68 e4       	ldi	r22, 0x48	; 72
    c3cc:	0e 94 ab 49 	call	0x9356	; 0x9356 <GSM_Wait_Response_P>
    c3d0:	88 23       	and	r24, r24
    c3d2:	09 f4       	brne	.+2      	; 0xc3d6 <GSM_Cycle+0x30e>
    c3d4:	99 ce       	rjmp	.-718    	; 0xc108 <GSM_Cycle+0x40>
    c3d6:	80 91 ad 06 	lds	r24, 0x06AD
    c3da:	8f 5f       	subi	r24, 0xFF	; 255
    c3dc:	80 93 ad 06 	sts	0x06AD, r24
    c3e0:	93 ce       	rjmp	.-730    	; 0xc108 <GSM_Cycle+0x40>
			break;
		case GSM_WAIT_CLCC_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;
		case GSM_SEND_DDET101:
			GSM_Execute_Command(AT_DDET101,100*GSM_DEBUG_DELAY); GSM_State++;
    c3e2:	83 e8       	ldi	r24, 0x83	; 131
    c3e4:	94 e0       	ldi	r25, 0x04	; 4
    c3e6:	64 e6       	ldi	r22, 0x64	; 100
    c3e8:	70 e0       	ldi	r23, 0x00	; 0
    c3ea:	0e 94 06 4a 	call	0x940c	; 0x940c <GSM_Execute_Command>
    c3ee:	80 91 ad 06 	lds	r24, 0x06AD
    c3f2:	8f 5f       	subi	r24, 0xFF	; 255
    c3f4:	80 93 ad 06 	sts	0x06AD, r24
    c3f8:	87 ce       	rjmp	.-754    	; 0xc108 <GSM_Cycle+0x40>
			break;
		case GSM_SEND_CLCC1:
			GSM_Execute_Command(AT_CLCC1,100*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CLCC_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    c3fa:	8d ee       	ldi	r24, 0xED	; 237
    c3fc:	93 e0       	ldi	r25, 0x03	; 3
    c3fe:	68 e4       	ldi	r22, 0x48	; 72
    c400:	0e 94 ab 49 	call	0x9356	; 0x9356 <GSM_Wait_Response_P>
    c404:	88 23       	and	r24, r24
    c406:	09 f4       	brne	.+2      	; 0xc40a <GSM_Cycle+0x342>
    c408:	7f ce       	rjmp	.-770    	; 0xc108 <GSM_Cycle+0x40>
    c40a:	80 91 ad 06 	lds	r24, 0x06AD
    c40e:	8f 5f       	subi	r24, 0xFF	; 255
    c410:	80 93 ad 06 	sts	0x06AD, r24
    c414:	79 ce       	rjmp	.-782    	; 0xc108 <GSM_Cycle+0x40>
			break;
		case GSM_WAIT_E0_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;
		case GSM_SEND_CLCC1:
			GSM_Execute_Command(AT_CLCC1,100*GSM_DEBUG_DELAY); GSM_State++;
    c416:	89 e7       	ldi	r24, 0x79	; 121
    c418:	94 e0       	ldi	r25, 0x04	; 4
    c41a:	64 e6       	ldi	r22, 0x64	; 100
    c41c:	70 e0       	ldi	r23, 0x00	; 0
    c41e:	0e 94 06 4a 	call	0x940c	; 0x940c <GSM_Execute_Command>
    c422:	80 91 ad 06 	lds	r24, 0x06AD
    c426:	8f 5f       	subi	r24, 0xFF	; 255
    c428:	80 93 ad 06 	sts	0x06AD, r24
    c42c:	6d ce       	rjmp	.-806    	; 0xc108 <GSM_Cycle+0x40>
		//------------------------
		case GSM_SEND_E0:
			GSM_Execute_Command(AT_E0,100*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_E0_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    c42e:	8d ee       	ldi	r24, 0xED	; 237
    c430:	93 e0       	ldi	r25, 0x03	; 3
    c432:	68 e4       	ldi	r22, 0x48	; 72
    c434:	0e 94 ab 49 	call	0x9356	; 0x9356 <GSM_Wait_Response_P>
    c438:	88 23       	and	r24, r24
    c43a:	09 f4       	brne	.+2      	; 0xc43e <GSM_Cycle+0x376>
    c43c:	65 ce       	rjmp	.-822    	; 0xc108 <GSM_Cycle+0x40>
    c43e:	80 91 ad 06 	lds	r24, 0x06AD
    c442:	8f 5f       	subi	r24, 0xFF	; 255
    c444:	80 93 ad 06 	sts	0x06AD, r24
    c448:	5f ce       	rjmp	.-834    	; 0xc108 <GSM_Cycle+0x40>
		case GSM_WAIT_SMS_READY:
			if(GSM_Wait_Response_P(URC_SMS_READY, GSM_ReStart1))GSM_State++;
			break;
		//------------------------
		case GSM_SEND_E0:
			GSM_Execute_Command(AT_E0,100*GSM_DEBUG_DELAY); GSM_State++;
    c44a:	84 e7       	ldi	r24, 0x74	; 116
    c44c:	94 e0       	ldi	r25, 0x04	; 4
    c44e:	64 e6       	ldi	r22, 0x64	; 100
    c450:	70 e0       	ldi	r23, 0x00	; 0
    c452:	0e 94 06 4a 	call	0x940c	; 0x940c <GSM_Execute_Command>
    c456:	80 91 ad 06 	lds	r24, 0x06AD
    c45a:	8f 5f       	subi	r24, 0xFF	; 255
    c45c:	80 93 ad 06 	sts	0x06AD, r24
    c460:	53 ce       	rjmp	.-858    	; 0xc108 <GSM_Cycle+0x40>
				if(GSM_Modem == SIMCOM_SIM800) GSM_State = GSM_WAIT_SMS_READY;
				else GSM_State = GSM_SEND_E0;
			}
			break;
		case GSM_WAIT_SMS_READY:
			if(GSM_Wait_Response_P(URC_SMS_READY, GSM_ReStart1))GSM_State++;
    c462:	88 ea       	ldi	r24, 0xA8	; 168
    c464:	93 e0       	ldi	r25, 0x03	; 3
    c466:	68 e4       	ldi	r22, 0x48	; 72
    c468:	0e 94 ab 49 	call	0x9356	; 0x9356 <GSM_Wait_Response_P>
    c46c:	88 23       	and	r24, r24
    c46e:	09 f4       	brne	.+2      	; 0xc472 <GSM_Cycle+0x3aa>
    c470:	4b ce       	rjmp	.-874    	; 0xc108 <GSM_Cycle+0x40>
    c472:	80 91 ad 06 	lds	r24, 0x06AD
    c476:	8f 5f       	subi	r24, 0xFF	; 255
    c478:	80 93 ad 06 	sts	0x06AD, r24
    c47c:	45 ce       	rjmp	.-886    	; 0xc108 <GSM_Cycle+0x40>

		case GSM_WAIT_RDY:
			if(GSM_Wait_Response_P(URC_RDY, GSM_ReStart1)) GSM_State++;
			break;
		case GSM_SEND_CGMM:
			GSM_Execute_Command(AT_CGMM,5000*GSM_DEBUG_DELAY); GSM_State++;
    c47e:	81 e9       	ldi	r24, 0x91	; 145
    c480:	94 e0       	ldi	r25, 0x04	; 4
    c482:	68 e8       	ldi	r22, 0x88	; 136
    c484:	73 e1       	ldi	r23, 0x13	; 19
    c486:	0e 94 06 4a 	call	0x940c	; 0x940c <GSM_Execute_Command>
    c48a:	80 91 ad 06 	lds	r24, 0x06AD
    c48e:	8f 5f       	subi	r24, 0xFF	; 255
    c490:	80 93 ad 06 	sts	0x06AD, r24
    c494:	39 ce       	rjmp	.-910    	; 0xc108 <GSM_Cycle+0x40>
			GSM_Modem = NOT_RECOGNIZED;
			GSM_State = GSM_WAIT_RDY;
			break;

		case GSM_WAIT_RDY:
			if(GSM_Wait_Response_P(URC_RDY, GSM_ReStart1)) GSM_State++;
    c496:	83 e8       	ldi	r24, 0x83	; 131
    c498:	93 e0       	ldi	r25, 0x03	; 3
    c49a:	68 e4       	ldi	r22, 0x48	; 72
    c49c:	0e 94 ab 49 	call	0x9356	; 0x9356 <GSM_Wait_Response_P>
    c4a0:	88 23       	and	r24, r24
    c4a2:	09 f4       	brne	.+2      	; 0xc4a6 <GSM_Cycle+0x3de>
    c4a4:	31 ce       	rjmp	.-926    	; 0xc108 <GSM_Cycle+0x40>
    c4a6:	80 91 ad 06 	lds	r24, 0x06AD
    c4aa:	8f 5f       	subi	r24, 0xFF	; 255
    c4ac:	80 93 ad 06 	sts	0x06AD, r24
    c4b0:	2b ce       	rjmp	.-938    	; 0xc108 <GSM_Cycle+0x40>
inline static void GSM_Auto(){

	switch(GSM_State){

		case GSM_PowerOn:
			StartTimer16(TD_GSM,1000*GSM_DEBUG_DELAY);
    c4b2:	80 91 e1 04 	lds	r24, 0x04E1
    c4b6:	68 ee       	ldi	r22, 0xE8	; 232
    c4b8:	73 e0       	ldi	r23, 0x03	; 3
    c4ba:	0e 94 1d 1a 	call	0x343a	; 0x343a <StartTimer16>
			StartTimer32(TD_GSM_Reset, 24UL*60UL*6000);	//    24 
    c4be:	80 91 e3 04 	lds	r24, 0x04E3
    c4c2:	40 e0       	ldi	r20, 0x00	; 0
    c4c4:	56 ed       	ldi	r21, 0xD6	; 214
    c4c6:	63 e8       	ldi	r22, 0x83	; 131
    c4c8:	70 e0       	ldi	r23, 0x00	; 0
    c4ca:	0e 94 5c 1a 	call	0x34b8	; 0x34b8 <StartTimer32>
			StartTimer32(TD_1hour_resetGPRS_timer, 360000); //     
    c4ce:	80 91 e5 04 	lds	r24, 0x04E5
    c4d2:	40 e4       	ldi	r20, 0x40	; 64
    c4d4:	5e e7       	ldi	r21, 0x7E	; 126
    c4d6:	65 e0       	ldi	r22, 0x05	; 5
    c4d8:	70 e0       	ldi	r23, 0x00	; 0
    c4da:	0e 94 5c 1a 	call	0x34b8	; 0x34b8 <StartTimer32>
			StartTimer16(TD_CheckModem,6000);//      5 	
    c4de:	80 91 e6 04 	lds	r24, 0x04E6
    c4e2:	60 e7       	ldi	r22, 0x70	; 112
    c4e4:	77 e1       	ldi	r23, 0x17	; 23
    c4e6:	0e 94 1d 1a 	call	0x343a	; 0x343a <StartTimer16>
		cli();
		PORTL|=(1<<PL5);
		sei();
	}
	void GSM_PWRCNTRL_ON(void){
		cli();
    c4ea:	f8 94       	cli
		PORTL &= ~(1<<PL5);
    c4ec:	80 91 0b 01 	lds	r24, 0x010B
    c4f0:	8f 7d       	andi	r24, 0xDF	; 223
    c4f2:	80 93 0b 01 	sts	0x010B, r24
		sei();
    c4f6:	78 94       	sei
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    c4f8:	8f ef       	ldi	r24, 0xFF	; 255
    c4fa:	80 93 f4 06 	sts	0x06F4, r24
	GSM_RX_FIFO_End = 255;
    c4fe:	80 93 4b 06 	sts	0x064B, r24
	GSM_RxCharN = 0;
    c502:	10 92 12 0b 	sts	0x0B12, r1
	GSM_RX_FIFOOverFlow = 0;
    c506:	10 92 c5 08 	sts	0x08C5, r1
	GSM_RX_FIFOMax = 0;
    c50a:	10 92 cb 08 	sts	0x08CB, r1
			StartTimer32(TD_GSM_Reset, 24UL*60UL*6000);	//    24 
			StartTimer32(TD_1hour_resetGPRS_timer, 360000); //     
			StartTimer16(TD_CheckModem,6000);//      5 	
			GSM_PWRCNTRL_ON();
			InitFIFO();
			counter=0;
    c50e:	10 92 dc 02 	sts	0x02DC, r1
			GSM_Modem = NOT_RECOGNIZED;
    c512:	10 92 eb 06 	sts	0x06EB, r1
			GSM_State = GSM_WAIT_RDY;
    c516:	81 e0       	ldi	r24, 0x01	; 1
    c518:	80 93 ad 06 	sts	0x06AD, r24
    c51c:	f5 cd       	rjmp	.-1046   	; 0xc108 <GSM_Cycle+0x40>
			}
		case GSM_WAIT_CFUN:
			if(GSM_Wait_Response_P(URC_CFUN, GSM_ReStart1)) GSM_State++;
			break;
		case GSM_WAIT_CPIN_READY:
			if(GSM_Wait_Response_P(URC_CPIN_READY, GSM_ReStart1)) GSM_State++;
    c51e:	80 e9       	ldi	r24, 0x90	; 144
    c520:	93 e0       	ldi	r25, 0x03	; 3
    c522:	68 e4       	ldi	r22, 0x48	; 72
    c524:	0e 94 ab 49 	call	0x9356	; 0x9356 <GSM_Wait_Response_P>
    c528:	88 23       	and	r24, r24
    c52a:	09 f4       	brne	.+2      	; 0xc52e <GSM_Cycle+0x466>
    c52c:	ed cd       	rjmp	.-1062   	; 0xc108 <GSM_Cycle+0x40>
    c52e:	80 91 ad 06 	lds	r24, 0x06AD
    c532:	8f 5f       	subi	r24, 0xFF	; 255
    c534:	80 93 ad 06 	sts	0x06AD, r24
    c538:	e7 cd       	rjmp	.-1074   	; 0xc108 <GSM_Cycle+0x40>
				}
				else GSM_State++;
			}
			break;
		case GSM_SEND_CIPMODE:
			if(GSM_MultiCon) GSM_Execute_Command(AT_CIPMODE_0, 100*GSM_DEBUG_DELAY);
    c53a:	80 91 25 0c 	lds	r24, 0x0C25
    c53e:	88 23       	and	r24, r24
    c540:	09 f4       	brne	.+2      	; 0xc544 <GSM_Cycle+0x47c>
    c542:	b4 c5       	rjmp	.+2920   	; 0xd0ac <GSM_Cycle+0xfe4>
    c544:	8e ee       	ldi	r24, 0xEE	; 238
    c546:	94 e0       	ldi	r25, 0x04	; 4
    c548:	64 e6       	ldi	r22, 0x64	; 100
    c54a:	70 e0       	ldi	r23, 0x00	; 0
    c54c:	0e 94 06 4a 	call	0x940c	; 0x940c <GSM_Execute_Command>
			else GSM_Execute_Command(AT_CIPMODE_1, 100*GSM_DEBUG_DELAY);
			GSM_State++;
    c550:	80 91 ad 06 	lds	r24, 0x06AD
    c554:	8f 5f       	subi	r24, 0xFF	; 255
    c556:	80 93 ad 06 	sts	0x06AD, r24
    c55a:	d6 cd       	rjmp	.-1108   	; 0xc108 <GSM_Cycle+0x40>
			if(GSM_MultiCon) GSM_Execute_Command(AT_CIPMUX_1, 100*GSM_DEBUG_DELAY);
			else GSM_Execute_Command(AT_CIPMUX_0, 100*GSM_DEBUG_DELAY);
			GSM_State++; 
			break;
		case GSM_WAIT_CIPMUX_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    c55c:	8d ee       	ldi	r24, 0xED	; 237
    c55e:	93 e0       	ldi	r25, 0x03	; 3
    c560:	68 e4       	ldi	r22, 0x48	; 72
    c562:	0e 94 ab 49 	call	0x9356	; 0x9356 <GSM_Wait_Response_P>
    c566:	88 23       	and	r24, r24
    c568:	09 f4       	brne	.+2      	; 0xc56c <GSM_Cycle+0x4a4>
    c56a:	ce cd       	rjmp	.-1124   	; 0xc108 <GSM_Cycle+0x40>
				if(GSM_MultiCon){
    c56c:	80 91 25 0c 	lds	r24, 0x0C25
    c570:	88 23       	and	r24, r24
    c572:	09 f0       	breq	.+2      	; 0xc576 <GSM_Cycle+0x4ae>
    c574:	28 c7       	rjmp	.+3664   	; 0xd3c6 <GSM_Cycle+0x12fe>
					GSM_State = GSM_WAIT_1;
					// between "Call Ready" and "+CMGS"; 8 sec min needs; for kyivstar vpni only
					StartTimer16(TD_GSM, 1000);
				}
				else GSM_State++;
    c576:	80 91 ad 06 	lds	r24, 0x06AD
    c57a:	8f 5f       	subi	r24, 0xFF	; 255
    c57c:	80 93 ad 06 	sts	0x06AD, r24
    c580:	c3 cd       	rjmp	.-1146   	; 0xc108 <GSM_Cycle+0x40>
			break;
		case GSM_SEND_CGATT:
			GSM_Execute_Command(AT_CGATT, 500*GSM_DEBUG_DELAY); GSM_Temp++; GSM_State++;
			break;
		case GSM_WAIT_CGATT_OK:
			if(GSM_Temp>20) GSM_State = GSM_ReStart1;
    c582:	80 91 d3 05 	lds	r24, 0x05D3
    c586:	85 31       	cpi	r24, 0x15	; 21
    c588:	18 f0       	brcs	.+6      	; 0xc590 <GSM_Cycle+0x4c8>
    c58a:	88 e4       	ldi	r24, 0x48	; 72
    c58c:	80 93 ad 06 	sts	0x06AD, r24
			if(GSM_Wait_Response_P(RESP_OK, GSM_SEND_CGATT)) GSM_State++;
    c590:	8d ee       	ldi	r24, 0xED	; 237
    c592:	93 e0       	ldi	r25, 0x03	; 3
    c594:	6d e2       	ldi	r22, 0x2D	; 45
    c596:	0e 94 ab 49 	call	0x9356	; 0x9356 <GSM_Wait_Response_P>
    c59a:	88 23       	and	r24, r24
    c59c:	09 f4       	brne	.+2      	; 0xc5a0 <GSM_Cycle+0x4d8>
    c59e:	b4 cd       	rjmp	.-1176   	; 0xc108 <GSM_Cycle+0x40>
    c5a0:	80 91 ad 06 	lds	r24, 0x06AD
    c5a4:	8f 5f       	subi	r24, 0xFF	; 255
    c5a6:	80 93 ad 06 	sts	0x06AD, r24
    c5aa:	ae cd       	rjmp	.-1188   	; 0xc108 <GSM_Cycle+0x40>
			break;
		case GSM_WAIT_CMGF_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;
		case GSM_SEND_CSMP:
			GSM_Execute_Command(AT_CSMP, 100*GSM_DEBUG_DELAY); GSM_State++;
    c5ac:	80 ed       	ldi	r24, 0xD0	; 208
    c5ae:	94 e0       	ldi	r25, 0x04	; 4
    c5b0:	64 e6       	ldi	r22, 0x64	; 100
    c5b2:	70 e0       	ldi	r23, 0x00	; 0
    c5b4:	0e 94 06 4a 	call	0x940c	; 0x940c <GSM_Execute_Command>
    c5b8:	80 91 ad 06 	lds	r24, 0x06AD
    c5bc:	8f 5f       	subi	r24, 0xFF	; 255
    c5be:	80 93 ad 06 	sts	0x06AD, r24
    c5c2:	a2 cd       	rjmp	.-1212   	; 0xc108 <GSM_Cycle+0x40>
///------------------------ / (  )
		case GSM_SEND_CMGF:
			GSM_Execute_Command(AT_CMGF,100*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CMGF_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    c5c4:	8d ee       	ldi	r24, 0xED	; 237
    c5c6:	93 e0       	ldi	r25, 0x03	; 3
    c5c8:	68 e4       	ldi	r22, 0x48	; 72
    c5ca:	0e 94 ab 49 	call	0x9356	; 0x9356 <GSM_Wait_Response_P>
    c5ce:	88 23       	and	r24, r24
    c5d0:	09 f4       	brne	.+2      	; 0xc5d4 <GSM_Cycle+0x50c>
    c5d2:	9a cd       	rjmp	.-1228   	; 0xc108 <GSM_Cycle+0x40>
    c5d4:	80 91 ad 06 	lds	r24, 0x06AD
    c5d8:	8f 5f       	subi	r24, 0xFF	; 255
    c5da:	80 93 ad 06 	sts	0x06AD, r24
    c5de:	94 cd       	rjmp	.-1240   	; 0xc108 <GSM_Cycle+0x40>



///------------------------ / (  )
		case GSM_SEND_CMGF:
			GSM_Execute_Command(AT_CMGF,100*GSM_DEBUG_DELAY); GSM_State++;
    c5e0:	86 ec       	ldi	r24, 0xC6	; 198
    c5e2:	94 e0       	ldi	r25, 0x04	; 4
    c5e4:	64 e6       	ldi	r22, 0x64	; 100
    c5e6:	70 e0       	ldi	r23, 0x00	; 0
    c5e8:	0e 94 06 4a 	call	0x940c	; 0x940c <GSM_Execute_Command>
    c5ec:	80 91 ad 06 	lds	r24, 0x06AD
    c5f0:	8f 5f       	subi	r24, 0xFF	; 255
    c5f2:	80 93 ad 06 	sts	0x06AD, r24
    c5f6:	88 cd       	rjmp	.-1264   	; 0xc108 <GSM_Cycle+0x40>
				Message[0]=0;
				GSM_State = GSM_SEND_ATD;
			}
			break;
		case GSM_SEND_ATD:
			sprintf_P(GSM_TxStr, ATD_PLUS);	GSMTxSz = strlen_P(ATD_PLUS);
    c5f8:	00 d0       	rcall	.+0      	; 0xc5fa <GSM_Cycle+0x532>
    c5fa:	0f 92       	push	r0
    c5fc:	8c ef       	ldi	r24, 0xFC	; 252
    c5fe:	99 e0       	ldi	r25, 0x09	; 9
    c600:	ad b7       	in	r26, 0x3d	; 61
    c602:	be b7       	in	r27, 0x3e	; 62
    c604:	12 96       	adiw	r26, 0x02	; 2
    c606:	9c 93       	st	X, r25
    c608:	8e 93       	st	-X, r24
    c60a:	11 97       	sbiw	r26, 0x01	; 1
    c60c:	05 eb       	ldi	r16, 0xB5	; 181
    c60e:	14 e0       	ldi	r17, 0x04	; 4
    c610:	14 96       	adiw	r26, 0x04	; 4
    c612:	1c 93       	st	X, r17
    c614:	0e 93       	st	-X, r16
    c616:	13 97       	sbiw	r26, 0x03	; 3
    c618:	0e 94 a7 7b 	call	0xf74e	; 0xf74e <sprintf_P>
    c61c:	0f 90       	pop	r0
    c61e:	0f 90       	pop	r0
    c620:	0f 90       	pop	r0
    c622:	0f 90       	pop	r0
    c624:	c8 01       	movw	r24, r16
    c626:	0e 94 8a 7a 	call	0xf514	; 0xf514 <strlen_P>
    c62a:	80 93 6f 07 	sts	0x076F, r24
			erbl(GSM_TxStr+GSMTxSz, CALL_Number+Message[1], MaxTelephN);
    c62e:	80 91 6f 07 	lds	r24, 0x076F
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    c632:	90 e0       	ldi	r25, 0x00	; 0
    c634:	60 91 ed 06 	lds	r22, 0x06ED
    c638:	2d e0       	ldi	r18, 0x0D	; 13
    c63a:	62 9f       	mul	r22, r18
    c63c:	b0 01       	movw	r22, r0
    c63e:	11 24       	eor	r1, r1
    c640:	64 51       	subi	r22, 0x14	; 20
    c642:	7f 4f       	sbci	r23, 0xFF	; 255
    c644:	84 50       	subi	r24, 0x04	; 4
    c646:	96 4f       	sbci	r25, 0xF6	; 246
    c648:	4d e0       	ldi	r20, 0x0D	; 13
    c64a:	50 e0       	ldi	r21, 0x00	; 0
    c64c:	0e 94 94 7d 	call	0xfb28	; 0xfb28 <__eerd_block_m2560>
			GSMTxSz+=MaxTelephN-1;
    c650:	80 91 6f 07 	lds	r24, 0x076F
    c654:	84 5f       	subi	r24, 0xF4	; 244
    c656:	80 93 6f 07 	sts	0x076F, r24
			const char c=';';
    c65a:	8b e3       	ldi	r24, 0x3B	; 59
    c65c:	89 83       	std	Y+1, r24	; 0x01
			sprintf(GSM_TxStr+GSMTxSz,&c);GSMTxSz++;
    c65e:	80 91 6f 07 	lds	r24, 0x076F
    c662:	00 d0       	rcall	.+0      	; 0xc664 <GSM_Cycle+0x59c>
    c664:	0f 92       	push	r0
    c666:	90 e0       	ldi	r25, 0x00	; 0
    c668:	84 50       	subi	r24, 0x04	; 4
    c66a:	96 4f       	sbci	r25, 0xF6	; 246
    c66c:	ed b7       	in	r30, 0x3d	; 61
    c66e:	fe b7       	in	r31, 0x3e	; 62
    c670:	92 83       	std	Z+2, r25	; 0x02
    c672:	81 83       	std	Z+1, r24	; 0x01
    c674:	ce 01       	movw	r24, r28
    c676:	01 96       	adiw	r24, 0x01	; 1
    c678:	94 83       	std	Z+4, r25	; 0x04
    c67a:	83 83       	std	Z+3, r24	; 0x03
    c67c:	0e 94 76 7b 	call	0xf6ec	; 0xf6ec <sprintf>
    c680:	80 91 6f 07 	lds	r24, 0x076F
    c684:	8f 5f       	subi	r24, 0xFF	; 255
    c686:	80 93 6f 07 	sts	0x076F, r24
			sprintf(GSM_TxStr + GSMTxSz, "\r");	GSMTxSz = GSMTxSz+1;
    c68a:	e0 91 6f 07 	lds	r30, 0x076F
    c68e:	f0 e0       	ldi	r31, 0x00	; 0
    c690:	e4 50       	subi	r30, 0x04	; 4
    c692:	f6 4f       	sbci	r31, 0xF6	; 246
    c694:	8d e0       	ldi	r24, 0x0D	; 13
    c696:	90 e0       	ldi	r25, 0x00	; 0
    c698:	91 83       	std	Z+1, r25	; 0x01
    c69a:	80 83       	st	Z, r24
    c69c:	80 91 6f 07 	lds	r24, 0x076F
    c6a0:	8f 5f       	subi	r24, 0xFF	; 255
    c6a2:	80 93 6f 07 	sts	0x076F, r24
			GSM_SendFirstChar();
    c6a6:	0f 90       	pop	r0
    c6a8:	0f 90       	pop	r0
    c6aa:	0f 90       	pop	r0
    c6ac:	0f 90       	pop	r0
    c6ae:	0e 94 fd 38 	call	0x71fa	; 0x71fa <GSM_SendFirstChar>
			GSM_State=GSM_WAIT_MESSAGE;
    c6b2:	8e e0       	ldi	r24, 0x0E	; 14
    c6b4:	80 93 ad 06 	sts	0x06AD, r24
    c6b8:	27 cd       	rjmp	.-1458   	; 0xc108 <GSM_Cycle+0x40>
		case GSM_WAIT_CSMP_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State=GSM_SEND_ATD_Check_Ballance;
			break;
		//------------------------
		case GSM_SEND_CIPMUX:
			if(GSM_MultiCon) GSM_Execute_Command(AT_CIPMUX_1, 100*GSM_DEBUG_DELAY);
    c6ba:	80 91 25 0c 	lds	r24, 0x0C25
    c6be:	88 23       	and	r24, r24
    c6c0:	09 f4       	brne	.+2      	; 0xc6c4 <GSM_Cycle+0x5fc>
    c6c2:	fb c4       	rjmp	.+2550   	; 0xd0ba <GSM_Cycle+0xff2>
    c6c4:	84 e1       	ldi	r24, 0x14	; 20
    c6c6:	95 e0       	ldi	r25, 0x05	; 5
    c6c8:	64 e6       	ldi	r22, 0x64	; 100
    c6ca:	70 e0       	ldi	r23, 0x00	; 0
    c6cc:	0e 94 06 4a 	call	0x940c	; 0x940c <GSM_Execute_Command>
			else GSM_Execute_Command(AT_CIPMUX_0, 100*GSM_DEBUG_DELAY);
			GSM_State++; 
    c6d0:	80 91 ad 06 	lds	r24, 0x06AD
    c6d4:	8f 5f       	subi	r24, 0xFF	; 255
    c6d6:	80 93 ad 06 	sts	0x06AD, r24
    c6da:	16 cd       	rjmp	.-1492   	; 0xc108 <GSM_Cycle+0x40>
			break;
		case GSM_SEND_CSMP:
			GSM_Execute_Command(AT_CSMP, 100*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CSMP_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State=GSM_SEND_ATD_Check_Ballance;
    c6dc:	8d ee       	ldi	r24, 0xED	; 237
    c6de:	93 e0       	ldi	r25, 0x03	; 3
    c6e0:	68 e4       	ldi	r22, 0x48	; 72
    c6e2:	0e 94 ab 49 	call	0x9356	; 0x9356 <GSM_Wait_Response_P>
    c6e6:	88 23       	and	r24, r24
    c6e8:	09 f4       	brne	.+2      	; 0xc6ec <GSM_Cycle+0x624>
    c6ea:	0e cd       	rjmp	.-1508   	; 0xc108 <GSM_Cycle+0x40>
    c6ec:	8a e4       	ldi	r24, 0x4A	; 74
    c6ee:	80 93 ad 06 	sts	0x06AD, r24
    c6f2:	0a cd       	rjmp	.-1516   	; 0xc108 <GSM_Cycle+0x40>
			 else GSM_State=GSM_SEND_CSTT;
			 }
			break;

		case GSM_SEND_CIPTKA:
			GSM_Execute_Command(AT_CIPTKA, 1000*GSM_DEBUG_DELAY); GSM_State++;
    c6f4:	84 e5       	ldi	r24, 0x54	; 84
    c6f6:	95 e0       	ldi	r25, 0x05	; 5
    c6f8:	68 ee       	ldi	r22, 0xE8	; 232
    c6fa:	73 e0       	ldi	r23, 0x03	; 3
    c6fc:	0e 94 06 4a 	call	0x940c	; 0x940c <GSM_Execute_Command>
    c700:	80 91 ad 06 	lds	r24, 0x06AD
    c704:	8f 5f       	subi	r24, 0xFF	; 255
    c706:	80 93 ad 06 	sts	0x06AD, r24
    c70a:	fe cc       	rjmp	.-1540   	; 0xc108 <GSM_Cycle+0x40>
			}
			break;

		//------------------------
		case GSM_WAIT_1:
			GetStringFromFIFO();		//     FIFO
    c70c:	0e 94 d3 37 	call	0x6fa6	; 0x6fa6 <GetStringFromFIFO>
			if(Timer16Stopp(TD_GSM)){
    c710:	80 91 e1 04 	lds	r24, 0x04E1
    c714:	0e 94 59 1b 	call	0x36b2	; 0x36b2 <Timer16Stopp>
    c718:	88 23       	and	r24, r24
    c71a:	09 f4       	brne	.+2      	; 0xc71e <GSM_Cycle+0x656>
    c71c:	f5 cc       	rjmp	.-1558   	; 0xc108 <GSM_Cycle+0x40>
				GSM_State++;
    c71e:	80 91 ad 06 	lds	r24, 0x06AD
    c722:	8f 5f       	subi	r24, 0xFF	; 255
    c724:	80 93 ad 06 	sts	0x06AD, r24
				GSM_Temp = 0;
    c728:	10 92 d3 05 	sts	0x05D3, r1
    c72c:	ed cc       	rjmp	.-1574   	; 0xc108 <GSM_Cycle+0x40>
			if(GSM_MultiCon) GSM_Execute_Command(AT_CIPMODE_0, 100*GSM_DEBUG_DELAY);
			else GSM_Execute_Command(AT_CIPMODE_1, 100*GSM_DEBUG_DELAY);
			GSM_State++;
			break;
		case GSM_WAIT_CIPMODE_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    c72e:	8d ee       	ldi	r24, 0xED	; 237
    c730:	93 e0       	ldi	r25, 0x03	; 3
    c732:	68 e4       	ldi	r22, 0x48	; 72
    c734:	0e 94 ab 49 	call	0x9356	; 0x9356 <GSM_Wait_Response_P>
    c738:	88 23       	and	r24, r24
    c73a:	09 f4       	brne	.+2      	; 0xc73e <GSM_Cycle+0x676>
    c73c:	e5 cc       	rjmp	.-1590   	; 0xc108 <GSM_Cycle+0x40>
				GSM_State++;
    c73e:	80 91 ad 06 	lds	r24, 0x06AD
    c742:	8f 5f       	subi	r24, 0xFF	; 255
    c744:	80 93 ad 06 	sts	0x06AD, r24
				// between "Call Ready" and "+CMGS"; 8 sec min needs; for kyivstar vpni only
				StartTimer16(TD_GSM, 1000);
    c748:	80 91 e1 04 	lds	r24, 0x04E1
    c74c:	68 ee       	ldi	r22, 0xE8	; 232
    c74e:	73 e0       	ldi	r23, 0x03	; 3
    c750:	0e 94 1d 1a 	call	0x343a	; 0x343a <StartTimer16>
    c754:	d9 cc       	rjmp	.-1614   	; 0xc108 <GSM_Cycle+0x40>
				GSM_State++;
				GSM_Temp = 0;
			}
			break;
		case GSM_SEND_CGATT:
			GSM_Execute_Command(AT_CGATT, 500*GSM_DEBUG_DELAY); GSM_Temp++; GSM_State++;
    c756:	80 e2       	ldi	r24, 0x20	; 32
    c758:	95 e0       	ldi	r25, 0x05	; 5
    c75a:	64 ef       	ldi	r22, 0xF4	; 244
    c75c:	71 e0       	ldi	r23, 0x01	; 1
    c75e:	0e 94 06 4a 	call	0x940c	; 0x940c <GSM_Execute_Command>
    c762:	80 91 d3 05 	lds	r24, 0x05D3
    c766:	8f 5f       	subi	r24, 0xFF	; 255
    c768:	80 93 d3 05 	sts	0x05D3, r24
    c76c:	80 91 ad 06 	lds	r24, 0x06AD
    c770:	8f 5f       	subi	r24, 0xFF	; 255
    c772:	80 93 ad 06 	sts	0x06AD, r24
    c776:	c8 cc       	rjmp	.-1648   	; 0xc108 <GSM_Cycle+0x40>
			break;
		case GSM_WAIT_ATD_Check_Ballance_OK:
			if(GSM_Wait_Response_P(RESP_OK,GSM_SEND_CSQ)) GSM_State++;
			break;
		case GSM_WAIT_Ballance:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_SEND_CSQ;
    c778:	80 91 e1 04 	lds	r24, 0x04E1
    c77c:	0e 94 59 1b 	call	0x36b2	; 0x36b2 <Timer16Stopp>
    c780:	88 23       	and	r24, r24
    c782:	19 f0       	breq	.+6      	; 0xc78a <GSM_Cycle+0x6c2>
    c784:	8d e4       	ldi	r24, 0x4D	; 77
    c786:	80 93 ad 06 	sts	0x06AD, r24
			GSM_RxStr[GSM_RXSTR_SIZE-1]='\0';
    c78a:	10 92 f6 07 	sts	0x07F6, r1
		
				GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);

				if(GSM_RxCharN >= 90){

					GSM_State = GSM_SEND_CSQ;
    c78e:	1d e4       	ldi	r17, 0x4D	; 77
			if(GSM_Wait_Response_P(RESP_OK,GSM_SEND_CSQ)) GSM_State++;
			break;
		case GSM_WAIT_Ballance:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_SEND_CSQ;
			GSM_RxStr[GSM_RXSTR_SIZE-1]='\0';
			while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    c790:	90 91 f4 06 	lds	r25, 0x06F4
    c794:	80 91 4b 06 	lds	r24, 0x064B
    c798:	98 17       	cp	r25, r24
    c79a:	09 f4       	brne	.+2      	; 0xc79e <GSM_Cycle+0x6d6>
    c79c:	a9 c3       	rjmp	.+1874   	; 0xcef0 <GSM_Cycle+0xe28>
				
		
				GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);
    c79e:	83 e9       	ldi	r24, 0x93	; 147
    c7a0:	97 e0       	ldi	r25, 0x07	; 7
    c7a2:	62 e1       	ldi	r22, 0x12	; 18
    c7a4:	7b e0       	ldi	r23, 0x0B	; 11
    c7a6:	44 e6       	ldi	r20, 0x64	; 100
    c7a8:	0e 94 69 37 	call	0x6ed2	; 0x6ed2 <GetByteFromFIFO>

				if(GSM_RxCharN >= 90){
    c7ac:	80 91 12 0b 	lds	r24, 0x0B12
    c7b0:	8a 35       	cpi	r24, 0x5A	; 90
    c7b2:	70 f3       	brcs	.-36     	; 0xc790 <GSM_Cycle+0x6c8>

					GSM_State = GSM_SEND_CSQ;
    c7b4:	10 93 ad 06 	sts	0x06AD, r17
    c7b8:	eb cf       	rjmp	.-42     	; 0xc790 <GSM_Cycle+0x6c8>
			}
			GSM_State++;	
			GSM_Temp = 0;
			break;
		case GSM_WAIT_ATD_Check_Ballance_OK:
			if(GSM_Wait_Response_P(RESP_OK,GSM_SEND_CSQ)) GSM_State++;
    c7ba:	8d ee       	ldi	r24, 0xED	; 237
    c7bc:	93 e0       	ldi	r25, 0x03	; 3
    c7be:	6d e4       	ldi	r22, 0x4D	; 77
    c7c0:	0e 94 ab 49 	call	0x9356	; 0x9356 <GSM_Wait_Response_P>
    c7c4:	88 23       	and	r24, r24
    c7c6:	09 f4       	brne	.+2      	; 0xc7ca <GSM_Cycle+0x702>
    c7c8:	9f cc       	rjmp	.-1730   	; 0xc108 <GSM_Cycle+0x40>
    c7ca:	80 91 ad 06 	lds	r24, 0x06AD
    c7ce:	8f 5f       	subi	r24, 0xFF	; 255
    c7d0:	80 93 ad 06 	sts	0x06AD, r24
    c7d4:	99 cc       	rjmp	.-1742   	; 0xc108 <GSM_Cycle+0x40>
			break;
		//------------------------    


		case GSM_SEND_ATD_Check_Ballance:	
			if(GSM_Flag & (1<<flg_TxCStr)){
    c7d6:	80 91 cf 02 	lds	r24, 0x02CF
    c7da:	80 ff       	sbrs	r24, 0
    c7dc:	4b c0       	rjmp	.+150    	; 0xc874 <GSM_Cycle+0x7ac>
				sprintf_P(GSM_TxStr, AT_CUSD101);	
    c7de:	00 d0       	rcall	.+0      	; 0xc7e0 <GSM_Cycle+0x718>
    c7e0:	0f 92       	push	r0
    c7e2:	8c ef       	ldi	r24, 0xFC	; 252
    c7e4:	99 e0       	ldi	r25, 0x09	; 9
    c7e6:	ad b7       	in	r26, 0x3d	; 61
    c7e8:	be b7       	in	r27, 0x3e	; 62
    c7ea:	12 96       	adiw	r26, 0x02	; 2
    c7ec:	9c 93       	st	X, r25
    c7ee:	8e 93       	st	-X, r24
    c7f0:	11 97       	sbiw	r26, 0x01	; 1
    c7f2:	0a eb       	ldi	r16, 0xBA	; 186
    c7f4:	14 e0       	ldi	r17, 0x04	; 4
    c7f6:	14 96       	adiw	r26, 0x04	; 4
    c7f8:	1c 93       	st	X, r17
    c7fa:	0e 93       	st	-X, r16
    c7fc:	13 97       	sbiw	r26, 0x03	; 3
    c7fe:	0e 94 a7 7b 	call	0xf74e	; 0xf74e <sprintf_P>
				GSMTxSz = strlen_P(AT_CUSD101);
    c802:	0f 90       	pop	r0
    c804:	0f 90       	pop	r0
    c806:	0f 90       	pop	r0
    c808:	0f 90       	pop	r0
    c80a:	c8 01       	movw	r24, r16
    c80c:	0e 94 8a 7a 	call	0xf514	; 0xf514 <strlen_P>
    c810:	80 93 6f 07 	sts	0x076F, r24
				GSMTxSz += strcpy_EE(GSM_TxStr+GSMTxSz,GPRS_checkballancerequest);
    c814:	80 91 6f 07 	lds	r24, 0x076F
    c818:	90 e0       	ldi	r25, 0x00	; 0
    c81a:	84 50       	subi	r24, 0x04	; 4
    c81c:	96 4f       	sbci	r25, 0xF6	; 246
    c81e:	61 e3       	ldi	r22, 0x31	; 49
    c820:	70 e0       	ldi	r23, 0x00	; 0
    c822:	0e 94 41 60 	call	0xc082	; 0xc082 <strcpy_EE>
    c826:	90 91 6f 07 	lds	r25, 0x076F
    c82a:	98 0f       	add	r25, r24
    c82c:	90 93 6f 07 	sts	0x076F, r25
				GSM_TxStr[GSMTxSz]='"';
    c830:	e0 91 6f 07 	lds	r30, 0x076F
    c834:	f0 e0       	ldi	r31, 0x00	; 0
    c836:	e4 50       	subi	r30, 0x04	; 4
    c838:	f6 4f       	sbci	r31, 0xF6	; 246
    c83a:	82 e2       	ldi	r24, 0x22	; 34
    c83c:	80 83       	st	Z, r24
				GSM_TxStr[GSMTxSz+1]='\r';
    c83e:	e0 91 6f 07 	lds	r30, 0x076F
    c842:	f0 e0       	ldi	r31, 0x00	; 0
    c844:	e4 50       	subi	r30, 0x04	; 4
    c846:	f6 4f       	sbci	r31, 0xF6	; 246
    c848:	8d e0       	ldi	r24, 0x0D	; 13
    c84a:	81 83       	std	Z+1, r24	; 0x01
				GSM_TxStr[GSMTxSz+2]='\n';
    c84c:	e0 91 6f 07 	lds	r30, 0x076F
    c850:	f0 e0       	ldi	r31, 0x00	; 0
    c852:	e4 50       	subi	r30, 0x04	; 4
    c854:	f6 4f       	sbci	r31, 0xF6	; 246
    c856:	8a e0       	ldi	r24, 0x0A	; 10
    c858:	82 83       	std	Z+2, r24	; 0x02
				GSMTxSz+=3;
    c85a:	80 91 6f 07 	lds	r24, 0x076F
    c85e:	8d 5f       	subi	r24, 0xFD	; 253
    c860:	80 93 6f 07 	sts	0x076F, r24
				GSM_SendFirstChar();
    c864:	0e 94 fd 38 	call	0x71fa	; 0x71fa <GSM_SendFirstChar>
				StartTimer16(TD_GSM, 1000);
    c868:	80 91 e1 04 	lds	r24, 0x04E1
    c86c:	68 ee       	ldi	r22, 0xE8	; 232
    c86e:	73 e0       	ldi	r23, 0x03	; 3
    c870:	0e 94 1d 1a 	call	0x343a	; 0x343a <StartTimer16>
			}
			GSM_State++;	
    c874:	80 91 ad 06 	lds	r24, 0x06AD
    c878:	8f 5f       	subi	r24, 0xFF	; 255
    c87a:	80 93 ad 06 	sts	0x06AD, r24
			GSM_Temp = 0;
    c87e:	10 92 d3 05 	sts	0x05D3, r1
    c882:	42 cc       	rjmp	.-1916   	; 0xc108 <GSM_Cycle+0x40>
			SetIP(&GSM_ClientIP,0,0,0,0);
			GSM_Flag |=(1<<flg_TxCStr);
			GSM_State++;
			break;
		case GSM_ReStart2:
			if(Timer16Stopp(TD_GSM)){
    c884:	80 91 e1 04 	lds	r24, 0x04E1
    c888:	0e 94 59 1b 	call	0x36b2	; 0x36b2 <Timer16Stopp>
    c88c:	88 23       	and	r24, r24
    c88e:	09 f4       	brne	.+2      	; 0xc892 <GSM_Cycle+0x7ca>
    c890:	3b cc       	rjmp	.-1930   	; 0xc108 <GSM_Cycle+0x40>
				GSM_State = GSM_PowerOn;
    c892:	10 92 ad 06 	sts	0x06AD, r1
    c896:	38 cc       	rjmp	.-1936   	; 0xc108 <GSM_Cycle+0x40>
		//------------------------

		
		//------------------------
		case GSM_ReStart1:
			GSM_ReStartN++;
    c898:	80 91 e7 08 	lds	r24, 0x08E7
    c89c:	8f 5f       	subi	r24, 0xFF	; 255
    c89e:	80 93 e7 08 	sts	0x08E7, r24
		cli();
		DDRL|=(1<<PL5);
		sei();
	}
	void GSM_PWRCNTRL_OFF(void){
		cli();
    c8a2:	f8 94       	cli
		PORTL|=(1<<PL5);
    c8a4:	80 91 0b 01 	lds	r24, 0x010B
    c8a8:	80 62       	ori	r24, 0x20	; 32
    c8aa:	80 93 0b 01 	sts	0x010B, r24
		sei();
    c8ae:	78 94       	sei
			GSM_PWRCNTRL_OFF();
			StartTimer16(TD_GSM,1000);
    c8b0:	80 91 e1 04 	lds	r24, 0x04E1
    c8b4:	68 ee       	ldi	r22, 0xE8	; 232
    c8b6:	73 e0       	ldi	r23, 0x03	; 3
    c8b8:	0e 94 1d 1a 	call	0x343a	; 0x343a <StartTimer16>
			RxBufOverFlow = 0;
    c8bc:	10 92 fb 0a 	sts	0x0AFB, r1
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    c8c0:	8f ef       	ldi	r24, 0xFF	; 255
    c8c2:	80 93 f4 06 	sts	0x06F4, r24
	GSM_RX_FIFO_End = 255;
    c8c6:	80 93 4b 06 	sts	0x064B, r24
	GSM_RxCharN = 0;
    c8ca:	10 92 12 0b 	sts	0x0B12, r1
	GSM_RX_FIFOOverFlow = 0;
    c8ce:	10 92 c5 08 	sts	0x08C5, r1
	GSM_RX_FIFOMax = 0;
    c8d2:	10 92 cb 08 	sts	0x08CB, r1
    c8d6:	e3 e9       	ldi	r30, 0x93	; 147
    c8d8:	f7 e0       	ldi	r31, 0x07	; 7
			RxBufOverFlow = 0;
		//	WebSession=0;
			InitFIFO();
			for(int i=0;i<GSM_RXSTR_SIZE;i++)
			{
				GSM_RxStr[i]=0;	
    c8da:	11 92       	st	Z+, r1
			GSM_PWRCNTRL_OFF();
			StartTimer16(TD_GSM,1000);
			RxBufOverFlow = 0;
		//	WebSession=0;
			InitFIFO();
			for(int i=0;i<GSM_RXSTR_SIZE;i++)
    c8dc:	27 e0       	ldi	r18, 0x07	; 7
    c8de:	e7 3f       	cpi	r30, 0xF7	; 247
    c8e0:	f2 07       	cpc	r31, r18
    c8e2:	d9 f7       	brne	.-10     	; 0xc8da <GSM_Cycle+0x812>
			{
				GSM_RxStr[i]=0;	
			}
			SMS_FlgSz_Out = 0;	// ..          -  
    c8e4:	10 92 7c 07 	sts	0x077C, r1
			GSM_ActiveConnection = NO_CONNECTION;
    c8e8:	8f ef       	ldi	r24, 0xFF	; 255
    c8ea:	80 93 d0 02 	sts	0x02D0, r24
	uint8_t IP4;
} IP_Addr;

//~~~~~~~~~~~~~~
void SetIP(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	IP->IP1 = IP1;
    c8ee:	10 92 fc 0a 	sts	0x0AFC, r1
	IP->IP2 = IP2;
    c8f2:	10 92 fd 0a 	sts	0x0AFD, r1
	IP->IP3 = IP3;
    c8f6:	10 92 fe 0a 	sts	0x0AFE, r1
	IP->IP4 = IP4;
    c8fa:	10 92 ff 0a 	sts	0x0AFF, r1
			SetIP(&GSM_ClientIP,0,0,0,0);
			GSM_Flag |=(1<<flg_TxCStr);
    c8fe:	80 91 cf 02 	lds	r24, 0x02CF
    c902:	81 60       	ori	r24, 0x01	; 1
    c904:	80 93 cf 02 	sts	0x02CF, r24
			GSM_State++;
    c908:	80 91 ad 06 	lds	r24, 0x06AD
    c90c:	8f 5f       	subi	r24, 0xFF	; 255
    c90e:	80 93 ad 06 	sts	0x06AD, r24
    c912:	fa cb       	rjmp	.-2060   	; 0xc108 <GSM_Cycle+0x40>
			break;
		case GSM_SEND_CGATT0:
			GSM_Execute_Command(AT_CGATT_0, 1000*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CGATT0_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    c914:	8d ee       	ldi	r24, 0xED	; 237
    c916:	93 e0       	ldi	r25, 0x03	; 3
    c918:	68 e4       	ldi	r22, 0x48	; 72
    c91a:	0e 94 ab 49 	call	0x9356	; 0x9356 <GSM_Wait_Response_P>
    c91e:	88 23       	and	r24, r24
    c920:	09 f4       	brne	.+2      	; 0xc924 <GSM_Cycle+0x85c>
    c922:	f2 cb       	rjmp	.-2076   	; 0xc108 <GSM_Cycle+0x40>
				StartTimer16(TD_GSM, 1000);
    c924:	80 91 e1 04 	lds	r24, 0x04E1
    c928:	68 ee       	ldi	r22, 0xE8	; 232
    c92a:	73 e0       	ldi	r23, 0x03	; 3
    c92c:	0e 94 1d 1a 	call	0x343a	; 0x343a <StartTimer16>
			 	GSM_State = GSM_SEND_ATD_Check_Ballance;
    c930:	8a e4       	ldi	r24, 0x4A	; 74
    c932:	80 93 ad 06 	sts	0x06AD, r24
    c936:	e8 cb       	rjmp	.-2096   	; 0xc108 <GSM_Cycle+0x40>
			break;
		case GSM_ShutWait_:
			if(GSM_Wait_Response_P(RESP_SHUT_OK, GSM_ReStart1)) GSM_State++;
			break;
		case GSM_SEND_CGATT0:
			GSM_Execute_Command(AT_CGATT_0, 1000*GSM_DEBUG_DELAY); GSM_State++;
    c938:	82 ee       	ldi	r24, 0xE2	; 226
    c93a:	95 e0       	ldi	r25, 0x05	; 5
    c93c:	68 ee       	ldi	r22, 0xE8	; 232
    c93e:	73 e0       	ldi	r23, 0x03	; 3
    c940:	0e 94 06 4a 	call	0x940c	; 0x940c <GSM_Execute_Command>
    c944:	80 91 ad 06 	lds	r24, 0x06AD
    c948:	8f 5f       	subi	r24, 0xFF	; 255
    c94a:	80 93 ad 06 	sts	0x06AD, r24
    c94e:	dc cb       	rjmp	.-2120   	; 0xc108 <GSM_Cycle+0x40>
		//------------------------
		case GSM_CIPSHUT_:
			GSM_Execute_Command(AT_CIPSHUT, 1000*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_ShutWait_:
			if(GSM_Wait_Response_P(RESP_SHUT_OK, GSM_ReStart1)) GSM_State++;
    c950:	85 e4       	ldi	r24, 0x45	; 69
    c952:	94 e0       	ldi	r25, 0x04	; 4
    c954:	68 e4       	ldi	r22, 0x48	; 72
    c956:	0e 94 ab 49 	call	0x9356	; 0x9356 <GSM_Wait_Response_P>
    c95a:	88 23       	and	r24, r24
    c95c:	09 f4       	brne	.+2      	; 0xc960 <GSM_Cycle+0x898>
    c95e:	d4 cb       	rjmp	.-2136   	; 0xc108 <GSM_Cycle+0x40>
    c960:	80 91 ad 06 	lds	r24, 0x06AD
    c964:	8f 5f       	subi	r24, 0xFF	; 255
    c966:	80 93 ad 06 	sts	0x06AD, r24
    c96a:	ce cb       	rjmp	.-2148   	; 0xc108 <GSM_Cycle+0x40>
		//------------------------

		//-----------

		case GSM_ProtocolMode:
			if( (strstr_P(GSM_RxStr, URC_CLOSED+2) != NULL) ){
    c96c:	83 e9       	ldi	r24, 0x93	; 147
    c96e:	97 e0       	ldi	r25, 0x07	; 7
    c970:	60 ed       	ldi	r22, 0xD0	; 208
    c972:	73 e0       	ldi	r23, 0x03	; 3
    c974:	0e 94 ac 7a 	call	0xf558	; 0xf558 <strstr_P>
    c978:	89 2b       	or	r24, r25
    c97a:	a9 f0       	breq	.+42     	; 0xc9a6 <GSM_Cycle+0x8de>
					GSM_State =GSM_ReStart1;
    c97c:	88 e4       	ldi	r24, 0x48	; 72
    c97e:	80 93 ad 06 	sts	0x06AD, r24
    c982:	c2 cb       	rjmp	.-2172   	; 0xc108 <GSM_Cycle+0x40>

			while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){	
					GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);
					if(GSM_RxCharN==2)
						{
							if(!strncmp_P(GSM_RxStr, PSTR("\r\n"), 2)) {GSM_RxCharN=0;}
    c984:	83 e9       	ldi	r24, 0x93	; 147
    c986:	97 e0       	ldi	r25, 0x07	; 7
    c988:	6a ed       	ldi	r22, 0xDA	; 218
    c98a:	7b e2       	ldi	r23, 0x2B	; 43
    c98c:	42 e0       	ldi	r20, 0x02	; 2
    c98e:	50 e0       	ldi	r21, 0x00	; 0
    c990:	0e 94 93 7a 	call	0xf526	; 0xf526 <strncmp_P>
    c994:	89 2b       	or	r24, r25
    c996:	11 f4       	brne	.+4      	; 0xc99c <GSM_Cycle+0x8d4>
    c998:	10 92 12 0b 	sts	0x0B12, r1
						}
					if(GSM_RxCharN >= 4){
    c99c:	80 91 12 0b 	lds	r24, 0x0B12
    c9a0:	84 30       	cpi	r24, 0x04	; 4
    c9a2:	08 f0       	brcs	.+2      	; 0xc9a6 <GSM_Cycle+0x8de>
    c9a4:	95 c3       	rjmp	.+1834   	; 0xd0d0 <GSM_Cycle+0x1008>
					break;
			}



			while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){	
    c9a6:	90 91 f4 06 	lds	r25, 0x06F4
    c9aa:	80 91 4b 06 	lds	r24, 0x064B
    c9ae:	98 17       	cp	r25, r24
    c9b0:	09 f4       	brne	.+2      	; 0xc9b4 <GSM_Cycle+0x8ec>
    c9b2:	d0 c3       	rjmp	.+1952   	; 0xd154 <GSM_Cycle+0x108c>
					GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);
    c9b4:	83 e9       	ldi	r24, 0x93	; 147
    c9b6:	97 e0       	ldi	r25, 0x07	; 7
    c9b8:	62 e1       	ldi	r22, 0x12	; 18
    c9ba:	7b e0       	ldi	r23, 0x0B	; 11
    c9bc:	44 e6       	ldi	r20, 0x64	; 100
    c9be:	0e 94 69 37 	call	0x6ed2	; 0x6ed2 <GetByteFromFIFO>
					if(GSM_RxCharN==2)
    c9c2:	80 91 12 0b 	lds	r24, 0x0B12
    c9c6:	82 30       	cpi	r24, 0x02	; 2
    c9c8:	49 f7       	brne	.-46     	; 0xc99c <GSM_Cycle+0x8d4>
    c9ca:	dc cf       	rjmp	.-72     	; 0xc984 <GSM_Cycle+0x8bc>
						}
					}
				}
			break;
		case GSM_WAIT_CSQ_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) {
    c9cc:	8d ee       	ldi	r24, 0xED	; 237
    c9ce:	93 e0       	ldi	r25, 0x03	; 3
    c9d0:	68 e4       	ldi	r22, 0x48	; 72
    c9d2:	0e 94 ab 49 	call	0x9356	; 0x9356 <GSM_Wait_Response_P>
    c9d6:	88 23       	and	r24, r24
    c9d8:	09 f4       	brne	.+2      	; 0xc9dc <GSM_Cycle+0x914>
    c9da:	96 cb       	rjmp	.-2260   	; 0xc108 <GSM_Cycle+0x40>
				if(CommandModeDestination==5){
    c9dc:	80 91 65 07 	lds	r24, 0x0765
    c9e0:	85 30       	cpi	r24, 0x05	; 5
    c9e2:	09 f4       	brne	.+2      	; 0xc9e6 <GSM_Cycle+0x91e>
    c9e4:	eb c4       	rjmp	.+2518   	; 0xd3bc <GSM_Cycle+0x12f4>
					GSM_State  = GSM_Return2dataMode;
				}
				else{
					GSM_State=GSM_SEND_CIPMUX;
    c9e6:	88 e2       	ldi	r24, 0x28	; 40
    c9e8:	80 93 ad 06 	sts	0x06AD, r24
    c9ec:	8d cb       	rjmp	.-2278   	; 0xc108 <GSM_Cycle+0x40>
				GSM_Execute_Command(AT_CSQ, 500*GSM_DEBUG_DELAY); 
				InitFIFO();
				GSM_State++;
			break;
		case GSM_WAIT_CSQ:
				if(Timer16Stopp(TD_GSM)){
    c9ee:	80 91 e1 04 	lds	r24, 0x04E1
    c9f2:	0e 94 59 1b 	call	0x36b2	; 0x36b2 <Timer16Stopp>
    c9f6:	88 23       	and	r24, r24
    c9f8:	09 f4       	brne	.+2      	; 0xc9fc <GSM_Cycle+0x934>
    c9fa:	e6 c3       	rjmp	.+1996   	; 0xd1c8 <GSM_Cycle+0x1100>
						GSM_State = GSM_ReStart1;
    c9fc:	88 e4       	ldi	r24, 0x48	; 72
    c9fe:	80 93 ad 06 	sts	0x06AD, r24
    ca02:	82 cb       	rjmp	.-2300   	; 0xc108 <GSM_Cycle+0x40>
				}
		
			break;

		case GSM_WAIT_CIPSTART_TCP_CLIENT_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    ca04:	8d ee       	ldi	r24, 0xED	; 237
    ca06:	93 e0       	ldi	r25, 0x03	; 3
    ca08:	68 e4       	ldi	r22, 0x48	; 72
    ca0a:	0e 94 ab 49 	call	0x9356	; 0x9356 <GSM_Wait_Response_P>
    ca0e:	88 23       	and	r24, r24
    ca10:	09 f4       	brne	.+2      	; 0xca14 <GSM_Cycle+0x94c>
    ca12:	7a cb       	rjmp	.-2316   	; 0xc108 <GSM_Cycle+0x40>
    ca14:	80 91 ad 06 	lds	r24, 0x06AD
    ca18:	8f 5f       	subi	r24, 0xFF	; 255
    ca1a:	80 93 ad 06 	sts	0x06AD, r24
    ca1e:	74 cb       	rjmp	.-2328   	; 0xc108 <GSM_Cycle+0x40>
				GSM_State =GSM_ReStart1;
				break;
			}			
			break;
		case GSM_Swtch2CommandMode:
			StartTimer16(TD_GSM,100);	// min 1000ms before +++
    ca20:	80 91 e1 04 	lds	r24, 0x04E1
    ca24:	64 e6       	ldi	r22, 0x64	; 100
    ca26:	70 e0       	ldi	r23, 0x00	; 0
    ca28:	0e 94 1d 1a 	call	0x343a	; 0x343a <StartTimer16>
//IF WEB			WebClose();
			GSM_State++;
    ca2c:	80 91 ad 06 	lds	r24, 0x06AD
    ca30:	8f 5f       	subi	r24, 0xFF	; 255
    ca32:	80 93 ad 06 	sts	0x06AD, r24
    ca36:	68 cb       	rjmp	.-2352   	; 0xc108 <GSM_Cycle+0x40>
			}
			break;

		case GSM_DataMode:
			// -----    
			if(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){	// if FIFO not empty
    ca38:	90 91 f4 06 	lds	r25, 0x06F4
    ca3c:	80 91 4b 06 	lds	r24, 0x064B
    ca40:	98 17       	cp	r25, r24
    ca42:	09 f4       	brne	.+2      	; 0xca46 <GSM_Cycle+0x97e>
    ca44:	92 c4       	rjmp	.+2340   	; 0xd36a <GSM_Cycle+0x12a2>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    ca46:	83 ec       	ldi	r24, 0xC3	; 195
    ca48:	90 e0       	ldi	r25, 0x00	; 0
    ca4a:	0e 94 b2 7d 	call	0xfb64	; 0xfb64 <__eerd_word_m2560>
    ca4e:	bc 01       	movw	r22, r24
				StartTimer16(TD_TCP_Connect, erw(&TCP_CONNECT_timeout));	//   
    ca50:	80 91 e2 04 	lds	r24, 0x04E2
    ca54:	0e 94 1d 1a 	call	0x343a	; 0x343a <StartTimer16>
    ca58:	57 cb       	rjmp	.-2386   	; 0xc108 <GSM_Cycle+0x40>
//IF WEB			WebClose();
			GSM_State++;

			break;
		case GSM_Swtch2CommandModePlus:
			if(Timer16Stopp(TD_GSM)){
    ca5a:	80 91 e1 04 	lds	r24, 0x04E1
    ca5e:	0e 94 59 1b 	call	0x36b2	; 0x36b2 <Timer16Stopp>
    ca62:	88 23       	and	r24, r24
    ca64:	09 f4       	brne	.+2      	; 0xca68 <GSM_Cycle+0x9a0>
    ca66:	50 cb       	rjmp	.-2400   	; 0xc108 <GSM_Cycle+0x40>
    ca68:	e3 e9       	ldi	r30, 0x93	; 147
    ca6a:	f7 e0       	ldi	r31, 0x07	; 7
				for(int i=0;i<GSM_RXSTR_SIZE;i++)
				{
					GSM_RxStr[i]=0;	
    ca6c:	11 92       	st	Z+, r1
			GSM_State++;

			break;
		case GSM_Swtch2CommandModePlus:
			if(Timer16Stopp(TD_GSM)){
				for(int i=0;i<GSM_RXSTR_SIZE;i++)
    ca6e:	27 e0       	ldi	r18, 0x07	; 7
    ca70:	e7 3f       	cpi	r30, 0xF7	; 247
    ca72:	f2 07       	cpc	r31, r18
    ca74:	d9 f7       	brne	.-10     	; 0xca6c <GSM_Cycle+0x9a4>
				{
					GSM_RxStr[i]=0;	
				}
				sprintf_P(GSM_TxStr, ESC_SEQ);
    ca76:	00 d0       	rcall	.+0      	; 0xca78 <GSM_Cycle+0x9b0>
    ca78:	0f 92       	push	r0
    ca7a:	0c ef       	ldi	r16, 0xFC	; 252
    ca7c:	19 e0       	ldi	r17, 0x09	; 9
    ca7e:	ad b7       	in	r26, 0x3d	; 61
    ca80:	be b7       	in	r27, 0x3e	; 62
    ca82:	12 96       	adiw	r26, 0x02	; 2
    ca84:	1c 93       	st	X, r17
    ca86:	0e 93       	st	-X, r16
    ca88:	11 97       	sbiw	r26, 0x01	; 1
    ca8a:	8d e4       	ldi	r24, 0x4D	; 77
    ca8c:	94 e0       	ldi	r25, 0x04	; 4
    ca8e:	14 96       	adiw	r26, 0x04	; 4
    ca90:	9c 93       	st	X, r25
    ca92:	8e 93       	st	-X, r24
    ca94:	13 97       	sbiw	r26, 0x03	; 3
    ca96:	0e 94 a7 7b 	call	0xf74e	; 0xf74e <sprintf_P>
				GSMTxSz = strlen(GSM_TxStr);
    ca9a:	f8 01       	movw	r30, r16
    ca9c:	01 90       	ld	r0, Z+
    ca9e:	00 20       	and	r0, r0
    caa0:	e9 f7       	brne	.-6      	; 0xca9c <GSM_Cycle+0x9d4>
    caa2:	8f 01       	movw	r16, r30
    caa4:	01 50       	subi	r16, 0x01	; 1
    caa6:	10 40       	sbci	r17, 0x00	; 0
    caa8:	0c 5f       	subi	r16, 0xFC	; 252
    caaa:	19 40       	sbci	r17, 0x09	; 9
    caac:	00 93 6f 07 	sts	0x076F, r16
				GSM_SendFirstChar();
    cab0:	0f 90       	pop	r0
    cab2:	0f 90       	pop	r0
    cab4:	0f 90       	pop	r0
    cab6:	0f 90       	pop	r0
    cab8:	0e 94 fd 38 	call	0x71fa	; 0x71fa <GSM_SendFirstChar>
				StartTimer16(TD_GSM,1000);	// min 500ms after +++
    cabc:	80 91 e1 04 	lds	r24, 0x04E1
    cac0:	68 ee       	ldi	r22, 0xE8	; 232
    cac2:	73 e0       	ldi	r23, 0x03	; 3
    cac4:	0e 94 1d 1a 	call	0x343a	; 0x343a <StartTimer16>
				GSM_State++;
    cac8:	80 91 ad 06 	lds	r24, 0x06AD
    cacc:	8f 5f       	subi	r24, 0xFF	; 255
    cace:	80 93 ad 06 	sts	0x06AD, r24
    cad2:	1a cb       	rjmp	.-2508   	; 0xc108 <GSM_Cycle+0x40>
			}
			break;

		//------------------------
		case GSM_SEND_CMGS:
			if(GSM_Flag & (1<<flg_TxCStr)){			
    cad4:	80 91 cf 02 	lds	r24, 0x02CF
    cad8:	80 ff       	sbrs	r24, 0
    cada:	16 cb       	rjmp	.-2516   	; 0xc108 <GSM_Cycle+0x40>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    cadc:	4c ef       	ldi	r20, 0xFC	; 252
    cade:	e4 2e       	mov	r14, r20
    cae0:	49 e0       	ldi	r20, 0x09	; 9
    cae2:	f4 2e       	mov	r15, r20
    cae4:	60 91 d4 05 	lds	r22, 0x05D4
    cae8:	8d e0       	ldi	r24, 0x0D	; 13
    caea:	68 9f       	mul	r22, r24
    caec:	b0 01       	movw	r22, r0
    caee:	11 24       	eor	r1, r1
    caf0:	6b 53       	subi	r22, 0x3B	; 59
    caf2:	7f 4f       	sbci	r23, 0xFF	; 255
    caf4:	c7 01       	movw	r24, r14
    caf6:	4d e0       	ldi	r20, 0x0D	; 13
    caf8:	50 e0       	ldi	r21, 0x00	; 0
    cafa:	0e 94 94 7d 	call	0xfb28	; 0xfb28 <__eerd_block_m2560>
				erbl(GSM_TxStr, SMS_Number+TempNum, MaxTelephN);
				GSMTxSz = strlen(GSM_TxStr);
    cafe:	f7 01       	movw	r30, r14
    cb00:	01 90       	ld	r0, Z+
    cb02:	00 20       	and	r0, r0
    cb04:	e9 f7       	brne	.-6      	; 0xcb00 <GSM_Cycle+0xa38>
    cb06:	31 97       	sbiw	r30, 0x01	; 1
    cb08:	ee 19       	sub	r30, r14
    cb0a:	ff 09       	sbc	r31, r15
    cb0c:	e0 93 6f 07 	sts	0x076F, r30
				uint8_t j=0;
				for(uint8_t i=0; i<GSMTxSz; i++)
    cb10:	80 91 6f 07 	lds	r24, 0x076F
    cb14:	88 23       	and	r24, r24
    cb16:	91 f0       	breq	.+36     	; 0xcb3c <GSM_Cycle+0xa74>
    cb18:	90 e0       	ldi	r25, 0x00	; 0
    cb1a:	20 e0       	ldi	r18, 0x00	; 0
					if(GSM_TxStr[i] != '0') j++;
    cb1c:	e9 2f       	mov	r30, r25
    cb1e:	f0 e0       	ldi	r31, 0x00	; 0
    cb20:	e4 50       	subi	r30, 0x04	; 4
    cb22:	f6 4f       	sbci	r31, 0xF6	; 246
    cb24:	80 81       	ld	r24, Z
    cb26:	80 33       	cpi	r24, 0x30	; 48
    cb28:	09 f0       	breq	.+2      	; 0xcb2c <GSM_Cycle+0xa64>
    cb2a:	2f 5f       	subi	r18, 0xFF	; 255
		case GSM_SEND_CMGS:
			if(GSM_Flag & (1<<flg_TxCStr)){			
				erbl(GSM_TxStr, SMS_Number+TempNum, MaxTelephN);
				GSMTxSz = strlen(GSM_TxStr);
				uint8_t j=0;
				for(uint8_t i=0; i<GSMTxSz; i++)
    cb2c:	9f 5f       	subi	r25, 0xFF	; 255
    cb2e:	80 91 6f 07 	lds	r24, 0x076F
    cb32:	98 17       	cp	r25, r24
    cb34:	98 f3       	brcs	.-26     	; 0xcb1c <GSM_Cycle+0xa54>
					if(GSM_TxStr[i] != '0') j++;
				if(j){
    cb36:	22 23       	and	r18, r18
    cb38:	09 f0       	breq	.+2      	; 0xcb3c <GSM_Cycle+0xa74>
    cb3a:	66 c4       	rjmp	.+2252   	; 0xd408 <GSM_Cycle+0x1340>
					GSM_SendFirstChar();
					StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
					GSM_State++;
				}
				else{
					TempNum++;
    cb3c:	80 91 d4 05 	lds	r24, 0x05D4
    cb40:	8f 5f       	subi	r24, 0xFF	; 255
    cb42:	80 93 d4 05 	sts	0x05D4, r24
					if(TempNum>=MaxTelephDirSz){
    cb46:	83 30       	cpi	r24, 0x03	; 3
    cb48:	08 f4       	brcc	.+2      	; 0xcb4c <GSM_Cycle+0xa84>
    cb4a:	de ca       	rjmp	.-2628   	; 0xc108 <GSM_Cycle+0x40>
						//StartTimer16(TD_GSM,150);

						GSM_State = GSM_Return2dataMode;
    cb4c:	85 e5       	ldi	r24, 0x55	; 85
    cb4e:	80 93 ad 06 	sts	0x06AD, r24
				
						SMS_FlgSz_Out = 0;
    cb52:	10 92 7c 07 	sts	0x077C, r1
    cb56:	d8 ca       	rjmp	.-2640   	; 0xc108 <GSM_Cycle+0x40>
			break;

		case GSM_AnalyzeURC:			//  
			
			// 
			if( (strstr_P(GSM_RxStr, URC_CLOSED+2) != NULL) ){
    cb58:	03 e9       	ldi	r16, 0x93	; 147
    cb5a:	17 e0       	ldi	r17, 0x07	; 7
    cb5c:	c8 01       	movw	r24, r16
    cb5e:	60 ed       	ldi	r22, 0xD0	; 208
    cb60:	73 e0       	ldi	r23, 0x03	; 3
    cb62:	0e 94 ac 7a 	call	0xf558	; 0xf558 <strstr_P>
    cb66:	89 2b       	or	r24, r25
    cb68:	09 f4       	brne	.+2      	; 0xcb6c <GSM_Cycle+0xaa4>
    cb6a:	ad c4       	rjmp	.+2394   	; 0xd4c6 <GSM_Cycle+0x13fe>
				GSM_State =GSM_ReStart1;
    cb6c:	88 e4       	ldi	r24, 0x48	; 72
    cb6e:	80 93 ad 06 	sts	0x06AD, r24
    cb72:	ca ca       	rjmp	.-2668   	; 0xc108 <GSM_Cycle+0x40>
			}	
			break;

		//------------------------   GSM-
		case GSM_SEND_CSQ:
				GSM_Execute_Command(AT_CSQ, 500*GSM_DEBUG_DELAY); 
    cb74:	8d ee       	ldi	r24, 0xED	; 237
    cb76:	95 e0       	ldi	r25, 0x05	; 5
    cb78:	64 ef       	ldi	r22, 0xF4	; 244
    cb7a:	71 e0       	ldi	r23, 0x01	; 1
    cb7c:	0e 94 06 4a 	call	0x940c	; 0x940c <GSM_Execute_Command>
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    cb80:	8f ef       	ldi	r24, 0xFF	; 255
    cb82:	80 93 f4 06 	sts	0x06F4, r24
	GSM_RX_FIFO_End = 255;
    cb86:	80 93 4b 06 	sts	0x064B, r24
	GSM_RxCharN = 0;
    cb8a:	10 92 12 0b 	sts	0x0B12, r1
	GSM_RX_FIFOOverFlow = 0;
    cb8e:	10 92 c5 08 	sts	0x08C5, r1
	GSM_RX_FIFOMax = 0;
    cb92:	10 92 cb 08 	sts	0x08CB, r1

		//------------------------   GSM-
		case GSM_SEND_CSQ:
				GSM_Execute_Command(AT_CSQ, 500*GSM_DEBUG_DELAY); 
				InitFIFO();
				GSM_State++;
    cb96:	80 91 ad 06 	lds	r24, 0x06AD
    cb9a:	8f 5f       	subi	r24, 0xFF	; 255
    cb9c:	80 93 ad 06 	sts	0x06AD, r24
    cba0:	b3 ca       	rjmp	.-2714   	; 0xc108 <GSM_Cycle+0x40>

		case GSM_SEND_CIICR:
			GSM_Execute_Command(AT_CIICR, 12000*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CIICR_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    cba2:	8d ee       	ldi	r24, 0xED	; 237
    cba4:	93 e0       	ldi	r25, 0x03	; 3
    cba6:	68 e4       	ldi	r22, 0x48	; 72
    cba8:	0e 94 ab 49 	call	0x9356	; 0x9356 <GSM_Wait_Response_P>
    cbac:	88 23       	and	r24, r24
    cbae:	09 f4       	brne	.+2      	; 0xcbb2 <GSM_Cycle+0xaea>
    cbb0:	ab ca       	rjmp	.-2730   	; 0xc108 <GSM_Cycle+0x40>
    cbb2:	80 91 ad 06 	lds	r24, 0x06AD
    cbb6:	8f 5f       	subi	r24, 0xFF	; 255
    cbb8:	80 93 ad 06 	sts	0x06AD, r24
    cbbc:	a5 ca       	rjmp	.-2742   	; 0xc108 <GSM_Cycle+0x40>
		case GSM_WAIT_CSTT_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;

		case GSM_SEND_CIICR:
			GSM_Execute_Command(AT_CIICR, 12000*GSM_DEBUG_DELAY); GSM_State++;
    cbbe:	82 e4       	ldi	r24, 0x42	; 66
    cbc0:	95 e0       	ldi	r25, 0x05	; 5
    cbc2:	60 ee       	ldi	r22, 0xE0	; 224
    cbc4:	7e e2       	ldi	r23, 0x2E	; 46
    cbc6:	0e 94 06 4a 	call	0x940c	; 0x940c <GSM_Execute_Command>
    cbca:	80 91 ad 06 	lds	r24, 0x06AD
    cbce:	8f 5f       	subi	r24, 0xFF	; 255
    cbd0:	80 93 ad 06 	sts	0x06AD, r24
    cbd4:	99 ca       	rjmp	.-2766   	; 0xc108 <GSM_Cycle+0x40>

		case GSM_SEND_CSTT:
			GSM_Execute_Command(AT_CSTT, 300*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CSTT_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    cbd6:	8d ee       	ldi	r24, 0xED	; 237
    cbd8:	93 e0       	ldi	r25, 0x03	; 3
    cbda:	68 e4       	ldi	r22, 0x48	; 72
    cbdc:	0e 94 ab 49 	call	0x9356	; 0x9356 <GSM_Wait_Response_P>
    cbe0:	88 23       	and	r24, r24
    cbe2:	09 f4       	brne	.+2      	; 0xcbe6 <GSM_Cycle+0xb1e>
    cbe4:	91 ca       	rjmp	.-2782   	; 0xc108 <GSM_Cycle+0x40>
    cbe6:	80 91 ad 06 	lds	r24, 0x06AD
    cbea:	8f 5f       	subi	r24, 0xFF	; 255
    cbec:	80 93 ad 06 	sts	0x06AD, r24
    cbf0:	8b ca       	rjmp	.-2794   	; 0xc108 <GSM_Cycle+0x40>
		case GSM_WAIT_CIPTKA_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;

		case GSM_SEND_CSTT:
			GSM_Execute_Command(AT_CSTT, 300*GSM_DEBUG_DELAY); GSM_State++;
    cbf2:	8a e3       	ldi	r24, 0x3A	; 58
    cbf4:	95 e0       	ldi	r25, 0x05	; 5
    cbf6:	6c e2       	ldi	r22, 0x2C	; 44
    cbf8:	71 e0       	ldi	r23, 0x01	; 1
    cbfa:	0e 94 06 4a 	call	0x940c	; 0x940c <GSM_Execute_Command>
    cbfe:	80 91 ad 06 	lds	r24, 0x06AD
    cc02:	8f 5f       	subi	r24, 0xFF	; 255
    cc04:	80 93 ad 06 	sts	0x06AD, r24
    cc08:	7f ca       	rjmp	.-2818   	; 0xc108 <GSM_Cycle+0x40>

		case GSM_SEND_CIFSR:
			GSM_Execute_Command(AT_CIFSR, 1000*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CIFSR_OK:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
    cc0a:	80 91 e1 04 	lds	r24, 0x04E1
    cc0e:	0e 94 59 1b 	call	0x36b2	; 0x36b2 <Timer16Stopp>
    cc12:	88 23       	and	r24, r24
    cc14:	19 f0       	breq	.+6      	; 0xcc1c <GSM_Cycle+0xb54>
    cc16:	88 e4       	ldi	r24, 0x48	; 72
    cc18:	80 93 ad 06 	sts	0x06AD, r24
			if(GetStringFromFIFO()){
    cc1c:	0e 94 d3 37 	call	0x6fa6	; 0x6fa6 <GetStringFromFIFO>
    cc20:	88 23       	and	r24, r24
    cc22:	09 f4       	brne	.+2      	; 0xcc26 <GSM_Cycle+0xb5e>
    cc24:	71 ca       	rjmp	.-2846   	; 0xc108 <GSM_Cycle+0x40>
	uint8_t IP4;
} IP_Addr;

//~~~~~~~~~~~~~~
void SetIP(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	IP->IP1 = IP1;
    cc26:	43 ee       	ldi	r20, 0xE3	; 227
    cc28:	58 e0       	ldi	r21, 0x08	; 8
    cc2a:	10 92 e3 08 	sts	0x08E3, r1
	IP->IP2 = IP2;
    cc2e:	ba 01       	movw	r22, r20
    cc30:	6f 5f       	subi	r22, 0xFF	; 255
    cc32:	7f 4f       	sbci	r23, 0xFF	; 255
    cc34:	10 92 e4 08 	sts	0x08E4, r1
	IP->IP3 = IP3;
    cc38:	8a 01       	movw	r16, r20
    cc3a:	0e 5f       	subi	r16, 0xFE	; 254
    cc3c:	1f 4f       	sbci	r17, 0xFF	; 255
    cc3e:	10 92 e5 08 	sts	0x08E5, r1
	IP->IP4 = IP4;
    cc42:	e3 e0       	ldi	r30, 0x03	; 3
    cc44:	ee 2e       	mov	r14, r30
    cc46:	f1 2c       	mov	r15, r1
    cc48:	e4 0e       	add	r14, r20
    cc4a:	f5 1e       	adc	r15, r21
    cc4c:	10 92 e6 08 	sts	0x08E6, r1
    cc50:	20 e0       	ldi	r18, 0x00	; 0
    cc52:	a3 e9       	ldi	r26, 0x93	; 147
    cc54:	b7 e0       	ldi	r27, 0x07	; 7
				SetIP(&GSM_MyIP,0,0,0,0);
				for(uint8_t i=0; i<strlen(GSM_RxStr); i++)
					if(!isdigit(GSM_RxStr[i])) GSM_RxStr[i] = ' ';
    cc56:	30 e2       	ldi	r19, 0x20	; 32
			break;
		case GSM_WAIT_CIFSR_OK:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
			if(GetStringFromFIFO()){
				SetIP(&GSM_MyIP,0,0,0,0);
				for(uint8_t i=0; i<strlen(GSM_RxStr); i++)
    cc58:	fd 01       	movw	r30, r26
    cc5a:	01 90       	ld	r0, Z+
    cc5c:	00 20       	and	r0, r0
    cc5e:	e9 f7       	brne	.-6      	; 0xcc5a <GSM_Cycle+0xb92>
    cc60:	31 97       	sbiw	r30, 0x01	; 1
    cc62:	e3 59       	subi	r30, 0x93	; 147
    cc64:	f7 40       	sbci	r31, 0x07	; 7
    cc66:	82 2f       	mov	r24, r18
    cc68:	90 e0       	ldi	r25, 0x00	; 0
    cc6a:	8e 17       	cp	r24, r30
    cc6c:	9f 07       	cpc	r25, r31
    cc6e:	08 f0       	brcs	.+2      	; 0xcc72 <GSM_Cycle+0xbaa>
    cc70:	e3 c1       	rjmp	.+966    	; 0xd038 <GSM_Cycle+0xf70>
					if(!isdigit(GSM_RxStr[i])) GSM_RxStr[i] = ' ';
    cc72:	fc 01       	movw	r30, r24
    cc74:	ed 56       	subi	r30, 0x6D	; 109
    cc76:	f8 4f       	sbci	r31, 0xF8	; 248
    cc78:	80 81       	ld	r24, Z
    cc7a:	90 e0       	ldi	r25, 0x00	; 0
    cc7c:	c0 97       	sbiw	r24, 0x30	; 48
    cc7e:	0a 97       	sbiw	r24, 0x0a	; 10
    cc80:	08 f0       	brcs	.+2      	; 0xcc84 <GSM_Cycle+0xbbc>
    cc82:	30 83       	st	Z, r19
			break;
		case GSM_WAIT_CIFSR_OK:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
			if(GetStringFromFIFO()){
				SetIP(&GSM_MyIP,0,0,0,0);
				for(uint8_t i=0; i<strlen(GSM_RxStr); i++)
    cc84:	2f 5f       	subi	r18, 0xFF	; 255
    cc86:	e8 cf       	rjmp	.-48     	; 0xcc58 <GSM_Cycle+0xb90>
			break;

	

		case GSM_SEND_CIFSR:
			GSM_Execute_Command(AT_CIFSR, 1000*GSM_DEBUG_DELAY); GSM_State++;
    cc88:	8b e4       	ldi	r24, 0x4B	; 75
    cc8a:	95 e0       	ldi	r25, 0x05	; 5
    cc8c:	68 ee       	ldi	r22, 0xE8	; 232
    cc8e:	73 e0       	ldi	r23, 0x03	; 3
    cc90:	0e 94 06 4a 	call	0x940c	; 0x940c <GSM_Execute_Command>
    cc94:	80 91 ad 06 	lds	r24, 0x06AD
    cc98:	8f 5f       	subi	r24, 0xFF	; 255
    cc9a:	80 93 ad 06 	sts	0x06AD, r24
    cc9e:	34 ca       	rjmp	.-2968   	; 0xc108 <GSM_Cycle+0x40>
			}			
			break;
		//------------------------
		case GSM_SEND_CIPSTART_TCP_CLIENT:
	
				if(GSM_Flag & (1<<flg_TxCStr)){
    cca0:	80 91 cf 02 	lds	r24, 0x02CF
    cca4:	80 ff       	sbrs	r24, 0
    cca6:	30 ca       	rjmp	.-2976   	; 0xc108 <GSM_Cycle+0x40>
					GSMTxSz = strlen_P(AT_CIPSTART_TCP_CLIENT);
    cca8:	5b e7       	ldi	r21, 0x7B	; 123
    ccaa:	e5 2e       	mov	r14, r21
    ccac:	55 e0       	ldi	r21, 0x05	; 5
    ccae:	f5 2e       	mov	r15, r21
    ccb0:	c7 01       	movw	r24, r14
    ccb2:	0e 94 8a 7a 	call	0xf514	; 0xf514 <strlen_P>
    ccb6:	80 93 6f 07 	sts	0x076F, r24
					sprintf_P(GSM_TxStr, AT_CIPSTART_TCP_CLIENT);
    ccba:	00 d0       	rcall	.+0      	; 0xccbc <GSM_Cycle+0xbf4>
    ccbc:	0f 92       	push	r0
    ccbe:	0c ef       	ldi	r16, 0xFC	; 252
    ccc0:	19 e0       	ldi	r17, 0x09	; 9
    ccc2:	ad b7       	in	r26, 0x3d	; 61
    ccc4:	be b7       	in	r27, 0x3e	; 62
    ccc6:	12 96       	adiw	r26, 0x02	; 2
    ccc8:	1c 93       	st	X, r17
    ccca:	0e 93       	st	-X, r16
    cccc:	11 97       	sbiw	r26, 0x01	; 1
    ccce:	14 96       	adiw	r26, 0x04	; 4
    ccd0:	fc 92       	st	X, r15
    ccd2:	ee 92       	st	-X, r14
    ccd4:	13 97       	sbiw	r26, 0x03	; 3
    ccd6:	0e 94 a7 7b 	call	0xf74e	; 0xf74e <sprintf_P>
					//GSM_TxStr[12] = 0x30+TempNum;
					sprintf(GSM_TxStr + GSMTxSz, "\"%u.%u.%u.%u\",\"%u\"\r",(unsigned int)erb(&TCP_ServerIP[0].IP1), (unsigned int)erb(&TCP_ServerIP[0].IP2), 
    ccda:	b0 90 6f 07 	lds	r11, 0x076F
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    ccde:	0f 90       	pop	r0
    cce0:	0f 90       	pop	r0
    cce2:	0f 90       	pop	r0
    cce4:	0f 90       	pop	r0
    cce6:	81 e9       	ldi	r24, 0x91	; 145
    cce8:	90 e0       	ldi	r25, 0x00	; 0
    ccea:	0e 94 a4 7d 	call	0xfb48	; 0xfb48 <__eerd_byte_m2560>
    ccee:	f8 2e       	mov	r15, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    ccf0:	82 e9       	ldi	r24, 0x92	; 146
    ccf2:	90 e0       	ldi	r25, 0x00	; 0
    ccf4:	0e 94 a4 7d 	call	0xfb48	; 0xfb48 <__eerd_byte_m2560>
    ccf8:	e8 2e       	mov	r14, r24
    ccfa:	83 e9       	ldi	r24, 0x93	; 147
    ccfc:	90 e0       	ldi	r25, 0x00	; 0
    ccfe:	0e 94 a4 7d 	call	0xfb48	; 0xfb48 <__eerd_byte_m2560>
    cd02:	d8 2e       	mov	r13, r24
    cd04:	84 e9       	ldi	r24, 0x94	; 148
    cd06:	90 e0       	ldi	r25, 0x00	; 0
    cd08:	0e 94 a4 7d 	call	0xfb48	; 0xfb48 <__eerd_byte_m2560>
    cd0c:	c8 2e       	mov	r12, r24
    cd0e:	89 ea       	ldi	r24, 0xA9	; 169
    cd10:	90 e0       	ldi	r25, 0x00	; 0
    cd12:	0e 94 b2 7d 	call	0xfb64	; 0xfb64 <__eerd_word_m2560>
    cd16:	ed b7       	in	r30, 0x3d	; 61
    cd18:	fe b7       	in	r31, 0x3e	; 62
    cd1a:	3e 97       	sbiw	r30, 0x0e	; 14
    cd1c:	0f b6       	in	r0, 0x3f	; 63
    cd1e:	f8 94       	cli
    cd20:	fe bf       	out	0x3e, r31	; 62
    cd22:	0f be       	out	0x3f, r0	; 63
    cd24:	ed bf       	out	0x3d, r30	; 61
    cd26:	31 96       	adiw	r30, 0x01	; 1
    cd28:	2b 2d       	mov	r18, r11
    cd2a:	30 e0       	ldi	r19, 0x00	; 0
    cd2c:	20 0f       	add	r18, r16
    cd2e:	31 1f       	adc	r19, r17
    cd30:	ad b7       	in	r26, 0x3d	; 61
    cd32:	be b7       	in	r27, 0x3e	; 62
    cd34:	12 96       	adiw	r26, 0x02	; 2
    cd36:	3c 93       	st	X, r19
    cd38:	2e 93       	st	-X, r18
    cd3a:	11 97       	sbiw	r26, 0x01	; 1
    cd3c:	25 eb       	ldi	r18, 0xB5	; 181
    cd3e:	32 e0       	ldi	r19, 0x02	; 2
    cd40:	33 83       	std	Z+3, r19	; 0x03
    cd42:	22 83       	std	Z+2, r18	; 0x02
    cd44:	f4 82       	std	Z+4, r15	; 0x04
    cd46:	15 82       	std	Z+5, r1	; 0x05
    cd48:	e6 82       	std	Z+6, r14	; 0x06
    cd4a:	17 82       	std	Z+7, r1	; 0x07
    cd4c:	d0 86       	std	Z+8, r13	; 0x08
    cd4e:	11 86       	std	Z+9, r1	; 0x09
    cd50:	c2 86       	std	Z+10, r12	; 0x0a
    cd52:	13 86       	std	Z+11, r1	; 0x0b
    cd54:	95 87       	std	Z+13, r25	; 0x0d
    cd56:	84 87       	std	Z+12, r24	; 0x0c
    cd58:	0e 94 76 7b 	call	0xf6ec	; 0xf6ec <sprintf>
						(unsigned int)erb(&TCP_ServerIP[0].IP3), (unsigned int)erb(&TCP_ServerIP[0].IP4), (unsigned int)erw(&TCP_ServerPort[0]));
					GSMTxSz = strlen(GSM_TxStr);
    cd5c:	f8 01       	movw	r30, r16
    cd5e:	01 90       	ld	r0, Z+
    cd60:	00 20       	and	r0, r0
    cd62:	e9 f7       	brne	.-6      	; 0xcd5e <GSM_Cycle+0xc96>
    cd64:	8f 01       	movw	r16, r30
    cd66:	01 50       	subi	r16, 0x01	; 1
    cd68:	10 40       	sbci	r17, 0x00	; 0
    cd6a:	0c 5f       	subi	r16, 0xFC	; 252
    cd6c:	19 40       	sbci	r17, 0x09	; 9
    cd6e:	00 93 6f 07 	sts	0x076F, r16
					GSM_SendFirstChar();
    cd72:	2d b7       	in	r18, 0x3d	; 61
    cd74:	3e b7       	in	r19, 0x3e	; 62
    cd76:	22 5f       	subi	r18, 0xF2	; 242
    cd78:	3f 4f       	sbci	r19, 0xFF	; 255
    cd7a:	0f b6       	in	r0, 0x3f	; 63
    cd7c:	f8 94       	cli
    cd7e:	3e bf       	out	0x3e, r19	; 62
    cd80:	0f be       	out	0x3f, r0	; 63
    cd82:	2d bf       	out	0x3d, r18	; 61
    cd84:	0e 94 fd 38 	call	0x71fa	; 0x71fa <GSM_SendFirstChar>
					StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    cd88:	80 91 e1 04 	lds	r24, 0x04E1
    cd8c:	64 ef       	ldi	r22, 0xF4	; 244
    cd8e:	71 e0       	ldi	r23, 0x01	; 1
    cd90:	0e 94 1d 1a 	call	0x343a	; 0x343a <StartTimer16>
					GSM_State++;
    cd94:	80 91 ad 06 	lds	r24, 0x06AD
    cd98:	8f 5f       	subi	r24, 0xFF	; 255
    cd9a:	80 93 ad 06 	sts	0x06AD, r24
    cd9e:	b4 c9       	rjmp	.-3224   	; 0xc108 <GSM_Cycle+0x40>
			break;
		case GSM_WAIT_SMS_Inv:
			if(GSM_Wait_Char('>', GSM_ReStart1)) GSM_State++;
			break;
		case GSM_SEND_SMS_DATA:
			SMS_Data_Out[SMS_FlgSz_Out] = 0x1A;	// SMS Data end - char Ctrl-Z
    cda0:	60 91 7c 07 	lds	r22, 0x077C
    cda4:	e6 2f       	mov	r30, r22
    cda6:	f0 e0       	ldi	r31, 0x00	; 0
    cda8:	e0 50       	subi	r30, 0x00	; 0
    cdaa:	f9 4f       	sbci	r31, 0xF9	; 249
    cdac:	8a e1       	ldi	r24, 0x1A	; 26
    cdae:	80 83       	st	Z, r24
			GSM_SendData((uint8_t *)SMS_Data_Out, SMS_FlgSz_Out+1);
    cdb0:	6f 5f       	subi	r22, 0xFF	; 255
    cdb2:	80 e0       	ldi	r24, 0x00	; 0
    cdb4:	97 e0       	ldi	r25, 0x07	; 7
    cdb6:	0e 94 89 3f 	call	0x7f12	; 0x7f12 <GSM_SendData>
			GSM_State++;
    cdba:	80 91 ad 06 	lds	r24, 0x06AD
    cdbe:	8f 5f       	subi	r24, 0xFF	; 255
    cdc0:	80 93 ad 06 	sts	0x06AD, r24
    cdc4:	a1 c9       	rjmp	.-3262   	; 0xc108 <GSM_Cycle+0x40>
					}					
				}
			}
			break;
		case GSM_WAIT_SMS_Inv:
			if(GSM_Wait_Char('>', GSM_ReStart1)) GSM_State++;
    cdc6:	8e e3       	ldi	r24, 0x3E	; 62
    cdc8:	68 e4       	ldi	r22, 0x48	; 72
    cdca:	0e 94 db 38 	call	0x71b6	; 0x71b6 <GSM_Wait_Char>
    cdce:	88 23       	and	r24, r24
    cdd0:	09 f4       	brne	.+2      	; 0xcdd4 <GSM_Cycle+0xd0c>
    cdd2:	9a c9       	rjmp	.-3276   	; 0xc108 <GSM_Cycle+0x40>
    cdd4:	80 91 ad 06 	lds	r24, 0x06AD
    cdd8:	8f 5f       	subi	r24, 0xFF	; 255
    cdda:	80 93 ad 06 	sts	0x06AD, r24
    cdde:	94 c9       	rjmp	.-3288   	; 0xc108 <GSM_Cycle+0x40>
			SMS_Data_Out[SMS_FlgSz_Out] = 0x1A;	// SMS Data end - char Ctrl-Z
			GSM_SendData((uint8_t *)SMS_Data_Out, SMS_FlgSz_Out+1);
			GSM_State++;
			break;		
		case GSM_WAIT_CMGS_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    cde0:	8d ee       	ldi	r24, 0xED	; 237
    cde2:	93 e0       	ldi	r25, 0x03	; 3
    cde4:	68 e4       	ldi	r22, 0x48	; 72
    cde6:	0e 94 ab 49 	call	0x9356	; 0x9356 <GSM_Wait_Response_P>
    cdea:	88 23       	and	r24, r24
    cdec:	09 f4       	brne	.+2      	; 0xcdf0 <GSM_Cycle+0xd28>
    cdee:	8c c9       	rjmp	.-3304   	; 0xc108 <GSM_Cycle+0x40>
				if(++TempNum>=MaxTelephDirSz){
    cdf0:	80 91 d4 05 	lds	r24, 0x05D4
    cdf4:	8f 5f       	subi	r24, 0xFF	; 255
    cdf6:	80 93 d4 05 	sts	0x05D4, r24
    cdfa:	83 30       	cpi	r24, 0x03	; 3
    cdfc:	08 f4       	brcc	.+2      	; 0xce00 <GSM_Cycle+0xd38>
    cdfe:	c4 c2       	rjmp	.+1416   	; 0xd388 <GSM_Cycle+0x12c0>
					GSM_State = GSM_Return2dataMode;
    ce00:	85 e5       	ldi	r24, 0x55	; 85
    ce02:	80 93 ad 06 	sts	0x06AD, r24
					SMS_FlgSz_Out = 0;
    ce06:	10 92 7c 07 	sts	0x077C, r1
    ce0a:	7e c9       	rjmp	.-3332   	; 0xc108 <GSM_Cycle+0x40>
				counter=1;

			}
			#endif	

			if(GetStringFromFIFO()){
    ce0c:	0e 94 d3 37 	call	0x6fa6	; 0x6fa6 <GetStringFromFIFO>
    ce10:	88 23       	and	r24, r24
    ce12:	09 f4       	brne	.+2      	; 0xce16 <GSM_Cycle+0xd4e>
    ce14:	79 c9       	rjmp	.-3342   	; 0xc108 <GSM_Cycle+0x40>
				GSM_State = GSM_AnalyzeURC;
    ce16:	8d e3       	ldi	r24, 0x3D	; 61
    ce18:	80 93 ad 06 	sts	0x06AD, r24
				TempNum = 0;
    ce1c:	10 92 d4 05 	sts	0x05D4, r1
    ce20:	73 c9       	rjmp	.-3354   	; 0xc108 <GSM_Cycle+0x40>

		case GSM_WAIT_CIPSTART_TCP_CLIENT_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;
		case GSM_WAIT_CIPSTART_TCP_CLIENT_CONNECT:
			if(GSM_Wait_Response_P(RESP_CONNECT, GSM_ReStart1)){
    ce22:	80 ef       	ldi	r24, 0xF0	; 240
    ce24:	93 e0       	ldi	r25, 0x03	; 3
    ce26:	68 e4       	ldi	r22, 0x48	; 72
    ce28:	0e 94 ab 49 	call	0x9356	; 0x9356 <GSM_Wait_Response_P>
    ce2c:	88 23       	and	r24, r24
    ce2e:	09 f4       	brne	.+2      	; 0xce32 <GSM_Cycle+0xd6a>
    ce30:	6b c9       	rjmp	.-3370   	; 0xc108 <GSM_Cycle+0x40>
				 GSM_State = GSM_WAIT_IDENTIFICATION;
    ce32:	8c e3       	ldi	r24, 0x3C	; 60
    ce34:	80 93 ad 06 	sts	0x06AD, r24
				 StartTimer16(TD_GSM, 1000*GSM_DEBUG_DELAY);
    ce38:	80 91 e1 04 	lds	r24, 0x04E1
    ce3c:	68 ee       	ldi	r22, 0xE8	; 232
    ce3e:	73 e0       	ldi	r23, 0x03	; 3
    ce40:	0e 94 1d 1a 	call	0x343a	; 0x343a <StartTimer16>
    ce44:	61 c9       	rjmp	.-3390   	; 0xc108 <GSM_Cycle+0x40>
			StartTimer16(TD_GSM,200);
			GSM_PWRCNTRL_ON();
			GSM_State++;
			break;
		case GSM_CFG_SEND_AT:
			if(Timer16Stopp(TD_GSM)) GSM_Execute_Command(AT_AT, 100); GSM_State++;
    ce46:	80 91 e1 04 	lds	r24, 0x04E1
    ce4a:	0e 94 59 1b 	call	0x36b2	; 0x36b2 <Timer16Stopp>
    ce4e:	88 23       	and	r24, r24
    ce50:	31 f0       	breq	.+12     	; 0xce5e <GSM_Cycle+0xd96>
    ce52:	80 e6       	ldi	r24, 0x60	; 96
    ce54:	94 e0       	ldi	r25, 0x04	; 4
    ce56:	64 e6       	ldi	r22, 0x64	; 100
    ce58:	70 e0       	ldi	r23, 0x00	; 0
    ce5a:	0e 94 06 4a 	call	0x940c	; 0x940c <GSM_Execute_Command>
    ce5e:	80 91 ad 06 	lds	r24, 0x06AD
    ce62:	8f 5f       	subi	r24, 0xFF	; 255
    ce64:	80 93 ad 06 	sts	0x06AD, r24
    ce68:	4f c9       	rjmp	.-3426   	; 0xc108 <GSM_Cycle+0x40>
				StartTimer16(TD_GSM,200);
				GSM_State++;
			}
			break;
		case GSM_SAVE_IPR:
			if(Timer16Stopp(TD_GSM)) GSM_State++;
    ce6a:	80 91 e1 04 	lds	r24, 0x04E1
    ce6e:	0e 94 59 1b 	call	0x36b2	; 0x36b2 <Timer16Stopp>
    ce72:	88 23       	and	r24, r24
    ce74:	09 f4       	brne	.+2      	; 0xce78 <GSM_Cycle+0xdb0>
    ce76:	48 c9       	rjmp	.-3440   	; 0xc108 <GSM_Cycle+0x40>
    ce78:	80 91 ad 06 	lds	r24, 0x06AD
    ce7c:	8f 5f       	subi	r24, 0xFF	; 255
    ce7e:	80 93 ad 06 	sts	0x06AD, r24
    ce82:	42 c9       	rjmp	.-3452   	; 0xc108 <GSM_Cycle+0x40>
			break;
		case GSM_CFG_SEND_IPR:
			GSM_Execute_Command(AT_IPR9600, 100); GSM_State++;
			break;
		case GSM_CFG_WAIT_IPR_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_CFG_SEND_AT)){
    ce84:	8d ee       	ldi	r24, 0xED	; 237
    ce86:	93 e0       	ldi	r25, 0x03	; 3
    ce88:	61 e0       	ldi	r22, 0x01	; 1
    ce8a:	0e 94 ab 49 	call	0x9356	; 0x9356 <GSM_Wait_Response_P>
    ce8e:	88 23       	and	r24, r24
    ce90:	09 f4       	brne	.+2      	; 0xce94 <GSM_Cycle+0xdcc>
    ce92:	3a c9       	rjmp	.-3468   	; 0xc108 <GSM_Cycle+0x40>
				StartTimer16(TD_GSM,200);
    ce94:	80 91 e1 04 	lds	r24, 0x04E1
    ce98:	68 ec       	ldi	r22, 0xC8	; 200
    ce9a:	70 e0       	ldi	r23, 0x00	; 0
    ce9c:	0e 94 1d 1a 	call	0x343a	; 0x343a <StartTimer16>
				GSM_State++;
    cea0:	80 91 ad 06 	lds	r24, 0x06AD
    cea4:	8f 5f       	subi	r24, 0xFF	; 255
    cea6:	80 93 ad 06 	sts	0x06AD, r24
    ceaa:	2e c9       	rjmp	.-3492   	; 0xc108 <GSM_Cycle+0x40>
			break;
		case GSM_CFG_SEND_ATW:
			GSM_Execute_Command(AT_W, 100); GSM_State++;
			break;
		case GSM_CFG_WAIT_ATW_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_CFG_SEND_AT)){
    ceac:	8d ee       	ldi	r24, 0xED	; 237
    ceae:	93 e0       	ldi	r25, 0x03	; 3
    ceb0:	61 e0       	ldi	r22, 0x01	; 1
    ceb2:	0e 94 ab 49 	call	0x9356	; 0x9356 <GSM_Wait_Response_P>
    ceb6:	88 23       	and	r24, r24
    ceb8:	09 f4       	brne	.+2      	; 0xcebc <GSM_Cycle+0xdf4>
    ceba:	26 c9       	rjmp	.-3508   	; 0xc108 <GSM_Cycle+0x40>
				StartTimer16(TD_GSM,200);
    cebc:	80 91 e1 04 	lds	r24, 0x04E1
    cec0:	68 ec       	ldi	r22, 0xC8	; 200
    cec2:	70 e0       	ldi	r23, 0x00	; 0
    cec4:	0e 94 1d 1a 	call	0x343a	; 0x343a <StartTimer16>
				GSM_State++;
    cec8:	80 91 ad 06 	lds	r24, 0x06AD
    cecc:	8f 5f       	subi	r24, 0xFF	; 255
    cece:	80 93 ad 06 	sts	0x06AD, r24
    ced2:	1a c9       	rjmp	.-3532   	; 0xc108 <GSM_Cycle+0x40>
			break;
		case GSM_CFG_SEND_AT:
			if(Timer16Stopp(TD_GSM)) GSM_Execute_Command(AT_AT, 100); GSM_State++;
			break;
		case GSM_CFG_WAIT_AT_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_CFG_SEND_AT)) GSM_State++;
    ced4:	8d ee       	ldi	r24, 0xED	; 237
    ced6:	93 e0       	ldi	r25, 0x03	; 3
    ced8:	61 e0       	ldi	r22, 0x01	; 1
    ceda:	0e 94 ab 49 	call	0x9356	; 0x9356 <GSM_Wait_Response_P>
    cede:	88 23       	and	r24, r24
    cee0:	09 f4       	brne	.+2      	; 0xcee4 <GSM_Cycle+0xe1c>
    cee2:	12 c9       	rjmp	.-3548   	; 0xc108 <GSM_Cycle+0x40>
    cee4:	80 91 ad 06 	lds	r24, 0x06AD
    cee8:	8f 5f       	subi	r24, 0xFF	; 255
    ceea:	80 93 ad 06 	sts	0x06AD, r24
    ceee:	0c c9       	rjmp	.-3560   	; 0xc108 <GSM_Cycle+0x40>
			if(GSM_Wait_Response_P(RESP_OK,GSM_SEND_CSQ)) GSM_State++;
			break;
		case GSM_WAIT_Ballance:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_SEND_CSQ;
			GSM_RxStr[GSM_RXSTR_SIZE-1]='\0';
			while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    cef0:	00 e0       	ldi	r16, 0x00	; 0
    cef2:	32 e0       	ldi	r19, 0x02	; 2
    cef4:	c3 2e       	mov	r12, r19
    cef6:	d1 2c       	mov	r13, r1
    cef8:	cc 0e       	add	r12, r28
    cefa:	dd 1e       	adc	r13, r29
    cefc:	09 c0       	rjmp	.+18     	; 0xcf10 <GSM_Cycle+0xe48>
				}

			}//while
			char buf[20];
			uint8_t i=0;
			while( (erb(&GPRS_currency[i])!='\0') && ((erb(&GPRS_currency[i])!=' ')||i==0) ){
    cefe:	80 32       	cpi	r24, 0x20	; 32
    cf00:	11 f4       	brne	.+4      	; 0xcf06 <GSM_Cycle+0xe3e>
    cf02:	00 23       	and	r16, r16
    cf04:	71 f4       	brne	.+28     	; 0xcf22 <GSM_Cycle+0xe5a>
				buf[i] = (char)erb(&GPRS_currency[i]);
    cf06:	ec 0c       	add	r14, r12
    cf08:	fd 1c       	adc	r15, r13
    cf0a:	f7 01       	movw	r30, r14
    cf0c:	80 83       	st	Z, r24
				i++;
    cf0e:	0f 5f       	subi	r16, 0xFF	; 255
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    cf10:	e0 2e       	mov	r14, r16
    cf12:	ff 24       	eor	r15, r15
    cf14:	c7 01       	movw	r24, r14
    cf16:	8b 5b       	subi	r24, 0xBB	; 187
    cf18:	9f 4f       	sbci	r25, 0xFF	; 255
    cf1a:	0e 94 a4 7d 	call	0xfb48	; 0xfb48 <__eerd_byte_m2560>
				}

			}//while
			char buf[20];
			uint8_t i=0;
			while( (erb(&GPRS_currency[i])!='\0') && ((erb(&GPRS_currency[i])!=' ')||i==0) ){
    cf1e:	88 23       	and	r24, r24
    cf20:	71 f7       	brne	.-36     	; 0xcefe <GSM_Cycle+0xe36>
				buf[i] = (char)erb(&GPRS_currency[i]);
				i++;
			}
			buf[i]='\0';
    cf22:	ec 0c       	add	r14, r12
    cf24:	fd 1c       	adc	r15, r13
    cf26:	d7 01       	movw	r26, r14
    cf28:	1c 92       	st	X, r1
			char *istr=strstr(GSM_RxStr, buf);
    cf2a:	83 e9       	ldi	r24, 0x93	; 147
    cf2c:	97 e0       	ldi	r25, 0x07	; 7
    cf2e:	b6 01       	movw	r22, r12
    cf30:	0e 94 ee 7a 	call	0xf5dc	; 0xf5dc <strstr>
			if(istr)
    cf34:	00 97       	sbiw	r24, 0x00	; 0
    cf36:	09 f4       	brne	.+2      	; 0xcf3a <GSM_Cycle+0xe72>
    cf38:	e7 c8       	rjmp	.-3634   	; 0xc108 <GSM_Cycle+0x40>
			{
					Ballance=*(istr-1)-0x30;
    cf3a:	fc 01       	movw	r30, r24
    cf3c:	82 91       	ld	r24, -Z
    cf3e:	90 e0       	ldi	r25, 0x00	; 0
    cf40:	c0 97       	sbiw	r24, 0x30	; 48
    cf42:	aa 27       	eor	r26, r26
    cf44:	97 fd       	sbrc	r25, 7
    cf46:	a0 95       	com	r26
    cf48:	ba 2f       	mov	r27, r26
    cf4a:	80 93 b2 06 	sts	0x06B2, r24
    cf4e:	90 93 b3 06 	sts	0x06B3, r25
    cf52:	a0 93 b4 06 	sts	0x06B4, r26
    cf56:	b0 93 b5 06 	sts	0x06B5, r27
					Ballance+=(*(istr-2)-0x30)*10;
    cf5a:	22 91       	ld	r18, -Z
    cf5c:	8f 01       	movw	r16, r30
    cf5e:	4a e0       	ldi	r20, 0x0A	; 10
    cf60:	24 9f       	mul	r18, r20
    cf62:	90 01       	movw	r18, r0
    cf64:	11 24       	eor	r1, r1
    cf66:	20 5e       	subi	r18, 0xE0	; 224
    cf68:	31 40       	sbci	r19, 0x01	; 1
    cf6a:	49 01       	movw	r8, r18
    cf6c:	aa 24       	eor	r10, r10
    cf6e:	97 fc       	sbrc	r9, 7
    cf70:	a0 94       	com	r10
    cf72:	ba 2c       	mov	r11, r10
    cf74:	88 0e       	add	r8, r24
    cf76:	99 1e       	adc	r9, r25
    cf78:	aa 1e       	adc	r10, r26
    cf7a:	bb 1e       	adc	r11, r27
    cf7c:	80 92 b2 06 	sts	0x06B2, r8
    cf80:	90 92 b3 06 	sts	0x06B3, r9
    cf84:	a0 92 b4 06 	sts	0x06B4, r10
    cf88:	b0 92 b5 06 	sts	0x06B5, r11
					uint8_t charnum=4;
					uint32_t razr=100;
					while((*(istr-charnum)>=0x30)&&(*(istr-charnum)<=0x39)){
    cf8c:	02 50       	subi	r16, 0x02	; 2
    cf8e:	10 40       	sbci	r17, 0x00	; 0
    cf90:	d8 01       	movw	r26, r16
    cf92:	6c 91       	ld	r22, X
    cf94:	0c 5f       	subi	r16, 0xFC	; 252
    cf96:	1f 4f       	sbci	r17, 0xFF	; 255
    cf98:	86 2f       	mov	r24, r22
    cf9a:	80 53       	subi	r24, 0x30	; 48
    cf9c:	8a 30       	cpi	r24, 0x0A	; 10
    cf9e:	88 f5       	brcc	.+98     	; 0xd002 <GSM_Cycle+0xf3a>
    cfa0:	24 e0       	ldi	r18, 0x04	; 4
    cfa2:	72 2e       	mov	r7, r18
    cfa4:	94 e6       	ldi	r25, 0x64	; 100
    cfa6:	c9 2e       	mov	r12, r25
    cfa8:	d1 2c       	mov	r13, r1
    cfaa:	e1 2c       	mov	r14, r1
    cfac:	f1 2c       	mov	r15, r1
						Ballance+=(*(istr-charnum)-0x30)*razr;
    cfae:	70 e0       	ldi	r23, 0x00	; 0
    cfb0:	60 53       	subi	r22, 0x30	; 48
    cfb2:	70 40       	sbci	r23, 0x00	; 0
    cfb4:	88 27       	eor	r24, r24
    cfb6:	77 fd       	sbrc	r23, 7
    cfb8:	80 95       	com	r24
    cfba:	98 2f       	mov	r25, r24
    cfbc:	a7 01       	movw	r20, r14
    cfbe:	96 01       	movw	r18, r12
    cfc0:	0e 94 e0 7d 	call	0xfbc0	; 0xfbc0 <__mulsi3>
    cfc4:	86 0e       	add	r8, r22
    cfc6:	97 1e       	adc	r9, r23
    cfc8:	a8 1e       	adc	r10, r24
    cfca:	b9 1e       	adc	r11, r25
    cfcc:	80 92 b2 06 	sts	0x06B2, r8
    cfd0:	90 92 b3 06 	sts	0x06B3, r9
    cfd4:	a0 92 b4 06 	sts	0x06B4, r10
    cfd8:	b0 92 b5 06 	sts	0x06B5, r11
						razr*=10;
    cfdc:	c7 01       	movw	r24, r14
    cfde:	b6 01       	movw	r22, r12
    cfe0:	2a e0       	ldi	r18, 0x0A	; 10
    cfe2:	30 e0       	ldi	r19, 0x00	; 0
    cfe4:	40 e0       	ldi	r20, 0x00	; 0
    cfe6:	50 e0       	ldi	r21, 0x00	; 0
    cfe8:	0e 94 e0 7d 	call	0xfbc0	; 0xfbc0 <__mulsi3>
    cfec:	6b 01       	movw	r12, r22
    cfee:	7c 01       	movw	r14, r24
						charnum++;	
    cff0:	73 94       	inc	r7
			{
					Ballance=*(istr-1)-0x30;
					Ballance+=(*(istr-2)-0x30)*10;
					uint8_t charnum=4;
					uint32_t razr=100;
					while((*(istr-charnum)>=0x30)&&(*(istr-charnum)<=0x39)){
    cff2:	f8 01       	movw	r30, r16
    cff4:	e7 19       	sub	r30, r7
    cff6:	f1 09       	sbc	r31, r1
    cff8:	60 81       	ld	r22, Z
    cffa:	86 2f       	mov	r24, r22
    cffc:	80 53       	subi	r24, 0x30	; 48
    cffe:	8a 30       	cpi	r24, 0x0A	; 10
    d000:	b0 f2       	brcs	.-84     	; 0xcfae <GSM_Cycle+0xee6>
						Ballance+=(*(istr-charnum)-0x30)*razr;
						razr*=10;
						charnum++;	
					}
					if(*(istr-charnum)==0x2D)
    d002:	6d 32       	cpi	r22, 0x2D	; 45
    d004:	09 f0       	breq	.+2      	; 0xd008 <GSM_Cycle+0xf40>
    d006:	80 c8       	rjmp	.-3840   	; 0xc108 <GSM_Cycle+0x40>
					{
						Ballance*=-1;
    d008:	80 91 b2 06 	lds	r24, 0x06B2
    d00c:	90 91 b3 06 	lds	r25, 0x06B3
    d010:	a0 91 b4 06 	lds	r26, 0x06B4
    d014:	b0 91 b5 06 	lds	r27, 0x06B5
    d018:	b0 95       	com	r27
    d01a:	a0 95       	com	r26
    d01c:	90 95       	com	r25
    d01e:	81 95       	neg	r24
    d020:	9f 4f       	sbci	r25, 0xFF	; 255
    d022:	af 4f       	sbci	r26, 0xFF	; 255
    d024:	bf 4f       	sbci	r27, 0xFF	; 255
    d026:	80 93 b2 06 	sts	0x06B2, r24
    d02a:	90 93 b3 06 	sts	0x06B3, r25
    d02e:	a0 93 b4 06 	sts	0x06B4, r26
    d032:	b0 93 b5 06 	sts	0x06B5, r27
    d036:	68 c8       	rjmp	.-3888   	; 0xc108 <GSM_Cycle+0x40>
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
			if(GetStringFromFIFO()){
				SetIP(&GSM_MyIP,0,0,0,0);
				for(uint8_t i=0; i<strlen(GSM_RxStr); i++)
					if(!isdigit(GSM_RxStr[i])) GSM_RxStr[i] = ' ';
				sscanf_P(GSM_RxStr,PSTR("%hhu %hhu %hhu %hhu"), (unsigned char*)&GSM_MyIP.IP1, (unsigned char*)&GSM_MyIP.IP2, (unsigned char*)&GSM_MyIP.IP3, (unsigned char*)&GSM_MyIP.IP4);
    d038:	ed b7       	in	r30, 0x3d	; 61
    d03a:	fe b7       	in	r31, 0x3e	; 62
    d03c:	3c 97       	sbiw	r30, 0x0c	; 12
    d03e:	0f b6       	in	r0, 0x3f	; 63
    d040:	f8 94       	cli
    d042:	fe bf       	out	0x3e, r31	; 62
    d044:	0f be       	out	0x3f, r0	; 63
    d046:	ed bf       	out	0x3d, r30	; 61
    d048:	31 96       	adiw	r30, 0x01	; 1
    d04a:	83 e9       	ldi	r24, 0x93	; 147
    d04c:	97 e0       	ldi	r25, 0x07	; 7
    d04e:	ad b7       	in	r26, 0x3d	; 61
    d050:	be b7       	in	r27, 0x3e	; 62
    d052:	12 96       	adiw	r26, 0x02	; 2
    d054:	9c 93       	st	X, r25
    d056:	8e 93       	st	-X, r24
    d058:	11 97       	sbiw	r26, 0x01	; 1
    d05a:	8d ef       	ldi	r24, 0xFD	; 253
    d05c:	9b e2       	ldi	r25, 0x2B	; 43
    d05e:	93 83       	std	Z+3, r25	; 0x03
    d060:	82 83       	std	Z+2, r24	; 0x02
    d062:	55 83       	std	Z+5, r21	; 0x05
    d064:	44 83       	std	Z+4, r20	; 0x04
    d066:	77 83       	std	Z+7, r23	; 0x07
    d068:	66 83       	std	Z+6, r22	; 0x06
    d06a:	11 87       	std	Z+9, r17	; 0x09
    d06c:	00 87       	std	Z+8, r16	; 0x08
    d06e:	f3 86       	std	Z+11, r15	; 0x0b
    d070:	e2 86       	std	Z+10, r14	; 0x0a
    d072:	0e 94 fb 7b 	call	0xf7f6	; 0xf7f6 <sscanf_P>
}
uint8_t IP_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	if((IP->IP1 == IP1) && (IP->IP2 == IP2) && (IP->IP3 == IP3) && (IP->IP4 == IP4)) return 1;
    d076:	ed b7       	in	r30, 0x3d	; 61
    d078:	fe b7       	in	r31, 0x3e	; 62
    d07a:	3c 96       	adiw	r30, 0x0c	; 12
    d07c:	0f b6       	in	r0, 0x3f	; 63
    d07e:	f8 94       	cli
    d080:	fe bf       	out	0x3e, r31	; 62
    d082:	0f be       	out	0x3f, r0	; 63
    d084:	ed bf       	out	0x3d, r30	; 61
    d086:	80 91 e3 08 	lds	r24, 0x08E3
    d08a:	88 23       	and	r24, r24
    d08c:	e9 f4       	brne	.+58     	; 0xd0c8 <GSM_Cycle+0x1000>
    d08e:	80 91 e4 08 	lds	r24, 0x08E4
    d092:	88 23       	and	r24, r24
    d094:	c9 f4       	brne	.+50     	; 0xd0c8 <GSM_Cycle+0x1000>
    d096:	80 91 e5 08 	lds	r24, 0x08E5
    d09a:	88 23       	and	r24, r24
    d09c:	a9 f4       	brne	.+42     	; 0xd0c8 <GSM_Cycle+0x1000>
    d09e:	80 91 e6 08 	lds	r24, 0x08E6
    d0a2:	88 23       	and	r24, r24
    d0a4:	89 f4       	brne	.+34     	; 0xd0c8 <GSM_Cycle+0x1000>
				if(!IP_compare_Const(&GSM_MyIP,0,0,0,0)){
				  GSM_State = GSM_SEND_CIPSTART_TCP_CLIENT;
				}
				TempNum=0;	//
    d0a6:	10 92 d4 05 	sts	0x05D4, r1
    d0aa:	2e c8       	rjmp	.-4004   	; 0xc108 <GSM_Cycle+0x40>
				else GSM_State++;
			}
			break;
		case GSM_SEND_CIPMODE:
			if(GSM_MultiCon) GSM_Execute_Command(AT_CIPMODE_0, 100*GSM_DEBUG_DELAY);
			else GSM_Execute_Command(AT_CIPMODE_1, 100*GSM_DEBUG_DELAY);
    d0ac:	8b ef       	ldi	r24, 0xFB	; 251
    d0ae:	94 e0       	ldi	r25, 0x04	; 4
    d0b0:	64 e6       	ldi	r22, 0x64	; 100
    d0b2:	70 e0       	ldi	r23, 0x00	; 0
    d0b4:	0e 94 06 4a 	call	0x940c	; 0x940c <GSM_Execute_Command>
    d0b8:	4b ca       	rjmp	.-2922   	; 0xc550 <GSM_Cycle+0x488>
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State=GSM_SEND_ATD_Check_Ballance;
			break;
		//------------------------
		case GSM_SEND_CIPMUX:
			if(GSM_MultiCon) GSM_Execute_Command(AT_CIPMUX_1, 100*GSM_DEBUG_DELAY);
			else GSM_Execute_Command(AT_CIPMUX_0, 100*GSM_DEBUG_DELAY);
    d0ba:	88 e0       	ldi	r24, 0x08	; 8
    d0bc:	95 e0       	ldi	r25, 0x05	; 5
    d0be:	64 e6       	ldi	r22, 0x64	; 100
    d0c0:	70 e0       	ldi	r23, 0x00	; 0
    d0c2:	0e 94 06 4a 	call	0x940c	; 0x940c <GSM_Execute_Command>
    d0c6:	04 cb       	rjmp	.-2552   	; 0xc6d0 <GSM_Cycle+0x608>
				SetIP(&GSM_MyIP,0,0,0,0);
				for(uint8_t i=0; i<strlen(GSM_RxStr); i++)
					if(!isdigit(GSM_RxStr[i])) GSM_RxStr[i] = ' ';
				sscanf_P(GSM_RxStr,PSTR("%hhu %hhu %hhu %hhu"), (unsigned char*)&GSM_MyIP.IP1, (unsigned char*)&GSM_MyIP.IP2, (unsigned char*)&GSM_MyIP.IP3, (unsigned char*)&GSM_MyIP.IP4);
				if(!IP_compare_Const(&GSM_MyIP,0,0,0,0)){
				  GSM_State = GSM_SEND_CIPSTART_TCP_CLIENT;
    d0c8:	89 e3       	ldi	r24, 0x39	; 57
    d0ca:	80 93 ad 06 	sts	0x06AD, r24
    d0ce:	eb cf       	rjmp	.-42     	; 0xd0a6 <GSM_Cycle+0xfde>
					if(GSM_RxCharN==2)
						{
							if(!strncmp_P(GSM_RxStr, PSTR("\r\n"), 2)) {GSM_RxCharN=0;}
						}
					if(GSM_RxCharN >= 4){
						AppProtocol = 0;
    d0d0:	10 92 99 08 	sts	0x0899, r1
						if(!strncmp_P(GSM_RxStr, PSTR("GET "), 4)) {AppProtocol = _HTTP;GSM_State = GSM_DataMode;break;}//GET
    d0d4:	83 e9       	ldi	r24, 0x93	; 147
    d0d6:	97 e0       	ldi	r25, 0x07	; 7
    d0d8:	65 ed       	ldi	r22, 0xD5	; 213
    d0da:	7b e2       	ldi	r23, 0x2B	; 43
    d0dc:	44 e0       	ldi	r20, 0x04	; 4
    d0de:	50 e0       	ldi	r21, 0x00	; 0
    d0e0:	0e 94 93 7a 	call	0xf526	; 0xf526 <strncmp_P>
    d0e4:	89 2b       	or	r24, r25
    d0e6:	09 f4       	brne	.+2      	; 0xd0ea <GSM_Cycle+0x1022>
    d0e8:	80 c2       	rjmp	.+1280   	; 0xd5ea <GSM_Cycle+0x1522>
						if(!strncmp_P(GSM_RxStr, PSTR("POST"), 4)) {AppProtocol = _HTTP;GSM_State = GSM_DataMode;break;}//POST
    d0ea:	83 e9       	ldi	r24, 0x93	; 147
    d0ec:	97 e0       	ldi	r25, 0x07	; 7
    d0ee:	60 ed       	ldi	r22, 0xD0	; 208
    d0f0:	7b e2       	ldi	r23, 0x2B	; 43
    d0f2:	44 e0       	ldi	r20, 0x04	; 4
    d0f4:	50 e0       	ldi	r21, 0x00	; 0
    d0f6:	0e 94 93 7a 	call	0xf526	; 0xf526 <strncmp_P>
    d0fa:	89 2b       	or	r24, r25
    d0fc:	09 f4       	brne	.+2      	; 0xd100 <GSM_Cycle+0x1038>
    d0fe:	75 c2       	rjmp	.+1258   	; 0xd5ea <GSM_Cycle+0x1522>
						if(!strncmp_P(GSM_RxStr, PSTR("CLOS"), 4)) {AppProtocol = _HTTP;GSM_State = GSM_ReStart1;break;}// 
    d100:	83 e9       	ldi	r24, 0x93	; 147
    d102:	97 e0       	ldi	r25, 0x07	; 7
    d104:	6b ec       	ldi	r22, 0xCB	; 203
    d106:	7b e2       	ldi	r23, 0x2B	; 43
    d108:	44 e0       	ldi	r20, 0x04	; 4
    d10a:	50 e0       	ldi	r21, 0x00	; 0
    d10c:	0e 94 93 7a 	call	0xf526	; 0xf526 <strncmp_P>
    d110:	89 2b       	or	r24, r25
    d112:	09 f4       	brne	.+2      	; 0xd116 <GSM_Cycle+0x104e>
    d114:	71 c2       	rjmp	.+1250   	; 0xd5f8 <GSM_Cycle+0x1530>
						if(!strncmp_P(GSM_RxStr, PSTR("+PDP"), 4)) {AppProtocol = _HTTP;GSM_State = GSM_ReStart1;break;}//GPRS 
    d116:	83 e9       	ldi	r24, 0x93	; 147
    d118:	97 e0       	ldi	r25, 0x07	; 7
    d11a:	66 ec       	ldi	r22, 0xC6	; 198
    d11c:	7b e2       	ldi	r23, 0x2B	; 43
    d11e:	44 e0       	ldi	r20, 0x04	; 4
    d120:	50 e0       	ldi	r21, 0x00	; 0
    d122:	0e 94 93 7a 	call	0xf526	; 0xf526 <strncmp_P>
    d126:	89 2b       	or	r24, r25
    d128:	09 f4       	brne	.+2      	; 0xd12c <GSM_Cycle+0x1064>
    d12a:	66 c2       	rjmp	.+1228   	; 0xd5f8 <GSM_Cycle+0x1530>
						if( (GSM_RxStr[0]==0) && (GSM_RxStr[1]==0)){AppProtocol = _HTTP;GSM_State = GSM_ReStart1;break;}//  
    d12c:	80 91 93 07 	lds	r24, 0x0793
    d130:	88 23       	and	r24, r24
    d132:	29 f4       	brne	.+10     	; 0xd13e <GSM_Cycle+0x1076>
    d134:	80 91 94 07 	lds	r24, 0x0794
    d138:	88 23       	and	r24, r24
    d13a:	09 f4       	brne	.+2      	; 0xd13e <GSM_Cycle+0x1076>
    d13c:	5d c2       	rjmp	.+1210   	; 0xd5f8 <GSM_Cycle+0x1530>
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    d13e:	8f ef       	ldi	r24, 0xFF	; 255
    d140:	80 93 f4 06 	sts	0x06F4, r24
	GSM_RX_FIFO_End = 255;
    d144:	80 93 4b 06 	sts	0x064B, r24
	GSM_RxCharN = 0;
    d148:	10 92 12 0b 	sts	0x0B12, r1
	GSM_RX_FIFOOverFlow = 0;
    d14c:	10 92 c5 08 	sts	0x08C5, r1
	GSM_RX_FIFOMax = 0;
    d150:	10 92 cb 08 	sts	0x08CB, r1
						StartTimer16(TD_CleanFIFO,500);
						//break;
					}
				}//while
				//GSM_RxCharN=0;
				if(Timer16Stopp(TD_CleanFIFO)&&(GSM_RX_FIFO_Begin == GSM_RX_FIFO_End)){
    d154:	80 91 e7 04 	lds	r24, 0x04E7
    d158:	0e 94 59 1b 	call	0x36b2	; 0x36b2 <Timer16Stopp>
    d15c:	88 23       	and	r24, r24
    d15e:	39 f0       	breq	.+14     	; 0xd16e <GSM_Cycle+0x10a6>
    d160:	90 91 f4 06 	lds	r25, 0x06F4
    d164:	80 91 4b 06 	lds	r24, 0x064B
    d168:	98 17       	cp	r25, r24
    d16a:	09 f4       	brne	.+2      	; 0xd16e <GSM_Cycle+0x10a6>
    d16c:	c9 c1       	rjmp	.+914    	; 0xd500 <GSM_Cycle+0x1438>
					StartTimer16(TD_CleanFIFO,500);
					InitFIFO();
				}

				if(Timer16Stopp(TD_data_start_delay)){
    d16e:	80 91 e8 04 	lds	r24, 0x04E8
    d172:	0e 94 59 1b 	call	0x36b2	; 0x36b2 <Timer16Stopp>
    d176:	88 23       	and	r24, r24
    d178:	11 f4       	brne	.+4      	; 0xd17e <GSM_Cycle+0x10b6>
    d17a:	0c 94 84 60 	jmp	0xc108	; 0xc108 <GSM_Cycle+0x40>
					if(GPRS_FlgSz_Out && (GPRS_FlgSz_Out <= GPRS_Out_MaxSz)&&(GSM_Flag&(1<<flg_TxCStr))&&Timer16Stopp(TD_timer_after_page_transfer)&&(!dataSendFlg)){			
    d17e:	80 91 67 07 	lds	r24, 0x0767
    d182:	88 23       	and	r24, r24
    d184:	11 f4       	brne	.+4      	; 0xd18a <GSM_Cycle+0x10c2>
    d186:	0c 94 84 60 	jmp	0xc108	; 0xc108 <GSM_Cycle+0x40>
    d18a:	80 91 cf 02 	lds	r24, 0x02CF
    d18e:	80 fd       	sbrc	r24, 0
    d190:	02 c0       	rjmp	.+4      	; 0xd196 <GSM_Cycle+0x10ce>
    d192:	0c 94 84 60 	jmp	0xc108	; 0xc108 <GSM_Cycle+0x40>
    d196:	80 91 e9 04 	lds	r24, 0x04E9
    d19a:	0e 94 59 1b 	call	0x36b2	; 0x36b2 <Timer16Stopp>
    d19e:	88 23       	and	r24, r24
    d1a0:	11 f4       	brne	.+4      	; 0xd1a6 <GSM_Cycle+0x10de>
    d1a2:	0c 94 84 60 	jmp	0xc108	; 0xc108 <GSM_Cycle+0x40>
    d1a6:	80 91 db 02 	lds	r24, 0x02DB
    d1aa:	88 23       	and	r24, r24
    d1ac:	11 f0       	breq	.+4      	; 0xd1b2 <GSM_Cycle+0x10ea>
    d1ae:	0c 94 84 60 	jmp	0xc108	; 0xc108 <GSM_Cycle+0x40>
							dataSendFlg=1;
    d1b2:	81 e0       	ldi	r24, 0x01	; 1
    d1b4:	80 93 db 02 	sts	0x02DB, r24
							GSM_AddHeaderSendData(GPRS_Data_Out, GPRS_FlgSz_Out);
    d1b8:	88 ef       	ldi	r24, 0xF8	; 248
    d1ba:	98 e0       	ldi	r25, 0x08	; 8
    d1bc:	60 91 67 07 	lds	r22, 0x0767
    d1c0:	0e 94 99 3f 	call	0x7f32	; 0x7f32 <GSM_AddHeaderSendData>
    d1c4:	0c 94 84 60 	jmp	0xc108	; 0xc108 <GSM_Cycle+0x40>
		case GSM_WAIT_CSQ:
				if(Timer16Stopp(TD_GSM)){
						GSM_State = GSM_ReStart1;
				}
				else{				
					if(GetStringFromFIFO()){
    d1c8:	0e 94 d3 37 	call	0x6fa6	; 0x6fa6 <GetStringFromFIFO>
    d1cc:	88 23       	and	r24, r24
    d1ce:	11 f4       	brne	.+4      	; 0xd1d4 <GSM_Cycle+0x110c>
    d1d0:	0c 94 84 60 	jmp	0xc108	; 0xc108 <GSM_Cycle+0x40>
						GSM_RSSI = 255; GSM_BER = 255;
    d1d4:	8f ef       	ldi	r24, 0xFF	; 255
    d1d6:	80 93 aa 06 	sts	0x06AA, r24
    d1da:	80 93 7e 07 	sts	0x077E, r24
						if(strstr_P(GSM_RxStr, RESP_CSQ) != NULL ){
    d1de:	03 e9       	ldi	r16, 0x93	; 147
    d1e0:	17 e0       	ldi	r17, 0x07	; 7
    d1e2:	c8 01       	movw	r24, r16
    d1e4:	6f e3       	ldi	r22, 0x3F	; 63
    d1e6:	74 e0       	ldi	r23, 0x04	; 4
    d1e8:	0e 94 ac 7a 	call	0xf558	; 0xf558 <strstr_P>
    d1ec:	89 2b       	or	r24, r25
    d1ee:	11 f4       	brne	.+4      	; 0xd1f4 <GSM_Cycle+0x112c>
    d1f0:	0c 94 84 60 	jmp	0xc108	; 0xc108 <GSM_Cycle+0x40>
							sscanf_P(GSM_RxStr,PSTR("+CSQ: %hhu,%hhu"), (unsigned char*)&GSM_RSSI, (unsigned char*)&GSM_BER);
    d1f4:	ed b7       	in	r30, 0x3d	; 61
    d1f6:	fe b7       	in	r31, 0x3e	; 62
    d1f8:	38 97       	sbiw	r30, 0x08	; 8
    d1fa:	0f b6       	in	r0, 0x3f	; 63
    d1fc:	f8 94       	cli
    d1fe:	fe bf       	out	0x3e, r31	; 62
    d200:	0f be       	out	0x3f, r0	; 63
    d202:	ed bf       	out	0x3d, r30	; 61
    d204:	31 96       	adiw	r30, 0x01	; 1
    d206:	ad b7       	in	r26, 0x3d	; 61
    d208:	be b7       	in	r27, 0x3e	; 62
    d20a:	12 96       	adiw	r26, 0x02	; 2
    d20c:	1c 93       	st	X, r17
    d20e:	0e 93       	st	-X, r16
    d210:	11 97       	sbiw	r26, 0x01	; 1
    d212:	8d ed       	ldi	r24, 0xDD	; 221
    d214:	9b e2       	ldi	r25, 0x2B	; 43
    d216:	93 83       	std	Z+3, r25	; 0x03
    d218:	82 83       	std	Z+2, r24	; 0x02
    d21a:	8a ea       	ldi	r24, 0xAA	; 170
    d21c:	96 e0       	ldi	r25, 0x06	; 6
    d21e:	95 83       	std	Z+5, r25	; 0x05
    d220:	84 83       	std	Z+4, r24	; 0x04
    d222:	8e e7       	ldi	r24, 0x7E	; 126
    d224:	97 e0       	ldi	r25, 0x07	; 7
    d226:	97 83       	std	Z+7, r25	; 0x07
    d228:	86 83       	std	Z+6, r24	; 0x06
    d22a:	0e 94 fb 7b 	call	0xf7f6	; 0xf7f6 <sscanf_P>
									
								GSM_State = GSM_WAIT_CSQ_OK;
    d22e:	8f e4       	ldi	r24, 0x4F	; 79
    d230:	80 93 ad 06 	sts	0x06AD, r24
    d234:	ed b7       	in	r30, 0x3d	; 61
    d236:	fe b7       	in	r31, 0x3e	; 62
    d238:	38 96       	adiw	r30, 0x08	; 8
    d23a:	0f b6       	in	r0, 0x3f	; 63
    d23c:	f8 94       	cli
    d23e:	fe bf       	out	0x3e, r31	; 62
    d240:	0f be       	out	0x3f, r0	; 63
    d242:	ed bf       	out	0x3d, r30	; 61
    d244:	0c 94 84 60 	jmp	0xc108	; 0xc108 <GSM_Cycle+0x40>
			break;

		case GSM_SEND_CIPCSGP:
			//GSM_Execute_Command(AT_CIPCSGP, 300*GSM_DEBUG_DELAY); GSM_State++;
			if(GSM_Flag & (1<<flg_TxCStr)){
				sprintf_P(GSM_TxStr, AT_CIPCSGP);	GSMTxSz = strlen_P(AT_CIPCSGP);
    d248:	00 d0       	rcall	.+0      	; 0xd24a <GSM_Cycle+0x1182>
    d24a:	0f 92       	push	r0
    d24c:	8c ef       	ldi	r24, 0xFC	; 252
    d24e:	99 e0       	ldi	r25, 0x09	; 9
    d250:	ad b7       	in	r26, 0x3d	; 61
    d252:	be b7       	in	r27, 0x3e	; 62
    d254:	12 96       	adiw	r26, 0x02	; 2
    d256:	9c 93       	st	X, r25
    d258:	8e 93       	st	-X, r24
    d25a:	11 97       	sbiw	r26, 0x01	; 1
    d25c:	0b e2       	ldi	r16, 0x2B	; 43
    d25e:	15 e0       	ldi	r17, 0x05	; 5
    d260:	14 96       	adiw	r26, 0x04	; 4
    d262:	1c 93       	st	X, r17
    d264:	0e 93       	st	-X, r16
    d266:	13 97       	sbiw	r26, 0x03	; 3
    d268:	0e 94 a7 7b 	call	0xf74e	; 0xf74e <sprintf_P>
    d26c:	0f 90       	pop	r0
    d26e:	0f 90       	pop	r0
    d270:	0f 90       	pop	r0
    d272:	0f 90       	pop	r0
    d274:	c8 01       	movw	r24, r16
    d276:	0e 94 8a 7a 	call	0xf514	; 0xf514 <strlen_P>
    d27a:	80 93 6f 07 	sts	0x076F, r24
				#if LCDXSz==40
					GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn);
				#else
					GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn1);
    d27e:	80 91 6f 07 	lds	r24, 0x076F
    d282:	90 e0       	ldi	r25, 0x00	; 0
    d284:	84 50       	subi	r24, 0x04	; 4
    d286:	96 4f       	sbci	r25, 0xF6	; 246
    d288:	69 e0       	ldi	r22, 0x09	; 9
    d28a:	70 e0       	ldi	r23, 0x00	; 0
    d28c:	0e 94 41 60 	call	0xc082	; 0xc082 <strcpy_EE>
    d290:	90 91 6f 07 	lds	r25, 0x076F
    d294:	98 0f       	add	r25, r24
    d296:	90 93 6f 07 	sts	0x076F, r25
					GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn2);
    d29a:	80 91 6f 07 	lds	r24, 0x076F
    d29e:	90 e0       	ldi	r25, 0x00	; 0
    d2a0:	84 50       	subi	r24, 0x04	; 4
    d2a2:	96 4f       	sbci	r25, 0xF6	; 246
    d2a4:	6d e1       	ldi	r22, 0x1D	; 29
    d2a6:	70 e0       	ldi	r23, 0x00	; 0
    d2a8:	0e 94 41 60 	call	0xc082	; 0xc082 <strcpy_EE>
    d2ac:	90 91 6f 07 	lds	r25, 0x076F
    d2b0:	98 0f       	add	r25, r24
    d2b2:	90 93 6f 07 	sts	0x076F, r25
				#endif
				sprintf(GSM_TxStr + GSMTxSz, "\",\"");	GSMTxSz = GSMTxSz+3;				
    d2b6:	e0 91 6f 07 	lds	r30, 0x076F
    d2ba:	f0 e0       	ldi	r31, 0x00	; 0
    d2bc:	e4 50       	subi	r30, 0x04	; 4
    d2be:	f6 4f       	sbci	r31, 0xF6	; 246
    d2c0:	a2 e2       	ldi	r26, 0x22	; 34
    d2c2:	ea 2e       	mov	r14, r26
    d2c4:	ac e2       	ldi	r26, 0x2C	; 44
    d2c6:	fa 2e       	mov	r15, r26
    d2c8:	a2 e2       	ldi	r26, 0x22	; 34
    d2ca:	0a 2f       	mov	r16, r26
    d2cc:	11 2d       	mov	r17, r1
    d2ce:	e0 82       	st	Z, r14
    d2d0:	f1 82       	std	Z+1, r15	; 0x01
    d2d2:	02 83       	std	Z+2, r16	; 0x02
    d2d4:	13 83       	std	Z+3, r17	; 0x03
    d2d6:	80 91 6f 07 	lds	r24, 0x076F
    d2da:	8d 5f       	subi	r24, 0xFD	; 253
    d2dc:	80 93 6f 07 	sts	0x076F, r24
				GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn_user_name);
    d2e0:	80 91 6f 07 	lds	r24, 0x076F
    d2e4:	90 e0       	ldi	r25, 0x00	; 0
    d2e6:	84 50       	subi	r24, 0x04	; 4
    d2e8:	96 4f       	sbci	r25, 0xF6	; 246
    d2ea:	69 e5       	ldi	r22, 0x59	; 89
    d2ec:	70 e0       	ldi	r23, 0x00	; 0
    d2ee:	0e 94 41 60 	call	0xc082	; 0xc082 <strcpy_EE>
    d2f2:	90 91 6f 07 	lds	r25, 0x076F
    d2f6:	98 0f       	add	r25, r24
    d2f8:	90 93 6f 07 	sts	0x076F, r25
				sprintf(GSM_TxStr + GSMTxSz, "\",\"");	GSMTxSz = GSMTxSz+3;
    d2fc:	e0 91 6f 07 	lds	r30, 0x076F
    d300:	f0 e0       	ldi	r31, 0x00	; 0
    d302:	e4 50       	subi	r30, 0x04	; 4
    d304:	f6 4f       	sbci	r31, 0xF6	; 246
    d306:	e0 82       	st	Z, r14
    d308:	f1 82       	std	Z+1, r15	; 0x01
    d30a:	02 83       	std	Z+2, r16	; 0x02
    d30c:	13 83       	std	Z+3, r17	; 0x03
    d30e:	80 91 6f 07 	lds	r24, 0x076F
    d312:	8d 5f       	subi	r24, 0xFD	; 253
    d314:	80 93 6f 07 	sts	0x076F, r24
				GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn_psw);
    d318:	80 91 6f 07 	lds	r24, 0x076F
    d31c:	90 e0       	ldi	r25, 0x00	; 0
    d31e:	84 50       	subi	r24, 0x04	; 4
    d320:	96 4f       	sbci	r25, 0xF6	; 246
    d322:	6d e6       	ldi	r22, 0x6D	; 109
    d324:	70 e0       	ldi	r23, 0x00	; 0
    d326:	0e 94 41 60 	call	0xc082	; 0xc082 <strcpy_EE>
    d32a:	90 91 6f 07 	lds	r25, 0x076F
    d32e:	98 0f       	add	r25, r24
    d330:	90 93 6f 07 	sts	0x076F, r25
				sprintf(GSM_TxStr + GSMTxSz, "\"\r");	GSMTxSz = GSMTxSz+2;
    d334:	80 91 6f 07 	lds	r24, 0x076F
    d338:	e8 2f       	mov	r30, r24
    d33a:	f0 e0       	ldi	r31, 0x00	; 0
    d33c:	e4 50       	subi	r30, 0x04	; 4
    d33e:	f6 4f       	sbci	r31, 0xF6	; 246
    d340:	a2 eb       	ldi	r26, 0xB2	; 178
    d342:	b2 e0       	ldi	r27, 0x02	; 2
    d344:	83 e0       	ldi	r24, 0x03	; 3
    d346:	0d 90       	ld	r0, X+
    d348:	01 92       	st	Z+, r0
    d34a:	81 50       	subi	r24, 0x01	; 1
    d34c:	e1 f7       	brne	.-8      	; 0xd346 <GSM_Cycle+0x127e>
    d34e:	80 91 6f 07 	lds	r24, 0x076F
    d352:	8e 5f       	subi	r24, 0xFE	; 254
    d354:	80 93 6f 07 	sts	0x076F, r24
				GSM_SendFirstChar();
    d358:	0e 94 fd 38 	call	0x71fa	; 0x71fa <GSM_SendFirstChar>
				StartTimer16(TD_GSM, 300*GSM_DEBUG_DELAY);
    d35c:	80 91 e1 04 	lds	r24, 0x04E1
    d360:	6c e2       	ldi	r22, 0x2C	; 44
    d362:	71 e0       	ldi	r23, 0x01	; 1
    d364:	0e 94 1d 1a 	call	0x343a	; 0x343a <StartTimer16>
    d368:	11 c8       	rjmp	.-4062   	; 0xc38c <GSM_Cycle+0x2c4>
		/*	if(Timer16Stopp(TD_TCP_Connect)){	//        CommandMode
				GSM_State = GSM_Swtch2CommandMode;
				break;
			}*/
			//StartTimer16(TD_CheckModem,1000);
			if( (strstr_P(GSM_RxStr, URC_CLOSED+2) != NULL) ){
    d36a:	83 e9       	ldi	r24, 0x93	; 147
    d36c:	97 e0       	ldi	r25, 0x07	; 7
    d36e:	60 ed       	ldi	r22, 0xD0	; 208
    d370:	73 e0       	ldi	r23, 0x03	; 3
    d372:	0e 94 ac 7a 	call	0xf558	; 0xf558 <strstr_P>
    d376:	89 2b       	or	r24, r25
    d378:	11 f4       	brne	.+4      	; 0xd37e <GSM_Cycle+0x12b6>
    d37a:	0c 94 84 60 	jmp	0xc108	; 0xc108 <GSM_Cycle+0x40>
				GSM_State =GSM_ReStart1;
    d37e:	88 e4       	ldi	r24, 0x48	; 72
    d380:	80 93 ad 06 	sts	0x06AD, r24
    d384:	0c 94 84 60 	jmp	0xc108	; 0xc108 <GSM_Cycle+0x40>
				if(++TempNum>=MaxTelephDirSz){
					GSM_State = GSM_Return2dataMode;
					SMS_FlgSz_Out = 0;
					//StartTimer16(TD_GSM,150);
				}
				else GSM_State = GSM_SEND_CMGS;
    d388:	8e e3       	ldi	r24, 0x3E	; 62
    d38a:	80 93 ad 06 	sts	0x06AD, r24
    d38e:	0c 94 84 60 	jmp	0xc108	; 0xc108 <GSM_Cycle+0x40>
			}
			break;
		case GSM_WAIT_D2C_SWITCH_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) {

				switch(CommandModeDestination){
    d392:	84 30       	cpi	r24, 0x04	; 4
    d394:	09 f4       	brne	.+2      	; 0xd398 <GSM_Cycle+0x12d0>
    d396:	90 c0       	rjmp	.+288    	; 0xd4b8 <GSM_Cycle+0x13f0>
    d398:	85 30       	cpi	r24, 0x05	; 5
    d39a:	11 f0       	breq	.+4      	; 0xd3a0 <GSM_Cycle+0x12d8>
    d39c:	0c 94 9e 61 	jmp	0xc33c	; 0xc33c <GSM_Cycle+0x274>
					case 4:	
						GSM_State = GSM_SEND_ATD_Check_Ballance;
						counter=0;	
						break;
					case 5:	
						GSM_State = GSM_SEND_CSQ;
    d3a0:	8d e4       	ldi	r24, 0x4D	; 77
    d3a2:	80 93 ad 06 	sts	0x06AD, r24
						counter=0;	
    d3a6:	10 92 dc 02 	sts	0x02DC, r1
    d3aa:	0c 94 84 60 	jmp	0xc108	; 0xc108 <GSM_Cycle+0x40>
			}
			GSM_State++;
			break;
		case GSM_WAIT_CIPCSGP_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
			 if(GSM_Modem == SIMCOM_SIM800)GSM_State++;
    d3ae:	80 91 ad 06 	lds	r24, 0x06AD
    d3b2:	8f 5f       	subi	r24, 0xFF	; 255
    d3b4:	80 93 ad 06 	sts	0x06AD, r24
    d3b8:	0c 94 84 60 	jmp	0xc108	; 0xc108 <GSM_Cycle+0x40>
				}
			break;
		case GSM_WAIT_CSQ_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) {
				if(CommandModeDestination==5){
					GSM_State  = GSM_Return2dataMode;
    d3bc:	85 e5       	ldi	r24, 0x55	; 85
    d3be:	80 93 ad 06 	sts	0x06AD, r24
    d3c2:	0c 94 84 60 	jmp	0xc108	; 0xc108 <GSM_Cycle+0x40>
			GSM_State++; 
			break;
		case GSM_WAIT_CIPMUX_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
				if(GSM_MultiCon){
					GSM_State = GSM_WAIT_1;
    d3c6:	8c e2       	ldi	r24, 0x2C	; 44
    d3c8:	80 93 ad 06 	sts	0x06AD, r24
					// between "Call Ready" and "+CMGS"; 8 sec min needs; for kyivstar vpni only
					StartTimer16(TD_GSM, 1000);
    d3cc:	80 91 e1 04 	lds	r24, 0x04E1
    d3d0:	68 ee       	ldi	r22, 0xE8	; 232
    d3d2:	73 e0       	ldi	r23, 0x03	; 3
    d3d4:	0e 94 1d 1a 	call	0x343a	; 0x343a <StartTimer16>
    d3d8:	0c 94 84 60 	jmp	0xc108	; 0xc108 <GSM_Cycle+0x40>
			if(GSM_Wait_Response_P(URC_CPIN_READY, GSM_ReStart1)) GSM_State++;
			break;

		case GSM_WAIT_CALL_READY:
			if(GSM_Wait_Response_P(URC_CALL_READY, GSM_ReStart1)){
				if(GSM_Modem == SIMCOM_SIM800) GSM_State = GSM_WAIT_SMS_READY;
    d3dc:	87 e0       	ldi	r24, 0x07	; 7
    d3de:	80 93 ad 06 	sts	0x06AD, r24
    d3e2:	0c 94 84 60 	jmp	0xc108	; 0xc108 <GSM_Cycle+0x40>
		case GSM_WAIT_CGMM_READ:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
			if(GetStringFromFIFO()){
				if(!strcmp_P(GSM_RxStr, GSM_SIMCOM_SIM900R)) GSM_Modem = SIMCOM_SIM900R;
				if(!strcmp_P(GSM_RxStr, GSM_SIMCOM_SIM800)) GSM_Modem = SIMCOM_SIM800;
				if(!strcmp_P(GSM_RxStr, GSM_SIMCOM_SIM800C)) GSM_Modem = SIMCOM_SIM800;
    d3e6:	82 e0       	ldi	r24, 0x02	; 2
    d3e8:	80 93 eb 06 	sts	0x06EB, r24
    d3ec:	0c 94 1c 61 	jmp	0xc238	; 0xc238 <GSM_Cycle+0x170>

				switch(CommandModeDestination){
					case 1:	GSM_State = GSM_SEND_CMGS;
						break;
					case 2:	
						GSM_State = GSM_CIPSHUT_;
    d3f0:	82 e4       	ldi	r24, 0x42	; 66
    d3f2:	80 93 ad 06 	sts	0x06AD, r24
						counter=0;	
    d3f6:	10 92 dc 02 	sts	0x02DC, r1
    d3fa:	0c 94 84 60 	jmp	0xc108	; 0xc108 <GSM_Cycle+0x40>
			break;
		case GSM_WAIT_D2C_SWITCH_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) {

				switch(CommandModeDestination){
					case 1:	GSM_State = GSM_SEND_CMGS;
    d3fe:	8e e3       	ldi	r24, 0x3E	; 62
    d400:	80 93 ad 06 	sts	0x06AD, r24
    d404:	0c 94 84 60 	jmp	0xc108	; 0xc108 <GSM_Cycle+0x40>
				GSMTxSz = strlen(GSM_TxStr);
				uint8_t j=0;
				for(uint8_t i=0; i<GSMTxSz; i++)
					if(GSM_TxStr[i] != '0') j++;
				if(j){
					GSMTxSz = strlen_P(AT_CMGS);
    d408:	03 ee       	ldi	r16, 0xE3	; 227
    d40a:	14 e0       	ldi	r17, 0x04	; 4
    d40c:	c8 01       	movw	r24, r16
    d40e:	0e 94 8a 7a 	call	0xf514	; 0xf514 <strlen_P>
    d412:	80 93 6f 07 	sts	0x076F, r24
					sprintf_P(GSM_TxStr, AT_CMGS);
    d416:	00 d0       	rcall	.+0      	; 0xd418 <GSM_Cycle+0x1350>
    d418:	0f 92       	push	r0
    d41a:	ad b7       	in	r26, 0x3d	; 61
    d41c:	be b7       	in	r27, 0x3e	; 62
    d41e:	12 96       	adiw	r26, 0x02	; 2
    d420:	fc 92       	st	X, r15
    d422:	ee 92       	st	-X, r14
    d424:	11 97       	sbiw	r26, 0x01	; 1
    d426:	14 96       	adiw	r26, 0x04	; 4
    d428:	1c 93       	st	X, r17
    d42a:	0e 93       	st	-X, r16
    d42c:	13 97       	sbiw	r26, 0x03	; 3
    d42e:	0e 94 a7 7b 	call	0xf74e	; 0xf74e <sprintf_P>
					erbl(GSM_TxStr+GSMTxSz, SMS_Number+TempNum, MaxTelephN);
    d432:	80 91 6f 07 	lds	r24, 0x076F
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    d436:	0f 90       	pop	r0
    d438:	0f 90       	pop	r0
    d43a:	0f 90       	pop	r0
    d43c:	0f 90       	pop	r0
    d43e:	90 e0       	ldi	r25, 0x00	; 0
    d440:	60 91 d4 05 	lds	r22, 0x05D4
    d444:	2d e0       	ldi	r18, 0x0D	; 13
    d446:	62 9f       	mul	r22, r18
    d448:	b0 01       	movw	r22, r0
    d44a:	11 24       	eor	r1, r1
    d44c:	6b 53       	subi	r22, 0x3B	; 59
    d44e:	7f 4f       	sbci	r23, 0xFF	; 255
    d450:	84 50       	subi	r24, 0x04	; 4
    d452:	96 4f       	sbci	r25, 0xF6	; 246
    d454:	4d e0       	ldi	r20, 0x0D	; 13
    d456:	50 e0       	ldi	r21, 0x00	; 0
    d458:	0e 94 94 7d 	call	0xfb28	; 0xfb28 <__eerd_block_m2560>
					GSMTxSz = strlen(GSM_TxStr);
    d45c:	f7 01       	movw	r30, r14
    d45e:	01 90       	ld	r0, Z+
    d460:	00 20       	and	r0, r0
    d462:	e9 f7       	brne	.-6      	; 0xd45e <GSM_Cycle+0x1396>
    d464:	31 97       	sbiw	r30, 0x01	; 1
    d466:	ec 5f       	subi	r30, 0xFC	; 252
    d468:	f9 40       	sbci	r31, 0x09	; 9
    d46a:	e0 93 6f 07 	sts	0x076F, r30
					sprintf(GSM_TxStr + GSMTxSz, "\"\r");
    d46e:	80 91 6f 07 	lds	r24, 0x076F
    d472:	e8 2f       	mov	r30, r24
    d474:	f0 e0       	ldi	r31, 0x00	; 0
    d476:	e4 50       	subi	r30, 0x04	; 4
    d478:	f6 4f       	sbci	r31, 0xF6	; 246
    d47a:	a2 eb       	ldi	r26, 0xB2	; 178
    d47c:	b2 e0       	ldi	r27, 0x02	; 2
    d47e:	83 e0       	ldi	r24, 0x03	; 3
    d480:	0d 90       	ld	r0, X+
    d482:	01 92       	st	Z+, r0
    d484:	81 50       	subi	r24, 0x01	; 1
    d486:	e1 f7       	brne	.-8      	; 0xd480 <GSM_Cycle+0x13b8>
					GSMTxSz = strlen(GSM_TxStr);
    d488:	f7 01       	movw	r30, r14
    d48a:	01 90       	ld	r0, Z+
    d48c:	00 20       	and	r0, r0
    d48e:	e9 f7       	brne	.-6      	; 0xd48a <GSM_Cycle+0x13c2>
    d490:	31 97       	sbiw	r30, 0x01	; 1
    d492:	ec 5f       	subi	r30, 0xFC	; 252
    d494:	f9 40       	sbci	r31, 0x09	; 9
    d496:	e0 93 6f 07 	sts	0x076F, r30
					GSM_SendFirstChar();
    d49a:	0e 94 fd 38 	call	0x71fa	; 0x71fa <GSM_SendFirstChar>
					StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    d49e:	80 91 e1 04 	lds	r24, 0x04E1
    d4a2:	64 ef       	ldi	r22, 0xF4	; 244
    d4a4:	71 e0       	ldi	r23, 0x01	; 1
    d4a6:	0e 94 1d 1a 	call	0x343a	; 0x343a <StartTimer16>
					GSM_State++;
    d4aa:	80 91 ad 06 	lds	r24, 0x06AD
    d4ae:	8f 5f       	subi	r24, 0xFF	; 255
    d4b0:	80 93 ad 06 	sts	0x06AD, r24
    d4b4:	0c 94 84 60 	jmp	0xc108	; 0xc108 <GSM_Cycle+0x40>
					case 2:	
						GSM_State = GSM_CIPSHUT_;
						counter=0;	
						break;						
					case 4:	
						GSM_State = GSM_SEND_ATD_Check_Ballance;
    d4b8:	8a e4       	ldi	r24, 0x4A	; 74
    d4ba:	80 93 ad 06 	sts	0x06AD, r24
						counter=0;	
    d4be:	10 92 dc 02 	sts	0x02DC, r1
    d4c2:	0c 94 84 60 	jmp	0xc108	; 0xc108 <GSM_Cycle+0x40>
				GSM_State = GSM_ProtocolMode;
				InitFIFO();
				break;
			}
*/			
			if( (strstr_P(GSM_RxStr, PSTR("OK")) != NULL) ){
    d4c6:	c8 01       	movw	r24, r16
    d4c8:	6a ef       	ldi	r22, 0xFA	; 250
    d4ca:	7b e2       	ldi	r23, 0x2B	; 43
    d4cc:	0e 94 ac 7a 	call	0xf558	; 0xf558 <strstr_P>
    d4d0:	89 2b       	or	r24, r25
    d4d2:	41 f1       	breq	.+80     	; 0xd524 <GSM_Cycle+0x145c>
				StartTimer16(TD_data_start_delay,100);
    d4d4:	80 91 e8 04 	lds	r24, 0x04E8
    d4d8:	64 e6       	ldi	r22, 0x64	; 100
    d4da:	70 e0       	ldi	r23, 0x00	; 0
    d4dc:	0e 94 1d 1a 	call	0x343a	; 0x343a <StartTimer16>
				GSM_State = GSM_ProtocolMode;
    d4e0:	80 e5       	ldi	r24, 0x50	; 80
    d4e2:	80 93 ad 06 	sts	0x06AD, r24
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    d4e6:	8f ef       	ldi	r24, 0xFF	; 255
    d4e8:	80 93 f4 06 	sts	0x06F4, r24
	GSM_RX_FIFO_End = 255;
    d4ec:	80 93 4b 06 	sts	0x064B, r24
	GSM_RxCharN = 0;
    d4f0:	10 92 12 0b 	sts	0x0B12, r1
	GSM_RX_FIFOOverFlow = 0;
    d4f4:	10 92 c5 08 	sts	0x08C5, r1
	GSM_RX_FIFOMax = 0;
    d4f8:	10 92 cb 08 	sts	0x08CB, r1
    d4fc:	0c 94 84 60 	jmp	0xc108	; 0xc108 <GSM_Cycle+0x40>
						//break;
					}
				}//while
				//GSM_RxCharN=0;
				if(Timer16Stopp(TD_CleanFIFO)&&(GSM_RX_FIFO_Begin == GSM_RX_FIFO_End)){
					StartTimer16(TD_CleanFIFO,500);
    d500:	80 91 e7 04 	lds	r24, 0x04E7
    d504:	64 ef       	ldi	r22, 0xF4	; 244
    d506:	71 e0       	ldi	r23, 0x01	; 1
    d508:	0e 94 1d 1a 	call	0x343a	; 0x343a <StartTimer16>
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    d50c:	8f ef       	ldi	r24, 0xFF	; 255
    d50e:	80 93 f4 06 	sts	0x06F4, r24
	GSM_RX_FIFO_End = 255;
    d512:	80 93 4b 06 	sts	0x064B, r24
	GSM_RxCharN = 0;
    d516:	10 92 12 0b 	sts	0x0B12, r1
	GSM_RX_FIFOOverFlow = 0;
    d51a:	10 92 c5 08 	sts	0x08C5, r1
	GSM_RX_FIFOMax = 0;
    d51e:	10 92 cb 08 	sts	0x08CB, r1
    d522:	25 ce       	rjmp	.-950    	; 0xd16e <GSM_Cycle+0x10a6>
				break;
			}


			//  
			if( (strstr_P(GSM_RxStr, URC_CONNECT) != NULL) ){
    d524:	c8 01       	movw	r24, r16
    d526:	6c eb       	ldi	r22, 0xBC	; 188
    d528:	73 e0       	ldi	r23, 0x03	; 3
    d52a:	0e 94 ac 7a 	call	0xf558	; 0xf558 <strstr_P>
    d52e:	89 2b       	or	r24, r25
    d530:	b1 f0       	breq	.+44     	; 0xd55e <GSM_Cycle+0x1496>

				GSM_State = GSM_ProtocolMode;
    d532:	80 e5       	ldi	r24, 0x50	; 80
    d534:	80 93 ad 06 	sts	0x06AD, r24
    d538:	f8 01       	movw	r30, r16
				for(int i=0;i<GSM_RXSTR_SIZE;i++)
				{
					GSM_RxStr[i]=0;	
    d53a:	11 92       	st	Z+, r1

			//  
			if( (strstr_P(GSM_RxStr, URC_CONNECT) != NULL) ){

				GSM_State = GSM_ProtocolMode;
				for(int i=0;i<GSM_RXSTR_SIZE;i++)
    d53c:	37 e0       	ldi	r19, 0x07	; 7
    d53e:	e7 3f       	cpi	r30, 0xF7	; 247
    d540:	f3 07       	cpc	r31, r19
    d542:	d9 f7       	brne	.-10     	; 0xd53a <GSM_Cycle+0x1472>
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    d544:	8f ef       	ldi	r24, 0xFF	; 255
    d546:	80 93 f4 06 	sts	0x06F4, r24
	GSM_RX_FIFO_End = 255;
    d54a:	80 93 4b 06 	sts	0x064B, r24
	GSM_RxCharN = 0;
    d54e:	10 92 12 0b 	sts	0x0B12, r1
	GSM_RX_FIFOOverFlow = 0;
    d552:	10 92 c5 08 	sts	0x08C5, r1
	GSM_RX_FIFOMax = 0;
    d556:	10 92 cb 08 	sts	0x08CB, r1
    d55a:	0c 94 84 60 	jmp	0xc108	; 0xc108 <GSM_Cycle+0x40>

				break;
			}

			//  
			if(strstr_P(GSM_RxStr, URC_CLOSED) != NULL){
    d55e:	c8 01       	movw	r24, r16
    d560:	6e ec       	ldi	r22, 0xCE	; 206
    d562:	73 e0       	ldi	r23, 0x03	; 3
    d564:	0e 94 ac 7a 	call	0xf558	; 0xf558 <strstr_P>
    d568:	89 2b       	or	r24, r25
    d56a:	99 f1       	breq	.+102    	; 0xd5d2 <GSM_Cycle+0x150a>
				//  
				sscanf_P(GSM_RxStr,PSTR("%hhu, CLOSED"),(unsigned char*)&TempNum);
    d56c:	00 d0       	rcall	.+0      	; 0xd56e <GSM_Cycle+0x14a6>
    d56e:	00 d0       	rcall	.+0      	; 0xd570 <GSM_Cycle+0x14a8>
    d570:	ed b7       	in	r30, 0x3d	; 61
    d572:	fe b7       	in	r31, 0x3e	; 62
    d574:	31 96       	adiw	r30, 0x01	; 1
    d576:	ad b7       	in	r26, 0x3d	; 61
    d578:	be b7       	in	r27, 0x3e	; 62
    d57a:	12 96       	adiw	r26, 0x02	; 2
    d57c:	1c 93       	st	X, r17
    d57e:	0e 93       	st	-X, r16
    d580:	11 97       	sbiw	r26, 0x01	; 1
    d582:	8d ee       	ldi	r24, 0xED	; 237
    d584:	9b e2       	ldi	r25, 0x2B	; 43
    d586:	93 83       	std	Z+3, r25	; 0x03
    d588:	82 83       	std	Z+2, r24	; 0x02
    d58a:	84 ed       	ldi	r24, 0xD4	; 212
    d58c:	95 e0       	ldi	r25, 0x05	; 5
    d58e:	95 83       	std	Z+5, r25	; 0x05
    d590:	84 83       	std	Z+4, r24	; 0x04
    d592:	0e 94 fb 7b 	call	0xf7f6	; 0xf7f6 <sscanf_P>
				if(GSM_ActiveConnection == TempNum){
    d596:	ed b7       	in	r30, 0x3d	; 61
    d598:	fe b7       	in	r31, 0x3e	; 62
    d59a:	36 96       	adiw	r30, 0x06	; 6
    d59c:	0f b6       	in	r0, 0x3f	; 63
    d59e:	f8 94       	cli
    d5a0:	fe bf       	out	0x3e, r31	; 62
    d5a2:	0f be       	out	0x3f, r0	; 63
    d5a4:	ed bf       	out	0x3d, r30	; 61
    d5a6:	90 91 d0 02 	lds	r25, 0x02D0
    d5aa:	80 91 d4 05 	lds	r24, 0x05D4
    d5ae:	98 17       	cp	r25, r24
    d5b0:	59 f4       	brne	.+22     	; 0xd5c8 <GSM_Cycle+0x1500>
					GSM_ActiveConnection = NO_CONNECTION;
    d5b2:	8f ef       	ldi	r24, 0xFF	; 255
    d5b4:	80 93 d0 02 	sts	0x02D0, r24
	uint8_t IP4;
} IP_Addr;

//~~~~~~~~~~~~~~
void SetIP(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	IP->IP1 = IP1;
    d5b8:	10 92 fc 0a 	sts	0x0AFC, r1
	IP->IP2 = IP2;
    d5bc:	10 92 fd 0a 	sts	0x0AFD, r1
	IP->IP3 = IP3;
    d5c0:	10 92 fe 0a 	sts	0x0AFE, r1
	IP->IP4 = IP4;
    d5c4:	10 92 ff 0a 	sts	0x0AFF, r1
					SetIP(&GSM_ClientIP,0,0,0,0);
				}

				GSM_State = GSM_ReStart1;
    d5c8:	88 e4       	ldi	r24, 0x48	; 72
    d5ca:	80 93 ad 06 	sts	0x06AD, r24
    d5ce:	0c 94 84 60 	jmp	0xc108	; 0xc108 <GSM_Cycle+0x40>
				break;
			}

			// +PDP DEACT
			if( (strstr_P(GSM_RxStr, URC_PDPDEACT) != NULL) ){
    d5d2:	c8 01       	movw	r24, r16
    d5d4:	67 ed       	ldi	r22, 0xD7	; 215
    d5d6:	73 e0       	ldi	r23, 0x03	; 3
    d5d8:	0e 94 ac 7a 	call	0xf558	; 0xf558 <strstr_P>
    d5dc:	89 2b       	or	r24, r25
    d5de:	99 f0       	breq	.+38     	; 0xd606 <GSM_Cycle+0x153e>
				GSM_State = GSM_SEND_E0;
    d5e0:	88 e0       	ldi	r24, 0x08	; 8
    d5e2:	80 93 ad 06 	sts	0x06AD, r24
    d5e6:	0c 94 84 60 	jmp	0xc108	; 0xc108 <GSM_Cycle+0x40>
							if(!strncmp_P(GSM_RxStr, PSTR("\r\n"), 2)) {GSM_RxCharN=0;}
						}
					if(GSM_RxCharN >= 4){
						AppProtocol = 0;
						if(!strncmp_P(GSM_RxStr, PSTR("GET "), 4)) {AppProtocol = _HTTP;GSM_State = GSM_DataMode;break;}//GET
						if(!strncmp_P(GSM_RxStr, PSTR("POST"), 4)) {AppProtocol = _HTTP;GSM_State = GSM_DataMode;break;}//POST
    d5ea:	81 e0       	ldi	r24, 0x01	; 1
    d5ec:	80 93 99 08 	sts	0x0899, r24
    d5f0:	81 e5       	ldi	r24, 0x51	; 81
    d5f2:	80 93 ad 06 	sts	0x06AD, r24
    d5f6:	ae cd       	rjmp	.-1188   	; 0xd154 <GSM_Cycle+0x108c>
						if(!strncmp_P(GSM_RxStr, PSTR("CLOS"), 4)) {AppProtocol = _HTTP;GSM_State = GSM_ReStart1;break;}// 
						if(!strncmp_P(GSM_RxStr, PSTR("+PDP"), 4)) {AppProtocol = _HTTP;GSM_State = GSM_ReStart1;break;}//GPRS 
						if( (GSM_RxStr[0]==0) && (GSM_RxStr[1]==0)){AppProtocol = _HTTP;GSM_State = GSM_ReStart1;break;}//  
    d5f8:	81 e0       	ldi	r24, 0x01	; 1
    d5fa:	80 93 99 08 	sts	0x0899, r24
    d5fe:	88 e4       	ldi	r24, 0x48	; 72
    d600:	80 93 ad 06 	sts	0x06AD, r24
    d604:	a7 cd       	rjmp	.-1202   	; 0xd154 <GSM_Cycle+0x108c>
			}



			//      
			if(strstr_P(GSM_RxStr, RESP_CSQ) != NULL ){
    d606:	c8 01       	movw	r24, r16
    d608:	6f e3       	ldi	r22, 0x3F	; 63
    d60a:	74 e0       	ldi	r23, 0x04	; 4
    d60c:	0e 94 ac 7a 	call	0xf558	; 0xf558 <strstr_P>
    d610:	89 2b       	or	r24, r25
    d612:	29 f0       	breq	.+10     	; 0xd61e <GSM_Cycle+0x1556>
				GSM_State = GSM_WAIT_CSQ;
    d614:	8e e4       	ldi	r24, 0x4E	; 78
    d616:	80 93 ad 06 	sts	0x06AD, r24
    d61a:	0c 94 84 60 	jmp	0xc108	; 0xc108 <GSM_Cycle+0x40>
				break;
			}

			// 
			GSM_State = GSM_WAIT_IDENTIFICATION;
    d61e:	8c e3       	ldi	r24, 0x3C	; 60
    d620:	80 93 ad 06 	sts	0x06AD, r24
    d624:	0c 94 84 60 	jmp	0xc108	; 0xc108 <GSM_Cycle+0x40>

0000d628 <USART_Cycle>:

// ~~~~~~~~~~~~~~
void
USART_Cycle(void)
{
	MB_Cycle();
    d628:	0e 94 0e 37 	call	0x6e1c	; 0x6e1c <MB_Cycle>
	#ifdef GSM
		GSM_Cycle();
    d62c:	0e 94 64 60 	call	0xc0c8	; 0xc0c8 <GSM_Cycle>
	#endif
	#ifdef UDP_EASY
		UDP_RxProcess();
	#endif
}
    d630:	08 95       	ret

0000d632 <IP_E_compare_Const>:
}
uint8_t IP_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	if((IP->IP1 == IP1) && (IP->IP2 == IP2) && (IP->IP3 == IP3) && (IP->IP4 == IP4)) return 1;
	else return 0;
}
uint8_t IP_E_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
    d632:	ef 92       	push	r14
    d634:	ff 92       	push	r15
    d636:	0f 93       	push	r16
    d638:	1f 93       	push	r17
    d63a:	cf 93       	push	r28
    d63c:	df 93       	push	r29
    d63e:	ec 01       	movw	r28, r24
    d640:	16 2f       	mov	r17, r22
    d642:	f4 2e       	mov	r15, r20
    d644:	e2 2e       	mov	r14, r18
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    d646:	0e 94 a4 7d 	call	0xfb48	; 0xfb48 <__eerd_byte_m2560>
	if((erb(&IP->IP1) == IP1) && (erb(&IP->IP2) == IP2) && (erb(&IP->IP3) == IP3) && (erb(&IP->IP4) == IP4)) return 1;
    d64a:	18 17       	cp	r17, r24
    d64c:	49 f0       	breq	.+18     	; 0xd660 <IP_E_compare_Const+0x2e>
	else return 0;
}
    d64e:	90 e0       	ldi	r25, 0x00	; 0
    d650:	89 2f       	mov	r24, r25
    d652:	df 91       	pop	r29
    d654:	cf 91       	pop	r28
    d656:	1f 91       	pop	r17
    d658:	0f 91       	pop	r16
    d65a:	ff 90       	pop	r15
    d65c:	ef 90       	pop	r14
    d65e:	08 95       	ret
    d660:	ce 01       	movw	r24, r28
    d662:	01 96       	adiw	r24, 0x01	; 1
    d664:	0e 94 a4 7d 	call	0xfb48	; 0xfb48 <__eerd_byte_m2560>
uint8_t IP_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	if((IP->IP1 == IP1) && (IP->IP2 == IP2) && (IP->IP3 == IP3) && (IP->IP4 == IP4)) return 1;
	else return 0;
}
uint8_t IP_E_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	if((erb(&IP->IP1) == IP1) && (erb(&IP->IP2) == IP2) && (erb(&IP->IP3) == IP3) && (erb(&IP->IP4) == IP4)) return 1;
    d668:	f8 16       	cp	r15, r24
    d66a:	89 f7       	brne	.-30     	; 0xd64e <IP_E_compare_Const+0x1c>
    d66c:	ce 01       	movw	r24, r28
    d66e:	02 96       	adiw	r24, 0x02	; 2
    d670:	0e 94 a4 7d 	call	0xfb48	; 0xfb48 <__eerd_byte_m2560>
    d674:	e8 16       	cp	r14, r24
    d676:	59 f7       	brne	.-42     	; 0xd64e <IP_E_compare_Const+0x1c>
    d678:	ce 01       	movw	r24, r28
    d67a:	03 96       	adiw	r24, 0x03	; 3
    d67c:	0e 94 a4 7d 	call	0xfb48	; 0xfb48 <__eerd_byte_m2560>
    d680:	90 e0       	ldi	r25, 0x00	; 0
    d682:	08 13       	cpse	r16, r24
    d684:	91 e0       	ldi	r25, 0x01	; 1
    d686:	81 e0       	ldi	r24, 0x01	; 1
    d688:	98 27       	eor	r25, r24
    d68a:	e2 cf       	rjmp	.-60     	; 0xd650 <IP_E_compare_Const+0x1e>

0000d68c <MB_M_Init>:
}

// ~~~~~~~~~~~~~~~~~~~~
void
MB_M_Init(uint8_t MB_N)
{
    d68c:	cf 92       	push	r12
    d68e:	df 92       	push	r13
    d690:	ef 92       	push	r14
    d692:	ff 92       	push	r15
    d694:	0f 93       	push	r16
    d696:	1f 93       	push	r17
	MB_M_Period[MB_N]		= erw(&MB_M_Param_EE[MB_N].Period);
    d698:	e8 2e       	mov	r14, r24
    d69a:	ff 24       	eor	r15, r15
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    d69c:	87 01       	movw	r16, r14
    d69e:	00 0f       	add	r16, r16
    d6a0:	11 1f       	adc	r17, r17
    d6a2:	00 0f       	add	r16, r16
    d6a4:	11 1f       	adc	r17, r17
    d6a6:	0e 0d       	add	r16, r14
    d6a8:	1f 1d       	adc	r17, r15
    d6aa:	82 e3       	ldi	r24, 0x32	; 50
    d6ac:	c8 2e       	mov	r12, r24
    d6ae:	81 e0       	ldi	r24, 0x01	; 1
    d6b0:	d8 2e       	mov	r13, r24
    d6b2:	c6 01       	movw	r24, r12
    d6b4:	80 0f       	add	r24, r16
    d6b6:	91 1f       	adc	r25, r17
    d6b8:	0e 94 b2 7d 	call	0xfb64	; 0xfb64 <__eerd_word_m2560>
    d6bc:	f7 01       	movw	r30, r14
    d6be:	ee 0f       	add	r30, r30
    d6c0:	ff 1f       	adc	r31, r31
    d6c2:	eb 55       	subi	r30, 0x5B	; 91
    d6c4:	f9 4f       	sbci	r31, 0xF9	; 249
    d6c6:	91 83       	std	Z+1, r25	; 0x01
    d6c8:	80 83       	st	Z, r24
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    d6ca:	0e 5f       	subi	r16, 0xFE	; 254
    d6cc:	1f 4f       	sbci	r17, 0xFF	; 255
    d6ce:	c6 01       	movw	r24, r12
    d6d0:	80 0f       	add	r24, r16
    d6d2:	91 1f       	adc	r25, r17
    d6d4:	0e 94 a4 7d 	call	0xfb48	; 0xfb48 <__eerd_byte_m2560>
	MB_M_Timeout[MB_N]	= erb(&MB_M_Param_EE[MB_N].Timeout);
    d6d8:	f7 01       	movw	r30, r14
    d6da:	e5 52       	subi	r30, 0x25	; 37
    d6dc:	f7 4f       	sbci	r31, 0xF7	; 247
    d6de:	80 83       	st	Z, r24
    d6e0:	0f 5f       	subi	r16, 0xFF	; 255
    d6e2:	1f 4f       	sbci	r17, 0xFF	; 255
    d6e4:	c6 01       	movw	r24, r12
    d6e6:	80 0f       	add	r24, r16
    d6e8:	91 1f       	adc	r25, r17
    d6ea:	0e 94 a4 7d 	call	0xfb48	; 0xfb48 <__eerd_byte_m2560>
	MB_M_Try[MB_N]			= erb(&MB_M_Param_EE[MB_N].Try);
    d6ee:	f7 01       	movw	r30, r14
    d6f0:	eb 50       	subi	r30, 0x0B	; 11
    d6f2:	f9 4f       	sbci	r31, 0xF9	; 249
    d6f4:	80 83       	st	Z, r24
    d6f6:	0f 5f       	subi	r16, 0xFF	; 255
    d6f8:	1f 4f       	sbci	r17, 0xFF	; 255
    d6fa:	c6 01       	movw	r24, r12
    d6fc:	80 0f       	add	r24, r16
    d6fe:	91 1f       	adc	r25, r17
    d700:	0e 94 a4 7d 	call	0xfb48	; 0xfb48 <__eerd_byte_m2560>
	MB_M_TimeOff[MB_N]	= erb(&MB_M_Param_EE[MB_N].TimeOff);
    d704:	27 ed       	ldi	r18, 0xD7	; 215
    d706:	35 e0       	ldi	r19, 0x05	; 5
    d708:	e2 0e       	add	r14, r18
    d70a:	f3 1e       	adc	r15, r19
    d70c:	f7 01       	movw	r30, r14
    d70e:	80 83       	st	Z, r24

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    d710:	80 91 cd 02 	lds	r24, 0x02CD
	VacantTimer16Sys += n;
    d714:	8d 5f       	subi	r24, 0xFD	; 253
    d716:	80 93 cd 02 	sts	0x02CD, r24
    d71a:	83 50       	subi	r24, 0x03	; 3

	TD_MB = Timer16SysAlloc(Modbus_Qt*3);
    d71c:	80 93 e0 04 	sts	0x04E0, r24
}
    d720:	1f 91       	pop	r17
    d722:	0f 91       	pop	r16
    d724:	ff 90       	pop	r15
    d726:	ef 90       	pop	r14
    d728:	df 90       	pop	r13
    d72a:	cf 90       	pop	r12
    d72c:	08 95       	ret

0000d72e <MB_S_Init>:
}

// ~~~~~~~~~~~~~~~~~~~~
void
MB_S_Init(uint8_t MB_N)
{
    d72e:	0f 93       	push	r16
    d730:	1f 93       	push	r17
    d732:	08 2f       	mov	r16, r24
    d734:	10 e0       	ldi	r17, 0x00	; 0
    d736:	c8 01       	movw	r24, r16
    d738:	89 5c       	subi	r24, 0xC9	; 201
    d73a:	9e 4f       	sbci	r25, 0xFE	; 254
    d73c:	0e 94 a4 7d 	call	0xfb48	; 0xfb48 <__eerd_byte_m2560>
	#ifndef MB_ADDR_DIP_SW
		MB_NativeAddr[MB_N] = erb(MB_NativeAddr_EE+MB_N);
    d740:	08 52       	subi	r16, 0x28	; 40
    d742:	1a 4f       	sbci	r17, 0xFA	; 250
    d744:	f8 01       	movw	r30, r16
    d746:	80 83       	st	Z, r24
	#endif
}
    d748:	1f 91       	pop	r17
    d74a:	0f 91       	pop	r16
    d74c:	08 95       	ret

0000d74e <SetBAUD>:
}

// ~~~~~~~~~~~~~~~~~~
void
SetBAUD(uint8_t MB_N)
{
    d74e:	ef 92       	push	r14
    d750:	ff 92       	push	r15
    d752:	0f 93       	push	r16
    d754:	1f 93       	push	r17
	BR_Val *ptrBR_Val = BR_Tbl + (MB_BitRate_RAM[MB_N] = erb(&MB_Param[MB_N].BitRate));
    d756:	08 2f       	mov	r16, r24
    d758:	10 e0       	ldi	r17, 0x00	; 0
    d75a:	78 01       	movw	r14, r16
    d75c:	ee 0c       	add	r14, r14
    d75e:	ff 1c       	adc	r15, r15
    d760:	e0 0e       	add	r14, r16
    d762:	f1 1e       	adc	r15, r17
    d764:	c7 01       	movw	r24, r14
    d766:	8a 5f       	subi	r24, 0xFA	; 250
    d768:	9f 4f       	sbci	r25, 0xFF	; 255
    d76a:	0e 94 a4 7d 	call	0xfb48	; 0xfb48 <__eerd_byte_m2560>
    d76e:	98 2f       	mov	r25, r24
    d770:	f8 01       	movw	r30, r16
    d772:	e0 58       	subi	r30, 0x80	; 128
    d774:	f8 4f       	sbci	r31, 0xF8	; 248
    d776:	80 83       	st	Z, r24
    d778:	83 e0       	ldi	r24, 0x03	; 3
    d77a:	98 9f       	mul	r25, r24
    d77c:	b0 01       	movw	r22, r0
    d77e:	11 24       	eor	r1, r1
    d780:	64 5c       	subi	r22, 0xC4	; 196
    d782:	7c 4f       	sbci	r23, 0xFC	; 252

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    d784:	00 0f       	add	r16, r16
    d786:	11 1f       	adc	r17, r17
    d788:	00 0f       	add	r16, r16
    d78a:	11 1f       	adc	r17, r17
    d78c:	c8 01       	movw	r24, r16
    d78e:	88 0f       	add	r24, r24
    d790:	99 1f       	adc	r25, r25
    d792:	88 0f       	add	r24, r24
    d794:	99 1f       	adc	r25, r25
    d796:	80 0f       	add	r24, r16
    d798:	91 1f       	adc	r25, r17
    d79a:	0a 96       	adiw	r24, 0x0a	; 10
    d79c:	41 e1       	ldi	r20, 0x11	; 17
    d79e:	5c e2       	ldi	r21, 0x2C	; 44
    d7a0:	9a 01       	movw	r18, r20
    d7a2:	28 0f       	add	r18, r24
    d7a4:	39 1f       	adc	r19, r25
    d7a6:	f9 01       	movw	r30, r18
    d7a8:	a5 91       	lpm	r26, Z+
    d7aa:	b4 91       	lpm	r27, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    d7ac:	fb 01       	movw	r30, r22
    d7ae:	24 91       	lpm	r18, Z+
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		USART_Reg(MB_N, ubrrl) = prb((uint8_t*)&ptrBR_Val->UBRR);
    d7b0:	2c 93       	st	X, r18

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    d7b2:	02 97       	sbiw	r24, 0x02	; 2
    d7b4:	84 0f       	add	r24, r20
    d7b6:	95 1f       	adc	r25, r21
    d7b8:	fc 01       	movw	r30, r24
    d7ba:	a5 91       	lpm	r26, Z+
    d7bc:	b4 91       	lpm	r27, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    d7be:	6f 5f       	subi	r22, 0xFF	; 255
    d7c0:	7f 4f       	sbci	r23, 0xFF	; 255
    d7c2:	fb 01       	movw	r30, r22
    d7c4:	84 91       	lpm	r24, Z+
		USART_Reg(MB_N, ubrrh) = prb((uint8_t*)&ptrBR_Val->UBRR+1);
    d7c6:	8c 93       	st	X, r24

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    d7c8:	c7 01       	movw	r24, r14
    d7ca:	88 0f       	add	r24, r24
    d7cc:	99 1f       	adc	r25, r25
    d7ce:	88 5d       	subi	r24, 0xD8	; 216
    d7d0:	93 4d       	sbci	r25, 0xD3	; 211
    d7d2:	fc 01       	movw	r30, r24
    d7d4:	a5 91       	lpm	r26, Z+
    d7d6:	b4 91       	lpm	r27, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    d7d8:	6f 5f       	subi	r22, 0xFF	; 255
    d7da:	7f 4f       	sbci	r23, 0xFF	; 255
    d7dc:	fb 01       	movw	r30, r22
    d7de:	84 91       	lpm	r24, Z+

		*(uint8_t*)prp(&MB_Timer[MB_N].OCR) = prb(&ptrBR_Val->Time35);
    d7e0:	8c 93       	st	X, r24
		usart->BAUDCTRLA = prb((uint8_t*)&ptrBR_Val->UBRR);
		usart->BAUDCTRLB = prb((uint8_t*)&ptrBR_Val->UBRR+1) + USART_BSCALE0_bm;

		((TC1_t*)prp(MB_Timer+MB_N))->PER = prw(&ptrBR_Val->Time35);
	#endif
}
    d7e2:	1f 91       	pop	r17
    d7e4:	0f 91       	pop	r16
    d7e6:	ff 90       	pop	r15
    d7e8:	ef 90       	pop	r14
    d7ea:	08 95       	ret

0000d7ec <Key_MB0_BitRate>:
	{" BAUD: }}}}}bps     ", NULL, F_MB##N##_Baud}																														\
};																																																					\
MenuPage MenuModbus##N = {SetMenu(L_MB##N), 1};

#if Modbus_Qt == 1
	M_Modbus(0)
    d7ec:	80 e0       	ldi	r24, 0x00	; 0
    d7ee:	0e 94 a7 6b 	call	0xd74e	; 0xd74e <SetBAUD>
    d7f2:	08 95       	ret

0000d7f4 <SetParity>:
// ~~~

// ~~~~~~~~~~~~~~~~~~~~
void
SetParity(uint8_t MB_N)
{
    d7f4:	ff 92       	push	r15
    d7f6:	0f 93       	push	r16
    d7f8:	1f 93       	push	r17
    d7fa:	cf 93       	push	r28
    d7fc:	df 93       	push	r29
	uint8_t Parity = erb(&MB_Param[MB_N].Parity), S_B = erb(&MB_Param[MB_N].StopBits);
    d7fe:	c8 2f       	mov	r28, r24
    d800:	d0 e0       	ldi	r29, 0x00	; 0
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    d802:	8e 01       	movw	r16, r28
    d804:	00 0f       	add	r16, r16
    d806:	11 1f       	adc	r17, r17
    d808:	0c 0f       	add	r16, r28
    d80a:	1d 1f       	adc	r17, r29
    d80c:	c8 01       	movw	r24, r16
    d80e:	8c 5f       	subi	r24, 0xFC	; 252
    d810:	9f 4f       	sbci	r25, 0xFF	; 255
    d812:	0e 94 a4 7d 	call	0xfb48	; 0xfb48 <__eerd_byte_m2560>
    d816:	f8 2e       	mov	r15, r24
    d818:	0b 5f       	subi	r16, 0xFB	; 251
    d81a:	1f 4f       	sbci	r17, 0xFF	; 255
    d81c:	c8 01       	movw	r24, r16
    d81e:	0e 94 a4 7d 	call	0xfb48	; 0xfb48 <__eerd_byte_m2560>
    d822:	48 2f       	mov	r20, r24
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		uint8_t ucsrc = (~(1<<6) |(1<<2) |(1<<1)) &~(1<<0);
		if (Parity==NoParity) {
    d824:	ff 20       	and	r15, r15
    d826:	e1 f4       	brne	.+56     	; 0xd860 <SetParity+0x6c>
			ucsrc &=~(1<<5) &~(1<<4);
			switch (S_B) {
    d828:	81 30       	cpi	r24, 0x01	; 1
    d82a:	09 f4       	brne	.+2      	; 0xd82e <SetParity+0x3a>
    d82c:	3d c0       	rjmp	.+122    	; 0xd8a8 <SetParity+0xb4>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    d82e:	ce 01       	movw	r24, r28
    d830:	88 0f       	add	r24, r24
    d832:	99 1f       	adc	r25, r25
    d834:	88 0f       	add	r24, r24
    d836:	99 1f       	adc	r25, r25
    d838:	9c 01       	movw	r18, r24
    d83a:	22 0f       	add	r18, r18
    d83c:	33 1f       	adc	r19, r19
    d83e:	22 0f       	add	r18, r18
    d840:	33 1f       	adc	r19, r19
    d842:	28 0f       	add	r18, r24
    d844:	39 1f       	adc	r19, r25
    d846:	29 5e       	subi	r18, 0xE9	; 233
    d848:	33 4d       	sbci	r19, 0xD3	; 211
    d84a:	f9 01       	movw	r30, r18
    d84c:	a5 91       	lpm	r26, Z+
    d84e:	b4 91       	lpm	r27, Z+
		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
			ucsrc  |=(1<<7);
		#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
			ucsrc &=~(1<<7);
		#endif
		USART_Reg(MB_N, ucsrc) = ucsrc;
    d850:	8e e0       	ldi	r24, 0x0E	; 14
    d852:	8c 93       	st	X, r24
			}
		}
	#endif
	if (Parity!=NoParity && S_B!=1)
		ewb(&MB_Param[MB_N].StopBits, 1);
}
    d854:	df 91       	pop	r29
    d856:	cf 91       	pop	r28
    d858:	1f 91       	pop	r17
    d85a:	0f 91       	pop	r16
    d85c:	ff 90       	pop	r15
    d85e:	08 95       	ret
				break;
			}
		}
		else {
			ucsrc &=~(1<<3);
			switch (Parity) {
    d860:	81 e0       	ldi	r24, 0x01	; 1
    d862:	f8 16       	cp	r15, r24
    d864:	f9 f0       	breq	.+62     	; 0xd8a4 <SetParity+0xb0>
			}
		}
	#endif
	if (Parity!=NoParity && S_B!=1)
		ewb(&MB_Param[MB_N].StopBits, 1);
}
    d866:	56 e3       	ldi	r21, 0x36	; 54
    d868:	ce 01       	movw	r24, r28
    d86a:	88 0f       	add	r24, r24
    d86c:	99 1f       	adc	r25, r25
    d86e:	88 0f       	add	r24, r24
    d870:	99 1f       	adc	r25, r25
    d872:	9c 01       	movw	r18, r24
    d874:	22 0f       	add	r18, r18
    d876:	33 1f       	adc	r19, r19
    d878:	22 0f       	add	r18, r18
    d87a:	33 1f       	adc	r19, r19
    d87c:	28 0f       	add	r18, r24
    d87e:	39 1f       	adc	r19, r25
    d880:	29 5e       	subi	r18, 0xE9	; 233
    d882:	33 4d       	sbci	r19, 0xD3	; 211
    d884:	f9 01       	movw	r30, r18
    d886:	a5 91       	lpm	r26, Z+
    d888:	b4 91       	lpm	r27, Z+
		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
			ucsrc  |=(1<<7);
		#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
			ucsrc &=~(1<<7);
		#endif
		USART_Reg(MB_N, ucsrc) = ucsrc;
    d88a:	5c 93       	st	X, r21
				usart->CTRLC |=USART_PMODE_ODD_gc;
				break;
			}
		}
	#endif
	if (Parity!=NoParity && S_B!=1)
    d88c:	41 30       	cpi	r20, 0x01	; 1
    d88e:	21 f0       	breq	.+8      	; 0xd898 <SetParity+0xa4>
		ewb(&MB_Param[MB_N].StopBits, 1);
    d890:	c8 01       	movw	r24, r16
    d892:	61 e0       	ldi	r22, 0x01	; 1
    d894:	0e 94 fd 4a 	call	0x95fa	; 0x95fa <ewb>
}
    d898:	df 91       	pop	r29
    d89a:	cf 91       	pop	r28
    d89c:	1f 91       	pop	r17
    d89e:	0f 91       	pop	r16
    d8a0:	ff 90       	pop	r15
    d8a2:	08 95       	ret
				break;
			}
		}
		else {
			ucsrc &=~(1<<3);
			switch (Parity) {
    d8a4:	56 e2       	ldi	r21, 0x26	; 38
    d8a6:	e0 cf       	rjmp	.-64     	; 0xd868 <SetParity+0x74>
    d8a8:	ce 01       	movw	r24, r28
    d8aa:	88 0f       	add	r24, r24
    d8ac:	99 1f       	adc	r25, r25
    d8ae:	88 0f       	add	r24, r24
    d8b0:	99 1f       	adc	r25, r25
    d8b2:	9c 01       	movw	r18, r24
    d8b4:	22 0f       	add	r18, r18
    d8b6:	33 1f       	adc	r19, r19
    d8b8:	22 0f       	add	r18, r18
    d8ba:	33 1f       	adc	r19, r19
    d8bc:	28 0f       	add	r18, r24
    d8be:	39 1f       	adc	r19, r25
    d8c0:	29 5e       	subi	r18, 0xE9	; 233
    d8c2:	33 4d       	sbci	r19, 0xD3	; 211
    d8c4:	f9 01       	movw	r30, r18
    d8c6:	a5 91       	lpm	r26, Z+
    d8c8:	b4 91       	lpm	r27, Z+
		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
			ucsrc  |=(1<<7);
		#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
			ucsrc &=~(1<<7);
		#endif
		USART_Reg(MB_N, ucsrc) = ucsrc;
    d8ca:	86 e0       	ldi	r24, 0x06	; 6
    d8cc:	8c 93       	st	X, r24
			}
		}
	#endif
	if (Parity!=NoParity && S_B!=1)
		ewb(&MB_Param[MB_N].StopBits, 1);
}
    d8ce:	df 91       	pop	r29
    d8d0:	cf 91       	pop	r28
    d8d2:	1f 91       	pop	r17
    d8d4:	0f 91       	pop	r16
    d8d6:	ff 90       	pop	r15
    d8d8:	08 95       	ret

0000d8da <Key_MB0_Parity>:
    d8da:	80 e0       	ldi	r24, 0x00	; 0
    d8dc:	0e 94 fa 6b 	call	0xd7f4	; 0xd7f4 <SetParity>
    d8e0:	08 95       	ret

0000d8e2 <MB_Init>:

// ~~~~~~~~~~
void
MB_Init(void)
{
	MB_PLC_Init();
    d8e2:	0e 94 47 1d 	call	0x3a8e	; 0x3a8e <MB_PLC_Init>
		PORTE.DIR |=(1<<3);
	#endif
	for (uint8_t MB_N=0; MB_N<Modbus_Qt; MB_N++) {
		void MB_S_Init(uint8_t);
		void MB_M_Init(uint8_t);
		MB_State[MB_N] = MB_Initi;
    d8e6:	10 92 ba 05 	sts	0x05BA, r1
    d8ea:	83 e1       	ldi	r24, 0x13	; 19
    d8ec:	9c e2       	ldi	r25, 0x2C	; 44
    d8ee:	fc 01       	movw	r30, r24
    d8f0:	a5 91       	lpm	r26, Z+
    d8f2:	b4 91       	lpm	r27, Z+
		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
			USART_Reg(MB_N, ucsra) = ~(1<<1) &~(1<<0);
    d8f4:	8c ef       	ldi	r24, 0xFC	; 252
    d8f6:	8c 93       	st	X, r24
    d8f8:	85 e1       	ldi	r24, 0x15	; 21
    d8fa:	9c e2       	ldi	r25, 0x2C	; 44
    d8fc:	fc 01       	movw	r30, r24
    d8fe:	a5 91       	lpm	r26, Z+
    d900:	b4 91       	lpm	r27, Z+
			USART_Reg(MB_N, ucsrb) = (((1<<7) &~(1<<6) &~(1<<5)) |(1<<4) |(1<<3)) &~(1<<2);
    d902:	88 e9       	ldi	r24, 0x98	; 152
    d904:	8c 93       	st	X, r24
			tc->CTRLD = TC_EVACT_OFF_gc;
			//tc->CTRLE = TC1_BYTEM_bm;
			tc->INTCTRLA |=TC_ERRINTLVL_OFF_gc;
			tc->INTCTRLB = 0;
		#endif
		SetParity(MB_N);
    d906:	80 e0       	ldi	r24, 0x00	; 0
    d908:	0e 94 fa 6b 	call	0xd7f4	; 0xd7f4 <SetParity>
		SetBAUD(MB_N);
    d90c:	80 e0       	ldi	r24, 0x00	; 0
    d90e:	0e 94 a7 6b 	call	0xd74e	; 0xd74e <SetBAUD>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    d912:	e5 e2       	ldi	r30, 0x25	; 37
    d914:	fc e2       	ldi	r31, 0x2C	; 44
    d916:	84 91       	lpm	r24, Z+
		switch (prb(MB_Role+MB_N)) {
    d918:	88 23       	and	r24, r24
    d91a:	59 f4       	brne	.+22     	; 0xd932 <MB_Init+0x50>
		case Role_Slave:
			MB_S_Init(MB_N);
    d91c:	80 e0       	ldi	r24, 0x00	; 0
    d91e:	0e 94 97 6b 	call	0xd72e	; 0xd72e <MB_S_Init>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    d922:	8a e2       	ldi	r24, 0x2A	; 42
    d924:	9c e2       	ldi	r25, 0x2C	; 44
    d926:	fc 01       	movw	r30, r24
    d928:	25 91       	lpm	r18, Z+
    d92a:	34 91       	lpm	r19, Z+
			break;
		case Role_Master:
			MB_M_Init(MB_N);
			break;
		}
		MB_StartTimer(MB_N);
    d92c:	f9 01       	movw	r30, r18
    d92e:	19 95       	eicall
	}
}
    d930:	08 95       	ret
			tc->INTCTRLA |=TC_ERRINTLVL_OFF_gc;
			tc->INTCTRLB = 0;
		#endif
		SetParity(MB_N);
		SetBAUD(MB_N);
		switch (prb(MB_Role+MB_N)) {
    d932:	81 30       	cpi	r24, 0x01	; 1
    d934:	b1 f7       	brne	.-20     	; 0xd922 <MB_Init+0x40>
		case Role_Slave:
			MB_S_Init(MB_N);
			break;
		case Role_Master:
			MB_M_Init(MB_N);
    d936:	80 e0       	ldi	r24, 0x00	; 0
    d938:	0e 94 46 6b 	call	0xd68c	; 0xd68c <MB_M_Init>
    d93c:	f2 cf       	rjmp	.-28     	; 0xd922 <MB_Init+0x40>

0000d93e <USART_Init>:

// ~~~~~~~~~~~~~
void
USART_Init(void)
{
	MB_Init();
    d93e:	0e 94 71 6c 	call	0xd8e2	; 0xd8e2 <MB_Init>
	#ifdef GSM
		GSM_Init();
    d942:	0e 94 65 38 	call	0x70ca	; 0x70ca <GSM_Init>
	#endif
	#ifdef UDP_EASY
		UDP_Init();
	#endif
}
    d946:	08 95       	ret

0000d948 <LCDBackLightStartTimer>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    d948:	81 e3       	ldi	r24, 0x31	; 49
    d94a:	91 e0       	ldi	r25, 0x01	; 1
    d94c:	0e 94 a4 7d 	call	0xfb48	; 0xfb48 <__eerd_byte_m2560>
			PORT_BACKLIGHT &= ~BACKLIGHT;
		#endif
		IntOn();
	}
	void LCDBackLightStartTimer(void){
		switch(erb(&BackLightTimeEE)){
    d950:	82 30       	cpi	r24, 0x02	; 2
    d952:	e9 f0       	breq	.+58     	; 0xd98e <LCDBackLightStartTimer+0x46>
    d954:	83 30       	cpi	r24, 0x03	; 3
    d956:	58 f0       	brcs	.+22     	; 0xd96e <LCDBackLightStartTimer+0x26>
    d958:	83 30       	cpi	r24, 0x03	; 3
    d95a:	01 f1       	breq	.+64     	; 0xd99c <LCDBackLightStartTimer+0x54>
    d95c:	84 30       	cpi	r24, 0x04	; 4
    d95e:	81 f0       	breq	.+32     	; 0xd980 <LCDBackLightStartTimer+0x38>
				break;	
			case BCKLT_10min:
				StartTimer16(TD_BackLight, 60000);
				break;
			default:
				StartTimer16(TD_BackLight, 3000);
    d960:	80 91 d0 04 	lds	r24, 0x04D0
    d964:	68 eb       	ldi	r22, 0xB8	; 184
    d966:	7b e0       	ldi	r23, 0x0B	; 11
    d968:	0e 94 1d 1a 	call	0x343a	; 0x343a <StartTimer16>
    d96c:	08 95       	ret
			PORT_BACKLIGHT &= ~BACKLIGHT;
		#endif
		IntOn();
	}
	void LCDBackLightStartTimer(void){
		switch(erb(&BackLightTimeEE)){
    d96e:	88 23       	and	r24, r24
    d970:	b9 f7       	brne	.-18     	; 0xd960 <LCDBackLightStartTimer+0x18>
			case BCKLT_10sec:
				StartTimer16(TD_BackLight, 1000);
    d972:	80 91 d0 04 	lds	r24, 0x04D0
    d976:	68 ee       	ldi	r22, 0xE8	; 232
    d978:	73 e0       	ldi	r23, 0x03	; 3
    d97a:	0e 94 1d 1a 	call	0x343a	; 0x343a <StartTimer16>
    d97e:	08 95       	ret
				break;
			case BCKLT_3min:
				StartTimer16(TD_BackLight, 18000);
				break;	
			case BCKLT_10min:
				StartTimer16(TD_BackLight, 60000);
    d980:	80 91 d0 04 	lds	r24, 0x04D0
    d984:	60 e6       	ldi	r22, 0x60	; 96
    d986:	7a ee       	ldi	r23, 0xEA	; 234
    d988:	0e 94 1d 1a 	call	0x343a	; 0x343a <StartTimer16>
    d98c:	08 95       	ret
				break;
			case BCKLT_30sec:
				StartTimer16(TD_BackLight, 3000);
				break;
			case BCKLT_1min:
				StartTimer16(TD_BackLight, 6000);
    d98e:	80 91 d0 04 	lds	r24, 0x04D0
    d992:	60 e7       	ldi	r22, 0x70	; 112
    d994:	77 e1       	ldi	r23, 0x17	; 23
    d996:	0e 94 1d 1a 	call	0x343a	; 0x343a <StartTimer16>
    d99a:	08 95       	ret
				break;
			case BCKLT_3min:
				StartTimer16(TD_BackLight, 18000);
    d99c:	80 91 d0 04 	lds	r24, 0x04D0
    d9a0:	60 e5       	ldi	r22, 0x50	; 80
    d9a2:	76 e4       	ldi	r23, 0x46	; 70
    d9a4:	0e 94 1d 1a 	call	0x343a	; 0x343a <StartTimer16>
    d9a8:	08 95       	ret

0000d9aa <LCDBackLightInit>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    d9aa:	9f b7       	in	r25, 0x3f	; 63
    d9ac:	90 78       	andi	r25, 0x80	; 128
    d9ae:	90 93 e6 02 	sts	0x02E6, r25
	cli();
    d9b2:	f8 94       	cli
	enum BACKLIGHT_TIMES{ BCKLT_10sec, BCKLT_30sec, BCKLT_1min,  BCKLT_3min,  BCKLT_10min};
	static uint8_t EEMEM BackLightTimeEE = BCKLT_10sec;

	void LCDBackLightInit(void){
		IntOff();	
		DDR_BACKLIGHT |= BACKLIGHT;
    d9b4:	80 91 0a 01 	lds	r24, 0x010A
    d9b8:	80 64       	ori	r24, 0x40	; 64
    d9ba:	80 93 0a 01 	sts	0x010A, r24

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    d9be:	99 23       	and	r25, r25
    d9c0:	09 f0       	breq	.+2      	; 0xd9c4 <LCDBackLightInit+0x1a>
		sei();
    d9c2:	78 94       	sei

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    d9c4:	80 91 cd 02 	lds	r24, 0x02CD
	VacantTimer16Sys += n;
    d9c8:	8f 5f       	subi	r24, 0xFF	; 255
    d9ca:	80 93 cd 02 	sts	0x02CD, r24
    d9ce:	81 50       	subi	r24, 0x01	; 1
		IntOn();	
		TD_BackLight = Timer16SysAlloc(1);
    d9d0:	80 93 d0 04 	sts	0x04D0, r24
		if(BackLightMode != 2){
    d9d4:	80 91 4a 06 	lds	r24, 0x064A
    d9d8:	82 30       	cpi	r24, 0x02	; 2
    d9da:	21 f0       	breq	.+8      	; 0xd9e4 <LCDBackLightInit+0x3a>
			LCDBackLightOn();
    d9dc:	0e 94 27 27 	call	0x4e4e	; 0x4e4e <LCDBackLightOn>
			LCDBackLightStartTimer();
    d9e0:	0e 94 a4 6c 	call	0xd948	; 0xd948 <LCDBackLightStartTimer>
    d9e4:	08 95       	ret

0000d9e6 <LCD_Init>:
}

// ~~~~~~~~~~~~
void
LCD_Init (void)
{
    d9e6:	ef 92       	push	r14
    d9e8:	ff 92       	push	r15
    d9ea:	1f 93       	push	r17
    d9ec:	cf 93       	push	r28
    d9ee:	df 93       	push	r29
	uint8_t i, j;

	// LCD pins
	#ifdef Port_LCD_RW
		Port_LCD_RW &= ~LCD_RW;
    d9f0:	43 98       	cbi	0x08, 3	; 8
		DDR_LCD_RW |= LCD_RW;
    d9f2:	3b 9a       	sbi	0x07, 3	; 7
	#endif

	Port_LCD_RS &= ~LCD_RS;	
    d9f4:	44 98       	cbi	0x08, 4	; 8
	DDR_LCD_RS |=LCD_RS;
    d9f6:	3c 9a       	sbi	0x07, 4	; 7

	Port_LCD_E &= ~LCD_E;	
    d9f8:	42 98       	cbi	0x08, 2	; 8
	DDR_LCD_E |=LCD_E;
    d9fa:	3a 9a       	sbi	0x07, 2	; 7

	#ifdef Port_LCD_DB0	
		DDR_LCD_DB0 |=DB0;
    d9fc:	39 9a       	sbi	0x07, 1	; 7
		DDR_LCD_DB1 |=DB1;
    d9fe:	38 9a       	sbi	0x07, 0	; 7
		DDR_LCD_DB2 |=DB2;
    da00:	99 9a       	sbi	0x13, 1	; 19
		DDR_LCD_DB3 |=DB3;
    da02:	98 9a       	sbi	0x13, 0	; 19
	#endif
	DDR_LCD_DB4 |=DB4;
    da04:	57 9a       	sbi	0x0a, 7	; 10
	DDR_LCD_DB5 |=DB5;
    da06:	56 9a       	sbi	0x0a, 6	; 10
	DDR_LCD_DB6 |=DB6;
    da08:	55 9a       	sbi	0x0a, 5	; 10
	DDR_LCD_DB7 |=DB7;
    da0a:	80 91 0a 01 	lds	r24, 0x010A
    da0e:	80 68       	ori	r24, 0x80	; 128
    da10:	80 93 0a 01 	sts	0x010A, r24
    da14:	21 e3       	ldi	r18, 0x31	; 49
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    da16:	40 ea       	ldi	r20, 0xA0	; 160
    da18:	5f e0       	ldi	r21, 0x0F	; 15
    da1a:	ca 01       	movw	r24, r20
    da1c:	01 97       	sbiw	r24, 0x01	; 1
    da1e:	f1 f7       	brne	.-4      	; 0xda1c <LCD_Init+0x36>

// ~~~~~~~~~~~~~~~~~~~~
void
Delay_ms(uint8_t Delay)
{
	while (Delay--)
    da20:	21 50       	subi	r18, 0x01	; 1
    da22:	d8 f7       	brcc	.-10     	; 0xda1a <LCD_Init+0x34>
#endif
// ~~~~~~~~~~~
static void
LCD_Rst0(void)
{
	cli();
    da24:	f8 94       	cli
	Port_LCD_RS &=~LCD_RS;
    da26:	44 98       	cbi	0x08, 4	; 8
	LCD_FuncSet0();
    da28:	0e 94 81 25 	call	0x4b02	; 0x4b02 <LCD_FuncSet0>
	sei();
    da2c:	78 94       	sei
    da2e:	80 ea       	ldi	r24, 0xA0	; 160
    da30:	9f e0       	ldi	r25, 0x0F	; 15
    da32:	fc 01       	movw	r30, r24
    da34:	31 97       	sbiw	r30, 0x01	; 1
    da36:	f1 f7       	brne	.-4      	; 0xda34 <LCD_Init+0x4e>
    da38:	fc 01       	movw	r30, r24
    da3a:	31 97       	sbiw	r30, 0x01	; 1
    da3c:	f1 f7       	brne	.-4      	; 0xda3a <LCD_Init+0x54>
    da3e:	fc 01       	movw	r30, r24
    da40:	31 97       	sbiw	r30, 0x01	; 1
    da42:	f1 f7       	brne	.-4      	; 0xda40 <LCD_Init+0x5a>
    da44:	fc 01       	movw	r30, r24
    da46:	31 97       	sbiw	r30, 0x01	; 1
    da48:	f1 f7       	brne	.-4      	; 0xda46 <LCD_Init+0x60>
    da4a:	01 97       	sbiw	r24, 0x01	; 1
    da4c:	f1 f7       	brne	.-4      	; 0xda4a <LCD_Init+0x64>

// ~~~~~~~~~~~
static void
LCD_Rst1(void)
{
	LCD_FuncSet0();
    da4e:	0e 94 81 25 	call	0x4b02	; 0x4b02 <LCD_FuncSet0>
	Delay_us(200);				// 100 us needs
    da52:	88 ec       	ldi	r24, 0xC8	; 200
    da54:	90 e0       	ldi	r25, 0x00	; 0
    da56:	0e 94 2f 1d 	call	0x3a5e	; 0x3a5e <Delay_us>
	LCD_FuncSet0();
    da5a:	0e 94 81 25 	call	0x4b02	; 0x4b02 <LCD_FuncSet0>
	Delay_us(LCD_Delay);
    da5e:	82 e3       	ldi	r24, 0x32	; 50
    da60:	90 e0       	ldi	r25, 0x00	; 0
    da62:	0e 94 2f 1d 	call	0x3a5e	; 0x3a5e <Delay_us>
	#ifdef Port_LCD_DB0	
		LCD_FuncSet0();
    da66:	0e 94 81 25 	call	0x4b02	; 0x4b02 <LCD_FuncSet0>
	#else
		LCD_FuncSet1();
	#endif
//// BF(Busy flag) can be checked follow
	Delay_us(LCD_Delay);
    da6a:	82 e3       	ldi	r24, 0x32	; 50
    da6c:	90 e0       	ldi	r25, 0x00	; 0
    da6e:	0e 94 2f 1d 	call	0x3a5e	; 0x3a5e <Delay_us>
	Port_LCD_RS |=LCD_RS;
    da72:	44 9a       	sbi	0x08, 4	; 8

	LCD_Rst0();
	Delay_ms(5);		// 4.1 ms needs
	LCD_Rst1();

	Port_LCD_RS &=~LCD_RS;
    da74:	44 98       	cbi	0x08, 4	; 8

	#ifdef Port_LCD_DB0	
		Send_I(0b00111000);	//; 8-bits DL, 2 lines, 5x7 dots
    da76:	88 e3       	ldi	r24, 0x38	; 56
    da78:	0e 94 7a 25 	call	0x4af4	; 0x4af4 <Send_I>
	#else
		Send_I(0b00101000);	//; 4-bits DL, 2 lines, 5x7 dots
	#endif
	Send_I(0b00001100);	//; Display on, cursor off, blink off	
    da7c:	8c e0       	ldi	r24, 0x0C	; 12
    da7e:	0e 94 7a 25 	call	0x4af4	; 0x4af4 <Send_I>
	Send_I(0b00000110);	//; cursor shift right, no display shift
    da82:	86 e0       	ldi	r24, 0x06	; 6
    da84:	0e 94 7a 25 	call	0x4af4	; 0x4af4 <Send_I>


	Send_I(0b01000000);	//;    CG RAM   0.
    da88:	80 e4       	ldi	r24, 0x40	; 64
    da8a:	0e 94 7a 25 	call	0x4af4	; 0x4af4 <Send_I>
	Port_LCD_RS |=LCD_RS;
    da8e:	44 9a       	sbi	0x08, 4	; 8
    da90:	78 e3       	ldi	r23, 0x38	; 56
    da92:	e7 2e       	mov	r14, r23
    da94:	7c e2       	ldi	r23, 0x2C	; 44
    da96:	f7 2e       	mov	r15, r23
	for (i=0; i<8; i++)
    da98:	e7 01       	movw	r28, r14
    da9a:	10 e0       	ldi	r17, 0x00	; 0

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    da9c:	fe 01       	movw	r30, r28
    da9e:	84 91       	lpm	r24, Z+
		for (j=0; j<8; j++)
			Send_I(prb(CGRAM_LCD[i]+j));
    daa0:	0e 94 7a 25 	call	0x4af4	; 0x4af4 <Send_I>


	Send_I(0b01000000);	//;    CG RAM   0.
	Port_LCD_RS |=LCD_RS;
	for (i=0; i<8; i++)
		for (j=0; j<8; j++)
    daa4:	1f 5f       	subi	r17, 0xFF	; 255
    daa6:	21 96       	adiw	r28, 0x01	; 1
    daa8:	18 30       	cpi	r17, 0x08	; 8
    daaa:	c1 f7       	brne	.-16     	; 0xda9c <LCD_Init+0xb6>
    daac:	88 e0       	ldi	r24, 0x08	; 8
    daae:	90 e0       	ldi	r25, 0x00	; 0
    dab0:	e8 0e       	add	r14, r24
    dab2:	f9 1e       	adc	r15, r25
	Send_I(0b00000110);	//; cursor shift right, no display shift


	Send_I(0b01000000);	//;    CG RAM   0.
	Port_LCD_RS |=LCD_RS;
	for (i=0; i<8; i++)
    dab4:	98 e7       	ldi	r25, 0x78	; 120
    dab6:	e9 16       	cp	r14, r25
    dab8:	9c e2       	ldi	r25, 0x2C	; 44
    daba:	f9 06       	cpc	r15, r25
    dabc:	69 f7       	brne	.-38     	; 0xda98 <LCD_Init+0xb2>
		for (j=0; j<8; j++)
			Send_I(prb(CGRAM_LCD[i]+j));

	Port_LCD_RS &=~LCD_RS;
    dabe:	44 98       	cbi	0x08, 4	; 8
	Send(0b00000001);
    dac0:	81 e0       	ldi	r24, 0x01	; 1
    dac2:	0e 94 39 25 	call	0x4a72	; 0x4a72 <Send>
    dac6:	80 ea       	ldi	r24, 0xA0	; 160
    dac8:	9f e0       	ldi	r25, 0x0F	; 15
    daca:	fc 01       	movw	r30, r24
    dacc:	31 97       	sbiw	r30, 0x01	; 1
    dace:	f1 f7       	brne	.-4      	; 0xdacc <LCD_Init+0xe6>
    dad0:	fc 01       	movw	r30, r24
    dad2:	31 97       	sbiw	r30, 0x01	; 1
    dad4:	f1 f7       	brne	.-4      	; 0xdad2 <LCD_Init+0xec>
    dad6:	fc 01       	movw	r30, r24
    dad8:	31 97       	sbiw	r30, 0x01	; 1
    dada:	f1 f7       	brne	.-4      	; 0xdad8 <LCD_Init+0xf2>
    dadc:	fc 01       	movw	r30, r24
    dade:	31 97       	sbiw	r30, 0x01	; 1
    dae0:	f1 f7       	brne	.-4      	; 0xdade <LCD_Init+0xf8>
    dae2:	01 97       	sbiw	r24, 0x01	; 1
    dae4:	f1 f7       	brne	.-4      	; 0xdae2 <LCD_Init+0xfc>
	Delay_ms(5);				// By trial
	Port_LCD_RS |=LCD_RS;
    dae6:	44 9a       	sbi	0x08, 4	; 8
}

uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    dae8:	80 91 cc 02 	lds	r24, 0x02CC
	VacantTimer8Sys += n;
    daec:	8f 5f       	subi	r24, 0xFF	; 255
    daee:	80 93 cc 02 	sts	0x02CC, r24
    daf2:	81 50       	subi	r24, 0x01	; 1

	// Frame Timer
	TD_LCD = Timer8SysAlloc(1);
    daf4:	80 93 cf 04 	sts	0x04CF, r24
    daf8:	20 e0       	ldi	r18, 0x00	; 0
    dafa:	30 e0       	ldi	r19, 0x00	; 0

	for (i=0; i<LCDYSz; i++)
		for (j=0; j<LCDXSz; j++)
			LCD_Buf[i][j] = ' ';
    dafc:	40 e2       	ldi	r20, 0x20	; 32
	Port_LCD_RS |=LCD_RS;

	// Frame Timer
	TD_LCD = Timer8SysAlloc(1);

	for (i=0; i<LCDYSz; i++)
    dafe:	c9 01       	movw	r24, r18
    db00:	88 0f       	add	r24, r24
    db02:	99 1f       	adc	r25, r25
    db04:	82 0f       	add	r24, r18
    db06:	93 1f       	adc	r25, r19
    db08:	fc 01       	movw	r30, r24
    db0a:	ee 0f       	add	r30, r30
    db0c:	ff 1f       	adc	r31, r31
    db0e:	ee 0f       	add	r30, r30
    db10:	ff 1f       	adc	r31, r31
    db12:	ee 0f       	add	r30, r30
    db14:	ff 1f       	adc	r31, r31
    db16:	e8 1b       	sub	r30, r24
    db18:	f9 0b       	sbc	r31, r25
    db1a:	e0 5b       	subi	r30, 0xB0	; 176
    db1c:	f9 4f       	sbci	r31, 0xF9	; 249
    db1e:	80 e0       	ldi	r24, 0x00	; 0
		for (j=0; j<LCDXSz; j++)
			LCD_Buf[i][j] = ' ';
    db20:	41 93       	st	Z+, r20

	// Frame Timer
	TD_LCD = Timer8SysAlloc(1);

	for (i=0; i<LCDYSz; i++)
		for (j=0; j<LCDXSz; j++)
    db22:	8f 5f       	subi	r24, 0xFF	; 255
    db24:	84 31       	cpi	r24, 0x14	; 20
    db26:	e1 f7       	brne	.-8      	; 0xdb20 <LCD_Init+0x13a>
    db28:	2f 5f       	subi	r18, 0xFF	; 255
    db2a:	3f 4f       	sbci	r19, 0xFF	; 255
	Port_LCD_RS |=LCD_RS;

	// Frame Timer
	TD_LCD = Timer8SysAlloc(1);

	for (i=0; i<LCDYSz; i++)
    db2c:	24 30       	cpi	r18, 0x04	; 4
    db2e:	31 05       	cpc	r19, r1
    db30:	31 f7       	brne	.-52     	; 0xdafe <LCD_Init+0x118>
		for (j=0; j<LCDXSz; j++)
			LCD_Buf[i][j] = ' ';

	#ifdef RTYP
		#ifndef QslRD
			*(uint8_t*)RTYP = R_PLC_Type;
    db32:	87 e0       	ldi	r24, 0x07	; 7
    db34:	80 93 43 08 	sts	0x0843, r24
		#endif	
	#endif

	#ifdef BACKLIGHT
		LCDBackLightInit();
    db38:	0e 94 d5 6c 	call	0xd9aa	; 0xd9aa <LCDBackLightInit>
	#endif
}
    db3c:	df 91       	pop	r29
    db3e:	cf 91       	pop	r28
    db40:	1f 91       	pop	r17
    db42:	ff 90       	pop	r15
    db44:	ef 90       	pop	r14
    db46:	08 95       	ret

0000db48 <RTC_Summer_Time>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    db48:	83 e0       	ldi	r24, 0x03	; 3
    db4a:	90 e0       	ldi	r25, 0x00	; 0
    db4c:	0e 94 a4 7d 	call	0xfb48	; 0xfb48 <__eerd_byte_m2560>
	
	return 0;
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void RTC_Summer_Time(void){
	if(erb(&SummerTime)){
    db50:	88 23       	and	r24, r24
    db52:	31 f0       	breq	.+12     	; 0xdb60 <RTC_Summer_Time+0x18>
		//   ()  02:00:00   03:00:00    
		if( (Tm_Mon == 3) && (Tm_WDay == 0) && (Tm_MDay>=25) && (Tm_Hour == 2) ){
    db54:	90 91 7f 07 	lds	r25, 0x077F
    db58:	93 30       	cpi	r25, 0x03	; 3
    db5a:	b1 f0       	breq	.+44     	; 0xdb88 <RTC_Summer_Time+0x40>
				Tm_Hour=3;
				SetHour();
		}

		//   ()  04:00:00   03:00:00    
		if( (Tm_Mon == 10) && (Tm_WDay == 0) && (Tm_MDay>=25) ){
    db5c:	9a 30       	cpi	r25, 0x0A	; 10
    db5e:	09 f0       	breq	.+2      	; 0xdb62 <RTC_Summer_Time+0x1a>
    db60:	08 95       	ret
    db62:	80 91 4f 06 	lds	r24, 0x064F
    db66:	88 23       	and	r24, r24
    db68:	d9 f7       	brne	.-10     	; 0xdb60 <RTC_Summer_Time+0x18>
    db6a:	80 91 11 0b 	lds	r24, 0x0B11
    db6e:	89 31       	cpi	r24, 0x19	; 25
    db70:	b8 f3       	brcs	.-18     	; 0xdb60 <RTC_Summer_Time+0x18>
				if(Tm_Hour == 4){
    db72:	80 91 b9 05 	lds	r24, 0x05B9
    db76:	84 30       	cpi	r24, 0x04	; 4
    db78:	d1 f0       	breq	.+52     	; 0xdbae <RTC_Summer_Time+0x66>
						Tm_Hour=3;
						SetHour();
						NotSummerTimeFlag = 1;
					}
				}
				if(Tm_Hour < 2) NotSummerTimeFlag = 0;
    db7a:	82 30       	cpi	r24, 0x02	; 2
    db7c:	38 f1       	brcs	.+78     	; 0xdbcc <RTC_Summer_Time+0x84>
				if(Tm_Hour >= 5) NotSummerTimeFlag = 0;
    db7e:	85 30       	cpi	r24, 0x05	; 5
    db80:	78 f3       	brcs	.-34     	; 0xdb60 <RTC_Summer_Time+0x18>
    db82:	10 92 d5 05 	sts	0x05D5, r1
    db86:	08 95       	ret
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void RTC_Summer_Time(void){
	if(erb(&SummerTime)){
		//   ()  02:00:00   03:00:00    
		if( (Tm_Mon == 3) && (Tm_WDay == 0) && (Tm_MDay>=25) && (Tm_Hour == 2) ){
    db88:	80 91 4f 06 	lds	r24, 0x064F
    db8c:	88 23       	and	r24, r24
    db8e:	41 f7       	brne	.-48     	; 0xdb60 <RTC_Summer_Time+0x18>
    db90:	80 91 11 0b 	lds	r24, 0x0B11
    db94:	89 31       	cpi	r24, 0x19	; 25
    db96:	20 f3       	brcs	.-56     	; 0xdb60 <RTC_Summer_Time+0x18>
    db98:	80 91 b9 05 	lds	r24, 0x05B9
    db9c:	82 30       	cpi	r24, 0x02	; 2
    db9e:	01 f7       	brne	.-64     	; 0xdb60 <RTC_Summer_Time+0x18>
				Tm_Hour=3;
    dba0:	90 93 b9 05 	sts	0x05B9, r25
				SetHour();
    dba4:	0e 94 0d 23 	call	0x461a	; 0x461a <SetHour>
    dba8:	90 91 7f 07 	lds	r25, 0x077F
    dbac:	d7 cf       	rjmp	.-82     	; 0xdb5c <RTC_Summer_Time+0x14>
		}

		//   ()  04:00:00   03:00:00    
		if( (Tm_Mon == 10) && (Tm_WDay == 0) && (Tm_MDay>=25) ){
				if(Tm_Hour == 4){
					if(!NotSummerTimeFlag){
    dbae:	80 91 d5 05 	lds	r24, 0x05D5
    dbb2:	88 23       	and	r24, r24
    dbb4:	a9 f6       	brne	.-86     	; 0xdb60 <RTC_Summer_Time+0x18>
						Tm_Hour=3;
    dbb6:	83 e0       	ldi	r24, 0x03	; 3
    dbb8:	80 93 b9 05 	sts	0x05B9, r24
						SetHour();
    dbbc:	0e 94 0d 23 	call	0x461a	; 0x461a <SetHour>
						NotSummerTimeFlag = 1;
    dbc0:	81 e0       	ldi	r24, 0x01	; 1
    dbc2:	80 93 d5 05 	sts	0x05D5, r24
    dbc6:	80 91 b9 05 	lds	r24, 0x05B9
    dbca:	d7 cf       	rjmp	.-82     	; 0xdb7a <RTC_Summer_Time+0x32>
					}
				}
				if(Tm_Hour < 2) NotSummerTimeFlag = 0;
    dbcc:	10 92 d5 05 	sts	0x05D5, r1
    dbd0:	d6 cf       	rjmp	.-84     	; 0xdb7e <RTC_Summer_Time+0x36>

0000dbd2 <TWI_In>:
}

// ~~~~~~~~~
void
TWI_In(void)
{
    dbd2:	cf 92       	push	r12
    dbd4:	ef 92       	push	r14
    dbd6:	0f 93       	push	r16
	if(Timer8Stopp(TD_TWI_Poll)){
    dbd8:	00 91 ca 04 	lds	r16, 0x04CA
    dbdc:	80 2f       	mov	r24, r16
    dbde:	0e 94 36 1b 	call	0x366c	; 0x366c <Timer8Stopp>
    dbe2:	88 23       	and	r24, r24
    dbe4:	e1 f0       	breq	.+56     	; 0xdc1e <TWI_In+0x4c>

		if (TWI_Phase == PCF_START){
    dbe6:	80 91 77 07 	lds	r24, 0x0777
    dbea:	88 23       	and	r24, r24
    dbec:	99 f1       	breq	.+102    	; 0xdc54 <TWI_In+0x82>
			StartTWI();		// Send Start
			TWI_Phase++;
			StartTimer8(TD_TWI_Timeout,40);
			return;
		}
		if(Timer8Stopp(TD_TWI_Timeout)){	// 
    dbee:	80 91 cb 04 	lds	r24, 0x04CB
    dbf2:	0e 94 36 1b 	call	0x366c	; 0x366c <Timer8Stopp>
    dbf6:	88 23       	and	r24, r24
    dbf8:	09 f0       	breq	.+2      	; 0xdbfc <TWI_In+0x2a>
    dbfa:	4e c0       	rjmp	.+156    	; 0xdc98 <TWI_In+0xc6>
			TWI_Error();
			return;
		}

		if (!(TWCR &(1<<TWINT))) return;
    dbfc:	80 91 bc 00 	lds	r24, 0x00BC
    dc00:	87 ff       	sbrs	r24, 7
    dc02:	33 c0       	rjmp	.+102    	; 0xdc6a <TWI_In+0x98>

		switch(TWI_Phase) {
    dc04:	40 91 77 07 	lds	r20, 0x0777
    dc08:	84 2f       	mov	r24, r20
    dc0a:	90 e0       	ldi	r25, 0x00	; 0
    dc0c:	fc 01       	movw	r30, r24
    dc0e:	31 97       	sbiw	r30, 0x01	; 1
    dc10:	e1 31       	cpi	r30, 0x11	; 17
    dc12:	f1 05       	cpc	r31, r1
    dc14:	08 f4       	brcc	.+2      	; 0xdc18 <TWI_In+0x46>
    dc16:	46 c0       	rjmp	.+140    	; 0xdca4 <TWI_In+0xd2>
			Tm_WDay = SetWeekday(Tm_Year, Tm_Mon, Tm_MDay);
			StartTimer8(TD_TWI_Poll, 49);
			TWI_Phase = 0xFF;
			break;
		}
		TWI_Phase++;
    dc18:	4f 5f       	subi	r20, 0xFF	; 255
    dc1a:	40 93 77 07 	sts	0x0777, r20
	}//Timer8Stopp(TD_TWI)

	if( Timer16Stopp(TD_RTC_Check) && (TWI_Phase == PCF_START) ){
    dc1e:	00 91 cc 04 	lds	r16, 0x04CC
    dc22:	80 2f       	mov	r24, r16
    dc24:	0e 94 59 1b 	call	0x36b2	; 0x36b2 <Timer16Stopp>
    dc28:	88 23       	and	r24, r24
    dc2a:	f9 f0       	breq	.+62     	; 0xdc6a <TWI_In+0x98>
    dc2c:	80 91 77 07 	lds	r24, 0x0777
    dc30:	88 23       	and	r24, r24
    dc32:	d9 f4       	brne	.+54     	; 0xdc6a <TWI_In+0x98>
		StartTimer16(TD_RTC_Check, 300);
    dc34:	80 2f       	mov	r24, r16
    dc36:	6c e2       	ldi	r22, 0x2C	; 44
    dc38:	71 e0       	ldi	r23, 0x01	; 1
    dc3a:	0e 94 1d 1a 	call	0x343a	; 0x343a <StartTimer16>
		if(RTC_Check() || PFC_Stop_bit){
    dc3e:	0e 94 32 24 	call	0x4864	; 0x4864 <RTC_Check>
    dc42:	88 23       	and	r24, r24
    dc44:	b1 f4       	brne	.+44     	; 0xdc72 <TWI_In+0xa0>
    dc46:	80 91 cd 04 	lds	r24, 0x04CD
    dc4a:	88 23       	and	r24, r24
    dc4c:	91 f4       	brne	.+36     	; 0xdc72 <TWI_In+0xa0>
			// RTC
			SetDateTime(TrueTime_Year, TrueTime_Mon, TrueTime_MDay, TrueTime_WDay, TrueTime_Hour, TrueTime_Min, TrueTime_Sec);
		}
		else RTC_GetTrueTime();
    dc4e:	0e 94 e9 23 	call	0x47d2	; 0x47d2 <RTC_GetTrueTime>
    dc52:	1f c0       	rjmp	.+62     	; 0xdc92 <TWI_In+0xc0>
TWI_In(void)
{
	if(Timer8Stopp(TD_TWI_Poll)){

		if (TWI_Phase == PCF_START){
			StartTWI();		// Send Start
    dc54:	84 ea       	ldi	r24, 0xA4	; 164
    dc56:	80 93 bc 00 	sts	0x00BC, r24
			TWI_Phase++;
    dc5a:	81 e0       	ldi	r24, 0x01	; 1
    dc5c:	80 93 77 07 	sts	0x0777, r24
			StartTimer8(TD_TWI_Timeout,40);
    dc60:	80 91 cb 04 	lds	r24, 0x04CB
    dc64:	68 e2       	ldi	r22, 0x28	; 40
    dc66:	0e 94 e2 19 	call	0x33c4	; 0x33c4 <StartTimer8>
		}
		else RTC_GetTrueTime();

		RTC_Summer_Time();
	}
}
    dc6a:	0f 91       	pop	r16
    dc6c:	ef 90       	pop	r14
    dc6e:	cf 90       	pop	r12
    dc70:	08 95       	ret

	if( Timer16Stopp(TD_RTC_Check) && (TWI_Phase == PCF_START) ){
		StartTimer16(TD_RTC_Check, 300);
		if(RTC_Check() || PFC_Stop_bit){
			// RTC
			SetDateTime(TrueTime_Year, TrueTime_Mon, TrueTime_MDay, TrueTime_WDay, TrueTime_Hour, TrueTime_Min, TrueTime_Sec);
    dc72:	80 91 75 07 	lds	r24, 0x0775
    dc76:	60 91 c7 08 	lds	r22, 0x08C7
    dc7a:	40 91 4e 06 	lds	r20, 0x064E
    dc7e:	20 91 10 0b 	lds	r18, 0x0B10
    dc82:	00 91 d0 05 	lds	r16, 0x05D0
    dc86:	e0 90 c8 08 	lds	r14, 0x08C8
    dc8a:	c0 90 c6 08 	lds	r12, 0x08C6
    dc8e:	0e 94 35 23 	call	0x466a	; 0x466a <SetDateTime>
		}
		else RTC_GetTrueTime();

		RTC_Summer_Time();
    dc92:	0e 94 a4 6d 	call	0xdb48	; 0xdb48 <RTC_Summer_Time>
    dc96:	e9 cf       	rjmp	.-46     	; 0xdc6a <TWI_In+0x98>
			Tm_Mon = DecodBCD(TWDR & 0b00011111);
			if(Tm_Mon > 12) Tm_Mon = 0;	//
			RunTWI();		//NACK
			break;
		case PCF_Year:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_NACK){ TWI_Error(); return;}
    dc98:	0e 94 6a 22 	call	0x44d4	; 0x44d4 <TWI_Error>
		}
		else RTC_GetTrueTime();

		RTC_Summer_Time();
	}
}
    dc9c:	0f 91       	pop	r16
    dc9e:	ef 90       	pop	r14
    dca0:	cf 90       	pop	r12
    dca2:	08 95       	ret
			return;
		}

		if (!(TWCR &(1<<TWINT))) return;

		switch(TWI_Phase) {
    dca4:	ec 5a       	subi	r30, 0xAC	; 172
    dca6:	fe 4f       	sbci	r31, 0xFE	; 254
    dca8:	ee 0f       	add	r30, r30
    dcaa:	ff 1f       	adc	r31, r31
    dcac:	05 90       	lpm	r0, Z+
    dcae:	f4 91       	lpm	r31, Z+
    dcb0:	e0 2d       	mov	r30, r0
    dcb2:	19 94       	eijmp
		case PFC_ACKN:
			AcknTWI();
			break;

		case PCF_Se:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
    dcb4:	80 91 b9 00 	lds	r24, 0x00B9
    dcb8:	88 7f       	andi	r24, 0xF8	; 248
    dcba:	80 35       	cpi	r24, 0x50	; 80
    dcbc:	69 f7       	brne	.-38     	; 0xdc98 <TWI_In+0xc6>
			Tm_Sec = DecodBCD(TWDR & 0b01111111);	// exclude ST bit
    dcbe:	20 91 bb 00 	lds	r18, 0x00BB
    dcc2:	82 2f       	mov	r24, r18
    dcc4:	8f 77       	andi	r24, 0x7F	; 127
    dcc6:	82 95       	swap	r24
    dcc8:	8f 70       	andi	r24, 0x0F	; 15
    dcca:	3a e0       	ldi	r19, 0x0A	; 10
    dccc:	83 9f       	mul	r24, r19
    dcce:	c0 01       	movw	r24, r0
    dcd0:	11 24       	eor	r1, r1
    dcd2:	2f 70       	andi	r18, 0x0F	; 15
    dcd4:	28 0f       	add	r18, r24
    dcd6:	20 93 ae 06 	sts	0x06AE, r18
			PFC_Stop_bit = TWDR & 0b10000000;
    dcda:	80 91 bb 00 	lds	r24, 0x00BB
    dcde:	80 78       	andi	r24, 0x80	; 128
    dce0:	80 93 cd 04 	sts	0x04CD, r24
/*			if(PFC_Stop_bit) NoTickCnt++;
			else NoTickCnt=0;*/
			AcknTWI();
    dce4:	84 ec       	ldi	r24, 0xC4	; 196
    dce6:	80 93 bc 00 	sts	0x00BC, r24
    dcea:	96 cf       	rjmp	.-212    	; 0xdc18 <TWI_In+0x46>

		case PCF_REAP_START1:
			StartTWI();
			break;
		case PCF_CHECK_REAP_START1:
			if( (TWSR & 0b11111000) != TWI_STATUS_RP_START){ TWI_Error(); return;}
    dcec:	80 91 b9 00 	lds	r24, 0x00B9
    dcf0:	88 7f       	andi	r24, 0xF8	; 248
    dcf2:	80 31       	cpi	r24, 0x10	; 16
    dcf4:	89 f6       	brne	.-94     	; 0xdc98 <TWI_In+0xc6>
    dcf6:	48 e0       	ldi	r20, 0x08	; 8
			else TWI_Phase++;

		case PCF_SLA_R:
			SLA_R(PCF_SLA);
    dcf8:	81 ed       	ldi	r24, 0xD1	; 209
    dcfa:	80 93 bb 00 	sts	0x00BB, r24
			RunTWI();
    dcfe:	84 e8       	ldi	r24, 0x84	; 132
    dd00:	80 93 bc 00 	sts	0x00BC, r24
    dd04:	89 cf       	rjmp	.-238    	; 0xdc18 <TWI_In+0x46>
		case PCF_Addr:
			TWDR = AddrSec;
			RunTWI();
			break;
		case PCF_CHECK_Addr:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATATX_ACK){ TWI_Error(); return;}
    dd06:	80 91 b9 00 	lds	r24, 0x00B9
    dd0a:	88 7f       	andi	r24, 0xF8	; 248
    dd0c:	88 32       	cpi	r24, 0x28	; 40
    dd0e:	21 f6       	brne	.-120    	; 0xdc98 <TWI_In+0xc6>
    dd10:	46 e0       	ldi	r20, 0x06	; 6
			else TWI_Phase++;

		case PCF_REAP_START1:
			StartTWI();
    dd12:	84 ea       	ldi	r24, 0xA4	; 164
    dd14:	80 93 bc 00 	sts	0x00BC, r24
    dd18:	7f cf       	rjmp	.-258    	; 0xdc18 <TWI_In+0x46>
		case PCF_SLA_W:
			SLA_W(PCF_SLA);
			RunTWI();
			break;
		case PCF_CHECK_SLA_W:
			if( (TWSR & 0b11111000) != TWI_STATUS_SLAW_ACK){ TWI_Error(); return;}
    dd1a:	80 91 b9 00 	lds	r24, 0x00B9
    dd1e:	88 7f       	andi	r24, 0xF8	; 248
    dd20:	88 31       	cpi	r24, 0x18	; 24
    dd22:	09 f0       	breq	.+2      	; 0xdd26 <TWI_In+0x154>
    dd24:	b9 cf       	rjmp	.-142    	; 0xdc98 <TWI_In+0xc6>
    dd26:	44 e0       	ldi	r20, 0x04	; 4
			else TWI_Phase++;

		case PCF_Addr:
			TWDR = AddrSec;
    dd28:	10 92 bb 00 	sts	0x00BB, r1
			RunTWI();
    dd2c:	84 e8       	ldi	r24, 0x84	; 132
    dd2e:	80 93 bc 00 	sts	0x00BC, r24
    dd32:	72 cf       	rjmp	.-284    	; 0xdc18 <TWI_In+0x46>
		if (!(TWCR &(1<<TWINT))) return;

		switch(TWI_Phase) {
		
		case PCF_CHECK_START:
			if( (TWSR & 0b11111000) != TWI_STATUS_START){ TWI_Error(); return;}
    dd34:	80 91 b9 00 	lds	r24, 0x00B9
    dd38:	88 7f       	andi	r24, 0xF8	; 248
    dd3a:	88 30       	cpi	r24, 0x08	; 8
    dd3c:	09 f0       	breq	.+2      	; 0xdd40 <TWI_In+0x16e>
    dd3e:	ac cf       	rjmp	.-168    	; 0xdc98 <TWI_In+0xc6>
    dd40:	42 e0       	ldi	r20, 0x02	; 2
			else TWI_Phase++;
			
		case PCF_SLA_W:
			SLA_W(PCF_SLA);
    dd42:	80 ed       	ldi	r24, 0xD0	; 208
    dd44:	80 93 bb 00 	sts	0x00BB, r24
			RunTWI();
    dd48:	84 e8       	ldi	r24, 0x84	; 132
    dd4a:	80 93 bc 00 	sts	0x00BC, r24
    dd4e:	64 cf       	rjmp	.-312    	; 0xdc18 <TWI_In+0x46>
		case PCF_SLA_R:
			SLA_R(PCF_SLA);
			RunTWI();
			break;
		case PCF_CHECK_SLA_R:
			if( (TWSR & 0b11111000) != TWI_STATUS_SLAR_ACK){ TWI_Error(); return;}
    dd50:	80 91 b9 00 	lds	r24, 0x00B9
    dd54:	88 7f       	andi	r24, 0xF8	; 248
    dd56:	80 34       	cpi	r24, 0x40	; 64
    dd58:	09 f0       	breq	.+2      	; 0xdd5c <TWI_In+0x18a>
    dd5a:	9e cf       	rjmp	.-196    	; 0xdc98 <TWI_In+0xc6>
    dd5c:	4a e0       	ldi	r20, 0x0A	; 10
    dd5e:	c2 cf       	rjmp	.-124    	; 0xdce4 <TWI_In+0x112>
			Tm_Mon = DecodBCD(TWDR & 0b00011111);
			if(Tm_Mon > 12) Tm_Mon = 0;	//
			RunTWI();		//NACK
			break;
		case PCF_Year:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_NACK){ TWI_Error(); return;}
    dd60:	80 91 b9 00 	lds	r24, 0x00B9
    dd64:	88 7f       	andi	r24, 0xF8	; 248
    dd66:	88 35       	cpi	r24, 0x58	; 88
    dd68:	09 f0       	breq	.+2      	; 0xdd6c <TWI_In+0x19a>
    dd6a:	96 cf       	rjmp	.-212    	; 0xdc98 <TWI_In+0xc6>
			Tm_Year = DecodBCD(TWDR);
    dd6c:	80 91 bb 00 	lds	r24, 0x00BB

// ~~~~~~~~~~~~~~~~~~
uint8_t
DecodBCD(uint8_t BCD)
{
	return 10*(BCD>>4)+(BCD&0x0F);
    dd70:	28 2f       	mov	r18, r24
    dd72:	22 95       	swap	r18
    dd74:	2f 70       	andi	r18, 0x0F	; 15
    dd76:	9a e0       	ldi	r25, 0x0A	; 10
    dd78:	29 9f       	mul	r18, r25
    dd7a:	90 01       	movw	r18, r0
    dd7c:	11 24       	eor	r1, r1
    dd7e:	8f 70       	andi	r24, 0x0F	; 15
    dd80:	82 0f       	add	r24, r18
    dd82:	80 93 d6 05 	sts	0x05D6, r24
			StopTWI();
    dd86:	94 e9       	ldi	r25, 0x94	; 148
    dd88:	90 93 bc 00 	sts	0x00BC, r25
			Tm_WDay = SetWeekday(Tm_Year, Tm_Mon, Tm_MDay);
    dd8c:	60 91 7f 07 	lds	r22, 0x077F
    dd90:	40 91 11 0b 	lds	r20, 0x0B11
    dd94:	0e 94 cd 22 	call	0x459a	; 0x459a <SetWeekday>
    dd98:	80 93 4f 06 	sts	0x064F, r24
			StartTimer8(TD_TWI_Poll, 49);
    dd9c:	80 2f       	mov	r24, r16
    dd9e:	61 e3       	ldi	r22, 0x31	; 49
    dda0:	0e 94 e2 19 	call	0x33c4	; 0x33c4 <StartTimer8>
    dda4:	4f ef       	ldi	r20, 0xFF	; 255
    dda6:	38 cf       	rjmp	.-400    	; 0xdc18 <TWI_In+0x46>
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
			Tm_MDay = DecodBCD(TWDR & 0b00111111);
			AcknTWI();
			break;
		case PCF_Mo:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
    dda8:	80 91 b9 00 	lds	r24, 0x00B9
    ddac:	88 7f       	andi	r24, 0xF8	; 248
    ddae:	80 35       	cpi	r24, 0x50	; 80
    ddb0:	09 f0       	breq	.+2      	; 0xddb4 <TWI_In+0x1e2>
    ddb2:	72 cf       	rjmp	.-284    	; 0xdc98 <TWI_In+0xc6>
			Tm_Mon = DecodBCD(TWDR & 0b00011111);
    ddb4:	80 91 bb 00 	lds	r24, 0x00BB
    ddb8:	28 2f       	mov	r18, r24
    ddba:	2f 71       	andi	r18, 0x1F	; 31
    ddbc:	22 95       	swap	r18
    ddbe:	2f 70       	andi	r18, 0x0F	; 15
    ddc0:	9a e0       	ldi	r25, 0x0A	; 10
    ddc2:	29 9f       	mul	r18, r25
    ddc4:	90 01       	movw	r18, r0
    ddc6:	11 24       	eor	r1, r1
    ddc8:	8f 70       	andi	r24, 0x0F	; 15
    ddca:	82 0f       	add	r24, r18
    ddcc:	80 93 7f 07 	sts	0x077F, r24
			if(Tm_Mon > 12) Tm_Mon = 0;	//
    ddd0:	8d 30       	cpi	r24, 0x0D	; 13
    ddd2:	10 f0       	brcs	.+4      	; 0xddd8 <TWI_In+0x206>
    ddd4:	10 92 7f 07 	sts	0x077F, r1
			RunTWI();		//NACK
    ddd8:	84 e8       	ldi	r24, 0x84	; 132
    ddda:	80 93 bc 00 	sts	0x00BC, r24
    ddde:	1c cf       	rjmp	.-456    	; 0xdc18 <TWI_In+0x46>
			TWDR;
			//Tm_WDay = DecodBCD(TWDR & 0b00000111); Ignore 
			AcknTWI();
			break;
		case PCF_MDay:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
    dde0:	80 91 b9 00 	lds	r24, 0x00B9
    dde4:	88 7f       	andi	r24, 0xF8	; 248
    dde6:	80 35       	cpi	r24, 0x50	; 80
    dde8:	09 f0       	breq	.+2      	; 0xddec <TWI_In+0x21a>
    ddea:	56 cf       	rjmp	.-340    	; 0xdc98 <TWI_In+0xc6>
			Tm_MDay = DecodBCD(TWDR & 0b00111111);
    ddec:	20 91 bb 00 	lds	r18, 0x00BB
    ddf0:	82 2f       	mov	r24, r18
    ddf2:	8f 73       	andi	r24, 0x3F	; 63
    ddf4:	82 95       	swap	r24
    ddf6:	8f 70       	andi	r24, 0x0F	; 15
    ddf8:	3a e0       	ldi	r19, 0x0A	; 10
    ddfa:	83 9f       	mul	r24, r19
    ddfc:	c0 01       	movw	r24, r0
    ddfe:	11 24       	eor	r1, r1
    de00:	2f 70       	andi	r18, 0x0F	; 15
    de02:	28 0f       	add	r18, r24
    de04:	20 93 11 0b 	sts	0x0B11, r18
			AcknTWI();
    de08:	84 ec       	ldi	r24, 0xC4	; 196
    de0a:	80 93 bc 00 	sts	0x00BC, r24
    de0e:	04 cf       	rjmp	.-504    	; 0xdc18 <TWI_In+0x46>
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
			Tm_Hour = DecodBCD(TWDR & 0b00111111);
			AcknTWI();
			break;
		case PCF_WDay:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
    de10:	80 91 b9 00 	lds	r24, 0x00B9
    de14:	88 7f       	andi	r24, 0xF8	; 248
    de16:	80 35       	cpi	r24, 0x50	; 80
    de18:	09 f0       	breq	.+2      	; 0xde1c <TWI_In+0x24a>
    de1a:	3e cf       	rjmp	.-388    	; 0xdc98 <TWI_In+0xc6>
			TWDR;
    de1c:	80 91 bb 00 	lds	r24, 0x00BB
			//Tm_WDay = DecodBCD(TWDR & 0b00000111); Ignore 
			AcknTWI();
    de20:	84 ec       	ldi	r24, 0xC4	; 196
    de22:	80 93 bc 00 	sts	0x00BC, r24
    de26:	f8 ce       	rjmp	.-528    	; 0xdc18 <TWI_In+0x46>
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
			Tm_Min = DecodBCD(TWDR & 0b01111111);
			AcknTWI();
			break;
		case PCF_Ho:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
    de28:	80 91 b9 00 	lds	r24, 0x00B9
    de2c:	88 7f       	andi	r24, 0xF8	; 248
    de2e:	80 35       	cpi	r24, 0x50	; 80
    de30:	09 f0       	breq	.+2      	; 0xde34 <TWI_In+0x262>
    de32:	32 cf       	rjmp	.-412    	; 0xdc98 <TWI_In+0xc6>
			Tm_Hour = DecodBCD(TWDR & 0b00111111);
    de34:	20 91 bb 00 	lds	r18, 0x00BB
    de38:	82 2f       	mov	r24, r18
    de3a:	8f 73       	andi	r24, 0x3F	; 63
    de3c:	82 95       	swap	r24
    de3e:	8f 70       	andi	r24, 0x0F	; 15
    de40:	3a e0       	ldi	r19, 0x0A	; 10
    de42:	83 9f       	mul	r24, r19
    de44:	c0 01       	movw	r24, r0
    de46:	11 24       	eor	r1, r1
    de48:	2f 70       	andi	r18, 0x0F	; 15
    de4a:	28 0f       	add	r18, r24
    de4c:	20 93 b9 05 	sts	0x05B9, r18
			AcknTWI();
    de50:	84 ec       	ldi	r24, 0xC4	; 196
    de52:	80 93 bc 00 	sts	0x00BC, r24
    de56:	e0 ce       	rjmp	.-576    	; 0xdc18 <TWI_In+0x46>
/*			if(PFC_Stop_bit) NoTickCnt++;
			else NoTickCnt=0;*/
			AcknTWI();
			break;
		case PCF_Mi:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
    de58:	80 91 b9 00 	lds	r24, 0x00B9
    de5c:	88 7f       	andi	r24, 0xF8	; 248
    de5e:	80 35       	cpi	r24, 0x50	; 80
    de60:	09 f0       	breq	.+2      	; 0xde64 <TWI_In+0x292>
    de62:	1a cf       	rjmp	.-460    	; 0xdc98 <TWI_In+0xc6>
			Tm_Min = DecodBCD(TWDR & 0b01111111);
    de64:	20 91 bb 00 	lds	r18, 0x00BB
    de68:	82 2f       	mov	r24, r18
    de6a:	8f 77       	andi	r24, 0x7F	; 127
    de6c:	82 95       	swap	r24
    de6e:	8f 70       	andi	r24, 0x0F	; 15
    de70:	3a e0       	ldi	r19, 0x0A	; 10
    de72:	83 9f       	mul	r24, r19
    de74:	c0 01       	movw	r24, r0
    de76:	11 24       	eor	r1, r1
    de78:	2f 70       	andi	r18, 0x0F	; 15
    de7a:	28 0f       	add	r18, r24
    de7c:	20 93 49 06 	sts	0x0649, r18
			AcknTWI();
    de80:	84 ec       	ldi	r24, 0xC4	; 196
    de82:	80 93 bc 00 	sts	0x00BC, r24
    de86:	c8 ce       	rjmp	.-624    	; 0xdc18 <TWI_In+0x46>

0000de88 <TimeInit>:

// ~~~~~~~~
void
WdtOn(void)
{
	wdt_reset();
    de88:	a8 95       	wdr
	wdt_enable(WDTO_2S);
    de8a:	2f e0       	ldi	r18, 0x0F	; 15
    de8c:	88 e1       	ldi	r24, 0x18	; 24
    de8e:	90 e0       	ldi	r25, 0x00	; 0
    de90:	0f b6       	in	r0, 0x3f	; 63
    de92:	f8 94       	cli
    de94:	a8 95       	wdr
    de96:	80 93 60 00 	sts	0x0060, r24
    de9a:	0f be       	out	0x3f, r0	; 63
    de9c:	20 93 60 00 	sts	0x0060, r18

	// WDT
	WdtOn();

	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TCCR1A = 0;
    dea0:	10 92 80 00 	sts	0x0080, r1
		TCCR1B = (((~(1<<WGM13) |(1<<WGM12)) &~(1<<CS12)) |(1<<CS11)) &~(1<<CS10);
    dea4:	8a ee       	ldi	r24, 0xEA	; 234
    dea6:	80 93 81 00 	sts	0x0081, r24
		OCR1A = 20000;
    deaa:	80 e2       	ldi	r24, 0x20	; 32
    deac:	9e e4       	ldi	r25, 0x4E	; 78
    deae:	90 93 89 00 	sts	0x0089, r25
    deb2:	80 93 88 00 	sts	0x0088, r24
		TCC0.CTRLE = ~TC0_BYTEM_bm;
	#endif
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__)
		TIMSK |=(1<<OCIE1A);
	#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TIMSK1 |=(1<<OCIE1A);
    deb6:	80 91 6f 00 	lds	r24, 0x006F
    deba:	82 60       	ori	r24, 0x02	; 2
    debc:	80 93 6f 00 	sts	0x006F, r24
    dec0:	80 e0       	ldi	r24, 0x00	; 0
    dec2:	90 e0       	ldi	r25, 0x00	; 0
	#endif

	// Program timers (10 ms)
	uint8_t i;
	for (i=0; i<sizeof(Timer8Flg); i++)
		Timer8Flg[i] = 0xFF;
    dec4:	2f ef       	ldi	r18, 0xFF	; 255
    dec6:	fc 01       	movw	r30, r24
    dec8:	e7 55       	subi	r30, 0x57	; 87
    deca:	fb 4f       	sbci	r31, 0xFB	; 251
    decc:	20 83       	st	Z, r18
    dece:	01 96       	adiw	r24, 0x01	; 1
		TCC0.INTCTRLB = 0;
	#endif

	// Program timers (10 ms)
	uint8_t i;
	for (i=0; i<sizeof(Timer8Flg); i++)
    ded0:	8c 30       	cpi	r24, 0x0C	; 12
    ded2:	91 05       	cpc	r25, r1
    ded4:	c1 f7       	brne	.-16     	; 0xdec6 <TimeInit+0x3e>
    ded6:	80 e0       	ldi	r24, 0x00	; 0
    ded8:	90 e0       	ldi	r25, 0x00	; 0
		Timer8Flg[i] = 0xFF;
	for (i=0; i<sizeof(Timer16Flg); i++)
		Timer16Flg[i] = 0xFF;
    deda:	3f ef       	ldi	r19, 0xFF	; 255
    dedc:	fc 01       	movw	r30, r24
    dede:	eb 54       	subi	r30, 0x4B	; 75
    dee0:	fb 4f       	sbci	r31, 0xFB	; 251
    dee2:	2f ef       	ldi	r18, 0xFF	; 255
    dee4:	30 83       	st	Z, r19
    dee6:	01 96       	adiw	r24, 0x01	; 1

	// Program timers (10 ms)
	uint8_t i;
	for (i=0; i<sizeof(Timer8Flg); i++)
		Timer8Flg[i] = 0xFF;
	for (i=0; i<sizeof(Timer16Flg); i++)
    dee8:	8d 30       	cpi	r24, 0x0D	; 13
    deea:	91 05       	cpc	r25, r1
    deec:	b9 f7       	brne	.-18     	; 0xdedc <TimeInit+0x54>
		Timer16Flg[i] = 0xFF;
	for (i=0; i<sizeof(Timer32Flg); i++)
		Timer32Flg[i] = 0xFF;
    deee:	20 93 c2 04 	sts	0x04C2, r18
    def2:	20 93 c3 04 	sts	0x04C3, r18
    def6:	20 93 c4 04 	sts	0x04C4, r18
    defa:	20 93 c5 04 	sts	0x04C5, r18
    defe:	20 93 c6 04 	sts	0x04C6, r18
    df02:	20 93 c7 04 	sts	0x04C7, r18
    df06:	8d e3       	ldi	r24, 0x3D	; 61
    df08:	91 e0       	ldi	r25, 0x01	; 1
    df0a:	0e 94 a4 7d 	call	0xfb48	; 0xfb48 <__eerd_byte_m2560>

	// 1 s
	Timer1min = erb(&Timer1min_EE);
    df0e:	80 93 a8 06 	sts	0x06A8, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    df12:	8e e3       	ldi	r24, 0x3E	; 62
    df14:	91 e0       	ldi	r25, 0x01	; 1
    df16:	0e 94 b2 7d 	call	0xfb64	; 0xfb64 <__eerd_word_m2560>
	Timer1hour = erw(&Timer1hour_EE);
    df1a:	90 93 1e 0c 	sts	0x0C1E, r25
    df1e:	80 93 1d 0c 	sts	0x0C1D, r24

	// Application
	#ifdef InitTimer
		StartTimer16(InitTimer, InitTime);
	#endif
}
    df22:	08 95       	ret

0000df24 <MemCheckInit>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    df24:	8c e3       	ldi	r24, 0x3C	; 60
    df26:	91 e0       	ldi	r25, 0x01	; 1
    df28:	0e 94 a4 7d 	call	0xfb48	; 0xfb48 <__eerd_byte_m2560>
// ~~~~~~~~~~~~~~~
void
MemCheckInit(void)
{
//	TD_Mem = Timer32SysAlloc(1);
	if (!erb(&MemCheck_stor.ReprogFlg)) {
    df2c:	81 11       	cpse	r24, r1
    df2e:	08 95       	ret
		eeprom_write_word(&MemCheck_stor.CRC_Flash_stor, CRC_Flash_calc());
    df30:	0e 94 de 18 	call	0x31bc	; 0x31bc <CRC_Flash_calc>
    df34:	bc 01       	movw	r22, r24
    df36:	88 e3       	ldi	r24, 0x38	; 56
    df38:	91 e0       	ldi	r25, 0x01	; 1
    df3a:	0e 94 d8 7d 	call	0xfbb0	; 0xfbb0 <__eewr_word_m2560>
		eeprom_write_word(&MemCheck_stor.CRC_EEPROM_stor, CRC_EEPROM_calc());
    df3e:	0e 94 f8 18 	call	0x31f0	; 0x31f0 <CRC_EEPROM_calc>
    df42:	bc 01       	movw	r22, r24
    df44:	8a e3       	ldi	r24, 0x3A	; 58
    df46:	91 e0       	ldi	r25, 0x01	; 1
    df48:	0e 94 d8 7d 	call	0xfbb0	; 0xfbb0 <__eewr_word_m2560>
		eeprom_write_byte(&MemCheck_stor.ReprogFlg, 1);
    df4c:	8c e3       	ldi	r24, 0x3C	; 60
    df4e:	91 e0       	ldi	r25, 0x01	; 1
    df50:	61 e0       	ldi	r22, 0x01	; 1
    df52:	0e 94 c2 7d 	call	0xfb84	; 0xfb84 <__eewr_byte_m2560>
    df56:	08 95       	ret

0000df58 <main>:
}

// ~~~~~~~
int
main(void)
{
    df58:	cf 93       	push	r28
    df5a:	df 93       	push	r29
	TimeInit();
    df5c:	0e 94 44 6f 	call	0xde88	; 0xde88 <TimeInit>
	TimersInc();
    df60:	0e 94 68 4b 	call	0x96d0	; 0x96d0 <TimersInc>
	MemCheckInit();
    df64:	0e 94 92 6f 	call	0xdf24	; 0xdf24 <MemCheckInit>
	LED_Init();
    df68:	0e 94 0b 25 	call	0x4a16	; 0x4a16 <LED_Init>

	LCD_Init();
    df6c:	0e 94 f3 6c 	call	0xd9e6	; 0xd9e6 <LCD_Init>

	KeypadInit();
    df70:	0e 94 b2 3a 	call	0x7564	; 0x7564 <KeypadInit>
	MenuInit();
    df74:	0e 94 00 3c 	call	0x7800	; 0x7800 <MenuInit>
InterruInit(void)
{
	#ifdef PMIC
		PMIC.CTRL = (uint8_t)(~PMIC_RREN_bm &~PMIC_IVSEL_bm) |PMIC_HILVLEN_bm |PMIC_MEDLVLEN_bm |PMIC_LOLVLEN_bm;
	#endif
	sei();
    df78:	78 94       	sei
	InterruInit();
	DigitInit();
    df7a:	0e 94 23 3d 	call	0x7a46	; 0x7a46 <DI_Init>
    df7e:	0e 94 32 3e 	call	0x7c64	; 0x7c64 <DO_Init>
	HSC_Init();

	AI_Init();
    df82:	0e 94 47 3e 	call	0x7c8e	; 0x7c8e <AI_Init>

	SPI_Init();
    df86:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <SPI_Init>

	PWM_Init();
    df8a:	0e 94 5f 1d 	call	0x3abe	; 0x3abe <PWM_Init>
	TWI_Init();
    df8e:	0e 94 4e 22 	call	0x449c	; 0x449c <TWI_Init>
#ifdef QslRD
	SlaveRD_Init();
#endif

	do {
		TimersInc();
    df92:	0e 94 68 4b 	call	0x96d0	; 0x96d0 <TimersInc>
		wdt_reset();
    df96:	a8 95       	wdr
		DigitIn();
    df98:	0e 94 76 4e 	call	0x9cec	; 0x9cec <DigitIn>
		TWI_In();
    df9c:	0e 94 e9 6d 	call	0xdbd2	; 0xdbd2 <TWI_In>
	StopTWI();
	TWI_Phase = PCF_START;
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t RTC_Ready(void){
	if(TWI_Phase == PCF_START) return 1;
    dfa0:	80 91 77 07 	lds	r24, 0x0777
    dfa4:	88 23       	and	r24, r24
    dfa6:	11 f4       	brne	.+4      	; 0xdfac <main+0x54>
		if(RTC_Ready()) RTC_GetTrueTime();
    dfa8:	0e 94 e9 23 	call	0x47d2	; 0x47d2 <RTC_GetTrueTime>
		LCD_Sweep();
    dfac:	0e 94 37 60 	call	0xc06e	; 0xc06e <LCD_Sweep>
	#ifdef TerIdx
	} while(ThermInit(AnalogIn()-TerIdx) || !RTC_Ready());
	#elif !defined ADC_Miss
		AnalogIn();
    dfb0:	0e 94 58 3e 	call	0x7cb0	; 0x7cb0 <AnalogIn>
	} while( (ADC_OK&&ThermInit(ADC_In())) || !RTC_Ready() );
    dfb4:	80 91 dd 08 	lds	r24, 0x08DD
    dfb8:	90 91 de 08 	lds	r25, 0x08DE
    dfbc:	89 2b       	or	r24, r25
    dfbe:	69 f4       	brne	.+26     	; 0xdfda <main+0x82>
    dfc0:	80 91 6a 07 	lds	r24, 0x076A
    dfc4:	90 91 6b 07 	lds	r25, 0x076B
    dfc8:	89 2b       	or	r24, r25
    dfca:	39 f4       	brne	.+14     	; 0xdfda <main+0x82>
    dfcc:	80 91 af 06 	lds	r24, 0x06AF
    dfd0:	90 91 b0 06 	lds	r25, 0x06B0
    dfd4:	89 2b       	or	r24, r25
    dfd6:	09 f4       	brne	.+2      	; 0xdfda <main+0x82>
    dfd8:	68 c0       	rjmp	.+208    	; 0xe0aa <main+0x152>
    dfda:	80 91 77 07 	lds	r24, 0x0777
    dfde:	88 23       	and	r24, r24
    dfe0:	c1 f6       	brne	.-80     	; 0xdf92 <main+0x3a>
	#else
	} while((AnalogIn()!=AI_Reg-1) || !RTC_Ready());
	#endif

	MemCheckMsg();
    dfe2:	0e 94 66 4d 	call	0x9acc	; 0x9acc <MemCheckMsg>

	ApplInit();

	USART_Init();
    dfe6:	0e 94 9f 6c 	call	0xd93e	; 0xd93e <USART_Init>
	ScanCycleInit();
    dfea:	0e 94 a3 1c 	call	0x3946	; 0x3946 <ScanCycleInit>
	if(TimerAllocError()) ShowMsg(&MsgErr41);
    dfee:	0e 94 87 1c 	call	0x390e	; 0x390e <TimerAllocError>
    dff2:	88 23       	and	r24, r24
    dff4:	09 f0       	breq	.+2      	; 0xdff8 <main+0xa0>
    dff6:	61 c0       	rjmp	.+194    	; 0xe0ba <main+0x162>

// ~~~~~~~~~~~~~~~~
void
Therm_ADC_Off(void)
{
	for (uint8_t i=0; i<TerReg; Temperature[i++]=ADC_Off_Mark);
    dff8:	c1 e0       	ldi	r28, 0x01	; 1
    dffa:	d0 e8       	ldi	r29, 0x80	; 128
    dffc:	10 c0       	rjmp	.+32     	; 0xe01e <main+0xc6>
			if(ADC_Work&&ADC_Phase==ADC_OFF) {
				Therm_ADC_Off();
				ShowMsg(&MsgErr21);
				ADC_Work = 0;
			}
			ThermChan(ADC_In());
    dffe:	0e 94 ea 1d 	call	0x3bd4	; 0x3bd4 <ADC_In>
    e002:	0e 94 98 4d 	call	0x9b30	; 0x9b30 <ThermChan>
		#endif
		ThermExt();
		TWI_In();
    e006:	0e 94 e9 6d 	call	0xdbd2	; 0xdbd2 <TWI_In>

		USART_Cycle();
    e00a:	0e 94 14 6b 	call	0xd628	; 0xd628 <USART_Cycle>
#ifdef QslRD
		SlaveRD();
#endif
		ApplCycle();
		
		LCD_Sweep();
    e00e:	0e 94 37 60 	call	0xc06e	; 0xc06e <LCD_Sweep>
		DigitOut();
    e012:	0e 94 e3 3d 	call	0x7bc6	; 0x7bc6 <DigitOut>
		DAC_Out();
		PWM_Out();
    e016:	0e 94 7e 1d 	call	0x3afc	; 0x3afc <PWM_Out>
		#ifdef BACKLIGHT
			LCDBackLightControl();
    e01a:	0e 94 43 27 	call	0x4e86	; 0x4e86 <LCDBackLightControl>
	USART_Init();
	ScanCycleInit();
	if(TimerAllocError()) ShowMsg(&MsgErr41);

	for(;;) {	
		TimersInc();
    e01e:	0e 94 68 4b 	call	0x96d0	; 0x96d0 <TimersInc>
		TimeCycle();
    e022:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <TimeCycle>
// ~~~~~~~~~~~~~~
static void
KeypadSweep(void)
{
	static T_KeyAct KeyAct[] PROGMEM = KEYS;
	T_KeyAct KA = prp(KeyAct+KeypadIn());
    e026:	0e 94 c5 3a 	call	0x758a	; 0x758a <KeypadIn>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    e02a:	e8 2f       	mov	r30, r24
    e02c:	f0 e0       	ldi	r31, 0x00	; 0
    e02e:	ee 0f       	add	r30, r30
    e030:	ff 1f       	adc	r31, r31
    e032:	e6 54       	subi	r30, 0x46	; 70
    e034:	f6 4d       	sbci	r31, 0xD6	; 214
    e036:	85 91       	lpm	r24, Z+
    e038:	94 91       	lpm	r25, Z+
	if(KA){
    e03a:	00 97       	sbiw	r24, 0x00	; 0
    e03c:	31 f0       	breq	.+12     	; 0xe04a <main+0xf2>
		KA();
    e03e:	fc 01       	movw	r30, r24
    e040:	19 95       	eicall
		#ifdef BACKLIGHT
			if(BackLightMode == 1){
    e042:	80 91 4a 06 	lds	r24, 0x064A
    e046:	81 30       	cpi	r24, 0x01	; 1
    e048:	59 f1       	breq	.+86     	; 0xe0a0 <main+0x148>
	for(;;) {	
		TimersInc();
		TimeCycle();

		KeypadSweep();
		DigitIn();
    e04a:	0e 94 76 4e 	call	0x9cec	; 0x9cec <DigitIn>
		HSC_In();
		#ifdef TerIdx
			ThermChan(AnalogIn()-TerIdx);
		#else
			AnalogIn();
    e04e:	0e 94 58 3e 	call	0x7cb0	; 0x7cb0 <AnalogIn>
		#endif
		#if !defined ADC_Miss && !defined TerIdx
			static uint8_t ADC_Work = 1;
			if(ADC_Work&&ADC_Phase==ADC_OFF) {
    e052:	80 91 d5 02 	lds	r24, 0x02D5
    e056:	88 23       	and	r24, r24
    e058:	91 f2       	breq	.-92     	; 0xdffe <main+0xa6>
    e05a:	80 91 1c 0b 	lds	r24, 0x0B1C
    e05e:	84 30       	cpi	r24, 0x04	; 4
    e060:	71 f6       	brne	.-100    	; 0xdffe <main+0xa6>
    e062:	d0 93 3e 06 	sts	0x063E, r29
    e066:	c0 93 3d 06 	sts	0x063D, r28
    e06a:	d0 93 40 06 	sts	0x0640, r29
    e06e:	c0 93 3f 06 	sts	0x063F, r28
    e072:	d0 93 42 06 	sts	0x0642, r29
    e076:	c0 93 41 06 	sts	0x0641, r28
    e07a:	d0 93 44 06 	sts	0x0644, r29
    e07e:	c0 93 43 06 	sts	0x0643, r28
    e082:	d0 93 46 06 	sts	0x0646, r29
    e086:	c0 93 45 06 	sts	0x0645, r28
    e08a:	d0 93 48 06 	sts	0x0648, r29
    e08e:	c0 93 47 06 	sts	0x0647, r28
				Therm_ADC_Off();
				ShowMsg(&MsgErr21);
    e092:	8d e6       	ldi	r24, 0x6D	; 109
    e094:	98 e0       	ldi	r25, 0x08	; 8
    e096:	0e 94 ef 3b 	call	0x77de	; 0x77de <ShowMsg>
				ADC_Work = 0;
    e09a:	10 92 d5 02 	sts	0x02D5, r1
    e09e:	af cf       	rjmp	.-162    	; 0xdffe <main+0xa6>
	T_KeyAct KA = prp(KeyAct+KeypadIn());
	if(KA){
		KA();
		#ifdef BACKLIGHT
			if(BackLightMode == 1){
				LCDBackLightOn();
    e0a0:	0e 94 27 27 	call	0x4e4e	; 0x4e4e <LCDBackLightOn>
				LCDBackLightStartTimer();
    e0a4:	0e 94 a4 6c 	call	0xd948	; 0xd948 <LCDBackLightStartTimer>
    e0a8:	d0 cf       	rjmp	.-96     	; 0xe04a <main+0xf2>
		LCD_Sweep();
	#ifdef TerIdx
	} while(ThermInit(AnalogIn()-TerIdx) || !RTC_Ready());
	#elif !defined ADC_Miss
		AnalogIn();
	} while( (ADC_OK&&ThermInit(ADC_In())) || !RTC_Ready() );
    e0aa:	0e 94 ea 1d 	call	0x3bd4	; 0x3bd4 <ADC_In>
    e0ae:	0e 94 34 4e 	call	0x9c68	; 0x9c68 <ThermInit>
    e0b2:	88 23       	and	r24, r24
    e0b4:	09 f0       	breq	.+2      	; 0xe0b8 <main+0x160>
    e0b6:	6d cf       	rjmp	.-294    	; 0xdf92 <main+0x3a>
    e0b8:	90 cf       	rjmp	.-224    	; 0xdfda <main+0x82>

	ApplInit();

	USART_Init();
	ScanCycleInit();
	if(TimerAllocError()) ShowMsg(&MsgErr41);
    e0ba:	82 e2       	ldi	r24, 0x22	; 34
    e0bc:	9a e1       	ldi	r25, 0x1A	; 26
    e0be:	0e 94 ef 3b 	call	0x77de	; 0x77de <ShowMsg>
    e0c2:	9a cf       	rjmp	.-204    	; 0xdff8 <main+0xa0>

0000e0c4 <EEMEMBackUpOk>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    e0c4:	80 e0       	ldi	r24, 0x00	; 0
    e0c6:	90 e0       	ldi	r25, 0x00	; 0
    e0c8:	0e 94 a4 7d 	call	0xfb48	; 0xfb48 <__eerd_byte_m2560>
	uint8_t Month;
	uint8_t Year;
}DateBackUp EEMEM = {0xFF,0xFF,0xFF};

uint8_t EEMEMBackUpOk(void){
	if( (erb(&DateBackUp.Day)==0xFF) || (erb(&DateBackUp.Month)==0xFF) || (erb(&DateBackUp.Year)== 0xFF) ) return 0;
    e0cc:	8f 3f       	cpi	r24, 0xFF	; 255
    e0ce:	81 f0       	breq	.+32     	; 0xe0f0 <EEMEMBackUpOk+0x2c>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    e0d0:	81 e0       	ldi	r24, 0x01	; 1
    e0d2:	90 e0       	ldi	r25, 0x00	; 0
    e0d4:	0e 94 a4 7d 	call	0xfb48	; 0xfb48 <__eerd_byte_m2560>
	uint8_t Month;
	uint8_t Year;
}DateBackUp EEMEM = {0xFF,0xFF,0xFF};

uint8_t EEMEMBackUpOk(void){
	if( (erb(&DateBackUp.Day)==0xFF) || (erb(&DateBackUp.Month)==0xFF) || (erb(&DateBackUp.Year)== 0xFF) ) return 0;
    e0d8:	8f 3f       	cpi	r24, 0xFF	; 255
    e0da:	51 f0       	breq	.+20     	; 0xe0f0 <EEMEMBackUpOk+0x2c>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    e0dc:	82 e0       	ldi	r24, 0x02	; 2
    e0de:	90 e0       	ldi	r25, 0x00	; 0
    e0e0:	0e 94 a4 7d 	call	0xfb48	; 0xfb48 <__eerd_byte_m2560>
    e0e4:	90 e0       	ldi	r25, 0x00	; 0
    e0e6:	8f 3f       	cpi	r24, 0xFF	; 255
    e0e8:	21 f0       	breq	.+8      	; 0xe0f2 <EEMEMBackUpOk+0x2e>
    e0ea:	91 e0       	ldi	r25, 0x01	; 1
}DateBackUp EEMEM = {0xFF,0xFF,0xFF};

uint8_t EEMEMBackUpOk(void){
	if( (erb(&DateBackUp.Day)==0xFF) || (erb(&DateBackUp.Month)==0xFF) || (erb(&DateBackUp.Year)== 0xFF) ) return 0;
	else return 1;
}
    e0ec:	89 2f       	mov	r24, r25
    e0ee:	08 95       	ret
	uint8_t Month;
	uint8_t Year;
}DateBackUp EEMEM = {0xFF,0xFF,0xFF};

uint8_t EEMEMBackUpOk(void){
	if( (erb(&DateBackUp.Day)==0xFF) || (erb(&DateBackUp.Month)==0xFF) || (erb(&DateBackUp.Year)== 0xFF) ) return 0;
    e0f0:	90 e0       	ldi	r25, 0x00	; 0
	else return 1;
}
    e0f2:	89 2f       	mov	r24, r25
    e0f4:	08 95       	ret

0000e0f6 <Menu_BackUp_Enter>:
			NULL, NULL, NULL, Menu_ConfirmationRest_Enter, NULL, NULL, NULL};
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	//		  
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	uint8_t Menu_BackUp_Enter(){
		switch(CurrLine){
    e0f6:	80 91 7d 07 	lds	r24, 0x077D
    e0fa:	82 30       	cpi	r24, 0x02	; 2
    e0fc:	11 f0       	breq	.+4      	; 0xe102 <Menu_BackUp_Enter+0xc>
			}
			NextPage = &Menu_ConfirmationRestore;
			break;
		}
		return StandartKey;
	}
    e0fe:	80 e0       	ldi	r24, 0x00	; 0
    e100:	08 95       	ret
	//		  
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	uint8_t Menu_BackUp_Enter(){
		switch(CurrLine){
		case 2:
			if(!EEMEMBackUpOk()){
    e102:	0e 94 62 70 	call	0xe0c4	; 0xe0c4 <EEMEMBackUpOk>
    e106:	88 23       	and	r24, r24
    e108:	59 f4       	brne	.+22     	; 0xe120 <Menu_BackUp_Enter+0x2a>
				//   EEPROM,   BackUp- -  
				if(MemFail & 1<<MemFail_EEPROM){
    e10a:	80 91 c9 08 	lds	r24, 0x08C9
    e10e:	81 ff       	sbrs	r24, 1
    e110:	0f c0       	rjmp	.+30     	; 0xe130 <Menu_BackUp_Enter+0x3a>
					MemFailReset();
    e112:	0e 94 d8 4a 	call	0x95b0	; 0x95b0 <MemFailReset>
					ShowMsg(&Msg_EEWarning);
    e116:	8e e2       	ldi	r24, 0x2E	; 46
    e118:	93 e1       	ldi	r25, 0x13	; 19
    e11a:	0e 94 ef 3b 	call	0x77de	; 0x77de <ShowMsg>
    e11e:	ef cf       	rjmp	.-34     	; 0xe0fe <Menu_BackUp_Enter+0x8>
				}
				else ShowMsg(&Msg_NoBackUp);
				break;
			}
			NextPage = &Menu_ConfirmationRestore;
    e120:	8e ed       	ldi	r24, 0xDE	; 222
    e122:	94 e1       	ldi	r25, 0x14	; 20
    e124:	90 93 d2 05 	sts	0x05D2, r25
    e128:	80 93 d1 05 	sts	0x05D1, r24
			break;
		}
		return StandartKey;
	}
    e12c:	80 e0       	ldi	r24, 0x00	; 0
    e12e:	08 95       	ret
				//   EEPROM,   BackUp- -  
				if(MemFail & 1<<MemFail_EEPROM){
					MemFailReset();
					ShowMsg(&Msg_EEWarning);
				}
				else ShowMsg(&Msg_NoBackUp);
    e130:	80 e9       	ldi	r24, 0x90	; 144
    e132:	93 e1       	ldi	r25, 0x13	; 19
    e134:	0e 94 ef 3b 	call	0x77de	; 0x77de <ShowMsg>
    e138:	e2 cf       	rjmp	.-60     	; 0xe0fe <Menu_BackUp_Enter+0x8>

0000e13a <vfprintf>:
    e13a:	2f 92       	push	r2
    e13c:	3f 92       	push	r3
    e13e:	4f 92       	push	r4
    e140:	5f 92       	push	r5
    e142:	6f 92       	push	r6
    e144:	7f 92       	push	r7
    e146:	8f 92       	push	r8
    e148:	9f 92       	push	r9
    e14a:	af 92       	push	r10
    e14c:	bf 92       	push	r11
    e14e:	cf 92       	push	r12
    e150:	df 92       	push	r13
    e152:	ef 92       	push	r14
    e154:	ff 92       	push	r15
    e156:	0f 93       	push	r16
    e158:	1f 93       	push	r17
    e15a:	df 93       	push	r29
    e15c:	cf 93       	push	r28
    e15e:	cd b7       	in	r28, 0x3d	; 61
    e160:	de b7       	in	r29, 0x3e	; 62
    e162:	61 97       	sbiw	r28, 0x11	; 17
    e164:	0f b6       	in	r0, 0x3f	; 63
    e166:	f8 94       	cli
    e168:	de bf       	out	0x3e, r29	; 62
    e16a:	0f be       	out	0x3f, r0	; 63
    e16c:	cd bf       	out	0x3d, r28	; 61
    e16e:	3c 01       	movw	r6, r24
    e170:	7f 87       	std	Y+15, r23	; 0x0f
    e172:	6e 87       	std	Y+14, r22	; 0x0e
    e174:	6a 01       	movw	r12, r20
    e176:	fc 01       	movw	r30, r24
    e178:	17 82       	std	Z+7, r1	; 0x07
    e17a:	16 82       	std	Z+6, r1	; 0x06
    e17c:	83 81       	ldd	r24, Z+3	; 0x03
    e17e:	81 fd       	sbrc	r24, 1
    e180:	03 c0       	rjmp	.+6      	; 0xe188 <vfprintf+0x4e>
    e182:	6f ef       	ldi	r22, 0xFF	; 255
    e184:	7f ef       	ldi	r23, 0xFF	; 255
    e186:	6f c3       	rjmp	.+1758   	; 0xe866 <vfprintf+0x72c>
    e188:	9e 01       	movw	r18, r28
    e18a:	2f 5f       	subi	r18, 0xFF	; 255
    e18c:	3f 4f       	sbci	r19, 0xFF	; 255
    e18e:	39 8b       	std	Y+17, r19	; 0x11
    e190:	28 8b       	std	Y+16, r18	; 0x10
    e192:	f3 01       	movw	r30, r6
    e194:	23 81       	ldd	r18, Z+3	; 0x03
    e196:	ee 85       	ldd	r30, Y+14	; 0x0e
    e198:	ff 85       	ldd	r31, Y+15	; 0x0f
    e19a:	23 fd       	sbrc	r18, 3
    e19c:	85 91       	lpm	r24, Z+
    e19e:	23 ff       	sbrs	r18, 3
    e1a0:	81 91       	ld	r24, Z+
    e1a2:	ff 87       	std	Y+15, r31	; 0x0f
    e1a4:	ee 87       	std	Y+14, r30	; 0x0e
    e1a6:	88 23       	and	r24, r24
    e1a8:	09 f4       	brne	.+2      	; 0xe1ac <vfprintf+0x72>
    e1aa:	5a c3       	rjmp	.+1716   	; 0xe860 <vfprintf+0x726>
    e1ac:	85 32       	cpi	r24, 0x25	; 37
    e1ae:	51 f4       	brne	.+20     	; 0xe1c4 <vfprintf+0x8a>
    e1b0:	ee 85       	ldd	r30, Y+14	; 0x0e
    e1b2:	ff 85       	ldd	r31, Y+15	; 0x0f
    e1b4:	23 fd       	sbrc	r18, 3
    e1b6:	85 91       	lpm	r24, Z+
    e1b8:	23 ff       	sbrs	r18, 3
    e1ba:	81 91       	ld	r24, Z+
    e1bc:	ff 87       	std	Y+15, r31	; 0x0f
    e1be:	ee 87       	std	Y+14, r30	; 0x0e
    e1c0:	85 32       	cpi	r24, 0x25	; 37
    e1c2:	29 f4       	brne	.+10     	; 0xe1ce <vfprintf+0x94>
    e1c4:	90 e0       	ldi	r25, 0x00	; 0
    e1c6:	b3 01       	movw	r22, r6
    e1c8:	0e 94 4a 7b 	call	0xf694	; 0xf694 <fputc>
    e1cc:	e2 cf       	rjmp	.-60     	; 0xe192 <vfprintf+0x58>
    e1ce:	98 2f       	mov	r25, r24
    e1d0:	10 e0       	ldi	r17, 0x00	; 0
    e1d2:	88 24       	eor	r8, r8
    e1d4:	99 24       	eor	r9, r9
    e1d6:	10 32       	cpi	r17, 0x20	; 32
    e1d8:	b0 f4       	brcc	.+44     	; 0xe206 <vfprintf+0xcc>
    e1da:	9b 32       	cpi	r25, 0x2B	; 43
    e1dc:	69 f0       	breq	.+26     	; 0xe1f8 <vfprintf+0xbe>
    e1de:	9c 32       	cpi	r25, 0x2C	; 44
    e1e0:	28 f4       	brcc	.+10     	; 0xe1ec <vfprintf+0xb2>
    e1e2:	90 32       	cpi	r25, 0x20	; 32
    e1e4:	51 f0       	breq	.+20     	; 0xe1fa <vfprintf+0xc0>
    e1e6:	93 32       	cpi	r25, 0x23	; 35
    e1e8:	71 f4       	brne	.+28     	; 0xe206 <vfprintf+0xcc>
    e1ea:	0b c0       	rjmp	.+22     	; 0xe202 <vfprintf+0xc8>
    e1ec:	9d 32       	cpi	r25, 0x2D	; 45
    e1ee:	39 f0       	breq	.+14     	; 0xe1fe <vfprintf+0xc4>
    e1f0:	90 33       	cpi	r25, 0x30	; 48
    e1f2:	49 f4       	brne	.+18     	; 0xe206 <vfprintf+0xcc>
    e1f4:	11 60       	ori	r17, 0x01	; 1
    e1f6:	28 c0       	rjmp	.+80     	; 0xe248 <vfprintf+0x10e>
    e1f8:	12 60       	ori	r17, 0x02	; 2
    e1fa:	14 60       	ori	r17, 0x04	; 4
    e1fc:	25 c0       	rjmp	.+74     	; 0xe248 <vfprintf+0x10e>
    e1fe:	18 60       	ori	r17, 0x08	; 8
    e200:	23 c0       	rjmp	.+70     	; 0xe248 <vfprintf+0x10e>
    e202:	10 61       	ori	r17, 0x10	; 16
    e204:	21 c0       	rjmp	.+66     	; 0xe248 <vfprintf+0x10e>
    e206:	17 fd       	sbrc	r17, 7
    e208:	2a c0       	rjmp	.+84     	; 0xe25e <vfprintf+0x124>
    e20a:	89 2f       	mov	r24, r25
    e20c:	80 53       	subi	r24, 0x30	; 48
    e20e:	8a 30       	cpi	r24, 0x0A	; 10
    e210:	78 f4       	brcc	.+30     	; 0xe230 <vfprintf+0xf6>
    e212:	16 ff       	sbrs	r17, 6
    e214:	06 c0       	rjmp	.+12     	; 0xe222 <vfprintf+0xe8>
    e216:	fa e0       	ldi	r31, 0x0A	; 10
    e218:	9f 9e       	mul	r9, r31
    e21a:	90 2c       	mov	r9, r0
    e21c:	11 24       	eor	r1, r1
    e21e:	98 0e       	add	r9, r24
    e220:	13 c0       	rjmp	.+38     	; 0xe248 <vfprintf+0x10e>
    e222:	3a e0       	ldi	r19, 0x0A	; 10
    e224:	83 9e       	mul	r8, r19
    e226:	80 2c       	mov	r8, r0
    e228:	11 24       	eor	r1, r1
    e22a:	88 0e       	add	r8, r24
    e22c:	10 62       	ori	r17, 0x20	; 32
    e22e:	0c c0       	rjmp	.+24     	; 0xe248 <vfprintf+0x10e>
    e230:	9e 32       	cpi	r25, 0x2E	; 46
    e232:	21 f4       	brne	.+8      	; 0xe23c <vfprintf+0x102>
    e234:	16 fd       	sbrc	r17, 6
    e236:	14 c3       	rjmp	.+1576   	; 0xe860 <vfprintf+0x726>
    e238:	10 64       	ori	r17, 0x40	; 64
    e23a:	06 c0       	rjmp	.+12     	; 0xe248 <vfprintf+0x10e>
    e23c:	9c 36       	cpi	r25, 0x6C	; 108
    e23e:	11 f4       	brne	.+4      	; 0xe244 <vfprintf+0x10a>
    e240:	10 68       	ori	r17, 0x80	; 128
    e242:	02 c0       	rjmp	.+4      	; 0xe248 <vfprintf+0x10e>
    e244:	98 36       	cpi	r25, 0x68	; 104
    e246:	59 f4       	brne	.+22     	; 0xe25e <vfprintf+0x124>
    e248:	ee 85       	ldd	r30, Y+14	; 0x0e
    e24a:	ff 85       	ldd	r31, Y+15	; 0x0f
    e24c:	23 fd       	sbrc	r18, 3
    e24e:	95 91       	lpm	r25, Z+
    e250:	23 ff       	sbrs	r18, 3
    e252:	91 91       	ld	r25, Z+
    e254:	ff 87       	std	Y+15, r31	; 0x0f
    e256:	ee 87       	std	Y+14, r30	; 0x0e
    e258:	99 23       	and	r25, r25
    e25a:	09 f0       	breq	.+2      	; 0xe25e <vfprintf+0x124>
    e25c:	bc cf       	rjmp	.-136    	; 0xe1d6 <vfprintf+0x9c>
    e25e:	89 2f       	mov	r24, r25
    e260:	85 54       	subi	r24, 0x45	; 69
    e262:	83 30       	cpi	r24, 0x03	; 3
    e264:	20 f4       	brcc	.+8      	; 0xe26e <vfprintf+0x134>
    e266:	81 2f       	mov	r24, r17
    e268:	80 61       	ori	r24, 0x10	; 16
    e26a:	90 5e       	subi	r25, 0xE0	; 224
    e26c:	07 c0       	rjmp	.+14     	; 0xe27c <vfprintf+0x142>
    e26e:	89 2f       	mov	r24, r25
    e270:	85 56       	subi	r24, 0x65	; 101
    e272:	83 30       	cpi	r24, 0x03	; 3
    e274:	08 f0       	brcs	.+2      	; 0xe278 <vfprintf+0x13e>
    e276:	9f c1       	rjmp	.+830    	; 0xe5b6 <vfprintf+0x47c>
    e278:	81 2f       	mov	r24, r17
    e27a:	8f 7e       	andi	r24, 0xEF	; 239
    e27c:	86 fd       	sbrc	r24, 6
    e27e:	02 c0       	rjmp	.+4      	; 0xe284 <vfprintf+0x14a>
    e280:	76 e0       	ldi	r23, 0x06	; 6
    e282:	97 2e       	mov	r9, r23
    e284:	6f e3       	ldi	r22, 0x3F	; 63
    e286:	f6 2e       	mov	r15, r22
    e288:	f8 22       	and	r15, r24
    e28a:	95 36       	cpi	r25, 0x65	; 101
    e28c:	19 f4       	brne	.+6      	; 0xe294 <vfprintf+0x15a>
    e28e:	f0 e4       	ldi	r31, 0x40	; 64
    e290:	ff 2a       	or	r15, r31
    e292:	07 c0       	rjmp	.+14     	; 0xe2a2 <vfprintf+0x168>
    e294:	96 36       	cpi	r25, 0x66	; 102
    e296:	19 f4       	brne	.+6      	; 0xe29e <vfprintf+0x164>
    e298:	20 e8       	ldi	r18, 0x80	; 128
    e29a:	f2 2a       	or	r15, r18
    e29c:	02 c0       	rjmp	.+4      	; 0xe2a2 <vfprintf+0x168>
    e29e:	91 10       	cpse	r9, r1
    e2a0:	9a 94       	dec	r9
    e2a2:	f7 fe       	sbrs	r15, 7
    e2a4:	0a c0       	rjmp	.+20     	; 0xe2ba <vfprintf+0x180>
    e2a6:	3b e3       	ldi	r19, 0x3B	; 59
    e2a8:	39 15       	cp	r19, r9
    e2aa:	18 f4       	brcc	.+6      	; 0xe2b2 <vfprintf+0x178>
    e2ac:	5c e3       	ldi	r21, 0x3C	; 60
    e2ae:	b5 2e       	mov	r11, r21
    e2b0:	02 c0       	rjmp	.+4      	; 0xe2b6 <vfprintf+0x17c>
    e2b2:	b9 2c       	mov	r11, r9
    e2b4:	b3 94       	inc	r11
    e2b6:	27 e0       	ldi	r18, 0x07	; 7
    e2b8:	09 c0       	rjmp	.+18     	; 0xe2cc <vfprintf+0x192>
    e2ba:	47 e0       	ldi	r20, 0x07	; 7
    e2bc:	49 15       	cp	r20, r9
    e2be:	20 f4       	brcc	.+8      	; 0xe2c8 <vfprintf+0x18e>
    e2c0:	bb 24       	eor	r11, r11
    e2c2:	47 e0       	ldi	r20, 0x07	; 7
    e2c4:	94 2e       	mov	r9, r20
    e2c6:	f7 cf       	rjmp	.-18     	; 0xe2b6 <vfprintf+0x17c>
    e2c8:	29 2d       	mov	r18, r9
    e2ca:	bb 24       	eor	r11, r11
    e2cc:	c6 01       	movw	r24, r12
    e2ce:	04 96       	adiw	r24, 0x04	; 4
    e2d0:	9d 87       	std	Y+13, r25	; 0x0d
    e2d2:	8c 87       	std	Y+12, r24	; 0x0c
    e2d4:	f6 01       	movw	r30, r12
    e2d6:	60 81       	ld	r22, Z
    e2d8:	71 81       	ldd	r23, Z+1	; 0x01
    e2da:	82 81       	ldd	r24, Z+2	; 0x02
    e2dc:	93 81       	ldd	r25, Z+3	; 0x03
    e2de:	ae 01       	movw	r20, r28
    e2e0:	4f 5f       	subi	r20, 0xFF	; 255
    e2e2:	5f 4f       	sbci	r21, 0xFF	; 255
    e2e4:	0b 2d       	mov	r16, r11
    e2e6:	0e 94 87 79 	call	0xf30e	; 0xf30e <__ftoa_engine>
    e2ea:	6c 01       	movw	r12, r24
    e2ec:	09 81       	ldd	r16, Y+1	; 0x01
    e2ee:	20 2e       	mov	r2, r16
    e2f0:	33 24       	eor	r3, r3
    e2f2:	00 ff       	sbrs	r16, 0
    e2f4:	04 c0       	rjmp	.+8      	; 0xe2fe <vfprintf+0x1c4>
    e2f6:	03 fd       	sbrc	r16, 3
    e2f8:	02 c0       	rjmp	.+4      	; 0xe2fe <vfprintf+0x1c4>
    e2fa:	1d e2       	ldi	r17, 0x2D	; 45
    e2fc:	09 c0       	rjmp	.+18     	; 0xe310 <vfprintf+0x1d6>
    e2fe:	f1 fe       	sbrs	r15, 1
    e300:	02 c0       	rjmp	.+4      	; 0xe306 <vfprintf+0x1cc>
    e302:	1b e2       	ldi	r17, 0x2B	; 43
    e304:	05 c0       	rjmp	.+10     	; 0xe310 <vfprintf+0x1d6>
    e306:	f2 fc       	sbrc	r15, 2
    e308:	02 c0       	rjmp	.+4      	; 0xe30e <vfprintf+0x1d4>
    e30a:	10 e0       	ldi	r17, 0x00	; 0
    e30c:	01 c0       	rjmp	.+2      	; 0xe310 <vfprintf+0x1d6>
    e30e:	10 e2       	ldi	r17, 0x20	; 32
    e310:	c1 01       	movw	r24, r2
    e312:	8c 70       	andi	r24, 0x0C	; 12
    e314:	90 70       	andi	r25, 0x00	; 0
    e316:	89 2b       	or	r24, r25
    e318:	b9 f1       	breq	.+110    	; 0xe388 <vfprintf+0x24e>
    e31a:	11 23       	and	r17, r17
    e31c:	11 f4       	brne	.+4      	; 0xe322 <vfprintf+0x1e8>
    e31e:	83 e0       	ldi	r24, 0x03	; 3
    e320:	01 c0       	rjmp	.+2      	; 0xe324 <vfprintf+0x1ea>
    e322:	84 e0       	ldi	r24, 0x04	; 4
    e324:	88 15       	cp	r24, r8
    e326:	10 f0       	brcs	.+4      	; 0xe32c <vfprintf+0x1f2>
    e328:	88 24       	eor	r8, r8
    e32a:	0a c0       	rjmp	.+20     	; 0xe340 <vfprintf+0x206>
    e32c:	88 1a       	sub	r8, r24
    e32e:	f3 fc       	sbrc	r15, 3
    e330:	07 c0       	rjmp	.+14     	; 0xe340 <vfprintf+0x206>
    e332:	80 e2       	ldi	r24, 0x20	; 32
    e334:	90 e0       	ldi	r25, 0x00	; 0
    e336:	b3 01       	movw	r22, r6
    e338:	0e 94 4a 7b 	call	0xf694	; 0xf694 <fputc>
    e33c:	8a 94       	dec	r8
    e33e:	c9 f7       	brne	.-14     	; 0xe332 <vfprintf+0x1f8>
    e340:	11 23       	and	r17, r17
    e342:	29 f0       	breq	.+10     	; 0xe34e <vfprintf+0x214>
    e344:	81 2f       	mov	r24, r17
    e346:	90 e0       	ldi	r25, 0x00	; 0
    e348:	b3 01       	movw	r22, r6
    e34a:	0e 94 4a 7b 	call	0xf694	; 0xf694 <fputc>
    e34e:	23 fe       	sbrs	r2, 3
    e350:	03 c0       	rjmp	.+6      	; 0xe358 <vfprintf+0x21e>
    e352:	0a ec       	ldi	r16, 0xCA	; 202
    e354:	12 e0       	ldi	r17, 0x02	; 2
    e356:	0e c0       	rjmp	.+28     	; 0xe374 <vfprintf+0x23a>
    e358:	0e ec       	ldi	r16, 0xCE	; 206
    e35a:	12 e0       	ldi	r17, 0x02	; 2
    e35c:	0b c0       	rjmp	.+22     	; 0xe374 <vfprintf+0x23a>
    e35e:	e1 14       	cp	r14, r1
    e360:	f1 04       	cpc	r15, r1
    e362:	09 f0       	breq	.+2      	; 0xe366 <vfprintf+0x22c>
    e364:	80 52       	subi	r24, 0x20	; 32
    e366:	90 e0       	ldi	r25, 0x00	; 0
    e368:	b3 01       	movw	r22, r6
    e36a:	0e 94 4a 7b 	call	0xf694	; 0xf694 <fputc>
    e36e:	0f 5f       	subi	r16, 0xFF	; 255
    e370:	1f 4f       	sbci	r17, 0xFF	; 255
    e372:	05 c0       	rjmp	.+10     	; 0xe37e <vfprintf+0x244>
    e374:	ef 2c       	mov	r14, r15
    e376:	ff 24       	eor	r15, r15
    e378:	f0 e1       	ldi	r31, 0x10	; 16
    e37a:	ef 22       	and	r14, r31
    e37c:	ff 24       	eor	r15, r15
    e37e:	f8 01       	movw	r30, r16
    e380:	84 91       	lpm	r24, Z+
    e382:	88 23       	and	r24, r24
    e384:	61 f7       	brne	.-40     	; 0xe35e <vfprintf+0x224>
    e386:	14 c1       	rjmp	.+552    	; 0xe5b0 <vfprintf+0x476>
    e388:	f7 fe       	sbrs	r15, 7
    e38a:	12 c0       	rjmp	.+36     	; 0xe3b0 <vfprintf+0x276>
    e38c:	bc 0c       	add	r11, r12
    e38e:	24 fe       	sbrs	r2, 4
    e390:	04 c0       	rjmp	.+8      	; 0xe39a <vfprintf+0x260>
    e392:	8a 81       	ldd	r24, Y+2	; 0x02
    e394:	81 33       	cpi	r24, 0x31	; 49
    e396:	09 f4       	brne	.+2      	; 0xe39a <vfprintf+0x260>
    e398:	ba 94       	dec	r11
    e39a:	1b 14       	cp	r1, r11
    e39c:	1c f0       	brlt	.+6      	; 0xe3a4 <vfprintf+0x26a>
    e39e:	bb 24       	eor	r11, r11
    e3a0:	b3 94       	inc	r11
    e3a2:	2d c0       	rjmp	.+90     	; 0xe3fe <vfprintf+0x2c4>
    e3a4:	f8 e0       	ldi	r31, 0x08	; 8
    e3a6:	fb 15       	cp	r31, r11
    e3a8:	50 f5       	brcc	.+84     	; 0xe3fe <vfprintf+0x2c4>
    e3aa:	38 e0       	ldi	r19, 0x08	; 8
    e3ac:	b3 2e       	mov	r11, r19
    e3ae:	27 c0       	rjmp	.+78     	; 0xe3fe <vfprintf+0x2c4>
    e3b0:	f6 fc       	sbrc	r15, 6
    e3b2:	25 c0       	rjmp	.+74     	; 0xe3fe <vfprintf+0x2c4>
    e3b4:	89 2d       	mov	r24, r9
    e3b6:	90 e0       	ldi	r25, 0x00	; 0
    e3b8:	8c 15       	cp	r24, r12
    e3ba:	9d 05       	cpc	r25, r13
    e3bc:	4c f0       	brlt	.+18     	; 0xe3d0 <vfprintf+0x296>
    e3be:	2c ef       	ldi	r18, 0xFC	; 252
    e3c0:	c2 16       	cp	r12, r18
    e3c2:	2f ef       	ldi	r18, 0xFF	; 255
    e3c4:	d2 06       	cpc	r13, r18
    e3c6:	24 f0       	brlt	.+8      	; 0xe3d0 <vfprintf+0x296>
    e3c8:	30 e8       	ldi	r19, 0x80	; 128
    e3ca:	f3 2a       	or	r15, r19
    e3cc:	01 c0       	rjmp	.+2      	; 0xe3d0 <vfprintf+0x296>
    e3ce:	9a 94       	dec	r9
    e3d0:	99 20       	and	r9, r9
    e3d2:	49 f0       	breq	.+18     	; 0xe3e6 <vfprintf+0x2ac>
    e3d4:	e2 e0       	ldi	r30, 0x02	; 2
    e3d6:	f0 e0       	ldi	r31, 0x00	; 0
    e3d8:	ec 0f       	add	r30, r28
    e3da:	fd 1f       	adc	r31, r29
    e3dc:	e9 0d       	add	r30, r9
    e3de:	f1 1d       	adc	r31, r1
    e3e0:	80 81       	ld	r24, Z
    e3e2:	80 33       	cpi	r24, 0x30	; 48
    e3e4:	a1 f3       	breq	.-24     	; 0xe3ce <vfprintf+0x294>
    e3e6:	f7 fe       	sbrs	r15, 7
    e3e8:	0a c0       	rjmp	.+20     	; 0xe3fe <vfprintf+0x2c4>
    e3ea:	b9 2c       	mov	r11, r9
    e3ec:	b3 94       	inc	r11
    e3ee:	89 2d       	mov	r24, r9
    e3f0:	90 e0       	ldi	r25, 0x00	; 0
    e3f2:	c8 16       	cp	r12, r24
    e3f4:	d9 06       	cpc	r13, r25
    e3f6:	14 f0       	brlt	.+4      	; 0xe3fc <vfprintf+0x2c2>
    e3f8:	99 24       	eor	r9, r9
    e3fa:	01 c0       	rjmp	.+2      	; 0xe3fe <vfprintf+0x2c4>
    e3fc:	9c 18       	sub	r9, r12
    e3fe:	f7 fc       	sbrc	r15, 7
    e400:	03 c0       	rjmp	.+6      	; 0xe408 <vfprintf+0x2ce>
    e402:	25 e0       	ldi	r18, 0x05	; 5
    e404:	30 e0       	ldi	r19, 0x00	; 0
    e406:	09 c0       	rjmp	.+18     	; 0xe41a <vfprintf+0x2e0>
    e408:	1c 14       	cp	r1, r12
    e40a:	1d 04       	cpc	r1, r13
    e40c:	1c f0       	brlt	.+6      	; 0xe414 <vfprintf+0x2da>
    e40e:	21 e0       	ldi	r18, 0x01	; 1
    e410:	30 e0       	ldi	r19, 0x00	; 0
    e412:	03 c0       	rjmp	.+6      	; 0xe41a <vfprintf+0x2e0>
    e414:	96 01       	movw	r18, r12
    e416:	2f 5f       	subi	r18, 0xFF	; 255
    e418:	3f 4f       	sbci	r19, 0xFF	; 255
    e41a:	11 23       	and	r17, r17
    e41c:	11 f0       	breq	.+4      	; 0xe422 <vfprintf+0x2e8>
    e41e:	2f 5f       	subi	r18, 0xFF	; 255
    e420:	3f 4f       	sbci	r19, 0xFF	; 255
    e422:	99 20       	and	r9, r9
    e424:	29 f0       	breq	.+10     	; 0xe430 <vfprintf+0x2f6>
    e426:	89 2d       	mov	r24, r9
    e428:	90 e0       	ldi	r25, 0x00	; 0
    e42a:	01 96       	adiw	r24, 0x01	; 1
    e42c:	28 0f       	add	r18, r24
    e42e:	39 1f       	adc	r19, r25
    e430:	88 2d       	mov	r24, r8
    e432:	90 e0       	ldi	r25, 0x00	; 0
    e434:	28 17       	cp	r18, r24
    e436:	39 07       	cpc	r19, r25
    e438:	14 f0       	brlt	.+4      	; 0xe43e <vfprintf+0x304>
    e43a:	88 24       	eor	r8, r8
    e43c:	01 c0       	rjmp	.+2      	; 0xe440 <vfprintf+0x306>
    e43e:	82 1a       	sub	r8, r18
    e440:	4f 2c       	mov	r4, r15
    e442:	55 24       	eor	r5, r5
    e444:	c2 01       	movw	r24, r4
    e446:	89 70       	andi	r24, 0x09	; 9
    e448:	90 70       	andi	r25, 0x00	; 0
    e44a:	89 2b       	or	r24, r25
    e44c:	39 f0       	breq	.+14     	; 0xe45c <vfprintf+0x322>
    e44e:	08 c0       	rjmp	.+16     	; 0xe460 <vfprintf+0x326>
    e450:	80 e2       	ldi	r24, 0x20	; 32
    e452:	90 e0       	ldi	r25, 0x00	; 0
    e454:	b3 01       	movw	r22, r6
    e456:	0e 94 4a 7b 	call	0xf694	; 0xf694 <fputc>
    e45a:	8a 94       	dec	r8
    e45c:	88 20       	and	r8, r8
    e45e:	c1 f7       	brne	.-16     	; 0xe450 <vfprintf+0x316>
    e460:	11 23       	and	r17, r17
    e462:	29 f0       	breq	.+10     	; 0xe46e <vfprintf+0x334>
    e464:	81 2f       	mov	r24, r17
    e466:	90 e0       	ldi	r25, 0x00	; 0
    e468:	b3 01       	movw	r22, r6
    e46a:	0e 94 4a 7b 	call	0xf694	; 0xf694 <fputc>
    e46e:	43 fe       	sbrs	r4, 3
    e470:	07 c0       	rjmp	.+14     	; 0xe480 <vfprintf+0x346>
    e472:	08 c0       	rjmp	.+16     	; 0xe484 <vfprintf+0x34a>
    e474:	80 e3       	ldi	r24, 0x30	; 48
    e476:	90 e0       	ldi	r25, 0x00	; 0
    e478:	b3 01       	movw	r22, r6
    e47a:	0e 94 4a 7b 	call	0xf694	; 0xf694 <fputc>
    e47e:	8a 94       	dec	r8
    e480:	88 20       	and	r8, r8
    e482:	c1 f7       	brne	.-16     	; 0xe474 <vfprintf+0x33a>
    e484:	f7 fe       	sbrs	r15, 7
    e486:	46 c0       	rjmp	.+140    	; 0xe514 <vfprintf+0x3da>
    e488:	86 01       	movw	r16, r12
    e48a:	d7 fe       	sbrs	r13, 7
    e48c:	02 c0       	rjmp	.+4      	; 0xe492 <vfprintf+0x358>
    e48e:	00 e0       	ldi	r16, 0x00	; 0
    e490:	10 e0       	ldi	r17, 0x00	; 0
    e492:	76 01       	movw	r14, r12
    e494:	08 94       	sec
    e496:	e1 1c       	adc	r14, r1
    e498:	f1 1c       	adc	r15, r1
    e49a:	e0 1a       	sub	r14, r16
    e49c:	f1 0a       	sbc	r15, r17
    e49e:	41 e0       	ldi	r20, 0x01	; 1
    e4a0:	50 e0       	ldi	r21, 0x00	; 0
    e4a2:	4c 0f       	add	r20, r28
    e4a4:	5d 1f       	adc	r21, r29
    e4a6:	e4 0e       	add	r14, r20
    e4a8:	f5 1e       	adc	r15, r21
    e4aa:	26 01       	movw	r4, r12
    e4ac:	4b 18       	sub	r4, r11
    e4ae:	51 08       	sbc	r5, r1
    e4b0:	89 2d       	mov	r24, r9
    e4b2:	90 e0       	ldi	r25, 0x00	; 0
    e4b4:	aa 24       	eor	r10, r10
    e4b6:	bb 24       	eor	r11, r11
    e4b8:	a8 1a       	sub	r10, r24
    e4ba:	b9 0a       	sbc	r11, r25
    e4bc:	5f ef       	ldi	r21, 0xFF	; 255
    e4be:	0f 3f       	cpi	r16, 0xFF	; 255
    e4c0:	15 07       	cpc	r17, r21
    e4c2:	29 f4       	brne	.+10     	; 0xe4ce <vfprintf+0x394>
    e4c4:	8e e2       	ldi	r24, 0x2E	; 46
    e4c6:	90 e0       	ldi	r25, 0x00	; 0
    e4c8:	b3 01       	movw	r22, r6
    e4ca:	0e 94 4a 7b 	call	0xf694	; 0xf694 <fputc>
    e4ce:	c0 16       	cp	r12, r16
    e4d0:	d1 06       	cpc	r13, r17
    e4d2:	34 f0       	brlt	.+12     	; 0xe4e0 <vfprintf+0x3a6>
    e4d4:	40 16       	cp	r4, r16
    e4d6:	51 06       	cpc	r5, r17
    e4d8:	1c f4       	brge	.+6      	; 0xe4e0 <vfprintf+0x3a6>
    e4da:	f7 01       	movw	r30, r14
    e4dc:	80 81       	ld	r24, Z
    e4de:	01 c0       	rjmp	.+2      	; 0xe4e2 <vfprintf+0x3a8>
    e4e0:	80 e3       	ldi	r24, 0x30	; 48
    e4e2:	01 50       	subi	r16, 0x01	; 1
    e4e4:	10 40       	sbci	r17, 0x00	; 0
    e4e6:	08 94       	sec
    e4e8:	e1 1c       	adc	r14, r1
    e4ea:	f1 1c       	adc	r15, r1
    e4ec:	0a 15       	cp	r16, r10
    e4ee:	1b 05       	cpc	r17, r11
    e4f0:	2c f0       	brlt	.+10     	; 0xe4fc <vfprintf+0x3c2>
    e4f2:	90 e0       	ldi	r25, 0x00	; 0
    e4f4:	b3 01       	movw	r22, r6
    e4f6:	0e 94 4a 7b 	call	0xf694	; 0xf694 <fputc>
    e4fa:	e0 cf       	rjmp	.-64     	; 0xe4bc <vfprintf+0x382>
    e4fc:	0c 15       	cp	r16, r12
    e4fe:	1d 05       	cpc	r17, r13
    e500:	39 f4       	brne	.+14     	; 0xe510 <vfprintf+0x3d6>
    e502:	9a 81       	ldd	r25, Y+2	; 0x02
    e504:	96 33       	cpi	r25, 0x36	; 54
    e506:	18 f4       	brcc	.+6      	; 0xe50e <vfprintf+0x3d4>
    e508:	95 33       	cpi	r25, 0x35	; 53
    e50a:	11 f4       	brne	.+4      	; 0xe510 <vfprintf+0x3d6>
    e50c:	24 fe       	sbrs	r2, 4
    e50e:	81 e3       	ldi	r24, 0x31	; 49
    e510:	90 e0       	ldi	r25, 0x00	; 0
    e512:	4b c0       	rjmp	.+150    	; 0xe5aa <vfprintf+0x470>
    e514:	8a 81       	ldd	r24, Y+2	; 0x02
    e516:	81 33       	cpi	r24, 0x31	; 49
    e518:	09 f0       	breq	.+2      	; 0xe51c <vfprintf+0x3e2>
    e51a:	0f 7e       	andi	r16, 0xEF	; 239
    e51c:	90 e0       	ldi	r25, 0x00	; 0
    e51e:	b3 01       	movw	r22, r6
    e520:	0e 94 4a 7b 	call	0xf694	; 0xf694 <fputc>
    e524:	99 20       	and	r9, r9
    e526:	a1 f0       	breq	.+40     	; 0xe550 <vfprintf+0x416>
    e528:	8e e2       	ldi	r24, 0x2E	; 46
    e52a:	90 e0       	ldi	r25, 0x00	; 0
    e52c:	b3 01       	movw	r22, r6
    e52e:	0e 94 4a 7b 	call	0xf694	; 0xf694 <fputc>
    e532:	12 e0       	ldi	r17, 0x02	; 2
    e534:	e1 e0       	ldi	r30, 0x01	; 1
    e536:	f0 e0       	ldi	r31, 0x00	; 0
    e538:	ec 0f       	add	r30, r28
    e53a:	fd 1f       	adc	r31, r29
    e53c:	e1 0f       	add	r30, r17
    e53e:	f1 1d       	adc	r31, r1
    e540:	1f 5f       	subi	r17, 0xFF	; 255
    e542:	80 81       	ld	r24, Z
    e544:	90 e0       	ldi	r25, 0x00	; 0
    e546:	b3 01       	movw	r22, r6
    e548:	0e 94 4a 7b 	call	0xf694	; 0xf694 <fputc>
    e54c:	9a 94       	dec	r9
    e54e:	91 f7       	brne	.-28     	; 0xe534 <vfprintf+0x3fa>
    e550:	44 fc       	sbrc	r4, 4
    e552:	03 c0       	rjmp	.+6      	; 0xe55a <vfprintf+0x420>
    e554:	85 e6       	ldi	r24, 0x65	; 101
    e556:	90 e0       	ldi	r25, 0x00	; 0
    e558:	02 c0       	rjmp	.+4      	; 0xe55e <vfprintf+0x424>
    e55a:	85 e4       	ldi	r24, 0x45	; 69
    e55c:	90 e0       	ldi	r25, 0x00	; 0
    e55e:	b3 01       	movw	r22, r6
    e560:	0e 94 4a 7b 	call	0xf694	; 0xf694 <fputc>
    e564:	d7 fc       	sbrc	r13, 7
    e566:	05 c0       	rjmp	.+10     	; 0xe572 <vfprintf+0x438>
    e568:	c1 14       	cp	r12, r1
    e56a:	d1 04       	cpc	r13, r1
    e56c:	41 f4       	brne	.+16     	; 0xe57e <vfprintf+0x444>
    e56e:	04 ff       	sbrs	r16, 4
    e570:	06 c0       	rjmp	.+12     	; 0xe57e <vfprintf+0x444>
    e572:	d0 94       	com	r13
    e574:	c1 94       	neg	r12
    e576:	d1 08       	sbc	r13, r1
    e578:	d3 94       	inc	r13
    e57a:	8d e2       	ldi	r24, 0x2D	; 45
    e57c:	01 c0       	rjmp	.+2      	; 0xe580 <vfprintf+0x446>
    e57e:	8b e2       	ldi	r24, 0x2B	; 43
    e580:	90 e0       	ldi	r25, 0x00	; 0
    e582:	b3 01       	movw	r22, r6
    e584:	0e 94 4a 7b 	call	0xf694	; 0xf694 <fputc>
    e588:	80 e3       	ldi	r24, 0x30	; 48
    e58a:	05 c0       	rjmp	.+10     	; 0xe596 <vfprintf+0x45c>
    e58c:	8f 5f       	subi	r24, 0xFF	; 255
    e58e:	26 ef       	ldi	r18, 0xF6	; 246
    e590:	3f ef       	ldi	r19, 0xFF	; 255
    e592:	c2 0e       	add	r12, r18
    e594:	d3 1e       	adc	r13, r19
    e596:	3a e0       	ldi	r19, 0x0A	; 10
    e598:	c3 16       	cp	r12, r19
    e59a:	d1 04       	cpc	r13, r1
    e59c:	bc f7       	brge	.-18     	; 0xe58c <vfprintf+0x452>
    e59e:	90 e0       	ldi	r25, 0x00	; 0
    e5a0:	b3 01       	movw	r22, r6
    e5a2:	0e 94 4a 7b 	call	0xf694	; 0xf694 <fputc>
    e5a6:	c6 01       	movw	r24, r12
    e5a8:	c0 96       	adiw	r24, 0x30	; 48
    e5aa:	b3 01       	movw	r22, r6
    e5ac:	0e 94 4a 7b 	call	0xf694	; 0xf694 <fputc>
    e5b0:	cc 84       	ldd	r12, Y+12	; 0x0c
    e5b2:	dd 84       	ldd	r13, Y+13	; 0x0d
    e5b4:	52 c1       	rjmp	.+676    	; 0xe85a <vfprintf+0x720>
    e5b6:	93 36       	cpi	r25, 0x63	; 99
    e5b8:	31 f0       	breq	.+12     	; 0xe5c6 <vfprintf+0x48c>
    e5ba:	93 37       	cpi	r25, 0x73	; 115
    e5bc:	99 f0       	breq	.+38     	; 0xe5e4 <vfprintf+0x4aa>
    e5be:	93 35       	cpi	r25, 0x53	; 83
    e5c0:	09 f0       	breq	.+2      	; 0xe5c4 <vfprintf+0x48a>
    e5c2:	59 c0       	rjmp	.+178    	; 0xe676 <vfprintf+0x53c>
    e5c4:	23 c0       	rjmp	.+70     	; 0xe60c <vfprintf+0x4d2>
    e5c6:	f6 01       	movw	r30, r12
    e5c8:	80 81       	ld	r24, Z
    e5ca:	89 83       	std	Y+1, r24	; 0x01
    e5cc:	5e 01       	movw	r10, r28
    e5ce:	08 94       	sec
    e5d0:	a1 1c       	adc	r10, r1
    e5d2:	b1 1c       	adc	r11, r1
    e5d4:	22 e0       	ldi	r18, 0x02	; 2
    e5d6:	30 e0       	ldi	r19, 0x00	; 0
    e5d8:	c2 0e       	add	r12, r18
    e5da:	d3 1e       	adc	r13, r19
    e5dc:	21 e0       	ldi	r18, 0x01	; 1
    e5de:	e2 2e       	mov	r14, r18
    e5e0:	f1 2c       	mov	r15, r1
    e5e2:	12 c0       	rjmp	.+36     	; 0xe608 <vfprintf+0x4ce>
    e5e4:	f6 01       	movw	r30, r12
    e5e6:	a0 80       	ld	r10, Z
    e5e8:	b1 80       	ldd	r11, Z+1	; 0x01
    e5ea:	16 fd       	sbrc	r17, 6
    e5ec:	03 c0       	rjmp	.+6      	; 0xe5f4 <vfprintf+0x4ba>
    e5ee:	6f ef       	ldi	r22, 0xFF	; 255
    e5f0:	7f ef       	ldi	r23, 0xFF	; 255
    e5f2:	02 c0       	rjmp	.+4      	; 0xe5f8 <vfprintf+0x4be>
    e5f4:	69 2d       	mov	r22, r9
    e5f6:	70 e0       	ldi	r23, 0x00	; 0
    e5f8:	22 e0       	ldi	r18, 0x02	; 2
    e5fa:	30 e0       	ldi	r19, 0x00	; 0
    e5fc:	c2 0e       	add	r12, r18
    e5fe:	d3 1e       	adc	r13, r19
    e600:	c5 01       	movw	r24, r10
    e602:	0e 94 e3 7a 	call	0xf5c6	; 0xf5c6 <strnlen>
    e606:	7c 01       	movw	r14, r24
    e608:	1f 77       	andi	r17, 0x7F	; 127
    e60a:	13 c0       	rjmp	.+38     	; 0xe632 <vfprintf+0x4f8>
    e60c:	f6 01       	movw	r30, r12
    e60e:	a0 80       	ld	r10, Z
    e610:	b1 80       	ldd	r11, Z+1	; 0x01
    e612:	16 fd       	sbrc	r17, 6
    e614:	03 c0       	rjmp	.+6      	; 0xe61c <vfprintf+0x4e2>
    e616:	6f ef       	ldi	r22, 0xFF	; 255
    e618:	7f ef       	ldi	r23, 0xFF	; 255
    e61a:	02 c0       	rjmp	.+4      	; 0xe620 <vfprintf+0x4e6>
    e61c:	69 2d       	mov	r22, r9
    e61e:	70 e0       	ldi	r23, 0x00	; 0
    e620:	22 e0       	ldi	r18, 0x02	; 2
    e622:	30 e0       	ldi	r19, 0x00	; 0
    e624:	c2 0e       	add	r12, r18
    e626:	d3 1e       	adc	r13, r19
    e628:	c5 01       	movw	r24, r10
    e62a:	0e 94 a1 7a 	call	0xf542	; 0xf542 <strnlen_P>
    e62e:	7c 01       	movw	r14, r24
    e630:	10 68       	ori	r17, 0x80	; 128
    e632:	13 ff       	sbrs	r17, 3
    e634:	07 c0       	rjmp	.+14     	; 0xe644 <vfprintf+0x50a>
    e636:	1b c0       	rjmp	.+54     	; 0xe66e <vfprintf+0x534>
    e638:	80 e2       	ldi	r24, 0x20	; 32
    e63a:	90 e0       	ldi	r25, 0x00	; 0
    e63c:	b3 01       	movw	r22, r6
    e63e:	0e 94 4a 7b 	call	0xf694	; 0xf694 <fputc>
    e642:	8a 94       	dec	r8
    e644:	88 2d       	mov	r24, r8
    e646:	90 e0       	ldi	r25, 0x00	; 0
    e648:	e8 16       	cp	r14, r24
    e64a:	f9 06       	cpc	r15, r25
    e64c:	a8 f3       	brcs	.-22     	; 0xe638 <vfprintf+0x4fe>
    e64e:	0f c0       	rjmp	.+30     	; 0xe66e <vfprintf+0x534>
    e650:	f5 01       	movw	r30, r10
    e652:	17 fd       	sbrc	r17, 7
    e654:	85 91       	lpm	r24, Z+
    e656:	17 ff       	sbrs	r17, 7
    e658:	81 91       	ld	r24, Z+
    e65a:	5f 01       	movw	r10, r30
    e65c:	90 e0       	ldi	r25, 0x00	; 0
    e65e:	b3 01       	movw	r22, r6
    e660:	0e 94 4a 7b 	call	0xf694	; 0xf694 <fputc>
    e664:	81 10       	cpse	r8, r1
    e666:	8a 94       	dec	r8
    e668:	08 94       	sec
    e66a:	e1 08       	sbc	r14, r1
    e66c:	f1 08       	sbc	r15, r1
    e66e:	e1 14       	cp	r14, r1
    e670:	f1 04       	cpc	r15, r1
    e672:	71 f7       	brne	.-36     	; 0xe650 <vfprintf+0x516>
    e674:	f2 c0       	rjmp	.+484    	; 0xe85a <vfprintf+0x720>
    e676:	94 36       	cpi	r25, 0x64	; 100
    e678:	11 f0       	breq	.+4      	; 0xe67e <vfprintf+0x544>
    e67a:	99 36       	cpi	r25, 0x69	; 105
    e67c:	89 f5       	brne	.+98     	; 0xe6e0 <vfprintf+0x5a6>
    e67e:	17 ff       	sbrs	r17, 7
    e680:	08 c0       	rjmp	.+16     	; 0xe692 <vfprintf+0x558>
    e682:	f6 01       	movw	r30, r12
    e684:	20 81       	ld	r18, Z
    e686:	31 81       	ldd	r19, Z+1	; 0x01
    e688:	42 81       	ldd	r20, Z+2	; 0x02
    e68a:	53 81       	ldd	r21, Z+3	; 0x03
    e68c:	84 e0       	ldi	r24, 0x04	; 4
    e68e:	90 e0       	ldi	r25, 0x00	; 0
    e690:	0a c0       	rjmp	.+20     	; 0xe6a6 <vfprintf+0x56c>
    e692:	f6 01       	movw	r30, r12
    e694:	80 81       	ld	r24, Z
    e696:	91 81       	ldd	r25, Z+1	; 0x01
    e698:	9c 01       	movw	r18, r24
    e69a:	44 27       	eor	r20, r20
    e69c:	37 fd       	sbrc	r19, 7
    e69e:	40 95       	com	r20
    e6a0:	54 2f       	mov	r21, r20
    e6a2:	82 e0       	ldi	r24, 0x02	; 2
    e6a4:	90 e0       	ldi	r25, 0x00	; 0
    e6a6:	c8 0e       	add	r12, r24
    e6a8:	d9 1e       	adc	r13, r25
    e6aa:	9f e6       	ldi	r25, 0x6F	; 111
    e6ac:	f9 2e       	mov	r15, r25
    e6ae:	f1 22       	and	r15, r17
    e6b0:	57 ff       	sbrs	r21, 7
    e6b2:	09 c0       	rjmp	.+18     	; 0xe6c6 <vfprintf+0x58c>
    e6b4:	50 95       	com	r21
    e6b6:	40 95       	com	r20
    e6b8:	30 95       	com	r19
    e6ba:	21 95       	neg	r18
    e6bc:	3f 4f       	sbci	r19, 0xFF	; 255
    e6be:	4f 4f       	sbci	r20, 0xFF	; 255
    e6c0:	5f 4f       	sbci	r21, 0xFF	; 255
    e6c2:	90 e8       	ldi	r25, 0x80	; 128
    e6c4:	f9 2a       	or	r15, r25
    e6c6:	ca 01       	movw	r24, r20
    e6c8:	b9 01       	movw	r22, r18
    e6ca:	ae 01       	movw	r20, r28
    e6cc:	4f 5f       	subi	r20, 0xFF	; 255
    e6ce:	5f 4f       	sbci	r21, 0xFF	; 255
    e6d0:	2a e0       	ldi	r18, 0x0A	; 10
    e6d2:	30 e0       	ldi	r19, 0x00	; 0
    e6d4:	0e 94 38 7c 	call	0xf870	; 0xf870 <__ultoa_invert>
    e6d8:	e8 2e       	mov	r14, r24
    e6da:	e8 89       	ldd	r30, Y+16	; 0x10
    e6dc:	ee 1a       	sub	r14, r30
    e6de:	41 c0       	rjmp	.+130    	; 0xe762 <vfprintf+0x628>
    e6e0:	95 37       	cpi	r25, 0x75	; 117
    e6e2:	21 f4       	brne	.+8      	; 0xe6ec <vfprintf+0x5b2>
    e6e4:	1f 7e       	andi	r17, 0xEF	; 239
    e6e6:	2a e0       	ldi	r18, 0x0A	; 10
    e6e8:	30 e0       	ldi	r19, 0x00	; 0
    e6ea:	1c c0       	rjmp	.+56     	; 0xe724 <vfprintf+0x5ea>
    e6ec:	19 7f       	andi	r17, 0xF9	; 249
    e6ee:	9f 36       	cpi	r25, 0x6F	; 111
    e6f0:	61 f0       	breq	.+24     	; 0xe70a <vfprintf+0x5d0>
    e6f2:	90 37       	cpi	r25, 0x70	; 112
    e6f4:	20 f4       	brcc	.+8      	; 0xe6fe <vfprintf+0x5c4>
    e6f6:	98 35       	cpi	r25, 0x58	; 88
    e6f8:	09 f0       	breq	.+2      	; 0xe6fc <vfprintf+0x5c2>
    e6fa:	b2 c0       	rjmp	.+356    	; 0xe860 <vfprintf+0x726>
    e6fc:	0f c0       	rjmp	.+30     	; 0xe71c <vfprintf+0x5e2>
    e6fe:	90 37       	cpi	r25, 0x70	; 112
    e700:	39 f0       	breq	.+14     	; 0xe710 <vfprintf+0x5d6>
    e702:	98 37       	cpi	r25, 0x78	; 120
    e704:	09 f0       	breq	.+2      	; 0xe708 <vfprintf+0x5ce>
    e706:	ac c0       	rjmp	.+344    	; 0xe860 <vfprintf+0x726>
    e708:	04 c0       	rjmp	.+8      	; 0xe712 <vfprintf+0x5d8>
    e70a:	28 e0       	ldi	r18, 0x08	; 8
    e70c:	30 e0       	ldi	r19, 0x00	; 0
    e70e:	0a c0       	rjmp	.+20     	; 0xe724 <vfprintf+0x5ea>
    e710:	10 61       	ori	r17, 0x10	; 16
    e712:	14 fd       	sbrc	r17, 4
    e714:	14 60       	ori	r17, 0x04	; 4
    e716:	20 e1       	ldi	r18, 0x10	; 16
    e718:	30 e0       	ldi	r19, 0x00	; 0
    e71a:	04 c0       	rjmp	.+8      	; 0xe724 <vfprintf+0x5ea>
    e71c:	14 fd       	sbrc	r17, 4
    e71e:	16 60       	ori	r17, 0x06	; 6
    e720:	20 e1       	ldi	r18, 0x10	; 16
    e722:	32 e0       	ldi	r19, 0x02	; 2
    e724:	17 ff       	sbrs	r17, 7
    e726:	08 c0       	rjmp	.+16     	; 0xe738 <vfprintf+0x5fe>
    e728:	f6 01       	movw	r30, r12
    e72a:	60 81       	ld	r22, Z
    e72c:	71 81       	ldd	r23, Z+1	; 0x01
    e72e:	82 81       	ldd	r24, Z+2	; 0x02
    e730:	93 81       	ldd	r25, Z+3	; 0x03
    e732:	44 e0       	ldi	r20, 0x04	; 4
    e734:	50 e0       	ldi	r21, 0x00	; 0
    e736:	08 c0       	rjmp	.+16     	; 0xe748 <vfprintf+0x60e>
    e738:	f6 01       	movw	r30, r12
    e73a:	80 81       	ld	r24, Z
    e73c:	91 81       	ldd	r25, Z+1	; 0x01
    e73e:	bc 01       	movw	r22, r24
    e740:	80 e0       	ldi	r24, 0x00	; 0
    e742:	90 e0       	ldi	r25, 0x00	; 0
    e744:	42 e0       	ldi	r20, 0x02	; 2
    e746:	50 e0       	ldi	r21, 0x00	; 0
    e748:	c4 0e       	add	r12, r20
    e74a:	d5 1e       	adc	r13, r21
    e74c:	ae 01       	movw	r20, r28
    e74e:	4f 5f       	subi	r20, 0xFF	; 255
    e750:	5f 4f       	sbci	r21, 0xFF	; 255
    e752:	0e 94 38 7c 	call	0xf870	; 0xf870 <__ultoa_invert>
    e756:	e8 2e       	mov	r14, r24
    e758:	58 89       	ldd	r21, Y+16	; 0x10
    e75a:	e5 1a       	sub	r14, r21
    e75c:	8f e7       	ldi	r24, 0x7F	; 127
    e75e:	f8 2e       	mov	r15, r24
    e760:	f1 22       	and	r15, r17
    e762:	f6 fe       	sbrs	r15, 6
    e764:	0b c0       	rjmp	.+22     	; 0xe77c <vfprintf+0x642>
    e766:	8e ef       	ldi	r24, 0xFE	; 254
    e768:	f8 22       	and	r15, r24
    e76a:	e9 14       	cp	r14, r9
    e76c:	38 f4       	brcc	.+14     	; 0xe77c <vfprintf+0x642>
    e76e:	f4 fe       	sbrs	r15, 4
    e770:	07 c0       	rjmp	.+14     	; 0xe780 <vfprintf+0x646>
    e772:	f2 fc       	sbrc	r15, 2
    e774:	05 c0       	rjmp	.+10     	; 0xe780 <vfprintf+0x646>
    e776:	9f ee       	ldi	r25, 0xEF	; 239
    e778:	f9 22       	and	r15, r25
    e77a:	02 c0       	rjmp	.+4      	; 0xe780 <vfprintf+0x646>
    e77c:	1e 2d       	mov	r17, r14
    e77e:	01 c0       	rjmp	.+2      	; 0xe782 <vfprintf+0x648>
    e780:	19 2d       	mov	r17, r9
    e782:	f4 fe       	sbrs	r15, 4
    e784:	0d c0       	rjmp	.+26     	; 0xe7a0 <vfprintf+0x666>
    e786:	fe 01       	movw	r30, r28
    e788:	ee 0d       	add	r30, r14
    e78a:	f1 1d       	adc	r31, r1
    e78c:	80 81       	ld	r24, Z
    e78e:	80 33       	cpi	r24, 0x30	; 48
    e790:	19 f4       	brne	.+6      	; 0xe798 <vfprintf+0x65e>
    e792:	e9 ee       	ldi	r30, 0xE9	; 233
    e794:	fe 22       	and	r15, r30
    e796:	08 c0       	rjmp	.+16     	; 0xe7a8 <vfprintf+0x66e>
    e798:	1f 5f       	subi	r17, 0xFF	; 255
    e79a:	f2 fe       	sbrs	r15, 2
    e79c:	05 c0       	rjmp	.+10     	; 0xe7a8 <vfprintf+0x66e>
    e79e:	03 c0       	rjmp	.+6      	; 0xe7a6 <vfprintf+0x66c>
    e7a0:	8f 2d       	mov	r24, r15
    e7a2:	86 78       	andi	r24, 0x86	; 134
    e7a4:	09 f0       	breq	.+2      	; 0xe7a8 <vfprintf+0x66e>
    e7a6:	1f 5f       	subi	r17, 0xFF	; 255
    e7a8:	0f 2d       	mov	r16, r15
    e7aa:	f3 fc       	sbrc	r15, 3
    e7ac:	14 c0       	rjmp	.+40     	; 0xe7d6 <vfprintf+0x69c>
    e7ae:	f0 fe       	sbrs	r15, 0
    e7b0:	0f c0       	rjmp	.+30     	; 0xe7d0 <vfprintf+0x696>
    e7b2:	18 15       	cp	r17, r8
    e7b4:	10 f0       	brcs	.+4      	; 0xe7ba <vfprintf+0x680>
    e7b6:	9e 2c       	mov	r9, r14
    e7b8:	0b c0       	rjmp	.+22     	; 0xe7d0 <vfprintf+0x696>
    e7ba:	9e 2c       	mov	r9, r14
    e7bc:	98 0c       	add	r9, r8
    e7be:	91 1a       	sub	r9, r17
    e7c0:	18 2d       	mov	r17, r8
    e7c2:	06 c0       	rjmp	.+12     	; 0xe7d0 <vfprintf+0x696>
    e7c4:	80 e2       	ldi	r24, 0x20	; 32
    e7c6:	90 e0       	ldi	r25, 0x00	; 0
    e7c8:	b3 01       	movw	r22, r6
    e7ca:	0e 94 4a 7b 	call	0xf694	; 0xf694 <fputc>
    e7ce:	1f 5f       	subi	r17, 0xFF	; 255
    e7d0:	18 15       	cp	r17, r8
    e7d2:	c0 f3       	brcs	.-16     	; 0xe7c4 <vfprintf+0x68a>
    e7d4:	04 c0       	rjmp	.+8      	; 0xe7de <vfprintf+0x6a4>
    e7d6:	18 15       	cp	r17, r8
    e7d8:	10 f4       	brcc	.+4      	; 0xe7de <vfprintf+0x6a4>
    e7da:	81 1a       	sub	r8, r17
    e7dc:	01 c0       	rjmp	.+2      	; 0xe7e0 <vfprintf+0x6a6>
    e7de:	88 24       	eor	r8, r8
    e7e0:	04 ff       	sbrs	r16, 4
    e7e2:	0f c0       	rjmp	.+30     	; 0xe802 <vfprintf+0x6c8>
    e7e4:	80 e3       	ldi	r24, 0x30	; 48
    e7e6:	90 e0       	ldi	r25, 0x00	; 0
    e7e8:	b3 01       	movw	r22, r6
    e7ea:	0e 94 4a 7b 	call	0xf694	; 0xf694 <fputc>
    e7ee:	02 ff       	sbrs	r16, 2
    e7f0:	1d c0       	rjmp	.+58     	; 0xe82c <vfprintf+0x6f2>
    e7f2:	01 fd       	sbrc	r16, 1
    e7f4:	03 c0       	rjmp	.+6      	; 0xe7fc <vfprintf+0x6c2>
    e7f6:	88 e7       	ldi	r24, 0x78	; 120
    e7f8:	90 e0       	ldi	r25, 0x00	; 0
    e7fa:	0e c0       	rjmp	.+28     	; 0xe818 <vfprintf+0x6de>
    e7fc:	88 e5       	ldi	r24, 0x58	; 88
    e7fe:	90 e0       	ldi	r25, 0x00	; 0
    e800:	0b c0       	rjmp	.+22     	; 0xe818 <vfprintf+0x6de>
    e802:	80 2f       	mov	r24, r16
    e804:	86 78       	andi	r24, 0x86	; 134
    e806:	91 f0       	breq	.+36     	; 0xe82c <vfprintf+0x6f2>
    e808:	01 ff       	sbrs	r16, 1
    e80a:	02 c0       	rjmp	.+4      	; 0xe810 <vfprintf+0x6d6>
    e80c:	8b e2       	ldi	r24, 0x2B	; 43
    e80e:	01 c0       	rjmp	.+2      	; 0xe812 <vfprintf+0x6d8>
    e810:	80 e2       	ldi	r24, 0x20	; 32
    e812:	f7 fc       	sbrc	r15, 7
    e814:	8d e2       	ldi	r24, 0x2D	; 45
    e816:	90 e0       	ldi	r25, 0x00	; 0
    e818:	b3 01       	movw	r22, r6
    e81a:	0e 94 4a 7b 	call	0xf694	; 0xf694 <fputc>
    e81e:	06 c0       	rjmp	.+12     	; 0xe82c <vfprintf+0x6f2>
    e820:	80 e3       	ldi	r24, 0x30	; 48
    e822:	90 e0       	ldi	r25, 0x00	; 0
    e824:	b3 01       	movw	r22, r6
    e826:	0e 94 4a 7b 	call	0xf694	; 0xf694 <fputc>
    e82a:	9a 94       	dec	r9
    e82c:	e9 14       	cp	r14, r9
    e82e:	c0 f3       	brcs	.-16     	; 0xe820 <vfprintf+0x6e6>
    e830:	ea 94       	dec	r14
    e832:	e1 e0       	ldi	r30, 0x01	; 1
    e834:	f0 e0       	ldi	r31, 0x00	; 0
    e836:	ec 0f       	add	r30, r28
    e838:	fd 1f       	adc	r31, r29
    e83a:	ee 0d       	add	r30, r14
    e83c:	f1 1d       	adc	r31, r1
    e83e:	80 81       	ld	r24, Z
    e840:	90 e0       	ldi	r25, 0x00	; 0
    e842:	b3 01       	movw	r22, r6
    e844:	0e 94 4a 7b 	call	0xf694	; 0xf694 <fputc>
    e848:	ee 20       	and	r14, r14
    e84a:	91 f7       	brne	.-28     	; 0xe830 <vfprintf+0x6f6>
    e84c:	06 c0       	rjmp	.+12     	; 0xe85a <vfprintf+0x720>
    e84e:	80 e2       	ldi	r24, 0x20	; 32
    e850:	90 e0       	ldi	r25, 0x00	; 0
    e852:	b3 01       	movw	r22, r6
    e854:	0e 94 4a 7b 	call	0xf694	; 0xf694 <fputc>
    e858:	8a 94       	dec	r8
    e85a:	88 20       	and	r8, r8
    e85c:	c1 f7       	brne	.-16     	; 0xe84e <vfprintf+0x714>
    e85e:	99 cc       	rjmp	.-1742   	; 0xe192 <vfprintf+0x58>
    e860:	f3 01       	movw	r30, r6
    e862:	66 81       	ldd	r22, Z+6	; 0x06
    e864:	77 81       	ldd	r23, Z+7	; 0x07
    e866:	cb 01       	movw	r24, r22
    e868:	61 96       	adiw	r28, 0x11	; 17
    e86a:	0f b6       	in	r0, 0x3f	; 63
    e86c:	f8 94       	cli
    e86e:	de bf       	out	0x3e, r29	; 62
    e870:	0f be       	out	0x3f, r0	; 63
    e872:	cd bf       	out	0x3d, r28	; 61
    e874:	cf 91       	pop	r28
    e876:	df 91       	pop	r29
    e878:	1f 91       	pop	r17
    e87a:	0f 91       	pop	r16
    e87c:	ff 90       	pop	r15
    e87e:	ef 90       	pop	r14
    e880:	df 90       	pop	r13
    e882:	cf 90       	pop	r12
    e884:	bf 90       	pop	r11
    e886:	af 90       	pop	r10
    e888:	9f 90       	pop	r9
    e88a:	8f 90       	pop	r8
    e88c:	7f 90       	pop	r7
    e88e:	6f 90       	pop	r6
    e890:	5f 90       	pop	r5
    e892:	4f 90       	pop	r4
    e894:	3f 90       	pop	r3
    e896:	2f 90       	pop	r2
    e898:	08 95       	ret

0000e89a <putval>:
    e89a:	fc 01       	movw	r30, r24
    e89c:	20 fd       	sbrc	r18, 0
    e89e:	08 c0       	rjmp	.+16     	; 0xe8b0 <putval+0x16>
    e8a0:	23 fd       	sbrc	r18, 3
    e8a2:	05 c0       	rjmp	.+10     	; 0xe8ae <putval+0x14>
    e8a4:	22 ff       	sbrs	r18, 2
    e8a6:	02 c0       	rjmp	.+4      	; 0xe8ac <putval+0x12>
    e8a8:	73 83       	std	Z+3, r23	; 0x03
    e8aa:	62 83       	std	Z+2, r22	; 0x02
    e8ac:	51 83       	std	Z+1, r21	; 0x01
    e8ae:	40 83       	st	Z, r20
    e8b0:	08 95       	ret

0000e8b2 <mulacc>:
    e8b2:	ef 92       	push	r14
    e8b4:	ff 92       	push	r15
    e8b6:	0f 93       	push	r16
    e8b8:	1f 93       	push	r17
    e8ba:	44 ff       	sbrs	r20, 4
    e8bc:	02 c0       	rjmp	.+4      	; 0xe8c2 <mulacc+0x10>
    e8be:	33 e0       	ldi	r19, 0x03	; 3
    e8c0:	11 c0       	rjmp	.+34     	; 0xe8e4 <mulacc+0x32>
    e8c2:	46 ff       	sbrs	r20, 6
    e8c4:	02 c0       	rjmp	.+4      	; 0xe8ca <mulacc+0x18>
    e8c6:	34 e0       	ldi	r19, 0x04	; 4
    e8c8:	0d c0       	rjmp	.+26     	; 0xe8e4 <mulacc+0x32>
    e8ca:	db 01       	movw	r26, r22
    e8cc:	fc 01       	movw	r30, r24
    e8ce:	aa 0f       	add	r26, r26
    e8d0:	bb 1f       	adc	r27, r27
    e8d2:	ee 1f       	adc	r30, r30
    e8d4:	ff 1f       	adc	r31, r31
    e8d6:	10 94       	com	r1
    e8d8:	d1 f7       	brne	.-12     	; 0xe8ce <mulacc+0x1c>
    e8da:	6a 0f       	add	r22, r26
    e8dc:	7b 1f       	adc	r23, r27
    e8de:	8e 1f       	adc	r24, r30
    e8e0:	9f 1f       	adc	r25, r31
    e8e2:	31 e0       	ldi	r19, 0x01	; 1
    e8e4:	66 0f       	add	r22, r22
    e8e6:	77 1f       	adc	r23, r23
    e8e8:	88 1f       	adc	r24, r24
    e8ea:	99 1f       	adc	r25, r25
    e8ec:	31 50       	subi	r19, 0x01	; 1
    e8ee:	d1 f7       	brne	.-12     	; 0xe8e4 <mulacc+0x32>
    e8f0:	7b 01       	movw	r14, r22
    e8f2:	8c 01       	movw	r16, r24
    e8f4:	e2 0e       	add	r14, r18
    e8f6:	f1 1c       	adc	r15, r1
    e8f8:	01 1d       	adc	r16, r1
    e8fa:	11 1d       	adc	r17, r1
    e8fc:	a8 01       	movw	r20, r16
    e8fe:	97 01       	movw	r18, r14
    e900:	b7 01       	movw	r22, r14
    e902:	ca 01       	movw	r24, r20
    e904:	1f 91       	pop	r17
    e906:	0f 91       	pop	r16
    e908:	ff 90       	pop	r15
    e90a:	ef 90       	pop	r14
    e90c:	08 95       	ret

0000e90e <skip_spaces>:
    e90e:	0f 93       	push	r16
    e910:	1f 93       	push	r17
    e912:	cf 93       	push	r28
    e914:	df 93       	push	r29
    e916:	8c 01       	movw	r16, r24
    e918:	c8 01       	movw	r24, r16
    e91a:	0e 94 08 7b 	call	0xf610	; 0xf610 <fgetc>
    e91e:	ec 01       	movw	r28, r24
    e920:	97 fd       	sbrc	r25, 7
    e922:	08 c0       	rjmp	.+16     	; 0xe934 <skip_spaces+0x26>
    e924:	0e 94 5f 7a 	call	0xf4be	; 0xf4be <isspace>
    e928:	89 2b       	or	r24, r25
    e92a:	b1 f7       	brne	.-20     	; 0xe918 <skip_spaces+0xa>
    e92c:	ce 01       	movw	r24, r28
    e92e:	b8 01       	movw	r22, r16
    e930:	0e 94 1e 7c 	call	0xf83c	; 0xf83c <ungetc>
    e934:	ce 01       	movw	r24, r28
    e936:	df 91       	pop	r29
    e938:	cf 91       	pop	r28
    e93a:	1f 91       	pop	r17
    e93c:	0f 91       	pop	r16
    e93e:	08 95       	ret

0000e940 <conv_int>:
    e940:	8f 92       	push	r8
    e942:	9f 92       	push	r9
    e944:	af 92       	push	r10
    e946:	bf 92       	push	r11
    e948:	df 92       	push	r13
    e94a:	ef 92       	push	r14
    e94c:	ff 92       	push	r15
    e94e:	0f 93       	push	r16
    e950:	1f 93       	push	r17
    e952:	cf 93       	push	r28
    e954:	df 93       	push	r29
    e956:	5c 01       	movw	r10, r24
    e958:	eb 01       	movw	r28, r22
    e95a:	4a 01       	movw	r8, r20
    e95c:	12 2f       	mov	r17, r18
    e95e:	0e 94 08 7b 	call	0xf610	; 0xf610 <fgetc>
    e962:	ac 01       	movw	r20, r24
    e964:	8b 32       	cpi	r24, 0x2B	; 43
    e966:	19 f0       	breq	.+6      	; 0xe96e <conv_int+0x2e>
    e968:	8d 32       	cpi	r24, 0x2D	; 45
    e96a:	51 f4       	brne	.+20     	; 0xe980 <conv_int+0x40>
    e96c:	10 68       	ori	r17, 0x80	; 128
    e96e:	21 97       	sbiw	r28, 0x01	; 1
    e970:	09 f4       	brne	.+2      	; 0xe974 <conv_int+0x34>
    e972:	6d c0       	rjmp	.+218    	; 0xea4e <conv_int+0x10e>
    e974:	c5 01       	movw	r24, r10
    e976:	0e 94 08 7b 	call	0xf610	; 0xf610 <fgetc>
    e97a:	ac 01       	movw	r20, r24
    e97c:	97 fd       	sbrc	r25, 7
    e97e:	67 c0       	rjmp	.+206    	; 0xea4e <conv_int+0x10e>
    e980:	6d ef       	ldi	r22, 0xFD	; 253
    e982:	d6 2e       	mov	r13, r22
    e984:	d1 22       	and	r13, r17
    e986:	8d 2d       	mov	r24, r13
    e988:	80 73       	andi	r24, 0x30	; 48
    e98a:	01 f5       	brne	.+64     	; 0xe9cc <conv_int+0x8c>
    e98c:	40 33       	cpi	r20, 0x30	; 48
    e98e:	f1 f4       	brne	.+60     	; 0xe9cc <conv_int+0x8c>
    e990:	21 97       	sbiw	r28, 0x01	; 1
    e992:	09 f4       	brne	.+2      	; 0xe996 <conv_int+0x56>
    e994:	47 c0       	rjmp	.+142    	; 0xea24 <conv_int+0xe4>
    e996:	c5 01       	movw	r24, r10
    e998:	0e 94 08 7b 	call	0xf610	; 0xf610 <fgetc>
    e99c:	ac 01       	movw	r20, r24
    e99e:	97 fd       	sbrc	r25, 7
    e9a0:	41 c0       	rjmp	.+130    	; 0xea24 <conv_int+0xe4>
    e9a2:	82 e0       	ldi	r24, 0x02	; 2
    e9a4:	d8 2a       	or	r13, r24
    e9a6:	48 37       	cpi	r20, 0x78	; 120
    e9a8:	11 f0       	breq	.+4      	; 0xe9ae <conv_int+0x6e>
    e9aa:	48 35       	cpi	r20, 0x58	; 88
    e9ac:	59 f4       	brne	.+22     	; 0xe9c4 <conv_int+0x84>
    e9ae:	80 e4       	ldi	r24, 0x40	; 64
    e9b0:	d8 2a       	or	r13, r24
    e9b2:	21 97       	sbiw	r28, 0x01	; 1
    e9b4:	b9 f1       	breq	.+110    	; 0xea24 <conv_int+0xe4>
    e9b6:	c5 01       	movw	r24, r10
    e9b8:	0e 94 08 7b 	call	0xf610	; 0xf610 <fgetc>
    e9bc:	ac 01       	movw	r20, r24
    e9be:	99 23       	and	r25, r25
    e9c0:	2c f4       	brge	.+10     	; 0xe9cc <conv_int+0x8c>
    e9c2:	30 c0       	rjmp	.+96     	; 0xea24 <conv_int+0xe4>
    e9c4:	d6 fc       	sbrc	r13, 6
    e9c6:	02 c0       	rjmp	.+4      	; 0xe9cc <conv_int+0x8c>
    e9c8:	80 e1       	ldi	r24, 0x10	; 16
    e9ca:	d8 2a       	or	r13, r24
    e9cc:	ee 24       	eor	r14, r14
    e9ce:	ff 24       	eor	r15, r15
    e9d0:	87 01       	movw	r16, r14
    e9d2:	24 2f       	mov	r18, r20
    e9d4:	20 53       	subi	r18, 0x30	; 48
    e9d6:	28 30       	cpi	r18, 0x08	; 8
    e9d8:	88 f0       	brcs	.+34     	; 0xe9fc <conv_int+0xbc>
    e9da:	d4 fc       	sbrc	r13, 4
    e9dc:	09 c0       	rjmp	.+18     	; 0xe9f0 <conv_int+0xb0>
    e9de:	2a 30       	cpi	r18, 0x0A	; 10
    e9e0:	68 f0       	brcs	.+26     	; 0xe9fc <conv_int+0xbc>
    e9e2:	d6 fe       	sbrs	r13, 6
    e9e4:	05 c0       	rjmp	.+10     	; 0xe9f0 <conv_int+0xb0>
    e9e6:	2f 7d       	andi	r18, 0xDF	; 223
    e9e8:	82 2f       	mov	r24, r18
    e9ea:	81 51       	subi	r24, 0x11	; 17
    e9ec:	86 30       	cpi	r24, 0x06	; 6
    e9ee:	28 f0       	brcs	.+10     	; 0xe9fa <conv_int+0xba>
    e9f0:	ca 01       	movw	r24, r20
    e9f2:	b5 01       	movw	r22, r10
    e9f4:	0e 94 1e 7c 	call	0xf83c	; 0xf83c <ungetc>
    e9f8:	12 c0       	rjmp	.+36     	; 0xea1e <conv_int+0xde>
    e9fa:	27 50       	subi	r18, 0x07	; 7
    e9fc:	c8 01       	movw	r24, r16
    e9fe:	b7 01       	movw	r22, r14
    ea00:	4d 2d       	mov	r20, r13
    ea02:	0e 94 59 74 	call	0xe8b2	; 0xe8b2 <mulacc>
    ea06:	7b 01       	movw	r14, r22
    ea08:	8c 01       	movw	r16, r24
    ea0a:	82 e0       	ldi	r24, 0x02	; 2
    ea0c:	d8 2a       	or	r13, r24
    ea0e:	21 97       	sbiw	r28, 0x01	; 1
    ea10:	61 f0       	breq	.+24     	; 0xea2a <conv_int+0xea>
    ea12:	c5 01       	movw	r24, r10
    ea14:	0e 94 08 7b 	call	0xf610	; 0xf610 <fgetc>
    ea18:	ac 01       	movw	r20, r24
    ea1a:	97 ff       	sbrs	r25, 7
    ea1c:	da cf       	rjmp	.-76     	; 0xe9d2 <conv_int+0x92>
    ea1e:	d1 fc       	sbrc	r13, 1
    ea20:	04 c0       	rjmp	.+8      	; 0xea2a <conv_int+0xea>
    ea22:	15 c0       	rjmp	.+42     	; 0xea4e <conv_int+0x10e>
    ea24:	ee 24       	eor	r14, r14
    ea26:	ff 24       	eor	r15, r15
    ea28:	87 01       	movw	r16, r14
    ea2a:	d7 fe       	sbrs	r13, 7
    ea2c:	08 c0       	rjmp	.+16     	; 0xea3e <conv_int+0xfe>
    ea2e:	10 95       	com	r17
    ea30:	00 95       	com	r16
    ea32:	f0 94       	com	r15
    ea34:	e0 94       	com	r14
    ea36:	e1 1c       	adc	r14, r1
    ea38:	f1 1c       	adc	r15, r1
    ea3a:	01 1d       	adc	r16, r1
    ea3c:	11 1d       	adc	r17, r1
    ea3e:	c4 01       	movw	r24, r8
    ea40:	b8 01       	movw	r22, r16
    ea42:	a7 01       	movw	r20, r14
    ea44:	2d 2d       	mov	r18, r13
    ea46:	0e 94 4d 74 	call	0xe89a	; 0xe89a <putval>
    ea4a:	81 e0       	ldi	r24, 0x01	; 1
    ea4c:	01 c0       	rjmp	.+2      	; 0xea50 <conv_int+0x110>
    ea4e:	80 e0       	ldi	r24, 0x00	; 0
    ea50:	df 91       	pop	r29
    ea52:	cf 91       	pop	r28
    ea54:	1f 91       	pop	r17
    ea56:	0f 91       	pop	r16
    ea58:	ff 90       	pop	r15
    ea5a:	ef 90       	pop	r14
    ea5c:	df 90       	pop	r13
    ea5e:	bf 90       	pop	r11
    ea60:	af 90       	pop	r10
    ea62:	9f 90       	pop	r9
    ea64:	8f 90       	pop	r8
    ea66:	08 95       	ret

0000ea68 <conv_brk>:
    ea68:	6f 92       	push	r6
    ea6a:	7f 92       	push	r7
    ea6c:	8f 92       	push	r8
    ea6e:	9f 92       	push	r9
    ea70:	af 92       	push	r10
    ea72:	bf 92       	push	r11
    ea74:	cf 92       	push	r12
    ea76:	df 92       	push	r13
    ea78:	ef 92       	push	r14
    ea7a:	ff 92       	push	r15
    ea7c:	0f 93       	push	r16
    ea7e:	1f 93       	push	r17
    ea80:	df 93       	push	r29
    ea82:	cf 93       	push	r28
    ea84:	cd b7       	in	r28, 0x3d	; 61
    ea86:	de b7       	in	r29, 0x3e	; 62
    ea88:	a0 97       	sbiw	r28, 0x20	; 32
    ea8a:	0f b6       	in	r0, 0x3f	; 63
    ea8c:	f8 94       	cli
    ea8e:	de bf       	out	0x3e, r29	; 62
    ea90:	0f be       	out	0x3f, r0	; 63
    ea92:	cd bf       	out	0x3d, r28	; 61
    ea94:	5c 01       	movw	r10, r24
    ea96:	6b 01       	movw	r12, r22
    ea98:	8a 01       	movw	r16, r20
    ea9a:	79 01       	movw	r14, r18
    ea9c:	fe 01       	movw	r30, r28
    ea9e:	31 96       	adiw	r30, 0x01	; 1
    eaa0:	80 e2       	ldi	r24, 0x20	; 32
    eaa2:	df 01       	movw	r26, r30
    eaa4:	1d 92       	st	X+, r1
    eaa6:	8a 95       	dec	r24
    eaa8:	e9 f7       	brne	.-6      	; 0xeaa4 <conv_brk+0x3c>
    eaaa:	70 e0       	ldi	r23, 0x00	; 0
    eaac:	30 e0       	ldi	r19, 0x00	; 0
    eaae:	60 e0       	ldi	r22, 0x00	; 0
    eab0:	40 e0       	ldi	r20, 0x00	; 0
    eab2:	50 e0       	ldi	r21, 0x00	; 0
    eab4:	3f 01       	movw	r6, r30
    eab6:	a1 e0       	ldi	r26, 0x01	; 1
    eab8:	b0 e0       	ldi	r27, 0x00	; 0
    eaba:	f5 01       	movw	r30, r10
    eabc:	83 81       	ldd	r24, Z+3	; 0x03
    eabe:	f7 01       	movw	r30, r14
    eac0:	83 fd       	sbrc	r24, 3
    eac2:	25 91       	lpm	r18, Z+
    eac4:	83 ff       	sbrs	r24, 3
    eac6:	21 91       	ld	r18, Z+
    eac8:	7f 01       	movw	r14, r30
    eaca:	22 23       	and	r18, r18
    eacc:	09 f4       	brne	.+2      	; 0xead0 <conv_brk+0x68>
    eace:	81 c0       	rjmp	.+258    	; 0xebd2 <conv_brk+0x16a>
    ead0:	2e 35       	cpi	r18, 0x5E	; 94
    ead2:	19 f4       	brne	.+6      	; 0xeada <conv_brk+0x72>
    ead4:	41 15       	cp	r20, r1
    ead6:	51 05       	cpc	r21, r1
    ead8:	69 f1       	breq	.+90     	; 0xeb34 <conv_brk+0xcc>
    eada:	87 2f       	mov	r24, r23
    eadc:	90 e0       	ldi	r25, 0x00	; 0
    eade:	84 17       	cp	r24, r20
    eae0:	95 07       	cpc	r25, r21
    eae2:	44 f4       	brge	.+16     	; 0xeaf4 <conv_brk+0x8c>
    eae4:	2d 35       	cpi	r18, 0x5D	; 93
    eae6:	51 f1       	breq	.+84     	; 0xeb3c <conv_brk+0xd4>
    eae8:	2d 32       	cpi	r18, 0x2D	; 45
    eaea:	21 f4       	brne	.+8      	; 0xeaf4 <conv_brk+0x8c>
    eaec:	33 23       	and	r19, r19
    eaee:	29 f4       	brne	.+10     	; 0xeafa <conv_brk+0x92>
    eaf0:	31 e0       	ldi	r19, 0x01	; 1
    eaf2:	21 c0       	rjmp	.+66     	; 0xeb36 <conv_brk+0xce>
    eaf4:	33 23       	and	r19, r19
    eaf6:	09 f4       	brne	.+2      	; 0xeafa <conv_brk+0x92>
    eaf8:	62 2f       	mov	r22, r18
    eafa:	32 2f       	mov	r19, r18
    eafc:	83 2f       	mov	r24, r19
    eafe:	86 95       	lsr	r24
    eb00:	86 95       	lsr	r24
    eb02:	86 95       	lsr	r24
    eb04:	f3 01       	movw	r30, r6
    eb06:	e8 0f       	add	r30, r24
    eb08:	f1 1d       	adc	r31, r1
    eb0a:	83 2f       	mov	r24, r19
    eb0c:	87 70       	andi	r24, 0x07	; 7
    eb0e:	4d 01       	movw	r8, r26
    eb10:	02 c0       	rjmp	.+4      	; 0xeb16 <conv_brk+0xae>
    eb12:	88 0c       	add	r8, r8
    eb14:	99 1c       	adc	r9, r9
    eb16:	8a 95       	dec	r24
    eb18:	e2 f7       	brpl	.-8      	; 0xeb12 <conv_brk+0xaa>
    eb1a:	20 81       	ld	r18, Z
    eb1c:	28 29       	or	r18, r8
    eb1e:	20 83       	st	Z, r18
    eb20:	36 17       	cp	r19, r22
    eb22:	11 f4       	brne	.+4      	; 0xeb28 <conv_brk+0xc0>
    eb24:	30 e0       	ldi	r19, 0x00	; 0
    eb26:	07 c0       	rjmp	.+14     	; 0xeb36 <conv_brk+0xce>
    eb28:	36 17       	cp	r19, r22
    eb2a:	10 f4       	brcc	.+4      	; 0xeb30 <conv_brk+0xc8>
    eb2c:	3f 5f       	subi	r19, 0xFF	; 255
    eb2e:	e6 cf       	rjmp	.-52     	; 0xeafc <conv_brk+0x94>
    eb30:	31 50       	subi	r19, 0x01	; 1
    eb32:	e4 cf       	rjmp	.-56     	; 0xeafc <conv_brk+0x94>
    eb34:	71 e0       	ldi	r23, 0x01	; 1
    eb36:	4f 5f       	subi	r20, 0xFF	; 255
    eb38:	5f 4f       	sbci	r21, 0xFF	; 255
    eb3a:	bf cf       	rjmp	.-130    	; 0xeaba <conv_brk+0x52>
    eb3c:	33 23       	and	r19, r19
    eb3e:	19 f0       	breq	.+6      	; 0xeb46 <conv_brk+0xde>
    eb40:	8e 81       	ldd	r24, Y+6	; 0x06
    eb42:	80 62       	ori	r24, 0x20	; 32
    eb44:	8e 83       	std	Y+6, r24	; 0x06
    eb46:	77 23       	and	r23, r23
    eb48:	59 f0       	breq	.+22     	; 0xeb60 <conv_brk+0xf8>
    eb4a:	fe 01       	movw	r30, r28
    eb4c:	31 96       	adiw	r30, 0x01	; 1
    eb4e:	9e 01       	movw	r18, r28
    eb50:	2f 5d       	subi	r18, 0xDF	; 223
    eb52:	3f 4f       	sbci	r19, 0xFF	; 255
    eb54:	80 81       	ld	r24, Z
    eb56:	80 95       	com	r24
    eb58:	81 93       	st	Z+, r24
    eb5a:	e2 17       	cp	r30, r18
    eb5c:	f3 07       	cpc	r31, r19
    eb5e:	d1 f7       	brne	.-12     	; 0xeb54 <conv_brk+0xec>
    eb60:	99 24       	eor	r9, r9
    eb62:	93 94       	inc	r9
    eb64:	3e 01       	movw	r6, r28
    eb66:	08 94       	sec
    eb68:	61 1c       	adc	r6, r1
    eb6a:	71 1c       	adc	r7, r1
    eb6c:	c5 01       	movw	r24, r10
    eb6e:	0e 94 08 7b 	call	0xf610	; 0xf610 <fgetc>
    eb72:	ac 01       	movw	r20, r24
    eb74:	97 fd       	sbrc	r25, 7
    eb76:	25 c0       	rjmp	.+74     	; 0xebc2 <conv_brk+0x15a>
    eb78:	86 95       	lsr	r24
    eb7a:	86 95       	lsr	r24
    eb7c:	86 95       	lsr	r24
    eb7e:	f3 01       	movw	r30, r6
    eb80:	e8 0f       	add	r30, r24
    eb82:	f1 1d       	adc	r31, r1
    eb84:	80 81       	ld	r24, Z
    eb86:	90 e0       	ldi	r25, 0x00	; 0
    eb88:	9a 01       	movw	r18, r20
    eb8a:	27 70       	andi	r18, 0x07	; 7
    eb8c:	30 70       	andi	r19, 0x00	; 0
    eb8e:	02 c0       	rjmp	.+4      	; 0xeb94 <conv_brk+0x12c>
    eb90:	95 95       	asr	r25
    eb92:	87 95       	ror	r24
    eb94:	2a 95       	dec	r18
    eb96:	e2 f7       	brpl	.-8      	; 0xeb90 <conv_brk+0x128>
    eb98:	80 fd       	sbrc	r24, 0
    eb9a:	05 c0       	rjmp	.+10     	; 0xeba6 <conv_brk+0x13e>
    eb9c:	ca 01       	movw	r24, r20
    eb9e:	b5 01       	movw	r22, r10
    eba0:	0e 94 1e 7c 	call	0xf83c	; 0xf83c <ungetc>
    eba4:	0e c0       	rjmp	.+28     	; 0xebc2 <conv_brk+0x15a>
    eba6:	01 15       	cp	r16, r1
    eba8:	11 05       	cpc	r17, r1
    ebaa:	19 f0       	breq	.+6      	; 0xebb2 <conv_brk+0x14a>
    ebac:	d8 01       	movw	r26, r16
    ebae:	4d 93       	st	X+, r20
    ebb0:	8d 01       	movw	r16, r26
    ebb2:	08 94       	sec
    ebb4:	c1 08       	sbc	r12, r1
    ebb6:	d1 08       	sbc	r13, r1
    ebb8:	99 24       	eor	r9, r9
    ebba:	c1 14       	cp	r12, r1
    ebbc:	d1 04       	cpc	r13, r1
    ebbe:	b1 f6       	brne	.-84     	; 0xeb6c <conv_brk+0x104>
    ebc0:	02 c0       	rjmp	.+4      	; 0xebc6 <conv_brk+0x15e>
    ebc2:	99 20       	and	r9, r9
    ebc4:	31 f4       	brne	.+12     	; 0xebd2 <conv_brk+0x16a>
    ebc6:	01 15       	cp	r16, r1
    ebc8:	11 05       	cpc	r17, r1
    ebca:	29 f0       	breq	.+10     	; 0xebd6 <conv_brk+0x16e>
    ebcc:	f8 01       	movw	r30, r16
    ebce:	10 82       	st	Z, r1
    ebd0:	02 c0       	rjmp	.+4      	; 0xebd6 <conv_brk+0x16e>
    ebd2:	ee 24       	eor	r14, r14
    ebd4:	ff 24       	eor	r15, r15
    ebd6:	c7 01       	movw	r24, r14
    ebd8:	a0 96       	adiw	r28, 0x20	; 32
    ebda:	0f b6       	in	r0, 0x3f	; 63
    ebdc:	f8 94       	cli
    ebde:	de bf       	out	0x3e, r29	; 62
    ebe0:	0f be       	out	0x3f, r0	; 63
    ebe2:	cd bf       	out	0x3d, r28	; 61
    ebe4:	cf 91       	pop	r28
    ebe6:	df 91       	pop	r29
    ebe8:	1f 91       	pop	r17
    ebea:	0f 91       	pop	r16
    ebec:	ff 90       	pop	r15
    ebee:	ef 90       	pop	r14
    ebf0:	df 90       	pop	r13
    ebf2:	cf 90       	pop	r12
    ebf4:	bf 90       	pop	r11
    ebf6:	af 90       	pop	r10
    ebf8:	9f 90       	pop	r9
    ebfa:	8f 90       	pop	r8
    ebfc:	7f 90       	pop	r7
    ebfe:	6f 90       	pop	r6
    ec00:	08 95       	ret

0000ec02 <conv_flt>:
    ec02:	2f 92       	push	r2
    ec04:	3f 92       	push	r3
    ec06:	5f 92       	push	r5
    ec08:	6f 92       	push	r6
    ec0a:	7f 92       	push	r7
    ec0c:	8f 92       	push	r8
    ec0e:	9f 92       	push	r9
    ec10:	af 92       	push	r10
    ec12:	bf 92       	push	r11
    ec14:	cf 92       	push	r12
    ec16:	df 92       	push	r13
    ec18:	ef 92       	push	r14
    ec1a:	ff 92       	push	r15
    ec1c:	0f 93       	push	r16
    ec1e:	1f 93       	push	r17
    ec20:	cf 93       	push	r28
    ec22:	df 93       	push	r29
    ec24:	3c 01       	movw	r6, r24
    ec26:	7b 01       	movw	r14, r22
    ec28:	1a 01       	movw	r2, r20
    ec2a:	0e 94 08 7b 	call	0xf610	; 0xf610 <fgetc>
    ec2e:	ec 01       	movw	r28, r24
    ec30:	8b 32       	cpi	r24, 0x2B	; 43
    ec32:	39 f0       	breq	.+14     	; 0xec42 <conv_flt+0x40>
    ec34:	8d 32       	cpi	r24, 0x2D	; 45
    ec36:	11 f0       	breq	.+4      	; 0xec3c <conv_flt+0x3a>
    ec38:	55 24       	eor	r5, r5
    ec3a:	11 c0       	rjmp	.+34     	; 0xec5e <conv_flt+0x5c>
    ec3c:	b0 e8       	ldi	r27, 0x80	; 128
    ec3e:	5b 2e       	mov	r5, r27
    ec40:	01 c0       	rjmp	.+2      	; 0xec44 <conv_flt+0x42>
    ec42:	55 24       	eor	r5, r5
    ec44:	08 94       	sec
    ec46:	e1 08       	sbc	r14, r1
    ec48:	f1 08       	sbc	r15, r1
    ec4a:	e1 14       	cp	r14, r1
    ec4c:	f1 04       	cpc	r15, r1
    ec4e:	09 f4       	brne	.+2      	; 0xec52 <conv_flt+0x50>
    ec50:	18 c1       	rjmp	.+560    	; 0xee82 <conv_flt+0x280>
    ec52:	c3 01       	movw	r24, r6
    ec54:	0e 94 08 7b 	call	0xf610	; 0xf610 <fgetc>
    ec58:	ec 01       	movw	r28, r24
    ec5a:	97 fd       	sbrc	r25, 7
    ec5c:	12 c1       	rjmp	.+548    	; 0xee82 <conv_flt+0x280>
    ec5e:	ce 01       	movw	r24, r28
    ec60:	0e 94 67 7a 	call	0xf4ce	; 0xf4ce <tolower>
    ec64:	89 36       	cpi	r24, 0x69	; 105
    ec66:	91 05       	cpc	r25, r1
    ec68:	21 f0       	breq	.+8      	; 0xec72 <conv_flt+0x70>
    ec6a:	8e 36       	cpi	r24, 0x6E	; 110
    ec6c:	91 05       	cpc	r25, r1
    ec6e:	99 f5       	brne	.+102    	; 0xecd6 <conv_flt+0xd4>
    ec70:	1d c0       	rjmp	.+58     	; 0xecac <conv_flt+0xaa>
    ec72:	07 ee       	ldi	r16, 0xE7	; 231
    ec74:	12 e0       	ldi	r17, 0x02	; 2
    ec76:	1c c0       	rjmp	.+56     	; 0xecb0 <conv_flt+0xae>
    ec78:	08 94       	sec
    ec7a:	e1 08       	sbc	r14, r1
    ec7c:	f1 08       	sbc	r15, r1
    ec7e:	e1 14       	cp	r14, r1
    ec80:	f1 04       	cpc	r15, r1
    ec82:	71 f0       	breq	.+28     	; 0xeca0 <conv_flt+0x9e>
    ec84:	c3 01       	movw	r24, r6
    ec86:	0e 94 08 7b 	call	0xf610	; 0xf610 <fgetc>
    ec8a:	ec 01       	movw	r28, r24
    ec8c:	97 fd       	sbrc	r25, 7
    ec8e:	08 c0       	rjmp	.+16     	; 0xeca0 <conv_flt+0x9e>
    ec90:	0e 94 67 7a 	call	0xf4ce	; 0xf4ce <tolower>
    ec94:	d8 16       	cp	r13, r24
    ec96:	61 f0       	breq	.+24     	; 0xecb0 <conv_flt+0xae>
    ec98:	ce 01       	movw	r24, r28
    ec9a:	b3 01       	movw	r22, r6
    ec9c:	0e 94 1e 7c 	call	0xf83c	; 0xf83c <ungetc>
    eca0:	22 e0       	ldi	r18, 0x02	; 2
    eca2:	0a 3e       	cpi	r16, 0xEA	; 234
    eca4:	12 07       	cpc	r17, r18
    eca6:	09 f0       	breq	.+2      	; 0xecaa <conv_flt+0xa8>
    eca8:	ec c0       	rjmp	.+472    	; 0xee82 <conv_flt+0x280>
    ecaa:	08 c0       	rjmp	.+16     	; 0xecbc <conv_flt+0xba>
    ecac:	04 ee       	ldi	r16, 0xE4	; 228
    ecae:	12 e0       	ldi	r17, 0x02	; 2
    ecb0:	f8 01       	movw	r30, r16
    ecb2:	0f 5f       	subi	r16, 0xFF	; 255
    ecb4:	1f 4f       	sbci	r17, 0xFF	; 255
    ecb6:	d4 90       	lpm	r13, Z+
    ecb8:	dd 20       	and	r13, r13
    ecba:	f1 f6       	brne	.-68     	; 0xec78 <conv_flt+0x76>
    ecbc:	07 5e       	subi	r16, 0xE7	; 231
    ecbe:	12 40       	sbci	r17, 0x02	; 2
    ecc0:	29 f0       	breq	.+10     	; 0xeccc <conv_flt+0xca>
    ecc2:	80 e0       	ldi	r24, 0x00	; 0
    ecc4:	90 e0       	ldi	r25, 0x00	; 0
    ecc6:	a0 e8       	ldi	r26, 0x80	; 128
    ecc8:	bf e7       	ldi	r27, 0x7F	; 127
    ecca:	cf c0       	rjmp	.+414    	; 0xee6a <conv_flt+0x268>
    eccc:	80 e0       	ldi	r24, 0x00	; 0
    ecce:	90 e0       	ldi	r25, 0x00	; 0
    ecd0:	a0 ec       	ldi	r26, 0xC0	; 192
    ecd2:	bf e7       	ldi	r27, 0x7F	; 127
    ecd4:	ca c0       	rjmp	.+404    	; 0xee6a <conv_flt+0x268>
    ecd6:	cc 24       	eor	r12, r12
    ecd8:	dd 24       	eor	r13, r13
    ecda:	88 24       	eor	r8, r8
    ecdc:	99 24       	eor	r9, r9
    ecde:	54 01       	movw	r10, r8
    ece0:	ae 01       	movw	r20, r28
    ece2:	40 53       	subi	r20, 0x30	; 48
    ece4:	24 2f       	mov	r18, r20
    ece6:	4a 30       	cpi	r20, 0x0A	; 10
    ece8:	38 f5       	brcc	.+78     	; 0xed38 <conv_flt+0x136>
    ecea:	52 e0       	ldi	r21, 0x02	; 2
    ecec:	55 2a       	or	r5, r21
    ecee:	85 2d       	mov	r24, r5
    ecf0:	90 e0       	ldi	r25, 0x00	; 0
    ecf2:	ac 01       	movw	r20, r24
    ecf4:	48 70       	andi	r20, 0x08	; 8
    ecf6:	50 70       	andi	r21, 0x00	; 0
    ecf8:	52 fe       	sbrs	r5, 2
    ecfa:	06 c0       	rjmp	.+12     	; 0xed08 <conv_flt+0x106>
    ecfc:	45 2b       	or	r20, r21
    ecfe:	11 f5       	brne	.+68     	; 0xed44 <conv_flt+0x142>
    ed00:	08 94       	sec
    ed02:	c1 1c       	adc	r12, r1
    ed04:	d1 1c       	adc	r13, r1
    ed06:	1e c0       	rjmp	.+60     	; 0xed44 <conv_flt+0x142>
    ed08:	45 2b       	or	r20, r21
    ed0a:	19 f0       	breq	.+6      	; 0xed12 <conv_flt+0x110>
    ed0c:	08 94       	sec
    ed0e:	c1 08       	sbc	r12, r1
    ed10:	d1 08       	sbc	r13, r1
    ed12:	c5 01       	movw	r24, r10
    ed14:	b4 01       	movw	r22, r8
    ed16:	40 e2       	ldi	r20, 0x20	; 32
    ed18:	0e 94 59 74 	call	0xe8b2	; 0xe8b2 <mulacc>
    ed1c:	4b 01       	movw	r8, r22
    ed1e:	5c 01       	movw	r10, r24
    ed20:	88 e9       	ldi	r24, 0x98	; 152
    ed22:	88 16       	cp	r8, r24
    ed24:	89 e9       	ldi	r24, 0x99	; 153
    ed26:	98 06       	cpc	r9, r24
    ed28:	89 e9       	ldi	r24, 0x99	; 153
    ed2a:	a8 06       	cpc	r10, r24
    ed2c:	89 e1       	ldi	r24, 0x19	; 25
    ed2e:	b8 06       	cpc	r11, r24
    ed30:	48 f0       	brcs	.+18     	; 0xed44 <conv_flt+0x142>
    ed32:	94 e0       	ldi	r25, 0x04	; 4
    ed34:	59 2a       	or	r5, r25
    ed36:	06 c0       	rjmp	.+12     	; 0xed44 <conv_flt+0x142>
    ed38:	4e 3f       	cpi	r20, 0xFE	; 254
    ed3a:	81 f4       	brne	.+32     	; 0xed5c <conv_flt+0x15a>
    ed3c:	53 fc       	sbrc	r5, 3
    ed3e:	0e c0       	rjmp	.+28     	; 0xed5c <conv_flt+0x15a>
    ed40:	e8 e0       	ldi	r30, 0x08	; 8
    ed42:	5e 2a       	or	r5, r30
    ed44:	08 94       	sec
    ed46:	e1 08       	sbc	r14, r1
    ed48:	f1 08       	sbc	r15, r1
    ed4a:	e1 14       	cp	r14, r1
    ed4c:	f1 04       	cpc	r15, r1
    ed4e:	31 f0       	breq	.+12     	; 0xed5c <conv_flt+0x15a>
    ed50:	c3 01       	movw	r24, r6
    ed52:	0e 94 08 7b 	call	0xf610	; 0xf610 <fgetc>
    ed56:	ec 01       	movw	r28, r24
    ed58:	97 ff       	sbrs	r25, 7
    ed5a:	c2 cf       	rjmp	.-124    	; 0xece0 <conv_flt+0xde>
    ed5c:	51 fe       	sbrs	r5, 1
    ed5e:	91 c0       	rjmp	.+290    	; 0xee82 <conv_flt+0x280>
    ed60:	c5 36       	cpi	r28, 0x65	; 101
    ed62:	19 f0       	breq	.+6      	; 0xed6a <conv_flt+0x168>
    ed64:	c5 34       	cpi	r28, 0x45	; 69
    ed66:	09 f0       	breq	.+2      	; 0xed6a <conv_flt+0x168>
    ed68:	46 c0       	rjmp	.+140    	; 0xedf6 <conv_flt+0x1f4>
    ed6a:	08 94       	sec
    ed6c:	e1 08       	sbc	r14, r1
    ed6e:	f1 08       	sbc	r15, r1
    ed70:	e1 14       	cp	r14, r1
    ed72:	f1 04       	cpc	r15, r1
    ed74:	09 f4       	brne	.+2      	; 0xed78 <conv_flt+0x176>
    ed76:	85 c0       	rjmp	.+266    	; 0xee82 <conv_flt+0x280>
    ed78:	c3 01       	movw	r24, r6
    ed7a:	0e 94 08 7b 	call	0xf610	; 0xf610 <fgetc>
    ed7e:	ec 01       	movw	r28, r24
    ed80:	97 fd       	sbrc	r25, 7
    ed82:	7f c0       	rjmp	.+254    	; 0xee82 <conv_flt+0x280>
    ed84:	8b 32       	cpi	r24, 0x2B	; 43
    ed86:	21 f0       	breq	.+8      	; 0xed90 <conv_flt+0x18e>
    ed88:	8d 32       	cpi	r24, 0x2D	; 45
    ed8a:	69 f4       	brne	.+26     	; 0xeda6 <conv_flt+0x1a4>
    ed8c:	f0 e1       	ldi	r31, 0x10	; 16
    ed8e:	5f 2a       	or	r5, r31
    ed90:	08 94       	sec
    ed92:	e1 08       	sbc	r14, r1
    ed94:	f1 08       	sbc	r15, r1
    ed96:	e1 14       	cp	r14, r1
    ed98:	f1 04       	cpc	r15, r1
    ed9a:	09 f4       	brne	.+2      	; 0xed9e <conv_flt+0x19c>
    ed9c:	72 c0       	rjmp	.+228    	; 0xee82 <conv_flt+0x280>
    ed9e:	c3 01       	movw	r24, r6
    eda0:	0e 94 08 7b 	call	0xf610	; 0xf610 <fgetc>
    eda4:	ec 01       	movw	r28, r24
    eda6:	ce 01       	movw	r24, r28
    eda8:	c0 97       	sbiw	r24, 0x30	; 48
    edaa:	0a 97       	sbiw	r24, 0x0a	; 10
    edac:	08 f0       	brcs	.+2      	; 0xedb0 <conv_flt+0x1ae>
    edae:	69 c0       	rjmp	.+210    	; 0xee82 <conv_flt+0x280>
    edb0:	00 e0       	ldi	r16, 0x00	; 0
    edb2:	10 e0       	ldi	r17, 0x00	; 0
    edb4:	b8 01       	movw	r22, r16
    edb6:	88 27       	eor	r24, r24
    edb8:	77 fd       	sbrc	r23, 7
    edba:	80 95       	com	r24
    edbc:	98 2f       	mov	r25, r24
    edbe:	ae 01       	movw	r20, r28
    edc0:	40 53       	subi	r20, 0x30	; 48
    edc2:	24 2f       	mov	r18, r20
    edc4:	40 e2       	ldi	r20, 0x20	; 32
    edc6:	0e 94 59 74 	call	0xe8b2	; 0xe8b2 <mulacc>
    edca:	8b 01       	movw	r16, r22
    edcc:	08 94       	sec
    edce:	e1 08       	sbc	r14, r1
    edd0:	f1 08       	sbc	r15, r1
    edd2:	e1 14       	cp	r14, r1
    edd4:	f1 04       	cpc	r15, r1
    edd6:	39 f0       	breq	.+14     	; 0xede6 <conv_flt+0x1e4>
    edd8:	c3 01       	movw	r24, r6
    edda:	0e 94 08 7b 	call	0xf610	; 0xf610 <fgetc>
    edde:	ec 01       	movw	r28, r24
    ede0:	c0 97       	sbiw	r24, 0x30	; 48
    ede2:	0a 97       	sbiw	r24, 0x0a	; 10
    ede4:	38 f3       	brcs	.-50     	; 0xedb4 <conv_flt+0x1b2>
    ede6:	b8 01       	movw	r22, r16
    ede8:	54 fe       	sbrs	r5, 4
    edea:	03 c0       	rjmp	.+6      	; 0xedf2 <conv_flt+0x1f0>
    edec:	70 95       	com	r23
    edee:	61 95       	neg	r22
    edf0:	7f 4f       	sbci	r23, 0xFF	; 255
    edf2:	c6 0e       	add	r12, r22
    edf4:	d7 1e       	adc	r13, r23
    edf6:	ef 28       	or	r14, r15
    edf8:	31 f0       	breq	.+12     	; 0xee06 <conv_flt+0x204>
    edfa:	d7 fd       	sbrc	r29, 7
    edfc:	04 c0       	rjmp	.+8      	; 0xee06 <conv_flt+0x204>
    edfe:	ce 01       	movw	r24, r28
    ee00:	b3 01       	movw	r22, r6
    ee02:	0e 94 1e 7c 	call	0xf83c	; 0xf83c <ungetc>
    ee06:	c5 01       	movw	r24, r10
    ee08:	b4 01       	movw	r22, r8
    ee0a:	0e 94 93 78 	call	0xf126	; 0xf126 <__floatunsisf>
    ee0e:	d7 fe       	sbrs	r13, 7
    ee10:	0d c0       	rjmp	.+26     	; 0xee2c <conv_flt+0x22a>
    ee12:	a3 e0       	ldi	r26, 0x03	; 3
    ee14:	ea 2e       	mov	r14, r26
    ee16:	a3 e0       	ldi	r26, 0x03	; 3
    ee18:	fa 2e       	mov	r15, r26
    ee1a:	d0 94       	com	r13
    ee1c:	c1 94       	neg	r12
    ee1e:	d1 08       	sbc	r13, r1
    ee20:	d3 94       	inc	r13
    ee22:	c0 e2       	ldi	r28, 0x20	; 32
    ee24:	d0 e0       	ldi	r29, 0x00	; 0
    ee26:	00 e0       	ldi	r16, 0x00	; 0
    ee28:	10 e0       	ldi	r17, 0x00	; 0
    ee2a:	0e c0       	rjmp	.+28     	; 0xee48 <conv_flt+0x246>
    ee2c:	fb e1       	ldi	r31, 0x1B	; 27
    ee2e:	ef 2e       	mov	r14, r31
    ee30:	f3 e0       	ldi	r31, 0x03	; 3
    ee32:	ff 2e       	mov	r15, r31
    ee34:	f6 cf       	rjmp	.-20     	; 0xee22 <conv_flt+0x220>
    ee36:	f7 01       	movw	r30, r14
    ee38:	25 91       	lpm	r18, Z+
    ee3a:	35 91       	lpm	r19, Z+
    ee3c:	45 91       	lpm	r20, Z+
    ee3e:	54 91       	lpm	r21, Z+
    ee40:	0e 94 d0 78 	call	0xf1a0	; 0xf1a0 <__mulsf3>
    ee44:	cc 1a       	sub	r12, r28
    ee46:	dd 0a       	sbc	r13, r29
    ee48:	cc 16       	cp	r12, r28
    ee4a:	dd 06       	cpc	r13, r29
    ee4c:	a0 f7       	brcc	.-24     	; 0xee36 <conv_flt+0x234>
    ee4e:	d6 95       	lsr	r29
    ee50:	c7 95       	ror	r28
    ee52:	0f 5f       	subi	r16, 0xFF	; 255
    ee54:	1f 4f       	sbci	r17, 0xFF	; 255
    ee56:	06 30       	cpi	r16, 0x06	; 6
    ee58:	11 05       	cpc	r17, r1
    ee5a:	29 f0       	breq	.+10     	; 0xee66 <conv_flt+0x264>
    ee5c:	ec ef       	ldi	r30, 0xFC	; 252
    ee5e:	ff ef       	ldi	r31, 0xFF	; 255
    ee60:	ee 0e       	add	r14, r30
    ee62:	ff 1e       	adc	r15, r31
    ee64:	f1 cf       	rjmp	.-30     	; 0xee48 <conv_flt+0x246>
    ee66:	dc 01       	movw	r26, r24
    ee68:	cb 01       	movw	r24, r22
    ee6a:	57 fc       	sbrc	r5, 7
    ee6c:	b0 58       	subi	r27, 0x80	; 128
    ee6e:	21 14       	cp	r2, r1
    ee70:	31 04       	cpc	r3, r1
    ee72:	29 f0       	breq	.+10     	; 0xee7e <conv_flt+0x27c>
    ee74:	f1 01       	movw	r30, r2
    ee76:	80 83       	st	Z, r24
    ee78:	91 83       	std	Z+1, r25	; 0x01
    ee7a:	a2 83       	std	Z+2, r26	; 0x02
    ee7c:	b3 83       	std	Z+3, r27	; 0x03
    ee7e:	81 e0       	ldi	r24, 0x01	; 1
    ee80:	01 c0       	rjmp	.+2      	; 0xee84 <conv_flt+0x282>
    ee82:	80 e0       	ldi	r24, 0x00	; 0
    ee84:	df 91       	pop	r29
    ee86:	cf 91       	pop	r28
    ee88:	1f 91       	pop	r17
    ee8a:	0f 91       	pop	r16
    ee8c:	ff 90       	pop	r15
    ee8e:	ef 90       	pop	r14
    ee90:	df 90       	pop	r13
    ee92:	cf 90       	pop	r12
    ee94:	bf 90       	pop	r11
    ee96:	af 90       	pop	r10
    ee98:	9f 90       	pop	r9
    ee9a:	8f 90       	pop	r8
    ee9c:	7f 90       	pop	r7
    ee9e:	6f 90       	pop	r6
    eea0:	5f 90       	pop	r5
    eea2:	3f 90       	pop	r3
    eea4:	2f 90       	pop	r2
    eea6:	08 95       	ret

0000eea8 <vfscanf>:
    eea8:	5f 92       	push	r5
    eeaa:	6f 92       	push	r6
    eeac:	7f 92       	push	r7
    eeae:	8f 92       	push	r8
    eeb0:	9f 92       	push	r9
    eeb2:	af 92       	push	r10
    eeb4:	bf 92       	push	r11
    eeb6:	cf 92       	push	r12
    eeb8:	df 92       	push	r13
    eeba:	ef 92       	push	r14
    eebc:	ff 92       	push	r15
    eebe:	0f 93       	push	r16
    eec0:	1f 93       	push	r17
    eec2:	cf 93       	push	r28
    eec4:	df 93       	push	r29
    eec6:	4c 01       	movw	r8, r24
    eec8:	5b 01       	movw	r10, r22
    eeca:	3a 01       	movw	r6, r20
    eecc:	fc 01       	movw	r30, r24
    eece:	17 82       	std	Z+7, r1	; 0x07
    eed0:	16 82       	std	Z+6, r1	; 0x06
    eed2:	55 24       	eor	r5, r5
    eed4:	04 c1       	rjmp	.+520    	; 0xf0de <vfscanf+0x236>
    eed6:	81 2f       	mov	r24, r17
    eed8:	90 e0       	ldi	r25, 0x00	; 0
    eeda:	0e 94 5f 7a 	call	0xf4be	; 0xf4be <isspace>
    eede:	89 2b       	or	r24, r25
    eee0:	21 f0       	breq	.+8      	; 0xeeea <vfscanf+0x42>
    eee2:	c4 01       	movw	r24, r8
    eee4:	0e 94 87 74 	call	0xe90e	; 0xe90e <skip_spaces>
    eee8:	fa c0       	rjmp	.+500    	; 0xf0de <vfscanf+0x236>
    eeea:	15 32       	cpi	r17, 0x25	; 37
    eeec:	49 f4       	brne	.+18     	; 0xef00 <vfscanf+0x58>
    eeee:	f5 01       	movw	r30, r10
    eef0:	f3 fc       	sbrc	r15, 3
    eef2:	65 91       	lpm	r22, Z+
    eef4:	f3 fe       	sbrs	r15, 3
    eef6:	61 91       	ld	r22, Z+
    eef8:	5f 01       	movw	r10, r30
    eefa:	65 32       	cpi	r22, 0x25	; 37
    eefc:	69 f4       	brne	.+26     	; 0xef18 <vfscanf+0x70>
    eefe:	15 e2       	ldi	r17, 0x25	; 37
    ef00:	c4 01       	movw	r24, r8
    ef02:	0e 94 08 7b 	call	0xf610	; 0xf610 <fgetc>
    ef06:	97 fd       	sbrc	r25, 7
    ef08:	f6 c0       	rjmp	.+492    	; 0xf0f6 <vfscanf+0x24e>
    ef0a:	18 17       	cp	r17, r24
    ef0c:	09 f4       	brne	.+2      	; 0xef10 <vfscanf+0x68>
    ef0e:	e7 c0       	rjmp	.+462    	; 0xf0de <vfscanf+0x236>
    ef10:	b4 01       	movw	r22, r8
    ef12:	0e 94 1e 7c 	call	0xf83c	; 0xf83c <ungetc>
    ef16:	f4 c0       	rjmp	.+488    	; 0xf100 <vfscanf+0x258>
    ef18:	6a 32       	cpi	r22, 0x2A	; 42
    ef1a:	19 f0       	breq	.+6      	; 0xef22 <vfscanf+0x7a>
    ef1c:	16 2f       	mov	r17, r22
    ef1e:	00 e0       	ldi	r16, 0x00	; 0
    ef20:	06 c0       	rjmp	.+12     	; 0xef2e <vfscanf+0x86>
    ef22:	f3 fc       	sbrc	r15, 3
    ef24:	15 91       	lpm	r17, Z+
    ef26:	f3 fe       	sbrs	r15, 3
    ef28:	11 91       	ld	r17, Z+
    ef2a:	5f 01       	movw	r10, r30
    ef2c:	01 e0       	ldi	r16, 0x01	; 1
    ef2e:	cc 24       	eor	r12, r12
    ef30:	dd 24       	eor	r13, r13
    ef32:	0e c0       	rjmp	.+28     	; 0xef50 <vfscanf+0xa8>
    ef34:	02 60       	ori	r16, 0x02	; 2
    ef36:	b6 01       	movw	r22, r12
    ef38:	80 e0       	ldi	r24, 0x00	; 0
    ef3a:	90 e0       	ldi	r25, 0x00	; 0
    ef3c:	40 e2       	ldi	r20, 0x20	; 32
    ef3e:	0e 94 59 74 	call	0xe8b2	; 0xe8b2 <mulacc>
    ef42:	6b 01       	movw	r12, r22
    ef44:	f5 01       	movw	r30, r10
    ef46:	f3 fc       	sbrc	r15, 3
    ef48:	15 91       	lpm	r17, Z+
    ef4a:	f3 fe       	sbrs	r15, 3
    ef4c:	11 91       	ld	r17, Z+
    ef4e:	5f 01       	movw	r10, r30
    ef50:	21 2f       	mov	r18, r17
    ef52:	20 53       	subi	r18, 0x30	; 48
    ef54:	2a 30       	cpi	r18, 0x0A	; 10
    ef56:	70 f3       	brcs	.-36     	; 0xef34 <vfscanf+0x8c>
    ef58:	01 fd       	sbrc	r16, 1
    ef5a:	04 c0       	rjmp	.+8      	; 0xef64 <vfscanf+0xbc>
    ef5c:	cc 24       	eor	r12, r12
    ef5e:	ca 94       	dec	r12
    ef60:	dc 2c       	mov	r13, r12
    ef62:	04 c0       	rjmp	.+8      	; 0xef6c <vfscanf+0xc4>
    ef64:	c1 14       	cp	r12, r1
    ef66:	d1 04       	cpc	r13, r1
    ef68:	09 f4       	brne	.+2      	; 0xef6c <vfscanf+0xc4>
    ef6a:	ca c0       	rjmp	.+404    	; 0xf100 <vfscanf+0x258>
    ef6c:	18 36       	cpi	r17, 0x68	; 104
    ef6e:	21 f0       	breq	.+8      	; 0xef78 <vfscanf+0xd0>
    ef70:	1c 36       	cpi	r17, 0x6C	; 108
    ef72:	99 f4       	brne	.+38     	; 0xef9a <vfscanf+0xf2>
    ef74:	f5 01       	movw	r30, r10
    ef76:	0b c0       	rjmp	.+22     	; 0xef8e <vfscanf+0xe6>
    ef78:	f5 01       	movw	r30, r10
    ef7a:	f3 fc       	sbrc	r15, 3
    ef7c:	65 91       	lpm	r22, Z+
    ef7e:	f3 fe       	sbrs	r15, 3
    ef80:	61 91       	ld	r22, Z+
    ef82:	68 36       	cpi	r22, 0x68	; 104
    ef84:	19 f0       	breq	.+6      	; 0xef8c <vfscanf+0xe4>
    ef86:	5f 01       	movw	r10, r30
    ef88:	16 2f       	mov	r17, r22
    ef8a:	07 c0       	rjmp	.+14     	; 0xef9a <vfscanf+0xf2>
    ef8c:	08 60       	ori	r16, 0x08	; 8
    ef8e:	04 60       	ori	r16, 0x04	; 4
    ef90:	f3 fc       	sbrc	r15, 3
    ef92:	15 91       	lpm	r17, Z+
    ef94:	f3 fe       	sbrs	r15, 3
    ef96:	11 91       	ld	r17, Z+
    ef98:	5f 01       	movw	r10, r30
    ef9a:	11 23       	and	r17, r17
    ef9c:	09 f4       	brne	.+2      	; 0xefa0 <vfscanf+0xf8>
    ef9e:	b0 c0       	rjmp	.+352    	; 0xf100 <vfscanf+0x258>
    efa0:	82 ed       	ldi	r24, 0xD2	; 210
    efa2:	92 e0       	ldi	r25, 0x02	; 2
    efa4:	61 2f       	mov	r22, r17
    efa6:	70 e0       	ldi	r23, 0x00	; 0
    efa8:	0e 94 6f 7a 	call	0xf4de	; 0xf4de <strchr_P>
    efac:	89 2b       	or	r24, r25
    efae:	09 f4       	brne	.+2      	; 0xefb2 <vfscanf+0x10a>
    efb0:	a7 c0       	rjmp	.+334    	; 0xf100 <vfscanf+0x258>
    efb2:	80 2f       	mov	r24, r16
    efb4:	00 ff       	sbrs	r16, 0
    efb6:	03 c0       	rjmp	.+6      	; 0xefbe <vfscanf+0x116>
    efb8:	ee 24       	eor	r14, r14
    efba:	ff 24       	eor	r15, r15
    efbc:	07 c0       	rjmp	.+14     	; 0xefcc <vfscanf+0x124>
    efbe:	f3 01       	movw	r30, r6
    efc0:	e0 80       	ld	r14, Z
    efc2:	f1 80       	ldd	r15, Z+1	; 0x01
    efc4:	22 e0       	ldi	r18, 0x02	; 2
    efc6:	30 e0       	ldi	r19, 0x00	; 0
    efc8:	62 0e       	add	r6, r18
    efca:	73 1e       	adc	r7, r19
    efcc:	1e 36       	cpi	r17, 0x6E	; 110
    efce:	51 f4       	brne	.+20     	; 0xefe4 <vfscanf+0x13c>
    efd0:	f4 01       	movw	r30, r8
    efd2:	46 81       	ldd	r20, Z+6	; 0x06
    efd4:	57 81       	ldd	r21, Z+7	; 0x07
    efd6:	60 e0       	ldi	r22, 0x00	; 0
    efd8:	70 e0       	ldi	r23, 0x00	; 0
    efda:	c7 01       	movw	r24, r14
    efdc:	20 2f       	mov	r18, r16
    efde:	0e 94 4d 74 	call	0xe89a	; 0xe89a <putval>
    efe2:	7d c0       	rjmp	.+250    	; 0xf0de <vfscanf+0x236>
    efe4:	13 36       	cpi	r17, 0x63	; 99
    efe6:	b9 f4       	brne	.+46     	; 0xf016 <vfscanf+0x16e>
    efe8:	81 fd       	sbrc	r24, 1
    efea:	03 c0       	rjmp	.+6      	; 0xeff2 <vfscanf+0x14a>
    efec:	11 e0       	ldi	r17, 0x01	; 1
    efee:	c1 2e       	mov	r12, r17
    eff0:	d1 2c       	mov	r13, r1
    eff2:	c4 01       	movw	r24, r8
    eff4:	0e 94 08 7b 	call	0xf610	; 0xf610 <fgetc>
    eff8:	97 fd       	sbrc	r25, 7
    effa:	7d c0       	rjmp	.+250    	; 0xf0f6 <vfscanf+0x24e>
    effc:	e1 14       	cp	r14, r1
    effe:	f1 04       	cpc	r15, r1
    f000:	19 f0       	breq	.+6      	; 0xf008 <vfscanf+0x160>
    f002:	f7 01       	movw	r30, r14
    f004:	81 93       	st	Z+, r24
    f006:	7f 01       	movw	r14, r30
    f008:	08 94       	sec
    f00a:	c1 08       	sbc	r12, r1
    f00c:	d1 08       	sbc	r13, r1
    f00e:	c1 14       	cp	r12, r1
    f010:	d1 04       	cpc	r13, r1
    f012:	79 f7       	brne	.-34     	; 0xeff2 <vfscanf+0x14a>
    f014:	62 c0       	rjmp	.+196    	; 0xf0da <vfscanf+0x232>
    f016:	1b 35       	cpi	r17, 0x5B	; 91
    f018:	59 f4       	brne	.+22     	; 0xf030 <vfscanf+0x188>
    f01a:	c4 01       	movw	r24, r8
    f01c:	b6 01       	movw	r22, r12
    f01e:	a7 01       	movw	r20, r14
    f020:	95 01       	movw	r18, r10
    f022:	0e 94 34 75 	call	0xea68	; 0xea68 <conv_brk>
    f026:	5c 01       	movw	r10, r24
    f028:	00 97       	sbiw	r24, 0x00	; 0
    f02a:	09 f0       	breq	.+2      	; 0xf02e <vfscanf+0x186>
    f02c:	56 c0       	rjmp	.+172    	; 0xf0da <vfscanf+0x232>
    f02e:	50 c0       	rjmp	.+160    	; 0xf0d0 <vfscanf+0x228>
    f030:	c4 01       	movw	r24, r8
    f032:	0e 94 87 74 	call	0xe90e	; 0xe90e <skip_spaces>
    f036:	97 fd       	sbrc	r25, 7
    f038:	5e c0       	rjmp	.+188    	; 0xf0f6 <vfscanf+0x24e>
    f03a:	1f 36       	cpi	r17, 0x6F	; 111
    f03c:	d1 f1       	breq	.+116    	; 0xf0b2 <vfscanf+0x20a>
    f03e:	10 37       	cpi	r17, 0x70	; 112
    f040:	38 f4       	brcc	.+14     	; 0xf050 <vfscanf+0x1a8>
    f042:	14 36       	cpi	r17, 0x64	; 100
    f044:	a1 f1       	breq	.+104    	; 0xf0ae <vfscanf+0x206>
    f046:	19 36       	cpi	r17, 0x69	; 105
    f048:	a9 f1       	breq	.+106    	; 0xf0b4 <vfscanf+0x20c>
    f04a:	18 35       	cpi	r17, 0x58	; 88
    f04c:	d1 f5       	brne	.+116    	; 0xf0c2 <vfscanf+0x21a>
    f04e:	2d c0       	rjmp	.+90     	; 0xf0aa <vfscanf+0x202>
    f050:	13 37       	cpi	r17, 0x73	; 115
    f052:	51 f0       	breq	.+20     	; 0xf068 <vfscanf+0x1c0>
    f054:	14 37       	cpi	r17, 0x74	; 116
    f056:	18 f4       	brcc	.+6      	; 0xf05e <vfscanf+0x1b6>
    f058:	10 37       	cpi	r17, 0x70	; 112
    f05a:	99 f5       	brne	.+102    	; 0xf0c2 <vfscanf+0x21a>
    f05c:	26 c0       	rjmp	.+76     	; 0xf0aa <vfscanf+0x202>
    f05e:	15 37       	cpi	r17, 0x75	; 117
    f060:	31 f1       	breq	.+76     	; 0xf0ae <vfscanf+0x206>
    f062:	18 37       	cpi	r17, 0x78	; 120
    f064:	71 f5       	brne	.+92     	; 0xf0c2 <vfscanf+0x21a>
    f066:	21 c0       	rjmp	.+66     	; 0xf0aa <vfscanf+0x202>
    f068:	c4 01       	movw	r24, r8
    f06a:	0e 94 08 7b 	call	0xf610	; 0xf610 <fgetc>
    f06e:	ec 01       	movw	r28, r24
    f070:	97 fd       	sbrc	r25, 7
    f072:	15 c0       	rjmp	.+42     	; 0xf09e <vfscanf+0x1f6>
    f074:	0e 94 5f 7a 	call	0xf4be	; 0xf4be <isspace>
    f078:	89 2b       	or	r24, r25
    f07a:	29 f0       	breq	.+10     	; 0xf086 <vfscanf+0x1de>
    f07c:	ce 01       	movw	r24, r28
    f07e:	b4 01       	movw	r22, r8
    f080:	0e 94 1e 7c 	call	0xf83c	; 0xf83c <ungetc>
    f084:	0c c0       	rjmp	.+24     	; 0xf09e <vfscanf+0x1f6>
    f086:	e1 14       	cp	r14, r1
    f088:	f1 04       	cpc	r15, r1
    f08a:	19 f0       	breq	.+6      	; 0xf092 <vfscanf+0x1ea>
    f08c:	f7 01       	movw	r30, r14
    f08e:	c1 93       	st	Z+, r28
    f090:	7f 01       	movw	r14, r30
    f092:	08 94       	sec
    f094:	c1 08       	sbc	r12, r1
    f096:	d1 08       	sbc	r13, r1
    f098:	c1 14       	cp	r12, r1
    f09a:	d1 04       	cpc	r13, r1
    f09c:	29 f7       	brne	.-54     	; 0xf068 <vfscanf+0x1c0>
    f09e:	e1 14       	cp	r14, r1
    f0a0:	f1 04       	cpc	r15, r1
    f0a2:	d9 f0       	breq	.+54     	; 0xf0da <vfscanf+0x232>
    f0a4:	f7 01       	movw	r30, r14
    f0a6:	10 82       	st	Z, r1
    f0a8:	18 c0       	rjmp	.+48     	; 0xf0da <vfscanf+0x232>
    f0aa:	00 64       	ori	r16, 0x40	; 64
    f0ac:	03 c0       	rjmp	.+6      	; 0xf0b4 <vfscanf+0x20c>
    f0ae:	00 62       	ori	r16, 0x20	; 32
    f0b0:	01 c0       	rjmp	.+2      	; 0xf0b4 <vfscanf+0x20c>
    f0b2:	00 61       	ori	r16, 0x10	; 16
    f0b4:	c4 01       	movw	r24, r8
    f0b6:	b6 01       	movw	r22, r12
    f0b8:	a7 01       	movw	r20, r14
    f0ba:	20 2f       	mov	r18, r16
    f0bc:	0e 94 a0 74 	call	0xe940	; 0xe940 <conv_int>
    f0c0:	05 c0       	rjmp	.+10     	; 0xf0cc <vfscanf+0x224>
    f0c2:	c4 01       	movw	r24, r8
    f0c4:	b6 01       	movw	r22, r12
    f0c6:	a7 01       	movw	r20, r14
    f0c8:	0e 94 01 76 	call	0xec02	; 0xec02 <conv_flt>
    f0cc:	88 23       	and	r24, r24
    f0ce:	29 f4       	brne	.+10     	; 0xf0da <vfscanf+0x232>
    f0d0:	f4 01       	movw	r30, r8
    f0d2:	83 81       	ldd	r24, Z+3	; 0x03
    f0d4:	80 73       	andi	r24, 0x30	; 48
    f0d6:	79 f4       	brne	.+30     	; 0xf0f6 <vfscanf+0x24e>
    f0d8:	13 c0       	rjmp	.+38     	; 0xf100 <vfscanf+0x258>
    f0da:	00 ff       	sbrs	r16, 0
    f0dc:	53 94       	inc	r5
    f0de:	f4 01       	movw	r30, r8
    f0e0:	f3 80       	ldd	r15, Z+3	; 0x03
    f0e2:	f5 01       	movw	r30, r10
    f0e4:	f3 fc       	sbrc	r15, 3
    f0e6:	15 91       	lpm	r17, Z+
    f0e8:	f3 fe       	sbrs	r15, 3
    f0ea:	11 91       	ld	r17, Z+
    f0ec:	5f 01       	movw	r10, r30
    f0ee:	11 23       	and	r17, r17
    f0f0:	09 f0       	breq	.+2      	; 0xf0f4 <vfscanf+0x24c>
    f0f2:	f1 ce       	rjmp	.-542    	; 0xeed6 <vfscanf+0x2e>
    f0f4:	05 c0       	rjmp	.+10     	; 0xf100 <vfscanf+0x258>
    f0f6:	55 20       	and	r5, r5
    f0f8:	19 f4       	brne	.+6      	; 0xf100 <vfscanf+0x258>
    f0fa:	2f ef       	ldi	r18, 0xFF	; 255
    f0fc:	3f ef       	ldi	r19, 0xFF	; 255
    f0fe:	02 c0       	rjmp	.+4      	; 0xf104 <vfscanf+0x25c>
    f100:	25 2d       	mov	r18, r5
    f102:	30 e0       	ldi	r19, 0x00	; 0
    f104:	c9 01       	movw	r24, r18
    f106:	df 91       	pop	r29
    f108:	cf 91       	pop	r28
    f10a:	1f 91       	pop	r17
    f10c:	0f 91       	pop	r16
    f10e:	ff 90       	pop	r15
    f110:	ef 90       	pop	r14
    f112:	df 90       	pop	r13
    f114:	cf 90       	pop	r12
    f116:	bf 90       	pop	r11
    f118:	af 90       	pop	r10
    f11a:	9f 90       	pop	r9
    f11c:	8f 90       	pop	r8
    f11e:	7f 90       	pop	r7
    f120:	6f 90       	pop	r6
    f122:	5f 90       	pop	r5
    f124:	08 95       	ret

0000f126 <__floatunsisf>:
    f126:	e8 94       	clt
    f128:	09 c0       	rjmp	.+18     	; 0xf13c <__floatsisf+0x12>

0000f12a <__floatsisf>:
    f12a:	97 fb       	bst	r25, 7
    f12c:	3e f4       	brtc	.+14     	; 0xf13c <__floatsisf+0x12>
    f12e:	90 95       	com	r25
    f130:	80 95       	com	r24
    f132:	70 95       	com	r23
    f134:	61 95       	neg	r22
    f136:	7f 4f       	sbci	r23, 0xFF	; 255
    f138:	8f 4f       	sbci	r24, 0xFF	; 255
    f13a:	9f 4f       	sbci	r25, 0xFF	; 255
    f13c:	99 23       	and	r25, r25
    f13e:	a9 f0       	breq	.+42     	; 0xf16a <__floatsisf+0x40>
    f140:	f9 2f       	mov	r31, r25
    f142:	96 e9       	ldi	r25, 0x96	; 150
    f144:	bb 27       	eor	r27, r27
    f146:	93 95       	inc	r25
    f148:	f6 95       	lsr	r31
    f14a:	87 95       	ror	r24
    f14c:	77 95       	ror	r23
    f14e:	67 95       	ror	r22
    f150:	b7 95       	ror	r27
    f152:	f1 11       	cpse	r31, r1
    f154:	f8 cf       	rjmp	.-16     	; 0xf146 <__floatsisf+0x1c>
    f156:	fa f4       	brpl	.+62     	; 0xf196 <__floatsisf+0x6c>
    f158:	bb 0f       	add	r27, r27
    f15a:	11 f4       	brne	.+4      	; 0xf160 <__floatsisf+0x36>
    f15c:	60 ff       	sbrs	r22, 0
    f15e:	1b c0       	rjmp	.+54     	; 0xf196 <__floatsisf+0x6c>
    f160:	6f 5f       	subi	r22, 0xFF	; 255
    f162:	7f 4f       	sbci	r23, 0xFF	; 255
    f164:	8f 4f       	sbci	r24, 0xFF	; 255
    f166:	9f 4f       	sbci	r25, 0xFF	; 255
    f168:	16 c0       	rjmp	.+44     	; 0xf196 <__floatsisf+0x6c>
    f16a:	88 23       	and	r24, r24
    f16c:	11 f0       	breq	.+4      	; 0xf172 <__floatsisf+0x48>
    f16e:	96 e9       	ldi	r25, 0x96	; 150
    f170:	11 c0       	rjmp	.+34     	; 0xf194 <__floatsisf+0x6a>
    f172:	77 23       	and	r23, r23
    f174:	21 f0       	breq	.+8      	; 0xf17e <__floatsisf+0x54>
    f176:	9e e8       	ldi	r25, 0x8E	; 142
    f178:	87 2f       	mov	r24, r23
    f17a:	76 2f       	mov	r23, r22
    f17c:	05 c0       	rjmp	.+10     	; 0xf188 <__floatsisf+0x5e>
    f17e:	66 23       	and	r22, r22
    f180:	71 f0       	breq	.+28     	; 0xf19e <__floatsisf+0x74>
    f182:	96 e8       	ldi	r25, 0x86	; 134
    f184:	86 2f       	mov	r24, r22
    f186:	70 e0       	ldi	r23, 0x00	; 0
    f188:	60 e0       	ldi	r22, 0x00	; 0
    f18a:	2a f0       	brmi	.+10     	; 0xf196 <__floatsisf+0x6c>
    f18c:	9a 95       	dec	r25
    f18e:	66 0f       	add	r22, r22
    f190:	77 1f       	adc	r23, r23
    f192:	88 1f       	adc	r24, r24
    f194:	da f7       	brpl	.-10     	; 0xf18c <__floatsisf+0x62>
    f196:	88 0f       	add	r24, r24
    f198:	96 95       	lsr	r25
    f19a:	87 95       	ror	r24
    f19c:	97 f9       	bld	r25, 7
    f19e:	08 95       	ret

0000f1a0 <__mulsf3>:
    f1a0:	0b d0       	rcall	.+22     	; 0xf1b8 <__mulsf3x>
    f1a2:	78 c0       	rjmp	.+240    	; 0xf294 <__fp_round>
    f1a4:	69 d0       	rcall	.+210    	; 0xf278 <__fp_pscA>
    f1a6:	28 f0       	brcs	.+10     	; 0xf1b2 <__mulsf3+0x12>
    f1a8:	6e d0       	rcall	.+220    	; 0xf286 <__fp_pscB>
    f1aa:	18 f0       	brcs	.+6      	; 0xf1b2 <__mulsf3+0x12>
    f1ac:	95 23       	and	r25, r21
    f1ae:	09 f0       	breq	.+2      	; 0xf1b2 <__mulsf3+0x12>
    f1b0:	5a c0       	rjmp	.+180    	; 0xf266 <__fp_inf>
    f1b2:	5f c0       	rjmp	.+190    	; 0xf272 <__fp_nan>
    f1b4:	11 24       	eor	r1, r1
    f1b6:	a2 c0       	rjmp	.+324    	; 0xf2fc <__fp_szero>

0000f1b8 <__mulsf3x>:
    f1b8:	7e d0       	rcall	.+252    	; 0xf2b6 <__fp_split3>
    f1ba:	a0 f3       	brcs	.-24     	; 0xf1a4 <__mulsf3+0x4>

0000f1bc <__mulsf3_pse>:
    f1bc:	95 9f       	mul	r25, r21
    f1be:	d1 f3       	breq	.-12     	; 0xf1b4 <__mulsf3+0x14>
    f1c0:	95 0f       	add	r25, r21
    f1c2:	50 e0       	ldi	r21, 0x00	; 0
    f1c4:	55 1f       	adc	r21, r21
    f1c6:	62 9f       	mul	r22, r18
    f1c8:	f0 01       	movw	r30, r0
    f1ca:	72 9f       	mul	r23, r18
    f1cc:	bb 27       	eor	r27, r27
    f1ce:	f0 0d       	add	r31, r0
    f1d0:	b1 1d       	adc	r27, r1
    f1d2:	63 9f       	mul	r22, r19
    f1d4:	aa 27       	eor	r26, r26
    f1d6:	f0 0d       	add	r31, r0
    f1d8:	b1 1d       	adc	r27, r1
    f1da:	aa 1f       	adc	r26, r26
    f1dc:	64 9f       	mul	r22, r20
    f1de:	66 27       	eor	r22, r22
    f1e0:	b0 0d       	add	r27, r0
    f1e2:	a1 1d       	adc	r26, r1
    f1e4:	66 1f       	adc	r22, r22
    f1e6:	82 9f       	mul	r24, r18
    f1e8:	22 27       	eor	r18, r18
    f1ea:	b0 0d       	add	r27, r0
    f1ec:	a1 1d       	adc	r26, r1
    f1ee:	62 1f       	adc	r22, r18
    f1f0:	73 9f       	mul	r23, r19
    f1f2:	b0 0d       	add	r27, r0
    f1f4:	a1 1d       	adc	r26, r1
    f1f6:	62 1f       	adc	r22, r18
    f1f8:	83 9f       	mul	r24, r19
    f1fa:	a0 0d       	add	r26, r0
    f1fc:	61 1d       	adc	r22, r1
    f1fe:	22 1f       	adc	r18, r18
    f200:	74 9f       	mul	r23, r20
    f202:	33 27       	eor	r19, r19
    f204:	a0 0d       	add	r26, r0
    f206:	61 1d       	adc	r22, r1
    f208:	23 1f       	adc	r18, r19
    f20a:	84 9f       	mul	r24, r20
    f20c:	60 0d       	add	r22, r0
    f20e:	21 1d       	adc	r18, r1
    f210:	82 2f       	mov	r24, r18
    f212:	76 2f       	mov	r23, r22
    f214:	6a 2f       	mov	r22, r26
    f216:	11 24       	eor	r1, r1
    f218:	9f 57       	subi	r25, 0x7F	; 127
    f21a:	50 40       	sbci	r21, 0x00	; 0
    f21c:	8a f0       	brmi	.+34     	; 0xf240 <__mulsf3_pse+0x84>
    f21e:	e1 f0       	breq	.+56     	; 0xf258 <__mulsf3_pse+0x9c>
    f220:	88 23       	and	r24, r24
    f222:	4a f0       	brmi	.+18     	; 0xf236 <__mulsf3_pse+0x7a>
    f224:	ee 0f       	add	r30, r30
    f226:	ff 1f       	adc	r31, r31
    f228:	bb 1f       	adc	r27, r27
    f22a:	66 1f       	adc	r22, r22
    f22c:	77 1f       	adc	r23, r23
    f22e:	88 1f       	adc	r24, r24
    f230:	91 50       	subi	r25, 0x01	; 1
    f232:	50 40       	sbci	r21, 0x00	; 0
    f234:	a9 f7       	brne	.-22     	; 0xf220 <__mulsf3_pse+0x64>
    f236:	9e 3f       	cpi	r25, 0xFE	; 254
    f238:	51 05       	cpc	r21, r1
    f23a:	70 f0       	brcs	.+28     	; 0xf258 <__mulsf3_pse+0x9c>
    f23c:	14 c0       	rjmp	.+40     	; 0xf266 <__fp_inf>
    f23e:	5e c0       	rjmp	.+188    	; 0xf2fc <__fp_szero>
    f240:	5f 3f       	cpi	r21, 0xFF	; 255
    f242:	ec f3       	brlt	.-6      	; 0xf23e <__mulsf3_pse+0x82>
    f244:	98 3e       	cpi	r25, 0xE8	; 232
    f246:	dc f3       	brlt	.-10     	; 0xf23e <__mulsf3_pse+0x82>
    f248:	86 95       	lsr	r24
    f24a:	77 95       	ror	r23
    f24c:	67 95       	ror	r22
    f24e:	b7 95       	ror	r27
    f250:	f7 95       	ror	r31
    f252:	e7 95       	ror	r30
    f254:	9f 5f       	subi	r25, 0xFF	; 255
    f256:	c1 f7       	brne	.-16     	; 0xf248 <__mulsf3_pse+0x8c>
    f258:	fe 2b       	or	r31, r30
    f25a:	88 0f       	add	r24, r24
    f25c:	91 1d       	adc	r25, r1
    f25e:	96 95       	lsr	r25
    f260:	87 95       	ror	r24
    f262:	97 f9       	bld	r25, 7
    f264:	08 95       	ret

0000f266 <__fp_inf>:
    f266:	97 f9       	bld	r25, 7
    f268:	9f 67       	ori	r25, 0x7F	; 127
    f26a:	80 e8       	ldi	r24, 0x80	; 128
    f26c:	70 e0       	ldi	r23, 0x00	; 0
    f26e:	60 e0       	ldi	r22, 0x00	; 0
    f270:	08 95       	ret

0000f272 <__fp_nan>:
    f272:	9f ef       	ldi	r25, 0xFF	; 255
    f274:	80 ec       	ldi	r24, 0xC0	; 192
    f276:	08 95       	ret

0000f278 <__fp_pscA>:
    f278:	00 24       	eor	r0, r0
    f27a:	0a 94       	dec	r0
    f27c:	16 16       	cp	r1, r22
    f27e:	17 06       	cpc	r1, r23
    f280:	18 06       	cpc	r1, r24
    f282:	09 06       	cpc	r0, r25
    f284:	08 95       	ret

0000f286 <__fp_pscB>:
    f286:	00 24       	eor	r0, r0
    f288:	0a 94       	dec	r0
    f28a:	12 16       	cp	r1, r18
    f28c:	13 06       	cpc	r1, r19
    f28e:	14 06       	cpc	r1, r20
    f290:	05 06       	cpc	r0, r21
    f292:	08 95       	ret

0000f294 <__fp_round>:
    f294:	09 2e       	mov	r0, r25
    f296:	03 94       	inc	r0
    f298:	00 0c       	add	r0, r0
    f29a:	11 f4       	brne	.+4      	; 0xf2a0 <__fp_round+0xc>
    f29c:	88 23       	and	r24, r24
    f29e:	52 f0       	brmi	.+20     	; 0xf2b4 <__fp_round+0x20>
    f2a0:	bb 0f       	add	r27, r27
    f2a2:	40 f4       	brcc	.+16     	; 0xf2b4 <__fp_round+0x20>
    f2a4:	bf 2b       	or	r27, r31
    f2a6:	11 f4       	brne	.+4      	; 0xf2ac <__fp_round+0x18>
    f2a8:	60 ff       	sbrs	r22, 0
    f2aa:	04 c0       	rjmp	.+8      	; 0xf2b4 <__fp_round+0x20>
    f2ac:	6f 5f       	subi	r22, 0xFF	; 255
    f2ae:	7f 4f       	sbci	r23, 0xFF	; 255
    f2b0:	8f 4f       	sbci	r24, 0xFF	; 255
    f2b2:	9f 4f       	sbci	r25, 0xFF	; 255
    f2b4:	08 95       	ret

0000f2b6 <__fp_split3>:
    f2b6:	57 fd       	sbrc	r21, 7
    f2b8:	90 58       	subi	r25, 0x80	; 128
    f2ba:	44 0f       	add	r20, r20
    f2bc:	55 1f       	adc	r21, r21
    f2be:	59 f0       	breq	.+22     	; 0xf2d6 <__fp_splitA+0x10>
    f2c0:	5f 3f       	cpi	r21, 0xFF	; 255
    f2c2:	71 f0       	breq	.+28     	; 0xf2e0 <__fp_splitA+0x1a>
    f2c4:	47 95       	ror	r20

0000f2c6 <__fp_splitA>:
    f2c6:	88 0f       	add	r24, r24
    f2c8:	97 fb       	bst	r25, 7
    f2ca:	99 1f       	adc	r25, r25
    f2cc:	61 f0       	breq	.+24     	; 0xf2e6 <__fp_splitA+0x20>
    f2ce:	9f 3f       	cpi	r25, 0xFF	; 255
    f2d0:	79 f0       	breq	.+30     	; 0xf2f0 <__fp_splitA+0x2a>
    f2d2:	87 95       	ror	r24
    f2d4:	08 95       	ret
    f2d6:	12 16       	cp	r1, r18
    f2d8:	13 06       	cpc	r1, r19
    f2da:	14 06       	cpc	r1, r20
    f2dc:	55 1f       	adc	r21, r21
    f2de:	f2 cf       	rjmp	.-28     	; 0xf2c4 <__fp_split3+0xe>
    f2e0:	46 95       	lsr	r20
    f2e2:	f1 df       	rcall	.-30     	; 0xf2c6 <__fp_splitA>
    f2e4:	08 c0       	rjmp	.+16     	; 0xf2f6 <__fp_splitA+0x30>
    f2e6:	16 16       	cp	r1, r22
    f2e8:	17 06       	cpc	r1, r23
    f2ea:	18 06       	cpc	r1, r24
    f2ec:	99 1f       	adc	r25, r25
    f2ee:	f1 cf       	rjmp	.-30     	; 0xf2d2 <__fp_splitA+0xc>
    f2f0:	86 95       	lsr	r24
    f2f2:	71 05       	cpc	r23, r1
    f2f4:	61 05       	cpc	r22, r1
    f2f6:	08 94       	sec
    f2f8:	08 95       	ret

0000f2fa <__fp_zero>:
    f2fa:	e8 94       	clt

0000f2fc <__fp_szero>:
    f2fc:	bb 27       	eor	r27, r27
    f2fe:	66 27       	eor	r22, r22
    f300:	77 27       	eor	r23, r23
    f302:	cb 01       	movw	r24, r22
    f304:	97 f9       	bld	r25, 7
    f306:	08 95       	ret

0000f308 <exit>:
    f308:	f8 94       	cli
    f30a:	0c 94 6f 7e 	jmp	0xfcde	; 0xfcde <_exit>

0000f30e <__ftoa_engine>:
    f30e:	28 30       	cpi	r18, 0x08	; 8
    f310:	08 f0       	brcs	.+2      	; 0xf314 <__ftoa_engine+0x6>
    f312:	27 e0       	ldi	r18, 0x07	; 7
    f314:	33 27       	eor	r19, r19
    f316:	da 01       	movw	r26, r20
    f318:	99 0f       	add	r25, r25
    f31a:	31 1d       	adc	r19, r1
    f31c:	87 fd       	sbrc	r24, 7
    f31e:	91 60       	ori	r25, 0x01	; 1
    f320:	00 96       	adiw	r24, 0x00	; 0
    f322:	61 05       	cpc	r22, r1
    f324:	71 05       	cpc	r23, r1
    f326:	39 f4       	brne	.+14     	; 0xf336 <__ftoa_engine+0x28>
    f328:	32 60       	ori	r19, 0x02	; 2
    f32a:	2e 5f       	subi	r18, 0xFE	; 254
    f32c:	3d 93       	st	X+, r19
    f32e:	30 e3       	ldi	r19, 0x30	; 48
    f330:	2a 95       	dec	r18
    f332:	e1 f7       	brne	.-8      	; 0xf32c <__ftoa_engine+0x1e>
    f334:	08 95       	ret
    f336:	9f 3f       	cpi	r25, 0xFF	; 255
    f338:	30 f0       	brcs	.+12     	; 0xf346 <__ftoa_engine+0x38>
    f33a:	80 38       	cpi	r24, 0x80	; 128
    f33c:	71 05       	cpc	r23, r1
    f33e:	61 05       	cpc	r22, r1
    f340:	09 f0       	breq	.+2      	; 0xf344 <__ftoa_engine+0x36>
    f342:	3c 5f       	subi	r19, 0xFC	; 252
    f344:	3c 5f       	subi	r19, 0xFC	; 252
    f346:	3d 93       	st	X+, r19
    f348:	91 30       	cpi	r25, 0x01	; 1
    f34a:	08 f0       	brcs	.+2      	; 0xf34e <__ftoa_engine+0x40>
    f34c:	80 68       	ori	r24, 0x80	; 128
    f34e:	91 1d       	adc	r25, r1
    f350:	df 93       	push	r29
    f352:	cf 93       	push	r28
    f354:	1f 93       	push	r17
    f356:	0f 93       	push	r16
    f358:	ff 92       	push	r15
    f35a:	ef 92       	push	r14
    f35c:	19 2f       	mov	r17, r25
    f35e:	98 7f       	andi	r25, 0xF8	; 248
    f360:	96 95       	lsr	r25
    f362:	e9 2f       	mov	r30, r25
    f364:	96 95       	lsr	r25
    f366:	96 95       	lsr	r25
    f368:	e9 0f       	add	r30, r25
    f36a:	ff 27       	eor	r31, r31
    f36c:	e3 52       	subi	r30, 0x23	; 35
    f36e:	f0 4d       	sbci	r31, 0xD0	; 208
    f370:	99 27       	eor	r25, r25
    f372:	33 27       	eor	r19, r19
    f374:	ee 24       	eor	r14, r14
    f376:	ff 24       	eor	r15, r15
    f378:	a7 01       	movw	r20, r14
    f37a:	e7 01       	movw	r28, r14
    f37c:	05 90       	lpm	r0, Z+
    f37e:	08 94       	sec
    f380:	07 94       	ror	r0
    f382:	28 f4       	brcc	.+10     	; 0xf38e <__ftoa_engine+0x80>
    f384:	36 0f       	add	r19, r22
    f386:	e7 1e       	adc	r14, r23
    f388:	f8 1e       	adc	r15, r24
    f38a:	49 1f       	adc	r20, r25
    f38c:	51 1d       	adc	r21, r1
    f38e:	66 0f       	add	r22, r22
    f390:	77 1f       	adc	r23, r23
    f392:	88 1f       	adc	r24, r24
    f394:	99 1f       	adc	r25, r25
    f396:	06 94       	lsr	r0
    f398:	a1 f7       	brne	.-24     	; 0xf382 <__ftoa_engine+0x74>
    f39a:	05 90       	lpm	r0, Z+
    f39c:	07 94       	ror	r0
    f39e:	28 f4       	brcc	.+10     	; 0xf3aa <__ftoa_engine+0x9c>
    f3a0:	e7 0e       	add	r14, r23
    f3a2:	f8 1e       	adc	r15, r24
    f3a4:	49 1f       	adc	r20, r25
    f3a6:	56 1f       	adc	r21, r22
    f3a8:	c1 1d       	adc	r28, r1
    f3aa:	77 0f       	add	r23, r23
    f3ac:	88 1f       	adc	r24, r24
    f3ae:	99 1f       	adc	r25, r25
    f3b0:	66 1f       	adc	r22, r22
    f3b2:	06 94       	lsr	r0
    f3b4:	a1 f7       	brne	.-24     	; 0xf39e <__ftoa_engine+0x90>
    f3b6:	05 90       	lpm	r0, Z+
    f3b8:	07 94       	ror	r0
    f3ba:	28 f4       	brcc	.+10     	; 0xf3c6 <__ftoa_engine+0xb8>
    f3bc:	f8 0e       	add	r15, r24
    f3be:	49 1f       	adc	r20, r25
    f3c0:	56 1f       	adc	r21, r22
    f3c2:	c7 1f       	adc	r28, r23
    f3c4:	d1 1d       	adc	r29, r1
    f3c6:	88 0f       	add	r24, r24
    f3c8:	99 1f       	adc	r25, r25
    f3ca:	66 1f       	adc	r22, r22
    f3cc:	77 1f       	adc	r23, r23
    f3ce:	06 94       	lsr	r0
    f3d0:	a1 f7       	brne	.-24     	; 0xf3ba <__ftoa_engine+0xac>
    f3d2:	05 90       	lpm	r0, Z+
    f3d4:	07 94       	ror	r0
    f3d6:	20 f4       	brcc	.+8      	; 0xf3e0 <__ftoa_engine+0xd2>
    f3d8:	49 0f       	add	r20, r25
    f3da:	56 1f       	adc	r21, r22
    f3dc:	c7 1f       	adc	r28, r23
    f3de:	d8 1f       	adc	r29, r24
    f3e0:	99 0f       	add	r25, r25
    f3e2:	66 1f       	adc	r22, r22
    f3e4:	77 1f       	adc	r23, r23
    f3e6:	88 1f       	adc	r24, r24
    f3e8:	06 94       	lsr	r0
    f3ea:	a9 f7       	brne	.-22     	; 0xf3d6 <__ftoa_engine+0xc8>
    f3ec:	84 91       	lpm	r24, Z+
    f3ee:	10 95       	com	r17
    f3f0:	17 70       	andi	r17, 0x07	; 7
    f3f2:	41 f0       	breq	.+16     	; 0xf404 <__ftoa_engine+0xf6>
    f3f4:	d6 95       	lsr	r29
    f3f6:	c7 95       	ror	r28
    f3f8:	57 95       	ror	r21
    f3fa:	47 95       	ror	r20
    f3fc:	f7 94       	ror	r15
    f3fe:	e7 94       	ror	r14
    f400:	1a 95       	dec	r17
    f402:	c1 f7       	brne	.-16     	; 0xf3f4 <__ftoa_engine+0xe6>
    f404:	e3 e8       	ldi	r30, 0x83	; 131
    f406:	ff e2       	ldi	r31, 0x2F	; 47
    f408:	68 94       	set
    f40a:	15 90       	lpm	r1, Z+
    f40c:	15 91       	lpm	r17, Z+
    f40e:	35 91       	lpm	r19, Z+
    f410:	65 91       	lpm	r22, Z+
    f412:	95 91       	lpm	r25, Z+
    f414:	05 90       	lpm	r0, Z+
    f416:	7f e2       	ldi	r23, 0x2F	; 47
    f418:	73 95       	inc	r23
    f41a:	e1 18       	sub	r14, r1
    f41c:	f1 0a       	sbc	r15, r17
    f41e:	43 0b       	sbc	r20, r19
    f420:	56 0b       	sbc	r21, r22
    f422:	c9 0b       	sbc	r28, r25
    f424:	d0 09       	sbc	r29, r0
    f426:	c0 f7       	brcc	.-16     	; 0xf418 <__ftoa_engine+0x10a>
    f428:	e1 0c       	add	r14, r1
    f42a:	f1 1e       	adc	r15, r17
    f42c:	43 1f       	adc	r20, r19
    f42e:	56 1f       	adc	r21, r22
    f430:	c9 1f       	adc	r28, r25
    f432:	d0 1d       	adc	r29, r0
    f434:	7e f4       	brtc	.+30     	; 0xf454 <__ftoa_engine+0x146>
    f436:	70 33       	cpi	r23, 0x30	; 48
    f438:	11 f4       	brne	.+4      	; 0xf43e <__ftoa_engine+0x130>
    f43a:	8a 95       	dec	r24
    f43c:	e6 cf       	rjmp	.-52     	; 0xf40a <__ftoa_engine+0xfc>
    f43e:	e8 94       	clt
    f440:	01 50       	subi	r16, 0x01	; 1
    f442:	30 f0       	brcs	.+12     	; 0xf450 <__ftoa_engine+0x142>
    f444:	08 0f       	add	r16, r24
    f446:	0a f4       	brpl	.+2      	; 0xf44a <__ftoa_engine+0x13c>
    f448:	00 27       	eor	r16, r16
    f44a:	02 17       	cp	r16, r18
    f44c:	08 f4       	brcc	.+2      	; 0xf450 <__ftoa_engine+0x142>
    f44e:	20 2f       	mov	r18, r16
    f450:	23 95       	inc	r18
    f452:	02 2f       	mov	r16, r18
    f454:	7a 33       	cpi	r23, 0x3A	; 58
    f456:	28 f0       	brcs	.+10     	; 0xf462 <__ftoa_engine+0x154>
    f458:	79 e3       	ldi	r23, 0x39	; 57
    f45a:	7d 93       	st	X+, r23
    f45c:	2a 95       	dec	r18
    f45e:	e9 f7       	brne	.-6      	; 0xf45a <__ftoa_engine+0x14c>
    f460:	10 c0       	rjmp	.+32     	; 0xf482 <__ftoa_engine+0x174>
    f462:	7d 93       	st	X+, r23
    f464:	2a 95       	dec	r18
    f466:	89 f6       	brne	.-94     	; 0xf40a <__ftoa_engine+0xfc>
    f468:	06 94       	lsr	r0
    f46a:	97 95       	ror	r25
    f46c:	67 95       	ror	r22
    f46e:	37 95       	ror	r19
    f470:	17 95       	ror	r17
    f472:	17 94       	ror	r1
    f474:	e1 18       	sub	r14, r1
    f476:	f1 0a       	sbc	r15, r17
    f478:	43 0b       	sbc	r20, r19
    f47a:	56 0b       	sbc	r21, r22
    f47c:	c9 0b       	sbc	r28, r25
    f47e:	d0 09       	sbc	r29, r0
    f480:	98 f0       	brcs	.+38     	; 0xf4a8 <__ftoa_engine+0x19a>
    f482:	23 95       	inc	r18
    f484:	7e 91       	ld	r23, -X
    f486:	73 95       	inc	r23
    f488:	7a 33       	cpi	r23, 0x3A	; 58
    f48a:	08 f0       	brcs	.+2      	; 0xf48e <__ftoa_engine+0x180>
    f48c:	70 e3       	ldi	r23, 0x30	; 48
    f48e:	7c 93       	st	X, r23
    f490:	20 13       	cpse	r18, r16
    f492:	b8 f7       	brcc	.-18     	; 0xf482 <__ftoa_engine+0x174>
    f494:	7e 91       	ld	r23, -X
    f496:	70 61       	ori	r23, 0x10	; 16
    f498:	7d 93       	st	X+, r23
    f49a:	30 f0       	brcs	.+12     	; 0xf4a8 <__ftoa_engine+0x19a>
    f49c:	83 95       	inc	r24
    f49e:	71 e3       	ldi	r23, 0x31	; 49
    f4a0:	7d 93       	st	X+, r23
    f4a2:	70 e3       	ldi	r23, 0x30	; 48
    f4a4:	2a 95       	dec	r18
    f4a6:	e1 f7       	brne	.-8      	; 0xf4a0 <__ftoa_engine+0x192>
    f4a8:	11 24       	eor	r1, r1
    f4aa:	ef 90       	pop	r14
    f4ac:	ff 90       	pop	r15
    f4ae:	0f 91       	pop	r16
    f4b0:	1f 91       	pop	r17
    f4b2:	cf 91       	pop	r28
    f4b4:	df 91       	pop	r29
    f4b6:	99 27       	eor	r25, r25
    f4b8:	87 fd       	sbrc	r24, 7
    f4ba:	90 95       	com	r25
    f4bc:	08 95       	ret

0000f4be <isspace>:
    f4be:	91 11       	cpse	r25, r1
    f4c0:	7c c3       	rjmp	.+1784   	; 0xfbba <__ctype_isfalse>
    f4c2:	80 32       	cpi	r24, 0x20	; 32
    f4c4:	19 f0       	breq	.+6      	; 0xf4cc <isspace+0xe>
    f4c6:	89 50       	subi	r24, 0x09	; 9
    f4c8:	85 50       	subi	r24, 0x05	; 5
    f4ca:	d0 f7       	brcc	.-12     	; 0xf4c0 <isspace+0x2>
    f4cc:	08 95       	ret

0000f4ce <tolower>:
    f4ce:	91 11       	cpse	r25, r1
    f4d0:	08 95       	ret
    f4d2:	81 54       	subi	r24, 0x41	; 65
    f4d4:	8a 51       	subi	r24, 0x1A	; 26
    f4d6:	08 f4       	brcc	.+2      	; 0xf4da <tolower+0xc>
    f4d8:	80 5e       	subi	r24, 0xE0	; 224
    f4da:	85 5a       	subi	r24, 0xA5	; 165
    f4dc:	08 95       	ret

0000f4de <strchr_P>:
    f4de:	fc 01       	movw	r30, r24
    f4e0:	05 90       	lpm	r0, Z+
    f4e2:	06 16       	cp	r0, r22
    f4e4:	21 f0       	breq	.+8      	; 0xf4ee <strchr_P+0x10>
    f4e6:	00 20       	and	r0, r0
    f4e8:	d9 f7       	brne	.-10     	; 0xf4e0 <strchr_P+0x2>
    f4ea:	c0 01       	movw	r24, r0
    f4ec:	08 95       	ret
    f4ee:	31 97       	sbiw	r30, 0x01	; 1
    f4f0:	cf 01       	movw	r24, r30
    f4f2:	08 95       	ret

0000f4f4 <strcmp_P>:
    f4f4:	fb 01       	movw	r30, r22
    f4f6:	dc 01       	movw	r26, r24
    f4f8:	8d 91       	ld	r24, X+
    f4fa:	05 90       	lpm	r0, Z+
    f4fc:	80 19       	sub	r24, r0
    f4fe:	01 10       	cpse	r0, r1
    f500:	d9 f3       	breq	.-10     	; 0xf4f8 <strcmp_P+0x4>
    f502:	99 0b       	sbc	r25, r25
    f504:	08 95       	ret

0000f506 <strcpy_P>:
    f506:	fb 01       	movw	r30, r22
    f508:	dc 01       	movw	r26, r24
    f50a:	05 90       	lpm	r0, Z+
    f50c:	0d 92       	st	X+, r0
    f50e:	00 20       	and	r0, r0
    f510:	e1 f7       	brne	.-8      	; 0xf50a <strcpy_P+0x4>
    f512:	08 95       	ret

0000f514 <strlen_P>:
    f514:	fc 01       	movw	r30, r24
    f516:	05 90       	lpm	r0, Z+
    f518:	00 20       	and	r0, r0
    f51a:	e9 f7       	brne	.-6      	; 0xf516 <strlen_P+0x2>
    f51c:	80 95       	com	r24
    f51e:	90 95       	com	r25
    f520:	8e 0f       	add	r24, r30
    f522:	9f 1f       	adc	r25, r31
    f524:	08 95       	ret

0000f526 <strncmp_P>:
    f526:	fb 01       	movw	r30, r22
    f528:	dc 01       	movw	r26, r24
    f52a:	41 50       	subi	r20, 0x01	; 1
    f52c:	50 40       	sbci	r21, 0x00	; 0
    f52e:	30 f0       	brcs	.+12     	; 0xf53c <strncmp_P+0x16>
    f530:	8d 91       	ld	r24, X+
    f532:	05 90       	lpm	r0, Z+
    f534:	80 19       	sub	r24, r0
    f536:	19 f4       	brne	.+6      	; 0xf53e <strncmp_P+0x18>
    f538:	00 20       	and	r0, r0
    f53a:	b9 f7       	brne	.-18     	; 0xf52a <strncmp_P+0x4>
    f53c:	88 1b       	sub	r24, r24
    f53e:	99 0b       	sbc	r25, r25
    f540:	08 95       	ret

0000f542 <strnlen_P>:
    f542:	fc 01       	movw	r30, r24
    f544:	05 90       	lpm	r0, Z+
    f546:	61 50       	subi	r22, 0x01	; 1
    f548:	70 40       	sbci	r23, 0x00	; 0
    f54a:	01 10       	cpse	r0, r1
    f54c:	d8 f7       	brcc	.-10     	; 0xf544 <strnlen_P+0x2>
    f54e:	80 95       	com	r24
    f550:	90 95       	com	r25
    f552:	8e 0f       	add	r24, r30
    f554:	9f 1f       	adc	r25, r31
    f556:	08 95       	ret

0000f558 <strstr_P>:
    f558:	fb 01       	movw	r30, r22
    f55a:	55 91       	lpm	r21, Z+
    f55c:	55 23       	and	r21, r21
    f55e:	a9 f0       	breq	.+42     	; 0xf58a <strstr_P+0x32>
    f560:	bf 01       	movw	r22, r30
    f562:	dc 01       	movw	r26, r24
    f564:	4d 91       	ld	r20, X+
    f566:	45 17       	cp	r20, r21
    f568:	41 11       	cpse	r20, r1
    f56a:	e1 f7       	brne	.-8      	; 0xf564 <strstr_P+0xc>
    f56c:	59 f4       	brne	.+22     	; 0xf584 <strstr_P+0x2c>
    f56e:	cd 01       	movw	r24, r26
    f570:	05 90       	lpm	r0, Z+
    f572:	00 20       	and	r0, r0
    f574:	49 f0       	breq	.+18     	; 0xf588 <strstr_P+0x30>
    f576:	4d 91       	ld	r20, X+
    f578:	40 15       	cp	r20, r0
    f57a:	41 11       	cpse	r20, r1
    f57c:	c9 f3       	breq	.-14     	; 0xf570 <strstr_P+0x18>
    f57e:	fb 01       	movw	r30, r22
    f580:	41 11       	cpse	r20, r1
    f582:	ef cf       	rjmp	.-34     	; 0xf562 <strstr_P+0xa>
    f584:	81 e0       	ldi	r24, 0x01	; 1
    f586:	90 e0       	ldi	r25, 0x00	; 0
    f588:	01 97       	sbiw	r24, 0x01	; 1
    f58a:	08 95       	ret

0000f58c <memcpy>:
    f58c:	fb 01       	movw	r30, r22
    f58e:	dc 01       	movw	r26, r24
    f590:	02 c0       	rjmp	.+4      	; 0xf596 <memcpy+0xa>
    f592:	01 90       	ld	r0, Z+
    f594:	0d 92       	st	X+, r0
    f596:	41 50       	subi	r20, 0x01	; 1
    f598:	50 40       	sbci	r21, 0x00	; 0
    f59a:	d8 f7       	brcc	.-10     	; 0xf592 <memcpy+0x6>
    f59c:	08 95       	ret

0000f59e <strchr>:
    f59e:	fc 01       	movw	r30, r24
    f5a0:	81 91       	ld	r24, Z+
    f5a2:	86 17       	cp	r24, r22
    f5a4:	21 f0       	breq	.+8      	; 0xf5ae <strchr+0x10>
    f5a6:	88 23       	and	r24, r24
    f5a8:	d9 f7       	brne	.-10     	; 0xf5a0 <strchr+0x2>
    f5aa:	99 27       	eor	r25, r25
    f5ac:	08 95       	ret
    f5ae:	31 97       	sbiw	r30, 0x01	; 1
    f5b0:	cf 01       	movw	r24, r30
    f5b2:	08 95       	ret

0000f5b4 <strcmp>:
    f5b4:	fb 01       	movw	r30, r22
    f5b6:	dc 01       	movw	r26, r24
    f5b8:	8d 91       	ld	r24, X+
    f5ba:	01 90       	ld	r0, Z+
    f5bc:	80 19       	sub	r24, r0
    f5be:	01 10       	cpse	r0, r1
    f5c0:	d9 f3       	breq	.-10     	; 0xf5b8 <strcmp+0x4>
    f5c2:	99 0b       	sbc	r25, r25
    f5c4:	08 95       	ret

0000f5c6 <strnlen>:
    f5c6:	fc 01       	movw	r30, r24
    f5c8:	61 50       	subi	r22, 0x01	; 1
    f5ca:	70 40       	sbci	r23, 0x00	; 0
    f5cc:	01 90       	ld	r0, Z+
    f5ce:	01 10       	cpse	r0, r1
    f5d0:	d8 f7       	brcc	.-10     	; 0xf5c8 <strnlen+0x2>
    f5d2:	80 95       	com	r24
    f5d4:	90 95       	com	r25
    f5d6:	8e 0f       	add	r24, r30
    f5d8:	9f 1f       	adc	r25, r31
    f5da:	08 95       	ret

0000f5dc <strstr>:
    f5dc:	fb 01       	movw	r30, r22
    f5de:	51 91       	ld	r21, Z+
    f5e0:	55 23       	and	r21, r21
    f5e2:	a9 f0       	breq	.+42     	; 0xf60e <strstr+0x32>
    f5e4:	bf 01       	movw	r22, r30
    f5e6:	dc 01       	movw	r26, r24
    f5e8:	4d 91       	ld	r20, X+
    f5ea:	45 17       	cp	r20, r21
    f5ec:	41 11       	cpse	r20, r1
    f5ee:	e1 f7       	brne	.-8      	; 0xf5e8 <strstr+0xc>
    f5f0:	59 f4       	brne	.+22     	; 0xf608 <strstr+0x2c>
    f5f2:	cd 01       	movw	r24, r26
    f5f4:	01 90       	ld	r0, Z+
    f5f6:	00 20       	and	r0, r0
    f5f8:	49 f0       	breq	.+18     	; 0xf60c <strstr+0x30>
    f5fa:	4d 91       	ld	r20, X+
    f5fc:	40 15       	cp	r20, r0
    f5fe:	41 11       	cpse	r20, r1
    f600:	c9 f3       	breq	.-14     	; 0xf5f4 <strstr+0x18>
    f602:	fb 01       	movw	r30, r22
    f604:	41 11       	cpse	r20, r1
    f606:	ef cf       	rjmp	.-34     	; 0xf5e6 <strstr+0xa>
    f608:	81 e0       	ldi	r24, 0x01	; 1
    f60a:	90 e0       	ldi	r25, 0x00	; 0
    f60c:	01 97       	sbiw	r24, 0x01	; 1
    f60e:	08 95       	ret

0000f610 <fgetc>:
    f610:	cf 93       	push	r28
    f612:	df 93       	push	r29
    f614:	ec 01       	movw	r28, r24
    f616:	4b 81       	ldd	r20, Y+3	; 0x03
    f618:	40 ff       	sbrs	r20, 0
    f61a:	1a c0       	rjmp	.+52     	; 0xf650 <fgetc+0x40>
    f61c:	46 ff       	sbrs	r20, 6
    f61e:	0a c0       	rjmp	.+20     	; 0xf634 <fgetc+0x24>
    f620:	4f 7b       	andi	r20, 0xBF	; 191
    f622:	4b 83       	std	Y+3, r20	; 0x03
    f624:	8e 81       	ldd	r24, Y+6	; 0x06
    f626:	9f 81       	ldd	r25, Y+7	; 0x07
    f628:	01 96       	adiw	r24, 0x01	; 1
    f62a:	9f 83       	std	Y+7, r25	; 0x07
    f62c:	8e 83       	std	Y+6, r24	; 0x06
    f62e:	8a 81       	ldd	r24, Y+2	; 0x02
    f630:	28 2f       	mov	r18, r24
    f632:	2b c0       	rjmp	.+86     	; 0xf68a <fgetc+0x7a>
    f634:	42 ff       	sbrs	r20, 2
    f636:	13 c0       	rjmp	.+38     	; 0xf65e <fgetc+0x4e>
    f638:	e8 81       	ld	r30, Y
    f63a:	f9 81       	ldd	r31, Y+1	; 0x01
    f63c:	80 81       	ld	r24, Z
    f63e:	28 2f       	mov	r18, r24
    f640:	33 27       	eor	r19, r19
    f642:	27 fd       	sbrc	r18, 7
    f644:	30 95       	com	r19
    f646:	21 15       	cp	r18, r1
    f648:	31 05       	cpc	r19, r1
    f64a:	29 f4       	brne	.+10     	; 0xf656 <fgetc+0x46>
    f64c:	40 62       	ori	r20, 0x20	; 32
    f64e:	4b 83       	std	Y+3, r20	; 0x03
    f650:	2f ef       	ldi	r18, 0xFF	; 255
    f652:	3f ef       	ldi	r19, 0xFF	; 255
    f654:	1b c0       	rjmp	.+54     	; 0xf68c <fgetc+0x7c>
    f656:	31 96       	adiw	r30, 0x01	; 1
    f658:	f9 83       	std	Y+1, r31	; 0x01
    f65a:	e8 83       	st	Y, r30
    f65c:	11 c0       	rjmp	.+34     	; 0xf680 <fgetc+0x70>
    f65e:	ea 85       	ldd	r30, Y+10	; 0x0a
    f660:	fb 85       	ldd	r31, Y+11	; 0x0b
    f662:	ce 01       	movw	r24, r28
    f664:	19 95       	eicall
    f666:	9c 01       	movw	r18, r24
    f668:	97 ff       	sbrs	r25, 7
    f66a:	0a c0       	rjmp	.+20     	; 0xf680 <fgetc+0x70>
    f66c:	9b 81       	ldd	r25, Y+3	; 0x03
    f66e:	2f 5f       	subi	r18, 0xFF	; 255
    f670:	3f 4f       	sbci	r19, 0xFF	; 255
    f672:	11 f0       	breq	.+4      	; 0xf678 <fgetc+0x68>
    f674:	80 e2       	ldi	r24, 0x20	; 32
    f676:	01 c0       	rjmp	.+2      	; 0xf67a <fgetc+0x6a>
    f678:	80 e1       	ldi	r24, 0x10	; 16
    f67a:	89 2b       	or	r24, r25
    f67c:	8b 83       	std	Y+3, r24	; 0x03
    f67e:	e8 cf       	rjmp	.-48     	; 0xf650 <fgetc+0x40>
    f680:	8e 81       	ldd	r24, Y+6	; 0x06
    f682:	9f 81       	ldd	r25, Y+7	; 0x07
    f684:	01 96       	adiw	r24, 0x01	; 1
    f686:	9f 83       	std	Y+7, r25	; 0x07
    f688:	8e 83       	std	Y+6, r24	; 0x06
    f68a:	30 e0       	ldi	r19, 0x00	; 0
    f68c:	c9 01       	movw	r24, r18
    f68e:	df 91       	pop	r29
    f690:	cf 91       	pop	r28
    f692:	08 95       	ret

0000f694 <fputc>:
    f694:	0f 93       	push	r16
    f696:	1f 93       	push	r17
    f698:	cf 93       	push	r28
    f69a:	df 93       	push	r29
    f69c:	8c 01       	movw	r16, r24
    f69e:	eb 01       	movw	r28, r22
    f6a0:	8b 81       	ldd	r24, Y+3	; 0x03
    f6a2:	81 ff       	sbrs	r24, 1
    f6a4:	1b c0       	rjmp	.+54     	; 0xf6dc <fputc+0x48>
    f6a6:	82 ff       	sbrs	r24, 2
    f6a8:	0d c0       	rjmp	.+26     	; 0xf6c4 <fputc+0x30>
    f6aa:	2e 81       	ldd	r18, Y+6	; 0x06
    f6ac:	3f 81       	ldd	r19, Y+7	; 0x07
    f6ae:	8c 81       	ldd	r24, Y+4	; 0x04
    f6b0:	9d 81       	ldd	r25, Y+5	; 0x05
    f6b2:	28 17       	cp	r18, r24
    f6b4:	39 07       	cpc	r19, r25
    f6b6:	64 f4       	brge	.+24     	; 0xf6d0 <fputc+0x3c>
    f6b8:	e8 81       	ld	r30, Y
    f6ba:	f9 81       	ldd	r31, Y+1	; 0x01
    f6bc:	01 93       	st	Z+, r16
    f6be:	f9 83       	std	Y+1, r31	; 0x01
    f6c0:	e8 83       	st	Y, r30
    f6c2:	06 c0       	rjmp	.+12     	; 0xf6d0 <fputc+0x3c>
    f6c4:	e8 85       	ldd	r30, Y+8	; 0x08
    f6c6:	f9 85       	ldd	r31, Y+9	; 0x09
    f6c8:	80 2f       	mov	r24, r16
    f6ca:	19 95       	eicall
    f6cc:	89 2b       	or	r24, r25
    f6ce:	31 f4       	brne	.+12     	; 0xf6dc <fputc+0x48>
    f6d0:	8e 81       	ldd	r24, Y+6	; 0x06
    f6d2:	9f 81       	ldd	r25, Y+7	; 0x07
    f6d4:	01 96       	adiw	r24, 0x01	; 1
    f6d6:	9f 83       	std	Y+7, r25	; 0x07
    f6d8:	8e 83       	std	Y+6, r24	; 0x06
    f6da:	02 c0       	rjmp	.+4      	; 0xf6e0 <fputc+0x4c>
    f6dc:	0f ef       	ldi	r16, 0xFF	; 255
    f6de:	1f ef       	ldi	r17, 0xFF	; 255
    f6e0:	c8 01       	movw	r24, r16
    f6e2:	df 91       	pop	r29
    f6e4:	cf 91       	pop	r28
    f6e6:	1f 91       	pop	r17
    f6e8:	0f 91       	pop	r16
    f6ea:	08 95       	ret

0000f6ec <sprintf>:
    f6ec:	0f 93       	push	r16
    f6ee:	1f 93       	push	r17
    f6f0:	df 93       	push	r29
    f6f2:	cf 93       	push	r28
    f6f4:	cd b7       	in	r28, 0x3d	; 61
    f6f6:	de b7       	in	r29, 0x3e	; 62
    f6f8:	2e 97       	sbiw	r28, 0x0e	; 14
    f6fa:	0f b6       	in	r0, 0x3f	; 63
    f6fc:	f8 94       	cli
    f6fe:	de bf       	out	0x3e, r29	; 62
    f700:	0f be       	out	0x3f, r0	; 63
    f702:	cd bf       	out	0x3d, r28	; 61
    f704:	0e 89       	ldd	r16, Y+22	; 0x16
    f706:	1f 89       	ldd	r17, Y+23	; 0x17
    f708:	86 e0       	ldi	r24, 0x06	; 6
    f70a:	8c 83       	std	Y+4, r24	; 0x04
    f70c:	1a 83       	std	Y+2, r17	; 0x02
    f70e:	09 83       	std	Y+1, r16	; 0x01
    f710:	8f ef       	ldi	r24, 0xFF	; 255
    f712:	9f e7       	ldi	r25, 0x7F	; 127
    f714:	9e 83       	std	Y+6, r25	; 0x06
    f716:	8d 83       	std	Y+5, r24	; 0x05
    f718:	9e 01       	movw	r18, r28
    f71a:	26 5e       	subi	r18, 0xE6	; 230
    f71c:	3f 4f       	sbci	r19, 0xFF	; 255
    f71e:	ce 01       	movw	r24, r28
    f720:	01 96       	adiw	r24, 0x01	; 1
    f722:	68 8d       	ldd	r22, Y+24	; 0x18
    f724:	79 8d       	ldd	r23, Y+25	; 0x19
    f726:	a9 01       	movw	r20, r18
    f728:	0e 94 9d 70 	call	0xe13a	; 0xe13a <vfprintf>
    f72c:	2f 81       	ldd	r18, Y+7	; 0x07
    f72e:	38 85       	ldd	r19, Y+8	; 0x08
    f730:	02 0f       	add	r16, r18
    f732:	13 1f       	adc	r17, r19
    f734:	f8 01       	movw	r30, r16
    f736:	10 82       	st	Z, r1
    f738:	2e 96       	adiw	r28, 0x0e	; 14
    f73a:	0f b6       	in	r0, 0x3f	; 63
    f73c:	f8 94       	cli
    f73e:	de bf       	out	0x3e, r29	; 62
    f740:	0f be       	out	0x3f, r0	; 63
    f742:	cd bf       	out	0x3d, r28	; 61
    f744:	cf 91       	pop	r28
    f746:	df 91       	pop	r29
    f748:	1f 91       	pop	r17
    f74a:	0f 91       	pop	r16
    f74c:	08 95       	ret

0000f74e <sprintf_P>:
    f74e:	0f 93       	push	r16
    f750:	1f 93       	push	r17
    f752:	df 93       	push	r29
    f754:	cf 93       	push	r28
    f756:	cd b7       	in	r28, 0x3d	; 61
    f758:	de b7       	in	r29, 0x3e	; 62
    f75a:	2e 97       	sbiw	r28, 0x0e	; 14
    f75c:	0f b6       	in	r0, 0x3f	; 63
    f75e:	f8 94       	cli
    f760:	de bf       	out	0x3e, r29	; 62
    f762:	0f be       	out	0x3f, r0	; 63
    f764:	cd bf       	out	0x3d, r28	; 61
    f766:	0e 89       	ldd	r16, Y+22	; 0x16
    f768:	1f 89       	ldd	r17, Y+23	; 0x17
    f76a:	8e e0       	ldi	r24, 0x0E	; 14
    f76c:	8c 83       	std	Y+4, r24	; 0x04
    f76e:	1a 83       	std	Y+2, r17	; 0x02
    f770:	09 83       	std	Y+1, r16	; 0x01
    f772:	8f ef       	ldi	r24, 0xFF	; 255
    f774:	9f e7       	ldi	r25, 0x7F	; 127
    f776:	9e 83       	std	Y+6, r25	; 0x06
    f778:	8d 83       	std	Y+5, r24	; 0x05
    f77a:	9e 01       	movw	r18, r28
    f77c:	26 5e       	subi	r18, 0xE6	; 230
    f77e:	3f 4f       	sbci	r19, 0xFF	; 255
    f780:	ce 01       	movw	r24, r28
    f782:	01 96       	adiw	r24, 0x01	; 1
    f784:	68 8d       	ldd	r22, Y+24	; 0x18
    f786:	79 8d       	ldd	r23, Y+25	; 0x19
    f788:	a9 01       	movw	r20, r18
    f78a:	0e 94 9d 70 	call	0xe13a	; 0xe13a <vfprintf>
    f78e:	2f 81       	ldd	r18, Y+7	; 0x07
    f790:	38 85       	ldd	r19, Y+8	; 0x08
    f792:	02 0f       	add	r16, r18
    f794:	13 1f       	adc	r17, r19
    f796:	f8 01       	movw	r30, r16
    f798:	10 82       	st	Z, r1
    f79a:	2e 96       	adiw	r28, 0x0e	; 14
    f79c:	0f b6       	in	r0, 0x3f	; 63
    f79e:	f8 94       	cli
    f7a0:	de bf       	out	0x3e, r29	; 62
    f7a2:	0f be       	out	0x3f, r0	; 63
    f7a4:	cd bf       	out	0x3d, r28	; 61
    f7a6:	cf 91       	pop	r28
    f7a8:	df 91       	pop	r29
    f7aa:	1f 91       	pop	r17
    f7ac:	0f 91       	pop	r16
    f7ae:	08 95       	ret

0000f7b0 <sscanf>:
    f7b0:	df 93       	push	r29
    f7b2:	cf 93       	push	r28
    f7b4:	cd b7       	in	r28, 0x3d	; 61
    f7b6:	de b7       	in	r29, 0x3e	; 62
    f7b8:	2e 97       	sbiw	r28, 0x0e	; 14
    f7ba:	0f b6       	in	r0, 0x3f	; 63
    f7bc:	f8 94       	cli
    f7be:	de bf       	out	0x3e, r29	; 62
    f7c0:	0f be       	out	0x3f, r0	; 63
    f7c2:	cd bf       	out	0x3d, r28	; 61
    f7c4:	85 e0       	ldi	r24, 0x05	; 5
    f7c6:	8c 83       	std	Y+4, r24	; 0x04
    f7c8:	8c 89       	ldd	r24, Y+20	; 0x14
    f7ca:	9d 89       	ldd	r25, Y+21	; 0x15
    f7cc:	9a 83       	std	Y+2, r25	; 0x02
    f7ce:	89 83       	std	Y+1, r24	; 0x01
    f7d0:	9e 01       	movw	r18, r28
    f7d2:	28 5e       	subi	r18, 0xE8	; 232
    f7d4:	3f 4f       	sbci	r19, 0xFF	; 255
    f7d6:	ce 01       	movw	r24, r28
    f7d8:	01 96       	adiw	r24, 0x01	; 1
    f7da:	6e 89       	ldd	r22, Y+22	; 0x16
    f7dc:	7f 89       	ldd	r23, Y+23	; 0x17
    f7de:	a9 01       	movw	r20, r18
    f7e0:	0e 94 54 77 	call	0xeea8	; 0xeea8 <vfscanf>
    f7e4:	2e 96       	adiw	r28, 0x0e	; 14
    f7e6:	0f b6       	in	r0, 0x3f	; 63
    f7e8:	f8 94       	cli
    f7ea:	de bf       	out	0x3e, r29	; 62
    f7ec:	0f be       	out	0x3f, r0	; 63
    f7ee:	cd bf       	out	0x3d, r28	; 61
    f7f0:	cf 91       	pop	r28
    f7f2:	df 91       	pop	r29
    f7f4:	08 95       	ret

0000f7f6 <sscanf_P>:
    f7f6:	df 93       	push	r29
    f7f8:	cf 93       	push	r28
    f7fa:	cd b7       	in	r28, 0x3d	; 61
    f7fc:	de b7       	in	r29, 0x3e	; 62
    f7fe:	2e 97       	sbiw	r28, 0x0e	; 14
    f800:	0f b6       	in	r0, 0x3f	; 63
    f802:	f8 94       	cli
    f804:	de bf       	out	0x3e, r29	; 62
    f806:	0f be       	out	0x3f, r0	; 63
    f808:	cd bf       	out	0x3d, r28	; 61
    f80a:	8d e0       	ldi	r24, 0x0D	; 13
    f80c:	8c 83       	std	Y+4, r24	; 0x04
    f80e:	8c 89       	ldd	r24, Y+20	; 0x14
    f810:	9d 89       	ldd	r25, Y+21	; 0x15
    f812:	9a 83       	std	Y+2, r25	; 0x02
    f814:	89 83       	std	Y+1, r24	; 0x01
    f816:	9e 01       	movw	r18, r28
    f818:	28 5e       	subi	r18, 0xE8	; 232
    f81a:	3f 4f       	sbci	r19, 0xFF	; 255
    f81c:	ce 01       	movw	r24, r28
    f81e:	01 96       	adiw	r24, 0x01	; 1
    f820:	6e 89       	ldd	r22, Y+22	; 0x16
    f822:	7f 89       	ldd	r23, Y+23	; 0x17
    f824:	a9 01       	movw	r20, r18
    f826:	0e 94 54 77 	call	0xeea8	; 0xeea8 <vfscanf>
    f82a:	2e 96       	adiw	r28, 0x0e	; 14
    f82c:	0f b6       	in	r0, 0x3f	; 63
    f82e:	f8 94       	cli
    f830:	de bf       	out	0x3e, r29	; 62
    f832:	0f be       	out	0x3f, r0	; 63
    f834:	cd bf       	out	0x3d, r28	; 61
    f836:	cf 91       	pop	r28
    f838:	df 91       	pop	r29
    f83a:	08 95       	ret

0000f83c <ungetc>:
    f83c:	9c 01       	movw	r18, r24
    f83e:	fb 01       	movw	r30, r22
    f840:	83 81       	ldd	r24, Z+3	; 0x03
    f842:	80 ff       	sbrs	r24, 0
    f844:	11 c0       	rjmp	.+34     	; 0xf868 <ungetc+0x2c>
    f846:	86 fd       	sbrc	r24, 6
    f848:	0f c0       	rjmp	.+30     	; 0xf868 <ungetc+0x2c>
    f84a:	9f ef       	ldi	r25, 0xFF	; 255
    f84c:	2f 3f       	cpi	r18, 0xFF	; 255
    f84e:	39 07       	cpc	r19, r25
    f850:	59 f0       	breq	.+22     	; 0xf868 <ungetc+0x2c>
    f852:	22 83       	std	Z+2, r18	; 0x02
    f854:	80 64       	ori	r24, 0x40	; 64
    f856:	8f 7d       	andi	r24, 0xDF	; 223
    f858:	83 83       	std	Z+3, r24	; 0x03
    f85a:	86 81       	ldd	r24, Z+6	; 0x06
    f85c:	97 81       	ldd	r25, Z+7	; 0x07
    f85e:	01 97       	sbiw	r24, 0x01	; 1
    f860:	97 83       	std	Z+7, r25	; 0x07
    f862:	86 83       	std	Z+6, r24	; 0x06
    f864:	30 e0       	ldi	r19, 0x00	; 0
    f866:	02 c0       	rjmp	.+4      	; 0xf86c <ungetc+0x30>
    f868:	2f ef       	ldi	r18, 0xFF	; 255
    f86a:	3f ef       	ldi	r19, 0xFF	; 255
    f86c:	c9 01       	movw	r24, r18
    f86e:	08 95       	ret

0000f870 <__ultoa_invert>:
    f870:	fa 01       	movw	r30, r20
    f872:	aa 27       	eor	r26, r26
    f874:	28 30       	cpi	r18, 0x08	; 8
    f876:	51 f1       	breq	.+84     	; 0xf8cc <__ultoa_invert+0x5c>
    f878:	20 31       	cpi	r18, 0x10	; 16
    f87a:	81 f1       	breq	.+96     	; 0xf8dc <__ultoa_invert+0x6c>
    f87c:	e8 94       	clt
    f87e:	6f 93       	push	r22
    f880:	6e 7f       	andi	r22, 0xFE	; 254
    f882:	6e 5f       	subi	r22, 0xFE	; 254
    f884:	7f 4f       	sbci	r23, 0xFF	; 255
    f886:	8f 4f       	sbci	r24, 0xFF	; 255
    f888:	9f 4f       	sbci	r25, 0xFF	; 255
    f88a:	af 4f       	sbci	r26, 0xFF	; 255
    f88c:	b1 e0       	ldi	r27, 0x01	; 1
    f88e:	3e d0       	rcall	.+124    	; 0xf90c <__ultoa_invert+0x9c>
    f890:	b4 e0       	ldi	r27, 0x04	; 4
    f892:	3c d0       	rcall	.+120    	; 0xf90c <__ultoa_invert+0x9c>
    f894:	67 0f       	add	r22, r23
    f896:	78 1f       	adc	r23, r24
    f898:	89 1f       	adc	r24, r25
    f89a:	9a 1f       	adc	r25, r26
    f89c:	a1 1d       	adc	r26, r1
    f89e:	68 0f       	add	r22, r24
    f8a0:	79 1f       	adc	r23, r25
    f8a2:	8a 1f       	adc	r24, r26
    f8a4:	91 1d       	adc	r25, r1
    f8a6:	a1 1d       	adc	r26, r1
    f8a8:	6a 0f       	add	r22, r26
    f8aa:	71 1d       	adc	r23, r1
    f8ac:	81 1d       	adc	r24, r1
    f8ae:	91 1d       	adc	r25, r1
    f8b0:	a1 1d       	adc	r26, r1
    f8b2:	20 d0       	rcall	.+64     	; 0xf8f4 <__ultoa_invert+0x84>
    f8b4:	09 f4       	brne	.+2      	; 0xf8b8 <__ultoa_invert+0x48>
    f8b6:	68 94       	set
    f8b8:	3f 91       	pop	r19
    f8ba:	2a e0       	ldi	r18, 0x0A	; 10
    f8bc:	26 9f       	mul	r18, r22
    f8be:	11 24       	eor	r1, r1
    f8c0:	30 19       	sub	r19, r0
    f8c2:	30 5d       	subi	r19, 0xD0	; 208
    f8c4:	31 93       	st	Z+, r19
    f8c6:	de f6       	brtc	.-74     	; 0xf87e <__ultoa_invert+0xe>
    f8c8:	cf 01       	movw	r24, r30
    f8ca:	08 95       	ret
    f8cc:	46 2f       	mov	r20, r22
    f8ce:	47 70       	andi	r20, 0x07	; 7
    f8d0:	40 5d       	subi	r20, 0xD0	; 208
    f8d2:	41 93       	st	Z+, r20
    f8d4:	b3 e0       	ldi	r27, 0x03	; 3
    f8d6:	0f d0       	rcall	.+30     	; 0xf8f6 <__ultoa_invert+0x86>
    f8d8:	c9 f7       	brne	.-14     	; 0xf8cc <__ultoa_invert+0x5c>
    f8da:	f6 cf       	rjmp	.-20     	; 0xf8c8 <__ultoa_invert+0x58>
    f8dc:	46 2f       	mov	r20, r22
    f8de:	4f 70       	andi	r20, 0x0F	; 15
    f8e0:	40 5d       	subi	r20, 0xD0	; 208
    f8e2:	4a 33       	cpi	r20, 0x3A	; 58
    f8e4:	18 f0       	brcs	.+6      	; 0xf8ec <__ultoa_invert+0x7c>
    f8e6:	49 5d       	subi	r20, 0xD9	; 217
    f8e8:	31 fd       	sbrc	r19, 1
    f8ea:	40 52       	subi	r20, 0x20	; 32
    f8ec:	41 93       	st	Z+, r20
    f8ee:	02 d0       	rcall	.+4      	; 0xf8f4 <__ultoa_invert+0x84>
    f8f0:	a9 f7       	brne	.-22     	; 0xf8dc <__ultoa_invert+0x6c>
    f8f2:	ea cf       	rjmp	.-44     	; 0xf8c8 <__ultoa_invert+0x58>
    f8f4:	b4 e0       	ldi	r27, 0x04	; 4
    f8f6:	a6 95       	lsr	r26
    f8f8:	97 95       	ror	r25
    f8fa:	87 95       	ror	r24
    f8fc:	77 95       	ror	r23
    f8fe:	67 95       	ror	r22
    f900:	ba 95       	dec	r27
    f902:	c9 f7       	brne	.-14     	; 0xf8f6 <__ultoa_invert+0x86>
    f904:	00 97       	sbiw	r24, 0x00	; 0
    f906:	61 05       	cpc	r22, r1
    f908:	71 05       	cpc	r23, r1
    f90a:	08 95       	ret
    f90c:	9b 01       	movw	r18, r22
    f90e:	ac 01       	movw	r20, r24
    f910:	0a 2e       	mov	r0, r26
    f912:	06 94       	lsr	r0
    f914:	57 95       	ror	r21
    f916:	47 95       	ror	r20
    f918:	37 95       	ror	r19
    f91a:	27 95       	ror	r18
    f91c:	ba 95       	dec	r27
    f91e:	c9 f7       	brne	.-14     	; 0xf912 <__ultoa_invert+0xa2>
    f920:	62 0f       	add	r22, r18
    f922:	73 1f       	adc	r23, r19
    f924:	84 1f       	adc	r24, r20
    f926:	95 1f       	adc	r25, r21
    f928:	a0 1d       	adc	r26, r0
    f92a:	08 95       	ret

0000f92c <__subsf3>:
    f92c:	50 58       	subi	r21, 0x80	; 128

0000f92e <__addsf3>:
    f92e:	bb 27       	eor	r27, r27
    f930:	aa 27       	eor	r26, r26
    f932:	0e d0       	rcall	.+28     	; 0xf950 <__addsf3x>
    f934:	af cc       	rjmp	.-1698   	; 0xf294 <__fp_round>
    f936:	a0 dc       	rcall	.-1728   	; 0xf278 <__fp_pscA>
    f938:	30 f0       	brcs	.+12     	; 0xf946 <__addsf3+0x18>
    f93a:	a5 dc       	rcall	.-1718   	; 0xf286 <__fp_pscB>
    f93c:	20 f0       	brcs	.+8      	; 0xf946 <__addsf3+0x18>
    f93e:	31 f4       	brne	.+12     	; 0xf94c <__addsf3+0x1e>
    f940:	9f 3f       	cpi	r25, 0xFF	; 255
    f942:	11 f4       	brne	.+4      	; 0xf948 <__addsf3+0x1a>
    f944:	1e f4       	brtc	.+6      	; 0xf94c <__addsf3+0x1e>
    f946:	95 cc       	rjmp	.-1750   	; 0xf272 <__fp_nan>
    f948:	0e f4       	brtc	.+2      	; 0xf94c <__addsf3+0x1e>
    f94a:	e0 95       	com	r30
    f94c:	e7 fb       	bst	r30, 7
    f94e:	8b cc       	rjmp	.-1770   	; 0xf266 <__fp_inf>

0000f950 <__addsf3x>:
    f950:	e9 2f       	mov	r30, r25
    f952:	b1 dc       	rcall	.-1694   	; 0xf2b6 <__fp_split3>
    f954:	80 f3       	brcs	.-32     	; 0xf936 <__addsf3+0x8>
    f956:	ba 17       	cp	r27, r26
    f958:	62 07       	cpc	r22, r18
    f95a:	73 07       	cpc	r23, r19
    f95c:	84 07       	cpc	r24, r20
    f95e:	95 07       	cpc	r25, r21
    f960:	18 f0       	brcs	.+6      	; 0xf968 <__addsf3x+0x18>
    f962:	71 f4       	brne	.+28     	; 0xf980 <__addsf3x+0x30>
    f964:	9e f5       	brtc	.+102    	; 0xf9cc <__addsf3x+0x7c>
    f966:	c9 cc       	rjmp	.-1646   	; 0xf2fa <__fp_zero>
    f968:	0e f4       	brtc	.+2      	; 0xf96c <__addsf3x+0x1c>
    f96a:	e0 95       	com	r30
    f96c:	0b 2e       	mov	r0, r27
    f96e:	ba 2f       	mov	r27, r26
    f970:	a0 2d       	mov	r26, r0
    f972:	0b 01       	movw	r0, r22
    f974:	b9 01       	movw	r22, r18
    f976:	90 01       	movw	r18, r0
    f978:	0c 01       	movw	r0, r24
    f97a:	ca 01       	movw	r24, r20
    f97c:	a0 01       	movw	r20, r0
    f97e:	11 24       	eor	r1, r1
    f980:	ff 27       	eor	r31, r31
    f982:	59 1b       	sub	r21, r25
    f984:	99 f0       	breq	.+38     	; 0xf9ac <__addsf3x+0x5c>
    f986:	59 3f       	cpi	r21, 0xF9	; 249
    f988:	50 f4       	brcc	.+20     	; 0xf99e <__addsf3x+0x4e>
    f98a:	50 3e       	cpi	r21, 0xE0	; 224
    f98c:	68 f1       	brcs	.+90     	; 0xf9e8 <__addsf3x+0x98>
    f98e:	1a 16       	cp	r1, r26
    f990:	f0 40       	sbci	r31, 0x00	; 0
    f992:	a2 2f       	mov	r26, r18
    f994:	23 2f       	mov	r18, r19
    f996:	34 2f       	mov	r19, r20
    f998:	44 27       	eor	r20, r20
    f99a:	58 5f       	subi	r21, 0xF8	; 248
    f99c:	f3 cf       	rjmp	.-26     	; 0xf984 <__addsf3x+0x34>
    f99e:	46 95       	lsr	r20
    f9a0:	37 95       	ror	r19
    f9a2:	27 95       	ror	r18
    f9a4:	a7 95       	ror	r26
    f9a6:	f0 40       	sbci	r31, 0x00	; 0
    f9a8:	53 95       	inc	r21
    f9aa:	c9 f7       	brne	.-14     	; 0xf99e <__addsf3x+0x4e>
    f9ac:	7e f4       	brtc	.+30     	; 0xf9cc <__addsf3x+0x7c>
    f9ae:	1f 16       	cp	r1, r31
    f9b0:	ba 0b       	sbc	r27, r26
    f9b2:	62 0b       	sbc	r22, r18
    f9b4:	73 0b       	sbc	r23, r19
    f9b6:	84 0b       	sbc	r24, r20
    f9b8:	ba f0       	brmi	.+46     	; 0xf9e8 <__addsf3x+0x98>
    f9ba:	91 50       	subi	r25, 0x01	; 1
    f9bc:	a1 f0       	breq	.+40     	; 0xf9e6 <__addsf3x+0x96>
    f9be:	ff 0f       	add	r31, r31
    f9c0:	bb 1f       	adc	r27, r27
    f9c2:	66 1f       	adc	r22, r22
    f9c4:	77 1f       	adc	r23, r23
    f9c6:	88 1f       	adc	r24, r24
    f9c8:	c2 f7       	brpl	.-16     	; 0xf9ba <__addsf3x+0x6a>
    f9ca:	0e c0       	rjmp	.+28     	; 0xf9e8 <__addsf3x+0x98>
    f9cc:	ba 0f       	add	r27, r26
    f9ce:	62 1f       	adc	r22, r18
    f9d0:	73 1f       	adc	r23, r19
    f9d2:	84 1f       	adc	r24, r20
    f9d4:	48 f4       	brcc	.+18     	; 0xf9e8 <__addsf3x+0x98>
    f9d6:	87 95       	ror	r24
    f9d8:	77 95       	ror	r23
    f9da:	67 95       	ror	r22
    f9dc:	b7 95       	ror	r27
    f9de:	f7 95       	ror	r31
    f9e0:	9e 3f       	cpi	r25, 0xFE	; 254
    f9e2:	08 f0       	brcs	.+2      	; 0xf9e6 <__addsf3x+0x96>
    f9e4:	b3 cf       	rjmp	.-154    	; 0xf94c <__addsf3+0x1e>
    f9e6:	93 95       	inc	r25
    f9e8:	88 0f       	add	r24, r24
    f9ea:	08 f0       	brcs	.+2      	; 0xf9ee <__addsf3x+0x9e>
    f9ec:	99 27       	eor	r25, r25
    f9ee:	ee 0f       	add	r30, r30
    f9f0:	97 95       	ror	r25
    f9f2:	87 95       	ror	r24
    f9f4:	08 95       	ret

0000f9f6 <__divsf3>:
    f9f6:	0c d0       	rcall	.+24     	; 0xfa10 <__divsf3x>
    f9f8:	4d cc       	rjmp	.-1894   	; 0xf294 <__fp_round>
    f9fa:	45 dc       	rcall	.-1910   	; 0xf286 <__fp_pscB>
    f9fc:	40 f0       	brcs	.+16     	; 0xfa0e <__divsf3+0x18>
    f9fe:	3c dc       	rcall	.-1928   	; 0xf278 <__fp_pscA>
    fa00:	30 f0       	brcs	.+12     	; 0xfa0e <__divsf3+0x18>
    fa02:	21 f4       	brne	.+8      	; 0xfa0c <__divsf3+0x16>
    fa04:	5f 3f       	cpi	r21, 0xFF	; 255
    fa06:	19 f0       	breq	.+6      	; 0xfa0e <__divsf3+0x18>
    fa08:	2e cc       	rjmp	.-1956   	; 0xf266 <__fp_inf>
    fa0a:	51 11       	cpse	r21, r1
    fa0c:	77 cc       	rjmp	.-1810   	; 0xf2fc <__fp_szero>
    fa0e:	31 cc       	rjmp	.-1950   	; 0xf272 <__fp_nan>

0000fa10 <__divsf3x>:
    fa10:	52 dc       	rcall	.-1884   	; 0xf2b6 <__fp_split3>
    fa12:	98 f3       	brcs	.-26     	; 0xf9fa <__divsf3+0x4>

0000fa14 <__divsf3_pse>:
    fa14:	99 23       	and	r25, r25
    fa16:	c9 f3       	breq	.-14     	; 0xfa0a <__divsf3+0x14>
    fa18:	55 23       	and	r21, r21
    fa1a:	b1 f3       	breq	.-20     	; 0xfa08 <__divsf3+0x12>
    fa1c:	95 1b       	sub	r25, r21
    fa1e:	55 0b       	sbc	r21, r21
    fa20:	bb 27       	eor	r27, r27
    fa22:	aa 27       	eor	r26, r26
    fa24:	62 17       	cp	r22, r18
    fa26:	73 07       	cpc	r23, r19
    fa28:	84 07       	cpc	r24, r20
    fa2a:	38 f0       	brcs	.+14     	; 0xfa3a <__divsf3_pse+0x26>
    fa2c:	9f 5f       	subi	r25, 0xFF	; 255
    fa2e:	5f 4f       	sbci	r21, 0xFF	; 255
    fa30:	22 0f       	add	r18, r18
    fa32:	33 1f       	adc	r19, r19
    fa34:	44 1f       	adc	r20, r20
    fa36:	aa 1f       	adc	r26, r26
    fa38:	a9 f3       	breq	.-22     	; 0xfa24 <__divsf3_pse+0x10>
    fa3a:	33 d0       	rcall	.+102    	; 0xfaa2 <__divsf3_pse+0x8e>
    fa3c:	0e 2e       	mov	r0, r30
    fa3e:	3a f0       	brmi	.+14     	; 0xfa4e <__divsf3_pse+0x3a>
    fa40:	e0 e8       	ldi	r30, 0x80	; 128
    fa42:	30 d0       	rcall	.+96     	; 0xfaa4 <__divsf3_pse+0x90>
    fa44:	91 50       	subi	r25, 0x01	; 1
    fa46:	50 40       	sbci	r21, 0x00	; 0
    fa48:	e6 95       	lsr	r30
    fa4a:	00 1c       	adc	r0, r0
    fa4c:	ca f7       	brpl	.-14     	; 0xfa40 <__divsf3_pse+0x2c>
    fa4e:	29 d0       	rcall	.+82     	; 0xfaa2 <__divsf3_pse+0x8e>
    fa50:	fe 2f       	mov	r31, r30
    fa52:	27 d0       	rcall	.+78     	; 0xfaa2 <__divsf3_pse+0x8e>
    fa54:	66 0f       	add	r22, r22
    fa56:	77 1f       	adc	r23, r23
    fa58:	88 1f       	adc	r24, r24
    fa5a:	bb 1f       	adc	r27, r27
    fa5c:	26 17       	cp	r18, r22
    fa5e:	37 07       	cpc	r19, r23
    fa60:	48 07       	cpc	r20, r24
    fa62:	ab 07       	cpc	r26, r27
    fa64:	b0 e8       	ldi	r27, 0x80	; 128
    fa66:	09 f0       	breq	.+2      	; 0xfa6a <__divsf3_pse+0x56>
    fa68:	bb 0b       	sbc	r27, r27
    fa6a:	80 2d       	mov	r24, r0
    fa6c:	bf 01       	movw	r22, r30
    fa6e:	ff 27       	eor	r31, r31
    fa70:	93 58       	subi	r25, 0x83	; 131
    fa72:	5f 4f       	sbci	r21, 0xFF	; 255
    fa74:	2a f0       	brmi	.+10     	; 0xfa80 <__divsf3_pse+0x6c>
    fa76:	9e 3f       	cpi	r25, 0xFE	; 254
    fa78:	51 05       	cpc	r21, r1
    fa7a:	68 f0       	brcs	.+26     	; 0xfa96 <__divsf3_pse+0x82>
    fa7c:	f4 cb       	rjmp	.-2072   	; 0xf266 <__fp_inf>
    fa7e:	3e cc       	rjmp	.-1924   	; 0xf2fc <__fp_szero>
    fa80:	5f 3f       	cpi	r21, 0xFF	; 255
    fa82:	ec f3       	brlt	.-6      	; 0xfa7e <__divsf3_pse+0x6a>
    fa84:	98 3e       	cpi	r25, 0xE8	; 232
    fa86:	dc f3       	brlt	.-10     	; 0xfa7e <__divsf3_pse+0x6a>
    fa88:	86 95       	lsr	r24
    fa8a:	77 95       	ror	r23
    fa8c:	67 95       	ror	r22
    fa8e:	b7 95       	ror	r27
    fa90:	f7 95       	ror	r31
    fa92:	9f 5f       	subi	r25, 0xFF	; 255
    fa94:	c9 f7       	brne	.-14     	; 0xfa88 <__divsf3_pse+0x74>
    fa96:	88 0f       	add	r24, r24
    fa98:	91 1d       	adc	r25, r1
    fa9a:	96 95       	lsr	r25
    fa9c:	87 95       	ror	r24
    fa9e:	97 f9       	bld	r25, 7
    faa0:	08 95       	ret
    faa2:	e1 e0       	ldi	r30, 0x01	; 1
    faa4:	66 0f       	add	r22, r22
    faa6:	77 1f       	adc	r23, r23
    faa8:	88 1f       	adc	r24, r24
    faaa:	bb 1f       	adc	r27, r27
    faac:	62 17       	cp	r22, r18
    faae:	73 07       	cpc	r23, r19
    fab0:	84 07       	cpc	r24, r20
    fab2:	ba 07       	cpc	r27, r26
    fab4:	20 f0       	brcs	.+8      	; 0xfabe <__divsf3_pse+0xaa>
    fab6:	62 1b       	sub	r22, r18
    fab8:	73 0b       	sbc	r23, r19
    faba:	84 0b       	sbc	r24, r20
    fabc:	ba 0b       	sbc	r27, r26
    fabe:	ee 1f       	adc	r30, r30
    fac0:	88 f7       	brcc	.-30     	; 0xfaa4 <__divsf3_pse+0x90>
    fac2:	e0 95       	com	r30
    fac4:	08 95       	ret

0000fac6 <__fixsfsi>:
    fac6:	04 d0       	rcall	.+8      	; 0xfad0 <__fixunssfsi>
    fac8:	68 94       	set
    faca:	b1 11       	cpse	r27, r1
    facc:	17 cc       	rjmp	.-2002   	; 0xf2fc <__fp_szero>
    face:	08 95       	ret

0000fad0 <__fixunssfsi>:
    fad0:	fa db       	rcall	.-2060   	; 0xf2c6 <__fp_splitA>
    fad2:	88 f0       	brcs	.+34     	; 0xfaf6 <__fixunssfsi+0x26>
    fad4:	9f 57       	subi	r25, 0x7F	; 127
    fad6:	90 f0       	brcs	.+36     	; 0xfafc <__fixunssfsi+0x2c>
    fad8:	b9 2f       	mov	r27, r25
    fada:	99 27       	eor	r25, r25
    fadc:	b7 51       	subi	r27, 0x17	; 23
    fade:	a0 f0       	brcs	.+40     	; 0xfb08 <__fixunssfsi+0x38>
    fae0:	d1 f0       	breq	.+52     	; 0xfb16 <__fixunssfsi+0x46>
    fae2:	66 0f       	add	r22, r22
    fae4:	77 1f       	adc	r23, r23
    fae6:	88 1f       	adc	r24, r24
    fae8:	99 1f       	adc	r25, r25
    faea:	1a f0       	brmi	.+6      	; 0xfaf2 <__fixunssfsi+0x22>
    faec:	ba 95       	dec	r27
    faee:	c9 f7       	brne	.-14     	; 0xfae2 <__fixunssfsi+0x12>
    faf0:	12 c0       	rjmp	.+36     	; 0xfb16 <__fixunssfsi+0x46>
    faf2:	b1 30       	cpi	r27, 0x01	; 1
    faf4:	81 f0       	breq	.+32     	; 0xfb16 <__fixunssfsi+0x46>
    faf6:	01 dc       	rcall	.-2046   	; 0xf2fa <__fp_zero>
    faf8:	b1 e0       	ldi	r27, 0x01	; 1
    fafa:	08 95       	ret
    fafc:	fe cb       	rjmp	.-2052   	; 0xf2fa <__fp_zero>
    fafe:	67 2f       	mov	r22, r23
    fb00:	78 2f       	mov	r23, r24
    fb02:	88 27       	eor	r24, r24
    fb04:	b8 5f       	subi	r27, 0xF8	; 248
    fb06:	39 f0       	breq	.+14     	; 0xfb16 <__fixunssfsi+0x46>
    fb08:	b9 3f       	cpi	r27, 0xF9	; 249
    fb0a:	cc f3       	brlt	.-14     	; 0xfafe <__fixunssfsi+0x2e>
    fb0c:	86 95       	lsr	r24
    fb0e:	77 95       	ror	r23
    fb10:	67 95       	ror	r22
    fb12:	b3 95       	inc	r27
    fb14:	d9 f7       	brne	.-10     	; 0xfb0c <__fixunssfsi+0x3c>
    fb16:	3e f4       	brtc	.+14     	; 0xfb26 <__fixunssfsi+0x56>
    fb18:	90 95       	com	r25
    fb1a:	80 95       	com	r24
    fb1c:	70 95       	com	r23
    fb1e:	61 95       	neg	r22
    fb20:	7f 4f       	sbci	r23, 0xFF	; 255
    fb22:	8f 4f       	sbci	r24, 0xFF	; 255
    fb24:	9f 4f       	sbci	r25, 0xFF	; 255
    fb26:	08 95       	ret

0000fb28 <__eerd_block_m2560>:
    fb28:	dc 01       	movw	r26, r24
    fb2a:	cb 01       	movw	r24, r22

0000fb2c <__eerd_blraw_m2560>:
    fb2c:	fc 01       	movw	r30, r24
    fb2e:	f9 99       	sbic	0x1f, 1	; 31
    fb30:	fe cf       	rjmp	.-4      	; 0xfb2e <__eerd_blraw_m2560+0x2>
    fb32:	06 c0       	rjmp	.+12     	; 0xfb40 <__eerd_blraw_m2560+0x14>
    fb34:	f2 bd       	out	0x22, r31	; 34
    fb36:	e1 bd       	out	0x21, r30	; 33
    fb38:	f8 9a       	sbi	0x1f, 0	; 31
    fb3a:	31 96       	adiw	r30, 0x01	; 1
    fb3c:	00 b4       	in	r0, 0x20	; 32
    fb3e:	0d 92       	st	X+, r0
    fb40:	41 50       	subi	r20, 0x01	; 1
    fb42:	50 40       	sbci	r21, 0x00	; 0
    fb44:	b8 f7       	brcc	.-18     	; 0xfb34 <__eerd_blraw_m2560+0x8>
    fb46:	08 95       	ret

0000fb48 <__eerd_byte_m2560>:
    fb48:	f9 99       	sbic	0x1f, 1	; 31
    fb4a:	fe cf       	rjmp	.-4      	; 0xfb48 <__eerd_byte_m2560>
    fb4c:	92 bd       	out	0x22, r25	; 34
    fb4e:	81 bd       	out	0x21, r24	; 33
    fb50:	f8 9a       	sbi	0x1f, 0	; 31
    fb52:	99 27       	eor	r25, r25
    fb54:	80 b5       	in	r24, 0x20	; 32
    fb56:	08 95       	ret

0000fb58 <__eerd_dword_m2560>:
    fb58:	a6 e1       	ldi	r26, 0x16	; 22
    fb5a:	b0 e0       	ldi	r27, 0x00	; 0
    fb5c:	44 e0       	ldi	r20, 0x04	; 4
    fb5e:	50 e0       	ldi	r21, 0x00	; 0
    fb60:	0c 94 96 7d 	jmp	0xfb2c	; 0xfb2c <__eerd_blraw_m2560>

0000fb64 <__eerd_word_m2560>:
    fb64:	a8 e1       	ldi	r26, 0x18	; 24
    fb66:	b0 e0       	ldi	r27, 0x00	; 0
    fb68:	42 e0       	ldi	r20, 0x02	; 2
    fb6a:	50 e0       	ldi	r21, 0x00	; 0
    fb6c:	0c 94 96 7d 	jmp	0xfb2c	; 0xfb2c <__eerd_blraw_m2560>

0000fb70 <__eewr_block_m2560>:
    fb70:	dc 01       	movw	r26, r24
    fb72:	cb 01       	movw	r24, r22
    fb74:	03 c0       	rjmp	.+6      	; 0xfb7c <__eewr_block_m2560+0xc>
    fb76:	2d 91       	ld	r18, X+
    fb78:	0e 94 c3 7d 	call	0xfb86	; 0xfb86 <__eewr_r18_m2560>
    fb7c:	41 50       	subi	r20, 0x01	; 1
    fb7e:	50 40       	sbci	r21, 0x00	; 0
    fb80:	d0 f7       	brcc	.-12     	; 0xfb76 <__eewr_block_m2560+0x6>
    fb82:	08 95       	ret

0000fb84 <__eewr_byte_m2560>:
    fb84:	26 2f       	mov	r18, r22

0000fb86 <__eewr_r18_m2560>:
    fb86:	f9 99       	sbic	0x1f, 1	; 31
    fb88:	fe cf       	rjmp	.-4      	; 0xfb86 <__eewr_r18_m2560>
    fb8a:	1f ba       	out	0x1f, r1	; 31
    fb8c:	92 bd       	out	0x22, r25	; 34
    fb8e:	81 bd       	out	0x21, r24	; 33
    fb90:	20 bd       	out	0x20, r18	; 32
    fb92:	0f b6       	in	r0, 0x3f	; 63
    fb94:	f8 94       	cli
    fb96:	fa 9a       	sbi	0x1f, 2	; 31
    fb98:	f9 9a       	sbi	0x1f, 1	; 31
    fb9a:	0f be       	out	0x3f, r0	; 63
    fb9c:	01 96       	adiw	r24, 0x01	; 1
    fb9e:	08 95       	ret

0000fba0 <__eewr_dword_m2560>:
    fba0:	24 2f       	mov	r18, r20
    fba2:	0e 94 c3 7d 	call	0xfb86	; 0xfb86 <__eewr_r18_m2560>
    fba6:	25 2f       	mov	r18, r21
    fba8:	0e 94 c3 7d 	call	0xfb86	; 0xfb86 <__eewr_r18_m2560>
    fbac:	0c 94 d8 7d 	jmp	0xfbb0	; 0xfbb0 <__eewr_word_m2560>

0000fbb0 <__eewr_word_m2560>:
    fbb0:	0e 94 c2 7d 	call	0xfb84	; 0xfb84 <__eewr_byte_m2560>
    fbb4:	27 2f       	mov	r18, r23
    fbb6:	0c 94 c3 7d 	jmp	0xfb86	; 0xfb86 <__eewr_r18_m2560>

0000fbba <__ctype_isfalse>:
    fbba:	99 27       	eor	r25, r25
    fbbc:	88 27       	eor	r24, r24

0000fbbe <__ctype_istrue>:
    fbbe:	08 95       	ret

0000fbc0 <__mulsi3>:
    fbc0:	62 9f       	mul	r22, r18
    fbc2:	d0 01       	movw	r26, r0
    fbc4:	73 9f       	mul	r23, r19
    fbc6:	f0 01       	movw	r30, r0
    fbc8:	82 9f       	mul	r24, r18
    fbca:	e0 0d       	add	r30, r0
    fbcc:	f1 1d       	adc	r31, r1
    fbce:	64 9f       	mul	r22, r20
    fbd0:	e0 0d       	add	r30, r0
    fbd2:	f1 1d       	adc	r31, r1
    fbd4:	92 9f       	mul	r25, r18
    fbd6:	f0 0d       	add	r31, r0
    fbd8:	83 9f       	mul	r24, r19
    fbda:	f0 0d       	add	r31, r0
    fbdc:	74 9f       	mul	r23, r20
    fbde:	f0 0d       	add	r31, r0
    fbe0:	65 9f       	mul	r22, r21
    fbe2:	f0 0d       	add	r31, r0
    fbe4:	99 27       	eor	r25, r25
    fbe6:	72 9f       	mul	r23, r18
    fbe8:	b0 0d       	add	r27, r0
    fbea:	e1 1d       	adc	r30, r1
    fbec:	f9 1f       	adc	r31, r25
    fbee:	63 9f       	mul	r22, r19
    fbf0:	b0 0d       	add	r27, r0
    fbf2:	e1 1d       	adc	r30, r1
    fbf4:	f9 1f       	adc	r31, r25
    fbf6:	bd 01       	movw	r22, r26
    fbf8:	cf 01       	movw	r24, r30
    fbfa:	11 24       	eor	r1, r1
    fbfc:	08 95       	ret

0000fbfe <__udivmodqi4>:
    fbfe:	99 1b       	sub	r25, r25
    fc00:	79 e0       	ldi	r23, 0x09	; 9
    fc02:	04 c0       	rjmp	.+8      	; 0xfc0c <__udivmodqi4_ep>

0000fc04 <__udivmodqi4_loop>:
    fc04:	99 1f       	adc	r25, r25
    fc06:	96 17       	cp	r25, r22
    fc08:	08 f0       	brcs	.+2      	; 0xfc0c <__udivmodqi4_ep>
    fc0a:	96 1b       	sub	r25, r22

0000fc0c <__udivmodqi4_ep>:
    fc0c:	88 1f       	adc	r24, r24
    fc0e:	7a 95       	dec	r23
    fc10:	c9 f7       	brne	.-14     	; 0xfc04 <__udivmodqi4_loop>
    fc12:	80 95       	com	r24
    fc14:	08 95       	ret

0000fc16 <__udivmodhi4>:
    fc16:	aa 1b       	sub	r26, r26
    fc18:	bb 1b       	sub	r27, r27
    fc1a:	51 e1       	ldi	r21, 0x11	; 17
    fc1c:	07 c0       	rjmp	.+14     	; 0xfc2c <__udivmodhi4_ep>

0000fc1e <__udivmodhi4_loop>:
    fc1e:	aa 1f       	adc	r26, r26
    fc20:	bb 1f       	adc	r27, r27
    fc22:	a6 17       	cp	r26, r22
    fc24:	b7 07       	cpc	r27, r23
    fc26:	10 f0       	brcs	.+4      	; 0xfc2c <__udivmodhi4_ep>
    fc28:	a6 1b       	sub	r26, r22
    fc2a:	b7 0b       	sbc	r27, r23

0000fc2c <__udivmodhi4_ep>:
    fc2c:	88 1f       	adc	r24, r24
    fc2e:	99 1f       	adc	r25, r25
    fc30:	5a 95       	dec	r21
    fc32:	a9 f7       	brne	.-22     	; 0xfc1e <__udivmodhi4_loop>
    fc34:	80 95       	com	r24
    fc36:	90 95       	com	r25
    fc38:	bc 01       	movw	r22, r24
    fc3a:	cd 01       	movw	r24, r26
    fc3c:	08 95       	ret

0000fc3e <__divmodhi4>:
    fc3e:	97 fb       	bst	r25, 7
    fc40:	09 2e       	mov	r0, r25
    fc42:	07 26       	eor	r0, r23
    fc44:	0a d0       	rcall	.+20     	; 0xfc5a <__divmodhi4_neg1>
    fc46:	77 fd       	sbrc	r23, 7
    fc48:	04 d0       	rcall	.+8      	; 0xfc52 <__divmodhi4_neg2>
    fc4a:	e5 df       	rcall	.-54     	; 0xfc16 <__udivmodhi4>
    fc4c:	06 d0       	rcall	.+12     	; 0xfc5a <__divmodhi4_neg1>
    fc4e:	00 20       	and	r0, r0
    fc50:	1a f4       	brpl	.+6      	; 0xfc58 <__divmodhi4_exit>

0000fc52 <__divmodhi4_neg2>:
    fc52:	70 95       	com	r23
    fc54:	61 95       	neg	r22
    fc56:	7f 4f       	sbci	r23, 0xFF	; 255

0000fc58 <__divmodhi4_exit>:
    fc58:	08 95       	ret

0000fc5a <__divmodhi4_neg1>:
    fc5a:	f6 f7       	brtc	.-4      	; 0xfc58 <__divmodhi4_exit>
    fc5c:	90 95       	com	r25
    fc5e:	81 95       	neg	r24
    fc60:	9f 4f       	sbci	r25, 0xFF	; 255
    fc62:	08 95       	ret

0000fc64 <__udivmodsi4>:
    fc64:	a1 e2       	ldi	r26, 0x21	; 33
    fc66:	1a 2e       	mov	r1, r26
    fc68:	aa 1b       	sub	r26, r26
    fc6a:	bb 1b       	sub	r27, r27
    fc6c:	fd 01       	movw	r30, r26
    fc6e:	0d c0       	rjmp	.+26     	; 0xfc8a <__udivmodsi4_ep>

0000fc70 <__udivmodsi4_loop>:
    fc70:	aa 1f       	adc	r26, r26
    fc72:	bb 1f       	adc	r27, r27
    fc74:	ee 1f       	adc	r30, r30
    fc76:	ff 1f       	adc	r31, r31
    fc78:	a2 17       	cp	r26, r18
    fc7a:	b3 07       	cpc	r27, r19
    fc7c:	e4 07       	cpc	r30, r20
    fc7e:	f5 07       	cpc	r31, r21
    fc80:	20 f0       	brcs	.+8      	; 0xfc8a <__udivmodsi4_ep>
    fc82:	a2 1b       	sub	r26, r18
    fc84:	b3 0b       	sbc	r27, r19
    fc86:	e4 0b       	sbc	r30, r20
    fc88:	f5 0b       	sbc	r31, r21

0000fc8a <__udivmodsi4_ep>:
    fc8a:	66 1f       	adc	r22, r22
    fc8c:	77 1f       	adc	r23, r23
    fc8e:	88 1f       	adc	r24, r24
    fc90:	99 1f       	adc	r25, r25
    fc92:	1a 94       	dec	r1
    fc94:	69 f7       	brne	.-38     	; 0xfc70 <__udivmodsi4_loop>
    fc96:	60 95       	com	r22
    fc98:	70 95       	com	r23
    fc9a:	80 95       	com	r24
    fc9c:	90 95       	com	r25
    fc9e:	9b 01       	movw	r18, r22
    fca0:	ac 01       	movw	r20, r24
    fca2:	bd 01       	movw	r22, r26
    fca4:	cf 01       	movw	r24, r30
    fca6:	08 95       	ret

0000fca8 <__divmodsi4>:
    fca8:	97 fb       	bst	r25, 7
    fcaa:	09 2e       	mov	r0, r25
    fcac:	05 26       	eor	r0, r21
    fcae:	0e d0       	rcall	.+28     	; 0xfccc <__divmodsi4_neg1>
    fcb0:	57 fd       	sbrc	r21, 7
    fcb2:	04 d0       	rcall	.+8      	; 0xfcbc <__divmodsi4_neg2>
    fcb4:	d7 df       	rcall	.-82     	; 0xfc64 <__udivmodsi4>
    fcb6:	0a d0       	rcall	.+20     	; 0xfccc <__divmodsi4_neg1>
    fcb8:	00 1c       	adc	r0, r0
    fcba:	38 f4       	brcc	.+14     	; 0xfcca <__divmodsi4_exit>

0000fcbc <__divmodsi4_neg2>:
    fcbc:	50 95       	com	r21
    fcbe:	40 95       	com	r20
    fcc0:	30 95       	com	r19
    fcc2:	21 95       	neg	r18
    fcc4:	3f 4f       	sbci	r19, 0xFF	; 255
    fcc6:	4f 4f       	sbci	r20, 0xFF	; 255
    fcc8:	5f 4f       	sbci	r21, 0xFF	; 255

0000fcca <__divmodsi4_exit>:
    fcca:	08 95       	ret

0000fccc <__divmodsi4_neg1>:
    fccc:	f6 f7       	brtc	.-4      	; 0xfcca <__divmodsi4_exit>
    fcce:	90 95       	com	r25
    fcd0:	80 95       	com	r24
    fcd2:	70 95       	com	r23
    fcd4:	61 95       	neg	r22
    fcd6:	7f 4f       	sbci	r23, 0xFF	; 255
    fcd8:	8f 4f       	sbci	r24, 0xFF	; 255
    fcda:	9f 4f       	sbci	r25, 0xFF	; 255
    fcdc:	08 95       	ret

0000fcde <_exit>:
    fcde:	f8 94       	cli

0000fce0 <__stop_program>:
    fce0:	ff cf       	rjmp	.-2      	; 0xfce0 <__stop_program>
