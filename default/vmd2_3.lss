
vmd2_3.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000da  00800200  000109c8  00010a7c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000109c8  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000999  008002da  008002da  00010b56  2**0
                  ALLOC
  3 .eeprom       000001a0  00810000  00810000  00010b56  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .debug_aranges 00000020  00000000  00000000  00010cf6  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 000030e0  00000000  00000000  00010d16  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000fbe8  00000000  00000000  00013df6  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000750  00000000  00000000  000239de  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00008dde  00000000  00000000  0002412e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000012f0  00000000  00000000  0002cf0c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000392c  00000000  00000000  0002e1fc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000084aa  00000000  00000000  00031b28  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00001128  00000000  00000000  00039fd2  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 fe 19 	jmp	0x33fc	; 0x33fc <__ctors_end>
       4:	0c 94 1f 1a 	jmp	0x343e	; 0x343e <__bad_interrupt>
       8:	0c 94 1f 1a 	jmp	0x343e	; 0x343e <__bad_interrupt>
       c:	0c 94 1f 1a 	jmp	0x343e	; 0x343e <__bad_interrupt>
      10:	0c 94 1f 1a 	jmp	0x343e	; 0x343e <__bad_interrupt>
      14:	0c 94 1f 1a 	jmp	0x343e	; 0x343e <__bad_interrupt>
      18:	0c 94 1f 1a 	jmp	0x343e	; 0x343e <__bad_interrupt>
      1c:	0c 94 1f 1a 	jmp	0x343e	; 0x343e <__bad_interrupt>
      20:	0c 94 1f 1a 	jmp	0x343e	; 0x343e <__bad_interrupt>
      24:	0c 94 1f 1a 	jmp	0x343e	; 0x343e <__bad_interrupt>
      28:	0c 94 1f 1a 	jmp	0x343e	; 0x343e <__bad_interrupt>
      2c:	0c 94 1f 1a 	jmp	0x343e	; 0x343e <__bad_interrupt>
      30:	0c 94 1f 1a 	jmp	0x343e	; 0x343e <__bad_interrupt>
      34:	0c 94 ca 29 	jmp	0x5394	; 0x5394 <__vector_13>
      38:	0c 94 1f 1a 	jmp	0x343e	; 0x343e <__bad_interrupt>
      3c:	0c 94 1f 1a 	jmp	0x343e	; 0x343e <__bad_interrupt>
      40:	0c 94 1f 1a 	jmp	0x343e	; 0x343e <__bad_interrupt>
      44:	0c 94 6e 1e 	jmp	0x3cdc	; 0x3cdc <__vector_17>
      48:	0c 94 97 27 	jmp	0x4f2e	; 0x4f2e <__vector_18>
      4c:	0c 94 1f 1a 	jmp	0x343e	; 0x343e <__bad_interrupt>
      50:	0c 94 1f 1a 	jmp	0x343e	; 0x343e <__bad_interrupt>
      54:	0c 94 98 29 	jmp	0x5330	; 0x5330 <__vector_21>
      58:	0c 94 1f 1a 	jmp	0x343e	; 0x343e <__bad_interrupt>
      5c:	0c 94 1f 1a 	jmp	0x343e	; 0x343e <__bad_interrupt>
      60:	0c 94 1f 1a 	jmp	0x343e	; 0x343e <__bad_interrupt>
      64:	0c 94 07 3b 	jmp	0x760e	; 0x760e <__vector_25>
      68:	0c 94 5b 3b 	jmp	0x76b6	; 0x76b6 <__vector_26>
      6c:	0c 94 31 3b 	jmp	0x7662	; 0x7662 <__vector_27>
      70:	0c 94 1f 1a 	jmp	0x343e	; 0x343e <__bad_interrupt>
      74:	0c 94 1f 1a 	jmp	0x343e	; 0x343e <__bad_interrupt>
      78:	0c 94 1f 1a 	jmp	0x343e	; 0x343e <__bad_interrupt>
      7c:	0c 94 1f 1a 	jmp	0x343e	; 0x343e <__bad_interrupt>
      80:	0c 94 1f 1a 	jmp	0x343e	; 0x343e <__bad_interrupt>
      84:	0c 94 1f 1a 	jmp	0x343e	; 0x343e <__bad_interrupt>
      88:	0c 94 1f 1a 	jmp	0x343e	; 0x343e <__bad_interrupt>
      8c:	0c 94 1f 1a 	jmp	0x343e	; 0x343e <__bad_interrupt>
      90:	0c 94 85 3b 	jmp	0x770a	; 0x770a <__vector_36>
      94:	0c 94 d9 3b 	jmp	0x77b2	; 0x77b2 <__vector_37>
      98:	0c 94 af 3b 	jmp	0x775e	; 0x775e <__vector_38>
      9c:	0c 94 1f 1a 	jmp	0x343e	; 0x343e <__bad_interrupt>
      a0:	0c 94 1f 1a 	jmp	0x343e	; 0x343e <__bad_interrupt>
      a4:	0c 94 1f 1a 	jmp	0x343e	; 0x343e <__bad_interrupt>
      a8:	0c 94 fe 29 	jmp	0x53fc	; 0x53fc <__vector_42>
      ac:	0c 94 1f 1a 	jmp	0x343e	; 0x343e <__bad_interrupt>
      b0:	0c 94 1f 1a 	jmp	0x343e	; 0x343e <__bad_interrupt>
      b4:	0c 94 1f 1a 	jmp	0x343e	; 0x343e <__bad_interrupt>
      b8:	0c 94 1f 1a 	jmp	0x343e	; 0x343e <__bad_interrupt>
      bc:	0c 94 1f 1a 	jmp	0x343e	; 0x343e <__bad_interrupt>
      c0:	0c 94 1f 1a 	jmp	0x343e	; 0x343e <__bad_interrupt>
      c4:	0c 94 1f 1a 	jmp	0x343e	; 0x343e <__bad_interrupt>
      c8:	0c 94 1f 1a 	jmp	0x343e	; 0x343e <__bad_interrupt>
      cc:	0c 94 53 3c 	jmp	0x78a6	; 0x78a6 <__vector_51>
      d0:	0c 94 03 3c 	jmp	0x7806	; 0x7806 <__vector_52>
      d4:	0c 94 2b 3c 	jmp	0x7856	; 0x7856 <__vector_53>
      d8:	0c 94 1f 1a 	jmp	0x343e	; 0x343e <__bad_interrupt>
      dc:	0c 94 1f 1a 	jmp	0x343e	; 0x343e <__bad_interrupt>
      e0:	0c 94 1f 1a 	jmp	0x343e	; 0x343e <__bad_interrupt>
      e4:	25 52       	subi	r18, 0x25	; 37
      e6:	4b 52       	subi	r20, 0x2B	; 43
      e8:	5c 52       	subi	r21, 0x2C	; 44
      ea:	6f 52       	subi	r22, 0x2F	; 47
      ec:	25 52       	subi	r18, 0x25	; 37
      ee:	4b 52       	subi	r20, 0x2B	; 43
      f0:	af 51       	subi	r26, 0x1F	; 31
      f2:	83 52       	subi	r24, 0x23	; 35
      f4:	93 52       	subi	r25, 0x23	; 35
      f6:	a3 52       	subi	r26, 0x23	; 35
      f8:	b6 52       	subi	r27, 0x26	; 38
      fa:	83 52       	subi	r24, 0x23	; 35
      fc:	93 52       	subi	r25, 0x23	; 35
      fe:	c9 52       	subi	r28, 0x29	; 41
     100:	c9 52       	subi	r28, 0x29	; 41
     102:	af 51       	subi	r26, 0x1F	; 31
     104:	af 51       	subi	r26, 0x1F	; 31
     106:	af 51       	subi	r26, 0x1F	; 31
     108:	af 51       	subi	r26, 0x1F	; 31
     10a:	af 51       	subi	r26, 0x1F	; 31
     10c:	af 51       	subi	r26, 0x1F	; 31
     10e:	af 51       	subi	r26, 0x1F	; 31
     110:	af 51       	subi	r26, 0x1F	; 31
     112:	af 51       	subi	r26, 0x1F	; 31
     114:	af 51       	subi	r26, 0x1F	; 31
     116:	af 51       	subi	r26, 0x1F	; 31
     118:	af 51       	subi	r26, 0x1F	; 31
     11a:	af 51       	subi	r26, 0x1F	; 31
     11c:	af 51       	subi	r26, 0x1F	; 31
     11e:	d7 52       	subi	r29, 0x27	; 39
     120:	e5 52       	subi	r30, 0x25	; 37
     122:	f4 52       	subi	r31, 0x24	; 36
     124:	05 53       	subi	r16, 0x35	; 53
     126:	f5 55       	subi	r31, 0x55	; 85
     128:	14 56       	subi	r17, 0x64	; 100
     12a:	35 56       	subi	r19, 0x65	; 101
     12c:	58 56       	subi	r21, 0x68	; 104
     12e:	f5 55       	subi	r31, 0x55	; 85
     130:	14 56       	subi	r17, 0x64	; 100
     132:	b7 55       	subi	r27, 0x57	; 87
     134:	7d 56       	subi	r23, 0x6D	; 109
     136:	9b 56       	subi	r25, 0x6B	; 107
     138:	ba 56       	subi	r27, 0x6A	; 106
     13a:	dc 56       	subi	r29, 0x6C	; 108
     13c:	7d 56       	subi	r23, 0x6D	; 109
     13e:	9b 56       	subi	r25, 0x6B	; 107
     140:	ff 56       	subi	r31, 0x6F	; 111
     142:	ff 56       	subi	r31, 0x6F	; 111
     144:	b7 55       	subi	r27, 0x57	; 87
     146:	07 57       	subi	r16, 0x77	; 119
     148:	80 55       	subi	r24, 0x50	; 80
     14a:	3e 57       	subi	r19, 0x7E	; 126
     14c:	75 57       	subi	r23, 0x75	; 117
     14e:	07 57       	subi	r16, 0x77	; 119
     150:	80 55       	subi	r24, 0x50	; 80
     152:	b7 55       	subi	r27, 0x57	; 87
     154:	b7 55       	subi	r27, 0x57	; 87
     156:	b7 55       	subi	r27, 0x57	; 87
     158:	b2 57       	subi	r27, 0x72	; 114
     15a:	dc 57       	subi	r29, 0x7C	; 124
     15c:	b2 57       	subi	r27, 0x72	; 114
     15e:	dc 57       	subi	r29, 0x7C	; 124
     160:	f5 55       	subi	r31, 0x55	; 85
     162:	14 56       	subi	r17, 0x64	; 100
     164:	06 58       	subi	r16, 0x86	; 134
     166:	17 58       	subi	r17, 0x87	; 135
     168:	2e 58       	subi	r18, 0x8E	; 142
     16a:	d3 55       	subi	r29, 0x53	; 83
     16c:	0e 5b       	subi	r16, 0xBE	; 190
     16e:	0e 5b       	subi	r16, 0xBE	; 190
     170:	c5 5a       	subi	r28, 0xA5	; 165
     172:	c5 5a       	subi	r28, 0xA5	; 165
     174:	0e 5b       	subi	r16, 0xBE	; 190
     176:	0e 5b       	subi	r16, 0xBE	; 190
     178:	d1 59       	subi	r29, 0x91	; 145
     17a:	0e 5b       	subi	r16, 0xBE	; 190
     17c:	0e 5b       	subi	r16, 0xBE	; 190
     17e:	c5 5a       	subi	r28, 0xA5	; 165
     180:	c5 5a       	subi	r28, 0xA5	; 165
     182:	0e 5b       	subi	r16, 0xBE	; 190
     184:	0e 5b       	subi	r16, 0xBE	; 190
     186:	a1 5a       	subi	r26, 0xA1	; 161
     188:	a1 5a       	subi	r26, 0xA1	; 161
     18a:	d1 59       	subi	r29, 0x91	; 145
     18c:	89 5a       	subi	r24, 0xA9	; 169
     18e:	89 5a       	subi	r24, 0xA9	; 169
     190:	89 5a       	subi	r24, 0xA9	; 169
     192:	89 5a       	subi	r24, 0xA9	; 169
     194:	89 5a       	subi	r24, 0xA9	; 169
     196:	89 5a       	subi	r24, 0xA9	; 169
     198:	d1 59       	subi	r29, 0x91	; 145
     19a:	d1 59       	subi	r29, 0x91	; 145
     19c:	d1 59       	subi	r29, 0x91	; 145
     19e:	89 5a       	subi	r24, 0xA9	; 169
     1a0:	89 5a       	subi	r24, 0xA9	; 169
     1a2:	89 5a       	subi	r24, 0xA9	; 169
     1a4:	89 5a       	subi	r24, 0xA9	; 169
     1a6:	6b 5a       	subi	r22, 0xAB	; 171
     1a8:	6b 5a       	subi	r22, 0xAB	; 171
     1aa:	4e 5a       	subi	r20, 0xAE	; 174
     1ac:	4e 5a       	subi	r20, 0xAE	; 174
     1ae:	16 5a       	subi	r17, 0xA6	; 166
     1b0:	16 5a       	subi	r17, 0xA6	; 166
     1b2:	f6 5d       	subi	r31, 0xD6	; 214
     1b4:	ed 5d       	subi	r30, 0xDD	; 221
     1b6:	e5 5d       	subi	r30, 0xD5	; 213
     1b8:	da 5d       	subi	r29, 0xDA	; 218
     1ba:	d4 5d       	subi	r29, 0xD4	; 212
     1bc:	cb 5d       	subi	r28, 0xDB	; 219
     1be:	c2 5d       	subi	r28, 0xD2	; 210
     1c0:	bc 5d       	subi	r27, 0xDC	; 220
     1c2:	b4 5d       	subi	r27, 0xD4	; 212
     1c4:	ae 5d       	subi	r26, 0xDE	; 222
     1c6:	a6 5d       	subi	r26, 0xD6	; 214
     1c8:	a0 5d       	subi	r26, 0xD0	; 208
     1ca:	98 5d       	subi	r25, 0xD8	; 216
     1cc:	bc 5d       	subi	r27, 0xDC	; 220
     1ce:	a0 5d       	subi	r26, 0xD0	; 208
     1d0:	8f 5d       	subi	r24, 0xDF	; 223
     1d2:	88 5d       	subi	r24, 0xD8	; 216
     1d4:	81 5d       	subi	r24, 0xD1	; 209
     1d6:	7a 5d       	subi	r23, 0xDA	; 218
     1d8:	73 5d       	subi	r23, 0xD3	; 211
     1da:	6c 5d       	subi	r22, 0xDC	; 220
     1dc:	65 5d       	subi	r22, 0xD5	; 213
     1de:	88 5d       	subi	r24, 0xD8	; 216
     1e0:	6c 5d       	subi	r22, 0xDC	; 220
     1e2:	5c 5d       	subi	r21, 0xDC	; 220
     1e4:	55 5d       	subi	r21, 0xD5	; 213
     1e6:	47 5d       	subi	r20, 0xD7	; 215
     1e8:	40 5d       	subi	r20, 0xD0	; 208
     1ea:	32 5d       	subi	r19, 0xD2	; 210
     1ec:	12 5d       	subi	r17, 0xD2	; 210
     1ee:	21 5d       	subi	r18, 0xD1	; 209
     1f0:	eb 5c       	subi	r30, 0xCB	; 203
     1f2:	9e 5c       	subi	r25, 0xCE	; 206
     1f4:	e6 5c       	subi	r30, 0xC6	; 198
     1f6:	d8 5c       	subi	r29, 0xC8	; 200
     1f8:	fd 68       	ori	r31, 0x8D	; 141
     1fa:	ef 68       	ori	r30, 0x8F	; 143
     1fc:	e3 68       	ori	r30, 0x83	; 131
     1fe:	5c 63       	ori	r21, 0x3C	; 60
     200:	8f 63       	ori	r24, 0x3F	; 63
     202:	44 69       	ori	r20, 0x94	; 148
     204:	33 69       	ori	r19, 0x93	; 147
     206:	d5 68       	ori	r29, 0x85	; 133
     208:	c9 68       	ori	r28, 0x89	; 137
     20a:	bb 68       	ori	r27, 0x8B	; 139
     20c:	af 68       	ori	r26, 0x8F	; 143
     20e:	a1 68       	ori	r26, 0x81	; 129
     210:	95 68       	ori	r25, 0x85	; 133
     212:	87 68       	ori	r24, 0x87	; 135
     214:	7f 68       	ori	r23, 0x8F	; 143
     216:	18 68       	ori	r17, 0x88	; 136
     218:	07 68       	ori	r16, 0x87	; 135
     21a:	68 67       	ori	r22, 0x78	; 120
     21c:	4f 67       	ori	r20, 0x7F	; 127
     21e:	f2 67       	ori	r31, 0x72	; 114
     220:	80 67       	ori	r24, 0x70	; 112
     222:	3d 67       	ori	r19, 0x7D	; 125
     224:	2b 67       	ori	r18, 0x7B	; 123
     226:	0a 67       	ori	r16, 0x7A	; 122
     228:	f8 66       	ori	r31, 0x68	; 104
     22a:	e0 66       	ori	r30, 0x60	; 96
     22c:	c9 66       	ori	r28, 0x69	; 105
     22e:	a4 66       	ori	r26, 0x64	; 100
     230:	92 66       	ori	r25, 0x62	; 98
     232:	6e 66       	ori	r22, 0x6E	; 110
     234:	5c 66       	ori	r21, 0x6C	; 108
     236:	49 6a       	ori	r20, 0xA9	; 169
     238:	24 6a       	ori	r18, 0xA4	; 164
     23a:	12 6a       	ori	r17, 0xA2	; 162
     23c:	00 6a       	ori	r16, 0xA0	; 160
     23e:	df 69       	ori	r29, 0x9F	; 159
     240:	c7 69       	ori	r28, 0x97	; 151
     242:	b5 69       	ori	r27, 0x95	; 149
     244:	a9 69       	ori	r26, 0x99	; 153
     246:	84 6a       	ori	r24, 0xA4	; 164
     248:	78 6a       	ori	r23, 0xA8	; 168
     24a:	6c 6a       	ori	r22, 0xAC	; 172
     24c:	5b 6a       	ori	r21, 0xAB	; 171
     24e:	88 69       	ori	r24, 0x98	; 152
     250:	77 69       	ori	r23, 0x97	; 151
     252:	63 69       	ori	r22, 0x93	; 147
     254:	52 69       	ori	r21, 0x92	; 146
     256:	ff 6b       	ori	r31, 0xBF	; 191
     258:	be 6b       	ori	r27, 0xBE	; 190
     25a:	b3 6b       	ori	r27, 0xB3	; 179
     25c:	a0 6b       	ori	r26, 0xB0	; 176
     25e:	e5 6b       	ori	r30, 0xB5	; 181
     260:	d5 6b       	ori	r29, 0xB5	; 181
     262:	f2 6b       	ori	r31, 0xB2	; 178
     264:	9b 69       	ori	r25, 0x9B	; 155
     266:	ec 6a       	ori	r30, 0xAC	; 172
     268:	dd 6a       	ori	r29, 0xAD	; 173
     26a:	d1 6a       	ori	r29, 0xA1	; 161
     26c:	92 6a       	ori	r25, 0xA2	; 162
     26e:	09 6b       	ori	r16, 0xB9	; 185
     270:	f9 6a       	ori	r31, 0xA9	; 169
     272:	8c 6b       	ori	r24, 0xBC	; 188
     274:	51 66       	ori	r21, 0x61	; 97
     276:	11 66       	ori	r17, 0x61	; 97
     278:	ce 65       	ori	r28, 0x5E	; 94
     27a:	c1 65       	ori	r28, 0x51	; 81
     27c:	ae 65       	ori	r26, 0x5E	; 94
     27e:	3a 66       	ori	r19, 0x6A	; 106
     280:	20 66       	ori	r18, 0x60	; 96
     282:	2c 66       	ori	r18, 0x6C	; 108
     284:	ab 64       	ori	r26, 0x4B	; 75
     286:	56 65       	ori	r21, 0x56	; 86
     288:	f0 62       	ori	r31, 0x20	; 32
     28a:	f0 62       	ori	r31, 0x20	; 32
     28c:	18 65       	ori	r17, 0x58	; 88
     28e:	0e 65       	ori	r16, 0x5E	; 94
     290:	b7 64       	ori	r27, 0x47	; 71
     292:	89 65       	ori	r24, 0x59	; 89
     294:	68 65       	ori	r22, 0x58	; 88
     296:	97 65       	ori	r25, 0x57	; 87
     298:	9f 64       	ori	r25, 0x4F	; 79
     29a:	8d 64       	ori	r24, 0x4D	; 77
     29c:	5b 64       	ori	r21, 0x4B	; 75
     29e:	49 64       	ori	r20, 0x49	; 73
     2a0:	3d 64       	ori	r19, 0x4D	; 77
     2a2:	00 64       	ori	r16, 0x40	; 64
     2a4:	e6 63       	ori	r30, 0x36	; 54
     2a6:	c8 63       	ori	r28, 0x38	; 56
     2a8:	ba 63       	ori	r27, 0x3A	; 58
     2aa:	9d 63       	ori	r25, 0x3D	; 61
     2ac:	03 75       	andi	r16, 0x53	; 83
     2ae:	0a 75       	andi	r16, 0x5A	; 90
     2b0:	f6 74       	andi	r31, 0x46	; 70
     2b2:	fd 74       	andi	r31, 0x4D	; 77
     2b4:	ec 74       	andi	r30, 0x4C	; 76
     2b6:	f2 74       	andi	r31, 0x42	; 66
     2b8:	df 74       	andi	r29, 0x4F	; 79
     2ba:	e5 74       	andi	r30, 0x45	; 69
     2bc:	11 75       	andi	r17, 0x51	; 81
     2be:	db 74       	andi	r29, 0x4B	; 75
     2c0:	c3 74       	andi	r28, 0x43	; 67
     2c2:	95 75       	andi	r25, 0x55	; 85
     2c4:	7d 75       	andi	r23, 0x5D	; 93
     2c6:	71 75       	andi	r23, 0x51	; 81
     2c8:	59 75       	andi	r21, 0x59	; 89
     2ca:	3d 75       	andi	r19, 0x5D	; 93
     2cc:	19 75       	andi	r17, 0x59	; 89

000002ce <__c.1790>:
     2ce:	6e 61 6e 00                                         nan.

000002d2 <__c.1788>:
     2d2:	69 6e 66 00                                         inf.

000002d6 <__c.2085>:
     2d6:	63 64 69 6e 6f 70 73 75 78 58 5b 65 66 67 45 46     cdinopsuxX[efgEF
     2e6:	47 00                                               G.

000002e8 <pstr_an>:
     2e8:	61 6e 00                                            an.

000002eb <pstr_nfinity>:
     2eb:	6e 66 69 6e 69 74 79 00                             nfinity.

000002f3 <pwr_m10>:
     2f3:	cd cc cc 3d 0a d7 23 3c 17 b7 d1 38 77 cc 2b 32     ...=..#<...8w.+2
     303:	95 95 e6 24 1f b1 4f 0a                             ...$..O.

0000030b <pwr_p10>:
     30b:	00 00 20 41 00 00 c8 42 00 40 1c 46 20 bc be 4c     .. A...B.@.F ..L
     31b:	ca 1b 0e 5a ae c5 9d 74                             ...Z...t

00000323 <DaysMonth>:
     323:	00 1f 1c 1f 1e 1f 1e 1f 1f 1e 1f 1e 1f              .............

00000330 <Modbus_Map>:
     330:	bc 07 20 00 45 0a 20 00 60 0b 04 00 44 08 50 00     .. .E. .`...D.P.

00000340 <BR_Tbl>:
     340:	42 03 ff a0 01 fb cf 00 7d 67 00 3f 44 00 2a 33     B.......}g.?D.*3
     350:	00 1f 22 00 1b 19 00 1b 10 00 1b                    .."........

0000035b <GSM_SIMCOM_SIM900R>:
     35b:	53 49 4d 43 4f 4d 5f 53 49 4d 39 30 30 52 00        SIMCOM_SIM900R.

0000036a <GSM_SIMCOM_SIM800>:
     36a:	53 49 4d 43 4f 4d 5f 53 49 4d 38 30 30 00           SIMCOM_SIM800.

00000378 <GSM_SIMCOM_SIM800C>:
     378:	53 49 4d 43 4f 4d 5f 53 49 4d 38 30 30 43 00        SIMCOM_SIM800C.

00000387 <URC_RDY>:
     387:	52 44 59 00                                         RDY.

0000038b <URC_CFUN>:
     38b:	2b 43 46 55 4e 3a 20 31 00                          +CFUN: 1.

00000394 <URC_CPIN_READY>:
     394:	2b 43 50 49 4e 3a 20 52 45 41 44 59 00              +CPIN: READY.

000003a1 <URC_CALL_READY>:
     3a1:	43 61 6c 6c 20 52 65 61 64 79 00                    Call Ready.

000003ac <URC_SMS_READY>:
     3ac:	53 4d 53 20 52 65 61 64 79 00                       SMS Ready.

000003b6 <URC_REMOTE_IP>:
     3b6:	52 45 4d 4f 54 45 20 49 50 00                       REMOTE IP.

000003c0 <URC_CONNECT>:
     3c0:	43 4f 4e 4e 45 43 54 00                             CONNECT.

000003c8 <URC_RECEIVE>:
     3c8:	2b 52 45 43 45 49 56 45 2c 00                       +RECEIVE,.

000003d2 <URC_CLOSED>:
     3d2:	2c 20 43 4c 4f 53 45 44 00                          , CLOSED.

000003db <URC_PDPDEACT>:
     3db:	2b 50 44 50 20 44 45 41 43 54 00                    +PDP DEACT.

000003e6 <URC_NO_CARRIER>:
     3e6:	4e 4f 20 43 41 52 52 49 45 52 00                    NO CARRIER.

000003f1 <RESP_OK>:
     3f1:	4f 4b 00                                            OK.

000003f4 <RESP_CONNECT>:
     3f4:	43 4f 4e 4e 45 43 54 00                             CONNECT.

000003fc <RESP_CONNECT_OK>:
     3fc:	78 2c 20 43 4f 4e 4e 45 43 54 20 4f 4b 00           x, CONNECT OK.

0000040a <RESP_SERVER_OK>:
     40a:	53 45 52 56 45 52 20 4f 4b 00                       SERVER OK.

00000414 <RESP_SERVER_CLOSE>:
     414:	53 45 52 56 45 52 20 43 4c 4f 53 45 00              SERVER CLOSE.

00000421 <RESP_Invitation>:
     421:	3e 00                                               >.

00000423 <RESP_SEND_OK>:
     423:	78 2c 20 53 45 4e 44 20 4f 4b 00                    x, SEND OK.

0000042e <RESP_CLOSE_OK>:
     42e:	43 4c 4f 53 45 20 4f 4b 00                          CLOSE OK.

00000437 <RESP_CLOSE_OK_FAST>:
     437:	78 2c 20 43 4c 4f 53 45 20 4f 4b 00                 x, CLOSE OK.

00000443 <RESP_CSQ>:
     443:	2b 43 53 51 3a 00                                   +CSQ:.

00000449 <RESP_SHUT_OK>:
     449:	53 48 55 54 20 4f 4b 00                             SHUT OK.

00000451 <RESP_CREC_0>:
     451:	2b 43 52 45 43 3a 20 30 00                          +CREC: 0.

0000045a <ESC_SEQ>:
     45a:	2b 2b 2b 00                                         +++.

0000045e <IDENTIFICATION>:
     45e:	49 44 45 4e 54 49 46 49 43 41 54 49 4f 4e 00        IDENTIFICATION.

0000046d <AT_AT>:
     46d:	41 54 00                                            AT.

00000470 <AT_IPR9600>:
     470:	41 54 2b 49 50 52 3d 39 36 30 30 00                 AT+IPR=9600.

0000047c <AT_W>:
     47c:	41 54 26 57 00                                      AT&W.

00000481 <AT_E0>:
     481:	41 54 45 30 00                                      ATE0.

00000486 <AT_CLCC1>:
     486:	41 54 2b 43 4c 43 43 3d 31 00                       AT+CLCC=1.

00000490 <AT_DDET101>:
     490:	41 54 2b 44 44 45 54 3d 31 2c 30 2c 31 00           AT+DDET=1,0,1.

0000049e <AT_CGMM>:
     49e:	41 54 2b 43 47 4d 4d 00                             AT+CGMM.

000004a6 <AT_CCID>:
     4a6:	41 54 2b 43 43 49 44 00                             AT+CCID.

000004ae <AT_IFC>:
     4ae:	41 54 2b 49 46 43 3d 32 2c 32 00                    AT+IFC=2,2.

000004b9 <ATD101>:
     4b9:	41 54 44 2a 31 30 31 23 00                          ATD*101#.

000004c2 <ATD_PLUS>:
     4c2:	41 54 44 2b 00                                      ATD+.

000004c7 <AT_CUSD101>:
     4c7:	41 54 2b 43 55 53 44 3d 31 2c 22 00                 AT+CUSD=1,".

000004d3 <AT_CMGF>:
     4d3:	41 54 2b 43 4d 47 46 3d 31 00                       AT+CMGF=1.

000004dd <AT_CSMP>:
     4dd:	41 54 2b 43 53 4d 50 3d 31 37 2c 31 36 37 2c 30     AT+CSMP=17,167,0
     4ed:	2c 30 00                                            ,0.

000004f0 <AT_CMGS>:
     4f0:	41 54 2b 43 4d 47 53 3d 22 2b 00                    AT+CMGS="+.

000004fb <AT_CIPMODE_0>:
     4fb:	41 54 2b 43 49 50 4d 4f 44 45 3d 30 00              AT+CIPMODE=0.

00000508 <AT_CIPMODE_1>:
     508:	41 54 2b 43 49 50 4d 4f 44 45 3d 31 00              AT+CIPMODE=1.

00000515 <AT_CIPMUX_0>:
     515:	41 54 2b 43 49 50 4d 55 58 3d 30 00                 AT+CIPMUX=0.

00000521 <AT_CIPMUX_1>:
     521:	41 54 2b 43 49 50 4d 55 58 3d 31 00                 AT+CIPMUX=1.

0000052d <AT_CGATT>:
     52d:	41 54 2b 43 47 41 54 54 3d 31 00                    AT+CGATT=1.

00000538 <AT_CIPCSGP>:
     538:	41 54 2b 43 49 50 43 53 47 50 3d 31 2c 22 00        AT+CIPCSGP=1,".

00000547 <AT_CSTT>:
     547:	41 54 2b 43 53 54 54 00                             AT+CSTT.

0000054f <AT_CIICR>:
     54f:	41 54 2b 43 49 49 43 52 00                          AT+CIICR.

00000558 <AT_CIFSR>:
     558:	41 54 2b 43 49 46 53 52 00                          AT+CIFSR.

00000561 <AT_CIPTKA>:
     561:	41 54 2b 43 49 50 54 4b 41 3d 31 2c 33 30 2c 33     AT+CIPTKA=1,30,3
     571:	30 2c 31 00                                         0,1.

00000575 <AT_CIPSTART>:
     575:	41 54 2b 43 49 50 53 54 41 52 54 3d 22 55 44 50     AT+CIPSTART="UDP
     585:	22 2c 00                                            ",.

00000588 <AT_CIPSTART_TCP_CLIENT>:
     588:	41 54 2b 43 49 50 53 54 41 52 54 3d 22 54 43 50     AT+CIPSTART="TCP
     598:	22 2c 00                                            ",.

0000059b <AT_CIPSERVER>:
     59b:	41 54 2b 43 49 50 53 45 52 56 45 52 3d 31 2c 00     AT+CIPSERVER=1,.

000005ab <AT_SERVERCLOSE>:
     5ab:	41 54 2b 43 49 50 53 45 52 56 45 52 3d 30 00        AT+CIPSERVER=0.

000005ba <AT_CIPSEND>:
     5ba:	41 54 2b 43 49 50 53 45 4e 44 3d 00                 AT+CIPSEND=.

000005c6 <AT_CIPCLOSE_1>:
     5c6:	41 54 2b 43 49 50 43 4c 4f 53 45 3d 78 2c 31 00     AT+CIPCLOSE=x,1.

000005d6 <AT_CIPCLOSE>:
     5d6:	41 54 2b 43 49 50 43 4c 4f 53 45 3d 31 00           AT+CIPCLOSE=1.

000005e4 <AT_CIPSHUT>:
     5e4:	41 54 2b 43 49 50 53 48 55 54 00                    AT+CIPSHUT.

000005ef <AT_CGATT_0>:
     5ef:	41 54 2b 43 47 41 54 54 3d 30 00                    AT+CGATT=0.

000005fa <AT_CSQ>:
     5fa:	41 54 2b 43 53 51 00                                AT+CSQ.

00000601 <ATO>:
     601:	41 54 4f 00                                         ATO.

00000605 <Symbols_P>:
     605:	30 31 32 33 34 35 36 37 38 39 61 62 63 64 65 66     0123456789abcdef
     615:	67 68 69 6a 6b 6c 6d 6e 6f 70 71 72 73 74 75 76     ghijklmnopqrstuv
     625:	77 78 79 7a 41 42 43 44 45 46 47 48 49 4a 4b 4c     wxyzABCDEFGHIJKL
     635:	4d 4e 4f 50 51 52 53 54 55 56 57 58 59 5a e0 e1     MNOPQRSTUVWXYZ..
     645:	e2 e3 e4 e5 b8 ba e6 e7 e8 b3 bf e9 ea eb ec ed     ................
     655:	ee ef f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 fa fb fc fd     ................
     665:	fe ff c0 c1 c2 c3 c4 c5 a8 aa c6 c7 c8 b2 af c9     ................
     675:	ca cb cc cd ce cf d0 d1 d2 d3 d4 d5 d6 d7 d8 d9     ................
     685:	da db dc dd de df 20 2b 2d 3d 3c 3e 24 25 26 2e     ...... +-=<>$%&.
     695:	2c 3f 21 27 40 3a 28 29 22 7c 2a 23 2f 00           ,?!'@:()"|*#/.

000006a3 <OnlyDigits_P>:
     6a3:	30 31 32 33 34 35 36 37 38 39 00                    0123456789.

000006ae <Digits_P>:
     6ae:	30 31 32 33 34 35 36 37 38 39 65 2b 2d 2e 00        0123456789e+-..

000006bd <ThermFami>:
     6bd:	00 00 00 00 00 00                                   ......

000006c3 <TermisLim>:
     6c3:	00 00 00 00 0c fe 08 07 0c fe 08 07 0c fe 70 17     ..............p.
     6d3:	0c fe 70 17 0c fe 70 17 0c fe 70 17 0c fe 08 07     ..p...p...p.....

000006e3 <TermocLim>:
     6e3:	00 00 00 00 30 f8 e0 2e 70 17 50 46 30 f8 4c 1d     ....0...p.PF0.L.
     6f3:	30 f8 70 17                                         0.p.

000006f7 <Fail_Str>:
     6f7:	d1 e1 ee e9 20 00                                   .... .

000006fd <Norm_Str>:
     6fd:	cd ee f0 ec e0 00                                   ......

00000703 <DI_NO_Str>:
     703:	ed e5 f2 20 00                                      ... .

00000708 <DI_OK_Str>:
     708:	ed ee f0 ec 00                                      .....

0000070d <DI_Sta_Tbl>:
     70d:	03 07 08 07                                         ....

00000711 <DI_Op_Str>:
     711:	f0 e0 e7 ec 00                                      .....

00000716 <DI_Cl_Str>:
     716:	e7 e0 ec ea 00                                      .....

0000071b <DI_Tbl>:
     71b:	11 07 16 07                                         ....

0000071f <DI_Inv_Cl_Str>:
     71f:	ed 2e e7 2e 00                                      .....

00000724 <DI_Inv_Op_Str>:
     724:	ed 2e f0 2e 00                                      .....

00000729 <DI_Inv_Tbl>:
     729:	1f 07 24 07                                         ..$.

0000072d <DO_Op_Str>:
     72d:	e2 fb ea eb 00                                      .....

00000732 <DO_Cl_Str>:
     732:	e2 ea eb 20 00                                      ... .

00000737 <DO_Tbl>:
     737:	2d 07 32 07                                         -.2.

0000073b <F_ADC_3>:
     73b:	07 b4 07 00 00 00                                   ......

00000741 <F_ADC_4>:
     741:	07 2a 09 00 00 00                                   .*....

00000747 <F_ADC_5>:
     747:	07 f8 06 00 00 00                                   ......

0000074d <List_ADC_Err>:
     74d:	20 2d 2d 2d 20 41 44 43 20 65 72 72 6f 72 73 20      --- ADC errors 
     75d:	2d 2d 2d 20 00 00 00 00 00 00 00 20 52 65 61 64     --- ....... Read
     76d:	20 66 61 69 6c 3a 20 20 20 20 7b 7b 7b 7b 7b 00      fail:    {{{{{.
     77d:	3b 07 00 00 00 00 20 43 61 6c 69 62 72 20 66 61     ;..... Calibr fa
     78d:	69 6c 3a 20 20 7b 7b 7b 7b 7b 00 41 07 00 00 00     il:  {{{{{.A....
     79d:	00 20 43 61 6c 69 62 72 20 62 72 65 61 6b 3a 20     . Calibr break: 
     7ad:	7b 7b 7b 7b 7b 00 47 07 00 00 00 00                 {{{{{.G.....

000007b9 <Menu_ADC_Err>:
     7b9:	4d 07 04 03 00 00 00 00 00 00 00 00 00 00 00 00     M...............
     7c9:	00 00 00 00                                         ....

000007cd <F_ADC_1>:
     7cd:	1d 69 0b 47 24 00                                   .i.G$.

000007d3 <F_ADC_2>:
     7d3:	00 b3 06 00 00 00 00 11 09 00 00 00                 ............

000007df <List_ADC>:
     7df:	20 d0 e5 e6 e8 ec 3a 20 7b 7b 7b 7b 7b 7b 7b 7b      .....: {{{{{{{{
     7ef:	7b 7b 7b 7b 00 cd 07 00 00 00 00 20 c2 f0 e5 ec     {{{{....... ....
     7ff:	ff 3a 7b 7b 30 ec f1 20 ca e0 ed e0 eb 3a 7b 00     .:{{0.. .....:{.
     80f:	d3 07 00 00 00 00 20 2d 20 ca e0 ed e0 eb fb 20     ...... - ...... 
     81f:	2d 20 20 20 20 20 20 20 20 20 00 00 00 00 00 68     -         .....h
     82f:	23 20 2d 20 ca e0 eb e8 e1 f0 ee e2 ea e0 20 2d     # - .......... -
     83f:	20 20 20 20 20 00 00 00 00 00 0c 24 20 2d 20 ce          ......$ - .
     84f:	f8 e8 e1 ea e8 20 2d 20 20 20 20 20 20 20 20 20     ..... -         
     85f:	00 00 00 00 00 b9 07                                .......

00000866 <MenuADC>:
     866:	df 07 05 02 00 00 00 00 00 00 00 00 00 00 00 00     ................
     876:	00 00 00 00                                         ....

0000087a <MsgErr21>:
     87a:	20 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f      _______________
     88a:	5f 5f 5f 20 00 00 00 20 49 6e 74 65 72 6e 61 6c     ___ ... Internal
     89a:	20 65 72 72 6f 72 20 32 31 3a 20 00 00 00 20 20      error 21: ...  
     8aa:	20 20 20 20 41 44 43 20 6f 66 66 20 20 20 20 20         ADC off     
     8ba:	20 20 00 00 00 20 20 20 20 20 20 20 20 20 20 20       ...           
     8ca:	20 20 20 20 20 20 20 20 20 00 00 00 00 00 00 00              .......
	...

000008dc <Therm_Off_Str>:
     8dc:	20 20 20 78 20 20 20 00                                x   .

000008e4 <ADC_Off_Str>:
     8e4:	2d 2d 2d 2d 2d 2d 2d 00                             -------.

000008ec <ThermTbl>:
     8ec:	dc 08 e4 08                                         ....

000008f0 <ThermOff_Str>:
     8f0:	ce f2 ea eb 2e 00                                   ......

000008f6 <TSM100_Str>:
     8f6:	d2 d1 cc 31 30 30 00                                ...100.

000008fd <TSM50_Str>:
     8fd:	d2 d1 cc 35 30 00                                   ...50.

00000903 <TSP100_Str>:
     903:	d2 d1 cf 31 30 30 00                                ...100.

0000090a <TSP50_Str>:
     90a:	d2 d1 cf 35 30 00                                   ...50.

00000910 <Pt100_Str>:
     910:	50 74 31 30 30 00                                   Pt100.

00000916 <Gr21_Str>:
     916:	c3 f0 32 31 00                                      ..21.

0000091b <Gr23_Str>:
     91b:	c3 f0 32 33 00                                      ..23.

00000920 <RTD_Name_List>:
     920:	f0 08 f6 08 fd 08 03 09 0a 09 10 09 16 09 1b 09     ................

00000930 <TC_K_Str>:
     930:	54 58 41 00                                         TXA.

00000934 <TC_B_Str>:
     934:	54 cf d0 00                                         T...

00000938 <TC_J_Str>:
     938:	54 c6 ca 00                                         T...

0000093c <TC_L_Str>:
     93c:	54 58 ca 00                                         TX..

00000940 <TC_Name_List>:
     940:	f0 08 30 09 34 09 38 09 3c 09                       ..0.4.8.<.

0000094a <NoPariStr>:
     94a:	ed e5 f2 00                                         ....

0000094e <EvenPariStr>:
     94e:	f7 e5 f2 ed fb e9 00                                .......

00000955 <OddPariStr>:
     955:	ed e5 f7 e5 f2 ed fb e9 00                          .........

0000095e <MBPariTbl>:
     95e:	4a 09 4e 09 55 09                                   J.N.U.

00000964 <BR_Str1200>:
     964:	31 32 30 30 00                                      1200.

00000969 <BR_Str2400>:
     969:	32 34 30 30 00                                      2400.

0000096e <BR_Str4800>:
     96e:	34 38 30 30 00                                      4800.

00000973 <BR_Str9600>:
     973:	39 36 30 30 00                                      9600.

00000978 <BR_Str14400>:
     978:	31 34 34 30 30 00                                   14400.

0000097e <BR_Str19200>:
     97e:	31 39 32 30 30 00                                   19200.

00000984 <BR_Str28800>:
     984:	32 38 38 30 30 00                                   28800.

0000098a <BR_Str38400>:
     98a:	33 38 34 30 30 00                                   38400.

00000990 <BR_Str57600>:
     990:	35 37 36 30 30 00                                   57600.

00000996 <BaudTbl>:
     996:	64 09 69 09 6e 09 73 09 78 09 7e 09 84 09 8a 09     d.i.n.s.x.~.....
     9a6:	90 09                                               ..

000009a8 <F_MB0_Pari>:
     9a8:	1e 04 00 00 00 00 00 02 00 00 00 d6 72 5e 09 00     ............r^..

000009b8 <F_MB0_Stopbits>:
     9b8:	01 05 00 01 00 00 00 02 00 00 00 d6 72 00 00 00     ............r...

000009c8 <F_MB0_Baud>:
     9c8:	1e 06 00 00 00 00 00 08 00 00 00 5f 72 96 09 00     ..........._r...

000009d8 <MB0_CPT_04>:
     9d8:	0b 35 09 00 00 00 0b 3d 09 00 00 00                 .5.....=....

000009e4 <MB0_CPT_15>:
     9e4:	0b 37 09 00 00 00 0b 3f 09 00 00 00                 .7.....?....

000009f0 <MB0_CPT_26>:
     9f0:	0b 39 09 00 00 00 0b 41 09 00 00 00                 .9.....A....

000009fc <MB0_CPT_37>:
     9fc:	0b 3b 09 00 00 00 0b 43 09 00 00 00                 .;.....C....

00000a08 <List_MB0_CPT>:
     a08:	43 50 31 3a 7b 7b 7b 7b 7b 20 20 43 50 35 3a 7b     CP1:{{{{{  CP5:{
     a18:	7b 7b 7b 7b 00 d8 09 00 00 00 00 43 50 32 3a 7b     {{{{.......CP2:{
     a28:	7b 7b 7b 7b 20 20 43 50 36 3a 7b 7b 7b 7b 7b 00     {{{{  CP6:{{{{{.
     a38:	e4 09 00 00 00 00 43 50 33 3a 7b 7b 7b 7b 7b 20     ......CP3:{{{{{ 
     a48:	20 43 50 37 3a 7b 7b 7b 7b 7b 00 f0 09 00 00 00      CP7:{{{{{......
     a58:	00 43 50 34 3a 7b 7b 7b 7b 7b 20 20 43 50 38 3a     .CP4:{{{{{  CP8:
     a68:	7b 7b 7b 7b 7b 00 fc 09 00 00 00 00                 {{{{{.......

00000a74 <M_MB0_CPT>:
     a74:	08 0a 04 03 00 00 00 00 00 00 00 00 04 41 00 00     .............A..
     a84:	00 00 00 00                                         ....

00000a88 <L_MB0>:
     a88:	20 2d 2d 2d 2d 20 4d 6f 64 62 75 73 20 30 20 2d      ---- Modbus 0 -
     a98:	2d 2d 2d 20 00 00 00 00 00 00 00 20 d1 f7 e5 f2     --- ....... ....
     aa8:	f7 e8 ea e8 20 28 f1 e1 f0 ee f1 3a 2d 3e 29 00     .... (.....:->).
     ab8:	00 00 00 00 74 0a 20 cf e0 f0 e8 f2 e5 f2 3a 20     ....t. .......: 
     ac8:	7d 7d 7d 7d 7d 7d 7d 7d 20 20 00 00 00 a8 09 00     }}}}}}}}  ......
     ad8:	00 20 d1 f2 ee ef 2d e1 e8 f2 fb 3a 20 7d 20 20     . ....-....: }  
     ae8:	20 20 20 20 20 00 00 00 b8 09 00 00 20 42 41 55          ....... BAU
     af8:	44 3a 20 7d 7d 7d 7d 7d 62 70 73 20 20 20 20 20     D: }}}}}bps     
     b08:	00 00 00 c8 09 00 00                                .......

00000b0f <MenuModbus0>:
     b0f:	88 0a 05 01 00 00 00 00 00 00 00 00 00 00 00 00     ................
     b1f:	00 00 00 00                                         ....

00000b23 <List_Modbus>:
     b23:	20 4d 6f 64 62 75 73 20 30 20 20 20 20 20 20 20      Modbus 0       
     b33:	20 20 20 20 00 00 00 00 00 0f 0b 20 20 20 20 58         .......    X
     b43:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 00                    .
     b53:	00 00 00 00 00 00 20 20 20 20 58 20 20 20 20 20     ......    X     
     b63:	20 20 20 20 20 20 20 20 20 20 00 00 00 00 00 00               ......
     b73:	00 20 20 20 20 58 20 20 20 20 20 20 20 20 20 20     .    X          
     b83:	20 20 20 20 20 00 00 00 00 00 00 00                      .......

00000b8f <MenuModbus>:
     b8f:	23 0b 04 00 00 00 00 00 00 00 00 00 00 00 00 00     #...............
     b9f:	00 00 00 00                                         ....

00000ba3 <N_Str>:
     ba3:	cd e5 f2 00                                         ....

00000ba7 <Y_Str>:
     ba7:	c4 e0 00                                            ...

00000baa <YN_Tbl>:
     baa:	a3 0b a7 0b                                         ....

00000bae <F_SummerTime>:
     bae:	1e 03 00 00 00 00 00 01 00 00 00 00 00 aa 0b 00     ................

00000bbe <F_WDay>:
     bbe:	00 57 06 00 00 00                                   .W....

00000bc4 <F_DateTime>:
     bc4:	04 5e 0b 01 00 00 00 1f 00 00 00 d6 24 00 00 00     .^..........$...
     bd4:	04 cb 07 01 00 00 00 0c 00 00 00 e0 24 00 00 00     ............$...
     be4:	04 de 05 00 00 00 00 63 00 00 00 ea 24 00 00 00     .......c....$...
     bf4:	04 c1 05 00 00 00 00 17 00 00 00 cc 24 00 00 00     ............$...
     c04:	04 51 06 00 00 00 00 3b 00 00 00 c2 24 00 00 00     .Q.....;....$...
     c14:	04 f7 06 00 00 00 00 3b 00 00 00 b8 24 00 00 00     .......;....$...

00000c24 <GSM_CNTL_AUTO_Str>:
     c24:	61 75 74 6f 20 20 00                                auto  .

00000c2b <GSM_CNTL_MANUAL_Str>:
     c2b:	6d 61 6e 75 61 6c 00                                manual.

00000c32 <GSM_CNTL_CONFIG_Str>:
     c32:	63 6f 6e 66 69 67 00                                config.

00000c39 <GSM_ControlList>:
     c39:	24 0c 2b 0c 32 0c                                   $.+.2.

00000c3f <GSM_Not_Recognize_Str>:
     c3f:	6e 6f 74 20 72 65 63 6f 67 00                       not recog.

00000c49 <GSM_SIMCOM_SIM900R_Str>:
     c49:	53 49 4d 39 30 30 52 20 20 00                       SIM900R  .

00000c53 <GSM_SIMCOM_SIM800_Str>:
     c53:	53 49 4d 38 30 30 20 20 20 00                       SIM800   .

00000c5d <GSM_ModemList>:
     c5d:	3f 0c 49 0c 53 0c                                   ?.I.S.

00000c63 <MenuGSM_Modem_State>:
     c63:	1d 34 07 5d 0c 00 00 f6 06 00 00 00                 .4.]........

00000c6f <MenuGSM_State>:
     c6f:	00 f6 06 00 00 00                                   ......

00000c75 <MenuGSM_GSM_Cont>:
     c75:	1d d0 07 00 00 00 00 02 00 00 00 13 41 39 0c 00     ............A9..

00000c85 <MenuGSM_GSM_MyIP>:
     c85:	00 30 09 00 00 00 00 31 09 00 00 00 00 32 09 00     .0.....1.....2..
     c95:	00 00 00 33 09 00 00 00                             ...3....

00000c9d <MenuGSM_ClientIP>:
     c9d:	00 49 0b 00 00 00 00 4a 0b 00 00 00 00 4b 0b 00     .I.....J.....K..
     cad:	00 00 00 4c 0b 00 00 00                             ...L....

00000cb5 <MenuGSM_ActiveCon>:
     cb5:	00 d3 02 00 00 00                                   ......

00000cbb <MenuGSM_FIFOMax>:
     cbb:	00 18 09 00 00 00                                   ......

00000cc1 <MenuGSM_APN1>:
     cc1:	22 09 00 00 00 00 00 06 00 00 00 00 00 00 00 00     "...............

00000cd1 <MenuGSM_APN2>:
     cd1:	22 1d 00 00 00 00 00 06 00 00 00 00 00 00 00 00     "...............

00000ce1 <MenuGSM_APN_USER_NAME>:
     ce1:	22 59 00 00 00 00 00 06 00 00 00 00 00 00 00 00     "Y..............

00000cf1 <MenuGSM_APN_PASSWORD>:
     cf1:	22 6d 00 00 00 00 00 06 00 00 00 00 00 00 00 00     "m..............

00000d01 <MenuGSM_IPUDP1>:
     d01:	01 81 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     d11:	01 82 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     d21:	01 83 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     d31:	01 84 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00000d41 <MenuGSM_IPUDP2>:
     d41:	01 85 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     d51:	01 86 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     d61:	01 87 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     d71:	01 88 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00000d81 <MenuGSM_IPUDP3>:
     d81:	01 89 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     d91:	01 8a 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     da1:	01 8b 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     db1:	01 8c 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00000dc1 <MenuGSM_IPUDP4>:
     dc1:	01 8d 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     dd1:	01 8e 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     de1:	01 8f 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     df1:	01 90 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00000e01 <MenuGSM_PortUDP1>:
     e01:	08 a1 00 00 00 00 00 ff ff 00 00 00 00 00 00 00     ................

00000e11 <MenuGSM_PortUDP2>:
     e11:	08 a3 00 00 00 00 00 ff ff 00 00 00 00 00 00 00     ................

00000e21 <MenuGSM_PortUDP3>:
     e21:	08 a5 00 00 00 00 00 ff ff 00 00 00 00 00 00 00     ................

00000e31 <MenuGSM_PortUDP4>:
     e31:	08 a7 00 00 00 00 00 ff ff 00 00 00 00 00 00 00     ................

00000e41 <MenuGSM_IPTCP1>:
     e41:	01 b3 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     e51:	01 b4 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     e61:	01 b5 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     e71:	01 b6 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00000e81 <MenuGSM_IPTCP2>:
     e81:	01 b7 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     e91:	01 b8 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     ea1:	01 b9 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     eb1:	01 ba 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00000ec1 <MenuGSM_IPTCP3>:
     ec1:	01 bb 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     ed1:	01 bc 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     ee1:	01 bd 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     ef1:	01 be 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00000f01 <MenuGSM_IPTCP4>:
     f01:	01 bf 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     f11:	01 c0 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     f21:	01 c1 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     f31:	01 c2 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00000f41 <MenuGSM_TCPPort>:
     f41:	08 b1 00 00 00 00 00 ff ff 00 00 00 00 00 00 00     ................

00000f51 <MenuGSM_TCPTimeout>:
     f51:	08 c3 00 64 00 00 00 ff ff 00 00 00 00 00 00 02     ...d............

00000f61 <MenuGSM_SMS>:
     f61:	01 13 01 00 00 00 00 01 00 00 00 00 00 00 00 00     ................

00000f71 <MenuGSM_VegaSN>:
     f71:	08 07 00 00 00 00 00 ff ff 00 00 00 00 00 00 00     ................

00000f81 <ListGSM>:
     f81:	20 cc ee e4 e5 ec 20 7b 7b 7b 7b 7b 7b 7b 7b 7b      ..... {{{{{{{{{
     f91:	20 7b 7b 7b 00 63 0c 00 00 00 00 20 43 6f 6e 74      {{{.c..... Cont
     fa1:	72 6f 6c 20 6d 6f 64 65 3a 7d 7d 7d 7d 7d 7d 00     rol mode:}}}}}}.
     fb1:	00 00 75 0c 00 00 20 4d 79 49 50 7b 7b 7b 2e 7b     ..u... MyIP{{{.{
     fc1:	7b 7b 2e 7b 7b 7b 2e 7b 7b 7b 00 85 0c 00 00 00     {{.{{{.{{{......
     fd1:	00 20 43 6c 49 50 7b 7b 7b 2e 7b 7b 7b 2e 7b 7b     . ClIP{{{.{{{.{{
     fe1:	7b 2e 7b 7b 7b 00 9d 0c 00 00 00 00 20 41 63 74     {.{{{....... Act
     ff1:	69 76 65 20 63 6f 6e 65 63 74 69 6f 6e 7b 7b 7b     ive conection{{{
    1001:	00 b5 0c 00 00 00 00 20 46 49 46 4f 3a 6d 61 78     ....... FIFO:max
    1011:	20 7b 7b 2f 37 30 62 79 74 65 20 00 bb 0c 00 00      {{/70byte .....
    1021:	00 00 20 2d 2d 2d 2d 2d 2d 2d 41 50 4e 2d 2d 2d     .. -------APN---
    1031:	2d 2d 2d 2d 2d 2d 00 00 00 00 00 00 00 20 7d 7d     ------....... }}
    1041:	7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d     }}}}}}}}}}}}}}}}
    1051:	7d 00 00 00 c1 0c 00 00 20 7d 7d 7d 7d 7d 7d 7d     }....... }}}}}}}
    1061:	7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 00 00 00 d1     }}}}}}}}}}}}....
    1071:	0c 00 00 20 2d 2d 2d 41 50 4e 2d 55 53 45 52 20     ... ---APN-USER 
    1081:	4e 41 4d 45 2d 2d 2d 00 00 00 00 00 00 00 20 7d     NAME---....... }
    1091:	7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d     }}}}}}}}}}}}}}}}
    10a1:	7d 7d 00 00 00 e1 0c 00 00 20 2d 2d 2d 41 50 4e     }}....... ---APN
    10b1:	2d 50 41 53 53 57 4f 52 44 2d 2d 2d 2d 00 00 00     -PASSWORD----...
    10c1:	00 00 00 00 20 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d     .... }}}}}}}}}}}
    10d1:	7d 7d 7d 7d 7d 7d 7d 7d 00 00 00 f1 0c 00 00 20     }}}}}}}}....... 
    10e1:	2d 2d 53 65 6e 64 20 55 44 50 20 74 6f 20 49 50     --Send UDP to IP
    10f1:	2d 2d 2d 00 00 00 00 00 00 00 20 49 50 31 3a 7d     ---....... IP1:}
    1101:	7d 7d 2e 7d 7d 7d 2e 7d 7d 7d 2e 7d 7d 7d 00 00     }}.}}}.}}}.}}}..
    1111:	00 01 0d 00 00 20 49 50 32 3a 7d 7d 7d 2e 7d 7d     ..... IP2:}}}.}}
    1121:	7d 2e 7d 7d 7d 2e 7d 7d 7d 00 00 00 41 0d 00 00     }.}}}.}}}...A...
    1131:	20 49 50 33 3a 7d 7d 7d 2e 7d 7d 7d 2e 7d 7d 7d      IP3:}}}.}}}.}}}
    1141:	2e 7d 7d 7d 00 00 00 81 0d 00 00 20 49 50 34 3a     .}}}....... IP4:
    1151:	7d 7d 7d 2e 7d 7d 7d 2e 7d 7d 7d 2e 7d 7d 7d 00     }}}.}}}.}}}.}}}.
    1161:	00 00 c1 0d 00 00 20 2d 2d 2d 2d 20 55 44 50 20     ...... ---- UDP 
    1171:	50 6f 72 74 20 2d 2d 2d 2d 2d 00 00 00 00 00 00     Port -----......
    1181:	00 20 49 50 31 20 50 6f 72 74 3a 7d 7d 7d 7d 7d     . IP1 Port:}}}}}
    1191:	20 20 20 20 20 00 00 00 01 0e 00 00 20 49 50 32          ....... IP2
    11a1:	20 50 6f 72 74 3a 7d 7d 7d 7d 7d 20 20 20 20 20      Port:}}}}}     
    11b1:	00 00 00 11 0e 00 00 20 49 50 33 20 50 6f 72 74     ....... IP3 Port
    11c1:	3a 7d 7d 7d 7d 7d 20 20 20 20 20 00 00 00 21 0e     :}}}}}     ...!.
    11d1:	00 00 20 49 50 34 20 50 6f 72 74 3a 7d 7d 7d 7d     .. IP4 Port:}}}}
    11e1:	7d 20 20 20 20 20 00 00 00 31 0e 00 00 20 2d 20     }     ...1... - 
    11f1:	54 43 50 20 49 50 20 46 69 72 65 77 61 6c 6c 2d     TCP IP Firewall-
    1201:	2d 00 00 00 00 00 00 00 20 49 50 31 3a 7d 7d 7d     -....... IP1:}}}
    1211:	2e 7d 7d 7d 2e 7d 7d 7d 2e 7d 7d 7d 00 00 00 41     .}}}.}}}.}}}...A
    1221:	0e 00 00 20 49 50 32 3a 7d 7d 7d 2e 7d 7d 7d 2e     ... IP2:}}}.}}}.
    1231:	7d 7d 7d 2e 7d 7d 7d 00 00 00 81 0e 00 00 20 49     }}}.}}}....... I
    1241:	50 33 3a 7d 7d 7d 2e 7d 7d 7d 2e 7d 7d 7d 2e 7d     P3:}}}.}}}.}}}.}
    1251:	7d 7d 00 00 00 c1 0e 00 00 20 49 50 34 3a 7d 7d     }}....... IP4:}}
    1261:	7d 2e 7d 7d 7d 2e 7d 7d 7d 2e 7d 7d 7d 00 00 00     }.}}}.}}}.}}}...
    1271:	01 0f 00 00 20 54 43 50 53 65 72 76 65 72 50 6f     .... TCPServerPo
    1281:	72 74 3a 7d 7d 7d 7d 7d 00 00 00 41 0f 00 00 20     rt:}}}}}...A... 
    1291:	54 69 6d 65 6f 75 74 20 54 43 50 3a 7d 7d 7d 7d     Timeout TCP:}}}}
    12a1:	7d 7d 63 00 00 00 51 0f 00 00 20 2d 2d 2d 2d 2d     }}c...Q... -----
    12b1:	2d 2d 20 53 4d 53 20 2d 2d 2d 2d 2d 2d 2d 00 00     -- SMS -------..
    12c1:	00 00 00 00 00 20 d0 e0 f1 f1 fb eb ea e0 20 53     ..... ........ S
    12d1:	4d 53 3a 20 20 20 7d 7d 7d 00 00 00 61 0f 00 00     MS:   }}}...a...
    12e1:	20 2d 2d 49 64 65 6e 74 69 66 69 63 61 74 69 6f      --Identificatio
    12f1:	6e 2d 2d 2d 00 00 00 00 00 00 00 20 56 65 67 61     n---....... Vega
    1301:	20 53 2f 4e 3a 20 20 20 20 20 7d 7d 7d 7d 7d 00      S/N:     }}}}}.
    1311:	00 00 71 0f 00 00                                   ..q...

00001317 <MenuGSM>:
    1317:	81 0f 22 00 00 00 00 00 00 00 00 00 00 00 00 00     ..".............
    1327:	00 00 00 00                                         ....

0000132b <Mem_OK_Tbl>:
    132b:	fd 06 f7 06                                         ....

0000132f <F_Ok_Flash>:
    132f:	1f 16 09 2b 13 00                                   ...+..

00001335 <F_Ok_EEPROM>:
    1335:	1f 16 09 2b 13 01                                   ...+..

0000133b <Msg_EEWarning>:
    133b:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    134b:	20 20 20 20 00 00 00 20 cf e5 f0 e5 e4 20 ef f0         ... ..... ..
    135b:	ee e4 ee eb e6 e5 ed e8 e5 ec 20 00 00 00 f0 e0     .......... .....
    136b:	e1 ee f2 fb 20 ef f0 ee e2 e5 f0 fc f2 e5 20 e2     .... ......... .
    137b:	f1 e5 00 00 00 20 20 20 20 20 20 ed e0 f1 f2 f0     .....      .....
    138b:	ee e9 ea e8 20 20 20 20 20 00 00 00 00 00 00 00     ....     .......
	...

0000139d <Msg_NoBackUp>:
    139d:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    13ad:	20 20 20 20 00 00 00 d1 ee f5 f0 e0 ed b8 ed ed         ............
    13bd:	fb f5 20 ed e0 f1 f2 f0 ee e5 ea 00 00 00 20 20     .. ...........  
    13cd:	20 20 ed e5 20 ee e1 ed e0 f0 f3 e6 e5 ed ee 20       .. .......... 
    13dd:	20 20 00 00 00 20 20 20 20 20 20 20 20 20 20 20       ...           
    13ed:	20 20 20 20 20 20 20 20 20 00 00 00 00 00 00 00              .......
	...

000013ff <Menu_ConfirmationSave_List>:
    13ff:	d1 ee f5 f0 e0 ed e8 f2 fc 20 ed e0 f1 f2 f0 ee     ......... ......
    140f:	e9 ea e8 3f 00 00 00 00 00 00 00 20 20 20 c4 e0     ...?.......   ..
    141f:	20 2d 20 ea ed ee ef ea e0 20 c2 d5 ce c4 20 00      - ...... .... .
    142f:	00 00 00 00 00 00 20 20 cd e5 f2 20 2d 20 ea ed     ......  ... - ..
    143f:	ee ef ea e0 20 c2 db d5 ce c4 00 00 00 00 00 00     .... ...........
    144f:	00 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20     .               
    145f:	20 20 20 20 20 00 00 00 00 00 00 00                      .......

0000146b <Menu_ConfirmationSave>:
    146b:	ff 13 04 03 00 00 00 00 00 00 00 00 a0 41 00 00     .............A..
    147b:	00 00 00 00                                         ....

0000147f <Menu_ConfirmationRest_List>:
    147f:	c2 ee f1 f2 e0 ed ee e2 2e 20 ed e0 f1 f2 f0 ee     ......... ......
    148f:	e9 ea e8 3f 00 00 00 00 00 00 00 20 20 20 c4 e0     ...?.......   ..
    149f:	20 2d 20 ea ed ee ef ea e0 20 c2 d5 ce c4 20 00      - ...... .... .
    14af:	00 00 00 00 00 00 20 20 cd e5 f2 20 2d 20 ea ed     ......  ... - ..
    14bf:	ee ef ea e0 20 c2 db d5 ce c4 00 00 00 00 00 00     .... ...........
    14cf:	00 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20     .               
    14df:	20 20 20 20 20 00 00 00 00 00 00 00                      .......

000014eb <Menu_ConfirmationRestore>:
    14eb:	7f 14 04 03 00 00 00 00 00 00 00 00 95 41 00 00     .............A..
    14fb:	00 00 00 00                                         ....

000014ff <NoBackUp_Str>:
    14ff:	2d 2d 00                                            --.

00001502 <BackUp_Tbl>:
    1502:	ff 14                                               ..

00001504 <Menu_BackUp_IField>:
    1504:	05 00 00 02 15 00 05 01 00 02 15 00 05 02 00 02     ................
    1514:	15 00                                               ..

00001516 <Menu_BackUp_List>:
    1516:	d3 f1 f2 ed 2f d0 e5 e7 e5 f0 e2 ed e0 ff 20 ea     ..../......... .
    1526:	ee ef e8 ff 00 00 00 00 00 00 00 20 d1 ee f5 f0     ........... ....
    1536:	e0 ed e8 f2 fc 20 20 20 20 20 20 20 20 20 20 00     .....          .
    1546:	00 00 00 00 6b 14 20 c2 ee f1 f2 e0 ed ee e2 3a     ....k. ........:
    1556:	7b 7b 2e 7b 7b 2e 32 30 7b 7b 00 04 15 00 00 00     {{.{{.20{{......
    1566:	00 20 d1 ee f1 f2 2e 45 45 50 52 4f 4d 3a 20 7b     . .....EEPROM: {
    1576:	7b 7b 7b 7b 20 00 35 13 00 00 00 00                 {{{{ .5.....

00001582 <Menu_BackUp>:
    1582:	16 15 04 01 00 00 00 00 00 00 00 00 ee 76 00 00     .............v..
    1592:	00 00 00 00                                         ....

00001596 <ListMem>:
    1596:	20 2d 2d 2d 2d 2d 20 4d 65 6d 6f 72 79 20 2d 2d      ----- Memory --
    15a6:	2d 2d 2d 20 00 00 00 00 00 00 00 20 46 6c 61 73     --- ....... Flas
    15b6:	68 3a 20 20 7b 7b 7b 7b 7b 20 20 20 20 20 20 00     h:  {{{{{      .
    15c6:	2f 13 00 00 00 00 20 45 45 50 52 4f 4d 3a 20 7b     /..... EEPROM: {
    15d6:	7b 7b 7b 7b 20 20 20 20 20 20 00 35 13 00 00 00     {{{{      .5....
    15e6:	00 20 52 65 73 65 74 20 45 45 50 52 4f 4d 20 66     . Reset EEPROM f
    15f6:	61 69 6c 20 20 00 00 00 00 00 00 00 20 42 61 63     ail  ....... Bac
    1606:	6b 55 70 20 45 45 50 52 4f 4d 20 20 20 20 20 20     kUp EEPROM      
    1616:	00 00 00 00 00 82 15                                .......

0000161d <MenuMem>:
    161d:	96 15 05 01 00 00 00 00 00 00 00 00 53 4d 00 00     ............SM..
    162d:	00 00 00 00                                         ....

00001631 <MsgErr11>:
    1631:	20 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f      _______________
    1641:	5f 5f 5f 20 00 00 00 20 49 6e 74 65 72 6e 61 6c     ___ ... Internal
    1651:	20 65 72 72 6f 72 20 31 31 3a 20 00 00 00 20 20      error 11: ...  
    1661:	20 20 20 46 6c 61 73 68 20 66 61 69 6c 20 20 20        Flash fail   
    1671:	20 20 00 00 00 20 20 20 20 20 20 20 20 20 20 20       ...           
    1681:	20 20 20 20 20 20 20 20 20 00 00 00 00 00 00 00              .......
	...

00001693 <MsgErr12>:
    1693:	20 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f      _______________
    16a3:	5f 5f 5f 20 00 00 00 20 49 6e 74 65 72 6e 61 6c     ___ ... Internal
    16b3:	20 65 72 72 6f 72 20 31 32 3a 20 00 00 00 20 20      error 12: ...  
    16c3:	20 20 45 45 50 52 4f 4d 20 66 61 69 6c 20 20 20       EEPROM fail   
    16d3:	20 20 00 00 00 20 20 20 20 20 20 20 20 20 20 20       ...           
    16e3:	20 20 20 20 20 20 20 20 20 00 00 00 00 00 00 00              .......
	...

000016f5 <MsgErr13>:
    16f5:	20 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f      _______________
    1705:	5f 5f 5f 20 00 00 00 20 49 6e 74 65 72 6e 61 6c     ___ ... Internal
    1715:	20 65 72 72 6f 72 20 31 33 3a 20 00 00 00 20 54      error 13: ... T
    1725:	6f 74 61 6c 20 6d 65 6d 6f 72 79 20 66 61 69 6c     otal memory fail
    1735:	20 20 00 00 00 20 20 20 20 20 20 20 20 20 20 20       ...           
    1745:	20 20 20 20 20 20 20 20 20 00 00 00 00 00 00 00              .......
	...

00001757 <MsgErrMemo>:
    1757:	00 00 31 16 93 16 f5 16                             ..1.....

0000175f <F_ScanCycle>:
    175f:	00 ae 07 00 00 00                                   ......

00001765 <F_ScanCyclePerSec>:
    1765:	07 cd 07 00 00 00                                   ......

0000176b <F_MaxScanCycle>:
    176b:	00 b1 06 00 00 00                                   ......

00001771 <ListScanCycle>:
    1771:	20 2d 2d 2d 20 53 63 61 6e 20 43 79 63 6c 65 20      --- Scan Cycle 
    1781:	2d 2d 2d 20 00 00 00 00 00 00 00 20 53 63 61 6e     --- ....... Scan
    1791:	43 79 63 6c 65 3a 20 20 20 7b 7b 7b 30 6d 73 00     Cycle:   {{{0ms.
    17a1:	5f 17 00 00 00 00 20 53 63 61 6e 43 79 63 6c 50     _..... ScanCyclP
    17b1:	65 72 53 65 63 3a 7b 7b 7b 7b 00 65 17 00 00 00     erSec:{{{{.e....
    17c1:	00 20 4d 61 78 53 63 61 6e 43 79 63 6c 65 3a 7b     . MaxScanCycle:{
    17d1:	7b 7b 30 6d 73 00 6b 17 00 00 00 00                 {{0ms.k.....

000017dd <MenuScanCycle>:
    17dd:	71 17 04 01 00 00 00 00 00 00 00 00 17 41 00 00     q............A..
    17ed:	00 00 00 00                                         ....

000017f1 <F_WT>:
    17f1:	0b 6a 0c 00 00 00 04 b0 06 00 00 00                 .j..........

000017fd <sec10_Str>:
    17fd:	31 30 20 f1 e5 ea 00                                10 ....

00001804 <sec30_Str>:
    1804:	33 30 20 f1 e5 ea 00                                30 ....

0000180b <min1_Str>:
    180b:	31 20 ec e8 ed 20 00                                1 ... .

00001812 <min3_Str>:
    1812:	33 20 ec e8 ed 20 00                                3 ... .

00001819 <min10_Str>:
    1819:	31 30 20 ec e8 ed 00                                10 ....

00001820 <BCKLT_Tbl>:
    1820:	fd 17 04 18 0b 18 12 18 19 18                       ..........

0000182a <F_Backlight>:
    182a:	1e 91 01 00 00 00 00 04 00 00 00 00 00 20 18 00     ............. ..

0000183a <F_IonT>:
    183a:	08 2f 01 00 00 00 00 ff 03 00 00 00 00 00 00 00     ./..............

0000184a <F_Menu_EMICounter>:
    184a:	10 3a 07 00 00 00                                   .:....

00001850 <ListSyst>:
    1850:	20 2d 20 d1 eb f3 e6 e5 e1 ed ee e5 20 ec e5 ed      - ......... ...
    1860:	fe 20 2d 20 00 00 00 00 00 00 00 20 c4 e8 f1 ea     . - ....... ....
    1870:	f0 e5 f2 ed fb e5 20 e2 f5 ee e4 fb 20 20 20 00     ...... .....   .
    1880:	00 00 00 00 6f 1e 20 c4 e8 f1 ea f0 e5 f2 ed fb     ....o. .........
    1890:	e5 20 e2 fb f5 ee e4 fb 20 20 00 00 00 00 00 33     . ......  .....3
    18a0:	21 20 c0 ed e0 eb ee e3 ee e2 fb e5 20 e2 f5 ee     ! .......... ...
    18b0:	e4 fb 20 20 20 00 00 00 00 00 e3 21 20 c0 ed e0     ..   ......! ...
    18c0:	eb ee e3 ee e2 fb e5 20 e2 fb f5 ee e4 fb 20 20     ....... ......  
    18d0:	00 00 00 00 00 a3 22 20 c0 d6 cf 20 20 20 20 20     ......" ...     
    18e0:	20 20 20 20 20 20 20 20 20 20 20 00 00 00 00 00                .....
    18f0:	66 08 20 d2 e5 f0 ec ee e4 e0 f2 f7 e8 ea e8 20     f. ............ 
    1900:	20 20 20 20 20 20 00 00 00 00 00 37 29 20 4d 6f           .....7) Mo
    1910:	64 62 75 73 20 20 20 20 20 20 20 20 20 20 20 20     dbus            
    1920:	20 00 00 00 00 00 8f 0b 20 cc ee e4 e5 ec 20 20      ....... .....  
    1930:	20 20 20 20 20 20 20 20 20 20 20 20 00 00 00 00                 ....
    1940:	00 17 13 20 7b 20 7d 7d 2e 7d 7d 2e 7d 7d 20 7d     ... { }}.}}.}} }
    1950:	7d 3a 7d 7d 3a 7d 7d 00 be 0b c4 0b 00 00 20 c0     }:}}:}}....... .
    1960:	e2 f2 ee cf e5 f0 e5 f5 cb e5 f2 ed c2 f0 3a 7d     ..............:}
    1970:	7d 7d 00 00 00 ae 0b 00 00 20 cd e0 f0 e0 e1 ee     }}....... ......
    1980:	f2 ea e0 3a 7b 7b 7b 7b 7b f7 7b 7b ec 00 f1 17     ...:{{{{{.{{....
    1990:	00 00 00 00 20 d1 ee f1 f2 ee ff ed e8 e5 20 ef     .... ......... .
    19a0:	e0 ec ff f2 e8 20 20 20 00 00 00 00 00 1d 16 20     .....   ....... 
    19b0:	53 63 61 6e 20 43 79 63 6c 65 3a 20 20 7b 7b 7b     Scan Cycle:  {{{
    19c0:	30 6d 73 00 5f 17 00 00 dd 17 20 cf ee f0 ee e3     0ms._..... .....
    19d0:	20 e8 ee ed ee e4 2e 3a 20 20 7d 7d 7d 7d 00 00      ......:  }}}}..
    19e0:	00 3a 18 00 00 20 cf ee e4 f1 e2 e5 f2 ea e0 c6     .:... ..........
    19f0:	ca c8 3a 7d 7d 7d 7d 7d 7d 00 00 00 2a 18 00 00     ..:}}}}}}...*...
    1a00:	20 d1 f7 b8 f2 2e dd cc cd 3a 7b 7b 7b 7b 7b 7b      ........:{{{{{{
    1a10:	7b 7b 7b 7b 00 4a 18 00 00 00 00                    {{{{.J.....

00001a1b <MenuSyst>:
    1a1b:	50 18 11 01 00 00 00 00 00 00 00 00 00 00 00 00     P...............
    1a2b:	00 00 00 00                                         ....

00001a2f <MsgErr41>:
    1a2f:	20 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f      _______________
    1a3f:	5f 5f 5f 20 00 00 00 20 49 6e 74 65 72 6e 61 6c     ___ ... Internal
    1a4f:	20 65 72 72 6f 72 20 34 31 3a 20 00 00 00 54 69      error 41: ...Ti
    1a5f:	6d 65 72 20 61 6c 6c 6f 63 61 74 69 6f 6e 20 65     mer allocation e
    1a6f:	72 72 00 00 00 20 20 20 20 20 20 20 20 20 20 20     rr...           
    1a7f:	20 20 20 20 20 20 20 20 20 00 00 00 00 00 00 00              .......
	...

00001a91 <F_DI1>:
    1a91:	1f 40 07 1b 07 00 1f 46 07 0d 07 00                 .@.....F....

00001a9d <F_DI2>:
    1a9d:	1f 40 07 1b 07 01 1f 46 07 0d 07 01                 .@.....F....

00001aa9 <F_DI3>:
    1aa9:	1f 40 07 1b 07 02 1f 46 07 0d 07 02                 .@.....F....

00001ab5 <F_DI4>:
    1ab5:	1f 40 07 1b 07 03 1f 46 07 0d 07 03                 .@.....F....

00001ac1 <F_DI5>:
    1ac1:	1f 40 07 1b 07 04 1f 46 07 0d 07 04                 .@.....F....

00001acd <F_DI6>:
    1acd:	1f 40 07 1b 07 05 1f 46 07 0d 07 05                 .@.....F....

00001ad9 <F_DI7>:
    1ad9:	1f 40 07 1b 07 06 1f 46 07 0d 07 06                 .@.....F....

00001ae5 <F_DI8>:
    1ae5:	1f 40 07 1b 07 07 1f 46 07 0d 07 07                 .@.....F....

00001af1 <F_DI9>:
    1af1:	1f 40 07 1b 07 08 1f 46 07 0d 07 08                 .@.....F....

00001afd <F_DI10>:
    1afd:	1f 40 07 1b 07 09 1f 46 07 0d 07 09                 .@.....F....

00001b09 <F_DI11>:
    1b09:	1f 40 07 1b 07 0a 1f 46 07 0d 07 0a                 .@.....F....

00001b15 <F_DI12>:
    1b15:	1f 40 07 1b 07 0b 1f 46 07 0d 07 0b                 .@.....F....

00001b21 <F_DI13>:
    1b21:	1f 40 07 1b 07 0c 1f 46 07 0d 07 0c                 .@.....F....

00001b2d <F_DI14>:
    1b2d:	1f 40 07 1b 07 0d 1f 46 07 0d 07 0d                 .@.....F....

00001b39 <F_DI15>:
    1b39:	1f 40 07 1b 07 0e 1f 46 07 0d 07 0e                 .@.....F....

00001b45 <F_DI16>:
    1b45:	1f 40 07 1b 07 0f 1f 46 07 0d 07 0f                 .@.....F....

00001b51 <F_DI17>:
    1b51:	1f 40 07 1b 07 10 1f 46 07 0d 07 10                 .@.....F....

00001b5d <F_DI18>:
    1b5d:	1f 40 07 1b 07 11 1f 46 07 0d 07 11                 .@.....F....

00001b69 <F_DII1>:
    1b69:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 00      ............)..

00001b79 <F_DII2>:
    1b79:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 01      ............)..

00001b89 <F_DII3>:
    1b89:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 02      ............)..

00001b99 <F_DII4>:
    1b99:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 03      ............)..

00001ba9 <F_DII5>:
    1ba9:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 04      ............)..

00001bb9 <F_DII6>:
    1bb9:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 05      ............)..

00001bc9 <F_DII7>:
    1bc9:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 06      ............)..

00001bd9 <F_DII8>:
    1bd9:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 07      ............)..

00001be9 <F_DII9>:
    1be9:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 08      ............)..

00001bf9 <F_DII10>:
    1bf9:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 09      ............)..

00001c09 <F_DII11>:
    1c09:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 0a      ............)..

00001c19 <F_DII12>:
    1c19:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 0b      ............)..

00001c29 <F_DII13>:
    1c29:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 0c      ............)..

00001c39 <F_DII14>:
    1c39:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 0d      ............)..

00001c49 <F_DII15>:
    1c49:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 0e      ............)..

00001c59 <F_DII16>:
    1c59:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 0f      ............)..

00001c69 <F_DII17>:
    1c69:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 10      ............)..

00001c79 <F_DII18>:
    1c79:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 11      ............)..

00001c89 <ListDI>:
    1c89:	20 4e 31 3a 20 20 7b 7b 7b 7b 20 7d 7d 7d 7d 20      N1:  {{{{ }}}} 
    1c99:	7b 7b 7b 7b 00 91 1a 69 1b 00 00 20 4e 32 3a 20     {{{{...i... N2: 
    1ca9:	20 7b 7b 7b 7b 20 7d 7d 7d 7d 20 7b 7b 7b 7b 00      {{{{ }}}} {{{{.
    1cb9:	9d 1a 79 1b 00 00 20 4e 33 3a 20 20 7b 7b 7b 7b     ..y... N3:  {{{{
    1cc9:	20 7d 7d 7d 7d 20 7b 7b 7b 7b 00 a9 1a 89 1b 00      }}}} {{{{......
    1cd9:	00 20 4e 34 3a 20 20 7b 7b 7b 7b 20 7d 7d 7d 7d     . N4:  {{{{ }}}}
    1ce9:	20 7b 7b 7b 7b 00 b5 1a 99 1b 00 00 20 4e 35 3a      {{{{....... N5:
    1cf9:	20 20 7b 7b 7b 7b 20 7d 7d 7d 7d 20 7b 7b 7b 7b       {{{{ }}}} {{{{
    1d09:	00 c1 1a a9 1b 00 00 20 4e 36 3a 20 20 7b 7b 7b     ....... N6:  {{{
    1d19:	7b 20 7d 7d 7d 7d 20 7b 7b 7b 7b 00 cd 1a b9 1b     { }}}} {{{{.....
    1d29:	00 00 20 4e 37 3a 20 20 7b 7b 7b 7b 20 7d 7d 7d     .. N7:  {{{{ }}}
    1d39:	7d 20 7b 7b 7b 7b 00 d9 1a c9 1b 00 00 20 4e 38     } {{{{....... N8
    1d49:	3a 20 20 7b 7b 7b 7b 20 7d 7d 7d 7d 20 7b 7b 7b     :  {{{{ }}}} {{{
    1d59:	7b 00 e5 1a d9 1b 00 00 20 4e 39 3a 20 20 7b 7b     {....... N9:  {{
    1d69:	7b 7b 20 7d 7d 7d 7d 20 7b 7b 7b 7b 00 f1 1a e9     {{ }}}} {{{{....
    1d79:	1b 00 00 20 4e 31 30 3a 20 7b 7b 7b 7b 20 7d 7d     ... N10: {{{{ }}
    1d89:	7d 7d 20 7b 7b 7b 7b 00 fd 1a f9 1b 00 00 20 4e     }} {{{{....... N
    1d99:	31 31 3a 20 7b 7b 7b 7b 20 7d 7d 7d 7d 20 7b 7b     11: {{{{ }}}} {{
    1da9:	7b 7b 00 09 1b 09 1c 00 00 20 4e 31 32 3a 20 7b     {{....... N12: {
    1db9:	7b 7b 7b 20 7d 7d 7d 7d 20 7b 7b 7b 7b 00 15 1b     {{{ }}}} {{{{...
    1dc9:	19 1c 00 00 20 4e 31 33 3a 20 7b 7b 7b 7b 20 7d     .... N13: {{{{ }
    1dd9:	7d 7d 7d 20 7b 7b 7b 7b 00 21 1b 29 1c 00 00 20     }}} {{{{.!.)... 
    1de9:	4e 31 34 3a 20 7b 7b 7b 7b 20 7d 7d 7d 7d 20 7b     N14: {{{{ }}}} {
    1df9:	7b 7b 7b 00 2d 1b 39 1c 00 00 20 4e 31 35 3a 20     {{{.-.9... N15: 
    1e09:	7b 7b 7b 7b 20 7d 7d 7d 7d 20 7b 7b 7b 7b 00 39     {{{{ }}}} {{{{.9
    1e19:	1b 49 1c 00 00 20 4e 31 36 3a 20 7b 7b 7b 7b 20     .I... N16: {{{{ 
    1e29:	7d 7d 7d 7d 20 7b 7b 7b 7b 00 45 1b 59 1c 00 00     }}}} {{{{.E.Y...
    1e39:	20 4e 31 37 3a 20 7b 7b 7b 7b 20 7d 7d 7d 7d 20      N17: {{{{ }}}} 
    1e49:	7b 7b 7b 7b 00 51 1b 69 1c 00 00 20 4e 31 38 3a     {{{{.Q.i... N18:
    1e59:	20 7b 7b 7b 7b 20 7d 7d 7d 7d 20 7b 7b 7b 7b 00      {{{{ }}}} {{{{.
    1e69:	5d 1b 79 1c 00 00                                   ].y...

00001e6f <MenuDI>:
    1e6f:	89 1c 12 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1e7f:	00 00 00 00                                         ....

00001e83 <F_DO1>:
    1e83:	1f de 07 00 00 00 00 00 00 00 00 00 00 37 07 00     .............7..

00001e93 <F_DO2>:
    1e93:	1f de 07 00 00 00 00 00 00 00 00 00 00 37 07 01     .............7..

00001ea3 <F_DO3>:
    1ea3:	1f de 07 00 00 00 00 00 00 00 00 00 00 37 07 02     .............7..

00001eb3 <F_DO4>:
    1eb3:	1f de 07 00 00 00 00 00 00 00 00 00 00 37 07 03     .............7..

00001ec3 <F_DO5>:
    1ec3:	1f de 07 00 00 00 00 00 00 00 00 00 00 37 07 04     .............7..

00001ed3 <F_DO6>:
    1ed3:	1f de 07 00 00 00 00 00 00 00 00 00 00 37 07 05     .............7..

00001ee3 <F_DO7>:
    1ee3:	1f de 07 00 00 00 00 00 00 00 00 00 00 37 07 06     .............7..

00001ef3 <F_DO8>:
    1ef3:	1f de 07 00 00 00 00 00 00 00 00 00 00 37 07 07     .............7..

00001f03 <F_DO9>:
    1f03:	1f de 07 00 00 00 00 00 00 00 00 00 00 37 07 08     .............7..

00001f13 <F_DO10>:
    1f13:	1f de 07 00 00 00 00 00 00 00 00 00 00 37 07 09     .............7..

00001f23 <F_DO11>:
    1f23:	1f de 07 00 00 00 00 00 00 00 00 00 00 37 07 0a     .............7..

00001f33 <F_DO12>:
    1f33:	1f de 07 00 00 00 00 00 00 00 00 00 00 37 07 0b     .............7..

00001f43 <F_DO13>:
    1f43:	1f de 07 00 00 00 00 00 00 00 00 00 00 37 07 0c     .............7..

00001f53 <F_DO14>:
    1f53:	1f de 07 00 00 00 00 00 00 00 00 00 00 37 07 0d     .............7..

00001f63 <F_DO15>:
    1f63:	1f de 07 00 00 00 00 00 00 00 00 00 00 37 07 0e     .............7..

00001f73 <F_DO16>:
    1f73:	1f de 07 00 00 00 00 00 00 00 00 00 00 37 07 0f     .............7..

00001f83 <ListDO>:
    1f83:	20 c2 fb f5 ee e4 20 4e 31 3a 20 20 20 20 20 7d      ..... N1:     }
    1f93:	7d 7d 7d 20 00 00 00 83 1e 00 00 20 c2 fb f5 ee     }}} ....... ....
    1fa3:	e4 20 4e 32 3a 20 20 20 20 20 7d 7d 7d 7d 20 00     . N2:     }}}} .
    1fb3:	00 00 93 1e 00 00 20 c2 fb f5 ee e4 20 4e 33 3a     ...... ..... N3:
    1fc3:	20 20 20 20 20 7d 7d 7d 7d 20 00 00 00 a3 1e 00          }}}} ......
    1fd3:	00 20 c2 fb f5 ee e4 20 4e 34 3a 20 20 20 20 20     . ..... N4:     
    1fe3:	7d 7d 7d 7d 20 00 00 00 b3 1e 00 00 20 c2 fb f5     }}}} ....... ...
    1ff3:	ee e4 20 4e 35 3a 20 20 20 20 20 7d 7d 7d 7d 20     .. N5:     }}}} 
    2003:	00 00 00 c3 1e 00 00 20 c2 fb f5 ee e4 20 4e 36     ....... ..... N6
    2013:	3a 20 20 20 20 20 7d 7d 7d 7d 20 00 00 00 d3 1e     :     }}}} .....
    2023:	00 00 20 c2 fb f5 ee e4 20 4e 37 3a 20 20 20 20     .. ..... N7:    
    2033:	20 7d 7d 7d 7d 20 00 00 00 e3 1e 00 00 20 c2 fb      }}}} ....... ..
    2043:	f5 ee e4 20 4e 38 3a 20 20 20 20 20 7d 7d 7d 7d     ... N8:     }}}}
    2053:	20 00 00 00 f3 1e 00 00 20 c2 fb f5 ee e4 20 4e      ....... ..... N
    2063:	39 3a 20 20 20 20 20 7d 7d 7d 7d 20 00 00 00 03     9:     }}}} ....
    2073:	1f 00 00 20 c2 fb f5 ee e4 20 4e 31 30 3a 20 20     ... ..... N10:  
    2083:	20 20 7d 7d 7d 7d 20 00 00 00 13 1f 00 00 20 c2       }}}} ....... .
    2093:	fb f5 ee e4 20 4e 31 31 3a 20 20 20 20 7d 7d 7d     .... N11:    }}}
    20a3:	7d 20 00 00 00 23 1f 00 00 20 c2 fb f5 ee e4 20     } ...#... ..... 
    20b3:	4e 31 32 3a 20 20 20 20 7d 7d 7d 7d 20 00 00 00     N12:    }}}} ...
    20c3:	33 1f 00 00 20 c2 fb f5 ee e4 20 4e 31 33 3a 20     3... ..... N13: 
    20d3:	20 20 20 7d 7d 7d 7d 20 00 00 00 43 1f 00 00 20        }}}} ...C... 
    20e3:	c2 fb f5 ee e4 20 4e 31 34 3a 20 20 20 20 7d 7d     ..... N14:    }}
    20f3:	7d 7d 20 00 00 00 53 1f 00 00 20 c2 fb f5 ee e4     }} ...S... .....
    2103:	20 4e 31 35 3a 20 20 20 20 7d 7d 7d 7d 20 00 00      N15:    }}}} ..
    2113:	00 63 1f 00 00 20 c2 fb f5 ee e4 20 4e 31 36 3a     .c... ..... N16:
    2123:	20 20 20 20 7d 7d 7d 7d 20 00 00 00 73 1f 00 00         }}}} ...s...

00002133 <MenuDO>:
    2133:	83 1f 10 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2143:	00 00 00 00                                         ....

00002147 <F_AI12>:
    2147:	0b 4d 0b 00 00 00 0b 4f 0b 00 00 00                 .M.....O....

00002153 <F_AI34>:
    2153:	0b 51 0b 00 00 00 0b 53 0b 00 00 00                 .Q.....S....

0000215f <F_AI56>:
    215f:	0b 55 0b 00 00 00 0b 57 0b 00 00 00                 .U.....W....

0000216b <F_AI78>:
    216b:	0b 59 0b 00 00 00 0b 5b 0b 00 00 00                 .Y.....[....

00002177 <ListAI>:
    2177:	20 4e 31 3a 20 7b 7b 7b 7b 7b 20 4e 32 3a 20 7b      N1: {{{{{ N2: {
    2187:	7b 7b 7b 7b 00 47 21 00 00 00 00 20 4e 33 3a 20     {{{{.G!.... N3: 
    2197:	7b 7b 7b 7b 7b 20 4e 34 3a 20 7b 7b 7b 7b 7b 00     {{{{{ N4: {{{{{.
    21a7:	53 21 00 00 00 00 20 4e 35 3a 20 7b 7b 7b 7b 7b     S!.... N5: {{{{{
    21b7:	20 4e 36 3a 20 7b 7b 7b 7b 7b 00 5f 21 00 00 00      N6: {{{{{._!...
    21c7:	00 20 4e 37 3a 20 7b 7b 7b 7b 7b 20 4e 38 3a 20     . N7: {{{{{ N8: 
    21d7:	7b 7b 7b 7b 7b 00 6b 21 00 00 00 00                 {{{{{.k!....

000021e3 <MenuAI>:
    21e3:	77 21 04 03 00 00 00 00 00 00 00 00 00 00 00 00     w!..............
    21f3:	00 00 00 00                                         ....

000021f7 <F_AO1>:
    21f7:	0e d1 07 00 00 00 00 ff 03 00 00 00 00 00 00 00     ................

00002207 <F_AO2>:
    2207:	0e d3 07 00 00 00 00 ff 03 00 00 00 00 00 00 00     ................

00002217 <F_AO3>:
    2217:	0e d5 07 00 00 00 00 ff 03 00 00 00 00 00 00 00     ................

00002227 <F_AO4>:
    2227:	0e d7 07 00 00 00 00 ff 03 00 00 00 00 00 00 00     ................

00002237 <ListAO>:
    2237:	20 c2 fb f5 ee e4 20 4e 31 3a 20 20 20 20 20 7d      ..... N1:     }
    2247:	7d 7d 7d 7d 00 00 00 f7 21 00 00 20 c2 fb f5 ee     }}}}....!.. ....
    2257:	e4 20 4e 32 3a 20 20 20 20 20 7d 7d 7d 7d 7d 00     . N2:     }}}}}.
    2267:	00 00 07 22 00 00 20 c2 fb f5 ee e4 20 4e 33 3a     ...".. ..... N3:
    2277:	20 20 20 20 20 7d 7d 7d 7d 7d 00 00 00 17 22 00          }}}}}....".
    2287:	00 20 c2 fb f5 ee e4 20 4e 34 3a 20 20 20 20 20     . ..... N4:     
    2297:	7d 7d 7d 7d 7d 00 00 00 27 22 00 00                 }}}}}...'"..

000022a3 <MenuAO>:
    22a3:	37 22 04 00 00 00 00 00 00 00 00 00 00 00 00 00     7"..............
    22b3:	00 00 00 00                                         ....

000022b7 <F_ADC12>:
    22b7:	07 1a 09 00 00 00 07 1c 09 00 00 00                 ............

000022c3 <F_ADC34>:
    22c3:	07 1e 09 00 00 00 07 20 09 00 00 00                 ....... ....

000022cf <F_ADC56>:
    22cf:	07 22 09 00 00 00 07 24 09 00 00 00                 .".....$....

000022db <F_ADC_Ref>:
    22db:	07 26 09 00 00 00                                   .&....

000022e1 <List_ADC_Chan>:
    22e1:	20 2d 2d 2d 20 ca e0 ed e0 eb fb 20 c0 d6 cf 20      --- ...... ... 
    22f1:	2d 2d 2d 20 00 00 00 00 00 00 00 20 4e 31 3a 20     --- ....... N1: 
    2301:	7b 7b 7b 7b 7b 20 4e 32 3a 20 7b 7b 7b 7b 7b 00     {{{{{ N2: {{{{{.
    2311:	b7 22 00 00 00 00 20 4e 33 3a 20 7b 7b 7b 7b 7b     .".... N3: {{{{{
    2321:	20 4e 34 3a 20 7b 7b 7b 7b 7b 00 c3 22 00 00 00      N4: {{{{{.."...
    2331:	00 20 4e 35 3a 20 7b 7b 7b 7b 7b 20 4e 36 3a 20     . N5: {{{{{ N6: 
    2341:	7b 7b 7b 7b 7b 00 cf 22 00 00 00 00 20 ce ef ee     {{{{{..".... ...
    2351:	f0 ed 2e 20 ea e0 ed e0 eb 3a 20 7b 7b 7b 7b 7b     ... .....: {{{{{
    2361:	00 db 22 00 00 00 00                                .."....

00002368 <Menu_ADC_Ch>:
    2368:	e1 22 05 01 00 00 00 00 00 00 00 00 00 00 00 00     ."..............
    2378:	00 00 00 00                                         ....

0000237c <F_ADC_Zero>:
    237c:	00 6e 0c 00 00 00 04 6d 0c 00 00 00 04 6c 0c 00     .n.....m.....l..
	...

0000238e <F_ADC_Full>:
    238e:	00 71 0c 00 00 00 04 70 0c 00 00 00 04 6f 0c 00     .q.....p.....o..
	...

000023a0 <List_ADC_Cali>:
    23a0:	20 2d 2d 2d 20 ca e0 eb e8 e1 f0 ee e2 ea e0 20      --- .......... 
    23b0:	2d 2d 2d 20 00 00 00 00 00 00 00 20 5a 65 72 6f     --- ....... Zero
    23c0:	3a 20 20 7b 7b 7b 20 7b 7b 7b 20 7b 7b 7b 20 00     :  {{{ {{{ {{{ .
    23d0:	7c 23 00 00 00 00 20 46 75 6c 6c 3a 20 20 7b 7b     |#.... Full:  {{
    23e0:	7b 20 7b 7b 7b 20 7b 7b 7b 20 00 8e 23 00 00 00     { {{{ {{{ ..#...
    23f0:	00 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20     .               
    2400:	20 20 20 20 20 00 00 00 00 00 00 00                      .......

0000240c <Menu_ADC_Cali>:
    240c:	a0 23 04 03 00 00 00 00 00 00 00 00 00 00 00 00     .#..............
    241c:	00 00 00 00                                         ....

00002420 <ADC_Rt_Str>:
    2420:	52 65 73 65 74 00                                   Reset.

00002426 <ADC_I1_Str>:
    2426:	49 6e 69 74 69 61 6c 69 73 61 74 00                 Initialisat.

00002432 <ADC_C1_Str>:
    2432:	43 61 6c 69 62 72 61 74 69 6f 6e 00                 Calibration.

0000243e <ADC_Re_Str>:
    243e:	52 65 61 64 00                                      Read.

00002443 <ADC_Of_Str>:
    2443:	4f 66 66 00                                         Off.

00002447 <ADC_Tbl>:
    2447:	20 24 26 24 32 24 3e 24 43 24                        $&$2$>$C$

00002451 <F_Therm1>:
    2451:	09 45 06 ec 08 01                                   .E....

00002457 <F_Therm2>:
    2457:	09 47 06 ec 08 01                                   .G....

0000245d <F_Therm3>:
    245d:	09 49 06 ec 08 01                                   .I....

00002463 <F_Therm4>:
    2463:	09 4b 06 ec 08 01                                   .K....

00002469 <F_Therm5>:
    2469:	09 4d 06 ec 08 01                                   .M....

0000246f <F_Therm6>:
    246f:	09 4f 06 ec 08 01                                   .O....

00002475 <F_Thermis1>:
    2475:	1e 17 01 00 00 00 00 07 00 00 00 00 00 20 09 00     ............. ..

00002485 <F_Thermis2>:
    2485:	1e 18 01 00 00 00 00 07 00 00 00 00 00 20 09 00     ............. ..

00002495 <F_Thermis3>:
    2495:	1e 19 01 00 00 00 00 07 00 00 00 00 00 20 09 00     ............. ..

000024a5 <F_Thermis4>:
    24a5:	1e 1a 01 00 00 00 00 07 00 00 00 00 00 20 09 00     ............. ..

000024b5 <F_Thermis5>:
    24b5:	1e 1b 01 00 00 00 00 07 00 00 00 00 00 20 09 00     ............. ..

000024c5 <F_Thermis6>:
    24c5:	1e 1c 01 00 00 00 00 07 00 00 00 00 00 20 09 00     ............. ..

000024d5 <F_ThermisD1>:
    24d5:	03 1d 01 80 ff ff ff 7f 00 00 00 00 00 00 00 01     ................

000024e5 <F_ThermisD2>:
    24e5:	03 20 01 80 ff ff ff 7f 00 00 00 00 00 00 00 01     . ..............

000024f5 <F_ThermisD3>:
    24f5:	03 23 01 80 ff ff ff 7f 00 00 00 00 00 00 00 01     .#..............

00002505 <F_ThermisD4>:
    2505:	03 26 01 80 ff ff ff 7f 00 00 00 00 00 00 00 01     .&..............

00002515 <F_ThermisD5>:
    2515:	03 29 01 80 ff ff ff 7f 00 00 00 00 00 00 00 01     .)..............

00002525 <F_ThermisD6>:
    2525:	03 2c 01 80 ff ff ff 7f 00 00 00 00 00 00 00 01     .,..............

00002535 <F_ThermisA1>:
    2535:	08 1e 01 84 03 00 00 4c 04 00 00 00 00 00 00 03     .......L........

00002545 <F_ThermisA2>:
    2545:	08 21 01 84 03 00 00 4c 04 00 00 00 00 00 00 03     .!.....L........

00002555 <F_ThermisA3>:
    2555:	08 24 01 84 03 00 00 4c 04 00 00 00 00 00 00 03     .$.....L........

00002565 <F_ThermisA4>:
    2565:	08 27 01 84 03 00 00 4c 04 00 00 00 00 00 00 03     .'.....L........

00002575 <F_ThermisA5>:
    2575:	08 2a 01 84 03 00 00 4c 04 00 00 00 00 00 00 03     .*.....L........

00002585 <F_ThermisA6>:
    2585:	08 2d 01 84 03 00 00 4c 04 00 00 00 00 00 00 03     .-.....L........

00002595 <ListTherm1>:
    2595:	20 ca e0 ed e0 eb 20 4e 31 3a 20 7b 7b 7b 7b 7b      ..... N1: {{{{{
    25a5:	7b 7b 7c 43 00 51 24 00 00 00 00 20 d2 e5 f0 ec     {{|C.Q$.... ....
    25b5:	ee e4 e0 f2 f7 e8 ea 3a 20 7d 7d 7d 7d 7d 7d 00     .......: }}}}}}.
    25c5:	00 00 75 24 00 00 20 d1 e4 e2 e8 e3 3a 20 20 20     ..u$.. .....:   
    25d5:	20 20 20 7d 7d 7d 7d 7d 7c 43 00 00 00 d5 24 00        }}}}}|C....$.
    25e5:	00 20 ca ee fd f4 f4 e8 f6 e8 e5 ed f2 3a 20 20     . ...........:  
    25f5:	7d 7d 7d 7d 7d 00 00 00 35 25 00 00                 }}}}}...5%..

00002601 <MenuTherm1>:
    2601:	95 25 04 01 00 00 00 00 00 00 00 00 00 00 00 00     .%..............
    2611:	00 00 00 00                                         ....

00002615 <ListTherm2>:
    2615:	20 ca e0 ed e0 eb 20 4e 32 3a 20 7b 7b 7b 7b 7b      ..... N2: {{{{{
    2625:	7b 7b 7c 43 00 57 24 00 00 00 00 20 d2 e5 f0 ec     {{|C.W$.... ....
    2635:	ee e4 e0 f2 f7 e8 ea 3a 20 7d 7d 7d 7d 7d 7d 00     .......: }}}}}}.
    2645:	00 00 85 24 00 00 20 d1 e4 e2 e8 e3 3a 20 20 20     ...$.. .....:   
    2655:	20 20 20 7d 7d 7d 7d 7d 7c 43 00 00 00 e5 24 00        }}}}}|C....$.
    2665:	00 20 ca ee fd f4 f4 e8 f6 e8 e5 ed f2 3a 20 20     . ...........:  
    2675:	7d 7d 7d 7d 7d 00 00 00 45 25 00 00                 }}}}}...E%..

00002681 <MenuTherm2>:
    2681:	15 26 04 01 00 00 00 00 00 00 00 00 00 00 00 00     .&..............
    2691:	00 00 00 00                                         ....

00002695 <ListTherm3>:
    2695:	20 ca e0 ed e0 eb 20 4e 33 3a 20 7b 7b 7b 7b 7b      ..... N3: {{{{{
    26a5:	7b 7b 7c 43 00 5d 24 00 00 00 00 20 d2 e5 f0 ec     {{|C.]$.... ....
    26b5:	ee e4 e0 f2 f7 e8 ea 3a 20 7d 7d 7d 7d 7d 7d 00     .......: }}}}}}.
    26c5:	00 00 95 24 00 00 20 d1 e4 e2 e8 e3 3a 20 20 20     ...$.. .....:   
    26d5:	20 20 20 7d 7d 7d 7d 7d 7c 43 00 00 00 f5 24 00        }}}}}|C....$.
    26e5:	00 20 ca ee fd f4 f4 e8 f6 e8 e5 ed f2 3a 20 20     . ...........:  
    26f5:	7d 7d 7d 7d 7d 00 00 00 55 25 00 00                 }}}}}...U%..

00002701 <MenuTherm3>:
    2701:	95 26 04 01 00 00 00 00 00 00 00 00 00 00 00 00     .&..............
    2711:	00 00 00 00                                         ....

00002715 <ListTherm4>:
    2715:	20 ca e0 ed e0 eb 20 4e 34 3a 20 7b 7b 7b 7b 7b      ..... N4: {{{{{
    2725:	7b 7b 7c 43 00 63 24 00 00 00 00 20 d2 e5 f0 ec     {{|C.c$.... ....
    2735:	ee e4 e0 f2 f7 e8 ea 3a 20 7d 7d 7d 7d 7d 7d 00     .......: }}}}}}.
    2745:	00 00 a5 24 00 00 20 d1 e4 e2 e8 e3 3a 20 20 20     ...$.. .....:   
    2755:	20 20 20 7d 7d 7d 7d 7d 7c 43 00 00 00 05 25 00        }}}}}|C....%.
    2765:	00 20 ca ee fd f4 f4 e8 f6 e8 e5 ed f2 3a 20 20     . ...........:  
    2775:	7d 7d 7d 7d 7d 00 00 00 65 25 00 00                 }}}}}...e%..

00002781 <MenuTherm4>:
    2781:	15 27 04 01 00 00 00 00 00 00 00 00 00 00 00 00     .'..............
    2791:	00 00 00 00                                         ....

00002795 <ListTherm5>:
    2795:	20 ca e0 ed e0 eb 20 4e 35 3a 20 7b 7b 7b 7b 7b      ..... N5: {{{{{
    27a5:	7b 7b 7c 43 00 69 24 00 00 00 00 20 d2 e5 f0 ec     {{|C.i$.... ....
    27b5:	ee e4 e0 f2 f7 e8 ea 3a 20 7d 7d 7d 7d 7d 7d 00     .......: }}}}}}.
    27c5:	00 00 b5 24 00 00 20 d1 e4 e2 e8 e3 3a 20 20 20     ...$.. .....:   
    27d5:	20 20 20 7d 7d 7d 7d 7d 7c 43 00 00 00 15 25 00        }}}}}|C....%.
    27e5:	00 20 ca ee fd f4 f4 e8 f6 e8 e5 ed f2 3a 20 20     . ...........:  
    27f5:	7d 7d 7d 7d 7d 00 00 00 75 25 00 00                 }}}}}...u%..

00002801 <MenuTherm5>:
    2801:	95 27 04 01 00 00 00 00 00 00 00 00 00 00 00 00     .'..............
    2811:	00 00 00 00                                         ....

00002815 <ListTherm6>:
    2815:	20 ca e0 ed e0 eb 20 4e 36 3a 20 7b 7b 7b 7b 7b      ..... N6: {{{{{
    2825:	7b 7b 7c 43 00 6f 24 00 00 00 00 20 d2 e5 f0 ec     {{|C.o$.... ....
    2835:	ee e4 e0 f2 f7 e8 ea 3a 20 7d 7d 7d 7d 7d 7d 00     .......: }}}}}}.
    2845:	00 00 c5 24 00 00 20 d1 e4 e2 e8 e3 3a 20 20 20     ...$.. .....:   
    2855:	20 20 20 7d 7d 7d 7d 7d 7c 43 00 00 00 25 25 00        }}}}}|C...%%.
    2865:	00 20 ca ee fd f4 f4 e8 f6 e8 e5 ed f2 3a 20 20     . ...........:  
    2875:	7d 7d 7d 7d 7d 00 00 00 85 25 00 00                 }}}}}....%..

00002881 <MenuTherm6>:
    2881:	15 28 04 01 00 00 00 00 00 00 00 00 00 00 00 00     .(..............
    2891:	00 00 00 00                                         ....

00002895 <List_Therm>:
    2895:	20 ca e0 ed e0 eb 20 4e 31 3a 20 7b 7b 7b 7b 7b      ..... N1: {{{{{
    28a5:	7b 7b 7c 43 00 51 24 00 00 01 26 20 ca e0 ed e0     {{|C.Q$...& ....
    28b5:	eb 20 4e 32 3a 20 7b 7b 7b 7b 7b 7b 7b 7c 43 00     . N2: {{{{{{{|C.
    28c5:	57 24 00 00 81 26 20 ca e0 ed e0 eb 20 4e 33 3a     W$...& ..... N3:
    28d5:	20 7b 7b 7b 7b 7b 7b 7b 7c 43 00 5d 24 00 00 01      {{{{{{{|C.]$...
    28e5:	27 20 ca e0 ed e0 eb 20 4e 34 3a 20 7b 7b 7b 7b     ' ..... N4: {{{{
    28f5:	7b 7b 7b 7c 43 00 63 24 00 00 81 27 20 ca e0 ed     {{{|C.c$...' ...
    2905:	e0 eb 20 4e 35 3a 20 7b 7b 7b 7b 7b 7b 7b 7c 43     .. N5: {{{{{{{|C
    2915:	00 69 24 00 00 01 28 20 ca e0 ed e0 eb 20 4e 36     .i$...( ..... N6
    2925:	3a 20 7b 7b 7b 7b 7b 7b 7b 7c 43 00 6f 24 00 00     : {{{{{{{|C.o$..
    2935:	81 28                                               .(

00002937 <MenuTherm>:
    2937:	95 28 06 00 00 00 00 00 00 00 00 00 00 00 00 00     .(..............
    2947:	00 00 00 00                                         ....

0000294b <MB_Master_List>:
    294b:	00 00 00                                            ...

0000294e <Channel0_Name_InField>:
    294e:	00 b6 06 00 00 00                                   ......

00002954 <Channel0_DI_State_InField>:
    2954:	00 b7 06 00 00 00                                   ......

0000295a <Channel0_Alarm_State_InField>:
    295a:	00 b8 06 00 00 00                                   ......

00002960 <Channel0_debounceTimeout_OutField>:
    2960:	08 31 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .1..............

00002970 <Channel0_calling_delay_OutField>:
    2970:	08 51 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .Q..............

00002980 <Channel0_calling_retry_delay_OutField>:
    2980:	08 71 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .q..............

00002990 <Channel0>:
    2990:	20 cd ee ec e5 f0 20 ea e0 ed e0 eb e0 20 20 20      ..... ......   
    29a0:	20 7b 7b 7b 00 4e 29 00 00 00 00 20 d1 ee f1 f2      {{{.N).... ....
    29b0:	ee ff ed e8 e5 20 e2 f5 ee e4 e0 20 7b 7b 7b 00     ..... ..... {{{.
    29c0:	54 29 00 00 00 00 20 d1 ee f1 f2 ee ff ed e8 e5     T).... .........
    29d0:	20 ea e0 ed e0 eb e0 7b 7b 7b 00 5a 29 00 00 00      ......{{{.Z)...
    29e0:	00 20 d2 e0 ed f2 e8 e4 f0 e5 e1 e5 e7 e3 20 20     . ............  
    29f0:	7d 7d 7d 7d 7d 00 00 00 60 29 00 00 20 d2 e4 ee     }}}}}...`).. ...
    2a00:	e7 e2 ee ed e0 20 20 20 20 20 20 7d 7d 7d 7d 7d     .....      }}}}}
    2a10:	00 00 00 70 29 00 00 20 d2 ef ee e2 f2 2e e4 ee     ...p).. ........
    2a20:	e7 e2 ee ed e0 20 7d 7d 7d 7d 7d 00 00 00 80 29     ..... }}}}}....)
	...

00002a32 <Channel0_Page>:
    2a32:	90 29 06 00 00 00 00 00 00 00 00 00 00 00 00 00     .)..............
    2a42:	00 00 00 00                                         ....

00002a46 <ChannelSettingsList>:
    2a46:	20 ca e0 ed e0 eb 20 31 20 20 20 20 20 20 20 20      ..... 1        
    2a56:	20 20 20 20 00 00 00 00 00 32 2a                        .....2*

00002a61 <MenuModem>:
    2a61:	81 0f 22 00 02 2b 00 00 00 00 00 00 00 00 00 00     .."..+..........
    2a71:	00 00 00 00                                         ....

00002a75 <Field_TransmitterState>:
    2a75:	00 ba 06 00 00 00                                   ......

00002a7b <Menu0List>:
    2a7b:	20 2d 47 53 4d 2d f1 e8 e3 ed e0 eb e8 e7 e0 f2      -GSM-..........
    2a8b:	ee f0 2d 20 00 00 00 00 00 02 2b 20 d1 eb f3 e6     ..- ......+ ....
    2a9b:	e5 e1 ed ee e5 20 20 20 20 20 20 20 20 20 20 00     .....          .
    2aab:	00 00 00 00 1b 1a 20 cc ee e4 e5 ec 20 20 20 20     ...... .....    
    2abb:	20 20 20 20 20 20 20 20 20 20 00 00 00 00 00 61               .....a
    2acb:	2a 20 cd e0 f1 f2 f0 ee e9 ea e0 20 ea e0 ed e0     * ......... ....
    2adb:	eb ee e2 20 20 00 00 00 00 00 32 2a 20 d1 ee f1     ...  .....2* ...
    2aeb:	f2 2e 6f e1 e7 e2 ee ed e0 20 20 20 20 7b 7b 7b     ..o......    {{{
    2afb:	00 75 2a 00 00 00 00                                .u*....

00002b02 <Menu0>:
    2b02:	7b 2a 05 00 02 2b 00 00 00 00 00 00 00 00 00 00     {*...+..........
    2b12:	00 00 00 00                                         ....

00002b16 <KeyAct.9481>:
    2b16:	00 00 8d 41 94 41 80 58 d8 53 2a 5c cf 5b           ...A.A.X.S*\.[

00002b24 <MaxThermType>:
    2b24:	07 02                                               ..

00002b26 <TerLimType>:
    2b26:	c3 06 e3 06                                         ....

00002b2a <TSM100Tbl>:
    2b2a:	00 00 e1 f6 91 08 30 f8 0e 28 18 fc a2 37 0c fe     ......0..(...7..
    2b3a:	ea 46 00 00 49 65 e8 03 a6 83 d0 07 ff ff f4 17     .F..Ie..........

00002b4a <TSM50Tbl>:
    2b4a:	00 00 df f6 46 04 30 f8 13 0c 24 fa fe 13 18 fc     ....F.0...$.....
    2b5a:	c6 1b 0c fe 6b 23 00 00 03 2b f4 01 9a 32 e8 03     ....k#...+...2..
    2b6a:	30 3a dc 05 c9 41 d0 07 ff ff bd 38                 0:...A.....8

00002b76 <TSP100Tbl>:
    2b76:	00 00 f6 f5 c2 38 0c fe e2 46 00 00 b6 62 e8 03     .....8...F...b..
    2b86:	96 7d d0 07 ae 97 b8 0b ea b0 a0 0f 54 c9 88 13     .}..........T...
    2b96:	e2 e0 70 17 ff ff 97 1e                             ..p.....

00002b9e <TSP50Tbl>:
    2b9e:	00 00 1f f6 5f 1c 0c fe 56 31 e8 03 d0 3e d0 07     ...._...V1...>..
    2bae:	d2 4b b8 0b 70 58 a0 0f aa 64 88 13 6c 70 70 17     .K..pX...d..lpp.
    2bbe:	ff ff 0e 47                                         ...G

00002bc2 <Pt100Tbl>:
    2bc2:	00 00 20 f6 fe 38 0c fe 48 62 e8 03 c4 7c d0 07     .. ..8..Hb...|..
    2bd2:	6e 96 b8 0b 50 af a0 0f 56 c7 88 13 94 de 70 17     n...P...V.....p.
    2be2:	f6 f4 58 1b ff ff 8b 1f                             ..X.....

00002bea <Gr21Tbl>:
    2bea:	00 00 1e f6 1c 1a 0c fe 64 2d e8 03 c6 39 d0 07     ........d-...9..
    2bfa:	c4 45 b8 0b 68 51 a0 0f 9e 5c 88 13 7a 67 70 17     .E..hQ...\..zgp.
    2c0a:	ff ff ce 4f                                         ...O

00002c0e <Gr23Tbl>:
    2c0e:	00 00 d5 f6 7d 1d 0c fe 8b 25 00 00 8f 2d f4 01     ....}....%...-..
    2c1e:	92 35 e8 03 95 3d dc 05 63 42 08 07 ff ff 3e 35     .5...=..cB....>5

00002c2e <TC_B_Tbl>:
    2c2e:	00 00 90 01 99 01 dc 05 7c 07 b8 0b 8e 15 88 13     ........|.......
    2c3e:	1b 1f 70 17 30 2a 58 1b c4 36 40 1f b6 44 28 23     ..p.0*X..6@..D(#
    2c4e:	f2 53 10 27 5a 64 f8 2a d0 75 e0 2e 40 88 c8 32     .S.'Zd.*.u..@..2
    2c5e:	78 9b b0 36 50 af 98 3a 82 c3 80 3e d2 d7 68 42     x..6P..:...>..hB
    2c6e:	ff ff 38 4a                                         ..8J

00002c72 <Mux.8930>:
    2c72:	06 00 07 00 00 08 01 08 02 08 03 08 04 08 05 08     ................

00002c82 <M.8855>:
    2c82:	00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f     ................

00002c92 <DI_M>:
    2c92:	07 01 08 01 06 01 40 00 07 01 08 01 06 01 80 00     ......@.........
    2ca2:	04 01 05 01 03 01 80 00 21 00 22 00 20 00 01 00     ........!.". ...
    2cb2:	21 00 22 00 20 00 02 00 21 00 22 00 20 00 04 00     !.". ...!.". ...
    2cc2:	21 00 22 00 20 00 08 00 21 00 22 00 20 00 10 00     !.". ...!.". ...
    2cd2:	21 00 22 00 20 00 20 00 21 00 22 00 20 00 40 00     !.". . .!.". .@.
    2ce2:	21 00 22 00 20 00 80 00 33 00 34 00 32 00 04 00     !.". ...3.4.2...
    2cf2:	04 01 05 01 03 01 40 00 04 01 05 01 03 01 20 00     ......@....... .
    2d02:	04 01 05 01 03 01 10 00 04 01 05 01 03 01 08 00     ................
    2d12:	04 01 05 01 03 01 02 01 04 01 05 01 03 01 04 01     ................

00002d22 <__c.6222>:
    2d22:	2b 50 44 50 00                                      +PDP.

00002d27 <__c.6220>:
    2d27:	43 4c 4f 53 00                                      CLOS.

00002d2c <__c.6218>:
    2d2c:	50 4f 53 54 00                                      POST.

00002d31 <__c.6215>:
    2d31:	47 45 54 20 00                                      GET .

00002d36 <__c.6213>:
    2d36:	0d 0a 00                                            ...

00002d39 <__c.6209>:
    2d39:	2b 43 53 51 3a 20 25 68 68 75 2c 25 68 68 75 00     +CSQ: %hhu,%hhu.

00002d49 <__c.6162>:
    2d49:	25 68 68 75 2c 20 43 4c 4f 53 45 44 00              %hhu, CLOSED.

00002d56 <__c.6156>:
    2d56:	4f 4b 00                                            OK.

00002d59 <__c.6149>:
    2d59:	25 68 68 75 20 25 68 68 75 20 25 68 68 75 20 25     %hhu %hhu %hhu %
    2d69:	68 68 75 00                                         hhu.

00002d6d <__c.6122>:
    2d6d:	4e 4f 20 43 41 52 52 49 45 52 00                    NO CARRIER.

00002d78 <__c.6120>:
    2d78:	42 55 53 59 00                                      BUSY.

00002d7d <__c.6118>:
    2d7d:	4f 4b 00                                            OK.

00002d80 <__c.6115>:
    2d80:	2b 43 4c 43 43 3a 20 31 2c 30 2c 36 2c 00           +CLCC: 1,0,6,.

00002d8e <__c.6112>:
    2d8e:	41 54 48 0d 00                                      ATH..

00002d93 <__c.6107>:
    2d93:	41 54 2b 43 52 45 43 3d 34 2c 22 43 3a 5c 55 73     AT+CREC=4,"C:\Us
    2da3:	65 72 5c 4e 6f 74 43 6f 6e 66 69 72 6d 2e 61 6d     er\NotConfirm.am
    2db3:	72 22 2c 30 2c 31 30 30 0d 00                       r",0,100..

00002dbd <__c.6102>:
    2dbd:	41 54 2b 43 52 45 43 3d 34 2c 22 43 3a 5c 55 73     AT+CREC=4,"C:\Us
    2dcd:	65 72 5c 43 6f 6e 66 69 72 6d 2e 61 6d 72 22 2c     er\Confirm.amr",
    2ddd:	30 2c 31 30 30 0d 00                                0,100..

00002de4 <__c.6099>:
    2de4:	2b 43 52 45 43 3a 20 30 00                          +CREC: 0.

00002ded <__c.6096>:
    2ded:	41 54 2b 43 52 45 43 3d 35 0d 00                    AT+CREC=5..

00002df8 <__c.6093>:
    2df8:	2b 43 4c 43 43 3a 20 33 2c 30 2c 36 00              +CLCC: 3,0,6.

00002e05 <__c.6091>:
    2e05:	2b 43 4c 43 43 3a 20 32 2c 30 2c 36 00              +CLCC: 2,0,6.

00002e12 <__c.6089>:
    2e12:	2b 43 4c 43 43 3a 20 31 2c 30 2c 36 00              +CLCC: 1,0,6.

00002e1f <__c.6087>:
    2e1f:	2b 44 54 4d 46 3a 20 31 00                          +DTMF: 1.

00002e28 <__c.6084>:
    2e28:	2b 43 52 45 43 3a 20 30 00                          +CREC: 0.

00002e31 <__c.6080>:
    2e31:	41 54 2b 43 52 45 43 3d 34 2c 22 43 3a 5c 55 73     AT+CREC=4,"C:\Us
    2e41:	65 72 5c 43 6f 6e 66 69 72 6d 52 65 71 75 65 73     er\ConfirmReques
    2e51:	74 2e 61 6d 72 22 2c 30 2c 31 30 30 0d 00           t.amr",0,100..

00002e5f <__c.6077>:
    2e5f:	2b 43 52 45 43 3a 20 30 00                          +CREC: 0.

00002e68 <__c.6073>:
    2e68:	2e 61 6d 72 22 2c 30 2c 31 30 30 0d 00              .amr",0,100..

00002e75 <__c.6071>:
    2e75:	41 54 2b 43 52 45 43 3d 34 2c 22 43 3a 5c 55 73     AT+CREC=4,"C:\Us
    2e85:	65 72 5c 41 6c 61 72 6d 00                          er\Alarm.

00002e8e <__c.6068>:
    2e8e:	2b 43 4c 43 43 3a 20 31 2c 30 2c 36 2c 00           +CLCC: 1,0,6,.

00002e9c <__c.6066>:
    2e9c:	2b 43 4c 43 43 3a 20 31 2c 30 2c 36 2c 00           +CLCC: 1,0,6,.

00002eaa <__c.6064>:
    2eaa:	2b 43 4c 43 43 3a 20 31 2c 30 2c 36 2c 00           +CLCC: 1,0,6,.

00002eb8 <__c.6062>:
    2eb8:	2b 43 4c 43 43 3a 20 31 2c 30 2c 30 2c 00           +CLCC: 1,0,0,.

00002ec6 <__c.6060>:
    2ec6:	2b 43 4c 43 43 3a 20 31 2c 30 2c 30 2c 00           +CLCC: 1,0,0,.

00002ed4 <__c.6058>:
    2ed4:	2b 43 4c 43 43 3a 20 31 2c 30 2c 30 2c 00           +CLCC: 1,0,0,.

00002ee2 <__c.6055>:
    2ee2:	2b 43 4c 43 43 3a 20 33 2c 30 2c 33 2c 00           +CLCC: 3,0,3,.

00002ef0 <__c.6053>:
    2ef0:	2b 43 4c 43 43 3a 20 32 2c 30 2c 33 2c 00           +CLCC: 2,0,3,.

00002efe <__c.6051>:
    2efe:	2b 43 4c 43 43 3a 20 31 2c 30 2c 33 2c 00           +CLCC: 1,0,3,.

00002f0c <__c.6049>:
    2f0c:	2b 43 4c 43 43 3a 20 33 2c 30 2c 36 2c 00           +CLCC: 3,0,6,.

00002f1a <__c.6047>:
    2f1a:	2b 43 4c 43 43 3a 20 32 2c 30 2c 36 2c 00           +CLCC: 2,0,6,.

00002f28 <__c.6045>:
    2f28:	2b 43 4c 43 43 3a 20 31 2c 30 2c 36 2c 00           +CLCC: 1,0,6,.

00002f36 <__c.6042>:
    2f36:	2b 43 4c 43 43 3a 20 33 2c 30 2c 32 2c 00           +CLCC: 3,0,2,.

00002f44 <__c.6040>:
    2f44:	2b 43 4c 43 43 3a 20 32 2c 30 2c 32 2c 00           +CLCC: 2,0,2,.

00002f52 <__c.6038>:
    2f52:	2b 43 4c 43 43 3a 20 31 2c 30 2c 32 2c 00           +CLCC: 1,0,2,.

00002f60 <__c.5999>:
    2f60:	2b 43 4c 43 43 3a 20 33 2c 30 2c 36 00              +CLCC: 3,0,6.

00002f6d <__c.5997>:
    2f6d:	2b 43 4c 43 43 3a 20 32 2c 30 2c 36 00              +CLCC: 2,0,6.

00002f7a <__c.5995>:
    2f7a:	2b 43 4c 43 43 3a 20 31 2c 30 2c 36 00              +CLCC: 1,0,6.

00002f87 <__c.5993>:
    2f87:	2b 44 54 4d 46 3a 20 31 00                          +DTMF: 1.

00002f90 <MB_Port>:
    2f90:	ce 00 c8 00 c9 00 ca 00 cd 00 cc 00 10 1f 16 1f     ................
    2fa0:	1a 1f 1b 1f                                         ....

00002fa4 <MB_Role>:
	...

00002fa5 <MB_Timer>:
    2fa5:	46 00 47 00 15 29 b2 00 b3 00 1f 29 a4 00 a8 00     F.G..).....)....
    2fb5:	2b 29                                               +)

00002fb7 <CGRAM_LCD>:
    2fb7:	00 04 06 1f 06 04 00 00 06 09 09 06 00 00 00 00     ................
    2fc7:	00 08 08 0e 0f 1f 0f 06 00 00 0e 11 1c 11 0e 00     ................
    2fd7:	0e 11 10 1c 10 11 0e 00 0a 00 0c 04 04 04 0e 00     ................
    2fe7:	0a 0e 04 04 04 04 0e 00 00 00 00 00 00 00 00 00     ................

00002ff7 <Win2LCD>:
    2ff7:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    3007:	00 02 ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    3017:	20 21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f      !"#$%&'()*+,-./
    3027:	30 31 32 33 34 35 36 37 38 39 3a 3b 3c 3d 3e 3f     0123456789:;<=>?
    3037:	40 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e 4f     @ABCDEFGHIJKLMNO
    3047:	50 51 52 53 54 55 56 57 58 59 5a 5b 5c 5d 5e 5f     PQRSTUVWXYZ[\]^_
    3057:	60 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e 6f     `abcdefghijklmno
    3067:	70 71 72 73 74 75 76 77 78 79 7a 7b 01 7d e9 7f     pqrstuvwxyz{.}..
    3077:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    3087:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    3097:	ff ff ff ff ff ff ff d9 a2 ff 04 ff ff ff ff 06     ................
    30a7:	ff ff 49 69 ff ff ff da b5 ff 03 ff ff ff ff 05     ..Ii............
    30b7:	41 a0 42 a1 e0 45 a3 a4 a5 a6 4b a7 4d 48 4f a8     A.B..E....K.MHO.
    30c7:	50 43 54 a9 aa 58 e1 ab ac e2 ad ae 62 af b0 b1     PCT..X......b...
    30d7:	61 b2 b3 b4 e3 65 b6 b7 b8 b9 ba bb bc bd 6f be     a....e........o.
    30e7:	70 63 bf 79 e4 78 e5 c0 c1 e6 c2 c3 c4 c5 c6 c7     pc.y.x..........

000030f7 <LineAddr.3690>:
    30f7:	80 c0 94 d4                                         ....

000030fb <Mux>:
    30fb:	00 01 02 03 04 05 06                                .......

00003102 <aCRCLo.1496>:
    3102:	00 c0 c1 01 c3 03 02 c2 c6 06 07 c7 05 c5 c4 04     ................
    3112:	cc 0c 0d cd 0f cf ce 0e 0a ca cb 0b c9 09 08 c8     ................
    3122:	d8 18 19 d9 1b db da 1a 1e de df 1f dd 1d 1c dc     ................
    3132:	14 d4 d5 15 d7 17 16 d6 d2 12 13 d3 11 d1 d0 10     ................
    3142:	f0 30 31 f1 33 f3 f2 32 36 f6 f7 37 f5 35 34 f4     .01.3..26..7.54.
    3152:	3c fc fd 3d ff 3f 3e fe fa 3a 3b fb 39 f9 f8 38     <..=.?>..:;.9..8
    3162:	28 e8 e9 29 eb 2b 2a ea ee 2e 2f ef 2d ed ec 2c     (..).+*.../.-..,
    3172:	e4 24 25 e5 27 e7 e6 26 22 e2 e3 23 e1 21 20 e0     .$%.'..&"..#.! .
    3182:	a0 60 61 a1 63 a3 a2 62 66 a6 a7 67 a5 65 64 a4     .`a.c..bf..g.ed.
    3192:	6c ac ad 6d af 6f 6e ae aa 6a 6b ab 69 a9 a8 68     l..m.on..jk.i..h
    31a2:	78 b8 b9 79 bb 7b 7a ba be 7e 7f bf 7d bd bc 7c     x..y.{z..~..}..|
    31b2:	b4 74 75 b5 77 b7 b6 76 72 b2 b3 73 b1 71 70 b0     .tu.w..vr..s.qp.
    31c2:	50 90 91 51 93 53 52 92 96 56 57 97 55 95 94 54     P..Q.SR..VW.U..T
    31d2:	9c 5c 5d 9d 5f 9f 9e 5e 5a 9a 9b 5b 99 59 58 98     .\]._..^Z..[.YX.
    31e2:	88 48 49 89 4b 8b 8a 4a 4e 8e 8f 4f 8d 4d 4c 8c     .HI.K..JN..O.ML.
    31f2:	44 84 85 45 87 47 46 86 82 42 43 83 41 81 80 40     D..E.GF..BC.A..@

00003202 <aCRCHi.1495>:
    3202:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    3212:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    3222:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    3232:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    3242:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    3252:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    3262:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    3272:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    3282:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    3292:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    32a2:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    32b2:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    32c2:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    32d2:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    32e2:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    32f2:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    3302:	00 40 7a 10 f3 5a 00 a0 72 4e 18 09 00 10 a5 d4     .@z..Z..rN......
    3312:	e8 00 00 e8 76 48 17 00 00 e4 0b 54 02 00 00 ca     ....vH.....T....
    3322:	9a 3b 00 00 00 e1 f5 05 00 00 80 96 98 00 00 00     .;..............
    3332:	40 42 0f 00 00 00 a0 86 01 00 00 00 10 27 00 00     @B...........'..
    3342:	00 00 e8 03 00 00 00 00 64 00 00 00 00 00 0a 00     ........d.......
    3352:	00 00 00 00 01 00 00 00 00 00 2c 76 d8 88 dc 67     ..........,v...g
    3362:	4f 08 23 df c1 df ae 59 e1 b1 b7 96 e5 e3 e4 53     O.#....Y.......S
    3372:	c6 3a e6 51 99 76 96 e8 e6 c2 84 26 eb 89 8c 9b     .:.Q.v.....&....
    3382:	62 ed 40 7c 6f fc ef bc 9c 9f 40 f2 ba a5 6f a5     b.@|o.....@...o.
    3392:	f4 90 05 5a 2a f7 5c 93 6b 6c f9 67 6d c1 1b fc     ...Z*.\.kl.gm...
    33a2:	e0 e4 0d 47 fe f5 20 e6 b5 00 d0 ed 90 2e 03 00     ...G.. .........
    33b2:	94 35 77 05 00 80 84 1e 08 00 00 20 4e 0a 00 00     .5w........ N...
    33c2:	00 c8 0c 33 33 33 33 0f 98 6e 12 83 11 41 ef 8d     ...3333..n...A..
    33d2:	21 14 89 3b e6 55 16 cf fe e6 db 18 d1 84 4b 38     !..;.U........K8
    33e2:	1b f7 7c 1d 90 1d a4 bb e4 24 20 32 84 72 5e 22     ..|......$ 2.r^"
    33f2:	81 00 c9 f1 24 ec a1 e5 3d 27                       ....$...='

000033fc <__ctors_end>:
    33fc:	11 24       	eor	r1, r1
    33fe:	1f be       	out	0x3f, r1	; 63
    3400:	cf ef       	ldi	r28, 0xFF	; 255
    3402:	d1 e2       	ldi	r29, 0x21	; 33
    3404:	de bf       	out	0x3e, r29	; 62
    3406:	cd bf       	out	0x3d, r28	; 61
    3408:	00 e0       	ldi	r16, 0x00	; 0
    340a:	0c bf       	out	0x3c, r16	; 60

0000340c <__do_copy_data>:
    340c:	12 e0       	ldi	r17, 0x02	; 2
    340e:	a0 e0       	ldi	r26, 0x00	; 0
    3410:	b2 e0       	ldi	r27, 0x02	; 2
    3412:	e8 ec       	ldi	r30, 0xC8	; 200
    3414:	f9 e0       	ldi	r31, 0x09	; 9
    3416:	01 e0       	ldi	r16, 0x01	; 1
    3418:	0b bf       	out	0x3b, r16	; 59
    341a:	02 c0       	rjmp	.+4      	; 0x3420 <__do_copy_data+0x14>
    341c:	07 90       	elpm	r0, Z+
    341e:	0d 92       	st	X+, r0
    3420:	aa 3d       	cpi	r26, 0xDA	; 218
    3422:	b1 07       	cpc	r27, r17
    3424:	d9 f7       	brne	.-10     	; 0x341c <__do_copy_data+0x10>

00003426 <__do_clear_bss>:
    3426:	1c e0       	ldi	r17, 0x0C	; 12
    3428:	aa ed       	ldi	r26, 0xDA	; 218
    342a:	b2 e0       	ldi	r27, 0x02	; 2
    342c:	01 c0       	rjmp	.+2      	; 0x3430 <.do_clear_bss_start>

0000342e <.do_clear_bss_loop>:
    342e:	1d 92       	st	X+, r1

00003430 <.do_clear_bss_start>:
    3430:	a3 37       	cpi	r26, 0x73	; 115
    3432:	b1 07       	cpc	r27, r17
    3434:	e1 f7       	brne	.-8      	; 0x342e <.do_clear_bss_loop>
    3436:	0e 94 15 76 	call	0xec2a	; 0xec2a <main>
    343a:	0c 94 f7 7f 	jmp	0xffee	; 0xffee <exit>

0000343e <__bad_interrupt>:
    343e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00003442 <rrb>:
#include <stdint.h>

// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
rrb(const uint8_t *addr)
{
    3442:	fc 01       	movw	r30, r24
	return *addr;
}
    3444:	80 81       	ld	r24, Z
    3446:	08 95       	ret

00003448 <prb>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    3448:	fc 01       	movw	r30, r24
    344a:	84 91       	lpm	r24, Z+
}
    344c:	08 95       	ret

0000344e <prw>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    344e:	fc 01       	movw	r30, r24
    3450:	25 91       	lpm	r18, Z+
    3452:	34 91       	lpm	r19, Z+
}
    3454:	c9 01       	movw	r24, r18
    3456:	08 95       	ret

00003458 <prd>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    3458:	fc 01       	movw	r30, r24
    345a:	25 91       	lpm	r18, Z+
    345c:	35 91       	lpm	r19, Z+
    345e:	45 91       	lpm	r20, Z+
    3460:	54 91       	lpm	r21, Z+
}
    3462:	b9 01       	movw	r22, r18
    3464:	ca 01       	movw	r24, r20
    3466:	08 95       	ret

00003468 <prb_f>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#if FLASHEND>0xFFFF
uint8_t
prb_f(const prog_uint8_t *addr)
{
	return pgm_read_byte_far((uint16_t)addr+0x10000);
    3468:	a0 e0       	ldi	r26, 0x00	; 0
    346a:	b0 e0       	ldi	r27, 0x00	; 0
    346c:	80 50       	subi	r24, 0x00	; 0
    346e:	90 40       	sbci	r25, 0x00	; 0
    3470:	af 4f       	sbci	r26, 0xFF	; 255
    3472:	bf 4f       	sbci	r27, 0xFF	; 255
}
    3474:	ab bf       	out	0x3b, r26	; 59
    3476:	fc 01       	movw	r30, r24
    3478:	87 91       	elpm	r24, Z+
    347a:	08 95       	ret

0000347c <prc>:

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    347c:	fc 01       	movw	r30, r24
    347e:	84 91       	lpm	r24, Z+
}
    3480:	08 95       	ret

00003482 <prp>:

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    3482:	fc 01       	movw	r30, r24
    3484:	25 91       	lpm	r18, Z+
    3486:	34 91       	lpm	r19, Z+
}
    3488:	c9 01       	movw	r24, r18
    348a:	08 95       	ret

0000348c <CRC_Seed>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
CRC_Seed(uint8_t (*GetByte)(const uint8_t*), const uint8_t *Block, uint32_t Sz, uint16_t Seed)
{
    348c:	6f 92       	push	r6
    348e:	7f 92       	push	r7
    3490:	8f 92       	push	r8
    3492:	9f 92       	push	r9
    3494:	af 92       	push	r10
    3496:	bf 92       	push	r11
    3498:	cf 92       	push	r12
    349a:	df 92       	push	r13
    349c:	ef 92       	push	r14
    349e:	ff 92       	push	r15
    34a0:	0f 93       	push	r16
    34a2:	1f 93       	push	r17
    34a4:	cf 93       	push	r28
    34a6:	df 93       	push	r29
    34a8:	3c 01       	movw	r6, r24
    34aa:	eb 01       	movw	r28, r22
    34ac:	49 01       	movw	r8, r18
    34ae:	5a 01       	movw	r10, r20
    34b0:	c1 2e       	mov	r12, r17
		0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54,
		0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98,
		0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
		0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 0x40
	};
	uint8_t CRCHi=Seed>>8, CRCLo=Seed;
    34b2:	d0 2e       	mov	r13, r16
	for (uint32_t i=0; i<Sz; i++) {
    34b4:	21 15       	cp	r18, r1
    34b6:	31 05       	cpc	r19, r1
    34b8:	41 05       	cpc	r20, r1
    34ba:	51 05       	cpc	r21, r1
    34bc:	f9 f0       	breq	.+62     	; 0x34fc <CRC_Seed+0x70>
    34be:	ee 24       	eor	r14, r14
    34c0:	ff 24       	eor	r15, r15
    34c2:	87 01       	movw	r16, r14
		uint8_t j = CRCLo^GetByte(Block+i);
    34c4:	ce 01       	movw	r24, r28
    34c6:	8e 0d       	add	r24, r14
    34c8:	9f 1d       	adc	r25, r15
    34ca:	f3 01       	movw	r30, r6
    34cc:	19 95       	eicall
		CRCLo = CRCHi^prb(aCRCHi+j);
    34ce:	d8 26       	eor	r13, r24
    34d0:	2d 2d       	mov	r18, r13
    34d2:	30 e0       	ldi	r19, 0x00	; 0

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    34d4:	c9 01       	movw	r24, r18
    34d6:	8e 5f       	subi	r24, 0xFE	; 254
    34d8:	9d 4c       	sbci	r25, 0xCD	; 205
    34da:	fc 01       	movw	r30, r24
    34dc:	d4 90       	lpm	r13, Z+
		0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 0x40
	};
	uint8_t CRCHi=Seed>>8, CRCLo=Seed;
	for (uint32_t i=0; i<Sz; i++) {
		uint8_t j = CRCLo^GetByte(Block+i);
		CRCLo = CRCHi^prb(aCRCHi+j);
    34de:	dc 24       	eor	r13, r12

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    34e0:	2e 5f       	subi	r18, 0xFE	; 254
    34e2:	3e 4c       	sbci	r19, 0xCE	; 206
    34e4:	f9 01       	movw	r30, r18
    34e6:	c4 90       	lpm	r12, Z+
		0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98,
		0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
		0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 0x40
	};
	uint8_t CRCHi=Seed>>8, CRCLo=Seed;
	for (uint32_t i=0; i<Sz; i++) {
    34e8:	08 94       	sec
    34ea:	e1 1c       	adc	r14, r1
    34ec:	f1 1c       	adc	r15, r1
    34ee:	01 1d       	adc	r16, r1
    34f0:	11 1d       	adc	r17, r1
    34f2:	e8 14       	cp	r14, r8
    34f4:	f9 04       	cpc	r15, r9
    34f6:	0a 05       	cpc	r16, r10
    34f8:	1b 05       	cpc	r17, r11
    34fa:	20 f3       	brcs	.-56     	; 0x34c4 <CRC_Seed+0x38>
    34fc:	9c 2d       	mov	r25, r12
    34fe:	80 e0       	ldi	r24, 0x00	; 0
    3500:	2d 2d       	mov	r18, r13
    3502:	30 e0       	ldi	r19, 0x00	; 0
    3504:	28 2b       	or	r18, r24
    3506:	39 2b       	or	r19, r25
		uint8_t j = CRCLo^GetByte(Block+i);
		CRCLo = CRCHi^prb(aCRCHi+j);
		CRCHi = prb(aCRCLo+j);
	}
	return CRCHi<<8|CRCLo;
}
    3508:	c9 01       	movw	r24, r18
    350a:	df 91       	pop	r29
    350c:	cf 91       	pop	r28
    350e:	1f 91       	pop	r17
    3510:	0f 91       	pop	r16
    3512:	ff 90       	pop	r15
    3514:	ef 90       	pop	r14
    3516:	df 90       	pop	r13
    3518:	cf 90       	pop	r12
    351a:	bf 90       	pop	r11
    351c:	af 90       	pop	r10
    351e:	9f 90       	pop	r9
    3520:	8f 90       	pop	r8
    3522:	7f 90       	pop	r7
    3524:	6f 90       	pop	r6
    3526:	08 95       	ret

00003528 <CRC>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
CRC(uint8_t (*GetByte)(const uint8_t*), const uint8_t *Block, uint32_t Sz)
{
    3528:	0f 93       	push	r16
    352a:	1f 93       	push	r17
	return CRC_Seed(GetByte, Block, Sz, 0xFFFF);
    352c:	0f ef       	ldi	r16, 0xFF	; 255
    352e:	1f ef       	ldi	r17, 0xFF	; 255
    3530:	0e 94 46 1a 	call	0x348c	; 0x348c <CRC_Seed>
}
    3534:	1f 91       	pop	r17
    3536:	0f 91       	pop	r16
    3538:	08 95       	ret

0000353a <CRC_Flash_calc>:

// ~~~~~~~~~~~~~~~~~
static uint16_t
CRC_Flash_calc(void)
{
    353a:	0f 93       	push	r16
    353c:	1f 93       	push	r17
	#if FLASHEND<0xFFFF
		return CRC(prb, NULL, (uint32_t)FLASHEND+1);
	#else
		return CRC_Seed(prb_f, NULL, FLASHEND-0xFFFF, CRC(prb, NULL, 0x10000));
    353e:	84 e2       	ldi	r24, 0x24	; 36
    3540:	9a e1       	ldi	r25, 0x1A	; 26
    3542:	60 e0       	ldi	r22, 0x00	; 0
    3544:	70 e0       	ldi	r23, 0x00	; 0
    3546:	20 e0       	ldi	r18, 0x00	; 0
    3548:	30 e0       	ldi	r19, 0x00	; 0
    354a:	41 e0       	ldi	r20, 0x01	; 1
    354c:	50 e0       	ldi	r21, 0x00	; 0
    354e:	0e 94 94 1a 	call	0x3528	; 0x3528 <CRC>
    3552:	8c 01       	movw	r16, r24
    3554:	84 e3       	ldi	r24, 0x34	; 52
    3556:	9a e1       	ldi	r25, 0x1A	; 26
    3558:	60 e0       	ldi	r22, 0x00	; 0
    355a:	70 e0       	ldi	r23, 0x00	; 0
    355c:	20 e0       	ldi	r18, 0x00	; 0
    355e:	30 e0       	ldi	r19, 0x00	; 0
    3560:	43 e0       	ldi	r20, 0x03	; 3
    3562:	50 e0       	ldi	r21, 0x00	; 0
    3564:	0e 94 46 1a 	call	0x348c	; 0x348c <CRC_Seed>
	#endif
}
    3568:	1f 91       	pop	r17
    356a:	0f 91       	pop	r16
    356c:	08 95       	ret

0000356e <CRC_EEPROM_calc>:

// ~~~~~~~~~~~~~~~~~~
static uint16_t
CRC_EEPROM_calc(void)
{
    356e:	cf 92       	push	r12
    3570:	df 92       	push	r13
    3572:	ef 92       	push	r14
    3574:	ff 92       	push	r15
    3576:	0f 93       	push	r16
    3578:	1f 93       	push	r17
	return
    357a:	94 ee       	ldi	r25, 0xE4	; 228
    357c:	c9 2e       	mov	r12, r25
    357e:	9f e4       	ldi	r25, 0x4F	; 79
    3580:	d9 2e       	mov	r13, r25
    3582:	88 e9       	ldi	r24, 0x98	; 152
    3584:	e8 2e       	mov	r14, r24
    3586:	81 e0       	ldi	r24, 0x01	; 1
    3588:	f8 2e       	mov	r15, r24
    358a:	97 01       	movw	r18, r14
    358c:	40 e0       	ldi	r20, 0x00	; 0
    358e:	50 e0       	ldi	r21, 0x00	; 0
    3590:	c6 01       	movw	r24, r12
    3592:	60 e0       	ldi	r22, 0x00	; 0
    3594:	70 e0       	ldi	r23, 0x00	; 0
    3596:	0e 94 94 1a 	call	0x3528	; 0x3528 <CRC>
    359a:	8c 01       	movw	r16, r24
    359c:	2b ef       	ldi	r18, 0xFB	; 251
    359e:	3f e0       	ldi	r19, 0x0F	; 15
    35a0:	2e 19       	sub	r18, r14
    35a2:	3f 09       	sbc	r19, r15
    35a4:	40 e0       	ldi	r20, 0x00	; 0
    35a6:	50 e0       	ldi	r21, 0x00	; 0
    35a8:	c6 01       	movw	r24, r12
    35aa:	65 e0       	ldi	r22, 0x05	; 5
    35ac:	70 e0       	ldi	r23, 0x00	; 0
    35ae:	e6 0e       	add	r14, r22
    35b0:	f7 1e       	adc	r15, r23
    35b2:	b7 01       	movw	r22, r14
    35b4:	0e 94 46 1a 	call	0x348c	; 0x348c <CRC_Seed>
		CRC_Seed(erb, (uint8_t*)&MemCheck_stor+sizeof(MemCheck_stor), E2END-((uint16_t)&MemCheck_stor-1)-sizeof(MemCheck_stor),
			CRC(erb, NULL, (uint16_t)&MemCheck_stor));
}
    35b8:	1f 91       	pop	r17
    35ba:	0f 91       	pop	r16
    35bc:	ff 90       	pop	r15
    35be:	ef 90       	pop	r14
    35c0:	df 90       	pop	r13
    35c2:	cf 90       	pop	r12
    35c4:	08 95       	ret

000035c6 <InterruInit>:
InterruInit(void)
{
	#ifdef PMIC
		PMIC.CTRL = (uint8_t)(~PMIC_RREN_bm &~PMIC_IVSEL_bm) |PMIC_HILVLEN_bm |PMIC_MEDLVLEN_bm |PMIC_LOLVLEN_bm;
	#endif
	sei();
    35c6:	78 94       	sei
}
    35c8:	08 95       	ret

000035ca <IntOff>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    35ca:	8f b7       	in	r24, 0x3f	; 63
    35cc:	80 78       	andi	r24, 0x80	; 128
    35ce:	80 93 ee 02 	sts	0x02EE, r24
	cli();
    35d2:	f8 94       	cli
	return interru_enub_flg;
}
    35d4:	08 95       	ret

000035d6 <IntOn>:

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    35d6:	80 91 ee 02 	lds	r24, 0x02EE
    35da:	88 23       	and	r24, r24
    35dc:	09 f0       	breq	.+2      	; 0x35e0 <IntOn+0xa>
		sei();
    35de:	78 94       	sei
	return interru_enub_flg;
}
    35e0:	08 95       	ret

000035e2 <WdtOn>:

// ~~~~~~~~
void
WdtOn(void)
{
	wdt_reset();
    35e2:	a8 95       	wdr
	wdt_enable(WDTO_2S);
    35e4:	2f e0       	ldi	r18, 0x0F	; 15
    35e6:	88 e1       	ldi	r24, 0x18	; 24
    35e8:	90 e0       	ldi	r25, 0x00	; 0
    35ea:	0f b6       	in	r0, 0x3f	; 63
    35ec:	f8 94       	cli
    35ee:	a8 95       	wdr
    35f0:	80 93 60 00 	sts	0x0060, r24
    35f4:	0f be       	out	0x3f, r0	; 63
    35f6:	20 93 60 00 	sts	0x0060, r18
}
    35fa:	08 95       	ret

000035fc <Timer8_ISR_Alloc>:

// ~~~~~~~~~~~~~~
uint8_t
Timer8_ISR_Alloc(void)
{
	uint8_t N = VacantTimer8_ISR;
    35fc:	80 91 da 02 	lds	r24, 0x02DA
	VacantTimer8_ISR++;
    3600:	8f 5f       	subi	r24, 0xFF	; 255
    3602:	80 93 da 02 	sts	0x02DA, r24
    3606:	81 50       	subi	r24, 0x01	; 1
	return N;
}
    3608:	08 95       	ret

0000360a <Timer8Alloc>:

uint8_t
Timer8Alloc(void)
{
	uint8_t N = VacantTimer8;
    360a:	80 91 cc 02 	lds	r24, 0x02CC
	VacantTimer8++;
    360e:	8f 5f       	subi	r24, 0xFF	; 255
    3610:	80 93 cc 02 	sts	0x02CC, r24
    3614:	81 50       	subi	r24, 0x01	; 1
	return N;
}
    3616:	08 95       	ret

00003618 <Timer16Alloc>:

// ~~~~~~~~~~~~~~~
uint8_t
Timer16Alloc(void)
{
	uint8_t N = VacantTimer16;
    3618:	80 91 cd 02 	lds	r24, 0x02CD
	VacantTimer16++;
    361c:	8f 5f       	subi	r24, 0xFF	; 255
    361e:	80 93 cd 02 	sts	0x02CD, r24
    3622:	81 50       	subi	r24, 0x01	; 1
	return N;
}
    3624:	08 95       	ret

00003626 <Timer32Alloc>:

// ~~~~~~~~~~~~~~~
uint8_t
Timer32Alloc(void)
{
	uint8_t N = VacantTimer32;
    3626:	80 91 ce 02 	lds	r24, 0x02CE
	VacantTimer32++;
    362a:	8f 5f       	subi	r24, 0xFF	; 255
    362c:	80 93 ce 02 	sts	0x02CE, r24
    3630:	81 50       	subi	r24, 0x01	; 1
	return N;
}
    3632:	08 95       	ret

00003634 <Timer8_ISR_AppAlloc>:
// ~~~~~~~~~~~~~~

uint8_t
Timer8_ISR_AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    3634:	88 23       	and	r24, r24
    3636:	39 f0       	breq	.+14     	; 0x3646 <Timer8_ISR_AppAlloc+0x12>
	uint8_t N = VacantTimer8_ISR;
    3638:	90 91 da 02 	lds	r25, 0x02DA
	VacantTimer8_ISR+=n;
    363c:	89 0f       	add	r24, r25
    363e:	80 93 da 02 	sts	0x02DA, r24
	return N;
}
    3642:	89 2f       	mov	r24, r25
    3644:	08 95       	ret
// ~~~~~~~~~~~~~~

uint8_t
Timer8_ISR_AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    3646:	90 e0       	ldi	r25, 0x00	; 0
	uint8_t N = VacantTimer8_ISR;
	VacantTimer8_ISR+=n;
	return N;
}
    3648:	89 2f       	mov	r24, r25
    364a:	08 95       	ret

0000364c <Timer8AppAlloc>:

uint8_t
Timer8AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    364c:	88 23       	and	r24, r24
    364e:	39 f0       	breq	.+14     	; 0x365e <Timer8AppAlloc+0x12>
	uint8_t N = VacantTimer8;
    3650:	90 91 cc 02 	lds	r25, 0x02CC
	VacantTimer8+=n;
    3654:	89 0f       	add	r24, r25
    3656:	80 93 cc 02 	sts	0x02CC, r24
	return N;
}
    365a:	89 2f       	mov	r24, r25
    365c:	08 95       	ret
}

uint8_t
Timer8AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    365e:	90 e0       	ldi	r25, 0x00	; 0
	uint8_t N = VacantTimer8;
	VacantTimer8+=n;
	return N;
}
    3660:	89 2f       	mov	r24, r25
    3662:	08 95       	ret

00003664 <Timer16AppAlloc>:

// ~~~~~~~~~~~~~~~
uint8_t
Timer16AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    3664:	88 23       	and	r24, r24
    3666:	39 f0       	breq	.+14     	; 0x3676 <Timer16AppAlloc+0x12>
	uint8_t N = VacantTimer16;
    3668:	90 91 cd 02 	lds	r25, 0x02CD
	VacantTimer16+=n;
    366c:	89 0f       	add	r24, r25
    366e:	80 93 cd 02 	sts	0x02CD, r24
	return N;
}
    3672:	89 2f       	mov	r24, r25
    3674:	08 95       	ret

// ~~~~~~~~~~~~~~~
uint8_t
Timer16AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    3676:	90 e0       	ldi	r25, 0x00	; 0
	uint8_t N = VacantTimer16;
	VacantTimer16+=n;
	return N;
}
    3678:	89 2f       	mov	r24, r25
    367a:	08 95       	ret

0000367c <Timer32AppAlloc>:

// ~~~~~~~~~~~~~~~
uint8_t
Timer32AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    367c:	88 23       	and	r24, r24
    367e:	39 f0       	breq	.+14     	; 0x368e <Timer32AppAlloc+0x12>
	uint8_t N = VacantTimer32;
    3680:	90 91 ce 02 	lds	r25, 0x02CE
	VacantTimer32+=n;
    3684:	89 0f       	add	r24, r25
    3686:	80 93 ce 02 	sts	0x02CE, r24
	return N;
}
    368a:	89 2f       	mov	r24, r25
    368c:	08 95       	ret

// ~~~~~~~~~~~~~~~
uint8_t
Timer32AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    368e:	90 e0       	ldi	r25, 0x00	; 0
	uint8_t N = VacantTimer32;
	VacantTimer32+=n;
	return N;
}
    3690:	89 2f       	mov	r24, r25
    3692:	08 95       	ret

00003694 <Timer8_ISR_SysAlloc>:

// ~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer8_ISR_SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys_ISR;
    3694:	90 91 db 02 	lds	r25, 0x02DB
	VacantTimer8Sys_ISR += n;
    3698:	89 0f       	add	r24, r25
    369a:	80 93 db 02 	sts	0x02DB, r24
	return N;
}
    369e:	89 2f       	mov	r24, r25
    36a0:	08 95       	ret

000036a2 <Timer8SysAlloc>:

uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    36a2:	90 91 cf 02 	lds	r25, 0x02CF
	VacantTimer8Sys += n;
    36a6:	89 0f       	add	r24, r25
    36a8:	80 93 cf 02 	sts	0x02CF, r24
	return N;
}
    36ac:	89 2f       	mov	r24, r25
    36ae:	08 95       	ret

000036b0 <Timer16SysAlloc>:

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    36b0:	90 91 d0 02 	lds	r25, 0x02D0
	VacantTimer16Sys += n;
    36b4:	89 0f       	add	r24, r25
    36b6:	80 93 d0 02 	sts	0x02D0, r24
	return N;
}
    36ba:	89 2f       	mov	r24, r25
    36bc:	08 95       	ret

000036be <Timer32SysAlloc>:

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer32SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer32Sys;
    36be:	90 91 d1 02 	lds	r25, 0x02D1
	VacantTimer32Sys += n;
    36c2:	89 0f       	add	r24, r25
    36c4:	80 93 d1 02 	sts	0x02D1, r24
	return N;
}
    36c8:	89 2f       	mov	r24, r25
    36ca:	08 95       	ret

000036cc <StartTimer8_ISR>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
StartTimer8_ISR(uint8_t TimerN, uint8_t Timeout)
{
    36cc:	98 2f       	mov	r25, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    36ce:	3f b7       	in	r19, 0x3f	; 63
    36d0:	30 78       	andi	r19, 0x80	; 128
    36d2:	30 93 ee 02 	sts	0x02EE, r19
	cli();
    36d6:	f8 94       	cli
	IntOff();
	if ((Timer8_ISR[TimerN]=Timeout)>0)
    36d8:	48 2f       	mov	r20, r24
    36da:	50 e0       	ldi	r21, 0x00	; 0
    36dc:	fa 01       	movw	r30, r20
    36de:	e1 51       	subi	r30, 0x11	; 17
    36e0:	fd 4f       	sbci	r31, 0xFD	; 253
    36e2:	60 83       	st	Z, r22
    36e4:	80 81       	ld	r24, Z
    36e6:	88 23       	and	r24, r24
    36e8:	c1 f0       	breq	.+48     	; 0x371a <StartTimer8_ISR+0x4e>
		Timer8_ISR_Flg[TimerN/8] &=~(1<<TimerN%8);
    36ea:	96 95       	lsr	r25
    36ec:	96 95       	lsr	r25
    36ee:	96 95       	lsr	r25
    36f0:	e9 2f       	mov	r30, r25
    36f2:	f0 e0       	ldi	r31, 0x00	; 0
    36f4:	e1 55       	subi	r30, 0x51	; 81
    36f6:	fb 4f       	sbci	r31, 0xFB	; 251
    36f8:	20 81       	ld	r18, Z
    36fa:	47 70       	andi	r20, 0x07	; 7
    36fc:	50 70       	andi	r21, 0x00	; 0
    36fe:	81 e0       	ldi	r24, 0x01	; 1
    3700:	90 e0       	ldi	r25, 0x00	; 0
    3702:	02 c0       	rjmp	.+4      	; 0x3708 <StartTimer8_ISR+0x3c>
    3704:	88 0f       	add	r24, r24
    3706:	99 1f       	adc	r25, r25
    3708:	4a 95       	dec	r20
    370a:	e2 f7       	brpl	.-8      	; 0x3704 <StartTimer8_ISR+0x38>
    370c:	80 95       	com	r24
    370e:	82 23       	and	r24, r18
    3710:	80 83       	st	Z, r24

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3712:	33 23       	and	r19, r19
    3714:	09 f0       	breq	.+2      	; 0x3718 <StartTimer8_ISR+0x4c>
		sei();
    3716:	78 94       	sei
    3718:	08 95       	ret
	else
		Timer8_ISR_Flg[TimerN/8] |=(1<<TimerN%8);
    371a:	96 95       	lsr	r25
    371c:	96 95       	lsr	r25
    371e:	96 95       	lsr	r25
    3720:	e9 2f       	mov	r30, r25
    3722:	f0 e0       	ldi	r31, 0x00	; 0
    3724:	e1 55       	subi	r30, 0x51	; 81
    3726:	fb 4f       	sbci	r31, 0xFB	; 251
    3728:	20 81       	ld	r18, Z
    372a:	47 70       	andi	r20, 0x07	; 7
    372c:	50 70       	andi	r21, 0x00	; 0
    372e:	81 e0       	ldi	r24, 0x01	; 1
    3730:	90 e0       	ldi	r25, 0x00	; 0
    3732:	02 c0       	rjmp	.+4      	; 0x3738 <StartTimer8_ISR+0x6c>
    3734:	88 0f       	add	r24, r24
    3736:	99 1f       	adc	r25, r25
    3738:	4a 95       	dec	r20
    373a:	e2 f7       	brpl	.-8      	; 0x3734 <StartTimer8_ISR+0x68>
    373c:	28 2b       	or	r18, r24
    373e:	20 83       	st	Z, r18
    3740:	e8 cf       	rjmp	.-48     	; 0x3712 <StartTimer8_ISR+0x46>

00003742 <StartTimer8>:
}


void
StartTimer8(uint8_t TimerN, uint8_t Timeout)
{
    3742:	98 2f       	mov	r25, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3744:	3f b7       	in	r19, 0x3f	; 63
    3746:	30 78       	andi	r19, 0x80	; 128
    3748:	30 93 ee 02 	sts	0x02EE, r19
	cli();
    374c:	f8 94       	cli
	IntOff();
	if ((Timer8[TimerN]=Timeout)>0)
    374e:	48 2f       	mov	r20, r24
    3750:	50 e0       	ldi	r21, 0x00	; 0
    3752:	fa 01       	movw	r30, r20
    3754:	e9 50       	subi	r30, 0x09	; 9
    3756:	fd 4f       	sbci	r31, 0xFD	; 253
    3758:	60 83       	st	Z, r22
    375a:	80 81       	ld	r24, Z
    375c:	88 23       	and	r24, r24
    375e:	c1 f0       	breq	.+48     	; 0x3790 <StartTimer8+0x4e>
		Timer8Flg[TimerN/8] &=~(1<<TimerN%8);
    3760:	96 95       	lsr	r25
    3762:	96 95       	lsr	r25
    3764:	96 95       	lsr	r25
    3766:	e9 2f       	mov	r30, r25
    3768:	f0 e0       	ldi	r31, 0x00	; 0
    376a:	ef 54       	subi	r30, 0x4F	; 79
    376c:	fb 4f       	sbci	r31, 0xFB	; 251
    376e:	20 81       	ld	r18, Z
    3770:	47 70       	andi	r20, 0x07	; 7
    3772:	50 70       	andi	r21, 0x00	; 0
    3774:	81 e0       	ldi	r24, 0x01	; 1
    3776:	90 e0       	ldi	r25, 0x00	; 0
    3778:	02 c0       	rjmp	.+4      	; 0x377e <StartTimer8+0x3c>
    377a:	88 0f       	add	r24, r24
    377c:	99 1f       	adc	r25, r25
    377e:	4a 95       	dec	r20
    3780:	e2 f7       	brpl	.-8      	; 0x377a <StartTimer8+0x38>
    3782:	80 95       	com	r24
    3784:	82 23       	and	r24, r18
    3786:	80 83       	st	Z, r24

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3788:	33 23       	and	r19, r19
    378a:	09 f0       	breq	.+2      	; 0x378e <StartTimer8+0x4c>
		sei();
    378c:	78 94       	sei
    378e:	08 95       	ret
	else
		Timer8Flg[TimerN/8] |=(1<<TimerN%8);
    3790:	96 95       	lsr	r25
    3792:	96 95       	lsr	r25
    3794:	96 95       	lsr	r25
    3796:	e9 2f       	mov	r30, r25
    3798:	f0 e0       	ldi	r31, 0x00	; 0
    379a:	ef 54       	subi	r30, 0x4F	; 79
    379c:	fb 4f       	sbci	r31, 0xFB	; 251
    379e:	20 81       	ld	r18, Z
    37a0:	47 70       	andi	r20, 0x07	; 7
    37a2:	50 70       	andi	r21, 0x00	; 0
    37a4:	81 e0       	ldi	r24, 0x01	; 1
    37a6:	90 e0       	ldi	r25, 0x00	; 0
    37a8:	02 c0       	rjmp	.+4      	; 0x37ae <StartTimer8+0x6c>
    37aa:	88 0f       	add	r24, r24
    37ac:	99 1f       	adc	r25, r25
    37ae:	4a 95       	dec	r20
    37b0:	e2 f7       	brpl	.-8      	; 0x37aa <StartTimer8+0x68>
    37b2:	28 2b       	or	r18, r24
    37b4:	20 83       	st	Z, r18
    37b6:	e8 cf       	rjmp	.-48     	; 0x3788 <StartTimer8+0x46>

000037b8 <StartTimer16>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
StartTimer16(uint8_t TimerN, uint16_t Timeout)
{
    37b8:	28 2f       	mov	r18, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    37ba:	3f b7       	in	r19, 0x3f	; 63
    37bc:	30 78       	andi	r19, 0x80	; 128
    37be:	30 93 ee 02 	sts	0x02EE, r19
	cli();
    37c2:	f8 94       	cli
	IntOff();
	if ((Timer16[TimerN]=Timeout)>0)
    37c4:	48 2f       	mov	r20, r24
    37c6:	50 e0       	ldi	r21, 0x00	; 0
    37c8:	fa 01       	movw	r30, r20
    37ca:	ee 0f       	add	r30, r30
    37cc:	ff 1f       	adc	r31, r31
    37ce:	e1 5b       	subi	r30, 0xB1	; 177
    37d0:	fc 4f       	sbci	r31, 0xFC	; 252
    37d2:	71 83       	std	Z+1, r23	; 0x01
    37d4:	60 83       	st	Z, r22
    37d6:	80 81       	ld	r24, Z
    37d8:	91 81       	ldd	r25, Z+1	; 0x01
    37da:	89 2b       	or	r24, r25
    37dc:	c1 f0       	breq	.+48     	; 0x380e <StartTimer16+0x56>
		Timer16Flg[TimerN/8] &=~(1<<TimerN%8);
    37de:	26 95       	lsr	r18
    37e0:	26 95       	lsr	r18
    37e2:	26 95       	lsr	r18
    37e4:	e2 2f       	mov	r30, r18
    37e6:	f0 e0       	ldi	r31, 0x00	; 0
    37e8:	e3 54       	subi	r30, 0x43	; 67
    37ea:	fb 4f       	sbci	r31, 0xFB	; 251
    37ec:	20 81       	ld	r18, Z
    37ee:	47 70       	andi	r20, 0x07	; 7
    37f0:	50 70       	andi	r21, 0x00	; 0
    37f2:	81 e0       	ldi	r24, 0x01	; 1
    37f4:	90 e0       	ldi	r25, 0x00	; 0
    37f6:	02 c0       	rjmp	.+4      	; 0x37fc <StartTimer16+0x44>
    37f8:	88 0f       	add	r24, r24
    37fa:	99 1f       	adc	r25, r25
    37fc:	4a 95       	dec	r20
    37fe:	e2 f7       	brpl	.-8      	; 0x37f8 <StartTimer16+0x40>
    3800:	80 95       	com	r24
    3802:	82 23       	and	r24, r18
    3804:	80 83       	st	Z, r24

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3806:	33 23       	and	r19, r19
    3808:	09 f0       	breq	.+2      	; 0x380c <StartTimer16+0x54>
		sei();
    380a:	78 94       	sei
    380c:	08 95       	ret
	else
		Timer16Flg[TimerN/8] |=(1<<TimerN%8);
    380e:	26 95       	lsr	r18
    3810:	26 95       	lsr	r18
    3812:	26 95       	lsr	r18
    3814:	e2 2f       	mov	r30, r18
    3816:	f0 e0       	ldi	r31, 0x00	; 0
    3818:	e3 54       	subi	r30, 0x43	; 67
    381a:	fb 4f       	sbci	r31, 0xFB	; 251
    381c:	20 81       	ld	r18, Z
    381e:	47 70       	andi	r20, 0x07	; 7
    3820:	50 70       	andi	r21, 0x00	; 0
    3822:	81 e0       	ldi	r24, 0x01	; 1
    3824:	90 e0       	ldi	r25, 0x00	; 0
    3826:	02 c0       	rjmp	.+4      	; 0x382c <StartTimer16+0x74>
    3828:	88 0f       	add	r24, r24
    382a:	99 1f       	adc	r25, r25
    382c:	4a 95       	dec	r20
    382e:	e2 f7       	brpl	.-8      	; 0x3828 <StartTimer16+0x70>
    3830:	28 2b       	or	r18, r24
    3832:	20 83       	st	Z, r18
    3834:	e8 cf       	rjmp	.-48     	; 0x3806 <StartTimer16+0x4e>

00003836 <StartTimer32>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
StartTimer32(uint8_t TimerN, uint32_t Timeout)
{
    3836:	cf 93       	push	r28
    3838:	df 93       	push	r29
    383a:	28 2f       	mov	r18, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    383c:	3f b7       	in	r19, 0x3f	; 63
    383e:	30 78       	andi	r19, 0x80	; 128
    3840:	30 93 ee 02 	sts	0x02EE, r19
	cli();
    3844:	f8 94       	cli
	IntOff();
	if ((Timer32[TimerN]=Timeout)>0)
    3846:	c8 2f       	mov	r28, r24
    3848:	d0 e0       	ldi	r29, 0x00	; 0
    384a:	fe 01       	movw	r30, r28
    384c:	ee 0f       	add	r30, r30
    384e:	ff 1f       	adc	r31, r31
    3850:	ee 0f       	add	r30, r30
    3852:	ff 1f       	adc	r31, r31
    3854:	e1 5f       	subi	r30, 0xF1	; 241
    3856:	fb 4f       	sbci	r31, 0xFB	; 251
    3858:	40 83       	st	Z, r20
    385a:	51 83       	std	Z+1, r21	; 0x01
    385c:	62 83       	std	Z+2, r22	; 0x02
    385e:	73 83       	std	Z+3, r23	; 0x03
    3860:	80 81       	ld	r24, Z
    3862:	91 81       	ldd	r25, Z+1	; 0x01
    3864:	a2 81       	ldd	r26, Z+2	; 0x02
    3866:	b3 81       	ldd	r27, Z+3	; 0x03
    3868:	00 97       	sbiw	r24, 0x00	; 0
    386a:	a1 05       	cpc	r26, r1
    386c:	b1 05       	cpc	r27, r1
    386e:	d1 f0       	breq	.+52     	; 0x38a4 <StartTimer32+0x6e>
		Timer32Flg[TimerN/8] &=~(1<<TimerN%8);
    3870:	26 95       	lsr	r18
    3872:	26 95       	lsr	r18
    3874:	26 95       	lsr	r18
    3876:	e2 2f       	mov	r30, r18
    3878:	f0 e0       	ldi	r31, 0x00	; 0
    387a:	e6 53       	subi	r30, 0x36	; 54
    387c:	fb 4f       	sbci	r31, 0xFB	; 251
    387e:	20 81       	ld	r18, Z
    3880:	c7 70       	andi	r28, 0x07	; 7
    3882:	d0 70       	andi	r29, 0x00	; 0
    3884:	81 e0       	ldi	r24, 0x01	; 1
    3886:	90 e0       	ldi	r25, 0x00	; 0
    3888:	02 c0       	rjmp	.+4      	; 0x388e <StartTimer32+0x58>
    388a:	88 0f       	add	r24, r24
    388c:	99 1f       	adc	r25, r25
    388e:	ca 95       	dec	r28
    3890:	e2 f7       	brpl	.-8      	; 0x388a <StartTimer32+0x54>
    3892:	80 95       	com	r24
    3894:	82 23       	and	r24, r18
    3896:	80 83       	st	Z, r24

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3898:	33 23       	and	r19, r19
    389a:	09 f0       	breq	.+2      	; 0x389e <StartTimer32+0x68>
		sei();
    389c:	78 94       	sei
	else
		Timer32Flg[TimerN/8] |=(1<<TimerN%8);
	IntOn();
}
    389e:	df 91       	pop	r29
    38a0:	cf 91       	pop	r28
    38a2:	08 95       	ret
{
	IntOff();
	if ((Timer32[TimerN]=Timeout)>0)
		Timer32Flg[TimerN/8] &=~(1<<TimerN%8);
	else
		Timer32Flg[TimerN/8] |=(1<<TimerN%8);
    38a4:	26 95       	lsr	r18
    38a6:	26 95       	lsr	r18
    38a8:	26 95       	lsr	r18
    38aa:	e2 2f       	mov	r30, r18
    38ac:	f0 e0       	ldi	r31, 0x00	; 0
    38ae:	e6 53       	subi	r30, 0x36	; 54
    38b0:	fb 4f       	sbci	r31, 0xFB	; 251
    38b2:	20 81       	ld	r18, Z
    38b4:	c7 70       	andi	r28, 0x07	; 7
    38b6:	d0 70       	andi	r29, 0x00	; 0
    38b8:	81 e0       	ldi	r24, 0x01	; 1
    38ba:	90 e0       	ldi	r25, 0x00	; 0
    38bc:	02 c0       	rjmp	.+4      	; 0x38c2 <StartTimer32+0x8c>
    38be:	88 0f       	add	r24, r24
    38c0:	99 1f       	adc	r25, r25
    38c2:	ca 95       	dec	r28
    38c4:	e2 f7       	brpl	.-8      	; 0x38be <StartTimer32+0x88>
    38c6:	28 2b       	or	r18, r24
    38c8:	20 83       	st	Z, r18
    38ca:	e6 cf       	rjmp	.-52     	; 0x3898 <StartTimer32+0x62>

000038cc <StopTimer8_ISR>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    38cc:	4f b7       	in	r20, 0x3f	; 63
    38ce:	40 78       	andi	r20, 0x80	; 128
    38d0:	40 93 ee 02 	sts	0x02EE, r20
	cli();
    38d4:	f8 94       	cli
// ~~~~~~~~~~~~~~~~~~~~~~~
void
StopTimer8_ISR(uint8_t TimerN)
{
	IntOff();
	Timer8_ISR_Flg[TimerN/8] |=(1<<TimerN%8);
    38d6:	e8 2f       	mov	r30, r24
    38d8:	e6 95       	lsr	r30
    38da:	e6 95       	lsr	r30
    38dc:	e6 95       	lsr	r30
    38de:	f0 e0       	ldi	r31, 0x00	; 0
    38e0:	e1 55       	subi	r30, 0x51	; 81
    38e2:	fb 4f       	sbci	r31, 0xFB	; 251
    38e4:	90 81       	ld	r25, Z
    38e6:	87 70       	andi	r24, 0x07	; 7
    38e8:	21 e0       	ldi	r18, 0x01	; 1
    38ea:	30 e0       	ldi	r19, 0x00	; 0
    38ec:	02 c0       	rjmp	.+4      	; 0x38f2 <StopTimer8_ISR+0x26>
    38ee:	22 0f       	add	r18, r18
    38f0:	33 1f       	adc	r19, r19
    38f2:	8a 95       	dec	r24
    38f4:	e2 f7       	brpl	.-8      	; 0x38ee <StopTimer8_ISR+0x22>
    38f6:	92 2b       	or	r25, r18
    38f8:	90 83       	st	Z, r25

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    38fa:	44 23       	and	r20, r20
    38fc:	09 f0       	breq	.+2      	; 0x3900 <StopTimer8_ISR+0x34>
		sei();
    38fe:	78 94       	sei
    3900:	08 95       	ret

00003902 <StopTimer8>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3902:	4f b7       	in	r20, 0x3f	; 63
    3904:	40 78       	andi	r20, 0x80	; 128
    3906:	40 93 ee 02 	sts	0x02EE, r20
	cli();
    390a:	f8 94       	cli

void
StopTimer8(uint8_t TimerN)
{
	IntOff();
	Timer8Flg[TimerN/8] |=(1<<TimerN%8);
    390c:	e8 2f       	mov	r30, r24
    390e:	e6 95       	lsr	r30
    3910:	e6 95       	lsr	r30
    3912:	e6 95       	lsr	r30
    3914:	f0 e0       	ldi	r31, 0x00	; 0
    3916:	ef 54       	subi	r30, 0x4F	; 79
    3918:	fb 4f       	sbci	r31, 0xFB	; 251
    391a:	90 81       	ld	r25, Z
    391c:	87 70       	andi	r24, 0x07	; 7
    391e:	21 e0       	ldi	r18, 0x01	; 1
    3920:	30 e0       	ldi	r19, 0x00	; 0
    3922:	02 c0       	rjmp	.+4      	; 0x3928 <StopTimer8+0x26>
    3924:	22 0f       	add	r18, r18
    3926:	33 1f       	adc	r19, r19
    3928:	8a 95       	dec	r24
    392a:	e2 f7       	brpl	.-8      	; 0x3924 <StopTimer8+0x22>
    392c:	92 2b       	or	r25, r18
    392e:	90 83       	st	Z, r25

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3930:	44 23       	and	r20, r20
    3932:	09 f0       	breq	.+2      	; 0x3936 <StopTimer8+0x34>
		sei();
    3934:	78 94       	sei
    3936:	08 95       	ret

00003938 <StopTimer16>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3938:	4f b7       	in	r20, 0x3f	; 63
    393a:	40 78       	andi	r20, 0x80	; 128
    393c:	40 93 ee 02 	sts	0x02EE, r20
	cli();
    3940:	f8 94       	cli
// ~~~~~~~~~~~~~~~~~~~~~~~~
void
StopTimer16(uint8_t TimerN)
{
	IntOff();
	Timer16Flg[TimerN/8] |=1<<TimerN%8;
    3942:	e8 2f       	mov	r30, r24
    3944:	e6 95       	lsr	r30
    3946:	e6 95       	lsr	r30
    3948:	e6 95       	lsr	r30
    394a:	f0 e0       	ldi	r31, 0x00	; 0
    394c:	e3 54       	subi	r30, 0x43	; 67
    394e:	fb 4f       	sbci	r31, 0xFB	; 251
    3950:	90 81       	ld	r25, Z
    3952:	87 70       	andi	r24, 0x07	; 7
    3954:	21 e0       	ldi	r18, 0x01	; 1
    3956:	30 e0       	ldi	r19, 0x00	; 0
    3958:	02 c0       	rjmp	.+4      	; 0x395e <StopTimer16+0x26>
    395a:	22 0f       	add	r18, r18
    395c:	33 1f       	adc	r19, r19
    395e:	8a 95       	dec	r24
    3960:	e2 f7       	brpl	.-8      	; 0x395a <StopTimer16+0x22>
    3962:	92 2b       	or	r25, r18
    3964:	90 83       	st	Z, r25

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3966:	44 23       	and	r20, r20
    3968:	09 f0       	breq	.+2      	; 0x396c <StopTimer16+0x34>
		sei();
    396a:	78 94       	sei
    396c:	08 95       	ret

0000396e <StopTimer32>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    396e:	4f b7       	in	r20, 0x3f	; 63
    3970:	40 78       	andi	r20, 0x80	; 128
    3972:	40 93 ee 02 	sts	0x02EE, r20
	cli();
    3976:	f8 94       	cli
// ~~~~~~~~~~~~~~~~~~~~~~~~
void
StopTimer32(uint8_t TimerN)
{
	IntOff();
	Timer32Flg[TimerN/8] |=1<<TimerN%8;
    3978:	e8 2f       	mov	r30, r24
    397a:	e6 95       	lsr	r30
    397c:	e6 95       	lsr	r30
    397e:	e6 95       	lsr	r30
    3980:	f0 e0       	ldi	r31, 0x00	; 0
    3982:	e6 53       	subi	r30, 0x36	; 54
    3984:	fb 4f       	sbci	r31, 0xFB	; 251
    3986:	90 81       	ld	r25, Z
    3988:	87 70       	andi	r24, 0x07	; 7
    398a:	21 e0       	ldi	r18, 0x01	; 1
    398c:	30 e0       	ldi	r19, 0x00	; 0
    398e:	02 c0       	rjmp	.+4      	; 0x3994 <StopTimer32+0x26>
    3990:	22 0f       	add	r18, r18
    3992:	33 1f       	adc	r19, r19
    3994:	8a 95       	dec	r24
    3996:	e2 f7       	brpl	.-8      	; 0x3990 <StopTimer32+0x22>
    3998:	92 2b       	or	r25, r18
    399a:	90 83       	st	Z, r25

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    399c:	44 23       	and	r20, r20
    399e:	09 f0       	breq	.+2      	; 0x39a2 <StopTimer32+0x34>
		sei();
    39a0:	78 94       	sei
    39a2:	08 95       	ret

000039a4 <Timer8Stopp_ISR>:
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer8Stopp_ISR(uint8_t TimerN)
{
	return (Timer8_ISR_Flg[TimerN/8] &(1<<TimerN%8)) && Timer8_ISR[TimerN]==0;
    39a4:	e8 2f       	mov	r30, r24
    39a6:	e6 95       	lsr	r30
    39a8:	e6 95       	lsr	r30
    39aa:	e6 95       	lsr	r30
    39ac:	f0 e0       	ldi	r31, 0x00	; 0
    39ae:	e1 55       	subi	r30, 0x51	; 81
    39b0:	fb 4f       	sbci	r31, 0xFB	; 251
    39b2:	20 81       	ld	r18, Z
    39b4:	e8 2f       	mov	r30, r24
    39b6:	f0 e0       	ldi	r31, 0x00	; 0
    39b8:	30 e0       	ldi	r19, 0x00	; 0
    39ba:	cf 01       	movw	r24, r30
    39bc:	87 70       	andi	r24, 0x07	; 7
    39be:	90 70       	andi	r25, 0x00	; 0
    39c0:	02 c0       	rjmp	.+4      	; 0x39c6 <Timer8Stopp_ISR+0x22>
    39c2:	35 95       	asr	r19
    39c4:	27 95       	ror	r18
    39c6:	8a 95       	dec	r24
    39c8:	e2 f7       	brpl	.-8      	; 0x39c2 <Timer8Stopp_ISR+0x1e>
    39ca:	20 fd       	sbrc	r18, 0
    39cc:	02 c0       	rjmp	.+4      	; 0x39d2 <Timer8Stopp_ISR+0x2e>
    39ce:	80 e0       	ldi	r24, 0x00	; 0
    39d0:	08 95       	ret
    39d2:	e1 51       	subi	r30, 0x11	; 17
    39d4:	fd 4f       	sbci	r31, 0xFD	; 253
    39d6:	90 81       	ld	r25, Z
    39d8:	99 23       	and	r25, r25
    39da:	19 f4       	brne	.+6      	; 0x39e2 <Timer8Stopp_ISR+0x3e>
    39dc:	81 e0       	ldi	r24, 0x01	; 1
    39de:	89 27       	eor	r24, r25
}
    39e0:	08 95       	ret
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer8Stopp_ISR(uint8_t TimerN)
{
	return (Timer8_ISR_Flg[TimerN/8] &(1<<TimerN%8)) && Timer8_ISR[TimerN]==0;
    39e2:	91 e0       	ldi	r25, 0x01	; 1
    39e4:	81 e0       	ldi	r24, 0x01	; 1
    39e6:	89 27       	eor	r24, r25
}
    39e8:	08 95       	ret

000039ea <Timer8Stopp>:

// ~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer8Stopp(uint8_t TimerN)
{
	return (Timer8Flg[TimerN/8] &(1<<TimerN%8)) && Timer8[TimerN]==0;
    39ea:	e8 2f       	mov	r30, r24
    39ec:	e6 95       	lsr	r30
    39ee:	e6 95       	lsr	r30
    39f0:	e6 95       	lsr	r30
    39f2:	f0 e0       	ldi	r31, 0x00	; 0
    39f4:	ef 54       	subi	r30, 0x4F	; 79
    39f6:	fb 4f       	sbci	r31, 0xFB	; 251
    39f8:	20 81       	ld	r18, Z
    39fa:	e8 2f       	mov	r30, r24
    39fc:	f0 e0       	ldi	r31, 0x00	; 0
    39fe:	30 e0       	ldi	r19, 0x00	; 0
    3a00:	cf 01       	movw	r24, r30
    3a02:	87 70       	andi	r24, 0x07	; 7
    3a04:	90 70       	andi	r25, 0x00	; 0
    3a06:	02 c0       	rjmp	.+4      	; 0x3a0c <Timer8Stopp+0x22>
    3a08:	35 95       	asr	r19
    3a0a:	27 95       	ror	r18
    3a0c:	8a 95       	dec	r24
    3a0e:	e2 f7       	brpl	.-8      	; 0x3a08 <Timer8Stopp+0x1e>
    3a10:	20 fd       	sbrc	r18, 0
    3a12:	02 c0       	rjmp	.+4      	; 0x3a18 <Timer8Stopp+0x2e>
    3a14:	80 e0       	ldi	r24, 0x00	; 0
    3a16:	08 95       	ret
    3a18:	e9 50       	subi	r30, 0x09	; 9
    3a1a:	fd 4f       	sbci	r31, 0xFD	; 253
    3a1c:	90 81       	ld	r25, Z
    3a1e:	99 23       	and	r25, r25
    3a20:	19 f4       	brne	.+6      	; 0x3a28 <Timer8Stopp+0x3e>
    3a22:	81 e0       	ldi	r24, 0x01	; 1
    3a24:	89 27       	eor	r24, r25
}
    3a26:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer8Stopp(uint8_t TimerN)
{
	return (Timer8Flg[TimerN/8] &(1<<TimerN%8)) && Timer8[TimerN]==0;
    3a28:	91 e0       	ldi	r25, 0x01	; 1
    3a2a:	81 e0       	ldi	r24, 0x01	; 1
    3a2c:	89 27       	eor	r24, r25
}
    3a2e:	08 95       	ret

00003a30 <Timer16Stopp>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3a30:	4f b7       	in	r20, 0x3f	; 63
    3a32:	40 78       	andi	r20, 0x80	; 128
    3a34:	40 93 ee 02 	sts	0x02EE, r20
	cli();
    3a38:	f8 94       	cli
// ~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16Stopp(uint8_t TimerN)
{
	IntOff();
	uint8_t T_S = (Timer16Flg[TimerN/8] &(1<<TimerN%8)) && Timer16[TimerN]==0;
    3a3a:	e8 2f       	mov	r30, r24
    3a3c:	e6 95       	lsr	r30
    3a3e:	e6 95       	lsr	r30
    3a40:	e6 95       	lsr	r30
    3a42:	f0 e0       	ldi	r31, 0x00	; 0
    3a44:	e3 54       	subi	r30, 0x43	; 67
    3a46:	fb 4f       	sbci	r31, 0xFB	; 251
    3a48:	20 81       	ld	r18, Z
    3a4a:	e8 2f       	mov	r30, r24
    3a4c:	f0 e0       	ldi	r31, 0x00	; 0
    3a4e:	30 e0       	ldi	r19, 0x00	; 0
    3a50:	cf 01       	movw	r24, r30
    3a52:	87 70       	andi	r24, 0x07	; 7
    3a54:	90 70       	andi	r25, 0x00	; 0
    3a56:	02 c0       	rjmp	.+4      	; 0x3a5c <Timer16Stopp+0x2c>
    3a58:	35 95       	asr	r19
    3a5a:	27 95       	ror	r18
    3a5c:	8a 95       	dec	r24
    3a5e:	e2 f7       	brpl	.-8      	; 0x3a58 <Timer16Stopp+0x28>
    3a60:	20 fd       	sbrc	r18, 0
    3a62:	06 c0       	rjmp	.+12     	; 0x3a70 <Timer16Stopp+0x40>
    3a64:	20 e0       	ldi	r18, 0x00	; 0

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3a66:	44 23       	and	r20, r20
    3a68:	09 f0       	breq	.+2      	; 0x3a6c <Timer16Stopp+0x3c>
		sei();
    3a6a:	78 94       	sei
	IntOn();
	return T_S;
}
    3a6c:	82 2f       	mov	r24, r18
    3a6e:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16Stopp(uint8_t TimerN)
{
	IntOff();
	uint8_t T_S = (Timer16Flg[TimerN/8] &(1<<TimerN%8)) && Timer16[TimerN]==0;
    3a70:	ee 0f       	add	r30, r30
    3a72:	ff 1f       	adc	r31, r31
    3a74:	e1 5b       	subi	r30, 0xB1	; 177
    3a76:	fc 4f       	sbci	r31, 0xFC	; 252
    3a78:	80 81       	ld	r24, Z
    3a7a:	91 81       	ldd	r25, Z+1	; 0x01
    3a7c:	20 e0       	ldi	r18, 0x00	; 0
    3a7e:	89 2b       	or	r24, r25
    3a80:	19 f4       	brne	.+6      	; 0x3a88 <Timer16Stopp+0x58>
    3a82:	81 e0       	ldi	r24, 0x01	; 1
    3a84:	28 27       	eor	r18, r24
    3a86:	ef cf       	rjmp	.-34     	; 0x3a66 <Timer16Stopp+0x36>
    3a88:	21 e0       	ldi	r18, 0x01	; 1
    3a8a:	81 e0       	ldi	r24, 0x01	; 1
    3a8c:	28 27       	eor	r18, r24
    3a8e:	eb cf       	rjmp	.-42     	; 0x3a66 <Timer16Stopp+0x36>

00003a90 <Timer32Stopp>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3a90:	4f b7       	in	r20, 0x3f	; 63
    3a92:	40 78       	andi	r20, 0x80	; 128
    3a94:	40 93 ee 02 	sts	0x02EE, r20
	cli();
    3a98:	f8 94       	cli
// ~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer32Stopp(uint8_t TimerN)
{
	IntOff();
	uint8_t T_S = (Timer32Flg[TimerN/8] &(1<<TimerN%8)) && Timer32[TimerN]==0;
    3a9a:	e8 2f       	mov	r30, r24
    3a9c:	e6 95       	lsr	r30
    3a9e:	e6 95       	lsr	r30
    3aa0:	e6 95       	lsr	r30
    3aa2:	f0 e0       	ldi	r31, 0x00	; 0
    3aa4:	e6 53       	subi	r30, 0x36	; 54
    3aa6:	fb 4f       	sbci	r31, 0xFB	; 251
    3aa8:	20 81       	ld	r18, Z
    3aaa:	e8 2f       	mov	r30, r24
    3aac:	f0 e0       	ldi	r31, 0x00	; 0
    3aae:	30 e0       	ldi	r19, 0x00	; 0
    3ab0:	cf 01       	movw	r24, r30
    3ab2:	87 70       	andi	r24, 0x07	; 7
    3ab4:	90 70       	andi	r25, 0x00	; 0
    3ab6:	02 c0       	rjmp	.+4      	; 0x3abc <Timer32Stopp+0x2c>
    3ab8:	35 95       	asr	r19
    3aba:	27 95       	ror	r18
    3abc:	8a 95       	dec	r24
    3abe:	e2 f7       	brpl	.-8      	; 0x3ab8 <Timer32Stopp+0x28>
    3ac0:	20 fd       	sbrc	r18, 0
    3ac2:	06 c0       	rjmp	.+12     	; 0x3ad0 <Timer32Stopp+0x40>
    3ac4:	20 e0       	ldi	r18, 0x00	; 0

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3ac6:	44 23       	and	r20, r20
    3ac8:	09 f0       	breq	.+2      	; 0x3acc <Timer32Stopp+0x3c>
		sei();
    3aca:	78 94       	sei
	IntOn();
	return T_S;
}
    3acc:	82 2f       	mov	r24, r18
    3ace:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer32Stopp(uint8_t TimerN)
{
	IntOff();
	uint8_t T_S = (Timer32Flg[TimerN/8] &(1<<TimerN%8)) && Timer32[TimerN]==0;
    3ad0:	ee 0f       	add	r30, r30
    3ad2:	ff 1f       	adc	r31, r31
    3ad4:	ee 0f       	add	r30, r30
    3ad6:	ff 1f       	adc	r31, r31
    3ad8:	e1 5f       	subi	r30, 0xF1	; 241
    3ada:	fb 4f       	sbci	r31, 0xFB	; 251
    3adc:	80 81       	ld	r24, Z
    3ade:	91 81       	ldd	r25, Z+1	; 0x01
    3ae0:	a2 81       	ldd	r26, Z+2	; 0x02
    3ae2:	b3 81       	ldd	r27, Z+3	; 0x03
    3ae4:	20 e0       	ldi	r18, 0x00	; 0
    3ae6:	00 97       	sbiw	r24, 0x00	; 0
    3ae8:	a1 05       	cpc	r26, r1
    3aea:	b1 05       	cpc	r27, r1
    3aec:	19 f4       	brne	.+6      	; 0x3af4 <Timer32Stopp+0x64>
    3aee:	81 e0       	ldi	r24, 0x01	; 1
    3af0:	28 27       	eor	r18, r24
    3af2:	e9 cf       	rjmp	.-46     	; 0x3ac6 <Timer32Stopp+0x36>
    3af4:	21 e0       	ldi	r18, 0x01	; 1
    3af6:	81 e0       	ldi	r24, 0x01	; 1
    3af8:	28 27       	eor	r18, r24
    3afa:	e5 cf       	rjmp	.-54     	; 0x3ac6 <Timer32Stopp+0x36>

00003afc <ResetTimer8_ISR>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3afc:	5f b7       	in	r21, 0x3f	; 63
    3afe:	50 78       	andi	r21, 0x80	; 128
    3b00:	50 93 ee 02 	sts	0x02EE, r21
	cli();
    3b04:	f8 94       	cli
//~~~~~~~~~~~~~~~~~~~~~~~~~
void
ResetTimer8_ISR(uint8_t TimerN)
{
	IntOff();
	Timer8_ISR_Flg[TimerN/8] |=(1<<TimerN%8);
    3b06:	e8 2f       	mov	r30, r24
    3b08:	e6 95       	lsr	r30
    3b0a:	e6 95       	lsr	r30
    3b0c:	e6 95       	lsr	r30
    3b0e:	f0 e0       	ldi	r31, 0x00	; 0
    3b10:	e1 55       	subi	r30, 0x51	; 81
    3b12:	fb 4f       	sbci	r31, 0xFB	; 251
    3b14:	40 81       	ld	r20, Z
    3b16:	a8 2f       	mov	r26, r24
    3b18:	b0 e0       	ldi	r27, 0x00	; 0
    3b1a:	9d 01       	movw	r18, r26
    3b1c:	27 70       	andi	r18, 0x07	; 7
    3b1e:	30 70       	andi	r19, 0x00	; 0
    3b20:	81 e0       	ldi	r24, 0x01	; 1
    3b22:	90 e0       	ldi	r25, 0x00	; 0
    3b24:	02 c0       	rjmp	.+4      	; 0x3b2a <ResetTimer8_ISR+0x2e>
    3b26:	88 0f       	add	r24, r24
    3b28:	99 1f       	adc	r25, r25
    3b2a:	2a 95       	dec	r18
    3b2c:	e2 f7       	brpl	.-8      	; 0x3b26 <ResetTimer8_ISR+0x2a>
    3b2e:	48 2b       	or	r20, r24
    3b30:	40 83       	st	Z, r20

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3b32:	55 23       	and	r21, r21
    3b34:	09 f0       	breq	.+2      	; 0x3b38 <ResetTimer8_ISR+0x3c>
		sei();
    3b36:	78 94       	sei
	IntOn();
	Timer8_ISR[TimerN] = 0;
    3b38:	a1 51       	subi	r26, 0x11	; 17
    3b3a:	bd 4f       	sbci	r27, 0xFD	; 253
    3b3c:	1c 92       	st	X, r1
}
    3b3e:	08 95       	ret

00003b40 <ResetTimer8>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3b40:	5f b7       	in	r21, 0x3f	; 63
    3b42:	50 78       	andi	r21, 0x80	; 128
    3b44:	50 93 ee 02 	sts	0x02EE, r21
	cli();
    3b48:	f8 94       	cli

void
ResetTimer8(uint8_t TimerN)
{
	IntOff();
	Timer8Flg[TimerN/8] |=(1<<TimerN%8);
    3b4a:	e8 2f       	mov	r30, r24
    3b4c:	e6 95       	lsr	r30
    3b4e:	e6 95       	lsr	r30
    3b50:	e6 95       	lsr	r30
    3b52:	f0 e0       	ldi	r31, 0x00	; 0
    3b54:	ef 54       	subi	r30, 0x4F	; 79
    3b56:	fb 4f       	sbci	r31, 0xFB	; 251
    3b58:	40 81       	ld	r20, Z
    3b5a:	a8 2f       	mov	r26, r24
    3b5c:	b0 e0       	ldi	r27, 0x00	; 0
    3b5e:	9d 01       	movw	r18, r26
    3b60:	27 70       	andi	r18, 0x07	; 7
    3b62:	30 70       	andi	r19, 0x00	; 0
    3b64:	81 e0       	ldi	r24, 0x01	; 1
    3b66:	90 e0       	ldi	r25, 0x00	; 0
    3b68:	02 c0       	rjmp	.+4      	; 0x3b6e <ResetTimer8+0x2e>
    3b6a:	88 0f       	add	r24, r24
    3b6c:	99 1f       	adc	r25, r25
    3b6e:	2a 95       	dec	r18
    3b70:	e2 f7       	brpl	.-8      	; 0x3b6a <ResetTimer8+0x2a>
    3b72:	48 2b       	or	r20, r24
    3b74:	40 83       	st	Z, r20

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3b76:	55 23       	and	r21, r21
    3b78:	09 f0       	breq	.+2      	; 0x3b7c <ResetTimer8+0x3c>
		sei();
    3b7a:	78 94       	sei
	IntOn();
	Timer8[TimerN] = 0;
    3b7c:	a9 50       	subi	r26, 0x09	; 9
    3b7e:	bd 4f       	sbci	r27, 0xFD	; 253
    3b80:	1c 92       	st	X, r1
}
    3b82:	08 95       	ret

00003b84 <ResetTimer16>:

//~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ResetTimer16(uint8_t TimerN)
{
    3b84:	e8 2f       	mov	r30, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3b86:	5f b7       	in	r21, 0x3f	; 63
    3b88:	50 78       	andi	r21, 0x80	; 128
    3b8a:	50 93 ee 02 	sts	0x02EE, r21
	cli();
    3b8e:	f8 94       	cli
	IntOff();
	Timer16Flg[TimerN/8] |=1<<TimerN%8;
    3b90:	a8 2f       	mov	r26, r24
    3b92:	a6 95       	lsr	r26
    3b94:	a6 95       	lsr	r26
    3b96:	a6 95       	lsr	r26
    3b98:	b0 e0       	ldi	r27, 0x00	; 0
    3b9a:	a3 54       	subi	r26, 0x43	; 67
    3b9c:	bb 4f       	sbci	r27, 0xFB	; 251
    3b9e:	4c 91       	ld	r20, X
    3ba0:	f0 e0       	ldi	r31, 0x00	; 0
    3ba2:	9f 01       	movw	r18, r30
    3ba4:	27 70       	andi	r18, 0x07	; 7
    3ba6:	30 70       	andi	r19, 0x00	; 0
    3ba8:	81 e0       	ldi	r24, 0x01	; 1
    3baa:	90 e0       	ldi	r25, 0x00	; 0
    3bac:	02 c0       	rjmp	.+4      	; 0x3bb2 <ResetTimer16+0x2e>
    3bae:	88 0f       	add	r24, r24
    3bb0:	99 1f       	adc	r25, r25
    3bb2:	2a 95       	dec	r18
    3bb4:	e2 f7       	brpl	.-8      	; 0x3bae <ResetTimer16+0x2a>
    3bb6:	48 2b       	or	r20, r24
    3bb8:	4c 93       	st	X, r20
	Timer16[TimerN] = 0;
    3bba:	ee 0f       	add	r30, r30
    3bbc:	ff 1f       	adc	r31, r31
    3bbe:	e1 5b       	subi	r30, 0xB1	; 177
    3bc0:	fc 4f       	sbci	r31, 0xFC	; 252
    3bc2:	11 82       	std	Z+1, r1	; 0x01
    3bc4:	10 82       	st	Z, r1

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3bc6:	55 23       	and	r21, r21
    3bc8:	09 f0       	breq	.+2      	; 0x3bcc <ResetTimer16+0x48>
		sei();
    3bca:	78 94       	sei
    3bcc:	08 95       	ret

00003bce <ResetTimer32>:
}

//~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ResetTimer32(uint8_t TimerN)
{
    3bce:	e8 2f       	mov	r30, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3bd0:	5f b7       	in	r21, 0x3f	; 63
    3bd2:	50 78       	andi	r21, 0x80	; 128
    3bd4:	50 93 ee 02 	sts	0x02EE, r21
	cli();
    3bd8:	f8 94       	cli
	IntOff();
	Timer32Flg[TimerN/8] |=1<<TimerN%8;
    3bda:	a8 2f       	mov	r26, r24
    3bdc:	a6 95       	lsr	r26
    3bde:	a6 95       	lsr	r26
    3be0:	a6 95       	lsr	r26
    3be2:	b0 e0       	ldi	r27, 0x00	; 0
    3be4:	a6 53       	subi	r26, 0x36	; 54
    3be6:	bb 4f       	sbci	r27, 0xFB	; 251
    3be8:	4c 91       	ld	r20, X
    3bea:	f0 e0       	ldi	r31, 0x00	; 0
    3bec:	9f 01       	movw	r18, r30
    3bee:	27 70       	andi	r18, 0x07	; 7
    3bf0:	30 70       	andi	r19, 0x00	; 0
    3bf2:	81 e0       	ldi	r24, 0x01	; 1
    3bf4:	90 e0       	ldi	r25, 0x00	; 0
    3bf6:	02 c0       	rjmp	.+4      	; 0x3bfc <ResetTimer32+0x2e>
    3bf8:	88 0f       	add	r24, r24
    3bfa:	99 1f       	adc	r25, r25
    3bfc:	2a 95       	dec	r18
    3bfe:	e2 f7       	brpl	.-8      	; 0x3bf8 <ResetTimer32+0x2a>
    3c00:	48 2b       	or	r20, r24
    3c02:	4c 93       	st	X, r20
	Timer32[TimerN] = 0;
    3c04:	ee 0f       	add	r30, r30
    3c06:	ff 1f       	adc	r31, r31
    3c08:	ee 0f       	add	r30, r30
    3c0a:	ff 1f       	adc	r31, r31
    3c0c:	e1 5f       	subi	r30, 0xF1	; 241
    3c0e:	fb 4f       	sbci	r31, 0xFB	; 251
    3c10:	10 82       	st	Z, r1
    3c12:	11 82       	std	Z+1, r1	; 0x01
    3c14:	12 82       	std	Z+2, r1	; 0x02
    3c16:	13 82       	std	Z+3, r1	; 0x03

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3c18:	55 23       	and	r21, r21
    3c1a:	09 f0       	breq	.+2      	; 0x3c1e <ResetTimer32+0x50>
		sei();
    3c1c:	78 94       	sei
    3c1e:	08 95       	ret

00003c20 <GetTimer8_ISR>:

// ~~~~~~~~~~~~~~~~~~~~~~
uint8_t
GetTimer8_ISR(uint8_t TimerN)
{
	return Timer8_ISR[TimerN];
    3c20:	ef ee       	ldi	r30, 0xEF	; 239
    3c22:	f2 e0       	ldi	r31, 0x02	; 2
    3c24:	e8 0f       	add	r30, r24
    3c26:	f1 1d       	adc	r31, r1
    3c28:	80 81       	ld	r24, Z
}
    3c2a:	08 95       	ret

00003c2c <GetTimer8>:
uint8_t
GetTimer8(uint8_t TimerN)
{
	return Timer8[TimerN];
    3c2c:	e7 ef       	ldi	r30, 0xF7	; 247
    3c2e:	f2 e0       	ldi	r31, 0x02	; 2
    3c30:	e8 0f       	add	r30, r24
    3c32:	f1 1d       	adc	r31, r1
    3c34:	80 81       	ld	r24, Z
}
    3c36:	08 95       	ret

00003c38 <GetTimer16>:

// ~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
GetTimer16(uint8_t TimerN)
{
    3c38:	e8 2f       	mov	r30, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3c3a:	8f b7       	in	r24, 0x3f	; 63
    3c3c:	80 78       	andi	r24, 0x80	; 128
    3c3e:	80 93 ee 02 	sts	0x02EE, r24
	cli();
    3c42:	f8 94       	cli
	IntOff();
	uint16_t Time = Timer16[TimerN];
    3c44:	f0 e0       	ldi	r31, 0x00	; 0
    3c46:	ee 0f       	add	r30, r30
    3c48:	ff 1f       	adc	r31, r31
    3c4a:	e1 5b       	subi	r30, 0xB1	; 177
    3c4c:	fc 4f       	sbci	r31, 0xFC	; 252
    3c4e:	01 90       	ld	r0, Z+
    3c50:	f0 81       	ld	r31, Z
    3c52:	e0 2d       	mov	r30, r0

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3c54:	88 23       	and	r24, r24
    3c56:	09 f0       	breq	.+2      	; 0x3c5a <GetTimer16+0x22>
		sei();
    3c58:	78 94       	sei
	IntOn();
	return Time;
}
    3c5a:	cf 01       	movw	r24, r30
    3c5c:	08 95       	ret

00003c5e <GetTimer32>:

// ~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
GetTimer32(uint8_t TimerN)
{
    3c5e:	e8 2f       	mov	r30, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3c60:	8f b7       	in	r24, 0x3f	; 63
    3c62:	80 78       	andi	r24, 0x80	; 128
    3c64:	80 93 ee 02 	sts	0x02EE, r24
	cli();
    3c68:	f8 94       	cli
	IntOff();
	uint32_t Time = Timer32[TimerN];
    3c6a:	f0 e0       	ldi	r31, 0x00	; 0
    3c6c:	ee 0f       	add	r30, r30
    3c6e:	ff 1f       	adc	r31, r31
    3c70:	ee 0f       	add	r30, r30
    3c72:	ff 1f       	adc	r31, r31
    3c74:	e1 5f       	subi	r30, 0xF1	; 241
    3c76:	fb 4f       	sbci	r31, 0xFB	; 251
    3c78:	20 81       	ld	r18, Z
    3c7a:	31 81       	ldd	r19, Z+1	; 0x01
    3c7c:	42 81       	ldd	r20, Z+2	; 0x02
    3c7e:	53 81       	ldd	r21, Z+3	; 0x03

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3c80:	88 23       	and	r24, r24
    3c82:	09 f0       	breq	.+2      	; 0x3c86 <GetTimer32+0x28>
		sei();
    3c84:	78 94       	sei
	IntOn();
	return Time;
}
    3c86:	b9 01       	movw	r22, r18
    3c88:	ca 01       	movw	r24, r20
    3c8a:	08 95       	ret

00003c8c <TimerAllocError>:
// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t TimerAllocError(void){
	return ( (VacantTimer8Sys >=  Timer8TotNumber) || (VacantTimer16Sys >=  Timer16TotNumber) || (VacantTimer32Sys >=  Timer32TotNumber) ||
    3c8c:	80 91 cf 02 	lds	r24, 0x02CF
    3c90:	88 35       	cpi	r24, 0x58	; 88
    3c92:	a8 f4       	brcc	.+42     	; 0x3cbe <TimerAllocError+0x32>
    3c94:	80 91 d0 02 	lds	r24, 0x02D0
    3c98:	80 36       	cpi	r24, 0x60	; 96
    3c9a:	88 f4       	brcc	.+34     	; 0x3cbe <TimerAllocError+0x32>
    3c9c:	80 91 d1 02 	lds	r24, 0x02D1
    3ca0:	88 32       	cpi	r24, 0x28	; 40
    3ca2:	68 f4       	brcc	.+26     	; 0x3cbe <TimerAllocError+0x32>
    3ca4:	80 91 cc 02 	lds	r24, 0x02CC
    3ca8:	80 34       	cpi	r24, 0x40	; 64
    3caa:	48 f4       	brcc	.+18     	; 0x3cbe <TimerAllocError+0x32>
    3cac:	80 91 cd 02 	lds	r24, 0x02CD
    3cb0:	88 34       	cpi	r24, 0x48	; 72
    3cb2:	28 f4       	brcc	.+10     	; 0x3cbe <TimerAllocError+0x32>
    3cb4:	90 e0       	ldi	r25, 0x00	; 0
    3cb6:	80 91 ce 02 	lds	r24, 0x02CE
    3cba:	80 32       	cpi	r24, 0x20	; 32
    3cbc:	08 f0       	brcs	.+2      	; 0x3cc0 <TimerAllocError+0x34>
    3cbe:	91 e0       	ldi	r25, 0x01	; 1
		 Timer8AllocErr() || Timer16AllocErr() || Timer32AllocErr() );
}
    3cc0:	89 2f       	mov	r24, r25
    3cc2:	08 95       	ret

00003cc4 <ScanCycleInit>:
}

uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    3cc4:	80 91 cf 02 	lds	r24, 0x02CF
	VacantTimer8Sys += n;
    3cc8:	8f 5f       	subi	r24, 0xFF	; 255
    3cca:	80 93 cf 02 	sts	0x02CF, r24
    3cce:	81 50       	subi	r24, 0x01	; 1

// ~~~~~~~~~~~~~~~~
void
ScanCycleInit(void)
{
	TD_Scan = Timer8SysAlloc(1);
    3cd0:	80 93 d0 04 	sts	0x04D0, r24
	StartTimer8(TD_Scan, 0xFF);
    3cd4:	6f ef       	ldi	r22, 0xFF	; 255
    3cd6:	0e 94 a1 1b 	call	0x3742	; 0x3742 <StartTimer8>
}
    3cda:	08 95       	ret

00003cdc <__vector_17>:
#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
	ISR(TIMER1_COMPA_vect)
#elif defined (__AVR_ATxmega128A1__)
	ISR(TCC0_OVF_vect)
#endif
{
    3cdc:	1f 92       	push	r1
    3cde:	0f 92       	push	r0
    3ce0:	0f b6       	in	r0, 0x3f	; 63
    3ce2:	0f 92       	push	r0
    3ce4:	0b b6       	in	r0, 0x3b	; 59
    3ce6:	0f 92       	push	r0
    3ce8:	11 24       	eor	r1, r1
    3cea:	2f 93       	push	r18
    3cec:	4f 93       	push	r20
    3cee:	5f 93       	push	r21
    3cf0:	6f 93       	push	r22
    3cf2:	7f 93       	push	r23
    3cf4:	8f 93       	push	r24
    3cf6:	9f 93       	push	r25
    3cf8:	af 93       	push	r26
    3cfa:	bf 93       	push	r27
    3cfc:	ef 93       	push	r30
    3cfe:	ff 93       	push	r31
	TickCounter++;
    3d00:	80 91 d1 04 	lds	r24, 0x04D1
    3d04:	8f 5f       	subi	r24, 0xFF	; 255
    3d06:	80 93 d1 04 	sts	0x04D1, r24
    3d0a:	40 e0       	ldi	r20, 0x00	; 0
    3d0c:	50 e0       	ldi	r21, 0x00	; 0
	uint8_t i;
	for (i=0; i<Timer8_ISR_TotNumber; i++)
			if (!(Timer8_ISR_Flg[i/8] &(1<<i%8)) && --Timer8_ISR[i]==0)
				Timer8_ISR_Flg[i/8] |=(1<<i%8);
    3d0e:	a1 e0       	ldi	r26, 0x01	; 1
    3d10:	b0 e0       	ldi	r27, 0x00	; 0
#endif
{
	TickCounter++;
	uint8_t i;
	for (i=0; i<Timer8_ISR_TotNumber; i++)
			if (!(Timer8_ISR_Flg[i/8] &(1<<i%8)) && --Timer8_ISR[i]==0)
    3d12:	80 91 af 04 	lds	r24, 0x04AF
    3d16:	ba 01       	movw	r22, r20
    3d18:	67 70       	andi	r22, 0x07	; 7
    3d1a:	70 70       	andi	r23, 0x00	; 0
    3d1c:	90 e0       	ldi	r25, 0x00	; 0
    3d1e:	06 2e       	mov	r0, r22
    3d20:	02 c0       	rjmp	.+4      	; 0x3d26 <__vector_17+0x4a>
    3d22:	95 95       	asr	r25
    3d24:	87 95       	ror	r24
    3d26:	0a 94       	dec	r0
    3d28:	e2 f7       	brpl	.-8      	; 0x3d22 <__vector_17+0x46>
    3d2a:	80 fd       	sbrc	r24, 0
    3d2c:	14 c0       	rjmp	.+40     	; 0x3d56 <__vector_17+0x7a>
    3d2e:	fa 01       	movw	r30, r20
    3d30:	e1 51       	subi	r30, 0x11	; 17
    3d32:	fd 4f       	sbci	r31, 0xFD	; 253
    3d34:	80 81       	ld	r24, Z
    3d36:	81 50       	subi	r24, 0x01	; 1
    3d38:	80 83       	st	Z, r24
    3d3a:	80 81       	ld	r24, Z
    3d3c:	88 23       	and	r24, r24
    3d3e:	59 f4       	brne	.+22     	; 0x3d56 <__vector_17+0x7a>
				Timer8_ISR_Flg[i/8] |=(1<<i%8);
    3d40:	20 91 af 04 	lds	r18, 0x04AF
    3d44:	cd 01       	movw	r24, r26
    3d46:	02 c0       	rjmp	.+4      	; 0x3d4c <__vector_17+0x70>
    3d48:	88 0f       	add	r24, r24
    3d4a:	99 1f       	adc	r25, r25
    3d4c:	6a 95       	dec	r22
    3d4e:	e2 f7       	brpl	.-8      	; 0x3d48 <__vector_17+0x6c>
    3d50:	28 2b       	or	r18, r24
    3d52:	20 93 af 04 	sts	0x04AF, r18
    3d56:	4f 5f       	subi	r20, 0xFF	; 255
    3d58:	5f 4f       	sbci	r21, 0xFF	; 255
	ISR(TCC0_OVF_vect)
#endif
{
	TickCounter++;
	uint8_t i;
	for (i=0; i<Timer8_ISR_TotNumber; i++)
    3d5a:	48 30       	cpi	r20, 0x08	; 8
    3d5c:	51 05       	cpc	r21, r1
    3d5e:	c9 f6       	brne	.-78     	; 0x3d12 <__vector_17+0x36>
				Timer8_ISR_Flg[i/8] |=(1<<i%8);

	#ifdef HIGH_SPEED_COUNTER
		HSC_Process();
	#endif
}
    3d60:	ff 91       	pop	r31
    3d62:	ef 91       	pop	r30
    3d64:	bf 91       	pop	r27
    3d66:	af 91       	pop	r26
    3d68:	9f 91       	pop	r25
    3d6a:	8f 91       	pop	r24
    3d6c:	7f 91       	pop	r23
    3d6e:	6f 91       	pop	r22
    3d70:	5f 91       	pop	r21
    3d72:	4f 91       	pop	r20
    3d74:	2f 91       	pop	r18
    3d76:	0f 90       	pop	r0
    3d78:	0b be       	out	0x3b, r0	; 59
    3d7a:	0f 90       	pop	r0
    3d7c:	0f be       	out	0x3f, r0	; 63
    3d7e:	0f 90       	pop	r0
    3d80:	1f 90       	pop	r1
    3d82:	18 95       	reti

00003d84 <TimeCycle>:
// ~~~~~~~~~~~~
void
TimeCycle(void)
{
	// WDT
	wdt_reset();
    3d84:	a8 95       	wdr

	// Scan cycle
	ScanCount++;
    3d86:	80 91 b2 07 	lds	r24, 0x07B2
    3d8a:	90 91 b3 07 	lds	r25, 0x07B3
    3d8e:	01 96       	adiw	r24, 0x01	; 1
    3d90:	90 93 b3 07 	sts	0x07B3, r25
    3d94:	80 93 b2 07 	sts	0x07B2, r24
	if ((ScanCycle=0xFF-Timer8[TD_Scan])>MaxScanCycle)
    3d98:	90 91 d0 04 	lds	r25, 0x04D0
    3d9c:	e9 2f       	mov	r30, r25
    3d9e:	f0 e0       	ldi	r31, 0x00	; 0
    3da0:	e9 50       	subi	r30, 0x09	; 9
    3da2:	fd 4f       	sbci	r31, 0xFD	; 253
    3da4:	e0 81       	ld	r30, Z
    3da6:	e0 95       	com	r30
    3da8:	e0 93 ae 07 	sts	0x07AE, r30
    3dac:	80 91 b1 06 	lds	r24, 0x06B1
    3db0:	8e 17       	cp	r24, r30
    3db2:	10 f4       	brcc	.+4      	; 0x3db8 <TimeCycle+0x34>
		MaxScanCycle = ScanCycle;
    3db4:	e0 93 b1 06 	sts	0x06B1, r30
	StartTimer8(TD_Scan, 0xFF);
    3db8:	89 2f       	mov	r24, r25
    3dba:	6f ef       	ldi	r22, 0xFF	; 255
    3dbc:	0e 94 a1 1b 	call	0x3742	; 0x3742 <StartTimer8>
}
    3dc0:	08 95       	ret

00003dc2 <MaxScanCycle_Clear>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
void
MaxScanCycle_Clear(void)
{
	MaxScanCycle = 0;
    3dc2:	10 92 b1 06 	sts	0x06B1, r1
}
    3dc6:	08 95       	ret

00003dc8 <Delay_ms>:

// ~~~~~~~~~~~~~~~~~~~~
void
Delay_ms(uint8_t Delay)
{
	while (Delay--)
    3dc8:	88 23       	and	r24, r24
    3dca:	39 f0       	breq	.+14     	; 0x3dda <Delay_ms+0x12>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3dcc:	20 ea       	ldi	r18, 0xA0	; 160
    3dce:	3f e0       	ldi	r19, 0x0F	; 15
    3dd0:	f9 01       	movw	r30, r18
    3dd2:	31 97       	sbiw	r30, 0x01	; 1
    3dd4:	f1 f7       	brne	.-4      	; 0x3dd2 <Delay_ms+0xa>
    3dd6:	81 50       	subi	r24, 0x01	; 1
    3dd8:	d9 f7       	brne	.-10     	; 0x3dd0 <Delay_ms+0x8>
    3dda:	08 95       	ret

00003ddc <Delay_us>:
{
	/*uint8_t i;
	for(i=Delay/Delay_us_Max; i; i--)
		_delay_us(Delay_us_Max);*/
	//_delay_us(Delay%Delay_us_Max);
	Delay *= .8;	// By trial
    3ddc:	a0 e0       	ldi	r26, 0x00	; 0
    3dde:	b0 e0       	ldi	r27, 0x00	; 0
    3de0:	bc 01       	movw	r22, r24
    3de2:	cd 01       	movw	r24, r26
    3de4:	0e 94 06 7f 	call	0xfe0c	; 0xfe0c <__floatunsisf>
    3de8:	2d ec       	ldi	r18, 0xCD	; 205
    3dea:	3c ec       	ldi	r19, 0xCC	; 204
    3dec:	4c e4       	ldi	r20, 0x4C	; 76
    3dee:	5f e3       	ldi	r21, 0x3F	; 63
    3df0:	0e 94 43 7f 	call	0xfe86	; 0xfe86 <__mulsf3>
    3df4:	0e 94 db 83 	call	0x107b6	; 0x107b6 <__fixunssfsi>
    3df8:	cb 01       	movw	r24, r22
	while (Delay--)
    3dfa:	67 2b       	or	r22, r23
    3dfc:	31 f0       	breq	.+12     	; 0x3e0a <Delay_us+0x2e>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3dfe:	35 e0       	ldi	r19, 0x05	; 5
    3e00:	23 2f       	mov	r18, r19
    3e02:	2a 95       	dec	r18
    3e04:	f1 f7       	brne	.-4      	; 0x3e02 <Delay_us+0x26>
    3e06:	01 97       	sbiw	r24, 0x01	; 1
    3e08:	d9 f7       	brne	.-10     	; 0x3e00 <Delay_us+0x24>
    3e0a:	08 95       	ret

00003e0c <MB_PLC_Init>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#if defined vmd2_3
	void MB_PLC_Init(void)
	{
		// RS485
		DDRE |=(1<<PE2); PORTE &=~(1<<PE2);
    3e0c:	6a 9a       	sbi	0x0d, 2	; 13
    3e0e:	72 98       	cbi	0x0e, 2	; 14
		DDRD |=(1<<PD4); PORTD &=~(1<<PD4);
    3e10:	54 9a       	sbi	0x0a, 4	; 10
    3e12:	5c 98       	cbi	0x0b, 4	; 11
	#ifndef GSM
		DDRL |=(1<<PL5); PORTL &=~(1<<PL5);
	#endif
	}
    3e14:	08 95       	ret

00003e16 <RS485_0>:
	void RS485_0(void) {PORTE ^=(1<<PE2);}
    3e16:	8e b1       	in	r24, 0x0e	; 14
    3e18:	94 e0       	ldi	r25, 0x04	; 4
    3e1a:	89 27       	eor	r24, r25
    3e1c:	8e b9       	out	0x0e, r24	; 14
    3e1e:	08 95       	ret

00003e20 <RS485_1>:
	void RS485_1(void) {PORTD ^=(1<<PD4);}
    3e20:	8b b1       	in	r24, 0x0b	; 11
    3e22:	90 e1       	ldi	r25, 0x10	; 16
    3e24:	89 27       	eor	r24, r25
    3e26:	8b b9       	out	0x0b, r24	; 11
    3e28:	08 95       	ret

00003e2a <MB_LED0>:
	}
	void RS485_0(void) {PORTE ^=(1<<PE2);}
	void RS485_1(void) {PORTC ^=(1<<PC0);}
#endif

void MB_LED0(void) {}
    3e2a:	08 95       	ret

00003e2c <MB_LED1>:
void MB_LED1(void) {}
    3e2c:	08 95       	ret

00003e2e <MB_LED2>:
void MB_LED2(void) {}
    3e2e:	08 95       	ret

00003e30 <MB_LED_Err_On_0>:

void MB_LED_Err_On_0(void)	{}
    3e30:	08 95       	ret

00003e32 <MB_LED_Err_Off_0>:
void MB_LED_Err_Off_0(void)	{}
    3e32:	08 95       	ret

00003e34 <MB_LED_Err_On_1>:
void MB_LED_Err_On_1(void)	{}
    3e34:	08 95       	ret

00003e36 <MB_LED_Err_Off_1>:
void MB_LED_Err_Off_1(void)	{}	
    3e36:	08 95       	ret

00003e38 <MB_LED_Err_On_2>:
void MB_LED_Err_On_2(void)	{}
    3e38:	08 95       	ret

00003e3a <MB_LED_Err_Off_2>:
void MB_LED_Err_Off_2(void)	{}
    3e3a:	08 95       	ret

00003e3c <PWM_Init>:

// ~~~~~~~~~~~
void
PWM_Init(void)
{
	TCCR3A = (1<<COM3A1) | (0<<COM3A0) | (1<<COM3B1) | (0<<COM3B0) | (0<<COM3C1) | (0<<COM3C0) | (1<<WGM31) | (0<<WGM30);
    3e3c:	32 ea       	ldi	r19, 0xA2	; 162
    3e3e:	30 93 90 00 	sts	0x0090, r19
	TCCR3B = (0<<CS32) | (0<<CS31) | (1<<CS30) | (1<<WGM33) | (1<<WGM32);	// Fpwm = 244Hz
    3e42:	29 e1       	ldi	r18, 0x19	; 25
    3e44:	20 93 91 00 	sts	0x0091, r18
	ICR3 = PWM_PERIOD_TC3;
    3e48:	8f ef       	ldi	r24, 0xFF	; 255
    3e4a:	9f ef       	ldi	r25, 0xFF	; 255
    3e4c:	90 93 97 00 	sts	0x0097, r25
    3e50:	80 93 96 00 	sts	0x0096, r24
	DDRE |= (1<<PE3) | (1<<PE4);
    3e54:	8d b1       	in	r24, 0x0d	; 13
    3e56:	88 61       	ori	r24, 0x18	; 24
    3e58:	8d b9       	out	0x0d, r24	; 13

	TCCR5A = (1<<COM5A1) | (0<<COM5A0) | (1<<COM5B1) | (0<<COM5B0) | (0<<COM5C1) | (0<<COM5C0) | (1<<WGM51) | (0<<WGM50);
    3e5a:	30 93 20 01 	sts	0x0120, r19
	TCCR5B = (0<<CS52) | (0<<CS51) | (1<<CS50) | (1<<WGM53) | (1<<WGM52);	// Fpwm = 244Hz
    3e5e:	20 93 21 01 	sts	0x0121, r18
	ICR5 = PWM_PERIOD_TC5;
    3e62:	8e e7       	ldi	r24, 0x7E	; 126
    3e64:	9c e0       	ldi	r25, 0x0C	; 12
    3e66:	90 93 27 01 	sts	0x0127, r25
    3e6a:	80 93 26 01 	sts	0x0126, r24
	DDRL |= (1<<PL3) | (1<<PL4);
    3e6e:	ea e0       	ldi	r30, 0x0A	; 10
    3e70:	f1 e0       	ldi	r31, 0x01	; 1
    3e72:	80 81       	ld	r24, Z
    3e74:	88 61       	ori	r24, 0x18	; 24
    3e76:	80 83       	st	Z, r24
}
    3e78:	08 95       	ret

00003e7a <PWM_Out>:
void
PWM_Out(void)
{
	uint16_t Buf;

	Buf = Coef_AO_PWM_TC3*DAC_Output[0];
    3e7a:	60 91 d1 07 	lds	r22, 0x07D1
    3e7e:	70 91 d2 07 	lds	r23, 0x07D2
    3e82:	80 e0       	ldi	r24, 0x00	; 0
    3e84:	90 e0       	ldi	r25, 0x00	; 0
    3e86:	0e 94 06 7f 	call	0xfe0c	; 0xfe0c <__floatunsisf>
    3e8a:	28 e8       	ldi	r18, 0x88	; 136
    3e8c:	3f e1       	ldi	r19, 0x1F	; 31
    3e8e:	40 e8       	ldi	r20, 0x80	; 128
    3e90:	52 e4       	ldi	r21, 0x42	; 66
    3e92:	0e 94 43 7f 	call	0xfe86	; 0xfe86 <__mulsf3>
    3e96:	0e 94 db 83 	call	0x107b6	; 0x107b6 <__fixunssfsi>
    3e9a:	26 2f       	mov	r18, r22

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3e9c:	9f b7       	in	r25, 0x3f	; 63
	cli();
    3e9e:	f8 94       	cli
	IntOff();
	OCR3AH = Buf>>8;
    3ea0:	70 93 99 00 	sts	0x0099, r23
	OCR3AL = Buf;
    3ea4:	20 93 98 00 	sts	0x0098, r18

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3ea8:	97 ff       	sbrs	r25, 7
    3eaa:	01 c0       	rjmp	.+2      	; 0x3eae <PWM_Out+0x34>
		sei();
    3eac:	78 94       	sei
	IntOn();

	Buf = Coef_AO_PWM_TC3*DAC_Output[1];
    3eae:	60 91 d3 07 	lds	r22, 0x07D3
    3eb2:	70 91 d4 07 	lds	r23, 0x07D4
    3eb6:	80 e0       	ldi	r24, 0x00	; 0
    3eb8:	90 e0       	ldi	r25, 0x00	; 0
    3eba:	0e 94 06 7f 	call	0xfe0c	; 0xfe0c <__floatunsisf>
    3ebe:	28 e8       	ldi	r18, 0x88	; 136
    3ec0:	3f e1       	ldi	r19, 0x1F	; 31
    3ec2:	40 e8       	ldi	r20, 0x80	; 128
    3ec4:	52 e4       	ldi	r21, 0x42	; 66
    3ec6:	0e 94 43 7f 	call	0xfe86	; 0xfe86 <__mulsf3>
    3eca:	0e 94 db 83 	call	0x107b6	; 0x107b6 <__fixunssfsi>
    3ece:	26 2f       	mov	r18, r22

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3ed0:	9f b7       	in	r25, 0x3f	; 63
	cli();
    3ed2:	f8 94       	cli
	IntOff();
	OCR3BH = Buf>>8;
    3ed4:	70 93 9b 00 	sts	0x009B, r23
	OCR3BL = Buf;
    3ed8:	20 93 9a 00 	sts	0x009A, r18

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3edc:	97 ff       	sbrs	r25, 7
    3ede:	01 c0       	rjmp	.+2      	; 0x3ee2 <PWM_Out+0x68>
		sei();
    3ee0:	78 94       	sei
	IntOn();


	Buf = Coef_AO_PWM_TC5*DAC_Output[2];
    3ee2:	60 91 d5 07 	lds	r22, 0x07D5
    3ee6:	70 91 d6 07 	lds	r23, 0x07D6
    3eea:	80 e0       	ldi	r24, 0x00	; 0
    3eec:	90 e0       	ldi	r25, 0x00	; 0
    3eee:	0e 94 06 7f 	call	0xfe0c	; 0xfe0c <__floatunsisf>
    3ef2:	25 e0       	ldi	r18, 0x05	; 5
    3ef4:	32 e1       	ldi	r19, 0x12	; 18
    3ef6:	48 e4       	ldi	r20, 0x48	; 72
    3ef8:	50 e4       	ldi	r21, 0x40	; 64
    3efa:	0e 94 43 7f 	call	0xfe86	; 0xfe86 <__mulsf3>
    3efe:	0e 94 db 83 	call	0x107b6	; 0x107b6 <__fixunssfsi>
    3f02:	26 2f       	mov	r18, r22

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3f04:	9f b7       	in	r25, 0x3f	; 63
	cli();
    3f06:	f8 94       	cli
	IntOff();
	OCR5AH = Buf>>8;
    3f08:	70 93 29 01 	sts	0x0129, r23
	OCR5AL = Buf;
    3f0c:	20 93 28 01 	sts	0x0128, r18

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3f10:	97 ff       	sbrs	r25, 7
    3f12:	01 c0       	rjmp	.+2      	; 0x3f16 <PWM_Out+0x9c>
		sei();
    3f14:	78 94       	sei
	IntOn();

	Buf = Coef_AO_PWM_TC5*DAC_Output[3];
    3f16:	60 91 d7 07 	lds	r22, 0x07D7
    3f1a:	70 91 d8 07 	lds	r23, 0x07D8
    3f1e:	80 e0       	ldi	r24, 0x00	; 0
    3f20:	90 e0       	ldi	r25, 0x00	; 0
    3f22:	0e 94 06 7f 	call	0xfe0c	; 0xfe0c <__floatunsisf>
    3f26:	25 e0       	ldi	r18, 0x05	; 5
    3f28:	32 e1       	ldi	r19, 0x12	; 18
    3f2a:	48 e4       	ldi	r20, 0x48	; 72
    3f2c:	50 e4       	ldi	r21, 0x40	; 64
    3f2e:	0e 94 43 7f 	call	0xfe86	; 0xfe86 <__mulsf3>
    3f32:	0e 94 db 83 	call	0x107b6	; 0x107b6 <__fixunssfsi>
    3f36:	26 2f       	mov	r18, r22

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3f38:	8f b7       	in	r24, 0x3f	; 63
    3f3a:	80 78       	andi	r24, 0x80	; 128
    3f3c:	80 93 ee 02 	sts	0x02EE, r24
	cli();
    3f40:	f8 94       	cli
	IntOff();
	OCR5BH = Buf>>8;
    3f42:	70 93 2b 01 	sts	0x012B, r23
	OCR5BL = Buf;
    3f46:	20 93 2a 01 	sts	0x012A, r18

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3f4a:	88 23       	and	r24, r24
    3f4c:	09 f0       	breq	.+2      	; 0x3f50 <PWM_Out+0xd6>
		sei();
    3f4e:	78 94       	sei
    3f50:	08 95       	ret

00003f52 <ADC_In>:
}

// ~~~~~~~~~
uint8_t
ADC_In(void)
{
    3f52:	1f 93       	push	r17

// ~~~~~~~~~~~~~~~
inline static void
ADC_Select(void)
{
	SPCR |=(1<<CPOL);
    3f54:	8c b5       	in	r24, 0x2c	; 44
    3f56:	88 60       	ori	r24, 0x08	; 8
    3f58:	8c bd       	out	0x2c, r24	; 44
	#ifdef CS_ADC
		cli();
    3f5a:	f8 94       	cli
		PortCS_ADC &=~CS_ADC;
    3f5c:	80 91 02 01 	lds	r24, 0x0102
    3f60:	87 7f       	andi	r24, 0xF7	; 247
    3f62:	80 93 02 01 	sts	0x0102, r24
		sei();
    3f66:	78 94       	sei
ADC_In(void)
{
	uint8_t Chan = ADC_Reg;
	ADC_Select();

	switch(ADC_Phase) {
    3f68:	80 91 69 0b 	lds	r24, 0x0B69
    3f6c:	81 30       	cpi	r24, 0x01	; 1
    3f6e:	09 f4       	brne	.+2      	; 0x3f72 <ADC_In+0x20>
    3f70:	ec c0       	rjmp	.+472    	; 0x414a <ADC_In+0x1f8>
    3f72:	81 30       	cpi	r24, 0x01	; 1
    3f74:	30 f5       	brcc	.+76     	; 0x3fc2 <ADC_In+0x70>

// ~~~~~~~~~~~~~~~
inline static void
ADC_Rst(void)
{
	cli();
    3f76:	f8 94       	cli
	PortRESET_PER &=~RESET_PER;
    3f78:	80 91 02 01 	lds	r24, 0x0102
    3f7c:	8f 7e       	andi	r24, 0xEF	; 239
    3f7e:	80 93 02 01 	sts	0x0102, r24
	sei();
    3f82:	78 94       	sei
    3f84:	85 e0       	ldi	r24, 0x05	; 5
    3f86:	8a 95       	dec	r24
    3f88:	f1 f7       	brne	.-4      	; 0x3f86 <ADC_In+0x34>
	_delay_us(1);							// 100 ns needs
	cli();
    3f8a:	f8 94       	cli
	PortRESET_PER |=RESET_PER;
    3f8c:	80 91 02 01 	lds	r24, 0x0102
    3f90:	80 61       	ori	r24, 0x10	; 16
    3f92:	80 93 02 01 	sts	0x0102, r24
	sei();
    3f96:	78 94       	sei
	StartTimer8_ISR(TD_ADC, 4);		// 16 ms needs
    3f98:	80 91 39 07 	lds	r24, 0x0739
    3f9c:	64 e0       	ldi	r22, 0x04	; 4
	WaitSPI();
	SPDR = SR;
	WaitSPI();
	SPDR = SetpVal(CaliMode) &~ADC_FSYNC;
	WaitSPI();
	StartTimer8_ISR(TD_ADC, 36);
    3f9e:	0e 94 66 1b 	call	0x36cc	; 0x36cc <StartTimer8_ISR>
	ADC_Phase++;
    3fa2:	80 91 69 0b 	lds	r24, 0x0B69
    3fa6:	8f 5f       	subi	r24, 0xFF	; 255
    3fa8:	80 93 69 0b 	sts	0x0B69, r24
    3fac:	17 e0       	ldi	r17, 0x07	; 7
// ~~~~~~~~~~~~~~~
inline static void
ADC_Desel(void)
{
	#ifdef CS_ADC
		cli();
    3fae:	f8 94       	cli
		PortCS_ADC |=CS_ADC;
    3fb0:	80 91 02 01 	lds	r24, 0x0102
    3fb4:	88 60       	ori	r24, 0x08	; 8
    3fb6:	80 93 02 01 	sts	0x0102, r24
		sei();
    3fba:	78 94       	sei
			IntOn();
		}
	#endif

	return Chan;
}
    3fbc:	81 2f       	mov	r24, r17
    3fbe:	1f 91       	pop	r17
    3fc0:	08 95       	ret
ADC_In(void)
{
	uint8_t Chan = ADC_Reg;
	ADC_Select();

	switch(ADC_Phase) {
    3fc2:	82 30       	cpi	r24, 0x02	; 2
    3fc4:	09 f4       	brne	.+2      	; 0x3fc8 <ADC_In+0x76>
    3fc6:	d2 c0       	rjmp	.+420    	; 0x416c <ADC_In+0x21a>
    3fc8:	83 30       	cpi	r24, 0x03	; 3
    3fca:	11 f0       	breq	.+4      	; 0x3fd0 <ADC_In+0x7e>
				StartTimer8_ISR(TD_ADC, ADC10ms);
			}
		}
		else if(Timer8Stopp_ISR(TD_ADC)) {
			ADC_ReadFail++;
			ADC_Phase = RST;
    3fcc:	17 e0       	ldi	r17, 0x07	; 7
    3fce:	ef cf       	rjmp	.-34     	; 0x3fae <ADC_In+0x5c>
		default:
			SPDR = ADC_IN1(Reg);
			break;
		}
	#else
		SPDR = ADC_IN1(Reg);
    3fd0:	88 e0       	ldi	r24, 0x08	; 8
    3fd2:	8e bd       	out	0x2e, r24	; 46

// ~~~~~~~~~~~
static void
WaitADC2(void)
{
	WaitSPI();
    3fd4:	0d b4       	in	r0, 0x2d	; 45
    3fd6:	07 fe       	sbrs	r0, 7
    3fd8:	fd cf       	rjmp	.-6      	; 0x3fd4 <ADC_In+0x82>
	SPDR = 0;
    3fda:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    3fdc:	0d b4       	in	r0, 0x2d	; 45
    3fde:	07 fe       	sbrs	r0, 7
    3fe0:	fd cf       	rjmp	.-6      	; 0x3fdc <ADC_In+0x8a>
			StartTimer8_ISR(TD_ADC, ADC10ms);
		break;
	case READ:
		ADC_IN(CommReg);
		WaitADC2();
		if(!(SPDR &ADC_DRDY)) {
    3fe2:	0e b4       	in	r0, 0x2e	; 46
    3fe4:	07 fc       	sbrc	r0, 7
    3fe6:	da c0       	rjmp	.+436    	; 0x419c <ADC_In+0x24a>
		default:
			SPDR = ADC_IN1(Reg);
			break;
		}
	#else
		SPDR = ADC_IN1(Reg);
    3fe8:	88 e3       	ldi	r24, 0x38	; 56
    3fea:	8e bd       	out	0x2e, r24	; 46

// ~~~~~~~~~~~
static void
WaitADC2(void)
{
	WaitSPI();
    3fec:	0d b4       	in	r0, 0x2d	; 45
    3fee:	07 fe       	sbrs	r0, 7
    3ff0:	fd cf       	rjmp	.-6      	; 0x3fec <ADC_In+0x9a>
	SPDR = 0;
    3ff2:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    3ff4:	0d b4       	in	r0, 0x2d	; 45
    3ff6:	07 fe       	sbrs	r0, 7
    3ff8:	fd cf       	rjmp	.-6      	; 0x3ff4 <ADC_In+0xa2>
		WaitADC2();
		if(!(SPDR &ADC_DRDY)) {
			uint16_t Buf;
			ADC_IN(DataReg);
			WaitADC2();
			Buf = SPDR<<8;
    3ffa:	3e b5       	in	r19, 0x2e	; 46

// ~~~~~~~~~~~
static void
WaitADC1(void)
{
	SPDR = 0;
    3ffc:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    3ffe:	0d b4       	in	r0, 0x2d	; 45
    4000:	07 fe       	sbrs	r0, 7
    4002:	fd cf       	rjmp	.-6      	; 0x3ffe <ADC_In+0xac>
			uint16_t Buf;
			ADC_IN(DataReg);
			WaitADC2();
			Buf = SPDR<<8;
			WaitADC1();
			Buf += SPDR;
    4004:	2e b5       	in	r18, 0x2e	; 46
		WaitADC2();
		if(!(SPDR &ADC_DRDY)) {
			uint16_t Buf;
			ADC_IN(DataReg);
			WaitADC2();
			Buf = SPDR<<8;
    4006:	93 2f       	mov	r25, r19
    4008:	80 e0       	ldi	r24, 0x00	; 0
			WaitADC1();
			Buf += SPDR;
    400a:	ac 01       	movw	r20, r24
    400c:	42 0f       	add	r20, r18
    400e:	51 1d       	adc	r21, r1
    4010:	9a 01       	movw	r18, r20
			#ifdef ADC_Ref_Chan
				if (ADC_Chan==sizeof(Mux)-1 && ADC_Input[sizeof(Mux)-1]!=0 && (Buf<ADC_Ref-ADC_Ref_d || Buf>ADC_Ref+ADC_Ref_d)) {
    4012:	10 91 11 09 	lds	r17, 0x0911
    4016:	16 30       	cpi	r17, 0x06	; 6
    4018:	09 f4       	brne	.+2      	; 0x401c <ADC_In+0xca>
    401a:	19 c1       	rjmp	.+562    	; 0x424e <ADC_In+0x2fc>
		default:
			SPDR = ADC_IN1(Reg);
			break;
		}
	#else
		SPDR = ADC_IN1(Reg);
    401c:	80 e1       	ldi	r24, 0x10	; 16
    401e:	8e bd       	out	0x2e, r24	; 46
{
	Scale *Scl;
	int8_t i;

	ADC_IN(SetpReg);
	WaitSPI();
    4020:	0d b4       	in	r0, 0x2d	; 45
    4022:	07 fe       	sbrs	r0, 7
    4024:	fd cf       	rjmp	.-6      	; 0x4020 <ADC_In+0xce>
	SPDR = SetpVal(NormMode) |ADC_FSYNC;
    4026:	87 e0       	ldi	r24, 0x07	; 7
    4028:	8e bd       	out	0x2e, r24	; 46
	WaitSPI();
    402a:	0d b4       	in	r0, 0x2d	; 45
    402c:	07 fe       	sbrs	r0, 7
    402e:	fd cf       	rjmp	.-6      	; 0x402a <ADC_In+0xd8>
	ADC_Time = ADC10ms-Timer8_ISR[TD_ADC];
    4030:	40 91 39 07 	lds	r20, 0x0739
    4034:	e4 2f       	mov	r30, r20
    4036:	f0 e0       	ldi	r31, 0x00	; 0
    4038:	e1 51       	subi	r30, 0x11	; 17
    403a:	fd 4f       	sbci	r31, 0xFD	; 253
    403c:	90 81       	ld	r25, Z
    403e:	84 e1       	ldi	r24, 0x14	; 20
    4040:	89 1b       	sub	r24, r25
    4042:	80 93 b3 06 	sts	0x06B3, r24
		default:
			SPDR = ADC_IN1(Reg);
			break;
		}
	#else
		SPDR = ADC_IN1(Reg);
    4046:	88 e6       	ldi	r24, 0x68	; 104
    4048:	8e bd       	out	0x2e, r24	; 46

// ~~~~~~~~~~~
static void
WaitADC2(void)
{
	WaitSPI();
    404a:	0d b4       	in	r0, 0x2d	; 45
    404c:	07 fe       	sbrs	r0, 7
    404e:	fd cf       	rjmp	.-6      	; 0x404a <ADC_In+0xf8>
	SPDR = 0;
    4050:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    4052:	0d b4       	in	r0, 0x2d	; 45
    4054:	07 fe       	sbrs	r0, 7
    4056:	fd cf       	rjmp	.-6      	; 0x4052 <ADC_In+0x100>
    4058:	ee e6       	ldi	r30, 0x6E	; 110
    405a:	fc e0       	ldi	r31, 0x0C	; 12
		Scl=&ADC_Scale1;
	#endif
	ADC_IN(ZeroReg);
	WaitADC2();
	for(i=2; i>=0; i--) {
		Scl->Zero[i] = SPDR;
    405c:	8e b5       	in	r24, 0x2e	; 46
    405e:	80 83       	st	Z, r24

// ~~~~~~~~~~~
static void
WaitADC1(void)
{
	SPDR = 0;
    4060:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    4062:	0d b4       	in	r0, 0x2d	; 45
    4064:	07 fe       	sbrs	r0, 7
    4066:	fd cf       	rjmp	.-6      	; 0x4062 <ADC_In+0x110>
    4068:	31 97       	sbiw	r30, 0x01	; 1
	#else
		Scl=&ADC_Scale1;
	#endif
	ADC_IN(ZeroReg);
	WaitADC2();
	for(i=2; i>=0; i--) {
    406a:	8c e0       	ldi	r24, 0x0C	; 12
    406c:	eb 36       	cpi	r30, 0x6B	; 107
    406e:	f8 07       	cpc	r31, r24
    4070:	a9 f7       	brne	.-22     	; 0x405c <ADC_In+0x10a>

// ~~~~~~~~~~~
static void
WaitADC1(void)
{
	SPDR = 0;
    4072:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    4074:	0d b4       	in	r0, 0x2d	; 45
    4076:	07 fe       	sbrs	r0, 7
    4078:	fd cf       	rjmp	.-6      	; 0x4074 <ADC_In+0x122>
		default:
			SPDR = ADC_IN1(Reg);
			break;
		}
	#else
		SPDR = ADC_IN1(Reg);
    407a:	88 e7       	ldi	r24, 0x78	; 120
    407c:	8e bd       	out	0x2e, r24	; 46

// ~~~~~~~~~~~
static void
WaitADC2(void)
{
	WaitSPI();
    407e:	0d b4       	in	r0, 0x2d	; 45
    4080:	07 fe       	sbrs	r0, 7
    4082:	fd cf       	rjmp	.-6      	; 0x407e <ADC_In+0x12c>
	SPDR = 0;
    4084:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    4086:	0d b4       	in	r0, 0x2d	; 45
    4088:	07 fe       	sbrs	r0, 7
    408a:	fd cf       	rjmp	.-6      	; 0x4086 <ADC_In+0x134>
    408c:	e1 e7       	ldi	r30, 0x71	; 113
    408e:	fc e0       	ldi	r31, 0x0C	; 12
	}
	WaitADC1();
	ADC_IN(FullReg);
	WaitADC2();
	for(i=2; i>=0; i--) {
		Scl->Full[i] = SPDR;
    4090:	8e b5       	in	r24, 0x2e	; 46
    4092:	80 83       	st	Z, r24

// ~~~~~~~~~~~
static void
WaitADC1(void)
{
	SPDR = 0;
    4094:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    4096:	0d b4       	in	r0, 0x2d	; 45
    4098:	07 fe       	sbrs	r0, 7
    409a:	fd cf       	rjmp	.-6      	; 0x4096 <ADC_In+0x144>
    409c:	31 97       	sbiw	r30, 0x01	; 1
		WaitADC1();
	}
	WaitADC1();
	ADC_IN(FullReg);
	WaitADC2();
	for(i=2; i>=0; i--) {
    409e:	5c e0       	ldi	r21, 0x0C	; 12
    40a0:	ee 36       	cpi	r30, 0x6E	; 110
    40a2:	f5 07       	cpc	r31, r21
    40a4:	a9 f7       	brne	.-22     	; 0x4090 <ADC_In+0x13e>

// ~~~~~~~~~~~
static void
WaitADC1(void)
{
	SPDR = 0;
    40a6:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    40a8:	0d b4       	in	r0, 0x2d	; 45
    40aa:	07 fe       	sbrs	r0, 7
    40ac:	fd cf       	rjmp	.-6      	; 0x40a8 <ADC_In+0x156>
	for(i=2; i>=0; i--) {
		Scl->Full[i] = SPDR;
		WaitADC1();
	}
	WaitADC1();
	return Scl->Zero[2]<25 || Scl->Zero[2]>27 || Scl->Full[2]<200 || Scl->Full[2]>203;
    40ae:	80 91 6e 0c 	lds	r24, 0x0C6E
    40b2:	89 51       	subi	r24, 0x19	; 25
    40b4:	83 30       	cpi	r24, 0x03	; 3
    40b6:	08 f0       	brcs	.+2      	; 0x40ba <ADC_In+0x168>
    40b8:	85 c0       	rjmp	.+266    	; 0x41c4 <ADC_In+0x272>
    40ba:	80 91 71 0c 	lds	r24, 0x0C71
    40be:	88 3c       	cpi	r24, 0xC8	; 200
    40c0:	08 f4       	brcc	.+2      	; 0x40c4 <ADC_In+0x172>
    40c2:	80 c0       	rjmp	.+256    	; 0x41c4 <ADC_In+0x272>
    40c4:	8c 3c       	cpi	r24, 0xCC	; 204
    40c6:	08 f0       	brcs	.+2      	; 0x40ca <ADC_In+0x178>
    40c8:	7d c0       	rjmp	.+250    	; 0x41c4 <ADC_In+0x272>
			if(ADC_Check()) {
				ADC_Break++;
				ADC_Phase = RST;
			}
			else {
				ADC_Input[ADC_Chan] = Buf;
    40ca:	e1 2f       	mov	r30, r17
    40cc:	f0 e0       	ldi	r31, 0x00	; 0
    40ce:	ee 0f       	add	r30, r30
    40d0:	ff 1f       	adc	r31, r31
    40d2:	e6 5e       	subi	r30, 0xE6	; 230
    40d4:	f6 4f       	sbci	r31, 0xF6	; 246
    40d6:	31 83       	std	Z+1, r19	; 0x01
    40d8:	20 83       	st	Z, r18

// ~~~~~~~~~~~~~~~
inline static void
SetMux(void)
{
	if(++ADC_Chan == ADC_Reg)
    40da:	81 2f       	mov	r24, r17
    40dc:	8f 5f       	subi	r24, 0xFF	; 255
    40de:	80 93 11 09 	sts	0x0911, r24
    40e2:	87 30       	cpi	r24, 0x07	; 7
    40e4:	11 f4       	brne	.+4      	; 0x40ea <ADC_In+0x198>
		ADC_Chan = 0;
    40e6:	10 92 11 09 	sts	0x0911, r1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    40ea:	e0 91 11 09 	lds	r30, 0x0911
    40ee:	f0 e0       	ldi	r31, 0x00	; 0
    40f0:	e5 50       	subi	r30, 0x05	; 5
    40f2:	ff 4c       	sbci	r31, 0xCF	; 207
    40f4:	94 91       	lpm	r25, Z+
		#if ADC_Reg>8
			if(ADC_Chan>=sizeof(Mux))
				return;
		#endif
		uint8_t Addr = prb(Mux+ADC_Chan);
		cli();
    40f6:	f8 94       	cli
		if (Addr/4){
    40f8:	94 30       	cpi	r25, 0x04	; 4
    40fa:	08 f4       	brcc	.+2      	; 0x40fe <ADC_In+0x1ac>
    40fc:	ca c0       	rjmp	.+404    	; 0x4292 <ADC_In+0x340>
			Port_INH|=INH;
    40fe:	77 9a       	sbi	0x0e, 7	; 14
			#ifdef Port_INH2
				Port_INH2 &=~INH2;
    4100:	80 91 02 01 	lds	r24, 0x0102
    4104:	8b 7f       	andi	r24, 0xFB	; 251
    4106:	80 93 02 01 	sts	0x0102, r24
			Port_INH &=~INH;
			#ifdef Port_INH2
				Port_INH2|=INH2;
			#endif
		}
		if (Addr%4/2)	Port_TER_B	|=TER_B;	else Port_TER_B	&=~TER_B;
    410a:	29 2f       	mov	r18, r25
    410c:	30 e0       	ldi	r19, 0x00	; 0
    410e:	c9 01       	movw	r24, r18
    4110:	83 70       	andi	r24, 0x03	; 3
    4112:	90 70       	andi	r25, 0x00	; 0
    4114:	01 96       	adiw	r24, 0x01	; 1
    4116:	03 97       	sbiw	r24, 0x03	; 3
    4118:	08 f4       	brcc	.+2      	; 0x411c <ADC_In+0x1ca>
    411a:	b9 c0       	rjmp	.+370    	; 0x428e <ADC_In+0x33c>
    411c:	76 9a       	sbi	0x0e, 6	; 14
		if (Addr%2)		Port_TER_A	|=TER_A;	else Port_TER_A	&=~TER_A;
    411e:	20 ff       	sbrs	r18, 0
    4120:	b4 c0       	rjmp	.+360    	; 0x428a <ADC_In+0x338>
    4122:	75 9a       	sbi	0x0e, 5	; 14
		sei();
    4124:	78 94       	sei
    4126:	85 e5       	ldi	r24, 0x55	; 85
    4128:	8a 95       	dec	r24
    412a:	f1 f7       	brne	.-4      	; 0x4128 <ADC_In+0x1d6>
		default:
			SPDR = ADC_IN1(Reg);
			break;
		}
	#else
		SPDR = ADC_IN1(Reg);
    412c:	80 e1       	ldi	r24, 0x10	; 16
    412e:	8e bd       	out	0x2e, r24	; 46
			else {
				ADC_Input[ADC_Chan] = Buf;
				Chan = ADC_Chan;
				SetMux();
				ADC_IN(SetpReg);
				WaitSPI();
    4130:	0d b4       	in	r0, 0x2d	; 45
    4132:	07 fe       	sbrs	r0, 7
    4134:	fd cf       	rjmp	.-6      	; 0x4130 <ADC_In+0x1de>
				SPDR = SetpVal(NormMode) &~ADC_FSYNC;
    4136:	86 e0       	ldi	r24, 0x06	; 6
    4138:	8e bd       	out	0x2e, r24	; 46
				WaitSPI();
    413a:	0d b4       	in	r0, 0x2d	; 45
    413c:	07 fe       	sbrs	r0, 7
    413e:	fd cf       	rjmp	.-6      	; 0x413a <ADC_In+0x1e8>
				StartTimer8_ISR(TD_ADC, ADC10ms);
    4140:	84 2f       	mov	r24, r20
    4142:	64 e1       	ldi	r22, 0x14	; 20
    4144:	0e 94 66 1b 	call	0x36cc	; 0x36cc <StartTimer8_ISR>
    4148:	32 cf       	rjmp	.-412    	; 0x3fae <ADC_In+0x5c>

// ~~~~~~~~~~~~~~~
inline static void
ADC_Init1(void)
{
	if(!Timer8Stopp_ISR(TD_ADC))
    414a:	80 91 39 07 	lds	r24, 0x0739
    414e:	0e 94 d2 1c 	call	0x39a4	; 0x39a4 <Timer8Stopp_ISR>
    4152:	88 23       	and	r24, r24
    4154:	09 f4       	brne	.+2      	; 0x4158 <ADC_In+0x206>
    4156:	3a cf       	rjmp	.-396    	; 0x3fcc <ADC_In+0x7a>
    4158:	81 e0       	ldi	r24, 0x01	; 1
		return;
	uint8_t i = 0;
	while(i++<8) {	// 4 x 0xFF needs
		SPDR = 0xFF;
    415a:	9f ef       	ldi	r25, 0xFF	; 255
    415c:	9e bd       	out	0x2e, r25	; 46
		WaitSPI();
    415e:	0d b4       	in	r0, 0x2d	; 45
    4160:	07 fe       	sbrs	r0, 7
    4162:	fd cf       	rjmp	.-6      	; 0x415e <ADC_In+0x20c>
ADC_Init1(void)
{
	if(!Timer8Stopp_ISR(TD_ADC))
		return;
	uint8_t i = 0;
	while(i++<8) {	// 4 x 0xFF needs
    4164:	88 30       	cpi	r24, 0x08	; 8
    4166:	d9 f1       	breq	.+118    	; 0x41de <ADC_In+0x28c>
    4168:	8f 5f       	subi	r24, 0xFF	; 255
    416a:	f8 cf       	rjmp	.-16     	; 0x415c <ADC_In+0x20a>
// ~~~~~~~~~~~~~~~
static void
Calibr(uint8_t CR)
{
	static uint8_t Try;
	SPDR = CR;
    416c:	88 e0       	ldi	r24, 0x08	; 8
    416e:	8e bd       	out	0x2e, r24	; 46

// ~~~~~~~~~~~
static void
WaitADC2(void)
{
	WaitSPI();
    4170:	0d b4       	in	r0, 0x2d	; 45
    4172:	07 fe       	sbrs	r0, 7
    4174:	fd cf       	rjmp	.-6      	; 0x4170 <ADC_In+0x21e>
	SPDR = 0;
    4176:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    4178:	0d b4       	in	r0, 0x2d	; 45
    417a:	07 fe       	sbrs	r0, 7
    417c:	fd cf       	rjmp	.-6      	; 0x4178 <ADC_In+0x226>
Calibr(uint8_t CR)
{
	static uint8_t Try;
	SPDR = CR;
	WaitADC2();
	if(!(SPDR &ADC_DRDY)) {
    417e:	0e b4       	in	r0, 0x2e	; 46
    4180:	07 fc       	sbrc	r0, 7
    4182:	45 c0       	rjmp	.+138    	; 0x420e <ADC_In+0x2bc>
		Try = 0;
    4184:	10 92 ec 02 	sts	0x02EC, r1
		ADC_Phase++;
    4188:	83 e0       	ldi	r24, 0x03	; 3
    418a:	80 93 69 0b 	sts	0x0B69, r24
		break;
	case CALI3:
		Calibr(ADC_IN3(CommReg));
#endif
		if (ADC_Phase==READ)
			StartTimer8_ISR(TD_ADC, ADC10ms);
    418e:	80 91 39 07 	lds	r24, 0x0739
    4192:	64 e1       	ldi	r22, 0x14	; 20
    4194:	0e 94 66 1b 	call	0x36cc	; 0x36cc <StartTimer8_ISR>
    4198:	17 e0       	ldi	r17, 0x07	; 7
    419a:	09 cf       	rjmp	.-494    	; 0x3fae <ADC_In+0x5c>
				SPDR = SetpVal(NormMode) &~ADC_FSYNC;
				WaitSPI();
				StartTimer8_ISR(TD_ADC, ADC10ms);
			}
		}
		else if(Timer8Stopp_ISR(TD_ADC)) {
    419c:	80 91 39 07 	lds	r24, 0x0739
    41a0:	0e 94 d2 1c 	call	0x39a4	; 0x39a4 <Timer8Stopp_ISR>
    41a4:	88 23       	and	r24, r24
    41a6:	09 f4       	brne	.+2      	; 0x41aa <ADC_In+0x258>
    41a8:	11 cf       	rjmp	.-478    	; 0x3fcc <ADC_In+0x7a>
			ADC_ReadFail++;
    41aa:	80 91 b4 07 	lds	r24, 0x07B4
    41ae:	90 91 b5 07 	lds	r25, 0x07B5
    41b2:	01 96       	adiw	r24, 0x01	; 1
    41b4:	90 93 b5 07 	sts	0x07B5, r25
    41b8:	80 93 b4 07 	sts	0x07B4, r24
			ADC_Phase = RST;
    41bc:	10 92 69 0b 	sts	0x0B69, r1
    41c0:	17 e0       	ldi	r17, 0x07	; 7
    41c2:	f5 ce       	rjmp	.-534    	; 0x3fae <ADC_In+0x5c>
					ADC_Chan--;
				}
				else
			#endif
			if(ADC_Check()) {
				ADC_Break++;
    41c4:	80 91 f8 06 	lds	r24, 0x06F8
    41c8:	90 91 f9 06 	lds	r25, 0x06F9
    41cc:	01 96       	adiw	r24, 0x01	; 1
    41ce:	90 93 f9 06 	sts	0x06F9, r25
    41d2:	80 93 f8 06 	sts	0x06F8, r24
				ADC_Phase = RST;
    41d6:	10 92 69 0b 	sts	0x0B69, r1
    41da:	17 e0       	ldi	r17, 0x07	; 7
    41dc:	e8 ce       	rjmp	.-560    	; 0x3fae <ADC_In+0x5c>

// ~~~~~~~~~~~~~~~~~~~~~~~~~
static void
Init(uint8_t CR, uint8_t SR)
{
	SPDR = CR;
    41de:	80 e2       	ldi	r24, 0x20	; 32
    41e0:	8e bd       	out	0x2e, r24	; 46
	WaitSPI();
    41e2:	0d b4       	in	r0, 0x2d	; 45
    41e4:	07 fe       	sbrs	r0, 7
    41e6:	fd cf       	rjmp	.-6      	; 0x41e2 <ADC_In+0x290>
	SPDR=ClckVal;
    41e8:	84 e0       	ldi	r24, 0x04	; 4
    41ea:	8e bd       	out	0x2e, r24	; 46
	WaitSPI();
    41ec:	0d b4       	in	r0, 0x2d	; 45
    41ee:	07 fe       	sbrs	r0, 7
    41f0:	fd cf       	rjmp	.-6      	; 0x41ec <ADC_In+0x29a>
	SPDR = SR;
    41f2:	80 e1       	ldi	r24, 0x10	; 16
    41f4:	8e bd       	out	0x2e, r24	; 46
	WaitSPI();
    41f6:	0d b4       	in	r0, 0x2d	; 45
    41f8:	07 fe       	sbrs	r0, 7
    41fa:	fd cf       	rjmp	.-6      	; 0x41f6 <ADC_In+0x2a4>
	SPDR = SetpVal(CaliMode) &~ADC_FSYNC;
    41fc:	86 e4       	ldi	r24, 0x46	; 70
    41fe:	8e bd       	out	0x2e, r24	; 46
	WaitSPI();
    4200:	0d b4       	in	r0, 0x2d	; 45
    4202:	07 fe       	sbrs	r0, 7
    4204:	fd cf       	rjmp	.-6      	; 0x4200 <ADC_In+0x2ae>
	StartTimer8_ISR(TD_ADC, 36);
    4206:	80 91 39 07 	lds	r24, 0x0739
    420a:	64 e2       	ldi	r22, 0x24	; 36
    420c:	c8 ce       	rjmp	.-624    	; 0x3f9e <ADC_In+0x4c>
	WaitADC2();
	if(!(SPDR &ADC_DRDY)) {
		Try = 0;
		ADC_Phase++;
	}
	else if(Timer8Stopp_ISR(TD_ADC)) {
    420e:	80 91 39 07 	lds	r24, 0x0739
    4212:	0e 94 d2 1c 	call	0x39a4	; 0x39a4 <Timer8Stopp_ISR>
    4216:	88 23       	and	r24, r24
    4218:	99 f0       	breq	.+38     	; 0x4240 <ADC_In+0x2ee>
		ADC_Fail++;
    421a:	80 91 2a 09 	lds	r24, 0x092A
    421e:	90 91 2b 09 	lds	r25, 0x092B
    4222:	01 96       	adiw	r24, 0x01	; 1
    4224:	90 93 2b 09 	sts	0x092B, r25
    4228:	80 93 2a 09 	sts	0x092A, r24
		ADC_Phase = ++Try<27 ? RST : ADC_OFF;
    422c:	80 91 ec 02 	lds	r24, 0x02EC
    4230:	8f 5f       	subi	r24, 0xFF	; 255
    4232:	80 93 ec 02 	sts	0x02EC, r24
    4236:	8b 31       	cpi	r24, 0x1B	; 27
    4238:	98 f1       	brcs	.+102    	; 0x42a0 <ADC_In+0x34e>
    423a:	84 e0       	ldi	r24, 0x04	; 4
    423c:	80 93 69 0b 	sts	0x0B69, r24
		Init(ADC_IN3(ClckReg), ADC_IN3(SetpReg));
		break;
	case CALI3:
		Calibr(ADC_IN3(CommReg));
#endif
		if (ADC_Phase==READ)
    4240:	80 91 69 0b 	lds	r24, 0x0B69
    4244:	83 30       	cpi	r24, 0x03	; 3
    4246:	09 f4       	brne	.+2      	; 0x424a <ADC_In+0x2f8>
    4248:	a2 cf       	rjmp	.-188    	; 0x418e <ADC_In+0x23c>
				StartTimer8_ISR(TD_ADC, ADC10ms);
			}
		}
		else if(Timer8Stopp_ISR(TD_ADC)) {
			ADC_ReadFail++;
			ADC_Phase = RST;
    424a:	17 e0       	ldi	r17, 0x07	; 7
    424c:	b0 ce       	rjmp	.-672    	; 0x3fae <ADC_In+0x5c>
			WaitADC2();
			Buf = SPDR<<8;
			WaitADC1();
			Buf += SPDR;
			#ifdef ADC_Ref_Chan
				if (ADC_Chan==sizeof(Mux)-1 && ADC_Input[sizeof(Mux)-1]!=0 && (Buf<ADC_Ref-ADC_Ref_d || Buf>ADC_Ref+ADC_Ref_d)) {
    424e:	80 91 26 09 	lds	r24, 0x0926
    4252:	90 91 27 09 	lds	r25, 0x0927
    4256:	89 2b       	or	r24, r25
    4258:	09 f4       	brne	.+2      	; 0x425c <ADC_In+0x30a>
    425a:	e0 ce       	rjmp	.-576    	; 0x401c <ADC_In+0xca>
    425c:	ca 01       	movw	r24, r20
    425e:	80 58       	subi	r24, 0x80	; 128
    4260:	9e 43       	sbci	r25, 0x3E	; 62
    4262:	81 5a       	subi	r24, 0xA1	; 161
    4264:	9f 40       	sbci	r25, 0x0F	; 15
    4266:	08 f4       	brcc	.+2      	; 0x426a <ADC_In+0x318>
    4268:	d9 ce       	rjmp	.-590    	; 0x401c <ADC_In+0xca>
					ADC_Break++;
    426a:	80 91 f8 06 	lds	r24, 0x06F8
    426e:	90 91 f9 06 	lds	r25, 0x06F9
    4272:	01 96       	adiw	r24, 0x01	; 1
    4274:	90 93 f9 06 	sts	0x06F9, r25
    4278:	80 93 f8 06 	sts	0x06F8, r24
					ADC_Phase = RST;
    427c:	10 92 69 0b 	sts	0x0B69, r1
					ADC_Chan--;
    4280:	85 e0       	ldi	r24, 0x05	; 5
    4282:	80 93 11 09 	sts	0x0911, r24
    4286:	17 e0       	ldi	r17, 0x07	; 7
    4288:	92 ce       	rjmp	.-732    	; 0x3fae <ADC_In+0x5c>
			#ifdef Port_INH2
				Port_INH2|=INH2;
			#endif
		}
		if (Addr%4/2)	Port_TER_B	|=TER_B;	else Port_TER_B	&=~TER_B;
		if (Addr%2)		Port_TER_A	|=TER_A;	else Port_TER_A	&=~TER_A;
    428a:	75 98       	cbi	0x0e, 5	; 14
    428c:	4b cf       	rjmp	.-362    	; 0x4124 <ADC_In+0x1d2>
			Port_INH &=~INH;
			#ifdef Port_INH2
				Port_INH2|=INH2;
			#endif
		}
		if (Addr%4/2)	Port_TER_B	|=TER_B;	else Port_TER_B	&=~TER_B;
    428e:	76 98       	cbi	0x0e, 6	; 14
    4290:	46 cf       	rjmp	.-372    	; 0x411e <ADC_In+0x1cc>
			#ifdef Port_INH2
				Port_INH2 &=~INH2;
			#endif
		}
		else{
			Port_INH &=~INH;
    4292:	77 98       	cbi	0x0e, 7	; 14
			#ifdef Port_INH2
				Port_INH2|=INH2;
    4294:	80 91 02 01 	lds	r24, 0x0102
    4298:	84 60       	ori	r24, 0x04	; 4
    429a:	80 93 02 01 	sts	0x0102, r24
    429e:	35 cf       	rjmp	.-406    	; 0x410a <ADC_In+0x1b8>
		Try = 0;
		ADC_Phase++;
	}
	else if(Timer8Stopp_ISR(TD_ADC)) {
		ADC_Fail++;
		ADC_Phase = ++Try<27 ? RST : ADC_OFF;
    42a0:	80 e0       	ldi	r24, 0x00	; 0
    42a2:	cc cf       	rjmp	.-104    	; 0x423c <ADC_In+0x2ea>

000042a4 <SPI_Init>:
// Total
// ~~~~~~~~~~~
void
SPI_Init(void)
{
	cli();
    42a4:	f8 94       	cli
	#if defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		DDRB = (DDRB &~(1<<DDB3)) |(1<<DDB2) |(1<<DDB1) |(1<<DDB0);
    42a6:	84 b1       	in	r24, 0x04	; 4
    42a8:	80 7f       	andi	r24, 0xF0	; 240
    42aa:	87 60       	ori	r24, 0x07	; 7
    42ac:	84 b9       	out	0x04, r24	; 4
		PORTB |=1<<PB3;
    42ae:	2b 9a       	sbi	0x05, 3	; 5
	#elif defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
		DDRB = (DDRB &~(1<<DDB6)) |(1<<DDB5) |(1<<DDB7) |(1<<DDB4);
		PORTB |=1<<PB6;
	#endif
	SPCR = (uint8_t)((~(1<<SPIE) |(1<<SPE)) &~(1<<DORD)) |(1<<MSTR) |(1<<CPHA) |(1<<SPR1) |(1<<SPR0);
    42b0:	8f e5       	ldi	r24, 0x5F	; 95
    42b2:	8c bd       	out	0x2c, r24	; 44
	sei();
    42b4:	78 94       	sei
		PortCS_DAC_2 |=CS_DAC_2;
		sei();
	#endif

	#ifndef ADC_Miss
		cli();
    42b6:	f8 94       	cli
		#ifdef CS_ADC
			DDR_CS_ADC |=CS_ADC;
    42b8:	80 91 01 01 	lds	r24, 0x0101
    42bc:	88 60       	ori	r24, 0x08	; 8
    42be:	80 93 01 01 	sts	0x0101, r24
			PortCS_ADC |=CS_ADC;
    42c2:	80 91 02 01 	lds	r24, 0x0102
    42c6:	88 60       	ori	r24, 0x08	; 8
    42c8:	80 93 02 01 	sts	0x0102, r24
		#endif
		DDR_RESET_PER |=RESET_PER;
    42cc:	80 91 01 01 	lds	r24, 0x0101
    42d0:	80 61       	ori	r24, 0x10	; 16
    42d2:	80 93 01 01 	sts	0x0101, r24
		#ifdef ADC_Mux
			DDR_INH |=INH;
    42d6:	6f 9a       	sbi	0x0d, 7	; 13
			#ifdef DDR_INH2			
				DDR_INH2 |=INH2;
    42d8:	80 91 01 01 	lds	r24, 0x0101
    42dc:	84 60       	ori	r24, 0x04	; 4
    42de:	80 93 01 01 	sts	0x0101, r24
			#endif
			DDR_TER_A |=TER_A;
    42e2:	6d 9a       	sbi	0x0d, 5	; 13
			DDR_TER_B |=TER_B;
    42e4:	6e 9a       	sbi	0x0d, 6	; 13
		#endif
		sei();
    42e6:	78 94       	sei

// ~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer8_ISR_SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys_ISR;
    42e8:	80 91 db 02 	lds	r24, 0x02DB
	VacantTimer8Sys_ISR += n;
    42ec:	8f 5f       	subi	r24, 0xFF	; 255
    42ee:	80 93 db 02 	sts	0x02DB, r24
    42f2:	81 50       	subi	r24, 0x01	; 1

		TD_ADC = Timer8_ISR_SysAlloc(1);
    42f4:	80 93 39 07 	sts	0x0739, r24


		ADC_Chan = ADC_Reg-1;		// Ignore 1-st measurement after calibration
    42f8:	86 e0       	ldi	r24, 0x06	; 6
    42fa:	80 93 11 09 	sts	0x0911, r24

		while(ADC_In()==ADC_Reg && ADC_OK);
    42fe:	0e 94 a9 1f 	call	0x3f52	; 0x3f52 <ADC_In>
    4302:	87 30       	cpi	r24, 0x07	; 7
    4304:	91 f4       	brne	.+36     	; 0x432a <SPI_Init+0x86>
    4306:	80 91 2a 09 	lds	r24, 0x092A
    430a:	90 91 2b 09 	lds	r25, 0x092B
    430e:	89 2b       	or	r24, r25
    4310:	61 f4       	brne	.+24     	; 0x432a <SPI_Init+0x86>
    4312:	80 91 b4 07 	lds	r24, 0x07B4
    4316:	90 91 b5 07 	lds	r25, 0x07B5
    431a:	89 2b       	or	r24, r25
    431c:	31 f4       	brne	.+12     	; 0x432a <SPI_Init+0x86>
    431e:	80 91 f8 06 	lds	r24, 0x06F8
    4322:	90 91 f9 06 	lds	r25, 0x06F9
    4326:	89 2b       	or	r24, r25
    4328:	51 f3       	breq	.-44     	; 0x42fe <SPI_Init+0x5a>
    432a:	08 95       	ret

0000432c <Pow10>:
#include <string.h>

// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
    432c:	48 2f       	mov	r20, r24
	uint16_t Pow = 1;
	while(Exp--)
    432e:	88 23       	and	r24, r24
    4330:	89 f0       	breq	.+34     	; 0x4354 <Pow10+0x28>
    4332:	21 e0       	ldi	r18, 0x01	; 1
    4334:	30 e0       	ldi	r19, 0x00	; 0
		Pow *= 10;
    4336:	c9 01       	movw	r24, r18
    4338:	88 0f       	add	r24, r24
    433a:	99 1f       	adc	r25, r25
    433c:	22 0f       	add	r18, r18
    433e:	33 1f       	adc	r19, r19
    4340:	22 0f       	add	r18, r18
    4342:	33 1f       	adc	r19, r19
    4344:	22 0f       	add	r18, r18
    4346:	33 1f       	adc	r19, r19
    4348:	28 0f       	add	r18, r24
    434a:	39 1f       	adc	r19, r25
    434c:	41 50       	subi	r20, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    434e:	99 f7       	brne	.-26     	; 0x4336 <Pow10+0xa>
		Pow *= 10;
	return Pow;
}
    4350:	c9 01       	movw	r24, r18
    4352:	08 95       	ret
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    4354:	21 e0       	ldi	r18, 0x01	; 1
    4356:	30 e0       	ldi	r19, 0x00	; 0
    4358:	fb cf       	rjmp	.-10     	; 0x4350 <Pow10+0x24>

0000435a <PowL10>:
	return Pow;
}
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
    435a:	1f 93       	push	r17
    435c:	18 2f       	mov	r17, r24
	uint32_t Pow = 1;
	while(Exp--)
    435e:	88 23       	and	r24, r24
    4360:	a1 f0       	breq	.+40     	; 0x438a <PowL10+0x30>
    4362:	21 e0       	ldi	r18, 0x01	; 1
    4364:	30 e0       	ldi	r19, 0x00	; 0
    4366:	40 e0       	ldi	r20, 0x00	; 0
    4368:	50 e0       	ldi	r21, 0x00	; 0
		Pow *= 10;
    436a:	ca 01       	movw	r24, r20
    436c:	b9 01       	movw	r22, r18
    436e:	2a e0       	ldi	r18, 0x0A	; 10
    4370:	30 e0       	ldi	r19, 0x00	; 0
    4372:	40 e0       	ldi	r20, 0x00	; 0
    4374:	50 e0       	ldi	r21, 0x00	; 0
    4376:	0e 94 53 84 	call	0x108a6	; 0x108a6 <__mulsi3>
    437a:	9b 01       	movw	r18, r22
    437c:	ac 01       	movw	r20, r24
    437e:	11 50       	subi	r17, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
	uint32_t Pow = 1;
	while(Exp--)
    4380:	a1 f7       	brne	.-24     	; 0x436a <PowL10+0x10>
		Pow *= 10;
	return Pow;
}
    4382:	b9 01       	movw	r22, r18
    4384:	ca 01       	movw	r24, r20
    4386:	1f 91       	pop	r17
    4388:	08 95       	ret
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
	uint32_t Pow = 1;
	while(Exp--)
    438a:	21 e0       	ldi	r18, 0x01	; 1
    438c:	30 e0       	ldi	r19, 0x00	; 0
    438e:	40 e0       	ldi	r20, 0x00	; 0
    4390:	50 e0       	ldi	r21, 0x00	; 0
    4392:	f7 cf       	rjmp	.-18     	; 0x4382 <PowL10+0x28>

00004394 <Log10>:
	return Pow;
}
// ~~~~~~~~~~~~~~~~~
uint8_t
Log10(uint32_t Numb)
{
    4394:	1f 93       	push	r17
	uint8_t Pos;
	for(Pos=0; Numb/=10; Pos++);
    4396:	2a e0       	ldi	r18, 0x0A	; 10
    4398:	30 e0       	ldi	r19, 0x00	; 0
    439a:	40 e0       	ldi	r20, 0x00	; 0
    439c:	50 e0       	ldi	r21, 0x00	; 0
    439e:	0e 94 a5 84 	call	0x1094a	; 0x1094a <__udivmodsi4>
    43a2:	c9 01       	movw	r24, r18
    43a4:	da 01       	movw	r26, r20
    43a6:	bc 01       	movw	r22, r24
    43a8:	cd 01       	movw	r24, r26
    43aa:	61 15       	cp	r22, r1
    43ac:	71 05       	cpc	r23, r1
    43ae:	81 05       	cpc	r24, r1
    43b0:	91 05       	cpc	r25, r1
    43b2:	a1 f0       	breq	.+40     	; 0x43dc <Log10+0x48>
    43b4:	10 e0       	ldi	r17, 0x00	; 0
    43b6:	1f 5f       	subi	r17, 0xFF	; 255
    43b8:	2a e0       	ldi	r18, 0x0A	; 10
    43ba:	30 e0       	ldi	r19, 0x00	; 0
    43bc:	40 e0       	ldi	r20, 0x00	; 0
    43be:	50 e0       	ldi	r21, 0x00	; 0
    43c0:	0e 94 a5 84 	call	0x1094a	; 0x1094a <__udivmodsi4>
    43c4:	c9 01       	movw	r24, r18
    43c6:	da 01       	movw	r26, r20
    43c8:	bc 01       	movw	r22, r24
    43ca:	cd 01       	movw	r24, r26
    43cc:	61 15       	cp	r22, r1
    43ce:	71 05       	cpc	r23, r1
    43d0:	81 05       	cpc	r24, r1
    43d2:	91 05       	cpc	r25, r1
    43d4:	81 f7       	brne	.-32     	; 0x43b6 <Log10+0x22>
	return Pos;
}
    43d6:	81 2f       	mov	r24, r17
    43d8:	1f 91       	pop	r17
    43da:	08 95       	ret
// ~~~~~~~~~~~~~~~~~
uint8_t
Log10(uint32_t Numb)
{
	uint8_t Pos;
	for(Pos=0; Numb/=10; Pos++);
    43dc:	10 e0       	ldi	r17, 0x00	; 0
    43de:	fb cf       	rjmp	.-10     	; 0x43d6 <Log10+0x42>

000043e0 <CodBCD>:
// ~~~~~~~~~~~~~~~~~~~~

// ~~~~~~~~~~~~~~~~~~~
uint8_t
CodBCD(uint8_t Number)
{
    43e0:	28 2f       	mov	r18, r24
    43e2:	6a e0       	ldi	r22, 0x0A	; 10
    43e4:	0e 94 72 84 	call	0x108e4	; 0x108e4 <__udivmodqi4>
    43e8:	38 2f       	mov	r19, r24
    43ea:	32 95       	swap	r19
    43ec:	30 7f       	andi	r19, 0xF0	; 240
    43ee:	82 2f       	mov	r24, r18
    43f0:	0e 94 72 84 	call	0x108e4	; 0x108e4 <__udivmodqi4>
	return (Number/10<<4)+Number%10;
}
    43f4:	83 2f       	mov	r24, r19
    43f6:	89 0f       	add	r24, r25
    43f8:	08 95       	ret

000043fa <DecodBCD>:

// ~~~~~~~~~~~~~~~~~~
uint8_t
DecodBCD(uint8_t BCD)
{
    43fa:	28 2f       	mov	r18, r24
    43fc:	22 95       	swap	r18
    43fe:	2f 70       	andi	r18, 0x0F	; 15
    4400:	9a e0       	ldi	r25, 0x0A	; 10
    4402:	29 9f       	mul	r18, r25
    4404:	90 01       	movw	r18, r0
    4406:	11 24       	eor	r1, r1
    4408:	8f 70       	andi	r24, 0x0F	; 15
	return 10*(BCD>>4)+(BCD&0x0F);
}
    440a:	82 0f       	add	r24, r18
    440c:	08 95       	ret

0000440e <LineFunc>:
} uLineGraph;

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
int16_t
LineFunc(const LineGraph *LG, int32_t x)
{
    440e:	2f 92       	push	r2
    4410:	3f 92       	push	r3
    4412:	4f 92       	push	r4
    4414:	5f 92       	push	r5
    4416:	6f 92       	push	r6
    4418:	7f 92       	push	r7
    441a:	8f 92       	push	r8
    441c:	9f 92       	push	r9
    441e:	af 92       	push	r10
    4420:	bf 92       	push	r11
    4422:	cf 92       	push	r12
    4424:	df 92       	push	r13
    4426:	ef 92       	push	r14
    4428:	ff 92       	push	r15
    442a:	0f 93       	push	r16
    442c:	1f 93       	push	r17
    442e:	cf 93       	push	r28
    4430:	df 93       	push	r29
    4432:	ec 01       	movw	r28, r24
    4434:	7a 01       	movw	r14, r20
    4436:	8b 01       	movw	r16, r22
	int16_t y;
	if (LG->x1==LG->x2)
    4438:	28 80       	ld	r2, Y
    443a:	39 80       	ldd	r3, Y+1	; 0x01
    443c:	4a 80       	ldd	r4, Y+2	; 0x02
    443e:	5b 80       	ldd	r5, Y+3	; 0x03
    4440:	6c 81       	ldd	r22, Y+4	; 0x04
    4442:	7d 81       	ldd	r23, Y+5	; 0x05
    4444:	8e 81       	ldd	r24, Y+6	; 0x06
    4446:	9f 81       	ldd	r25, Y+7	; 0x07
    4448:	26 16       	cp	r2, r22
    444a:	37 06       	cpc	r3, r23
    444c:	48 06       	cpc	r4, r24
    444e:	59 06       	cpc	r5, r25
    4450:	09 f4       	brne	.+2      	; 0x4454 <LineFunc+0x46>
    4452:	58 c0       	rjmp	.+176    	; 0x4504 <LineFunc+0xf6>
		y = LG->y1;
	else {
		float x1=LG->x1, x2=LG->x2, y1=LG->y1, y2=LG->y2;
    4454:	0e 94 08 7f 	call	0xfe10	; 0xfe10 <__floatsisf>
    4458:	5b 01       	movw	r10, r22
    445a:	6c 01       	movw	r12, r24
    445c:	6a 85       	ldd	r22, Y+10	; 0x0a
    445e:	7b 85       	ldd	r23, Y+11	; 0x0b
    4460:	88 27       	eor	r24, r24
    4462:	77 fd       	sbrc	r23, 7
    4464:	80 95       	com	r24
    4466:	98 2f       	mov	r25, r24
    4468:	0e 94 08 7f 	call	0xfe10	; 0xfe10 <__floatsisf>
    446c:	3b 01       	movw	r6, r22
    446e:	4c 01       	movw	r8, r24
		y = (x-x2)*(y2-y1)/(x2-x1)+y2;
    4470:	c8 01       	movw	r24, r16
    4472:	b7 01       	movw	r22, r14
    4474:	0e 94 08 7f 	call	0xfe10	; 0xfe10 <__floatsisf>
    4478:	a6 01       	movw	r20, r12
    447a:	95 01       	movw	r18, r10
    447c:	0e 94 09 83 	call	0x10612	; 0x10612 <__subsf3>
    4480:	7b 01       	movw	r14, r22
    4482:	8c 01       	movw	r16, r24
    4484:	68 85       	ldd	r22, Y+8	; 0x08
    4486:	79 85       	ldd	r23, Y+9	; 0x09
    4488:	88 27       	eor	r24, r24
    448a:	77 fd       	sbrc	r23, 7
    448c:	80 95       	com	r24
    448e:	98 2f       	mov	r25, r24
    4490:	0e 94 08 7f 	call	0xfe10	; 0xfe10 <__floatsisf>
    4494:	9b 01       	movw	r18, r22
    4496:	ac 01       	movw	r20, r24
    4498:	c4 01       	movw	r24, r8
    449a:	b3 01       	movw	r22, r6
    449c:	0e 94 09 83 	call	0x10612	; 0x10612 <__subsf3>
    44a0:	9b 01       	movw	r18, r22
    44a2:	ac 01       	movw	r20, r24
    44a4:	c8 01       	movw	r24, r16
    44a6:	b7 01       	movw	r22, r14
    44a8:	0e 94 43 7f 	call	0xfe86	; 0xfe86 <__mulsf3>
    44ac:	7b 01       	movw	r14, r22
    44ae:	8c 01       	movw	r16, r24
    44b0:	c2 01       	movw	r24, r4
    44b2:	b1 01       	movw	r22, r2
    44b4:	0e 94 08 7f 	call	0xfe10	; 0xfe10 <__floatsisf>
    44b8:	9b 01       	movw	r18, r22
    44ba:	ac 01       	movw	r20, r24
    44bc:	c6 01       	movw	r24, r12
    44be:	b5 01       	movw	r22, r10
    44c0:	0e 94 09 83 	call	0x10612	; 0x10612 <__subsf3>
    44c4:	9b 01       	movw	r18, r22
    44c6:	ac 01       	movw	r20, r24
    44c8:	c8 01       	movw	r24, r16
    44ca:	b7 01       	movw	r22, r14
    44cc:	0e 94 6e 83 	call	0x106dc	; 0x106dc <__divsf3>
    44d0:	a4 01       	movw	r20, r8
    44d2:	93 01       	movw	r18, r6
    44d4:	0e 94 0a 83 	call	0x10614	; 0x10614 <__addsf3>
    44d8:	0e 94 d6 83 	call	0x107ac	; 0x107ac <__fixsfsi>
    44dc:	cb 01       	movw	r24, r22
	}
	return y;
}
    44de:	df 91       	pop	r29
    44e0:	cf 91       	pop	r28
    44e2:	1f 91       	pop	r17
    44e4:	0f 91       	pop	r16
    44e6:	ff 90       	pop	r15
    44e8:	ef 90       	pop	r14
    44ea:	df 90       	pop	r13
    44ec:	cf 90       	pop	r12
    44ee:	bf 90       	pop	r11
    44f0:	af 90       	pop	r10
    44f2:	9f 90       	pop	r9
    44f4:	8f 90       	pop	r8
    44f6:	7f 90       	pop	r7
    44f8:	6f 90       	pop	r6
    44fa:	5f 90       	pop	r5
    44fc:	4f 90       	pop	r4
    44fe:	3f 90       	pop	r3
    4500:	2f 90       	pop	r2
    4502:	08 95       	ret
int16_t
LineFunc(const LineGraph *LG, int32_t x)
{
	int16_t y;
	if (LG->x1==LG->x2)
		y = LG->y1;
    4504:	88 85       	ldd	r24, Y+8	; 0x08
    4506:	99 85       	ldd	r25, Y+9	; 0x09
    4508:	ea cf       	rjmp	.-44     	; 0x44de <LineFunc+0xd0>

0000450a <uLineFunc>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
int16_t
uLineFunc(const uLineGraph *LG, uint32_t x)
{
    450a:	2f 92       	push	r2
    450c:	3f 92       	push	r3
    450e:	4f 92       	push	r4
    4510:	5f 92       	push	r5
    4512:	6f 92       	push	r6
    4514:	7f 92       	push	r7
    4516:	8f 92       	push	r8
    4518:	9f 92       	push	r9
    451a:	af 92       	push	r10
    451c:	bf 92       	push	r11
    451e:	cf 92       	push	r12
    4520:	df 92       	push	r13
    4522:	ef 92       	push	r14
    4524:	ff 92       	push	r15
    4526:	0f 93       	push	r16
    4528:	1f 93       	push	r17
    452a:	cf 93       	push	r28
    452c:	df 93       	push	r29
    452e:	ec 01       	movw	r28, r24
    4530:	7a 01       	movw	r14, r20
    4532:	8b 01       	movw	r16, r22
	int16_t y;
	if (LG->x1==LG->x2)
    4534:	28 80       	ld	r2, Y
    4536:	39 80       	ldd	r3, Y+1	; 0x01
    4538:	4a 80       	ldd	r4, Y+2	; 0x02
    453a:	5b 80       	ldd	r5, Y+3	; 0x03
    453c:	6c 81       	ldd	r22, Y+4	; 0x04
    453e:	7d 81       	ldd	r23, Y+5	; 0x05
    4540:	8e 81       	ldd	r24, Y+6	; 0x06
    4542:	9f 81       	ldd	r25, Y+7	; 0x07
    4544:	26 16       	cp	r2, r22
    4546:	37 06       	cpc	r3, r23
    4548:	48 06       	cpc	r4, r24
    454a:	59 06       	cpc	r5, r25
    454c:	09 f4       	brne	.+2      	; 0x4550 <uLineFunc+0x46>
    454e:	58 c0       	rjmp	.+176    	; 0x4600 <uLineFunc+0xf6>
		y = LG->y1;
	else {
		float x1=LG->x1, x2=LG->x2, y1=LG->y1, y2=LG->y2;
    4550:	0e 94 06 7f 	call	0xfe0c	; 0xfe0c <__floatunsisf>
    4554:	5b 01       	movw	r10, r22
    4556:	6c 01       	movw	r12, r24
    4558:	6a 85       	ldd	r22, Y+10	; 0x0a
    455a:	7b 85       	ldd	r23, Y+11	; 0x0b
    455c:	88 27       	eor	r24, r24
    455e:	77 fd       	sbrc	r23, 7
    4560:	80 95       	com	r24
    4562:	98 2f       	mov	r25, r24
    4564:	0e 94 08 7f 	call	0xfe10	; 0xfe10 <__floatsisf>
    4568:	3b 01       	movw	r6, r22
    456a:	4c 01       	movw	r8, r24
		y = (x-x2)*(y2-y1)/(x2-x1)+y2;
    456c:	c8 01       	movw	r24, r16
    456e:	b7 01       	movw	r22, r14
    4570:	0e 94 06 7f 	call	0xfe0c	; 0xfe0c <__floatunsisf>
    4574:	a6 01       	movw	r20, r12
    4576:	95 01       	movw	r18, r10
    4578:	0e 94 09 83 	call	0x10612	; 0x10612 <__subsf3>
    457c:	7b 01       	movw	r14, r22
    457e:	8c 01       	movw	r16, r24
    4580:	68 85       	ldd	r22, Y+8	; 0x08
    4582:	79 85       	ldd	r23, Y+9	; 0x09
    4584:	88 27       	eor	r24, r24
    4586:	77 fd       	sbrc	r23, 7
    4588:	80 95       	com	r24
    458a:	98 2f       	mov	r25, r24
    458c:	0e 94 08 7f 	call	0xfe10	; 0xfe10 <__floatsisf>
    4590:	9b 01       	movw	r18, r22
    4592:	ac 01       	movw	r20, r24
    4594:	c4 01       	movw	r24, r8
    4596:	b3 01       	movw	r22, r6
    4598:	0e 94 09 83 	call	0x10612	; 0x10612 <__subsf3>
    459c:	9b 01       	movw	r18, r22
    459e:	ac 01       	movw	r20, r24
    45a0:	c8 01       	movw	r24, r16
    45a2:	b7 01       	movw	r22, r14
    45a4:	0e 94 43 7f 	call	0xfe86	; 0xfe86 <__mulsf3>
    45a8:	7b 01       	movw	r14, r22
    45aa:	8c 01       	movw	r16, r24
    45ac:	c2 01       	movw	r24, r4
    45ae:	b1 01       	movw	r22, r2
    45b0:	0e 94 06 7f 	call	0xfe0c	; 0xfe0c <__floatunsisf>
    45b4:	9b 01       	movw	r18, r22
    45b6:	ac 01       	movw	r20, r24
    45b8:	c6 01       	movw	r24, r12
    45ba:	b5 01       	movw	r22, r10
    45bc:	0e 94 09 83 	call	0x10612	; 0x10612 <__subsf3>
    45c0:	9b 01       	movw	r18, r22
    45c2:	ac 01       	movw	r20, r24
    45c4:	c8 01       	movw	r24, r16
    45c6:	b7 01       	movw	r22, r14
    45c8:	0e 94 6e 83 	call	0x106dc	; 0x106dc <__divsf3>
    45cc:	a4 01       	movw	r20, r8
    45ce:	93 01       	movw	r18, r6
    45d0:	0e 94 0a 83 	call	0x10614	; 0x10614 <__addsf3>
    45d4:	0e 94 d6 83 	call	0x107ac	; 0x107ac <__fixsfsi>
    45d8:	cb 01       	movw	r24, r22
	}
	return y;
}
    45da:	df 91       	pop	r29
    45dc:	cf 91       	pop	r28
    45de:	1f 91       	pop	r17
    45e0:	0f 91       	pop	r16
    45e2:	ff 90       	pop	r15
    45e4:	ef 90       	pop	r14
    45e6:	df 90       	pop	r13
    45e8:	cf 90       	pop	r12
    45ea:	bf 90       	pop	r11
    45ec:	af 90       	pop	r10
    45ee:	9f 90       	pop	r9
    45f0:	8f 90       	pop	r8
    45f2:	7f 90       	pop	r7
    45f4:	6f 90       	pop	r6
    45f6:	5f 90       	pop	r5
    45f8:	4f 90       	pop	r4
    45fa:	3f 90       	pop	r3
    45fc:	2f 90       	pop	r2
    45fe:	08 95       	ret
int16_t
uLineFunc(const uLineGraph *LG, uint32_t x)
{
	int16_t y;
	if (LG->x1==LG->x2)
		y = LG->y1;
    4600:	88 85       	ldd	r24, Y+8	; 0x08
    4602:	99 85       	ldd	r25, Y+9	; 0x09
    4604:	ea cf       	rjmp	.-44     	; 0x45da <uLineFunc+0xd0>

00004606 <PGM_uBrokLine>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
int16_t
PGM_uBrokLine(PGM_uDataPoint *Brok, uint16_t x)
{
    4606:	af 92       	push	r10
    4608:	bf 92       	push	r11
    460a:	cf 92       	push	r12
    460c:	df 92       	push	r13
    460e:	ef 92       	push	r14
    4610:	ff 92       	push	r15
    4612:	0f 93       	push	r16
    4614:	1f 93       	push	r17
    4616:	df 93       	push	r29
    4618:	cf 93       	push	r28
    461a:	cd b7       	in	r28, 0x3d	; 61
    461c:	de b7       	in	r29, 0x3e	; 62
    461e:	2c 97       	sbiw	r28, 0x0c	; 12
    4620:	0f b6       	in	r0, 0x3f	; 63
    4622:	f8 94       	cli
    4624:	de bf       	out	0x3e, r29	; 62
    4626:	0f be       	out	0x3f, r0	; 63
    4628:	cd bf       	out	0x3d, r28	; 61
    462a:	dc 01       	movw	r26, r24

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    462c:	fc 01       	movw	r30, r24
    462e:	85 91       	lpm	r24, Z+
    4630:	94 91       	lpm	r25, Z+
	uLineGraph Segm;
	Segm.x2 = prw(&Brok->x);
    4632:	7c 01       	movw	r14, r24
    4634:	00 e0       	ldi	r16, 0x00	; 0
    4636:	10 e0       	ldi	r17, 0x00	; 0
    4638:	5b 01       	movw	r10, r22
    463a:	cc 24       	eor	r12, r12
    463c:	dd 24       	eor	r13, r13
	do {
		Segm.x1 = Segm.x2;
		Segm.x2 = prw(&(++Brok)->x);
    463e:	cd 01       	movw	r24, r26
    4640:	04 96       	adiw	r24, 0x04	; 4
    4642:	fc 01       	movw	r30, r24
    4644:	25 91       	lpm	r18, Z+
    4646:	34 91       	lpm	r19, Z+
    4648:	ad 01       	movw	r20, r26
    464a:	b7 01       	movw	r22, r14
    464c:	f8 01       	movw	r30, r16
    464e:	dc 01       	movw	r26, r24
    4650:	79 01       	movw	r14, r18
    4652:	00 e0       	ldi	r16, 0x00	; 0
    4654:	10 e0       	ldi	r17, 0x00	; 0
	} while(x>Segm.x2);
    4656:	ea 14       	cp	r14, r10
    4658:	fb 04       	cpc	r15, r11
    465a:	0c 05       	cpc	r16, r12
    465c:	1d 05       	cpc	r17, r13
    465e:	78 f3       	brcs	.-34     	; 0x463e <PGM_uBrokLine+0x38>
    4660:	ca 01       	movw	r24, r20
    4662:	9b 01       	movw	r18, r22
    4664:	af 01       	movw	r20, r30
    4666:	69 83       	std	Y+1, r22	; 0x01
    4668:	3a 83       	std	Y+2, r19	; 0x02
    466a:	eb 83       	std	Y+3, r30	; 0x03
    466c:	5c 83       	std	Y+4, r21	; 0x04
    466e:	ed 82       	std	Y+5, r14	; 0x05
    4670:	fe 82       	std	Y+6, r15	; 0x06
    4672:	0f 83       	std	Y+7, r16	; 0x07
    4674:	18 87       	std	Y+8, r17	; 0x08
    4676:	fc 01       	movw	r30, r24
    4678:	32 96       	adiw	r30, 0x02	; 2
    467a:	85 91       	lpm	r24, Z+
    467c:	94 91       	lpm	r25, Z+
	Segm.y1 = (int16_t)prw(&(Brok-1)->y);
    467e:	9a 87       	std	Y+10, r25	; 0x0a
    4680:	89 87       	std	Y+9, r24	; 0x09
    4682:	fd 01       	movw	r30, r26
    4684:	32 96       	adiw	r30, 0x02	; 2
    4686:	85 91       	lpm	r24, Z+
    4688:	94 91       	lpm	r25, Z+
	Segm.y2 = (int16_t)prw(&Brok->y);
    468a:	9c 87       	std	Y+12, r25	; 0x0c
    468c:	8b 87       	std	Y+11, r24	; 0x0b
	return uLineFunc(&Segm, x);
    468e:	ce 01       	movw	r24, r28
    4690:	01 96       	adiw	r24, 0x01	; 1
    4692:	b6 01       	movw	r22, r12
    4694:	a5 01       	movw	r20, r10
    4696:	0e 94 85 22 	call	0x450a	; 0x450a <uLineFunc>
}
    469a:	2c 96       	adiw	r28, 0x0c	; 12
    469c:	0f b6       	in	r0, 0x3f	; 63
    469e:	f8 94       	cli
    46a0:	de bf       	out	0x3e, r29	; 62
    46a2:	0f be       	out	0x3f, r0	; 63
    46a4:	cd bf       	out	0x3d, r28	; 61
    46a6:	cf 91       	pop	r28
    46a8:	df 91       	pop	r29
    46aa:	1f 91       	pop	r17
    46ac:	0f 91       	pop	r16
    46ae:	ff 90       	pop	r15
    46b0:	ef 90       	pop	r14
    46b2:	df 90       	pop	r13
    46b4:	cf 90       	pop	r12
    46b6:	bf 90       	pop	r11
    46b8:	af 90       	pop	r10
    46ba:	08 95       	ret

000046bc <InterBrokLine>:
	uint8_t WiAbsc, int16_t (*TblAbsc)[WiAbsc], uint8_t Absc,
	uint8_t WiOrdi, int16_t (*TblOrdi)[WiOrdi], uint8_t Ordi,
	uint8_t Len,
	int16_t x
)
{
    46bc:	2f 92       	push	r2
    46be:	3f 92       	push	r3
    46c0:	4f 92       	push	r4
    46c2:	5f 92       	push	r5
    46c4:	6f 92       	push	r6
    46c6:	7f 92       	push	r7
    46c8:	8f 92       	push	r8
    46ca:	9f 92       	push	r9
    46cc:	af 92       	push	r10
    46ce:	bf 92       	push	r11
    46d0:	cf 92       	push	r12
    46d2:	df 92       	push	r13
    46d4:	ef 92       	push	r14
    46d6:	ff 92       	push	r15
    46d8:	0f 93       	push	r16
    46da:	1f 93       	push	r17
    46dc:	df 93       	push	r29
    46de:	cf 93       	push	r28
    46e0:	cd b7       	in	r28, 0x3d	; 61
    46e2:	de b7       	in	r29, 0x3e	; 62
    46e4:	2e 97       	sbiw	r28, 0x0e	; 14
    46e6:	0f b6       	in	r0, 0x3f	; 63
    46e8:	f8 94       	cli
    46ea:	de bf       	out	0x3e, r29	; 62
    46ec:	0f be       	out	0x3f, r0	; 63
    46ee:	cd bf       	out	0x3d, r28	; 61
    46f0:	2b 01       	movw	r4, r22
    46f2:	2d 87       	std	Y+13, r18	; 0x0d
    46f4:	18 01       	movw	r2, r16
    46f6:	ee 86       	std	Y+14, r14	; 0x0e
    46f8:	7c 2d       	mov	r23, r12
	LineGraph Segm;
	uint8_t i = 0;
	Segm.x2=TblAbsc[0][Absc];
    46fa:	c4 2e       	mov	r12, r20
    46fc:	dd 24       	eor	r13, r13
    46fe:	cc 0c       	add	r12, r12
    4700:	dd 1c       	adc	r13, r13
    4702:	f2 01       	movw	r30, r4
    4704:	ec 0d       	add	r30, r12
    4706:	fd 1d       	adc	r31, r13
    4708:	20 81       	ld	r18, Z
    470a:	31 81       	ldd	r19, Z+1	; 0x01
    470c:	79 01       	movw	r14, r18
    470e:	00 27       	eor	r16, r16
    4710:	f7 fc       	sbrc	r15, 7
    4712:	00 95       	com	r16
    4714:	10 2f       	mov	r17, r16
    4716:	ed 82       	std	Y+5, r14	; 0x05
    4718:	fe 82       	std	Y+6, r15	; 0x06
    471a:	0f 83       	std	Y+7, r16	; 0x07
    471c:	18 87       	std	Y+8, r17	; 0x08
    471e:	a8 2f       	mov	r26, r24
    4720:	b0 e0       	ldi	r27, 0x00	; 0
    4722:	aa 0f       	add	r26, r26
    4724:	bb 1f       	adc	r27, r27
    4726:	35 01       	movw	r6, r10
    4728:	88 24       	eor	r8, r8
    472a:	77 fc       	sbrc	r7, 7
    472c:	80 94       	com	r8
    472e:	98 2c       	mov	r9, r8
    4730:	60 e0       	ldi	r22, 0x00	; 0
    4732:	02 c0       	rjmp	.+4      	; 0x4738 <InterBrokLine+0x7c>
	do {
		Segm.x1 = Segm.x2;
		Segm.x2 = TblAbsc[++i][Absc];
	} while(x>Segm.x2 && i<Len);
    4734:	79 01       	movw	r14, r18
    4736:	8a 01       	movw	r16, r20
	LineGraph Segm;
	uint8_t i = 0;
	Segm.x2=TblAbsc[0][Absc];
	do {
		Segm.x1 = Segm.x2;
		Segm.x2 = TblAbsc[++i][Absc];
    4738:	6f 5f       	subi	r22, 0xFF	; 255
    473a:	a6 2e       	mov	r10, r22
    473c:	bb 24       	eor	r11, r11
    473e:	aa 9e       	mul	r10, r26
    4740:	f0 01       	movw	r30, r0
    4742:	ab 9e       	mul	r10, r27
    4744:	f0 0d       	add	r31, r0
    4746:	ba 9e       	mul	r11, r26
    4748:	f0 0d       	add	r31, r0
    474a:	11 24       	eor	r1, r1
    474c:	e4 0d       	add	r30, r4
    474e:	f5 1d       	adc	r31, r5
    4750:	ec 0d       	add	r30, r12
    4752:	fd 1d       	adc	r31, r13
    4754:	80 81       	ld	r24, Z
    4756:	91 81       	ldd	r25, Z+1	; 0x01
    4758:	9c 01       	movw	r18, r24
    475a:	44 27       	eor	r20, r20
    475c:	37 fd       	sbrc	r19, 7
    475e:	40 95       	com	r20
    4760:	54 2f       	mov	r21, r20
	} while(x>Segm.x2 && i<Len);
    4762:	26 15       	cp	r18, r6
    4764:	37 05       	cpc	r19, r7
    4766:	48 05       	cpc	r20, r8
    4768:	59 05       	cpc	r21, r9
    476a:	14 f4       	brge	.+4      	; 0x4770 <InterBrokLine+0xb4>
    476c:	67 17       	cp	r22, r23
    476e:	10 f3       	brcs	.-60     	; 0x4734 <InterBrokLine+0x78>
    4770:	e9 82       	std	Y+1, r14	; 0x01
    4772:	fa 82       	std	Y+2, r15	; 0x02
    4774:	0b 83       	std	Y+3, r16	; 0x03
    4776:	1c 83       	std	Y+4, r17	; 0x04
    4778:	2d 83       	std	Y+5, r18	; 0x05
    477a:	3e 83       	std	Y+6, r19	; 0x06
    477c:	4f 83       	std	Y+7, r20	; 0x07
    477e:	58 87       	std	Y+8, r21	; 0x08
	Segm.y1 = TblOrdi[i-1][Ordi];
    4780:	8d 85       	ldd	r24, Y+13	; 0x0d
    4782:	28 2f       	mov	r18, r24
    4784:	30 e0       	ldi	r19, 0x00	; 0
    4786:	22 0f       	add	r18, r18
    4788:	33 1f       	adc	r19, r19
    478a:	8e 85       	ldd	r24, Y+14	; 0x0e
    478c:	a8 2f       	mov	r26, r24
    478e:	b0 e0       	ldi	r27, 0x00	; 0
    4790:	08 94       	sec
    4792:	a1 08       	sbc	r10, r1
    4794:	b1 08       	sbc	r11, r1
    4796:	a2 9e       	mul	r10, r18
    4798:	f0 01       	movw	r30, r0
    479a:	a3 9e       	mul	r10, r19
    479c:	f0 0d       	add	r31, r0
    479e:	b2 9e       	mul	r11, r18
    47a0:	f0 0d       	add	r31, r0
    47a2:	11 24       	eor	r1, r1
    47a4:	08 94       	sec
    47a6:	a1 1c       	adc	r10, r1
    47a8:	b1 1c       	adc	r11, r1
    47aa:	e2 0d       	add	r30, r2
    47ac:	f3 1d       	adc	r31, r3
    47ae:	aa 0f       	add	r26, r26
    47b0:	bb 1f       	adc	r27, r27
    47b2:	ea 0f       	add	r30, r26
    47b4:	fb 1f       	adc	r31, r27
    47b6:	80 81       	ld	r24, Z
    47b8:	91 81       	ldd	r25, Z+1	; 0x01
    47ba:	9a 87       	std	Y+10, r25	; 0x0a
    47bc:	89 87       	std	Y+9, r24	; 0x09
	Segm.y2 = TblOrdi[i][Ordi];
    47be:	a2 9e       	mul	r10, r18
    47c0:	c0 01       	movw	r24, r0
    47c2:	a3 9e       	mul	r10, r19
    47c4:	90 0d       	add	r25, r0
    47c6:	b2 9e       	mul	r11, r18
    47c8:	90 0d       	add	r25, r0
    47ca:	11 24       	eor	r1, r1
    47cc:	82 0d       	add	r24, r2
    47ce:	93 1d       	adc	r25, r3
    47d0:	a8 0f       	add	r26, r24
    47d2:	b9 1f       	adc	r27, r25
    47d4:	8d 91       	ld	r24, X+
    47d6:	9c 91       	ld	r25, X
    47d8:	9c 87       	std	Y+12, r25	; 0x0c
    47da:	8b 87       	std	Y+11, r24	; 0x0b
	return LineFunc(&Segm, x);
    47dc:	ce 01       	movw	r24, r28
    47de:	01 96       	adiw	r24, 0x01	; 1
    47e0:	b4 01       	movw	r22, r8
    47e2:	a3 01       	movw	r20, r6
    47e4:	0e 94 07 22 	call	0x440e	; 0x440e <LineFunc>
}
    47e8:	2e 96       	adiw	r28, 0x0e	; 14
    47ea:	0f b6       	in	r0, 0x3f	; 63
    47ec:	f8 94       	cli
    47ee:	de bf       	out	0x3e, r29	; 62
    47f0:	0f be       	out	0x3f, r0	; 63
    47f2:	cd bf       	out	0x3d, r28	; 61
    47f4:	cf 91       	pop	r28
    47f6:	df 91       	pop	r29
    47f8:	1f 91       	pop	r17
    47fa:	0f 91       	pop	r16
    47fc:	ff 90       	pop	r15
    47fe:	ef 90       	pop	r14
    4800:	df 90       	pop	r13
    4802:	cf 90       	pop	r12
    4804:	bf 90       	pop	r11
    4806:	af 90       	pop	r10
    4808:	9f 90       	pop	r9
    480a:	8f 90       	pop	r8
    480c:	7f 90       	pop	r7
    480e:	6f 90       	pop	r6
    4810:	5f 90       	pop	r5
    4812:	4f 90       	pop	r4
    4814:	3f 90       	pop	r3
    4816:	2f 90       	pop	r2
    4818:	08 95       	ret

0000481a <TWI_Init>:
}

uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    481a:	90 91 cf 02 	lds	r25, 0x02CF
	VacantTimer8Sys += n;
    481e:	89 2f       	mov	r24, r25
    4820:	8f 5f       	subi	r24, 0xFF	; 255

// ~~~~~~~~~~~
void
TWI_Init(void)
{
	TD_TWI_Poll = Timer8SysAlloc(1);
    4822:	90 93 d2 04 	sts	0x04D2, r25
    4826:	8f 5f       	subi	r24, 0xFF	; 255
    4828:	80 93 cf 02 	sts	0x02CF, r24
    482c:	81 50       	subi	r24, 0x01	; 1
	TD_TWI_Timeout = Timer8SysAlloc(1);
    482e:	80 93 d3 04 	sts	0x04D3, r24

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    4832:	80 91 d0 02 	lds	r24, 0x02D0
	VacantTimer16Sys += n;
    4836:	8f 5f       	subi	r24, 0xFF	; 255
    4838:	80 93 d0 02 	sts	0x02D0, r24
    483c:	81 50       	subi	r24, 0x01	; 1
	TD_RTC_Check = Timer16SysAlloc(1);
    483e:	80 93 d4 04 	sts	0x04D4, r24
	StartTimer16(TD_RTC_Check, 300);
    4842:	6c e2       	ldi	r22, 0x2C	; 44
    4844:	71 e0       	ldi	r23, 0x01	; 1
    4846:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
	TWBR = 144;	//50
    484a:	80 e9       	ldi	r24, 0x90	; 144
    484c:	80 93 b8 00 	sts	0x00B8, r24
}
    4850:	08 95       	ret

00004852 <TWI_Error>:
// ~~~~~~~~~~~
void
TWI_Error(void)
{
	TWI_Error_Counter++;
    4852:	80 91 e4 08 	lds	r24, 0x08E4
    4856:	90 91 e5 08 	lds	r25, 0x08E5
    485a:	01 96       	adiw	r24, 0x01	; 1
    485c:	90 93 e5 08 	sts	0x08E5, r25
    4860:	80 93 e4 08 	sts	0x08E4, r24
	//StopTWI();
	PowerOffTWI();
    4864:	10 92 bc 00 	sts	0x00BC, r1
	TWI_Phase = PCF_START;
    4868:	10 92 c3 07 	sts	0x07C3, r1
	StartTimer8(TD_TWI_Poll, 49);
    486c:	80 91 d2 04 	lds	r24, 0x04D2
    4870:	61 e3       	ldi	r22, 0x31	; 49
    4872:	0e 94 a1 1b 	call	0x3742	; 0x3742 <StartTimer8>
}
    4876:	08 95       	ret

00004878 <WriteRTC>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
WriteRTC(uint8_t Addr, uint8_t Dat)
{
    4878:	bf 92       	push	r11
    487a:	cf 92       	push	r12
    487c:	df 92       	push	r13
    487e:	ef 92       	push	r14
    4880:	ff 92       	push	r15
    4882:	0f 93       	push	r16
    4884:	1f 93       	push	r17
/*	if (!(TWCR &(1<<TWINT))){ //Wait for the end of current TWI operation and isuue STOP
		_delay_us(100);
		StopTWI();
		_delay_us(50);
	}*/
	PowerOffTWI();
    4886:	4c eb       	ldi	r20, 0xBC	; 188
    4888:	c4 2e       	mov	r12, r20
    488a:	d1 2c       	mov	r13, r1
    488c:	f6 01       	movw	r30, r12
    488e:	10 82       	st	Z, r1
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    4890:	e0 e9       	ldi	r30, 0x90	; 144
    4892:	f1 e0       	ldi	r31, 0x01	; 1
    4894:	31 97       	sbiw	r30, 0x01	; 1
    4896:	f1 f7       	brne	.-4      	; 0x4894 <WriteRTC+0x1c>
	_delay_us(100);
	//_delay_us(150);_delay_us(150);
	StartTWI();
    4898:	94 ea       	ldi	r25, 0xA4	; 164
    489a:	f6 01       	movw	r30, r12
    489c:	90 83       	st	Z, r25
    489e:	08 e5       	ldi	r16, 0x58	; 88
    48a0:	12 e0       	ldi	r17, 0x02	; 2
    48a2:	f8 01       	movw	r30, r16
    48a4:	31 97       	sbiw	r30, 0x01	; 1
    48a6:	f1 f7       	brne	.-4      	; 0x48a4 <WriteRTC+0x2c>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = SLA_W(PCF_SLA);
    48a8:	f8 01       	movw	r30, r16
    48aa:	31 97       	sbiw	r30, 0x01	; 1
    48ac:	f1 f7       	brne	.-4      	; 0x48aa <WriteRTC+0x32>
    48ae:	3b eb       	ldi	r19, 0xBB	; 187
    48b0:	e3 2e       	mov	r14, r19
    48b2:	f1 2c       	mov	r15, r1
    48b4:	90 ed       	ldi	r25, 0xD0	; 208
    48b6:	f7 01       	movw	r30, r14
    48b8:	90 83       	st	Z, r25
    48ba:	90 81       	ld	r25, Z
    48bc:	90 83       	st	Z, r25
	RunTWI();
    48be:	24 e8       	ldi	r18, 0x84	; 132
    48c0:	b2 2e       	mov	r11, r18
    48c2:	f6 01       	movw	r30, r12
    48c4:	b0 82       	st	Z, r11
    48c6:	f8 01       	movw	r30, r16
    48c8:	31 97       	sbiw	r30, 0x01	; 1
    48ca:	f1 f7       	brne	.-4      	; 0x48c8 <WriteRTC+0x50>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = AddrSec+Addr;
    48cc:	f8 01       	movw	r30, r16
    48ce:	31 97       	sbiw	r30, 0x01	; 1
    48d0:	f1 f7       	brne	.-4      	; 0x48ce <WriteRTC+0x56>
    48d2:	f7 01       	movw	r30, r14
    48d4:	80 83       	st	Z, r24
	RunTWI();
    48d6:	f6 01       	movw	r30, r12
    48d8:	b0 82       	st	Z, r11
    48da:	c8 01       	movw	r24, r16
    48dc:	01 97       	sbiw	r24, 0x01	; 1
    48de:	f1 f7       	brne	.-4      	; 0x48dc <WriteRTC+0x64>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = CodBCD(Dat);
    48e0:	c8 01       	movw	r24, r16
    48e2:	01 97       	sbiw	r24, 0x01	; 1
    48e4:	f1 f7       	brne	.-4      	; 0x48e2 <WriteRTC+0x6a>
    48e6:	86 2f       	mov	r24, r22
    48e8:	0e 94 f0 21 	call	0x43e0	; 0x43e0 <CodBCD>
    48ec:	f7 01       	movw	r30, r14
    48ee:	80 83       	st	Z, r24
	RunTWI();
    48f0:	f6 01       	movw	r30, r12
    48f2:	b0 82       	st	Z, r11
    48f4:	c8 01       	movw	r24, r16
    48f6:	01 97       	sbiw	r24, 0x01	; 1
    48f8:	f1 f7       	brne	.-4      	; 0x48f6 <WriteRTC+0x7e>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	StopTWI();
    48fa:	c8 01       	movw	r24, r16
    48fc:	01 97       	sbiw	r24, 0x01	; 1
    48fe:	f1 f7       	brne	.-4      	; 0x48fc <WriteRTC+0x84>
    4900:	84 e9       	ldi	r24, 0x94	; 148
    4902:	80 83       	st	Z, r24
	TWI_Phase = PCF_START;
    4904:	10 92 c3 07 	sts	0x07C3, r1
}
    4908:	1f 91       	pop	r17
    490a:	0f 91       	pop	r16
    490c:	ff 90       	pop	r15
    490e:	ef 90       	pop	r14
    4910:	df 90       	pop	r13
    4912:	cf 90       	pop	r12
    4914:	bf 90       	pop	r11
    4916:	08 95       	ret

00004918 <SetWeekday>:
*/

// ~~~~~~~~~~~~~~~
// 31.12.00 was Su
uint8_t SetWeekday(uint8_t Year, uint8_t Month, uint8_t MDay)
{
    4918:	a6 2f       	mov	r26, r22
	uint8_t DayCount;
	uint8_t LastYear = Year-1;
    491a:	b8 2f       	mov	r27, r24
    491c:	b1 50       	subi	r27, 0x01	; 1

	DayCount = (LastYear+LastYear/4);
    491e:	5b 2f       	mov	r21, r27
    4920:	56 95       	lsr	r21
    4922:	56 95       	lsr	r21
    4924:	5b 0f       	add	r21, r27
	for (uint8_t i=1; i<Month; DayCount+=prb(DaysMonth+i++)%7);
    4926:	62 30       	cpi	r22, 0x02	; 2
    4928:	88 f0       	brcs	.+34     	; 0x494c <SetWeekday+0x34>
    492a:	e4 e2       	ldi	r30, 0x24	; 36
    492c:	f3 e0       	ldi	r31, 0x03	; 3
    492e:	a2 50       	subi	r26, 0x02	; 2
    4930:	2a 2f       	mov	r18, r26
    4932:	30 e0       	ldi	r19, 0x00	; 0
    4934:	ae 5f       	subi	r26, 0xFE	; 254
    4936:	2b 5d       	subi	r18, 0xDB	; 219
    4938:	3c 4f       	sbci	r19, 0xFC	; 252

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    493a:	84 91       	lpm	r24, Z+
    493c:	67 e0       	ldi	r22, 0x07	; 7
    493e:	0e 94 72 84 	call	0x108e4	; 0x108e4 <__udivmodqi4>
    4942:	59 0f       	add	r21, r25
    4944:	31 96       	adiw	r30, 0x01	; 1
    4946:	e2 17       	cp	r30, r18
    4948:	f3 07       	cpc	r31, r19
    494a:	b9 f7       	brne	.-18     	; 0x493a <SetWeekday+0x22>
    494c:	25 2f       	mov	r18, r21
	if (LastYear%4==3 && Month>2)
    494e:	b3 70       	andi	r27, 0x03	; 3
    4950:	b3 30       	cpi	r27, 0x03	; 3
    4952:	51 f0       	breq	.+20     	; 0x4968 <SetWeekday+0x50>
		DayCount++;
    4954:	84 2f       	mov	r24, r20
    4956:	67 e0       	ldi	r22, 0x07	; 7
    4958:	0e 94 72 84 	call	0x108e4	; 0x108e4 <__udivmodqi4>
    495c:	82 2f       	mov	r24, r18
    495e:	89 0f       	add	r24, r25
    4960:	0e 94 72 84 	call	0x108e4	; 0x108e4 <__udivmodqi4>
	DayCount += MDay%7;
	return DayCount%7;
}
    4964:	89 2f       	mov	r24, r25
    4966:	08 95       	ret
	uint8_t DayCount;
	uint8_t LastYear = Year-1;

	DayCount = (LastYear+LastYear/4);
	for (uint8_t i=1; i<Month; DayCount+=prb(DaysMonth+i++)%7);
	if (LastYear%4==3 && Month>2)
    4968:	a3 30       	cpi	r26, 0x03	; 3
    496a:	a0 f3       	brcs	.-24     	; 0x4954 <SetWeekday+0x3c>
		DayCount++;
    496c:	2f 5f       	subi	r18, 0xFF	; 255
    496e:	f2 cf       	rjmp	.-28     	; 0x4954 <SetWeekday+0x3c>

00004970 <SetSec>:
}
// ~~~~~~~~~
void
SetSec(void)
{
	WriteRTC(0, Tm_Sec);
    4970:	80 e0       	ldi	r24, 0x00	; 0
    4972:	60 91 f7 06 	lds	r22, 0x06F7
    4976:	0e 94 3c 24 	call	0x4878	; 0x4878 <WriteRTC>
	TrueTime_Sec = Tm_Sec;
    497a:	80 91 f7 06 	lds	r24, 0x06F7
    497e:	80 93 13 09 	sts	0x0913, r24
}
    4982:	08 95       	ret

00004984 <SetMin>:

// ~~~~~~~~~
void
SetMin(void)
{
	WriteRTC(1, Tm_Min);
    4984:	81 e0       	ldi	r24, 0x01	; 1
    4986:	60 91 51 06 	lds	r22, 0x0651
    498a:	0e 94 3c 24 	call	0x4878	; 0x4878 <WriteRTC>
	TrueTime_Min = Tm_Min;
    498e:	80 91 51 06 	lds	r24, 0x0651
    4992:	80 93 15 09 	sts	0x0915, r24
}
    4996:	08 95       	ret

00004998 <SetHour>:

// ~~~~~~~~~~
void
SetHour(void)
{
	WriteRTC(2,  Tm_Hour);
    4998:	82 e0       	ldi	r24, 0x02	; 2
    499a:	60 91 c1 05 	lds	r22, 0x05C1
    499e:	0e 94 3c 24 	call	0x4878	; 0x4878 <WriteRTC>
	TrueTime_Hour = Tm_Hour;
    49a2:	80 91 c1 05 	lds	r24, 0x05C1
    49a6:	80 93 d8 05 	sts	0x05D8, r24
}
    49aa:	08 95       	ret

000049ac <SetMDay>:
// ~~~~~~~~~~
void
SetMDay(void)
{
	WriteRTC(4,  Tm_MDay);
    49ac:	84 e0       	ldi	r24, 0x04	; 4
    49ae:	60 91 5e 0b 	lds	r22, 0x0B5E
    49b2:	0e 94 3c 24 	call	0x4878	; 0x4878 <WriteRTC>
	TrueTime_MDay = Tm_MDay;
    49b6:	80 91 5e 0b 	lds	r24, 0x0B5E
    49ba:	80 93 56 06 	sts	0x0656, r24
}
    49be:	08 95       	ret

000049c0 <SetMon>:
// ~~~~~~~~~
void
SetMon(void)
{
	WriteRTC(5, Tm_Mon);
    49c0:	85 e0       	ldi	r24, 0x05	; 5
    49c2:	60 91 cb 07 	lds	r22, 0x07CB
    49c6:	0e 94 3c 24 	call	0x4878	; 0x4878 <WriteRTC>
	TrueTime_Mon = Tm_Mon;
    49ca:	80 91 cb 07 	lds	r24, 0x07CB
    49ce:	80 93 14 09 	sts	0x0914, r24
}
    49d2:	08 95       	ret

000049d4 <SetYear>:
// ~~~~~~~~~~~~~
void
SetYear(void)
{
	WriteRTC(6, Tm_Year);
    49d4:	86 e0       	ldi	r24, 0x06	; 6
    49d6:	60 91 de 05 	lds	r22, 0x05DE
    49da:	0e 94 3c 24 	call	0x4878	; 0x4878 <WriteRTC>
	TrueTime_Year = Tm_Year;
    49de:	80 91 de 05 	lds	r24, 0x05DE
    49e2:	80 93 c1 07 	sts	0x07C1, r24
}
    49e6:	08 95       	ret

000049e8 <SetDateTime>:
// ~~~~~~~~~~~~~
void
SetDateTime(uint8_t Year, uint8_t Month, uint8_t Day, uint8_t WDay, uint8_t Hour, uint8_t Min, uint8_t Sec){
    49e8:	5f 92       	push	r5
    49ea:	6f 92       	push	r6
    49ec:	7f 92       	push	r7
    49ee:	8f 92       	push	r8
    49f0:	9f 92       	push	r9
    49f2:	af 92       	push	r10
    49f4:	bf 92       	push	r11
    49f6:	cf 92       	push	r12
    49f8:	df 92       	push	r13
    49fa:	ef 92       	push	r14
    49fc:	ff 92       	push	r15
    49fe:	0f 93       	push	r16
    4a00:	1f 93       	push	r17
    4a02:	58 2e       	mov	r5, r24
    4a04:	66 2e       	mov	r6, r22
    4a06:	74 2e       	mov	r7, r20
    4a08:	f2 2e       	mov	r15, r18
    4a0a:	8c 2d       	mov	r24, r12
	PowerOffTWI();
    4a0c:	7c eb       	ldi	r23, 0xBC	; 188
    4a0e:	87 2e       	mov	r8, r23
    4a10:	91 2c       	mov	r9, r1
    4a12:	f4 01       	movw	r30, r8
    4a14:	10 82       	st	Z, r1
    4a16:	e0 e9       	ldi	r30, 0x90	; 144
    4a18:	f1 e0       	ldi	r31, 0x01	; 1
    4a1a:	31 97       	sbiw	r30, 0x01	; 1
    4a1c:	f1 f7       	brne	.-4      	; 0x4a1a <SetDateTime+0x32>
	_delay_us(100);
	//_delay_us(150);_delay_us(150);
	StartTWI();
    4a1e:	94 ea       	ldi	r25, 0xA4	; 164
    4a20:	f4 01       	movw	r30, r8
    4a22:	90 83       	st	Z, r25
    4a24:	68 e5       	ldi	r22, 0x58	; 88
    4a26:	c6 2e       	mov	r12, r22
    4a28:	62 e0       	ldi	r22, 0x02	; 2
    4a2a:	d6 2e       	mov	r13, r22
    4a2c:	f6 01       	movw	r30, r12
    4a2e:	31 97       	sbiw	r30, 0x01	; 1
    4a30:	f1 f7       	brne	.-4      	; 0x4a2e <SetDateTime+0x46>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = SLA_W(PCF_SLA);
    4a32:	f6 01       	movw	r30, r12
    4a34:	31 97       	sbiw	r30, 0x01	; 1
    4a36:	f1 f7       	brne	.-4      	; 0x4a34 <SetDateTime+0x4c>
    4a38:	5b eb       	ldi	r21, 0xBB	; 187
    4a3a:	a5 2e       	mov	r10, r21
    4a3c:	b1 2c       	mov	r11, r1
    4a3e:	90 ed       	ldi	r25, 0xD0	; 208
    4a40:	f5 01       	movw	r30, r10
    4a42:	90 83       	st	Z, r25
    4a44:	90 81       	ld	r25, Z
    4a46:	90 83       	st	Z, r25
	RunTWI();
    4a48:	14 e8       	ldi	r17, 0x84	; 132
    4a4a:	f4 01       	movw	r30, r8
    4a4c:	10 83       	st	Z, r17
    4a4e:	f6 01       	movw	r30, r12
    4a50:	31 97       	sbiw	r30, 0x01	; 1
    4a52:	f1 f7       	brne	.-4      	; 0x4a50 <SetDateTime+0x68>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = AddrSec;
    4a54:	f6 01       	movw	r30, r12
    4a56:	31 97       	sbiw	r30, 0x01	; 1
    4a58:	f1 f7       	brne	.-4      	; 0x4a56 <SetDateTime+0x6e>
    4a5a:	f5 01       	movw	r30, r10
    4a5c:	10 82       	st	Z, r1
	RunTWI();
    4a5e:	f4 01       	movw	r30, r8
    4a60:	10 83       	st	Z, r17
    4a62:	f6 01       	movw	r30, r12
    4a64:	31 97       	sbiw	r30, 0x01	; 1
    4a66:	f1 f7       	brne	.-4      	; 0x4a64 <SetDateTime+0x7c>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = CodBCD(Sec);
    4a68:	f6 01       	movw	r30, r12
    4a6a:	31 97       	sbiw	r30, 0x01	; 1
    4a6c:	f1 f7       	brne	.-4      	; 0x4a6a <SetDateTime+0x82>
    4a6e:	0e 94 f0 21 	call	0x43e0	; 0x43e0 <CodBCD>
    4a72:	f5 01       	movw	r30, r10
    4a74:	80 83       	st	Z, r24
	RunTWI();
    4a76:	f4 01       	movw	r30, r8
    4a78:	10 83       	st	Z, r17
    4a7a:	c6 01       	movw	r24, r12
    4a7c:	01 97       	sbiw	r24, 0x01	; 1
    4a7e:	f1 f7       	brne	.-4      	; 0x4a7c <SetDateTime+0x94>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = CodBCD(Min);
    4a80:	c6 01       	movw	r24, r12
    4a82:	01 97       	sbiw	r24, 0x01	; 1
    4a84:	f1 f7       	brne	.-4      	; 0x4a82 <SetDateTime+0x9a>
    4a86:	8e 2d       	mov	r24, r14
    4a88:	0e 94 f0 21 	call	0x43e0	; 0x43e0 <CodBCD>
    4a8c:	f5 01       	movw	r30, r10
    4a8e:	80 83       	st	Z, r24
	RunTWI();
    4a90:	f4 01       	movw	r30, r8
    4a92:	10 83       	st	Z, r17
    4a94:	c6 01       	movw	r24, r12
    4a96:	01 97       	sbiw	r24, 0x01	; 1
    4a98:	f1 f7       	brne	.-4      	; 0x4a96 <SetDateTime+0xae>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = CodBCD(Hour);
    4a9a:	c6 01       	movw	r24, r12
    4a9c:	01 97       	sbiw	r24, 0x01	; 1
    4a9e:	f1 f7       	brne	.-4      	; 0x4a9c <SetDateTime+0xb4>
    4aa0:	80 2f       	mov	r24, r16
    4aa2:	0e 94 f0 21 	call	0x43e0	; 0x43e0 <CodBCD>
    4aa6:	f5 01       	movw	r30, r10
    4aa8:	80 83       	st	Z, r24
	RunTWI();
    4aaa:	f4 01       	movw	r30, r8
    4aac:	10 83       	st	Z, r17
    4aae:	c6 01       	movw	r24, r12
    4ab0:	01 97       	sbiw	r24, 0x01	; 1
    4ab2:	f1 f7       	brne	.-4      	; 0x4ab0 <SetDateTime+0xc8>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = WDay;
    4ab4:	c6 01       	movw	r24, r12
    4ab6:	01 97       	sbiw	r24, 0x01	; 1
    4ab8:	f1 f7       	brne	.-4      	; 0x4ab6 <SetDateTime+0xce>
    4aba:	f5 01       	movw	r30, r10
    4abc:	f0 82       	st	Z, r15
	RunTWI();
    4abe:	f4 01       	movw	r30, r8
    4ac0:	10 83       	st	Z, r17
    4ac2:	c6 01       	movw	r24, r12
    4ac4:	01 97       	sbiw	r24, 0x01	; 1
    4ac6:	f1 f7       	brne	.-4      	; 0x4ac4 <SetDateTime+0xdc>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = CodBCD(Day);
    4ac8:	c6 01       	movw	r24, r12
    4aca:	01 97       	sbiw	r24, 0x01	; 1
    4acc:	f1 f7       	brne	.-4      	; 0x4aca <SetDateTime+0xe2>
    4ace:	87 2d       	mov	r24, r7
    4ad0:	0e 94 f0 21 	call	0x43e0	; 0x43e0 <CodBCD>
    4ad4:	f5 01       	movw	r30, r10
    4ad6:	80 83       	st	Z, r24
	RunTWI();
    4ad8:	f4 01       	movw	r30, r8
    4ada:	10 83       	st	Z, r17
    4adc:	c6 01       	movw	r24, r12
    4ade:	01 97       	sbiw	r24, 0x01	; 1
    4ae0:	f1 f7       	brne	.-4      	; 0x4ade <SetDateTime+0xf6>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = CodBCD(Month);
    4ae2:	c6 01       	movw	r24, r12
    4ae4:	01 97       	sbiw	r24, 0x01	; 1
    4ae6:	f1 f7       	brne	.-4      	; 0x4ae4 <SetDateTime+0xfc>
    4ae8:	86 2d       	mov	r24, r6
    4aea:	0e 94 f0 21 	call	0x43e0	; 0x43e0 <CodBCD>
    4aee:	f5 01       	movw	r30, r10
    4af0:	80 83       	st	Z, r24
	RunTWI();
    4af2:	f4 01       	movw	r30, r8
    4af4:	10 83       	st	Z, r17
    4af6:	c6 01       	movw	r24, r12
    4af8:	01 97       	sbiw	r24, 0x01	; 1
    4afa:	f1 f7       	brne	.-4      	; 0x4af8 <SetDateTime+0x110>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = CodBCD(Year);
    4afc:	c6 01       	movw	r24, r12
    4afe:	01 97       	sbiw	r24, 0x01	; 1
    4b00:	f1 f7       	brne	.-4      	; 0x4afe <SetDateTime+0x116>
    4b02:	85 2d       	mov	r24, r5
    4b04:	0e 94 f0 21 	call	0x43e0	; 0x43e0 <CodBCD>
    4b08:	f5 01       	movw	r30, r10
    4b0a:	80 83       	st	Z, r24
	RunTWI();
    4b0c:	f4 01       	movw	r30, r8
    4b0e:	10 83       	st	Z, r17
    4b10:	c6 01       	movw	r24, r12
    4b12:	01 97       	sbiw	r24, 0x01	; 1
    4b14:	f1 f7       	brne	.-4      	; 0x4b12 <SetDateTime+0x12a>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	StopTWI();
    4b16:	c6 01       	movw	r24, r12
    4b18:	01 97       	sbiw	r24, 0x01	; 1
    4b1a:	f1 f7       	brne	.-4      	; 0x4b18 <SetDateTime+0x130>
    4b1c:	84 e9       	ldi	r24, 0x94	; 148
    4b1e:	80 83       	st	Z, r24
	TWI_Phase = PCF_START;
    4b20:	10 92 c3 07 	sts	0x07C3, r1
}
    4b24:	1f 91       	pop	r17
    4b26:	0f 91       	pop	r16
    4b28:	ff 90       	pop	r15
    4b2a:	ef 90       	pop	r14
    4b2c:	df 90       	pop	r13
    4b2e:	cf 90       	pop	r12
    4b30:	bf 90       	pop	r11
    4b32:	af 90       	pop	r10
    4b34:	9f 90       	pop	r9
    4b36:	8f 90       	pop	r8
    4b38:	7f 90       	pop	r7
    4b3a:	6f 90       	pop	r6
    4b3c:	5f 90       	pop	r5
    4b3e:	08 95       	ret

00004b40 <RTC_Ready>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t RTC_Ready(void){
    4b40:	90 e0       	ldi	r25, 0x00	; 0
    4b42:	80 91 c3 07 	lds	r24, 0x07C3
    4b46:	88 23       	and	r24, r24
    4b48:	09 f4       	brne	.+2      	; 0x4b4c <RTC_Ready+0xc>
    4b4a:	91 e0       	ldi	r25, 0x01	; 1
	if(TWI_Phase == PCF_START) return 1;
	else return 0;
}
    4b4c:	89 2f       	mov	r24, r25
    4b4e:	08 95       	ret

00004b50 <RTC_GetTrueTime>:
void RTC_GetTrueTime(void){
	TrueTime_Sec = Tm_Sec;
    4b50:	80 91 f7 06 	lds	r24, 0x06F7
    4b54:	80 93 13 09 	sts	0x0913, r24
	TrueTime_Min = Tm_Min;
    4b58:	80 91 51 06 	lds	r24, 0x0651
    4b5c:	80 93 15 09 	sts	0x0915, r24
	TrueTime_Hour = Tm_Hour;
    4b60:	80 91 c1 05 	lds	r24, 0x05C1
    4b64:	80 93 d8 05 	sts	0x05D8, r24
	TrueTime_MDay = Tm_MDay;
    4b68:	40 91 5e 0b 	lds	r20, 0x0B5E
    4b6c:	40 93 56 06 	sts	0x0656, r20
	TrueTime_Mon = Tm_Mon;
    4b70:	60 91 cb 07 	lds	r22, 0x07CB
    4b74:	60 93 14 09 	sts	0x0914, r22
	TrueTime_Year = Tm_Year;
    4b78:	80 91 de 05 	lds	r24, 0x05DE
    4b7c:	80 93 c1 07 	sts	0x07C1, r24
	TrueTime_WDay = SetWeekday(TrueTime_Year, TrueTime_Mon, TrueTime_MDay);
    4b80:	0e 94 8c 24 	call	0x4918	; 0x4918 <SetWeekday>
    4b84:	80 93 5d 0b 	sts	0x0B5D, r24
}
    4b88:	08 95       	ret

00004b8a <RTC_SetTrueTime>:
void RTC_SetTrueTime(uint8_t Year, uint8_t Month, uint8_t Day, uint8_t WDay, uint8_t Hour, uint8_t Min, uint8_t Sec){
    4b8a:	8f 92       	push	r8
    4b8c:	9f 92       	push	r9
    4b8e:	af 92       	push	r10
    4b90:	bf 92       	push	r11
    4b92:	cf 92       	push	r12
    4b94:	df 92       	push	r13
    4b96:	ef 92       	push	r14
    4b98:	ff 92       	push	r15
    4b9a:	0f 93       	push	r16
    4b9c:	1f 93       	push	r17
    4b9e:	88 2e       	mov	r8, r24
    4ba0:	a6 2e       	mov	r10, r22
    4ba2:	b4 2e       	mov	r11, r20
    4ba4:	92 2e       	mov	r9, r18
    4ba6:	d0 2e       	mov	r13, r16
    4ba8:	fe 2c       	mov	r15, r14
    4baa:	1c 2d       	mov	r17, r12
	SetDateTime(Year, Month, Day, WDay, Hour, Min, Sec);
    4bac:	0e 94 f4 24 	call	0x49e8	; 0x49e8 <SetDateTime>
	TrueTime_Sec = Sec;
    4bb0:	10 93 13 09 	sts	0x0913, r17
	TrueTime_Min = Min;
    4bb4:	f0 92 15 09 	sts	0x0915, r15
	TrueTime_Hour = Hour;
    4bb8:	d0 92 d8 05 	sts	0x05D8, r13
	TrueTime_MDay = Day;
    4bbc:	b0 92 56 06 	sts	0x0656, r11
	TrueTime_Mon = Month;
    4bc0:	a0 92 14 09 	sts	0x0914, r10
	TrueTime_Year = Year;
    4bc4:	80 92 c1 07 	sts	0x07C1, r8
	TrueTime_WDay = WDay;
    4bc8:	90 92 5d 0b 	sts	0x0B5D, r9
}
    4bcc:	1f 91       	pop	r17
    4bce:	0f 91       	pop	r16
    4bd0:	ff 90       	pop	r15
    4bd2:	ef 90       	pop	r14
    4bd4:	df 90       	pop	r13
    4bd6:	cf 90       	pop	r12
    4bd8:	bf 90       	pop	r11
    4bda:	af 90       	pop	r10
    4bdc:	9f 90       	pop	r9
    4bde:	8f 90       	pop	r8
    4be0:	08 95       	ret

00004be2 <RTC_Check>:

//  3 

uint8_t RTC_Check(void){

	if( (Tm_Year == TrueTime_Year)  && (Tm_Mon == TrueTime_Mon) && (Tm_MDay == TrueTime_MDay) &&
    4be2:	50 91 de 05 	lds	r21, 0x05DE
    4be6:	40 91 c1 07 	lds	r20, 0x07C1
    4bea:	54 17       	cp	r21, r20
    4bec:	59 f1       	breq	.+86     	; 0x4c44 <RTC_Check+0x62>
    4bee:	90 91 13 09 	lds	r25, 0x0913
			(Tm_Hour == TrueTime_Hour) && (Tm_Min == TrueTime_Min) && (Tm_Sec == TrueTime_Sec) ) return 1;

	if(TrueTime_Sec>55){
    4bf2:	98 33       	cpi	r25, 0x38	; 56
    4bf4:	58 f0       	brcs	.+22     	; 0x4c0c <RTC_Check+0x2a>
		if(TrueTime_Min == 59){
    4bf6:	80 91 15 09 	lds	r24, 0x0915
    4bfa:	8b 33       	cpi	r24, 0x3B	; 59
    4bfc:	09 f4       	brne	.+2      	; 0x4c00 <RTC_Check+0x1e>
    4bfe:	5a c0       	rjmp	.+180    	; 0x4cb4 <RTC_Check+0xd2>
			else{
				if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ) return 1;
			}
		}
		else{
			if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ||
    4c00:	54 17       	cp	r21, r20
    4c02:	09 f4       	brne	.+2      	; 0x4c06 <RTC_Check+0x24>
    4c04:	40 c0       	rjmp	.+128    	; 0x4c86 <RTC_Check+0xa4>
				(Tm_Hour != TrueTime_Hour) ) return 1;		
		}
	}
	else{
		if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ||
    4c06:	21 e0       	ldi	r18, 0x01	; 1
			(Tm_Hour != TrueTime_Hour) || (Tm_Min != TrueTime_Min) ) return 1;
	}
	
	return 0;
}
    4c08:	82 2f       	mov	r24, r18
    4c0a:	08 95       	ret
			if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ||
				(Tm_Hour != TrueTime_Hour) ) return 1;		
		}
	}
	else{
		if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ||
    4c0c:	54 17       	cp	r21, r20
    4c0e:	d9 f7       	brne	.-10     	; 0x4c06 <RTC_Check+0x24>
    4c10:	90 91 cb 07 	lds	r25, 0x07CB
    4c14:	80 91 14 09 	lds	r24, 0x0914
    4c18:	98 17       	cp	r25, r24
    4c1a:	a9 f7       	brne	.-22     	; 0x4c06 <RTC_Check+0x24>
    4c1c:	90 91 5e 0b 	lds	r25, 0x0B5E
    4c20:	80 91 56 06 	lds	r24, 0x0656
    4c24:	98 17       	cp	r25, r24
    4c26:	79 f7       	brne	.-34     	; 0x4c06 <RTC_Check+0x24>
    4c28:	90 91 c1 05 	lds	r25, 0x05C1
    4c2c:	80 91 d8 05 	lds	r24, 0x05D8
    4c30:	98 17       	cp	r25, r24
    4c32:	49 f7       	brne	.-46     	; 0x4c06 <RTC_Check+0x24>
    4c34:	20 e0       	ldi	r18, 0x00	; 0
    4c36:	90 91 51 06 	lds	r25, 0x0651
    4c3a:	80 91 15 09 	lds	r24, 0x0915
    4c3e:	98 17       	cp	r25, r24
    4c40:	11 f7       	brne	.-60     	; 0x4c06 <RTC_Check+0x24>
    4c42:	e2 cf       	rjmp	.-60     	; 0x4c08 <RTC_Check+0x26>

//  3 

uint8_t RTC_Check(void){

	if( (Tm_Year == TrueTime_Year)  && (Tm_Mon == TrueTime_Mon) && (Tm_MDay == TrueTime_MDay) &&
    4c44:	90 91 cb 07 	lds	r25, 0x07CB
    4c48:	80 91 14 09 	lds	r24, 0x0914
    4c4c:	98 17       	cp	r25, r24
    4c4e:	79 f6       	brne	.-98     	; 0x4bee <RTC_Check+0xc>
    4c50:	90 91 5e 0b 	lds	r25, 0x0B5E
    4c54:	80 91 56 06 	lds	r24, 0x0656
    4c58:	98 17       	cp	r25, r24
    4c5a:	49 f6       	brne	.-110    	; 0x4bee <RTC_Check+0xc>
    4c5c:	90 91 c1 05 	lds	r25, 0x05C1
    4c60:	80 91 d8 05 	lds	r24, 0x05D8
    4c64:	98 17       	cp	r25, r24
    4c66:	19 f6       	brne	.-122    	; 0x4bee <RTC_Check+0xc>
    4c68:	90 91 51 06 	lds	r25, 0x0651
    4c6c:	80 91 15 09 	lds	r24, 0x0915
    4c70:	98 17       	cp	r25, r24
    4c72:	09 f0       	breq	.+2      	; 0x4c76 <RTC_Check+0x94>
    4c74:	bc cf       	rjmp	.-136    	; 0x4bee <RTC_Check+0xc>
    4c76:	80 91 f7 06 	lds	r24, 0x06F7
    4c7a:	90 91 13 09 	lds	r25, 0x0913
    4c7e:	89 17       	cp	r24, r25
    4c80:	09 f0       	breq	.+2      	; 0x4c84 <RTC_Check+0xa2>
    4c82:	b7 cf       	rjmp	.-146    	; 0x4bf2 <RTC_Check+0x10>
    4c84:	c0 cf       	rjmp	.-128    	; 0x4c06 <RTC_Check+0x24>
			else{
				if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ) return 1;
			}
		}
		else{
			if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ||
    4c86:	90 91 cb 07 	lds	r25, 0x07CB
    4c8a:	80 91 14 09 	lds	r24, 0x0914
    4c8e:	98 17       	cp	r25, r24
    4c90:	09 f0       	breq	.+2      	; 0x4c94 <RTC_Check+0xb2>
    4c92:	b9 cf       	rjmp	.-142    	; 0x4c06 <RTC_Check+0x24>
    4c94:	90 91 5e 0b 	lds	r25, 0x0B5E
    4c98:	80 91 56 06 	lds	r24, 0x0656
    4c9c:	98 17       	cp	r25, r24
    4c9e:	09 f0       	breq	.+2      	; 0x4ca2 <RTC_Check+0xc0>
    4ca0:	b2 cf       	rjmp	.-156    	; 0x4c06 <RTC_Check+0x24>
    4ca2:	20 e0       	ldi	r18, 0x00	; 0
    4ca4:	90 91 c1 05 	lds	r25, 0x05C1
    4ca8:	80 91 d8 05 	lds	r24, 0x05D8
    4cac:	98 17       	cp	r25, r24
    4cae:	09 f0       	breq	.+2      	; 0x4cb2 <RTC_Check+0xd0>
    4cb0:	aa cf       	rjmp	.-172    	; 0x4c06 <RTC_Check+0x24>
    4cb2:	aa cf       	rjmp	.-172    	; 0x4c08 <RTC_Check+0x26>
	if( (Tm_Year == TrueTime_Year)  && (Tm_Mon == TrueTime_Mon) && (Tm_MDay == TrueTime_MDay) &&
			(Tm_Hour == TrueTime_Hour) && (Tm_Min == TrueTime_Min) && (Tm_Sec == TrueTime_Sec) ) return 1;

	if(TrueTime_Sec>55){
		if(TrueTime_Min == 59){
			if(TrueTime_Hour == 23){
    4cb4:	80 91 d8 05 	lds	r24, 0x05D8
    4cb8:	87 31       	cpi	r24, 0x17	; 23
    4cba:	99 f0       	breq	.+38     	; 0x4ce2 <RTC_Check+0x100>
				else{
					if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) ) return 1;
				}
			}
			else{
				if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ) return 1;
    4cbc:	54 17       	cp	r21, r20
    4cbe:	09 f0       	breq	.+2      	; 0x4cc2 <RTC_Check+0xe0>
    4cc0:	a2 cf       	rjmp	.-188    	; 0x4c06 <RTC_Check+0x24>
    4cc2:	90 91 cb 07 	lds	r25, 0x07CB
    4cc6:	80 91 14 09 	lds	r24, 0x0914
    4cca:	98 17       	cp	r25, r24
    4ccc:	09 f0       	breq	.+2      	; 0x4cd0 <RTC_Check+0xee>
    4cce:	9b cf       	rjmp	.-202    	; 0x4c06 <RTC_Check+0x24>
    4cd0:	20 e0       	ldi	r18, 0x00	; 0
    4cd2:	90 91 5e 0b 	lds	r25, 0x0B5E
    4cd6:	80 91 56 06 	lds	r24, 0x0656
    4cda:	98 17       	cp	r25, r24
    4cdc:	09 f0       	breq	.+2      	; 0x4ce0 <RTC_Check+0xfe>
    4cde:	93 cf       	rjmp	.-218    	; 0x4c06 <RTC_Check+0x24>
    4ce0:	93 cf       	rjmp	.-218    	; 0x4c08 <RTC_Check+0x26>
			(Tm_Hour == TrueTime_Hour) && (Tm_Min == TrueTime_Min) && (Tm_Sec == TrueTime_Sec) ) return 1;

	if(TrueTime_Sec>55){
		if(TrueTime_Min == 59){
			if(TrueTime_Hour == 23){
				if(TrueTime_MDay >= 28){
    4ce2:	80 91 56 06 	lds	r24, 0x0656
    4ce6:	8c 31       	cpi	r24, 0x1C	; 28
    4ce8:	48 f0       	brcs	.+18     	; 0x4cfc <RTC_Check+0x11a>
					if(TrueTime_Mon == 12){
    4cea:	80 91 14 09 	lds	r24, 0x0914
    4cee:	8c 30       	cpi	r24, 0x0C	; 12
    4cf0:	89 f0       	breq	.+34     	; 0x4d14 <RTC_Check+0x132>
						if( ((TrueTime_Year+1) == Tm_Year) || (TrueTime_Year==Tm_Year) || ((TrueTime_Year==99) && (Tm_Year==0)) ) return 0;
    4cf2:	20 e0       	ldi	r18, 0x00	; 0
    4cf4:	54 17       	cp	r21, r20
    4cf6:	09 f0       	breq	.+2      	; 0x4cfa <RTC_Check+0x118>
    4cf8:	86 cf       	rjmp	.-244    	; 0x4c06 <RTC_Check+0x24>
    4cfa:	86 cf       	rjmp	.-244    	; 0x4c08 <RTC_Check+0x26>
					else{
						if(Tm_Year!= TrueTime_Year) return 1;
					}
				}
				else{
					if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) ) return 1;
    4cfc:	54 17       	cp	r21, r20
    4cfe:	09 f0       	breq	.+2      	; 0x4d02 <RTC_Check+0x120>
    4d00:	82 cf       	rjmp	.-252    	; 0x4c06 <RTC_Check+0x24>
    4d02:	20 e0       	ldi	r18, 0x00	; 0
    4d04:	90 91 cb 07 	lds	r25, 0x07CB
    4d08:	80 91 14 09 	lds	r24, 0x0914
    4d0c:	98 17       	cp	r25, r24
    4d0e:	09 f0       	breq	.+2      	; 0x4d12 <RTC_Check+0x130>
    4d10:	7a cf       	rjmp	.-268    	; 0x4c06 <RTC_Check+0x24>
    4d12:	7a cf       	rjmp	.-268    	; 0x4c08 <RTC_Check+0x26>
	if(TrueTime_Sec>55){
		if(TrueTime_Min == 59){
			if(TrueTime_Hour == 23){
				if(TrueTime_MDay >= 28){
					if(TrueTime_Mon == 12){
						if( ((TrueTime_Year+1) == Tm_Year) || (TrueTime_Year==Tm_Year) || ((TrueTime_Year==99) && (Tm_Year==0)) ) return 0;
    4d14:	84 2f       	mov	r24, r20
    4d16:	90 e0       	ldi	r25, 0x00	; 0
    4d18:	01 96       	adiw	r24, 0x01	; 1
    4d1a:	25 2f       	mov	r18, r21
    4d1c:	30 e0       	ldi	r19, 0x00	; 0
    4d1e:	82 17       	cp	r24, r18
    4d20:	93 07       	cpc	r25, r19
    4d22:	61 f0       	breq	.+24     	; 0x4d3c <RTC_Check+0x15a>
    4d24:	54 17       	cp	r21, r20
    4d26:	51 f0       	breq	.+20     	; 0x4d3c <RTC_Check+0x15a>
    4d28:	43 36       	cpi	r20, 0x63	; 99
    4d2a:	09 f0       	breq	.+2      	; 0x4d2e <RTC_Check+0x14c>
    4d2c:	6c cf       	rjmp	.-296    	; 0x4c06 <RTC_Check+0x24>
    4d2e:	20 e0       	ldi	r18, 0x00	; 0
    4d30:	55 23       	and	r21, r21
    4d32:	09 f4       	brne	.+2      	; 0x4d36 <RTC_Check+0x154>
    4d34:	21 e0       	ldi	r18, 0x01	; 1
    4d36:	81 e0       	ldi	r24, 0x01	; 1
    4d38:	28 27       	eor	r18, r24
    4d3a:	66 cf       	rjmp	.-308    	; 0x4c08 <RTC_Check+0x26>
			if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ||
				(Tm_Hour != TrueTime_Hour) ) return 1;		
		}
	}
	else{
		if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ||
    4d3c:	20 e0       	ldi	r18, 0x00	; 0
    4d3e:	64 cf       	rjmp	.-312    	; 0x4c08 <RTC_Check+0x26>

00004d40 <GSM_PWRCNTRL_Config>:
#endif

//  gsm_sim900r.h   PWRCNTRL
#ifdef vmd2_3
	void GSM_PWRCNTRL_Config(void){
		cli();
    4d40:	f8 94       	cli
		DDRL|=(1<<PL5);
    4d42:	ea e0       	ldi	r30, 0x0A	; 10
    4d44:	f1 e0       	ldi	r31, 0x01	; 1
    4d46:	80 81       	ld	r24, Z
    4d48:	80 62       	ori	r24, 0x20	; 32
    4d4a:	80 83       	st	Z, r24
		sei();
    4d4c:	78 94       	sei
	}
    4d4e:	08 95       	ret

00004d50 <GSM_PWRCNTRL_OFF>:
	void GSM_PWRCNTRL_OFF(void){
		cli();
    4d50:	f8 94       	cli
		PORTL|=(1<<PL5);
    4d52:	eb e0       	ldi	r30, 0x0B	; 11
    4d54:	f1 e0       	ldi	r31, 0x01	; 1
    4d56:	80 81       	ld	r24, Z
    4d58:	80 62       	ori	r24, 0x20	; 32
    4d5a:	80 83       	st	Z, r24
		sei();
    4d5c:	78 94       	sei
	}
    4d5e:	08 95       	ret

00004d60 <GSM_PWRCNTRL_ON>:
	void GSM_PWRCNTRL_ON(void){
		cli();
    4d60:	f8 94       	cli
		PORTL &= ~(1<<PL5);
    4d62:	eb e0       	ldi	r30, 0x0B	; 11
    4d64:	f1 e0       	ldi	r31, 0x01	; 1
    4d66:	80 81       	ld	r24, Z
    4d68:	8f 7d       	andi	r24, 0xDF	; 223
    4d6a:	80 83       	st	Z, r24
		sei();
    4d6c:	78 94       	sei
	}
    4d6e:	08 95       	ret

00004d70 <GSM_CTS_RTS_Config>:

	void GSM_CTS_RTS_Config(void){
		cli();
    4d70:	f8 94       	cli
		//TS
		DDRB &=~(1<<PB6);
    4d72:	26 98       	cbi	0x04, 6	; 4
		PORTB |=(1<<PB6);	//pull'up
    4d74:	2e 9a       	sbi	0x05, 6	; 5
		//RTS
		DDRG |= (1<<PG5);
    4d76:	9d 9a       	sbi	0x13, 5	; 19
		PORTG &= ~(1<<PG5);
    4d78:	a5 98       	cbi	0x14, 5	; 20
		sei();
    4d7a:	78 94       	sei
	}
    4d7c:	08 95       	ret

00004d7e <GSM_CTS_State>:
	uint8_t GSM_CTS_State(void){
		return PINB & (1<<PB6);
    4d7e:	83 b1       	in	r24, 0x03	; 3
	}
    4d80:	80 74       	andi	r24, 0x40	; 64
    4d82:	08 95       	ret

00004d84 <GSM_RTS_OFF>:
	void GSM_RTS_OFF(void){
		cli();
    4d84:	f8 94       	cli
		PORTG &= ~(1<<PG5);
    4d86:	a5 98       	cbi	0x14, 5	; 20
		sei();
    4d88:	78 94       	sei
	}
    4d8a:	08 95       	ret

00004d8c <GSM_RTS_ON>:
	void GSM_RTS_ON(void){
		cli();
    4d8c:	f8 94       	cli
		PORTG |= (1<<PG5);
    4d8e:	a5 9a       	sbi	0x14, 5	; 20
		sei();
    4d90:	78 94       	sei
	}
    4d92:	08 95       	ret

00004d94 <LED_Init>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    4d94:	8f b7       	in	r24, 0x3f	; 63
    4d96:	80 78       	andi	r24, 0x80	; 128
    4d98:	80 93 ee 02 	sts	0x02EE, r24
	cli();
    4d9c:	f8 94       	cli
//~~~~~~~~~~~~
void
LED_Init(void)
{
	IntOff();
	DDR_LED |=PinLED;
    4d9e:	83 9a       	sbi	0x10, 3	; 16
	LED_Rst();
    4da0:	8b 98       	cbi	0x11, 3	; 17

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    4da2:	88 23       	and	r24, r24
    4da4:	09 f0       	breq	.+2      	; 0x4da8 <LED_Init+0x14>
		sei();
    4da6:	78 94       	sei
    4da8:	08 95       	ret

00004daa <LED_On>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    4daa:	8f b7       	in	r24, 0x3f	; 63
    4dac:	80 78       	andi	r24, 0x80	; 128
    4dae:	80 93 ee 02 	sts	0x02EE, r24
	cli();
    4db2:	f8 94       	cli
// ~~~~~~~~~
void
LED_On(void)
{
	IntOff();
	LED_Set();
    4db4:	8b 9a       	sbi	0x11, 3	; 17

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    4db6:	88 23       	and	r24, r24
    4db8:	09 f0       	breq	.+2      	; 0x4dbc <LED_On+0x12>
		sei();
    4dba:	78 94       	sei
    4dbc:	08 95       	ret

00004dbe <LED_Off>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    4dbe:	8f b7       	in	r24, 0x3f	; 63
    4dc0:	80 78       	andi	r24, 0x80	; 128
    4dc2:	80 93 ee 02 	sts	0x02EE, r24
	cli();
    4dc6:	f8 94       	cli
// ~~~~~~~~~~
void
LED_Off(void)
{
	IntOff();
	LED_Rst();
    4dc8:	8b 98       	cbi	0x11, 3	; 17

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    4dca:	88 23       	and	r24, r24
    4dcc:	09 f0       	breq	.+2      	; 0x4dd0 <LED_Off+0x12>
		sei();
    4dce:	78 94       	sei
    4dd0:	08 95       	ret

00004dd2 <LED_Toggle>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    4dd2:	8f b7       	in	r24, 0x3f	; 63
    4dd4:	80 78       	andi	r24, 0x80	; 128
    4dd6:	80 93 ee 02 	sts	0x02EE, r24
	cli();
    4dda:	f8 94       	cli
// ~~~~~~~~~~~~~
uint8_t
LED_Toggle(void)
{
	IntOff();
	LED_Inv();
    4ddc:	91 b3       	in	r25, 0x11	; 17
    4dde:	28 e0       	ldi	r18, 0x08	; 8
    4de0:	92 27       	eor	r25, r18
    4de2:	91 bb       	out	0x11, r25	; 17

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    4de4:	88 23       	and	r24, r24
    4de6:	09 f0       	breq	.+2      	; 0x4dea <LED_Toggle+0x18>
		sei();
    4de8:	78 94       	sei
	IntOn();
	return PortLED &PinLED;
    4dea:	81 b3       	in	r24, 0x11	; 17
}
    4dec:	88 70       	andi	r24, 0x08	; 8
    4dee:	08 95       	ret

00004df0 <Send>:
#ifdef Port_LCD_DB0	//8-bit width data bus
	// ~~~~~~~~~~~~~~
	static void
	Send(uint8_t Val)
	{
		if (Val &(1<<0)) Port_LCD_DB0 |=DB0; else Port_LCD_DB0 &=~DB0;
    4df0:	98 2f       	mov	r25, r24
    4df2:	80 ff       	sbrs	r24, 0
    4df4:	23 c0       	rjmp	.+70     	; 0x4e3c <Send+0x4c>
    4df6:	41 9a       	sbi	0x08, 1	; 8
		if (Val &(1<<1)) Port_LCD_DB1 |=DB1; else Port_LCD_DB1 &=~DB1;
    4df8:	91 ff       	sbrs	r25, 1
    4dfa:	23 c0       	rjmp	.+70     	; 0x4e42 <Send+0x52>
    4dfc:	40 9a       	sbi	0x08, 0	; 8
		if (Val &(1<<2)) Port_LCD_DB2 |=DB2; else Port_LCD_DB2 &=~DB2;
    4dfe:	92 ff       	sbrs	r25, 2
    4e00:	23 c0       	rjmp	.+70     	; 0x4e48 <Send+0x58>
    4e02:	a1 9a       	sbi	0x14, 1	; 20
		if (Val &(1<<3)) Port_LCD_DB3 |=DB3; else Port_LCD_DB3 &=~DB3;
    4e04:	93 ff       	sbrs	r25, 3
    4e06:	23 c0       	rjmp	.+70     	; 0x4e4e <Send+0x5e>
    4e08:	a0 9a       	sbi	0x14, 0	; 20
		if (Val &(1<<4)) Port_LCD_DB4 |=DB4; else Port_LCD_DB4 &=~DB4;
    4e0a:	94 ff       	sbrs	r25, 4
    4e0c:	23 c0       	rjmp	.+70     	; 0x4e54 <Send+0x64>
    4e0e:	5f 9a       	sbi	0x0b, 7	; 11
		if (Val &(1<<5)) Port_LCD_DB5 |=DB5; else Port_LCD_DB5 &=~DB5;
    4e10:	95 ff       	sbrs	r25, 5
    4e12:	23 c0       	rjmp	.+70     	; 0x4e5a <Send+0x6a>
    4e14:	5e 9a       	sbi	0x0b, 6	; 11
		if (Val &(1<<6)) Port_LCD_DB6 |=DB6; else Port_LCD_DB6 &=~DB6;
    4e16:	96 ff       	sbrs	r25, 6
    4e18:	23 c0       	rjmp	.+70     	; 0x4e60 <Send+0x70>
    4e1a:	5d 9a       	sbi	0x0b, 5	; 11
		if (Val &(1<<7)) Port_LCD_DB7 |=DB7; else Port_LCD_DB7 &=~DB7;
    4e1c:	87 fd       	sbrc	r24, 7
    4e1e:	23 c0       	rjmp	.+70     	; 0x4e66 <Send+0x76>
    4e20:	80 91 0b 01 	lds	r24, 0x010B
    4e24:	8f 77       	andi	r24, 0x7F	; 127
    4e26:	80 93 0b 01 	sts	0x010B, r24

		Port_LCD_E |=LCD_E;
    4e2a:	42 9a       	sbi	0x08, 2	; 8
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    4e2c:	85 e0       	ldi	r24, 0x05	; 5
    4e2e:	98 2f       	mov	r25, r24
    4e30:	9a 95       	dec	r25
    4e32:	f1 f7       	brne	.-4      	; 0x4e30 <Send+0x40>
		_delay_us(1);		// 450 ns needs
		Port_LCD_E &=~LCD_E;
    4e34:	42 98       	cbi	0x08, 2	; 8
    4e36:	8a 95       	dec	r24
    4e38:	f1 f7       	brne	.-4      	; 0x4e36 <Send+0x46>
		_delay_us(1);		// 10 ns needs
	}
    4e3a:	08 95       	ret
#ifdef Port_LCD_DB0	//8-bit width data bus
	// ~~~~~~~~~~~~~~
	static void
	Send(uint8_t Val)
	{
		if (Val &(1<<0)) Port_LCD_DB0 |=DB0; else Port_LCD_DB0 &=~DB0;
    4e3c:	41 98       	cbi	0x08, 1	; 8
		if (Val &(1<<1)) Port_LCD_DB1 |=DB1; else Port_LCD_DB1 &=~DB1;
    4e3e:	91 fd       	sbrc	r25, 1
    4e40:	dd cf       	rjmp	.-70     	; 0x4dfc <Send+0xc>
    4e42:	40 98       	cbi	0x08, 0	; 8
		if (Val &(1<<2)) Port_LCD_DB2 |=DB2; else Port_LCD_DB2 &=~DB2;
    4e44:	92 fd       	sbrc	r25, 2
    4e46:	dd cf       	rjmp	.-70     	; 0x4e02 <Send+0x12>
    4e48:	a1 98       	cbi	0x14, 1	; 20
		if (Val &(1<<3)) Port_LCD_DB3 |=DB3; else Port_LCD_DB3 &=~DB3;
    4e4a:	93 fd       	sbrc	r25, 3
    4e4c:	dd cf       	rjmp	.-70     	; 0x4e08 <Send+0x18>
    4e4e:	a0 98       	cbi	0x14, 0	; 20
		if (Val &(1<<4)) Port_LCD_DB4 |=DB4; else Port_LCD_DB4 &=~DB4;
    4e50:	94 fd       	sbrc	r25, 4
    4e52:	dd cf       	rjmp	.-70     	; 0x4e0e <Send+0x1e>
    4e54:	5f 98       	cbi	0x0b, 7	; 11
		if (Val &(1<<5)) Port_LCD_DB5 |=DB5; else Port_LCD_DB5 &=~DB5;
    4e56:	95 fd       	sbrc	r25, 5
    4e58:	dd cf       	rjmp	.-70     	; 0x4e14 <Send+0x24>
    4e5a:	5e 98       	cbi	0x0b, 6	; 11
		if (Val &(1<<6)) Port_LCD_DB6 |=DB6; else Port_LCD_DB6 &=~DB6;
    4e5c:	96 fd       	sbrc	r25, 6
    4e5e:	dd cf       	rjmp	.-70     	; 0x4e1a <Send+0x2a>
    4e60:	5d 98       	cbi	0x0b, 5	; 11
		if (Val &(1<<7)) Port_LCD_DB7 |=DB7; else Port_LCD_DB7 &=~DB7;
    4e62:	87 ff       	sbrs	r24, 7
    4e64:	dd cf       	rjmp	.-70     	; 0x4e20 <Send+0x30>
    4e66:	80 91 0b 01 	lds	r24, 0x010B
    4e6a:	80 68       	ori	r24, 0x80	; 128
    4e6c:	80 93 0b 01 	sts	0x010B, r24
    4e70:	dc cf       	rjmp	.-72     	; 0x4e2a <Send+0x3a>

00004e72 <Send_I>:
#endif
// ~~~~~~~~~~~~~~~~
static void
Send_I(uint8_t Val)
{
	Send(Val);
    4e72:	0e 94 f8 26 	call	0x4df0	; 0x4df0 <Send>
	Delay_us(LCD_Delay);
    4e76:	82 e3       	ldi	r24, 0x32	; 50
    4e78:	90 e0       	ldi	r25, 0x00	; 0
    4e7a:	0e 94 ee 1e 	call	0x3ddc	; 0x3ddc <Delay_us>
}
    4e7e:	08 95       	ret

00004e80 <LCD_FuncSet0>:

// ~~~~~~~~~~~
static void
LCD_FuncSet0(void)
{
	Port_LCD_DB4  |=DB4;
    4e80:	5f 9a       	sbi	0x0b, 7	; 11
	Port_LCD_DB5  |=DB5;
    4e82:	5e 9a       	sbi	0x0b, 6	; 11
	Port_LCD_DB6 &=~DB6;
    4e84:	5d 98       	cbi	0x0b, 5	; 11
	Port_LCD_DB7 &=~DB7;
    4e86:	eb e0       	ldi	r30, 0x0B	; 11
    4e88:	f1 e0       	ldi	r31, 0x01	; 1
    4e8a:	80 81       	ld	r24, Z
    4e8c:	8f 77       	andi	r24, 0x7F	; 127
    4e8e:	80 83       	st	Z, r24
}
    4e90:	08 95       	ret

00004e92 <LCD_Rdy>:
}

// ~~~~~~~~~~
uint8_t
LCD_Rdy(void)
{
    4e92:	1f 93       	push	r17
	uint8_t Rdy = Timer8Stopp(TD_LCD);
    4e94:	10 91 d7 04 	lds	r17, 0x04D7
    4e98:	81 2f       	mov	r24, r17
    4e9a:	0e 94 f5 1c 	call	0x39ea	; 0x39ea <Timer8Stopp>
	Rdy = Rdy && !(TIMSK_LCD &(1<<OCIE1B));
    4e9e:	88 23       	and	r24, r24
    4ea0:	29 f0       	breq	.+10     	; 0x4eac <LCD_Rdy+0x1a>
    4ea2:	80 91 6f 00 	lds	r24, 0x006F
    4ea6:	82 ff       	sbrs	r24, 2
    4ea8:	03 c0       	rjmp	.+6      	; 0x4eb0 <LCD_Rdy+0x1e>
    4eaa:	80 e0       	ldi	r24, 0x00	; 0
	if (Rdy)
		StartTimer8(TD_LCD, 6);
	return Rdy;
}
    4eac:	1f 91       	pop	r17
    4eae:	08 95       	ret
LCD_Rdy(void)
{
	uint8_t Rdy = Timer8Stopp(TD_LCD);
	Rdy = Rdy && !(TIMSK_LCD &(1<<OCIE1B));
	if (Rdy)
		StartTimer8(TD_LCD, 6);
    4eb0:	81 2f       	mov	r24, r17
    4eb2:	66 e0       	ldi	r22, 0x06	; 6
    4eb4:	0e 94 a1 1b 	call	0x3742	; 0x3742 <StartTimer8>
    4eb8:	81 e0       	ldi	r24, 0x01	; 1
	return Rdy;
}
    4eba:	1f 91       	pop	r17
    4ebc:	08 95       	ret

00004ebe <LCD_Out>:
LCD_Out(void)
{
	static uint8_t N;
	uint16_t LCD_delay = 100;	//50us

	if( (N>=20) && !LCD_Rst_Flg ){
    4ebe:	90 91 eb 02 	lds	r25, 0x02EB
    4ec2:	94 31       	cpi	r25, 0x14	; 20
    4ec4:	20 f0       	brcs	.+8      	; 0x4ece <LCD_Out+0x10>
    4ec6:	80 91 d6 04 	lds	r24, 0x04D6
    4eca:	88 23       	and	r24, r24
    4ecc:	19 f1       	breq	.+70     	; 0x4f14 <LCD_Out+0x56>
		LCD_Rst0();
		LCD_Rst_Flg = 1;
		LCD_delay = 10000;	//5ms
	}
	else {
		N++;
    4ece:	9f 5f       	subi	r25, 0xFF	; 255
    4ed0:	90 93 eb 02 	sts	0x02EB, r25
    4ed4:	24 e6       	ldi	r18, 0x64	; 100
    4ed6:	30 e0       	ldi	r19, 0x00	; 0
	}

	cli();
    4ed8:	f8 94       	cli
	LCD_delay = TCNT1 + LCD_delay;
    4eda:	80 91 84 00 	lds	r24, 0x0084
    4ede:	90 91 85 00 	lds	r25, 0x0085
    4ee2:	82 0f       	add	r24, r18
    4ee4:	93 1f       	adc	r25, r19
	if(LCD_delay >= 20000) OCR1B = LCD_delay - 20000;
    4ee6:	2e e4       	ldi	r18, 0x4E	; 78
    4ee8:	80 32       	cpi	r24, 0x20	; 32
    4eea:	92 07       	cpc	r25, r18
    4eec:	60 f4       	brcc	.+24     	; 0x4f06 <LCD_Out+0x48>
	else OCR1B = LCD_delay;
    4eee:	90 93 8b 00 	sts	0x008B, r25
    4ef2:	80 93 8a 00 	sts	0x008A, r24
	TIFR_LCD |= (1<<OCF1B);
    4ef6:	b2 9a       	sbi	0x16, 2	; 22
	TIMSK_LCD |= (1<<OCIE1B);
    4ef8:	80 91 6f 00 	lds	r24, 0x006F
    4efc:	84 60       	ori	r24, 0x04	; 4
    4efe:	80 93 6f 00 	sts	0x006F, r24
	sei();
    4f02:	78 94       	sei
}
    4f04:	08 95       	ret
		N++;
	}

	cli();
	LCD_delay = TCNT1 + LCD_delay;
	if(LCD_delay >= 20000) OCR1B = LCD_delay - 20000;
    4f06:	80 52       	subi	r24, 0x20	; 32
    4f08:	9e 44       	sbci	r25, 0x4E	; 78
    4f0a:	90 93 8b 00 	sts	0x008B, r25
    4f0e:	80 93 8a 00 	sts	0x008A, r24
    4f12:	f1 cf       	rjmp	.-30     	; 0x4ef6 <LCD_Out+0x38>
{
	static uint8_t N;
	uint16_t LCD_delay = 100;	//50us

	if( (N>=20) && !LCD_Rst_Flg ){
		N = 0;
    4f14:	10 92 eb 02 	sts	0x02EB, r1
#endif
// ~~~~~~~~~~~
static void
LCD_Rst0(void)
{
	cli();
    4f18:	f8 94       	cli
	Port_LCD_RS &=~LCD_RS;
    4f1a:	44 98       	cbi	0x08, 4	; 8
	LCD_FuncSet0();
    4f1c:	0e 94 40 27 	call	0x4e80	; 0x4e80 <LCD_FuncSet0>
	sei();
    4f20:	78 94       	sei
	uint16_t LCD_delay = 100;	//50us

	if( (N>=20) && !LCD_Rst_Flg ){
		N = 0;
		LCD_Rst0();
		LCD_Rst_Flg = 1;
    4f22:	81 e0       	ldi	r24, 0x01	; 1
    4f24:	80 93 d6 04 	sts	0x04D6, r24
    4f28:	20 e1       	ldi	r18, 0x10	; 16
    4f2a:	37 e2       	ldi	r19, 0x27	; 39
    4f2c:	d5 cf       	rjmp	.-86     	; 0x4ed8 <LCD_Out+0x1a>

00004f2e <__vector_18>:
	sei();
}

// ~~~~~~~~~~~~~~~~~~~~~~
// 40 us needs
ISR(TIMER1_COMPB_vect){
    4f2e:	1f 92       	push	r1
    4f30:	0f 92       	push	r0
    4f32:	0f b6       	in	r0, 0x3f	; 63
    4f34:	0f 92       	push	r0
    4f36:	0b b6       	in	r0, 0x3b	; 59
    4f38:	0f 92       	push	r0
    4f3a:	11 24       	eor	r1, r1
    4f3c:	ff 92       	push	r15
    4f3e:	0f 93       	push	r16
    4f40:	1f 93       	push	r17
    4f42:	2f 93       	push	r18
    4f44:	3f 93       	push	r19
    4f46:	4f 93       	push	r20
    4f48:	5f 93       	push	r21
    4f4a:	6f 93       	push	r22
    4f4c:	7f 93       	push	r23
    4f4e:	8f 93       	push	r24
    4f50:	9f 93       	push	r25
    4f52:	af 93       	push	r26
    4f54:	bf 93       	push	r27
    4f56:	ef 93       	push	r30
    4f58:	ff 93       	push	r31

	uint16_t LCD_delay = 100;	//50us

	if (LCD_Rst_Flg) {
    4f5a:	80 91 d6 04 	lds	r24, 0x04D6
    4f5e:	88 23       	and	r24, r24
    4f60:	f1 f0       	breq	.+60     	; 0x4f9e <__vector_18+0x70>
		switch(LCD_Rst_Flg){
    4f62:	10 91 d6 04 	lds	r17, 0x04D6
    4f66:	15 30       	cpi	r17, 0x05	; 5
    4f68:	09 f4       	brne	.+2      	; 0x4f6c <__vector_18+0x3e>
    4f6a:	b5 c0       	rjmp	.+362    	; 0x50d6 <__vector_18+0x1a8>
    4f6c:	16 30       	cpi	r17, 0x06	; 6
    4f6e:	08 f4       	brcc	.+2      	; 0x4f72 <__vector_18+0x44>
    4f70:	a1 c0       	rjmp	.+322    	; 0x50b4 <__vector_18+0x186>
    4f72:	17 30       	cpi	r17, 0x07	; 7
    4f74:	09 f4       	brne	.+2      	; 0x4f78 <__vector_18+0x4a>
    4f76:	15 c1       	rjmp	.+554    	; 0x51a2 <__vector_18+0x274>
    4f78:	17 30       	cpi	r17, 0x07	; 7
    4f7a:	08 f0       	brcs	.+2      	; 0x4f7e <__vector_18+0x50>
    4f7c:	dc c0       	rjmp	.+440    	; 0x5136 <__vector_18+0x208>
				break;
			case 5:
				Send(0b00001100);	//; Display on, cursor off, blink off	
				break;
			case 6:
				Send(0b00000110);	//; cursor shift right, no display shift
    4f7e:	86 e0       	ldi	r24, 0x06	; 6
    4f80:	0e 94 f8 26 	call	0x4df0	; 0x4df0 <Send>
				#endif
				Port_LCD_RS |=LCD_RS;
			default:
				LCD_Rst_Flg = 255;
		}
		if(LCD_Rst_Flg==1) LCD_delay = 400;	//200us
    4f84:	80 91 d6 04 	lds	r24, 0x04D6
    4f88:	81 30       	cpi	r24, 0x01	; 1
    4f8a:	09 f4       	brne	.+2      	; 0x4f8e <__vector_18+0x60>
    4f8c:	a1 c0       	rjmp	.+322    	; 0x50d0 <__vector_18+0x1a2>
    4f8e:	24 e6       	ldi	r18, 0x64	; 100
    4f90:	30 e0       	ldi	r19, 0x00	; 0

		LCD_Rst_Flg++;
    4f92:	80 91 d6 04 	lds	r24, 0x04D6
    4f96:	8f 5f       	subi	r24, 0xFF	; 255
    4f98:	80 93 d6 04 	sts	0x04D6, r24
    4f9c:	5f c0       	rjmp	.+190    	; 0x505c <__vector_18+0x12e>
	else {
		static uint8_t X, Y;
		static prog_uint8_t LineAddr[] = {128, 192, 148, 212};
		unsigned char cursor_symb;
		
		if (X<LCDXSz) {
    4f9e:	10 91 e8 02 	lds	r17, 0x02E8
    4fa2:	14 31       	cpi	r17, 0x14	; 20
    4fa4:	08 f0       	brcs	.+2      	; 0x4fa8 <__vector_18+0x7a>
    4fa6:	45 c0       	rjmp	.+138    	; 0x5032 <__vector_18+0x104>
			if((X>=CurrX)&&(X<(CurrX+StrSize))&&(Y==CurrLCD)){
    4fa8:	80 91 fa 06 	lds	r24, 0x06FA
    4fac:	18 17       	cp	r17, r24
    4fae:	08 f4       	brcc	.+2      	; 0x4fb2 <__vector_18+0x84>
    4fb0:	96 c0       	rjmp	.+300    	; 0x50de <__vector_18+0x1b0>
    4fb2:	61 2f       	mov	r22, r17
    4fb4:	70 e0       	ldi	r23, 0x00	; 0
    4fb6:	20 91 ac 06 	lds	r18, 0x06AC
    4fba:	90 e0       	ldi	r25, 0x00	; 0
    4fbc:	82 0f       	add	r24, r18
    4fbe:	91 1d       	adc	r25, r1
    4fc0:	68 17       	cp	r22, r24
    4fc2:	79 07       	cpc	r23, r25
    4fc4:	0c f4       	brge	.+2      	; 0x4fc8 <__vector_18+0x9a>
    4fc6:	e4 c0       	rjmp	.+456    	; 0x5190 <__vector_18+0x262>
    4fc8:	e0 91 e7 02 	lds	r30, 0x02E7
    4fcc:	20 e0       	ldi	r18, 0x00	; 0
			else
			{
				cursor_symb=0;
			}

			Send(
    4fce:	4e 2f       	mov	r20, r30
    4fd0:	50 e0       	ldi	r21, 0x00	; 0
    4fd2:	90 91 17 09 	lds	r25, 0x0917
    4fd6:	89 2f       	mov	r24, r25
    4fd8:	88 50       	subi	r24, 0x08	; 8
    4fda:	83 30       	cpi	r24, 0x03	; 3
    4fdc:	18 f0       	brcs	.+6      	; 0x4fe4 <__vector_18+0xb6>
    4fde:	9e 30       	cpi	r25, 0x0E	; 14
    4fe0:	08 f4       	brcc	.+2      	; 0x4fe4 <__vector_18+0xb6>
    4fe2:	91 c0       	rjmp	.+290    	; 0x5106 <__vector_18+0x1d8>
    4fe4:	22 23       	and	r18, r18
    4fe6:	09 f4       	brne	.+2      	; 0x4fea <__vector_18+0xbc>
    4fe8:	8e c0       	rjmp	.+284    	; 0x5106 <__vector_18+0x1d8>
    4fea:	80 91 d6 02 	lds	r24, 0x02D6
    4fee:	8f 3f       	cpi	r24, 0xFF	; 255
    4ff0:	09 f4       	brne	.+2      	; 0x4ff4 <__vector_18+0xc6>
    4ff2:	89 c0       	rjmp	.+274    	; 0x5106 <__vector_18+0x1d8>
    4ff4:	e2 2f       	mov	r30, r18
    4ff6:	f0 e0       	ldi	r31, 0x00	; 0
    4ff8:	e9 50       	subi	r30, 0x09	; 9
    4ffa:	f0 4d       	sbci	r31, 0xD0	; 208
    4ffc:	24 91       	lpm	r18, Z+
    4ffe:	fa 01       	movw	r30, r20
    5000:	ee 0f       	add	r30, r30
    5002:	ff 1f       	adc	r31, r31
    5004:	ee 0f       	add	r30, r30
    5006:	ff 1f       	adc	r31, r31
    5008:	cf 01       	movw	r24, r30
    500a:	88 0f       	add	r24, r24
    500c:	99 1f       	adc	r25, r25
    500e:	88 0f       	add	r24, r24
    5010:	99 1f       	adc	r25, r25
    5012:	e8 0f       	add	r30, r24
    5014:	f9 1f       	adc	r31, r25
    5016:	e6 0f       	add	r30, r22
    5018:	f7 1f       	adc	r31, r23
    501a:	ee 56       	subi	r30, 0x6E	; 110
    501c:	f7 4f       	sbci	r31, 0xF7	; 247
    501e:	20 83       	st	Z, r18
    5020:	82 2f       	mov	r24, r18
    5022:	0e 94 f8 26 	call	0x4df0	; 0x4df0 <Send>
				#ifndef QslRD
					*((uint8_t*)RMON+Y*LCDXSz+X) =
				#endif
			#endif
				(((Blink>=8 && Blink<=10 )|| Blink>=14)&&cursor_symb&&(CurrField!=255))?prb(Win2LCD+(unsigned char)cursor_symb):(prb(Win2LCD+(unsigned char)LCD_Buf[Y][X])));
				X++;
    5026:	1f 5f       	subi	r17, 0xFF	; 255
    5028:	10 93 e8 02 	sts	0x02E8, r17
    502c:	24 e6       	ldi	r18, 0x64	; 100
    502e:	30 e0       	ldi	r19, 0x00	; 0
    5030:	15 c0       	rjmp	.+42     	; 0x505c <__vector_18+0x12e>
		}
		else {
			X = 0;
    5032:	10 92 e8 02 	sts	0x02E8, r1
			if (++Y==LCDYSz) {
    5036:	e0 91 e7 02 	lds	r30, 0x02E7
    503a:	ef 5f       	subi	r30, 0xFF	; 255
    503c:	e0 93 e7 02 	sts	0x02E7, r30
    5040:	e4 30       	cpi	r30, 0x04	; 4
    5042:	09 f4       	brne	.+2      	; 0x5046 <__vector_18+0x118>
    5044:	51 c0       	rjmp	.+162    	; 0x50e8 <__vector_18+0x1ba>
				Y = 0;
				TIMSK_LCD &= ~(1<<OCIE1B);	//stop Output CompareB interrups
			}
			Port_LCD_RS &=~LCD_RS;
    5046:	44 98       	cbi	0x08, 4	; 8
    5048:	f0 e0       	ldi	r31, 0x00	; 0
    504a:	e9 50       	subi	r30, 0x09	; 9
    504c:	ff 4c       	sbci	r31, 0xCF	; 207
    504e:	e4 91       	lpm	r30, Z+
			Send(prb(LineAddr+Y));
    5050:	8e 2f       	mov	r24, r30
    5052:	0e 94 f8 26 	call	0x4df0	; 0x4df0 <Send>
			Port_LCD_RS |=LCD_RS;
    5056:	44 9a       	sbi	0x08, 4	; 8
    5058:	24 e6       	ldi	r18, 0x64	; 100
    505a:	30 e0       	ldi	r19, 0x00	; 0
		}
	}
	LCD_delay = TCNT1 + LCD_delay;
    505c:	80 91 84 00 	lds	r24, 0x0084
    5060:	90 91 85 00 	lds	r25, 0x0085
    5064:	82 0f       	add	r24, r18
    5066:	93 1f       	adc	r25, r19
	if(LCD_delay >= 20000) OCR1B = LCD_delay - 20000;
    5068:	2e e4       	ldi	r18, 0x4E	; 78
    506a:	80 32       	cpi	r24, 0x20	; 32
    506c:	92 07       	cpc	r25, r18
    506e:	d8 f4       	brcc	.+54     	; 0x50a6 <__vector_18+0x178>
	else OCR1B = LCD_delay;
    5070:	90 93 8b 00 	sts	0x008B, r25
    5074:	80 93 8a 00 	sts	0x008A, r24
	TIFR_LCD |= (1<<OCF1B);
    5078:	b2 9a       	sbi	0x16, 2	; 22
}
    507a:	ff 91       	pop	r31
    507c:	ef 91       	pop	r30
    507e:	bf 91       	pop	r27
    5080:	af 91       	pop	r26
    5082:	9f 91       	pop	r25
    5084:	8f 91       	pop	r24
    5086:	7f 91       	pop	r23
    5088:	6f 91       	pop	r22
    508a:	5f 91       	pop	r21
    508c:	4f 91       	pop	r20
    508e:	3f 91       	pop	r19
    5090:	2f 91       	pop	r18
    5092:	1f 91       	pop	r17
    5094:	0f 91       	pop	r16
    5096:	ff 90       	pop	r15
    5098:	0f 90       	pop	r0
    509a:	0b be       	out	0x3b, r0	; 59
    509c:	0f 90       	pop	r0
    509e:	0f be       	out	0x3f, r0	; 63
    50a0:	0f 90       	pop	r0
    50a2:	1f 90       	pop	r1
    50a4:	18 95       	reti
			Send(prb(LineAddr+Y));
			Port_LCD_RS |=LCD_RS;
		}
	}
	LCD_delay = TCNT1 + LCD_delay;
	if(LCD_delay >= 20000) OCR1B = LCD_delay - 20000;
    50a6:	80 52       	subi	r24, 0x20	; 32
    50a8:	9e 44       	sbci	r25, 0x4E	; 78
    50aa:	90 93 8b 00 	sts	0x008B, r25
    50ae:	80 93 8a 00 	sts	0x008A, r24
    50b2:	e2 cf       	rjmp	.-60     	; 0x5078 <__vector_18+0x14a>
ISR(TIMER1_COMPB_vect){

	uint16_t LCD_delay = 100;	//50us

	if (LCD_Rst_Flg) {
		switch(LCD_Rst_Flg){
    50b4:	12 30       	cpi	r17, 0x02	; 2
    50b6:	21 f1       	breq	.+72     	; 0x5100 <__vector_18+0x1d2>
    50b8:	13 30       	cpi	r17, 0x03	; 3
    50ba:	f8 f4       	brcc	.+62     	; 0x50fa <__vector_18+0x1cc>
    50bc:	11 30       	cpi	r17, 0x01	; 1
    50be:	01 f1       	breq	.+64     	; 0x5100 <__vector_18+0x1d2>
				#else
					Send(0b00000010);	//RETURN HOME					
				#endif
				Port_LCD_RS |=LCD_RS;
			default:
				LCD_Rst_Flg = 255;
    50c0:	8f ef       	ldi	r24, 0xFF	; 255
    50c2:	80 93 d6 04 	sts	0x04D6, r24
		}
		if(LCD_Rst_Flg==1) LCD_delay = 400;	//200us
    50c6:	80 91 d6 04 	lds	r24, 0x04D6
    50ca:	81 30       	cpi	r24, 0x01	; 1
    50cc:	09 f0       	breq	.+2      	; 0x50d0 <__vector_18+0x1a2>
    50ce:	5f cf       	rjmp	.-322    	; 0x4f8e <__vector_18+0x60>
    50d0:	20 e9       	ldi	r18, 0x90	; 144
    50d2:	31 e0       	ldi	r19, 0x01	; 1
    50d4:	5e cf       	rjmp	.-324    	; 0x4f92 <__vector_18+0x64>
				#else
					Send(0b00101000);	//; 4-bits DL, 2 lines, 5x7 dots
				#endif
				break;
			case 5:
				Send(0b00001100);	//; Display on, cursor off, blink off	
    50d6:	8c e0       	ldi	r24, 0x0C	; 12
    50d8:	0e 94 f8 26 	call	0x4df0	; 0x4df0 <Send>
    50dc:	53 cf       	rjmp	.-346    	; 0x4f84 <__vector_18+0x56>
    50de:	61 2f       	mov	r22, r17
    50e0:	70 e0       	ldi	r23, 0x00	; 0
    50e2:	e0 91 e7 02 	lds	r30, 0x02E7
    50e6:	72 cf       	rjmp	.-284    	; 0x4fcc <__vector_18+0x9e>
				X++;
		}
		else {
			X = 0;
			if (++Y==LCDYSz) {
				Y = 0;
    50e8:	10 92 e7 02 	sts	0x02E7, r1
				TIMSK_LCD &= ~(1<<OCIE1B);	//stop Output CompareB interrups
    50ec:	80 91 6f 00 	lds	r24, 0x006F
    50f0:	8b 7f       	andi	r24, 0xFB	; 251
    50f2:	80 93 6f 00 	sts	0x006F, r24
    50f6:	e0 e0       	ldi	r30, 0x00	; 0
    50f8:	a6 cf       	rjmp	.-180    	; 0x5046 <__vector_18+0x118>
ISR(TIMER1_COMPB_vect){

	uint16_t LCD_delay = 100;	//50us

	if (LCD_Rst_Flg) {
		switch(LCD_Rst_Flg){
    50fa:	13 30       	cpi	r17, 0x03	; 3
    50fc:	09 f0       	breq	.+2      	; 0x5100 <__vector_18+0x1d2>
    50fe:	56 c0       	rjmp	.+172    	; 0x51ac <__vector_18+0x27e>
			case 2:
				LCD_FuncSet0();
				break;
			case 3:
				#ifdef Port_LCD_DB0	
					LCD_FuncSet0();
    5100:	0e 94 40 27 	call	0x4e80	; 0x4e80 <LCD_FuncSet0>
    5104:	3f cf       	rjmp	.-386    	; 0x4f84 <__vector_18+0x56>
			else
			{
				cursor_symb=0;
			}

			Send(
    5106:	ca 01       	movw	r24, r20
    5108:	88 0f       	add	r24, r24
    510a:	99 1f       	adc	r25, r25
    510c:	84 0f       	add	r24, r20
    510e:	95 1f       	adc	r25, r21
    5110:	fc 01       	movw	r30, r24
    5112:	ee 0f       	add	r30, r30
    5114:	ff 1f       	adc	r31, r31
    5116:	ee 0f       	add	r30, r30
    5118:	ff 1f       	adc	r31, r31
    511a:	ee 0f       	add	r30, r30
    511c:	ff 1f       	adc	r31, r31
    511e:	e8 1b       	sub	r30, r24
    5120:	f9 0b       	sbc	r31, r25
    5122:	e6 0f       	add	r30, r22
    5124:	f7 1f       	adc	r31, r23
    5126:	e8 5a       	subi	r30, 0xA8	; 168
    5128:	f9 4f       	sbci	r31, 0xF9	; 249
    512a:	e0 81       	ld	r30, Z
    512c:	f0 e0       	ldi	r31, 0x00	; 0
    512e:	e9 50       	subi	r30, 0x09	; 9
    5130:	f0 4d       	sbci	r31, 0xD0	; 208
    5132:	24 91       	lpm	r18, Z+
    5134:	64 cf       	rjmp	.-312    	; 0x4ffe <__vector_18+0xd0>
ISR(TIMER1_COMPB_vect){

	uint16_t LCD_delay = 100;	//50us

	if (LCD_Rst_Flg) {
		switch(LCD_Rst_Flg){
    5136:	18 30       	cpi	r17, 0x08	; 8
    5138:	49 f0       	breq	.+18     	; 0x514c <__vector_18+0x21e>
    513a:	19 30       	cpi	r17, 0x09	; 9
    513c:	09 f0       	breq	.+2      	; 0x5140 <__vector_18+0x212>
    513e:	c0 cf       	rjmp	.-128    	; 0x50c0 <__vector_18+0x192>
						else{i=0;LCD_Rst_Flg = 8;}
					}
				}
				break;
			case 9:
				Port_LCD_RS &=~LCD_RS;
    5140:	44 98       	cbi	0x08, 4	; 8
				#ifdef NOT_USE_LCD_RETURN_HOME_CMD
					Send(128);			//     
				#else
					Send(0b00000010);	//RETURN HOME					
    5142:	82 e0       	ldi	r24, 0x02	; 2
    5144:	0e 94 f8 26 	call	0x4df0	; 0x4df0 <Send>
				#endif
				Port_LCD_RS |=LCD_RS;
    5148:	44 9a       	sbi	0x08, 4	; 8
    514a:	ba cf       	rjmp	.-140    	; 0x50c0 <__vector_18+0x192>
				Send(0b01000000);	//;    CG RAM   0.
				Port_LCD_RS |=LCD_RS;
				break;
			case 8:{
					static uint8_t i,j;
					LCD_Rst_Flg = 7;
    514c:	87 e0       	ldi	r24, 0x07	; 7
    514e:	80 93 d6 04 	sts	0x04D6, r24
					Send(prb(CGRAM_LCD[i]+j));
    5152:	f0 90 ea 02 	lds	r15, 0x02EA
    5156:	00 91 e9 02 	lds	r16, 0x02E9
    515a:	ef 2d       	mov	r30, r15
    515c:	f0 e0       	ldi	r31, 0x00	; 0
    515e:	ee 0f       	add	r30, r30
    5160:	ff 1f       	adc	r31, r31
    5162:	ee 0f       	add	r30, r30
    5164:	ff 1f       	adc	r31, r31
    5166:	ee 0f       	add	r30, r30
    5168:	ff 1f       	adc	r31, r31
    516a:	e0 0f       	add	r30, r16
    516c:	f1 1d       	adc	r31, r1
    516e:	e9 54       	subi	r30, 0x49	; 73
    5170:	f0 4d       	sbci	r31, 0xD0	; 208
    5172:	e4 91       	lpm	r30, Z+
    5174:	8e 2f       	mov	r24, r30
    5176:	0e 94 f8 26 	call	0x4df0	; 0x4df0 <Send>
					if(j<7) j++;
    517a:	07 30       	cpi	r16, 0x07	; 7
    517c:	f0 f0       	brcs	.+60     	; 0x51ba <__vector_18+0x28c>
					else{
						j=0;
    517e:	10 92 e9 02 	sts	0x02E9, r1
						if(i<7)i++;
    5182:	26 e0       	ldi	r18, 0x06	; 6
    5184:	2f 15       	cp	r18, r15
    5186:	e8 f0       	brcs	.+58     	; 0x51c2 <__vector_18+0x294>
    5188:	f3 94       	inc	r15
    518a:	f0 92 ea 02 	sts	0x02EA, r15
    518e:	fa ce       	rjmp	.-524    	; 0x4f84 <__vector_18+0x56>
		static uint8_t X, Y;
		static prog_uint8_t LineAddr[] = {128, 192, 148, 212};
		unsigned char cursor_symb;
		
		if (X<LCDXSz) {
			if((X>=CurrX)&&(X<(CurrX+StrSize))&&(Y==CurrLCD)){
    5190:	e0 91 e7 02 	lds	r30, 0x02E7
    5194:	80 91 e7 08 	lds	r24, 0x08E7
    5198:	e8 17       	cp	r30, r24
    519a:	09 f0       	breq	.+2      	; 0x519e <__vector_18+0x270>
    519c:	17 cf       	rjmp	.-466    	; 0x4fcc <__vector_18+0x9e>
    519e:	2f e5       	ldi	r18, 0x5F	; 95
    51a0:	16 cf       	rjmp	.-468    	; 0x4fce <__vector_18+0xa0>
				break;
			case 6:
				Send(0b00000110);	//; cursor shift right, no display shift
				break;
			case 7:
				Send(0b01000000);	//;    CG RAM   0.
    51a2:	80 e4       	ldi	r24, 0x40	; 64
    51a4:	0e 94 f8 26 	call	0x4df0	; 0x4df0 <Send>
				Port_LCD_RS |=LCD_RS;
    51a8:	44 9a       	sbi	0x08, 4	; 8
    51aa:	ec ce       	rjmp	.-552    	; 0x4f84 <__vector_18+0x56>
ISR(TIMER1_COMPB_vect){

	uint16_t LCD_delay = 100;	//50us

	if (LCD_Rst_Flg) {
		switch(LCD_Rst_Flg){
    51ac:	14 30       	cpi	r17, 0x04	; 4
    51ae:	09 f0       	breq	.+2      	; 0x51b2 <__vector_18+0x284>
    51b0:	87 cf       	rjmp	.-242    	; 0x50c0 <__vector_18+0x192>
					LCD_FuncSet1();
				#endif
				break;
			case 4:
				#ifdef Port_LCD_DB0	
					Send(0b00111000);	//; 8-bits DL, 2 lines, 5x7 dots
    51b2:	88 e3       	ldi	r24, 0x38	; 56
    51b4:	0e 94 f8 26 	call	0x4df0	; 0x4df0 <Send>
    51b8:	e5 ce       	rjmp	.-566    	; 0x4f84 <__vector_18+0x56>
				break;
			case 8:{
					static uint8_t i,j;
					LCD_Rst_Flg = 7;
					Send(prb(CGRAM_LCD[i]+j));
					if(j<7) j++;
    51ba:	0f 5f       	subi	r16, 0xFF	; 255
    51bc:	00 93 e9 02 	sts	0x02E9, r16
    51c0:	e1 ce       	rjmp	.-574    	; 0x4f84 <__vector_18+0x56>
					else{
						j=0;
						if(i<7)i++;
						else{i=0;LCD_Rst_Flg = 8;}
    51c2:	10 92 ea 02 	sts	0x02EA, r1
    51c6:	10 93 d6 04 	sts	0x04D6, r17
    51ca:	dc ce       	rjmp	.-584    	; 0x4f84 <__vector_18+0x56>

000051cc <LCDBackLightOn>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    51cc:	9f b7       	in	r25, 0x3f	; 63
    51ce:	90 78       	andi	r25, 0x80	; 128
    51d0:	90 93 ee 02 	sts	0x02EE, r25
	cli();
    51d4:	f8 94       	cli
	void LCDBackLightOn(void){
		IntOff();	
		#ifdef BACKLIGHT_INVERSION
			PORT_BACKLIGHT &= ~BACKLIGHT;
		#else
			PORT_BACKLIGHT |= BACKLIGHT;
    51d6:	80 91 0b 01 	lds	r24, 0x010B
    51da:	80 64       	ori	r24, 0x40	; 64
    51dc:	80 93 0b 01 	sts	0x010B, r24

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    51e0:	99 23       	and	r25, r25
    51e2:	09 f0       	breq	.+2      	; 0x51e6 <LCDBackLightOn+0x1a>
		sei();
    51e4:	78 94       	sei
    51e6:	08 95       	ret

000051e8 <LCDBackLightOff>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    51e8:	9f b7       	in	r25, 0x3f	; 63
    51ea:	90 78       	andi	r25, 0x80	; 128
    51ec:	90 93 ee 02 	sts	0x02EE, r25
	cli();
    51f0:	f8 94       	cli
	void LCDBackLightOff(void){
		IntOff();	
		#ifdef BACKLIGHT_INVERSION
			PORT_BACKLIGHT |= BACKLIGHT;
		#else
			PORT_BACKLIGHT &= ~BACKLIGHT;
    51f2:	80 91 0b 01 	lds	r24, 0x010B
    51f6:	8f 7b       	andi	r24, 0xBF	; 191
    51f8:	80 93 0b 01 	sts	0x010B, r24

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    51fc:	99 23       	and	r25, r25
    51fe:	09 f0       	breq	.+2      	; 0x5202 <LCDBackLightOff+0x1a>
		sei();
    5200:	78 94       	sei
    5202:	08 95       	ret

00005204 <LCDBackLightControl>:
				StartTimer16(TD_BackLight, 3000);
				break;			
		}
	}
	void LCDBackLightControl(void){
		switch(BackLightMode){
    5204:	80 91 52 06 	lds	r24, 0x0652
    5208:	81 30       	cpi	r24, 0x01	; 1
    520a:	29 f0       	breq	.+10     	; 0x5216 <LCDBackLightControl+0x12>
    520c:	82 30       	cpi	r24, 0x02	; 2
    520e:	61 f0       	breq	.+24     	; 0x5228 <LCDBackLightControl+0x24>
		case 1: if(Timer16Stopp(TD_BackLight)) LCDBackLightOff();
			break;
		case 2:
			break;
		default: LCDBackLightOn();
    5210:	0e 94 e6 28 	call	0x51cc	; 0x51cc <LCDBackLightOn>
    5214:	08 95       	ret
				break;			
		}
	}
	void LCDBackLightControl(void){
		switch(BackLightMode){
		case 1: if(Timer16Stopp(TD_BackLight)) LCDBackLightOff();
    5216:	80 91 d8 04 	lds	r24, 0x04D8
    521a:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <Timer16Stopp>
    521e:	88 23       	and	r24, r24
    5220:	c9 f3       	breq	.-14     	; 0x5214 <LCDBackLightControl+0x10>
    5222:	0e 94 f4 28 	call	0x51e8	; 0x51e8 <LCDBackLightOff>
    5226:	08 95       	ret
    5228:	08 95       	ret

0000522a <StartTimer0>:
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
		TCCR0  = ((((1<<WGM01) &~(1<<WGM00)  &~(1<<COM01)  &~(1<<COM00)) |(1<<CS02)) &~(1<<CS01)) |(1<<CS00);
	#elif defined (__AVR_ATmega128__)
		TCCR0  =   ((1<<WGM01) &~(1<<WGM00)  &~(1<<COM01)  &~(1<<COM00)) |(1<<CS02)   |(1<<CS01)  |(1<<CS00);
	#elif defined (__AVR_ATmega1280__)  || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TCCR0A =    (1<<WGM01) &~(1<<WGM00)  &~(1<<COM0A1) &~(1<<COM0A0) &~(1<<COM0B1) &~(1<<COM0B0);
    522a:	82 e0       	ldi	r24, 0x02	; 2
    522c:	84 bd       	out	0x24, r24	; 36
		TCCR0B = ((~(1<<WGM02)                                           |(1<<CS02)) &~(1<<CS01)) |(1<<CS00);
    522e:	85 ef       	ldi	r24, 0xF5	; 245
    5230:	85 bd       	out	0x25, r24	; 37
	#endif
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__)
		TIMSK |=(1<<OCIE0);
	#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TIMSK0 |=(1<<OCIE0A);
    5232:	ee e6       	ldi	r30, 0x6E	; 110
    5234:	f0 e0       	ldi	r31, 0x00	; 0
    5236:	80 81       	ld	r24, Z
    5238:	82 60       	ori	r24, 0x02	; 2
    523a:	80 83       	st	Z, r24
	#endif
}
    523c:	08 95       	ret

0000523e <StartTimer2>:
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
		TCCR2  =   ((1<<WGM21) &~(1<<WGM20)  &~(1<<COM21)  &~(1<<COM20)) |(1<<CS22)   |(1<<CS21)  |(1<<CS20);
	#elif defined (__AVR_ATmega128__)
		TCCR2  = ((((1<<WGM21) &~(1<<WGM20)  &~(1<<COM21)  &~(1<<COM20)) |(1<<CS22)) &~(1<<CS21)) |(1<<CS20);
	#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TCCR2A =    (1<<WGM21) &~(1<<WGM20)  &~(1<<COM2A1) &~(1<<COM2A0) &~(1<<COM2B1) &~(1<<COM2B0);
    523e:	82 e0       	ldi	r24, 0x02	; 2
    5240:	80 93 b0 00 	sts	0x00B0, r24
		TCCR2B =   ~(1<<WGM22)                                           |(1<<CS22)   |(1<<CS21)  |(1<<CS20);
    5244:	87 ef       	ldi	r24, 0xF7	; 247
    5246:	80 93 b1 00 	sts	0x00B1, r24
	#endif
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__)
		TIMSK |=(1<<OCIE2);
	#elif  defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TIMSK2 |=(1<<OCIE2A);
    524a:	e0 e7       	ldi	r30, 0x70	; 112
    524c:	f0 e0       	ldi	r31, 0x00	; 0
    524e:	80 81       	ld	r24, Z
    5250:	82 60       	ori	r24, 0x02	; 2
    5252:	80 83       	st	Z, r24
	#endif
}
    5254:	08 95       	ret

00005256 <StartTimer4>:
#if defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
	//static void
	void
	StartTimer4(void)
	{
		TCCR4A = 0;
    5256:	10 92 a0 00 	sts	0x00A0, r1
		TCCR4B = (1<<WGM42) | (1<<CS42) | (0<<CS41) | (1<<CS40);	// clk/1024
    525a:	8d e0       	ldi	r24, 0x0D	; 13
    525c:	80 93 a1 00 	sts	0x00A1, r24
		TIMSK4 |=(1<<OCIE4A);
    5260:	e2 e7       	ldi	r30, 0x72	; 114
    5262:	f0 e0       	ldi	r31, 0x00	; 0
    5264:	80 81       	ld	r24, Z
    5266:	82 60       	ori	r24, 0x02	; 2
    5268:	80 83       	st	Z, r24
	}
    526a:	08 95       	ret

0000526c <MB_Timer_ISR>:
// ~~~

// ~~~~~~~~~~~~~~~~~~~
static void
MB_Timer_ISR(tc_t *tc)
{
    526c:	bc 01       	movw	r22, r24

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    526e:	e5 ea       	ldi	r30, 0xA5	; 165
    5270:	ff e2       	ldi	r31, 0x2F	; 47
    5272:	85 91       	lpm	r24, Z+
    5274:	94 91       	lpm	r25, Z+
	#if defined (__AVR_ATxmega128A1__)
		tc->INTCTRLA = (tc->INTCTRLA &~TC1_OVFINTLVL_gm) |TC_OVFINTLVL_OFF_gc;
		tc->CTRLA = TC_CLKSEL_OFF_gc;
	#endif
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Timer[MB_N]tc_f)!=tc; MB_N++);
    5276:	68 17       	cp	r22, r24
    5278:	79 07       	cpc	r23, r25
    527a:	09 f4       	brne	.+2      	; 0x527e <MB_Timer_ISR+0x12>
    527c:	54 c0       	rjmp	.+168    	; 0x5326 <MB_Timer_ISR+0xba>
    527e:	20 e0       	ldi	r18, 0x00	; 0
    5280:	2f 5f       	subi	r18, 0xFF	; 255
    5282:	42 2f       	mov	r20, r18
    5284:	50 e0       	ldi	r21, 0x00	; 0
    5286:	fa 01       	movw	r30, r20
    5288:	ee 0f       	add	r30, r30
    528a:	ff 1f       	adc	r31, r31
    528c:	e4 0f       	add	r30, r20
    528e:	f5 1f       	adc	r31, r21
    5290:	ee 0f       	add	r30, r30
    5292:	ff 1f       	adc	r31, r31
    5294:	eb 55       	subi	r30, 0x5B	; 91
    5296:	f0 4d       	sbci	r31, 0xD0	; 208
    5298:	85 91       	lpm	r24, Z+
    529a:	94 91       	lpm	r25, Z+
    529c:	68 17       	cp	r22, r24
    529e:	79 07       	cpc	r23, r25
    52a0:	79 f7       	brne	.-34     	; 0x5280 <MB_Timer_ISR+0x14>
    52a2:	fa 01       	movw	r30, r20

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    52a4:	ec 55       	subi	r30, 0x5C	; 92
    52a6:	f0 4d       	sbci	r31, 0xD0	; 208
    52a8:	84 91       	lpm	r24, Z+

	
	switch (prb(MB_Role+MB_N)){
    52aa:	88 23       	and	r24, r24
    52ac:	f9 f4       	brne	.+62     	; 0x52ec <MB_Timer_ISR+0x80>
	case Role_Slave:
		if(MB_Frame[MB_N][0]==MB_NativeAddr[MB_N]){	// Slave     -   MB_TimerFlag
    52ae:	f4 2f       	mov	r31, r20
    52b0:	ee 27       	eor	r30, r30
    52b2:	e6 59       	subi	r30, 0x96	; 150
    52b4:	f4 4f       	sbci	r31, 0xF4	; 244
    52b6:	da 01       	movw	r26, r20
    52b8:	a0 52       	subi	r26, 0x20	; 32
    52ba:	ba 4f       	sbci	r27, 0xFA	; 250
    52bc:	90 81       	ld	r25, Z
    52be:	8c 91       	ld	r24, X
    52c0:	98 17       	cp	r25, r24
    52c2:	21 f1       	breq	.+72     	; 0x530c <MB_Timer_ISR+0xa0>
			MB_TimerFlag |= (1<<MB_N);
		}
		else{
			MB_State[MB_N] = MB_Idle;
    52c4:	fa 01       	movw	r30, r20
    52c6:	ee 53       	subi	r30, 0x3E	; 62
    52c8:	fa 4f       	sbci	r31, 0xFA	; 250
    52ca:	81 e0       	ldi	r24, 0x01	; 1
    52cc:	80 83       	st	Z, r24
			MB_CPT[MB_N][0]++;
    52ce:	fa 01       	movw	r30, r20
    52d0:	e2 95       	swap	r30
    52d2:	f2 95       	swap	r31
    52d4:	f0 7f       	andi	r31, 0xF0	; 240
    52d6:	fe 27       	eor	r31, r30
    52d8:	e0 7f       	andi	r30, 0xF0	; 240
    52da:	fe 27       	eor	r31, r30
    52dc:	eb 5c       	subi	r30, 0xCB	; 203
    52de:	f6 4f       	sbci	r31, 0xF6	; 246
    52e0:	80 81       	ld	r24, Z
    52e2:	91 81       	ldd	r25, Z+1	; 0x01
    52e4:	01 96       	adiw	r24, 0x01	; 1
    52e6:	91 83       	std	Z+1, r25	; 0x01
    52e8:	80 83       	st	Z, r24
    52ea:	08 95       	ret
	#endif
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Timer[MB_N]tc_f)!=tc; MB_N++);

	
	switch (prb(MB_Role+MB_N)){
    52ec:	81 30       	cpi	r24, 0x01	; 1
    52ee:	09 f0       	breq	.+2      	; 0x52f2 <MB_Timer_ISR+0x86>
    52f0:	08 95       	ret
			MB_State[MB_N] = MB_Idle;
			MB_CPT[MB_N][0]++;
		}
		break;
	case Role_Master:
		MB_TimerFlag |= (1<<MB_N);
    52f2:	20 91 29 09 	lds	r18, 0x0929
    52f6:	81 e0       	ldi	r24, 0x01	; 1
    52f8:	90 e0       	ldi	r25, 0x00	; 0
    52fa:	02 c0       	rjmp	.+4      	; 0x5300 <MB_Timer_ISR+0x94>
    52fc:	88 0f       	add	r24, r24
    52fe:	99 1f       	adc	r25, r25
    5300:	4a 95       	dec	r20
    5302:	e2 f7       	brpl	.-8      	; 0x52fc <MB_Timer_ISR+0x90>
    5304:	28 2b       	or	r18, r24
    5306:	20 93 29 09 	sts	0x0929, r18
    530a:	08 95       	ret

	
	switch (prb(MB_Role+MB_N)){
	case Role_Slave:
		if(MB_Frame[MB_N][0]==MB_NativeAddr[MB_N]){	// Slave     -   MB_TimerFlag
			MB_TimerFlag |= (1<<MB_N);
    530c:	20 91 29 09 	lds	r18, 0x0929
    5310:	81 e0       	ldi	r24, 0x01	; 1
    5312:	90 e0       	ldi	r25, 0x00	; 0
    5314:	02 c0       	rjmp	.+4      	; 0x531a <MB_Timer_ISR+0xae>
    5316:	88 0f       	add	r24, r24
    5318:	99 1f       	adc	r25, r25
    531a:	4a 95       	dec	r20
    531c:	e2 f7       	brpl	.-8      	; 0x5316 <MB_Timer_ISR+0xaa>
    531e:	28 2b       	or	r18, r24
    5320:	20 93 29 09 	sts	0x0929, r18
    5324:	08 95       	ret
	#if defined (__AVR_ATxmega128A1__)
		tc->INTCTRLA = (tc->INTCTRLA &~TC1_OVFINTLVL_gm) |TC_OVFINTLVL_OFF_gc;
		tc->CTRLA = TC_CLKSEL_OFF_gc;
	#endif
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Timer[MB_N]tc_f)!=tc; MB_N++);
    5326:	40 e0       	ldi	r20, 0x00	; 0
    5328:	50 e0       	ldi	r21, 0x00	; 0
    532a:	e0 e0       	ldi	r30, 0x00	; 0
    532c:	f0 e0       	ldi	r31, 0x00	; 0
    532e:	ba cf       	rjmp	.-140    	; 0x52a4 <MB_Timer_ISR+0x38>

00005330 <__vector_21>:
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#elif  defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) ||defined (__AVR_ATmega2561__)
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ISR(TIMER0_COMPA_vect)
{
    5330:	1f 92       	push	r1
    5332:	0f 92       	push	r0
    5334:	0f b6       	in	r0, 0x3f	; 63
    5336:	0f 92       	push	r0
    5338:	0b b6       	in	r0, 0x3b	; 59
    533a:	0f 92       	push	r0
    533c:	11 24       	eor	r1, r1
    533e:	2f 93       	push	r18
    5340:	3f 93       	push	r19
    5342:	4f 93       	push	r20
    5344:	5f 93       	push	r21
    5346:	6f 93       	push	r22
    5348:	7f 93       	push	r23
    534a:	8f 93       	push	r24
    534c:	9f 93       	push	r25
    534e:	af 93       	push	r26
    5350:	bf 93       	push	r27
    5352:	ef 93       	push	r30
    5354:	ff 93       	push	r31
	TCCR0B &=~(1<<CS02) &~(1<<CS01) &~(1<<CS00);
    5356:	85 b5       	in	r24, 0x25	; 37
    5358:	88 7f       	andi	r24, 0xF8	; 248
    535a:	85 bd       	out	0x25, r24	; 37
	TIMSK0 &=~(1<<OCIE0A);
    535c:	ee e6       	ldi	r30, 0x6E	; 110
    535e:	f0 e0       	ldi	r31, 0x00	; 0
    5360:	80 81       	ld	r24, Z
    5362:	8d 7f       	andi	r24, 0xFD	; 253
    5364:	80 83       	st	Z, r24
	MB_Timer_ISR(&TCNT0);
    5366:	86 e4       	ldi	r24, 0x46	; 70
    5368:	90 e0       	ldi	r25, 0x00	; 0
    536a:	0e 94 36 29 	call	0x526c	; 0x526c <MB_Timer_ISR>
}
    536e:	ff 91       	pop	r31
    5370:	ef 91       	pop	r30
    5372:	bf 91       	pop	r27
    5374:	af 91       	pop	r26
    5376:	9f 91       	pop	r25
    5378:	8f 91       	pop	r24
    537a:	7f 91       	pop	r23
    537c:	6f 91       	pop	r22
    537e:	5f 91       	pop	r21
    5380:	4f 91       	pop	r20
    5382:	3f 91       	pop	r19
    5384:	2f 91       	pop	r18
    5386:	0f 90       	pop	r0
    5388:	0b be       	out	0x3b, r0	; 59
    538a:	0f 90       	pop	r0
    538c:	0f be       	out	0x3f, r0	; 63
    538e:	0f 90       	pop	r0
    5390:	1f 90       	pop	r1
    5392:	18 95       	reti

00005394 <__vector_13>:

// ~~~~~~~~~~~~~~~~~~~
ISR(TIMER2_COMPA_vect)
{
    5394:	1f 92       	push	r1
    5396:	0f 92       	push	r0
    5398:	0f b6       	in	r0, 0x3f	; 63
    539a:	0f 92       	push	r0
    539c:	0b b6       	in	r0, 0x3b	; 59
    539e:	0f 92       	push	r0
    53a0:	11 24       	eor	r1, r1
    53a2:	2f 93       	push	r18
    53a4:	3f 93       	push	r19
    53a6:	4f 93       	push	r20
    53a8:	5f 93       	push	r21
    53aa:	6f 93       	push	r22
    53ac:	7f 93       	push	r23
    53ae:	8f 93       	push	r24
    53b0:	9f 93       	push	r25
    53b2:	af 93       	push	r26
    53b4:	bf 93       	push	r27
    53b6:	ef 93       	push	r30
    53b8:	ff 93       	push	r31
	TCCR2B &=~(1<<CS22) &~(1<<CS21) &~(1<<CS20);
    53ba:	e1 eb       	ldi	r30, 0xB1	; 177
    53bc:	f0 e0       	ldi	r31, 0x00	; 0
    53be:	80 81       	ld	r24, Z
    53c0:	88 7f       	andi	r24, 0xF8	; 248
    53c2:	80 83       	st	Z, r24
	TIMSK2 &=~(1<<OCIE2A);
    53c4:	e0 e7       	ldi	r30, 0x70	; 112
    53c6:	f0 e0       	ldi	r31, 0x00	; 0
    53c8:	80 81       	ld	r24, Z
    53ca:	8d 7f       	andi	r24, 0xFD	; 253
    53cc:	80 83       	st	Z, r24
	MB_Timer_ISR(&TCNT2);
    53ce:	82 eb       	ldi	r24, 0xB2	; 178
    53d0:	90 e0       	ldi	r25, 0x00	; 0
    53d2:	0e 94 36 29 	call	0x526c	; 0x526c <MB_Timer_ISR>
}
    53d6:	ff 91       	pop	r31
    53d8:	ef 91       	pop	r30
    53da:	bf 91       	pop	r27
    53dc:	af 91       	pop	r26
    53de:	9f 91       	pop	r25
    53e0:	8f 91       	pop	r24
    53e2:	7f 91       	pop	r23
    53e4:	6f 91       	pop	r22
    53e6:	5f 91       	pop	r21
    53e8:	4f 91       	pop	r20
    53ea:	3f 91       	pop	r19
    53ec:	2f 91       	pop	r18
    53ee:	0f 90       	pop	r0
    53f0:	0b be       	out	0x3b, r0	; 59
    53f2:	0f 90       	pop	r0
    53f4:	0f be       	out	0x3f, r0	; 63
    53f6:	0f 90       	pop	r0
    53f8:	1f 90       	pop	r1
    53fa:	18 95       	reti

000053fc <__vector_42>:
// ~~~~~~~~~~~~~~~~~~~
ISR(TIMER4_COMPA_vect)
{
    53fc:	1f 92       	push	r1
    53fe:	0f 92       	push	r0
    5400:	0f b6       	in	r0, 0x3f	; 63
    5402:	0f 92       	push	r0
    5404:	0b b6       	in	r0, 0x3b	; 59
    5406:	0f 92       	push	r0
    5408:	11 24       	eor	r1, r1
    540a:	2f 93       	push	r18
    540c:	3f 93       	push	r19
    540e:	4f 93       	push	r20
    5410:	5f 93       	push	r21
    5412:	6f 93       	push	r22
    5414:	7f 93       	push	r23
    5416:	8f 93       	push	r24
    5418:	9f 93       	push	r25
    541a:	af 93       	push	r26
    541c:	bf 93       	push	r27
    541e:	ef 93       	push	r30
    5420:	ff 93       	push	r31
	TCCR4B &=~(1<<CS42) &~(1<<CS41) &~(1<<CS40);
    5422:	e1 ea       	ldi	r30, 0xA1	; 161
    5424:	f0 e0       	ldi	r31, 0x00	; 0
    5426:	80 81       	ld	r24, Z
    5428:	88 7f       	andi	r24, 0xF8	; 248
    542a:	80 83       	st	Z, r24
	TIMSK4 &=~(1<<OCIE4A);
    542c:	e2 e7       	ldi	r30, 0x72	; 114
    542e:	f0 e0       	ldi	r31, 0x00	; 0
    5430:	80 81       	ld	r24, Z
    5432:	8d 7f       	andi	r24, 0xFD	; 253
    5434:	80 83       	st	Z, r24
	MB_Timer_ISR((uint8_t*)&TCNT4);
    5436:	84 ea       	ldi	r24, 0xA4	; 164
    5438:	90 e0       	ldi	r25, 0x00	; 0
    543a:	0e 94 36 29 	call	0x526c	; 0x526c <MB_Timer_ISR>
}
    543e:	ff 91       	pop	r31
    5440:	ef 91       	pop	r30
    5442:	bf 91       	pop	r27
    5444:	af 91       	pop	r26
    5446:	9f 91       	pop	r25
    5448:	8f 91       	pop	r24
    544a:	7f 91       	pop	r23
    544c:	6f 91       	pop	r22
    544e:	5f 91       	pop	r21
    5450:	4f 91       	pop	r20
    5452:	3f 91       	pop	r19
    5454:	2f 91       	pop	r18
    5456:	0f 90       	pop	r0
    5458:	0b be       	out	0x3b, r0	; 59
    545a:	0f 90       	pop	r0
    545c:	0f be       	out	0x3f, r0	; 63
    545e:	0f 90       	pop	r0
    5460:	1f 90       	pop	r1
    5462:	18 95       	reti

00005464 <MBRecept>:
		#endif
		MB_Err &=(1<<MB_N);
		return;
	}
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		Buf = USART_Reg(MB_N, ucsra);
    5464:	68 2f       	mov	r22, r24
    5466:	70 e0       	ldi	r23, 0x00	; 0

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5468:	9b 01       	movw	r18, r22
    546a:	22 0f       	add	r18, r18
    546c:	33 1f       	adc	r19, r19
    546e:	cb 01       	movw	r24, r22
    5470:	88 0f       	add	r24, r24
    5472:	99 1f       	adc	r25, r25
    5474:	88 0f       	add	r24, r24
    5476:	99 1f       	adc	r25, r25
    5478:	88 0f       	add	r24, r24
    547a:	99 1f       	adc	r25, r25
    547c:	28 0f       	add	r18, r24
    547e:	39 1f       	adc	r19, r25
    5480:	22 0f       	add	r18, r18
    5482:	33 1f       	adc	r19, r19
    5484:	2e 56       	subi	r18, 0x6E	; 110
    5486:	30 4d       	sbci	r19, 0xD0	; 208
    5488:	f9 01       	movw	r30, r18
    548a:	a5 91       	lpm	r26, Z+
    548c:	b4 91       	lpm	r27, Z+
    548e:	3c 91       	ld	r19, X
		MB_Frame[MB_N][MB_Frame_Sz[MB_N]++] = USART_Reg(MB_N, udr);
    5490:	ab 01       	movw	r20, r22
    5492:	47 5b       	subi	r20, 0xB7	; 183
    5494:	58 4f       	sbci	r21, 0xF8	; 248
    5496:	fa 01       	movw	r30, r20
    5498:	20 81       	ld	r18, Z
    549a:	cb 01       	movw	r24, r22
    549c:	88 0f       	add	r24, r24
    549e:	99 1f       	adc	r25, r25
    54a0:	88 0f       	add	r24, r24
    54a2:	99 1f       	adc	r25, r25
    54a4:	fc 01       	movw	r30, r24
    54a6:	ee 0f       	add	r30, r30
    54a8:	ff 1f       	adc	r31, r31
    54aa:	ee 0f       	add	r30, r30
    54ac:	ff 1f       	adc	r31, r31
    54ae:	e8 0f       	add	r30, r24
    54b0:	f9 1f       	adc	r31, r25
    54b2:	e0 57       	subi	r30, 0x70	; 112
    54b4:	f0 4d       	sbci	r31, 0xD0	; 208
    54b6:	a5 91       	lpm	r26, Z+
    54b8:	b4 91       	lpm	r27, Z+
    54ba:	f6 2f       	mov	r31, r22
    54bc:	ee 27       	eor	r30, r30
    54be:	e2 0f       	add	r30, r18
    54c0:	f1 1d       	adc	r31, r1
    54c2:	e6 59       	subi	r30, 0x96	; 150
    54c4:	f4 4f       	sbci	r31, 0xF4	; 244
    54c6:	8c 91       	ld	r24, X
    54c8:	80 83       	st	Z, r24
    54ca:	2f 5f       	subi	r18, 0xFF	; 255
    54cc:	fa 01       	movw	r30, r20
    54ce:	20 83       	st	Z, r18
	#elif defined (__AVR_ATxmega128A1__)
		USART_t *usart = prp(&MB_Port[MB_N].usart);
		Buf = usart->STATUS;
		MB_Frame[MB_N][MB_Frame_Sz[MB_N]++] = usart->DATA;
	#endif
	if (Buf &(1<<3))
    54d0:	23 2f       	mov	r18, r19
    54d2:	30 e0       	ldi	r19, 0x00	; 0
    54d4:	23 ff       	sbrs	r18, 3
    54d6:	0e c0       	rjmp	.+28     	; 0x54f4 <MBRecept+0x90>
		MB_CPT[MB_N][7]++;
    54d8:	fb 01       	movw	r30, r22
    54da:	e2 95       	swap	r30
    54dc:	f2 95       	swap	r31
    54de:	f0 7f       	andi	r31, 0xF0	; 240
    54e0:	fe 27       	eor	r31, r30
    54e2:	e0 7f       	andi	r30, 0xF0	; 240
    54e4:	fe 27       	eor	r31, r30
    54e6:	eb 5c       	subi	r30, 0xCB	; 203
    54e8:	f6 4f       	sbci	r31, 0xF6	; 246
    54ea:	86 85       	ldd	r24, Z+14	; 0x0e
    54ec:	97 85       	ldd	r25, Z+15	; 0x0f
    54ee:	01 96       	adiw	r24, 0x01	; 1
    54f0:	97 87       	std	Z+15, r25	; 0x0f
    54f2:	86 87       	std	Z+14, r24	; 0x0e
	if (Buf &((1<<4) |(1<<3) |(1<<2)))
    54f4:	2c 71       	andi	r18, 0x1C	; 28
    54f6:	30 70       	andi	r19, 0x00	; 0
    54f8:	23 2b       	or	r18, r19
    54fa:	61 f0       	breq	.+24     	; 0x5514 <MBRecept+0xb0>
		MB_Err |=(1<<MB_N);
    54fc:	81 e0       	ldi	r24, 0x01	; 1
    54fe:	90 e0       	ldi	r25, 0x00	; 0
    5500:	02 c0       	rjmp	.+4      	; 0x5506 <MBRecept+0xa2>
    5502:	88 0f       	add	r24, r24
    5504:	99 1f       	adc	r25, r25
    5506:	6a 95       	dec	r22
    5508:	e2 f7       	brpl	.-8      	; 0x5502 <MBRecept+0x9e>
    550a:	20 91 d9 04 	lds	r18, 0x04D9
    550e:	28 2b       	or	r18, r24
    5510:	20 93 d9 04 	sts	0x04D9, r18
    5514:	08 95       	ret

00005516 <MB_Transm>:
}

// ~~~~~~~~~~~~~~~~~~~~
void
MB_Transm(uint8_t MB_N)
{
    5516:	af 92       	push	r10
    5518:	bf 92       	push	r11
    551a:	cf 92       	push	r12
    551c:	df 92       	push	r13
    551e:	ef 92       	push	r14
    5520:	ff 92       	push	r15
    5522:	0f 93       	push	r16
    5524:	1f 93       	push	r17
	MB_State[MB_N] = MB_Trans;
    5526:	e8 2e       	mov	r14, r24
    5528:	ff 24       	eor	r15, r15
    552a:	f7 01       	movw	r30, r14
    552c:	ee 53       	subi	r30, 0x3E	; 62
    552e:	fa 4f       	sbci	r31, 0xFA	; 250
    5530:	83 e0       	ldi	r24, 0x03	; 3
    5532:	80 83       	st	Z, r24
    5534:	57 01       	movw	r10, r14
    5536:	aa 0c       	add	r10, r10
    5538:	bb 1c       	adc	r11, r11
    553a:	aa 0c       	add	r10, r10
    553c:	bb 1c       	adc	r11, r11
    553e:	85 01       	movw	r16, r10
    5540:	00 0f       	add	r16, r16
    5542:	11 1f       	adc	r17, r17
    5544:	00 0f       	add	r16, r16
    5546:	11 1f       	adc	r17, r17
    5548:	0a 0d       	add	r16, r10
    554a:	1b 1d       	adc	r17, r11
    554c:	04 5f       	subi	r16, 0xF4	; 244
    554e:	1f 4f       	sbci	r17, 0xFF	; 255
    5550:	80 e9       	ldi	r24, 0x90	; 144
    5552:	c8 2e       	mov	r12, r24
    5554:	8f e2       	ldi	r24, 0x2F	; 47
    5556:	d8 2e       	mov	r13, r24
    5558:	c6 01       	movw	r24, r12
    555a:	80 0f       	add	r24, r16
    555c:	91 1f       	adc	r25, r17
    555e:	0c 50       	subi	r16, 0x0C	; 12
    5560:	10 40       	sbci	r17, 0x00	; 0
    5562:	fc 01       	movw	r30, r24
    5564:	25 91       	lpm	r18, Z+
    5566:	34 91       	lpm	r19, Z+
	USART_Func(MB_N, RS485);
    5568:	f9 01       	movw	r30, r18
    556a:	19 95       	eicall
    556c:	f6 01       	movw	r30, r12
    556e:	e0 0f       	add	r30, r16
    5570:	f1 1f       	adc	r31, r17
    5572:	a5 91       	lpm	r26, Z+
    5574:	b4 91       	lpm	r27, Z+
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		//USART_Reg(MB_N, ucsrb) |=(1<<6);
		USART_Reg(MB_N, udr) = MB_Frame[MB_N][0];
    5576:	fe 2d       	mov	r31, r14
    5578:	ee 27       	eor	r30, r30
    557a:	e6 59       	subi	r30, 0x96	; 150
    557c:	f4 4f       	sbci	r31, 0xF4	; 244
    557e:	80 81       	ld	r24, Z
    5580:	8c 93       	st	X, r24
    5582:	97 01       	movw	r18, r14
    5584:	22 0f       	add	r18, r18
    5586:	33 1f       	adc	r19, r19
    5588:	c7 01       	movw	r24, r14
    558a:	88 0f       	add	r24, r24
    558c:	99 1f       	adc	r25, r25
    558e:	88 0f       	add	r24, r24
    5590:	99 1f       	adc	r25, r25
    5592:	88 0f       	add	r24, r24
    5594:	99 1f       	adc	r25, r25
    5596:	28 0f       	add	r18, r24
    5598:	39 1f       	adc	r19, r25
    559a:	2f 5f       	subi	r18, 0xFF	; 255
    559c:	3f 4f       	sbci	r19, 0xFF	; 255
    559e:	22 0f       	add	r18, r18
    55a0:	33 1f       	adc	r19, r19
    55a2:	2c 0d       	add	r18, r12
    55a4:	3d 1d       	adc	r19, r13
    55a6:	f9 01       	movw	r30, r18
    55a8:	a5 91       	lpm	r26, Z+
    55aa:	b4 91       	lpm	r27, Z+

		USART_Reg(MB_N, ucsra) |=(1<<6);	//Clear TxC pending interrupt		
    55ac:	8c 91       	ld	r24, X
    55ae:	80 64       	ori	r24, 0x40	; 64
    55b0:	8c 93       	st	X, r24
    55b2:	c5 01       	movw	r24, r10
    55b4:	8e 0d       	add	r24, r14
    55b6:	9f 1d       	adc	r25, r15
    55b8:	01 96       	adiw	r24, 0x01	; 1
    55ba:	88 0f       	add	r24, r24
    55bc:	99 1f       	adc	r25, r25
    55be:	88 0f       	add	r24, r24
    55c0:	99 1f       	adc	r25, r25
    55c2:	8c 0d       	add	r24, r12
    55c4:	9d 1d       	adc	r25, r13
    55c6:	fc 01       	movw	r30, r24
    55c8:	a5 91       	lpm	r26, Z+
    55ca:	b4 91       	lpm	r27, Z+
		USART_Reg(MB_N, ucsrb) |=(1<<5);
    55cc:	8c 91       	ld	r24, X
    55ce:	80 62       	ori	r24, 0x20	; 32
    55d0:	8c 93       	st	X, r24
	#elif defined (__AVR_ATxmega128A1__)
		USART_t *usart = prp(&MB_Port[MB_N].usart);
		usart->CTRLA = (usart->CTRLA &~USART_TXCINTLVL_gm) |USART_TXCINTLVL_HI_gc;
		usart->DATA = MB_Frame[MB_N][0];
	#endif
}
    55d2:	1f 91       	pop	r17
    55d4:	0f 91       	pop	r16
    55d6:	ff 90       	pop	r15
    55d8:	ef 90       	pop	r14
    55da:	df 90       	pop	r13
    55dc:	cf 90       	pop	r12
    55de:	bf 90       	pop	r11
    55e0:	af 90       	pop	r10
    55e2:	08 95       	ret

000055e4 <Modbus_RX>:

// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_RX(usart_t *usart)
{
    55e4:	cf 93       	push	r28
    55e6:	df 93       	push	r29
    55e8:	dc 01       	movw	r26, r24
    55ea:	e0 e9       	ldi	r30, 0x90	; 144
    55ec:	ff e2       	ldi	r31, 0x2F	; 47
    55ee:	85 91       	lpm	r24, Z+
    55f0:	94 91       	lpm	r25, Z+
// ~~~~~~~~~~~~~~~~~~~~~~
static uint8_t
MB_Port_N(usart_t *usart)
{
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Port[MB_N].usart_field)!=usart; MB_N++);
    55f2:	a8 17       	cp	r26, r24
    55f4:	b9 07       	cpc	r27, r25
    55f6:	09 f4       	brne	.+2      	; 0x55fa <Modbus_RX+0x16>
    55f8:	6e c0       	rjmp	.+220    	; 0x56d6 <Modbus_RX+0xf2>
    55fa:	30 e0       	ldi	r19, 0x00	; 0
    55fc:	3f 5f       	subi	r19, 0xFF	; 255
    55fe:	c3 2f       	mov	r28, r19
    5600:	d0 e0       	ldi	r29, 0x00	; 0
    5602:	ce 01       	movw	r24, r28
    5604:	88 0f       	add	r24, r24
    5606:	99 1f       	adc	r25, r25
    5608:	88 0f       	add	r24, r24
    560a:	99 1f       	adc	r25, r25
    560c:	fc 01       	movw	r30, r24
    560e:	ee 0f       	add	r30, r30
    5610:	ff 1f       	adc	r31, r31
    5612:	ee 0f       	add	r30, r30
    5614:	ff 1f       	adc	r31, r31
    5616:	e8 0f       	add	r30, r24
    5618:	f9 1f       	adc	r31, r25
    561a:	e0 57       	subi	r30, 0x70	; 112
    561c:	f0 4d       	sbci	r31, 0xD0	; 208
    561e:	85 91       	lpm	r24, Z+
    5620:	94 91       	lpm	r25, Z+
    5622:	a8 17       	cp	r26, r24
    5624:	b9 07       	cpc	r27, r25
    5626:	51 f7       	brne	.-44     	; 0x55fc <Modbus_RX+0x18>
// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_RX(usart_t *usart)
{
	uint8_t MB_N = MB_Port_N(usart);
	switch (MB_State[MB_N]) {
    5628:	fe 01       	movw	r30, r28
    562a:	ee 53       	subi	r30, 0x3E	; 62
    562c:	fa 4f       	sbci	r31, 0xFA	; 250
    562e:	80 81       	ld	r24, Z
    5630:	82 30       	cpi	r24, 0x02	; 2
    5632:	19 f1       	breq	.+70     	; 0x567a <Modbus_RX+0x96>
    5634:	83 30       	cpi	r24, 0x03	; 3
    5636:	28 f0       	brcs	.+10     	; 0x5642 <Modbus_RX+0x5e>
    5638:	86 30       	cpi	r24, 0x06	; 6
    563a:	d8 f0       	brcs	.+54     	; 0x5672 <Modbus_RX+0x8e>
	case MB_Trans: case MB_Proc: 
	case MB_NoReply: // MB_NoReply    MB_Recept ..  MB_M_Cycle   MB_Trans
		usart_data(usart);
		break;
	}
}
    563c:	df 91       	pop	r29
    563e:	cf 91       	pop	r28
    5640:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_RX(usart_t *usart)
{
	uint8_t MB_N = MB_Port_N(usart);
	switch (MB_State[MB_N]) {
    5642:	88 23       	and	r24, r24
    5644:	f1 f4       	brne	.+60     	; 0x5682 <Modbus_RX+0x9e>
	case MB_Initi:
		MB_Frame[MB_N][0] = usart_data(usart);
    5646:	8c 91       	ld	r24, X
    5648:	fc 2f       	mov	r31, r28
    564a:	ee 27       	eor	r30, r30
    564c:	e6 59       	subi	r30, 0x96	; 150
    564e:	f4 4f       	sbci	r31, 0xF4	; 244
    5650:	80 83       	st	Z, r24
    5652:	ce 01       	movw	r24, r28
    5654:	88 0f       	add	r24, r24
    5656:	99 1f       	adc	r25, r25
    5658:	8c 0f       	add	r24, r28
    565a:	9d 1f       	adc	r25, r29
    565c:	88 0f       	add	r24, r24
    565e:	99 1f       	adc	r25, r25
    5660:	8b 55       	subi	r24, 0x5B	; 91
    5662:	90 4d       	sbci	r25, 0xD0	; 208
    5664:	fc 01       	movw	r30, r24
    5666:	a5 91       	lpm	r26, Z+
    5668:	b4 91       	lpm	r27, Z+
		break;
	case MB_Recept:
		/*if(TCNT2>=prb(&(BR_Tbl+MB_BitRate_RAM[MB_N])->Time15))
			MB_Err &=(1<<MB_N);*/
		MBRecept(MB_N);
		MB_ClearTimer(MB_N);
    566a:	1c 92       	st	X, r1
	case MB_Trans: case MB_Proc: 
	case MB_NoReply: // MB_NoReply    MB_Recept ..  MB_M_Cycle   MB_Trans
		usart_data(usart);
		break;
	}
}
    566c:	df 91       	pop	r29
    566e:	cf 91       	pop	r28
    5670:	08 95       	ret
		MBRecept(MB_N);
		MB_ClearTimer(MB_N);
		break;
	case MB_Trans: case MB_Proc: 
	case MB_NoReply: // MB_NoReply    MB_Recept ..  MB_M_Cycle   MB_Trans
		usart_data(usart);
    5672:	8c 91       	ld	r24, X
		break;
	}
}
    5674:	df 91       	pop	r29
    5676:	cf 91       	pop	r28
    5678:	08 95       	ret
		MB_StartTimer(MB_N);
		break;
	case MB_Recept:
		/*if(TCNT2>=prb(&(BR_Tbl+MB_BitRate_RAM[MB_N])->Time15))
			MB_Err &=(1<<MB_N);*/
		MBRecept(MB_N);
    567a:	83 2f       	mov	r24, r19
    567c:	0e 94 32 2a 	call	0x5464	; 0x5464 <MBRecept>
    5680:	e8 cf       	rjmp	.-48     	; 0x5652 <Modbus_RX+0x6e>
// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_RX(usart_t *usart)
{
	uint8_t MB_N = MB_Port_N(usart);
	switch (MB_State[MB_N]) {
    5682:	81 30       	cpi	r24, 0x01	; 1
    5684:	d9 f6       	brne	.-74     	; 0x563c <Modbus_RX+0x58>
	case MB_Initi:
		MB_Frame[MB_N][0] = usart_data(usart);
		MB_ClearTimer(MB_N);
		break;
	case MB_Idle: 
		MB_State[MB_N] = MB_Recept;
    5686:	82 e0       	ldi	r24, 0x02	; 2
    5688:	80 83       	st	Z, r24
		MB_Err &=~(1<<MB_N);
    568a:	81 e0       	ldi	r24, 0x01	; 1
    568c:	90 e0       	ldi	r25, 0x00	; 0
    568e:	0c 2e       	mov	r0, r28
    5690:	02 c0       	rjmp	.+4      	; 0x5696 <Modbus_RX+0xb2>
    5692:	88 0f       	add	r24, r24
    5694:	99 1f       	adc	r25, r25
    5696:	0a 94       	dec	r0
    5698:	e2 f7       	brpl	.-8      	; 0x5692 <Modbus_RX+0xae>
    569a:	80 95       	com	r24
    569c:	20 91 d9 04 	lds	r18, 0x04D9
    56a0:	28 23       	and	r18, r24
    56a2:	20 93 d9 04 	sts	0x04D9, r18
		MB_Frame_Sz[MB_N] = 0;
    56a6:	fe 01       	movw	r30, r28
    56a8:	e7 5b       	subi	r30, 0xB7	; 183
    56aa:	f8 4f       	sbci	r31, 0xF8	; 248
    56ac:	10 82       	st	Z, r1
		MBRecept(MB_N);
    56ae:	83 2f       	mov	r24, r19
    56b0:	0e 94 32 2a 	call	0x5464	; 0x5464 <MBRecept>
    56b4:	ce 01       	movw	r24, r28
    56b6:	88 0f       	add	r24, r24
    56b8:	99 1f       	adc	r25, r25
    56ba:	8c 0f       	add	r24, r28
    56bc:	9d 1f       	adc	r25, r29
    56be:	88 0f       	add	r24, r24
    56c0:	99 1f       	adc	r25, r25
    56c2:	87 55       	subi	r24, 0x57	; 87
    56c4:	90 4d       	sbci	r25, 0xD0	; 208
    56c6:	fc 01       	movw	r30, r24
    56c8:	25 91       	lpm	r18, Z+
    56ca:	34 91       	lpm	r19, Z+
		MB_StartTimer(MB_N);
    56cc:	f9 01       	movw	r30, r18
    56ce:	19 95       	eicall
	case MB_Trans: case MB_Proc: 
	case MB_NoReply: // MB_NoReply    MB_Recept ..  MB_M_Cycle   MB_Trans
		usart_data(usart);
		break;
	}
}
    56d0:	df 91       	pop	r29
    56d2:	cf 91       	pop	r28
    56d4:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~
static uint8_t
MB_Port_N(usart_t *usart)
{
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Port[MB_N].usart_field)!=usart; MB_N++);
    56d6:	30 e0       	ldi	r19, 0x00	; 0
    56d8:	c0 e0       	ldi	r28, 0x00	; 0
    56da:	d0 e0       	ldi	r29, 0x00	; 0
    56dc:	a5 cf       	rjmp	.-182    	; 0x5628 <Modbus_RX+0x44>

000056de <CommErr>:
}

// ~~~~~~~~~~~~~~~~~~
uint8_t
CommErr(uint8_t MB_N)
{
    56de:	0f 93       	push	r16
    56e0:	1f 93       	push	r17
    56e2:	cf 93       	push	r28
    56e4:	df 93       	push	r29
    56e6:	38 2f       	mov	r19, r24
	uint8_t Sz = MB_Frame_Sz[MB_N]-2;
    56e8:	c8 2f       	mov	r28, r24
    56ea:	d0 e0       	ldi	r29, 0x00	; 0
    56ec:	fe 01       	movw	r30, r28
    56ee:	e7 5b       	subi	r30, 0xB7	; 183
    56f0:	f8 4f       	sbci	r31, 0xF8	; 248
    56f2:	20 81       	ld	r18, Z
	uint8_t Err = MB_Err &(1<<MB_N) || MB_Frame_Sz[MB_N]<3 || *(uint16_t*)(MB_Frame[MB_N]+Sz)!=CRC(rrb, MB_Frame[MB_N], Sz);
    56f4:	80 91 d9 04 	lds	r24, 0x04D9
    56f8:	90 e0       	ldi	r25, 0x00	; 0
    56fa:	03 2e       	mov	r0, r19
    56fc:	02 c0       	rjmp	.+4      	; 0x5702 <CommErr+0x24>
    56fe:	95 95       	asr	r25
    5700:	87 95       	ror	r24
    5702:	0a 94       	dec	r0
    5704:	e2 f7       	brpl	.-8      	; 0x56fe <CommErr+0x20>
    5706:	80 ff       	sbrs	r24, 0
    5708:	29 c0       	rjmp	.+82     	; 0x575c <CommErr+0x7e>
	if (Err) {
		MB_CPT[MB_N][1]++;
    570a:	fe 01       	movw	r30, r28
    570c:	ee 0f       	add	r30, r30
    570e:	ff 1f       	adc	r31, r31
    5710:	ee 0f       	add	r30, r30
    5712:	ff 1f       	adc	r31, r31
    5714:	ee 0f       	add	r30, r30
    5716:	ff 1f       	adc	r31, r31
    5718:	ee 0f       	add	r30, r30
    571a:	ff 1f       	adc	r31, r31
    571c:	e9 5c       	subi	r30, 0xC9	; 201
    571e:	f6 4f       	sbci	r31, 0xF6	; 246
    5720:	80 81       	ld	r24, Z
    5722:	91 81       	ldd	r25, Z+1	; 0x01
    5724:	01 96       	adiw	r24, 0x01	; 1
    5726:	91 83       	std	Z+1, r25	; 0x01
    5728:	80 83       	st	Z, r24
    572a:	ce 01       	movw	r24, r28
    572c:	88 0f       	add	r24, r24
    572e:	99 1f       	adc	r25, r25
    5730:	88 0f       	add	r24, r24
    5732:	99 1f       	adc	r25, r25
    5734:	9c 01       	movw	r18, r24
    5736:	22 0f       	add	r18, r18
    5738:	33 1f       	adc	r19, r19
    573a:	22 0f       	add	r18, r18
    573c:	33 1f       	adc	r19, r19
    573e:	28 0f       	add	r18, r24
    5740:	39 1f       	adc	r19, r25
    5742:	20 56       	subi	r18, 0x60	; 96
    5744:	30 4d       	sbci	r19, 0xD0	; 208
    5746:	f9 01       	movw	r30, r18
    5748:	85 91       	lpm	r24, Z+
    574a:	94 91       	lpm	r25, Z+
		USART_Func(MB_N, LED_Err_On);
    574c:	fc 01       	movw	r30, r24
    574e:	19 95       	eicall
    5750:	81 e0       	ldi	r24, 0x01	; 1
	else {
		MB_CPT[MB_N][0]++;
		USART_Func(MB_N, LED_Err_Off);
	}
	return Err;
}
    5752:	df 91       	pop	r29
    5754:	cf 91       	pop	r28
    5756:	1f 91       	pop	r17
    5758:	0f 91       	pop	r16
    575a:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~
uint8_t
CommErr(uint8_t MB_N)
{
	uint8_t Sz = MB_Frame_Sz[MB_N]-2;
	uint8_t Err = MB_Err &(1<<MB_N) || MB_Frame_Sz[MB_N]<3 || *(uint16_t*)(MB_Frame[MB_N]+Sz)!=CRC(rrb, MB_Frame[MB_N], Sz);
    575c:	23 30       	cpi	r18, 0x03	; 3
    575e:	a8 f2       	brcs	.-86     	; 0x570a <CommErr+0x2c>

// ~~~~~~~~~~~~~~~~~~
uint8_t
CommErr(uint8_t MB_N)
{
	uint8_t Sz = MB_Frame_Sz[MB_N]-2;
    5760:	22 50       	subi	r18, 0x02	; 2
	uint8_t Err = MB_Err &(1<<MB_N) || MB_Frame_Sz[MB_N]<3 || *(uint16_t*)(MB_Frame[MB_N]+Sz)!=CRC(rrb, MB_Frame[MB_N], Sz);
    5762:	73 2f       	mov	r23, r19
    5764:	60 e0       	ldi	r22, 0x00	; 0
    5766:	fb 01       	movw	r30, r22
    5768:	e2 0f       	add	r30, r18
    576a:	f1 1d       	adc	r31, r1
    576c:	e6 59       	subi	r30, 0x96	; 150
    576e:	f4 4f       	sbci	r31, 0xF4	; 244
    5770:	00 81       	ld	r16, Z
    5772:	11 81       	ldd	r17, Z+1	; 0x01
    5774:	66 59       	subi	r22, 0x96	; 150
    5776:	74 4f       	sbci	r23, 0xF4	; 244
    5778:	30 e0       	ldi	r19, 0x00	; 0
    577a:	40 e0       	ldi	r20, 0x00	; 0
    577c:	50 e0       	ldi	r21, 0x00	; 0
    577e:	81 e2       	ldi	r24, 0x21	; 33
    5780:	9a e1       	ldi	r25, 0x1A	; 26
    5782:	0e 94 94 1a 	call	0x3528	; 0x3528 <CRC>
    5786:	08 17       	cp	r16, r24
    5788:	19 07       	cpc	r17, r25
    578a:	09 f0       	breq	.+2      	; 0x578e <CommErr+0xb0>
    578c:	be cf       	rjmp	.-132    	; 0x570a <CommErr+0x2c>
	if (Err) {
		MB_CPT[MB_N][1]++;
		USART_Func(MB_N, LED_Err_On);
	}
	else {
		MB_CPT[MB_N][0]++;
    578e:	fe 01       	movw	r30, r28
    5790:	e2 95       	swap	r30
    5792:	f2 95       	swap	r31
    5794:	f0 7f       	andi	r31, 0xF0	; 240
    5796:	fe 27       	eor	r31, r30
    5798:	e0 7f       	andi	r30, 0xF0	; 240
    579a:	fe 27       	eor	r31, r30
    579c:	eb 5c       	subi	r30, 0xCB	; 203
    579e:	f6 4f       	sbci	r31, 0xF6	; 246
    57a0:	80 81       	ld	r24, Z
    57a2:	91 81       	ldd	r25, Z+1	; 0x01
    57a4:	01 96       	adiw	r24, 0x01	; 1
    57a6:	91 83       	std	Z+1, r25	; 0x01
    57a8:	80 83       	st	Z, r24
    57aa:	ce 01       	movw	r24, r28
    57ac:	88 0f       	add	r24, r24
    57ae:	99 1f       	adc	r25, r25
    57b0:	88 0f       	add	r24, r24
    57b2:	99 1f       	adc	r25, r25
    57b4:	9c 01       	movw	r18, r24
    57b6:	22 0f       	add	r18, r18
    57b8:	33 1f       	adc	r19, r19
    57ba:	22 0f       	add	r18, r18
    57bc:	33 1f       	adc	r19, r19
    57be:	28 0f       	add	r18, r24
    57c0:	39 1f       	adc	r19, r25
    57c2:	2e 55       	subi	r18, 0x5E	; 94
    57c4:	30 4d       	sbci	r19, 0xD0	; 208
    57c6:	f9 01       	movw	r30, r18
    57c8:	85 91       	lpm	r24, Z+
    57ca:	94 91       	lpm	r25, Z+
		USART_Func(MB_N, LED_Err_Off);
    57cc:	fc 01       	movw	r30, r24
    57ce:	19 95       	eicall
    57d0:	80 e0       	ldi	r24, 0x00	; 0
    57d2:	bf cf       	rjmp	.-130    	; 0x5752 <CommErr+0x74>

000057d4 <SetCRC_MB>:
}

// ~~~~~~~~~~~~~~~~~~~~
void
SetCRC_MB(uint8_t MB_N)
{
    57d4:	df 92       	push	r13
    57d6:	ef 92       	push	r14
    57d8:	ff 92       	push	r15
    57da:	0f 93       	push	r16
    57dc:	1f 93       	push	r17
	uint8_t Sz = MB_Frame_Sz[MB_N]-2;
    57de:	e9 e4       	ldi	r30, 0x49	; 73
    57e0:	f7 e0       	ldi	r31, 0x07	; 7
    57e2:	e8 0f       	add	r30, r24
    57e4:	f1 1d       	adc	r31, r1
    57e6:	d0 80       	ld	r13, Z
    57e8:	9e ef       	ldi	r25, 0xFE	; 254
    57ea:	d9 0e       	add	r13, r25
	*(uint16_t*)(MB_Frame[MB_N]+Sz) = CRC(rrb, MB_Frame[MB_N], Sz);
    57ec:	18 2f       	mov	r17, r24
    57ee:	00 e0       	ldi	r16, 0x00	; 0
    57f0:	8a e6       	ldi	r24, 0x6A	; 106
    57f2:	e8 2e       	mov	r14, r24
    57f4:	8b e0       	ldi	r24, 0x0B	; 11
    57f6:	f8 2e       	mov	r15, r24
    57f8:	b7 01       	movw	r22, r14
    57fa:	60 0f       	add	r22, r16
    57fc:	71 1f       	adc	r23, r17
    57fe:	2d 2d       	mov	r18, r13
    5800:	30 e0       	ldi	r19, 0x00	; 0
    5802:	40 e0       	ldi	r20, 0x00	; 0
    5804:	50 e0       	ldi	r21, 0x00	; 0
    5806:	81 e2       	ldi	r24, 0x21	; 33
    5808:	9a e1       	ldi	r25, 0x1A	; 26
    580a:	0e 94 94 1a 	call	0x3528	; 0x3528 <CRC>
    580e:	0d 0d       	add	r16, r13
    5810:	11 1d       	adc	r17, r1
    5812:	e0 0e       	add	r14, r16
    5814:	f1 1e       	adc	r15, r17
    5816:	f7 01       	movw	r30, r14
    5818:	91 83       	std	Z+1, r25	; 0x01
    581a:	80 83       	st	Z, r24
}
    581c:	1f 91       	pop	r17
    581e:	0f 91       	pop	r16
    5820:	ff 90       	pop	r15
    5822:	ef 90       	pop	r14
    5824:	df 90       	pop	r13
    5826:	08 95       	ret

00005828 <MB_FrameReg>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
MB_FrameReg(uint8_t MB_N, uint8_t i)
{
	return MB_Frame[MB_N][i]<<8 | MB_Frame[MB_N][i+1];
    5828:	70 e0       	ldi	r23, 0x00	; 0
    582a:	aa e6       	ldi	r26, 0x6A	; 106
    582c:	bb e0       	ldi	r27, 0x0B	; 11
    582e:	f8 2f       	mov	r31, r24
    5830:	e0 e0       	ldi	r30, 0x00	; 0
    5832:	ea 0f       	add	r30, r26
    5834:	fb 1f       	adc	r31, r27
    5836:	e6 0f       	add	r30, r22
    5838:	f7 1f       	adc	r31, r23
    583a:	41 81       	ldd	r20, Z+1	; 0x01
    583c:	50 e0       	ldi	r21, 0x00	; 0
    583e:	38 2f       	mov	r19, r24
    5840:	20 e0       	ldi	r18, 0x00	; 0
    5842:	26 0f       	add	r18, r22
    5844:	37 1f       	adc	r19, r23
    5846:	a2 0f       	add	r26, r18
    5848:	b3 1f       	adc	r27, r19
    584a:	9c 91       	ld	r25, X
    584c:	80 e0       	ldi	r24, 0x00	; 0
    584e:	48 2b       	or	r20, r24
    5850:	59 2b       	or	r21, r25
}
    5852:	ca 01       	movw	r24, r20
    5854:	08 95       	ret

00005856 <MB_CPT_Clear>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~
void
MB_CPT_Clear(uint8_t MB_N)
{
    5856:	90 e0       	ldi	r25, 0x00	; 0
    5858:	20 e0       	ldi	r18, 0x00	; 0
    585a:	30 e0       	ldi	r19, 0x00	; 0
    585c:	88 0f       	add	r24, r24
    585e:	99 1f       	adc	r25, r25
    5860:	88 0f       	add	r24, r24
    5862:	99 1f       	adc	r25, r25
    5864:	88 0f       	add	r24, r24
    5866:	99 1f       	adc	r25, r25
	for (uint8_t i=0; i<8; MB_CPT[MB_N][i++]=0);
    5868:	fc 01       	movw	r30, r24
    586a:	e2 0f       	add	r30, r18
    586c:	f3 1f       	adc	r31, r19
    586e:	ee 0f       	add	r30, r30
    5870:	ff 1f       	adc	r31, r31
    5872:	eb 5c       	subi	r30, 0xCB	; 203
    5874:	f6 4f       	sbci	r31, 0xF6	; 246
    5876:	11 82       	std	Z+1, r1	; 0x01
    5878:	10 82       	st	Z, r1
    587a:	2f 5f       	subi	r18, 0xFF	; 255
    587c:	3f 4f       	sbci	r19, 0xFF	; 255
    587e:	28 30       	cpi	r18, 0x08	; 8
    5880:	31 05       	cpc	r19, r1
    5882:	91 f7       	brne	.-28     	; 0x5868 <MB_CPT_Clear+0x12>
}
    5884:	08 95       	ret

00005886 <MB_S_Timer_ISR>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_S_Timer_ISR(uint8_t MB_N)
{
    5886:	2f 92       	push	r2
    5888:	3f 92       	push	r3
    588a:	4f 92       	push	r4
    588c:	5f 92       	push	r5
    588e:	6f 92       	push	r6
    5890:	7f 92       	push	r7
    5892:	8f 92       	push	r8
    5894:	9f 92       	push	r9
    5896:	af 92       	push	r10
    5898:	bf 92       	push	r11
    589a:	cf 92       	push	r12
    589c:	df 92       	push	r13
    589e:	ef 92       	push	r14
    58a0:	ff 92       	push	r15
    58a2:	0f 93       	push	r16
    58a4:	1f 93       	push	r17
    58a6:	df 93       	push	r29
    58a8:	cf 93       	push	r28
    58aa:	cd b7       	in	r28, 0x3d	; 61
    58ac:	de b7       	in	r29, 0x3e	; 62
    58ae:	29 97       	sbiw	r28, 0x09	; 9
    58b0:	0f b6       	in	r0, 0x3f	; 63
    58b2:	f8 94       	cli
    58b4:	de bf       	out	0x3e, r29	; 62
    58b6:	0f be       	out	0x3f, r0	; 63
    58b8:	cd bf       	out	0x3d, r28	; 61
    58ba:	d8 2e       	mov	r13, r24
	switch (MB_State[MB_N]) {
    58bc:	28 2f       	mov	r18, r24
    58be:	30 e0       	ldi	r19, 0x00	; 0
    58c0:	39 87       	std	Y+9, r19	; 0x09
    58c2:	28 87       	std	Y+8, r18	; 0x08
    58c4:	89 01       	movw	r16, r18
    58c6:	0e 53       	subi	r16, 0x3E	; 62
    58c8:	1a 4f       	sbci	r17, 0xFA	; 250
    58ca:	d8 01       	movw	r26, r16
    58cc:	8c 91       	ld	r24, X
    58ce:	88 23       	and	r24, r24
    58d0:	b9 f1       	breq	.+110    	; 0x5940 <MB_S_Timer_ISR+0xba>
    58d2:	82 30       	cpi	r24, 0x02	; 2
    58d4:	c9 f0       	breq	.+50     	; 0x5908 <MB_S_Timer_ISR+0x82>
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
		MB_S_CtrlProc(MB_N);
		break;
	}
}
    58d6:	29 96       	adiw	r28, 0x09	; 9
    58d8:	0f b6       	in	r0, 0x3f	; 63
    58da:	f8 94       	cli
    58dc:	de bf       	out	0x3e, r29	; 62
    58de:	0f be       	out	0x3f, r0	; 63
    58e0:	cd bf       	out	0x3d, r28	; 61
    58e2:	cf 91       	pop	r28
    58e4:	df 91       	pop	r29
    58e6:	1f 91       	pop	r17
    58e8:	0f 91       	pop	r16
    58ea:	ff 90       	pop	r15
    58ec:	ef 90       	pop	r14
    58ee:	df 90       	pop	r13
    58f0:	cf 90       	pop	r12
    58f2:	bf 90       	pop	r11
    58f4:	af 90       	pop	r10
    58f6:	9f 90       	pop	r9
    58f8:	8f 90       	pop	r8
    58fa:	7f 90       	pop	r7
    58fc:	6f 90       	pop	r6
    58fe:	5f 90       	pop	r5
    5900:	4f 90       	pop	r4
    5902:	3f 90       	pop	r3
    5904:	2f 90       	pop	r2
    5906:	08 95       	ret
	switch (MB_State[MB_N]) {
	case MB_Initi:
		MB_State[MB_N] = MB_Idle;
		break;
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
    5908:	84 e0       	ldi	r24, 0x04	; 4
    590a:	d8 01       	movw	r26, r16
    590c:	8c 93       	st	X, r24

// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
MB_S_CtrlProc(uint8_t MB_N)
{
	if (CommErr(MB_N)) {
    590e:	8d 2d       	mov	r24, r13
    5910:	0e 94 6f 2b 	call	0x56de	; 0x56de <CommErr>
    5914:	88 23       	and	r24, r24
    5916:	a1 f4       	brne	.+40     	; 0x5940 <MB_S_Timer_ISR+0xba>
		MB_State[MB_N] = MB_Idle;
		return;
	}
	if (MB_Frame[MB_N][0]!=0 && MB_Frame[MB_N][0]!=MB_NativeAddr[MB_N]) {
    5918:	28 85       	ldd	r18, Y+8	; 0x08
    591a:	39 85       	ldd	r19, Y+9	; 0x09
    591c:	f2 2e       	mov	r15, r18
    591e:	ee 24       	eor	r14, r14
    5920:	f7 01       	movw	r30, r14
    5922:	e6 59       	subi	r30, 0x96	; 150
    5924:	f4 4f       	sbci	r31, 0xF4	; 244
    5926:	90 81       	ld	r25, Z
    5928:	99 23       	and	r25, r25
    592a:	71 f0       	breq	.+28     	; 0x5948 <MB_S_Timer_ISR+0xc2>
    592c:	f9 01       	movw	r30, r18
    592e:	e0 52       	subi	r30, 0x20	; 32
    5930:	fa 4f       	sbci	r31, 0xFA	; 250
    5932:	80 81       	ld	r24, Z
    5934:	98 17       	cp	r25, r24
    5936:	41 f0       	breq	.+16     	; 0x5948 <MB_S_Timer_ISR+0xc2>
		MB_State[MB_N] = MB_Idle;
    5938:	81 e0       	ldi	r24, 0x01	; 1
    593a:	d8 01       	movw	r26, r16
    593c:	8c 93       	st	X, r24
    593e:	cb cf       	rjmp	.-106    	; 0x58d6 <MB_S_Timer_ISR+0x50>
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
MB_S_CtrlProc(uint8_t MB_N)
{
	if (CommErr(MB_N)) {
		MB_State[MB_N] = MB_Idle;
    5940:	81 e0       	ldi	r24, 0x01	; 1
    5942:	f8 01       	movw	r30, r16
    5944:	80 83       	st	Z, r24
    5946:	c7 cf       	rjmp	.-114    	; 0x58d6 <MB_S_Timer_ISR+0x50>
    5948:	28 84       	ldd	r2, Y+8	; 0x08
    594a:	39 84       	ldd	r3, Y+9	; 0x09
    594c:	22 0c       	add	r2, r2
    594e:	33 1c       	adc	r3, r3
    5950:	22 0c       	add	r2, r2
    5952:	33 1c       	adc	r3, r3
    5954:	51 01       	movw	r10, r2
    5956:	aa 0c       	add	r10, r10
    5958:	bb 1c       	adc	r11, r11
    595a:	aa 0c       	add	r10, r10
    595c:	bb 1c       	adc	r11, r11
    595e:	a2 0c       	add	r10, r2
    5960:	b3 1c       	adc	r11, r3
    5962:	ee e9       	ldi	r30, 0x9E	; 158
    5964:	ff e2       	ldi	r31, 0x2F	; 47
    5966:	ae 0e       	add	r10, r30
    5968:	bf 1e       	adc	r11, r31
    596a:	f5 01       	movw	r30, r10
    596c:	25 91       	lpm	r18, Z+
    596e:	34 91       	lpm	r19, Z+
	}
	if (MB_Frame[MB_N][0]!=0 && MB_Frame[MB_N][0]!=MB_NativeAddr[MB_N]) {
		MB_State[MB_N] = MB_Idle;
		return;
	}
	USART_Func(MB_N, LED);
    5970:	f9 01       	movw	r30, r18
    5972:	19 95       	eicall
	MB_CPT[MB_N][3]++;
    5974:	68 84       	ldd	r6, Y+8	; 0x08
    5976:	79 84       	ldd	r7, Y+9	; 0x09
    5978:	62 94       	swap	r6
    597a:	72 94       	swap	r7
    597c:	b0 ef       	ldi	r27, 0xF0	; 240
    597e:	7b 22       	and	r7, r27
    5980:	76 24       	eor	r7, r6
    5982:	6b 22       	and	r6, r27
    5984:	76 24       	eor	r7, r6
    5986:	f3 01       	movw	r30, r6
    5988:	eb 5c       	subi	r30, 0xCB	; 203
    598a:	f6 4f       	sbci	r31, 0xF6	; 246
    598c:	86 81       	ldd	r24, Z+6	; 0x06
    598e:	97 81       	ldd	r25, Z+7	; 0x07
    5990:	01 96       	adiw	r24, 0x01	; 1
    5992:	97 83       	std	Z+7, r25	; 0x07
    5994:	86 83       	std	Z+6, r24	; 0x06

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
MB_FrameReg(uint8_t MB_N, uint8_t i)
{
	return MB_Frame[MB_N][i]<<8 | MB_Frame[MB_N][i+1];
    5996:	68 85       	ldd	r22, Y+8	; 0x08
    5998:	79 85       	ldd	r23, Y+9	; 0x09
    599a:	76 95       	lsr	r23
    599c:	76 2f       	mov	r23, r22
    599e:	66 27       	eor	r22, r22
    59a0:	77 95       	ror	r23
    59a2:	67 95       	ror	r22
    59a4:	db 01       	movw	r26, r22
    59a6:	aa 0f       	add	r26, r26
    59a8:	bb 1f       	adc	r27, r27
    59aa:	a4 59       	subi	r26, 0x94	; 148
    59ac:	b4 4f       	sbci	r27, 0xF4	; 244
    59ae:	9c 91       	ld	r25, X
    59b0:	80 e0       	ldi	r24, 0x00	; 0
    59b2:	a7 01       	movw	r20, r14
    59b4:	46 59       	subi	r20, 0x96	; 150
    59b6:	54 4f       	sbci	r21, 0xF4	; 244
    59b8:	fa 01       	movw	r30, r20
    59ba:	23 81       	ldd	r18, Z+3	; 0x03
    59bc:	82 2e       	mov	r8, r18
    59be:	99 24       	eor	r9, r9
    59c0:	88 2a       	or	r8, r24
    59c2:	99 2a       	or	r9, r25
inline static uint8_t
Process(uint8_t MB_N)
{
	uint8_t Err;
	uint16_t StartAddr = MB_FrameReg(MB_N, 2);
	switch (MB_Frame[MB_N][1]) {
    59c4:	31 81       	ldd	r19, Z+1	; 0x01
    59c6:	35 30       	cpi	r19, 0x05	; 5
    59c8:	08 f0       	brcs	.+2      	; 0x59cc <MB_S_Timer_ISR+0x146>
    59ca:	52 c0       	rjmp	.+164    	; 0x5a70 <MB_S_Timer_ISR+0x1ea>
    59cc:	33 30       	cpi	r19, 0x03	; 3
    59ce:	08 f4       	brcc	.+2      	; 0x59d2 <MB_S_Timer_ISR+0x14c>
    59d0:	72 c0       	rjmp	.+228    	; 0x5ab6 <MB_S_Timer_ISR+0x230>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_ReadReg(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame[MB_N][0]==0)
    59d2:	fa 01       	movw	r30, r20
    59d4:	80 81       	ld	r24, Z
    59d6:	88 23       	and	r24, r24
    59d8:	09 f4       	brne	.+2      	; 0x59dc <MB_S_Timer_ISR+0x156>
    59da:	5c c0       	rjmp	.+184    	; 0x5a94 <MB_S_Timer_ISR+0x20e>
		return 0xFF;
	if (MB_Frame_Sz[MB_N]!=8)
    59dc:	29 e4       	ldi	r18, 0x49	; 73
    59de:	42 2e       	mov	r4, r18
    59e0:	27 e0       	ldi	r18, 0x07	; 7
    59e2:	52 2e       	mov	r5, r18
    59e4:	88 85       	ldd	r24, Y+8	; 0x08
    59e6:	99 85       	ldd	r25, Y+9	; 0x09
    59e8:	48 0e       	add	r4, r24
    59ea:	59 1e       	adc	r5, r25
    59ec:	f2 01       	movw	r30, r4
    59ee:	80 81       	ld	r24, Z
    59f0:	88 30       	cpi	r24, 0x08	; 8
    59f2:	09 f4       	brne	.+2      	; 0x59f6 <MB_S_Timer_ISR+0x170>
    59f4:	27 c2       	rjmp	.+1102   	; 0x5e44 <MB_S_Timer_ISR+0x5be>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_PresetSingle(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame_Sz[MB_N]!=8)
		return MB_Frame[MB_N][2]=IllegData;
    59f6:	83 e0       	ldi	r24, 0x03	; 3
    59f8:	8c 93       	st	X, r24
    59fa:	93 e0       	ldi	r25, 0x03	; 3
		break;
	default:
		Err = MB_Frame[MB_N][2] = IllegFunc;
		break;
	}
	if (MB_Frame[MB_N][0]) {
    59fc:	f7 01       	movw	r30, r14
    59fe:	e6 59       	subi	r30, 0x96	; 150
    5a00:	f4 4f       	sbci	r31, 0xF4	; 244
    5a02:	80 81       	ld	r24, Z
    5a04:	88 23       	and	r24, r24
    5a06:	81 f0       	breq	.+32     	; 0x5a28 <MB_S_Timer_ISR+0x1a2>
		if (Err) {
    5a08:	99 23       	and	r25, r25
    5a0a:	49 f0       	breq	.+18     	; 0x5a1e <MB_S_Timer_ISR+0x198>
			MB_Frame[MB_N][1] |=(1<<7);
    5a0c:	81 81       	ldd	r24, Z+1	; 0x01
    5a0e:	80 68       	ori	r24, 0x80	; 128
    5a10:	81 83       	std	Z+1, r24	; 0x01
			MB_Frame_Sz[MB_N] = 5;
    5a12:	e8 85       	ldd	r30, Y+8	; 0x08
    5a14:	f9 85       	ldd	r31, Y+9	; 0x09
    5a16:	e7 5b       	subi	r30, 0xB7	; 183
    5a18:	f8 4f       	sbci	r31, 0xF8	; 248
    5a1a:	85 e0       	ldi	r24, 0x05	; 5
    5a1c:	80 83       	st	Z, r24
		}
		SetCRC_MB(MB_N);
    5a1e:	8d 2d       	mov	r24, r13
    5a20:	9d 83       	std	Y+5, r25	; 0x05
    5a22:	0e 94 ea 2b 	call	0x57d4	; 0x57d4 <SetCRC_MB>
    5a26:	9d 81       	ldd	r25, Y+5	; 0x05
		MB_State[MB_N] = MB_Idle;
		return;
	}
	USART_Func(MB_N, LED);
	MB_CPT[MB_N][3]++;
	if (Process(MB_N))
    5a28:	99 23       	and	r25, r25
    5a2a:	a1 f5       	brne	.+104    	; 0x5a94 <MB_S_Timer_ISR+0x20e>
		MB_CPT[MB_N][2]++;
	if (MB_Frame[MB_N][0])
    5a2c:	2a e6       	ldi	r18, 0x6A	; 106
    5a2e:	3b e0       	ldi	r19, 0x0B	; 11
    5a30:	e2 0e       	add	r14, r18
    5a32:	f3 1e       	adc	r15, r19
    5a34:	d7 01       	movw	r26, r14
    5a36:	8c 91       	ld	r24, X
    5a38:	88 23       	and	r24, r24
    5a3a:	c9 f5       	brne	.+114    	; 0x5aae <MB_S_Timer_ISR+0x228>
		MB_Transm(MB_N);
	else {
		MB_CPT[MB_N][4]++;
    5a3c:	e8 85       	ldd	r30, Y+8	; 0x08
    5a3e:	f9 85       	ldd	r31, Y+9	; 0x09
    5a40:	ee 0f       	add	r30, r30
    5a42:	ff 1f       	adc	r31, r31
    5a44:	ee 0f       	add	r30, r30
    5a46:	ff 1f       	adc	r31, r31
    5a48:	ee 0f       	add	r30, r30
    5a4a:	ff 1f       	adc	r31, r31
    5a4c:	ee 0f       	add	r30, r30
    5a4e:	ff 1f       	adc	r31, r31
    5a50:	e3 5c       	subi	r30, 0xC3	; 195
    5a52:	f6 4f       	sbci	r31, 0xF6	; 246
    5a54:	80 81       	ld	r24, Z
    5a56:	91 81       	ldd	r25, Z+1	; 0x01
    5a58:	01 96       	adiw	r24, 0x01	; 1
    5a5a:	91 83       	std	Z+1, r25	; 0x01
    5a5c:	80 83       	st	Z, r24
		MB_State[MB_N] = MB_Idle;
    5a5e:	81 e0       	ldi	r24, 0x01	; 1
    5a60:	f8 01       	movw	r30, r16
    5a62:	80 83       	st	Z, r24
    5a64:	f5 01       	movw	r30, r10
    5a66:	85 91       	lpm	r24, Z+
    5a68:	94 91       	lpm	r25, Z+
		USART_Func(MB_N, LED);
    5a6a:	fc 01       	movw	r30, r24
    5a6c:	19 95       	eicall
    5a6e:	33 cf       	rjmp	.-410    	; 0x58d6 <MB_S_Timer_ISR+0x50>
inline static uint8_t
Process(uint8_t MB_N)
{
	uint8_t Err;
	uint16_t StartAddr = MB_FrameReg(MB_N, 2);
	switch (MB_Frame[MB_N][1]) {
    5a70:	3f 30       	cpi	r19, 0x0F	; 15
    5a72:	09 f4       	brne	.+2      	; 0x5a76 <MB_S_Timer_ISR+0x1f0>
    5a74:	1e c1       	rjmp	.+572    	; 0x5cb2 <MB_S_Timer_ISR+0x42c>
    5a76:	30 31       	cpi	r19, 0x10	; 16
    5a78:	09 f4       	brne	.+2      	; 0x5a7c <MB_S_Timer_ISR+0x1f6>
    5a7a:	fc c0       	rjmp	.+504    	; 0x5c74 <MB_S_Timer_ISR+0x3ee>
    5a7c:	36 30       	cpi	r19, 0x06	; 6
    5a7e:	09 f4       	brne	.+2      	; 0x5a82 <MB_S_Timer_ISR+0x1fc>
    5a80:	bd c0       	rjmp	.+378    	; 0x5bfc <MB_S_Timer_ISR+0x376>
		break;
	case 0x10:
		Err = MB_S_Preset(MB_N, StartAddr);
		break;
	default:
		Err = MB_Frame[MB_N][2] = IllegFunc;
    5a82:	66 0f       	add	r22, r22
    5a84:	77 1f       	adc	r23, r23
    5a86:	64 59       	subi	r22, 0x94	; 148
    5a88:	74 4f       	sbci	r23, 0xF4	; 244
    5a8a:	81 e0       	ldi	r24, 0x01	; 1
    5a8c:	fb 01       	movw	r30, r22
    5a8e:	80 83       	st	Z, r24
    5a90:	91 e0       	ldi	r25, 0x01	; 1
    5a92:	b4 cf       	rjmp	.-152    	; 0x59fc <MB_S_Timer_ISR+0x176>
		return;
	}
	USART_Func(MB_N, LED);
	MB_CPT[MB_N][3]++;
	if (Process(MB_N))
		MB_CPT[MB_N][2]++;
    5a94:	f1 01       	movw	r30, r2
    5a96:	ee 0f       	add	r30, r30
    5a98:	ff 1f       	adc	r31, r31
    5a9a:	ee 0f       	add	r30, r30
    5a9c:	ff 1f       	adc	r31, r31
    5a9e:	e7 5c       	subi	r30, 0xC7	; 199
    5aa0:	f6 4f       	sbci	r31, 0xF6	; 246
    5aa2:	80 81       	ld	r24, Z
    5aa4:	91 81       	ldd	r25, Z+1	; 0x01
    5aa6:	01 96       	adiw	r24, 0x01	; 1
    5aa8:	91 83       	std	Z+1, r25	; 0x01
    5aaa:	80 83       	st	Z, r24
    5aac:	bf cf       	rjmp	.-130    	; 0x5a2c <MB_S_Timer_ISR+0x1a6>
	if (MB_Frame[MB_N][0])
		MB_Transm(MB_N);
    5aae:	8d 2d       	mov	r24, r13
    5ab0:	0e 94 8b 2a 	call	0x5516	; 0x5516 <MB_Transm>
    5ab4:	10 cf       	rjmp	.-480    	; 0x58d6 <MB_S_Timer_ISR+0x50>
inline static uint8_t
Process(uint8_t MB_N)
{
	uint8_t Err;
	uint16_t StartAddr = MB_FrameReg(MB_N, 2);
	switch (MB_Frame[MB_N][1]) {
    5ab6:	31 30       	cpi	r19, 0x01	; 1
    5ab8:	20 f3       	brcs	.-56     	; 0x5a82 <MB_S_Timer_ISR+0x1fc>
*/
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_ReadDiscr(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame[MB_N][0]==0)
    5aba:	fa 01       	movw	r30, r20
    5abc:	80 81       	ld	r24, Z
    5abe:	88 23       	and	r24, r24
    5ac0:	49 f3       	breq	.-46     	; 0x5a94 <MB_S_Timer_ISR+0x20e>
		return 0xFF;
	if (MB_Frame_Sz[MB_N]!=8)
    5ac2:	e9 e4       	ldi	r30, 0x49	; 73
    5ac4:	4e 2e       	mov	r4, r30
    5ac6:	e7 e0       	ldi	r30, 0x07	; 7
    5ac8:	5e 2e       	mov	r5, r30
    5aca:	88 85       	ldd	r24, Y+8	; 0x08
    5acc:	99 85       	ldd	r25, Y+9	; 0x09
    5ace:	48 0e       	add	r4, r24
    5ad0:	59 1e       	adc	r5, r25
    5ad2:	f2 01       	movw	r30, r4
    5ad4:	80 81       	ld	r24, Z
    5ad6:	88 30       	cpi	r24, 0x08	; 8
    5ad8:	09 f0       	breq	.+2      	; 0x5adc <MB_S_Timer_ISR+0x256>
    5ada:	8d cf       	rjmp	.-230    	; 0x59f6 <MB_S_Timer_ISR+0x170>
    5adc:	88 85       	ldd	r24, Y+8	; 0x08
    5ade:	99 85       	ldd	r25, Y+9	; 0x09
    5ae0:	f8 2f       	mov	r31, r24
    5ae2:	ee 27       	eor	r30, r30
    5ae4:	e2 59       	subi	r30, 0x92	; 146
    5ae6:	f4 4f       	sbci	r31, 0xF4	; 244
    5ae8:	90 81       	ld	r25, Z
    5aea:	80 e0       	ldi	r24, 0x00	; 0
    5aec:	da 01       	movw	r26, r20
    5aee:	15 96       	adiw	r26, 0x05	; 5
    5af0:	2c 91       	ld	r18, X
    5af2:	a2 2f       	mov	r26, r18
    5af4:	b0 e0       	ldi	r27, 0x00	; 0
    5af6:	a8 2b       	or	r26, r24
    5af8:	b9 2b       	or	r27, r25
		return MB_Frame[MB_N][2]=IllegData;
	uint16_t Qt = MB_FrameReg(MB_N, 4);
	if (StartAddr+Qt>(MB_Frame[MB_N][1]==1?prw(&Modbus_Map[MB_N].Coil_Qt):prw(&Modbus_Map[MB_N].Input_Qt)))
    5afa:	31 30       	cpi	r19, 0x01	; 1
    5afc:	09 f4       	brne	.+2      	; 0x5b00 <MB_S_Timer_ISR+0x27a>
    5afe:	44 c2       	rjmp	.+1160   	; 0x5f88 <MB_S_Timer_ISR+0x702>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    5b00:	f3 01       	movw	r30, r6
    5b02:	ea 5c       	subi	r30, 0xCA	; 202
    5b04:	fc 4f       	sbci	r31, 0xFC	; 252
    5b06:	45 91       	lpm	r20, Z+
    5b08:	54 91       	lpm	r21, Z+
    5b0a:	cd 01       	movw	r24, r26
    5b0c:	88 0d       	add	r24, r8
    5b0e:	99 1d       	adc	r25, r9
    5b10:	48 17       	cp	r20, r24
    5b12:	59 07       	cpc	r21, r25
    5b14:	08 f4       	brcc	.+2      	; 0x5b18 <MB_S_Timer_ISR+0x292>
    5b16:	8d c1       	rjmp	.+794    	; 0x5e32 <MB_S_Timer_ISR+0x5ac>
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
    5b18:	31 30       	cpi	r19, 0x01	; 1
    5b1a:	09 f4       	brne	.+2      	; 0x5b1e <MB_S_Timer_ISR+0x298>
    5b1c:	4a c2       	rjmp	.+1172   	; 0x5fb2 <MB_S_Timer_ISR+0x72c>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5b1e:	f1 01       	movw	r30, r2
    5b20:	ee 0f       	add	r30, r30
    5b22:	ff 1f       	adc	r31, r31
    5b24:	ee 0f       	add	r30, r30
    5b26:	ff 1f       	adc	r31, r31
    5b28:	ec 5c       	subi	r30, 0xCC	; 204
    5b2a:	fc 4f       	sbci	r31, 0xFC	; 252
    5b2c:	85 91       	lpm	r24, Z+
    5b2e:	94 91       	lpm	r25, Z+
    5b30:	28 2f       	mov	r18, r24
    5b32:	89 2f       	mov	r24, r25
    5b34:	62 2e       	mov	r6, r18
    5b36:	78 2e       	mov	r7, r24
	MB_Frame[MB_N][2] = Qt/8+(Qt%8>0);
    5b38:	20 e0       	ldi	r18, 0x00	; 0
    5b3a:	cd 01       	movw	r24, r26
    5b3c:	87 70       	andi	r24, 0x07	; 7
    5b3e:	90 70       	andi	r25, 0x00	; 0
    5b40:	89 2b       	or	r24, r25
    5b42:	09 f0       	breq	.+2      	; 0x5b46 <MB_S_Timer_ISR+0x2c0>
    5b44:	21 e0       	ldi	r18, 0x01	; 1
    5b46:	cd 01       	movw	r24, r26
    5b48:	96 95       	lsr	r25
    5b4a:	87 95       	ror	r24
    5b4c:	96 95       	lsr	r25
    5b4e:	87 95       	ror	r24
    5b50:	96 95       	lsr	r25
    5b52:	87 95       	ror	r24
    5b54:	82 0f       	add	r24, r18
    5b56:	66 0f       	add	r22, r22
    5b58:	77 1f       	adc	r23, r23
    5b5a:	64 59       	subi	r22, 0x94	; 148
    5b5c:	74 4f       	sbci	r23, 0xF4	; 244
    5b5e:	fb 01       	movw	r30, r22
    5b60:	80 83       	st	Z, r24
	MB_Frame_Sz[MB_N] = MB_Frame[MB_N][2]+5;
    5b62:	8b 5f       	subi	r24, 0xFB	; 251
    5b64:	f2 01       	movw	r30, r4
    5b66:	80 83       	st	Z, r24
	for (uint8_t i=0; i<Qt; i++) {
    5b68:	10 97       	sbiw	r26, 0x00	; 0
    5b6a:	09 f4       	brne	.+2      	; 0x5b6e <MB_S_Timer_ISR+0x2e8>
    5b6c:	22 c1       	rjmp	.+580    	; 0x5db2 <MB_S_Timer_ISR+0x52c>
    5b6e:	60 e0       	ldi	r22, 0x00	; 0
    5b70:	20 e0       	ldi	r18, 0x00	; 0
    5b72:	30 e0       	ldi	r19, 0x00	; 0
    5b74:	80 e0       	ldi	r24, 0x00	; 0
    5b76:	90 e0       	ldi	r25, 0x00	; 0
		uint16_t j = StartAddr+i;
		uint8_t Byte=3+i/8, Bit=1<<i%8;
    5b78:	e1 e0       	ldi	r30, 0x01	; 1
    5b7a:	4e 2e       	mov	r4, r30
    5b7c:	51 2c       	mov	r5, r1
    5b7e:	10 c0       	rjmp	.+32     	; 0x5ba0 <MB_S_Timer_ISR+0x31a>
		if (Discr[j/8] &(1<<j%8))
			MB_Frame[MB_N][Byte] |=Bit;
    5b80:	f7 01       	movw	r30, r14
    5b82:	e4 0f       	add	r30, r20
    5b84:	f1 1d       	adc	r31, r1
    5b86:	e6 59       	subi	r30, 0x96	; 150
    5b88:	f4 4f       	sbci	r31, 0xF4	; 244
    5b8a:	80 81       	ld	r24, Z
    5b8c:	85 2b       	or	r24, r21
    5b8e:	80 83       	st	Z, r24
	if (StartAddr+Qt>(MB_Frame[MB_N][1]==1?prw(&Modbus_Map[MB_N].Coil_Qt):prw(&Modbus_Map[MB_N].Input_Qt)))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
	MB_Frame[MB_N][2] = Qt/8+(Qt%8>0);
	MB_Frame_Sz[MB_N] = MB_Frame[MB_N][2]+5;
	for (uint8_t i=0; i<Qt; i++) {
    5b90:	6f 5f       	subi	r22, 0xFF	; 255
    5b92:	86 2f       	mov	r24, r22
    5b94:	90 e0       	ldi	r25, 0x00	; 0
    5b96:	9c 01       	movw	r18, r24
    5b98:	8a 17       	cp	r24, r26
    5b9a:	9b 07       	cpc	r25, r27
    5b9c:	08 f0       	brcs	.+2      	; 0x5ba0 <MB_S_Timer_ISR+0x31a>
    5b9e:	09 c1       	rjmp	.+530    	; 0x5db2 <MB_S_Timer_ISR+0x52c>
		uint16_t j = StartAddr+i;
    5ba0:	28 0d       	add	r18, r8
    5ba2:	39 1d       	adc	r19, r9
		uint8_t Byte=3+i/8, Bit=1<<i%8;
    5ba4:	46 2f       	mov	r20, r22
    5ba6:	46 95       	lsr	r20
    5ba8:	46 95       	lsr	r20
    5baa:	46 95       	lsr	r20
    5bac:	4d 5f       	subi	r20, 0xFD	; 253
    5bae:	87 70       	andi	r24, 0x07	; 7
    5bb0:	90 70       	andi	r25, 0x00	; 0
    5bb2:	f2 01       	movw	r30, r4
    5bb4:	02 c0       	rjmp	.+4      	; 0x5bba <MB_S_Timer_ISR+0x334>
    5bb6:	ee 0f       	add	r30, r30
    5bb8:	ff 1f       	adc	r31, r31
    5bba:	8a 95       	dec	r24
    5bbc:	e2 f7       	brpl	.-8      	; 0x5bb6 <MB_S_Timer_ISR+0x330>
    5bbe:	5e 2f       	mov	r21, r30
		if (Discr[j/8] &(1<<j%8))
    5bc0:	f9 01       	movw	r30, r18
    5bc2:	f6 95       	lsr	r31
    5bc4:	e7 95       	ror	r30
    5bc6:	f6 95       	lsr	r31
    5bc8:	e7 95       	ror	r30
    5bca:	f6 95       	lsr	r31
    5bcc:	e7 95       	ror	r30
    5bce:	e6 0d       	add	r30, r6
    5bd0:	f7 1d       	adc	r31, r7
    5bd2:	80 81       	ld	r24, Z
    5bd4:	90 e0       	ldi	r25, 0x00	; 0
    5bd6:	27 70       	andi	r18, 0x07	; 7
    5bd8:	30 70       	andi	r19, 0x00	; 0
    5bda:	02 c0       	rjmp	.+4      	; 0x5be0 <MB_S_Timer_ISR+0x35a>
    5bdc:	95 95       	asr	r25
    5bde:	87 95       	ror	r24
    5be0:	2a 95       	dec	r18
    5be2:	e2 f7       	brpl	.-8      	; 0x5bdc <MB_S_Timer_ISR+0x356>
    5be4:	80 fd       	sbrc	r24, 0
    5be6:	cc cf       	rjmp	.-104    	; 0x5b80 <MB_S_Timer_ISR+0x2fa>
			MB_Frame[MB_N][Byte] |=Bit;
		else
			MB_Frame[MB_N][Byte] &=~Bit;
    5be8:	f7 01       	movw	r30, r14
    5bea:	e4 0f       	add	r30, r20
    5bec:	f1 1d       	adc	r31, r1
    5bee:	e6 59       	subi	r30, 0x96	; 150
    5bf0:	f4 4f       	sbci	r31, 0xF4	; 244
    5bf2:	50 95       	com	r21
    5bf4:	80 81       	ld	r24, Z
    5bf6:	58 23       	and	r21, r24
    5bf8:	50 83       	st	Z, r21
    5bfa:	ca cf       	rjmp	.-108    	; 0x5b90 <MB_S_Timer_ISR+0x30a>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_PresetSingle(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame_Sz[MB_N]!=8)
    5bfc:	68 85       	ldd	r22, Y+8	; 0x08
    5bfe:	79 85       	ldd	r23, Y+9	; 0x09
    5c00:	67 5b       	subi	r22, 0xB7	; 183
    5c02:	78 4f       	sbci	r23, 0xF8	; 248
    5c04:	fb 01       	movw	r30, r22
    5c06:	c0 80       	ld	r12, Z
    5c08:	f8 e0       	ldi	r31, 0x08	; 8
    5c0a:	cf 16       	cp	r12, r31
    5c0c:	09 f0       	breq	.+2      	; 0x5c10 <MB_S_Timer_ISR+0x38a>
    5c0e:	f3 ce       	rjmp	.-538    	; 0x59f6 <MB_S_Timer_ISR+0x170>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    5c10:	f3 01       	movw	r30, r6
    5c12:	e6 5c       	subi	r30, 0xC6	; 198
    5c14:	fc 4f       	sbci	r31, 0xFC	; 252
    5c16:	25 91       	lpm	r18, Z+
    5c18:	34 91       	lpm	r19, Z+
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+1>prw(&Modbus_Map[MB_N].HoldReg_Qt))
    5c1a:	c4 01       	movw	r24, r8
    5c1c:	01 96       	adiw	r24, 0x01	; 1
    5c1e:	28 17       	cp	r18, r24
    5c20:	39 07       	cpc	r19, r25
    5c22:	08 f4       	brcc	.+2      	; 0x5c26 <MB_S_Timer_ISR+0x3a0>
    5c24:	02 c1       	rjmp	.+516    	; 0x5e2a <MB_S_Timer_ISR+0x5a4>
		return MB_Frame[MB_N][2]=IllegAddr;
	MB_Frame_Sz[MB_N] = 8;
    5c26:	db 01       	movw	r26, r22
    5c28:	cc 92       	st	X, r12

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5c2a:	e8 85       	ldd	r30, Y+8	; 0x08
    5c2c:	f9 85       	ldd	r31, Y+9	; 0x09
    5c2e:	ee 0f       	add	r30, r30
    5c30:	ff 1f       	adc	r31, r31
    5c32:	ee 0f       	add	r30, r30
    5c34:	ff 1f       	adc	r31, r31
    5c36:	ee 0f       	add	r30, r30
    5c38:	ff 1f       	adc	r31, r31
    5c3a:	ee 0f       	add	r30, r30
    5c3c:	ff 1f       	adc	r31, r31
    5c3e:	e8 5c       	subi	r30, 0xC8	; 200
    5c40:	fc 4f       	sbci	r31, 0xFC	; 252
    5c42:	85 91       	lpm	r24, Z+
    5c44:	94 91       	lpm	r25, Z+
	*((uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+StartAddr) = MB_FrameReg(MB_N, 4);
    5c46:	88 0c       	add	r8, r8
    5c48:	99 1c       	adc	r9, r9
    5c4a:	88 0e       	add	r8, r24
    5c4c:	99 1e       	adc	r9, r25
    5c4e:	28 85       	ldd	r18, Y+8	; 0x08
    5c50:	39 85       	ldd	r19, Y+9	; 0x09
    5c52:	f2 2f       	mov	r31, r18
    5c54:	ee 27       	eor	r30, r30
    5c56:	e2 59       	subi	r30, 0x92	; 146
    5c58:	f4 4f       	sbci	r31, 0xF4	; 244
    5c5a:	90 81       	ld	r25, Z
    5c5c:	80 e0       	ldi	r24, 0x00	; 0
    5c5e:	da 01       	movw	r26, r20
    5c60:	15 96       	adiw	r26, 0x05	; 5
    5c62:	2c 91       	ld	r18, X
    5c64:	30 e0       	ldi	r19, 0x00	; 0
    5c66:	82 2b       	or	r24, r18
    5c68:	93 2b       	or	r25, r19
    5c6a:	f4 01       	movw	r30, r8
    5c6c:	91 83       	std	Z+1, r25	; 0x01
    5c6e:	80 83       	st	Z, r24
    5c70:	90 e0       	ldi	r25, 0x00	; 0
    5c72:	c4 ce       	rjmp	.-632    	; 0x59fc <MB_S_Timer_ISR+0x176>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_Preset(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][6]+9 || MB_Frame[MB_N][5]*2!=MB_Frame[MB_N][6])
    5c74:	fa 01       	movw	r30, r20
    5c76:	86 81       	ldd	r24, Z+6	; 0x06
    5c78:	28 2f       	mov	r18, r24
    5c7a:	30 e0       	ldi	r19, 0x00	; 0
    5c7c:	3f 83       	std	Y+7, r19	; 0x07
    5c7e:	2e 83       	std	Y+6, r18	; 0x06
    5c80:	89 e4       	ldi	r24, 0x49	; 73
    5c82:	48 2e       	mov	r4, r24
    5c84:	87 e0       	ldi	r24, 0x07	; 7
    5c86:	58 2e       	mov	r5, r24
    5c88:	88 85       	ldd	r24, Y+8	; 0x08
    5c8a:	99 85       	ldd	r25, Y+9	; 0x09
    5c8c:	48 0e       	add	r4, r24
    5c8e:	59 1e       	adc	r5, r25
    5c90:	f2 01       	movw	r30, r4
    5c92:	80 81       	ld	r24, Z
    5c94:	90 e0       	ldi	r25, 0x00	; 0
    5c96:	27 5f       	subi	r18, 0xF7	; 247
    5c98:	3f 4f       	sbci	r19, 0xFF	; 255
    5c9a:	82 17       	cp	r24, r18
    5c9c:	93 07       	cpc	r25, r19
    5c9e:	99 f1       	breq	.+102    	; 0x5d06 <MB_S_Timer_ISR+0x480>
		return MB_Frame[MB_N][2]=IllegData;
    5ca0:	66 0f       	add	r22, r22
    5ca2:	77 1f       	adc	r23, r23
    5ca4:	64 59       	subi	r22, 0x94	; 148
    5ca6:	74 4f       	sbci	r23, 0xF4	; 244
    5ca8:	83 e0       	ldi	r24, 0x03	; 3
    5caa:	db 01       	movw	r26, r22
    5cac:	8c 93       	st	X, r24
    5cae:	93 e0       	ldi	r25, 0x03	; 3
    5cb0:	a5 ce       	rjmp	.-694    	; 0x59fc <MB_S_Timer_ISR+0x176>
    5cb2:	28 85       	ldd	r18, Y+8	; 0x08
    5cb4:	39 85       	ldd	r19, Y+9	; 0x09
    5cb6:	f2 2f       	mov	r31, r18
    5cb8:	ee 27       	eor	r30, r30
    5cba:	e2 59       	subi	r30, 0x92	; 146
    5cbc:	f4 4f       	sbci	r31, 0xF4	; 244
    5cbe:	e0 81       	ld	r30, Z
    5cc0:	da 01       	movw	r26, r20
    5cc2:	15 96       	adiw	r26, 0x05	; 5
    5cc4:	fc 91       	ld	r31, X
    5cc6:	15 97       	sbiw	r26, 0x05	; 5
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_Force(uint8_t MB_N, uint16_t StartAddr)
{
	uint16_t Qt = MB_FrameReg(MB_N, 4);
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][6]+9 || Qt/8+(Qt%8>0)!=MB_Frame[MB_N][6])
    5cc8:	16 96       	adiw	r26, 0x06	; 6
    5cca:	2c 91       	ld	r18, X
    5ccc:	a9 e4       	ldi	r26, 0x49	; 73
    5cce:	4a 2e       	mov	r4, r26
    5cd0:	a7 e0       	ldi	r26, 0x07	; 7
    5cd2:	5a 2e       	mov	r5, r26
    5cd4:	88 85       	ldd	r24, Y+8	; 0x08
    5cd6:	99 85       	ldd	r25, Y+9	; 0x09
    5cd8:	48 0e       	add	r4, r24
    5cda:	59 1e       	adc	r5, r25
    5cdc:	d2 01       	movw	r26, r4
    5cde:	8c 91       	ld	r24, X
    5ce0:	90 e0       	ldi	r25, 0x00	; 0
    5ce2:	42 2f       	mov	r20, r18
    5ce4:	50 e0       	ldi	r21, 0x00	; 0
    5ce6:	9a 01       	movw	r18, r20
    5ce8:	27 5f       	subi	r18, 0xF7	; 247
    5cea:	3f 4f       	sbci	r19, 0xFF	; 255
    5cec:	82 17       	cp	r24, r18
    5cee:	93 07       	cpc	r25, r19
    5cf0:	09 f4       	brne	.+2      	; 0x5cf4 <MB_S_Timer_ISR+0x46e>
    5cf2:	61 c0       	rjmp	.+194    	; 0x5db6 <MB_S_Timer_ISR+0x530>
		return MB_Frame[MB_N][2]=IllegData;
    5cf4:	66 0f       	add	r22, r22
    5cf6:	77 1f       	adc	r23, r23
    5cf8:	64 59       	subi	r22, 0x94	; 148
    5cfa:	74 4f       	sbci	r23, 0xF4	; 244
    5cfc:	83 e0       	ldi	r24, 0x03	; 3
    5cfe:	fb 01       	movw	r30, r22
    5d00:	80 83       	st	Z, r24
    5d02:	93 e0       	ldi	r25, 0x03	; 3
    5d04:	7b ce       	rjmp	.-778    	; 0x59fc <MB_S_Timer_ISR+0x176>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_Preset(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][6]+9 || MB_Frame[MB_N][5]*2!=MB_Frame[MB_N][6])
    5d06:	9a 01       	movw	r18, r20
    5d08:	2b 5f       	subi	r18, 0xFB	; 251
    5d0a:	3f 4f       	sbci	r19, 0xFF	; 255
    5d0c:	3c 83       	std	Y+4, r19	; 0x04
    5d0e:	2b 83       	std	Y+3, r18	; 0x03
    5d10:	fa 01       	movw	r30, r20
    5d12:	c5 80       	ldd	r12, Z+5	; 0x05
    5d14:	2c 2d       	mov	r18, r12
    5d16:	30 e0       	ldi	r19, 0x00	; 0
    5d18:	c9 01       	movw	r24, r18
    5d1a:	88 0f       	add	r24, r24
    5d1c:	99 1f       	adc	r25, r25
    5d1e:	ee 81       	ldd	r30, Y+6	; 0x06
    5d20:	ff 81       	ldd	r31, Y+7	; 0x07
    5d22:	e8 17       	cp	r30, r24
    5d24:	f9 07       	cpc	r31, r25
    5d26:	09 f0       	breq	.+2      	; 0x5d2a <MB_S_Timer_ISR+0x4a4>
    5d28:	bb cf       	rjmp	.-138    	; 0x5ca0 <MB_S_Timer_ISR+0x41a>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    5d2a:	f3 01       	movw	r30, r6
    5d2c:	e6 5c       	subi	r30, 0xC6	; 198
    5d2e:	fc 4f       	sbci	r31, 0xFC	; 252
    5d30:	85 91       	lpm	r24, Z+
    5d32:	94 91       	lpm	r25, Z+
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+MB_Frame[MB_N][5]>prw(&Modbus_Map[MB_N].HoldReg_Qt))
    5d34:	28 0d       	add	r18, r8
    5d36:	39 1d       	adc	r19, r9
    5d38:	82 17       	cp	r24, r18
    5d3a:	93 07       	cpc	r25, r19
    5d3c:	08 f4       	brcc	.+2      	; 0x5d40 <MB_S_Timer_ISR+0x4ba>
    5d3e:	75 c0       	rjmp	.+234    	; 0x5e2a <MB_S_Timer_ISR+0x5a4>
		return MB_Frame[MB_N][2]=IllegAddr;
	MB_Frame_Sz[MB_N] = 8;
    5d40:	88 e0       	ldi	r24, 0x08	; 8
    5d42:	f2 01       	movw	r30, r4
    5d44:	80 83       	st	Z, r24

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5d46:	e8 85       	ldd	r30, Y+8	; 0x08
    5d48:	f9 85       	ldd	r31, Y+9	; 0x09
    5d4a:	ee 0f       	add	r30, r30
    5d4c:	ff 1f       	adc	r31, r31
    5d4e:	ee 0f       	add	r30, r30
    5d50:	ff 1f       	adc	r31, r31
    5d52:	ee 0f       	add	r30, r30
    5d54:	ff 1f       	adc	r31, r31
    5d56:	ee 0f       	add	r30, r30
    5d58:	ff 1f       	adc	r31, r31
    5d5a:	e8 5c       	subi	r30, 0xC8	; 200
    5d5c:	fc 4f       	sbci	r31, 0xFC	; 252
    5d5e:	45 90       	lpm	r4, Z+
    5d60:	54 90       	lpm	r5, Z+
	uint16_t *HoldReg = prp(&Modbus_Map[MB_N].HoldReg);
	for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    5d62:	cc 20       	and	r12, r12
    5d64:	31 f1       	breq	.+76     	; 0x5db2 <MB_S_Timer_ISR+0x52c>
    5d66:	60 e0       	ldi	r22, 0x00	; 0
    5d68:	6b 80       	ldd	r6, Y+3	; 0x03
    5d6a:	7c 80       	ldd	r7, Y+4	; 0x04
    5d6c:	a6 2f       	mov	r26, r22
    5d6e:	b0 e0       	ldi	r27, 0x00	; 0
    5d70:	cd 01       	movw	r24, r26
    5d72:	88 0f       	add	r24, r24
    5d74:	99 1f       	adc	r25, r25
    5d76:	89 5f       	subi	r24, 0xF9	; 249
    5d78:	28 2f       	mov	r18, r24
    5d7a:	30 e0       	ldi	r19, 0x00	; 0
		uint8_t j = i*2;
		HoldReg[StartAddr+i] = MB_FrameReg(MB_N, 7+j);
    5d7c:	a8 0d       	add	r26, r8
    5d7e:	b9 1d       	adc	r27, r9
    5d80:	aa 0f       	add	r26, r26
    5d82:	bb 1f       	adc	r27, r27
    5d84:	a4 0d       	add	r26, r4
    5d86:	b5 1d       	adc	r27, r5
    5d88:	fa 01       	movw	r30, r20
    5d8a:	e2 0f       	add	r30, r18
    5d8c:	f3 1f       	adc	r31, r19
    5d8e:	81 81       	ldd	r24, Z+1	; 0x01
    5d90:	90 e0       	ldi	r25, 0x00	; 0
    5d92:	2e 0d       	add	r18, r14
    5d94:	3f 1d       	adc	r19, r15
    5d96:	26 59       	subi	r18, 0x96	; 150
    5d98:	34 4f       	sbci	r19, 0xF4	; 244
    5d9a:	f9 01       	movw	r30, r18
    5d9c:	30 81       	ld	r19, Z
    5d9e:	20 e0       	ldi	r18, 0x00	; 0
    5da0:	82 2b       	or	r24, r18
    5da2:	93 2b       	or	r25, r19
    5da4:	8d 93       	st	X+, r24
    5da6:	9c 93       	st	X, r25
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+MB_Frame[MB_N][5]>prw(&Modbus_Map[MB_N].HoldReg_Qt))
		return MB_Frame[MB_N][2]=IllegAddr;
	MB_Frame_Sz[MB_N] = 8;
	uint16_t *HoldReg = prp(&Modbus_Map[MB_N].HoldReg);
	for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    5da8:	6f 5f       	subi	r22, 0xFF	; 255
    5daa:	d3 01       	movw	r26, r6
    5dac:	8c 91       	ld	r24, X
    5dae:	68 17       	cp	r22, r24
    5db0:	e8 f2       	brcs	.-70     	; 0x5d6c <MB_S_Timer_ISR+0x4e6>
		break;
	case 0x10:
		Err = MB_S_Preset(MB_N, StartAddr);
		break;
	default:
		Err = MB_Frame[MB_N][2] = IllegFunc;
    5db2:	90 e0       	ldi	r25, 0x00	; 0
    5db4:	23 ce       	rjmp	.-954    	; 0x59fc <MB_S_Timer_ISR+0x176>
    5db6:	9e 2f       	mov	r25, r30
    5db8:	80 e0       	ldi	r24, 0x00	; 0
    5dba:	af 2f       	mov	r26, r31
    5dbc:	b0 e0       	ldi	r27, 0x00	; 0
    5dbe:	a8 2b       	or	r26, r24
    5dc0:	b9 2b       	or	r27, r25
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_Force(uint8_t MB_N, uint16_t StartAddr)
{
	uint16_t Qt = MB_FrameReg(MB_N, 4);
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][6]+9 || Qt/8+(Qt%8>0)!=MB_Frame[MB_N][6])
    5dc2:	20 e0       	ldi	r18, 0x00	; 0
    5dc4:	30 e0       	ldi	r19, 0x00	; 0
    5dc6:	cd 01       	movw	r24, r26
    5dc8:	87 70       	andi	r24, 0x07	; 7
    5dca:	90 70       	andi	r25, 0x00	; 0
    5dcc:	89 2b       	or	r24, r25
    5dce:	11 f0       	breq	.+4      	; 0x5dd4 <MB_S_Timer_ISR+0x54e>
    5dd0:	21 e0       	ldi	r18, 0x01	; 1
    5dd2:	30 e0       	ldi	r19, 0x00	; 0
    5dd4:	cd 01       	movw	r24, r26
    5dd6:	96 95       	lsr	r25
    5dd8:	87 95       	ror	r24
    5dda:	96 95       	lsr	r25
    5ddc:	87 95       	ror	r24
    5dde:	96 95       	lsr	r25
    5de0:	87 95       	ror	r24
    5de2:	28 0f       	add	r18, r24
    5de4:	39 1f       	adc	r19, r25
    5de6:	24 17       	cp	r18, r20
    5de8:	35 07       	cpc	r19, r21
    5dea:	09 f0       	breq	.+2      	; 0x5dee <MB_S_Timer_ISR+0x568>
    5dec:	83 cf       	rjmp	.-250    	; 0x5cf4 <MB_S_Timer_ISR+0x46e>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    5dee:	e8 85       	ldd	r30, Y+8	; 0x08
    5df0:	f9 85       	ldd	r31, Y+9	; 0x09
    5df2:	ee 0f       	add	r30, r30
    5df4:	ff 1f       	adc	r31, r31
    5df6:	ee 0f       	add	r30, r30
    5df8:	ff 1f       	adc	r31, r31
    5dfa:	ee 0f       	add	r30, r30
    5dfc:	ff 1f       	adc	r31, r31
    5dfe:	ee 0f       	add	r30, r30
    5e00:	ff 1f       	adc	r31, r31
    5e02:	ee 5c       	subi	r30, 0xCE	; 206
    5e04:	fc 4f       	sbci	r31, 0xFC	; 252
    5e06:	25 91       	lpm	r18, Z+
    5e08:	34 91       	lpm	r19, Z+
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+Qt > prw(&Modbus_Map[MB_N].Coil_Qt))
    5e0a:	cd 01       	movw	r24, r26
    5e0c:	88 0d       	add	r24, r8
    5e0e:	99 1d       	adc	r25, r9
    5e10:	28 17       	cp	r18, r24
    5e12:	39 07       	cpc	r19, r25
    5e14:	08 f0       	brcs	.+2      	; 0x5e18 <MB_S_Timer_ISR+0x592>
    5e16:	5d c0       	rjmp	.+186    	; 0x5ed2 <MB_S_Timer_ISR+0x64c>
		return MB_Frame[MB_N][2]=IllegAddr;
    5e18:	66 0f       	add	r22, r22
    5e1a:	77 1f       	adc	r23, r23
    5e1c:	64 59       	subi	r22, 0x94	; 148
    5e1e:	74 4f       	sbci	r23, 0xF4	; 244
    5e20:	82 e0       	ldi	r24, 0x02	; 2
    5e22:	db 01       	movw	r26, r22
    5e24:	8c 93       	st	X, r24
    5e26:	92 e0       	ldi	r25, 0x02	; 2
    5e28:	e9 cd       	rjmp	.-1070   	; 0x59fc <MB_S_Timer_ISR+0x176>
MB_S_Preset(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][6]+9 || MB_Frame[MB_N][5]*2!=MB_Frame[MB_N][6])
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+MB_Frame[MB_N][5]>prw(&Modbus_Map[MB_N].HoldReg_Qt))
		return MB_Frame[MB_N][2]=IllegAddr;
    5e2a:	82 e0       	ldi	r24, 0x02	; 2
    5e2c:	8c 93       	st	X, r24
    5e2e:	92 e0       	ldi	r25, 0x02	; 2
    5e30:	e5 cd       	rjmp	.-1078   	; 0x59fc <MB_S_Timer_ISR+0x176>
	if (MB_Frame[MB_N][0]==0)
		return 0xFF;
	if (MB_Frame_Sz[MB_N]!=8)
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+MB_Frame[MB_N][5]>(MB_Frame[MB_N][1]==3?prw(&Modbus_Map[MB_N].HoldReg_Qt):prw(&Modbus_Map[MB_N].InReg_Qt)))
		return MB_Frame[MB_N][2]=IllegAddr;
    5e32:	66 0f       	add	r22, r22
    5e34:	77 1f       	adc	r23, r23
    5e36:	64 59       	subi	r22, 0x94	; 148
    5e38:	74 4f       	sbci	r23, 0xF4	; 244
    5e3a:	82 e0       	ldi	r24, 0x02	; 2
    5e3c:	fb 01       	movw	r30, r22
    5e3e:	80 83       	st	Z, r24
    5e40:	92 e0       	ldi	r25, 0x02	; 2
    5e42:	dc cd       	rjmp	.-1096   	; 0x59fc <MB_S_Timer_ISR+0x176>
{
	if (MB_Frame[MB_N][0]==0)
		return 0xFF;
	if (MB_Frame_Sz[MB_N]!=8)
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+MB_Frame[MB_N][5]>(MB_Frame[MB_N][1]==3?prw(&Modbus_Map[MB_N].HoldReg_Qt):prw(&Modbus_Map[MB_N].InReg_Qt)))
    5e44:	da 01       	movw	r26, r20
    5e46:	15 96       	adiw	r26, 0x05	; 5
    5e48:	8c 91       	ld	r24, X
    5e4a:	33 30       	cpi	r19, 0x03	; 3
    5e4c:	09 f4       	brne	.+2      	; 0x5e50 <MB_S_Timer_ISR+0x5ca>
    5e4e:	ab c0       	rjmp	.+342    	; 0x5fa6 <MB_S_Timer_ISR+0x720>
    5e50:	f3 01       	movw	r30, r6
    5e52:	e2 5c       	subi	r30, 0xC2	; 194
    5e54:	fc 4f       	sbci	r31, 0xFC	; 252
    5e56:	45 91       	lpm	r20, Z+
    5e58:	54 91       	lpm	r21, Z+
    5e5a:	a8 2f       	mov	r26, r24
    5e5c:	b0 e0       	ldi	r27, 0x00	; 0
    5e5e:	c4 01       	movw	r24, r8
    5e60:	8a 0f       	add	r24, r26
    5e62:	9b 1f       	adc	r25, r27
    5e64:	48 17       	cp	r20, r24
    5e66:	59 07       	cpc	r21, r25
    5e68:	20 f3       	brcs	.-56     	; 0x5e32 <MB_S_Timer_ISR+0x5ac>
		return MB_Frame[MB_N][2]=IllegAddr;
	uint16_t *Reg = (uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg)) + StartAddr;
    5e6a:	33 30       	cpi	r19, 0x03	; 3
    5e6c:	09 f4       	brne	.+2      	; 0x5e70 <MB_S_Timer_ISR+0x5ea>
    5e6e:	a9 c0       	rjmp	.+338    	; 0x5fc2 <MB_S_Timer_ISR+0x73c>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5e70:	f3 01       	movw	r30, r6
    5e72:	e4 5c       	subi	r30, 0xC4	; 196
    5e74:	fc 4f       	sbci	r31, 0xFC	; 252
    5e76:	85 91       	lpm	r24, Z+
    5e78:	94 91       	lpm	r25, Z+
    5e7a:	94 01       	movw	r18, r8
    5e7c:	22 0f       	add	r18, r18
    5e7e:	33 1f       	adc	r19, r19
    5e80:	28 0f       	add	r18, r24
    5e82:	39 1f       	adc	r19, r25
	MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][2] = MB_Frame[MB_N][5]*2) + 5;
    5e84:	cd 01       	movw	r24, r26
    5e86:	88 0f       	add	r24, r24
    5e88:	99 1f       	adc	r25, r25
    5e8a:	66 0f       	add	r22, r22
    5e8c:	77 1f       	adc	r23, r23
    5e8e:	64 59       	subi	r22, 0x94	; 148
    5e90:	74 4f       	sbci	r23, 0xF4	; 244
    5e92:	db 01       	movw	r26, r22
    5e94:	8c 93       	st	X, r24
    5e96:	8b 5f       	subi	r24, 0xFB	; 251
    5e98:	f2 01       	movw	r30, r4
    5e9a:	80 83       	st	Z, r24
	uint8_t Qt = MB_Frame[MB_N][5];
    5e9c:	f7 01       	movw	r30, r14
    5e9e:	e6 59       	subi	r30, 0x96	; 150
    5ea0:	f4 4f       	sbci	r31, 0xF4	; 244
    5ea2:	45 81       	ldd	r20, Z+5	; 0x05
	for (uint8_t i=0; i<Qt; i++) {
    5ea4:	44 23       	and	r20, r20
    5ea6:	09 f4       	brne	.+2      	; 0x5eaa <MB_S_Timer_ISR+0x624>
    5ea8:	84 cf       	rjmp	.-248    	; 0x5db2 <MB_S_Timer_ISR+0x52c>
    5eaa:	d9 01       	movw	r26, r18
    5eac:	90 e0       	ldi	r25, 0x00	; 0
		uint8_t j = i*2;
		MB_Frame[MB_N][3+j] = Reg[i]>>8;
    5eae:	9f 01       	movw	r18, r30
    5eb0:	89 2f       	mov	r24, r25
    5eb2:	88 0f       	add	r24, r24
    5eb4:	f9 01       	movw	r30, r18
    5eb6:	e8 0f       	add	r30, r24
    5eb8:	f1 1d       	adc	r31, r1
    5eba:	11 96       	adiw	r26, 0x01	; 1
    5ebc:	8c 91       	ld	r24, X
    5ebe:	11 97       	sbiw	r26, 0x01	; 1
    5ec0:	83 83       	std	Z+3, r24	; 0x03
		MB_Frame[MB_N][4+j] = Reg[i];
    5ec2:	8c 91       	ld	r24, X
    5ec4:	84 83       	std	Z+4, r24	; 0x04
	if (StartAddr+MB_Frame[MB_N][5]>(MB_Frame[MB_N][1]==3?prw(&Modbus_Map[MB_N].HoldReg_Qt):prw(&Modbus_Map[MB_N].InReg_Qt)))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint16_t *Reg = (uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg)) + StartAddr;
	MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][2] = MB_Frame[MB_N][5]*2) + 5;
	uint8_t Qt = MB_Frame[MB_N][5];
	for (uint8_t i=0; i<Qt; i++) {
    5ec6:	9f 5f       	subi	r25, 0xFF	; 255
    5ec8:	12 96       	adiw	r26, 0x02	; 2
    5eca:	94 17       	cp	r25, r20
    5ecc:	88 f3       	brcs	.-30     	; 0x5eb0 <MB_S_Timer_ISR+0x62a>
		break;
	case 0x10:
		Err = MB_S_Preset(MB_N, StartAddr);
		break;
	default:
		Err = MB_Frame[MB_N][2] = IllegFunc;
    5ece:	90 e0       	ldi	r25, 0x00	; 0
    5ed0:	95 cd       	rjmp	.-1238   	; 0x59fc <MB_S_Timer_ISR+0x176>
    5ed2:	93 01       	movw	r18, r6
    5ed4:	20 5d       	subi	r18, 0xD0	; 208
    5ed6:	3c 4f       	sbci	r19, 0xFC	; 252
    5ed8:	f9 01       	movw	r30, r18
    5eda:	85 91       	lpm	r24, Z+
    5edc:	94 91       	lpm	r25, Z+
    5ede:	9a 83       	std	Y+2, r25	; 0x02
    5ee0:	89 83       	std	Y+1, r24	; 0x01
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][6]+9 || Qt/8+(Qt%8>0)!=MB_Frame[MB_N][6])
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+Qt > prw(&Modbus_Map[MB_N].Coil_Qt))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Coil = prp(&Modbus_Map[MB_N].Coil);
	MB_Frame_Sz[MB_N] = 8;
    5ee2:	88 e0       	ldi	r24, 0x08	; 8
    5ee4:	f2 01       	movw	r30, r4
    5ee6:	80 83       	st	Z, r24
	for (uint8_t i=0; i<Qt; i++) {
    5ee8:	10 97       	sbiw	r26, 0x00	; 0
    5eea:	09 f4       	brne	.+2      	; 0x5eee <MB_S_Timer_ISR+0x668>
    5eec:	62 cf       	rjmp	.-316    	; 0x5db2 <MB_S_Timer_ISR+0x52c>
    5eee:	cc 24       	eor	r12, r12
    5ef0:	80 e0       	ldi	r24, 0x00	; 0
    5ef2:	90 e0       	ldi	r25, 0x00	; 0
    5ef4:	20 e0       	ldi	r18, 0x00	; 0
    5ef6:	30 e0       	ldi	r19, 0x00	; 0
		uint16_t j = StartAddr+i;
		uint16_t Byte=j/8, Bit=1<<j%8;
    5ef8:	e1 e0       	ldi	r30, 0x01	; 1
    5efa:	4e 2e       	mov	r4, r30
    5efc:	51 2c       	mov	r5, r1
		if (MB_Frame[MB_N][7+i/8] &(1<<i%8))
    5efe:	7a e6       	ldi	r23, 0x6A	; 106
    5f00:	67 2e       	mov	r6, r23
    5f02:	7b e0       	ldi	r23, 0x0B	; 11
    5f04:	77 2e       	mov	r7, r23
    5f06:	6e 0c       	add	r6, r14
    5f08:	7f 1c       	adc	r7, r15
    5f0a:	10 c0       	rjmp	.+32     	; 0x5f2c <MB_S_Timer_ISR+0x6a6>
			Coil[Byte] |=Bit;
    5f0c:	29 81       	ldd	r18, Y+1	; 0x01
    5f0e:	3a 81       	ldd	r19, Y+2	; 0x02
    5f10:	24 0f       	add	r18, r20
    5f12:	35 1f       	adc	r19, r21
    5f14:	f9 01       	movw	r30, r18
    5f16:	80 81       	ld	r24, Z
    5f18:	86 2b       	or	r24, r22
    5f1a:	80 83       	st	Z, r24
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+Qt > prw(&Modbus_Map[MB_N].Coil_Qt))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Coil = prp(&Modbus_Map[MB_N].Coil);
	MB_Frame_Sz[MB_N] = 8;
	for (uint8_t i=0; i<Qt; i++) {
    5f1c:	c3 94       	inc	r12
    5f1e:	2c 2d       	mov	r18, r12
    5f20:	30 e0       	ldi	r19, 0x00	; 0
    5f22:	c9 01       	movw	r24, r18
    5f24:	2a 17       	cp	r18, r26
    5f26:	3b 07       	cpc	r19, r27
    5f28:	08 f0       	brcs	.+2      	; 0x5f2c <MB_S_Timer_ISR+0x6a6>
    5f2a:	43 cf       	rjmp	.-378    	; 0x5db2 <MB_S_Timer_ISR+0x52c>
		uint16_t j = StartAddr+i;
    5f2c:	88 0d       	add	r24, r8
    5f2e:	99 1d       	adc	r25, r9
		uint16_t Byte=j/8, Bit=1<<j%8;
    5f30:	ac 01       	movw	r20, r24
    5f32:	56 95       	lsr	r21
    5f34:	47 95       	ror	r20
    5f36:	56 95       	lsr	r21
    5f38:	47 95       	ror	r20
    5f3a:	56 95       	lsr	r21
    5f3c:	47 95       	ror	r20
    5f3e:	87 70       	andi	r24, 0x07	; 7
    5f40:	90 70       	andi	r25, 0x00	; 0
    5f42:	b2 01       	movw	r22, r4
    5f44:	02 c0       	rjmp	.+4      	; 0x5f4a <MB_S_Timer_ISR+0x6c4>
    5f46:	66 0f       	add	r22, r22
    5f48:	77 1f       	adc	r23, r23
    5f4a:	8a 95       	dec	r24
    5f4c:	e2 f7       	brpl	.-8      	; 0x5f46 <MB_S_Timer_ISR+0x6c0>
		if (MB_Frame[MB_N][7+i/8] &(1<<i%8))
    5f4e:	8c 2d       	mov	r24, r12
    5f50:	86 95       	lsr	r24
    5f52:	86 95       	lsr	r24
    5f54:	86 95       	lsr	r24
    5f56:	f3 01       	movw	r30, r6
    5f58:	e8 0f       	add	r30, r24
    5f5a:	f1 1d       	adc	r31, r1
    5f5c:	87 81       	ldd	r24, Z+7	; 0x07
    5f5e:	90 e0       	ldi	r25, 0x00	; 0
    5f60:	27 70       	andi	r18, 0x07	; 7
    5f62:	30 70       	andi	r19, 0x00	; 0
    5f64:	02 c0       	rjmp	.+4      	; 0x5f6a <MB_S_Timer_ISR+0x6e4>
    5f66:	95 95       	asr	r25
    5f68:	87 95       	ror	r24
    5f6a:	2a 95       	dec	r18
    5f6c:	e2 f7       	brpl	.-8      	; 0x5f66 <MB_S_Timer_ISR+0x6e0>
    5f6e:	80 fd       	sbrc	r24, 0
    5f70:	cd cf       	rjmp	.-102    	; 0x5f0c <MB_S_Timer_ISR+0x686>
			Coil[Byte] |=Bit;
		else
			Coil[Byte] &=~Bit;
    5f72:	29 81       	ldd	r18, Y+1	; 0x01
    5f74:	3a 81       	ldd	r19, Y+2	; 0x02
    5f76:	24 0f       	add	r18, r20
    5f78:	35 1f       	adc	r19, r21
    5f7a:	96 2f       	mov	r25, r22
    5f7c:	90 95       	com	r25
    5f7e:	f9 01       	movw	r30, r18
    5f80:	80 81       	ld	r24, Z
    5f82:	89 23       	and	r24, r25
    5f84:	80 83       	st	Z, r24
    5f86:	ca cf       	rjmp	.-108    	; 0x5f1c <MB_S_Timer_ISR+0x696>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    5f88:	e8 85       	ldd	r30, Y+8	; 0x08
    5f8a:	f9 85       	ldd	r31, Y+9	; 0x09
    5f8c:	ee 0f       	add	r30, r30
    5f8e:	ff 1f       	adc	r31, r31
    5f90:	ee 0f       	add	r30, r30
    5f92:	ff 1f       	adc	r31, r31
    5f94:	ee 0f       	add	r30, r30
    5f96:	ff 1f       	adc	r31, r31
    5f98:	ee 0f       	add	r30, r30
    5f9a:	ff 1f       	adc	r31, r31
    5f9c:	ee 5c       	subi	r30, 0xCE	; 206
    5f9e:	fc 4f       	sbci	r31, 0xFC	; 252
    5fa0:	45 91       	lpm	r20, Z+
    5fa2:	54 91       	lpm	r21, Z+
    5fa4:	b2 cd       	rjmp	.-1180   	; 0x5b0a <MB_S_Timer_ISR+0x284>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5fa6:	f3 01       	movw	r30, r6
    5fa8:	e6 5c       	subi	r30, 0xC6	; 198
    5faa:	fc 4f       	sbci	r31, 0xFC	; 252
    5fac:	45 91       	lpm	r20, Z+
    5fae:	54 91       	lpm	r21, Z+
    5fb0:	54 cf       	rjmp	.-344    	; 0x5e5a <MB_S_Timer_ISR+0x5d4>
    5fb2:	f3 01       	movw	r30, r6
    5fb4:	e0 5d       	subi	r30, 0xD0	; 208
    5fb6:	fc 4f       	sbci	r31, 0xFC	; 252
    5fb8:	85 91       	lpm	r24, Z+
    5fba:	94 91       	lpm	r25, Z+
    5fbc:	28 2f       	mov	r18, r24
    5fbe:	89 2f       	mov	r24, r25
    5fc0:	b9 cd       	rjmp	.-1166   	; 0x5b34 <MB_S_Timer_ISR+0x2ae>
    5fc2:	e8 85       	ldd	r30, Y+8	; 0x08
    5fc4:	f9 85       	ldd	r31, Y+9	; 0x09
    5fc6:	ee 0f       	add	r30, r30
    5fc8:	ff 1f       	adc	r31, r31
    5fca:	ee 0f       	add	r30, r30
    5fcc:	ff 1f       	adc	r31, r31
    5fce:	ee 0f       	add	r30, r30
    5fd0:	ff 1f       	adc	r31, r31
    5fd2:	ee 0f       	add	r30, r30
    5fd4:	ff 1f       	adc	r31, r31
    5fd6:	e8 5c       	subi	r30, 0xC8	; 200
    5fd8:	fc 4f       	sbci	r31, 0xFC	; 252
    5fda:	85 91       	lpm	r24, Z+
    5fdc:	94 91       	lpm	r25, Z+
    5fde:	4d cf       	rjmp	.-358    	; 0x5e7a <MB_S_Timer_ISR+0x5f4>

00005fe0 <MB_S_Tx>:
    5fe0:	94 e1       	ldi	r25, 0x14	; 20
    5fe2:	89 9f       	mul	r24, r25
    5fe4:	c0 01       	movw	r24, r0
    5fe6:	11 24       	eor	r1, r1
    5fe8:	82 56       	subi	r24, 0x62	; 98
    5fea:	90 4d       	sbci	r25, 0xD0	; 208
    5fec:	fc 01       	movw	r30, r24
    5fee:	25 91       	lpm	r18, Z+
    5ff0:	34 91       	lpm	r19, Z+

// ~~~~~~~~~~~~~~~~~~
void
MB_S_Tx(uint8_t MB_N)
{
	USART_Func(MB_N, LED);
    5ff2:	f9 01       	movw	r30, r18
    5ff4:	19 95       	eicall
}
    5ff6:	08 95       	ret

00005ff8 <MB_Slave_Off>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
MB_Slave_Off(uint8_t MB_N, uint8_t S_N)
{
    5ff8:	21 e0       	ldi	r18, 0x01	; 1
    5ffa:	30 e0       	ldi	r19, 0x00	; 0
    5ffc:	40 e0       	ldi	r20, 0x00	; 0
    5ffe:	50 e0       	ldi	r21, 0x00	; 0
    6000:	04 c0       	rjmp	.+8      	; 0x600a <MB_Slave_Off+0x12>
    6002:	22 0f       	add	r18, r18
    6004:	33 1f       	adc	r19, r19
    6006:	44 1f       	adc	r20, r20
    6008:	55 1f       	adc	r21, r21
    600a:	6a 95       	dec	r22
    600c:	d2 f7       	brpl	.-12     	; 0x6002 <MB_Slave_Off+0xa>
    600e:	e8 2f       	mov	r30, r24
    6010:	f0 e0       	ldi	r31, 0x00	; 0
    6012:	ee 0f       	add	r30, r30
    6014:	ff 1f       	adc	r31, r31
    6016:	ee 0f       	add	r30, r30
    6018:	ff 1f       	adc	r31, r31
    601a:	e4 5d       	subi	r30, 0xD4	; 212
    601c:	f6 4f       	sbci	r31, 0xF6	; 246
    601e:	80 81       	ld	r24, Z
    6020:	91 81       	ldd	r25, Z+1	; 0x01
    6022:	a2 81       	ldd	r26, Z+2	; 0x02
    6024:	b3 81       	ldd	r27, Z+3	; 0x03
    6026:	28 23       	and	r18, r24
    6028:	39 23       	and	r19, r25
    602a:	4a 23       	and	r20, r26
    602c:	5b 23       	and	r21, r27
	return SlaveOff[MB_N] &((uint32_t)1<<S_N);
}
    602e:	b9 01       	movw	r22, r18
    6030:	ca 01       	movw	r24, r20
    6032:	08 95       	ret

00006034 <GetReg>:
}

// ~~~~~~~~~~~~~~~~~
static uint16_t*
GetReg(uint8_t MB_N)
{
    6034:	98 2f       	mov	r25, r24
	return MB_SingleState[MB_N]!=MB_SingleExec?(uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+prw(&GetQuery(MB_N)->AllocAddr):MB_SingleQuery[MB_N].Buf;
    6036:	a8 2f       	mov	r26, r24
    6038:	b0 e0       	ldi	r27, 0x00	; 0
    603a:	fd 01       	movw	r30, r26
    603c:	e1 55       	subi	r30, 0x51	; 81
    603e:	f9 4f       	sbci	r31, 0xF9	; 249
    6040:	80 81       	ld	r24, Z
    6042:	82 30       	cpi	r24, 0x02	; 2
    6044:	09 f4       	brne	.+2      	; 0x6048 <GetReg+0x14>
    6046:	39 c0       	rjmp	.+114    	; 0x60ba <GetReg+0x86>
    6048:	fd 01       	movw	r30, r26
    604a:	ee 0f       	add	r30, r30
    604c:	ff 1f       	adc	r31, r31
    604e:	ee 0f       	add	r30, r30
    6050:	ff 1f       	adc	r31, r31
    6052:	ee 0f       	add	r30, r30
    6054:	ff 1f       	adc	r31, r31
    6056:	ee 0f       	add	r30, r30
    6058:	ff 1f       	adc	r31, r31
    605a:	e8 5c       	subi	r30, 0xC8	; 200
    605c:	fc 4f       	sbci	r31, 0xFC	; 252
    605e:	45 91       	lpm	r20, Z+
    6060:	54 91       	lpm	r21, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    6062:	83 e0       	ldi	r24, 0x03	; 3
    6064:	98 9f       	mul	r25, r24
    6066:	f0 01       	movw	r30, r0
    6068:	11 24       	eor	r1, r1
    606a:	e5 5b       	subi	r30, 0xB5	; 181
    606c:	f6 4d       	sbci	r31, 0xD6	; 214
    606e:	25 91       	lpm	r18, Z+
    6070:	34 91       	lpm	r19, Z+
    6072:	fd 01       	movw	r30, r26
    6074:	ec 5a       	subi	r30, 0xAC	; 172
    6076:	f9 4f       	sbci	r31, 0xF9	; 249
    6078:	80 81       	ld	r24, Z
    607a:	90 e0       	ldi	r25, 0x00	; 0
    607c:	88 0f       	add	r24, r24
    607e:	99 1f       	adc	r25, r25
    6080:	88 0f       	add	r24, r24
    6082:	99 1f       	adc	r25, r25
    6084:	28 0f       	add	r18, r24
    6086:	39 1f       	adc	r19, r25
    6088:	2f 5f       	subi	r18, 0xFF	; 255
    608a:	3f 4f       	sbci	r19, 0xFF	; 255
    608c:	f9 01       	movw	r30, r18
    608e:	65 91       	lpm	r22, Z+
    6090:	74 91       	lpm	r23, Z+
    6092:	ab 5a       	subi	r26, 0xAB	; 171
    6094:	b9 4f       	sbci	r27, 0xF9	; 249
    6096:	8c 91       	ld	r24, X
    6098:	27 e0       	ldi	r18, 0x07	; 7
    609a:	82 9f       	mul	r24, r18
    609c:	c0 01       	movw	r24, r0
    609e:	11 24       	eor	r1, r1
    60a0:	68 0f       	add	r22, r24
    60a2:	79 1f       	adc	r23, r25
    60a4:	6b 5f       	subi	r22, 0xFB	; 251
    60a6:	7f 4f       	sbci	r23, 0xFF	; 255
    60a8:	fb 01       	movw	r30, r22
    60aa:	85 91       	lpm	r24, Z+
    60ac:	94 91       	lpm	r25, Z+
    60ae:	88 0f       	add	r24, r24
    60b0:	99 1f       	adc	r25, r25
    60b2:	48 0f       	add	r20, r24
    60b4:	59 1f       	adc	r21, r25
}
    60b6:	ca 01       	movw	r24, r20
    60b8:	08 95       	ret

// ~~~~~~~~~~~~~~~~~
static uint16_t*
GetReg(uint8_t MB_N)
{
	return MB_SingleState[MB_N]!=MB_SingleExec?(uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+prw(&GetQuery(MB_N)->AllocAddr):MB_SingleQuery[MB_N].Buf;
    60ba:	aa 0f       	add	r26, r26
    60bc:	bb 1f       	adc	r27, r27
    60be:	aa 0f       	add	r26, r26
    60c0:	bb 1f       	adc	r27, r27
    60c2:	aa 0f       	add	r26, r26
    60c4:	bb 1f       	adc	r27, r27
    60c6:	a6 52       	subi	r26, 0x26	; 38
    60c8:	bb 4f       	sbci	r27, 0xFB	; 251
    60ca:	16 96       	adiw	r26, 0x06	; 6
    60cc:	4d 91       	ld	r20, X+
    60ce:	5c 91       	ld	r21, X
    60d0:	17 97       	sbiw	r26, 0x07	; 7
}
    60d2:	ca 01       	movw	r24, r20
    60d4:	08 95       	ret

000060d6 <FormData>:

// ~~~~~~~~~~~~~~~~~~~
static void
FormData(uint8_t MB_N)
{
    60d6:	cf 92       	push	r12
    60d8:	df 92       	push	r13
    60da:	ef 92       	push	r14
    60dc:	ff 92       	push	r15
    60de:	0f 93       	push	r16
    60e0:	1f 93       	push	r17
    60e2:	cf 93       	push	r28
    60e4:	df 93       	push	r29
    60e6:	e8 2e       	mov	r14, r24
	uint16_t Qt;
	uint16_t *Reg;
	switch (MB_Frame[MB_N][1]) {
    60e8:	c8 2f       	mov	r28, r24
    60ea:	d0 e0       	ldi	r29, 0x00	; 0
    60ec:	7c 2f       	mov	r23, r28
    60ee:	66 27       	eor	r22, r22
    60f0:	8b 01       	movw	r16, r22
    60f2:	06 59       	subi	r16, 0x96	; 150
    60f4:	14 4f       	sbci	r17, 0xF4	; 244
    60f6:	f8 01       	movw	r30, r16
    60f8:	81 81       	ldd	r24, Z+1	; 0x01
    60fa:	86 30       	cpi	r24, 0x06	; 6
    60fc:	09 f4       	brne	.+2      	; 0x6100 <FormData+0x2a>
    60fe:	4b c0       	rjmp	.+150    	; 0x6196 <FormData+0xc0>
    6100:	87 30       	cpi	r24, 0x07	; 7
    6102:	88 f0       	brcs	.+34     	; 0x6126 <FormData+0x50>
    6104:	8f 30       	cpi	r24, 0x0F	; 15
    6106:	09 f4       	brne	.+2      	; 0x610a <FormData+0x34>
    6108:	5b c0       	rjmp	.+182    	; 0x61c0 <FormData+0xea>
    610a:	80 31       	cpi	r24, 0x10	; 16
    610c:	a1 f0       	breq	.+40     	; 0x6136 <FormData+0x60>
			MB_Frame[MB_N][7+j] = Reg[i]>>8;
			MB_Frame[MB_N][8+j] = Reg[i];
		}
		break;
	}
	SetCRC_MB(MB_N);
    610e:	8e 2d       	mov	r24, r14
    6110:	0e 94 ea 2b 	call	0x57d4	; 0x57d4 <SetCRC_MB>
}
    6114:	df 91       	pop	r29
    6116:	cf 91       	pop	r28
    6118:	1f 91       	pop	r17
    611a:	0f 91       	pop	r16
    611c:	ff 90       	pop	r15
    611e:	ef 90       	pop	r14
    6120:	df 90       	pop	r13
    6122:	cf 90       	pop	r12
    6124:	08 95       	ret
static void
FormData(uint8_t MB_N)
{
	uint16_t Qt;
	uint16_t *Reg;
	switch (MB_Frame[MB_N][1]) {
    6126:	81 50       	subi	r24, 0x01	; 1
    6128:	84 30       	cpi	r24, 0x04	; 4
    612a:	88 f7       	brcc	.-30     	; 0x610e <FormData+0x38>
	case 1: case 2: case 3: case 4:
		MB_Frame_Sz[MB_N] = 8;
    612c:	c7 5b       	subi	r28, 0xB7	; 183
    612e:	d8 4f       	sbci	r29, 0xF8	; 248
    6130:	88 e0       	ldi	r24, 0x08	; 8
    6132:	88 83       	st	Y, r24
    6134:	ec cf       	rjmp	.-40     	; 0x610e <FormData+0x38>
			else
				MB_Frame[MB_N][Byte] &=~Bit;
		}
		break;
	case 0x10:
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = MB_Frame[MB_N][5]*2) + 9;
    6136:	55 e0       	ldi	r21, 0x05	; 5
    6138:	c5 2e       	mov	r12, r21
    613a:	d1 2c       	mov	r13, r1
    613c:	c0 0e       	add	r12, r16
    613e:	d1 1e       	adc	r13, r17
    6140:	f8 01       	movw	r30, r16
    6142:	85 81       	ldd	r24, Z+5	; 0x05
    6144:	90 e0       	ldi	r25, 0x00	; 0
    6146:	88 0f       	add	r24, r24
    6148:	99 1f       	adc	r25, r25
    614a:	86 83       	std	Z+6, r24	; 0x06
    614c:	c7 5b       	subi	r28, 0xB7	; 183
    614e:	d8 4f       	sbci	r29, 0xF8	; 248
    6150:	87 5f       	subi	r24, 0xF7	; 247
    6152:	88 83       	st	Y, r24
		Reg = GetReg(MB_N);
    6154:	8e 2d       	mov	r24, r14
    6156:	0e 94 1a 30 	call	0x6034	; 0x6034 <GetReg>
    615a:	bc 01       	movw	r22, r24
		for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    615c:	f8 01       	movw	r30, r16
    615e:	85 81       	ldd	r24, Z+5	; 0x05
    6160:	88 23       	and	r24, r24
    6162:	a9 f2       	breq	.-86     	; 0x610e <FormData+0x38>
    6164:	20 e0       	ldi	r18, 0x00	; 0
			uint8_t j = i*2;
			MB_Frame[MB_N][7+j] = Reg[i]>>8;
    6166:	a8 01       	movw	r20, r16
		}
		break;
	case 0x10:
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = MB_Frame[MB_N][5]*2) + 9;
		Reg = GetReg(MB_N);
		for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    6168:	e6 01       	movw	r28, r12
			uint8_t j = i*2;
			MB_Frame[MB_N][7+j] = Reg[i]>>8;
    616a:	82 2f       	mov	r24, r18
    616c:	90 e0       	ldi	r25, 0x00	; 0
    616e:	88 0f       	add	r24, r24
    6170:	99 1f       	adc	r25, r25
    6172:	fb 01       	movw	r30, r22
    6174:	e8 0f       	add	r30, r24
    6176:	f9 1f       	adc	r31, r25
    6178:	da 01       	movw	r26, r20
    617a:	a8 0f       	add	r26, r24
    617c:	b1 1d       	adc	r27, r1
    617e:	81 81       	ldd	r24, Z+1	; 0x01
    6180:	17 96       	adiw	r26, 0x07	; 7
    6182:	8c 93       	st	X, r24
    6184:	17 97       	sbiw	r26, 0x07	; 7
			MB_Frame[MB_N][8+j] = Reg[i];
    6186:	80 81       	ld	r24, Z
    6188:	18 96       	adiw	r26, 0x08	; 8
    618a:	8c 93       	st	X, r24
		}
		break;
	case 0x10:
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = MB_Frame[MB_N][5]*2) + 9;
		Reg = GetReg(MB_N);
		for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    618c:	2f 5f       	subi	r18, 0xFF	; 255
    618e:	88 81       	ld	r24, Y
    6190:	28 17       	cp	r18, r24
    6192:	58 f3       	brcs	.-42     	; 0x616a <FormData+0x94>
    6194:	bc cf       	rjmp	.-136    	; 0x610e <FormData+0x38>
		MB_Frame_Sz[MB_N] = 8;
		MB_Frame[MB_N][5] = 0;
		break;
	*/
	case 6:
		MB_Frame_Sz[MB_N] = 8;
    6196:	fe 01       	movw	r30, r28
    6198:	e7 5b       	subi	r30, 0xB7	; 183
    619a:	f8 4f       	sbci	r31, 0xF8	; 248
    619c:	88 e0       	ldi	r24, 0x08	; 8
    619e:	80 83       	st	Z, r24
		Reg = GetReg(MB_N);
    61a0:	8e 2d       	mov	r24, r14
    61a2:	0e 94 1a 30 	call	0x6034	; 0x6034 <GetReg>
    61a6:	dc 01       	movw	r26, r24
		MB_Frame[MB_N][4] = *Reg>>8;
    61a8:	fc 2f       	mov	r31, r28
    61aa:	ee 27       	eor	r30, r30
    61ac:	e2 59       	subi	r30, 0x92	; 146
    61ae:	f4 4f       	sbci	r31, 0xF4	; 244
    61b0:	11 96       	adiw	r26, 0x01	; 1
    61b2:	8c 91       	ld	r24, X
    61b4:	11 97       	sbiw	r26, 0x01	; 1
    61b6:	80 83       	st	Z, r24
		MB_Frame[MB_N][5] = *Reg;
    61b8:	8c 91       	ld	r24, X
    61ba:	f8 01       	movw	r30, r16
    61bc:	85 83       	std	Z+5, r24	; 0x05
    61be:	a7 cf       	rjmp	.-178    	; 0x610e <FormData+0x38>
    61c0:	fc 2f       	mov	r31, r28
    61c2:	ee 27       	eor	r30, r30
    61c4:	e2 59       	subi	r30, 0x92	; 146
    61c6:	f4 4f       	sbci	r31, 0xF4	; 244
    61c8:	90 81       	ld	r25, Z
    61ca:	80 e0       	ldi	r24, 0x00	; 0
    61cc:	f8 01       	movw	r30, r16
    61ce:	25 81       	ldd	r18, Z+5	; 0x05
    61d0:	02 2f       	mov	r16, r18
    61d2:	10 e0       	ldi	r17, 0x00	; 0
    61d4:	08 2b       	or	r16, r24
    61d6:	19 2b       	or	r17, r25
		break;
	case 0x0F:
		Qt = MB_FrameReg(MB_N, 4);
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = Qt/8 + (Qt%8>0)) + 9;
    61d8:	98 01       	movw	r18, r16
    61da:	36 95       	lsr	r19
    61dc:	27 95       	ror	r18
    61de:	36 95       	lsr	r19
    61e0:	27 95       	ror	r18
    61e2:	36 95       	lsr	r19
    61e4:	27 95       	ror	r18
    61e6:	40 e0       	ldi	r20, 0x00	; 0
    61e8:	c8 01       	movw	r24, r16
    61ea:	87 70       	andi	r24, 0x07	; 7
    61ec:	90 70       	andi	r25, 0x00	; 0
    61ee:	89 2b       	or	r24, r25
    61f0:	09 f0       	breq	.+2      	; 0x61f4 <FormData+0x11e>
    61f2:	8b c0       	rjmp	.+278    	; 0x630a <FormData+0x234>
    61f4:	84 2f       	mov	r24, r20
    61f6:	82 0f       	add	r24, r18
    61f8:	fb 01       	movw	r30, r22
    61fa:	e6 59       	subi	r30, 0x96	; 150
    61fc:	f4 4f       	sbci	r31, 0xF4	; 244
    61fe:	86 83       	std	Z+6, r24	; 0x06
    6200:	de 01       	movw	r26, r28
    6202:	a7 5b       	subi	r26, 0xB7	; 183
    6204:	b8 4f       	sbci	r27, 0xF8	; 248
    6206:	87 5f       	subi	r24, 0xF7	; 247
    6208:	8c 93       	st	X, r24
		MB_Frame[MB_N][7+Qt/8] = 0;
    620a:	e2 0f       	add	r30, r18
    620c:	f3 1f       	adc	r31, r19
    620e:	17 82       	std	Z+7, r1	; 0x07
		uint8_t *Discr;
		uint8_t Pin;
		if (MB_SingleState[MB_N]!=MB_SingleExec) {
    6210:	fe 01       	movw	r30, r28
    6212:	e1 55       	subi	r30, 0x51	; 81
    6214:	f9 4f       	sbci	r31, 0xF9	; 249
    6216:	80 81       	ld	r24, Z
    6218:	82 30       	cpi	r24, 0x02	; 2
    621a:	09 f4       	brne	.+2      	; 0x621e <FormData+0x148>
    621c:	78 c0       	rjmp	.+240    	; 0x630e <FormData+0x238>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    621e:	fe 01       	movw	r30, r28
    6220:	e2 95       	swap	r30
    6222:	f2 95       	swap	r31
    6224:	f0 7f       	andi	r31, 0xF0	; 240
    6226:	fe 27       	eor	r31, r30
    6228:	e0 7f       	andi	r30, 0xF0	; 240
    622a:	fe 27       	eor	r31, r30
    622c:	e0 5d       	subi	r30, 0xD0	; 208
    622e:	fc 4f       	sbci	r31, 0xFC	; 252
			Discr = prp(&Modbus_Map[MB_N].Coil);
    6230:	a5 91       	lpm	r26, Z+
    6232:	b4 91       	lpm	r27, Z+
    6234:	83 e0       	ldi	r24, 0x03	; 3
    6236:	e8 9e       	mul	r14, r24
    6238:	f0 01       	movw	r30, r0
    623a:	11 24       	eor	r1, r1
    623c:	e5 5b       	subi	r30, 0xB5	; 181
    623e:	f6 4d       	sbci	r31, 0xD6	; 214
    6240:	25 91       	lpm	r18, Z+
    6242:	34 91       	lpm	r19, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    6244:	fe 01       	movw	r30, r28
    6246:	ec 5a       	subi	r30, 0xAC	; 172
    6248:	f9 4f       	sbci	r31, 0xF9	; 249
    624a:	80 81       	ld	r24, Z
    624c:	90 e0       	ldi	r25, 0x00	; 0
    624e:	88 0f       	add	r24, r24
    6250:	99 1f       	adc	r25, r25
    6252:	88 0f       	add	r24, r24
    6254:	99 1f       	adc	r25, r25
    6256:	28 0f       	add	r18, r24
    6258:	39 1f       	adc	r19, r25
    625a:	2f 5f       	subi	r18, 0xFF	; 255
    625c:	3f 4f       	sbci	r19, 0xFF	; 255
    625e:	f9 01       	movw	r30, r18
    6260:	45 91       	lpm	r20, Z+
    6262:	54 91       	lpm	r21, Z+
    6264:	cb 5a       	subi	r28, 0xAB	; 171
    6266:	d9 4f       	sbci	r29, 0xF9	; 249
    6268:	88 81       	ld	r24, Y
    626a:	27 e0       	ldi	r18, 0x07	; 7
    626c:	82 9f       	mul	r24, r18
    626e:	c0 01       	movw	r24, r0
    6270:	11 24       	eor	r1, r1
    6272:	48 0f       	add	r20, r24
    6274:	59 1f       	adc	r21, r25
    6276:	4b 5f       	subi	r20, 0xFB	; 251
    6278:	5f 4f       	sbci	r21, 0xFF	; 255
    627a:	fa 01       	movw	r30, r20
    627c:	85 91       	lpm	r24, Z+
    627e:	94 91       	lpm	r25, Z+
			Pin = prw(&GetQuery(MB_N)->AllocAddr);
    6280:	f8 2e       	mov	r15, r24
		}
		else {
			Discr = MB_SingleQuery[MB_N].Buf;
			Pin = 0;
		}
		for (uint8_t i=0; i<Qt; i++) {
    6282:	01 15       	cp	r16, r1
    6284:	11 05       	cpc	r17, r1
    6286:	09 f4       	brne	.+2      	; 0x628a <FormData+0x1b4>
    6288:	42 cf       	rjmp	.-380    	; 0x610e <FormData+0x38>
    628a:	50 e0       	ldi	r21, 0x00	; 0
    628c:	80 e0       	ldi	r24, 0x00	; 0
    628e:	90 e0       	ldi	r25, 0x00	; 0
			uint8_t j = Pin+i;
			uint8_t Byte=7+i/8, Bit=1<<i%8;
    6290:	c1 e0       	ldi	r28, 0x01	; 1
    6292:	d0 e0       	ldi	r29, 0x00	; 0
    6294:	0f c0       	rjmp	.+30     	; 0x62b4 <FormData+0x1de>
			if (Discr[j/8] &(1<<j%8))
				MB_Frame[MB_N][Byte] |=Bit;
    6296:	fb 01       	movw	r30, r22
    6298:	e3 0f       	add	r30, r19
    629a:	f1 1d       	adc	r31, r1
    629c:	e6 59       	subi	r30, 0x96	; 150
    629e:	f4 4f       	sbci	r31, 0xF4	; 244
    62a0:	80 81       	ld	r24, Z
    62a2:	84 2b       	or	r24, r20
    62a4:	80 83       	st	Z, r24
		}
		else {
			Discr = MB_SingleQuery[MB_N].Buf;
			Pin = 0;
		}
		for (uint8_t i=0; i<Qt; i++) {
    62a6:	5f 5f       	subi	r21, 0xFF	; 255
    62a8:	85 2f       	mov	r24, r21
    62aa:	90 e0       	ldi	r25, 0x00	; 0
    62ac:	80 17       	cp	r24, r16
    62ae:	91 07       	cpc	r25, r17
    62b0:	08 f0       	brcs	.+2      	; 0x62b4 <FormData+0x1de>
    62b2:	2d cf       	rjmp	.-422    	; 0x610e <FormData+0x38>
    62b4:	25 2f       	mov	r18, r21
    62b6:	2f 0d       	add	r18, r15
			uint8_t j = Pin+i;
			uint8_t Byte=7+i/8, Bit=1<<i%8;
    62b8:	35 2f       	mov	r19, r21
    62ba:	36 95       	lsr	r19
    62bc:	36 95       	lsr	r19
    62be:	36 95       	lsr	r19
    62c0:	39 5f       	subi	r19, 0xF9	; 249
    62c2:	87 70       	andi	r24, 0x07	; 7
    62c4:	90 70       	andi	r25, 0x00	; 0
    62c6:	fe 01       	movw	r30, r28
    62c8:	02 c0       	rjmp	.+4      	; 0x62ce <FormData+0x1f8>
    62ca:	ee 0f       	add	r30, r30
    62cc:	ff 1f       	adc	r31, r31
    62ce:	8a 95       	dec	r24
    62d0:	e2 f7       	brpl	.-8      	; 0x62ca <FormData+0x1f4>
    62d2:	4e 2f       	mov	r20, r30
			if (Discr[j/8] &(1<<j%8))
    62d4:	82 2f       	mov	r24, r18
    62d6:	86 95       	lsr	r24
    62d8:	86 95       	lsr	r24
    62da:	86 95       	lsr	r24
    62dc:	fd 01       	movw	r30, r26
    62de:	e8 0f       	add	r30, r24
    62e0:	f1 1d       	adc	r31, r1
    62e2:	80 81       	ld	r24, Z
    62e4:	90 e0       	ldi	r25, 0x00	; 0
    62e6:	27 70       	andi	r18, 0x07	; 7
    62e8:	02 c0       	rjmp	.+4      	; 0x62ee <FormData+0x218>
    62ea:	95 95       	asr	r25
    62ec:	87 95       	ror	r24
    62ee:	2a 95       	dec	r18
    62f0:	e2 f7       	brpl	.-8      	; 0x62ea <FormData+0x214>
    62f2:	80 fd       	sbrc	r24, 0
    62f4:	d0 cf       	rjmp	.-96     	; 0x6296 <FormData+0x1c0>
				MB_Frame[MB_N][Byte] |=Bit;
			else
				MB_Frame[MB_N][Byte] &=~Bit;
    62f6:	fb 01       	movw	r30, r22
    62f8:	e3 0f       	add	r30, r19
    62fa:	f1 1d       	adc	r31, r1
    62fc:	e6 59       	subi	r30, 0x96	; 150
    62fe:	f4 4f       	sbci	r31, 0xF4	; 244
    6300:	40 95       	com	r20
    6302:	80 81       	ld	r24, Z
    6304:	48 23       	and	r20, r24
    6306:	40 83       	st	Z, r20
    6308:	ce cf       	rjmp	.-100    	; 0x62a6 <FormData+0x1d0>
		MB_Frame[MB_N][4] = *Reg>>8;
		MB_Frame[MB_N][5] = *Reg;
		break;
	case 0x0F:
		Qt = MB_FrameReg(MB_N, 4);
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = Qt/8 + (Qt%8>0)) + 9;
    630a:	41 e0       	ldi	r20, 0x01	; 1
    630c:	73 cf       	rjmp	.-282    	; 0x61f4 <FormData+0x11e>
		if (MB_SingleState[MB_N]!=MB_SingleExec) {
			Discr = prp(&Modbus_Map[MB_N].Coil);
			Pin = prw(&GetQuery(MB_N)->AllocAddr);
		}
		else {
			Discr = MB_SingleQuery[MB_N].Buf;
    630e:	cc 0f       	add	r28, r28
    6310:	dd 1f       	adc	r29, r29
    6312:	cc 0f       	add	r28, r28
    6314:	dd 1f       	adc	r29, r29
    6316:	cc 0f       	add	r28, r28
    6318:	dd 1f       	adc	r29, r29
    631a:	c6 52       	subi	r28, 0x26	; 38
    631c:	db 4f       	sbci	r29, 0xFB	; 251
    631e:	ae 81       	ldd	r26, Y+6	; 0x06
    6320:	bf 81       	ldd	r27, Y+7	; 0x07
    6322:	ff 24       	eor	r15, r15
    6324:	ae cf       	rjmp	.-164    	; 0x6282 <FormData+0x1ac>

00006326 <FormQuery>:
}

// ~~~~~~~~~~~~~~~~~~~~
static void
FormQuery(uint8_t MB_N)
{
    6326:	cf 93       	push	r28
    6328:	df 93       	push	r29

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    632a:	93 e0       	ldi	r25, 0x03	; 3
    632c:	89 9f       	mul	r24, r25
    632e:	f0 01       	movw	r30, r0
    6330:	11 24       	eor	r1, r1
    6332:	e5 5b       	subi	r30, 0xB5	; 181
    6334:	f6 4d       	sbci	r31, 0xD6	; 214
    6336:	65 91       	lpm	r22, Z+
    6338:	74 91       	lpm	r23, Z+

// ~~~~~~~~~~~~~~~~~~~
static MB_Slave*
GetSlave(uint8_t MB_N)
{
	return (MB_Slave*)prp(&(MB_Master_List+MB_N)->SlaveList)+CurrSlave[MB_N];
    633a:	48 2f       	mov	r20, r24
    633c:	50 e0       	ldi	r21, 0x00	; 0
    633e:	fa 01       	movw	r30, r20
    6340:	ec 5a       	subi	r30, 0xAC	; 172
    6342:	f9 4f       	sbci	r31, 0xF9	; 249
    6344:	20 81       	ld	r18, Z
    6346:	30 e0       	ldi	r19, 0x00	; 0
    6348:	22 0f       	add	r18, r18
    634a:	33 1f       	adc	r19, r19
    634c:	22 0f       	add	r18, r18
    634e:	33 1f       	adc	r19, r19
    6350:	62 0f       	add	r22, r18
    6352:	73 1f       	adc	r23, r19
    6354:	fb 01       	movw	r30, r22
    6356:	31 96       	adiw	r30, 0x01	; 1
    6358:	c5 91       	lpm	r28, Z+
    635a:	d4 91       	lpm	r29, Z+
// ~~~~~~~~~~~~~~~~~~~~
static void
FormQuery(uint8_t MB_N)
{
	MB_Slave *Slave = GetSlave(MB_N);
	MB_Query *Query = (MB_Query*)prp(&Slave->QueryList)+CurrQuery[MB_N];
    635c:	fa 01       	movw	r30, r20
    635e:	eb 5a       	subi	r30, 0xAB	; 171
    6360:	f9 4f       	sbci	r31, 0xF9	; 249
    6362:	20 81       	ld	r18, Z
    6364:	97 e0       	ldi	r25, 0x07	; 7
    6366:	29 9f       	mul	r18, r25
    6368:	90 01       	movw	r18, r0
    636a:	11 24       	eor	r1, r1
    636c:	c2 0f       	add	r28, r18
    636e:	d3 1f       	adc	r29, r19

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    6370:	fb 01       	movw	r30, r22
    6372:	94 91       	lpm	r25, Z+

	MB_Frame[MB_N][0] = prb(&Slave->Addr);
    6374:	2a e6       	ldi	r18, 0x6A	; 106
    6376:	3b e0       	ldi	r19, 0x0B	; 11
    6378:	b4 2f       	mov	r27, r20
    637a:	aa 27       	eor	r26, r26
    637c:	a2 0f       	add	r26, r18
    637e:	b3 1f       	adc	r27, r19
    6380:	9c 93       	st	X, r25
    6382:	fe 01       	movw	r30, r28
    6384:	94 91       	lpm	r25, Z+
	MB_Frame[MB_N][1] = prb(&Query->Func);
    6386:	11 96       	adiw	r26, 0x01	; 1
    6388:	9c 93       	st	X, r25
    638a:	11 97       	sbiw	r26, 0x01	; 1
	MB_Frame[MB_N][2] = prb((uint8_t*)&Query->StartAddr+1);
    638c:	be 01       	movw	r22, r28
    638e:	6f 5f       	subi	r22, 0xFF	; 255
    6390:	7f 4f       	sbci	r23, 0xFF	; 255
    6392:	6f 5f       	subi	r22, 0xFF	; 255
    6394:	7f 4f       	sbci	r23, 0xFF	; 255
    6396:	fb 01       	movw	r30, r22
    6398:	94 91       	lpm	r25, Z+
    639a:	61 50       	subi	r22, 0x01	; 1
    639c:	70 40       	sbci	r23, 0x00	; 0
    639e:	fd 01       	movw	r30, r26
    63a0:	92 83       	std	Z+2, r25	; 0x02
    63a2:	fb 01       	movw	r30, r22
    63a4:	94 91       	lpm	r25, Z+
	MB_Frame[MB_N][3] = prb((uint8_t*)&Query->StartAddr);
    63a6:	13 96       	adiw	r26, 0x03	; 3
    63a8:	9c 93       	st	X, r25
    63aa:	13 97       	sbiw	r26, 0x03	; 3
    63ac:	24 96       	adiw	r28, 0x04	; 4
    63ae:	fe 01       	movw	r30, r28
    63b0:	94 91       	lpm	r25, Z+
	MB_Frame[MB_N][4] = prb((uint8_t*)&Query->Qt+1);
    63b2:	fd 01       	movw	r30, r26
    63b4:	94 83       	std	Z+4, r25	; 0x04
    63b6:	21 97       	sbiw	r28, 0x01	; 1
    63b8:	fe 01       	movw	r30, r28
    63ba:	94 91       	lpm	r25, Z+
	MB_Frame[MB_N][5] = prb((uint8_t*)&Query->Qt);
    63bc:	15 96       	adiw	r26, 0x05	; 5
    63be:	9c 93       	st	X, r25

	FormData(MB_N);
    63c0:	0e 94 6b 30 	call	0x60d6	; 0x60d6 <FormData>
}
    63c4:	df 91       	pop	r29
    63c6:	cf 91       	pop	r28
    63c8:	08 95       	ret

000063ca <FormSingle>:

// ~~~~~~~~~~~~~~~~~~~~~
static void
FormSingle(uint8_t MB_N)
{
    63ca:	1f 93       	push	r17
    63cc:	cf 93       	push	r28
    63ce:	df 93       	push	r29
	MB_Frame[MB_N][0] = MB_SingleQuery[MB_N].Addr;
    63d0:	a8 2f       	mov	r26, r24
    63d2:	b0 e0       	ldi	r27, 0x00	; 0
    63d4:	6a e6       	ldi	r22, 0x6A	; 106
    63d6:	7b e0       	ldi	r23, 0x0B	; 11
    63d8:	5a 2f       	mov	r21, r26
    63da:	44 27       	eor	r20, r20
    63dc:	46 0f       	add	r20, r22
    63de:	57 1f       	adc	r21, r23
    63e0:	2a ed       	ldi	r18, 0xDA	; 218
    63e2:	34 e0       	ldi	r19, 0x04	; 4
    63e4:	fd 01       	movw	r30, r26
    63e6:	ee 0f       	add	r30, r30
    63e8:	ff 1f       	adc	r31, r31
    63ea:	ee 0f       	add	r30, r30
    63ec:	ff 1f       	adc	r31, r31
    63ee:	ee 0f       	add	r30, r30
    63f0:	ff 1f       	adc	r31, r31
    63f2:	e2 0f       	add	r30, r18
    63f4:	f3 1f       	adc	r31, r19
    63f6:	90 81       	ld	r25, Z
    63f8:	ea 01       	movw	r28, r20
    63fa:	98 83       	st	Y, r25
	MB_Frame[MB_N][1] = MB_SingleQuery[MB_N].Func;
    63fc:	91 81       	ldd	r25, Z+1	; 0x01
    63fe:	99 83       	std	Y+1, r25	; 0x01
	MB_Frame[MB_N][2] = MB_SingleQuery[MB_N].StartAddr>>8;
    6400:	fd 01       	movw	r30, r26
    6402:	ee 0f       	add	r30, r30
    6404:	ff 1f       	adc	r31, r31
    6406:	ee 0f       	add	r30, r30
    6408:	ff 1f       	adc	r31, r31
    640a:	ee 0f       	add	r30, r30
    640c:	ff 1f       	adc	r31, r31
    640e:	32 96       	adiw	r30, 0x02	; 2
    6410:	e2 0f       	add	r30, r18
    6412:	f3 1f       	adc	r31, r19
    6414:	10 81       	ld	r17, Z
    6416:	91 81       	ldd	r25, Z+1	; 0x01
    6418:	fa 01       	movw	r30, r20
    641a:	92 83       	std	Z+2, r25	; 0x02
	MB_Frame[MB_N][3] = MB_SingleQuery[MB_N].StartAddr;
    641c:	1b 83       	std	Y+3, r17	; 0x03
	MB_Frame[MB_N][4] = MB_SingleQuery[MB_N].Qt>>8;
    641e:	fd 01       	movw	r30, r26
    6420:	ee 0f       	add	r30, r30
    6422:	ff 1f       	adc	r31, r31
    6424:	ee 0f       	add	r30, r30
    6426:	ff 1f       	adc	r31, r31
    6428:	ee 0f       	add	r30, r30
    642a:	ff 1f       	adc	r31, r31
    642c:	34 96       	adiw	r30, 0x04	; 4
    642e:	e2 0f       	add	r30, r18
    6430:	f3 1f       	adc	r31, r19
    6432:	10 81       	ld	r17, Z
    6434:	91 81       	ldd	r25, Z+1	; 0x01
    6436:	9c 83       	std	Y+4, r25	; 0x04
	MB_Frame[MB_N][5] = MB_SingleQuery[MB_N].Qt;
    6438:	1d 83       	std	Y+5, r17	; 0x05
	
	MB_SingleState[MB_N] = MB_SingleExec;
    643a:	a1 55       	subi	r26, 0x51	; 81
    643c:	b9 4f       	sbci	r27, 0xF9	; 249
    643e:	92 e0       	ldi	r25, 0x02	; 2
    6440:	9c 93       	st	X, r25
	FormData(MB_N);
    6442:	0e 94 6b 30 	call	0x60d6	; 0x60d6 <FormData>
}
    6446:	df 91       	pop	r29
    6448:	cf 91       	pop	r28
    644a:	1f 91       	pop	r17
    644c:	08 95       	ret

0000644e <NextSlave>:

// ~~~~~~~~~~~~~~~~~~~~
static uint8_t
NextSlave(uint8_t MB_N)
{
    644e:	2f 92       	push	r2
    6450:	3f 92       	push	r3
    6452:	4f 92       	push	r4
    6454:	5f 92       	push	r5
    6456:	6f 92       	push	r6
    6458:	7f 92       	push	r7
    645a:	8f 92       	push	r8
    645c:	9f 92       	push	r9
    645e:	af 92       	push	r10
    6460:	bf 92       	push	r11
    6462:	cf 92       	push	r12
    6464:	df 92       	push	r13
    6466:	ef 92       	push	r14
    6468:	ff 92       	push	r15
    646a:	0f 93       	push	r16
    646c:	1f 93       	push	r17
    646e:	df 93       	push	r29
    6470:	cf 93       	push	r28
    6472:	00 d0       	rcall	.+0      	; 0x6474 <NextSlave+0x26>
    6474:	00 d0       	rcall	.+0      	; 0x6476 <NextSlave+0x28>
    6476:	cd b7       	in	r28, 0x3d	; 61
    6478:	de b7       	in	r29, 0x3e	; 62
    647a:	68 2e       	mov	r6, r24
    647c:	e3 e0       	ldi	r30, 0x03	; 3
    647e:	8e 9f       	mul	r24, r30
    6480:	f0 01       	movw	r30, r0
    6482:	11 24       	eor	r1, r1
    6484:	e3 5b       	subi	r30, 0xB3	; 179
    6486:	f6 4d       	sbci	r31, 0xD6	; 214
    6488:	04 91       	lpm	r16, Z+
    648a:	c8 2e       	mov	r12, r24
    648c:	dd 24       	eor	r13, r13
    648e:	a6 01       	movw	r20, r12
    6490:	4c 5a       	subi	r20, 0xAC	; 172
    6492:	59 4f       	sbci	r21, 0xF9	; 249
    6494:	5e 83       	std	Y+6, r21	; 0x06
    6496:	4d 83       	std	Y+5, r20	; 0x05
    6498:	fa 01       	movw	r30, r20
    649a:	20 81       	ld	r18, Z
    649c:	16 01       	movw	r2, r12
    649e:	22 0c       	add	r2, r2
    64a0:	33 1c       	adc	r3, r3
    64a2:	22 0c       	add	r2, r2
    64a4:	33 1c       	adc	r3, r3
    64a6:	f1 01       	movw	r30, r2
    64a8:	ec 51       	subi	r30, 0x1C	; 28
    64aa:	fb 4f       	sbci	r31, 0xFB	; 251
    64ac:	80 80       	ld	r8, Z
    64ae:	91 80       	ldd	r9, Z+1	; 0x01
    64b0:	a2 80       	ldd	r10, Z+2	; 0x02
    64b2:	b3 80       	ldd	r11, Z+3	; 0x03
	do
		if (++CurrSlave[MB_N]==SlaveQt) {
			CurrSlave[MB_N] = 0;
			Over = 1;

			if ((MB_Master_Cycle[MB_N]=0xFFFF-GetTimer16(TD_MB_Cycle+MB_N))>MB_Master_MaxCycle[MB_N])
    64b4:	70 90 e8 04 	lds	r7, 0x04E8
    64b8:	f2 e0       	ldi	r31, 0x02	; 2
    64ba:	7f 0e       	add	r7, r31
    64bc:	47 2d       	mov	r20, r7
    64be:	48 0f       	add	r20, r24
    64c0:	4a 83       	std	Y+2, r20	; 0x02
    64c2:	5e ef       	ldi	r21, 0xFE	; 254
    64c4:	75 0e       	add	r7, r21
// ~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
GetTimer16(uint8_t TimerN)
{
	IntOff();
	uint16_t Time = Timer16[TimerN];
    64c6:	e4 2e       	mov	r14, r20
    64c8:	ff 24       	eor	r15, r15
    64ca:	19 82       	std	Y+1, r1	; 0x01
    64cc:	10 e0       	ldi	r17, 0x00	; 0
    64ce:	ee 0c       	add	r14, r14
    64d0:	ff 1c       	adc	r15, r15
    64d2:	8f e4       	ldi	r24, 0x4F	; 79
    64d4:	93 e0       	ldi	r25, 0x03	; 3
    64d6:	e8 0e       	add	r14, r24
    64d8:	f9 1e       	adc	r15, r25
    64da:	c6 01       	movw	r24, r12
    64dc:	88 0f       	add	r24, r24
    64de:	99 1f       	adc	r25, r25
    64e0:	fc 01       	movw	r30, r24
    64e2:	e8 54       	subi	r30, 0x48	; 72
    64e4:	f8 4f       	sbci	r31, 0xF8	; 248
    64e6:	fc 83       	std	Y+4, r31	; 0x04
    64e8:	eb 83       	std	Y+3, r30	; 0x03
    64ea:	ff ef       	ldi	r31, 0xFF	; 255
    64ec:	4f 2e       	mov	r4, r31
    64ee:	f6 e0       	ldi	r31, 0x06	; 6
    64f0:	5f 2e       	mov	r5, r31
    64f2:	48 0e       	add	r4, r24
    64f4:	59 1e       	adc	r5, r25
    64f6:	14 c0       	rjmp	.+40     	; 0x6520 <NextSlave+0xd2>
				MB_Master_MaxCycle[MB_N] = MB_Master_Cycle[MB_N];
			StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
		}
	while (SlaveSkip[MB_N] &((uint32_t)1<<CurrSlave[MB_N]) && ++i<SlaveQt);
    64f8:	ed 81       	ldd	r30, Y+5	; 0x05
    64fa:	fe 81       	ldd	r31, Y+6	; 0x06
    64fc:	20 81       	ld	r18, Z
    64fe:	d5 01       	movw	r26, r10
    6500:	c4 01       	movw	r24, r8
    6502:	02 2e       	mov	r0, r18
    6504:	04 c0       	rjmp	.+8      	; 0x650e <NextSlave+0xc0>
    6506:	b6 95       	lsr	r27
    6508:	a7 95       	ror	r26
    650a:	97 95       	ror	r25
    650c:	87 95       	ror	r24
    650e:	0a 94       	dec	r0
    6510:	d2 f7       	brpl	.-12     	; 0x6506 <NextSlave+0xb8>
    6512:	81 70       	andi	r24, 0x01	; 1
    6514:	90 70       	andi	r25, 0x00	; 0
    6516:	88 23       	and	r24, r24
    6518:	61 f1       	breq	.+88     	; 0x6572 <NextSlave+0x124>
    651a:	1f 5f       	subi	r17, 0xFF	; 255
    651c:	10 17       	cp	r17, r16
    651e:	48 f5       	brcc	.+82     	; 0x6572 <NextSlave+0x124>
{
	uint8_t Over = 0;
	uint8_t i = 0;
	uint8_t SlaveQt = prb(&(MB_Master_List+MB_N)->SlaveQt);
	do
		if (++CurrSlave[MB_N]==SlaveQt) {
    6520:	82 2f       	mov	r24, r18
    6522:	8f 5f       	subi	r24, 0xFF	; 255
    6524:	ed 81       	ldd	r30, Y+5	; 0x05
    6526:	fe 81       	ldd	r31, Y+6	; 0x06
    6528:	80 83       	st	Z, r24
    652a:	80 17       	cp	r24, r16
    652c:	29 f7       	brne	.-54     	; 0x64f8 <NextSlave+0xaa>
			CurrSlave[MB_N] = 0;
    652e:	10 82       	st	Z, r1

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    6530:	8f b7       	in	r24, 0x3f	; 63
    6532:	80 78       	andi	r24, 0x80	; 128
    6534:	80 93 ee 02 	sts	0x02EE, r24
	cli();
    6538:	f8 94       	cli
    653a:	f7 01       	movw	r30, r14
    653c:	20 81       	ld	r18, Z
    653e:	31 81       	ldd	r19, Z+1	; 0x01

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    6540:	88 23       	and	r24, r24
    6542:	09 f0       	breq	.+2      	; 0x6546 <NextSlave+0xf8>
		sei();
    6544:	78 94       	sei
			Over = 1;

			if ((MB_Master_Cycle[MB_N]=0xFFFF-GetTimer16(TD_MB_Cycle+MB_N))>MB_Master_MaxCycle[MB_N])
    6546:	20 95       	com	r18
    6548:	30 95       	com	r19
    654a:	eb 81       	ldd	r30, Y+3	; 0x03
    654c:	fc 81       	ldd	r31, Y+4	; 0x04
    654e:	31 83       	std	Z+1, r19	; 0x01
    6550:	20 83       	st	Z, r18
    6552:	f2 01       	movw	r30, r4
    6554:	80 81       	ld	r24, Z
    6556:	91 81       	ldd	r25, Z+1	; 0x01
    6558:	82 17       	cp	r24, r18
    655a:	93 07       	cpc	r25, r19
    655c:	10 f4       	brcc	.+4      	; 0x6562 <NextSlave+0x114>
				MB_Master_MaxCycle[MB_N] = MB_Master_Cycle[MB_N];
    655e:	31 83       	std	Z+1, r19	; 0x01
    6560:	20 83       	st	Z, r18
			StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
    6562:	8a 81       	ldd	r24, Y+2	; 0x02
    6564:	6f ef       	ldi	r22, 0xFF	; 255
    6566:	7f ef       	ldi	r23, 0xFF	; 255
    6568:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
    656c:	f1 e0       	ldi	r31, 0x01	; 1
    656e:	f9 83       	std	Y+1, r31	; 0x01
    6570:	c3 cf       	rjmp	.-122    	; 0x64f8 <NextSlave+0xaa>
		}
	while (SlaveSkip[MB_N] &((uint32_t)1<<CurrSlave[MB_N]) && ++i<SlaveQt);
	if (i==SlaveQt) {
    6572:	10 17       	cp	r17, r16
    6574:	01 f1       	breq	.+64     	; 0x65b6 <NextSlave+0x168>
		SlavesOn(MB_N);
		if (++CurrSlave[MB_N]==SlaveQt)
			CurrSlave[MB_N] = 0;
	}
	CurrQuery[MB_N] = 0;
    6576:	45 e5       	ldi	r20, 0x55	; 85
    6578:	56 e0       	ldi	r21, 0x06	; 6
    657a:	c4 0e       	add	r12, r20
    657c:	d5 1e       	adc	r13, r21
    657e:	f6 01       	movw	r30, r12
    6580:	10 82       	st	Z, r1
	return Over;
}
    6582:	89 81       	ldd	r24, Y+1	; 0x01
    6584:	26 96       	adiw	r28, 0x06	; 6
    6586:	0f b6       	in	r0, 0x3f	; 63
    6588:	f8 94       	cli
    658a:	de bf       	out	0x3e, r29	; 62
    658c:	0f be       	out	0x3f, r0	; 63
    658e:	cd bf       	out	0x3d, r28	; 61
    6590:	cf 91       	pop	r28
    6592:	df 91       	pop	r29
    6594:	1f 91       	pop	r17
    6596:	0f 91       	pop	r16
    6598:	ff 90       	pop	r15
    659a:	ef 90       	pop	r14
    659c:	df 90       	pop	r13
    659e:	cf 90       	pop	r12
    65a0:	bf 90       	pop	r11
    65a2:	af 90       	pop	r10
    65a4:	9f 90       	pop	r9
    65a6:	8f 90       	pop	r8
    65a8:	7f 90       	pop	r7
    65aa:	6f 90       	pop	r6
    65ac:	5f 90       	pop	r5
    65ae:	4f 90       	pop	r4
    65b0:	3f 90       	pop	r3
    65b2:	2f 90       	pop	r2
    65b4:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~
static void
SlavesOn(uint8_t MB_N)
{
	SlaveSkip[MB_N] = 0;
    65b6:	44 ee       	ldi	r20, 0xE4	; 228
    65b8:	54 e0       	ldi	r21, 0x04	; 4
    65ba:	24 0e       	add	r2, r20
    65bc:	35 1e       	adc	r3, r21
    65be:	f1 01       	movw	r30, r2
    65c0:	10 82       	st	Z, r1
    65c2:	11 82       	std	Z+1, r1	; 0x01
    65c4:	12 82       	std	Z+2, r1	; 0x02
    65c6:	13 82       	std	Z+3, r1	; 0x03
	StartTimer16(TD_MB_SlaveOff+MB_N, 100*MB_M_TimeOff[MB_N]);
    65c8:	73 94       	inc	r7
    65ca:	f6 01       	movw	r30, r12
    65cc:	e1 52       	subi	r30, 0x21	; 33
    65ce:	fa 4f       	sbci	r31, 0xFA	; 250
    65d0:	60 81       	ld	r22, Z
    65d2:	84 e6       	ldi	r24, 0x64	; 100
    65d4:	68 9f       	mul	r22, r24
    65d6:	b0 01       	movw	r22, r0
    65d8:	11 24       	eor	r1, r1
    65da:	87 2d       	mov	r24, r7
    65dc:	86 0d       	add	r24, r6
    65de:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
			StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
		}
	while (SlaveSkip[MB_N] &((uint32_t)1<<CurrSlave[MB_N]) && ++i<SlaveQt);
	if (i==SlaveQt) {
		SlavesOn(MB_N);
		if (++CurrSlave[MB_N]==SlaveQt)
    65e2:	ed 81       	ldd	r30, Y+5	; 0x05
    65e4:	fe 81       	ldd	r31, Y+6	; 0x06
    65e6:	80 81       	ld	r24, Z
    65e8:	8f 5f       	subi	r24, 0xFF	; 255
    65ea:	80 83       	st	Z, r24
    65ec:	18 17       	cp	r17, r24
    65ee:	19 f6       	brne	.-122    	; 0x6576 <NextSlave+0x128>
			CurrSlave[MB_N] = 0;
    65f0:	10 82       	st	Z, r1
    65f2:	c1 cf       	rjmp	.-126    	; 0x6576 <NextSlave+0x128>

000065f4 <FailSlave>:
}

// ~~~~~~~~~~~~~~~~~~~~
static uint8_t
FailSlave(uint8_t MB_N)
{
    65f4:	ef 92       	push	r14
    65f6:	ff 92       	push	r15
    65f8:	1f 93       	push	r17
    65fa:	cf 93       	push	r28
    65fc:	df 93       	push	r29
    65fe:	18 2f       	mov	r17, r24
	uint8_t Over = 0;
	if (MB_SingleState[MB_N]==MB_SingleExec)
    6600:	68 2f       	mov	r22, r24
    6602:	70 e0       	ldi	r23, 0x00	; 0
    6604:	fb 01       	movw	r30, r22
    6606:	e1 55       	subi	r30, 0x51	; 81
    6608:	f9 4f       	sbci	r31, 0xF9	; 249
    660a:	80 81       	ld	r24, Z
    660c:	82 30       	cpi	r24, 0x02	; 2
    660e:	19 f1       	breq	.+70     	; 0x6656 <FailSlave+0x62>
		MB_SingleState[MB_N] = MB_SingleIdle;
	else{
		MB_CPT[MB_N][4]++;	// -    
    6610:	fb 01       	movw	r30, r22
    6612:	ee 0f       	add	r30, r30
    6614:	ff 1f       	adc	r31, r31
    6616:	ee 0f       	add	r30, r30
    6618:	ff 1f       	adc	r31, r31
    661a:	ee 0f       	add	r30, r30
    661c:	ff 1f       	adc	r31, r31
    661e:	ee 0f       	add	r30, r30
    6620:	ff 1f       	adc	r31, r31
    6622:	e3 5c       	subi	r30, 0xC3	; 195
    6624:	f6 4f       	sbci	r31, 0xF6	; 246
    6626:	80 81       	ld	r24, Z
    6628:	91 81       	ldd	r25, Z+1	; 0x01
    662a:	01 96       	adiw	r24, 0x01	; 1
    662c:	91 83       	std	Z+1, r25	; 0x01
    662e:	80 83       	st	Z, r24
		if (++Try[MB_N]==MB_M_Try[MB_N]) {
    6630:	eb 01       	movw	r28, r22
    6632:	cd 51       	subi	r28, 0x1D	; 29
    6634:	db 4f       	sbci	r29, 0xFB	; 251
    6636:	88 81       	ld	r24, Y
    6638:	8f 5f       	subi	r24, 0xFF	; 255
    663a:	88 83       	st	Y, r24
    663c:	fb 01       	movw	r30, r22
    663e:	e1 5c       	subi	r30, 0xC1	; 193
    6640:	f8 4f       	sbci	r31, 0xF8	; 248
    6642:	90 81       	ld	r25, Z
    6644:	89 17       	cp	r24, r25
    6646:	79 f0       	breq	.+30     	; 0x6666 <FailSlave+0x72>
    6648:	80 e0       	ldi	r24, 0x00	; 0
			Try[MB_N] = 0;
			Over = NextSlave(MB_N);
		}
	}
	return Over;
}
    664a:	df 91       	pop	r29
    664c:	cf 91       	pop	r28
    664e:	1f 91       	pop	r17
    6650:	ff 90       	pop	r15
    6652:	ef 90       	pop	r14
    6654:	08 95       	ret
static uint8_t
FailSlave(uint8_t MB_N)
{
	uint8_t Over = 0;
	if (MB_SingleState[MB_N]==MB_SingleExec)
		MB_SingleState[MB_N] = MB_SingleIdle;
    6656:	10 82       	st	Z, r1
    6658:	80 e0       	ldi	r24, 0x00	; 0
			Try[MB_N] = 0;
			Over = NextSlave(MB_N);
		}
	}
	return Over;
}
    665a:	df 91       	pop	r29
    665c:	cf 91       	pop	r28
    665e:	1f 91       	pop	r17
    6660:	ff 90       	pop	r15
    6662:	ef 90       	pop	r14
    6664:	08 95       	ret
	if (MB_SingleState[MB_N]==MB_SingleExec)
		MB_SingleState[MB_N] = MB_SingleIdle;
	else{
		MB_CPT[MB_N][4]++;	// -    
		if (++Try[MB_N]==MB_M_Try[MB_N]) {
			uint32_t S_N = (uint32_t)1<<CurrSlave[MB_N];
    6666:	fb 01       	movw	r30, r22
    6668:	ec 5a       	subi	r30, 0xAC	; 172
    666a:	f9 4f       	sbci	r31, 0xF9	; 249
    666c:	21 e0       	ldi	r18, 0x01	; 1
    666e:	30 e0       	ldi	r19, 0x00	; 0
    6670:	40 e0       	ldi	r20, 0x00	; 0
    6672:	50 e0       	ldi	r21, 0x00	; 0
    6674:	00 80       	ld	r0, Z
    6676:	04 c0       	rjmp	.+8      	; 0x6680 <FailSlave+0x8c>
    6678:	22 0f       	add	r18, r18
    667a:	33 1f       	adc	r19, r19
    667c:	44 1f       	adc	r20, r20
    667e:	55 1f       	adc	r21, r21
    6680:	0a 94       	dec	r0
    6682:	d2 f7       	brpl	.-12     	; 0x6678 <FailSlave+0x84>
			SlaveOff[MB_N] |=S_N;
    6684:	7b 01       	movw	r14, r22
    6686:	ee 0c       	add	r14, r14
    6688:	ff 1c       	adc	r15, r15
    668a:	ee 0c       	add	r14, r14
    668c:	ff 1c       	adc	r15, r15
    668e:	b7 01       	movw	r22, r14
    6690:	64 5d       	subi	r22, 0xD4	; 212
    6692:	76 4f       	sbci	r23, 0xF6	; 246
    6694:	fb 01       	movw	r30, r22
    6696:	80 81       	ld	r24, Z
    6698:	91 81       	ldd	r25, Z+1	; 0x01
    669a:	a2 81       	ldd	r26, Z+2	; 0x02
    669c:	b3 81       	ldd	r27, Z+3	; 0x03
    669e:	82 2b       	or	r24, r18
    66a0:	93 2b       	or	r25, r19
    66a2:	a4 2b       	or	r26, r20
    66a4:	b5 2b       	or	r27, r21
    66a6:	80 83       	st	Z, r24
    66a8:	91 83       	std	Z+1, r25	; 0x01
    66aa:	a2 83       	std	Z+2, r26	; 0x02
    66ac:	b3 83       	std	Z+3, r27	; 0x03
			SlaveSkip[MB_N] |=S_N;
    66ae:	f7 01       	movw	r30, r14
    66b0:	ec 51       	subi	r30, 0x1C	; 28
    66b2:	fb 4f       	sbci	r31, 0xFB	; 251
    66b4:	80 81       	ld	r24, Z
    66b6:	91 81       	ldd	r25, Z+1	; 0x01
    66b8:	a2 81       	ldd	r26, Z+2	; 0x02
    66ba:	b3 81       	ldd	r27, Z+3	; 0x03
    66bc:	28 2b       	or	r18, r24
    66be:	39 2b       	or	r19, r25
    66c0:	4a 2b       	or	r20, r26
    66c2:	5b 2b       	or	r21, r27
    66c4:	20 83       	st	Z, r18
    66c6:	31 83       	std	Z+1, r19	; 0x01
    66c8:	42 83       	std	Z+2, r20	; 0x02
    66ca:	53 83       	std	Z+3, r21	; 0x03
			Try[MB_N] = 0;
    66cc:	18 82       	st	Y, r1
			Over = NextSlave(MB_N);
    66ce:	81 2f       	mov	r24, r17
    66d0:	0e 94 27 32 	call	0x644e	; 0x644e <NextSlave>
		}
	}
	return Over;
}
    66d4:	df 91       	pop	r29
    66d6:	cf 91       	pop	r28
    66d8:	1f 91       	pop	r17
    66da:	ff 90       	pop	r15
    66dc:	ef 90       	pop	r14
    66de:	08 95       	ret

000066e0 <MB_M_Timer_ISR>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_M_Timer_ISR(uint8_t MB_N)
{
    66e0:	4f 92       	push	r4
    66e2:	5f 92       	push	r5
    66e4:	6f 92       	push	r6
    66e6:	7f 92       	push	r7
    66e8:	8f 92       	push	r8
    66ea:	9f 92       	push	r9
    66ec:	af 92       	push	r10
    66ee:	bf 92       	push	r11
    66f0:	cf 92       	push	r12
    66f2:	df 92       	push	r13
    66f4:	ef 92       	push	r14
    66f6:	ff 92       	push	r15
    66f8:	0f 93       	push	r16
    66fa:	1f 93       	push	r17
    66fc:	cf 93       	push	r28
    66fe:	df 93       	push	r29
    6700:	18 2f       	mov	r17, r24
	switch (MB_State[MB_N]) {
    6702:	c8 2f       	mov	r28, r24
    6704:	d0 e0       	ldi	r29, 0x00	; 0
    6706:	fe 01       	movw	r30, r28
    6708:	ee 53       	subi	r30, 0x3E	; 62
    670a:	fa 4f       	sbci	r31, 0xFA	; 250
    670c:	80 81       	ld	r24, Z
    670e:	88 23       	and	r24, r24
    6710:	f9 f4       	brne	.+62     	; 0x6750 <MB_M_Timer_ISR+0x70>
	case MB_Initi:
		StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
    6712:	80 91 e8 04 	lds	r24, 0x04E8
    6716:	8e 5f       	subi	r24, 0xFE	; 254
    6718:	81 0f       	add	r24, r17
    671a:	6f ef       	ldi	r22, 0xFF	; 255
    671c:	7f ef       	ldi	r23, 0xFF	; 255
    671e:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
		FormQuery(MB_N);
    6722:	81 2f       	mov	r24, r17
    6724:	0e 94 93 31 	call	0x6326	; 0x6326 <FormQuery>
		MB_Transm(MB_N);
    6728:	81 2f       	mov	r24, r17
    672a:	0e 94 8b 2a 	call	0x5516	; 0x5516 <MB_Transm>
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
		MB_M_CtrlProc(MB_N);
		break;
	}
}
    672e:	df 91       	pop	r29
    6730:	cf 91       	pop	r28
    6732:	1f 91       	pop	r17
    6734:	0f 91       	pop	r16
    6736:	ff 90       	pop	r15
    6738:	ef 90       	pop	r14
    673a:	df 90       	pop	r13
    673c:	cf 90       	pop	r12
    673e:	bf 90       	pop	r11
    6740:	af 90       	pop	r10
    6742:	9f 90       	pop	r9
    6744:	8f 90       	pop	r8
    6746:	7f 90       	pop	r7
    6748:	6f 90       	pop	r6
    674a:	5f 90       	pop	r5
    674c:	4f 90       	pop	r4
    674e:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_M_Timer_ISR(uint8_t MB_N)
{
	switch (MB_State[MB_N]) {
    6750:	82 30       	cpi	r24, 0x02	; 2
    6752:	69 f7       	brne	.-38     	; 0x672e <MB_M_Timer_ISR+0x4e>
		StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
		FormQuery(MB_N);
		MB_Transm(MB_N);
		break;
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
    6754:	84 e0       	ldi	r24, 0x04	; 4
    6756:	80 83       	st	Z, r24
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
MB_M_CtrlProc(uint8_t MB_N)
{
	uint8_t Over = 0;
	LastProcSingle = MB_SingleState[MB_N]==MB_SingleExec;
    6758:	ef ea       	ldi	r30, 0xAF	; 175
    675a:	ae 2e       	mov	r10, r30
    675c:	e6 e0       	ldi	r30, 0x06	; 6
    675e:	be 2e       	mov	r11, r30
    6760:	ac 0e       	add	r10, r28
    6762:	bd 1e       	adc	r11, r29
    6764:	d5 01       	movw	r26, r10
    6766:	8c 91       	ld	r24, X
    6768:	90 e0       	ldi	r25, 0x00	; 0
    676a:	82 30       	cpi	r24, 0x02	; 2
    676c:	09 f4       	brne	.+2      	; 0x6770 <MB_M_Timer_ISR+0x90>
    676e:	4e c0       	rjmp	.+156    	; 0x680c <MB_M_Timer_ISR+0x12c>
    6770:	90 93 e2 04 	sts	0x04E2, r25
	if (CommErr(MB_N))
    6774:	81 2f       	mov	r24, r17
    6776:	0e 94 6f 2b 	call	0x56de	; 0x56de <CommErr>
    677a:	88 23       	and	r24, r24
    677c:	91 f5       	brne	.+100    	; 0x67e2 <MB_M_Timer_ISR+0x102>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    677e:	7e 01       	movw	r14, r28
    6780:	ee 0c       	add	r14, r14
    6782:	ff 1c       	adc	r15, r15
    6784:	ee 0c       	add	r14, r14
    6786:	ff 1c       	adc	r15, r15
    6788:	c7 01       	movw	r24, r14
    678a:	88 0f       	add	r24, r24
    678c:	99 1f       	adc	r25, r25
    678e:	88 0f       	add	r24, r24
    6790:	99 1f       	adc	r25, r25
    6792:	8e 0d       	add	r24, r14
    6794:	9f 1d       	adc	r25, r15
    6796:	82 56       	subi	r24, 0x62	; 98
    6798:	90 4d       	sbci	r25, 0xD0	; 208
    679a:	fc 01       	movw	r30, r24
    679c:	25 91       	lpm	r18, Z+
    679e:	34 91       	lpm	r19, Z+
		Over = FailSlave(MB_N);
	else {
		USART_Func(MB_N, LED);
    67a0:	f9 01       	movw	r30, r18
    67a2:	19 95       	eicall
		MB_Slave *Slave;
		MB_Query *Query;
		uint8_t Addr, Func;
		if (LastProcSingle) {
    67a4:	80 91 e2 04 	lds	r24, 0x04E2
    67a8:	88 23       	and	r24, r24
    67aa:	91 f1       	breq	.+100    	; 0x6810 <MB_M_Timer_ISR+0x130>
			Addr = MB_SingleQuery[MB_N].Addr;
    67ac:	fe 01       	movw	r30, r28
    67ae:	ee 0f       	add	r30, r30
    67b0:	ff 1f       	adc	r31, r31
    67b2:	ee 0f       	add	r30, r30
    67b4:	ff 1f       	adc	r31, r31
    67b6:	ee 0f       	add	r30, r30
    67b8:	ff 1f       	adc	r31, r31
    67ba:	e6 52       	subi	r30, 0x26	; 38
    67bc:	fb 4f       	sbci	r31, 0xFB	; 251
    67be:	20 81       	ld	r18, Z
			Func = MB_SingleQuery[MB_N].Func;
    67c0:	91 81       	ldd	r25, Z+1	; 0x01
    67c2:	40 e0       	ldi	r20, 0x00	; 0
    67c4:	50 e0       	ldi	r21, 0x00	; 0
    67c6:	60 e0       	ldi	r22, 0x00	; 0
    67c8:	70 e0       	ldi	r23, 0x00	; 0
			Slave = GetSlave(MB_N);
			Query = (MB_Query*)prp(&Slave->QueryList)+CurrQuery[MB_N];
			Addr = prb(&Slave->Addr);
			Func = prb(&Query->Func);
		}
		if (MB_Frame[MB_N][0]!=Addr || MB_Frame[MB_N][1]!=Func)
    67ca:	dc 2e       	mov	r13, r28
    67cc:	cc 24       	eor	r12, r12
    67ce:	f6 01       	movw	r30, r12
    67d0:	e6 59       	subi	r30, 0x96	; 150
    67d2:	f4 4f       	sbci	r31, 0xF4	; 244
    67d4:	80 81       	ld	r24, Z
    67d6:	82 17       	cp	r24, r18
    67d8:	21 f4       	brne	.+8      	; 0x67e2 <MB_M_Timer_ISR+0x102>
    67da:	a1 81       	ldd	r26, Z+1	; 0x01
    67dc:	a9 17       	cp	r26, r25
    67de:	09 f4       	brne	.+2      	; 0x67e2 <MB_M_Timer_ISR+0x102>
    67e0:	3d c0       	rjmp	.+122    	; 0x685c <MB_M_Timer_ISR+0x17c>
				Err = MB_M_Force(MB_N, Query);
				break;
			}
			if (Err) {
				MB_CPT[MB_N][2]++;
				Over = FailSlave(MB_N);
    67e2:	81 2f       	mov	r24, r17
    67e4:	0e 94 fa 32 	call	0x65f4	; 0x65f4 <FailSlave>
    67e8:	98 2f       	mov	r25, r24
			}
		}
		/*if (Over)
			USART_Func(MB_N, LED);*/
	}
	StartTimer16(TD_MB_Idle+MB_N, Over?MB_M_Period[MB_N]:MB_M_Pause_Min);
    67ea:	80 91 e8 04 	lds	r24, 0x04E8
    67ee:	81 0f       	add	r24, r17
    67f0:	99 23       	and	r25, r25
    67f2:	49 f0       	breq	.+18     	; 0x6806 <MB_M_Timer_ISR+0x126>
    67f4:	cc 0f       	add	r28, r28
    67f6:	dd 1f       	adc	r29, r29
    67f8:	c3 55       	subi	r28, 0x53	; 83
    67fa:	d9 4f       	sbci	r29, 0xF9	; 249
    67fc:	68 81       	ld	r22, Y
    67fe:	79 81       	ldd	r23, Y+1	; 0x01
    6800:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
    6804:	94 cf       	rjmp	.-216    	; 0x672e <MB_M_Timer_ISR+0x4e>
    6806:	65 e0       	ldi	r22, 0x05	; 5
    6808:	70 e0       	ldi	r23, 0x00	; 0
    680a:	fa cf       	rjmp	.-12     	; 0x6800 <MB_M_Timer_ISR+0x120>
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
MB_M_CtrlProc(uint8_t MB_N)
{
	uint8_t Over = 0;
	LastProcSingle = MB_SingleState[MB_N]==MB_SingleExec;
    680c:	91 e0       	ldi	r25, 0x01	; 1
    680e:	b0 cf       	rjmp	.-160    	; 0x6770 <MB_M_Timer_ISR+0x90>
    6810:	83 e0       	ldi	r24, 0x03	; 3
    6812:	18 9f       	mul	r17, r24
    6814:	f0 01       	movw	r30, r0
    6816:	11 24       	eor	r1, r1
    6818:	e5 5b       	subi	r30, 0xB5	; 181
    681a:	f6 4d       	sbci	r31, 0xD6	; 214
    681c:	65 91       	lpm	r22, Z+
    681e:	74 91       	lpm	r23, Z+

// ~~~~~~~~~~~~~~~~~~~
static MB_Slave*
GetSlave(uint8_t MB_N)
{
	return (MB_Slave*)prp(&(MB_Master_List+MB_N)->SlaveList)+CurrSlave[MB_N];
    6820:	fe 01       	movw	r30, r28
    6822:	ec 5a       	subi	r30, 0xAC	; 172
    6824:	f9 4f       	sbci	r31, 0xF9	; 249
    6826:	80 81       	ld	r24, Z
    6828:	90 e0       	ldi	r25, 0x00	; 0
    682a:	88 0f       	add	r24, r24
    682c:	99 1f       	adc	r25, r25
    682e:	88 0f       	add	r24, r24
    6830:	99 1f       	adc	r25, r25
    6832:	68 0f       	add	r22, r24
    6834:	79 1f       	adc	r23, r25
    6836:	fb 01       	movw	r30, r22
    6838:	31 96       	adiw	r30, 0x01	; 1
    683a:	45 91       	lpm	r20, Z+
    683c:	54 91       	lpm	r21, Z+
			Addr = MB_SingleQuery[MB_N].Addr;
			Func = MB_SingleQuery[MB_N].Func;
		}
		else {
			Slave = GetSlave(MB_N);
			Query = (MB_Query*)prp(&Slave->QueryList)+CurrQuery[MB_N];
    683e:	fe 01       	movw	r30, r28
    6840:	eb 5a       	subi	r30, 0xAB	; 171
    6842:	f9 4f       	sbci	r31, 0xF9	; 249
    6844:	80 81       	ld	r24, Z
    6846:	27 e0       	ldi	r18, 0x07	; 7
    6848:	82 9f       	mul	r24, r18
    684a:	c0 01       	movw	r24, r0
    684c:	11 24       	eor	r1, r1
    684e:	48 0f       	add	r20, r24
    6850:	59 1f       	adc	r21, r25

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    6852:	fb 01       	movw	r30, r22
    6854:	24 91       	lpm	r18, Z+
		}
		if (MB_Frame[MB_N][0]!=Addr || MB_Frame[MB_N][1]!=Func)
			Over = FailSlave(MB_N);
		else {
			uint8_t Err;
			switch (Func) {
    6856:	fa 01       	movw	r30, r20
    6858:	94 91       	lpm	r25, Z+
    685a:	b7 cf       	rjmp	.-146    	; 0x67ca <MB_M_Timer_ISR+0xea>
    685c:	95 30       	cpi	r25, 0x05	; 5
    685e:	18 f5       	brcc	.+70     	; 0x68a6 <MB_M_Timer_ISR+0x1c6>
    6860:	93 30       	cpi	r25, 0x03	; 3
    6862:	08 f4       	brcc	.+2      	; 0x6866 <MB_M_Timer_ISR+0x186>
    6864:	ad c0       	rjmp	.+346    	; 0x69c0 <MB_M_Timer_ISR+0x2e0>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_M_ReadReg(uint8_t MB_N, MB_Query *Query)
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || (LastProcSingle?MB_SingleQuery[MB_N].Qt:prw(&Query->Qt))*2!=MB_Frame[MB_N][2])
    6866:	fc 2f       	mov	r31, r28
    6868:	ee 27       	eor	r30, r30
    686a:	e4 59       	subi	r30, 0x94	; 148
    686c:	f4 4f       	sbci	r31, 0xF4	; 244
    686e:	b0 81       	ld	r27, Z
    6870:	fe 01       	movw	r30, r28
    6872:	e7 5b       	subi	r30, 0xB7	; 183
    6874:	f8 4f       	sbci	r31, 0xF8	; 248
    6876:	80 81       	ld	r24, Z
    6878:	90 e0       	ldi	r25, 0x00	; 0
    687a:	8b 2e       	mov	r8, r27
    687c:	99 24       	eor	r9, r9
    687e:	94 01       	movw	r18, r8
    6880:	2b 5f       	subi	r18, 0xFB	; 251
    6882:	3f 4f       	sbci	r19, 0xFF	; 255
    6884:	82 17       	cp	r24, r18
    6886:	93 07       	cpc	r25, r19
    6888:	09 f4       	brne	.+2      	; 0x688c <MB_M_Timer_ISR+0x1ac>
    688a:	94 c1       	rjmp	.+808    	; 0x6bb4 <MB_M_Timer_ISR+0x4d4>
			case 0x0F: case 0x10:
				Err = MB_M_Force(MB_N, Query);
				break;
			}
			if (Err) {
				MB_CPT[MB_N][2]++;
    688c:	f7 01       	movw	r30, r14
    688e:	ee 0f       	add	r30, r30
    6890:	ff 1f       	adc	r31, r31
    6892:	ee 0f       	add	r30, r30
    6894:	ff 1f       	adc	r31, r31
    6896:	e7 5c       	subi	r30, 0xC7	; 199
    6898:	f6 4f       	sbci	r31, 0xF6	; 246
    689a:	80 81       	ld	r24, Z
    689c:	91 81       	ldd	r25, Z+1	; 0x01
    689e:	01 96       	adiw	r24, 0x01	; 1
    68a0:	91 83       	std	Z+1, r25	; 0x01
    68a2:	80 83       	st	Z, r24
    68a4:	9e cf       	rjmp	.-196    	; 0x67e2 <MB_M_Timer_ISR+0x102>
		}
		if (MB_Frame[MB_N][0]!=Addr || MB_Frame[MB_N][1]!=Func)
			Over = FailSlave(MB_N);
		else {
			uint8_t Err;
			switch (Func) {
    68a6:	96 30       	cpi	r25, 0x06	; 6
    68a8:	09 f4       	brne	.+2      	; 0x68ac <MB_M_Timer_ISR+0x1cc>
    68aa:	18 c1       	rjmp	.+560    	; 0x6adc <MB_M_Timer_ISR+0x3fc>
    68ac:	96 30       	cpi	r25, 0x06	; 6
    68ae:	08 f4       	brcc	.+2      	; 0x68b2 <MB_M_Timer_ISR+0x1d2>
    68b0:	43 c0       	rjmp	.+134    	; 0x6938 <MB_M_Timer_ISR+0x258>
    68b2:	9f 50       	subi	r25, 0x0F	; 15
    68b4:	92 30       	cpi	r25, 0x02	; 2
    68b6:	08 f0       	brcs	.+2      	; 0x68ba <MB_M_Timer_ISR+0x1da>
    68b8:	3f c0       	rjmp	.+126    	; 0x6938 <MB_M_Timer_ISR+0x258>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_M_Force(uint8_t MB_N, MB_Query *Query)
{
	uint16_t StartAddr, Qt;
	if (LastProcSingle) {
    68ba:	80 91 e2 04 	lds	r24, 0x04E2
    68be:	88 23       	and	r24, r24
    68c0:	09 f4       	brne	.+2      	; 0x68c4 <MB_M_Timer_ISR+0x1e4>
    68c2:	4e c1       	rjmp	.+668    	; 0x6b60 <MB_M_Timer_ISR+0x480>
		StartAddr	= MB_SingleQuery[MB_N].StartAddr;
    68c4:	f7 01       	movw	r30, r14
    68c6:	ee 0f       	add	r30, r30
    68c8:	ff 1f       	adc	r31, r31
    68ca:	e4 52       	subi	r30, 0x24	; 36
    68cc:	fb 4f       	sbci	r31, 0xFB	; 251
    68ce:	80 80       	ld	r8, Z
    68d0:	91 80       	ldd	r9, Z+1	; 0x01
		Qt				= MB_SingleQuery[MB_N].Qt;
    68d2:	fe 01       	movw	r30, r28
    68d4:	ee 0f       	add	r30, r30
    68d6:	ff 1f       	adc	r31, r31
    68d8:	ee 0f       	add	r30, r30
    68da:	ff 1f       	adc	r31, r31
    68dc:	ee 0f       	add	r30, r30
    68de:	ff 1f       	adc	r31, r31
    68e0:	e2 52       	subi	r30, 0x22	; 34
    68e2:	fb 4f       	sbci	r31, 0xFB	; 251
    68e4:	40 81       	ld	r20, Z
    68e6:	51 81       	ldd	r21, Z+1	; 0x01
	}
	else {
		StartAddr	= prw(&Query->StartAddr);
		Qt				= prw(&Query->Qt);
	}
	return MB_Frame_Sz[MB_N]!=8 || MB_FrameReg(MB_N, 2)!=StartAddr || MB_FrameReg(MB_N, 4)!=Qt;
    68e8:	fe 01       	movw	r30, r28
    68ea:	e7 5b       	subi	r30, 0xB7	; 183
    68ec:	f8 4f       	sbci	r31, 0xF8	; 248
    68ee:	80 81       	ld	r24, Z
    68f0:	88 30       	cpi	r24, 0x08	; 8
    68f2:	61 f6       	brne	.-104    	; 0x688c <MB_M_Timer_ISR+0x1ac>
    68f4:	fc 2f       	mov	r31, r28
    68f6:	ee 27       	eor	r30, r30
    68f8:	e4 59       	subi	r30, 0x94	; 148
    68fa:	f4 4f       	sbci	r31, 0xF4	; 244
    68fc:	30 81       	ld	r19, Z
    68fe:	20 e0       	ldi	r18, 0x00	; 0
    6900:	d6 01       	movw	r26, r12
    6902:	a6 59       	subi	r26, 0x96	; 150
    6904:	b4 4f       	sbci	r27, 0xF4	; 244
    6906:	13 96       	adiw	r26, 0x03	; 3
    6908:	8c 91       	ld	r24, X
    690a:	13 97       	sbiw	r26, 0x03	; 3
    690c:	90 e0       	ldi	r25, 0x00	; 0
    690e:	28 2b       	or	r18, r24
    6910:	39 2b       	or	r19, r25
    6912:	28 15       	cp	r18, r8
    6914:	39 05       	cpc	r19, r9
    6916:	09 f0       	breq	.+2      	; 0x691a <MB_M_Timer_ISR+0x23a>
    6918:	b9 cf       	rjmp	.-142    	; 0x688c <MB_M_Timer_ISR+0x1ac>
    691a:	fc 2f       	mov	r31, r28
    691c:	ee 27       	eor	r30, r30
    691e:	e2 59       	subi	r30, 0x92	; 146
    6920:	f4 4f       	sbci	r31, 0xF4	; 244
    6922:	90 81       	ld	r25, Z
    6924:	80 e0       	ldi	r24, 0x00	; 0
    6926:	15 96       	adiw	r26, 0x05	; 5
    6928:	2c 91       	ld	r18, X
    692a:	30 e0       	ldi	r19, 0x00	; 0
    692c:	82 2b       	or	r24, r18
    692e:	93 2b       	or	r25, r19
    6930:	84 17       	cp	r24, r20
    6932:	95 07       	cpc	r25, r21
    6934:	09 f0       	breq	.+2      	; 0x6938 <MB_M_Timer_ISR+0x258>
    6936:	aa cf       	rjmp	.-172    	; 0x688c <MB_M_Timer_ISR+0x1ac>
			}
			if (Err) {
				MB_CPT[MB_N][2]++;
				Over = FailSlave(MB_N);
			}
			else if (LastProcSingle)
    6938:	80 91 e2 04 	lds	r24, 0x04E2
    693c:	88 23       	and	r24, r24
    693e:	41 f0       	breq	.+16     	; 0x6950 <MB_M_Timer_ISR+0x270>
				MB_SingleState[MB_N] = MB_SingleIdle;
    6940:	d5 01       	movw	r26, r10
    6942:	1c 92       	st	X, r1
			}
		}
		/*if (Over)
			USART_Func(MB_N, LED);*/
	}
	StartTimer16(TD_MB_Idle+MB_N, Over?MB_M_Period[MB_N]:MB_M_Pause_Min);
    6944:	80 91 e8 04 	lds	r24, 0x04E8
    6948:	81 0f       	add	r24, r17
    694a:	65 e0       	ldi	r22, 0x05	; 5
    694c:	70 e0       	ldi	r23, 0x00	; 0
    694e:	58 cf       	rjmp	.-336    	; 0x6800 <MB_M_Timer_ISR+0x120>
				Over = FailSlave(MB_N);
			}
			else if (LastProcSingle)
				MB_SingleState[MB_N] = MB_SingleIdle;
			else {
				SlaveOff[MB_N] &=~((uint32_t)1<<CurrSlave[MB_N]);
    6950:	ec e2       	ldi	r30, 0x2C	; 44
    6952:	f9 e0       	ldi	r31, 0x09	; 9
    6954:	ee 0e       	add	r14, r30
    6956:	ff 1e       	adc	r15, r31
    6958:	9e 01       	movw	r18, r28
    695a:	2c 5a       	subi	r18, 0xAC	; 172
    695c:	39 4f       	sbci	r19, 0xF9	; 249
    695e:	81 e0       	ldi	r24, 0x01	; 1
    6960:	90 e0       	ldi	r25, 0x00	; 0
    6962:	a0 e0       	ldi	r26, 0x00	; 0
    6964:	b0 e0       	ldi	r27, 0x00	; 0
    6966:	f9 01       	movw	r30, r18
    6968:	00 80       	ld	r0, Z
    696a:	04 c0       	rjmp	.+8      	; 0x6974 <MB_M_Timer_ISR+0x294>
    696c:	88 0f       	add	r24, r24
    696e:	99 1f       	adc	r25, r25
    6970:	aa 1f       	adc	r26, r26
    6972:	bb 1f       	adc	r27, r27
    6974:	0a 94       	dec	r0
    6976:	d2 f7       	brpl	.-12     	; 0x696c <MB_M_Timer_ISR+0x28c>
    6978:	80 95       	com	r24
    697a:	90 95       	com	r25
    697c:	a0 95       	com	r26
    697e:	b0 95       	com	r27
    6980:	f7 01       	movw	r30, r14
    6982:	20 81       	ld	r18, Z
    6984:	31 81       	ldd	r19, Z+1	; 0x01
    6986:	42 81       	ldd	r20, Z+2	; 0x02
    6988:	53 81       	ldd	r21, Z+3	; 0x03
    698a:	82 23       	and	r24, r18
    698c:	93 23       	and	r25, r19
    698e:	a4 23       	and	r26, r20
    6990:	b5 23       	and	r27, r21
    6992:	80 83       	st	Z, r24
    6994:	91 83       	std	Z+1, r25	; 0x01
    6996:	a2 83       	std	Z+2, r26	; 0x02
    6998:	b3 83       	std	Z+3, r27	; 0x03
				if (++CurrQuery[MB_N]==prb(&Slave->QueryQt))
    699a:	fe 01       	movw	r30, r28
    699c:	eb 5a       	subi	r30, 0xAB	; 171
    699e:	f9 4f       	sbci	r31, 0xF9	; 249
    69a0:	80 81       	ld	r24, Z
    69a2:	8f 5f       	subi	r24, 0xFF	; 255
    69a4:	80 83       	st	Z, r24
    69a6:	6d 5f       	subi	r22, 0xFD	; 253
    69a8:	7f 4f       	sbci	r23, 0xFF	; 255
    69aa:	fb 01       	movw	r30, r22
    69ac:	94 91       	lpm	r25, Z+
    69ae:	89 17       	cp	r24, r25
    69b0:	09 f4       	brne	.+2      	; 0x69b4 <MB_M_Timer_ISR+0x2d4>
    69b2:	55 c1       	rjmp	.+682    	; 0x6c5e <MB_M_Timer_ISR+0x57e>
    69b4:	90 e0       	ldi	r25, 0x00	; 0
					Over = NextSlave(MB_N);
				Try[MB_N] = 0;
    69b6:	fe 01       	movw	r30, r28
    69b8:	ed 51       	subi	r30, 0x1D	; 29
    69ba:	fb 4f       	sbci	r31, 0xFB	; 251
    69bc:	10 82       	st	Z, r1
    69be:	15 cf       	rjmp	.-470    	; 0x67ea <MB_M_Timer_ISR+0x10a>
		}
		if (MB_Frame[MB_N][0]!=Addr || MB_Frame[MB_N][1]!=Func)
			Over = FailSlave(MB_N);
		else {
			uint8_t Err;
			switch (Func) {
    69c0:	91 30       	cpi	r25, 0x01	; 1
    69c2:	08 f4       	brcc	.+2      	; 0x69c6 <MB_M_Timer_ISR+0x2e6>
    69c4:	b9 cf       	rjmp	.-142    	; 0x6938 <MB_M_Timer_ISR+0x258>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_M_ReadDiscr(uint8_t MB_N, MB_Query *Query)
{
	uint8_t Qt = LastProcSingle ? MB_SingleQuery[MB_N].Qt : prb((uint8_t*)&Query->Qt);
    69c6:	80 91 e2 04 	lds	r24, 0x04E2
    69ca:	88 23       	and	r24, r24
    69cc:	09 f4       	brne	.+2      	; 0x69d0 <MB_M_Timer_ISR+0x2f0>
    69ce:	eb c0       	rjmp	.+470    	; 0x6ba6 <MB_M_Timer_ISR+0x4c6>
    69d0:	fe 01       	movw	r30, r28
    69d2:	ee 0f       	add	r30, r30
    69d4:	ff 1f       	adc	r31, r31
    69d6:	ee 0f       	add	r30, r30
    69d8:	ff 1f       	adc	r31, r31
    69da:	ee 0f       	add	r30, r30
    69dc:	ff 1f       	adc	r31, r31
    69de:	e2 52       	subi	r30, 0x22	; 34
    69e0:	fb 4f       	sbci	r31, 0xFB	; 251
    69e2:	b0 81       	ld	r27, Z
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || Qt/8+((Qt%8)>0)!=MB_Frame[MB_N][2])
    69e4:	fc 2f       	mov	r31, r28
    69e6:	ee 27       	eor	r30, r30
    69e8:	e4 59       	subi	r30, 0x94	; 148
    69ea:	f4 4f       	sbci	r31, 0xF4	; 244
    69ec:	80 81       	ld	r24, Z
    69ee:	88 2e       	mov	r8, r24
    69f0:	99 24       	eor	r9, r9
    69f2:	fe 01       	movw	r30, r28
    69f4:	e7 5b       	subi	r30, 0xB7	; 183
    69f6:	f8 4f       	sbci	r31, 0xF8	; 248
    69f8:	80 81       	ld	r24, Z
    69fa:	90 e0       	ldi	r25, 0x00	; 0
    69fc:	94 01       	movw	r18, r8
    69fe:	2b 5f       	subi	r18, 0xFB	; 251
    6a00:	3f 4f       	sbci	r19, 0xFF	; 255
    6a02:	82 17       	cp	r24, r18
    6a04:	93 07       	cpc	r25, r19
    6a06:	09 f0       	breq	.+2      	; 0x6a0a <MB_M_Timer_ISR+0x32a>
    6a08:	41 cf       	rjmp	.-382    	; 0x688c <MB_M_Timer_ISR+0x1ac>
    6a0a:	20 e0       	ldi	r18, 0x00	; 0
    6a0c:	30 e0       	ldi	r19, 0x00	; 0
    6a0e:	6b 2e       	mov	r6, r27
    6a10:	77 24       	eor	r7, r7
    6a12:	c3 01       	movw	r24, r6
    6a14:	87 70       	andi	r24, 0x07	; 7
    6a16:	90 70       	andi	r25, 0x00	; 0
    6a18:	18 16       	cp	r1, r24
    6a1a:	19 06       	cpc	r1, r25
    6a1c:	14 f4       	brge	.+4      	; 0x6a22 <MB_M_Timer_ISR+0x342>
    6a1e:	21 e0       	ldi	r18, 0x01	; 1
    6a20:	30 e0       	ldi	r19, 0x00	; 0
    6a22:	b6 95       	lsr	r27
    6a24:	b6 95       	lsr	r27
    6a26:	b6 95       	lsr	r27
    6a28:	2b 0f       	add	r18, r27
    6a2a:	31 1d       	adc	r19, r1
    6a2c:	82 16       	cp	r8, r18
    6a2e:	93 06       	cpc	r9, r19
    6a30:	09 f0       	breq	.+2      	; 0x6a34 <MB_M_Timer_ISR+0x354>
    6a32:	2c cf       	rjmp	.-424    	; 0x688c <MB_M_Timer_ISR+0x1ac>
		return 1;
	uint8_t *Discr;
	uint8_t Pin;
	if (LastProcSingle) {
    6a34:	80 91 e2 04 	lds	r24, 0x04E2
    6a38:	88 23       	and	r24, r24
    6a3a:	09 f4       	brne	.+2      	; 0x6a3e <MB_M_Timer_ISR+0x35e>
    6a3c:	1d c1       	rjmp	.+570    	; 0x6c78 <MB_M_Timer_ISR+0x598>
		Discr = MB_SingleQuery[MB_N].Buf;
    6a3e:	fe 01       	movw	r30, r28
    6a40:	ee 0f       	add	r30, r30
    6a42:	ff 1f       	adc	r31, r31
    6a44:	ee 0f       	add	r30, r30
    6a46:	ff 1f       	adc	r31, r31
    6a48:	ee 0f       	add	r30, r30
    6a4a:	ff 1f       	adc	r31, r31
    6a4c:	e6 52       	subi	r30, 0x26	; 38
    6a4e:	fb 4f       	sbci	r31, 0xFB	; 251
    6a50:	86 80       	ldd	r8, Z+6	; 0x06
    6a52:	97 80       	ldd	r9, Z+7	; 0x07
    6a54:	00 e0       	ldi	r16, 0x00	; 0
	}
	else {
		Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
		Pin = prw(&Query->AllocAddr);
	}
	for (uint16_t i=0; i<Qt; i++) {
    6a56:	61 14       	cp	r6, r1
    6a58:	71 04       	cpc	r7, r1
    6a5a:	09 f4       	brne	.+2      	; 0x6a5e <MB_M_Timer_ISR+0x37e>
    6a5c:	6d cf       	rjmp	.-294    	; 0x6938 <MB_M_Timer_ISR+0x258>
    6a5e:	40 e0       	ldi	r20, 0x00	; 0
    6a60:	50 e0       	ldi	r21, 0x00	; 0
		uint8_t j = Pin+i;
		uint8_t Byte=j/8, Bit=1<<j%8;
    6a62:	21 e0       	ldi	r18, 0x01	; 1
    6a64:	42 2e       	mov	r4, r18
    6a66:	51 2c       	mov	r5, r1
		if (MB_Frame[MB_N][3+i/8] &(1<<i%8))
    6a68:	8a e6       	ldi	r24, 0x6A	; 106
    6a6a:	9b e0       	ldi	r25, 0x0B	; 11
    6a6c:	c8 0e       	add	r12, r24
    6a6e:	d9 1e       	adc	r13, r25
    6a70:	0c c0       	rjmp	.+24     	; 0x6a8a <MB_M_Timer_ISR+0x3aa>
			Discr[Byte] |=Bit;
    6a72:	f4 01       	movw	r30, r8
    6a74:	eb 0f       	add	r30, r27
    6a76:	f1 1d       	adc	r31, r1
    6a78:	80 81       	ld	r24, Z
    6a7a:	8a 2b       	or	r24, r26
    6a7c:	80 83       	st	Z, r24
	}
	else {
		Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
		Pin = prw(&Query->AllocAddr);
	}
	for (uint16_t i=0; i<Qt; i++) {
    6a7e:	4f 5f       	subi	r20, 0xFF	; 255
    6a80:	5f 4f       	sbci	r21, 0xFF	; 255
    6a82:	46 15       	cp	r20, r6
    6a84:	57 05       	cpc	r21, r7
    6a86:	08 f0       	brcs	.+2      	; 0x6a8a <MB_M_Timer_ISR+0x3aa>
    6a88:	57 cf       	rjmp	.-338    	; 0x6938 <MB_M_Timer_ISR+0x258>
    6a8a:	80 2f       	mov	r24, r16
    6a8c:	84 0f       	add	r24, r20
		uint8_t j = Pin+i;
		uint8_t Byte=j/8, Bit=1<<j%8;
    6a8e:	b8 2f       	mov	r27, r24
    6a90:	b6 95       	lsr	r27
    6a92:	b6 95       	lsr	r27
    6a94:	b6 95       	lsr	r27
    6a96:	87 70       	andi	r24, 0x07	; 7
    6a98:	a4 2d       	mov	r26, r4
    6a9a:	01 c0       	rjmp	.+2      	; 0x6a9e <MB_M_Timer_ISR+0x3be>
    6a9c:	aa 0f       	add	r26, r26
    6a9e:	8a 95       	dec	r24
    6aa0:	ea f7       	brpl	.-6      	; 0x6a9c <MB_M_Timer_ISR+0x3bc>
		if (MB_Frame[MB_N][3+i/8] &(1<<i%8))
    6aa2:	fa 01       	movw	r30, r20
    6aa4:	f6 95       	lsr	r31
    6aa6:	e7 95       	ror	r30
    6aa8:	f6 95       	lsr	r31
    6aaa:	e7 95       	ror	r30
    6aac:	f6 95       	lsr	r31
    6aae:	e7 95       	ror	r30
    6ab0:	ec 0d       	add	r30, r12
    6ab2:	fd 1d       	adc	r31, r13
    6ab4:	83 81       	ldd	r24, Z+3	; 0x03
    6ab6:	90 e0       	ldi	r25, 0x00	; 0
    6ab8:	9a 01       	movw	r18, r20
    6aba:	27 70       	andi	r18, 0x07	; 7
    6abc:	30 70       	andi	r19, 0x00	; 0
    6abe:	02 c0       	rjmp	.+4      	; 0x6ac4 <MB_M_Timer_ISR+0x3e4>
    6ac0:	95 95       	asr	r25
    6ac2:	87 95       	ror	r24
    6ac4:	2a 95       	dec	r18
    6ac6:	e2 f7       	brpl	.-8      	; 0x6ac0 <MB_M_Timer_ISR+0x3e0>
    6ac8:	80 fd       	sbrc	r24, 0
    6aca:	d3 cf       	rjmp	.-90     	; 0x6a72 <MB_M_Timer_ISR+0x392>
			Discr[Byte] |=Bit;
		else
			Discr[Byte] &=~Bit;
    6acc:	f4 01       	movw	r30, r8
    6ace:	eb 0f       	add	r30, r27
    6ad0:	f1 1d       	adc	r31, r1
    6ad2:	a0 95       	com	r26
    6ad4:	80 81       	ld	r24, Z
    6ad6:	8a 23       	and	r24, r26
    6ad8:	80 83       	st	Z, r24
    6ada:	d1 cf       	rjmp	.-94     	; 0x6a7e <MB_M_Timer_ISR+0x39e>
inline static uint8_t
MB_M_PresetSingle(uint8_t MB_N, MB_Query *Query)
{
	uint16_t StartAddr;
	uint16_t *Reg;
	if (LastProcSingle) {
    6adc:	80 91 e2 04 	lds	r24, 0x04E2
    6ae0:	88 23       	and	r24, r24
    6ae2:	09 f4       	brne	.+2      	; 0x6ae6 <MB_M_Timer_ISR+0x406>
    6ae4:	46 c0       	rjmp	.+140    	; 0x6b72 <MB_M_Timer_ISR+0x492>
		StartAddr = MB_SingleQuery[MB_N].StartAddr;
    6ae6:	f7 01       	movw	r30, r14
    6ae8:	ee 0f       	add	r30, r30
    6aea:	ff 1f       	adc	r31, r31
    6aec:	e4 52       	subi	r30, 0x24	; 36
    6aee:	fb 4f       	sbci	r31, 0xFB	; 251
    6af0:	80 80       	ld	r8, Z
    6af2:	91 80       	ldd	r9, Z+1	; 0x01
		Reg = MB_SingleQuery[MB_N].Buf;
    6af4:	fe 01       	movw	r30, r28
    6af6:	ee 0f       	add	r30, r30
    6af8:	ff 1f       	adc	r31, r31
    6afa:	ee 0f       	add	r30, r30
    6afc:	ff 1f       	adc	r31, r31
    6afe:	ee 0f       	add	r30, r30
    6b00:	ff 1f       	adc	r31, r31
    6b02:	e6 52       	subi	r30, 0x26	; 38
    6b04:	fb 4f       	sbci	r31, 0xFB	; 251
    6b06:	a6 81       	ldd	r26, Z+6	; 0x06
    6b08:	b7 81       	ldd	r27, Z+7	; 0x07
	}
	else {
		StartAddr = prw(&Query->StartAddr);
		Reg = (uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+prw(&Query->AllocAddr);
	}
	return MB_Frame_Sz[MB_N]!=8 || MB_FrameReg(MB_N, 2)!=StartAddr || MB_FrameReg(MB_N, 4)!=*Reg;
    6b0a:	fe 01       	movw	r30, r28
    6b0c:	e7 5b       	subi	r30, 0xB7	; 183
    6b0e:	f8 4f       	sbci	r31, 0xF8	; 248
    6b10:	80 81       	ld	r24, Z
    6b12:	88 30       	cpi	r24, 0x08	; 8
    6b14:	09 f0       	breq	.+2      	; 0x6b18 <MB_M_Timer_ISR+0x438>
    6b16:	ba ce       	rjmp	.-652    	; 0x688c <MB_M_Timer_ISR+0x1ac>
    6b18:	fc 2f       	mov	r31, r28
    6b1a:	ee 27       	eor	r30, r30
    6b1c:	e4 59       	subi	r30, 0x94	; 148
    6b1e:	f4 4f       	sbci	r31, 0xF4	; 244
    6b20:	30 81       	ld	r19, Z
    6b22:	20 e0       	ldi	r18, 0x00	; 0
    6b24:	a6 01       	movw	r20, r12
    6b26:	46 59       	subi	r20, 0x96	; 150
    6b28:	54 4f       	sbci	r21, 0xF4	; 244
    6b2a:	fa 01       	movw	r30, r20
    6b2c:	83 81       	ldd	r24, Z+3	; 0x03
    6b2e:	90 e0       	ldi	r25, 0x00	; 0
    6b30:	28 2b       	or	r18, r24
    6b32:	39 2b       	or	r19, r25
    6b34:	28 15       	cp	r18, r8
    6b36:	39 05       	cpc	r19, r9
    6b38:	09 f0       	breq	.+2      	; 0x6b3c <MB_M_Timer_ISR+0x45c>
    6b3a:	a8 ce       	rjmp	.-688    	; 0x688c <MB_M_Timer_ISR+0x1ac>
    6b3c:	fc 2f       	mov	r31, r28
    6b3e:	ee 27       	eor	r30, r30
    6b40:	e2 59       	subi	r30, 0x92	; 146
    6b42:	f4 4f       	sbci	r31, 0xF4	; 244
    6b44:	30 81       	ld	r19, Z
    6b46:	20 e0       	ldi	r18, 0x00	; 0
    6b48:	fa 01       	movw	r30, r20
    6b4a:	85 81       	ldd	r24, Z+5	; 0x05
    6b4c:	90 e0       	ldi	r25, 0x00	; 0
    6b4e:	28 2b       	or	r18, r24
    6b50:	39 2b       	or	r19, r25
    6b52:	8d 91       	ld	r24, X+
    6b54:	9c 91       	ld	r25, X
    6b56:	28 17       	cp	r18, r24
    6b58:	39 07       	cpc	r19, r25
    6b5a:	09 f0       	breq	.+2      	; 0x6b5e <MB_M_Timer_ISR+0x47e>
    6b5c:	97 ce       	rjmp	.-722    	; 0x688c <MB_M_Timer_ISR+0x1ac>
    6b5e:	ec ce       	rjmp	.-552    	; 0x6938 <MB_M_Timer_ISR+0x258>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    6b60:	fa 01       	movw	r30, r20
    6b62:	31 96       	adiw	r30, 0x01	; 1
    6b64:	85 90       	lpm	r8, Z+
    6b66:	94 90       	lpm	r9, Z+

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6b68:	fa 01       	movw	r30, r20
    6b6a:	33 96       	adiw	r30, 0x03	; 3
    6b6c:	45 91       	lpm	r20, Z+
    6b6e:	54 91       	lpm	r21, Z+
    6b70:	bb ce       	rjmp	.-650    	; 0x68e8 <MB_M_Timer_ISR+0x208>
    6b72:	fa 01       	movw	r30, r20
    6b74:	31 96       	adiw	r30, 0x01	; 1
    6b76:	85 90       	lpm	r8, Z+
    6b78:	94 90       	lpm	r9, Z+
    6b7a:	fe 01       	movw	r30, r28
    6b7c:	ee 0f       	add	r30, r30
    6b7e:	ff 1f       	adc	r31, r31
    6b80:	ee 0f       	add	r30, r30
    6b82:	ff 1f       	adc	r31, r31
    6b84:	ee 0f       	add	r30, r30
    6b86:	ff 1f       	adc	r31, r31
    6b88:	ee 0f       	add	r30, r30
    6b8a:	ff 1f       	adc	r31, r31
    6b8c:	e8 5c       	subi	r30, 0xC8	; 200
    6b8e:	fc 4f       	sbci	r31, 0xFC	; 252
    6b90:	a5 91       	lpm	r26, Z+
    6b92:	b4 91       	lpm	r27, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    6b94:	fa 01       	movw	r30, r20
    6b96:	35 96       	adiw	r30, 0x05	; 5
    6b98:	85 91       	lpm	r24, Z+
    6b9a:	94 91       	lpm	r25, Z+
		StartAddr = MB_SingleQuery[MB_N].StartAddr;
		Reg = MB_SingleQuery[MB_N].Buf;
	}
	else {
		StartAddr = prw(&Query->StartAddr);
		Reg = (uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+prw(&Query->AllocAddr);
    6b9c:	88 0f       	add	r24, r24
    6b9e:	99 1f       	adc	r25, r25
    6ba0:	a8 0f       	add	r26, r24
    6ba2:	b9 1f       	adc	r27, r25
    6ba4:	b2 cf       	rjmp	.-156    	; 0x6b0a <MB_M_Timer_ISR+0x42a>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    6ba6:	4d 5f       	subi	r20, 0xFD	; 253
    6ba8:	5f 4f       	sbci	r21, 0xFF	; 255
    6baa:	fa 01       	movw	r30, r20
    6bac:	b4 91       	lpm	r27, Z+
    6bae:	43 50       	subi	r20, 0x03	; 3
    6bb0:	50 40       	sbci	r21, 0x00	; 0
    6bb2:	18 cf       	rjmp	.-464    	; 0x69e4 <MB_M_Timer_ISR+0x304>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_M_ReadReg(uint8_t MB_N, MB_Query *Query)
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || (LastProcSingle?MB_SingleQuery[MB_N].Qt:prw(&Query->Qt))*2!=MB_Frame[MB_N][2])
    6bb4:	80 91 e2 04 	lds	r24, 0x04E2
    6bb8:	88 23       	and	r24, r24
    6bba:	09 f4       	brne	.+2      	; 0x6bbe <MB_M_Timer_ISR+0x4de>
    6bbc:	55 c0       	rjmp	.+170    	; 0x6c68 <MB_M_Timer_ISR+0x588>
    6bbe:	fe 01       	movw	r30, r28
    6bc0:	ee 0f       	add	r30, r30
    6bc2:	ff 1f       	adc	r31, r31
    6bc4:	ee 0f       	add	r30, r30
    6bc6:	ff 1f       	adc	r31, r31
    6bc8:	ee 0f       	add	r30, r30
    6bca:	ff 1f       	adc	r31, r31
    6bcc:	e2 52       	subi	r30, 0x22	; 34
    6bce:	fb 4f       	sbci	r31, 0xFB	; 251
    6bd0:	20 81       	ld	r18, Z
    6bd2:	31 81       	ldd	r19, Z+1	; 0x01
    6bd4:	22 0f       	add	r18, r18
    6bd6:	33 1f       	adc	r19, r19
    6bd8:	82 16       	cp	r8, r18
    6bda:	93 06       	cpc	r9, r19
    6bdc:	09 f0       	breq	.+2      	; 0x6be0 <MB_M_Timer_ISR+0x500>
    6bde:	56 ce       	rjmp	.-852    	; 0x688c <MB_M_Timer_ISR+0x1ac>
		return 1;
	uint16_t *Reg = LastProcSingle ?
		MB_SingleQuery[MB_N].Buf
	:
		(uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg))+prw(&Query->AllocAddr);
    6be0:	80 91 e2 04 	lds	r24, 0x04E2
    6be4:	88 23       	and	r24, r24
    6be6:	09 f4       	brne	.+2      	; 0x6bea <MB_M_Timer_ISR+0x50a>
    6be8:	5e c0       	rjmp	.+188    	; 0x6ca6 <MB_M_Timer_ISR+0x5c6>
    6bea:	fe 01       	movw	r30, r28
    6bec:	ee 0f       	add	r30, r30
    6bee:	ff 1f       	adc	r31, r31
    6bf0:	ee 0f       	add	r30, r30
    6bf2:	ff 1f       	adc	r31, r31
    6bf4:	ee 0f       	add	r30, r30
    6bf6:	ff 1f       	adc	r31, r31
    6bf8:	e6 52       	subi	r30, 0x26	; 38
    6bfa:	fb 4f       	sbci	r31, 0xFB	; 251
    6bfc:	26 81       	ldd	r18, Z+6	; 0x06
    6bfe:	37 81       	ldd	r19, Z+7	; 0x07
	for (int8_t j=MB_Frame[MB_N][2]/2-1; j>=0; j--) {
    6c00:	4b 2f       	mov	r20, r27
    6c02:	46 95       	lsr	r20
    6c04:	41 50       	subi	r20, 0x01	; 1
    6c06:	47 fd       	sbrc	r20, 7
    6c08:	97 ce       	rjmp	.-722    	; 0x6938 <MB_M_Timer_ISR+0x258>
    6c0a:	84 2f       	mov	r24, r20
    6c0c:	99 27       	eor	r25, r25
    6c0e:	87 fd       	sbrc	r24, 7
    6c10:	90 95       	com	r25
    6c12:	88 0f       	add	r24, r24
    6c14:	99 1f       	adc	r25, r25
    6c16:	58 2f       	mov	r21, r24
    6c18:	5d 5f       	subi	r21, 0xFD	; 253
    6c1a:	28 0f       	add	r18, r24
    6c1c:	39 1f       	adc	r19, r25
		int8_t i = j*2;
		Reg[j] = MB_FrameReg(MB_N, 3+i);
    6c1e:	8a e6       	ldi	r24, 0x6A	; 106
    6c20:	88 2e       	mov	r8, r24
    6c22:	8b e0       	ldi	r24, 0x0B	; 11
    6c24:	98 2e       	mov	r9, r24
    6c26:	8c 0c       	add	r8, r12
    6c28:	9d 1c       	adc	r9, r13
    6c2a:	e5 2f       	mov	r30, r21
    6c2c:	f0 e0       	ldi	r31, 0x00	; 0
    6c2e:	d4 01       	movw	r26, r8
    6c30:	ae 0f       	add	r26, r30
    6c32:	bf 1f       	adc	r27, r31
    6c34:	11 96       	adiw	r26, 0x01	; 1
    6c36:	8c 91       	ld	r24, X
    6c38:	90 e0       	ldi	r25, 0x00	; 0
    6c3a:	ec 0d       	add	r30, r12
    6c3c:	fd 1d       	adc	r31, r13
    6c3e:	e6 59       	subi	r30, 0x96	; 150
    6c40:	f4 4f       	sbci	r31, 0xF4	; 244
    6c42:	f0 81       	ld	r31, Z
    6c44:	e0 e0       	ldi	r30, 0x00	; 0
    6c46:	8e 2b       	or	r24, r30
    6c48:	9f 2b       	or	r25, r31
    6c4a:	d9 01       	movw	r26, r18
    6c4c:	8d 93       	st	X+, r24
    6c4e:	9c 93       	st	X, r25
		return 1;
	uint16_t *Reg = LastProcSingle ?
		MB_SingleQuery[MB_N].Buf
	:
		(uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg))+prw(&Query->AllocAddr);
	for (int8_t j=MB_Frame[MB_N][2]/2-1; j>=0; j--) {
    6c50:	41 50       	subi	r20, 0x01	; 1
    6c52:	52 50       	subi	r21, 0x02	; 2
    6c54:	22 50       	subi	r18, 0x02	; 2
    6c56:	30 40       	sbci	r19, 0x00	; 0
    6c58:	47 ff       	sbrs	r20, 7
    6c5a:	e7 cf       	rjmp	.-50     	; 0x6c2a <MB_M_Timer_ISR+0x54a>
    6c5c:	6d ce       	rjmp	.-806    	; 0x6938 <MB_M_Timer_ISR+0x258>
			else if (LastProcSingle)
				MB_SingleState[MB_N] = MB_SingleIdle;
			else {
				SlaveOff[MB_N] &=~((uint32_t)1<<CurrSlave[MB_N]);
				if (++CurrQuery[MB_N]==prb(&Slave->QueryQt))
					Over = NextSlave(MB_N);
    6c5e:	81 2f       	mov	r24, r17
    6c60:	0e 94 27 32 	call	0x644e	; 0x644e <NextSlave>
    6c64:	98 2f       	mov	r25, r24
    6c66:	a7 ce       	rjmp	.-690    	; 0x69b6 <MB_M_Timer_ISR+0x2d6>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    6c68:	ca 01       	movw	r24, r20
    6c6a:	03 96       	adiw	r24, 0x03	; 3
    6c6c:	fc 01       	movw	r30, r24
    6c6e:	25 91       	lpm	r18, Z+
    6c70:	34 91       	lpm	r19, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_M_ReadReg(uint8_t MB_N, MB_Query *Query)
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || (LastProcSingle?MB_SingleQuery[MB_N].Qt:prw(&Query->Qt))*2!=MB_Frame[MB_N][2])
    6c72:	22 0f       	add	r18, r18
    6c74:	33 1f       	adc	r19, r19
    6c76:	b0 cf       	rjmp	.-160    	; 0x6bd8 <MB_M_Timer_ISR+0x4f8>
	if (LastProcSingle) {
		Discr = MB_SingleQuery[MB_N].Buf;
		Pin = 0;
	}
	else {
		Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
    6c78:	a1 30       	cpi	r26, 0x01	; 1
    6c7a:	59 f1       	breq	.+86     	; 0x6cd2 <MB_M_Timer_ISR+0x5f2>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6c7c:	f7 01       	movw	r30, r14
    6c7e:	ee 0f       	add	r30, r30
    6c80:	ff 1f       	adc	r31, r31
    6c82:	ee 0f       	add	r30, r30
    6c84:	ff 1f       	adc	r31, r31
    6c86:	ec 5c       	subi	r30, 0xCC	; 204
    6c88:	fc 4f       	sbci	r31, 0xFC	; 252
    6c8a:	85 91       	lpm	r24, Z+
    6c8c:	94 91       	lpm	r25, Z+
    6c8e:	e8 2f       	mov	r30, r24
    6c90:	89 2f       	mov	r24, r25
    6c92:	2e 2f       	mov	r18, r30
    6c94:	38 2f       	mov	r19, r24
    6c96:	c9 01       	movw	r24, r18
    6c98:	4c 01       	movw	r8, r24

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    6c9a:	fa 01       	movw	r30, r20
    6c9c:	35 96       	adiw	r30, 0x05	; 5
    6c9e:	85 91       	lpm	r24, Z+
    6ca0:	94 91       	lpm	r25, Z+
		Pin = prw(&Query->AllocAddr);
    6ca2:	08 2f       	mov	r16, r24
    6ca4:	d8 ce       	rjmp	.-592    	; 0x6a56 <MB_M_Timer_ISR+0x376>
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || (LastProcSingle?MB_SingleQuery[MB_N].Qt:prw(&Query->Qt))*2!=MB_Frame[MB_N][2])
		return 1;
	uint16_t *Reg = LastProcSingle ?
		MB_SingleQuery[MB_N].Buf
	:
		(uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg))+prw(&Query->AllocAddr);
    6ca6:	a3 30       	cpi	r26, 0x03	; 3
    6ca8:	11 f1       	breq	.+68     	; 0x6cee <MB_M_Timer_ISR+0x60e>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6caa:	fe 01       	movw	r30, r28
    6cac:	e2 95       	swap	r30
    6cae:	f2 95       	swap	r31
    6cb0:	f0 7f       	andi	r31, 0xF0	; 240
    6cb2:	fe 27       	eor	r31, r30
    6cb4:	e0 7f       	andi	r30, 0xF0	; 240
    6cb6:	fe 27       	eor	r31, r30
    6cb8:	e4 5c       	subi	r30, 0xC4	; 196
    6cba:	fc 4f       	sbci	r31, 0xFC	; 252
    6cbc:	85 91       	lpm	r24, Z+
    6cbe:	94 91       	lpm	r25, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    6cc0:	fa 01       	movw	r30, r20
    6cc2:	35 96       	adiw	r30, 0x05	; 5
    6cc4:	25 91       	lpm	r18, Z+
    6cc6:	34 91       	lpm	r19, Z+
    6cc8:	22 0f       	add	r18, r18
    6cca:	33 1f       	adc	r19, r19
    6ccc:	28 0f       	add	r18, r24
    6cce:	39 1f       	adc	r19, r25
    6cd0:	97 cf       	rjmp	.-210    	; 0x6c00 <MB_M_Timer_ISR+0x520>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6cd2:	fe 01       	movw	r30, r28
    6cd4:	e2 95       	swap	r30
    6cd6:	f2 95       	swap	r31
    6cd8:	f0 7f       	andi	r31, 0xF0	; 240
    6cda:	fe 27       	eor	r31, r30
    6cdc:	e0 7f       	andi	r30, 0xF0	; 240
    6cde:	fe 27       	eor	r31, r30
    6ce0:	e0 5d       	subi	r30, 0xD0	; 208
    6ce2:	fc 4f       	sbci	r31, 0xFC	; 252
    6ce4:	85 91       	lpm	r24, Z+
    6ce6:	94 91       	lpm	r25, Z+
    6ce8:	e8 2f       	mov	r30, r24
    6cea:	89 2f       	mov	r24, r25
    6cec:	d2 cf       	rjmp	.-92     	; 0x6c92 <MB_M_Timer_ISR+0x5b2>

// ~~~~~~~~~~~~~~~~~~
void
MB_M_Tx(uint8_t MB_N)
{
	StartTimer16(TD_MB_Idle+MB_N, MB_M_Timeout[MB_N]);
    6cee:	fe 01       	movw	r30, r28
    6cf0:	ee 0f       	add	r30, r30
    6cf2:	ff 1f       	adc	r31, r31
    6cf4:	ee 0f       	add	r30, r30
    6cf6:	ff 1f       	adc	r31, r31
    6cf8:	ee 0f       	add	r30, r30
    6cfa:	ff 1f       	adc	r31, r31
    6cfc:	ee 0f       	add	r30, r30
    6cfe:	ff 1f       	adc	r31, r31
    6d00:	e8 5c       	subi	r30, 0xC8	; 200
    6d02:	fc 4f       	sbci	r31, 0xFC	; 252
    6d04:	85 91       	lpm	r24, Z+
    6d06:	94 91       	lpm	r25, Z+
    6d08:	db cf       	rjmp	.-74     	; 0x6cc0 <MB_M_Timer_ISR+0x5e0>

00006d0a <MB_M_Tx>:
    6d0a:	90 91 e8 04 	lds	r25, 0x04E8
    6d0e:	e8 e2       	ldi	r30, 0x28	; 40
    6d10:	f9 e0       	ldi	r31, 0x09	; 9
    6d12:	e8 0f       	add	r30, r24
    6d14:	f1 1d       	adc	r31, r1
    6d16:	60 81       	ld	r22, Z
    6d18:	89 0f       	add	r24, r25
    6d1a:	70 e0       	ldi	r23, 0x00	; 0
    6d1c:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
}
    6d20:	08 95       	ret

00006d22 <Modbus_TX>:
}

// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_TX(usart_t *usart)
{
    6d22:	cf 92       	push	r12
    6d24:	df 92       	push	r13
    6d26:	ef 92       	push	r14
    6d28:	ff 92       	push	r15
    6d2a:	1f 93       	push	r17
    6d2c:	cf 93       	push	r28
    6d2e:	df 93       	push	r29
    6d30:	dc 01       	movw	r26, r24
    6d32:	e0 e9       	ldi	r30, 0x90	; 144
    6d34:	ff e2       	ldi	r31, 0x2F	; 47
    6d36:	85 91       	lpm	r24, Z+
    6d38:	94 91       	lpm	r25, Z+
// ~~~~~~~~~~~~~~~~~~~~~~
static uint8_t
MB_Port_N(usart_t *usart)
{
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Port[MB_N].usart_field)!=usart; MB_N++);
    6d3a:	a8 17       	cp	r26, r24
    6d3c:	b9 07       	cpc	r27, r25
    6d3e:	09 f4       	brne	.+2      	; 0x6d42 <Modbus_TX+0x20>
    6d40:	c0 c0       	rjmp	.+384    	; 0x6ec2 <Modbus_TX+0x1a0>
    6d42:	10 e0       	ldi	r17, 0x00	; 0
    6d44:	1f 5f       	subi	r17, 0xFF	; 255
    6d46:	c1 2f       	mov	r28, r17
    6d48:	d0 e0       	ldi	r29, 0x00	; 0
    6d4a:	ce 01       	movw	r24, r28
    6d4c:	88 0f       	add	r24, r24
    6d4e:	99 1f       	adc	r25, r25
    6d50:	88 0f       	add	r24, r24
    6d52:	99 1f       	adc	r25, r25
    6d54:	fc 01       	movw	r30, r24
    6d56:	ee 0f       	add	r30, r30
    6d58:	ff 1f       	adc	r31, r31
    6d5a:	ee 0f       	add	r30, r30
    6d5c:	ff 1f       	adc	r31, r31
    6d5e:	e8 0f       	add	r30, r24
    6d60:	f9 1f       	adc	r31, r25
    6d62:	e0 57       	subi	r30, 0x70	; 112
    6d64:	f0 4d       	sbci	r31, 0xD0	; 208
    6d66:	85 91       	lpm	r24, Z+
    6d68:	94 91       	lpm	r25, Z+
    6d6a:	a8 17       	cp	r26, r24
    6d6c:	b9 07       	cpc	r27, r25
    6d6e:	51 f7       	brne	.-44     	; 0x6d44 <Modbus_TX+0x22>
void
Modbus_TX(usart_t *usart)
{
	uint8_t MB_N = MB_Port_N(usart);
	static uint8_t Count[Modbus_Qt];
	if (Count[MB_N] == MB_Frame_Sz[MB_N]-2){
    6d70:	26 ee       	ldi	r18, 0xE6	; 230
    6d72:	c2 2e       	mov	r12, r18
    6d74:	22 e0       	ldi	r18, 0x02	; 2
    6d76:	d2 2e       	mov	r13, r18
    6d78:	cc 0e       	add	r12, r28
    6d7a:	dd 1e       	adc	r13, r29
    6d7c:	f6 01       	movw	r30, r12
    6d7e:	50 81       	ld	r21, Z
    6d80:	be 01       	movw	r22, r28
    6d82:	67 5b       	subi	r22, 0xB7	; 183
    6d84:	78 4f       	sbci	r23, 0xF8	; 248
    6d86:	fb 01       	movw	r30, r22
    6d88:	40 81       	ld	r20, Z
    6d8a:	25 2f       	mov	r18, r21
    6d8c:	30 e0       	ldi	r19, 0x00	; 0
    6d8e:	84 2f       	mov	r24, r20
    6d90:	90 e0       	ldi	r25, 0x00	; 0
    6d92:	02 97       	sbiw	r24, 0x02	; 2
    6d94:	28 17       	cp	r18, r24
    6d96:	39 07       	cpc	r19, r25
    6d98:	09 f4       	brne	.+2      	; 0x6d9c <Modbus_TX+0x7a>
    6d9a:	55 c0       	rjmp	.+170    	; 0x6e46 <Modbus_TX+0x124>
		USART_Reg(MB_N, ucsrb) &=~(1<<5);
		USART_Reg(MB_N, ucsrb) |=(1<<6);
		USART_Reg(MB_N, ucsra) |=(1<<6);	//Clear TxC pending interrupt		
	}
	if (++Count[MB_N]<MB_Frame_Sz[MB_N]) {
    6d9c:	25 2f       	mov	r18, r21
    6d9e:	2f 5f       	subi	r18, 0xFF	; 255
    6da0:	f6 01       	movw	r30, r12
    6da2:	20 83       	st	Z, r18
    6da4:	24 17       	cp	r18, r20
    6da6:	80 f4       	brcc	.+32     	; 0x6dc8 <Modbus_TX+0xa6>
		usart_data(usart) = MB_Frame[MB_N][Count[MB_N]];
    6da8:	fc 2f       	mov	r31, r28
    6daa:	ee 27       	eor	r30, r30
    6dac:	e2 0f       	add	r30, r18
    6dae:	f1 1d       	adc	r31, r1
    6db0:	e6 59       	subi	r30, 0x96	; 150
    6db2:	f4 4f       	sbci	r31, 0xF4	; 244
    6db4:	80 81       	ld	r24, Z
    6db6:	8c 93       	st	X, r24
		break;
	case Role_Master:
		MB_M_Tx(MB_N);
		break;
	}
}
    6db8:	df 91       	pop	r29
    6dba:	cf 91       	pop	r28
    6dbc:	1f 91       	pop	r17
    6dbe:	ff 90       	pop	r15
    6dc0:	ef 90       	pop	r14
    6dc2:	df 90       	pop	r13
    6dc4:	cf 90       	pop	r12
    6dc6:	08 95       	ret
    6dc8:	9e 01       	movw	r18, r28
    6dca:	22 0f       	add	r18, r18
    6dcc:	33 1f       	adc	r19, r19
    6dce:	22 0f       	add	r18, r18
    6dd0:	33 1f       	adc	r19, r19
    6dd2:	c9 01       	movw	r24, r18
    6dd4:	8c 0f       	add	r24, r28
    6dd6:	9d 1f       	adc	r25, r29
    6dd8:	88 0f       	add	r24, r24
    6dda:	99 1f       	adc	r25, r25
    6ddc:	88 0f       	add	r24, r24
    6dde:	99 1f       	adc	r25, r25
    6de0:	8c 56       	subi	r24, 0x6C	; 108
    6de2:	90 4d       	sbci	r25, 0xD0	; 208
    6de4:	fc 01       	movw	r30, r24
    6de6:	a5 91       	lpm	r26, Z+
    6de8:	b4 91       	lpm	r27, Z+
	}

	void MB_S_Tx(uint8_t);
	void MB_M_Tx(uint8_t);
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		USART_Reg(MB_N, ucsrb) &=~((1<<6)|(1<<5)); 	// .  USART Data Register Empty Interrupt
    6dea:	8c 91       	ld	r24, X
    6dec:	8f 79       	andi	r24, 0x9F	; 159
    6dee:	8c 93       	st	X, r24
    6df0:	79 01       	movw	r14, r18
    6df2:	ee 0c       	add	r14, r14
    6df4:	ff 1c       	adc	r15, r15
    6df6:	ee 0c       	add	r14, r14
    6df8:	ff 1c       	adc	r15, r15
    6dfa:	e2 0e       	add	r14, r18
    6dfc:	f3 1e       	adc	r15, r19
    6dfe:	c7 01       	movw	r24, r14
    6e00:	84 56       	subi	r24, 0x64	; 100
    6e02:	90 4d       	sbci	r25, 0xD0	; 208
    6e04:	fc 01       	movw	r30, r24
    6e06:	25 91       	lpm	r18, Z+
    6e08:	34 91       	lpm	r19, Z+
	#elif defined (__AVR_ATxmega128A1__)
		usart->CTRLA = (usart->CTRLA &~USART_TXCINTLVL_gm) |USART_TXCINTLVL_OFF_gc;
	#endif
	USART_Func(MB_N, RS485);
    6e0a:	f9 01       	movw	r30, r18
    6e0c:	19 95       	eicall
	Count[MB_N] = 0;
    6e0e:	f6 01       	movw	r30, r12
    6e10:	10 82       	st	Z, r1
	//StartTime3_5();
	MB_State[MB_N] = MB_Idle;
    6e12:	ce 53       	subi	r28, 0x3E	; 62
    6e14:	da 4f       	sbci	r29, 0xFA	; 250
    6e16:	81 e0       	ldi	r24, 0x01	; 1
    6e18:	88 83       	st	Y, r24

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    6e1a:	e1 2f       	mov	r30, r17
    6e1c:	f0 e0       	ldi	r31, 0x00	; 0
    6e1e:	ec 55       	subi	r30, 0x5C	; 92
    6e20:	f0 4d       	sbci	r31, 0xD0	; 208
    6e22:	84 91       	lpm	r24, Z+
	switch (prb(MB_Role+MB_N)) {
    6e24:	88 23       	and	r24, r24
    6e26:	09 f4       	brne	.+2      	; 0x6e2a <Modbus_TX+0x108>
    6e28:	3c c0       	rjmp	.+120    	; 0x6ea2 <Modbus_TX+0x180>
    6e2a:	81 30       	cpi	r24, 0x01	; 1
    6e2c:	09 f0       	breq	.+2      	; 0x6e30 <Modbus_TX+0x10e>
    6e2e:	c4 cf       	rjmp	.-120    	; 0x6db8 <Modbus_TX+0x96>
	case Role_Slave:
		MB_S_Tx(MB_N);
		break;
	case Role_Master:
		MB_M_Tx(MB_N);
    6e30:	81 2f       	mov	r24, r17
    6e32:	0e 94 85 36 	call	0x6d0a	; 0x6d0a <MB_M_Tx>
		break;
	}
}
    6e36:	df 91       	pop	r29
    6e38:	cf 91       	pop	r28
    6e3a:	1f 91       	pop	r17
    6e3c:	ff 90       	pop	r15
    6e3e:	ef 90       	pop	r14
    6e40:	df 90       	pop	r13
    6e42:	cf 90       	pop	r12
    6e44:	08 95       	ret

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6e46:	fe 01       	movw	r30, r28
    6e48:	ee 0f       	add	r30, r30
    6e4a:	ff 1f       	adc	r31, r31
    6e4c:	ee 0f       	add	r30, r30
    6e4e:	ff 1f       	adc	r31, r31
    6e50:	ec 0f       	add	r30, r28
    6e52:	fd 1f       	adc	r31, r29
    6e54:	ee 0f       	add	r30, r30
    6e56:	ff 1f       	adc	r31, r31
    6e58:	ee 0f       	add	r30, r30
    6e5a:	ff 1f       	adc	r31, r31
    6e5c:	ec 56       	subi	r30, 0x6C	; 108
    6e5e:	f0 4d       	sbci	r31, 0xD0	; 208
    6e60:	25 91       	lpm	r18, Z+
    6e62:	34 91       	lpm	r19, Z+
Modbus_TX(usart_t *usart)
{
	uint8_t MB_N = MB_Port_N(usart);
	static uint8_t Count[Modbus_Qt];
	if (Count[MB_N] == MB_Frame_Sz[MB_N]-2){
		USART_Reg(MB_N, ucsrb) &=~(1<<5);
    6e64:	f9 01       	movw	r30, r18
    6e66:	80 81       	ld	r24, Z
    6e68:	8f 7d       	andi	r24, 0xDF	; 223
		USART_Reg(MB_N, ucsrb) |=(1<<6);
    6e6a:	80 64       	ori	r24, 0x40	; 64
    6e6c:	80 83       	st	Z, r24
    6e6e:	9e 01       	movw	r18, r28
    6e70:	22 0f       	add	r18, r18
    6e72:	33 1f       	adc	r19, r19
    6e74:	ce 01       	movw	r24, r28
    6e76:	88 0f       	add	r24, r24
    6e78:	99 1f       	adc	r25, r25
    6e7a:	88 0f       	add	r24, r24
    6e7c:	99 1f       	adc	r25, r25
    6e7e:	88 0f       	add	r24, r24
    6e80:	99 1f       	adc	r25, r25
    6e82:	28 0f       	add	r18, r24
    6e84:	39 1f       	adc	r19, r25
    6e86:	22 0f       	add	r18, r18
    6e88:	33 1f       	adc	r19, r19
    6e8a:	2e 56       	subi	r18, 0x6E	; 110
    6e8c:	30 4d       	sbci	r19, 0xD0	; 208
    6e8e:	f9 01       	movw	r30, r18
    6e90:	e5 90       	lpm	r14, Z+
    6e92:	f4 90       	lpm	r15, Z+
		USART_Reg(MB_N, ucsra) |=(1<<6);	//Clear TxC pending interrupt		
    6e94:	f7 01       	movw	r30, r14
    6e96:	80 81       	ld	r24, Z
    6e98:	80 64       	ori	r24, 0x40	; 64
    6e9a:	80 83       	st	Z, r24
    6e9c:	fb 01       	movw	r30, r22
    6e9e:	40 81       	ld	r20, Z
    6ea0:	7d cf       	rjmp	.-262    	; 0x6d9c <Modbus_TX+0x7a>
    6ea2:	c7 01       	movw	r24, r14
    6ea4:	82 56       	subi	r24, 0x62	; 98
    6ea6:	90 4d       	sbci	r25, 0xD0	; 208
    6ea8:	fc 01       	movw	r30, r24
    6eaa:	25 91       	lpm	r18, Z+
    6eac:	34 91       	lpm	r19, Z+

// ~~~~~~~~~~~~~~~~~~
void
MB_S_Tx(uint8_t MB_N)
{
	USART_Func(MB_N, LED);
    6eae:	f9 01       	movw	r30, r18
    6eb0:	19 95       	eicall
		break;
	case Role_Master:
		MB_M_Tx(MB_N);
		break;
	}
}
    6eb2:	df 91       	pop	r29
    6eb4:	cf 91       	pop	r28
    6eb6:	1f 91       	pop	r17
    6eb8:	ff 90       	pop	r15
    6eba:	ef 90       	pop	r14
    6ebc:	df 90       	pop	r13
    6ebe:	cf 90       	pop	r12
    6ec0:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~
static uint8_t
MB_Port_N(usart_t *usart)
{
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Port[MB_N].usart_field)!=usart; MB_N++);
    6ec2:	10 e0       	ldi	r17, 0x00	; 0
    6ec4:	c0 e0       	ldi	r28, 0x00	; 0
    6ec6:	d0 e0       	ldi	r29, 0x00	; 0
    6ec8:	53 cf       	rjmp	.-346    	; 0x6d70 <Modbus_TX+0x4e>

00006eca <MB_SingleRun>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_SingleRun(uint8_t MB_N, uint8_t Addr, uint8_t Func, uint16_t StartAddr, uint16_t Qt, void *Buf)
{
    6eca:	df 92       	push	r13
    6ecc:	ef 92       	push	r14
    6ece:	ff 92       	push	r15
    6ed0:	0f 93       	push	r16
    6ed2:	1f 93       	push	r17
    6ed4:	cf 93       	push	r28
    6ed6:	df 93       	push	r29
    6ed8:	d8 2e       	mov	r13, r24
    6eda:	94 2f       	mov	r25, r20
    6edc:	a9 01       	movw	r20, r18
	if (MB_SingleState[MB_N]!=MB_SingleIdle)
    6ede:	c8 2f       	mov	r28, r24
    6ee0:	d0 e0       	ldi	r29, 0x00	; 0
    6ee2:	9e 01       	movw	r18, r28
    6ee4:	21 55       	subi	r18, 0x51	; 81
    6ee6:	39 4f       	sbci	r19, 0xF9	; 249
    6ee8:	f9 01       	movw	r30, r18
    6eea:	80 81       	ld	r24, Z
    6eec:	88 23       	and	r24, r24
    6eee:	91 f5       	brne	.+100    	; 0x6f54 <MB_SingleRun+0x8a>
		return;

	MB_SingleQuery[MB_N].Addr				= Addr;
    6ef0:	de 01       	movw	r26, r28
    6ef2:	aa 0f       	add	r26, r26
    6ef4:	bb 1f       	adc	r27, r27
    6ef6:	aa 0f       	add	r26, r26
    6ef8:	bb 1f       	adc	r27, r27
    6efa:	aa 0f       	add	r26, r26
    6efc:	bb 1f       	adc	r27, r27
    6efe:	a6 52       	subi	r26, 0x26	; 38
    6f00:	bb 4f       	sbci	r27, 0xFB	; 251
    6f02:	6c 93       	st	X, r22
	MB_SingleQuery[MB_N].Func				= Func;
    6f04:	11 96       	adiw	r26, 0x01	; 1
    6f06:	9c 93       	st	X, r25
    6f08:	11 97       	sbiw	r26, 0x01	; 1
	MB_SingleQuery[MB_N].StartAddr	= StartAddr;
    6f0a:	be 01       	movw	r22, r28
    6f0c:	66 0f       	add	r22, r22
    6f0e:	77 1f       	adc	r23, r23
    6f10:	66 0f       	add	r22, r22
    6f12:	77 1f       	adc	r23, r23
    6f14:	fb 01       	movw	r30, r22
    6f16:	ee 0f       	add	r30, r30
    6f18:	ff 1f       	adc	r31, r31
    6f1a:	e4 52       	subi	r30, 0x24	; 36
    6f1c:	fb 4f       	sbci	r31, 0xFB	; 251
    6f1e:	51 83       	std	Z+1, r21	; 0x01
    6f20:	40 83       	st	Z, r20
	MB_SingleQuery[MB_N].Qt					= Qt;
    6f22:	ae 01       	movw	r20, r28
    6f24:	44 0f       	add	r20, r20
    6f26:	55 1f       	adc	r21, r21
    6f28:	fa 01       	movw	r30, r20
    6f2a:	ee 0f       	add	r30, r30
    6f2c:	ff 1f       	adc	r31, r31
    6f2e:	ee 0f       	add	r30, r30
    6f30:	ff 1f       	adc	r31, r31
    6f32:	e2 52       	subi	r30, 0x22	; 34
    6f34:	fb 4f       	sbci	r31, 0xFB	; 251
    6f36:	11 83       	std	Z+1, r17	; 0x01
    6f38:	00 83       	st	Z, r16
	MB_SingleQuery[MB_N].Buf				= Buf;
    6f3a:	17 96       	adiw	r26, 0x07	; 7
    6f3c:	fc 92       	st	X, r15
    6f3e:	ee 92       	st	-X, r14
    6f40:	16 97       	sbiw	r26, 0x06	; 6

	MB_SingleState[MB_N] = MB_SingleStart;
    6f42:	81 e0       	ldi	r24, 0x01	; 1
    6f44:	f9 01       	movw	r30, r18
    6f46:	80 83       	st	Z, r24
	if (MB_State[MB_N]==MB_Proc && !LastProcSingle) {
    6f48:	fe 01       	movw	r30, r28
    6f4a:	ee 53       	subi	r30, 0x3E	; 62
    6f4c:	fa 4f       	sbci	r31, 0xFA	; 250
    6f4e:	80 81       	ld	r24, Z
    6f50:	84 30       	cpi	r24, 0x04	; 4
    6f52:	41 f0       	breq	.+16     	; 0x6f64 <MB_SingleRun+0x9a>
			IntOff();
			MB_Transm(MB_N);
			IntOn();
		}
	}
}
    6f54:	df 91       	pop	r29
    6f56:	cf 91       	pop	r28
    6f58:	1f 91       	pop	r17
    6f5a:	0f 91       	pop	r16
    6f5c:	ff 90       	pop	r15
    6f5e:	ef 90       	pop	r14
    6f60:	df 90       	pop	r13
    6f62:	08 95       	ret
	MB_SingleQuery[MB_N].StartAddr	= StartAddr;
	MB_SingleQuery[MB_N].Qt					= Qt;
	MB_SingleQuery[MB_N].Buf				= Buf;

	MB_SingleState[MB_N] = MB_SingleStart;
	if (MB_State[MB_N]==MB_Proc && !LastProcSingle) {
    6f64:	80 91 e2 04 	lds	r24, 0x04E2
    6f68:	88 23       	and	r24, r24
    6f6a:	a1 f7       	brne	.-24     	; 0x6f54 <MB_SingleRun+0x8a>
		uint16_t T = (CurrSlave[MB_N]==0 ? MB_M_Period[MB_N] : MB_M_Timeout[MB_N]) - GetTimer16(TD_MB_Idle+MB_N);
    6f6c:	fe 01       	movw	r30, r28
    6f6e:	ec 5a       	subi	r30, 0xAC	; 172
    6f70:	f9 4f       	sbci	r31, 0xF9	; 249
    6f72:	80 81       	ld	r24, Z
    6f74:	88 23       	and	r24, r24
    6f76:	09 f0       	breq	.+2      	; 0x6f7a <MB_SingleRun+0xb0>
    6f78:	4d c0       	rjmp	.+154    	; 0x7014 <MB_SingleRun+0x14a>
    6f7a:	43 55       	subi	r20, 0x53	; 83
    6f7c:	59 4f       	sbci	r21, 0xF9	; 249
    6f7e:	fa 01       	movw	r30, r20
    6f80:	40 81       	ld	r20, Z
    6f82:	51 81       	ldd	r21, Z+1	; 0x01
    6f84:	20 91 e8 04 	lds	r18, 0x04E8
    6f88:	2d 0d       	add	r18, r13

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    6f8a:	8f b7       	in	r24, 0x3f	; 63
    6f8c:	80 78       	andi	r24, 0x80	; 128
    6f8e:	80 93 ee 02 	sts	0x02EE, r24
	cli();
    6f92:	f8 94       	cli
    6f94:	e2 2f       	mov	r30, r18
    6f96:	f0 e0       	ldi	r31, 0x00	; 0
    6f98:	ee 0f       	add	r30, r30
    6f9a:	ff 1f       	adc	r31, r31
    6f9c:	e1 5b       	subi	r30, 0xB1	; 177
    6f9e:	fc 4f       	sbci	r31, 0xFC	; 252
    6fa0:	a0 81       	ld	r26, Z
    6fa2:	b1 81       	ldd	r27, Z+1	; 0x01

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    6fa4:	88 23       	and	r24, r24
    6fa6:	09 f0       	breq	.+2      	; 0x6faa <MB_SingleRun+0xe0>
		sei();
    6fa8:	78 94       	sei
    6faa:	ca 01       	movw	r24, r20
    6fac:	8a 1b       	sub	r24, r26
    6fae:	9b 0b       	sbc	r25, r27
		if (T<MB_M_Pause_Min)
    6fb0:	85 30       	cpi	r24, 0x05	; 5
    6fb2:	91 05       	cpc	r25, r1
    6fb4:	a8 f1       	brcs	.+106    	; 0x7020 <MB_SingleRun+0x156>

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    6fb6:	8f b7       	in	r24, 0x3f	; 63
    6fb8:	80 78       	andi	r24, 0x80	; 128
    6fba:	80 93 ee 02 	sts	0x02EE, r24
	cli();
    6fbe:	f8 94       	cli
    6fc0:	cb 01       	movw	r24, r22
    6fc2:	88 0f       	add	r24, r24
    6fc4:	99 1f       	adc	r25, r25
    6fc6:	88 0f       	add	r24, r24
    6fc8:	99 1f       	adc	r25, r25
    6fca:	86 0f       	add	r24, r22
    6fcc:	97 1f       	adc	r25, r23
    6fce:	82 56       	subi	r24, 0x62	; 98
    6fd0:	90 4d       	sbci	r25, 0xD0	; 208
    6fd2:	fc 01       	movw	r30, r24
    6fd4:	25 91       	lpm	r18, Z+
    6fd6:	34 91       	lpm	r19, Z+
			StartTimer16(TD_MB_Idle+MB_N, MB_M_Pause_Min-T);
		else {
			IntOff();
			USART_Func(MB_N, LED);
    6fd8:	f9 01       	movw	r30, r18
    6fda:	19 95       	eicall

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    6fdc:	80 91 ee 02 	lds	r24, 0x02EE
    6fe0:	88 23       	and	r24, r24
    6fe2:	09 f0       	breq	.+2      	; 0x6fe6 <MB_SingleRun+0x11c>
		sei();
    6fe4:	78 94       	sei
			IntOn();
			ResetTimer16(TD_MB_Idle+MB_N);
    6fe6:	80 91 e8 04 	lds	r24, 0x04E8
    6fea:	8d 0d       	add	r24, r13
    6fec:	0e 94 c2 1d 	call	0x3b84	; 0x3b84 <ResetTimer16>
			FormSingle(MB_N);
    6ff0:	8d 2d       	mov	r24, r13
    6ff2:	0e 94 e5 31 	call	0x63ca	; 0x63ca <FormSingle>

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    6ff6:	8f b7       	in	r24, 0x3f	; 63
    6ff8:	80 78       	andi	r24, 0x80	; 128
    6ffa:	80 93 ee 02 	sts	0x02EE, r24
	cli();
    6ffe:	f8 94       	cli
			IntOff();
			MB_Transm(MB_N);
    7000:	8d 2d       	mov	r24, r13
    7002:	0e 94 8b 2a 	call	0x5516	; 0x5516 <MB_Transm>

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    7006:	80 91 ee 02 	lds	r24, 0x02EE
    700a:	88 23       	and	r24, r24
    700c:	09 f4       	brne	.+2      	; 0x7010 <MB_SingleRun+0x146>
    700e:	a2 cf       	rjmp	.-188    	; 0x6f54 <MB_SingleRun+0x8a>
		sei();
    7010:	78 94       	sei
    7012:	a0 cf       	rjmp	.-192    	; 0x6f54 <MB_SingleRun+0x8a>
	MB_SingleQuery[MB_N].Qt					= Qt;
	MB_SingleQuery[MB_N].Buf				= Buf;

	MB_SingleState[MB_N] = MB_SingleStart;
	if (MB_State[MB_N]==MB_Proc && !LastProcSingle) {
		uint16_t T = (CurrSlave[MB_N]==0 ? MB_M_Period[MB_N] : MB_M_Timeout[MB_N]) - GetTimer16(TD_MB_Idle+MB_N);
    7014:	c8 5d       	subi	r28, 0xD8	; 216
    7016:	d6 4f       	sbci	r29, 0xF6	; 246
    7018:	88 81       	ld	r24, Y
    701a:	48 2f       	mov	r20, r24
    701c:	50 e0       	ldi	r21, 0x00	; 0
    701e:	b2 cf       	rjmp	.-156    	; 0x6f84 <MB_SingleRun+0xba>
		if (T<MB_M_Pause_Min)
			StartTimer16(TD_MB_Idle+MB_N, MB_M_Pause_Min-T);
    7020:	65 e0       	ldi	r22, 0x05	; 5
    7022:	70 e0       	ldi	r23, 0x00	; 0
    7024:	68 1b       	sub	r22, r24
    7026:	79 0b       	sbc	r23, r25
    7028:	82 2f       	mov	r24, r18
    702a:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
    702e:	92 cf       	rjmp	.-220    	; 0x6f54 <MB_SingleRun+0x8a>

00007030 <MB_Master_MaxCycle_Clear>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_Master_MaxCycle_Clear(uint8_t MB_N)
{
	MB_Master_MaxCycle[MB_N] = 0;
    7030:	e8 2f       	mov	r30, r24
    7032:	f0 e0       	ldi	r31, 0x00	; 0
    7034:	ee 0f       	add	r30, r30
    7036:	ff 1f       	adc	r31, r31
    7038:	e1 50       	subi	r30, 0x01	; 1
    703a:	f9 4f       	sbci	r31, 0xF9	; 249
    703c:	11 82       	std	Z+1, r1	; 0x01
    703e:	10 82       	st	Z, r1
}
    7040:	08 95       	ret

00007042 <MB_M_Cycle>:

// ~~~~~~~~~~~~~~~~~~~~~
void
MB_M_Cycle(uint8_t MB_N)
{
    7042:	ff 92       	push	r15
    7044:	0f 93       	push	r16
    7046:	1f 93       	push	r17
    7048:	cf 93       	push	r28
    704a:	df 93       	push	r29
    704c:	f8 2e       	mov	r15, r24
	if (Timer16Stopp(TD_MB_SlaveOff+MB_N))
    704e:	10 91 e8 04 	lds	r17, 0x04E8
    7052:	18 0f       	add	r17, r24
    7054:	01 2f       	mov	r16, r17
    7056:	0f 5f       	subi	r16, 0xFF	; 255
    7058:	80 2f       	mov	r24, r16
    705a:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <Timer16Stopp>
    705e:	88 23       	and	r24, r24
    7060:	d9 f4       	brne	.+54     	; 0x7098 <MB_M_Cycle+0x56>
		SlavesOn(MB_N);

	if (Timer16Stopp(TD_MB_Idle+MB_N)){
    7062:	81 2f       	mov	r24, r17
    7064:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <Timer16Stopp>
    7068:	88 23       	and	r24, r24
    706a:	81 f0       	breq	.+32     	; 0x708c <MB_M_Cycle+0x4a>
		cli();
    706c:	f8 94       	cli
		if(MB_State[MB_N] == MB_Idle) MB_State[MB_N] = MB_NoReply;
    706e:	cf 2d       	mov	r28, r15
    7070:	d0 e0       	ldi	r29, 0x00	; 0
    7072:	fe 01       	movw	r30, r28
    7074:	ee 53       	subi	r30, 0x3E	; 62
    7076:	fa 4f       	sbci	r31, 0xFA	; 250
    7078:	80 81       	ld	r24, Z
    707a:	81 30       	cpi	r24, 0x01	; 1
    707c:	29 f1       	breq	.+74     	; 0x70c8 <MB_M_Cycle+0x86>
		sei();
    707e:	78 94       	sei
	}
	else return;
	
	switch (MB_State[MB_N]) {
    7080:	80 81       	ld	r24, Z
    7082:	84 30       	cpi	r24, 0x04	; 4
    7084:	39 f1       	breq	.+78     	; 0x70d4 <MB_M_Cycle+0x92>
    7086:	85 30       	cpi	r24, 0x05	; 5
    7088:	09 f4       	brne	.+2      	; 0x708c <MB_M_Cycle+0x4a>
    708a:	52 c0       	rjmp	.+164    	; 0x7130 <MB_M_Cycle+0xee>
		cli();
		MB_Transm(MB_N);
		sei();
		break;
	}
}
    708c:	df 91       	pop	r29
    708e:	cf 91       	pop	r28
    7090:	1f 91       	pop	r17
    7092:	0f 91       	pop	r16
    7094:	ff 90       	pop	r15
    7096:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~
static void
SlavesOn(uint8_t MB_N)
{
	SlaveSkip[MB_N] = 0;
    7098:	af 2d       	mov	r26, r15
    709a:	b0 e0       	ldi	r27, 0x00	; 0
    709c:	fd 01       	movw	r30, r26
    709e:	ee 0f       	add	r30, r30
    70a0:	ff 1f       	adc	r31, r31
    70a2:	ee 0f       	add	r30, r30
    70a4:	ff 1f       	adc	r31, r31
    70a6:	ec 51       	subi	r30, 0x1C	; 28
    70a8:	fb 4f       	sbci	r31, 0xFB	; 251
    70aa:	10 82       	st	Z, r1
    70ac:	11 82       	std	Z+1, r1	; 0x01
    70ae:	12 82       	std	Z+2, r1	; 0x02
    70b0:	13 82       	std	Z+3, r1	; 0x03
	StartTimer16(TD_MB_SlaveOff+MB_N, 100*MB_M_TimeOff[MB_N]);
    70b2:	a1 52       	subi	r26, 0x21	; 33
    70b4:	ba 4f       	sbci	r27, 0xFA	; 250
    70b6:	6c 91       	ld	r22, X
    70b8:	84 e6       	ldi	r24, 0x64	; 100
    70ba:	68 9f       	mul	r22, r24
    70bc:	b0 01       	movw	r22, r0
    70be:	11 24       	eor	r1, r1
    70c0:	80 2f       	mov	r24, r16
    70c2:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
    70c6:	cd cf       	rjmp	.-102    	; 0x7062 <MB_M_Cycle+0x20>
	if (Timer16Stopp(TD_MB_SlaveOff+MB_N))
		SlavesOn(MB_N);

	if (Timer16Stopp(TD_MB_Idle+MB_N)){
		cli();
		if(MB_State[MB_N] == MB_Idle) MB_State[MB_N] = MB_NoReply;
    70c8:	85 e0       	ldi	r24, 0x05	; 5
    70ca:	80 83       	st	Z, r24
		sei();
    70cc:	78 94       	sei
	}
	else return;
	
	switch (MB_State[MB_N]) {
    70ce:	80 81       	ld	r24, Z
    70d0:	84 30       	cpi	r24, 0x04	; 4
    70d2:	c9 f6       	brne	.-78     	; 0x7086 <MB_M_Cycle+0x44>
		cli();
		MB_Transm(MB_N);
		sei();
		break;
	case MB_Proc:
		cli();
    70d4:	f8 94       	cli
    70d6:	ce 01       	movw	r24, r28
    70d8:	88 0f       	add	r24, r24
    70da:	99 1f       	adc	r25, r25
    70dc:	88 0f       	add	r24, r24
    70de:	99 1f       	adc	r25, r25
    70e0:	9c 01       	movw	r18, r24
    70e2:	22 0f       	add	r18, r18
    70e4:	33 1f       	adc	r19, r19
    70e6:	22 0f       	add	r18, r18
    70e8:	33 1f       	adc	r19, r19
    70ea:	28 0f       	add	r18, r24
    70ec:	39 1f       	adc	r19, r25
    70ee:	22 56       	subi	r18, 0x62	; 98
    70f0:	30 4d       	sbci	r19, 0xD0	; 208
    70f2:	f9 01       	movw	r30, r18
    70f4:	85 91       	lpm	r24, Z+
    70f6:	94 91       	lpm	r25, Z+
		USART_Func(MB_N, LED);
    70f8:	fc 01       	movw	r30, r24
    70fa:	19 95       	eicall
		sei();
    70fc:	78 94       	sei
		switch (MB_SingleState[MB_N]) {
    70fe:	c1 55       	subi	r28, 0x51	; 81
    7100:	d9 4f       	sbci	r29, 0xF9	; 249
    7102:	88 81       	ld	r24, Y
    7104:	88 23       	and	r24, r24
    7106:	b1 f1       	breq	.+108    	; 0x7174 <MB_M_Cycle+0x132>
    7108:	81 30       	cpi	r24, 0x01	; 1
    710a:	81 f1       	breq	.+96     	; 0x716c <MB_M_Cycle+0x12a>
				FormQuery(MB_N);
			else
				FormSingle(MB_N);
			break;
		}
		StartTimer16(TD_MB_Idle+MB_N, 0xFFFF);	//     
    710c:	80 91 e8 04 	lds	r24, 0x04E8
    7110:	8f 0d       	add	r24, r15
    7112:	6f ef       	ldi	r22, 0xFF	; 255
    7114:	7f ef       	ldi	r23, 0xFF	; 255
    7116:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
		cli();
    711a:	f8 94       	cli
		MB_Transm(MB_N);
    711c:	8f 2d       	mov	r24, r15
    711e:	0e 94 8b 2a 	call	0x5516	; 0x5516 <MB_Transm>
		sei();
    7122:	78 94       	sei
		break;
	}
}
    7124:	df 91       	pop	r29
    7126:	cf 91       	pop	r28
    7128:	1f 91       	pop	r17
    712a:	0f 91       	pop	r16
    712c:	ff 90       	pop	r15
    712e:	08 95       	ret
	}
	else return;
	
	switch (MB_State[MB_N]) {
	case MB_NoReply:
		FailSlave(MB_N);
    7130:	8f 2d       	mov	r24, r15
    7132:	0e 94 fa 32 	call	0x65f4	; 0x65f4 <FailSlave>
		switch (MB_SingleState[MB_N]) {
    7136:	fe 01       	movw	r30, r28
    7138:	e1 55       	subi	r30, 0x51	; 81
    713a:	f9 4f       	sbci	r31, 0xF9	; 249
    713c:	e0 81       	ld	r30, Z
    713e:	ee 23       	and	r30, r30
    7140:	e9 f4       	brne	.+58     	; 0x717c <MB_M_Cycle+0x13a>
		case MB_SingleIdle:
			FormQuery(MB_N);
    7142:	8f 2d       	mov	r24, r15
    7144:	0e 94 93 31 	call	0x6326	; 0x6326 <FormQuery>
		case MB_SingleStart:
			if (Try[MB_N]==0)
				FormSingle(MB_N);
			break;
		}
		StartTimer16(TD_MB_Idle+MB_N, 0xFFFF);	//     
    7148:	80 91 e8 04 	lds	r24, 0x04E8
    714c:	8f 0d       	add	r24, r15
    714e:	6f ef       	ldi	r22, 0xFF	; 255
    7150:	7f ef       	ldi	r23, 0xFF	; 255
    7152:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
		cli();
    7156:	f8 94       	cli
		MB_Transm(MB_N);
    7158:	8f 2d       	mov	r24, r15
    715a:	0e 94 8b 2a 	call	0x5516	; 0x5516 <MB_Transm>
		sei();
    715e:	78 94       	sei
		cli();
		MB_Transm(MB_N);
		sei();
		break;
	}
}
    7160:	df 91       	pop	r29
    7162:	cf 91       	pop	r28
    7164:	1f 91       	pop	r17
    7166:	0f 91       	pop	r16
    7168:	ff 90       	pop	r15
    716a:	08 95       	ret
		switch (MB_SingleState[MB_N]) {
		case MB_SingleIdle:
			FormQuery(MB_N);
			break;
		case MB_SingleStart:
			if (LastProcSingle)
    716c:	80 91 e2 04 	lds	r24, 0x04E2
    7170:	88 23       	and	r24, r24
    7172:	79 f0       	breq	.+30     	; 0x7192 <MB_M_Cycle+0x150>
				FormQuery(MB_N);
    7174:	8f 2d       	mov	r24, r15
    7176:	0e 94 93 31 	call	0x6326	; 0x6326 <FormQuery>
    717a:	c8 cf       	rjmp	.-112    	; 0x710c <MB_M_Cycle+0xca>
	else return;
	
	switch (MB_State[MB_N]) {
	case MB_NoReply:
		FailSlave(MB_N);
		switch (MB_SingleState[MB_N]) {
    717c:	e1 30       	cpi	r30, 0x01	; 1
    717e:	21 f7       	brne	.-56     	; 0x7148 <MB_M_Cycle+0x106>
		case MB_SingleIdle:
			FormQuery(MB_N);
			break;
		case MB_SingleStart:
			if (Try[MB_N]==0)
    7180:	cd 51       	subi	r28, 0x1D	; 29
    7182:	db 4f       	sbci	r29, 0xFB	; 251
    7184:	88 81       	ld	r24, Y
    7186:	88 23       	and	r24, r24
    7188:	f9 f6       	brne	.-66     	; 0x7148 <MB_M_Cycle+0x106>
				FormSingle(MB_N);
    718a:	8f 2d       	mov	r24, r15
    718c:	0e 94 e5 31 	call	0x63ca	; 0x63ca <FormSingle>
    7190:	db cf       	rjmp	.-74     	; 0x7148 <MB_M_Cycle+0x106>
			break;
		case MB_SingleStart:
			if (LastProcSingle)
				FormQuery(MB_N);
			else
				FormSingle(MB_N);
    7192:	8f 2d       	mov	r24, r15
    7194:	0e 94 e5 31 	call	0x63ca	; 0x63ca <FormSingle>
    7198:	b9 cf       	rjmp	.-142    	; 0x710c <MB_M_Cycle+0xca>

0000719a <MB_Cycle>:
}

// ~~~~~~~~~~~
void
MB_Cycle(void)
{
    719a:	cf 93       	push	r28
    719c:	df 93       	push	r29
	void MB_S_Timer_ISR(uint8_t);
	void MB_M_Timer_ISR(uint8_t);

	for (uint8_t MB_N=0; MB_N<Modbus_Qt; MB_N++){
		if(MB_TimerFlag & (1<<MB_N)){
    719e:	80 91 29 09 	lds	r24, 0x0929
    71a2:	80 fd       	sbrc	r24, 0
    71a4:	0c c0       	rjmp	.+24     	; 0x71be <MB_Cycle+0x24>
    71a6:	c4 ea       	ldi	r28, 0xA4	; 164
    71a8:	df e2       	ldi	r29, 0x2F	; 47

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    71aa:	fe 01       	movw	r30, r28
    71ac:	84 91       	lpm	r24, Z+
	}

	void MB_M_Cycle(uint8_t);

	for (uint8_t MB_N=0; MB_N<Modbus_Qt; MB_N++)
		if (prb(MB_Role+MB_N)==Role_Master)
    71ae:	81 30       	cpi	r24, 0x01	; 1
    71b0:	19 f4       	brne	.+6      	; 0x71b8 <MB_Cycle+0x1e>
			MB_M_Cycle(MB_N);
    71b2:	80 e0       	ldi	r24, 0x00	; 0
    71b4:	0e 94 21 38 	call	0x7042	; 0x7042 <MB_M_Cycle>
}
    71b8:	df 91       	pop	r29
    71ba:	cf 91       	pop	r28
    71bc:	08 95       	ret
	void MB_S_Timer_ISR(uint8_t);
	void MB_M_Timer_ISR(uint8_t);

	for (uint8_t MB_N=0; MB_N<Modbus_Qt; MB_N++){
		if(MB_TimerFlag & (1<<MB_N)){
			cli();
    71be:	f8 94       	cli
			MB_TimerFlag &= ~(1<<MB_N);
    71c0:	80 91 29 09 	lds	r24, 0x0929
    71c4:	8e 7f       	andi	r24, 0xFE	; 254
    71c6:	80 93 29 09 	sts	0x0929, r24
			sei();
    71ca:	78 94       	sei
    71cc:	c4 ea       	ldi	r28, 0xA4	; 164
    71ce:	df e2       	ldi	r29, 0x2F	; 47
    71d0:	fe 01       	movw	r30, r28
    71d2:	84 91       	lpm	r24, Z+
			switch (prb(MB_Role+MB_N)) {
    71d4:	88 23       	and	r24, r24
    71d6:	21 f4       	brne	.+8      	; 0x71e0 <MB_Cycle+0x46>
			case Role_Slave:
				MB_S_Timer_ISR(MB_N);
    71d8:	80 e0       	ldi	r24, 0x00	; 0
    71da:	0e 94 43 2c 	call	0x5886	; 0x5886 <MB_S_Timer_ISR>
    71de:	e5 cf       	rjmp	.-54     	; 0x71aa <MB_Cycle+0x10>
	for (uint8_t MB_N=0; MB_N<Modbus_Qt; MB_N++){
		if(MB_TimerFlag & (1<<MB_N)){
			cli();
			MB_TimerFlag &= ~(1<<MB_N);
			sei();
			switch (prb(MB_Role+MB_N)) {
    71e0:	81 30       	cpi	r24, 0x01	; 1
    71e2:	19 f7       	brne	.-58     	; 0x71aa <MB_Cycle+0x10>
			case Role_Slave:
				MB_S_Timer_ISR(MB_N);
				break;
			case Role_Master:
				MB_M_Timer_ISR(MB_N);
    71e4:	80 e0       	ldi	r24, 0x00	; 0
    71e6:	0e 94 70 33 	call	0x66e0	; 0x66e0 <MB_M_Timer_ISR>
    71ea:	df cf       	rjmp	.-66     	; 0x71aa <MB_Cycle+0x10>

000071ec <SetIP>:
	uint8_t IP3;
	uint8_t IP4;
} IP_Addr;

//~~~~~~~~~~~~~~
void SetIP(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
    71ec:	0f 93       	push	r16
    71ee:	fc 01       	movw	r30, r24
	IP->IP1 = IP1;
    71f0:	60 83       	st	Z, r22
	IP->IP2 = IP2;
    71f2:	41 83       	std	Z+1, r20	; 0x01
	IP->IP3 = IP3;
    71f4:	22 83       	std	Z+2, r18	; 0x02
	IP->IP4 = IP4;
    71f6:	03 83       	std	Z+3, r16	; 0x03
}
    71f8:	0f 91       	pop	r16
    71fa:	08 95       	ret

000071fc <IP_compare_Const>:
uint8_t IP_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
    71fc:	0f 93       	push	r16
    71fe:	fc 01       	movw	r30, r24
	if((IP->IP1 == IP1) && (IP->IP2 == IP2) && (IP->IP3 == IP3) && (IP->IP4 == IP4)) return 1;
    7200:	80 81       	ld	r24, Z
    7202:	86 17       	cp	r24, r22
    7204:	21 f0       	breq	.+8      	; 0x720e <IP_compare_Const+0x12>
    7206:	20 e0       	ldi	r18, 0x00	; 0
	else return 0;
}
    7208:	82 2f       	mov	r24, r18
    720a:	0f 91       	pop	r16
    720c:	08 95       	ret
	IP->IP2 = IP2;
	IP->IP3 = IP3;
	IP->IP4 = IP4;
}
uint8_t IP_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	if((IP->IP1 == IP1) && (IP->IP2 == IP2) && (IP->IP3 == IP3) && (IP->IP4 == IP4)) return 1;
    720e:	81 81       	ldd	r24, Z+1	; 0x01
    7210:	84 17       	cp	r24, r20
    7212:	c9 f7       	brne	.-14     	; 0x7206 <IP_compare_Const+0xa>
    7214:	82 81       	ldd	r24, Z+2	; 0x02
    7216:	82 17       	cp	r24, r18
    7218:	b1 f7       	brne	.-20     	; 0x7206 <IP_compare_Const+0xa>
    721a:	20 e0       	ldi	r18, 0x00	; 0
    721c:	83 81       	ldd	r24, Z+3	; 0x03
    721e:	80 13       	cpse	r24, r16
    7220:	21 e0       	ldi	r18, 0x01	; 1
    7222:	81 e0       	ldi	r24, 0x01	; 1
    7224:	28 27       	eor	r18, r24
    7226:	f0 cf       	rjmp	.-32     	; 0x7208 <IP_compare_Const+0xc>

00007228 <GSM_StartCalling>:
uint8_t numOfCheckBallanceRetry=0;

uint8_t Message[3];  // 
uint8_t GSMBusyState=0; // " " 0 -  , 1 -  
void GSM_StartCalling(uint8_t inputN,uint8_t abonentN){
	Message[0]=1;
    7228:	91 e0       	ldi	r25, 0x01	; 1
    722a:	90 93 35 07 	sts	0x0735, r25
	Message[1]=inputN;
    722e:	80 93 36 07 	sts	0x0736, r24
	Message[2]=abonentN;
    7232:	60 93 37 07 	sts	0x0737, r22
}
    7236:	08 95       	ret

00007238 <InitFIFO>:
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    7238:	8f ef       	ldi	r24, 0xFF	; 255
    723a:	80 93 3e 07 	sts	0x073E, r24
	GSM_RX_FIFO_End = 255;
    723e:	80 93 53 06 	sts	0x0653, r24
	GSM_RxCharN = 0;
    7242:	10 92 5f 0b 	sts	0x0B5F, r1
	GSM_RX_FIFOOverFlow = 0;
    7246:	10 92 12 09 	sts	0x0912, r1
	GSM_RX_FIFOMax = 0;
    724a:	10 92 18 09 	sts	0x0918, r1
}
    724e:	08 95       	ret

00007250 <GetByteFromFIFO>:
// ~~~~~~~~~~~
void GetByteFromFIFO(uint8_t *ReadBuf, uint8_t *Index, uint8_t ReadBuf_Sz){
    7250:	0f 93       	push	r16
    7252:	1f 93       	push	r17
    7254:	cf 93       	push	r28
    7256:	df 93       	push	r29
    7258:	8c 01       	movw	r16, r24
    725a:	eb 01       	movw	r28, r22

	//Reset *Index if read buffer overflow
	if(*Index >= ReadBuf_Sz){
    725c:	88 81       	ld	r24, Y
    725e:	84 17       	cp	r24, r20
    7260:	08 f0       	brcs	.+2      	; 0x7264 <GetByteFromFIFO+0x14>
		*Index = 0;
    7262:	18 82       	st	Y, r1
		//TODO  
	}	

	if(GSM_RX_FIFO_Begin > GSM_RX_FIFO_End){
    7264:	80 91 3e 07 	lds	r24, 0x073E
    7268:	e0 91 53 06 	lds	r30, 0x0653
    726c:	e8 17       	cp	r30, r24
    726e:	f8 f4       	brcc	.+62     	; 0x72ae <GetByteFromFIFO+0x5e>
		if((GSM_RX_FIFO_End != 255)&&(GSM_RX_FIFO_End != 255))			
    7270:	ef 3f       	cpi	r30, 0xFF	; 255
    7272:	61 f0       	breq	.+24     	; 0x728c <GetByteFromFIFO+0x3c>
			if(GSM_RX_FIFOMax < (GSM_RX_FIFO_Begin - GSM_RX_FIFO_End))
    7274:	20 91 18 09 	lds	r18, 0x0918
    7278:	80 91 3e 07 	lds	r24, 0x073E
    727c:	30 e0       	ldi	r19, 0x00	; 0
    727e:	90 e0       	ldi	r25, 0x00	; 0
    7280:	8e 1b       	sub	r24, r30
    7282:	91 09       	sbc	r25, r1
    7284:	28 17       	cp	r18, r24
    7286:	39 07       	cpc	r19, r25
    7288:	0c f4       	brge	.+2      	; 0x728c <GetByteFromFIFO+0x3c>
    728a:	46 c0       	rjmp	.+140    	; 0x7318 <GetByteFromFIFO+0xc8>
				GSM_RX_FIFOMax =  GSM_RX_FIFO_Begin - GSM_RX_FIFO_End;
		GSM_RX_FIFO_End++;
    728c:	ef 5f       	subi	r30, 0xFF	; 255
    728e:	e0 93 53 06 	sts	0x0653, r30
		ReadBuf[*Index] = GSM_RX_FIFO[GSM_RX_FIFO_End];
    7292:	88 81       	ld	r24, Y
    7294:	d8 01       	movw	r26, r16
    7296:	a8 0f       	add	r26, r24
    7298:	b1 1d       	adc	r27, r1
    729a:	f0 e0       	ldi	r31, 0x00	; 0
    729c:	ef 51       	subi	r30, 0x1F	; 31
    729e:	fa 4f       	sbci	r31, 0xFA	; 250
    72a0:	80 81       	ld	r24, Z
    72a2:	8c 93       	st	X, r24
		*Index=*Index+1;
    72a4:	88 81       	ld	r24, Y
    72a6:	8f 5f       	subi	r24, 0xFF	; 255
    72a8:	88 83       	st	Y, r24
    72aa:	e0 91 53 06 	lds	r30, 0x0653
	}
	if(GSM_RX_FIFO_End > GSM_RX_FIFO_Begin){
    72ae:	80 91 3e 07 	lds	r24, 0x073E
    72b2:	8e 17       	cp	r24, r30
    72b4:	28 f5       	brcc	.+74     	; 0x7300 <GetByteFromFIFO+0xb0>
		if((GSM_RX_FIFO_End != 255)&&(GSM_RX_FIFO_End != 255))
    72b6:	ef 3f       	cpi	r30, 0xFF	; 255
    72b8:	99 f0       	breq	.+38     	; 0x72e0 <GetByteFromFIFO+0x90>
			if(GSM_RX_FIFOMax < (GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End  + GSM_RX_FIFO_Begin))
    72ba:	20 91 18 09 	lds	r18, 0x0918
    72be:	80 91 3e 07 	lds	r24, 0x073E
    72c2:	30 e0       	ldi	r19, 0x00	; 0
    72c4:	90 e0       	ldi	r25, 0x00	; 0
    72c6:	8c 59       	subi	r24, 0x9C	; 156
    72c8:	9f 4f       	sbci	r25, 0xFF	; 255
    72ca:	8e 1b       	sub	r24, r30
    72cc:	91 09       	sbc	r25, r1
    72ce:	28 17       	cp	r18, r24
    72d0:	39 07       	cpc	r19, r25
    72d2:	dc f0       	brlt	.+54     	; 0x730a <GetByteFromFIFO+0xba>
				GSM_RX_FIFOMax = GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End  + GSM_RX_FIFO_Begin;
		GSM_RX_FIFO_End++;
    72d4:	8e 2f       	mov	r24, r30
    72d6:	8f 5f       	subi	r24, 0xFF	; 255
    72d8:	80 93 53 06 	sts	0x0653, r24
		if(GSM_RX_FIFO_End >= GSM_RX_FIFO_SIZE) GSM_RX_FIFO_End = 0;
    72dc:	84 36       	cpi	r24, 0x64	; 100
    72de:	10 f0       	brcs	.+4      	; 0x72e4 <GetByteFromFIFO+0x94>
    72e0:	10 92 53 06 	sts	0x0653, r1
		ReadBuf[*Index] = GSM_RX_FIFO[GSM_RX_FIFO_End];
    72e4:	88 81       	ld	r24, Y
    72e6:	08 0f       	add	r16, r24
    72e8:	11 1d       	adc	r17, r1
    72ea:	e0 91 53 06 	lds	r30, 0x0653
    72ee:	f0 e0       	ldi	r31, 0x00	; 0
    72f0:	ef 51       	subi	r30, 0x1F	; 31
    72f2:	fa 4f       	sbci	r31, 0xFA	; 250
    72f4:	80 81       	ld	r24, Z
    72f6:	f8 01       	movw	r30, r16
    72f8:	80 83       	st	Z, r24
		*Index=*Index+1;
    72fa:	88 81       	ld	r24, Y
    72fc:	8f 5f       	subi	r24, 0xFF	; 255
    72fe:	88 83       	st	Y, r24
	}
}
    7300:	df 91       	pop	r29
    7302:	cf 91       	pop	r28
    7304:	1f 91       	pop	r17
    7306:	0f 91       	pop	r16
    7308:	08 95       	ret
		*Index=*Index+1;
	}
	if(GSM_RX_FIFO_End > GSM_RX_FIFO_Begin){
		if((GSM_RX_FIFO_End != 255)&&(GSM_RX_FIFO_End != 255))
			if(GSM_RX_FIFOMax < (GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End  + GSM_RX_FIFO_Begin))
				GSM_RX_FIFOMax = GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End  + GSM_RX_FIFO_Begin;
    730a:	80 91 3e 07 	lds	r24, 0x073E
    730e:	8c 59       	subi	r24, 0x9C	; 156
    7310:	8e 1b       	sub	r24, r30
    7312:	80 93 18 09 	sts	0x0918, r24
    7316:	de cf       	rjmp	.-68     	; 0x72d4 <GetByteFromFIFO+0x84>
	}	

	if(GSM_RX_FIFO_Begin > GSM_RX_FIFO_End){
		if((GSM_RX_FIFO_End != 255)&&(GSM_RX_FIFO_End != 255))			
			if(GSM_RX_FIFOMax < (GSM_RX_FIFO_Begin - GSM_RX_FIFO_End))
				GSM_RX_FIFOMax =  GSM_RX_FIFO_Begin - GSM_RX_FIFO_End;
    7318:	80 91 3e 07 	lds	r24, 0x073E
    731c:	8e 1b       	sub	r24, r30
    731e:	80 93 18 09 	sts	0x0918, r24
    7322:	b4 cf       	rjmp	.-152    	; 0x728c <GetByteFromFIFO+0x3c>

00007324 <GetStringFromFIFO>:
//        
uint8_t GetStringFromFIFO(void){

	uint8_t StrLength = 0;

	while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    7324:	90 91 3e 07 	lds	r25, 0x073E
    7328:	80 91 53 06 	lds	r24, 0x0653
    732c:	98 17       	cp	r25, r24
    732e:	39 f1       	breq	.+78     	; 0x737e <GetStringFromFIFO+0x5a>
		
		GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);
    7330:	80 ee       	ldi	r24, 0xE0	; 224
    7332:	97 e0       	ldi	r25, 0x07	; 7
    7334:	6f e5       	ldi	r22, 0x5F	; 95
    7336:	7b e0       	ldi	r23, 0x0B	; 11
    7338:	44 e6       	ldi	r20, 0x64	; 100
    733a:	0e 94 28 39 	call	0x7250	; 0x7250 <GetByteFromFIFO>

		//   : xxxxxxxxxxxxxxxx<CR><LF>
		//	'\r' CR - carridge return 0x0D
		//	'\n' LF - line feed 0x0A
		//   xxxxxxxxxxxxxxxx<\0>
		if( (GSM_RxCharN >= 2) && (GSM_RxStr[GSM_RxCharN-2]== '\r') && (GSM_RxStr[GSM_RxCharN-1]== '\n') ){
    733e:	80 91 5f 0b 	lds	r24, 0x0B5F
    7342:	82 30       	cpi	r24, 0x02	; 2
    7344:	78 f3       	brcs	.-34     	; 0x7324 <GetStringFromFIFO>
    7346:	e0 91 5f 0b 	lds	r30, 0x0B5F
    734a:	f0 e0       	ldi	r31, 0x00	; 0
    734c:	e2 52       	subi	r30, 0x22	; 34
    734e:	f8 4f       	sbci	r31, 0xF8	; 248
    7350:	80 81       	ld	r24, Z
    7352:	8d 30       	cpi	r24, 0x0D	; 13
    7354:	39 f7       	brne	.-50     	; 0x7324 <GetStringFromFIFO>
    7356:	e0 91 5f 0b 	lds	r30, 0x0B5F
    735a:	f0 e0       	ldi	r31, 0x00	; 0
    735c:	e1 52       	subi	r30, 0x21	; 33
    735e:	f8 4f       	sbci	r31, 0xF8	; 248
    7360:	80 81       	ld	r24, Z
    7362:	8a 30       	cpi	r24, 0x0A	; 10
    7364:	f9 f6       	brne	.-66     	; 0x7324 <GetStringFromFIFO>
			GSM_RxStr[GSM_RxCharN-2] = '\0';
    7366:	e0 91 5f 0b 	lds	r30, 0x0B5F
    736a:	f0 e0       	ldi	r31, 0x00	; 0
    736c:	e2 52       	subi	r30, 0x22	; 34
    736e:	f8 4f       	sbci	r31, 0xF8	; 248
    7370:	10 82       	st	Z, r1
			StrLength = GSM_RxCharN-1;
    7372:	80 91 5f 0b 	lds	r24, 0x0B5F
    7376:	81 50       	subi	r24, 0x01	; 1
			GSM_RxCharN = 0;
    7378:	10 92 5f 0b 	sts	0x0B5F, r1
    737c:	08 95       	ret
//        
uint8_t GetStringFromFIFO(void){

	uint8_t StrLength = 0;

	while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    737e:	80 e0       	ldi	r24, 0x00	; 0
		}

	}//while
	
	return StrLength;
}
    7380:	08 95       	ret

00007382 <GetStringFromFIFOwithOverflowDetect>:

uint8_t GetStringFromFIFOwithOverflowDetect(void){
    7382:	04 c0       	rjmp	.+8      	; 0x738c <GetStringFromFIFOwithOverflowDetect+0xa>

		//   : xxxxxxxxxxxxxxxx<CR><LF>
		//	'\r' CR - carridge return 0x0D
		//	'\n' LF - line feed 0x0A
		//   xxxxxxxxxxxxxxxx<\0>
		if( ((GSM_RxCharN >= 2) && (GSM_RxStr[GSM_RxCharN-2]== '\r') && (GSM_RxStr[GSM_RxCharN-1]== '\n'))||(GSM_RxCharN==GSM_RXSTR_SIZE-1) ){
    7384:	80 91 5f 0b 	lds	r24, 0x0B5F
    7388:	83 36       	cpi	r24, 0x63	; 99
    738a:	09 f1       	breq	.+66     	; 0x73ce <GetStringFromFIFOwithOverflowDetect+0x4c>

uint8_t GetStringFromFIFOwithOverflowDetect(void){

	uint8_t StrLength = 0;

	while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    738c:	90 91 3e 07 	lds	r25, 0x073E
    7390:	80 91 53 06 	lds	r24, 0x0653
    7394:	98 17       	cp	r25, r24
    7396:	39 f1       	breq	.+78     	; 0x73e6 <GetStringFromFIFOwithOverflowDetect+0x64>
		
		GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);
    7398:	80 ee       	ldi	r24, 0xE0	; 224
    739a:	97 e0       	ldi	r25, 0x07	; 7
    739c:	6f e5       	ldi	r22, 0x5F	; 95
    739e:	7b e0       	ldi	r23, 0x0B	; 11
    73a0:	44 e6       	ldi	r20, 0x64	; 100
    73a2:	0e 94 28 39 	call	0x7250	; 0x7250 <GetByteFromFIFO>

		//   : xxxxxxxxxxxxxxxx<CR><LF>
		//	'\r' CR - carridge return 0x0D
		//	'\n' LF - line feed 0x0A
		//   xxxxxxxxxxxxxxxx<\0>
		if( ((GSM_RxCharN >= 2) && (GSM_RxStr[GSM_RxCharN-2]== '\r') && (GSM_RxStr[GSM_RxCharN-1]== '\n'))||(GSM_RxCharN==GSM_RXSTR_SIZE-1) ){
    73a6:	80 91 5f 0b 	lds	r24, 0x0B5F
    73aa:	82 30       	cpi	r24, 0x02	; 2
    73ac:	58 f3       	brcs	.-42     	; 0x7384 <GetStringFromFIFOwithOverflowDetect+0x2>
    73ae:	e0 91 5f 0b 	lds	r30, 0x0B5F
    73b2:	f0 e0       	ldi	r31, 0x00	; 0
    73b4:	e2 52       	subi	r30, 0x22	; 34
    73b6:	f8 4f       	sbci	r31, 0xF8	; 248
    73b8:	80 81       	ld	r24, Z
    73ba:	8d 30       	cpi	r24, 0x0D	; 13
    73bc:	19 f7       	brne	.-58     	; 0x7384 <GetStringFromFIFOwithOverflowDetect+0x2>
    73be:	e0 91 5f 0b 	lds	r30, 0x0B5F
    73c2:	f0 e0       	ldi	r31, 0x00	; 0
    73c4:	e1 52       	subi	r30, 0x21	; 33
    73c6:	f8 4f       	sbci	r31, 0xF8	; 248
    73c8:	80 81       	ld	r24, Z
    73ca:	8a 30       	cpi	r24, 0x0A	; 10
    73cc:	d9 f6       	brne	.-74     	; 0x7384 <GetStringFromFIFOwithOverflowDetect+0x2>
			GSM_RxStr[GSM_RxCharN-2] = '\0';
    73ce:	e0 91 5f 0b 	lds	r30, 0x0B5F
    73d2:	f0 e0       	ldi	r31, 0x00	; 0
    73d4:	e2 52       	subi	r30, 0x22	; 34
    73d6:	f8 4f       	sbci	r31, 0xF8	; 248
    73d8:	10 82       	st	Z, r1
			StrLength = GSM_RxCharN-1;
    73da:	80 91 5f 0b 	lds	r24, 0x0B5F
    73de:	81 50       	subi	r24, 0x01	; 1
			GSM_RxCharN = 0;
    73e0:	10 92 5f 0b 	sts	0x0B5F, r1
    73e4:	08 95       	ret

uint8_t GetStringFromFIFOwithOverflowDetect(void){

	uint8_t StrLength = 0;

	while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    73e6:	80 e0       	ldi	r24, 0x00	; 0
		}

	}//while
	
	return StrLength;
}
    73e8:	08 95       	ret

000073ea <ForceEndStringFromFIFO>:
// ~~~~~~~~~~~
//    GSM_RxStr  <CR><LF>
uint8_t ForceEndStringFromFIFO(void){
	uint8_t StrLength;
	if(GSM_RxCharN > GSM_RXSTR_SIZE-1) GSM_RxCharN = GSM_RXSTR_SIZE-1;
    73ea:	80 91 5f 0b 	lds	r24, 0x0B5F
    73ee:	84 36       	cpi	r24, 0x64	; 100
    73f0:	18 f0       	brcs	.+6      	; 0x73f8 <ForceEndStringFromFIFO+0xe>
    73f2:	83 e6       	ldi	r24, 0x63	; 99
    73f4:	80 93 5f 0b 	sts	0x0B5F, r24
	StrLength = GSM_RxCharN;
    73f8:	80 91 5f 0b 	lds	r24, 0x0B5F
	GSM_RxStr[GSM_RxCharN]='\0';
    73fc:	e0 91 5f 0b 	lds	r30, 0x0B5F
    7400:	f0 e0       	ldi	r31, 0x00	; 0
    7402:	e0 52       	subi	r30, 0x20	; 32
    7404:	f8 4f       	sbci	r31, 0xF8	; 248
    7406:	10 82       	st	Z, r1
	GSM_RxCharN = 0;
    7408:	10 92 5f 0b 	sts	0x0B5F, r1
	return StrLength;
}
    740c:	08 95       	ret

0000740e <GetDataFromFIFO>:

// ~~~~~~~~~~~
uint8_t GetDataFromFIFO(const uint8_t Amount){
    740e:	1f 93       	push	r17
    7410:	18 2f       	mov	r17, r24

	while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    7412:	90 91 3e 07 	lds	r25, 0x073E
    7416:	80 91 53 06 	lds	r24, 0x0653
    741a:	98 17       	cp	r25, r24
    741c:	81 f0       	breq	.+32     	; 0x743e <GetDataFromFIFO+0x30>
		GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);
    741e:	80 ee       	ldi	r24, 0xE0	; 224
    7420:	97 e0       	ldi	r25, 0x07	; 7
    7422:	6f e5       	ldi	r22, 0x5F	; 95
    7424:	7b e0       	ldi	r23, 0x0B	; 11
    7426:	44 e6       	ldi	r20, 0x64	; 100
    7428:	0e 94 28 39 	call	0x7250	; 0x7250 <GetByteFromFIFO>
		if(GSM_RxCharN >= Amount){
    742c:	80 91 5f 0b 	lds	r24, 0x0B5F
    7430:	81 17       	cp	r24, r17
    7432:	78 f3       	brcs	.-34     	; 0x7412 <GetDataFromFIFO+0x4>
			GSM_RxCharN = 0;
    7434:	10 92 5f 0b 	sts	0x0B5F, r1
			return Amount;
		}
	}//while
	return GSM_RxCharN;
}
    7438:	81 2f       	mov	r24, r17
    743a:	1f 91       	pop	r17
    743c:	08 95       	ret
		if(GSM_RxCharN >= Amount){
			GSM_RxCharN = 0;
			return Amount;
		}
	}//while
	return GSM_RxCharN;
    743e:	10 91 5f 0b 	lds	r17, 0x0B5F
}
    7442:	81 2f       	mov	r24, r17
    7444:	1f 91       	pop	r17
    7446:	08 95       	ret

00007448 <GSM_Init>:
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    7448:	8f ef       	ldi	r24, 0xFF	; 255
    744a:	80 93 3e 07 	sts	0x073E, r24
	GSM_RX_FIFO_End = 255;
    744e:	80 93 53 06 	sts	0x0653, r24
	GSM_RxCharN = 0;
    7452:	10 92 5f 0b 	sts	0x0B5F, r1
	GSM_RX_FIFOOverFlow = 0;
    7456:	10 92 12 09 	sts	0x0912, r1
	GSM_RX_FIFOMax = 0;
    745a:	10 92 18 09 	sts	0x0918, r1
		USART_GSM.BAUDCTRLB = 0x00 + USART_BSCALE0_bm;
		USART_GSM.CTRLA = USART_RXCINTLVL_HI_gc;
		USART_GSM.CTRLB = (1<<USART_RXEN_bp) | (1<<USART_TXEN_bp) | (0<<USART_CLK2X_bp) | (0 << USART_MPCM_bp) | (0 << USART_TXB8_bp);
		USART_GSM.CTRLC = USART_CMODE_ASYNCHRONOUS_gc | USART_PMODE_DISABLED_gc | (0<< USART_SBMODE_bp) | USART_CHSIZE_8BIT_gc;
	#else
		UCSR_GSM_A = ~(1<<U2X_GSM) &~(1<<MPCM_GSM);
    745e:	8c ef       	ldi	r24, 0xFC	; 252
    7460:	80 93 d0 00 	sts	0x00D0, r24
		UCSR_GSM_B =  (1<<RXCIE_GSM) | (0<<TXCIE_GSM) | (0<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    7464:	88 e9       	ldi	r24, 0x98	; 152
    7466:	80 93 d1 00 	sts	0x00D1, r24
		#if defined (__AVR_ATmega2561__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__)			
			UCSR_GSM_C = (0<<UMSEL_GSM_1) | (0<<UMSEL_GSM_0) | (0<<UPM_GSM_1) | (0<<UPM_GSM_0) | (0<<USBS_GSM) | (1<<UCSZ_GSM_1) | (1<<UCSZ_GSM_0) | (0<<UCPOL_GSM);
    746a:	86 e0       	ldi	r24, 0x06	; 6
    746c:	80 93 d2 00 	sts	0x00D2, r24
		#else
			UCSR_GSM_C = ((~(1<<UMSEL_GSM) &~(1<<UPM_GSM_1) &~(1<<UPM_GSM_0) &~(1<<USBS_GSM)) |(1<<UCSZ_GSM_1) |(1<<UCSZ_GSM_0)) &~(1<<UCPOL_GSM);
		#endif
		UBRR_GSM_H = 0x00;
    7470:	10 92 d5 00 	sts	0x00D5, r1
		UBRR_GSM_L = 0x67;	// 9600
    7474:	87 e6       	ldi	r24, 0x67	; 103
    7476:	80 93 d4 00 	sts	0x00D4, r24
#endif

//  gsm_sim900r.h   PWRCNTRL
#ifdef vmd2_3
	void GSM_PWRCNTRL_Config(void){
		cli();
    747a:	f8 94       	cli
		DDRL|=(1<<PL5);
    747c:	ea e0       	ldi	r30, 0x0A	; 10
    747e:	f1 e0       	ldi	r31, 0x01	; 1
    7480:	80 81       	ld	r24, Z
    7482:	80 62       	ori	r24, 0x20	; 32
    7484:	80 83       	st	Z, r24
		sei();
    7486:	78 94       	sei
		cli();
		PORTL|=(1<<PL5);
		sei();
	}
	void GSM_PWRCNTRL_ON(void){
		cli();
    7488:	f8 94       	cli
		PORTL &= ~(1<<PL5);
    748a:	eb e0       	ldi	r30, 0x0B	; 11
    748c:	f1 e0       	ldi	r31, 0x01	; 1
    748e:	80 81       	ld	r24, Z
    7490:	8f 7d       	andi	r24, 0xDF	; 223
    7492:	80 83       	st	Z, r24
		sei();
    7494:	78 94       	sei

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    7496:	80 91 d0 02 	lds	r24, 0x02D0
	VacantTimer16Sys += n;
    749a:	98 2f       	mov	r25, r24
    749c:	9f 5f       	subi	r25, 0xFF	; 255
	GSM_PWRCNTRL_ON();
	#ifdef GSM_HW_FLOW_CONTROL
		GSM_CTS_RTS_Config();
	#endif

	TD_GSM = Timer16SysAlloc(1);
    749e:	80 93 e9 04 	sts	0x04E9, r24
    74a2:	29 2f       	mov	r18, r25
    74a4:	2f 5f       	subi	r18, 0xFF	; 255
	TD_TCP_Connect = Timer16SysAlloc(1);
    74a6:	90 93 ea 04 	sts	0x04EA, r25

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer32SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer32Sys;
    74aa:	90 91 d1 02 	lds	r25, 0x02D1
	VacantTimer32Sys += n;
    74ae:	89 2f       	mov	r24, r25
    74b0:	8f 5f       	subi	r24, 0xFF	; 255
	TD_GSM_Reset = Timer32SysAlloc(1);
    74b2:	90 93 eb 04 	sts	0x04EB, r25
// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
	VacantTimer16Sys += n;
    74b6:	92 2f       	mov	r25, r18
    74b8:	9f 5f       	subi	r25, 0xFF	; 255
	TD_5min_timer = Timer16SysAlloc(1);
    74ba:	20 93 ec 04 	sts	0x04EC, r18
// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer32SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer32Sys;
	VacantTimer32Sys += n;
    74be:	8f 5f       	subi	r24, 0xFF	; 255
    74c0:	80 93 d1 02 	sts	0x02D1, r24
    74c4:	81 50       	subi	r24, 0x01	; 1
	TD_1hour_resetGPRS_timer = Timer32SysAlloc(1);
    74c6:	80 93 ed 04 	sts	0x04ED, r24
// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
	VacantTimer16Sys += n;
    74ca:	89 2f       	mov	r24, r25
    74cc:	8f 5f       	subi	r24, 0xFF	; 255
	TD_CheckModem = Timer16SysAlloc(1);
    74ce:	90 93 ee 04 	sts	0x04EE, r25
    74d2:	9e 5f       	subi	r25, 0xFE	; 254
	TD_CleanFIFO = Timer16SysAlloc(1);
    74d4:	80 93 ef 04 	sts	0x04EF, r24
    74d8:	8e 5f       	subi	r24, 0xFE	; 254
	TD_data_start_delay = Timer16SysAlloc(1);
    74da:	90 93 f0 04 	sts	0x04F0, r25
    74de:	8f 5f       	subi	r24, 0xFF	; 255
    74e0:	80 93 d0 02 	sts	0x02D0, r24
    74e4:	81 50       	subi	r24, 0x01	; 1
	TD_timer_after_page_transfer = Timer16SysAlloc(1);
    74e6:	80 93 f1 04 	sts	0x04F1, r24

/*	for (uint8_t i=0; i<4; i++)
		GPRS_ServerAddr[i] = erb(GPRS_ServerAddr_EE+i);
*/
	GSM_Control = GSM_CNTL_AUTO;
    74ea:	10 92 d0 07 	sts	0x07D0, r1
	GSM_State = GSM_PowerOn;
    74ee:	10 92 f6 06 	sts	0x06F6, r1



}
    74f2:	08 95       	ret

000074f4 <GSM_RX>:
// ~~~~~~~~~
void
GSM_RX(void)
{
	char Char = UDR_GSM;
    74f4:	90 91 d6 00 	lds	r25, 0x00D6

	//---FIFO
	GSM_RX_FIFO_Begin++;
    74f8:	80 91 3e 07 	lds	r24, 0x073E
    74fc:	8f 5f       	subi	r24, 0xFF	; 255
    74fe:	80 93 3e 07 	sts	0x073E, r24
	if(GSM_RX_FIFO_Begin >= GSM_RX_FIFO_SIZE) GSM_RX_FIFO_Begin = 0;
    7502:	80 91 3e 07 	lds	r24, 0x073E
    7506:	84 36       	cpi	r24, 0x64	; 100
    7508:	10 f0       	brcs	.+4      	; 0x750e <GSM_RX+0x1a>
    750a:	10 92 3e 07 	sts	0x073E, r1
	GSM_RX_FIFO[GSM_RX_FIFO_Begin] = Char;
    750e:	e0 91 3e 07 	lds	r30, 0x073E
    7512:	f0 e0       	ldi	r31, 0x00	; 0
    7514:	ef 51       	subi	r30, 0x1F	; 31
    7516:	fa 4f       	sbci	r31, 0xFA	; 250
    7518:	90 83       	st	Z, r25
	if(GSM_RX_FIFO_Begin == GSM_RX_FIFO_End){
    751a:	90 91 3e 07 	lds	r25, 0x073E
    751e:	80 91 53 06 	lds	r24, 0x0653
    7522:	98 13       	cpse	r25, r24
    7524:	08 95       	ret
		GSM_RX_FIFOOverFlow = 1;
    7526:	81 e0       	ldi	r24, 0x01	; 1
    7528:	80 93 12 09 	sts	0x0912, r24
		GSM_RX_FIFOMax = GSM_RX_FIFO_SIZE;
    752c:	84 e6       	ldi	r24, 0x64	; 100
    752e:	80 93 18 09 	sts	0x0918, r24
    7532:	08 95       	ret

00007534 <GSM_Wait_Char>:
		else return 1;
	}
	else return 0;
}
// ~~~~~~~~~
uint8_t GSM_Wait_Char(char Char, uint8_t RestoreCMD){
    7534:	0f 93       	push	r16
    7536:	1f 93       	push	r17
    7538:	08 2f       	mov	r16, r24
    753a:	16 2f       	mov	r17, r22
	if(Timer16Stopp(TD_GSM)){
    753c:	80 91 e9 04 	lds	r24, 0x04E9
    7540:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <Timer16Stopp>
    7544:	88 23       	and	r24, r24
    7546:	39 f0       	breq	.+14     	; 0x7556 <GSM_Wait_Char+0x22>
		GSM_State = RestoreCMD;
    7548:	10 93 f6 06 	sts	0x06F6, r17
    754c:	90 e0       	ldi	r25, 0x00	; 0
	if(GetDataFromFIFO(1)){
		if(GSM_RxStr[0] == Char)	return 1;
		else return 0;
	}
	else return 0;
}
    754e:	89 2f       	mov	r24, r25
    7550:	1f 91       	pop	r17
    7552:	0f 91       	pop	r16
    7554:	08 95       	ret
	if(Timer16Stopp(TD_GSM)){
		GSM_State = RestoreCMD;
		return 0;
	}
	//   
	if(GetDataFromFIFO(1)){
    7556:	81 e0       	ldi	r24, 0x01	; 1
    7558:	0e 94 07 3a 	call	0x740e	; 0x740e <GetDataFromFIFO>
    755c:	88 23       	and	r24, r24
    755e:	39 f0       	breq	.+14     	; 0x756e <GSM_Wait_Char+0x3a>
    7560:	90 e0       	ldi	r25, 0x00	; 0
    7562:	80 91 e0 07 	lds	r24, 0x07E0
    7566:	80 17       	cp	r24, r16
    7568:	91 f7       	brne	.-28     	; 0x754e <GSM_Wait_Char+0x1a>
    756a:	91 e0       	ldi	r25, 0x01	; 1
    756c:	f0 cf       	rjmp	.-32     	; 0x754e <GSM_Wait_Char+0x1a>
    756e:	90 e0       	ldi	r25, 0x00	; 0
		if(GSM_RxStr[0] == Char)	return 1;
		else return 0;
	}
	else return 0;
}
    7570:	89 2f       	mov	r24, r25
    7572:	1f 91       	pop	r17
    7574:	0f 91       	pop	r16
    7576:	08 95       	ret

00007578 <GSM_SendFirstChar>:
// ~~~~~~~~~
void GSM_SendFirstChar(void){

	UDR_GSM = GSM_TxStr[0];
    7578:	80 91 49 0a 	lds	r24, 0x0A49
    757c:	80 93 d6 00 	sts	0x00D6, r24
	#ifdef GSM_DEBUG
		GPRS_TerminalProcess(GSM_TxStr[0]);
	#endif

	GSM_TxCharN = 1;
    7580:	81 e0       	ldi	r24, 0x01	; 1
    7582:	80 93 68 0b 	sts	0x0B68, r24
	cli();
    7586:	f8 94       	cli
	GSM_Flag &=~(1<<flg_TxCStr);	
    7588:	80 91 d2 02 	lds	r24, 0x02D2
    758c:	8e 7f       	andi	r24, 0xFE	; 254
    758e:	80 93 d2 02 	sts	0x02D2, r24
	sei();
    7592:	78 94       	sei
	cli();
    7594:	f8 94       	cli
	#if defined (__AVR_ATxmega128A1__)
		USART_GSM.CTRLA = USART_RXCINTLVL_HI_gc | USART_DREINTLVL_HI_gc;
	#else
		UCSR_GSM_B =  (1<<RXCIE_GSM) | (0<<TXCIE_GSM) | (1<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    7596:	88 eb       	ldi	r24, 0xB8	; 184
    7598:	80 93 d1 00 	sts	0x00D1, r24
	#endif
	
	sei();	
    759c:	78 94       	sei
}
    759e:	08 95       	ret

000075a0 <GSM_DRE>:
		StartTimer16(TD_GSM, Timeout);
	}
}
// ~~~~~~~~~
void GSM_DRE(void){
	if(GSM_TxCharN < GSMTxSz){
    75a0:	90 91 68 0b 	lds	r25, 0x0B68
    75a4:	80 91 bb 07 	lds	r24, 0x07BB
    75a8:	98 17       	cp	r25, r24
    75aa:	20 f0       	brcs	.+8      	; 0x75b4 <GSM_DRE+0x14>
	}
	else{
		#if defined (__AVR_ATxmega128A1__)
			USART_GSM.CTRLA = USART_RXCINTLVL_HI_gc | USART_TXCINTLVL_HI_gc;
		#else
			UCSR_GSM_B =  (1<<RXCIE_GSM) | (1<<TXCIE_GSM) | (0<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    75ac:	88 ed       	ldi	r24, 0xD8	; 216
    75ae:	80 93 d1 00 	sts	0x00D1, r24
    75b2:	08 95       	ret
	}
}
// ~~~~~~~~~
void GSM_DRE(void){
	if(GSM_TxCharN < GSMTxSz){
		UDR_GSM = GSM_TxStr[GSM_TxCharN];
    75b4:	e0 91 68 0b 	lds	r30, 0x0B68
    75b8:	f0 e0       	ldi	r31, 0x00	; 0
    75ba:	e7 5b       	subi	r30, 0xB7	; 183
    75bc:	f5 4f       	sbci	r31, 0xF5	; 245
    75be:	80 81       	ld	r24, Z
    75c0:	80 93 d6 00 	sts	0x00D6, r24
		#ifdef GSM_DEBUG
			GPRS_TerminalProcess(GSM_TxStr[GSM_TxCharN]);
		#endif
		GSM_TxCharN++;
    75c4:	80 91 68 0b 	lds	r24, 0x0B68
    75c8:	8f 5f       	subi	r24, 0xFF	; 255
    75ca:	80 93 68 0b 	sts	0x0B68, r24
    75ce:	08 95       	ret

000075d0 <GSM_TX>:
}
// ~~~~~~~~~
void
GSM_TX(void)
{
	GSM_Flag |=(1<<flg_TxCStr);
    75d0:	80 91 d2 02 	lds	r24, 0x02D2
    75d4:	81 60       	ori	r24, 0x01	; 1
    75d6:	80 93 d2 02 	sts	0x02D2, r24
	if(dataSendFlg){
    75da:	80 91 df 02 	lds	r24, 0x02DF
    75de:	88 23       	and	r24, r24
    75e0:	21 f0       	breq	.+8      	; 0x75ea <GSM_TX+0x1a>
	dataSendFlg=0;
    75e2:	10 92 df 02 	sts	0x02DF, r1
	GPRS_FlgSz_Out=0;
    75e6:	10 92 b1 07 	sts	0x07B1, r1
	}
	#if defined (__AVR_ATxmega128A1__)
		USART_GSM.CTRLA = USART_RXCINTLVL_HI_gc;
	#else
		UCSR_GSM_B =  (1<<RXCIE_GSM) | (0<<TXCIE_GSM) | (0<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    75ea:	88 e9       	ldi	r24, 0x98	; 152
    75ec:	80 93 d1 00 	sts	0x00D1, r24
	#endif
}
    75f0:	08 95       	ret

000075f2 <GSM_Reset>:
GSM_Reset(void)
{
/*	IntOff();
	GSM_State = GSM_Restart;
	IntOn();*/
}
    75f2:	08 95       	ret

000075f4 <GSM_GotoNextVega>:

uint8_t GSM_GotoNextVega(void){
 return 0;
}
    75f4:	80 e0       	ldi	r24, 0x00	; 0
    75f6:	08 95       	ret

000075f8 <GSM_GetConfirmState>:
}
uint8_t ConfirmState = 0;
uint8_t RequestRepeatCounter = 0;
uint8_t TransmitterState = 0;
uint8_t GSM_GetConfirmState(){
	if(1 == ConfirmState){
    75f8:	80 91 e1 02 	lds	r24, 0x02E1
    75fc:	81 30       	cpi	r24, 0x01	; 1
    75fe:	11 f0       	breq	.+4      	; 0x7604 <GSM_GetConfirmState+0xc>
    7600:	80 e0       	ldi	r24, 0x00	; 0
    7602:	08 95       	ret
		ConfirmState = 0;
    7604:	10 92 e1 02 	sts	0x02E1, r1
    7608:	81 e0       	ldi	r24, 0x01	; 1
		return 1;
	}
	else return 0;
}
    760a:	08 95       	ret

0000760c <GPRS_ServerAddr_Save>:
// ~~~~~~~~~~~~~~~~~~~~~~~~
void
GPRS_ServerAddr_Save(void)
{

}
    760c:	08 95       	ret

0000760e <__vector_25>:
#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__)
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	#ifdef vmd2_3
		// ~~~~~~~~~~
		// USART0 - PORT0
		Modbus_ISR(0)
    760e:	1f 92       	push	r1
    7610:	0f 92       	push	r0
    7612:	0f b6       	in	r0, 0x3f	; 63
    7614:	0f 92       	push	r0
    7616:	0b b6       	in	r0, 0x3b	; 59
    7618:	0f 92       	push	r0
    761a:	11 24       	eor	r1, r1
    761c:	2f 93       	push	r18
    761e:	3f 93       	push	r19
    7620:	4f 93       	push	r20
    7622:	5f 93       	push	r21
    7624:	6f 93       	push	r22
    7626:	7f 93       	push	r23
    7628:	8f 93       	push	r24
    762a:	9f 93       	push	r25
    762c:	af 93       	push	r26
    762e:	bf 93       	push	r27
    7630:	ef 93       	push	r30
    7632:	ff 93       	push	r31
    7634:	86 ec       	ldi	r24, 0xC6	; 198
    7636:	90 e0       	ldi	r25, 0x00	; 0
    7638:	0e 94 f2 2a 	call	0x55e4	; 0x55e4 <Modbus_RX>
    763c:	ff 91       	pop	r31
    763e:	ef 91       	pop	r30
    7640:	bf 91       	pop	r27
    7642:	af 91       	pop	r26
    7644:	9f 91       	pop	r25
    7646:	8f 91       	pop	r24
    7648:	7f 91       	pop	r23
    764a:	6f 91       	pop	r22
    764c:	5f 91       	pop	r21
    764e:	4f 91       	pop	r20
    7650:	3f 91       	pop	r19
    7652:	2f 91       	pop	r18
    7654:	0f 90       	pop	r0
    7656:	0b be       	out	0x3b, r0	; 59
    7658:	0f 90       	pop	r0
    765a:	0f be       	out	0x3f, r0	; 63
    765c:	0f 90       	pop	r0
    765e:	1f 90       	pop	r1
    7660:	18 95       	reti

00007662 <__vector_27>:
    7662:	1f 92       	push	r1
    7664:	0f 92       	push	r0
    7666:	0f b6       	in	r0, 0x3f	; 63
    7668:	0f 92       	push	r0
    766a:	0b b6       	in	r0, 0x3b	; 59
    766c:	0f 92       	push	r0
    766e:	11 24       	eor	r1, r1
    7670:	2f 93       	push	r18
    7672:	3f 93       	push	r19
    7674:	4f 93       	push	r20
    7676:	5f 93       	push	r21
    7678:	6f 93       	push	r22
    767a:	7f 93       	push	r23
    767c:	8f 93       	push	r24
    767e:	9f 93       	push	r25
    7680:	af 93       	push	r26
    7682:	bf 93       	push	r27
    7684:	ef 93       	push	r30
    7686:	ff 93       	push	r31
    7688:	86 ec       	ldi	r24, 0xC6	; 198
    768a:	90 e0       	ldi	r25, 0x00	; 0
    768c:	0e 94 91 36 	call	0x6d22	; 0x6d22 <Modbus_TX>
    7690:	ff 91       	pop	r31
    7692:	ef 91       	pop	r30
    7694:	bf 91       	pop	r27
    7696:	af 91       	pop	r26
    7698:	9f 91       	pop	r25
    769a:	8f 91       	pop	r24
    769c:	7f 91       	pop	r23
    769e:	6f 91       	pop	r22
    76a0:	5f 91       	pop	r21
    76a2:	4f 91       	pop	r20
    76a4:	3f 91       	pop	r19
    76a6:	2f 91       	pop	r18
    76a8:	0f 90       	pop	r0
    76aa:	0b be       	out	0x3b, r0	; 59
    76ac:	0f 90       	pop	r0
    76ae:	0f be       	out	0x3f, r0	; 63
    76b0:	0f 90       	pop	r0
    76b2:	1f 90       	pop	r1
    76b4:	18 95       	reti

000076b6 <__vector_26>:
    76b6:	1f 92       	push	r1
    76b8:	0f 92       	push	r0
    76ba:	0f b6       	in	r0, 0x3f	; 63
    76bc:	0f 92       	push	r0
    76be:	0b b6       	in	r0, 0x3b	; 59
    76c0:	0f 92       	push	r0
    76c2:	11 24       	eor	r1, r1
    76c4:	2f 93       	push	r18
    76c6:	3f 93       	push	r19
    76c8:	4f 93       	push	r20
    76ca:	5f 93       	push	r21
    76cc:	6f 93       	push	r22
    76ce:	7f 93       	push	r23
    76d0:	8f 93       	push	r24
    76d2:	9f 93       	push	r25
    76d4:	af 93       	push	r26
    76d6:	bf 93       	push	r27
    76d8:	ef 93       	push	r30
    76da:	ff 93       	push	r31
    76dc:	86 ec       	ldi	r24, 0xC6	; 198
    76de:	90 e0       	ldi	r25, 0x00	; 0
    76e0:	0e 94 91 36 	call	0x6d22	; 0x6d22 <Modbus_TX>
    76e4:	ff 91       	pop	r31
    76e6:	ef 91       	pop	r30
    76e8:	bf 91       	pop	r27
    76ea:	af 91       	pop	r26
    76ec:	9f 91       	pop	r25
    76ee:	8f 91       	pop	r24
    76f0:	7f 91       	pop	r23
    76f2:	6f 91       	pop	r22
    76f4:	5f 91       	pop	r21
    76f6:	4f 91       	pop	r20
    76f8:	3f 91       	pop	r19
    76fa:	2f 91       	pop	r18
    76fc:	0f 90       	pop	r0
    76fe:	0b be       	out	0x3b, r0	; 59
    7700:	0f 90       	pop	r0
    7702:	0f be       	out	0x3f, r0	; 63
    7704:	0f 90       	pop	r0
    7706:	1f 90       	pop	r1
    7708:	18 95       	reti

0000770a <__vector_36>:

		// ~~~~~~~~~~
		// USART1 - PORT1
		Modbus_ISR(1)
    770a:	1f 92       	push	r1
    770c:	0f 92       	push	r0
    770e:	0f b6       	in	r0, 0x3f	; 63
    7710:	0f 92       	push	r0
    7712:	0b b6       	in	r0, 0x3b	; 59
    7714:	0f 92       	push	r0
    7716:	11 24       	eor	r1, r1
    7718:	2f 93       	push	r18
    771a:	3f 93       	push	r19
    771c:	4f 93       	push	r20
    771e:	5f 93       	push	r21
    7720:	6f 93       	push	r22
    7722:	7f 93       	push	r23
    7724:	8f 93       	push	r24
    7726:	9f 93       	push	r25
    7728:	af 93       	push	r26
    772a:	bf 93       	push	r27
    772c:	ef 93       	push	r30
    772e:	ff 93       	push	r31
    7730:	8e ec       	ldi	r24, 0xCE	; 206
    7732:	90 e0       	ldi	r25, 0x00	; 0
    7734:	0e 94 f2 2a 	call	0x55e4	; 0x55e4 <Modbus_RX>
    7738:	ff 91       	pop	r31
    773a:	ef 91       	pop	r30
    773c:	bf 91       	pop	r27
    773e:	af 91       	pop	r26
    7740:	9f 91       	pop	r25
    7742:	8f 91       	pop	r24
    7744:	7f 91       	pop	r23
    7746:	6f 91       	pop	r22
    7748:	5f 91       	pop	r21
    774a:	4f 91       	pop	r20
    774c:	3f 91       	pop	r19
    774e:	2f 91       	pop	r18
    7750:	0f 90       	pop	r0
    7752:	0b be       	out	0x3b, r0	; 59
    7754:	0f 90       	pop	r0
    7756:	0f be       	out	0x3f, r0	; 63
    7758:	0f 90       	pop	r0
    775a:	1f 90       	pop	r1
    775c:	18 95       	reti

0000775e <__vector_38>:
    775e:	1f 92       	push	r1
    7760:	0f 92       	push	r0
    7762:	0f b6       	in	r0, 0x3f	; 63
    7764:	0f 92       	push	r0
    7766:	0b b6       	in	r0, 0x3b	; 59
    7768:	0f 92       	push	r0
    776a:	11 24       	eor	r1, r1
    776c:	2f 93       	push	r18
    776e:	3f 93       	push	r19
    7770:	4f 93       	push	r20
    7772:	5f 93       	push	r21
    7774:	6f 93       	push	r22
    7776:	7f 93       	push	r23
    7778:	8f 93       	push	r24
    777a:	9f 93       	push	r25
    777c:	af 93       	push	r26
    777e:	bf 93       	push	r27
    7780:	ef 93       	push	r30
    7782:	ff 93       	push	r31
    7784:	8e ec       	ldi	r24, 0xCE	; 206
    7786:	90 e0       	ldi	r25, 0x00	; 0
    7788:	0e 94 91 36 	call	0x6d22	; 0x6d22 <Modbus_TX>
    778c:	ff 91       	pop	r31
    778e:	ef 91       	pop	r30
    7790:	bf 91       	pop	r27
    7792:	af 91       	pop	r26
    7794:	9f 91       	pop	r25
    7796:	8f 91       	pop	r24
    7798:	7f 91       	pop	r23
    779a:	6f 91       	pop	r22
    779c:	5f 91       	pop	r21
    779e:	4f 91       	pop	r20
    77a0:	3f 91       	pop	r19
    77a2:	2f 91       	pop	r18
    77a4:	0f 90       	pop	r0
    77a6:	0b be       	out	0x3b, r0	; 59
    77a8:	0f 90       	pop	r0
    77aa:	0f be       	out	0x3f, r0	; 63
    77ac:	0f 90       	pop	r0
    77ae:	1f 90       	pop	r1
    77b0:	18 95       	reti

000077b2 <__vector_37>:
    77b2:	1f 92       	push	r1
    77b4:	0f 92       	push	r0
    77b6:	0f b6       	in	r0, 0x3f	; 63
    77b8:	0f 92       	push	r0
    77ba:	0b b6       	in	r0, 0x3b	; 59
    77bc:	0f 92       	push	r0
    77be:	11 24       	eor	r1, r1
    77c0:	2f 93       	push	r18
    77c2:	3f 93       	push	r19
    77c4:	4f 93       	push	r20
    77c6:	5f 93       	push	r21
    77c8:	6f 93       	push	r22
    77ca:	7f 93       	push	r23
    77cc:	8f 93       	push	r24
    77ce:	9f 93       	push	r25
    77d0:	af 93       	push	r26
    77d2:	bf 93       	push	r27
    77d4:	ef 93       	push	r30
    77d6:	ff 93       	push	r31
    77d8:	8e ec       	ldi	r24, 0xCE	; 206
    77da:	90 e0       	ldi	r25, 0x00	; 0
    77dc:	0e 94 91 36 	call	0x6d22	; 0x6d22 <Modbus_TX>
    77e0:	ff 91       	pop	r31
    77e2:	ef 91       	pop	r30
    77e4:	bf 91       	pop	r27
    77e6:	af 91       	pop	r26
    77e8:	9f 91       	pop	r25
    77ea:	8f 91       	pop	r24
    77ec:	7f 91       	pop	r23
    77ee:	6f 91       	pop	r22
    77f0:	5f 91       	pop	r21
    77f2:	4f 91       	pop	r20
    77f4:	3f 91       	pop	r19
    77f6:	2f 91       	pop	r18
    77f8:	0f 90       	pop	r0
    77fa:	0b be       	out	0x3b, r0	; 59
    77fc:	0f 90       	pop	r0
    77fe:	0f be       	out	0x3f, r0	; 63
    7800:	0f 90       	pop	r0
    7802:	1f 90       	pop	r1
    7804:	18 95       	reti

00007806 <__vector_52>:

		// USART2 - PORT2 (only GSM)
		#ifdef GSM
			#ifndef SIM300DZ
				ISR(USART2_UDRE_vect) {GSM_DRE();}
    7806:	1f 92       	push	r1
    7808:	0f 92       	push	r0
    780a:	0f b6       	in	r0, 0x3f	; 63
    780c:	0f 92       	push	r0
    780e:	0b b6       	in	r0, 0x3b	; 59
    7810:	0f 92       	push	r0
    7812:	11 24       	eor	r1, r1
    7814:	2f 93       	push	r18
    7816:	3f 93       	push	r19
    7818:	4f 93       	push	r20
    781a:	5f 93       	push	r21
    781c:	6f 93       	push	r22
    781e:	7f 93       	push	r23
    7820:	8f 93       	push	r24
    7822:	9f 93       	push	r25
    7824:	af 93       	push	r26
    7826:	bf 93       	push	r27
    7828:	ef 93       	push	r30
    782a:	ff 93       	push	r31
    782c:	0e 94 d0 3a 	call	0x75a0	; 0x75a0 <GSM_DRE>
    7830:	ff 91       	pop	r31
    7832:	ef 91       	pop	r30
    7834:	bf 91       	pop	r27
    7836:	af 91       	pop	r26
    7838:	9f 91       	pop	r25
    783a:	8f 91       	pop	r24
    783c:	7f 91       	pop	r23
    783e:	6f 91       	pop	r22
    7840:	5f 91       	pop	r21
    7842:	4f 91       	pop	r20
    7844:	3f 91       	pop	r19
    7846:	2f 91       	pop	r18
    7848:	0f 90       	pop	r0
    784a:	0b be       	out	0x3b, r0	; 59
    784c:	0f 90       	pop	r0
    784e:	0f be       	out	0x3f, r0	; 63
    7850:	0f 90       	pop	r0
    7852:	1f 90       	pop	r1
    7854:	18 95       	reti

00007856 <__vector_53>:
			#endif
			ISR(USART2_TX_vect) {GSM_TX();}
    7856:	1f 92       	push	r1
    7858:	0f 92       	push	r0
    785a:	0f b6       	in	r0, 0x3f	; 63
    785c:	0f 92       	push	r0
    785e:	0b b6       	in	r0, 0x3b	; 59
    7860:	0f 92       	push	r0
    7862:	11 24       	eor	r1, r1
    7864:	2f 93       	push	r18
    7866:	3f 93       	push	r19
    7868:	4f 93       	push	r20
    786a:	5f 93       	push	r21
    786c:	6f 93       	push	r22
    786e:	7f 93       	push	r23
    7870:	8f 93       	push	r24
    7872:	9f 93       	push	r25
    7874:	af 93       	push	r26
    7876:	bf 93       	push	r27
    7878:	ef 93       	push	r30
    787a:	ff 93       	push	r31
    787c:	0e 94 e8 3a 	call	0x75d0	; 0x75d0 <GSM_TX>
    7880:	ff 91       	pop	r31
    7882:	ef 91       	pop	r30
    7884:	bf 91       	pop	r27
    7886:	af 91       	pop	r26
    7888:	9f 91       	pop	r25
    788a:	8f 91       	pop	r24
    788c:	7f 91       	pop	r23
    788e:	6f 91       	pop	r22
    7890:	5f 91       	pop	r21
    7892:	4f 91       	pop	r20
    7894:	3f 91       	pop	r19
    7896:	2f 91       	pop	r18
    7898:	0f 90       	pop	r0
    789a:	0b be       	out	0x3b, r0	; 59
    789c:	0f 90       	pop	r0
    789e:	0f be       	out	0x3f, r0	; 63
    78a0:	0f 90       	pop	r0
    78a2:	1f 90       	pop	r1
    78a4:	18 95       	reti

000078a6 <__vector_51>:
			ISR(USART2_RX_vect) {GSM_RX();}
    78a6:	1f 92       	push	r1
    78a8:	0f 92       	push	r0
    78aa:	0f b6       	in	r0, 0x3f	; 63
    78ac:	0f 92       	push	r0
    78ae:	0b b6       	in	r0, 0x3b	; 59
    78b0:	0f 92       	push	r0
    78b2:	11 24       	eor	r1, r1
    78b4:	2f 93       	push	r18
    78b6:	3f 93       	push	r19
    78b8:	4f 93       	push	r20
    78ba:	5f 93       	push	r21
    78bc:	6f 93       	push	r22
    78be:	7f 93       	push	r23
    78c0:	8f 93       	push	r24
    78c2:	9f 93       	push	r25
    78c4:	af 93       	push	r26
    78c6:	bf 93       	push	r27
    78c8:	ef 93       	push	r30
    78ca:	ff 93       	push	r31
    78cc:	0e 94 7a 3a 	call	0x74f4	; 0x74f4 <GSM_RX>
    78d0:	ff 91       	pop	r31
    78d2:	ef 91       	pop	r30
    78d4:	bf 91       	pop	r27
    78d6:	af 91       	pop	r26
    78d8:	9f 91       	pop	r25
    78da:	8f 91       	pop	r24
    78dc:	7f 91       	pop	r23
    78de:	6f 91       	pop	r22
    78e0:	5f 91       	pop	r21
    78e2:	4f 91       	pop	r20
    78e4:	3f 91       	pop	r19
    78e6:	2f 91       	pop	r18
    78e8:	0f 90       	pop	r0
    78ea:	0b be       	out	0x3b, r0	; 59
    78ec:	0f 90       	pop	r0
    78ee:	0f be       	out	0x3f, r0	; 63
    78f0:	0f 90       	pop	r0
    78f2:	1f 90       	pop	r1
    78f4:	18 95       	reti

000078f6 <KeypadInit>:
		for (uint8_t str=0; str<sizeof(KeyStr); str++) {
			uint8_t KS = prb(KeyStr+str);
			DDR_Key &=~KS;
			PortKey |=KS;
		}*/
		DDR_KeyROW1 |= KeyROW1;
    78f6:	81 9a       	sbi	0x10, 1	; 16
		DDR_KeyROW2 |= KeyROW2;
    78f8:	80 9a       	sbi	0x10, 0	; 16
		PortKeyROW1 |= KeyROW1;
    78fa:	89 9a       	sbi	0x11, 1	; 17
		PortKeyROW2 |= KeyROW2;
    78fc:	88 9a       	sbi	0x11, 0	; 17
		
		DDR_KeySTR1 &= ~KeySTR1;
    78fe:	85 98       	cbi	0x10, 5	; 16
		DDR_KeySTR2 &= ~KeySTR2;
    7900:	84 98       	cbi	0x10, 4	; 16
		DDR_KeySTR3 &= ~KeySTR3;
    7902:	82 98       	cbi	0x10, 2	; 16
		PortKeySTR1 |= KeySTR1;
    7904:	8d 9a       	sbi	0x11, 5	; 17
		PortKeySTR2 |= KeySTR2;
    7906:	8c 9a       	sbi	0x11, 4	; 17
		PortKeySTR3 |= KeySTR3;
    7908:	8a 9a       	sbi	0x11, 2	; 17
}

uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    790a:	80 91 cf 02 	lds	r24, 0x02CF
	VacantTimer8Sys += n;
    790e:	8f 5f       	subi	r24, 0xFF	; 255
    7910:	80 93 cf 02 	sts	0x02CF, r24
    7914:	81 50       	subi	r24, 0x01	; 1
		PORTJ.DIRCLR = (1<<7);
		for (uint8_t str=1; str<sizeof(KeyStr); str++)
			PORTK.DIRCLR = prb(KeyStr+str);
		PORTJ.PIN7CTRL = PORTK.PIN0CTRL = PORTK.PIN1CTRL = PORTK.PIN2CTRL = PORTK.PIN3CTRL = PORT_OPC_PULLUP_gc;
	#endif
	TD_Keypad = Timer8SysAlloc(1);
    7916:	80 93 f3 04 	sts	0x04F3, r24
}
    791a:	08 95       	ret

0000791c <KeypadIn>:
	return KeyPressedNonFilter = Key;
}
// ~~~~~~~~~~~
uint8_t
KeypadIn(void)
{
    791c:	0f 93       	push	r16
    791e:	1f 93       	push	r17
			}
		}
		RowOff(KR);
	}*/

	cli(); PortKeyROW1 &= ~KeyROW1; sei();
    7920:	f8 94       	cli
    7922:	89 98       	cbi	0x11, 1	; 17
    7924:	78 94       	sei
    7926:	85 e3       	ldi	r24, 0x35	; 53
    7928:	8a 95       	dec	r24
    792a:	f1 f7       	brne	.-4      	; 0x7928 <KeypadIn+0xc>
	_delay_us(10);		// By trial
	if(!(PIN_KeySTR1 & (KeySTR1))){ Key=2; PresKeysQuant++;} 
    792c:	7d 99       	sbic	0x0f, 5	; 15
    792e:	38 c0       	rjmp	.+112    	; 0x79a0 <KeypadIn+0x84>
    7930:	91 e0       	ldi	r25, 0x01	; 1
    7932:	02 e0       	ldi	r16, 0x02	; 2
	if(!(PIN_KeySTR2 & (KeySTR2))){ Key=6; PresKeysQuant++;} 
    7934:	7c 99       	sbic	0x0f, 4	; 15
    7936:	02 c0       	rjmp	.+4      	; 0x793c <KeypadIn+0x20>
    7938:	9f 5f       	subi	r25, 0xFF	; 255
    793a:	06 e0       	ldi	r16, 0x06	; 6
	if(!(PIN_KeySTR3 & (KeySTR3))){ Key=4; PresKeysQuant++;} 
    793c:	7a 99       	sbic	0x0f, 2	; 15
    793e:	02 c0       	rjmp	.+4      	; 0x7944 <KeypadIn+0x28>
    7940:	9f 5f       	subi	r25, 0xFF	; 255
    7942:	04 e0       	ldi	r16, 0x04	; 4
	cli(); PortKeyROW1 |= KeyROW1; sei();	
    7944:	f8 94       	cli
    7946:	89 9a       	sbi	0x11, 1	; 17
    7948:	78 94       	sei

	cli(); PortKeyROW2 &= ~KeyROW2; sei();
    794a:	f8 94       	cli
    794c:	88 98       	cbi	0x11, 0	; 17
    794e:	78 94       	sei
    7950:	85 e3       	ldi	r24, 0x35	; 53
    7952:	8a 95       	dec	r24
    7954:	f1 f7       	brne	.-4      	; 0x7952 <KeypadIn+0x36>
	_delay_us(10);		// By trial
	if(!(PIN_KeySTR1 & (KeySTR1))){ Key=1; PresKeysQuant++;}
    7956:	7d 99       	sbic	0x0f, 5	; 15
    7958:	02 c0       	rjmp	.+4      	; 0x795e <KeypadIn+0x42>
    795a:	9f 5f       	subi	r25, 0xFF	; 255
    795c:	01 e0       	ldi	r16, 0x01	; 1
	if(!(PIN_KeySTR2 & (KeySTR2))){ Key=5; PresKeysQuant++;}
    795e:	7c 99       	sbic	0x0f, 4	; 15
    7960:	02 c0       	rjmp	.+4      	; 0x7966 <KeypadIn+0x4a>
    7962:	9f 5f       	subi	r25, 0xFF	; 255
    7964:	05 e0       	ldi	r16, 0x05	; 5
	if(!(PIN_KeySTR3 & (KeySTR3))){ Key=3; PresKeysQuant++;}
    7966:	7a 99       	sbic	0x0f, 2	; 15
    7968:	02 c0       	rjmp	.+4      	; 0x796e <KeypadIn+0x52>
    796a:	9f 5f       	subi	r25, 0xFF	; 255
    796c:	03 e0       	ldi	r16, 0x03	; 3
	cli(); PortKeyROW2 |= KeyROW2; sei();
    796e:	f8 94       	cli
    7970:	88 9a       	sbi	0x11, 0	; 17
    7972:	78 94       	sei
	if(PresKeysQuant!=1) Key = 0;
    7974:	91 30       	cpi	r25, 0x01	; 1
    7976:	09 f4       	brne	.+2      	; 0x797a <KeypadIn+0x5e>
    7978:	4a c0       	rjmp	.+148    	; 0x7a0e <KeypadIn+0xf2>

	return KeyPressedNonFilter = Key;
    797a:	10 92 10 09 	sts	0x0910, r1
    797e:	00 e0       	ldi	r16, 0x00	; 0
{
	static uint8_t PrevKey;
	uint8_t KeyResult = 0;
	uint8_t Key = KeypadScan();	//   
	if(Key) KeyPressedCounter++;
	if(Key != PrevKey){			//     -   
    7980:	80 91 e5 02 	lds	r24, 0x02E5
    7984:	80 17       	cp	r24, r16
    7986:	11 f0       	breq	.+4      	; 0x798c <KeypadIn+0x70>
		PrevKey = 0;
    7988:	10 92 e5 02 	sts	0x02E5, r1
	}
	
	if (Timer8Stopp(TD_Keypad)) {
    798c:	10 91 f3 04 	lds	r17, 0x04F3
    7990:	81 2f       	mov	r24, r17
    7992:	0e 94 f5 1c 	call	0x39ea	; 0x39ea <Timer8Stopp>
    7996:	88 23       	and	r24, r24
    7998:	31 f4       	brne	.+12     	; 0x79a6 <KeypadIn+0x8a>
					for(I=0;I<=(KeyQuantity/8);I++) *((uint8_t*)RKEY+I) = 0;
				}
		#endif
	}
	return KeyResult;
}
    799a:	1f 91       	pop	r17
    799c:	0f 91       	pop	r16
    799e:	08 95       	ret
		RowOff(KR);
	}*/

	cli(); PortKeyROW1 &= ~KeyROW1; sei();
	_delay_us(10);		// By trial
	if(!(PIN_KeySTR1 & (KeySTR1))){ Key=2; PresKeysQuant++;} 
    79a0:	90 e0       	ldi	r25, 0x00	; 0
    79a2:	00 e0       	ldi	r16, 0x00	; 0
    79a4:	c7 cf       	rjmp	.-114    	; 0x7934 <KeypadIn+0x18>
	if(Key != PrevKey){			//     -   
		PrevKey = 0;
	}
	
	if (Timer8Stopp(TD_Keypad)) {
		StartTimer8(TD_Keypad, 6);	// By trial keystroke time == 70-180 ms
    79a6:	81 2f       	mov	r24, r17
    79a8:	66 e0       	ldi	r22, 0x06	; 6
    79aa:	0e 94 a1 1b 	call	0x3742	; 0x3742 <StartTimer8>
		if (Key != PrevKey) {
    79ae:	80 91 e5 02 	lds	r24, 0x02E5
    79b2:	80 17       	cp	r24, r16
    79b4:	09 f4       	brne	.+2      	; 0x79b8 <KeypadIn+0x9c>
    79b6:	44 c0       	rjmp	.+136    	; 0x7a40 <KeypadIn+0x124>
				PrevKey = Key;
    79b8:	00 93 e5 02 	sts	0x02E5, r16
				Key = 0;
				KeyStroke = 0;
    79bc:	10 92 f2 04 	sts	0x04F2, r1

		#ifdef RKEY
			#ifdef QslRD
				if(!*(uint8_t*)RNUM)
			#endif
				if (KeyResult==0) {
    79c0:	40 e0       	ldi	r20, 0x00	; 0
    79c2:	50 e0       	ldi	r21, 0x00	; 0
					uint8_t I = 0;
					while (1<<(I++ & 0b00000111) != *((uint8_t*)RKEY+(I>>3)) && I<=KeyQuantity);
    79c4:	a1 e0       	ldi	r26, 0x01	; 1
    79c6:	b0 e0       	ldi	r27, 0x00	; 0

		#ifdef RKEY
			#ifdef QslRD
				if(!*(uint8_t*)RNUM)
			#endif
				if (KeyResult==0) {
    79c8:	e4 2f       	mov	r30, r20
    79ca:	64 2f       	mov	r22, r20
    79cc:	6f 5f       	subi	r22, 0xFF	; 255
					uint8_t I = 0;
					while (1<<(I++ & 0b00000111) != *((uint8_t*)RKEY+(I>>3)) && I<=KeyQuantity);
    79ce:	9a 01       	movw	r18, r20
    79d0:	27 70       	andi	r18, 0x07	; 7
    79d2:	30 70       	andi	r19, 0x00	; 0
    79d4:	cd 01       	movw	r24, r26
    79d6:	02 c0       	rjmp	.+4      	; 0x79dc <KeypadIn+0xc0>
    79d8:	88 0f       	add	r24, r24
    79da:	99 1f       	adc	r25, r25
    79dc:	2a 95       	dec	r18
    79de:	e2 f7       	brpl	.-8      	; 0x79d8 <KeypadIn+0xbc>
    79e0:	9c 01       	movw	r18, r24
    79e2:	e6 95       	lsr	r30
    79e4:	e6 95       	lsr	r30
    79e6:	e6 95       	lsr	r30
    79e8:	f0 e0       	ldi	r31, 0x00	; 0
    79ea:	e1 54       	subi	r30, 0x41	; 65
    79ec:	f8 4f       	sbci	r31, 0xF8	; 248
    79ee:	80 81       	ld	r24, Z
    79f0:	90 e0       	ldi	r25, 0x00	; 0
    79f2:	28 17       	cp	r18, r24
    79f4:	39 07       	cpc	r19, r25
    79f6:	b1 f1       	breq	.+108    	; 0x7a64 <KeypadIn+0x148>
    79f8:	4f 5f       	subi	r20, 0xFF	; 255
    79fa:	5f 4f       	sbci	r21, 0xFF	; 255
    79fc:	47 30       	cpi	r20, 0x07	; 7
    79fe:	51 05       	cpc	r21, r1
    7a00:	19 f7       	brne	.-58     	; 0x79c8 <KeypadIn+0xac>
					if (I<=KeyQuantity)
    7a02:	80 e0       	ldi	r24, 0x00	; 0
						KeyResult = I;
					for(I=0;I<=(KeyQuantity/8);I++) *((uint8_t*)RKEY+I) = 0;
    7a04:	10 92 bf 07 	sts	0x07BF, r1
				}
		#endif
	}
	return KeyResult;
}
    7a08:	1f 91       	pop	r17
    7a0a:	0f 91       	pop	r16
    7a0c:	08 95       	ret
	if(!(PIN_KeySTR2 & (KeySTR2))){ Key=5; PresKeysQuant++;}
	if(!(PIN_KeySTR3 & (KeySTR3))){ Key=3; PresKeysQuant++;}
	cli(); PortKeyROW2 |= KeyROW2; sei();
	if(PresKeysQuant!=1) Key = 0;

	return KeyPressedNonFilter = Key;
    7a0e:	00 93 10 09 	sts	0x0910, r16
KeypadIn(void)
{
	static uint8_t PrevKey;
	uint8_t KeyResult = 0;
	uint8_t Key = KeypadScan();	//   
	if(Key) KeyPressedCounter++;
    7a12:	00 23       	and	r16, r16
    7a14:	09 f4       	brne	.+2      	; 0x7a18 <KeypadIn+0xfc>
    7a16:	b4 cf       	rjmp	.-152    	; 0x7980 <KeypadIn+0x64>
    7a18:	80 91 3a 07 	lds	r24, 0x073A
    7a1c:	90 91 3b 07 	lds	r25, 0x073B
    7a20:	a0 91 3c 07 	lds	r26, 0x073C
    7a24:	b0 91 3d 07 	lds	r27, 0x073D
    7a28:	01 96       	adiw	r24, 0x01	; 1
    7a2a:	a1 1d       	adc	r26, r1
    7a2c:	b1 1d       	adc	r27, r1
    7a2e:	80 93 3a 07 	sts	0x073A, r24
    7a32:	90 93 3b 07 	sts	0x073B, r25
    7a36:	a0 93 3c 07 	sts	0x073C, r26
    7a3a:	b0 93 3d 07 	sts	0x073D, r27
    7a3e:	a0 cf       	rjmp	.-192    	; 0x7980 <KeypadIn+0x64>
				PrevKey = Key;
				Key = 0;
				KeyStroke = 0;
		}
		else{
			KeyPressed = KeyResult = Key;
    7a40:	00 93 b0 07 	sts	0x07B0, r16
			if(KeyStroke<0xFF && ++KeyStroke>1 && KeyStroke<=0xF) KeyResult = 0;
    7a44:	90 91 f2 04 	lds	r25, 0x04F2
    7a48:	9f 3f       	cpi	r25, 0xFF	; 255
    7a4a:	41 f0       	breq	.+16     	; 0x7a5c <KeypadIn+0x140>
    7a4c:	9f 5f       	subi	r25, 0xFF	; 255
    7a4e:	90 93 f2 04 	sts	0x04F2, r25
    7a52:	92 30       	cpi	r25, 0x02	; 2
    7a54:	18 f0       	brcs	.+6      	; 0x7a5c <KeypadIn+0x140>
    7a56:	90 31       	cpi	r25, 0x10	; 16
    7a58:	08 f4       	brcc	.+2      	; 0x7a5c <KeypadIn+0x140>
    7a5a:	b2 cf       	rjmp	.-156    	; 0x79c0 <KeypadIn+0xa4>

		#ifdef RKEY
			#ifdef QslRD
				if(!*(uint8_t*)RNUM)
			#endif
				if (KeyResult==0) {
    7a5c:	88 23       	and	r24, r24
    7a5e:	09 f0       	breq	.+2      	; 0x7a62 <KeypadIn+0x146>
    7a60:	9c cf       	rjmp	.-200    	; 0x799a <KeypadIn+0x7e>
    7a62:	ae cf       	rjmp	.-164    	; 0x79c0 <KeypadIn+0xa4>
					uint8_t I = 0;
					while (1<<(I++ & 0b00000111) != *((uint8_t*)RKEY+(I>>3)) && I<=KeyQuantity);
					if (I<=KeyQuantity)
    7a64:	67 30       	cpi	r22, 0x07	; 7
    7a66:	68 f6       	brcc	.-102    	; 0x7a02 <KeypadIn+0xe6>
    7a68:	86 2f       	mov	r24, r22
    7a6a:	cc cf       	rjmp	.-104    	; 0x7a04 <KeypadIn+0xe8>

00007a6c <InitBufStr>:
static uint8_t Minus;
// ~~~~~~~~~~~
char BufStr[LCDXSz+1];
uint8_t CurrFieldSize;

void InitBufStr(OutField *Field){
    7a6c:	e3 ec       	ldi	r30, 0xC3	; 195
    7a6e:	f5 e0       	ldi	r31, 0x05	; 5
	for(uint8_t i =0; i<LCDXSz; i++) BufStr[i]=' ';
    7a70:	80 e2       	ldi	r24, 0x20	; 32
    7a72:	81 93       	st	Z+, r24
    7a74:	95 e0       	ldi	r25, 0x05	; 5
    7a76:	e7 3d       	cpi	r30, 0xD7	; 215
    7a78:	f9 07       	cpc	r31, r25
    7a7a:	d9 f7       	brne	.-10     	; 0x7a72 <InitBufStr+0x6>
	BufStr[LCDXSz] ='\0';
    7a7c:	10 82       	st	Z, r1
	CurrFieldSize = 0;
    7a7e:	10 92 c0 07 	sts	0x07C0, r1
	MultiSymbol = 0;
    7a82:	10 92 f4 04 	sts	0x04F4, r1
}
    7a86:	08 95       	ret

00007a88 <EventFunc>:

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    7a88:	fc 01       	movw	r30, r24
    7a8a:	85 91       	lpm	r24, Z+
    7a8c:	94 91       	lpm	r25, Z+
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
EventFunc(const MenuEvent *Event)
{
	MenuEvent Func = prp(Event);
	if (Func)
    7a8e:	00 97       	sbiw	r24, 0x00	; 0
    7a90:	11 f0       	breq	.+4      	; 0x7a96 <EventFunc+0xe>
		Func();
    7a92:	fc 01       	movw	r30, r24
    7a94:	19 95       	eicall
    7a96:	08 95       	ret

00007a98 <KeyFunc>:
    7a98:	fc 01       	movw	r30, r24
    7a9a:	85 91       	lpm	r24, Z+
    7a9c:	94 91       	lpm	r25, Z+
// ~~~~~~~~~~~~~~~~~~~~~~~~
static uint8_t
KeyFunc(const MenuKey *Key)
{
	MenuKey Func=prp(Key);
	return Func && Func()==CustomKey;
    7a9e:	00 97       	sbiw	r24, 0x00	; 0
    7aa0:	51 f0       	breq	.+20     	; 0x7ab6 <KeyFunc+0x1e>
    7aa2:	fc 01       	movw	r30, r24
    7aa4:	19 95       	eicall
    7aa6:	90 e0       	ldi	r25, 0x00	; 0
    7aa8:	81 30       	cpi	r24, 0x01	; 1
    7aaa:	09 f0       	breq	.+2      	; 0x7aae <KeyFunc+0x16>
    7aac:	91 e0       	ldi	r25, 0x01	; 1
    7aae:	81 e0       	ldi	r24, 0x01	; 1
    7ab0:	98 27       	eor	r25, r24
}
    7ab2:	89 2f       	mov	r24, r25
    7ab4:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~~~
static uint8_t
KeyFunc(const MenuKey *Key)
{
	MenuKey Func=prp(Key);
	return Func && Func()==CustomKey;
    7ab6:	90 e0       	ldi	r25, 0x00	; 0
}
    7ab8:	89 2f       	mov	r24, r25
    7aba:	08 95       	ret

00007abc <GotoMenu>:

// ~~~~~~~~~~~~~~~~~~~~~
void
GotoMenu(MenuPage *Menu)
{
    7abc:	cf 93       	push	r28
    7abe:	df 93       	push	r29
    7ac0:	ec 01       	movw	r28, r24
	EventFunc(&CurrPage->Exit);
    7ac2:	80 91 d4 02 	lds	r24, 0x02D4
    7ac6:	90 91 d5 02 	lds	r25, 0x02D5
    7aca:	0a 96       	adiw	r24, 0x0a	; 10
    7acc:	0e 94 44 3d 	call	0x7a88	; 0x7a88 <EventFunc>
    7ad0:	fe 01       	movw	r30, r28
    7ad2:	34 96       	adiw	r30, 0x04	; 4
    7ad4:	85 91       	lpm	r24, Z+
    7ad6:	94 91       	lpm	r25, Z+
	if(prp(&Menu->OutPage))
    7ad8:	89 2b       	or	r24, r25
    7ada:	c9 f0       	breq	.+50     	; 0x7b0e <GotoMenu+0x52>
		MenuDepth=0;
    7adc:	10 92 ba 07 	sts	0x07BA, r1
	else {
		MenuStack[MenuDepth].Page = CurrPage;
		MenuStack[MenuDepth].Line = CurrLine;
		MenuStack[MenuDepth++].LCD = CurrLCD;
	}
	CurrPage = Menu;
    7ae0:	d0 93 d5 02 	sts	0x02D5, r29
    7ae4:	c0 93 d4 02 	sts	0x02D4, r28

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    7ae8:	23 96       	adiw	r28, 0x03	; 3
    7aea:	fe 01       	movw	r30, r28
    7aec:	84 91       	lpm	r24, Z+
	CurrLine = CurrLCD = GetFix();
    7aee:	80 93 e7 08 	sts	0x08E7, r24
    7af2:	80 93 c9 07 	sts	0x07C9, r24
	CurrField = CurrPos = NullPos;
    7af6:	8f ef       	ldi	r24, 0xFF	; 255
    7af8:	80 93 d7 02 	sts	0x02D7, r24
    7afc:	80 93 d6 02 	sts	0x02D6, r24
	EventFunc(&CurrPage->Load);
    7b00:	ce 01       	movw	r24, r28
    7b02:	03 96       	adiw	r24, 0x03	; 3
    7b04:	0e 94 44 3d 	call	0x7a88	; 0x7a88 <EventFunc>
}
    7b08:	df 91       	pop	r29
    7b0a:	cf 91       	pop	r28
    7b0c:	08 95       	ret
{
	EventFunc(&CurrPage->Exit);
	if(prp(&Menu->OutPage))
		MenuDepth=0;
	else {
		MenuStack[MenuDepth].Page = CurrPage;
    7b0e:	20 91 ba 07 	lds	r18, 0x07BA
    7b12:	e2 2f       	mov	r30, r18
    7b14:	f0 e0       	ldi	r31, 0x00	; 0
    7b16:	ee 0f       	add	r30, r30
    7b18:	ff 1f       	adc	r31, r31
    7b1a:	ee 0f       	add	r30, r30
    7b1c:	ff 1f       	adc	r31, r31
    7b1e:	df 01       	movw	r26, r30
    7b20:	a8 51       	subi	r26, 0x18	; 24
    7b22:	b7 4f       	sbci	r27, 0xF7	; 247
    7b24:	80 91 d4 02 	lds	r24, 0x02D4
    7b28:	90 91 d5 02 	lds	r25, 0x02D5
    7b2c:	11 96       	adiw	r26, 0x01	; 1
    7b2e:	9c 93       	st	X, r25
    7b30:	8e 93       	st	-X, r24
		MenuStack[MenuDepth].Line = CurrLine;
    7b32:	80 91 c9 07 	lds	r24, 0x07C9
    7b36:	13 96       	adiw	r26, 0x03	; 3
    7b38:	8c 93       	st	X, r24
		MenuStack[MenuDepth++].LCD = CurrLCD;
    7b3a:	e6 51       	subi	r30, 0x16	; 22
    7b3c:	f7 4f       	sbci	r31, 0xF7	; 247
    7b3e:	80 91 e7 08 	lds	r24, 0x08E7
    7b42:	80 83       	st	Z, r24
    7b44:	2f 5f       	subi	r18, 0xFF	; 255
    7b46:	20 93 ba 07 	sts	0x07BA, r18
    7b4a:	ca cf       	rjmp	.-108    	; 0x7ae0 <GotoMenu+0x24>

00007b4c <HideMsg>:

// ~~~~~~~~~~
uint8_t
HideMsg(void)
{
	if (CurrMsg) {
    7b4c:	80 91 f5 04 	lds	r24, 0x04F5
    7b50:	90 91 f6 04 	lds	r25, 0x04F6
    7b54:	00 97       	sbiw	r24, 0x00	; 0
    7b56:	51 f0       	breq	.+20     	; 0x7b6c <HideMsg+0x20>
		EventFunc(&CurrMsg->Exit);
    7b58:	80 5a       	subi	r24, 0xA0	; 160
    7b5a:	9f 4f       	sbci	r25, 0xFF	; 255
    7b5c:	0e 94 44 3d 	call	0x7a88	; 0x7a88 <EventFunc>
		CurrMsg = NULL;
    7b60:	10 92 f6 04 	sts	0x04F6, r1
    7b64:	10 92 f5 04 	sts	0x04F5, r1
    7b68:	81 e0       	ldi	r24, 0x01	; 1
		return 1;
	}
	else
		return 0;
}
    7b6a:	08 95       	ret

// ~~~~~~~~~~
uint8_t
HideMsg(void)
{
	if (CurrMsg) {
    7b6c:	80 e0       	ldi	r24, 0x00	; 0
    7b6e:	08 95       	ret

00007b70 <ShowMsg>:
}

// ~~~~~~~~~~~~~~~~~~
void
ShowMsg(MsgPage *Msg)
{
    7b70:	0f 93       	push	r16
    7b72:	1f 93       	push	r17
    7b74:	8c 01       	movw	r16, r24
	HideMsg();
    7b76:	0e 94 a6 3d 	call	0x7b4c	; 0x7b4c <HideMsg>
	CurrMsg = Msg;
    7b7a:	10 93 f6 04 	sts	0x04F6, r17
    7b7e:	00 93 f5 04 	sts	0x04F5, r16
	EventFunc(&CurrMsg->Load);
    7b82:	c8 01       	movw	r24, r16
    7b84:	84 5a       	subi	r24, 0xA4	; 164
    7b86:	9f 4f       	sbci	r25, 0xFF	; 255
    7b88:	0e 94 44 3d 	call	0x7a88	; 0x7a88 <EventFunc>
}
    7b8c:	1f 91       	pop	r17
    7b8e:	0f 91       	pop	r16
    7b90:	08 95       	ret

00007b92 <MenuInit>:

// ~~~~~~~~~~~
void
MenuInit(void)
{
	CurrLCD = CurrLine = GetFix();
    7b92:	e0 91 d4 02 	lds	r30, 0x02D4
    7b96:	f0 91 d5 02 	lds	r31, 0x02D5
    7b9a:	33 96       	adiw	r30, 0x03	; 3
    7b9c:	84 91       	lpm	r24, Z+
    7b9e:	80 93 c9 07 	sts	0x07C9, r24
    7ba2:	80 93 e7 08 	sts	0x08E7, r24
	#ifdef InitMsg
		ShowMsg(&InitMsg);
	#endif
	EventFunc(&CurrPage->Load);
    7ba6:	cf 01       	movw	r24, r30
    7ba8:	03 96       	adiw	r24, 0x03	; 3
    7baa:	0e 94 44 3d 	call	0x7a88	; 0x7a88 <EventFunc>
}
    7bae:	08 95       	ret

00007bb0 <PosBlink>:
}

// ~~~~~~~~~~~~~~~~~~~~~
static void
PosBlink(T_Param *Param, char Cursor)
{
    7bb0:	fc 01       	movw	r30, r24
	CurrX=Param->Pos+Param->Size-CurrPos-(Param->Prec&&CurrPos>=Param->Prec?2:1)-LCD_Buf[Y1];
    7bb2:	20 81       	ld	r18, Z
    7bb4:	33 81       	ldd	r19, Z+3	; 0x03
    7bb6:	90 91 d7 02 	lds	r25, 0x02D7
    7bba:	82 81       	ldd	r24, Z+2	; 0x02
    7bbc:	88 23       	and	r24, r24
    7bbe:	11 f0       	breq	.+4      	; 0x7bc4 <PosBlink+0x14>
    7bc0:	98 17       	cp	r25, r24
    7bc2:	a0 f4       	brcc	.+40     	; 0x7bec <PosBlink+0x3c>
    7bc4:	4f ef       	ldi	r20, 0xFF	; 255
    7bc6:	39 1b       	sub	r19, r25
    7bc8:	32 0f       	add	r19, r18
    7bca:	88 e5       	ldi	r24, 0x58	; 88
    7bcc:	96 e0       	ldi	r25, 0x06	; 6
    7bce:	38 1b       	sub	r19, r24
    7bd0:	80 91 44 0a 	lds	r24, 0x0A44
    7bd4:	25 e1       	ldi	r18, 0x15	; 21
    7bd6:	82 9f       	mul	r24, r18
    7bd8:	c0 01       	movw	r24, r0
    7bda:	11 24       	eor	r1, r1
    7bdc:	38 1b       	sub	r19, r24
    7bde:	34 0f       	add	r19, r20
    7be0:	30 93 fa 06 	sts	0x06FA, r19
	StrSize=1;
    7be4:	81 e0       	ldi	r24, 0x01	; 1
    7be6:	80 93 ac 06 	sts	0x06AC, r24
}
    7bea:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~~~
static void
PosBlink(T_Param *Param, char Cursor)
{
	CurrX=Param->Pos+Param->Size-CurrPos-(Param->Prec&&CurrPos>=Param->Prec?2:1)-LCD_Buf[Y1];
    7bec:	4e ef       	ldi	r20, 0xFE	; 254
    7bee:	eb cf       	rjmp	.-42     	; 0x7bc6 <PosBlink+0x16>

00007bf0 <GetCurrFieldSize>:

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    7bf0:	e0 91 d4 02 	lds	r30, 0x02D4
    7bf4:	f0 91 d5 02 	lds	r31, 0x02D5
    7bf8:	45 91       	lpm	r20, Z+
    7bfa:	54 91       	lpm	r21, Z+
}
// ~~~~~~~~~~~~~~~~~~~~~~~
// Return size of CurrField. Use to determine size of Text, EE_Text OutField vars
uint8_t GetCurrFieldSize(void){
	uint8_t Size;
	MenuLine *Line=GetLine+CurrLine;
    7bfc:	80 91 c9 07 	lds	r24, 0x07C9
    7c00:	2b e1       	ldi	r18, 0x1B	; 27
    7c02:	82 9f       	mul	r24, r18
    7c04:	c0 01       	movw	r24, r0
    7c06:	11 24       	eor	r1, r1
    7c08:	48 0f       	add	r20, r24
    7c0a:	59 1f       	adc	r21, r25
		while(prc(CurrStr+X)=='}'){
			X++;
			Size++;
		}
		if(Size){
			if(OF_N == CurrField) return Size;
    7c0c:	30 91 d6 02 	lds	r19, 0x02D6
    7c10:	90 e0       	ldi	r25, 0x00	; 0
    7c12:	20 e0       	ldi	r18, 0x00	; 0

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    7c14:	fa 01       	movw	r30, r20
    7c16:	e9 0f       	add	r30, r25
    7c18:	f1 1d       	adc	r31, r1
    7c1a:	e4 91       	lpm	r30, Z+
	MenuLine *Line=GetLine+CurrLine;
	PGM_P CurrStr=(PGM_P)(Line->Str);
	uint8_t OF_N = 0;
	for(uint8_t X=0; X<LCDXSz; X++){
		Size = 0;
		while(prc(CurrStr+X)=='}'){
    7c1c:	ed 37       	cpi	r30, 0x7D	; 125
    7c1e:	71 f4       	brne	.+28     	; 0x7c3c <GetCurrFieldSize+0x4c>
			X++;
			Size++;
		}
		if(Size){
			if(OF_N == CurrField) return Size;
    7c20:	80 e0       	ldi	r24, 0x00	; 0
	PGM_P CurrStr=(PGM_P)(Line->Str);
	uint8_t OF_N = 0;
	for(uint8_t X=0; X<LCDXSz; X++){
		Size = 0;
		while(prc(CurrStr+X)=='}'){
			X++;
    7c22:	9f 5f       	subi	r25, 0xFF	; 255
			Size++;
    7c24:	8f 5f       	subi	r24, 0xFF	; 255
    7c26:	fa 01       	movw	r30, r20
    7c28:	e9 0f       	add	r30, r25
    7c2a:	f1 1d       	adc	r31, r1
    7c2c:	e4 91       	lpm	r30, Z+
	MenuLine *Line=GetLine+CurrLine;
	PGM_P CurrStr=(PGM_P)(Line->Str);
	uint8_t OF_N = 0;
	for(uint8_t X=0; X<LCDXSz; X++){
		Size = 0;
		while(prc(CurrStr+X)=='}'){
    7c2e:	ed 37       	cpi	r30, 0x7D	; 125
    7c30:	c1 f3       	breq	.-16     	; 0x7c22 <GetCurrFieldSize+0x32>
			X++;
			Size++;
		}
		if(Size){
    7c32:	88 23       	and	r24, r24
    7c34:	19 f0       	breq	.+6      	; 0x7c3c <GetCurrFieldSize+0x4c>
			if(OF_N == CurrField) return Size;
    7c36:	23 17       	cp	r18, r19
    7c38:	29 f0       	breq	.+10     	; 0x7c44 <GetCurrFieldSize+0x54>
			OF_N++;
    7c3a:	2f 5f       	subi	r18, 0xFF	; 255
uint8_t GetCurrFieldSize(void){
	uint8_t Size;
	MenuLine *Line=GetLine+CurrLine;
	PGM_P CurrStr=(PGM_P)(Line->Str);
	uint8_t OF_N = 0;
	for(uint8_t X=0; X<LCDXSz; X++){
    7c3c:	9f 5f       	subi	r25, 0xFF	; 255
    7c3e:	94 31       	cpi	r25, 0x14	; 20
    7c40:	48 f3       	brcs	.-46     	; 0x7c14 <GetCurrFieldSize+0x24>
		Size = 0;
		while(prc(CurrStr+X)=='}'){
    7c42:	80 e0       	ldi	r24, 0x00	; 0
			if(OF_N == CurrField) return Size;
			OF_N++;
		}
	}
	return 0;
}
    7c44:	08 95       	ret

00007c46 <Inc>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
static int32_t
Inc(int8_t Dir, uint32_t Buf)
{
    7c46:	5f 92       	push	r5
    7c48:	6f 92       	push	r6
    7c4a:	7f 92       	push	r7
    7c4c:	8f 92       	push	r8
    7c4e:	9f 92       	push	r9
    7c50:	af 92       	push	r10
    7c52:	bf 92       	push	r11
    7c54:	cf 92       	push	r12
    7c56:	df 92       	push	r13
    7c58:	ef 92       	push	r14
    7c5a:	ff 92       	push	r15
    7c5c:	0f 93       	push	r16
    7c5e:	1f 93       	push	r17
    7c60:	cf 93       	push	r28
    7c62:	df 93       	push	r29
    7c64:	58 2e       	mov	r5, r24
    7c66:	3a 01       	movw	r6, r20
    7c68:	4b 01       	movw	r8, r22
	uint32_t Pos = PowL10(CurrPos);
    7c6a:	d0 90 d7 02 	lds	r13, 0x02D7
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
	uint32_t Pow = 1;
	while(Exp--)
    7c6e:	dd 20       	and	r13, r13
    7c70:	09 f4       	brne	.+2      	; 0x7c74 <Inc+0x2e>
    7c72:	5f c0       	rjmp	.+190    	; 0x7d32 <Inc+0xec>
    7c74:	61 e0       	ldi	r22, 0x01	; 1
    7c76:	e6 2e       	mov	r14, r22
    7c78:	f1 2c       	mov	r15, r1
    7c7a:	01 2d       	mov	r16, r1
    7c7c:	11 2d       	mov	r17, r1
		Pow *= 10;
    7c7e:	c8 01       	movw	r24, r16
    7c80:	b7 01       	movw	r22, r14
    7c82:	2a e0       	ldi	r18, 0x0A	; 10
    7c84:	30 e0       	ldi	r19, 0x00	; 0
    7c86:	40 e0       	ldi	r20, 0x00	; 0
    7c88:	50 e0       	ldi	r21, 0x00	; 0
    7c8a:	0e 94 53 84 	call	0x108a6	; 0x108a6 <__mulsi3>
    7c8e:	7b 01       	movw	r14, r22
    7c90:	8c 01       	movw	r16, r24
    7c92:	da 94       	dec	r13
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
	uint32_t Pow = 1;
	while(Exp--)
    7c94:	a1 f7       	brne	.-24     	; 0x7c7e <Inc+0x38>
    7c96:	5b 01       	movw	r10, r22
    7c98:	6c 01       	movw	r12, r24
	uint8_t Dig=Buf%(Pos*10)/Pos;
	if(Dig==(Dir==1?9:0)) {
    7c9a:	81 e0       	ldi	r24, 0x01	; 1
    7c9c:	58 16       	cp	r5, r24
    7c9e:	09 f4       	brne	.+2      	; 0x7ca2 <Inc+0x5c>
    7ca0:	45 c0       	rjmp	.+138    	; 0x7d2c <Inc+0xe6>
    7ca2:	c0 e0       	ldi	r28, 0x00	; 0
    7ca4:	d0 e0       	ldi	r29, 0x00	; 0
    7ca6:	c8 01       	movw	r24, r16
    7ca8:	b7 01       	movw	r22, r14
    7caa:	2a e0       	ldi	r18, 0x0A	; 10
    7cac:	30 e0       	ldi	r19, 0x00	; 0
    7cae:	40 e0       	ldi	r20, 0x00	; 0
    7cb0:	50 e0       	ldi	r21, 0x00	; 0
    7cb2:	0e 94 53 84 	call	0x108a6	; 0x108a6 <__mulsi3>
    7cb6:	9b 01       	movw	r18, r22
    7cb8:	ac 01       	movw	r20, r24
    7cba:	c4 01       	movw	r24, r8
    7cbc:	b3 01       	movw	r22, r6
    7cbe:	0e 94 a5 84 	call	0x1094a	; 0x1094a <__udivmodsi4>
    7cc2:	a8 01       	movw	r20, r16
    7cc4:	97 01       	movw	r18, r14
    7cc6:	0e 94 a5 84 	call	0x1094a	; 0x1094a <__udivmodsi4>
    7cca:	30 e0       	ldi	r19, 0x00	; 0
    7ccc:	2c 17       	cp	r18, r28
    7cce:	3d 07       	cpc	r19, r29
    7cd0:	99 f4       	brne	.+38     	; 0x7cf8 <Inc+0xb2>
			Dir = -Dir;
    7cd2:	51 94       	neg	r5
			Pos *= 9;
    7cd4:	57 01       	movw	r10, r14
    7cd6:	68 01       	movw	r12, r16
    7cd8:	aa 0c       	add	r10, r10
    7cda:	bb 1c       	adc	r11, r11
    7cdc:	cc 1c       	adc	r12, r12
    7cde:	dd 1c       	adc	r13, r13
    7ce0:	aa 0c       	add	r10, r10
    7ce2:	bb 1c       	adc	r11, r11
    7ce4:	cc 1c       	adc	r12, r12
    7ce6:	dd 1c       	adc	r13, r13
    7ce8:	aa 0c       	add	r10, r10
    7cea:	bb 1c       	adc	r11, r11
    7cec:	cc 1c       	adc	r12, r12
    7cee:	dd 1c       	adc	r13, r13
    7cf0:	ae 0c       	add	r10, r14
    7cf2:	bf 1c       	adc	r11, r15
    7cf4:	c0 1e       	adc	r12, r16
    7cf6:	d1 1e       	adc	r13, r17
    7cf8:	65 2d       	mov	r22, r5
    7cfa:	77 27       	eor	r23, r23
    7cfc:	67 fd       	sbrc	r22, 7
    7cfe:	70 95       	com	r23
    7d00:	87 2f       	mov	r24, r23
    7d02:	97 2f       	mov	r25, r23
    7d04:	a6 01       	movw	r20, r12
    7d06:	95 01       	movw	r18, r10
    7d08:	0e 94 53 84 	call	0x108a6	; 0x108a6 <__mulsi3>
	}
	return Pos*Dir;
}
    7d0c:	df 91       	pop	r29
    7d0e:	cf 91       	pop	r28
    7d10:	1f 91       	pop	r17
    7d12:	0f 91       	pop	r16
    7d14:	ff 90       	pop	r15
    7d16:	ef 90       	pop	r14
    7d18:	df 90       	pop	r13
    7d1a:	cf 90       	pop	r12
    7d1c:	bf 90       	pop	r11
    7d1e:	af 90       	pop	r10
    7d20:	9f 90       	pop	r9
    7d22:	8f 90       	pop	r8
    7d24:	7f 90       	pop	r7
    7d26:	6f 90       	pop	r6
    7d28:	5f 90       	pop	r5
    7d2a:	08 95       	ret
static int32_t
Inc(int8_t Dir, uint32_t Buf)
{
	uint32_t Pos = PowL10(CurrPos);
	uint8_t Dig=Buf%(Pos*10)/Pos;
	if(Dig==(Dir==1?9:0)) {
    7d2c:	c9 e0       	ldi	r28, 0x09	; 9
    7d2e:	d0 e0       	ldi	r29, 0x00	; 0
    7d30:	ba cf       	rjmp	.-140    	; 0x7ca6 <Inc+0x60>
    7d32:	e1 e0       	ldi	r30, 0x01	; 1
    7d34:	ee 2e       	mov	r14, r30
    7d36:	f1 2c       	mov	r15, r1
    7d38:	01 2d       	mov	r16, r1
    7d3a:	11 2d       	mov	r17, r1
    7d3c:	71 e0       	ldi	r23, 0x01	; 1
    7d3e:	a7 2e       	mov	r10, r23
    7d40:	b1 2c       	mov	r11, r1
    7d42:	c1 2c       	mov	r12, r1
    7d44:	d1 2c       	mov	r13, r1
    7d46:	a9 cf       	rjmp	.-174    	; 0x7c9a <Inc+0x54>

00007d48 <MenuRight>:

// ~~~~~~~~~~~~
void
MenuRight(void)
{
}
    7d48:	08 95       	ret

00007d4a <MenuLeft>:

// ~~~~~~~~~~~~~
void
MenuLeft(void)
{
}
    7d4a:	08 95       	ret

00007d4c <MenuEnter>:

// ~~~~~~~~~~~~
void
MenuEnter(void)
{
}
    7d4c:	08 95       	ret

00007d4e <MenuEsc>:

// ~~~~~~~~~~
void
MenuEsc(void)
{
}
    7d4e:	08 95       	ret

00007d50 <DI_State>:
} DigInput;

// ~~~~~~~~~~~~~~~~~~
uint8_t
DI_State(uint8_t D_N)
{
    7d50:	28 2f       	mov	r18, r24
    7d52:	86 95       	lsr	r24
    7d54:	86 95       	lsr	r24
    7d56:	86 95       	lsr	r24
    7d58:	e0 e4       	ldi	r30, 0x40	; 64
    7d5a:	f7 e0       	ldi	r31, 0x07	; 7
    7d5c:	e8 0f       	add	r30, r24
    7d5e:	f1 1d       	adc	r31, r1
    7d60:	80 81       	ld	r24, Z
    7d62:	90 e0       	ldi	r25, 0x00	; 0
    7d64:	27 70       	andi	r18, 0x07	; 7
    7d66:	02 c0       	rjmp	.+4      	; 0x7d6c <DI_State+0x1c>
    7d68:	95 95       	asr	r25
    7d6a:	87 95       	ror	r24
    7d6c:	2a 95       	dec	r18
    7d6e:	e2 f7       	brpl	.-8      	; 0x7d68 <DI_State+0x18>
	return (DigInput.State[D_N/8] &(1<<D_N%8)) != 0;
}
    7d70:	81 70       	andi	r24, 0x01	; 1
    7d72:	08 95       	ret

00007d74 <DI_Front>:

// ~~~~~~~~~~~~~~~~~~
uint8_t
DI_Front(uint8_t D_N)
{
    7d74:	e8 2f       	mov	r30, r24
	uint8_t Byte=D_N/8, Bit=1<<D_N%8;
    7d76:	28 2f       	mov	r18, r24
    7d78:	27 70       	andi	r18, 0x07	; 7
    7d7a:	81 e0       	ldi	r24, 0x01	; 1
    7d7c:	90 e0       	ldi	r25, 0x00	; 0
    7d7e:	01 c0       	rjmp	.+2      	; 0x7d82 <DI_Front+0xe>
    7d80:	88 0f       	add	r24, r24
    7d82:	2a 95       	dec	r18
    7d84:	ea f7       	brpl	.-6      	; 0x7d80 <DI_Front+0xc>
	uint8_t State = DigInput.State[Byte] &Bit;
    7d86:	e6 95       	lsr	r30
    7d88:	e6 95       	lsr	r30
    7d8a:	e6 95       	lsr	r30
    7d8c:	f0 e0       	ldi	r31, 0x00	; 0
    7d8e:	e0 5c       	subi	r30, 0xC0	; 192
    7d90:	f8 4f       	sbci	r31, 0xF8	; 248
    7d92:	90 81       	ld	r25, Z
    7d94:	98 23       	and	r25, r24
	return DigInput.StateOld[Byte] &Bit ? State?NoFront:FallFront : State?RiseFront:NoFront;
    7d96:	23 81       	ldd	r18, Z+3	; 0x03
    7d98:	82 23       	and	r24, r18
    7d9a:	21 f0       	breq	.+8      	; 0x7da4 <DI_Front+0x30>
    7d9c:	99 23       	and	r25, r25
    7d9e:	41 f4       	brne	.+16     	; 0x7db0 <DI_Front+0x3c>
    7da0:	82 e0       	ldi	r24, 0x02	; 2
    7da2:	08 95       	ret
    7da4:	89 2f       	mov	r24, r25
    7da6:	99 23       	and	r25, r25
    7da8:	09 f4       	brne	.+2      	; 0x7dac <DI_Front+0x38>
}
    7daa:	08 95       	ret
uint8_t
DI_Front(uint8_t D_N)
{
	uint8_t Byte=D_N/8, Bit=1<<D_N%8;
	uint8_t State = DigInput.State[Byte] &Bit;
	return DigInput.StateOld[Byte] &Bit ? State?NoFront:FallFront : State?RiseFront:NoFront;
    7dac:	81 e0       	ldi	r24, 0x01	; 1
}
    7dae:	08 95       	ret
uint8_t
DI_Front(uint8_t D_N)
{
	uint8_t Byte=D_N/8, Bit=1<<D_N%8;
	uint8_t State = DigInput.State[Byte] &Bit;
	return DigInput.StateOld[Byte] &Bit ? State?NoFront:FallFront : State?RiseFront:NoFront;
    7db0:	80 e0       	ldi	r24, 0x00	; 0
    7db2:	08 95       	ret

00007db4 <DI_Status>:
}

// ~~~~~~~~~~~~~~~~~~~
uint8_t
DI_Status(uint8_t D_N)
{
    7db4:	28 2f       	mov	r18, r24
    7db6:	86 95       	lsr	r24
    7db8:	86 95       	lsr	r24
    7dba:	86 95       	lsr	r24
    7dbc:	e0 e4       	ldi	r30, 0x40	; 64
    7dbe:	f7 e0       	ldi	r31, 0x07	; 7
    7dc0:	e8 0f       	add	r30, r24
    7dc2:	f1 1d       	adc	r31, r1
    7dc4:	86 81       	ldd	r24, Z+6	; 0x06
    7dc6:	90 e0       	ldi	r25, 0x00	; 0
    7dc8:	27 70       	andi	r18, 0x07	; 7
    7dca:	02 c0       	rjmp	.+4      	; 0x7dd0 <DI_Status+0x1c>
    7dcc:	95 95       	asr	r25
    7dce:	87 95       	ror	r24
    7dd0:	2a 95       	dec	r18
    7dd2:	e2 f7       	brpl	.-8      	; 0x7dcc <DI_Status+0x18>
	return (DigInput.Status[D_N/8] &(1<<D_N%8)) != 0;
}
    7dd4:	81 70       	andi	r24, 0x01	; 1
    7dd6:	08 95       	ret

00007dd8 <DI_Init>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

// ~~~~~~~~~~
void
DI_Init(void)
{
    7dd8:	20 e0       	ldi	r18, 0x00	; 0
    7dda:	30 e0       	ldi	r19, 0x00	; 0
// ~~~~~~~~~~~~~~~
static void
DI_Init_Hard(void)
{
	for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
		cli();
    7ddc:	f8 94       	cli

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    7dde:	a9 01       	movw	r20, r18
    7de0:	44 0f       	add	r20, r20
    7de2:	55 1f       	adc	r21, r21
    7de4:	44 0f       	add	r20, r20
    7de6:	55 1f       	adc	r21, r21
    7de8:	44 0f       	add	r20, r20
    7dea:	55 1f       	adc	r21, r21
    7dec:	ca 01       	movw	r24, r20
    7dee:	8e 56       	subi	r24, 0x6E	; 110
    7df0:	93 4d       	sbci	r25, 0xD3	; 211
    7df2:	fc 01       	movw	r30, r24
    7df4:	a5 91       	lpm	r26, Z+
    7df6:	b4 91       	lpm	r27, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    7df8:	48 56       	subi	r20, 0x68	; 104
    7dfa:	53 4d       	sbci	r21, 0xD3	; 211
    7dfc:	fa 01       	movw	r30, r20
    7dfe:	44 91       	lpm	r20, Z+
		*(uint8_t*)prp(&DI_M[D_N].DDR) &=~prb(&DI_M[D_N].P);
    7e00:	94 2f       	mov	r25, r20
    7e02:	90 95       	com	r25
    7e04:	8c 91       	ld	r24, X
    7e06:	89 23       	and	r24, r25
    7e08:	8c 93       	st	X, r24

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    7e0a:	c9 01       	movw	r24, r18
    7e0c:	88 0f       	add	r24, r24
    7e0e:	99 1f       	adc	r25, r25
    7e10:	88 0f       	add	r24, r24
    7e12:	99 1f       	adc	r25, r25
    7e14:	88 0f       	add	r24, r24
    7e16:	99 1f       	adc	r25, r25
    7e18:	8c 56       	subi	r24, 0x6C	; 108
    7e1a:	93 4d       	sbci	r25, 0xD3	; 211
    7e1c:	fc 01       	movw	r30, r24
    7e1e:	a5 91       	lpm	r26, Z+
    7e20:	b4 91       	lpm	r27, Z+
		*(uint8_t*)prp(&DI_M[D_N].PORT) |=prb(&DI_M[D_N].P);
    7e22:	8c 91       	ld	r24, X
    7e24:	84 2b       	or	r24, r20
    7e26:	8c 93       	st	X, r24
		sei();
    7e28:	78 94       	sei
    7e2a:	2f 5f       	subi	r18, 0xFF	; 255
    7e2c:	3f 4f       	sbci	r19, 0xFF	; 255

// ~~~~~~~~~~~~~~~
static void
DI_Init_Hard(void)
{
	for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
    7e2e:	22 31       	cpi	r18, 0x12	; 18
    7e30:	31 05       	cpc	r19, r1
    7e32:	a1 f6       	brne	.-88     	; 0x7ddc <DI_Init+0x4>
{
	DI_Init_Hard();
	#ifdef HSC_Reg
		HSC_Init();
	#endif
}
    7e34:	08 95       	ret

00007e36 <DO_State>:
} DigOutput;

// ~~~~~~~~~~~~~~~~~~
uint8_t
DO_State(uint8_t D_N)
{
    7e36:	90 e0       	ldi	r25, 0x00	; 0
    7e38:	e8 2f       	mov	r30, r24
    7e3a:	e6 95       	lsr	r30
    7e3c:	e6 95       	lsr	r30
    7e3e:	e6 95       	lsr	r30
    7e40:	f0 e0       	ldi	r31, 0x00	; 0
    7e42:	e6 52       	subi	r30, 0x26	; 38
    7e44:	f8 4f       	sbci	r31, 0xF8	; 248
    7e46:	40 81       	ld	r20, Z
    7e48:	50 e0       	ldi	r21, 0x00	; 0
    7e4a:	87 70       	andi	r24, 0x07	; 7
    7e4c:	21 e0       	ldi	r18, 0x01	; 1
    7e4e:	30 e0       	ldi	r19, 0x00	; 0
    7e50:	02 c0       	rjmp	.+4      	; 0x7e56 <DO_State+0x20>
    7e52:	22 0f       	add	r18, r18
    7e54:	33 1f       	adc	r19, r19
    7e56:	8a 95       	dec	r24
    7e58:	e2 f7       	brpl	.-8      	; 0x7e52 <DO_State+0x1c>
    7e5a:	42 23       	and	r20, r18
    7e5c:	53 23       	and	r21, r19
    7e5e:	14 16       	cp	r1, r20
    7e60:	15 06       	cpc	r1, r21
    7e62:	0c f4       	brge	.+2      	; 0x7e66 <DO_State+0x30>
    7e64:	91 e0       	ldi	r25, 0x01	; 1
	return (DigOutput.State[D_N/8] &(1<<D_N%8)) > 0;
}
    7e66:	89 2f       	mov	r24, r25
    7e68:	08 95       	ret

00007e6a <DO_Front>:

// ~~~~~~~~~~~~~~~~~~
uint8_t
DO_Front(uint8_t D_N)
{
    7e6a:	e8 2f       	mov	r30, r24
	uint8_t Byte=D_N/8, Bit=1<<D_N%8;
    7e6c:	28 2f       	mov	r18, r24
    7e6e:	27 70       	andi	r18, 0x07	; 7
    7e70:	81 e0       	ldi	r24, 0x01	; 1
    7e72:	90 e0       	ldi	r25, 0x00	; 0
    7e74:	01 c0       	rjmp	.+2      	; 0x7e78 <DO_Front+0xe>
    7e76:	88 0f       	add	r24, r24
    7e78:	2a 95       	dec	r18
    7e7a:	ea f7       	brpl	.-6      	; 0x7e76 <DO_Front+0xc>
	uint8_t State = DigOutput.State[Byte] &Bit;
    7e7c:	e6 95       	lsr	r30
    7e7e:	e6 95       	lsr	r30
    7e80:	e6 95       	lsr	r30
    7e82:	f0 e0       	ldi	r31, 0x00	; 0
    7e84:	e6 52       	subi	r30, 0x26	; 38
    7e86:	f8 4f       	sbci	r31, 0xF8	; 248
    7e88:	90 81       	ld	r25, Z
    7e8a:	98 23       	and	r25, r24
	return DigOutput.StateOld[Byte] &Bit ? State?NoFront:FallFront : State?RiseFront:NoFront;
    7e8c:	22 81       	ldd	r18, Z+2	; 0x02
    7e8e:	82 23       	and	r24, r18
    7e90:	21 f0       	breq	.+8      	; 0x7e9a <DO_Front+0x30>
    7e92:	99 23       	and	r25, r25
    7e94:	41 f4       	brne	.+16     	; 0x7ea6 <DO_Front+0x3c>
    7e96:	82 e0       	ldi	r24, 0x02	; 2
    7e98:	08 95       	ret
    7e9a:	89 2f       	mov	r24, r25
    7e9c:	99 23       	and	r25, r25
    7e9e:	09 f4       	brne	.+2      	; 0x7ea2 <DO_Front+0x38>
}
    7ea0:	08 95       	ret
uint8_t
DO_Front(uint8_t D_N)
{
	uint8_t Byte=D_N/8, Bit=1<<D_N%8;
	uint8_t State = DigOutput.State[Byte] &Bit;
	return DigOutput.StateOld[Byte] &Bit ? State?NoFront:FallFront : State?RiseFront:NoFront;
    7ea2:	81 e0       	ldi	r24, 0x01	; 1
}
    7ea4:	08 95       	ret
uint8_t
DO_Front(uint8_t D_N)
{
	uint8_t Byte=D_N/8, Bit=1<<D_N%8;
	uint8_t State = DigOutput.State[Byte] &Bit;
	return DigOutput.StateOld[Byte] &Bit ? State?NoFront:FallFront : State?RiseFront:NoFront;
    7ea6:	80 e0       	ldi	r24, 0x00	; 0
    7ea8:	08 95       	ret

00007eaa <SetDigOut>:

// ~~~~~~~~~~~~~~~~~~~
void
SetDigOut(uint8_t D_N)
{
	DigOutput.Buf[D_N/8] |=(1<<D_N%8);
    7eaa:	98 2f       	mov	r25, r24
    7eac:	96 95       	lsr	r25
    7eae:	96 95       	lsr	r25
    7eb0:	96 95       	lsr	r25
    7eb2:	ea ed       	ldi	r30, 0xDA	; 218
    7eb4:	f7 e0       	ldi	r31, 0x07	; 7
    7eb6:	e9 0f       	add	r30, r25
    7eb8:	f1 1d       	adc	r31, r1
    7eba:	87 70       	andi	r24, 0x07	; 7
    7ebc:	21 e0       	ldi	r18, 0x01	; 1
    7ebe:	30 e0       	ldi	r19, 0x00	; 0
    7ec0:	02 c0       	rjmp	.+4      	; 0x7ec6 <SetDigOut+0x1c>
    7ec2:	22 0f       	add	r18, r18
    7ec4:	33 1f       	adc	r19, r19
    7ec6:	8a 95       	dec	r24
    7ec8:	e2 f7       	brpl	.-8      	; 0x7ec2 <SetDigOut+0x18>
    7eca:	84 81       	ldd	r24, Z+4	; 0x04
    7ecc:	82 2b       	or	r24, r18
    7ece:	84 83       	std	Z+4, r24	; 0x04
}
    7ed0:	08 95       	ret

00007ed2 <ResDigOut>:

// ~~~~~~~~~~~~~~~~~~~
void
ResDigOut(uint8_t D_N)
{
	DigOutput.Buf[D_N/8] &=~(1<<D_N%8);
    7ed2:	98 2f       	mov	r25, r24
    7ed4:	96 95       	lsr	r25
    7ed6:	96 95       	lsr	r25
    7ed8:	96 95       	lsr	r25
    7eda:	ea ed       	ldi	r30, 0xDA	; 218
    7edc:	f7 e0       	ldi	r31, 0x07	; 7
    7ede:	e9 0f       	add	r30, r25
    7ee0:	f1 1d       	adc	r31, r1
    7ee2:	87 70       	andi	r24, 0x07	; 7
    7ee4:	21 e0       	ldi	r18, 0x01	; 1
    7ee6:	30 e0       	ldi	r19, 0x00	; 0
    7ee8:	02 c0       	rjmp	.+4      	; 0x7eee <ResDigOut+0x1c>
    7eea:	22 0f       	add	r18, r18
    7eec:	33 1f       	adc	r19, r19
    7eee:	8a 95       	dec	r24
    7ef0:	e2 f7       	brpl	.-8      	; 0x7eea <ResDigOut+0x18>
    7ef2:	20 95       	com	r18
    7ef4:	84 81       	ldd	r24, Z+4	; 0x04
    7ef6:	28 23       	and	r18, r24
    7ef8:	24 83       	std	Z+4, r18	; 0x04
}
    7efa:	08 95       	ret

00007efc <TogDigOut>:

// ~~~~~~~~~~~~~~~~~~~
void
TogDigOut(uint8_t D_N)
{
	DigOutput.Buf[D_N/8] ^=(1<<D_N%8);
    7efc:	98 2f       	mov	r25, r24
    7efe:	96 95       	lsr	r25
    7f00:	96 95       	lsr	r25
    7f02:	96 95       	lsr	r25
    7f04:	ea ed       	ldi	r30, 0xDA	; 218
    7f06:	f7 e0       	ldi	r31, 0x07	; 7
    7f08:	e9 0f       	add	r30, r25
    7f0a:	f1 1d       	adc	r31, r1
    7f0c:	87 70       	andi	r24, 0x07	; 7
    7f0e:	21 e0       	ldi	r18, 0x01	; 1
    7f10:	30 e0       	ldi	r19, 0x00	; 0
    7f12:	02 c0       	rjmp	.+4      	; 0x7f18 <TogDigOut+0x1c>
    7f14:	22 0f       	add	r18, r18
    7f16:	33 1f       	adc	r19, r19
    7f18:	8a 95       	dec	r24
    7f1a:	e2 f7       	brpl	.-8      	; 0x7f14 <TogDigOut+0x18>
    7f1c:	84 81       	ldd	r24, Z+4	; 0x04
    7f1e:	82 27       	eor	r24, r18
    7f20:	84 83       	std	Z+4, r24	; 0x04
}
    7f22:	08 95       	ret

00007f24 <SetAllDigOut>:

// ~~~~~~~~~~~~~~~
void
SetAllDigOut(void)
{
	for (uint8_t i=0; i<DO_Reg; DigOutput.Buf[i++]=0xFF);
    7f24:	8f ef       	ldi	r24, 0xFF	; 255
    7f26:	80 93 de 07 	sts	0x07DE, r24
    7f2a:	80 93 df 07 	sts	0x07DF, r24
}
    7f2e:	08 95       	ret

00007f30 <DO_Enable>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    7f30:	8f b7       	in	r24, 0x3f	; 63
    7f32:	80 78       	andi	r24, 0x80	; 128
    7f34:	80 93 ee 02 	sts	0x02EE, r24
	cli();
    7f38:	f8 94       	cli
void
DO_Enable(void)
{
	#ifdef Enable
		IntOff();
		PortEnable |=Enable;
    7f3a:	46 9a       	sbi	0x08, 6	; 8

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    7f3c:	88 23       	and	r24, r24
    7f3e:	09 f0       	breq	.+2      	; 0x7f42 <DO_Enable+0x12>
		sei();
    7f40:	78 94       	sei
    7f42:	08 95       	ret

00007f44 <DO_Disable>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    7f44:	8f b7       	in	r24, 0x3f	; 63
    7f46:	80 78       	andi	r24, 0x80	; 128
    7f48:	80 93 ee 02 	sts	0x02EE, r24
	cli();
    7f4c:	f8 94       	cli
void
DO_Disable()
{
	#ifdef Enable
		IntOff();
		PortEnable &=~Enable;
    7f4e:	46 98       	cbi	0x08, 6	; 8

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    7f50:	88 23       	and	r24, r24
    7f52:	09 f0       	breq	.+2      	; 0x7f56 <DO_Disable+0x12>
		sei();
    7f54:	78 94       	sei
    7f56:	08 95       	ret

00007f58 <DigitOut>:

// ~~~~~~~~~~~
void
DigitOut(void)
{
	memcpy(DigOutput.StateOld, DigOutput.State, DO_Reg+DO_Reg_Ext);
    7f58:	90 91 da 07 	lds	r25, 0x07DA
    7f5c:	80 91 db 07 	lds	r24, 0x07DB
    7f60:	80 93 dd 07 	sts	0x07DD, r24
    7f64:	90 93 dc 07 	sts	0x07DC, r25
	memcpy(DigOutput.State, DigOutput.Buf, DO_Reg);
    7f68:	90 91 de 07 	lds	r25, 0x07DE
    7f6c:	80 91 df 07 	lds	r24, 0x07DF
    7f70:	80 93 db 07 	sts	0x07DB, r24
    7f74:	90 93 da 07 	sts	0x07DA, r25
    7f78:	20 e1       	ldi	r18, 0x10	; 16
    7f7a:	35 e0       	ldi	r19, 0x05	; 5
    7f7c:	10 c0       	rjmp	.+32     	; 0x7f9e <DigitOut+0x46>
	uint8_t N = DO_Reg*8;
	while (N) {
		uint8_t D_N = prb(M+--N);
		cli();
		if (DigOutput.State[D_N/8] &(1<<D_N%8))
			PortData  |=Data;
    7f7e:	47 9a       	sbi	0x08, 7	; 8
		else
			PortData &=~Data;
		sei();
    7f80:	78 94       	sei
    7f82:	83 2f       	mov	r24, r19
    7f84:	8a 95       	dec	r24
    7f86:	f1 f7       	brne	.-4      	; 0x7f84 <DigitOut+0x2c>
		_delay_us(1);				// 125 ns needs at 5V
		cli();
    7f88:	f8 94       	cli
		PortClock |=Clock;
    7f8a:	45 9a       	sbi	0x08, 5	; 8
		sei();
    7f8c:	78 94       	sei
    7f8e:	83 2f       	mov	r24, r19
    7f90:	8a 95       	dec	r24
    7f92:	f1 f7       	brne	.-4      	; 0x7f90 <DigitOut+0x38>
		_delay_us(1);				// 200 ns needs at 5V
		cli();
    7f94:	f8 94       	cli
		PortClock &=~Clock;
    7f96:	45 98       	cbi	0x08, 5	; 8
		sei();
    7f98:	78 94       	sei
DigitOut_Hard(void)
{
	static prog_uint8_t M[DO_Reg*8] = DO_Map;

	uint8_t N = DO_Reg*8;
	while (N) {
    7f9a:	22 23       	and	r18, r18
    7f9c:	d1 f0       	breq	.+52     	; 0x7fd2 <DigitOut+0x7a>
		uint8_t D_N = prb(M+--N);
    7f9e:	21 50       	subi	r18, 0x01	; 1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    7fa0:	e2 2f       	mov	r30, r18
    7fa2:	f0 e0       	ldi	r31, 0x00	; 0
    7fa4:	ee 57       	subi	r30, 0x7E	; 126
    7fa6:	f3 4d       	sbci	r31, 0xD3	; 211
    7fa8:	e4 91       	lpm	r30, Z+
		cli();
    7faa:	f8 94       	cli
		if (DigOutput.State[D_N/8] &(1<<D_N%8))
    7fac:	ae 2f       	mov	r26, r30
    7fae:	a6 95       	lsr	r26
    7fb0:	a6 95       	lsr	r26
    7fb2:	a6 95       	lsr	r26
    7fb4:	b0 e0       	ldi	r27, 0x00	; 0
    7fb6:	a6 52       	subi	r26, 0x26	; 38
    7fb8:	b8 4f       	sbci	r27, 0xF8	; 248
    7fba:	8c 91       	ld	r24, X
    7fbc:	90 e0       	ldi	r25, 0x00	; 0
    7fbe:	e7 70       	andi	r30, 0x07	; 7
    7fc0:	02 c0       	rjmp	.+4      	; 0x7fc6 <DigitOut+0x6e>
    7fc2:	95 95       	asr	r25
    7fc4:	87 95       	ror	r24
    7fc6:	ea 95       	dec	r30
    7fc8:	e2 f7       	brpl	.-8      	; 0x7fc2 <DigitOut+0x6a>
    7fca:	80 fd       	sbrc	r24, 0
    7fcc:	d8 cf       	rjmp	.-80     	; 0x7f7e <DigitOut+0x26>
			PortData  |=Data;
		else
			PortData &=~Data;
    7fce:	47 98       	cbi	0x08, 7	; 8
    7fd0:	d7 cf       	rjmp	.-82     	; 0x7f80 <DigitOut+0x28>
		_delay_us(1);				// 200 ns needs at 5V
		cli();
		PortClock &=~Clock;
		sei();
	}
	cli();
    7fd2:	f8 94       	cli
	PortStrobe |=Strobe;
    7fd4:	80 91 05 01 	lds	r24, 0x0105
    7fd8:	81 60       	ori	r24, 0x01	; 1
    7fda:	80 93 05 01 	sts	0x0105, r24
	sei();
    7fde:	78 94       	sei
    7fe0:	85 e0       	ldi	r24, 0x05	; 5
    7fe2:	8a 95       	dec	r24
    7fe4:	f1 f7       	brne	.-4      	; 0x7fe2 <DigitOut+0x8a>
	_delay_us(1);					// 200 ns needs at 5V
	cli();
    7fe6:	f8 94       	cli
	PortStrobe &=~Strobe;
    7fe8:	80 91 05 01 	lds	r24, 0x0105
    7fec:	8e 7f       	andi	r24, 0xFE	; 254
    7fee:	80 93 05 01 	sts	0x0105, r24
	sei();
    7ff2:	78 94       	sei
				DigOutput.State[j] = (DigOutput_Ext)[i];
			(DigOutput_Ext)[i+DO_Reg_Ext] = DigOutput.Buf[j];
			IntOn();
		}
	#endif
}
    7ff4:	08 95       	ret

00007ff6 <DO_Init>:

// ~~~~~~~~~~~~~~~
static void
DO_Init_Hard(void)
{
	cli();
    7ff6:	f8 94       	cli
	DDR_Strobe |= Strobe;
    7ff8:	e4 e0       	ldi	r30, 0x04	; 4
    7ffa:	f1 e0       	ldi	r31, 0x01	; 1
    7ffc:	80 81       	ld	r24, Z
    7ffe:	81 60       	ori	r24, 0x01	; 1
    8000:	80 83       	st	Z, r24
	DDR_Data |= Data;
    8002:	3f 9a       	sbi	0x07, 7	; 7
	DDR_Enable |= Enable;
    8004:	3e 9a       	sbi	0x07, 6	; 7
	DDR_Clock |=Clock;
    8006:	3d 9a       	sbi	0x07, 5	; 7
	PortStrobe &=~Strobe;
    8008:	e5 e0       	ldi	r30, 0x05	; 5
    800a:	f1 e0       	ldi	r31, 0x01	; 1
    800c:	80 81       	ld	r24, Z
    800e:	8e 7f       	andi	r24, 0xFE	; 254
    8010:	80 83       	st	Z, r24
	PortClock &=~Clock;
    8012:	45 98       	cbi	0x08, 5	; 8
	sei();
    8014:	78 94       	sei
// ~~~~~~~~~~
void
DO_Init(void)
{
	DO_Init_Hard();
	DigitOut();		// Clear all
    8016:	0e 94 ac 3f 	call	0x7f58	; 0x7f58 <DigitOut>
	DO_Enable();
    801a:	0e 94 98 3f 	call	0x7f30	; 0x7f30 <DO_Enable>
}
    801e:	08 95       	ret

00008020 <AI_Init>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    8020:	e0 91 00 05 	lds	r30, 0x0500
    8024:	f0 e0       	ldi	r31, 0x00	; 0
    8026:	ee 0f       	add	r30, r30
    8028:	ff 1f       	adc	r31, r31
    802a:	ee 58       	subi	r30, 0x8E	; 142
    802c:	f3 4d       	sbci	r31, 0xD3	; 211
    802e:	85 91       	lpm	r24, Z+
    8030:	94 91       	lpm	r25, Z+
// ~~~~~~~~~~~
static void
SetMuxAI(void)
{
	static prog_uint16_t Mux[] = AI_Mux;
	ADMUX = (uint8_t) prw(Mux+AI_N);
    8032:	80 93 7c 00 	sts	0x007C, r24
	#ifdef MUX5
		ADCSRB = (uint8_t) (prw(Mux+AI_N)>>8);
    8036:	90 93 7b 00 	sts	0x007B, r25
		#ifdef AN_C
			DDR_AN_C |=AN_C;
		#endif
	#endif
	SetMuxAI();
	ADCSRA = (((((1<<ADEN) |(1<<ADSC)) &~(1<<AD_Mode)) |(1<<ADIF)) &~(1<<ADIE)) |(1<<ADPS2) |(1<<ADPS1) |(1<<ADPS0);
    803a:	87 ed       	ldi	r24, 0xD7	; 215
    803c:	80 93 7a 00 	sts	0x007A, r24
		}
	#endif
	#ifdef InitAI_10ms
		TD_InnADC = Timer8SysAlloc(AI_Reg);
	#endif
}
    8040:	08 95       	ret

00008042 <AnalogIn>:

// ~~~~~~~~~~~
uint8_t
AnalogIn(void)
{
	if (ADCSRA &(1<<ADSC))
    8042:	80 91 7a 00 	lds	r24, 0x007A
    8046:	86 fd       	sbrc	r24, 6
    8048:	2c c0       	rjmp	.+88     	; 0x80a2 <AnalogIn+0x60>
		return AI_Reg;
	AnalogInput[AI_N] = ADCL;
    804a:	50 91 00 05 	lds	r21, 0x0500
    804e:	65 2f       	mov	r22, r21
    8050:	20 91 78 00 	lds	r18, 0x0078
	AnalogInput[AI_N] |= ADCH<<8;
    8054:	40 91 79 00 	lds	r20, 0x0079
    8058:	e5 2f       	mov	r30, r21
    805a:	f0 e0       	ldi	r31, 0x00	; 0
    805c:	ee 0f       	add	r30, r30
    805e:	ff 1f       	adc	r31, r31
    8060:	e3 5b       	subi	r30, 0xB3	; 179
    8062:	f4 4f       	sbci	r31, 0xF4	; 244
    8064:	94 2f       	mov	r25, r20
    8066:	80 e0       	ldi	r24, 0x00	; 0
    8068:	30 e0       	ldi	r19, 0x00	; 0
    806a:	82 2b       	or	r24, r18
    806c:	93 2b       	or	r25, r19
    806e:	91 83       	std	Z+1, r25	; 0x01
    8070:	80 83       	st	Z, r24
		}
		else
			Chan = AI_Reg;
	#endif

	if (++AI_N == AI_Reg)
    8072:	5f 5f       	subi	r21, 0xFF	; 255
    8074:	50 93 00 05 	sts	0x0500, r21
    8078:	58 30       	cpi	r21, 0x08	; 8
    807a:	b1 f0       	breq	.+44     	; 0x80a8 <AnalogIn+0x66>
    807c:	e5 2f       	mov	r30, r21
    807e:	f0 e0       	ldi	r31, 0x00	; 0
    8080:	ee 0f       	add	r30, r30
    8082:	ff 1f       	adc	r31, r31
    8084:	ee 58       	subi	r30, 0x8E	; 142
    8086:	f3 4d       	sbci	r31, 0xD3	; 211
    8088:	85 91       	lpm	r24, Z+
    808a:	94 91       	lpm	r25, Z+
// ~~~~~~~~~~~
static void
SetMuxAI(void)
{
	static prog_uint16_t Mux[] = AI_Mux;
	ADMUX = (uint8_t) prw(Mux+AI_N);
    808c:	80 93 7c 00 	sts	0x007C, r24
	#ifdef MUX5
		ADCSRB = (uint8_t) (prw(Mux+AI_N)>>8);
    8090:	90 93 7b 00 	sts	0x007B, r25
	#endif

	if (++AI_N == AI_Reg)
		AI_N = 0;
	SetMuxAI();
	ADCSRA |=(1<<ADSC);
    8094:	80 91 7a 00 	lds	r24, 0x007A
    8098:	80 64       	ori	r24, 0x40	; 64
    809a:	80 93 7a 00 	sts	0x007A, r24
			IntOn();
		}
	#endif

	return Chan;
}
    809e:	86 2f       	mov	r24, r22
    80a0:	08 95       	ret

// ~~~~~~~~~~~
uint8_t
AnalogIn(void)
{
	if (ADCSRA &(1<<ADSC))
    80a2:	68 e0       	ldi	r22, 0x08	; 8
			IntOn();
		}
	#endif

	return Chan;
}
    80a4:	86 2f       	mov	r24, r22
    80a6:	08 95       	ret
		else
			Chan = AI_Reg;
	#endif

	if (++AI_N == AI_Reg)
		AI_N = 0;
    80a8:	10 92 00 05 	sts	0x0500, r1
    80ac:	50 e0       	ldi	r21, 0x00	; 0
    80ae:	e6 cf       	rjmp	.-52     	; 0x807c <AnalogIn+0x3a>

000080b0 <Thermode>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
int16_t
Thermode(uint8_t T_Fami, uint8_t T_Type, uint16_t Code)
{
	if (T_Type==ThermOff)
    80b0:	66 23       	and	r22, r22
    80b2:	f9 f0       	breq	.+62     	; 0x80f2 <Thermode+0x42>
		return Therm_Off_Mark;
	if (T_Fami==Thermis)
    80b4:	88 23       	and	r24, r24
    80b6:	91 f4       	brne	.+36     	; 0x80dc <Thermode+0x2c>
		switch(T_Type) {
    80b8:	64 30       	cpi	r22, 0x04	; 4
    80ba:	d9 f1       	breq	.+118    	; 0x8132 <Thermode+0x82>
    80bc:	65 30       	cpi	r22, 0x05	; 5
    80be:	60 f5       	brcc	.+88     	; 0x8118 <Thermode+0x68>
    80c0:	62 30       	cpi	r22, 0x02	; 2
    80c2:	09 f4       	brne	.+2      	; 0x80c6 <Thermode+0x16>
    80c4:	4b c0       	rjmp	.+150    	; 0x815c <Thermode+0xac>
    80c6:	63 30       	cpi	r22, 0x03	; 3
    80c8:	d8 f5       	brcc	.+118    	; 0x8140 <Thermode+0x90>
    80ca:	61 30       	cpi	r22, 0x01	; 1
    80cc:	a1 f4       	brne	.+40     	; 0x80f6 <Thermode+0x46>
		case TSM100:
			return ThermCalc(TSM100);
    80ce:	8a e2       	ldi	r24, 0x2A	; 42
    80d0:	9b e2       	ldi	r25, 0x2B	; 43
    80d2:	ba 01       	movw	r22, r20
    80d4:	0e 94 03 23 	call	0x4606	; 0x4606 <PGM_uBrokLine>
    80d8:	ac 01       	movw	r20, r24
    80da:	0d c0       	rjmp	.+26     	; 0x80f6 <Thermode+0x46>
#endif
		default:
			return Code;
		}
	else	// T_Fami==Thermoc
		switch(T_Type) {
    80dc:	61 30       	cpi	r22, 0x01	; 1
    80de:	69 f0       	breq	.+26     	; 0x80fa <Thermode+0x4a>
    80e0:	62 30       	cpi	r22, 0x02	; 2
    80e2:	49 f4       	brne	.+18     	; 0x80f6 <Thermode+0x46>
		case TC_K:
			return .1851*Code;
#endif
#if	TerInput==ADC_Input
		case TC_B:
			return ThermCalc(TC_B_);
    80e4:	8e e2       	ldi	r24, 0x2E	; 46
    80e6:	9c e2       	ldi	r25, 0x2C	; 44
    80e8:	ba 01       	movw	r22, r20
    80ea:	0e 94 03 23 	call	0x4606	; 0x4606 <PGM_uBrokLine>
    80ee:	ac 01       	movw	r20, r24
    80f0:	02 c0       	rjmp	.+4      	; 0x80f6 <Thermode+0x46>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
int16_t
Thermode(uint8_t T_Fami, uint8_t T_Type, uint16_t Code)
{
	if (T_Type==ThermOff)
    80f2:	40 e0       	ldi	r20, 0x00	; 0
    80f4:	50 e8       	ldi	r21, 0x80	; 128
			return ThermCalc(TC_B_);
#endif
		default:
			return Code;
		}
}
    80f6:	ca 01       	movw	r24, r20
    80f8:	08 95       	ret
			return ThermCalc(TC_J_) + InnerTer;
		case TC_L:
			return ThermCalc(TC_L_) + InnerTer;
#else
		case TC_K:
			return .1851*Code;
    80fa:	ba 01       	movw	r22, r20
    80fc:	80 e0       	ldi	r24, 0x00	; 0
    80fe:	90 e0       	ldi	r25, 0x00	; 0
    8100:	0e 94 06 7f 	call	0xfe0c	; 0xfe0c <__floatunsisf>
    8104:	2b ed       	ldi	r18, 0xDB	; 219
    8106:	3a e8       	ldi	r19, 0x8A	; 138
    8108:	4d e3       	ldi	r20, 0x3D	; 61
    810a:	5e e3       	ldi	r21, 0x3E	; 62
    810c:	0e 94 43 7f 	call	0xfe86	; 0xfe86 <__mulsf3>
    8110:	0e 94 d6 83 	call	0x107ac	; 0x107ac <__fixsfsi>
    8114:	ab 01       	movw	r20, r22
    8116:	ef cf       	rjmp	.-34     	; 0x80f6 <Thermode+0x46>
Thermode(uint8_t T_Fami, uint8_t T_Type, uint16_t Code)
{
	if (T_Type==ThermOff)
		return Therm_Off_Mark;
	if (T_Fami==Thermis)
		switch(T_Type) {
    8118:	66 30       	cpi	r22, 0x06	; 6
    811a:	39 f1       	breq	.+78     	; 0x816a <Thermode+0xba>
    811c:	66 30       	cpi	r22, 0x06	; 6
    811e:	b8 f0       	brcs	.+46     	; 0x814e <Thermode+0x9e>
    8120:	67 30       	cpi	r22, 0x07	; 7
    8122:	49 f7       	brne	.-46     	; 0x80f6 <Thermode+0x46>
			return ThermCalc(Pt100);
#if	TerInput==ADC_Input
		case Gr21:
			return ThermCalc(Gr21);
		case Gr23:
			return ThermCalc(Gr23);
    8124:	8e e0       	ldi	r24, 0x0E	; 14
    8126:	9c e2       	ldi	r25, 0x2C	; 44
    8128:	ba 01       	movw	r22, r20
    812a:	0e 94 03 23 	call	0x4606	; 0x4606 <PGM_uBrokLine>
    812e:	ac 01       	movw	r20, r24
    8130:	e2 cf       	rjmp	.-60     	; 0x80f6 <Thermode+0x46>
		case TSM50:
			return ThermCalc(TSM50);
		case TSP100:
			return ThermCalc(TSP100);
		case TSP50:
			return ThermCalc(TSP50);
    8132:	8e e9       	ldi	r24, 0x9E	; 158
    8134:	9b e2       	ldi	r25, 0x2B	; 43
    8136:	ba 01       	movw	r22, r20
    8138:	0e 94 03 23 	call	0x4606	; 0x4606 <PGM_uBrokLine>
    813c:	ac 01       	movw	r20, r24
    813e:	db cf       	rjmp	.-74     	; 0x80f6 <Thermode+0x46>
		case TSM100:
			return ThermCalc(TSM100);
		case TSM50:
			return ThermCalc(TSM50);
		case TSP100:
			return ThermCalc(TSP100);
    8140:	86 e7       	ldi	r24, 0x76	; 118
    8142:	9b e2       	ldi	r25, 0x2B	; 43
    8144:	ba 01       	movw	r22, r20
    8146:	0e 94 03 23 	call	0x4606	; 0x4606 <PGM_uBrokLine>
    814a:	ac 01       	movw	r20, r24
    814c:	d4 cf       	rjmp	.-88     	; 0x80f6 <Thermode+0x46>
		case TSP50:
			return ThermCalc(TSP50);
		case Pt100:
			return ThermCalc(Pt100);
    814e:	82 ec       	ldi	r24, 0xC2	; 194
    8150:	9b e2       	ldi	r25, 0x2B	; 43
    8152:	ba 01       	movw	r22, r20
    8154:	0e 94 03 23 	call	0x4606	; 0x4606 <PGM_uBrokLine>
    8158:	ac 01       	movw	r20, r24
    815a:	cd cf       	rjmp	.-102    	; 0x80f6 <Thermode+0x46>
	if (T_Fami==Thermis)
		switch(T_Type) {
		case TSM100:
			return ThermCalc(TSM100);
		case TSM50:
			return ThermCalc(TSM50);
    815c:	8a e4       	ldi	r24, 0x4A	; 74
    815e:	9b e2       	ldi	r25, 0x2B	; 43
    8160:	ba 01       	movw	r22, r20
    8162:	0e 94 03 23 	call	0x4606	; 0x4606 <PGM_uBrokLine>
    8166:	ac 01       	movw	r20, r24
    8168:	c6 cf       	rjmp	.-116    	; 0x80f6 <Thermode+0x46>
			return ThermCalc(TSP50);
		case Pt100:
			return ThermCalc(Pt100);
#if	TerInput==ADC_Input
		case Gr21:
			return ThermCalc(Gr21);
    816a:	8a ee       	ldi	r24, 0xEA	; 234
    816c:	9b e2       	ldi	r25, 0x2B	; 43
    816e:	ba 01       	movw	r22, r20
    8170:	0e 94 03 23 	call	0x4606	; 0x4606 <PGM_uBrokLine>
    8174:	ac 01       	movw	r20, r24
    8176:	bf cf       	rjmp	.-130    	; 0x80f6 <Thermode+0x46>

00008178 <ThermExt>:
			IntOff();
			Temperature[TerReg+i] = (Temperature_Ext)[i];
			IntOn();
		}
	#endif
}
    8178:	08 95       	ret

0000817a <Therm_ADC_Off>:

// ~~~~~~~~~~~~~~~~
void
Therm_ADC_Off(void)
{
	for (uint8_t i=0; i<TerReg; Temperature[i++]=ADC_Off_Mark);
    817a:	81 e0       	ldi	r24, 0x01	; 1
    817c:	90 e8       	ldi	r25, 0x80	; 128
    817e:	90 93 46 06 	sts	0x0646, r25
    8182:	80 93 45 06 	sts	0x0645, r24
    8186:	90 93 48 06 	sts	0x0648, r25
    818a:	80 93 47 06 	sts	0x0647, r24
    818e:	90 93 4a 06 	sts	0x064A, r25
    8192:	80 93 49 06 	sts	0x0649, r24
    8196:	90 93 4c 06 	sts	0x064C, r25
    819a:	80 93 4b 06 	sts	0x064B, r24
    819e:	90 93 4e 06 	sts	0x064E, r25
    81a2:	80 93 4d 06 	sts	0x064D, r24
    81a6:	90 93 50 06 	sts	0x0650, r25
    81aa:	80 93 4f 06 	sts	0x064F, r24
}
    81ae:	08 95       	ret

000081b0 <ThermWrong>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
ThermWrong(uint8_t T_Fami, uint8_t T_Type, int16_t Ter)
{
	uint8_t TW = ThermNorm;
	if (T_Type!=ThermOff && T_Type<=prb(MaxThermType+T_Fami)) {
    81b0:	66 23       	and	r22, r22
    81b2:	31 f1       	breq	.+76     	; 0x8200 <ThermWrong+0x50>
    81b4:	28 2f       	mov	r18, r24
    81b6:	30 e0       	ldi	r19, 0x00	; 0

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    81b8:	f9 01       	movw	r30, r18
    81ba:	ec 5d       	subi	r30, 0xDC	; 220
    81bc:	f4 4d       	sbci	r31, 0xD4	; 212
    81be:	e4 91       	lpm	r30, Z+
    81c0:	e6 17       	cp	r30, r22
    81c2:	f0 f0       	brcs	.+60     	; 0x8200 <ThermWrong+0x50>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    81c4:	f9 01       	movw	r30, r18
    81c6:	ee 0f       	add	r30, r30
    81c8:	ff 1f       	adc	r31, r31
    81ca:	ea 5d       	subi	r30, 0xDA	; 218
    81cc:	f4 4d       	sbci	r31, 0xD4	; 212
    81ce:	25 91       	lpm	r18, Z+
    81d0:	34 91       	lpm	r19, Z+
		TerLim *T_L = prp(TerLimType+T_Fami);
		if (Ter<(int16_t)prw(&T_L[T_Type].Low))
    81d2:	86 2f       	mov	r24, r22
    81d4:	90 e0       	ldi	r25, 0x00	; 0
    81d6:	88 0f       	add	r24, r24
    81d8:	99 1f       	adc	r25, r25
    81da:	88 0f       	add	r24, r24
    81dc:	99 1f       	adc	r25, r25
    81de:	28 0f       	add	r18, r24
    81e0:	39 1f       	adc	r19, r25

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    81e2:	f9 01       	movw	r30, r18
    81e4:	85 91       	lpm	r24, Z+
    81e6:	94 91       	lpm	r25, Z+
    81e8:	48 17       	cp	r20, r24
    81ea:	59 07       	cpc	r21, r25
    81ec:	5c f0       	brlt	.+22     	; 0x8204 <ThermWrong+0x54>
    81ee:	f9 01       	movw	r30, r18
    81f0:	32 96       	adiw	r30, 0x02	; 2
    81f2:	85 91       	lpm	r24, Z+
    81f4:	94 91       	lpm	r25, Z+
			TW = ThermUnder;
		else if(Ter>(int16_t)prw(&T_L[T_Type].Upp))
    81f6:	84 17       	cp	r24, r20
    81f8:	95 07       	cpc	r25, r21
    81fa:	14 f4       	brge	.+4      	; 0x8200 <ThermWrong+0x50>
    81fc:	82 e0       	ldi	r24, 0x02	; 2
    81fe:	08 95       	ret
    8200:	80 e0       	ldi	r24, 0x00	; 0
			TW = ThermOver;
	}
	return TW;
}
    8202:	08 95       	ret
ThermWrong(uint8_t T_Fami, uint8_t T_Type, int16_t Ter)
{
	uint8_t TW = ThermNorm;
	if (T_Type!=ThermOff && T_Type<=prb(MaxThermType+T_Fami)) {
		TerLim *T_L = prp(TerLimType+T_Fami);
		if (Ter<(int16_t)prw(&T_L[T_Type].Low))
    8204:	81 e0       	ldi	r24, 0x01	; 1
    8206:	08 95       	ret

00008208 <Key_MB0_CPT_Clear>:
	{" BAUD: }}}}}bps     ", NULL, F_MB##N##_Baud}																														\
};																																																					\
MenuPage MenuModbus##N = {SetMenu(L_MB##N), 1};

#if Modbus_Qt == 1
	M_Modbus(0)
    8208:	80 e0       	ldi	r24, 0x00	; 0
    820a:	90 e0       	ldi	r25, 0x00	; 0

// ~~~~~~~~~~~~~~~~~~~~~~~
void
MB_CPT_Clear(uint8_t MB_N)
{
	for (uint8_t i=0; i<8; MB_CPT[MB_N][i++]=0);
    820c:	fc 01       	movw	r30, r24
    820e:	ee 0f       	add	r30, r30
    8210:	ff 1f       	adc	r31, r31
    8212:	eb 5c       	subi	r30, 0xCB	; 203
    8214:	f6 4f       	sbci	r31, 0xF6	; 246
    8216:	11 82       	std	Z+1, r1	; 0x01
    8218:	10 82       	st	Z, r1
    821a:	01 96       	adiw	r24, 0x01	; 1
    821c:	88 30       	cpi	r24, 0x08	; 8
    821e:	91 05       	cpc	r25, r1
    8220:	a9 f7       	brne	.-22     	; 0x820c <Key_MB0_CPT_Clear+0x4>
    8222:	81 e0       	ldi	r24, 0x01	; 1
    8224:	08 95       	ret

00008226 <ResetGSMState>:
	#ifdef GSM_DEBUG
		MenuPage MenuGSMConsole;
	#endif

	void ResetGSMState(void){
		GSM_State = GSM_ReStart1;
    8226:	8a e4       	ldi	r24, 0x4A	; 74
    8228:	80 93 f6 06 	sts	0x06F6, r24
	}
    822c:	08 95       	ret

0000822e <Key_MaxScanCycle_Clear>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
InField F_ScanCycle[] = { {Byte, &ScanCycle} };
InField F_ScanCyclePerSec[] = { {Word, &ScanPerSec} }; 
InField F_MaxScanCycle[] = {{Byte, &MaxScanCycle}};

uint8_t Key_MaxScanCycle_Clear(void) {if(CurrLine==3) MaxScanCycle_Clear(); return StandartKey;}
    822e:	80 91 c9 07 	lds	r24, 0x07C9
    8232:	83 30       	cpi	r24, 0x03	; 3
    8234:	11 f4       	brne	.+4      	; 0x823a <Key_MaxScanCycle_Clear+0xc>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
void
MaxScanCycle_Clear(void)
{
	MaxScanCycle = 0;
    8236:	10 92 b1 06 	sts	0x06B1, r1
    823a:	80 e0       	ldi	r24, 0x00	; 0
    823c:	08 95       	ret

0000823e <Caller_StartCalling>:
uint8_t CallerState;
uint8_t CallerMessage[2];
uint8_t CurrentAbonent;
uint8_t CurrentCall;
void Caller_StartCalling(uint8_t inputN){
	CallerMessage[0]=1;
    823e:	91 e0       	ldi	r25, 0x01	; 1
    8240:	90 93 b6 07 	sts	0x07B6, r25
	CallerMessage[1]=inputN;
    8244:	80 93 b7 07 	sts	0x07B7, r24
}
    8248:	08 95       	ret

0000824a <CallerCycle>:

void CallerCycle(){
	
	switch(Caller_state){
    824a:	80 91 e4 02 	lds	r24, 0x02E4
    824e:	81 30       	cpi	r24, 0x01	; 1
    8250:	39 f1       	breq	.+78     	; 0x82a0 <CallerCycle+0x56>
    8252:	81 30       	cpi	r24, 0x01	; 1
    8254:	70 f4       	brcc	.+28     	; 0x8272 <CallerCycle+0x28>
		case CALLER_IDLE:
			if(0 != CallerMessage[0]){
    8256:	80 91 b6 07 	lds	r24, 0x07B6
    825a:	88 23       	and	r24, r24
    825c:	61 f0       	breq	.+24     	; 0x8276 <CallerCycle+0x2c>
				CallerMessage[0] = 0;
    825e:	10 92 b6 07 	sts	0x07B6, r1
				CurrentAbonent = 0;
    8262:	10 92 38 07 	sts	0x0738, r1
				CurrentCall = 0;
    8266:	10 92 d9 07 	sts	0x07D9, r1
				Caller_state = CHECK_PHONE_BUSY;
    826a:	81 e0       	ldi	r24, 0x01	; 1
    826c:	80 93 e4 02 	sts	0x02E4, r24
    8270:	08 95       	ret
	CallerMessage[1]=inputN;
}

void CallerCycle(){
	
	switch(Caller_state){
    8272:	82 30       	cpi	r24, 0x02	; 2
    8274:	09 f0       	breq	.+2      	; 0x8278 <CallerCycle+0x2e>
    8276:	08 95       	ret
					break;
				}
			}
			break;
		case CALLER_ARBITR:
			GSM_StartCalling(CurrentAbonent,CallerMessage[1]);
    8278:	90 91 38 07 	lds	r25, 0x0738
    827c:	80 91 b7 07 	lds	r24, 0x07B7
uint8_t numOfCheckBallanceRetry=0;

uint8_t Message[3];  // 
uint8_t GSMBusyState=0; // " " 0 -  , 1 -  
void GSM_StartCalling(uint8_t inputN,uint8_t abonentN){
	Message[0]=1;
    8280:	21 e0       	ldi	r18, 0x01	; 1
    8282:	20 93 35 07 	sts	0x0735, r18
	Message[1]=inputN;
    8286:	90 93 36 07 	sts	0x0736, r25
	Message[2]=abonentN;
    828a:	80 93 37 07 	sts	0x0737, r24
			if(CurrentCall<2){
    828e:	80 91 d9 07 	lds	r24, 0x07D9
    8292:	82 30       	cpi	r24, 0x02	; 2
    8294:	b0 f0       	brcs	.+44     	; 0x82c2 <CallerCycle+0x78>
				CurrentCall++;
				Caller_state = CHECK_PHONE_BUSY;
				break;
			}
			else{
			 if(CurrentAbonent<MaxTelephDirSz-1){
    8296:	92 30       	cpi	r25, 0x02	; 2
    8298:	d0 f0       	brcs	.+52     	; 0x82ce <CallerCycle+0x84>
				CurrentCall = 0;
				Caller_state = CHECK_PHONE_BUSY;
				break;
			 }
			 else{
			 	Caller_state = CALLER_IDLE;
    829a:	10 92 e4 02 	sts	0x02E4, r1
    829e:	08 95       	ret
				Caller_state = CHECK_PHONE_BUSY;
				break;
			}
			break;
		case CHECK_PHONE_BUSY:
			if(0==TransmitterState){
    82a0:	80 91 e3 02 	lds	r24, 0x02E3
    82a4:	88 23       	and	r24, r24
    82a6:	49 f0       	breq	.+18     	; 0x82ba <CallerCycle+0x70>
}
uint8_t ConfirmState = 0;
uint8_t RequestRepeatCounter = 0;
uint8_t TransmitterState = 0;
uint8_t GSM_GetConfirmState(){
	if(1 == ConfirmState){
    82a8:	80 91 e1 02 	lds	r24, 0x02E1
    82ac:	81 30       	cpi	r24, 0x01	; 1
    82ae:	19 f7       	brne	.-58     	; 0x8276 <CallerCycle+0x2c>
		ConfirmState = 0;
    82b0:	10 92 e1 02 	sts	0x02E1, r1
				Caller_state = CALLER_ARBITR;
				break;
			}else 
			{
				if(1 == GSM_GetConfirmState()){
					Caller_state = CALLER_IDLE;
    82b4:	10 92 e4 02 	sts	0x02E4, r1
    82b8:	08 95       	ret
				break;
			}
			break;
		case CHECK_PHONE_BUSY:
			if(0==TransmitterState){
				Caller_state = CALLER_ARBITR;
    82ba:	82 e0       	ldi	r24, 0x02	; 2
    82bc:	80 93 e4 02 	sts	0x02E4, r24
    82c0:	08 95       	ret
			}
			break;
		case CALLER_ARBITR:
			GSM_StartCalling(CurrentAbonent,CallerMessage[1]);
			if(CurrentCall<2){
				CurrentCall++;
    82c2:	8f 5f       	subi	r24, 0xFF	; 255
    82c4:	80 93 d9 07 	sts	0x07D9, r24
				Caller_state = CHECK_PHONE_BUSY;
    82c8:	20 93 e4 02 	sts	0x02E4, r18
    82cc:	08 95       	ret
				break;
			}
			else{
			 if(CurrentAbonent<MaxTelephDirSz-1){
			 	CurrentAbonent++;
    82ce:	9f 5f       	subi	r25, 0xFF	; 255
    82d0:	90 93 38 07 	sts	0x0738, r25
				CurrentCall = 0;
    82d4:	10 92 d9 07 	sts	0x07D9, r1
				Caller_state = CHECK_PHONE_BUSY;
    82d8:	20 93 e4 02 	sts	0x02E4, r18
    82dc:	08 95       	ret

000082de <ChannelProcessing>:
	}
}

void ChannelProcessing(uint8_t chNumber){

}
    82de:	08 95       	ret

000082e0 <ApplInit>:

void
ApplInit(void)
{
    82e0:	e6 eb       	ldi	r30, 0xB6	; 182
    82e2:	f6 e0       	ldi	r31, 0x06	; 6
    82e4:	81 e0       	ldi	r24, 0x01	; 1
	for(int i=0; i<16; i++){
		Channels[i].number = i+1;
    82e6:	80 83       	st	Z, r24
    82e8:	34 96       	adiw	r30, 0x04	; 4
    82ea:	8f 5f       	subi	r24, 0xFF	; 255
}

void
ApplInit(void)
{
	for(int i=0; i<16; i++){
    82ec:	81 31       	cpi	r24, 0x11	; 17
    82ee:	d9 f7       	brne	.-10     	; 0x82e6 <ApplInit+0x6>
		Channels[i].number = i+1;
	}

}
    82f0:	08 95       	ret

000082f2 <ApplCycle>:

// ~~~~~~~~~~~~
void
ApplCycle(void)
{
    82f2:	1f 93       	push	r17
    82f4:	cf 93       	push	r28
    82f6:	df 93       	push	r29
    82f8:	c7 eb       	ldi	r28, 0xB7	; 183
    82fa:	d6 e0       	ldi	r29, 0x06	; 6
    82fc:	1f ef       	ldi	r17, 0xFF	; 255
	for(uint8_t i=0; i<16; i++){
		Channels[i].DI_State = DI_State(i-1);
    82fe:	81 2f       	mov	r24, r17
    8300:	0e 94 a8 3e 	call	0x7d50	; 0x7d50 <DI_State>
    8304:	88 83       	st	Y, r24
    8306:	1f 5f       	subi	r17, 0xFF	; 255
    8308:	24 96       	adiw	r28, 0x04	; 4

// ~~~~~~~~~~~~
void
ApplCycle(void)
{
	for(uint8_t i=0; i<16; i++){
    830a:	1f 30       	cpi	r17, 0x0F	; 15
    830c:	c1 f7       	brne	.-16     	; 0x82fe <ApplCycle+0xc>
		Channels[i].DI_State = DI_State(i-1);
	}

	CallerCycle();
    830e:	0e 94 25 41 	call	0x824a	; 0x824a <CallerCycle>
}
    8312:	df 91       	pop	r29
    8314:	cf 91       	pop	r28
    8316:	1f 91       	pop	r17
    8318:	08 95       	ret

0000831a <StartKey>:
uint8_t CallerState;
uint8_t CallerMessage[2];
uint8_t CurrentAbonent;
uint8_t CurrentCall;
void Caller_StartCalling(uint8_t inputN){
	CallerMessage[0]=1;
    831a:	81 e0       	ldi	r24, 0x01	; 1
    831c:	80 93 b6 07 	sts	0x07B6, r24
	CallerMessage[1]=inputN;
    8320:	8b e0       	ldi	r24, 0x0B	; 11
    8322:	80 93 b7 07 	sts	0x07B7, r24
// ~~~~~~~~~~~
void
StartKey(void)
{	
	Caller_StartCalling(11);
}
    8326:	08 95       	ret

00008328 <StopKey>:
// ~~~~~~~~~~
void
StopKey(void)
{
	
}
    8328:	08 95       	ret

0000832a <Menu_ConfirmationRest_Enter>:
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	//		   
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	uint8_t Menu_ConfirmationRest_Enter(){

		eeprom_write_byte((uint8_t*)E2END, 0xBB);
    832a:	8f ef       	ldi	r24, 0xFF	; 255
    832c:	9f e0       	ldi	r25, 0x0F	; 15
    832e:	6b eb       	ldi	r22, 0xBB	; 187
    8330:	0e 94 35 84 	call	0x1086a	; 0x1086a <__eewr_byte_m2560>
		eeprom_write_byte(&MemCheck_stor.ReprogFlg, 0);
    8334:	8c e9       	ldi	r24, 0x9C	; 156
    8336:	91 e0       	ldi	r25, 0x01	; 1
    8338:	60 e0       	ldi	r22, 0x00	; 0
    833a:	0e 94 35 84 	call	0x1086a	; 0x1086a <__eewr_byte_m2560>
    833e:	ff cf       	rjmp	.-2      	; 0x833e <Menu_ConfirmationRest_Enter+0x14>

00008340 <Menu_ConfirmationSave_Enter>:
	//		   
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	uint8_t Menu_ConfirmationSave_Enter(){

		//  backup-
		eeprom_write_byte((uint8_t*)E2END, 0xAA);
    8340:	8f ef       	ldi	r24, 0xFF	; 255
    8342:	9f e0       	ldi	r25, 0x0F	; 15
    8344:	6a ea       	ldi	r22, 0xAA	; 170
    8346:	0e 94 35 84 	call	0x1086a	; 0x1086a <__eewr_byte_m2560>
		eeprom_write_byte(&DateBackUp.Day, Tm_MDay);
    834a:	80 e0       	ldi	r24, 0x00	; 0
    834c:	90 e0       	ldi	r25, 0x00	; 0
    834e:	60 91 5e 0b 	lds	r22, 0x0B5E
    8352:	0e 94 35 84 	call	0x1086a	; 0x1086a <__eewr_byte_m2560>
		eeprom_write_byte(&DateBackUp.Month, Tm_Mon);
    8356:	81 e0       	ldi	r24, 0x01	; 1
    8358:	90 e0       	ldi	r25, 0x00	; 0
    835a:	60 91 cb 07 	lds	r22, 0x07CB
    835e:	0e 94 35 84 	call	0x1086a	; 0x1086a <__eewr_byte_m2560>
		#ifdef M41T56
			eeprom_write_byte(&DateBackUp.Year, Tm_Year);
    8362:	82 e0       	ldi	r24, 0x02	; 2
    8364:	90 e0       	ldi	r25, 0x00	; 0
    8366:	60 91 de 05 	lds	r22, 0x05DE
    836a:	0e 94 35 84 	call	0x1086a	; 0x1086a <__eewr_byte_m2560>
		#else
			eeprom_write_byte(&DateBackUp.Year, erb(&Tm_Year));
		#endif
		eeprom_write_byte(&MemCheck_stor.ReprogFlg, 0);
    836e:	8c e9       	ldi	r24, 0x9C	; 156
    8370:	91 e0       	ldi	r25, 0x01	; 1
    8372:	60 e0       	ldi	r22, 0x00	; 0
    8374:	0e 94 35 84 	call	0x1086a	; 0x1086a <__eewr_byte_m2560>
    8378:	ff cf       	rjmp	.-2      	; 0x8378 <Menu_ConfirmationSave_Enter+0x38>

0000837a <GSM_SendData>:
	GSMTxSz = Size;
	memcpy(GSM_TxStr, Data_Out, GSMTxSz);
	GSM_SendFirstChar();
}
// ~~~~~~~~~
void GSM_SendData(uint8_t *Data_Out, uint8_t Size){
    837a:	58 2f       	mov	r21, r24
    837c:	79 2f       	mov	r23, r25
	GSMTxSz = Size;
    837e:	60 93 bb 07 	sts	0x07BB, r22
	memcpy(GSM_TxStr, Data_Out, GSMTxSz);
    8382:	40 91 bb 07 	lds	r20, 0x07BB
    8386:	29 e4       	ldi	r18, 0x49	; 73
    8388:	3a e0       	ldi	r19, 0x0A	; 10
    838a:	c9 01       	movw	r24, r18
    838c:	65 2f       	mov	r22, r21
    838e:	50 e0       	ldi	r21, 0x00	; 0
    8390:	0e 94 39 81 	call	0x10272	; 0x10272 <memcpy>
	GSM_SendFirstChar();
    8394:	0e 94 bc 3a 	call	0x7578	; 0x7578 <GSM_SendFirstChar>
}
    8398:	08 95       	ret

0000839a <GSM_AddHeaderSendData>:
	GSMTxSz++;
	GSM_SendFirstChar();
}
// ~~~~~~~~~
//   + CntrZ
void GSM_AddHeaderSendData(uint8_t *Data_Out, uint8_t Size){
    839a:	58 2f       	mov	r21, r24
    839c:	79 2f       	mov	r23, r25
	GSMTxSz = Size;
    839e:	60 93 bb 07 	sts	0x07BB, r22
	memcpy(GSM_TxStr, Data_Out, GSMTxSz);
    83a2:	40 91 bb 07 	lds	r20, 0x07BB
    83a6:	29 e4       	ldi	r18, 0x49	; 73
    83a8:	3a e0       	ldi	r19, 0x0A	; 10
    83aa:	c9 01       	movw	r24, r18
    83ac:	65 2f       	mov	r22, r21
    83ae:	50 e0       	ldi	r21, 0x00	; 0
    83b0:	0e 94 39 81 	call	0x10272	; 0x10272 <memcpy>
	GSM_SendFirstChar();
    83b4:	0e 94 bc 3a 	call	0x7578	; 0x7578 <GSM_SendFirstChar>
}
    83b8:	08 95       	ret

000083ba <PresicionHanler>:
		ew##ty3((ty2*)Var, Min);						\
	else																	\
		ew##ty3((ty2*)Var, (ty2)Buf)
// ~~~~~~~~~~~~~~~~~~~~~~~
//Change BufStr due to precision for correct sscanf reading BufStr
void PresicionHanler(OutField *Field){
    83ba:	cf 93       	push	r28
    83bc:	df 93       	push	r29

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    83be:	ec 01       	movw	r28, r24
    83c0:	2f 96       	adiw	r28, 0x0f	; 15
    83c2:	fe 01       	movw	r30, r28
    83c4:	84 91       	lpm	r24, Z+
	if(prb(&Field->Prec)){
    83c6:	88 23       	and	r24, r24
    83c8:	19 f4       	brne	.+6      	; 0x83d0 <PresicionHanler+0x16>
			}
			p++;
		}
	}
	
}
    83ca:	df 91       	pop	r29
    83cc:	cf 91       	pop	r28
    83ce:	08 95       	ret
		ew##ty3((ty2*)Var, (ty2)Buf)
// ~~~~~~~~~~~~~~~~~~~~~~~
//Change BufStr due to precision for correct sscanf reading BufStr
void PresicionHanler(OutField *Field){
	if(prb(&Field->Prec)){
		char *p = strchr(BufStr,'.');	//seek for first decimal point
    83d0:	83 ec       	ldi	r24, 0xC3	; 195
    83d2:	95 e0       	ldi	r25, 0x05	; 5
    83d4:	6e e2       	ldi	r22, 0x2E	; 46
    83d6:	70 e0       	ldi	r23, 0x00	; 0
    83d8:	0e 94 42 81 	call	0x10284	; 0x10284 <strchr>
		if(p==NULL){
    83dc:	00 97       	sbiw	r24, 0x00	; 0
    83de:	01 f1       	breq	.+64     	; 0x8420 <PresicionHanler+0x66>
    83e0:	fe 01       	movw	r30, r28
    83e2:	24 91       	lpm	r18, Z+
			p = strchr(BufStr,' ');	//else seek for first space
		}
	  	for(uint8_t i=0; i<prb(&Field->Prec); i++){
    83e4:	22 23       	and	r18, r18
    83e6:	89 f3       	breq	.-30     	; 0x83ca <PresicionHanler+0x10>
    83e8:	fc 01       	movw	r30, r24
    83ea:	dc 01       	movw	r26, r24
    83ec:	11 96       	adiw	r26, 0x01	; 1
    83ee:	30 e0       	ldi	r19, 0x00	; 0
			if(*p == '.'){
				if(isdigit(*(p+1))){
					*p= *(p+1);
					*(p+1) = '.';
				}
				else *p='0'; 
    83f0:	60 e3       	ldi	r22, 0x30	; 48
    83f2:	52 2f       	mov	r21, r18
    83f4:	07 c0       	rjmp	.+14     	; 0x8404 <PresicionHanler+0x4a>
		if(p==NULL){
			p = strchr(BufStr,' ');	//else seek for first space
		}
	  	for(uint8_t i=0; i<prb(&Field->Prec); i++){
			if(*p == ' ') *p='0'; 
			if(*p == '.'){
    83f6:	2e 32       	cpi	r18, 0x2E	; 46
    83f8:	51 f0       	breq	.+20     	; 0x840e <PresicionHanler+0x54>
	if(prb(&Field->Prec)){
		char *p = strchr(BufStr,'.');	//seek for first decimal point
		if(p==NULL){
			p = strchr(BufStr,' ');	//else seek for first space
		}
	  	for(uint8_t i=0; i<prb(&Field->Prec); i++){
    83fa:	3f 5f       	subi	r19, 0xFF	; 255
    83fc:	31 96       	adiw	r30, 0x01	; 1
    83fe:	11 96       	adiw	r26, 0x01	; 1
    8400:	35 17       	cp	r19, r21
    8402:	18 f7       	brcc	.-58     	; 0x83ca <PresicionHanler+0x10>
			if(*p == ' ') *p='0'; 
    8404:	20 81       	ld	r18, Z
    8406:	20 32       	cpi	r18, 0x20	; 32
    8408:	b1 f7       	brne	.-20     	; 0x83f6 <PresicionHanler+0x3c>
			if(*p == '.'){
				if(isdigit(*(p+1))){
					*p= *(p+1);
					*(p+1) = '.';
				}
				else *p='0'; 
    840a:	60 83       	st	Z, r22
    840c:	f6 cf       	rjmp	.-20     	; 0x83fa <PresicionHanler+0x40>
			p = strchr(BufStr,' ');	//else seek for first space
		}
	  	for(uint8_t i=0; i<prb(&Field->Prec); i++){
			if(*p == ' ') *p='0'; 
			if(*p == '.'){
				if(isdigit(*(p+1))){
    840e:	4c 91       	ld	r20, X
    8410:	84 2f       	mov	r24, r20
    8412:	90 e0       	ldi	r25, 0x00	; 0
    8414:	c0 97       	sbiw	r24, 0x30	; 48
    8416:	0a 97       	sbiw	r24, 0x0a	; 10
    8418:	c0 f7       	brcc	.-16     	; 0x840a <PresicionHanler+0x50>
					*p= *(p+1);
    841a:	40 83       	st	Z, r20
					*(p+1) = '.';
    841c:	2c 93       	st	X, r18
    841e:	ed cf       	rjmp	.-38     	; 0x83fa <PresicionHanler+0x40>
//Change BufStr due to precision for correct sscanf reading BufStr
void PresicionHanler(OutField *Field){
	if(prb(&Field->Prec)){
		char *p = strchr(BufStr,'.');	//seek for first decimal point
		if(p==NULL){
			p = strchr(BufStr,' ');	//else seek for first space
    8420:	83 ec       	ldi	r24, 0xC3	; 195
    8422:	95 e0       	ldi	r25, 0x05	; 5
    8424:	60 e2       	ldi	r22, 0x20	; 32
    8426:	70 e0       	ldi	r23, 0x00	; 0
    8428:	0e 94 42 81 	call	0x10284	; 0x10284 <strchr>
    842c:	d9 cf       	rjmp	.-78     	; 0x83e0 <PresicionHanler+0x26>

0000842e <GetMultiSymbol>:
	}
	return 0;
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~
//    MultiSymbol   
uint8_t GetMultiSymbol(PGM_P Str_P, char Char){
    842e:	1f 93       	push	r17
    8430:	18 2f       	mov	r17, r24
	PGM_P ptr_P= strchr_P(Str_P, Char);
    8432:	70 e0       	ldi	r23, 0x00	; 0
    8434:	0e 94 e2 80 	call	0x101c4	; 0x101c4 <strchr_P>
	if(ptr_P) return (uint8_t)(ptr_P - Str_P);
    8438:	00 97       	sbiw	r24, 0x00	; 0
    843a:	19 f0       	breq	.+6      	; 0x8442 <GetMultiSymbol+0x14>
    843c:	81 1b       	sub	r24, r17
	else return 0;
}
    843e:	1f 91       	pop	r17
    8440:	08 95       	ret
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~
//    MultiSymbol   
uint8_t GetMultiSymbol(PGM_P Str_P, char Char){
	PGM_P ptr_P= strchr_P(Str_P, Char);
	if(ptr_P) return (uint8_t)(ptr_P - Str_P);
    8442:	80 e0       	ldi	r24, 0x00	; 0
	else return 0;
}
    8444:	1f 91       	pop	r17
    8446:	08 95       	ret

00008448 <PutEnum>:
} T_Param;

// ~~~~~~~~~~~~~~~~~~~~
void
PutEnum(T_Param *Param)
{
    8448:	0f 93       	push	r16
    844a:	1f 93       	push	r17
    844c:	cf 93       	push	r28
    844e:	df 93       	push	r29
    8450:	8c 01       	movw	r16, r24

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    8452:	dc 01       	movw	r26, r24
    8454:	14 96       	adiw	r26, 0x04	; 4
    8456:	ed 91       	ld	r30, X+
    8458:	fc 91       	ld	r31, X
    845a:	15 97       	sbiw	r26, 0x05	; 5
    845c:	65 91       	lpm	r22, Z+
    845e:	74 91       	lpm	r23, Z+
	strcpy_P(Param->Pos, prp(Param->Txt));
    8460:	8d 91       	ld	r24, X+
    8462:	9c 91       	ld	r25, X
    8464:	0e 94 f6 80 	call	0x101ec	; 0x101ec <strcpy_P>
	for(uint8_t i=strlen(Param->Pos); i<Param->Size; *(Param->Pos+i++)=' ');
    8468:	f8 01       	movw	r30, r16
    846a:	c0 81       	ld	r28, Z
    846c:	d1 81       	ldd	r29, Z+1	; 0x01
    846e:	fe 01       	movw	r30, r28
    8470:	01 90       	ld	r0, Z+
    8472:	00 20       	and	r0, r0
    8474:	e9 f7       	brne	.-6      	; 0x8470 <PutEnum+0x28>
    8476:	31 97       	sbiw	r30, 0x01	; 1
    8478:	ec 1b       	sub	r30, r28
    847a:	d8 01       	movw	r26, r16
    847c:	13 96       	adiw	r26, 0x03	; 3
    847e:	8c 91       	ld	r24, X
    8480:	e8 17       	cp	r30, r24
    8482:	70 f4       	brcc	.+28     	; 0x84a0 <PutEnum+0x58>
    8484:	90 e2       	ldi	r25, 0x20	; 32
    8486:	02 c0       	rjmp	.+4      	; 0x848c <PutEnum+0x44>
    8488:	cd 91       	ld	r28, X+
    848a:	dc 91       	ld	r29, X
    848c:	ce 0f       	add	r28, r30
    848e:	d1 1d       	adc	r29, r1
    8490:	98 83       	st	Y, r25
    8492:	ef 5f       	subi	r30, 0xFF	; 255
    8494:	d8 01       	movw	r26, r16
    8496:	13 96       	adiw	r26, 0x03	; 3
    8498:	8c 91       	ld	r24, X
    849a:	13 97       	sbiw	r26, 0x03	; 3
    849c:	e8 17       	cp	r30, r24
    849e:	a0 f3       	brcs	.-24     	; 0x8488 <PutEnum+0x40>
}
    84a0:	df 91       	pop	r29
    84a2:	cf 91       	pop	r28
    84a4:	1f 91       	pop	r17
    84a6:	0f 91       	pop	r16
    84a8:	08 95       	ret

000084aa <Put_sbVal>:
}

// ~~~~~~~~~~~~~~~~~~~~~~
void
Put_sbVal(T_Param *Param)
{
    84aa:	6f 92       	push	r6
    84ac:	7f 92       	push	r7
    84ae:	8f 92       	push	r8
    84b0:	9f 92       	push	r9
    84b2:	af 92       	push	r10
    84b4:	bf 92       	push	r11
    84b6:	cf 92       	push	r12
    84b8:	df 92       	push	r13
    84ba:	ef 92       	push	r14
    84bc:	ff 92       	push	r15
    84be:	0f 93       	push	r16
    84c0:	1f 93       	push	r17
    84c2:	df 93       	push	r29
    84c4:	cf 93       	push	r28
    84c6:	cd b7       	in	r28, 0x3d	; 61
    84c8:	de b7       	in	r29, 0x3e	; 62
    84ca:	2c 97       	sbiw	r28, 0x0c	; 12
    84cc:	0f b6       	in	r0, 0x3f	; 63
    84ce:	f8 94       	cli
    84d0:	de bf       	out	0x3e, r29	; 62
    84d2:	0f be       	out	0x3f, r0	; 63
    84d4:	cd bf       	out	0x3d, r28	; 61
    84d6:	5c 01       	movw	r10, r24
	char Format[] = "%0+ li.%. u";
    84d8:	be 01       	movw	r22, r28
    84da:	6f 5f       	subi	r22, 0xFF	; 255
    84dc:	7f 4f       	sbci	r23, 0xFF	; 255
    84de:	db 01       	movw	r26, r22
    84e0:	e0 e0       	ldi	r30, 0x00	; 0
    84e2:	f2 e0       	ldi	r31, 0x02	; 2
    84e4:	8c e0       	ldi	r24, 0x0C	; 12
    84e6:	01 90       	ld	r0, Z+
    84e8:	0d 92       	st	X+, r0
    84ea:	81 50       	subi	r24, 0x01	; 1
    84ec:	e1 f7       	brne	.-8      	; 0x84e6 <Put_sbVal+0x3c>
	Format[3] = '0'+Param->Size;
    84ee:	d5 01       	movw	r26, r10
    84f0:	13 96       	adiw	r26, 0x03	; 3
    84f2:	2c 91       	ld	r18, X
    84f4:	13 97       	sbiw	r26, 0x03	; 3
    84f6:	20 5d       	subi	r18, 0xD0	; 208
    84f8:	2c 83       	std	Y+4, r18	; 0x04
	if(Param->Prec) {
    84fa:	12 96       	adiw	r26, 0x02	; 2
    84fc:	9c 91       	ld	r25, X
    84fe:	99 23       	and	r25, r25
    8500:	09 f4       	brne	.+2      	; 0x8504 <Put_sbVal+0x5a>
    8502:	8d c0       	rjmp	.+282    	; 0x861e <Put_sbVal+0x174>
		Format[3] -= Param->Prec+1;
    8504:	89 2f       	mov	r24, r25
    8506:	80 95       	com	r24
    8508:	82 0f       	add	r24, r18
    850a:	8c 83       	std	Y+4, r24	; 0x04
		Format[9] = '0'+Param->Prec;
    850c:	90 5d       	subi	r25, 0xD0	; 208
    850e:	9a 87       	std	Y+10, r25	; 0x0a
    8510:	90 53       	subi	r25, 0x30	; 48
		int16_t Div=Pow10(Param->Prec);
    8512:	49 2f       	mov	r20, r25
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    8514:	21 e0       	ldi	r18, 0x01	; 1
    8516:	30 e0       	ldi	r19, 0x00	; 0
		Pow *= 10;
    8518:	c9 01       	movw	r24, r18
    851a:	88 0f       	add	r24, r24
    851c:	99 1f       	adc	r25, r25
    851e:	22 0f       	add	r18, r18
    8520:	33 1f       	adc	r19, r19
    8522:	22 0f       	add	r18, r18
    8524:	33 1f       	adc	r19, r19
    8526:	22 0f       	add	r18, r18
    8528:	33 1f       	adc	r19, r19
    852a:	28 0f       	add	r18, r24
    852c:	39 1f       	adc	r19, r25
    852e:	41 50       	subi	r20, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    8530:	99 f7       	brne	.-26     	; 0x8518 <Put_sbVal+0x6e>
    8532:	39 01       	movw	r6, r18
    8534:	88 24       	eor	r8, r8
    8536:	77 fc       	sbrc	r7, 7
    8538:	80 94       	com	r8
    853a:	98 2c       	mov	r9, r8
		sprintf(Param->Pos, Format, sF_Buf/Div, (uint32_t)labs(sF_Buf)%Div);
    853c:	10 91 fb 04 	lds	r17, 0x04FB
    8540:	00 91 fc 04 	lds	r16, 0x04FC
    8544:	f0 90 fd 04 	lds	r15, 0x04FD
    8548:	e0 90 fe 04 	lds	r14, 0x04FE
    854c:	ed b7       	in	r30, 0x3d	; 61
    854e:	fe b7       	in	r31, 0x3e	; 62
    8550:	3c 97       	sbiw	r30, 0x0c	; 12
    8552:	0f b6       	in	r0, 0x3f	; 63
    8554:	f8 94       	cli
    8556:	fe bf       	out	0x3e, r31	; 62
    8558:	0f be       	out	0x3f, r0	; 63
    855a:	ed bf       	out	0x3d, r30	; 61
    855c:	cd b6       	in	r12, 0x3d	; 61
    855e:	de b6       	in	r13, 0x3e	; 62
    8560:	08 94       	sec
    8562:	c1 1c       	adc	r12, r1
    8564:	d1 1c       	adc	r13, r1
    8566:	d5 01       	movw	r26, r10
    8568:	8d 91       	ld	r24, X+
    856a:	9c 91       	ld	r25, X
    856c:	92 83       	std	Z+2, r25	; 0x02
    856e:	81 83       	std	Z+1, r24	; 0x01
    8570:	f6 01       	movw	r30, r12
    8572:	73 83       	std	Z+3, r23	; 0x03
    8574:	62 83       	std	Z+2, r22	; 0x02
    8576:	61 2f       	mov	r22, r17
    8578:	70 2f       	mov	r23, r16
    857a:	8f 2d       	mov	r24, r15
    857c:	9e 2d       	mov	r25, r14
    857e:	a4 01       	movw	r20, r8
    8580:	93 01       	movw	r18, r6
    8582:	0e 94 c7 84 	call	0x1098e	; 0x1098e <__divmodsi4>
    8586:	d6 01       	movw	r26, r12
    8588:	14 96       	adiw	r26, 0x04	; 4
    858a:	2d 93       	st	X+, r18
    858c:	3d 93       	st	X+, r19
    858e:	4d 93       	st	X+, r20
    8590:	5c 93       	st	X, r21
    8592:	17 97       	sbiw	r26, 0x07	; 7
    8594:	21 2f       	mov	r18, r17
    8596:	30 2f       	mov	r19, r16
    8598:	4f 2d       	mov	r20, r15
    859a:	5e 2d       	mov	r21, r14
    859c:	c9 01       	movw	r24, r18
    859e:	da 01       	movw	r26, r20
    85a0:	bc 01       	movw	r22, r24
    85a2:	cd 01       	movw	r24, r26
    85a4:	97 fd       	sbrc	r25, 7
    85a6:	77 c0       	rjmp	.+238    	; 0x8696 <Put_sbVal+0x1ec>
    85a8:	a4 01       	movw	r20, r8
    85aa:	93 01       	movw	r18, r6
    85ac:	0e 94 a5 84 	call	0x1094a	; 0x1094a <__udivmodsi4>
    85b0:	f6 01       	movw	r30, r12
    85b2:	60 87       	std	Z+8, r22	; 0x08
    85b4:	71 87       	std	Z+9, r23	; 0x09
    85b6:	82 87       	std	Z+10, r24	; 0x0a
    85b8:	93 87       	std	Z+11, r25	; 0x0b
    85ba:	0e 94 e9 81 	call	0x103d2	; 0x103d2 <sprintf>
		if(sF_Buf<0) {
    85be:	8d b7       	in	r24, 0x3d	; 61
    85c0:	9e b7       	in	r25, 0x3e	; 62
    85c2:	0c 96       	adiw	r24, 0x0c	; 12
    85c4:	0f b6       	in	r0, 0x3f	; 63
    85c6:	f8 94       	cli
    85c8:	9e bf       	out	0x3e, r25	; 62
    85ca:	0f be       	out	0x3f, r0	; 63
    85cc:	8d bf       	out	0x3d, r24	; 61
    85ce:	80 91 fb 04 	lds	r24, 0x04FB
    85d2:	90 91 fc 04 	lds	r25, 0x04FC
    85d6:	a0 91 fd 04 	lds	r26, 0x04FD
    85da:	b0 91 fe 04 	lds	r27, 0x04FE
    85de:	b7 fd       	sbrc	r27, 7
    85e0:	4a c0       	rjmp	.+148    	; 0x8676 <Put_sbVal+0x1cc>
	}
	else {
		Format[6] = '\0';
		sprintf(Param->Pos, Format, sF_Buf);
	}
	if(Minus)
    85e2:	80 91 ff 04 	lds	r24, 0x04FF
    85e6:	88 23       	and	r24, r24
    85e8:	29 f0       	breq	.+10     	; 0x85f4 <Put_sbVal+0x14a>
		*Param->Pos = '-';
    85ea:	d5 01       	movw	r26, r10
    85ec:	ed 91       	ld	r30, X+
    85ee:	fc 91       	ld	r31, X
    85f0:	8d e2       	ldi	r24, 0x2D	; 45
    85f2:	80 83       	st	Z, r24
}
    85f4:	2c 96       	adiw	r28, 0x0c	; 12
    85f6:	0f b6       	in	r0, 0x3f	; 63
    85f8:	f8 94       	cli
    85fa:	de bf       	out	0x3e, r29	; 62
    85fc:	0f be       	out	0x3f, r0	; 63
    85fe:	cd bf       	out	0x3d, r28	; 61
    8600:	cf 91       	pop	r28
    8602:	df 91       	pop	r29
    8604:	1f 91       	pop	r17
    8606:	0f 91       	pop	r16
    8608:	ff 90       	pop	r15
    860a:	ef 90       	pop	r14
    860c:	df 90       	pop	r13
    860e:	cf 90       	pop	r12
    8610:	bf 90       	pop	r11
    8612:	af 90       	pop	r10
    8614:	9f 90       	pop	r9
    8616:	8f 90       	pop	r8
    8618:	7f 90       	pop	r7
    861a:	6f 90       	pop	r6
    861c:	08 95       	ret
				Param->Pos++;
			*Param->Pos = '-';
		}
	}
	else {
		Format[6] = '\0';
    861e:	1f 82       	std	Y+7, r1	; 0x07
		sprintf(Param->Pos, Format, sF_Buf);
    8620:	ed b7       	in	r30, 0x3d	; 61
    8622:	fe b7       	in	r31, 0x3e	; 62
    8624:	38 97       	sbiw	r30, 0x08	; 8
    8626:	0f b6       	in	r0, 0x3f	; 63
    8628:	f8 94       	cli
    862a:	fe bf       	out	0x3e, r31	; 62
    862c:	0f be       	out	0x3f, r0	; 63
    862e:	ed bf       	out	0x3d, r30	; 61
    8630:	31 96       	adiw	r30, 0x01	; 1
    8632:	d5 01       	movw	r26, r10
    8634:	8d 91       	ld	r24, X+
    8636:	9c 91       	ld	r25, X
    8638:	ad b7       	in	r26, 0x3d	; 61
    863a:	be b7       	in	r27, 0x3e	; 62
    863c:	12 96       	adiw	r26, 0x02	; 2
    863e:	9c 93       	st	X, r25
    8640:	8e 93       	st	-X, r24
    8642:	11 97       	sbiw	r26, 0x01	; 1
    8644:	73 83       	std	Z+3, r23	; 0x03
    8646:	62 83       	std	Z+2, r22	; 0x02
    8648:	80 91 fb 04 	lds	r24, 0x04FB
    864c:	90 91 fc 04 	lds	r25, 0x04FC
    8650:	a0 91 fd 04 	lds	r26, 0x04FD
    8654:	b0 91 fe 04 	lds	r27, 0x04FE
    8658:	84 83       	std	Z+4, r24	; 0x04
    865a:	95 83       	std	Z+5, r25	; 0x05
    865c:	a6 83       	std	Z+6, r26	; 0x06
    865e:	b7 83       	std	Z+7, r27	; 0x07
    8660:	0e 94 e9 81 	call	0x103d2	; 0x103d2 <sprintf>
    8664:	ed b7       	in	r30, 0x3d	; 61
    8666:	fe b7       	in	r31, 0x3e	; 62
    8668:	38 96       	adiw	r30, 0x08	; 8
    866a:	0f b6       	in	r0, 0x3f	; 63
    866c:	f8 94       	cli
    866e:	fe bf       	out	0x3e, r31	; 62
    8670:	0f be       	out	0x3f, r0	; 63
    8672:	ed bf       	out	0x3d, r30	; 61
    8674:	b6 cf       	rjmp	.-148    	; 0x85e2 <Put_sbVal+0x138>
		Format[3] -= Param->Prec+1;
		Format[9] = '0'+Param->Prec;
		int16_t Div=Pow10(Param->Prec);
		sprintf(Param->Pos, Format, sF_Buf/Div, (uint32_t)labs(sF_Buf)%Div);
		if(sF_Buf<0) {
			while(*Param->Pos==' ')
    8676:	d5 01       	movw	r26, r10
    8678:	ed 91       	ld	r30, X+
    867a:	fc 91       	ld	r31, X
    867c:	80 81       	ld	r24, Z
    867e:	80 32       	cpi	r24, 0x20	; 32
    8680:	39 f4       	brne	.+14     	; 0x8690 <Put_sbVal+0x1e6>
				Param->Pos++;
    8682:	31 96       	adiw	r30, 0x01	; 1
    8684:	d5 01       	movw	r26, r10
    8686:	ed 93       	st	X+, r30
    8688:	fc 93       	st	X, r31
		Format[3] -= Param->Prec+1;
		Format[9] = '0'+Param->Prec;
		int16_t Div=Pow10(Param->Prec);
		sprintf(Param->Pos, Format, sF_Buf/Div, (uint32_t)labs(sF_Buf)%Div);
		if(sF_Buf<0) {
			while(*Param->Pos==' ')
    868a:	80 81       	ld	r24, Z
    868c:	80 32       	cpi	r24, 0x20	; 32
    868e:	c9 f3       	breq	.-14     	; 0x8682 <Put_sbVal+0x1d8>
				Param->Pos++;
			*Param->Pos = '-';
    8690:	8d e2       	ldi	r24, 0x2D	; 45
    8692:	80 83       	st	Z, r24
    8694:	a6 cf       	rjmp	.-180    	; 0x85e2 <Put_sbVal+0x138>
	Format[3] = '0'+Param->Size;
	if(Param->Prec) {
		Format[3] -= Param->Prec+1;
		Format[9] = '0'+Param->Prec;
		int16_t Div=Pow10(Param->Prec);
		sprintf(Param->Pos, Format, sF_Buf/Div, (uint32_t)labs(sF_Buf)%Div);
    8696:	90 95       	com	r25
    8698:	80 95       	com	r24
    869a:	70 95       	com	r23
    869c:	61 95       	neg	r22
    869e:	7f 4f       	sbci	r23, 0xFF	; 255
    86a0:	8f 4f       	sbci	r24, 0xFF	; 255
    86a2:	9f 4f       	sbci	r25, 0xFF	; 255
    86a4:	81 cf       	rjmp	.-254    	; 0x85a8 <Put_sbVal+0xfe>

000086a6 <Put_bVal>:
}

// ~~~~~~~~~~~~~~~~~~~~~
void
Put_bVal(T_Param *Param)
{
    86a6:	6f 92       	push	r6
    86a8:	7f 92       	push	r7
    86aa:	8f 92       	push	r8
    86ac:	9f 92       	push	r9
    86ae:	af 92       	push	r10
    86b0:	bf 92       	push	r11
    86b2:	cf 92       	push	r12
    86b4:	df 92       	push	r13
    86b6:	ef 92       	push	r14
    86b8:	ff 92       	push	r15
    86ba:	0f 93       	push	r16
    86bc:	1f 93       	push	r17
    86be:	df 93       	push	r29
    86c0:	cf 93       	push	r28
    86c2:	cd b7       	in	r28, 0x3d	; 61
    86c4:	de b7       	in	r29, 0x3e	; 62
    86c6:	2b 97       	sbiw	r28, 0x0b	; 11
    86c8:	0f b6       	in	r0, 0x3f	; 63
    86ca:	f8 94       	cli
    86cc:	de bf       	out	0x3e, r29	; 62
    86ce:	0f be       	out	0x3f, r0	; 63
    86d0:	cd bf       	out	0x3d, r28	; 61
    86d2:	bc 01       	movw	r22, r24
	char Format[] = "%0 li.%. u";
    86d4:	3e 01       	movw	r6, r28
    86d6:	08 94       	sec
    86d8:	61 1c       	adc	r6, r1
    86da:	71 1c       	adc	r7, r1
    86dc:	d3 01       	movw	r26, r6
    86de:	ec e0       	ldi	r30, 0x0C	; 12
    86e0:	f2 e0       	ldi	r31, 0x02	; 2
    86e2:	8b e0       	ldi	r24, 0x0B	; 11
    86e4:	01 90       	ld	r0, Z+
    86e6:	0d 92       	st	X+, r0
    86e8:	81 50       	subi	r24, 0x01	; 1
    86ea:	e1 f7       	brne	.-8      	; 0x86e4 <Put_bVal+0x3e>
	Format[2] = '0'+Param->Size;
    86ec:	db 01       	movw	r26, r22
    86ee:	13 96       	adiw	r26, 0x03	; 3
    86f0:	2c 91       	ld	r18, X
    86f2:	13 97       	sbiw	r26, 0x03	; 3
    86f4:	20 5d       	subi	r18, 0xD0	; 208
    86f6:	2b 83       	std	Y+3, r18	; 0x03
	if(Param->Prec) {
    86f8:	12 96       	adiw	r26, 0x02	; 2
    86fa:	9c 91       	ld	r25, X
    86fc:	99 23       	and	r25, r25
    86fe:	09 f4       	brne	.+2      	; 0x8702 <Put_bVal+0x5c>
    8700:	6d c0       	rjmp	.+218    	; 0x87dc <Put_bVal+0x136>
		Format[2] -= Param->Prec+1;
    8702:	89 2f       	mov	r24, r25
    8704:	80 95       	com	r24
    8706:	82 0f       	add	r24, r18
    8708:	8b 83       	std	Y+3, r24	; 0x03
		Format[8] = '0'+Param->Prec;
    870a:	90 5d       	subi	r25, 0xD0	; 208
    870c:	99 87       	std	Y+9, r25	; 0x09
    870e:	90 53       	subi	r25, 0x30	; 48
		uint16_t Div=Pow10(Param->Prec);
    8710:	49 2f       	mov	r20, r25
    8712:	21 e0       	ldi	r18, 0x01	; 1
    8714:	30 e0       	ldi	r19, 0x00	; 0
		Pow *= 10;
    8716:	c9 01       	movw	r24, r18
    8718:	88 0f       	add	r24, r24
    871a:	99 1f       	adc	r25, r25
    871c:	22 0f       	add	r18, r18
    871e:	33 1f       	adc	r19, r19
    8720:	22 0f       	add	r18, r18
    8722:	33 1f       	adc	r19, r19
    8724:	22 0f       	add	r18, r18
    8726:	33 1f       	adc	r19, r19
    8728:	28 0f       	add	r18, r24
    872a:	39 1f       	adc	r19, r25
    872c:	41 50       	subi	r20, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    872e:	99 f7       	brne	.-26     	; 0x8716 <Put_bVal+0x70>
    8730:	49 01       	movw	r8, r18
    8732:	aa 24       	eor	r10, r10
    8734:	bb 24       	eor	r11, r11
		sprintf(Param->Pos, Format, F_Buf/Div, F_Buf%Div);
    8736:	c0 90 f7 04 	lds	r12, 0x04F7
    873a:	d0 90 f8 04 	lds	r13, 0x04F8
    873e:	e0 90 f9 04 	lds	r14, 0x04F9
    8742:	f0 90 fa 04 	lds	r15, 0x04FA
    8746:	ed b7       	in	r30, 0x3d	; 61
    8748:	fe b7       	in	r31, 0x3e	; 62
    874a:	3c 97       	sbiw	r30, 0x0c	; 12
    874c:	0f b6       	in	r0, 0x3f	; 63
    874e:	f8 94       	cli
    8750:	fe bf       	out	0x3e, r31	; 62
    8752:	0f be       	out	0x3f, r0	; 63
    8754:	ed bf       	out	0x3d, r30	; 61
    8756:	0d b7       	in	r16, 0x3d	; 61
    8758:	1e b7       	in	r17, 0x3e	; 62
    875a:	0f 5f       	subi	r16, 0xFF	; 255
    875c:	1f 4f       	sbci	r17, 0xFF	; 255
    875e:	db 01       	movw	r26, r22
    8760:	8d 91       	ld	r24, X+
    8762:	9c 91       	ld	r25, X
    8764:	92 83       	std	Z+2, r25	; 0x02
    8766:	81 83       	std	Z+1, r24	; 0x01
    8768:	f8 01       	movw	r30, r16
    876a:	73 82       	std	Z+3, r7	; 0x03
    876c:	62 82       	std	Z+2, r6	; 0x02
    876e:	c7 01       	movw	r24, r14
    8770:	b6 01       	movw	r22, r12
    8772:	a5 01       	movw	r20, r10
    8774:	94 01       	movw	r18, r8
    8776:	0e 94 a5 84 	call	0x1094a	; 0x1094a <__udivmodsi4>
    877a:	d8 01       	movw	r26, r16
    877c:	14 96       	adiw	r26, 0x04	; 4
    877e:	2d 93       	st	X+, r18
    8780:	3d 93       	st	X+, r19
    8782:	4d 93       	st	X+, r20
    8784:	5c 93       	st	X, r21
    8786:	17 97       	sbiw	r26, 0x07	; 7
    8788:	c7 01       	movw	r24, r14
    878a:	b6 01       	movw	r22, r12
    878c:	a5 01       	movw	r20, r10
    878e:	94 01       	movw	r18, r8
    8790:	0e 94 a5 84 	call	0x1094a	; 0x1094a <__udivmodsi4>
    8794:	f8 01       	movw	r30, r16
    8796:	60 87       	std	Z+8, r22	; 0x08
    8798:	71 87       	std	Z+9, r23	; 0x09
    879a:	82 87       	std	Z+10, r24	; 0x0a
    879c:	93 87       	std	Z+11, r25	; 0x0b
    879e:	0e 94 e9 81 	call	0x103d2	; 0x103d2 <sprintf>
    87a2:	8d b7       	in	r24, 0x3d	; 61
    87a4:	9e b7       	in	r25, 0x3e	; 62
    87a6:	0c 96       	adiw	r24, 0x0c	; 12
    87a8:	0f b6       	in	r0, 0x3f	; 63
    87aa:	f8 94       	cli
    87ac:	9e bf       	out	0x3e, r25	; 62
    87ae:	0f be       	out	0x3f, r0	; 63
    87b0:	8d bf       	out	0x3d, r24	; 61
	}
	else{
		Format[5] = '\0';
		sprintf(Param->Pos, Format, F_Buf);
	}
}
    87b2:	2b 96       	adiw	r28, 0x0b	; 11
    87b4:	0f b6       	in	r0, 0x3f	; 63
    87b6:	f8 94       	cli
    87b8:	de bf       	out	0x3e, r29	; 62
    87ba:	0f be       	out	0x3f, r0	; 63
    87bc:	cd bf       	out	0x3d, r28	; 61
    87be:	cf 91       	pop	r28
    87c0:	df 91       	pop	r29
    87c2:	1f 91       	pop	r17
    87c4:	0f 91       	pop	r16
    87c6:	ff 90       	pop	r15
    87c8:	ef 90       	pop	r14
    87ca:	df 90       	pop	r13
    87cc:	cf 90       	pop	r12
    87ce:	bf 90       	pop	r11
    87d0:	af 90       	pop	r10
    87d2:	9f 90       	pop	r9
    87d4:	8f 90       	pop	r8
    87d6:	7f 90       	pop	r7
    87d8:	6f 90       	pop	r6
    87da:	08 95       	ret
		Format[8] = '0'+Param->Prec;
		uint16_t Div=Pow10(Param->Prec);
		sprintf(Param->Pos, Format, F_Buf/Div, F_Buf%Div);
	}
	else{
		Format[5] = '\0';
    87dc:	1e 82       	std	Y+6, r1	; 0x06
		sprintf(Param->Pos, Format, F_Buf);
    87de:	ad b7       	in	r26, 0x3d	; 61
    87e0:	be b7       	in	r27, 0x3e	; 62
    87e2:	18 97       	sbiw	r26, 0x08	; 8
    87e4:	0f b6       	in	r0, 0x3f	; 63
    87e6:	f8 94       	cli
    87e8:	be bf       	out	0x3e, r27	; 62
    87ea:	0f be       	out	0x3f, r0	; 63
    87ec:	ad bf       	out	0x3d, r26	; 61
    87ee:	ed b7       	in	r30, 0x3d	; 61
    87f0:	fe b7       	in	r31, 0x3e	; 62
    87f2:	31 96       	adiw	r30, 0x01	; 1
    87f4:	db 01       	movw	r26, r22
    87f6:	8d 91       	ld	r24, X+
    87f8:	9c 91       	ld	r25, X
    87fa:	ad b7       	in	r26, 0x3d	; 61
    87fc:	be b7       	in	r27, 0x3e	; 62
    87fe:	12 96       	adiw	r26, 0x02	; 2
    8800:	9c 93       	st	X, r25
    8802:	8e 93       	st	-X, r24
    8804:	11 97       	sbiw	r26, 0x01	; 1
    8806:	73 82       	std	Z+3, r7	; 0x03
    8808:	62 82       	std	Z+2, r6	; 0x02
    880a:	80 91 f7 04 	lds	r24, 0x04F7
    880e:	90 91 f8 04 	lds	r25, 0x04F8
    8812:	a0 91 f9 04 	lds	r26, 0x04F9
    8816:	b0 91 fa 04 	lds	r27, 0x04FA
    881a:	84 83       	std	Z+4, r24	; 0x04
    881c:	95 83       	std	Z+5, r25	; 0x05
    881e:	a6 83       	std	Z+6, r26	; 0x06
    8820:	b7 83       	std	Z+7, r27	; 0x07
    8822:	0e 94 e9 81 	call	0x103d2	; 0x103d2 <sprintf>
    8826:	ed b7       	in	r30, 0x3d	; 61
    8828:	fe b7       	in	r31, 0x3e	; 62
    882a:	38 96       	adiw	r30, 0x08	; 8
    882c:	0f b6       	in	r0, 0x3f	; 63
    882e:	f8 94       	cli
    8830:	fe bf       	out	0x3e, r31	; 62
    8832:	0f be       	out	0x3f, r0	; 63
    8834:	ed bf       	out	0x3d, r30	; 61
    8836:	bd cf       	rjmp	.-134    	; 0x87b2 <Put_bVal+0x10c>

00008838 <Put_TextValAlignLeft>:
	char Format[8];
	//char Format[8] = "%10.10s";
	sprintf(Format,"%%%u.%us", Param->Size, Param->Size);
	sprintf(Param->Pos, Format, Val);
}
void Put_TextValAlignLeft(char* Val, T_Param *Param){
    8838:	cf 92       	push	r12
    883a:	df 92       	push	r13
    883c:	ef 92       	push	r14
    883e:	ff 92       	push	r15
    8840:	0f 93       	push	r16
    8842:	1f 93       	push	r17
    8844:	df 93       	push	r29
    8846:	cf 93       	push	r28
    8848:	cd b7       	in	r28, 0x3d	; 61
    884a:	de b7       	in	r29, 0x3e	; 62
    884c:	29 97       	sbiw	r28, 0x09	; 9
    884e:	0f b6       	in	r0, 0x3f	; 63
    8850:	f8 94       	cli
    8852:	de bf       	out	0x3e, r29	; 62
    8854:	0f be       	out	0x3f, r0	; 63
    8856:	cd bf       	out	0x3d, r28	; 61
    8858:	6c 01       	movw	r12, r24
    885a:	7b 01       	movw	r14, r22
	char Format[9];
	//char Format[8] = "%10.10s";
	sprintf(Format,"%%-%u.%us", Param->Size, Param->Size);
    885c:	db 01       	movw	r26, r22
    885e:	13 96       	adiw	r26, 0x03	; 3
    8860:	2c 91       	ld	r18, X
    8862:	ed b7       	in	r30, 0x3d	; 61
    8864:	fe b7       	in	r31, 0x3e	; 62
    8866:	38 97       	sbiw	r30, 0x08	; 8
    8868:	0f b6       	in	r0, 0x3f	; 63
    886a:	f8 94       	cli
    886c:	fe bf       	out	0x3e, r31	; 62
    886e:	0f be       	out	0x3f, r0	; 63
    8870:	ed bf       	out	0x3d, r30	; 61
    8872:	31 96       	adiw	r30, 0x01	; 1
    8874:	8e 01       	movw	r16, r28
    8876:	0f 5f       	subi	r16, 0xFF	; 255
    8878:	1f 4f       	sbci	r17, 0xFF	; 255
    887a:	ad b7       	in	r26, 0x3d	; 61
    887c:	be b7       	in	r27, 0x3e	; 62
    887e:	12 96       	adiw	r26, 0x02	; 2
    8880:	1c 93       	st	X, r17
    8882:	0e 93       	st	-X, r16
    8884:	11 97       	sbiw	r26, 0x01	; 1
    8886:	87 e1       	ldi	r24, 0x17	; 23
    8888:	92 e0       	ldi	r25, 0x02	; 2
    888a:	93 83       	std	Z+3, r25	; 0x03
    888c:	82 83       	std	Z+2, r24	; 0x02
    888e:	24 83       	std	Z+4, r18	; 0x04
    8890:	15 82       	std	Z+5, r1	; 0x05
    8892:	26 83       	std	Z+6, r18	; 0x06
    8894:	17 82       	std	Z+7, r1	; 0x07
    8896:	0e 94 e9 81 	call	0x103d2	; 0x103d2 <sprintf>
	sprintf(Param->Pos, Format, Val);
    889a:	0f 90       	pop	r0
    889c:	0f 90       	pop	r0
    889e:	ed b7       	in	r30, 0x3d	; 61
    88a0:	fe b7       	in	r31, 0x3e	; 62
    88a2:	31 96       	adiw	r30, 0x01	; 1
    88a4:	d7 01       	movw	r26, r14
    88a6:	8d 91       	ld	r24, X+
    88a8:	9c 91       	ld	r25, X
    88aa:	ad b7       	in	r26, 0x3d	; 61
    88ac:	be b7       	in	r27, 0x3e	; 62
    88ae:	12 96       	adiw	r26, 0x02	; 2
    88b0:	9c 93       	st	X, r25
    88b2:	8e 93       	st	-X, r24
    88b4:	11 97       	sbiw	r26, 0x01	; 1
    88b6:	13 83       	std	Z+3, r17	; 0x03
    88b8:	02 83       	std	Z+2, r16	; 0x02
    88ba:	d5 82       	std	Z+5, r13	; 0x05
    88bc:	c4 82       	std	Z+4, r12	; 0x04
    88be:	0e 94 e9 81 	call	0x103d2	; 0x103d2 <sprintf>
    88c2:	ed b7       	in	r30, 0x3d	; 61
    88c4:	fe b7       	in	r31, 0x3e	; 62
    88c6:	36 96       	adiw	r30, 0x06	; 6
    88c8:	0f b6       	in	r0, 0x3f	; 63
    88ca:	f8 94       	cli
    88cc:	fe bf       	out	0x3e, r31	; 62
    88ce:	0f be       	out	0x3f, r0	; 63
    88d0:	ed bf       	out	0x3d, r30	; 61
}
    88d2:	29 96       	adiw	r28, 0x09	; 9
    88d4:	0f b6       	in	r0, 0x3f	; 63
    88d6:	f8 94       	cli
    88d8:	de bf       	out	0x3e, r29	; 62
    88da:	0f be       	out	0x3f, r0	; 63
    88dc:	cd bf       	out	0x3d, r28	; 61
    88de:	cf 91       	pop	r28
    88e0:	df 91       	pop	r29
    88e2:	1f 91       	pop	r17
    88e4:	0f 91       	pop	r16
    88e6:	ff 90       	pop	r15
    88e8:	ef 90       	pop	r14
    88ea:	df 90       	pop	r13
    88ec:	cf 90       	pop	r12
    88ee:	08 95       	ret

000088f0 <Put_TextValAlignRight>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Put_TextVal -  
// if, for example, Filed width =12 -> sprintf(Param->Pos,"%12.12s",Val)
// min and max width = Param->Size and align right
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void Put_TextValAlignRight(char* Val, T_Param *Param){
    88f0:	cf 92       	push	r12
    88f2:	df 92       	push	r13
    88f4:	ef 92       	push	r14
    88f6:	ff 92       	push	r15
    88f8:	0f 93       	push	r16
    88fa:	1f 93       	push	r17
    88fc:	df 93       	push	r29
    88fe:	cf 93       	push	r28
    8900:	cd b7       	in	r28, 0x3d	; 61
    8902:	de b7       	in	r29, 0x3e	; 62
    8904:	28 97       	sbiw	r28, 0x08	; 8
    8906:	0f b6       	in	r0, 0x3f	; 63
    8908:	f8 94       	cli
    890a:	de bf       	out	0x3e, r29	; 62
    890c:	0f be       	out	0x3f, r0	; 63
    890e:	cd bf       	out	0x3d, r28	; 61
    8910:	6c 01       	movw	r12, r24
    8912:	7b 01       	movw	r14, r22
	char Format[8];
	//char Format[8] = "%10.10s";
	sprintf(Format,"%%%u.%us", Param->Size, Param->Size);
    8914:	db 01       	movw	r26, r22
    8916:	13 96       	adiw	r26, 0x03	; 3
    8918:	2c 91       	ld	r18, X
    891a:	ed b7       	in	r30, 0x3d	; 61
    891c:	fe b7       	in	r31, 0x3e	; 62
    891e:	38 97       	sbiw	r30, 0x08	; 8
    8920:	0f b6       	in	r0, 0x3f	; 63
    8922:	f8 94       	cli
    8924:	fe bf       	out	0x3e, r31	; 62
    8926:	0f be       	out	0x3f, r0	; 63
    8928:	ed bf       	out	0x3d, r30	; 61
    892a:	31 96       	adiw	r30, 0x01	; 1
    892c:	8e 01       	movw	r16, r28
    892e:	0f 5f       	subi	r16, 0xFF	; 255
    8930:	1f 4f       	sbci	r17, 0xFF	; 255
    8932:	ad b7       	in	r26, 0x3d	; 61
    8934:	be b7       	in	r27, 0x3e	; 62
    8936:	12 96       	adiw	r26, 0x02	; 2
    8938:	1c 93       	st	X, r17
    893a:	0e 93       	st	-X, r16
    893c:	11 97       	sbiw	r26, 0x01	; 1
    893e:	81 e2       	ldi	r24, 0x21	; 33
    8940:	92 e0       	ldi	r25, 0x02	; 2
    8942:	93 83       	std	Z+3, r25	; 0x03
    8944:	82 83       	std	Z+2, r24	; 0x02
    8946:	24 83       	std	Z+4, r18	; 0x04
    8948:	15 82       	std	Z+5, r1	; 0x05
    894a:	26 83       	std	Z+6, r18	; 0x06
    894c:	17 82       	std	Z+7, r1	; 0x07
    894e:	0e 94 e9 81 	call	0x103d2	; 0x103d2 <sprintf>
	sprintf(Param->Pos, Format, Val);
    8952:	0f 90       	pop	r0
    8954:	0f 90       	pop	r0
    8956:	ed b7       	in	r30, 0x3d	; 61
    8958:	fe b7       	in	r31, 0x3e	; 62
    895a:	31 96       	adiw	r30, 0x01	; 1
    895c:	d7 01       	movw	r26, r14
    895e:	8d 91       	ld	r24, X+
    8960:	9c 91       	ld	r25, X
    8962:	ad b7       	in	r26, 0x3d	; 61
    8964:	be b7       	in	r27, 0x3e	; 62
    8966:	12 96       	adiw	r26, 0x02	; 2
    8968:	9c 93       	st	X, r25
    896a:	8e 93       	st	-X, r24
    896c:	11 97       	sbiw	r26, 0x01	; 1
    896e:	13 83       	std	Z+3, r17	; 0x03
    8970:	02 83       	std	Z+2, r16	; 0x02
    8972:	d5 82       	std	Z+5, r13	; 0x05
    8974:	c4 82       	std	Z+4, r12	; 0x04
    8976:	0e 94 e9 81 	call	0x103d2	; 0x103d2 <sprintf>
    897a:	ed b7       	in	r30, 0x3d	; 61
    897c:	fe b7       	in	r31, 0x3e	; 62
    897e:	36 96       	adiw	r30, 0x06	; 6
    8980:	0f b6       	in	r0, 0x3f	; 63
    8982:	f8 94       	cli
    8984:	fe bf       	out	0x3e, r31	; 62
    8986:	0f be       	out	0x3f, r0	; 63
    8988:	ed bf       	out	0x3d, r30	; 61
}
    898a:	28 96       	adiw	r28, 0x08	; 8
    898c:	0f b6       	in	r0, 0x3f	; 63
    898e:	f8 94       	cli
    8990:	de bf       	out	0x3e, r29	; 62
    8992:	0f be       	out	0x3f, r0	; 63
    8994:	cd bf       	out	0x3d, r28	; 61
    8996:	cf 91       	pop	r28
    8998:	df 91       	pop	r29
    899a:	1f 91       	pop	r17
    899c:	0f 91       	pop	r16
    899e:	ff 90       	pop	r15
    89a0:	ef 90       	pop	r14
    89a2:	df 90       	pop	r13
    89a4:	cf 90       	pop	r12
    89a6:	08 95       	ret

000089a8 <Put_GFVal>:
// Trailing zeros are removed from the fractional part of the result; 
// a decimal point appears only if it is followed by at least one digit.
// Max presicion - 8digits Why???
// Therefore Max Field size - 9
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void Put_GFVal(float Val, T_Param *Param){
    89a8:	ef 92       	push	r14
    89aa:	ff 92       	push	r15
    89ac:	0f 93       	push	r16
    89ae:	1f 93       	push	r17
    89b0:	df 93       	push	r29
    89b2:	cf 93       	push	r28
    89b4:	cd b7       	in	r28, 0x3d	; 61
    89b6:	de b7       	in	r29, 0x3e	; 62
    89b8:	2f 97       	sbiw	r28, 0x0f	; 15
    89ba:	0f b6       	in	r0, 0x3f	; 63
    89bc:	f8 94       	cli
    89be:	de bf       	out	0x3e, r29	; 62
    89c0:	0f be       	out	0x3f, r0	; 63
    89c2:	cd bf       	out	0x3d, r28	; 61
    89c4:	7b 01       	movw	r14, r22
    89c6:	8c 01       	movw	r16, r24
    89c8:	9a 01       	movw	r18, r20
	if(Param->Size < 10){
    89ca:	da 01       	movw	r26, r20
    89cc:	13 96       	adiw	r26, 0x03	; 3
    89ce:	8c 91       	ld	r24, X
    89d0:	8a 30       	cpi	r24, 0x0A	; 10
    89d2:	08 f4       	brcc	.+2      	; 0x89d6 <Put_GFVal+0x2e>
    89d4:	44 c0       	rjmp	.+136    	; 0x8a5e <Put_GFVal+0xb6>
		Format[2] = '0'+Param->Size;
		Format[4] = '0'+Param->Prec;
		sprintf(Param->Pos, Format, Val);
	}
	else{
		char Format[] = "%+1 . g";
    89d6:	ae 01       	movw	r20, r28
    89d8:	48 5f       	subi	r20, 0xF8	; 248
    89da:	5f 4f       	sbci	r21, 0xFF	; 255
    89dc:	da 01       	movw	r26, r20
    89de:	ea e2       	ldi	r30, 0x2A	; 42
    89e0:	f2 e0       	ldi	r31, 0x02	; 2
    89e2:	88 e0       	ldi	r24, 0x08	; 8
    89e4:	01 90       	ld	r0, Z+
    89e6:	0d 92       	st	X+, r0
    89e8:	81 50       	subi	r24, 0x01	; 1
    89ea:	e1 f7       	brne	.-8      	; 0x89e4 <Put_GFVal+0x3c>
		Format[3] = '0'+Param->Size-10;	
    89ec:	d9 01       	movw	r26, r18
    89ee:	13 96       	adiw	r26, 0x03	; 3
    89f0:	8c 91       	ld	r24, X
    89f2:	13 97       	sbiw	r26, 0x03	; 3
    89f4:	8a 5d       	subi	r24, 0xDA	; 218
    89f6:	8b 87       	std	Y+11, r24	; 0x0b
		Format[5] = '0'+Param->Prec;
    89f8:	12 96       	adiw	r26, 0x02	; 2
    89fa:	8c 91       	ld	r24, X
    89fc:	12 97       	sbiw	r26, 0x02	; 2
    89fe:	80 5d       	subi	r24, 0xD0	; 208
    8a00:	8d 87       	std	Y+13, r24	; 0x0d
		sprintf(Param->Pos, Format, Val);
    8a02:	ed b7       	in	r30, 0x3d	; 61
    8a04:	fe b7       	in	r31, 0x3e	; 62
    8a06:	38 97       	sbiw	r30, 0x08	; 8
    8a08:	0f b6       	in	r0, 0x3f	; 63
    8a0a:	f8 94       	cli
    8a0c:	fe bf       	out	0x3e, r31	; 62
    8a0e:	0f be       	out	0x3f, r0	; 63
    8a10:	ed bf       	out	0x3d, r30	; 61
    8a12:	31 96       	adiw	r30, 0x01	; 1
    8a14:	8d 91       	ld	r24, X+
    8a16:	9c 91       	ld	r25, X
    8a18:	ad b7       	in	r26, 0x3d	; 61
    8a1a:	be b7       	in	r27, 0x3e	; 62
    8a1c:	12 96       	adiw	r26, 0x02	; 2
    8a1e:	9c 93       	st	X, r25
    8a20:	8e 93       	st	-X, r24
    8a22:	11 97       	sbiw	r26, 0x01	; 1
    8a24:	53 83       	std	Z+3, r21	; 0x03
    8a26:	42 83       	std	Z+2, r20	; 0x02
    8a28:	e4 82       	std	Z+4, r14	; 0x04
    8a2a:	f5 82       	std	Z+5, r15	; 0x05
    8a2c:	06 83       	std	Z+6, r16	; 0x06
    8a2e:	17 83       	std	Z+7, r17	; 0x07
    8a30:	0e 94 e9 81 	call	0x103d2	; 0x103d2 <sprintf>
    8a34:	ed b7       	in	r30, 0x3d	; 61
    8a36:	fe b7       	in	r31, 0x3e	; 62
    8a38:	38 96       	adiw	r30, 0x08	; 8
    8a3a:	0f b6       	in	r0, 0x3f	; 63
    8a3c:	f8 94       	cli
    8a3e:	fe bf       	out	0x3e, r31	; 62
    8a40:	0f be       	out	0x3f, r0	; 63
    8a42:	ed bf       	out	0x3d, r30	; 61
	}
}
    8a44:	2f 96       	adiw	r28, 0x0f	; 15
    8a46:	0f b6       	in	r0, 0x3f	; 63
    8a48:	f8 94       	cli
    8a4a:	de bf       	out	0x3e, r29	; 62
    8a4c:	0f be       	out	0x3f, r0	; 63
    8a4e:	cd bf       	out	0x3d, r28	; 61
    8a50:	cf 91       	pop	r28
    8a52:	df 91       	pop	r29
    8a54:	1f 91       	pop	r17
    8a56:	0f 91       	pop	r16
    8a58:	ff 90       	pop	r15
    8a5a:	ef 90       	pop	r14
    8a5c:	08 95       	ret
// Max presicion - 8digits Why???
// Therefore Max Field size - 9
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void Put_GFVal(float Val, T_Param *Param){
	if(Param->Size < 10){
		char Format[] = "%+ . g";
    8a5e:	ae 01       	movw	r20, r28
    8a60:	4f 5f       	subi	r20, 0xFF	; 255
    8a62:	5f 4f       	sbci	r21, 0xFF	; 255
    8a64:	da 01       	movw	r26, r20
    8a66:	e2 e3       	ldi	r30, 0x32	; 50
    8a68:	f2 e0       	ldi	r31, 0x02	; 2
    8a6a:	87 e0       	ldi	r24, 0x07	; 7
    8a6c:	01 90       	ld	r0, Z+
    8a6e:	0d 92       	st	X+, r0
    8a70:	81 50       	subi	r24, 0x01	; 1
    8a72:	e1 f7       	brne	.-8      	; 0x8a6c <Put_GFVal+0xc4>
		Format[2] = '0'+Param->Size;
    8a74:	f9 01       	movw	r30, r18
    8a76:	83 81       	ldd	r24, Z+3	; 0x03
    8a78:	80 5d       	subi	r24, 0xD0	; 208
    8a7a:	8b 83       	std	Y+3, r24	; 0x03
		Format[4] = '0'+Param->Prec;
    8a7c:	82 81       	ldd	r24, Z+2	; 0x02
    8a7e:	80 5d       	subi	r24, 0xD0	; 208
    8a80:	8d 83       	std	Y+5, r24	; 0x05
		sprintf(Param->Pos, Format, Val);
    8a82:	8d b7       	in	r24, 0x3d	; 61
    8a84:	9e b7       	in	r25, 0x3e	; 62
    8a86:	08 97       	sbiw	r24, 0x08	; 8
    8a88:	0f b6       	in	r0, 0x3f	; 63
    8a8a:	f8 94       	cli
    8a8c:	9e bf       	out	0x3e, r25	; 62
    8a8e:	0f be       	out	0x3f, r0	; 63
    8a90:	8d bf       	out	0x3d, r24	; 61
    8a92:	ed b7       	in	r30, 0x3d	; 61
    8a94:	fe b7       	in	r31, 0x3e	; 62
    8a96:	31 96       	adiw	r30, 0x01	; 1
    8a98:	d9 01       	movw	r26, r18
    8a9a:	bc cf       	rjmp	.-136    	; 0x8a14 <Put_GFVal+0x6c>

00008a9c <Put_FFVal>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Put_FVal -  The double argument is rounded and converted to decimal notation in the format "[-]ddd.ddd"
// Max presicion - 8digits Why???
// Therefore Max Field size - 9
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void Put_FFVal(float Val, T_Param *Param){
    8a9c:	ef 92       	push	r14
    8a9e:	ff 92       	push	r15
    8aa0:	0f 93       	push	r16
    8aa2:	1f 93       	push	r17
    8aa4:	df 93       	push	r29
    8aa6:	cf 93       	push	r28
    8aa8:	cd b7       	in	r28, 0x3d	; 61
    8aaa:	de b7       	in	r29, 0x3e	; 62
    8aac:	27 97       	sbiw	r28, 0x07	; 7
    8aae:	0f b6       	in	r0, 0x3f	; 63
    8ab0:	f8 94       	cli
    8ab2:	de bf       	out	0x3e, r29	; 62
    8ab4:	0f be       	out	0x3f, r0	; 63
    8ab6:	cd bf       	out	0x3d, r28	; 61
    8ab8:	7b 01       	movw	r14, r22
    8aba:	8c 01       	movw	r16, r24
    8abc:	9a 01       	movw	r18, r20
	char Format[] = "%+ . f";
    8abe:	ae 01       	movw	r20, r28
    8ac0:	4f 5f       	subi	r20, 0xFF	; 255
    8ac2:	5f 4f       	sbci	r21, 0xFF	; 255
    8ac4:	da 01       	movw	r26, r20
    8ac6:	e9 e3       	ldi	r30, 0x39	; 57
    8ac8:	f2 e0       	ldi	r31, 0x02	; 2
    8aca:	87 e0       	ldi	r24, 0x07	; 7
    8acc:	01 90       	ld	r0, Z+
    8ace:	0d 92       	st	X+, r0
    8ad0:	81 50       	subi	r24, 0x01	; 1
    8ad2:	e1 f7       	brne	.-8      	; 0x8acc <Put_FFVal+0x30>
	Format[2] = '0'+Param->Size;
    8ad4:	d9 01       	movw	r26, r18
    8ad6:	13 96       	adiw	r26, 0x03	; 3
    8ad8:	8c 91       	ld	r24, X
    8ada:	13 97       	sbiw	r26, 0x03	; 3
    8adc:	80 5d       	subi	r24, 0xD0	; 208
    8ade:	8b 83       	std	Y+3, r24	; 0x03
	Format[4] = '0'+Param->Prec;	
    8ae0:	12 96       	adiw	r26, 0x02	; 2
    8ae2:	8c 91       	ld	r24, X
    8ae4:	12 97       	sbiw	r26, 0x02	; 2
    8ae6:	80 5d       	subi	r24, 0xD0	; 208
    8ae8:	8d 83       	std	Y+5, r24	; 0x05
	sprintf(Param->Pos, Format, Val);
    8aea:	ed b7       	in	r30, 0x3d	; 61
    8aec:	fe b7       	in	r31, 0x3e	; 62
    8aee:	38 97       	sbiw	r30, 0x08	; 8
    8af0:	0f b6       	in	r0, 0x3f	; 63
    8af2:	f8 94       	cli
    8af4:	fe bf       	out	0x3e, r31	; 62
    8af6:	0f be       	out	0x3f, r0	; 63
    8af8:	ed bf       	out	0x3d, r30	; 61
    8afa:	31 96       	adiw	r30, 0x01	; 1
    8afc:	8d 91       	ld	r24, X+
    8afe:	9c 91       	ld	r25, X
    8b00:	ad b7       	in	r26, 0x3d	; 61
    8b02:	be b7       	in	r27, 0x3e	; 62
    8b04:	12 96       	adiw	r26, 0x02	; 2
    8b06:	9c 93       	st	X, r25
    8b08:	8e 93       	st	-X, r24
    8b0a:	11 97       	sbiw	r26, 0x01	; 1
    8b0c:	53 83       	std	Z+3, r21	; 0x03
    8b0e:	42 83       	std	Z+2, r20	; 0x02
    8b10:	e4 82       	std	Z+4, r14	; 0x04
    8b12:	f5 82       	std	Z+5, r15	; 0x05
    8b14:	06 83       	std	Z+6, r16	; 0x06
    8b16:	17 83       	std	Z+7, r17	; 0x07
    8b18:	0e 94 e9 81 	call	0x103d2	; 0x103d2 <sprintf>
    8b1c:	ed b7       	in	r30, 0x3d	; 61
    8b1e:	fe b7       	in	r31, 0x3e	; 62
    8b20:	38 96       	adiw	r30, 0x08	; 8
    8b22:	0f b6       	in	r0, 0x3f	; 63
    8b24:	f8 94       	cli
    8b26:	fe bf       	out	0x3e, r31	; 62
    8b28:	0f be       	out	0x3f, r0	; 63
    8b2a:	ed bf       	out	0x3d, r30	; 61
}
    8b2c:	27 96       	adiw	r28, 0x07	; 7
    8b2e:	0f b6       	in	r0, 0x3f	; 63
    8b30:	f8 94       	cli
    8b32:	de bf       	out	0x3e, r29	; 62
    8b34:	0f be       	out	0x3f, r0	; 63
    8b36:	cd bf       	out	0x3d, r28	; 61
    8b38:	cf 91       	pop	r28
    8b3a:	df 91       	pop	r29
    8b3c:	1f 91       	pop	r17
    8b3e:	0f 91       	pop	r16
    8b40:	ff 90       	pop	r15
    8b42:	ef 90       	pop	r14
    8b44:	08 95       	ret

00008b46 <Put_zDVal>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Put_zDVal - print unsigned Longint with leading zeroes in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void 
Put_zDVal(uint32_t Val, T_Param *Param)
{
    8b46:	2f 92       	push	r2
    8b48:	3f 92       	push	r3
    8b4a:	4f 92       	push	r4
    8b4c:	5f 92       	push	r5
    8b4e:	6f 92       	push	r6
    8b50:	7f 92       	push	r7
    8b52:	8f 92       	push	r8
    8b54:	9f 92       	push	r9
    8b56:	af 92       	push	r10
    8b58:	bf 92       	push	r11
    8b5a:	cf 92       	push	r12
    8b5c:	df 92       	push	r13
    8b5e:	ef 92       	push	r14
    8b60:	ff 92       	push	r15
    8b62:	0f 93       	push	r16
    8b64:	1f 93       	push	r17
    8b66:	df 93       	push	r29
    8b68:	cf 93       	push	r28
    8b6a:	cd b7       	in	r28, 0x3d	; 61
    8b6c:	de b7       	in	r29, 0x3e	; 62
    8b6e:	2c 97       	sbiw	r28, 0x0c	; 12
    8b70:	0f b6       	in	r0, 0x3f	; 63
    8b72:	f8 94       	cli
    8b74:	de bf       	out	0x3e, r29	; 62
    8b76:	0f be       	out	0x3f, r0	; 63
    8b78:	cd bf       	out	0x3d, r28	; 61
    8b7a:	1b 01       	movw	r2, r22
    8b7c:	2c 01       	movw	r4, r24
    8b7e:	3a 01       	movw	r6, r20
	uint32_t Idx = 0xFFFFFFFF-Val;
	if(Param->Txt && Idx<2) {
    8b80:	da 01       	movw	r26, r20
    8b82:	14 96       	adiw	r26, 0x04	; 4
    8b84:	2d 91       	ld	r18, X+
    8b86:	3c 91       	ld	r19, X
    8b88:	15 97       	sbiw	r26, 0x05	; 5
    8b8a:	21 15       	cp	r18, r1
    8b8c:	31 05       	cpc	r19, r1
    8b8e:	61 f0       	breq	.+24     	; 0x8ba8 <Put_zDVal+0x62>
// Put_zDVal - print unsigned Longint with leading zeroes in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void 
Put_zDVal(uint32_t Val, T_Param *Param)
{
	uint32_t Idx = 0xFFFFFFFF-Val;
    8b90:	dc 01       	movw	r26, r24
    8b92:	cb 01       	movw	r24, r22
    8b94:	80 95       	com	r24
    8b96:	90 95       	com	r25
    8b98:	a0 95       	com	r26
    8b9a:	b0 95       	com	r27
	if(Param->Txt && Idx<2) {
    8b9c:	82 30       	cpi	r24, 0x02	; 2
    8b9e:	91 05       	cpc	r25, r1
    8ba0:	a1 05       	cpc	r26, r1
    8ba2:	b1 05       	cpc	r27, r1
    8ba4:	08 f4       	brcc	.+2      	; 0x8ba8 <Put_zDVal+0x62>
    8ba6:	e5 c0       	rjmp	.+458    	; 0x8d72 <Put_zDVal+0x22c>
		Param->Txt += Idx;
		PutEnum(Param);
		return;
	}

	if(Param->Size==10 && Param->Prec==0){
    8ba8:	d3 01       	movw	r26, r6
    8baa:	13 96       	adiw	r26, 0x03	; 3
    8bac:	8c 91       	ld	r24, X
    8bae:	13 97       	sbiw	r26, 0x03	; 3
    8bb0:	8a 30       	cpi	r24, 0x0A	; 10
    8bb2:	09 f4       	brne	.+2      	; 0x8bb6 <Put_zDVal+0x70>
    8bb4:	72 c0       	rjmp	.+228    	; 0x8c9a <Put_zDVal+0x154>
		sprintf(Param->Pos, "%010lu", Val);
		return;
	}
	char Format[] = "%0 lu.%. lu";
    8bb6:	de 01       	movw	r26, r28
    8bb8:	11 96       	adiw	r26, 0x01	; 1
    8bba:	e7 e4       	ldi	r30, 0x47	; 71
    8bbc:	f2 e0       	ldi	r31, 0x02	; 2
    8bbe:	8c e0       	ldi	r24, 0x0C	; 12
    8bc0:	01 90       	ld	r0, Z+
    8bc2:	0d 92       	st	X+, r0
    8bc4:	81 50       	subi	r24, 0x01	; 1
    8bc6:	e1 f7       	brne	.-8      	; 0x8bc0 <Put_zDVal+0x7a>
	Format[2] = '0'+Param->Size;
    8bc8:	d3 01       	movw	r26, r6
    8bca:	13 96       	adiw	r26, 0x03	; 3
    8bcc:	2c 91       	ld	r18, X
    8bce:	13 97       	sbiw	r26, 0x03	; 3
    8bd0:	20 5d       	subi	r18, 0xD0	; 208
    8bd2:	2b 83       	std	Y+3, r18	; 0x03
	if(Param->Prec) {
    8bd4:	12 96       	adiw	r26, 0x02	; 2
    8bd6:	9c 91       	ld	r25, X
    8bd8:	99 23       	and	r25, r25
    8bda:	09 f4       	brne	.+2      	; 0x8bde <Put_zDVal+0x98>
    8bdc:	a0 c0       	rjmp	.+320    	; 0x8d1e <Put_zDVal+0x1d8>
		Format[2] -= Param->Prec+1;
    8bde:	89 2f       	mov	r24, r25
    8be0:	80 95       	com	r24
    8be2:	82 0f       	add	r24, r18
    8be4:	8b 83       	std	Y+3, r24	; 0x03
		Format[8] = '0'+Param->Prec;
    8be6:	90 5d       	subi	r25, 0xD0	; 208
    8be8:	99 87       	std	Y+9, r25	; 0x09
    8bea:	90 53       	subi	r25, 0x30	; 48
		uint32_t Div=PowL10(Param->Prec);
    8bec:	09 2f       	mov	r16, r25
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
	uint32_t Pow = 1;
	while(Exp--)
    8bee:	61 e0       	ldi	r22, 0x01	; 1
    8bf0:	86 2e       	mov	r8, r22
    8bf2:	91 2c       	mov	r9, r1
    8bf4:	a1 2c       	mov	r10, r1
    8bf6:	b1 2c       	mov	r11, r1
		Pow *= 10;
    8bf8:	c5 01       	movw	r24, r10
    8bfa:	b4 01       	movw	r22, r8
    8bfc:	2a e0       	ldi	r18, 0x0A	; 10
    8bfe:	30 e0       	ldi	r19, 0x00	; 0
    8c00:	40 e0       	ldi	r20, 0x00	; 0
    8c02:	50 e0       	ldi	r21, 0x00	; 0
    8c04:	0e 94 53 84 	call	0x108a6	; 0x108a6 <__mulsi3>
    8c08:	4b 01       	movw	r8, r22
    8c0a:	5c 01       	movw	r10, r24
    8c0c:	01 50       	subi	r16, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
	uint32_t Pow = 1;
	while(Exp--)
    8c0e:	a1 f7       	brne	.-24     	; 0x8bf8 <Put_zDVal+0xb2>
    8c10:	c2 01       	movw	r24, r4
    8c12:	b1 01       	movw	r22, r2
    8c14:	94 01       	movw	r18, r8
    8c16:	a5 01       	movw	r20, r10
    8c18:	0e 94 a5 84 	call	0x1094a	; 0x1094a <__udivmodsi4>
    8c1c:	f6 2e       	mov	r15, r22
    8c1e:	e7 2e       	mov	r14, r23
    8c20:	d8 2e       	mov	r13, r24
    8c22:	c9 2e       	mov	r12, r25
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
    8c24:	ed b7       	in	r30, 0x3d	; 61
    8c26:	fe b7       	in	r31, 0x3e	; 62
    8c28:	3c 97       	sbiw	r30, 0x0c	; 12
    8c2a:	0f b6       	in	r0, 0x3f	; 63
    8c2c:	f8 94       	cli
    8c2e:	fe bf       	out	0x3e, r31	; 62
    8c30:	0f be       	out	0x3f, r0	; 63
    8c32:	ed bf       	out	0x3d, r30	; 61
    8c34:	0d b7       	in	r16, 0x3d	; 61
    8c36:	1e b7       	in	r17, 0x3e	; 62
    8c38:	0f 5f       	subi	r16, 0xFF	; 255
    8c3a:	1f 4f       	sbci	r17, 0xFF	; 255
    8c3c:	d3 01       	movw	r26, r6
    8c3e:	8d 91       	ld	r24, X+
    8c40:	9c 91       	ld	r25, X
    8c42:	92 83       	std	Z+2, r25	; 0x02
    8c44:	81 83       	std	Z+1, r24	; 0x01
    8c46:	81 e0       	ldi	r24, 0x01	; 1
    8c48:	90 e0       	ldi	r25, 0x00	; 0
    8c4a:	8c 0f       	add	r24, r28
    8c4c:	9d 1f       	adc	r25, r29
    8c4e:	f8 01       	movw	r30, r16
    8c50:	93 83       	std	Z+3, r25	; 0x03
    8c52:	82 83       	std	Z+2, r24	; 0x02
    8c54:	c2 01       	movw	r24, r4
    8c56:	b1 01       	movw	r22, r2
    8c58:	a5 01       	movw	r20, r10
    8c5a:	94 01       	movw	r18, r8
    8c5c:	0e 94 a5 84 	call	0x1094a	; 0x1094a <__udivmodsi4>
    8c60:	d8 01       	movw	r26, r16
    8c62:	14 96       	adiw	r26, 0x04	; 4
    8c64:	2d 93       	st	X+, r18
    8c66:	3d 93       	st	X+, r19
    8c68:	4d 93       	st	X+, r20
    8c6a:	5c 93       	st	X, r21
    8c6c:	17 97       	sbiw	r26, 0x07	; 7
    8c6e:	18 96       	adiw	r26, 0x08	; 8
    8c70:	fc 92       	st	X, r15
    8c72:	18 97       	sbiw	r26, 0x08	; 8
    8c74:	19 96       	adiw	r26, 0x09	; 9
    8c76:	ec 92       	st	X, r14
    8c78:	19 97       	sbiw	r26, 0x09	; 9
    8c7a:	1a 96       	adiw	r26, 0x0a	; 10
    8c7c:	dc 92       	st	X, r13
    8c7e:	1a 97       	sbiw	r26, 0x0a	; 10
    8c80:	1b 96       	adiw	r26, 0x0b	; 11
    8c82:	cc 92       	st	X, r12
    8c84:	0e 94 e9 81 	call	0x103d2	; 0x103d2 <sprintf>
    8c88:	ed b7       	in	r30, 0x3d	; 61
    8c8a:	fe b7       	in	r31, 0x3e	; 62
    8c8c:	3c 96       	adiw	r30, 0x0c	; 12
    8c8e:	0f b6       	in	r0, 0x3f	; 63
    8c90:	f8 94       	cli
    8c92:	fe bf       	out	0x3e, r31	; 62
    8c94:	0f be       	out	0x3f, r0	; 63
    8c96:	ed bf       	out	0x3d, r30	; 61
    8c98:	29 c0       	rjmp	.+82     	; 0x8cec <Put_zDVal+0x1a6>
		Param->Txt += Idx;
		PutEnum(Param);
		return;
	}

	if(Param->Size==10 && Param->Prec==0){
    8c9a:	12 96       	adiw	r26, 0x02	; 2
    8c9c:	8c 91       	ld	r24, X
    8c9e:	12 97       	sbiw	r26, 0x02	; 2
    8ca0:	88 23       	and	r24, r24
    8ca2:	09 f0       	breq	.+2      	; 0x8ca6 <Put_zDVal+0x160>
    8ca4:	88 cf       	rjmp	.-240    	; 0x8bb6 <Put_zDVal+0x70>
		sprintf(Param->Pos, "%010lu", Val);
    8ca6:	ed b7       	in	r30, 0x3d	; 61
    8ca8:	fe b7       	in	r31, 0x3e	; 62
    8caa:	38 97       	sbiw	r30, 0x08	; 8
    8cac:	0f b6       	in	r0, 0x3f	; 63
    8cae:	f8 94       	cli
    8cb0:	fe bf       	out	0x3e, r31	; 62
    8cb2:	0f be       	out	0x3f, r0	; 63
    8cb4:	ed bf       	out	0x3d, r30	; 61
    8cb6:	31 96       	adiw	r30, 0x01	; 1
    8cb8:	8d 91       	ld	r24, X+
    8cba:	9c 91       	ld	r25, X
    8cbc:	ad b7       	in	r26, 0x3d	; 61
    8cbe:	be b7       	in	r27, 0x3e	; 62
    8cc0:	12 96       	adiw	r26, 0x02	; 2
    8cc2:	9c 93       	st	X, r25
    8cc4:	8e 93       	st	-X, r24
    8cc6:	11 97       	sbiw	r26, 0x01	; 1
    8cc8:	80 e4       	ldi	r24, 0x40	; 64
    8cca:	92 e0       	ldi	r25, 0x02	; 2
    8ccc:	93 83       	std	Z+3, r25	; 0x03
    8cce:	82 83       	std	Z+2, r24	; 0x02
    8cd0:	24 82       	std	Z+4, r2	; 0x04
    8cd2:	35 82       	std	Z+5, r3	; 0x05
    8cd4:	46 82       	std	Z+6, r4	; 0x06
    8cd6:	57 82       	std	Z+7, r5	; 0x07
    8cd8:	0e 94 e9 81 	call	0x103d2	; 0x103d2 <sprintf>
    8cdc:	ed b7       	in	r30, 0x3d	; 61
    8cde:	fe b7       	in	r31, 0x3e	; 62
    8ce0:	38 96       	adiw	r30, 0x08	; 8
    8ce2:	0f b6       	in	r0, 0x3f	; 63
    8ce4:	f8 94       	cli
    8ce6:	fe bf       	out	0x3e, r31	; 62
    8ce8:	0f be       	out	0x3f, r0	; 63
    8cea:	ed bf       	out	0x3d, r30	; 61
	}
	else {
		Format[5] = '\0';
		sprintf(Param->Pos, Format, Val);
	}
}
    8cec:	2c 96       	adiw	r28, 0x0c	; 12
    8cee:	0f b6       	in	r0, 0x3f	; 63
    8cf0:	f8 94       	cli
    8cf2:	de bf       	out	0x3e, r29	; 62
    8cf4:	0f be       	out	0x3f, r0	; 63
    8cf6:	cd bf       	out	0x3d, r28	; 61
    8cf8:	cf 91       	pop	r28
    8cfa:	df 91       	pop	r29
    8cfc:	1f 91       	pop	r17
    8cfe:	0f 91       	pop	r16
    8d00:	ff 90       	pop	r15
    8d02:	ef 90       	pop	r14
    8d04:	df 90       	pop	r13
    8d06:	cf 90       	pop	r12
    8d08:	bf 90       	pop	r11
    8d0a:	af 90       	pop	r10
    8d0c:	9f 90       	pop	r9
    8d0e:	8f 90       	pop	r8
    8d10:	7f 90       	pop	r7
    8d12:	6f 90       	pop	r6
    8d14:	5f 90       	pop	r5
    8d16:	4f 90       	pop	r4
    8d18:	3f 90       	pop	r3
    8d1a:	2f 90       	pop	r2
    8d1c:	08 95       	ret
		Format[8] = '0'+Param->Prec;
		uint32_t Div=PowL10(Param->Prec);
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
	}
	else {
		Format[5] = '\0';
    8d1e:	1e 82       	std	Y+6, r1	; 0x06
		sprintf(Param->Pos, Format, Val);
    8d20:	8d b7       	in	r24, 0x3d	; 61
    8d22:	9e b7       	in	r25, 0x3e	; 62
    8d24:	08 97       	sbiw	r24, 0x08	; 8
    8d26:	0f b6       	in	r0, 0x3f	; 63
    8d28:	f8 94       	cli
    8d2a:	9e bf       	out	0x3e, r25	; 62
    8d2c:	0f be       	out	0x3f, r0	; 63
    8d2e:	8d bf       	out	0x3d, r24	; 61
    8d30:	ed b7       	in	r30, 0x3d	; 61
    8d32:	fe b7       	in	r31, 0x3e	; 62
    8d34:	31 96       	adiw	r30, 0x01	; 1
    8d36:	d3 01       	movw	r26, r6
    8d38:	8d 91       	ld	r24, X+
    8d3a:	9c 91       	ld	r25, X
    8d3c:	ad b7       	in	r26, 0x3d	; 61
    8d3e:	be b7       	in	r27, 0x3e	; 62
    8d40:	12 96       	adiw	r26, 0x02	; 2
    8d42:	9c 93       	st	X, r25
    8d44:	8e 93       	st	-X, r24
    8d46:	11 97       	sbiw	r26, 0x01	; 1
    8d48:	81 e0       	ldi	r24, 0x01	; 1
    8d4a:	90 e0       	ldi	r25, 0x00	; 0
    8d4c:	8c 0f       	add	r24, r28
    8d4e:	9d 1f       	adc	r25, r29
    8d50:	93 83       	std	Z+3, r25	; 0x03
    8d52:	82 83       	std	Z+2, r24	; 0x02
    8d54:	24 82       	std	Z+4, r2	; 0x04
    8d56:	35 82       	std	Z+5, r3	; 0x05
    8d58:	46 82       	std	Z+6, r4	; 0x06
    8d5a:	57 82       	std	Z+7, r5	; 0x07
    8d5c:	0e 94 e9 81 	call	0x103d2	; 0x103d2 <sprintf>
    8d60:	ad b7       	in	r26, 0x3d	; 61
    8d62:	be b7       	in	r27, 0x3e	; 62
    8d64:	18 96       	adiw	r26, 0x08	; 8
    8d66:	0f b6       	in	r0, 0x3f	; 63
    8d68:	f8 94       	cli
    8d6a:	be bf       	out	0x3e, r27	; 62
    8d6c:	0f be       	out	0x3f, r0	; 63
    8d6e:	ad bf       	out	0x3d, r26	; 61
    8d70:	bd cf       	rjmp	.-134    	; 0x8cec <Put_zDVal+0x1a6>
void 
Put_zDVal(uint32_t Val, T_Param *Param)
{
	uint32_t Idx = 0xFFFFFFFF-Val;
	if(Param->Txt && Idx<2) {
		Param->Txt += Idx;
    8d72:	88 0f       	add	r24, r24
    8d74:	99 1f       	adc	r25, r25
    8d76:	28 0f       	add	r18, r24
    8d78:	39 1f       	adc	r19, r25
    8d7a:	fa 01       	movw	r30, r20
    8d7c:	35 83       	std	Z+5, r19	; 0x05
    8d7e:	24 83       	std	Z+4, r18	; 0x04
		PutEnum(Param);
    8d80:	ca 01       	movw	r24, r20
    8d82:	0e 94 24 42 	call	0x8448	; 0x8448 <PutEnum>
    8d86:	b2 cf       	rjmp	.-156    	; 0x8cec <Put_zDVal+0x1a6>

00008d88 <Put_sDVal>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Put_sDVal - print signed Longint in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_sDVal(int32_t Val, T_Param *Param)
{
    8d88:	cf 92       	push	r12
    8d8a:	df 92       	push	r13
    8d8c:	ef 92       	push	r14
    8d8e:	ff 92       	push	r15
    8d90:	0f 93       	push	r16
    8d92:	1f 93       	push	r17
    8d94:	df 93       	push	r29
    8d96:	cf 93       	push	r28
    8d98:	cd b7       	in	r28, 0x3d	; 61
    8d9a:	de b7       	in	r29, 0x3e	; 62
    8d9c:	2d 97       	sbiw	r28, 0x0d	; 13
    8d9e:	0f b6       	in	r0, 0x3f	; 63
    8da0:	f8 94       	cli
    8da2:	de bf       	out	0x3e, r29	; 62
    8da4:	0f be       	out	0x3f, r0	; 63
    8da6:	cd bf       	out	0x3d, r28	; 61
    8da8:	6b 01       	movw	r12, r22
    8daa:	7c 01       	movw	r14, r24
    8dac:	8a 01       	movw	r16, r20
	uint32_t Idx = 0x80000000+Val;
	if(Param->Txt && Idx<2) {
    8dae:	da 01       	movw	r26, r20
    8db0:	14 96       	adiw	r26, 0x04	; 4
    8db2:	2d 91       	ld	r18, X+
    8db4:	3c 91       	ld	r19, X
    8db6:	15 97       	sbiw	r26, 0x05	; 5
    8db8:	21 15       	cp	r18, r1
    8dba:	31 05       	cpc	r19, r1
    8dbc:	61 f0       	breq	.+24     	; 0x8dd6 <Put_sDVal+0x4e>
// Put_sDVal - print signed Longint in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_sDVal(int32_t Val, T_Param *Param)
{
	uint32_t Idx = 0x80000000+Val;
    8dbe:	dc 01       	movw	r26, r24
    8dc0:	cb 01       	movw	r24, r22
    8dc2:	80 50       	subi	r24, 0x00	; 0
    8dc4:	90 40       	sbci	r25, 0x00	; 0
    8dc6:	a0 40       	sbci	r26, 0x00	; 0
    8dc8:	b0 48       	sbci	r27, 0x80	; 128
	if(Param->Txt && Idx<2) {
    8dca:	82 30       	cpi	r24, 0x02	; 2
    8dcc:	91 05       	cpc	r25, r1
    8dce:	a1 05       	cpc	r26, r1
    8dd0:	b1 05       	cpc	r27, r1
    8dd2:	08 f4       	brcc	.+2      	; 0x8dd6 <Put_sDVal+0x4e>
    8dd4:	f7 c0       	rjmp	.+494    	; 0x8fc4 <Put_sDVal+0x23c>
		Param->Txt += Idx;
		PutEnum(Param);
		return;
	}
	// standart specificator to print Longint in string
	if(Param->Size>9){
    8dd6:	d8 01       	movw	r26, r16
    8dd8:	13 96       	adiw	r26, 0x03	; 3
    8dda:	8c 91       	ld	r24, X
    8ddc:	8a 30       	cpi	r24, 0x0A	; 10
    8dde:	f8 f0       	brcs	.+62     	; 0x8e1e <Put_sDVal+0x96>
		char Format[] = "%+1 ld";
    8de0:	9e 01       	movw	r18, r28
    8de2:	29 5f       	subi	r18, 0xF9	; 249
    8de4:	3f 4f       	sbci	r19, 0xFF	; 255
    8de6:	d9 01       	movw	r26, r18
    8de8:	e3 e5       	ldi	r30, 0x53	; 83
    8dea:	f2 e0       	ldi	r31, 0x02	; 2
    8dec:	87 e0       	ldi	r24, 0x07	; 7
    8dee:	01 90       	ld	r0, Z+
    8df0:	0d 92       	st	X+, r0
    8df2:	81 50       	subi	r24, 0x01	; 1
    8df4:	e1 f7       	brne	.-8      	; 0x8dee <Put_sDVal+0x66>
		Format[3] = '0'+Param->Size%10;
    8df6:	f8 01       	movw	r30, r16
    8df8:	83 81       	ldd	r24, Z+3	; 0x03
    8dfa:	6a e0       	ldi	r22, 0x0A	; 10
    8dfc:	0e 94 72 84 	call	0x108e4	; 0x108e4 <__udivmodqi4>
    8e00:	90 5d       	subi	r25, 0xD0	; 208
    8e02:	9a 87       	std	Y+10, r25	; 0x0a
		sprintf(Param->Pos, Format, Val);
    8e04:	8d b7       	in	r24, 0x3d	; 61
    8e06:	9e b7       	in	r25, 0x3e	; 62
    8e08:	08 97       	sbiw	r24, 0x08	; 8
    8e0a:	0f b6       	in	r0, 0x3f	; 63
    8e0c:	f8 94       	cli
    8e0e:	9e bf       	out	0x3e, r25	; 62
    8e10:	0f be       	out	0x3f, r0	; 63
    8e12:	8d bf       	out	0x3d, r24	; 61
    8e14:	ed b7       	in	r30, 0x3d	; 61
    8e16:	fe b7       	in	r31, 0x3e	; 62
    8e18:	31 96       	adiw	r30, 0x01	; 1
    8e1a:	d8 01       	movw	r26, r16
    8e1c:	1a c0       	rjmp	.+52     	; 0x8e52 <Put_sDVal+0xca>
	}
	else{
		char Format[] = "%+ ld";
    8e1e:	9e 01       	movw	r18, r28
    8e20:	2f 5f       	subi	r18, 0xFF	; 255
    8e22:	3f 4f       	sbci	r19, 0xFF	; 255
    8e24:	d9 01       	movw	r26, r18
    8e26:	ea e5       	ldi	r30, 0x5A	; 90
    8e28:	f2 e0       	ldi	r31, 0x02	; 2
    8e2a:	86 e0       	ldi	r24, 0x06	; 6
    8e2c:	01 90       	ld	r0, Z+
    8e2e:	0d 92       	st	X+, r0
    8e30:	81 50       	subi	r24, 0x01	; 1
    8e32:	e1 f7       	brne	.-8      	; 0x8e2c <Put_sDVal+0xa4>
		Format[2] = '0'+Param->Size;
    8e34:	d8 01       	movw	r26, r16
    8e36:	13 96       	adiw	r26, 0x03	; 3
    8e38:	8c 91       	ld	r24, X
    8e3a:	13 97       	sbiw	r26, 0x03	; 3
    8e3c:	80 5d       	subi	r24, 0xD0	; 208
    8e3e:	8b 83       	std	Y+3, r24	; 0x03
		sprintf(Param->Pos, Format, Val);
    8e40:	ed b7       	in	r30, 0x3d	; 61
    8e42:	fe b7       	in	r31, 0x3e	; 62
    8e44:	38 97       	sbiw	r30, 0x08	; 8
    8e46:	0f b6       	in	r0, 0x3f	; 63
    8e48:	f8 94       	cli
    8e4a:	fe bf       	out	0x3e, r31	; 62
    8e4c:	0f be       	out	0x3f, r0	; 63
    8e4e:	ed bf       	out	0x3d, r30	; 61
    8e50:	31 96       	adiw	r30, 0x01	; 1
    8e52:	8d 91       	ld	r24, X+
    8e54:	9c 91       	ld	r25, X
    8e56:	ad b7       	in	r26, 0x3d	; 61
    8e58:	be b7       	in	r27, 0x3e	; 62
    8e5a:	12 96       	adiw	r26, 0x02	; 2
    8e5c:	9c 93       	st	X, r25
    8e5e:	8e 93       	st	-X, r24
    8e60:	11 97       	sbiw	r26, 0x01	; 1
    8e62:	33 83       	std	Z+3, r19	; 0x03
    8e64:	22 83       	std	Z+2, r18	; 0x02
    8e66:	c4 82       	std	Z+4, r12	; 0x04
    8e68:	d5 82       	std	Z+5, r13	; 0x05
    8e6a:	e6 82       	std	Z+6, r14	; 0x06
    8e6c:	f7 82       	std	Z+7, r15	; 0x07
    8e6e:	0e 94 e9 81 	call	0x103d2	; 0x103d2 <sprintf>
    8e72:	ed b7       	in	r30, 0x3d	; 61
    8e74:	fe b7       	in	r31, 0x3e	; 62
    8e76:	38 96       	adiw	r30, 0x08	; 8
    8e78:	0f b6       	in	r0, 0x3f	; 63
    8e7a:	f8 94       	cli
    8e7c:	fe bf       	out	0x3e, r31	; 62
    8e7e:	0f be       	out	0x3f, r0	; 63
    8e80:	ed bf       	out	0x3d, r30	; 61
	}
	//Delete sign if zero
	if(!Val)Param->Pos[Param->Size-2] = ' ';
    8e82:	c1 14       	cp	r12, r1
    8e84:	d1 04       	cpc	r13, r1
    8e86:	e1 04       	cpc	r14, r1
    8e88:	f1 04       	cpc	r15, r1
    8e8a:	59 f4       	brne	.+22     	; 0x8ea2 <Put_sDVal+0x11a>
    8e8c:	d8 01       	movw	r26, r16
    8e8e:	13 96       	adiw	r26, 0x03	; 3
    8e90:	8c 91       	ld	r24, X
    8e92:	13 97       	sbiw	r26, 0x03	; 3
    8e94:	ed 91       	ld	r30, X+
    8e96:	fc 91       	ld	r31, X
    8e98:	e8 0f       	add	r30, r24
    8e9a:	f1 1d       	adc	r31, r1
    8e9c:	32 97       	sbiw	r30, 0x02	; 2
    8e9e:	80 e2       	ldi	r24, 0x20	; 32
    8ea0:	80 83       	st	Z, r24

	if(Param->Prec){
    8ea2:	f8 01       	movw	r30, r16
    8ea4:	92 81       	ldd	r25, Z+2	; 0x02
    8ea6:	99 23       	and	r25, r25
    8ea8:	09 f4       	brne	.+2      	; 0x8eac <Put_sDVal+0x124>
    8eaa:	41 c0       	rjmp	.+130    	; 0x8f2e <Put_sDVal+0x1a6>
		//Insert decimal point
		for(uint8_t i=0; i< Param->Size - Param->Prec; i++){
    8eac:	83 81       	ldd	r24, Z+3	; 0x03
    8eae:	28 2f       	mov	r18, r24
    8eb0:	30 e0       	ldi	r19, 0x00	; 0
    8eb2:	29 1b       	sub	r18, r25
    8eb4:	31 09       	sbc	r19, r1
    8eb6:	12 16       	cp	r1, r18
    8eb8:	13 06       	cpc	r1, r19
    8eba:	d4 f4       	brge	.+52     	; 0x8ef0 <Put_sDVal+0x168>
    8ebc:	40 e0       	ldi	r20, 0x00	; 0
    8ebe:	80 e0       	ldi	r24, 0x00	; 0
    8ec0:	90 e0       	ldi	r25, 0x00	; 0
			Param->Pos[i] = Param->Pos[i+1];
    8ec2:	d8 01       	movw	r26, r16
    8ec4:	ed 91       	ld	r30, X+
    8ec6:	fc 91       	ld	r31, X
    8ec8:	11 97       	sbiw	r26, 0x01	; 1
    8eca:	e8 0f       	add	r30, r24
    8ecc:	f9 1f       	adc	r31, r25
    8ece:	81 81       	ldd	r24, Z+1	; 0x01
    8ed0:	80 83       	st	Z, r24
	//Delete sign if zero
	if(!Val)Param->Pos[Param->Size-2] = ' ';

	if(Param->Prec){
		//Insert decimal point
		for(uint8_t i=0; i< Param->Size - Param->Prec; i++){
    8ed2:	4f 5f       	subi	r20, 0xFF	; 255
    8ed4:	13 96       	adiw	r26, 0x03	; 3
    8ed6:	8c 91       	ld	r24, X
    8ed8:	13 97       	sbiw	r26, 0x03	; 3
    8eda:	28 2f       	mov	r18, r24
    8edc:	30 e0       	ldi	r19, 0x00	; 0
    8ede:	12 96       	adiw	r26, 0x02	; 2
    8ee0:	8c 91       	ld	r24, X
    8ee2:	28 1b       	sub	r18, r24
    8ee4:	31 09       	sbc	r19, r1
    8ee6:	84 2f       	mov	r24, r20
    8ee8:	90 e0       	ldi	r25, 0x00	; 0
    8eea:	82 17       	cp	r24, r18
    8eec:	93 07       	cpc	r25, r19
    8eee:	4c f3       	brlt	.-46     	; 0x8ec2 <Put_sDVal+0x13a>
			Param->Pos[i] = Param->Pos[i+1];
		}
		Param->Pos[Param->Size - Param->Prec-1] = '.';
    8ef0:	d8 01       	movw	r26, r16
    8ef2:	ed 91       	ld	r30, X+
    8ef4:	fc 91       	ld	r31, X
    8ef6:	11 97       	sbiw	r26, 0x01	; 1
    8ef8:	e2 0f       	add	r30, r18
    8efa:	f3 1f       	adc	r31, r19
    8efc:	31 97       	sbiw	r30, 0x01	; 1
    8efe:	8e e2       	ldi	r24, 0x2E	; 46
    8f00:	80 83       	st	Z, r24
		//Fill zeros and shift sign for correct view
		char c = Param->Pos[Param->Size - Param->Prec-2];
    8f02:	4d 91       	ld	r20, X+
    8f04:	5c 91       	ld	r21, X
    8f06:	11 97       	sbiw	r26, 0x01	; 1
    8f08:	13 96       	adiw	r26, 0x03	; 3
    8f0a:	9c 91       	ld	r25, X
    8f0c:	13 97       	sbiw	r26, 0x03	; 3
    8f0e:	e9 2f       	mov	r30, r25
    8f10:	f0 e0       	ldi	r31, 0x00	; 0
    8f12:	12 96       	adiw	r26, 0x02	; 2
    8f14:	8c 91       	ld	r24, X
    8f16:	e8 1b       	sub	r30, r24
    8f18:	f1 09       	sbc	r31, r1
    8f1a:	e4 0f       	add	r30, r20
    8f1c:	f5 1f       	adc	r31, r21
    8f1e:	32 97       	sbiw	r30, 0x02	; 2
    8f20:	e0 81       	ld	r30, Z
		if(c ==' ' || c =='+' || c =='-'){
    8f22:	e0 32       	cpi	r30, 0x20	; 32
    8f24:	99 f0       	breq	.+38     	; 0x8f4c <Put_sDVal+0x1c4>
    8f26:	eb 32       	cpi	r30, 0x2B	; 43
    8f28:	89 f0       	breq	.+34     	; 0x8f4c <Put_sDVal+0x1c4>
    8f2a:	ed 32       	cpi	r30, 0x2D	; 45
    8f2c:	79 f0       	breq	.+30     	; 0x8f4c <Put_sDVal+0x1c4>
				}
			}
		}
	}

}
    8f2e:	2d 96       	adiw	r28, 0x0d	; 13
    8f30:	0f b6       	in	r0, 0x3f	; 63
    8f32:	f8 94       	cli
    8f34:	de bf       	out	0x3e, r29	; 62
    8f36:	0f be       	out	0x3f, r0	; 63
    8f38:	cd bf       	out	0x3d, r28	; 61
    8f3a:	cf 91       	pop	r28
    8f3c:	df 91       	pop	r29
    8f3e:	1f 91       	pop	r17
    8f40:	0f 91       	pop	r16
    8f42:	ff 90       	pop	r15
    8f44:	ef 90       	pop	r14
    8f46:	df 90       	pop	r13
    8f48:	cf 90       	pop	r12
    8f4a:	08 95       	ret
		}
		Param->Pos[Param->Size - Param->Prec-1] = '.';
		//Fill zeros and shift sign for correct view
		char c = Param->Pos[Param->Size - Param->Prec-2];
		if(c ==' ' || c =='+' || c =='-'){
			for(uint8_t i=Param->Size-1; i>1; i--){
    8f4c:	e9 2f       	mov	r30, r25
    8f4e:	e1 50       	subi	r30, 0x01	; 1
    8f50:	e2 30       	cpi	r30, 0x02	; 2
    8f52:	68 f3       	brcs	.-38     	; 0x8f2e <Put_sDVal+0x1a6>
				if(Param->Pos[i] == ' '|| Param->Pos[i] == '+' || Param->Pos[i] == '-' ) Param->Pos[i]='0';
    8f54:	90 e3       	ldi	r25, 0x30	; 48
    8f56:	09 c0       	rjmp	.+18     	; 0x8f6a <Put_sDVal+0x1e2>
    8f58:	8b 32       	cpi	r24, 0x2B	; 43
    8f5a:	79 f0       	breq	.+30     	; 0x8f7a <Put_sDVal+0x1f2>
    8f5c:	8d 32       	cpi	r24, 0x2D	; 45
    8f5e:	69 f0       	breq	.+26     	; 0x8f7a <Put_sDVal+0x1f2>
				if(Param->Pos[i] == '.'){
    8f60:	8e 32       	cpi	r24, 0x2E	; 46
    8f62:	a9 f0       	breq	.+42     	; 0x8f8e <Put_sDVal+0x206>
		}
		Param->Pos[Param->Size - Param->Prec-1] = '.';
		//Fill zeros and shift sign for correct view
		char c = Param->Pos[Param->Size - Param->Prec-2];
		if(c ==' ' || c =='+' || c =='-'){
			for(uint8_t i=Param->Size-1; i>1; i--){
    8f64:	e1 50       	subi	r30, 0x01	; 1
    8f66:	e2 30       	cpi	r30, 0x02	; 2
    8f68:	10 f3       	brcs	.-60     	; 0x8f2e <Put_sDVal+0x1a6>
				if(Param->Pos[i] == ' '|| Param->Pos[i] == '+' || Param->Pos[i] == '-' ) Param->Pos[i]='0';
    8f6a:	2e 2f       	mov	r18, r30
    8f6c:	30 e0       	ldi	r19, 0x00	; 0
    8f6e:	da 01       	movw	r26, r20
    8f70:	a2 0f       	add	r26, r18
    8f72:	b3 1f       	adc	r27, r19
    8f74:	8c 91       	ld	r24, X
    8f76:	80 32       	cpi	r24, 0x20	; 32
    8f78:	79 f7       	brne	.-34     	; 0x8f58 <Put_sDVal+0x1d0>
    8f7a:	9c 93       	st	X, r25
    8f7c:	d8 01       	movw	r26, r16
    8f7e:	4d 91       	ld	r20, X+
    8f80:	5c 91       	ld	r21, X
    8f82:	da 01       	movw	r26, r20
    8f84:	a2 0f       	add	r26, r18
    8f86:	b3 1f       	adc	r27, r19
    8f88:	8c 91       	ld	r24, X
				if(Param->Pos[i] == '.'){
    8f8a:	8e 32       	cpi	r24, 0x2E	; 46
    8f8c:	59 f7       	brne	.-42     	; 0x8f64 <Put_sDVal+0x1dc>
					Param->Pos[i-1]='0';
    8f8e:	11 97       	sbiw	r26, 0x01	; 1
    8f90:	80 e3       	ldi	r24, 0x30	; 48
    8f92:	8c 93       	st	X, r24
					if(Val>0)Param->Pos[i-2]='+';
    8f94:	1c 14       	cp	r1, r12
    8f96:	1d 04       	cpc	r1, r13
    8f98:	1e 04       	cpc	r1, r14
    8f9a:	1f 04       	cpc	r1, r15
    8f9c:	44 f4       	brge	.+16     	; 0x8fae <Put_sDVal+0x226>
    8f9e:	d8 01       	movw	r26, r16
    8fa0:	ed 91       	ld	r30, X+
    8fa2:	fc 91       	ld	r31, X
    8fa4:	e2 0f       	add	r30, r18
    8fa6:	f3 1f       	adc	r31, r19
    8fa8:	32 97       	sbiw	r30, 0x02	; 2
    8faa:	8b e2       	ldi	r24, 0x2B	; 43
    8fac:	80 83       	st	Z, r24
					if(Val<0)Param->Pos[i-2]='-';
    8fae:	f7 fe       	sbrs	r15, 7
    8fb0:	be cf       	rjmp	.-132    	; 0x8f2e <Put_sDVal+0x1a6>
    8fb2:	d8 01       	movw	r26, r16
    8fb4:	ed 91       	ld	r30, X+
    8fb6:	fc 91       	ld	r31, X
    8fb8:	e2 0f       	add	r30, r18
    8fba:	f3 1f       	adc	r31, r19
    8fbc:	32 97       	sbiw	r30, 0x02	; 2
    8fbe:	8d e2       	ldi	r24, 0x2D	; 45
    8fc0:	80 83       	st	Z, r24
    8fc2:	b5 cf       	rjmp	.-150    	; 0x8f2e <Put_sDVal+0x1a6>
void
Put_sDVal(int32_t Val, T_Param *Param)
{
	uint32_t Idx = 0x80000000+Val;
	if(Param->Txt && Idx<2) {
		Param->Txt += Idx;
    8fc4:	88 0f       	add	r24, r24
    8fc6:	99 1f       	adc	r25, r25
    8fc8:	28 0f       	add	r18, r24
    8fca:	39 1f       	adc	r19, r25
    8fcc:	fa 01       	movw	r30, r20
    8fce:	35 83       	std	Z+5, r19	; 0x05
    8fd0:	24 83       	std	Z+4, r18	; 0x04
		PutEnum(Param);
    8fd2:	ca 01       	movw	r24, r20
    8fd4:	0e 94 24 42 	call	0x8448	; 0x8448 <PutEnum>
    8fd8:	aa cf       	rjmp	.-172    	; 0x8f2e <Put_sDVal+0x1a6>

00008fda <PutDVal>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// PutDVal - print unsigned Longint in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
PutDVal(uint32_t Val, T_Param *Param)
{
    8fda:	2f 92       	push	r2
    8fdc:	3f 92       	push	r3
    8fde:	4f 92       	push	r4
    8fe0:	5f 92       	push	r5
    8fe2:	6f 92       	push	r6
    8fe4:	7f 92       	push	r7
    8fe6:	8f 92       	push	r8
    8fe8:	9f 92       	push	r9
    8fea:	af 92       	push	r10
    8fec:	bf 92       	push	r11
    8fee:	cf 92       	push	r12
    8ff0:	df 92       	push	r13
    8ff2:	ef 92       	push	r14
    8ff4:	ff 92       	push	r15
    8ff6:	0f 93       	push	r16
    8ff8:	1f 93       	push	r17
    8ffa:	df 93       	push	r29
    8ffc:	cf 93       	push	r28
    8ffe:	cd b7       	in	r28, 0x3d	; 61
    9000:	de b7       	in	r29, 0x3e	; 62
    9002:	2b 97       	sbiw	r28, 0x0b	; 11
    9004:	0f b6       	in	r0, 0x3f	; 63
    9006:	f8 94       	cli
    9008:	de bf       	out	0x3e, r29	; 62
    900a:	0f be       	out	0x3f, r0	; 63
    900c:	cd bf       	out	0x3d, r28	; 61
    900e:	1b 01       	movw	r2, r22
    9010:	2c 01       	movw	r4, r24
    9012:	3a 01       	movw	r6, r20
	uint32_t Idx = 0xFFFFFFFF-Val;
	if(Param->Txt && Idx<2) {
    9014:	da 01       	movw	r26, r20
    9016:	14 96       	adiw	r26, 0x04	; 4
    9018:	2d 91       	ld	r18, X+
    901a:	3c 91       	ld	r19, X
    901c:	15 97       	sbiw	r26, 0x05	; 5
    901e:	21 15       	cp	r18, r1
    9020:	31 05       	cpc	r19, r1
    9022:	61 f0       	breq	.+24     	; 0x903c <PutDVal+0x62>
// PutDVal - print unsigned Longint in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
PutDVal(uint32_t Val, T_Param *Param)
{
	uint32_t Idx = 0xFFFFFFFF-Val;
    9024:	dc 01       	movw	r26, r24
    9026:	cb 01       	movw	r24, r22
    9028:	80 95       	com	r24
    902a:	90 95       	com	r25
    902c:	a0 95       	com	r26
    902e:	b0 95       	com	r27
	if(Param->Txt && Idx<2) {
    9030:	82 30       	cpi	r24, 0x02	; 2
    9032:	91 05       	cpc	r25, r1
    9034:	a1 05       	cpc	r26, r1
    9036:	b1 05       	cpc	r27, r1
    9038:	08 f4       	brcc	.+2      	; 0x903c <PutDVal+0x62>
    903a:	e5 c0       	rjmp	.+458    	; 0x9206 <PutDVal+0x22c>
		Param->Txt += Idx;
		PutEnum(Param);
		return;
	}

	if(Param->Size==10 && Param->Prec==0){
    903c:	d3 01       	movw	r26, r6
    903e:	13 96       	adiw	r26, 0x03	; 3
    9040:	8c 91       	ld	r24, X
    9042:	13 97       	sbiw	r26, 0x03	; 3
    9044:	8a 30       	cpi	r24, 0x0A	; 10
    9046:	09 f4       	brne	.+2      	; 0x904a <PutDVal+0x70>
    9048:	72 c0       	rjmp	.+228    	; 0x912e <PutDVal+0x154>
		sprintf(Param->Pos, "%10lu", Val);
		return;
	}
	char Format[] = "% lu.%. lu";
    904a:	de 01       	movw	r26, r28
    904c:	11 96       	adiw	r26, 0x01	; 1
    904e:	e6 e6       	ldi	r30, 0x66	; 102
    9050:	f2 e0       	ldi	r31, 0x02	; 2
    9052:	8b e0       	ldi	r24, 0x0B	; 11
    9054:	01 90       	ld	r0, Z+
    9056:	0d 92       	st	X+, r0
    9058:	81 50       	subi	r24, 0x01	; 1
    905a:	e1 f7       	brne	.-8      	; 0x9054 <PutDVal+0x7a>
	Format[1] = '0'+Param->Size;
    905c:	d3 01       	movw	r26, r6
    905e:	13 96       	adiw	r26, 0x03	; 3
    9060:	2c 91       	ld	r18, X
    9062:	13 97       	sbiw	r26, 0x03	; 3
    9064:	20 5d       	subi	r18, 0xD0	; 208
    9066:	2a 83       	std	Y+2, r18	; 0x02
	if(Param->Prec) {
    9068:	12 96       	adiw	r26, 0x02	; 2
    906a:	9c 91       	ld	r25, X
    906c:	99 23       	and	r25, r25
    906e:	09 f4       	brne	.+2      	; 0x9072 <PutDVal+0x98>
    9070:	a0 c0       	rjmp	.+320    	; 0x91b2 <PutDVal+0x1d8>
		Format[1] -= Param->Prec+1;
    9072:	89 2f       	mov	r24, r25
    9074:	80 95       	com	r24
    9076:	82 0f       	add	r24, r18
    9078:	8a 83       	std	Y+2, r24	; 0x02
		Format[7] = '0'+Param->Prec;
    907a:	90 5d       	subi	r25, 0xD0	; 208
    907c:	98 87       	std	Y+8, r25	; 0x08
    907e:	90 53       	subi	r25, 0x30	; 48
		uint32_t Div=PowL10(Param->Prec);
    9080:	09 2f       	mov	r16, r25
    9082:	f1 e0       	ldi	r31, 0x01	; 1
    9084:	8f 2e       	mov	r8, r31
    9086:	91 2c       	mov	r9, r1
    9088:	a1 2c       	mov	r10, r1
    908a:	b1 2c       	mov	r11, r1
		Pow *= 10;
    908c:	c5 01       	movw	r24, r10
    908e:	b4 01       	movw	r22, r8
    9090:	2a e0       	ldi	r18, 0x0A	; 10
    9092:	30 e0       	ldi	r19, 0x00	; 0
    9094:	40 e0       	ldi	r20, 0x00	; 0
    9096:	50 e0       	ldi	r21, 0x00	; 0
    9098:	0e 94 53 84 	call	0x108a6	; 0x108a6 <__mulsi3>
    909c:	4b 01       	movw	r8, r22
    909e:	5c 01       	movw	r10, r24
    90a0:	01 50       	subi	r16, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
	uint32_t Pow = 1;
	while(Exp--)
    90a2:	a1 f7       	brne	.-24     	; 0x908c <PutDVal+0xb2>
    90a4:	c2 01       	movw	r24, r4
    90a6:	b1 01       	movw	r22, r2
    90a8:	94 01       	movw	r18, r8
    90aa:	a5 01       	movw	r20, r10
    90ac:	0e 94 a5 84 	call	0x1094a	; 0x1094a <__udivmodsi4>
    90b0:	f6 2e       	mov	r15, r22
    90b2:	e7 2e       	mov	r14, r23
    90b4:	d8 2e       	mov	r13, r24
    90b6:	c9 2e       	mov	r12, r25
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
    90b8:	ed b7       	in	r30, 0x3d	; 61
    90ba:	fe b7       	in	r31, 0x3e	; 62
    90bc:	3c 97       	sbiw	r30, 0x0c	; 12
    90be:	0f b6       	in	r0, 0x3f	; 63
    90c0:	f8 94       	cli
    90c2:	fe bf       	out	0x3e, r31	; 62
    90c4:	0f be       	out	0x3f, r0	; 63
    90c6:	ed bf       	out	0x3d, r30	; 61
    90c8:	0d b7       	in	r16, 0x3d	; 61
    90ca:	1e b7       	in	r17, 0x3e	; 62
    90cc:	0f 5f       	subi	r16, 0xFF	; 255
    90ce:	1f 4f       	sbci	r17, 0xFF	; 255
    90d0:	d3 01       	movw	r26, r6
    90d2:	8d 91       	ld	r24, X+
    90d4:	9c 91       	ld	r25, X
    90d6:	92 83       	std	Z+2, r25	; 0x02
    90d8:	81 83       	std	Z+1, r24	; 0x01
    90da:	81 e0       	ldi	r24, 0x01	; 1
    90dc:	90 e0       	ldi	r25, 0x00	; 0
    90de:	8c 0f       	add	r24, r28
    90e0:	9d 1f       	adc	r25, r29
    90e2:	f8 01       	movw	r30, r16
    90e4:	93 83       	std	Z+3, r25	; 0x03
    90e6:	82 83       	std	Z+2, r24	; 0x02
    90e8:	c2 01       	movw	r24, r4
    90ea:	b1 01       	movw	r22, r2
    90ec:	a5 01       	movw	r20, r10
    90ee:	94 01       	movw	r18, r8
    90f0:	0e 94 a5 84 	call	0x1094a	; 0x1094a <__udivmodsi4>
    90f4:	d8 01       	movw	r26, r16
    90f6:	14 96       	adiw	r26, 0x04	; 4
    90f8:	2d 93       	st	X+, r18
    90fa:	3d 93       	st	X+, r19
    90fc:	4d 93       	st	X+, r20
    90fe:	5c 93       	st	X, r21
    9100:	17 97       	sbiw	r26, 0x07	; 7
    9102:	18 96       	adiw	r26, 0x08	; 8
    9104:	fc 92       	st	X, r15
    9106:	18 97       	sbiw	r26, 0x08	; 8
    9108:	19 96       	adiw	r26, 0x09	; 9
    910a:	ec 92       	st	X, r14
    910c:	19 97       	sbiw	r26, 0x09	; 9
    910e:	1a 96       	adiw	r26, 0x0a	; 10
    9110:	dc 92       	st	X, r13
    9112:	1a 97       	sbiw	r26, 0x0a	; 10
    9114:	1b 96       	adiw	r26, 0x0b	; 11
    9116:	cc 92       	st	X, r12
    9118:	0e 94 e9 81 	call	0x103d2	; 0x103d2 <sprintf>
    911c:	ed b7       	in	r30, 0x3d	; 61
    911e:	fe b7       	in	r31, 0x3e	; 62
    9120:	3c 96       	adiw	r30, 0x0c	; 12
    9122:	0f b6       	in	r0, 0x3f	; 63
    9124:	f8 94       	cli
    9126:	fe bf       	out	0x3e, r31	; 62
    9128:	0f be       	out	0x3f, r0	; 63
    912a:	ed bf       	out	0x3d, r30	; 61
    912c:	29 c0       	rjmp	.+82     	; 0x9180 <PutDVal+0x1a6>
		Param->Txt += Idx;
		PutEnum(Param);
		return;
	}

	if(Param->Size==10 && Param->Prec==0){
    912e:	12 96       	adiw	r26, 0x02	; 2
    9130:	8c 91       	ld	r24, X
    9132:	12 97       	sbiw	r26, 0x02	; 2
    9134:	88 23       	and	r24, r24
    9136:	09 f0       	breq	.+2      	; 0x913a <PutDVal+0x160>
    9138:	88 cf       	rjmp	.-240    	; 0x904a <PutDVal+0x70>
		sprintf(Param->Pos, "%10lu", Val);
    913a:	ed b7       	in	r30, 0x3d	; 61
    913c:	fe b7       	in	r31, 0x3e	; 62
    913e:	38 97       	sbiw	r30, 0x08	; 8
    9140:	0f b6       	in	r0, 0x3f	; 63
    9142:	f8 94       	cli
    9144:	fe bf       	out	0x3e, r31	; 62
    9146:	0f be       	out	0x3f, r0	; 63
    9148:	ed bf       	out	0x3d, r30	; 61
    914a:	31 96       	adiw	r30, 0x01	; 1
    914c:	8d 91       	ld	r24, X+
    914e:	9c 91       	ld	r25, X
    9150:	ad b7       	in	r26, 0x3d	; 61
    9152:	be b7       	in	r27, 0x3e	; 62
    9154:	12 96       	adiw	r26, 0x02	; 2
    9156:	9c 93       	st	X, r25
    9158:	8e 93       	st	-X, r24
    915a:	11 97       	sbiw	r26, 0x01	; 1
    915c:	80 e6       	ldi	r24, 0x60	; 96
    915e:	92 e0       	ldi	r25, 0x02	; 2
    9160:	93 83       	std	Z+3, r25	; 0x03
    9162:	82 83       	std	Z+2, r24	; 0x02
    9164:	24 82       	std	Z+4, r2	; 0x04
    9166:	35 82       	std	Z+5, r3	; 0x05
    9168:	46 82       	std	Z+6, r4	; 0x06
    916a:	57 82       	std	Z+7, r5	; 0x07
    916c:	0e 94 e9 81 	call	0x103d2	; 0x103d2 <sprintf>
    9170:	ed b7       	in	r30, 0x3d	; 61
    9172:	fe b7       	in	r31, 0x3e	; 62
    9174:	38 96       	adiw	r30, 0x08	; 8
    9176:	0f b6       	in	r0, 0x3f	; 63
    9178:	f8 94       	cli
    917a:	fe bf       	out	0x3e, r31	; 62
    917c:	0f be       	out	0x3f, r0	; 63
    917e:	ed bf       	out	0x3d, r30	; 61
	}
	else {
		Format[4] = '\0';
		sprintf(Param->Pos, Format, Val);
	}
}
    9180:	2b 96       	adiw	r28, 0x0b	; 11
    9182:	0f b6       	in	r0, 0x3f	; 63
    9184:	f8 94       	cli
    9186:	de bf       	out	0x3e, r29	; 62
    9188:	0f be       	out	0x3f, r0	; 63
    918a:	cd bf       	out	0x3d, r28	; 61
    918c:	cf 91       	pop	r28
    918e:	df 91       	pop	r29
    9190:	1f 91       	pop	r17
    9192:	0f 91       	pop	r16
    9194:	ff 90       	pop	r15
    9196:	ef 90       	pop	r14
    9198:	df 90       	pop	r13
    919a:	cf 90       	pop	r12
    919c:	bf 90       	pop	r11
    919e:	af 90       	pop	r10
    91a0:	9f 90       	pop	r9
    91a2:	8f 90       	pop	r8
    91a4:	7f 90       	pop	r7
    91a6:	6f 90       	pop	r6
    91a8:	5f 90       	pop	r5
    91aa:	4f 90       	pop	r4
    91ac:	3f 90       	pop	r3
    91ae:	2f 90       	pop	r2
    91b0:	08 95       	ret
		Format[7] = '0'+Param->Prec;
		uint32_t Div=PowL10(Param->Prec);
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
	}
	else {
		Format[4] = '\0';
    91b2:	1d 82       	std	Y+5, r1	; 0x05
		sprintf(Param->Pos, Format, Val);
    91b4:	8d b7       	in	r24, 0x3d	; 61
    91b6:	9e b7       	in	r25, 0x3e	; 62
    91b8:	08 97       	sbiw	r24, 0x08	; 8
    91ba:	0f b6       	in	r0, 0x3f	; 63
    91bc:	f8 94       	cli
    91be:	9e bf       	out	0x3e, r25	; 62
    91c0:	0f be       	out	0x3f, r0	; 63
    91c2:	8d bf       	out	0x3d, r24	; 61
    91c4:	ed b7       	in	r30, 0x3d	; 61
    91c6:	fe b7       	in	r31, 0x3e	; 62
    91c8:	31 96       	adiw	r30, 0x01	; 1
    91ca:	d3 01       	movw	r26, r6
    91cc:	8d 91       	ld	r24, X+
    91ce:	9c 91       	ld	r25, X
    91d0:	ad b7       	in	r26, 0x3d	; 61
    91d2:	be b7       	in	r27, 0x3e	; 62
    91d4:	12 96       	adiw	r26, 0x02	; 2
    91d6:	9c 93       	st	X, r25
    91d8:	8e 93       	st	-X, r24
    91da:	11 97       	sbiw	r26, 0x01	; 1
    91dc:	81 e0       	ldi	r24, 0x01	; 1
    91de:	90 e0       	ldi	r25, 0x00	; 0
    91e0:	8c 0f       	add	r24, r28
    91e2:	9d 1f       	adc	r25, r29
    91e4:	93 83       	std	Z+3, r25	; 0x03
    91e6:	82 83       	std	Z+2, r24	; 0x02
    91e8:	24 82       	std	Z+4, r2	; 0x04
    91ea:	35 82       	std	Z+5, r3	; 0x05
    91ec:	46 82       	std	Z+6, r4	; 0x06
    91ee:	57 82       	std	Z+7, r5	; 0x07
    91f0:	0e 94 e9 81 	call	0x103d2	; 0x103d2 <sprintf>
    91f4:	ad b7       	in	r26, 0x3d	; 61
    91f6:	be b7       	in	r27, 0x3e	; 62
    91f8:	18 96       	adiw	r26, 0x08	; 8
    91fa:	0f b6       	in	r0, 0x3f	; 63
    91fc:	f8 94       	cli
    91fe:	be bf       	out	0x3e, r27	; 62
    9200:	0f be       	out	0x3f, r0	; 63
    9202:	ad bf       	out	0x3d, r26	; 61
    9204:	bd cf       	rjmp	.-134    	; 0x9180 <PutDVal+0x1a6>
void
PutDVal(uint32_t Val, T_Param *Param)
{
	uint32_t Idx = 0xFFFFFFFF-Val;
	if(Param->Txt && Idx<2) {
		Param->Txt += Idx;
    9206:	88 0f       	add	r24, r24
    9208:	99 1f       	adc	r25, r25
    920a:	28 0f       	add	r18, r24
    920c:	39 1f       	adc	r19, r25
    920e:	fa 01       	movw	r30, r20
    9210:	35 83       	std	Z+5, r19	; 0x05
    9212:	24 83       	std	Z+4, r18	; 0x04
		PutEnum(Param);
    9214:	ca 01       	movw	r24, r20
    9216:	0e 94 24 42 	call	0x8448	; 0x8448 <PutEnum>
    921a:	b2 cf       	rjmp	.-156    	; 0x9180 <PutDVal+0x1a6>

0000921c <Put_zVal_h>:
	}
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_zVal_h(uint32_t Val, char Type, T_Param *Param)
{
    921c:	1f 93       	push	r17
    921e:	17 2f       	mov	r17, r23
    9220:	58 2f       	mov	r21, r24
    9222:	79 2f       	mov	r23, r25
    9224:	d9 01       	movw	r26, r18
	if(Type=='b') sprintf(Param->Pos, "%02hx", (uint8_t)Val);
    9226:	42 36       	cpi	r20, 0x62	; 98
    9228:	71 f1       	breq	.+92     	; 0x9286 <Put_zVal_h+0x6a>
	if(Type=='w') sprintf(Param->Pos, "%04x", (uint16_t)Val);
    922a:	47 37       	cpi	r20, 0x77	; 119
    922c:	09 f4       	brne	.+2      	; 0x9230 <Put_zVal_h+0x14>
    922e:	4a c0       	rjmp	.+148    	; 0x92c4 <Put_zVal_h+0xa8>
	if(Type=='l') sprintf(Param->Pos, "%08lx", Val);
    9230:	4c 36       	cpi	r20, 0x6C	; 108
    9232:	11 f0       	breq	.+4      	; 0x9238 <Put_zVal_h+0x1c>
}
    9234:	1f 91       	pop	r17
    9236:	08 95       	ret
void
Put_zVal_h(uint32_t Val, char Type, T_Param *Param)
{
	if(Type=='b') sprintf(Param->Pos, "%02hx", (uint8_t)Val);
	if(Type=='w') sprintf(Param->Pos, "%04x", (uint16_t)Val);
	if(Type=='l') sprintf(Param->Pos, "%08lx", Val);
    9238:	8d b7       	in	r24, 0x3d	; 61
    923a:	9e b7       	in	r25, 0x3e	; 62
    923c:	08 97       	sbiw	r24, 0x08	; 8
    923e:	0f b6       	in	r0, 0x3f	; 63
    9240:	f8 94       	cli
    9242:	9e bf       	out	0x3e, r25	; 62
    9244:	0f be       	out	0x3f, r0	; 63
    9246:	8d bf       	out	0x3d, r24	; 61
    9248:	ed b7       	in	r30, 0x3d	; 61
    924a:	fe b7       	in	r31, 0x3e	; 62
    924c:	31 96       	adiw	r30, 0x01	; 1
    924e:	8d 91       	ld	r24, X+
    9250:	9c 91       	ld	r25, X
    9252:	ad b7       	in	r26, 0x3d	; 61
    9254:	be b7       	in	r27, 0x3e	; 62
    9256:	12 96       	adiw	r26, 0x02	; 2
    9258:	9c 93       	st	X, r25
    925a:	8e 93       	st	-X, r24
    925c:	11 97       	sbiw	r26, 0x01	; 1
    925e:	8c e7       	ldi	r24, 0x7C	; 124
    9260:	92 e0       	ldi	r25, 0x02	; 2
    9262:	93 83       	std	Z+3, r25	; 0x03
    9264:	82 83       	std	Z+2, r24	; 0x02
    9266:	64 83       	std	Z+4, r22	; 0x04
    9268:	15 83       	std	Z+5, r17	; 0x05
    926a:	56 83       	std	Z+6, r21	; 0x06
    926c:	77 83       	std	Z+7, r23	; 0x07
    926e:	0e 94 e9 81 	call	0x103d2	; 0x103d2 <sprintf>
    9272:	8d b7       	in	r24, 0x3d	; 61
    9274:	9e b7       	in	r25, 0x3e	; 62
    9276:	08 96       	adiw	r24, 0x08	; 8
    9278:	0f b6       	in	r0, 0x3f	; 63
    927a:	f8 94       	cli
    927c:	9e bf       	out	0x3e, r25	; 62
    927e:	0f be       	out	0x3f, r0	; 63
    9280:	8d bf       	out	0x3d, r24	; 61
}
    9282:	1f 91       	pop	r17
    9284:	08 95       	ret
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_zVal_h(uint32_t Val, char Type, T_Param *Param)
{
	if(Type=='b') sprintf(Param->Pos, "%02hx", (uint8_t)Val);
    9286:	00 d0       	rcall	.+0      	; 0x9288 <Put_zVal_h+0x6c>
    9288:	00 d0       	rcall	.+0      	; 0x928a <Put_zVal_h+0x6e>
    928a:	ed b7       	in	r30, 0x3d	; 61
    928c:	fe b7       	in	r31, 0x3e	; 62
    928e:	31 96       	adiw	r30, 0x01	; 1
    9290:	8d 91       	ld	r24, X+
    9292:	9c 91       	ld	r25, X
    9294:	ad b7       	in	r26, 0x3d	; 61
    9296:	be b7       	in	r27, 0x3e	; 62
    9298:	12 96       	adiw	r26, 0x02	; 2
    929a:	9c 93       	st	X, r25
    929c:	8e 93       	st	-X, r24
    929e:	11 97       	sbiw	r26, 0x01	; 1
    92a0:	81 e7       	ldi	r24, 0x71	; 113
    92a2:	92 e0       	ldi	r25, 0x02	; 2
    92a4:	93 83       	std	Z+3, r25	; 0x03
    92a6:	82 83       	std	Z+2, r24	; 0x02
    92a8:	64 83       	std	Z+4, r22	; 0x04
    92aa:	15 82       	std	Z+5, r1	; 0x05
    92ac:	0e 94 e9 81 	call	0x103d2	; 0x103d2 <sprintf>
    92b0:	8d b7       	in	r24, 0x3d	; 61
    92b2:	9e b7       	in	r25, 0x3e	; 62
    92b4:	06 96       	adiw	r24, 0x06	; 6
    92b6:	0f b6       	in	r0, 0x3f	; 63
    92b8:	f8 94       	cli
    92ba:	9e bf       	out	0x3e, r25	; 62
    92bc:	0f be       	out	0x3f, r0	; 63
    92be:	8d bf       	out	0x3d, r24	; 61
	if(Type=='w') sprintf(Param->Pos, "%04x", (uint16_t)Val);
	if(Type=='l') sprintf(Param->Pos, "%08lx", Val);
}
    92c0:	1f 91       	pop	r17
    92c2:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_zVal_h(uint32_t Val, char Type, T_Param *Param)
{
	if(Type=='b') sprintf(Param->Pos, "%02hx", (uint8_t)Val);
	if(Type=='w') sprintf(Param->Pos, "%04x", (uint16_t)Val);
    92c4:	00 d0       	rcall	.+0      	; 0x92c6 <Put_zVal_h+0xaa>
    92c6:	00 d0       	rcall	.+0      	; 0x92c8 <Put_zVal_h+0xac>
    92c8:	ed b7       	in	r30, 0x3d	; 61
    92ca:	fe b7       	in	r31, 0x3e	; 62
    92cc:	31 96       	adiw	r30, 0x01	; 1
    92ce:	8d 91       	ld	r24, X+
    92d0:	9c 91       	ld	r25, X
    92d2:	ad b7       	in	r26, 0x3d	; 61
    92d4:	be b7       	in	r27, 0x3e	; 62
    92d6:	12 96       	adiw	r26, 0x02	; 2
    92d8:	9c 93       	st	X, r25
    92da:	8e 93       	st	-X, r24
    92dc:	11 97       	sbiw	r26, 0x01	; 1
    92de:	87 e7       	ldi	r24, 0x77	; 119
    92e0:	92 e0       	ldi	r25, 0x02	; 2
    92e2:	93 83       	std	Z+3, r25	; 0x03
    92e4:	82 83       	std	Z+2, r24	; 0x02
    92e6:	64 83       	std	Z+4, r22	; 0x04
    92e8:	15 83       	std	Z+5, r17	; 0x05
    92ea:	0e 94 e9 81 	call	0x103d2	; 0x103d2 <sprintf>
    92ee:	8d b7       	in	r24, 0x3d	; 61
    92f0:	9e b7       	in	r25, 0x3e	; 62
    92f2:	06 96       	adiw	r24, 0x06	; 6
    92f4:	0f b6       	in	r0, 0x3f	; 63
    92f6:	f8 94       	cli
    92f8:	9e bf       	out	0x3e, r25	; 62
    92fa:	0f be       	out	0x3f, r0	; 63
    92fc:	8d bf       	out	0x3d, r24	; 61
	if(Type=='l') sprintf(Param->Pos, "%08lx", Val);
}
    92fe:	1f 91       	pop	r17
    9300:	08 95       	ret

00009302 <Put_zVal>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_zVal(uint16_t Val, char Type, T_Param *Param)
{
    9302:	af 92       	push	r10
    9304:	bf 92       	push	r11
    9306:	cf 92       	push	r12
    9308:	df 92       	push	r13
    930a:	ef 92       	push	r14
    930c:	ff 92       	push	r15
    930e:	0f 93       	push	r16
    9310:	1f 93       	push	r17
    9312:	df 93       	push	r29
    9314:	cf 93       	push	r28
    9316:	cd b7       	in	r28, 0x3d	; 61
    9318:	de b7       	in	r29, 0x3e	; 62
    931a:	2a 97       	sbiw	r28, 0x0a	; 10
    931c:	0f b6       	in	r0, 0x3f	; 63
    931e:	f8 94       	cli
    9320:	de bf       	out	0x3e, r29	; 62
    9322:	0f be       	out	0x3f, r0	; 63
    9324:	cd bf       	out	0x3d, r28	; 61
    9326:	6c 01       	movw	r12, r24
    9328:	7a 01       	movw	r14, r20
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
    932a:	67 37       	cpi	r22, 0x77	; 119
    932c:	09 f4       	brne	.+2      	; 0x9330 <Put_zVal+0x2e>
    932e:	79 c0       	rjmp	.+242    	; 0x9422 <Put_zVal+0x120>
    9330:	8f ef       	ldi	r24, 0xFF	; 255
    9332:	90 e0       	ldi	r25, 0x00	; 0
	if(Param->Txt && Idx<2) {
    9334:	d7 01       	movw	r26, r14
    9336:	14 96       	adiw	r26, 0x04	; 4
    9338:	2d 91       	ld	r18, X+
    933a:	3c 91       	ld	r19, X
    933c:	15 97       	sbiw	r26, 0x05	; 5
    933e:	21 15       	cp	r18, r1
    9340:	31 05       	cpc	r19, r1
    9342:	31 f0       	breq	.+12     	; 0x9350 <Put_zVal+0x4e>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_zVal(uint16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
    9344:	8c 19       	sub	r24, r12
    9346:	9d 09       	sbc	r25, r13
	if(Param->Txt && Idx<2) {
    9348:	82 30       	cpi	r24, 0x02	; 2
    934a:	91 05       	cpc	r25, r1
    934c:	08 f4       	brcc	.+2      	; 0x9350 <Put_zVal+0x4e>
    934e:	8a c0       	rjmp	.+276    	; 0x9464 <Put_zVal+0x162>
		Param->Txt += Idx;
		PutEnum(Param);
		return;
	}
	char Format[] = "%0 u.%. u";
    9350:	5e 01       	movw	r10, r28
    9352:	08 94       	sec
    9354:	a1 1c       	adc	r10, r1
    9356:	b1 1c       	adc	r11, r1
    9358:	d5 01       	movw	r26, r10
    935a:	e2 e8       	ldi	r30, 0x82	; 130
    935c:	f2 e0       	ldi	r31, 0x02	; 2
    935e:	8a e0       	ldi	r24, 0x0A	; 10
    9360:	01 90       	ld	r0, Z+
    9362:	0d 92       	st	X+, r0
    9364:	81 50       	subi	r24, 0x01	; 1
    9366:	e1 f7       	brne	.-8      	; 0x9360 <Put_zVal+0x5e>
	Format[2] = '0'+Param->Size;
    9368:	f7 01       	movw	r30, r14
    936a:	23 81       	ldd	r18, Z+3	; 0x03
    936c:	20 5d       	subi	r18, 0xD0	; 208
    936e:	2b 83       	std	Y+3, r18	; 0x03
	if(Param->Prec) {
    9370:	92 81       	ldd	r25, Z+2	; 0x02
    9372:	99 23       	and	r25, r25
    9374:	09 f4       	brne	.+2      	; 0x9378 <Put_zVal+0x76>
    9376:	58 c0       	rjmp	.+176    	; 0x9428 <Put_zVal+0x126>
		Format[2] -= Param->Prec+1;
    9378:	89 2f       	mov	r24, r25
    937a:	80 95       	com	r24
    937c:	82 0f       	add	r24, r18
    937e:	8b 83       	std	Y+3, r24	; 0x03
		Format[7] = '0'+Param->Prec;
    9380:	90 5d       	subi	r25, 0xD0	; 208
    9382:	98 87       	std	Y+8, r25	; 0x08
    9384:	90 53       	subi	r25, 0x30	; 48
		uint16_t Div=Pow10(Param->Prec);
    9386:	29 2f       	mov	r18, r25
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    9388:	01 e0       	ldi	r16, 0x01	; 1
    938a:	10 e0       	ldi	r17, 0x00	; 0
		Pow *= 10;
    938c:	c8 01       	movw	r24, r16
    938e:	88 0f       	add	r24, r24
    9390:	99 1f       	adc	r25, r25
    9392:	00 0f       	add	r16, r16
    9394:	11 1f       	adc	r17, r17
    9396:	00 0f       	add	r16, r16
    9398:	11 1f       	adc	r17, r17
    939a:	00 0f       	add	r16, r16
    939c:	11 1f       	adc	r17, r17
    939e:	08 0f       	add	r16, r24
    93a0:	19 1f       	adc	r17, r25
    93a2:	21 50       	subi	r18, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    93a4:	99 f7       	brne	.-26     	; 0x938c <Put_zVal+0x8a>
    93a6:	c6 01       	movw	r24, r12
    93a8:	b8 01       	movw	r22, r16
    93aa:	0e 94 7e 84 	call	0x108fc	; 0x108fc <__udivmodhi4>
    93ae:	9c 01       	movw	r18, r24
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
    93b0:	8d b7       	in	r24, 0x3d	; 61
    93b2:	9e b7       	in	r25, 0x3e	; 62
    93b4:	08 97       	sbiw	r24, 0x08	; 8
    93b6:	0f b6       	in	r0, 0x3f	; 63
    93b8:	f8 94       	cli
    93ba:	9e bf       	out	0x3e, r25	; 62
    93bc:	0f be       	out	0x3f, r0	; 63
    93be:	8d bf       	out	0x3d, r24	; 61
    93c0:	ed b7       	in	r30, 0x3d	; 61
    93c2:	fe b7       	in	r31, 0x3e	; 62
    93c4:	31 96       	adiw	r30, 0x01	; 1
    93c6:	d7 01       	movw	r26, r14
    93c8:	8d 91       	ld	r24, X+
    93ca:	9c 91       	ld	r25, X
    93cc:	ad b7       	in	r26, 0x3d	; 61
    93ce:	be b7       	in	r27, 0x3e	; 62
    93d0:	12 96       	adiw	r26, 0x02	; 2
    93d2:	9c 93       	st	X, r25
    93d4:	8e 93       	st	-X, r24
    93d6:	11 97       	sbiw	r26, 0x01	; 1
    93d8:	b3 82       	std	Z+3, r11	; 0x03
    93da:	a2 82       	std	Z+2, r10	; 0x02
    93dc:	c6 01       	movw	r24, r12
    93de:	b8 01       	movw	r22, r16
    93e0:	0e 94 7e 84 	call	0x108fc	; 0x108fc <__udivmodhi4>
    93e4:	75 83       	std	Z+5, r23	; 0x05
    93e6:	64 83       	std	Z+4, r22	; 0x04
    93e8:	26 83       	std	Z+6, r18	; 0x06
    93ea:	37 83       	std	Z+7, r19	; 0x07
    93ec:	0e 94 e9 81 	call	0x103d2	; 0x103d2 <sprintf>
    93f0:	ed b7       	in	r30, 0x3d	; 61
    93f2:	fe b7       	in	r31, 0x3e	; 62
    93f4:	38 96       	adiw	r30, 0x08	; 8
    93f6:	0f b6       	in	r0, 0x3f	; 63
    93f8:	f8 94       	cli
    93fa:	fe bf       	out	0x3e, r31	; 62
    93fc:	0f be       	out	0x3f, r0	; 63
    93fe:	ed bf       	out	0x3d, r30	; 61
	}
	else {
		Format[4] = '\0';
		sprintf(Param->Pos, Format, Val);
	}
}
    9400:	2a 96       	adiw	r28, 0x0a	; 10
    9402:	0f b6       	in	r0, 0x3f	; 63
    9404:	f8 94       	cli
    9406:	de bf       	out	0x3e, r29	; 62
    9408:	0f be       	out	0x3f, r0	; 63
    940a:	cd bf       	out	0x3d, r28	; 61
    940c:	cf 91       	pop	r28
    940e:	df 91       	pop	r29
    9410:	1f 91       	pop	r17
    9412:	0f 91       	pop	r16
    9414:	ff 90       	pop	r15
    9416:	ef 90       	pop	r14
    9418:	df 90       	pop	r13
    941a:	cf 90       	pop	r12
    941c:	bf 90       	pop	r11
    941e:	af 90       	pop	r10
    9420:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_zVal(uint16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
    9422:	8f ef       	ldi	r24, 0xFF	; 255
    9424:	9f ef       	ldi	r25, 0xFF	; 255
    9426:	86 cf       	rjmp	.-244    	; 0x9334 <Put_zVal+0x32>
		Format[7] = '0'+Param->Prec;
		uint16_t Div=Pow10(Param->Prec);
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
	}
	else {
		Format[4] = '\0';
    9428:	1d 82       	std	Y+5, r1	; 0x05
		sprintf(Param->Pos, Format, Val);
    942a:	00 d0       	rcall	.+0      	; 0x942c <Put_zVal+0x12a>
    942c:	00 d0       	rcall	.+0      	; 0x942e <Put_zVal+0x12c>
    942e:	ed b7       	in	r30, 0x3d	; 61
    9430:	fe b7       	in	r31, 0x3e	; 62
    9432:	31 96       	adiw	r30, 0x01	; 1
    9434:	d7 01       	movw	r26, r14
    9436:	8d 91       	ld	r24, X+
    9438:	9c 91       	ld	r25, X
    943a:	ad b7       	in	r26, 0x3d	; 61
    943c:	be b7       	in	r27, 0x3e	; 62
    943e:	12 96       	adiw	r26, 0x02	; 2
    9440:	9c 93       	st	X, r25
    9442:	8e 93       	st	-X, r24
    9444:	11 97       	sbiw	r26, 0x01	; 1
    9446:	b3 82       	std	Z+3, r11	; 0x03
    9448:	a2 82       	std	Z+2, r10	; 0x02
    944a:	d5 82       	std	Z+5, r13	; 0x05
    944c:	c4 82       	std	Z+4, r12	; 0x04
    944e:	0e 94 e9 81 	call	0x103d2	; 0x103d2 <sprintf>
    9452:	ed b7       	in	r30, 0x3d	; 61
    9454:	fe b7       	in	r31, 0x3e	; 62
    9456:	36 96       	adiw	r30, 0x06	; 6
    9458:	0f b6       	in	r0, 0x3f	; 63
    945a:	f8 94       	cli
    945c:	fe bf       	out	0x3e, r31	; 62
    945e:	0f be       	out	0x3f, r0	; 63
    9460:	ed bf       	out	0x3d, r30	; 61
    9462:	ce cf       	rjmp	.-100    	; 0x9400 <Put_zVal+0xfe>
void
Put_zVal(uint16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
	if(Param->Txt && Idx<2) {
		Param->Txt += Idx;
    9464:	88 0f       	add	r24, r24
    9466:	99 1f       	adc	r25, r25
    9468:	28 0f       	add	r18, r24
    946a:	39 1f       	adc	r19, r25
    946c:	15 96       	adiw	r26, 0x05	; 5
    946e:	3c 93       	st	X, r19
    9470:	2e 93       	st	-X, r18
    9472:	14 97       	sbiw	r26, 0x04	; 4
		PutEnum(Param);
    9474:	c7 01       	movw	r24, r14
    9476:	0e 94 24 42 	call	0x8448	; 0x8448 <PutEnum>
    947a:	c2 cf       	rjmp	.-124    	; 0x9400 <Put_zVal+0xfe>

0000947c <Put_sVal>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_sVal(int16_t Val, char Type, T_Param *Param)
{
    947c:	af 92       	push	r10
    947e:	bf 92       	push	r11
    9480:	cf 92       	push	r12
    9482:	df 92       	push	r13
    9484:	ef 92       	push	r14
    9486:	ff 92       	push	r15
    9488:	0f 93       	push	r16
    948a:	1f 93       	push	r17
    948c:	df 93       	push	r29
    948e:	cf 93       	push	r28
    9490:	cd b7       	in	r28, 0x3d	; 61
    9492:	de b7       	in	r29, 0x3e	; 62
    9494:	2a 97       	sbiw	r28, 0x0a	; 10
    9496:	0f b6       	in	r0, 0x3f	; 63
    9498:	f8 94       	cli
    949a:	de bf       	out	0x3e, r29	; 62
    949c:	0f be       	out	0x3f, r0	; 63
    949e:	cd bf       	out	0x3d, r28	; 61
    94a0:	6c 01       	movw	r12, r24
    94a2:	7a 01       	movw	r14, r20
	uint16_t Idx = (Type=='w'?0x8000:0x80)+Val;
    94a4:	67 37       	cpi	r22, 0x77	; 119
    94a6:	09 f4       	brne	.+2      	; 0x94aa <Put_sVal+0x2e>
    94a8:	81 c0       	rjmp	.+258    	; 0x95ac <Put_sVal+0x130>
    94aa:	80 e8       	ldi	r24, 0x80	; 128
    94ac:	90 e0       	ldi	r25, 0x00	; 0
	if(Param->Txt && Idx<2) {
    94ae:	d7 01       	movw	r26, r14
    94b0:	14 96       	adiw	r26, 0x04	; 4
    94b2:	2d 91       	ld	r18, X+
    94b4:	3c 91       	ld	r19, X
    94b6:	15 97       	sbiw	r26, 0x05	; 5
    94b8:	21 15       	cp	r18, r1
    94ba:	31 05       	cpc	r19, r1
    94bc:	31 f0       	breq	.+12     	; 0x94ca <Put_sVal+0x4e>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_sVal(int16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0x8000:0x80)+Val;
    94be:	8c 0d       	add	r24, r12
    94c0:	9d 1d       	adc	r25, r13
	if(Param->Txt && Idx<2) {
    94c2:	82 30       	cpi	r24, 0x02	; 2
    94c4:	91 05       	cpc	r25, r1
    94c6:	08 f4       	brcc	.+2      	; 0x94ca <Put_sVal+0x4e>
    94c8:	ac c0       	rjmp	.+344    	; 0x9622 <Put_sVal+0x1a6>
		Param->Txt += Idx;
		PutEnum(Param);
		return;
	}
	char Format[] = "%+ d.%. u";
    94ca:	5e 01       	movw	r10, r28
    94cc:	08 94       	sec
    94ce:	a1 1c       	adc	r10, r1
    94d0:	b1 1c       	adc	r11, r1
    94d2:	d5 01       	movw	r26, r10
    94d4:	ec e8       	ldi	r30, 0x8C	; 140
    94d6:	f2 e0       	ldi	r31, 0x02	; 2
    94d8:	8a e0       	ldi	r24, 0x0A	; 10
    94da:	01 90       	ld	r0, Z+
    94dc:	0d 92       	st	X+, r0
    94de:	81 50       	subi	r24, 0x01	; 1
    94e0:	e1 f7       	brne	.-8      	; 0x94da <Put_sVal+0x5e>
	if(Val==0)
    94e2:	c1 14       	cp	r12, r1
    94e4:	d1 04       	cpc	r13, r1
    94e6:	09 f4       	brne	.+2      	; 0x94ea <Put_sVal+0x6e>
    94e8:	64 c0       	rjmp	.+200    	; 0x95b2 <Put_sVal+0x136>
		Format[1] = ' ';
	Format[2] = '0'+Param->Size;
    94ea:	f7 01       	movw	r30, r14
    94ec:	23 81       	ldd	r18, Z+3	; 0x03
    94ee:	20 5d       	subi	r18, 0xD0	; 208
    94f0:	2b 83       	std	Y+3, r18	; 0x03
	if(Param->Prec) {
    94f2:	92 81       	ldd	r25, Z+2	; 0x02
    94f4:	99 23       	and	r25, r25
    94f6:	09 f4       	brne	.+2      	; 0x94fa <Put_sVal+0x7e>
    94f8:	66 c0       	rjmp	.+204    	; 0x95c6 <Put_sVal+0x14a>
		Format[2] -= Param->Prec+1;
    94fa:	89 2f       	mov	r24, r25
    94fc:	80 95       	com	r24
    94fe:	82 0f       	add	r24, r18
    9500:	8b 83       	std	Y+3, r24	; 0x03
		Format[7] = '0'+Param->Prec;
    9502:	90 5d       	subi	r25, 0xD0	; 208
    9504:	98 87       	std	Y+8, r25	; 0x08
    9506:	90 53       	subi	r25, 0x30	; 48
		int16_t Div=Pow10(Param->Prec);
    9508:	29 2f       	mov	r18, r25
    950a:	01 e0       	ldi	r16, 0x01	; 1
    950c:	10 e0       	ldi	r17, 0x00	; 0
		Pow *= 10;
    950e:	c8 01       	movw	r24, r16
    9510:	88 0f       	add	r24, r24
    9512:	99 1f       	adc	r25, r25
    9514:	00 0f       	add	r16, r16
    9516:	11 1f       	adc	r17, r17
    9518:	00 0f       	add	r16, r16
    951a:	11 1f       	adc	r17, r17
    951c:	00 0f       	add	r16, r16
    951e:	11 1f       	adc	r17, r17
    9520:	08 0f       	add	r16, r24
    9522:	19 1f       	adc	r17, r25
    9524:	21 50       	subi	r18, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    9526:	99 f7       	brne	.-26     	; 0x950e <Put_sVal+0x92>
    9528:	c6 01       	movw	r24, r12
    952a:	d7 fc       	sbrc	r13, 7
    952c:	86 c0       	rjmp	.+268    	; 0x963a <Put_sVal+0x1be>
    952e:	b8 01       	movw	r22, r16
    9530:	0e 94 7e 84 	call	0x108fc	; 0x108fc <__udivmodhi4>
    9534:	9c 01       	movw	r18, r24
		sprintf(Param->Pos, Format, Val/Div, (uint16_t)abs(Val)%Div);
    9536:	8d b7       	in	r24, 0x3d	; 61
    9538:	9e b7       	in	r25, 0x3e	; 62
    953a:	08 97       	sbiw	r24, 0x08	; 8
    953c:	0f b6       	in	r0, 0x3f	; 63
    953e:	f8 94       	cli
    9540:	9e bf       	out	0x3e, r25	; 62
    9542:	0f be       	out	0x3f, r0	; 63
    9544:	8d bf       	out	0x3d, r24	; 61
    9546:	ed b7       	in	r30, 0x3d	; 61
    9548:	fe b7       	in	r31, 0x3e	; 62
    954a:	31 96       	adiw	r30, 0x01	; 1
    954c:	d7 01       	movw	r26, r14
    954e:	8d 91       	ld	r24, X+
    9550:	9c 91       	ld	r25, X
    9552:	ad b7       	in	r26, 0x3d	; 61
    9554:	be b7       	in	r27, 0x3e	; 62
    9556:	12 96       	adiw	r26, 0x02	; 2
    9558:	9c 93       	st	X, r25
    955a:	8e 93       	st	-X, r24
    955c:	11 97       	sbiw	r26, 0x01	; 1
    955e:	b3 82       	std	Z+3, r11	; 0x03
    9560:	a2 82       	std	Z+2, r10	; 0x02
    9562:	c6 01       	movw	r24, r12
    9564:	b8 01       	movw	r22, r16
    9566:	0e 94 92 84 	call	0x10924	; 0x10924 <__divmodhi4>
    956a:	75 83       	std	Z+5, r23	; 0x05
    956c:	64 83       	std	Z+4, r22	; 0x04
    956e:	26 83       	std	Z+6, r18	; 0x06
    9570:	37 83       	std	Z+7, r19	; 0x07
    9572:	0e 94 e9 81 	call	0x103d2	; 0x103d2 <sprintf>
		if(Val<0) {
    9576:	ed b7       	in	r30, 0x3d	; 61
    9578:	fe b7       	in	r31, 0x3e	; 62
    957a:	38 96       	adiw	r30, 0x08	; 8
    957c:	0f b6       	in	r0, 0x3f	; 63
    957e:	f8 94       	cli
    9580:	fe bf       	out	0x3e, r31	; 62
    9582:	0f be       	out	0x3f, r0	; 63
    9584:	ed bf       	out	0x3d, r30	; 61
    9586:	d7 fc       	sbrc	r13, 7
    9588:	3c c0       	rjmp	.+120    	; 0x9602 <Put_sVal+0x186>
	}
	else {
		Format[4] = '\0';
		sprintf(Param->Pos, Format, Val);
	}
}
    958a:	2a 96       	adiw	r28, 0x0a	; 10
    958c:	0f b6       	in	r0, 0x3f	; 63
    958e:	f8 94       	cli
    9590:	de bf       	out	0x3e, r29	; 62
    9592:	0f be       	out	0x3f, r0	; 63
    9594:	cd bf       	out	0x3d, r28	; 61
    9596:	cf 91       	pop	r28
    9598:	df 91       	pop	r29
    959a:	1f 91       	pop	r17
    959c:	0f 91       	pop	r16
    959e:	ff 90       	pop	r15
    95a0:	ef 90       	pop	r14
    95a2:	df 90       	pop	r13
    95a4:	cf 90       	pop	r12
    95a6:	bf 90       	pop	r11
    95a8:	af 90       	pop	r10
    95aa:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_sVal(int16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0x8000:0x80)+Val;
    95ac:	80 e0       	ldi	r24, 0x00	; 0
    95ae:	90 e8       	ldi	r25, 0x80	; 128
    95b0:	7e cf       	rjmp	.-260    	; 0x94ae <Put_sVal+0x32>
		PutEnum(Param);
		return;
	}
	char Format[] = "%+ d.%. u";
	if(Val==0)
		Format[1] = ' ';
    95b2:	80 e2       	ldi	r24, 0x20	; 32
    95b4:	8a 83       	std	Y+2, r24	; 0x02
	Format[2] = '0'+Param->Size;
    95b6:	f7 01       	movw	r30, r14
    95b8:	23 81       	ldd	r18, Z+3	; 0x03
    95ba:	20 5d       	subi	r18, 0xD0	; 208
    95bc:	2b 83       	std	Y+3, r18	; 0x03
	if(Param->Prec) {
    95be:	92 81       	ldd	r25, Z+2	; 0x02
    95c0:	99 23       	and	r25, r25
    95c2:	09 f0       	breq	.+2      	; 0x95c6 <Put_sVal+0x14a>
    95c4:	9a cf       	rjmp	.-204    	; 0x94fa <Put_sVal+0x7e>
				Param->Pos++;
			*Param->Pos = '-';
		}
	}
	else {
		Format[4] = '\0';
    95c6:	1d 82       	std	Y+5, r1	; 0x05
		sprintf(Param->Pos, Format, Val);
    95c8:	00 d0       	rcall	.+0      	; 0x95ca <Put_sVal+0x14e>
    95ca:	00 d0       	rcall	.+0      	; 0x95cc <Put_sVal+0x150>
    95cc:	ed b7       	in	r30, 0x3d	; 61
    95ce:	fe b7       	in	r31, 0x3e	; 62
    95d0:	31 96       	adiw	r30, 0x01	; 1
    95d2:	d7 01       	movw	r26, r14
    95d4:	8d 91       	ld	r24, X+
    95d6:	9c 91       	ld	r25, X
    95d8:	ad b7       	in	r26, 0x3d	; 61
    95da:	be b7       	in	r27, 0x3e	; 62
    95dc:	12 96       	adiw	r26, 0x02	; 2
    95de:	9c 93       	st	X, r25
    95e0:	8e 93       	st	-X, r24
    95e2:	11 97       	sbiw	r26, 0x01	; 1
    95e4:	b3 82       	std	Z+3, r11	; 0x03
    95e6:	a2 82       	std	Z+2, r10	; 0x02
    95e8:	d5 82       	std	Z+5, r13	; 0x05
    95ea:	c4 82       	std	Z+4, r12	; 0x04
    95ec:	0e 94 e9 81 	call	0x103d2	; 0x103d2 <sprintf>
    95f0:	ed b7       	in	r30, 0x3d	; 61
    95f2:	fe b7       	in	r31, 0x3e	; 62
    95f4:	36 96       	adiw	r30, 0x06	; 6
    95f6:	0f b6       	in	r0, 0x3f	; 63
    95f8:	f8 94       	cli
    95fa:	fe bf       	out	0x3e, r31	; 62
    95fc:	0f be       	out	0x3f, r0	; 63
    95fe:	ed bf       	out	0x3d, r30	; 61
    9600:	c4 cf       	rjmp	.-120    	; 0x958a <Put_sVal+0x10e>
		Format[2] -= Param->Prec+1;
		Format[7] = '0'+Param->Prec;
		int16_t Div=Pow10(Param->Prec);
		sprintf(Param->Pos, Format, Val/Div, (uint16_t)abs(Val)%Div);
		if(Val<0) {
			while(*Param->Pos==' ')
    9602:	d7 01       	movw	r26, r14
    9604:	ed 91       	ld	r30, X+
    9606:	fc 91       	ld	r31, X
    9608:	80 81       	ld	r24, Z
    960a:	80 32       	cpi	r24, 0x20	; 32
    960c:	39 f4       	brne	.+14     	; 0x961c <Put_sVal+0x1a0>
				Param->Pos++;
    960e:	31 96       	adiw	r30, 0x01	; 1
    9610:	d7 01       	movw	r26, r14
    9612:	ed 93       	st	X+, r30
    9614:	fc 93       	st	X, r31
		Format[2] -= Param->Prec+1;
		Format[7] = '0'+Param->Prec;
		int16_t Div=Pow10(Param->Prec);
		sprintf(Param->Pos, Format, Val/Div, (uint16_t)abs(Val)%Div);
		if(Val<0) {
			while(*Param->Pos==' ')
    9616:	80 81       	ld	r24, Z
    9618:	80 32       	cpi	r24, 0x20	; 32
    961a:	c9 f3       	breq	.-14     	; 0x960e <Put_sVal+0x192>
				Param->Pos++;
			*Param->Pos = '-';
    961c:	8d e2       	ldi	r24, 0x2D	; 45
    961e:	80 83       	st	Z, r24
    9620:	b4 cf       	rjmp	.-152    	; 0x958a <Put_sVal+0x10e>
void
Put_sVal(int16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0x8000:0x80)+Val;
	if(Param->Txt && Idx<2) {
		Param->Txt += Idx;
    9622:	88 0f       	add	r24, r24
    9624:	99 1f       	adc	r25, r25
    9626:	28 0f       	add	r18, r24
    9628:	39 1f       	adc	r19, r25
    962a:	15 96       	adiw	r26, 0x05	; 5
    962c:	3c 93       	st	X, r19
    962e:	2e 93       	st	-X, r18
    9630:	14 97       	sbiw	r26, 0x04	; 4
		PutEnum(Param);
    9632:	c7 01       	movw	r24, r14
    9634:	0e 94 24 42 	call	0x8448	; 0x8448 <PutEnum>
    9638:	a8 cf       	rjmp	.-176    	; 0x958a <Put_sVal+0x10e>
    963a:	88 27       	eor	r24, r24
    963c:	99 27       	eor	r25, r25
    963e:	8c 19       	sub	r24, r12
    9640:	9d 09       	sbc	r25, r13
    9642:	75 cf       	rjmp	.-278    	; 0x952e <Put_sVal+0xb2>

00009644 <PutVal>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
PutVal(uint16_t Val, char Type, T_Param *Param)
{
    9644:	af 92       	push	r10
    9646:	bf 92       	push	r11
    9648:	cf 92       	push	r12
    964a:	df 92       	push	r13
    964c:	ef 92       	push	r14
    964e:	ff 92       	push	r15
    9650:	0f 93       	push	r16
    9652:	1f 93       	push	r17
    9654:	df 93       	push	r29
    9656:	cf 93       	push	r28
    9658:	cd b7       	in	r28, 0x3d	; 61
    965a:	de b7       	in	r29, 0x3e	; 62
    965c:	29 97       	sbiw	r28, 0x09	; 9
    965e:	0f b6       	in	r0, 0x3f	; 63
    9660:	f8 94       	cli
    9662:	de bf       	out	0x3e, r29	; 62
    9664:	0f be       	out	0x3f, r0	; 63
    9666:	cd bf       	out	0x3d, r28	; 61
    9668:	6c 01       	movw	r12, r24
    966a:	7a 01       	movw	r14, r20
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
    966c:	67 37       	cpi	r22, 0x77	; 119
    966e:	09 f4       	brne	.+2      	; 0x9672 <PutVal+0x2e>
    9670:	79 c0       	rjmp	.+242    	; 0x9764 <PutVal+0x120>
    9672:	8f ef       	ldi	r24, 0xFF	; 255
    9674:	90 e0       	ldi	r25, 0x00	; 0
	if(Param->Txt && Idx<2) {
    9676:	d7 01       	movw	r26, r14
    9678:	14 96       	adiw	r26, 0x04	; 4
    967a:	2d 91       	ld	r18, X+
    967c:	3c 91       	ld	r19, X
    967e:	15 97       	sbiw	r26, 0x05	; 5
    9680:	21 15       	cp	r18, r1
    9682:	31 05       	cpc	r19, r1
    9684:	31 f0       	breq	.+12     	; 0x9692 <PutVal+0x4e>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
PutVal(uint16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
    9686:	8c 19       	sub	r24, r12
    9688:	9d 09       	sbc	r25, r13
	if(Param->Txt && Idx<2) {
    968a:	82 30       	cpi	r24, 0x02	; 2
    968c:	91 05       	cpc	r25, r1
    968e:	08 f4       	brcc	.+2      	; 0x9692 <PutVal+0x4e>
    9690:	8a c0       	rjmp	.+276    	; 0x97a6 <PutVal+0x162>
		Param->Txt += Idx;
		PutEnum(Param);
		return;
	}
	char Format[] = "% u.%. u";
    9692:	5e 01       	movw	r10, r28
    9694:	08 94       	sec
    9696:	a1 1c       	adc	r10, r1
    9698:	b1 1c       	adc	r11, r1
    969a:	d5 01       	movw	r26, r10
    969c:	e6 e9       	ldi	r30, 0x96	; 150
    969e:	f2 e0       	ldi	r31, 0x02	; 2
    96a0:	89 e0       	ldi	r24, 0x09	; 9
    96a2:	01 90       	ld	r0, Z+
    96a4:	0d 92       	st	X+, r0
    96a6:	81 50       	subi	r24, 0x01	; 1
    96a8:	e1 f7       	brne	.-8      	; 0x96a2 <PutVal+0x5e>
	Format[1] = '0'+Param->Size;
    96aa:	f7 01       	movw	r30, r14
    96ac:	23 81       	ldd	r18, Z+3	; 0x03
    96ae:	20 5d       	subi	r18, 0xD0	; 208
    96b0:	2a 83       	std	Y+2, r18	; 0x02
	if(Param->Prec) {
    96b2:	92 81       	ldd	r25, Z+2	; 0x02
    96b4:	99 23       	and	r25, r25
    96b6:	09 f4       	brne	.+2      	; 0x96ba <PutVal+0x76>
    96b8:	58 c0       	rjmp	.+176    	; 0x976a <PutVal+0x126>
		Format[1] -= Param->Prec+1;
    96ba:	89 2f       	mov	r24, r25
    96bc:	80 95       	com	r24
    96be:	82 0f       	add	r24, r18
    96c0:	8a 83       	std	Y+2, r24	; 0x02
		Format[6] = '0'+Param->Prec;
    96c2:	90 5d       	subi	r25, 0xD0	; 208
    96c4:	9f 83       	std	Y+7, r25	; 0x07
    96c6:	90 53       	subi	r25, 0x30	; 48
		uint16_t Div=Pow10(Param->Prec);
    96c8:	29 2f       	mov	r18, r25
    96ca:	01 e0       	ldi	r16, 0x01	; 1
    96cc:	10 e0       	ldi	r17, 0x00	; 0
		Pow *= 10;
    96ce:	c8 01       	movw	r24, r16
    96d0:	88 0f       	add	r24, r24
    96d2:	99 1f       	adc	r25, r25
    96d4:	00 0f       	add	r16, r16
    96d6:	11 1f       	adc	r17, r17
    96d8:	00 0f       	add	r16, r16
    96da:	11 1f       	adc	r17, r17
    96dc:	00 0f       	add	r16, r16
    96de:	11 1f       	adc	r17, r17
    96e0:	08 0f       	add	r16, r24
    96e2:	19 1f       	adc	r17, r25
    96e4:	21 50       	subi	r18, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    96e6:	99 f7       	brne	.-26     	; 0x96ce <PutVal+0x8a>
    96e8:	c6 01       	movw	r24, r12
    96ea:	b8 01       	movw	r22, r16
    96ec:	0e 94 7e 84 	call	0x108fc	; 0x108fc <__udivmodhi4>
    96f0:	9c 01       	movw	r18, r24
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
    96f2:	8d b7       	in	r24, 0x3d	; 61
    96f4:	9e b7       	in	r25, 0x3e	; 62
    96f6:	08 97       	sbiw	r24, 0x08	; 8
    96f8:	0f b6       	in	r0, 0x3f	; 63
    96fa:	f8 94       	cli
    96fc:	9e bf       	out	0x3e, r25	; 62
    96fe:	0f be       	out	0x3f, r0	; 63
    9700:	8d bf       	out	0x3d, r24	; 61
    9702:	ed b7       	in	r30, 0x3d	; 61
    9704:	fe b7       	in	r31, 0x3e	; 62
    9706:	31 96       	adiw	r30, 0x01	; 1
    9708:	d7 01       	movw	r26, r14
    970a:	8d 91       	ld	r24, X+
    970c:	9c 91       	ld	r25, X
    970e:	ad b7       	in	r26, 0x3d	; 61
    9710:	be b7       	in	r27, 0x3e	; 62
    9712:	12 96       	adiw	r26, 0x02	; 2
    9714:	9c 93       	st	X, r25
    9716:	8e 93       	st	-X, r24
    9718:	11 97       	sbiw	r26, 0x01	; 1
    971a:	b3 82       	std	Z+3, r11	; 0x03
    971c:	a2 82       	std	Z+2, r10	; 0x02
    971e:	c6 01       	movw	r24, r12
    9720:	b8 01       	movw	r22, r16
    9722:	0e 94 7e 84 	call	0x108fc	; 0x108fc <__udivmodhi4>
    9726:	75 83       	std	Z+5, r23	; 0x05
    9728:	64 83       	std	Z+4, r22	; 0x04
    972a:	26 83       	std	Z+6, r18	; 0x06
    972c:	37 83       	std	Z+7, r19	; 0x07
    972e:	0e 94 e9 81 	call	0x103d2	; 0x103d2 <sprintf>
    9732:	ed b7       	in	r30, 0x3d	; 61
    9734:	fe b7       	in	r31, 0x3e	; 62
    9736:	38 96       	adiw	r30, 0x08	; 8
    9738:	0f b6       	in	r0, 0x3f	; 63
    973a:	f8 94       	cli
    973c:	fe bf       	out	0x3e, r31	; 62
    973e:	0f be       	out	0x3f, r0	; 63
    9740:	ed bf       	out	0x3d, r30	; 61
	}
	else {
		Format[3] = '\0';
		sprintf(Param->Pos, Format, Val);
	}
}
    9742:	29 96       	adiw	r28, 0x09	; 9
    9744:	0f b6       	in	r0, 0x3f	; 63
    9746:	f8 94       	cli
    9748:	de bf       	out	0x3e, r29	; 62
    974a:	0f be       	out	0x3f, r0	; 63
    974c:	cd bf       	out	0x3d, r28	; 61
    974e:	cf 91       	pop	r28
    9750:	df 91       	pop	r29
    9752:	1f 91       	pop	r17
    9754:	0f 91       	pop	r16
    9756:	ff 90       	pop	r15
    9758:	ef 90       	pop	r14
    975a:	df 90       	pop	r13
    975c:	cf 90       	pop	r12
    975e:	bf 90       	pop	r11
    9760:	af 90       	pop	r10
    9762:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
PutVal(uint16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
    9764:	8f ef       	ldi	r24, 0xFF	; 255
    9766:	9f ef       	ldi	r25, 0xFF	; 255
    9768:	86 cf       	rjmp	.-244    	; 0x9676 <PutVal+0x32>
		Format[6] = '0'+Param->Prec;
		uint16_t Div=Pow10(Param->Prec);
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
	}
	else {
		Format[3] = '\0';
    976a:	1c 82       	std	Y+4, r1	; 0x04
		sprintf(Param->Pos, Format, Val);
    976c:	00 d0       	rcall	.+0      	; 0x976e <PutVal+0x12a>
    976e:	00 d0       	rcall	.+0      	; 0x9770 <PutVal+0x12c>
    9770:	ed b7       	in	r30, 0x3d	; 61
    9772:	fe b7       	in	r31, 0x3e	; 62
    9774:	31 96       	adiw	r30, 0x01	; 1
    9776:	d7 01       	movw	r26, r14
    9778:	8d 91       	ld	r24, X+
    977a:	9c 91       	ld	r25, X
    977c:	ad b7       	in	r26, 0x3d	; 61
    977e:	be b7       	in	r27, 0x3e	; 62
    9780:	12 96       	adiw	r26, 0x02	; 2
    9782:	9c 93       	st	X, r25
    9784:	8e 93       	st	-X, r24
    9786:	11 97       	sbiw	r26, 0x01	; 1
    9788:	b3 82       	std	Z+3, r11	; 0x03
    978a:	a2 82       	std	Z+2, r10	; 0x02
    978c:	d5 82       	std	Z+5, r13	; 0x05
    978e:	c4 82       	std	Z+4, r12	; 0x04
    9790:	0e 94 e9 81 	call	0x103d2	; 0x103d2 <sprintf>
    9794:	ed b7       	in	r30, 0x3d	; 61
    9796:	fe b7       	in	r31, 0x3e	; 62
    9798:	36 96       	adiw	r30, 0x06	; 6
    979a:	0f b6       	in	r0, 0x3f	; 63
    979c:	f8 94       	cli
    979e:	fe bf       	out	0x3e, r31	; 62
    97a0:	0f be       	out	0x3f, r0	; 63
    97a2:	ed bf       	out	0x3d, r30	; 61
    97a4:	ce cf       	rjmp	.-100    	; 0x9742 <PutVal+0xfe>
void
PutVal(uint16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
	if(Param->Txt && Idx<2) {
		Param->Txt += Idx;
    97a6:	88 0f       	add	r24, r24
    97a8:	99 1f       	adc	r25, r25
    97aa:	28 0f       	add	r18, r24
    97ac:	39 1f       	adc	r19, r25
    97ae:	15 96       	adiw	r26, 0x05	; 5
    97b0:	3c 93       	st	X, r19
    97b2:	2e 93       	st	-X, r18
    97b4:	14 97       	sbiw	r26, 0x04	; 4
		PutEnum(Param);
    97b6:	c7 01       	movw	r24, r14
    97b8:	0e 94 24 42 	call	0x8448	; 0x8448 <PutEnum>
    97bc:	c2 cf       	rjmp	.-124    	; 0x9742 <PutVal+0xfe>

000097be <GSM_Wait_Response_P>:
//	}
	if(strcmp(GSM_RxStr, Str))return 0;
	else return 1;
}
// ~~~~~~~~~
uint8_t GSM_Wait_Response_P(prog_char *Str_P, uint8_t RestoreCMD){
    97be:	1f 93       	push	r17
    97c0:	cf 93       	push	r28
    97c2:	df 93       	push	r29
    97c4:	ec 01       	movw	r28, r24
    97c6:	16 2f       	mov	r17, r22
	
	if(Timer16Stopp(TD_GSM) && RestoreCMD){
    97c8:	80 91 e9 04 	lds	r24, 0x04E9
    97cc:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <Timer16Stopp>
    97d0:	88 23       	and	r24, r24
    97d2:	11 f0       	breq	.+4      	; 0x97d8 <GSM_Wait_Response_P+0x1a>
    97d4:	11 23       	and	r17, r17
    97d6:	51 f4       	brne	.+20     	; 0x97ec <GSM_Wait_Response_P+0x2e>
		GSM_State = RestoreCMD;
		return 0;
	}
	//  
	if(GetStringFromFIFO()){
    97d8:	0e 94 92 39 	call	0x7324	; 0x7324 <GetStringFromFIFO>
    97dc:	88 23       	and	r24, r24
    97de:	71 f4       	brne	.+28     	; 0x97fc <GSM_Wait_Response_P+0x3e>
    97e0:	20 e0       	ldi	r18, 0x00	; 0
		if(strcmp_P(GSM_RxStr, Str_P)) return 0;
		else return 1;
	}
	else return 0;
}
    97e2:	82 2f       	mov	r24, r18
    97e4:	df 91       	pop	r29
    97e6:	cf 91       	pop	r28
    97e8:	1f 91       	pop	r17
    97ea:	08 95       	ret
}
// ~~~~~~~~~
uint8_t GSM_Wait_Response_P(prog_char *Str_P, uint8_t RestoreCMD){
	
	if(Timer16Stopp(TD_GSM) && RestoreCMD){
		GSM_State = RestoreCMD;
    97ec:	10 93 f6 06 	sts	0x06F6, r17
    97f0:	20 e0       	ldi	r18, 0x00	; 0
	if(GetStringFromFIFO()){
		if(strcmp_P(GSM_RxStr, Str_P)) return 0;
		else return 1;
	}
	else return 0;
}
    97f2:	82 2f       	mov	r24, r18
    97f4:	df 91       	pop	r29
    97f6:	cf 91       	pop	r28
    97f8:	1f 91       	pop	r17
    97fa:	08 95       	ret
		GSM_State = RestoreCMD;
		return 0;
	}
	//  
	if(GetStringFromFIFO()){
		if(strcmp_P(GSM_RxStr, Str_P)) return 0;
    97fc:	80 ee       	ldi	r24, 0xE0	; 224
    97fe:	97 e0       	ldi	r25, 0x07	; 7
    9800:	be 01       	movw	r22, r28
    9802:	0e 94 ed 80 	call	0x101da	; 0x101da <strcmp_P>
    9806:	20 e0       	ldi	r18, 0x00	; 0
    9808:	89 2b       	or	r24, r25
    980a:	59 f7       	brne	.-42     	; 0x97e2 <GSM_Wait_Response_P+0x24>
    980c:	21 e0       	ldi	r18, 0x01	; 1
		else return 1;
	}
	else return 0;
}
    980e:	82 2f       	mov	r24, r18
    9810:	df 91       	pop	r29
    9812:	cf 91       	pop	r28
    9814:	1f 91       	pop	r17
    9816:	08 95       	ret

00009818 <GSM_SendCR>:
	
	sei();	
}
// ~~~~~~~~~
//   + CR
void GSM_SendCR(prog_char *Str_P){
    9818:	ef 92       	push	r14
    981a:	ff 92       	push	r15
    981c:	0f 93       	push	r16
    981e:	1f 93       	push	r17
    9820:	7c 01       	movw	r14, r24
	GSMTxSz = strlen_P(Str_P);
    9822:	0e 94 fd 80 	call	0x101fa	; 0x101fa <strlen_P>
    9826:	80 93 bb 07 	sts	0x07BB, r24
	sprintf_P(GSM_TxStr, Str_P);
    982a:	00 d0       	rcall	.+0      	; 0x982c <GSM_SendCR+0x14>
    982c:	0f 92       	push	r0
    982e:	09 e4       	ldi	r16, 0x49	; 73
    9830:	1a e0       	ldi	r17, 0x0A	; 10
    9832:	ed b7       	in	r30, 0x3d	; 61
    9834:	fe b7       	in	r31, 0x3e	; 62
    9836:	12 83       	std	Z+2, r17	; 0x02
    9838:	01 83       	std	Z+1, r16	; 0x01
    983a:	f4 82       	std	Z+4, r15	; 0x04
    983c:	e3 82       	std	Z+3, r14	; 0x03
    983e:	0e 94 1a 82 	call	0x10434	; 0x10434 <sprintf_P>
	sprintf(GSM_TxStr + GSMTxSz, "\r");
    9842:	80 91 bb 07 	lds	r24, 0x07BB
    9846:	08 0f       	add	r16, r24
    9848:	11 1d       	adc	r17, r1
    984a:	8d e0       	ldi	r24, 0x0D	; 13
    984c:	90 e0       	ldi	r25, 0x00	; 0
    984e:	f8 01       	movw	r30, r16
    9850:	91 83       	std	Z+1, r25	; 0x01
    9852:	80 83       	st	Z, r24
	GSMTxSz++;
    9854:	80 91 bb 07 	lds	r24, 0x07BB
    9858:	8f 5f       	subi	r24, 0xFF	; 255
    985a:	80 93 bb 07 	sts	0x07BB, r24
	GSM_SendFirstChar();
    985e:	0f 90       	pop	r0
    9860:	0f 90       	pop	r0
    9862:	0f 90       	pop	r0
    9864:	0f 90       	pop	r0
    9866:	0e 94 bc 3a 	call	0x7578	; 0x7578 <GSM_SendFirstChar>
}
    986a:	1f 91       	pop	r17
    986c:	0f 91       	pop	r16
    986e:	ff 90       	pop	r15
    9870:	ef 90       	pop	r14
    9872:	08 95       	ret

00009874 <GSM_Execute_Command>:
	GSMTxSz = Size;
	memcpy(GSM_TxStr, Data_Out, GSMTxSz);
	GSM_SendFirstChar();
}
// ~~~~~~~~~
void GSM_Execute_Command(prog_char *Str_P, uint16_t Timeout){
    9874:	cf 93       	push	r28
    9876:	df 93       	push	r29
    9878:	9c 01       	movw	r18, r24
    987a:	eb 01       	movw	r28, r22
	if(GSM_Flag & (1<<flg_TxCStr)){
    987c:	80 91 d2 02 	lds	r24, 0x02D2
    9880:	80 ff       	sbrs	r24, 0
    9882:	08 c0       	rjmp	.+16     	; 0x9894 <GSM_Execute_Command+0x20>
		GSM_SendCR(Str_P);
    9884:	c9 01       	movw	r24, r18
    9886:	0e 94 0c 4c 	call	0x9818	; 0x9818 <GSM_SendCR>
		StartTimer16(TD_GSM, Timeout);
    988a:	80 91 e9 04 	lds	r24, 0x04E9
    988e:	be 01       	movw	r22, r28
    9890:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
	}
}
    9894:	df 91       	pop	r29
    9896:	cf 91       	pop	r28
    9898:	08 95       	ret

0000989a <analize_DTMF>:
uint8_t GSM_GotoNextVega(void){
 return 0;
}
uint8_t counter=0;
uint8_t analize_DTMF(){
	if((strstr_P(GSM_RxStr, PSTR("+DTMF: 1")) != NULL) ){
    989a:	80 ee       	ldi	r24, 0xE0	; 224
    989c:	97 e0       	ldi	r25, 0x07	; 7
    989e:	67 e8       	ldi	r22, 0x87	; 135
    98a0:	7f e2       	ldi	r23, 0x2F	; 47
    98a2:	0e 94 1f 81 	call	0x1023e	; 0x1023e <strstr_P>
    98a6:	89 2b       	or	r24, r25
    98a8:	59 f0       	breq	.+22     	; 0x98c0 <analize_DTMF+0x26>
		StartTimer16(TD_GSM,1000);
    98aa:	80 91 e9 04 	lds	r24, 0x04E9
    98ae:	68 ee       	ldi	r22, 0xE8	; 232
    98b0:	73 e0       	ldi	r23, 0x03	; 3
    98b2:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
		GSM_State = GSM_SEND_CREC_5;
    98b6:	8b e1       	ldi	r24, 0x1B	; 27
    98b8:	80 93 f6 06 	sts	0x06F6, r24
    98bc:	81 e0       	ldi	r24, 0x01	; 1
    98be:	08 95       	ret
		return 1;
	}
	if((strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 2,0,6")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 3,0,6")) != NULL) ){
    98c0:	80 ee       	ldi	r24, 0xE0	; 224
    98c2:	97 e0       	ldi	r25, 0x07	; 7
    98c4:	6a e7       	ldi	r22, 0x7A	; 122
    98c6:	7f e2       	ldi	r23, 0x2F	; 47
    98c8:	0e 94 1f 81 	call	0x1023e	; 0x1023e <strstr_P>
    98cc:	89 2b       	or	r24, r25
    98ce:	59 f0       	breq	.+22     	; 0x98e6 <analize_DTMF+0x4c>
		StartTimer16(TD_GSM,2000);
    98d0:	80 91 e9 04 	lds	r24, 0x04E9
    98d4:	60 ed       	ldi	r22, 0xD0	; 208
    98d6:	77 e0       	ldi	r23, 0x07	; 7
    98d8:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
		GSM_State = GSM_WAIT_DISCONNECT_CAUSE;
    98dc:	85 e2       	ldi	r24, 0x25	; 37
    98de:	80 93 f6 06 	sts	0x06F6, r24
    98e2:	81 e0       	ldi	r24, 0x01	; 1
		return 1;
	}
	return 0;
}
    98e4:	08 95       	ret
	if((strstr_P(GSM_RxStr, PSTR("+DTMF: 1")) != NULL) ){
		StartTimer16(TD_GSM,1000);
		GSM_State = GSM_SEND_CREC_5;
		return 1;
	}
	if((strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 2,0,6")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 3,0,6")) != NULL) ){
    98e6:	80 ee       	ldi	r24, 0xE0	; 224
    98e8:	97 e0       	ldi	r25, 0x07	; 7
    98ea:	6d e6       	ldi	r22, 0x6D	; 109
    98ec:	7f e2       	ldi	r23, 0x2F	; 47
    98ee:	0e 94 1f 81 	call	0x1023e	; 0x1023e <strstr_P>
    98f2:	89 2b       	or	r24, r25
    98f4:	69 f7       	brne	.-38     	; 0x98d0 <analize_DTMF+0x36>
    98f6:	80 ee       	ldi	r24, 0xE0	; 224
    98f8:	97 e0       	ldi	r25, 0x07	; 7
    98fa:	60 e6       	ldi	r22, 0x60	; 96
    98fc:	7f e2       	ldi	r23, 0x2F	; 47
    98fe:	0e 94 1f 81 	call	0x1023e	; 0x1023e <strstr_P>
    9902:	89 2b       	or	r24, r25
    9904:	29 f7       	brne	.-54     	; 0x98d0 <analize_DTMF+0x36>
    9906:	80 e0       	ldi	r24, 0x00	; 0
    9908:	08 95       	ret

0000990a <GSM_Wait_Response>:
	#endif

}
// ~~~~~~~~~
//   GetStringFromFIFO()!
uint8_t GSM_Wait_Response(char *Str, uint8_t RestoreCMD){
    990a:	bc 01       	movw	r22, r24
//	if(Timer16Stopp(TD_GSM) && RestoreCMD){
//		GSM_State = RestoreCMD;
//		return 0;
//	}
	if(strcmp(GSM_RxStr, Str))return 0;
    990c:	80 ee       	ldi	r24, 0xE0	; 224
    990e:	97 e0       	ldi	r25, 0x07	; 7
    9910:	0e 94 4d 81 	call	0x1029a	; 0x1029a <strcmp>
    9914:	9c 01       	movw	r18, r24
    9916:	80 e0       	ldi	r24, 0x00	; 0
    9918:	23 2b       	or	r18, r19
    991a:	09 f4       	brne	.+2      	; 0x991e <GSM_Wait_Response+0x14>
    991c:	81 e0       	ldi	r24, 0x01	; 1
	else return 1;
}
    991e:	08 95       	ret

00009920 <DigiFilt>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
DigiFilt(const uint16_t *Array, uint8_t Edge)
{
    9920:	6f 92       	push	r6
    9922:	7f 92       	push	r7
    9924:	8f 92       	push	r8
    9926:	9f 92       	push	r9
    9928:	bf 92       	push	r11
    992a:	cf 92       	push	r12
    992c:	df 92       	push	r13
    992e:	ef 92       	push	r14
    9930:	ff 92       	push	r15
    9932:	0f 93       	push	r16
    9934:	1f 93       	push	r17
    9936:	df 93       	push	r29
    9938:	cf 93       	push	r28
    993a:	cd b7       	in	r28, 0x3d	; 61
    993c:	de b7       	in	r29, 0x3e	; 62
    993e:	28 2f       	mov	r18, r24
    9940:	79 2f       	mov	r23, r25
    9942:	e6 2e       	mov	r14, r22
				Buf[i] = Buf[j];
				Buf[j] = Swap;
			}
	for(i=Edge; i<_Edge; Sum+=Buf[i++]);
	return Sum/(Edge*2);
}
    9944:	6d b6       	in	r6, 0x3d	; 61
    9946:	7e b6       	in	r7, 0x3e	; 62

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
DigiFilt(const uint16_t *Array, uint8_t Edge)
{
	uint8_t Sz = Edge*4;
    9948:	86 2e       	mov	r8, r22
    994a:	99 24       	eor	r9, r9
    994c:	f6 2e       	mov	r15, r22
    994e:	ff 0c       	add	r15, r15
    9950:	ff 0c       	add	r15, r15
	uint8_t _Edge = Sz-Edge;
    9952:	bf 2c       	mov	r11, r15
    9954:	b6 1a       	sub	r11, r22
	uint16_t Buf[Sz];
    9956:	ef 2d       	mov	r30, r15
    9958:	f0 e0       	ldi	r31, 0x00	; 0
    995a:	ee 0f       	add	r30, r30
    995c:	ff 1f       	adc	r31, r31
    995e:	8d b7       	in	r24, 0x3d	; 61
    9960:	9e b7       	in	r25, 0x3e	; 62
    9962:	8e 1b       	sub	r24, r30
    9964:	9f 0b       	sbc	r25, r31
    9966:	0f b6       	in	r0, 0x3f	; 63
    9968:	f8 94       	cli
    996a:	9e bf       	out	0x3e, r25	; 62
    996c:	0f be       	out	0x3f, r0	; 63
    996e:	8d bf       	out	0x3d, r24	; 61
    9970:	0d b7       	in	r16, 0x3d	; 61
    9972:	1e b7       	in	r17, 0x3e	; 62
    9974:	0f 5f       	subi	r16, 0xFF	; 255
    9976:	1f 4f       	sbci	r17, 0xFF	; 255
	uint32_t Sum = 0;
	uint16_t Swap;
	uint8_t i, j;
	memcpy(Buf, Array, Sz*2);
    9978:	c8 01       	movw	r24, r16
    997a:	62 2f       	mov	r22, r18
    997c:	af 01       	movw	r20, r30
    997e:	0e 94 39 81 	call	0x10272	; 0x10272 <memcpy>
	for(i=0; i<Edge; i++)
    9982:	ee 20       	and	r14, r14
    9984:	09 f1       	breq	.+66     	; 0x99c8 <DigiFilt+0xa8>
    9986:	d8 01       	movw	r26, r16
    9988:	80 e0       	ldi	r24, 0x00	; 0
		for(j=i+1; j<Sz; j++)
    998a:	58 2f       	mov	r21, r24
    998c:	5f 5f       	subi	r21, 0xFF	; 255
    998e:	5f 15       	cp	r21, r15
    9990:	b8 f4       	brcc	.+46     	; 0x99c0 <DigiFilt+0xa0>
    9992:	45 2f       	mov	r20, r21
			if(Buf[j] < Buf[i]) {
    9994:	e4 2f       	mov	r30, r20
    9996:	f0 e0       	ldi	r31, 0x00	; 0
    9998:	ee 0f       	add	r30, r30
    999a:	ff 1f       	adc	r31, r31
    999c:	e0 0f       	add	r30, r16
    999e:	f1 1f       	adc	r31, r17
    99a0:	20 81       	ld	r18, Z
    99a2:	31 81       	ldd	r19, Z+1	; 0x01
    99a4:	8d 91       	ld	r24, X+
    99a6:	9c 91       	ld	r25, X
    99a8:	11 97       	sbiw	r26, 0x01	; 1
    99aa:	28 17       	cp	r18, r24
    99ac:	39 07       	cpc	r19, r25
    99ae:	28 f4       	brcc	.+10     	; 0x99ba <DigiFilt+0x9a>
				Swap = Buf[i];
				Buf[i] = Buf[j];
    99b0:	11 96       	adiw	r26, 0x01	; 1
    99b2:	3c 93       	st	X, r19
    99b4:	2e 93       	st	-X, r18
				Buf[j] = Swap;
    99b6:	91 83       	std	Z+1, r25	; 0x01
    99b8:	80 83       	st	Z, r24
	uint32_t Sum = 0;
	uint16_t Swap;
	uint8_t i, j;
	memcpy(Buf, Array, Sz*2);
	for(i=0; i<Edge; i++)
		for(j=i+1; j<Sz; j++)
    99ba:	4f 5f       	subi	r20, 0xFF	; 255
    99bc:	4f 15       	cp	r20, r15
    99be:	50 f3       	brcs	.-44     	; 0x9994 <DigiFilt+0x74>
    99c0:	12 96       	adiw	r26, 0x02	; 2
    99c2:	85 2f       	mov	r24, r21
	uint16_t Buf[Sz];
	uint32_t Sum = 0;
	uint16_t Swap;
	uint8_t i, j;
	memcpy(Buf, Array, Sz*2);
	for(i=0; i<Edge; i++)
    99c4:	5e 15       	cp	r21, r14
    99c6:	08 f3       	brcs	.-62     	; 0x998a <DigiFilt+0x6a>
			if(Buf[j] < Buf[i]) {
				Swap = Buf[i];
				Buf[i] = Buf[j];
				Buf[j] = Swap;
			}
	for(i=Sz-1; i>=_Edge; i--)
    99c8:	ef 2d       	mov	r30, r15
    99ca:	e1 50       	subi	r30, 0x01	; 1
    99cc:	eb 15       	cp	r30, r11
    99ce:	10 f1       	brcs	.+68     	; 0x9a14 <DigiFilt+0xf4>
		for(j=i-1; j>=Edge; j--)
    99d0:	5e 2f       	mov	r21, r30
    99d2:	51 50       	subi	r21, 0x01	; 1
    99d4:	5e 15       	cp	r21, r14
    99d6:	d8 f0       	brcs	.+54     	; 0x9a0e <DigiFilt+0xee>
    99d8:	f0 e0       	ldi	r31, 0x00	; 0
    99da:	45 2f       	mov	r20, r21
    99dc:	ee 0f       	add	r30, r30
    99de:	ff 1f       	adc	r31, r31
			if(Buf[j] > Buf[i]) {
    99e0:	e0 0f       	add	r30, r16
    99e2:	f1 1f       	adc	r31, r17
    99e4:	a4 2f       	mov	r26, r20
    99e6:	b0 e0       	ldi	r27, 0x00	; 0
    99e8:	aa 0f       	add	r26, r26
    99ea:	bb 1f       	adc	r27, r27
    99ec:	a0 0f       	add	r26, r16
    99ee:	b1 1f       	adc	r27, r17
    99f0:	2d 91       	ld	r18, X+
    99f2:	3c 91       	ld	r19, X
    99f4:	11 97       	sbiw	r26, 0x01	; 1
    99f6:	80 81       	ld	r24, Z
    99f8:	91 81       	ldd	r25, Z+1	; 0x01
    99fa:	82 17       	cp	r24, r18
    99fc:	93 07       	cpc	r25, r19
    99fe:	20 f4       	brcc	.+8      	; 0x9a08 <DigiFilt+0xe8>
				Swap = Buf[i];
				Buf[i] = Buf[j];
    9a00:	31 83       	std	Z+1, r19	; 0x01
    9a02:	20 83       	st	Z, r18
				Buf[j] = Swap;
    9a04:	8d 93       	st	X+, r24
    9a06:	9c 93       	st	X, r25
				Swap = Buf[i];
				Buf[i] = Buf[j];
				Buf[j] = Swap;
			}
	for(i=Sz-1; i>=_Edge; i--)
		for(j=i-1; j>=Edge; j--)
    9a08:	41 50       	subi	r20, 0x01	; 1
    9a0a:	4e 15       	cp	r20, r14
    9a0c:	58 f7       	brcc	.-42     	; 0x99e4 <DigiFilt+0xc4>
    9a0e:	e5 2f       	mov	r30, r21
			if(Buf[j] < Buf[i]) {
				Swap = Buf[i];
				Buf[i] = Buf[j];
				Buf[j] = Swap;
			}
	for(i=Sz-1; i>=_Edge; i--)
    9a10:	5b 15       	cp	r21, r11
    9a12:	f0 f6       	brcc	.-68     	; 0x99d0 <DigiFilt+0xb0>
			if(Buf[j] > Buf[i]) {
				Swap = Buf[i];
				Buf[i] = Buf[j];
				Buf[j] = Swap;
			}
	for(i=Edge; i<_Edge; Sum+=Buf[i++]);
    9a14:	eb 14       	cp	r14, r11
    9a16:	a0 f5       	brcc	.+104    	; 0x9a80 <DigiFilt+0x160>
    9a18:	6e 2d       	mov	r22, r14
    9a1a:	cc 24       	eor	r12, r12
    9a1c:	dd 24       	eor	r13, r13
    9a1e:	76 01       	movw	r14, r12
    9a20:	e6 2f       	mov	r30, r22
    9a22:	f0 e0       	ldi	r31, 0x00	; 0
    9a24:	ee 0f       	add	r30, r30
    9a26:	ff 1f       	adc	r31, r31
    9a28:	e0 0f       	add	r30, r16
    9a2a:	f1 1f       	adc	r31, r17
    9a2c:	80 81       	ld	r24, Z
    9a2e:	91 81       	ldd	r25, Z+1	; 0x01
    9a30:	a0 e0       	ldi	r26, 0x00	; 0
    9a32:	b0 e0       	ldi	r27, 0x00	; 0
    9a34:	c8 0e       	add	r12, r24
    9a36:	d9 1e       	adc	r13, r25
    9a38:	ea 1e       	adc	r14, r26
    9a3a:	fb 1e       	adc	r15, r27
    9a3c:	6f 5f       	subi	r22, 0xFF	; 255
    9a3e:	6b 15       	cp	r22, r11
    9a40:	78 f3       	brcs	.-34     	; 0x9a20 <DigiFilt+0x100>
    9a42:	88 0c       	add	r8, r8
    9a44:	99 1c       	adc	r9, r9
    9a46:	94 01       	movw	r18, r8
    9a48:	44 27       	eor	r20, r20
    9a4a:	37 fd       	sbrc	r19, 7
    9a4c:	40 95       	com	r20
    9a4e:	54 2f       	mov	r21, r20
    9a50:	c7 01       	movw	r24, r14
    9a52:	b6 01       	movw	r22, r12
    9a54:	0e 94 a5 84 	call	0x1094a	; 0x1094a <__udivmodsi4>
    9a58:	c9 01       	movw	r24, r18
	return Sum/(Edge*2);
}
    9a5a:	0f b6       	in	r0, 0x3f	; 63
    9a5c:	f8 94       	cli
    9a5e:	7e be       	out	0x3e, r7	; 62
    9a60:	0f be       	out	0x3f, r0	; 63
    9a62:	6d be       	out	0x3d, r6	; 61
    9a64:	cf 91       	pop	r28
    9a66:	df 91       	pop	r29
    9a68:	1f 91       	pop	r17
    9a6a:	0f 91       	pop	r16
    9a6c:	ff 90       	pop	r15
    9a6e:	ef 90       	pop	r14
    9a70:	df 90       	pop	r13
    9a72:	cf 90       	pop	r12
    9a74:	bf 90       	pop	r11
    9a76:	9f 90       	pop	r9
    9a78:	8f 90       	pop	r8
    9a7a:	7f 90       	pop	r7
    9a7c:	6f 90       	pop	r6
    9a7e:	08 95       	ret
			if(Buf[j] > Buf[i]) {
				Swap = Buf[i];
				Buf[i] = Buf[j];
				Buf[j] = Swap;
			}
	for(i=Edge; i<_Edge; Sum+=Buf[i++]);
    9a80:	cc 24       	eor	r12, r12
    9a82:	dd 24       	eor	r13, r13
    9a84:	76 01       	movw	r14, r12
    9a86:	dd cf       	rjmp	.-70     	; 0x9a42 <DigiFilt+0x122>

00009a88 <MemFailReset>:

// ~~~~~~~~~~~~~~~
void
MemFailReset(void)
{
	if (MemFail &(1<<MemFail_EEPROM)) {
    9a88:	80 91 16 09 	lds	r24, 0x0916
    9a8c:	81 ff       	sbrs	r24, 1
    9a8e:	08 95       	ret
		MemFail &=~(1<<MemFail_EEPROM);
    9a90:	8d 7f       	andi	r24, 0xFD	; 253
    9a92:	80 93 16 09 	sts	0x0916, r24
		eeprom_write_word(&MemCheck_stor.CRC_EEPROM_stor, CRC_EEPROM_calc());
    9a96:	0e 94 b7 1a 	call	0x356e	; 0x356e <CRC_EEPROM_calc>
    9a9a:	bc 01       	movw	r22, r24
    9a9c:	8a e9       	ldi	r24, 0x9A	; 154
    9a9e:	91 e0       	ldi	r25, 0x01	; 1
    9aa0:	0e 94 4b 84 	call	0x10896	; 0x10896 <__eewr_word_m2560>
    9aa4:	08 95       	ret

00009aa6 <Key_Mem>:
		MenuPage Menu_BackUp = { SetMenu(Menu_BackUp_List), 1, NULL,
				NULL, NULL, NULL, Menu_BackUp_Enter, NULL, NULL, NULL};
#endif

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t Key_Mem(void) {if(CurrLine==3) MemFailReset(); return StandartKey;}
    9aa6:	80 91 c9 07 	lds	r24, 0x07C9
    9aaa:	83 30       	cpi	r24, 0x03	; 3
    9aac:	11 f0       	breq	.+4      	; 0x9ab2 <Key_Mem+0xc>
    9aae:	80 e0       	ldi	r24, 0x00	; 0
    9ab0:	08 95       	ret
    9ab2:	0e 94 44 4d 	call	0x9a88	; 0x9a88 <MemFailReset>
    9ab6:	80 e0       	ldi	r24, 0x00	; 0
    9ab8:	08 95       	ret

00009aba <CRC_EEPROM_upd>:
// ~~~~~~~~~~~~~~~~~
// Duration: 48 ms
static void
CRC_EEPROM_upd(void)
{
	if (!(MemFail &(1<<MemFail_EEPROM)))
    9aba:	80 91 16 09 	lds	r24, 0x0916
    9abe:	81 fd       	sbrc	r24, 1
    9ac0:	08 95       	ret
		eeprom_write_word(&MemCheck_stor.CRC_EEPROM_stor, CRC_EEPROM_calc());
    9ac2:	0e 94 b7 1a 	call	0x356e	; 0x356e <CRC_EEPROM_calc>
    9ac6:	bc 01       	movw	r22, r24
    9ac8:	8a e9       	ldi	r24, 0x9A	; 154
    9aca:	91 e0       	ldi	r25, 0x01	; 1
    9acc:	0e 94 4b 84 	call	0x10896	; 0x10896 <__eewr_word_m2560>
    9ad0:	08 95       	ret

00009ad2 <ewb>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ewb(uint8_t *addr, uint8_t val)
{
	//IntOff();
	eeprom_write_byte(addr, val);
    9ad2:	0e 94 35 84 	call	0x1086a	; 0x1086a <__eewr_byte_m2560>
	CRC_EEPROM_upd();
    9ad6:	0e 94 5d 4d 	call	0x9aba	; 0x9aba <CRC_EEPROM_upd>
	//IntOn();
}
    9ada:	08 95       	ret

00009adc <MB_M_TimeOff_Set>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_M_TimeOff_Set(uint8_t MB_N)
{
	ewb(&MB_M_Param_EE[MB_N].TimeOff, MB_M_TimeOff[MB_N]);
    9adc:	e8 2f       	mov	r30, r24
    9ade:	f0 e0       	ldi	r31, 0x00	; 0
    9ae0:	cf 01       	movw	r24, r30
    9ae2:	88 0f       	add	r24, r24
    9ae4:	99 1f       	adc	r25, r25
    9ae6:	88 0f       	add	r24, r24
    9ae8:	99 1f       	adc	r25, r25
    9aea:	8e 0f       	add	r24, r30
    9aec:	9f 1f       	adc	r25, r31
    9aee:	e1 52       	subi	r30, 0x21	; 33
    9af0:	fa 4f       	sbci	r31, 0xFA	; 250
    9af2:	8a 56       	subi	r24, 0x6A	; 106
    9af4:	9e 4f       	sbci	r25, 0xFE	; 254
    9af6:	60 81       	ld	r22, Z
    9af8:	0e 94 69 4d 	call	0x9ad2	; 0x9ad2 <ewb>
}
    9afc:	08 95       	ret

00009afe <MB_M_Try_Set>:

// ~~~~~~~~~~~~~~~~~~~~~~~
void
MB_M_Try_Set(uint8_t MB_N)
{
	ewb(&MB_M_Param_EE[MB_N].Try, MB_M_Try[MB_N]);
    9afe:	e8 2f       	mov	r30, r24
    9b00:	f0 e0       	ldi	r31, 0x00	; 0
    9b02:	cf 01       	movw	r24, r30
    9b04:	88 0f       	add	r24, r24
    9b06:	99 1f       	adc	r25, r25
    9b08:	88 0f       	add	r24, r24
    9b0a:	99 1f       	adc	r25, r25
    9b0c:	8e 0f       	add	r24, r30
    9b0e:	9f 1f       	adc	r25, r31
    9b10:	e1 5c       	subi	r30, 0xC1	; 193
    9b12:	f8 4f       	sbci	r31, 0xF8	; 248
    9b14:	8b 56       	subi	r24, 0x6B	; 107
    9b16:	9e 4f       	sbci	r25, 0xFE	; 254
    9b18:	60 81       	ld	r22, Z
    9b1a:	0e 94 69 4d 	call	0x9ad2	; 0x9ad2 <ewb>
}
    9b1e:	08 95       	ret

00009b20 <MB_M_Timeout_Set>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_M_Timeout_Set(uint8_t MB_N)
{
	ewb(&MB_M_Param_EE[MB_N].Timeout, MB_M_Timeout[MB_N]);
    9b20:	e8 2f       	mov	r30, r24
    9b22:	f0 e0       	ldi	r31, 0x00	; 0
    9b24:	cf 01       	movw	r24, r30
    9b26:	88 0f       	add	r24, r24
    9b28:	99 1f       	adc	r25, r25
    9b2a:	88 0f       	add	r24, r24
    9b2c:	99 1f       	adc	r25, r25
    9b2e:	8e 0f       	add	r24, r30
    9b30:	9f 1f       	adc	r25, r31
    9b32:	e8 5d       	subi	r30, 0xD8	; 216
    9b34:	f6 4f       	sbci	r31, 0xF6	; 246
    9b36:	8c 56       	subi	r24, 0x6C	; 108
    9b38:	9e 4f       	sbci	r25, 0xFE	; 254
    9b3a:	60 81       	ld	r22, Z
    9b3c:	0e 94 69 4d 	call	0x9ad2	; 0x9ad2 <ewb>
}
    9b40:	08 95       	ret

00009b42 <Set_MB_Addr>:
	static uint8_t EEMEM MB_NativeAddr_EE[Modbus_Qt] = Init_MB_NativeAddr;
	// ~~~~~~~~~~~~~~~~~~~~~~
	void
	Set_MB_Addr(uint8_t MB_N)
	{
		ewb(MB_NativeAddr_EE+MB_N, MB_NativeAddr[MB_N]);
    9b42:	e8 2f       	mov	r30, r24
    9b44:	f0 e0       	ldi	r31, 0x00	; 0
    9b46:	cf 01       	movw	r24, r30
    9b48:	89 56       	subi	r24, 0x69	; 105
    9b4a:	9e 4f       	sbci	r25, 0xFE	; 254
    9b4c:	e0 52       	subi	r30, 0x20	; 32
    9b4e:	fa 4f       	sbci	r31, 0xFA	; 250
    9b50:	60 81       	ld	r22, Z
    9b52:	0e 94 69 4d 	call	0x9ad2	; 0x9ad2 <ewb>
	}
    9b56:	08 95       	ret

00009b58 <eww>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
eww(uint16_t *addr, uint16_t val)
{
	//IntOff();
	eeprom_write_word(addr, val);
    9b58:	0e 94 4b 84 	call	0x10896	; 0x10896 <__eewr_word_m2560>
	CRC_EEPROM_upd();
    9b5c:	0e 94 5d 4d 	call	0x9aba	; 0x9aba <CRC_EEPROM_upd>
	//IntOn();
}
    9b60:	08 95       	ret

00009b62 <MB_M_Period_Set>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_M_Period_Set(uint8_t MB_N)
{
	eww(&MB_M_Param_EE[MB_N].Period, MB_M_Period[MB_N]);
    9b62:	e8 2f       	mov	r30, r24
    9b64:	f0 e0       	ldi	r31, 0x00	; 0
    9b66:	cf 01       	movw	r24, r30
    9b68:	88 0f       	add	r24, r24
    9b6a:	99 1f       	adc	r25, r25
    9b6c:	88 0f       	add	r24, r24
    9b6e:	99 1f       	adc	r25, r25
    9b70:	8e 0f       	add	r24, r30
    9b72:	9f 1f       	adc	r25, r31
    9b74:	ee 0f       	add	r30, r30
    9b76:	ff 1f       	adc	r31, r31
    9b78:	e3 55       	subi	r30, 0x53	; 83
    9b7a:	f9 4f       	sbci	r31, 0xF9	; 249
    9b7c:	60 81       	ld	r22, Z
    9b7e:	71 81       	ldd	r23, Z+1	; 0x01
    9b80:	8e 56       	subi	r24, 0x6E	; 110
    9b82:	9e 4f       	sbci	r25, 0xFE	; 254
    9b84:	0e 94 ac 4d 	call	0x9b58	; 0x9b58 <eww>
}
    9b88:	08 95       	ret

00009b8a <OnTimeSave>:

// ~~~~~~~~~~~~~
void
OnTimeSave(void)
{
	ewb(&Timer1min_EE, Timer1min);
    9b8a:	8d e9       	ldi	r24, 0x9D	; 157
    9b8c:	91 e0       	ldi	r25, 0x01	; 1
    9b8e:	60 91 b0 06 	lds	r22, 0x06B0
    9b92:	0e 94 69 4d 	call	0x9ad2	; 0x9ad2 <ewb>
	eww(&Timer1hour_EE, Timer1hour);
    9b96:	60 91 6a 0c 	lds	r22, 0x0C6A
    9b9a:	70 91 6b 0c 	lds	r23, 0x0C6B
    9b9e:	8e e9       	ldi	r24, 0x9E	; 158
    9ba0:	91 e0       	ldi	r25, 0x01	; 1
    9ba2:	0e 94 ac 4d 	call	0x9b58	; 0x9b58 <eww>
}
    9ba6:	08 95       	ret

00009ba8 <TimersInc>:
		HSC_Process();
	#endif
}
void 
TimersInc(void)
{
    9ba8:	ef 92       	push	r14
    9baa:	ff 92       	push	r15
    9bac:	0f 93       	push	r16
    9bae:	1f 93       	push	r17
    9bb0:	cf 93       	push	r28
    9bb2:	df 93       	push	r29
	uint8_t i, TickCounterVar;	
	cli();
    9bb4:	f8 94       	cli
	TickCounterVar = TickCounter;
    9bb6:	e0 90 d1 04 	lds	r14, 0x04D1
	TickCounter = 0;
    9bba:	10 92 d1 04 	sts	0x04D1, r1
	sei();
    9bbe:	78 94       	sei
	for(uint8_t j=0;j<TickCounterVar;j++){
    9bc0:	ee 20       	and	r14, r14
    9bc2:	09 f4       	brne	.+2      	; 0x9bc6 <TimersInc+0x1e>
    9bc4:	c8 c0       	rjmp	.+400    	; 0x9d56 <TimersInc+0x1ae>
    9bc6:	ff 24       	eor	r15, r15
		LiveTime++;
	 	for (i=0; i<Timer8TotNumber; i++){
			cli();
			if (!(Timer8Flg[i/8] &(1<<i%8)) && --Timer8[i]==0)
				Timer8Flg[i/8] |=(1<<i%8);
    9bc8:	01 e0       	ldi	r16, 0x01	; 1
    9bca:	10 e0       	ldi	r17, 0x00	; 0
	cli();
	TickCounterVar = TickCounter;
	TickCounter = 0;
	sei();
	for(uint8_t j=0;j<TickCounterVar;j++){
		LiveTime++;
    9bcc:	80 91 c4 07 	lds	r24, 0x07C4
    9bd0:	90 91 c5 07 	lds	r25, 0x07C5
    9bd4:	a0 91 c6 07 	lds	r26, 0x07C6
    9bd8:	b0 91 c7 07 	lds	r27, 0x07C7
    9bdc:	01 96       	adiw	r24, 0x01	; 1
    9bde:	a1 1d       	adc	r26, r1
    9be0:	b1 1d       	adc	r27, r1
    9be2:	80 93 c4 07 	sts	0x07C4, r24
    9be6:	90 93 c5 07 	sts	0x07C5, r25
    9bea:	a0 93 c6 07 	sts	0x07C6, r26
    9bee:	b0 93 c7 07 	sts	0x07C7, r27
    9bf2:	40 e0       	ldi	r20, 0x00	; 0
    9bf4:	50 e0       	ldi	r21, 0x00	; 0
	 	for (i=0; i<Timer8TotNumber; i++){
			cli();
    9bf6:	f8 94       	cli
			if (!(Timer8Flg[i/8] &(1<<i%8)) && --Timer8[i]==0)
    9bf8:	84 2f       	mov	r24, r20
    9bfa:	86 95       	lsr	r24
    9bfc:	86 95       	lsr	r24
    9bfe:	86 95       	lsr	r24
    9c00:	a8 2f       	mov	r26, r24
    9c02:	b0 e0       	ldi	r27, 0x00	; 0
    9c04:	af 54       	subi	r26, 0x4F	; 79
    9c06:	bb 4f       	sbci	r27, 0xFB	; 251
    9c08:	8c 91       	ld	r24, X
    9c0a:	ba 01       	movw	r22, r20
    9c0c:	67 70       	andi	r22, 0x07	; 7
    9c0e:	70 70       	andi	r23, 0x00	; 0
    9c10:	90 e0       	ldi	r25, 0x00	; 0
    9c12:	06 2e       	mov	r0, r22
    9c14:	02 c0       	rjmp	.+4      	; 0x9c1a <TimersInc+0x72>
    9c16:	95 95       	asr	r25
    9c18:	87 95       	ror	r24
    9c1a:	0a 94       	dec	r0
    9c1c:	e2 f7       	brpl	.-8      	; 0x9c16 <TimersInc+0x6e>
    9c1e:	80 fd       	sbrc	r24, 0
    9c20:	12 c0       	rjmp	.+36     	; 0x9c46 <TimersInc+0x9e>
    9c22:	fa 01       	movw	r30, r20
    9c24:	e9 50       	subi	r30, 0x09	; 9
    9c26:	fd 4f       	sbci	r31, 0xFD	; 253
    9c28:	80 81       	ld	r24, Z
    9c2a:	81 50       	subi	r24, 0x01	; 1
    9c2c:	80 83       	st	Z, r24
    9c2e:	80 81       	ld	r24, Z
    9c30:	88 23       	and	r24, r24
    9c32:	49 f4       	brne	.+18     	; 0x9c46 <TimersInc+0x9e>
				Timer8Flg[i/8] |=(1<<i%8);
    9c34:	2c 91       	ld	r18, X
    9c36:	c8 01       	movw	r24, r16
    9c38:	02 c0       	rjmp	.+4      	; 0x9c3e <TimersInc+0x96>
    9c3a:	88 0f       	add	r24, r24
    9c3c:	99 1f       	adc	r25, r25
    9c3e:	6a 95       	dec	r22
    9c40:	e2 f7       	brpl	.-8      	; 0x9c3a <TimersInc+0x92>
    9c42:	28 2b       	or	r18, r24
    9c44:	2c 93       	st	X, r18
			sei();
    9c46:	78 94       	sei
    9c48:	4f 5f       	subi	r20, 0xFF	; 255
    9c4a:	5f 4f       	sbci	r21, 0xFF	; 255
	TickCounterVar = TickCounter;
	TickCounter = 0;
	sei();
	for(uint8_t j=0;j<TickCounterVar;j++){
		LiveTime++;
	 	for (i=0; i<Timer8TotNumber; i++){
    9c4c:	48 35       	cpi	r20, 0x58	; 88
    9c4e:	51 05       	cpc	r21, r1
    9c50:	91 f6       	brne	.-92     	; 0x9bf6 <TimersInc+0x4e>
    9c52:	40 e0       	ldi	r20, 0x00	; 0
    9c54:	50 e0       	ldi	r21, 0x00	; 0
			if (!(Timer8Flg[i/8] &(1<<i%8)) && --Timer8[i]==0)
				Timer8Flg[i/8] |=(1<<i%8);
			sei();
		}
		for (i=0; i<Timer16TotNumber; i++){
			cli();
    9c56:	f8 94       	cli
			if (!(Timer16Flg[i/8] &(1<<i%8)) && --Timer16[i]==0)
    9c58:	84 2f       	mov	r24, r20
    9c5a:	86 95       	lsr	r24
    9c5c:	86 95       	lsr	r24
    9c5e:	86 95       	lsr	r24
    9c60:	a8 2f       	mov	r26, r24
    9c62:	b0 e0       	ldi	r27, 0x00	; 0
    9c64:	a3 54       	subi	r26, 0x43	; 67
    9c66:	bb 4f       	sbci	r27, 0xFB	; 251
    9c68:	8c 91       	ld	r24, X
    9c6a:	ba 01       	movw	r22, r20
    9c6c:	67 70       	andi	r22, 0x07	; 7
    9c6e:	70 70       	andi	r23, 0x00	; 0
    9c70:	90 e0       	ldi	r25, 0x00	; 0
    9c72:	06 2e       	mov	r0, r22
    9c74:	02 c0       	rjmp	.+4      	; 0x9c7a <TimersInc+0xd2>
    9c76:	95 95       	asr	r25
    9c78:	87 95       	ror	r24
    9c7a:	0a 94       	dec	r0
    9c7c:	e2 f7       	brpl	.-8      	; 0x9c76 <TimersInc+0xce>
    9c7e:	80 fd       	sbrc	r24, 0
    9c80:	17 c0       	rjmp	.+46     	; 0x9cb0 <TimersInc+0x108>
    9c82:	fa 01       	movw	r30, r20
    9c84:	ee 0f       	add	r30, r30
    9c86:	ff 1f       	adc	r31, r31
    9c88:	e1 5b       	subi	r30, 0xB1	; 177
    9c8a:	fc 4f       	sbci	r31, 0xFC	; 252
    9c8c:	80 81       	ld	r24, Z
    9c8e:	91 81       	ldd	r25, Z+1	; 0x01
    9c90:	01 97       	sbiw	r24, 0x01	; 1
    9c92:	91 83       	std	Z+1, r25	; 0x01
    9c94:	80 83       	st	Z, r24
    9c96:	80 81       	ld	r24, Z
    9c98:	91 81       	ldd	r25, Z+1	; 0x01
    9c9a:	89 2b       	or	r24, r25
    9c9c:	49 f4       	brne	.+18     	; 0x9cb0 <TimersInc+0x108>
				Timer16Flg[i/8] |=(1<<i%8);
    9c9e:	2c 91       	ld	r18, X
    9ca0:	c8 01       	movw	r24, r16
    9ca2:	02 c0       	rjmp	.+4      	; 0x9ca8 <TimersInc+0x100>
    9ca4:	88 0f       	add	r24, r24
    9ca6:	99 1f       	adc	r25, r25
    9ca8:	6a 95       	dec	r22
    9caa:	e2 f7       	brpl	.-8      	; 0x9ca4 <TimersInc+0xfc>
    9cac:	28 2b       	or	r18, r24
    9cae:	2c 93       	st	X, r18
			sei();
    9cb0:	78 94       	sei
    9cb2:	4f 5f       	subi	r20, 0xFF	; 255
    9cb4:	5f 4f       	sbci	r21, 0xFF	; 255
			cli();
			if (!(Timer8Flg[i/8] &(1<<i%8)) && --Timer8[i]==0)
				Timer8Flg[i/8] |=(1<<i%8);
			sei();
		}
		for (i=0; i<Timer16TotNumber; i++){
    9cb6:	40 36       	cpi	r20, 0x60	; 96
    9cb8:	51 05       	cpc	r21, r1
    9cba:	69 f6       	brne	.-102    	; 0x9c56 <TimersInc+0xae>
    9cbc:	40 e0       	ldi	r20, 0x00	; 0
    9cbe:	50 e0       	ldi	r21, 0x00	; 0
			if (!(Timer16Flg[i/8] &(1<<i%8)) && --Timer16[i]==0)
				Timer16Flg[i/8] |=(1<<i%8);
			sei();
		}
		for (i=0; i<Timer32TotNumber; i++){
			cli();
    9cc0:	f8 94       	cli
			if (!(Timer32Flg[i/8] &(1<<i%8)) && --Timer32[i]==0)
    9cc2:	84 2f       	mov	r24, r20
    9cc4:	86 95       	lsr	r24
    9cc6:	86 95       	lsr	r24
    9cc8:	86 95       	lsr	r24
    9cca:	c8 2f       	mov	r28, r24
    9ccc:	d0 e0       	ldi	r29, 0x00	; 0
    9cce:	c6 53       	subi	r28, 0x36	; 54
    9cd0:	db 4f       	sbci	r29, 0xFB	; 251
    9cd2:	88 81       	ld	r24, Y
    9cd4:	ba 01       	movw	r22, r20
    9cd6:	67 70       	andi	r22, 0x07	; 7
    9cd8:	70 70       	andi	r23, 0x00	; 0
    9cda:	90 e0       	ldi	r25, 0x00	; 0
    9cdc:	06 2e       	mov	r0, r22
    9cde:	02 c0       	rjmp	.+4      	; 0x9ce4 <TimersInc+0x13c>
    9ce0:	95 95       	asr	r25
    9ce2:	87 95       	ror	r24
    9ce4:	0a 94       	dec	r0
    9ce6:	e2 f7       	brpl	.-8      	; 0x9ce0 <TimersInc+0x138>
    9ce8:	80 fd       	sbrc	r24, 0
    9cea:	23 c0       	rjmp	.+70     	; 0x9d32 <TimersInc+0x18a>
    9cec:	fa 01       	movw	r30, r20
    9cee:	ee 0f       	add	r30, r30
    9cf0:	ff 1f       	adc	r31, r31
    9cf2:	ee 0f       	add	r30, r30
    9cf4:	ff 1f       	adc	r31, r31
    9cf6:	e1 5f       	subi	r30, 0xF1	; 241
    9cf8:	fb 4f       	sbci	r31, 0xFB	; 251
    9cfa:	80 81       	ld	r24, Z
    9cfc:	91 81       	ldd	r25, Z+1	; 0x01
    9cfe:	a2 81       	ldd	r26, Z+2	; 0x02
    9d00:	b3 81       	ldd	r27, Z+3	; 0x03
    9d02:	01 97       	sbiw	r24, 0x01	; 1
    9d04:	a1 09       	sbc	r26, r1
    9d06:	b1 09       	sbc	r27, r1
    9d08:	80 83       	st	Z, r24
    9d0a:	91 83       	std	Z+1, r25	; 0x01
    9d0c:	a2 83       	std	Z+2, r26	; 0x02
    9d0e:	b3 83       	std	Z+3, r27	; 0x03
    9d10:	80 81       	ld	r24, Z
    9d12:	91 81       	ldd	r25, Z+1	; 0x01
    9d14:	a2 81       	ldd	r26, Z+2	; 0x02
    9d16:	b3 81       	ldd	r27, Z+3	; 0x03
    9d18:	00 97       	sbiw	r24, 0x00	; 0
    9d1a:	a1 05       	cpc	r26, r1
    9d1c:	b1 05       	cpc	r27, r1
    9d1e:	49 f4       	brne	.+18     	; 0x9d32 <TimersInc+0x18a>
				Timer32Flg[i/8] |=(1<<i%8);	
    9d20:	28 81       	ld	r18, Y
    9d22:	c8 01       	movw	r24, r16
    9d24:	02 c0       	rjmp	.+4      	; 0x9d2a <TimersInc+0x182>
    9d26:	88 0f       	add	r24, r24
    9d28:	99 1f       	adc	r25, r25
    9d2a:	6a 95       	dec	r22
    9d2c:	e2 f7       	brpl	.-8      	; 0x9d26 <TimersInc+0x17e>
    9d2e:	28 2b       	or	r18, r24
    9d30:	28 83       	st	Y, r18
			sei();
    9d32:	78 94       	sei
    9d34:	4f 5f       	subi	r20, 0xFF	; 255
    9d36:	5f 4f       	sbci	r21, 0xFF	; 255
			cli();
			if (!(Timer16Flg[i/8] &(1<<i%8)) && --Timer16[i]==0)
				Timer16Flg[i/8] |=(1<<i%8);
			sei();
		}
		for (i=0; i<Timer32TotNumber; i++){
    9d38:	48 32       	cpi	r20, 0x28	; 40
    9d3a:	51 05       	cpc	r21, r1
    9d3c:	09 f0       	breq	.+2      	; 0x9d40 <TimersInc+0x198>
    9d3e:	c0 cf       	rjmp	.-128    	; 0x9cc0 <TimersInc+0x118>
			sei();
		}

		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		static uint8_t Timer10ms;
		if (++Timer10ms==100) {
    9d40:	80 91 ed 02 	lds	r24, 0x02ED
    9d44:	8f 5f       	subi	r24, 0xFF	; 255
    9d46:	80 93 ed 02 	sts	0x02ED, r24
    9d4a:	84 36       	cpi	r24, 0x64	; 100
    9d4c:	59 f0       	breq	.+22     	; 0x9d64 <TimersInc+0x1bc>
	uint8_t i, TickCounterVar;	
	cli();
	TickCounterVar = TickCounter;
	TickCounter = 0;
	sei();
	for(uint8_t j=0;j<TickCounterVar;j++){
    9d4e:	f3 94       	inc	r15
    9d50:	fe 14       	cp	r15, r14
    9d52:	08 f4       	brcc	.+2      	; 0x9d56 <TimersInc+0x1ae>
    9d54:	3b cf       	rjmp	.-394    	; 0x9bcc <TimersInc+0x24>
 			ScanCount = 0;
			RT();
		}
		#endif
	}
}
    9d56:	df 91       	pop	r29
    9d58:	cf 91       	pop	r28
    9d5a:	1f 91       	pop	r17
    9d5c:	0f 91       	pop	r16
    9d5e:	ff 90       	pop	r15
    9d60:	ef 90       	pop	r14
    9d62:	08 95       	ret
		}

		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		static uint8_t Timer10ms;
		if (++Timer10ms==100) {
			Timer10ms = 0;
    9d64:	10 92 ed 02 	sts	0x02ED, r1
			ScanPerSec = ScanCount;
    9d68:	80 91 b2 07 	lds	r24, 0x07B2
    9d6c:	90 91 b3 07 	lds	r25, 0x07B3
    9d70:	90 93 ce 07 	sts	0x07CE, r25
    9d74:	80 93 cd 07 	sts	0x07CD, r24
 			ScanCount = 0;
    9d78:	10 92 b3 07 	sts	0x07B3, r1
    9d7c:	10 92 b2 07 	sts	0x07B2, r1

// ~~~~~~~~~~~~~~~
inline static void
RT(void)
{
	if (++Timer1s==60) {
    9d80:	80 91 19 09 	lds	r24, 0x0919
    9d84:	8f 5f       	subi	r24, 0xFF	; 255
    9d86:	80 93 19 09 	sts	0x0919, r24
    9d8a:	8c 33       	cpi	r24, 0x3C	; 60
    9d8c:	01 f7       	brne	.-64     	; 0x9d4e <TimersInc+0x1a6>
		Timer1s = 0;
    9d8e:	10 92 19 09 	sts	0x0919, r1
		if (++Timer1min==60) {
    9d92:	80 91 b0 06 	lds	r24, 0x06B0
    9d96:	8f 5f       	subi	r24, 0xFF	; 255
    9d98:	80 93 b0 06 	sts	0x06B0, r24
    9d9c:	8c 33       	cpi	r24, 0x3C	; 60
    9d9e:	b9 f6       	brne	.-82     	; 0x9d4e <TimersInc+0x1a6>
			Timer1min = 0;
    9da0:	10 92 b0 06 	sts	0x06B0, r1
			++Timer1hour;
    9da4:	80 91 6a 0c 	lds	r24, 0x0C6A
    9da8:	90 91 6b 0c 	lds	r25, 0x0C6B
    9dac:	01 96       	adiw	r24, 0x01	; 1
    9dae:	90 93 6b 0c 	sts	0x0C6B, r25
    9db2:	80 93 6a 0c 	sts	0x0C6A, r24
			OnTimeSave();
    9db6:	0e 94 c5 4d 	call	0x9b8a	; 0x9b8a <OnTimeSave>
    9dba:	c9 cf       	rjmp	.-110    	; 0x9d4e <TimersInc+0x1a6>

00009dbc <ewbl>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ewbl(const void *src, void *dst, size_t n)
{
	//IntOff();
	eeprom_write_block(src, dst, n);
    9dbc:	0e 94 2b 84 	call	0x10856	; 0x10856 <__eewr_block_m2560>
	CRC_EEPROM_upd();
    9dc0:	0e 94 5d 4d 	call	0x9aba	; 0x9aba <CRC_EEPROM_upd>
	//IntOn();
}
    9dc4:	08 95       	ret

00009dc6 <ewd>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ewd(uint32_t *addr, uint32_t val)
{
	//IntOff();
	eeprom_write_dword(addr, val);
    9dc6:	0e 94 43 84 	call	0x10886	; 0x10886 <__eewr_dword_m2560>
	CRC_EEPROM_upd();
    9dca:	0e 94 5d 4d 	call	0x9aba	; 0x9aba <CRC_EEPROM_upd>
	//IntOn();
}
    9dce:	08 95       	ret

00009dd0 <erbl>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    9dd0:	0e 94 07 84 	call	0x1080e	; 0x1080e <__eerd_block_m2560>
	//IntOn();
}
    9dd4:	08 95       	ret

00009dd6 <erd>:
// ~~~~~~~~~~~~~~~~~~~~~~
uint32_t
erd(const uint32_t *addr)
{
	//IntOff();
	uint32_t word = eeprom_read_dword(addr);
    9dd6:	0e 94 1f 84 	call	0x1083e	; 0x1083e <__eerd_dword_m2560>
	//IntOn();
	return word;
}
    9dda:	08 95       	ret

00009ddc <erw>:
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    9ddc:	0e 94 25 84 	call	0x1084a	; 0x1084a <__eerd_word_m2560>
	//IntOn();
	return word;
}
    9de0:	08 95       	ret

00009de2 <EE_InterBrokLine>:
	uint8_t WiAbsc, uint16_t (*TblAbsc)[WiAbsc], uint8_t Absc,
	uint8_t WiOrdi, uint16_t (*TblOrdi)[WiOrdi], uint8_t Ordi,
	uint8_t Len,
	int16_t x
)
{
    9de2:	2f 92       	push	r2
    9de4:	3f 92       	push	r3
    9de6:	4f 92       	push	r4
    9de8:	5f 92       	push	r5
    9dea:	6f 92       	push	r6
    9dec:	7f 92       	push	r7
    9dee:	8f 92       	push	r8
    9df0:	9f 92       	push	r9
    9df2:	af 92       	push	r10
    9df4:	bf 92       	push	r11
    9df6:	cf 92       	push	r12
    9df8:	df 92       	push	r13
    9dfa:	ef 92       	push	r14
    9dfc:	ff 92       	push	r15
    9dfe:	0f 93       	push	r16
    9e00:	1f 93       	push	r17
    9e02:	df 93       	push	r29
    9e04:	cf 93       	push	r28
    9e06:	cd b7       	in	r28, 0x3d	; 61
    9e08:	de b7       	in	r29, 0x3e	; 62
    9e0a:	2e 97       	sbiw	r28, 0x0e	; 14
    9e0c:	0f b6       	in	r0, 0x3f	; 63
    9e0e:	f8 94       	cli
    9e10:	de bf       	out	0x3e, r29	; 62
    9e12:	0f be       	out	0x3f, r0	; 63
    9e14:	cd bf       	out	0x3d, r28	; 61
    9e16:	f8 2e       	mov	r15, r24
    9e18:	2b 01       	movw	r4, r22
    9e1a:	2d 87       	std	Y+13, r18	; 0x0d
    9e1c:	18 01       	movw	r2, r16
    9e1e:	ee 86       	std	Y+14, r14	; 0x0e
    9e20:	0c 2d       	mov	r16, r12
	LineGraph Segm;
	uint8_t i = 0;
	Segm.x2 = (int16_t)erw(TblAbsc[0]+Absc);
    9e22:	c4 2e       	mov	r12, r20
    9e24:	dd 24       	eor	r13, r13
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    9e26:	c6 01       	movw	r24, r12
    9e28:	88 0f       	add	r24, r24
    9e2a:	99 1f       	adc	r25, r25
    9e2c:	86 0f       	add	r24, r22
    9e2e:	97 1f       	adc	r25, r23
    9e30:	0e 94 25 84 	call	0x1084a	; 0x1084a <__eerd_word_m2560>
    9e34:	aa 27       	eor	r26, r26
    9e36:	97 fd       	sbrc	r25, 7
    9e38:	a0 95       	com	r26
    9e3a:	ba 2f       	mov	r27, r26
    9e3c:	8d 83       	std	Y+5, r24	; 0x05
    9e3e:	9e 83       	std	Y+6, r25	; 0x06
    9e40:	af 83       	std	Y+7, r26	; 0x07
    9e42:	b8 87       	std	Y+8, r27	; 0x08
    9e44:	ef 2c       	mov	r14, r15
    9e46:	ff 24       	eor	r15, r15
    9e48:	35 01       	movw	r6, r10
    9e4a:	88 24       	eor	r8, r8
    9e4c:	77 fc       	sbrc	r7, 7
    9e4e:	80 94       	com	r8
    9e50:	98 2c       	mov	r9, r8
    9e52:	10 e0       	ldi	r17, 0x00	; 0
    9e54:	9c 01       	movw	r18, r24
    9e56:	ad 01       	movw	r20, r26
	do {
		Segm.x1 = Segm.x2;
    9e58:	29 83       	std	Y+1, r18	; 0x01
    9e5a:	3a 83       	std	Y+2, r19	; 0x02
    9e5c:	4b 83       	std	Y+3, r20	; 0x03
    9e5e:	5c 83       	std	Y+4, r21	; 0x04
		Segm.x2 = (int16_t)erw(TblAbsc[++i]+Absc);
    9e60:	1f 5f       	subi	r17, 0xFF	; 255
    9e62:	a1 2e       	mov	r10, r17
    9e64:	bb 24       	eor	r11, r11
    9e66:	ae 9c       	mul	r10, r14
    9e68:	c0 01       	movw	r24, r0
    9e6a:	af 9c       	mul	r10, r15
    9e6c:	90 0d       	add	r25, r0
    9e6e:	be 9c       	mul	r11, r14
    9e70:	90 0d       	add	r25, r0
    9e72:	11 24       	eor	r1, r1
    9e74:	8c 0d       	add	r24, r12
    9e76:	9d 1d       	adc	r25, r13
    9e78:	88 0f       	add	r24, r24
    9e7a:	99 1f       	adc	r25, r25
    9e7c:	84 0d       	add	r24, r4
    9e7e:	95 1d       	adc	r25, r5
    9e80:	0e 94 25 84 	call	0x1084a	; 0x1084a <__eerd_word_m2560>
    9e84:	9c 01       	movw	r18, r24
    9e86:	44 27       	eor	r20, r20
    9e88:	37 fd       	sbrc	r19, 7
    9e8a:	40 95       	com	r20
    9e8c:	54 2f       	mov	r21, r20
    9e8e:	2d 83       	std	Y+5, r18	; 0x05
    9e90:	3e 83       	std	Y+6, r19	; 0x06
    9e92:	4f 83       	std	Y+7, r20	; 0x07
    9e94:	58 87       	std	Y+8, r21	; 0x08
	} while(x>Segm.x2 && i<Len);
    9e96:	26 15       	cp	r18, r6
    9e98:	37 05       	cpc	r19, r7
    9e9a:	48 05       	cpc	r20, r8
    9e9c:	59 05       	cpc	r21, r9
    9e9e:	14 f4       	brge	.+4      	; 0x9ea4 <EE_InterBrokLine+0xc2>
    9ea0:	10 17       	cp	r17, r16
    9ea2:	d0 f2       	brcs	.-76     	; 0x9e58 <EE_InterBrokLine+0x76>
	Segm.y1 = (int16_t)erw(TblOrdi[i-1]+Ordi);
    9ea4:	8d 85       	ldd	r24, Y+13	; 0x0d
    9ea6:	08 2f       	mov	r16, r24
    9ea8:	10 e0       	ldi	r17, 0x00	; 0
    9eaa:	8e 85       	ldd	r24, Y+14	; 0x0e
    9eac:	e8 2e       	mov	r14, r24
    9eae:	ff 24       	eor	r15, r15
    9eb0:	08 94       	sec
    9eb2:	a1 08       	sbc	r10, r1
    9eb4:	b1 08       	sbc	r11, r1
    9eb6:	a0 9e       	mul	r10, r16
    9eb8:	c0 01       	movw	r24, r0
    9eba:	a1 9e       	mul	r10, r17
    9ebc:	90 0d       	add	r25, r0
    9ebe:	b0 9e       	mul	r11, r16
    9ec0:	90 0d       	add	r25, r0
    9ec2:	11 24       	eor	r1, r1
    9ec4:	08 94       	sec
    9ec6:	a1 1c       	adc	r10, r1
    9ec8:	b1 1c       	adc	r11, r1
    9eca:	8e 0d       	add	r24, r14
    9ecc:	9f 1d       	adc	r25, r15
    9ece:	88 0f       	add	r24, r24
    9ed0:	99 1f       	adc	r25, r25
    9ed2:	82 0d       	add	r24, r2
    9ed4:	93 1d       	adc	r25, r3
    9ed6:	0e 94 25 84 	call	0x1084a	; 0x1084a <__eerd_word_m2560>
    9eda:	9a 87       	std	Y+10, r25	; 0x0a
    9edc:	89 87       	std	Y+9, r24	; 0x09
    9ede:	a0 9e       	mul	r10, r16
    9ee0:	c0 01       	movw	r24, r0
    9ee2:	a1 9e       	mul	r10, r17
    9ee4:	90 0d       	add	r25, r0
    9ee6:	b0 9e       	mul	r11, r16
    9ee8:	90 0d       	add	r25, r0
    9eea:	11 24       	eor	r1, r1
    9eec:	8e 0d       	add	r24, r14
    9eee:	9f 1d       	adc	r25, r15
    9ef0:	88 0f       	add	r24, r24
    9ef2:	99 1f       	adc	r25, r25
    9ef4:	82 0d       	add	r24, r2
    9ef6:	93 1d       	adc	r25, r3
    9ef8:	0e 94 25 84 	call	0x1084a	; 0x1084a <__eerd_word_m2560>
	Segm.y2 = (int16_t)erw(TblOrdi[i]+Ordi);
    9efc:	9c 87       	std	Y+12, r25	; 0x0c
    9efe:	8b 87       	std	Y+11, r24	; 0x0b
	return LineFunc(&Segm, x);
    9f00:	ce 01       	movw	r24, r28
    9f02:	01 96       	adiw	r24, 0x01	; 1
    9f04:	b4 01       	movw	r22, r8
    9f06:	a3 01       	movw	r20, r6
    9f08:	0e 94 07 22 	call	0x440e	; 0x440e <LineFunc>
}
    9f0c:	2e 96       	adiw	r28, 0x0e	; 14
    9f0e:	0f b6       	in	r0, 0x3f	; 63
    9f10:	f8 94       	cli
    9f12:	de bf       	out	0x3e, r29	; 62
    9f14:	0f be       	out	0x3f, r0	; 63
    9f16:	cd bf       	out	0x3d, r28	; 61
    9f18:	cf 91       	pop	r28
    9f1a:	df 91       	pop	r29
    9f1c:	1f 91       	pop	r17
    9f1e:	0f 91       	pop	r16
    9f20:	ff 90       	pop	r15
    9f22:	ef 90       	pop	r14
    9f24:	df 90       	pop	r13
    9f26:	cf 90       	pop	r12
    9f28:	bf 90       	pop	r11
    9f2a:	af 90       	pop	r10
    9f2c:	9f 90       	pop	r9
    9f2e:	8f 90       	pop	r8
    9f30:	7f 90       	pop	r7
    9f32:	6f 90       	pop	r6
    9f34:	5f 90       	pop	r5
    9f36:	4f 90       	pop	r4
    9f38:	3f 90       	pop	r3
    9f3a:	2f 90       	pop	r2
    9f3c:	08 95       	ret

00009f3e <MemCheck>:
}

// ~~~~~~~~~~~
uint8_t
MemCheck(void)
{
    9f3e:	0f 93       	push	r16
    9f40:	1f 93       	push	r17
//	uint8_t T = Timer32Stopp(TD_Mem);
//	if (T) {
//		StartTimer32(TD_Mem, 360000);
		if (!(MemFail &(1<<MemFail_Flash)) && CRC_Flash_calc()!=erw(&MemCheck_stor.CRC_Flash_stor))
    9f42:	80 91 16 09 	lds	r24, 0x0916
    9f46:	80 ff       	sbrs	r24, 0
    9f48:	17 c0       	rjmp	.+46     	; 0x9f78 <MemCheck+0x3a>
			MemFail |=(1<<MemFail_Flash);
		if (!(MemFail &(1<<MemFail_EEPROM)) && CRC_EEPROM_calc()!=erw(&MemCheck_stor.CRC_EEPROM_stor))
    9f4a:	81 ff       	sbrs	r24, 1
    9f4c:	03 c0       	rjmp	.+6      	; 0x9f54 <MemCheck+0x16>
			MemFail |=(1<<MemFail_EEPROM);
//	}
//	return T && MemFail;
	return MemFail;
}
    9f4e:	1f 91       	pop	r17
    9f50:	0f 91       	pop	r16
    9f52:	08 95       	ret
//	uint8_t T = Timer32Stopp(TD_Mem);
//	if (T) {
//		StartTimer32(TD_Mem, 360000);
		if (!(MemFail &(1<<MemFail_Flash)) && CRC_Flash_calc()!=erw(&MemCheck_stor.CRC_Flash_stor))
			MemFail |=(1<<MemFail_Flash);
		if (!(MemFail &(1<<MemFail_EEPROM)) && CRC_EEPROM_calc()!=erw(&MemCheck_stor.CRC_EEPROM_stor))
    9f54:	0e 94 b7 1a 	call	0x356e	; 0x356e <CRC_EEPROM_calc>
    9f58:	8c 01       	movw	r16, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    9f5a:	8a e9       	ldi	r24, 0x9A	; 154
    9f5c:	91 e0       	ldi	r25, 0x01	; 1
    9f5e:	0e 94 25 84 	call	0x1084a	; 0x1084a <__eerd_word_m2560>
//	uint8_t T = Timer32Stopp(TD_Mem);
//	if (T) {
//		StartTimer32(TD_Mem, 360000);
		if (!(MemFail &(1<<MemFail_Flash)) && CRC_Flash_calc()!=erw(&MemCheck_stor.CRC_Flash_stor))
			MemFail |=(1<<MemFail_Flash);
		if (!(MemFail &(1<<MemFail_EEPROM)) && CRC_EEPROM_calc()!=erw(&MemCheck_stor.CRC_EEPROM_stor))
    9f62:	08 17       	cp	r16, r24
    9f64:	19 07       	cpc	r17, r25
    9f66:	d9 f0       	breq	.+54     	; 0x9f9e <MemCheck+0x60>
			MemFail |=(1<<MemFail_EEPROM);
    9f68:	80 91 16 09 	lds	r24, 0x0916
    9f6c:	82 60       	ori	r24, 0x02	; 2
    9f6e:	80 93 16 09 	sts	0x0916, r24
//	}
//	return T && MemFail;
	return MemFail;
}
    9f72:	1f 91       	pop	r17
    9f74:	0f 91       	pop	r16
    9f76:	08 95       	ret
MemCheck(void)
{
//	uint8_t T = Timer32Stopp(TD_Mem);
//	if (T) {
//		StartTimer32(TD_Mem, 360000);
		if (!(MemFail &(1<<MemFail_Flash)) && CRC_Flash_calc()!=erw(&MemCheck_stor.CRC_Flash_stor))
    9f78:	0e 94 9d 1a 	call	0x353a	; 0x353a <CRC_Flash_calc>
    9f7c:	8c 01       	movw	r16, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    9f7e:	88 e9       	ldi	r24, 0x98	; 152
    9f80:	91 e0       	ldi	r25, 0x01	; 1
    9f82:	0e 94 25 84 	call	0x1084a	; 0x1084a <__eerd_word_m2560>
MemCheck(void)
{
//	uint8_t T = Timer32Stopp(TD_Mem);
//	if (T) {
//		StartTimer32(TD_Mem, 360000);
		if (!(MemFail &(1<<MemFail_Flash)) && CRC_Flash_calc()!=erw(&MemCheck_stor.CRC_Flash_stor))
    9f86:	08 17       	cp	r16, r24
    9f88:	19 07       	cpc	r17, r25
    9f8a:	31 f0       	breq	.+12     	; 0x9f98 <MemCheck+0x5a>
			MemFail |=(1<<MemFail_Flash);
    9f8c:	80 91 16 09 	lds	r24, 0x0916
    9f90:	81 60       	ori	r24, 0x01	; 1
    9f92:	80 93 16 09 	sts	0x0916, r24
    9f96:	d9 cf       	rjmp	.-78     	; 0x9f4a <MemCheck+0xc>
    9f98:	80 91 16 09 	lds	r24, 0x0916
    9f9c:	d6 cf       	rjmp	.-84     	; 0x9f4a <MemCheck+0xc>
    9f9e:	80 91 16 09 	lds	r24, 0x0916
    9fa2:	d5 cf       	rjmp	.-86     	; 0x9f4e <MemCheck+0x10>

00009fa4 <MemCheckMsg>:

// ~~~~~~~~~~~~~~
void
MemCheckMsg(void)
{
	if(MemCheck())
    9fa4:	0e 94 9f 4f 	call	0x9f3e	; 0x9f3e <MemCheck>
    9fa8:	88 23       	and	r24, r24
    9faa:	09 f4       	brne	.+2      	; 0x9fae <MemCheckMsg+0xa>
    9fac:	08 95       	ret

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    9fae:	80 91 16 09 	lds	r24, 0x0916
    9fb2:	e8 2f       	mov	r30, r24
    9fb4:	f0 e0       	ldi	r31, 0x00	; 0
    9fb6:	ee 0f       	add	r30, r30
    9fb8:	ff 1f       	adc	r31, r31
    9fba:	e9 5a       	subi	r30, 0xA9	; 169
    9fbc:	f8 4e       	sbci	r31, 0xE8	; 232
		ShowMsg(prp(MsgErrMemo+MemFail));
    9fbe:	85 91       	lpm	r24, Z+
    9fc0:	94 91       	lpm	r25, Z+
    9fc2:	0e 94 b8 3d 	call	0x7b70	; 0x7b70 <ShowMsg>
    9fc6:	08 95       	ret

00009fc8 <erb>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    9fc8:	0e 94 17 84 	call	0x1082e	; 0x1082e <__eerd_byte_m2560>
	//IntOn();
	return byte;
}
    9fcc:	08 95       	ret

00009fce <ThermChanWrong>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
ThermChanWrong(uint8_t ChanN)
{
    9fce:	ff 92       	push	r15
    9fd0:	0f 93       	push	r16
    9fd2:	1f 93       	push	r17
	return ThermWrong(prb(ThermFami+ChanN), erb(ThermType+ChanN), Temperature[ChanN]);
    9fd4:	08 2f       	mov	r16, r24
    9fd6:	10 e0       	ldi	r17, 0x00	; 0

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    9fd8:	f8 01       	movw	r30, r16
    9fda:	e3 54       	subi	r30, 0x43	; 67
    9fdc:	f9 4f       	sbci	r31, 0xF9	; 249
    9fde:	f4 90       	lpm	r15, Z+
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    9fe0:	c8 01       	movw	r24, r16
    9fe2:	89 5e       	subi	r24, 0xE9	; 233
    9fe4:	9e 4f       	sbci	r25, 0xFE	; 254
    9fe6:	0e 94 17 84 	call	0x1082e	; 0x1082e <__eerd_byte_m2560>
    9fea:	68 2f       	mov	r22, r24
    9fec:	00 0f       	add	r16, r16
    9fee:	11 1f       	adc	r17, r17
    9ff0:	0b 5b       	subi	r16, 0xBB	; 187
    9ff2:	19 4f       	sbci	r17, 0xF9	; 249
    9ff4:	f8 01       	movw	r30, r16
    9ff6:	40 81       	ld	r20, Z
    9ff8:	51 81       	ldd	r21, Z+1	; 0x01
    9ffa:	8f 2d       	mov	r24, r15
    9ffc:	0e 94 d8 40 	call	0x81b0	; 0x81b0 <ThermWrong>
}
    a000:	1f 91       	pop	r17
    a002:	0f 91       	pop	r16
    a004:	ff 90       	pop	r15
    a006:	08 95       	ret

0000a008 <ThermChan>:
}

// ~~~~~~~~~~~~~~~~~~~~~
void
ThermChan(uint8_t ChanN)
{
    a008:	8f 92       	push	r8
    a00a:	9f 92       	push	r9
    a00c:	af 92       	push	r10
    a00e:	bf 92       	push	r11
    a010:	cf 92       	push	r12
    a012:	df 92       	push	r13
    a014:	ef 92       	push	r14
    a016:	ff 92       	push	r15
    a018:	0f 93       	push	r16
    a01a:	1f 93       	push	r17
    a01c:	cf 93       	push	r28
    a01e:	df 93       	push	r29
	if (ChanN>=TerReg)
    a020:	86 30       	cpi	r24, 0x06	; 6
    a022:	08 f0       	brcs	.+2      	; 0xa026 <ThermChan+0x1e>
    a024:	4c c0       	rjmp	.+152    	; 0xa0be <ThermChan+0xb6>
		return;
    a026:	e8 2e       	mov	r14, r24
    a028:	ff 24       	eor	r15, r15
    a02a:	d7 01       	movw	r26, r14
    a02c:	aa 0f       	add	r26, r26
    a02e:	bb 1f       	adc	r27, r27
    a030:	a2 95       	swap	r26
    a032:	b2 95       	swap	r27
    a034:	b0 7f       	andi	r27, 0xF0	; 240
    a036:	ba 27       	eor	r27, r26
    a038:	a0 7f       	andi	r26, 0xF0	; 240
    a03a:	ba 27       	eor	r27, r26
    a03c:	fd 01       	movw	r30, r26
    a03e:	e3 5e       	subi	r30, 0xE3	; 227
    a040:	fa 4f       	sbci	r31, 0xFA	; 250
    a042:	2f e0       	ldi	r18, 0x0F	; 15
	for (uint8_t i=TerFiltLev*4-1; i; i--)
		TerBuf[ChanN][i] = TerBuf[ChanN][i-1];
    a044:	80 81       	ld	r24, Z
    a046:	91 81       	ldd	r25, Z+1	; 0x01
    a048:	93 83       	std	Z+3, r25	; 0x03
    a04a:	82 83       	std	Z+2, r24	; 0x02
void
ThermChan(uint8_t ChanN)
{
	if (ChanN>=TerReg)
		return;
	for (uint8_t i=TerFiltLev*4-1; i; i--)
    a04c:	21 50       	subi	r18, 0x01	; 1
    a04e:	32 97       	sbiw	r30, 0x02	; 2
    a050:	22 23       	and	r18, r18
    a052:	c1 f7       	brne	.-16     	; 0xa044 <ThermChan+0x3c>
		TerBuf[ChanN][i] = TerBuf[ChanN][i-1];
	TerBuf[ChanN][0] = TerInput[ChanN];
    a054:	af 5f       	subi	r26, 0xFF	; 255
    a056:	ba 4f       	sbci	r27, 0xFA	; 250
    a058:	47 01       	movw	r8, r14
    a05a:	88 0c       	add	r8, r8
    a05c:	99 1c       	adc	r9, r9
    a05e:	f4 01       	movw	r30, r8
    a060:	e6 5e       	subi	r30, 0xE6	; 230
    a062:	f6 4f       	sbci	r31, 0xF6	; 246
    a064:	80 81       	ld	r24, Z
    a066:	91 81       	ldd	r25, Z+1	; 0x01
    a068:	8d 93       	st	X+, r24
    a06a:	9c 93       	st	X, r25

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    a06c:	f7 01       	movw	r30, r14
    a06e:	e3 54       	subi	r30, 0x43	; 67
    a070:	f9 4f       	sbci	r31, 0xF9	; 249
    a072:	c4 90       	lpm	r12, Z+
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    a074:	c7 01       	movw	r24, r14
    a076:	89 5e       	subi	r24, 0xE9	; 233
    a078:	9e 4f       	sbci	r25, 0xFE	; 254
    a07a:	0e 94 17 84 	call	0x1082e	; 0x1082e <__eerd_byte_m2560>
    a07e:	18 2f       	mov	r17, r24
	int16_t Ter = Thermode(prb(ThermFami+ChanN), erb(ThermType+ChanN), DigiFilt(TerBuf[ChanN],TerFiltLev));
    a080:	c7 01       	movw	r24, r14
    a082:	88 0f       	add	r24, r24
    a084:	99 1f       	adc	r25, r25
    a086:	82 95       	swap	r24
    a088:	92 95       	swap	r25
    a08a:	90 7f       	andi	r25, 0xF0	; 240
    a08c:	98 27       	eor	r25, r24
    a08e:	80 7f       	andi	r24, 0xF0	; 240
    a090:	98 27       	eor	r25, r24
    a092:	8f 5f       	subi	r24, 0xFF	; 255
    a094:	9a 4f       	sbci	r25, 0xFA	; 250
    a096:	64 e0       	ldi	r22, 0x04	; 4
    a098:	0e 94 90 4c 	call	0x9920	; 0x9920 <DigiFilt>
    a09c:	ac 01       	movw	r20, r24
    a09e:	8c 2d       	mov	r24, r12
    a0a0:	61 2f       	mov	r22, r17
    a0a2:	0e 94 58 40 	call	0x80b0	; 0x80b0 <Thermode>
    a0a6:	ec 01       	movw	r28, r24
	if (Ter!=Therm_Off_Mark)
    a0a8:	80 e8       	ldi	r24, 0x80	; 128
    a0aa:	c0 30       	cpi	r28, 0x00	; 0
    a0ac:	d8 07       	cpc	r29, r24
    a0ae:	a1 f4       	brne	.+40     	; 0xa0d8 <ThermChan+0xd0>
		Ter = (Ter+(int8_t)erb(&ThermCorr[ChanN].D))*(erw(&ThermCorr[ChanN].A)/1000.0);
	Temperature[ChanN] = Ter;
    a0b0:	e5 e4       	ldi	r30, 0x45	; 69
    a0b2:	f6 e0       	ldi	r31, 0x06	; 6
    a0b4:	8e 0e       	add	r8, r30
    a0b6:	9f 1e       	adc	r9, r31
    a0b8:	f4 01       	movw	r30, r8
    a0ba:	d1 83       	std	Z+1, r29	; 0x01
    a0bc:	c0 83       	st	Z, r28
}
    a0be:	df 91       	pop	r29
    a0c0:	cf 91       	pop	r28
    a0c2:	1f 91       	pop	r17
    a0c4:	0f 91       	pop	r16
    a0c6:	ff 90       	pop	r15
    a0c8:	ef 90       	pop	r14
    a0ca:	df 90       	pop	r13
    a0cc:	cf 90       	pop	r12
    a0ce:	bf 90       	pop	r11
    a0d0:	af 90       	pop	r10
    a0d2:	9f 90       	pop	r9
    a0d4:	8f 90       	pop	r8
    a0d6:	08 95       	ret
    a0d8:	64 01       	movw	r12, r8
    a0da:	ce 0c       	add	r12, r14
    a0dc:	df 1c       	adc	r13, r15
    a0de:	c6 01       	movw	r24, r12
    a0e0:	83 5e       	subi	r24, 0xE3	; 227
    a0e2:	9e 4f       	sbci	r25, 0xFE	; 254
    a0e4:	0e 94 17 84 	call	0x1082e	; 0x1082e <__eerd_byte_m2560>
    a0e8:	e8 2e       	mov	r14, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    a0ea:	c6 01       	movw	r24, r12
    a0ec:	82 5e       	subi	r24, 0xE2	; 226
    a0ee:	9e 4f       	sbci	r25, 0xFE	; 254
    a0f0:	0e 94 25 84 	call	0x1084a	; 0x1084a <__eerd_word_m2560>
    a0f4:	5c 01       	movw	r10, r24
	for (uint8_t i=TerFiltLev*4-1; i; i--)
		TerBuf[ChanN][i] = TerBuf[ChanN][i-1];
	TerBuf[ChanN][0] = TerInput[ChanN];
	int16_t Ter = Thermode(prb(ThermFami+ChanN), erb(ThermType+ChanN), DigiFilt(TerBuf[ChanN],TerFiltLev));
	if (Ter!=Therm_Off_Mark)
		Ter = (Ter+(int8_t)erb(&ThermCorr[ChanN].D))*(erw(&ThermCorr[ChanN].A)/1000.0);
    a0f6:	ff 24       	eor	r15, r15
    a0f8:	e7 fc       	sbrc	r14, 7
    a0fa:	f0 94       	com	r15
    a0fc:	ec 0e       	add	r14, r28
    a0fe:	fd 1e       	adc	r15, r29
    a100:	00 27       	eor	r16, r16
    a102:	f7 fc       	sbrc	r15, 7
    a104:	00 95       	com	r16
    a106:	10 2f       	mov	r17, r16
    a108:	c8 01       	movw	r24, r16
    a10a:	b7 01       	movw	r22, r14
    a10c:	0e 94 08 7f 	call	0xfe10	; 0xfe10 <__floatsisf>
    a110:	7b 01       	movw	r14, r22
    a112:	8c 01       	movw	r16, r24
    a114:	cc 24       	eor	r12, r12
    a116:	dd 24       	eor	r13, r13
    a118:	c6 01       	movw	r24, r12
    a11a:	b5 01       	movw	r22, r10
    a11c:	0e 94 06 7f 	call	0xfe0c	; 0xfe0c <__floatunsisf>
    a120:	20 e0       	ldi	r18, 0x00	; 0
    a122:	30 e0       	ldi	r19, 0x00	; 0
    a124:	4a e7       	ldi	r20, 0x7A	; 122
    a126:	54 e4       	ldi	r21, 0x44	; 68
    a128:	0e 94 6e 83 	call	0x106dc	; 0x106dc <__divsf3>
    a12c:	9b 01       	movw	r18, r22
    a12e:	ac 01       	movw	r20, r24
    a130:	c8 01       	movw	r24, r16
    a132:	b7 01       	movw	r22, r14
    a134:	0e 94 43 7f 	call	0xfe86	; 0xfe86 <__mulsf3>
    a138:	0e 94 d6 83 	call	0x107ac	; 0x107ac <__fixsfsi>
    a13c:	eb 01       	movw	r28, r22
    a13e:	b8 cf       	rjmp	.-144    	; 0xa0b0 <ThermChan+0xa8>

0000a140 <ThermInit>:
}

// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
ThermInit(uint8_t ChanN)
{
    a140:	ef 92       	push	r14
    a142:	ff 92       	push	r15
    a144:	0f 93       	push	r16
    a146:	1f 93       	push	r17
    a148:	cf 93       	push	r28
    a14a:	df 93       	push	r29
    a14c:	f8 2e       	mov	r15, r24
	if (ChanN<TerReg) {
    a14e:	85 e0       	ldi	r24, 0x05	; 5
    a150:	8f 15       	cp	r24, r15
    a152:	68 f1       	brcs	.+90     	; 0xa1ae <ThermInit+0x6e>
    a154:	8f 2d       	mov	r24, r15
    a156:	90 e0       	ldi	r25, 0x00	; 0
    a158:	8c 01       	movw	r16, r24
    a15a:	00 0f       	add	r16, r16
    a15c:	11 1f       	adc	r17, r17
    a15e:	f8 01       	movw	r30, r16
    a160:	e6 5e       	subi	r30, 0xE6	; 230
    a162:	f6 4f       	sbci	r31, 0xF6	; 246
    a164:	c0 81       	ld	r28, Z
    a166:	d1 81       	ldd	r29, Z+1	; 0x01
    a168:	fc 01       	movw	r30, r24
    a16a:	ee 0f       	add	r30, r30
    a16c:	ff 1f       	adc	r31, r31
    a16e:	e2 95       	swap	r30
    a170:	f2 95       	swap	r31
    a172:	f0 7f       	andi	r31, 0xF0	; 240
    a174:	fe 27       	eor	r31, r30
    a176:	e0 7f       	andi	r30, 0xF0	; 240
    a178:	fe 27       	eor	r31, r30
    a17a:	ef 5f       	subi	r30, 0xFF	; 255
    a17c:	fa 4f       	sbci	r31, 0xFA	; 250
    a17e:	20 e0       	ldi	r18, 0x00	; 0
		for (uint8_t i=0; i<TerFiltLev*4; TerBuf[ChanN][i++]=TerInput[ChanN]);
    a180:	c1 93       	st	Z+, r28
    a182:	d1 93       	st	Z+, r29
    a184:	2f 5f       	subi	r18, 0xFF	; 255
    a186:	20 31       	cpi	r18, 0x10	; 16
    a188:	d9 f7       	brne	.-10     	; 0xa180 <ThermInit+0x40>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    a18a:	fc 01       	movw	r30, r24
    a18c:	e3 54       	subi	r30, 0x43	; 67
    a18e:	f9 4f       	sbci	r31, 0xF9	; 249
    a190:	e4 90       	lpm	r14, Z+
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    a192:	89 5e       	subi	r24, 0xE9	; 233
    a194:	9e 4f       	sbci	r25, 0xFE	; 254
    a196:	0e 94 17 84 	call	0x1082e	; 0x1082e <__eerd_byte_m2560>
    a19a:	68 2f       	mov	r22, r24
		Temperature[ChanN] = Thermode(prb(ThermFami+ChanN), erb(ThermType+ChanN), TerInput[ChanN]);
    a19c:	8e 2d       	mov	r24, r14
    a19e:	ae 01       	movw	r20, r28
    a1a0:	0e 94 58 40 	call	0x80b0	; 0x80b0 <Thermode>
    a1a4:	0b 5b       	subi	r16, 0xBB	; 187
    a1a6:	19 4f       	sbci	r17, 0xF9	; 249
    a1a8:	f8 01       	movw	r30, r16
    a1aa:	91 83       	std	Z+1, r25	; 0x01
    a1ac:	80 83       	st	Z, r24
    a1ae:	80 e0       	ldi	r24, 0x00	; 0
    a1b0:	f5 e0       	ldi	r31, 0x05	; 5
    a1b2:	ff 12       	cpse	r15, r31
    a1b4:	81 e0       	ldi	r24, 0x01	; 1
	}
	return ChanN!=TerReg-1;
}
    a1b6:	df 91       	pop	r29
    a1b8:	cf 91       	pop	r28
    a1ba:	1f 91       	pop	r17
    a1bc:	0f 91       	pop	r16
    a1be:	ff 90       	pop	r15
    a1c0:	ef 90       	pop	r14
    a1c2:	08 95       	ret

0000a1c4 <DigitIn>:
}

// ~~~~~~~~~~
void
DigitIn(void)
{
    a1c4:	cf 93       	push	r28
    a1c6:	df 93       	push	r29
	memcpy(DigInput.StateOld, DigInput.State, DI_Reg+DI_Reg_Ext);
    a1c8:	e3 e4       	ldi	r30, 0x43	; 67
    a1ca:	f7 e0       	ldi	r31, 0x07	; 7
    a1cc:	df 01       	movw	r26, r30
    a1ce:	13 97       	sbiw	r26, 0x03	; 3
    a1d0:	83 e0       	ldi	r24, 0x03	; 3
    a1d2:	0d 90       	ld	r0, X+
    a1d4:	01 92       	st	Z+, r0
    a1d6:	81 50       	subi	r24, 0x01	; 1
    a1d8:	e1 f7       	brne	.-8      	; 0xa1d2 <DigitIn+0xe>
    a1da:	84 e1       	ldi	r24, 0x14	; 20
    a1dc:	91 e0       	ldi	r25, 0x01	; 1
    a1de:	0e 94 17 84 	call	0x1082e	; 0x1082e <__eerd_byte_m2560>
	for (uint8_t i=0; i<DI_Reg; i++)
		DigInput.Status[i] = DigInput.State[i]^erb(DI_Invers+i);
    a1e2:	90 91 40 07 	lds	r25, 0x0740
    a1e6:	98 27       	eor	r25, r24
    a1e8:	90 93 46 07 	sts	0x0746, r25
    a1ec:	85 e1       	ldi	r24, 0x15	; 21
    a1ee:	91 e0       	ldi	r25, 0x01	; 1
    a1f0:	0e 94 17 84 	call	0x1082e	; 0x1082e <__eerd_byte_m2560>
    a1f4:	90 91 41 07 	lds	r25, 0x0741
    a1f8:	98 27       	eor	r25, r24
    a1fa:	90 93 47 07 	sts	0x0747, r25
    a1fe:	86 e1       	ldi	r24, 0x16	; 22
    a200:	91 e0       	ldi	r25, 0x01	; 1
    a202:	0e 94 17 84 	call	0x1082e	; 0x1082e <__eerd_byte_m2560>
    a206:	90 91 42 07 	lds	r25, 0x0742
    a20a:	98 27       	eor	r25, r24
    a20c:	90 93 48 07 	sts	0x0748, r25
    a210:	40 e0       	ldi	r20, 0x00	; 0
    a212:	50 e0       	ldi	r21, 0x00	; 0
#else
	static void
	DigitIn_Hard(void)
	{
		for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
			uint8_t Byte=D_N/8, Bit=1<<D_N%8;
    a214:	a1 e0       	ldi	r26, 0x01	; 1
    a216:	b0 e0       	ldi	r27, 0x00	; 0
    a218:	1b c0       	rjmp	.+54     	; 0xa250 <DigitIn+0x8c>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    a21a:	c9 01       	movw	r24, r18
    a21c:	8a 56       	subi	r24, 0x6A	; 106
    a21e:	93 4d       	sbci	r25, 0xD3	; 211
    a220:	fc 01       	movw	r30, r24
    a222:	c5 91       	lpm	r28, Z+
    a224:	d4 91       	lpm	r29, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    a226:	28 56       	subi	r18, 0x68	; 104
    a228:	33 4d       	sbci	r19, 0xD3	; 211
    a22a:	f9 01       	movw	r30, r18
    a22c:	84 91       	lpm	r24, Z+
			if(prb(&DI_M[D_N].Inversion)){
				if (*(uint8_t*)prp(&DI_M[D_N].PIN) & prb(&DI_M[D_N].P))
    a22e:	98 81       	ld	r25, Y
    a230:	89 23       	and	r24, r25
    a232:	09 f4       	brne	.+2      	; 0xa236 <DigitIn+0x72>
    a234:	3d c0       	rjmp	.+122    	; 0xa2b0 <DigitIn+0xec>
			}
			else{
				if (*(uint8_t*)prp(&DI_M[D_N].PIN) & prb(&DI_M[D_N].P))
					DigInput.State[Byte] &=~Bit;
				else
					DigInput.State[Byte]  |=Bit;
    a236:	e7 2f       	mov	r30, r23
    a238:	f0 e0       	ldi	r31, 0x00	; 0
    a23a:	e0 5c       	subi	r30, 0xC0	; 192
    a23c:	f8 4f       	sbci	r31, 0xF8	; 248
    a23e:	80 81       	ld	r24, Z
    a240:	86 2b       	or	r24, r22
    a242:	80 83       	st	Z, r24
    a244:	4f 5f       	subi	r20, 0xFF	; 255
    a246:	5f 4f       	sbci	r21, 0xFF	; 255
	void DigitIn_Hard(void);
#else
	static void
	DigitIn_Hard(void)
	{
		for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
    a248:	42 31       	cpi	r20, 0x12	; 18
    a24a:	51 05       	cpc	r21, r1
    a24c:	09 f4       	brne	.+2      	; 0xa250 <DigitIn+0x8c>
    a24e:	3e c0       	rjmp	.+124    	; 0xa2cc <DigitIn+0x108>
			uint8_t Byte=D_N/8, Bit=1<<D_N%8;
    a250:	74 2f       	mov	r23, r20
    a252:	76 95       	lsr	r23
    a254:	76 95       	lsr	r23
    a256:	76 95       	lsr	r23
    a258:	ca 01       	movw	r24, r20
    a25a:	87 70       	andi	r24, 0x07	; 7
    a25c:	90 70       	andi	r25, 0x00	; 0
    a25e:	9d 01       	movw	r18, r26
    a260:	02 c0       	rjmp	.+4      	; 0xa266 <DigitIn+0xa2>
    a262:	22 0f       	add	r18, r18
    a264:	33 1f       	adc	r19, r19
    a266:	8a 95       	dec	r24
    a268:	e2 f7       	brpl	.-8      	; 0xa262 <DigitIn+0x9e>
    a26a:	62 2f       	mov	r22, r18
    a26c:	9a 01       	movw	r18, r20
    a26e:	22 0f       	add	r18, r18
    a270:	33 1f       	adc	r19, r19
    a272:	22 0f       	add	r18, r18
    a274:	33 1f       	adc	r19, r19
    a276:	22 0f       	add	r18, r18
    a278:	33 1f       	adc	r19, r19
    a27a:	f9 01       	movw	r30, r18
    a27c:	e7 56       	subi	r30, 0x67	; 103
    a27e:	f3 4d       	sbci	r31, 0xD3	; 211
    a280:	e4 91       	lpm	r30, Z+
			if(prb(&DI_M[D_N].Inversion)){
    a282:	ee 23       	and	r30, r30
    a284:	09 f0       	breq	.+2      	; 0xa288 <DigitIn+0xc4>
    a286:	c9 cf       	rjmp	.-110    	; 0xa21a <DigitIn+0x56>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    a288:	ca 01       	movw	r24, r20
    a28a:	88 0f       	add	r24, r24
    a28c:	99 1f       	adc	r25, r25
    a28e:	88 0f       	add	r24, r24
    a290:	99 1f       	adc	r25, r25
    a292:	88 0f       	add	r24, r24
    a294:	99 1f       	adc	r25, r25
    a296:	8a 56       	subi	r24, 0x6A	; 106
    a298:	93 4d       	sbci	r25, 0xD3	; 211
    a29a:	fc 01       	movw	r30, r24
    a29c:	c5 91       	lpm	r28, Z+
    a29e:	d4 91       	lpm	r29, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    a2a0:	28 56       	subi	r18, 0x68	; 104
    a2a2:	33 4d       	sbci	r19, 0xD3	; 211
    a2a4:	f9 01       	movw	r30, r18
    a2a6:	84 91       	lpm	r24, Z+
					DigInput.State[Byte] |=Bit;
				else
					DigInput.State[Byte] &=~Bit;
			}
			else{
				if (*(uint8_t*)prp(&DI_M[D_N].PIN) & prb(&DI_M[D_N].P))
    a2a8:	98 81       	ld	r25, Y
    a2aa:	89 23       	and	r24, r25
    a2ac:	09 f4       	brne	.+2      	; 0xa2b0 <DigitIn+0xec>
    a2ae:	c3 cf       	rjmp	.-122    	; 0xa236 <DigitIn+0x72>
					DigInput.State[Byte] &=~Bit;
    a2b0:	e7 2f       	mov	r30, r23
    a2b2:	f0 e0       	ldi	r31, 0x00	; 0
    a2b4:	e0 5c       	subi	r30, 0xC0	; 192
    a2b6:	f8 4f       	sbci	r31, 0xF8	; 248
    a2b8:	60 95       	com	r22
    a2ba:	80 81       	ld	r24, Z
    a2bc:	68 23       	and	r22, r24
    a2be:	60 83       	st	Z, r22
				else
					DigInput.State[Byte]  |=Bit;
    a2c0:	4f 5f       	subi	r20, 0xFF	; 255
    a2c2:	5f 4f       	sbci	r21, 0xFF	; 255
	void DigitIn_Hard(void);
#else
	static void
	DigitIn_Hard(void)
	{
		for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
    a2c4:	42 31       	cpi	r20, 0x12	; 18
    a2c6:	51 05       	cpc	r21, r1
    a2c8:	09 f0       	breq	.+2      	; 0xa2cc <DigitIn+0x108>
    a2ca:	c2 cf       	rjmp	.-124    	; 0xa250 <DigitIn+0x8c>
			DigInput.State[j]		= (DigInput_Ext)[i];
			DigInput.Status[j]	= (DigInput_Ext)[i+DI_Reg_Ext];
			IntOn();
		}
	#endif
}
    a2cc:	df 91       	pop	r29
    a2ce:	cf 91       	pop	r28
    a2d0:	08 95       	ret

0000a2d2 <Field2Buf>:
	else return 0;
}
// ~~~~~~~~~~~~~~~~~~~~~~~
static void
Field2Buf(OutField *Field)
{
    a2d2:	6f 92       	push	r6
    a2d4:	7f 92       	push	r7
    a2d6:	8f 92       	push	r8
    a2d8:	9f 92       	push	r9
    a2da:	af 92       	push	r10
    a2dc:	bf 92       	push	r11
    a2de:	cf 92       	push	r12
    a2e0:	df 92       	push	r13
    a2e2:	ef 92       	push	r14
    a2e4:	ff 92       	push	r15
    a2e6:	0f 93       	push	r16
    a2e8:	1f 93       	push	r17
    a2ea:	df 93       	push	r29
    a2ec:	cf 93       	push	r28
    a2ee:	cd b7       	in	r28, 0x3d	; 61
    a2f0:	de b7       	in	r29, 0x3e	; 62
    a2f2:	6f 97       	sbiw	r28, 0x1f	; 31
    a2f4:	0f b6       	in	r0, 0x3f	; 63
    a2f6:	f8 94       	cli
    a2f8:	de bf       	out	0x3e, r29	; 62
    a2fa:	0f be       	out	0x3f, r0	; 63
    a2fc:	cd bf       	out	0x3d, r28	; 61
    a2fe:	7c 01       	movw	r14, r24

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    a300:	fc 01       	movw	r30, r24
    a302:	31 96       	adiw	r30, 0x01	; 1
    a304:	c5 90       	lpm	r12, Z+
    a306:	d4 90       	lpm	r13, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    a308:	bf e0       	ldi	r27, 0x0F	; 15
    a30a:	8b 2e       	mov	r8, r27
    a30c:	91 2c       	mov	r9, r1
    a30e:	88 0e       	add	r8, r24
    a310:	99 1e       	adc	r9, r25
    a312:	f4 01       	movw	r30, r8
    a314:	24 91       	lpm	r18, Z+
	void *Var = prp(&Field->Var);
	uint8_t BitN=prb(&Field->Prec), Mask=1<<BitN%8, *BitVar=(uint8_t*)Var+BitN/8;
    a316:	32 2f       	mov	r19, r18
    a318:	37 70       	andi	r19, 0x07	; 7
    a31a:	81 e0       	ldi	r24, 0x01	; 1
    a31c:	90 e0       	ldi	r25, 0x00	; 0
    a31e:	18 2f       	mov	r17, r24
    a320:	01 c0       	rjmp	.+2      	; 0xa324 <Field2Buf+0x52>
    a322:	11 0f       	add	r17, r17
    a324:	3a 95       	dec	r19
    a326:	ea f7       	brpl	.-6      	; 0xa322 <Field2Buf+0x50>
    a328:	26 95       	lsr	r18
    a32a:	26 95       	lsr	r18
    a32c:	26 95       	lsr	r18
    a32e:	56 01       	movw	r10, r12
    a330:	a2 0e       	add	r10, r18
    a332:	b1 1c       	adc	r11, r1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    a334:	a7 e0       	ldi	r26, 0x07	; 7
    a336:	6a 2e       	mov	r6, r26
    a338:	71 2c       	mov	r7, r1
    a33a:	6e 0c       	add	r6, r14
    a33c:	7f 1c       	adc	r7, r15
    a33e:	f3 01       	movw	r30, r6
    a340:	65 91       	lpm	r22, Z+
    a342:	75 91       	lpm	r23, Z+
    a344:	85 91       	lpm	r24, Z+
    a346:	94 91       	lpm	r25, Z+
	uint8_t Pos=Log10(prd(&Field->Max));
    a348:	0e 94 ca 21 	call	0x4394	; 0x4394 <Log10>
    a34c:	08 2f       	mov	r16, r24

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    a34e:	f7 01       	movw	r30, r14
    a350:	84 91       	lpm	r24, Z+
	uint8_t Oldstyle = 0;

	switch(prb(&Field->Type)) {
    a352:	e8 2f       	mov	r30, r24
    a354:	f0 e0       	ldi	r31, 0x00	; 0
    a356:	e1 32       	cpi	r30, 0x21	; 33
    a358:	f1 05       	cpc	r31, r1
    a35a:	08 f4       	brcc	.+2      	; 0xa35e <Field2Buf+0x8c>
    a35c:	6e c0       	rjmp	.+220    	; 0xa43a <Field2Buf+0x168>
		F_Buf = (erb(BitVar) &Mask) > 0;
		Oldstyle = 1;
		break;
	}

	Minus=0;
    a35e:	10 92 ff 04 	sts	0x04FF, r1
	if(Oldstyle) return;

	InitBufStr(Field);
    a362:	c7 01       	movw	r24, r14
    a364:	0e 94 36 3d 	call	0x7a6c	; 0x7a6c <InitBufStr>
	CurrFieldSize = GetCurrFieldSize();
    a368:	0e 94 f8 3d 	call	0x7bf0	; 0x7bf0 <GetCurrFieldSize>
    a36c:	48 2f       	mov	r20, r24
    a36e:	80 93 c0 07 	sts	0x07C0, r24
	CurrPos = CurrFieldSize - 1;
    a372:	41 50       	subi	r20, 0x01	; 1
    a374:	40 93 d7 02 	sts	0x02D7, r20
    a378:	4f 5f       	subi	r20, 0xFF	; 255
	float fTemp;
	T_Param Param;
	Param.Size = CurrFieldSize;
    a37a:	48 87       	std	Y+8, r20	; 0x08
	Param.Pos = BufStr;
    a37c:	83 ec       	ldi	r24, 0xC3	; 195
    a37e:	95 e0       	ldi	r25, 0x05	; 5
    a380:	9e 83       	std	Y+6, r25	; 0x06
    a382:	8d 83       	std	Y+5, r24	; 0x05
    a384:	f4 01       	movw	r30, r8
    a386:	84 91       	lpm	r24, Z+
	Param.Prec = prb(&Field->Prec);
    a388:	8f 83       	std	Y+7, r24	; 0x07
	Param.Txt = NULL;
    a38a:	1a 86       	std	Y+10, r1	; 0x0a
    a38c:	19 86       	std	Y+9, r1	; 0x09
    a38e:	f7 01       	movw	r30, r14
    a390:	84 91       	lpm	r24, Z+

	switch(prb(&Field->Type)) {
    a392:	85 31       	cpi	r24, 0x15	; 21
    a394:	09 f4       	brne	.+2      	; 0xa398 <Field2Buf+0xc6>
    a396:	74 c1       	rjmp	.+744    	; 0xa680 <Field2Buf+0x3ae>
    a398:	86 31       	cpi	r24, 0x16	; 22
    a39a:	08 f4       	brcc	.+2      	; 0xa39e <Field2Buf+0xcc>
    a39c:	56 c1       	rjmp	.+684    	; 0xa64a <Field2Buf+0x378>
    a39e:	8b 31       	cpi	r24, 0x1B	; 27
    a3a0:	09 f4       	brne	.+2      	; 0xa3a4 <Field2Buf+0xd2>
    a3a2:	fe c1       	rjmp	.+1020   	; 0xa7a0 <Field2Buf+0x4ce>
    a3a4:	8c 31       	cpi	r24, 0x1C	; 28
    a3a6:	08 f0       	brcs	.+2      	; 0xa3aa <Field2Buf+0xd8>
    a3a8:	b7 c1       	rjmp	.+878    	; 0xa718 <Field2Buf+0x446>
    a3aa:	89 31       	cpi	r24, 0x19	; 25
    a3ac:	09 f4       	brne	.+2      	; 0xa3b0 <Field2Buf+0xde>
    a3ae:	92 c1       	rjmp	.+804    	; 0xa6d4 <Field2Buf+0x402>
    a3b0:	8a 31       	cpi	r24, 0x1A	; 26
    a3b2:	09 f0       	breq	.+2      	; 0xa3b6 <Field2Buf+0xe4>
    a3b4:	5b c0       	rjmp	.+182    	; 0xa46c <Field2Buf+0x19a>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    a3b6:	7e 01       	movw	r14, r28
    a3b8:	08 94       	sec
    a3ba:	e1 1c       	adc	r14, r1
    a3bc:	f1 1c       	adc	r15, r1
    a3be:	c7 01       	movw	r24, r14
    a3c0:	b6 01       	movw	r22, r12
    a3c2:	44 e0       	ldi	r20, 0x04	; 4
    a3c4:	50 e0       	ldi	r21, 0x00	; 0
    a3c6:	0e 94 07 84 	call	0x1080e	; 0x1080e <__eerd_block_m2560>
		Put_FFVal(*(float*)Var, &Param);
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
		break;
	case EE_FFloat:
		erbl(&fTemp, Var, 4);
		Put_FFVal(fTemp, &Param);
    a3ca:	69 81       	ldd	r22, Y+1	; 0x01
    a3cc:	7a 81       	ldd	r23, Y+2	; 0x02
    a3ce:	8b 81       	ldd	r24, Y+3	; 0x03
    a3d0:	9c 81       	ldd	r25, Y+4	; 0x04
    a3d2:	8e 01       	movw	r16, r28
    a3d4:	0b 5f       	subi	r16, 0xFB	; 251
    a3d6:	1f 4f       	sbci	r17, 0xFF	; 255
    a3d8:	a8 01       	movw	r20, r16
    a3da:	0e 94 4e 45 	call	0x8a9c	; 0x8a9c <Put_FFVal>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
    a3de:	8e ea       	ldi	r24, 0xAE	; 174
    a3e0:	96 e0       	ldi	r25, 0x06	; 6
    a3e2:	60 91 c3 05 	lds	r22, 0x05C3
    a3e6:	0e 94 17 42 	call	0x842e	; 0x842e <GetMultiSymbol>
    a3ea:	80 93 f4 04 	sts	0x04F4, r24
	case GFloat:
		Put_GFVal(*(float*)Var, &Param);
    a3ee:	f6 01       	movw	r30, r12
    a3f0:	60 81       	ld	r22, Z
    a3f2:	71 81       	ldd	r23, Z+1	; 0x01
    a3f4:	82 81       	ldd	r24, Z+2	; 0x02
    a3f6:	93 81       	ldd	r25, Z+3	; 0x03
    a3f8:	a8 01       	movw	r20, r16
    a3fa:	0e 94 d4 44 	call	0x89a8	; 0x89a8 <Put_GFVal>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
    a3fe:	8e ea       	ldi	r24, 0xAE	; 174
    a400:	96 e0       	ldi	r25, 0x06	; 6
    a402:	60 91 c3 05 	lds	r22, 0x05C3
    a406:	0e 94 17 42 	call	0x842e	; 0x842e <GetMultiSymbol>
    a40a:	80 93 f4 04 	sts	0x04F4, r24
    a40e:	c7 01       	movw	r24, r14
    a410:	b6 01       	movw	r22, r12
    a412:	44 e0       	ldi	r20, 0x04	; 4
    a414:	50 e0       	ldi	r21, 0x00	; 0
    a416:	0e 94 07 84 	call	0x1080e	; 0x1080e <__eerd_block_m2560>
	case EE_GFloat:
		erbl(&fTemp, Var, 4);
		Put_GFVal(fTemp, &Param);
    a41a:	69 81       	ldd	r22, Y+1	; 0x01
    a41c:	7a 81       	ldd	r23, Y+2	; 0x02
    a41e:	8b 81       	ldd	r24, Y+3	; 0x03
    a420:	9c 81       	ldd	r25, Y+4	; 0x04
    a422:	a8 01       	movw	r20, r16
    a424:	0e 94 d4 44 	call	0x89a8	; 0x89a8 <Put_GFVal>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
    a428:	8e ea       	ldi	r24, 0xAE	; 174
    a42a:	96 e0       	ldi	r25, 0x06	; 6
    a42c:	60 91 c3 05 	lds	r22, 0x05C3
    a430:	0e 94 17 42 	call	0x842e	; 0x842e <GetMultiSymbol>
    a434:	80 93 f4 04 	sts	0x04F4, r24
    a438:	19 c0       	rjmp	.+50     	; 0xa46c <Field2Buf+0x19a>
	void *Var = prp(&Field->Var);
	uint8_t BitN=prb(&Field->Prec), Mask=1<<BitN%8, *BitVar=(uint8_t*)Var+BitN/8;
	uint8_t Pos=Log10(prd(&Field->Max));
	uint8_t Oldstyle = 0;

	switch(prb(&Field->Type)) {
    a43a:	ee 58       	subi	r30, 0x8E	; 142
    a43c:	ff 4f       	sbci	r31, 0xFF	; 255
    a43e:	ee 0f       	add	r30, r30
    a440:	ff 1f       	adc	r31, r31
    a442:	05 90       	lpm	r0, Z+
    a444:	f4 91       	lpm	r31, Z+
    a446:	e0 2d       	mov	r30, r0
    a448:	19 94       	eijmp
	case Byte: case z_Byte:
		F_Buf = *(uint8_t*)Var;
    a44a:	f6 01       	movw	r30, r12
    a44c:	80 81       	ld	r24, Z
    a44e:	90 e0       	ldi	r25, 0x00	; 0
    a450:	a0 e0       	ldi	r26, 0x00	; 0
    a452:	b0 e0       	ldi	r27, 0x00	; 0
    a454:	80 93 f7 04 	sts	0x04F7, r24
    a458:	90 93 f8 04 	sts	0x04F8, r25
    a45c:	a0 93 f9 04 	sts	0x04F9, r26
    a460:	b0 93 fa 04 	sts	0x04FA, r27
		CurrPos = Pos;
    a464:	00 93 d7 02 	sts	0x02D7, r16
		F_Buf = (erb(BitVar) &Mask) > 0;
		Oldstyle = 1;
		break;
	}

	Minus=0;
    a468:	10 92 ff 04 	sts	0x04FF, r1
				MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[0]);
			else MultiSymbol = GetMultiSymbol(Symbols_P, BufStr[0]);
		}
		break;
	}
}
    a46c:	6f 96       	adiw	r28, 0x1f	; 31
    a46e:	0f b6       	in	r0, 0x3f	; 63
    a470:	f8 94       	cli
    a472:	de bf       	out	0x3e, r29	; 62
    a474:	0f be       	out	0x3f, r0	; 63
    a476:	cd bf       	out	0x3d, r28	; 61
    a478:	cf 91       	pop	r28
    a47a:	df 91       	pop	r29
    a47c:	1f 91       	pop	r17
    a47e:	0f 91       	pop	r16
    a480:	ff 90       	pop	r15
    a482:	ef 90       	pop	r14
    a484:	df 90       	pop	r13
    a486:	cf 90       	pop	r12
    a488:	bf 90       	pop	r11
    a48a:	af 90       	pop	r10
    a48c:	9f 90       	pop	r9
    a48e:	8f 90       	pop	r8
    a490:	7f 90       	pop	r7
    a492:	6f 90       	pop	r6
    a494:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    a496:	c6 01       	movw	r24, r12
    a498:	0e 94 17 84 	call	0x1082e	; 0x1082e <__eerd_byte_m2560>
		sF_Buf = *(int8_t*)Var;
		CurrPos = Pos+1;
		Oldstyle = 1;
		break;
	case EE_Byte: case z_EE_Byte:
		F_Buf = erb((uint8_t*)Var);
    a49c:	90 e0       	ldi	r25, 0x00	; 0
    a49e:	a0 e0       	ldi	r26, 0x00	; 0
    a4a0:	b0 e0       	ldi	r27, 0x00	; 0
    a4a2:	80 93 f7 04 	sts	0x04F7, r24
    a4a6:	90 93 f8 04 	sts	0x04F8, r25
    a4aa:	a0 93 f9 04 	sts	0x04F9, r26
    a4ae:	b0 93 fa 04 	sts	0x04FA, r27
		CurrPos = Pos;
    a4b2:	00 93 d7 02 	sts	0x02D7, r16
    a4b6:	d8 cf       	rjmp	.-80     	; 0xa468 <Field2Buf+0x196>
		F_Buf = *(uint8_t*)Var;
		CurrPos = Pos;
		Oldstyle = 1;
		break;
	case s_Byte:
		sF_Buf = *(int8_t*)Var;
    a4b8:	f6 01       	movw	r30, r12
    a4ba:	80 81       	ld	r24, Z
    a4bc:	99 27       	eor	r25, r25
    a4be:	87 fd       	sbrc	r24, 7
    a4c0:	90 95       	com	r25
    a4c2:	a9 2f       	mov	r26, r25
    a4c4:	b9 2f       	mov	r27, r25
    a4c6:	80 93 fb 04 	sts	0x04FB, r24
    a4ca:	90 93 fc 04 	sts	0x04FC, r25
    a4ce:	a0 93 fd 04 	sts	0x04FD, r26
    a4d2:	b0 93 fe 04 	sts	0x04FE, r27
		CurrPos = Pos+1;
    a4d6:	0f 5f       	subi	r16, 0xFF	; 255
    a4d8:	00 93 d7 02 	sts	0x02D7, r16
    a4dc:	c5 cf       	rjmp	.-118    	; 0xa468 <Field2Buf+0x196>
    a4de:	c6 01       	movw	r24, r12
    a4e0:	0e 94 17 84 	call	0x1082e	; 0x1082e <__eerd_byte_m2560>
		F_Buf = erb((uint8_t*)Var);
		CurrPos = Pos;
		Oldstyle = 1;
		break;
	case s_EE_Byte:
		sF_Buf = (int8_t)erb((uint8_t*)Var);
    a4e4:	99 27       	eor	r25, r25
    a4e6:	87 fd       	sbrc	r24, 7
    a4e8:	90 95       	com	r25
    a4ea:	a9 2f       	mov	r26, r25
    a4ec:	b9 2f       	mov	r27, r25
    a4ee:	80 93 fb 04 	sts	0x04FB, r24
    a4f2:	90 93 fc 04 	sts	0x04FC, r25
    a4f6:	a0 93 fd 04 	sts	0x04FD, r26
    a4fa:	b0 93 fe 04 	sts	0x04FE, r27
		CurrPos = Pos+1;
    a4fe:	0f 5f       	subi	r16, 0xFF	; 255
    a500:	00 93 d7 02 	sts	0x02D7, r16
    a504:	b1 cf       	rjmp	.-158    	; 0xa468 <Field2Buf+0x196>
		Oldstyle = 1;
		break;

	case Word: case z_Word:
		F_Buf = *(uint16_t*)Var;
    a506:	f6 01       	movw	r30, r12
    a508:	80 81       	ld	r24, Z
    a50a:	91 81       	ldd	r25, Z+1	; 0x01
    a50c:	a0 e0       	ldi	r26, 0x00	; 0
    a50e:	b0 e0       	ldi	r27, 0x00	; 0
    a510:	80 93 f7 04 	sts	0x04F7, r24
    a514:	90 93 f8 04 	sts	0x04F8, r25
    a518:	a0 93 f9 04 	sts	0x04F9, r26
    a51c:	b0 93 fa 04 	sts	0x04FA, r27
		CurrPos = Pos;
    a520:	00 93 d7 02 	sts	0x02D7, r16
    a524:	a1 cf       	rjmp	.-190    	; 0xa468 <Field2Buf+0x196>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    a526:	c6 01       	movw	r24, r12
    a528:	0e 94 25 84 	call	0x1084a	; 0x1084a <__eerd_word_m2560>
		Oldstyle = 1;
		break;
	case EE_Word: case z_EE_Word:
		F_Buf = erw((uint16_t*)Var);
    a52c:	a0 e0       	ldi	r26, 0x00	; 0
    a52e:	b0 e0       	ldi	r27, 0x00	; 0
    a530:	80 93 f7 04 	sts	0x04F7, r24
    a534:	90 93 f8 04 	sts	0x04F8, r25
    a538:	a0 93 f9 04 	sts	0x04F9, r26
    a53c:	b0 93 fa 04 	sts	0x04FA, r27
		CurrPos = Pos;
    a540:	00 93 d7 02 	sts	0x02D7, r16
    a544:	91 cf       	rjmp	.-222    	; 0xa468 <Field2Buf+0x196>
		Oldstyle = 1;
		break;
	case s_Word:
		sF_Buf = *(int16_t*)Var;
    a546:	f6 01       	movw	r30, r12
    a548:	80 81       	ld	r24, Z
    a54a:	91 81       	ldd	r25, Z+1	; 0x01
    a54c:	aa 27       	eor	r26, r26
    a54e:	97 fd       	sbrc	r25, 7
    a550:	a0 95       	com	r26
    a552:	ba 2f       	mov	r27, r26
    a554:	80 93 fb 04 	sts	0x04FB, r24
    a558:	90 93 fc 04 	sts	0x04FC, r25
    a55c:	a0 93 fd 04 	sts	0x04FD, r26
    a560:	b0 93 fe 04 	sts	0x04FE, r27
		CurrPos = Pos+1;
    a564:	0f 5f       	subi	r16, 0xFF	; 255
    a566:	00 93 d7 02 	sts	0x02D7, r16
    a56a:	7e cf       	rjmp	.-260    	; 0xa468 <Field2Buf+0x196>
    a56c:	c6 01       	movw	r24, r12
    a56e:	0e 94 25 84 	call	0x1084a	; 0x1084a <__eerd_word_m2560>
		Oldstyle = 1;
		break;
	case s_EE_Word:
		sF_Buf = (int16_t)erw((uint16_t*)Var);
    a572:	aa 27       	eor	r26, r26
    a574:	97 fd       	sbrc	r25, 7
    a576:	a0 95       	com	r26
    a578:	ba 2f       	mov	r27, r26
    a57a:	80 93 fb 04 	sts	0x04FB, r24
    a57e:	90 93 fc 04 	sts	0x04FC, r25
    a582:	a0 93 fd 04 	sts	0x04FD, r26
    a586:	b0 93 fe 04 	sts	0x04FE, r27
		CurrPos = Pos+1;
    a58a:	0f 5f       	subi	r16, 0xFF	; 255
    a58c:	00 93 d7 02 	sts	0x02D7, r16
    a590:	6b cf       	rjmp	.-298    	; 0xa468 <Field2Buf+0x196>
		Oldstyle = 1;
		break;
	case c_Word: case zc_Word:
		F_Buf = *(uint16_t*)Var;
    a592:	f6 01       	movw	r30, r12
    a594:	80 81       	ld	r24, Z
    a596:	91 81       	ldd	r25, Z+1	; 0x01
    a598:	a0 e0       	ldi	r26, 0x00	; 0
    a59a:	b0 e0       	ldi	r27, 0x00	; 0
    a59c:	80 93 f7 04 	sts	0x04F7, r24
    a5a0:	90 93 f8 04 	sts	0x04F8, r25
    a5a4:	a0 93 f9 04 	sts	0x04F9, r26
    a5a8:	b0 93 fa 04 	sts	0x04FA, r27
    a5ac:	5d cf       	rjmp	.-326    	; 0xa468 <Field2Buf+0x196>
		Oldstyle = 1;
		break;

	case Enum:
		F_Buf = *(uint8_t*)Var;
    a5ae:	f6 01       	movw	r30, r12
    a5b0:	80 81       	ld	r24, Z
    a5b2:	90 e0       	ldi	r25, 0x00	; 0
    a5b4:	a0 e0       	ldi	r26, 0x00	; 0
    a5b6:	b0 e0       	ldi	r27, 0x00	; 0
    a5b8:	80 93 f7 04 	sts	0x04F7, r24
    a5bc:	90 93 f8 04 	sts	0x04F8, r25
    a5c0:	a0 93 f9 04 	sts	0x04F9, r26
    a5c4:	b0 93 fa 04 	sts	0x04FA, r27
    a5c8:	4f cf       	rjmp	.-354    	; 0xa468 <Field2Buf+0x196>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    a5ca:	c6 01       	movw	r24, r12
    a5cc:	0e 94 17 84 	call	0x1082e	; 0x1082e <__eerd_byte_m2560>
		Oldstyle = 1;
		break;
	case EE_Enum:
		F_Buf = erb((uint8_t*)Var);
    a5d0:	90 e0       	ldi	r25, 0x00	; 0
    a5d2:	a0 e0       	ldi	r26, 0x00	; 0
    a5d4:	b0 e0       	ldi	r27, 0x00	; 0
    a5d6:	80 93 f7 04 	sts	0x04F7, r24
    a5da:	90 93 f8 04 	sts	0x04F8, r25
    a5de:	a0 93 f9 04 	sts	0x04F9, r26
    a5e2:	b0 93 fa 04 	sts	0x04FA, r27
    a5e6:	40 cf       	rjmp	.-384    	; 0xa468 <Field2Buf+0x196>
		Oldstyle = 1;
		break;
	case Bit:
		F_Buf = (*BitVar &Mask) > 0;
    a5e8:	20 e0       	ldi	r18, 0x00	; 0
    a5ea:	30 e0       	ldi	r19, 0x00	; 0
    a5ec:	40 e0       	ldi	r20, 0x00	; 0
    a5ee:	50 e0       	ldi	r21, 0x00	; 0
    a5f0:	f5 01       	movw	r30, r10
    a5f2:	80 81       	ld	r24, Z
    a5f4:	81 23       	and	r24, r17
    a5f6:	21 f5       	brne	.+72     	; 0xa640 <Field2Buf+0x36e>
    a5f8:	20 93 f7 04 	sts	0x04F7, r18
    a5fc:	30 93 f8 04 	sts	0x04F8, r19
    a600:	40 93 f9 04 	sts	0x04F9, r20
    a604:	50 93 fa 04 	sts	0x04FA, r21
    a608:	2f cf       	rjmp	.-418    	; 0xa468 <Field2Buf+0x196>
    a60a:	c5 01       	movw	r24, r10
    a60c:	0e 94 17 84 	call	0x1082e	; 0x1082e <__eerd_byte_m2560>
		Oldstyle = 1;
		break;
	case EE_Bit:
		F_Buf = (erb(BitVar) &Mask) > 0;
    a610:	10 92 f7 04 	sts	0x04F7, r1
    a614:	10 92 f8 04 	sts	0x04F8, r1
    a618:	10 92 f9 04 	sts	0x04F9, r1
    a61c:	10 92 fa 04 	sts	0x04FA, r1
    a620:	18 23       	and	r17, r24
    a622:	09 f4       	brne	.+2      	; 0xa626 <Field2Buf+0x354>
    a624:	21 cf       	rjmp	.-446    	; 0xa468 <Field2Buf+0x196>
    a626:	81 e0       	ldi	r24, 0x01	; 1
    a628:	90 e0       	ldi	r25, 0x00	; 0
    a62a:	a0 e0       	ldi	r26, 0x00	; 0
    a62c:	b0 e0       	ldi	r27, 0x00	; 0
    a62e:	80 93 f7 04 	sts	0x04F7, r24
    a632:	90 93 f8 04 	sts	0x04F8, r25
    a636:	a0 93 f9 04 	sts	0x04F9, r26
    a63a:	b0 93 fa 04 	sts	0x04FA, r27
    a63e:	14 cf       	rjmp	.-472    	; 0xa468 <Field2Buf+0x196>
	case EE_Enum:
		F_Buf = erb((uint8_t*)Var);
		Oldstyle = 1;
		break;
	case Bit:
		F_Buf = (*BitVar &Mask) > 0;
    a640:	21 e0       	ldi	r18, 0x01	; 1
    a642:	30 e0       	ldi	r19, 0x00	; 0
    a644:	40 e0       	ldi	r20, 0x00	; 0
    a646:	50 e0       	ldi	r21, 0x00	; 0
    a648:	d7 cf       	rjmp	.-82     	; 0xa5f8 <Field2Buf+0x326>
	Param.Size = CurrFieldSize;
	Param.Pos = BufStr;
	Param.Prec = prb(&Field->Prec);
	Param.Txt = NULL;

	switch(prb(&Field->Type)) {
    a64a:	82 31       	cpi	r24, 0x12	; 18
    a64c:	51 f1       	breq	.+84     	; 0xa6a2 <Field2Buf+0x3d0>
    a64e:	83 31       	cpi	r24, 0x13	; 19
    a650:	08 f0       	brcs	.+2      	; 0xa654 <Field2Buf+0x382>
    a652:	53 c0       	rjmp	.+166    	; 0xa6fa <Field2Buf+0x428>
    a654:	80 31       	cpi	r24, 0x10	; 16
    a656:	c1 f1       	breq	.+112    	; 0xa6c8 <Field2Buf+0x3f6>
    a658:	81 31       	cpi	r24, 0x11	; 17
    a65a:	09 f0       	breq	.+2      	; 0xa65e <Field2Buf+0x38c>
    a65c:	07 cf       	rjmp	.-498    	; 0xa46c <Field2Buf+0x19a>
// ~~~~~~~~~~~~~~~~~~~~~~
uint32_t
erd(const uint32_t *addr)
{
	//IntOff();
	uint32_t word = eeprom_read_dword(addr);
    a65e:	c6 01       	movw	r24, r12
    a660:	0e 94 1f 84 	call	0x1083e	; 0x1083e <__eerd_dword_m2560>
	case z_Longint:
		Put_zDVal(*(uint32_t*)Var, &Param);
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
		break;
	case EE_Longint: 
		PutDVal(erd((uint32_t*)Var), &Param);
    a664:	ae 01       	movw	r20, r28
    a666:	4b 5f       	subi	r20, 0xFB	; 251
    a668:	5f 4f       	sbci	r21, 0xFF	; 255
    a66a:	0e 94 ed 47 	call	0x8fda	; 0x8fda <PutDVal>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
    a66e:	8e ea       	ldi	r24, 0xAE	; 174
    a670:	96 e0       	ldi	r25, 0x06	; 6
    a672:	60 91 c3 05 	lds	r22, 0x05C3
    a676:	0e 94 17 42 	call	0x842e	; 0x842e <GetMultiSymbol>
    a67a:	80 93 f4 04 	sts	0x04F4, r24
    a67e:	f6 ce       	rjmp	.-532    	; 0xa46c <Field2Buf+0x19a>
    a680:	c6 01       	movw	r24, r12
    a682:	0e 94 1f 84 	call	0x1083e	; 0x1083e <__eerd_dword_m2560>
		break;
	case z_EE_Longint:
		Put_zDVal(erd((uint32_t*)Var), &Param);
    a686:	ae 01       	movw	r20, r28
    a688:	4b 5f       	subi	r20, 0xFB	; 251
    a68a:	5f 4f       	sbci	r21, 0xFF	; 255
    a68c:	0e 94 a3 45 	call	0x8b46	; 0x8b46 <Put_zDVal>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
    a690:	8e ea       	ldi	r24, 0xAE	; 174
    a692:	96 e0       	ldi	r25, 0x06	; 6
    a694:	60 91 c3 05 	lds	r22, 0x05C3
    a698:	0e 94 17 42 	call	0x842e	; 0x842e <GetMultiSymbol>
    a69c:	80 93 f4 04 	sts	0x04F4, r24
    a6a0:	e5 ce       	rjmp	.-566    	; 0xa46c <Field2Buf+0x19a>
		break;
	case s_Longint:
		Put_sDVal(*(int32_t*)Var, &Param);
    a6a2:	f6 01       	movw	r30, r12
    a6a4:	60 81       	ld	r22, Z
    a6a6:	71 81       	ldd	r23, Z+1	; 0x01
    a6a8:	82 81       	ldd	r24, Z+2	; 0x02
    a6aa:	93 81       	ldd	r25, Z+3	; 0x03
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
		break;
	case s_EE_Longint:
		Put_sDVal((int32_t)erd((uint32_t*)Var), &Param);
    a6ac:	ae 01       	movw	r20, r28
    a6ae:	4b 5f       	subi	r20, 0xFB	; 251
    a6b0:	5f 4f       	sbci	r21, 0xFF	; 255
    a6b2:	0e 94 c4 46 	call	0x8d88	; 0x8d88 <Put_sDVal>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
    a6b6:	8e ea       	ldi	r24, 0xAE	; 174
    a6b8:	96 e0       	ldi	r25, 0x06	; 6
    a6ba:	60 91 c3 05 	lds	r22, 0x05C3
    a6be:	0e 94 17 42 	call	0x842e	; 0x842e <GetMultiSymbol>
    a6c2:	80 93 f4 04 	sts	0x04F4, r24
    a6c6:	d2 ce       	rjmp	.-604    	; 0xa46c <Field2Buf+0x19a>
	Param.Prec = prb(&Field->Prec);
	Param.Txt = NULL;

	switch(prb(&Field->Type)) {
	case Longint:
		PutDVal(*(uint32_t*)Var, &Param);
    a6c8:	f6 01       	movw	r30, r12
    a6ca:	60 81       	ld	r22, Z
    a6cc:	71 81       	ldd	r23, Z+1	; 0x01
    a6ce:	82 81       	ldd	r24, Z+2	; 0x02
    a6d0:	93 81       	ldd	r25, Z+3	; 0x03
    a6d2:	c8 cf       	rjmp	.-112    	; 0xa664 <Field2Buf+0x392>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
		break;


	case FFloat:
		Put_FFVal(*(float*)Var, &Param);
    a6d4:	f6 01       	movw	r30, r12
    a6d6:	60 81       	ld	r22, Z
    a6d8:	71 81       	ldd	r23, Z+1	; 0x01
    a6da:	82 81       	ldd	r24, Z+2	; 0x02
    a6dc:	93 81       	ldd	r25, Z+3	; 0x03
    a6de:	ae 01       	movw	r20, r28
    a6e0:	4b 5f       	subi	r20, 0xFB	; 251
    a6e2:	5f 4f       	sbci	r21, 0xFF	; 255
    a6e4:	0e 94 4e 45 	call	0x8a9c	; 0x8a9c <Put_FFVal>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
    a6e8:	8e ea       	ldi	r24, 0xAE	; 174
    a6ea:	96 e0       	ldi	r25, 0x06	; 6
    a6ec:	60 91 c3 05 	lds	r22, 0x05C3
    a6f0:	0e 94 17 42 	call	0x842e	; 0x842e <GetMultiSymbol>
    a6f4:	80 93 f4 04 	sts	0x04F4, r24
    a6f8:	b9 ce       	rjmp	.-654    	; 0xa46c <Field2Buf+0x19a>
	Param.Size = CurrFieldSize;
	Param.Pos = BufStr;
	Param.Prec = prb(&Field->Prec);
	Param.Txt = NULL;

	switch(prb(&Field->Type)) {
    a6fa:	83 31       	cpi	r24, 0x13	; 19
    a6fc:	49 f0       	breq	.+18     	; 0xa710 <Field2Buf+0x43e>
    a6fe:	84 31       	cpi	r24, 0x14	; 20
    a700:	09 f0       	breq	.+2      	; 0xa704 <Field2Buf+0x432>
    a702:	b4 ce       	rjmp	.-664    	; 0xa46c <Field2Buf+0x19a>
	case Longint:
		PutDVal(*(uint32_t*)Var, &Param);
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
		break;
	case z_Longint:
		Put_zDVal(*(uint32_t*)Var, &Param);
    a704:	f6 01       	movw	r30, r12
    a706:	60 81       	ld	r22, Z
    a708:	71 81       	ldd	r23, Z+1	; 0x01
    a70a:	82 81       	ldd	r24, Z+2	; 0x02
    a70c:	93 81       	ldd	r25, Z+3	; 0x03
    a70e:	bb cf       	rjmp	.-138    	; 0xa686 <Field2Buf+0x3b4>
    a710:	c6 01       	movw	r24, r12
    a712:	0e 94 1f 84 	call	0x1083e	; 0x1083e <__eerd_dword_m2560>
    a716:	ca cf       	rjmp	.-108    	; 0xa6ac <Field2Buf+0x3da>
	Param.Size = CurrFieldSize;
	Param.Pos = BufStr;
	Param.Prec = prb(&Field->Prec);
	Param.Txt = NULL;

	switch(prb(&Field->Type)) {
    a718:	81 32       	cpi	r24, 0x21	; 33
    a71a:	69 f0       	breq	.+26     	; 0xa736 <Field2Buf+0x464>
    a71c:	82 32       	cpi	r24, 0x22	; 34
    a71e:	69 f1       	breq	.+90     	; 0xa77a <Field2Buf+0x4a8>
    a720:	8c 31       	cpi	r24, 0x1C	; 28
    a722:	09 f0       	breq	.+2      	; 0xa726 <Field2Buf+0x454>
    a724:	a3 ce       	rjmp	.-698    	; 0xa46c <Field2Buf+0x19a>
    a726:	8e 01       	movw	r16, r28
    a728:	0b 5f       	subi	r16, 0xFB	; 251
    a72a:	1f 4f       	sbci	r17, 0xFF	; 255
    a72c:	7e 01       	movw	r14, r28
    a72e:	08 94       	sec
    a730:	e1 1c       	adc	r14, r1
    a732:	f1 1c       	adc	r15, r1
    a734:	6c ce       	rjmp	.-808    	; 0xa40e <Field2Buf+0x13c>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
		break;


	case Text:
		Put_TextValAlignLeft((char*)Var, &Param);
    a736:	c6 01       	movw	r24, r12
		
		break;
	case EE_Text:{
			char TempStr[LCDXSz+1];
			erbl(TempStr, Var, CurrFieldSize);
			Put_TextValAlignLeft(TempStr, &Param);
    a738:	be 01       	movw	r22, r28
    a73a:	6b 5f       	subi	r22, 0xFB	; 251
    a73c:	7f 4f       	sbci	r23, 0xFF	; 255
    a73e:	0e 94 1c 44 	call	0x8838	; 0x8838 <Put_TextValAlignLeft>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    a742:	f7 01       	movw	r30, r14
    a744:	33 96       	adiw	r30, 0x03	; 3
    a746:	85 91       	lpm	r24, Z+
    a748:	95 91       	lpm	r25, Z+
    a74a:	a5 91       	lpm	r26, Z+
    a74c:	b4 91       	lpm	r27, Z+
			if( (prd(&Field->Min) == DIGIT) && (prd(&Field->Max) == DIGIT) )
    a74e:	00 97       	sbiw	r24, 0x00	; 0
    a750:	a1 05       	cpc	r26, r1
    a752:	b1 05       	cpc	r27, r1
    a754:	49 f4       	brne	.+18     	; 0xa768 <Field2Buf+0x496>
    a756:	f3 01       	movw	r30, r6
    a758:	85 91       	lpm	r24, Z+
    a75a:	95 91       	lpm	r25, Z+
    a75c:	a5 91       	lpm	r26, Z+
    a75e:	b4 91       	lpm	r27, Z+
    a760:	00 97       	sbiw	r24, 0x00	; 0
    a762:	a1 05       	cpc	r26, r1
    a764:	b1 05       	cpc	r27, r1
    a766:	99 f0       	breq	.+38     	; 0xa78e <Field2Buf+0x4bc>
				MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[0]);
			else MultiSymbol = GetMultiSymbol(Symbols_P, BufStr[0]);
    a768:	85 e0       	ldi	r24, 0x05	; 5
    a76a:	96 e0       	ldi	r25, 0x06	; 6
    a76c:	60 91 c3 05 	lds	r22, 0x05C3
    a770:	0e 94 17 42 	call	0x842e	; 0x842e <GetMultiSymbol>
    a774:	80 93 f4 04 	sts	0x04F4, r24
    a778:	79 ce       	rjmp	.-782    	; 0xa46c <Field2Buf+0x19a>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    a77a:	8e 01       	movw	r16, r28
    a77c:	05 5f       	subi	r16, 0xF5	; 245
    a77e:	1f 4f       	sbci	r17, 0xFF	; 255
    a780:	c8 01       	movw	r24, r16
    a782:	b6 01       	movw	r22, r12
    a784:	50 e0       	ldi	r21, 0x00	; 0
    a786:	0e 94 07 84 	call	0x1080e	; 0x1080e <__eerd_block_m2560>
		
		break;
	case EE_Text:{
			char TempStr[LCDXSz+1];
			erbl(TempStr, Var, CurrFieldSize);
			Put_TextValAlignLeft(TempStr, &Param);
    a78a:	c8 01       	movw	r24, r16
    a78c:	d5 cf       	rjmp	.-86     	; 0xa738 <Field2Buf+0x466>
			if( (prd(&Field->Min) == DIGIT) && (prd(&Field->Max) == DIGIT) )
				MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[0]);
    a78e:	83 ea       	ldi	r24, 0xA3	; 163
    a790:	96 e0       	ldi	r25, 0x06	; 6
    a792:	60 91 c3 05 	lds	r22, 0x05C3
    a796:	0e 94 17 42 	call	0x842e	; 0x842e <GetMultiSymbol>
    a79a:	80 93 f4 04 	sts	0x04F4, r24
    a79e:	66 ce       	rjmp	.-820    	; 0xa46c <Field2Buf+0x19a>
    a7a0:	8e 01       	movw	r16, r28
    a7a2:	0b 5f       	subi	r16, 0xFB	; 251
    a7a4:	1f 4f       	sbci	r17, 0xFF	; 255
    a7a6:	7e 01       	movw	r14, r28
    a7a8:	08 94       	sec
    a7aa:	e1 1c       	adc	r14, r1
    a7ac:	f1 1c       	adc	r15, r1
    a7ae:	1f ce       	rjmp	.-962    	; 0xa3ee <Field2Buf+0x11c>

0000a7b0 <MenuEscLeft>:
}

// ~~~~~~~~~~~~~~
void
MenuEscLeft(void)
{
    a7b0:	0f 93       	push	r16
    a7b2:	1f 93       	push	r17
    a7b4:	cf 93       	push	r28
    a7b6:	df 93       	push	r29
//	1) Hide current Message
	if(HideMsg()||KeyFunc(&CurrPage->Esc))
    a7b8:	0e 94 a6 3d 	call	0x7b4c	; 0x7b4c <HideMsg>
    a7bc:	88 23       	and	r24, r24
    a7be:	29 f0       	breq	.+10     	; 0xa7ca <MenuEscLeft+0x1a>
		else
			CurrPage=prp(&CurrPage->OutPage);
		CurrLine=CurrLCD=GetFix();
	}
	EventFunc(&CurrPage->Load);
}
    a7c0:	df 91       	pop	r29
    a7c2:	cf 91       	pop	r28
    a7c4:	1f 91       	pop	r17
    a7c6:	0f 91       	pop	r16
    a7c8:	08 95       	ret
// ~~~~~~~~~~~~~~
void
MenuEscLeft(void)
{
//	1) Hide current Message
	if(HideMsg()||KeyFunc(&CurrPage->Esc))
    a7ca:	80 91 d4 02 	lds	r24, 0x02D4
    a7ce:	90 91 d5 02 	lds	r25, 0x02D5
    a7d2:	0e 96       	adiw	r24, 0x0e	; 14
    a7d4:	0e 94 4c 3d 	call	0x7a98	; 0x7a98 <KeyFunc>
    a7d8:	88 23       	and	r24, r24
    a7da:	91 f7       	brne	.-28     	; 0xa7c0 <MenuEscLeft+0x10>
		return;

// 2) Variable
	if(CurrField!=NullPos) {
    a7dc:	30 91 d6 02 	lds	r19, 0x02D6
    a7e0:	3f 3f       	cpi	r19, 0xFF	; 255
    a7e2:	09 f4       	brne	.+2      	; 0xa7e6 <MenuEscLeft+0x36>
    a7e4:	c8 c0       	rjmp	.+400    	; 0xa976 <MenuEscLeft+0x1c6>
		if(CurrPos!=NullPos) {
    a7e6:	40 91 d7 02 	lds	r20, 0x02D7
    a7ea:	4f 3f       	cpi	r20, 0xFF	; 255
    a7ec:	09 f4       	brne	.+2      	; 0xa7f0 <MenuEscLeft+0x40>
    a7ee:	5a c0       	rjmp	.+180    	; 0xa8a4 <MenuEscLeft+0xf4>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    a7f0:	80 91 d4 02 	lds	r24, 0x02D4
    a7f4:	90 91 d5 02 	lds	r25, 0x02D5
    a7f8:	fc 01       	movw	r30, r24
    a7fa:	65 91       	lpm	r22, Z+
    a7fc:	74 91       	lpm	r23, Z+
			OutField *Field=GetField;
    a7fe:	80 91 c9 07 	lds	r24, 0x07C9
    a802:	2b e1       	ldi	r18, 0x1B	; 27
    a804:	82 9f       	mul	r24, r18
    a806:	c0 01       	movw	r24, r0
    a808:	11 24       	eor	r1, r1
    a80a:	68 0f       	add	r22, r24
    a80c:	79 1f       	adc	r23, r25
    a80e:	69 5e       	subi	r22, 0xE9	; 233
    a810:	7f 4f       	sbci	r23, 0xFF	; 255
    a812:	fb 01       	movw	r30, r22
    a814:	c5 91       	lpm	r28, Z+
    a816:	d4 91       	lpm	r29, Z+
    a818:	83 2f       	mov	r24, r19
    a81a:	90 e0       	ldi	r25, 0x00	; 0
    a81c:	82 95       	swap	r24
    a81e:	92 95       	swap	r25
    a820:	90 7f       	andi	r25, 0xF0	; 240
    a822:	98 27       	eor	r25, r24
    a824:	80 7f       	andi	r24, 0xF0	; 240
    a826:	98 27       	eor	r25, r24
    a828:	c8 0f       	add	r28, r24
    a82a:	d9 1f       	adc	r29, r25

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    a82c:	fe 01       	movw	r30, r28
    a82e:	14 91       	lpm	r17, Z+
			uint8_t Type=prb(&Field->Type);
			uint8_t Pos;

			if( (Type == Text) || (Type == EE_Text) ||
    a830:	01 2f       	mov	r16, r17
    a832:	01 52       	subi	r16, 0x21	; 33
    a834:	02 30       	cpi	r16, 0x02	; 2
    a836:	00 f1       	brcs	.+64     	; 0xa878 <MenuEscLeft+0xc8>
    a838:	10 31       	cpi	r17, 0x10	; 16
    a83a:	f1 f0       	breq	.+60     	; 0xa878 <MenuEscLeft+0xc8>
    a83c:	11 31       	cpi	r17, 0x11	; 17
    a83e:	e1 f0       	breq	.+56     	; 0xa878 <MenuEscLeft+0xc8>
    a840:	12 31       	cpi	r17, 0x12	; 18
    a842:	d1 f0       	breq	.+52     	; 0xa878 <MenuEscLeft+0xc8>
    a844:	13 31       	cpi	r17, 0x13	; 19
    a846:	c1 f0       	breq	.+48     	; 0xa878 <MenuEscLeft+0xc8>
    a848:	14 31       	cpi	r17, 0x14	; 20
    a84a:	b1 f0       	breq	.+44     	; 0xa878 <MenuEscLeft+0xc8>
    a84c:	15 31       	cpi	r17, 0x15	; 21
    a84e:	a1 f0       	breq	.+40     	; 0xa878 <MenuEscLeft+0xc8>
    a850:	19 31       	cpi	r17, 0x19	; 25
    a852:	91 f0       	breq	.+36     	; 0xa878 <MenuEscLeft+0xc8>
    a854:	1a 31       	cpi	r17, 0x1A	; 26
    a856:	81 f0       	breq	.+32     	; 0xa878 <MenuEscLeft+0xc8>
    a858:	1b 31       	cpi	r17, 0x1B	; 27
    a85a:	71 f0       	breq	.+28     	; 0xa878 <MenuEscLeft+0xc8>
    a85c:	1c 31       	cpi	r17, 0x1C	; 28
    a85e:	61 f0       	breq	.+24     	; 0xa878 <MenuEscLeft+0xc8>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    a860:	fe 01       	movw	r30, r28
    a862:	37 96       	adiw	r30, 0x07	; 7
    a864:	65 91       	lpm	r22, Z+
    a866:	75 91       	lpm	r23, Z+
    a868:	85 91       	lpm	r24, Z+
    a86a:	94 91       	lpm	r25, Z+
			 (Type == Longint) || (Type == EE_Longint)|| (Type == s_Longint) || (Type == s_EE_Longint) || (Type == z_Longint) || (Type == z_EE_Longint) ||
			 (Type == FFloat) || (Type == EE_FFloat) || (Type == GFloat) || (Type == EE_GFloat) ) 
			 	Pos = CurrFieldSize-1;
			else Pos=Log10(prd(&Field->Max));
    a86c:	0e 94 ca 21 	call	0x4394	; 0x4394 <Log10>
    a870:	98 2f       	mov	r25, r24
    a872:	40 91 d7 02 	lds	r20, 0x02D7
    a876:	03 c0       	rjmp	.+6      	; 0xa87e <MenuEscLeft+0xce>
			uint8_t Pos;

			if( (Type == Text) || (Type == EE_Text) ||
			 (Type == Longint) || (Type == EE_Longint)|| (Type == s_Longint) || (Type == s_EE_Longint) || (Type == z_Longint) || (Type == z_EE_Longint) ||
			 (Type == FFloat) || (Type == EE_FFloat) || (Type == GFloat) || (Type == EE_GFloat) ) 
			 	Pos = CurrFieldSize-1;
    a878:	90 91 c0 07 	lds	r25, 0x07C0
    a87c:	91 50       	subi	r25, 0x01	; 1
			else Pos=Log10(prd(&Field->Max));

			if(Type==s_Byte || Type==s_EE_Byte || Type==s_Word || Type==s_EE_Word)
    a87e:	81 2f       	mov	r24, r17
    a880:	82 50       	subi	r24, 0x02	; 2
    a882:	82 30       	cpi	r24, 0x02	; 2
    a884:	b0 f1       	brcs	.+108    	; 0xa8f2 <MenuEscLeft+0x142>
    a886:	19 30       	cpi	r17, 0x09	; 9
    a888:	a1 f1       	breq	.+104    	; 0xa8f2 <MenuEscLeft+0x142>
    a88a:	1a 30       	cpi	r17, 0x0A	; 10
    a88c:	91 f1       	breq	.+100    	; 0xa8f2 <MenuEscLeft+0x142>
				Pos++;
			if(++CurrPos>Pos)
    a88e:	24 2f       	mov	r18, r20
    a890:	2f 5f       	subi	r18, 0xFF	; 255
    a892:	20 93 d7 02 	sts	0x02D7, r18
    a896:	92 17       	cp	r25, r18
    a898:	70 f5       	brcc	.+92     	; 0xa8f6 <MenuEscLeft+0x146>
				CurrPos = NullPos;
    a89a:	8f ef       	ldi	r24, 0xFF	; 255
    a89c:	80 93 d7 02 	sts	0x02D7, r24
    a8a0:	30 91 d6 02 	lds	r19, 0x02D6
				}
				return;
			}
		}
		//     
		if(--CurrField!=NullPos)
    a8a4:	31 50       	subi	r19, 0x01	; 1
    a8a6:	30 93 d6 02 	sts	0x02D6, r19
    a8aa:	3f 3f       	cpi	r19, 0xFF	; 255
    a8ac:	09 f4       	brne	.+2      	; 0xa8b0 <MenuEscLeft+0x100>
    a8ae:	88 cf       	rjmp	.-240    	; 0xa7c0 <MenuEscLeft+0x10>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    a8b0:	80 91 d4 02 	lds	r24, 0x02D4
    a8b4:	90 91 d5 02 	lds	r25, 0x02D5
    a8b8:	fc 01       	movw	r30, r24
    a8ba:	45 91       	lpm	r20, Z+
    a8bc:	54 91       	lpm	r21, Z+
			Field2Buf(GetField);
    a8be:	80 91 c9 07 	lds	r24, 0x07C9
    a8c2:	2b e1       	ldi	r18, 0x1B	; 27
    a8c4:	82 9f       	mul	r24, r18
    a8c6:	c0 01       	movw	r24, r0
    a8c8:	11 24       	eor	r1, r1
    a8ca:	48 0f       	add	r20, r24
    a8cc:	59 1f       	adc	r21, r25
    a8ce:	49 5e       	subi	r20, 0xE9	; 233
    a8d0:	5f 4f       	sbci	r21, 0xFF	; 255
    a8d2:	fa 01       	movw	r30, r20
    a8d4:	85 91       	lpm	r24, Z+
    a8d6:	94 91       	lpm	r25, Z+
    a8d8:	23 2f       	mov	r18, r19
    a8da:	30 e0       	ldi	r19, 0x00	; 0
    a8dc:	22 95       	swap	r18
    a8de:	32 95       	swap	r19
    a8e0:	30 7f       	andi	r19, 0xF0	; 240
    a8e2:	32 27       	eor	r19, r18
    a8e4:	20 7f       	andi	r18, 0xF0	; 240
    a8e6:	32 27       	eor	r19, r18
    a8e8:	82 0f       	add	r24, r18
    a8ea:	93 1f       	adc	r25, r19
    a8ec:	0e 94 69 51 	call	0xa2d2	; 0xa2d2 <Field2Buf>
    a8f0:	67 cf       	rjmp	.-306    	; 0xa7c0 <MenuEscLeft+0x10>
			 (Type == FFloat) || (Type == EE_FFloat) || (Type == GFloat) || (Type == EE_GFloat) ) 
			 	Pos = CurrFieldSize-1;
			else Pos=Log10(prd(&Field->Max));

			if(Type==s_Byte || Type==s_EE_Byte || Type==s_Word || Type==s_EE_Word)
				Pos++;
    a8f2:	9f 5f       	subi	r25, 0xFF	; 255
    a8f4:	cc cf       	rjmp	.-104    	; 0xa88e <MenuEscLeft+0xde>
			if(++CurrPos>Pos)
				CurrPos = NullPos;
			else{
				switch(Type){
    a8f6:	1d 31       	cpi	r17, 0x1D	; 29
    a8f8:	40 f1       	brcs	.+80     	; 0xa94a <MenuEscLeft+0x19a>
    a8fa:	02 30       	cpi	r16, 0x02	; 2
    a8fc:	08 f0       	brcs	.+2      	; 0xa900 <MenuEscLeft+0x150>
    a8fe:	60 cf       	rjmp	.-320    	; 0xa7c0 <MenuEscLeft+0x10>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    a900:	fe 01       	movw	r30, r28
    a902:	33 96       	adiw	r30, 0x03	; 3
    a904:	85 91       	lpm	r24, Z+
    a906:	95 91       	lpm	r25, Z+
    a908:	a5 91       	lpm	r26, Z+
    a90a:	b4 91       	lpm	r27, Z+
				case Text: case EE_Text:
					if( (prd(&Field->Min) == DIGIT) && (prd(&Field->Max) == DIGIT) )
    a90c:	00 97       	sbiw	r24, 0x00	; 0
    a90e:	a1 05       	cpc	r26, r1
    a910:	b1 05       	cpc	r27, r1
    a912:	59 f4       	brne	.+22     	; 0xa92a <MenuEscLeft+0x17a>
    a914:	fe 01       	movw	r30, r28
    a916:	37 96       	adiw	r30, 0x07	; 7
    a918:	85 91       	lpm	r24, Z+
    a91a:	95 91       	lpm	r25, Z+
    a91c:	a5 91       	lpm	r26, Z+
    a91e:	b4 91       	lpm	r27, Z+
    a920:	00 97       	sbiw	r24, 0x00	; 0
    a922:	a1 05       	cpc	r26, r1
    a924:	b1 05       	cpc	r27, r1
    a926:	09 f4       	brne	.+2      	; 0xa92a <MenuEscLeft+0x17a>
    a928:	6f c0       	rjmp	.+222    	; 0xaa08 <MenuEscLeft+0x258>
						MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[CurrFieldSize - 1 - CurrPos]);
					else MultiSymbol = GetMultiSymbol(Symbols_P, BufStr[CurrFieldSize - 1 - CurrPos]);
    a92a:	e0 91 c0 07 	lds	r30, 0x07C0
    a92e:	f0 e0       	ldi	r31, 0x00	; 0
    a930:	31 97       	sbiw	r30, 0x01	; 1
    a932:	e2 1b       	sub	r30, r18
    a934:	f1 09       	sbc	r31, r1
    a936:	ed 53       	subi	r30, 0x3D	; 61
    a938:	fa 4f       	sbci	r31, 0xFA	; 250
    a93a:	85 e0       	ldi	r24, 0x05	; 5
    a93c:	96 e0       	ldi	r25, 0x06	; 6
    a93e:	60 81       	ld	r22, Z
    a940:	0e 94 17 42 	call	0x842e	; 0x842e <GetMultiSymbol>
    a944:	80 93 f4 04 	sts	0x04F4, r24
    a948:	3b cf       	rjmp	.-394    	; 0xa7c0 <MenuEscLeft+0x10>
			if(Type==s_Byte || Type==s_EE_Byte || Type==s_Word || Type==s_EE_Word)
				Pos++;
			if(++CurrPos>Pos)
				CurrPos = NullPos;
			else{
				switch(Type){
    a94a:	19 31       	cpi	r17, 0x19	; 25
    a94c:	20 f4       	brcc	.+8      	; 0xa956 <MenuEscLeft+0x1a6>
    a94e:	10 51       	subi	r17, 0x10	; 16
    a950:	16 30       	cpi	r17, 0x06	; 6
    a952:	08 f0       	brcs	.+2      	; 0xa956 <MenuEscLeft+0x1a6>
    a954:	35 cf       	rjmp	.-406    	; 0xa7c0 <MenuEscLeft+0x10>
						MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[CurrFieldSize - 1 - CurrPos]);
					else MultiSymbol = GetMultiSymbol(Symbols_P, BufStr[CurrFieldSize - 1 - CurrPos]);
					break;
				case Longint: case z_Longint: case EE_Longint: case z_EE_Longint: case s_Longint: case s_EE_Longint:
				case FFloat: case EE_FFloat: case GFloat: case EE_GFloat:
					MultiSymbol = GetMultiSymbol(Digits_P, BufStr[CurrFieldSize - 1 - CurrPos]);
    a956:	e0 91 c0 07 	lds	r30, 0x07C0
    a95a:	f0 e0       	ldi	r31, 0x00	; 0
    a95c:	31 97       	sbiw	r30, 0x01	; 1
    a95e:	e2 1b       	sub	r30, r18
    a960:	f1 09       	sbc	r31, r1
    a962:	ed 53       	subi	r30, 0x3D	; 61
    a964:	fa 4f       	sbci	r31, 0xFA	; 250
    a966:	8e ea       	ldi	r24, 0xAE	; 174
    a968:	96 e0       	ldi	r25, 0x06	; 6
    a96a:	60 81       	ld	r22, Z
    a96c:	0e 94 17 42 	call	0x842e	; 0x842e <GetMultiSymbol>
    a970:	80 93 f4 04 	sts	0x04F4, r24
    a974:	25 cf       	rjmp	.-438    	; 0xa7c0 <MenuEscLeft+0x10>
			Field2Buf(GetField);
		return;
	}

// 3) Go to menu
	EventFunc(&CurrPage->Exit);
    a976:	80 91 d4 02 	lds	r24, 0x02D4
    a97a:	90 91 d5 02 	lds	r25, 0x02D5
    a97e:	0a 96       	adiw	r24, 0x0a	; 10
    a980:	0e 94 44 3d 	call	0x7a88	; 0x7a88 <EventFunc>
	if(MenuDepth) {
    a984:	e0 91 ba 07 	lds	r30, 0x07BA
    a988:	ee 23       	and	r30, r30
    a98a:	21 f1       	breq	.+72     	; 0xa9d4 <MenuEscLeft+0x224>
		CurrPage=MenuStack[--MenuDepth].Page;
    a98c:	e1 50       	subi	r30, 0x01	; 1
    a98e:	e0 93 ba 07 	sts	0x07BA, r30
    a992:	f0 e0       	ldi	r31, 0x00	; 0
    a994:	ee 0f       	add	r30, r30
    a996:	ff 1f       	adc	r31, r31
    a998:	ee 0f       	add	r30, r30
    a99a:	ff 1f       	adc	r31, r31
    a99c:	df 01       	movw	r26, r30
    a99e:	a8 51       	subi	r26, 0x18	; 24
    a9a0:	b7 4f       	sbci	r27, 0xF7	; 247
    a9a2:	9c 91       	ld	r25, X
    a9a4:	11 96       	adiw	r26, 0x01	; 1
    a9a6:	2c 91       	ld	r18, X
    a9a8:	11 97       	sbiw	r26, 0x01	; 1
    a9aa:	90 93 d4 02 	sts	0x02D4, r25
    a9ae:	20 93 d5 02 	sts	0x02D5, r18
		CurrLine=MenuStack[MenuDepth].Line;
    a9b2:	13 96       	adiw	r26, 0x03	; 3
    a9b4:	8c 91       	ld	r24, X
    a9b6:	80 93 c9 07 	sts	0x07C9, r24
		CurrLCD=MenuStack[MenuDepth].LCD;
    a9ba:	e6 51       	subi	r30, 0x16	; 22
    a9bc:	f7 4f       	sbci	r31, 0xF7	; 247
    a9be:	80 81       	ld	r24, Z
    a9c0:	80 93 e7 08 	sts	0x08E7, r24
    a9c4:	e9 2f       	mov	r30, r25
    a9c6:	f2 2f       	mov	r31, r18
    a9c8:	9f 01       	movw	r18, r30
		}
		else
			CurrPage=prp(&CurrPage->OutPage);
		CurrLine=CurrLCD=GetFix();
	}
	EventFunc(&CurrPage->Load);
    a9ca:	c9 01       	movw	r24, r18
    a9cc:	06 96       	adiw	r24, 0x06	; 6
    a9ce:	0e 94 44 3d 	call	0x7a88	; 0x7a88 <EventFunc>
    a9d2:	f6 ce       	rjmp	.-532    	; 0xa7c0 <MenuEscLeft+0x10>
		CurrPage=MenuStack[--MenuDepth].Page;
		CurrLine=MenuStack[MenuDepth].Line;
		CurrLCD=MenuStack[MenuDepth].LCD;
	}
	else {
		if(NextPage) {
    a9d4:	e0 91 d9 05 	lds	r30, 0x05D9
    a9d8:	f0 91 da 05 	lds	r31, 0x05DA
    a9dc:	30 97       	sbiw	r30, 0x00	; 0
    a9de:	21 f1       	breq	.+72     	; 0xaa28 <MenuEscLeft+0x278>
			CurrPage=NextPage;
    a9e0:	f0 93 d5 02 	sts	0x02D5, r31
    a9e4:	e0 93 d4 02 	sts	0x02D4, r30
			NextPage=NULL;
    a9e8:	10 92 da 05 	sts	0x05DA, r1
    a9ec:	10 92 d9 05 	sts	0x05D9, r1
    a9f0:	9f 01       	movw	r18, r30

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    a9f2:	2d 5f       	subi	r18, 0xFD	; 253
    a9f4:	3f 4f       	sbci	r19, 0xFF	; 255
    a9f6:	f9 01       	movw	r30, r18
    a9f8:	84 91       	lpm	r24, Z+
    a9fa:	23 50       	subi	r18, 0x03	; 3
    a9fc:	30 40       	sbci	r19, 0x00	; 0
		}
		else
			CurrPage=prp(&CurrPage->OutPage);
		CurrLine=CurrLCD=GetFix();
    a9fe:	80 93 e7 08 	sts	0x08E7, r24
    aa02:	80 93 c9 07 	sts	0x07C9, r24
    aa06:	e1 cf       	rjmp	.-62     	; 0xa9ca <MenuEscLeft+0x21a>
				CurrPos = NullPos;
			else{
				switch(Type){
				case Text: case EE_Text:
					if( (prd(&Field->Min) == DIGIT) && (prd(&Field->Max) == DIGIT) )
						MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[CurrFieldSize - 1 - CurrPos]);
    aa08:	e0 91 c0 07 	lds	r30, 0x07C0
    aa0c:	f0 e0       	ldi	r31, 0x00	; 0
    aa0e:	31 97       	sbiw	r30, 0x01	; 1
    aa10:	e2 1b       	sub	r30, r18
    aa12:	f1 09       	sbc	r31, r1
    aa14:	ed 53       	subi	r30, 0x3D	; 61
    aa16:	fa 4f       	sbci	r31, 0xFA	; 250
    aa18:	83 ea       	ldi	r24, 0xA3	; 163
    aa1a:	96 e0       	ldi	r25, 0x06	; 6
    aa1c:	60 81       	ld	r22, Z
    aa1e:	0e 94 17 42 	call	0x842e	; 0x842e <GetMultiSymbol>
    aa22:	80 93 f4 04 	sts	0x04F4, r24
    aa26:	cc ce       	rjmp	.-616    	; 0xa7c0 <MenuEscLeft+0x10>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    aa28:	80 91 d4 02 	lds	r24, 0x02D4
    aa2c:	90 91 d5 02 	lds	r25, 0x02D5
    aa30:	04 96       	adiw	r24, 0x04	; 4
		if(NextPage) {
			CurrPage=NextPage;
			NextPage=NULL;
		}
		else
			CurrPage=prp(&CurrPage->OutPage);
    aa32:	fc 01       	movw	r30, r24
    aa34:	25 91       	lpm	r18, Z+
    aa36:	34 91       	lpm	r19, Z+
    aa38:	30 93 d5 02 	sts	0x02D5, r19
    aa3c:	20 93 d4 02 	sts	0x02D4, r18
    aa40:	d8 cf       	rjmp	.-80     	; 0xa9f2 <MenuEscLeft+0x242>

0000aa42 <Buf2Field>:
// ~~~~~~~~~~~~~~~~~~~~~~~
//       
//     -
static void
Buf2Field(OutField *Field)
{
    aa42:	3f 92       	push	r3
    aa44:	4f 92       	push	r4
    aa46:	5f 92       	push	r5
    aa48:	6f 92       	push	r6
    aa4a:	7f 92       	push	r7
    aa4c:	8f 92       	push	r8
    aa4e:	9f 92       	push	r9
    aa50:	af 92       	push	r10
    aa52:	bf 92       	push	r11
    aa54:	cf 92       	push	r12
    aa56:	df 92       	push	r13
    aa58:	ef 92       	push	r14
    aa5a:	ff 92       	push	r15
    aa5c:	0f 93       	push	r16
    aa5e:	1f 93       	push	r17
    aa60:	df 93       	push	r29
    aa62:	cf 93       	push	r28
    aa64:	cd b7       	in	r28, 0x3d	; 61
    aa66:	de b7       	in	r29, 0x3e	; 62
    aa68:	6d 97       	sbiw	r28, 0x1d	; 29
    aa6a:	0f b6       	in	r0, 0x3f	; 63
    aa6c:	f8 94       	cli
    aa6e:	de bf       	out	0x3e, r29	; 62
    aa70:	0f be       	out	0x3f, r0	; 63
    aa72:	cd bf       	out	0x3d, r28	; 61
    aa74:	6c 01       	movw	r12, r24
    aa76:	fc 01       	movw	r30, r24
    aa78:	31 96       	adiw	r30, 0x01	; 1
    aa7a:	45 90       	lpm	r4, Z+
    aa7c:	54 90       	lpm	r5, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    aa7e:	2f e0       	ldi	r18, 0x0F	; 15
    aa80:	30 e0       	ldi	r19, 0x00	; 0
    aa82:	c2 0e       	add	r12, r18
    aa84:	d3 1e       	adc	r13, r19
    aa86:	f6 01       	movw	r30, r12
    aa88:	24 91       	lpm	r18, Z+
    aa8a:	81 ef       	ldi	r24, 0xF1	; 241
    aa8c:	9f ef       	ldi	r25, 0xFF	; 255
    aa8e:	c8 0e       	add	r12, r24
    aa90:	d9 1e       	adc	r13, r25
	void *Var = prp(&Field->Var);
	uint8_t BitN=prb(&Field->Prec), Mask=1<<BitN%8, *BitVar=(uint8_t*)Var+BitN/8;
    aa92:	32 2f       	mov	r19, r18
    aa94:	37 70       	andi	r19, 0x07	; 7
    aa96:	81 e0       	ldi	r24, 0x01	; 1
    aa98:	90 e0       	ldi	r25, 0x00	; 0
    aa9a:	38 2e       	mov	r3, r24
    aa9c:	01 c0       	rjmp	.+2      	; 0xaaa0 <Buf2Field+0x5e>
    aa9e:	33 0c       	add	r3, r3
    aaa0:	3a 95       	dec	r19
    aaa2:	ea f7       	brpl	.-6      	; 0xaa9e <Buf2Field+0x5c>
    aaa4:	26 95       	lsr	r18
    aaa6:	26 95       	lsr	r18
    aaa8:	26 95       	lsr	r18
    aaaa:	32 01       	movw	r6, r4
    aaac:	62 0e       	add	r6, r18
    aaae:	71 1c       	adc	r7, r1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    aab0:	f6 01       	movw	r30, r12
    aab2:	33 96       	adiw	r30, 0x03	; 3
    aab4:	85 90       	lpm	r8, Z+
    aab6:	95 90       	lpm	r9, Z+
    aab8:	a5 90       	lpm	r10, Z+
    aaba:	b4 90       	lpm	r11, Z+
	uint8_t EE_BitVar;
	uint32_t Min=prd(&Field->Min), Max=prd(&Field->Max);

	uint32_t Temp=0;
    aabc:	f6 01       	movw	r30, r12
    aabe:	37 96       	adiw	r30, 0x07	; 7
    aac0:	e5 90       	lpm	r14, Z+
    aac2:	f5 90       	lpm	r15, Z+
    aac4:	05 91       	lpm	r16, Z+
    aac6:	14 91       	lpm	r17, Z+
    aac8:	19 82       	std	Y+1, r1	; 0x01
    aaca:	1a 82       	std	Y+2, r1	; 0x02
    aacc:	1b 82       	std	Y+3, r1	; 0x03
    aace:	1c 82       	std	Y+4, r1	; 0x04
	float fTemp=0;
    aad0:	80 e0       	ldi	r24, 0x00	; 0
    aad2:	90 e0       	ldi	r25, 0x00	; 0
    aad4:	a0 e0       	ldi	r26, 0x00	; 0
    aad6:	b0 e0       	ldi	r27, 0x00	; 0
    aad8:	8d 83       	std	Y+5, r24	; 0x05
    aada:	9e 83       	std	Y+6, r25	; 0x06
    aadc:	af 83       	std	Y+7, r26	; 0x07
    aade:	b8 87       	std	Y+8, r27	; 0x08

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    aae0:	f6 01       	movw	r30, r12
    aae2:	84 91       	lpm	r24, Z+

	switch(prb(&Field->Type)) {
    aae4:	e8 2f       	mov	r30, r24
    aae6:	f0 e0       	ldi	r31, 0x00	; 0
    aae8:	e3 32       	cpi	r30, 0x23	; 35
    aaea:	f1 05       	cpc	r31, r1
    aaec:	08 f0       	brcs	.+2      	; 0xaaf0 <Buf2Field+0xae>
    aaee:	3f c0       	rjmp	.+126    	; 0xab6e <Buf2Field+0x12c>
    aaf0:	ed 56       	subi	r30, 0x6D	; 109
    aaf2:	ff 4f       	sbci	r31, 0xFF	; 255
    aaf4:	ee 0f       	add	r30, r30
    aaf6:	ff 1f       	adc	r31, r31
    aaf8:	05 90       	lpm	r0, Z+
    aafa:	f4 91       	lpm	r31, Z+
    aafc:	e0 2d       	mov	r30, r0
    aafe:	19 94       	eijmp
		PresicionHanler(Field);
		sscanf(BufStr,"%lud", (uint32_t*)&Temp);
		SetField32(Temp, uint32_t);
		break;
	case EE_Longint: case z_EE_Longint:
		PresicionHanler(Field);
    ab00:	c6 01       	movw	r24, r12
    ab02:	0e 94 dd 41 	call	0x83ba	; 0x83ba <PresicionHanler>
		if(sscanf(BufStr,"%lud", (uint32_t*)&Temp) == 1){
    ab06:	00 d0       	rcall	.+0      	; 0xab08 <Buf2Field+0xc6>
    ab08:	00 d0       	rcall	.+0      	; 0xab0a <Buf2Field+0xc8>
    ab0a:	ed b7       	in	r30, 0x3d	; 61
    ab0c:	fe b7       	in	r31, 0x3e	; 62
    ab0e:	31 96       	adiw	r30, 0x01	; 1
    ab10:	83 ec       	ldi	r24, 0xC3	; 195
    ab12:	95 e0       	ldi	r25, 0x05	; 5
    ab14:	ad b7       	in	r26, 0x3d	; 61
    ab16:	be b7       	in	r27, 0x3e	; 62
    ab18:	12 96       	adiw	r26, 0x02	; 2
    ab1a:	9c 93       	st	X, r25
    ab1c:	8e 93       	st	-X, r24
    ab1e:	11 97       	sbiw	r26, 0x01	; 1
    ab20:	8f e9       	ldi	r24, 0x9F	; 159
    ab22:	92 e0       	ldi	r25, 0x02	; 2
    ab24:	93 83       	std	Z+3, r25	; 0x03
    ab26:	82 83       	std	Z+2, r24	; 0x02
    ab28:	ce 01       	movw	r24, r28
    ab2a:	01 96       	adiw	r24, 0x01	; 1
    ab2c:	95 83       	std	Z+5, r25	; 0x05
    ab2e:	84 83       	std	Z+4, r24	; 0x04
    ab30:	0e 94 4b 82 	call	0x10496	; 0x10496 <sscanf>
    ab34:	ed b7       	in	r30, 0x3d	; 61
    ab36:	fe b7       	in	r31, 0x3e	; 62
    ab38:	36 96       	adiw	r30, 0x06	; 6
    ab3a:	0f b6       	in	r0, 0x3f	; 63
    ab3c:	f8 94       	cli
    ab3e:	fe bf       	out	0x3e, r31	; 62
    ab40:	0f be       	out	0x3f, r0	; 63
    ab42:	ed bf       	out	0x3d, r30	; 61
    ab44:	01 97       	sbiw	r24, 0x01	; 1
    ab46:	99 f4       	brne	.+38     	; 0xab6e <Buf2Field+0x12c>
			SetEEField32(Temp, uint32_t, uint32_t, d);
    ab48:	49 81       	ldd	r20, Y+1	; 0x01
    ab4a:	5a 81       	ldd	r21, Y+2	; 0x02
    ab4c:	6b 81       	ldd	r22, Y+3	; 0x03
    ab4e:	7c 81       	ldd	r23, Y+4	; 0x04
    ab50:	e4 16       	cp	r14, r20
    ab52:	f5 06       	cpc	r15, r21
    ab54:	06 07       	cpc	r16, r22
    ab56:	17 07       	cpc	r17, r23
    ab58:	08 f4       	brcc	.+2      	; 0xab5c <Buf2Field+0x11a>
    ab5a:	cc c2       	rjmp	.+1432   	; 0xb0f4 <Buf2Field+0x6b2>
    ab5c:	48 15       	cp	r20, r8
    ab5e:	59 05       	cpc	r21, r9
    ab60:	6a 05       	cpc	r22, r10
    ab62:	7b 05       	cpc	r23, r11
    ab64:	08 f4       	brcc	.+2      	; 0xab68 <Buf2Field+0x126>
    ab66:	f8 c1       	rjmp	.+1008   	; 0xaf58 <Buf2Field+0x516>
		SetField32(Temp, int32_t);
		break;
	case s_EE_Longint:
		PresicionHanler(Field);
		if(sscanf(BufStr,"%ld", (int32_t*)&Temp) == 1){
			SetEEField32(Temp, int32_t, uint32_t, d);
    ab68:	c2 01       	movw	r24, r4
    ab6a:	0e 94 e3 4e 	call	0x9dc6	; 0x9dc6 <ewd>
			ewbl(TempStr, Var, Width);
		}
		break;

	}
	EventFunc(&Field->Act);
    ab6e:	c6 01       	movw	r24, r12
    ab70:	0b 96       	adiw	r24, 0x0b	; 11
    ab72:	0e 94 44 3d 	call	0x7a88	; 0x7a88 <EventFunc>
}
    ab76:	6d 96       	adiw	r28, 0x1d	; 29
    ab78:	0f b6       	in	r0, 0x3f	; 63
    ab7a:	f8 94       	cli
    ab7c:	de bf       	out	0x3e, r29	; 62
    ab7e:	0f be       	out	0x3f, r0	; 63
    ab80:	cd bf       	out	0x3d, r28	; 61
    ab82:	cf 91       	pop	r28
    ab84:	df 91       	pop	r29
    ab86:	1f 91       	pop	r17
    ab88:	0f 91       	pop	r16
    ab8a:	ff 90       	pop	r15
    ab8c:	ef 90       	pop	r14
    ab8e:	df 90       	pop	r13
    ab90:	cf 90       	pop	r12
    ab92:	bf 90       	pop	r11
    ab94:	af 90       	pop	r10
    ab96:	9f 90       	pop	r9
    ab98:	8f 90       	pop	r8
    ab9a:	7f 90       	pop	r7
    ab9c:	6f 90       	pop	r6
    ab9e:	5f 90       	pop	r5
    aba0:	4f 90       	pop	r4
    aba2:	3f 90       	pop	r3
    aba4:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    aba6:	8e 01       	movw	r16, r28
    aba8:	07 5f       	subi	r16, 0xF7	; 247
    abaa:	1f 4f       	sbci	r17, 0xFF	; 255
    abac:	c8 01       	movw	r24, r16
    abae:	b2 01       	movw	r22, r4
    abb0:	45 e1       	ldi	r20, 0x15	; 21
    abb2:	50 e0       	ldi	r21, 0x00	; 0
    abb4:	0e 94 07 84 	call	0x1080e	; 0x1080e <__eerd_block_m2560>
		}
		break;
	case EE_Text:{
			char TempStr[LCDXSz+1];
			erbl(TempStr, Var, LCDXSz+1);
			uint8_t Width = strlen(TempStr);
    abb8:	d8 01       	movw	r26, r16
    abba:	0d 90       	ld	r0, X+
    abbc:	00 20       	and	r0, r0
    abbe:	e9 f7       	brne	.-6      	; 0xabba <Buf2Field+0x178>
    abc0:	7d 01       	movw	r14, r26
    abc2:	08 94       	sec
    abc4:	e1 08       	sbc	r14, r1
    abc6:	f1 08       	sbc	r15, r1
    abc8:	e0 1a       	sub	r14, r16
    abca:	f1 0a       	sbc	r15, r17
			memcpy(TempStr, BufStr, Width);
    abcc:	23 ec       	ldi	r18, 0xC3	; 195
    abce:	35 e0       	ldi	r19, 0x05	; 5
    abd0:	c8 01       	movw	r24, r16
    abd2:	b9 01       	movw	r22, r18
    abd4:	4e 2d       	mov	r20, r14
    abd6:	50 e0       	ldi	r21, 0x00	; 0
    abd8:	0e 94 39 81 	call	0x10272	; 0x10272 <memcpy>
			ewbl(TempStr, Var, Width);
    abdc:	c8 01       	movw	r24, r16
    abde:	b2 01       	movw	r22, r4
    abe0:	4e 2d       	mov	r20, r14
    abe2:	50 e0       	ldi	r21, 0x00	; 0
    abe4:	0e 94 de 4e 	call	0x9dbc	; 0x9dbc <ewbl>
    abe8:	c2 cf       	rjmp	.-124    	; 0xab6e <Buf2Field+0x12c>
	uint32_t Temp=0;
	float fTemp=0;

	switch(prb(&Field->Type)) {
	case Byte: case z_Byte: case Enum:
		SetField(F_Buf, uint8_t);
    abea:	20 91 f7 04 	lds	r18, 0x04F7
    abee:	30 91 f8 04 	lds	r19, 0x04F8
    abf2:	40 91 f9 04 	lds	r20, 0x04F9
    abf6:	50 91 fa 04 	lds	r21, 0x04FA
    abfa:	8e 2d       	mov	r24, r14
    abfc:	90 e0       	ldi	r25, 0x00	; 0
    abfe:	a0 e0       	ldi	r26, 0x00	; 0
    ac00:	b0 e0       	ldi	r27, 0x00	; 0
    ac02:	82 17       	cp	r24, r18
    ac04:	93 07       	cpc	r25, r19
    ac06:	a4 07       	cpc	r26, r20
    ac08:	b5 07       	cpc	r27, r21
    ac0a:	08 f4       	brcc	.+2      	; 0xac0e <Buf2Field+0x1cc>
    ac0c:	50 c2       	rjmp	.+1184   	; 0xb0ae <Buf2Field+0x66c>
    ac0e:	88 2d       	mov	r24, r8
    ac10:	90 e0       	ldi	r25, 0x00	; 0
    ac12:	a0 e0       	ldi	r26, 0x00	; 0
    ac14:	b0 e0       	ldi	r27, 0x00	; 0
    ac16:	28 17       	cp	r18, r24
    ac18:	39 07       	cpc	r19, r25
    ac1a:	4a 07       	cpc	r20, r26
    ac1c:	5b 07       	cpc	r21, r27
    ac1e:	08 f0       	brcs	.+2      	; 0xac22 <Buf2Field+0x1e0>
    ac20:	66 c2       	rjmp	.+1228   	; 0xb0ee <Buf2Field+0x6ac>
    ac22:	f2 01       	movw	r30, r4
    ac24:	80 82       	st	Z, r8
    ac26:	a3 cf       	rjmp	.-186    	; 0xab6e <Buf2Field+0x12c>
		break;
	case s_Byte:
		SetField(sF_Buf, int8_t);
		break;
	case EE_Byte: case z_EE_Byte: case EE_Enum:
		SetEEField(F_Buf, uint8_t, uint8_t, b);
    ac28:	20 91 f7 04 	lds	r18, 0x04F7
    ac2c:	30 91 f8 04 	lds	r19, 0x04F8
    ac30:	40 91 f9 04 	lds	r20, 0x04F9
    ac34:	50 91 fa 04 	lds	r21, 0x04FA
    ac38:	8e 2d       	mov	r24, r14
    ac3a:	90 e0       	ldi	r25, 0x00	; 0
    ac3c:	a0 e0       	ldi	r26, 0x00	; 0
    ac3e:	b0 e0       	ldi	r27, 0x00	; 0
    ac40:	82 17       	cp	r24, r18
    ac42:	93 07       	cpc	r25, r19
    ac44:	a4 07       	cpc	r26, r20
    ac46:	b5 07       	cpc	r27, r21
    ac48:	08 f4       	brcc	.+2      	; 0xac4c <Buf2Field+0x20a>
    ac4a:	41 c2       	rjmp	.+1154   	; 0xb0ce <Buf2Field+0x68c>
    ac4c:	88 2d       	mov	r24, r8
    ac4e:	90 e0       	ldi	r25, 0x00	; 0
    ac50:	a0 e0       	ldi	r26, 0x00	; 0
    ac52:	b0 e0       	ldi	r27, 0x00	; 0
    ac54:	28 17       	cp	r18, r24
    ac56:	39 07       	cpc	r19, r25
    ac58:	4a 07       	cpc	r20, r26
    ac5a:	5b 07       	cpc	r21, r27
    ac5c:	08 f4       	brcc	.+2      	; 0xac60 <Buf2Field+0x21e>
    ac5e:	48 c0       	rjmp	.+144    	; 0xacf0 <Buf2Field+0x2ae>
		break;
	case s_EE_Byte:
		SetEEField(sF_Buf, int8_t, uint8_t, b);
    ac60:	c2 01       	movw	r24, r4
    ac62:	62 2f       	mov	r22, r18
    ac64:	0e 94 69 4d 	call	0x9ad2	; 0x9ad2 <ewb>
    ac68:	82 cf       	rjmp	.-252    	; 0xab6e <Buf2Field+0x12c>
	switch(prb(&Field->Type)) {
	case Byte: case z_Byte: case Enum:
		SetField(F_Buf, uint8_t);
		break;
	case s_Byte:
		SetField(sF_Buf, int8_t);
    ac6a:	20 91 fb 04 	lds	r18, 0x04FB
    ac6e:	30 91 fc 04 	lds	r19, 0x04FC
    ac72:	40 91 fd 04 	lds	r20, 0x04FD
    ac76:	50 91 fe 04 	lds	r21, 0x04FE
    ac7a:	8e 2d       	mov	r24, r14
    ac7c:	99 27       	eor	r25, r25
    ac7e:	87 fd       	sbrc	r24, 7
    ac80:	90 95       	com	r25
    ac82:	a9 2f       	mov	r26, r25
    ac84:	b9 2f       	mov	r27, r25
    ac86:	82 17       	cp	r24, r18
    ac88:	93 07       	cpc	r25, r19
    ac8a:	a4 07       	cpc	r26, r20
    ac8c:	b5 07       	cpc	r27, r21
    ac8e:	0c f4       	brge	.+2      	; 0xac92 <Buf2Field+0x250>
    ac90:	08 c2       	rjmp	.+1040   	; 0xb0a2 <Buf2Field+0x660>
    ac92:	88 2d       	mov	r24, r8
    ac94:	99 27       	eor	r25, r25
    ac96:	87 fd       	sbrc	r24, 7
    ac98:	90 95       	com	r25
    ac9a:	a9 2f       	mov	r26, r25
    ac9c:	b9 2f       	mov	r27, r25
    ac9e:	28 17       	cp	r18, r24
    aca0:	39 07       	cpc	r19, r25
    aca2:	4a 07       	cpc	r20, r26
    aca4:	5b 07       	cpc	r21, r27
    aca6:	0c f0       	brlt	.+2      	; 0xacaa <Buf2Field+0x268>
    aca8:	17 c2       	rjmp	.+1070   	; 0xb0d8 <Buf2Field+0x696>
    acaa:	d2 01       	movw	r26, r4
    acac:	8c 92       	st	X, r8
    acae:	5f cf       	rjmp	.-322    	; 0xab6e <Buf2Field+0x12c>
		break;
	case EE_Byte: case z_EE_Byte: case EE_Enum:
		SetEEField(F_Buf, uint8_t, uint8_t, b);
		break;
	case s_EE_Byte:
		SetEEField(sF_Buf, int8_t, uint8_t, b);
    acb0:	20 91 fb 04 	lds	r18, 0x04FB
    acb4:	30 91 fc 04 	lds	r19, 0x04FC
    acb8:	40 91 fd 04 	lds	r20, 0x04FD
    acbc:	50 91 fe 04 	lds	r21, 0x04FE
    acc0:	8e 2d       	mov	r24, r14
    acc2:	99 27       	eor	r25, r25
    acc4:	87 fd       	sbrc	r24, 7
    acc6:	90 95       	com	r25
    acc8:	a9 2f       	mov	r26, r25
    acca:	b9 2f       	mov	r27, r25
    accc:	82 17       	cp	r24, r18
    acce:	93 07       	cpc	r25, r19
    acd0:	a4 07       	cpc	r26, r20
    acd2:	b5 07       	cpc	r27, r21
    acd4:	0c f4       	brge	.+2      	; 0xacd8 <Buf2Field+0x296>
    acd6:	fb c1       	rjmp	.+1014   	; 0xb0ce <Buf2Field+0x68c>
    acd8:	88 2d       	mov	r24, r8
    acda:	99 27       	eor	r25, r25
    acdc:	87 fd       	sbrc	r24, 7
    acde:	90 95       	com	r25
    ace0:	a9 2f       	mov	r26, r25
    ace2:	b9 2f       	mov	r27, r25
    ace4:	28 17       	cp	r18, r24
    ace6:	39 07       	cpc	r19, r25
    ace8:	4a 07       	cpc	r20, r26
    acea:	5b 07       	cpc	r21, r27
    acec:	0c f0       	brlt	.+2      	; 0xacf0 <Buf2Field+0x2ae>
    acee:	b8 cf       	rjmp	.-144    	; 0xac60 <Buf2Field+0x21e>
    acf0:	c2 01       	movw	r24, r4
    acf2:	68 2d       	mov	r22, r8
    acf4:	0e 94 69 4d 	call	0x9ad2	; 0x9ad2 <ewb>
    acf8:	3a cf       	rjmp	.-396    	; 0xab6e <Buf2Field+0x12c>
		break;
	case Word: case z_Word:
		SetField(F_Buf, uint16_t);
    acfa:	20 91 f7 04 	lds	r18, 0x04F7
    acfe:	30 91 f8 04 	lds	r19, 0x04F8
    ad02:	40 91 f9 04 	lds	r20, 0x04F9
    ad06:	50 91 fa 04 	lds	r21, 0x04FA
    ad0a:	c7 01       	movw	r24, r14
    ad0c:	a0 e0       	ldi	r26, 0x00	; 0
    ad0e:	b0 e0       	ldi	r27, 0x00	; 0
    ad10:	82 17       	cp	r24, r18
    ad12:	93 07       	cpc	r25, r19
    ad14:	a4 07       	cpc	r26, r20
    ad16:	b5 07       	cpc	r27, r21
    ad18:	08 f4       	brcc	.+2      	; 0xad1c <Buf2Field+0x2da>
    ad1a:	cc c1       	rjmp	.+920    	; 0xb0b4 <Buf2Field+0x672>
    ad1c:	c4 01       	movw	r24, r8
    ad1e:	a0 e0       	ldi	r26, 0x00	; 0
    ad20:	b0 e0       	ldi	r27, 0x00	; 0
    ad22:	28 17       	cp	r18, r24
    ad24:	39 07       	cpc	r19, r25
    ad26:	4a 07       	cpc	r20, r26
    ad28:	5b 07       	cpc	r21, r27
    ad2a:	08 f0       	brcs	.+2      	; 0xad2e <Buf2Field+0x2ec>
    ad2c:	d8 c1       	rjmp	.+944    	; 0xb0de <Buf2Field+0x69c>
    ad2e:	f2 01       	movw	r30, r4
    ad30:	91 82       	std	Z+1, r9	; 0x01
    ad32:	80 82       	st	Z, r8
    ad34:	1c cf       	rjmp	.-456    	; 0xab6e <Buf2Field+0x12c>
		break;
	case EE_Word: case z_EE_Word:
		SetEEField(F_Buf, uint16_t, uint16_t, w);
    ad36:	20 91 f7 04 	lds	r18, 0x04F7
    ad3a:	30 91 f8 04 	lds	r19, 0x04F8
    ad3e:	40 91 f9 04 	lds	r20, 0x04F9
    ad42:	50 91 fa 04 	lds	r21, 0x04FA
    ad46:	c7 01       	movw	r24, r14
    ad48:	a0 e0       	ldi	r26, 0x00	; 0
    ad4a:	b0 e0       	ldi	r27, 0x00	; 0
    ad4c:	82 17       	cp	r24, r18
    ad4e:	93 07       	cpc	r25, r19
    ad50:	a4 07       	cpc	r26, r20
    ad52:	b5 07       	cpc	r27, r21
    ad54:	08 f4       	brcc	.+2      	; 0xad58 <Buf2Field+0x316>
    ad56:	b6 c1       	rjmp	.+876    	; 0xb0c4 <Buf2Field+0x682>
    ad58:	c4 01       	movw	r24, r8
    ad5a:	a0 e0       	ldi	r26, 0x00	; 0
    ad5c:	b0 e0       	ldi	r27, 0x00	; 0
    ad5e:	28 17       	cp	r18, r24
    ad60:	39 07       	cpc	r19, r25
    ad62:	4a 07       	cpc	r20, r26
    ad64:	5b 07       	cpc	r21, r27
    ad66:	08 f4       	brcc	.+2      	; 0xad6a <Buf2Field+0x328>
    ad68:	45 c0       	rjmp	.+138    	; 0xadf4 <Buf2Field+0x3b2>
		break;
	case s_Word:
		SetField(sF_Buf, int16_t);
		break;
	case s_EE_Word:
		SetEEField(sF_Buf, int16_t, uint16_t, w);
    ad6a:	c2 01       	movw	r24, r4
    ad6c:	b9 01       	movw	r22, r18
    ad6e:	0e 94 ac 4d 	call	0x9b58	; 0x9b58 <eww>
    ad72:	fd ce       	rjmp	.-518    	; 0xab6e <Buf2Field+0x12c>
		break;
	case EE_Word: case z_EE_Word:
		SetEEField(F_Buf, uint16_t, uint16_t, w);
		break;
	case s_Word:
		SetField(sF_Buf, int16_t);
    ad74:	20 91 fb 04 	lds	r18, 0x04FB
    ad78:	30 91 fc 04 	lds	r19, 0x04FC
    ad7c:	40 91 fd 04 	lds	r20, 0x04FD
    ad80:	50 91 fe 04 	lds	r21, 0x04FE
    ad84:	c7 01       	movw	r24, r14
    ad86:	aa 27       	eor	r26, r26
    ad88:	97 fd       	sbrc	r25, 7
    ad8a:	a0 95       	com	r26
    ad8c:	ba 2f       	mov	r27, r26
    ad8e:	82 17       	cp	r24, r18
    ad90:	93 07       	cpc	r25, r19
    ad92:	a4 07       	cpc	r26, r20
    ad94:	b5 07       	cpc	r27, r21
    ad96:	0c f4       	brge	.+2      	; 0xad9a <Buf2Field+0x358>
    ad98:	91 c1       	rjmp	.+802    	; 0xb0bc <Buf2Field+0x67a>
    ad9a:	c4 01       	movw	r24, r8
    ad9c:	aa 27       	eor	r26, r26
    ad9e:	97 fd       	sbrc	r25, 7
    ada0:	a0 95       	com	r26
    ada2:	ba 2f       	mov	r27, r26
    ada4:	28 17       	cp	r18, r24
    ada6:	39 07       	cpc	r19, r25
    ada8:	4a 07       	cpc	r20, r26
    adaa:	5b 07       	cpc	r21, r27
    adac:	0c f0       	brlt	.+2      	; 0xadb0 <Buf2Field+0x36e>
    adae:	9b c1       	rjmp	.+822    	; 0xb0e6 <Buf2Field+0x6a4>
    adb0:	d2 01       	movw	r26, r4
    adb2:	8d 92       	st	X+, r8
    adb4:	9c 92       	st	X, r9
    adb6:	db ce       	rjmp	.-586    	; 0xab6e <Buf2Field+0x12c>
		break;
	case s_EE_Word:
		SetEEField(sF_Buf, int16_t, uint16_t, w);
    adb8:	20 91 fb 04 	lds	r18, 0x04FB
    adbc:	30 91 fc 04 	lds	r19, 0x04FC
    adc0:	40 91 fd 04 	lds	r20, 0x04FD
    adc4:	50 91 fe 04 	lds	r21, 0x04FE
    adc8:	c7 01       	movw	r24, r14
    adca:	aa 27       	eor	r26, r26
    adcc:	97 fd       	sbrc	r25, 7
    adce:	a0 95       	com	r26
    add0:	ba 2f       	mov	r27, r26
    add2:	82 17       	cp	r24, r18
    add4:	93 07       	cpc	r25, r19
    add6:	a4 07       	cpc	r26, r20
    add8:	b5 07       	cpc	r27, r21
    adda:	0c f4       	brge	.+2      	; 0xadde <Buf2Field+0x39c>
    addc:	73 c1       	rjmp	.+742    	; 0xb0c4 <Buf2Field+0x682>
    adde:	c4 01       	movw	r24, r8
    ade0:	aa 27       	eor	r26, r26
    ade2:	97 fd       	sbrc	r25, 7
    ade4:	a0 95       	com	r26
    ade6:	ba 2f       	mov	r27, r26
    ade8:	28 17       	cp	r18, r24
    adea:	39 07       	cpc	r19, r25
    adec:	4a 07       	cpc	r20, r26
    adee:	5b 07       	cpc	r21, r27
    adf0:	0c f0       	brlt	.+2      	; 0xadf4 <Buf2Field+0x3b2>
    adf2:	bb cf       	rjmp	.-138    	; 0xad6a <Buf2Field+0x328>
    adf4:	c2 01       	movw	r24, r4
    adf6:	b4 01       	movw	r22, r8
    adf8:	0e 94 ac 4d 	call	0x9b58	; 0x9b58 <eww>
    adfc:	b8 ce       	rjmp	.-656    	; 0xab6e <Buf2Field+0x12c>
		break;
	case c_Word: case zc_Word:
		*(uint16_t*)Var = F_Buf;
    adfe:	80 91 f7 04 	lds	r24, 0x04F7
    ae02:	90 91 f8 04 	lds	r25, 0x04F8
    ae06:	d2 01       	movw	r26, r4
    ae08:	8d 93       	st	X+, r24
    ae0a:	9c 93       	st	X, r25
    ae0c:	b0 ce       	rjmp	.-672    	; 0xab6e <Buf2Field+0x12c>
		break;


	case Longint: case z_Longint:
		//if(Limit_uByteVar(Temp)) sscanf(BufStr,"%ud", (unsigned short int*)&Temp);
		PresicionHanler(Field);
    ae0e:	c6 01       	movw	r24, r12
    ae10:	0e 94 dd 41 	call	0x83ba	; 0x83ba <PresicionHanler>
		sscanf(BufStr,"%lud", (uint32_t*)&Temp);
    ae14:	00 d0       	rcall	.+0      	; 0xae16 <Buf2Field+0x3d4>
    ae16:	00 d0       	rcall	.+0      	; 0xae18 <Buf2Field+0x3d6>
    ae18:	ed b7       	in	r30, 0x3d	; 61
    ae1a:	fe b7       	in	r31, 0x3e	; 62
    ae1c:	31 96       	adiw	r30, 0x01	; 1
    ae1e:	83 ec       	ldi	r24, 0xC3	; 195
    ae20:	95 e0       	ldi	r25, 0x05	; 5
    ae22:	ad b7       	in	r26, 0x3d	; 61
    ae24:	be b7       	in	r27, 0x3e	; 62
    ae26:	12 96       	adiw	r26, 0x02	; 2
    ae28:	9c 93       	st	X, r25
    ae2a:	8e 93       	st	-X, r24
    ae2c:	11 97       	sbiw	r26, 0x01	; 1
    ae2e:	8f e9       	ldi	r24, 0x9F	; 159
    ae30:	92 e0       	ldi	r25, 0x02	; 2
    ae32:	93 83       	std	Z+3, r25	; 0x03
    ae34:	82 83       	std	Z+2, r24	; 0x02
    ae36:	ce 01       	movw	r24, r28
    ae38:	01 96       	adiw	r24, 0x01	; 1
    ae3a:	95 83       	std	Z+5, r25	; 0x05
    ae3c:	84 83       	std	Z+4, r24	; 0x04
    ae3e:	0e 94 4b 82 	call	0x10496	; 0x10496 <sscanf>
		SetField32(Temp, uint32_t);
    ae42:	89 81       	ldd	r24, Y+1	; 0x01
    ae44:	9a 81       	ldd	r25, Y+2	; 0x02
    ae46:	ab 81       	ldd	r26, Y+3	; 0x03
    ae48:	bc 81       	ldd	r27, Y+4	; 0x04
    ae4a:	ed b7       	in	r30, 0x3d	; 61
    ae4c:	fe b7       	in	r31, 0x3e	; 62
    ae4e:	36 96       	adiw	r30, 0x06	; 6
    ae50:	0f b6       	in	r0, 0x3f	; 63
    ae52:	f8 94       	cli
    ae54:	fe bf       	out	0x3e, r31	; 62
    ae56:	0f be       	out	0x3f, r0	; 63
    ae58:	ed bf       	out	0x3d, r30	; 61
    ae5a:	e8 16       	cp	r14, r24
    ae5c:	f9 06       	cpc	r15, r25
    ae5e:	0a 07       	cpc	r16, r26
    ae60:	1b 07       	cpc	r17, r27
    ae62:	08 f4       	brcc	.+2      	; 0xae66 <Buf2Field+0x424>
    ae64:	17 c1       	rjmp	.+558    	; 0xb094 <Buf2Field+0x652>
    ae66:	88 15       	cp	r24, r8
    ae68:	99 05       	cpc	r25, r9
    ae6a:	aa 05       	cpc	r26, r10
    ae6c:	bb 05       	cpc	r27, r11
    ae6e:	b8 f1       	brcs	.+110    	; 0xaede <Buf2Field+0x49c>
		break;
	case s_Longint:
		PresicionHanler(Field);
		//if(Limit_sByteVar(Temp)) sscanf(BufStr,"%hd", (short int*)&Temp);
		sscanf(BufStr,"%ld", (int32_t*)&Temp);
		SetField32(Temp, int32_t);
    ae70:	f2 01       	movw	r30, r4
    ae72:	80 83       	st	Z, r24
    ae74:	91 83       	std	Z+1, r25	; 0x01
    ae76:	a2 83       	std	Z+2, r26	; 0x02
    ae78:	b3 83       	std	Z+3, r27	; 0x03
    ae7a:	79 ce       	rjmp	.-782    	; 0xab6e <Buf2Field+0x12c>
		if(sscanf(BufStr,"%lud", (uint32_t*)&Temp) == 1){
			SetEEField32(Temp, uint32_t, uint32_t, d);
		}		
		break;
	case s_Longint:
		PresicionHanler(Field);
    ae7c:	c6 01       	movw	r24, r12
    ae7e:	0e 94 dd 41 	call	0x83ba	; 0x83ba <PresicionHanler>
		//if(Limit_sByteVar(Temp)) sscanf(BufStr,"%hd", (short int*)&Temp);
		sscanf(BufStr,"%ld", (int32_t*)&Temp);
    ae82:	00 d0       	rcall	.+0      	; 0xae84 <Buf2Field+0x442>
    ae84:	00 d0       	rcall	.+0      	; 0xae86 <Buf2Field+0x444>
    ae86:	ed b7       	in	r30, 0x3d	; 61
    ae88:	fe b7       	in	r31, 0x3e	; 62
    ae8a:	31 96       	adiw	r30, 0x01	; 1
    ae8c:	83 ec       	ldi	r24, 0xC3	; 195
    ae8e:	95 e0       	ldi	r25, 0x05	; 5
    ae90:	ad b7       	in	r26, 0x3d	; 61
    ae92:	be b7       	in	r27, 0x3e	; 62
    ae94:	12 96       	adiw	r26, 0x02	; 2
    ae96:	9c 93       	st	X, r25
    ae98:	8e 93       	st	-X, r24
    ae9a:	11 97       	sbiw	r26, 0x01	; 1
    ae9c:	84 ea       	ldi	r24, 0xA4	; 164
    ae9e:	92 e0       	ldi	r25, 0x02	; 2
    aea0:	93 83       	std	Z+3, r25	; 0x03
    aea2:	82 83       	std	Z+2, r24	; 0x02
    aea4:	ce 01       	movw	r24, r28
    aea6:	01 96       	adiw	r24, 0x01	; 1
    aea8:	95 83       	std	Z+5, r25	; 0x05
    aeaa:	84 83       	std	Z+4, r24	; 0x04
    aeac:	0e 94 4b 82 	call	0x10496	; 0x10496 <sscanf>
		SetField32(Temp, int32_t);
    aeb0:	89 81       	ldd	r24, Y+1	; 0x01
    aeb2:	9a 81       	ldd	r25, Y+2	; 0x02
    aeb4:	ab 81       	ldd	r26, Y+3	; 0x03
    aeb6:	bc 81       	ldd	r27, Y+4	; 0x04
    aeb8:	ed b7       	in	r30, 0x3d	; 61
    aeba:	fe b7       	in	r31, 0x3e	; 62
    aebc:	36 96       	adiw	r30, 0x06	; 6
    aebe:	0f b6       	in	r0, 0x3f	; 63
    aec0:	f8 94       	cli
    aec2:	fe bf       	out	0x3e, r31	; 62
    aec4:	0f be       	out	0x3f, r0	; 63
    aec6:	ed bf       	out	0x3d, r30	; 61
    aec8:	e8 16       	cp	r14, r24
    aeca:	f9 06       	cpc	r15, r25
    aecc:	0a 07       	cpc	r16, r26
    aece:	1b 07       	cpc	r17, r27
    aed0:	0c f4       	brge	.+2      	; 0xaed4 <Buf2Field+0x492>
    aed2:	e0 c0       	rjmp	.+448    	; 0xb094 <Buf2Field+0x652>
    aed4:	88 15       	cp	r24, r8
    aed6:	99 05       	cpc	r25, r9
    aed8:	aa 05       	cpc	r26, r10
    aeda:	bb 05       	cpc	r27, r11
    aedc:	4c f6       	brge	.-110    	; 0xae70 <Buf2Field+0x42e>
    aede:	f2 01       	movw	r30, r4
    aee0:	80 82       	st	Z, r8
    aee2:	91 82       	std	Z+1, r9	; 0x01
    aee4:	a2 82       	std	Z+2, r10	; 0x02
    aee6:	b3 82       	std	Z+3, r11	; 0x03
    aee8:	42 ce       	rjmp	.-892    	; 0xab6e <Buf2Field+0x12c>
		break;
	case s_EE_Longint:
		PresicionHanler(Field);
    aeea:	c6 01       	movw	r24, r12
    aeec:	0e 94 dd 41 	call	0x83ba	; 0x83ba <PresicionHanler>
		if(sscanf(BufStr,"%ld", (int32_t*)&Temp) == 1){
    aef0:	00 d0       	rcall	.+0      	; 0xaef2 <Buf2Field+0x4b0>
    aef2:	00 d0       	rcall	.+0      	; 0xaef4 <Buf2Field+0x4b2>
    aef4:	ed b7       	in	r30, 0x3d	; 61
    aef6:	fe b7       	in	r31, 0x3e	; 62
    aef8:	31 96       	adiw	r30, 0x01	; 1
    aefa:	83 ec       	ldi	r24, 0xC3	; 195
    aefc:	95 e0       	ldi	r25, 0x05	; 5
    aefe:	ad b7       	in	r26, 0x3d	; 61
    af00:	be b7       	in	r27, 0x3e	; 62
    af02:	12 96       	adiw	r26, 0x02	; 2
    af04:	9c 93       	st	X, r25
    af06:	8e 93       	st	-X, r24
    af08:	11 97       	sbiw	r26, 0x01	; 1
    af0a:	84 ea       	ldi	r24, 0xA4	; 164
    af0c:	92 e0       	ldi	r25, 0x02	; 2
    af0e:	93 83       	std	Z+3, r25	; 0x03
    af10:	82 83       	std	Z+2, r24	; 0x02
    af12:	ce 01       	movw	r24, r28
    af14:	01 96       	adiw	r24, 0x01	; 1
    af16:	95 83       	std	Z+5, r25	; 0x05
    af18:	84 83       	std	Z+4, r24	; 0x04
    af1a:	0e 94 4b 82 	call	0x10496	; 0x10496 <sscanf>
    af1e:	ed b7       	in	r30, 0x3d	; 61
    af20:	fe b7       	in	r31, 0x3e	; 62
    af22:	36 96       	adiw	r30, 0x06	; 6
    af24:	0f b6       	in	r0, 0x3f	; 63
    af26:	f8 94       	cli
    af28:	fe bf       	out	0x3e, r31	; 62
    af2a:	0f be       	out	0x3f, r0	; 63
    af2c:	ed bf       	out	0x3d, r30	; 61
    af2e:	01 97       	sbiw	r24, 0x01	; 1
    af30:	09 f0       	breq	.+2      	; 0xaf34 <Buf2Field+0x4f2>
    af32:	1d ce       	rjmp	.-966    	; 0xab6e <Buf2Field+0x12c>
			SetEEField32(Temp, int32_t, uint32_t, d);
    af34:	49 81       	ldd	r20, Y+1	; 0x01
    af36:	5a 81       	ldd	r21, Y+2	; 0x02
    af38:	6b 81       	ldd	r22, Y+3	; 0x03
    af3a:	7c 81       	ldd	r23, Y+4	; 0x04
    af3c:	ca 01       	movw	r24, r20
    af3e:	db 01       	movw	r26, r22
    af40:	e8 16       	cp	r14, r24
    af42:	f9 06       	cpc	r15, r25
    af44:	0a 07       	cpc	r16, r26
    af46:	1b 07       	cpc	r17, r27
    af48:	0c f4       	brge	.+2      	; 0xaf4c <Buf2Field+0x50a>
    af4a:	d4 c0       	rjmp	.+424    	; 0xb0f4 <Buf2Field+0x6b2>
    af4c:	88 15       	cp	r24, r8
    af4e:	99 05       	cpc	r25, r9
    af50:	aa 05       	cpc	r26, r10
    af52:	bb 05       	cpc	r27, r11
    af54:	0c f0       	brlt	.+2      	; 0xaf58 <Buf2Field+0x516>
    af56:	08 ce       	rjmp	.-1008   	; 0xab68 <Buf2Field+0x126>
    af58:	c2 01       	movw	r24, r4
    af5a:	b5 01       	movw	r22, r10
    af5c:	a4 01       	movw	r20, r8
    af5e:	0e 94 e3 4e 	call	0x9dc6	; 0x9dc6 <ewd>
    af62:	05 ce       	rjmp	.-1014   	; 0xab6e <Buf2Field+0x12c>
		}
		break;


	case FFloat: case GFloat:
		sscanf(BufStr,"%f", &fTemp);
    af64:	00 d0       	rcall	.+0      	; 0xaf66 <Buf2Field+0x524>
    af66:	00 d0       	rcall	.+0      	; 0xaf68 <Buf2Field+0x526>
    af68:	ed b7       	in	r30, 0x3d	; 61
    af6a:	fe b7       	in	r31, 0x3e	; 62
    af6c:	31 96       	adiw	r30, 0x01	; 1
    af6e:	83 ec       	ldi	r24, 0xC3	; 195
    af70:	95 e0       	ldi	r25, 0x05	; 5
    af72:	ad b7       	in	r26, 0x3d	; 61
    af74:	be b7       	in	r27, 0x3e	; 62
    af76:	12 96       	adiw	r26, 0x02	; 2
    af78:	9c 93       	st	X, r25
    af7a:	8e 93       	st	-X, r24
    af7c:	11 97       	sbiw	r26, 0x01	; 1
    af7e:	88 ea       	ldi	r24, 0xA8	; 168
    af80:	92 e0       	ldi	r25, 0x02	; 2
    af82:	93 83       	std	Z+3, r25	; 0x03
    af84:	82 83       	std	Z+2, r24	; 0x02
    af86:	ce 01       	movw	r24, r28
    af88:	05 96       	adiw	r24, 0x05	; 5
    af8a:	95 83       	std	Z+5, r25	; 0x05
    af8c:	84 83       	std	Z+4, r24	; 0x04
    af8e:	0e 94 4b 82 	call	0x10496	; 0x10496 <sscanf>
		*(float*)Var = fTemp;
    af92:	8d 81       	ldd	r24, Y+5	; 0x05
    af94:	9e 81       	ldd	r25, Y+6	; 0x06
    af96:	af 81       	ldd	r26, Y+7	; 0x07
    af98:	b8 85       	ldd	r27, Y+8	; 0x08
    af9a:	f2 01       	movw	r30, r4
    af9c:	80 83       	st	Z, r24
    af9e:	91 83       	std	Z+1, r25	; 0x01
    afa0:	a2 83       	std	Z+2, r26	; 0x02
    afa2:	b3 83       	std	Z+3, r27	; 0x03
    afa4:	2d b7       	in	r18, 0x3d	; 61
    afa6:	3e b7       	in	r19, 0x3e	; 62
    afa8:	2a 5f       	subi	r18, 0xFA	; 250
    afaa:	3f 4f       	sbci	r19, 0xFF	; 255
    afac:	0f b6       	in	r0, 0x3f	; 63
    afae:	f8 94       	cli
    afb0:	3e bf       	out	0x3e, r19	; 62
    afb2:	0f be       	out	0x3f, r0	; 63
    afb4:	2d bf       	out	0x3d, r18	; 61
    afb6:	db cd       	rjmp	.-1098   	; 0xab6e <Buf2Field+0x12c>
		break;
	case EE_FFloat: case EE_GFloat:
		if(sscanf(BufStr,"%f", &fTemp) == 1){
    afb8:	00 d0       	rcall	.+0      	; 0xafba <Buf2Field+0x578>
    afba:	00 d0       	rcall	.+0      	; 0xafbc <Buf2Field+0x57a>
    afbc:	ed b7       	in	r30, 0x3d	; 61
    afbe:	fe b7       	in	r31, 0x3e	; 62
    afc0:	31 96       	adiw	r30, 0x01	; 1
    afc2:	83 ec       	ldi	r24, 0xC3	; 195
    afc4:	95 e0       	ldi	r25, 0x05	; 5
    afc6:	ad b7       	in	r26, 0x3d	; 61
    afc8:	be b7       	in	r27, 0x3e	; 62
    afca:	12 96       	adiw	r26, 0x02	; 2
    afcc:	9c 93       	st	X, r25
    afce:	8e 93       	st	-X, r24
    afd0:	11 97       	sbiw	r26, 0x01	; 1
    afd2:	88 ea       	ldi	r24, 0xA8	; 168
    afd4:	92 e0       	ldi	r25, 0x02	; 2
    afd6:	93 83       	std	Z+3, r25	; 0x03
    afd8:	82 83       	std	Z+2, r24	; 0x02
    afda:	8e 01       	movw	r16, r28
    afdc:	0b 5f       	subi	r16, 0xFB	; 251
    afde:	1f 4f       	sbci	r17, 0xFF	; 255
    afe0:	15 83       	std	Z+5, r17	; 0x05
    afe2:	04 83       	std	Z+4, r16	; 0x04
    afe4:	0e 94 4b 82 	call	0x10496	; 0x10496 <sscanf>
    afe8:	ed b7       	in	r30, 0x3d	; 61
    afea:	fe b7       	in	r31, 0x3e	; 62
    afec:	36 96       	adiw	r30, 0x06	; 6
    afee:	0f b6       	in	r0, 0x3f	; 63
    aff0:	f8 94       	cli
    aff2:	fe bf       	out	0x3e, r31	; 62
    aff4:	0f be       	out	0x3f, r0	; 63
    aff6:	ed bf       	out	0x3d, r30	; 61
    aff8:	01 97       	sbiw	r24, 0x01	; 1
    affa:	09 f0       	breq	.+2      	; 0xaffe <Buf2Field+0x5bc>
    affc:	b8 cd       	rjmp	.-1168   	; 0xab6e <Buf2Field+0x12c>
			ewbl(&fTemp, (float*)Var, 4);
    affe:	c8 01       	movw	r24, r16
    b000:	b2 01       	movw	r22, r4
    b002:	44 e0       	ldi	r20, 0x04	; 4
    b004:	50 e0       	ldi	r21, 0x00	; 0
    b006:	0e 94 de 4e 	call	0x9dbc	; 0x9dbc <ewbl>
    b00a:	b1 cd       	rjmp	.-1182   	; 0xab6e <Buf2Field+0x12c>
		}
		break;


	case Bit:
		if(F_Buf)
    b00c:	80 91 f7 04 	lds	r24, 0x04F7
    b010:	90 91 f8 04 	lds	r25, 0x04F8
    b014:	a0 91 f9 04 	lds	r26, 0x04F9
    b018:	b0 91 fa 04 	lds	r27, 0x04FA
    b01c:	00 97       	sbiw	r24, 0x00	; 0
    b01e:	a1 05       	cpc	r26, r1
    b020:	b1 05       	cpc	r27, r1
    b022:	91 f1       	breq	.+100    	; 0xb088 <Buf2Field+0x646>
			*BitVar |=Mask;
    b024:	d3 01       	movw	r26, r6
    b026:	8c 91       	ld	r24, X
    b028:	83 29       	or	r24, r3
    b02a:	8c 93       	st	X, r24
    b02c:	a0 cd       	rjmp	.-1216   	; 0xab6e <Buf2Field+0x12c>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    b02e:	c3 01       	movw	r24, r6
    b030:	0e 94 17 84 	call	0x1082e	; 0x1082e <__eerd_byte_m2560>
    b034:	28 2f       	mov	r18, r24
		else
			*BitVar &=~Mask;
		break;
	case EE_Bit:
		EE_BitVar=erb(BitVar);
		ewb(BitVar, F_Buf ? EE_BitVar |Mask : EE_BitVar &~Mask);
    b036:	80 91 f7 04 	lds	r24, 0x04F7
    b03a:	90 91 f8 04 	lds	r25, 0x04F8
    b03e:	a0 91 f9 04 	lds	r26, 0x04F9
    b042:	b0 91 fa 04 	lds	r27, 0x04FA
    b046:	00 97       	sbiw	r24, 0x00	; 0
    b048:	a1 05       	cpc	r26, r1
    b04a:	b1 05       	cpc	r27, r1
    b04c:	d1 f4       	brne	.+52     	; 0xb082 <Buf2Field+0x640>
    b04e:	63 2d       	mov	r22, r3
    b050:	60 95       	com	r22
    b052:	62 23       	and	r22, r18
    b054:	c3 01       	movw	r24, r6
    b056:	0e 94 69 4d 	call	0x9ad2	; 0x9ad2 <ewb>
    b05a:	89 cd       	rjmp	.-1262   	; 0xab6e <Buf2Field+0x12c>
		break;


	case Text:{
		//    
		uint8_t Field_width = strlen((char*)Var);
    b05c:	f2 01       	movw	r30, r4
    b05e:	01 90       	ld	r0, Z+
    b060:	00 20       	and	r0, r0
    b062:	e9 f7       	brne	.-6      	; 0xb05e <Buf2Field+0x61c>
    b064:	31 97       	sbiw	r30, 0x01	; 1
    b066:	4e 2f       	mov	r20, r30
    b068:	44 19       	sub	r20, r4
		if(Field_width > LCDXSz) Field_width = LCDXSz+1;
    b06a:	45 31       	cpi	r20, 0x15	; 21
    b06c:	e8 f0       	brcs	.+58     	; 0xb0a8 <Buf2Field+0x666>
    b06e:	e5 e1       	ldi	r30, 0x15	; 21
    b070:	f0 e0       	ldi	r31, 0x00	; 0
		memcpy(Var,BufStr,Field_width);
    b072:	23 ec       	ldi	r18, 0xC3	; 195
    b074:	35 e0       	ldi	r19, 0x05	; 5
    b076:	c2 01       	movw	r24, r4
    b078:	b9 01       	movw	r22, r18
    b07a:	af 01       	movw	r20, r30
    b07c:	0e 94 39 81 	call	0x10272	; 0x10272 <memcpy>
    b080:	76 cd       	rjmp	.-1300   	; 0xab6e <Buf2Field+0x12c>
		else
			*BitVar &=~Mask;
		break;
	case EE_Bit:
		EE_BitVar=erb(BitVar);
		ewb(BitVar, F_Buf ? EE_BitVar |Mask : EE_BitVar &~Mask);
    b082:	63 2d       	mov	r22, r3
    b084:	62 2b       	or	r22, r18
    b086:	e6 cf       	rjmp	.-52     	; 0xb054 <Buf2Field+0x612>

	case Bit:
		if(F_Buf)
			*BitVar |=Mask;
		else
			*BitVar &=~Mask;
    b088:	30 94       	com	r3
    b08a:	f3 01       	movw	r30, r6
    b08c:	80 81       	ld	r24, Z
    b08e:	83 21       	and	r24, r3
    b090:	80 83       	st	Z, r24
    b092:	6d cd       	rjmp	.-1318   	; 0xab6e <Buf2Field+0x12c>
		break;
	case s_Longint:
		PresicionHanler(Field);
		//if(Limit_sByteVar(Temp)) sscanf(BufStr,"%hd", (short int*)&Temp);
		sscanf(BufStr,"%ld", (int32_t*)&Temp);
		SetField32(Temp, int32_t);
    b094:	d2 01       	movw	r26, r4
    b096:	ed 92       	st	X+, r14
    b098:	fd 92       	st	X+, r15
    b09a:	0d 93       	st	X+, r16
    b09c:	1c 93       	st	X, r17
    b09e:	13 97       	sbiw	r26, 0x03	; 3
    b0a0:	66 cd       	rjmp	.-1332   	; 0xab6e <Buf2Field+0x12c>
	switch(prb(&Field->Type)) {
	case Byte: case z_Byte: case Enum:
		SetField(F_Buf, uint8_t);
		break;
	case s_Byte:
		SetField(sF_Buf, int8_t);
    b0a2:	f2 01       	movw	r30, r4
    b0a4:	e0 82       	st	Z, r14
    b0a6:	63 cd       	rjmp	.-1338   	; 0xab6e <Buf2Field+0x12c>


	case Text:{
		//    
		uint8_t Field_width = strlen((char*)Var);
		if(Field_width > LCDXSz) Field_width = LCDXSz+1;
    b0a8:	e4 2f       	mov	r30, r20
    b0aa:	f0 e0       	ldi	r31, 0x00	; 0
    b0ac:	e2 cf       	rjmp	.-60     	; 0xb072 <Buf2Field+0x630>
	uint32_t Temp=0;
	float fTemp=0;

	switch(prb(&Field->Type)) {
	case Byte: case z_Byte: case Enum:
		SetField(F_Buf, uint8_t);
    b0ae:	d2 01       	movw	r26, r4
    b0b0:	ec 92       	st	X, r14
    b0b2:	5d cd       	rjmp	.-1350   	; 0xab6e <Buf2Field+0x12c>
		break;
	case s_EE_Byte:
		SetEEField(sF_Buf, int8_t, uint8_t, b);
		break;
	case Word: case z_Word:
		SetField(F_Buf, uint16_t);
    b0b4:	d2 01       	movw	r26, r4
    b0b6:	ed 92       	st	X+, r14
    b0b8:	fc 92       	st	X, r15
    b0ba:	59 cd       	rjmp	.-1358   	; 0xab6e <Buf2Field+0x12c>
		break;
	case EE_Word: case z_EE_Word:
		SetEEField(F_Buf, uint16_t, uint16_t, w);
		break;
	case s_Word:
		SetField(sF_Buf, int16_t);
    b0bc:	f2 01       	movw	r30, r4
    b0be:	f1 82       	std	Z+1, r15	; 0x01
    b0c0:	e0 82       	st	Z, r14
    b0c2:	55 cd       	rjmp	.-1366   	; 0xab6e <Buf2Field+0x12c>
		break;
	case s_EE_Word:
		SetEEField(sF_Buf, int16_t, uint16_t, w);
    b0c4:	c2 01       	movw	r24, r4
    b0c6:	b7 01       	movw	r22, r14
    b0c8:	0e 94 ac 4d 	call	0x9b58	; 0x9b58 <eww>
    b0cc:	50 cd       	rjmp	.-1376   	; 0xab6e <Buf2Field+0x12c>
		break;
	case EE_Byte: case z_EE_Byte: case EE_Enum:
		SetEEField(F_Buf, uint8_t, uint8_t, b);
		break;
	case s_EE_Byte:
		SetEEField(sF_Buf, int8_t, uint8_t, b);
    b0ce:	c2 01       	movw	r24, r4
    b0d0:	6e 2d       	mov	r22, r14
    b0d2:	0e 94 69 4d 	call	0x9ad2	; 0x9ad2 <ewb>
    b0d6:	4b cd       	rjmp	.-1386   	; 0xab6e <Buf2Field+0x12c>
	switch(prb(&Field->Type)) {
	case Byte: case z_Byte: case Enum:
		SetField(F_Buf, uint8_t);
		break;
	case s_Byte:
		SetField(sF_Buf, int8_t);
    b0d8:	f2 01       	movw	r30, r4
    b0da:	20 83       	st	Z, r18
    b0dc:	48 cd       	rjmp	.-1392   	; 0xab6e <Buf2Field+0x12c>
		break;
	case s_EE_Byte:
		SetEEField(sF_Buf, int8_t, uint8_t, b);
		break;
	case Word: case z_Word:
		SetField(F_Buf, uint16_t);
    b0de:	d2 01       	movw	r26, r4
    b0e0:	2d 93       	st	X+, r18
    b0e2:	3c 93       	st	X, r19
    b0e4:	44 cd       	rjmp	.-1400   	; 0xab6e <Buf2Field+0x12c>
		break;
	case EE_Word: case z_EE_Word:
		SetEEField(F_Buf, uint16_t, uint16_t, w);
		break;
	case s_Word:
		SetField(sF_Buf, int16_t);
    b0e6:	f2 01       	movw	r30, r4
    b0e8:	31 83       	std	Z+1, r19	; 0x01
    b0ea:	20 83       	st	Z, r18
    b0ec:	40 cd       	rjmp	.-1408   	; 0xab6e <Buf2Field+0x12c>
	uint32_t Temp=0;
	float fTemp=0;

	switch(prb(&Field->Type)) {
	case Byte: case z_Byte: case Enum:
		SetField(F_Buf, uint8_t);
    b0ee:	d2 01       	movw	r26, r4
    b0f0:	2c 93       	st	X, r18
    b0f2:	3d cd       	rjmp	.-1414   	; 0xab6e <Buf2Field+0x12c>
		SetField32(Temp, int32_t);
		break;
	case s_EE_Longint:
		PresicionHanler(Field);
		if(sscanf(BufStr,"%ld", (int32_t*)&Temp) == 1){
			SetEEField32(Temp, int32_t, uint32_t, d);
    b0f4:	c2 01       	movw	r24, r4
    b0f6:	b8 01       	movw	r22, r16
    b0f8:	a7 01       	movw	r20, r14
    b0fa:	0e 94 e3 4e 	call	0x9dc6	; 0x9dc6 <ewd>
    b0fe:	37 cd       	rjmp	.-1426   	; 0xab6e <Buf2Field+0x12c>

0000b100 <MenuEnterRight>:
}

// ~~~~~~~~~~~~~~~~~
void
MenuEnterRight(void)
{
    b100:	ef 92       	push	r14
    b102:	ff 92       	push	r15
    b104:	0f 93       	push	r16
    b106:	1f 93       	push	r17
    b108:	cf 93       	push	r28
    b10a:	df 93       	push	r29
//	1) Hide current Message
	if(HideMsg()||KeyFunc(&CurrPage->Enter))
    b10c:	0e 94 a6 3d 	call	0x7b4c	; 0x7b4c <HideMsg>
    b110:	88 23       	and	r24, r24
    b112:	39 f0       	breq	.+14     	; 0xb122 <MenuEnterRight+0x22>
	if(NextPage || (NextPage=prp(&Line->InnPage))) {
		GotoMenu(NextPage);
		NextPage=NULL;
		return;
	}
}
    b114:	df 91       	pop	r29
    b116:	cf 91       	pop	r28
    b118:	1f 91       	pop	r17
    b11a:	0f 91       	pop	r16
    b11c:	ff 90       	pop	r15
    b11e:	ef 90       	pop	r14
    b120:	08 95       	ret
// ~~~~~~~~~~~~~~~~~
void
MenuEnterRight(void)
{
//	1) Hide current Message
	if(HideMsg()||KeyFunc(&CurrPage->Enter))
    b122:	80 91 d4 02 	lds	r24, 0x02D4
    b126:	90 91 d5 02 	lds	r25, 0x02D5
    b12a:	0c 96       	adiw	r24, 0x0c	; 12
    b12c:	0e 94 4c 3d 	call	0x7a98	; 0x7a98 <KeyFunc>
    b130:	88 23       	and	r24, r24
    b132:	81 f7       	brne	.-32     	; 0xb114 <MenuEnterRight+0x14>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    b134:	40 91 d4 02 	lds	r20, 0x02D4
    b138:	50 91 d5 02 	lds	r21, 0x02D5
    b13c:	fa 01       	movw	r30, r20
    b13e:	c5 91       	lpm	r28, Z+
    b140:	d4 91       	lpm	r29, Z+
		return;

	MenuLine *Line=GetLine+CurrLine;
    b142:	90 91 c9 07 	lds	r25, 0x07C9
    b146:	8b e1       	ldi	r24, 0x1B	; 27
    b148:	98 9f       	mul	r25, r24
    b14a:	b0 01       	movw	r22, r0
    b14c:	11 24       	eor	r1, r1
    b14e:	c6 0f       	add	r28, r22
    b150:	d7 1f       	adc	r29, r23
    b152:	fe 01       	movw	r30, r28
    b154:	77 96       	adiw	r30, 0x17	; 23
    b156:	e5 90       	lpm	r14, Z+
    b158:	f4 90       	lpm	r15, Z+
	OutField *Field=prp(&Line->OF_List);

// 2) Variable
	if(Field){
    b15a:	e1 14       	cp	r14, r1
    b15c:	f1 04       	cpc	r15, r1
    b15e:	09 f4       	brne	.+2      	; 0xb162 <MenuEnterRight+0x62>
    b160:	93 c0       	rjmp	.+294    	; 0xb288 <MenuEnterRight+0x188>
    b162:	30 e0       	ldi	r19, 0x00	; 0
    b164:	10 e0       	ldi	r17, 0x00	; 0
    b166:	80 e0       	ldi	r24, 0x00	; 0
    b168:	90 e0       	ldi	r25, 0x00	; 0
    b16a:	05 c0       	rjmp	.+10     	; 0xb176 <MenuEnterRight+0x76>
		uint8_t i=0;
		while(i<LCDXSz) {
			Char1 = Char2;
			Char2 = prc(CurrStr+i++);
			if (Char2=='}' && Char1!='}')
				FieldNumber++;
    b16c:	01 96       	adiw	r24, 0x01	; 1
	// Define variable quantity 
		uint8_t FieldNumber = 0;
		PGM_P CurrStr=(PGM_P)(Line->Str);
		char Char1, Char2=0;
		uint8_t i=0;
		while(i<LCDXSz) {
    b16e:	84 31       	cpi	r24, 0x14	; 20
    b170:	91 05       	cpc	r25, r1
    b172:	71 f0       	breq	.+28     	; 0xb190 <MenuEnterRight+0x90>
    b174:	32 2f       	mov	r19, r18

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    b176:	fe 01       	movw	r30, r28
    b178:	e8 0f       	add	r30, r24
    b17a:	f9 1f       	adc	r31, r25
    b17c:	24 91       	lpm	r18, Z+
			Char1 = Char2;
			Char2 = prc(CurrStr+i++);
			if (Char2=='}' && Char1!='}')
    b17e:	2d 37       	cpi	r18, 0x7D	; 125
    b180:	a9 f7       	brne	.-22     	; 0xb16c <MenuEnterRight+0x6c>
    b182:	3d 37       	cpi	r19, 0x7D	; 125
    b184:	99 f3       	breq	.-26     	; 0xb16c <MenuEnterRight+0x6c>
				FieldNumber++;
    b186:	1f 5f       	subi	r17, 0xFF	; 255
    b188:	01 96       	adiw	r24, 0x01	; 1
	// Define variable quantity 
		uint8_t FieldNumber = 0;
		PGM_P CurrStr=(PGM_P)(Line->Str);
		char Char1, Char2=0;
		uint8_t i=0;
		while(i<LCDXSz) {
    b18a:	84 31       	cpi	r24, 0x14	; 20
    b18c:	91 05       	cpc	r25, r1
    b18e:	91 f7       	brne	.-28     	; 0xb174 <MenuEnterRight+0x74>
			Char2 = prc(CurrStr+i++);
			if (Char2=='}' && Char1!='}')
				FieldNumber++;
		}
		//    Bit (:)   
		if(FieldNumber==1 && prb(&Field->Type)==Bit) {
    b190:	11 30       	cpi	r17, 0x01	; 1
    b192:	09 f4       	brne	.+2      	; 0xb196 <MenuEnterRight+0x96>
    b194:	b8 c0       	rjmp	.+368    	; 0xb306 <MenuEnterRight+0x206>
			EventFunc(&Field->Act);
			return;
		}

	//    
		if(CurrPos!=NullPos && --CurrPos!=NullPos){
    b196:	80 91 d7 02 	lds	r24, 0x02D7
    b19a:	8f 3f       	cpi	r24, 0xFF	; 255
    b19c:	09 f4       	brne	.+2      	; 0xb1a0 <MenuEnterRight+0xa0>
    b19e:	4a c0       	rjmp	.+148    	; 0xb234 <MenuEnterRight+0x134>
    b1a0:	08 2f       	mov	r16, r24
    b1a2:	01 50       	subi	r16, 0x01	; 1
    b1a4:	00 93 d7 02 	sts	0x02D7, r16
    b1a8:	0f 3f       	cpi	r16, 0xFF	; 255
    b1aa:	09 f4       	brne	.+2      	; 0xb1ae <MenuEnterRight+0xae>
    b1ac:	43 c0       	rjmp	.+134    	; 0xb234 <MenuEnterRight+0x134>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    b1ae:	fa 01       	movw	r30, r20
    b1b0:	45 91       	lpm	r20, Z+
    b1b2:	54 91       	lpm	r21, Z+
			OutField *Field1=GetField;
    b1b4:	46 0f       	add	r20, r22
    b1b6:	57 1f       	adc	r21, r23
    b1b8:	49 5e       	subi	r20, 0xE9	; 233
    b1ba:	5f 4f       	sbci	r21, 0xFF	; 255
    b1bc:	fa 01       	movw	r30, r20
    b1be:	25 91       	lpm	r18, Z+
    b1c0:	34 91       	lpm	r19, Z+
    b1c2:	80 91 d6 02 	lds	r24, 0x02D6
    b1c6:	90 e0       	ldi	r25, 0x00	; 0
    b1c8:	82 95       	swap	r24
    b1ca:	92 95       	swap	r25
    b1cc:	90 7f       	andi	r25, 0xF0	; 240
    b1ce:	98 27       	eor	r25, r24
    b1d0:	80 7f       	andi	r24, 0xF0	; 240
    b1d2:	98 27       	eor	r25, r24
    b1d4:	28 0f       	add	r18, r24
    b1d6:	39 1f       	adc	r19, r25

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    b1d8:	f9 01       	movw	r30, r18
    b1da:	84 91       	lpm	r24, Z+
			switch(prb(&Field1->Type)){
    b1dc:	8d 31       	cpi	r24, 0x1D	; 29
    b1de:	08 f4       	brcc	.+2      	; 0xb1e2 <MenuEnterRight+0xe2>
    b1e0:	67 c0       	rjmp	.+206    	; 0xb2b0 <MenuEnterRight+0x1b0>
    b1e2:	81 52       	subi	r24, 0x21	; 33
    b1e4:	82 30       	cpi	r24, 0x02	; 2
    b1e6:	08 f0       	brcs	.+2      	; 0xb1ea <MenuEnterRight+0xea>
    b1e8:	95 cf       	rjmp	.-214    	; 0xb114 <MenuEnterRight+0x14>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    b1ea:	f9 01       	movw	r30, r18
    b1ec:	33 96       	adiw	r30, 0x03	; 3
    b1ee:	85 91       	lpm	r24, Z+
    b1f0:	95 91       	lpm	r25, Z+
    b1f2:	a5 91       	lpm	r26, Z+
    b1f4:	b4 91       	lpm	r27, Z+
			case Text: case EE_Text:
				if( (prd(&Field1->Min) == DIGIT) && (prd(&Field1->Max) == DIGIT) )
    b1f6:	00 97       	sbiw	r24, 0x00	; 0
    b1f8:	a1 05       	cpc	r26, r1
    b1fa:	b1 05       	cpc	r27, r1
    b1fc:	59 f4       	brne	.+22     	; 0xb214 <MenuEnterRight+0x114>
    b1fe:	f9 01       	movw	r30, r18
    b200:	37 96       	adiw	r30, 0x07	; 7
    b202:	85 91       	lpm	r24, Z+
    b204:	95 91       	lpm	r25, Z+
    b206:	a5 91       	lpm	r26, Z+
    b208:	b4 91       	lpm	r27, Z+
    b20a:	00 97       	sbiw	r24, 0x00	; 0
    b20c:	a1 05       	cpc	r26, r1
    b20e:	b1 05       	cpc	r27, r1
    b210:	09 f4       	brne	.+2      	; 0xb214 <MenuEnterRight+0x114>
    b212:	a3 c0       	rjmp	.+326    	; 0xb35a <MenuEnterRight+0x25a>
					MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[CurrFieldSize - 1 - CurrPos]);
				else MultiSymbol = GetMultiSymbol(Symbols_P, BufStr[CurrFieldSize - 1 - CurrPos]);
    b214:	e0 91 c0 07 	lds	r30, 0x07C0
    b218:	f0 e0       	ldi	r31, 0x00	; 0
    b21a:	31 97       	sbiw	r30, 0x01	; 1
    b21c:	e0 1b       	sub	r30, r16
    b21e:	f1 09       	sbc	r31, r1
    b220:	ed 53       	subi	r30, 0x3D	; 61
    b222:	fa 4f       	sbci	r31, 0xFA	; 250
    b224:	85 e0       	ldi	r24, 0x05	; 5
    b226:	96 e0       	ldi	r25, 0x06	; 6
    b228:	60 81       	ld	r22, Z
    b22a:	0e 94 17 42 	call	0x842e	; 0x842e <GetMultiSymbol>
    b22e:	80 93 f4 04 	sts	0x04F4, r24
    b232:	70 cf       	rjmp	.-288    	; 0xb114 <MenuEnterRight+0x14>
				break;		
			}
			return;
		}

		if(CurrField!=NullPos) {
    b234:	80 91 d6 02 	lds	r24, 0x02D6
    b238:	8f 3f       	cpi	r24, 0xFF	; 255
    b23a:	81 f0       	breq	.+32     	; 0xb25c <MenuEnterRight+0x15c>
			Buf2Field(Field+CurrField);
    b23c:	90 e0       	ldi	r25, 0x00	; 0
    b23e:	82 95       	swap	r24
    b240:	92 95       	swap	r25
    b242:	90 7f       	andi	r25, 0xF0	; 240
    b244:	98 27       	eor	r25, r24
    b246:	80 7f       	andi	r24, 0xF0	; 240
    b248:	98 27       	eor	r25, r24
    b24a:	8e 0d       	add	r24, r14
    b24c:	9f 1d       	adc	r25, r15
    b24e:	0e 94 21 55 	call	0xaa42	; 0xaa42 <Buf2Field>
			if(CurrField==NullPos)
    b252:	80 91 d6 02 	lds	r24, 0x02D6
    b256:	8f 3f       	cpi	r24, 0xFF	; 255
    b258:	09 f4       	brne	.+2      	; 0xb25c <MenuEnterRight+0x15c>
    b25a:	5c cf       	rjmp	.-328    	; 0xb114 <MenuEnterRight+0x14>
				return;
		}
		//     
		if(++CurrField==FieldNumber)
    b25c:	8f 5f       	subi	r24, 0xFF	; 255
    b25e:	80 93 d6 02 	sts	0x02D6, r24
    b262:	18 17       	cp	r17, r24
    b264:	d9 f1       	breq	.+118    	; 0xb2dc <MenuEnterRight+0x1dc>
			CurrField=NullPos;
		else
			Field2Buf(Field+CurrField);
    b266:	90 e0       	ldi	r25, 0x00	; 0
    b268:	82 95       	swap	r24
    b26a:	92 95       	swap	r25
    b26c:	90 7f       	andi	r25, 0xF0	; 240
    b26e:	98 27       	eor	r25, r24
    b270:	80 7f       	andi	r24, 0xF0	; 240
    b272:	98 27       	eor	r25, r24
    b274:	8e 0d       	add	r24, r14
    b276:	9f 1d       	adc	r25, r15
    b278:	0e 94 69 51 	call	0xa2d2	; 0xa2d2 <Field2Buf>
    b27c:	40 91 d4 02 	lds	r20, 0x02D4
    b280:	50 91 d5 02 	lds	r21, 0x02D5
    b284:	90 91 c9 07 	lds	r25, 0x07C9

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    b288:	4e 5f       	subi	r20, 0xFE	; 254
    b28a:	5f 4f       	sbci	r21, 0xFF	; 255
    b28c:	fa 01       	movw	r30, r20
    b28e:	84 91       	lpm	r24, Z+
	}

// 3) Go to menu
	if( CurrLine >= prb(&CurrPage->LineNumber) )
    b290:	98 17       	cp	r25, r24
    b292:	08 f0       	brcs	.+2      	; 0xb296 <MenuEnterRight+0x196>
    b294:	3f cf       	rjmp	.-386    	; 0xb114 <MenuEnterRight+0x14>
		return;

	if(NextPage || (NextPage=prp(&Line->InnPage))) {
    b296:	80 91 d9 05 	lds	r24, 0x05D9
    b29a:	90 91 da 05 	lds	r25, 0x05DA
    b29e:	00 97       	sbiw	r24, 0x00	; 0
    b2a0:	39 f1       	breq	.+78     	; 0xb2f0 <MenuEnterRight+0x1f0>
		GotoMenu(NextPage);
    b2a2:	0e 94 5e 3d 	call	0x7abc	; 0x7abc <GotoMenu>
		NextPage=NULL;
    b2a6:	10 92 da 05 	sts	0x05DA, r1
    b2aa:	10 92 d9 05 	sts	0x05D9, r1
    b2ae:	32 cf       	rjmp	.-412    	; 0xb114 <MenuEnterRight+0x14>
		}

	//    
		if(CurrPos!=NullPos && --CurrPos!=NullPos){
			OutField *Field1=GetField;
			switch(prb(&Field1->Type)){
    b2b0:	89 31       	cpi	r24, 0x19	; 25
    b2b2:	20 f4       	brcc	.+8      	; 0xb2bc <MenuEnterRight+0x1bc>
    b2b4:	80 51       	subi	r24, 0x10	; 16
    b2b6:	86 30       	cpi	r24, 0x06	; 6
    b2b8:	08 f0       	brcs	.+2      	; 0xb2bc <MenuEnterRight+0x1bc>
    b2ba:	2c cf       	rjmp	.-424    	; 0xb114 <MenuEnterRight+0x14>
					MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[CurrFieldSize - 1 - CurrPos]);
				else MultiSymbol = GetMultiSymbol(Symbols_P, BufStr[CurrFieldSize - 1 - CurrPos]);
				break;
			case Longint: case z_Longint: case EE_Longint: case z_EE_Longint: case s_Longint: case s_EE_Longint:
			case FFloat: case EE_FFloat: case GFloat: case EE_GFloat:
				MultiSymbol = GetMultiSymbol(Digits_P, BufStr[CurrFieldSize - 1 - CurrPos]);
    b2bc:	e0 91 c0 07 	lds	r30, 0x07C0
    b2c0:	f0 e0       	ldi	r31, 0x00	; 0
    b2c2:	31 97       	sbiw	r30, 0x01	; 1
    b2c4:	e0 1b       	sub	r30, r16
    b2c6:	f1 09       	sbc	r31, r1
    b2c8:	ed 53       	subi	r30, 0x3D	; 61
    b2ca:	fa 4f       	sbci	r31, 0xFA	; 250
    b2cc:	8e ea       	ldi	r24, 0xAE	; 174
    b2ce:	96 e0       	ldi	r25, 0x06	; 6
    b2d0:	60 81       	ld	r22, Z
    b2d2:	0e 94 17 42 	call	0x842e	; 0x842e <GetMultiSymbol>
    b2d6:	80 93 f4 04 	sts	0x04F4, r24
    b2da:	1c cf       	rjmp	.-456    	; 0xb114 <MenuEnterRight+0x14>
			if(CurrField==NullPos)
				return;
		}
		//     
		if(++CurrField==FieldNumber)
			CurrField=NullPos;
    b2dc:	8f ef       	ldi	r24, 0xFF	; 255
    b2de:	80 93 d6 02 	sts	0x02D6, r24
    b2e2:	40 91 d4 02 	lds	r20, 0x02D4
    b2e6:	50 91 d5 02 	lds	r21, 0x02D5
    b2ea:	90 91 c9 07 	lds	r25, 0x07C9
    b2ee:	cc cf       	rjmp	.-104    	; 0xb288 <MenuEnterRight+0x188>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    b2f0:	fe 01       	movw	r30, r28
    b2f2:	79 96       	adiw	r30, 0x19	; 25
    b2f4:	85 91       	lpm	r24, Z+
    b2f6:	94 91       	lpm	r25, Z+

// 3) Go to menu
	if( CurrLine >= prb(&CurrPage->LineNumber) )
		return;

	if(NextPage || (NextPage=prp(&Line->InnPage))) {
    b2f8:	90 93 da 05 	sts	0x05DA, r25
    b2fc:	80 93 d9 05 	sts	0x05D9, r24
    b300:	00 97       	sbiw	r24, 0x00	; 0
    b302:	79 f6       	brne	.-98     	; 0xb2a2 <MenuEnterRight+0x1a2>
    b304:	07 cf       	rjmp	.-498    	; 0xb114 <MenuEnterRight+0x14>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    b306:	f7 01       	movw	r30, r14
    b308:	84 91       	lpm	r24, Z+
			Char2 = prc(CurrStr+i++);
			if (Char2=='}' && Char1!='}')
				FieldNumber++;
		}
		//    Bit (:)   
		if(FieldNumber==1 && prb(&Field->Type)==Bit) {
    b30a:	8f 31       	cpi	r24, 0x1F	; 31
    b30c:	09 f0       	breq	.+2      	; 0xb310 <MenuEnterRight+0x210>
    b30e:	43 cf       	rjmp	.-378    	; 0xb196 <MenuEnterRight+0x96>
    b310:	8f e0       	ldi	r24, 0x0F	; 15
    b312:	90 e0       	ldi	r25, 0x00	; 0
    b314:	e8 0e       	add	r14, r24
    b316:	f9 1e       	adc	r15, r25
    b318:	f7 01       	movw	r30, r14
    b31a:	24 91       	lpm	r18, Z+
    b31c:	81 ef       	ldi	r24, 0xF1	; 241
    b31e:	9f ef       	ldi	r25, 0xFF	; 255
    b320:	e8 0e       	add	r14, r24
    b322:	f9 1e       	adc	r15, r25

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    b324:	c7 01       	movw	r24, r14
    b326:	01 96       	adiw	r24, 0x01	; 1
    b328:	fc 01       	movw	r30, r24
    b32a:	a5 91       	lpm	r26, Z+
    b32c:	b4 91       	lpm	r27, Z+
			uint8_t BitN=prb(&Field->Prec);
			*((uint8_t*)prp(&Field->Var)+BitN/8) ^=(1<<BitN%8);
    b32e:	82 2f       	mov	r24, r18
    b330:	86 95       	lsr	r24
    b332:	86 95       	lsr	r24
    b334:	86 95       	lsr	r24
    b336:	a8 0f       	add	r26, r24
    b338:	b1 1d       	adc	r27, r1
    b33a:	27 70       	andi	r18, 0x07	; 7
    b33c:	81 e0       	ldi	r24, 0x01	; 1
    b33e:	90 e0       	ldi	r25, 0x00	; 0
    b340:	02 c0       	rjmp	.+4      	; 0xb346 <MenuEnterRight+0x246>
    b342:	88 0f       	add	r24, r24
    b344:	99 1f       	adc	r25, r25
    b346:	2a 95       	dec	r18
    b348:	e2 f7       	brpl	.-8      	; 0xb342 <MenuEnterRight+0x242>
    b34a:	2c 91       	ld	r18, X
    b34c:	28 27       	eor	r18, r24
    b34e:	2c 93       	st	X, r18
			EventFunc(&Field->Act);
    b350:	c7 01       	movw	r24, r14
    b352:	0b 96       	adiw	r24, 0x0b	; 11
    b354:	0e 94 44 3d 	call	0x7a88	; 0x7a88 <EventFunc>
    b358:	dd ce       	rjmp	.-582    	; 0xb114 <MenuEnterRight+0x14>
		if(CurrPos!=NullPos && --CurrPos!=NullPos){
			OutField *Field1=GetField;
			switch(prb(&Field1->Type)){
			case Text: case EE_Text:
				if( (prd(&Field1->Min) == DIGIT) && (prd(&Field1->Max) == DIGIT) )
					MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[CurrFieldSize - 1 - CurrPos]);
    b35a:	e0 91 c0 07 	lds	r30, 0x07C0
    b35e:	f0 e0       	ldi	r31, 0x00	; 0
    b360:	31 97       	sbiw	r30, 0x01	; 1
    b362:	e0 1b       	sub	r30, r16
    b364:	f1 09       	sbc	r31, r1
    b366:	ed 53       	subi	r30, 0x3D	; 61
    b368:	fa 4f       	sbci	r31, 0xFA	; 250
    b36a:	83 ea       	ldi	r24, 0xA3	; 163
    b36c:	96 e0       	ldi	r25, 0x06	; 6
    b36e:	60 81       	ld	r22, Z
    b370:	0e 94 17 42 	call	0x842e	; 0x842e <GetMultiSymbol>
    b374:	80 93 f4 04 	sts	0x04F4, r24
    b378:	cd ce       	rjmp	.-614    	; 0xb114 <MenuEnterRight+0x14>

0000b37a <MenuUD>:
	return Pos*Dir;
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
MenuUD(const MenuKey *Key, int8_t Dir, uint8_t LimLine, uint8_t LimLCD, uint8_t LimVar)
{
    b37a:	af 92       	push	r10
    b37c:	bf 92       	push	r11
    b37e:	cf 92       	push	r12
    b380:	df 92       	push	r13
    b382:	ef 92       	push	r14
    b384:	ff 92       	push	r15
    b386:	0f 93       	push	r16
    b388:	1f 93       	push	r17
    b38a:	cf 93       	push	r28
    b38c:	df 93       	push	r29
    b38e:	fc 01       	movw	r30, r24
    b390:	e6 2e       	mov	r14, r22
    b392:	14 2f       	mov	r17, r20
    b394:	f2 2e       	mov	r15, r18
	if(CurrMsg || KeyFunc(Key))
    b396:	80 91 f5 04 	lds	r24, 0x04F5
    b39a:	90 91 f6 04 	lds	r25, 0x04F6
    b39e:	89 2b       	or	r24, r25
    b3a0:	59 f0       	breq	.+22     	; 0xb3b8 <MenuUD+0x3e>
		else 		{if(--MultiSymbol == 255) MultiSymbol = strlen_P(Digits_P)-1;}
		if(CurrPos!=NullPos)
			BufStr[CurrFieldSize - 1 - CurrPos] = prc(Digits_P + MultiSymbol);
		break;
	}
}
    b3a2:	df 91       	pop	r29
    b3a4:	cf 91       	pop	r28
    b3a6:	1f 91       	pop	r17
    b3a8:	0f 91       	pop	r16
    b3aa:	ff 90       	pop	r15
    b3ac:	ef 90       	pop	r14
    b3ae:	df 90       	pop	r13
    b3b0:	cf 90       	pop	r12
    b3b2:	bf 90       	pop	r11
    b3b4:	af 90       	pop	r10
    b3b6:	08 95       	ret
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
MenuUD(const MenuKey *Key, int8_t Dir, uint8_t LimLine, uint8_t LimLCD, uint8_t LimVar)
{
	if(CurrMsg || KeyFunc(Key))
    b3b8:	cf 01       	movw	r24, r30
    b3ba:	0e 94 4c 3d 	call	0x7a98	; 0x7a98 <KeyFunc>
    b3be:	88 23       	and	r24, r24
    b3c0:	81 f7       	brne	.-32     	; 0xb3a2 <MenuUD+0x28>
		return;
	if(CurrField==NullPos) {
    b3c2:	30 91 d6 02 	lds	r19, 0x02D6
    b3c6:	3f 3f       	cpi	r19, 0xFF	; 255
    b3c8:	09 f4       	brne	.+2      	; 0xb3cc <MenuUD+0x52>
    b3ca:	48 c1       	rjmp	.+656    	; 0xb65c <MenuUD+0x2e2>
			if(LimLCD)
				CurrLCD -= Dir;
		}
		return;
	}
	Blink=0;
    b3cc:	10 92 17 09 	sts	0x0917, r1
    b3d0:	80 91 d4 02 	lds	r24, 0x02D4
    b3d4:	90 91 d5 02 	lds	r25, 0x02D5
    b3d8:	fc 01       	movw	r30, r24
    b3da:	45 91       	lpm	r20, Z+
    b3dc:	54 91       	lpm	r21, Z+
	OutField *Field=GetField;
    b3de:	80 91 c9 07 	lds	r24, 0x07C9
    b3e2:	2b e1       	ldi	r18, 0x1B	; 27
    b3e4:	82 9f       	mul	r24, r18
    b3e6:	c0 01       	movw	r24, r0
    b3e8:	11 24       	eor	r1, r1
    b3ea:	48 0f       	add	r20, r24
    b3ec:	59 1f       	adc	r21, r25
    b3ee:	49 5e       	subi	r20, 0xE9	; 233
    b3f0:	5f 4f       	sbci	r21, 0xFF	; 255
    b3f2:	fa 01       	movw	r30, r20
    b3f4:	c5 91       	lpm	r28, Z+
    b3f6:	d4 91       	lpm	r29, Z+
    b3f8:	83 2f       	mov	r24, r19
    b3fa:	90 e0       	ldi	r25, 0x00	; 0
    b3fc:	82 95       	swap	r24
    b3fe:	92 95       	swap	r25
    b400:	90 7f       	andi	r25, 0xF0	; 240
    b402:	98 27       	eor	r25, r24
    b404:	80 7f       	andi	r24, 0xF0	; 240
    b406:	98 27       	eor	r25, r24
    b408:	c8 0f       	add	r28, r24
    b40a:	d9 1f       	adc	r29, r25

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    b40c:	fe 01       	movw	r30, r28
    b40e:	84 91       	lpm	r24, Z+
	switch(prb(&Field->Type)) {
    b410:	e8 2f       	mov	r30, r24
    b412:	f0 e0       	ldi	r31, 0x00	; 0
    b414:	e3 32       	cpi	r30, 0x23	; 35
    b416:	f1 05       	cpc	r31, r1
    b418:	08 f0       	brcs	.+2      	; 0xb41c <MenuUD+0xa2>
    b41a:	c3 cf       	rjmp	.-122    	; 0xb3a2 <MenuUD+0x28>
    b41c:	ea 54       	subi	r30, 0x4A	; 74
    b41e:	ff 4f       	sbci	r31, 0xFF	; 255
    b420:	ee 0f       	add	r30, r30
    b422:	ff 1f       	adc	r31, r31
    b424:	05 90       	lpm	r0, Z+
    b426:	f4 91       	lpm	r31, Z+
    b428:	e0 2d       	mov	r30, r0
    b42a:	19 94       	eijmp

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    b42c:	fe 01       	movw	r30, r28
    b42e:	33 96       	adiw	r30, 0x03	; 3
    b430:	85 91       	lpm	r24, Z+
    b432:	95 91       	lpm	r25, Z+
    b434:	a5 91       	lpm	r26, Z+
    b436:	b4 91       	lpm	r27, Z+
		break;
	case Bit: case EE_Bit:
		F_Buf = !F_Buf;
		break;
	case Text: case EE_Text:
		if( (prd(&Field->Min) == DIGIT) && (prd(&Field->Max) == DIGIT) ){
    b438:	00 97       	sbiw	r24, 0x00	; 0
    b43a:	a1 05       	cpc	r26, r1
    b43c:	b1 05       	cpc	r27, r1
    b43e:	09 f0       	breq	.+2      	; 0xb442 <MenuUD+0xc8>
    b440:	1e c1       	rjmp	.+572    	; 0xb67e <MenuUD+0x304>
    b442:	fe 01       	movw	r30, r28
    b444:	37 96       	adiw	r30, 0x07	; 7
    b446:	85 91       	lpm	r24, Z+
    b448:	95 91       	lpm	r25, Z+
    b44a:	a5 91       	lpm	r26, Z+
    b44c:	b4 91       	lpm	r27, Z+
    b44e:	00 97       	sbiw	r24, 0x00	; 0
    b450:	a1 05       	cpc	r26, r1
    b452:	b1 05       	cpc	r27, r1
    b454:	09 f0       	breq	.+2      	; 0xb458 <MenuUD+0xde>
    b456:	13 c1       	rjmp	.+550    	; 0xb67e <MenuUD+0x304>
			if(Dir==1){	if(++MultiSymbol > 9) MultiSymbol = 0;}
    b458:	31 e0       	ldi	r19, 0x01	; 1
    b45a:	e3 16       	cp	r14, r19
    b45c:	09 f4       	brne	.+2      	; 0xb460 <MenuUD+0xe6>
    b45e:	92 c1       	rjmp	.+804    	; 0xb784 <MenuUD+0x40a>
			else{		if(--MultiSymbol == 255) MultiSymbol = 9;}
    b460:	80 91 f4 04 	lds	r24, 0x04F4
    b464:	81 50       	subi	r24, 0x01	; 1
    b466:	80 93 f4 04 	sts	0x04F4, r24
    b46a:	8f 3f       	cpi	r24, 0xFF	; 255
    b46c:	09 f4       	brne	.+2      	; 0xb470 <MenuUD+0xf6>
    b46e:	93 c1       	rjmp	.+806    	; 0xb796 <MenuUD+0x41c>
		}
		else{
			if(Dir==1){	if(++MultiSymbol >= strlen_P(Symbols_P)) MultiSymbol = 0;}
			else{		if(--MultiSymbol == 255) MultiSymbol = strlen_P(Symbols_P)-1;}
		}
		if(CurrPos!=NullPos)
    b470:	90 91 d7 02 	lds	r25, 0x02D7
    b474:	9f 3f       	cpi	r25, 0xFF	; 255
    b476:	09 f4       	brne	.+2      	; 0xb47a <MenuUD+0x100>
    b478:	94 cf       	rjmp	.-216    	; 0xb3a2 <MenuUD+0x28>

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    b47a:	80 91 f4 04 	lds	r24, 0x04F4
    b47e:	e8 2f       	mov	r30, r24
    b480:	f0 e0       	ldi	r31, 0x00	; 0
    b482:	eb 5f       	subi	r30, 0xFB	; 251
    b484:	f9 4f       	sbci	r31, 0xF9	; 249
	case Longint: case z_Longint: case EE_Longint: case z_EE_Longint: case s_Longint: case s_EE_Longint:
	case FFloat: case EE_FFloat: case GFloat: case EE_GFloat:
		if(Dir==1)	{if(++MultiSymbol >= strlen_P(Digits_P)) MultiSymbol = 0;}
		else 		{if(--MultiSymbol == 255) MultiSymbol = strlen_P(Digits_P)-1;}
		if(CurrPos!=NullPos)
			BufStr[CurrFieldSize - 1 - CurrPos] = prc(Digits_P + MultiSymbol);
    b486:	84 91       	lpm	r24, Z+
    b488:	e0 91 c0 07 	lds	r30, 0x07C0
    b48c:	f0 e0       	ldi	r31, 0x00	; 0
    b48e:	31 97       	sbiw	r30, 0x01	; 1
    b490:	e9 1b       	sub	r30, r25
    b492:	f1 09       	sbc	r31, r1
    b494:	ed 53       	subi	r30, 0x3D	; 61
    b496:	fa 4f       	sbci	r31, 0xFA	; 250
    b498:	80 83       	st	Z, r24
    b49a:	83 cf       	rjmp	.-250    	; 0xb3a2 <MenuUD+0x28>
	case Enum: case EE_Enum:
		if(LimVar)
			F_Buf += Dir;
		break;
	case Bit: case EE_Bit:
		F_Buf = !F_Buf;
    b49c:	20 e0       	ldi	r18, 0x00	; 0
    b49e:	30 e0       	ldi	r19, 0x00	; 0
    b4a0:	40 e0       	ldi	r20, 0x00	; 0
    b4a2:	50 e0       	ldi	r21, 0x00	; 0
    b4a4:	80 91 f7 04 	lds	r24, 0x04F7
    b4a8:	90 91 f8 04 	lds	r25, 0x04F8
    b4ac:	a0 91 f9 04 	lds	r26, 0x04F9
    b4b0:	b0 91 fa 04 	lds	r27, 0x04FA
    b4b4:	00 97       	sbiw	r24, 0x00	; 0
    b4b6:	a1 05       	cpc	r26, r1
    b4b8:	b1 05       	cpc	r27, r1
    b4ba:	21 f4       	brne	.+8      	; 0xb4c4 <MenuUD+0x14a>
    b4bc:	21 e0       	ldi	r18, 0x01	; 1
    b4be:	30 e0       	ldi	r19, 0x00	; 0
    b4c0:	40 e0       	ldi	r20, 0x00	; 0
    b4c2:	50 e0       	ldi	r21, 0x00	; 0
    b4c4:	20 93 f7 04 	sts	0x04F7, r18
    b4c8:	30 93 f8 04 	sts	0x04F8, r19
    b4cc:	40 93 f9 04 	sts	0x04F9, r20
    b4d0:	50 93 fa 04 	sts	0x04FA, r21
    b4d4:	66 cf       	rjmp	.-308    	; 0xb3a2 <MenuUD+0x28>
			Buf2Field(Field);
			Field2Buf(Field);
		}
		break;
	case Enum: case EE_Enum:
		if(LimVar)
    b4d6:	00 23       	and	r16, r16
    b4d8:	09 f4       	brne	.+2      	; 0xb4dc <MenuUD+0x162>
    b4da:	63 cf       	rjmp	.-314    	; 0xb3a2 <MenuUD+0x28>
			F_Buf += Dir;
    b4dc:	2e 2d       	mov	r18, r14
    b4de:	33 27       	eor	r19, r19
    b4e0:	27 fd       	sbrc	r18, 7
    b4e2:	30 95       	com	r19
    b4e4:	43 2f       	mov	r20, r19
    b4e6:	53 2f       	mov	r21, r19
    b4e8:	80 91 f7 04 	lds	r24, 0x04F7
    b4ec:	90 91 f8 04 	lds	r25, 0x04F8
    b4f0:	a0 91 f9 04 	lds	r26, 0x04F9
    b4f4:	b0 91 fa 04 	lds	r27, 0x04FA
    b4f8:	82 0f       	add	r24, r18
    b4fa:	93 1f       	adc	r25, r19
    b4fc:	a4 1f       	adc	r26, r20
    b4fe:	b5 1f       	adc	r27, r21
    b500:	80 93 f7 04 	sts	0x04F7, r24
    b504:	90 93 f8 04 	sts	0x04F8, r25
    b508:	a0 93 f9 04 	sts	0x04F9, r26
    b50c:	b0 93 fa 04 	sts	0x04FA, r27
    b510:	48 cf       	rjmp	.-368    	; 0xb3a2 <MenuUD+0x28>
		if(CurrPos!=NullPos)
			BufStr[CurrFieldSize - 1 - CurrPos] = prc(Symbols_P + MultiSymbol);
		break;
	case Longint: case z_Longint: case EE_Longint: case z_EE_Longint: case s_Longint: case s_EE_Longint:
	case FFloat: case EE_FFloat: case GFloat: case EE_GFloat:
		if(Dir==1)	{if(++MultiSymbol >= strlen_P(Digits_P)) MultiSymbol = 0;}
    b512:	51 e0       	ldi	r21, 0x01	; 1
    b514:	e5 16       	cp	r14, r21
    b516:	09 f4       	brne	.+2      	; 0xb51a <MenuUD+0x1a0>
    b518:	fb c0       	rjmp	.+502    	; 0xb710 <MenuUD+0x396>
		else 		{if(--MultiSymbol == 255) MultiSymbol = strlen_P(Digits_P)-1;}
    b51a:	80 91 f4 04 	lds	r24, 0x04F4
    b51e:	81 50       	subi	r24, 0x01	; 1
    b520:	80 93 f4 04 	sts	0x04F4, r24
    b524:	8f 3f       	cpi	r24, 0xFF	; 255
    b526:	09 f4       	brne	.+2      	; 0xb52a <MenuUD+0x1b0>
    b528:	14 c1       	rjmp	.+552    	; 0xb752 <MenuUD+0x3d8>
		if(CurrPos!=NullPos)
    b52a:	90 91 d7 02 	lds	r25, 0x02D7
    b52e:	9f 3f       	cpi	r25, 0xFF	; 255
    b530:	09 f4       	brne	.+2      	; 0xb534 <MenuUD+0x1ba>
    b532:	37 cf       	rjmp	.-402    	; 0xb3a2 <MenuUD+0x28>
    b534:	80 91 f4 04 	lds	r24, 0x04F4
    b538:	e8 2f       	mov	r30, r24
    b53a:	f0 e0       	ldi	r31, 0x00	; 0
    b53c:	e2 55       	subi	r30, 0x52	; 82
    b53e:	f9 4f       	sbci	r31, 0xF9	; 249
    b540:	a2 cf       	rjmp	.-188    	; 0xb486 <MenuUD+0x10c>
			sF_Buf += Inc(Dir, sF_Buf);
		else if(sF_Buf<0 || sF_Buf==0 && Minus)
			Minus = (sF_Buf-=Inc(Dir, -sF_Buf))==0;
		break;
	case c_Word: case zc_Word:
		if(LimVar) {
    b542:	00 23       	and	r16, r16
    b544:	09 f4       	brne	.+2      	; 0xb548 <MenuUD+0x1ce>
    b546:	2d cf       	rjmp	.-422    	; 0xb3a2 <MenuUD+0x28>
			F_Buf += Dir;
    b548:	2e 2d       	mov	r18, r14
    b54a:	33 27       	eor	r19, r19
    b54c:	27 fd       	sbrc	r18, 7
    b54e:	30 95       	com	r19
    b550:	43 2f       	mov	r20, r19
    b552:	53 2f       	mov	r21, r19
    b554:	80 91 f7 04 	lds	r24, 0x04F7
    b558:	90 91 f8 04 	lds	r25, 0x04F8
    b55c:	a0 91 f9 04 	lds	r26, 0x04F9
    b560:	b0 91 fa 04 	lds	r27, 0x04FA
    b564:	82 0f       	add	r24, r18
    b566:	93 1f       	adc	r25, r19
    b568:	a4 1f       	adc	r26, r20
    b56a:	b5 1f       	adc	r27, r21
    b56c:	80 93 f7 04 	sts	0x04F7, r24
    b570:	90 93 f8 04 	sts	0x04F8, r25
    b574:	a0 93 f9 04 	sts	0x04F9, r26
    b578:	b0 93 fa 04 	sts	0x04FA, r27
			Buf2Field(Field);
    b57c:	ce 01       	movw	r24, r28
    b57e:	0e 94 21 55 	call	0xaa42	; 0xaa42 <Buf2Field>
			Field2Buf(Field);
    b582:	ce 01       	movw	r24, r28
    b584:	0e 94 69 51 	call	0xa2d2	; 0xa2d2 <Field2Buf>
    b588:	0c cf       	rjmp	.-488    	; 0xb3a2 <MenuUD+0x28>
	case Word: case EE_Word: case z_Word: case z_EE_Word:
		F_Buf += Inc(Dir, F_Buf);
		break;
	case s_Byte: case s_EE_Byte:
	case s_Word: case s_EE_Word:
		if(CurrPos==Log10(prd(&Field->Max))+1) {
    b58a:	00 91 d7 02 	lds	r16, 0x02D7
    b58e:	10 e0       	ldi	r17, 0x00	; 0

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    b590:	fe 01       	movw	r30, r28
    b592:	37 96       	adiw	r30, 0x07	; 7
    b594:	65 91       	lpm	r22, Z+
    b596:	75 91       	lpm	r23, Z+
    b598:	85 91       	lpm	r24, Z+
    b59a:	94 91       	lpm	r25, Z+
    b59c:	0e 94 ca 21 	call	0x4394	; 0x4394 <Log10>
    b5a0:	90 e0       	ldi	r25, 0x00	; 0
    b5a2:	01 96       	adiw	r24, 0x01	; 1
    b5a4:	08 17       	cp	r16, r24
    b5a6:	19 07       	cpc	r17, r25
    b5a8:	09 f4       	brne	.+2      	; 0xb5ac <MenuUD+0x232>
    b5aa:	9c c0       	rjmp	.+312    	; 0xb6e4 <MenuUD+0x36a>
			if(sF_Buf==0)
				Minus = !Minus;
			else
				sF_Buf = -sF_Buf;
		}
		else if(sF_Buf>0 || sF_Buf==0 && !Minus)
    b5ac:	a0 90 fb 04 	lds	r10, 0x04FB
    b5b0:	b0 90 fc 04 	lds	r11, 0x04FC
    b5b4:	c0 90 fd 04 	lds	r12, 0x04FD
    b5b8:	d0 90 fe 04 	lds	r13, 0x04FE
    b5bc:	1a 14       	cp	r1, r10
    b5be:	1b 04       	cpc	r1, r11
    b5c0:	1c 04       	cpc	r1, r12
    b5c2:	1d 04       	cpc	r1, r13
    b5c4:	0c f4       	brge	.+2      	; 0xb5c8 <MenuUD+0x24e>
    b5c6:	74 c0       	rjmp	.+232    	; 0xb6b0 <MenuUD+0x336>
    b5c8:	a1 14       	cp	r10, r1
    b5ca:	b1 04       	cpc	r11, r1
    b5cc:	c1 04       	cpc	r12, r1
    b5ce:	d1 04       	cpc	r13, r1
    b5d0:	09 f4       	brne	.+2      	; 0xb5d4 <MenuUD+0x25a>
    b5d2:	69 c0       	rjmp	.+210    	; 0xb6a6 <MenuUD+0x32c>
			sF_Buf += Inc(Dir, sF_Buf);
		else if(sF_Buf<0 || sF_Buf==0 && Minus)
			Minus = (sF_Buf-=Inc(Dir, -sF_Buf))==0;
    b5d4:	44 27       	eor	r20, r20
    b5d6:	55 27       	eor	r21, r21
    b5d8:	ba 01       	movw	r22, r20
    b5da:	4a 19       	sub	r20, r10
    b5dc:	5b 09       	sbc	r21, r11
    b5de:	6c 09       	sbc	r22, r12
    b5e0:	7d 09       	sbc	r23, r13
    b5e2:	8e 2d       	mov	r24, r14
    b5e4:	0e 94 23 3e 	call	0x7c46	; 0x7c46 <Inc>
    b5e8:	a6 01       	movw	r20, r12
    b5ea:	95 01       	movw	r18, r10
    b5ec:	26 1b       	sub	r18, r22
    b5ee:	37 0b       	sbc	r19, r23
    b5f0:	48 0b       	sbc	r20, r24
    b5f2:	59 0b       	sbc	r21, r25
    b5f4:	20 93 fb 04 	sts	0x04FB, r18
    b5f8:	30 93 fc 04 	sts	0x04FC, r19
    b5fc:	40 93 fd 04 	sts	0x04FD, r20
    b600:	50 93 fe 04 	sts	0x04FE, r21
    b604:	10 92 ff 04 	sts	0x04FF, r1
    b608:	21 15       	cp	r18, r1
    b60a:	31 05       	cpc	r19, r1
    b60c:	41 05       	cpc	r20, r1
    b60e:	51 05       	cpc	r21, r1
    b610:	09 f0       	breq	.+2      	; 0xb614 <MenuUD+0x29a>
    b612:	c7 ce       	rjmp	.-626    	; 0xb3a2 <MenuUD+0x28>
    b614:	81 e0       	ldi	r24, 0x01	; 1
    b616:	80 93 ff 04 	sts	0x04FF, r24
    b61a:	c3 ce       	rjmp	.-634    	; 0xb3a2 <MenuUD+0x28>
	Blink=0;
	OutField *Field=GetField;
	switch(prb(&Field->Type)) {
	case Byte: case EE_Byte: case z_Byte: case z_EE_Byte:
	case Word: case EE_Word: case z_Word: case z_EE_Word:
		F_Buf += Inc(Dir, F_Buf);
    b61c:	40 91 f7 04 	lds	r20, 0x04F7
    b620:	50 91 f8 04 	lds	r21, 0x04F8
    b624:	60 91 f9 04 	lds	r22, 0x04F9
    b628:	70 91 fa 04 	lds	r23, 0x04FA
    b62c:	8e 2d       	mov	r24, r14
    b62e:	0e 94 23 3e 	call	0x7c46	; 0x7c46 <Inc>
    b632:	20 91 f7 04 	lds	r18, 0x04F7
    b636:	30 91 f8 04 	lds	r19, 0x04F8
    b63a:	40 91 f9 04 	lds	r20, 0x04F9
    b63e:	50 91 fa 04 	lds	r21, 0x04FA
    b642:	26 0f       	add	r18, r22
    b644:	37 1f       	adc	r19, r23
    b646:	48 1f       	adc	r20, r24
    b648:	59 1f       	adc	r21, r25
    b64a:	20 93 f7 04 	sts	0x04F7, r18
    b64e:	30 93 f8 04 	sts	0x04F8, r19
    b652:	40 93 f9 04 	sts	0x04F9, r20
    b656:	50 93 fa 04 	sts	0x04FA, r21
    b65a:	a3 ce       	rjmp	.-698    	; 0xb3a2 <MenuUD+0x28>
MenuUD(const MenuKey *Key, int8_t Dir, uint8_t LimLine, uint8_t LimLCD, uint8_t LimVar)
{
	if(CurrMsg || KeyFunc(Key))
		return;
	if(CurrField==NullPos) {
		if(LimLine) {
    b65c:	11 23       	and	r17, r17
    b65e:	09 f4       	brne	.+2      	; 0xb662 <MenuUD+0x2e8>
    b660:	a0 ce       	rjmp	.-704    	; 0xb3a2 <MenuUD+0x28>
			CurrLine -= Dir;
    b662:	80 91 c9 07 	lds	r24, 0x07C9
    b666:	8e 19       	sub	r24, r14
    b668:	80 93 c9 07 	sts	0x07C9, r24
			if(LimLCD)
    b66c:	ff 20       	and	r15, r15
    b66e:	09 f4       	brne	.+2      	; 0xb672 <MenuUD+0x2f8>
    b670:	98 ce       	rjmp	.-720    	; 0xb3a2 <MenuUD+0x28>
				CurrLCD -= Dir;
    b672:	80 91 e7 08 	lds	r24, 0x08E7
    b676:	8e 19       	sub	r24, r14
    b678:	80 93 e7 08 	sts	0x08E7, r24
    b67c:	92 ce       	rjmp	.-732    	; 0xb3a2 <MenuUD+0x28>
		if( (prd(&Field->Min) == DIGIT) && (prd(&Field->Max) == DIGIT) ){
			if(Dir==1){	if(++MultiSymbol > 9) MultiSymbol = 0;}
			else{		if(--MultiSymbol == 255) MultiSymbol = 9;}
		}
		else{
			if(Dir==1){	if(++MultiSymbol >= strlen_P(Symbols_P)) MultiSymbol = 0;}
    b67e:	41 e0       	ldi	r20, 0x01	; 1
    b680:	e4 16       	cp	r14, r20
    b682:	09 f4       	brne	.+2      	; 0xb686 <MenuUD+0x30c>
    b684:	6e c0       	rjmp	.+220    	; 0xb762 <MenuUD+0x3e8>
			else{		if(--MultiSymbol == 255) MultiSymbol = strlen_P(Symbols_P)-1;}
    b686:	80 91 f4 04 	lds	r24, 0x04F4
    b68a:	81 50       	subi	r24, 0x01	; 1
    b68c:	80 93 f4 04 	sts	0x04F4, r24
    b690:	8f 3f       	cpi	r24, 0xFF	; 255
    b692:	09 f0       	breq	.+2      	; 0xb696 <MenuUD+0x31c>
    b694:	ed ce       	rjmp	.-550    	; 0xb470 <MenuUD+0xf6>
    b696:	85 e0       	ldi	r24, 0x05	; 5
    b698:	96 e0       	ldi	r25, 0x06	; 6
    b69a:	0e 94 fd 80 	call	0x101fa	; 0x101fa <strlen_P>
    b69e:	81 50       	subi	r24, 0x01	; 1
    b6a0:	80 93 f4 04 	sts	0x04F4, r24
    b6a4:	e5 ce       	rjmp	.-566    	; 0xb470 <MenuUD+0xf6>
			if(sF_Buf==0)
				Minus = !Minus;
			else
				sF_Buf = -sF_Buf;
		}
		else if(sF_Buf>0 || sF_Buf==0 && !Minus)
    b6a6:	80 91 ff 04 	lds	r24, 0x04FF
    b6aa:	88 23       	and	r24, r24
    b6ac:	09 f0       	breq	.+2      	; 0xb6b0 <MenuUD+0x336>
    b6ae:	92 cf       	rjmp	.-220    	; 0xb5d4 <MenuUD+0x25a>
			sF_Buf += Inc(Dir, sF_Buf);
    b6b0:	8e 2d       	mov	r24, r14
    b6b2:	b6 01       	movw	r22, r12
    b6b4:	a5 01       	movw	r20, r10
    b6b6:	0e 94 23 3e 	call	0x7c46	; 0x7c46 <Inc>
    b6ba:	20 91 fb 04 	lds	r18, 0x04FB
    b6be:	30 91 fc 04 	lds	r19, 0x04FC
    b6c2:	40 91 fd 04 	lds	r20, 0x04FD
    b6c6:	50 91 fe 04 	lds	r21, 0x04FE
    b6ca:	26 0f       	add	r18, r22
    b6cc:	37 1f       	adc	r19, r23
    b6ce:	48 1f       	adc	r20, r24
    b6d0:	59 1f       	adc	r21, r25
    b6d2:	20 93 fb 04 	sts	0x04FB, r18
    b6d6:	30 93 fc 04 	sts	0x04FC, r19
    b6da:	40 93 fd 04 	sts	0x04FD, r20
    b6de:	50 93 fe 04 	sts	0x04FE, r21
    b6e2:	5f ce       	rjmp	.-834    	; 0xb3a2 <MenuUD+0x28>
		F_Buf += Inc(Dir, F_Buf);
		break;
	case s_Byte: case s_EE_Byte:
	case s_Word: case s_EE_Word:
		if(CurrPos==Log10(prd(&Field->Max))+1) {
			if(sF_Buf==0)
    b6e4:	20 91 fb 04 	lds	r18, 0x04FB
    b6e8:	30 91 fc 04 	lds	r19, 0x04FC
    b6ec:	40 91 fd 04 	lds	r20, 0x04FD
    b6f0:	50 91 fe 04 	lds	r21, 0x04FE
    b6f4:	21 15       	cp	r18, r1
    b6f6:	31 05       	cpc	r19, r1
    b6f8:	41 05       	cpc	r20, r1
    b6fa:	51 05       	cpc	r21, r1
    b6fc:	d1 f4       	brne	.+52     	; 0xb732 <MenuUD+0x3b8>
				Minus = !Minus;
    b6fe:	90 e0       	ldi	r25, 0x00	; 0
    b700:	80 91 ff 04 	lds	r24, 0x04FF
    b704:	88 23       	and	r24, r24
    b706:	09 f4       	brne	.+2      	; 0xb70a <MenuUD+0x390>
    b708:	91 e0       	ldi	r25, 0x01	; 1
    b70a:	90 93 ff 04 	sts	0x04FF, r25
    b70e:	49 ce       	rjmp	.-878    	; 0xb3a2 <MenuUD+0x28>
		if(CurrPos!=NullPos)
			BufStr[CurrFieldSize - 1 - CurrPos] = prc(Symbols_P + MultiSymbol);
		break;
	case Longint: case z_Longint: case EE_Longint: case z_EE_Longint: case s_Longint: case s_EE_Longint:
	case FFloat: case EE_FFloat: case GFloat: case EE_GFloat:
		if(Dir==1)	{if(++MultiSymbol >= strlen_P(Digits_P)) MultiSymbol = 0;}
    b710:	00 91 f4 04 	lds	r16, 0x04F4
    b714:	0f 5f       	subi	r16, 0xFF	; 255
    b716:	00 93 f4 04 	sts	0x04F4, r16
    b71a:	8e ea       	ldi	r24, 0xAE	; 174
    b71c:	96 e0       	ldi	r25, 0x06	; 6
    b71e:	0e 94 fd 80 	call	0x101fa	; 0x101fa <strlen_P>
    b722:	10 e0       	ldi	r17, 0x00	; 0
    b724:	08 17       	cp	r16, r24
    b726:	19 07       	cpc	r17, r25
    b728:	08 f4       	brcc	.+2      	; 0xb72c <MenuUD+0x3b2>
    b72a:	ff ce       	rjmp	.-514    	; 0xb52a <MenuUD+0x1b0>
    b72c:	10 92 f4 04 	sts	0x04F4, r1
    b730:	fc ce       	rjmp	.-520    	; 0xb52a <MenuUD+0x1b0>
	case s_Word: case s_EE_Word:
		if(CurrPos==Log10(prd(&Field->Max))+1) {
			if(sF_Buf==0)
				Minus = !Minus;
			else
				sF_Buf = -sF_Buf;
    b732:	88 27       	eor	r24, r24
    b734:	99 27       	eor	r25, r25
    b736:	dc 01       	movw	r26, r24
    b738:	82 1b       	sub	r24, r18
    b73a:	93 0b       	sbc	r25, r19
    b73c:	a4 0b       	sbc	r26, r20
    b73e:	b5 0b       	sbc	r27, r21
    b740:	80 93 fb 04 	sts	0x04FB, r24
    b744:	90 93 fc 04 	sts	0x04FC, r25
    b748:	a0 93 fd 04 	sts	0x04FD, r26
    b74c:	b0 93 fe 04 	sts	0x04FE, r27
    b750:	28 ce       	rjmp	.-944    	; 0xb3a2 <MenuUD+0x28>
			BufStr[CurrFieldSize - 1 - CurrPos] = prc(Symbols_P + MultiSymbol);
		break;
	case Longint: case z_Longint: case EE_Longint: case z_EE_Longint: case s_Longint: case s_EE_Longint:
	case FFloat: case EE_FFloat: case GFloat: case EE_GFloat:
		if(Dir==1)	{if(++MultiSymbol >= strlen_P(Digits_P)) MultiSymbol = 0;}
		else 		{if(--MultiSymbol == 255) MultiSymbol = strlen_P(Digits_P)-1;}
    b752:	8e ea       	ldi	r24, 0xAE	; 174
    b754:	96 e0       	ldi	r25, 0x06	; 6
    b756:	0e 94 fd 80 	call	0x101fa	; 0x101fa <strlen_P>
    b75a:	81 50       	subi	r24, 0x01	; 1
    b75c:	80 93 f4 04 	sts	0x04F4, r24
    b760:	e4 ce       	rjmp	.-568    	; 0xb52a <MenuUD+0x1b0>
		if( (prd(&Field->Min) == DIGIT) && (prd(&Field->Max) == DIGIT) ){
			if(Dir==1){	if(++MultiSymbol > 9) MultiSymbol = 0;}
			else{		if(--MultiSymbol == 255) MultiSymbol = 9;}
		}
		else{
			if(Dir==1){	if(++MultiSymbol >= strlen_P(Symbols_P)) MultiSymbol = 0;}
    b762:	00 91 f4 04 	lds	r16, 0x04F4
    b766:	0f 5f       	subi	r16, 0xFF	; 255
    b768:	00 93 f4 04 	sts	0x04F4, r16
    b76c:	85 e0       	ldi	r24, 0x05	; 5
    b76e:	96 e0       	ldi	r25, 0x06	; 6
    b770:	0e 94 fd 80 	call	0x101fa	; 0x101fa <strlen_P>
    b774:	10 e0       	ldi	r17, 0x00	; 0
    b776:	08 17       	cp	r16, r24
    b778:	19 07       	cpc	r17, r25
    b77a:	08 f4       	brcc	.+2      	; 0xb77e <MenuUD+0x404>
    b77c:	79 ce       	rjmp	.-782    	; 0xb470 <MenuUD+0xf6>
    b77e:	10 92 f4 04 	sts	0x04F4, r1
    b782:	76 ce       	rjmp	.-788    	; 0xb470 <MenuUD+0xf6>
	case Bit: case EE_Bit:
		F_Buf = !F_Buf;
		break;
	case Text: case EE_Text:
		if( (prd(&Field->Min) == DIGIT) && (prd(&Field->Max) == DIGIT) ){
			if(Dir==1){	if(++MultiSymbol > 9) MultiSymbol = 0;}
    b784:	80 91 f4 04 	lds	r24, 0x04F4
    b788:	8f 5f       	subi	r24, 0xFF	; 255
    b78a:	80 93 f4 04 	sts	0x04F4, r24
    b78e:	8a 30       	cpi	r24, 0x0A	; 10
    b790:	08 f4       	brcc	.+2      	; 0xb794 <MenuUD+0x41a>
    b792:	6e ce       	rjmp	.-804    	; 0xb470 <MenuUD+0xf6>
    b794:	f4 cf       	rjmp	.-24     	; 0xb77e <MenuUD+0x404>
			else{		if(--MultiSymbol == 255) MultiSymbol = 9;}
    b796:	89 e0       	ldi	r24, 0x09	; 9
    b798:	80 93 f4 04 	sts	0x04F4, r24
    b79c:	69 ce       	rjmp	.-814    	; 0xb470 <MenuUD+0xf6>

0000b79e <MenuDown>:
}

// ~~~~~~~~~~~
void
MenuDown(void)
{
    b79e:	ef 92       	push	r14
    b7a0:	ff 92       	push	r15
    b7a2:	0f 93       	push	r16
    b7a4:	1f 93       	push	r17
    b7a6:	cf 93       	push	r28
    b7a8:	df 93       	push	r29
	MenuUD(&CurrPage->Down, -1, prb(&CurrPage->LineNumber)-CurrLine>1, CurrLCD<LCDYSz-1, F_Buf>prd(&GetField->Min));
    b7aa:	c0 91 d4 02 	lds	r28, 0x02D4
    b7ae:	d0 91 d5 02 	lds	r29, 0x02D5

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    b7b2:	22 96       	adiw	r28, 0x02	; 2
    b7b4:	fe 01       	movw	r30, r28
    b7b6:	24 91       	lpm	r18, Z+
    b7b8:	22 97       	sbiw	r28, 0x02	; 2
    b7ba:	40 91 c9 07 	lds	r20, 0x07C9

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    b7be:	fe 01       	movw	r30, r28
    b7c0:	65 91       	lpm	r22, Z+
    b7c2:	74 91       	lpm	r23, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    b7c4:	8b e1       	ldi	r24, 0x1B	; 27
    b7c6:	48 9f       	mul	r20, r24
    b7c8:	c0 01       	movw	r24, r0
    b7ca:	11 24       	eor	r1, r1
    b7cc:	68 0f       	add	r22, r24
    b7ce:	79 1f       	adc	r23, r25
    b7d0:	69 5e       	subi	r22, 0xE9	; 233
    b7d2:	7f 4f       	sbci	r23, 0xFF	; 255
    b7d4:	fb 01       	movw	r30, r22
    b7d6:	a5 91       	lpm	r26, Z+
    b7d8:	b4 91       	lpm	r27, Z+
    b7da:	80 91 d6 02 	lds	r24, 0x02D6
    b7de:	90 e0       	ldi	r25, 0x00	; 0
    b7e0:	82 95       	swap	r24
    b7e2:	92 95       	swap	r25
    b7e4:	90 7f       	andi	r25, 0xF0	; 240
    b7e6:	98 27       	eor	r25, r24
    b7e8:	80 7f       	andi	r24, 0xF0	; 240
    b7ea:	98 27       	eor	r25, r24
    b7ec:	a8 0f       	add	r26, r24
    b7ee:	b9 1f       	adc	r27, r25
    b7f0:	13 96       	adiw	r26, 0x03	; 3
    b7f2:	fd 01       	movw	r30, r26
    b7f4:	e5 90       	lpm	r14, Z+
    b7f6:	f5 90       	lpm	r15, Z+
    b7f8:	05 91       	lpm	r16, Z+
    b7fa:	14 91       	lpm	r17, Z+
    b7fc:	fe 01       	movw	r30, r28
    b7fe:	72 96       	adiw	r30, 0x12	; 18
    b800:	50 e0       	ldi	r21, 0x00	; 0
    b802:	30 e0       	ldi	r19, 0x00	; 0
    b804:	24 1b       	sub	r18, r20
    b806:	31 09       	sbc	r19, r1
    b808:	22 30       	cpi	r18, 0x02	; 2
    b80a:	31 05       	cpc	r19, r1
    b80c:	0c f0       	brlt	.+2      	; 0xb810 <MenuDown+0x72>
    b80e:	51 e0       	ldi	r21, 0x01	; 1
    b810:	20 e0       	ldi	r18, 0x00	; 0
    b812:	80 91 e7 08 	lds	r24, 0x08E7
    b816:	83 30       	cpi	r24, 0x03	; 3
    b818:	08 f4       	brcc	.+2      	; 0xb81c <MenuDown+0x7e>
    b81a:	21 e0       	ldi	r18, 0x01	; 1
    b81c:	30 e0       	ldi	r19, 0x00	; 0
    b81e:	80 91 f7 04 	lds	r24, 0x04F7
    b822:	90 91 f8 04 	lds	r25, 0x04F8
    b826:	a0 91 f9 04 	lds	r26, 0x04F9
    b82a:	b0 91 fa 04 	lds	r27, 0x04FA
    b82e:	e8 16       	cp	r14, r24
    b830:	f9 06       	cpc	r15, r25
    b832:	0a 07       	cpc	r16, r26
    b834:	1b 07       	cpc	r17, r27
    b836:	08 f4       	brcc	.+2      	; 0xb83a <MenuDown+0x9c>
    b838:	31 e0       	ldi	r19, 0x01	; 1
    b83a:	cf 01       	movw	r24, r30
    b83c:	6f ef       	ldi	r22, 0xFF	; 255
    b83e:	45 2f       	mov	r20, r21
    b840:	03 2f       	mov	r16, r19
    b842:	0e 94 bd 59 	call	0xb37a	; 0xb37a <MenuUD>
}
    b846:	df 91       	pop	r29
    b848:	cf 91       	pop	r28
    b84a:	1f 91       	pop	r17
    b84c:	0f 91       	pop	r16
    b84e:	ff 90       	pop	r15
    b850:	ef 90       	pop	r14
    b852:	08 95       	ret

0000b854 <MenuUp>:
}

// ~~~~~~~~~
void
MenuUp(void)
{
    b854:	ef 92       	push	r14
    b856:	ff 92       	push	r15
    b858:	0f 93       	push	r16
    b85a:	1f 93       	push	r17
	uint8_t Fix=GetFix();
    b85c:	a0 91 d4 02 	lds	r26, 0x02D4
    b860:	b0 91 d5 02 	lds	r27, 0x02D5

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    b864:	13 96       	adiw	r26, 0x03	; 3
    b866:	fd 01       	movw	r30, r26
    b868:	34 91       	lpm	r19, Z+
    b86a:	13 97       	sbiw	r26, 0x03	; 3
	MenuUD(&CurrPage->Up, 1, CurrLine>Fix, CurrLCD>Fix, F_Buf<prd(&GetField->Max));
    b86c:	20 91 c9 07 	lds	r18, 0x07C9

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    b870:	fd 01       	movw	r30, r26
    b872:	45 91       	lpm	r20, Z+
    b874:	54 91       	lpm	r21, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    b876:	8b e1       	ldi	r24, 0x1B	; 27
    b878:	28 9f       	mul	r18, r24
    b87a:	c0 01       	movw	r24, r0
    b87c:	11 24       	eor	r1, r1
    b87e:	48 0f       	add	r20, r24
    b880:	59 1f       	adc	r21, r25
    b882:	49 5e       	subi	r20, 0xE9	; 233
    b884:	5f 4f       	sbci	r21, 0xFF	; 255
    b886:	fa 01       	movw	r30, r20
    b888:	65 91       	lpm	r22, Z+
    b88a:	74 91       	lpm	r23, Z+
    b88c:	80 91 d6 02 	lds	r24, 0x02D6
    b890:	90 e0       	ldi	r25, 0x00	; 0
    b892:	82 95       	swap	r24
    b894:	92 95       	swap	r25
    b896:	90 7f       	andi	r25, 0xF0	; 240
    b898:	98 27       	eor	r25, r24
    b89a:	80 7f       	andi	r24, 0xF0	; 240
    b89c:	98 27       	eor	r25, r24
    b89e:	68 0f       	add	r22, r24
    b8a0:	79 1f       	adc	r23, r25
    b8a2:	69 5f       	subi	r22, 0xF9	; 249
    b8a4:	7f 4f       	sbci	r23, 0xFF	; 255
    b8a6:	fb 01       	movw	r30, r22
    b8a8:	e5 90       	lpm	r14, Z+
    b8aa:	f5 90       	lpm	r15, Z+
    b8ac:	05 91       	lpm	r16, Z+
    b8ae:	14 91       	lpm	r17, Z+
    b8b0:	fd 01       	movw	r30, r26
    b8b2:	70 96       	adiw	r30, 0x10	; 16
    b8b4:	40 e0       	ldi	r20, 0x00	; 0
    b8b6:	32 17       	cp	r19, r18
    b8b8:	08 f4       	brcc	.+2      	; 0xb8bc <MenuUp+0x68>
    b8ba:	41 e0       	ldi	r20, 0x01	; 1
    b8bc:	20 e0       	ldi	r18, 0x00	; 0
    b8be:	80 91 e7 08 	lds	r24, 0x08E7
    b8c2:	38 17       	cp	r19, r24
    b8c4:	08 f4       	brcc	.+2      	; 0xb8c8 <MenuUp+0x74>
    b8c6:	21 e0       	ldi	r18, 0x01	; 1
    b8c8:	30 e0       	ldi	r19, 0x00	; 0
    b8ca:	80 91 f7 04 	lds	r24, 0x04F7
    b8ce:	90 91 f8 04 	lds	r25, 0x04F8
    b8d2:	a0 91 f9 04 	lds	r26, 0x04F9
    b8d6:	b0 91 fa 04 	lds	r27, 0x04FA
    b8da:	8e 15       	cp	r24, r14
    b8dc:	9f 05       	cpc	r25, r15
    b8de:	a0 07       	cpc	r26, r16
    b8e0:	b1 07       	cpc	r27, r17
    b8e2:	08 f4       	brcc	.+2      	; 0xb8e6 <MenuUp+0x92>
    b8e4:	31 e0       	ldi	r19, 0x01	; 1
    b8e6:	cf 01       	movw	r24, r30
    b8e8:	61 e0       	ldi	r22, 0x01	; 1
    b8ea:	03 2f       	mov	r16, r19
    b8ec:	0e 94 bd 59 	call	0xb37a	; 0xb37a <MenuUD>
}
    b8f0:	1f 91       	pop	r17
    b8f2:	0f 91       	pop	r16
    b8f4:	ff 90       	pop	r15
    b8f6:	ef 90       	pop	r14
    b8f8:	08 95       	ret

0000b8fa <PutField>:
	sprintf(Param->Pos, Format, Val);
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
PutField(uint8_t Type, void *Var, T_Param *Param)
{
    b8fa:	af 92       	push	r10
    b8fc:	bf 92       	push	r11
    b8fe:	cf 92       	push	r12
    b900:	df 92       	push	r13
    b902:	ef 92       	push	r14
    b904:	ff 92       	push	r15
    b906:	0f 93       	push	r16
    b908:	1f 93       	push	r17
    b90a:	df 93       	push	r29
    b90c:	cf 93       	push	r28
    b90e:	cd b7       	in	r28, 0x3d	; 61
    b910:	de b7       	in	r29, 0x3e	; 62
    b912:	69 97       	sbiw	r28, 0x19	; 25
    b914:	0f b6       	in	r0, 0x3f	; 63
    b916:	f8 94       	cli
    b918:	de bf       	out	0x3e, r29	; 62
    b91a:	0f be       	out	0x3f, r0	; 63
    b91c:	cd bf       	out	0x3d, r28	; 61
    b91e:	db 01       	movw	r26, r22
    b920:	7a 01       	movw	r14, r20
	float fTemp;

	switch(Type) {
    b922:	e8 2f       	mov	r30, r24
    b924:	f0 e0       	ldi	r31, 0x00	; 0
    b926:	e3 32       	cpi	r30, 0x23	; 35
    b928:	f1 05       	cpc	r31, r1
    b92a:	88 f5       	brcc	.+98     	; 0xb98e <PutField+0x94>
    b92c:	e7 52       	subi	r30, 0x27	; 39
    b92e:	ff 4f       	sbci	r31, 0xFF	; 255
    b930:	ee 0f       	add	r30, r30
    b932:	ff 1f       	adc	r31, r31
    b934:	05 90       	lpm	r0, Z+
    b936:	f4 91       	lpm	r31, Z+
    b938:	e0 2d       	mov	r30, r0
    b93a:	19 94       	eijmp
		break;
	case Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((*((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
		break;
	case EE_Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((erb((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
    b93c:	fa 01       	movw	r30, r20
    b93e:	a0 80       	ld	r10, Z
    b940:	b1 80       	ldd	r11, Z+1	; 0x01
    b942:	c4 80       	ldd	r12, Z+4	; 0x04
    b944:	d5 80       	ldd	r13, Z+5	; 0x05
    b946:	12 81       	ldd	r17, Z+2	; 0x02
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    b948:	81 2f       	mov	r24, r17
    b94a:	86 95       	lsr	r24
    b94c:	86 95       	lsr	r24
    b94e:	86 95       	lsr	r24
    b950:	9b 01       	movw	r18, r22
    b952:	28 0f       	add	r18, r24
    b954:	31 1d       	adc	r19, r1
    b956:	c9 01       	movw	r24, r18
    b958:	0e 94 17 84 	call	0x1082e	; 0x1082e <__eerd_byte_m2560>
    b95c:	17 70       	andi	r17, 0x07	; 7
    b95e:	21 e0       	ldi	r18, 0x01	; 1
    b960:	30 e0       	ldi	r19, 0x00	; 0
    b962:	02 c0       	rjmp	.+4      	; 0xb968 <PutField+0x6e>
    b964:	22 0f       	add	r18, r18
    b966:	33 1f       	adc	r19, r19
    b968:	1a 95       	dec	r17
    b96a:	e2 f7       	brpl	.-8      	; 0xb964 <PutField+0x6a>
    b96c:	90 e0       	ldi	r25, 0x00	; 0
    b96e:	28 23       	and	r18, r24
    b970:	39 23       	and	r19, r25
    b972:	12 16       	cp	r1, r18
    b974:	13 06       	cpc	r1, r19
    b976:	0c f0       	brlt	.+2      	; 0xb97a <PutField+0x80>
    b978:	3f c1       	rjmp	.+638    	; 0xbbf8 <PutField+0x2fe>
    b97a:	82 e0       	ldi	r24, 0x02	; 2
    b97c:	90 e0       	ldi	r25, 0x00	; 0

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    b97e:	f6 01       	movw	r30, r12
    b980:	e8 0f       	add	r30, r24
    b982:	f9 1f       	adc	r31, r25
    b984:	65 91       	lpm	r22, Z+
    b986:	74 91       	lpm	r23, Z+
    b988:	c5 01       	movw	r24, r10
    b98a:	0e 94 f6 80 	call	0x101ec	; 0x101ec <strcpy_P>
			erbl(TempStr, Var, Param->Size);
			Put_TextValAlignRight(TempStr, Param);
		}
		break;
	}
}
    b98e:	69 96       	adiw	r28, 0x19	; 25
    b990:	0f b6       	in	r0, 0x3f	; 63
    b992:	f8 94       	cli
    b994:	de bf       	out	0x3e, r29	; 62
    b996:	0f be       	out	0x3f, r0	; 63
    b998:	cd bf       	out	0x3d, r28	; 61
    b99a:	cf 91       	pop	r28
    b99c:	df 91       	pop	r29
    b99e:	1f 91       	pop	r17
    b9a0:	0f 91       	pop	r16
    b9a2:	ff 90       	pop	r15
    b9a4:	ef 90       	pop	r14
    b9a6:	df 90       	pop	r13
    b9a8:	cf 90       	pop	r12
    b9aa:	bf 90       	pop	r11
    b9ac:	af 90       	pop	r10
    b9ae:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    b9b0:	8e 01       	movw	r16, r28
    b9b2:	0b 5f       	subi	r16, 0xFB	; 251
    b9b4:	1f 4f       	sbci	r17, 0xFF	; 255
    b9b6:	fa 01       	movw	r30, r20
    b9b8:	43 81       	ldd	r20, Z+3	; 0x03
    b9ba:	c8 01       	movw	r24, r16
    b9bc:	50 e0       	ldi	r21, 0x00	; 0
    b9be:	0e 94 07 84 	call	0x1080e	; 0x1080e <__eerd_block_m2560>
		Put_TextValAlignRight(Var, Param);
		break;
	case EE_Text:{
			char TempStr[LCDXSz+1];
			erbl(TempStr, Var, Param->Size);
			Put_TextValAlignRight(TempStr, Param);
    b9c2:	c8 01       	movw	r24, r16
    b9c4:	b7 01       	movw	r22, r14
    b9c6:	0e 94 78 44 	call	0x88f0	; 0x88f0 <Put_TextValAlignRight>
    b9ca:	e1 cf       	rjmp	.-62     	; 0xb98e <PutField+0x94>
	case EE_Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((erb((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
		break;

	case Text:
		Put_TextValAlignRight(Var, Param);
    b9cc:	cb 01       	movw	r24, r22
    b9ce:	ba 01       	movw	r22, r20
    b9d0:	0e 94 78 44 	call	0x88f0	; 0x88f0 <Put_TextValAlignRight>
    b9d4:	dc cf       	rjmp	.-72     	; 0xb98e <PutField+0x94>
	case EE_Enum:
		Param->Txt += erb((uint8_t*)Var);
		PutEnum(Param);
		break;
	case Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((*((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
    b9d6:	fa 01       	movw	r30, r20
    b9d8:	00 81       	ld	r16, Z
    b9da:	11 81       	ldd	r17, Z+1	; 0x01
    b9dc:	64 81       	ldd	r22, Z+4	; 0x04
    b9de:	75 81       	ldd	r23, Z+5	; 0x05
    b9e0:	42 81       	ldd	r20, Z+2	; 0x02
    b9e2:	84 2f       	mov	r24, r20
    b9e4:	86 95       	lsr	r24
    b9e6:	86 95       	lsr	r24
    b9e8:	86 95       	lsr	r24
    b9ea:	a8 0f       	add	r26, r24
    b9ec:	b1 1d       	adc	r27, r1
    b9ee:	2c 91       	ld	r18, X
    b9f0:	30 e0       	ldi	r19, 0x00	; 0
    b9f2:	47 70       	andi	r20, 0x07	; 7
    b9f4:	81 e0       	ldi	r24, 0x01	; 1
    b9f6:	90 e0       	ldi	r25, 0x00	; 0
    b9f8:	02 c0       	rjmp	.+4      	; 0xb9fe <PutField+0x104>
    b9fa:	88 0f       	add	r24, r24
    b9fc:	99 1f       	adc	r25, r25
    b9fe:	4a 95       	dec	r20
    ba00:	e2 f7       	brpl	.-8      	; 0xb9fa <PutField+0x100>
    ba02:	28 23       	and	r18, r24
    ba04:	39 23       	and	r19, r25
    ba06:	12 16       	cp	r1, r18
    ba08:	13 06       	cpc	r1, r19
    ba0a:	0c f0       	brlt	.+2      	; 0xba0e <PutField+0x114>
    ba0c:	f8 c0       	rjmp	.+496    	; 0xbbfe <PutField+0x304>
    ba0e:	82 e0       	ldi	r24, 0x02	; 2
    ba10:	90 e0       	ldi	r25, 0x00	; 0

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    ba12:	fb 01       	movw	r30, r22
    ba14:	e8 0f       	add	r30, r24
    ba16:	f9 1f       	adc	r31, r25
    ba18:	65 91       	lpm	r22, Z+
    ba1a:	74 91       	lpm	r23, Z+
    ba1c:	c8 01       	movw	r24, r16
    ba1e:	0e 94 f6 80 	call	0x101ec	; 0x101ec <strcpy_P>
    ba22:	b5 cf       	rjmp	.-150    	; 0xb98e <PutField+0x94>
		Put_GFVal(fTemp, Param);
		break;


	case Enum:
		Param->Txt += *(uint8_t*)Var;
    ba24:	2c 91       	ld	r18, X
    ba26:	30 e0       	ldi	r19, 0x00	; 0
    ba28:	22 0f       	add	r18, r18
    ba2a:	33 1f       	adc	r19, r19
    ba2c:	f7 01       	movw	r30, r14
    ba2e:	84 81       	ldd	r24, Z+4	; 0x04
    ba30:	95 81       	ldd	r25, Z+5	; 0x05
    ba32:	82 0f       	add	r24, r18
    ba34:	93 1f       	adc	r25, r19
    ba36:	95 83       	std	Z+5, r25	; 0x05
    ba38:	84 83       	std	Z+4, r24	; 0x04
		PutEnum(Param);
    ba3a:	c7 01       	movw	r24, r14
    ba3c:	0e 94 24 42 	call	0x8448	; 0x8448 <PutEnum>
    ba40:	a6 cf       	rjmp	.-180    	; 0xb98e <PutField+0x94>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    ba42:	cb 01       	movw	r24, r22
    ba44:	0e 94 17 84 	call	0x1082e	; 0x1082e <__eerd_byte_m2560>
		break;
	case EE_Enum:
		Param->Txt += erb((uint8_t*)Var);
    ba48:	90 e0       	ldi	r25, 0x00	; 0
    ba4a:	88 0f       	add	r24, r24
    ba4c:	99 1f       	adc	r25, r25
    ba4e:	f7 01       	movw	r30, r14
    ba50:	24 81       	ldd	r18, Z+4	; 0x04
    ba52:	35 81       	ldd	r19, Z+5	; 0x05
    ba54:	28 0f       	add	r18, r24
    ba56:	39 1f       	adc	r19, r25
    ba58:	35 83       	std	Z+5, r19	; 0x05
    ba5a:	24 83       	std	Z+4, r18	; 0x04
		PutEnum(Param);
    ba5c:	c7 01       	movw	r24, r14
    ba5e:	0e 94 24 42 	call	0x8448	; 0x8448 <PutEnum>
    ba62:	95 cf       	rjmp	.-214    	; 0xb98e <PutField+0x94>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    ba64:	ce 01       	movw	r24, r28
    ba66:	01 96       	adiw	r24, 0x01	; 1
    ba68:	44 e0       	ldi	r20, 0x04	; 4
    ba6a:	50 e0       	ldi	r21, 0x00	; 0
    ba6c:	0e 94 07 84 	call	0x1080e	; 0x1080e <__eerd_block_m2560>
	case GFloat:
		Put_GFVal(*(float*)Var, Param);
		break;			
	case EE_GFloat:
		erbl(&fTemp, Var, 4);
		Put_GFVal(fTemp, Param);
    ba70:	69 81       	ldd	r22, Y+1	; 0x01
    ba72:	7a 81       	ldd	r23, Y+2	; 0x02
    ba74:	8b 81       	ldd	r24, Y+3	; 0x03
    ba76:	9c 81       	ldd	r25, Y+4	; 0x04
    ba78:	a7 01       	movw	r20, r14
    ba7a:	0e 94 d4 44 	call	0x89a8	; 0x89a8 <Put_GFVal>
    ba7e:	87 cf       	rjmp	.-242    	; 0xb98e <PutField+0x94>
	case EE_FFloat:
		erbl(&fTemp, Var, 4);
		Put_FFVal(fTemp, Param);
		break;
	case GFloat:
		Put_GFVal(*(float*)Var, Param);
    ba80:	6d 91       	ld	r22, X+
    ba82:	7d 91       	ld	r23, X+
    ba84:	8d 91       	ld	r24, X+
    ba86:	9c 91       	ld	r25, X
    ba88:	0e 94 d4 44 	call	0x89a8	; 0x89a8 <Put_GFVal>
    ba8c:	80 cf       	rjmp	.-256    	; 0xb98e <PutField+0x94>
    ba8e:	ce 01       	movw	r24, r28
    ba90:	01 96       	adiw	r24, 0x01	; 1
    ba92:	44 e0       	ldi	r20, 0x04	; 4
    ba94:	50 e0       	ldi	r21, 0x00	; 0
    ba96:	0e 94 07 84 	call	0x1080e	; 0x1080e <__eerd_block_m2560>
	case FFloat:
		Put_FFVal(*(float*)Var, Param);
		break;			
	case EE_FFloat:
		erbl(&fTemp, Var, 4);
		Put_FFVal(fTemp, Param);
    ba9a:	69 81       	ldd	r22, Y+1	; 0x01
    ba9c:	7a 81       	ldd	r23, Y+2	; 0x02
    ba9e:	8b 81       	ldd	r24, Y+3	; 0x03
    baa0:	9c 81       	ldd	r25, Y+4	; 0x04
    baa2:	a7 01       	movw	r20, r14
    baa4:	0e 94 4e 45 	call	0x8a9c	; 0x8a9c <Put_FFVal>
    baa8:	72 cf       	rjmp	.-284    	; 0xb98e <PutField+0x94>
		Put_zDVal(erd((uint32_t*)Var), Param);
		break;

		
	case FFloat:
		Put_FFVal(*(float*)Var, Param);
    baaa:	6d 91       	ld	r22, X+
    baac:	7d 91       	ld	r23, X+
    baae:	8d 91       	ld	r24, X+
    bab0:	9c 91       	ld	r25, X
    bab2:	0e 94 4e 45 	call	0x8a9c	; 0x8a9c <Put_FFVal>
    bab6:	6b cf       	rjmp	.-298    	; 0xb98e <PutField+0x94>
		break;
	case zh_Word:
		Put_zVal_h(*(uint16_t*)Var, 'w', Param);
		break;
	case zh_Longint:
		Put_zVal_h(*(uint32_t*)Var, 'l', Param);
    bab8:	6d 91       	ld	r22, X+
    baba:	7d 91       	ld	r23, X+
    babc:	8d 91       	ld	r24, X+
    babe:	9c 91       	ld	r25, X
    bac0:	4c e6       	ldi	r20, 0x6C	; 108
    bac2:	97 01       	movw	r18, r14
    bac4:	0e 94 0e 49 	call	0x921c	; 0x921c <Put_zVal_h>
    bac8:	62 cf       	rjmp	.-316    	; 0xb98e <PutField+0x94>
// ~~~~~~~~~~~~~~~~~~~~~~
uint32_t
erd(const uint32_t *addr)
{
	//IntOff();
	uint32_t word = eeprom_read_dword(addr);
    baca:	cb 01       	movw	r24, r22
    bacc:	0e 94 1f 84 	call	0x1083e	; 0x1083e <__eerd_dword_m2560>
		break;
	case z_Longint: case zc_Longint:
		Put_zDVal(*(uint32_t*)Var, Param);
		break;
	case z_EE_Longint:
		Put_zDVal(erd((uint32_t*)Var), Param);
    bad0:	a7 01       	movw	r20, r14
    bad2:	0e 94 a3 45 	call	0x8b46	; 0x8b46 <Put_zDVal>
    bad6:	5b cf       	rjmp	.-330    	; 0xb98e <PutField+0x94>
		break;
	case s_EE_Longint:
		Put_sDVal((int32_t)erd((uint32_t*)Var), Param);
		break;
	case z_Longint: case zc_Longint:
		Put_zDVal(*(uint32_t*)Var, Param);
    bad8:	6d 91       	ld	r22, X+
    bada:	7d 91       	ld	r23, X+
    badc:	8d 91       	ld	r24, X+
    bade:	9c 91       	ld	r25, X
    bae0:	0e 94 a3 45 	call	0x8b46	; 0x8b46 <Put_zDVal>
    bae4:	54 cf       	rjmp	.-344    	; 0xb98e <PutField+0x94>
    bae6:	cb 01       	movw	r24, r22
    bae8:	0e 94 1f 84 	call	0x1083e	; 0x1083e <__eerd_dword_m2560>
		break;
	case s_Longint:
		Put_sDVal(*(int32_t*)Var, Param);
		break;
	case s_EE_Longint:
		Put_sDVal((int32_t)erd((uint32_t*)Var), Param);
    baec:	a7 01       	movw	r20, r14
    baee:	0e 94 c4 46 	call	0x8d88	; 0x8d88 <Put_sDVal>
    baf2:	4d cf       	rjmp	.-358    	; 0xb98e <PutField+0x94>
		break;
	case EE_Longint:
		PutDVal(erd((uint32_t*)Var), Param);
		break;
	case s_Longint:
		Put_sDVal(*(int32_t*)Var, Param);
    baf4:	6d 91       	ld	r22, X+
    baf6:	7d 91       	ld	r23, X+
    baf8:	8d 91       	ld	r24, X+
    bafa:	9c 91       	ld	r25, X
    bafc:	0e 94 c4 46 	call	0x8d88	; 0x8d88 <Put_sDVal>
    bb00:	46 cf       	rjmp	.-372    	; 0xb98e <PutField+0x94>
    bb02:	cb 01       	movw	r24, r22
    bb04:	0e 94 1f 84 	call	0x1083e	; 0x1083e <__eerd_dword_m2560>

	case Longint: case c_Longint:
		PutDVal(*(uint32_t*)Var, Param);
		break;
	case EE_Longint:
		PutDVal(erd((uint32_t*)Var), Param);
    bb08:	a7 01       	movw	r20, r14
    bb0a:	0e 94 ed 47 	call	0x8fda	; 0x8fda <PutDVal>
    bb0e:	3f cf       	rjmp	.-386    	; 0xb98e <PutField+0x94>
		Put_zVal(erw((uint16_t*)Var), 'w', Param);
		break;


	case Longint: case c_Longint:
		PutDVal(*(uint32_t*)Var, Param);
    bb10:	6d 91       	ld	r22, X+
    bb12:	7d 91       	ld	r23, X+
    bb14:	8d 91       	ld	r24, X+
    bb16:	9c 91       	ld	r25, X
    bb18:	0e 94 ed 47 	call	0x8fda	; 0x8fda <PutDVal>
    bb1c:	38 cf       	rjmp	.-400    	; 0xb98e <PutField+0x94>

	case zh_Byte:
		Put_zVal_h(*(uint8_t*)Var, 'b', Param);
		break;
	case zh_Word:
		Put_zVal_h(*(uint16_t*)Var, 'w', Param);
    bb1e:	6d 91       	ld	r22, X+
    bb20:	7c 91       	ld	r23, X
    bb22:	80 e0       	ldi	r24, 0x00	; 0
    bb24:	90 e0       	ldi	r25, 0x00	; 0
    bb26:	47 e7       	ldi	r20, 0x77	; 119
    bb28:	97 01       	movw	r18, r14
    bb2a:	0e 94 0e 49 	call	0x921c	; 0x921c <Put_zVal_h>
    bb2e:	2f cf       	rjmp	.-418    	; 0xb98e <PutField+0x94>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    bb30:	cb 01       	movw	r24, r22
    bb32:	0e 94 25 84 	call	0x1084a	; 0x1084a <__eerd_word_m2560>
		break;
	case z_Word: case zc_Word:
		Put_zVal(*(uint16_t*)Var, 'w', Param);
		break;
	case z_EE_Word:
		Put_zVal(erw((uint16_t*)Var), 'w', Param);
    bb36:	67 e7       	ldi	r22, 0x77	; 119
    bb38:	a7 01       	movw	r20, r14
    bb3a:	0e 94 81 49 	call	0x9302	; 0x9302 <Put_zVal>
    bb3e:	27 cf       	rjmp	.-434    	; 0xb98e <PutField+0x94>
		break;
	case s_EE_Word:
		Put_sVal((int16_t)erw((uint16_t*)Var), 'w', Param);
		break;
	case z_Word: case zc_Word:
		Put_zVal(*(uint16_t*)Var, 'w', Param);
    bb40:	8d 91       	ld	r24, X+
    bb42:	9c 91       	ld	r25, X
    bb44:	67 e7       	ldi	r22, 0x77	; 119
    bb46:	0e 94 81 49 	call	0x9302	; 0x9302 <Put_zVal>
    bb4a:	21 cf       	rjmp	.-446    	; 0xb98e <PutField+0x94>
    bb4c:	cb 01       	movw	r24, r22
    bb4e:	0e 94 25 84 	call	0x1084a	; 0x1084a <__eerd_word_m2560>
		break;
	case s_Word:
		Put_sVal(*(int16_t*)Var, 'w', Param);
		break;
	case s_EE_Word:
		Put_sVal((int16_t)erw((uint16_t*)Var), 'w', Param);
    bb52:	67 e7       	ldi	r22, 0x77	; 119
    bb54:	a7 01       	movw	r20, r14
    bb56:	0e 94 3e 4a 	call	0x947c	; 0x947c <Put_sVal>
    bb5a:	19 cf       	rjmp	.-462    	; 0xb98e <PutField+0x94>
		break;
	case EE_Word:
		PutVal(erw((uint16_t*)Var), 'w', Param);
		break;
	case s_Word:
		Put_sVal(*(int16_t*)Var, 'w', Param);
    bb5c:	8d 91       	ld	r24, X+
    bb5e:	9c 91       	ld	r25, X
    bb60:	67 e7       	ldi	r22, 0x77	; 119
    bb62:	0e 94 3e 4a 	call	0x947c	; 0x947c <Put_sVal>
    bb66:	13 cf       	rjmp	.-474    	; 0xb98e <PutField+0x94>
    bb68:	cb 01       	movw	r24, r22
    bb6a:	0e 94 25 84 	call	0x1084a	; 0x1084a <__eerd_word_m2560>

	case Word: case c_Word:
		PutVal(*(uint16_t*)Var, 'w', Param);
		break;
	case EE_Word:
		PutVal(erw((uint16_t*)Var), 'w', Param);
    bb6e:	67 e7       	ldi	r22, 0x77	; 119
    bb70:	a7 01       	movw	r20, r14
    bb72:	0e 94 22 4b 	call	0x9644	; 0x9644 <PutVal>
    bb76:	0b cf       	rjmp	.-490    	; 0xb98e <PutField+0x94>
	case zh_Longint:
		Put_zVal_h(*(uint32_t*)Var, 'l', Param);
		break;

	case Word: case c_Word:
		PutVal(*(uint16_t*)Var, 'w', Param);
    bb78:	8d 91       	ld	r24, X+
    bb7a:	9c 91       	ld	r25, X
    bb7c:	67 e7       	ldi	r22, 0x77	; 119
    bb7e:	0e 94 22 4b 	call	0x9644	; 0x9644 <PutVal>
    bb82:	05 cf       	rjmp	.-502    	; 0xb98e <PutField+0x94>
	case z_EE_Byte:
		Put_zVal(erb((uint8_t*)Var), 'b', Param);
		break;

	case zh_Byte:
		Put_zVal_h(*(uint8_t*)Var, 'b', Param);
    bb84:	6c 91       	ld	r22, X
    bb86:	70 e0       	ldi	r23, 0x00	; 0
    bb88:	80 e0       	ldi	r24, 0x00	; 0
    bb8a:	90 e0       	ldi	r25, 0x00	; 0
    bb8c:	42 e6       	ldi	r20, 0x62	; 98
    bb8e:	97 01       	movw	r18, r14
    bb90:	0e 94 0e 49 	call	0x921c	; 0x921c <Put_zVal_h>
    bb94:	fc ce       	rjmp	.-520    	; 0xb98e <PutField+0x94>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    bb96:	cb 01       	movw	r24, r22
    bb98:	0e 94 17 84 	call	0x1082e	; 0x1082e <__eerd_byte_m2560>
		break;
	case z_Byte:
		Put_zVal(*(uint8_t*)Var, 'b', Param);
		break;
	case z_EE_Byte:
		Put_zVal(erb((uint8_t*)Var), 'b', Param);
    bb9c:	90 e0       	ldi	r25, 0x00	; 0
    bb9e:	62 e6       	ldi	r22, 0x62	; 98
    bba0:	a7 01       	movw	r20, r14
    bba2:	0e 94 81 49 	call	0x9302	; 0x9302 <Put_zVal>
    bba6:	f3 ce       	rjmp	.-538    	; 0xb98e <PutField+0x94>
		break;
	case s_EE_Byte:
		Put_sVal((int8_t)erb((uint8_t*)Var), 'b', Param);
		break;
	case z_Byte:
		Put_zVal(*(uint8_t*)Var, 'b', Param);
    bba8:	8c 91       	ld	r24, X
    bbaa:	90 e0       	ldi	r25, 0x00	; 0
    bbac:	62 e6       	ldi	r22, 0x62	; 98
    bbae:	0e 94 81 49 	call	0x9302	; 0x9302 <Put_zVal>
    bbb2:	ed ce       	rjmp	.-550    	; 0xb98e <PutField+0x94>
    bbb4:	cb 01       	movw	r24, r22
    bbb6:	0e 94 17 84 	call	0x1082e	; 0x1082e <__eerd_byte_m2560>
		break;
	case s_Byte:
		Put_sVal(*(int8_t*)Var, 'b', Param);
		break;
	case s_EE_Byte:
		Put_sVal((int8_t)erb((uint8_t*)Var), 'b', Param);
    bbba:	99 27       	eor	r25, r25
    bbbc:	87 fd       	sbrc	r24, 7
    bbbe:	90 95       	com	r25
    bbc0:	62 e6       	ldi	r22, 0x62	; 98
    bbc2:	a7 01       	movw	r20, r14
    bbc4:	0e 94 3e 4a 	call	0x947c	; 0x947c <Put_sVal>
    bbc8:	e2 ce       	rjmp	.-572    	; 0xb98e <PutField+0x94>
		break;
	case EE_Byte:
		PutVal(erb((uint8_t*)Var), 'b', Param);
		break;
	case s_Byte:
		Put_sVal(*(int8_t*)Var, 'b', Param);
    bbca:	8c 91       	ld	r24, X
    bbcc:	99 27       	eor	r25, r25
    bbce:	87 fd       	sbrc	r24, 7
    bbd0:	90 95       	com	r25
    bbd2:	62 e6       	ldi	r22, 0x62	; 98
    bbd4:	0e 94 3e 4a 	call	0x947c	; 0x947c <Put_sVal>
    bbd8:	da ce       	rjmp	.-588    	; 0xb98e <PutField+0x94>
    bbda:	cb 01       	movw	r24, r22
    bbdc:	0e 94 17 84 	call	0x1082e	; 0x1082e <__eerd_byte_m2560>
	switch(Type) {
	case Byte:
		PutVal(*(uint8_t*)Var, 'b', Param);
		break;
	case EE_Byte:
		PutVal(erb((uint8_t*)Var), 'b', Param);
    bbe0:	90 e0       	ldi	r25, 0x00	; 0
    bbe2:	62 e6       	ldi	r22, 0x62	; 98
    bbe4:	a7 01       	movw	r20, r14
    bbe6:	0e 94 22 4b 	call	0x9644	; 0x9644 <PutVal>
    bbea:	d1 ce       	rjmp	.-606    	; 0xb98e <PutField+0x94>
{
	float fTemp;

	switch(Type) {
	case Byte:
		PutVal(*(uint8_t*)Var, 'b', Param);
    bbec:	8c 91       	ld	r24, X
    bbee:	90 e0       	ldi	r25, 0x00	; 0
    bbf0:	62 e6       	ldi	r22, 0x62	; 98
    bbf2:	0e 94 22 4b 	call	0x9644	; 0x9644 <PutVal>
    bbf6:	cb ce       	rjmp	.-618    	; 0xb98e <PutField+0x94>
		break;
	case Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((*((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
		break;
	case EE_Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((erb((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
    bbf8:	80 e0       	ldi	r24, 0x00	; 0
    bbfa:	90 e0       	ldi	r25, 0x00	; 0
    bbfc:	c0 ce       	rjmp	.-640    	; 0xb97e <PutField+0x84>
	case EE_Enum:
		Param->Txt += erb((uint8_t*)Var);
		PutEnum(Param);
		break;
	case Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((*((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
    bbfe:	80 e0       	ldi	r24, 0x00	; 0
    bc00:	90 e0       	ldi	r25, 0x00	; 0
    bc02:	07 cf       	rjmp	.-498    	; 0xba12 <PutField+0x118>

0000bc04 <PutLine>:
	PosBlink(Param,'_');
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
PutLine(uint8_t LineN, uint8_t Y)
{
    bc04:	2f 92       	push	r2
    bc06:	3f 92       	push	r3
    bc08:	4f 92       	push	r4
    bc0a:	5f 92       	push	r5
    bc0c:	6f 92       	push	r6
    bc0e:	7f 92       	push	r7
    bc10:	8f 92       	push	r8
    bc12:	9f 92       	push	r9
    bc14:	af 92       	push	r10
    bc16:	bf 92       	push	r11
    bc18:	cf 92       	push	r12
    bc1a:	df 92       	push	r13
    bc1c:	ef 92       	push	r14
    bc1e:	ff 92       	push	r15
    bc20:	0f 93       	push	r16
    bc22:	1f 93       	push	r17
    bc24:	df 93       	push	r29
    bc26:	cf 93       	push	r28
    bc28:	cd b7       	in	r28, 0x3d	; 61
    bc2a:	de b7       	in	r29, 0x3e	; 62
    bc2c:	60 97       	sbiw	r28, 0x10	; 16
    bc2e:	0f b6       	in	r0, 0x3f	; 63
    bc30:	f8 94       	cli
    bc32:	de bf       	out	0x3e, r29	; 62
    bc34:	0f be       	out	0x3f, r0	; 63
    bc36:	cd bf       	out	0x3d, r28	; 61
    bc38:	8f 87       	std	Y+15, r24	; 0x0f
    bc3a:	68 8b       	std	Y+16, r22	; 0x10

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    bc3c:	e0 91 d4 02 	lds	r30, 0x02D4
    bc40:	f0 91 d5 02 	lds	r31, 0x02D5
    bc44:	e5 90       	lpm	r14, Z+
    bc46:	f4 90       	lpm	r15, Z+
	MenuLine *Line=GetLine+LineN;
    bc48:	8b e1       	ldi	r24, 0x1B	; 27
    bc4a:	2f 85       	ldd	r18, Y+15	; 0x0f
    bc4c:	28 9f       	mul	r18, r24
    bc4e:	c0 01       	movw	r24, r0
    bc50:	11 24       	eor	r1, r1
    bc52:	e8 0e       	add	r14, r24
    bc54:	f9 1e       	adc	r15, r25
	PGM_P CurrStr=(PGM_P)(Line->Str);
    bc56:	be 2c       	mov	r11, r14
    bc58:	af 2c       	mov	r10, r15
    bc5a:	f7 01       	movw	r30, r14
    bc5c:	75 96       	adiw	r30, 0x15	; 21
    bc5e:	c5 90       	lpm	r12, Z+
    bc60:	d4 90       	lpm	r13, Z+

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    bc62:	f7 01       	movw	r30, r14
    bc64:	77 96       	adiw	r30, 0x17	; 23
    bc66:	85 91       	lpm	r24, Z+
    bc68:	94 91       	lpm	r25, Z+
    bc6a:	9e 87       	std	Y+14, r25	; 0x0e
    bc6c:	8d 87       	std	Y+13, r24	; 0x0d
    bc6e:	87 01       	movw	r16, r14
    bc70:	f7 01       	movw	r30, r14
    bc72:	84 91       	lpm	r24, Z+
	uint8_t X;
	uint8_t X0=0;
	uint8_t X1=LCDXSz;
	int8_t Xs = 0;
	//--- ">>" Align right
	if(prc(CurrStr+0) == '>' && prc(CurrStr+1) == '>'){
    bc74:	8e 33       	cpi	r24, 0x3E	; 62
    bc76:	09 f4       	brne	.+2      	; 0xbc7a <PutLine+0x76>
    bc78:	a6 c1       	rjmp	.+844    	; 0xbfc6 <PutLine+0x3c2>
		X0 = LCDXSz - strlen_P(CurrStr) + 2;
		Xs = X0-2;
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';
    bc7a:	40 e0       	ldi	r20, 0x00	; 0
    bc7c:	50 e0       	ldi	r21, 0x00	; 0
    bc7e:	f8 01       	movw	r30, r16
    bc80:	84 91       	lpm	r24, Z+
	}
	//--- "<<" Align left
	if(prc(CurrStr+0) == '<' && prc(CurrStr+1) == '<'){
    bc82:	8c 33       	cpi	r24, 0x3C	; 60
    bc84:	09 f4       	brne	.+2      	; 0xbc88 <PutLine+0x84>
    bc86:	8a c1       	rjmp	.+788    	; 0xbf9c <PutLine+0x398>
		X1 = strlen_P(CurrStr) - 2;
    bc88:	84 e1       	ldi	r24, 0x14	; 20
    bc8a:	98 2e       	mov	r9, r24
    bc8c:	f8 01       	movw	r30, r16
    bc8e:	84 91       	lpm	r24, Z+
		X0 = 0;
		Xs = X0-2;
	}
	//--- "<>" Align center
	if(prc(CurrStr+0) == '<' && prc(CurrStr+1) == '>'){
    bc90:	8c 33       	cpi	r24, 0x3C	; 60
    bc92:	09 f4       	brne	.+2      	; 0xbc96 <PutLine+0x92>
    bc94:	56 c1       	rjmp	.+684    	; 0xbf42 <PutLine+0x33e>
		Xs = X0-2;
		X1 = X0 + (strlen_P(CurrStr) - 2);
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';		
	}
	//---
	for(X=X0; X<X1; X++){
    bc96:	49 15       	cp	r20, r9
    bc98:	08 f0       	brcs	.+2      	; 0xbc9c <PutLine+0x98>
    bc9a:	ac c0       	rjmp	.+344    	; 0xbdf4 <PutLine+0x1f0>
static void
PutLine(uint8_t LineN, uint8_t Y)
{
	MenuLine *Line=GetLine+LineN;
	PGM_P CurrStr=(PGM_P)(Line->Str);
	InField *IF = prp(&Line->IF_List);
    bc9c:	88 89       	ldd	r24, Y+16	; 0x10
    bc9e:	28 2f       	mov	r18, r24
    bca0:	30 e0       	ldi	r19, 0x00	; 0
    bca2:	c9 01       	movw	r24, r18
    bca4:	88 0f       	add	r24, r24
    bca6:	99 1f       	adc	r25, r25
    bca8:	82 0f       	add	r24, r18
    bcaa:	93 1f       	adc	r25, r19
    bcac:	5c 01       	movw	r10, r24
    bcae:	aa 0c       	add	r10, r10
    bcb0:	bb 1c       	adc	r11, r11
    bcb2:	aa 0c       	add	r10, r10
    bcb4:	bb 1c       	adc	r11, r11
    bcb6:	aa 0c       	add	r10, r10
    bcb8:	bb 1c       	adc	r11, r11
    bcba:	a8 1a       	sub	r10, r24
    bcbc:	b9 0a       	sbc	r11, r25
    bcbe:	25 2e       	mov	r2, r21
    bcc0:	33 24       	eor	r3, r3
    bcc2:	27 fc       	sbrc	r2, 7
    bcc4:	30 94       	com	r3
    bcc6:	04 2f       	mov	r16, r20
    bcc8:	88 24       	eor	r8, r8
		switch(Char=prc(CurrStr+X-Xs)) {
		case '{':
			while((Char=prc(CurrStr + X - Xs + ++Param.Size))=='{');
			Param.Prec = prb(&IF->Prec);
			Param.Txt = prp(&IF->EnumList);
			PutField(prb(&IF->Type), prp(&IF->Var), &Param);
    bcca:	3e 01       	movw	r6, r28
    bccc:	08 94       	sec
    bcce:	61 1c       	adc	r6, r1
    bcd0:	71 1c       	adc	r7, r1
			else
				PutField(prb(&(OF+OF_N)->Type), prp(&(OF+OF_N)->Var), &Param);
			OF_N++;
			break;
		}
		LCD_Buf[Y][X+=Param.Size] = Char;
    bcd2:	25 01       	movw	r4, r10
    bcd4:	11 c0       	rjmp	.+34     	; 0xbcf8 <PutLine+0xf4>
	for(X=X0; X<X1; X++){
		char Char;
		T_Param Param;
		Param.Pos = LCD_Buf[Y]+X;
		Param.Size = 0;
		switch(Char=prc(CurrStr+X-Xs)) {
    bcd6:	1d 37       	cpi	r17, 0x7D	; 125
    bcd8:	09 f4       	brne	.+2      	; 0xbcdc <PutLine+0xd8>
    bcda:	4c c0       	rjmp	.+152    	; 0xbd74 <PutLine+0x170>
    bcdc:	30 e0       	ldi	r19, 0x00	; 0
			else
				PutField(prb(&(OF+OF_N)->Type), prp(&(OF+OF_N)->Var), &Param);
			OF_N++;
			break;
		}
		LCD_Buf[Y][X+=Param.Size] = Char;
    bcde:	80 2f       	mov	r24, r16
    bce0:	83 0f       	add	r24, r19
    bce2:	f2 01       	movw	r30, r4
    bce4:	e8 0f       	add	r30, r24
    bce6:	f1 1d       	adc	r31, r1
    bce8:	e8 5a       	subi	r30, 0xA8	; 168
    bcea:	f9 4f       	sbci	r31, 0xF9	; 249
    bcec:	10 83       	st	Z, r17
		Xs = X0-2;
		X1 = X0 + (strlen_P(CurrStr) - 2);
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';		
	}
	//---
	for(X=X0; X<X1; X++){
    bcee:	08 2f       	mov	r16, r24
    bcf0:	0f 5f       	subi	r16, 0xFF	; 255
    bcf2:	09 15       	cp	r16, r9
    bcf4:	08 f0       	brcs	.+2      	; 0xbcf8 <PutLine+0xf4>
    bcf6:	7e c0       	rjmp	.+252    	; 0xbdf4 <PutLine+0x1f0>
		char Char;
		T_Param Param;
		Param.Pos = LCD_Buf[Y]+X;
    bcf8:	80 2f       	mov	r24, r16
    bcfa:	90 e0       	ldi	r25, 0x00	; 0
    bcfc:	9c 01       	movw	r18, r24
    bcfe:	2a 0d       	add	r18, r10
    bd00:	3b 1d       	adc	r19, r11
    bd02:	28 5a       	subi	r18, 0xA8	; 168
    bd04:	39 4f       	sbci	r19, 0xF9	; 249
    bd06:	3a 83       	std	Y+2, r19	; 0x02
    bd08:	29 83       	std	Y+1, r18	; 0x01
		Param.Size = 0;
		switch(Char=prc(CurrStr+X-Xs)) {
    bd0a:	82 19       	sub	r24, r2
    bd0c:	93 09       	sbc	r25, r3
    bd0e:	f7 01       	movw	r30, r14
    bd10:	e8 0f       	add	r30, r24
    bd12:	f9 1f       	adc	r31, r25
    bd14:	14 91       	lpm	r17, Z+
    bd16:	1b 37       	cpi	r17, 0x7B	; 123
    bd18:	f1 f6       	brne	.-68     	; 0xbcd6 <PutLine+0xd2>
    bd1a:	21 e0       	ldi	r18, 0x01	; 1
    bd1c:	01 c0       	rjmp	.+2      	; 0xbd20 <PutLine+0x11c>
		case '{':
			while((Char=prc(CurrStr + X - Xs + ++Param.Size))=='{');
    bd1e:	23 2f       	mov	r18, r19
    bd20:	fc 01       	movw	r30, r24
    bd22:	e2 0f       	add	r30, r18
    bd24:	f1 1d       	adc	r31, r1
    bd26:	ee 0d       	add	r30, r14
    bd28:	ff 1d       	adc	r31, r15
    bd2a:	14 91       	lpm	r17, Z+
    bd2c:	32 2f       	mov	r19, r18
    bd2e:	3f 5f       	subi	r19, 0xFF	; 255
    bd30:	1b 37       	cpi	r17, 0x7B	; 123
    bd32:	a9 f3       	breq	.-22     	; 0xbd1e <PutLine+0x11a>
    bd34:	2c 83       	std	Y+4, r18	; 0x04

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    bd36:	a5 e0       	ldi	r26, 0x05	; 5
    bd38:	b0 e0       	ldi	r27, 0x00	; 0
    bd3a:	ca 0e       	add	r12, r26
    bd3c:	db 1e       	adc	r13, r27
    bd3e:	f6 01       	movw	r30, r12
    bd40:	84 91       	lpm	r24, Z+
    bd42:	2b ef       	ldi	r18, 0xFB	; 251
    bd44:	3f ef       	ldi	r19, 0xFF	; 255
    bd46:	c2 0e       	add	r12, r18
    bd48:	d3 1e       	adc	r13, r19
			Param.Prec = prb(&IF->Prec);
    bd4a:	8b 83       	std	Y+3, r24	; 0x03

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    bd4c:	f6 01       	movw	r30, r12
    bd4e:	33 96       	adiw	r30, 0x03	; 3
    bd50:	85 91       	lpm	r24, Z+
    bd52:	94 91       	lpm	r25, Z+
			Param.Txt = prp(&IF->EnumList);
    bd54:	9e 83       	std	Y+6, r25	; 0x06
    bd56:	8d 83       	std	Y+5, r24	; 0x05

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    bd58:	f6 01       	movw	r30, r12
    bd5a:	84 91       	lpm	r24, Z+

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    bd5c:	31 96       	adiw	r30, 0x01	; 1
    bd5e:	65 91       	lpm	r22, Z+
    bd60:	74 91       	lpm	r23, Z+
			PutField(prb(&IF->Type), prp(&IF->Var), &Param);
    bd62:	a3 01       	movw	r20, r6
    bd64:	0e 94 7d 5c 	call	0xb8fa	; 0xb8fa <PutField>
			IF++;
    bd68:	26 e0       	ldi	r18, 0x06	; 6
    bd6a:	30 e0       	ldi	r19, 0x00	; 0
    bd6c:	c2 0e       	add	r12, r18
    bd6e:	d3 1e       	adc	r13, r19
    bd70:	3c 81       	ldd	r19, Y+4	; 0x04
    bd72:	b5 cf       	rjmp	.-150    	; 0xbcde <PutLine+0xda>
			break;
    bd74:	21 e0       	ldi	r18, 0x01	; 1
    bd76:	01 c0       	rjmp	.+2      	; 0xbd7a <PutLine+0x176>
		case '}':
			while((Char=prc(CurrStr+X - Xs + ++Param.Size))=='}');
    bd78:	23 2f       	mov	r18, r19

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    bd7a:	fc 01       	movw	r30, r24
    bd7c:	e2 0f       	add	r30, r18
    bd7e:	f1 1d       	adc	r31, r1
    bd80:	ee 0d       	add	r30, r14
    bd82:	ff 1d       	adc	r31, r15
    bd84:	14 91       	lpm	r17, Z+
    bd86:	32 2f       	mov	r19, r18
    bd88:	3f 5f       	subi	r19, 0xFF	; 255
    bd8a:	1d 37       	cpi	r17, 0x7D	; 125
    bd8c:	a9 f3       	breq	.-22     	; 0xbd78 <PutLine+0x174>
    bd8e:	2c 83       	std	Y+4, r18	; 0x04
			Y1=Y;
    bd90:	38 89       	ldd	r19, Y+16	; 0x10
    bd92:	30 93 44 0a 	sts	0x0A44, r19
			Param.Prec = prb(&(OF+OF_N)->Prec);
    bd96:	48 2d       	mov	r20, r8
    bd98:	50 e0       	ldi	r21, 0x00	; 0
    bd9a:	42 95       	swap	r20
    bd9c:	52 95       	swap	r21
    bd9e:	50 7f       	andi	r21, 0xF0	; 240
    bda0:	54 27       	eor	r21, r20
    bda2:	40 7f       	andi	r20, 0xF0	; 240
    bda4:	54 27       	eor	r21, r20
    bda6:	8d 85       	ldd	r24, Y+13	; 0x0d
    bda8:	9e 85       	ldd	r25, Y+14	; 0x0e
    bdaa:	48 0f       	add	r20, r24
    bdac:	59 1f       	adc	r21, r25

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    bdae:	41 5f       	subi	r20, 0xF1	; 241
    bdb0:	5f 4f       	sbci	r21, 0xFF	; 255
    bdb2:	fa 01       	movw	r30, r20
    bdb4:	84 91       	lpm	r24, Z+
    bdb6:	4f 50       	subi	r20, 0x0F	; 15
    bdb8:	50 40       	sbci	r21, 0x00	; 0
    bdba:	8b 83       	std	Y+3, r24	; 0x03

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    bdbc:	ca 01       	movw	r24, r20
    bdbe:	0d 96       	adiw	r24, 0x0d	; 13
    bdc0:	fc 01       	movw	r30, r24
    bdc2:	25 91       	lpm	r18, Z+
    bdc4:	34 91       	lpm	r19, Z+
			Param.Txt = prp(&(OF+OF_N)->EnumList);
    bdc6:	3e 83       	std	Y+6, r19	; 0x06
    bdc8:	2d 83       	std	Y+5, r18	; 0x05
			if(LineN==CurrLine && OF_N==CurrField)
    bdca:	80 91 c9 07 	lds	r24, 0x07C9
    bdce:	ff 85       	ldd	r31, Y+15	; 0x0f
    bdd0:	f8 17       	cp	r31, r24
    bdd2:	29 f4       	brne	.+10     	; 0xbdde <PutLine+0x1da>
    bdd4:	80 91 d6 02 	lds	r24, 0x02D6
    bdd8:	88 16       	cp	r8, r24
    bdda:	09 f4       	brne	.+2      	; 0xbdde <PutLine+0x1da>
    bddc:	43 c0       	rjmp	.+134    	; 0xbe64 <PutLine+0x260>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    bdde:	fa 01       	movw	r30, r20
    bde0:	84 91       	lpm	r24, Z+

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    bde2:	31 96       	adiw	r30, 0x01	; 1
    bde4:	65 91       	lpm	r22, Z+
    bde6:	74 91       	lpm	r23, Z+
				}
				else{ 
					PutBuf(prb(&(OF+OF_N)->Type), &Param);
				}			
			else
				PutField(prb(&(OF+OF_N)->Type), prp(&(OF+OF_N)->Var), &Param);
    bde8:	a3 01       	movw	r20, r6
    bdea:	0e 94 7d 5c 	call	0xb8fa	; 0xb8fa <PutField>
    bdee:	3c 81       	ldd	r19, Y+4	; 0x04
			OF_N++;
    bdf0:	83 94       	inc	r8
    bdf2:	75 cf       	rjmp	.-278    	; 0xbcde <PutLine+0xda>
		}
		LCD_Buf[Y][X+=Param.Size] = Char;

	}
	X=X1;
	for(;X<LCDXSz; X++) LCD_Buf[Y][X] = ' ';
    bdf4:	f3 e1       	ldi	r31, 0x13	; 19
    bdf6:	f9 15       	cp	r31, r9
    bdf8:	e0 f0       	brcs	.+56     	; 0xbe32 <PutLine+0x22e>
    bdfa:	88 89       	ldd	r24, Y+16	; 0x10
    bdfc:	28 2f       	mov	r18, r24
    bdfe:	30 e0       	ldi	r19, 0x00	; 0
    be00:	49 2d       	mov	r20, r9
    be02:	c9 01       	movw	r24, r18
    be04:	88 0f       	add	r24, r24
    be06:	99 1f       	adc	r25, r25
    be08:	82 0f       	add	r24, r18
    be0a:	93 1f       	adc	r25, r19
    be0c:	9c 01       	movw	r18, r24
    be0e:	22 0f       	add	r18, r18
    be10:	33 1f       	adc	r19, r19
    be12:	22 0f       	add	r18, r18
    be14:	33 1f       	adc	r19, r19
    be16:	22 0f       	add	r18, r18
    be18:	33 1f       	adc	r19, r19
    be1a:	28 1b       	sub	r18, r24
    be1c:	39 0b       	sbc	r19, r25
    be1e:	80 e2       	ldi	r24, 0x20	; 32
    be20:	f9 01       	movw	r30, r18
    be22:	e4 0f       	add	r30, r20
    be24:	f1 1d       	adc	r31, r1
    be26:	e8 5a       	subi	r30, 0xA8	; 168
    be28:	f9 4f       	sbci	r31, 0xF9	; 249
    be2a:	80 83       	st	Z, r24
    be2c:	4f 5f       	subi	r20, 0xFF	; 255
    be2e:	44 31       	cpi	r20, 0x14	; 20
    be30:	b8 f3       	brcs	.-18     	; 0xbe20 <PutLine+0x21c>

}
    be32:	60 96       	adiw	r28, 0x10	; 16
    be34:	0f b6       	in	r0, 0x3f	; 63
    be36:	f8 94       	cli
    be38:	de bf       	out	0x3e, r29	; 62
    be3a:	0f be       	out	0x3f, r0	; 63
    be3c:	cd bf       	out	0x3d, r28	; 61
    be3e:	cf 91       	pop	r28
    be40:	df 91       	pop	r29
    be42:	1f 91       	pop	r17
    be44:	0f 91       	pop	r16
    be46:	ff 90       	pop	r15
    be48:	ef 90       	pop	r14
    be4a:	df 90       	pop	r13
    be4c:	cf 90       	pop	r12
    be4e:	bf 90       	pop	r11
    be50:	af 90       	pop	r10
    be52:	9f 90       	pop	r9
    be54:	8f 90       	pop	r8
    be56:	7f 90       	pop	r7
    be58:	6f 90       	pop	r6
    be5a:	5f 90       	pop	r5
    be5c:	4f 90       	pop	r4
    be5e:	3f 90       	pop	r3
    be60:	2f 90       	pop	r2
    be62:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    be64:	fa 01       	movw	r30, r20
    be66:	84 91       	lpm	r24, Z+
			Y1=Y;
			Param.Prec = prb(&(OF+OF_N)->Prec);
			Param.Txt = prp(&(OF+OF_N)->EnumList);
			if(LineN==CurrLine && OF_N==CurrField)
				//add new
				if( (prb(&(OF+OF_N)->Type) == Text) || (prb(&(OF+OF_N)->Type) == EE_Text ) ||
    be68:	81 32       	cpi	r24, 0x21	; 33
    be6a:	61 f1       	breq	.+88     	; 0xbec4 <PutLine+0x2c0>
    be6c:	82 32       	cpi	r24, 0x22	; 34
    be6e:	51 f1       	breq	.+84     	; 0xbec4 <PutLine+0x2c0>
    be70:	80 31       	cpi	r24, 0x10	; 16
    be72:	41 f1       	breq	.+80     	; 0xbec4 <PutLine+0x2c0>
    be74:	84 31       	cpi	r24, 0x14	; 20
    be76:	31 f1       	breq	.+76     	; 0xbec4 <PutLine+0x2c0>
    be78:	81 31       	cpi	r24, 0x11	; 17
    be7a:	21 f1       	breq	.+72     	; 0xbec4 <PutLine+0x2c0>
    be7c:	85 31       	cpi	r24, 0x15	; 21
    be7e:	11 f1       	breq	.+68     	; 0xbec4 <PutLine+0x2c0>
    be80:	82 31       	cpi	r24, 0x12	; 18
    be82:	01 f1       	breq	.+64     	; 0xbec4 <PutLine+0x2c0>
    be84:	83 31       	cpi	r24, 0x13	; 19
    be86:	f1 f0       	breq	.+60     	; 0xbec4 <PutLine+0x2c0>
    be88:	89 31       	cpi	r24, 0x19	; 25
    be8a:	e1 f0       	breq	.+56     	; 0xbec4 <PutLine+0x2c0>
    be8c:	8b 31       	cpi	r24, 0x1B	; 27
    be8e:	d1 f0       	breq	.+52     	; 0xbec4 <PutLine+0x2c0>
    be90:	8a 31       	cpi	r24, 0x1A	; 26
    be92:	c1 f0       	breq	.+48     	; 0xbec4 <PutLine+0x2c0>
    be94:	8c 31       	cpi	r24, 0x1C	; 28
    be96:	b1 f0       	breq	.+44     	; 0xbec4 <PutLine+0x2c0>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
PutBuf(uint8_t Type, T_Param *Param)
{
	switch(Type) {
    be98:	89 30       	cpi	r24, 0x09	; 9
    be9a:	08 f0       	brcs	.+2      	; 0xbe9e <PutLine+0x29a>
    be9c:	b7 c0       	rjmp	.+366    	; 0xc00c <PutLine+0x408>
    be9e:	87 30       	cpi	r24, 0x07	; 7
    bea0:	08 f0       	brcs	.+2      	; 0xbea4 <PutLine+0x2a0>
    bea2:	b9 c0       	rjmp	.+370    	; 0xc016 <PutLine+0x412>
    bea4:	84 30       	cpi	r24, 0x04	; 4
    bea6:	08 f0       	brcs	.+2      	; 0xbeaa <PutLine+0x2a6>
    bea8:	e5 c0       	rjmp	.+458    	; 0xc074 <PutLine+0x470>
    beaa:	82 30       	cpi	r24, 0x02	; 2
    beac:	08 f4       	brcc	.+2      	; 0xbeb0 <PutLine+0x2ac>
    beae:	b3 c0       	rjmp	.+358    	; 0xc016 <PutLine+0x412>
		Put_bVal(Param);
		PosBlink(Param,' ');
		break;
	case s_Byte: case s_EE_Byte:
	case s_Word: case s_EE_Word:
		Put_sbVal(Param);
    beb0:	c3 01       	movw	r24, r6
    beb2:	0e 94 55 42 	call	0x84aa	; 0x84aa <Put_sbVal>
		PosBlink(Param,' ');
    beb6:	c3 01       	movw	r24, r6
    beb8:	60 e2       	ldi	r22, 0x20	; 32
    beba:	0e 94 d8 3d 	call	0x7bb0	; 0x7bb0 <PosBlink>
    bebe:	3c 81       	ldd	r19, Y+4	; 0x04
				else{ 
					PutBuf(prb(&(OF+OF_N)->Type), &Param);
				}			
			else
				PutField(prb(&(OF+OF_N)->Type), prp(&(OF+OF_N)->Var), &Param);
			OF_N++;
    bec0:	83 94       	inc	r8
    bec2:	0d cf       	rjmp	.-486    	; 0xbcde <PutLine+0xda>
// When use BufStr for variable edit
inline static void
PutBufStr(uint8_t Type, T_Param *Param)
{	
	char Format[6];
	sprintf(Format,"%%.%us", Param->Size);
    bec4:	00 d0       	rcall	.+0      	; 0xbec6 <PutLine+0x2c2>
    bec6:	00 d0       	rcall	.+0      	; 0xbec8 <PutLine+0x2c4>
    bec8:	ed b7       	in	r30, 0x3d	; 61
    beca:	fe b7       	in	r31, 0x3e	; 62
    becc:	31 96       	adiw	r30, 0x01	; 1
    bece:	27 e0       	ldi	r18, 0x07	; 7
    bed0:	30 e0       	ldi	r19, 0x00	; 0
    bed2:	2c 0f       	add	r18, r28
    bed4:	3d 1f       	adc	r19, r29
    bed6:	ad b7       	in	r26, 0x3d	; 61
    bed8:	be b7       	in	r27, 0x3e	; 62
    beda:	12 96       	adiw	r26, 0x02	; 2
    bedc:	3c 93       	st	X, r19
    bede:	2e 93       	st	-X, r18
    bee0:	11 97       	sbiw	r26, 0x01	; 1
    bee2:	8b ea       	ldi	r24, 0xAB	; 171
    bee4:	92 e0       	ldi	r25, 0x02	; 2
    bee6:	93 83       	std	Z+3, r25	; 0x03
    bee8:	82 83       	std	Z+2, r24	; 0x02
    beea:	8c 81       	ldd	r24, Y+4	; 0x04
    beec:	84 83       	std	Z+4, r24	; 0x04
    beee:	15 82       	std	Z+5, r1	; 0x05
    bef0:	0e 94 e9 81 	call	0x103d2	; 0x103d2 <sprintf>
	sprintf(Param->Pos, Format, BufStr);
    bef4:	ed b7       	in	r30, 0x3d	; 61
    bef6:	fe b7       	in	r31, 0x3e	; 62
    bef8:	31 96       	adiw	r30, 0x01	; 1
    befa:	89 81       	ldd	r24, Y+1	; 0x01
    befc:	9a 81       	ldd	r25, Y+2	; 0x02
    befe:	ad b7       	in	r26, 0x3d	; 61
    bf00:	be b7       	in	r27, 0x3e	; 62
    bf02:	12 96       	adiw	r26, 0x02	; 2
    bf04:	9c 93       	st	X, r25
    bf06:	8e 93       	st	-X, r24
    bf08:	11 97       	sbiw	r26, 0x01	; 1
    bf0a:	27 e0       	ldi	r18, 0x07	; 7
    bf0c:	30 e0       	ldi	r19, 0x00	; 0
    bf0e:	2c 0f       	add	r18, r28
    bf10:	3d 1f       	adc	r19, r29
    bf12:	33 83       	std	Z+3, r19	; 0x03
    bf14:	22 83       	std	Z+2, r18	; 0x02
    bf16:	83 ec       	ldi	r24, 0xC3	; 195
    bf18:	95 e0       	ldi	r25, 0x05	; 5
    bf1a:	95 83       	std	Z+5, r25	; 0x05
    bf1c:	84 83       	std	Z+4, r24	; 0x04
    bf1e:	0e 94 e9 81 	call	0x103d2	; 0x103d2 <sprintf>
	Param->Prec = 0;
    bf22:	1b 82       	std	Y+3, r1	; 0x03
	PosBlink(Param,'_');
    bf24:	ad b7       	in	r26, 0x3d	; 61
    bf26:	be b7       	in	r27, 0x3e	; 62
    bf28:	16 96       	adiw	r26, 0x06	; 6
    bf2a:	0f b6       	in	r0, 0x3f	; 63
    bf2c:	f8 94       	cli
    bf2e:	be bf       	out	0x3e, r27	; 62
    bf30:	0f be       	out	0x3f, r0	; 63
    bf32:	ad bf       	out	0x3d, r26	; 61
    bf34:	c3 01       	movw	r24, r6
    bf36:	6f e5       	ldi	r22, 0x5F	; 95
    bf38:	0e 94 d8 3d 	call	0x7bb0	; 0x7bb0 <PosBlink>
    bf3c:	3c 81       	ldd	r19, Y+4	; 0x04
				else{ 
					PutBuf(prb(&(OF+OF_N)->Type), &Param);
				}			
			else
				PutField(prb(&(OF+OF_N)->Type), prp(&(OF+OF_N)->Var), &Param);
			OF_N++;
    bf3e:	83 94       	inc	r8
    bf40:	ce ce       	rjmp	.-612    	; 0xbcde <PutLine+0xda>

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    bf42:	08 94       	sec
    bf44:	e1 1c       	adc	r14, r1
    bf46:	f1 1c       	adc	r15, r1
    bf48:	f7 01       	movw	r30, r14
    bf4a:	84 91       	lpm	r24, Z+
    bf4c:	08 94       	sec
    bf4e:	e1 08       	sbc	r14, r1
    bf50:	f1 08       	sbc	r15, r1
		X1 = strlen_P(CurrStr) - 2;
		X0 = 0;
		Xs = X0-2;
	}
	//--- "<>" Align center
	if(prc(CurrStr+0) == '<' && prc(CurrStr+1) == '>'){
    bf52:	8e 33       	cpi	r24, 0x3E	; 62
    bf54:	09 f0       	breq	.+2      	; 0xbf58 <PutLine+0x354>
    bf56:	9f ce       	rjmp	.-706    	; 0xbc96 <PutLine+0x92>
		X0 = (LCDXSz - strlen_P(CurrStr) + 2) / 2;
    bf58:	8b 2d       	mov	r24, r11
    bf5a:	9a 2d       	mov	r25, r10
    bf5c:	0e 94 fd 80 	call	0x101fa	; 0x101fa <strlen_P>
    bf60:	26 e1       	ldi	r18, 0x16	; 22
    bf62:	30 e0       	ldi	r19, 0x00	; 0
    bf64:	28 1b       	sub	r18, r24
    bf66:	39 0b       	sbc	r19, r25
    bf68:	36 95       	lsr	r19
    bf6a:	27 95       	ror	r18
    bf6c:	42 2f       	mov	r20, r18
		Xs = X0-2;
    bf6e:	52 2f       	mov	r21, r18
    bf70:	52 50       	subi	r21, 0x02	; 2
		X1 = X0 + (strlen_P(CurrStr) - 2);
    bf72:	be ef       	ldi	r27, 0xFE	; 254
    bf74:	9b 2e       	mov	r9, r27
    bf76:	98 0e       	add	r9, r24
    bf78:	92 0e       	add	r9, r18
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';		
    bf7a:	22 23       	and	r18, r18
    bf7c:	09 f4       	brne	.+2      	; 0xbf80 <PutLine+0x37c>
    bf7e:	8b ce       	rjmp	.-746    	; 0xbc96 <PutLine+0x92>
    bf80:	85 e1       	ldi	r24, 0x15	; 21
    bf82:	28 89       	ldd	r18, Y+16	; 0x10
    bf84:	28 9f       	mul	r18, r24
    bf86:	f0 01       	movw	r30, r0
    bf88:	11 24       	eor	r1, r1
    bf8a:	e8 5a       	subi	r30, 0xA8	; 168
    bf8c:	f9 4f       	sbci	r31, 0xF9	; 249
    bf8e:	80 e0       	ldi	r24, 0x00	; 0
    bf90:	90 e2       	ldi	r25, 0x20	; 32
    bf92:	91 93       	st	Z+, r25
    bf94:	8f 5f       	subi	r24, 0xFF	; 255
    bf96:	84 17       	cp	r24, r20
    bf98:	e0 f3       	brcs	.-8      	; 0xbf92 <PutLine+0x38e>
    bf9a:	7d ce       	rjmp	.-774    	; 0xbc96 <PutLine+0x92>
    bf9c:	08 94       	sec
    bf9e:	e1 1c       	adc	r14, r1
    bfa0:	f1 1c       	adc	r15, r1
    bfa2:	f7 01       	movw	r30, r14
    bfa4:	84 91       	lpm	r24, Z+
    bfa6:	08 94       	sec
    bfa8:	e1 08       	sbc	r14, r1
    bfaa:	f1 08       	sbc	r15, r1
		X0 = LCDXSz - strlen_P(CurrStr) + 2;
		Xs = X0-2;
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';
	}
	//--- "<<" Align left
	if(prc(CurrStr+0) == '<' && prc(CurrStr+1) == '<'){
    bfac:	8c 33       	cpi	r24, 0x3C	; 60
    bfae:	09 f0       	breq	.+2      	; 0xbfb2 <PutLine+0x3ae>
    bfb0:	6b ce       	rjmp	.-810    	; 0xbc88 <PutLine+0x84>
		X1 = strlen_P(CurrStr) - 2;
    bfb2:	8b 2d       	mov	r24, r11
    bfb4:	9a 2d       	mov	r25, r10
    bfb6:	0e 94 fd 80 	call	0x101fa	; 0x101fa <strlen_P>
    bfba:	9e ef       	ldi	r25, 0xFE	; 254
    bfbc:	99 2e       	mov	r9, r25
    bfbe:	98 0e       	add	r9, r24
    bfc0:	40 e0       	ldi	r20, 0x00	; 0
    bfc2:	5e ef       	ldi	r21, 0xFE	; 254
    bfc4:	63 ce       	rjmp	.-826    	; 0xbc8c <PutLine+0x88>
    bfc6:	08 94       	sec
    bfc8:	e1 1c       	adc	r14, r1
    bfca:	f1 1c       	adc	r15, r1
    bfcc:	f7 01       	movw	r30, r14
    bfce:	84 91       	lpm	r24, Z+
    bfd0:	08 94       	sec
    bfd2:	e1 08       	sbc	r14, r1
    bfd4:	f1 08       	sbc	r15, r1
	uint8_t X;
	uint8_t X0=0;
	uint8_t X1=LCDXSz;
	int8_t Xs = 0;
	//--- ">>" Align right
	if(prc(CurrStr+0) == '>' && prc(CurrStr+1) == '>'){
    bfd6:	8e 33       	cpi	r24, 0x3E	; 62
    bfd8:	09 f0       	breq	.+2      	; 0xbfdc <PutLine+0x3d8>
    bfda:	4f ce       	rjmp	.-866    	; 0xbc7a <PutLine+0x76>
		X0 = LCDXSz - strlen_P(CurrStr) + 2;
    bfdc:	c7 01       	movw	r24, r14
    bfde:	0e 94 fd 80 	call	0x101fa	; 0x101fa <strlen_P>
    bfe2:	46 e1       	ldi	r20, 0x16	; 22
    bfe4:	48 1b       	sub	r20, r24
		Xs = X0-2;
    bfe6:	54 2f       	mov	r21, r20
    bfe8:	52 50       	subi	r21, 0x02	; 2
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';
    bfea:	44 23       	and	r20, r20
    bfec:	09 f4       	brne	.+2      	; 0xbff0 <PutLine+0x3ec>
    bfee:	47 ce       	rjmp	.-882    	; 0xbc7e <PutLine+0x7a>
    bff0:	85 e1       	ldi	r24, 0x15	; 21
    bff2:	28 89       	ldd	r18, Y+16	; 0x10
    bff4:	28 9f       	mul	r18, r24
    bff6:	f0 01       	movw	r30, r0
    bff8:	11 24       	eor	r1, r1
    bffa:	e8 5a       	subi	r30, 0xA8	; 168
    bffc:	f9 4f       	sbci	r31, 0xF9	; 249
    bffe:	80 e0       	ldi	r24, 0x00	; 0
    c000:	90 e2       	ldi	r25, 0x20	; 32
    c002:	91 93       	st	Z+, r25
    c004:	8f 5f       	subi	r24, 0xFF	; 255
    c006:	84 17       	cp	r24, r20
    c008:	e0 f3       	brcs	.-8      	; 0xc002 <PutLine+0x3fe>
    c00a:	39 ce       	rjmp	.-910    	; 0xbc7e <PutLine+0x7a>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
PutBuf(uint8_t Type, T_Param *Param)
{
	switch(Type) {
    c00c:	8d 30       	cpi	r24, 0x0D	; 13
    c00e:	68 f4       	brcc	.+26     	; 0xc02a <PutLine+0x426>
    c010:	8b 30       	cpi	r24, 0x0B	; 11
    c012:	08 f4       	brcc	.+2      	; 0xc016 <PutLine+0x412>
    c014:	4d cf       	rjmp	.-358    	; 0xbeb0 <PutLine+0x2ac>
	case Byte: case EE_Byte: case z_Byte: case z_EE_Byte:
	case Word: case EE_Word: case z_Word: case z_EE_Word:
		Put_bVal(Param);
    c016:	c3 01       	movw	r24, r6
    c018:	0e 94 53 43 	call	0x86a6	; 0x86a6 <Put_bVal>
		PosBlink(Param,' ');
    c01c:	c3 01       	movw	r24, r6
    c01e:	60 e2       	ldi	r22, 0x20	; 32
    c020:	0e 94 d8 3d 	call	0x7bb0	; 0x7bb0 <PosBlink>
    c024:	3c 81       	ldd	r19, Y+4	; 0x04
				else{ 
					PutBuf(prb(&(OF+OF_N)->Type), &Param);
				}			
			else
				PutField(prb(&(OF+OF_N)->Type), prp(&(OF+OF_N)->Var), &Param);
			OF_N++;
    c026:	83 94       	inc	r8
    c028:	5a ce       	rjmp	.-844    	; 0xbcde <PutLine+0xda>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
PutBuf(uint8_t Type, T_Param *Param)
{
	switch(Type) {
    c02a:	8e 30       	cpi	r24, 0x0E	; 14
    c02c:	b9 f1       	breq	.+110    	; 0xc09c <PutLine+0x498>
    c02e:	8e 30       	cpi	r24, 0x0E	; 14
    c030:	28 f1       	brcs	.+74     	; 0xc07c <PutLine+0x478>
    c032:	8d 51       	subi	r24, 0x1D	; 29
    c034:	84 30       	cpi	r24, 0x04	; 4
    c036:	08 f0       	brcs	.+2      	; 0xc03a <PutLine+0x436>
    c038:	da ce       	rjmp	.-588    	; 0xbdee <PutLine+0x1ea>
	case zc_Word:
		Put_zVal(F_Buf, 'w', Param);
		ValBlink(Param->Pos, Param->Size);
		break;
	case Enum: case EE_Enum: case Bit: case EE_Bit:
		Param->Txt += (uint8_t)F_Buf;
    c03a:	80 91 f7 04 	lds	r24, 0x04F7
    c03e:	90 e0       	ldi	r25, 0x00	; 0
    c040:	88 0f       	add	r24, r24
    c042:	99 1f       	adc	r25, r25
    c044:	28 0f       	add	r18, r24
    c046:	39 1f       	adc	r19, r25
    c048:	3e 83       	std	Y+6, r19	; 0x06
    c04a:	2d 83       	std	Y+5, r18	; 0x05
		PutEnum(Param);
    c04c:	c3 01       	movw	r24, r6
    c04e:	0e 94 24 42 	call	0x8448	; 0x8448 <PutEnum>
		ValBlink(Param->Pos, Param->Size);
    c052:	3c 81       	ldd	r19, Y+4	; 0x04

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
ValBlink(char *Pos, uint8_t Sz)
{
	CurrX=Pos-LCD_Buf[Y1];
    c054:	80 91 44 0a 	lds	r24, 0x0A44
    c058:	f5 e1       	ldi	r31, 0x15	; 21
    c05a:	8f 9f       	mul	r24, r31
    c05c:	c0 01       	movw	r24, r0
    c05e:	11 24       	eor	r1, r1
    c060:	88 5a       	subi	r24, 0xA8	; 168
    c062:	99 4f       	sbci	r25, 0xF9	; 249
    c064:	29 81       	ldd	r18, Y+1	; 0x01
    c066:	28 1b       	sub	r18, r24
    c068:	20 93 fa 06 	sts	0x06FA, r18
	StrSize=Sz; 
    c06c:	30 93 ac 06 	sts	0x06AC, r19
				else{ 
					PutBuf(prb(&(OF+OF_N)->Type), &Param);
				}			
			else
				PutField(prb(&(OF+OF_N)->Type), prp(&(OF+OF_N)->Var), &Param);
			OF_N++;
    c070:	83 94       	inc	r8
    c072:	35 ce       	rjmp	.-918    	; 0xbcde <PutLine+0xda>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
PutBuf(uint8_t Type, T_Param *Param)
{
	switch(Type) {
    c074:	86 30       	cpi	r24, 0x06	; 6
    c076:	78 f2       	brcs	.-98     	; 0xc016 <PutLine+0x412>
    c078:	3c 81       	ldd	r19, Y+4	; 0x04
    c07a:	ba ce       	rjmp	.-652    	; 0xbdf0 <PutLine+0x1ec>
	case s_Word: case s_EE_Word:
		Put_sbVal(Param);
		PosBlink(Param,' ');
		break;
	case c_Word:
		PutVal(F_Buf, 'w', Param);
    c07c:	80 91 f7 04 	lds	r24, 0x04F7
    c080:	90 91 f8 04 	lds	r25, 0x04F8
    c084:	67 e7       	ldi	r22, 0x77	; 119
    c086:	a3 01       	movw	r20, r6
    c088:	0e 94 22 4b 	call	0x9644	; 0x9644 <PutVal>
		ValBlink(Param->Pos, Param->Size);
    c08c:	3c 81       	ldd	r19, Y+4	; 0x04

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
ValBlink(char *Pos, uint8_t Sz)
{
	CurrX=Pos-LCD_Buf[Y1];
    c08e:	80 91 44 0a 	lds	r24, 0x0A44
    c092:	b5 e1       	ldi	r27, 0x15	; 21
    c094:	8b 9f       	mul	r24, r27
    c096:	c0 01       	movw	r24, r0
    c098:	11 24       	eor	r1, r1
    c09a:	e2 cf       	rjmp	.-60     	; 0xc060 <PutLine+0x45c>
	case c_Word:
		PutVal(F_Buf, 'w', Param);
		ValBlink(Param->Pos, Param->Size);
		break;
	case zc_Word:
		Put_zVal(F_Buf, 'w', Param);
    c09c:	80 91 f7 04 	lds	r24, 0x04F7
    c0a0:	90 91 f8 04 	lds	r25, 0x04F8
    c0a4:	67 e7       	ldi	r22, 0x77	; 119
    c0a6:	a3 01       	movw	r20, r6
    c0a8:	0e 94 81 49 	call	0x9302	; 0x9302 <Put_zVal>
		ValBlink(Param->Pos, Param->Size);
    c0ac:	3c 81       	ldd	r19, Y+4	; 0x04

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
ValBlink(char *Pos, uint8_t Sz)
{
	CurrX=Pos-LCD_Buf[Y1];
    c0ae:	80 91 44 0a 	lds	r24, 0x0A44
    c0b2:	e5 e1       	ldi	r30, 0x15	; 21
    c0b4:	8e 9f       	mul	r24, r30
    c0b6:	c0 01       	movw	r24, r0
    c0b8:	11 24       	eor	r1, r1
    c0ba:	d2 cf       	rjmp	.-92     	; 0xc060 <PutLine+0x45c>

0000c0bc <MenuOut>:
	while(X<LCDXSz)	LCD_Buf[Y][X++] = ' ';
}
// ~~~~~~~~~~
void
MenuOut(void)
{
    c0bc:	2f 92       	push	r2
    c0be:	3f 92       	push	r3
    c0c0:	4f 92       	push	r4
    c0c2:	5f 92       	push	r5
    c0c4:	6f 92       	push	r6
    c0c6:	7f 92       	push	r7
    c0c8:	8f 92       	push	r8
    c0ca:	9f 92       	push	r9
    c0cc:	af 92       	push	r10
    c0ce:	bf 92       	push	r11
    c0d0:	cf 92       	push	r12
    c0d2:	df 92       	push	r13
    c0d4:	ef 92       	push	r14
    c0d6:	ff 92       	push	r15
    c0d8:	0f 93       	push	r16
    c0da:	1f 93       	push	r17
    c0dc:	df 93       	push	r29
    c0de:	cf 93       	push	r28
    c0e0:	cd b7       	in	r28, 0x3d	; 61
    c0e2:	de b7       	in	r29, 0x3e	; 62
    c0e4:	2a 97       	sbiw	r28, 0x0a	; 10
    c0e6:	0f b6       	in	r0, 0x3f	; 63
    c0e8:	f8 94       	cli
    c0ea:	de bf       	out	0x3e, r29	; 62
    c0ec:	0f be       	out	0x3f, r0	; 63
    c0ee:	cd bf       	out	0x3d, r28	; 61
	uint8_t Y;
	if(CurrMsg) {
    c0f0:	a0 90 f5 04 	lds	r10, 0x04F5
    c0f4:	b0 90 f6 04 	lds	r11, 0x04F6
    c0f8:	a1 14       	cp	r10, r1
    c0fa:	b1 04       	cpc	r11, r1
    c0fc:	09 f4       	brne	.+2      	; 0xc100 <MenuOut+0x44>
    c0fe:	6a c1       	rjmp	.+724    	; 0xc3d4 <MenuOut+0x318>
    c100:	22 24       	eor	r2, r2
    c102:	33 24       	eor	r3, r3
    c104:	18 86       	std	Y+8, r1	; 0x08
    c106:	1f 82       	std	Y+7, r1	; 0x07
	int8_t Xs = 0;
	//--- ">>" Align right
	if(prc(CurrStr+0) == '>' && prc(CurrStr+1) == '>'){
		X0 = LCDXSz - strlen_P(CurrStr) + 2;
		Xs = X0-2;
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';
    c108:	80 e2       	ldi	r24, 0x20	; 32
    c10a:	48 2e       	mov	r4, r24
	#if TypeLCD==840
		const MsgLine *Line=(MsgLine*)prp(&CurrMsg->LineList)+Y;
	#else
		const MsgLine *Line=CurrMsg->LineList+Y;		
	#endif
	PGM_P CurrStr=(PGM_P)(Line->Str);
    c10c:	91 01       	movw	r18, r2
    c10e:	22 0f       	add	r18, r18
    c110:	33 1f       	adc	r19, r19
    c112:	3a 87       	std	Y+10, r19	; 0x0a
    c114:	29 87       	std	Y+9, r18	; 0x09
    c116:	49 01       	movw	r8, r18
    c118:	82 0c       	add	r8, r2
    c11a:	93 1c       	adc	r9, r3
    c11c:	64 01       	movw	r12, r8
    c11e:	cc 0c       	add	r12, r12
    c120:	dd 1c       	adc	r13, r13
    c122:	cc 0c       	add	r12, r12
    c124:	dd 1c       	adc	r13, r13
    c126:	cc 0c       	add	r12, r12
    c128:	dd 1c       	adc	r13, r13
    c12a:	96 01       	movw	r18, r12
    c12c:	22 19       	sub	r18, r2
    c12e:	33 09       	sbc	r19, r3
    c130:	75 01       	movw	r14, r10
    c132:	e2 0e       	add	r14, r18
    c134:	f3 1e       	adc	r15, r19

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    c136:	2b 5e       	subi	r18, 0xEB	; 235
    c138:	3f 4f       	sbci	r19, 0xFF	; 255
    c13a:	c5 01       	movw	r24, r10
    c13c:	82 0f       	add	r24, r18
    c13e:	93 1f       	adc	r25, r19
    c140:	25 51       	subi	r18, 0x15	; 21
    c142:	30 40       	sbci	r19, 0x00	; 0
    c144:	fc 01       	movw	r30, r24
    c146:	65 90       	lpm	r6, Z+
    c148:	74 90       	lpm	r7, Z+

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    c14a:	f7 01       	movw	r30, r14
    c14c:	84 91       	lpm	r24, Z+
	uint8_t X;
	uint8_t X0=0;
	uint8_t X1=LCDXSz;
	int8_t Xs = 0;
	//--- ">>" Align right
	if(prc(CurrStr+0) == '>' && prc(CurrStr+1) == '>'){
    c14e:	8e 33       	cpi	r24, 0x3E	; 62
    c150:	09 f4       	brne	.+2      	; 0xc154 <MenuOut+0x98>
    c152:	b3 c0       	rjmp	.+358    	; 0xc2ba <MenuOut+0x1fe>
		X0 = LCDXSz - strlen_P(CurrStr) + 2;
		Xs = X0-2;
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';
    c154:	90 e0       	ldi	r25, 0x00	; 0
    c156:	00 e0       	ldi	r16, 0x00	; 0
    c158:	f7 01       	movw	r30, r14
    c15a:	84 91       	lpm	r24, Z+
	}
	//--- "<<" Align left
	if(prc(CurrStr+0) == '<' && prc(CurrStr+1) == '<'){
    c15c:	8c 33       	cpi	r24, 0x3C	; 60
    c15e:	09 f4       	brne	.+2      	; 0xc162 <MenuOut+0xa6>
    c160:	cd c0       	rjmp	.+410    	; 0xc2fc <MenuOut+0x240>
		X1 = strlen_P(CurrStr) - 2;
    c162:	f4 e1       	ldi	r31, 0x14	; 20
    c164:	5f 2e       	mov	r5, r31
    c166:	f7 01       	movw	r30, r14
    c168:	84 91       	lpm	r24, Z+
		X0 = 0;
		Xs = X0-2;
	}
	//--- "<>" Align center
	if(prc(CurrStr+0) == '<' && prc(CurrStr+1) == '>'){
    c16a:	8c 33       	cpi	r24, 0x3C	; 60
    c16c:	09 f4       	brne	.+2      	; 0xc170 <MenuOut+0xb4>
    c16e:	e6 c0       	rjmp	.+460    	; 0xc33c <MenuOut+0x280>
		X1 = X0 + (strlen_P(CurrStr) - 2);
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';		
	}
	//---

	for(X=X0; X<X1; X++){
    c170:	05 15       	cp	r16, r5
    c172:	08 f0       	brcs	.+2      	; 0xc176 <MenuOut+0xba>
    c174:	73 c0       	rjmp	.+230    	; 0xc25c <MenuOut+0x1a0>
		const MsgLine *Line=(MsgLine*)prp(&CurrMsg->LineList)+Y;
	#else
		const MsgLine *Line=CurrMsg->LineList+Y;		
	#endif
	PGM_P CurrStr=(PGM_P)(Line->Str);
	InField *IF = prp(&Line->IF_List);
    c176:	73 01       	movw	r14, r6
    c178:	69 2e       	mov	r6, r25
    c17a:	77 24       	eor	r7, r7
    c17c:	67 fc       	sbrc	r6, 7
    c17e:	70 94       	com	r7
    c180:	29 85       	ldd	r18, Y+9	; 0x09
    c182:	3a 85       	ldd	r19, Y+10	; 0x0a
    c184:	22 0d       	add	r18, r2
    c186:	33 1d       	adc	r19, r3
    c188:	c9 01       	movw	r24, r18
    c18a:	88 0f       	add	r24, r24
    c18c:	99 1f       	adc	r25, r25
    c18e:	88 0f       	add	r24, r24
    c190:	99 1f       	adc	r25, r25
    c192:	88 0f       	add	r24, r24
    c194:	99 1f       	adc	r25, r25
    c196:	6c 01       	movw	r12, r24
    c198:	c2 18       	sub	r12, r2
    c19a:	d3 08       	sbc	r13, r3
			Param.Txt = prp(&IF->EnumList);
			PutField(prb(&IF->Type), prp(&IF->Var), &Param);
			IF++;
			X += Param.Size;
		}
		LCD_Buf[Y][X] = Char;
    c19c:	4c 01       	movw	r8, r24
    c19e:	82 1a       	sub	r8, r18
    c1a0:	93 0a       	sbc	r9, r19
    c1a2:	09 c0       	rjmp	.+18     	; 0xc1b6 <MenuOut+0xfa>
    c1a4:	a8 0d       	add	r26, r8
    c1a6:	b9 1d       	adc	r27, r9
    c1a8:	a8 5a       	subi	r26, 0xA8	; 168
    c1aa:	b9 4f       	sbci	r27, 0xF9	; 249
    c1ac:	1c 93       	st	X, r17
		X1 = X0 + (strlen_P(CurrStr) - 2);
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';		
	}
	//---

	for(X=X0; X<X1; X++){
    c1ae:	0f 5f       	subi	r16, 0xFF	; 255
    c1b0:	05 15       	cp	r16, r5
    c1b2:	08 f0       	brcs	.+2      	; 0xc1b6 <MenuOut+0xfa>
    c1b4:	4f c0       	rjmp	.+158    	; 0xc254 <MenuOut+0x198>
		char Char;
		if((Char=prc(CurrStr+X-Xs))=='{') {
    c1b6:	a0 2f       	mov	r26, r16
    c1b8:	b0 e0       	ldi	r27, 0x00	; 0
    c1ba:	9d 01       	movw	r18, r26
    c1bc:	26 19       	sub	r18, r6
    c1be:	37 09       	sbc	r19, r7
    c1c0:	f6 01       	movw	r30, r12
    c1c2:	e2 0f       	add	r30, r18
    c1c4:	f3 1f       	adc	r31, r19
    c1c6:	ea 0d       	add	r30, r10
    c1c8:	fb 1d       	adc	r31, r11
    c1ca:	14 91       	lpm	r17, Z+
    c1cc:	1b 37       	cpi	r17, 0x7B	; 123
    c1ce:	51 f7       	brne	.-44     	; 0xc1a4 <MenuOut+0xe8>
			T_Param Param;
			Param.Pos = LCD_Buf[Y]+X;
    c1d0:	8f 81       	ldd	r24, Y+7	; 0x07
    c1d2:	98 85       	ldd	r25, Y+8	; 0x08
    c1d4:	a8 0f       	add	r26, r24
    c1d6:	b9 1f       	adc	r27, r25
    c1d8:	a8 5a       	subi	r26, 0xA8	; 168
    c1da:	b9 4f       	sbci	r27, 0xF9	; 249
    c1dc:	ba 83       	std	Y+2, r27	; 0x02
    c1de:	a9 83       	std	Y+1, r26	; 0x01
    c1e0:	81 e0       	ldi	r24, 0x01	; 1
    c1e2:	f9 01       	movw	r30, r18
    c1e4:	e8 0f       	add	r30, r24
    c1e6:	f1 1d       	adc	r31, r1
    c1e8:	ec 0d       	add	r30, r12
    c1ea:	fd 1d       	adc	r31, r13
    c1ec:	ea 0d       	add	r30, r10
    c1ee:	fb 1d       	adc	r31, r11
    c1f0:	14 91       	lpm	r17, Z+
    c1f2:	98 2f       	mov	r25, r24
    c1f4:	8f 5f       	subi	r24, 0xFF	; 255
			Param.Size = 0;
			while((Char=prc(CurrStr+X-Xs+ ++Param.Size))=='{');
    c1f6:	1b 37       	cpi	r17, 0x7B	; 123
    c1f8:	a1 f3       	breq	.-24     	; 0xc1e2 <MenuOut+0x126>
    c1fa:	9c 83       	std	Y+4, r25	; 0x04

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    c1fc:	e5 e0       	ldi	r30, 0x05	; 5
    c1fe:	f0 e0       	ldi	r31, 0x00	; 0
    c200:	ee 0e       	add	r14, r30
    c202:	ff 1e       	adc	r15, r31
    c204:	f7 01       	movw	r30, r14
    c206:	84 91       	lpm	r24, Z+
    c208:	2b ef       	ldi	r18, 0xFB	; 251
    c20a:	3f ef       	ldi	r19, 0xFF	; 255
    c20c:	e2 0e       	add	r14, r18
    c20e:	f3 1e       	adc	r15, r19
			Param.Prec = prb(&IF->Prec);
    c210:	8b 83       	std	Y+3, r24	; 0x03

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    c212:	f7 01       	movw	r30, r14
    c214:	33 96       	adiw	r30, 0x03	; 3
    c216:	85 91       	lpm	r24, Z+
    c218:	94 91       	lpm	r25, Z+
			Param.Txt = prp(&IF->EnumList);
    c21a:	9e 83       	std	Y+6, r25	; 0x06
    c21c:	8d 83       	std	Y+5, r24	; 0x05

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    c21e:	f7 01       	movw	r30, r14
    c220:	84 91       	lpm	r24, Z+

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    c222:	31 96       	adiw	r30, 0x01	; 1
    c224:	65 91       	lpm	r22, Z+
    c226:	74 91       	lpm	r23, Z+
			PutField(prb(&IF->Type), prp(&IF->Var), &Param);
    c228:	ae 01       	movw	r20, r28
    c22a:	4f 5f       	subi	r20, 0xFF	; 255
    c22c:	5f 4f       	sbci	r21, 0xFF	; 255
    c22e:	0e 94 7d 5c 	call	0xb8fa	; 0xb8fa <PutField>
			IF++;
    c232:	26 e0       	ldi	r18, 0x06	; 6
    c234:	30 e0       	ldi	r19, 0x00	; 0
    c236:	e2 0e       	add	r14, r18
    c238:	f3 1e       	adc	r15, r19
			X += Param.Size;
    c23a:	8c 81       	ldd	r24, Y+4	; 0x04
    c23c:	08 0f       	add	r16, r24
    c23e:	a0 2f       	mov	r26, r16
    c240:	b0 e0       	ldi	r27, 0x00	; 0
		}
		LCD_Buf[Y][X] = Char;
    c242:	a8 0d       	add	r26, r8
    c244:	b9 1d       	adc	r27, r9
    c246:	a8 5a       	subi	r26, 0xA8	; 168
    c248:	b9 4f       	sbci	r27, 0xF9	; 249
    c24a:	1c 93       	st	X, r17
		X1 = X0 + (strlen_P(CurrStr) - 2);
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';		
	}
	//---

	for(X=X0; X<X1; X++){
    c24c:	0f 5f       	subi	r16, 0xFF	; 255
    c24e:	05 15       	cp	r16, r5
    c250:	08 f4       	brcc	.+2      	; 0xc254 <MenuOut+0x198>
    c252:	b1 cf       	rjmp	.-158    	; 0xc1b6 <MenuOut+0xfa>
    c254:	a0 90 f5 04 	lds	r10, 0x04F5
    c258:	b0 90 f6 04 	lds	r11, 0x04F6
			X += Param.Size;
		}
		LCD_Buf[Y][X] = Char;
	}
	X=X1;
	for(;X<LCDXSz; X++) LCD_Buf[Y][X] = ' ';
    c25c:	33 e1       	ldi	r19, 0x13	; 19
    c25e:	35 15       	cp	r19, r5
    c260:	08 f0       	brcs	.+2      	; 0xc264 <MenuOut+0x1a8>
    c262:	9f c0       	rjmp	.+318    	; 0xc3a2 <MenuOut+0x2e6>
    c264:	08 94       	sec
    c266:	21 1c       	adc	r2, r1
    c268:	31 1c       	adc	r3, r1
    c26a:	ef 81       	ldd	r30, Y+7	; 0x07
    c26c:	f8 85       	ldd	r31, Y+8	; 0x08
    c26e:	75 96       	adiw	r30, 0x15	; 21
    c270:	f8 87       	std	Y+8, r31	; 0x08
    c272:	ef 83       	std	Y+7, r30	; 0x07
void
MenuOut(void)
{
	uint8_t Y;
	if(CurrMsg) {
		for(Y=0; Y<LCDYSz; PutMsgLine(Y++));
    c274:	f4 e0       	ldi	r31, 0x04	; 4
    c276:	2f 16       	cp	r2, r31
    c278:	31 04       	cpc	r3, r1
    c27a:	09 f0       	breq	.+2      	; 0xc27e <MenuOut+0x1c2>
    c27c:	47 cf       	rjmp	.-370    	; 0xc10c <MenuOut+0x50>
		EventFunc(&CurrMsg->Run);
    c27e:	c5 01       	movw	r24, r10
    c280:	82 5a       	subi	r24, 0xA2	; 162
    c282:	9f 4f       	sbci	r25, 0xFF	; 255
    c284:	0e 94 44 3d 	call	0x7a88	; 0x7a88 <EventFunc>
	if(prb(&CurrPage->LineNumber)>LCDYSz || Fix<LCDYSz-1 || prp(&(GetLine+CurrLine)->OF_List))
		LCD_Buf[CurrLCD][0] = CharCursor;
	if(++Blink>16)
		Blink=0;
	EventFunc(&CurrPage->Run);
}
    c288:	2a 96       	adiw	r28, 0x0a	; 10
    c28a:	0f b6       	in	r0, 0x3f	; 63
    c28c:	f8 94       	cli
    c28e:	de bf       	out	0x3e, r29	; 62
    c290:	0f be       	out	0x3f, r0	; 63
    c292:	cd bf       	out	0x3d, r28	; 61
    c294:	cf 91       	pop	r28
    c296:	df 91       	pop	r29
    c298:	1f 91       	pop	r17
    c29a:	0f 91       	pop	r16
    c29c:	ff 90       	pop	r15
    c29e:	ef 90       	pop	r14
    c2a0:	df 90       	pop	r13
    c2a2:	cf 90       	pop	r12
    c2a4:	bf 90       	pop	r11
    c2a6:	af 90       	pop	r10
    c2a8:	9f 90       	pop	r9
    c2aa:	8f 90       	pop	r8
    c2ac:	7f 90       	pop	r7
    c2ae:	6f 90       	pop	r6
    c2b0:	5f 90       	pop	r5
    c2b2:	4f 90       	pop	r4
    c2b4:	3f 90       	pop	r3
    c2b6:	2f 90       	pop	r2
    c2b8:	08 95       	ret

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    c2ba:	f9 01       	movw	r30, r18
    c2bc:	31 96       	adiw	r30, 0x01	; 1
    c2be:	ea 0d       	add	r30, r10
    c2c0:	fb 1d       	adc	r31, r11
    c2c2:	e4 91       	lpm	r30, Z+
	uint8_t X;
	uint8_t X0=0;
	uint8_t X1=LCDXSz;
	int8_t Xs = 0;
	//--- ">>" Align right
	if(prc(CurrStr+0) == '>' && prc(CurrStr+1) == '>'){
    c2c4:	ee 33       	cpi	r30, 0x3E	; 62
    c2c6:	09 f0       	breq	.+2      	; 0xc2ca <MenuOut+0x20e>
    c2c8:	45 cf       	rjmp	.-374    	; 0xc154 <MenuOut+0x98>
		X0 = LCDXSz - strlen_P(CurrStr) + 2;
    c2ca:	c7 01       	movw	r24, r14
    c2cc:	0e 94 fd 80 	call	0x101fa	; 0x101fa <strlen_P>
    c2d0:	06 e1       	ldi	r16, 0x16	; 22
    c2d2:	08 1b       	sub	r16, r24
		Xs = X0-2;
    c2d4:	90 2f       	mov	r25, r16
    c2d6:	92 50       	subi	r25, 0x02	; 2
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';
    c2d8:	00 23       	and	r16, r16
    c2da:	09 f4       	brne	.+2      	; 0xc2de <MenuOut+0x222>
    c2dc:	3d cf       	rjmp	.-390    	; 0xc158 <MenuOut+0x9c>
    c2de:	f6 01       	movw	r30, r12
    c2e0:	e8 19       	sub	r30, r8
    c2e2:	f9 09       	sbc	r31, r9
    c2e4:	e8 5a       	subi	r30, 0xA8	; 168
    c2e6:	f9 4f       	sbci	r31, 0xF9	; 249
    c2e8:	80 e0       	ldi	r24, 0x00	; 0
    c2ea:	41 92       	st	Z+, r4
    c2ec:	8f 5f       	subi	r24, 0xFF	; 255
    c2ee:	80 17       	cp	r24, r16
    c2f0:	e0 f3       	brcs	.-8      	; 0xc2ea <MenuOut+0x22e>
    c2f2:	f7 01       	movw	r30, r14
    c2f4:	84 91       	lpm	r24, Z+
	}
	//--- "<<" Align left
	if(prc(CurrStr+0) == '<' && prc(CurrStr+1) == '<'){
    c2f6:	8c 33       	cpi	r24, 0x3C	; 60
    c2f8:	09 f0       	breq	.+2      	; 0xc2fc <MenuOut+0x240>
    c2fa:	33 cf       	rjmp	.-410    	; 0xc162 <MenuOut+0xa6>
    c2fc:	e9 85       	ldd	r30, Y+9	; 0x09
    c2fe:	fa 85       	ldd	r31, Y+10	; 0x0a
    c300:	e2 0d       	add	r30, r2
    c302:	f3 1d       	adc	r31, r3
    c304:	ee 0f       	add	r30, r30
    c306:	ff 1f       	adc	r31, r31
    c308:	ee 0f       	add	r30, r30
    c30a:	ff 1f       	adc	r31, r31
    c30c:	ee 0f       	add	r30, r30
    c30e:	ff 1f       	adc	r31, r31
    c310:	e2 19       	sub	r30, r2
    c312:	f3 09       	sbc	r31, r3
    c314:	31 96       	adiw	r30, 0x01	; 1
    c316:	ea 0d       	add	r30, r10
    c318:	fb 1d       	adc	r31, r11
    c31a:	e4 91       	lpm	r30, Z+
    c31c:	ec 33       	cpi	r30, 0x3C	; 60
    c31e:	09 f0       	breq	.+2      	; 0xc322 <MenuOut+0x266>
    c320:	20 cf       	rjmp	.-448    	; 0xc162 <MenuOut+0xa6>
		X1 = strlen_P(CurrStr) - 2;
    c322:	c7 01       	movw	r24, r14
    c324:	0e 94 fd 80 	call	0x101fa	; 0x101fa <strlen_P>
    c328:	ae ef       	ldi	r26, 0xFE	; 254
    c32a:	5a 2e       	mov	r5, r26
    c32c:	58 0e       	add	r5, r24
    c32e:	9e ef       	ldi	r25, 0xFE	; 254
    c330:	00 e0       	ldi	r16, 0x00	; 0
    c332:	f7 01       	movw	r30, r14
    c334:	84 91       	lpm	r24, Z+
		X0 = 0;
		Xs = X0-2;
	}
	//--- "<>" Align center
	if(prc(CurrStr+0) == '<' && prc(CurrStr+1) == '>'){
    c336:	8c 33       	cpi	r24, 0x3C	; 60
    c338:	09 f0       	breq	.+2      	; 0xc33c <MenuOut+0x280>
    c33a:	1a cf       	rjmp	.-460    	; 0xc170 <MenuOut+0xb4>
    c33c:	89 84       	ldd	r8, Y+9	; 0x09
    c33e:	9a 84       	ldd	r9, Y+10	; 0x0a
    c340:	82 0c       	add	r8, r2
    c342:	93 1c       	adc	r9, r3
    c344:	64 01       	movw	r12, r8
    c346:	cc 0c       	add	r12, r12
    c348:	dd 1c       	adc	r13, r13
    c34a:	cc 0c       	add	r12, r12
    c34c:	dd 1c       	adc	r13, r13
    c34e:	cc 0c       	add	r12, r12
    c350:	dd 1c       	adc	r13, r13
    c352:	f6 01       	movw	r30, r12
    c354:	e2 19       	sub	r30, r2
    c356:	f3 09       	sbc	r31, r3
    c358:	31 96       	adiw	r30, 0x01	; 1
    c35a:	ea 0d       	add	r30, r10
    c35c:	fb 1d       	adc	r31, r11
    c35e:	e4 91       	lpm	r30, Z+
    c360:	ee 33       	cpi	r30, 0x3E	; 62
    c362:	09 f0       	breq	.+2      	; 0xc366 <MenuOut+0x2aa>
    c364:	05 cf       	rjmp	.-502    	; 0xc170 <MenuOut+0xb4>
		X0 = (LCDXSz - strlen_P(CurrStr) + 2) / 2;
    c366:	c7 01       	movw	r24, r14
    c368:	0e 94 fd 80 	call	0x101fa	; 0x101fa <strlen_P>
    c36c:	26 e1       	ldi	r18, 0x16	; 22
    c36e:	30 e0       	ldi	r19, 0x00	; 0
    c370:	28 1b       	sub	r18, r24
    c372:	39 0b       	sbc	r19, r25
    c374:	36 95       	lsr	r19
    c376:	27 95       	ror	r18
    c378:	02 2f       	mov	r16, r18
		Xs = X0-2;
    c37a:	92 2f       	mov	r25, r18
    c37c:	92 50       	subi	r25, 0x02	; 2
		X1 = X0 + (strlen_P(CurrStr) - 2);
    c37e:	6e ef       	ldi	r22, 0xFE	; 254
    c380:	56 2e       	mov	r5, r22
    c382:	58 0e       	add	r5, r24
    c384:	52 0e       	add	r5, r18
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';		
    c386:	22 23       	and	r18, r18
    c388:	09 f4       	brne	.+2      	; 0xc38c <MenuOut+0x2d0>
    c38a:	f2 ce       	rjmp	.-540    	; 0xc170 <MenuOut+0xb4>
    c38c:	f6 01       	movw	r30, r12
    c38e:	e8 19       	sub	r30, r8
    c390:	f9 09       	sbc	r31, r9
    c392:	e8 5a       	subi	r30, 0xA8	; 168
    c394:	f9 4f       	sbci	r31, 0xF9	; 249
    c396:	80 e0       	ldi	r24, 0x00	; 0
    c398:	41 92       	st	Z+, r4
    c39a:	8f 5f       	subi	r24, 0xFF	; 255
    c39c:	80 17       	cp	r24, r16
    c39e:	e0 f3       	brcs	.-8      	; 0xc398 <MenuOut+0x2dc>
    c3a0:	e7 ce       	rjmp	.-562    	; 0xc170 <MenuOut+0xb4>
			X += Param.Size;
		}
		LCD_Buf[Y][X] = Char;
	}
	X=X1;
	for(;X<LCDXSz; X++) LCD_Buf[Y][X] = ' ';
    c3a2:	89 85       	ldd	r24, Y+9	; 0x09
    c3a4:	9a 85       	ldd	r25, Y+10	; 0x0a
    c3a6:	82 0d       	add	r24, r2
    c3a8:	93 1d       	adc	r25, r3
    c3aa:	9c 01       	movw	r18, r24
    c3ac:	22 0f       	add	r18, r18
    c3ae:	33 1f       	adc	r19, r19
    c3b0:	22 0f       	add	r18, r18
    c3b2:	33 1f       	adc	r19, r19
    c3b4:	22 0f       	add	r18, r18
    c3b6:	33 1f       	adc	r19, r19
    c3b8:	28 1b       	sub	r18, r24
    c3ba:	39 0b       	sbc	r19, r25
    c3bc:	f9 01       	movw	r30, r18
    c3be:	e5 0d       	add	r30, r5
    c3c0:	f1 1d       	adc	r31, r1
    c3c2:	e8 5a       	subi	r30, 0xA8	; 168
    c3c4:	f9 4f       	sbci	r31, 0xF9	; 249
    c3c6:	40 82       	st	Z, r4
    c3c8:	53 94       	inc	r5
    c3ca:	83 e1       	ldi	r24, 0x13	; 19
    c3cc:	85 15       	cp	r24, r5
    c3ce:	08 f4       	brcc	.+2      	; 0xc3d2 <MenuOut+0x316>
    c3d0:	49 cf       	rjmp	.-366    	; 0xc264 <MenuOut+0x1a8>
    c3d2:	f4 cf       	rjmp	.-24     	; 0xc3bc <MenuOut+0x300>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    c3d4:	40 91 d4 02 	lds	r20, 0x02D4
    c3d8:	50 91 d5 02 	lds	r21, 0x02D5
    c3dc:	4d 5f       	subi	r20, 0xFD	; 253
    c3de:	5f 4f       	sbci	r21, 0xFF	; 255
    c3e0:	fa 01       	movw	r30, r20
    c3e2:	e4 90       	lpm	r14, Z+
    c3e4:	43 50       	subi	r20, 0x03	; 3
    c3e6:	50 40       	sbci	r21, 0x00	; 0
		for(Y=0; Y<LCDYSz; PutMsgLine(Y++));
		EventFunc(&CurrMsg->Run);
		return;
	}
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
    c3e8:	c0 90 c9 07 	lds	r12, 0x07C9
    c3ec:	d0 90 e7 08 	lds	r13, 0x08E7
	for(Y=0; Y<Fix; Y++)
    c3f0:	ee 20       	and	r14, r14
    c3f2:	09 f4       	brne	.+2      	; 0xc3f6 <MenuOut+0x33a>
    c3f4:	a6 c0       	rjmp	.+332    	; 0xc542 <MenuOut+0x486>
    c3f6:	00 e0       	ldi	r16, 0x00	; 0
    c3f8:	10 e0       	ldi	r17, 0x00	; 0
// ~~~~~~~~~~~~~~~~~~
inline static void
PutBlankLine(uint8_t Y)
{
	uint8_t X=0;
	while(X<LCDXSz)	LCD_Buf[Y][X++] = ' ';
    c3fa:	80 e2       	ldi	r24, 0x20	; 32
    c3fc:	f8 2e       	mov	r15, r24
    c3fe:	4e 5f       	subi	r20, 0xFE	; 254
    c400:	5f 4f       	sbci	r21, 0xFF	; 255
    c402:	fa 01       	movw	r30, r20
    c404:	84 91       	lpm	r24, Z+
    c406:	42 50       	subi	r20, 0x02	; 2
    c408:	50 40       	sbci	r21, 0x00	; 0
		return;
	}
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
    c40a:	08 17       	cp	r16, r24
    c40c:	08 f4       	brcc	.+2      	; 0xc410 <MenuOut+0x354>
    c40e:	69 c0       	rjmp	.+210    	; 0xc4e2 <MenuOut+0x426>
    c410:	c8 01       	movw	r24, r16
    c412:	88 0f       	add	r24, r24
    c414:	99 1f       	adc	r25, r25
    c416:	80 0f       	add	r24, r16
    c418:	91 1f       	adc	r25, r17
    c41a:	fc 01       	movw	r30, r24
    c41c:	ee 0f       	add	r30, r30
    c41e:	ff 1f       	adc	r31, r31
    c420:	ee 0f       	add	r30, r30
    c422:	ff 1f       	adc	r31, r31
    c424:	ee 0f       	add	r30, r30
    c426:	ff 1f       	adc	r31, r31
    c428:	e8 1b       	sub	r30, r24
    c42a:	f9 0b       	sbc	r31, r25
    c42c:	e8 5a       	subi	r30, 0xA8	; 168
    c42e:	f9 4f       	sbci	r31, 0xF9	; 249
    c430:	80 e0       	ldi	r24, 0x00	; 0
// ~~~~~~~~~~~~~~~~~~
inline static void
PutBlankLine(uint8_t Y)
{
	uint8_t X=0;
	while(X<LCDXSz)	LCD_Buf[Y][X++] = ' ';
    c432:	f1 92       	st	Z+, r15
    c434:	8f 5f       	subi	r24, 0xFF	; 255
    c436:	84 31       	cpi	r24, 0x14	; 20
    c438:	e1 f7       	brne	.-8      	; 0xc432 <MenuOut+0x376>
	}
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Y, Y);
    c43a:	0f 5f       	subi	r16, 0xFF	; 255
    c43c:	1f 4f       	sbci	r17, 0xFF	; 255
		EventFunc(&CurrMsg->Run);
		return;
	}
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
    c43e:	0e 15       	cp	r16, r14
    c440:	f0 f2       	brcs	.-68     	; 0xc3fe <MenuOut+0x342>
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Y, Y);
	for(; Y<LCDYSz; Y++)
    c442:	f3 e0       	ldi	r31, 0x03	; 3
    c444:	fe 15       	cp	r31, r14
    c446:	f0 f0       	brcs	.+60     	; 0xc484 <MenuOut+0x3c8>
    c448:	1e 2d       	mov	r17, r14
		EventFunc(&CurrMsg->Run);
		return;
	}
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
    c44a:	fc 2c       	mov	r15, r12
    c44c:	fd 18       	sub	r15, r13
    c44e:	f1 0e       	add	r15, r17
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Y, Y);
	for(; Y<LCDYSz; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
    c450:	95 e1       	ldi	r25, 0x15	; 21
    c452:	d9 2e       	mov	r13, r25
// ~~~~~~~~~~~~~~~~~~
inline static void
PutBlankLine(uint8_t Y)
{
	uint8_t X=0;
	while(X<LCDXSz)	LCD_Buf[Y][X++] = ' ';
    c454:	00 e2       	ldi	r16, 0x20	; 32
    c456:	4e 5f       	subi	r20, 0xFE	; 254
    c458:	5f 4f       	sbci	r21, 0xFF	; 255
    c45a:	fa 01       	movw	r30, r20
    c45c:	84 91       	lpm	r24, Z+
    c45e:	42 50       	subi	r20, 0x02	; 2
    c460:	50 40       	sbci	r21, 0x00	; 0
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Y, Y);
	for(; Y<LCDYSz; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
    c462:	18 17       	cp	r17, r24
    c464:	08 f4       	brcc	.+2      	; 0xc468 <MenuOut+0x3ac>
    c466:	4b c0       	rjmp	.+150    	; 0xc4fe <MenuOut+0x442>
    c468:	1d 9d       	mul	r17, r13
    c46a:	f0 01       	movw	r30, r0
    c46c:	11 24       	eor	r1, r1
    c46e:	e8 5a       	subi	r30, 0xA8	; 168
    c470:	f9 4f       	sbci	r31, 0xF9	; 249
    c472:	80 e0       	ldi	r24, 0x00	; 0
// ~~~~~~~~~~~~~~~~~~
inline static void
PutBlankLine(uint8_t Y)
{
	uint8_t X=0;
	while(X<LCDXSz)	LCD_Buf[Y][X++] = ' ';
    c474:	01 93       	st	Z+, r16
    c476:	8f 5f       	subi	r24, 0xFF	; 255
    c478:	84 31       	cpi	r24, 0x14	; 20
    c47a:	e1 f7       	brne	.-8      	; 0xc474 <MenuOut+0x3b8>
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Y, Y);
	for(; Y<LCDYSz; Y++)
    c47c:	1f 5f       	subi	r17, 0xFF	; 255
    c47e:	f3 94       	inc	r15
    c480:	14 30       	cpi	r17, 0x04	; 4
    c482:	48 f3       	brcs	.-46     	; 0xc456 <MenuOut+0x39a>
    c484:	4e 5f       	subi	r20, 0xFE	; 254
    c486:	5f 4f       	sbci	r21, 0xFF	; 255
    c488:	fa 01       	movw	r30, r20
    c48a:	84 91       	lpm	r24, Z+
    c48c:	42 50       	subi	r20, 0x02	; 2
    c48e:	50 40       	sbci	r21, 0x00	; 0
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Dist+Y, Y);
	if(prb(&CurrPage->LineNumber)>LCDYSz || Fix<LCDYSz-1 || prp(&(GetLine+CurrLine)->OF_List))
    c490:	85 30       	cpi	r24, 0x05	; 5
    c492:	20 f4       	brcc	.+8      	; 0xc49c <MenuOut+0x3e0>
    c494:	f2 e0       	ldi	r31, 0x02	; 2
    c496:	fe 15       	cp	r31, r14
    c498:	08 f4       	brcc	.+2      	; 0xc49c <MenuOut+0x3e0>
    c49a:	3f c0       	rjmp	.+126    	; 0xc51a <MenuOut+0x45e>
		LCD_Buf[CurrLCD][0] = CharCursor;
    c49c:	80 91 e7 08 	lds	r24, 0x08E7
    c4a0:	90 e0       	ldi	r25, 0x00	; 0
    c4a2:	9c 01       	movw	r18, r24
    c4a4:	22 0f       	add	r18, r18
    c4a6:	33 1f       	adc	r19, r19
    c4a8:	28 0f       	add	r18, r24
    c4aa:	39 1f       	adc	r19, r25
    c4ac:	f9 01       	movw	r30, r18
    c4ae:	ee 0f       	add	r30, r30
    c4b0:	ff 1f       	adc	r31, r31
    c4b2:	ee 0f       	add	r30, r30
    c4b4:	ff 1f       	adc	r31, r31
    c4b6:	ee 0f       	add	r30, r30
    c4b8:	ff 1f       	adc	r31, r31
    c4ba:	e2 1b       	sub	r30, r18
    c4bc:	f3 0b       	sbc	r31, r19
    c4be:	e8 5a       	subi	r30, 0xA8	; 168
    c4c0:	f9 4f       	sbci	r31, 0xF9	; 249
    c4c2:	80 e1       	ldi	r24, 0x10	; 16
    c4c4:	80 83       	st	Z, r24
	if(++Blink>16)
    c4c6:	80 91 17 09 	lds	r24, 0x0917
    c4ca:	8f 5f       	subi	r24, 0xFF	; 255
    c4cc:	80 93 17 09 	sts	0x0917, r24
    c4d0:	81 31       	cpi	r24, 0x11	; 17
    c4d2:	10 f0       	brcs	.+4      	; 0xc4d8 <MenuOut+0x41c>
		Blink=0;
    c4d4:	10 92 17 09 	sts	0x0917, r1
	EventFunc(&CurrPage->Run);
    c4d8:	ca 01       	movw	r24, r20
    c4da:	08 96       	adiw	r24, 0x08	; 8
    c4dc:	0e 94 44 3d 	call	0x7a88	; 0x7a88 <EventFunc>
    c4e0:	d3 ce       	rjmp	.-602    	; 0xc288 <MenuOut+0x1cc>
	}
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Y, Y);
    c4e2:	80 2f       	mov	r24, r16
    c4e4:	60 2f       	mov	r22, r16
    c4e6:	0e 94 02 5e 	call	0xbc04	; 0xbc04 <PutLine>
    c4ea:	40 91 d4 02 	lds	r20, 0x02D4
    c4ee:	50 91 d5 02 	lds	r21, 0x02D5
    c4f2:	0f 5f       	subi	r16, 0xFF	; 255
    c4f4:	1f 4f       	sbci	r17, 0xFF	; 255
		EventFunc(&CurrMsg->Run);
		return;
	}
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
    c4f6:	0e 15       	cp	r16, r14
    c4f8:	08 f4       	brcc	.+2      	; 0xc4fc <MenuOut+0x440>
    c4fa:	81 cf       	rjmp	.-254    	; 0xc3fe <MenuOut+0x342>
    c4fc:	a2 cf       	rjmp	.-188    	; 0xc442 <MenuOut+0x386>
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Y, Y);
	for(; Y<LCDYSz; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Dist+Y, Y);
    c4fe:	8f 2d       	mov	r24, r15
    c500:	61 2f       	mov	r22, r17
    c502:	0e 94 02 5e 	call	0xbc04	; 0xbc04 <PutLine>
    c506:	40 91 d4 02 	lds	r20, 0x02D4
    c50a:	50 91 d5 02 	lds	r21, 0x02D5
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Y, Y);
	for(; Y<LCDYSz; Y++)
    c50e:	1f 5f       	subi	r17, 0xFF	; 255
    c510:	f3 94       	inc	r15
    c512:	14 30       	cpi	r17, 0x04	; 4
    c514:	08 f4       	brcc	.+2      	; 0xc518 <MenuOut+0x45c>
    c516:	9f cf       	rjmp	.-194    	; 0xc456 <MenuOut+0x39a>
    c518:	b5 cf       	rjmp	.-150    	; 0xc484 <MenuOut+0x3c8>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    c51a:	fa 01       	movw	r30, r20
    c51c:	65 91       	lpm	r22, Z+
    c51e:	74 91       	lpm	r23, Z+
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Dist+Y, Y);
	if(prb(&CurrPage->LineNumber)>LCDYSz || Fix<LCDYSz-1 || prp(&(GetLine+CurrLine)->OF_List))
    c520:	80 91 c9 07 	lds	r24, 0x07C9
    c524:	2b e1       	ldi	r18, 0x1B	; 27
    c526:	82 9f       	mul	r24, r18
    c528:	c0 01       	movw	r24, r0
    c52a:	11 24       	eor	r1, r1
    c52c:	68 0f       	add	r22, r24
    c52e:	79 1f       	adc	r23, r25
    c530:	69 5e       	subi	r22, 0xE9	; 233
    c532:	7f 4f       	sbci	r23, 0xFF	; 255
    c534:	fb 01       	movw	r30, r22
    c536:	85 91       	lpm	r24, Z+
    c538:	94 91       	lpm	r25, Z+
    c53a:	89 2b       	or	r24, r25
    c53c:	09 f0       	breq	.+2      	; 0xc540 <MenuOut+0x484>
    c53e:	ae cf       	rjmp	.-164    	; 0xc49c <MenuOut+0x3e0>
    c540:	c2 cf       	rjmp	.-124    	; 0xc4c6 <MenuOut+0x40a>
		EventFunc(&CurrMsg->Run);
		return;
	}
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
    c542:	10 e0       	ldi	r17, 0x00	; 0
    c544:	82 cf       	rjmp	.-252    	; 0xc44a <MenuOut+0x38e>

0000c546 <LCD_Sweep>:

// ~~~~~~~~~~~~
static void
LCD_Sweep(void)
{
	if(LCD_Rdy()) {
    c546:	0e 94 49 27 	call	0x4e92	; 0x4e92 <LCD_Rdy>
    c54a:	88 23       	and	r24, r24
    c54c:	09 f4       	brne	.+2      	; 0xc550 <LCD_Sweep+0xa>
    c54e:	08 95       	ret
		MenuOut();
    c550:	0e 94 5e 60 	call	0xc0bc	; 0xc0bc <MenuOut>
		LCD_Out();
    c554:	0e 94 5f 27 	call	0x4ebe	; 0x4ebe <LCD_Out>
    c558:	08 95       	ret

0000c55a <strcpy_EE>:
	}//while
	return GSM_RxCharN;
}
// ~~~~~~~~~~~
//    EEPROM   RAM     '\0'    EEPROM
uint8_t strcpy_EE(char* str_RAM, uint8_t* str_EE){
    c55a:	cf 92       	push	r12
    c55c:	df 92       	push	r13
    c55e:	ef 92       	push	r14
    c560:	ff 92       	push	r15
    c562:	1f 93       	push	r17
    c564:	cf 93       	push	r28
    c566:	df 93       	push	r29
    c568:	6c 01       	movw	r12, r24
    c56a:	7b 01       	movw	r14, r22
    c56c:	10 e0       	ldi	r17, 0x00	; 0
    c56e:	06 c0       	rjmp	.+12     	; 0xc57c <strcpy_EE+0x22>
	uint8_t i=0;
	while( (erb(&str_EE[i])!='\0') && (erb(&str_EE[i])!=' ') ){
    c570:	80 32       	cpi	r24, 0x20	; 32
    c572:	69 f0       	breq	.+26     	; 0xc58e <strcpy_EE+0x34>
		str_RAM[i] = (char)erb(&str_EE[i]);
    c574:	cc 0d       	add	r28, r12
    c576:	dd 1d       	adc	r29, r13
    c578:	88 83       	st	Y, r24
		i++;
    c57a:	1f 5f       	subi	r17, 0xFF	; 255
}
// ~~~~~~~~~~~
//    EEPROM   RAM     '\0'    EEPROM
uint8_t strcpy_EE(char* str_RAM, uint8_t* str_EE){
	uint8_t i=0;
	while( (erb(&str_EE[i])!='\0') && (erb(&str_EE[i])!=' ') ){
    c57c:	c1 2f       	mov	r28, r17
    c57e:	d0 e0       	ldi	r29, 0x00	; 0
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    c580:	c7 01       	movw	r24, r14
    c582:	8c 0f       	add	r24, r28
    c584:	9d 1f       	adc	r25, r29
    c586:	0e 94 17 84 	call	0x1082e	; 0x1082e <__eerd_byte_m2560>
    c58a:	88 23       	and	r24, r24
    c58c:	89 f7       	brne	.-30     	; 0xc570 <strcpy_EE+0x16>
		str_RAM[i] = (char)erb(&str_EE[i]);
		i++;
	}
	return i;	
}
    c58e:	81 2f       	mov	r24, r17
    c590:	df 91       	pop	r29
    c592:	cf 91       	pop	r28
    c594:	1f 91       	pop	r17
    c596:	ff 90       	pop	r15
    c598:	ef 90       	pop	r14
    c59a:	df 90       	pop	r13
    c59c:	cf 90       	pop	r12
    c59e:	08 95       	ret

0000c5a0 <GSM_Cycle>:
	}//switch
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
void
GSM_Cycle(void)
{
    c5a0:	7f 92       	push	r7
    c5a2:	8f 92       	push	r8
    c5a4:	9f 92       	push	r9
    c5a6:	af 92       	push	r10
    c5a8:	bf 92       	push	r11
    c5aa:	cf 92       	push	r12
    c5ac:	df 92       	push	r13
    c5ae:	ef 92       	push	r14
    c5b0:	ff 92       	push	r15
    c5b2:	0f 93       	push	r16
    c5b4:	1f 93       	push	r17
    c5b6:	df 93       	push	r29
    c5b8:	cf 93       	push	r28
    c5ba:	cd b7       	in	r28, 0x3d	; 61
    c5bc:	de b7       	in	r29, 0x3e	; 62
    c5be:	65 97       	sbiw	r28, 0x15	; 21
    c5c0:	0f b6       	in	r0, 0x3f	; 63
    c5c2:	f8 94       	cli
    c5c4:	de bf       	out	0x3e, r29	; 62
    c5c6:	0f be       	out	0x3f, r0	; 63
    c5c8:	cd bf       	out	0x3d, r28	; 61
	switch(GSM_Control){
    c5ca:	80 91 d0 07 	lds	r24, 0x07D0
    c5ce:	88 23       	and	r24, r24
    c5d0:	d9 f4       	brne	.+54     	; 0xc608 <GSM_Cycle+0x68>
	else return 0;
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Auto(){

	switch(GSM_State){
    c5d2:	80 91 f6 06 	lds	r24, 0x06F6
    c5d6:	e8 2f       	mov	r30, r24
    c5d8:	f0 e0       	ldi	r31, 0x00	; 0
    c5da:	ea 35       	cpi	r30, 0x5A	; 90
    c5dc:	f1 05       	cpc	r31, r1
    c5de:	68 f1       	brcs	.+90     	; 0xc63a <GSM_Cycle+0x9a>
			break;	
		case GSM_CNTL_CONFIG:
			GSM_Config();
			break;								
	}
}
    c5e0:	65 96       	adiw	r28, 0x15	; 21
    c5e2:	0f b6       	in	r0, 0x3f	; 63
    c5e4:	f8 94       	cli
    c5e6:	de bf       	out	0x3e, r29	; 62
    c5e8:	0f be       	out	0x3f, r0	; 63
    c5ea:	cd bf       	out	0x3d, r28	; 61
    c5ec:	cf 91       	pop	r28
    c5ee:	df 91       	pop	r29
    c5f0:	1f 91       	pop	r17
    c5f2:	0f 91       	pop	r16
    c5f4:	ff 90       	pop	r15
    c5f6:	ef 90       	pop	r14
    c5f8:	df 90       	pop	r13
    c5fa:	cf 90       	pop	r12
    c5fc:	bf 90       	pop	r11
    c5fe:	af 90       	pop	r10
    c600:	9f 90       	pop	r9
    c602:	8f 90       	pop	r8
    c604:	7f 90       	pop	r7
    c606:	08 95       	ret
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
void
GSM_Cycle(void)
{
	switch(GSM_Control){
    c608:	82 30       	cpi	r24, 0x02	; 2
    c60a:	51 f7       	brne	.-44     	; 0xc5e0 <GSM_Cycle+0x40>
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Manual(){}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Config(){
	switch(GSM_State){
    c60c:	80 91 f6 06 	lds	r24, 0x06F6
    c610:	84 30       	cpi	r24, 0x04	; 4
    c612:	11 f4       	brne	.+4      	; 0xc618 <GSM_Cycle+0x78>
    c614:	0c 94 59 6c 	jmp	0xd8b2	; 0xd8b2 <GSM_Cycle+0x1312>
    c618:	85 30       	cpi	r24, 0x05	; 5
    c61a:	b8 f0       	brcs	.+46     	; 0xc64a <GSM_Cycle+0xaa>
    c61c:	86 30       	cpi	r24, 0x06	; 6
    c61e:	11 f4       	brne	.+4      	; 0xc624 <GSM_Cycle+0x84>
    c620:	0c 94 20 6c 	jmp	0xd840	; 0xd840 <GSM_Cycle+0x12a0>
    c624:	86 30       	cpi	r24, 0x06	; 6
    c626:	48 f1       	brcs	.+82     	; 0xc67a <GSM_Cycle+0xda>
    c628:	87 30       	cpi	r24, 0x07	; 7
    c62a:	11 f4       	brne	.+4      	; 0xc630 <GSM_Cycle+0x90>
    c62c:	0c 94 11 6c 	jmp	0xd822	; 0xd822 <GSM_Cycle+0x1282>
    c630:	88 30       	cpi	r24, 0x08	; 8
    c632:	b1 f2       	breq	.-84     	; 0xc5e0 <GSM_Cycle+0x40>
			if(Timer16Stopp(TD_GSM)) GSM_State++;
			break;
		case GSM_FINISH:			
			break;
		default:
			GSM_State = GSM_CFG_START;
    c634:	10 92 f6 06 	sts	0x06F6, r1
    c638:	d3 cf       	rjmp	.-90     	; 0xc5e0 <GSM_Cycle+0x40>
	else return 0;
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Auto(){

	switch(GSM_State){
    c63a:	e4 50       	subi	r30, 0x04	; 4
    c63c:	ff 4f       	sbci	r31, 0xFF	; 255
    c63e:	ee 0f       	add	r30, r30
    c640:	ff 1f       	adc	r31, r31
    c642:	05 90       	lpm	r0, Z+
    c644:	f4 91       	lpm	r31, Z+
    c646:	e0 2d       	mov	r30, r0
    c648:	19 94       	eijmp
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Manual(){}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Config(){
	switch(GSM_State){
    c64a:	81 30       	cpi	r24, 0x01	; 1
    c64c:	11 f4       	brne	.+4      	; 0xc652 <GSM_Cycle+0xb2>
    c64e:	0c 94 46 6c 	jmp	0xd88c	; 0xd88c <GSM_Cycle+0x12ec>
    c652:	81 30       	cpi	r24, 0x01	; 1
    c654:	f0 f0       	brcs	.+60     	; 0xc692 <GSM_Cycle+0xf2>
    c656:	82 30       	cpi	r24, 0x02	; 2
    c658:	11 f4       	brne	.+4      	; 0xc65e <GSM_Cycle+0xbe>
    c65a:	0c 94 36 6c 	jmp	0xd86c	; 0xd86c <GSM_Cycle+0x12cc>
    c65e:	83 30       	cpi	r24, 0x03	; 3
    c660:	49 f7       	brne	.-46     	; 0xc634 <GSM_Cycle+0x94>
			break;
		case GSM_CFG_WAIT_AT_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_CFG_SEND_AT)) GSM_State++;
			break;
		case GSM_CFG_SEND_IPR:
			GSM_Execute_Command(AT_IPR9600, 100); GSM_State++;
    c662:	80 e7       	ldi	r24, 0x70	; 112
    c664:	94 e0       	ldi	r25, 0x04	; 4
    c666:	64 e6       	ldi	r22, 0x64	; 100
    c668:	70 e0       	ldi	r23, 0x00	; 0
    c66a:	0e 94 3a 4c 	call	0x9874	; 0x9874 <GSM_Execute_Command>
    c66e:	80 91 f6 06 	lds	r24, 0x06F6
    c672:	8f 5f       	subi	r24, 0xFF	; 255
    c674:	80 93 f6 06 	sts	0x06F6, r24
    c678:	b3 cf       	rjmp	.-154    	; 0xc5e0 <GSM_Cycle+0x40>
				StartTimer16(TD_GSM,200);
				GSM_State++;
			}
			break;
		case GSM_CFG_SEND_ATW:
			GSM_Execute_Command(AT_W, 100); GSM_State++;
    c67a:	8c e7       	ldi	r24, 0x7C	; 124
    c67c:	94 e0       	ldi	r25, 0x04	; 4
    c67e:	64 e6       	ldi	r22, 0x64	; 100
    c680:	70 e0       	ldi	r23, 0x00	; 0
    c682:	0e 94 3a 4c 	call	0x9874	; 0x9874 <GSM_Execute_Command>
    c686:	80 91 f6 06 	lds	r24, 0x06F6
    c68a:	8f 5f       	subi	r24, 0xFF	; 255
    c68c:	80 93 f6 06 	sts	0x06F6, r24
    c690:	a7 cf       	rjmp	.-178    	; 0xc5e0 <GSM_Cycle+0x40>
inline static void GSM_Manual(){}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Config(){
	switch(GSM_State){
		case GSM_CFG_START:
			StartTimer16(TD_GSM,200);
    c692:	80 91 e9 04 	lds	r24, 0x04E9
    c696:	68 ec       	ldi	r22, 0xC8	; 200
    c698:	70 e0       	ldi	r23, 0x00	; 0
    c69a:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
		cli();
		PORTL|=(1<<PL5);
		sei();
	}
	void GSM_PWRCNTRL_ON(void){
		cli();
    c69e:	f8 94       	cli
		PORTL &= ~(1<<PL5);
    c6a0:	80 91 0b 01 	lds	r24, 0x010B
    c6a4:	8f 7d       	andi	r24, 0xDF	; 223
    c6a6:	80 93 0b 01 	sts	0x010B, r24
		sei();
    c6aa:	78 94       	sei
			GSM_PWRCNTRL_ON();
			GSM_State++;
    c6ac:	80 91 f6 06 	lds	r24, 0x06F6
    c6b0:	8f 5f       	subi	r24, 0xFF	; 255
    c6b2:	80 93 f6 06 	sts	0x06F6, r24
    c6b6:	94 cf       	rjmp	.-216    	; 0xc5e0 <GSM_Cycle+0x40>
			break;
		case GSM_SEND_CGMM:
			GSM_Execute_Command(AT_CGMM,5000*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CGMM_READ:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
    c6b8:	80 91 e9 04 	lds	r24, 0x04E9
    c6bc:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <Timer16Stopp>
    c6c0:	88 23       	and	r24, r24
    c6c2:	19 f0       	breq	.+6      	; 0xc6ca <GSM_Cycle+0x12a>
    c6c4:	8a e4       	ldi	r24, 0x4A	; 74
    c6c6:	80 93 f6 06 	sts	0x06F6, r24
			if(GetStringFromFIFO()){
    c6ca:	0e 94 92 39 	call	0x7324	; 0x7324 <GetStringFromFIFO>
    c6ce:	88 23       	and	r24, r24
    c6d0:	31 f1       	breq	.+76     	; 0xc71e <GSM_Cycle+0x17e>
				if(!strcmp_P(GSM_RxStr, GSM_SIMCOM_SIM900R)) GSM_Modem = SIMCOM_SIM900R;
    c6d2:	80 ee       	ldi	r24, 0xE0	; 224
    c6d4:	97 e0       	ldi	r25, 0x07	; 7
    c6d6:	6b e5       	ldi	r22, 0x5B	; 91
    c6d8:	73 e0       	ldi	r23, 0x03	; 3
    c6da:	0e 94 ed 80 	call	0x101da	; 0x101da <strcmp_P>
    c6de:	89 2b       	or	r24, r25
    c6e0:	19 f4       	brne	.+6      	; 0xc6e8 <GSM_Cycle+0x148>
    c6e2:	81 e0       	ldi	r24, 0x01	; 1
    c6e4:	80 93 34 07 	sts	0x0734, r24
				if(!strcmp_P(GSM_RxStr, GSM_SIMCOM_SIM800)) GSM_Modem = SIMCOM_SIM800;
    c6e8:	80 ee       	ldi	r24, 0xE0	; 224
    c6ea:	97 e0       	ldi	r25, 0x07	; 7
    c6ec:	6a e6       	ldi	r22, 0x6A	; 106
    c6ee:	73 e0       	ldi	r23, 0x03	; 3
    c6f0:	0e 94 ed 80 	call	0x101da	; 0x101da <strcmp_P>
    c6f4:	89 2b       	or	r24, r25
    c6f6:	19 f4       	brne	.+6      	; 0xc6fe <GSM_Cycle+0x15e>
    c6f8:	82 e0       	ldi	r24, 0x02	; 2
    c6fa:	80 93 34 07 	sts	0x0734, r24
				if(!strcmp_P(GSM_RxStr, GSM_SIMCOM_SIM800C)) GSM_Modem = SIMCOM_SIM800;
    c6fe:	80 ee       	ldi	r24, 0xE0	; 224
    c700:	97 e0       	ldi	r25, 0x07	; 7
    c702:	68 e7       	ldi	r22, 0x78	; 120
    c704:	73 e0       	ldi	r23, 0x03	; 3
    c706:	0e 94 ed 80 	call	0x101da	; 0x101da <strcmp_P>
    c70a:	89 2b       	or	r24, r25
    c70c:	11 f0       	breq	.+4      	; 0xc712 <GSM_Cycle+0x172>
    c70e:	0c 94 d4 6f 	jmp	0xdfa8	; 0xdfa8 <GSM_Cycle+0x1a08>
    c712:	82 e0       	ldi	r24, 0x02	; 2
    c714:	80 93 34 07 	sts	0x0734, r24
				//Add here new model GSM-modem
				if(GSM_Modem != NOT_RECOGNIZED) GSM_State = GSM_WAIT_CALL_READY;
    c718:	86 e0       	ldi	r24, 0x06	; 6
    c71a:	80 93 f6 06 	sts	0x06F6, r24
			}
		case GSM_WAIT_CFUN:
			if(GSM_Wait_Response_P(URC_CFUN, GSM_ReStart1)) GSM_State++;
    c71e:	8b e8       	ldi	r24, 0x8B	; 139
    c720:	93 e0       	ldi	r25, 0x03	; 3
    c722:	6a e4       	ldi	r22, 0x4A	; 74
    c724:	0e 94 df 4b 	call	0x97be	; 0x97be <GSM_Wait_Response_P>
    c728:	88 23       	and	r24, r24
    c72a:	09 f4       	brne	.+2      	; 0xc72e <GSM_Cycle+0x18e>
    c72c:	59 cf       	rjmp	.-334    	; 0xc5e0 <GSM_Cycle+0x40>
    c72e:	80 91 f6 06 	lds	r24, 0x06F6
    c732:	8f 5f       	subi	r24, 0xFF	; 255
    c734:	80 93 f6 06 	sts	0x06F6, r24
    c738:	53 cf       	rjmp	.-346    	; 0xc5e0 <GSM_Cycle+0x40>
		case GSM_WAIT_R2D_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;

		case GSM_WAIT_R2D_CONNECT:
			if(GSM_Wait_Response_P(RESP_CONNECT, GSM_ReStart1)){ 				
    c73a:	84 ef       	ldi	r24, 0xF4	; 244
    c73c:	93 e0       	ldi	r25, 0x03	; 3
    c73e:	6a e4       	ldi	r22, 0x4A	; 74
    c740:	0e 94 df 4b 	call	0x97be	; 0x97be <GSM_Wait_Response_P>
    c744:	88 23       	and	r24, r24
    c746:	09 f4       	brne	.+2      	; 0xc74a <GSM_Cycle+0x1aa>
    c748:	4b cf       	rjmp	.-362    	; 0xc5e0 <GSM_Cycle+0x40>
				GSM_State=GSM_ProtocolMode;
    c74a:	82 e5       	ldi	r24, 0x52	; 82
    c74c:	80 93 f6 06 	sts	0x06F6, r24
				StartTimer16(TD_timer_after_page_transfer,100);
    c750:	80 91 f1 04 	lds	r24, 0x04F1
    c754:	64 e6       	ldi	r22, 0x64	; 100
    c756:	70 e0       	ldi	r23, 0x00	; 0
    c758:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    c75c:	8f ef       	ldi	r24, 0xFF	; 255
    c75e:	80 93 3e 07 	sts	0x073E, r24
	GSM_RX_FIFO_End = 255;
    c762:	80 93 53 06 	sts	0x0653, r24
	GSM_RxCharN = 0;
    c766:	10 92 5f 0b 	sts	0x0B5F, r1
	GSM_RX_FIFOOverFlow = 0;
    c76a:	10 92 12 09 	sts	0x0912, r1
	GSM_RX_FIFOMax = 0;
    c76e:	10 92 18 09 	sts	0x0918, r1
    c772:	36 cf       	rjmp	.-404    	; 0xc5e0 <GSM_Cycle+0x40>
			GSM_State=GSM_WAIT_R2D_CONNECT;
		
			break;

		case GSM_WAIT_R2D_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    c774:	81 ef       	ldi	r24, 0xF1	; 241
    c776:	93 e0       	ldi	r25, 0x03	; 3
    c778:	6a e4       	ldi	r22, 0x4A	; 74
    c77a:	0e 94 df 4b 	call	0x97be	; 0x97be <GSM_Wait_Response_P>
    c77e:	88 23       	and	r24, r24
    c780:	09 f4       	brne	.+2      	; 0xc784 <GSM_Cycle+0x1e4>
    c782:	2e cf       	rjmp	.-420    	; 0xc5e0 <GSM_Cycle+0x40>
    c784:	80 91 f6 06 	lds	r24, 0x06F6
    c788:	8f 5f       	subi	r24, 0xFF	; 255
    c78a:	80 93 f6 06 	sts	0x06F6, r24
    c78e:	28 cf       	rjmp	.-432    	; 0xc5e0 <GSM_Cycle+0x40>
			break;

		//----  data mode
		case GSM_Return2dataMode:

			CommandModeDestination=0;
    c790:	10 92 af 07 	sts	0x07AF, r1
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    c794:	8f ef       	ldi	r24, 0xFF	; 255
    c796:	80 93 3e 07 	sts	0x073E, r24
	GSM_RX_FIFO_End = 255;
    c79a:	80 93 53 06 	sts	0x0653, r24
	GSM_RxCharN = 0;
    c79e:	10 92 5f 0b 	sts	0x0B5F, r1
	GSM_RX_FIFOOverFlow = 0;
    c7a2:	10 92 12 09 	sts	0x0912, r1
	GSM_RX_FIFOMax = 0;
    c7a6:	10 92 18 09 	sts	0x0918, r1
    c7aa:	e0 ee       	ldi	r30, 0xE0	; 224
    c7ac:	f7 e0       	ldi	r31, 0x07	; 7

			CommandModeDestination=0;
			InitFIFO();
			for(int i=0;i<GSM_RXSTR_SIZE;i++)
			{
				GSM_RxStr[i]=0;	
    c7ae:	11 92       	st	Z+, r1
		//----  data mode
		case GSM_Return2dataMode:

			CommandModeDestination=0;
			InitFIFO();
			for(int i=0;i<GSM_RXSTR_SIZE;i++)
    c7b0:	b8 e0       	ldi	r27, 0x08	; 8
    c7b2:	e4 34       	cpi	r30, 0x44	; 68
    c7b4:	fb 07       	cpc	r31, r27
    c7b6:	d9 f7       	brne	.-10     	; 0xc7ae <GSM_Cycle+0x20e>
			{
				GSM_RxStr[i]=0;	
			}
			GSM_Execute_Command(ATO, 600*GSM_DEBUG_DELAY); //GSM_State++;
    c7b8:	81 e0       	ldi	r24, 0x01	; 1
    c7ba:	96 e0       	ldi	r25, 0x06	; 6
    c7bc:	68 e5       	ldi	r22, 0x58	; 88
    c7be:	72 e0       	ldi	r23, 0x02	; 2
    c7c0:	0e 94 3a 4c 	call	0x9874	; 0x9874 <GSM_Execute_Command>
			GSM_State=GSM_WAIT_R2D_CONNECT;
    c7c4:	89 e5       	ldi	r24, 0x59	; 89
    c7c6:	80 93 f6 06 	sts	0x06F6, r24
    c7ca:	0a cf       	rjmp	.-492    	; 0xc5e0 <GSM_Cycle+0x40>
				StartTimer16(TD_GSM,1000);	// min 500ms after +++
				GSM_State++;
			}
			break;
		case GSM_WAIT_D2C_SWITCH_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) {
    c7cc:	81 ef       	ldi	r24, 0xF1	; 241
    c7ce:	93 e0       	ldi	r25, 0x03	; 3
    c7d0:	6a e4       	ldi	r22, 0x4A	; 74
    c7d2:	0e 94 df 4b 	call	0x97be	; 0x97be <GSM_Wait_Response_P>
    c7d6:	88 23       	and	r24, r24
    c7d8:	09 f4       	brne	.+2      	; 0xc7dc <GSM_Cycle+0x23c>
    c7da:	02 cf       	rjmp	.-508    	; 0xc5e0 <GSM_Cycle+0x40>

				switch(CommandModeDestination){
    c7dc:	80 91 af 07 	lds	r24, 0x07AF
    c7e0:	82 30       	cpi	r24, 0x02	; 2
    c7e2:	11 f4       	brne	.+4      	; 0xc7e8 <GSM_Cycle+0x248>
    c7e4:	0c 94 4d 70 	jmp	0xe09a	; 0xe09a <GSM_Cycle+0x1afa>
    c7e8:	83 30       	cpi	r24, 0x03	; 3
    c7ea:	10 f0       	brcs	.+4      	; 0xc7f0 <GSM_Cycle+0x250>
    c7ec:	0c 94 bd 6f 	jmp	0xdf7a	; 0xdf7a <GSM_Cycle+0x19da>
    c7f0:	81 30       	cpi	r24, 0x01	; 1
    c7f2:	11 f4       	brne	.+4      	; 0xc7f8 <GSM_Cycle+0x258>
    c7f4:	0c 94 54 70 	jmp	0xe0a8	; 0xe0a8 <GSM_Cycle+0x1b08>
						break;
					case 5:	
						GSM_State = GSM_SEND_CSQ;
						counter=0;	
						break;
					default:GSM_State = GSM_Return2dataMode;
    c7f8:	87 e5       	ldi	r24, 0x57	; 87
    c7fa:	80 93 f6 06 	sts	0x06F6, r24
    c7fe:	f0 ce       	rjmp	.-544    	; 0xc5e0 <GSM_Cycle+0x40>
//IF WEB			WebClose();
			GSM_State++;

			break;
		case GSM_Swtch2CommandModePlus:
			if(Timer16Stopp(TD_GSM)){
    c800:	80 91 e9 04 	lds	r24, 0x04E9
    c804:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <Timer16Stopp>
    c808:	88 23       	and	r24, r24
    c80a:	09 f4       	brne	.+2      	; 0xc80e <GSM_Cycle+0x26e>
    c80c:	e9 ce       	rjmp	.-558    	; 0xc5e0 <GSM_Cycle+0x40>
    c80e:	e0 ee       	ldi	r30, 0xE0	; 224
    c810:	f7 e0       	ldi	r31, 0x07	; 7
				for(int i=0;i<GSM_RXSTR_SIZE;i++)
				{
					GSM_RxStr[i]=0;	
    c812:	11 92       	st	Z+, r1
			GSM_State++;

			break;
		case GSM_Swtch2CommandModePlus:
			if(Timer16Stopp(TD_GSM)){
				for(int i=0;i<GSM_RXSTR_SIZE;i++)
    c814:	28 e0       	ldi	r18, 0x08	; 8
    c816:	e4 34       	cpi	r30, 0x44	; 68
    c818:	f2 07       	cpc	r31, r18
    c81a:	d9 f7       	brne	.-10     	; 0xc812 <GSM_Cycle+0x272>
				{
					GSM_RxStr[i]=0;	
				}
				sprintf_P(GSM_TxStr, ESC_SEQ);
    c81c:	00 d0       	rcall	.+0      	; 0xc81e <GSM_Cycle+0x27e>
    c81e:	0f 92       	push	r0
    c820:	09 e4       	ldi	r16, 0x49	; 73
    c822:	1a e0       	ldi	r17, 0x0A	; 10
    c824:	ad b7       	in	r26, 0x3d	; 61
    c826:	be b7       	in	r27, 0x3e	; 62
    c828:	12 96       	adiw	r26, 0x02	; 2
    c82a:	1c 93       	st	X, r17
    c82c:	0e 93       	st	-X, r16
    c82e:	11 97       	sbiw	r26, 0x01	; 1
    c830:	8a e5       	ldi	r24, 0x5A	; 90
    c832:	94 e0       	ldi	r25, 0x04	; 4
    c834:	14 96       	adiw	r26, 0x04	; 4
    c836:	9c 93       	st	X, r25
    c838:	8e 93       	st	-X, r24
    c83a:	13 97       	sbiw	r26, 0x03	; 3
    c83c:	0e 94 1a 82 	call	0x10434	; 0x10434 <sprintf_P>
				GSMTxSz = strlen(GSM_TxStr);
    c840:	f8 01       	movw	r30, r16
    c842:	01 90       	ld	r0, Z+
    c844:	00 20       	and	r0, r0
    c846:	e9 f7       	brne	.-6      	; 0xc842 <GSM_Cycle+0x2a2>
    c848:	8f 01       	movw	r16, r30
    c84a:	01 50       	subi	r16, 0x01	; 1
    c84c:	10 40       	sbci	r17, 0x00	; 0
    c84e:	09 54       	subi	r16, 0x49	; 73
    c850:	1a 40       	sbci	r17, 0x0A	; 10
    c852:	00 93 bb 07 	sts	0x07BB, r16
				GSM_SendFirstChar();
    c856:	0f 90       	pop	r0
    c858:	0f 90       	pop	r0
    c85a:	0f 90       	pop	r0
    c85c:	0f 90       	pop	r0
    c85e:	0e 94 bc 3a 	call	0x7578	; 0x7578 <GSM_SendFirstChar>
				StartTimer16(TD_GSM,1000);	// min 500ms after +++
    c862:	80 91 e9 04 	lds	r24, 0x04E9
    c866:	68 ee       	ldi	r22, 0xE8	; 232
    c868:	73 e0       	ldi	r23, 0x03	; 3
    c86a:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
				GSM_State++;
    c86e:	80 91 f6 06 	lds	r24, 0x06F6
    c872:	8f 5f       	subi	r24, 0xFF	; 255
    c874:	80 93 f6 06 	sts	0x06F6, r24
    c878:	b3 ce       	rjmp	.-666    	; 0xc5e0 <GSM_Cycle+0x40>
				GSM_State =GSM_ReStart1;
				break;
			}			
			break;
		case GSM_Swtch2CommandMode:
			StartTimer16(TD_GSM,100);	// min 1000ms before +++
    c87a:	80 91 e9 04 	lds	r24, 0x04E9
    c87e:	64 e6       	ldi	r22, 0x64	; 100
    c880:	70 e0       	ldi	r23, 0x00	; 0
    c882:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
//IF WEB			WebClose();
			GSM_State++;
    c886:	80 91 f6 06 	lds	r24, 0x06F6
    c88a:	8f 5f       	subi	r24, 0xFF	; 255
    c88c:	80 93 f6 06 	sts	0x06F6, r24
    c890:	a7 ce       	rjmp	.-690    	; 0xc5e0 <GSM_Cycle+0x40>
			}
			break;

		case GSM_DataMode:
			// -----    
			if(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){	// if FIFO not empty
    c892:	90 91 3e 07 	lds	r25, 0x073E
    c896:	80 91 53 06 	lds	r24, 0x0653
    c89a:	98 17       	cp	r25, r24
    c89c:	11 f4       	brne	.+4      	; 0xc8a2 <GSM_Cycle+0x302>
    c89e:	0c 94 a3 6e 	jmp	0xdd46	; 0xdd46 <GSM_Cycle+0x17a6>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    c8a2:	83 ec       	ldi	r24, 0xC3	; 195
    c8a4:	90 e0       	ldi	r25, 0x00	; 0
    c8a6:	0e 94 25 84 	call	0x1084a	; 0x1084a <__eerd_word_m2560>
    c8aa:	bc 01       	movw	r22, r24
				StartTimer16(TD_TCP_Connect, erw(&TCP_CONNECT_timeout));	//   
    c8ac:	80 91 ea 04 	lds	r24, 0x04EA
    c8b0:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
    c8b4:	95 ce       	rjmp	.-726    	; 0xc5e0 <GSM_Cycle+0x40>
		//------------------------

		//-----------

		case GSM_ProtocolMode:
			if( (strstr_P(GSM_RxStr, URC_CLOSED+2) != NULL) ){
    c8b6:	80 ee       	ldi	r24, 0xE0	; 224
    c8b8:	97 e0       	ldi	r25, 0x07	; 7
    c8ba:	64 ed       	ldi	r22, 0xD4	; 212
    c8bc:	73 e0       	ldi	r23, 0x03	; 3
    c8be:	0e 94 1f 81 	call	0x1023e	; 0x1023e <strstr_P>
    c8c2:	89 2b       	or	r24, r25
    c8c4:	b1 f0       	breq	.+44     	; 0xc8f2 <GSM_Cycle+0x352>
					GSM_State =GSM_ReStart1;
    c8c6:	8a e4       	ldi	r24, 0x4A	; 74
    c8c8:	80 93 f6 06 	sts	0x06F6, r24
    c8cc:	89 ce       	rjmp	.-750    	; 0xc5e0 <GSM_Cycle+0x40>

			while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){	
					GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);
					if(GSM_RxCharN==2)
						{
							if(!strncmp_P(GSM_RxStr, PSTR("\r\n"), 2)) {GSM_RxCharN=0;}
    c8ce:	80 ee       	ldi	r24, 0xE0	; 224
    c8d0:	97 e0       	ldi	r25, 0x07	; 7
    c8d2:	66 e3       	ldi	r22, 0x36	; 54
    c8d4:	7d e2       	ldi	r23, 0x2D	; 45
    c8d6:	42 e0       	ldi	r20, 0x02	; 2
    c8d8:	50 e0       	ldi	r21, 0x00	; 0
    c8da:	0e 94 06 81 	call	0x1020c	; 0x1020c <strncmp_P>
    c8de:	89 2b       	or	r24, r25
    c8e0:	11 f4       	brne	.+4      	; 0xc8e6 <GSM_Cycle+0x346>
    c8e2:	10 92 5f 0b 	sts	0x0B5F, r1
						}
					if(GSM_RxCharN >= 4){
    c8e6:	80 91 5f 0b 	lds	r24, 0x0B5F
    c8ea:	84 30       	cpi	r24, 0x04	; 4
    c8ec:	10 f0       	brcs	.+4      	; 0xc8f2 <GSM_Cycle+0x352>
    c8ee:	0c 94 17 6e 	jmp	0xdc2e	; 0xdc2e <GSM_Cycle+0x168e>
					break;
			}



			while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){	
    c8f2:	90 91 3e 07 	lds	r25, 0x073E
    c8f6:	80 91 53 06 	lds	r24, 0x0653
    c8fa:	98 17       	cp	r25, r24
    c8fc:	11 f4       	brne	.+4      	; 0xc902 <GSM_Cycle+0x362>
    c8fe:	0c 94 59 6e 	jmp	0xdcb2	; 0xdcb2 <GSM_Cycle+0x1712>
					GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);
    c902:	80 ee       	ldi	r24, 0xE0	; 224
    c904:	97 e0       	ldi	r25, 0x07	; 7
    c906:	6f e5       	ldi	r22, 0x5F	; 95
    c908:	7b e0       	ldi	r23, 0x0B	; 11
    c90a:	44 e6       	ldi	r20, 0x64	; 100
    c90c:	0e 94 28 39 	call	0x7250	; 0x7250 <GetByteFromFIFO>
					if(GSM_RxCharN==2)
    c910:	80 91 5f 0b 	lds	r24, 0x0B5F
    c914:	82 30       	cpi	r24, 0x02	; 2
    c916:	39 f7       	brne	.-50     	; 0xc8e6 <GSM_Cycle+0x346>
    c918:	da cf       	rjmp	.-76     	; 0xc8ce <GSM_Cycle+0x32e>
						}
					}
				}
			break;
		case GSM_WAIT_CSQ_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) {
    c91a:	81 ef       	ldi	r24, 0xF1	; 241
    c91c:	93 e0       	ldi	r25, 0x03	; 3
    c91e:	6a e4       	ldi	r22, 0x4A	; 74
    c920:	0e 94 df 4b 	call	0x97be	; 0x97be <GSM_Wait_Response_P>
    c924:	88 23       	and	r24, r24
    c926:	09 f4       	brne	.+2      	; 0xc92a <GSM_Cycle+0x38a>
    c928:	5b ce       	rjmp	.-842    	; 0xc5e0 <GSM_Cycle+0x40>
				if(CommandModeDestination==5){
    c92a:	80 91 af 07 	lds	r24, 0x07AF
    c92e:	85 30       	cpi	r24, 0x05	; 5
    c930:	11 f4       	brne	.+4      	; 0xc936 <GSM_Cycle+0x396>
    c932:	0c 94 cf 6f 	jmp	0xdf9e	; 0xdf9e <GSM_Cycle+0x19fe>
					GSM_State  = GSM_Return2dataMode;
				}
				else{
					GSM_State=GSM_SEND_CIPMUX;
    c936:	8a e2       	ldi	r24, 0x2A	; 42
    c938:	80 93 f6 06 	sts	0x06F6, r24
    c93c:	51 ce       	rjmp	.-862    	; 0xc5e0 <GSM_Cycle+0x40>
				GSM_Execute_Command(AT_CSQ, 500*GSM_DEBUG_DELAY); 
				InitFIFO();
				GSM_State++;
			break;
		case GSM_WAIT_CSQ:
				if(Timer16Stopp(TD_GSM)){
    c93e:	80 91 e9 04 	lds	r24, 0x04E9
    c942:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <Timer16Stopp>
    c946:	88 23       	and	r24, r24
    c948:	11 f4       	brne	.+4      	; 0xc94e <GSM_Cycle+0x3ae>
    c94a:	0c 94 43 6f 	jmp	0xde86	; 0xde86 <GSM_Cycle+0x18e6>
						GSM_State = GSM_ReStart1;
    c94e:	8a e4       	ldi	r24, 0x4A	; 74
    c950:	80 93 f6 06 	sts	0x06F6, r24
    c954:	45 ce       	rjmp	.-886    	; 0xc5e0 <GSM_Cycle+0x40>
			break;
		case GSM_ShutWait_:
			if(GSM_Wait_Response_P(RESP_SHUT_OK, GSM_ReStart1)) GSM_State++;
			break;
		case GSM_SEND_CGATT0:
			GSM_Execute_Command(AT_CGATT_0, 1000*GSM_DEBUG_DELAY); GSM_State++;
    c956:	8f ee       	ldi	r24, 0xEF	; 239
    c958:	95 e0       	ldi	r25, 0x05	; 5
    c95a:	68 ee       	ldi	r22, 0xE8	; 232
    c95c:	73 e0       	ldi	r23, 0x03	; 3
    c95e:	0e 94 3a 4c 	call	0x9874	; 0x9874 <GSM_Execute_Command>
    c962:	80 91 f6 06 	lds	r24, 0x06F6
    c966:	8f 5f       	subi	r24, 0xFF	; 255
    c968:	80 93 f6 06 	sts	0x06F6, r24
    c96c:	39 ce       	rjmp	.-910    	; 0xc5e0 <GSM_Cycle+0x40>
			break;
		//------------------------    


		case GSM_SEND_ATD_Check_Ballance:	
			if(GSM_Flag & (1<<flg_TxCStr)){
    c96e:	80 91 d2 02 	lds	r24, 0x02D2
    c972:	80 ff       	sbrs	r24, 0
    c974:	4b c0       	rjmp	.+150    	; 0xca0c <GSM_Cycle+0x46c>
				sprintf_P(GSM_TxStr, AT_CUSD101);	
    c976:	00 d0       	rcall	.+0      	; 0xc978 <GSM_Cycle+0x3d8>
    c978:	0f 92       	push	r0
    c97a:	89 e4       	ldi	r24, 0x49	; 73
    c97c:	9a e0       	ldi	r25, 0x0A	; 10
    c97e:	ad b7       	in	r26, 0x3d	; 61
    c980:	be b7       	in	r27, 0x3e	; 62
    c982:	12 96       	adiw	r26, 0x02	; 2
    c984:	9c 93       	st	X, r25
    c986:	8e 93       	st	-X, r24
    c988:	11 97       	sbiw	r26, 0x01	; 1
    c98a:	07 ec       	ldi	r16, 0xC7	; 199
    c98c:	14 e0       	ldi	r17, 0x04	; 4
    c98e:	14 96       	adiw	r26, 0x04	; 4
    c990:	1c 93       	st	X, r17
    c992:	0e 93       	st	-X, r16
    c994:	13 97       	sbiw	r26, 0x03	; 3
    c996:	0e 94 1a 82 	call	0x10434	; 0x10434 <sprintf_P>
				GSMTxSz = strlen_P(AT_CUSD101);
    c99a:	0f 90       	pop	r0
    c99c:	0f 90       	pop	r0
    c99e:	0f 90       	pop	r0
    c9a0:	0f 90       	pop	r0
    c9a2:	c8 01       	movw	r24, r16
    c9a4:	0e 94 fd 80 	call	0x101fa	; 0x101fa <strlen_P>
    c9a8:	80 93 bb 07 	sts	0x07BB, r24
				GSMTxSz += strcpy_EE(GSM_TxStr+GSMTxSz,GPRS_checkballancerequest);
    c9ac:	80 91 bb 07 	lds	r24, 0x07BB
    c9b0:	90 e0       	ldi	r25, 0x00	; 0
    c9b2:	87 5b       	subi	r24, 0xB7	; 183
    c9b4:	95 4f       	sbci	r25, 0xF5	; 245
    c9b6:	61 e3       	ldi	r22, 0x31	; 49
    c9b8:	70 e0       	ldi	r23, 0x00	; 0
    c9ba:	0e 94 ad 62 	call	0xc55a	; 0xc55a <strcpy_EE>
    c9be:	90 91 bb 07 	lds	r25, 0x07BB
    c9c2:	98 0f       	add	r25, r24
    c9c4:	90 93 bb 07 	sts	0x07BB, r25
				GSM_TxStr[GSMTxSz]='"';
    c9c8:	e0 91 bb 07 	lds	r30, 0x07BB
    c9cc:	f0 e0       	ldi	r31, 0x00	; 0
    c9ce:	e7 5b       	subi	r30, 0xB7	; 183
    c9d0:	f5 4f       	sbci	r31, 0xF5	; 245
    c9d2:	82 e2       	ldi	r24, 0x22	; 34
    c9d4:	80 83       	st	Z, r24
				GSM_TxStr[GSMTxSz+1]='\r';
    c9d6:	e0 91 bb 07 	lds	r30, 0x07BB
    c9da:	f0 e0       	ldi	r31, 0x00	; 0
    c9dc:	e7 5b       	subi	r30, 0xB7	; 183
    c9de:	f5 4f       	sbci	r31, 0xF5	; 245
    c9e0:	8d e0       	ldi	r24, 0x0D	; 13
    c9e2:	81 83       	std	Z+1, r24	; 0x01
				GSM_TxStr[GSMTxSz+2]='\n';
    c9e4:	e0 91 bb 07 	lds	r30, 0x07BB
    c9e8:	f0 e0       	ldi	r31, 0x00	; 0
    c9ea:	e7 5b       	subi	r30, 0xB7	; 183
    c9ec:	f5 4f       	sbci	r31, 0xF5	; 245
    c9ee:	8a e0       	ldi	r24, 0x0A	; 10
    c9f0:	82 83       	std	Z+2, r24	; 0x02
				GSMTxSz+=3;
    c9f2:	80 91 bb 07 	lds	r24, 0x07BB
    c9f6:	8d 5f       	subi	r24, 0xFD	; 253
    c9f8:	80 93 bb 07 	sts	0x07BB, r24
				GSM_SendFirstChar();
    c9fc:	0e 94 bc 3a 	call	0x7578	; 0x7578 <GSM_SendFirstChar>
				StartTimer16(TD_GSM, 1000);
    ca00:	80 91 e9 04 	lds	r24, 0x04E9
    ca04:	68 ee       	ldi	r22, 0xE8	; 232
    ca06:	73 e0       	ldi	r23, 0x03	; 3
    ca08:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
			}
			GSM_State++;	
    ca0c:	80 91 f6 06 	lds	r24, 0x06F6
    ca10:	8f 5f       	subi	r24, 0xFF	; 255
    ca12:	80 93 f6 06 	sts	0x06F6, r24
			GSM_Temp = 0;
    ca16:	10 92 db 05 	sts	0x05DB, r1
    ca1a:	e2 cd       	rjmp	.-1084   	; 0xc5e0 <GSM_Cycle+0x40>
			SetIP(&GSM_ClientIP,0,0,0,0);
			GSM_Flag |=(1<<flg_TxCStr);
			GSM_State++;
			break;
		case GSM_ReStart2:
			if(Timer16Stopp(TD_GSM)){
    ca1c:	80 91 e9 04 	lds	r24, 0x04E9
    ca20:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <Timer16Stopp>
    ca24:	88 23       	and	r24, r24
    ca26:	09 f4       	brne	.+2      	; 0xca2a <GSM_Cycle+0x48a>
    ca28:	db cd       	rjmp	.-1098   	; 0xc5e0 <GSM_Cycle+0x40>
				GSM_State = GSM_PowerOn;
    ca2a:	10 92 f6 06 	sts	0x06F6, r1
    ca2e:	d8 cd       	rjmp	.-1104   	; 0xc5e0 <GSM_Cycle+0x40>
		//------------------------

		
		//------------------------
		case GSM_ReStart1:
			GSM_ReStartN++;
    ca30:	80 91 34 09 	lds	r24, 0x0934
    ca34:	8f 5f       	subi	r24, 0xFF	; 255
    ca36:	80 93 34 09 	sts	0x0934, r24
		cli();
		DDRL|=(1<<PL5);
		sei();
	}
	void GSM_PWRCNTRL_OFF(void){
		cli();
    ca3a:	f8 94       	cli
		PORTL|=(1<<PL5);
    ca3c:	80 91 0b 01 	lds	r24, 0x010B
    ca40:	80 62       	ori	r24, 0x20	; 32
    ca42:	80 93 0b 01 	sts	0x010B, r24
		sei();
    ca46:	78 94       	sei
			GSM_PWRCNTRL_OFF();
			StartTimer16(TD_GSM,1000);
    ca48:	80 91 e9 04 	lds	r24, 0x04E9
    ca4c:	68 ee       	ldi	r22, 0xE8	; 232
    ca4e:	73 e0       	ldi	r23, 0x03	; 3
    ca50:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
			RxBufOverFlow = 0;
    ca54:	10 92 48 0b 	sts	0x0B48, r1
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    ca58:	8f ef       	ldi	r24, 0xFF	; 255
    ca5a:	80 93 3e 07 	sts	0x073E, r24
	GSM_RX_FIFO_End = 255;
    ca5e:	80 93 53 06 	sts	0x0653, r24
	GSM_RxCharN = 0;
    ca62:	10 92 5f 0b 	sts	0x0B5F, r1
	GSM_RX_FIFOOverFlow = 0;
    ca66:	10 92 12 09 	sts	0x0912, r1
	GSM_RX_FIFOMax = 0;
    ca6a:	10 92 18 09 	sts	0x0918, r1
    ca6e:	e0 ee       	ldi	r30, 0xE0	; 224
    ca70:	f7 e0       	ldi	r31, 0x07	; 7
			RxBufOverFlow = 0;
		//	WebSession=0;
			InitFIFO();
			for(int i=0;i<GSM_RXSTR_SIZE;i++)
			{
				GSM_RxStr[i]=0;	
    ca72:	11 92       	st	Z+, r1
			GSM_PWRCNTRL_OFF();
			StartTimer16(TD_GSM,1000);
			RxBufOverFlow = 0;
		//	WebSession=0;
			InitFIFO();
			for(int i=0;i<GSM_RXSTR_SIZE;i++)
    ca74:	28 e0       	ldi	r18, 0x08	; 8
    ca76:	e4 34       	cpi	r30, 0x44	; 68
    ca78:	f2 07       	cpc	r31, r18
    ca7a:	d9 f7       	brne	.-10     	; 0xca72 <GSM_Cycle+0x4d2>
			{
				GSM_RxStr[i]=0;	
			}
			SMS_FlgSz_Out = 0;	// ..          -  
    ca7c:	10 92 c8 07 	sts	0x07C8, r1
			GSM_ActiveConnection = NO_CONNECTION;
    ca80:	8f ef       	ldi	r24, 0xFF	; 255
    ca82:	80 93 d3 02 	sts	0x02D3, r24
	uint8_t IP4;
} IP_Addr;

//~~~~~~~~~~~~~~
void SetIP(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	IP->IP1 = IP1;
    ca86:	10 92 49 0b 	sts	0x0B49, r1
	IP->IP2 = IP2;
    ca8a:	10 92 4a 0b 	sts	0x0B4A, r1
	IP->IP3 = IP3;
    ca8e:	10 92 4b 0b 	sts	0x0B4B, r1
	IP->IP4 = IP4;
    ca92:	10 92 4c 0b 	sts	0x0B4C, r1
			SetIP(&GSM_ClientIP,0,0,0,0);
			GSM_Flag |=(1<<flg_TxCStr);
    ca96:	80 91 d2 02 	lds	r24, 0x02D2
    ca9a:	81 60       	ori	r24, 0x01	; 1
    ca9c:	80 93 d2 02 	sts	0x02D2, r24
			GSM_State++;
    caa0:	80 91 f6 06 	lds	r24, 0x06F6
    caa4:	8f 5f       	subi	r24, 0xFF	; 255
    caa6:	80 93 f6 06 	sts	0x06F6, r24
    caaa:	9a cd       	rjmp	.-1228   	; 0xc5e0 <GSM_Cycle+0x40>
			break;
		case GSM_SEND_CGATT0:
			GSM_Execute_Command(AT_CGATT_0, 1000*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CGATT0_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    caac:	81 ef       	ldi	r24, 0xF1	; 241
    caae:	93 e0       	ldi	r25, 0x03	; 3
    cab0:	6a e4       	ldi	r22, 0x4A	; 74
    cab2:	0e 94 df 4b 	call	0x97be	; 0x97be <GSM_Wait_Response_P>
    cab6:	88 23       	and	r24, r24
    cab8:	09 f4       	brne	.+2      	; 0xcabc <GSM_Cycle+0x51c>
    caba:	92 cd       	rjmp	.-1244   	; 0xc5e0 <GSM_Cycle+0x40>
				StartTimer16(TD_GSM, 1000);
    cabc:	80 91 e9 04 	lds	r24, 0x04E9
    cac0:	68 ee       	ldi	r22, 0xE8	; 232
    cac2:	73 e0       	ldi	r23, 0x03	; 3
    cac4:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
			 	GSM_State = GSM_SEND_ATD_Check_Ballance;
    cac8:	8c e4       	ldi	r24, 0x4C	; 76
    caca:	80 93 f6 06 	sts	0x06F6, r24
    cace:	88 cd       	rjmp	.-1264   	; 0xc5e0 <GSM_Cycle+0x40>
			break;
		case GSM_WAIT_ATD_Check_Ballance_OK:
			if(GSM_Wait_Response_P(RESP_OK,GSM_SEND_CSQ)) GSM_State++;
			break;
		case GSM_WAIT_Ballance:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_SEND_CSQ;
    cad0:	80 91 e9 04 	lds	r24, 0x04E9
    cad4:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <Timer16Stopp>
    cad8:	88 23       	and	r24, r24
    cada:	19 f0       	breq	.+6      	; 0xcae2 <GSM_Cycle+0x542>
    cadc:	8f e4       	ldi	r24, 0x4F	; 79
    cade:	80 93 f6 06 	sts	0x06F6, r24
			GSM_RxStr[GSM_RXSTR_SIZE-1]='\0';
    cae2:	10 92 43 08 	sts	0x0843, r1
		
				GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);

				if(GSM_RxCharN >= 90){

					GSM_State = GSM_SEND_CSQ;
    cae6:	1f e4       	ldi	r17, 0x4F	; 79
			if(GSM_Wait_Response_P(RESP_OK,GSM_SEND_CSQ)) GSM_State++;
			break;
		case GSM_WAIT_Ballance:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_SEND_CSQ;
			GSM_RxStr[GSM_RXSTR_SIZE-1]='\0';
			while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    cae8:	90 91 3e 07 	lds	r25, 0x073E
    caec:	80 91 53 06 	lds	r24, 0x0653
    caf0:	98 17       	cp	r25, r24
    caf2:	09 f4       	brne	.+2      	; 0xcaf6 <GSM_Cycle+0x556>
    caf4:	f4 c6       	rjmp	.+3560   	; 0xd8de <GSM_Cycle+0x133e>
				
		
				GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);
    caf6:	80 ee       	ldi	r24, 0xE0	; 224
    caf8:	97 e0       	ldi	r25, 0x07	; 7
    cafa:	6f e5       	ldi	r22, 0x5F	; 95
    cafc:	7b e0       	ldi	r23, 0x0B	; 11
    cafe:	44 e6       	ldi	r20, 0x64	; 100
    cb00:	0e 94 28 39 	call	0x7250	; 0x7250 <GetByteFromFIFO>

				if(GSM_RxCharN >= 90){
    cb04:	80 91 5f 0b 	lds	r24, 0x0B5F
    cb08:	8a 35       	cpi	r24, 0x5A	; 90
    cb0a:	70 f3       	brcs	.-36     	; 0xcae8 <GSM_Cycle+0x548>

					GSM_State = GSM_SEND_CSQ;
    cb0c:	10 93 f6 06 	sts	0x06F6, r17
    cb10:	eb cf       	rjmp	.-42     	; 0xcae8 <GSM_Cycle+0x548>
			}
			GSM_State++;	
			GSM_Temp = 0;
			break;
		case GSM_WAIT_ATD_Check_Ballance_OK:
			if(GSM_Wait_Response_P(RESP_OK,GSM_SEND_CSQ)) GSM_State++;
    cb12:	81 ef       	ldi	r24, 0xF1	; 241
    cb14:	93 e0       	ldi	r25, 0x03	; 3
    cb16:	6f e4       	ldi	r22, 0x4F	; 79
    cb18:	0e 94 df 4b 	call	0x97be	; 0x97be <GSM_Wait_Response_P>
    cb1c:	88 23       	and	r24, r24
    cb1e:	09 f4       	brne	.+2      	; 0xcb22 <GSM_Cycle+0x582>
    cb20:	5f cd       	rjmp	.-1346   	; 0xc5e0 <GSM_Cycle+0x40>
    cb22:	80 91 f6 06 	lds	r24, 0x06F6
    cb26:	8f 5f       	subi	r24, 0xFF	; 255
    cb28:	80 93 f6 06 	sts	0x06F6, r24
    cb2c:	59 cd       	rjmp	.-1358   	; 0xc5e0 <GSM_Cycle+0x40>
			}	
			break;

		//------------------------   GSM-
		case GSM_SEND_CSQ:
				GSM_Execute_Command(AT_CSQ, 500*GSM_DEBUG_DELAY); 
    cb2e:	8a ef       	ldi	r24, 0xFA	; 250
    cb30:	95 e0       	ldi	r25, 0x05	; 5
    cb32:	64 ef       	ldi	r22, 0xF4	; 244
    cb34:	71 e0       	ldi	r23, 0x01	; 1
    cb36:	0e 94 3a 4c 	call	0x9874	; 0x9874 <GSM_Execute_Command>
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    cb3a:	8f ef       	ldi	r24, 0xFF	; 255
    cb3c:	80 93 3e 07 	sts	0x073E, r24
	GSM_RX_FIFO_End = 255;
    cb40:	80 93 53 06 	sts	0x0653, r24
	GSM_RxCharN = 0;
    cb44:	10 92 5f 0b 	sts	0x0B5F, r1
	GSM_RX_FIFOOverFlow = 0;
    cb48:	10 92 12 09 	sts	0x0912, r1
	GSM_RX_FIFOMax = 0;
    cb4c:	10 92 18 09 	sts	0x0918, r1

		//------------------------   GSM-
		case GSM_SEND_CSQ:
				GSM_Execute_Command(AT_CSQ, 500*GSM_DEBUG_DELAY); 
				InitFIFO();
				GSM_State++;
    cb50:	80 91 f6 06 	lds	r24, 0x06F6
    cb54:	8f 5f       	subi	r24, 0xFF	; 255
    cb56:	80 93 f6 06 	sts	0x06F6, r24
    cb5a:	42 cd       	rjmp	.-1404   	; 0xc5e0 <GSM_Cycle+0x40>
			break;
		case GSM_WAIT_SMS_Inv:
			if(GSM_Wait_Char('>', GSM_ReStart1)) GSM_State++;
			break;
		case GSM_SEND_SMS_DATA:
			SMS_Data_Out[SMS_FlgSz_Out] = 0x1A;	// SMS Data end - char Ctrl-Z
    cb5c:	60 91 c8 07 	lds	r22, 0x07C8
    cb60:	e6 2f       	mov	r30, r22
    cb62:	f0 e0       	ldi	r31, 0x00	; 0
    cb64:	e6 5b       	subi	r30, 0xB6	; 182
    cb66:	f8 4f       	sbci	r31, 0xF8	; 248
    cb68:	8a e1       	ldi	r24, 0x1A	; 26
    cb6a:	80 83       	st	Z, r24
			GSM_SendData((uint8_t *)SMS_Data_Out, SMS_FlgSz_Out+1);
    cb6c:	6f 5f       	subi	r22, 0xFF	; 255
    cb6e:	8a e4       	ldi	r24, 0x4A	; 74
    cb70:	97 e0       	ldi	r25, 0x07	; 7
    cb72:	0e 94 bd 41 	call	0x837a	; 0x837a <GSM_SendData>
			GSM_State++;
    cb76:	80 91 f6 06 	lds	r24, 0x06F6
    cb7a:	8f 5f       	subi	r24, 0xFF	; 255
    cb7c:	80 93 f6 06 	sts	0x06F6, r24
    cb80:	2f cd       	rjmp	.-1442   	; 0xc5e0 <GSM_Cycle+0x40>
					}					
				}
			}
			break;
		case GSM_WAIT_SMS_Inv:
			if(GSM_Wait_Char('>', GSM_ReStart1)) GSM_State++;
    cb82:	8e e3       	ldi	r24, 0x3E	; 62
    cb84:	6a e4       	ldi	r22, 0x4A	; 74
    cb86:	0e 94 9a 3a 	call	0x7534	; 0x7534 <GSM_Wait_Char>
    cb8a:	88 23       	and	r24, r24
    cb8c:	09 f4       	brne	.+2      	; 0xcb90 <GSM_Cycle+0x5f0>
    cb8e:	28 cd       	rjmp	.-1456   	; 0xc5e0 <GSM_Cycle+0x40>
    cb90:	80 91 f6 06 	lds	r24, 0x06F6
    cb94:	8f 5f       	subi	r24, 0xFF	; 255
    cb96:	80 93 f6 06 	sts	0x06F6, r24
    cb9a:	22 cd       	rjmp	.-1468   	; 0xc5e0 <GSM_Cycle+0x40>
			}
			break;

		//------------------------
		case GSM_SEND_CMGS:
			if(GSM_Flag & (1<<flg_TxCStr)){			
    cb9c:	80 91 d2 02 	lds	r24, 0x02D2
    cba0:	80 ff       	sbrs	r24, 0
    cba2:	1e cd       	rjmp	.-1476   	; 0xc5e0 <GSM_Cycle+0x40>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    cba4:	49 e4       	ldi	r20, 0x49	; 73
    cba6:	e4 2e       	mov	r14, r20
    cba8:	4a e0       	ldi	r20, 0x0A	; 10
    cbaa:	f4 2e       	mov	r15, r20
    cbac:	60 91 dc 05 	lds	r22, 0x05DC
    cbb0:	8d e0       	ldi	r24, 0x0D	; 13
    cbb2:	68 9f       	mul	r22, r24
    cbb4:	b0 01       	movw	r22, r0
    cbb6:	11 24       	eor	r1, r1
    cbb8:	6b 53       	subi	r22, 0x3B	; 59
    cbba:	7f 4f       	sbci	r23, 0xFF	; 255
    cbbc:	c7 01       	movw	r24, r14
    cbbe:	4d e0       	ldi	r20, 0x0D	; 13
    cbc0:	50 e0       	ldi	r21, 0x00	; 0
    cbc2:	0e 94 07 84 	call	0x1080e	; 0x1080e <__eerd_block_m2560>
				erbl(GSM_TxStr, SMS_Number+TempNum, MaxTelephN);
				GSMTxSz = strlen(GSM_TxStr);
    cbc6:	f7 01       	movw	r30, r14
    cbc8:	01 90       	ld	r0, Z+
    cbca:	00 20       	and	r0, r0
    cbcc:	e9 f7       	brne	.-6      	; 0xcbc8 <GSM_Cycle+0x628>
    cbce:	31 97       	sbiw	r30, 0x01	; 1
    cbd0:	ee 19       	sub	r30, r14
    cbd2:	ff 09       	sbc	r31, r15
    cbd4:	e0 93 bb 07 	sts	0x07BB, r30
				uint8_t j=0;
				for(uint8_t i=0; i<GSMTxSz; i++)
    cbd8:	80 91 bb 07 	lds	r24, 0x07BB
    cbdc:	88 23       	and	r24, r24
    cbde:	99 f0       	breq	.+38     	; 0xcc06 <GSM_Cycle+0x666>
    cbe0:	90 e0       	ldi	r25, 0x00	; 0
    cbe2:	20 e0       	ldi	r18, 0x00	; 0
					if(GSM_TxStr[i] != '0') j++;
    cbe4:	e9 2f       	mov	r30, r25
    cbe6:	f0 e0       	ldi	r31, 0x00	; 0
    cbe8:	e7 5b       	subi	r30, 0xB7	; 183
    cbea:	f5 4f       	sbci	r31, 0xF5	; 245
    cbec:	80 81       	ld	r24, Z
    cbee:	80 33       	cpi	r24, 0x30	; 48
    cbf0:	09 f0       	breq	.+2      	; 0xcbf4 <GSM_Cycle+0x654>
    cbf2:	2f 5f       	subi	r18, 0xFF	; 255
		case GSM_SEND_CMGS:
			if(GSM_Flag & (1<<flg_TxCStr)){			
				erbl(GSM_TxStr, SMS_Number+TempNum, MaxTelephN);
				GSMTxSz = strlen(GSM_TxStr);
				uint8_t j=0;
				for(uint8_t i=0; i<GSMTxSz; i++)
    cbf4:	9f 5f       	subi	r25, 0xFF	; 255
    cbf6:	80 91 bb 07 	lds	r24, 0x07BB
    cbfa:	98 17       	cp	r25, r24
    cbfc:	98 f3       	brcs	.-26     	; 0xcbe4 <GSM_Cycle+0x644>
					if(GSM_TxStr[i] != '0') j++;
				if(j){
    cbfe:	22 23       	and	r18, r18
    cc00:	11 f0       	breq	.+4      	; 0xcc06 <GSM_Cycle+0x666>
    cc02:	0c 94 f5 6f 	jmp	0xdfea	; 0xdfea <GSM_Cycle+0x1a4a>
					GSM_SendFirstChar();
					StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
					GSM_State++;
				}
				else{
					TempNum++;
    cc06:	80 91 dc 05 	lds	r24, 0x05DC
    cc0a:	8f 5f       	subi	r24, 0xFF	; 255
    cc0c:	80 93 dc 05 	sts	0x05DC, r24
					if(TempNum>=MaxTelephDirSz){
    cc10:	83 30       	cpi	r24, 0x03	; 3
    cc12:	08 f4       	brcc	.+2      	; 0xcc16 <GSM_Cycle+0x676>
    cc14:	e5 cc       	rjmp	.-1590   	; 0xc5e0 <GSM_Cycle+0x40>
						//StartTimer16(TD_GSM,150);

						GSM_State = GSM_Return2dataMode;
    cc16:	87 e5       	ldi	r24, 0x57	; 87
    cc18:	80 93 f6 06 	sts	0x06F6, r24
				
						SMS_FlgSz_Out = 0;
    cc1c:	10 92 c8 07 	sts	0x07C8, r1
    cc20:	df cc       	rjmp	.-1602   	; 0xc5e0 <GSM_Cycle+0x40>
			break;

		case GSM_AnalyzeURC:			//  
			
			// 
			if( (strstr_P(GSM_RxStr, URC_CLOSED+2) != NULL) ){
    cc22:	00 ee       	ldi	r16, 0xE0	; 224
    cc24:	17 e0       	ldi	r17, 0x07	; 7
    cc26:	c8 01       	movw	r24, r16
    cc28:	64 ed       	ldi	r22, 0xD4	; 212
    cc2a:	73 e0       	ldi	r23, 0x03	; 3
    cc2c:	0e 94 1f 81 	call	0x1023e	; 0x1023e <strstr_P>
    cc30:	89 2b       	or	r24, r25
    cc32:	11 f4       	brne	.+4      	; 0xcc38 <GSM_Cycle+0x698>
    cc34:	0c 94 59 70 	jmp	0xe0b2	; 0xe0b2 <GSM_Cycle+0x1b12>
				GSM_State =GSM_ReStart1;
    cc38:	8a e4       	ldi	r24, 0x4A	; 74
    cc3a:	80 93 f6 06 	sts	0x06F6, r24
    cc3e:	d0 cc       	rjmp	.-1632   	; 0xc5e0 <GSM_Cycle+0x40>
		//------------------------


		//------------------------
		case GSM_CIPSHUT_:
			GSM_Execute_Command(AT_CIPSHUT, 1000*GSM_DEBUG_DELAY); GSM_State++;
    cc40:	84 ee       	ldi	r24, 0xE4	; 228
    cc42:	95 e0       	ldi	r25, 0x05	; 5
    cc44:	68 ee       	ldi	r22, 0xE8	; 232
    cc46:	73 e0       	ldi	r23, 0x03	; 3
    cc48:	0e 94 3a 4c 	call	0x9874	; 0x9874 <GSM_Execute_Command>
    cc4c:	80 91 f6 06 	lds	r24, 0x06F6
    cc50:	8f 5f       	subi	r24, 0xFF	; 255
    cc52:	80 93 f6 06 	sts	0x06F6, r24
    cc56:	c4 cc       	rjmp	.-1656   	; 0xc5e0 <GSM_Cycle+0x40>
			break;
		case GSM_ShutWait_:
			if(GSM_Wait_Response_P(RESP_SHUT_OK, GSM_ReStart1)) GSM_State++;
    cc58:	89 e4       	ldi	r24, 0x49	; 73
    cc5a:	94 e0       	ldi	r25, 0x04	; 4
    cc5c:	6a e4       	ldi	r22, 0x4A	; 74
    cc5e:	0e 94 df 4b 	call	0x97be	; 0x97be <GSM_Wait_Response_P>
    cc62:	88 23       	and	r24, r24
    cc64:	09 f4       	brne	.+2      	; 0xcc68 <GSM_Cycle+0x6c8>
    cc66:	bc cc       	rjmp	.-1672   	; 0xc5e0 <GSM_Cycle+0x40>
    cc68:	80 91 f6 06 	lds	r24, 0x06F6
    cc6c:	8f 5f       	subi	r24, 0xFF	; 255
    cc6e:	80 93 f6 06 	sts	0x06F6, r24
    cc72:	b6 cc       	rjmp	.-1684   	; 0xc5e0 <GSM_Cycle+0x40>
			SMS_Data_Out[SMS_FlgSz_Out] = 0x1A;	// SMS Data end - char Ctrl-Z
			GSM_SendData((uint8_t *)SMS_Data_Out, SMS_FlgSz_Out+1);
			GSM_State++;
			break;		
		case GSM_WAIT_CMGS_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    cc74:	81 ef       	ldi	r24, 0xF1	; 241
    cc76:	93 e0       	ldi	r25, 0x03	; 3
    cc78:	6a e4       	ldi	r22, 0x4A	; 74
    cc7a:	0e 94 df 4b 	call	0x97be	; 0x97be <GSM_Wait_Response_P>
    cc7e:	88 23       	and	r24, r24
    cc80:	09 f4       	brne	.+2      	; 0xcc84 <GSM_Cycle+0x6e4>
    cc82:	ae cc       	rjmp	.-1700   	; 0xc5e0 <GSM_Cycle+0x40>
				if(++TempNum>=MaxTelephDirSz){
    cc84:	80 91 dc 05 	lds	r24, 0x05DC
    cc88:	8f 5f       	subi	r24, 0xFF	; 255
    cc8a:	80 93 dc 05 	sts	0x05DC, r24
    cc8e:	83 30       	cpi	r24, 0x03	; 3
    cc90:	10 f4       	brcc	.+4      	; 0xcc96 <GSM_Cycle+0x6f6>
    cc92:	0c 94 b8 6f 	jmp	0xdf70	; 0xdf70 <GSM_Cycle+0x19d0>
					GSM_State = GSM_Return2dataMode;
    cc96:	87 e5       	ldi	r24, 0x57	; 87
    cc98:	80 93 f6 06 	sts	0x06F6, r24
					SMS_FlgSz_Out = 0;
    cc9c:	10 92 c8 07 	sts	0x07C8, r1
    cca0:	9f cc       	rjmp	.-1730   	; 0xc5e0 <GSM_Cycle+0x40>
				counter=1;

			}
			#endif	

			if(GetStringFromFIFO()){
    cca2:	0e 94 92 39 	call	0x7324	; 0x7324 <GetStringFromFIFO>
    cca6:	88 23       	and	r24, r24
    cca8:	09 f4       	brne	.+2      	; 0xccac <GSM_Cycle+0x70c>
    ccaa:	9a cc       	rjmp	.-1740   	; 0xc5e0 <GSM_Cycle+0x40>
				GSM_State = GSM_AnalyzeURC;
    ccac:	8f e3       	ldi	r24, 0x3F	; 63
    ccae:	80 93 f6 06 	sts	0x06F6, r24
				TempNum = 0;
    ccb2:	10 92 dc 05 	sts	0x05DC, r1
    ccb6:	94 cc       	rjmp	.-1752   	; 0xc5e0 <GSM_Cycle+0x40>
			GSM_SendFirstChar();
			GSM_State = GSM_WAIT_PLAY_CONFIRM_FILE_OK;
			StartTimer16(TD_GSM, 2000);
			break;
		case GSM_WAIT_PLAY_CONFIRM_FILE_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_WAIT_PLAY_CONFIRM_FILE_OK)) 
    ccb8:	81 ef       	ldi	r24, 0xF1	; 241
    ccba:	93 e0       	ldi	r25, 0x03	; 3
    ccbc:	6e e1       	ldi	r22, 0x1E	; 30
    ccbe:	0e 94 df 4b 	call	0x97be	; 0x97be <GSM_Wait_Response_P>
    ccc2:	88 23       	and	r24, r24
    ccc4:	09 f4       	brne	.+2      	; 0xccc8 <GSM_Cycle+0x728>
    ccc6:	8c cc       	rjmp	.-1768   	; 0xc5e0 <GSM_Cycle+0x40>
				{
					GSM_State = GSM_WAIT_PLAY_CONFIRM_FILE_CREC_0;
    ccc8:	8f e1       	ldi	r24, 0x1F	; 31
    ccca:	80 93 f6 06 	sts	0x06F6, r24
					StartTimer16(TD_GSM, 20000);
    ccce:	80 91 e9 04 	lds	r24, 0x04E9
    ccd2:	60 e2       	ldi	r22, 0x20	; 32
    ccd4:	7e e4       	ldi	r23, 0x4E	; 78
    ccd6:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
    ccda:	82 cc       	rjmp	.-1788   	; 0xc5e0 <GSM_Cycle+0x40>
			}

			break;

		case GSM_SEND_PLAY_CONFIRM_FILE: 
			ConfirmState = 1;
    ccdc:	81 e0       	ldi	r24, 0x01	; 1
    ccde:	80 93 e1 02 	sts	0x02E1, r24
			sprintf_P(GSM_TxStr, PSTR("AT+CREC=4,\"C:\\User\\Confirm.amr\",0,100\r"));
    cce2:	00 d0       	rcall	.+0      	; 0xcce4 <GSM_Cycle+0x744>
    cce4:	0f 92       	push	r0
    cce6:	89 e4       	ldi	r24, 0x49	; 73
    cce8:	9a e0       	ldi	r25, 0x0A	; 10
    ccea:	ed b7       	in	r30, 0x3d	; 61
    ccec:	fe b7       	in	r31, 0x3e	; 62
    ccee:	92 83       	std	Z+2, r25	; 0x02
    ccf0:	81 83       	std	Z+1, r24	; 0x01
    ccf2:	8d eb       	ldi	r24, 0xBD	; 189
    ccf4:	9d e2       	ldi	r25, 0x2D	; 45
    ccf6:	94 83       	std	Z+4, r25	; 0x04
    ccf8:	83 83       	std	Z+3, r24	; 0x03
    ccfa:	0e 94 1a 82 	call	0x10434	; 0x10434 <sprintf_P>
			GSMTxSz=38;
    ccfe:	86 e2       	ldi	r24, 0x26	; 38
    cd00:	80 93 bb 07 	sts	0x07BB, r24
			GSM_SendFirstChar();
    cd04:	0f 90       	pop	r0
    cd06:	0f 90       	pop	r0
    cd08:	0f 90       	pop	r0
    cd0a:	0f 90       	pop	r0
    cd0c:	0e 94 bc 3a 	call	0x7578	; 0x7578 <GSM_SendFirstChar>
			GSM_State = GSM_WAIT_PLAY_CONFIRM_FILE_OK;
    cd10:	8e e1       	ldi	r24, 0x1E	; 30
    cd12:	80 93 f6 06 	sts	0x06F6, r24
			StartTimer16(TD_GSM, 2000);
    cd16:	80 91 e9 04 	lds	r24, 0x04E9
    cd1a:	60 ed       	ldi	r22, 0xD0	; 208
    cd1c:	77 e0       	ldi	r23, 0x07	; 7
    cd1e:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
    cd22:	5e cc       	rjmp	.-1860   	; 0xc5e0 <GSM_Cycle+0x40>
			GSM_State = GSM_WAIT_CREC_0;
			StartTimer16(TD_GSM, 1000);
			GSM_SendFirstChar();
			break;
		case GSM_WAIT_CREC_0:
			if(GetStringFromFIFO()){
    cd24:	0e 94 92 39 	call	0x7324	; 0x7324 <GetStringFromFIFO>
    cd28:	88 23       	and	r24, r24
    cd2a:	09 f4       	brne	.+2      	; 0xcd2e <GSM_Cycle+0x78e>
    cd2c:	8c c6       	rjmp	.+3352   	; 0xda46 <GSM_Cycle+0x14a6>
				if((strstr_P(GSM_RxStr, PSTR("+CREC: 0")) != NULL) ){
    cd2e:	80 ee       	ldi	r24, 0xE0	; 224
    cd30:	97 e0       	ldi	r25, 0x07	; 7
    cd32:	64 ee       	ldi	r22, 0xE4	; 228
    cd34:	7d e2       	ldi	r23, 0x2D	; 45
    cd36:	0e 94 1f 81 	call	0x1023e	; 0x1023e <strstr_P>
    cd3a:	89 2b       	or	r24, r25
    cd3c:	09 f4       	brne	.+2      	; 0xcd40 <GSM_Cycle+0x7a0>
    cd3e:	83 c6       	rjmp	.+3334   	; 0xda46 <GSM_Cycle+0x14a6>
					GSM_State = GSM_SEND_PLAY_CONFIRM_FILE;
    cd40:	8d e1       	ldi	r24, 0x1D	; 29
    cd42:	80 93 f6 06 	sts	0x06F6, r24
    cd46:	4c cc       	rjmp	.-1896   	; 0xc5e0 <GSM_Cycle+0x40>
				}
			}

			break;
		case GSM_SEND_CREC_5:
			sprintf_P(GSM_TxStr, PSTR("AT+CREC=5\r"));
    cd48:	00 d0       	rcall	.+0      	; 0xcd4a <GSM_Cycle+0x7aa>
    cd4a:	0f 92       	push	r0
    cd4c:	89 e4       	ldi	r24, 0x49	; 73
    cd4e:	9a e0       	ldi	r25, 0x0A	; 10
    cd50:	ad b7       	in	r26, 0x3d	; 61
    cd52:	be b7       	in	r27, 0x3e	; 62
    cd54:	12 96       	adiw	r26, 0x02	; 2
    cd56:	9c 93       	st	X, r25
    cd58:	8e 93       	st	-X, r24
    cd5a:	11 97       	sbiw	r26, 0x01	; 1
    cd5c:	8d ee       	ldi	r24, 0xED	; 237
    cd5e:	9d e2       	ldi	r25, 0x2D	; 45
    cd60:	14 96       	adiw	r26, 0x04	; 4
    cd62:	9c 93       	st	X, r25
    cd64:	8e 93       	st	-X, r24
    cd66:	13 97       	sbiw	r26, 0x03	; 3
    cd68:	0e 94 1a 82 	call	0x10434	; 0x10434 <sprintf_P>
			GSMTxSz=10;
    cd6c:	8a e0       	ldi	r24, 0x0A	; 10
    cd6e:	80 93 bb 07 	sts	0x07BB, r24
			GSM_State = GSM_WAIT_CREC_0;
    cd72:	8c e1       	ldi	r24, 0x1C	; 28
    cd74:	80 93 f6 06 	sts	0x06F6, r24
			StartTimer16(TD_GSM, 1000);
    cd78:	0f 90       	pop	r0
    cd7a:	0f 90       	pop	r0
    cd7c:	0f 90       	pop	r0
    cd7e:	0f 90       	pop	r0
    cd80:	80 91 e9 04 	lds	r24, 0x04E9
    cd84:	68 ee       	ldi	r22, 0xE8	; 232
    cd86:	73 e0       	ldi	r23, 0x03	; 3
    cd88:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
			GSM_SendFirstChar();
    cd8c:	0e 94 bc 3a 	call	0x7578	; 0x7578 <GSM_SendFirstChar>
    cd90:	27 cc       	rjmp	.-1970   	; 0xc5e0 <GSM_Cycle+0x40>
			if(Timer16Stopp(TD_GSM)){
				GSM_State = GSM_WAIT_MESSAGE;
			}
			break;
		case GSM_WAIT_CONFIRMRESPONSE:
			if(GetStringFromFIFO()){
    cd92:	0e 94 92 39 	call	0x7324	; 0x7324 <GetStringFromFIFO>
    cd96:	88 23       	and	r24, r24
    cd98:	11 f0       	breq	.+4      	; 0xcd9e <GSM_Cycle+0x7fe>
    cd9a:	0c 94 83 6f 	jmp	0xdf06	; 0xdf06 <GSM_Cycle+0x1966>
						StartTimer16(TD_GSM,2000);
						GSM_State = GSM_WAIT_DISCONNECT_CAUSE;
						
					}
			}
			if(Timer16Stopp(TD_GSM)){
    cd9e:	80 91 e9 04 	lds	r24, 0x04E9
    cda2:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <Timer16Stopp>
    cda6:	88 23       	and	r24, r24
    cda8:	09 f4       	brne	.+2      	; 0xcdac <GSM_Cycle+0x80c>
    cdaa:	1a cc       	rjmp	.-1996   	; 0xc5e0 <GSM_Cycle+0x40>
				if(RequestRepeatCounter<4){
    cdac:	80 91 e2 02 	lds	r24, 0x02E2
    cdb0:	84 30       	cpi	r24, 0x04	; 4
    cdb2:	10 f0       	brcs	.+4      	; 0xcdb8 <GSM_Cycle+0x818>
    cdb4:	0c 94 b3 6f 	jmp	0xdf66	; 0xdf66 <GSM_Cycle+0x19c6>
				GSM_State = GSM_SEND_PLAY_ALARM_FILE;
    cdb8:	84 e1       	ldi	r24, 0x14	; 20
    cdba:	80 93 f6 06 	sts	0x06F6, r24
    cdbe:	10 cc       	rjmp	.-2016   	; 0xc5e0 <GSM_Cycle+0x40>
					GSM_State = GSM_WAIT_PLAY_CONFIRMREQUEST_FILE_CREC_0;
					StartTimer16(TD_GSM, 20000);
				}
			break;
		case GSM_WAIT_PLAY_CONFIRMREQUEST_FILE_CREC_0:
			if(GetStringFromFIFO()){
    cdc0:	0e 94 92 39 	call	0x7324	; 0x7324 <GetStringFromFIFO>
    cdc4:	88 23       	and	r24, r24
    cdc6:	09 f4       	brne	.+2      	; 0xcdca <GSM_Cycle+0x82a>
    cdc8:	51 c6       	rjmp	.+3234   	; 0xda6c <GSM_Cycle+0x14cc>
				if((strstr_P(GSM_RxStr, PSTR("+CREC: 0")) != NULL) ){
    cdca:	80 ee       	ldi	r24, 0xE0	; 224
    cdcc:	97 e0       	ldi	r25, 0x07	; 7
    cdce:	68 e2       	ldi	r22, 0x28	; 40
    cdd0:	7e e2       	ldi	r23, 0x2E	; 46
    cdd2:	0e 94 1f 81 	call	0x1023e	; 0x1023e <strstr_P>
    cdd6:	89 2b       	or	r24, r25
    cdd8:	09 f4       	brne	.+2      	; 0xcddc <GSM_Cycle+0x83c>
    cdda:	42 c6       	rjmp	.+3204   	; 0xda60 <GSM_Cycle+0x14c0>
					GSM_State = GSM_WAIT_CONFIRMRESPONSE;
    cddc:	8a e1       	ldi	r24, 0x1A	; 26
    cdde:	80 93 f6 06 	sts	0x06F6, r24
					StartTimer16(TD_GSM, 200);
    cde2:	80 91 e9 04 	lds	r24, 0x04E9
    cde6:	68 ec       	ldi	r22, 0xC8	; 200
    cde8:	70 e0       	ldi	r23, 0x00	; 0
    cdea:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
    cdee:	f8 cb       	rjmp	.-2064   	; 0xc5e0 <GSM_Cycle+0x40>
			GSM_SendFirstChar();
			GSM_State = GSM_WAIT_PLAY_CONFIRMREQUEST_FILE_OK;
			StartTimer16(TD_GSM, 1000);
			break;
		case GSM_WAIT_PLAY_CONFIRMREQUEST_FILE_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_WAIT_MESSAGE)) 
    cdf0:	81 ef       	ldi	r24, 0xF1	; 241
    cdf2:	93 e0       	ldi	r25, 0x03	; 3
    cdf4:	6e e0       	ldi	r22, 0x0E	; 14
    cdf6:	0e 94 df 4b 	call	0x97be	; 0x97be <GSM_Wait_Response_P>
    cdfa:	88 23       	and	r24, r24
    cdfc:	09 f4       	brne	.+2      	; 0xce00 <GSM_Cycle+0x860>
    cdfe:	f0 cb       	rjmp	.-2080   	; 0xc5e0 <GSM_Cycle+0x40>
				{
					GSM_State = GSM_WAIT_PLAY_CONFIRMREQUEST_FILE_CREC_0;
    ce00:	89 e1       	ldi	r24, 0x19	; 25
    ce02:	80 93 f6 06 	sts	0x06F6, r24
					StartTimer16(TD_GSM, 20000);
    ce06:	80 91 e9 04 	lds	r24, 0x04E9
    ce0a:	60 e2       	ldi	r22, 0x20	; 32
    ce0c:	7e e4       	ldi	r23, 0x4E	; 78
    ce0e:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
    ce12:	e6 cb       	rjmp	.-2100   	; 0xc5e0 <GSM_Cycle+0x40>
			if(Timer16Stopp(TD_GSM)){
				GSM_State = GSM_WAIT_MESSAGE;
			}
			break;
		case GSM_SEND_PLAY_CONFIRMREQUEST_FILE: 
			sprintf_P(GSM_TxStr, PSTR("AT+CREC=4,\"C:\\User\\ConfirmRequest.amr\",0,100\r"));
    ce14:	00 d0       	rcall	.+0      	; 0xce16 <GSM_Cycle+0x876>
    ce16:	0f 92       	push	r0
    ce18:	89 e4       	ldi	r24, 0x49	; 73
    ce1a:	9a e0       	ldi	r25, 0x0A	; 10
    ce1c:	ed b7       	in	r30, 0x3d	; 61
    ce1e:	fe b7       	in	r31, 0x3e	; 62
    ce20:	92 83       	std	Z+2, r25	; 0x02
    ce22:	81 83       	std	Z+1, r24	; 0x01
    ce24:	81 e3       	ldi	r24, 0x31	; 49
    ce26:	9e e2       	ldi	r25, 0x2E	; 46
    ce28:	94 83       	std	Z+4, r25	; 0x04
    ce2a:	83 83       	std	Z+3, r24	; 0x03
    ce2c:	0e 94 1a 82 	call	0x10434	; 0x10434 <sprintf_P>
			GSMTxSz=45;
    ce30:	8d e2       	ldi	r24, 0x2D	; 45
    ce32:	80 93 bb 07 	sts	0x07BB, r24
			GSM_SendFirstChar();
    ce36:	0f 90       	pop	r0
    ce38:	0f 90       	pop	r0
    ce3a:	0f 90       	pop	r0
    ce3c:	0f 90       	pop	r0
    ce3e:	0e 94 bc 3a 	call	0x7578	; 0x7578 <GSM_SendFirstChar>
			GSM_State = GSM_WAIT_PLAY_CONFIRMREQUEST_FILE_OK;
    ce42:	88 e1       	ldi	r24, 0x18	; 24
    ce44:	80 93 f6 06 	sts	0x06F6, r24
			StartTimer16(TD_GSM, 1000);
    ce48:	80 91 e9 04 	lds	r24, 0x04E9
    ce4c:	68 ee       	ldi	r22, 0xE8	; 232
    ce4e:	73 e0       	ldi	r23, 0x03	; 3
    ce50:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
    ce54:	c5 cb       	rjmp	.-2166   	; 0xc5e0 <GSM_Cycle+0x40>
					GSM_State = GSM_WAIT_PLAY_ALARM_FILE_CREC_0;
					StartTimer16(TD_GSM, 20000);
				}
			break;
		case GSM_WAIT_PLAY_ALARM_FILE_CREC_0:
			if(GetStringFromFIFO()){
    ce56:	0e 94 92 39 	call	0x7324	; 0x7324 <GetStringFromFIFO>
    ce5a:	88 23       	and	r24, r24
    ce5c:	09 f4       	brne	.+2      	; 0xce60 <GSM_Cycle+0x8c0>
    ce5e:	19 c6       	rjmp	.+3122   	; 0xda92 <GSM_Cycle+0x14f2>
				if((strstr_P(GSM_RxStr, PSTR("+CREC: 0")) != NULL) ){
    ce60:	80 ee       	ldi	r24, 0xE0	; 224
    ce62:	97 e0       	ldi	r25, 0x07	; 7
    ce64:	6f e5       	ldi	r22, 0x5F	; 95
    ce66:	7e e2       	ldi	r23, 0x2E	; 46
    ce68:	0e 94 1f 81 	call	0x1023e	; 0x1023e <strstr_P>
    ce6c:	89 2b       	or	r24, r25
    ce6e:	09 f4       	brne	.+2      	; 0xce72 <GSM_Cycle+0x8d2>
    ce70:	0a c6       	rjmp	.+3092   	; 0xda86 <GSM_Cycle+0x14e6>
					GSM_State = GSM_SEND_PLAY_CONFIRMREQUEST_FILE;
    ce72:	87 e1       	ldi	r24, 0x17	; 23
    ce74:	80 93 f6 06 	sts	0x06F6, r24
    ce78:	b3 cb       	rjmp	.-2202   	; 0xc5e0 <GSM_Cycle+0x40>
			GSM_SendFirstChar();
			GSM_State = GSM_WAIT_PLAY_ALARM_FILE_OK;
			StartTimer16(TD_GSM, 1000);
			break;
		case GSM_WAIT_PLAY_ALARM_FILE_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_WAIT_MESSAGE)) 
    ce7a:	81 ef       	ldi	r24, 0xF1	; 241
    ce7c:	93 e0       	ldi	r25, 0x03	; 3
    ce7e:	6e e0       	ldi	r22, 0x0E	; 14
    ce80:	0e 94 df 4b 	call	0x97be	; 0x97be <GSM_Wait_Response_P>
    ce84:	88 23       	and	r24, r24
    ce86:	09 f4       	brne	.+2      	; 0xce8a <GSM_Cycle+0x8ea>
    ce88:	ab cb       	rjmp	.-2218   	; 0xc5e0 <GSM_Cycle+0x40>
				{
					GSM_State = GSM_WAIT_PLAY_ALARM_FILE_CREC_0;
    ce8a:	86 e1       	ldi	r24, 0x16	; 22
    ce8c:	80 93 f6 06 	sts	0x06F6, r24
					StartTimer16(TD_GSM, 20000);
    ce90:	80 91 e9 04 	lds	r24, 0x04E9
    ce94:	60 e2       	ldi	r22, 0x20	; 32
    ce96:	7e e4       	ldi	r23, 0x4E	; 78
    ce98:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
    ce9c:	a1 cb       	rjmp	.-2238   	; 0xc5e0 <GSM_Cycle+0x40>
			if(Timer16Stopp(TD_GSM)){
				GSM_State = GSM_WAIT_MESSAGE;
			}
			break;
		case GSM_WAIT_CCLC_3:
			if(GetStringFromFIFO()){
    ce9e:	0e 94 92 39 	call	0x7324	; 0x7324 <GetStringFromFIFO>
    cea2:	88 23       	and	r24, r24
    cea4:	09 f4       	brne	.+2      	; 0xcea8 <GSM_Cycle+0x908>
    cea6:	79 c6       	rjmp	.+3314   	; 0xdb9a <GSM_Cycle+0x15fa>
				if( (strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 2,0,6,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 3,0,6,")) != NULL) ){
    cea8:	80 ee       	ldi	r24, 0xE0	; 224
    ceaa:	97 e0       	ldi	r25, 0x07	; 7
    ceac:	68 e2       	ldi	r22, 0x28	; 40
    ceae:	7f e2       	ldi	r23, 0x2F	; 47
    ceb0:	0e 94 1f 81 	call	0x1023e	; 0x1023e <strstr_P>
    ceb4:	89 2b       	or	r24, r25
    ceb6:	11 f4       	brne	.+4      	; 0xcebc <GSM_Cycle+0x91c>
    ceb8:	0c 94 77 70 	jmp	0xe0ee	; 0xe0ee <GSM_Cycle+0x1b4e>
					StartTimer16(TD_GSM, 6000);
    cebc:	80 91 e9 04 	lds	r24, 0x04E9
    cec0:	60 e7       	ldi	r22, 0x70	; 112
    cec2:	77 e1       	ldi	r23, 0x17	; 23
    cec4:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
					GSM_State = GSM_WAIT_MESSAGE;
    cec8:	8e e0       	ldi	r24, 0x0E	; 14
    ceca:	80 93 f6 06 	sts	0x06F6, r24
    cece:	88 cb       	rjmp	.-2288   	; 0xc5e0 <GSM_Cycle+0x40>
		case GSM_WAIT_ATD_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_WAIT_MESSAGE)) GSM_State = GSM_WAIT_CCLC_2;
			StartTimer16(TD_GSM, 1000);
			break;
		case GSM_WAIT_CCLC_2:
			if(GetStringFromFIFO()){
    ced0:	0e 94 92 39 	call	0x7324	; 0x7324 <GetStringFromFIFO>
    ced4:	88 23       	and	r24, r24
    ced6:	09 f4       	brne	.+2      	; 0xceda <GSM_Cycle+0x93a>
    ced8:	41 c6       	rjmp	.+3202   	; 0xdb5c <GSM_Cycle+0x15bc>
				if( (strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,2,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 2,0,2,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 3,0,2,")) != NULL) ){
    ceda:	80 ee       	ldi	r24, 0xE0	; 224
    cedc:	97 e0       	ldi	r25, 0x07	; 7
    cede:	62 e5       	ldi	r22, 0x52	; 82
    cee0:	7f e2       	ldi	r23, 0x2F	; 47
    cee2:	0e 94 1f 81 	call	0x1023e	; 0x1023e <strstr_P>
    cee6:	89 2b       	or	r24, r25
    cee8:	09 f4       	brne	.+2      	; 0xceec <GSM_Cycle+0x94c>
    ceea:	26 c6       	rjmp	.+3148   	; 0xdb38 <GSM_Cycle+0x1598>
					StartTimer16(TD_GSM, 2000);
    ceec:	80 91 e9 04 	lds	r24, 0x04E9
    cef0:	60 ed       	ldi	r22, 0xD0	; 208
    cef2:	77 e0       	ldi	r23, 0x07	; 7
    cef4:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
					GSM_State = GSM_WAIT_CCLC_3;
    cef8:	82 e1       	ldi	r24, 0x12	; 18
    cefa:	80 93 f6 06 	sts	0x06F6, r24
    cefe:	70 cb       	rjmp	.-2336   	; 0xc5e0 <GSM_Cycle+0x40>
			if(Timer16Stopp(TD_GSM)){
				GSM_State = GSM_WAIT_MESSAGE;
			}
			break;
		case GSM_SEND_PLAY_ALARM_FILE: 
			RequestRepeatCounter++;
    cf00:	80 91 e2 02 	lds	r24, 0x02E2
    cf04:	8f 5f       	subi	r24, 0xFF	; 255
    cf06:	80 93 e2 02 	sts	0x02E2, r24
			sprintf_P(GSM_TxStr, PSTR("AT+CREC=4,\"C:\\User\\Alarm"));
    cf0a:	00 d0       	rcall	.+0      	; 0xcf0c <GSM_Cycle+0x96c>
    cf0c:	0f 92       	push	r0
    cf0e:	b9 e4       	ldi	r27, 0x49	; 73
    cf10:	eb 2e       	mov	r14, r27
    cf12:	ba e0       	ldi	r27, 0x0A	; 10
    cf14:	fb 2e       	mov	r15, r27
    cf16:	ad b7       	in	r26, 0x3d	; 61
    cf18:	be b7       	in	r27, 0x3e	; 62
    cf1a:	12 96       	adiw	r26, 0x02	; 2
    cf1c:	fc 92       	st	X, r15
    cf1e:	ee 92       	st	-X, r14
    cf20:	11 97       	sbiw	r26, 0x01	; 1
    cf22:	85 e7       	ldi	r24, 0x75	; 117
    cf24:	9e e2       	ldi	r25, 0x2E	; 46
    cf26:	14 96       	adiw	r26, 0x04	; 4
    cf28:	9c 93       	st	X, r25
    cf2a:	8e 93       	st	-X, r24
    cf2c:	13 97       	sbiw	r26, 0x03	; 3
    cf2e:	0e 94 1a 82 	call	0x10434	; 0x10434 <sprintf_P>
			GSMTxSz=24;
    cf32:	88 e1       	ldi	r24, 0x18	; 24
    cf34:	80 93 bb 07 	sts	0x07BB, r24
			sprintf(GSM_TxStr+GSMTxSz,"%u",Message[2]);
    cf38:	80 91 bb 07 	lds	r24, 0x07BB
    cf3c:	0f 92       	push	r0
    cf3e:	0f 92       	push	r0
    cf40:	ed b7       	in	r30, 0x3d	; 61
    cf42:	fe b7       	in	r31, 0x3e	; 62
    cf44:	31 96       	adiw	r30, 0x01	; 1
    cf46:	90 e0       	ldi	r25, 0x00	; 0
    cf48:	8e 0d       	add	r24, r14
    cf4a:	9f 1d       	adc	r25, r15
    cf4c:	ad b7       	in	r26, 0x3d	; 61
    cf4e:	be b7       	in	r27, 0x3e	; 62
    cf50:	12 96       	adiw	r26, 0x02	; 2
    cf52:	9c 93       	st	X, r25
    cf54:	8e 93       	st	-X, r24
    cf56:	11 97       	sbiw	r26, 0x01	; 1
    cf58:	82 eb       	ldi	r24, 0xB2	; 178
    cf5a:	92 e0       	ldi	r25, 0x02	; 2
    cf5c:	93 83       	std	Z+3, r25	; 0x03
    cf5e:	82 83       	std	Z+2, r24	; 0x02
    cf60:	80 91 37 07 	lds	r24, 0x0737
    cf64:	84 83       	std	Z+4, r24	; 0x04
    cf66:	15 82       	std	Z+5, r1	; 0x05
    cf68:	0e 94 e9 81 	call	0x103d2	; 0x103d2 <sprintf>
			if(Message[2]>9){
    cf6c:	ed b7       	in	r30, 0x3d	; 61
    cf6e:	fe b7       	in	r31, 0x3e	; 62
    cf70:	36 96       	adiw	r30, 0x06	; 6
    cf72:	0f b6       	in	r0, 0x3f	; 63
    cf74:	f8 94       	cli
    cf76:	fe bf       	out	0x3e, r31	; 62
    cf78:	0f be       	out	0x3f, r0	; 63
    cf7a:	ed bf       	out	0x3d, r30	; 61
    cf7c:	80 91 37 07 	lds	r24, 0x0737
    cf80:	8a 30       	cpi	r24, 0x0A	; 10
    cf82:	08 f4       	brcc	.+2      	; 0xcf86 <GSM_Cycle+0x9e6>
    cf84:	36 c6       	rjmp	.+3180   	; 0xdbf2 <GSM_Cycle+0x1652>
				GSMTxSz+=2;
    cf86:	80 91 bb 07 	lds	r24, 0x07BB
    cf8a:	8e 5f       	subi	r24, 0xFE	; 254
    cf8c:	80 93 bb 07 	sts	0x07BB, r24
			}
			else{
				GSMTxSz++;
			};
			sprintf_P(GSM_TxStr+GSMTxSz, PSTR(".amr\",0,100\r"));
    cf90:	80 91 bb 07 	lds	r24, 0x07BB
    cf94:	00 d0       	rcall	.+0      	; 0xcf96 <GSM_Cycle+0x9f6>
    cf96:	0f 92       	push	r0
    cf98:	90 e0       	ldi	r25, 0x00	; 0
    cf9a:	87 5b       	subi	r24, 0xB7	; 183
    cf9c:	95 4f       	sbci	r25, 0xF5	; 245
    cf9e:	ad b7       	in	r26, 0x3d	; 61
    cfa0:	be b7       	in	r27, 0x3e	; 62
    cfa2:	12 96       	adiw	r26, 0x02	; 2
    cfa4:	9c 93       	st	X, r25
    cfa6:	8e 93       	st	-X, r24
    cfa8:	11 97       	sbiw	r26, 0x01	; 1
    cfaa:	88 e6       	ldi	r24, 0x68	; 104
    cfac:	9e e2       	ldi	r25, 0x2E	; 46
    cfae:	14 96       	adiw	r26, 0x04	; 4
    cfb0:	9c 93       	st	X, r25
    cfb2:	8e 93       	st	-X, r24
    cfb4:	13 97       	sbiw	r26, 0x03	; 3
    cfb6:	0e 94 1a 82 	call	0x10434	; 0x10434 <sprintf_P>
			GSMTxSz += 12;
    cfba:	80 91 bb 07 	lds	r24, 0x07BB
    cfbe:	84 5f       	subi	r24, 0xF4	; 244
    cfc0:	80 93 bb 07 	sts	0x07BB, r24
			GSM_SendFirstChar();
    cfc4:	0f 90       	pop	r0
    cfc6:	0f 90       	pop	r0
    cfc8:	0f 90       	pop	r0
    cfca:	0f 90       	pop	r0
    cfcc:	0e 94 bc 3a 	call	0x7578	; 0x7578 <GSM_SendFirstChar>
			GSM_State = GSM_WAIT_PLAY_ALARM_FILE_OK;
    cfd0:	85 e1       	ldi	r24, 0x15	; 21
    cfd2:	80 93 f6 06 	sts	0x06F6, r24
			StartTimer16(TD_GSM, 1000);
    cfd6:	80 91 e9 04 	lds	r24, 0x04E9
    cfda:	68 ee       	ldi	r22, 0xE8	; 232
    cfdc:	73 e0       	ldi	r23, 0x03	; 3
    cfde:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
    cfe2:	fe ca       	rjmp	.-2564   	; 0xc5e0 <GSM_Cycle+0x40>
			if(Timer16Stopp(TD_GSM)){
				GSM_State = GSM_WAIT_MESSAGE;
			}
			break;
		case GSM_WAIT_CCLC_0:
			if(GetStringFromFIFO()){
    cfe4:	0e 94 92 39 	call	0x7324	; 0x7324 <GetStringFromFIFO>
    cfe8:	88 23       	and	r24, r24
    cfea:	09 f4       	brne	.+2      	; 0xcfee <GSM_Cycle+0xa4e>
    cfec:	f5 c5       	rjmp	.+3050   	; 0xdbd8 <GSM_Cycle+0x1638>
				if((strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,0,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,0,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,0,")) != NULL) ){
    cfee:	80 ee       	ldi	r24, 0xE0	; 224
    cff0:	97 e0       	ldi	r25, 0x07	; 7
    cff2:	64 ed       	ldi	r22, 0xD4	; 212
    cff4:	7e e2       	ldi	r23, 0x2E	; 46
    cff6:	0e 94 1f 81 	call	0x1023e	; 0x1023e <strstr_P>
    cffa:	89 2b       	or	r24, r25
    cffc:	11 f4       	brne	.+4      	; 0xd002 <GSM_Cycle+0xa62>
    cffe:	0c 94 c1 70 	jmp	0xe182	; 0xe182 <GSM_Cycle+0x1be2>
					RequestRepeatCounter = 0;
    d002:	10 92 e2 02 	sts	0x02E2, r1
					GSM_State = GSM_SEND_PLAY_ALARM_FILE;
    d006:	84 e1       	ldi	r24, 0x14	; 20
    d008:	80 93 f6 06 	sts	0x06F6, r24
    d00c:	e9 ca       	rjmp	.-2606   	; 0xc5e0 <GSM_Cycle+0x40>
			GSM_SendFirstChar();
			GSM_State = GSM_WAIT_ATD_OK;
			StartTimer16(TD_GSM, 1000);
			break;
		case GSM_WAIT_ATD_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_WAIT_MESSAGE)) GSM_State = GSM_WAIT_CCLC_2;
    d00e:	81 ef       	ldi	r24, 0xF1	; 241
    d010:	93 e0       	ldi	r25, 0x03	; 3
    d012:	6e e0       	ldi	r22, 0x0E	; 14
    d014:	0e 94 df 4b 	call	0x97be	; 0x97be <GSM_Wait_Response_P>
    d018:	88 23       	and	r24, r24
    d01a:	19 f0       	breq	.+6      	; 0xd022 <GSM_Cycle+0xa82>
    d01c:	81 e1       	ldi	r24, 0x11	; 17
    d01e:	80 93 f6 06 	sts	0x06F6, r24
			StartTimer16(TD_GSM, 1000);
    d022:	80 91 e9 04 	lds	r24, 0x04E9
    d026:	68 ee       	ldi	r22, 0xE8	; 232
    d028:	73 e0       	ldi	r23, 0x03	; 3
    d02a:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
    d02e:	d8 ca       	rjmp	.-2640   	; 0xc5e0 <GSM_Cycle+0x40>
				break;
			}
			TransmitterState = 0;
			break;
		case GSM_SEND_ATD:
			sprintf_P(GSM_TxStr, ATD_PLUS);	GSMTxSz = strlen_P(ATD_PLUS);
    d030:	00 d0       	rcall	.+0      	; 0xd032 <GSM_Cycle+0xa92>
    d032:	0f 92       	push	r0
    d034:	89 e4       	ldi	r24, 0x49	; 73
    d036:	9a e0       	ldi	r25, 0x0A	; 10
    d038:	ad b7       	in	r26, 0x3d	; 61
    d03a:	be b7       	in	r27, 0x3e	; 62
    d03c:	12 96       	adiw	r26, 0x02	; 2
    d03e:	9c 93       	st	X, r25
    d040:	8e 93       	st	-X, r24
    d042:	11 97       	sbiw	r26, 0x01	; 1
    d044:	02 ec       	ldi	r16, 0xC2	; 194
    d046:	14 e0       	ldi	r17, 0x04	; 4
    d048:	14 96       	adiw	r26, 0x04	; 4
    d04a:	1c 93       	st	X, r17
    d04c:	0e 93       	st	-X, r16
    d04e:	13 97       	sbiw	r26, 0x03	; 3
    d050:	0e 94 1a 82 	call	0x10434	; 0x10434 <sprintf_P>
    d054:	0f 90       	pop	r0
    d056:	0f 90       	pop	r0
    d058:	0f 90       	pop	r0
    d05a:	0f 90       	pop	r0
    d05c:	c8 01       	movw	r24, r16
    d05e:	0e 94 fd 80 	call	0x101fa	; 0x101fa <strlen_P>
    d062:	80 93 bb 07 	sts	0x07BB, r24
			erbl(GSM_TxStr+GSMTxSz, CALL_Number+Message[1], MaxTelephN);
    d066:	80 91 bb 07 	lds	r24, 0x07BB
    d06a:	90 e0       	ldi	r25, 0x00	; 0
    d06c:	60 91 36 07 	lds	r22, 0x0736
    d070:	2d e0       	ldi	r18, 0x0D	; 13
    d072:	62 9f       	mul	r22, r18
    d074:	b0 01       	movw	r22, r0
    d076:	11 24       	eor	r1, r1
    d078:	64 51       	subi	r22, 0x14	; 20
    d07a:	7f 4f       	sbci	r23, 0xFF	; 255
    d07c:	87 5b       	subi	r24, 0xB7	; 183
    d07e:	95 4f       	sbci	r25, 0xF5	; 245
    d080:	4d e0       	ldi	r20, 0x0D	; 13
    d082:	50 e0       	ldi	r21, 0x00	; 0
    d084:	0e 94 07 84 	call	0x1080e	; 0x1080e <__eerd_block_m2560>
			GSMTxSz+=MaxTelephN-1;
    d088:	80 91 bb 07 	lds	r24, 0x07BB
    d08c:	84 5f       	subi	r24, 0xF4	; 244
    d08e:	80 93 bb 07 	sts	0x07BB, r24
			const char c=';';
    d092:	8b e3       	ldi	r24, 0x3B	; 59
    d094:	89 83       	std	Y+1, r24	; 0x01
			sprintf(GSM_TxStr+GSMTxSz,&c);GSMTxSz++;
    d096:	80 91 bb 07 	lds	r24, 0x07BB
    d09a:	00 d0       	rcall	.+0      	; 0xd09c <GSM_Cycle+0xafc>
    d09c:	0f 92       	push	r0
    d09e:	90 e0       	ldi	r25, 0x00	; 0
    d0a0:	87 5b       	subi	r24, 0xB7	; 183
    d0a2:	95 4f       	sbci	r25, 0xF5	; 245
    d0a4:	ed b7       	in	r30, 0x3d	; 61
    d0a6:	fe b7       	in	r31, 0x3e	; 62
    d0a8:	92 83       	std	Z+2, r25	; 0x02
    d0aa:	81 83       	std	Z+1, r24	; 0x01
    d0ac:	ce 01       	movw	r24, r28
    d0ae:	01 96       	adiw	r24, 0x01	; 1
    d0b0:	94 83       	std	Z+4, r25	; 0x04
    d0b2:	83 83       	std	Z+3, r24	; 0x03
    d0b4:	0e 94 e9 81 	call	0x103d2	; 0x103d2 <sprintf>
    d0b8:	80 91 bb 07 	lds	r24, 0x07BB
    d0bc:	8f 5f       	subi	r24, 0xFF	; 255
    d0be:	80 93 bb 07 	sts	0x07BB, r24
			sprintf(GSM_TxStr + GSMTxSz, "\r");	GSMTxSz = GSMTxSz+1;
    d0c2:	e0 91 bb 07 	lds	r30, 0x07BB
    d0c6:	f0 e0       	ldi	r31, 0x00	; 0
    d0c8:	e7 5b       	subi	r30, 0xB7	; 183
    d0ca:	f5 4f       	sbci	r31, 0xF5	; 245
    d0cc:	8d e0       	ldi	r24, 0x0D	; 13
    d0ce:	90 e0       	ldi	r25, 0x00	; 0
    d0d0:	91 83       	std	Z+1, r25	; 0x01
    d0d2:	80 83       	st	Z, r24
    d0d4:	80 91 bb 07 	lds	r24, 0x07BB
    d0d8:	8f 5f       	subi	r24, 0xFF	; 255
    d0da:	80 93 bb 07 	sts	0x07BB, r24
			GSM_SendFirstChar();
    d0de:	0f 90       	pop	r0
    d0e0:	0f 90       	pop	r0
    d0e2:	0f 90       	pop	r0
    d0e4:	0f 90       	pop	r0
    d0e6:	0e 94 bc 3a 	call	0x7578	; 0x7578 <GSM_SendFirstChar>
			GSM_State = GSM_WAIT_ATD_OK;
    d0ea:	80 e1       	ldi	r24, 0x10	; 16
    d0ec:	80 93 f6 06 	sts	0x06F6, r24
			StartTimer16(TD_GSM, 1000);
    d0f0:	80 91 e9 04 	lds	r24, 0x04E9
    d0f4:	68 ee       	ldi	r22, 0xE8	; 232
    d0f6:	73 e0       	ldi	r23, 0x03	; 3
    d0f8:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
    d0fc:	71 ca       	rjmp	.-2846   	; 0xc5e0 <GSM_Cycle+0x40>
		case GSM_WAIT_DDET101_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;
		case GSM_WAIT_MESSAGE:
			
			if(Message[0]==1)
    d0fe:	80 91 35 07 	lds	r24, 0x0735
    d102:	81 30       	cpi	r24, 0x01	; 1
    d104:	09 f4       	brne	.+2      	; 0xd108 <GSM_Cycle+0xb68>
    d106:	24 c7       	rjmp	.+3656   	; 0xdf50 <GSM_Cycle+0x19b0>
				ConfirmState = 0;
				TransmitterState = 1;
				GSM_State = GSM_SEND_ATD;
				break;
			}
			TransmitterState = 0;
    d108:	10 92 e3 02 	sts	0x02E3, r1
    d10c:	69 ca       	rjmp	.-2862   	; 0xc5e0 <GSM_Cycle+0x40>
			break;
		case GSM_SEND_DDET101:
			GSM_Execute_Command(AT_DDET101,100*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_DDET101_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    d10e:	81 ef       	ldi	r24, 0xF1	; 241
    d110:	93 e0       	ldi	r25, 0x03	; 3
    d112:	6a e4       	ldi	r22, 0x4A	; 74
    d114:	0e 94 df 4b 	call	0x97be	; 0x97be <GSM_Wait_Response_P>
    d118:	88 23       	and	r24, r24
    d11a:	09 f4       	brne	.+2      	; 0xd11e <GSM_Cycle+0xb7e>
    d11c:	61 ca       	rjmp	.-2878   	; 0xc5e0 <GSM_Cycle+0x40>
    d11e:	80 91 f6 06 	lds	r24, 0x06F6
    d122:	8f 5f       	subi	r24, 0xFF	; 255
    d124:	80 93 f6 06 	sts	0x06F6, r24
    d128:	5b ca       	rjmp	.-2890   	; 0xc5e0 <GSM_Cycle+0x40>
			break;
		case GSM_WAIT_CLCC_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;
		case GSM_SEND_DDET101:
			GSM_Execute_Command(AT_DDET101,100*GSM_DEBUG_DELAY); GSM_State++;
    d12a:	80 e9       	ldi	r24, 0x90	; 144
    d12c:	94 e0       	ldi	r25, 0x04	; 4
    d12e:	64 e6       	ldi	r22, 0x64	; 100
    d130:	70 e0       	ldi	r23, 0x00	; 0
    d132:	0e 94 3a 4c 	call	0x9874	; 0x9874 <GSM_Execute_Command>
    d136:	80 91 f6 06 	lds	r24, 0x06F6
    d13a:	8f 5f       	subi	r24, 0xFF	; 255
    d13c:	80 93 f6 06 	sts	0x06F6, r24
    d140:	4f ca       	rjmp	.-2914   	; 0xc5e0 <GSM_Cycle+0x40>
			break;
		case GSM_SEND_CLCC1:
			GSM_Execute_Command(AT_CLCC1,100*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CLCC_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    d142:	81 ef       	ldi	r24, 0xF1	; 241
    d144:	93 e0       	ldi	r25, 0x03	; 3
    d146:	6a e4       	ldi	r22, 0x4A	; 74
    d148:	0e 94 df 4b 	call	0x97be	; 0x97be <GSM_Wait_Response_P>
    d14c:	88 23       	and	r24, r24
    d14e:	09 f4       	brne	.+2      	; 0xd152 <GSM_Cycle+0xbb2>
    d150:	47 ca       	rjmp	.-2930   	; 0xc5e0 <GSM_Cycle+0x40>
    d152:	80 91 f6 06 	lds	r24, 0x06F6
    d156:	8f 5f       	subi	r24, 0xFF	; 255
    d158:	80 93 f6 06 	sts	0x06F6, r24
    d15c:	41 ca       	rjmp	.-2942   	; 0xc5e0 <GSM_Cycle+0x40>
			break;
		case GSM_WAIT_E0_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;
		case GSM_SEND_CLCC1:
			GSM_Execute_Command(AT_CLCC1,100*GSM_DEBUG_DELAY); GSM_State++;
    d15e:	86 e8       	ldi	r24, 0x86	; 134
    d160:	94 e0       	ldi	r25, 0x04	; 4
    d162:	64 e6       	ldi	r22, 0x64	; 100
    d164:	70 e0       	ldi	r23, 0x00	; 0
    d166:	0e 94 3a 4c 	call	0x9874	; 0x9874 <GSM_Execute_Command>
    d16a:	80 91 f6 06 	lds	r24, 0x06F6
    d16e:	8f 5f       	subi	r24, 0xFF	; 255
    d170:	80 93 f6 06 	sts	0x06F6, r24
    d174:	35 ca       	rjmp	.-2966   	; 0xc5e0 <GSM_Cycle+0x40>
		//------------------------
		case GSM_SEND_E0:
			GSM_Execute_Command(AT_E0,100*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_E0_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    d176:	81 ef       	ldi	r24, 0xF1	; 241
    d178:	93 e0       	ldi	r25, 0x03	; 3
    d17a:	6a e4       	ldi	r22, 0x4A	; 74
    d17c:	0e 94 df 4b 	call	0x97be	; 0x97be <GSM_Wait_Response_P>
    d180:	88 23       	and	r24, r24
    d182:	09 f4       	brne	.+2      	; 0xd186 <GSM_Cycle+0xbe6>
    d184:	2d ca       	rjmp	.-2982   	; 0xc5e0 <GSM_Cycle+0x40>
    d186:	80 91 f6 06 	lds	r24, 0x06F6
    d18a:	8f 5f       	subi	r24, 0xFF	; 255
    d18c:	80 93 f6 06 	sts	0x06F6, r24
    d190:	27 ca       	rjmp	.-2994   	; 0xc5e0 <GSM_Cycle+0x40>
		case GSM_WAIT_SMS_READY:
			if(GSM_Wait_Response_P(URC_SMS_READY, GSM_ReStart1))GSM_State++;
			break;
		//------------------------
		case GSM_SEND_E0:
			GSM_Execute_Command(AT_E0,100*GSM_DEBUG_DELAY); GSM_State++;
    d192:	81 e8       	ldi	r24, 0x81	; 129
    d194:	94 e0       	ldi	r25, 0x04	; 4
    d196:	64 e6       	ldi	r22, 0x64	; 100
    d198:	70 e0       	ldi	r23, 0x00	; 0
    d19a:	0e 94 3a 4c 	call	0x9874	; 0x9874 <GSM_Execute_Command>
    d19e:	80 91 f6 06 	lds	r24, 0x06F6
    d1a2:	8f 5f       	subi	r24, 0xFF	; 255
    d1a4:	80 93 f6 06 	sts	0x06F6, r24
    d1a8:	1b ca       	rjmp	.-3018   	; 0xc5e0 <GSM_Cycle+0x40>
				if(GSM_Modem == SIMCOM_SIM800) GSM_State = GSM_WAIT_SMS_READY;
				else GSM_State = GSM_SEND_E0;
			}
			break;
		case GSM_WAIT_SMS_READY:
			if(GSM_Wait_Response_P(URC_SMS_READY, GSM_ReStart1))GSM_State++;
    d1aa:	8c ea       	ldi	r24, 0xAC	; 172
    d1ac:	93 e0       	ldi	r25, 0x03	; 3
    d1ae:	6a e4       	ldi	r22, 0x4A	; 74
    d1b0:	0e 94 df 4b 	call	0x97be	; 0x97be <GSM_Wait_Response_P>
    d1b4:	88 23       	and	r24, r24
    d1b6:	09 f4       	brne	.+2      	; 0xd1ba <GSM_Cycle+0xc1a>
    d1b8:	13 ca       	rjmp	.-3034   	; 0xc5e0 <GSM_Cycle+0x40>
    d1ba:	80 91 f6 06 	lds	r24, 0x06F6
    d1be:	8f 5f       	subi	r24, 0xFF	; 255
    d1c0:	80 93 f6 06 	sts	0x06F6, r24
    d1c4:	0d ca       	rjmp	.-3046   	; 0xc5e0 <GSM_Cycle+0x40>

		case GSM_WAIT_RDY:
			if(GSM_Wait_Response_P(URC_RDY, GSM_ReStart1)) GSM_State++;
			break;
		case GSM_SEND_CGMM:
			GSM_Execute_Command(AT_CGMM,5000*GSM_DEBUG_DELAY); GSM_State++;
    d1c6:	8e e9       	ldi	r24, 0x9E	; 158
    d1c8:	94 e0       	ldi	r25, 0x04	; 4
    d1ca:	68 e8       	ldi	r22, 0x88	; 136
    d1cc:	73 e1       	ldi	r23, 0x13	; 19
    d1ce:	0e 94 3a 4c 	call	0x9874	; 0x9874 <GSM_Execute_Command>
    d1d2:	80 91 f6 06 	lds	r24, 0x06F6
    d1d6:	8f 5f       	subi	r24, 0xFF	; 255
    d1d8:	80 93 f6 06 	sts	0x06F6, r24
    d1dc:	01 ca       	rjmp	.-3070   	; 0xc5e0 <GSM_Cycle+0x40>
			GSM_Modem = NOT_RECOGNIZED;
			GSM_State = GSM_WAIT_RDY;
			break;

		case GSM_WAIT_RDY:
			if(GSM_Wait_Response_P(URC_RDY, GSM_ReStart1)) GSM_State++;
    d1de:	87 e8       	ldi	r24, 0x87	; 135
    d1e0:	93 e0       	ldi	r25, 0x03	; 3
    d1e2:	6a e4       	ldi	r22, 0x4A	; 74
    d1e4:	0e 94 df 4b 	call	0x97be	; 0x97be <GSM_Wait_Response_P>
    d1e8:	88 23       	and	r24, r24
    d1ea:	09 f4       	brne	.+2      	; 0xd1ee <GSM_Cycle+0xc4e>
    d1ec:	f9 c9       	rjmp	.-3086   	; 0xc5e0 <GSM_Cycle+0x40>
    d1ee:	80 91 f6 06 	lds	r24, 0x06F6
    d1f2:	8f 5f       	subi	r24, 0xFF	; 255
    d1f4:	80 93 f6 06 	sts	0x06F6, r24
    d1f8:	f3 c9       	rjmp	.-3098   	; 0xc5e0 <GSM_Cycle+0x40>
inline static void GSM_Auto(){

	switch(GSM_State){

		case GSM_PowerOn:
			StartTimer16(TD_GSM,1000*GSM_DEBUG_DELAY);
    d1fa:	80 91 e9 04 	lds	r24, 0x04E9
    d1fe:	68 ee       	ldi	r22, 0xE8	; 232
    d200:	73 e0       	ldi	r23, 0x03	; 3
    d202:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
			StartTimer32(TD_GSM_Reset, 24UL*60UL*6000);	//    24 
    d206:	80 91 eb 04 	lds	r24, 0x04EB
    d20a:	40 e0       	ldi	r20, 0x00	; 0
    d20c:	56 ed       	ldi	r21, 0xD6	; 214
    d20e:	63 e8       	ldi	r22, 0x83	; 131
    d210:	70 e0       	ldi	r23, 0x00	; 0
    d212:	0e 94 1b 1c 	call	0x3836	; 0x3836 <StartTimer32>
			StartTimer32(TD_1hour_resetGPRS_timer, 360000); //     
    d216:	80 91 ed 04 	lds	r24, 0x04ED
    d21a:	40 e4       	ldi	r20, 0x40	; 64
    d21c:	5e e7       	ldi	r21, 0x7E	; 126
    d21e:	65 e0       	ldi	r22, 0x05	; 5
    d220:	70 e0       	ldi	r23, 0x00	; 0
    d222:	0e 94 1b 1c 	call	0x3836	; 0x3836 <StartTimer32>
			StartTimer16(TD_CheckModem,6000);//      5 	
    d226:	80 91 ee 04 	lds	r24, 0x04EE
    d22a:	60 e7       	ldi	r22, 0x70	; 112
    d22c:	77 e1       	ldi	r23, 0x17	; 23
    d22e:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
	}
	void GSM_PWRCNTRL_ON(void){
		cli();
    d232:	f8 94       	cli
		PORTL &= ~(1<<PL5);
    d234:	80 91 0b 01 	lds	r24, 0x010B
    d238:	8f 7d       	andi	r24, 0xDF	; 223
    d23a:	80 93 0b 01 	sts	0x010B, r24
		sei();
    d23e:	78 94       	sei
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    d240:	8f ef       	ldi	r24, 0xFF	; 255
    d242:	80 93 3e 07 	sts	0x073E, r24
	GSM_RX_FIFO_End = 255;
    d246:	80 93 53 06 	sts	0x0653, r24
	GSM_RxCharN = 0;
    d24a:	10 92 5f 0b 	sts	0x0B5F, r1
	GSM_RX_FIFOOverFlow = 0;
    d24e:	10 92 12 09 	sts	0x0912, r1
	GSM_RX_FIFOMax = 0;
    d252:	10 92 18 09 	sts	0x0918, r1
			StartTimer32(TD_GSM_Reset, 24UL*60UL*6000);	//    24 
			StartTimer32(TD_1hour_resetGPRS_timer, 360000); //     
			StartTimer16(TD_CheckModem,6000);//      5 	
			GSM_PWRCNTRL_ON();
			InitFIFO();
			counter=0;
    d256:	10 92 e0 02 	sts	0x02E0, r1
			GSM_Modem = NOT_RECOGNIZED;
    d25a:	10 92 34 07 	sts	0x0734, r1
			GSM_State = GSM_WAIT_RDY;
    d25e:	81 e0       	ldi	r24, 0x01	; 1
    d260:	80 93 f6 06 	sts	0x06F6, r24
    d264:	bd c9       	rjmp	.-3206   	; 0xc5e0 <GSM_Cycle+0x40>
		case GSM_WAIT_CPIN_READY:
			if(GSM_Wait_Response_P(URC_CPIN_READY, GSM_ReStart1)) GSM_State++;
			break;

		case GSM_WAIT_CALL_READY:
			if(GSM_Wait_Response_P(URC_CALL_READY, GSM_ReStart1)){
    d266:	81 ea       	ldi	r24, 0xA1	; 161
    d268:	93 e0       	ldi	r25, 0x03	; 3
    d26a:	6a e4       	ldi	r22, 0x4A	; 74
    d26c:	0e 94 df 4b 	call	0x97be	; 0x97be <GSM_Wait_Response_P>
    d270:	88 23       	and	r24, r24
    d272:	09 f4       	brne	.+2      	; 0xd276 <GSM_Cycle+0xcd6>
    d274:	b5 c9       	rjmp	.-3222   	; 0xc5e0 <GSM_Cycle+0x40>
				if(GSM_Modem == SIMCOM_SIM800) GSM_State = GSM_WAIT_SMS_READY;
    d276:	80 91 34 07 	lds	r24, 0x0734
    d27a:	82 30       	cpi	r24, 0x02	; 2
    d27c:	09 f4       	brne	.+2      	; 0xd280 <GSM_Cycle+0xce0>
    d27e:	8a c6       	rjmp	.+3348   	; 0xdf94 <GSM_Cycle+0x19f4>
				else GSM_State = GSM_SEND_E0;
    d280:	88 e0       	ldi	r24, 0x08	; 8
    d282:	80 93 f6 06 	sts	0x06F6, r24
    d286:	ac c9       	rjmp	.-3240   	; 0xc5e0 <GSM_Cycle+0x40>
			}
		case GSM_WAIT_CFUN:
			if(GSM_Wait_Response_P(URC_CFUN, GSM_ReStart1)) GSM_State++;
			break;
		case GSM_WAIT_CPIN_READY:
			if(GSM_Wait_Response_P(URC_CPIN_READY, GSM_ReStart1)) GSM_State++;
    d288:	84 e9       	ldi	r24, 0x94	; 148
    d28a:	93 e0       	ldi	r25, 0x03	; 3
    d28c:	6a e4       	ldi	r22, 0x4A	; 74
    d28e:	0e 94 df 4b 	call	0x97be	; 0x97be <GSM_Wait_Response_P>
    d292:	88 23       	and	r24, r24
    d294:	09 f4       	brne	.+2      	; 0xd298 <GSM_Cycle+0xcf8>
    d296:	a4 c9       	rjmp	.-3256   	; 0xc5e0 <GSM_Cycle+0x40>
    d298:	80 91 f6 06 	lds	r24, 0x06F6
    d29c:	8f 5f       	subi	r24, 0xFF	; 255
    d29e:	80 93 f6 06 	sts	0x06F6, r24
    d2a2:	9e c9       	rjmp	.-3268   	; 0xc5e0 <GSM_Cycle+0x40>
			}
			break;

		//------------------------
		case GSM_WAIT_1:
			GetStringFromFIFO();		//     FIFO
    d2a4:	0e 94 92 39 	call	0x7324	; 0x7324 <GetStringFromFIFO>
			if(Timer16Stopp(TD_GSM)){
    d2a8:	80 91 e9 04 	lds	r24, 0x04E9
    d2ac:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <Timer16Stopp>
    d2b0:	88 23       	and	r24, r24
    d2b2:	09 f4       	brne	.+2      	; 0xd2b6 <GSM_Cycle+0xd16>
    d2b4:	95 c9       	rjmp	.-3286   	; 0xc5e0 <GSM_Cycle+0x40>
				GSM_State++;
    d2b6:	80 91 f6 06 	lds	r24, 0x06F6
    d2ba:	8f 5f       	subi	r24, 0xFF	; 255
    d2bc:	80 93 f6 06 	sts	0x06F6, r24
				GSM_Temp = 0;
    d2c0:	10 92 db 05 	sts	0x05DB, r1
    d2c4:	8d c9       	rjmp	.-3302   	; 0xc5e0 <GSM_Cycle+0x40>
			if(GSM_MultiCon) GSM_Execute_Command(AT_CIPMODE_0, 100*GSM_DEBUG_DELAY);
			else GSM_Execute_Command(AT_CIPMODE_1, 100*GSM_DEBUG_DELAY);
			GSM_State++;
			break;
		case GSM_WAIT_CIPMODE_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    d2c6:	81 ef       	ldi	r24, 0xF1	; 241
    d2c8:	93 e0       	ldi	r25, 0x03	; 3
    d2ca:	6a e4       	ldi	r22, 0x4A	; 74
    d2cc:	0e 94 df 4b 	call	0x97be	; 0x97be <GSM_Wait_Response_P>
    d2d0:	88 23       	and	r24, r24
    d2d2:	09 f4       	brne	.+2      	; 0xd2d6 <GSM_Cycle+0xd36>
    d2d4:	85 c9       	rjmp	.-3318   	; 0xc5e0 <GSM_Cycle+0x40>
				GSM_State++;
    d2d6:	80 91 f6 06 	lds	r24, 0x06F6
    d2da:	8f 5f       	subi	r24, 0xFF	; 255
    d2dc:	80 93 f6 06 	sts	0x06F6, r24
				// between "Call Ready" and "+CMGS"; 8 sec min needs; for kyivstar vpni only
				StartTimer16(TD_GSM, 1000);
    d2e0:	80 91 e9 04 	lds	r24, 0x04E9
    d2e4:	68 ee       	ldi	r22, 0xE8	; 232
    d2e6:	73 e0       	ldi	r23, 0x03	; 3
    d2e8:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
    d2ec:	79 c9       	rjmp	.-3342   	; 0xc5e0 <GSM_Cycle+0x40>
				}
				else GSM_State++;
			}
			break;
		case GSM_SEND_CIPMODE:
			if(GSM_MultiCon) GSM_Execute_Command(AT_CIPMODE_0, 100*GSM_DEBUG_DELAY);
    d2ee:	80 91 72 0c 	lds	r24, 0x0C72
    d2f2:	88 23       	and	r24, r24
    d2f4:	09 f4       	brne	.+2      	; 0xd2f8 <GSM_Cycle+0xd58>
    d2f6:	83 c4       	rjmp	.+2310   	; 0xdbfe <GSM_Cycle+0x165e>
    d2f8:	8b ef       	ldi	r24, 0xFB	; 251
    d2fa:	94 e0       	ldi	r25, 0x04	; 4
    d2fc:	64 e6       	ldi	r22, 0x64	; 100
    d2fe:	70 e0       	ldi	r23, 0x00	; 0
    d300:	0e 94 3a 4c 	call	0x9874	; 0x9874 <GSM_Execute_Command>
			else GSM_Execute_Command(AT_CIPMODE_1, 100*GSM_DEBUG_DELAY);
			GSM_State++;
    d304:	80 91 f6 06 	lds	r24, 0x06F6
    d308:	8f 5f       	subi	r24, 0xFF	; 255
    d30a:	80 93 f6 06 	sts	0x06F6, r24
    d30e:	68 c9       	rjmp	.-3376   	; 0xc5e0 <GSM_Cycle+0x40>
			if(GSM_MultiCon) GSM_Execute_Command(AT_CIPMUX_1, 100*GSM_DEBUG_DELAY);
			else GSM_Execute_Command(AT_CIPMUX_0, 100*GSM_DEBUG_DELAY);
			GSM_State++; 
			break;
		case GSM_WAIT_CIPMUX_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    d310:	81 ef       	ldi	r24, 0xF1	; 241
    d312:	93 e0       	ldi	r25, 0x03	; 3
    d314:	6a e4       	ldi	r22, 0x4A	; 74
    d316:	0e 94 df 4b 	call	0x97be	; 0x97be <GSM_Wait_Response_P>
    d31a:	88 23       	and	r24, r24
    d31c:	09 f4       	brne	.+2      	; 0xd320 <GSM_Cycle+0xd80>
    d31e:	60 c9       	rjmp	.-3392   	; 0xc5e0 <GSM_Cycle+0x40>
				if(GSM_MultiCon){
    d320:	80 91 72 0c 	lds	r24, 0x0C72
    d324:	88 23       	and	r24, r24
    d326:	09 f0       	breq	.+2      	; 0xd32a <GSM_Cycle+0xd8a>
    d328:	4e c6       	rjmp	.+3228   	; 0xdfc6 <GSM_Cycle+0x1a26>
					GSM_State = GSM_WAIT_1;
					// between "Call Ready" and "+CMGS"; 8 sec min needs; for kyivstar vpni only
					StartTimer16(TD_GSM, 1000);
				}
				else GSM_State++;
    d32a:	80 91 f6 06 	lds	r24, 0x06F6
    d32e:	8f 5f       	subi	r24, 0xFF	; 255
    d330:	80 93 f6 06 	sts	0x06F6, r24
    d334:	55 c9       	rjmp	.-3414   	; 0xc5e0 <GSM_Cycle+0x40>

		case GSM_SEND_CSTT:
			GSM_Execute_Command(AT_CSTT, 300*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CSTT_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    d336:	81 ef       	ldi	r24, 0xF1	; 241
    d338:	93 e0       	ldi	r25, 0x03	; 3
    d33a:	6a e4       	ldi	r22, 0x4A	; 74
    d33c:	0e 94 df 4b 	call	0x97be	; 0x97be <GSM_Wait_Response_P>
    d340:	88 23       	and	r24, r24
    d342:	09 f4       	brne	.+2      	; 0xd346 <GSM_Cycle+0xda6>
    d344:	4d c9       	rjmp	.-3430   	; 0xc5e0 <GSM_Cycle+0x40>
    d346:	80 91 f6 06 	lds	r24, 0x06F6
    d34a:	8f 5f       	subi	r24, 0xFF	; 255
    d34c:	80 93 f6 06 	sts	0x06F6, r24
    d350:	47 c9       	rjmp	.-3442   	; 0xc5e0 <GSM_Cycle+0x40>



///------------------------ / (  )
		case GSM_SEND_CMGF:
			GSM_Execute_Command(AT_CMGF,100*GSM_DEBUG_DELAY); GSM_State++;
    d352:	83 ed       	ldi	r24, 0xD3	; 211
    d354:	94 e0       	ldi	r25, 0x04	; 4
    d356:	64 e6       	ldi	r22, 0x64	; 100
    d358:	70 e0       	ldi	r23, 0x00	; 0
    d35a:	0e 94 3a 4c 	call	0x9874	; 0x9874 <GSM_Execute_Command>
    d35e:	80 91 f6 06 	lds	r24, 0x06F6
    d362:	8f 5f       	subi	r24, 0xFF	; 255
    d364:	80 93 f6 06 	sts	0x06F6, r24
    d368:	3b c9       	rjmp	.-3466   	; 0xc5e0 <GSM_Cycle+0x40>
			if(Timer16Stopp(TD_GSM)){
				GSM_State = GSM_WAIT_MESSAGE;
			}
			break;
		case GSM_WAIT_DISCONNECT_CAUSE:
			if(GetStringFromFIFO()){
    d36a:	0e 94 92 39 	call	0x7324	; 0x7324 <GetStringFromFIFO>
    d36e:	88 23       	and	r24, r24
    d370:	09 f4       	brne	.+2      	; 0xd374 <GSM_Cycle+0xdd4>
    d372:	4c c4       	rjmp	.+2200   	; 0xdc0c <GSM_Cycle+0x166c>
				if((strstr_P(GSM_RxStr, PSTR("OK")) != NULL) ){
    d374:	80 ee       	ldi	r24, 0xE0	; 224
    d376:	97 e0       	ldi	r25, 0x07	; 7
    d378:	6d e7       	ldi	r22, 0x7D	; 125
    d37a:	7d e2       	ldi	r23, 0x2D	; 45
    d37c:	0e 94 1f 81 	call	0x1023e	; 0x1023e <strstr_P>
    d380:	89 2b       	or	r24, r25
    d382:	09 f4       	brne	.+2      	; 0xd386 <GSM_Cycle+0xde6>
    d384:	dc c6       	rjmp	.+3512   	; 0xe13e <GSM_Cycle+0x1b9e>
					GSM_State = GSM_WAIT_MESSAGE;
    d386:	8e e0       	ldi	r24, 0x0E	; 14
    d388:	80 93 f6 06 	sts	0x06F6, r24
    d38c:	29 c9       	rjmp	.-3502   	; 0xc5e0 <GSM_Cycle+0x40>
			GSM_SendFirstChar();
			GSM_State = GSM_WAIT_CCLC_6;
			StartTimer16(TD_GSM, 1000);
			break;	
		case GSM_WAIT_CCLC_6:
			if(GetStringFromFIFO()){
    d38e:	0e 94 92 39 	call	0x7324	; 0x7324 <GetStringFromFIFO>
    d392:	88 23       	and	r24, r24
    d394:	09 f4       	brne	.+2      	; 0xd398 <GSM_Cycle+0xdf8>
    d396:	4a c3       	rjmp	.+1684   	; 0xda2c <GSM_Cycle+0x148c>
				if((strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6,")) != NULL) ){
    d398:	80 ee       	ldi	r24, 0xE0	; 224
    d39a:	97 e0       	ldi	r25, 0x07	; 7
    d39c:	60 e8       	ldi	r22, 0x80	; 128
    d39e:	7d e2       	ldi	r23, 0x2D	; 45
    d3a0:	0e 94 1f 81 	call	0x1023e	; 0x1023e <strstr_P>
    d3a4:	89 2b       	or	r24, r25
    d3a6:	09 f4       	brne	.+2      	; 0xd3aa <GSM_Cycle+0xe0a>
    d3a8:	41 c3       	rjmp	.+1666   	; 0xda2c <GSM_Cycle+0x148c>
					GSM_State = GSM_WAIT_DISCONNECT_CAUSE;
    d3aa:	85 e2       	ldi	r24, 0x25	; 37
    d3ac:	80 93 f6 06 	sts	0x06F6, r24
					StartTimer16(TD_GSM, 10000);
    d3b0:	80 91 e9 04 	lds	r24, 0x04E9
    d3b4:	60 e1       	ldi	r22, 0x10	; 16
    d3b6:	77 e2       	ldi	r23, 0x27	; 39
    d3b8:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
    d3bc:	11 c9       	rjmp	.-3550   	; 0xc5e0 <GSM_Cycle+0x40>
				GSM_State = GSM_SEND_ATH;
				StartTimer16(TD_GSM, 10000);
			}
			break;	
		case GSM_SEND_ATH:
			sprintf_P(GSM_TxStr, PSTR("ATH\r"));
    d3be:	00 d0       	rcall	.+0      	; 0xd3c0 <GSM_Cycle+0xe20>
    d3c0:	0f 92       	push	r0
    d3c2:	89 e4       	ldi	r24, 0x49	; 73
    d3c4:	9a e0       	ldi	r25, 0x0A	; 10
    d3c6:	ed b7       	in	r30, 0x3d	; 61
    d3c8:	fe b7       	in	r31, 0x3e	; 62
    d3ca:	92 83       	std	Z+2, r25	; 0x02
    d3cc:	81 83       	std	Z+1, r24	; 0x01
    d3ce:	8e e8       	ldi	r24, 0x8E	; 142
    d3d0:	9d e2       	ldi	r25, 0x2D	; 45
    d3d2:	94 83       	std	Z+4, r25	; 0x04
    d3d4:	83 83       	std	Z+3, r24	; 0x03
    d3d6:	0e 94 1a 82 	call	0x10434	; 0x10434 <sprintf_P>
			GSMTxSz = 4;
    d3da:	84 e0       	ldi	r24, 0x04	; 4
    d3dc:	80 93 bb 07 	sts	0x07BB, r24
			GSM_SendFirstChar();
    d3e0:	0f 90       	pop	r0
    d3e2:	0f 90       	pop	r0
    d3e4:	0f 90       	pop	r0
    d3e6:	0f 90       	pop	r0
    d3e8:	0e 94 bc 3a 	call	0x7578	; 0x7578 <GSM_SendFirstChar>
			GSM_State = GSM_WAIT_CCLC_6;
    d3ec:	84 e2       	ldi	r24, 0x24	; 36
    d3ee:	80 93 f6 06 	sts	0x06F6, r24
			StartTimer16(TD_GSM, 1000);
    d3f2:	80 91 e9 04 	lds	r24, 0x04E9
    d3f6:	68 ee       	ldi	r22, 0xE8	; 232
    d3f8:	73 e0       	ldi	r23, 0x03	; 3
    d3fa:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
    d3fe:	f0 c8       	rjmp	.-3616   	; 0xc5e0 <GSM_Cycle+0x40>
					GSM_State = GSM_WAIT_PLAY_NOTCONFIRM_FILE_CREC_0;
					StartTimer16(TD_GSM, 20000);
				}
			break;
		case GSM_WAIT_PLAY_NOTCONFIRM_FILE_CREC_0:
			if(GSM_Wait_Response_P(RESP_CREC_0, GSM_SEND_ATD)) 
    d400:	81 e5       	ldi	r24, 0x51	; 81
    d402:	94 e0       	ldi	r25, 0x04	; 4
    d404:	6f e0       	ldi	r22, 0x0F	; 15
    d406:	0e 94 df 4b 	call	0x97be	; 0x97be <GSM_Wait_Response_P>
    d40a:	88 23       	and	r24, r24
    d40c:	09 f4       	brne	.+2      	; 0xd410 <GSM_Cycle+0xe70>
    d40e:	e8 c8       	rjmp	.-3632   	; 0xc5e0 <GSM_Cycle+0x40>
			{
				GSM_State = GSM_SEND_ATH;
    d410:	83 e2       	ldi	r24, 0x23	; 35
    d412:	80 93 f6 06 	sts	0x06F6, r24
				StartTimer16(TD_GSM, 10000);
    d416:	80 91 e9 04 	lds	r24, 0x04E9
    d41a:	60 e1       	ldi	r22, 0x10	; 16
    d41c:	77 e2       	ldi	r23, 0x27	; 39
    d41e:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
    d422:	de c8       	rjmp	.-3652   	; 0xc5e0 <GSM_Cycle+0x40>
			GSM_SendFirstChar();
			GSM_State = GSM_WAIT_PLAY_NOTCONFIRM_FILE_OK;
			StartTimer16(TD_GSM, 1000);
			break;
		case GSM_WAIT_PLAY_NOTCONFIRM_FILE_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_WAIT_PLAY_NOTCONFIRM_FILE_OK)) 
    d424:	81 ef       	ldi	r24, 0xF1	; 241
    d426:	93 e0       	ldi	r25, 0x03	; 3
    d428:	61 e2       	ldi	r22, 0x21	; 33
    d42a:	0e 94 df 4b 	call	0x97be	; 0x97be <GSM_Wait_Response_P>
    d42e:	88 23       	and	r24, r24
    d430:	09 f4       	brne	.+2      	; 0xd434 <GSM_Cycle+0xe94>
    d432:	d6 c8       	rjmp	.-3668   	; 0xc5e0 <GSM_Cycle+0x40>
				{
					GSM_State = GSM_WAIT_PLAY_NOTCONFIRM_FILE_CREC_0;
    d434:	82 e2       	ldi	r24, 0x22	; 34
    d436:	80 93 f6 06 	sts	0x06F6, r24
					StartTimer16(TD_GSM, 20000);
    d43a:	80 91 e9 04 	lds	r24, 0x04E9
    d43e:	60 e2       	ldi	r22, 0x20	; 32
    d440:	7e e4       	ldi	r23, 0x4E	; 78
    d442:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
    d446:	cc c8       	rjmp	.-3688   	; 0xc5e0 <GSM_Cycle+0x40>
				GSM_State = GSM_SEND_ATH;
				StartTimer16(TD_GSM, 10000);
			}
			break;
		case GSM_SEND_PLAY_NOTCONFIRM_FILE: 
			sprintf_P(GSM_TxStr, PSTR("AT+CREC=4,\"C:\\User\\NotConfirm.amr\",0,100\r"));
    d448:	00 d0       	rcall	.+0      	; 0xd44a <GSM_Cycle+0xeaa>
    d44a:	0f 92       	push	r0
    d44c:	89 e4       	ldi	r24, 0x49	; 73
    d44e:	9a e0       	ldi	r25, 0x0A	; 10
    d450:	ad b7       	in	r26, 0x3d	; 61
    d452:	be b7       	in	r27, 0x3e	; 62
    d454:	12 96       	adiw	r26, 0x02	; 2
    d456:	9c 93       	st	X, r25
    d458:	8e 93       	st	-X, r24
    d45a:	11 97       	sbiw	r26, 0x01	; 1
    d45c:	83 e9       	ldi	r24, 0x93	; 147
    d45e:	9d e2       	ldi	r25, 0x2D	; 45
    d460:	14 96       	adiw	r26, 0x04	; 4
    d462:	9c 93       	st	X, r25
    d464:	8e 93       	st	-X, r24
    d466:	13 97       	sbiw	r26, 0x03	; 3
    d468:	0e 94 1a 82 	call	0x10434	; 0x10434 <sprintf_P>
			GSMTxSz = 41;
    d46c:	89 e2       	ldi	r24, 0x29	; 41
    d46e:	80 93 bb 07 	sts	0x07BB, r24
			GSM_SendFirstChar();
    d472:	0f 90       	pop	r0
    d474:	0f 90       	pop	r0
    d476:	0f 90       	pop	r0
    d478:	0f 90       	pop	r0
    d47a:	0e 94 bc 3a 	call	0x7578	; 0x7578 <GSM_SendFirstChar>
			GSM_State = GSM_WAIT_PLAY_NOTCONFIRM_FILE_OK;
    d47e:	81 e2       	ldi	r24, 0x21	; 33
    d480:	80 93 f6 06 	sts	0x06F6, r24
			StartTimer16(TD_GSM, 1000);
    d484:	80 91 e9 04 	lds	r24, 0x04E9
    d488:	68 ee       	ldi	r22, 0xE8	; 232
    d48a:	73 e0       	ldi	r23, 0x03	; 3
    d48c:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
    d490:	a7 c8       	rjmp	.-3762   	; 0xc5e0 <GSM_Cycle+0x40>
					GSM_State = GSM_WAIT_PLAY_CONFIRM_FILE_CREC_0;
					StartTimer16(TD_GSM, 20000);
				}
			break;
		case GSM_WAIT_PLAY_CONFIRM_FILE_CREC_0:
			if(GSM_Wait_Response_P(RESP_CREC_0, GSM_SEND_ATD)) 
    d492:	81 e5       	ldi	r24, 0x51	; 81
    d494:	94 e0       	ldi	r25, 0x04	; 4
    d496:	6f e0       	ldi	r22, 0x0F	; 15
    d498:	0e 94 df 4b 	call	0x97be	; 0x97be <GSM_Wait_Response_P>
    d49c:	88 23       	and	r24, r24
    d49e:	09 f4       	brne	.+2      	; 0xd4a2 <GSM_Cycle+0xf02>
    d4a0:	9f c8       	rjmp	.-3778   	; 0xc5e0 <GSM_Cycle+0x40>
			{
				GSM_State = GSM_SEND_ATH;
    d4a2:	83 e2       	ldi	r24, 0x23	; 35
    d4a4:	80 93 f6 06 	sts	0x06F6, r24
				StartTimer16(TD_GSM, 10000);
    d4a8:	80 91 e9 04 	lds	r24, 0x04E9
    d4ac:	60 e1       	ldi	r22, 0x10	; 16
    d4ae:	77 e2       	ldi	r23, 0x27	; 39
    d4b0:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
    d4b4:	95 c8       	rjmp	.-3798   	; 0xc5e0 <GSM_Cycle+0x40>
		case GSM_WAIT_CSMP_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State=GSM_SEND_ATD_Check_Ballance;
			break;
		//------------------------
		case GSM_SEND_CIPMUX:
			if(GSM_MultiCon) GSM_Execute_Command(AT_CIPMUX_1, 100*GSM_DEBUG_DELAY);
    d4b6:	80 91 72 0c 	lds	r24, 0x0C72
    d4ba:	88 23       	and	r24, r24
    d4bc:	09 f4       	brne	.+2      	; 0xd4c0 <GSM_Cycle+0xf20>
    d4be:	35 c3       	rjmp	.+1642   	; 0xdb2a <GSM_Cycle+0x158a>
    d4c0:	81 e2       	ldi	r24, 0x21	; 33
    d4c2:	95 e0       	ldi	r25, 0x05	; 5
    d4c4:	64 e6       	ldi	r22, 0x64	; 100
    d4c6:	70 e0       	ldi	r23, 0x00	; 0
    d4c8:	0e 94 3a 4c 	call	0x9874	; 0x9874 <GSM_Execute_Command>
			else GSM_Execute_Command(AT_CIPMUX_0, 100*GSM_DEBUG_DELAY);
			GSM_State++; 
    d4cc:	80 91 f6 06 	lds	r24, 0x06F6
    d4d0:	8f 5f       	subi	r24, 0xFF	; 255
    d4d2:	80 93 f6 06 	sts	0x06F6, r24
    d4d6:	84 c8       	rjmp	.-3832   	; 0xc5e0 <GSM_Cycle+0x40>
			break;
		case GSM_SEND_CSMP:
			GSM_Execute_Command(AT_CSMP, 100*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CSMP_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State=GSM_SEND_ATD_Check_Ballance;
    d4d8:	81 ef       	ldi	r24, 0xF1	; 241
    d4da:	93 e0       	ldi	r25, 0x03	; 3
    d4dc:	6a e4       	ldi	r22, 0x4A	; 74
    d4de:	0e 94 df 4b 	call	0x97be	; 0x97be <GSM_Wait_Response_P>
    d4e2:	88 23       	and	r24, r24
    d4e4:	09 f4       	brne	.+2      	; 0xd4e8 <GSM_Cycle+0xf48>
    d4e6:	7c c8       	rjmp	.-3848   	; 0xc5e0 <GSM_Cycle+0x40>
    d4e8:	8c e4       	ldi	r24, 0x4C	; 76
    d4ea:	80 93 f6 06 	sts	0x06F6, r24
    d4ee:	78 c8       	rjmp	.-3856   	; 0xc5e0 <GSM_Cycle+0x40>
			break;
		case GSM_WAIT_CMGF_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;
		case GSM_SEND_CSMP:
			GSM_Execute_Command(AT_CSMP, 100*GSM_DEBUG_DELAY); GSM_State++;
    d4f0:	8d ed       	ldi	r24, 0xDD	; 221
    d4f2:	94 e0       	ldi	r25, 0x04	; 4
    d4f4:	64 e6       	ldi	r22, 0x64	; 100
    d4f6:	70 e0       	ldi	r23, 0x00	; 0
    d4f8:	0e 94 3a 4c 	call	0x9874	; 0x9874 <GSM_Execute_Command>
    d4fc:	80 91 f6 06 	lds	r24, 0x06F6
    d500:	8f 5f       	subi	r24, 0xFF	; 255
    d502:	80 93 f6 06 	sts	0x06F6, r24
    d506:	6c c8       	rjmp	.-3880   	; 0xc5e0 <GSM_Cycle+0x40>
///------------------------ / (  )
		case GSM_SEND_CMGF:
			GSM_Execute_Command(AT_CMGF,100*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CMGF_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    d508:	81 ef       	ldi	r24, 0xF1	; 241
    d50a:	93 e0       	ldi	r25, 0x03	; 3
    d50c:	6a e4       	ldi	r22, 0x4A	; 74
    d50e:	0e 94 df 4b 	call	0x97be	; 0x97be <GSM_Wait_Response_P>
    d512:	88 23       	and	r24, r24
    d514:	09 f4       	brne	.+2      	; 0xd518 <GSM_Cycle+0xf78>
    d516:	64 c8       	rjmp	.-3896   	; 0xc5e0 <GSM_Cycle+0x40>
    d518:	80 91 f6 06 	lds	r24, 0x06F6
    d51c:	8f 5f       	subi	r24, 0xFF	; 255
    d51e:	80 93 f6 06 	sts	0x06F6, r24
    d522:	5e c8       	rjmp	.-3908   	; 0xc5e0 <GSM_Cycle+0x40>

		case GSM_SEND_CIFSR:
			GSM_Execute_Command(AT_CIFSR, 1000*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CIFSR_OK:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
    d524:	80 91 e9 04 	lds	r24, 0x04E9
    d528:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <Timer16Stopp>
    d52c:	88 23       	and	r24, r24
    d52e:	19 f0       	breq	.+6      	; 0xd536 <GSM_Cycle+0xf96>
    d530:	8a e4       	ldi	r24, 0x4A	; 74
    d532:	80 93 f6 06 	sts	0x06F6, r24
			if(GetStringFromFIFO()){
    d536:	0e 94 92 39 	call	0x7324	; 0x7324 <GetStringFromFIFO>
    d53a:	88 23       	and	r24, r24
    d53c:	09 f4       	brne	.+2      	; 0xd540 <GSM_Cycle+0xfa0>
    d53e:	50 c8       	rjmp	.-3936   	; 0xc5e0 <GSM_Cycle+0x40>
	uint8_t IP4;
} IP_Addr;

//~~~~~~~~~~~~~~
void SetIP(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	IP->IP1 = IP1;
    d540:	40 e3       	ldi	r20, 0x30	; 48
    d542:	59 e0       	ldi	r21, 0x09	; 9
    d544:	10 92 30 09 	sts	0x0930, r1
	IP->IP2 = IP2;
    d548:	ba 01       	movw	r22, r20
    d54a:	6f 5f       	subi	r22, 0xFF	; 255
    d54c:	7f 4f       	sbci	r23, 0xFF	; 255
    d54e:	10 92 31 09 	sts	0x0931, r1
	IP->IP3 = IP3;
    d552:	8a 01       	movw	r16, r20
    d554:	0e 5f       	subi	r16, 0xFE	; 254
    d556:	1f 4f       	sbci	r17, 0xFF	; 255
    d558:	10 92 32 09 	sts	0x0932, r1
	IP->IP4 = IP4;
    d55c:	e3 e0       	ldi	r30, 0x03	; 3
    d55e:	ee 2e       	mov	r14, r30
    d560:	f1 2c       	mov	r15, r1
    d562:	e4 0e       	add	r14, r20
    d564:	f5 1e       	adc	r15, r21
    d566:	10 92 33 09 	sts	0x0933, r1
    d56a:	20 e0       	ldi	r18, 0x00	; 0
    d56c:	a0 ee       	ldi	r26, 0xE0	; 224
    d56e:	b7 e0       	ldi	r27, 0x07	; 7
				SetIP(&GSM_MyIP,0,0,0,0);
				for(uint8_t i=0; i<strlen(GSM_RxStr); i++)
					if(!isdigit(GSM_RxStr[i])) GSM_RxStr[i] = ' ';
    d570:	30 e2       	ldi	r19, 0x20	; 32
			break;
		case GSM_WAIT_CIFSR_OK:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
			if(GetStringFromFIFO()){
				SetIP(&GSM_MyIP,0,0,0,0);
				for(uint8_t i=0; i<strlen(GSM_RxStr); i++)
    d572:	fd 01       	movw	r30, r26
    d574:	01 90       	ld	r0, Z+
    d576:	00 20       	and	r0, r0
    d578:	e9 f7       	brne	.-6      	; 0xd574 <GSM_Cycle+0xfd4>
    d57a:	31 97       	sbiw	r30, 0x01	; 1
    d57c:	e0 5e       	subi	r30, 0xE0	; 224
    d57e:	f7 40       	sbci	r31, 0x07	; 7
    d580:	82 2f       	mov	r24, r18
    d582:	90 e0       	ldi	r25, 0x00	; 0
    d584:	8e 17       	cp	r24, r30
    d586:	9f 07       	cpc	r25, r31
    d588:	08 f0       	brcs	.+2      	; 0xd58c <GSM_Cycle+0xfec>
    d58a:	90 c2       	rjmp	.+1312   	; 0xdaac <GSM_Cycle+0x150c>
					if(!isdigit(GSM_RxStr[i])) GSM_RxStr[i] = ' ';
    d58c:	fc 01       	movw	r30, r24
    d58e:	e0 52       	subi	r30, 0x20	; 32
    d590:	f8 4f       	sbci	r31, 0xF8	; 248
    d592:	80 81       	ld	r24, Z
    d594:	90 e0       	ldi	r25, 0x00	; 0
    d596:	c0 97       	sbiw	r24, 0x30	; 48
    d598:	0a 97       	sbiw	r24, 0x0a	; 10
    d59a:	08 f0       	brcs	.+2      	; 0xd59e <GSM_Cycle+0xffe>
    d59c:	30 83       	st	Z, r19
			break;
		case GSM_WAIT_CIFSR_OK:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
			if(GetStringFromFIFO()){
				SetIP(&GSM_MyIP,0,0,0,0);
				for(uint8_t i=0; i<strlen(GSM_RxStr); i++)
    d59e:	2f 5f       	subi	r18, 0xFF	; 255
    d5a0:	e8 cf       	rjmp	.-48     	; 0xd572 <GSM_Cycle+0xfd2>
			break;

	

		case GSM_SEND_CIFSR:
			GSM_Execute_Command(AT_CIFSR, 1000*GSM_DEBUG_DELAY); GSM_State++;
    d5a2:	88 e5       	ldi	r24, 0x58	; 88
    d5a4:	95 e0       	ldi	r25, 0x05	; 5
    d5a6:	68 ee       	ldi	r22, 0xE8	; 232
    d5a8:	73 e0       	ldi	r23, 0x03	; 3
    d5aa:	0e 94 3a 4c 	call	0x9874	; 0x9874 <GSM_Execute_Command>
    d5ae:	80 91 f6 06 	lds	r24, 0x06F6
    d5b2:	8f 5f       	subi	r24, 0xFF	; 255
    d5b4:	80 93 f6 06 	sts	0x06F6, r24
    d5b8:	13 c8       	rjmp	.-4058   	; 0xc5e0 <GSM_Cycle+0x40>

		case GSM_SEND_CIICR:
			GSM_Execute_Command(AT_CIICR, 12000*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CIICR_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    d5ba:	81 ef       	ldi	r24, 0xF1	; 241
    d5bc:	93 e0       	ldi	r25, 0x03	; 3
    d5be:	6a e4       	ldi	r22, 0x4A	; 74
    d5c0:	0e 94 df 4b 	call	0x97be	; 0x97be <GSM_Wait_Response_P>
    d5c4:	88 23       	and	r24, r24
    d5c6:	09 f4       	brne	.+2      	; 0xd5ca <GSM_Cycle+0x102a>
    d5c8:	0b c8       	rjmp	.-4074   	; 0xc5e0 <GSM_Cycle+0x40>
    d5ca:	80 91 f6 06 	lds	r24, 0x06F6
    d5ce:	8f 5f       	subi	r24, 0xFF	; 255
    d5d0:	80 93 f6 06 	sts	0x06F6, r24
    d5d4:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
		case GSM_WAIT_CSTT_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;

		case GSM_SEND_CIICR:
			GSM_Execute_Command(AT_CIICR, 12000*GSM_DEBUG_DELAY); GSM_State++;
    d5d8:	8f e4       	ldi	r24, 0x4F	; 79
    d5da:	95 e0       	ldi	r25, 0x05	; 5
    d5dc:	60 ee       	ldi	r22, 0xE0	; 224
    d5de:	7e e2       	ldi	r23, 0x2E	; 46
    d5e0:	0e 94 3a 4c 	call	0x9874	; 0x9874 <GSM_Execute_Command>
    d5e4:	80 91 f6 06 	lds	r24, 0x06F6
    d5e8:	8f 5f       	subi	r24, 0xFF	; 255
    d5ea:	80 93 f6 06 	sts	0x06F6, r24
    d5ee:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
				}
		
			break;

		case GSM_WAIT_CIPSTART_TCP_CLIENT_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    d5f2:	81 ef       	ldi	r24, 0xF1	; 241
    d5f4:	93 e0       	ldi	r25, 0x03	; 3
    d5f6:	6a e4       	ldi	r22, 0x4A	; 74
    d5f8:	0e 94 df 4b 	call	0x97be	; 0x97be <GSM_Wait_Response_P>
    d5fc:	88 23       	and	r24, r24
    d5fe:	11 f4       	brne	.+4      	; 0xd604 <GSM_Cycle+0x1064>
    d600:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
    d604:	80 91 f6 06 	lds	r24, 0x06F6
    d608:	8f 5f       	subi	r24, 0xFF	; 255
    d60a:	80 93 f6 06 	sts	0x06F6, r24
    d60e:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
			}			
			break;
		//------------------------
		case GSM_SEND_CIPSTART_TCP_CLIENT:
	
				if(GSM_Flag & (1<<flg_TxCStr)){
    d612:	80 91 d2 02 	lds	r24, 0x02D2
    d616:	80 fd       	sbrc	r24, 0
    d618:	02 c0       	rjmp	.+4      	; 0xd61e <GSM_Cycle+0x107e>
    d61a:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
					GSMTxSz = strlen_P(AT_CIPSTART_TCP_CLIENT);
    d61e:	58 e8       	ldi	r21, 0x88	; 136
    d620:	e5 2e       	mov	r14, r21
    d622:	55 e0       	ldi	r21, 0x05	; 5
    d624:	f5 2e       	mov	r15, r21
    d626:	c7 01       	movw	r24, r14
    d628:	0e 94 fd 80 	call	0x101fa	; 0x101fa <strlen_P>
    d62c:	80 93 bb 07 	sts	0x07BB, r24
					sprintf_P(GSM_TxStr, AT_CIPSTART_TCP_CLIENT);
    d630:	00 d0       	rcall	.+0      	; 0xd632 <GSM_Cycle+0x1092>
    d632:	0f 92       	push	r0
    d634:	09 e4       	ldi	r16, 0x49	; 73
    d636:	1a e0       	ldi	r17, 0x0A	; 10
    d638:	ad b7       	in	r26, 0x3d	; 61
    d63a:	be b7       	in	r27, 0x3e	; 62
    d63c:	12 96       	adiw	r26, 0x02	; 2
    d63e:	1c 93       	st	X, r17
    d640:	0e 93       	st	-X, r16
    d642:	11 97       	sbiw	r26, 0x01	; 1
    d644:	14 96       	adiw	r26, 0x04	; 4
    d646:	fc 92       	st	X, r15
    d648:	ee 92       	st	-X, r14
    d64a:	13 97       	sbiw	r26, 0x03	; 3
    d64c:	0e 94 1a 82 	call	0x10434	; 0x10434 <sprintf_P>
					//GSM_TxStr[12] = 0x30+TempNum;
					sprintf(GSM_TxStr + GSMTxSz, "\"%u.%u.%u.%u\",\"%u\"\r",(unsigned int)erb(&TCP_ServerIP[0].IP1), (unsigned int)erb(&TCP_ServerIP[0].IP2), 
    d650:	b0 90 bb 07 	lds	r11, 0x07BB
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    d654:	0f 90       	pop	r0
    d656:	0f 90       	pop	r0
    d658:	0f 90       	pop	r0
    d65a:	0f 90       	pop	r0
    d65c:	81 e9       	ldi	r24, 0x91	; 145
    d65e:	90 e0       	ldi	r25, 0x00	; 0
    d660:	0e 94 17 84 	call	0x1082e	; 0x1082e <__eerd_byte_m2560>
    d664:	f8 2e       	mov	r15, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    d666:	82 e9       	ldi	r24, 0x92	; 146
    d668:	90 e0       	ldi	r25, 0x00	; 0
    d66a:	0e 94 17 84 	call	0x1082e	; 0x1082e <__eerd_byte_m2560>
    d66e:	e8 2e       	mov	r14, r24
    d670:	83 e9       	ldi	r24, 0x93	; 147
    d672:	90 e0       	ldi	r25, 0x00	; 0
    d674:	0e 94 17 84 	call	0x1082e	; 0x1082e <__eerd_byte_m2560>
    d678:	d8 2e       	mov	r13, r24
    d67a:	84 e9       	ldi	r24, 0x94	; 148
    d67c:	90 e0       	ldi	r25, 0x00	; 0
    d67e:	0e 94 17 84 	call	0x1082e	; 0x1082e <__eerd_byte_m2560>
    d682:	c8 2e       	mov	r12, r24
    d684:	89 ea       	ldi	r24, 0xA9	; 169
    d686:	90 e0       	ldi	r25, 0x00	; 0
    d688:	0e 94 25 84 	call	0x1084a	; 0x1084a <__eerd_word_m2560>
    d68c:	ed b7       	in	r30, 0x3d	; 61
    d68e:	fe b7       	in	r31, 0x3e	; 62
    d690:	3e 97       	sbiw	r30, 0x0e	; 14
    d692:	0f b6       	in	r0, 0x3f	; 63
    d694:	f8 94       	cli
    d696:	fe bf       	out	0x3e, r31	; 62
    d698:	0f be       	out	0x3f, r0	; 63
    d69a:	ed bf       	out	0x3d, r30	; 61
    d69c:	31 96       	adiw	r30, 0x01	; 1
    d69e:	2b 2d       	mov	r18, r11
    d6a0:	30 e0       	ldi	r19, 0x00	; 0
    d6a2:	20 0f       	add	r18, r16
    d6a4:	31 1f       	adc	r19, r17
    d6a6:	ad b7       	in	r26, 0x3d	; 61
    d6a8:	be b7       	in	r27, 0x3e	; 62
    d6aa:	12 96       	adiw	r26, 0x02	; 2
    d6ac:	3c 93       	st	X, r19
    d6ae:	2e 93       	st	-X, r18
    d6b0:	11 97       	sbiw	r26, 0x01	; 1
    d6b2:	28 eb       	ldi	r18, 0xB8	; 184
    d6b4:	32 e0       	ldi	r19, 0x02	; 2
    d6b6:	33 83       	std	Z+3, r19	; 0x03
    d6b8:	22 83       	std	Z+2, r18	; 0x02
    d6ba:	f4 82       	std	Z+4, r15	; 0x04
    d6bc:	15 82       	std	Z+5, r1	; 0x05
    d6be:	e6 82       	std	Z+6, r14	; 0x06
    d6c0:	17 82       	std	Z+7, r1	; 0x07
    d6c2:	d0 86       	std	Z+8, r13	; 0x08
    d6c4:	11 86       	std	Z+9, r1	; 0x09
    d6c6:	c2 86       	std	Z+10, r12	; 0x0a
    d6c8:	13 86       	std	Z+11, r1	; 0x0b
    d6ca:	95 87       	std	Z+13, r25	; 0x0d
    d6cc:	84 87       	std	Z+12, r24	; 0x0c
    d6ce:	0e 94 e9 81 	call	0x103d2	; 0x103d2 <sprintf>
						(unsigned int)erb(&TCP_ServerIP[0].IP3), (unsigned int)erb(&TCP_ServerIP[0].IP4), (unsigned int)erw(&TCP_ServerPort[0]));
					GSMTxSz = strlen(GSM_TxStr);
    d6d2:	f8 01       	movw	r30, r16
    d6d4:	01 90       	ld	r0, Z+
    d6d6:	00 20       	and	r0, r0
    d6d8:	e9 f7       	brne	.-6      	; 0xd6d4 <GSM_Cycle+0x1134>
    d6da:	8f 01       	movw	r16, r30
    d6dc:	01 50       	subi	r16, 0x01	; 1
    d6de:	10 40       	sbci	r17, 0x00	; 0
    d6e0:	09 54       	subi	r16, 0x49	; 73
    d6e2:	1a 40       	sbci	r17, 0x0A	; 10
    d6e4:	00 93 bb 07 	sts	0x07BB, r16
					GSM_SendFirstChar();
    d6e8:	2d b7       	in	r18, 0x3d	; 61
    d6ea:	3e b7       	in	r19, 0x3e	; 62
    d6ec:	22 5f       	subi	r18, 0xF2	; 242
    d6ee:	3f 4f       	sbci	r19, 0xFF	; 255
    d6f0:	0f b6       	in	r0, 0x3f	; 63
    d6f2:	f8 94       	cli
    d6f4:	3e bf       	out	0x3e, r19	; 62
    d6f6:	0f be       	out	0x3f, r0	; 63
    d6f8:	2d bf       	out	0x3d, r18	; 61
    d6fa:	0e 94 bc 3a 	call	0x7578	; 0x7578 <GSM_SendFirstChar>
					StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    d6fe:	80 91 e9 04 	lds	r24, 0x04E9
    d702:	64 ef       	ldi	r22, 0xF4	; 244
    d704:	71 e0       	ldi	r23, 0x01	; 1
    d706:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
					GSM_State++;
    d70a:	80 91 f6 06 	lds	r24, 0x06F6
    d70e:	8f 5f       	subi	r24, 0xFF	; 255
    d710:	80 93 f6 06 	sts	0x06F6, r24
    d714:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>

		case GSM_WAIT_CIPSTART_TCP_CLIENT_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;
		case GSM_WAIT_CIPSTART_TCP_CLIENT_CONNECT:
			if(GSM_Wait_Response_P(RESP_CONNECT, GSM_ReStart1)){
    d718:	84 ef       	ldi	r24, 0xF4	; 244
    d71a:	93 e0       	ldi	r25, 0x03	; 3
    d71c:	6a e4       	ldi	r22, 0x4A	; 74
    d71e:	0e 94 df 4b 	call	0x97be	; 0x97be <GSM_Wait_Response_P>
    d722:	88 23       	and	r24, r24
    d724:	11 f4       	brne	.+4      	; 0xd72a <GSM_Cycle+0x118a>
    d726:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
				 GSM_State = GSM_WAIT_IDENTIFICATION;
    d72a:	8e e3       	ldi	r24, 0x3E	; 62
    d72c:	80 93 f6 06 	sts	0x06F6, r24
				 StartTimer16(TD_GSM, 1000*GSM_DEBUG_DELAY);
    d730:	80 91 e9 04 	lds	r24, 0x04E9
    d734:	68 ee       	ldi	r22, 0xE8	; 232
    d736:	73 e0       	ldi	r23, 0x03	; 3
    d738:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
    d73c:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
				StartTimer16(TD_GSM, 300*GSM_DEBUG_DELAY);
			}
			GSM_State++;
			break;
		case GSM_WAIT_CIPCSGP_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    d740:	81 ef       	ldi	r24, 0xF1	; 241
    d742:	93 e0       	ldi	r25, 0x03	; 3
    d744:	6a e4       	ldi	r22, 0x4A	; 74
    d746:	0e 94 df 4b 	call	0x97be	; 0x97be <GSM_Wait_Response_P>
    d74a:	88 23       	and	r24, r24
    d74c:	11 f4       	brne	.+4      	; 0xd752 <GSM_Cycle+0x11b2>
    d74e:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
			 if(GSM_Modem == SIMCOM_SIM800)GSM_State++;
    d752:	80 91 34 07 	lds	r24, 0x0734
    d756:	82 30       	cpi	r24, 0x02	; 2
    d758:	09 f4       	brne	.+2      	; 0xd75c <GSM_Cycle+0x11bc>
    d75a:	2e c4       	rjmp	.+2140   	; 0xdfb8 <GSM_Cycle+0x1a18>
			 else GSM_State=GSM_SEND_CSTT;
    d75c:	85 e3       	ldi	r24, 0x35	; 53
    d75e:	80 93 f6 06 	sts	0x06F6, r24
    d762:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
			if(GSM_Wait_Response_P(RESP_OK, GSM_SEND_CGATT)) GSM_State++;
			break;

		case GSM_SEND_CIPCSGP:
			//GSM_Execute_Command(AT_CIPCSGP, 300*GSM_DEBUG_DELAY); GSM_State++;
			if(GSM_Flag & (1<<flg_TxCStr)){
    d766:	80 91 d2 02 	lds	r24, 0x02D2
    d76a:	80 fd       	sbrc	r24, 0
    d76c:	fb c2       	rjmp	.+1526   	; 0xdd64 <GSM_Cycle+0x17c4>
				GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn_psw);
				sprintf(GSM_TxStr + GSMTxSz, "\"\r");	GSMTxSz = GSMTxSz+2;
				GSM_SendFirstChar();
				StartTimer16(TD_GSM, 300*GSM_DEBUG_DELAY);
			}
			GSM_State++;
    d76e:	80 91 f6 06 	lds	r24, 0x06F6
    d772:	8f 5f       	subi	r24, 0xFF	; 255
    d774:	80 93 f6 06 	sts	0x06F6, r24
    d778:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
			break;
		case GSM_SEND_CGATT:
			GSM_Execute_Command(AT_CGATT, 500*GSM_DEBUG_DELAY); GSM_Temp++; GSM_State++;
			break;
		case GSM_WAIT_CGATT_OK:
			if(GSM_Temp>20) GSM_State = GSM_ReStart1;
    d77c:	80 91 db 05 	lds	r24, 0x05DB
    d780:	85 31       	cpi	r24, 0x15	; 21
    d782:	18 f0       	brcs	.+6      	; 0xd78a <GSM_Cycle+0x11ea>
    d784:	8a e4       	ldi	r24, 0x4A	; 74
    d786:	80 93 f6 06 	sts	0x06F6, r24
			if(GSM_Wait_Response_P(RESP_OK, GSM_SEND_CGATT)) GSM_State++;
    d78a:	81 ef       	ldi	r24, 0xF1	; 241
    d78c:	93 e0       	ldi	r25, 0x03	; 3
    d78e:	6f e2       	ldi	r22, 0x2F	; 47
    d790:	0e 94 df 4b 	call	0x97be	; 0x97be <GSM_Wait_Response_P>
    d794:	88 23       	and	r24, r24
    d796:	11 f4       	brne	.+4      	; 0xd79c <GSM_Cycle+0x11fc>
    d798:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
    d79c:	80 91 f6 06 	lds	r24, 0x06F6
    d7a0:	8f 5f       	subi	r24, 0xFF	; 255
    d7a2:	80 93 f6 06 	sts	0x06F6, r24
    d7a6:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>

		case GSM_SEND_CIPTKA:
			GSM_Execute_Command(AT_CIPTKA, 1000*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CIPTKA_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    d7aa:	81 ef       	ldi	r24, 0xF1	; 241
    d7ac:	93 e0       	ldi	r25, 0x03	; 3
    d7ae:	6a e4       	ldi	r22, 0x4A	; 74
    d7b0:	0e 94 df 4b 	call	0x97be	; 0x97be <GSM_Wait_Response_P>
    d7b4:	88 23       	and	r24, r24
    d7b6:	11 f4       	brne	.+4      	; 0xd7bc <GSM_Cycle+0x121c>
    d7b8:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
    d7bc:	80 91 f6 06 	lds	r24, 0x06F6
    d7c0:	8f 5f       	subi	r24, 0xFF	; 255
    d7c2:	80 93 f6 06 	sts	0x06F6, r24
    d7c6:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
			 else GSM_State=GSM_SEND_CSTT;
			 }
			break;

		case GSM_SEND_CIPTKA:
			GSM_Execute_Command(AT_CIPTKA, 1000*GSM_DEBUG_DELAY); GSM_State++;
    d7ca:	81 e6       	ldi	r24, 0x61	; 97
    d7cc:	95 e0       	ldi	r25, 0x05	; 5
    d7ce:	68 ee       	ldi	r22, 0xE8	; 232
    d7d0:	73 e0       	ldi	r23, 0x03	; 3
    d7d2:	0e 94 3a 4c 	call	0x9874	; 0x9874 <GSM_Execute_Command>
    d7d6:	80 91 f6 06 	lds	r24, 0x06F6
    d7da:	8f 5f       	subi	r24, 0xFF	; 255
    d7dc:	80 93 f6 06 	sts	0x06F6, r24
    d7e0:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
		case GSM_WAIT_CIPTKA_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;

		case GSM_SEND_CSTT:
			GSM_Execute_Command(AT_CSTT, 300*GSM_DEBUG_DELAY); GSM_State++;
    d7e4:	87 e4       	ldi	r24, 0x47	; 71
    d7e6:	95 e0       	ldi	r25, 0x05	; 5
    d7e8:	6c e2       	ldi	r22, 0x2C	; 44
    d7ea:	71 e0       	ldi	r23, 0x01	; 1
    d7ec:	0e 94 3a 4c 	call	0x9874	; 0x9874 <GSM_Execute_Command>
    d7f0:	80 91 f6 06 	lds	r24, 0x06F6
    d7f4:	8f 5f       	subi	r24, 0xFF	; 255
    d7f6:	80 93 f6 06 	sts	0x06F6, r24
    d7fa:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
				GSM_State++;
				GSM_Temp = 0;
			}
			break;
		case GSM_SEND_CGATT:
			GSM_Execute_Command(AT_CGATT, 500*GSM_DEBUG_DELAY); GSM_Temp++; GSM_State++;
    d7fe:	8d e2       	ldi	r24, 0x2D	; 45
    d800:	95 e0       	ldi	r25, 0x05	; 5
    d802:	64 ef       	ldi	r22, 0xF4	; 244
    d804:	71 e0       	ldi	r23, 0x01	; 1
    d806:	0e 94 3a 4c 	call	0x9874	; 0x9874 <GSM_Execute_Command>
    d80a:	80 91 db 05 	lds	r24, 0x05DB
    d80e:	8f 5f       	subi	r24, 0xFF	; 255
    d810:	80 93 db 05 	sts	0x05DB, r24
    d814:	80 91 f6 06 	lds	r24, 0x06F6
    d818:	8f 5f       	subi	r24, 0xFF	; 255
    d81a:	80 93 f6 06 	sts	0x06F6, r24
    d81e:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
				StartTimer16(TD_GSM,200);
				GSM_State++;
			}
			break;
		case GSM_SAVE_IPR:
			if(Timer16Stopp(TD_GSM)) GSM_State++;
    d822:	80 91 e9 04 	lds	r24, 0x04E9
    d826:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <Timer16Stopp>
    d82a:	88 23       	and	r24, r24
    d82c:	11 f4       	brne	.+4      	; 0xd832 <GSM_Cycle+0x1292>
    d82e:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
    d832:	80 91 f6 06 	lds	r24, 0x06F6
    d836:	8f 5f       	subi	r24, 0xFF	; 255
    d838:	80 93 f6 06 	sts	0x06F6, r24
    d83c:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
			break;
		case GSM_CFG_SEND_ATW:
			GSM_Execute_Command(AT_W, 100); GSM_State++;
			break;
		case GSM_CFG_WAIT_ATW_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_CFG_SEND_AT)){
    d840:	81 ef       	ldi	r24, 0xF1	; 241
    d842:	93 e0       	ldi	r25, 0x03	; 3
    d844:	61 e0       	ldi	r22, 0x01	; 1
    d846:	0e 94 df 4b 	call	0x97be	; 0x97be <GSM_Wait_Response_P>
    d84a:	88 23       	and	r24, r24
    d84c:	11 f4       	brne	.+4      	; 0xd852 <GSM_Cycle+0x12b2>
    d84e:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
				StartTimer16(TD_GSM,200);
    d852:	80 91 e9 04 	lds	r24, 0x04E9
    d856:	68 ec       	ldi	r22, 0xC8	; 200
    d858:	70 e0       	ldi	r23, 0x00	; 0
    d85a:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
				GSM_State++;
    d85e:	80 91 f6 06 	lds	r24, 0x06F6
    d862:	8f 5f       	subi	r24, 0xFF	; 255
    d864:	80 93 f6 06 	sts	0x06F6, r24
    d868:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
			break;
		case GSM_CFG_SEND_AT:
			if(Timer16Stopp(TD_GSM)) GSM_Execute_Command(AT_AT, 100); GSM_State++;
			break;
		case GSM_CFG_WAIT_AT_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_CFG_SEND_AT)) GSM_State++;
    d86c:	81 ef       	ldi	r24, 0xF1	; 241
    d86e:	93 e0       	ldi	r25, 0x03	; 3
    d870:	61 e0       	ldi	r22, 0x01	; 1
    d872:	0e 94 df 4b 	call	0x97be	; 0x97be <GSM_Wait_Response_P>
    d876:	88 23       	and	r24, r24
    d878:	11 f4       	brne	.+4      	; 0xd87e <GSM_Cycle+0x12de>
    d87a:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
    d87e:	80 91 f6 06 	lds	r24, 0x06F6
    d882:	8f 5f       	subi	r24, 0xFF	; 255
    d884:	80 93 f6 06 	sts	0x06F6, r24
    d888:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
			StartTimer16(TD_GSM,200);
			GSM_PWRCNTRL_ON();
			GSM_State++;
			break;
		case GSM_CFG_SEND_AT:
			if(Timer16Stopp(TD_GSM)) GSM_Execute_Command(AT_AT, 100); GSM_State++;
    d88c:	80 91 e9 04 	lds	r24, 0x04E9
    d890:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <Timer16Stopp>
    d894:	88 23       	and	r24, r24
    d896:	31 f0       	breq	.+12     	; 0xd8a4 <GSM_Cycle+0x1304>
    d898:	8d e6       	ldi	r24, 0x6D	; 109
    d89a:	94 e0       	ldi	r25, 0x04	; 4
    d89c:	64 e6       	ldi	r22, 0x64	; 100
    d89e:	70 e0       	ldi	r23, 0x00	; 0
    d8a0:	0e 94 3a 4c 	call	0x9874	; 0x9874 <GSM_Execute_Command>
    d8a4:	80 91 f6 06 	lds	r24, 0x06F6
    d8a8:	8f 5f       	subi	r24, 0xFF	; 255
    d8aa:	80 93 f6 06 	sts	0x06F6, r24
    d8ae:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
			break;
		case GSM_CFG_SEND_IPR:
			GSM_Execute_Command(AT_IPR9600, 100); GSM_State++;
			break;
		case GSM_CFG_WAIT_IPR_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_CFG_SEND_AT)){
    d8b2:	81 ef       	ldi	r24, 0xF1	; 241
    d8b4:	93 e0       	ldi	r25, 0x03	; 3
    d8b6:	61 e0       	ldi	r22, 0x01	; 1
    d8b8:	0e 94 df 4b 	call	0x97be	; 0x97be <GSM_Wait_Response_P>
    d8bc:	88 23       	and	r24, r24
    d8be:	11 f4       	brne	.+4      	; 0xd8c4 <GSM_Cycle+0x1324>
    d8c0:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
				StartTimer16(TD_GSM,200);
    d8c4:	80 91 e9 04 	lds	r24, 0x04E9
    d8c8:	68 ec       	ldi	r22, 0xC8	; 200
    d8ca:	70 e0       	ldi	r23, 0x00	; 0
    d8cc:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
				GSM_State++;
    d8d0:	80 91 f6 06 	lds	r24, 0x06F6
    d8d4:	8f 5f       	subi	r24, 0xFF	; 255
    d8d6:	80 93 f6 06 	sts	0x06F6, r24
    d8da:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
			if(GSM_Wait_Response_P(RESP_OK,GSM_SEND_CSQ)) GSM_State++;
			break;
		case GSM_WAIT_Ballance:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_SEND_CSQ;
			GSM_RxStr[GSM_RXSTR_SIZE-1]='\0';
			while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    d8de:	00 e0       	ldi	r16, 0x00	; 0
    d8e0:	32 e0       	ldi	r19, 0x02	; 2
    d8e2:	c3 2e       	mov	r12, r19
    d8e4:	d1 2c       	mov	r13, r1
    d8e6:	cc 0e       	add	r12, r28
    d8e8:	dd 1e       	adc	r13, r29
    d8ea:	09 c0       	rjmp	.+18     	; 0xd8fe <GSM_Cycle+0x135e>
				}

			}//while
			char buf[20];
			uint8_t i=0;
			while( (erb(&GPRS_currency[i])!='\0') && ((erb(&GPRS_currency[i])!=' ')||i==0) ){
    d8ec:	80 32       	cpi	r24, 0x20	; 32
    d8ee:	11 f4       	brne	.+4      	; 0xd8f4 <GSM_Cycle+0x1354>
    d8f0:	00 23       	and	r16, r16
    d8f2:	71 f4       	brne	.+28     	; 0xd910 <GSM_Cycle+0x1370>
				buf[i] = (char)erb(&GPRS_currency[i]);
    d8f4:	ec 0c       	add	r14, r12
    d8f6:	fd 1c       	adc	r15, r13
    d8f8:	f7 01       	movw	r30, r14
    d8fa:	80 83       	st	Z, r24
				i++;
    d8fc:	0f 5f       	subi	r16, 0xFF	; 255
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    d8fe:	e0 2e       	mov	r14, r16
    d900:	ff 24       	eor	r15, r15
    d902:	c7 01       	movw	r24, r14
    d904:	8b 5b       	subi	r24, 0xBB	; 187
    d906:	9f 4f       	sbci	r25, 0xFF	; 255
    d908:	0e 94 17 84 	call	0x1082e	; 0x1082e <__eerd_byte_m2560>
				}

			}//while
			char buf[20];
			uint8_t i=0;
			while( (erb(&GPRS_currency[i])!='\0') && ((erb(&GPRS_currency[i])!=' ')||i==0) ){
    d90c:	88 23       	and	r24, r24
    d90e:	71 f7       	brne	.-36     	; 0xd8ec <GSM_Cycle+0x134c>
				buf[i] = (char)erb(&GPRS_currency[i]);
				i++;
			}
			buf[i]='\0';
    d910:	ec 0c       	add	r14, r12
    d912:	fd 1c       	adc	r15, r13
    d914:	d7 01       	movw	r26, r14
    d916:	1c 92       	st	X, r1
			char *istr=strstr(GSM_RxStr, buf);
    d918:	80 ee       	ldi	r24, 0xE0	; 224
    d91a:	97 e0       	ldi	r25, 0x07	; 7
    d91c:	b6 01       	movw	r22, r12
    d91e:	0e 94 61 81 	call	0x102c2	; 0x102c2 <strstr>
			if(istr)
    d922:	00 97       	sbiw	r24, 0x00	; 0
    d924:	11 f4       	brne	.+4      	; 0xd92a <GSM_Cycle+0x138a>
    d926:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
			{
					Ballance=*(istr-1)-0x30;
    d92a:	fc 01       	movw	r30, r24
    d92c:	82 91       	ld	r24, -Z
    d92e:	90 e0       	ldi	r25, 0x00	; 0
    d930:	c0 97       	sbiw	r24, 0x30	; 48
    d932:	aa 27       	eor	r26, r26
    d934:	97 fd       	sbrc	r25, 7
    d936:	a0 95       	com	r26
    d938:	ba 2f       	mov	r27, r26
    d93a:	80 93 fb 06 	sts	0x06FB, r24
    d93e:	90 93 fc 06 	sts	0x06FC, r25
    d942:	a0 93 fd 06 	sts	0x06FD, r26
    d946:	b0 93 fe 06 	sts	0x06FE, r27
					Ballance+=(*(istr-2)-0x30)*10;
    d94a:	22 91       	ld	r18, -Z
    d94c:	8f 01       	movw	r16, r30
    d94e:	4a e0       	ldi	r20, 0x0A	; 10
    d950:	24 9f       	mul	r18, r20
    d952:	90 01       	movw	r18, r0
    d954:	11 24       	eor	r1, r1
    d956:	20 5e       	subi	r18, 0xE0	; 224
    d958:	31 40       	sbci	r19, 0x01	; 1
    d95a:	49 01       	movw	r8, r18
    d95c:	aa 24       	eor	r10, r10
    d95e:	97 fc       	sbrc	r9, 7
    d960:	a0 94       	com	r10
    d962:	ba 2c       	mov	r11, r10
    d964:	88 0e       	add	r8, r24
    d966:	99 1e       	adc	r9, r25
    d968:	aa 1e       	adc	r10, r26
    d96a:	bb 1e       	adc	r11, r27
    d96c:	80 92 fb 06 	sts	0x06FB, r8
    d970:	90 92 fc 06 	sts	0x06FC, r9
    d974:	a0 92 fd 06 	sts	0x06FD, r10
    d978:	b0 92 fe 06 	sts	0x06FE, r11
					uint8_t charnum=4;
					uint32_t razr=100;
					while((*(istr-charnum)>=0x30)&&(*(istr-charnum)<=0x39)){
    d97c:	02 50       	subi	r16, 0x02	; 2
    d97e:	10 40       	sbci	r17, 0x00	; 0
    d980:	d8 01       	movw	r26, r16
    d982:	6c 91       	ld	r22, X
    d984:	0c 5f       	subi	r16, 0xFC	; 252
    d986:	1f 4f       	sbci	r17, 0xFF	; 255
    d988:	86 2f       	mov	r24, r22
    d98a:	80 53       	subi	r24, 0x30	; 48
    d98c:	8a 30       	cpi	r24, 0x0A	; 10
    d98e:	88 f5       	brcc	.+98     	; 0xd9f2 <GSM_Cycle+0x1452>
    d990:	24 e0       	ldi	r18, 0x04	; 4
    d992:	72 2e       	mov	r7, r18
    d994:	94 e6       	ldi	r25, 0x64	; 100
    d996:	c9 2e       	mov	r12, r25
    d998:	d1 2c       	mov	r13, r1
    d99a:	e1 2c       	mov	r14, r1
    d99c:	f1 2c       	mov	r15, r1
						Ballance+=(*(istr-charnum)-0x30)*razr;
    d99e:	70 e0       	ldi	r23, 0x00	; 0
    d9a0:	60 53       	subi	r22, 0x30	; 48
    d9a2:	70 40       	sbci	r23, 0x00	; 0
    d9a4:	88 27       	eor	r24, r24
    d9a6:	77 fd       	sbrc	r23, 7
    d9a8:	80 95       	com	r24
    d9aa:	98 2f       	mov	r25, r24
    d9ac:	a7 01       	movw	r20, r14
    d9ae:	96 01       	movw	r18, r12
    d9b0:	0e 94 53 84 	call	0x108a6	; 0x108a6 <__mulsi3>
    d9b4:	86 0e       	add	r8, r22
    d9b6:	97 1e       	adc	r9, r23
    d9b8:	a8 1e       	adc	r10, r24
    d9ba:	b9 1e       	adc	r11, r25
    d9bc:	80 92 fb 06 	sts	0x06FB, r8
    d9c0:	90 92 fc 06 	sts	0x06FC, r9
    d9c4:	a0 92 fd 06 	sts	0x06FD, r10
    d9c8:	b0 92 fe 06 	sts	0x06FE, r11
						razr*=10;
    d9cc:	c7 01       	movw	r24, r14
    d9ce:	b6 01       	movw	r22, r12
    d9d0:	2a e0       	ldi	r18, 0x0A	; 10
    d9d2:	30 e0       	ldi	r19, 0x00	; 0
    d9d4:	40 e0       	ldi	r20, 0x00	; 0
    d9d6:	50 e0       	ldi	r21, 0x00	; 0
    d9d8:	0e 94 53 84 	call	0x108a6	; 0x108a6 <__mulsi3>
    d9dc:	6b 01       	movw	r12, r22
    d9de:	7c 01       	movw	r14, r24
						charnum++;	
    d9e0:	73 94       	inc	r7
			{
					Ballance=*(istr-1)-0x30;
					Ballance+=(*(istr-2)-0x30)*10;
					uint8_t charnum=4;
					uint32_t razr=100;
					while((*(istr-charnum)>=0x30)&&(*(istr-charnum)<=0x39)){
    d9e2:	f8 01       	movw	r30, r16
    d9e4:	e7 19       	sub	r30, r7
    d9e6:	f1 09       	sbc	r31, r1
    d9e8:	60 81       	ld	r22, Z
    d9ea:	86 2f       	mov	r24, r22
    d9ec:	80 53       	subi	r24, 0x30	; 48
    d9ee:	8a 30       	cpi	r24, 0x0A	; 10
    d9f0:	b0 f2       	brcs	.-84     	; 0xd99e <GSM_Cycle+0x13fe>
						Ballance+=(*(istr-charnum)-0x30)*razr;
						razr*=10;
						charnum++;	
					}
					if(*(istr-charnum)==0x2D)
    d9f2:	6d 32       	cpi	r22, 0x2D	; 45
    d9f4:	11 f0       	breq	.+4      	; 0xd9fa <GSM_Cycle+0x145a>
    d9f6:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
					{
						Ballance*=-1;
    d9fa:	80 91 fb 06 	lds	r24, 0x06FB
    d9fe:	90 91 fc 06 	lds	r25, 0x06FC
    da02:	a0 91 fd 06 	lds	r26, 0x06FD
    da06:	b0 91 fe 06 	lds	r27, 0x06FE
    da0a:	b0 95       	com	r27
    da0c:	a0 95       	com	r26
    da0e:	90 95       	com	r25
    da10:	81 95       	neg	r24
    da12:	9f 4f       	sbci	r25, 0xFF	; 255
    da14:	af 4f       	sbci	r26, 0xFF	; 255
    da16:	bf 4f       	sbci	r27, 0xFF	; 255
    da18:	80 93 fb 06 	sts	0x06FB, r24
    da1c:	90 93 fc 06 	sts	0x06FC, r25
    da20:	a0 93 fd 06 	sts	0x06FD, r26
    da24:	b0 93 fe 06 	sts	0x06FE, r27
    da28:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
					GSM_State = GSM_WAIT_DISCONNECT_CAUSE;
					StartTimer16(TD_GSM, 10000);
					break;
				}
			}
			if(Timer16Stopp(TD_GSM)){
    da2c:	80 91 e9 04 	lds	r24, 0x04E9
    da30:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <Timer16Stopp>
    da34:	88 23       	and	r24, r24
    da36:	11 f4       	brne	.+4      	; 0xda3c <GSM_Cycle+0x149c>
    da38:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
				GSM_State = GSM_WAIT_MESSAGE;
    da3c:	8e e0       	ldi	r24, 0x0E	; 14
    da3e:	80 93 f6 06 	sts	0x06F6, r24
    da42:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
				if((strstr_P(GSM_RxStr, PSTR("+CREC: 0")) != NULL) ){
					GSM_State = GSM_SEND_PLAY_CONFIRM_FILE;
					break;
				}
			}
			if(Timer16Stopp(TD_GSM)){
    da46:	80 91 e9 04 	lds	r24, 0x04E9
    da4a:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <Timer16Stopp>
    da4e:	88 23       	and	r24, r24
    da50:	11 f4       	brne	.+4      	; 0xda56 <GSM_Cycle+0x14b6>
    da52:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
				GSM_State = GSM_WAIT_MESSAGE;
    da56:	8e e0       	ldi	r24, 0x0E	; 14
    da58:	80 93 f6 06 	sts	0x06F6, r24
    da5c:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
				if((strstr_P(GSM_RxStr, PSTR("+CREC: 0")) != NULL) ){
					GSM_State = GSM_WAIT_CONFIRMRESPONSE;
					StartTimer16(TD_GSM, 200);
					break;
				}
				if(analize_DTMF()){
    da60:	0e 94 4d 4c 	call	0x989a	; 0x989a <analize_DTMF>
    da64:	88 23       	and	r24, r24
    da66:	11 f0       	breq	.+4      	; 0xda6c <GSM_Cycle+0x14cc>
    da68:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
					break;
				}
			}
			if(Timer16Stopp(TD_GSM)){
    da6c:	80 91 e9 04 	lds	r24, 0x04E9
    da70:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <Timer16Stopp>
    da74:	88 23       	and	r24, r24
    da76:	11 f4       	brne	.+4      	; 0xda7c <GSM_Cycle+0x14dc>
    da78:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
				GSM_State = GSM_WAIT_MESSAGE;
    da7c:	8e e0       	ldi	r24, 0x0E	; 14
    da7e:	80 93 f6 06 	sts	0x06F6, r24
    da82:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
			if(GetStringFromFIFO()){
				if((strstr_P(GSM_RxStr, PSTR("+CREC: 0")) != NULL) ){
					GSM_State = GSM_SEND_PLAY_CONFIRMREQUEST_FILE;
					break;
				}
				if(analize_DTMF()){
    da86:	0e 94 4d 4c 	call	0x989a	; 0x989a <analize_DTMF>
    da8a:	88 23       	and	r24, r24
    da8c:	11 f0       	breq	.+4      	; 0xda92 <GSM_Cycle+0x14f2>
    da8e:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
					break;
				}
			}
			if(Timer16Stopp(TD_GSM)){
    da92:	80 91 e9 04 	lds	r24, 0x04E9
    da96:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <Timer16Stopp>
    da9a:	88 23       	and	r24, r24
    da9c:	11 f4       	brne	.+4      	; 0xdaa2 <GSM_Cycle+0x1502>
    da9e:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
				GSM_State = GSM_WAIT_MESSAGE;
    daa2:	8e e0       	ldi	r24, 0x0E	; 14
    daa4:	80 93 f6 06 	sts	0x06F6, r24
    daa8:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
			if(GetStringFromFIFO()){
				SetIP(&GSM_MyIP,0,0,0,0);
				for(uint8_t i=0; i<strlen(GSM_RxStr); i++)
					if(!isdigit(GSM_RxStr[i])) GSM_RxStr[i] = ' ';
				sscanf_P(GSM_RxStr,PSTR("%hhu %hhu %hhu %hhu"), (unsigned char*)&GSM_MyIP.IP1, (unsigned char*)&GSM_MyIP.IP2, (unsigned char*)&GSM_MyIP.IP3, (unsigned char*)&GSM_MyIP.IP4);
    daac:	ed b7       	in	r30, 0x3d	; 61
    daae:	fe b7       	in	r31, 0x3e	; 62
    dab0:	3c 97       	sbiw	r30, 0x0c	; 12
    dab2:	0f b6       	in	r0, 0x3f	; 63
    dab4:	f8 94       	cli
    dab6:	fe bf       	out	0x3e, r31	; 62
    dab8:	0f be       	out	0x3f, r0	; 63
    daba:	ed bf       	out	0x3d, r30	; 61
    dabc:	31 96       	adiw	r30, 0x01	; 1
    dabe:	80 ee       	ldi	r24, 0xE0	; 224
    dac0:	97 e0       	ldi	r25, 0x07	; 7
    dac2:	ad b7       	in	r26, 0x3d	; 61
    dac4:	be b7       	in	r27, 0x3e	; 62
    dac6:	12 96       	adiw	r26, 0x02	; 2
    dac8:	9c 93       	st	X, r25
    daca:	8e 93       	st	-X, r24
    dacc:	11 97       	sbiw	r26, 0x01	; 1
    dace:	89 e5       	ldi	r24, 0x59	; 89
    dad0:	9d e2       	ldi	r25, 0x2D	; 45
    dad2:	93 83       	std	Z+3, r25	; 0x03
    dad4:	82 83       	std	Z+2, r24	; 0x02
    dad6:	55 83       	std	Z+5, r21	; 0x05
    dad8:	44 83       	std	Z+4, r20	; 0x04
    dada:	77 83       	std	Z+7, r23	; 0x07
    dadc:	66 83       	std	Z+6, r22	; 0x06
    dade:	11 87       	std	Z+9, r17	; 0x09
    dae0:	00 87       	std	Z+8, r16	; 0x08
    dae2:	f3 86       	std	Z+11, r15	; 0x0b
    dae4:	e2 86       	std	Z+10, r14	; 0x0a
    dae6:	0e 94 6e 82 	call	0x104dc	; 0x104dc <sscanf_P>
}
uint8_t IP_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	if((IP->IP1 == IP1) && (IP->IP2 == IP2) && (IP->IP3 == IP3) && (IP->IP4 == IP4)) return 1;
    daea:	ed b7       	in	r30, 0x3d	; 61
    daec:	fe b7       	in	r31, 0x3e	; 62
    daee:	3c 96       	adiw	r30, 0x0c	; 12
    daf0:	0f b6       	in	r0, 0x3f	; 63
    daf2:	f8 94       	cli
    daf4:	fe bf       	out	0x3e, r31	; 62
    daf6:	0f be       	out	0x3f, r0	; 63
    daf8:	ed bf       	out	0x3d, r30	; 61
    dafa:	80 91 30 09 	lds	r24, 0x0930
    dafe:	88 23       	and	r24, r24
    db00:	09 f0       	breq	.+2      	; 0xdb04 <GSM_Cycle+0x1564>
    db02:	91 c0       	rjmp	.+290    	; 0xdc26 <GSM_Cycle+0x1686>
    db04:	80 91 31 09 	lds	r24, 0x0931
    db08:	88 23       	and	r24, r24
    db0a:	09 f0       	breq	.+2      	; 0xdb0e <GSM_Cycle+0x156e>
    db0c:	8c c0       	rjmp	.+280    	; 0xdc26 <GSM_Cycle+0x1686>
    db0e:	80 91 32 09 	lds	r24, 0x0932
    db12:	88 23       	and	r24, r24
    db14:	09 f0       	breq	.+2      	; 0xdb18 <GSM_Cycle+0x1578>
    db16:	87 c0       	rjmp	.+270    	; 0xdc26 <GSM_Cycle+0x1686>
    db18:	80 91 33 09 	lds	r24, 0x0933
    db1c:	88 23       	and	r24, r24
    db1e:	09 f0       	breq	.+2      	; 0xdb22 <GSM_Cycle+0x1582>
    db20:	82 c0       	rjmp	.+260    	; 0xdc26 <GSM_Cycle+0x1686>
				if(!IP_compare_Const(&GSM_MyIP,0,0,0,0)){
				  GSM_State = GSM_SEND_CIPSTART_TCP_CLIENT;
				}
				TempNum=0;	//
    db22:	10 92 dc 05 	sts	0x05DC, r1
    db26:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State=GSM_SEND_ATD_Check_Ballance;
			break;
		//------------------------
		case GSM_SEND_CIPMUX:
			if(GSM_MultiCon) GSM_Execute_Command(AT_CIPMUX_1, 100*GSM_DEBUG_DELAY);
			else GSM_Execute_Command(AT_CIPMUX_0, 100*GSM_DEBUG_DELAY);
    db2a:	85 e1       	ldi	r24, 0x15	; 21
    db2c:	95 e0       	ldi	r25, 0x05	; 5
    db2e:	64 e6       	ldi	r22, 0x64	; 100
    db30:	70 e0       	ldi	r23, 0x00	; 0
    db32:	0e 94 3a 4c 	call	0x9874	; 0x9874 <GSM_Execute_Command>
    db36:	ca cc       	rjmp	.-1644   	; 0xd4cc <GSM_Cycle+0xf2c>
			if(GSM_Wait_Response_P(RESP_OK, GSM_WAIT_MESSAGE)) GSM_State = GSM_WAIT_CCLC_2;
			StartTimer16(TD_GSM, 1000);
			break;
		case GSM_WAIT_CCLC_2:
			if(GetStringFromFIFO()){
				if( (strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,2,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 2,0,2,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 3,0,2,")) != NULL) ){
    db38:	80 ee       	ldi	r24, 0xE0	; 224
    db3a:	97 e0       	ldi	r25, 0x07	; 7
    db3c:	64 e4       	ldi	r22, 0x44	; 68
    db3e:	7f e2       	ldi	r23, 0x2F	; 47
    db40:	0e 94 1f 81 	call	0x1023e	; 0x1023e <strstr_P>
    db44:	89 2b       	or	r24, r25
    db46:	09 f0       	breq	.+2      	; 0xdb4a <GSM_Cycle+0x15aa>
    db48:	d1 c9       	rjmp	.-3166   	; 0xceec <GSM_Cycle+0x94c>
    db4a:	80 ee       	ldi	r24, 0xE0	; 224
    db4c:	97 e0       	ldi	r25, 0x07	; 7
    db4e:	66 e3       	ldi	r22, 0x36	; 54
    db50:	7f e2       	ldi	r23, 0x2F	; 47
    db52:	0e 94 1f 81 	call	0x1023e	; 0x1023e <strstr_P>
    db56:	89 2b       	or	r24, r25
    db58:	09 f0       	breq	.+2      	; 0xdb5c <GSM_Cycle+0x15bc>
    db5a:	c8 c9       	rjmp	.-3184   	; 0xceec <GSM_Cycle+0x94c>
					StartTimer16(TD_GSM, 2000);
					GSM_State = GSM_WAIT_CCLC_3;
					break;
				}
			}
			if(Timer16Stopp(TD_GSM)){
    db5c:	80 91 e9 04 	lds	r24, 0x04E9
    db60:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <Timer16Stopp>
    db64:	88 23       	and	r24, r24
    db66:	11 f4       	brne	.+4      	; 0xdb6c <GSM_Cycle+0x15cc>
    db68:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
				GSM_State = GSM_WAIT_MESSAGE;
    db6c:	8e e0       	ldi	r24, 0x0E	; 14
    db6e:	80 93 f6 06 	sts	0x06F6, r24
    db72:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
				if( (strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 2,0,6,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 3,0,6,")) != NULL) ){
					StartTimer16(TD_GSM, 6000);
					GSM_State = GSM_WAIT_MESSAGE;
					break;
				}
				if( (strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,3,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 2,0,3,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 3,0,3,")) != NULL) ){
    db76:	80 ee       	ldi	r24, 0xE0	; 224
    db78:	97 e0       	ldi	r25, 0x07	; 7
    db7a:	60 ef       	ldi	r22, 0xF0	; 240
    db7c:	7e e2       	ldi	r23, 0x2E	; 46
    db7e:	0e 94 1f 81 	call	0x1023e	; 0x1023e <strstr_P>
    db82:	89 2b       	or	r24, r25
    db84:	09 f0       	breq	.+2      	; 0xdb88 <GSM_Cycle+0x15e8>
    db86:	d0 c2       	rjmp	.+1440   	; 0xe128 <GSM_Cycle+0x1b88>
    db88:	80 ee       	ldi	r24, 0xE0	; 224
    db8a:	97 e0       	ldi	r25, 0x07	; 7
    db8c:	62 ee       	ldi	r22, 0xE2	; 226
    db8e:	7e e2       	ldi	r23, 0x2E	; 46
    db90:	0e 94 1f 81 	call	0x1023e	; 0x1023e <strstr_P>
    db94:	89 2b       	or	r24, r25
    db96:	09 f0       	breq	.+2      	; 0xdb9a <GSM_Cycle+0x15fa>
    db98:	c7 c2       	rjmp	.+1422   	; 0xe128 <GSM_Cycle+0x1b88>
					GSM_State = GSM_WAIT_CCLC_0;
					break;
				}

			}
			if(Timer16Stopp(TD_GSM)){
    db9a:	80 91 e9 04 	lds	r24, 0x04E9
    db9e:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <Timer16Stopp>
    dba2:	88 23       	and	r24, r24
    dba4:	11 f4       	brne	.+4      	; 0xdbaa <GSM_Cycle+0x160a>
    dba6:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
				GSM_State = GSM_WAIT_MESSAGE;
    dbaa:	8e e0       	ldi	r24, 0x0E	; 14
    dbac:	80 93 f6 06 	sts	0x06F6, r24
    dbb0:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
				if((strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,0,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,0,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,0,")) != NULL) ){
					RequestRepeatCounter = 0;
					GSM_State = GSM_SEND_PLAY_ALARM_FILE;
					break;
				}
				if( (strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6,")) != NULL)){
    dbb4:	80 ee       	ldi	r24, 0xE0	; 224
    dbb6:	97 e0       	ldi	r25, 0x07	; 7
    dbb8:	6c e9       	ldi	r22, 0x9C	; 156
    dbba:	7e e2       	ldi	r23, 0x2E	; 46
    dbbc:	0e 94 1f 81 	call	0x1023e	; 0x1023e <strstr_P>
    dbc0:	89 2b       	or	r24, r25
    dbc2:	09 f0       	breq	.+2      	; 0xdbc6 <GSM_Cycle+0x1626>
    dbc4:	fb c2       	rjmp	.+1526   	; 0xe1bc <GSM_Cycle+0x1c1c>
    dbc6:	80 ee       	ldi	r24, 0xE0	; 224
    dbc8:	97 e0       	ldi	r25, 0x07	; 7
    dbca:	6e e8       	ldi	r22, 0x8E	; 142
    dbcc:	7e e2       	ldi	r23, 0x2E	; 46
    dbce:	0e 94 1f 81 	call	0x1023e	; 0x1023e <strstr_P>
    dbd2:	89 2b       	or	r24, r25
    dbd4:	09 f0       	breq	.+2      	; 0xdbd8 <GSM_Cycle+0x1638>
    dbd6:	f2 c2       	rjmp	.+1508   	; 0xe1bc <GSM_Cycle+0x1c1c>
					StartTimer16(TD_GSM, 6000);
					GSM_State = GSM_WAIT_DISCONNECT_CAUSE;
					break;
				}
			}
			if(Timer16Stopp(TD_GSM)){
    dbd8:	80 91 e9 04 	lds	r24, 0x04E9
    dbdc:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <Timer16Stopp>
    dbe0:	88 23       	and	r24, r24
    dbe2:	11 f4       	brne	.+4      	; 0xdbe8 <GSM_Cycle+0x1648>
    dbe4:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
				GSM_State = GSM_WAIT_MESSAGE;
    dbe8:	8e e0       	ldi	r24, 0x0E	; 14
    dbea:	80 93 f6 06 	sts	0x06F6, r24
    dbee:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
			sprintf(GSM_TxStr+GSMTxSz,"%u",Message[2]);
			if(Message[2]>9){
				GSMTxSz+=2;
			}
			else{
				GSMTxSz++;
    dbf2:	80 91 bb 07 	lds	r24, 0x07BB
    dbf6:	8f 5f       	subi	r24, 0xFF	; 255
    dbf8:	80 93 bb 07 	sts	0x07BB, r24
    dbfc:	c9 c9       	rjmp	.-3182   	; 0xcf90 <GSM_Cycle+0x9f0>
				else GSM_State++;
			}
			break;
		case GSM_SEND_CIPMODE:
			if(GSM_MultiCon) GSM_Execute_Command(AT_CIPMODE_0, 100*GSM_DEBUG_DELAY);
			else GSM_Execute_Command(AT_CIPMODE_1, 100*GSM_DEBUG_DELAY);
    dbfe:	88 e0       	ldi	r24, 0x08	; 8
    dc00:	95 e0       	ldi	r25, 0x05	; 5
    dc02:	64 e6       	ldi	r22, 0x64	; 100
    dc04:	70 e0       	ldi	r23, 0x00	; 0
    dc06:	0e 94 3a 4c 	call	0x9874	; 0x9874 <GSM_Execute_Command>
    dc0a:	7c cb       	rjmp	.-2312   	; 0xd304 <GSM_Cycle+0xd64>
					break;
				}
				GSM_State = GSM_WAIT_MESSAGE;
				break;
			}
			if(Timer16Stopp(TD_GSM)){
    dc0c:	80 91 e9 04 	lds	r24, 0x04E9
    dc10:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <Timer16Stopp>
    dc14:	88 23       	and	r24, r24
    dc16:	11 f4       	brne	.+4      	; 0xdc1c <GSM_Cycle+0x167c>
    dc18:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
				GSM_State = GSM_WAIT_MESSAGE;
    dc1c:	8e e0       	ldi	r24, 0x0E	; 14
    dc1e:	80 93 f6 06 	sts	0x06F6, r24
    dc22:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
				SetIP(&GSM_MyIP,0,0,0,0);
				for(uint8_t i=0; i<strlen(GSM_RxStr); i++)
					if(!isdigit(GSM_RxStr[i])) GSM_RxStr[i] = ' ';
				sscanf_P(GSM_RxStr,PSTR("%hhu %hhu %hhu %hhu"), (unsigned char*)&GSM_MyIP.IP1, (unsigned char*)&GSM_MyIP.IP2, (unsigned char*)&GSM_MyIP.IP3, (unsigned char*)&GSM_MyIP.IP4);
				if(!IP_compare_Const(&GSM_MyIP,0,0,0,0)){
				  GSM_State = GSM_SEND_CIPSTART_TCP_CLIENT;
    dc26:	8b e3       	ldi	r24, 0x3B	; 59
    dc28:	80 93 f6 06 	sts	0x06F6, r24
    dc2c:	7a cf       	rjmp	.-268    	; 0xdb22 <GSM_Cycle+0x1582>
					if(GSM_RxCharN==2)
						{
							if(!strncmp_P(GSM_RxStr, PSTR("\r\n"), 2)) {GSM_RxCharN=0;}
						}
					if(GSM_RxCharN >= 4){
						AppProtocol = 0;
    dc2e:	10 92 e6 08 	sts	0x08E6, r1
						if(!strncmp_P(GSM_RxStr, PSTR("GET "), 4)) {AppProtocol = _HTTP;GSM_State = GSM_DataMode;break;}//GET
    dc32:	80 ee       	ldi	r24, 0xE0	; 224
    dc34:	97 e0       	ldi	r25, 0x07	; 7
    dc36:	61 e3       	ldi	r22, 0x31	; 49
    dc38:	7d e2       	ldi	r23, 0x2D	; 45
    dc3a:	44 e0       	ldi	r20, 0x04	; 4
    dc3c:	50 e0       	ldi	r21, 0x00	; 0
    dc3e:	0e 94 06 81 	call	0x1020c	; 0x1020c <strncmp_P>
    dc42:	89 2b       	or	r24, r25
    dc44:	09 f4       	brne	.+2      	; 0xdc48 <GSM_Cycle+0x16a8>
    dc46:	3b c3       	rjmp	.+1654   	; 0xe2be <GSM_Cycle+0x1d1e>
						if(!strncmp_P(GSM_RxStr, PSTR("POST"), 4)) {AppProtocol = _HTTP;GSM_State = GSM_DataMode;break;}//POST
    dc48:	80 ee       	ldi	r24, 0xE0	; 224
    dc4a:	97 e0       	ldi	r25, 0x07	; 7
    dc4c:	6c e2       	ldi	r22, 0x2C	; 44
    dc4e:	7d e2       	ldi	r23, 0x2D	; 45
    dc50:	44 e0       	ldi	r20, 0x04	; 4
    dc52:	50 e0       	ldi	r21, 0x00	; 0
    dc54:	0e 94 06 81 	call	0x1020c	; 0x1020c <strncmp_P>
    dc58:	89 2b       	or	r24, r25
    dc5a:	09 f4       	brne	.+2      	; 0xdc5e <GSM_Cycle+0x16be>
    dc5c:	30 c3       	rjmp	.+1632   	; 0xe2be <GSM_Cycle+0x1d1e>
						if(!strncmp_P(GSM_RxStr, PSTR("CLOS"), 4)) {AppProtocol = _HTTP;GSM_State = GSM_ReStart1;break;}// 
    dc5e:	80 ee       	ldi	r24, 0xE0	; 224
    dc60:	97 e0       	ldi	r25, 0x07	; 7
    dc62:	67 e2       	ldi	r22, 0x27	; 39
    dc64:	7d e2       	ldi	r23, 0x2D	; 45
    dc66:	44 e0       	ldi	r20, 0x04	; 4
    dc68:	50 e0       	ldi	r21, 0x00	; 0
    dc6a:	0e 94 06 81 	call	0x1020c	; 0x1020c <strncmp_P>
    dc6e:	89 2b       	or	r24, r25
    dc70:	09 f4       	brne	.+2      	; 0xdc74 <GSM_Cycle+0x16d4>
    dc72:	1e c3       	rjmp	.+1596   	; 0xe2b0 <GSM_Cycle+0x1d10>
						if(!strncmp_P(GSM_RxStr, PSTR("+PDP"), 4)) {AppProtocol = _HTTP;GSM_State = GSM_ReStart1;break;}//GPRS 
    dc74:	80 ee       	ldi	r24, 0xE0	; 224
    dc76:	97 e0       	ldi	r25, 0x07	; 7
    dc78:	62 e2       	ldi	r22, 0x22	; 34
    dc7a:	7d e2       	ldi	r23, 0x2D	; 45
    dc7c:	44 e0       	ldi	r20, 0x04	; 4
    dc7e:	50 e0       	ldi	r21, 0x00	; 0
    dc80:	0e 94 06 81 	call	0x1020c	; 0x1020c <strncmp_P>
    dc84:	89 2b       	or	r24, r25
    dc86:	09 f4       	brne	.+2      	; 0xdc8a <GSM_Cycle+0x16ea>
    dc88:	13 c3       	rjmp	.+1574   	; 0xe2b0 <GSM_Cycle+0x1d10>
						if( (GSM_RxStr[0]==0) && (GSM_RxStr[1]==0)){AppProtocol = _HTTP;GSM_State = GSM_ReStart1;break;}//  
    dc8a:	80 91 e0 07 	lds	r24, 0x07E0
    dc8e:	88 23       	and	r24, r24
    dc90:	29 f4       	brne	.+10     	; 0xdc9c <GSM_Cycle+0x16fc>
    dc92:	80 91 e1 07 	lds	r24, 0x07E1
    dc96:	88 23       	and	r24, r24
    dc98:	09 f4       	brne	.+2      	; 0xdc9c <GSM_Cycle+0x16fc>
    dc9a:	0a c3       	rjmp	.+1556   	; 0xe2b0 <GSM_Cycle+0x1d10>
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    dc9c:	8f ef       	ldi	r24, 0xFF	; 255
    dc9e:	80 93 3e 07 	sts	0x073E, r24
	GSM_RX_FIFO_End = 255;
    dca2:	80 93 53 06 	sts	0x0653, r24
	GSM_RxCharN = 0;
    dca6:	10 92 5f 0b 	sts	0x0B5F, r1
	GSM_RX_FIFOOverFlow = 0;
    dcaa:	10 92 12 09 	sts	0x0912, r1
	GSM_RX_FIFOMax = 0;
    dcae:	10 92 18 09 	sts	0x0918, r1
						StartTimer16(TD_CleanFIFO,500);
						//break;
					}
				}//while
				//GSM_RxCharN=0;
				if(Timer16Stopp(TD_CleanFIFO)&&(GSM_RX_FIFO_Begin == GSM_RX_FIFO_End)){
    dcb2:	80 91 ef 04 	lds	r24, 0x04EF
    dcb6:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <Timer16Stopp>
    dcba:	88 23       	and	r24, r24
    dcbc:	b9 f0       	breq	.+46     	; 0xdcec <GSM_Cycle+0x174c>
    dcbe:	90 91 3e 07 	lds	r25, 0x073E
    dcc2:	80 91 53 06 	lds	r24, 0x0653
    dcc6:	98 17       	cp	r25, r24
    dcc8:	89 f4       	brne	.+34     	; 0xdcec <GSM_Cycle+0x174c>
					StartTimer16(TD_CleanFIFO,500);
    dcca:	80 91 ef 04 	lds	r24, 0x04EF
    dcce:	64 ef       	ldi	r22, 0xF4	; 244
    dcd0:	71 e0       	ldi	r23, 0x01	; 1
    dcd2:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    dcd6:	8f ef       	ldi	r24, 0xFF	; 255
    dcd8:	80 93 3e 07 	sts	0x073E, r24
	GSM_RX_FIFO_End = 255;
    dcdc:	80 93 53 06 	sts	0x0653, r24
	GSM_RxCharN = 0;
    dce0:	10 92 5f 0b 	sts	0x0B5F, r1
	GSM_RX_FIFOOverFlow = 0;
    dce4:	10 92 12 09 	sts	0x0912, r1
	GSM_RX_FIFOMax = 0;
    dce8:	10 92 18 09 	sts	0x0918, r1
				if(Timer16Stopp(TD_CleanFIFO)&&(GSM_RX_FIFO_Begin == GSM_RX_FIFO_End)){
					StartTimer16(TD_CleanFIFO,500);
					InitFIFO();
				}

				if(Timer16Stopp(TD_data_start_delay)){
    dcec:	80 91 f0 04 	lds	r24, 0x04F0
    dcf0:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <Timer16Stopp>
    dcf4:	88 23       	and	r24, r24
    dcf6:	11 f4       	brne	.+4      	; 0xdcfc <GSM_Cycle+0x175c>
    dcf8:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
					if(GPRS_FlgSz_Out && (GPRS_FlgSz_Out <= GPRS_Out_MaxSz)&&(GSM_Flag&(1<<flg_TxCStr))&&Timer16Stopp(TD_timer_after_page_transfer)&&(!dataSendFlg)){			
    dcfc:	80 91 b1 07 	lds	r24, 0x07B1
    dd00:	88 23       	and	r24, r24
    dd02:	11 f4       	brne	.+4      	; 0xdd08 <GSM_Cycle+0x1768>
    dd04:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
    dd08:	80 91 d2 02 	lds	r24, 0x02D2
    dd0c:	80 fd       	sbrc	r24, 0
    dd0e:	02 c0       	rjmp	.+4      	; 0xdd14 <GSM_Cycle+0x1774>
    dd10:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
    dd14:	80 91 f1 04 	lds	r24, 0x04F1
    dd18:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <Timer16Stopp>
    dd1c:	88 23       	and	r24, r24
    dd1e:	11 f4       	brne	.+4      	; 0xdd24 <GSM_Cycle+0x1784>
    dd20:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
    dd24:	80 91 df 02 	lds	r24, 0x02DF
    dd28:	88 23       	and	r24, r24
    dd2a:	11 f0       	breq	.+4      	; 0xdd30 <GSM_Cycle+0x1790>
    dd2c:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
							dataSendFlg=1;
    dd30:	81 e0       	ldi	r24, 0x01	; 1
    dd32:	80 93 df 02 	sts	0x02DF, r24
							GSM_AddHeaderSendData(GPRS_Data_Out, GPRS_FlgSz_Out);
    dd36:	85 e4       	ldi	r24, 0x45	; 69
    dd38:	99 e0       	ldi	r25, 0x09	; 9
    dd3a:	60 91 b1 07 	lds	r22, 0x07B1
    dd3e:	0e 94 cd 41 	call	0x839a	; 0x839a <GSM_AddHeaderSendData>
    dd42:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
		/*	if(Timer16Stopp(TD_TCP_Connect)){	//        CommandMode
				GSM_State = GSM_Swtch2CommandMode;
				break;
			}*/
			//StartTimer16(TD_CheckModem,1000);
			if( (strstr_P(GSM_RxStr, URC_CLOSED+2) != NULL) ){
    dd46:	80 ee       	ldi	r24, 0xE0	; 224
    dd48:	97 e0       	ldi	r25, 0x07	; 7
    dd4a:	64 ed       	ldi	r22, 0xD4	; 212
    dd4c:	73 e0       	ldi	r23, 0x03	; 3
    dd4e:	0e 94 1f 81 	call	0x1023e	; 0x1023e <strstr_P>
    dd52:	89 2b       	or	r24, r25
    dd54:	11 f4       	brne	.+4      	; 0xdd5a <GSM_Cycle+0x17ba>
    dd56:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
				GSM_State =GSM_ReStart1;
    dd5a:	8a e4       	ldi	r24, 0x4A	; 74
    dd5c:	80 93 f6 06 	sts	0x06F6, r24
    dd60:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
			break;

		case GSM_SEND_CIPCSGP:
			//GSM_Execute_Command(AT_CIPCSGP, 300*GSM_DEBUG_DELAY); GSM_State++;
			if(GSM_Flag & (1<<flg_TxCStr)){
				sprintf_P(GSM_TxStr, AT_CIPCSGP);	GSMTxSz = strlen_P(AT_CIPCSGP);
    dd64:	00 d0       	rcall	.+0      	; 0xdd66 <GSM_Cycle+0x17c6>
    dd66:	0f 92       	push	r0
    dd68:	89 e4       	ldi	r24, 0x49	; 73
    dd6a:	9a e0       	ldi	r25, 0x0A	; 10
    dd6c:	ad b7       	in	r26, 0x3d	; 61
    dd6e:	be b7       	in	r27, 0x3e	; 62
    dd70:	12 96       	adiw	r26, 0x02	; 2
    dd72:	9c 93       	st	X, r25
    dd74:	8e 93       	st	-X, r24
    dd76:	11 97       	sbiw	r26, 0x01	; 1
    dd78:	08 e3       	ldi	r16, 0x38	; 56
    dd7a:	15 e0       	ldi	r17, 0x05	; 5
    dd7c:	14 96       	adiw	r26, 0x04	; 4
    dd7e:	1c 93       	st	X, r17
    dd80:	0e 93       	st	-X, r16
    dd82:	13 97       	sbiw	r26, 0x03	; 3
    dd84:	0e 94 1a 82 	call	0x10434	; 0x10434 <sprintf_P>
    dd88:	0f 90       	pop	r0
    dd8a:	0f 90       	pop	r0
    dd8c:	0f 90       	pop	r0
    dd8e:	0f 90       	pop	r0
    dd90:	c8 01       	movw	r24, r16
    dd92:	0e 94 fd 80 	call	0x101fa	; 0x101fa <strlen_P>
    dd96:	80 93 bb 07 	sts	0x07BB, r24
				#if LCDXSz==40
					GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn);
				#else
					GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn1);
    dd9a:	80 91 bb 07 	lds	r24, 0x07BB
    dd9e:	90 e0       	ldi	r25, 0x00	; 0
    dda0:	87 5b       	subi	r24, 0xB7	; 183
    dda2:	95 4f       	sbci	r25, 0xF5	; 245
    dda4:	69 e0       	ldi	r22, 0x09	; 9
    dda6:	70 e0       	ldi	r23, 0x00	; 0
    dda8:	0e 94 ad 62 	call	0xc55a	; 0xc55a <strcpy_EE>
    ddac:	90 91 bb 07 	lds	r25, 0x07BB
    ddb0:	98 0f       	add	r25, r24
    ddb2:	90 93 bb 07 	sts	0x07BB, r25
					GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn2);
    ddb6:	80 91 bb 07 	lds	r24, 0x07BB
    ddba:	90 e0       	ldi	r25, 0x00	; 0
    ddbc:	87 5b       	subi	r24, 0xB7	; 183
    ddbe:	95 4f       	sbci	r25, 0xF5	; 245
    ddc0:	6d e1       	ldi	r22, 0x1D	; 29
    ddc2:	70 e0       	ldi	r23, 0x00	; 0
    ddc4:	0e 94 ad 62 	call	0xc55a	; 0xc55a <strcpy_EE>
    ddc8:	90 91 bb 07 	lds	r25, 0x07BB
    ddcc:	98 0f       	add	r25, r24
    ddce:	90 93 bb 07 	sts	0x07BB, r25
				#endif
				sprintf(GSM_TxStr + GSMTxSz, "\",\"");	GSMTxSz = GSMTxSz+3;				
    ddd2:	e0 91 bb 07 	lds	r30, 0x07BB
    ddd6:	f0 e0       	ldi	r31, 0x00	; 0
    ddd8:	e7 5b       	subi	r30, 0xB7	; 183
    ddda:	f5 4f       	sbci	r31, 0xF5	; 245
    dddc:	a2 e2       	ldi	r26, 0x22	; 34
    ddde:	ea 2e       	mov	r14, r26
    dde0:	ac e2       	ldi	r26, 0x2C	; 44
    dde2:	fa 2e       	mov	r15, r26
    dde4:	a2 e2       	ldi	r26, 0x22	; 34
    dde6:	0a 2f       	mov	r16, r26
    dde8:	11 2d       	mov	r17, r1
    ddea:	e0 82       	st	Z, r14
    ddec:	f1 82       	std	Z+1, r15	; 0x01
    ddee:	02 83       	std	Z+2, r16	; 0x02
    ddf0:	13 83       	std	Z+3, r17	; 0x03
    ddf2:	80 91 bb 07 	lds	r24, 0x07BB
    ddf6:	8d 5f       	subi	r24, 0xFD	; 253
    ddf8:	80 93 bb 07 	sts	0x07BB, r24
				GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn_user_name);
    ddfc:	80 91 bb 07 	lds	r24, 0x07BB
    de00:	90 e0       	ldi	r25, 0x00	; 0
    de02:	87 5b       	subi	r24, 0xB7	; 183
    de04:	95 4f       	sbci	r25, 0xF5	; 245
    de06:	69 e5       	ldi	r22, 0x59	; 89
    de08:	70 e0       	ldi	r23, 0x00	; 0
    de0a:	0e 94 ad 62 	call	0xc55a	; 0xc55a <strcpy_EE>
    de0e:	90 91 bb 07 	lds	r25, 0x07BB
    de12:	98 0f       	add	r25, r24
    de14:	90 93 bb 07 	sts	0x07BB, r25
				sprintf(GSM_TxStr + GSMTxSz, "\",\"");	GSMTxSz = GSMTxSz+3;
    de18:	e0 91 bb 07 	lds	r30, 0x07BB
    de1c:	f0 e0       	ldi	r31, 0x00	; 0
    de1e:	e7 5b       	subi	r30, 0xB7	; 183
    de20:	f5 4f       	sbci	r31, 0xF5	; 245
    de22:	e0 82       	st	Z, r14
    de24:	f1 82       	std	Z+1, r15	; 0x01
    de26:	02 83       	std	Z+2, r16	; 0x02
    de28:	13 83       	std	Z+3, r17	; 0x03
    de2a:	80 91 bb 07 	lds	r24, 0x07BB
    de2e:	8d 5f       	subi	r24, 0xFD	; 253
    de30:	80 93 bb 07 	sts	0x07BB, r24
				GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn_psw);
    de34:	80 91 bb 07 	lds	r24, 0x07BB
    de38:	90 e0       	ldi	r25, 0x00	; 0
    de3a:	87 5b       	subi	r24, 0xB7	; 183
    de3c:	95 4f       	sbci	r25, 0xF5	; 245
    de3e:	6d e6       	ldi	r22, 0x6D	; 109
    de40:	70 e0       	ldi	r23, 0x00	; 0
    de42:	0e 94 ad 62 	call	0xc55a	; 0xc55a <strcpy_EE>
    de46:	90 91 bb 07 	lds	r25, 0x07BB
    de4a:	98 0f       	add	r25, r24
    de4c:	90 93 bb 07 	sts	0x07BB, r25
				sprintf(GSM_TxStr + GSMTxSz, "\"\r");	GSMTxSz = GSMTxSz+2;
    de50:	80 91 bb 07 	lds	r24, 0x07BB
    de54:	e8 2f       	mov	r30, r24
    de56:	f0 e0       	ldi	r31, 0x00	; 0
    de58:	e7 5b       	subi	r30, 0xB7	; 183
    de5a:	f5 4f       	sbci	r31, 0xF5	; 245
    de5c:	a5 eb       	ldi	r26, 0xB5	; 181
    de5e:	b2 e0       	ldi	r27, 0x02	; 2
    de60:	83 e0       	ldi	r24, 0x03	; 3
    de62:	0d 90       	ld	r0, X+
    de64:	01 92       	st	Z+, r0
    de66:	81 50       	subi	r24, 0x01	; 1
    de68:	e1 f7       	brne	.-8      	; 0xde62 <GSM_Cycle+0x18c2>
    de6a:	80 91 bb 07 	lds	r24, 0x07BB
    de6e:	8e 5f       	subi	r24, 0xFE	; 254
    de70:	80 93 bb 07 	sts	0x07BB, r24
				GSM_SendFirstChar();
    de74:	0e 94 bc 3a 	call	0x7578	; 0x7578 <GSM_SendFirstChar>
				StartTimer16(TD_GSM, 300*GSM_DEBUG_DELAY);
    de78:	80 91 e9 04 	lds	r24, 0x04E9
    de7c:	6c e2       	ldi	r22, 0x2C	; 44
    de7e:	71 e0       	ldi	r23, 0x01	; 1
    de80:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
    de84:	74 cc       	rjmp	.-1816   	; 0xd76e <GSM_Cycle+0x11ce>
		case GSM_WAIT_CSQ:
				if(Timer16Stopp(TD_GSM)){
						GSM_State = GSM_ReStart1;
				}
				else{				
					if(GetStringFromFIFO()){
    de86:	0e 94 92 39 	call	0x7324	; 0x7324 <GetStringFromFIFO>
    de8a:	88 23       	and	r24, r24
    de8c:	11 f4       	brne	.+4      	; 0xde92 <GSM_Cycle+0x18f2>
    de8e:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
						GSM_RSSI = 255; GSM_BER = 255;
    de92:	8f ef       	ldi	r24, 0xFF	; 255
    de94:	80 93 b2 06 	sts	0x06B2, r24
    de98:	80 93 ca 07 	sts	0x07CA, r24
						if(strstr_P(GSM_RxStr, RESP_CSQ) != NULL ){
    de9c:	00 ee       	ldi	r16, 0xE0	; 224
    de9e:	17 e0       	ldi	r17, 0x07	; 7
    dea0:	c8 01       	movw	r24, r16
    dea2:	63 e4       	ldi	r22, 0x43	; 67
    dea4:	74 e0       	ldi	r23, 0x04	; 4
    dea6:	0e 94 1f 81 	call	0x1023e	; 0x1023e <strstr_P>
    deaa:	89 2b       	or	r24, r25
    deac:	11 f4       	brne	.+4      	; 0xdeb2 <GSM_Cycle+0x1912>
    deae:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
							sscanf_P(GSM_RxStr,PSTR("+CSQ: %hhu,%hhu"), (unsigned char*)&GSM_RSSI, (unsigned char*)&GSM_BER);
    deb2:	ed b7       	in	r30, 0x3d	; 61
    deb4:	fe b7       	in	r31, 0x3e	; 62
    deb6:	38 97       	sbiw	r30, 0x08	; 8
    deb8:	0f b6       	in	r0, 0x3f	; 63
    deba:	f8 94       	cli
    debc:	fe bf       	out	0x3e, r31	; 62
    debe:	0f be       	out	0x3f, r0	; 63
    dec0:	ed bf       	out	0x3d, r30	; 61
    dec2:	31 96       	adiw	r30, 0x01	; 1
    dec4:	ad b7       	in	r26, 0x3d	; 61
    dec6:	be b7       	in	r27, 0x3e	; 62
    dec8:	12 96       	adiw	r26, 0x02	; 2
    deca:	1c 93       	st	X, r17
    decc:	0e 93       	st	-X, r16
    dece:	11 97       	sbiw	r26, 0x01	; 1
    ded0:	89 e3       	ldi	r24, 0x39	; 57
    ded2:	9d e2       	ldi	r25, 0x2D	; 45
    ded4:	93 83       	std	Z+3, r25	; 0x03
    ded6:	82 83       	std	Z+2, r24	; 0x02
    ded8:	82 eb       	ldi	r24, 0xB2	; 178
    deda:	96 e0       	ldi	r25, 0x06	; 6
    dedc:	95 83       	std	Z+5, r25	; 0x05
    dede:	84 83       	std	Z+4, r24	; 0x04
    dee0:	8a ec       	ldi	r24, 0xCA	; 202
    dee2:	97 e0       	ldi	r25, 0x07	; 7
    dee4:	97 83       	std	Z+7, r25	; 0x07
    dee6:	86 83       	std	Z+6, r24	; 0x06
    dee8:	0e 94 6e 82 	call	0x104dc	; 0x104dc <sscanf_P>
									
								GSM_State = GSM_WAIT_CSQ_OK;
    deec:	81 e5       	ldi	r24, 0x51	; 81
    deee:	80 93 f6 06 	sts	0x06F6, r24
    def2:	ed b7       	in	r30, 0x3d	; 61
    def4:	fe b7       	in	r31, 0x3e	; 62
    def6:	38 96       	adiw	r30, 0x08	; 8
    def8:	0f b6       	in	r0, 0x3f	; 63
    defa:	f8 94       	cli
    defc:	fe bf       	out	0x3e, r31	; 62
    defe:	0f be       	out	0x3f, r0	; 63
    df00:	ed bf       	out	0x3d, r30	; 61
    df02:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
				GSM_State = GSM_WAIT_MESSAGE;
			}
			break;
		case GSM_WAIT_CONFIRMRESPONSE:
			if(GetStringFromFIFO()){
					if((strstr_P(GSM_RxStr, PSTR("+DTMF: 1")) != NULL) ){
    df06:	80 ee       	ldi	r24, 0xE0	; 224
    df08:	97 e0       	ldi	r25, 0x07	; 7
    df0a:	6f e1       	ldi	r22, 0x1F	; 31
    df0c:	7e e2       	ldi	r23, 0x2E	; 46
    df0e:	0e 94 1f 81 	call	0x1023e	; 0x1023e <strstr_P>
    df12:	89 2b       	or	r24, r25
    df14:	49 f0       	breq	.+18     	; 0xdf28 <GSM_Cycle+0x1988>
						StartTimer16(TD_GSM,1000);
    df16:	80 91 e9 04 	lds	r24, 0x04E9
    df1a:	68 ee       	ldi	r22, 0xE8	; 232
    df1c:	73 e0       	ldi	r23, 0x03	; 3
    df1e:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
						GSM_State = GSM_SEND_PLAY_CONFIRM_FILE;
    df22:	8d e1       	ldi	r24, 0x1D	; 29
    df24:	80 93 f6 06 	sts	0x06F6, r24
						
					}
					if((strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 2,0,6")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 3,0,6")) != NULL) ){
    df28:	80 ee       	ldi	r24, 0xE0	; 224
    df2a:	97 e0       	ldi	r25, 0x07	; 7
    df2c:	62 e1       	ldi	r22, 0x12	; 18
    df2e:	7e e2       	ldi	r23, 0x2E	; 46
    df30:	0e 94 1f 81 	call	0x1023e	; 0x1023e <strstr_P>
    df34:	89 2b       	or	r24, r25
    df36:	09 f4       	brne	.+2      	; 0xdf3a <GSM_Cycle+0x199a>
    df38:	10 c1       	rjmp	.+544    	; 0xe15a <GSM_Cycle+0x1bba>
						StartTimer16(TD_GSM,2000);
    df3a:	80 91 e9 04 	lds	r24, 0x04E9
    df3e:	60 ed       	ldi	r22, 0xD0	; 208
    df40:	77 e0       	ldi	r23, 0x07	; 7
    df42:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
						GSM_State = GSM_WAIT_DISCONNECT_CAUSE;
    df46:	85 e2       	ldi	r24, 0x25	; 37
    df48:	80 93 f6 06 	sts	0x06F6, r24
    df4c:	0c 94 cf 66 	jmp	0xcd9e	; 0xcd9e <GSM_Cycle+0x7fe>
			break;
		case GSM_WAIT_MESSAGE:
			
			if(Message[0]==1)
			{
				Message[0]=0;
    df50:	10 92 35 07 	sts	0x0735, r1
				ConfirmState=0;
				ConfirmState = 0;
    df54:	10 92 e1 02 	sts	0x02E1, r1
				TransmitterState = 1;
    df58:	80 93 e3 02 	sts	0x02E3, r24
				GSM_State = GSM_SEND_ATD;
    df5c:	8f e0       	ldi	r24, 0x0F	; 15
    df5e:	80 93 f6 06 	sts	0x06F6, r24
    df62:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
			if(Timer16Stopp(TD_GSM)){
				if(RequestRepeatCounter<4){
				GSM_State = GSM_SEND_PLAY_ALARM_FILE;
				}
				else{
				GSM_State = GSM_SEND_PLAY_NOTCONFIRM_FILE;				
    df66:	80 e2       	ldi	r24, 0x20	; 32
    df68:	80 93 f6 06 	sts	0x06F6, r24
    df6c:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
				if(++TempNum>=MaxTelephDirSz){
					GSM_State = GSM_Return2dataMode;
					SMS_FlgSz_Out = 0;
					//StartTimer16(TD_GSM,150);
				}
				else GSM_State = GSM_SEND_CMGS;
    df70:	80 e4       	ldi	r24, 0x40	; 64
    df72:	80 93 f6 06 	sts	0x06F6, r24
    df76:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
			}
			break;
		case GSM_WAIT_D2C_SWITCH_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) {

				switch(CommandModeDestination){
    df7a:	84 30       	cpi	r24, 0x04	; 4
    df7c:	79 f1       	breq	.+94     	; 0xdfdc <GSM_Cycle+0x1a3c>
    df7e:	85 30       	cpi	r24, 0x05	; 5
    df80:	11 f0       	breq	.+4      	; 0xdf86 <GSM_Cycle+0x19e6>
    df82:	0c 94 fc 63 	jmp	0xc7f8	; 0xc7f8 <GSM_Cycle+0x258>
					case 4:	
						GSM_State = GSM_SEND_ATD_Check_Ballance;
						counter=0;	
						break;
					case 5:	
						GSM_State = GSM_SEND_CSQ;
    df86:	8f e4       	ldi	r24, 0x4F	; 79
    df88:	80 93 f6 06 	sts	0x06F6, r24
						counter=0;	
    df8c:	10 92 e0 02 	sts	0x02E0, r1
    df90:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
			if(GSM_Wait_Response_P(URC_CPIN_READY, GSM_ReStart1)) GSM_State++;
			break;

		case GSM_WAIT_CALL_READY:
			if(GSM_Wait_Response_P(URC_CALL_READY, GSM_ReStart1)){
				if(GSM_Modem == SIMCOM_SIM800) GSM_State = GSM_WAIT_SMS_READY;
    df94:	87 e0       	ldi	r24, 0x07	; 7
    df96:	80 93 f6 06 	sts	0x06F6, r24
    df9a:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
				}
			break;
		case GSM_WAIT_CSQ_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) {
				if(CommandModeDestination==5){
					GSM_State  = GSM_Return2dataMode;
    df9e:	87 e5       	ldi	r24, 0x57	; 87
    dfa0:	80 93 f6 06 	sts	0x06F6, r24
    dfa4:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
			if(GetStringFromFIFO()){
				if(!strcmp_P(GSM_RxStr, GSM_SIMCOM_SIM900R)) GSM_Modem = SIMCOM_SIM900R;
				if(!strcmp_P(GSM_RxStr, GSM_SIMCOM_SIM800)) GSM_Modem = SIMCOM_SIM800;
				if(!strcmp_P(GSM_RxStr, GSM_SIMCOM_SIM800C)) GSM_Modem = SIMCOM_SIM800;
				//Add here new model GSM-modem
				if(GSM_Modem != NOT_RECOGNIZED) GSM_State = GSM_WAIT_CALL_READY;
    dfa8:	80 91 34 07 	lds	r24, 0x0734
    dfac:	88 23       	and	r24, r24
    dfae:	11 f4       	brne	.+4      	; 0xdfb4 <GSM_Cycle+0x1a14>
    dfb0:	0c 94 8f 63 	jmp	0xc71e	; 0xc71e <GSM_Cycle+0x17e>
    dfb4:	0c 94 8c 63 	jmp	0xc718	; 0xc718 <GSM_Cycle+0x178>
			}
			GSM_State++;
			break;
		case GSM_WAIT_CIPCSGP_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
			 if(GSM_Modem == SIMCOM_SIM800)GSM_State++;
    dfb8:	80 91 f6 06 	lds	r24, 0x06F6
    dfbc:	8f 5f       	subi	r24, 0xFF	; 255
    dfbe:	80 93 f6 06 	sts	0x06F6, r24
    dfc2:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
			GSM_State++; 
			break;
		case GSM_WAIT_CIPMUX_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
				if(GSM_MultiCon){
					GSM_State = GSM_WAIT_1;
    dfc6:	8e e2       	ldi	r24, 0x2E	; 46
    dfc8:	80 93 f6 06 	sts	0x06F6, r24
					// between "Call Ready" and "+CMGS"; 8 sec min needs; for kyivstar vpni only
					StartTimer16(TD_GSM, 1000);
    dfcc:	80 91 e9 04 	lds	r24, 0x04E9
    dfd0:	68 ee       	ldi	r22, 0xE8	; 232
    dfd2:	73 e0       	ldi	r23, 0x03	; 3
    dfd4:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
    dfd8:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
					case 2:	
						GSM_State = GSM_CIPSHUT_;
						counter=0;	
						break;						
					case 4:	
						GSM_State = GSM_SEND_ATD_Check_Ballance;
    dfdc:	8c e4       	ldi	r24, 0x4C	; 76
    dfde:	80 93 f6 06 	sts	0x06F6, r24
						counter=0;	
    dfe2:	10 92 e0 02 	sts	0x02E0, r1
    dfe6:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
				GSMTxSz = strlen(GSM_TxStr);
				uint8_t j=0;
				for(uint8_t i=0; i<GSMTxSz; i++)
					if(GSM_TxStr[i] != '0') j++;
				if(j){
					GSMTxSz = strlen_P(AT_CMGS);
    dfea:	00 ef       	ldi	r16, 0xF0	; 240
    dfec:	14 e0       	ldi	r17, 0x04	; 4
    dfee:	c8 01       	movw	r24, r16
    dff0:	0e 94 fd 80 	call	0x101fa	; 0x101fa <strlen_P>
    dff4:	80 93 bb 07 	sts	0x07BB, r24
					sprintf_P(GSM_TxStr, AT_CMGS);
    dff8:	00 d0       	rcall	.+0      	; 0xdffa <GSM_Cycle+0x1a5a>
    dffa:	0f 92       	push	r0
    dffc:	ad b7       	in	r26, 0x3d	; 61
    dffe:	be b7       	in	r27, 0x3e	; 62
    e000:	12 96       	adiw	r26, 0x02	; 2
    e002:	fc 92       	st	X, r15
    e004:	ee 92       	st	-X, r14
    e006:	11 97       	sbiw	r26, 0x01	; 1
    e008:	14 96       	adiw	r26, 0x04	; 4
    e00a:	1c 93       	st	X, r17
    e00c:	0e 93       	st	-X, r16
    e00e:	13 97       	sbiw	r26, 0x03	; 3
    e010:	0e 94 1a 82 	call	0x10434	; 0x10434 <sprintf_P>
					erbl(GSM_TxStr+GSMTxSz, SMS_Number+TempNum, MaxTelephN);
    e014:	80 91 bb 07 	lds	r24, 0x07BB
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    e018:	0f 90       	pop	r0
    e01a:	0f 90       	pop	r0
    e01c:	0f 90       	pop	r0
    e01e:	0f 90       	pop	r0
    e020:	90 e0       	ldi	r25, 0x00	; 0
    e022:	60 91 dc 05 	lds	r22, 0x05DC
    e026:	2d e0       	ldi	r18, 0x0D	; 13
    e028:	62 9f       	mul	r22, r18
    e02a:	b0 01       	movw	r22, r0
    e02c:	11 24       	eor	r1, r1
    e02e:	6b 53       	subi	r22, 0x3B	; 59
    e030:	7f 4f       	sbci	r23, 0xFF	; 255
    e032:	87 5b       	subi	r24, 0xB7	; 183
    e034:	95 4f       	sbci	r25, 0xF5	; 245
    e036:	4d e0       	ldi	r20, 0x0D	; 13
    e038:	50 e0       	ldi	r21, 0x00	; 0
    e03a:	0e 94 07 84 	call	0x1080e	; 0x1080e <__eerd_block_m2560>
					GSMTxSz = strlen(GSM_TxStr);
    e03e:	f7 01       	movw	r30, r14
    e040:	01 90       	ld	r0, Z+
    e042:	00 20       	and	r0, r0
    e044:	e9 f7       	brne	.-6      	; 0xe040 <GSM_Cycle+0x1aa0>
    e046:	31 97       	sbiw	r30, 0x01	; 1
    e048:	e9 54       	subi	r30, 0x49	; 73
    e04a:	fa 40       	sbci	r31, 0x0A	; 10
    e04c:	e0 93 bb 07 	sts	0x07BB, r30
					sprintf(GSM_TxStr + GSMTxSz, "\"\r");
    e050:	80 91 bb 07 	lds	r24, 0x07BB
    e054:	e8 2f       	mov	r30, r24
    e056:	f0 e0       	ldi	r31, 0x00	; 0
    e058:	e7 5b       	subi	r30, 0xB7	; 183
    e05a:	f5 4f       	sbci	r31, 0xF5	; 245
    e05c:	a5 eb       	ldi	r26, 0xB5	; 181
    e05e:	b2 e0       	ldi	r27, 0x02	; 2
    e060:	83 e0       	ldi	r24, 0x03	; 3
    e062:	0d 90       	ld	r0, X+
    e064:	01 92       	st	Z+, r0
    e066:	81 50       	subi	r24, 0x01	; 1
    e068:	e1 f7       	brne	.-8      	; 0xe062 <GSM_Cycle+0x1ac2>
					GSMTxSz = strlen(GSM_TxStr);
    e06a:	f7 01       	movw	r30, r14
    e06c:	01 90       	ld	r0, Z+
    e06e:	00 20       	and	r0, r0
    e070:	e9 f7       	brne	.-6      	; 0xe06c <GSM_Cycle+0x1acc>
    e072:	31 97       	sbiw	r30, 0x01	; 1
    e074:	e9 54       	subi	r30, 0x49	; 73
    e076:	fa 40       	sbci	r31, 0x0A	; 10
    e078:	e0 93 bb 07 	sts	0x07BB, r30
					GSM_SendFirstChar();
    e07c:	0e 94 bc 3a 	call	0x7578	; 0x7578 <GSM_SendFirstChar>
					StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    e080:	80 91 e9 04 	lds	r24, 0x04E9
    e084:	64 ef       	ldi	r22, 0xF4	; 244
    e086:	71 e0       	ldi	r23, 0x01	; 1
    e088:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
					GSM_State++;
    e08c:	80 91 f6 06 	lds	r24, 0x06F6
    e090:	8f 5f       	subi	r24, 0xFF	; 255
    e092:	80 93 f6 06 	sts	0x06F6, r24
    e096:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>

				switch(CommandModeDestination){
					case 1:	GSM_State = GSM_SEND_CMGS;
						break;
					case 2:	
						GSM_State = GSM_CIPSHUT_;
    e09a:	84 e4       	ldi	r24, 0x44	; 68
    e09c:	80 93 f6 06 	sts	0x06F6, r24
						counter=0;	
    e0a0:	10 92 e0 02 	sts	0x02E0, r1
    e0a4:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
			break;
		case GSM_WAIT_D2C_SWITCH_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) {

				switch(CommandModeDestination){
					case 1:	GSM_State = GSM_SEND_CMGS;
    e0a8:	80 e4       	ldi	r24, 0x40	; 64
    e0aa:	80 93 f6 06 	sts	0x06F6, r24
    e0ae:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
				GSM_State = GSM_ProtocolMode;
				InitFIFO();
				break;
			}
*/			
			if( (strstr_P(GSM_RxStr, PSTR("OK")) != NULL) ){
    e0b2:	c8 01       	movw	r24, r16
    e0b4:	66 e5       	ldi	r22, 0x56	; 86
    e0b6:	7d e2       	ldi	r23, 0x2D	; 45
    e0b8:	0e 94 1f 81 	call	0x1023e	; 0x1023e <strstr_P>
    e0bc:	89 2b       	or	r24, r25
    e0be:	09 f4       	brne	.+2      	; 0xe0c2 <GSM_Cycle+0x1b22>
    e0c0:	88 c0       	rjmp	.+272    	; 0xe1d2 <GSM_Cycle+0x1c32>
				StartTimer16(TD_data_start_delay,100);
    e0c2:	80 91 f0 04 	lds	r24, 0x04F0
    e0c6:	64 e6       	ldi	r22, 0x64	; 100
    e0c8:	70 e0       	ldi	r23, 0x00	; 0
    e0ca:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
				GSM_State = GSM_ProtocolMode;
    e0ce:	82 e5       	ldi	r24, 0x52	; 82
    e0d0:	80 93 f6 06 	sts	0x06F6, r24
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    e0d4:	8f ef       	ldi	r24, 0xFF	; 255
    e0d6:	80 93 3e 07 	sts	0x073E, r24
	GSM_RX_FIFO_End = 255;
    e0da:	80 93 53 06 	sts	0x0653, r24
	GSM_RxCharN = 0;
    e0de:	10 92 5f 0b 	sts	0x0B5F, r1
	GSM_RX_FIFOOverFlow = 0;
    e0e2:	10 92 12 09 	sts	0x0912, r1
	GSM_RX_FIFOMax = 0;
    e0e6:	10 92 18 09 	sts	0x0918, r1
    e0ea:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
				GSM_State = GSM_WAIT_MESSAGE;
			}
			break;
		case GSM_WAIT_CCLC_3:
			if(GetStringFromFIFO()){
				if( (strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 2,0,6,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 3,0,6,")) != NULL) ){
    e0ee:	80 ee       	ldi	r24, 0xE0	; 224
    e0f0:	97 e0       	ldi	r25, 0x07	; 7
    e0f2:	6a e1       	ldi	r22, 0x1A	; 26
    e0f4:	7f e2       	ldi	r23, 0x2F	; 47
    e0f6:	0e 94 1f 81 	call	0x1023e	; 0x1023e <strstr_P>
    e0fa:	89 2b       	or	r24, r25
    e0fc:	11 f0       	breq	.+4      	; 0xe102 <GSM_Cycle+0x1b62>
    e0fe:	0c 94 5e 67 	jmp	0xcebc	; 0xcebc <GSM_Cycle+0x91c>
    e102:	80 ee       	ldi	r24, 0xE0	; 224
    e104:	97 e0       	ldi	r25, 0x07	; 7
    e106:	6c e0       	ldi	r22, 0x0C	; 12
    e108:	7f e2       	ldi	r23, 0x2F	; 47
    e10a:	0e 94 1f 81 	call	0x1023e	; 0x1023e <strstr_P>
    e10e:	89 2b       	or	r24, r25
    e110:	11 f0       	breq	.+4      	; 0xe116 <GSM_Cycle+0x1b76>
    e112:	0c 94 5e 67 	jmp	0xcebc	; 0xcebc <GSM_Cycle+0x91c>
					StartTimer16(TD_GSM, 6000);
					GSM_State = GSM_WAIT_MESSAGE;
					break;
				}
				if( (strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,3,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 2,0,3,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 3,0,3,")) != NULL) ){
    e116:	80 ee       	ldi	r24, 0xE0	; 224
    e118:	97 e0       	ldi	r25, 0x07	; 7
    e11a:	6e ef       	ldi	r22, 0xFE	; 254
    e11c:	7e e2       	ldi	r23, 0x2E	; 46
    e11e:	0e 94 1f 81 	call	0x1023e	; 0x1023e <strstr_P>
    e122:	89 2b       	or	r24, r25
    e124:	09 f4       	brne	.+2      	; 0xe128 <GSM_Cycle+0x1b88>
    e126:	27 cd       	rjmp	.-1458   	; 0xdb76 <GSM_Cycle+0x15d6>
					StartTimer16(TD_GSM, 6000);
    e128:	80 91 e9 04 	lds	r24, 0x04E9
    e12c:	60 e7       	ldi	r22, 0x70	; 112
    e12e:	77 e1       	ldi	r23, 0x17	; 23
    e130:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
					GSM_State = GSM_WAIT_CCLC_0;
    e134:	83 e1       	ldi	r24, 0x13	; 19
    e136:	80 93 f6 06 	sts	0x06F6, r24
    e13a:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
				if((strstr_P(GSM_RxStr, PSTR("OK")) != NULL) ){
					GSM_State = GSM_WAIT_MESSAGE;

					break;
				}
				if((strstr_P(GSM_RxStr, PSTR("BUSY")) != NULL) ){
    e13e:	80 ee       	ldi	r24, 0xE0	; 224
    e140:	97 e0       	ldi	r25, 0x07	; 7
    e142:	68 e7       	ldi	r22, 0x78	; 120
    e144:	7d e2       	ldi	r23, 0x2D	; 45
    e146:	0e 94 1f 81 	call	0x1023e	; 0x1023e <strstr_P>
    e14a:	89 2b       	or	r24, r25
    e14c:	09 f4       	brne	.+2      	; 0xe150 <GSM_Cycle+0x1bb0>
    e14e:	be c0       	rjmp	.+380    	; 0xe2cc <GSM_Cycle+0x1d2c>
					GSM_State = GSM_WAIT_MESSAGE;
    e150:	8e e0       	ldi	r24, 0x0E	; 14
    e152:	80 93 f6 06 	sts	0x06F6, r24
    e156:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
					if((strstr_P(GSM_RxStr, PSTR("+DTMF: 1")) != NULL) ){
						StartTimer16(TD_GSM,1000);
						GSM_State = GSM_SEND_PLAY_CONFIRM_FILE;
						
					}
					if((strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 2,0,6")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 3,0,6")) != NULL) ){
    e15a:	80 ee       	ldi	r24, 0xE0	; 224
    e15c:	97 e0       	ldi	r25, 0x07	; 7
    e15e:	65 e0       	ldi	r22, 0x05	; 5
    e160:	7e e2       	ldi	r23, 0x2E	; 46
    e162:	0e 94 1f 81 	call	0x1023e	; 0x1023e <strstr_P>
    e166:	89 2b       	or	r24, r25
    e168:	09 f0       	breq	.+2      	; 0xe16c <GSM_Cycle+0x1bcc>
    e16a:	e7 ce       	rjmp	.-562    	; 0xdf3a <GSM_Cycle+0x199a>
    e16c:	80 ee       	ldi	r24, 0xE0	; 224
    e16e:	97 e0       	ldi	r25, 0x07	; 7
    e170:	68 ef       	ldi	r22, 0xF8	; 248
    e172:	7d e2       	ldi	r23, 0x2D	; 45
    e174:	0e 94 1f 81 	call	0x1023e	; 0x1023e <strstr_P>
    e178:	89 2b       	or	r24, r25
    e17a:	09 f0       	breq	.+2      	; 0xe17e <GSM_Cycle+0x1bde>
    e17c:	de ce       	rjmp	.-580    	; 0xdf3a <GSM_Cycle+0x199a>
    e17e:	0c 94 cf 66 	jmp	0xcd9e	; 0xcd9e <GSM_Cycle+0x7fe>
				GSM_State = GSM_WAIT_MESSAGE;
			}
			break;
		case GSM_WAIT_CCLC_0:
			if(GetStringFromFIFO()){
				if((strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,0,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,0,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,0,")) != NULL) ){
    e182:	80 ee       	ldi	r24, 0xE0	; 224
    e184:	97 e0       	ldi	r25, 0x07	; 7
    e186:	66 ec       	ldi	r22, 0xC6	; 198
    e188:	7e e2       	ldi	r23, 0x2E	; 46
    e18a:	0e 94 1f 81 	call	0x1023e	; 0x1023e <strstr_P>
    e18e:	89 2b       	or	r24, r25
    e190:	11 f0       	breq	.+4      	; 0xe196 <GSM_Cycle+0x1bf6>
    e192:	0c 94 01 68 	jmp	0xd002	; 0xd002 <GSM_Cycle+0xa62>
    e196:	80 ee       	ldi	r24, 0xE0	; 224
    e198:	97 e0       	ldi	r25, 0x07	; 7
    e19a:	68 eb       	ldi	r22, 0xB8	; 184
    e19c:	7e e2       	ldi	r23, 0x2E	; 46
    e19e:	0e 94 1f 81 	call	0x1023e	; 0x1023e <strstr_P>
    e1a2:	89 2b       	or	r24, r25
    e1a4:	11 f0       	breq	.+4      	; 0xe1aa <GSM_Cycle+0x1c0a>
    e1a6:	0c 94 01 68 	jmp	0xd002	; 0xd002 <GSM_Cycle+0xa62>
					RequestRepeatCounter = 0;
					GSM_State = GSM_SEND_PLAY_ALARM_FILE;
					break;
				}
				if( (strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6,")) != NULL)){
    e1aa:	80 ee       	ldi	r24, 0xE0	; 224
    e1ac:	97 e0       	ldi	r25, 0x07	; 7
    e1ae:	6a ea       	ldi	r22, 0xAA	; 170
    e1b0:	7e e2       	ldi	r23, 0x2E	; 46
    e1b2:	0e 94 1f 81 	call	0x1023e	; 0x1023e <strstr_P>
    e1b6:	89 2b       	or	r24, r25
    e1b8:	09 f4       	brne	.+2      	; 0xe1bc <GSM_Cycle+0x1c1c>
    e1ba:	fc cc       	rjmp	.-1544   	; 0xdbb4 <GSM_Cycle+0x1614>
					StartTimer16(TD_GSM, 6000);
    e1bc:	80 91 e9 04 	lds	r24, 0x04E9
    e1c0:	60 e7       	ldi	r22, 0x70	; 112
    e1c2:	77 e1       	ldi	r23, 0x17	; 23
    e1c4:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
					GSM_State = GSM_WAIT_DISCONNECT_CAUSE;
    e1c8:	85 e2       	ldi	r24, 0x25	; 37
    e1ca:	80 93 f6 06 	sts	0x06F6, r24
    e1ce:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
				break;
			}


			//  
			if( (strstr_P(GSM_RxStr, URC_CONNECT) != NULL) ){
    e1d2:	c8 01       	movw	r24, r16
    e1d4:	60 ec       	ldi	r22, 0xC0	; 192
    e1d6:	73 e0       	ldi	r23, 0x03	; 3
    e1d8:	0e 94 1f 81 	call	0x1023e	; 0x1023e <strstr_P>
    e1dc:	89 2b       	or	r24, r25
    e1de:	b1 f0       	breq	.+44     	; 0xe20c <GSM_Cycle+0x1c6c>

				GSM_State = GSM_ProtocolMode;
    e1e0:	82 e5       	ldi	r24, 0x52	; 82
    e1e2:	80 93 f6 06 	sts	0x06F6, r24
    e1e6:	f8 01       	movw	r30, r16
				for(int i=0;i<GSM_RXSTR_SIZE;i++)
				{
					GSM_RxStr[i]=0;	
    e1e8:	11 92       	st	Z+, r1

			//  
			if( (strstr_P(GSM_RxStr, URC_CONNECT) != NULL) ){

				GSM_State = GSM_ProtocolMode;
				for(int i=0;i<GSM_RXSTR_SIZE;i++)
    e1ea:	38 e0       	ldi	r19, 0x08	; 8
    e1ec:	e4 34       	cpi	r30, 0x44	; 68
    e1ee:	f3 07       	cpc	r31, r19
    e1f0:	d9 f7       	brne	.-10     	; 0xe1e8 <GSM_Cycle+0x1c48>
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    e1f2:	8f ef       	ldi	r24, 0xFF	; 255
    e1f4:	80 93 3e 07 	sts	0x073E, r24
	GSM_RX_FIFO_End = 255;
    e1f8:	80 93 53 06 	sts	0x0653, r24
	GSM_RxCharN = 0;
    e1fc:	10 92 5f 0b 	sts	0x0B5F, r1
	GSM_RX_FIFOOverFlow = 0;
    e200:	10 92 12 09 	sts	0x0912, r1
	GSM_RX_FIFOMax = 0;
    e204:	10 92 18 09 	sts	0x0918, r1
    e208:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>

				break;
			}

			//  
			if(strstr_P(GSM_RxStr, URC_CLOSED) != NULL){
    e20c:	c8 01       	movw	r24, r16
    e20e:	62 ed       	ldi	r22, 0xD2	; 210
    e210:	73 e0       	ldi	r23, 0x03	; 3
    e212:	0e 94 1f 81 	call	0x1023e	; 0x1023e <strstr_P>
    e216:	89 2b       	or	r24, r25
    e218:	99 f1       	breq	.+102    	; 0xe280 <GSM_Cycle+0x1ce0>
				//  
				sscanf_P(GSM_RxStr,PSTR("%hhu, CLOSED"),(unsigned char*)&TempNum);
    e21a:	00 d0       	rcall	.+0      	; 0xe21c <GSM_Cycle+0x1c7c>
    e21c:	00 d0       	rcall	.+0      	; 0xe21e <GSM_Cycle+0x1c7e>
    e21e:	ed b7       	in	r30, 0x3d	; 61
    e220:	fe b7       	in	r31, 0x3e	; 62
    e222:	31 96       	adiw	r30, 0x01	; 1
    e224:	ad b7       	in	r26, 0x3d	; 61
    e226:	be b7       	in	r27, 0x3e	; 62
    e228:	12 96       	adiw	r26, 0x02	; 2
    e22a:	1c 93       	st	X, r17
    e22c:	0e 93       	st	-X, r16
    e22e:	11 97       	sbiw	r26, 0x01	; 1
    e230:	89 e4       	ldi	r24, 0x49	; 73
    e232:	9d e2       	ldi	r25, 0x2D	; 45
    e234:	93 83       	std	Z+3, r25	; 0x03
    e236:	82 83       	std	Z+2, r24	; 0x02
    e238:	8c ed       	ldi	r24, 0xDC	; 220
    e23a:	95 e0       	ldi	r25, 0x05	; 5
    e23c:	95 83       	std	Z+5, r25	; 0x05
    e23e:	84 83       	std	Z+4, r24	; 0x04
    e240:	0e 94 6e 82 	call	0x104dc	; 0x104dc <sscanf_P>
				if(GSM_ActiveConnection == TempNum){
    e244:	ed b7       	in	r30, 0x3d	; 61
    e246:	fe b7       	in	r31, 0x3e	; 62
    e248:	36 96       	adiw	r30, 0x06	; 6
    e24a:	0f b6       	in	r0, 0x3f	; 63
    e24c:	f8 94       	cli
    e24e:	fe bf       	out	0x3e, r31	; 62
    e250:	0f be       	out	0x3f, r0	; 63
    e252:	ed bf       	out	0x3d, r30	; 61
    e254:	90 91 d3 02 	lds	r25, 0x02D3
    e258:	80 91 dc 05 	lds	r24, 0x05DC
    e25c:	98 17       	cp	r25, r24
    e25e:	59 f4       	brne	.+22     	; 0xe276 <GSM_Cycle+0x1cd6>
					GSM_ActiveConnection = NO_CONNECTION;
    e260:	8f ef       	ldi	r24, 0xFF	; 255
    e262:	80 93 d3 02 	sts	0x02D3, r24
	uint8_t IP4;
} IP_Addr;

//~~~~~~~~~~~~~~
void SetIP(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	IP->IP1 = IP1;
    e266:	10 92 49 0b 	sts	0x0B49, r1
	IP->IP2 = IP2;
    e26a:	10 92 4a 0b 	sts	0x0B4A, r1
	IP->IP3 = IP3;
    e26e:	10 92 4b 0b 	sts	0x0B4B, r1
	IP->IP4 = IP4;
    e272:	10 92 4c 0b 	sts	0x0B4C, r1
					SetIP(&GSM_ClientIP,0,0,0,0);
				}

				GSM_State = GSM_ReStart1;
    e276:	8a e4       	ldi	r24, 0x4A	; 74
    e278:	80 93 f6 06 	sts	0x06F6, r24
    e27c:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
				break;
			}

			// +PDP DEACT
			if( (strstr_P(GSM_RxStr, URC_PDPDEACT) != NULL) ){
    e280:	c8 01       	movw	r24, r16
    e282:	6b ed       	ldi	r22, 0xDB	; 219
    e284:	73 e0       	ldi	r23, 0x03	; 3
    e286:	0e 94 1f 81 	call	0x1023e	; 0x1023e <strstr_P>
    e28a:	89 2b       	or	r24, r25
    e28c:	29 f0       	breq	.+10     	; 0xe298 <GSM_Cycle+0x1cf8>
				GSM_State = GSM_SEND_E0;
    e28e:	88 e0       	ldi	r24, 0x08	; 8
    e290:	80 93 f6 06 	sts	0x06F6, r24
    e294:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
			}



			//      
			if(strstr_P(GSM_RxStr, RESP_CSQ) != NULL ){
    e298:	c8 01       	movw	r24, r16
    e29a:	63 e4       	ldi	r22, 0x43	; 67
    e29c:	74 e0       	ldi	r23, 0x04	; 4
    e29e:	0e 94 1f 81 	call	0x1023e	; 0x1023e <strstr_P>
    e2a2:	89 2b       	or	r24, r25
    e2a4:	01 f1       	breq	.+64     	; 0xe2e6 <GSM_Cycle+0x1d46>
				GSM_State = GSM_WAIT_CSQ;
    e2a6:	80 e5       	ldi	r24, 0x50	; 80
    e2a8:	80 93 f6 06 	sts	0x06F6, r24
    e2ac:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
						AppProtocol = 0;
						if(!strncmp_P(GSM_RxStr, PSTR("GET "), 4)) {AppProtocol = _HTTP;GSM_State = GSM_DataMode;break;}//GET
						if(!strncmp_P(GSM_RxStr, PSTR("POST"), 4)) {AppProtocol = _HTTP;GSM_State = GSM_DataMode;break;}//POST
						if(!strncmp_P(GSM_RxStr, PSTR("CLOS"), 4)) {AppProtocol = _HTTP;GSM_State = GSM_ReStart1;break;}// 
						if(!strncmp_P(GSM_RxStr, PSTR("+PDP"), 4)) {AppProtocol = _HTTP;GSM_State = GSM_ReStart1;break;}//GPRS 
						if( (GSM_RxStr[0]==0) && (GSM_RxStr[1]==0)){AppProtocol = _HTTP;GSM_State = GSM_ReStart1;break;}//  
    e2b0:	81 e0       	ldi	r24, 0x01	; 1
    e2b2:	80 93 e6 08 	sts	0x08E6, r24
    e2b6:	8a e4       	ldi	r24, 0x4A	; 74
    e2b8:	80 93 f6 06 	sts	0x06F6, r24
    e2bc:	fa cc       	rjmp	.-1548   	; 0xdcb2 <GSM_Cycle+0x1712>
							if(!strncmp_P(GSM_RxStr, PSTR("\r\n"), 2)) {GSM_RxCharN=0;}
						}
					if(GSM_RxCharN >= 4){
						AppProtocol = 0;
						if(!strncmp_P(GSM_RxStr, PSTR("GET "), 4)) {AppProtocol = _HTTP;GSM_State = GSM_DataMode;break;}//GET
						if(!strncmp_P(GSM_RxStr, PSTR("POST"), 4)) {AppProtocol = _HTTP;GSM_State = GSM_DataMode;break;}//POST
    e2be:	81 e0       	ldi	r24, 0x01	; 1
    e2c0:	80 93 e6 08 	sts	0x08E6, r24
    e2c4:	83 e5       	ldi	r24, 0x53	; 83
    e2c6:	80 93 f6 06 	sts	0x06F6, r24
    e2ca:	f3 cc       	rjmp	.-1562   	; 0xdcb2 <GSM_Cycle+0x1712>
				if((strstr_P(GSM_RxStr, PSTR("BUSY")) != NULL) ){
					GSM_State = GSM_WAIT_MESSAGE;

					break;
				}
				if((strstr_P(GSM_RxStr, PSTR("NO CARRIER")) != NULL) ){
    e2cc:	80 ee       	ldi	r24, 0xE0	; 224
    e2ce:	97 e0       	ldi	r25, 0x07	; 7
    e2d0:	6d e6       	ldi	r22, 0x6D	; 109
    e2d2:	7d e2       	ldi	r23, 0x2D	; 45
    e2d4:	0e 94 1f 81 	call	0x1023e	; 0x1023e <strstr_P>
    e2d8:	89 2b       	or	r24, r25
    e2da:	51 f0       	breq	.+20     	; 0xe2f0 <GSM_Cycle+0x1d50>
					GSM_State = GSM_WAIT_MESSAGE;
    e2dc:	8e e0       	ldi	r24, 0x0E	; 14
    e2de:	80 93 f6 06 	sts	0x06F6, r24
    e2e2:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
				GSM_State = GSM_WAIT_CSQ;
				break;
			}

			// 
			GSM_State = GSM_WAIT_IDENTIFICATION;
    e2e6:	8e e3       	ldi	r24, 0x3E	; 62
    e2e8:	80 93 f6 06 	sts	0x06F6, r24
    e2ec:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>
				if((strstr_P(GSM_RxStr, PSTR("NO CARRIER")) != NULL) ){
					GSM_State = GSM_WAIT_MESSAGE;

					break;
				}
				GSM_State = GSM_WAIT_MESSAGE;
    e2f0:	8e e0       	ldi	r24, 0x0E	; 14
    e2f2:	80 93 f6 06 	sts	0x06F6, r24
    e2f6:	0c 94 f0 62 	jmp	0xc5e0	; 0xc5e0 <GSM_Cycle+0x40>

0000e2fa <USART_Cycle>:

// ~~~~~~~~~~~~~~
void
USART_Cycle(void)
{
	MB_Cycle();
    e2fa:	0e 94 cd 38 	call	0x719a	; 0x719a <MB_Cycle>
	#ifdef GSM
		GSM_Cycle();
    e2fe:	0e 94 d0 62 	call	0xc5a0	; 0xc5a0 <GSM_Cycle>
	#endif
	#ifdef UDP_EASY
		UDP_RxProcess();
	#endif
}
    e302:	08 95       	ret

0000e304 <IP_E_compare_Const>:
}
uint8_t IP_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	if((IP->IP1 == IP1) && (IP->IP2 == IP2) && (IP->IP3 == IP3) && (IP->IP4 == IP4)) return 1;
	else return 0;
}
uint8_t IP_E_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
    e304:	ef 92       	push	r14
    e306:	ff 92       	push	r15
    e308:	0f 93       	push	r16
    e30a:	1f 93       	push	r17
    e30c:	cf 93       	push	r28
    e30e:	df 93       	push	r29
    e310:	ec 01       	movw	r28, r24
    e312:	16 2f       	mov	r17, r22
    e314:	f4 2e       	mov	r15, r20
    e316:	e2 2e       	mov	r14, r18
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    e318:	0e 94 17 84 	call	0x1082e	; 0x1082e <__eerd_byte_m2560>
	if((erb(&IP->IP1) == IP1) && (erb(&IP->IP2) == IP2) && (erb(&IP->IP3) == IP3) && (erb(&IP->IP4) == IP4)) return 1;
    e31c:	18 17       	cp	r17, r24
    e31e:	49 f0       	breq	.+18     	; 0xe332 <IP_E_compare_Const+0x2e>
	else return 0;
}
    e320:	90 e0       	ldi	r25, 0x00	; 0
    e322:	89 2f       	mov	r24, r25
    e324:	df 91       	pop	r29
    e326:	cf 91       	pop	r28
    e328:	1f 91       	pop	r17
    e32a:	0f 91       	pop	r16
    e32c:	ff 90       	pop	r15
    e32e:	ef 90       	pop	r14
    e330:	08 95       	ret
    e332:	ce 01       	movw	r24, r28
    e334:	01 96       	adiw	r24, 0x01	; 1
    e336:	0e 94 17 84 	call	0x1082e	; 0x1082e <__eerd_byte_m2560>
uint8_t IP_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	if((IP->IP1 == IP1) && (IP->IP2 == IP2) && (IP->IP3 == IP3) && (IP->IP4 == IP4)) return 1;
	else return 0;
}
uint8_t IP_E_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	if((erb(&IP->IP1) == IP1) && (erb(&IP->IP2) == IP2) && (erb(&IP->IP3) == IP3) && (erb(&IP->IP4) == IP4)) return 1;
    e33a:	f8 16       	cp	r15, r24
    e33c:	89 f7       	brne	.-30     	; 0xe320 <IP_E_compare_Const+0x1c>
    e33e:	ce 01       	movw	r24, r28
    e340:	02 96       	adiw	r24, 0x02	; 2
    e342:	0e 94 17 84 	call	0x1082e	; 0x1082e <__eerd_byte_m2560>
    e346:	e8 16       	cp	r14, r24
    e348:	59 f7       	brne	.-42     	; 0xe320 <IP_E_compare_Const+0x1c>
    e34a:	ce 01       	movw	r24, r28
    e34c:	03 96       	adiw	r24, 0x03	; 3
    e34e:	0e 94 17 84 	call	0x1082e	; 0x1082e <__eerd_byte_m2560>
    e352:	90 e0       	ldi	r25, 0x00	; 0
    e354:	08 13       	cpse	r16, r24
    e356:	91 e0       	ldi	r25, 0x01	; 1
    e358:	81 e0       	ldi	r24, 0x01	; 1
    e35a:	98 27       	eor	r25, r24
    e35c:	e2 cf       	rjmp	.-60     	; 0xe322 <IP_E_compare_Const+0x1e>

0000e35e <MB_M_Init>:
}

// ~~~~~~~~~~~~~~~~~~~~
void
MB_M_Init(uint8_t MB_N)
{
    e35e:	cf 92       	push	r12
    e360:	df 92       	push	r13
    e362:	ef 92       	push	r14
    e364:	ff 92       	push	r15
    e366:	0f 93       	push	r16
    e368:	1f 93       	push	r17
	MB_M_Period[MB_N]		= erw(&MB_M_Param_EE[MB_N].Period);
    e36a:	e8 2e       	mov	r14, r24
    e36c:	ff 24       	eor	r15, r15
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    e36e:	87 01       	movw	r16, r14
    e370:	00 0f       	add	r16, r16
    e372:	11 1f       	adc	r17, r17
    e374:	00 0f       	add	r16, r16
    e376:	11 1f       	adc	r17, r17
    e378:	0e 0d       	add	r16, r14
    e37a:	1f 1d       	adc	r17, r15
    e37c:	32 e9       	ldi	r19, 0x92	; 146
    e37e:	c3 2e       	mov	r12, r19
    e380:	31 e0       	ldi	r19, 0x01	; 1
    e382:	d3 2e       	mov	r13, r19
    e384:	c6 01       	movw	r24, r12
    e386:	80 0f       	add	r24, r16
    e388:	91 1f       	adc	r25, r17
    e38a:	0e 94 25 84 	call	0x1084a	; 0x1084a <__eerd_word_m2560>
    e38e:	f7 01       	movw	r30, r14
    e390:	ee 0f       	add	r30, r30
    e392:	ff 1f       	adc	r31, r31
    e394:	e3 55       	subi	r30, 0x53	; 83
    e396:	f9 4f       	sbci	r31, 0xF9	; 249
    e398:	91 83       	std	Z+1, r25	; 0x01
    e39a:	80 83       	st	Z, r24
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    e39c:	0e 5f       	subi	r16, 0xFE	; 254
    e39e:	1f 4f       	sbci	r17, 0xFF	; 255
    e3a0:	c6 01       	movw	r24, r12
    e3a2:	80 0f       	add	r24, r16
    e3a4:	91 1f       	adc	r25, r17
    e3a6:	0e 94 17 84 	call	0x1082e	; 0x1082e <__eerd_byte_m2560>
	MB_M_Timeout[MB_N]	= erb(&MB_M_Param_EE[MB_N].Timeout);
    e3aa:	f7 01       	movw	r30, r14
    e3ac:	e8 5d       	subi	r30, 0xD8	; 216
    e3ae:	f6 4f       	sbci	r31, 0xF6	; 246
    e3b0:	80 83       	st	Z, r24
    e3b2:	0f 5f       	subi	r16, 0xFF	; 255
    e3b4:	1f 4f       	sbci	r17, 0xFF	; 255
    e3b6:	c6 01       	movw	r24, r12
    e3b8:	80 0f       	add	r24, r16
    e3ba:	91 1f       	adc	r25, r17
    e3bc:	0e 94 17 84 	call	0x1082e	; 0x1082e <__eerd_byte_m2560>
	MB_M_Try[MB_N]			= erb(&MB_M_Param_EE[MB_N].Try);
    e3c0:	f7 01       	movw	r30, r14
    e3c2:	e1 5c       	subi	r30, 0xC1	; 193
    e3c4:	f8 4f       	sbci	r31, 0xF8	; 248
    e3c6:	80 83       	st	Z, r24
    e3c8:	0f 5f       	subi	r16, 0xFF	; 255
    e3ca:	1f 4f       	sbci	r17, 0xFF	; 255
    e3cc:	c6 01       	movw	r24, r12
    e3ce:	80 0f       	add	r24, r16
    e3d0:	91 1f       	adc	r25, r17
    e3d2:	0e 94 17 84 	call	0x1082e	; 0x1082e <__eerd_byte_m2560>
	MB_M_TimeOff[MB_N]	= erb(&MB_M_Param_EE[MB_N].TimeOff);
    e3d6:	2f ed       	ldi	r18, 0xDF	; 223
    e3d8:	35 e0       	ldi	r19, 0x05	; 5
    e3da:	e2 0e       	add	r14, r18
    e3dc:	f3 1e       	adc	r15, r19
    e3de:	f7 01       	movw	r30, r14
    e3e0:	80 83       	st	Z, r24

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    e3e2:	80 91 d0 02 	lds	r24, 0x02D0
	VacantTimer16Sys += n;
    e3e6:	8d 5f       	subi	r24, 0xFD	; 253
    e3e8:	80 93 d0 02 	sts	0x02D0, r24
    e3ec:	83 50       	subi	r24, 0x03	; 3

	TD_MB = Timer16SysAlloc(Modbus_Qt*3);
    e3ee:	80 93 e8 04 	sts	0x04E8, r24
}
    e3f2:	1f 91       	pop	r17
    e3f4:	0f 91       	pop	r16
    e3f6:	ff 90       	pop	r15
    e3f8:	ef 90       	pop	r14
    e3fa:	df 90       	pop	r13
    e3fc:	cf 90       	pop	r12
    e3fe:	08 95       	ret

0000e400 <MB_S_Init>:
}

// ~~~~~~~~~~~~~~~~~~~~
void
MB_S_Init(uint8_t MB_N)
{
    e400:	0f 93       	push	r16
    e402:	1f 93       	push	r17
    e404:	08 2f       	mov	r16, r24
    e406:	10 e0       	ldi	r17, 0x00	; 0
    e408:	c8 01       	movw	r24, r16
    e40a:	89 56       	subi	r24, 0x69	; 105
    e40c:	9e 4f       	sbci	r25, 0xFE	; 254
    e40e:	0e 94 17 84 	call	0x1082e	; 0x1082e <__eerd_byte_m2560>
	#ifndef MB_ADDR_DIP_SW
		MB_NativeAddr[MB_N] = erb(MB_NativeAddr_EE+MB_N);
    e412:	00 52       	subi	r16, 0x20	; 32
    e414:	1a 4f       	sbci	r17, 0xFA	; 250
    e416:	f8 01       	movw	r30, r16
    e418:	80 83       	st	Z, r24
	#endif
}
    e41a:	1f 91       	pop	r17
    e41c:	0f 91       	pop	r16
    e41e:	08 95       	ret

0000e420 <SetBAUD>:
}

// ~~~~~~~~~~~~~~~~~~
void
SetBAUD(uint8_t MB_N)
{
    e420:	ef 92       	push	r14
    e422:	ff 92       	push	r15
    e424:	0f 93       	push	r16
    e426:	1f 93       	push	r17
	BR_Val *ptrBR_Val = BR_Tbl + (MB_BitRate_RAM[MB_N] = erb(&MB_Param[MB_N].BitRate));
    e428:	08 2f       	mov	r16, r24
    e42a:	10 e0       	ldi	r17, 0x00	; 0
    e42c:	78 01       	movw	r14, r16
    e42e:	ee 0c       	add	r14, r14
    e430:	ff 1c       	adc	r15, r15
    e432:	e0 0e       	add	r14, r16
    e434:	f1 1e       	adc	r15, r17
    e436:	c7 01       	movw	r24, r14
    e438:	8a 5f       	subi	r24, 0xFA	; 250
    e43a:	9f 4f       	sbci	r25, 0xFF	; 255
    e43c:	0e 94 17 84 	call	0x1082e	; 0x1082e <__eerd_byte_m2560>
    e440:	98 2f       	mov	r25, r24
    e442:	f8 01       	movw	r30, r16
    e444:	e4 53       	subi	r30, 0x34	; 52
    e446:	f8 4f       	sbci	r31, 0xF8	; 248
    e448:	80 83       	st	Z, r24
    e44a:	83 e0       	ldi	r24, 0x03	; 3
    e44c:	98 9f       	mul	r25, r24
    e44e:	b0 01       	movw	r22, r0
    e450:	11 24       	eor	r1, r1
    e452:	60 5c       	subi	r22, 0xC0	; 192
    e454:	7c 4f       	sbci	r23, 0xFC	; 252

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    e456:	00 0f       	add	r16, r16
    e458:	11 1f       	adc	r17, r17
    e45a:	00 0f       	add	r16, r16
    e45c:	11 1f       	adc	r17, r17
    e45e:	c8 01       	movw	r24, r16
    e460:	88 0f       	add	r24, r24
    e462:	99 1f       	adc	r25, r25
    e464:	88 0f       	add	r24, r24
    e466:	99 1f       	adc	r25, r25
    e468:	80 0f       	add	r24, r16
    e46a:	91 1f       	adc	r25, r17
    e46c:	0a 96       	adiw	r24, 0x0a	; 10
    e46e:	40 e9       	ldi	r20, 0x90	; 144
    e470:	5f e2       	ldi	r21, 0x2F	; 47
    e472:	9a 01       	movw	r18, r20
    e474:	28 0f       	add	r18, r24
    e476:	39 1f       	adc	r19, r25
    e478:	f9 01       	movw	r30, r18
    e47a:	a5 91       	lpm	r26, Z+
    e47c:	b4 91       	lpm	r27, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    e47e:	fb 01       	movw	r30, r22
    e480:	24 91       	lpm	r18, Z+
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		USART_Reg(MB_N, ubrrl) = prb((uint8_t*)&ptrBR_Val->UBRR);
    e482:	2c 93       	st	X, r18

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    e484:	02 97       	sbiw	r24, 0x02	; 2
    e486:	84 0f       	add	r24, r20
    e488:	95 1f       	adc	r25, r21
    e48a:	fc 01       	movw	r30, r24
    e48c:	a5 91       	lpm	r26, Z+
    e48e:	b4 91       	lpm	r27, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    e490:	6f 5f       	subi	r22, 0xFF	; 255
    e492:	7f 4f       	sbci	r23, 0xFF	; 255
    e494:	fb 01       	movw	r30, r22
    e496:	84 91       	lpm	r24, Z+
		USART_Reg(MB_N, ubrrh) = prb((uint8_t*)&ptrBR_Val->UBRR+1);
    e498:	8c 93       	st	X, r24

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    e49a:	c7 01       	movw	r24, r14
    e49c:	88 0f       	add	r24, r24
    e49e:	99 1f       	adc	r25, r25
    e4a0:	89 55       	subi	r24, 0x59	; 89
    e4a2:	90 4d       	sbci	r25, 0xD0	; 208
    e4a4:	fc 01       	movw	r30, r24
    e4a6:	a5 91       	lpm	r26, Z+
    e4a8:	b4 91       	lpm	r27, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    e4aa:	6f 5f       	subi	r22, 0xFF	; 255
    e4ac:	7f 4f       	sbci	r23, 0xFF	; 255
    e4ae:	fb 01       	movw	r30, r22
    e4b0:	84 91       	lpm	r24, Z+

		*(uint8_t*)prp(&MB_Timer[MB_N].OCR) = prb(&ptrBR_Val->Time35);
    e4b2:	8c 93       	st	X, r24
		usart->BAUDCTRLA = prb((uint8_t*)&ptrBR_Val->UBRR);
		usart->BAUDCTRLB = prb((uint8_t*)&ptrBR_Val->UBRR+1) + USART_BSCALE0_bm;

		((TC1_t*)prp(MB_Timer+MB_N))->PER = prw(&ptrBR_Val->Time35);
	#endif
}
    e4b4:	1f 91       	pop	r17
    e4b6:	0f 91       	pop	r16
    e4b8:	ff 90       	pop	r15
    e4ba:	ef 90       	pop	r14
    e4bc:	08 95       	ret

0000e4be <Key_MB0_BitRate>:
	{" BAUD: }}}}}bps     ", NULL, F_MB##N##_Baud}																														\
};																																																					\
MenuPage MenuModbus##N = {SetMenu(L_MB##N), 1};

#if Modbus_Qt == 1
	M_Modbus(0)
    e4be:	80 e0       	ldi	r24, 0x00	; 0
    e4c0:	0e 94 10 72 	call	0xe420	; 0xe420 <SetBAUD>
    e4c4:	08 95       	ret

0000e4c6 <SetParity>:
// ~~~

// ~~~~~~~~~~~~~~~~~~~~
void
SetParity(uint8_t MB_N)
{
    e4c6:	ff 92       	push	r15
    e4c8:	0f 93       	push	r16
    e4ca:	1f 93       	push	r17
    e4cc:	cf 93       	push	r28
    e4ce:	df 93       	push	r29
	uint8_t Parity = erb(&MB_Param[MB_N].Parity), S_B = erb(&MB_Param[MB_N].StopBits);
    e4d0:	c8 2f       	mov	r28, r24
    e4d2:	d0 e0       	ldi	r29, 0x00	; 0
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    e4d4:	8e 01       	movw	r16, r28
    e4d6:	00 0f       	add	r16, r16
    e4d8:	11 1f       	adc	r17, r17
    e4da:	0c 0f       	add	r16, r28
    e4dc:	1d 1f       	adc	r17, r29
    e4de:	c8 01       	movw	r24, r16
    e4e0:	8c 5f       	subi	r24, 0xFC	; 252
    e4e2:	9f 4f       	sbci	r25, 0xFF	; 255
    e4e4:	0e 94 17 84 	call	0x1082e	; 0x1082e <__eerd_byte_m2560>
    e4e8:	f8 2e       	mov	r15, r24
    e4ea:	0b 5f       	subi	r16, 0xFB	; 251
    e4ec:	1f 4f       	sbci	r17, 0xFF	; 255
    e4ee:	c8 01       	movw	r24, r16
    e4f0:	0e 94 17 84 	call	0x1082e	; 0x1082e <__eerd_byte_m2560>
    e4f4:	48 2f       	mov	r20, r24
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		uint8_t ucsrc = (~(1<<6) |(1<<2) |(1<<1)) &~(1<<0);
		if (Parity==NoParity) {
    e4f6:	ff 20       	and	r15, r15
    e4f8:	e1 f4       	brne	.+56     	; 0xe532 <SetParity+0x6c>
			ucsrc &=~(1<<5) &~(1<<4);
			switch (S_B) {
    e4fa:	81 30       	cpi	r24, 0x01	; 1
    e4fc:	09 f4       	brne	.+2      	; 0xe500 <SetParity+0x3a>
    e4fe:	3d c0       	rjmp	.+122    	; 0xe57a <SetParity+0xb4>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    e500:	ce 01       	movw	r24, r28
    e502:	88 0f       	add	r24, r24
    e504:	99 1f       	adc	r25, r25
    e506:	88 0f       	add	r24, r24
    e508:	99 1f       	adc	r25, r25
    e50a:	9c 01       	movw	r18, r24
    e50c:	22 0f       	add	r18, r18
    e50e:	33 1f       	adc	r19, r19
    e510:	22 0f       	add	r18, r18
    e512:	33 1f       	adc	r19, r19
    e514:	28 0f       	add	r18, r24
    e516:	39 1f       	adc	r19, r25
    e518:	2a 56       	subi	r18, 0x6A	; 106
    e51a:	30 4d       	sbci	r19, 0xD0	; 208
    e51c:	f9 01       	movw	r30, r18
    e51e:	a5 91       	lpm	r26, Z+
    e520:	b4 91       	lpm	r27, Z+
		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
			ucsrc  |=(1<<7);
		#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
			ucsrc &=~(1<<7);
		#endif
		USART_Reg(MB_N, ucsrc) = ucsrc;
    e522:	8e e0       	ldi	r24, 0x0E	; 14
    e524:	8c 93       	st	X, r24
			}
		}
	#endif
	if (Parity!=NoParity && S_B!=1)
		ewb(&MB_Param[MB_N].StopBits, 1);
}
    e526:	df 91       	pop	r29
    e528:	cf 91       	pop	r28
    e52a:	1f 91       	pop	r17
    e52c:	0f 91       	pop	r16
    e52e:	ff 90       	pop	r15
    e530:	08 95       	ret
				break;
			}
		}
		else {
			ucsrc &=~(1<<3);
			switch (Parity) {
    e532:	81 e0       	ldi	r24, 0x01	; 1
    e534:	f8 16       	cp	r15, r24
    e536:	f9 f0       	breq	.+62     	; 0xe576 <SetParity+0xb0>
			}
		}
	#endif
	if (Parity!=NoParity && S_B!=1)
		ewb(&MB_Param[MB_N].StopBits, 1);
}
    e538:	56 e3       	ldi	r21, 0x36	; 54
    e53a:	ce 01       	movw	r24, r28
    e53c:	88 0f       	add	r24, r24
    e53e:	99 1f       	adc	r25, r25
    e540:	88 0f       	add	r24, r24
    e542:	99 1f       	adc	r25, r25
    e544:	9c 01       	movw	r18, r24
    e546:	22 0f       	add	r18, r18
    e548:	33 1f       	adc	r19, r19
    e54a:	22 0f       	add	r18, r18
    e54c:	33 1f       	adc	r19, r19
    e54e:	28 0f       	add	r18, r24
    e550:	39 1f       	adc	r19, r25
    e552:	2a 56       	subi	r18, 0x6A	; 106
    e554:	30 4d       	sbci	r19, 0xD0	; 208
    e556:	f9 01       	movw	r30, r18
    e558:	a5 91       	lpm	r26, Z+
    e55a:	b4 91       	lpm	r27, Z+
		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
			ucsrc  |=(1<<7);
		#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
			ucsrc &=~(1<<7);
		#endif
		USART_Reg(MB_N, ucsrc) = ucsrc;
    e55c:	5c 93       	st	X, r21
				usart->CTRLC |=USART_PMODE_ODD_gc;
				break;
			}
		}
	#endif
	if (Parity!=NoParity && S_B!=1)
    e55e:	41 30       	cpi	r20, 0x01	; 1
    e560:	21 f0       	breq	.+8      	; 0xe56a <SetParity+0xa4>
		ewb(&MB_Param[MB_N].StopBits, 1);
    e562:	c8 01       	movw	r24, r16
    e564:	61 e0       	ldi	r22, 0x01	; 1
    e566:	0e 94 69 4d 	call	0x9ad2	; 0x9ad2 <ewb>
}
    e56a:	df 91       	pop	r29
    e56c:	cf 91       	pop	r28
    e56e:	1f 91       	pop	r17
    e570:	0f 91       	pop	r16
    e572:	ff 90       	pop	r15
    e574:	08 95       	ret
				break;
			}
		}
		else {
			ucsrc &=~(1<<3);
			switch (Parity) {
    e576:	56 e2       	ldi	r21, 0x26	; 38
    e578:	e0 cf       	rjmp	.-64     	; 0xe53a <SetParity+0x74>
    e57a:	ce 01       	movw	r24, r28
    e57c:	88 0f       	add	r24, r24
    e57e:	99 1f       	adc	r25, r25
    e580:	88 0f       	add	r24, r24
    e582:	99 1f       	adc	r25, r25
    e584:	9c 01       	movw	r18, r24
    e586:	22 0f       	add	r18, r18
    e588:	33 1f       	adc	r19, r19
    e58a:	22 0f       	add	r18, r18
    e58c:	33 1f       	adc	r19, r19
    e58e:	28 0f       	add	r18, r24
    e590:	39 1f       	adc	r19, r25
    e592:	2a 56       	subi	r18, 0x6A	; 106
    e594:	30 4d       	sbci	r19, 0xD0	; 208
    e596:	f9 01       	movw	r30, r18
    e598:	a5 91       	lpm	r26, Z+
    e59a:	b4 91       	lpm	r27, Z+
		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
			ucsrc  |=(1<<7);
		#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
			ucsrc &=~(1<<7);
		#endif
		USART_Reg(MB_N, ucsrc) = ucsrc;
    e59c:	86 e0       	ldi	r24, 0x06	; 6
    e59e:	8c 93       	st	X, r24
			}
		}
	#endif
	if (Parity!=NoParity && S_B!=1)
		ewb(&MB_Param[MB_N].StopBits, 1);
}
    e5a0:	df 91       	pop	r29
    e5a2:	cf 91       	pop	r28
    e5a4:	1f 91       	pop	r17
    e5a6:	0f 91       	pop	r16
    e5a8:	ff 90       	pop	r15
    e5aa:	08 95       	ret

0000e5ac <Key_MB0_Parity>:
    e5ac:	80 e0       	ldi	r24, 0x00	; 0
    e5ae:	0e 94 63 72 	call	0xe4c6	; 0xe4c6 <SetParity>
    e5b2:	08 95       	ret

0000e5b4 <MB_Init>:

// ~~~~~~~~~~
void
MB_Init(void)
{
	MB_PLC_Init();
    e5b4:	0e 94 06 1f 	call	0x3e0c	; 0x3e0c <MB_PLC_Init>
		PORTE.DIR |=(1<<3);
	#endif
	for (uint8_t MB_N=0; MB_N<Modbus_Qt; MB_N++) {
		void MB_S_Init(uint8_t);
		void MB_M_Init(uint8_t);
		MB_State[MB_N] = MB_Initi;
    e5b8:	10 92 c2 05 	sts	0x05C2, r1
    e5bc:	82 e9       	ldi	r24, 0x92	; 146
    e5be:	9f e2       	ldi	r25, 0x2F	; 47
    e5c0:	fc 01       	movw	r30, r24
    e5c2:	a5 91       	lpm	r26, Z+
    e5c4:	b4 91       	lpm	r27, Z+
		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
			USART_Reg(MB_N, ucsra) = ~(1<<1) &~(1<<0);
    e5c6:	8c ef       	ldi	r24, 0xFC	; 252
    e5c8:	8c 93       	st	X, r24
    e5ca:	84 e9       	ldi	r24, 0x94	; 148
    e5cc:	9f e2       	ldi	r25, 0x2F	; 47
    e5ce:	fc 01       	movw	r30, r24
    e5d0:	a5 91       	lpm	r26, Z+
    e5d2:	b4 91       	lpm	r27, Z+
			USART_Reg(MB_N, ucsrb) = (((1<<7) &~(1<<6) &~(1<<5)) |(1<<4) |(1<<3)) &~(1<<2);
    e5d4:	88 e9       	ldi	r24, 0x98	; 152
    e5d6:	8c 93       	st	X, r24
			tc->CTRLD = TC_EVACT_OFF_gc;
			//tc->CTRLE = TC1_BYTEM_bm;
			tc->INTCTRLA |=TC_ERRINTLVL_OFF_gc;
			tc->INTCTRLB = 0;
		#endif
		SetParity(MB_N);
    e5d8:	80 e0       	ldi	r24, 0x00	; 0
    e5da:	0e 94 63 72 	call	0xe4c6	; 0xe4c6 <SetParity>
		SetBAUD(MB_N);
    e5de:	80 e0       	ldi	r24, 0x00	; 0
    e5e0:	0e 94 10 72 	call	0xe420	; 0xe420 <SetBAUD>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    e5e4:	e4 ea       	ldi	r30, 0xA4	; 164
    e5e6:	ff e2       	ldi	r31, 0x2F	; 47
    e5e8:	84 91       	lpm	r24, Z+
		switch (prb(MB_Role+MB_N)) {
    e5ea:	88 23       	and	r24, r24
    e5ec:	59 f4       	brne	.+22     	; 0xe604 <MB_Init+0x50>
		case Role_Slave:
			MB_S_Init(MB_N);
    e5ee:	80 e0       	ldi	r24, 0x00	; 0
    e5f0:	0e 94 00 72 	call	0xe400	; 0xe400 <MB_S_Init>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    e5f4:	89 ea       	ldi	r24, 0xA9	; 169
    e5f6:	9f e2       	ldi	r25, 0x2F	; 47
    e5f8:	fc 01       	movw	r30, r24
    e5fa:	25 91       	lpm	r18, Z+
    e5fc:	34 91       	lpm	r19, Z+
			break;
		case Role_Master:
			MB_M_Init(MB_N);
			break;
		}
		MB_StartTimer(MB_N);
    e5fe:	f9 01       	movw	r30, r18
    e600:	19 95       	eicall
	}
}
    e602:	08 95       	ret
			tc->INTCTRLA |=TC_ERRINTLVL_OFF_gc;
			tc->INTCTRLB = 0;
		#endif
		SetParity(MB_N);
		SetBAUD(MB_N);
		switch (prb(MB_Role+MB_N)) {
    e604:	81 30       	cpi	r24, 0x01	; 1
    e606:	b1 f7       	brne	.-20     	; 0xe5f4 <MB_Init+0x40>
		case Role_Slave:
			MB_S_Init(MB_N);
			break;
		case Role_Master:
			MB_M_Init(MB_N);
    e608:	80 e0       	ldi	r24, 0x00	; 0
    e60a:	0e 94 af 71 	call	0xe35e	; 0xe35e <MB_M_Init>
    e60e:	f2 cf       	rjmp	.-28     	; 0xe5f4 <MB_Init+0x40>

0000e610 <USART_Init>:

// ~~~~~~~~~~~~~
void
USART_Init(void)
{
	MB_Init();
    e610:	0e 94 da 72 	call	0xe5b4	; 0xe5b4 <MB_Init>
	#ifdef GSM
		GSM_Init();
    e614:	0e 94 24 3a 	call	0x7448	; 0x7448 <GSM_Init>
	#endif
	#ifdef UDP_EASY
		UDP_Init();
	#endif
}
    e618:	08 95       	ret

0000e61a <LCDBackLightStartTimer>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    e61a:	81 e9       	ldi	r24, 0x91	; 145
    e61c:	91 e0       	ldi	r25, 0x01	; 1
    e61e:	0e 94 17 84 	call	0x1082e	; 0x1082e <__eerd_byte_m2560>
			PORT_BACKLIGHT &= ~BACKLIGHT;
		#endif
		IntOn();
	}
	void LCDBackLightStartTimer(void){
		switch(erb(&BackLightTimeEE)){
    e622:	82 30       	cpi	r24, 0x02	; 2
    e624:	e9 f0       	breq	.+58     	; 0xe660 <LCDBackLightStartTimer+0x46>
    e626:	83 30       	cpi	r24, 0x03	; 3
    e628:	58 f0       	brcs	.+22     	; 0xe640 <LCDBackLightStartTimer+0x26>
    e62a:	83 30       	cpi	r24, 0x03	; 3
    e62c:	01 f1       	breq	.+64     	; 0xe66e <LCDBackLightStartTimer+0x54>
    e62e:	84 30       	cpi	r24, 0x04	; 4
    e630:	81 f0       	breq	.+32     	; 0xe652 <LCDBackLightStartTimer+0x38>
				break;	
			case BCKLT_10min:
				StartTimer16(TD_BackLight, 60000);
				break;
			default:
				StartTimer16(TD_BackLight, 3000);
    e632:	80 91 d8 04 	lds	r24, 0x04D8
    e636:	68 eb       	ldi	r22, 0xB8	; 184
    e638:	7b e0       	ldi	r23, 0x0B	; 11
    e63a:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
    e63e:	08 95       	ret
			PORT_BACKLIGHT &= ~BACKLIGHT;
		#endif
		IntOn();
	}
	void LCDBackLightStartTimer(void){
		switch(erb(&BackLightTimeEE)){
    e640:	88 23       	and	r24, r24
    e642:	b9 f7       	brne	.-18     	; 0xe632 <LCDBackLightStartTimer+0x18>
			case BCKLT_10sec:
				StartTimer16(TD_BackLight, 1000);
    e644:	80 91 d8 04 	lds	r24, 0x04D8
    e648:	68 ee       	ldi	r22, 0xE8	; 232
    e64a:	73 e0       	ldi	r23, 0x03	; 3
    e64c:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
    e650:	08 95       	ret
				break;
			case BCKLT_3min:
				StartTimer16(TD_BackLight, 18000);
				break;	
			case BCKLT_10min:
				StartTimer16(TD_BackLight, 60000);
    e652:	80 91 d8 04 	lds	r24, 0x04D8
    e656:	60 e6       	ldi	r22, 0x60	; 96
    e658:	7a ee       	ldi	r23, 0xEA	; 234
    e65a:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
    e65e:	08 95       	ret
				break;
			case BCKLT_30sec:
				StartTimer16(TD_BackLight, 3000);
				break;
			case BCKLT_1min:
				StartTimer16(TD_BackLight, 6000);
    e660:	80 91 d8 04 	lds	r24, 0x04D8
    e664:	60 e7       	ldi	r22, 0x70	; 112
    e666:	77 e1       	ldi	r23, 0x17	; 23
    e668:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
    e66c:	08 95       	ret
				break;
			case BCKLT_3min:
				StartTimer16(TD_BackLight, 18000);
    e66e:	80 91 d8 04 	lds	r24, 0x04D8
    e672:	60 e5       	ldi	r22, 0x50	; 80
    e674:	76 e4       	ldi	r23, 0x46	; 70
    e676:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
    e67a:	08 95       	ret

0000e67c <LCDBackLightInit>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    e67c:	9f b7       	in	r25, 0x3f	; 63
    e67e:	90 78       	andi	r25, 0x80	; 128
    e680:	90 93 ee 02 	sts	0x02EE, r25
	cli();
    e684:	f8 94       	cli
	enum BACKLIGHT_TIMES{ BCKLT_10sec, BCKLT_30sec, BCKLT_1min,  BCKLT_3min,  BCKLT_10min};
	static uint8_t EEMEM BackLightTimeEE = BCKLT_10sec;

	void LCDBackLightInit(void){
		IntOff();	
		DDR_BACKLIGHT |= BACKLIGHT;
    e686:	80 91 0a 01 	lds	r24, 0x010A
    e68a:	80 64       	ori	r24, 0x40	; 64
    e68c:	80 93 0a 01 	sts	0x010A, r24

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    e690:	99 23       	and	r25, r25
    e692:	09 f0       	breq	.+2      	; 0xe696 <LCDBackLightInit+0x1a>
		sei();
    e694:	78 94       	sei

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    e696:	80 91 d0 02 	lds	r24, 0x02D0
	VacantTimer16Sys += n;
    e69a:	8f 5f       	subi	r24, 0xFF	; 255
    e69c:	80 93 d0 02 	sts	0x02D0, r24
    e6a0:	81 50       	subi	r24, 0x01	; 1
		IntOn();	
		TD_BackLight = Timer16SysAlloc(1);
    e6a2:	80 93 d8 04 	sts	0x04D8, r24
		if(BackLightMode != 2){
    e6a6:	80 91 52 06 	lds	r24, 0x0652
    e6aa:	82 30       	cpi	r24, 0x02	; 2
    e6ac:	21 f0       	breq	.+8      	; 0xe6b6 <LCDBackLightInit+0x3a>
			LCDBackLightOn();
    e6ae:	0e 94 e6 28 	call	0x51cc	; 0x51cc <LCDBackLightOn>
			LCDBackLightStartTimer();
    e6b2:	0e 94 0d 73 	call	0xe61a	; 0xe61a <LCDBackLightStartTimer>
    e6b6:	08 95       	ret

0000e6b8 <LCD_Init>:
}

// ~~~~~~~~~~~~
void
LCD_Init (void)
{
    e6b8:	ef 92       	push	r14
    e6ba:	ff 92       	push	r15
    e6bc:	1f 93       	push	r17
    e6be:	cf 93       	push	r28
    e6c0:	df 93       	push	r29
	uint8_t i, j;

	// LCD pins
	#ifdef Port_LCD_RW
		Port_LCD_RW &= ~LCD_RW;
    e6c2:	43 98       	cbi	0x08, 3	; 8
		DDR_LCD_RW |= LCD_RW;
    e6c4:	3b 9a       	sbi	0x07, 3	; 7
	#endif

	Port_LCD_RS &= ~LCD_RS;	
    e6c6:	44 98       	cbi	0x08, 4	; 8
	DDR_LCD_RS |=LCD_RS;
    e6c8:	3c 9a       	sbi	0x07, 4	; 7

	Port_LCD_E &= ~LCD_E;	
    e6ca:	42 98       	cbi	0x08, 2	; 8
	DDR_LCD_E |=LCD_E;
    e6cc:	3a 9a       	sbi	0x07, 2	; 7

	#ifdef Port_LCD_DB0	
		DDR_LCD_DB0 |=DB0;
    e6ce:	39 9a       	sbi	0x07, 1	; 7
		DDR_LCD_DB1 |=DB1;
    e6d0:	38 9a       	sbi	0x07, 0	; 7
		DDR_LCD_DB2 |=DB2;
    e6d2:	99 9a       	sbi	0x13, 1	; 19
		DDR_LCD_DB3 |=DB3;
    e6d4:	98 9a       	sbi	0x13, 0	; 19
	#endif
	DDR_LCD_DB4 |=DB4;
    e6d6:	57 9a       	sbi	0x0a, 7	; 10
	DDR_LCD_DB5 |=DB5;
    e6d8:	56 9a       	sbi	0x0a, 6	; 10
	DDR_LCD_DB6 |=DB6;
    e6da:	55 9a       	sbi	0x0a, 5	; 10
	DDR_LCD_DB7 |=DB7;
    e6dc:	80 91 0a 01 	lds	r24, 0x010A
    e6e0:	80 68       	ori	r24, 0x80	; 128
    e6e2:	80 93 0a 01 	sts	0x010A, r24
    e6e6:	21 e3       	ldi	r18, 0x31	; 49
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    e6e8:	40 ea       	ldi	r20, 0xA0	; 160
    e6ea:	5f e0       	ldi	r21, 0x0F	; 15
    e6ec:	ca 01       	movw	r24, r20
    e6ee:	01 97       	sbiw	r24, 0x01	; 1
    e6f0:	f1 f7       	brne	.-4      	; 0xe6ee <LCD_Init+0x36>

// ~~~~~~~~~~~~~~~~~~~~
void
Delay_ms(uint8_t Delay)
{
	while (Delay--)
    e6f2:	21 50       	subi	r18, 0x01	; 1
    e6f4:	d8 f7       	brcc	.-10     	; 0xe6ec <LCD_Init+0x34>
#endif
// ~~~~~~~~~~~
static void
LCD_Rst0(void)
{
	cli();
    e6f6:	f8 94       	cli
	Port_LCD_RS &=~LCD_RS;
    e6f8:	44 98       	cbi	0x08, 4	; 8
	LCD_FuncSet0();
    e6fa:	0e 94 40 27 	call	0x4e80	; 0x4e80 <LCD_FuncSet0>
	sei();
    e6fe:	78 94       	sei
    e700:	80 ea       	ldi	r24, 0xA0	; 160
    e702:	9f e0       	ldi	r25, 0x0F	; 15
    e704:	fc 01       	movw	r30, r24
    e706:	31 97       	sbiw	r30, 0x01	; 1
    e708:	f1 f7       	brne	.-4      	; 0xe706 <LCD_Init+0x4e>
    e70a:	fc 01       	movw	r30, r24
    e70c:	31 97       	sbiw	r30, 0x01	; 1
    e70e:	f1 f7       	brne	.-4      	; 0xe70c <LCD_Init+0x54>
    e710:	fc 01       	movw	r30, r24
    e712:	31 97       	sbiw	r30, 0x01	; 1
    e714:	f1 f7       	brne	.-4      	; 0xe712 <LCD_Init+0x5a>
    e716:	fc 01       	movw	r30, r24
    e718:	31 97       	sbiw	r30, 0x01	; 1
    e71a:	f1 f7       	brne	.-4      	; 0xe718 <LCD_Init+0x60>
    e71c:	01 97       	sbiw	r24, 0x01	; 1
    e71e:	f1 f7       	brne	.-4      	; 0xe71c <LCD_Init+0x64>

// ~~~~~~~~~~~
static void
LCD_Rst1(void)
{
	LCD_FuncSet0();
    e720:	0e 94 40 27 	call	0x4e80	; 0x4e80 <LCD_FuncSet0>
	Delay_us(200);				// 100 us needs
    e724:	88 ec       	ldi	r24, 0xC8	; 200
    e726:	90 e0       	ldi	r25, 0x00	; 0
    e728:	0e 94 ee 1e 	call	0x3ddc	; 0x3ddc <Delay_us>
	LCD_FuncSet0();
    e72c:	0e 94 40 27 	call	0x4e80	; 0x4e80 <LCD_FuncSet0>
	Delay_us(LCD_Delay);
    e730:	82 e3       	ldi	r24, 0x32	; 50
    e732:	90 e0       	ldi	r25, 0x00	; 0
    e734:	0e 94 ee 1e 	call	0x3ddc	; 0x3ddc <Delay_us>
	#ifdef Port_LCD_DB0	
		LCD_FuncSet0();
    e738:	0e 94 40 27 	call	0x4e80	; 0x4e80 <LCD_FuncSet0>
	#else
		LCD_FuncSet1();
	#endif
//// BF(Busy flag) can be checked follow
	Delay_us(LCD_Delay);
    e73c:	82 e3       	ldi	r24, 0x32	; 50
    e73e:	90 e0       	ldi	r25, 0x00	; 0
    e740:	0e 94 ee 1e 	call	0x3ddc	; 0x3ddc <Delay_us>
	Port_LCD_RS |=LCD_RS;
    e744:	44 9a       	sbi	0x08, 4	; 8

	LCD_Rst0();
	Delay_ms(5);		// 4.1 ms needs
	LCD_Rst1();

	Port_LCD_RS &=~LCD_RS;
    e746:	44 98       	cbi	0x08, 4	; 8

	#ifdef Port_LCD_DB0	
		Send_I(0b00111000);	//; 8-bits DL, 2 lines, 5x7 dots
    e748:	88 e3       	ldi	r24, 0x38	; 56
    e74a:	0e 94 39 27 	call	0x4e72	; 0x4e72 <Send_I>
	#else
		Send_I(0b00101000);	//; 4-bits DL, 2 lines, 5x7 dots
	#endif
	Send_I(0b00001100);	//; Display on, cursor off, blink off	
    e74e:	8c e0       	ldi	r24, 0x0C	; 12
    e750:	0e 94 39 27 	call	0x4e72	; 0x4e72 <Send_I>
	Send_I(0b00000110);	//; cursor shift right, no display shift
    e754:	86 e0       	ldi	r24, 0x06	; 6
    e756:	0e 94 39 27 	call	0x4e72	; 0x4e72 <Send_I>


	Send_I(0b01000000);	//;    CG RAM   0.
    e75a:	80 e4       	ldi	r24, 0x40	; 64
    e75c:	0e 94 39 27 	call	0x4e72	; 0x4e72 <Send_I>
	Port_LCD_RS |=LCD_RS;
    e760:	44 9a       	sbi	0x08, 4	; 8
    e762:	87 eb       	ldi	r24, 0xB7	; 183
    e764:	e8 2e       	mov	r14, r24
    e766:	8f e2       	ldi	r24, 0x2F	; 47
    e768:	f8 2e       	mov	r15, r24
	for (i=0; i<8; i++)
    e76a:	e7 01       	movw	r28, r14
    e76c:	10 e0       	ldi	r17, 0x00	; 0

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    e76e:	fe 01       	movw	r30, r28
    e770:	84 91       	lpm	r24, Z+
		for (j=0; j<8; j++)
			Send_I(prb(CGRAM_LCD[i]+j));
    e772:	0e 94 39 27 	call	0x4e72	; 0x4e72 <Send_I>


	Send_I(0b01000000);	//;    CG RAM   0.
	Port_LCD_RS |=LCD_RS;
	for (i=0; i<8; i++)
		for (j=0; j<8; j++)
    e776:	1f 5f       	subi	r17, 0xFF	; 255
    e778:	21 96       	adiw	r28, 0x01	; 1
    e77a:	18 30       	cpi	r17, 0x08	; 8
    e77c:	c1 f7       	brne	.-16     	; 0xe76e <LCD_Init+0xb6>
    e77e:	88 e0       	ldi	r24, 0x08	; 8
    e780:	90 e0       	ldi	r25, 0x00	; 0
    e782:	e8 0e       	add	r14, r24
    e784:	f9 1e       	adc	r15, r25
	Send_I(0b00000110);	//; cursor shift right, no display shift


	Send_I(0b01000000);	//;    CG RAM   0.
	Port_LCD_RS |=LCD_RS;
	for (i=0; i<8; i++)
    e786:	97 ef       	ldi	r25, 0xF7	; 247
    e788:	e9 16       	cp	r14, r25
    e78a:	9f e2       	ldi	r25, 0x2F	; 47
    e78c:	f9 06       	cpc	r15, r25
    e78e:	69 f7       	brne	.-38     	; 0xe76a <LCD_Init+0xb2>
		for (j=0; j<8; j++)
			Send_I(prb(CGRAM_LCD[i]+j));

	Port_LCD_RS &=~LCD_RS;
    e790:	44 98       	cbi	0x08, 4	; 8
	Send(0b00000001);
    e792:	81 e0       	ldi	r24, 0x01	; 1
    e794:	0e 94 f8 26 	call	0x4df0	; 0x4df0 <Send>
    e798:	80 ea       	ldi	r24, 0xA0	; 160
    e79a:	9f e0       	ldi	r25, 0x0F	; 15
    e79c:	fc 01       	movw	r30, r24
    e79e:	31 97       	sbiw	r30, 0x01	; 1
    e7a0:	f1 f7       	brne	.-4      	; 0xe79e <LCD_Init+0xe6>
    e7a2:	fc 01       	movw	r30, r24
    e7a4:	31 97       	sbiw	r30, 0x01	; 1
    e7a6:	f1 f7       	brne	.-4      	; 0xe7a4 <LCD_Init+0xec>
    e7a8:	fc 01       	movw	r30, r24
    e7aa:	31 97       	sbiw	r30, 0x01	; 1
    e7ac:	f1 f7       	brne	.-4      	; 0xe7aa <LCD_Init+0xf2>
    e7ae:	fc 01       	movw	r30, r24
    e7b0:	31 97       	sbiw	r30, 0x01	; 1
    e7b2:	f1 f7       	brne	.-4      	; 0xe7b0 <LCD_Init+0xf8>
    e7b4:	01 97       	sbiw	r24, 0x01	; 1
    e7b6:	f1 f7       	brne	.-4      	; 0xe7b4 <LCD_Init+0xfc>
	Delay_ms(5);				// By trial
	Port_LCD_RS |=LCD_RS;
    e7b8:	44 9a       	sbi	0x08, 4	; 8
}

uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    e7ba:	80 91 cf 02 	lds	r24, 0x02CF
	VacantTimer8Sys += n;
    e7be:	8f 5f       	subi	r24, 0xFF	; 255
    e7c0:	80 93 cf 02 	sts	0x02CF, r24
    e7c4:	81 50       	subi	r24, 0x01	; 1

	// Frame Timer
	TD_LCD = Timer8SysAlloc(1);
    e7c6:	80 93 d7 04 	sts	0x04D7, r24
    e7ca:	20 e0       	ldi	r18, 0x00	; 0
    e7cc:	30 e0       	ldi	r19, 0x00	; 0

	for (i=0; i<LCDYSz; i++)
		for (j=0; j<LCDXSz; j++)
			LCD_Buf[i][j] = ' ';
    e7ce:	40 e2       	ldi	r20, 0x20	; 32
	Port_LCD_RS |=LCD_RS;

	// Frame Timer
	TD_LCD = Timer8SysAlloc(1);

	for (i=0; i<LCDYSz; i++)
    e7d0:	c9 01       	movw	r24, r18
    e7d2:	88 0f       	add	r24, r24
    e7d4:	99 1f       	adc	r25, r25
    e7d6:	82 0f       	add	r24, r18
    e7d8:	93 1f       	adc	r25, r19
    e7da:	fc 01       	movw	r30, r24
    e7dc:	ee 0f       	add	r30, r30
    e7de:	ff 1f       	adc	r31, r31
    e7e0:	ee 0f       	add	r30, r30
    e7e2:	ff 1f       	adc	r31, r31
    e7e4:	ee 0f       	add	r30, r30
    e7e6:	ff 1f       	adc	r31, r31
    e7e8:	e8 1b       	sub	r30, r24
    e7ea:	f9 0b       	sbc	r31, r25
    e7ec:	e8 5a       	subi	r30, 0xA8	; 168
    e7ee:	f9 4f       	sbci	r31, 0xF9	; 249
    e7f0:	80 e0       	ldi	r24, 0x00	; 0
		for (j=0; j<LCDXSz; j++)
			LCD_Buf[i][j] = ' ';
    e7f2:	41 93       	st	Z+, r20

	// Frame Timer
	TD_LCD = Timer8SysAlloc(1);

	for (i=0; i<LCDYSz; i++)
		for (j=0; j<LCDXSz; j++)
    e7f4:	8f 5f       	subi	r24, 0xFF	; 255
    e7f6:	84 31       	cpi	r24, 0x14	; 20
    e7f8:	e1 f7       	brne	.-8      	; 0xe7f2 <LCD_Init+0x13a>
    e7fa:	2f 5f       	subi	r18, 0xFF	; 255
    e7fc:	3f 4f       	sbci	r19, 0xFF	; 255
	Port_LCD_RS |=LCD_RS;

	// Frame Timer
	TD_LCD = Timer8SysAlloc(1);

	for (i=0; i<LCDYSz; i++)
    e7fe:	24 30       	cpi	r18, 0x04	; 4
    e800:	31 05       	cpc	r19, r1
    e802:	31 f7       	brne	.-52     	; 0xe7d0 <LCD_Init+0x118>
		for (j=0; j<LCDXSz; j++)
			LCD_Buf[i][j] = ' ';

	#ifdef RTYP
		#ifndef QslRD
			*(uint8_t*)RTYP = R_PLC_Type;
    e804:	87 e0       	ldi	r24, 0x07	; 7
    e806:	80 93 90 08 	sts	0x0890, r24
		#endif	
	#endif

	#ifdef BACKLIGHT
		LCDBackLightInit();
    e80a:	0e 94 3e 73 	call	0xe67c	; 0xe67c <LCDBackLightInit>
	#endif
}
    e80e:	df 91       	pop	r29
    e810:	cf 91       	pop	r28
    e812:	1f 91       	pop	r17
    e814:	ff 90       	pop	r15
    e816:	ef 90       	pop	r14
    e818:	08 95       	ret

0000e81a <RTC_Summer_Time>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    e81a:	83 e0       	ldi	r24, 0x03	; 3
    e81c:	90 e0       	ldi	r25, 0x00	; 0
    e81e:	0e 94 17 84 	call	0x1082e	; 0x1082e <__eerd_byte_m2560>
	
	return 0;
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void RTC_Summer_Time(void){
	if(erb(&SummerTime)){
    e822:	88 23       	and	r24, r24
    e824:	31 f0       	breq	.+12     	; 0xe832 <RTC_Summer_Time+0x18>
		//   ()  02:00:00   03:00:00    
		if( (Tm_Mon == 3) && (Tm_WDay == 0) && (Tm_MDay>=25) && (Tm_Hour == 2) ){
    e826:	90 91 cb 07 	lds	r25, 0x07CB
    e82a:	93 30       	cpi	r25, 0x03	; 3
    e82c:	b1 f0       	breq	.+44     	; 0xe85a <RTC_Summer_Time+0x40>
				Tm_Hour=3;
				SetHour();
		}

		//   ()  04:00:00   03:00:00    
		if( (Tm_Mon == 10) && (Tm_WDay == 0) && (Tm_MDay>=25) ){
    e82e:	9a 30       	cpi	r25, 0x0A	; 10
    e830:	09 f0       	breq	.+2      	; 0xe834 <RTC_Summer_Time+0x1a>
    e832:	08 95       	ret
    e834:	80 91 57 06 	lds	r24, 0x0657
    e838:	88 23       	and	r24, r24
    e83a:	d9 f7       	brne	.-10     	; 0xe832 <RTC_Summer_Time+0x18>
    e83c:	80 91 5e 0b 	lds	r24, 0x0B5E
    e840:	89 31       	cpi	r24, 0x19	; 25
    e842:	b8 f3       	brcs	.-18     	; 0xe832 <RTC_Summer_Time+0x18>
				if(Tm_Hour == 4){
    e844:	80 91 c1 05 	lds	r24, 0x05C1
    e848:	84 30       	cpi	r24, 0x04	; 4
    e84a:	d1 f0       	breq	.+52     	; 0xe880 <RTC_Summer_Time+0x66>
						Tm_Hour=3;
						SetHour();
						NotSummerTimeFlag = 1;
					}
				}
				if(Tm_Hour < 2) NotSummerTimeFlag = 0;
    e84c:	82 30       	cpi	r24, 0x02	; 2
    e84e:	38 f1       	brcs	.+78     	; 0xe89e <RTC_Summer_Time+0x84>
				if(Tm_Hour >= 5) NotSummerTimeFlag = 0;
    e850:	85 30       	cpi	r24, 0x05	; 5
    e852:	78 f3       	brcs	.-34     	; 0xe832 <RTC_Summer_Time+0x18>
    e854:	10 92 dd 05 	sts	0x05DD, r1
    e858:	08 95       	ret
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void RTC_Summer_Time(void){
	if(erb(&SummerTime)){
		//   ()  02:00:00   03:00:00    
		if( (Tm_Mon == 3) && (Tm_WDay == 0) && (Tm_MDay>=25) && (Tm_Hour == 2) ){
    e85a:	80 91 57 06 	lds	r24, 0x0657
    e85e:	88 23       	and	r24, r24
    e860:	41 f7       	brne	.-48     	; 0xe832 <RTC_Summer_Time+0x18>
    e862:	80 91 5e 0b 	lds	r24, 0x0B5E
    e866:	89 31       	cpi	r24, 0x19	; 25
    e868:	20 f3       	brcs	.-56     	; 0xe832 <RTC_Summer_Time+0x18>
    e86a:	80 91 c1 05 	lds	r24, 0x05C1
    e86e:	82 30       	cpi	r24, 0x02	; 2
    e870:	01 f7       	brne	.-64     	; 0xe832 <RTC_Summer_Time+0x18>
				Tm_Hour=3;
    e872:	90 93 c1 05 	sts	0x05C1, r25
				SetHour();
    e876:	0e 94 cc 24 	call	0x4998	; 0x4998 <SetHour>
    e87a:	90 91 cb 07 	lds	r25, 0x07CB
    e87e:	d7 cf       	rjmp	.-82     	; 0xe82e <RTC_Summer_Time+0x14>
		}

		//   ()  04:00:00   03:00:00    
		if( (Tm_Mon == 10) && (Tm_WDay == 0) && (Tm_MDay>=25) ){
				if(Tm_Hour == 4){
					if(!NotSummerTimeFlag){
    e880:	80 91 dd 05 	lds	r24, 0x05DD
    e884:	88 23       	and	r24, r24
    e886:	a9 f6       	brne	.-86     	; 0xe832 <RTC_Summer_Time+0x18>
						Tm_Hour=3;
    e888:	83 e0       	ldi	r24, 0x03	; 3
    e88a:	80 93 c1 05 	sts	0x05C1, r24
						SetHour();
    e88e:	0e 94 cc 24 	call	0x4998	; 0x4998 <SetHour>
						NotSummerTimeFlag = 1;
    e892:	81 e0       	ldi	r24, 0x01	; 1
    e894:	80 93 dd 05 	sts	0x05DD, r24
    e898:	80 91 c1 05 	lds	r24, 0x05C1
    e89c:	d7 cf       	rjmp	.-82     	; 0xe84c <RTC_Summer_Time+0x32>
					}
				}
				if(Tm_Hour < 2) NotSummerTimeFlag = 0;
    e89e:	10 92 dd 05 	sts	0x05DD, r1
    e8a2:	d6 cf       	rjmp	.-84     	; 0xe850 <RTC_Summer_Time+0x36>

0000e8a4 <TWI_In>:
}

// ~~~~~~~~~
void
TWI_In(void)
{
    e8a4:	cf 92       	push	r12
    e8a6:	ef 92       	push	r14
    e8a8:	0f 93       	push	r16
	if(Timer8Stopp(TD_TWI_Poll)){
    e8aa:	00 91 d2 04 	lds	r16, 0x04D2
    e8ae:	80 2f       	mov	r24, r16
    e8b0:	0e 94 f5 1c 	call	0x39ea	; 0x39ea <Timer8Stopp>
    e8b4:	88 23       	and	r24, r24
    e8b6:	e1 f0       	breq	.+56     	; 0xe8f0 <TWI_In+0x4c>

		if (TWI_Phase == PCF_START){
    e8b8:	80 91 c3 07 	lds	r24, 0x07C3
    e8bc:	88 23       	and	r24, r24
    e8be:	99 f1       	breq	.+102    	; 0xe926 <TWI_In+0x82>
			StartTWI();		// Send Start
			TWI_Phase++;
			StartTimer8(TD_TWI_Timeout,40);
			return;
		}
		if(Timer8Stopp(TD_TWI_Timeout)){	// 
    e8c0:	80 91 d3 04 	lds	r24, 0x04D3
    e8c4:	0e 94 f5 1c 	call	0x39ea	; 0x39ea <Timer8Stopp>
    e8c8:	88 23       	and	r24, r24
    e8ca:	09 f0       	breq	.+2      	; 0xe8ce <TWI_In+0x2a>
    e8cc:	4e c0       	rjmp	.+156    	; 0xe96a <TWI_In+0xc6>
			TWI_Error();
			return;
		}

		if (!(TWCR &(1<<TWINT))) return;
    e8ce:	80 91 bc 00 	lds	r24, 0x00BC
    e8d2:	87 ff       	sbrs	r24, 7
    e8d4:	33 c0       	rjmp	.+102    	; 0xe93c <TWI_In+0x98>

		switch(TWI_Phase) {
    e8d6:	40 91 c3 07 	lds	r20, 0x07C3
    e8da:	84 2f       	mov	r24, r20
    e8dc:	90 e0       	ldi	r25, 0x00	; 0
    e8de:	fc 01       	movw	r30, r24
    e8e0:	31 97       	sbiw	r30, 0x01	; 1
    e8e2:	e1 31       	cpi	r30, 0x11	; 17
    e8e4:	f1 05       	cpc	r31, r1
    e8e6:	08 f4       	brcc	.+2      	; 0xe8ea <TWI_In+0x46>
    e8e8:	46 c0       	rjmp	.+140    	; 0xe976 <TWI_In+0xd2>
			Tm_WDay = SetWeekday(Tm_Year, Tm_Mon, Tm_MDay);
			StartTimer8(TD_TWI_Poll, 49);
			TWI_Phase = 0xFF;
			break;
		}
		TWI_Phase++;
    e8ea:	4f 5f       	subi	r20, 0xFF	; 255
    e8ec:	40 93 c3 07 	sts	0x07C3, r20
	}//Timer8Stopp(TD_TWI)

	if( Timer16Stopp(TD_RTC_Check) && (TWI_Phase == PCF_START) ){
    e8f0:	00 91 d4 04 	lds	r16, 0x04D4
    e8f4:	80 2f       	mov	r24, r16
    e8f6:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <Timer16Stopp>
    e8fa:	88 23       	and	r24, r24
    e8fc:	f9 f0       	breq	.+62     	; 0xe93c <TWI_In+0x98>
    e8fe:	80 91 c3 07 	lds	r24, 0x07C3
    e902:	88 23       	and	r24, r24
    e904:	d9 f4       	brne	.+54     	; 0xe93c <TWI_In+0x98>
		StartTimer16(TD_RTC_Check, 300);
    e906:	80 2f       	mov	r24, r16
    e908:	6c e2       	ldi	r22, 0x2C	; 44
    e90a:	71 e0       	ldi	r23, 0x01	; 1
    e90c:	0e 94 dc 1b 	call	0x37b8	; 0x37b8 <StartTimer16>
		if(RTC_Check() || PFC_Stop_bit){
    e910:	0e 94 f1 25 	call	0x4be2	; 0x4be2 <RTC_Check>
    e914:	88 23       	and	r24, r24
    e916:	b1 f4       	brne	.+44     	; 0xe944 <TWI_In+0xa0>
    e918:	80 91 d5 04 	lds	r24, 0x04D5
    e91c:	88 23       	and	r24, r24
    e91e:	91 f4       	brne	.+36     	; 0xe944 <TWI_In+0xa0>
			// RTC
			SetDateTime(TrueTime_Year, TrueTime_Mon, TrueTime_MDay, TrueTime_WDay, TrueTime_Hour, TrueTime_Min, TrueTime_Sec);
		}
		else RTC_GetTrueTime();
    e920:	0e 94 a8 25 	call	0x4b50	; 0x4b50 <RTC_GetTrueTime>
    e924:	1f c0       	rjmp	.+62     	; 0xe964 <TWI_In+0xc0>
TWI_In(void)
{
	if(Timer8Stopp(TD_TWI_Poll)){

		if (TWI_Phase == PCF_START){
			StartTWI();		// Send Start
    e926:	84 ea       	ldi	r24, 0xA4	; 164
    e928:	80 93 bc 00 	sts	0x00BC, r24
			TWI_Phase++;
    e92c:	81 e0       	ldi	r24, 0x01	; 1
    e92e:	80 93 c3 07 	sts	0x07C3, r24
			StartTimer8(TD_TWI_Timeout,40);
    e932:	80 91 d3 04 	lds	r24, 0x04D3
    e936:	68 e2       	ldi	r22, 0x28	; 40
    e938:	0e 94 a1 1b 	call	0x3742	; 0x3742 <StartTimer8>
		}
		else RTC_GetTrueTime();

		RTC_Summer_Time();
	}
}
    e93c:	0f 91       	pop	r16
    e93e:	ef 90       	pop	r14
    e940:	cf 90       	pop	r12
    e942:	08 95       	ret

	if( Timer16Stopp(TD_RTC_Check) && (TWI_Phase == PCF_START) ){
		StartTimer16(TD_RTC_Check, 300);
		if(RTC_Check() || PFC_Stop_bit){
			// RTC
			SetDateTime(TrueTime_Year, TrueTime_Mon, TrueTime_MDay, TrueTime_WDay, TrueTime_Hour, TrueTime_Min, TrueTime_Sec);
    e944:	80 91 c1 07 	lds	r24, 0x07C1
    e948:	60 91 14 09 	lds	r22, 0x0914
    e94c:	40 91 56 06 	lds	r20, 0x0656
    e950:	20 91 5d 0b 	lds	r18, 0x0B5D
    e954:	00 91 d8 05 	lds	r16, 0x05D8
    e958:	e0 90 15 09 	lds	r14, 0x0915
    e95c:	c0 90 13 09 	lds	r12, 0x0913
    e960:	0e 94 f4 24 	call	0x49e8	; 0x49e8 <SetDateTime>
		}
		else RTC_GetTrueTime();

		RTC_Summer_Time();
    e964:	0e 94 0d 74 	call	0xe81a	; 0xe81a <RTC_Summer_Time>
    e968:	e9 cf       	rjmp	.-46     	; 0xe93c <TWI_In+0x98>
			Tm_Mon = DecodBCD(TWDR & 0b00011111);
			if(Tm_Mon > 12) Tm_Mon = 0;	//
			RunTWI();		//NACK
			break;
		case PCF_Year:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_NACK){ TWI_Error(); return;}
    e96a:	0e 94 29 24 	call	0x4852	; 0x4852 <TWI_Error>
		}
		else RTC_GetTrueTime();

		RTC_Summer_Time();
	}
}
    e96e:	0f 91       	pop	r16
    e970:	ef 90       	pop	r14
    e972:	cf 90       	pop	r12
    e974:	08 95       	ret
			return;
		}

		if (!(TWCR &(1<<TWINT))) return;

		switch(TWI_Phase) {
    e976:	ea 5a       	subi	r30, 0xAA	; 170
    e978:	fe 4f       	sbci	r31, 0xFE	; 254
    e97a:	ee 0f       	add	r30, r30
    e97c:	ff 1f       	adc	r31, r31
    e97e:	05 90       	lpm	r0, Z+
    e980:	f4 91       	lpm	r31, Z+
    e982:	e0 2d       	mov	r30, r0
    e984:	19 94       	eijmp
		case PFC_ACKN:
			AcknTWI();
			break;

		case PCF_Se:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
    e986:	80 91 b9 00 	lds	r24, 0x00B9
    e98a:	88 7f       	andi	r24, 0xF8	; 248
    e98c:	80 35       	cpi	r24, 0x50	; 80
    e98e:	69 f7       	brne	.-38     	; 0xe96a <TWI_In+0xc6>
			Tm_Sec = DecodBCD(TWDR & 0b01111111);	// exclude ST bit
    e990:	20 91 bb 00 	lds	r18, 0x00BB
    e994:	82 2f       	mov	r24, r18
    e996:	8f 77       	andi	r24, 0x7F	; 127
    e998:	82 95       	swap	r24
    e99a:	8f 70       	andi	r24, 0x0F	; 15
    e99c:	3a e0       	ldi	r19, 0x0A	; 10
    e99e:	83 9f       	mul	r24, r19
    e9a0:	c0 01       	movw	r24, r0
    e9a2:	11 24       	eor	r1, r1
    e9a4:	2f 70       	andi	r18, 0x0F	; 15
    e9a6:	28 0f       	add	r18, r24
    e9a8:	20 93 f7 06 	sts	0x06F7, r18
			PFC_Stop_bit = TWDR & 0b10000000;
    e9ac:	80 91 bb 00 	lds	r24, 0x00BB
    e9b0:	80 78       	andi	r24, 0x80	; 128
    e9b2:	80 93 d5 04 	sts	0x04D5, r24
/*			if(PFC_Stop_bit) NoTickCnt++;
			else NoTickCnt=0;*/
			AcknTWI();
    e9b6:	84 ec       	ldi	r24, 0xC4	; 196
    e9b8:	80 93 bc 00 	sts	0x00BC, r24
    e9bc:	96 cf       	rjmp	.-212    	; 0xe8ea <TWI_In+0x46>

		case PCF_REAP_START1:
			StartTWI();
			break;
		case PCF_CHECK_REAP_START1:
			if( (TWSR & 0b11111000) != TWI_STATUS_RP_START){ TWI_Error(); return;}
    e9be:	80 91 b9 00 	lds	r24, 0x00B9
    e9c2:	88 7f       	andi	r24, 0xF8	; 248
    e9c4:	80 31       	cpi	r24, 0x10	; 16
    e9c6:	89 f6       	brne	.-94     	; 0xe96a <TWI_In+0xc6>
    e9c8:	48 e0       	ldi	r20, 0x08	; 8
			else TWI_Phase++;

		case PCF_SLA_R:
			SLA_R(PCF_SLA);
    e9ca:	81 ed       	ldi	r24, 0xD1	; 209
    e9cc:	80 93 bb 00 	sts	0x00BB, r24
			RunTWI();
    e9d0:	84 e8       	ldi	r24, 0x84	; 132
    e9d2:	80 93 bc 00 	sts	0x00BC, r24
    e9d6:	89 cf       	rjmp	.-238    	; 0xe8ea <TWI_In+0x46>
		case PCF_Addr:
			TWDR = AddrSec;
			RunTWI();
			break;
		case PCF_CHECK_Addr:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATATX_ACK){ TWI_Error(); return;}
    e9d8:	80 91 b9 00 	lds	r24, 0x00B9
    e9dc:	88 7f       	andi	r24, 0xF8	; 248
    e9de:	88 32       	cpi	r24, 0x28	; 40
    e9e0:	21 f6       	brne	.-120    	; 0xe96a <TWI_In+0xc6>
    e9e2:	46 e0       	ldi	r20, 0x06	; 6
			else TWI_Phase++;

		case PCF_REAP_START1:
			StartTWI();
    e9e4:	84 ea       	ldi	r24, 0xA4	; 164
    e9e6:	80 93 bc 00 	sts	0x00BC, r24
    e9ea:	7f cf       	rjmp	.-258    	; 0xe8ea <TWI_In+0x46>
		case PCF_SLA_W:
			SLA_W(PCF_SLA);
			RunTWI();
			break;
		case PCF_CHECK_SLA_W:
			if( (TWSR & 0b11111000) != TWI_STATUS_SLAW_ACK){ TWI_Error(); return;}
    e9ec:	80 91 b9 00 	lds	r24, 0x00B9
    e9f0:	88 7f       	andi	r24, 0xF8	; 248
    e9f2:	88 31       	cpi	r24, 0x18	; 24
    e9f4:	09 f0       	breq	.+2      	; 0xe9f8 <TWI_In+0x154>
    e9f6:	b9 cf       	rjmp	.-142    	; 0xe96a <TWI_In+0xc6>
    e9f8:	44 e0       	ldi	r20, 0x04	; 4
			else TWI_Phase++;

		case PCF_Addr:
			TWDR = AddrSec;
    e9fa:	10 92 bb 00 	sts	0x00BB, r1
			RunTWI();
    e9fe:	84 e8       	ldi	r24, 0x84	; 132
    ea00:	80 93 bc 00 	sts	0x00BC, r24
    ea04:	72 cf       	rjmp	.-284    	; 0xe8ea <TWI_In+0x46>
		if (!(TWCR &(1<<TWINT))) return;

		switch(TWI_Phase) {
		
		case PCF_CHECK_START:
			if( (TWSR & 0b11111000) != TWI_STATUS_START){ TWI_Error(); return;}
    ea06:	80 91 b9 00 	lds	r24, 0x00B9
    ea0a:	88 7f       	andi	r24, 0xF8	; 248
    ea0c:	88 30       	cpi	r24, 0x08	; 8
    ea0e:	09 f0       	breq	.+2      	; 0xea12 <TWI_In+0x16e>
    ea10:	ac cf       	rjmp	.-168    	; 0xe96a <TWI_In+0xc6>
    ea12:	42 e0       	ldi	r20, 0x02	; 2
			else TWI_Phase++;
			
		case PCF_SLA_W:
			SLA_W(PCF_SLA);
    ea14:	80 ed       	ldi	r24, 0xD0	; 208
    ea16:	80 93 bb 00 	sts	0x00BB, r24
			RunTWI();
    ea1a:	84 e8       	ldi	r24, 0x84	; 132
    ea1c:	80 93 bc 00 	sts	0x00BC, r24
    ea20:	64 cf       	rjmp	.-312    	; 0xe8ea <TWI_In+0x46>
		case PCF_SLA_R:
			SLA_R(PCF_SLA);
			RunTWI();
			break;
		case PCF_CHECK_SLA_R:
			if( (TWSR & 0b11111000) != TWI_STATUS_SLAR_ACK){ TWI_Error(); return;}
    ea22:	80 91 b9 00 	lds	r24, 0x00B9
    ea26:	88 7f       	andi	r24, 0xF8	; 248
    ea28:	80 34       	cpi	r24, 0x40	; 64
    ea2a:	09 f0       	breq	.+2      	; 0xea2e <TWI_In+0x18a>
    ea2c:	9e cf       	rjmp	.-196    	; 0xe96a <TWI_In+0xc6>
    ea2e:	4a e0       	ldi	r20, 0x0A	; 10
    ea30:	c2 cf       	rjmp	.-124    	; 0xe9b6 <TWI_In+0x112>
			Tm_Mon = DecodBCD(TWDR & 0b00011111);
			if(Tm_Mon > 12) Tm_Mon = 0;	//
			RunTWI();		//NACK
			break;
		case PCF_Year:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_NACK){ TWI_Error(); return;}
    ea32:	80 91 b9 00 	lds	r24, 0x00B9
    ea36:	88 7f       	andi	r24, 0xF8	; 248
    ea38:	88 35       	cpi	r24, 0x58	; 88
    ea3a:	09 f0       	breq	.+2      	; 0xea3e <TWI_In+0x19a>
    ea3c:	96 cf       	rjmp	.-212    	; 0xe96a <TWI_In+0xc6>
			Tm_Year = DecodBCD(TWDR);
    ea3e:	80 91 bb 00 	lds	r24, 0x00BB

// ~~~~~~~~~~~~~~~~~~
uint8_t
DecodBCD(uint8_t BCD)
{
	return 10*(BCD>>4)+(BCD&0x0F);
    ea42:	28 2f       	mov	r18, r24
    ea44:	22 95       	swap	r18
    ea46:	2f 70       	andi	r18, 0x0F	; 15
    ea48:	9a e0       	ldi	r25, 0x0A	; 10
    ea4a:	29 9f       	mul	r18, r25
    ea4c:	90 01       	movw	r18, r0
    ea4e:	11 24       	eor	r1, r1
    ea50:	8f 70       	andi	r24, 0x0F	; 15
    ea52:	82 0f       	add	r24, r18
    ea54:	80 93 de 05 	sts	0x05DE, r24
			StopTWI();
    ea58:	94 e9       	ldi	r25, 0x94	; 148
    ea5a:	90 93 bc 00 	sts	0x00BC, r25
			Tm_WDay = SetWeekday(Tm_Year, Tm_Mon, Tm_MDay);
    ea5e:	60 91 cb 07 	lds	r22, 0x07CB
    ea62:	40 91 5e 0b 	lds	r20, 0x0B5E
    ea66:	0e 94 8c 24 	call	0x4918	; 0x4918 <SetWeekday>
    ea6a:	80 93 57 06 	sts	0x0657, r24
			StartTimer8(TD_TWI_Poll, 49);
    ea6e:	80 2f       	mov	r24, r16
    ea70:	61 e3       	ldi	r22, 0x31	; 49
    ea72:	0e 94 a1 1b 	call	0x3742	; 0x3742 <StartTimer8>
    ea76:	4f ef       	ldi	r20, 0xFF	; 255
    ea78:	38 cf       	rjmp	.-400    	; 0xe8ea <TWI_In+0x46>
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
			Tm_MDay = DecodBCD(TWDR & 0b00111111);
			AcknTWI();
			break;
		case PCF_Mo:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
    ea7a:	80 91 b9 00 	lds	r24, 0x00B9
    ea7e:	88 7f       	andi	r24, 0xF8	; 248
    ea80:	80 35       	cpi	r24, 0x50	; 80
    ea82:	09 f0       	breq	.+2      	; 0xea86 <TWI_In+0x1e2>
    ea84:	72 cf       	rjmp	.-284    	; 0xe96a <TWI_In+0xc6>
			Tm_Mon = DecodBCD(TWDR & 0b00011111);
    ea86:	80 91 bb 00 	lds	r24, 0x00BB
    ea8a:	28 2f       	mov	r18, r24
    ea8c:	2f 71       	andi	r18, 0x1F	; 31
    ea8e:	22 95       	swap	r18
    ea90:	2f 70       	andi	r18, 0x0F	; 15
    ea92:	9a e0       	ldi	r25, 0x0A	; 10
    ea94:	29 9f       	mul	r18, r25
    ea96:	90 01       	movw	r18, r0
    ea98:	11 24       	eor	r1, r1
    ea9a:	8f 70       	andi	r24, 0x0F	; 15
    ea9c:	82 0f       	add	r24, r18
    ea9e:	80 93 cb 07 	sts	0x07CB, r24
			if(Tm_Mon > 12) Tm_Mon = 0;	//
    eaa2:	8d 30       	cpi	r24, 0x0D	; 13
    eaa4:	10 f0       	brcs	.+4      	; 0xeaaa <TWI_In+0x206>
    eaa6:	10 92 cb 07 	sts	0x07CB, r1
			RunTWI();		//NACK
    eaaa:	84 e8       	ldi	r24, 0x84	; 132
    eaac:	80 93 bc 00 	sts	0x00BC, r24
    eab0:	1c cf       	rjmp	.-456    	; 0xe8ea <TWI_In+0x46>
			TWDR;
			//Tm_WDay = DecodBCD(TWDR & 0b00000111); Ignore 
			AcknTWI();
			break;
		case PCF_MDay:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
    eab2:	80 91 b9 00 	lds	r24, 0x00B9
    eab6:	88 7f       	andi	r24, 0xF8	; 248
    eab8:	80 35       	cpi	r24, 0x50	; 80
    eaba:	09 f0       	breq	.+2      	; 0xeabe <TWI_In+0x21a>
    eabc:	56 cf       	rjmp	.-340    	; 0xe96a <TWI_In+0xc6>
			Tm_MDay = DecodBCD(TWDR & 0b00111111);
    eabe:	20 91 bb 00 	lds	r18, 0x00BB
    eac2:	82 2f       	mov	r24, r18
    eac4:	8f 73       	andi	r24, 0x3F	; 63
    eac6:	82 95       	swap	r24
    eac8:	8f 70       	andi	r24, 0x0F	; 15
    eaca:	3a e0       	ldi	r19, 0x0A	; 10
    eacc:	83 9f       	mul	r24, r19
    eace:	c0 01       	movw	r24, r0
    ead0:	11 24       	eor	r1, r1
    ead2:	2f 70       	andi	r18, 0x0F	; 15
    ead4:	28 0f       	add	r18, r24
    ead6:	20 93 5e 0b 	sts	0x0B5E, r18
			AcknTWI();
    eada:	84 ec       	ldi	r24, 0xC4	; 196
    eadc:	80 93 bc 00 	sts	0x00BC, r24
    eae0:	04 cf       	rjmp	.-504    	; 0xe8ea <TWI_In+0x46>
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
			Tm_Hour = DecodBCD(TWDR & 0b00111111);
			AcknTWI();
			break;
		case PCF_WDay:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
    eae2:	80 91 b9 00 	lds	r24, 0x00B9
    eae6:	88 7f       	andi	r24, 0xF8	; 248
    eae8:	80 35       	cpi	r24, 0x50	; 80
    eaea:	09 f0       	breq	.+2      	; 0xeaee <TWI_In+0x24a>
    eaec:	3e cf       	rjmp	.-388    	; 0xe96a <TWI_In+0xc6>
			TWDR;
    eaee:	80 91 bb 00 	lds	r24, 0x00BB
			//Tm_WDay = DecodBCD(TWDR & 0b00000111); Ignore 
			AcknTWI();
    eaf2:	84 ec       	ldi	r24, 0xC4	; 196
    eaf4:	80 93 bc 00 	sts	0x00BC, r24
    eaf8:	f8 ce       	rjmp	.-528    	; 0xe8ea <TWI_In+0x46>
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
			Tm_Min = DecodBCD(TWDR & 0b01111111);
			AcknTWI();
			break;
		case PCF_Ho:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
    eafa:	80 91 b9 00 	lds	r24, 0x00B9
    eafe:	88 7f       	andi	r24, 0xF8	; 248
    eb00:	80 35       	cpi	r24, 0x50	; 80
    eb02:	09 f0       	breq	.+2      	; 0xeb06 <TWI_In+0x262>
    eb04:	32 cf       	rjmp	.-412    	; 0xe96a <TWI_In+0xc6>
			Tm_Hour = DecodBCD(TWDR & 0b00111111);
    eb06:	20 91 bb 00 	lds	r18, 0x00BB
    eb0a:	82 2f       	mov	r24, r18
    eb0c:	8f 73       	andi	r24, 0x3F	; 63
    eb0e:	82 95       	swap	r24
    eb10:	8f 70       	andi	r24, 0x0F	; 15
    eb12:	3a e0       	ldi	r19, 0x0A	; 10
    eb14:	83 9f       	mul	r24, r19
    eb16:	c0 01       	movw	r24, r0
    eb18:	11 24       	eor	r1, r1
    eb1a:	2f 70       	andi	r18, 0x0F	; 15
    eb1c:	28 0f       	add	r18, r24
    eb1e:	20 93 c1 05 	sts	0x05C1, r18
			AcknTWI();
    eb22:	84 ec       	ldi	r24, 0xC4	; 196
    eb24:	80 93 bc 00 	sts	0x00BC, r24
    eb28:	e0 ce       	rjmp	.-576    	; 0xe8ea <TWI_In+0x46>
/*			if(PFC_Stop_bit) NoTickCnt++;
			else NoTickCnt=0;*/
			AcknTWI();
			break;
		case PCF_Mi:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
    eb2a:	80 91 b9 00 	lds	r24, 0x00B9
    eb2e:	88 7f       	andi	r24, 0xF8	; 248
    eb30:	80 35       	cpi	r24, 0x50	; 80
    eb32:	09 f0       	breq	.+2      	; 0xeb36 <TWI_In+0x292>
    eb34:	1a cf       	rjmp	.-460    	; 0xe96a <TWI_In+0xc6>
			Tm_Min = DecodBCD(TWDR & 0b01111111);
    eb36:	20 91 bb 00 	lds	r18, 0x00BB
    eb3a:	82 2f       	mov	r24, r18
    eb3c:	8f 77       	andi	r24, 0x7F	; 127
    eb3e:	82 95       	swap	r24
    eb40:	8f 70       	andi	r24, 0x0F	; 15
    eb42:	3a e0       	ldi	r19, 0x0A	; 10
    eb44:	83 9f       	mul	r24, r19
    eb46:	c0 01       	movw	r24, r0
    eb48:	11 24       	eor	r1, r1
    eb4a:	2f 70       	andi	r18, 0x0F	; 15
    eb4c:	28 0f       	add	r18, r24
    eb4e:	20 93 51 06 	sts	0x0651, r18
			AcknTWI();
    eb52:	84 ec       	ldi	r24, 0xC4	; 196
    eb54:	80 93 bc 00 	sts	0x00BC, r24
    eb58:	c8 ce       	rjmp	.-624    	; 0xe8ea <TWI_In+0x46>

0000eb5a <TimeInit>:

// ~~~~~~~~
void
WdtOn(void)
{
	wdt_reset();
    eb5a:	a8 95       	wdr
	wdt_enable(WDTO_2S);
    eb5c:	2f e0       	ldi	r18, 0x0F	; 15
    eb5e:	88 e1       	ldi	r24, 0x18	; 24
    eb60:	90 e0       	ldi	r25, 0x00	; 0
    eb62:	0f b6       	in	r0, 0x3f	; 63
    eb64:	f8 94       	cli
    eb66:	a8 95       	wdr
    eb68:	80 93 60 00 	sts	0x0060, r24
    eb6c:	0f be       	out	0x3f, r0	; 63
    eb6e:	20 93 60 00 	sts	0x0060, r18

	// WDT
	WdtOn();

	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TCCR1A = 0;
    eb72:	10 92 80 00 	sts	0x0080, r1
		TCCR1B = (((~(1<<WGM13) |(1<<WGM12)) &~(1<<CS12)) |(1<<CS11)) &~(1<<CS10);
    eb76:	8a ee       	ldi	r24, 0xEA	; 234
    eb78:	80 93 81 00 	sts	0x0081, r24
		OCR1A = 20000;
    eb7c:	80 e2       	ldi	r24, 0x20	; 32
    eb7e:	9e e4       	ldi	r25, 0x4E	; 78
    eb80:	90 93 89 00 	sts	0x0089, r25
    eb84:	80 93 88 00 	sts	0x0088, r24
		TCC0.CTRLE = ~TC0_BYTEM_bm;
	#endif
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__)
		TIMSK |=(1<<OCIE1A);
	#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TIMSK1 |=(1<<OCIE1A);
    eb88:	80 91 6f 00 	lds	r24, 0x006F
    eb8c:	82 60       	ori	r24, 0x02	; 2
    eb8e:	80 93 6f 00 	sts	0x006F, r24
    eb92:	80 e0       	ldi	r24, 0x00	; 0
    eb94:	90 e0       	ldi	r25, 0x00	; 0
	#endif

	// Program timers (10 ms)
	uint8_t i;
	for (i=0; i<sizeof(Timer8Flg); i++)
		Timer8Flg[i] = 0xFF;
    eb96:	2f ef       	ldi	r18, 0xFF	; 255
    eb98:	fc 01       	movw	r30, r24
    eb9a:	ef 54       	subi	r30, 0x4F	; 79
    eb9c:	fb 4f       	sbci	r31, 0xFB	; 251
    eb9e:	20 83       	st	Z, r18
    eba0:	01 96       	adiw	r24, 0x01	; 1
		TCC0.INTCTRLB = 0;
	#endif

	// Program timers (10 ms)
	uint8_t i;
	for (i=0; i<sizeof(Timer8Flg); i++)
    eba2:	8c 30       	cpi	r24, 0x0C	; 12
    eba4:	91 05       	cpc	r25, r1
    eba6:	c1 f7       	brne	.-16     	; 0xeb98 <TimeInit+0x3e>
    eba8:	80 e0       	ldi	r24, 0x00	; 0
    ebaa:	90 e0       	ldi	r25, 0x00	; 0
		Timer8Flg[i] = 0xFF;
	for (i=0; i<sizeof(Timer16Flg); i++)
		Timer16Flg[i] = 0xFF;
    ebac:	3f ef       	ldi	r19, 0xFF	; 255
    ebae:	fc 01       	movw	r30, r24
    ebb0:	e3 54       	subi	r30, 0x43	; 67
    ebb2:	fb 4f       	sbci	r31, 0xFB	; 251
    ebb4:	2f ef       	ldi	r18, 0xFF	; 255
    ebb6:	30 83       	st	Z, r19
    ebb8:	01 96       	adiw	r24, 0x01	; 1

	// Program timers (10 ms)
	uint8_t i;
	for (i=0; i<sizeof(Timer8Flg); i++)
		Timer8Flg[i] = 0xFF;
	for (i=0; i<sizeof(Timer16Flg); i++)
    ebba:	8d 30       	cpi	r24, 0x0D	; 13
    ebbc:	91 05       	cpc	r25, r1
    ebbe:	b9 f7       	brne	.-18     	; 0xebae <TimeInit+0x54>
		Timer16Flg[i] = 0xFF;
	for (i=0; i<sizeof(Timer32Flg); i++)
		Timer32Flg[i] = 0xFF;
    ebc0:	20 93 ca 04 	sts	0x04CA, r18
    ebc4:	20 93 cb 04 	sts	0x04CB, r18
    ebc8:	20 93 cc 04 	sts	0x04CC, r18
    ebcc:	20 93 cd 04 	sts	0x04CD, r18
    ebd0:	20 93 ce 04 	sts	0x04CE, r18
    ebd4:	20 93 cf 04 	sts	0x04CF, r18
    ebd8:	8d e9       	ldi	r24, 0x9D	; 157
    ebda:	91 e0       	ldi	r25, 0x01	; 1
    ebdc:	0e 94 17 84 	call	0x1082e	; 0x1082e <__eerd_byte_m2560>

	// 1 s
	Timer1min = erb(&Timer1min_EE);
    ebe0:	80 93 b0 06 	sts	0x06B0, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    ebe4:	8e e9       	ldi	r24, 0x9E	; 158
    ebe6:	91 e0       	ldi	r25, 0x01	; 1
    ebe8:	0e 94 25 84 	call	0x1084a	; 0x1084a <__eerd_word_m2560>
	Timer1hour = erw(&Timer1hour_EE);
    ebec:	90 93 6b 0c 	sts	0x0C6B, r25
    ebf0:	80 93 6a 0c 	sts	0x0C6A, r24

	// Application
	#ifdef InitTimer
		StartTimer16(InitTimer, InitTime);
	#endif
}
    ebf4:	08 95       	ret

0000ebf6 <MemCheckInit>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    ebf6:	8c e9       	ldi	r24, 0x9C	; 156
    ebf8:	91 e0       	ldi	r25, 0x01	; 1
    ebfa:	0e 94 17 84 	call	0x1082e	; 0x1082e <__eerd_byte_m2560>
// ~~~~~~~~~~~~~~~
void
MemCheckInit(void)
{
//	TD_Mem = Timer32SysAlloc(1);
	if (!erb(&MemCheck_stor.ReprogFlg)) {
    ebfe:	81 11       	cpse	r24, r1
    ec00:	08 95       	ret
		eeprom_write_word(&MemCheck_stor.CRC_Flash_stor, CRC_Flash_calc());
    ec02:	0e 94 9d 1a 	call	0x353a	; 0x353a <CRC_Flash_calc>
    ec06:	bc 01       	movw	r22, r24
    ec08:	88 e9       	ldi	r24, 0x98	; 152
    ec0a:	91 e0       	ldi	r25, 0x01	; 1
    ec0c:	0e 94 4b 84 	call	0x10896	; 0x10896 <__eewr_word_m2560>
		eeprom_write_word(&MemCheck_stor.CRC_EEPROM_stor, CRC_EEPROM_calc());
    ec10:	0e 94 b7 1a 	call	0x356e	; 0x356e <CRC_EEPROM_calc>
    ec14:	bc 01       	movw	r22, r24
    ec16:	8a e9       	ldi	r24, 0x9A	; 154
    ec18:	91 e0       	ldi	r25, 0x01	; 1
    ec1a:	0e 94 4b 84 	call	0x10896	; 0x10896 <__eewr_word_m2560>
		eeprom_write_byte(&MemCheck_stor.ReprogFlg, 1);
    ec1e:	8c e9       	ldi	r24, 0x9C	; 156
    ec20:	91 e0       	ldi	r25, 0x01	; 1
    ec22:	61 e0       	ldi	r22, 0x01	; 1
    ec24:	0e 94 35 84 	call	0x1086a	; 0x1086a <__eewr_byte_m2560>
    ec28:	08 95       	ret

0000ec2a <main>:
}

// ~~~~~~~
int
main(void)
{
    ec2a:	cf 93       	push	r28
    ec2c:	df 93       	push	r29
	TimeInit();
    ec2e:	0e 94 ad 75 	call	0xeb5a	; 0xeb5a <TimeInit>
	TimersInc();
    ec32:	0e 94 d4 4d 	call	0x9ba8	; 0x9ba8 <TimersInc>
	MemCheckInit();
    ec36:	0e 94 fb 75 	call	0xebf6	; 0xebf6 <MemCheckInit>
	LED_Init();
    ec3a:	0e 94 ca 26 	call	0x4d94	; 0x4d94 <LED_Init>

	LCD_Init();
    ec3e:	0e 94 5c 73 	call	0xe6b8	; 0xe6b8 <LCD_Init>

	KeypadInit();
    ec42:	0e 94 7b 3c 	call	0x78f6	; 0x78f6 <KeypadInit>
	MenuInit();
    ec46:	0e 94 c9 3d 	call	0x7b92	; 0x7b92 <MenuInit>
InterruInit(void)
{
	#ifdef PMIC
		PMIC.CTRL = (uint8_t)(~PMIC_RREN_bm &~PMIC_IVSEL_bm) |PMIC_HILVLEN_bm |PMIC_MEDLVLEN_bm |PMIC_LOLVLEN_bm;
	#endif
	sei();
    ec4a:	78 94       	sei
	InterruInit();
	DigitInit();
    ec4c:	0e 94 ec 3e 	call	0x7dd8	; 0x7dd8 <DI_Init>
    ec50:	0e 94 fb 3f 	call	0x7ff6	; 0x7ff6 <DO_Init>
	HSC_Init();

	AI_Init();
    ec54:	0e 94 10 40 	call	0x8020	; 0x8020 <AI_Init>

	SPI_Init();
    ec58:	0e 94 52 21 	call	0x42a4	; 0x42a4 <SPI_Init>

	PWM_Init();
    ec5c:	0e 94 1e 1f 	call	0x3e3c	; 0x3e3c <PWM_Init>
	TWI_Init();
    ec60:	0e 94 0d 24 	call	0x481a	; 0x481a <TWI_Init>
#ifdef QslRD
	SlaveRD_Init();
#endif

	do {
		TimersInc();
    ec64:	0e 94 d4 4d 	call	0x9ba8	; 0x9ba8 <TimersInc>
		wdt_reset();
    ec68:	a8 95       	wdr
		DigitIn();
    ec6a:	0e 94 e2 50 	call	0xa1c4	; 0xa1c4 <DigitIn>
		TWI_In();
    ec6e:	0e 94 52 74 	call	0xe8a4	; 0xe8a4 <TWI_In>
	StopTWI();
	TWI_Phase = PCF_START;
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t RTC_Ready(void){
	if(TWI_Phase == PCF_START) return 1;
    ec72:	80 91 c3 07 	lds	r24, 0x07C3
    ec76:	88 23       	and	r24, r24
    ec78:	11 f4       	brne	.+4      	; 0xec7e <main+0x54>
		if(RTC_Ready()) RTC_GetTrueTime();
    ec7a:	0e 94 a8 25 	call	0x4b50	; 0x4b50 <RTC_GetTrueTime>
		LCD_Sweep();
    ec7e:	0e 94 a3 62 	call	0xc546	; 0xc546 <LCD_Sweep>
	#ifdef TerIdx
	} while(ThermInit(AnalogIn()-TerIdx) || !RTC_Ready());
	#elif !defined ADC_Miss
		AnalogIn();
    ec82:	0e 94 21 40 	call	0x8042	; 0x8042 <AnalogIn>
	} while( (ADC_OK&&ThermInit(ADC_In())) || !RTC_Ready() );
    ec86:	80 91 2a 09 	lds	r24, 0x092A
    ec8a:	90 91 2b 09 	lds	r25, 0x092B
    ec8e:	89 2b       	or	r24, r25
    ec90:	69 f4       	brne	.+26     	; 0xecac <main+0x82>
    ec92:	80 91 b4 07 	lds	r24, 0x07B4
    ec96:	90 91 b5 07 	lds	r25, 0x07B5
    ec9a:	89 2b       	or	r24, r25
    ec9c:	39 f4       	brne	.+14     	; 0xecac <main+0x82>
    ec9e:	80 91 f8 06 	lds	r24, 0x06F8
    eca2:	90 91 f9 06 	lds	r25, 0x06F9
    eca6:	89 2b       	or	r24, r25
    eca8:	09 f4       	brne	.+2      	; 0xecac <main+0x82>
    ecaa:	72 c0       	rjmp	.+228    	; 0xed90 <main+0x166>
    ecac:	80 91 c3 07 	lds	r24, 0x07C3
    ecb0:	88 23       	and	r24, r24
    ecb2:	c1 f6       	brne	.-80     	; 0xec64 <main+0x3a>
	#else
	} while((AnalogIn()!=AI_Reg-1) || !RTC_Ready());
	#endif

	MemCheckMsg();
    ecb4:	0e 94 d2 4f 	call	0x9fa4	; 0x9fa4 <MemCheckMsg>
    ecb8:	e6 eb       	ldi	r30, 0xB6	; 182
    ecba:	f6 e0       	ldi	r31, 0x06	; 6
    ecbc:	81 e0       	ldi	r24, 0x01	; 1

void
ApplInit(void)
{
	for(int i=0; i<16; i++){
		Channels[i].number = i+1;
    ecbe:	80 83       	st	Z, r24
    ecc0:	34 96       	adiw	r30, 0x04	; 4
    ecc2:	8f 5f       	subi	r24, 0xFF	; 255
}

void
ApplInit(void)
{
	for(int i=0; i<16; i++){
    ecc4:	81 31       	cpi	r24, 0x11	; 17
    ecc6:	d9 f7       	brne	.-10     	; 0xecbe <main+0x94>

	ApplInit();

	USART_Init();
    ecc8:	0e 94 08 73 	call	0xe610	; 0xe610 <USART_Init>
	ScanCycleInit();
    eccc:	0e 94 62 1e 	call	0x3cc4	; 0x3cc4 <ScanCycleInit>
	if(TimerAllocError()) ShowMsg(&MsgErr41);
    ecd0:	0e 94 46 1e 	call	0x3c8c	; 0x3c8c <TimerAllocError>
    ecd4:	88 23       	and	r24, r24
    ecd6:	09 f0       	breq	.+2      	; 0xecda <main+0xb0>
    ecd8:	63 c0       	rjmp	.+198    	; 0xeda0 <main+0x176>

// ~~~~~~~~~~~~~~~~
void
Therm_ADC_Off(void)
{
	for (uint8_t i=0; i<TerReg; Temperature[i++]=ADC_Off_Mark);
    ecda:	c1 e0       	ldi	r28, 0x01	; 1
    ecdc:	d0 e8       	ldi	r29, 0x80	; 128
    ecde:	12 c0       	rjmp	.+36     	; 0xed04 <main+0xda>
			if(ADC_Work&&ADC_Phase==ADC_OFF) {
				Therm_ADC_Off();
				ShowMsg(&MsgErr21);
				ADC_Work = 0;
			}
			ThermChan(ADC_In());
    ece0:	0e 94 a9 1f 	call	0x3f52	; 0x3f52 <ADC_In>
    ece4:	0e 94 04 50 	call	0xa008	; 0xa008 <ThermChan>
		#endif
		ThermExt();
		TWI_In();
    ece8:	0e 94 52 74 	call	0xe8a4	; 0xe8a4 <TWI_In>

		USART_Cycle();
    ecec:	0e 94 7d 71 	call	0xe2fa	; 0xe2fa <USART_Cycle>
#ifdef QslRD
		SlaveRD();
#endif
		ApplCycle();
    ecf0:	0e 94 79 41 	call	0x82f2	; 0x82f2 <ApplCycle>
		
		LCD_Sweep();
    ecf4:	0e 94 a3 62 	call	0xc546	; 0xc546 <LCD_Sweep>
		DigitOut();
    ecf8:	0e 94 ac 3f 	call	0x7f58	; 0x7f58 <DigitOut>
		DAC_Out();
		PWM_Out();
    ecfc:	0e 94 3d 1f 	call	0x3e7a	; 0x3e7a <PWM_Out>
		#ifdef BACKLIGHT
			LCDBackLightControl();
    ed00:	0e 94 02 29 	call	0x5204	; 0x5204 <LCDBackLightControl>
	USART_Init();
	ScanCycleInit();
	if(TimerAllocError()) ShowMsg(&MsgErr41);

	for(;;) {	
		TimersInc();
    ed04:	0e 94 d4 4d 	call	0x9ba8	; 0x9ba8 <TimersInc>
		TimeCycle();
    ed08:	0e 94 c2 1e 	call	0x3d84	; 0x3d84 <TimeCycle>
// ~~~~~~~~~~~~~~
static void
KeypadSweep(void)
{
	static T_KeyAct KeyAct[] PROGMEM = KEYS;
	T_KeyAct KA = prp(KeyAct+KeypadIn());
    ed0c:	0e 94 8e 3c 	call	0x791c	; 0x791c <KeypadIn>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    ed10:	e8 2f       	mov	r30, r24
    ed12:	f0 e0       	ldi	r31, 0x00	; 0
    ed14:	ee 0f       	add	r30, r30
    ed16:	ff 1f       	adc	r31, r31
    ed18:	ea 5e       	subi	r30, 0xEA	; 234
    ed1a:	f4 4d       	sbci	r31, 0xD4	; 212
    ed1c:	85 91       	lpm	r24, Z+
    ed1e:	94 91       	lpm	r25, Z+
	if(KA){
    ed20:	00 97       	sbiw	r24, 0x00	; 0
    ed22:	31 f0       	breq	.+12     	; 0xed30 <main+0x106>
		KA();
    ed24:	fc 01       	movw	r30, r24
    ed26:	19 95       	eicall
		#ifdef BACKLIGHT
			if(BackLightMode == 1){
    ed28:	80 91 52 06 	lds	r24, 0x0652
    ed2c:	81 30       	cpi	r24, 0x01	; 1
    ed2e:	59 f1       	breq	.+86     	; 0xed86 <main+0x15c>
	for(;;) {	
		TimersInc();
		TimeCycle();

		KeypadSweep();
		DigitIn();
    ed30:	0e 94 e2 50 	call	0xa1c4	; 0xa1c4 <DigitIn>
		HSC_In();
		#ifdef TerIdx
			ThermChan(AnalogIn()-TerIdx);
		#else
			AnalogIn();
    ed34:	0e 94 21 40 	call	0x8042	; 0x8042 <AnalogIn>
		#endif
		#if !defined ADC_Miss && !defined TerIdx
			static uint8_t ADC_Work = 1;
			if(ADC_Work&&ADC_Phase==ADC_OFF) {
    ed38:	80 91 d8 02 	lds	r24, 0x02D8
    ed3c:	88 23       	and	r24, r24
    ed3e:	81 f2       	breq	.-96     	; 0xece0 <main+0xb6>
    ed40:	80 91 69 0b 	lds	r24, 0x0B69
    ed44:	84 30       	cpi	r24, 0x04	; 4
    ed46:	61 f6       	brne	.-104    	; 0xece0 <main+0xb6>
    ed48:	d0 93 46 06 	sts	0x0646, r29
    ed4c:	c0 93 45 06 	sts	0x0645, r28
    ed50:	d0 93 48 06 	sts	0x0648, r29
    ed54:	c0 93 47 06 	sts	0x0647, r28
    ed58:	d0 93 4a 06 	sts	0x064A, r29
    ed5c:	c0 93 49 06 	sts	0x0649, r28
    ed60:	d0 93 4c 06 	sts	0x064C, r29
    ed64:	c0 93 4b 06 	sts	0x064B, r28
    ed68:	d0 93 4e 06 	sts	0x064E, r29
    ed6c:	c0 93 4d 06 	sts	0x064D, r28
    ed70:	d0 93 50 06 	sts	0x0650, r29
    ed74:	c0 93 4f 06 	sts	0x064F, r28
				Therm_ADC_Off();
				ShowMsg(&MsgErr21);
    ed78:	8a e7       	ldi	r24, 0x7A	; 122
    ed7a:	98 e0       	ldi	r25, 0x08	; 8
    ed7c:	0e 94 b8 3d 	call	0x7b70	; 0x7b70 <ShowMsg>
				ADC_Work = 0;
    ed80:	10 92 d8 02 	sts	0x02D8, r1
    ed84:	ad cf       	rjmp	.-166    	; 0xece0 <main+0xb6>
	T_KeyAct KA = prp(KeyAct+KeypadIn());
	if(KA){
		KA();
		#ifdef BACKLIGHT
			if(BackLightMode == 1){
				LCDBackLightOn();
    ed86:	0e 94 e6 28 	call	0x51cc	; 0x51cc <LCDBackLightOn>
				LCDBackLightStartTimer();
    ed8a:	0e 94 0d 73 	call	0xe61a	; 0xe61a <LCDBackLightStartTimer>
    ed8e:	d0 cf       	rjmp	.-96     	; 0xed30 <main+0x106>
		LCD_Sweep();
	#ifdef TerIdx
	} while(ThermInit(AnalogIn()-TerIdx) || !RTC_Ready());
	#elif !defined ADC_Miss
		AnalogIn();
	} while( (ADC_OK&&ThermInit(ADC_In())) || !RTC_Ready() );
    ed90:	0e 94 a9 1f 	call	0x3f52	; 0x3f52 <ADC_In>
    ed94:	0e 94 a0 50 	call	0xa140	; 0xa140 <ThermInit>
    ed98:	88 23       	and	r24, r24
    ed9a:	09 f0       	breq	.+2      	; 0xed9e <main+0x174>
    ed9c:	63 cf       	rjmp	.-314    	; 0xec64 <main+0x3a>
    ed9e:	86 cf       	rjmp	.-244    	; 0xecac <main+0x82>

	ApplInit();

	USART_Init();
	ScanCycleInit();
	if(TimerAllocError()) ShowMsg(&MsgErr41);
    eda0:	8f e2       	ldi	r24, 0x2F	; 47
    eda2:	9a e1       	ldi	r25, 0x1A	; 26
    eda4:	0e 94 b8 3d 	call	0x7b70	; 0x7b70 <ShowMsg>
    eda8:	98 cf       	rjmp	.-208    	; 0xecda <main+0xb0>

0000edaa <EEMEMBackUpOk>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    edaa:	80 e0       	ldi	r24, 0x00	; 0
    edac:	90 e0       	ldi	r25, 0x00	; 0
    edae:	0e 94 17 84 	call	0x1082e	; 0x1082e <__eerd_byte_m2560>
	uint8_t Month;
	uint8_t Year;
}DateBackUp EEMEM = {0xFF,0xFF,0xFF};

uint8_t EEMEMBackUpOk(void){
	if( (erb(&DateBackUp.Day)==0xFF) || (erb(&DateBackUp.Month)==0xFF) || (erb(&DateBackUp.Year)== 0xFF) ) return 0;
    edb2:	8f 3f       	cpi	r24, 0xFF	; 255
    edb4:	81 f0       	breq	.+32     	; 0xedd6 <EEMEMBackUpOk+0x2c>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    edb6:	81 e0       	ldi	r24, 0x01	; 1
    edb8:	90 e0       	ldi	r25, 0x00	; 0
    edba:	0e 94 17 84 	call	0x1082e	; 0x1082e <__eerd_byte_m2560>
	uint8_t Month;
	uint8_t Year;
}DateBackUp EEMEM = {0xFF,0xFF,0xFF};

uint8_t EEMEMBackUpOk(void){
	if( (erb(&DateBackUp.Day)==0xFF) || (erb(&DateBackUp.Month)==0xFF) || (erb(&DateBackUp.Year)== 0xFF) ) return 0;
    edbe:	8f 3f       	cpi	r24, 0xFF	; 255
    edc0:	51 f0       	breq	.+20     	; 0xedd6 <EEMEMBackUpOk+0x2c>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    edc2:	82 e0       	ldi	r24, 0x02	; 2
    edc4:	90 e0       	ldi	r25, 0x00	; 0
    edc6:	0e 94 17 84 	call	0x1082e	; 0x1082e <__eerd_byte_m2560>
    edca:	90 e0       	ldi	r25, 0x00	; 0
    edcc:	8f 3f       	cpi	r24, 0xFF	; 255
    edce:	21 f0       	breq	.+8      	; 0xedd8 <EEMEMBackUpOk+0x2e>
    edd0:	91 e0       	ldi	r25, 0x01	; 1
}DateBackUp EEMEM = {0xFF,0xFF,0xFF};

uint8_t EEMEMBackUpOk(void){
	if( (erb(&DateBackUp.Day)==0xFF) || (erb(&DateBackUp.Month)==0xFF) || (erb(&DateBackUp.Year)== 0xFF) ) return 0;
	else return 1;
}
    edd2:	89 2f       	mov	r24, r25
    edd4:	08 95       	ret
	uint8_t Month;
	uint8_t Year;
}DateBackUp EEMEM = {0xFF,0xFF,0xFF};

uint8_t EEMEMBackUpOk(void){
	if( (erb(&DateBackUp.Day)==0xFF) || (erb(&DateBackUp.Month)==0xFF) || (erb(&DateBackUp.Year)== 0xFF) ) return 0;
    edd6:	90 e0       	ldi	r25, 0x00	; 0
	else return 1;
}
    edd8:	89 2f       	mov	r24, r25
    edda:	08 95       	ret

0000eddc <Menu_BackUp_Enter>:
			NULL, NULL, NULL, Menu_ConfirmationRest_Enter, NULL, NULL, NULL};
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	//		  
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	uint8_t Menu_BackUp_Enter(){
		switch(CurrLine){
    eddc:	80 91 c9 07 	lds	r24, 0x07C9
    ede0:	82 30       	cpi	r24, 0x02	; 2
    ede2:	11 f0       	breq	.+4      	; 0xede8 <Menu_BackUp_Enter+0xc>
			}
			NextPage = &Menu_ConfirmationRestore;
			break;
		}
		return StandartKey;
	}
    ede4:	80 e0       	ldi	r24, 0x00	; 0
    ede6:	08 95       	ret
	//		  
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	uint8_t Menu_BackUp_Enter(){
		switch(CurrLine){
		case 2:
			if(!EEMEMBackUpOk()){
    ede8:	0e 94 d5 76 	call	0xedaa	; 0xedaa <EEMEMBackUpOk>
    edec:	88 23       	and	r24, r24
    edee:	59 f4       	brne	.+22     	; 0xee06 <Menu_BackUp_Enter+0x2a>
				//   EEPROM,   BackUp- -  
				if(MemFail & 1<<MemFail_EEPROM){
    edf0:	80 91 16 09 	lds	r24, 0x0916
    edf4:	81 ff       	sbrs	r24, 1
    edf6:	0f c0       	rjmp	.+30     	; 0xee16 <Menu_BackUp_Enter+0x3a>
					MemFailReset();
    edf8:	0e 94 44 4d 	call	0x9a88	; 0x9a88 <MemFailReset>
					ShowMsg(&Msg_EEWarning);
    edfc:	8b e3       	ldi	r24, 0x3B	; 59
    edfe:	93 e1       	ldi	r25, 0x13	; 19
    ee00:	0e 94 b8 3d 	call	0x7b70	; 0x7b70 <ShowMsg>
    ee04:	ef cf       	rjmp	.-34     	; 0xede4 <Menu_BackUp_Enter+0x8>
				}
				else ShowMsg(&Msg_NoBackUp);
				break;
			}
			NextPage = &Menu_ConfirmationRestore;
    ee06:	8b ee       	ldi	r24, 0xEB	; 235
    ee08:	94 e1       	ldi	r25, 0x14	; 20
    ee0a:	90 93 da 05 	sts	0x05DA, r25
    ee0e:	80 93 d9 05 	sts	0x05D9, r24
			break;
		}
		return StandartKey;
	}
    ee12:	80 e0       	ldi	r24, 0x00	; 0
    ee14:	08 95       	ret
				//   EEPROM,   BackUp- -  
				if(MemFail & 1<<MemFail_EEPROM){
					MemFailReset();
					ShowMsg(&Msg_EEWarning);
				}
				else ShowMsg(&Msg_NoBackUp);
    ee16:	8d e9       	ldi	r24, 0x9D	; 157
    ee18:	93 e1       	ldi	r25, 0x13	; 19
    ee1a:	0e 94 b8 3d 	call	0x7b70	; 0x7b70 <ShowMsg>
    ee1e:	e2 cf       	rjmp	.-60     	; 0xede4 <Menu_BackUp_Enter+0x8>

0000ee20 <vfprintf>:
    ee20:	2f 92       	push	r2
    ee22:	3f 92       	push	r3
    ee24:	4f 92       	push	r4
    ee26:	5f 92       	push	r5
    ee28:	6f 92       	push	r6
    ee2a:	7f 92       	push	r7
    ee2c:	8f 92       	push	r8
    ee2e:	9f 92       	push	r9
    ee30:	af 92       	push	r10
    ee32:	bf 92       	push	r11
    ee34:	cf 92       	push	r12
    ee36:	df 92       	push	r13
    ee38:	ef 92       	push	r14
    ee3a:	ff 92       	push	r15
    ee3c:	0f 93       	push	r16
    ee3e:	1f 93       	push	r17
    ee40:	df 93       	push	r29
    ee42:	cf 93       	push	r28
    ee44:	cd b7       	in	r28, 0x3d	; 61
    ee46:	de b7       	in	r29, 0x3e	; 62
    ee48:	61 97       	sbiw	r28, 0x11	; 17
    ee4a:	0f b6       	in	r0, 0x3f	; 63
    ee4c:	f8 94       	cli
    ee4e:	de bf       	out	0x3e, r29	; 62
    ee50:	0f be       	out	0x3f, r0	; 63
    ee52:	cd bf       	out	0x3d, r28	; 61
    ee54:	3c 01       	movw	r6, r24
    ee56:	7f 87       	std	Y+15, r23	; 0x0f
    ee58:	6e 87       	std	Y+14, r22	; 0x0e
    ee5a:	6a 01       	movw	r12, r20
    ee5c:	fc 01       	movw	r30, r24
    ee5e:	17 82       	std	Z+7, r1	; 0x07
    ee60:	16 82       	std	Z+6, r1	; 0x06
    ee62:	83 81       	ldd	r24, Z+3	; 0x03
    ee64:	81 fd       	sbrc	r24, 1
    ee66:	03 c0       	rjmp	.+6      	; 0xee6e <vfprintf+0x4e>
    ee68:	6f ef       	ldi	r22, 0xFF	; 255
    ee6a:	7f ef       	ldi	r23, 0xFF	; 255
    ee6c:	6f c3       	rjmp	.+1758   	; 0xf54c <vfprintf+0x72c>
    ee6e:	9e 01       	movw	r18, r28
    ee70:	2f 5f       	subi	r18, 0xFF	; 255
    ee72:	3f 4f       	sbci	r19, 0xFF	; 255
    ee74:	39 8b       	std	Y+17, r19	; 0x11
    ee76:	28 8b       	std	Y+16, r18	; 0x10
    ee78:	f3 01       	movw	r30, r6
    ee7a:	23 81       	ldd	r18, Z+3	; 0x03
    ee7c:	ee 85       	ldd	r30, Y+14	; 0x0e
    ee7e:	ff 85       	ldd	r31, Y+15	; 0x0f
    ee80:	23 fd       	sbrc	r18, 3
    ee82:	85 91       	lpm	r24, Z+
    ee84:	23 ff       	sbrs	r18, 3
    ee86:	81 91       	ld	r24, Z+
    ee88:	ff 87       	std	Y+15, r31	; 0x0f
    ee8a:	ee 87       	std	Y+14, r30	; 0x0e
    ee8c:	88 23       	and	r24, r24
    ee8e:	09 f4       	brne	.+2      	; 0xee92 <vfprintf+0x72>
    ee90:	5a c3       	rjmp	.+1716   	; 0xf546 <vfprintf+0x726>
    ee92:	85 32       	cpi	r24, 0x25	; 37
    ee94:	51 f4       	brne	.+20     	; 0xeeaa <vfprintf+0x8a>
    ee96:	ee 85       	ldd	r30, Y+14	; 0x0e
    ee98:	ff 85       	ldd	r31, Y+15	; 0x0f
    ee9a:	23 fd       	sbrc	r18, 3
    ee9c:	85 91       	lpm	r24, Z+
    ee9e:	23 ff       	sbrs	r18, 3
    eea0:	81 91       	ld	r24, Z+
    eea2:	ff 87       	std	Y+15, r31	; 0x0f
    eea4:	ee 87       	std	Y+14, r30	; 0x0e
    eea6:	85 32       	cpi	r24, 0x25	; 37
    eea8:	29 f4       	brne	.+10     	; 0xeeb4 <vfprintf+0x94>
    eeaa:	90 e0       	ldi	r25, 0x00	; 0
    eeac:	b3 01       	movw	r22, r6
    eeae:	0e 94 bd 81 	call	0x1037a	; 0x1037a <fputc>
    eeb2:	e2 cf       	rjmp	.-60     	; 0xee78 <vfprintf+0x58>
    eeb4:	98 2f       	mov	r25, r24
    eeb6:	10 e0       	ldi	r17, 0x00	; 0
    eeb8:	88 24       	eor	r8, r8
    eeba:	99 24       	eor	r9, r9
    eebc:	10 32       	cpi	r17, 0x20	; 32
    eebe:	b0 f4       	brcc	.+44     	; 0xeeec <vfprintf+0xcc>
    eec0:	9b 32       	cpi	r25, 0x2B	; 43
    eec2:	69 f0       	breq	.+26     	; 0xeede <vfprintf+0xbe>
    eec4:	9c 32       	cpi	r25, 0x2C	; 44
    eec6:	28 f4       	brcc	.+10     	; 0xeed2 <vfprintf+0xb2>
    eec8:	90 32       	cpi	r25, 0x20	; 32
    eeca:	51 f0       	breq	.+20     	; 0xeee0 <vfprintf+0xc0>
    eecc:	93 32       	cpi	r25, 0x23	; 35
    eece:	71 f4       	brne	.+28     	; 0xeeec <vfprintf+0xcc>
    eed0:	0b c0       	rjmp	.+22     	; 0xeee8 <vfprintf+0xc8>
    eed2:	9d 32       	cpi	r25, 0x2D	; 45
    eed4:	39 f0       	breq	.+14     	; 0xeee4 <vfprintf+0xc4>
    eed6:	90 33       	cpi	r25, 0x30	; 48
    eed8:	49 f4       	brne	.+18     	; 0xeeec <vfprintf+0xcc>
    eeda:	11 60       	ori	r17, 0x01	; 1
    eedc:	28 c0       	rjmp	.+80     	; 0xef2e <vfprintf+0x10e>
    eede:	12 60       	ori	r17, 0x02	; 2
    eee0:	14 60       	ori	r17, 0x04	; 4
    eee2:	25 c0       	rjmp	.+74     	; 0xef2e <vfprintf+0x10e>
    eee4:	18 60       	ori	r17, 0x08	; 8
    eee6:	23 c0       	rjmp	.+70     	; 0xef2e <vfprintf+0x10e>
    eee8:	10 61       	ori	r17, 0x10	; 16
    eeea:	21 c0       	rjmp	.+66     	; 0xef2e <vfprintf+0x10e>
    eeec:	17 fd       	sbrc	r17, 7
    eeee:	2a c0       	rjmp	.+84     	; 0xef44 <vfprintf+0x124>
    eef0:	89 2f       	mov	r24, r25
    eef2:	80 53       	subi	r24, 0x30	; 48
    eef4:	8a 30       	cpi	r24, 0x0A	; 10
    eef6:	78 f4       	brcc	.+30     	; 0xef16 <vfprintf+0xf6>
    eef8:	16 ff       	sbrs	r17, 6
    eefa:	06 c0       	rjmp	.+12     	; 0xef08 <vfprintf+0xe8>
    eefc:	fa e0       	ldi	r31, 0x0A	; 10
    eefe:	9f 9e       	mul	r9, r31
    ef00:	90 2c       	mov	r9, r0
    ef02:	11 24       	eor	r1, r1
    ef04:	98 0e       	add	r9, r24
    ef06:	13 c0       	rjmp	.+38     	; 0xef2e <vfprintf+0x10e>
    ef08:	3a e0       	ldi	r19, 0x0A	; 10
    ef0a:	83 9e       	mul	r8, r19
    ef0c:	80 2c       	mov	r8, r0
    ef0e:	11 24       	eor	r1, r1
    ef10:	88 0e       	add	r8, r24
    ef12:	10 62       	ori	r17, 0x20	; 32
    ef14:	0c c0       	rjmp	.+24     	; 0xef2e <vfprintf+0x10e>
    ef16:	9e 32       	cpi	r25, 0x2E	; 46
    ef18:	21 f4       	brne	.+8      	; 0xef22 <vfprintf+0x102>
    ef1a:	16 fd       	sbrc	r17, 6
    ef1c:	14 c3       	rjmp	.+1576   	; 0xf546 <vfprintf+0x726>
    ef1e:	10 64       	ori	r17, 0x40	; 64
    ef20:	06 c0       	rjmp	.+12     	; 0xef2e <vfprintf+0x10e>
    ef22:	9c 36       	cpi	r25, 0x6C	; 108
    ef24:	11 f4       	brne	.+4      	; 0xef2a <vfprintf+0x10a>
    ef26:	10 68       	ori	r17, 0x80	; 128
    ef28:	02 c0       	rjmp	.+4      	; 0xef2e <vfprintf+0x10e>
    ef2a:	98 36       	cpi	r25, 0x68	; 104
    ef2c:	59 f4       	brne	.+22     	; 0xef44 <vfprintf+0x124>
    ef2e:	ee 85       	ldd	r30, Y+14	; 0x0e
    ef30:	ff 85       	ldd	r31, Y+15	; 0x0f
    ef32:	23 fd       	sbrc	r18, 3
    ef34:	95 91       	lpm	r25, Z+
    ef36:	23 ff       	sbrs	r18, 3
    ef38:	91 91       	ld	r25, Z+
    ef3a:	ff 87       	std	Y+15, r31	; 0x0f
    ef3c:	ee 87       	std	Y+14, r30	; 0x0e
    ef3e:	99 23       	and	r25, r25
    ef40:	09 f0       	breq	.+2      	; 0xef44 <vfprintf+0x124>
    ef42:	bc cf       	rjmp	.-136    	; 0xeebc <vfprintf+0x9c>
    ef44:	89 2f       	mov	r24, r25
    ef46:	85 54       	subi	r24, 0x45	; 69
    ef48:	83 30       	cpi	r24, 0x03	; 3
    ef4a:	20 f4       	brcc	.+8      	; 0xef54 <vfprintf+0x134>
    ef4c:	81 2f       	mov	r24, r17
    ef4e:	80 61       	ori	r24, 0x10	; 16
    ef50:	90 5e       	subi	r25, 0xE0	; 224
    ef52:	07 c0       	rjmp	.+14     	; 0xef62 <vfprintf+0x142>
    ef54:	89 2f       	mov	r24, r25
    ef56:	85 56       	subi	r24, 0x65	; 101
    ef58:	83 30       	cpi	r24, 0x03	; 3
    ef5a:	08 f0       	brcs	.+2      	; 0xef5e <vfprintf+0x13e>
    ef5c:	9f c1       	rjmp	.+830    	; 0xf29c <vfprintf+0x47c>
    ef5e:	81 2f       	mov	r24, r17
    ef60:	8f 7e       	andi	r24, 0xEF	; 239
    ef62:	86 fd       	sbrc	r24, 6
    ef64:	02 c0       	rjmp	.+4      	; 0xef6a <vfprintf+0x14a>
    ef66:	76 e0       	ldi	r23, 0x06	; 6
    ef68:	97 2e       	mov	r9, r23
    ef6a:	6f e3       	ldi	r22, 0x3F	; 63
    ef6c:	f6 2e       	mov	r15, r22
    ef6e:	f8 22       	and	r15, r24
    ef70:	95 36       	cpi	r25, 0x65	; 101
    ef72:	19 f4       	brne	.+6      	; 0xef7a <vfprintf+0x15a>
    ef74:	f0 e4       	ldi	r31, 0x40	; 64
    ef76:	ff 2a       	or	r15, r31
    ef78:	07 c0       	rjmp	.+14     	; 0xef88 <vfprintf+0x168>
    ef7a:	96 36       	cpi	r25, 0x66	; 102
    ef7c:	19 f4       	brne	.+6      	; 0xef84 <vfprintf+0x164>
    ef7e:	20 e8       	ldi	r18, 0x80	; 128
    ef80:	f2 2a       	or	r15, r18
    ef82:	02 c0       	rjmp	.+4      	; 0xef88 <vfprintf+0x168>
    ef84:	91 10       	cpse	r9, r1
    ef86:	9a 94       	dec	r9
    ef88:	f7 fe       	sbrs	r15, 7
    ef8a:	0a c0       	rjmp	.+20     	; 0xefa0 <vfprintf+0x180>
    ef8c:	3b e3       	ldi	r19, 0x3B	; 59
    ef8e:	39 15       	cp	r19, r9
    ef90:	18 f4       	brcc	.+6      	; 0xef98 <vfprintf+0x178>
    ef92:	5c e3       	ldi	r21, 0x3C	; 60
    ef94:	b5 2e       	mov	r11, r21
    ef96:	02 c0       	rjmp	.+4      	; 0xef9c <vfprintf+0x17c>
    ef98:	b9 2c       	mov	r11, r9
    ef9a:	b3 94       	inc	r11
    ef9c:	27 e0       	ldi	r18, 0x07	; 7
    ef9e:	09 c0       	rjmp	.+18     	; 0xefb2 <vfprintf+0x192>
    efa0:	47 e0       	ldi	r20, 0x07	; 7
    efa2:	49 15       	cp	r20, r9
    efa4:	20 f4       	brcc	.+8      	; 0xefae <vfprintf+0x18e>
    efa6:	bb 24       	eor	r11, r11
    efa8:	47 e0       	ldi	r20, 0x07	; 7
    efaa:	94 2e       	mov	r9, r20
    efac:	f7 cf       	rjmp	.-18     	; 0xef9c <vfprintf+0x17c>
    efae:	29 2d       	mov	r18, r9
    efb0:	bb 24       	eor	r11, r11
    efb2:	c6 01       	movw	r24, r12
    efb4:	04 96       	adiw	r24, 0x04	; 4
    efb6:	9d 87       	std	Y+13, r25	; 0x0d
    efb8:	8c 87       	std	Y+12, r24	; 0x0c
    efba:	f6 01       	movw	r30, r12
    efbc:	60 81       	ld	r22, Z
    efbe:	71 81       	ldd	r23, Z+1	; 0x01
    efc0:	82 81       	ldd	r24, Z+2	; 0x02
    efc2:	93 81       	ldd	r25, Z+3	; 0x03
    efc4:	ae 01       	movw	r20, r28
    efc6:	4f 5f       	subi	r20, 0xFF	; 255
    efc8:	5f 4f       	sbci	r21, 0xFF	; 255
    efca:	0b 2d       	mov	r16, r11
    efcc:	0e 94 fa 7f 	call	0xfff4	; 0xfff4 <__ftoa_engine>
    efd0:	6c 01       	movw	r12, r24
    efd2:	09 81       	ldd	r16, Y+1	; 0x01
    efd4:	20 2e       	mov	r2, r16
    efd6:	33 24       	eor	r3, r3
    efd8:	00 ff       	sbrs	r16, 0
    efda:	04 c0       	rjmp	.+8      	; 0xefe4 <vfprintf+0x1c4>
    efdc:	03 fd       	sbrc	r16, 3
    efde:	02 c0       	rjmp	.+4      	; 0xefe4 <vfprintf+0x1c4>
    efe0:	1d e2       	ldi	r17, 0x2D	; 45
    efe2:	09 c0       	rjmp	.+18     	; 0xeff6 <vfprintf+0x1d6>
    efe4:	f1 fe       	sbrs	r15, 1
    efe6:	02 c0       	rjmp	.+4      	; 0xefec <vfprintf+0x1cc>
    efe8:	1b e2       	ldi	r17, 0x2B	; 43
    efea:	05 c0       	rjmp	.+10     	; 0xeff6 <vfprintf+0x1d6>
    efec:	f2 fc       	sbrc	r15, 2
    efee:	02 c0       	rjmp	.+4      	; 0xeff4 <vfprintf+0x1d4>
    eff0:	10 e0       	ldi	r17, 0x00	; 0
    eff2:	01 c0       	rjmp	.+2      	; 0xeff6 <vfprintf+0x1d6>
    eff4:	10 e2       	ldi	r17, 0x20	; 32
    eff6:	c1 01       	movw	r24, r2
    eff8:	8c 70       	andi	r24, 0x0C	; 12
    effa:	90 70       	andi	r25, 0x00	; 0
    effc:	89 2b       	or	r24, r25
    effe:	b9 f1       	breq	.+110    	; 0xf06e <vfprintf+0x24e>
    f000:	11 23       	and	r17, r17
    f002:	11 f4       	brne	.+4      	; 0xf008 <vfprintf+0x1e8>
    f004:	83 e0       	ldi	r24, 0x03	; 3
    f006:	01 c0       	rjmp	.+2      	; 0xf00a <vfprintf+0x1ea>
    f008:	84 e0       	ldi	r24, 0x04	; 4
    f00a:	88 15       	cp	r24, r8
    f00c:	10 f0       	brcs	.+4      	; 0xf012 <vfprintf+0x1f2>
    f00e:	88 24       	eor	r8, r8
    f010:	0a c0       	rjmp	.+20     	; 0xf026 <vfprintf+0x206>
    f012:	88 1a       	sub	r8, r24
    f014:	f3 fc       	sbrc	r15, 3
    f016:	07 c0       	rjmp	.+14     	; 0xf026 <vfprintf+0x206>
    f018:	80 e2       	ldi	r24, 0x20	; 32
    f01a:	90 e0       	ldi	r25, 0x00	; 0
    f01c:	b3 01       	movw	r22, r6
    f01e:	0e 94 bd 81 	call	0x1037a	; 0x1037a <fputc>
    f022:	8a 94       	dec	r8
    f024:	c9 f7       	brne	.-14     	; 0xf018 <vfprintf+0x1f8>
    f026:	11 23       	and	r17, r17
    f028:	29 f0       	breq	.+10     	; 0xf034 <vfprintf+0x214>
    f02a:	81 2f       	mov	r24, r17
    f02c:	90 e0       	ldi	r25, 0x00	; 0
    f02e:	b3 01       	movw	r22, r6
    f030:	0e 94 bd 81 	call	0x1037a	; 0x1037a <fputc>
    f034:	23 fe       	sbrs	r2, 3
    f036:	03 c0       	rjmp	.+6      	; 0xf03e <vfprintf+0x21e>
    f038:	0e ec       	ldi	r16, 0xCE	; 206
    f03a:	12 e0       	ldi	r17, 0x02	; 2
    f03c:	0e c0       	rjmp	.+28     	; 0xf05a <vfprintf+0x23a>
    f03e:	02 ed       	ldi	r16, 0xD2	; 210
    f040:	12 e0       	ldi	r17, 0x02	; 2
    f042:	0b c0       	rjmp	.+22     	; 0xf05a <vfprintf+0x23a>
    f044:	e1 14       	cp	r14, r1
    f046:	f1 04       	cpc	r15, r1
    f048:	09 f0       	breq	.+2      	; 0xf04c <vfprintf+0x22c>
    f04a:	80 52       	subi	r24, 0x20	; 32
    f04c:	90 e0       	ldi	r25, 0x00	; 0
    f04e:	b3 01       	movw	r22, r6
    f050:	0e 94 bd 81 	call	0x1037a	; 0x1037a <fputc>
    f054:	0f 5f       	subi	r16, 0xFF	; 255
    f056:	1f 4f       	sbci	r17, 0xFF	; 255
    f058:	05 c0       	rjmp	.+10     	; 0xf064 <vfprintf+0x244>
    f05a:	ef 2c       	mov	r14, r15
    f05c:	ff 24       	eor	r15, r15
    f05e:	f0 e1       	ldi	r31, 0x10	; 16
    f060:	ef 22       	and	r14, r31
    f062:	ff 24       	eor	r15, r15
    f064:	f8 01       	movw	r30, r16
    f066:	84 91       	lpm	r24, Z+
    f068:	88 23       	and	r24, r24
    f06a:	61 f7       	brne	.-40     	; 0xf044 <vfprintf+0x224>
    f06c:	14 c1       	rjmp	.+552    	; 0xf296 <vfprintf+0x476>
    f06e:	f7 fe       	sbrs	r15, 7
    f070:	12 c0       	rjmp	.+36     	; 0xf096 <vfprintf+0x276>
    f072:	bc 0c       	add	r11, r12
    f074:	24 fe       	sbrs	r2, 4
    f076:	04 c0       	rjmp	.+8      	; 0xf080 <vfprintf+0x260>
    f078:	8a 81       	ldd	r24, Y+2	; 0x02
    f07a:	81 33       	cpi	r24, 0x31	; 49
    f07c:	09 f4       	brne	.+2      	; 0xf080 <vfprintf+0x260>
    f07e:	ba 94       	dec	r11
    f080:	1b 14       	cp	r1, r11
    f082:	1c f0       	brlt	.+6      	; 0xf08a <vfprintf+0x26a>
    f084:	bb 24       	eor	r11, r11
    f086:	b3 94       	inc	r11
    f088:	2d c0       	rjmp	.+90     	; 0xf0e4 <vfprintf+0x2c4>
    f08a:	f8 e0       	ldi	r31, 0x08	; 8
    f08c:	fb 15       	cp	r31, r11
    f08e:	50 f5       	brcc	.+84     	; 0xf0e4 <vfprintf+0x2c4>
    f090:	38 e0       	ldi	r19, 0x08	; 8
    f092:	b3 2e       	mov	r11, r19
    f094:	27 c0       	rjmp	.+78     	; 0xf0e4 <vfprintf+0x2c4>
    f096:	f6 fc       	sbrc	r15, 6
    f098:	25 c0       	rjmp	.+74     	; 0xf0e4 <vfprintf+0x2c4>
    f09a:	89 2d       	mov	r24, r9
    f09c:	90 e0       	ldi	r25, 0x00	; 0
    f09e:	8c 15       	cp	r24, r12
    f0a0:	9d 05       	cpc	r25, r13
    f0a2:	4c f0       	brlt	.+18     	; 0xf0b6 <vfprintf+0x296>
    f0a4:	2c ef       	ldi	r18, 0xFC	; 252
    f0a6:	c2 16       	cp	r12, r18
    f0a8:	2f ef       	ldi	r18, 0xFF	; 255
    f0aa:	d2 06       	cpc	r13, r18
    f0ac:	24 f0       	brlt	.+8      	; 0xf0b6 <vfprintf+0x296>
    f0ae:	30 e8       	ldi	r19, 0x80	; 128
    f0b0:	f3 2a       	or	r15, r19
    f0b2:	01 c0       	rjmp	.+2      	; 0xf0b6 <vfprintf+0x296>
    f0b4:	9a 94       	dec	r9
    f0b6:	99 20       	and	r9, r9
    f0b8:	49 f0       	breq	.+18     	; 0xf0cc <vfprintf+0x2ac>
    f0ba:	e2 e0       	ldi	r30, 0x02	; 2
    f0bc:	f0 e0       	ldi	r31, 0x00	; 0
    f0be:	ec 0f       	add	r30, r28
    f0c0:	fd 1f       	adc	r31, r29
    f0c2:	e9 0d       	add	r30, r9
    f0c4:	f1 1d       	adc	r31, r1
    f0c6:	80 81       	ld	r24, Z
    f0c8:	80 33       	cpi	r24, 0x30	; 48
    f0ca:	a1 f3       	breq	.-24     	; 0xf0b4 <vfprintf+0x294>
    f0cc:	f7 fe       	sbrs	r15, 7
    f0ce:	0a c0       	rjmp	.+20     	; 0xf0e4 <vfprintf+0x2c4>
    f0d0:	b9 2c       	mov	r11, r9
    f0d2:	b3 94       	inc	r11
    f0d4:	89 2d       	mov	r24, r9
    f0d6:	90 e0       	ldi	r25, 0x00	; 0
    f0d8:	c8 16       	cp	r12, r24
    f0da:	d9 06       	cpc	r13, r25
    f0dc:	14 f0       	brlt	.+4      	; 0xf0e2 <vfprintf+0x2c2>
    f0de:	99 24       	eor	r9, r9
    f0e0:	01 c0       	rjmp	.+2      	; 0xf0e4 <vfprintf+0x2c4>
    f0e2:	9c 18       	sub	r9, r12
    f0e4:	f7 fc       	sbrc	r15, 7
    f0e6:	03 c0       	rjmp	.+6      	; 0xf0ee <vfprintf+0x2ce>
    f0e8:	25 e0       	ldi	r18, 0x05	; 5
    f0ea:	30 e0       	ldi	r19, 0x00	; 0
    f0ec:	09 c0       	rjmp	.+18     	; 0xf100 <vfprintf+0x2e0>
    f0ee:	1c 14       	cp	r1, r12
    f0f0:	1d 04       	cpc	r1, r13
    f0f2:	1c f0       	brlt	.+6      	; 0xf0fa <vfprintf+0x2da>
    f0f4:	21 e0       	ldi	r18, 0x01	; 1
    f0f6:	30 e0       	ldi	r19, 0x00	; 0
    f0f8:	03 c0       	rjmp	.+6      	; 0xf100 <vfprintf+0x2e0>
    f0fa:	96 01       	movw	r18, r12
    f0fc:	2f 5f       	subi	r18, 0xFF	; 255
    f0fe:	3f 4f       	sbci	r19, 0xFF	; 255
    f100:	11 23       	and	r17, r17
    f102:	11 f0       	breq	.+4      	; 0xf108 <vfprintf+0x2e8>
    f104:	2f 5f       	subi	r18, 0xFF	; 255
    f106:	3f 4f       	sbci	r19, 0xFF	; 255
    f108:	99 20       	and	r9, r9
    f10a:	29 f0       	breq	.+10     	; 0xf116 <vfprintf+0x2f6>
    f10c:	89 2d       	mov	r24, r9
    f10e:	90 e0       	ldi	r25, 0x00	; 0
    f110:	01 96       	adiw	r24, 0x01	; 1
    f112:	28 0f       	add	r18, r24
    f114:	39 1f       	adc	r19, r25
    f116:	88 2d       	mov	r24, r8
    f118:	90 e0       	ldi	r25, 0x00	; 0
    f11a:	28 17       	cp	r18, r24
    f11c:	39 07       	cpc	r19, r25
    f11e:	14 f0       	brlt	.+4      	; 0xf124 <vfprintf+0x304>
    f120:	88 24       	eor	r8, r8
    f122:	01 c0       	rjmp	.+2      	; 0xf126 <vfprintf+0x306>
    f124:	82 1a       	sub	r8, r18
    f126:	4f 2c       	mov	r4, r15
    f128:	55 24       	eor	r5, r5
    f12a:	c2 01       	movw	r24, r4
    f12c:	89 70       	andi	r24, 0x09	; 9
    f12e:	90 70       	andi	r25, 0x00	; 0
    f130:	89 2b       	or	r24, r25
    f132:	39 f0       	breq	.+14     	; 0xf142 <vfprintf+0x322>
    f134:	08 c0       	rjmp	.+16     	; 0xf146 <vfprintf+0x326>
    f136:	80 e2       	ldi	r24, 0x20	; 32
    f138:	90 e0       	ldi	r25, 0x00	; 0
    f13a:	b3 01       	movw	r22, r6
    f13c:	0e 94 bd 81 	call	0x1037a	; 0x1037a <fputc>
    f140:	8a 94       	dec	r8
    f142:	88 20       	and	r8, r8
    f144:	c1 f7       	brne	.-16     	; 0xf136 <vfprintf+0x316>
    f146:	11 23       	and	r17, r17
    f148:	29 f0       	breq	.+10     	; 0xf154 <vfprintf+0x334>
    f14a:	81 2f       	mov	r24, r17
    f14c:	90 e0       	ldi	r25, 0x00	; 0
    f14e:	b3 01       	movw	r22, r6
    f150:	0e 94 bd 81 	call	0x1037a	; 0x1037a <fputc>
    f154:	43 fe       	sbrs	r4, 3
    f156:	07 c0       	rjmp	.+14     	; 0xf166 <vfprintf+0x346>
    f158:	08 c0       	rjmp	.+16     	; 0xf16a <vfprintf+0x34a>
    f15a:	80 e3       	ldi	r24, 0x30	; 48
    f15c:	90 e0       	ldi	r25, 0x00	; 0
    f15e:	b3 01       	movw	r22, r6
    f160:	0e 94 bd 81 	call	0x1037a	; 0x1037a <fputc>
    f164:	8a 94       	dec	r8
    f166:	88 20       	and	r8, r8
    f168:	c1 f7       	brne	.-16     	; 0xf15a <vfprintf+0x33a>
    f16a:	f7 fe       	sbrs	r15, 7
    f16c:	46 c0       	rjmp	.+140    	; 0xf1fa <vfprintf+0x3da>
    f16e:	86 01       	movw	r16, r12
    f170:	d7 fe       	sbrs	r13, 7
    f172:	02 c0       	rjmp	.+4      	; 0xf178 <vfprintf+0x358>
    f174:	00 e0       	ldi	r16, 0x00	; 0
    f176:	10 e0       	ldi	r17, 0x00	; 0
    f178:	76 01       	movw	r14, r12
    f17a:	08 94       	sec
    f17c:	e1 1c       	adc	r14, r1
    f17e:	f1 1c       	adc	r15, r1
    f180:	e0 1a       	sub	r14, r16
    f182:	f1 0a       	sbc	r15, r17
    f184:	41 e0       	ldi	r20, 0x01	; 1
    f186:	50 e0       	ldi	r21, 0x00	; 0
    f188:	4c 0f       	add	r20, r28
    f18a:	5d 1f       	adc	r21, r29
    f18c:	e4 0e       	add	r14, r20
    f18e:	f5 1e       	adc	r15, r21
    f190:	26 01       	movw	r4, r12
    f192:	4b 18       	sub	r4, r11
    f194:	51 08       	sbc	r5, r1
    f196:	89 2d       	mov	r24, r9
    f198:	90 e0       	ldi	r25, 0x00	; 0
    f19a:	aa 24       	eor	r10, r10
    f19c:	bb 24       	eor	r11, r11
    f19e:	a8 1a       	sub	r10, r24
    f1a0:	b9 0a       	sbc	r11, r25
    f1a2:	5f ef       	ldi	r21, 0xFF	; 255
    f1a4:	0f 3f       	cpi	r16, 0xFF	; 255
    f1a6:	15 07       	cpc	r17, r21
    f1a8:	29 f4       	brne	.+10     	; 0xf1b4 <vfprintf+0x394>
    f1aa:	8e e2       	ldi	r24, 0x2E	; 46
    f1ac:	90 e0       	ldi	r25, 0x00	; 0
    f1ae:	b3 01       	movw	r22, r6
    f1b0:	0e 94 bd 81 	call	0x1037a	; 0x1037a <fputc>
    f1b4:	c0 16       	cp	r12, r16
    f1b6:	d1 06       	cpc	r13, r17
    f1b8:	34 f0       	brlt	.+12     	; 0xf1c6 <vfprintf+0x3a6>
    f1ba:	40 16       	cp	r4, r16
    f1bc:	51 06       	cpc	r5, r17
    f1be:	1c f4       	brge	.+6      	; 0xf1c6 <vfprintf+0x3a6>
    f1c0:	f7 01       	movw	r30, r14
    f1c2:	80 81       	ld	r24, Z
    f1c4:	01 c0       	rjmp	.+2      	; 0xf1c8 <vfprintf+0x3a8>
    f1c6:	80 e3       	ldi	r24, 0x30	; 48
    f1c8:	01 50       	subi	r16, 0x01	; 1
    f1ca:	10 40       	sbci	r17, 0x00	; 0
    f1cc:	08 94       	sec
    f1ce:	e1 1c       	adc	r14, r1
    f1d0:	f1 1c       	adc	r15, r1
    f1d2:	0a 15       	cp	r16, r10
    f1d4:	1b 05       	cpc	r17, r11
    f1d6:	2c f0       	brlt	.+10     	; 0xf1e2 <vfprintf+0x3c2>
    f1d8:	90 e0       	ldi	r25, 0x00	; 0
    f1da:	b3 01       	movw	r22, r6
    f1dc:	0e 94 bd 81 	call	0x1037a	; 0x1037a <fputc>
    f1e0:	e0 cf       	rjmp	.-64     	; 0xf1a2 <vfprintf+0x382>
    f1e2:	0c 15       	cp	r16, r12
    f1e4:	1d 05       	cpc	r17, r13
    f1e6:	39 f4       	brne	.+14     	; 0xf1f6 <vfprintf+0x3d6>
    f1e8:	9a 81       	ldd	r25, Y+2	; 0x02
    f1ea:	96 33       	cpi	r25, 0x36	; 54
    f1ec:	18 f4       	brcc	.+6      	; 0xf1f4 <vfprintf+0x3d4>
    f1ee:	95 33       	cpi	r25, 0x35	; 53
    f1f0:	11 f4       	brne	.+4      	; 0xf1f6 <vfprintf+0x3d6>
    f1f2:	24 fe       	sbrs	r2, 4
    f1f4:	81 e3       	ldi	r24, 0x31	; 49
    f1f6:	90 e0       	ldi	r25, 0x00	; 0
    f1f8:	4b c0       	rjmp	.+150    	; 0xf290 <vfprintf+0x470>
    f1fa:	8a 81       	ldd	r24, Y+2	; 0x02
    f1fc:	81 33       	cpi	r24, 0x31	; 49
    f1fe:	09 f0       	breq	.+2      	; 0xf202 <vfprintf+0x3e2>
    f200:	0f 7e       	andi	r16, 0xEF	; 239
    f202:	90 e0       	ldi	r25, 0x00	; 0
    f204:	b3 01       	movw	r22, r6
    f206:	0e 94 bd 81 	call	0x1037a	; 0x1037a <fputc>
    f20a:	99 20       	and	r9, r9
    f20c:	a1 f0       	breq	.+40     	; 0xf236 <vfprintf+0x416>
    f20e:	8e e2       	ldi	r24, 0x2E	; 46
    f210:	90 e0       	ldi	r25, 0x00	; 0
    f212:	b3 01       	movw	r22, r6
    f214:	0e 94 bd 81 	call	0x1037a	; 0x1037a <fputc>
    f218:	12 e0       	ldi	r17, 0x02	; 2
    f21a:	e1 e0       	ldi	r30, 0x01	; 1
    f21c:	f0 e0       	ldi	r31, 0x00	; 0
    f21e:	ec 0f       	add	r30, r28
    f220:	fd 1f       	adc	r31, r29
    f222:	e1 0f       	add	r30, r17
    f224:	f1 1d       	adc	r31, r1
    f226:	1f 5f       	subi	r17, 0xFF	; 255
    f228:	80 81       	ld	r24, Z
    f22a:	90 e0       	ldi	r25, 0x00	; 0
    f22c:	b3 01       	movw	r22, r6
    f22e:	0e 94 bd 81 	call	0x1037a	; 0x1037a <fputc>
    f232:	9a 94       	dec	r9
    f234:	91 f7       	brne	.-28     	; 0xf21a <vfprintf+0x3fa>
    f236:	44 fc       	sbrc	r4, 4
    f238:	03 c0       	rjmp	.+6      	; 0xf240 <vfprintf+0x420>
    f23a:	85 e6       	ldi	r24, 0x65	; 101
    f23c:	90 e0       	ldi	r25, 0x00	; 0
    f23e:	02 c0       	rjmp	.+4      	; 0xf244 <vfprintf+0x424>
    f240:	85 e4       	ldi	r24, 0x45	; 69
    f242:	90 e0       	ldi	r25, 0x00	; 0
    f244:	b3 01       	movw	r22, r6
    f246:	0e 94 bd 81 	call	0x1037a	; 0x1037a <fputc>
    f24a:	d7 fc       	sbrc	r13, 7
    f24c:	05 c0       	rjmp	.+10     	; 0xf258 <vfprintf+0x438>
    f24e:	c1 14       	cp	r12, r1
    f250:	d1 04       	cpc	r13, r1
    f252:	41 f4       	brne	.+16     	; 0xf264 <vfprintf+0x444>
    f254:	04 ff       	sbrs	r16, 4
    f256:	06 c0       	rjmp	.+12     	; 0xf264 <vfprintf+0x444>
    f258:	d0 94       	com	r13
    f25a:	c1 94       	neg	r12
    f25c:	d1 08       	sbc	r13, r1
    f25e:	d3 94       	inc	r13
    f260:	8d e2       	ldi	r24, 0x2D	; 45
    f262:	01 c0       	rjmp	.+2      	; 0xf266 <vfprintf+0x446>
    f264:	8b e2       	ldi	r24, 0x2B	; 43
    f266:	90 e0       	ldi	r25, 0x00	; 0
    f268:	b3 01       	movw	r22, r6
    f26a:	0e 94 bd 81 	call	0x1037a	; 0x1037a <fputc>
    f26e:	80 e3       	ldi	r24, 0x30	; 48
    f270:	05 c0       	rjmp	.+10     	; 0xf27c <vfprintf+0x45c>
    f272:	8f 5f       	subi	r24, 0xFF	; 255
    f274:	26 ef       	ldi	r18, 0xF6	; 246
    f276:	3f ef       	ldi	r19, 0xFF	; 255
    f278:	c2 0e       	add	r12, r18
    f27a:	d3 1e       	adc	r13, r19
    f27c:	3a e0       	ldi	r19, 0x0A	; 10
    f27e:	c3 16       	cp	r12, r19
    f280:	d1 04       	cpc	r13, r1
    f282:	bc f7       	brge	.-18     	; 0xf272 <vfprintf+0x452>
    f284:	90 e0       	ldi	r25, 0x00	; 0
    f286:	b3 01       	movw	r22, r6
    f288:	0e 94 bd 81 	call	0x1037a	; 0x1037a <fputc>
    f28c:	c6 01       	movw	r24, r12
    f28e:	c0 96       	adiw	r24, 0x30	; 48
    f290:	b3 01       	movw	r22, r6
    f292:	0e 94 bd 81 	call	0x1037a	; 0x1037a <fputc>
    f296:	cc 84       	ldd	r12, Y+12	; 0x0c
    f298:	dd 84       	ldd	r13, Y+13	; 0x0d
    f29a:	52 c1       	rjmp	.+676    	; 0xf540 <vfprintf+0x720>
    f29c:	93 36       	cpi	r25, 0x63	; 99
    f29e:	31 f0       	breq	.+12     	; 0xf2ac <vfprintf+0x48c>
    f2a0:	93 37       	cpi	r25, 0x73	; 115
    f2a2:	99 f0       	breq	.+38     	; 0xf2ca <vfprintf+0x4aa>
    f2a4:	93 35       	cpi	r25, 0x53	; 83
    f2a6:	09 f0       	breq	.+2      	; 0xf2aa <vfprintf+0x48a>
    f2a8:	59 c0       	rjmp	.+178    	; 0xf35c <vfprintf+0x53c>
    f2aa:	23 c0       	rjmp	.+70     	; 0xf2f2 <vfprintf+0x4d2>
    f2ac:	f6 01       	movw	r30, r12
    f2ae:	80 81       	ld	r24, Z
    f2b0:	89 83       	std	Y+1, r24	; 0x01
    f2b2:	5e 01       	movw	r10, r28
    f2b4:	08 94       	sec
    f2b6:	a1 1c       	adc	r10, r1
    f2b8:	b1 1c       	adc	r11, r1
    f2ba:	22 e0       	ldi	r18, 0x02	; 2
    f2bc:	30 e0       	ldi	r19, 0x00	; 0
    f2be:	c2 0e       	add	r12, r18
    f2c0:	d3 1e       	adc	r13, r19
    f2c2:	21 e0       	ldi	r18, 0x01	; 1
    f2c4:	e2 2e       	mov	r14, r18
    f2c6:	f1 2c       	mov	r15, r1
    f2c8:	12 c0       	rjmp	.+36     	; 0xf2ee <vfprintf+0x4ce>
    f2ca:	f6 01       	movw	r30, r12
    f2cc:	a0 80       	ld	r10, Z
    f2ce:	b1 80       	ldd	r11, Z+1	; 0x01
    f2d0:	16 fd       	sbrc	r17, 6
    f2d2:	03 c0       	rjmp	.+6      	; 0xf2da <vfprintf+0x4ba>
    f2d4:	6f ef       	ldi	r22, 0xFF	; 255
    f2d6:	7f ef       	ldi	r23, 0xFF	; 255
    f2d8:	02 c0       	rjmp	.+4      	; 0xf2de <vfprintf+0x4be>
    f2da:	69 2d       	mov	r22, r9
    f2dc:	70 e0       	ldi	r23, 0x00	; 0
    f2de:	22 e0       	ldi	r18, 0x02	; 2
    f2e0:	30 e0       	ldi	r19, 0x00	; 0
    f2e2:	c2 0e       	add	r12, r18
    f2e4:	d3 1e       	adc	r13, r19
    f2e6:	c5 01       	movw	r24, r10
    f2e8:	0e 94 56 81 	call	0x102ac	; 0x102ac <strnlen>
    f2ec:	7c 01       	movw	r14, r24
    f2ee:	1f 77       	andi	r17, 0x7F	; 127
    f2f0:	13 c0       	rjmp	.+38     	; 0xf318 <vfprintf+0x4f8>
    f2f2:	f6 01       	movw	r30, r12
    f2f4:	a0 80       	ld	r10, Z
    f2f6:	b1 80       	ldd	r11, Z+1	; 0x01
    f2f8:	16 fd       	sbrc	r17, 6
    f2fa:	03 c0       	rjmp	.+6      	; 0xf302 <vfprintf+0x4e2>
    f2fc:	6f ef       	ldi	r22, 0xFF	; 255
    f2fe:	7f ef       	ldi	r23, 0xFF	; 255
    f300:	02 c0       	rjmp	.+4      	; 0xf306 <vfprintf+0x4e6>
    f302:	69 2d       	mov	r22, r9
    f304:	70 e0       	ldi	r23, 0x00	; 0
    f306:	22 e0       	ldi	r18, 0x02	; 2
    f308:	30 e0       	ldi	r19, 0x00	; 0
    f30a:	c2 0e       	add	r12, r18
    f30c:	d3 1e       	adc	r13, r19
    f30e:	c5 01       	movw	r24, r10
    f310:	0e 94 14 81 	call	0x10228	; 0x10228 <strnlen_P>
    f314:	7c 01       	movw	r14, r24
    f316:	10 68       	ori	r17, 0x80	; 128
    f318:	13 ff       	sbrs	r17, 3
    f31a:	07 c0       	rjmp	.+14     	; 0xf32a <vfprintf+0x50a>
    f31c:	1b c0       	rjmp	.+54     	; 0xf354 <vfprintf+0x534>
    f31e:	80 e2       	ldi	r24, 0x20	; 32
    f320:	90 e0       	ldi	r25, 0x00	; 0
    f322:	b3 01       	movw	r22, r6
    f324:	0e 94 bd 81 	call	0x1037a	; 0x1037a <fputc>
    f328:	8a 94       	dec	r8
    f32a:	88 2d       	mov	r24, r8
    f32c:	90 e0       	ldi	r25, 0x00	; 0
    f32e:	e8 16       	cp	r14, r24
    f330:	f9 06       	cpc	r15, r25
    f332:	a8 f3       	brcs	.-22     	; 0xf31e <vfprintf+0x4fe>
    f334:	0f c0       	rjmp	.+30     	; 0xf354 <vfprintf+0x534>
    f336:	f5 01       	movw	r30, r10
    f338:	17 fd       	sbrc	r17, 7
    f33a:	85 91       	lpm	r24, Z+
    f33c:	17 ff       	sbrs	r17, 7
    f33e:	81 91       	ld	r24, Z+
    f340:	5f 01       	movw	r10, r30
    f342:	90 e0       	ldi	r25, 0x00	; 0
    f344:	b3 01       	movw	r22, r6
    f346:	0e 94 bd 81 	call	0x1037a	; 0x1037a <fputc>
    f34a:	81 10       	cpse	r8, r1
    f34c:	8a 94       	dec	r8
    f34e:	08 94       	sec
    f350:	e1 08       	sbc	r14, r1
    f352:	f1 08       	sbc	r15, r1
    f354:	e1 14       	cp	r14, r1
    f356:	f1 04       	cpc	r15, r1
    f358:	71 f7       	brne	.-36     	; 0xf336 <vfprintf+0x516>
    f35a:	f2 c0       	rjmp	.+484    	; 0xf540 <vfprintf+0x720>
    f35c:	94 36       	cpi	r25, 0x64	; 100
    f35e:	11 f0       	breq	.+4      	; 0xf364 <vfprintf+0x544>
    f360:	99 36       	cpi	r25, 0x69	; 105
    f362:	89 f5       	brne	.+98     	; 0xf3c6 <vfprintf+0x5a6>
    f364:	17 ff       	sbrs	r17, 7
    f366:	08 c0       	rjmp	.+16     	; 0xf378 <vfprintf+0x558>
    f368:	f6 01       	movw	r30, r12
    f36a:	20 81       	ld	r18, Z
    f36c:	31 81       	ldd	r19, Z+1	; 0x01
    f36e:	42 81       	ldd	r20, Z+2	; 0x02
    f370:	53 81       	ldd	r21, Z+3	; 0x03
    f372:	84 e0       	ldi	r24, 0x04	; 4
    f374:	90 e0       	ldi	r25, 0x00	; 0
    f376:	0a c0       	rjmp	.+20     	; 0xf38c <vfprintf+0x56c>
    f378:	f6 01       	movw	r30, r12
    f37a:	80 81       	ld	r24, Z
    f37c:	91 81       	ldd	r25, Z+1	; 0x01
    f37e:	9c 01       	movw	r18, r24
    f380:	44 27       	eor	r20, r20
    f382:	37 fd       	sbrc	r19, 7
    f384:	40 95       	com	r20
    f386:	54 2f       	mov	r21, r20
    f388:	82 e0       	ldi	r24, 0x02	; 2
    f38a:	90 e0       	ldi	r25, 0x00	; 0
    f38c:	c8 0e       	add	r12, r24
    f38e:	d9 1e       	adc	r13, r25
    f390:	9f e6       	ldi	r25, 0x6F	; 111
    f392:	f9 2e       	mov	r15, r25
    f394:	f1 22       	and	r15, r17
    f396:	57 ff       	sbrs	r21, 7
    f398:	09 c0       	rjmp	.+18     	; 0xf3ac <vfprintf+0x58c>
    f39a:	50 95       	com	r21
    f39c:	40 95       	com	r20
    f39e:	30 95       	com	r19
    f3a0:	21 95       	neg	r18
    f3a2:	3f 4f       	sbci	r19, 0xFF	; 255
    f3a4:	4f 4f       	sbci	r20, 0xFF	; 255
    f3a6:	5f 4f       	sbci	r21, 0xFF	; 255
    f3a8:	90 e8       	ldi	r25, 0x80	; 128
    f3aa:	f9 2a       	or	r15, r25
    f3ac:	ca 01       	movw	r24, r20
    f3ae:	b9 01       	movw	r22, r18
    f3b0:	ae 01       	movw	r20, r28
    f3b2:	4f 5f       	subi	r20, 0xFF	; 255
    f3b4:	5f 4f       	sbci	r21, 0xFF	; 255
    f3b6:	2a e0       	ldi	r18, 0x0A	; 10
    f3b8:	30 e0       	ldi	r19, 0x00	; 0
    f3ba:	0e 94 ab 82 	call	0x10556	; 0x10556 <__ultoa_invert>
    f3be:	e8 2e       	mov	r14, r24
    f3c0:	e8 89       	ldd	r30, Y+16	; 0x10
    f3c2:	ee 1a       	sub	r14, r30
    f3c4:	41 c0       	rjmp	.+130    	; 0xf448 <vfprintf+0x628>
    f3c6:	95 37       	cpi	r25, 0x75	; 117
    f3c8:	21 f4       	brne	.+8      	; 0xf3d2 <vfprintf+0x5b2>
    f3ca:	1f 7e       	andi	r17, 0xEF	; 239
    f3cc:	2a e0       	ldi	r18, 0x0A	; 10
    f3ce:	30 e0       	ldi	r19, 0x00	; 0
    f3d0:	1c c0       	rjmp	.+56     	; 0xf40a <vfprintf+0x5ea>
    f3d2:	19 7f       	andi	r17, 0xF9	; 249
    f3d4:	9f 36       	cpi	r25, 0x6F	; 111
    f3d6:	61 f0       	breq	.+24     	; 0xf3f0 <vfprintf+0x5d0>
    f3d8:	90 37       	cpi	r25, 0x70	; 112
    f3da:	20 f4       	brcc	.+8      	; 0xf3e4 <vfprintf+0x5c4>
    f3dc:	98 35       	cpi	r25, 0x58	; 88
    f3de:	09 f0       	breq	.+2      	; 0xf3e2 <vfprintf+0x5c2>
    f3e0:	b2 c0       	rjmp	.+356    	; 0xf546 <vfprintf+0x726>
    f3e2:	0f c0       	rjmp	.+30     	; 0xf402 <vfprintf+0x5e2>
    f3e4:	90 37       	cpi	r25, 0x70	; 112
    f3e6:	39 f0       	breq	.+14     	; 0xf3f6 <vfprintf+0x5d6>
    f3e8:	98 37       	cpi	r25, 0x78	; 120
    f3ea:	09 f0       	breq	.+2      	; 0xf3ee <vfprintf+0x5ce>
    f3ec:	ac c0       	rjmp	.+344    	; 0xf546 <vfprintf+0x726>
    f3ee:	04 c0       	rjmp	.+8      	; 0xf3f8 <vfprintf+0x5d8>
    f3f0:	28 e0       	ldi	r18, 0x08	; 8
    f3f2:	30 e0       	ldi	r19, 0x00	; 0
    f3f4:	0a c0       	rjmp	.+20     	; 0xf40a <vfprintf+0x5ea>
    f3f6:	10 61       	ori	r17, 0x10	; 16
    f3f8:	14 fd       	sbrc	r17, 4
    f3fa:	14 60       	ori	r17, 0x04	; 4
    f3fc:	20 e1       	ldi	r18, 0x10	; 16
    f3fe:	30 e0       	ldi	r19, 0x00	; 0
    f400:	04 c0       	rjmp	.+8      	; 0xf40a <vfprintf+0x5ea>
    f402:	14 fd       	sbrc	r17, 4
    f404:	16 60       	ori	r17, 0x06	; 6
    f406:	20 e1       	ldi	r18, 0x10	; 16
    f408:	32 e0       	ldi	r19, 0x02	; 2
    f40a:	17 ff       	sbrs	r17, 7
    f40c:	08 c0       	rjmp	.+16     	; 0xf41e <vfprintf+0x5fe>
    f40e:	f6 01       	movw	r30, r12
    f410:	60 81       	ld	r22, Z
    f412:	71 81       	ldd	r23, Z+1	; 0x01
    f414:	82 81       	ldd	r24, Z+2	; 0x02
    f416:	93 81       	ldd	r25, Z+3	; 0x03
    f418:	44 e0       	ldi	r20, 0x04	; 4
    f41a:	50 e0       	ldi	r21, 0x00	; 0
    f41c:	08 c0       	rjmp	.+16     	; 0xf42e <vfprintf+0x60e>
    f41e:	f6 01       	movw	r30, r12
    f420:	80 81       	ld	r24, Z
    f422:	91 81       	ldd	r25, Z+1	; 0x01
    f424:	bc 01       	movw	r22, r24
    f426:	80 e0       	ldi	r24, 0x00	; 0
    f428:	90 e0       	ldi	r25, 0x00	; 0
    f42a:	42 e0       	ldi	r20, 0x02	; 2
    f42c:	50 e0       	ldi	r21, 0x00	; 0
    f42e:	c4 0e       	add	r12, r20
    f430:	d5 1e       	adc	r13, r21
    f432:	ae 01       	movw	r20, r28
    f434:	4f 5f       	subi	r20, 0xFF	; 255
    f436:	5f 4f       	sbci	r21, 0xFF	; 255
    f438:	0e 94 ab 82 	call	0x10556	; 0x10556 <__ultoa_invert>
    f43c:	e8 2e       	mov	r14, r24
    f43e:	58 89       	ldd	r21, Y+16	; 0x10
    f440:	e5 1a       	sub	r14, r21
    f442:	8f e7       	ldi	r24, 0x7F	; 127
    f444:	f8 2e       	mov	r15, r24
    f446:	f1 22       	and	r15, r17
    f448:	f6 fe       	sbrs	r15, 6
    f44a:	0b c0       	rjmp	.+22     	; 0xf462 <vfprintf+0x642>
    f44c:	8e ef       	ldi	r24, 0xFE	; 254
    f44e:	f8 22       	and	r15, r24
    f450:	e9 14       	cp	r14, r9
    f452:	38 f4       	brcc	.+14     	; 0xf462 <vfprintf+0x642>
    f454:	f4 fe       	sbrs	r15, 4
    f456:	07 c0       	rjmp	.+14     	; 0xf466 <vfprintf+0x646>
    f458:	f2 fc       	sbrc	r15, 2
    f45a:	05 c0       	rjmp	.+10     	; 0xf466 <vfprintf+0x646>
    f45c:	9f ee       	ldi	r25, 0xEF	; 239
    f45e:	f9 22       	and	r15, r25
    f460:	02 c0       	rjmp	.+4      	; 0xf466 <vfprintf+0x646>
    f462:	1e 2d       	mov	r17, r14
    f464:	01 c0       	rjmp	.+2      	; 0xf468 <vfprintf+0x648>
    f466:	19 2d       	mov	r17, r9
    f468:	f4 fe       	sbrs	r15, 4
    f46a:	0d c0       	rjmp	.+26     	; 0xf486 <vfprintf+0x666>
    f46c:	fe 01       	movw	r30, r28
    f46e:	ee 0d       	add	r30, r14
    f470:	f1 1d       	adc	r31, r1
    f472:	80 81       	ld	r24, Z
    f474:	80 33       	cpi	r24, 0x30	; 48
    f476:	19 f4       	brne	.+6      	; 0xf47e <vfprintf+0x65e>
    f478:	e9 ee       	ldi	r30, 0xE9	; 233
    f47a:	fe 22       	and	r15, r30
    f47c:	08 c0       	rjmp	.+16     	; 0xf48e <vfprintf+0x66e>
    f47e:	1f 5f       	subi	r17, 0xFF	; 255
    f480:	f2 fe       	sbrs	r15, 2
    f482:	05 c0       	rjmp	.+10     	; 0xf48e <vfprintf+0x66e>
    f484:	03 c0       	rjmp	.+6      	; 0xf48c <vfprintf+0x66c>
    f486:	8f 2d       	mov	r24, r15
    f488:	86 78       	andi	r24, 0x86	; 134
    f48a:	09 f0       	breq	.+2      	; 0xf48e <vfprintf+0x66e>
    f48c:	1f 5f       	subi	r17, 0xFF	; 255
    f48e:	0f 2d       	mov	r16, r15
    f490:	f3 fc       	sbrc	r15, 3
    f492:	14 c0       	rjmp	.+40     	; 0xf4bc <vfprintf+0x69c>
    f494:	f0 fe       	sbrs	r15, 0
    f496:	0f c0       	rjmp	.+30     	; 0xf4b6 <vfprintf+0x696>
    f498:	18 15       	cp	r17, r8
    f49a:	10 f0       	brcs	.+4      	; 0xf4a0 <vfprintf+0x680>
    f49c:	9e 2c       	mov	r9, r14
    f49e:	0b c0       	rjmp	.+22     	; 0xf4b6 <vfprintf+0x696>
    f4a0:	9e 2c       	mov	r9, r14
    f4a2:	98 0c       	add	r9, r8
    f4a4:	91 1a       	sub	r9, r17
    f4a6:	18 2d       	mov	r17, r8
    f4a8:	06 c0       	rjmp	.+12     	; 0xf4b6 <vfprintf+0x696>
    f4aa:	80 e2       	ldi	r24, 0x20	; 32
    f4ac:	90 e0       	ldi	r25, 0x00	; 0
    f4ae:	b3 01       	movw	r22, r6
    f4b0:	0e 94 bd 81 	call	0x1037a	; 0x1037a <fputc>
    f4b4:	1f 5f       	subi	r17, 0xFF	; 255
    f4b6:	18 15       	cp	r17, r8
    f4b8:	c0 f3       	brcs	.-16     	; 0xf4aa <vfprintf+0x68a>
    f4ba:	04 c0       	rjmp	.+8      	; 0xf4c4 <vfprintf+0x6a4>
    f4bc:	18 15       	cp	r17, r8
    f4be:	10 f4       	brcc	.+4      	; 0xf4c4 <vfprintf+0x6a4>
    f4c0:	81 1a       	sub	r8, r17
    f4c2:	01 c0       	rjmp	.+2      	; 0xf4c6 <vfprintf+0x6a6>
    f4c4:	88 24       	eor	r8, r8
    f4c6:	04 ff       	sbrs	r16, 4
    f4c8:	0f c0       	rjmp	.+30     	; 0xf4e8 <vfprintf+0x6c8>
    f4ca:	80 e3       	ldi	r24, 0x30	; 48
    f4cc:	90 e0       	ldi	r25, 0x00	; 0
    f4ce:	b3 01       	movw	r22, r6
    f4d0:	0e 94 bd 81 	call	0x1037a	; 0x1037a <fputc>
    f4d4:	02 ff       	sbrs	r16, 2
    f4d6:	1d c0       	rjmp	.+58     	; 0xf512 <vfprintf+0x6f2>
    f4d8:	01 fd       	sbrc	r16, 1
    f4da:	03 c0       	rjmp	.+6      	; 0xf4e2 <vfprintf+0x6c2>
    f4dc:	88 e7       	ldi	r24, 0x78	; 120
    f4de:	90 e0       	ldi	r25, 0x00	; 0
    f4e0:	0e c0       	rjmp	.+28     	; 0xf4fe <vfprintf+0x6de>
    f4e2:	88 e5       	ldi	r24, 0x58	; 88
    f4e4:	90 e0       	ldi	r25, 0x00	; 0
    f4e6:	0b c0       	rjmp	.+22     	; 0xf4fe <vfprintf+0x6de>
    f4e8:	80 2f       	mov	r24, r16
    f4ea:	86 78       	andi	r24, 0x86	; 134
    f4ec:	91 f0       	breq	.+36     	; 0xf512 <vfprintf+0x6f2>
    f4ee:	01 ff       	sbrs	r16, 1
    f4f0:	02 c0       	rjmp	.+4      	; 0xf4f6 <vfprintf+0x6d6>
    f4f2:	8b e2       	ldi	r24, 0x2B	; 43
    f4f4:	01 c0       	rjmp	.+2      	; 0xf4f8 <vfprintf+0x6d8>
    f4f6:	80 e2       	ldi	r24, 0x20	; 32
    f4f8:	f7 fc       	sbrc	r15, 7
    f4fa:	8d e2       	ldi	r24, 0x2D	; 45
    f4fc:	90 e0       	ldi	r25, 0x00	; 0
    f4fe:	b3 01       	movw	r22, r6
    f500:	0e 94 bd 81 	call	0x1037a	; 0x1037a <fputc>
    f504:	06 c0       	rjmp	.+12     	; 0xf512 <vfprintf+0x6f2>
    f506:	80 e3       	ldi	r24, 0x30	; 48
    f508:	90 e0       	ldi	r25, 0x00	; 0
    f50a:	b3 01       	movw	r22, r6
    f50c:	0e 94 bd 81 	call	0x1037a	; 0x1037a <fputc>
    f510:	9a 94       	dec	r9
    f512:	e9 14       	cp	r14, r9
    f514:	c0 f3       	brcs	.-16     	; 0xf506 <vfprintf+0x6e6>
    f516:	ea 94       	dec	r14
    f518:	e1 e0       	ldi	r30, 0x01	; 1
    f51a:	f0 e0       	ldi	r31, 0x00	; 0
    f51c:	ec 0f       	add	r30, r28
    f51e:	fd 1f       	adc	r31, r29
    f520:	ee 0d       	add	r30, r14
    f522:	f1 1d       	adc	r31, r1
    f524:	80 81       	ld	r24, Z
    f526:	90 e0       	ldi	r25, 0x00	; 0
    f528:	b3 01       	movw	r22, r6
    f52a:	0e 94 bd 81 	call	0x1037a	; 0x1037a <fputc>
    f52e:	ee 20       	and	r14, r14
    f530:	91 f7       	brne	.-28     	; 0xf516 <vfprintf+0x6f6>
    f532:	06 c0       	rjmp	.+12     	; 0xf540 <vfprintf+0x720>
    f534:	80 e2       	ldi	r24, 0x20	; 32
    f536:	90 e0       	ldi	r25, 0x00	; 0
    f538:	b3 01       	movw	r22, r6
    f53a:	0e 94 bd 81 	call	0x1037a	; 0x1037a <fputc>
    f53e:	8a 94       	dec	r8
    f540:	88 20       	and	r8, r8
    f542:	c1 f7       	brne	.-16     	; 0xf534 <vfprintf+0x714>
    f544:	99 cc       	rjmp	.-1742   	; 0xee78 <vfprintf+0x58>
    f546:	f3 01       	movw	r30, r6
    f548:	66 81       	ldd	r22, Z+6	; 0x06
    f54a:	77 81       	ldd	r23, Z+7	; 0x07
    f54c:	cb 01       	movw	r24, r22
    f54e:	61 96       	adiw	r28, 0x11	; 17
    f550:	0f b6       	in	r0, 0x3f	; 63
    f552:	f8 94       	cli
    f554:	de bf       	out	0x3e, r29	; 62
    f556:	0f be       	out	0x3f, r0	; 63
    f558:	cd bf       	out	0x3d, r28	; 61
    f55a:	cf 91       	pop	r28
    f55c:	df 91       	pop	r29
    f55e:	1f 91       	pop	r17
    f560:	0f 91       	pop	r16
    f562:	ff 90       	pop	r15
    f564:	ef 90       	pop	r14
    f566:	df 90       	pop	r13
    f568:	cf 90       	pop	r12
    f56a:	bf 90       	pop	r11
    f56c:	af 90       	pop	r10
    f56e:	9f 90       	pop	r9
    f570:	8f 90       	pop	r8
    f572:	7f 90       	pop	r7
    f574:	6f 90       	pop	r6
    f576:	5f 90       	pop	r5
    f578:	4f 90       	pop	r4
    f57a:	3f 90       	pop	r3
    f57c:	2f 90       	pop	r2
    f57e:	08 95       	ret

0000f580 <putval>:
    f580:	fc 01       	movw	r30, r24
    f582:	20 fd       	sbrc	r18, 0
    f584:	08 c0       	rjmp	.+16     	; 0xf596 <putval+0x16>
    f586:	23 fd       	sbrc	r18, 3
    f588:	05 c0       	rjmp	.+10     	; 0xf594 <putval+0x14>
    f58a:	22 ff       	sbrs	r18, 2
    f58c:	02 c0       	rjmp	.+4      	; 0xf592 <putval+0x12>
    f58e:	73 83       	std	Z+3, r23	; 0x03
    f590:	62 83       	std	Z+2, r22	; 0x02
    f592:	51 83       	std	Z+1, r21	; 0x01
    f594:	40 83       	st	Z, r20
    f596:	08 95       	ret

0000f598 <mulacc>:
    f598:	ef 92       	push	r14
    f59a:	ff 92       	push	r15
    f59c:	0f 93       	push	r16
    f59e:	1f 93       	push	r17
    f5a0:	44 ff       	sbrs	r20, 4
    f5a2:	02 c0       	rjmp	.+4      	; 0xf5a8 <mulacc+0x10>
    f5a4:	33 e0       	ldi	r19, 0x03	; 3
    f5a6:	11 c0       	rjmp	.+34     	; 0xf5ca <mulacc+0x32>
    f5a8:	46 ff       	sbrs	r20, 6
    f5aa:	02 c0       	rjmp	.+4      	; 0xf5b0 <mulacc+0x18>
    f5ac:	34 e0       	ldi	r19, 0x04	; 4
    f5ae:	0d c0       	rjmp	.+26     	; 0xf5ca <mulacc+0x32>
    f5b0:	db 01       	movw	r26, r22
    f5b2:	fc 01       	movw	r30, r24
    f5b4:	aa 0f       	add	r26, r26
    f5b6:	bb 1f       	adc	r27, r27
    f5b8:	ee 1f       	adc	r30, r30
    f5ba:	ff 1f       	adc	r31, r31
    f5bc:	10 94       	com	r1
    f5be:	d1 f7       	brne	.-12     	; 0xf5b4 <mulacc+0x1c>
    f5c0:	6a 0f       	add	r22, r26
    f5c2:	7b 1f       	adc	r23, r27
    f5c4:	8e 1f       	adc	r24, r30
    f5c6:	9f 1f       	adc	r25, r31
    f5c8:	31 e0       	ldi	r19, 0x01	; 1
    f5ca:	66 0f       	add	r22, r22
    f5cc:	77 1f       	adc	r23, r23
    f5ce:	88 1f       	adc	r24, r24
    f5d0:	99 1f       	adc	r25, r25
    f5d2:	31 50       	subi	r19, 0x01	; 1
    f5d4:	d1 f7       	brne	.-12     	; 0xf5ca <mulacc+0x32>
    f5d6:	7b 01       	movw	r14, r22
    f5d8:	8c 01       	movw	r16, r24
    f5da:	e2 0e       	add	r14, r18
    f5dc:	f1 1c       	adc	r15, r1
    f5de:	01 1d       	adc	r16, r1
    f5e0:	11 1d       	adc	r17, r1
    f5e2:	a8 01       	movw	r20, r16
    f5e4:	97 01       	movw	r18, r14
    f5e6:	b7 01       	movw	r22, r14
    f5e8:	ca 01       	movw	r24, r20
    f5ea:	1f 91       	pop	r17
    f5ec:	0f 91       	pop	r16
    f5ee:	ff 90       	pop	r15
    f5f0:	ef 90       	pop	r14
    f5f2:	08 95       	ret

0000f5f4 <skip_spaces>:
    f5f4:	0f 93       	push	r16
    f5f6:	1f 93       	push	r17
    f5f8:	cf 93       	push	r28
    f5fa:	df 93       	push	r29
    f5fc:	8c 01       	movw	r16, r24
    f5fe:	c8 01       	movw	r24, r16
    f600:	0e 94 7b 81 	call	0x102f6	; 0x102f6 <fgetc>
    f604:	ec 01       	movw	r28, r24
    f606:	97 fd       	sbrc	r25, 7
    f608:	08 c0       	rjmp	.+16     	; 0xf61a <skip_spaces+0x26>
    f60a:	0e 94 d2 80 	call	0x101a4	; 0x101a4 <isspace>
    f60e:	89 2b       	or	r24, r25
    f610:	b1 f7       	brne	.-20     	; 0xf5fe <skip_spaces+0xa>
    f612:	ce 01       	movw	r24, r28
    f614:	b8 01       	movw	r22, r16
    f616:	0e 94 91 82 	call	0x10522	; 0x10522 <ungetc>
    f61a:	ce 01       	movw	r24, r28
    f61c:	df 91       	pop	r29
    f61e:	cf 91       	pop	r28
    f620:	1f 91       	pop	r17
    f622:	0f 91       	pop	r16
    f624:	08 95       	ret

0000f626 <conv_int>:
    f626:	8f 92       	push	r8
    f628:	9f 92       	push	r9
    f62a:	af 92       	push	r10
    f62c:	bf 92       	push	r11
    f62e:	df 92       	push	r13
    f630:	ef 92       	push	r14
    f632:	ff 92       	push	r15
    f634:	0f 93       	push	r16
    f636:	1f 93       	push	r17
    f638:	cf 93       	push	r28
    f63a:	df 93       	push	r29
    f63c:	5c 01       	movw	r10, r24
    f63e:	eb 01       	movw	r28, r22
    f640:	4a 01       	movw	r8, r20
    f642:	12 2f       	mov	r17, r18
    f644:	0e 94 7b 81 	call	0x102f6	; 0x102f6 <fgetc>
    f648:	ac 01       	movw	r20, r24
    f64a:	8b 32       	cpi	r24, 0x2B	; 43
    f64c:	19 f0       	breq	.+6      	; 0xf654 <conv_int+0x2e>
    f64e:	8d 32       	cpi	r24, 0x2D	; 45
    f650:	51 f4       	brne	.+20     	; 0xf666 <conv_int+0x40>
    f652:	10 68       	ori	r17, 0x80	; 128
    f654:	21 97       	sbiw	r28, 0x01	; 1
    f656:	09 f4       	brne	.+2      	; 0xf65a <conv_int+0x34>
    f658:	6d c0       	rjmp	.+218    	; 0xf734 <conv_int+0x10e>
    f65a:	c5 01       	movw	r24, r10
    f65c:	0e 94 7b 81 	call	0x102f6	; 0x102f6 <fgetc>
    f660:	ac 01       	movw	r20, r24
    f662:	97 fd       	sbrc	r25, 7
    f664:	67 c0       	rjmp	.+206    	; 0xf734 <conv_int+0x10e>
    f666:	6d ef       	ldi	r22, 0xFD	; 253
    f668:	d6 2e       	mov	r13, r22
    f66a:	d1 22       	and	r13, r17
    f66c:	8d 2d       	mov	r24, r13
    f66e:	80 73       	andi	r24, 0x30	; 48
    f670:	01 f5       	brne	.+64     	; 0xf6b2 <conv_int+0x8c>
    f672:	40 33       	cpi	r20, 0x30	; 48
    f674:	f1 f4       	brne	.+60     	; 0xf6b2 <conv_int+0x8c>
    f676:	21 97       	sbiw	r28, 0x01	; 1
    f678:	09 f4       	brne	.+2      	; 0xf67c <conv_int+0x56>
    f67a:	47 c0       	rjmp	.+142    	; 0xf70a <conv_int+0xe4>
    f67c:	c5 01       	movw	r24, r10
    f67e:	0e 94 7b 81 	call	0x102f6	; 0x102f6 <fgetc>
    f682:	ac 01       	movw	r20, r24
    f684:	97 fd       	sbrc	r25, 7
    f686:	41 c0       	rjmp	.+130    	; 0xf70a <conv_int+0xe4>
    f688:	82 e0       	ldi	r24, 0x02	; 2
    f68a:	d8 2a       	or	r13, r24
    f68c:	48 37       	cpi	r20, 0x78	; 120
    f68e:	11 f0       	breq	.+4      	; 0xf694 <conv_int+0x6e>
    f690:	48 35       	cpi	r20, 0x58	; 88
    f692:	59 f4       	brne	.+22     	; 0xf6aa <conv_int+0x84>
    f694:	80 e4       	ldi	r24, 0x40	; 64
    f696:	d8 2a       	or	r13, r24
    f698:	21 97       	sbiw	r28, 0x01	; 1
    f69a:	b9 f1       	breq	.+110    	; 0xf70a <conv_int+0xe4>
    f69c:	c5 01       	movw	r24, r10
    f69e:	0e 94 7b 81 	call	0x102f6	; 0x102f6 <fgetc>
    f6a2:	ac 01       	movw	r20, r24
    f6a4:	99 23       	and	r25, r25
    f6a6:	2c f4       	brge	.+10     	; 0xf6b2 <conv_int+0x8c>
    f6a8:	30 c0       	rjmp	.+96     	; 0xf70a <conv_int+0xe4>
    f6aa:	d6 fc       	sbrc	r13, 6
    f6ac:	02 c0       	rjmp	.+4      	; 0xf6b2 <conv_int+0x8c>
    f6ae:	80 e1       	ldi	r24, 0x10	; 16
    f6b0:	d8 2a       	or	r13, r24
    f6b2:	ee 24       	eor	r14, r14
    f6b4:	ff 24       	eor	r15, r15
    f6b6:	87 01       	movw	r16, r14
    f6b8:	24 2f       	mov	r18, r20
    f6ba:	20 53       	subi	r18, 0x30	; 48
    f6bc:	28 30       	cpi	r18, 0x08	; 8
    f6be:	88 f0       	brcs	.+34     	; 0xf6e2 <conv_int+0xbc>
    f6c0:	d4 fc       	sbrc	r13, 4
    f6c2:	09 c0       	rjmp	.+18     	; 0xf6d6 <conv_int+0xb0>
    f6c4:	2a 30       	cpi	r18, 0x0A	; 10
    f6c6:	68 f0       	brcs	.+26     	; 0xf6e2 <conv_int+0xbc>
    f6c8:	d6 fe       	sbrs	r13, 6
    f6ca:	05 c0       	rjmp	.+10     	; 0xf6d6 <conv_int+0xb0>
    f6cc:	2f 7d       	andi	r18, 0xDF	; 223
    f6ce:	82 2f       	mov	r24, r18
    f6d0:	81 51       	subi	r24, 0x11	; 17
    f6d2:	86 30       	cpi	r24, 0x06	; 6
    f6d4:	28 f0       	brcs	.+10     	; 0xf6e0 <conv_int+0xba>
    f6d6:	ca 01       	movw	r24, r20
    f6d8:	b5 01       	movw	r22, r10
    f6da:	0e 94 91 82 	call	0x10522	; 0x10522 <ungetc>
    f6de:	12 c0       	rjmp	.+36     	; 0xf704 <conv_int+0xde>
    f6e0:	27 50       	subi	r18, 0x07	; 7
    f6e2:	c8 01       	movw	r24, r16
    f6e4:	b7 01       	movw	r22, r14
    f6e6:	4d 2d       	mov	r20, r13
    f6e8:	0e 94 cc 7a 	call	0xf598	; 0xf598 <mulacc>
    f6ec:	7b 01       	movw	r14, r22
    f6ee:	8c 01       	movw	r16, r24
    f6f0:	82 e0       	ldi	r24, 0x02	; 2
    f6f2:	d8 2a       	or	r13, r24
    f6f4:	21 97       	sbiw	r28, 0x01	; 1
    f6f6:	61 f0       	breq	.+24     	; 0xf710 <conv_int+0xea>
    f6f8:	c5 01       	movw	r24, r10
    f6fa:	0e 94 7b 81 	call	0x102f6	; 0x102f6 <fgetc>
    f6fe:	ac 01       	movw	r20, r24
    f700:	97 ff       	sbrs	r25, 7
    f702:	da cf       	rjmp	.-76     	; 0xf6b8 <conv_int+0x92>
    f704:	d1 fc       	sbrc	r13, 1
    f706:	04 c0       	rjmp	.+8      	; 0xf710 <conv_int+0xea>
    f708:	15 c0       	rjmp	.+42     	; 0xf734 <conv_int+0x10e>
    f70a:	ee 24       	eor	r14, r14
    f70c:	ff 24       	eor	r15, r15
    f70e:	87 01       	movw	r16, r14
    f710:	d7 fe       	sbrs	r13, 7
    f712:	08 c0       	rjmp	.+16     	; 0xf724 <conv_int+0xfe>
    f714:	10 95       	com	r17
    f716:	00 95       	com	r16
    f718:	f0 94       	com	r15
    f71a:	e0 94       	com	r14
    f71c:	e1 1c       	adc	r14, r1
    f71e:	f1 1c       	adc	r15, r1
    f720:	01 1d       	adc	r16, r1
    f722:	11 1d       	adc	r17, r1
    f724:	c4 01       	movw	r24, r8
    f726:	b8 01       	movw	r22, r16
    f728:	a7 01       	movw	r20, r14
    f72a:	2d 2d       	mov	r18, r13
    f72c:	0e 94 c0 7a 	call	0xf580	; 0xf580 <putval>
    f730:	81 e0       	ldi	r24, 0x01	; 1
    f732:	01 c0       	rjmp	.+2      	; 0xf736 <conv_int+0x110>
    f734:	80 e0       	ldi	r24, 0x00	; 0
    f736:	df 91       	pop	r29
    f738:	cf 91       	pop	r28
    f73a:	1f 91       	pop	r17
    f73c:	0f 91       	pop	r16
    f73e:	ff 90       	pop	r15
    f740:	ef 90       	pop	r14
    f742:	df 90       	pop	r13
    f744:	bf 90       	pop	r11
    f746:	af 90       	pop	r10
    f748:	9f 90       	pop	r9
    f74a:	8f 90       	pop	r8
    f74c:	08 95       	ret

0000f74e <conv_brk>:
    f74e:	6f 92       	push	r6
    f750:	7f 92       	push	r7
    f752:	8f 92       	push	r8
    f754:	9f 92       	push	r9
    f756:	af 92       	push	r10
    f758:	bf 92       	push	r11
    f75a:	cf 92       	push	r12
    f75c:	df 92       	push	r13
    f75e:	ef 92       	push	r14
    f760:	ff 92       	push	r15
    f762:	0f 93       	push	r16
    f764:	1f 93       	push	r17
    f766:	df 93       	push	r29
    f768:	cf 93       	push	r28
    f76a:	cd b7       	in	r28, 0x3d	; 61
    f76c:	de b7       	in	r29, 0x3e	; 62
    f76e:	a0 97       	sbiw	r28, 0x20	; 32
    f770:	0f b6       	in	r0, 0x3f	; 63
    f772:	f8 94       	cli
    f774:	de bf       	out	0x3e, r29	; 62
    f776:	0f be       	out	0x3f, r0	; 63
    f778:	cd bf       	out	0x3d, r28	; 61
    f77a:	5c 01       	movw	r10, r24
    f77c:	6b 01       	movw	r12, r22
    f77e:	8a 01       	movw	r16, r20
    f780:	79 01       	movw	r14, r18
    f782:	fe 01       	movw	r30, r28
    f784:	31 96       	adiw	r30, 0x01	; 1
    f786:	80 e2       	ldi	r24, 0x20	; 32
    f788:	df 01       	movw	r26, r30
    f78a:	1d 92       	st	X+, r1
    f78c:	8a 95       	dec	r24
    f78e:	e9 f7       	brne	.-6      	; 0xf78a <conv_brk+0x3c>
    f790:	70 e0       	ldi	r23, 0x00	; 0
    f792:	30 e0       	ldi	r19, 0x00	; 0
    f794:	60 e0       	ldi	r22, 0x00	; 0
    f796:	40 e0       	ldi	r20, 0x00	; 0
    f798:	50 e0       	ldi	r21, 0x00	; 0
    f79a:	3f 01       	movw	r6, r30
    f79c:	a1 e0       	ldi	r26, 0x01	; 1
    f79e:	b0 e0       	ldi	r27, 0x00	; 0
    f7a0:	f5 01       	movw	r30, r10
    f7a2:	83 81       	ldd	r24, Z+3	; 0x03
    f7a4:	f7 01       	movw	r30, r14
    f7a6:	83 fd       	sbrc	r24, 3
    f7a8:	25 91       	lpm	r18, Z+
    f7aa:	83 ff       	sbrs	r24, 3
    f7ac:	21 91       	ld	r18, Z+
    f7ae:	7f 01       	movw	r14, r30
    f7b0:	22 23       	and	r18, r18
    f7b2:	09 f4       	brne	.+2      	; 0xf7b6 <conv_brk+0x68>
    f7b4:	81 c0       	rjmp	.+258    	; 0xf8b8 <conv_brk+0x16a>
    f7b6:	2e 35       	cpi	r18, 0x5E	; 94
    f7b8:	19 f4       	brne	.+6      	; 0xf7c0 <conv_brk+0x72>
    f7ba:	41 15       	cp	r20, r1
    f7bc:	51 05       	cpc	r21, r1
    f7be:	69 f1       	breq	.+90     	; 0xf81a <conv_brk+0xcc>
    f7c0:	87 2f       	mov	r24, r23
    f7c2:	90 e0       	ldi	r25, 0x00	; 0
    f7c4:	84 17       	cp	r24, r20
    f7c6:	95 07       	cpc	r25, r21
    f7c8:	44 f4       	brge	.+16     	; 0xf7da <conv_brk+0x8c>
    f7ca:	2d 35       	cpi	r18, 0x5D	; 93
    f7cc:	51 f1       	breq	.+84     	; 0xf822 <conv_brk+0xd4>
    f7ce:	2d 32       	cpi	r18, 0x2D	; 45
    f7d0:	21 f4       	brne	.+8      	; 0xf7da <conv_brk+0x8c>
    f7d2:	33 23       	and	r19, r19
    f7d4:	29 f4       	brne	.+10     	; 0xf7e0 <conv_brk+0x92>
    f7d6:	31 e0       	ldi	r19, 0x01	; 1
    f7d8:	21 c0       	rjmp	.+66     	; 0xf81c <conv_brk+0xce>
    f7da:	33 23       	and	r19, r19
    f7dc:	09 f4       	brne	.+2      	; 0xf7e0 <conv_brk+0x92>
    f7de:	62 2f       	mov	r22, r18
    f7e0:	32 2f       	mov	r19, r18
    f7e2:	83 2f       	mov	r24, r19
    f7e4:	86 95       	lsr	r24
    f7e6:	86 95       	lsr	r24
    f7e8:	86 95       	lsr	r24
    f7ea:	f3 01       	movw	r30, r6
    f7ec:	e8 0f       	add	r30, r24
    f7ee:	f1 1d       	adc	r31, r1
    f7f0:	83 2f       	mov	r24, r19
    f7f2:	87 70       	andi	r24, 0x07	; 7
    f7f4:	4d 01       	movw	r8, r26
    f7f6:	02 c0       	rjmp	.+4      	; 0xf7fc <conv_brk+0xae>
    f7f8:	88 0c       	add	r8, r8
    f7fa:	99 1c       	adc	r9, r9
    f7fc:	8a 95       	dec	r24
    f7fe:	e2 f7       	brpl	.-8      	; 0xf7f8 <conv_brk+0xaa>
    f800:	20 81       	ld	r18, Z
    f802:	28 29       	or	r18, r8
    f804:	20 83       	st	Z, r18
    f806:	36 17       	cp	r19, r22
    f808:	11 f4       	brne	.+4      	; 0xf80e <conv_brk+0xc0>
    f80a:	30 e0       	ldi	r19, 0x00	; 0
    f80c:	07 c0       	rjmp	.+14     	; 0xf81c <conv_brk+0xce>
    f80e:	36 17       	cp	r19, r22
    f810:	10 f4       	brcc	.+4      	; 0xf816 <conv_brk+0xc8>
    f812:	3f 5f       	subi	r19, 0xFF	; 255
    f814:	e6 cf       	rjmp	.-52     	; 0xf7e2 <conv_brk+0x94>
    f816:	31 50       	subi	r19, 0x01	; 1
    f818:	e4 cf       	rjmp	.-56     	; 0xf7e2 <conv_brk+0x94>
    f81a:	71 e0       	ldi	r23, 0x01	; 1
    f81c:	4f 5f       	subi	r20, 0xFF	; 255
    f81e:	5f 4f       	sbci	r21, 0xFF	; 255
    f820:	bf cf       	rjmp	.-130    	; 0xf7a0 <conv_brk+0x52>
    f822:	33 23       	and	r19, r19
    f824:	19 f0       	breq	.+6      	; 0xf82c <conv_brk+0xde>
    f826:	8e 81       	ldd	r24, Y+6	; 0x06
    f828:	80 62       	ori	r24, 0x20	; 32
    f82a:	8e 83       	std	Y+6, r24	; 0x06
    f82c:	77 23       	and	r23, r23
    f82e:	59 f0       	breq	.+22     	; 0xf846 <conv_brk+0xf8>
    f830:	fe 01       	movw	r30, r28
    f832:	31 96       	adiw	r30, 0x01	; 1
    f834:	9e 01       	movw	r18, r28
    f836:	2f 5d       	subi	r18, 0xDF	; 223
    f838:	3f 4f       	sbci	r19, 0xFF	; 255
    f83a:	80 81       	ld	r24, Z
    f83c:	80 95       	com	r24
    f83e:	81 93       	st	Z+, r24
    f840:	e2 17       	cp	r30, r18
    f842:	f3 07       	cpc	r31, r19
    f844:	d1 f7       	brne	.-12     	; 0xf83a <conv_brk+0xec>
    f846:	99 24       	eor	r9, r9
    f848:	93 94       	inc	r9
    f84a:	3e 01       	movw	r6, r28
    f84c:	08 94       	sec
    f84e:	61 1c       	adc	r6, r1
    f850:	71 1c       	adc	r7, r1
    f852:	c5 01       	movw	r24, r10
    f854:	0e 94 7b 81 	call	0x102f6	; 0x102f6 <fgetc>
    f858:	ac 01       	movw	r20, r24
    f85a:	97 fd       	sbrc	r25, 7
    f85c:	25 c0       	rjmp	.+74     	; 0xf8a8 <conv_brk+0x15a>
    f85e:	86 95       	lsr	r24
    f860:	86 95       	lsr	r24
    f862:	86 95       	lsr	r24
    f864:	f3 01       	movw	r30, r6
    f866:	e8 0f       	add	r30, r24
    f868:	f1 1d       	adc	r31, r1
    f86a:	80 81       	ld	r24, Z
    f86c:	90 e0       	ldi	r25, 0x00	; 0
    f86e:	9a 01       	movw	r18, r20
    f870:	27 70       	andi	r18, 0x07	; 7
    f872:	30 70       	andi	r19, 0x00	; 0
    f874:	02 c0       	rjmp	.+4      	; 0xf87a <conv_brk+0x12c>
    f876:	95 95       	asr	r25
    f878:	87 95       	ror	r24
    f87a:	2a 95       	dec	r18
    f87c:	e2 f7       	brpl	.-8      	; 0xf876 <conv_brk+0x128>
    f87e:	80 fd       	sbrc	r24, 0
    f880:	05 c0       	rjmp	.+10     	; 0xf88c <conv_brk+0x13e>
    f882:	ca 01       	movw	r24, r20
    f884:	b5 01       	movw	r22, r10
    f886:	0e 94 91 82 	call	0x10522	; 0x10522 <ungetc>
    f88a:	0e c0       	rjmp	.+28     	; 0xf8a8 <conv_brk+0x15a>
    f88c:	01 15       	cp	r16, r1
    f88e:	11 05       	cpc	r17, r1
    f890:	19 f0       	breq	.+6      	; 0xf898 <conv_brk+0x14a>
    f892:	d8 01       	movw	r26, r16
    f894:	4d 93       	st	X+, r20
    f896:	8d 01       	movw	r16, r26
    f898:	08 94       	sec
    f89a:	c1 08       	sbc	r12, r1
    f89c:	d1 08       	sbc	r13, r1
    f89e:	99 24       	eor	r9, r9
    f8a0:	c1 14       	cp	r12, r1
    f8a2:	d1 04       	cpc	r13, r1
    f8a4:	b1 f6       	brne	.-84     	; 0xf852 <conv_brk+0x104>
    f8a6:	02 c0       	rjmp	.+4      	; 0xf8ac <conv_brk+0x15e>
    f8a8:	99 20       	and	r9, r9
    f8aa:	31 f4       	brne	.+12     	; 0xf8b8 <conv_brk+0x16a>
    f8ac:	01 15       	cp	r16, r1
    f8ae:	11 05       	cpc	r17, r1
    f8b0:	29 f0       	breq	.+10     	; 0xf8bc <conv_brk+0x16e>
    f8b2:	f8 01       	movw	r30, r16
    f8b4:	10 82       	st	Z, r1
    f8b6:	02 c0       	rjmp	.+4      	; 0xf8bc <conv_brk+0x16e>
    f8b8:	ee 24       	eor	r14, r14
    f8ba:	ff 24       	eor	r15, r15
    f8bc:	c7 01       	movw	r24, r14
    f8be:	a0 96       	adiw	r28, 0x20	; 32
    f8c0:	0f b6       	in	r0, 0x3f	; 63
    f8c2:	f8 94       	cli
    f8c4:	de bf       	out	0x3e, r29	; 62
    f8c6:	0f be       	out	0x3f, r0	; 63
    f8c8:	cd bf       	out	0x3d, r28	; 61
    f8ca:	cf 91       	pop	r28
    f8cc:	df 91       	pop	r29
    f8ce:	1f 91       	pop	r17
    f8d0:	0f 91       	pop	r16
    f8d2:	ff 90       	pop	r15
    f8d4:	ef 90       	pop	r14
    f8d6:	df 90       	pop	r13
    f8d8:	cf 90       	pop	r12
    f8da:	bf 90       	pop	r11
    f8dc:	af 90       	pop	r10
    f8de:	9f 90       	pop	r9
    f8e0:	8f 90       	pop	r8
    f8e2:	7f 90       	pop	r7
    f8e4:	6f 90       	pop	r6
    f8e6:	08 95       	ret

0000f8e8 <conv_flt>:
    f8e8:	2f 92       	push	r2
    f8ea:	3f 92       	push	r3
    f8ec:	5f 92       	push	r5
    f8ee:	6f 92       	push	r6
    f8f0:	7f 92       	push	r7
    f8f2:	8f 92       	push	r8
    f8f4:	9f 92       	push	r9
    f8f6:	af 92       	push	r10
    f8f8:	bf 92       	push	r11
    f8fa:	cf 92       	push	r12
    f8fc:	df 92       	push	r13
    f8fe:	ef 92       	push	r14
    f900:	ff 92       	push	r15
    f902:	0f 93       	push	r16
    f904:	1f 93       	push	r17
    f906:	cf 93       	push	r28
    f908:	df 93       	push	r29
    f90a:	3c 01       	movw	r6, r24
    f90c:	7b 01       	movw	r14, r22
    f90e:	1a 01       	movw	r2, r20
    f910:	0e 94 7b 81 	call	0x102f6	; 0x102f6 <fgetc>
    f914:	ec 01       	movw	r28, r24
    f916:	8b 32       	cpi	r24, 0x2B	; 43
    f918:	39 f0       	breq	.+14     	; 0xf928 <conv_flt+0x40>
    f91a:	8d 32       	cpi	r24, 0x2D	; 45
    f91c:	11 f0       	breq	.+4      	; 0xf922 <conv_flt+0x3a>
    f91e:	55 24       	eor	r5, r5
    f920:	11 c0       	rjmp	.+34     	; 0xf944 <conv_flt+0x5c>
    f922:	b0 e8       	ldi	r27, 0x80	; 128
    f924:	5b 2e       	mov	r5, r27
    f926:	01 c0       	rjmp	.+2      	; 0xf92a <conv_flt+0x42>
    f928:	55 24       	eor	r5, r5
    f92a:	08 94       	sec
    f92c:	e1 08       	sbc	r14, r1
    f92e:	f1 08       	sbc	r15, r1
    f930:	e1 14       	cp	r14, r1
    f932:	f1 04       	cpc	r15, r1
    f934:	09 f4       	brne	.+2      	; 0xf938 <conv_flt+0x50>
    f936:	18 c1       	rjmp	.+560    	; 0xfb68 <conv_flt+0x280>
    f938:	c3 01       	movw	r24, r6
    f93a:	0e 94 7b 81 	call	0x102f6	; 0x102f6 <fgetc>
    f93e:	ec 01       	movw	r28, r24
    f940:	97 fd       	sbrc	r25, 7
    f942:	12 c1       	rjmp	.+548    	; 0xfb68 <conv_flt+0x280>
    f944:	ce 01       	movw	r24, r28
    f946:	0e 94 da 80 	call	0x101b4	; 0x101b4 <tolower>
    f94a:	89 36       	cpi	r24, 0x69	; 105
    f94c:	91 05       	cpc	r25, r1
    f94e:	21 f0       	breq	.+8      	; 0xf958 <conv_flt+0x70>
    f950:	8e 36       	cpi	r24, 0x6E	; 110
    f952:	91 05       	cpc	r25, r1
    f954:	99 f5       	brne	.+102    	; 0xf9bc <conv_flt+0xd4>
    f956:	1d c0       	rjmp	.+58     	; 0xf992 <conv_flt+0xaa>
    f958:	0b ee       	ldi	r16, 0xEB	; 235
    f95a:	12 e0       	ldi	r17, 0x02	; 2
    f95c:	1c c0       	rjmp	.+56     	; 0xf996 <conv_flt+0xae>
    f95e:	08 94       	sec
    f960:	e1 08       	sbc	r14, r1
    f962:	f1 08       	sbc	r15, r1
    f964:	e1 14       	cp	r14, r1
    f966:	f1 04       	cpc	r15, r1
    f968:	71 f0       	breq	.+28     	; 0xf986 <conv_flt+0x9e>
    f96a:	c3 01       	movw	r24, r6
    f96c:	0e 94 7b 81 	call	0x102f6	; 0x102f6 <fgetc>
    f970:	ec 01       	movw	r28, r24
    f972:	97 fd       	sbrc	r25, 7
    f974:	08 c0       	rjmp	.+16     	; 0xf986 <conv_flt+0x9e>
    f976:	0e 94 da 80 	call	0x101b4	; 0x101b4 <tolower>
    f97a:	d8 16       	cp	r13, r24
    f97c:	61 f0       	breq	.+24     	; 0xf996 <conv_flt+0xae>
    f97e:	ce 01       	movw	r24, r28
    f980:	b3 01       	movw	r22, r6
    f982:	0e 94 91 82 	call	0x10522	; 0x10522 <ungetc>
    f986:	22 e0       	ldi	r18, 0x02	; 2
    f988:	0e 3e       	cpi	r16, 0xEE	; 238
    f98a:	12 07       	cpc	r17, r18
    f98c:	09 f0       	breq	.+2      	; 0xf990 <conv_flt+0xa8>
    f98e:	ec c0       	rjmp	.+472    	; 0xfb68 <conv_flt+0x280>
    f990:	08 c0       	rjmp	.+16     	; 0xf9a2 <conv_flt+0xba>
    f992:	08 ee       	ldi	r16, 0xE8	; 232
    f994:	12 e0       	ldi	r17, 0x02	; 2
    f996:	f8 01       	movw	r30, r16
    f998:	0f 5f       	subi	r16, 0xFF	; 255
    f99a:	1f 4f       	sbci	r17, 0xFF	; 255
    f99c:	d4 90       	lpm	r13, Z+
    f99e:	dd 20       	and	r13, r13
    f9a0:	f1 f6       	brne	.-68     	; 0xf95e <conv_flt+0x76>
    f9a2:	0b 5e       	subi	r16, 0xEB	; 235
    f9a4:	12 40       	sbci	r17, 0x02	; 2
    f9a6:	29 f0       	breq	.+10     	; 0xf9b2 <conv_flt+0xca>
    f9a8:	80 e0       	ldi	r24, 0x00	; 0
    f9aa:	90 e0       	ldi	r25, 0x00	; 0
    f9ac:	a0 e8       	ldi	r26, 0x80	; 128
    f9ae:	bf e7       	ldi	r27, 0x7F	; 127
    f9b0:	cf c0       	rjmp	.+414    	; 0xfb50 <conv_flt+0x268>
    f9b2:	80 e0       	ldi	r24, 0x00	; 0
    f9b4:	90 e0       	ldi	r25, 0x00	; 0
    f9b6:	a0 ec       	ldi	r26, 0xC0	; 192
    f9b8:	bf e7       	ldi	r27, 0x7F	; 127
    f9ba:	ca c0       	rjmp	.+404    	; 0xfb50 <conv_flt+0x268>
    f9bc:	cc 24       	eor	r12, r12
    f9be:	dd 24       	eor	r13, r13
    f9c0:	88 24       	eor	r8, r8
    f9c2:	99 24       	eor	r9, r9
    f9c4:	54 01       	movw	r10, r8
    f9c6:	ae 01       	movw	r20, r28
    f9c8:	40 53       	subi	r20, 0x30	; 48
    f9ca:	24 2f       	mov	r18, r20
    f9cc:	4a 30       	cpi	r20, 0x0A	; 10
    f9ce:	38 f5       	brcc	.+78     	; 0xfa1e <conv_flt+0x136>
    f9d0:	52 e0       	ldi	r21, 0x02	; 2
    f9d2:	55 2a       	or	r5, r21
    f9d4:	85 2d       	mov	r24, r5
    f9d6:	90 e0       	ldi	r25, 0x00	; 0
    f9d8:	ac 01       	movw	r20, r24
    f9da:	48 70       	andi	r20, 0x08	; 8
    f9dc:	50 70       	andi	r21, 0x00	; 0
    f9de:	52 fe       	sbrs	r5, 2
    f9e0:	06 c0       	rjmp	.+12     	; 0xf9ee <conv_flt+0x106>
    f9e2:	45 2b       	or	r20, r21
    f9e4:	11 f5       	brne	.+68     	; 0xfa2a <conv_flt+0x142>
    f9e6:	08 94       	sec
    f9e8:	c1 1c       	adc	r12, r1
    f9ea:	d1 1c       	adc	r13, r1
    f9ec:	1e c0       	rjmp	.+60     	; 0xfa2a <conv_flt+0x142>
    f9ee:	45 2b       	or	r20, r21
    f9f0:	19 f0       	breq	.+6      	; 0xf9f8 <conv_flt+0x110>
    f9f2:	08 94       	sec
    f9f4:	c1 08       	sbc	r12, r1
    f9f6:	d1 08       	sbc	r13, r1
    f9f8:	c5 01       	movw	r24, r10
    f9fa:	b4 01       	movw	r22, r8
    f9fc:	40 e2       	ldi	r20, 0x20	; 32
    f9fe:	0e 94 cc 7a 	call	0xf598	; 0xf598 <mulacc>
    fa02:	4b 01       	movw	r8, r22
    fa04:	5c 01       	movw	r10, r24
    fa06:	88 e9       	ldi	r24, 0x98	; 152
    fa08:	88 16       	cp	r8, r24
    fa0a:	89 e9       	ldi	r24, 0x99	; 153
    fa0c:	98 06       	cpc	r9, r24
    fa0e:	89 e9       	ldi	r24, 0x99	; 153
    fa10:	a8 06       	cpc	r10, r24
    fa12:	89 e1       	ldi	r24, 0x19	; 25
    fa14:	b8 06       	cpc	r11, r24
    fa16:	48 f0       	brcs	.+18     	; 0xfa2a <conv_flt+0x142>
    fa18:	94 e0       	ldi	r25, 0x04	; 4
    fa1a:	59 2a       	or	r5, r25
    fa1c:	06 c0       	rjmp	.+12     	; 0xfa2a <conv_flt+0x142>
    fa1e:	4e 3f       	cpi	r20, 0xFE	; 254
    fa20:	81 f4       	brne	.+32     	; 0xfa42 <conv_flt+0x15a>
    fa22:	53 fc       	sbrc	r5, 3
    fa24:	0e c0       	rjmp	.+28     	; 0xfa42 <conv_flt+0x15a>
    fa26:	e8 e0       	ldi	r30, 0x08	; 8
    fa28:	5e 2a       	or	r5, r30
    fa2a:	08 94       	sec
    fa2c:	e1 08       	sbc	r14, r1
    fa2e:	f1 08       	sbc	r15, r1
    fa30:	e1 14       	cp	r14, r1
    fa32:	f1 04       	cpc	r15, r1
    fa34:	31 f0       	breq	.+12     	; 0xfa42 <conv_flt+0x15a>
    fa36:	c3 01       	movw	r24, r6
    fa38:	0e 94 7b 81 	call	0x102f6	; 0x102f6 <fgetc>
    fa3c:	ec 01       	movw	r28, r24
    fa3e:	97 ff       	sbrs	r25, 7
    fa40:	c2 cf       	rjmp	.-124    	; 0xf9c6 <conv_flt+0xde>
    fa42:	51 fe       	sbrs	r5, 1
    fa44:	91 c0       	rjmp	.+290    	; 0xfb68 <conv_flt+0x280>
    fa46:	c5 36       	cpi	r28, 0x65	; 101
    fa48:	19 f0       	breq	.+6      	; 0xfa50 <conv_flt+0x168>
    fa4a:	c5 34       	cpi	r28, 0x45	; 69
    fa4c:	09 f0       	breq	.+2      	; 0xfa50 <conv_flt+0x168>
    fa4e:	46 c0       	rjmp	.+140    	; 0xfadc <conv_flt+0x1f4>
    fa50:	08 94       	sec
    fa52:	e1 08       	sbc	r14, r1
    fa54:	f1 08       	sbc	r15, r1
    fa56:	e1 14       	cp	r14, r1
    fa58:	f1 04       	cpc	r15, r1
    fa5a:	09 f4       	brne	.+2      	; 0xfa5e <conv_flt+0x176>
    fa5c:	85 c0       	rjmp	.+266    	; 0xfb68 <conv_flt+0x280>
    fa5e:	c3 01       	movw	r24, r6
    fa60:	0e 94 7b 81 	call	0x102f6	; 0x102f6 <fgetc>
    fa64:	ec 01       	movw	r28, r24
    fa66:	97 fd       	sbrc	r25, 7
    fa68:	7f c0       	rjmp	.+254    	; 0xfb68 <conv_flt+0x280>
    fa6a:	8b 32       	cpi	r24, 0x2B	; 43
    fa6c:	21 f0       	breq	.+8      	; 0xfa76 <conv_flt+0x18e>
    fa6e:	8d 32       	cpi	r24, 0x2D	; 45
    fa70:	69 f4       	brne	.+26     	; 0xfa8c <conv_flt+0x1a4>
    fa72:	f0 e1       	ldi	r31, 0x10	; 16
    fa74:	5f 2a       	or	r5, r31
    fa76:	08 94       	sec
    fa78:	e1 08       	sbc	r14, r1
    fa7a:	f1 08       	sbc	r15, r1
    fa7c:	e1 14       	cp	r14, r1
    fa7e:	f1 04       	cpc	r15, r1
    fa80:	09 f4       	brne	.+2      	; 0xfa84 <conv_flt+0x19c>
    fa82:	72 c0       	rjmp	.+228    	; 0xfb68 <conv_flt+0x280>
    fa84:	c3 01       	movw	r24, r6
    fa86:	0e 94 7b 81 	call	0x102f6	; 0x102f6 <fgetc>
    fa8a:	ec 01       	movw	r28, r24
    fa8c:	ce 01       	movw	r24, r28
    fa8e:	c0 97       	sbiw	r24, 0x30	; 48
    fa90:	0a 97       	sbiw	r24, 0x0a	; 10
    fa92:	08 f0       	brcs	.+2      	; 0xfa96 <conv_flt+0x1ae>
    fa94:	69 c0       	rjmp	.+210    	; 0xfb68 <conv_flt+0x280>
    fa96:	00 e0       	ldi	r16, 0x00	; 0
    fa98:	10 e0       	ldi	r17, 0x00	; 0
    fa9a:	b8 01       	movw	r22, r16
    fa9c:	88 27       	eor	r24, r24
    fa9e:	77 fd       	sbrc	r23, 7
    faa0:	80 95       	com	r24
    faa2:	98 2f       	mov	r25, r24
    faa4:	ae 01       	movw	r20, r28
    faa6:	40 53       	subi	r20, 0x30	; 48
    faa8:	24 2f       	mov	r18, r20
    faaa:	40 e2       	ldi	r20, 0x20	; 32
    faac:	0e 94 cc 7a 	call	0xf598	; 0xf598 <mulacc>
    fab0:	8b 01       	movw	r16, r22
    fab2:	08 94       	sec
    fab4:	e1 08       	sbc	r14, r1
    fab6:	f1 08       	sbc	r15, r1
    fab8:	e1 14       	cp	r14, r1
    faba:	f1 04       	cpc	r15, r1
    fabc:	39 f0       	breq	.+14     	; 0xfacc <conv_flt+0x1e4>
    fabe:	c3 01       	movw	r24, r6
    fac0:	0e 94 7b 81 	call	0x102f6	; 0x102f6 <fgetc>
    fac4:	ec 01       	movw	r28, r24
    fac6:	c0 97       	sbiw	r24, 0x30	; 48
    fac8:	0a 97       	sbiw	r24, 0x0a	; 10
    faca:	38 f3       	brcs	.-50     	; 0xfa9a <conv_flt+0x1b2>
    facc:	b8 01       	movw	r22, r16
    face:	54 fe       	sbrs	r5, 4
    fad0:	03 c0       	rjmp	.+6      	; 0xfad8 <conv_flt+0x1f0>
    fad2:	70 95       	com	r23
    fad4:	61 95       	neg	r22
    fad6:	7f 4f       	sbci	r23, 0xFF	; 255
    fad8:	c6 0e       	add	r12, r22
    fada:	d7 1e       	adc	r13, r23
    fadc:	ef 28       	or	r14, r15
    fade:	31 f0       	breq	.+12     	; 0xfaec <conv_flt+0x204>
    fae0:	d7 fd       	sbrc	r29, 7
    fae2:	04 c0       	rjmp	.+8      	; 0xfaec <conv_flt+0x204>
    fae4:	ce 01       	movw	r24, r28
    fae6:	b3 01       	movw	r22, r6
    fae8:	0e 94 91 82 	call	0x10522	; 0x10522 <ungetc>
    faec:	c5 01       	movw	r24, r10
    faee:	b4 01       	movw	r22, r8
    faf0:	0e 94 06 7f 	call	0xfe0c	; 0xfe0c <__floatunsisf>
    faf4:	d7 fe       	sbrs	r13, 7
    faf6:	0d c0       	rjmp	.+26     	; 0xfb12 <conv_flt+0x22a>
    faf8:	a7 e0       	ldi	r26, 0x07	; 7
    fafa:	ea 2e       	mov	r14, r26
    fafc:	a3 e0       	ldi	r26, 0x03	; 3
    fafe:	fa 2e       	mov	r15, r26
    fb00:	d0 94       	com	r13
    fb02:	c1 94       	neg	r12
    fb04:	d1 08       	sbc	r13, r1
    fb06:	d3 94       	inc	r13
    fb08:	c0 e2       	ldi	r28, 0x20	; 32
    fb0a:	d0 e0       	ldi	r29, 0x00	; 0
    fb0c:	00 e0       	ldi	r16, 0x00	; 0
    fb0e:	10 e0       	ldi	r17, 0x00	; 0
    fb10:	0e c0       	rjmp	.+28     	; 0xfb2e <conv_flt+0x246>
    fb12:	ff e1       	ldi	r31, 0x1F	; 31
    fb14:	ef 2e       	mov	r14, r31
    fb16:	f3 e0       	ldi	r31, 0x03	; 3
    fb18:	ff 2e       	mov	r15, r31
    fb1a:	f6 cf       	rjmp	.-20     	; 0xfb08 <conv_flt+0x220>
    fb1c:	f7 01       	movw	r30, r14
    fb1e:	25 91       	lpm	r18, Z+
    fb20:	35 91       	lpm	r19, Z+
    fb22:	45 91       	lpm	r20, Z+
    fb24:	54 91       	lpm	r21, Z+
    fb26:	0e 94 43 7f 	call	0xfe86	; 0xfe86 <__mulsf3>
    fb2a:	cc 1a       	sub	r12, r28
    fb2c:	dd 0a       	sbc	r13, r29
    fb2e:	cc 16       	cp	r12, r28
    fb30:	dd 06       	cpc	r13, r29
    fb32:	a0 f7       	brcc	.-24     	; 0xfb1c <conv_flt+0x234>
    fb34:	d6 95       	lsr	r29
    fb36:	c7 95       	ror	r28
    fb38:	0f 5f       	subi	r16, 0xFF	; 255
    fb3a:	1f 4f       	sbci	r17, 0xFF	; 255
    fb3c:	06 30       	cpi	r16, 0x06	; 6
    fb3e:	11 05       	cpc	r17, r1
    fb40:	29 f0       	breq	.+10     	; 0xfb4c <conv_flt+0x264>
    fb42:	ec ef       	ldi	r30, 0xFC	; 252
    fb44:	ff ef       	ldi	r31, 0xFF	; 255
    fb46:	ee 0e       	add	r14, r30
    fb48:	ff 1e       	adc	r15, r31
    fb4a:	f1 cf       	rjmp	.-30     	; 0xfb2e <conv_flt+0x246>
    fb4c:	dc 01       	movw	r26, r24
    fb4e:	cb 01       	movw	r24, r22
    fb50:	57 fc       	sbrc	r5, 7
    fb52:	b0 58       	subi	r27, 0x80	; 128
    fb54:	21 14       	cp	r2, r1
    fb56:	31 04       	cpc	r3, r1
    fb58:	29 f0       	breq	.+10     	; 0xfb64 <conv_flt+0x27c>
    fb5a:	f1 01       	movw	r30, r2
    fb5c:	80 83       	st	Z, r24
    fb5e:	91 83       	std	Z+1, r25	; 0x01
    fb60:	a2 83       	std	Z+2, r26	; 0x02
    fb62:	b3 83       	std	Z+3, r27	; 0x03
    fb64:	81 e0       	ldi	r24, 0x01	; 1
    fb66:	01 c0       	rjmp	.+2      	; 0xfb6a <conv_flt+0x282>
    fb68:	80 e0       	ldi	r24, 0x00	; 0
    fb6a:	df 91       	pop	r29
    fb6c:	cf 91       	pop	r28
    fb6e:	1f 91       	pop	r17
    fb70:	0f 91       	pop	r16
    fb72:	ff 90       	pop	r15
    fb74:	ef 90       	pop	r14
    fb76:	df 90       	pop	r13
    fb78:	cf 90       	pop	r12
    fb7a:	bf 90       	pop	r11
    fb7c:	af 90       	pop	r10
    fb7e:	9f 90       	pop	r9
    fb80:	8f 90       	pop	r8
    fb82:	7f 90       	pop	r7
    fb84:	6f 90       	pop	r6
    fb86:	5f 90       	pop	r5
    fb88:	3f 90       	pop	r3
    fb8a:	2f 90       	pop	r2
    fb8c:	08 95       	ret

0000fb8e <vfscanf>:
    fb8e:	5f 92       	push	r5
    fb90:	6f 92       	push	r6
    fb92:	7f 92       	push	r7
    fb94:	8f 92       	push	r8
    fb96:	9f 92       	push	r9
    fb98:	af 92       	push	r10
    fb9a:	bf 92       	push	r11
    fb9c:	cf 92       	push	r12
    fb9e:	df 92       	push	r13
    fba0:	ef 92       	push	r14
    fba2:	ff 92       	push	r15
    fba4:	0f 93       	push	r16
    fba6:	1f 93       	push	r17
    fba8:	cf 93       	push	r28
    fbaa:	df 93       	push	r29
    fbac:	4c 01       	movw	r8, r24
    fbae:	5b 01       	movw	r10, r22
    fbb0:	3a 01       	movw	r6, r20
    fbb2:	fc 01       	movw	r30, r24
    fbb4:	17 82       	std	Z+7, r1	; 0x07
    fbb6:	16 82       	std	Z+6, r1	; 0x06
    fbb8:	55 24       	eor	r5, r5
    fbba:	04 c1       	rjmp	.+520    	; 0xfdc4 <vfscanf+0x236>
    fbbc:	81 2f       	mov	r24, r17
    fbbe:	90 e0       	ldi	r25, 0x00	; 0
    fbc0:	0e 94 d2 80 	call	0x101a4	; 0x101a4 <isspace>
    fbc4:	89 2b       	or	r24, r25
    fbc6:	21 f0       	breq	.+8      	; 0xfbd0 <vfscanf+0x42>
    fbc8:	c4 01       	movw	r24, r8
    fbca:	0e 94 fa 7a 	call	0xf5f4	; 0xf5f4 <skip_spaces>
    fbce:	fa c0       	rjmp	.+500    	; 0xfdc4 <vfscanf+0x236>
    fbd0:	15 32       	cpi	r17, 0x25	; 37
    fbd2:	49 f4       	brne	.+18     	; 0xfbe6 <vfscanf+0x58>
    fbd4:	f5 01       	movw	r30, r10
    fbd6:	f3 fc       	sbrc	r15, 3
    fbd8:	65 91       	lpm	r22, Z+
    fbda:	f3 fe       	sbrs	r15, 3
    fbdc:	61 91       	ld	r22, Z+
    fbde:	5f 01       	movw	r10, r30
    fbe0:	65 32       	cpi	r22, 0x25	; 37
    fbe2:	69 f4       	brne	.+26     	; 0xfbfe <vfscanf+0x70>
    fbe4:	15 e2       	ldi	r17, 0x25	; 37
    fbe6:	c4 01       	movw	r24, r8
    fbe8:	0e 94 7b 81 	call	0x102f6	; 0x102f6 <fgetc>
    fbec:	97 fd       	sbrc	r25, 7
    fbee:	f6 c0       	rjmp	.+492    	; 0xfddc <vfscanf+0x24e>
    fbf0:	18 17       	cp	r17, r24
    fbf2:	09 f4       	brne	.+2      	; 0xfbf6 <vfscanf+0x68>
    fbf4:	e7 c0       	rjmp	.+462    	; 0xfdc4 <vfscanf+0x236>
    fbf6:	b4 01       	movw	r22, r8
    fbf8:	0e 94 91 82 	call	0x10522	; 0x10522 <ungetc>
    fbfc:	f4 c0       	rjmp	.+488    	; 0xfde6 <vfscanf+0x258>
    fbfe:	6a 32       	cpi	r22, 0x2A	; 42
    fc00:	19 f0       	breq	.+6      	; 0xfc08 <vfscanf+0x7a>
    fc02:	16 2f       	mov	r17, r22
    fc04:	00 e0       	ldi	r16, 0x00	; 0
    fc06:	06 c0       	rjmp	.+12     	; 0xfc14 <vfscanf+0x86>
    fc08:	f3 fc       	sbrc	r15, 3
    fc0a:	15 91       	lpm	r17, Z+
    fc0c:	f3 fe       	sbrs	r15, 3
    fc0e:	11 91       	ld	r17, Z+
    fc10:	5f 01       	movw	r10, r30
    fc12:	01 e0       	ldi	r16, 0x01	; 1
    fc14:	cc 24       	eor	r12, r12
    fc16:	dd 24       	eor	r13, r13
    fc18:	0e c0       	rjmp	.+28     	; 0xfc36 <vfscanf+0xa8>
    fc1a:	02 60       	ori	r16, 0x02	; 2
    fc1c:	b6 01       	movw	r22, r12
    fc1e:	80 e0       	ldi	r24, 0x00	; 0
    fc20:	90 e0       	ldi	r25, 0x00	; 0
    fc22:	40 e2       	ldi	r20, 0x20	; 32
    fc24:	0e 94 cc 7a 	call	0xf598	; 0xf598 <mulacc>
    fc28:	6b 01       	movw	r12, r22
    fc2a:	f5 01       	movw	r30, r10
    fc2c:	f3 fc       	sbrc	r15, 3
    fc2e:	15 91       	lpm	r17, Z+
    fc30:	f3 fe       	sbrs	r15, 3
    fc32:	11 91       	ld	r17, Z+
    fc34:	5f 01       	movw	r10, r30
    fc36:	21 2f       	mov	r18, r17
    fc38:	20 53       	subi	r18, 0x30	; 48
    fc3a:	2a 30       	cpi	r18, 0x0A	; 10
    fc3c:	70 f3       	brcs	.-36     	; 0xfc1a <vfscanf+0x8c>
    fc3e:	01 fd       	sbrc	r16, 1
    fc40:	04 c0       	rjmp	.+8      	; 0xfc4a <vfscanf+0xbc>
    fc42:	cc 24       	eor	r12, r12
    fc44:	ca 94       	dec	r12
    fc46:	dc 2c       	mov	r13, r12
    fc48:	04 c0       	rjmp	.+8      	; 0xfc52 <vfscanf+0xc4>
    fc4a:	c1 14       	cp	r12, r1
    fc4c:	d1 04       	cpc	r13, r1
    fc4e:	09 f4       	brne	.+2      	; 0xfc52 <vfscanf+0xc4>
    fc50:	ca c0       	rjmp	.+404    	; 0xfde6 <vfscanf+0x258>
    fc52:	18 36       	cpi	r17, 0x68	; 104
    fc54:	21 f0       	breq	.+8      	; 0xfc5e <vfscanf+0xd0>
    fc56:	1c 36       	cpi	r17, 0x6C	; 108
    fc58:	99 f4       	brne	.+38     	; 0xfc80 <vfscanf+0xf2>
    fc5a:	f5 01       	movw	r30, r10
    fc5c:	0b c0       	rjmp	.+22     	; 0xfc74 <vfscanf+0xe6>
    fc5e:	f5 01       	movw	r30, r10
    fc60:	f3 fc       	sbrc	r15, 3
    fc62:	65 91       	lpm	r22, Z+
    fc64:	f3 fe       	sbrs	r15, 3
    fc66:	61 91       	ld	r22, Z+
    fc68:	68 36       	cpi	r22, 0x68	; 104
    fc6a:	19 f0       	breq	.+6      	; 0xfc72 <vfscanf+0xe4>
    fc6c:	5f 01       	movw	r10, r30
    fc6e:	16 2f       	mov	r17, r22
    fc70:	07 c0       	rjmp	.+14     	; 0xfc80 <vfscanf+0xf2>
    fc72:	08 60       	ori	r16, 0x08	; 8
    fc74:	04 60       	ori	r16, 0x04	; 4
    fc76:	f3 fc       	sbrc	r15, 3
    fc78:	15 91       	lpm	r17, Z+
    fc7a:	f3 fe       	sbrs	r15, 3
    fc7c:	11 91       	ld	r17, Z+
    fc7e:	5f 01       	movw	r10, r30
    fc80:	11 23       	and	r17, r17
    fc82:	09 f4       	brne	.+2      	; 0xfc86 <vfscanf+0xf8>
    fc84:	b0 c0       	rjmp	.+352    	; 0xfde6 <vfscanf+0x258>
    fc86:	86 ed       	ldi	r24, 0xD6	; 214
    fc88:	92 e0       	ldi	r25, 0x02	; 2
    fc8a:	61 2f       	mov	r22, r17
    fc8c:	70 e0       	ldi	r23, 0x00	; 0
    fc8e:	0e 94 e2 80 	call	0x101c4	; 0x101c4 <strchr_P>
    fc92:	89 2b       	or	r24, r25
    fc94:	09 f4       	brne	.+2      	; 0xfc98 <vfscanf+0x10a>
    fc96:	a7 c0       	rjmp	.+334    	; 0xfde6 <vfscanf+0x258>
    fc98:	80 2f       	mov	r24, r16
    fc9a:	00 ff       	sbrs	r16, 0
    fc9c:	03 c0       	rjmp	.+6      	; 0xfca4 <vfscanf+0x116>
    fc9e:	ee 24       	eor	r14, r14
    fca0:	ff 24       	eor	r15, r15
    fca2:	07 c0       	rjmp	.+14     	; 0xfcb2 <vfscanf+0x124>
    fca4:	f3 01       	movw	r30, r6
    fca6:	e0 80       	ld	r14, Z
    fca8:	f1 80       	ldd	r15, Z+1	; 0x01
    fcaa:	22 e0       	ldi	r18, 0x02	; 2
    fcac:	30 e0       	ldi	r19, 0x00	; 0
    fcae:	62 0e       	add	r6, r18
    fcb0:	73 1e       	adc	r7, r19
    fcb2:	1e 36       	cpi	r17, 0x6E	; 110
    fcb4:	51 f4       	brne	.+20     	; 0xfcca <vfscanf+0x13c>
    fcb6:	f4 01       	movw	r30, r8
    fcb8:	46 81       	ldd	r20, Z+6	; 0x06
    fcba:	57 81       	ldd	r21, Z+7	; 0x07
    fcbc:	60 e0       	ldi	r22, 0x00	; 0
    fcbe:	70 e0       	ldi	r23, 0x00	; 0
    fcc0:	c7 01       	movw	r24, r14
    fcc2:	20 2f       	mov	r18, r16
    fcc4:	0e 94 c0 7a 	call	0xf580	; 0xf580 <putval>
    fcc8:	7d c0       	rjmp	.+250    	; 0xfdc4 <vfscanf+0x236>
    fcca:	13 36       	cpi	r17, 0x63	; 99
    fccc:	b9 f4       	brne	.+46     	; 0xfcfc <vfscanf+0x16e>
    fcce:	81 fd       	sbrc	r24, 1
    fcd0:	03 c0       	rjmp	.+6      	; 0xfcd8 <vfscanf+0x14a>
    fcd2:	11 e0       	ldi	r17, 0x01	; 1
    fcd4:	c1 2e       	mov	r12, r17
    fcd6:	d1 2c       	mov	r13, r1
    fcd8:	c4 01       	movw	r24, r8
    fcda:	0e 94 7b 81 	call	0x102f6	; 0x102f6 <fgetc>
    fcde:	97 fd       	sbrc	r25, 7
    fce0:	7d c0       	rjmp	.+250    	; 0xfddc <vfscanf+0x24e>
    fce2:	e1 14       	cp	r14, r1
    fce4:	f1 04       	cpc	r15, r1
    fce6:	19 f0       	breq	.+6      	; 0xfcee <vfscanf+0x160>
    fce8:	f7 01       	movw	r30, r14
    fcea:	81 93       	st	Z+, r24
    fcec:	7f 01       	movw	r14, r30
    fcee:	08 94       	sec
    fcf0:	c1 08       	sbc	r12, r1
    fcf2:	d1 08       	sbc	r13, r1
    fcf4:	c1 14       	cp	r12, r1
    fcf6:	d1 04       	cpc	r13, r1
    fcf8:	79 f7       	brne	.-34     	; 0xfcd8 <vfscanf+0x14a>
    fcfa:	62 c0       	rjmp	.+196    	; 0xfdc0 <vfscanf+0x232>
    fcfc:	1b 35       	cpi	r17, 0x5B	; 91
    fcfe:	59 f4       	brne	.+22     	; 0xfd16 <vfscanf+0x188>
    fd00:	c4 01       	movw	r24, r8
    fd02:	b6 01       	movw	r22, r12
    fd04:	a7 01       	movw	r20, r14
    fd06:	95 01       	movw	r18, r10
    fd08:	0e 94 a7 7b 	call	0xf74e	; 0xf74e <conv_brk>
    fd0c:	5c 01       	movw	r10, r24
    fd0e:	00 97       	sbiw	r24, 0x00	; 0
    fd10:	09 f0       	breq	.+2      	; 0xfd14 <vfscanf+0x186>
    fd12:	56 c0       	rjmp	.+172    	; 0xfdc0 <vfscanf+0x232>
    fd14:	50 c0       	rjmp	.+160    	; 0xfdb6 <vfscanf+0x228>
    fd16:	c4 01       	movw	r24, r8
    fd18:	0e 94 fa 7a 	call	0xf5f4	; 0xf5f4 <skip_spaces>
    fd1c:	97 fd       	sbrc	r25, 7
    fd1e:	5e c0       	rjmp	.+188    	; 0xfddc <vfscanf+0x24e>
    fd20:	1f 36       	cpi	r17, 0x6F	; 111
    fd22:	d1 f1       	breq	.+116    	; 0xfd98 <vfscanf+0x20a>
    fd24:	10 37       	cpi	r17, 0x70	; 112
    fd26:	38 f4       	brcc	.+14     	; 0xfd36 <vfscanf+0x1a8>
    fd28:	14 36       	cpi	r17, 0x64	; 100
    fd2a:	a1 f1       	breq	.+104    	; 0xfd94 <vfscanf+0x206>
    fd2c:	19 36       	cpi	r17, 0x69	; 105
    fd2e:	a9 f1       	breq	.+106    	; 0xfd9a <vfscanf+0x20c>
    fd30:	18 35       	cpi	r17, 0x58	; 88
    fd32:	d1 f5       	brne	.+116    	; 0xfda8 <vfscanf+0x21a>
    fd34:	2d c0       	rjmp	.+90     	; 0xfd90 <vfscanf+0x202>
    fd36:	13 37       	cpi	r17, 0x73	; 115
    fd38:	51 f0       	breq	.+20     	; 0xfd4e <vfscanf+0x1c0>
    fd3a:	14 37       	cpi	r17, 0x74	; 116
    fd3c:	18 f4       	brcc	.+6      	; 0xfd44 <vfscanf+0x1b6>
    fd3e:	10 37       	cpi	r17, 0x70	; 112
    fd40:	99 f5       	brne	.+102    	; 0xfda8 <vfscanf+0x21a>
    fd42:	26 c0       	rjmp	.+76     	; 0xfd90 <vfscanf+0x202>
    fd44:	15 37       	cpi	r17, 0x75	; 117
    fd46:	31 f1       	breq	.+76     	; 0xfd94 <vfscanf+0x206>
    fd48:	18 37       	cpi	r17, 0x78	; 120
    fd4a:	71 f5       	brne	.+92     	; 0xfda8 <vfscanf+0x21a>
    fd4c:	21 c0       	rjmp	.+66     	; 0xfd90 <vfscanf+0x202>
    fd4e:	c4 01       	movw	r24, r8
    fd50:	0e 94 7b 81 	call	0x102f6	; 0x102f6 <fgetc>
    fd54:	ec 01       	movw	r28, r24
    fd56:	97 fd       	sbrc	r25, 7
    fd58:	15 c0       	rjmp	.+42     	; 0xfd84 <vfscanf+0x1f6>
    fd5a:	0e 94 d2 80 	call	0x101a4	; 0x101a4 <isspace>
    fd5e:	89 2b       	or	r24, r25
    fd60:	29 f0       	breq	.+10     	; 0xfd6c <vfscanf+0x1de>
    fd62:	ce 01       	movw	r24, r28
    fd64:	b4 01       	movw	r22, r8
    fd66:	0e 94 91 82 	call	0x10522	; 0x10522 <ungetc>
    fd6a:	0c c0       	rjmp	.+24     	; 0xfd84 <vfscanf+0x1f6>
    fd6c:	e1 14       	cp	r14, r1
    fd6e:	f1 04       	cpc	r15, r1
    fd70:	19 f0       	breq	.+6      	; 0xfd78 <vfscanf+0x1ea>
    fd72:	f7 01       	movw	r30, r14
    fd74:	c1 93       	st	Z+, r28
    fd76:	7f 01       	movw	r14, r30
    fd78:	08 94       	sec
    fd7a:	c1 08       	sbc	r12, r1
    fd7c:	d1 08       	sbc	r13, r1
    fd7e:	c1 14       	cp	r12, r1
    fd80:	d1 04       	cpc	r13, r1
    fd82:	29 f7       	brne	.-54     	; 0xfd4e <vfscanf+0x1c0>
    fd84:	e1 14       	cp	r14, r1
    fd86:	f1 04       	cpc	r15, r1
    fd88:	d9 f0       	breq	.+54     	; 0xfdc0 <vfscanf+0x232>
    fd8a:	f7 01       	movw	r30, r14
    fd8c:	10 82       	st	Z, r1
    fd8e:	18 c0       	rjmp	.+48     	; 0xfdc0 <vfscanf+0x232>
    fd90:	00 64       	ori	r16, 0x40	; 64
    fd92:	03 c0       	rjmp	.+6      	; 0xfd9a <vfscanf+0x20c>
    fd94:	00 62       	ori	r16, 0x20	; 32
    fd96:	01 c0       	rjmp	.+2      	; 0xfd9a <vfscanf+0x20c>
    fd98:	00 61       	ori	r16, 0x10	; 16
    fd9a:	c4 01       	movw	r24, r8
    fd9c:	b6 01       	movw	r22, r12
    fd9e:	a7 01       	movw	r20, r14
    fda0:	20 2f       	mov	r18, r16
    fda2:	0e 94 13 7b 	call	0xf626	; 0xf626 <conv_int>
    fda6:	05 c0       	rjmp	.+10     	; 0xfdb2 <vfscanf+0x224>
    fda8:	c4 01       	movw	r24, r8
    fdaa:	b6 01       	movw	r22, r12
    fdac:	a7 01       	movw	r20, r14
    fdae:	0e 94 74 7c 	call	0xf8e8	; 0xf8e8 <conv_flt>
    fdb2:	88 23       	and	r24, r24
    fdb4:	29 f4       	brne	.+10     	; 0xfdc0 <vfscanf+0x232>
    fdb6:	f4 01       	movw	r30, r8
    fdb8:	83 81       	ldd	r24, Z+3	; 0x03
    fdba:	80 73       	andi	r24, 0x30	; 48
    fdbc:	79 f4       	brne	.+30     	; 0xfddc <vfscanf+0x24e>
    fdbe:	13 c0       	rjmp	.+38     	; 0xfde6 <vfscanf+0x258>
    fdc0:	00 ff       	sbrs	r16, 0
    fdc2:	53 94       	inc	r5
    fdc4:	f4 01       	movw	r30, r8
    fdc6:	f3 80       	ldd	r15, Z+3	; 0x03
    fdc8:	f5 01       	movw	r30, r10
    fdca:	f3 fc       	sbrc	r15, 3
    fdcc:	15 91       	lpm	r17, Z+
    fdce:	f3 fe       	sbrs	r15, 3
    fdd0:	11 91       	ld	r17, Z+
    fdd2:	5f 01       	movw	r10, r30
    fdd4:	11 23       	and	r17, r17
    fdd6:	09 f0       	breq	.+2      	; 0xfdda <vfscanf+0x24c>
    fdd8:	f1 ce       	rjmp	.-542    	; 0xfbbc <vfscanf+0x2e>
    fdda:	05 c0       	rjmp	.+10     	; 0xfde6 <vfscanf+0x258>
    fddc:	55 20       	and	r5, r5
    fdde:	19 f4       	brne	.+6      	; 0xfde6 <vfscanf+0x258>
    fde0:	2f ef       	ldi	r18, 0xFF	; 255
    fde2:	3f ef       	ldi	r19, 0xFF	; 255
    fde4:	02 c0       	rjmp	.+4      	; 0xfdea <vfscanf+0x25c>
    fde6:	25 2d       	mov	r18, r5
    fde8:	30 e0       	ldi	r19, 0x00	; 0
    fdea:	c9 01       	movw	r24, r18
    fdec:	df 91       	pop	r29
    fdee:	cf 91       	pop	r28
    fdf0:	1f 91       	pop	r17
    fdf2:	0f 91       	pop	r16
    fdf4:	ff 90       	pop	r15
    fdf6:	ef 90       	pop	r14
    fdf8:	df 90       	pop	r13
    fdfa:	cf 90       	pop	r12
    fdfc:	bf 90       	pop	r11
    fdfe:	af 90       	pop	r10
    fe00:	9f 90       	pop	r9
    fe02:	8f 90       	pop	r8
    fe04:	7f 90       	pop	r7
    fe06:	6f 90       	pop	r6
    fe08:	5f 90       	pop	r5
    fe0a:	08 95       	ret

0000fe0c <__floatunsisf>:
    fe0c:	e8 94       	clt
    fe0e:	09 c0       	rjmp	.+18     	; 0xfe22 <__floatsisf+0x12>

0000fe10 <__floatsisf>:
    fe10:	97 fb       	bst	r25, 7
    fe12:	3e f4       	brtc	.+14     	; 0xfe22 <__floatsisf+0x12>
    fe14:	90 95       	com	r25
    fe16:	80 95       	com	r24
    fe18:	70 95       	com	r23
    fe1a:	61 95       	neg	r22
    fe1c:	7f 4f       	sbci	r23, 0xFF	; 255
    fe1e:	8f 4f       	sbci	r24, 0xFF	; 255
    fe20:	9f 4f       	sbci	r25, 0xFF	; 255
    fe22:	99 23       	and	r25, r25
    fe24:	a9 f0       	breq	.+42     	; 0xfe50 <__floatsisf+0x40>
    fe26:	f9 2f       	mov	r31, r25
    fe28:	96 e9       	ldi	r25, 0x96	; 150
    fe2a:	bb 27       	eor	r27, r27
    fe2c:	93 95       	inc	r25
    fe2e:	f6 95       	lsr	r31
    fe30:	87 95       	ror	r24
    fe32:	77 95       	ror	r23
    fe34:	67 95       	ror	r22
    fe36:	b7 95       	ror	r27
    fe38:	f1 11       	cpse	r31, r1
    fe3a:	f8 cf       	rjmp	.-16     	; 0xfe2c <__floatsisf+0x1c>
    fe3c:	fa f4       	brpl	.+62     	; 0xfe7c <__floatsisf+0x6c>
    fe3e:	bb 0f       	add	r27, r27
    fe40:	11 f4       	brne	.+4      	; 0xfe46 <__floatsisf+0x36>
    fe42:	60 ff       	sbrs	r22, 0
    fe44:	1b c0       	rjmp	.+54     	; 0xfe7c <__floatsisf+0x6c>
    fe46:	6f 5f       	subi	r22, 0xFF	; 255
    fe48:	7f 4f       	sbci	r23, 0xFF	; 255
    fe4a:	8f 4f       	sbci	r24, 0xFF	; 255
    fe4c:	9f 4f       	sbci	r25, 0xFF	; 255
    fe4e:	16 c0       	rjmp	.+44     	; 0xfe7c <__floatsisf+0x6c>
    fe50:	88 23       	and	r24, r24
    fe52:	11 f0       	breq	.+4      	; 0xfe58 <__floatsisf+0x48>
    fe54:	96 e9       	ldi	r25, 0x96	; 150
    fe56:	11 c0       	rjmp	.+34     	; 0xfe7a <__floatsisf+0x6a>
    fe58:	77 23       	and	r23, r23
    fe5a:	21 f0       	breq	.+8      	; 0xfe64 <__floatsisf+0x54>
    fe5c:	9e e8       	ldi	r25, 0x8E	; 142
    fe5e:	87 2f       	mov	r24, r23
    fe60:	76 2f       	mov	r23, r22
    fe62:	05 c0       	rjmp	.+10     	; 0xfe6e <__floatsisf+0x5e>
    fe64:	66 23       	and	r22, r22
    fe66:	71 f0       	breq	.+28     	; 0xfe84 <__floatsisf+0x74>
    fe68:	96 e8       	ldi	r25, 0x86	; 134
    fe6a:	86 2f       	mov	r24, r22
    fe6c:	70 e0       	ldi	r23, 0x00	; 0
    fe6e:	60 e0       	ldi	r22, 0x00	; 0
    fe70:	2a f0       	brmi	.+10     	; 0xfe7c <__floatsisf+0x6c>
    fe72:	9a 95       	dec	r25
    fe74:	66 0f       	add	r22, r22
    fe76:	77 1f       	adc	r23, r23
    fe78:	88 1f       	adc	r24, r24
    fe7a:	da f7       	brpl	.-10     	; 0xfe72 <__floatsisf+0x62>
    fe7c:	88 0f       	add	r24, r24
    fe7e:	96 95       	lsr	r25
    fe80:	87 95       	ror	r24
    fe82:	97 f9       	bld	r25, 7
    fe84:	08 95       	ret

0000fe86 <__mulsf3>:
    fe86:	0b d0       	rcall	.+22     	; 0xfe9e <__mulsf3x>
    fe88:	78 c0       	rjmp	.+240    	; 0xff7a <__fp_round>
    fe8a:	69 d0       	rcall	.+210    	; 0xff5e <__fp_pscA>
    fe8c:	28 f0       	brcs	.+10     	; 0xfe98 <__mulsf3+0x12>
    fe8e:	6e d0       	rcall	.+220    	; 0xff6c <__fp_pscB>
    fe90:	18 f0       	brcs	.+6      	; 0xfe98 <__mulsf3+0x12>
    fe92:	95 23       	and	r25, r21
    fe94:	09 f0       	breq	.+2      	; 0xfe98 <__mulsf3+0x12>
    fe96:	5a c0       	rjmp	.+180    	; 0xff4c <__fp_inf>
    fe98:	5f c0       	rjmp	.+190    	; 0xff58 <__fp_nan>
    fe9a:	11 24       	eor	r1, r1
    fe9c:	a2 c0       	rjmp	.+324    	; 0xffe2 <__fp_szero>

0000fe9e <__mulsf3x>:
    fe9e:	7e d0       	rcall	.+252    	; 0xff9c <__fp_split3>
    fea0:	a0 f3       	brcs	.-24     	; 0xfe8a <__mulsf3+0x4>

0000fea2 <__mulsf3_pse>:
    fea2:	95 9f       	mul	r25, r21
    fea4:	d1 f3       	breq	.-12     	; 0xfe9a <__mulsf3+0x14>
    fea6:	95 0f       	add	r25, r21
    fea8:	50 e0       	ldi	r21, 0x00	; 0
    feaa:	55 1f       	adc	r21, r21
    feac:	62 9f       	mul	r22, r18
    feae:	f0 01       	movw	r30, r0
    feb0:	72 9f       	mul	r23, r18
    feb2:	bb 27       	eor	r27, r27
    feb4:	f0 0d       	add	r31, r0
    feb6:	b1 1d       	adc	r27, r1
    feb8:	63 9f       	mul	r22, r19
    feba:	aa 27       	eor	r26, r26
    febc:	f0 0d       	add	r31, r0
    febe:	b1 1d       	adc	r27, r1
    fec0:	aa 1f       	adc	r26, r26
    fec2:	64 9f       	mul	r22, r20
    fec4:	66 27       	eor	r22, r22
    fec6:	b0 0d       	add	r27, r0
    fec8:	a1 1d       	adc	r26, r1
    feca:	66 1f       	adc	r22, r22
    fecc:	82 9f       	mul	r24, r18
    fece:	22 27       	eor	r18, r18
    fed0:	b0 0d       	add	r27, r0
    fed2:	a1 1d       	adc	r26, r1
    fed4:	62 1f       	adc	r22, r18
    fed6:	73 9f       	mul	r23, r19
    fed8:	b0 0d       	add	r27, r0
    feda:	a1 1d       	adc	r26, r1
    fedc:	62 1f       	adc	r22, r18
    fede:	83 9f       	mul	r24, r19
    fee0:	a0 0d       	add	r26, r0
    fee2:	61 1d       	adc	r22, r1
    fee4:	22 1f       	adc	r18, r18
    fee6:	74 9f       	mul	r23, r20
    fee8:	33 27       	eor	r19, r19
    feea:	a0 0d       	add	r26, r0
    feec:	61 1d       	adc	r22, r1
    feee:	23 1f       	adc	r18, r19
    fef0:	84 9f       	mul	r24, r20
    fef2:	60 0d       	add	r22, r0
    fef4:	21 1d       	adc	r18, r1
    fef6:	82 2f       	mov	r24, r18
    fef8:	76 2f       	mov	r23, r22
    fefa:	6a 2f       	mov	r22, r26
    fefc:	11 24       	eor	r1, r1
    fefe:	9f 57       	subi	r25, 0x7F	; 127
    ff00:	50 40       	sbci	r21, 0x00	; 0
    ff02:	8a f0       	brmi	.+34     	; 0xff26 <__mulsf3_pse+0x84>
    ff04:	e1 f0       	breq	.+56     	; 0xff3e <__mulsf3_pse+0x9c>
    ff06:	88 23       	and	r24, r24
    ff08:	4a f0       	brmi	.+18     	; 0xff1c <__mulsf3_pse+0x7a>
    ff0a:	ee 0f       	add	r30, r30
    ff0c:	ff 1f       	adc	r31, r31
    ff0e:	bb 1f       	adc	r27, r27
    ff10:	66 1f       	adc	r22, r22
    ff12:	77 1f       	adc	r23, r23
    ff14:	88 1f       	adc	r24, r24
    ff16:	91 50       	subi	r25, 0x01	; 1
    ff18:	50 40       	sbci	r21, 0x00	; 0
    ff1a:	a9 f7       	brne	.-22     	; 0xff06 <__mulsf3_pse+0x64>
    ff1c:	9e 3f       	cpi	r25, 0xFE	; 254
    ff1e:	51 05       	cpc	r21, r1
    ff20:	70 f0       	brcs	.+28     	; 0xff3e <__mulsf3_pse+0x9c>
    ff22:	14 c0       	rjmp	.+40     	; 0xff4c <__fp_inf>
    ff24:	5e c0       	rjmp	.+188    	; 0xffe2 <__fp_szero>
    ff26:	5f 3f       	cpi	r21, 0xFF	; 255
    ff28:	ec f3       	brlt	.-6      	; 0xff24 <__mulsf3_pse+0x82>
    ff2a:	98 3e       	cpi	r25, 0xE8	; 232
    ff2c:	dc f3       	brlt	.-10     	; 0xff24 <__mulsf3_pse+0x82>
    ff2e:	86 95       	lsr	r24
    ff30:	77 95       	ror	r23
    ff32:	67 95       	ror	r22
    ff34:	b7 95       	ror	r27
    ff36:	f7 95       	ror	r31
    ff38:	e7 95       	ror	r30
    ff3a:	9f 5f       	subi	r25, 0xFF	; 255
    ff3c:	c1 f7       	brne	.-16     	; 0xff2e <__mulsf3_pse+0x8c>
    ff3e:	fe 2b       	or	r31, r30
    ff40:	88 0f       	add	r24, r24
    ff42:	91 1d       	adc	r25, r1
    ff44:	96 95       	lsr	r25
    ff46:	87 95       	ror	r24
    ff48:	97 f9       	bld	r25, 7
    ff4a:	08 95       	ret

0000ff4c <__fp_inf>:
    ff4c:	97 f9       	bld	r25, 7
    ff4e:	9f 67       	ori	r25, 0x7F	; 127
    ff50:	80 e8       	ldi	r24, 0x80	; 128
    ff52:	70 e0       	ldi	r23, 0x00	; 0
    ff54:	60 e0       	ldi	r22, 0x00	; 0
    ff56:	08 95       	ret

0000ff58 <__fp_nan>:
    ff58:	9f ef       	ldi	r25, 0xFF	; 255
    ff5a:	80 ec       	ldi	r24, 0xC0	; 192
    ff5c:	08 95       	ret

0000ff5e <__fp_pscA>:
    ff5e:	00 24       	eor	r0, r0
    ff60:	0a 94       	dec	r0
    ff62:	16 16       	cp	r1, r22
    ff64:	17 06       	cpc	r1, r23
    ff66:	18 06       	cpc	r1, r24
    ff68:	09 06       	cpc	r0, r25
    ff6a:	08 95       	ret

0000ff6c <__fp_pscB>:
    ff6c:	00 24       	eor	r0, r0
    ff6e:	0a 94       	dec	r0
    ff70:	12 16       	cp	r1, r18
    ff72:	13 06       	cpc	r1, r19
    ff74:	14 06       	cpc	r1, r20
    ff76:	05 06       	cpc	r0, r21
    ff78:	08 95       	ret

0000ff7a <__fp_round>:
    ff7a:	09 2e       	mov	r0, r25
    ff7c:	03 94       	inc	r0
    ff7e:	00 0c       	add	r0, r0
    ff80:	11 f4       	brne	.+4      	; 0xff86 <__fp_round+0xc>
    ff82:	88 23       	and	r24, r24
    ff84:	52 f0       	brmi	.+20     	; 0xff9a <__fp_round+0x20>
    ff86:	bb 0f       	add	r27, r27
    ff88:	40 f4       	brcc	.+16     	; 0xff9a <__fp_round+0x20>
    ff8a:	bf 2b       	or	r27, r31
    ff8c:	11 f4       	brne	.+4      	; 0xff92 <__fp_round+0x18>
    ff8e:	60 ff       	sbrs	r22, 0
    ff90:	04 c0       	rjmp	.+8      	; 0xff9a <__fp_round+0x20>
    ff92:	6f 5f       	subi	r22, 0xFF	; 255
    ff94:	7f 4f       	sbci	r23, 0xFF	; 255
    ff96:	8f 4f       	sbci	r24, 0xFF	; 255
    ff98:	9f 4f       	sbci	r25, 0xFF	; 255
    ff9a:	08 95       	ret

0000ff9c <__fp_split3>:
    ff9c:	57 fd       	sbrc	r21, 7
    ff9e:	90 58       	subi	r25, 0x80	; 128
    ffa0:	44 0f       	add	r20, r20
    ffa2:	55 1f       	adc	r21, r21
    ffa4:	59 f0       	breq	.+22     	; 0xffbc <__fp_splitA+0x10>
    ffa6:	5f 3f       	cpi	r21, 0xFF	; 255
    ffa8:	71 f0       	breq	.+28     	; 0xffc6 <__fp_splitA+0x1a>
    ffaa:	47 95       	ror	r20

0000ffac <__fp_splitA>:
    ffac:	88 0f       	add	r24, r24
    ffae:	97 fb       	bst	r25, 7
    ffb0:	99 1f       	adc	r25, r25
    ffb2:	61 f0       	breq	.+24     	; 0xffcc <__fp_splitA+0x20>
    ffb4:	9f 3f       	cpi	r25, 0xFF	; 255
    ffb6:	79 f0       	breq	.+30     	; 0xffd6 <__fp_splitA+0x2a>
    ffb8:	87 95       	ror	r24
    ffba:	08 95       	ret
    ffbc:	12 16       	cp	r1, r18
    ffbe:	13 06       	cpc	r1, r19
    ffc0:	14 06       	cpc	r1, r20
    ffc2:	55 1f       	adc	r21, r21
    ffc4:	f2 cf       	rjmp	.-28     	; 0xffaa <__fp_split3+0xe>
    ffc6:	46 95       	lsr	r20
    ffc8:	f1 df       	rcall	.-30     	; 0xffac <__fp_splitA>
    ffca:	08 c0       	rjmp	.+16     	; 0xffdc <__fp_splitA+0x30>
    ffcc:	16 16       	cp	r1, r22
    ffce:	17 06       	cpc	r1, r23
    ffd0:	18 06       	cpc	r1, r24
    ffd2:	99 1f       	adc	r25, r25
    ffd4:	f1 cf       	rjmp	.-30     	; 0xffb8 <__fp_splitA+0xc>
    ffd6:	86 95       	lsr	r24
    ffd8:	71 05       	cpc	r23, r1
    ffda:	61 05       	cpc	r22, r1
    ffdc:	08 94       	sec
    ffde:	08 95       	ret

0000ffe0 <__fp_zero>:
    ffe0:	e8 94       	clt

0000ffe2 <__fp_szero>:
    ffe2:	bb 27       	eor	r27, r27
    ffe4:	66 27       	eor	r22, r22
    ffe6:	77 27       	eor	r23, r23
    ffe8:	cb 01       	movw	r24, r22
    ffea:	97 f9       	bld	r25, 7
    ffec:	08 95       	ret

0000ffee <exit>:
    ffee:	f8 94       	cli
    fff0:	0c 94 e2 84 	jmp	0x109c4	; 0x109c4 <_exit>

0000fff4 <__ftoa_engine>:
    fff4:	28 30       	cpi	r18, 0x08	; 8
    fff6:	08 f0       	brcs	.+2      	; 0xfffa <__ftoa_engine+0x6>
    fff8:	27 e0       	ldi	r18, 0x07	; 7
    fffa:	33 27       	eor	r19, r19
    fffc:	da 01       	movw	r26, r20
    fffe:	99 0f       	add	r25, r25
   10000:	31 1d       	adc	r19, r1
   10002:	87 fd       	sbrc	r24, 7
   10004:	91 60       	ori	r25, 0x01	; 1
   10006:	00 96       	adiw	r24, 0x00	; 0
   10008:	61 05       	cpc	r22, r1
   1000a:	71 05       	cpc	r23, r1
   1000c:	39 f4       	brne	.+14     	; 0x1001c <__ftoa_engine+0x28>
   1000e:	32 60       	ori	r19, 0x02	; 2
   10010:	2e 5f       	subi	r18, 0xFE	; 254
   10012:	3d 93       	st	X+, r19
   10014:	30 e3       	ldi	r19, 0x30	; 48
   10016:	2a 95       	dec	r18
   10018:	e1 f7       	brne	.-8      	; 0x10012 <__ftoa_engine+0x1e>
   1001a:	08 95       	ret
   1001c:	9f 3f       	cpi	r25, 0xFF	; 255
   1001e:	30 f0       	brcs	.+12     	; 0x1002c <__ftoa_engine+0x38>
   10020:	80 38       	cpi	r24, 0x80	; 128
   10022:	71 05       	cpc	r23, r1
   10024:	61 05       	cpc	r22, r1
   10026:	09 f0       	breq	.+2      	; 0x1002a <__ftoa_engine+0x36>
   10028:	3c 5f       	subi	r19, 0xFC	; 252
   1002a:	3c 5f       	subi	r19, 0xFC	; 252
   1002c:	3d 93       	st	X+, r19
   1002e:	91 30       	cpi	r25, 0x01	; 1
   10030:	08 f0       	brcs	.+2      	; 0x10034 <__ftoa_engine+0x40>
   10032:	80 68       	ori	r24, 0x80	; 128
   10034:	91 1d       	adc	r25, r1
   10036:	df 93       	push	r29
   10038:	cf 93       	push	r28
   1003a:	1f 93       	push	r17
   1003c:	0f 93       	push	r16
   1003e:	ff 92       	push	r15
   10040:	ef 92       	push	r14
   10042:	19 2f       	mov	r17, r25
   10044:	98 7f       	andi	r25, 0xF8	; 248
   10046:	96 95       	lsr	r25
   10048:	e9 2f       	mov	r30, r25
   1004a:	96 95       	lsr	r25
   1004c:	96 95       	lsr	r25
   1004e:	e9 0f       	add	r30, r25
   10050:	ff 27       	eor	r31, r31
   10052:	e4 5a       	subi	r30, 0xA4	; 164
   10054:	fc 4c       	sbci	r31, 0xCC	; 204
   10056:	99 27       	eor	r25, r25
   10058:	33 27       	eor	r19, r19
   1005a:	ee 24       	eor	r14, r14
   1005c:	ff 24       	eor	r15, r15
   1005e:	a7 01       	movw	r20, r14
   10060:	e7 01       	movw	r28, r14
   10062:	05 90       	lpm	r0, Z+
   10064:	08 94       	sec
   10066:	07 94       	ror	r0
   10068:	28 f4       	brcc	.+10     	; 0x10074 <__ftoa_engine+0x80>
   1006a:	36 0f       	add	r19, r22
   1006c:	e7 1e       	adc	r14, r23
   1006e:	f8 1e       	adc	r15, r24
   10070:	49 1f       	adc	r20, r25
   10072:	51 1d       	adc	r21, r1
   10074:	66 0f       	add	r22, r22
   10076:	77 1f       	adc	r23, r23
   10078:	88 1f       	adc	r24, r24
   1007a:	99 1f       	adc	r25, r25
   1007c:	06 94       	lsr	r0
   1007e:	a1 f7       	brne	.-24     	; 0x10068 <__ftoa_engine+0x74>
   10080:	05 90       	lpm	r0, Z+
   10082:	07 94       	ror	r0
   10084:	28 f4       	brcc	.+10     	; 0x10090 <__ftoa_engine+0x9c>
   10086:	e7 0e       	add	r14, r23
   10088:	f8 1e       	adc	r15, r24
   1008a:	49 1f       	adc	r20, r25
   1008c:	56 1f       	adc	r21, r22
   1008e:	c1 1d       	adc	r28, r1
   10090:	77 0f       	add	r23, r23
   10092:	88 1f       	adc	r24, r24
   10094:	99 1f       	adc	r25, r25
   10096:	66 1f       	adc	r22, r22
   10098:	06 94       	lsr	r0
   1009a:	a1 f7       	brne	.-24     	; 0x10084 <__ftoa_engine+0x90>
   1009c:	05 90       	lpm	r0, Z+
   1009e:	07 94       	ror	r0
   100a0:	28 f4       	brcc	.+10     	; 0x100ac <__ftoa_engine+0xb8>
   100a2:	f8 0e       	add	r15, r24
   100a4:	49 1f       	adc	r20, r25
   100a6:	56 1f       	adc	r21, r22
   100a8:	c7 1f       	adc	r28, r23
   100aa:	d1 1d       	adc	r29, r1
   100ac:	88 0f       	add	r24, r24
   100ae:	99 1f       	adc	r25, r25
   100b0:	66 1f       	adc	r22, r22
   100b2:	77 1f       	adc	r23, r23
   100b4:	06 94       	lsr	r0
   100b6:	a1 f7       	brne	.-24     	; 0x100a0 <__ftoa_engine+0xac>
   100b8:	05 90       	lpm	r0, Z+
   100ba:	07 94       	ror	r0
   100bc:	20 f4       	brcc	.+8      	; 0x100c6 <__ftoa_engine+0xd2>
   100be:	49 0f       	add	r20, r25
   100c0:	56 1f       	adc	r21, r22
   100c2:	c7 1f       	adc	r28, r23
   100c4:	d8 1f       	adc	r29, r24
   100c6:	99 0f       	add	r25, r25
   100c8:	66 1f       	adc	r22, r22
   100ca:	77 1f       	adc	r23, r23
   100cc:	88 1f       	adc	r24, r24
   100ce:	06 94       	lsr	r0
   100d0:	a9 f7       	brne	.-22     	; 0x100bc <__ftoa_engine+0xc8>
   100d2:	84 91       	lpm	r24, Z+
   100d4:	10 95       	com	r17
   100d6:	17 70       	andi	r17, 0x07	; 7
   100d8:	41 f0       	breq	.+16     	; 0x100ea <__ftoa_engine+0xf6>
   100da:	d6 95       	lsr	r29
   100dc:	c7 95       	ror	r28
   100de:	57 95       	ror	r21
   100e0:	47 95       	ror	r20
   100e2:	f7 94       	ror	r15
   100e4:	e7 94       	ror	r14
   100e6:	1a 95       	dec	r17
   100e8:	c1 f7       	brne	.-16     	; 0x100da <__ftoa_engine+0xe6>
   100ea:	e2 e0       	ldi	r30, 0x02	; 2
   100ec:	f3 e3       	ldi	r31, 0x33	; 51
   100ee:	68 94       	set
   100f0:	15 90       	lpm	r1, Z+
   100f2:	15 91       	lpm	r17, Z+
   100f4:	35 91       	lpm	r19, Z+
   100f6:	65 91       	lpm	r22, Z+
   100f8:	95 91       	lpm	r25, Z+
   100fa:	05 90       	lpm	r0, Z+
   100fc:	7f e2       	ldi	r23, 0x2F	; 47
   100fe:	73 95       	inc	r23
   10100:	e1 18       	sub	r14, r1
   10102:	f1 0a       	sbc	r15, r17
   10104:	43 0b       	sbc	r20, r19
   10106:	56 0b       	sbc	r21, r22
   10108:	c9 0b       	sbc	r28, r25
   1010a:	d0 09       	sbc	r29, r0
   1010c:	c0 f7       	brcc	.-16     	; 0x100fe <__ftoa_engine+0x10a>
   1010e:	e1 0c       	add	r14, r1
   10110:	f1 1e       	adc	r15, r17
   10112:	43 1f       	adc	r20, r19
   10114:	56 1f       	adc	r21, r22
   10116:	c9 1f       	adc	r28, r25
   10118:	d0 1d       	adc	r29, r0
   1011a:	7e f4       	brtc	.+30     	; 0x1013a <__ftoa_engine+0x146>
   1011c:	70 33       	cpi	r23, 0x30	; 48
   1011e:	11 f4       	brne	.+4      	; 0x10124 <__ftoa_engine+0x130>
   10120:	8a 95       	dec	r24
   10122:	e6 cf       	rjmp	.-52     	; 0x100f0 <__ftoa_engine+0xfc>
   10124:	e8 94       	clt
   10126:	01 50       	subi	r16, 0x01	; 1
   10128:	30 f0       	brcs	.+12     	; 0x10136 <__ftoa_engine+0x142>
   1012a:	08 0f       	add	r16, r24
   1012c:	0a f4       	brpl	.+2      	; 0x10130 <__ftoa_engine+0x13c>
   1012e:	00 27       	eor	r16, r16
   10130:	02 17       	cp	r16, r18
   10132:	08 f4       	brcc	.+2      	; 0x10136 <__ftoa_engine+0x142>
   10134:	20 2f       	mov	r18, r16
   10136:	23 95       	inc	r18
   10138:	02 2f       	mov	r16, r18
   1013a:	7a 33       	cpi	r23, 0x3A	; 58
   1013c:	28 f0       	brcs	.+10     	; 0x10148 <__ftoa_engine+0x154>
   1013e:	79 e3       	ldi	r23, 0x39	; 57
   10140:	7d 93       	st	X+, r23
   10142:	2a 95       	dec	r18
   10144:	e9 f7       	brne	.-6      	; 0x10140 <__ftoa_engine+0x14c>
   10146:	10 c0       	rjmp	.+32     	; 0x10168 <__ftoa_engine+0x174>
   10148:	7d 93       	st	X+, r23
   1014a:	2a 95       	dec	r18
   1014c:	89 f6       	brne	.-94     	; 0x100f0 <__ftoa_engine+0xfc>
   1014e:	06 94       	lsr	r0
   10150:	97 95       	ror	r25
   10152:	67 95       	ror	r22
   10154:	37 95       	ror	r19
   10156:	17 95       	ror	r17
   10158:	17 94       	ror	r1
   1015a:	e1 18       	sub	r14, r1
   1015c:	f1 0a       	sbc	r15, r17
   1015e:	43 0b       	sbc	r20, r19
   10160:	56 0b       	sbc	r21, r22
   10162:	c9 0b       	sbc	r28, r25
   10164:	d0 09       	sbc	r29, r0
   10166:	98 f0       	brcs	.+38     	; 0x1018e <__ftoa_engine+0x19a>
   10168:	23 95       	inc	r18
   1016a:	7e 91       	ld	r23, -X
   1016c:	73 95       	inc	r23
   1016e:	7a 33       	cpi	r23, 0x3A	; 58
   10170:	08 f0       	brcs	.+2      	; 0x10174 <__ftoa_engine+0x180>
   10172:	70 e3       	ldi	r23, 0x30	; 48
   10174:	7c 93       	st	X, r23
   10176:	20 13       	cpse	r18, r16
   10178:	b8 f7       	brcc	.-18     	; 0x10168 <__ftoa_engine+0x174>
   1017a:	7e 91       	ld	r23, -X
   1017c:	70 61       	ori	r23, 0x10	; 16
   1017e:	7d 93       	st	X+, r23
   10180:	30 f0       	brcs	.+12     	; 0x1018e <__ftoa_engine+0x19a>
   10182:	83 95       	inc	r24
   10184:	71 e3       	ldi	r23, 0x31	; 49
   10186:	7d 93       	st	X+, r23
   10188:	70 e3       	ldi	r23, 0x30	; 48
   1018a:	2a 95       	dec	r18
   1018c:	e1 f7       	brne	.-8      	; 0x10186 <__ftoa_engine+0x192>
   1018e:	11 24       	eor	r1, r1
   10190:	ef 90       	pop	r14
   10192:	ff 90       	pop	r15
   10194:	0f 91       	pop	r16
   10196:	1f 91       	pop	r17
   10198:	cf 91       	pop	r28
   1019a:	df 91       	pop	r29
   1019c:	99 27       	eor	r25, r25
   1019e:	87 fd       	sbrc	r24, 7
   101a0:	90 95       	com	r25
   101a2:	08 95       	ret

000101a4 <isspace>:
   101a4:	91 11       	cpse	r25, r1
   101a6:	7c c3       	rjmp	.+1784   	; 0x108a0 <__ctype_isfalse>
   101a8:	80 32       	cpi	r24, 0x20	; 32
   101aa:	19 f0       	breq	.+6      	; 0x101b2 <isspace+0xe>
   101ac:	89 50       	subi	r24, 0x09	; 9
   101ae:	85 50       	subi	r24, 0x05	; 5
   101b0:	d0 f7       	brcc	.-12     	; 0x101a6 <isspace+0x2>
   101b2:	08 95       	ret

000101b4 <tolower>:
   101b4:	91 11       	cpse	r25, r1
   101b6:	08 95       	ret
   101b8:	81 54       	subi	r24, 0x41	; 65
   101ba:	8a 51       	subi	r24, 0x1A	; 26
   101bc:	08 f4       	brcc	.+2      	; 0x101c0 <tolower+0xc>
   101be:	80 5e       	subi	r24, 0xE0	; 224
   101c0:	85 5a       	subi	r24, 0xA5	; 165
   101c2:	08 95       	ret

000101c4 <strchr_P>:
   101c4:	fc 01       	movw	r30, r24
   101c6:	05 90       	lpm	r0, Z+
   101c8:	06 16       	cp	r0, r22
   101ca:	21 f0       	breq	.+8      	; 0x101d4 <strchr_P+0x10>
   101cc:	00 20       	and	r0, r0
   101ce:	d9 f7       	brne	.-10     	; 0x101c6 <strchr_P+0x2>
   101d0:	c0 01       	movw	r24, r0
   101d2:	08 95       	ret
   101d4:	31 97       	sbiw	r30, 0x01	; 1
   101d6:	cf 01       	movw	r24, r30
   101d8:	08 95       	ret

000101da <strcmp_P>:
   101da:	fb 01       	movw	r30, r22
   101dc:	dc 01       	movw	r26, r24
   101de:	8d 91       	ld	r24, X+
   101e0:	05 90       	lpm	r0, Z+
   101e2:	80 19       	sub	r24, r0
   101e4:	01 10       	cpse	r0, r1
   101e6:	d9 f3       	breq	.-10     	; 0x101de <strcmp_P+0x4>
   101e8:	99 0b       	sbc	r25, r25
   101ea:	08 95       	ret

000101ec <strcpy_P>:
   101ec:	fb 01       	movw	r30, r22
   101ee:	dc 01       	movw	r26, r24
   101f0:	05 90       	lpm	r0, Z+
   101f2:	0d 92       	st	X+, r0
   101f4:	00 20       	and	r0, r0
   101f6:	e1 f7       	brne	.-8      	; 0x101f0 <strcpy_P+0x4>
   101f8:	08 95       	ret

000101fa <strlen_P>:
   101fa:	fc 01       	movw	r30, r24
   101fc:	05 90       	lpm	r0, Z+
   101fe:	00 20       	and	r0, r0
   10200:	e9 f7       	brne	.-6      	; 0x101fc <strlen_P+0x2>
   10202:	80 95       	com	r24
   10204:	90 95       	com	r25
   10206:	8e 0f       	add	r24, r30
   10208:	9f 1f       	adc	r25, r31
   1020a:	08 95       	ret

0001020c <strncmp_P>:
   1020c:	fb 01       	movw	r30, r22
   1020e:	dc 01       	movw	r26, r24
   10210:	41 50       	subi	r20, 0x01	; 1
   10212:	50 40       	sbci	r21, 0x00	; 0
   10214:	30 f0       	brcs	.+12     	; 0x10222 <strncmp_P+0x16>
   10216:	8d 91       	ld	r24, X+
   10218:	05 90       	lpm	r0, Z+
   1021a:	80 19       	sub	r24, r0
   1021c:	19 f4       	brne	.+6      	; 0x10224 <strncmp_P+0x18>
   1021e:	00 20       	and	r0, r0
   10220:	b9 f7       	brne	.-18     	; 0x10210 <strncmp_P+0x4>
   10222:	88 1b       	sub	r24, r24
   10224:	99 0b       	sbc	r25, r25
   10226:	08 95       	ret

00010228 <strnlen_P>:
   10228:	fc 01       	movw	r30, r24
   1022a:	05 90       	lpm	r0, Z+
   1022c:	61 50       	subi	r22, 0x01	; 1
   1022e:	70 40       	sbci	r23, 0x00	; 0
   10230:	01 10       	cpse	r0, r1
   10232:	d8 f7       	brcc	.-10     	; 0x1022a <strnlen_P+0x2>
   10234:	80 95       	com	r24
   10236:	90 95       	com	r25
   10238:	8e 0f       	add	r24, r30
   1023a:	9f 1f       	adc	r25, r31
   1023c:	08 95       	ret

0001023e <strstr_P>:
   1023e:	fb 01       	movw	r30, r22
   10240:	55 91       	lpm	r21, Z+
   10242:	55 23       	and	r21, r21
   10244:	a9 f0       	breq	.+42     	; 0x10270 <strstr_P+0x32>
   10246:	bf 01       	movw	r22, r30
   10248:	dc 01       	movw	r26, r24
   1024a:	4d 91       	ld	r20, X+
   1024c:	45 17       	cp	r20, r21
   1024e:	41 11       	cpse	r20, r1
   10250:	e1 f7       	brne	.-8      	; 0x1024a <strstr_P+0xc>
   10252:	59 f4       	brne	.+22     	; 0x1026a <strstr_P+0x2c>
   10254:	cd 01       	movw	r24, r26
   10256:	05 90       	lpm	r0, Z+
   10258:	00 20       	and	r0, r0
   1025a:	49 f0       	breq	.+18     	; 0x1026e <strstr_P+0x30>
   1025c:	4d 91       	ld	r20, X+
   1025e:	40 15       	cp	r20, r0
   10260:	41 11       	cpse	r20, r1
   10262:	c9 f3       	breq	.-14     	; 0x10256 <strstr_P+0x18>
   10264:	fb 01       	movw	r30, r22
   10266:	41 11       	cpse	r20, r1
   10268:	ef cf       	rjmp	.-34     	; 0x10248 <strstr_P+0xa>
   1026a:	81 e0       	ldi	r24, 0x01	; 1
   1026c:	90 e0       	ldi	r25, 0x00	; 0
   1026e:	01 97       	sbiw	r24, 0x01	; 1
   10270:	08 95       	ret

00010272 <memcpy>:
   10272:	fb 01       	movw	r30, r22
   10274:	dc 01       	movw	r26, r24
   10276:	02 c0       	rjmp	.+4      	; 0x1027c <memcpy+0xa>
   10278:	01 90       	ld	r0, Z+
   1027a:	0d 92       	st	X+, r0
   1027c:	41 50       	subi	r20, 0x01	; 1
   1027e:	50 40       	sbci	r21, 0x00	; 0
   10280:	d8 f7       	brcc	.-10     	; 0x10278 <memcpy+0x6>
   10282:	08 95       	ret

00010284 <strchr>:
   10284:	fc 01       	movw	r30, r24
   10286:	81 91       	ld	r24, Z+
   10288:	86 17       	cp	r24, r22
   1028a:	21 f0       	breq	.+8      	; 0x10294 <strchr+0x10>
   1028c:	88 23       	and	r24, r24
   1028e:	d9 f7       	brne	.-10     	; 0x10286 <strchr+0x2>
   10290:	99 27       	eor	r25, r25
   10292:	08 95       	ret
   10294:	31 97       	sbiw	r30, 0x01	; 1
   10296:	cf 01       	movw	r24, r30
   10298:	08 95       	ret

0001029a <strcmp>:
   1029a:	fb 01       	movw	r30, r22
   1029c:	dc 01       	movw	r26, r24
   1029e:	8d 91       	ld	r24, X+
   102a0:	01 90       	ld	r0, Z+
   102a2:	80 19       	sub	r24, r0
   102a4:	01 10       	cpse	r0, r1
   102a6:	d9 f3       	breq	.-10     	; 0x1029e <strcmp+0x4>
   102a8:	99 0b       	sbc	r25, r25
   102aa:	08 95       	ret

000102ac <strnlen>:
   102ac:	fc 01       	movw	r30, r24
   102ae:	61 50       	subi	r22, 0x01	; 1
   102b0:	70 40       	sbci	r23, 0x00	; 0
   102b2:	01 90       	ld	r0, Z+
   102b4:	01 10       	cpse	r0, r1
   102b6:	d8 f7       	brcc	.-10     	; 0x102ae <strnlen+0x2>
   102b8:	80 95       	com	r24
   102ba:	90 95       	com	r25
   102bc:	8e 0f       	add	r24, r30
   102be:	9f 1f       	adc	r25, r31
   102c0:	08 95       	ret

000102c2 <strstr>:
   102c2:	fb 01       	movw	r30, r22
   102c4:	51 91       	ld	r21, Z+
   102c6:	55 23       	and	r21, r21
   102c8:	a9 f0       	breq	.+42     	; 0x102f4 <strstr+0x32>
   102ca:	bf 01       	movw	r22, r30
   102cc:	dc 01       	movw	r26, r24
   102ce:	4d 91       	ld	r20, X+
   102d0:	45 17       	cp	r20, r21
   102d2:	41 11       	cpse	r20, r1
   102d4:	e1 f7       	brne	.-8      	; 0x102ce <strstr+0xc>
   102d6:	59 f4       	brne	.+22     	; 0x102ee <strstr+0x2c>
   102d8:	cd 01       	movw	r24, r26
   102da:	01 90       	ld	r0, Z+
   102dc:	00 20       	and	r0, r0
   102de:	49 f0       	breq	.+18     	; 0x102f2 <strstr+0x30>
   102e0:	4d 91       	ld	r20, X+
   102e2:	40 15       	cp	r20, r0
   102e4:	41 11       	cpse	r20, r1
   102e6:	c9 f3       	breq	.-14     	; 0x102da <strstr+0x18>
   102e8:	fb 01       	movw	r30, r22
   102ea:	41 11       	cpse	r20, r1
   102ec:	ef cf       	rjmp	.-34     	; 0x102cc <strstr+0xa>
   102ee:	81 e0       	ldi	r24, 0x01	; 1
   102f0:	90 e0       	ldi	r25, 0x00	; 0
   102f2:	01 97       	sbiw	r24, 0x01	; 1
   102f4:	08 95       	ret

000102f6 <fgetc>:
   102f6:	cf 93       	push	r28
   102f8:	df 93       	push	r29
   102fa:	ec 01       	movw	r28, r24
   102fc:	4b 81       	ldd	r20, Y+3	; 0x03
   102fe:	40 ff       	sbrs	r20, 0
   10300:	1a c0       	rjmp	.+52     	; 0x10336 <fgetc+0x40>
   10302:	46 ff       	sbrs	r20, 6
   10304:	0a c0       	rjmp	.+20     	; 0x1031a <fgetc+0x24>
   10306:	4f 7b       	andi	r20, 0xBF	; 191
   10308:	4b 83       	std	Y+3, r20	; 0x03
   1030a:	8e 81       	ldd	r24, Y+6	; 0x06
   1030c:	9f 81       	ldd	r25, Y+7	; 0x07
   1030e:	01 96       	adiw	r24, 0x01	; 1
   10310:	9f 83       	std	Y+7, r25	; 0x07
   10312:	8e 83       	std	Y+6, r24	; 0x06
   10314:	8a 81       	ldd	r24, Y+2	; 0x02
   10316:	28 2f       	mov	r18, r24
   10318:	2b c0       	rjmp	.+86     	; 0x10370 <fgetc+0x7a>
   1031a:	42 ff       	sbrs	r20, 2
   1031c:	13 c0       	rjmp	.+38     	; 0x10344 <fgetc+0x4e>
   1031e:	e8 81       	ld	r30, Y
   10320:	f9 81       	ldd	r31, Y+1	; 0x01
   10322:	80 81       	ld	r24, Z
   10324:	28 2f       	mov	r18, r24
   10326:	33 27       	eor	r19, r19
   10328:	27 fd       	sbrc	r18, 7
   1032a:	30 95       	com	r19
   1032c:	21 15       	cp	r18, r1
   1032e:	31 05       	cpc	r19, r1
   10330:	29 f4       	brne	.+10     	; 0x1033c <fgetc+0x46>
   10332:	40 62       	ori	r20, 0x20	; 32
   10334:	4b 83       	std	Y+3, r20	; 0x03
   10336:	2f ef       	ldi	r18, 0xFF	; 255
   10338:	3f ef       	ldi	r19, 0xFF	; 255
   1033a:	1b c0       	rjmp	.+54     	; 0x10372 <fgetc+0x7c>
   1033c:	31 96       	adiw	r30, 0x01	; 1
   1033e:	f9 83       	std	Y+1, r31	; 0x01
   10340:	e8 83       	st	Y, r30
   10342:	11 c0       	rjmp	.+34     	; 0x10366 <fgetc+0x70>
   10344:	ea 85       	ldd	r30, Y+10	; 0x0a
   10346:	fb 85       	ldd	r31, Y+11	; 0x0b
   10348:	ce 01       	movw	r24, r28
   1034a:	19 95       	eicall
   1034c:	9c 01       	movw	r18, r24
   1034e:	97 ff       	sbrs	r25, 7
   10350:	0a c0       	rjmp	.+20     	; 0x10366 <fgetc+0x70>
   10352:	9b 81       	ldd	r25, Y+3	; 0x03
   10354:	2f 5f       	subi	r18, 0xFF	; 255
   10356:	3f 4f       	sbci	r19, 0xFF	; 255
   10358:	11 f0       	breq	.+4      	; 0x1035e <fgetc+0x68>
   1035a:	80 e2       	ldi	r24, 0x20	; 32
   1035c:	01 c0       	rjmp	.+2      	; 0x10360 <fgetc+0x6a>
   1035e:	80 e1       	ldi	r24, 0x10	; 16
   10360:	89 2b       	or	r24, r25
   10362:	8b 83       	std	Y+3, r24	; 0x03
   10364:	e8 cf       	rjmp	.-48     	; 0x10336 <fgetc+0x40>
   10366:	8e 81       	ldd	r24, Y+6	; 0x06
   10368:	9f 81       	ldd	r25, Y+7	; 0x07
   1036a:	01 96       	adiw	r24, 0x01	; 1
   1036c:	9f 83       	std	Y+7, r25	; 0x07
   1036e:	8e 83       	std	Y+6, r24	; 0x06
   10370:	30 e0       	ldi	r19, 0x00	; 0
   10372:	c9 01       	movw	r24, r18
   10374:	df 91       	pop	r29
   10376:	cf 91       	pop	r28
   10378:	08 95       	ret

0001037a <fputc>:
   1037a:	0f 93       	push	r16
   1037c:	1f 93       	push	r17
   1037e:	cf 93       	push	r28
   10380:	df 93       	push	r29
   10382:	8c 01       	movw	r16, r24
   10384:	eb 01       	movw	r28, r22
   10386:	8b 81       	ldd	r24, Y+3	; 0x03
   10388:	81 ff       	sbrs	r24, 1
   1038a:	1b c0       	rjmp	.+54     	; 0x103c2 <fputc+0x48>
   1038c:	82 ff       	sbrs	r24, 2
   1038e:	0d c0       	rjmp	.+26     	; 0x103aa <fputc+0x30>
   10390:	2e 81       	ldd	r18, Y+6	; 0x06
   10392:	3f 81       	ldd	r19, Y+7	; 0x07
   10394:	8c 81       	ldd	r24, Y+4	; 0x04
   10396:	9d 81       	ldd	r25, Y+5	; 0x05
   10398:	28 17       	cp	r18, r24
   1039a:	39 07       	cpc	r19, r25
   1039c:	64 f4       	brge	.+24     	; 0x103b6 <fputc+0x3c>
   1039e:	e8 81       	ld	r30, Y
   103a0:	f9 81       	ldd	r31, Y+1	; 0x01
   103a2:	01 93       	st	Z+, r16
   103a4:	f9 83       	std	Y+1, r31	; 0x01
   103a6:	e8 83       	st	Y, r30
   103a8:	06 c0       	rjmp	.+12     	; 0x103b6 <fputc+0x3c>
   103aa:	e8 85       	ldd	r30, Y+8	; 0x08
   103ac:	f9 85       	ldd	r31, Y+9	; 0x09
   103ae:	80 2f       	mov	r24, r16
   103b0:	19 95       	eicall
   103b2:	89 2b       	or	r24, r25
   103b4:	31 f4       	brne	.+12     	; 0x103c2 <fputc+0x48>
   103b6:	8e 81       	ldd	r24, Y+6	; 0x06
   103b8:	9f 81       	ldd	r25, Y+7	; 0x07
   103ba:	01 96       	adiw	r24, 0x01	; 1
   103bc:	9f 83       	std	Y+7, r25	; 0x07
   103be:	8e 83       	std	Y+6, r24	; 0x06
   103c0:	02 c0       	rjmp	.+4      	; 0x103c6 <fputc+0x4c>
   103c2:	0f ef       	ldi	r16, 0xFF	; 255
   103c4:	1f ef       	ldi	r17, 0xFF	; 255
   103c6:	c8 01       	movw	r24, r16
   103c8:	df 91       	pop	r29
   103ca:	cf 91       	pop	r28
   103cc:	1f 91       	pop	r17
   103ce:	0f 91       	pop	r16
   103d0:	08 95       	ret

000103d2 <sprintf>:
   103d2:	0f 93       	push	r16
   103d4:	1f 93       	push	r17
   103d6:	df 93       	push	r29
   103d8:	cf 93       	push	r28
   103da:	cd b7       	in	r28, 0x3d	; 61
   103dc:	de b7       	in	r29, 0x3e	; 62
   103de:	2e 97       	sbiw	r28, 0x0e	; 14
   103e0:	0f b6       	in	r0, 0x3f	; 63
   103e2:	f8 94       	cli
   103e4:	de bf       	out	0x3e, r29	; 62
   103e6:	0f be       	out	0x3f, r0	; 63
   103e8:	cd bf       	out	0x3d, r28	; 61
   103ea:	0e 89       	ldd	r16, Y+22	; 0x16
   103ec:	1f 89       	ldd	r17, Y+23	; 0x17
   103ee:	86 e0       	ldi	r24, 0x06	; 6
   103f0:	8c 83       	std	Y+4, r24	; 0x04
   103f2:	1a 83       	std	Y+2, r17	; 0x02
   103f4:	09 83       	std	Y+1, r16	; 0x01
   103f6:	8f ef       	ldi	r24, 0xFF	; 255
   103f8:	9f e7       	ldi	r25, 0x7F	; 127
   103fa:	9e 83       	std	Y+6, r25	; 0x06
   103fc:	8d 83       	std	Y+5, r24	; 0x05
   103fe:	9e 01       	movw	r18, r28
   10400:	26 5e       	subi	r18, 0xE6	; 230
   10402:	3f 4f       	sbci	r19, 0xFF	; 255
   10404:	ce 01       	movw	r24, r28
   10406:	01 96       	adiw	r24, 0x01	; 1
   10408:	68 8d       	ldd	r22, Y+24	; 0x18
   1040a:	79 8d       	ldd	r23, Y+25	; 0x19
   1040c:	a9 01       	movw	r20, r18
   1040e:	0e 94 10 77 	call	0xee20	; 0xee20 <vfprintf>
   10412:	2f 81       	ldd	r18, Y+7	; 0x07
   10414:	38 85       	ldd	r19, Y+8	; 0x08
   10416:	02 0f       	add	r16, r18
   10418:	13 1f       	adc	r17, r19
   1041a:	f8 01       	movw	r30, r16
   1041c:	10 82       	st	Z, r1
   1041e:	2e 96       	adiw	r28, 0x0e	; 14
   10420:	0f b6       	in	r0, 0x3f	; 63
   10422:	f8 94       	cli
   10424:	de bf       	out	0x3e, r29	; 62
   10426:	0f be       	out	0x3f, r0	; 63
   10428:	cd bf       	out	0x3d, r28	; 61
   1042a:	cf 91       	pop	r28
   1042c:	df 91       	pop	r29
   1042e:	1f 91       	pop	r17
   10430:	0f 91       	pop	r16
   10432:	08 95       	ret

00010434 <sprintf_P>:
   10434:	0f 93       	push	r16
   10436:	1f 93       	push	r17
   10438:	df 93       	push	r29
   1043a:	cf 93       	push	r28
   1043c:	cd b7       	in	r28, 0x3d	; 61
   1043e:	de b7       	in	r29, 0x3e	; 62
   10440:	2e 97       	sbiw	r28, 0x0e	; 14
   10442:	0f b6       	in	r0, 0x3f	; 63
   10444:	f8 94       	cli
   10446:	de bf       	out	0x3e, r29	; 62
   10448:	0f be       	out	0x3f, r0	; 63
   1044a:	cd bf       	out	0x3d, r28	; 61
   1044c:	0e 89       	ldd	r16, Y+22	; 0x16
   1044e:	1f 89       	ldd	r17, Y+23	; 0x17
   10450:	8e e0       	ldi	r24, 0x0E	; 14
   10452:	8c 83       	std	Y+4, r24	; 0x04
   10454:	1a 83       	std	Y+2, r17	; 0x02
   10456:	09 83       	std	Y+1, r16	; 0x01
   10458:	8f ef       	ldi	r24, 0xFF	; 255
   1045a:	9f e7       	ldi	r25, 0x7F	; 127
   1045c:	9e 83       	std	Y+6, r25	; 0x06
   1045e:	8d 83       	std	Y+5, r24	; 0x05
   10460:	9e 01       	movw	r18, r28
   10462:	26 5e       	subi	r18, 0xE6	; 230
   10464:	3f 4f       	sbci	r19, 0xFF	; 255
   10466:	ce 01       	movw	r24, r28
   10468:	01 96       	adiw	r24, 0x01	; 1
   1046a:	68 8d       	ldd	r22, Y+24	; 0x18
   1046c:	79 8d       	ldd	r23, Y+25	; 0x19
   1046e:	a9 01       	movw	r20, r18
   10470:	0e 94 10 77 	call	0xee20	; 0xee20 <vfprintf>
   10474:	2f 81       	ldd	r18, Y+7	; 0x07
   10476:	38 85       	ldd	r19, Y+8	; 0x08
   10478:	02 0f       	add	r16, r18
   1047a:	13 1f       	adc	r17, r19
   1047c:	f8 01       	movw	r30, r16
   1047e:	10 82       	st	Z, r1
   10480:	2e 96       	adiw	r28, 0x0e	; 14
   10482:	0f b6       	in	r0, 0x3f	; 63
   10484:	f8 94       	cli
   10486:	de bf       	out	0x3e, r29	; 62
   10488:	0f be       	out	0x3f, r0	; 63
   1048a:	cd bf       	out	0x3d, r28	; 61
   1048c:	cf 91       	pop	r28
   1048e:	df 91       	pop	r29
   10490:	1f 91       	pop	r17
   10492:	0f 91       	pop	r16
   10494:	08 95       	ret

00010496 <sscanf>:
   10496:	df 93       	push	r29
   10498:	cf 93       	push	r28
   1049a:	cd b7       	in	r28, 0x3d	; 61
   1049c:	de b7       	in	r29, 0x3e	; 62
   1049e:	2e 97       	sbiw	r28, 0x0e	; 14
   104a0:	0f b6       	in	r0, 0x3f	; 63
   104a2:	f8 94       	cli
   104a4:	de bf       	out	0x3e, r29	; 62
   104a6:	0f be       	out	0x3f, r0	; 63
   104a8:	cd bf       	out	0x3d, r28	; 61
   104aa:	85 e0       	ldi	r24, 0x05	; 5
   104ac:	8c 83       	std	Y+4, r24	; 0x04
   104ae:	8c 89       	ldd	r24, Y+20	; 0x14
   104b0:	9d 89       	ldd	r25, Y+21	; 0x15
   104b2:	9a 83       	std	Y+2, r25	; 0x02
   104b4:	89 83       	std	Y+1, r24	; 0x01
   104b6:	9e 01       	movw	r18, r28
   104b8:	28 5e       	subi	r18, 0xE8	; 232
   104ba:	3f 4f       	sbci	r19, 0xFF	; 255
   104bc:	ce 01       	movw	r24, r28
   104be:	01 96       	adiw	r24, 0x01	; 1
   104c0:	6e 89       	ldd	r22, Y+22	; 0x16
   104c2:	7f 89       	ldd	r23, Y+23	; 0x17
   104c4:	a9 01       	movw	r20, r18
   104c6:	0e 94 c7 7d 	call	0xfb8e	; 0xfb8e <vfscanf>
   104ca:	2e 96       	adiw	r28, 0x0e	; 14
   104cc:	0f b6       	in	r0, 0x3f	; 63
   104ce:	f8 94       	cli
   104d0:	de bf       	out	0x3e, r29	; 62
   104d2:	0f be       	out	0x3f, r0	; 63
   104d4:	cd bf       	out	0x3d, r28	; 61
   104d6:	cf 91       	pop	r28
   104d8:	df 91       	pop	r29
   104da:	08 95       	ret

000104dc <sscanf_P>:
   104dc:	df 93       	push	r29
   104de:	cf 93       	push	r28
   104e0:	cd b7       	in	r28, 0x3d	; 61
   104e2:	de b7       	in	r29, 0x3e	; 62
   104e4:	2e 97       	sbiw	r28, 0x0e	; 14
   104e6:	0f b6       	in	r0, 0x3f	; 63
   104e8:	f8 94       	cli
   104ea:	de bf       	out	0x3e, r29	; 62
   104ec:	0f be       	out	0x3f, r0	; 63
   104ee:	cd bf       	out	0x3d, r28	; 61
   104f0:	8d e0       	ldi	r24, 0x0D	; 13
   104f2:	8c 83       	std	Y+4, r24	; 0x04
   104f4:	8c 89       	ldd	r24, Y+20	; 0x14
   104f6:	9d 89       	ldd	r25, Y+21	; 0x15
   104f8:	9a 83       	std	Y+2, r25	; 0x02
   104fa:	89 83       	std	Y+1, r24	; 0x01
   104fc:	9e 01       	movw	r18, r28
   104fe:	28 5e       	subi	r18, 0xE8	; 232
   10500:	3f 4f       	sbci	r19, 0xFF	; 255
   10502:	ce 01       	movw	r24, r28
   10504:	01 96       	adiw	r24, 0x01	; 1
   10506:	6e 89       	ldd	r22, Y+22	; 0x16
   10508:	7f 89       	ldd	r23, Y+23	; 0x17
   1050a:	a9 01       	movw	r20, r18
   1050c:	0e 94 c7 7d 	call	0xfb8e	; 0xfb8e <vfscanf>
   10510:	2e 96       	adiw	r28, 0x0e	; 14
   10512:	0f b6       	in	r0, 0x3f	; 63
   10514:	f8 94       	cli
   10516:	de bf       	out	0x3e, r29	; 62
   10518:	0f be       	out	0x3f, r0	; 63
   1051a:	cd bf       	out	0x3d, r28	; 61
   1051c:	cf 91       	pop	r28
   1051e:	df 91       	pop	r29
   10520:	08 95       	ret

00010522 <ungetc>:
   10522:	9c 01       	movw	r18, r24
   10524:	fb 01       	movw	r30, r22
   10526:	83 81       	ldd	r24, Z+3	; 0x03
   10528:	80 ff       	sbrs	r24, 0
   1052a:	11 c0       	rjmp	.+34     	; 0x1054e <ungetc+0x2c>
   1052c:	86 fd       	sbrc	r24, 6
   1052e:	0f c0       	rjmp	.+30     	; 0x1054e <ungetc+0x2c>
   10530:	9f ef       	ldi	r25, 0xFF	; 255
   10532:	2f 3f       	cpi	r18, 0xFF	; 255
   10534:	39 07       	cpc	r19, r25
   10536:	59 f0       	breq	.+22     	; 0x1054e <ungetc+0x2c>
   10538:	22 83       	std	Z+2, r18	; 0x02
   1053a:	80 64       	ori	r24, 0x40	; 64
   1053c:	8f 7d       	andi	r24, 0xDF	; 223
   1053e:	83 83       	std	Z+3, r24	; 0x03
   10540:	86 81       	ldd	r24, Z+6	; 0x06
   10542:	97 81       	ldd	r25, Z+7	; 0x07
   10544:	01 97       	sbiw	r24, 0x01	; 1
   10546:	97 83       	std	Z+7, r25	; 0x07
   10548:	86 83       	std	Z+6, r24	; 0x06
   1054a:	30 e0       	ldi	r19, 0x00	; 0
   1054c:	02 c0       	rjmp	.+4      	; 0x10552 <ungetc+0x30>
   1054e:	2f ef       	ldi	r18, 0xFF	; 255
   10550:	3f ef       	ldi	r19, 0xFF	; 255
   10552:	c9 01       	movw	r24, r18
   10554:	08 95       	ret

00010556 <__ultoa_invert>:
   10556:	fa 01       	movw	r30, r20
   10558:	aa 27       	eor	r26, r26
   1055a:	28 30       	cpi	r18, 0x08	; 8
   1055c:	51 f1       	breq	.+84     	; 0x105b2 <__ultoa_invert+0x5c>
   1055e:	20 31       	cpi	r18, 0x10	; 16
   10560:	81 f1       	breq	.+96     	; 0x105c2 <__ultoa_invert+0x6c>
   10562:	e8 94       	clt
   10564:	6f 93       	push	r22
   10566:	6e 7f       	andi	r22, 0xFE	; 254
   10568:	6e 5f       	subi	r22, 0xFE	; 254
   1056a:	7f 4f       	sbci	r23, 0xFF	; 255
   1056c:	8f 4f       	sbci	r24, 0xFF	; 255
   1056e:	9f 4f       	sbci	r25, 0xFF	; 255
   10570:	af 4f       	sbci	r26, 0xFF	; 255
   10572:	b1 e0       	ldi	r27, 0x01	; 1
   10574:	3e d0       	rcall	.+124    	; 0x105f2 <__ultoa_invert+0x9c>
   10576:	b4 e0       	ldi	r27, 0x04	; 4
   10578:	3c d0       	rcall	.+120    	; 0x105f2 <__ultoa_invert+0x9c>
   1057a:	67 0f       	add	r22, r23
   1057c:	78 1f       	adc	r23, r24
   1057e:	89 1f       	adc	r24, r25
   10580:	9a 1f       	adc	r25, r26
   10582:	a1 1d       	adc	r26, r1
   10584:	68 0f       	add	r22, r24
   10586:	79 1f       	adc	r23, r25
   10588:	8a 1f       	adc	r24, r26
   1058a:	91 1d       	adc	r25, r1
   1058c:	a1 1d       	adc	r26, r1
   1058e:	6a 0f       	add	r22, r26
   10590:	71 1d       	adc	r23, r1
   10592:	81 1d       	adc	r24, r1
   10594:	91 1d       	adc	r25, r1
   10596:	a1 1d       	adc	r26, r1
   10598:	20 d0       	rcall	.+64     	; 0x105da <__ultoa_invert+0x84>
   1059a:	09 f4       	brne	.+2      	; 0x1059e <__ultoa_invert+0x48>
   1059c:	68 94       	set
   1059e:	3f 91       	pop	r19
   105a0:	2a e0       	ldi	r18, 0x0A	; 10
   105a2:	26 9f       	mul	r18, r22
   105a4:	11 24       	eor	r1, r1
   105a6:	30 19       	sub	r19, r0
   105a8:	30 5d       	subi	r19, 0xD0	; 208
   105aa:	31 93       	st	Z+, r19
   105ac:	de f6       	brtc	.-74     	; 0x10564 <__ultoa_invert+0xe>
   105ae:	cf 01       	movw	r24, r30
   105b0:	08 95       	ret
   105b2:	46 2f       	mov	r20, r22
   105b4:	47 70       	andi	r20, 0x07	; 7
   105b6:	40 5d       	subi	r20, 0xD0	; 208
   105b8:	41 93       	st	Z+, r20
   105ba:	b3 e0       	ldi	r27, 0x03	; 3
   105bc:	0f d0       	rcall	.+30     	; 0x105dc <__ultoa_invert+0x86>
   105be:	c9 f7       	brne	.-14     	; 0x105b2 <__ultoa_invert+0x5c>
   105c0:	f6 cf       	rjmp	.-20     	; 0x105ae <__ultoa_invert+0x58>
   105c2:	46 2f       	mov	r20, r22
   105c4:	4f 70       	andi	r20, 0x0F	; 15
   105c6:	40 5d       	subi	r20, 0xD0	; 208
   105c8:	4a 33       	cpi	r20, 0x3A	; 58
   105ca:	18 f0       	brcs	.+6      	; 0x105d2 <__ultoa_invert+0x7c>
   105cc:	49 5d       	subi	r20, 0xD9	; 217
   105ce:	31 fd       	sbrc	r19, 1
   105d0:	40 52       	subi	r20, 0x20	; 32
   105d2:	41 93       	st	Z+, r20
   105d4:	02 d0       	rcall	.+4      	; 0x105da <__ultoa_invert+0x84>
   105d6:	a9 f7       	brne	.-22     	; 0x105c2 <__ultoa_invert+0x6c>
   105d8:	ea cf       	rjmp	.-44     	; 0x105ae <__ultoa_invert+0x58>
   105da:	b4 e0       	ldi	r27, 0x04	; 4
   105dc:	a6 95       	lsr	r26
   105de:	97 95       	ror	r25
   105e0:	87 95       	ror	r24
   105e2:	77 95       	ror	r23
   105e4:	67 95       	ror	r22
   105e6:	ba 95       	dec	r27
   105e8:	c9 f7       	brne	.-14     	; 0x105dc <__ultoa_invert+0x86>
   105ea:	00 97       	sbiw	r24, 0x00	; 0
   105ec:	61 05       	cpc	r22, r1
   105ee:	71 05       	cpc	r23, r1
   105f0:	08 95       	ret
   105f2:	9b 01       	movw	r18, r22
   105f4:	ac 01       	movw	r20, r24
   105f6:	0a 2e       	mov	r0, r26
   105f8:	06 94       	lsr	r0
   105fa:	57 95       	ror	r21
   105fc:	47 95       	ror	r20
   105fe:	37 95       	ror	r19
   10600:	27 95       	ror	r18
   10602:	ba 95       	dec	r27
   10604:	c9 f7       	brne	.-14     	; 0x105f8 <__ultoa_invert+0xa2>
   10606:	62 0f       	add	r22, r18
   10608:	73 1f       	adc	r23, r19
   1060a:	84 1f       	adc	r24, r20
   1060c:	95 1f       	adc	r25, r21
   1060e:	a0 1d       	adc	r26, r0
   10610:	08 95       	ret

00010612 <__subsf3>:
   10612:	50 58       	subi	r21, 0x80	; 128

00010614 <__addsf3>:
   10614:	bb 27       	eor	r27, r27
   10616:	aa 27       	eor	r26, r26
   10618:	0e d0       	rcall	.+28     	; 0x10636 <__addsf3x>
   1061a:	af cc       	rjmp	.-1698   	; 0xff7a <__fp_round>
   1061c:	a0 dc       	rcall	.-1728   	; 0xff5e <__fp_pscA>
   1061e:	30 f0       	brcs	.+12     	; 0x1062c <__addsf3+0x18>
   10620:	a5 dc       	rcall	.-1718   	; 0xff6c <__fp_pscB>
   10622:	20 f0       	brcs	.+8      	; 0x1062c <__addsf3+0x18>
   10624:	31 f4       	brne	.+12     	; 0x10632 <__addsf3+0x1e>
   10626:	9f 3f       	cpi	r25, 0xFF	; 255
   10628:	11 f4       	brne	.+4      	; 0x1062e <__addsf3+0x1a>
   1062a:	1e f4       	brtc	.+6      	; 0x10632 <__addsf3+0x1e>
   1062c:	95 cc       	rjmp	.-1750   	; 0xff58 <__fp_nan>
   1062e:	0e f4       	brtc	.+2      	; 0x10632 <__addsf3+0x1e>
   10630:	e0 95       	com	r30
   10632:	e7 fb       	bst	r30, 7
   10634:	8b cc       	rjmp	.-1770   	; 0xff4c <__fp_inf>

00010636 <__addsf3x>:
   10636:	e9 2f       	mov	r30, r25
   10638:	b1 dc       	rcall	.-1694   	; 0xff9c <__fp_split3>
   1063a:	80 f3       	brcs	.-32     	; 0x1061c <__addsf3+0x8>
   1063c:	ba 17       	cp	r27, r26
   1063e:	62 07       	cpc	r22, r18
   10640:	73 07       	cpc	r23, r19
   10642:	84 07       	cpc	r24, r20
   10644:	95 07       	cpc	r25, r21
   10646:	18 f0       	brcs	.+6      	; 0x1064e <__addsf3x+0x18>
   10648:	71 f4       	brne	.+28     	; 0x10666 <__addsf3x+0x30>
   1064a:	9e f5       	brtc	.+102    	; 0x106b2 <__addsf3x+0x7c>
   1064c:	c9 cc       	rjmp	.-1646   	; 0xffe0 <__fp_zero>
   1064e:	0e f4       	brtc	.+2      	; 0x10652 <__addsf3x+0x1c>
   10650:	e0 95       	com	r30
   10652:	0b 2e       	mov	r0, r27
   10654:	ba 2f       	mov	r27, r26
   10656:	a0 2d       	mov	r26, r0
   10658:	0b 01       	movw	r0, r22
   1065a:	b9 01       	movw	r22, r18
   1065c:	90 01       	movw	r18, r0
   1065e:	0c 01       	movw	r0, r24
   10660:	ca 01       	movw	r24, r20
   10662:	a0 01       	movw	r20, r0
   10664:	11 24       	eor	r1, r1
   10666:	ff 27       	eor	r31, r31
   10668:	59 1b       	sub	r21, r25
   1066a:	99 f0       	breq	.+38     	; 0x10692 <__addsf3x+0x5c>
   1066c:	59 3f       	cpi	r21, 0xF9	; 249
   1066e:	50 f4       	brcc	.+20     	; 0x10684 <__addsf3x+0x4e>
   10670:	50 3e       	cpi	r21, 0xE0	; 224
   10672:	68 f1       	brcs	.+90     	; 0x106ce <__addsf3x+0x98>
   10674:	1a 16       	cp	r1, r26
   10676:	f0 40       	sbci	r31, 0x00	; 0
   10678:	a2 2f       	mov	r26, r18
   1067a:	23 2f       	mov	r18, r19
   1067c:	34 2f       	mov	r19, r20
   1067e:	44 27       	eor	r20, r20
   10680:	58 5f       	subi	r21, 0xF8	; 248
   10682:	f3 cf       	rjmp	.-26     	; 0x1066a <__addsf3x+0x34>
   10684:	46 95       	lsr	r20
   10686:	37 95       	ror	r19
   10688:	27 95       	ror	r18
   1068a:	a7 95       	ror	r26
   1068c:	f0 40       	sbci	r31, 0x00	; 0
   1068e:	53 95       	inc	r21
   10690:	c9 f7       	brne	.-14     	; 0x10684 <__addsf3x+0x4e>
   10692:	7e f4       	brtc	.+30     	; 0x106b2 <__addsf3x+0x7c>
   10694:	1f 16       	cp	r1, r31
   10696:	ba 0b       	sbc	r27, r26
   10698:	62 0b       	sbc	r22, r18
   1069a:	73 0b       	sbc	r23, r19
   1069c:	84 0b       	sbc	r24, r20
   1069e:	ba f0       	brmi	.+46     	; 0x106ce <__addsf3x+0x98>
   106a0:	91 50       	subi	r25, 0x01	; 1
   106a2:	a1 f0       	breq	.+40     	; 0x106cc <__addsf3x+0x96>
   106a4:	ff 0f       	add	r31, r31
   106a6:	bb 1f       	adc	r27, r27
   106a8:	66 1f       	adc	r22, r22
   106aa:	77 1f       	adc	r23, r23
   106ac:	88 1f       	adc	r24, r24
   106ae:	c2 f7       	brpl	.-16     	; 0x106a0 <__addsf3x+0x6a>
   106b0:	0e c0       	rjmp	.+28     	; 0x106ce <__addsf3x+0x98>
   106b2:	ba 0f       	add	r27, r26
   106b4:	62 1f       	adc	r22, r18
   106b6:	73 1f       	adc	r23, r19
   106b8:	84 1f       	adc	r24, r20
   106ba:	48 f4       	brcc	.+18     	; 0x106ce <__addsf3x+0x98>
   106bc:	87 95       	ror	r24
   106be:	77 95       	ror	r23
   106c0:	67 95       	ror	r22
   106c2:	b7 95       	ror	r27
   106c4:	f7 95       	ror	r31
   106c6:	9e 3f       	cpi	r25, 0xFE	; 254
   106c8:	08 f0       	brcs	.+2      	; 0x106cc <__addsf3x+0x96>
   106ca:	b3 cf       	rjmp	.-154    	; 0x10632 <__addsf3+0x1e>
   106cc:	93 95       	inc	r25
   106ce:	88 0f       	add	r24, r24
   106d0:	08 f0       	brcs	.+2      	; 0x106d4 <__addsf3x+0x9e>
   106d2:	99 27       	eor	r25, r25
   106d4:	ee 0f       	add	r30, r30
   106d6:	97 95       	ror	r25
   106d8:	87 95       	ror	r24
   106da:	08 95       	ret

000106dc <__divsf3>:
   106dc:	0c d0       	rcall	.+24     	; 0x106f6 <__divsf3x>
   106de:	4d cc       	rjmp	.-1894   	; 0xff7a <__fp_round>
   106e0:	45 dc       	rcall	.-1910   	; 0xff6c <__fp_pscB>
   106e2:	40 f0       	brcs	.+16     	; 0x106f4 <__divsf3+0x18>
   106e4:	3c dc       	rcall	.-1928   	; 0xff5e <__fp_pscA>
   106e6:	30 f0       	brcs	.+12     	; 0x106f4 <__divsf3+0x18>
   106e8:	21 f4       	brne	.+8      	; 0x106f2 <__divsf3+0x16>
   106ea:	5f 3f       	cpi	r21, 0xFF	; 255
   106ec:	19 f0       	breq	.+6      	; 0x106f4 <__divsf3+0x18>
   106ee:	2e cc       	rjmp	.-1956   	; 0xff4c <__fp_inf>
   106f0:	51 11       	cpse	r21, r1
   106f2:	77 cc       	rjmp	.-1810   	; 0xffe2 <__fp_szero>
   106f4:	31 cc       	rjmp	.-1950   	; 0xff58 <__fp_nan>

000106f6 <__divsf3x>:
   106f6:	52 dc       	rcall	.-1884   	; 0xff9c <__fp_split3>
   106f8:	98 f3       	brcs	.-26     	; 0x106e0 <__divsf3+0x4>

000106fa <__divsf3_pse>:
   106fa:	99 23       	and	r25, r25
   106fc:	c9 f3       	breq	.-14     	; 0x106f0 <__divsf3+0x14>
   106fe:	55 23       	and	r21, r21
   10700:	b1 f3       	breq	.-20     	; 0x106ee <__divsf3+0x12>
   10702:	95 1b       	sub	r25, r21
   10704:	55 0b       	sbc	r21, r21
   10706:	bb 27       	eor	r27, r27
   10708:	aa 27       	eor	r26, r26
   1070a:	62 17       	cp	r22, r18
   1070c:	73 07       	cpc	r23, r19
   1070e:	84 07       	cpc	r24, r20
   10710:	38 f0       	brcs	.+14     	; 0x10720 <__divsf3_pse+0x26>
   10712:	9f 5f       	subi	r25, 0xFF	; 255
   10714:	5f 4f       	sbci	r21, 0xFF	; 255
   10716:	22 0f       	add	r18, r18
   10718:	33 1f       	adc	r19, r19
   1071a:	44 1f       	adc	r20, r20
   1071c:	aa 1f       	adc	r26, r26
   1071e:	a9 f3       	breq	.-22     	; 0x1070a <__divsf3_pse+0x10>
   10720:	33 d0       	rcall	.+102    	; 0x10788 <__divsf3_pse+0x8e>
   10722:	0e 2e       	mov	r0, r30
   10724:	3a f0       	brmi	.+14     	; 0x10734 <__divsf3_pse+0x3a>
   10726:	e0 e8       	ldi	r30, 0x80	; 128
   10728:	30 d0       	rcall	.+96     	; 0x1078a <__divsf3_pse+0x90>
   1072a:	91 50       	subi	r25, 0x01	; 1
   1072c:	50 40       	sbci	r21, 0x00	; 0
   1072e:	e6 95       	lsr	r30
   10730:	00 1c       	adc	r0, r0
   10732:	ca f7       	brpl	.-14     	; 0x10726 <__divsf3_pse+0x2c>
   10734:	29 d0       	rcall	.+82     	; 0x10788 <__divsf3_pse+0x8e>
   10736:	fe 2f       	mov	r31, r30
   10738:	27 d0       	rcall	.+78     	; 0x10788 <__divsf3_pse+0x8e>
   1073a:	66 0f       	add	r22, r22
   1073c:	77 1f       	adc	r23, r23
   1073e:	88 1f       	adc	r24, r24
   10740:	bb 1f       	adc	r27, r27
   10742:	26 17       	cp	r18, r22
   10744:	37 07       	cpc	r19, r23
   10746:	48 07       	cpc	r20, r24
   10748:	ab 07       	cpc	r26, r27
   1074a:	b0 e8       	ldi	r27, 0x80	; 128
   1074c:	09 f0       	breq	.+2      	; 0x10750 <__divsf3_pse+0x56>
   1074e:	bb 0b       	sbc	r27, r27
   10750:	80 2d       	mov	r24, r0
   10752:	bf 01       	movw	r22, r30
   10754:	ff 27       	eor	r31, r31
   10756:	93 58       	subi	r25, 0x83	; 131
   10758:	5f 4f       	sbci	r21, 0xFF	; 255
   1075a:	2a f0       	brmi	.+10     	; 0x10766 <__divsf3_pse+0x6c>
   1075c:	9e 3f       	cpi	r25, 0xFE	; 254
   1075e:	51 05       	cpc	r21, r1
   10760:	68 f0       	brcs	.+26     	; 0x1077c <__divsf3_pse+0x82>
   10762:	f4 cb       	rjmp	.-2072   	; 0xff4c <__fp_inf>
   10764:	3e cc       	rjmp	.-1924   	; 0xffe2 <__fp_szero>
   10766:	5f 3f       	cpi	r21, 0xFF	; 255
   10768:	ec f3       	brlt	.-6      	; 0x10764 <__divsf3_pse+0x6a>
   1076a:	98 3e       	cpi	r25, 0xE8	; 232
   1076c:	dc f3       	brlt	.-10     	; 0x10764 <__divsf3_pse+0x6a>
   1076e:	86 95       	lsr	r24
   10770:	77 95       	ror	r23
   10772:	67 95       	ror	r22
   10774:	b7 95       	ror	r27
   10776:	f7 95       	ror	r31
   10778:	9f 5f       	subi	r25, 0xFF	; 255
   1077a:	c9 f7       	brne	.-14     	; 0x1076e <__divsf3_pse+0x74>
   1077c:	88 0f       	add	r24, r24
   1077e:	91 1d       	adc	r25, r1
   10780:	96 95       	lsr	r25
   10782:	87 95       	ror	r24
   10784:	97 f9       	bld	r25, 7
   10786:	08 95       	ret
   10788:	e1 e0       	ldi	r30, 0x01	; 1
   1078a:	66 0f       	add	r22, r22
   1078c:	77 1f       	adc	r23, r23
   1078e:	88 1f       	adc	r24, r24
   10790:	bb 1f       	adc	r27, r27
   10792:	62 17       	cp	r22, r18
   10794:	73 07       	cpc	r23, r19
   10796:	84 07       	cpc	r24, r20
   10798:	ba 07       	cpc	r27, r26
   1079a:	20 f0       	brcs	.+8      	; 0x107a4 <__divsf3_pse+0xaa>
   1079c:	62 1b       	sub	r22, r18
   1079e:	73 0b       	sbc	r23, r19
   107a0:	84 0b       	sbc	r24, r20
   107a2:	ba 0b       	sbc	r27, r26
   107a4:	ee 1f       	adc	r30, r30
   107a6:	88 f7       	brcc	.-30     	; 0x1078a <__divsf3_pse+0x90>
   107a8:	e0 95       	com	r30
   107aa:	08 95       	ret

000107ac <__fixsfsi>:
   107ac:	04 d0       	rcall	.+8      	; 0x107b6 <__fixunssfsi>
   107ae:	68 94       	set
   107b0:	b1 11       	cpse	r27, r1
   107b2:	17 cc       	rjmp	.-2002   	; 0xffe2 <__fp_szero>
   107b4:	08 95       	ret

000107b6 <__fixunssfsi>:
   107b6:	fa db       	rcall	.-2060   	; 0xffac <__fp_splitA>
   107b8:	88 f0       	brcs	.+34     	; 0x107dc <__fixunssfsi+0x26>
   107ba:	9f 57       	subi	r25, 0x7F	; 127
   107bc:	90 f0       	brcs	.+36     	; 0x107e2 <__fixunssfsi+0x2c>
   107be:	b9 2f       	mov	r27, r25
   107c0:	99 27       	eor	r25, r25
   107c2:	b7 51       	subi	r27, 0x17	; 23
   107c4:	a0 f0       	brcs	.+40     	; 0x107ee <__fixunssfsi+0x38>
   107c6:	d1 f0       	breq	.+52     	; 0x107fc <__fixunssfsi+0x46>
   107c8:	66 0f       	add	r22, r22
   107ca:	77 1f       	adc	r23, r23
   107cc:	88 1f       	adc	r24, r24
   107ce:	99 1f       	adc	r25, r25
   107d0:	1a f0       	brmi	.+6      	; 0x107d8 <__fixunssfsi+0x22>
   107d2:	ba 95       	dec	r27
   107d4:	c9 f7       	brne	.-14     	; 0x107c8 <__fixunssfsi+0x12>
   107d6:	12 c0       	rjmp	.+36     	; 0x107fc <__fixunssfsi+0x46>
   107d8:	b1 30       	cpi	r27, 0x01	; 1
   107da:	81 f0       	breq	.+32     	; 0x107fc <__fixunssfsi+0x46>
   107dc:	01 dc       	rcall	.-2046   	; 0xffe0 <__fp_zero>
   107de:	b1 e0       	ldi	r27, 0x01	; 1
   107e0:	08 95       	ret
   107e2:	fe cb       	rjmp	.-2052   	; 0xffe0 <__fp_zero>
   107e4:	67 2f       	mov	r22, r23
   107e6:	78 2f       	mov	r23, r24
   107e8:	88 27       	eor	r24, r24
   107ea:	b8 5f       	subi	r27, 0xF8	; 248
   107ec:	39 f0       	breq	.+14     	; 0x107fc <__fixunssfsi+0x46>
   107ee:	b9 3f       	cpi	r27, 0xF9	; 249
   107f0:	cc f3       	brlt	.-14     	; 0x107e4 <__fixunssfsi+0x2e>
   107f2:	86 95       	lsr	r24
   107f4:	77 95       	ror	r23
   107f6:	67 95       	ror	r22
   107f8:	b3 95       	inc	r27
   107fa:	d9 f7       	brne	.-10     	; 0x107f2 <__fixunssfsi+0x3c>
   107fc:	3e f4       	brtc	.+14     	; 0x1080c <__fixunssfsi+0x56>
   107fe:	90 95       	com	r25
   10800:	80 95       	com	r24
   10802:	70 95       	com	r23
   10804:	61 95       	neg	r22
   10806:	7f 4f       	sbci	r23, 0xFF	; 255
   10808:	8f 4f       	sbci	r24, 0xFF	; 255
   1080a:	9f 4f       	sbci	r25, 0xFF	; 255
   1080c:	08 95       	ret

0001080e <__eerd_block_m2560>:
   1080e:	dc 01       	movw	r26, r24
   10810:	cb 01       	movw	r24, r22

00010812 <__eerd_blraw_m2560>:
   10812:	fc 01       	movw	r30, r24
   10814:	f9 99       	sbic	0x1f, 1	; 31
   10816:	fe cf       	rjmp	.-4      	; 0x10814 <__eerd_blraw_m2560+0x2>
   10818:	06 c0       	rjmp	.+12     	; 0x10826 <__eerd_blraw_m2560+0x14>
   1081a:	f2 bd       	out	0x22, r31	; 34
   1081c:	e1 bd       	out	0x21, r30	; 33
   1081e:	f8 9a       	sbi	0x1f, 0	; 31
   10820:	31 96       	adiw	r30, 0x01	; 1
   10822:	00 b4       	in	r0, 0x20	; 32
   10824:	0d 92       	st	X+, r0
   10826:	41 50       	subi	r20, 0x01	; 1
   10828:	50 40       	sbci	r21, 0x00	; 0
   1082a:	b8 f7       	brcc	.-18     	; 0x1081a <__eerd_blraw_m2560+0x8>
   1082c:	08 95       	ret

0001082e <__eerd_byte_m2560>:
   1082e:	f9 99       	sbic	0x1f, 1	; 31
   10830:	fe cf       	rjmp	.-4      	; 0x1082e <__eerd_byte_m2560>
   10832:	92 bd       	out	0x22, r25	; 34
   10834:	81 bd       	out	0x21, r24	; 33
   10836:	f8 9a       	sbi	0x1f, 0	; 31
   10838:	99 27       	eor	r25, r25
   1083a:	80 b5       	in	r24, 0x20	; 32
   1083c:	08 95       	ret

0001083e <__eerd_dword_m2560>:
   1083e:	a6 e1       	ldi	r26, 0x16	; 22
   10840:	b0 e0       	ldi	r27, 0x00	; 0
   10842:	44 e0       	ldi	r20, 0x04	; 4
   10844:	50 e0       	ldi	r21, 0x00	; 0
   10846:	0c 94 09 84 	jmp	0x10812	; 0x10812 <__eerd_blraw_m2560>

0001084a <__eerd_word_m2560>:
   1084a:	a8 e1       	ldi	r26, 0x18	; 24
   1084c:	b0 e0       	ldi	r27, 0x00	; 0
   1084e:	42 e0       	ldi	r20, 0x02	; 2
   10850:	50 e0       	ldi	r21, 0x00	; 0
   10852:	0c 94 09 84 	jmp	0x10812	; 0x10812 <__eerd_blraw_m2560>

00010856 <__eewr_block_m2560>:
   10856:	dc 01       	movw	r26, r24
   10858:	cb 01       	movw	r24, r22
   1085a:	03 c0       	rjmp	.+6      	; 0x10862 <__eewr_block_m2560+0xc>
   1085c:	2d 91       	ld	r18, X+
   1085e:	0e 94 36 84 	call	0x1086c	; 0x1086c <__eewr_r18_m2560>
   10862:	41 50       	subi	r20, 0x01	; 1
   10864:	50 40       	sbci	r21, 0x00	; 0
   10866:	d0 f7       	brcc	.-12     	; 0x1085c <__eewr_block_m2560+0x6>
   10868:	08 95       	ret

0001086a <__eewr_byte_m2560>:
   1086a:	26 2f       	mov	r18, r22

0001086c <__eewr_r18_m2560>:
   1086c:	f9 99       	sbic	0x1f, 1	; 31
   1086e:	fe cf       	rjmp	.-4      	; 0x1086c <__eewr_r18_m2560>
   10870:	1f ba       	out	0x1f, r1	; 31
   10872:	92 bd       	out	0x22, r25	; 34
   10874:	81 bd       	out	0x21, r24	; 33
   10876:	20 bd       	out	0x20, r18	; 32
   10878:	0f b6       	in	r0, 0x3f	; 63
   1087a:	f8 94       	cli
   1087c:	fa 9a       	sbi	0x1f, 2	; 31
   1087e:	f9 9a       	sbi	0x1f, 1	; 31
   10880:	0f be       	out	0x3f, r0	; 63
   10882:	01 96       	adiw	r24, 0x01	; 1
   10884:	08 95       	ret

00010886 <__eewr_dword_m2560>:
   10886:	24 2f       	mov	r18, r20
   10888:	0e 94 36 84 	call	0x1086c	; 0x1086c <__eewr_r18_m2560>
   1088c:	25 2f       	mov	r18, r21
   1088e:	0e 94 36 84 	call	0x1086c	; 0x1086c <__eewr_r18_m2560>
   10892:	0c 94 4b 84 	jmp	0x10896	; 0x10896 <__eewr_word_m2560>

00010896 <__eewr_word_m2560>:
   10896:	0e 94 35 84 	call	0x1086a	; 0x1086a <__eewr_byte_m2560>
   1089a:	27 2f       	mov	r18, r23
   1089c:	0c 94 36 84 	jmp	0x1086c	; 0x1086c <__eewr_r18_m2560>

000108a0 <__ctype_isfalse>:
   108a0:	99 27       	eor	r25, r25
   108a2:	88 27       	eor	r24, r24

000108a4 <__ctype_istrue>:
   108a4:	08 95       	ret

000108a6 <__mulsi3>:
   108a6:	62 9f       	mul	r22, r18
   108a8:	d0 01       	movw	r26, r0
   108aa:	73 9f       	mul	r23, r19
   108ac:	f0 01       	movw	r30, r0
   108ae:	82 9f       	mul	r24, r18
   108b0:	e0 0d       	add	r30, r0
   108b2:	f1 1d       	adc	r31, r1
   108b4:	64 9f       	mul	r22, r20
   108b6:	e0 0d       	add	r30, r0
   108b8:	f1 1d       	adc	r31, r1
   108ba:	92 9f       	mul	r25, r18
   108bc:	f0 0d       	add	r31, r0
   108be:	83 9f       	mul	r24, r19
   108c0:	f0 0d       	add	r31, r0
   108c2:	74 9f       	mul	r23, r20
   108c4:	f0 0d       	add	r31, r0
   108c6:	65 9f       	mul	r22, r21
   108c8:	f0 0d       	add	r31, r0
   108ca:	99 27       	eor	r25, r25
   108cc:	72 9f       	mul	r23, r18
   108ce:	b0 0d       	add	r27, r0
   108d0:	e1 1d       	adc	r30, r1
   108d2:	f9 1f       	adc	r31, r25
   108d4:	63 9f       	mul	r22, r19
   108d6:	b0 0d       	add	r27, r0
   108d8:	e1 1d       	adc	r30, r1
   108da:	f9 1f       	adc	r31, r25
   108dc:	bd 01       	movw	r22, r26
   108de:	cf 01       	movw	r24, r30
   108e0:	11 24       	eor	r1, r1
   108e2:	08 95       	ret

000108e4 <__udivmodqi4>:
   108e4:	99 1b       	sub	r25, r25
   108e6:	79 e0       	ldi	r23, 0x09	; 9
   108e8:	04 c0       	rjmp	.+8      	; 0x108f2 <__udivmodqi4_ep>

000108ea <__udivmodqi4_loop>:
   108ea:	99 1f       	adc	r25, r25
   108ec:	96 17       	cp	r25, r22
   108ee:	08 f0       	brcs	.+2      	; 0x108f2 <__udivmodqi4_ep>
   108f0:	96 1b       	sub	r25, r22

000108f2 <__udivmodqi4_ep>:
   108f2:	88 1f       	adc	r24, r24
   108f4:	7a 95       	dec	r23
   108f6:	c9 f7       	brne	.-14     	; 0x108ea <__udivmodqi4_loop>
   108f8:	80 95       	com	r24
   108fa:	08 95       	ret

000108fc <__udivmodhi4>:
   108fc:	aa 1b       	sub	r26, r26
   108fe:	bb 1b       	sub	r27, r27
   10900:	51 e1       	ldi	r21, 0x11	; 17
   10902:	07 c0       	rjmp	.+14     	; 0x10912 <__udivmodhi4_ep>

00010904 <__udivmodhi4_loop>:
   10904:	aa 1f       	adc	r26, r26
   10906:	bb 1f       	adc	r27, r27
   10908:	a6 17       	cp	r26, r22
   1090a:	b7 07       	cpc	r27, r23
   1090c:	10 f0       	brcs	.+4      	; 0x10912 <__udivmodhi4_ep>
   1090e:	a6 1b       	sub	r26, r22
   10910:	b7 0b       	sbc	r27, r23

00010912 <__udivmodhi4_ep>:
   10912:	88 1f       	adc	r24, r24
   10914:	99 1f       	adc	r25, r25
   10916:	5a 95       	dec	r21
   10918:	a9 f7       	brne	.-22     	; 0x10904 <__udivmodhi4_loop>
   1091a:	80 95       	com	r24
   1091c:	90 95       	com	r25
   1091e:	bc 01       	movw	r22, r24
   10920:	cd 01       	movw	r24, r26
   10922:	08 95       	ret

00010924 <__divmodhi4>:
   10924:	97 fb       	bst	r25, 7
   10926:	09 2e       	mov	r0, r25
   10928:	07 26       	eor	r0, r23
   1092a:	0a d0       	rcall	.+20     	; 0x10940 <__divmodhi4_neg1>
   1092c:	77 fd       	sbrc	r23, 7
   1092e:	04 d0       	rcall	.+8      	; 0x10938 <__divmodhi4_neg2>
   10930:	e5 df       	rcall	.-54     	; 0x108fc <__udivmodhi4>
   10932:	06 d0       	rcall	.+12     	; 0x10940 <__divmodhi4_neg1>
   10934:	00 20       	and	r0, r0
   10936:	1a f4       	brpl	.+6      	; 0x1093e <__divmodhi4_exit>

00010938 <__divmodhi4_neg2>:
   10938:	70 95       	com	r23
   1093a:	61 95       	neg	r22
   1093c:	7f 4f       	sbci	r23, 0xFF	; 255

0001093e <__divmodhi4_exit>:
   1093e:	08 95       	ret

00010940 <__divmodhi4_neg1>:
   10940:	f6 f7       	brtc	.-4      	; 0x1093e <__divmodhi4_exit>
   10942:	90 95       	com	r25
   10944:	81 95       	neg	r24
   10946:	9f 4f       	sbci	r25, 0xFF	; 255
   10948:	08 95       	ret

0001094a <__udivmodsi4>:
   1094a:	a1 e2       	ldi	r26, 0x21	; 33
   1094c:	1a 2e       	mov	r1, r26
   1094e:	aa 1b       	sub	r26, r26
   10950:	bb 1b       	sub	r27, r27
   10952:	fd 01       	movw	r30, r26
   10954:	0d c0       	rjmp	.+26     	; 0x10970 <__udivmodsi4_ep>

00010956 <__udivmodsi4_loop>:
   10956:	aa 1f       	adc	r26, r26
   10958:	bb 1f       	adc	r27, r27
   1095a:	ee 1f       	adc	r30, r30
   1095c:	ff 1f       	adc	r31, r31
   1095e:	a2 17       	cp	r26, r18
   10960:	b3 07       	cpc	r27, r19
   10962:	e4 07       	cpc	r30, r20
   10964:	f5 07       	cpc	r31, r21
   10966:	20 f0       	brcs	.+8      	; 0x10970 <__udivmodsi4_ep>
   10968:	a2 1b       	sub	r26, r18
   1096a:	b3 0b       	sbc	r27, r19
   1096c:	e4 0b       	sbc	r30, r20
   1096e:	f5 0b       	sbc	r31, r21

00010970 <__udivmodsi4_ep>:
   10970:	66 1f       	adc	r22, r22
   10972:	77 1f       	adc	r23, r23
   10974:	88 1f       	adc	r24, r24
   10976:	99 1f       	adc	r25, r25
   10978:	1a 94       	dec	r1
   1097a:	69 f7       	brne	.-38     	; 0x10956 <__udivmodsi4_loop>
   1097c:	60 95       	com	r22
   1097e:	70 95       	com	r23
   10980:	80 95       	com	r24
   10982:	90 95       	com	r25
   10984:	9b 01       	movw	r18, r22
   10986:	ac 01       	movw	r20, r24
   10988:	bd 01       	movw	r22, r26
   1098a:	cf 01       	movw	r24, r30
   1098c:	08 95       	ret

0001098e <__divmodsi4>:
   1098e:	97 fb       	bst	r25, 7
   10990:	09 2e       	mov	r0, r25
   10992:	05 26       	eor	r0, r21
   10994:	0e d0       	rcall	.+28     	; 0x109b2 <__divmodsi4_neg1>
   10996:	57 fd       	sbrc	r21, 7
   10998:	04 d0       	rcall	.+8      	; 0x109a2 <__divmodsi4_neg2>
   1099a:	d7 df       	rcall	.-82     	; 0x1094a <__udivmodsi4>
   1099c:	0a d0       	rcall	.+20     	; 0x109b2 <__divmodsi4_neg1>
   1099e:	00 1c       	adc	r0, r0
   109a0:	38 f4       	brcc	.+14     	; 0x109b0 <__divmodsi4_exit>

000109a2 <__divmodsi4_neg2>:
   109a2:	50 95       	com	r21
   109a4:	40 95       	com	r20
   109a6:	30 95       	com	r19
   109a8:	21 95       	neg	r18
   109aa:	3f 4f       	sbci	r19, 0xFF	; 255
   109ac:	4f 4f       	sbci	r20, 0xFF	; 255
   109ae:	5f 4f       	sbci	r21, 0xFF	; 255

000109b0 <__divmodsi4_exit>:
   109b0:	08 95       	ret

000109b2 <__divmodsi4_neg1>:
   109b2:	f6 f7       	brtc	.-4      	; 0x109b0 <__divmodsi4_exit>
   109b4:	90 95       	com	r25
   109b6:	80 95       	com	r24
   109b8:	70 95       	com	r23
   109ba:	61 95       	neg	r22
   109bc:	7f 4f       	sbci	r23, 0xFF	; 255
   109be:	8f 4f       	sbci	r24, 0xFF	; 255
   109c0:	9f 4f       	sbci	r25, 0xFF	; 255
   109c2:	08 95       	ret

000109c4 <_exit>:
   109c4:	f8 94       	cli

000109c6 <__stop_program>:
   109c6:	ff cf       	rjmp	.-2      	; 0x109c6 <__stop_program>
