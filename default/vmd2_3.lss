
vmd2_3.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000d6  00800200  0000fba0  0000fc54  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000fba0  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000094c  008002d6  008002d6  0000fd2a  2**0
                  ALLOC
  3 .eeprom       00000140  00810000  00810000  0000fd2a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .debug_aranges 00000020  00000000  00000000  0000fe6a  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 00002e3c  00000000  00000000  0000fe8a  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000f2fe  00000000  00000000  00012cc6  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000713  00000000  00000000  00021fc4  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000086d3  00000000  00000000  000226d7  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001290  00000000  00000000  0002adac  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00003486  00000000  00000000  0002c03c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000849d  00000000  00000000  0002f4c2  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000f40  00000000  00000000  0003795f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 27 18 	jmp	0x304e	; 0x304e <__ctors_end>
       4:	0c 94 48 18 	jmp	0x3090	; 0x3090 <__bad_interrupt>
       8:	0c 94 48 18 	jmp	0x3090	; 0x3090 <__bad_interrupt>
       c:	0c 94 48 18 	jmp	0x3090	; 0x3090 <__bad_interrupt>
      10:	0c 94 48 18 	jmp	0x3090	; 0x3090 <__bad_interrupt>
      14:	0c 94 48 18 	jmp	0x3090	; 0x3090 <__bad_interrupt>
      18:	0c 94 48 18 	jmp	0x3090	; 0x3090 <__bad_interrupt>
      1c:	0c 94 48 18 	jmp	0x3090	; 0x3090 <__bad_interrupt>
      20:	0c 94 48 18 	jmp	0x3090	; 0x3090 <__bad_interrupt>
      24:	0c 94 48 18 	jmp	0x3090	; 0x3090 <__bad_interrupt>
      28:	0c 94 48 18 	jmp	0x3090	; 0x3090 <__bad_interrupt>
      2c:	0c 94 48 18 	jmp	0x3090	; 0x3090 <__bad_interrupt>
      30:	0c 94 48 18 	jmp	0x3090	; 0x3090 <__bad_interrupt>
      34:	0c 94 f3 27 	jmp	0x4fe6	; 0x4fe6 <__vector_13>
      38:	0c 94 48 18 	jmp	0x3090	; 0x3090 <__bad_interrupt>
      3c:	0c 94 48 18 	jmp	0x3090	; 0x3090 <__bad_interrupt>
      40:	0c 94 48 18 	jmp	0x3090	; 0x3090 <__bad_interrupt>
      44:	0c 94 97 1c 	jmp	0x392e	; 0x392e <__vector_17>
      48:	0c 94 c0 25 	jmp	0x4b80	; 0x4b80 <__vector_18>
      4c:	0c 94 48 18 	jmp	0x3090	; 0x3090 <__bad_interrupt>
      50:	0c 94 48 18 	jmp	0x3090	; 0x3090 <__bad_interrupt>
      54:	0c 94 c1 27 	jmp	0x4f82	; 0x4f82 <__vector_21>
      58:	0c 94 48 18 	jmp	0x3090	; 0x3090 <__bad_interrupt>
      5c:	0c 94 48 18 	jmp	0x3090	; 0x3090 <__bad_interrupt>
      60:	0c 94 48 18 	jmp	0x3090	; 0x3090 <__bad_interrupt>
      64:	0c 94 1e 39 	jmp	0x723c	; 0x723c <__vector_25>
      68:	0c 94 72 39 	jmp	0x72e4	; 0x72e4 <__vector_26>
      6c:	0c 94 48 39 	jmp	0x7290	; 0x7290 <__vector_27>
      70:	0c 94 48 18 	jmp	0x3090	; 0x3090 <__bad_interrupt>
      74:	0c 94 48 18 	jmp	0x3090	; 0x3090 <__bad_interrupt>
      78:	0c 94 48 18 	jmp	0x3090	; 0x3090 <__bad_interrupt>
      7c:	0c 94 48 18 	jmp	0x3090	; 0x3090 <__bad_interrupt>
      80:	0c 94 48 18 	jmp	0x3090	; 0x3090 <__bad_interrupt>
      84:	0c 94 48 18 	jmp	0x3090	; 0x3090 <__bad_interrupt>
      88:	0c 94 48 18 	jmp	0x3090	; 0x3090 <__bad_interrupt>
      8c:	0c 94 48 18 	jmp	0x3090	; 0x3090 <__bad_interrupt>
      90:	0c 94 9c 39 	jmp	0x7338	; 0x7338 <__vector_36>
      94:	0c 94 f0 39 	jmp	0x73e0	; 0x73e0 <__vector_37>
      98:	0c 94 c6 39 	jmp	0x738c	; 0x738c <__vector_38>
      9c:	0c 94 48 18 	jmp	0x3090	; 0x3090 <__bad_interrupt>
      a0:	0c 94 48 18 	jmp	0x3090	; 0x3090 <__bad_interrupt>
      a4:	0c 94 48 18 	jmp	0x3090	; 0x3090 <__bad_interrupt>
      a8:	0c 94 27 28 	jmp	0x504e	; 0x504e <__vector_42>
      ac:	0c 94 48 18 	jmp	0x3090	; 0x3090 <__bad_interrupt>
      b0:	0c 94 48 18 	jmp	0x3090	; 0x3090 <__bad_interrupt>
      b4:	0c 94 48 18 	jmp	0x3090	; 0x3090 <__bad_interrupt>
      b8:	0c 94 48 18 	jmp	0x3090	; 0x3090 <__bad_interrupt>
      bc:	0c 94 48 18 	jmp	0x3090	; 0x3090 <__bad_interrupt>
      c0:	0c 94 48 18 	jmp	0x3090	; 0x3090 <__bad_interrupt>
      c4:	0c 94 48 18 	jmp	0x3090	; 0x3090 <__bad_interrupt>
      c8:	0c 94 48 18 	jmp	0x3090	; 0x3090 <__bad_interrupt>
      cc:	0c 94 6a 3a 	jmp	0x74d4	; 0x74d4 <__vector_51>
      d0:	0c 94 1a 3a 	jmp	0x7434	; 0x7434 <__vector_52>
      d4:	0c 94 42 3a 	jmp	0x7484	; 0x7484 <__vector_53>
      d8:	0c 94 48 18 	jmp	0x3090	; 0x3090 <__bad_interrupt>
      dc:	0c 94 48 18 	jmp	0x3090	; 0x3090 <__bad_interrupt>
      e0:	0c 94 48 18 	jmp	0x3090	; 0x3090 <__bad_interrupt>
      e4:	92 4f       	sbci	r25, 0xF2	; 242
      e6:	b8 4f       	sbci	r27, 0xF8	; 248
      e8:	c9 4f       	sbci	r28, 0xF9	; 249
      ea:	dc 4f       	sbci	r29, 0xFC	; 252
      ec:	92 4f       	sbci	r25, 0xF2	; 242
      ee:	b8 4f       	sbci	r27, 0xF8	; 248
      f0:	1c 4f       	sbci	r17, 0xFC	; 252
      f2:	f0 4f       	sbci	r31, 0xF0	; 240
      f4:	00 50       	subi	r16, 0x00	; 0
      f6:	10 50       	subi	r17, 0x00	; 0
      f8:	23 50       	subi	r18, 0x03	; 3
      fa:	f0 4f       	sbci	r31, 0xF0	; 240
      fc:	00 50       	subi	r16, 0x00	; 0
      fe:	36 50       	subi	r19, 0x06	; 6
     100:	36 50       	subi	r19, 0x06	; 6
     102:	1c 4f       	sbci	r17, 0xFC	; 252
     104:	1c 4f       	sbci	r17, 0xFC	; 252
     106:	1c 4f       	sbci	r17, 0xFC	; 252
     108:	1c 4f       	sbci	r17, 0xFC	; 252
     10a:	1c 4f       	sbci	r17, 0xFC	; 252
     10c:	1c 4f       	sbci	r17, 0xFC	; 252
     10e:	1c 4f       	sbci	r17, 0xFC	; 252
     110:	1c 4f       	sbci	r17, 0xFC	; 252
     112:	1c 4f       	sbci	r17, 0xFC	; 252
     114:	1c 4f       	sbci	r17, 0xFC	; 252
     116:	1c 4f       	sbci	r17, 0xFC	; 252
     118:	1c 4f       	sbci	r17, 0xFC	; 252
     11a:	1c 4f       	sbci	r17, 0xFC	; 252
     11c:	1c 4f       	sbci	r17, 0xFC	; 252
     11e:	44 50       	subi	r20, 0x04	; 4
     120:	52 50       	subi	r21, 0x02	; 2
     122:	61 50       	subi	r22, 0x01	; 1
     124:	72 50       	subi	r23, 0x02	; 2
     126:	62 53       	subi	r22, 0x32	; 50
     128:	81 53       	subi	r24, 0x31	; 49
     12a:	a2 53       	subi	r26, 0x32	; 50
     12c:	c5 53       	subi	r28, 0x35	; 53
     12e:	62 53       	subi	r22, 0x32	; 50
     130:	81 53       	subi	r24, 0x31	; 49
     132:	24 53       	subi	r18, 0x34	; 52
     134:	ea 53       	subi	r30, 0x3A	; 58
     136:	08 54       	subi	r16, 0x48	; 72
     138:	27 54       	subi	r18, 0x47	; 71
     13a:	49 54       	subi	r20, 0x49	; 73
     13c:	ea 53       	subi	r30, 0x3A	; 58
     13e:	08 54       	subi	r16, 0x48	; 72
     140:	6c 54       	subi	r22, 0x4C	; 76
     142:	6c 54       	subi	r22, 0x4C	; 76
     144:	24 53       	subi	r18, 0x34	; 52
     146:	74 54       	subi	r23, 0x44	; 68
     148:	ed 52       	subi	r30, 0x2D	; 45
     14a:	ab 54       	subi	r26, 0x4B	; 75
     14c:	e2 54       	subi	r30, 0x42	; 66
     14e:	74 54       	subi	r23, 0x44	; 68
     150:	ed 52       	subi	r30, 0x2D	; 45
     152:	24 53       	subi	r18, 0x34	; 52
     154:	24 53       	subi	r18, 0x34	; 52
     156:	24 53       	subi	r18, 0x34	; 52
     158:	1f 55       	subi	r17, 0x5F	; 95
     15a:	49 55       	subi	r20, 0x59	; 89
     15c:	1f 55       	subi	r17, 0x5F	; 95
     15e:	49 55       	subi	r20, 0x59	; 89
     160:	62 53       	subi	r22, 0x32	; 50
     162:	81 53       	subi	r24, 0x31	; 49
     164:	73 55       	subi	r23, 0x53	; 83
     166:	84 55       	subi	r24, 0x54	; 84
     168:	9b 55       	subi	r25, 0x5B	; 91
     16a:	40 53       	subi	r20, 0x30	; 48
     16c:	7b 58       	subi	r23, 0x8B	; 139
     16e:	7b 58       	subi	r23, 0x8B	; 139
     170:	32 58       	subi	r19, 0x82	; 130
     172:	32 58       	subi	r19, 0x82	; 130
     174:	7b 58       	subi	r23, 0x8B	; 139
     176:	7b 58       	subi	r23, 0x8B	; 139
     178:	3e 57       	subi	r19, 0x7E	; 126
     17a:	7b 58       	subi	r23, 0x8B	; 139
     17c:	7b 58       	subi	r23, 0x8B	; 139
     17e:	32 58       	subi	r19, 0x82	; 130
     180:	32 58       	subi	r19, 0x82	; 130
     182:	7b 58       	subi	r23, 0x8B	; 139
     184:	7b 58       	subi	r23, 0x8B	; 139
     186:	0e 58       	subi	r16, 0x8E	; 142
     188:	0e 58       	subi	r16, 0x8E	; 142
     18a:	3e 57       	subi	r19, 0x7E	; 126
     18c:	f6 57       	subi	r31, 0x76	; 118
     18e:	f6 57       	subi	r31, 0x76	; 118
     190:	f6 57       	subi	r31, 0x76	; 118
     192:	f6 57       	subi	r31, 0x76	; 118
     194:	f6 57       	subi	r31, 0x76	; 118
     196:	f6 57       	subi	r31, 0x76	; 118
     198:	3e 57       	subi	r19, 0x7E	; 126
     19a:	3e 57       	subi	r19, 0x7E	; 126
     19c:	3e 57       	subi	r19, 0x7E	; 126
     19e:	f6 57       	subi	r31, 0x76	; 118
     1a0:	f6 57       	subi	r31, 0x76	; 118
     1a2:	f6 57       	subi	r31, 0x76	; 118
     1a4:	f6 57       	subi	r31, 0x76	; 118
     1a6:	d8 57       	subi	r29, 0x78	; 120
     1a8:	d8 57       	subi	r29, 0x78	; 120
     1aa:	bb 57       	subi	r27, 0x7B	; 123
     1ac:	bb 57       	subi	r27, 0x7B	; 123
     1ae:	83 57       	subi	r24, 0x73	; 115
     1b0:	83 57       	subi	r24, 0x73	; 115
     1b2:	63 5b       	subi	r22, 0xB3	; 179
     1b4:	5a 5b       	subi	r21, 0xBA	; 186
     1b6:	52 5b       	subi	r21, 0xB2	; 178
     1b8:	47 5b       	subi	r20, 0xB7	; 183
     1ba:	41 5b       	subi	r20, 0xB1	; 177
     1bc:	38 5b       	subi	r19, 0xB8	; 184
     1be:	2f 5b       	subi	r18, 0xBF	; 191
     1c0:	29 5b       	subi	r18, 0xB9	; 185
     1c2:	21 5b       	subi	r18, 0xB1	; 177
     1c4:	1b 5b       	subi	r17, 0xBB	; 187
     1c6:	13 5b       	subi	r17, 0xB3	; 179
     1c8:	0d 5b       	subi	r16, 0xBD	; 189
     1ca:	05 5b       	subi	r16, 0xB5	; 181
     1cc:	29 5b       	subi	r18, 0xB9	; 185
     1ce:	0d 5b       	subi	r16, 0xBD	; 189
     1d0:	fc 5a       	subi	r31, 0xAC	; 172
     1d2:	f5 5a       	subi	r31, 0xA5	; 165
     1d4:	ee 5a       	subi	r30, 0xAE	; 174
     1d6:	e7 5a       	subi	r30, 0xA7	; 167
     1d8:	e0 5a       	subi	r30, 0xA0	; 160
     1da:	d9 5a       	subi	r29, 0xA9	; 169
     1dc:	d2 5a       	subi	r29, 0xA2	; 162
     1de:	f5 5a       	subi	r31, 0xA5	; 165
     1e0:	d9 5a       	subi	r29, 0xA9	; 169
     1e2:	c9 5a       	subi	r28, 0xA9	; 169
     1e4:	c2 5a       	subi	r28, 0xA2	; 162
     1e6:	b4 5a       	subi	r27, 0xA4	; 164
     1e8:	ad 5a       	subi	r26, 0xAD	; 173
     1ea:	9f 5a       	subi	r25, 0xAF	; 175
     1ec:	7f 5a       	subi	r23, 0xAF	; 175
     1ee:	8e 5a       	subi	r24, 0xAE	; 174
     1f0:	58 5a       	subi	r21, 0xA8	; 168
     1f2:	0b 5a       	subi	r16, 0xAB	; 171
     1f4:	53 5a       	subi	r21, 0xA3	; 163
     1f6:	45 5a       	subi	r20, 0xA5	; 165
     1f8:	b9 62       	ori	r27, 0x29	; 41
     1fa:	ab 62       	ori	r26, 0x2B	; 43
     1fc:	9f 62       	ori	r25, 0x2F	; 47
     1fe:	c4 60       	ori	r28, 0x04	; 4
     200:	f7 60       	ori	r31, 0x07	; 7
     202:	ef 62       	ori	r30, 0x2F	; 47
     204:	22 61       	ori	r18, 0x12	; 18
     206:	91 62       	ori	r25, 0x21	; 33
     208:	85 62       	ori	r24, 0x25	; 37
     20a:	77 62       	ori	r23, 0x27	; 39
     20c:	6b 62       	ori	r22, 0x2B	; 43
     20e:	5d 62       	ori	r21, 0x2D	; 45
     210:	51 62       	ori	r21, 0x21	; 33
     212:	43 62       	ori	r20, 0x23	; 35
     214:	5d 60       	ori	r21, 0x0D	; 13
     216:	37 62       	ori	r19, 0x27	; 39
     218:	29 62       	ori	r18, 0x29	; 41
     21a:	11 62       	ori	r17, 0x21	; 33
     21c:	1d 62       	ori	r17, 0x2D	; 45
     21e:	00 62       	ori	r16, 0x20	; 32
     220:	ed 61       	ori	r30, 0x1D	; 29
     222:	dc 61       	ori	r29, 0x1C	; 28
     224:	c8 61       	ori	r28, 0x18	; 24
     226:	b7 61       	ori	r27, 0x17	; 23
     228:	a6 61       	ori	r26, 0x16	; 22
     22a:	91 61       	ori	r25, 0x11	; 17
     22c:	87 61       	ori	r24, 0x17	; 23
     22e:	76 61       	ori	r23, 0x16	; 22
     230:	6a 61       	ori	r22, 0x1A	; 26
     232:	5c 61       	ori	r21, 0x1C	; 28
     234:	50 61       	ori	r21, 0x10	; 16
     236:	42 61       	ori	r20, 0x12	; 18
     238:	ad 64       	ori	r26, 0x4D	; 77
     23a:	9f 64       	ori	r25, 0x4F	; 79
     23c:	93 64       	ori	r25, 0x43	; 67
     23e:	54 64       	ori	r21, 0x44	; 68
     240:	d4 63       	ori	r29, 0x34	; 52
     242:	c6 63       	ori	r28, 0x36	; 54
     244:	b4 63       	ori	r27, 0x34	; 52
     246:	a9 63       	ori	r26, 0x39	; 57
     248:	8e 63       	ori	r24, 0x3E	; 62
     24a:	4c 63       	ori	r20, 0x3C	; 60
     24c:	9c 63       	ori	r25, 0x3C	; 60
     24e:	39 63       	ori	r19, 0x39	; 57
     250:	23 63       	ori	r18, 0x33	; 51
     252:	17 63       	ori	r17, 0x37	; 55
     254:	09 63       	ori	r16, 0x39	; 57
     256:	fd 62       	ori	r31, 0x2D	; 45
     258:	a9 65       	ori	r26, 0x59	; 89
     25a:	5d 60       	ori	r21, 0x0D	; 13
     25c:	5d 60       	ori	r21, 0x0D	; 13
     25e:	6b 65       	ori	r22, 0x5B	; 91
     260:	61 65       	ori	r22, 0x51	; 81
     262:	0a 65       	ori	r16, 0x5A	; 90
     264:	fc 64       	ori	r31, 0x4C	; 76
     266:	db 64       	ori	r29, 0x4B	; 75
     268:	c4 64       	ori	r28, 0x44	; 68
     26a:	b9 64       	ori	r27, 0x49	; 73
     26c:	3d 66       	ori	r19, 0x6D	; 109
     26e:	d8 65       	ori	r29, 0x58	; 88
     270:	c7 65       	ori	r28, 0x57	; 87
     272:	bb 65       	ori	r27, 0x5B	; 91
     274:	4e 66       	ori	r20, 0x6E	; 110
     276:	08 66       	ori	r16, 0x68	; 104
     278:	1f 66       	ori	r17, 0x6F	; 111
     27a:	34 61       	ori	r19, 0x14	; 20
     27c:	05 61       	ori	r16, 0x15	; 21
     27e:	f9 6d       	ori	r31, 0xD9	; 217
     280:	00 6e       	ori	r16, 0xE0	; 224
     282:	ec 6d       	ori	r30, 0xDC	; 220
     284:	f3 6d       	ori	r31, 0xD3	; 211
     286:	e2 6d       	ori	r30, 0xD2	; 210
     288:	e8 6d       	ori	r30, 0xD8	; 216
     28a:	d5 6d       	ori	r29, 0xD5	; 213
     28c:	db 6d       	ori	r29, 0xDB	; 219
     28e:	07 6e       	ori	r16, 0xE7	; 231
     290:	d1 6d       	ori	r29, 0xD1	; 209
     292:	b9 6d       	ori	r27, 0xD9	; 217
     294:	8b 6e       	ori	r24, 0xEB	; 235
     296:	73 6e       	ori	r23, 0xE3	; 227
     298:	67 6e       	ori	r22, 0xE7	; 231
     29a:	4f 6e       	ori	r20, 0xEF	; 239
     29c:	33 6e       	ori	r19, 0xE3	; 227
     29e:	0f 6e       	ori	r16, 0xEF	; 239

000002a0 <__c.1790>:
     2a0:	6e 61 6e 00                                         nan.

000002a4 <__c.1788>:
     2a4:	69 6e 66 00                                         inf.

000002a8 <__c.2085>:
     2a8:	63 64 69 6e 6f 70 73 75 78 58 5b 65 66 67 45 46     cdinopsuxX[efgEF
     2b8:	47 00                                               G.

000002ba <pstr_an>:
     2ba:	61 6e 00                                            an.

000002bd <pstr_nfinity>:
     2bd:	6e 66 69 6e 69 74 79 00                             nfinity.

000002c5 <pwr_m10>:
     2c5:	cd cc cc 3d 0a d7 23 3c 17 b7 d1 38 77 cc 2b 32     ...=..#<...8w.+2
     2d5:	95 95 e6 24 1f b1 4f 0a                             ...$..O.

000002dd <pwr_p10>:
     2dd:	00 00 20 41 00 00 c8 42 00 40 1c 46 20 bc be 4c     .. A...B.@.F ..L
     2ed:	ca 1b 0e 5a ae c5 9d 74                             ...Z...t

000002f5 <DaysMonth>:
     2f5:	00 1f 1c 1f 1e 1f 1e 1f 1f 1e 1f 1e 1f              .............

00000302 <Modbus_Map>:
     302:	6c 07 20 00 f4 09 20 00 0f 0b 04 00 f3 07 50 00     l. ... .......P.

00000312 <BR_Tbl>:
     312:	42 03 ff a0 01 fb cf 00 7d 67 00 3f 44 00 2a 33     B.......}g.?D.*3
     322:	00 1f 22 00 1b 19 00 1b 10 00 1b                    .."........

0000032d <GSM_SIMCOM_SIM900R>:
     32d:	53 49 4d 43 4f 4d 5f 53 49 4d 39 30 30 52 00        SIMCOM_SIM900R.

0000033c <GSM_SIMCOM_SIM800>:
     33c:	53 49 4d 43 4f 4d 5f 53 49 4d 38 30 30 00           SIMCOM_SIM800.

0000034a <GSM_SIMCOM_SIM800C>:
     34a:	53 49 4d 43 4f 4d 5f 53 49 4d 38 30 30 43 00        SIMCOM_SIM800C.

00000359 <URC_RDY>:
     359:	52 44 59 00                                         RDY.

0000035d <URC_CFUN>:
     35d:	2b 43 46 55 4e 3a 20 31 00                          +CFUN: 1.

00000366 <URC_CPIN_READY>:
     366:	2b 43 50 49 4e 3a 20 52 45 41 44 59 00              +CPIN: READY.

00000373 <URC_CALL_READY>:
     373:	43 61 6c 6c 20 52 65 61 64 79 00                    Call Ready.

0000037e <URC_SMS_READY>:
     37e:	53 4d 53 20 52 65 61 64 79 00                       SMS Ready.

00000388 <URC_REMOTE_IP>:
     388:	52 45 4d 4f 54 45 20 49 50 00                       REMOTE IP.

00000392 <URC_CONNECT>:
     392:	43 4f 4e 4e 45 43 54 00                             CONNECT.

0000039a <URC_RECEIVE>:
     39a:	2b 52 45 43 45 49 56 45 2c 00                       +RECEIVE,.

000003a4 <URC_CLOSED>:
     3a4:	2c 20 43 4c 4f 53 45 44 00                          , CLOSED.

000003ad <URC_PDPDEACT>:
     3ad:	2b 50 44 50 20 44 45 41 43 54 00                    +PDP DEACT.

000003b8 <URC_NO_CARRIER>:
     3b8:	4e 4f 20 43 41 52 52 49 45 52 00                    NO CARRIER.

000003c3 <RESP_OK>:
     3c3:	4f 4b 00                                            OK.

000003c6 <RESP_CONNECT>:
     3c6:	43 4f 4e 4e 45 43 54 00                             CONNECT.

000003ce <RESP_CONNECT_OK>:
     3ce:	78 2c 20 43 4f 4e 4e 45 43 54 20 4f 4b 00           x, CONNECT OK.

000003dc <RESP_SERVER_OK>:
     3dc:	53 45 52 56 45 52 20 4f 4b 00                       SERVER OK.

000003e6 <RESP_SERVER_CLOSE>:
     3e6:	53 45 52 56 45 52 20 43 4c 4f 53 45 00              SERVER CLOSE.

000003f3 <RESP_Invitation>:
     3f3:	3e 00                                               >.

000003f5 <RESP_SEND_OK>:
     3f5:	78 2c 20 53 45 4e 44 20 4f 4b 00                    x, SEND OK.

00000400 <RESP_CLOSE_OK>:
     400:	43 4c 4f 53 45 20 4f 4b 00                          CLOSE OK.

00000409 <RESP_CLOSE_OK_FAST>:
     409:	78 2c 20 43 4c 4f 53 45 20 4f 4b 00                 x, CLOSE OK.

00000415 <RESP_CSQ>:
     415:	2b 43 53 51 3a 00                                   +CSQ:.

0000041b <RESP_SHUT_OK>:
     41b:	53 48 55 54 20 4f 4b 00                             SHUT OK.

00000423 <ESC_SEQ>:
     423:	2b 2b 2b 00                                         +++.

00000427 <IDENTIFICATION>:
     427:	49 44 45 4e 54 49 46 49 43 41 54 49 4f 4e 00        IDENTIFICATION.

00000436 <AT_AT>:
     436:	41 54 00                                            AT.

00000439 <AT_IPR9600>:
     439:	41 54 2b 49 50 52 3d 39 36 30 30 00                 AT+IPR=9600.

00000445 <AT_W>:
     445:	41 54 26 57 00                                      AT&W.

0000044a <AT_E0>:
     44a:	41 54 45 30 00                                      ATE0.

0000044f <AT_CLCC1>:
     44f:	41 54 2b 43 4c 43 43 3d 31 00                       AT+CLCC=1.

00000459 <AT_DDET101>:
     459:	41 54 2b 44 44 45 54 3d 31 2c 30 2c 31 00           AT+DDET=1,0,1.

00000467 <AT_CGMM>:
     467:	41 54 2b 43 47 4d 4d 00                             AT+CGMM.

0000046f <AT_CCID>:
     46f:	41 54 2b 43 43 49 44 00                             AT+CCID.

00000477 <AT_IFC>:
     477:	41 54 2b 49 46 43 3d 32 2c 32 00                    AT+IFC=2,2.

00000482 <ATD101>:
     482:	41 54 44 2a 31 30 31 23 00                          ATD*101#.

0000048b <AT_CUSD101>:
     48b:	41 54 2b 43 55 53 44 3d 31 2c 22 00                 AT+CUSD=1,".

00000497 <AT_CMGF>:
     497:	41 54 2b 43 4d 47 46 3d 31 00                       AT+CMGF=1.

000004a1 <AT_CSMP>:
     4a1:	41 54 2b 43 53 4d 50 3d 31 37 2c 31 36 37 2c 30     AT+CSMP=17,167,0
     4b1:	2c 30 00                                            ,0.

000004b4 <AT_CMGS>:
     4b4:	41 54 2b 43 4d 47 53 3d 22 2b 00                    AT+CMGS="+.

000004bf <AT_CIPMODE_0>:
     4bf:	41 54 2b 43 49 50 4d 4f 44 45 3d 30 00              AT+CIPMODE=0.

000004cc <AT_CIPMODE_1>:
     4cc:	41 54 2b 43 49 50 4d 4f 44 45 3d 31 00              AT+CIPMODE=1.

000004d9 <AT_CIPMUX_0>:
     4d9:	41 54 2b 43 49 50 4d 55 58 3d 30 00                 AT+CIPMUX=0.

000004e5 <AT_CIPMUX_1>:
     4e5:	41 54 2b 43 49 50 4d 55 58 3d 31 00                 AT+CIPMUX=1.

000004f1 <AT_CGATT>:
     4f1:	41 54 2b 43 47 41 54 54 3d 31 00                    AT+CGATT=1.

000004fc <AT_CIPCSGP>:
     4fc:	41 54 2b 43 49 50 43 53 47 50 3d 31 2c 22 00        AT+CIPCSGP=1,".

0000050b <AT_CSTT>:
     50b:	41 54 2b 43 53 54 54 00                             AT+CSTT.

00000513 <AT_CIICR>:
     513:	41 54 2b 43 49 49 43 52 00                          AT+CIICR.

0000051c <AT_CIFSR>:
     51c:	41 54 2b 43 49 46 53 52 00                          AT+CIFSR.

00000525 <AT_CIPTKA>:
     525:	41 54 2b 43 49 50 54 4b 41 3d 31 2c 33 30 2c 33     AT+CIPTKA=1,30,3
     535:	30 2c 31 00                                         0,1.

00000539 <AT_CIPSTART>:
     539:	41 54 2b 43 49 50 53 54 41 52 54 3d 22 55 44 50     AT+CIPSTART="UDP
     549:	22 2c 00                                            ",.

0000054c <AT_CIPSTART_TCP_CLIENT>:
     54c:	41 54 2b 43 49 50 53 54 41 52 54 3d 22 54 43 50     AT+CIPSTART="TCP
     55c:	22 2c 00                                            ",.

0000055f <AT_CIPSERVER>:
     55f:	41 54 2b 43 49 50 53 45 52 56 45 52 3d 31 2c 00     AT+CIPSERVER=1,.

0000056f <AT_SERVERCLOSE>:
     56f:	41 54 2b 43 49 50 53 45 52 56 45 52 3d 30 00        AT+CIPSERVER=0.

0000057e <AT_CIPSEND>:
     57e:	41 54 2b 43 49 50 53 45 4e 44 3d 00                 AT+CIPSEND=.

0000058a <AT_CIPCLOSE_1>:
     58a:	41 54 2b 43 49 50 43 4c 4f 53 45 3d 78 2c 31 00     AT+CIPCLOSE=x,1.

0000059a <AT_CIPCLOSE>:
     59a:	41 54 2b 43 49 50 43 4c 4f 53 45 3d 31 00           AT+CIPCLOSE=1.

000005a8 <AT_CIPSHUT>:
     5a8:	41 54 2b 43 49 50 53 48 55 54 00                    AT+CIPSHUT.

000005b3 <AT_CGATT_0>:
     5b3:	41 54 2b 43 47 41 54 54 3d 30 00                    AT+CGATT=0.

000005be <AT_CSQ>:
     5be:	41 54 2b 43 53 51 00                                AT+CSQ.

000005c5 <ATO>:
     5c5:	41 54 4f 00                                         ATO.

000005c9 <Symbols_P>:
     5c9:	30 31 32 33 34 35 36 37 38 39 61 62 63 64 65 66     0123456789abcdef
     5d9:	67 68 69 6a 6b 6c 6d 6e 6f 70 71 72 73 74 75 76     ghijklmnopqrstuv
     5e9:	77 78 79 7a 41 42 43 44 45 46 47 48 49 4a 4b 4c     wxyzABCDEFGHIJKL
     5f9:	4d 4e 4f 50 51 52 53 54 55 56 57 58 59 5a e0 e1     MNOPQRSTUVWXYZ..
     609:	e2 e3 e4 e5 b8 ba e6 e7 e8 b3 bf e9 ea eb ec ed     ................
     619:	ee ef f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 fa fb fc fd     ................
     629:	fe ff c0 c1 c2 c3 c4 c5 a8 aa c6 c7 c8 b2 af c9     ................
     639:	ca cb cc cd ce cf d0 d1 d2 d3 d4 d5 d6 d7 d8 d9     ................
     649:	da db dc dd de df 20 2b 2d 3d 3c 3e 24 25 26 2e     ...... +-=<>$%&.
     659:	2c 3f 21 27 40 3a 28 29 22 7c 2a 23 2f 00           ,?!'@:()"|*#/.

00000667 <OnlyDigits_P>:
     667:	30 31 32 33 34 35 36 37 38 39 00                    0123456789.

00000672 <Digits_P>:
     672:	30 31 32 33 34 35 36 37 38 39 65 2b 2d 2e 00        0123456789e+-..

00000681 <ThermFami>:
     681:	00 00 00 00 00 00                                   ......

00000687 <TermisLim>:
     687:	00 00 00 00 0c fe 08 07 0c fe 08 07 0c fe 70 17     ..............p.
     697:	0c fe 70 17 0c fe 70 17 0c fe 70 17 0c fe 08 07     ..p...p...p.....

000006a7 <TermocLim>:
     6a7:	00 00 00 00 30 f8 e0 2e 70 17 50 46 30 f8 4c 1d     ....0...p.PF0.L.
     6b7:	30 f8 70 17                                         0.p.

000006bb <Fail_Str>:
     6bb:	d1 e1 ee e9 20 00                                   .... .

000006c1 <Norm_Str>:
     6c1:	cd ee f0 ec e0 00                                   ......

000006c7 <DI_NO_Str>:
     6c7:	ed e5 f2 20 00                                      ... .

000006cc <DI_OK_Str>:
     6cc:	ed ee f0 ec 00                                      .....

000006d1 <DI_Sta_Tbl>:
     6d1:	c7 06 cc 06                                         ....

000006d5 <DI_Op_Str>:
     6d5:	f0 e0 e7 ec 00                                      .....

000006da <DI_Cl_Str>:
     6da:	e7 e0 ec ea 00                                      .....

000006df <DI_Tbl>:
     6df:	d5 06 da 06                                         ....

000006e3 <DI_Inv_Cl_Str>:
     6e3:	ed 2e e7 2e 00                                      .....

000006e8 <DI_Inv_Op_Str>:
     6e8:	ed 2e f0 2e 00                                      .....

000006ed <DI_Inv_Tbl>:
     6ed:	e3 06 e8 06                                         ....

000006f1 <DO_Op_Str>:
     6f1:	e2 fb ea eb 00                                      .....

000006f6 <DO_Cl_Str>:
     6f6:	e2 ea eb 20 00                                      ... .

000006fb <DO_Tbl>:
     6fb:	f1 06 f6 06                                         ....

000006ff <F_ADC_3>:
     6ff:	07 66 07 00 00 00                                   .f....

00000705 <F_ADC_4>:
     705:	07 d9 08 00 00 00                                   ......

0000070b <F_ADC_5>:
     70b:	07 ae 06 00 00 00                                   ......

00000711 <List_ADC_Err>:
     711:	20 2d 2d 2d 20 41 44 43 20 65 72 72 6f 72 73 20      --- ADC errors 
     721:	2d 2d 2d 20 00 00 00 00 00 00 00 20 52 65 61 64     --- ....... Read
     731:	20 66 61 69 6c 3a 20 20 20 20 7b 7b 7b 7b 7b 00      fail:    {{{{{.
     741:	ff 06 00 00 00 00 20 43 61 6c 69 62 72 20 66 61     ...... Calibr fa
     751:	69 6c 3a 20 20 7b 7b 7b 7b 7b 00 05 07 00 00 00     il:  {{{{{......
     761:	00 20 43 61 6c 69 62 72 20 62 72 65 61 6b 3a 20     . Calibr break: 
     771:	7b 7b 7b 7b 7b 00 0b 07 00 00 00 00                 {{{{{.......

0000077d <Menu_ADC_Err>:
     77d:	11 07 04 03 00 00 00 00 00 00 00 00 00 00 00 00     ................
     78d:	00 00 00 00                                         ....

00000791 <F_ADC_1>:
     791:	1d 18 0b 0b 24 00                                   ....$.

00000797 <F_ADC_2>:
     797:	00 aa 06 00 00 00 00 c0 08 00 00 00                 ............

000007a3 <List_ADC>:
     7a3:	20 d0 e5 e6 e8 ec 3a 20 7b 7b 7b 7b 7b 7b 7b 7b      .....: {{{{{{{{
     7b3:	7b 7b 7b 7b 00 91 07 00 00 00 00 20 c2 f0 e5 ec     {{{{....... ....
     7c3:	ff 3a 7b 7b 30 ec f1 20 ca e0 ed e0 eb 3a 7b 00     .:{{0.. .....:{.
     7d3:	97 07 00 00 00 00 20 2d 20 ca e0 ed e0 eb fb 20     ...... - ...... 
     7e3:	2d 20 20 20 20 20 20 20 20 20 00 00 00 00 00 2c     -         .....,
     7f3:	23 20 2d 20 ca e0 eb e8 e1 f0 ee e2 ea e0 20 2d     # - .......... -
     803:	20 20 20 20 20 00 00 00 00 00 d0 23 20 2d 20 ce          ......# - .
     813:	f8 e8 e1 ea e8 20 2d 20 20 20 20 20 20 20 20 20     ..... -         
     823:	00 00 00 00 00 7d 07                                .....}.

0000082a <MenuADC>:
     82a:	a3 07 05 02 00 00 00 00 00 00 00 00 00 00 00 00     ................
     83a:	00 00 00 00                                         ....

0000083e <MsgErr21>:
     83e:	20 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f      _______________
     84e:	5f 5f 5f 20 00 00 00 20 49 6e 74 65 72 6e 61 6c     ___ ... Internal
     85e:	20 65 72 72 6f 72 20 32 31 3a 20 00 00 00 20 20      error 21: ...  
     86e:	20 20 20 20 41 44 43 20 6f 66 66 20 20 20 20 20         ADC off     
     87e:	20 20 00 00 00 20 20 20 20 20 20 20 20 20 20 20       ...           
     88e:	20 20 20 20 20 20 20 20 20 00 00 00 00 00 00 00              .......
	...

000008a0 <Therm_Off_Str>:
     8a0:	20 20 20 78 20 20 20 00                                x   .

000008a8 <ADC_Off_Str>:
     8a8:	2d 2d 2d 2d 2d 2d 2d 00                             -------.

000008b0 <ThermTbl>:
     8b0:	a0 08 a8 08                                         ....

000008b4 <ThermOff_Str>:
     8b4:	ce f2 ea eb 2e 00                                   ......

000008ba <TSM100_Str>:
     8ba:	d2 d1 cc 31 30 30 00                                ...100.

000008c1 <TSM50_Str>:
     8c1:	d2 d1 cc 35 30 00                                   ...50.

000008c7 <TSP100_Str>:
     8c7:	d2 d1 cf 31 30 30 00                                ...100.

000008ce <TSP50_Str>:
     8ce:	d2 d1 cf 35 30 00                                   ...50.

000008d4 <Pt100_Str>:
     8d4:	50 74 31 30 30 00                                   Pt100.

000008da <Gr21_Str>:
     8da:	c3 f0 32 31 00                                      ..21.

000008df <Gr23_Str>:
     8df:	c3 f0 32 33 00                                      ..23.

000008e4 <RTD_Name_List>:
     8e4:	b4 08 ba 08 c1 08 c7 08 ce 08 d4 08 da 08 df 08     ................

000008f4 <TC_K_Str>:
     8f4:	54 58 41 00                                         TXA.

000008f8 <TC_B_Str>:
     8f8:	54 cf d0 00                                         T...

000008fc <TC_J_Str>:
     8fc:	54 c6 ca 00                                         T...

00000900 <TC_L_Str>:
     900:	54 58 ca 00                                         TX..

00000904 <TC_Name_List>:
     904:	b4 08 f4 08 f8 08 fc 08 00 09                       ..........

0000090e <NoPariStr>:
     90e:	ed e5 f2 00                                         ....

00000912 <EvenPariStr>:
     912:	f7 e5 f2 ed fb e9 00                                .......

00000919 <OddPariStr>:
     919:	ed e5 f7 e5 f2 ed fb e9 00                          .........

00000922 <MBPariTbl>:
     922:	0e 09 12 09 19 09                                   ......

00000928 <BR_Str1200>:
     928:	31 32 30 30 00                                      1200.

0000092d <BR_Str2400>:
     92d:	32 34 30 30 00                                      2400.

00000932 <BR_Str4800>:
     932:	34 38 30 30 00                                      4800.

00000937 <BR_Str9600>:
     937:	39 36 30 30 00                                      9600.

0000093c <BR_Str14400>:
     93c:	31 34 34 30 30 00                                   14400.

00000942 <BR_Str19200>:
     942:	31 39 32 30 30 00                                   19200.

00000948 <BR_Str28800>:
     948:	32 38 38 30 30 00                                   28800.

0000094e <BR_Str38400>:
     94e:	33 38 34 30 30 00                                   38400.

00000954 <BR_Str57600>:
     954:	35 37 36 30 30 00                                   57600.

0000095a <BaudTbl>:
     95a:	28 09 2d 09 32 09 37 09 3c 09 42 09 48 09 4e 09     (.-.2.7.<.B.H.N.
     96a:	54 09                                               T.

0000096c <F_MB0_Pari>:
     96c:	1e 04 00 00 00 00 00 02 00 00 00 cc 6b 22 09 00     ............k"..

0000097c <F_MB0_Stopbits>:
     97c:	01 05 00 01 00 00 00 02 00 00 00 cc 6b 00 00 00     ............k...

0000098c <F_MB0_Baud>:
     98c:	1e 06 00 00 00 00 00 08 00 00 00 55 6b 5a 09 00     ...........UkZ..

0000099c <MB0_CPT_04>:
     99c:	0b e4 08 00 00 00 0b ec 08 00 00 00                 ............

000009a8 <MB0_CPT_15>:
     9a8:	0b e6 08 00 00 00 0b ee 08 00 00 00                 ............

000009b4 <MB0_CPT_26>:
     9b4:	0b e8 08 00 00 00 0b f0 08 00 00 00                 ............

000009c0 <MB0_CPT_37>:
     9c0:	0b ea 08 00 00 00 0b f2 08 00 00 00                 ............

000009cc <List_MB0_CPT>:
     9cc:	43 50 31 3a 7b 7b 7b 7b 7b 20 20 43 50 35 3a 7b     CP1:{{{{{  CP5:{
     9dc:	7b 7b 7b 7b 00 9c 09 00 00 00 00 43 50 32 3a 7b     {{{{.......CP2:{
     9ec:	7b 7b 7b 7b 20 20 43 50 36 3a 7b 7b 7b 7b 7b 00     {{{{  CP6:{{{{{.
     9fc:	a8 09 00 00 00 00 43 50 33 3a 7b 7b 7b 7b 7b 20     ......CP3:{{{{{ 
     a0c:	20 43 50 37 3a 7b 7b 7b 7b 7b 00 b4 09 00 00 00      CP7:{{{{{......
     a1c:	00 43 50 34 3a 7b 7b 7b 7b 7b 20 20 43 50 38 3a     .CP4:{{{{{  CP8:
     a2c:	7b 7b 7b 7b 7b 00 c0 09 00 00 00 00                 {{{{{.......

00000a38 <M_MB0_CPT>:
     a38:	cc 09 04 03 00 00 00 00 00 00 00 00 1b 3f 00 00     .............?..
     a48:	00 00 00 00                                         ....

00000a4c <L_MB0>:
     a4c:	20 2d 2d 2d 2d 20 4d 6f 64 62 75 73 20 30 20 2d      ---- Modbus 0 -
     a5c:	2d 2d 2d 20 00 00 00 00 00 00 00 20 d1 f7 e5 f2     --- ....... ....
     a6c:	f7 e8 ea e8 20 28 f1 e1 f0 ee f1 3a 2d 3e 29 00     .... (.....:->).
     a7c:	00 00 00 00 38 0a 20 cf e0 f0 e8 f2 e5 f2 3a 20     ....8. .......: 
     a8c:	7d 7d 7d 7d 7d 7d 7d 7d 20 20 00 00 00 6c 09 00     }}}}}}}}  ...l..
     a9c:	00 20 d1 f2 ee ef 2d e1 e8 f2 fb 3a 20 7d 20 20     . ....-....: }  
     aac:	20 20 20 20 20 00 00 00 7c 09 00 00 20 42 41 55          ...|... BAU
     abc:	44 3a 20 7d 7d 7d 7d 7d 62 70 73 20 20 20 20 20     D: }}}}}bps     
     acc:	00 00 00 8c 09 00 00                                .......

00000ad3 <MenuModbus0>:
     ad3:	4c 0a 05 01 00 00 00 00 00 00 00 00 00 00 00 00     L...............
     ae3:	00 00 00 00                                         ....

00000ae7 <List_Modbus>:
     ae7:	20 4d 6f 64 62 75 73 20 30 20 20 20 20 20 20 20      Modbus 0       
     af7:	20 20 20 20 00 00 00 00 00 d3 0a 20 20 20 20 58         .......    X
     b07:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 00                    .
     b17:	00 00 00 00 00 00 20 20 20 20 58 20 20 20 20 20     ......    X     
     b27:	20 20 20 20 20 20 20 20 20 20 00 00 00 00 00 00               ......
     b37:	00 20 20 20 20 58 20 20 20 20 20 20 20 20 20 20     .    X          
     b47:	20 20 20 20 20 00 00 00 00 00 00 00                      .......

00000b53 <MenuModbus>:
     b53:	e7 0a 04 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     b63:	00 00 00 00                                         ....

00000b67 <N_Str>:
     b67:	cd e5 f2 00                                         ....

00000b6b <Y_Str>:
     b6b:	c4 e0 00                                            ...

00000b6e <YN_Tbl>:
     b6e:	67 0b 6b 0b                                         g.k.

00000b72 <F_SummerTime>:
     b72:	1e 03 00 00 00 00 00 01 00 00 00 00 00 6e 0b 00     .............n..

00000b82 <F_WDay>:
     b82:	00 4e 06 00 00 00                                   .N....

00000b88 <F_DateTime>:
     b88:	04 0d 0b 01 00 00 00 1f 00 00 00 ff 22 00 00 00     ............"...
     b98:	04 7b 07 01 00 00 00 0c 00 00 00 09 23 00 00 00     .{..........#...
     ba8:	04 d5 05 00 00 00 00 63 00 00 00 13 23 00 00 00     .......c....#...
     bb8:	04 b8 05 00 00 00 00 17 00 00 00 f5 22 00 00 00     ............"...
     bc8:	04 48 06 00 00 00 00 3b 00 00 00 eb 22 00 00 00     .H.....;...."...
     bd8:	04 ad 06 00 00 00 00 3b 00 00 00 e1 22 00 00 00     .......;...."...

00000be8 <GSM_CNTL_AUTO_Str>:
     be8:	61 75 74 6f 20 20 00                                auto  .

00000bef <GSM_CNTL_MANUAL_Str>:
     bef:	6d 61 6e 75 61 6c 00                                manual.

00000bf6 <GSM_CNTL_CONFIG_Str>:
     bf6:	63 6f 6e 66 69 67 00                                config.

00000bfd <GSM_ControlList>:
     bfd:	e8 0b ef 0b f6 0b                                   ......

00000c03 <GSM_Not_Recognize_Str>:
     c03:	6e 6f 74 20 72 65 63 6f 67 00                       not recog.

00000c0d <GSM_SIMCOM_SIM900R_Str>:
     c0d:	53 49 4d 39 30 30 52 20 20 00                       SIM900R  .

00000c17 <GSM_SIMCOM_SIM800_Str>:
     c17:	53 49 4d 38 30 30 20 20 20 00                       SIM800   .

00000c21 <GSM_ModemList>:
     c21:	03 0c 0d 0c 17 0c                                   ......

00000c27 <MenuGSM_Modem_State>:
     c27:	1d ea 06 21 0c 00 00 ac 06 00 00 00                 ...!........

00000c33 <MenuGSM_State>:
     c33:	00 ac 06 00 00 00                                   ......

00000c39 <MenuGSM_GSM_Cont>:
     c39:	1d 80 07 00 00 00 00 02 00 00 00 2a 3f fd 0b 00     ...........*?...

00000c49 <MenuGSM_GSM_MyIP>:
     c49:	00 df 08 00 00 00 00 e0 08 00 00 00 00 e1 08 00     ................
     c59:	00 00 00 e2 08 00 00 00                             ........

00000c61 <MenuGSM_ClientIP>:
     c61:	00 f8 0a 00 00 00 00 f9 0a 00 00 00 00 fa 0a 00     ................
     c71:	00 00 00 fb 0a 00 00 00                             ........

00000c79 <MenuGSM_ActiveCon>:
     c79:	00 d0 02 00 00 00                                   ......

00000c7f <MenuGSM_FIFOMax>:
     c7f:	00 c7 08 00 00 00                                   ......

00000c85 <MenuGSM_APN1>:
     c85:	22 09 00 00 00 00 00 06 00 00 00 00 00 00 00 00     "...............

00000c95 <MenuGSM_APN2>:
     c95:	22 1d 00 00 00 00 00 06 00 00 00 00 00 00 00 00     "...............

00000ca5 <MenuGSM_APN_USER_NAME>:
     ca5:	22 59 00 00 00 00 00 06 00 00 00 00 00 00 00 00     "Y..............

00000cb5 <MenuGSM_APN_PASSWORD>:
     cb5:	22 6d 00 00 00 00 00 06 00 00 00 00 00 00 00 00     "m..............

00000cc5 <MenuGSM_IPUDP1>:
     cc5:	01 81 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     cd5:	01 82 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     ce5:	01 83 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     cf5:	01 84 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00000d05 <MenuGSM_IPUDP2>:
     d05:	01 85 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     d15:	01 86 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     d25:	01 87 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     d35:	01 88 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00000d45 <MenuGSM_IPUDP3>:
     d45:	01 89 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     d55:	01 8a 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     d65:	01 8b 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     d75:	01 8c 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00000d85 <MenuGSM_IPUDP4>:
     d85:	01 8d 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     d95:	01 8e 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     da5:	01 8f 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     db5:	01 90 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00000dc5 <MenuGSM_PortUDP1>:
     dc5:	08 a1 00 00 00 00 00 ff ff 00 00 00 00 00 00 00     ................

00000dd5 <MenuGSM_PortUDP2>:
     dd5:	08 a3 00 00 00 00 00 ff ff 00 00 00 00 00 00 00     ................

00000de5 <MenuGSM_PortUDP3>:
     de5:	08 a5 00 00 00 00 00 ff ff 00 00 00 00 00 00 00     ................

00000df5 <MenuGSM_PortUDP4>:
     df5:	08 a7 00 00 00 00 00 ff ff 00 00 00 00 00 00 00     ................

00000e05 <MenuGSM_IPTCP1>:
     e05:	01 b3 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     e15:	01 b4 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     e25:	01 b5 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     e35:	01 b6 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00000e45 <MenuGSM_IPTCP2>:
     e45:	01 b7 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     e55:	01 b8 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     e65:	01 b9 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     e75:	01 ba 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00000e85 <MenuGSM_IPTCP3>:
     e85:	01 bb 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     e95:	01 bc 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     ea5:	01 bd 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     eb5:	01 be 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00000ec5 <MenuGSM_IPTCP4>:
     ec5:	01 bf 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     ed5:	01 c0 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     ee5:	01 c1 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     ef5:	01 c2 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00000f05 <MenuGSM_TCPPort>:
     f05:	08 b1 00 00 00 00 00 ff ff 00 00 00 00 00 00 00     ................

00000f15 <MenuGSM_TCPTimeout>:
     f15:	08 c3 00 64 00 00 00 ff ff 00 00 00 00 00 00 02     ...d............

00000f25 <MenuGSM_SMS>:
     f25:	01 13 01 00 00 00 00 01 00 00 00 00 00 00 00 00     ................

00000f35 <MenuGSM_VegaSN>:
     f35:	08 07 00 00 00 00 00 ff ff 00 00 00 00 00 00 00     ................

00000f45 <ListGSM>:
     f45:	20 cc ee e4 e5 ec 20 7b 7b 7b 7b 7b 7b 7b 7b 7b      ..... {{{{{{{{{
     f55:	20 7b 7b 7b 00 27 0c 00 00 00 00 20 43 6f 6e 74      {{{.'..... Cont
     f65:	72 6f 6c 20 6d 6f 64 65 3a 7d 7d 7d 7d 7d 7d 00     rol mode:}}}}}}.
     f75:	00 00 39 0c 00 00 20 4d 79 49 50 7b 7b 7b 2e 7b     ..9... MyIP{{{.{
     f85:	7b 7b 2e 7b 7b 7b 2e 7b 7b 7b 00 49 0c 00 00 00     {{.{{{.{{{.I....
     f95:	00 20 43 6c 49 50 7b 7b 7b 2e 7b 7b 7b 2e 7b 7b     . ClIP{{{.{{{.{{
     fa5:	7b 2e 7b 7b 7b 00 61 0c 00 00 00 00 20 41 63 74     {.{{{.a..... Act
     fb5:	69 76 65 20 63 6f 6e 65 63 74 69 6f 6e 7b 7b 7b     ive conection{{{
     fc5:	00 79 0c 00 00 00 00 20 46 49 46 4f 3a 6d 61 78     .y..... FIFO:max
     fd5:	20 7b 7b 2f 37 30 62 79 74 65 20 00 7f 0c 00 00      {{/70byte .....
     fe5:	00 00 20 2d 2d 2d 2d 2d 2d 2d 41 50 4e 2d 2d 2d     .. -------APN---
     ff5:	2d 2d 2d 2d 2d 2d 00 00 00 00 00 00 00 20 7d 7d     ------....... }}
    1005:	7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d     }}}}}}}}}}}}}}}}
    1015:	7d 00 00 00 85 0c 00 00 20 7d 7d 7d 7d 7d 7d 7d     }....... }}}}}}}
    1025:	7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 00 00 00 95     }}}}}}}}}}}}....
    1035:	0c 00 00 20 2d 2d 2d 41 50 4e 2d 55 53 45 52 20     ... ---APN-USER 
    1045:	4e 41 4d 45 2d 2d 2d 00 00 00 00 00 00 00 20 7d     NAME---....... }
    1055:	7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d     }}}}}}}}}}}}}}}}
    1065:	7d 7d 00 00 00 a5 0c 00 00 20 2d 2d 2d 41 50 4e     }}....... ---APN
    1075:	2d 50 41 53 53 57 4f 52 44 2d 2d 2d 2d 00 00 00     -PASSWORD----...
    1085:	00 00 00 00 20 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d     .... }}}}}}}}}}}
    1095:	7d 7d 7d 7d 7d 7d 7d 7d 00 00 00 b5 0c 00 00 20     }}}}}}}}....... 
    10a5:	2d 2d 53 65 6e 64 20 55 44 50 20 74 6f 20 49 50     --Send UDP to IP
    10b5:	2d 2d 2d 00 00 00 00 00 00 00 20 49 50 31 3a 7d     ---....... IP1:}
    10c5:	7d 7d 2e 7d 7d 7d 2e 7d 7d 7d 2e 7d 7d 7d 00 00     }}.}}}.}}}.}}}..
    10d5:	00 c5 0c 00 00 20 49 50 32 3a 7d 7d 7d 2e 7d 7d     ..... IP2:}}}.}}
    10e5:	7d 2e 7d 7d 7d 2e 7d 7d 7d 00 00 00 05 0d 00 00     }.}}}.}}}.......
    10f5:	20 49 50 33 3a 7d 7d 7d 2e 7d 7d 7d 2e 7d 7d 7d      IP3:}}}.}}}.}}}
    1105:	2e 7d 7d 7d 00 00 00 45 0d 00 00 20 49 50 34 3a     .}}}...E... IP4:
    1115:	7d 7d 7d 2e 7d 7d 7d 2e 7d 7d 7d 2e 7d 7d 7d 00     }}}.}}}.}}}.}}}.
    1125:	00 00 85 0d 00 00 20 2d 2d 2d 2d 20 55 44 50 20     ...... ---- UDP 
    1135:	50 6f 72 74 20 2d 2d 2d 2d 2d 00 00 00 00 00 00     Port -----......
    1145:	00 20 49 50 31 20 50 6f 72 74 3a 7d 7d 7d 7d 7d     . IP1 Port:}}}}}
    1155:	20 20 20 20 20 00 00 00 c5 0d 00 00 20 49 50 32          ....... IP2
    1165:	20 50 6f 72 74 3a 7d 7d 7d 7d 7d 20 20 20 20 20      Port:}}}}}     
    1175:	00 00 00 d5 0d 00 00 20 49 50 33 20 50 6f 72 74     ....... IP3 Port
    1185:	3a 7d 7d 7d 7d 7d 20 20 20 20 20 00 00 00 e5 0d     :}}}}}     .....
    1195:	00 00 20 49 50 34 20 50 6f 72 74 3a 7d 7d 7d 7d     .. IP4 Port:}}}}
    11a5:	7d 20 20 20 20 20 00 00 00 f5 0d 00 00 20 2d 20     }     ....... - 
    11b5:	54 43 50 20 49 50 20 46 69 72 65 77 61 6c 6c 2d     TCP IP Firewall-
    11c5:	2d 00 00 00 00 00 00 00 20 49 50 31 3a 7d 7d 7d     -....... IP1:}}}
    11d5:	2e 7d 7d 7d 2e 7d 7d 7d 2e 7d 7d 7d 00 00 00 05     .}}}.}}}.}}}....
    11e5:	0e 00 00 20 49 50 32 3a 7d 7d 7d 2e 7d 7d 7d 2e     ... IP2:}}}.}}}.
    11f5:	7d 7d 7d 2e 7d 7d 7d 00 00 00 45 0e 00 00 20 49     }}}.}}}...E... I
    1205:	50 33 3a 7d 7d 7d 2e 7d 7d 7d 2e 7d 7d 7d 2e 7d     P3:}}}.}}}.}}}.}
    1215:	7d 7d 00 00 00 85 0e 00 00 20 49 50 34 3a 7d 7d     }}....... IP4:}}
    1225:	7d 2e 7d 7d 7d 2e 7d 7d 7d 2e 7d 7d 7d 00 00 00     }.}}}.}}}.}}}...
    1235:	c5 0e 00 00 20 54 43 50 53 65 72 76 65 72 50 6f     .... TCPServerPo
    1245:	72 74 3a 7d 7d 7d 7d 7d 00 00 00 05 0f 00 00 20     rt:}}}}}....... 
    1255:	54 69 6d 65 6f 75 74 20 54 43 50 3a 7d 7d 7d 7d     Timeout TCP:}}}}
    1265:	7d 7d 63 00 00 00 15 0f 00 00 20 2d 2d 2d 2d 2d     }}c....... -----
    1275:	2d 2d 20 53 4d 53 20 2d 2d 2d 2d 2d 2d 2d 00 00     -- SMS -------..
    1285:	00 00 00 00 00 20 d0 e0 f1 f1 fb eb ea e0 20 53     ..... ........ S
    1295:	4d 53 3a 20 20 20 7d 7d 7d 00 00 00 25 0f 00 00     MS:   }}}...%...
    12a5:	20 2d 2d 49 64 65 6e 74 69 66 69 63 61 74 69 6f      --Identificatio
    12b5:	6e 2d 2d 2d 00 00 00 00 00 00 00 20 56 65 67 61     n---....... Vega
    12c5:	20 53 2f 4e 3a 20 20 20 20 20 7d 7d 7d 7d 7d 00      S/N:     }}}}}.
    12d5:	00 00 35 0f 00 00                                   ..5...

000012db <MenuGSM>:
    12db:	45 0f 22 00 00 00 00 00 00 00 00 00 00 00 00 00     E.".............
    12eb:	00 00 00 00                                         ....

000012ef <Mem_OK_Tbl>:
    12ef:	c1 06 bb 06                                         ....

000012f3 <F_Ok_Flash>:
    12f3:	1f c5 08 ef 12 00                                   ......

000012f9 <F_Ok_EEPROM>:
    12f9:	1f c5 08 ef 12 01                                   ......

000012ff <Msg_EEWarning>:
    12ff:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    130f:	20 20 20 20 00 00 00 20 cf e5 f0 e5 e4 20 ef f0         ... ..... ..
    131f:	ee e4 ee eb e6 e5 ed e8 e5 ec 20 00 00 00 f0 e0     .......... .....
    132f:	e1 ee f2 fb 20 ef f0 ee e2 e5 f0 fc f2 e5 20 e2     .... ......... .
    133f:	f1 e5 00 00 00 20 20 20 20 20 20 ed e0 f1 f2 f0     .....      .....
    134f:	ee e9 ea e8 20 20 20 20 20 00 00 00 00 00 00 00     ....     .......
	...

00001361 <Msg_NoBackUp>:
    1361:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    1371:	20 20 20 20 00 00 00 d1 ee f5 f0 e0 ed b8 ed ed         ............
    1381:	fb f5 20 ed e0 f1 f2 f0 ee e5 ea 00 00 00 20 20     .. ...........  
    1391:	20 20 ed e5 20 ee e1 ed e0 f0 f3 e6 e5 ed ee 20       .. .......... 
    13a1:	20 20 00 00 00 20 20 20 20 20 20 20 20 20 20 20       ...           
    13b1:	20 20 20 20 20 20 20 20 20 00 00 00 00 00 00 00              .......
	...

000013c3 <Menu_ConfirmationSave_List>:
    13c3:	d1 ee f5 f0 e0 ed e8 f2 fc 20 ed e0 f1 f2 f0 ee     ......... ......
    13d3:	e9 ea e8 3f 00 00 00 00 00 00 00 20 20 20 c4 e0     ...?.......   ..
    13e3:	20 2d 20 ea ed ee ef ea e0 20 c2 d5 ce c4 20 00      - ...... .... .
    13f3:	00 00 00 00 00 00 20 20 cd e5 f2 20 2d 20 ea ed     ......  ... - ..
    1403:	ee ef ea e0 20 c2 db d5 ce c4 00 00 00 00 00 00     .... ...........
    1413:	00 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20     .               
    1423:	20 20 20 20 20 00 00 00 00 00 00 00                      .......

0000142f <Menu_ConfirmationSave>:
    142f:	c3 13 04 03 00 00 00 00 00 00 00 00 45 3f 00 00     ............E?..
    143f:	00 00 00 00                                         ....

00001443 <Menu_ConfirmationRest_List>:
    1443:	c2 ee f1 f2 e0 ed ee e2 2e 20 ed e0 f1 f2 f0 ee     ......... ......
    1453:	e9 ea e8 3f 00 00 00 00 00 00 00 20 20 20 c4 e0     ...?.......   ..
    1463:	20 2d 20 ea ed ee ef ea e0 20 c2 d5 ce c4 20 00      - ...... .... .
    1473:	00 00 00 00 00 00 20 20 cd e5 f2 20 2d 20 ea ed     ......  ... - ..
    1483:	ee ef ea e0 20 c2 db d5 ce c4 00 00 00 00 00 00     .... ...........
    1493:	00 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20     .               
    14a3:	20 20 20 20 20 00 00 00 00 00 00 00                      .......

000014af <Menu_ConfirmationRestore>:
    14af:	43 14 04 03 00 00 00 00 00 00 00 00 3a 3f 00 00     C...........:?..
    14bf:	00 00 00 00                                         ....

000014c3 <NoBackUp_Str>:
    14c3:	2d 2d 00                                            --.

000014c6 <BackUp_Tbl>:
    14c6:	c3 14                                               ..

000014c8 <Menu_BackUp_IField>:
    14c8:	05 00 00 c6 14 00 05 01 00 c6 14 00 05 02 00 c6     ................
    14d8:	14 00                                               ..

000014da <Menu_BackUp_List>:
    14da:	d3 f1 f2 ed 2f d0 e5 e7 e5 f0 e2 ed e0 ff 20 ea     ..../......... .
    14ea:	ee ef e8 ff 00 00 00 00 00 00 00 20 d1 ee f5 f0     ........... ....
    14fa:	e0 ed e8 f2 fc 20 20 20 20 20 20 20 20 20 20 00     .....          .
    150a:	00 00 00 00 2f 14 20 c2 ee f1 f2 e0 ed ee e2 3a     ..../. ........:
    151a:	7b 7b 2e 7b 7b 2e 32 30 7b 7b 00 c8 14 00 00 00     {{.{{.20{{......
    152a:	00 20 d1 ee f1 f2 2e 45 45 50 52 4f 4d 3a 20 7b     . .....EEPROM: {
    153a:	7b 7b 7b 7b 20 00 f9 12 00 00 00 00                 {{{{ .......

00001546 <Menu_BackUp>:
    1546:	da 14 04 01 00 00 00 00 00 00 00 00 da 6f 00 00     .............o..
    1556:	00 00 00 00                                         ....

0000155a <ListMem>:
    155a:	20 2d 2d 2d 2d 2d 20 4d 65 6d 6f 72 79 20 2d 2d      ----- Memory --
    156a:	2d 2d 2d 20 00 00 00 00 00 00 00 20 46 6c 61 73     --- ....... Flas
    157a:	68 3a 20 20 7b 7b 7b 7b 7b 20 20 20 20 20 20 00     h:  {{{{{      .
    158a:	f3 12 00 00 00 00 20 45 45 50 52 4f 4d 3a 20 7b     ...... EEPROM: {
    159a:	7b 7b 7b 7b 20 20 20 20 20 20 00 f9 12 00 00 00     {{{{      ......
    15aa:	00 20 52 65 73 65 74 20 45 45 50 52 4f 4d 20 66     . Reset EEPROM f
    15ba:	61 69 6c 20 20 00 00 00 00 00 00 00 20 42 61 63     ail  ....... Bac
    15ca:	6b 55 70 20 45 45 50 52 4f 4d 20 20 20 20 20 20     kUp EEPROM      
    15da:	00 00 00 00 00 46 15                                .....F.

000015e1 <MenuMem>:
    15e1:	5a 15 05 01 00 00 00 00 00 00 00 00 c0 4a 00 00     Z............J..
    15f1:	00 00 00 00                                         ....

000015f5 <MsgErr11>:
    15f5:	20 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f      _______________
    1605:	5f 5f 5f 20 00 00 00 20 49 6e 74 65 72 6e 61 6c     ___ ... Internal
    1615:	20 65 72 72 6f 72 20 31 31 3a 20 00 00 00 20 20      error 11: ...  
    1625:	20 20 20 46 6c 61 73 68 20 66 61 69 6c 20 20 20        Flash fail   
    1635:	20 20 00 00 00 20 20 20 20 20 20 20 20 20 20 20       ...           
    1645:	20 20 20 20 20 20 20 20 20 00 00 00 00 00 00 00              .......
	...

00001657 <MsgErr12>:
    1657:	20 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f      _______________
    1667:	5f 5f 5f 20 00 00 00 20 49 6e 74 65 72 6e 61 6c     ___ ... Internal
    1677:	20 65 72 72 6f 72 20 31 32 3a 20 00 00 00 20 20      error 12: ...  
    1687:	20 20 45 45 50 52 4f 4d 20 66 61 69 6c 20 20 20       EEPROM fail   
    1697:	20 20 00 00 00 20 20 20 20 20 20 20 20 20 20 20       ...           
    16a7:	20 20 20 20 20 20 20 20 20 00 00 00 00 00 00 00              .......
	...

000016b9 <MsgErr13>:
    16b9:	20 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f      _______________
    16c9:	5f 5f 5f 20 00 00 00 20 49 6e 74 65 72 6e 61 6c     ___ ... Internal
    16d9:	20 65 72 72 6f 72 20 31 33 3a 20 00 00 00 20 54      error 13: ... T
    16e9:	6f 74 61 6c 20 6d 65 6d 6f 72 79 20 66 61 69 6c     otal memory fail
    16f9:	20 20 00 00 00 20 20 20 20 20 20 20 20 20 20 20       ...           
    1709:	20 20 20 20 20 20 20 20 20 00 00 00 00 00 00 00              .......
	...

0000171b <MsgErrMemo>:
    171b:	00 00 f5 15 57 16 b9 16                             ....W...

00001723 <F_ScanCycle>:
    1723:	00 60 07 00 00 00                                   .`....

00001729 <F_ScanCyclePerSec>:
    1729:	07 7d 07 00 00 00                                   .}....

0000172f <F_MaxScanCycle>:
    172f:	00 a8 06 00 00 00                                   ......

00001735 <ListScanCycle>:
    1735:	20 2d 2d 2d 20 53 63 61 6e 20 43 79 63 6c 65 20      --- Scan Cycle 
    1745:	2d 2d 2d 20 00 00 00 00 00 00 00 20 53 63 61 6e     --- ....... Scan
    1755:	43 79 63 6c 65 3a 20 20 20 7b 7b 7b 30 6d 73 00     Cycle:   {{{0ms.
    1765:	23 17 00 00 00 00 20 53 63 61 6e 43 79 63 6c 50     #..... ScanCyclP
    1775:	65 72 53 65 63 3a 7b 7b 7b 7b 00 29 17 00 00 00     erSec:{{{{.)....
    1785:	00 20 4d 61 78 53 63 61 6e 43 79 63 6c 65 3a 7b     . MaxScanCycle:{
    1795:	7b 7b 30 6d 73 00 2f 17 00 00 00 00                 {{0ms./.....

000017a1 <MenuScanCycle>:
    17a1:	35 17 04 01 00 00 00 00 00 00 00 00 2e 3f 00 00     5............?..
    17b1:	00 00 00 00                                         ....

000017b5 <F_WT>:
    17b5:	0b 19 0c 00 00 00 04 a7 06 00 00 00                 ............

000017c1 <sec10_Str>:
    17c1:	31 30 20 f1 e5 ea 00                                10 ....

000017c8 <sec30_Str>:
    17c8:	33 30 20 f1 e5 ea 00                                30 ....

000017cf <min1_Str>:
    17cf:	31 20 ec e8 ed 20 00                                1 ... .

000017d6 <min3_Str>:
    17d6:	33 20 ec e8 ed 20 00                                3 ... .

000017dd <min10_Str>:
    17dd:	31 30 20 ec e8 ed 00                                10 ....

000017e4 <BCKLT_Tbl>:
    17e4:	c1 17 c8 17 cf 17 d6 17 dd 17                       ..........

000017ee <F_Backlight>:
    17ee:	1e 31 01 00 00 00 00 04 00 00 00 00 00 e4 17 00     .1..............

000017fe <F_IonT>:
    17fe:	08 2f 01 00 00 00 00 ff 03 00 00 00 00 00 00 00     ./..............

0000180e <F_Menu_EMICounter>:
    180e:	10 ec 06 00 00 00                                   ......

00001814 <ListSyst>:
    1814:	20 2d 20 d1 eb f3 e6 e5 e1 ed ee e5 20 ec e5 ed      - ......... ...
    1824:	fe 20 2d 20 00 00 00 00 00 00 00 20 c4 e8 f1 ea     . - ....... ....
    1834:	f0 e5 f2 ed fb e5 20 e2 f5 ee e4 fb 20 20 20 00     ...... .....   .
    1844:	00 00 00 00 33 1e 20 c4 e8 f1 ea f0 e5 f2 ed fb     ....3. .........
    1854:	e5 20 e2 fb f5 ee e4 fb 20 20 00 00 00 00 00 f7     . ......  ......
    1864:	20 20 c0 ed e0 eb ee e3 ee e2 fb e5 20 e2 f5 ee       .......... ...
    1874:	e4 fb 20 20 20 00 00 00 00 00 a7 21 20 c0 ed e0     ..   ......! ...
    1884:	eb ee e3 ee e2 fb e5 20 e2 fb f5 ee e4 fb 20 20     ....... ......  
    1894:	00 00 00 00 00 67 22 20 c0 d6 cf 20 20 20 20 20     .....g" ...     
    18a4:	20 20 20 20 20 20 20 20 20 20 20 00 00 00 00 00                .....
    18b4:	2a 08 20 d2 e5 f0 ec ee e4 e0 f2 f7 e8 ea e8 20     *. ............ 
    18c4:	20 20 20 20 20 20 00 00 00 00 00 fb 28 20 4d 6f           ......( Mo
    18d4:	64 62 75 73 20 20 20 20 20 20 20 20 20 20 20 20     dbus            
    18e4:	20 00 00 00 00 00 53 0b 20 cc ee e4 e5 ec 20 20      .....S. .....  
    18f4:	20 20 20 20 20 20 20 20 20 20 20 20 00 00 00 00                 ....
    1904:	00 db 12 20 7b 20 7d 7d 2e 7d 7d 2e 7d 7d 20 7d     ... { }}.}}.}} }
    1914:	7d 3a 7d 7d 3a 7d 7d 00 82 0b 88 0b 00 00 20 c0     }:}}:}}....... .
    1924:	e2 f2 ee cf e5 f0 e5 f5 cb e5 f2 ed c2 f0 3a 7d     ..............:}
    1934:	7d 7d 00 00 00 72 0b 00 00 20 cd e0 f0 e0 e1 ee     }}...r... ......
    1944:	f2 ea e0 3a 7b 7b 7b 7b 7b f7 7b 7b ec 00 b5 17     ...:{{{{{.{{....
    1954:	00 00 00 00 20 d1 ee f1 f2 ee ff ed e8 e5 20 ef     .... ......... .
    1964:	e0 ec ff f2 e8 20 20 20 00 00 00 00 00 e1 15 20     .....   ....... 
    1974:	53 63 61 6e 20 43 79 63 6c 65 3a 20 20 7b 7b 7b     Scan Cycle:  {{{
    1984:	30 6d 73 00 23 17 00 00 a1 17 20 cf ee f0 ee e3     0ms.#..... .....
    1994:	20 e8 ee ed ee e4 2e 3a 20 20 7d 7d 7d 7d 00 00      ......:  }}}}..
    19a4:	00 fe 17 00 00 20 cf ee e4 f1 e2 e5 f2 ea e0 c6     ..... ..........
    19b4:	ca c8 3a 7d 7d 7d 7d 7d 7d 00 00 00 ee 17 00 00     ..:}}}}}}.......
    19c4:	20 d1 f7 b8 f2 2e dd cc cd 3a 7b 7b 7b 7b 7b 7b      ........:{{{{{{
    19d4:	7b 7b 7b 7b 00 0e 18 00 00 00 00                    {{{{.......

000019df <MenuSyst>:
    19df:	14 18 11 01 00 00 00 00 00 00 00 00 00 00 00 00     ................
    19ef:	00 00 00 00                                         ....

000019f3 <MsgErr41>:
    19f3:	20 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f      _______________
    1a03:	5f 5f 5f 20 00 00 00 20 49 6e 74 65 72 6e 61 6c     ___ ... Internal
    1a13:	20 65 72 72 6f 72 20 34 31 3a 20 00 00 00 54 69      error 41: ...Ti
    1a23:	6d 65 72 20 61 6c 6c 6f 63 61 74 69 6f 6e 20 65     mer allocation e
    1a33:	72 72 00 00 00 20 20 20 20 20 20 20 20 20 20 20     rr...           
    1a43:	20 20 20 20 20 20 20 20 20 00 00 00 00 00 00 00              .......
	...

00001a55 <F_DI1>:
    1a55:	1f f2 06 df 06 00 1f f8 06 d1 06 00                 ............

00001a61 <F_DI2>:
    1a61:	1f f2 06 df 06 01 1f f8 06 d1 06 01                 ............

00001a6d <F_DI3>:
    1a6d:	1f f2 06 df 06 02 1f f8 06 d1 06 02                 ............

00001a79 <F_DI4>:
    1a79:	1f f2 06 df 06 03 1f f8 06 d1 06 03                 ............

00001a85 <F_DI5>:
    1a85:	1f f2 06 df 06 04 1f f8 06 d1 06 04                 ............

00001a91 <F_DI6>:
    1a91:	1f f2 06 df 06 05 1f f8 06 d1 06 05                 ............

00001a9d <F_DI7>:
    1a9d:	1f f2 06 df 06 06 1f f8 06 d1 06 06                 ............

00001aa9 <F_DI8>:
    1aa9:	1f f2 06 df 06 07 1f f8 06 d1 06 07                 ............

00001ab5 <F_DI9>:
    1ab5:	1f f2 06 df 06 08 1f f8 06 d1 06 08                 ............

00001ac1 <F_DI10>:
    1ac1:	1f f2 06 df 06 09 1f f8 06 d1 06 09                 ............

00001acd <F_DI11>:
    1acd:	1f f2 06 df 06 0a 1f f8 06 d1 06 0a                 ............

00001ad9 <F_DI12>:
    1ad9:	1f f2 06 df 06 0b 1f f8 06 d1 06 0b                 ............

00001ae5 <F_DI13>:
    1ae5:	1f f2 06 df 06 0c 1f f8 06 d1 06 0c                 ............

00001af1 <F_DI14>:
    1af1:	1f f2 06 df 06 0d 1f f8 06 d1 06 0d                 ............

00001afd <F_DI15>:
    1afd:	1f f2 06 df 06 0e 1f f8 06 d1 06 0e                 ............

00001b09 <F_DI16>:
    1b09:	1f f2 06 df 06 0f 1f f8 06 d1 06 0f                 ............

00001b15 <F_DI17>:
    1b15:	1f f2 06 df 06 10 1f f8 06 d1 06 10                 ............

00001b21 <F_DI18>:
    1b21:	1f f2 06 df 06 11 1f f8 06 d1 06 11                 ............

00001b2d <F_DII1>:
    1b2d:	20 14 01 00 00 00 00 00 00 00 00 00 00 ed 06 00      ...............

00001b3d <F_DII2>:
    1b3d:	20 14 01 00 00 00 00 00 00 00 00 00 00 ed 06 01      ...............

00001b4d <F_DII3>:
    1b4d:	20 14 01 00 00 00 00 00 00 00 00 00 00 ed 06 02      ...............

00001b5d <F_DII4>:
    1b5d:	20 14 01 00 00 00 00 00 00 00 00 00 00 ed 06 03      ...............

00001b6d <F_DII5>:
    1b6d:	20 14 01 00 00 00 00 00 00 00 00 00 00 ed 06 04      ...............

00001b7d <F_DII6>:
    1b7d:	20 14 01 00 00 00 00 00 00 00 00 00 00 ed 06 05      ...............

00001b8d <F_DII7>:
    1b8d:	20 14 01 00 00 00 00 00 00 00 00 00 00 ed 06 06      ...............

00001b9d <F_DII8>:
    1b9d:	20 14 01 00 00 00 00 00 00 00 00 00 00 ed 06 07      ...............

00001bad <F_DII9>:
    1bad:	20 14 01 00 00 00 00 00 00 00 00 00 00 ed 06 08      ...............

00001bbd <F_DII10>:
    1bbd:	20 14 01 00 00 00 00 00 00 00 00 00 00 ed 06 09      ...............

00001bcd <F_DII11>:
    1bcd:	20 14 01 00 00 00 00 00 00 00 00 00 00 ed 06 0a      ...............

00001bdd <F_DII12>:
    1bdd:	20 14 01 00 00 00 00 00 00 00 00 00 00 ed 06 0b      ...............

00001bed <F_DII13>:
    1bed:	20 14 01 00 00 00 00 00 00 00 00 00 00 ed 06 0c      ...............

00001bfd <F_DII14>:
    1bfd:	20 14 01 00 00 00 00 00 00 00 00 00 00 ed 06 0d      ...............

00001c0d <F_DII15>:
    1c0d:	20 14 01 00 00 00 00 00 00 00 00 00 00 ed 06 0e      ...............

00001c1d <F_DII16>:
    1c1d:	20 14 01 00 00 00 00 00 00 00 00 00 00 ed 06 0f      ...............

00001c2d <F_DII17>:
    1c2d:	20 14 01 00 00 00 00 00 00 00 00 00 00 ed 06 10      ...............

00001c3d <F_DII18>:
    1c3d:	20 14 01 00 00 00 00 00 00 00 00 00 00 ed 06 11      ...............

00001c4d <ListDI>:
    1c4d:	20 4e 31 3a 20 20 7b 7b 7b 7b 20 7d 7d 7d 7d 20      N1:  {{{{ }}}} 
    1c5d:	7b 7b 7b 7b 00 55 1a 2d 1b 00 00 20 4e 32 3a 20     {{{{.U.-... N2: 
    1c6d:	20 7b 7b 7b 7b 20 7d 7d 7d 7d 20 7b 7b 7b 7b 00      {{{{ }}}} {{{{.
    1c7d:	61 1a 3d 1b 00 00 20 4e 33 3a 20 20 7b 7b 7b 7b     a.=... N3:  {{{{
    1c8d:	20 7d 7d 7d 7d 20 7b 7b 7b 7b 00 6d 1a 4d 1b 00      }}}} {{{{.m.M..
    1c9d:	00 20 4e 34 3a 20 20 7b 7b 7b 7b 20 7d 7d 7d 7d     . N4:  {{{{ }}}}
    1cad:	20 7b 7b 7b 7b 00 79 1a 5d 1b 00 00 20 4e 35 3a      {{{{.y.]... N5:
    1cbd:	20 20 7b 7b 7b 7b 20 7d 7d 7d 7d 20 7b 7b 7b 7b       {{{{ }}}} {{{{
    1ccd:	00 85 1a 6d 1b 00 00 20 4e 36 3a 20 20 7b 7b 7b     ...m... N6:  {{{
    1cdd:	7b 20 7d 7d 7d 7d 20 7b 7b 7b 7b 00 91 1a 7d 1b     { }}}} {{{{...}.
    1ced:	00 00 20 4e 37 3a 20 20 7b 7b 7b 7b 20 7d 7d 7d     .. N7:  {{{{ }}}
    1cfd:	7d 20 7b 7b 7b 7b 00 9d 1a 8d 1b 00 00 20 4e 38     } {{{{....... N8
    1d0d:	3a 20 20 7b 7b 7b 7b 20 7d 7d 7d 7d 20 7b 7b 7b     :  {{{{ }}}} {{{
    1d1d:	7b 00 a9 1a 9d 1b 00 00 20 4e 39 3a 20 20 7b 7b     {....... N9:  {{
    1d2d:	7b 7b 20 7d 7d 7d 7d 20 7b 7b 7b 7b 00 b5 1a ad     {{ }}}} {{{{....
    1d3d:	1b 00 00 20 4e 31 30 3a 20 7b 7b 7b 7b 20 7d 7d     ... N10: {{{{ }}
    1d4d:	7d 7d 20 7b 7b 7b 7b 00 c1 1a bd 1b 00 00 20 4e     }} {{{{....... N
    1d5d:	31 31 3a 20 7b 7b 7b 7b 20 7d 7d 7d 7d 20 7b 7b     11: {{{{ }}}} {{
    1d6d:	7b 7b 00 cd 1a cd 1b 00 00 20 4e 31 32 3a 20 7b     {{....... N12: {
    1d7d:	7b 7b 7b 20 7d 7d 7d 7d 20 7b 7b 7b 7b 00 d9 1a     {{{ }}}} {{{{...
    1d8d:	dd 1b 00 00 20 4e 31 33 3a 20 7b 7b 7b 7b 20 7d     .... N13: {{{{ }
    1d9d:	7d 7d 7d 20 7b 7b 7b 7b 00 e5 1a ed 1b 00 00 20     }}} {{{{....... 
    1dad:	4e 31 34 3a 20 7b 7b 7b 7b 20 7d 7d 7d 7d 20 7b     N14: {{{{ }}}} {
    1dbd:	7b 7b 7b 00 f1 1a fd 1b 00 00 20 4e 31 35 3a 20     {{{....... N15: 
    1dcd:	7b 7b 7b 7b 20 7d 7d 7d 7d 20 7b 7b 7b 7b 00 fd     {{{{ }}}} {{{{..
    1ddd:	1a 0d 1c 00 00 20 4e 31 36 3a 20 7b 7b 7b 7b 20     ..... N16: {{{{ 
    1ded:	7d 7d 7d 7d 20 7b 7b 7b 7b 00 09 1b 1d 1c 00 00     }}}} {{{{.......
    1dfd:	20 4e 31 37 3a 20 7b 7b 7b 7b 20 7d 7d 7d 7d 20      N17: {{{{ }}}} 
    1e0d:	7b 7b 7b 7b 00 15 1b 2d 1c 00 00 20 4e 31 38 3a     {{{{...-... N18:
    1e1d:	20 7b 7b 7b 7b 20 7d 7d 7d 7d 20 7b 7b 7b 7b 00      {{{{ }}}} {{{{.
    1e2d:	21 1b 3d 1c 00 00                                   !.=...

00001e33 <MenuDI>:
    1e33:	4d 1c 12 00 00 00 00 00 00 00 00 00 00 00 00 00     M...............
    1e43:	00 00 00 00                                         ....

00001e47 <F_DO1>:
    1e47:	1f 8d 07 00 00 00 00 00 00 00 00 00 00 fb 06 00     ................

00001e57 <F_DO2>:
    1e57:	1f 8d 07 00 00 00 00 00 00 00 00 00 00 fb 06 01     ................

00001e67 <F_DO3>:
    1e67:	1f 8d 07 00 00 00 00 00 00 00 00 00 00 fb 06 02     ................

00001e77 <F_DO4>:
    1e77:	1f 8d 07 00 00 00 00 00 00 00 00 00 00 fb 06 03     ................

00001e87 <F_DO5>:
    1e87:	1f 8d 07 00 00 00 00 00 00 00 00 00 00 fb 06 04     ................

00001e97 <F_DO6>:
    1e97:	1f 8d 07 00 00 00 00 00 00 00 00 00 00 fb 06 05     ................

00001ea7 <F_DO7>:
    1ea7:	1f 8d 07 00 00 00 00 00 00 00 00 00 00 fb 06 06     ................

00001eb7 <F_DO8>:
    1eb7:	1f 8d 07 00 00 00 00 00 00 00 00 00 00 fb 06 07     ................

00001ec7 <F_DO9>:
    1ec7:	1f 8d 07 00 00 00 00 00 00 00 00 00 00 fb 06 08     ................

00001ed7 <F_DO10>:
    1ed7:	1f 8d 07 00 00 00 00 00 00 00 00 00 00 fb 06 09     ................

00001ee7 <F_DO11>:
    1ee7:	1f 8d 07 00 00 00 00 00 00 00 00 00 00 fb 06 0a     ................

00001ef7 <F_DO12>:
    1ef7:	1f 8d 07 00 00 00 00 00 00 00 00 00 00 fb 06 0b     ................

00001f07 <F_DO13>:
    1f07:	1f 8d 07 00 00 00 00 00 00 00 00 00 00 fb 06 0c     ................

00001f17 <F_DO14>:
    1f17:	1f 8d 07 00 00 00 00 00 00 00 00 00 00 fb 06 0d     ................

00001f27 <F_DO15>:
    1f27:	1f 8d 07 00 00 00 00 00 00 00 00 00 00 fb 06 0e     ................

00001f37 <F_DO16>:
    1f37:	1f 8d 07 00 00 00 00 00 00 00 00 00 00 fb 06 0f     ................

00001f47 <ListDO>:
    1f47:	20 c2 fb f5 ee e4 20 4e 31 3a 20 20 20 20 20 7d      ..... N1:     }
    1f57:	7d 7d 7d 20 00 00 00 47 1e 00 00 20 c2 fb f5 ee     }}} ...G... ....
    1f67:	e4 20 4e 32 3a 20 20 20 20 20 7d 7d 7d 7d 20 00     . N2:     }}}} .
    1f77:	00 00 57 1e 00 00 20 c2 fb f5 ee e4 20 4e 33 3a     ..W... ..... N3:
    1f87:	20 20 20 20 20 7d 7d 7d 7d 20 00 00 00 67 1e 00          }}}} ...g..
    1f97:	00 20 c2 fb f5 ee e4 20 4e 34 3a 20 20 20 20 20     . ..... N4:     
    1fa7:	7d 7d 7d 7d 20 00 00 00 77 1e 00 00 20 c2 fb f5     }}}} ...w... ...
    1fb7:	ee e4 20 4e 35 3a 20 20 20 20 20 7d 7d 7d 7d 20     .. N5:     }}}} 
    1fc7:	00 00 00 87 1e 00 00 20 c2 fb f5 ee e4 20 4e 36     ....... ..... N6
    1fd7:	3a 20 20 20 20 20 7d 7d 7d 7d 20 00 00 00 97 1e     :     }}}} .....
    1fe7:	00 00 20 c2 fb f5 ee e4 20 4e 37 3a 20 20 20 20     .. ..... N7:    
    1ff7:	20 7d 7d 7d 7d 20 00 00 00 a7 1e 00 00 20 c2 fb      }}}} ....... ..
    2007:	f5 ee e4 20 4e 38 3a 20 20 20 20 20 7d 7d 7d 7d     ... N8:     }}}}
    2017:	20 00 00 00 b7 1e 00 00 20 c2 fb f5 ee e4 20 4e      ....... ..... N
    2027:	39 3a 20 20 20 20 20 7d 7d 7d 7d 20 00 00 00 c7     9:     }}}} ....
    2037:	1e 00 00 20 c2 fb f5 ee e4 20 4e 31 30 3a 20 20     ... ..... N10:  
    2047:	20 20 7d 7d 7d 7d 20 00 00 00 d7 1e 00 00 20 c2       }}}} ....... .
    2057:	fb f5 ee e4 20 4e 31 31 3a 20 20 20 20 7d 7d 7d     .... N11:    }}}
    2067:	7d 20 00 00 00 e7 1e 00 00 20 c2 fb f5 ee e4 20     } ....... ..... 
    2077:	4e 31 32 3a 20 20 20 20 7d 7d 7d 7d 20 00 00 00     N12:    }}}} ...
    2087:	f7 1e 00 00 20 c2 fb f5 ee e4 20 4e 31 33 3a 20     .... ..... N13: 
    2097:	20 20 20 7d 7d 7d 7d 20 00 00 00 07 1f 00 00 20        }}}} ....... 
    20a7:	c2 fb f5 ee e4 20 4e 31 34 3a 20 20 20 20 7d 7d     ..... N14:    }}
    20b7:	7d 7d 20 00 00 00 17 1f 00 00 20 c2 fb f5 ee e4     }} ....... .....
    20c7:	20 4e 31 35 3a 20 20 20 20 7d 7d 7d 7d 20 00 00      N15:    }}}} ..
    20d7:	00 27 1f 00 00 20 c2 fb f5 ee e4 20 4e 31 36 3a     .'... ..... N16:
    20e7:	20 20 20 20 7d 7d 7d 7d 20 00 00 00 37 1f 00 00         }}}} ...7...

000020f7 <MenuDO>:
    20f7:	47 1f 10 00 00 00 00 00 00 00 00 00 00 00 00 00     G...............
    2107:	00 00 00 00                                         ....

0000210b <F_AI12>:
    210b:	0b fc 0a 00 00 00 0b fe 0a 00 00 00                 ............

00002117 <F_AI34>:
    2117:	0b 00 0b 00 00 00 0b 02 0b 00 00 00                 ............

00002123 <F_AI56>:
    2123:	0b 04 0b 00 00 00 0b 06 0b 00 00 00                 ............

0000212f <F_AI78>:
    212f:	0b 08 0b 00 00 00 0b 0a 0b 00 00 00                 ............

0000213b <ListAI>:
    213b:	20 4e 31 3a 20 7b 7b 7b 7b 7b 20 4e 32 3a 20 7b      N1: {{{{{ N2: {
    214b:	7b 7b 7b 7b 00 0b 21 00 00 00 00 20 4e 33 3a 20     {{{{..!.... N3: 
    215b:	7b 7b 7b 7b 7b 20 4e 34 3a 20 7b 7b 7b 7b 7b 00     {{{{{ N4: {{{{{.
    216b:	17 21 00 00 00 00 20 4e 35 3a 20 7b 7b 7b 7b 7b     .!.... N5: {{{{{
    217b:	20 4e 36 3a 20 7b 7b 7b 7b 7b 00 23 21 00 00 00      N6: {{{{{.#!...
    218b:	00 20 4e 37 3a 20 7b 7b 7b 7b 7b 20 4e 38 3a 20     . N7: {{{{{ N8: 
    219b:	7b 7b 7b 7b 7b 00 2f 21 00 00 00 00                 {{{{{./!....

000021a7 <MenuAI>:
    21a7:	3b 21 04 03 00 00 00 00 00 00 00 00 00 00 00 00     ;!..............
    21b7:	00 00 00 00                                         ....

000021bb <F_AO1>:
    21bb:	0e 81 07 00 00 00 00 ff 03 00 00 00 00 00 00 00     ................

000021cb <F_AO2>:
    21cb:	0e 83 07 00 00 00 00 ff 03 00 00 00 00 00 00 00     ................

000021db <F_AO3>:
    21db:	0e 85 07 00 00 00 00 ff 03 00 00 00 00 00 00 00     ................

000021eb <F_AO4>:
    21eb:	0e 87 07 00 00 00 00 ff 03 00 00 00 00 00 00 00     ................

000021fb <ListAO>:
    21fb:	20 c2 fb f5 ee e4 20 4e 31 3a 20 20 20 20 20 7d      ..... N1:     }
    220b:	7d 7d 7d 7d 00 00 00 bb 21 00 00 20 c2 fb f5 ee     }}}}....!.. ....
    221b:	e4 20 4e 32 3a 20 20 20 20 20 7d 7d 7d 7d 7d 00     . N2:     }}}}}.
    222b:	00 00 cb 21 00 00 20 c2 fb f5 ee e4 20 4e 33 3a     ...!.. ..... N3:
    223b:	20 20 20 20 20 7d 7d 7d 7d 7d 00 00 00 db 21 00          }}}}}....!.
    224b:	00 20 c2 fb f5 ee e4 20 4e 34 3a 20 20 20 20 20     . ..... N4:     
    225b:	7d 7d 7d 7d 7d 00 00 00 eb 21 00 00                 }}}}}....!..

00002267 <MenuAO>:
    2267:	fb 21 04 00 00 00 00 00 00 00 00 00 00 00 00 00     .!..............
    2277:	00 00 00 00                                         ....

0000227b <F_ADC12>:
    227b:	07 c9 08 00 00 00 07 cb 08 00 00 00                 ............

00002287 <F_ADC34>:
    2287:	07 cd 08 00 00 00 07 cf 08 00 00 00                 ............

00002293 <F_ADC56>:
    2293:	07 d1 08 00 00 00 07 d3 08 00 00 00                 ............

0000229f <F_ADC_Ref>:
    229f:	07 d5 08 00 00 00                                   ......

000022a5 <List_ADC_Chan>:
    22a5:	20 2d 2d 2d 20 ca e0 ed e0 eb fb 20 c0 d6 cf 20      --- ...... ... 
    22b5:	2d 2d 2d 20 00 00 00 00 00 00 00 20 4e 31 3a 20     --- ....... N1: 
    22c5:	7b 7b 7b 7b 7b 20 4e 32 3a 20 7b 7b 7b 7b 7b 00     {{{{{ N2: {{{{{.
    22d5:	7b 22 00 00 00 00 20 4e 33 3a 20 7b 7b 7b 7b 7b     {".... N3: {{{{{
    22e5:	20 4e 34 3a 20 7b 7b 7b 7b 7b 00 87 22 00 00 00      N4: {{{{{.."...
    22f5:	00 20 4e 35 3a 20 7b 7b 7b 7b 7b 20 4e 36 3a 20     . N5: {{{{{ N6: 
    2305:	7b 7b 7b 7b 7b 00 93 22 00 00 00 00 20 ce ef ee     {{{{{..".... ...
    2315:	f0 ed 2e 20 ea e0 ed e0 eb 3a 20 7b 7b 7b 7b 7b     ... .....: {{{{{
    2325:	00 9f 22 00 00 00 00                                .."....

0000232c <Menu_ADC_Ch>:
    232c:	a5 22 05 01 00 00 00 00 00 00 00 00 00 00 00 00     ."..............
    233c:	00 00 00 00                                         ....

00002340 <F_ADC_Zero>:
    2340:	00 1d 0c 00 00 00 04 1c 0c 00 00 00 04 1b 0c 00     ................
	...

00002352 <F_ADC_Full>:
    2352:	00 20 0c 00 00 00 04 1f 0c 00 00 00 04 1e 0c 00     . ..............
	...

00002364 <List_ADC_Cali>:
    2364:	20 2d 2d 2d 20 ca e0 eb e8 e1 f0 ee e2 ea e0 20      --- .......... 
    2374:	2d 2d 2d 20 00 00 00 00 00 00 00 20 5a 65 72 6f     --- ....... Zero
    2384:	3a 20 20 7b 7b 7b 20 7b 7b 7b 20 7b 7b 7b 20 00     :  {{{ {{{ {{{ .
    2394:	40 23 00 00 00 00 20 46 75 6c 6c 3a 20 20 7b 7b     @#.... Full:  {{
    23a4:	7b 20 7b 7b 7b 20 7b 7b 7b 20 00 52 23 00 00 00     { {{{ {{{ .R#...
    23b4:	00 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20     .               
    23c4:	20 20 20 20 20 00 00 00 00 00 00 00                      .......

000023d0 <Menu_ADC_Cali>:
    23d0:	64 23 04 03 00 00 00 00 00 00 00 00 00 00 00 00     d#..............
    23e0:	00 00 00 00                                         ....

000023e4 <ADC_Rt_Str>:
    23e4:	52 65 73 65 74 00                                   Reset.

000023ea <ADC_I1_Str>:
    23ea:	49 6e 69 74 69 61 6c 69 73 61 74 00                 Initialisat.

000023f6 <ADC_C1_Str>:
    23f6:	43 61 6c 69 62 72 61 74 69 6f 6e 00                 Calibration.

00002402 <ADC_Re_Str>:
    2402:	52 65 61 64 00                                      Read.

00002407 <ADC_Of_Str>:
    2407:	4f 66 66 00                                         Off.

0000240b <ADC_Tbl>:
    240b:	e4 23 ea 23 f6 23 02 24 07 24                       .#.#.#.$.$

00002415 <F_Therm1>:
    2415:	09 3c 06 b0 08 01                                   .<....

0000241b <F_Therm2>:
    241b:	09 3e 06 b0 08 01                                   .>....

00002421 <F_Therm3>:
    2421:	09 40 06 b0 08 01                                   .@....

00002427 <F_Therm4>:
    2427:	09 42 06 b0 08 01                                   .B....

0000242d <F_Therm5>:
    242d:	09 44 06 b0 08 01                                   .D....

00002433 <F_Therm6>:
    2433:	09 46 06 b0 08 01                                   .F....

00002439 <F_Thermis1>:
    2439:	1e 17 01 00 00 00 00 07 00 00 00 00 00 e4 08 00     ................

00002449 <F_Thermis2>:
    2449:	1e 18 01 00 00 00 00 07 00 00 00 00 00 e4 08 00     ................

00002459 <F_Thermis3>:
    2459:	1e 19 01 00 00 00 00 07 00 00 00 00 00 e4 08 00     ................

00002469 <F_Thermis4>:
    2469:	1e 1a 01 00 00 00 00 07 00 00 00 00 00 e4 08 00     ................

00002479 <F_Thermis5>:
    2479:	1e 1b 01 00 00 00 00 07 00 00 00 00 00 e4 08 00     ................

00002489 <F_Thermis6>:
    2489:	1e 1c 01 00 00 00 00 07 00 00 00 00 00 e4 08 00     ................

00002499 <F_ThermisD1>:
    2499:	03 1d 01 80 ff ff ff 7f 00 00 00 00 00 00 00 01     ................

000024a9 <F_ThermisD2>:
    24a9:	03 20 01 80 ff ff ff 7f 00 00 00 00 00 00 00 01     . ..............

000024b9 <F_ThermisD3>:
    24b9:	03 23 01 80 ff ff ff 7f 00 00 00 00 00 00 00 01     .#..............

000024c9 <F_ThermisD4>:
    24c9:	03 26 01 80 ff ff ff 7f 00 00 00 00 00 00 00 01     .&..............

000024d9 <F_ThermisD5>:
    24d9:	03 29 01 80 ff ff ff 7f 00 00 00 00 00 00 00 01     .)..............

000024e9 <F_ThermisD6>:
    24e9:	03 2c 01 80 ff ff ff 7f 00 00 00 00 00 00 00 01     .,..............

000024f9 <F_ThermisA1>:
    24f9:	08 1e 01 84 03 00 00 4c 04 00 00 00 00 00 00 03     .......L........

00002509 <F_ThermisA2>:
    2509:	08 21 01 84 03 00 00 4c 04 00 00 00 00 00 00 03     .!.....L........

00002519 <F_ThermisA3>:
    2519:	08 24 01 84 03 00 00 4c 04 00 00 00 00 00 00 03     .$.....L........

00002529 <F_ThermisA4>:
    2529:	08 27 01 84 03 00 00 4c 04 00 00 00 00 00 00 03     .'.....L........

00002539 <F_ThermisA5>:
    2539:	08 2a 01 84 03 00 00 4c 04 00 00 00 00 00 00 03     .*.....L........

00002549 <F_ThermisA6>:
    2549:	08 2d 01 84 03 00 00 4c 04 00 00 00 00 00 00 03     .-.....L........

00002559 <ListTherm1>:
    2559:	20 ca e0 ed e0 eb 20 4e 31 3a 20 7b 7b 7b 7b 7b      ..... N1: {{{{{
    2569:	7b 7b 7c 43 00 15 24 00 00 00 00 20 d2 e5 f0 ec     {{|C..$.... ....
    2579:	ee e4 e0 f2 f7 e8 ea 3a 20 7d 7d 7d 7d 7d 7d 00     .......: }}}}}}.
    2589:	00 00 39 24 00 00 20 d1 e4 e2 e8 e3 3a 20 20 20     ..9$.. .....:   
    2599:	20 20 20 7d 7d 7d 7d 7d 7c 43 00 00 00 99 24 00        }}}}}|C....$.
    25a9:	00 20 ca ee fd f4 f4 e8 f6 e8 e5 ed f2 3a 20 20     . ...........:  
    25b9:	7d 7d 7d 7d 7d 00 00 00 f9 24 00 00                 }}}}}....$..

000025c5 <MenuTherm1>:
    25c5:	59 25 04 01 00 00 00 00 00 00 00 00 00 00 00 00     Y%..............
    25d5:	00 00 00 00                                         ....

000025d9 <ListTherm2>:
    25d9:	20 ca e0 ed e0 eb 20 4e 32 3a 20 7b 7b 7b 7b 7b      ..... N2: {{{{{
    25e9:	7b 7b 7c 43 00 1b 24 00 00 00 00 20 d2 e5 f0 ec     {{|C..$.... ....
    25f9:	ee e4 e0 f2 f7 e8 ea 3a 20 7d 7d 7d 7d 7d 7d 00     .......: }}}}}}.
    2609:	00 00 49 24 00 00 20 d1 e4 e2 e8 e3 3a 20 20 20     ..I$.. .....:   
    2619:	20 20 20 7d 7d 7d 7d 7d 7c 43 00 00 00 a9 24 00        }}}}}|C....$.
    2629:	00 20 ca ee fd f4 f4 e8 f6 e8 e5 ed f2 3a 20 20     . ...........:  
    2639:	7d 7d 7d 7d 7d 00 00 00 09 25 00 00                 }}}}}....%..

00002645 <MenuTherm2>:
    2645:	d9 25 04 01 00 00 00 00 00 00 00 00 00 00 00 00     .%..............
    2655:	00 00 00 00                                         ....

00002659 <ListTherm3>:
    2659:	20 ca e0 ed e0 eb 20 4e 33 3a 20 7b 7b 7b 7b 7b      ..... N3: {{{{{
    2669:	7b 7b 7c 43 00 21 24 00 00 00 00 20 d2 e5 f0 ec     {{|C.!$.... ....
    2679:	ee e4 e0 f2 f7 e8 ea 3a 20 7d 7d 7d 7d 7d 7d 00     .......: }}}}}}.
    2689:	00 00 59 24 00 00 20 d1 e4 e2 e8 e3 3a 20 20 20     ..Y$.. .....:   
    2699:	20 20 20 7d 7d 7d 7d 7d 7c 43 00 00 00 b9 24 00        }}}}}|C....$.
    26a9:	00 20 ca ee fd f4 f4 e8 f6 e8 e5 ed f2 3a 20 20     . ...........:  
    26b9:	7d 7d 7d 7d 7d 00 00 00 19 25 00 00                 }}}}}....%..

000026c5 <MenuTherm3>:
    26c5:	59 26 04 01 00 00 00 00 00 00 00 00 00 00 00 00     Y&..............
    26d5:	00 00 00 00                                         ....

000026d9 <ListTherm4>:
    26d9:	20 ca e0 ed e0 eb 20 4e 34 3a 20 7b 7b 7b 7b 7b      ..... N4: {{{{{
    26e9:	7b 7b 7c 43 00 27 24 00 00 00 00 20 d2 e5 f0 ec     {{|C.'$.... ....
    26f9:	ee e4 e0 f2 f7 e8 ea 3a 20 7d 7d 7d 7d 7d 7d 00     .......: }}}}}}.
    2709:	00 00 69 24 00 00 20 d1 e4 e2 e8 e3 3a 20 20 20     ..i$.. .....:   
    2719:	20 20 20 7d 7d 7d 7d 7d 7c 43 00 00 00 c9 24 00        }}}}}|C....$.
    2729:	00 20 ca ee fd f4 f4 e8 f6 e8 e5 ed f2 3a 20 20     . ...........:  
    2739:	7d 7d 7d 7d 7d 00 00 00 29 25 00 00                 }}}}}...)%..

00002745 <MenuTherm4>:
    2745:	d9 26 04 01 00 00 00 00 00 00 00 00 00 00 00 00     .&..............
    2755:	00 00 00 00                                         ....

00002759 <ListTherm5>:
    2759:	20 ca e0 ed e0 eb 20 4e 35 3a 20 7b 7b 7b 7b 7b      ..... N5: {{{{{
    2769:	7b 7b 7c 43 00 2d 24 00 00 00 00 20 d2 e5 f0 ec     {{|C.-$.... ....
    2779:	ee e4 e0 f2 f7 e8 ea 3a 20 7d 7d 7d 7d 7d 7d 00     .......: }}}}}}.
    2789:	00 00 79 24 00 00 20 d1 e4 e2 e8 e3 3a 20 20 20     ..y$.. .....:   
    2799:	20 20 20 7d 7d 7d 7d 7d 7c 43 00 00 00 d9 24 00        }}}}}|C....$.
    27a9:	00 20 ca ee fd f4 f4 e8 f6 e8 e5 ed f2 3a 20 20     . ...........:  
    27b9:	7d 7d 7d 7d 7d 00 00 00 39 25 00 00                 }}}}}...9%..

000027c5 <MenuTherm5>:
    27c5:	59 27 04 01 00 00 00 00 00 00 00 00 00 00 00 00     Y'..............
    27d5:	00 00 00 00                                         ....

000027d9 <ListTherm6>:
    27d9:	20 ca e0 ed e0 eb 20 4e 36 3a 20 7b 7b 7b 7b 7b      ..... N6: {{{{{
    27e9:	7b 7b 7c 43 00 33 24 00 00 00 00 20 d2 e5 f0 ec     {{|C.3$.... ....
    27f9:	ee e4 e0 f2 f7 e8 ea 3a 20 7d 7d 7d 7d 7d 7d 00     .......: }}}}}}.
    2809:	00 00 89 24 00 00 20 d1 e4 e2 e8 e3 3a 20 20 20     ...$.. .....:   
    2819:	20 20 20 7d 7d 7d 7d 7d 7c 43 00 00 00 e9 24 00        }}}}}|C....$.
    2829:	00 20 ca ee fd f4 f4 e8 f6 e8 e5 ed f2 3a 20 20     . ...........:  
    2839:	7d 7d 7d 7d 7d 00 00 00 49 25 00 00                 }}}}}...I%..

00002845 <MenuTherm6>:
    2845:	d9 27 04 01 00 00 00 00 00 00 00 00 00 00 00 00     .'..............
    2855:	00 00 00 00                                         ....

00002859 <List_Therm>:
    2859:	20 ca e0 ed e0 eb 20 4e 31 3a 20 7b 7b 7b 7b 7b      ..... N1: {{{{{
    2869:	7b 7b 7c 43 00 15 24 00 00 c5 25 20 ca e0 ed e0     {{|C..$...% ....
    2879:	eb 20 4e 32 3a 20 7b 7b 7b 7b 7b 7b 7b 7c 43 00     . N2: {{{{{{{|C.
    2889:	1b 24 00 00 45 26 20 ca e0 ed e0 eb 20 4e 33 3a     .$..E& ..... N3:
    2899:	20 7b 7b 7b 7b 7b 7b 7b 7c 43 00 21 24 00 00 c5      {{{{{{{|C.!$...
    28a9:	26 20 ca e0 ed e0 eb 20 4e 34 3a 20 7b 7b 7b 7b     & ..... N4: {{{{
    28b9:	7b 7b 7b 7c 43 00 27 24 00 00 45 27 20 ca e0 ed     {{{|C.'$..E' ...
    28c9:	e0 eb 20 4e 35 3a 20 7b 7b 7b 7b 7b 7b 7b 7c 43     .. N5: {{{{{{{|C
    28d9:	00 2d 24 00 00 c5 27 20 ca e0 ed e0 eb 20 4e 36     .-$...' ..... N6
    28e9:	3a 20 7b 7b 7b 7b 7b 7b 7b 7c 43 00 33 24 00 00     : {{{{{{{|C.3$..
    28f9:	45 28                                               E(

000028fb <MenuTherm>:
    28fb:	59 28 06 00 00 00 00 00 00 00 00 00 00 00 00 00     Y(..............
    290b:	00 00 00 00                                         ....

0000290f <MB_Master_List>:
    290f:	00 00 00                                            ...

00002912 <MenuModem>:
    2912:	45 0f 22 00 77 29 00 00 00 00 00 00 00 00 00 00     E.".w)..........
    2922:	00 00 00 00                                         ....

00002926 <Menu0List>:
    2926:	20 2d 47 53 4d 2d f1 e8 e3 ed e0 eb e8 e7 e0 f2      -GSM-..........
    2936:	ee f0 2d 20 00 00 00 00 00 77 29 20 d1 eb f3 e6     ..- .....w) ....
    2946:	e5 e1 ed ee e5 20 20 20 20 20 20 20 20 20 20 00     .....          .
    2956:	00 00 00 00 df 19 20 cc ee e4 e5 ec 20 20 20 20     ...... .....    
    2966:	20 20 20 20 20 20 20 20 20 20 00 00 00 00 00 12               ......
    2976:	29                                                  )

00002977 <Menu0>:
    2977:	26 29 03 00 77 29 00 00 00 00 00 00 00 00 00 00     &)..w)..........
    2987:	00 00 00 00                                         ....

0000298b <KeyAct.9232>:
    298b:	00 00 38 3f 39 3f ed 55 45 51 97 59 3c 59           ..8?9?.UEQ.Y<Y

00002999 <MaxThermType>:
    2999:	07 02                                               ..

0000299b <TerLimType>:
    299b:	87 06 a7 06                                         ....

0000299f <TSM100Tbl>:
    299f:	00 00 e1 f6 91 08 30 f8 0e 28 18 fc a2 37 0c fe     ......0..(...7..
    29af:	ea 46 00 00 49 65 e8 03 a6 83 d0 07 ff ff f4 17     .F..Ie..........

000029bf <TSM50Tbl>:
    29bf:	00 00 df f6 46 04 30 f8 13 0c 24 fa fe 13 18 fc     ....F.0...$.....
    29cf:	c6 1b 0c fe 6b 23 00 00 03 2b f4 01 9a 32 e8 03     ....k#...+...2..
    29df:	30 3a dc 05 c9 41 d0 07 ff ff bd 38                 0:...A.....8

000029eb <TSP100Tbl>:
    29eb:	00 00 f6 f5 c2 38 0c fe e2 46 00 00 b6 62 e8 03     .....8...F...b..
    29fb:	96 7d d0 07 ae 97 b8 0b ea b0 a0 0f 54 c9 88 13     .}..........T...
    2a0b:	e2 e0 70 17 ff ff 97 1e                             ..p.....

00002a13 <TSP50Tbl>:
    2a13:	00 00 1f f6 5f 1c 0c fe 56 31 e8 03 d0 3e d0 07     ...._...V1...>..
    2a23:	d2 4b b8 0b 70 58 a0 0f aa 64 88 13 6c 70 70 17     .K..pX...d..lpp.
    2a33:	ff ff 0e 47                                         ...G

00002a37 <Pt100Tbl>:
    2a37:	00 00 20 f6 fe 38 0c fe 48 62 e8 03 c4 7c d0 07     .. ..8..Hb...|..
    2a47:	6e 96 b8 0b 50 af a0 0f 56 c7 88 13 94 de 70 17     n...P...V.....p.
    2a57:	f6 f4 58 1b ff ff 8b 1f                             ..X.....

00002a5f <Gr21Tbl>:
    2a5f:	00 00 1e f6 1c 1a 0c fe 64 2d e8 03 c6 39 d0 07     ........d-...9..
    2a6f:	c4 45 b8 0b 68 51 a0 0f 9e 5c 88 13 7a 67 70 17     .E..hQ...\..zgp.
    2a7f:	ff ff ce 4f                                         ...O

00002a83 <Gr23Tbl>:
    2a83:	00 00 d5 f6 7d 1d 0c fe 8b 25 00 00 8f 2d f4 01     ....}....%...-..
    2a93:	92 35 e8 03 95 3d dc 05 63 42 08 07 ff ff 3e 35     .5...=..cB....>5

00002aa3 <TC_B_Tbl>:
    2aa3:	00 00 90 01 99 01 dc 05 7c 07 b8 0b 8e 15 88 13     ........|.......
    2ab3:	1b 1f 70 17 30 2a 58 1b c4 36 40 1f b6 44 28 23     ..p.0*X..6@..D(#
    2ac3:	f2 53 10 27 5a 64 f8 2a d0 75 e0 2e 40 88 c8 32     .S.'Zd.*.u..@..2
    2ad3:	78 9b b0 36 50 af 98 3a 82 c3 80 3e d2 d7 68 42     x..6P..:...>..hB
    2ae3:	ff ff 38 4a                                         ..8J

00002ae7 <Mux.8681>:
    2ae7:	06 00 07 00 00 08 01 08 02 08 03 08 04 08 05 08     ................

00002af7 <M.8606>:
    2af7:	00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f     ................

00002b07 <DI_M>:
    2b07:	07 01 08 01 06 01 40 00 07 01 08 01 06 01 80 00     ......@.........
    2b17:	04 01 05 01 03 01 80 00 21 00 22 00 20 00 01 00     ........!.". ...
    2b27:	21 00 22 00 20 00 02 00 21 00 22 00 20 00 04 00     !.". ...!.". ...
    2b37:	21 00 22 00 20 00 08 00 21 00 22 00 20 00 10 00     !.". ...!.". ...
    2b47:	21 00 22 00 20 00 20 00 21 00 22 00 20 00 40 00     !.". . .!.". .@.
    2b57:	21 00 22 00 20 00 80 00 33 00 34 00 32 00 04 00     !.". ...3.4.2...
    2b67:	04 01 05 01 03 01 40 00 04 01 05 01 03 01 20 00     ......@....... .
    2b77:	04 01 05 01 03 01 10 00 04 01 05 01 03 01 08 00     ................
    2b87:	04 01 05 01 03 01 02 01 04 01 05 01 03 01 04 01     ................

00002b97 <__c.6076>:
    2b97:	2b 50 44 50 00                                      +PDP.

00002b9c <__c.6074>:
    2b9c:	43 4c 4f 53 00                                      CLOS.

00002ba1 <__c.6072>:
    2ba1:	50 4f 53 54 00                                      POST.

00002ba6 <__c.6069>:
    2ba6:	47 45 54 20 00                                      GET .

00002bab <__c.6067>:
    2bab:	0d 0a 00                                            ...

00002bae <__c.6063>:
    2bae:	2b 43 53 51 3a 20 25 68 68 75 2c 25 68 68 75 00     +CSQ: %hhu,%hhu.

00002bbe <__c.6016>:
    2bbe:	25 68 68 75 2c 20 43 4c 4f 53 45 44 00              %hhu, CLOSED.

00002bcb <__c.6010>:
    2bcb:	4f 4b 00                                            OK.

00002bce <__c.6003>:
    2bce:	25 68 68 75 20 25 68 68 75 20 25 68 68 75 20 25     %hhu %hhu %hhu %
    2bde:	68 68 75 00                                         hhu.

00002be2 <MB_Port>:
    2be2:	ce 00 c8 00 c9 00 ca 00 cd 00 cc 00 39 1d 3f 1d     ............9.?.
    2bf2:	43 1d 44 1d                                         C.D.

00002bf6 <MB_Role>:
	...

00002bf7 <MB_Timer>:
    2bf7:	46 00 47 00 3e 27 b2 00 b3 00 48 27 a4 00 a8 00     F.G.>'....H'....
    2c07:	54 27                                               T'

00002c09 <CGRAM_LCD>:
    2c09:	00 04 06 1f 06 04 00 00 06 09 09 06 00 00 00 00     ................
    2c19:	00 08 08 0e 0f 1f 0f 06 00 00 0e 11 1c 11 0e 00     ................
    2c29:	0e 11 10 1c 10 11 0e 00 0a 00 0c 04 04 04 0e 00     ................
    2c39:	0a 0e 04 04 04 04 0e 00 00 00 00 00 00 00 00 00     ................

00002c49 <Win2LCD>:
    2c49:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    2c59:	00 02 ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    2c69:	20 21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f      !"#$%&'()*+,-./
    2c79:	30 31 32 33 34 35 36 37 38 39 3a 3b 3c 3d 3e 3f     0123456789:;<=>?
    2c89:	40 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e 4f     @ABCDEFGHIJKLMNO
    2c99:	50 51 52 53 54 55 56 57 58 59 5a 5b 5c 5d 5e 5f     PQRSTUVWXYZ[\]^_
    2ca9:	60 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e 6f     `abcdefghijklmno
    2cb9:	70 71 72 73 74 75 76 77 78 79 7a 7b 01 7d e9 7f     pqrstuvwxyz{.}..
    2cc9:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    2cd9:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    2ce9:	ff ff ff ff ff ff ff d9 a2 ff 04 ff ff ff ff 06     ................
    2cf9:	ff ff 49 69 ff ff ff da b5 ff 03 ff ff ff ff 05     ..Ii............
    2d09:	41 a0 42 a1 e0 45 a3 a4 a5 a6 4b a7 4d 48 4f a8     A.B..E....K.MHO.
    2d19:	50 43 54 a9 aa 58 e1 ab ac e2 ad ae 62 af b0 b1     PCT..X......b...
    2d29:	61 b2 b3 b4 e3 65 b6 b7 b8 b9 ba bb bc bd 6f be     a....e........o.
    2d39:	70 63 bf 79 e4 78 e5 c0 c1 e6 c2 c3 c4 c5 c6 c7     pc.y.x..........

00002d49 <LineAddr.3690>:
    2d49:	80 c0 94 d4                                         ....

00002d4d <Mux>:
    2d4d:	00 01 02 03 04 05 06                                .......

00002d54 <aCRCLo.1496>:
    2d54:	00 c0 c1 01 c3 03 02 c2 c6 06 07 c7 05 c5 c4 04     ................
    2d64:	cc 0c 0d cd 0f cf ce 0e 0a ca cb 0b c9 09 08 c8     ................
    2d74:	d8 18 19 d9 1b db da 1a 1e de df 1f dd 1d 1c dc     ................
    2d84:	14 d4 d5 15 d7 17 16 d6 d2 12 13 d3 11 d1 d0 10     ................
    2d94:	f0 30 31 f1 33 f3 f2 32 36 f6 f7 37 f5 35 34 f4     .01.3..26..7.54.
    2da4:	3c fc fd 3d ff 3f 3e fe fa 3a 3b fb 39 f9 f8 38     <..=.?>..:;.9..8
    2db4:	28 e8 e9 29 eb 2b 2a ea ee 2e 2f ef 2d ed ec 2c     (..).+*.../.-..,
    2dc4:	e4 24 25 e5 27 e7 e6 26 22 e2 e3 23 e1 21 20 e0     .$%.'..&"..#.! .
    2dd4:	a0 60 61 a1 63 a3 a2 62 66 a6 a7 67 a5 65 64 a4     .`a.c..bf..g.ed.
    2de4:	6c ac ad 6d af 6f 6e ae aa 6a 6b ab 69 a9 a8 68     l..m.on..jk.i..h
    2df4:	78 b8 b9 79 bb 7b 7a ba be 7e 7f bf 7d bd bc 7c     x..y.{z..~..}..|
    2e04:	b4 74 75 b5 77 b7 b6 76 72 b2 b3 73 b1 71 70 b0     .tu.w..vr..s.qp.
    2e14:	50 90 91 51 93 53 52 92 96 56 57 97 55 95 94 54     P..Q.SR..VW.U..T
    2e24:	9c 5c 5d 9d 5f 9f 9e 5e 5a 9a 9b 5b 99 59 58 98     .\]._..^Z..[.YX.
    2e34:	88 48 49 89 4b 8b 8a 4a 4e 8e 8f 4f 8d 4d 4c 8c     .HI.K..JN..O.ML.
    2e44:	44 84 85 45 87 47 46 86 82 42 43 83 41 81 80 40     D..E.GF..BC.A..@

00002e54 <aCRCHi.1495>:
    2e54:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    2e64:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    2e74:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    2e84:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    2e94:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    2ea4:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    2eb4:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    2ec4:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    2ed4:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    2ee4:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    2ef4:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    2f04:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    2f14:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    2f24:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    2f34:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    2f44:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    2f54:	00 40 7a 10 f3 5a 00 a0 72 4e 18 09 00 10 a5 d4     .@z..Z..rN......
    2f64:	e8 00 00 e8 76 48 17 00 00 e4 0b 54 02 00 00 ca     ....vH.....T....
    2f74:	9a 3b 00 00 00 e1 f5 05 00 00 80 96 98 00 00 00     .;..............
    2f84:	40 42 0f 00 00 00 a0 86 01 00 00 00 10 27 00 00     @B...........'..
    2f94:	00 00 e8 03 00 00 00 00 64 00 00 00 00 00 0a 00     ........d.......
    2fa4:	00 00 00 00 01 00 00 00 00 00 2c 76 d8 88 dc 67     ..........,v...g
    2fb4:	4f 08 23 df c1 df ae 59 e1 b1 b7 96 e5 e3 e4 53     O.#....Y.......S
    2fc4:	c6 3a e6 51 99 76 96 e8 e6 c2 84 26 eb 89 8c 9b     .:.Q.v.....&....
    2fd4:	62 ed 40 7c 6f fc ef bc 9c 9f 40 f2 ba a5 6f a5     b.@|o.....@...o.
    2fe4:	f4 90 05 5a 2a f7 5c 93 6b 6c f9 67 6d c1 1b fc     ...Z*.\.kl.gm...
    2ff4:	e0 e4 0d 47 fe f5 20 e6 b5 00 d0 ed 90 2e 03 00     ...G.. .........
    3004:	94 35 77 05 00 80 84 1e 08 00 00 20 4e 0a 00 00     .5w........ N...
    3014:	00 c8 0c 33 33 33 33 0f 98 6e 12 83 11 41 ef 8d     ...3333..n...A..
    3024:	21 14 89 3b e6 55 16 cf fe e6 db 18 d1 84 4b 38     !..;.U........K8
    3034:	1b f7 7c 1d 90 1d a4 bb e4 24 20 32 84 72 5e 22     ..|......$ 2.r^"
    3044:	81 00 c9 f1 24 ec a1 e5 3d 27                       ....$...='

0000304e <__ctors_end>:
    304e:	11 24       	eor	r1, r1
    3050:	1f be       	out	0x3f, r1	; 63
    3052:	cf ef       	ldi	r28, 0xFF	; 255
    3054:	d1 e2       	ldi	r29, 0x21	; 33
    3056:	de bf       	out	0x3e, r29	; 62
    3058:	cd bf       	out	0x3d, r28	; 61
    305a:	00 e0       	ldi	r16, 0x00	; 0
    305c:	0c bf       	out	0x3c, r16	; 60

0000305e <__do_copy_data>:
    305e:	12 e0       	ldi	r17, 0x02	; 2
    3060:	a0 e0       	ldi	r26, 0x00	; 0
    3062:	b2 e0       	ldi	r27, 0x02	; 2
    3064:	e0 ea       	ldi	r30, 0xA0	; 160
    3066:	fb ef       	ldi	r31, 0xFB	; 251
    3068:	00 e0       	ldi	r16, 0x00	; 0
    306a:	0b bf       	out	0x3b, r16	; 59
    306c:	02 c0       	rjmp	.+4      	; 0x3072 <__do_copy_data+0x14>
    306e:	07 90       	elpm	r0, Z+
    3070:	0d 92       	st	X+, r0
    3072:	a6 3d       	cpi	r26, 0xD6	; 214
    3074:	b1 07       	cpc	r27, r17
    3076:	d9 f7       	brne	.-10     	; 0x306e <__do_copy_data+0x10>

00003078 <__do_clear_bss>:
    3078:	1c e0       	ldi	r17, 0x0C	; 12
    307a:	a6 ed       	ldi	r26, 0xD6	; 214
    307c:	b2 e0       	ldi	r27, 0x02	; 2
    307e:	01 c0       	rjmp	.+2      	; 0x3082 <.do_clear_bss_start>

00003080 <.do_clear_bss_loop>:
    3080:	1d 92       	st	X+, r1

00003082 <.do_clear_bss_start>:
    3082:	a2 32       	cpi	r26, 0x22	; 34
    3084:	b1 07       	cpc	r27, r17
    3086:	e1 f7       	brne	.-8      	; 0x3080 <.do_clear_bss_loop>
    3088:	0e 94 0b 6f 	call	0xde16	; 0xde16 <main>
    308c:	0c 94 e3 78 	jmp	0xf1c6	; 0xf1c6 <exit>

00003090 <__bad_interrupt>:
    3090:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00003094 <rrb>:
#include <stdint.h>

// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
rrb(const uint8_t *addr)
{
    3094:	fc 01       	movw	r30, r24
	return *addr;
}
    3096:	80 81       	ld	r24, Z
    3098:	08 95       	ret

0000309a <prb>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    309a:	fc 01       	movw	r30, r24
    309c:	84 91       	lpm	r24, Z+
}
    309e:	08 95       	ret

000030a0 <prw>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    30a0:	fc 01       	movw	r30, r24
    30a2:	25 91       	lpm	r18, Z+
    30a4:	34 91       	lpm	r19, Z+
}
    30a6:	c9 01       	movw	r24, r18
    30a8:	08 95       	ret

000030aa <prd>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    30aa:	fc 01       	movw	r30, r24
    30ac:	25 91       	lpm	r18, Z+
    30ae:	35 91       	lpm	r19, Z+
    30b0:	45 91       	lpm	r20, Z+
    30b2:	54 91       	lpm	r21, Z+
}
    30b4:	b9 01       	movw	r22, r18
    30b6:	ca 01       	movw	r24, r20
    30b8:	08 95       	ret

000030ba <prb_f>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#if FLASHEND>0xFFFF
uint8_t
prb_f(const prog_uint8_t *addr)
{
	return pgm_read_byte_far((uint16_t)addr+0x10000);
    30ba:	a0 e0       	ldi	r26, 0x00	; 0
    30bc:	b0 e0       	ldi	r27, 0x00	; 0
    30be:	80 50       	subi	r24, 0x00	; 0
    30c0:	90 40       	sbci	r25, 0x00	; 0
    30c2:	af 4f       	sbci	r26, 0xFF	; 255
    30c4:	bf 4f       	sbci	r27, 0xFF	; 255
}
    30c6:	ab bf       	out	0x3b, r26	; 59
    30c8:	fc 01       	movw	r30, r24
    30ca:	87 91       	elpm	r24, Z+
    30cc:	08 95       	ret

000030ce <prc>:

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    30ce:	fc 01       	movw	r30, r24
    30d0:	84 91       	lpm	r24, Z+
}
    30d2:	08 95       	ret

000030d4 <prp>:

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    30d4:	fc 01       	movw	r30, r24
    30d6:	25 91       	lpm	r18, Z+
    30d8:	34 91       	lpm	r19, Z+
}
    30da:	c9 01       	movw	r24, r18
    30dc:	08 95       	ret

000030de <CRC_Seed>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
CRC_Seed(uint8_t (*GetByte)(const uint8_t*), const uint8_t *Block, uint32_t Sz, uint16_t Seed)
{
    30de:	6f 92       	push	r6
    30e0:	7f 92       	push	r7
    30e2:	8f 92       	push	r8
    30e4:	9f 92       	push	r9
    30e6:	af 92       	push	r10
    30e8:	bf 92       	push	r11
    30ea:	cf 92       	push	r12
    30ec:	df 92       	push	r13
    30ee:	ef 92       	push	r14
    30f0:	ff 92       	push	r15
    30f2:	0f 93       	push	r16
    30f4:	1f 93       	push	r17
    30f6:	cf 93       	push	r28
    30f8:	df 93       	push	r29
    30fa:	3c 01       	movw	r6, r24
    30fc:	eb 01       	movw	r28, r22
    30fe:	49 01       	movw	r8, r18
    3100:	5a 01       	movw	r10, r20
    3102:	c1 2e       	mov	r12, r17
		0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54,
		0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98,
		0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
		0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 0x40
	};
	uint8_t CRCHi=Seed>>8, CRCLo=Seed;
    3104:	d0 2e       	mov	r13, r16
	for (uint32_t i=0; i<Sz; i++) {
    3106:	21 15       	cp	r18, r1
    3108:	31 05       	cpc	r19, r1
    310a:	41 05       	cpc	r20, r1
    310c:	51 05       	cpc	r21, r1
    310e:	f9 f0       	breq	.+62     	; 0x314e <CRC_Seed+0x70>
    3110:	ee 24       	eor	r14, r14
    3112:	ff 24       	eor	r15, r15
    3114:	87 01       	movw	r16, r14
		uint8_t j = CRCLo^GetByte(Block+i);
    3116:	ce 01       	movw	r24, r28
    3118:	8e 0d       	add	r24, r14
    311a:	9f 1d       	adc	r25, r15
    311c:	f3 01       	movw	r30, r6
    311e:	19 95       	eicall
		CRCLo = CRCHi^prb(aCRCHi+j);
    3120:	d8 26       	eor	r13, r24
    3122:	2d 2d       	mov	r18, r13
    3124:	30 e0       	ldi	r19, 0x00	; 0

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    3126:	c9 01       	movw	r24, r18
    3128:	8c 5a       	subi	r24, 0xAC	; 172
    312a:	91 4d       	sbci	r25, 0xD1	; 209
    312c:	fc 01       	movw	r30, r24
    312e:	d4 90       	lpm	r13, Z+
		0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 0x40
	};
	uint8_t CRCHi=Seed>>8, CRCLo=Seed;
	for (uint32_t i=0; i<Sz; i++) {
		uint8_t j = CRCLo^GetByte(Block+i);
		CRCLo = CRCHi^prb(aCRCHi+j);
    3130:	dc 24       	eor	r13, r12

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    3132:	2c 5a       	subi	r18, 0xAC	; 172
    3134:	32 4d       	sbci	r19, 0xD2	; 210
    3136:	f9 01       	movw	r30, r18
    3138:	c4 90       	lpm	r12, Z+
		0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98,
		0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
		0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 0x40
	};
	uint8_t CRCHi=Seed>>8, CRCLo=Seed;
	for (uint32_t i=0; i<Sz; i++) {
    313a:	08 94       	sec
    313c:	e1 1c       	adc	r14, r1
    313e:	f1 1c       	adc	r15, r1
    3140:	01 1d       	adc	r16, r1
    3142:	11 1d       	adc	r17, r1
    3144:	e8 14       	cp	r14, r8
    3146:	f9 04       	cpc	r15, r9
    3148:	0a 05       	cpc	r16, r10
    314a:	1b 05       	cpc	r17, r11
    314c:	20 f3       	brcs	.-56     	; 0x3116 <CRC_Seed+0x38>
    314e:	9c 2d       	mov	r25, r12
    3150:	80 e0       	ldi	r24, 0x00	; 0
    3152:	2d 2d       	mov	r18, r13
    3154:	30 e0       	ldi	r19, 0x00	; 0
    3156:	28 2b       	or	r18, r24
    3158:	39 2b       	or	r19, r25
		uint8_t j = CRCLo^GetByte(Block+i);
		CRCLo = CRCHi^prb(aCRCHi+j);
		CRCHi = prb(aCRCLo+j);
	}
	return CRCHi<<8|CRCLo;
}
    315a:	c9 01       	movw	r24, r18
    315c:	df 91       	pop	r29
    315e:	cf 91       	pop	r28
    3160:	1f 91       	pop	r17
    3162:	0f 91       	pop	r16
    3164:	ff 90       	pop	r15
    3166:	ef 90       	pop	r14
    3168:	df 90       	pop	r13
    316a:	cf 90       	pop	r12
    316c:	bf 90       	pop	r11
    316e:	af 90       	pop	r10
    3170:	9f 90       	pop	r9
    3172:	8f 90       	pop	r8
    3174:	7f 90       	pop	r7
    3176:	6f 90       	pop	r6
    3178:	08 95       	ret

0000317a <CRC>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
CRC(uint8_t (*GetByte)(const uint8_t*), const uint8_t *Block, uint32_t Sz)
{
    317a:	0f 93       	push	r16
    317c:	1f 93       	push	r17
	return CRC_Seed(GetByte, Block, Sz, 0xFFFF);
    317e:	0f ef       	ldi	r16, 0xFF	; 255
    3180:	1f ef       	ldi	r17, 0xFF	; 255
    3182:	0e 94 6f 18 	call	0x30de	; 0x30de <CRC_Seed>
}
    3186:	1f 91       	pop	r17
    3188:	0f 91       	pop	r16
    318a:	08 95       	ret

0000318c <CRC_Flash_calc>:

// ~~~~~~~~~~~~~~~~~
static uint16_t
CRC_Flash_calc(void)
{
    318c:	0f 93       	push	r16
    318e:	1f 93       	push	r17
	#if FLASHEND<0xFFFF
		return CRC(prb, NULL, (uint32_t)FLASHEND+1);
	#else
		return CRC_Seed(prb_f, NULL, FLASHEND-0xFFFF, CRC(prb, NULL, 0x10000));
    3190:	8d e4       	ldi	r24, 0x4D	; 77
    3192:	98 e1       	ldi	r25, 0x18	; 24
    3194:	60 e0       	ldi	r22, 0x00	; 0
    3196:	70 e0       	ldi	r23, 0x00	; 0
    3198:	20 e0       	ldi	r18, 0x00	; 0
    319a:	30 e0       	ldi	r19, 0x00	; 0
    319c:	41 e0       	ldi	r20, 0x01	; 1
    319e:	50 e0       	ldi	r21, 0x00	; 0
    31a0:	0e 94 bd 18 	call	0x317a	; 0x317a <CRC>
    31a4:	8c 01       	movw	r16, r24
    31a6:	8d e5       	ldi	r24, 0x5D	; 93
    31a8:	98 e1       	ldi	r25, 0x18	; 24
    31aa:	60 e0       	ldi	r22, 0x00	; 0
    31ac:	70 e0       	ldi	r23, 0x00	; 0
    31ae:	20 e0       	ldi	r18, 0x00	; 0
    31b0:	30 e0       	ldi	r19, 0x00	; 0
    31b2:	43 e0       	ldi	r20, 0x03	; 3
    31b4:	50 e0       	ldi	r21, 0x00	; 0
    31b6:	0e 94 6f 18 	call	0x30de	; 0x30de <CRC_Seed>
	#endif
}
    31ba:	1f 91       	pop	r17
    31bc:	0f 91       	pop	r16
    31be:	08 95       	ret

000031c0 <CRC_EEPROM_calc>:

// ~~~~~~~~~~~~~~~~~~
static uint16_t
CRC_EEPROM_calc(void)
{
    31c0:	cf 92       	push	r12
    31c2:	df 92       	push	r13
    31c4:	ef 92       	push	r14
    31c6:	ff 92       	push	r15
    31c8:	0f 93       	push	r16
    31ca:	1f 93       	push	r17
	return
    31cc:	91 e5       	ldi	r25, 0x51	; 81
    31ce:	c9 2e       	mov	r12, r25
    31d0:	9d e4       	ldi	r25, 0x4D	; 77
    31d2:	d9 2e       	mov	r13, r25
    31d4:	88 e3       	ldi	r24, 0x38	; 56
    31d6:	e8 2e       	mov	r14, r24
    31d8:	81 e0       	ldi	r24, 0x01	; 1
    31da:	f8 2e       	mov	r15, r24
    31dc:	97 01       	movw	r18, r14
    31de:	40 e0       	ldi	r20, 0x00	; 0
    31e0:	50 e0       	ldi	r21, 0x00	; 0
    31e2:	c6 01       	movw	r24, r12
    31e4:	60 e0       	ldi	r22, 0x00	; 0
    31e6:	70 e0       	ldi	r23, 0x00	; 0
    31e8:	0e 94 bd 18 	call	0x317a	; 0x317a <CRC>
    31ec:	8c 01       	movw	r16, r24
    31ee:	2b ef       	ldi	r18, 0xFB	; 251
    31f0:	3f e0       	ldi	r19, 0x0F	; 15
    31f2:	2e 19       	sub	r18, r14
    31f4:	3f 09       	sbc	r19, r15
    31f6:	40 e0       	ldi	r20, 0x00	; 0
    31f8:	50 e0       	ldi	r21, 0x00	; 0
    31fa:	c6 01       	movw	r24, r12
    31fc:	65 e0       	ldi	r22, 0x05	; 5
    31fe:	70 e0       	ldi	r23, 0x00	; 0
    3200:	e6 0e       	add	r14, r22
    3202:	f7 1e       	adc	r15, r23
    3204:	b7 01       	movw	r22, r14
    3206:	0e 94 6f 18 	call	0x30de	; 0x30de <CRC_Seed>
		CRC_Seed(erb, (uint8_t*)&MemCheck_stor+sizeof(MemCheck_stor), E2END-((uint16_t)&MemCheck_stor-1)-sizeof(MemCheck_stor),
			CRC(erb, NULL, (uint16_t)&MemCheck_stor));
}
    320a:	1f 91       	pop	r17
    320c:	0f 91       	pop	r16
    320e:	ff 90       	pop	r15
    3210:	ef 90       	pop	r14
    3212:	df 90       	pop	r13
    3214:	cf 90       	pop	r12
    3216:	08 95       	ret

00003218 <InterruInit>:
InterruInit(void)
{
	#ifdef PMIC
		PMIC.CTRL = (uint8_t)(~PMIC_RREN_bm &~PMIC_IVSEL_bm) |PMIC_HILVLEN_bm |PMIC_MEDLVLEN_bm |PMIC_LOLVLEN_bm;
	#endif
	sei();
    3218:	78 94       	sei
}
    321a:	08 95       	ret

0000321c <IntOff>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    321c:	8f b7       	in	r24, 0x3f	; 63
    321e:	80 78       	andi	r24, 0x80	; 128
    3220:	80 93 e5 02 	sts	0x02E5, r24
	cli();
    3224:	f8 94       	cli
	return interru_enub_flg;
}
    3226:	08 95       	ret

00003228 <IntOn>:

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3228:	80 91 e5 02 	lds	r24, 0x02E5
    322c:	88 23       	and	r24, r24
    322e:	09 f0       	breq	.+2      	; 0x3232 <IntOn+0xa>
		sei();
    3230:	78 94       	sei
	return interru_enub_flg;
}
    3232:	08 95       	ret

00003234 <WdtOn>:

// ~~~~~~~~
void
WdtOn(void)
{
	wdt_reset();
    3234:	a8 95       	wdr
	wdt_enable(WDTO_2S);
    3236:	2f e0       	ldi	r18, 0x0F	; 15
    3238:	88 e1       	ldi	r24, 0x18	; 24
    323a:	90 e0       	ldi	r25, 0x00	; 0
    323c:	0f b6       	in	r0, 0x3f	; 63
    323e:	f8 94       	cli
    3240:	a8 95       	wdr
    3242:	80 93 60 00 	sts	0x0060, r24
    3246:	0f be       	out	0x3f, r0	; 63
    3248:	20 93 60 00 	sts	0x0060, r18
}
    324c:	08 95       	ret

0000324e <Timer8_ISR_Alloc>:

// ~~~~~~~~~~~~~~
uint8_t
Timer8_ISR_Alloc(void)
{
	uint8_t N = VacantTimer8_ISR;
    324e:	80 91 d6 02 	lds	r24, 0x02D6
	VacantTimer8_ISR++;
    3252:	8f 5f       	subi	r24, 0xFF	; 255
    3254:	80 93 d6 02 	sts	0x02D6, r24
    3258:	81 50       	subi	r24, 0x01	; 1
	return N;
}
    325a:	08 95       	ret

0000325c <Timer8Alloc>:

uint8_t
Timer8Alloc(void)
{
	uint8_t N = VacantTimer8;
    325c:	80 91 c9 02 	lds	r24, 0x02C9
	VacantTimer8++;
    3260:	8f 5f       	subi	r24, 0xFF	; 255
    3262:	80 93 c9 02 	sts	0x02C9, r24
    3266:	81 50       	subi	r24, 0x01	; 1
	return N;
}
    3268:	08 95       	ret

0000326a <Timer16Alloc>:

// ~~~~~~~~~~~~~~~
uint8_t
Timer16Alloc(void)
{
	uint8_t N = VacantTimer16;
    326a:	80 91 ca 02 	lds	r24, 0x02CA
	VacantTimer16++;
    326e:	8f 5f       	subi	r24, 0xFF	; 255
    3270:	80 93 ca 02 	sts	0x02CA, r24
    3274:	81 50       	subi	r24, 0x01	; 1
	return N;
}
    3276:	08 95       	ret

00003278 <Timer32Alloc>:

// ~~~~~~~~~~~~~~~
uint8_t
Timer32Alloc(void)
{
	uint8_t N = VacantTimer32;
    3278:	80 91 cb 02 	lds	r24, 0x02CB
	VacantTimer32++;
    327c:	8f 5f       	subi	r24, 0xFF	; 255
    327e:	80 93 cb 02 	sts	0x02CB, r24
    3282:	81 50       	subi	r24, 0x01	; 1
	return N;
}
    3284:	08 95       	ret

00003286 <Timer8_ISR_AppAlloc>:
// ~~~~~~~~~~~~~~

uint8_t
Timer8_ISR_AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    3286:	88 23       	and	r24, r24
    3288:	39 f0       	breq	.+14     	; 0x3298 <Timer8_ISR_AppAlloc+0x12>
	uint8_t N = VacantTimer8_ISR;
    328a:	90 91 d6 02 	lds	r25, 0x02D6
	VacantTimer8_ISR+=n;
    328e:	89 0f       	add	r24, r25
    3290:	80 93 d6 02 	sts	0x02D6, r24
	return N;
}
    3294:	89 2f       	mov	r24, r25
    3296:	08 95       	ret
// ~~~~~~~~~~~~~~

uint8_t
Timer8_ISR_AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    3298:	90 e0       	ldi	r25, 0x00	; 0
	uint8_t N = VacantTimer8_ISR;
	VacantTimer8_ISR+=n;
	return N;
}
    329a:	89 2f       	mov	r24, r25
    329c:	08 95       	ret

0000329e <Timer8AppAlloc>:

uint8_t
Timer8AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    329e:	88 23       	and	r24, r24
    32a0:	39 f0       	breq	.+14     	; 0x32b0 <Timer8AppAlloc+0x12>
	uint8_t N = VacantTimer8;
    32a2:	90 91 c9 02 	lds	r25, 0x02C9
	VacantTimer8+=n;
    32a6:	89 0f       	add	r24, r25
    32a8:	80 93 c9 02 	sts	0x02C9, r24
	return N;
}
    32ac:	89 2f       	mov	r24, r25
    32ae:	08 95       	ret
}

uint8_t
Timer8AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    32b0:	90 e0       	ldi	r25, 0x00	; 0
	uint8_t N = VacantTimer8;
	VacantTimer8+=n;
	return N;
}
    32b2:	89 2f       	mov	r24, r25
    32b4:	08 95       	ret

000032b6 <Timer16AppAlloc>:

// ~~~~~~~~~~~~~~~
uint8_t
Timer16AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    32b6:	88 23       	and	r24, r24
    32b8:	39 f0       	breq	.+14     	; 0x32c8 <Timer16AppAlloc+0x12>
	uint8_t N = VacantTimer16;
    32ba:	90 91 ca 02 	lds	r25, 0x02CA
	VacantTimer16+=n;
    32be:	89 0f       	add	r24, r25
    32c0:	80 93 ca 02 	sts	0x02CA, r24
	return N;
}
    32c4:	89 2f       	mov	r24, r25
    32c6:	08 95       	ret

// ~~~~~~~~~~~~~~~
uint8_t
Timer16AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    32c8:	90 e0       	ldi	r25, 0x00	; 0
	uint8_t N = VacantTimer16;
	VacantTimer16+=n;
	return N;
}
    32ca:	89 2f       	mov	r24, r25
    32cc:	08 95       	ret

000032ce <Timer32AppAlloc>:

// ~~~~~~~~~~~~~~~
uint8_t
Timer32AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    32ce:	88 23       	and	r24, r24
    32d0:	39 f0       	breq	.+14     	; 0x32e0 <Timer32AppAlloc+0x12>
	uint8_t N = VacantTimer32;
    32d2:	90 91 cb 02 	lds	r25, 0x02CB
	VacantTimer32+=n;
    32d6:	89 0f       	add	r24, r25
    32d8:	80 93 cb 02 	sts	0x02CB, r24
	return N;
}
    32dc:	89 2f       	mov	r24, r25
    32de:	08 95       	ret

// ~~~~~~~~~~~~~~~
uint8_t
Timer32AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    32e0:	90 e0       	ldi	r25, 0x00	; 0
	uint8_t N = VacantTimer32;
	VacantTimer32+=n;
	return N;
}
    32e2:	89 2f       	mov	r24, r25
    32e4:	08 95       	ret

000032e6 <Timer8_ISR_SysAlloc>:

// ~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer8_ISR_SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys_ISR;
    32e6:	90 91 d7 02 	lds	r25, 0x02D7
	VacantTimer8Sys_ISR += n;
    32ea:	89 0f       	add	r24, r25
    32ec:	80 93 d7 02 	sts	0x02D7, r24
	return N;
}
    32f0:	89 2f       	mov	r24, r25
    32f2:	08 95       	ret

000032f4 <Timer8SysAlloc>:

uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    32f4:	90 91 cc 02 	lds	r25, 0x02CC
	VacantTimer8Sys += n;
    32f8:	89 0f       	add	r24, r25
    32fa:	80 93 cc 02 	sts	0x02CC, r24
	return N;
}
    32fe:	89 2f       	mov	r24, r25
    3300:	08 95       	ret

00003302 <Timer16SysAlloc>:

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    3302:	90 91 cd 02 	lds	r25, 0x02CD
	VacantTimer16Sys += n;
    3306:	89 0f       	add	r24, r25
    3308:	80 93 cd 02 	sts	0x02CD, r24
	return N;
}
    330c:	89 2f       	mov	r24, r25
    330e:	08 95       	ret

00003310 <Timer32SysAlloc>:

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer32SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer32Sys;
    3310:	90 91 ce 02 	lds	r25, 0x02CE
	VacantTimer32Sys += n;
    3314:	89 0f       	add	r24, r25
    3316:	80 93 ce 02 	sts	0x02CE, r24
	return N;
}
    331a:	89 2f       	mov	r24, r25
    331c:	08 95       	ret

0000331e <StartTimer8_ISR>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
StartTimer8_ISR(uint8_t TimerN, uint8_t Timeout)
{
    331e:	98 2f       	mov	r25, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3320:	3f b7       	in	r19, 0x3f	; 63
    3322:	30 78       	andi	r19, 0x80	; 128
    3324:	30 93 e5 02 	sts	0x02E5, r19
	cli();
    3328:	f8 94       	cli
	IntOff();
	if ((Timer8_ISR[TimerN]=Timeout)>0)
    332a:	48 2f       	mov	r20, r24
    332c:	50 e0       	ldi	r21, 0x00	; 0
    332e:	fa 01       	movw	r30, r20
    3330:	ea 51       	subi	r30, 0x1A	; 26
    3332:	fd 4f       	sbci	r31, 0xFD	; 253
    3334:	60 83       	st	Z, r22
    3336:	80 81       	ld	r24, Z
    3338:	88 23       	and	r24, r24
    333a:	c1 f0       	breq	.+48     	; 0x336c <StartTimer8_ISR+0x4e>
		Timer8_ISR_Flg[TimerN/8] &=~(1<<TimerN%8);
    333c:	96 95       	lsr	r25
    333e:	96 95       	lsr	r25
    3340:	96 95       	lsr	r25
    3342:	e9 2f       	mov	r30, r25
    3344:	f0 e0       	ldi	r31, 0x00	; 0
    3346:	ea 55       	subi	r30, 0x5A	; 90
    3348:	fb 4f       	sbci	r31, 0xFB	; 251
    334a:	20 81       	ld	r18, Z
    334c:	47 70       	andi	r20, 0x07	; 7
    334e:	50 70       	andi	r21, 0x00	; 0
    3350:	81 e0       	ldi	r24, 0x01	; 1
    3352:	90 e0       	ldi	r25, 0x00	; 0
    3354:	02 c0       	rjmp	.+4      	; 0x335a <StartTimer8_ISR+0x3c>
    3356:	88 0f       	add	r24, r24
    3358:	99 1f       	adc	r25, r25
    335a:	4a 95       	dec	r20
    335c:	e2 f7       	brpl	.-8      	; 0x3356 <StartTimer8_ISR+0x38>
    335e:	80 95       	com	r24
    3360:	82 23       	and	r24, r18
    3362:	80 83       	st	Z, r24

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3364:	33 23       	and	r19, r19
    3366:	09 f0       	breq	.+2      	; 0x336a <StartTimer8_ISR+0x4c>
		sei();
    3368:	78 94       	sei
    336a:	08 95       	ret
	else
		Timer8_ISR_Flg[TimerN/8] |=(1<<TimerN%8);
    336c:	96 95       	lsr	r25
    336e:	96 95       	lsr	r25
    3370:	96 95       	lsr	r25
    3372:	e9 2f       	mov	r30, r25
    3374:	f0 e0       	ldi	r31, 0x00	; 0
    3376:	ea 55       	subi	r30, 0x5A	; 90
    3378:	fb 4f       	sbci	r31, 0xFB	; 251
    337a:	20 81       	ld	r18, Z
    337c:	47 70       	andi	r20, 0x07	; 7
    337e:	50 70       	andi	r21, 0x00	; 0
    3380:	81 e0       	ldi	r24, 0x01	; 1
    3382:	90 e0       	ldi	r25, 0x00	; 0
    3384:	02 c0       	rjmp	.+4      	; 0x338a <StartTimer8_ISR+0x6c>
    3386:	88 0f       	add	r24, r24
    3388:	99 1f       	adc	r25, r25
    338a:	4a 95       	dec	r20
    338c:	e2 f7       	brpl	.-8      	; 0x3386 <StartTimer8_ISR+0x68>
    338e:	28 2b       	or	r18, r24
    3390:	20 83       	st	Z, r18
    3392:	e8 cf       	rjmp	.-48     	; 0x3364 <StartTimer8_ISR+0x46>

00003394 <StartTimer8>:
}


void
StartTimer8(uint8_t TimerN, uint8_t Timeout)
{
    3394:	98 2f       	mov	r25, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3396:	3f b7       	in	r19, 0x3f	; 63
    3398:	30 78       	andi	r19, 0x80	; 128
    339a:	30 93 e5 02 	sts	0x02E5, r19
	cli();
    339e:	f8 94       	cli
	IntOff();
	if ((Timer8[TimerN]=Timeout)>0)
    33a0:	48 2f       	mov	r20, r24
    33a2:	50 e0       	ldi	r21, 0x00	; 0
    33a4:	fa 01       	movw	r30, r20
    33a6:	e2 51       	subi	r30, 0x12	; 18
    33a8:	fd 4f       	sbci	r31, 0xFD	; 253
    33aa:	60 83       	st	Z, r22
    33ac:	80 81       	ld	r24, Z
    33ae:	88 23       	and	r24, r24
    33b0:	c1 f0       	breq	.+48     	; 0x33e2 <StartTimer8+0x4e>
		Timer8Flg[TimerN/8] &=~(1<<TimerN%8);
    33b2:	96 95       	lsr	r25
    33b4:	96 95       	lsr	r25
    33b6:	96 95       	lsr	r25
    33b8:	e9 2f       	mov	r30, r25
    33ba:	f0 e0       	ldi	r31, 0x00	; 0
    33bc:	e8 55       	subi	r30, 0x58	; 88
    33be:	fb 4f       	sbci	r31, 0xFB	; 251
    33c0:	20 81       	ld	r18, Z
    33c2:	47 70       	andi	r20, 0x07	; 7
    33c4:	50 70       	andi	r21, 0x00	; 0
    33c6:	81 e0       	ldi	r24, 0x01	; 1
    33c8:	90 e0       	ldi	r25, 0x00	; 0
    33ca:	02 c0       	rjmp	.+4      	; 0x33d0 <StartTimer8+0x3c>
    33cc:	88 0f       	add	r24, r24
    33ce:	99 1f       	adc	r25, r25
    33d0:	4a 95       	dec	r20
    33d2:	e2 f7       	brpl	.-8      	; 0x33cc <StartTimer8+0x38>
    33d4:	80 95       	com	r24
    33d6:	82 23       	and	r24, r18
    33d8:	80 83       	st	Z, r24

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    33da:	33 23       	and	r19, r19
    33dc:	09 f0       	breq	.+2      	; 0x33e0 <StartTimer8+0x4c>
		sei();
    33de:	78 94       	sei
    33e0:	08 95       	ret
	else
		Timer8Flg[TimerN/8] |=(1<<TimerN%8);
    33e2:	96 95       	lsr	r25
    33e4:	96 95       	lsr	r25
    33e6:	96 95       	lsr	r25
    33e8:	e9 2f       	mov	r30, r25
    33ea:	f0 e0       	ldi	r31, 0x00	; 0
    33ec:	e8 55       	subi	r30, 0x58	; 88
    33ee:	fb 4f       	sbci	r31, 0xFB	; 251
    33f0:	20 81       	ld	r18, Z
    33f2:	47 70       	andi	r20, 0x07	; 7
    33f4:	50 70       	andi	r21, 0x00	; 0
    33f6:	81 e0       	ldi	r24, 0x01	; 1
    33f8:	90 e0       	ldi	r25, 0x00	; 0
    33fa:	02 c0       	rjmp	.+4      	; 0x3400 <StartTimer8+0x6c>
    33fc:	88 0f       	add	r24, r24
    33fe:	99 1f       	adc	r25, r25
    3400:	4a 95       	dec	r20
    3402:	e2 f7       	brpl	.-8      	; 0x33fc <StartTimer8+0x68>
    3404:	28 2b       	or	r18, r24
    3406:	20 83       	st	Z, r18
    3408:	e8 cf       	rjmp	.-48     	; 0x33da <StartTimer8+0x46>

0000340a <StartTimer16>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
StartTimer16(uint8_t TimerN, uint16_t Timeout)
{
    340a:	28 2f       	mov	r18, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    340c:	3f b7       	in	r19, 0x3f	; 63
    340e:	30 78       	andi	r19, 0x80	; 128
    3410:	30 93 e5 02 	sts	0x02E5, r19
	cli();
    3414:	f8 94       	cli
	IntOff();
	if ((Timer16[TimerN]=Timeout)>0)
    3416:	48 2f       	mov	r20, r24
    3418:	50 e0       	ldi	r21, 0x00	; 0
    341a:	fa 01       	movw	r30, r20
    341c:	ee 0f       	add	r30, r30
    341e:	ff 1f       	adc	r31, r31
    3420:	ea 5b       	subi	r30, 0xBA	; 186
    3422:	fc 4f       	sbci	r31, 0xFC	; 252
    3424:	71 83       	std	Z+1, r23	; 0x01
    3426:	60 83       	st	Z, r22
    3428:	80 81       	ld	r24, Z
    342a:	91 81       	ldd	r25, Z+1	; 0x01
    342c:	89 2b       	or	r24, r25
    342e:	c1 f0       	breq	.+48     	; 0x3460 <StartTimer16+0x56>
		Timer16Flg[TimerN/8] &=~(1<<TimerN%8);
    3430:	26 95       	lsr	r18
    3432:	26 95       	lsr	r18
    3434:	26 95       	lsr	r18
    3436:	e2 2f       	mov	r30, r18
    3438:	f0 e0       	ldi	r31, 0x00	; 0
    343a:	ec 54       	subi	r30, 0x4C	; 76
    343c:	fb 4f       	sbci	r31, 0xFB	; 251
    343e:	20 81       	ld	r18, Z
    3440:	47 70       	andi	r20, 0x07	; 7
    3442:	50 70       	andi	r21, 0x00	; 0
    3444:	81 e0       	ldi	r24, 0x01	; 1
    3446:	90 e0       	ldi	r25, 0x00	; 0
    3448:	02 c0       	rjmp	.+4      	; 0x344e <StartTimer16+0x44>
    344a:	88 0f       	add	r24, r24
    344c:	99 1f       	adc	r25, r25
    344e:	4a 95       	dec	r20
    3450:	e2 f7       	brpl	.-8      	; 0x344a <StartTimer16+0x40>
    3452:	80 95       	com	r24
    3454:	82 23       	and	r24, r18
    3456:	80 83       	st	Z, r24

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3458:	33 23       	and	r19, r19
    345a:	09 f0       	breq	.+2      	; 0x345e <StartTimer16+0x54>
		sei();
    345c:	78 94       	sei
    345e:	08 95       	ret
	else
		Timer16Flg[TimerN/8] |=(1<<TimerN%8);
    3460:	26 95       	lsr	r18
    3462:	26 95       	lsr	r18
    3464:	26 95       	lsr	r18
    3466:	e2 2f       	mov	r30, r18
    3468:	f0 e0       	ldi	r31, 0x00	; 0
    346a:	ec 54       	subi	r30, 0x4C	; 76
    346c:	fb 4f       	sbci	r31, 0xFB	; 251
    346e:	20 81       	ld	r18, Z
    3470:	47 70       	andi	r20, 0x07	; 7
    3472:	50 70       	andi	r21, 0x00	; 0
    3474:	81 e0       	ldi	r24, 0x01	; 1
    3476:	90 e0       	ldi	r25, 0x00	; 0
    3478:	02 c0       	rjmp	.+4      	; 0x347e <StartTimer16+0x74>
    347a:	88 0f       	add	r24, r24
    347c:	99 1f       	adc	r25, r25
    347e:	4a 95       	dec	r20
    3480:	e2 f7       	brpl	.-8      	; 0x347a <StartTimer16+0x70>
    3482:	28 2b       	or	r18, r24
    3484:	20 83       	st	Z, r18
    3486:	e8 cf       	rjmp	.-48     	; 0x3458 <StartTimer16+0x4e>

00003488 <StartTimer32>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
StartTimer32(uint8_t TimerN, uint32_t Timeout)
{
    3488:	cf 93       	push	r28
    348a:	df 93       	push	r29
    348c:	28 2f       	mov	r18, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    348e:	3f b7       	in	r19, 0x3f	; 63
    3490:	30 78       	andi	r19, 0x80	; 128
    3492:	30 93 e5 02 	sts	0x02E5, r19
	cli();
    3496:	f8 94       	cli
	IntOff();
	if ((Timer32[TimerN]=Timeout)>0)
    3498:	c8 2f       	mov	r28, r24
    349a:	d0 e0       	ldi	r29, 0x00	; 0
    349c:	fe 01       	movw	r30, r28
    349e:	ee 0f       	add	r30, r30
    34a0:	ff 1f       	adc	r31, r31
    34a2:	ee 0f       	add	r30, r30
    34a4:	ff 1f       	adc	r31, r31
    34a6:	ea 5f       	subi	r30, 0xFA	; 250
    34a8:	fb 4f       	sbci	r31, 0xFB	; 251
    34aa:	40 83       	st	Z, r20
    34ac:	51 83       	std	Z+1, r21	; 0x01
    34ae:	62 83       	std	Z+2, r22	; 0x02
    34b0:	73 83       	std	Z+3, r23	; 0x03
    34b2:	80 81       	ld	r24, Z
    34b4:	91 81       	ldd	r25, Z+1	; 0x01
    34b6:	a2 81       	ldd	r26, Z+2	; 0x02
    34b8:	b3 81       	ldd	r27, Z+3	; 0x03
    34ba:	00 97       	sbiw	r24, 0x00	; 0
    34bc:	a1 05       	cpc	r26, r1
    34be:	b1 05       	cpc	r27, r1
    34c0:	d1 f0       	breq	.+52     	; 0x34f6 <StartTimer32+0x6e>
		Timer32Flg[TimerN/8] &=~(1<<TimerN%8);
    34c2:	26 95       	lsr	r18
    34c4:	26 95       	lsr	r18
    34c6:	26 95       	lsr	r18
    34c8:	e2 2f       	mov	r30, r18
    34ca:	f0 e0       	ldi	r31, 0x00	; 0
    34cc:	ef 53       	subi	r30, 0x3F	; 63
    34ce:	fb 4f       	sbci	r31, 0xFB	; 251
    34d0:	20 81       	ld	r18, Z
    34d2:	c7 70       	andi	r28, 0x07	; 7
    34d4:	d0 70       	andi	r29, 0x00	; 0
    34d6:	81 e0       	ldi	r24, 0x01	; 1
    34d8:	90 e0       	ldi	r25, 0x00	; 0
    34da:	02 c0       	rjmp	.+4      	; 0x34e0 <StartTimer32+0x58>
    34dc:	88 0f       	add	r24, r24
    34de:	99 1f       	adc	r25, r25
    34e0:	ca 95       	dec	r28
    34e2:	e2 f7       	brpl	.-8      	; 0x34dc <StartTimer32+0x54>
    34e4:	80 95       	com	r24
    34e6:	82 23       	and	r24, r18
    34e8:	80 83       	st	Z, r24

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    34ea:	33 23       	and	r19, r19
    34ec:	09 f0       	breq	.+2      	; 0x34f0 <StartTimer32+0x68>
		sei();
    34ee:	78 94       	sei
	else
		Timer32Flg[TimerN/8] |=(1<<TimerN%8);
	IntOn();
}
    34f0:	df 91       	pop	r29
    34f2:	cf 91       	pop	r28
    34f4:	08 95       	ret
{
	IntOff();
	if ((Timer32[TimerN]=Timeout)>0)
		Timer32Flg[TimerN/8] &=~(1<<TimerN%8);
	else
		Timer32Flg[TimerN/8] |=(1<<TimerN%8);
    34f6:	26 95       	lsr	r18
    34f8:	26 95       	lsr	r18
    34fa:	26 95       	lsr	r18
    34fc:	e2 2f       	mov	r30, r18
    34fe:	f0 e0       	ldi	r31, 0x00	; 0
    3500:	ef 53       	subi	r30, 0x3F	; 63
    3502:	fb 4f       	sbci	r31, 0xFB	; 251
    3504:	20 81       	ld	r18, Z
    3506:	c7 70       	andi	r28, 0x07	; 7
    3508:	d0 70       	andi	r29, 0x00	; 0
    350a:	81 e0       	ldi	r24, 0x01	; 1
    350c:	90 e0       	ldi	r25, 0x00	; 0
    350e:	02 c0       	rjmp	.+4      	; 0x3514 <StartTimer32+0x8c>
    3510:	88 0f       	add	r24, r24
    3512:	99 1f       	adc	r25, r25
    3514:	ca 95       	dec	r28
    3516:	e2 f7       	brpl	.-8      	; 0x3510 <StartTimer32+0x88>
    3518:	28 2b       	or	r18, r24
    351a:	20 83       	st	Z, r18
    351c:	e6 cf       	rjmp	.-52     	; 0x34ea <StartTimer32+0x62>

0000351e <StopTimer8_ISR>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    351e:	4f b7       	in	r20, 0x3f	; 63
    3520:	40 78       	andi	r20, 0x80	; 128
    3522:	40 93 e5 02 	sts	0x02E5, r20
	cli();
    3526:	f8 94       	cli
// ~~~~~~~~~~~~~~~~~~~~~~~
void
StopTimer8_ISR(uint8_t TimerN)
{
	IntOff();
	Timer8_ISR_Flg[TimerN/8] |=(1<<TimerN%8);
    3528:	e8 2f       	mov	r30, r24
    352a:	e6 95       	lsr	r30
    352c:	e6 95       	lsr	r30
    352e:	e6 95       	lsr	r30
    3530:	f0 e0       	ldi	r31, 0x00	; 0
    3532:	ea 55       	subi	r30, 0x5A	; 90
    3534:	fb 4f       	sbci	r31, 0xFB	; 251
    3536:	90 81       	ld	r25, Z
    3538:	87 70       	andi	r24, 0x07	; 7
    353a:	21 e0       	ldi	r18, 0x01	; 1
    353c:	30 e0       	ldi	r19, 0x00	; 0
    353e:	02 c0       	rjmp	.+4      	; 0x3544 <StopTimer8_ISR+0x26>
    3540:	22 0f       	add	r18, r18
    3542:	33 1f       	adc	r19, r19
    3544:	8a 95       	dec	r24
    3546:	e2 f7       	brpl	.-8      	; 0x3540 <StopTimer8_ISR+0x22>
    3548:	92 2b       	or	r25, r18
    354a:	90 83       	st	Z, r25

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    354c:	44 23       	and	r20, r20
    354e:	09 f0       	breq	.+2      	; 0x3552 <StopTimer8_ISR+0x34>
		sei();
    3550:	78 94       	sei
    3552:	08 95       	ret

00003554 <StopTimer8>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3554:	4f b7       	in	r20, 0x3f	; 63
    3556:	40 78       	andi	r20, 0x80	; 128
    3558:	40 93 e5 02 	sts	0x02E5, r20
	cli();
    355c:	f8 94       	cli

void
StopTimer8(uint8_t TimerN)
{
	IntOff();
	Timer8Flg[TimerN/8] |=(1<<TimerN%8);
    355e:	e8 2f       	mov	r30, r24
    3560:	e6 95       	lsr	r30
    3562:	e6 95       	lsr	r30
    3564:	e6 95       	lsr	r30
    3566:	f0 e0       	ldi	r31, 0x00	; 0
    3568:	e8 55       	subi	r30, 0x58	; 88
    356a:	fb 4f       	sbci	r31, 0xFB	; 251
    356c:	90 81       	ld	r25, Z
    356e:	87 70       	andi	r24, 0x07	; 7
    3570:	21 e0       	ldi	r18, 0x01	; 1
    3572:	30 e0       	ldi	r19, 0x00	; 0
    3574:	02 c0       	rjmp	.+4      	; 0x357a <StopTimer8+0x26>
    3576:	22 0f       	add	r18, r18
    3578:	33 1f       	adc	r19, r19
    357a:	8a 95       	dec	r24
    357c:	e2 f7       	brpl	.-8      	; 0x3576 <StopTimer8+0x22>
    357e:	92 2b       	or	r25, r18
    3580:	90 83       	st	Z, r25

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3582:	44 23       	and	r20, r20
    3584:	09 f0       	breq	.+2      	; 0x3588 <StopTimer8+0x34>
		sei();
    3586:	78 94       	sei
    3588:	08 95       	ret

0000358a <StopTimer16>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    358a:	4f b7       	in	r20, 0x3f	; 63
    358c:	40 78       	andi	r20, 0x80	; 128
    358e:	40 93 e5 02 	sts	0x02E5, r20
	cli();
    3592:	f8 94       	cli
// ~~~~~~~~~~~~~~~~~~~~~~~~
void
StopTimer16(uint8_t TimerN)
{
	IntOff();
	Timer16Flg[TimerN/8] |=1<<TimerN%8;
    3594:	e8 2f       	mov	r30, r24
    3596:	e6 95       	lsr	r30
    3598:	e6 95       	lsr	r30
    359a:	e6 95       	lsr	r30
    359c:	f0 e0       	ldi	r31, 0x00	; 0
    359e:	ec 54       	subi	r30, 0x4C	; 76
    35a0:	fb 4f       	sbci	r31, 0xFB	; 251
    35a2:	90 81       	ld	r25, Z
    35a4:	87 70       	andi	r24, 0x07	; 7
    35a6:	21 e0       	ldi	r18, 0x01	; 1
    35a8:	30 e0       	ldi	r19, 0x00	; 0
    35aa:	02 c0       	rjmp	.+4      	; 0x35b0 <StopTimer16+0x26>
    35ac:	22 0f       	add	r18, r18
    35ae:	33 1f       	adc	r19, r19
    35b0:	8a 95       	dec	r24
    35b2:	e2 f7       	brpl	.-8      	; 0x35ac <StopTimer16+0x22>
    35b4:	92 2b       	or	r25, r18
    35b6:	90 83       	st	Z, r25

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    35b8:	44 23       	and	r20, r20
    35ba:	09 f0       	breq	.+2      	; 0x35be <StopTimer16+0x34>
		sei();
    35bc:	78 94       	sei
    35be:	08 95       	ret

000035c0 <StopTimer32>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    35c0:	4f b7       	in	r20, 0x3f	; 63
    35c2:	40 78       	andi	r20, 0x80	; 128
    35c4:	40 93 e5 02 	sts	0x02E5, r20
	cli();
    35c8:	f8 94       	cli
// ~~~~~~~~~~~~~~~~~~~~~~~~
void
StopTimer32(uint8_t TimerN)
{
	IntOff();
	Timer32Flg[TimerN/8] |=1<<TimerN%8;
    35ca:	e8 2f       	mov	r30, r24
    35cc:	e6 95       	lsr	r30
    35ce:	e6 95       	lsr	r30
    35d0:	e6 95       	lsr	r30
    35d2:	f0 e0       	ldi	r31, 0x00	; 0
    35d4:	ef 53       	subi	r30, 0x3F	; 63
    35d6:	fb 4f       	sbci	r31, 0xFB	; 251
    35d8:	90 81       	ld	r25, Z
    35da:	87 70       	andi	r24, 0x07	; 7
    35dc:	21 e0       	ldi	r18, 0x01	; 1
    35de:	30 e0       	ldi	r19, 0x00	; 0
    35e0:	02 c0       	rjmp	.+4      	; 0x35e6 <StopTimer32+0x26>
    35e2:	22 0f       	add	r18, r18
    35e4:	33 1f       	adc	r19, r19
    35e6:	8a 95       	dec	r24
    35e8:	e2 f7       	brpl	.-8      	; 0x35e2 <StopTimer32+0x22>
    35ea:	92 2b       	or	r25, r18
    35ec:	90 83       	st	Z, r25

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    35ee:	44 23       	and	r20, r20
    35f0:	09 f0       	breq	.+2      	; 0x35f4 <StopTimer32+0x34>
		sei();
    35f2:	78 94       	sei
    35f4:	08 95       	ret

000035f6 <Timer8Stopp_ISR>:
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer8Stopp_ISR(uint8_t TimerN)
{
	return (Timer8_ISR_Flg[TimerN/8] &(1<<TimerN%8)) && Timer8_ISR[TimerN]==0;
    35f6:	e8 2f       	mov	r30, r24
    35f8:	e6 95       	lsr	r30
    35fa:	e6 95       	lsr	r30
    35fc:	e6 95       	lsr	r30
    35fe:	f0 e0       	ldi	r31, 0x00	; 0
    3600:	ea 55       	subi	r30, 0x5A	; 90
    3602:	fb 4f       	sbci	r31, 0xFB	; 251
    3604:	20 81       	ld	r18, Z
    3606:	e8 2f       	mov	r30, r24
    3608:	f0 e0       	ldi	r31, 0x00	; 0
    360a:	30 e0       	ldi	r19, 0x00	; 0
    360c:	cf 01       	movw	r24, r30
    360e:	87 70       	andi	r24, 0x07	; 7
    3610:	90 70       	andi	r25, 0x00	; 0
    3612:	02 c0       	rjmp	.+4      	; 0x3618 <Timer8Stopp_ISR+0x22>
    3614:	35 95       	asr	r19
    3616:	27 95       	ror	r18
    3618:	8a 95       	dec	r24
    361a:	e2 f7       	brpl	.-8      	; 0x3614 <Timer8Stopp_ISR+0x1e>
    361c:	20 fd       	sbrc	r18, 0
    361e:	02 c0       	rjmp	.+4      	; 0x3624 <Timer8Stopp_ISR+0x2e>
    3620:	80 e0       	ldi	r24, 0x00	; 0
    3622:	08 95       	ret
    3624:	ea 51       	subi	r30, 0x1A	; 26
    3626:	fd 4f       	sbci	r31, 0xFD	; 253
    3628:	90 81       	ld	r25, Z
    362a:	99 23       	and	r25, r25
    362c:	19 f4       	brne	.+6      	; 0x3634 <Timer8Stopp_ISR+0x3e>
    362e:	81 e0       	ldi	r24, 0x01	; 1
    3630:	89 27       	eor	r24, r25
}
    3632:	08 95       	ret
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer8Stopp_ISR(uint8_t TimerN)
{
	return (Timer8_ISR_Flg[TimerN/8] &(1<<TimerN%8)) && Timer8_ISR[TimerN]==0;
    3634:	91 e0       	ldi	r25, 0x01	; 1
    3636:	81 e0       	ldi	r24, 0x01	; 1
    3638:	89 27       	eor	r24, r25
}
    363a:	08 95       	ret

0000363c <Timer8Stopp>:

// ~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer8Stopp(uint8_t TimerN)
{
	return (Timer8Flg[TimerN/8] &(1<<TimerN%8)) && Timer8[TimerN]==0;
    363c:	e8 2f       	mov	r30, r24
    363e:	e6 95       	lsr	r30
    3640:	e6 95       	lsr	r30
    3642:	e6 95       	lsr	r30
    3644:	f0 e0       	ldi	r31, 0x00	; 0
    3646:	e8 55       	subi	r30, 0x58	; 88
    3648:	fb 4f       	sbci	r31, 0xFB	; 251
    364a:	20 81       	ld	r18, Z
    364c:	e8 2f       	mov	r30, r24
    364e:	f0 e0       	ldi	r31, 0x00	; 0
    3650:	30 e0       	ldi	r19, 0x00	; 0
    3652:	cf 01       	movw	r24, r30
    3654:	87 70       	andi	r24, 0x07	; 7
    3656:	90 70       	andi	r25, 0x00	; 0
    3658:	02 c0       	rjmp	.+4      	; 0x365e <Timer8Stopp+0x22>
    365a:	35 95       	asr	r19
    365c:	27 95       	ror	r18
    365e:	8a 95       	dec	r24
    3660:	e2 f7       	brpl	.-8      	; 0x365a <Timer8Stopp+0x1e>
    3662:	20 fd       	sbrc	r18, 0
    3664:	02 c0       	rjmp	.+4      	; 0x366a <Timer8Stopp+0x2e>
    3666:	80 e0       	ldi	r24, 0x00	; 0
    3668:	08 95       	ret
    366a:	e2 51       	subi	r30, 0x12	; 18
    366c:	fd 4f       	sbci	r31, 0xFD	; 253
    366e:	90 81       	ld	r25, Z
    3670:	99 23       	and	r25, r25
    3672:	19 f4       	brne	.+6      	; 0x367a <Timer8Stopp+0x3e>
    3674:	81 e0       	ldi	r24, 0x01	; 1
    3676:	89 27       	eor	r24, r25
}
    3678:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer8Stopp(uint8_t TimerN)
{
	return (Timer8Flg[TimerN/8] &(1<<TimerN%8)) && Timer8[TimerN]==0;
    367a:	91 e0       	ldi	r25, 0x01	; 1
    367c:	81 e0       	ldi	r24, 0x01	; 1
    367e:	89 27       	eor	r24, r25
}
    3680:	08 95       	ret

00003682 <Timer16Stopp>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3682:	4f b7       	in	r20, 0x3f	; 63
    3684:	40 78       	andi	r20, 0x80	; 128
    3686:	40 93 e5 02 	sts	0x02E5, r20
	cli();
    368a:	f8 94       	cli
// ~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16Stopp(uint8_t TimerN)
{
	IntOff();
	uint8_t T_S = (Timer16Flg[TimerN/8] &(1<<TimerN%8)) && Timer16[TimerN]==0;
    368c:	e8 2f       	mov	r30, r24
    368e:	e6 95       	lsr	r30
    3690:	e6 95       	lsr	r30
    3692:	e6 95       	lsr	r30
    3694:	f0 e0       	ldi	r31, 0x00	; 0
    3696:	ec 54       	subi	r30, 0x4C	; 76
    3698:	fb 4f       	sbci	r31, 0xFB	; 251
    369a:	20 81       	ld	r18, Z
    369c:	e8 2f       	mov	r30, r24
    369e:	f0 e0       	ldi	r31, 0x00	; 0
    36a0:	30 e0       	ldi	r19, 0x00	; 0
    36a2:	cf 01       	movw	r24, r30
    36a4:	87 70       	andi	r24, 0x07	; 7
    36a6:	90 70       	andi	r25, 0x00	; 0
    36a8:	02 c0       	rjmp	.+4      	; 0x36ae <Timer16Stopp+0x2c>
    36aa:	35 95       	asr	r19
    36ac:	27 95       	ror	r18
    36ae:	8a 95       	dec	r24
    36b0:	e2 f7       	brpl	.-8      	; 0x36aa <Timer16Stopp+0x28>
    36b2:	20 fd       	sbrc	r18, 0
    36b4:	06 c0       	rjmp	.+12     	; 0x36c2 <Timer16Stopp+0x40>
    36b6:	20 e0       	ldi	r18, 0x00	; 0

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    36b8:	44 23       	and	r20, r20
    36ba:	09 f0       	breq	.+2      	; 0x36be <Timer16Stopp+0x3c>
		sei();
    36bc:	78 94       	sei
	IntOn();
	return T_S;
}
    36be:	82 2f       	mov	r24, r18
    36c0:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16Stopp(uint8_t TimerN)
{
	IntOff();
	uint8_t T_S = (Timer16Flg[TimerN/8] &(1<<TimerN%8)) && Timer16[TimerN]==0;
    36c2:	ee 0f       	add	r30, r30
    36c4:	ff 1f       	adc	r31, r31
    36c6:	ea 5b       	subi	r30, 0xBA	; 186
    36c8:	fc 4f       	sbci	r31, 0xFC	; 252
    36ca:	80 81       	ld	r24, Z
    36cc:	91 81       	ldd	r25, Z+1	; 0x01
    36ce:	20 e0       	ldi	r18, 0x00	; 0
    36d0:	89 2b       	or	r24, r25
    36d2:	19 f4       	brne	.+6      	; 0x36da <Timer16Stopp+0x58>
    36d4:	81 e0       	ldi	r24, 0x01	; 1
    36d6:	28 27       	eor	r18, r24
    36d8:	ef cf       	rjmp	.-34     	; 0x36b8 <Timer16Stopp+0x36>
    36da:	21 e0       	ldi	r18, 0x01	; 1
    36dc:	81 e0       	ldi	r24, 0x01	; 1
    36de:	28 27       	eor	r18, r24
    36e0:	eb cf       	rjmp	.-42     	; 0x36b8 <Timer16Stopp+0x36>

000036e2 <Timer32Stopp>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    36e2:	4f b7       	in	r20, 0x3f	; 63
    36e4:	40 78       	andi	r20, 0x80	; 128
    36e6:	40 93 e5 02 	sts	0x02E5, r20
	cli();
    36ea:	f8 94       	cli
// ~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer32Stopp(uint8_t TimerN)
{
	IntOff();
	uint8_t T_S = (Timer32Flg[TimerN/8] &(1<<TimerN%8)) && Timer32[TimerN]==0;
    36ec:	e8 2f       	mov	r30, r24
    36ee:	e6 95       	lsr	r30
    36f0:	e6 95       	lsr	r30
    36f2:	e6 95       	lsr	r30
    36f4:	f0 e0       	ldi	r31, 0x00	; 0
    36f6:	ef 53       	subi	r30, 0x3F	; 63
    36f8:	fb 4f       	sbci	r31, 0xFB	; 251
    36fa:	20 81       	ld	r18, Z
    36fc:	e8 2f       	mov	r30, r24
    36fe:	f0 e0       	ldi	r31, 0x00	; 0
    3700:	30 e0       	ldi	r19, 0x00	; 0
    3702:	cf 01       	movw	r24, r30
    3704:	87 70       	andi	r24, 0x07	; 7
    3706:	90 70       	andi	r25, 0x00	; 0
    3708:	02 c0       	rjmp	.+4      	; 0x370e <Timer32Stopp+0x2c>
    370a:	35 95       	asr	r19
    370c:	27 95       	ror	r18
    370e:	8a 95       	dec	r24
    3710:	e2 f7       	brpl	.-8      	; 0x370a <Timer32Stopp+0x28>
    3712:	20 fd       	sbrc	r18, 0
    3714:	06 c0       	rjmp	.+12     	; 0x3722 <Timer32Stopp+0x40>
    3716:	20 e0       	ldi	r18, 0x00	; 0

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3718:	44 23       	and	r20, r20
    371a:	09 f0       	breq	.+2      	; 0x371e <Timer32Stopp+0x3c>
		sei();
    371c:	78 94       	sei
	IntOn();
	return T_S;
}
    371e:	82 2f       	mov	r24, r18
    3720:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer32Stopp(uint8_t TimerN)
{
	IntOff();
	uint8_t T_S = (Timer32Flg[TimerN/8] &(1<<TimerN%8)) && Timer32[TimerN]==0;
    3722:	ee 0f       	add	r30, r30
    3724:	ff 1f       	adc	r31, r31
    3726:	ee 0f       	add	r30, r30
    3728:	ff 1f       	adc	r31, r31
    372a:	ea 5f       	subi	r30, 0xFA	; 250
    372c:	fb 4f       	sbci	r31, 0xFB	; 251
    372e:	80 81       	ld	r24, Z
    3730:	91 81       	ldd	r25, Z+1	; 0x01
    3732:	a2 81       	ldd	r26, Z+2	; 0x02
    3734:	b3 81       	ldd	r27, Z+3	; 0x03
    3736:	20 e0       	ldi	r18, 0x00	; 0
    3738:	00 97       	sbiw	r24, 0x00	; 0
    373a:	a1 05       	cpc	r26, r1
    373c:	b1 05       	cpc	r27, r1
    373e:	19 f4       	brne	.+6      	; 0x3746 <Timer32Stopp+0x64>
    3740:	81 e0       	ldi	r24, 0x01	; 1
    3742:	28 27       	eor	r18, r24
    3744:	e9 cf       	rjmp	.-46     	; 0x3718 <Timer32Stopp+0x36>
    3746:	21 e0       	ldi	r18, 0x01	; 1
    3748:	81 e0       	ldi	r24, 0x01	; 1
    374a:	28 27       	eor	r18, r24
    374c:	e5 cf       	rjmp	.-54     	; 0x3718 <Timer32Stopp+0x36>

0000374e <ResetTimer8_ISR>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    374e:	5f b7       	in	r21, 0x3f	; 63
    3750:	50 78       	andi	r21, 0x80	; 128
    3752:	50 93 e5 02 	sts	0x02E5, r21
	cli();
    3756:	f8 94       	cli
//~~~~~~~~~~~~~~~~~~~~~~~~~
void
ResetTimer8_ISR(uint8_t TimerN)
{
	IntOff();
	Timer8_ISR_Flg[TimerN/8] |=(1<<TimerN%8);
    3758:	e8 2f       	mov	r30, r24
    375a:	e6 95       	lsr	r30
    375c:	e6 95       	lsr	r30
    375e:	e6 95       	lsr	r30
    3760:	f0 e0       	ldi	r31, 0x00	; 0
    3762:	ea 55       	subi	r30, 0x5A	; 90
    3764:	fb 4f       	sbci	r31, 0xFB	; 251
    3766:	40 81       	ld	r20, Z
    3768:	a8 2f       	mov	r26, r24
    376a:	b0 e0       	ldi	r27, 0x00	; 0
    376c:	9d 01       	movw	r18, r26
    376e:	27 70       	andi	r18, 0x07	; 7
    3770:	30 70       	andi	r19, 0x00	; 0
    3772:	81 e0       	ldi	r24, 0x01	; 1
    3774:	90 e0       	ldi	r25, 0x00	; 0
    3776:	02 c0       	rjmp	.+4      	; 0x377c <ResetTimer8_ISR+0x2e>
    3778:	88 0f       	add	r24, r24
    377a:	99 1f       	adc	r25, r25
    377c:	2a 95       	dec	r18
    377e:	e2 f7       	brpl	.-8      	; 0x3778 <ResetTimer8_ISR+0x2a>
    3780:	48 2b       	or	r20, r24
    3782:	40 83       	st	Z, r20

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3784:	55 23       	and	r21, r21
    3786:	09 f0       	breq	.+2      	; 0x378a <ResetTimer8_ISR+0x3c>
		sei();
    3788:	78 94       	sei
	IntOn();
	Timer8_ISR[TimerN] = 0;
    378a:	aa 51       	subi	r26, 0x1A	; 26
    378c:	bd 4f       	sbci	r27, 0xFD	; 253
    378e:	1c 92       	st	X, r1
}
    3790:	08 95       	ret

00003792 <ResetTimer8>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3792:	5f b7       	in	r21, 0x3f	; 63
    3794:	50 78       	andi	r21, 0x80	; 128
    3796:	50 93 e5 02 	sts	0x02E5, r21
	cli();
    379a:	f8 94       	cli

void
ResetTimer8(uint8_t TimerN)
{
	IntOff();
	Timer8Flg[TimerN/8] |=(1<<TimerN%8);
    379c:	e8 2f       	mov	r30, r24
    379e:	e6 95       	lsr	r30
    37a0:	e6 95       	lsr	r30
    37a2:	e6 95       	lsr	r30
    37a4:	f0 e0       	ldi	r31, 0x00	; 0
    37a6:	e8 55       	subi	r30, 0x58	; 88
    37a8:	fb 4f       	sbci	r31, 0xFB	; 251
    37aa:	40 81       	ld	r20, Z
    37ac:	a8 2f       	mov	r26, r24
    37ae:	b0 e0       	ldi	r27, 0x00	; 0
    37b0:	9d 01       	movw	r18, r26
    37b2:	27 70       	andi	r18, 0x07	; 7
    37b4:	30 70       	andi	r19, 0x00	; 0
    37b6:	81 e0       	ldi	r24, 0x01	; 1
    37b8:	90 e0       	ldi	r25, 0x00	; 0
    37ba:	02 c0       	rjmp	.+4      	; 0x37c0 <ResetTimer8+0x2e>
    37bc:	88 0f       	add	r24, r24
    37be:	99 1f       	adc	r25, r25
    37c0:	2a 95       	dec	r18
    37c2:	e2 f7       	brpl	.-8      	; 0x37bc <ResetTimer8+0x2a>
    37c4:	48 2b       	or	r20, r24
    37c6:	40 83       	st	Z, r20

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    37c8:	55 23       	and	r21, r21
    37ca:	09 f0       	breq	.+2      	; 0x37ce <ResetTimer8+0x3c>
		sei();
    37cc:	78 94       	sei
	IntOn();
	Timer8[TimerN] = 0;
    37ce:	a2 51       	subi	r26, 0x12	; 18
    37d0:	bd 4f       	sbci	r27, 0xFD	; 253
    37d2:	1c 92       	st	X, r1
}
    37d4:	08 95       	ret

000037d6 <ResetTimer16>:

//~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ResetTimer16(uint8_t TimerN)
{
    37d6:	e8 2f       	mov	r30, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    37d8:	5f b7       	in	r21, 0x3f	; 63
    37da:	50 78       	andi	r21, 0x80	; 128
    37dc:	50 93 e5 02 	sts	0x02E5, r21
	cli();
    37e0:	f8 94       	cli
	IntOff();
	Timer16Flg[TimerN/8] |=1<<TimerN%8;
    37e2:	a8 2f       	mov	r26, r24
    37e4:	a6 95       	lsr	r26
    37e6:	a6 95       	lsr	r26
    37e8:	a6 95       	lsr	r26
    37ea:	b0 e0       	ldi	r27, 0x00	; 0
    37ec:	ac 54       	subi	r26, 0x4C	; 76
    37ee:	bb 4f       	sbci	r27, 0xFB	; 251
    37f0:	4c 91       	ld	r20, X
    37f2:	f0 e0       	ldi	r31, 0x00	; 0
    37f4:	9f 01       	movw	r18, r30
    37f6:	27 70       	andi	r18, 0x07	; 7
    37f8:	30 70       	andi	r19, 0x00	; 0
    37fa:	81 e0       	ldi	r24, 0x01	; 1
    37fc:	90 e0       	ldi	r25, 0x00	; 0
    37fe:	02 c0       	rjmp	.+4      	; 0x3804 <ResetTimer16+0x2e>
    3800:	88 0f       	add	r24, r24
    3802:	99 1f       	adc	r25, r25
    3804:	2a 95       	dec	r18
    3806:	e2 f7       	brpl	.-8      	; 0x3800 <ResetTimer16+0x2a>
    3808:	48 2b       	or	r20, r24
    380a:	4c 93       	st	X, r20
	Timer16[TimerN] = 0;
    380c:	ee 0f       	add	r30, r30
    380e:	ff 1f       	adc	r31, r31
    3810:	ea 5b       	subi	r30, 0xBA	; 186
    3812:	fc 4f       	sbci	r31, 0xFC	; 252
    3814:	11 82       	std	Z+1, r1	; 0x01
    3816:	10 82       	st	Z, r1

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3818:	55 23       	and	r21, r21
    381a:	09 f0       	breq	.+2      	; 0x381e <ResetTimer16+0x48>
		sei();
    381c:	78 94       	sei
    381e:	08 95       	ret

00003820 <ResetTimer32>:
}

//~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ResetTimer32(uint8_t TimerN)
{
    3820:	e8 2f       	mov	r30, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3822:	5f b7       	in	r21, 0x3f	; 63
    3824:	50 78       	andi	r21, 0x80	; 128
    3826:	50 93 e5 02 	sts	0x02E5, r21
	cli();
    382a:	f8 94       	cli
	IntOff();
	Timer32Flg[TimerN/8] |=1<<TimerN%8;
    382c:	a8 2f       	mov	r26, r24
    382e:	a6 95       	lsr	r26
    3830:	a6 95       	lsr	r26
    3832:	a6 95       	lsr	r26
    3834:	b0 e0       	ldi	r27, 0x00	; 0
    3836:	af 53       	subi	r26, 0x3F	; 63
    3838:	bb 4f       	sbci	r27, 0xFB	; 251
    383a:	4c 91       	ld	r20, X
    383c:	f0 e0       	ldi	r31, 0x00	; 0
    383e:	9f 01       	movw	r18, r30
    3840:	27 70       	andi	r18, 0x07	; 7
    3842:	30 70       	andi	r19, 0x00	; 0
    3844:	81 e0       	ldi	r24, 0x01	; 1
    3846:	90 e0       	ldi	r25, 0x00	; 0
    3848:	02 c0       	rjmp	.+4      	; 0x384e <ResetTimer32+0x2e>
    384a:	88 0f       	add	r24, r24
    384c:	99 1f       	adc	r25, r25
    384e:	2a 95       	dec	r18
    3850:	e2 f7       	brpl	.-8      	; 0x384a <ResetTimer32+0x2a>
    3852:	48 2b       	or	r20, r24
    3854:	4c 93       	st	X, r20
	Timer32[TimerN] = 0;
    3856:	ee 0f       	add	r30, r30
    3858:	ff 1f       	adc	r31, r31
    385a:	ee 0f       	add	r30, r30
    385c:	ff 1f       	adc	r31, r31
    385e:	ea 5f       	subi	r30, 0xFA	; 250
    3860:	fb 4f       	sbci	r31, 0xFB	; 251
    3862:	10 82       	st	Z, r1
    3864:	11 82       	std	Z+1, r1	; 0x01
    3866:	12 82       	std	Z+2, r1	; 0x02
    3868:	13 82       	std	Z+3, r1	; 0x03

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    386a:	55 23       	and	r21, r21
    386c:	09 f0       	breq	.+2      	; 0x3870 <ResetTimer32+0x50>
		sei();
    386e:	78 94       	sei
    3870:	08 95       	ret

00003872 <GetTimer8_ISR>:

// ~~~~~~~~~~~~~~~~~~~~~~
uint8_t
GetTimer8_ISR(uint8_t TimerN)
{
	return Timer8_ISR[TimerN];
    3872:	e6 ee       	ldi	r30, 0xE6	; 230
    3874:	f2 e0       	ldi	r31, 0x02	; 2
    3876:	e8 0f       	add	r30, r24
    3878:	f1 1d       	adc	r31, r1
    387a:	80 81       	ld	r24, Z
}
    387c:	08 95       	ret

0000387e <GetTimer8>:
uint8_t
GetTimer8(uint8_t TimerN)
{
	return Timer8[TimerN];
    387e:	ee ee       	ldi	r30, 0xEE	; 238
    3880:	f2 e0       	ldi	r31, 0x02	; 2
    3882:	e8 0f       	add	r30, r24
    3884:	f1 1d       	adc	r31, r1
    3886:	80 81       	ld	r24, Z
}
    3888:	08 95       	ret

0000388a <GetTimer16>:

// ~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
GetTimer16(uint8_t TimerN)
{
    388a:	e8 2f       	mov	r30, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    388c:	8f b7       	in	r24, 0x3f	; 63
    388e:	80 78       	andi	r24, 0x80	; 128
    3890:	80 93 e5 02 	sts	0x02E5, r24
	cli();
    3894:	f8 94       	cli
	IntOff();
	uint16_t Time = Timer16[TimerN];
    3896:	f0 e0       	ldi	r31, 0x00	; 0
    3898:	ee 0f       	add	r30, r30
    389a:	ff 1f       	adc	r31, r31
    389c:	ea 5b       	subi	r30, 0xBA	; 186
    389e:	fc 4f       	sbci	r31, 0xFC	; 252
    38a0:	01 90       	ld	r0, Z+
    38a2:	f0 81       	ld	r31, Z
    38a4:	e0 2d       	mov	r30, r0

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    38a6:	88 23       	and	r24, r24
    38a8:	09 f0       	breq	.+2      	; 0x38ac <GetTimer16+0x22>
		sei();
    38aa:	78 94       	sei
	IntOn();
	return Time;
}
    38ac:	cf 01       	movw	r24, r30
    38ae:	08 95       	ret

000038b0 <GetTimer32>:

// ~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
GetTimer32(uint8_t TimerN)
{
    38b0:	e8 2f       	mov	r30, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    38b2:	8f b7       	in	r24, 0x3f	; 63
    38b4:	80 78       	andi	r24, 0x80	; 128
    38b6:	80 93 e5 02 	sts	0x02E5, r24
	cli();
    38ba:	f8 94       	cli
	IntOff();
	uint32_t Time = Timer32[TimerN];
    38bc:	f0 e0       	ldi	r31, 0x00	; 0
    38be:	ee 0f       	add	r30, r30
    38c0:	ff 1f       	adc	r31, r31
    38c2:	ee 0f       	add	r30, r30
    38c4:	ff 1f       	adc	r31, r31
    38c6:	ea 5f       	subi	r30, 0xFA	; 250
    38c8:	fb 4f       	sbci	r31, 0xFB	; 251
    38ca:	20 81       	ld	r18, Z
    38cc:	31 81       	ldd	r19, Z+1	; 0x01
    38ce:	42 81       	ldd	r20, Z+2	; 0x02
    38d0:	53 81       	ldd	r21, Z+3	; 0x03

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    38d2:	88 23       	and	r24, r24
    38d4:	09 f0       	breq	.+2      	; 0x38d8 <GetTimer32+0x28>
		sei();
    38d6:	78 94       	sei
	IntOn();
	return Time;
}
    38d8:	b9 01       	movw	r22, r18
    38da:	ca 01       	movw	r24, r20
    38dc:	08 95       	ret

000038de <TimerAllocError>:
// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t TimerAllocError(void){
	return ( (VacantTimer8Sys >=  Timer8TotNumber) || (VacantTimer16Sys >=  Timer16TotNumber) || (VacantTimer32Sys >=  Timer32TotNumber) ||
    38de:	80 91 cc 02 	lds	r24, 0x02CC
    38e2:	88 35       	cpi	r24, 0x58	; 88
    38e4:	a8 f4       	brcc	.+42     	; 0x3910 <TimerAllocError+0x32>
    38e6:	80 91 cd 02 	lds	r24, 0x02CD
    38ea:	80 36       	cpi	r24, 0x60	; 96
    38ec:	88 f4       	brcc	.+34     	; 0x3910 <TimerAllocError+0x32>
    38ee:	80 91 ce 02 	lds	r24, 0x02CE
    38f2:	88 32       	cpi	r24, 0x28	; 40
    38f4:	68 f4       	brcc	.+26     	; 0x3910 <TimerAllocError+0x32>
    38f6:	80 91 c9 02 	lds	r24, 0x02C9
    38fa:	80 34       	cpi	r24, 0x40	; 64
    38fc:	48 f4       	brcc	.+18     	; 0x3910 <TimerAllocError+0x32>
    38fe:	80 91 ca 02 	lds	r24, 0x02CA
    3902:	88 34       	cpi	r24, 0x48	; 72
    3904:	28 f4       	brcc	.+10     	; 0x3910 <TimerAllocError+0x32>
    3906:	90 e0       	ldi	r25, 0x00	; 0
    3908:	80 91 cb 02 	lds	r24, 0x02CB
    390c:	80 32       	cpi	r24, 0x20	; 32
    390e:	08 f0       	brcs	.+2      	; 0x3912 <TimerAllocError+0x34>
    3910:	91 e0       	ldi	r25, 0x01	; 1
		 Timer8AllocErr() || Timer16AllocErr() || Timer32AllocErr() );
}
    3912:	89 2f       	mov	r24, r25
    3914:	08 95       	ret

00003916 <ScanCycleInit>:
}

uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    3916:	80 91 cc 02 	lds	r24, 0x02CC
	VacantTimer8Sys += n;
    391a:	8f 5f       	subi	r24, 0xFF	; 255
    391c:	80 93 cc 02 	sts	0x02CC, r24
    3920:	81 50       	subi	r24, 0x01	; 1

// ~~~~~~~~~~~~~~~~
void
ScanCycleInit(void)
{
	TD_Scan = Timer8SysAlloc(1);
    3922:	80 93 c7 04 	sts	0x04C7, r24
	StartTimer8(TD_Scan, 0xFF);
    3926:	6f ef       	ldi	r22, 0xFF	; 255
    3928:	0e 94 ca 19 	call	0x3394	; 0x3394 <StartTimer8>
}
    392c:	08 95       	ret

0000392e <__vector_17>:
#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
	ISR(TIMER1_COMPA_vect)
#elif defined (__AVR_ATxmega128A1__)
	ISR(TCC0_OVF_vect)
#endif
{
    392e:	1f 92       	push	r1
    3930:	0f 92       	push	r0
    3932:	0f b6       	in	r0, 0x3f	; 63
    3934:	0f 92       	push	r0
    3936:	0b b6       	in	r0, 0x3b	; 59
    3938:	0f 92       	push	r0
    393a:	11 24       	eor	r1, r1
    393c:	2f 93       	push	r18
    393e:	4f 93       	push	r20
    3940:	5f 93       	push	r21
    3942:	6f 93       	push	r22
    3944:	7f 93       	push	r23
    3946:	8f 93       	push	r24
    3948:	9f 93       	push	r25
    394a:	af 93       	push	r26
    394c:	bf 93       	push	r27
    394e:	ef 93       	push	r30
    3950:	ff 93       	push	r31
	TickCounter++;
    3952:	80 91 c8 04 	lds	r24, 0x04C8
    3956:	8f 5f       	subi	r24, 0xFF	; 255
    3958:	80 93 c8 04 	sts	0x04C8, r24
    395c:	40 e0       	ldi	r20, 0x00	; 0
    395e:	50 e0       	ldi	r21, 0x00	; 0
	uint8_t i;
	for (i=0; i<Timer8_ISR_TotNumber; i++)
			if (!(Timer8_ISR_Flg[i/8] &(1<<i%8)) && --Timer8_ISR[i]==0)
				Timer8_ISR_Flg[i/8] |=(1<<i%8);
    3960:	a1 e0       	ldi	r26, 0x01	; 1
    3962:	b0 e0       	ldi	r27, 0x00	; 0
#endif
{
	TickCounter++;
	uint8_t i;
	for (i=0; i<Timer8_ISR_TotNumber; i++)
			if (!(Timer8_ISR_Flg[i/8] &(1<<i%8)) && --Timer8_ISR[i]==0)
    3964:	80 91 a6 04 	lds	r24, 0x04A6
    3968:	ba 01       	movw	r22, r20
    396a:	67 70       	andi	r22, 0x07	; 7
    396c:	70 70       	andi	r23, 0x00	; 0
    396e:	90 e0       	ldi	r25, 0x00	; 0
    3970:	06 2e       	mov	r0, r22
    3972:	02 c0       	rjmp	.+4      	; 0x3978 <__vector_17+0x4a>
    3974:	95 95       	asr	r25
    3976:	87 95       	ror	r24
    3978:	0a 94       	dec	r0
    397a:	e2 f7       	brpl	.-8      	; 0x3974 <__vector_17+0x46>
    397c:	80 fd       	sbrc	r24, 0
    397e:	14 c0       	rjmp	.+40     	; 0x39a8 <__vector_17+0x7a>
    3980:	fa 01       	movw	r30, r20
    3982:	ea 51       	subi	r30, 0x1A	; 26
    3984:	fd 4f       	sbci	r31, 0xFD	; 253
    3986:	80 81       	ld	r24, Z
    3988:	81 50       	subi	r24, 0x01	; 1
    398a:	80 83       	st	Z, r24
    398c:	80 81       	ld	r24, Z
    398e:	88 23       	and	r24, r24
    3990:	59 f4       	brne	.+22     	; 0x39a8 <__vector_17+0x7a>
				Timer8_ISR_Flg[i/8] |=(1<<i%8);
    3992:	20 91 a6 04 	lds	r18, 0x04A6
    3996:	cd 01       	movw	r24, r26
    3998:	02 c0       	rjmp	.+4      	; 0x399e <__vector_17+0x70>
    399a:	88 0f       	add	r24, r24
    399c:	99 1f       	adc	r25, r25
    399e:	6a 95       	dec	r22
    39a0:	e2 f7       	brpl	.-8      	; 0x399a <__vector_17+0x6c>
    39a2:	28 2b       	or	r18, r24
    39a4:	20 93 a6 04 	sts	0x04A6, r18
    39a8:	4f 5f       	subi	r20, 0xFF	; 255
    39aa:	5f 4f       	sbci	r21, 0xFF	; 255
	ISR(TCC0_OVF_vect)
#endif
{
	TickCounter++;
	uint8_t i;
	for (i=0; i<Timer8_ISR_TotNumber; i++)
    39ac:	48 30       	cpi	r20, 0x08	; 8
    39ae:	51 05       	cpc	r21, r1
    39b0:	c9 f6       	brne	.-78     	; 0x3964 <__vector_17+0x36>
				Timer8_ISR_Flg[i/8] |=(1<<i%8);

	#ifdef HIGH_SPEED_COUNTER
		HSC_Process();
	#endif
}
    39b2:	ff 91       	pop	r31
    39b4:	ef 91       	pop	r30
    39b6:	bf 91       	pop	r27
    39b8:	af 91       	pop	r26
    39ba:	9f 91       	pop	r25
    39bc:	8f 91       	pop	r24
    39be:	7f 91       	pop	r23
    39c0:	6f 91       	pop	r22
    39c2:	5f 91       	pop	r21
    39c4:	4f 91       	pop	r20
    39c6:	2f 91       	pop	r18
    39c8:	0f 90       	pop	r0
    39ca:	0b be       	out	0x3b, r0	; 59
    39cc:	0f 90       	pop	r0
    39ce:	0f be       	out	0x3f, r0	; 63
    39d0:	0f 90       	pop	r0
    39d2:	1f 90       	pop	r1
    39d4:	18 95       	reti

000039d6 <TimeCycle>:
// ~~~~~~~~~~~~
void
TimeCycle(void)
{
	// WDT
	wdt_reset();
    39d6:	a8 95       	wdr

	// Scan cycle
	ScanCount++;
    39d8:	80 91 64 07 	lds	r24, 0x0764
    39dc:	90 91 65 07 	lds	r25, 0x0765
    39e0:	01 96       	adiw	r24, 0x01	; 1
    39e2:	90 93 65 07 	sts	0x0765, r25
    39e6:	80 93 64 07 	sts	0x0764, r24
	if ((ScanCycle=0xFF-Timer8[TD_Scan])>MaxScanCycle)
    39ea:	90 91 c7 04 	lds	r25, 0x04C7
    39ee:	e9 2f       	mov	r30, r25
    39f0:	f0 e0       	ldi	r31, 0x00	; 0
    39f2:	e2 51       	subi	r30, 0x12	; 18
    39f4:	fd 4f       	sbci	r31, 0xFD	; 253
    39f6:	e0 81       	ld	r30, Z
    39f8:	e0 95       	com	r30
    39fa:	e0 93 60 07 	sts	0x0760, r30
    39fe:	80 91 a8 06 	lds	r24, 0x06A8
    3a02:	8e 17       	cp	r24, r30
    3a04:	10 f4       	brcc	.+4      	; 0x3a0a <TimeCycle+0x34>
		MaxScanCycle = ScanCycle;
    3a06:	e0 93 a8 06 	sts	0x06A8, r30
	StartTimer8(TD_Scan, 0xFF);
    3a0a:	89 2f       	mov	r24, r25
    3a0c:	6f ef       	ldi	r22, 0xFF	; 255
    3a0e:	0e 94 ca 19 	call	0x3394	; 0x3394 <StartTimer8>
}
    3a12:	08 95       	ret

00003a14 <MaxScanCycle_Clear>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
void
MaxScanCycle_Clear(void)
{
	MaxScanCycle = 0;
    3a14:	10 92 a8 06 	sts	0x06A8, r1
}
    3a18:	08 95       	ret

00003a1a <Delay_ms>:

// ~~~~~~~~~~~~~~~~~~~~
void
Delay_ms(uint8_t Delay)
{
	while (Delay--)
    3a1a:	88 23       	and	r24, r24
    3a1c:	39 f0       	breq	.+14     	; 0x3a2c <Delay_ms+0x12>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3a1e:	20 ea       	ldi	r18, 0xA0	; 160
    3a20:	3f e0       	ldi	r19, 0x0F	; 15
    3a22:	f9 01       	movw	r30, r18
    3a24:	31 97       	sbiw	r30, 0x01	; 1
    3a26:	f1 f7       	brne	.-4      	; 0x3a24 <Delay_ms+0xa>
    3a28:	81 50       	subi	r24, 0x01	; 1
    3a2a:	d9 f7       	brne	.-10     	; 0x3a22 <Delay_ms+0x8>
    3a2c:	08 95       	ret

00003a2e <Delay_us>:
{
	/*uint8_t i;
	for(i=Delay/Delay_us_Max; i; i--)
		_delay_us(Delay_us_Max);*/
	//_delay_us(Delay%Delay_us_Max);
	Delay *= .8;	// By trial
    3a2e:	a0 e0       	ldi	r26, 0x00	; 0
    3a30:	b0 e0       	ldi	r27, 0x00	; 0
    3a32:	bc 01       	movw	r22, r24
    3a34:	cd 01       	movw	r24, r26
    3a36:	0e 94 f2 77 	call	0xefe4	; 0xefe4 <__floatunsisf>
    3a3a:	2d ec       	ldi	r18, 0xCD	; 205
    3a3c:	3c ec       	ldi	r19, 0xCC	; 204
    3a3e:	4c e4       	ldi	r20, 0x4C	; 76
    3a40:	5f e3       	ldi	r21, 0x3F	; 63
    3a42:	0e 94 2f 78 	call	0xf05e	; 0xf05e <__mulsf3>
    3a46:	0e 94 c7 7c 	call	0xf98e	; 0xf98e <__fixunssfsi>
    3a4a:	cb 01       	movw	r24, r22
	while (Delay--)
    3a4c:	67 2b       	or	r22, r23
    3a4e:	31 f0       	breq	.+12     	; 0x3a5c <Delay_us+0x2e>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3a50:	35 e0       	ldi	r19, 0x05	; 5
    3a52:	23 2f       	mov	r18, r19
    3a54:	2a 95       	dec	r18
    3a56:	f1 f7       	brne	.-4      	; 0x3a54 <Delay_us+0x26>
    3a58:	01 97       	sbiw	r24, 0x01	; 1
    3a5a:	d9 f7       	brne	.-10     	; 0x3a52 <Delay_us+0x24>
    3a5c:	08 95       	ret

00003a5e <MB_PLC_Init>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#if defined vmd2_3
	void MB_PLC_Init(void)
	{
		// RS485
		DDRE |=(1<<PE2); PORTE &=~(1<<PE2);
    3a5e:	6a 9a       	sbi	0x0d, 2	; 13
    3a60:	72 98       	cbi	0x0e, 2	; 14
		DDRD |=(1<<PD4); PORTD &=~(1<<PD4);
    3a62:	54 9a       	sbi	0x0a, 4	; 10
    3a64:	5c 98       	cbi	0x0b, 4	; 11
	#ifndef GSM
		DDRL |=(1<<PL5); PORTL &=~(1<<PL5);
	#endif
	}
    3a66:	08 95       	ret

00003a68 <RS485_0>:
	void RS485_0(void) {PORTE ^=(1<<PE2);}
    3a68:	8e b1       	in	r24, 0x0e	; 14
    3a6a:	94 e0       	ldi	r25, 0x04	; 4
    3a6c:	89 27       	eor	r24, r25
    3a6e:	8e b9       	out	0x0e, r24	; 14
    3a70:	08 95       	ret

00003a72 <RS485_1>:
	void RS485_1(void) {PORTD ^=(1<<PD4);}
    3a72:	8b b1       	in	r24, 0x0b	; 11
    3a74:	90 e1       	ldi	r25, 0x10	; 16
    3a76:	89 27       	eor	r24, r25
    3a78:	8b b9       	out	0x0b, r24	; 11
    3a7a:	08 95       	ret

00003a7c <MB_LED0>:
	}
	void RS485_0(void) {PORTE ^=(1<<PE2);}
	void RS485_1(void) {PORTC ^=(1<<PC0);}
#endif

void MB_LED0(void) {}
    3a7c:	08 95       	ret

00003a7e <MB_LED1>:
void MB_LED1(void) {}
    3a7e:	08 95       	ret

00003a80 <MB_LED2>:
void MB_LED2(void) {}
    3a80:	08 95       	ret

00003a82 <MB_LED_Err_On_0>:

void MB_LED_Err_On_0(void)	{}
    3a82:	08 95       	ret

00003a84 <MB_LED_Err_Off_0>:
void MB_LED_Err_Off_0(void)	{}
    3a84:	08 95       	ret

00003a86 <MB_LED_Err_On_1>:
void MB_LED_Err_On_1(void)	{}
    3a86:	08 95       	ret

00003a88 <MB_LED_Err_Off_1>:
void MB_LED_Err_Off_1(void)	{}	
    3a88:	08 95       	ret

00003a8a <MB_LED_Err_On_2>:
void MB_LED_Err_On_2(void)	{}
    3a8a:	08 95       	ret

00003a8c <MB_LED_Err_Off_2>:
void MB_LED_Err_Off_2(void)	{}
    3a8c:	08 95       	ret

00003a8e <PWM_Init>:

// ~~~~~~~~~~~
void
PWM_Init(void)
{
	TCCR3A = (1<<COM3A1) | (0<<COM3A0) | (1<<COM3B1) | (0<<COM3B0) | (0<<COM3C1) | (0<<COM3C0) | (1<<WGM31) | (0<<WGM30);
    3a8e:	32 ea       	ldi	r19, 0xA2	; 162
    3a90:	30 93 90 00 	sts	0x0090, r19
	TCCR3B = (0<<CS32) | (0<<CS31) | (1<<CS30) | (1<<WGM33) | (1<<WGM32);	// Fpwm = 244Hz
    3a94:	29 e1       	ldi	r18, 0x19	; 25
    3a96:	20 93 91 00 	sts	0x0091, r18
	ICR3 = PWM_PERIOD_TC3;
    3a9a:	8f ef       	ldi	r24, 0xFF	; 255
    3a9c:	9f ef       	ldi	r25, 0xFF	; 255
    3a9e:	90 93 97 00 	sts	0x0097, r25
    3aa2:	80 93 96 00 	sts	0x0096, r24
	DDRE |= (1<<PE3) | (1<<PE4);
    3aa6:	8d b1       	in	r24, 0x0d	; 13
    3aa8:	88 61       	ori	r24, 0x18	; 24
    3aaa:	8d b9       	out	0x0d, r24	; 13

	TCCR5A = (1<<COM5A1) | (0<<COM5A0) | (1<<COM5B1) | (0<<COM5B0) | (0<<COM5C1) | (0<<COM5C0) | (1<<WGM51) | (0<<WGM50);
    3aac:	30 93 20 01 	sts	0x0120, r19
	TCCR5B = (0<<CS52) | (0<<CS51) | (1<<CS50) | (1<<WGM53) | (1<<WGM52);	// Fpwm = 244Hz
    3ab0:	20 93 21 01 	sts	0x0121, r18
	ICR5 = PWM_PERIOD_TC5;
    3ab4:	8e e7       	ldi	r24, 0x7E	; 126
    3ab6:	9c e0       	ldi	r25, 0x0C	; 12
    3ab8:	90 93 27 01 	sts	0x0127, r25
    3abc:	80 93 26 01 	sts	0x0126, r24
	DDRL |= (1<<PL3) | (1<<PL4);
    3ac0:	ea e0       	ldi	r30, 0x0A	; 10
    3ac2:	f1 e0       	ldi	r31, 0x01	; 1
    3ac4:	80 81       	ld	r24, Z
    3ac6:	88 61       	ori	r24, 0x18	; 24
    3ac8:	80 83       	st	Z, r24
}
    3aca:	08 95       	ret

00003acc <PWM_Out>:
void
PWM_Out(void)
{
	uint16_t Buf;

	Buf = Coef_AO_PWM_TC3*DAC_Output[0];
    3acc:	60 91 81 07 	lds	r22, 0x0781
    3ad0:	70 91 82 07 	lds	r23, 0x0782
    3ad4:	80 e0       	ldi	r24, 0x00	; 0
    3ad6:	90 e0       	ldi	r25, 0x00	; 0
    3ad8:	0e 94 f2 77 	call	0xefe4	; 0xefe4 <__floatunsisf>
    3adc:	28 e8       	ldi	r18, 0x88	; 136
    3ade:	3f e1       	ldi	r19, 0x1F	; 31
    3ae0:	40 e8       	ldi	r20, 0x80	; 128
    3ae2:	52 e4       	ldi	r21, 0x42	; 66
    3ae4:	0e 94 2f 78 	call	0xf05e	; 0xf05e <__mulsf3>
    3ae8:	0e 94 c7 7c 	call	0xf98e	; 0xf98e <__fixunssfsi>
    3aec:	26 2f       	mov	r18, r22

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3aee:	9f b7       	in	r25, 0x3f	; 63
	cli();
    3af0:	f8 94       	cli
	IntOff();
	OCR3AH = Buf>>8;
    3af2:	70 93 99 00 	sts	0x0099, r23
	OCR3AL = Buf;
    3af6:	20 93 98 00 	sts	0x0098, r18

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3afa:	97 ff       	sbrs	r25, 7
    3afc:	01 c0       	rjmp	.+2      	; 0x3b00 <PWM_Out+0x34>
		sei();
    3afe:	78 94       	sei
	IntOn();

	Buf = Coef_AO_PWM_TC3*DAC_Output[1];
    3b00:	60 91 83 07 	lds	r22, 0x0783
    3b04:	70 91 84 07 	lds	r23, 0x0784
    3b08:	80 e0       	ldi	r24, 0x00	; 0
    3b0a:	90 e0       	ldi	r25, 0x00	; 0
    3b0c:	0e 94 f2 77 	call	0xefe4	; 0xefe4 <__floatunsisf>
    3b10:	28 e8       	ldi	r18, 0x88	; 136
    3b12:	3f e1       	ldi	r19, 0x1F	; 31
    3b14:	40 e8       	ldi	r20, 0x80	; 128
    3b16:	52 e4       	ldi	r21, 0x42	; 66
    3b18:	0e 94 2f 78 	call	0xf05e	; 0xf05e <__mulsf3>
    3b1c:	0e 94 c7 7c 	call	0xf98e	; 0xf98e <__fixunssfsi>
    3b20:	26 2f       	mov	r18, r22

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3b22:	9f b7       	in	r25, 0x3f	; 63
	cli();
    3b24:	f8 94       	cli
	IntOff();
	OCR3BH = Buf>>8;
    3b26:	70 93 9b 00 	sts	0x009B, r23
	OCR3BL = Buf;
    3b2a:	20 93 9a 00 	sts	0x009A, r18

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3b2e:	97 ff       	sbrs	r25, 7
    3b30:	01 c0       	rjmp	.+2      	; 0x3b34 <PWM_Out+0x68>
		sei();
    3b32:	78 94       	sei
	IntOn();


	Buf = Coef_AO_PWM_TC5*DAC_Output[2];
    3b34:	60 91 85 07 	lds	r22, 0x0785
    3b38:	70 91 86 07 	lds	r23, 0x0786
    3b3c:	80 e0       	ldi	r24, 0x00	; 0
    3b3e:	90 e0       	ldi	r25, 0x00	; 0
    3b40:	0e 94 f2 77 	call	0xefe4	; 0xefe4 <__floatunsisf>
    3b44:	25 e0       	ldi	r18, 0x05	; 5
    3b46:	32 e1       	ldi	r19, 0x12	; 18
    3b48:	48 e4       	ldi	r20, 0x48	; 72
    3b4a:	50 e4       	ldi	r21, 0x40	; 64
    3b4c:	0e 94 2f 78 	call	0xf05e	; 0xf05e <__mulsf3>
    3b50:	0e 94 c7 7c 	call	0xf98e	; 0xf98e <__fixunssfsi>
    3b54:	26 2f       	mov	r18, r22

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3b56:	9f b7       	in	r25, 0x3f	; 63
	cli();
    3b58:	f8 94       	cli
	IntOff();
	OCR5AH = Buf>>8;
    3b5a:	70 93 29 01 	sts	0x0129, r23
	OCR5AL = Buf;
    3b5e:	20 93 28 01 	sts	0x0128, r18

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3b62:	97 ff       	sbrs	r25, 7
    3b64:	01 c0       	rjmp	.+2      	; 0x3b68 <PWM_Out+0x9c>
		sei();
    3b66:	78 94       	sei
	IntOn();

	Buf = Coef_AO_PWM_TC5*DAC_Output[3];
    3b68:	60 91 87 07 	lds	r22, 0x0787
    3b6c:	70 91 88 07 	lds	r23, 0x0788
    3b70:	80 e0       	ldi	r24, 0x00	; 0
    3b72:	90 e0       	ldi	r25, 0x00	; 0
    3b74:	0e 94 f2 77 	call	0xefe4	; 0xefe4 <__floatunsisf>
    3b78:	25 e0       	ldi	r18, 0x05	; 5
    3b7a:	32 e1       	ldi	r19, 0x12	; 18
    3b7c:	48 e4       	ldi	r20, 0x48	; 72
    3b7e:	50 e4       	ldi	r21, 0x40	; 64
    3b80:	0e 94 2f 78 	call	0xf05e	; 0xf05e <__mulsf3>
    3b84:	0e 94 c7 7c 	call	0xf98e	; 0xf98e <__fixunssfsi>
    3b88:	26 2f       	mov	r18, r22

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3b8a:	8f b7       	in	r24, 0x3f	; 63
    3b8c:	80 78       	andi	r24, 0x80	; 128
    3b8e:	80 93 e5 02 	sts	0x02E5, r24
	cli();
    3b92:	f8 94       	cli
	IntOff();
	OCR5BH = Buf>>8;
    3b94:	70 93 2b 01 	sts	0x012B, r23
	OCR5BL = Buf;
    3b98:	20 93 2a 01 	sts	0x012A, r18

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3b9c:	88 23       	and	r24, r24
    3b9e:	09 f0       	breq	.+2      	; 0x3ba2 <PWM_Out+0xd6>
		sei();
    3ba0:	78 94       	sei
    3ba2:	08 95       	ret

00003ba4 <ADC_In>:
}

// ~~~~~~~~~
uint8_t
ADC_In(void)
{
    3ba4:	1f 93       	push	r17

// ~~~~~~~~~~~~~~~
inline static void
ADC_Select(void)
{
	SPCR |=(1<<CPOL);
    3ba6:	8c b5       	in	r24, 0x2c	; 44
    3ba8:	88 60       	ori	r24, 0x08	; 8
    3baa:	8c bd       	out	0x2c, r24	; 44
	#ifdef CS_ADC
		cli();
    3bac:	f8 94       	cli
		PortCS_ADC &=~CS_ADC;
    3bae:	80 91 02 01 	lds	r24, 0x0102
    3bb2:	87 7f       	andi	r24, 0xF7	; 247
    3bb4:	80 93 02 01 	sts	0x0102, r24
		sei();
    3bb8:	78 94       	sei
ADC_In(void)
{
	uint8_t Chan = ADC_Reg;
	ADC_Select();

	switch(ADC_Phase) {
    3bba:	80 91 18 0b 	lds	r24, 0x0B18
    3bbe:	81 30       	cpi	r24, 0x01	; 1
    3bc0:	09 f4       	brne	.+2      	; 0x3bc4 <ADC_In+0x20>
    3bc2:	ec c0       	rjmp	.+472    	; 0x3d9c <ADC_In+0x1f8>
    3bc4:	81 30       	cpi	r24, 0x01	; 1
    3bc6:	30 f5       	brcc	.+76     	; 0x3c14 <ADC_In+0x70>

// ~~~~~~~~~~~~~~~
inline static void
ADC_Rst(void)
{
	cli();
    3bc8:	f8 94       	cli
	PortRESET_PER &=~RESET_PER;
    3bca:	80 91 02 01 	lds	r24, 0x0102
    3bce:	8f 7e       	andi	r24, 0xEF	; 239
    3bd0:	80 93 02 01 	sts	0x0102, r24
	sei();
    3bd4:	78 94       	sei
    3bd6:	85 e0       	ldi	r24, 0x05	; 5
    3bd8:	8a 95       	dec	r24
    3bda:	f1 f7       	brne	.-4      	; 0x3bd8 <ADC_In+0x34>
	_delay_us(1);							// 100 ns needs
	cli();
    3bdc:	f8 94       	cli
	PortRESET_PER |=RESET_PER;
    3bde:	80 91 02 01 	lds	r24, 0x0102
    3be2:	80 61       	ori	r24, 0x10	; 16
    3be4:	80 93 02 01 	sts	0x0102, r24
	sei();
    3be8:	78 94       	sei
	StartTimer8_ISR(TD_ADC, 4);		// 16 ms needs
    3bea:	80 91 eb 06 	lds	r24, 0x06EB
    3bee:	64 e0       	ldi	r22, 0x04	; 4
	WaitSPI();
	SPDR = SR;
	WaitSPI();
	SPDR = SetpVal(CaliMode) &~ADC_FSYNC;
	WaitSPI();
	StartTimer8_ISR(TD_ADC, 36);
    3bf0:	0e 94 8f 19 	call	0x331e	; 0x331e <StartTimer8_ISR>
	ADC_Phase++;
    3bf4:	80 91 18 0b 	lds	r24, 0x0B18
    3bf8:	8f 5f       	subi	r24, 0xFF	; 255
    3bfa:	80 93 18 0b 	sts	0x0B18, r24
    3bfe:	17 e0       	ldi	r17, 0x07	; 7
// ~~~~~~~~~~~~~~~
inline static void
ADC_Desel(void)
{
	#ifdef CS_ADC
		cli();
    3c00:	f8 94       	cli
		PortCS_ADC |=CS_ADC;
    3c02:	80 91 02 01 	lds	r24, 0x0102
    3c06:	88 60       	ori	r24, 0x08	; 8
    3c08:	80 93 02 01 	sts	0x0102, r24
		sei();
    3c0c:	78 94       	sei
			IntOn();
		}
	#endif

	return Chan;
}
    3c0e:	81 2f       	mov	r24, r17
    3c10:	1f 91       	pop	r17
    3c12:	08 95       	ret
ADC_In(void)
{
	uint8_t Chan = ADC_Reg;
	ADC_Select();

	switch(ADC_Phase) {
    3c14:	82 30       	cpi	r24, 0x02	; 2
    3c16:	09 f4       	brne	.+2      	; 0x3c1a <ADC_In+0x76>
    3c18:	d2 c0       	rjmp	.+420    	; 0x3dbe <ADC_In+0x21a>
    3c1a:	83 30       	cpi	r24, 0x03	; 3
    3c1c:	11 f0       	breq	.+4      	; 0x3c22 <ADC_In+0x7e>
				StartTimer8_ISR(TD_ADC, ADC10ms);
			}
		}
		else if(Timer8Stopp_ISR(TD_ADC)) {
			ADC_ReadFail++;
			ADC_Phase = RST;
    3c1e:	17 e0       	ldi	r17, 0x07	; 7
    3c20:	ef cf       	rjmp	.-34     	; 0x3c00 <ADC_In+0x5c>
		default:
			SPDR = ADC_IN1(Reg);
			break;
		}
	#else
		SPDR = ADC_IN1(Reg);
    3c22:	88 e0       	ldi	r24, 0x08	; 8
    3c24:	8e bd       	out	0x2e, r24	; 46

// ~~~~~~~~~~~
static void
WaitADC2(void)
{
	WaitSPI();
    3c26:	0d b4       	in	r0, 0x2d	; 45
    3c28:	07 fe       	sbrs	r0, 7
    3c2a:	fd cf       	rjmp	.-6      	; 0x3c26 <ADC_In+0x82>
	SPDR = 0;
    3c2c:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    3c2e:	0d b4       	in	r0, 0x2d	; 45
    3c30:	07 fe       	sbrs	r0, 7
    3c32:	fd cf       	rjmp	.-6      	; 0x3c2e <ADC_In+0x8a>
			StartTimer8_ISR(TD_ADC, ADC10ms);
		break;
	case READ:
		ADC_IN(CommReg);
		WaitADC2();
		if(!(SPDR &ADC_DRDY)) {
    3c34:	0e b4       	in	r0, 0x2e	; 46
    3c36:	07 fc       	sbrc	r0, 7
    3c38:	da c0       	rjmp	.+436    	; 0x3dee <ADC_In+0x24a>
		default:
			SPDR = ADC_IN1(Reg);
			break;
		}
	#else
		SPDR = ADC_IN1(Reg);
    3c3a:	88 e3       	ldi	r24, 0x38	; 56
    3c3c:	8e bd       	out	0x2e, r24	; 46

// ~~~~~~~~~~~
static void
WaitADC2(void)
{
	WaitSPI();
    3c3e:	0d b4       	in	r0, 0x2d	; 45
    3c40:	07 fe       	sbrs	r0, 7
    3c42:	fd cf       	rjmp	.-6      	; 0x3c3e <ADC_In+0x9a>
	SPDR = 0;
    3c44:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    3c46:	0d b4       	in	r0, 0x2d	; 45
    3c48:	07 fe       	sbrs	r0, 7
    3c4a:	fd cf       	rjmp	.-6      	; 0x3c46 <ADC_In+0xa2>
		WaitADC2();
		if(!(SPDR &ADC_DRDY)) {
			uint16_t Buf;
			ADC_IN(DataReg);
			WaitADC2();
			Buf = SPDR<<8;
    3c4c:	3e b5       	in	r19, 0x2e	; 46

// ~~~~~~~~~~~
static void
WaitADC1(void)
{
	SPDR = 0;
    3c4e:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    3c50:	0d b4       	in	r0, 0x2d	; 45
    3c52:	07 fe       	sbrs	r0, 7
    3c54:	fd cf       	rjmp	.-6      	; 0x3c50 <ADC_In+0xac>
			uint16_t Buf;
			ADC_IN(DataReg);
			WaitADC2();
			Buf = SPDR<<8;
			WaitADC1();
			Buf += SPDR;
    3c56:	2e b5       	in	r18, 0x2e	; 46
		WaitADC2();
		if(!(SPDR &ADC_DRDY)) {
			uint16_t Buf;
			ADC_IN(DataReg);
			WaitADC2();
			Buf = SPDR<<8;
    3c58:	93 2f       	mov	r25, r19
    3c5a:	80 e0       	ldi	r24, 0x00	; 0
			WaitADC1();
			Buf += SPDR;
    3c5c:	ac 01       	movw	r20, r24
    3c5e:	42 0f       	add	r20, r18
    3c60:	51 1d       	adc	r21, r1
    3c62:	9a 01       	movw	r18, r20
			#ifdef ADC_Ref_Chan
				if (ADC_Chan==sizeof(Mux)-1 && ADC_Input[sizeof(Mux)-1]!=0 && (Buf<ADC_Ref-ADC_Ref_d || Buf>ADC_Ref+ADC_Ref_d)) {
    3c64:	10 91 c0 08 	lds	r17, 0x08C0
    3c68:	16 30       	cpi	r17, 0x06	; 6
    3c6a:	09 f4       	brne	.+2      	; 0x3c6e <ADC_In+0xca>
    3c6c:	19 c1       	rjmp	.+562    	; 0x3ea0 <ADC_In+0x2fc>
		default:
			SPDR = ADC_IN1(Reg);
			break;
		}
	#else
		SPDR = ADC_IN1(Reg);
    3c6e:	80 e1       	ldi	r24, 0x10	; 16
    3c70:	8e bd       	out	0x2e, r24	; 46
{
	Scale *Scl;
	int8_t i;

	ADC_IN(SetpReg);
	WaitSPI();
    3c72:	0d b4       	in	r0, 0x2d	; 45
    3c74:	07 fe       	sbrs	r0, 7
    3c76:	fd cf       	rjmp	.-6      	; 0x3c72 <ADC_In+0xce>
	SPDR = SetpVal(NormMode) |ADC_FSYNC;
    3c78:	87 e0       	ldi	r24, 0x07	; 7
    3c7a:	8e bd       	out	0x2e, r24	; 46
	WaitSPI();
    3c7c:	0d b4       	in	r0, 0x2d	; 45
    3c7e:	07 fe       	sbrs	r0, 7
    3c80:	fd cf       	rjmp	.-6      	; 0x3c7c <ADC_In+0xd8>
	ADC_Time = ADC10ms-Timer8_ISR[TD_ADC];
    3c82:	40 91 eb 06 	lds	r20, 0x06EB
    3c86:	e4 2f       	mov	r30, r20
    3c88:	f0 e0       	ldi	r31, 0x00	; 0
    3c8a:	ea 51       	subi	r30, 0x1A	; 26
    3c8c:	fd 4f       	sbci	r31, 0xFD	; 253
    3c8e:	90 81       	ld	r25, Z
    3c90:	84 e1       	ldi	r24, 0x14	; 20
    3c92:	89 1b       	sub	r24, r25
    3c94:	80 93 aa 06 	sts	0x06AA, r24
		default:
			SPDR = ADC_IN1(Reg);
			break;
		}
	#else
		SPDR = ADC_IN1(Reg);
    3c98:	88 e6       	ldi	r24, 0x68	; 104
    3c9a:	8e bd       	out	0x2e, r24	; 46

// ~~~~~~~~~~~
static void
WaitADC2(void)
{
	WaitSPI();
    3c9c:	0d b4       	in	r0, 0x2d	; 45
    3c9e:	07 fe       	sbrs	r0, 7
    3ca0:	fd cf       	rjmp	.-6      	; 0x3c9c <ADC_In+0xf8>
	SPDR = 0;
    3ca2:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    3ca4:	0d b4       	in	r0, 0x2d	; 45
    3ca6:	07 fe       	sbrs	r0, 7
    3ca8:	fd cf       	rjmp	.-6      	; 0x3ca4 <ADC_In+0x100>
    3caa:	ed e1       	ldi	r30, 0x1D	; 29
    3cac:	fc e0       	ldi	r31, 0x0C	; 12
		Scl=&ADC_Scale1;
	#endif
	ADC_IN(ZeroReg);
	WaitADC2();
	for(i=2; i>=0; i--) {
		Scl->Zero[i] = SPDR;
    3cae:	8e b5       	in	r24, 0x2e	; 46
    3cb0:	80 83       	st	Z, r24

// ~~~~~~~~~~~
static void
WaitADC1(void)
{
	SPDR = 0;
    3cb2:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    3cb4:	0d b4       	in	r0, 0x2d	; 45
    3cb6:	07 fe       	sbrs	r0, 7
    3cb8:	fd cf       	rjmp	.-6      	; 0x3cb4 <ADC_In+0x110>
    3cba:	31 97       	sbiw	r30, 0x01	; 1
	#else
		Scl=&ADC_Scale1;
	#endif
	ADC_IN(ZeroReg);
	WaitADC2();
	for(i=2; i>=0; i--) {
    3cbc:	8c e0       	ldi	r24, 0x0C	; 12
    3cbe:	ea 31       	cpi	r30, 0x1A	; 26
    3cc0:	f8 07       	cpc	r31, r24
    3cc2:	a9 f7       	brne	.-22     	; 0x3cae <ADC_In+0x10a>

// ~~~~~~~~~~~
static void
WaitADC1(void)
{
	SPDR = 0;
    3cc4:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    3cc6:	0d b4       	in	r0, 0x2d	; 45
    3cc8:	07 fe       	sbrs	r0, 7
    3cca:	fd cf       	rjmp	.-6      	; 0x3cc6 <ADC_In+0x122>
		default:
			SPDR = ADC_IN1(Reg);
			break;
		}
	#else
		SPDR = ADC_IN1(Reg);
    3ccc:	88 e7       	ldi	r24, 0x78	; 120
    3cce:	8e bd       	out	0x2e, r24	; 46

// ~~~~~~~~~~~
static void
WaitADC2(void)
{
	WaitSPI();
    3cd0:	0d b4       	in	r0, 0x2d	; 45
    3cd2:	07 fe       	sbrs	r0, 7
    3cd4:	fd cf       	rjmp	.-6      	; 0x3cd0 <ADC_In+0x12c>
	SPDR = 0;
    3cd6:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    3cd8:	0d b4       	in	r0, 0x2d	; 45
    3cda:	07 fe       	sbrs	r0, 7
    3cdc:	fd cf       	rjmp	.-6      	; 0x3cd8 <ADC_In+0x134>
    3cde:	e0 e2       	ldi	r30, 0x20	; 32
    3ce0:	fc e0       	ldi	r31, 0x0C	; 12
	}
	WaitADC1();
	ADC_IN(FullReg);
	WaitADC2();
	for(i=2; i>=0; i--) {
		Scl->Full[i] = SPDR;
    3ce2:	8e b5       	in	r24, 0x2e	; 46
    3ce4:	80 83       	st	Z, r24

// ~~~~~~~~~~~
static void
WaitADC1(void)
{
	SPDR = 0;
    3ce6:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    3ce8:	0d b4       	in	r0, 0x2d	; 45
    3cea:	07 fe       	sbrs	r0, 7
    3cec:	fd cf       	rjmp	.-6      	; 0x3ce8 <ADC_In+0x144>
    3cee:	31 97       	sbiw	r30, 0x01	; 1
		WaitADC1();
	}
	WaitADC1();
	ADC_IN(FullReg);
	WaitADC2();
	for(i=2; i>=0; i--) {
    3cf0:	5c e0       	ldi	r21, 0x0C	; 12
    3cf2:	ed 31       	cpi	r30, 0x1D	; 29
    3cf4:	f5 07       	cpc	r31, r21
    3cf6:	a9 f7       	brne	.-22     	; 0x3ce2 <ADC_In+0x13e>

// ~~~~~~~~~~~
static void
WaitADC1(void)
{
	SPDR = 0;
    3cf8:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    3cfa:	0d b4       	in	r0, 0x2d	; 45
    3cfc:	07 fe       	sbrs	r0, 7
    3cfe:	fd cf       	rjmp	.-6      	; 0x3cfa <ADC_In+0x156>
	for(i=2; i>=0; i--) {
		Scl->Full[i] = SPDR;
		WaitADC1();
	}
	WaitADC1();
	return Scl->Zero[2]<25 || Scl->Zero[2]>27 || Scl->Full[2]<200 || Scl->Full[2]>203;
    3d00:	80 91 1d 0c 	lds	r24, 0x0C1D
    3d04:	89 51       	subi	r24, 0x19	; 25
    3d06:	83 30       	cpi	r24, 0x03	; 3
    3d08:	08 f0       	brcs	.+2      	; 0x3d0c <ADC_In+0x168>
    3d0a:	85 c0       	rjmp	.+266    	; 0x3e16 <ADC_In+0x272>
    3d0c:	80 91 20 0c 	lds	r24, 0x0C20
    3d10:	88 3c       	cpi	r24, 0xC8	; 200
    3d12:	08 f4       	brcc	.+2      	; 0x3d16 <ADC_In+0x172>
    3d14:	80 c0       	rjmp	.+256    	; 0x3e16 <ADC_In+0x272>
    3d16:	8c 3c       	cpi	r24, 0xCC	; 204
    3d18:	08 f0       	brcs	.+2      	; 0x3d1c <ADC_In+0x178>
    3d1a:	7d c0       	rjmp	.+250    	; 0x3e16 <ADC_In+0x272>
			if(ADC_Check()) {
				ADC_Break++;
				ADC_Phase = RST;
			}
			else {
				ADC_Input[ADC_Chan] = Buf;
    3d1c:	e1 2f       	mov	r30, r17
    3d1e:	f0 e0       	ldi	r31, 0x00	; 0
    3d20:	ee 0f       	add	r30, r30
    3d22:	ff 1f       	adc	r31, r31
    3d24:	e7 53       	subi	r30, 0x37	; 55
    3d26:	f7 4f       	sbci	r31, 0xF7	; 247
    3d28:	31 83       	std	Z+1, r19	; 0x01
    3d2a:	20 83       	st	Z, r18

// ~~~~~~~~~~~~~~~
inline static void
SetMux(void)
{
	if(++ADC_Chan == ADC_Reg)
    3d2c:	81 2f       	mov	r24, r17
    3d2e:	8f 5f       	subi	r24, 0xFF	; 255
    3d30:	80 93 c0 08 	sts	0x08C0, r24
    3d34:	87 30       	cpi	r24, 0x07	; 7
    3d36:	11 f4       	brne	.+4      	; 0x3d3c <ADC_In+0x198>
		ADC_Chan = 0;
    3d38:	10 92 c0 08 	sts	0x08C0, r1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    3d3c:	e0 91 c0 08 	lds	r30, 0x08C0
    3d40:	f0 e0       	ldi	r31, 0x00	; 0
    3d42:	e3 5b       	subi	r30, 0xB3	; 179
    3d44:	f2 4d       	sbci	r31, 0xD2	; 210
    3d46:	94 91       	lpm	r25, Z+
		#if ADC_Reg>8
			if(ADC_Chan>=sizeof(Mux))
				return;
		#endif
		uint8_t Addr = prb(Mux+ADC_Chan);
		cli();
    3d48:	f8 94       	cli
		if (Addr/4){
    3d4a:	94 30       	cpi	r25, 0x04	; 4
    3d4c:	08 f4       	brcc	.+2      	; 0x3d50 <ADC_In+0x1ac>
    3d4e:	ca c0       	rjmp	.+404    	; 0x3ee4 <ADC_In+0x340>
			Port_INH|=INH;
    3d50:	77 9a       	sbi	0x0e, 7	; 14
			#ifdef Port_INH2
				Port_INH2 &=~INH2;
    3d52:	80 91 02 01 	lds	r24, 0x0102
    3d56:	8b 7f       	andi	r24, 0xFB	; 251
    3d58:	80 93 02 01 	sts	0x0102, r24
			Port_INH &=~INH;
			#ifdef Port_INH2
				Port_INH2|=INH2;
			#endif
		}
		if (Addr%4/2)	Port_TER_B	|=TER_B;	else Port_TER_B	&=~TER_B;
    3d5c:	29 2f       	mov	r18, r25
    3d5e:	30 e0       	ldi	r19, 0x00	; 0
    3d60:	c9 01       	movw	r24, r18
    3d62:	83 70       	andi	r24, 0x03	; 3
    3d64:	90 70       	andi	r25, 0x00	; 0
    3d66:	01 96       	adiw	r24, 0x01	; 1
    3d68:	03 97       	sbiw	r24, 0x03	; 3
    3d6a:	08 f4       	brcc	.+2      	; 0x3d6e <ADC_In+0x1ca>
    3d6c:	b9 c0       	rjmp	.+370    	; 0x3ee0 <ADC_In+0x33c>
    3d6e:	76 9a       	sbi	0x0e, 6	; 14
		if (Addr%2)		Port_TER_A	|=TER_A;	else Port_TER_A	&=~TER_A;
    3d70:	20 ff       	sbrs	r18, 0
    3d72:	b4 c0       	rjmp	.+360    	; 0x3edc <ADC_In+0x338>
    3d74:	75 9a       	sbi	0x0e, 5	; 14
		sei();
    3d76:	78 94       	sei
    3d78:	85 e5       	ldi	r24, 0x55	; 85
    3d7a:	8a 95       	dec	r24
    3d7c:	f1 f7       	brne	.-4      	; 0x3d7a <ADC_In+0x1d6>
		default:
			SPDR = ADC_IN1(Reg);
			break;
		}
	#else
		SPDR = ADC_IN1(Reg);
    3d7e:	80 e1       	ldi	r24, 0x10	; 16
    3d80:	8e bd       	out	0x2e, r24	; 46
			else {
				ADC_Input[ADC_Chan] = Buf;
				Chan = ADC_Chan;
				SetMux();
				ADC_IN(SetpReg);
				WaitSPI();
    3d82:	0d b4       	in	r0, 0x2d	; 45
    3d84:	07 fe       	sbrs	r0, 7
    3d86:	fd cf       	rjmp	.-6      	; 0x3d82 <ADC_In+0x1de>
				SPDR = SetpVal(NormMode) &~ADC_FSYNC;
    3d88:	86 e0       	ldi	r24, 0x06	; 6
    3d8a:	8e bd       	out	0x2e, r24	; 46
				WaitSPI();
    3d8c:	0d b4       	in	r0, 0x2d	; 45
    3d8e:	07 fe       	sbrs	r0, 7
    3d90:	fd cf       	rjmp	.-6      	; 0x3d8c <ADC_In+0x1e8>
				StartTimer8_ISR(TD_ADC, ADC10ms);
    3d92:	84 2f       	mov	r24, r20
    3d94:	64 e1       	ldi	r22, 0x14	; 20
    3d96:	0e 94 8f 19 	call	0x331e	; 0x331e <StartTimer8_ISR>
    3d9a:	32 cf       	rjmp	.-412    	; 0x3c00 <ADC_In+0x5c>

// ~~~~~~~~~~~~~~~
inline static void
ADC_Init1(void)
{
	if(!Timer8Stopp_ISR(TD_ADC))
    3d9c:	80 91 eb 06 	lds	r24, 0x06EB
    3da0:	0e 94 fb 1a 	call	0x35f6	; 0x35f6 <Timer8Stopp_ISR>
    3da4:	88 23       	and	r24, r24
    3da6:	09 f4       	brne	.+2      	; 0x3daa <ADC_In+0x206>
    3da8:	3a cf       	rjmp	.-396    	; 0x3c1e <ADC_In+0x7a>
    3daa:	81 e0       	ldi	r24, 0x01	; 1
		return;
	uint8_t i = 0;
	while(i++<8) {	// 4 x 0xFF needs
		SPDR = 0xFF;
    3dac:	9f ef       	ldi	r25, 0xFF	; 255
    3dae:	9e bd       	out	0x2e, r25	; 46
		WaitSPI();
    3db0:	0d b4       	in	r0, 0x2d	; 45
    3db2:	07 fe       	sbrs	r0, 7
    3db4:	fd cf       	rjmp	.-6      	; 0x3db0 <ADC_In+0x20c>
ADC_Init1(void)
{
	if(!Timer8Stopp_ISR(TD_ADC))
		return;
	uint8_t i = 0;
	while(i++<8) {	// 4 x 0xFF needs
    3db6:	88 30       	cpi	r24, 0x08	; 8
    3db8:	d9 f1       	breq	.+118    	; 0x3e30 <ADC_In+0x28c>
    3dba:	8f 5f       	subi	r24, 0xFF	; 255
    3dbc:	f8 cf       	rjmp	.-16     	; 0x3dae <ADC_In+0x20a>
// ~~~~~~~~~~~~~~~
static void
Calibr(uint8_t CR)
{
	static uint8_t Try;
	SPDR = CR;
    3dbe:	88 e0       	ldi	r24, 0x08	; 8
    3dc0:	8e bd       	out	0x2e, r24	; 46

// ~~~~~~~~~~~
static void
WaitADC2(void)
{
	WaitSPI();
    3dc2:	0d b4       	in	r0, 0x2d	; 45
    3dc4:	07 fe       	sbrs	r0, 7
    3dc6:	fd cf       	rjmp	.-6      	; 0x3dc2 <ADC_In+0x21e>
	SPDR = 0;
    3dc8:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    3dca:	0d b4       	in	r0, 0x2d	; 45
    3dcc:	07 fe       	sbrs	r0, 7
    3dce:	fd cf       	rjmp	.-6      	; 0x3dca <ADC_In+0x226>
Calibr(uint8_t CR)
{
	static uint8_t Try;
	SPDR = CR;
	WaitADC2();
	if(!(SPDR &ADC_DRDY)) {
    3dd0:	0e b4       	in	r0, 0x2e	; 46
    3dd2:	07 fc       	sbrc	r0, 7
    3dd4:	45 c0       	rjmp	.+138    	; 0x3e60 <ADC_In+0x2bc>
		Try = 0;
    3dd6:	10 92 e3 02 	sts	0x02E3, r1
		ADC_Phase++;
    3dda:	83 e0       	ldi	r24, 0x03	; 3
    3ddc:	80 93 18 0b 	sts	0x0B18, r24
		break;
	case CALI3:
		Calibr(ADC_IN3(CommReg));
#endif
		if (ADC_Phase==READ)
			StartTimer8_ISR(TD_ADC, ADC10ms);
    3de0:	80 91 eb 06 	lds	r24, 0x06EB
    3de4:	64 e1       	ldi	r22, 0x14	; 20
    3de6:	0e 94 8f 19 	call	0x331e	; 0x331e <StartTimer8_ISR>
    3dea:	17 e0       	ldi	r17, 0x07	; 7
    3dec:	09 cf       	rjmp	.-494    	; 0x3c00 <ADC_In+0x5c>
				SPDR = SetpVal(NormMode) &~ADC_FSYNC;
				WaitSPI();
				StartTimer8_ISR(TD_ADC, ADC10ms);
			}
		}
		else if(Timer8Stopp_ISR(TD_ADC)) {
    3dee:	80 91 eb 06 	lds	r24, 0x06EB
    3df2:	0e 94 fb 1a 	call	0x35f6	; 0x35f6 <Timer8Stopp_ISR>
    3df6:	88 23       	and	r24, r24
    3df8:	09 f4       	brne	.+2      	; 0x3dfc <ADC_In+0x258>
    3dfa:	11 cf       	rjmp	.-478    	; 0x3c1e <ADC_In+0x7a>
			ADC_ReadFail++;
    3dfc:	80 91 66 07 	lds	r24, 0x0766
    3e00:	90 91 67 07 	lds	r25, 0x0767
    3e04:	01 96       	adiw	r24, 0x01	; 1
    3e06:	90 93 67 07 	sts	0x0767, r25
    3e0a:	80 93 66 07 	sts	0x0766, r24
			ADC_Phase = RST;
    3e0e:	10 92 18 0b 	sts	0x0B18, r1
    3e12:	17 e0       	ldi	r17, 0x07	; 7
    3e14:	f5 ce       	rjmp	.-534    	; 0x3c00 <ADC_In+0x5c>
					ADC_Chan--;
				}
				else
			#endif
			if(ADC_Check()) {
				ADC_Break++;
    3e16:	80 91 ae 06 	lds	r24, 0x06AE
    3e1a:	90 91 af 06 	lds	r25, 0x06AF
    3e1e:	01 96       	adiw	r24, 0x01	; 1
    3e20:	90 93 af 06 	sts	0x06AF, r25
    3e24:	80 93 ae 06 	sts	0x06AE, r24
				ADC_Phase = RST;
    3e28:	10 92 18 0b 	sts	0x0B18, r1
    3e2c:	17 e0       	ldi	r17, 0x07	; 7
    3e2e:	e8 ce       	rjmp	.-560    	; 0x3c00 <ADC_In+0x5c>

// ~~~~~~~~~~~~~~~~~~~~~~~~~
static void
Init(uint8_t CR, uint8_t SR)
{
	SPDR = CR;
    3e30:	80 e2       	ldi	r24, 0x20	; 32
    3e32:	8e bd       	out	0x2e, r24	; 46
	WaitSPI();
    3e34:	0d b4       	in	r0, 0x2d	; 45
    3e36:	07 fe       	sbrs	r0, 7
    3e38:	fd cf       	rjmp	.-6      	; 0x3e34 <ADC_In+0x290>
	SPDR=ClckVal;
    3e3a:	84 e0       	ldi	r24, 0x04	; 4
    3e3c:	8e bd       	out	0x2e, r24	; 46
	WaitSPI();
    3e3e:	0d b4       	in	r0, 0x2d	; 45
    3e40:	07 fe       	sbrs	r0, 7
    3e42:	fd cf       	rjmp	.-6      	; 0x3e3e <ADC_In+0x29a>
	SPDR = SR;
    3e44:	80 e1       	ldi	r24, 0x10	; 16
    3e46:	8e bd       	out	0x2e, r24	; 46
	WaitSPI();
    3e48:	0d b4       	in	r0, 0x2d	; 45
    3e4a:	07 fe       	sbrs	r0, 7
    3e4c:	fd cf       	rjmp	.-6      	; 0x3e48 <ADC_In+0x2a4>
	SPDR = SetpVal(CaliMode) &~ADC_FSYNC;
    3e4e:	86 e4       	ldi	r24, 0x46	; 70
    3e50:	8e bd       	out	0x2e, r24	; 46
	WaitSPI();
    3e52:	0d b4       	in	r0, 0x2d	; 45
    3e54:	07 fe       	sbrs	r0, 7
    3e56:	fd cf       	rjmp	.-6      	; 0x3e52 <ADC_In+0x2ae>
	StartTimer8_ISR(TD_ADC, 36);
    3e58:	80 91 eb 06 	lds	r24, 0x06EB
    3e5c:	64 e2       	ldi	r22, 0x24	; 36
    3e5e:	c8 ce       	rjmp	.-624    	; 0x3bf0 <ADC_In+0x4c>
	WaitADC2();
	if(!(SPDR &ADC_DRDY)) {
		Try = 0;
		ADC_Phase++;
	}
	else if(Timer8Stopp_ISR(TD_ADC)) {
    3e60:	80 91 eb 06 	lds	r24, 0x06EB
    3e64:	0e 94 fb 1a 	call	0x35f6	; 0x35f6 <Timer8Stopp_ISR>
    3e68:	88 23       	and	r24, r24
    3e6a:	99 f0       	breq	.+38     	; 0x3e92 <ADC_In+0x2ee>
		ADC_Fail++;
    3e6c:	80 91 d9 08 	lds	r24, 0x08D9
    3e70:	90 91 da 08 	lds	r25, 0x08DA
    3e74:	01 96       	adiw	r24, 0x01	; 1
    3e76:	90 93 da 08 	sts	0x08DA, r25
    3e7a:	80 93 d9 08 	sts	0x08D9, r24
		ADC_Phase = ++Try<27 ? RST : ADC_OFF;
    3e7e:	80 91 e3 02 	lds	r24, 0x02E3
    3e82:	8f 5f       	subi	r24, 0xFF	; 255
    3e84:	80 93 e3 02 	sts	0x02E3, r24
    3e88:	8b 31       	cpi	r24, 0x1B	; 27
    3e8a:	98 f1       	brcs	.+102    	; 0x3ef2 <ADC_In+0x34e>
    3e8c:	84 e0       	ldi	r24, 0x04	; 4
    3e8e:	80 93 18 0b 	sts	0x0B18, r24
		Init(ADC_IN3(ClckReg), ADC_IN3(SetpReg));
		break;
	case CALI3:
		Calibr(ADC_IN3(CommReg));
#endif
		if (ADC_Phase==READ)
    3e92:	80 91 18 0b 	lds	r24, 0x0B18
    3e96:	83 30       	cpi	r24, 0x03	; 3
    3e98:	09 f4       	brne	.+2      	; 0x3e9c <ADC_In+0x2f8>
    3e9a:	a2 cf       	rjmp	.-188    	; 0x3de0 <ADC_In+0x23c>
				StartTimer8_ISR(TD_ADC, ADC10ms);
			}
		}
		else if(Timer8Stopp_ISR(TD_ADC)) {
			ADC_ReadFail++;
			ADC_Phase = RST;
    3e9c:	17 e0       	ldi	r17, 0x07	; 7
    3e9e:	b0 ce       	rjmp	.-672    	; 0x3c00 <ADC_In+0x5c>
			WaitADC2();
			Buf = SPDR<<8;
			WaitADC1();
			Buf += SPDR;
			#ifdef ADC_Ref_Chan
				if (ADC_Chan==sizeof(Mux)-1 && ADC_Input[sizeof(Mux)-1]!=0 && (Buf<ADC_Ref-ADC_Ref_d || Buf>ADC_Ref+ADC_Ref_d)) {
    3ea0:	80 91 d5 08 	lds	r24, 0x08D5
    3ea4:	90 91 d6 08 	lds	r25, 0x08D6
    3ea8:	89 2b       	or	r24, r25
    3eaa:	09 f4       	brne	.+2      	; 0x3eae <ADC_In+0x30a>
    3eac:	e0 ce       	rjmp	.-576    	; 0x3c6e <ADC_In+0xca>
    3eae:	ca 01       	movw	r24, r20
    3eb0:	80 58       	subi	r24, 0x80	; 128
    3eb2:	9e 43       	sbci	r25, 0x3E	; 62
    3eb4:	81 5a       	subi	r24, 0xA1	; 161
    3eb6:	9f 40       	sbci	r25, 0x0F	; 15
    3eb8:	08 f4       	brcc	.+2      	; 0x3ebc <ADC_In+0x318>
    3eba:	d9 ce       	rjmp	.-590    	; 0x3c6e <ADC_In+0xca>
					ADC_Break++;
    3ebc:	80 91 ae 06 	lds	r24, 0x06AE
    3ec0:	90 91 af 06 	lds	r25, 0x06AF
    3ec4:	01 96       	adiw	r24, 0x01	; 1
    3ec6:	90 93 af 06 	sts	0x06AF, r25
    3eca:	80 93 ae 06 	sts	0x06AE, r24
					ADC_Phase = RST;
    3ece:	10 92 18 0b 	sts	0x0B18, r1
					ADC_Chan--;
    3ed2:	85 e0       	ldi	r24, 0x05	; 5
    3ed4:	80 93 c0 08 	sts	0x08C0, r24
    3ed8:	17 e0       	ldi	r17, 0x07	; 7
    3eda:	92 ce       	rjmp	.-732    	; 0x3c00 <ADC_In+0x5c>
			#ifdef Port_INH2
				Port_INH2|=INH2;
			#endif
		}
		if (Addr%4/2)	Port_TER_B	|=TER_B;	else Port_TER_B	&=~TER_B;
		if (Addr%2)		Port_TER_A	|=TER_A;	else Port_TER_A	&=~TER_A;
    3edc:	75 98       	cbi	0x0e, 5	; 14
    3ede:	4b cf       	rjmp	.-362    	; 0x3d76 <ADC_In+0x1d2>
			Port_INH &=~INH;
			#ifdef Port_INH2
				Port_INH2|=INH2;
			#endif
		}
		if (Addr%4/2)	Port_TER_B	|=TER_B;	else Port_TER_B	&=~TER_B;
    3ee0:	76 98       	cbi	0x0e, 6	; 14
    3ee2:	46 cf       	rjmp	.-372    	; 0x3d70 <ADC_In+0x1cc>
			#ifdef Port_INH2
				Port_INH2 &=~INH2;
			#endif
		}
		else{
			Port_INH &=~INH;
    3ee4:	77 98       	cbi	0x0e, 7	; 14
			#ifdef Port_INH2
				Port_INH2|=INH2;
    3ee6:	80 91 02 01 	lds	r24, 0x0102
    3eea:	84 60       	ori	r24, 0x04	; 4
    3eec:	80 93 02 01 	sts	0x0102, r24
    3ef0:	35 cf       	rjmp	.-406    	; 0x3d5c <ADC_In+0x1b8>
		Try = 0;
		ADC_Phase++;
	}
	else if(Timer8Stopp_ISR(TD_ADC)) {
		ADC_Fail++;
		ADC_Phase = ++Try<27 ? RST : ADC_OFF;
    3ef2:	80 e0       	ldi	r24, 0x00	; 0
    3ef4:	cc cf       	rjmp	.-104    	; 0x3e8e <ADC_In+0x2ea>

00003ef6 <SPI_Init>:
// Total
// ~~~~~~~~~~~
void
SPI_Init(void)
{
	cli();
    3ef6:	f8 94       	cli
	#if defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		DDRB = (DDRB &~(1<<DDB3)) |(1<<DDB2) |(1<<DDB1) |(1<<DDB0);
    3ef8:	84 b1       	in	r24, 0x04	; 4
    3efa:	80 7f       	andi	r24, 0xF0	; 240
    3efc:	87 60       	ori	r24, 0x07	; 7
    3efe:	84 b9       	out	0x04, r24	; 4
		PORTB |=1<<PB3;
    3f00:	2b 9a       	sbi	0x05, 3	; 5
	#elif defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
		DDRB = (DDRB &~(1<<DDB6)) |(1<<DDB5) |(1<<DDB7) |(1<<DDB4);
		PORTB |=1<<PB6;
	#endif
	SPCR = (uint8_t)((~(1<<SPIE) |(1<<SPE)) &~(1<<DORD)) |(1<<MSTR) |(1<<CPHA) |(1<<SPR1) |(1<<SPR0);
    3f02:	8f e5       	ldi	r24, 0x5F	; 95
    3f04:	8c bd       	out	0x2c, r24	; 44
	sei();
    3f06:	78 94       	sei
		PortCS_DAC_2 |=CS_DAC_2;
		sei();
	#endif

	#ifndef ADC_Miss
		cli();
    3f08:	f8 94       	cli
		#ifdef CS_ADC
			DDR_CS_ADC |=CS_ADC;
    3f0a:	80 91 01 01 	lds	r24, 0x0101
    3f0e:	88 60       	ori	r24, 0x08	; 8
    3f10:	80 93 01 01 	sts	0x0101, r24
			PortCS_ADC |=CS_ADC;
    3f14:	80 91 02 01 	lds	r24, 0x0102
    3f18:	88 60       	ori	r24, 0x08	; 8
    3f1a:	80 93 02 01 	sts	0x0102, r24
		#endif
		DDR_RESET_PER |=RESET_PER;
    3f1e:	80 91 01 01 	lds	r24, 0x0101
    3f22:	80 61       	ori	r24, 0x10	; 16
    3f24:	80 93 01 01 	sts	0x0101, r24
		#ifdef ADC_Mux
			DDR_INH |=INH;
    3f28:	6f 9a       	sbi	0x0d, 7	; 13
			#ifdef DDR_INH2			
				DDR_INH2 |=INH2;
    3f2a:	80 91 01 01 	lds	r24, 0x0101
    3f2e:	84 60       	ori	r24, 0x04	; 4
    3f30:	80 93 01 01 	sts	0x0101, r24
			#endif
			DDR_TER_A |=TER_A;
    3f34:	6d 9a       	sbi	0x0d, 5	; 13
			DDR_TER_B |=TER_B;
    3f36:	6e 9a       	sbi	0x0d, 6	; 13
		#endif
		sei();
    3f38:	78 94       	sei

// ~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer8_ISR_SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys_ISR;
    3f3a:	80 91 d7 02 	lds	r24, 0x02D7
	VacantTimer8Sys_ISR += n;
    3f3e:	8f 5f       	subi	r24, 0xFF	; 255
    3f40:	80 93 d7 02 	sts	0x02D7, r24
    3f44:	81 50       	subi	r24, 0x01	; 1

		TD_ADC = Timer8_ISR_SysAlloc(1);
    3f46:	80 93 eb 06 	sts	0x06EB, r24


		ADC_Chan = ADC_Reg-1;		// Ignore 1-st measurement after calibration
    3f4a:	86 e0       	ldi	r24, 0x06	; 6
    3f4c:	80 93 c0 08 	sts	0x08C0, r24

		while(ADC_In()==ADC_Reg && ADC_OK);
    3f50:	0e 94 d2 1d 	call	0x3ba4	; 0x3ba4 <ADC_In>
    3f54:	87 30       	cpi	r24, 0x07	; 7
    3f56:	91 f4       	brne	.+36     	; 0x3f7c <SPI_Init+0x86>
    3f58:	80 91 d9 08 	lds	r24, 0x08D9
    3f5c:	90 91 da 08 	lds	r25, 0x08DA
    3f60:	89 2b       	or	r24, r25
    3f62:	61 f4       	brne	.+24     	; 0x3f7c <SPI_Init+0x86>
    3f64:	80 91 66 07 	lds	r24, 0x0766
    3f68:	90 91 67 07 	lds	r25, 0x0767
    3f6c:	89 2b       	or	r24, r25
    3f6e:	31 f4       	brne	.+12     	; 0x3f7c <SPI_Init+0x86>
    3f70:	80 91 ae 06 	lds	r24, 0x06AE
    3f74:	90 91 af 06 	lds	r25, 0x06AF
    3f78:	89 2b       	or	r24, r25
    3f7a:	51 f3       	breq	.-44     	; 0x3f50 <SPI_Init+0x5a>
    3f7c:	08 95       	ret

00003f7e <Pow10>:
#include <string.h>

// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
    3f7e:	48 2f       	mov	r20, r24
	uint16_t Pow = 1;
	while(Exp--)
    3f80:	88 23       	and	r24, r24
    3f82:	89 f0       	breq	.+34     	; 0x3fa6 <Pow10+0x28>
    3f84:	21 e0       	ldi	r18, 0x01	; 1
    3f86:	30 e0       	ldi	r19, 0x00	; 0
		Pow *= 10;
    3f88:	c9 01       	movw	r24, r18
    3f8a:	88 0f       	add	r24, r24
    3f8c:	99 1f       	adc	r25, r25
    3f8e:	22 0f       	add	r18, r18
    3f90:	33 1f       	adc	r19, r19
    3f92:	22 0f       	add	r18, r18
    3f94:	33 1f       	adc	r19, r19
    3f96:	22 0f       	add	r18, r18
    3f98:	33 1f       	adc	r19, r19
    3f9a:	28 0f       	add	r18, r24
    3f9c:	39 1f       	adc	r19, r25
    3f9e:	41 50       	subi	r20, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    3fa0:	99 f7       	brne	.-26     	; 0x3f88 <Pow10+0xa>
		Pow *= 10;
	return Pow;
}
    3fa2:	c9 01       	movw	r24, r18
    3fa4:	08 95       	ret
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    3fa6:	21 e0       	ldi	r18, 0x01	; 1
    3fa8:	30 e0       	ldi	r19, 0x00	; 0
    3faa:	fb cf       	rjmp	.-10     	; 0x3fa2 <Pow10+0x24>

00003fac <PowL10>:
	return Pow;
}
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
    3fac:	1f 93       	push	r17
    3fae:	18 2f       	mov	r17, r24
	uint32_t Pow = 1;
	while(Exp--)
    3fb0:	88 23       	and	r24, r24
    3fb2:	a1 f0       	breq	.+40     	; 0x3fdc <PowL10+0x30>
    3fb4:	21 e0       	ldi	r18, 0x01	; 1
    3fb6:	30 e0       	ldi	r19, 0x00	; 0
    3fb8:	40 e0       	ldi	r20, 0x00	; 0
    3fba:	50 e0       	ldi	r21, 0x00	; 0
		Pow *= 10;
    3fbc:	ca 01       	movw	r24, r20
    3fbe:	b9 01       	movw	r22, r18
    3fc0:	2a e0       	ldi	r18, 0x0A	; 10
    3fc2:	30 e0       	ldi	r19, 0x00	; 0
    3fc4:	40 e0       	ldi	r20, 0x00	; 0
    3fc6:	50 e0       	ldi	r21, 0x00	; 0
    3fc8:	0e 94 3f 7d 	call	0xfa7e	; 0xfa7e <__mulsi3>
    3fcc:	9b 01       	movw	r18, r22
    3fce:	ac 01       	movw	r20, r24
    3fd0:	11 50       	subi	r17, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
	uint32_t Pow = 1;
	while(Exp--)
    3fd2:	a1 f7       	brne	.-24     	; 0x3fbc <PowL10+0x10>
		Pow *= 10;
	return Pow;
}
    3fd4:	b9 01       	movw	r22, r18
    3fd6:	ca 01       	movw	r24, r20
    3fd8:	1f 91       	pop	r17
    3fda:	08 95       	ret
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
	uint32_t Pow = 1;
	while(Exp--)
    3fdc:	21 e0       	ldi	r18, 0x01	; 1
    3fde:	30 e0       	ldi	r19, 0x00	; 0
    3fe0:	40 e0       	ldi	r20, 0x00	; 0
    3fe2:	50 e0       	ldi	r21, 0x00	; 0
    3fe4:	f7 cf       	rjmp	.-18     	; 0x3fd4 <PowL10+0x28>

00003fe6 <Log10>:
	return Pow;
}
// ~~~~~~~~~~~~~~~~~
uint8_t
Log10(uint32_t Numb)
{
    3fe6:	1f 93       	push	r17
	uint8_t Pos;
	for(Pos=0; Numb/=10; Pos++);
    3fe8:	2a e0       	ldi	r18, 0x0A	; 10
    3fea:	30 e0       	ldi	r19, 0x00	; 0
    3fec:	40 e0       	ldi	r20, 0x00	; 0
    3fee:	50 e0       	ldi	r21, 0x00	; 0
    3ff0:	0e 94 91 7d 	call	0xfb22	; 0xfb22 <__udivmodsi4>
    3ff4:	c9 01       	movw	r24, r18
    3ff6:	da 01       	movw	r26, r20
    3ff8:	bc 01       	movw	r22, r24
    3ffa:	cd 01       	movw	r24, r26
    3ffc:	61 15       	cp	r22, r1
    3ffe:	71 05       	cpc	r23, r1
    4000:	81 05       	cpc	r24, r1
    4002:	91 05       	cpc	r25, r1
    4004:	a1 f0       	breq	.+40     	; 0x402e <Log10+0x48>
    4006:	10 e0       	ldi	r17, 0x00	; 0
    4008:	1f 5f       	subi	r17, 0xFF	; 255
    400a:	2a e0       	ldi	r18, 0x0A	; 10
    400c:	30 e0       	ldi	r19, 0x00	; 0
    400e:	40 e0       	ldi	r20, 0x00	; 0
    4010:	50 e0       	ldi	r21, 0x00	; 0
    4012:	0e 94 91 7d 	call	0xfb22	; 0xfb22 <__udivmodsi4>
    4016:	c9 01       	movw	r24, r18
    4018:	da 01       	movw	r26, r20
    401a:	bc 01       	movw	r22, r24
    401c:	cd 01       	movw	r24, r26
    401e:	61 15       	cp	r22, r1
    4020:	71 05       	cpc	r23, r1
    4022:	81 05       	cpc	r24, r1
    4024:	91 05       	cpc	r25, r1
    4026:	81 f7       	brne	.-32     	; 0x4008 <Log10+0x22>
	return Pos;
}
    4028:	81 2f       	mov	r24, r17
    402a:	1f 91       	pop	r17
    402c:	08 95       	ret
// ~~~~~~~~~~~~~~~~~
uint8_t
Log10(uint32_t Numb)
{
	uint8_t Pos;
	for(Pos=0; Numb/=10; Pos++);
    402e:	10 e0       	ldi	r17, 0x00	; 0
    4030:	fb cf       	rjmp	.-10     	; 0x4028 <Log10+0x42>

00004032 <CodBCD>:
// ~~~~~~~~~~~~~~~~~~~~

// ~~~~~~~~~~~~~~~~~~~
uint8_t
CodBCD(uint8_t Number)
{
    4032:	28 2f       	mov	r18, r24
    4034:	6a e0       	ldi	r22, 0x0A	; 10
    4036:	0e 94 5e 7d 	call	0xfabc	; 0xfabc <__udivmodqi4>
    403a:	38 2f       	mov	r19, r24
    403c:	32 95       	swap	r19
    403e:	30 7f       	andi	r19, 0xF0	; 240
    4040:	82 2f       	mov	r24, r18
    4042:	0e 94 5e 7d 	call	0xfabc	; 0xfabc <__udivmodqi4>
	return (Number/10<<4)+Number%10;
}
    4046:	83 2f       	mov	r24, r19
    4048:	89 0f       	add	r24, r25
    404a:	08 95       	ret

0000404c <DecodBCD>:

// ~~~~~~~~~~~~~~~~~~
uint8_t
DecodBCD(uint8_t BCD)
{
    404c:	28 2f       	mov	r18, r24
    404e:	22 95       	swap	r18
    4050:	2f 70       	andi	r18, 0x0F	; 15
    4052:	9a e0       	ldi	r25, 0x0A	; 10
    4054:	29 9f       	mul	r18, r25
    4056:	90 01       	movw	r18, r0
    4058:	11 24       	eor	r1, r1
    405a:	8f 70       	andi	r24, 0x0F	; 15
	return 10*(BCD>>4)+(BCD&0x0F);
}
    405c:	82 0f       	add	r24, r18
    405e:	08 95       	ret

00004060 <LineFunc>:
} uLineGraph;

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
int16_t
LineFunc(const LineGraph *LG, int32_t x)
{
    4060:	2f 92       	push	r2
    4062:	3f 92       	push	r3
    4064:	4f 92       	push	r4
    4066:	5f 92       	push	r5
    4068:	6f 92       	push	r6
    406a:	7f 92       	push	r7
    406c:	8f 92       	push	r8
    406e:	9f 92       	push	r9
    4070:	af 92       	push	r10
    4072:	bf 92       	push	r11
    4074:	cf 92       	push	r12
    4076:	df 92       	push	r13
    4078:	ef 92       	push	r14
    407a:	ff 92       	push	r15
    407c:	0f 93       	push	r16
    407e:	1f 93       	push	r17
    4080:	cf 93       	push	r28
    4082:	df 93       	push	r29
    4084:	ec 01       	movw	r28, r24
    4086:	7a 01       	movw	r14, r20
    4088:	8b 01       	movw	r16, r22
	int16_t y;
	if (LG->x1==LG->x2)
    408a:	28 80       	ld	r2, Y
    408c:	39 80       	ldd	r3, Y+1	; 0x01
    408e:	4a 80       	ldd	r4, Y+2	; 0x02
    4090:	5b 80       	ldd	r5, Y+3	; 0x03
    4092:	6c 81       	ldd	r22, Y+4	; 0x04
    4094:	7d 81       	ldd	r23, Y+5	; 0x05
    4096:	8e 81       	ldd	r24, Y+6	; 0x06
    4098:	9f 81       	ldd	r25, Y+7	; 0x07
    409a:	26 16       	cp	r2, r22
    409c:	37 06       	cpc	r3, r23
    409e:	48 06       	cpc	r4, r24
    40a0:	59 06       	cpc	r5, r25
    40a2:	09 f4       	brne	.+2      	; 0x40a6 <LineFunc+0x46>
    40a4:	58 c0       	rjmp	.+176    	; 0x4156 <LineFunc+0xf6>
		y = LG->y1;
	else {
		float x1=LG->x1, x2=LG->x2, y1=LG->y1, y2=LG->y2;
    40a6:	0e 94 f4 77 	call	0xefe8	; 0xefe8 <__floatsisf>
    40aa:	5b 01       	movw	r10, r22
    40ac:	6c 01       	movw	r12, r24
    40ae:	6a 85       	ldd	r22, Y+10	; 0x0a
    40b0:	7b 85       	ldd	r23, Y+11	; 0x0b
    40b2:	88 27       	eor	r24, r24
    40b4:	77 fd       	sbrc	r23, 7
    40b6:	80 95       	com	r24
    40b8:	98 2f       	mov	r25, r24
    40ba:	0e 94 f4 77 	call	0xefe8	; 0xefe8 <__floatsisf>
    40be:	3b 01       	movw	r6, r22
    40c0:	4c 01       	movw	r8, r24
		y = (x-x2)*(y2-y1)/(x2-x1)+y2;
    40c2:	c8 01       	movw	r24, r16
    40c4:	b7 01       	movw	r22, r14
    40c6:	0e 94 f4 77 	call	0xefe8	; 0xefe8 <__floatsisf>
    40ca:	a6 01       	movw	r20, r12
    40cc:	95 01       	movw	r18, r10
    40ce:	0e 94 f5 7b 	call	0xf7ea	; 0xf7ea <__subsf3>
    40d2:	7b 01       	movw	r14, r22
    40d4:	8c 01       	movw	r16, r24
    40d6:	68 85       	ldd	r22, Y+8	; 0x08
    40d8:	79 85       	ldd	r23, Y+9	; 0x09
    40da:	88 27       	eor	r24, r24
    40dc:	77 fd       	sbrc	r23, 7
    40de:	80 95       	com	r24
    40e0:	98 2f       	mov	r25, r24
    40e2:	0e 94 f4 77 	call	0xefe8	; 0xefe8 <__floatsisf>
    40e6:	9b 01       	movw	r18, r22
    40e8:	ac 01       	movw	r20, r24
    40ea:	c4 01       	movw	r24, r8
    40ec:	b3 01       	movw	r22, r6
    40ee:	0e 94 f5 7b 	call	0xf7ea	; 0xf7ea <__subsf3>
    40f2:	9b 01       	movw	r18, r22
    40f4:	ac 01       	movw	r20, r24
    40f6:	c8 01       	movw	r24, r16
    40f8:	b7 01       	movw	r22, r14
    40fa:	0e 94 2f 78 	call	0xf05e	; 0xf05e <__mulsf3>
    40fe:	7b 01       	movw	r14, r22
    4100:	8c 01       	movw	r16, r24
    4102:	c2 01       	movw	r24, r4
    4104:	b1 01       	movw	r22, r2
    4106:	0e 94 f4 77 	call	0xefe8	; 0xefe8 <__floatsisf>
    410a:	9b 01       	movw	r18, r22
    410c:	ac 01       	movw	r20, r24
    410e:	c6 01       	movw	r24, r12
    4110:	b5 01       	movw	r22, r10
    4112:	0e 94 f5 7b 	call	0xf7ea	; 0xf7ea <__subsf3>
    4116:	9b 01       	movw	r18, r22
    4118:	ac 01       	movw	r20, r24
    411a:	c8 01       	movw	r24, r16
    411c:	b7 01       	movw	r22, r14
    411e:	0e 94 5a 7c 	call	0xf8b4	; 0xf8b4 <__divsf3>
    4122:	a4 01       	movw	r20, r8
    4124:	93 01       	movw	r18, r6
    4126:	0e 94 f6 7b 	call	0xf7ec	; 0xf7ec <__addsf3>
    412a:	0e 94 c2 7c 	call	0xf984	; 0xf984 <__fixsfsi>
    412e:	cb 01       	movw	r24, r22
	}
	return y;
}
    4130:	df 91       	pop	r29
    4132:	cf 91       	pop	r28
    4134:	1f 91       	pop	r17
    4136:	0f 91       	pop	r16
    4138:	ff 90       	pop	r15
    413a:	ef 90       	pop	r14
    413c:	df 90       	pop	r13
    413e:	cf 90       	pop	r12
    4140:	bf 90       	pop	r11
    4142:	af 90       	pop	r10
    4144:	9f 90       	pop	r9
    4146:	8f 90       	pop	r8
    4148:	7f 90       	pop	r7
    414a:	6f 90       	pop	r6
    414c:	5f 90       	pop	r5
    414e:	4f 90       	pop	r4
    4150:	3f 90       	pop	r3
    4152:	2f 90       	pop	r2
    4154:	08 95       	ret
int16_t
LineFunc(const LineGraph *LG, int32_t x)
{
	int16_t y;
	if (LG->x1==LG->x2)
		y = LG->y1;
    4156:	88 85       	ldd	r24, Y+8	; 0x08
    4158:	99 85       	ldd	r25, Y+9	; 0x09
    415a:	ea cf       	rjmp	.-44     	; 0x4130 <LineFunc+0xd0>

0000415c <uLineFunc>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
int16_t
uLineFunc(const uLineGraph *LG, uint32_t x)
{
    415c:	2f 92       	push	r2
    415e:	3f 92       	push	r3
    4160:	4f 92       	push	r4
    4162:	5f 92       	push	r5
    4164:	6f 92       	push	r6
    4166:	7f 92       	push	r7
    4168:	8f 92       	push	r8
    416a:	9f 92       	push	r9
    416c:	af 92       	push	r10
    416e:	bf 92       	push	r11
    4170:	cf 92       	push	r12
    4172:	df 92       	push	r13
    4174:	ef 92       	push	r14
    4176:	ff 92       	push	r15
    4178:	0f 93       	push	r16
    417a:	1f 93       	push	r17
    417c:	cf 93       	push	r28
    417e:	df 93       	push	r29
    4180:	ec 01       	movw	r28, r24
    4182:	7a 01       	movw	r14, r20
    4184:	8b 01       	movw	r16, r22
	int16_t y;
	if (LG->x1==LG->x2)
    4186:	28 80       	ld	r2, Y
    4188:	39 80       	ldd	r3, Y+1	; 0x01
    418a:	4a 80       	ldd	r4, Y+2	; 0x02
    418c:	5b 80       	ldd	r5, Y+3	; 0x03
    418e:	6c 81       	ldd	r22, Y+4	; 0x04
    4190:	7d 81       	ldd	r23, Y+5	; 0x05
    4192:	8e 81       	ldd	r24, Y+6	; 0x06
    4194:	9f 81       	ldd	r25, Y+7	; 0x07
    4196:	26 16       	cp	r2, r22
    4198:	37 06       	cpc	r3, r23
    419a:	48 06       	cpc	r4, r24
    419c:	59 06       	cpc	r5, r25
    419e:	09 f4       	brne	.+2      	; 0x41a2 <uLineFunc+0x46>
    41a0:	58 c0       	rjmp	.+176    	; 0x4252 <uLineFunc+0xf6>
		y = LG->y1;
	else {
		float x1=LG->x1, x2=LG->x2, y1=LG->y1, y2=LG->y2;
    41a2:	0e 94 f2 77 	call	0xefe4	; 0xefe4 <__floatunsisf>
    41a6:	5b 01       	movw	r10, r22
    41a8:	6c 01       	movw	r12, r24
    41aa:	6a 85       	ldd	r22, Y+10	; 0x0a
    41ac:	7b 85       	ldd	r23, Y+11	; 0x0b
    41ae:	88 27       	eor	r24, r24
    41b0:	77 fd       	sbrc	r23, 7
    41b2:	80 95       	com	r24
    41b4:	98 2f       	mov	r25, r24
    41b6:	0e 94 f4 77 	call	0xefe8	; 0xefe8 <__floatsisf>
    41ba:	3b 01       	movw	r6, r22
    41bc:	4c 01       	movw	r8, r24
		y = (x-x2)*(y2-y1)/(x2-x1)+y2;
    41be:	c8 01       	movw	r24, r16
    41c0:	b7 01       	movw	r22, r14
    41c2:	0e 94 f2 77 	call	0xefe4	; 0xefe4 <__floatunsisf>
    41c6:	a6 01       	movw	r20, r12
    41c8:	95 01       	movw	r18, r10
    41ca:	0e 94 f5 7b 	call	0xf7ea	; 0xf7ea <__subsf3>
    41ce:	7b 01       	movw	r14, r22
    41d0:	8c 01       	movw	r16, r24
    41d2:	68 85       	ldd	r22, Y+8	; 0x08
    41d4:	79 85       	ldd	r23, Y+9	; 0x09
    41d6:	88 27       	eor	r24, r24
    41d8:	77 fd       	sbrc	r23, 7
    41da:	80 95       	com	r24
    41dc:	98 2f       	mov	r25, r24
    41de:	0e 94 f4 77 	call	0xefe8	; 0xefe8 <__floatsisf>
    41e2:	9b 01       	movw	r18, r22
    41e4:	ac 01       	movw	r20, r24
    41e6:	c4 01       	movw	r24, r8
    41e8:	b3 01       	movw	r22, r6
    41ea:	0e 94 f5 7b 	call	0xf7ea	; 0xf7ea <__subsf3>
    41ee:	9b 01       	movw	r18, r22
    41f0:	ac 01       	movw	r20, r24
    41f2:	c8 01       	movw	r24, r16
    41f4:	b7 01       	movw	r22, r14
    41f6:	0e 94 2f 78 	call	0xf05e	; 0xf05e <__mulsf3>
    41fa:	7b 01       	movw	r14, r22
    41fc:	8c 01       	movw	r16, r24
    41fe:	c2 01       	movw	r24, r4
    4200:	b1 01       	movw	r22, r2
    4202:	0e 94 f2 77 	call	0xefe4	; 0xefe4 <__floatunsisf>
    4206:	9b 01       	movw	r18, r22
    4208:	ac 01       	movw	r20, r24
    420a:	c6 01       	movw	r24, r12
    420c:	b5 01       	movw	r22, r10
    420e:	0e 94 f5 7b 	call	0xf7ea	; 0xf7ea <__subsf3>
    4212:	9b 01       	movw	r18, r22
    4214:	ac 01       	movw	r20, r24
    4216:	c8 01       	movw	r24, r16
    4218:	b7 01       	movw	r22, r14
    421a:	0e 94 5a 7c 	call	0xf8b4	; 0xf8b4 <__divsf3>
    421e:	a4 01       	movw	r20, r8
    4220:	93 01       	movw	r18, r6
    4222:	0e 94 f6 7b 	call	0xf7ec	; 0xf7ec <__addsf3>
    4226:	0e 94 c2 7c 	call	0xf984	; 0xf984 <__fixsfsi>
    422a:	cb 01       	movw	r24, r22
	}
	return y;
}
    422c:	df 91       	pop	r29
    422e:	cf 91       	pop	r28
    4230:	1f 91       	pop	r17
    4232:	0f 91       	pop	r16
    4234:	ff 90       	pop	r15
    4236:	ef 90       	pop	r14
    4238:	df 90       	pop	r13
    423a:	cf 90       	pop	r12
    423c:	bf 90       	pop	r11
    423e:	af 90       	pop	r10
    4240:	9f 90       	pop	r9
    4242:	8f 90       	pop	r8
    4244:	7f 90       	pop	r7
    4246:	6f 90       	pop	r6
    4248:	5f 90       	pop	r5
    424a:	4f 90       	pop	r4
    424c:	3f 90       	pop	r3
    424e:	2f 90       	pop	r2
    4250:	08 95       	ret
int16_t
uLineFunc(const uLineGraph *LG, uint32_t x)
{
	int16_t y;
	if (LG->x1==LG->x2)
		y = LG->y1;
    4252:	88 85       	ldd	r24, Y+8	; 0x08
    4254:	99 85       	ldd	r25, Y+9	; 0x09
    4256:	ea cf       	rjmp	.-44     	; 0x422c <uLineFunc+0xd0>

00004258 <PGM_uBrokLine>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
int16_t
PGM_uBrokLine(PGM_uDataPoint *Brok, uint16_t x)
{
    4258:	af 92       	push	r10
    425a:	bf 92       	push	r11
    425c:	cf 92       	push	r12
    425e:	df 92       	push	r13
    4260:	ef 92       	push	r14
    4262:	ff 92       	push	r15
    4264:	0f 93       	push	r16
    4266:	1f 93       	push	r17
    4268:	df 93       	push	r29
    426a:	cf 93       	push	r28
    426c:	cd b7       	in	r28, 0x3d	; 61
    426e:	de b7       	in	r29, 0x3e	; 62
    4270:	2c 97       	sbiw	r28, 0x0c	; 12
    4272:	0f b6       	in	r0, 0x3f	; 63
    4274:	f8 94       	cli
    4276:	de bf       	out	0x3e, r29	; 62
    4278:	0f be       	out	0x3f, r0	; 63
    427a:	cd bf       	out	0x3d, r28	; 61
    427c:	dc 01       	movw	r26, r24

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    427e:	fc 01       	movw	r30, r24
    4280:	85 91       	lpm	r24, Z+
    4282:	94 91       	lpm	r25, Z+
	uLineGraph Segm;
	Segm.x2 = prw(&Brok->x);
    4284:	7c 01       	movw	r14, r24
    4286:	00 e0       	ldi	r16, 0x00	; 0
    4288:	10 e0       	ldi	r17, 0x00	; 0
    428a:	5b 01       	movw	r10, r22
    428c:	cc 24       	eor	r12, r12
    428e:	dd 24       	eor	r13, r13
	do {
		Segm.x1 = Segm.x2;
		Segm.x2 = prw(&(++Brok)->x);
    4290:	cd 01       	movw	r24, r26
    4292:	04 96       	adiw	r24, 0x04	; 4
    4294:	fc 01       	movw	r30, r24
    4296:	25 91       	lpm	r18, Z+
    4298:	34 91       	lpm	r19, Z+
    429a:	ad 01       	movw	r20, r26
    429c:	b7 01       	movw	r22, r14
    429e:	f8 01       	movw	r30, r16
    42a0:	dc 01       	movw	r26, r24
    42a2:	79 01       	movw	r14, r18
    42a4:	00 e0       	ldi	r16, 0x00	; 0
    42a6:	10 e0       	ldi	r17, 0x00	; 0
	} while(x>Segm.x2);
    42a8:	ea 14       	cp	r14, r10
    42aa:	fb 04       	cpc	r15, r11
    42ac:	0c 05       	cpc	r16, r12
    42ae:	1d 05       	cpc	r17, r13
    42b0:	78 f3       	brcs	.-34     	; 0x4290 <PGM_uBrokLine+0x38>
    42b2:	ca 01       	movw	r24, r20
    42b4:	9b 01       	movw	r18, r22
    42b6:	af 01       	movw	r20, r30
    42b8:	69 83       	std	Y+1, r22	; 0x01
    42ba:	3a 83       	std	Y+2, r19	; 0x02
    42bc:	eb 83       	std	Y+3, r30	; 0x03
    42be:	5c 83       	std	Y+4, r21	; 0x04
    42c0:	ed 82       	std	Y+5, r14	; 0x05
    42c2:	fe 82       	std	Y+6, r15	; 0x06
    42c4:	0f 83       	std	Y+7, r16	; 0x07
    42c6:	18 87       	std	Y+8, r17	; 0x08
    42c8:	fc 01       	movw	r30, r24
    42ca:	32 96       	adiw	r30, 0x02	; 2
    42cc:	85 91       	lpm	r24, Z+
    42ce:	94 91       	lpm	r25, Z+
	Segm.y1 = (int16_t)prw(&(Brok-1)->y);
    42d0:	9a 87       	std	Y+10, r25	; 0x0a
    42d2:	89 87       	std	Y+9, r24	; 0x09
    42d4:	fd 01       	movw	r30, r26
    42d6:	32 96       	adiw	r30, 0x02	; 2
    42d8:	85 91       	lpm	r24, Z+
    42da:	94 91       	lpm	r25, Z+
	Segm.y2 = (int16_t)prw(&Brok->y);
    42dc:	9c 87       	std	Y+12, r25	; 0x0c
    42de:	8b 87       	std	Y+11, r24	; 0x0b
	return uLineFunc(&Segm, x);
    42e0:	ce 01       	movw	r24, r28
    42e2:	01 96       	adiw	r24, 0x01	; 1
    42e4:	b6 01       	movw	r22, r12
    42e6:	a5 01       	movw	r20, r10
    42e8:	0e 94 ae 20 	call	0x415c	; 0x415c <uLineFunc>
}
    42ec:	2c 96       	adiw	r28, 0x0c	; 12
    42ee:	0f b6       	in	r0, 0x3f	; 63
    42f0:	f8 94       	cli
    42f2:	de bf       	out	0x3e, r29	; 62
    42f4:	0f be       	out	0x3f, r0	; 63
    42f6:	cd bf       	out	0x3d, r28	; 61
    42f8:	cf 91       	pop	r28
    42fa:	df 91       	pop	r29
    42fc:	1f 91       	pop	r17
    42fe:	0f 91       	pop	r16
    4300:	ff 90       	pop	r15
    4302:	ef 90       	pop	r14
    4304:	df 90       	pop	r13
    4306:	cf 90       	pop	r12
    4308:	bf 90       	pop	r11
    430a:	af 90       	pop	r10
    430c:	08 95       	ret

0000430e <InterBrokLine>:
	uint8_t WiAbsc, int16_t (*TblAbsc)[WiAbsc], uint8_t Absc,
	uint8_t WiOrdi, int16_t (*TblOrdi)[WiOrdi], uint8_t Ordi,
	uint8_t Len,
	int16_t x
)
{
    430e:	2f 92       	push	r2
    4310:	3f 92       	push	r3
    4312:	4f 92       	push	r4
    4314:	5f 92       	push	r5
    4316:	6f 92       	push	r6
    4318:	7f 92       	push	r7
    431a:	8f 92       	push	r8
    431c:	9f 92       	push	r9
    431e:	af 92       	push	r10
    4320:	bf 92       	push	r11
    4322:	cf 92       	push	r12
    4324:	df 92       	push	r13
    4326:	ef 92       	push	r14
    4328:	ff 92       	push	r15
    432a:	0f 93       	push	r16
    432c:	1f 93       	push	r17
    432e:	df 93       	push	r29
    4330:	cf 93       	push	r28
    4332:	cd b7       	in	r28, 0x3d	; 61
    4334:	de b7       	in	r29, 0x3e	; 62
    4336:	2e 97       	sbiw	r28, 0x0e	; 14
    4338:	0f b6       	in	r0, 0x3f	; 63
    433a:	f8 94       	cli
    433c:	de bf       	out	0x3e, r29	; 62
    433e:	0f be       	out	0x3f, r0	; 63
    4340:	cd bf       	out	0x3d, r28	; 61
    4342:	2b 01       	movw	r4, r22
    4344:	2d 87       	std	Y+13, r18	; 0x0d
    4346:	18 01       	movw	r2, r16
    4348:	ee 86       	std	Y+14, r14	; 0x0e
    434a:	7c 2d       	mov	r23, r12
	LineGraph Segm;
	uint8_t i = 0;
	Segm.x2=TblAbsc[0][Absc];
    434c:	c4 2e       	mov	r12, r20
    434e:	dd 24       	eor	r13, r13
    4350:	cc 0c       	add	r12, r12
    4352:	dd 1c       	adc	r13, r13
    4354:	f2 01       	movw	r30, r4
    4356:	ec 0d       	add	r30, r12
    4358:	fd 1d       	adc	r31, r13
    435a:	20 81       	ld	r18, Z
    435c:	31 81       	ldd	r19, Z+1	; 0x01
    435e:	79 01       	movw	r14, r18
    4360:	00 27       	eor	r16, r16
    4362:	f7 fc       	sbrc	r15, 7
    4364:	00 95       	com	r16
    4366:	10 2f       	mov	r17, r16
    4368:	ed 82       	std	Y+5, r14	; 0x05
    436a:	fe 82       	std	Y+6, r15	; 0x06
    436c:	0f 83       	std	Y+7, r16	; 0x07
    436e:	18 87       	std	Y+8, r17	; 0x08
    4370:	a8 2f       	mov	r26, r24
    4372:	b0 e0       	ldi	r27, 0x00	; 0
    4374:	aa 0f       	add	r26, r26
    4376:	bb 1f       	adc	r27, r27
    4378:	35 01       	movw	r6, r10
    437a:	88 24       	eor	r8, r8
    437c:	77 fc       	sbrc	r7, 7
    437e:	80 94       	com	r8
    4380:	98 2c       	mov	r9, r8
    4382:	60 e0       	ldi	r22, 0x00	; 0
    4384:	02 c0       	rjmp	.+4      	; 0x438a <InterBrokLine+0x7c>
	do {
		Segm.x1 = Segm.x2;
		Segm.x2 = TblAbsc[++i][Absc];
	} while(x>Segm.x2 && i<Len);
    4386:	79 01       	movw	r14, r18
    4388:	8a 01       	movw	r16, r20
	LineGraph Segm;
	uint8_t i = 0;
	Segm.x2=TblAbsc[0][Absc];
	do {
		Segm.x1 = Segm.x2;
		Segm.x2 = TblAbsc[++i][Absc];
    438a:	6f 5f       	subi	r22, 0xFF	; 255
    438c:	a6 2e       	mov	r10, r22
    438e:	bb 24       	eor	r11, r11
    4390:	aa 9e       	mul	r10, r26
    4392:	f0 01       	movw	r30, r0
    4394:	ab 9e       	mul	r10, r27
    4396:	f0 0d       	add	r31, r0
    4398:	ba 9e       	mul	r11, r26
    439a:	f0 0d       	add	r31, r0
    439c:	11 24       	eor	r1, r1
    439e:	e4 0d       	add	r30, r4
    43a0:	f5 1d       	adc	r31, r5
    43a2:	ec 0d       	add	r30, r12
    43a4:	fd 1d       	adc	r31, r13
    43a6:	80 81       	ld	r24, Z
    43a8:	91 81       	ldd	r25, Z+1	; 0x01
    43aa:	9c 01       	movw	r18, r24
    43ac:	44 27       	eor	r20, r20
    43ae:	37 fd       	sbrc	r19, 7
    43b0:	40 95       	com	r20
    43b2:	54 2f       	mov	r21, r20
	} while(x>Segm.x2 && i<Len);
    43b4:	26 15       	cp	r18, r6
    43b6:	37 05       	cpc	r19, r7
    43b8:	48 05       	cpc	r20, r8
    43ba:	59 05       	cpc	r21, r9
    43bc:	14 f4       	brge	.+4      	; 0x43c2 <InterBrokLine+0xb4>
    43be:	67 17       	cp	r22, r23
    43c0:	10 f3       	brcs	.-60     	; 0x4386 <InterBrokLine+0x78>
    43c2:	e9 82       	std	Y+1, r14	; 0x01
    43c4:	fa 82       	std	Y+2, r15	; 0x02
    43c6:	0b 83       	std	Y+3, r16	; 0x03
    43c8:	1c 83       	std	Y+4, r17	; 0x04
    43ca:	2d 83       	std	Y+5, r18	; 0x05
    43cc:	3e 83       	std	Y+6, r19	; 0x06
    43ce:	4f 83       	std	Y+7, r20	; 0x07
    43d0:	58 87       	std	Y+8, r21	; 0x08
	Segm.y1 = TblOrdi[i-1][Ordi];
    43d2:	8d 85       	ldd	r24, Y+13	; 0x0d
    43d4:	28 2f       	mov	r18, r24
    43d6:	30 e0       	ldi	r19, 0x00	; 0
    43d8:	22 0f       	add	r18, r18
    43da:	33 1f       	adc	r19, r19
    43dc:	8e 85       	ldd	r24, Y+14	; 0x0e
    43de:	a8 2f       	mov	r26, r24
    43e0:	b0 e0       	ldi	r27, 0x00	; 0
    43e2:	08 94       	sec
    43e4:	a1 08       	sbc	r10, r1
    43e6:	b1 08       	sbc	r11, r1
    43e8:	a2 9e       	mul	r10, r18
    43ea:	f0 01       	movw	r30, r0
    43ec:	a3 9e       	mul	r10, r19
    43ee:	f0 0d       	add	r31, r0
    43f0:	b2 9e       	mul	r11, r18
    43f2:	f0 0d       	add	r31, r0
    43f4:	11 24       	eor	r1, r1
    43f6:	08 94       	sec
    43f8:	a1 1c       	adc	r10, r1
    43fa:	b1 1c       	adc	r11, r1
    43fc:	e2 0d       	add	r30, r2
    43fe:	f3 1d       	adc	r31, r3
    4400:	aa 0f       	add	r26, r26
    4402:	bb 1f       	adc	r27, r27
    4404:	ea 0f       	add	r30, r26
    4406:	fb 1f       	adc	r31, r27
    4408:	80 81       	ld	r24, Z
    440a:	91 81       	ldd	r25, Z+1	; 0x01
    440c:	9a 87       	std	Y+10, r25	; 0x0a
    440e:	89 87       	std	Y+9, r24	; 0x09
	Segm.y2 = TblOrdi[i][Ordi];
    4410:	a2 9e       	mul	r10, r18
    4412:	c0 01       	movw	r24, r0
    4414:	a3 9e       	mul	r10, r19
    4416:	90 0d       	add	r25, r0
    4418:	b2 9e       	mul	r11, r18
    441a:	90 0d       	add	r25, r0
    441c:	11 24       	eor	r1, r1
    441e:	82 0d       	add	r24, r2
    4420:	93 1d       	adc	r25, r3
    4422:	a8 0f       	add	r26, r24
    4424:	b9 1f       	adc	r27, r25
    4426:	8d 91       	ld	r24, X+
    4428:	9c 91       	ld	r25, X
    442a:	9c 87       	std	Y+12, r25	; 0x0c
    442c:	8b 87       	std	Y+11, r24	; 0x0b
	return LineFunc(&Segm, x);
    442e:	ce 01       	movw	r24, r28
    4430:	01 96       	adiw	r24, 0x01	; 1
    4432:	b4 01       	movw	r22, r8
    4434:	a3 01       	movw	r20, r6
    4436:	0e 94 30 20 	call	0x4060	; 0x4060 <LineFunc>
}
    443a:	2e 96       	adiw	r28, 0x0e	; 14
    443c:	0f b6       	in	r0, 0x3f	; 63
    443e:	f8 94       	cli
    4440:	de bf       	out	0x3e, r29	; 62
    4442:	0f be       	out	0x3f, r0	; 63
    4444:	cd bf       	out	0x3d, r28	; 61
    4446:	cf 91       	pop	r28
    4448:	df 91       	pop	r29
    444a:	1f 91       	pop	r17
    444c:	0f 91       	pop	r16
    444e:	ff 90       	pop	r15
    4450:	ef 90       	pop	r14
    4452:	df 90       	pop	r13
    4454:	cf 90       	pop	r12
    4456:	bf 90       	pop	r11
    4458:	af 90       	pop	r10
    445a:	9f 90       	pop	r9
    445c:	8f 90       	pop	r8
    445e:	7f 90       	pop	r7
    4460:	6f 90       	pop	r6
    4462:	5f 90       	pop	r5
    4464:	4f 90       	pop	r4
    4466:	3f 90       	pop	r3
    4468:	2f 90       	pop	r2
    446a:	08 95       	ret

0000446c <TWI_Init>:
}

uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    446c:	90 91 cc 02 	lds	r25, 0x02CC
	VacantTimer8Sys += n;
    4470:	89 2f       	mov	r24, r25
    4472:	8f 5f       	subi	r24, 0xFF	; 255

// ~~~~~~~~~~~
void
TWI_Init(void)
{
	TD_TWI_Poll = Timer8SysAlloc(1);
    4474:	90 93 c9 04 	sts	0x04C9, r25
    4478:	8f 5f       	subi	r24, 0xFF	; 255
    447a:	80 93 cc 02 	sts	0x02CC, r24
    447e:	81 50       	subi	r24, 0x01	; 1
	TD_TWI_Timeout = Timer8SysAlloc(1);
    4480:	80 93 ca 04 	sts	0x04CA, r24

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    4484:	80 91 cd 02 	lds	r24, 0x02CD
	VacantTimer16Sys += n;
    4488:	8f 5f       	subi	r24, 0xFF	; 255
    448a:	80 93 cd 02 	sts	0x02CD, r24
    448e:	81 50       	subi	r24, 0x01	; 1
	TD_RTC_Check = Timer16SysAlloc(1);
    4490:	80 93 cb 04 	sts	0x04CB, r24
	StartTimer16(TD_RTC_Check, 300);
    4494:	6c e2       	ldi	r22, 0x2C	; 44
    4496:	71 e0       	ldi	r23, 0x01	; 1
    4498:	0e 94 05 1a 	call	0x340a	; 0x340a <StartTimer16>
	TWBR = 144;	//50
    449c:	80 e9       	ldi	r24, 0x90	; 144
    449e:	80 93 b8 00 	sts	0x00B8, r24
}
    44a2:	08 95       	ret

000044a4 <TWI_Error>:
// ~~~~~~~~~~~
void
TWI_Error(void)
{
	TWI_Error_Counter++;
    44a4:	80 91 93 08 	lds	r24, 0x0893
    44a8:	90 91 94 08 	lds	r25, 0x0894
    44ac:	01 96       	adiw	r24, 0x01	; 1
    44ae:	90 93 94 08 	sts	0x0894, r25
    44b2:	80 93 93 08 	sts	0x0893, r24
	//StopTWI();
	PowerOffTWI();
    44b6:	10 92 bc 00 	sts	0x00BC, r1
	TWI_Phase = PCF_START;
    44ba:	10 92 73 07 	sts	0x0773, r1
	StartTimer8(TD_TWI_Poll, 49);
    44be:	80 91 c9 04 	lds	r24, 0x04C9
    44c2:	61 e3       	ldi	r22, 0x31	; 49
    44c4:	0e 94 ca 19 	call	0x3394	; 0x3394 <StartTimer8>
}
    44c8:	08 95       	ret

000044ca <WriteRTC>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
WriteRTC(uint8_t Addr, uint8_t Dat)
{
    44ca:	bf 92       	push	r11
    44cc:	cf 92       	push	r12
    44ce:	df 92       	push	r13
    44d0:	ef 92       	push	r14
    44d2:	ff 92       	push	r15
    44d4:	0f 93       	push	r16
    44d6:	1f 93       	push	r17
/*	if (!(TWCR &(1<<TWINT))){ //Wait for the end of current TWI operation and isuue STOP
		_delay_us(100);
		StopTWI();
		_delay_us(50);
	}*/
	PowerOffTWI();
    44d8:	4c eb       	ldi	r20, 0xBC	; 188
    44da:	c4 2e       	mov	r12, r20
    44dc:	d1 2c       	mov	r13, r1
    44de:	f6 01       	movw	r30, r12
    44e0:	10 82       	st	Z, r1
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    44e2:	e0 e9       	ldi	r30, 0x90	; 144
    44e4:	f1 e0       	ldi	r31, 0x01	; 1
    44e6:	31 97       	sbiw	r30, 0x01	; 1
    44e8:	f1 f7       	brne	.-4      	; 0x44e6 <WriteRTC+0x1c>
	_delay_us(100);
	//_delay_us(150);_delay_us(150);
	StartTWI();
    44ea:	94 ea       	ldi	r25, 0xA4	; 164
    44ec:	f6 01       	movw	r30, r12
    44ee:	90 83       	st	Z, r25
    44f0:	08 e5       	ldi	r16, 0x58	; 88
    44f2:	12 e0       	ldi	r17, 0x02	; 2
    44f4:	f8 01       	movw	r30, r16
    44f6:	31 97       	sbiw	r30, 0x01	; 1
    44f8:	f1 f7       	brne	.-4      	; 0x44f6 <WriteRTC+0x2c>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = SLA_W(PCF_SLA);
    44fa:	f8 01       	movw	r30, r16
    44fc:	31 97       	sbiw	r30, 0x01	; 1
    44fe:	f1 f7       	brne	.-4      	; 0x44fc <WriteRTC+0x32>
    4500:	3b eb       	ldi	r19, 0xBB	; 187
    4502:	e3 2e       	mov	r14, r19
    4504:	f1 2c       	mov	r15, r1
    4506:	90 ed       	ldi	r25, 0xD0	; 208
    4508:	f7 01       	movw	r30, r14
    450a:	90 83       	st	Z, r25
    450c:	90 81       	ld	r25, Z
    450e:	90 83       	st	Z, r25
	RunTWI();
    4510:	24 e8       	ldi	r18, 0x84	; 132
    4512:	b2 2e       	mov	r11, r18
    4514:	f6 01       	movw	r30, r12
    4516:	b0 82       	st	Z, r11
    4518:	f8 01       	movw	r30, r16
    451a:	31 97       	sbiw	r30, 0x01	; 1
    451c:	f1 f7       	brne	.-4      	; 0x451a <WriteRTC+0x50>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = AddrSec+Addr;
    451e:	f8 01       	movw	r30, r16
    4520:	31 97       	sbiw	r30, 0x01	; 1
    4522:	f1 f7       	brne	.-4      	; 0x4520 <WriteRTC+0x56>
    4524:	f7 01       	movw	r30, r14
    4526:	80 83       	st	Z, r24
	RunTWI();
    4528:	f6 01       	movw	r30, r12
    452a:	b0 82       	st	Z, r11
    452c:	c8 01       	movw	r24, r16
    452e:	01 97       	sbiw	r24, 0x01	; 1
    4530:	f1 f7       	brne	.-4      	; 0x452e <WriteRTC+0x64>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = CodBCD(Dat);
    4532:	c8 01       	movw	r24, r16
    4534:	01 97       	sbiw	r24, 0x01	; 1
    4536:	f1 f7       	brne	.-4      	; 0x4534 <WriteRTC+0x6a>
    4538:	86 2f       	mov	r24, r22
    453a:	0e 94 19 20 	call	0x4032	; 0x4032 <CodBCD>
    453e:	f7 01       	movw	r30, r14
    4540:	80 83       	st	Z, r24
	RunTWI();
    4542:	f6 01       	movw	r30, r12
    4544:	b0 82       	st	Z, r11
    4546:	c8 01       	movw	r24, r16
    4548:	01 97       	sbiw	r24, 0x01	; 1
    454a:	f1 f7       	brne	.-4      	; 0x4548 <WriteRTC+0x7e>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	StopTWI();
    454c:	c8 01       	movw	r24, r16
    454e:	01 97       	sbiw	r24, 0x01	; 1
    4550:	f1 f7       	brne	.-4      	; 0x454e <WriteRTC+0x84>
    4552:	84 e9       	ldi	r24, 0x94	; 148
    4554:	80 83       	st	Z, r24
	TWI_Phase = PCF_START;
    4556:	10 92 73 07 	sts	0x0773, r1
}
    455a:	1f 91       	pop	r17
    455c:	0f 91       	pop	r16
    455e:	ff 90       	pop	r15
    4560:	ef 90       	pop	r14
    4562:	df 90       	pop	r13
    4564:	cf 90       	pop	r12
    4566:	bf 90       	pop	r11
    4568:	08 95       	ret

0000456a <SetWeekday>:
*/

// ~~~~~~~~~~~~~~~
// 31.12.00 was Su
uint8_t SetWeekday(uint8_t Year, uint8_t Month, uint8_t MDay)
{
    456a:	a6 2f       	mov	r26, r22
	uint8_t DayCount;
	uint8_t LastYear = Year-1;
    456c:	b8 2f       	mov	r27, r24
    456e:	b1 50       	subi	r27, 0x01	; 1

	DayCount = (LastYear+LastYear/4);
    4570:	5b 2f       	mov	r21, r27
    4572:	56 95       	lsr	r21
    4574:	56 95       	lsr	r21
    4576:	5b 0f       	add	r21, r27
	for (uint8_t i=1; i<Month; DayCount+=prb(DaysMonth+i++)%7);
    4578:	62 30       	cpi	r22, 0x02	; 2
    457a:	88 f0       	brcs	.+34     	; 0x459e <SetWeekday+0x34>
    457c:	e6 ef       	ldi	r30, 0xF6	; 246
    457e:	f2 e0       	ldi	r31, 0x02	; 2
    4580:	a2 50       	subi	r26, 0x02	; 2
    4582:	2a 2f       	mov	r18, r26
    4584:	30 e0       	ldi	r19, 0x00	; 0
    4586:	ae 5f       	subi	r26, 0xFE	; 254
    4588:	29 50       	subi	r18, 0x09	; 9
    458a:	3d 4f       	sbci	r19, 0xFD	; 253

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    458c:	84 91       	lpm	r24, Z+
    458e:	67 e0       	ldi	r22, 0x07	; 7
    4590:	0e 94 5e 7d 	call	0xfabc	; 0xfabc <__udivmodqi4>
    4594:	59 0f       	add	r21, r25
    4596:	31 96       	adiw	r30, 0x01	; 1
    4598:	e2 17       	cp	r30, r18
    459a:	f3 07       	cpc	r31, r19
    459c:	b9 f7       	brne	.-18     	; 0x458c <SetWeekday+0x22>
    459e:	25 2f       	mov	r18, r21
	if (LastYear%4==3 && Month>2)
    45a0:	b3 70       	andi	r27, 0x03	; 3
    45a2:	b3 30       	cpi	r27, 0x03	; 3
    45a4:	51 f0       	breq	.+20     	; 0x45ba <SetWeekday+0x50>
		DayCount++;
    45a6:	84 2f       	mov	r24, r20
    45a8:	67 e0       	ldi	r22, 0x07	; 7
    45aa:	0e 94 5e 7d 	call	0xfabc	; 0xfabc <__udivmodqi4>
    45ae:	82 2f       	mov	r24, r18
    45b0:	89 0f       	add	r24, r25
    45b2:	0e 94 5e 7d 	call	0xfabc	; 0xfabc <__udivmodqi4>
	DayCount += MDay%7;
	return DayCount%7;
}
    45b6:	89 2f       	mov	r24, r25
    45b8:	08 95       	ret
	uint8_t DayCount;
	uint8_t LastYear = Year-1;

	DayCount = (LastYear+LastYear/4);
	for (uint8_t i=1; i<Month; DayCount+=prb(DaysMonth+i++)%7);
	if (LastYear%4==3 && Month>2)
    45ba:	a3 30       	cpi	r26, 0x03	; 3
    45bc:	a0 f3       	brcs	.-24     	; 0x45a6 <SetWeekday+0x3c>
		DayCount++;
    45be:	2f 5f       	subi	r18, 0xFF	; 255
    45c0:	f2 cf       	rjmp	.-28     	; 0x45a6 <SetWeekday+0x3c>

000045c2 <SetSec>:
}
// ~~~~~~~~~
void
SetSec(void)
{
	WriteRTC(0, Tm_Sec);
    45c2:	80 e0       	ldi	r24, 0x00	; 0
    45c4:	60 91 ad 06 	lds	r22, 0x06AD
    45c8:	0e 94 65 22 	call	0x44ca	; 0x44ca <WriteRTC>
	TrueTime_Sec = Tm_Sec;
    45cc:	80 91 ad 06 	lds	r24, 0x06AD
    45d0:	80 93 c2 08 	sts	0x08C2, r24
}
    45d4:	08 95       	ret

000045d6 <SetMin>:

// ~~~~~~~~~
void
SetMin(void)
{
	WriteRTC(1, Tm_Min);
    45d6:	81 e0       	ldi	r24, 0x01	; 1
    45d8:	60 91 48 06 	lds	r22, 0x0648
    45dc:	0e 94 65 22 	call	0x44ca	; 0x44ca <WriteRTC>
	TrueTime_Min = Tm_Min;
    45e0:	80 91 48 06 	lds	r24, 0x0648
    45e4:	80 93 c4 08 	sts	0x08C4, r24
}
    45e8:	08 95       	ret

000045ea <SetHour>:

// ~~~~~~~~~~
void
SetHour(void)
{
	WriteRTC(2,  Tm_Hour);
    45ea:	82 e0       	ldi	r24, 0x02	; 2
    45ec:	60 91 b8 05 	lds	r22, 0x05B8
    45f0:	0e 94 65 22 	call	0x44ca	; 0x44ca <WriteRTC>
	TrueTime_Hour = Tm_Hour;
    45f4:	80 91 b8 05 	lds	r24, 0x05B8
    45f8:	80 93 cf 05 	sts	0x05CF, r24
}
    45fc:	08 95       	ret

000045fe <SetMDay>:
// ~~~~~~~~~~
void
SetMDay(void)
{
	WriteRTC(4,  Tm_MDay);
    45fe:	84 e0       	ldi	r24, 0x04	; 4
    4600:	60 91 0d 0b 	lds	r22, 0x0B0D
    4604:	0e 94 65 22 	call	0x44ca	; 0x44ca <WriteRTC>
	TrueTime_MDay = Tm_MDay;
    4608:	80 91 0d 0b 	lds	r24, 0x0B0D
    460c:	80 93 4d 06 	sts	0x064D, r24
}
    4610:	08 95       	ret

00004612 <SetMon>:
// ~~~~~~~~~
void
SetMon(void)
{
	WriteRTC(5, Tm_Mon);
    4612:	85 e0       	ldi	r24, 0x05	; 5
    4614:	60 91 7b 07 	lds	r22, 0x077B
    4618:	0e 94 65 22 	call	0x44ca	; 0x44ca <WriteRTC>
	TrueTime_Mon = Tm_Mon;
    461c:	80 91 7b 07 	lds	r24, 0x077B
    4620:	80 93 c3 08 	sts	0x08C3, r24
}
    4624:	08 95       	ret

00004626 <SetYear>:
// ~~~~~~~~~~~~~
void
SetYear(void)
{
	WriteRTC(6, Tm_Year);
    4626:	86 e0       	ldi	r24, 0x06	; 6
    4628:	60 91 d5 05 	lds	r22, 0x05D5
    462c:	0e 94 65 22 	call	0x44ca	; 0x44ca <WriteRTC>
	TrueTime_Year = Tm_Year;
    4630:	80 91 d5 05 	lds	r24, 0x05D5
    4634:	80 93 71 07 	sts	0x0771, r24
}
    4638:	08 95       	ret

0000463a <SetDateTime>:
// ~~~~~~~~~~~~~
void
SetDateTime(uint8_t Year, uint8_t Month, uint8_t Day, uint8_t WDay, uint8_t Hour, uint8_t Min, uint8_t Sec){
    463a:	5f 92       	push	r5
    463c:	6f 92       	push	r6
    463e:	7f 92       	push	r7
    4640:	8f 92       	push	r8
    4642:	9f 92       	push	r9
    4644:	af 92       	push	r10
    4646:	bf 92       	push	r11
    4648:	cf 92       	push	r12
    464a:	df 92       	push	r13
    464c:	ef 92       	push	r14
    464e:	ff 92       	push	r15
    4650:	0f 93       	push	r16
    4652:	1f 93       	push	r17
    4654:	58 2e       	mov	r5, r24
    4656:	66 2e       	mov	r6, r22
    4658:	74 2e       	mov	r7, r20
    465a:	f2 2e       	mov	r15, r18
    465c:	8c 2d       	mov	r24, r12
	PowerOffTWI();
    465e:	7c eb       	ldi	r23, 0xBC	; 188
    4660:	87 2e       	mov	r8, r23
    4662:	91 2c       	mov	r9, r1
    4664:	f4 01       	movw	r30, r8
    4666:	10 82       	st	Z, r1
    4668:	e0 e9       	ldi	r30, 0x90	; 144
    466a:	f1 e0       	ldi	r31, 0x01	; 1
    466c:	31 97       	sbiw	r30, 0x01	; 1
    466e:	f1 f7       	brne	.-4      	; 0x466c <SetDateTime+0x32>
	_delay_us(100);
	//_delay_us(150);_delay_us(150);
	StartTWI();
    4670:	94 ea       	ldi	r25, 0xA4	; 164
    4672:	f4 01       	movw	r30, r8
    4674:	90 83       	st	Z, r25
    4676:	68 e5       	ldi	r22, 0x58	; 88
    4678:	c6 2e       	mov	r12, r22
    467a:	62 e0       	ldi	r22, 0x02	; 2
    467c:	d6 2e       	mov	r13, r22
    467e:	f6 01       	movw	r30, r12
    4680:	31 97       	sbiw	r30, 0x01	; 1
    4682:	f1 f7       	brne	.-4      	; 0x4680 <SetDateTime+0x46>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = SLA_W(PCF_SLA);
    4684:	f6 01       	movw	r30, r12
    4686:	31 97       	sbiw	r30, 0x01	; 1
    4688:	f1 f7       	brne	.-4      	; 0x4686 <SetDateTime+0x4c>
    468a:	5b eb       	ldi	r21, 0xBB	; 187
    468c:	a5 2e       	mov	r10, r21
    468e:	b1 2c       	mov	r11, r1
    4690:	90 ed       	ldi	r25, 0xD0	; 208
    4692:	f5 01       	movw	r30, r10
    4694:	90 83       	st	Z, r25
    4696:	90 81       	ld	r25, Z
    4698:	90 83       	st	Z, r25
	RunTWI();
    469a:	14 e8       	ldi	r17, 0x84	; 132
    469c:	f4 01       	movw	r30, r8
    469e:	10 83       	st	Z, r17
    46a0:	f6 01       	movw	r30, r12
    46a2:	31 97       	sbiw	r30, 0x01	; 1
    46a4:	f1 f7       	brne	.-4      	; 0x46a2 <SetDateTime+0x68>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = AddrSec;
    46a6:	f6 01       	movw	r30, r12
    46a8:	31 97       	sbiw	r30, 0x01	; 1
    46aa:	f1 f7       	brne	.-4      	; 0x46a8 <SetDateTime+0x6e>
    46ac:	f5 01       	movw	r30, r10
    46ae:	10 82       	st	Z, r1
	RunTWI();
    46b0:	f4 01       	movw	r30, r8
    46b2:	10 83       	st	Z, r17
    46b4:	f6 01       	movw	r30, r12
    46b6:	31 97       	sbiw	r30, 0x01	; 1
    46b8:	f1 f7       	brne	.-4      	; 0x46b6 <SetDateTime+0x7c>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = CodBCD(Sec);
    46ba:	f6 01       	movw	r30, r12
    46bc:	31 97       	sbiw	r30, 0x01	; 1
    46be:	f1 f7       	brne	.-4      	; 0x46bc <SetDateTime+0x82>
    46c0:	0e 94 19 20 	call	0x4032	; 0x4032 <CodBCD>
    46c4:	f5 01       	movw	r30, r10
    46c6:	80 83       	st	Z, r24
	RunTWI();
    46c8:	f4 01       	movw	r30, r8
    46ca:	10 83       	st	Z, r17
    46cc:	c6 01       	movw	r24, r12
    46ce:	01 97       	sbiw	r24, 0x01	; 1
    46d0:	f1 f7       	brne	.-4      	; 0x46ce <SetDateTime+0x94>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = CodBCD(Min);
    46d2:	c6 01       	movw	r24, r12
    46d4:	01 97       	sbiw	r24, 0x01	; 1
    46d6:	f1 f7       	brne	.-4      	; 0x46d4 <SetDateTime+0x9a>
    46d8:	8e 2d       	mov	r24, r14
    46da:	0e 94 19 20 	call	0x4032	; 0x4032 <CodBCD>
    46de:	f5 01       	movw	r30, r10
    46e0:	80 83       	st	Z, r24
	RunTWI();
    46e2:	f4 01       	movw	r30, r8
    46e4:	10 83       	st	Z, r17
    46e6:	c6 01       	movw	r24, r12
    46e8:	01 97       	sbiw	r24, 0x01	; 1
    46ea:	f1 f7       	brne	.-4      	; 0x46e8 <SetDateTime+0xae>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = CodBCD(Hour);
    46ec:	c6 01       	movw	r24, r12
    46ee:	01 97       	sbiw	r24, 0x01	; 1
    46f0:	f1 f7       	brne	.-4      	; 0x46ee <SetDateTime+0xb4>
    46f2:	80 2f       	mov	r24, r16
    46f4:	0e 94 19 20 	call	0x4032	; 0x4032 <CodBCD>
    46f8:	f5 01       	movw	r30, r10
    46fa:	80 83       	st	Z, r24
	RunTWI();
    46fc:	f4 01       	movw	r30, r8
    46fe:	10 83       	st	Z, r17
    4700:	c6 01       	movw	r24, r12
    4702:	01 97       	sbiw	r24, 0x01	; 1
    4704:	f1 f7       	brne	.-4      	; 0x4702 <SetDateTime+0xc8>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = WDay;
    4706:	c6 01       	movw	r24, r12
    4708:	01 97       	sbiw	r24, 0x01	; 1
    470a:	f1 f7       	brne	.-4      	; 0x4708 <SetDateTime+0xce>
    470c:	f5 01       	movw	r30, r10
    470e:	f0 82       	st	Z, r15
	RunTWI();
    4710:	f4 01       	movw	r30, r8
    4712:	10 83       	st	Z, r17
    4714:	c6 01       	movw	r24, r12
    4716:	01 97       	sbiw	r24, 0x01	; 1
    4718:	f1 f7       	brne	.-4      	; 0x4716 <SetDateTime+0xdc>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = CodBCD(Day);
    471a:	c6 01       	movw	r24, r12
    471c:	01 97       	sbiw	r24, 0x01	; 1
    471e:	f1 f7       	brne	.-4      	; 0x471c <SetDateTime+0xe2>
    4720:	87 2d       	mov	r24, r7
    4722:	0e 94 19 20 	call	0x4032	; 0x4032 <CodBCD>
    4726:	f5 01       	movw	r30, r10
    4728:	80 83       	st	Z, r24
	RunTWI();
    472a:	f4 01       	movw	r30, r8
    472c:	10 83       	st	Z, r17
    472e:	c6 01       	movw	r24, r12
    4730:	01 97       	sbiw	r24, 0x01	; 1
    4732:	f1 f7       	brne	.-4      	; 0x4730 <SetDateTime+0xf6>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = CodBCD(Month);
    4734:	c6 01       	movw	r24, r12
    4736:	01 97       	sbiw	r24, 0x01	; 1
    4738:	f1 f7       	brne	.-4      	; 0x4736 <SetDateTime+0xfc>
    473a:	86 2d       	mov	r24, r6
    473c:	0e 94 19 20 	call	0x4032	; 0x4032 <CodBCD>
    4740:	f5 01       	movw	r30, r10
    4742:	80 83       	st	Z, r24
	RunTWI();
    4744:	f4 01       	movw	r30, r8
    4746:	10 83       	st	Z, r17
    4748:	c6 01       	movw	r24, r12
    474a:	01 97       	sbiw	r24, 0x01	; 1
    474c:	f1 f7       	brne	.-4      	; 0x474a <SetDateTime+0x110>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = CodBCD(Year);
    474e:	c6 01       	movw	r24, r12
    4750:	01 97       	sbiw	r24, 0x01	; 1
    4752:	f1 f7       	brne	.-4      	; 0x4750 <SetDateTime+0x116>
    4754:	85 2d       	mov	r24, r5
    4756:	0e 94 19 20 	call	0x4032	; 0x4032 <CodBCD>
    475a:	f5 01       	movw	r30, r10
    475c:	80 83       	st	Z, r24
	RunTWI();
    475e:	f4 01       	movw	r30, r8
    4760:	10 83       	st	Z, r17
    4762:	c6 01       	movw	r24, r12
    4764:	01 97       	sbiw	r24, 0x01	; 1
    4766:	f1 f7       	brne	.-4      	; 0x4764 <SetDateTime+0x12a>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	StopTWI();
    4768:	c6 01       	movw	r24, r12
    476a:	01 97       	sbiw	r24, 0x01	; 1
    476c:	f1 f7       	brne	.-4      	; 0x476a <SetDateTime+0x130>
    476e:	84 e9       	ldi	r24, 0x94	; 148
    4770:	80 83       	st	Z, r24
	TWI_Phase = PCF_START;
    4772:	10 92 73 07 	sts	0x0773, r1
}
    4776:	1f 91       	pop	r17
    4778:	0f 91       	pop	r16
    477a:	ff 90       	pop	r15
    477c:	ef 90       	pop	r14
    477e:	df 90       	pop	r13
    4780:	cf 90       	pop	r12
    4782:	bf 90       	pop	r11
    4784:	af 90       	pop	r10
    4786:	9f 90       	pop	r9
    4788:	8f 90       	pop	r8
    478a:	7f 90       	pop	r7
    478c:	6f 90       	pop	r6
    478e:	5f 90       	pop	r5
    4790:	08 95       	ret

00004792 <RTC_Ready>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t RTC_Ready(void){
    4792:	90 e0       	ldi	r25, 0x00	; 0
    4794:	80 91 73 07 	lds	r24, 0x0773
    4798:	88 23       	and	r24, r24
    479a:	09 f4       	brne	.+2      	; 0x479e <RTC_Ready+0xc>
    479c:	91 e0       	ldi	r25, 0x01	; 1
	if(TWI_Phase == PCF_START) return 1;
	else return 0;
}
    479e:	89 2f       	mov	r24, r25
    47a0:	08 95       	ret

000047a2 <RTC_GetTrueTime>:
void RTC_GetTrueTime(void){
	TrueTime_Sec = Tm_Sec;
    47a2:	80 91 ad 06 	lds	r24, 0x06AD
    47a6:	80 93 c2 08 	sts	0x08C2, r24
	TrueTime_Min = Tm_Min;
    47aa:	80 91 48 06 	lds	r24, 0x0648
    47ae:	80 93 c4 08 	sts	0x08C4, r24
	TrueTime_Hour = Tm_Hour;
    47b2:	80 91 b8 05 	lds	r24, 0x05B8
    47b6:	80 93 cf 05 	sts	0x05CF, r24
	TrueTime_MDay = Tm_MDay;
    47ba:	40 91 0d 0b 	lds	r20, 0x0B0D
    47be:	40 93 4d 06 	sts	0x064D, r20
	TrueTime_Mon = Tm_Mon;
    47c2:	60 91 7b 07 	lds	r22, 0x077B
    47c6:	60 93 c3 08 	sts	0x08C3, r22
	TrueTime_Year = Tm_Year;
    47ca:	80 91 d5 05 	lds	r24, 0x05D5
    47ce:	80 93 71 07 	sts	0x0771, r24
	TrueTime_WDay = SetWeekday(TrueTime_Year, TrueTime_Mon, TrueTime_MDay);
    47d2:	0e 94 b5 22 	call	0x456a	; 0x456a <SetWeekday>
    47d6:	80 93 0c 0b 	sts	0x0B0C, r24
}
    47da:	08 95       	ret

000047dc <RTC_SetTrueTime>:
void RTC_SetTrueTime(uint8_t Year, uint8_t Month, uint8_t Day, uint8_t WDay, uint8_t Hour, uint8_t Min, uint8_t Sec){
    47dc:	8f 92       	push	r8
    47de:	9f 92       	push	r9
    47e0:	af 92       	push	r10
    47e2:	bf 92       	push	r11
    47e4:	cf 92       	push	r12
    47e6:	df 92       	push	r13
    47e8:	ef 92       	push	r14
    47ea:	ff 92       	push	r15
    47ec:	0f 93       	push	r16
    47ee:	1f 93       	push	r17
    47f0:	88 2e       	mov	r8, r24
    47f2:	a6 2e       	mov	r10, r22
    47f4:	b4 2e       	mov	r11, r20
    47f6:	92 2e       	mov	r9, r18
    47f8:	d0 2e       	mov	r13, r16
    47fa:	fe 2c       	mov	r15, r14
    47fc:	1c 2d       	mov	r17, r12
	SetDateTime(Year, Month, Day, WDay, Hour, Min, Sec);
    47fe:	0e 94 1d 23 	call	0x463a	; 0x463a <SetDateTime>
	TrueTime_Sec = Sec;
    4802:	10 93 c2 08 	sts	0x08C2, r17
	TrueTime_Min = Min;
    4806:	f0 92 c4 08 	sts	0x08C4, r15
	TrueTime_Hour = Hour;
    480a:	d0 92 cf 05 	sts	0x05CF, r13
	TrueTime_MDay = Day;
    480e:	b0 92 4d 06 	sts	0x064D, r11
	TrueTime_Mon = Month;
    4812:	a0 92 c3 08 	sts	0x08C3, r10
	TrueTime_Year = Year;
    4816:	80 92 71 07 	sts	0x0771, r8
	TrueTime_WDay = WDay;
    481a:	90 92 0c 0b 	sts	0x0B0C, r9
}
    481e:	1f 91       	pop	r17
    4820:	0f 91       	pop	r16
    4822:	ff 90       	pop	r15
    4824:	ef 90       	pop	r14
    4826:	df 90       	pop	r13
    4828:	cf 90       	pop	r12
    482a:	bf 90       	pop	r11
    482c:	af 90       	pop	r10
    482e:	9f 90       	pop	r9
    4830:	8f 90       	pop	r8
    4832:	08 95       	ret

00004834 <RTC_Check>:

//  3 

uint8_t RTC_Check(void){

	if( (Tm_Year == TrueTime_Year)  && (Tm_Mon == TrueTime_Mon) && (Tm_MDay == TrueTime_MDay) &&
    4834:	50 91 d5 05 	lds	r21, 0x05D5
    4838:	40 91 71 07 	lds	r20, 0x0771
    483c:	54 17       	cp	r21, r20
    483e:	59 f1       	breq	.+86     	; 0x4896 <RTC_Check+0x62>
    4840:	90 91 c2 08 	lds	r25, 0x08C2
			(Tm_Hour == TrueTime_Hour) && (Tm_Min == TrueTime_Min) && (Tm_Sec == TrueTime_Sec) ) return 1;

	if(TrueTime_Sec>55){
    4844:	98 33       	cpi	r25, 0x38	; 56
    4846:	58 f0       	brcs	.+22     	; 0x485e <RTC_Check+0x2a>
		if(TrueTime_Min == 59){
    4848:	80 91 c4 08 	lds	r24, 0x08C4
    484c:	8b 33       	cpi	r24, 0x3B	; 59
    484e:	09 f4       	brne	.+2      	; 0x4852 <RTC_Check+0x1e>
    4850:	5a c0       	rjmp	.+180    	; 0x4906 <RTC_Check+0xd2>
			else{
				if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ) return 1;
			}
		}
		else{
			if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ||
    4852:	54 17       	cp	r21, r20
    4854:	09 f4       	brne	.+2      	; 0x4858 <RTC_Check+0x24>
    4856:	40 c0       	rjmp	.+128    	; 0x48d8 <RTC_Check+0xa4>
				(Tm_Hour != TrueTime_Hour) ) return 1;		
		}
	}
	else{
		if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ||
    4858:	21 e0       	ldi	r18, 0x01	; 1
			(Tm_Hour != TrueTime_Hour) || (Tm_Min != TrueTime_Min) ) return 1;
	}
	
	return 0;
}
    485a:	82 2f       	mov	r24, r18
    485c:	08 95       	ret
			if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ||
				(Tm_Hour != TrueTime_Hour) ) return 1;		
		}
	}
	else{
		if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ||
    485e:	54 17       	cp	r21, r20
    4860:	d9 f7       	brne	.-10     	; 0x4858 <RTC_Check+0x24>
    4862:	90 91 7b 07 	lds	r25, 0x077B
    4866:	80 91 c3 08 	lds	r24, 0x08C3
    486a:	98 17       	cp	r25, r24
    486c:	a9 f7       	brne	.-22     	; 0x4858 <RTC_Check+0x24>
    486e:	90 91 0d 0b 	lds	r25, 0x0B0D
    4872:	80 91 4d 06 	lds	r24, 0x064D
    4876:	98 17       	cp	r25, r24
    4878:	79 f7       	brne	.-34     	; 0x4858 <RTC_Check+0x24>
    487a:	90 91 b8 05 	lds	r25, 0x05B8
    487e:	80 91 cf 05 	lds	r24, 0x05CF
    4882:	98 17       	cp	r25, r24
    4884:	49 f7       	brne	.-46     	; 0x4858 <RTC_Check+0x24>
    4886:	20 e0       	ldi	r18, 0x00	; 0
    4888:	90 91 48 06 	lds	r25, 0x0648
    488c:	80 91 c4 08 	lds	r24, 0x08C4
    4890:	98 17       	cp	r25, r24
    4892:	11 f7       	brne	.-60     	; 0x4858 <RTC_Check+0x24>
    4894:	e2 cf       	rjmp	.-60     	; 0x485a <RTC_Check+0x26>

//  3 

uint8_t RTC_Check(void){

	if( (Tm_Year == TrueTime_Year)  && (Tm_Mon == TrueTime_Mon) && (Tm_MDay == TrueTime_MDay) &&
    4896:	90 91 7b 07 	lds	r25, 0x077B
    489a:	80 91 c3 08 	lds	r24, 0x08C3
    489e:	98 17       	cp	r25, r24
    48a0:	79 f6       	brne	.-98     	; 0x4840 <RTC_Check+0xc>
    48a2:	90 91 0d 0b 	lds	r25, 0x0B0D
    48a6:	80 91 4d 06 	lds	r24, 0x064D
    48aa:	98 17       	cp	r25, r24
    48ac:	49 f6       	brne	.-110    	; 0x4840 <RTC_Check+0xc>
    48ae:	90 91 b8 05 	lds	r25, 0x05B8
    48b2:	80 91 cf 05 	lds	r24, 0x05CF
    48b6:	98 17       	cp	r25, r24
    48b8:	19 f6       	brne	.-122    	; 0x4840 <RTC_Check+0xc>
    48ba:	90 91 48 06 	lds	r25, 0x0648
    48be:	80 91 c4 08 	lds	r24, 0x08C4
    48c2:	98 17       	cp	r25, r24
    48c4:	09 f0       	breq	.+2      	; 0x48c8 <RTC_Check+0x94>
    48c6:	bc cf       	rjmp	.-136    	; 0x4840 <RTC_Check+0xc>
    48c8:	80 91 ad 06 	lds	r24, 0x06AD
    48cc:	90 91 c2 08 	lds	r25, 0x08C2
    48d0:	89 17       	cp	r24, r25
    48d2:	09 f0       	breq	.+2      	; 0x48d6 <RTC_Check+0xa2>
    48d4:	b7 cf       	rjmp	.-146    	; 0x4844 <RTC_Check+0x10>
    48d6:	c0 cf       	rjmp	.-128    	; 0x4858 <RTC_Check+0x24>
			else{
				if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ) return 1;
			}
		}
		else{
			if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ||
    48d8:	90 91 7b 07 	lds	r25, 0x077B
    48dc:	80 91 c3 08 	lds	r24, 0x08C3
    48e0:	98 17       	cp	r25, r24
    48e2:	09 f0       	breq	.+2      	; 0x48e6 <RTC_Check+0xb2>
    48e4:	b9 cf       	rjmp	.-142    	; 0x4858 <RTC_Check+0x24>
    48e6:	90 91 0d 0b 	lds	r25, 0x0B0D
    48ea:	80 91 4d 06 	lds	r24, 0x064D
    48ee:	98 17       	cp	r25, r24
    48f0:	09 f0       	breq	.+2      	; 0x48f4 <RTC_Check+0xc0>
    48f2:	b2 cf       	rjmp	.-156    	; 0x4858 <RTC_Check+0x24>
    48f4:	20 e0       	ldi	r18, 0x00	; 0
    48f6:	90 91 b8 05 	lds	r25, 0x05B8
    48fa:	80 91 cf 05 	lds	r24, 0x05CF
    48fe:	98 17       	cp	r25, r24
    4900:	09 f0       	breq	.+2      	; 0x4904 <RTC_Check+0xd0>
    4902:	aa cf       	rjmp	.-172    	; 0x4858 <RTC_Check+0x24>
    4904:	aa cf       	rjmp	.-172    	; 0x485a <RTC_Check+0x26>
	if( (Tm_Year == TrueTime_Year)  && (Tm_Mon == TrueTime_Mon) && (Tm_MDay == TrueTime_MDay) &&
			(Tm_Hour == TrueTime_Hour) && (Tm_Min == TrueTime_Min) && (Tm_Sec == TrueTime_Sec) ) return 1;

	if(TrueTime_Sec>55){
		if(TrueTime_Min == 59){
			if(TrueTime_Hour == 23){
    4906:	80 91 cf 05 	lds	r24, 0x05CF
    490a:	87 31       	cpi	r24, 0x17	; 23
    490c:	99 f0       	breq	.+38     	; 0x4934 <RTC_Check+0x100>
				else{
					if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) ) return 1;
				}
			}
			else{
				if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ) return 1;
    490e:	54 17       	cp	r21, r20
    4910:	09 f0       	breq	.+2      	; 0x4914 <RTC_Check+0xe0>
    4912:	a2 cf       	rjmp	.-188    	; 0x4858 <RTC_Check+0x24>
    4914:	90 91 7b 07 	lds	r25, 0x077B
    4918:	80 91 c3 08 	lds	r24, 0x08C3
    491c:	98 17       	cp	r25, r24
    491e:	09 f0       	breq	.+2      	; 0x4922 <RTC_Check+0xee>
    4920:	9b cf       	rjmp	.-202    	; 0x4858 <RTC_Check+0x24>
    4922:	20 e0       	ldi	r18, 0x00	; 0
    4924:	90 91 0d 0b 	lds	r25, 0x0B0D
    4928:	80 91 4d 06 	lds	r24, 0x064D
    492c:	98 17       	cp	r25, r24
    492e:	09 f0       	breq	.+2      	; 0x4932 <RTC_Check+0xfe>
    4930:	93 cf       	rjmp	.-218    	; 0x4858 <RTC_Check+0x24>
    4932:	93 cf       	rjmp	.-218    	; 0x485a <RTC_Check+0x26>
			(Tm_Hour == TrueTime_Hour) && (Tm_Min == TrueTime_Min) && (Tm_Sec == TrueTime_Sec) ) return 1;

	if(TrueTime_Sec>55){
		if(TrueTime_Min == 59){
			if(TrueTime_Hour == 23){
				if(TrueTime_MDay >= 28){
    4934:	80 91 4d 06 	lds	r24, 0x064D
    4938:	8c 31       	cpi	r24, 0x1C	; 28
    493a:	48 f0       	brcs	.+18     	; 0x494e <RTC_Check+0x11a>
					if(TrueTime_Mon == 12){
    493c:	80 91 c3 08 	lds	r24, 0x08C3
    4940:	8c 30       	cpi	r24, 0x0C	; 12
    4942:	89 f0       	breq	.+34     	; 0x4966 <RTC_Check+0x132>
						if( ((TrueTime_Year+1) == Tm_Year) || (TrueTime_Year==Tm_Year) || ((TrueTime_Year==99) && (Tm_Year==0)) ) return 0;
    4944:	20 e0       	ldi	r18, 0x00	; 0
    4946:	54 17       	cp	r21, r20
    4948:	09 f0       	breq	.+2      	; 0x494c <RTC_Check+0x118>
    494a:	86 cf       	rjmp	.-244    	; 0x4858 <RTC_Check+0x24>
    494c:	86 cf       	rjmp	.-244    	; 0x485a <RTC_Check+0x26>
					else{
						if(Tm_Year!= TrueTime_Year) return 1;
					}
				}
				else{
					if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) ) return 1;
    494e:	54 17       	cp	r21, r20
    4950:	09 f0       	breq	.+2      	; 0x4954 <RTC_Check+0x120>
    4952:	82 cf       	rjmp	.-252    	; 0x4858 <RTC_Check+0x24>
    4954:	20 e0       	ldi	r18, 0x00	; 0
    4956:	90 91 7b 07 	lds	r25, 0x077B
    495a:	80 91 c3 08 	lds	r24, 0x08C3
    495e:	98 17       	cp	r25, r24
    4960:	09 f0       	breq	.+2      	; 0x4964 <RTC_Check+0x130>
    4962:	7a cf       	rjmp	.-268    	; 0x4858 <RTC_Check+0x24>
    4964:	7a cf       	rjmp	.-268    	; 0x485a <RTC_Check+0x26>
	if(TrueTime_Sec>55){
		if(TrueTime_Min == 59){
			if(TrueTime_Hour == 23){
				if(TrueTime_MDay >= 28){
					if(TrueTime_Mon == 12){
						if( ((TrueTime_Year+1) == Tm_Year) || (TrueTime_Year==Tm_Year) || ((TrueTime_Year==99) && (Tm_Year==0)) ) return 0;
    4966:	84 2f       	mov	r24, r20
    4968:	90 e0       	ldi	r25, 0x00	; 0
    496a:	01 96       	adiw	r24, 0x01	; 1
    496c:	25 2f       	mov	r18, r21
    496e:	30 e0       	ldi	r19, 0x00	; 0
    4970:	82 17       	cp	r24, r18
    4972:	93 07       	cpc	r25, r19
    4974:	61 f0       	breq	.+24     	; 0x498e <RTC_Check+0x15a>
    4976:	54 17       	cp	r21, r20
    4978:	51 f0       	breq	.+20     	; 0x498e <RTC_Check+0x15a>
    497a:	43 36       	cpi	r20, 0x63	; 99
    497c:	09 f0       	breq	.+2      	; 0x4980 <RTC_Check+0x14c>
    497e:	6c cf       	rjmp	.-296    	; 0x4858 <RTC_Check+0x24>
    4980:	20 e0       	ldi	r18, 0x00	; 0
    4982:	55 23       	and	r21, r21
    4984:	09 f4       	brne	.+2      	; 0x4988 <RTC_Check+0x154>
    4986:	21 e0       	ldi	r18, 0x01	; 1
    4988:	81 e0       	ldi	r24, 0x01	; 1
    498a:	28 27       	eor	r18, r24
    498c:	66 cf       	rjmp	.-308    	; 0x485a <RTC_Check+0x26>
			if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ||
				(Tm_Hour != TrueTime_Hour) ) return 1;		
		}
	}
	else{
		if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ||
    498e:	20 e0       	ldi	r18, 0x00	; 0
    4990:	64 cf       	rjmp	.-312    	; 0x485a <RTC_Check+0x26>

00004992 <GSM_PWRCNTRL_Config>:
#endif

//  gsm_sim900r.h   PWRCNTRL
#ifdef vmd2_3
	void GSM_PWRCNTRL_Config(void){
		cli();
    4992:	f8 94       	cli
		DDRL|=(1<<PL5);
    4994:	ea e0       	ldi	r30, 0x0A	; 10
    4996:	f1 e0       	ldi	r31, 0x01	; 1
    4998:	80 81       	ld	r24, Z
    499a:	80 62       	ori	r24, 0x20	; 32
    499c:	80 83       	st	Z, r24
		sei();
    499e:	78 94       	sei
	}
    49a0:	08 95       	ret

000049a2 <GSM_PWRCNTRL_OFF>:
	void GSM_PWRCNTRL_OFF(void){
		cli();
    49a2:	f8 94       	cli
		PORTL|=(1<<PL5);
    49a4:	eb e0       	ldi	r30, 0x0B	; 11
    49a6:	f1 e0       	ldi	r31, 0x01	; 1
    49a8:	80 81       	ld	r24, Z
    49aa:	80 62       	ori	r24, 0x20	; 32
    49ac:	80 83       	st	Z, r24
		sei();
    49ae:	78 94       	sei
	}
    49b0:	08 95       	ret

000049b2 <GSM_PWRCNTRL_ON>:
	void GSM_PWRCNTRL_ON(void){
		cli();
    49b2:	f8 94       	cli
		PORTL &= ~(1<<PL5);
    49b4:	eb e0       	ldi	r30, 0x0B	; 11
    49b6:	f1 e0       	ldi	r31, 0x01	; 1
    49b8:	80 81       	ld	r24, Z
    49ba:	8f 7d       	andi	r24, 0xDF	; 223
    49bc:	80 83       	st	Z, r24
		sei();
    49be:	78 94       	sei
	}
    49c0:	08 95       	ret

000049c2 <GSM_CTS_RTS_Config>:

	void GSM_CTS_RTS_Config(void){
		cli();
    49c2:	f8 94       	cli
		//TS
		DDRB &=~(1<<PB6);
    49c4:	26 98       	cbi	0x04, 6	; 4
		PORTB |=(1<<PB6);	//pull'up
    49c6:	2e 9a       	sbi	0x05, 6	; 5
		//RTS
		DDRG |= (1<<PG5);
    49c8:	9d 9a       	sbi	0x13, 5	; 19
		PORTG &= ~(1<<PG5);
    49ca:	a5 98       	cbi	0x14, 5	; 20
		sei();
    49cc:	78 94       	sei
	}
    49ce:	08 95       	ret

000049d0 <GSM_CTS_State>:
	uint8_t GSM_CTS_State(void){
		return PINB & (1<<PB6);
    49d0:	83 b1       	in	r24, 0x03	; 3
	}
    49d2:	80 74       	andi	r24, 0x40	; 64
    49d4:	08 95       	ret

000049d6 <GSM_RTS_OFF>:
	void GSM_RTS_OFF(void){
		cli();
    49d6:	f8 94       	cli
		PORTG &= ~(1<<PG5);
    49d8:	a5 98       	cbi	0x14, 5	; 20
		sei();
    49da:	78 94       	sei
	}
    49dc:	08 95       	ret

000049de <GSM_RTS_ON>:
	void GSM_RTS_ON(void){
		cli();
    49de:	f8 94       	cli
		PORTG |= (1<<PG5);
    49e0:	a5 9a       	sbi	0x14, 5	; 20
		sei();
    49e2:	78 94       	sei
	}
    49e4:	08 95       	ret

000049e6 <LED_Init>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    49e6:	8f b7       	in	r24, 0x3f	; 63
    49e8:	80 78       	andi	r24, 0x80	; 128
    49ea:	80 93 e5 02 	sts	0x02E5, r24
	cli();
    49ee:	f8 94       	cli
//~~~~~~~~~~~~
void
LED_Init(void)
{
	IntOff();
	DDR_LED |=PinLED;
    49f0:	83 9a       	sbi	0x10, 3	; 16
	LED_Rst();
    49f2:	8b 98       	cbi	0x11, 3	; 17

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    49f4:	88 23       	and	r24, r24
    49f6:	09 f0       	breq	.+2      	; 0x49fa <LED_Init+0x14>
		sei();
    49f8:	78 94       	sei
    49fa:	08 95       	ret

000049fc <LED_On>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    49fc:	8f b7       	in	r24, 0x3f	; 63
    49fe:	80 78       	andi	r24, 0x80	; 128
    4a00:	80 93 e5 02 	sts	0x02E5, r24
	cli();
    4a04:	f8 94       	cli
// ~~~~~~~~~
void
LED_On(void)
{
	IntOff();
	LED_Set();
    4a06:	8b 9a       	sbi	0x11, 3	; 17

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    4a08:	88 23       	and	r24, r24
    4a0a:	09 f0       	breq	.+2      	; 0x4a0e <LED_On+0x12>
		sei();
    4a0c:	78 94       	sei
    4a0e:	08 95       	ret

00004a10 <LED_Off>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    4a10:	8f b7       	in	r24, 0x3f	; 63
    4a12:	80 78       	andi	r24, 0x80	; 128
    4a14:	80 93 e5 02 	sts	0x02E5, r24
	cli();
    4a18:	f8 94       	cli
// ~~~~~~~~~~
void
LED_Off(void)
{
	IntOff();
	LED_Rst();
    4a1a:	8b 98       	cbi	0x11, 3	; 17

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    4a1c:	88 23       	and	r24, r24
    4a1e:	09 f0       	breq	.+2      	; 0x4a22 <LED_Off+0x12>
		sei();
    4a20:	78 94       	sei
    4a22:	08 95       	ret

00004a24 <LED_Toggle>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    4a24:	8f b7       	in	r24, 0x3f	; 63
    4a26:	80 78       	andi	r24, 0x80	; 128
    4a28:	80 93 e5 02 	sts	0x02E5, r24
	cli();
    4a2c:	f8 94       	cli
// ~~~~~~~~~~~~~
uint8_t
LED_Toggle(void)
{
	IntOff();
	LED_Inv();
    4a2e:	91 b3       	in	r25, 0x11	; 17
    4a30:	28 e0       	ldi	r18, 0x08	; 8
    4a32:	92 27       	eor	r25, r18
    4a34:	91 bb       	out	0x11, r25	; 17

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    4a36:	88 23       	and	r24, r24
    4a38:	09 f0       	breq	.+2      	; 0x4a3c <LED_Toggle+0x18>
		sei();
    4a3a:	78 94       	sei
	IntOn();
	return PortLED &PinLED;
    4a3c:	81 b3       	in	r24, 0x11	; 17
}
    4a3e:	88 70       	andi	r24, 0x08	; 8
    4a40:	08 95       	ret

00004a42 <Send>:
#ifdef Port_LCD_DB0	//8-bit width data bus
	// ~~~~~~~~~~~~~~
	static void
	Send(uint8_t Val)
	{
		if (Val &(1<<0)) Port_LCD_DB0 |=DB0; else Port_LCD_DB0 &=~DB0;
    4a42:	98 2f       	mov	r25, r24
    4a44:	80 ff       	sbrs	r24, 0
    4a46:	23 c0       	rjmp	.+70     	; 0x4a8e <Send+0x4c>
    4a48:	41 9a       	sbi	0x08, 1	; 8
		if (Val &(1<<1)) Port_LCD_DB1 |=DB1; else Port_LCD_DB1 &=~DB1;
    4a4a:	91 ff       	sbrs	r25, 1
    4a4c:	23 c0       	rjmp	.+70     	; 0x4a94 <Send+0x52>
    4a4e:	40 9a       	sbi	0x08, 0	; 8
		if (Val &(1<<2)) Port_LCD_DB2 |=DB2; else Port_LCD_DB2 &=~DB2;
    4a50:	92 ff       	sbrs	r25, 2
    4a52:	23 c0       	rjmp	.+70     	; 0x4a9a <Send+0x58>
    4a54:	a1 9a       	sbi	0x14, 1	; 20
		if (Val &(1<<3)) Port_LCD_DB3 |=DB3; else Port_LCD_DB3 &=~DB3;
    4a56:	93 ff       	sbrs	r25, 3
    4a58:	23 c0       	rjmp	.+70     	; 0x4aa0 <Send+0x5e>
    4a5a:	a0 9a       	sbi	0x14, 0	; 20
		if (Val &(1<<4)) Port_LCD_DB4 |=DB4; else Port_LCD_DB4 &=~DB4;
    4a5c:	94 ff       	sbrs	r25, 4
    4a5e:	23 c0       	rjmp	.+70     	; 0x4aa6 <Send+0x64>
    4a60:	5f 9a       	sbi	0x0b, 7	; 11
		if (Val &(1<<5)) Port_LCD_DB5 |=DB5; else Port_LCD_DB5 &=~DB5;
    4a62:	95 ff       	sbrs	r25, 5
    4a64:	23 c0       	rjmp	.+70     	; 0x4aac <Send+0x6a>
    4a66:	5e 9a       	sbi	0x0b, 6	; 11
		if (Val &(1<<6)) Port_LCD_DB6 |=DB6; else Port_LCD_DB6 &=~DB6;
    4a68:	96 ff       	sbrs	r25, 6
    4a6a:	23 c0       	rjmp	.+70     	; 0x4ab2 <Send+0x70>
    4a6c:	5d 9a       	sbi	0x0b, 5	; 11
		if (Val &(1<<7)) Port_LCD_DB7 |=DB7; else Port_LCD_DB7 &=~DB7;
    4a6e:	87 fd       	sbrc	r24, 7
    4a70:	23 c0       	rjmp	.+70     	; 0x4ab8 <Send+0x76>
    4a72:	80 91 0b 01 	lds	r24, 0x010B
    4a76:	8f 77       	andi	r24, 0x7F	; 127
    4a78:	80 93 0b 01 	sts	0x010B, r24

		Port_LCD_E |=LCD_E;
    4a7c:	42 9a       	sbi	0x08, 2	; 8
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    4a7e:	85 e0       	ldi	r24, 0x05	; 5
    4a80:	98 2f       	mov	r25, r24
    4a82:	9a 95       	dec	r25
    4a84:	f1 f7       	brne	.-4      	; 0x4a82 <Send+0x40>
		_delay_us(1);		// 450 ns needs
		Port_LCD_E &=~LCD_E;
    4a86:	42 98       	cbi	0x08, 2	; 8
    4a88:	8a 95       	dec	r24
    4a8a:	f1 f7       	brne	.-4      	; 0x4a88 <Send+0x46>
		_delay_us(1);		// 10 ns needs
	}
    4a8c:	08 95       	ret
#ifdef Port_LCD_DB0	//8-bit width data bus
	// ~~~~~~~~~~~~~~
	static void
	Send(uint8_t Val)
	{
		if (Val &(1<<0)) Port_LCD_DB0 |=DB0; else Port_LCD_DB0 &=~DB0;
    4a8e:	41 98       	cbi	0x08, 1	; 8
		if (Val &(1<<1)) Port_LCD_DB1 |=DB1; else Port_LCD_DB1 &=~DB1;
    4a90:	91 fd       	sbrc	r25, 1
    4a92:	dd cf       	rjmp	.-70     	; 0x4a4e <Send+0xc>
    4a94:	40 98       	cbi	0x08, 0	; 8
		if (Val &(1<<2)) Port_LCD_DB2 |=DB2; else Port_LCD_DB2 &=~DB2;
    4a96:	92 fd       	sbrc	r25, 2
    4a98:	dd cf       	rjmp	.-70     	; 0x4a54 <Send+0x12>
    4a9a:	a1 98       	cbi	0x14, 1	; 20
		if (Val &(1<<3)) Port_LCD_DB3 |=DB3; else Port_LCD_DB3 &=~DB3;
    4a9c:	93 fd       	sbrc	r25, 3
    4a9e:	dd cf       	rjmp	.-70     	; 0x4a5a <Send+0x18>
    4aa0:	a0 98       	cbi	0x14, 0	; 20
		if (Val &(1<<4)) Port_LCD_DB4 |=DB4; else Port_LCD_DB4 &=~DB4;
    4aa2:	94 fd       	sbrc	r25, 4
    4aa4:	dd cf       	rjmp	.-70     	; 0x4a60 <Send+0x1e>
    4aa6:	5f 98       	cbi	0x0b, 7	; 11
		if (Val &(1<<5)) Port_LCD_DB5 |=DB5; else Port_LCD_DB5 &=~DB5;
    4aa8:	95 fd       	sbrc	r25, 5
    4aaa:	dd cf       	rjmp	.-70     	; 0x4a66 <Send+0x24>
    4aac:	5e 98       	cbi	0x0b, 6	; 11
		if (Val &(1<<6)) Port_LCD_DB6 |=DB6; else Port_LCD_DB6 &=~DB6;
    4aae:	96 fd       	sbrc	r25, 6
    4ab0:	dd cf       	rjmp	.-70     	; 0x4a6c <Send+0x2a>
    4ab2:	5d 98       	cbi	0x0b, 5	; 11
		if (Val &(1<<7)) Port_LCD_DB7 |=DB7; else Port_LCD_DB7 &=~DB7;
    4ab4:	87 ff       	sbrs	r24, 7
    4ab6:	dd cf       	rjmp	.-70     	; 0x4a72 <Send+0x30>
    4ab8:	80 91 0b 01 	lds	r24, 0x010B
    4abc:	80 68       	ori	r24, 0x80	; 128
    4abe:	80 93 0b 01 	sts	0x010B, r24
    4ac2:	dc cf       	rjmp	.-72     	; 0x4a7c <Send+0x3a>

00004ac4 <Send_I>:
#endif
// ~~~~~~~~~~~~~~~~
static void
Send_I(uint8_t Val)
{
	Send(Val);
    4ac4:	0e 94 21 25 	call	0x4a42	; 0x4a42 <Send>
	Delay_us(LCD_Delay);
    4ac8:	82 e3       	ldi	r24, 0x32	; 50
    4aca:	90 e0       	ldi	r25, 0x00	; 0
    4acc:	0e 94 17 1d 	call	0x3a2e	; 0x3a2e <Delay_us>
}
    4ad0:	08 95       	ret

00004ad2 <LCD_FuncSet0>:

// ~~~~~~~~~~~
static void
LCD_FuncSet0(void)
{
	Port_LCD_DB4  |=DB4;
    4ad2:	5f 9a       	sbi	0x0b, 7	; 11
	Port_LCD_DB5  |=DB5;
    4ad4:	5e 9a       	sbi	0x0b, 6	; 11
	Port_LCD_DB6 &=~DB6;
    4ad6:	5d 98       	cbi	0x0b, 5	; 11
	Port_LCD_DB7 &=~DB7;
    4ad8:	eb e0       	ldi	r30, 0x0B	; 11
    4ada:	f1 e0       	ldi	r31, 0x01	; 1
    4adc:	80 81       	ld	r24, Z
    4ade:	8f 77       	andi	r24, 0x7F	; 127
    4ae0:	80 83       	st	Z, r24
}
    4ae2:	08 95       	ret

00004ae4 <LCD_Rdy>:
}

// ~~~~~~~~~~
uint8_t
LCD_Rdy(void)
{
    4ae4:	1f 93       	push	r17
	uint8_t Rdy = Timer8Stopp(TD_LCD);
    4ae6:	10 91 ce 04 	lds	r17, 0x04CE
    4aea:	81 2f       	mov	r24, r17
    4aec:	0e 94 1e 1b 	call	0x363c	; 0x363c <Timer8Stopp>
	Rdy = Rdy && !(TIMSK_LCD &(1<<OCIE1B));
    4af0:	88 23       	and	r24, r24
    4af2:	29 f0       	breq	.+10     	; 0x4afe <LCD_Rdy+0x1a>
    4af4:	80 91 6f 00 	lds	r24, 0x006F
    4af8:	82 ff       	sbrs	r24, 2
    4afa:	03 c0       	rjmp	.+6      	; 0x4b02 <LCD_Rdy+0x1e>
    4afc:	80 e0       	ldi	r24, 0x00	; 0
	if (Rdy)
		StartTimer8(TD_LCD, 6);
	return Rdy;
}
    4afe:	1f 91       	pop	r17
    4b00:	08 95       	ret
LCD_Rdy(void)
{
	uint8_t Rdy = Timer8Stopp(TD_LCD);
	Rdy = Rdy && !(TIMSK_LCD &(1<<OCIE1B));
	if (Rdy)
		StartTimer8(TD_LCD, 6);
    4b02:	81 2f       	mov	r24, r17
    4b04:	66 e0       	ldi	r22, 0x06	; 6
    4b06:	0e 94 ca 19 	call	0x3394	; 0x3394 <StartTimer8>
    4b0a:	81 e0       	ldi	r24, 0x01	; 1
	return Rdy;
}
    4b0c:	1f 91       	pop	r17
    4b0e:	08 95       	ret

00004b10 <LCD_Out>:
LCD_Out(void)
{
	static uint8_t N;
	uint16_t LCD_delay = 100;	//50us

	if( (N>=20) && !LCD_Rst_Flg ){
    4b10:	90 91 e2 02 	lds	r25, 0x02E2
    4b14:	94 31       	cpi	r25, 0x14	; 20
    4b16:	20 f0       	brcs	.+8      	; 0x4b20 <LCD_Out+0x10>
    4b18:	80 91 cd 04 	lds	r24, 0x04CD
    4b1c:	88 23       	and	r24, r24
    4b1e:	19 f1       	breq	.+70     	; 0x4b66 <LCD_Out+0x56>
		LCD_Rst0();
		LCD_Rst_Flg = 1;
		LCD_delay = 10000;	//5ms
	}
	else {
		N++;
    4b20:	9f 5f       	subi	r25, 0xFF	; 255
    4b22:	90 93 e2 02 	sts	0x02E2, r25
    4b26:	24 e6       	ldi	r18, 0x64	; 100
    4b28:	30 e0       	ldi	r19, 0x00	; 0
	}

	cli();
    4b2a:	f8 94       	cli
	LCD_delay = TCNT1 + LCD_delay;
    4b2c:	80 91 84 00 	lds	r24, 0x0084
    4b30:	90 91 85 00 	lds	r25, 0x0085
    4b34:	82 0f       	add	r24, r18
    4b36:	93 1f       	adc	r25, r19
	if(LCD_delay >= 20000) OCR1B = LCD_delay - 20000;
    4b38:	2e e4       	ldi	r18, 0x4E	; 78
    4b3a:	80 32       	cpi	r24, 0x20	; 32
    4b3c:	92 07       	cpc	r25, r18
    4b3e:	60 f4       	brcc	.+24     	; 0x4b58 <LCD_Out+0x48>
	else OCR1B = LCD_delay;
    4b40:	90 93 8b 00 	sts	0x008B, r25
    4b44:	80 93 8a 00 	sts	0x008A, r24
	TIFR_LCD |= (1<<OCF1B);
    4b48:	b2 9a       	sbi	0x16, 2	; 22
	TIMSK_LCD |= (1<<OCIE1B);
    4b4a:	80 91 6f 00 	lds	r24, 0x006F
    4b4e:	84 60       	ori	r24, 0x04	; 4
    4b50:	80 93 6f 00 	sts	0x006F, r24
	sei();
    4b54:	78 94       	sei
}
    4b56:	08 95       	ret
		N++;
	}

	cli();
	LCD_delay = TCNT1 + LCD_delay;
	if(LCD_delay >= 20000) OCR1B = LCD_delay - 20000;
    4b58:	80 52       	subi	r24, 0x20	; 32
    4b5a:	9e 44       	sbci	r25, 0x4E	; 78
    4b5c:	90 93 8b 00 	sts	0x008B, r25
    4b60:	80 93 8a 00 	sts	0x008A, r24
    4b64:	f1 cf       	rjmp	.-30     	; 0x4b48 <LCD_Out+0x38>
{
	static uint8_t N;
	uint16_t LCD_delay = 100;	//50us

	if( (N>=20) && !LCD_Rst_Flg ){
		N = 0;
    4b66:	10 92 e2 02 	sts	0x02E2, r1
#endif
// ~~~~~~~~~~~
static void
LCD_Rst0(void)
{
	cli();
    4b6a:	f8 94       	cli
	Port_LCD_RS &=~LCD_RS;
    4b6c:	44 98       	cbi	0x08, 4	; 8
	LCD_FuncSet0();
    4b6e:	0e 94 69 25 	call	0x4ad2	; 0x4ad2 <LCD_FuncSet0>
	sei();
    4b72:	78 94       	sei
	uint16_t LCD_delay = 100;	//50us

	if( (N>=20) && !LCD_Rst_Flg ){
		N = 0;
		LCD_Rst0();
		LCD_Rst_Flg = 1;
    4b74:	81 e0       	ldi	r24, 0x01	; 1
    4b76:	80 93 cd 04 	sts	0x04CD, r24
    4b7a:	20 e1       	ldi	r18, 0x10	; 16
    4b7c:	37 e2       	ldi	r19, 0x27	; 39
    4b7e:	d5 cf       	rjmp	.-86     	; 0x4b2a <LCD_Out+0x1a>

00004b80 <__vector_18>:
	sei();
}

// ~~~~~~~~~~~~~~~~~~~~~~
// 40 us needs
ISR(TIMER1_COMPB_vect){
    4b80:	1f 92       	push	r1
    4b82:	0f 92       	push	r0
    4b84:	0f b6       	in	r0, 0x3f	; 63
    4b86:	0f 92       	push	r0
    4b88:	0b b6       	in	r0, 0x3b	; 59
    4b8a:	0f 92       	push	r0
    4b8c:	11 24       	eor	r1, r1
    4b8e:	ff 92       	push	r15
    4b90:	0f 93       	push	r16
    4b92:	1f 93       	push	r17
    4b94:	2f 93       	push	r18
    4b96:	3f 93       	push	r19
    4b98:	4f 93       	push	r20
    4b9a:	5f 93       	push	r21
    4b9c:	6f 93       	push	r22
    4b9e:	7f 93       	push	r23
    4ba0:	8f 93       	push	r24
    4ba2:	9f 93       	push	r25
    4ba4:	af 93       	push	r26
    4ba6:	bf 93       	push	r27
    4ba8:	ef 93       	push	r30
    4baa:	ff 93       	push	r31

	uint16_t LCD_delay = 100;	//50us

	if (LCD_Rst_Flg) {
    4bac:	80 91 cd 04 	lds	r24, 0x04CD
    4bb0:	88 23       	and	r24, r24
    4bb2:	f1 f0       	breq	.+60     	; 0x4bf0 <__vector_18+0x70>
		switch(LCD_Rst_Flg){
    4bb4:	10 91 cd 04 	lds	r17, 0x04CD
    4bb8:	15 30       	cpi	r17, 0x05	; 5
    4bba:	09 f4       	brne	.+2      	; 0x4bbe <__vector_18+0x3e>
    4bbc:	b5 c0       	rjmp	.+362    	; 0x4d28 <__vector_18+0x1a8>
    4bbe:	16 30       	cpi	r17, 0x06	; 6
    4bc0:	08 f4       	brcc	.+2      	; 0x4bc4 <__vector_18+0x44>
    4bc2:	a1 c0       	rjmp	.+322    	; 0x4d06 <__vector_18+0x186>
    4bc4:	17 30       	cpi	r17, 0x07	; 7
    4bc6:	09 f4       	brne	.+2      	; 0x4bca <__vector_18+0x4a>
    4bc8:	15 c1       	rjmp	.+554    	; 0x4df4 <__vector_18+0x274>
    4bca:	17 30       	cpi	r17, 0x07	; 7
    4bcc:	08 f0       	brcs	.+2      	; 0x4bd0 <__vector_18+0x50>
    4bce:	dc c0       	rjmp	.+440    	; 0x4d88 <__vector_18+0x208>
				break;
			case 5:
				Send(0b00001100);	//; Display on, cursor off, blink off	
				break;
			case 6:
				Send(0b00000110);	//; cursor shift right, no display shift
    4bd0:	86 e0       	ldi	r24, 0x06	; 6
    4bd2:	0e 94 21 25 	call	0x4a42	; 0x4a42 <Send>
				#endif
				Port_LCD_RS |=LCD_RS;
			default:
				LCD_Rst_Flg = 255;
		}
		if(LCD_Rst_Flg==1) LCD_delay = 400;	//200us
    4bd6:	80 91 cd 04 	lds	r24, 0x04CD
    4bda:	81 30       	cpi	r24, 0x01	; 1
    4bdc:	09 f4       	brne	.+2      	; 0x4be0 <__vector_18+0x60>
    4bde:	a1 c0       	rjmp	.+322    	; 0x4d22 <__vector_18+0x1a2>
    4be0:	24 e6       	ldi	r18, 0x64	; 100
    4be2:	30 e0       	ldi	r19, 0x00	; 0

		LCD_Rst_Flg++;
    4be4:	80 91 cd 04 	lds	r24, 0x04CD
    4be8:	8f 5f       	subi	r24, 0xFF	; 255
    4bea:	80 93 cd 04 	sts	0x04CD, r24
    4bee:	5f c0       	rjmp	.+190    	; 0x4cae <__vector_18+0x12e>
	else {
		static uint8_t X, Y;
		static prog_uint8_t LineAddr[] = {128, 192, 148, 212};
		unsigned char cursor_symb;
		
		if (X<LCDXSz) {
    4bf0:	10 91 df 02 	lds	r17, 0x02DF
    4bf4:	14 31       	cpi	r17, 0x14	; 20
    4bf6:	08 f0       	brcs	.+2      	; 0x4bfa <__vector_18+0x7a>
    4bf8:	45 c0       	rjmp	.+138    	; 0x4c84 <__vector_18+0x104>
			if((X>=CurrX)&&(X<(CurrX+StrSize))&&(Y==CurrLCD)){
    4bfa:	80 91 b0 06 	lds	r24, 0x06B0
    4bfe:	18 17       	cp	r17, r24
    4c00:	08 f4       	brcc	.+2      	; 0x4c04 <__vector_18+0x84>
    4c02:	96 c0       	rjmp	.+300    	; 0x4d30 <__vector_18+0x1b0>
    4c04:	61 2f       	mov	r22, r17
    4c06:	70 e0       	ldi	r23, 0x00	; 0
    4c08:	20 91 a3 06 	lds	r18, 0x06A3
    4c0c:	90 e0       	ldi	r25, 0x00	; 0
    4c0e:	82 0f       	add	r24, r18
    4c10:	91 1d       	adc	r25, r1
    4c12:	68 17       	cp	r22, r24
    4c14:	79 07       	cpc	r23, r25
    4c16:	0c f4       	brge	.+2      	; 0x4c1a <__vector_18+0x9a>
    4c18:	e4 c0       	rjmp	.+456    	; 0x4de2 <__vector_18+0x262>
    4c1a:	e0 91 de 02 	lds	r30, 0x02DE
    4c1e:	20 e0       	ldi	r18, 0x00	; 0
			else
			{
				cursor_symb=0;
			}

			Send(
    4c20:	4e 2f       	mov	r20, r30
    4c22:	50 e0       	ldi	r21, 0x00	; 0
    4c24:	90 91 c6 08 	lds	r25, 0x08C6
    4c28:	89 2f       	mov	r24, r25
    4c2a:	88 50       	subi	r24, 0x08	; 8
    4c2c:	83 30       	cpi	r24, 0x03	; 3
    4c2e:	18 f0       	brcs	.+6      	; 0x4c36 <__vector_18+0xb6>
    4c30:	9e 30       	cpi	r25, 0x0E	; 14
    4c32:	08 f4       	brcc	.+2      	; 0x4c36 <__vector_18+0xb6>
    4c34:	91 c0       	rjmp	.+290    	; 0x4d58 <__vector_18+0x1d8>
    4c36:	22 23       	and	r18, r18
    4c38:	09 f4       	brne	.+2      	; 0x4c3c <__vector_18+0xbc>
    4c3a:	8e c0       	rjmp	.+284    	; 0x4d58 <__vector_18+0x1d8>
    4c3c:	80 91 d3 02 	lds	r24, 0x02D3
    4c40:	8f 3f       	cpi	r24, 0xFF	; 255
    4c42:	09 f4       	brne	.+2      	; 0x4c46 <__vector_18+0xc6>
    4c44:	89 c0       	rjmp	.+274    	; 0x4d58 <__vector_18+0x1d8>
    4c46:	e2 2f       	mov	r30, r18
    4c48:	f0 e0       	ldi	r31, 0x00	; 0
    4c4a:	e7 5b       	subi	r30, 0xB7	; 183
    4c4c:	f3 4d       	sbci	r31, 0xD3	; 211
    4c4e:	24 91       	lpm	r18, Z+
    4c50:	fa 01       	movw	r30, r20
    4c52:	ee 0f       	add	r30, r30
    4c54:	ff 1f       	adc	r31, r31
    4c56:	ee 0f       	add	r30, r30
    4c58:	ff 1f       	adc	r31, r31
    4c5a:	cf 01       	movw	r24, r30
    4c5c:	88 0f       	add	r24, r24
    4c5e:	99 1f       	adc	r25, r25
    4c60:	88 0f       	add	r24, r24
    4c62:	99 1f       	adc	r25, r25
    4c64:	e8 0f       	add	r30, r24
    4c66:	f9 1f       	adc	r31, r25
    4c68:	e6 0f       	add	r30, r22
    4c6a:	f7 1f       	adc	r31, r23
    4c6c:	ef 5b       	subi	r30, 0xBF	; 191
    4c6e:	f7 4f       	sbci	r31, 0xF7	; 247
    4c70:	20 83       	st	Z, r18
    4c72:	82 2f       	mov	r24, r18
    4c74:	0e 94 21 25 	call	0x4a42	; 0x4a42 <Send>
				#ifndef QslRD
					*((uint8_t*)RMON+Y*LCDXSz+X) =
				#endif
			#endif
				(((Blink>=8 && Blink<=10 )|| Blink>=14)&&cursor_symb&&(CurrField!=255))?prb(Win2LCD+(unsigned char)cursor_symb):(prb(Win2LCD+(unsigned char)LCD_Buf[Y][X])));
				X++;
    4c78:	1f 5f       	subi	r17, 0xFF	; 255
    4c7a:	10 93 df 02 	sts	0x02DF, r17
    4c7e:	24 e6       	ldi	r18, 0x64	; 100
    4c80:	30 e0       	ldi	r19, 0x00	; 0
    4c82:	15 c0       	rjmp	.+42     	; 0x4cae <__vector_18+0x12e>
		}
		else {
			X = 0;
    4c84:	10 92 df 02 	sts	0x02DF, r1
			if (++Y==LCDYSz) {
    4c88:	e0 91 de 02 	lds	r30, 0x02DE
    4c8c:	ef 5f       	subi	r30, 0xFF	; 255
    4c8e:	e0 93 de 02 	sts	0x02DE, r30
    4c92:	e4 30       	cpi	r30, 0x04	; 4
    4c94:	09 f4       	brne	.+2      	; 0x4c98 <__vector_18+0x118>
    4c96:	51 c0       	rjmp	.+162    	; 0x4d3a <__vector_18+0x1ba>
				Y = 0;
				TIMSK_LCD &= ~(1<<OCIE1B);	//stop Output CompareB interrups
			}
			Port_LCD_RS &=~LCD_RS;
    4c98:	44 98       	cbi	0x08, 4	; 8
    4c9a:	f0 e0       	ldi	r31, 0x00	; 0
    4c9c:	e7 5b       	subi	r30, 0xB7	; 183
    4c9e:	f2 4d       	sbci	r31, 0xD2	; 210
    4ca0:	e4 91       	lpm	r30, Z+
			Send(prb(LineAddr+Y));
    4ca2:	8e 2f       	mov	r24, r30
    4ca4:	0e 94 21 25 	call	0x4a42	; 0x4a42 <Send>
			Port_LCD_RS |=LCD_RS;
    4ca8:	44 9a       	sbi	0x08, 4	; 8
    4caa:	24 e6       	ldi	r18, 0x64	; 100
    4cac:	30 e0       	ldi	r19, 0x00	; 0
		}
	}
	LCD_delay = TCNT1 + LCD_delay;
    4cae:	80 91 84 00 	lds	r24, 0x0084
    4cb2:	90 91 85 00 	lds	r25, 0x0085
    4cb6:	82 0f       	add	r24, r18
    4cb8:	93 1f       	adc	r25, r19
	if(LCD_delay >= 20000) OCR1B = LCD_delay - 20000;
    4cba:	2e e4       	ldi	r18, 0x4E	; 78
    4cbc:	80 32       	cpi	r24, 0x20	; 32
    4cbe:	92 07       	cpc	r25, r18
    4cc0:	d8 f4       	brcc	.+54     	; 0x4cf8 <__vector_18+0x178>
	else OCR1B = LCD_delay;
    4cc2:	90 93 8b 00 	sts	0x008B, r25
    4cc6:	80 93 8a 00 	sts	0x008A, r24
	TIFR_LCD |= (1<<OCF1B);
    4cca:	b2 9a       	sbi	0x16, 2	; 22
}
    4ccc:	ff 91       	pop	r31
    4cce:	ef 91       	pop	r30
    4cd0:	bf 91       	pop	r27
    4cd2:	af 91       	pop	r26
    4cd4:	9f 91       	pop	r25
    4cd6:	8f 91       	pop	r24
    4cd8:	7f 91       	pop	r23
    4cda:	6f 91       	pop	r22
    4cdc:	5f 91       	pop	r21
    4cde:	4f 91       	pop	r20
    4ce0:	3f 91       	pop	r19
    4ce2:	2f 91       	pop	r18
    4ce4:	1f 91       	pop	r17
    4ce6:	0f 91       	pop	r16
    4ce8:	ff 90       	pop	r15
    4cea:	0f 90       	pop	r0
    4cec:	0b be       	out	0x3b, r0	; 59
    4cee:	0f 90       	pop	r0
    4cf0:	0f be       	out	0x3f, r0	; 63
    4cf2:	0f 90       	pop	r0
    4cf4:	1f 90       	pop	r1
    4cf6:	18 95       	reti
			Send(prb(LineAddr+Y));
			Port_LCD_RS |=LCD_RS;
		}
	}
	LCD_delay = TCNT1 + LCD_delay;
	if(LCD_delay >= 20000) OCR1B = LCD_delay - 20000;
    4cf8:	80 52       	subi	r24, 0x20	; 32
    4cfa:	9e 44       	sbci	r25, 0x4E	; 78
    4cfc:	90 93 8b 00 	sts	0x008B, r25
    4d00:	80 93 8a 00 	sts	0x008A, r24
    4d04:	e2 cf       	rjmp	.-60     	; 0x4cca <__vector_18+0x14a>
ISR(TIMER1_COMPB_vect){

	uint16_t LCD_delay = 100;	//50us

	if (LCD_Rst_Flg) {
		switch(LCD_Rst_Flg){
    4d06:	12 30       	cpi	r17, 0x02	; 2
    4d08:	21 f1       	breq	.+72     	; 0x4d52 <__vector_18+0x1d2>
    4d0a:	13 30       	cpi	r17, 0x03	; 3
    4d0c:	f8 f4       	brcc	.+62     	; 0x4d4c <__vector_18+0x1cc>
    4d0e:	11 30       	cpi	r17, 0x01	; 1
    4d10:	01 f1       	breq	.+64     	; 0x4d52 <__vector_18+0x1d2>
				#else
					Send(0b00000010);	//RETURN HOME					
				#endif
				Port_LCD_RS |=LCD_RS;
			default:
				LCD_Rst_Flg = 255;
    4d12:	8f ef       	ldi	r24, 0xFF	; 255
    4d14:	80 93 cd 04 	sts	0x04CD, r24
		}
		if(LCD_Rst_Flg==1) LCD_delay = 400;	//200us
    4d18:	80 91 cd 04 	lds	r24, 0x04CD
    4d1c:	81 30       	cpi	r24, 0x01	; 1
    4d1e:	09 f0       	breq	.+2      	; 0x4d22 <__vector_18+0x1a2>
    4d20:	5f cf       	rjmp	.-322    	; 0x4be0 <__vector_18+0x60>
    4d22:	20 e9       	ldi	r18, 0x90	; 144
    4d24:	31 e0       	ldi	r19, 0x01	; 1
    4d26:	5e cf       	rjmp	.-324    	; 0x4be4 <__vector_18+0x64>
				#else
					Send(0b00101000);	//; 4-bits DL, 2 lines, 5x7 dots
				#endif
				break;
			case 5:
				Send(0b00001100);	//; Display on, cursor off, blink off	
    4d28:	8c e0       	ldi	r24, 0x0C	; 12
    4d2a:	0e 94 21 25 	call	0x4a42	; 0x4a42 <Send>
    4d2e:	53 cf       	rjmp	.-346    	; 0x4bd6 <__vector_18+0x56>
    4d30:	61 2f       	mov	r22, r17
    4d32:	70 e0       	ldi	r23, 0x00	; 0
    4d34:	e0 91 de 02 	lds	r30, 0x02DE
    4d38:	72 cf       	rjmp	.-284    	; 0x4c1e <__vector_18+0x9e>
				X++;
		}
		else {
			X = 0;
			if (++Y==LCDYSz) {
				Y = 0;
    4d3a:	10 92 de 02 	sts	0x02DE, r1
				TIMSK_LCD &= ~(1<<OCIE1B);	//stop Output CompareB interrups
    4d3e:	80 91 6f 00 	lds	r24, 0x006F
    4d42:	8b 7f       	andi	r24, 0xFB	; 251
    4d44:	80 93 6f 00 	sts	0x006F, r24
    4d48:	e0 e0       	ldi	r30, 0x00	; 0
    4d4a:	a6 cf       	rjmp	.-180    	; 0x4c98 <__vector_18+0x118>
ISR(TIMER1_COMPB_vect){

	uint16_t LCD_delay = 100;	//50us

	if (LCD_Rst_Flg) {
		switch(LCD_Rst_Flg){
    4d4c:	13 30       	cpi	r17, 0x03	; 3
    4d4e:	09 f0       	breq	.+2      	; 0x4d52 <__vector_18+0x1d2>
    4d50:	56 c0       	rjmp	.+172    	; 0x4dfe <__vector_18+0x27e>
			case 2:
				LCD_FuncSet0();
				break;
			case 3:
				#ifdef Port_LCD_DB0	
					LCD_FuncSet0();
    4d52:	0e 94 69 25 	call	0x4ad2	; 0x4ad2 <LCD_FuncSet0>
    4d56:	3f cf       	rjmp	.-386    	; 0x4bd6 <__vector_18+0x56>
			else
			{
				cursor_symb=0;
			}

			Send(
    4d58:	ca 01       	movw	r24, r20
    4d5a:	88 0f       	add	r24, r24
    4d5c:	99 1f       	adc	r25, r25
    4d5e:	84 0f       	add	r24, r20
    4d60:	95 1f       	adc	r25, r21
    4d62:	fc 01       	movw	r30, r24
    4d64:	ee 0f       	add	r30, r30
    4d66:	ff 1f       	adc	r31, r31
    4d68:	ee 0f       	add	r30, r30
    4d6a:	ff 1f       	adc	r31, r31
    4d6c:	ee 0f       	add	r30, r30
    4d6e:	ff 1f       	adc	r31, r31
    4d70:	e8 1b       	sub	r30, r24
    4d72:	f9 0b       	sbc	r31, r25
    4d74:	e6 0f       	add	r30, r22
    4d76:	f7 1f       	adc	r31, r23
    4d78:	e1 5b       	subi	r30, 0xB1	; 177
    4d7a:	f9 4f       	sbci	r31, 0xF9	; 249
    4d7c:	e0 81       	ld	r30, Z
    4d7e:	f0 e0       	ldi	r31, 0x00	; 0
    4d80:	e7 5b       	subi	r30, 0xB7	; 183
    4d82:	f3 4d       	sbci	r31, 0xD3	; 211
    4d84:	24 91       	lpm	r18, Z+
    4d86:	64 cf       	rjmp	.-312    	; 0x4c50 <__vector_18+0xd0>
ISR(TIMER1_COMPB_vect){

	uint16_t LCD_delay = 100;	//50us

	if (LCD_Rst_Flg) {
		switch(LCD_Rst_Flg){
    4d88:	18 30       	cpi	r17, 0x08	; 8
    4d8a:	49 f0       	breq	.+18     	; 0x4d9e <__vector_18+0x21e>
    4d8c:	19 30       	cpi	r17, 0x09	; 9
    4d8e:	09 f0       	breq	.+2      	; 0x4d92 <__vector_18+0x212>
    4d90:	c0 cf       	rjmp	.-128    	; 0x4d12 <__vector_18+0x192>
						else{i=0;LCD_Rst_Flg = 8;}
					}
				}
				break;
			case 9:
				Port_LCD_RS &=~LCD_RS;
    4d92:	44 98       	cbi	0x08, 4	; 8
				#ifdef NOT_USE_LCD_RETURN_HOME_CMD
					Send(128);			//     
				#else
					Send(0b00000010);	//RETURN HOME					
    4d94:	82 e0       	ldi	r24, 0x02	; 2
    4d96:	0e 94 21 25 	call	0x4a42	; 0x4a42 <Send>
				#endif
				Port_LCD_RS |=LCD_RS;
    4d9a:	44 9a       	sbi	0x08, 4	; 8
    4d9c:	ba cf       	rjmp	.-140    	; 0x4d12 <__vector_18+0x192>
				Send(0b01000000);	//;    CG RAM   0.
				Port_LCD_RS |=LCD_RS;
				break;
			case 8:{
					static uint8_t i,j;
					LCD_Rst_Flg = 7;
    4d9e:	87 e0       	ldi	r24, 0x07	; 7
    4da0:	80 93 cd 04 	sts	0x04CD, r24
					Send(prb(CGRAM_LCD[i]+j));
    4da4:	f0 90 e1 02 	lds	r15, 0x02E1
    4da8:	00 91 e0 02 	lds	r16, 0x02E0
    4dac:	ef 2d       	mov	r30, r15
    4dae:	f0 e0       	ldi	r31, 0x00	; 0
    4db0:	ee 0f       	add	r30, r30
    4db2:	ff 1f       	adc	r31, r31
    4db4:	ee 0f       	add	r30, r30
    4db6:	ff 1f       	adc	r31, r31
    4db8:	ee 0f       	add	r30, r30
    4dba:	ff 1f       	adc	r31, r31
    4dbc:	e0 0f       	add	r30, r16
    4dbe:	f1 1d       	adc	r31, r1
    4dc0:	e7 5f       	subi	r30, 0xF7	; 247
    4dc2:	f3 4d       	sbci	r31, 0xD3	; 211
    4dc4:	e4 91       	lpm	r30, Z+
    4dc6:	8e 2f       	mov	r24, r30
    4dc8:	0e 94 21 25 	call	0x4a42	; 0x4a42 <Send>
					if(j<7) j++;
    4dcc:	07 30       	cpi	r16, 0x07	; 7
    4dce:	f0 f0       	brcs	.+60     	; 0x4e0c <__vector_18+0x28c>
					else{
						j=0;
    4dd0:	10 92 e0 02 	sts	0x02E0, r1
						if(i<7)i++;
    4dd4:	26 e0       	ldi	r18, 0x06	; 6
    4dd6:	2f 15       	cp	r18, r15
    4dd8:	e8 f0       	brcs	.+58     	; 0x4e14 <__vector_18+0x294>
    4dda:	f3 94       	inc	r15
    4ddc:	f0 92 e1 02 	sts	0x02E1, r15
    4de0:	fa ce       	rjmp	.-524    	; 0x4bd6 <__vector_18+0x56>
		static uint8_t X, Y;
		static prog_uint8_t LineAddr[] = {128, 192, 148, 212};
		unsigned char cursor_symb;
		
		if (X<LCDXSz) {
			if((X>=CurrX)&&(X<(CurrX+StrSize))&&(Y==CurrLCD)){
    4de2:	e0 91 de 02 	lds	r30, 0x02DE
    4de6:	80 91 96 08 	lds	r24, 0x0896
    4dea:	e8 17       	cp	r30, r24
    4dec:	09 f0       	breq	.+2      	; 0x4df0 <__vector_18+0x270>
    4dee:	17 cf       	rjmp	.-466    	; 0x4c1e <__vector_18+0x9e>
    4df0:	2f e5       	ldi	r18, 0x5F	; 95
    4df2:	16 cf       	rjmp	.-468    	; 0x4c20 <__vector_18+0xa0>
				break;
			case 6:
				Send(0b00000110);	//; cursor shift right, no display shift
				break;
			case 7:
				Send(0b01000000);	//;    CG RAM   0.
    4df4:	80 e4       	ldi	r24, 0x40	; 64
    4df6:	0e 94 21 25 	call	0x4a42	; 0x4a42 <Send>
				Port_LCD_RS |=LCD_RS;
    4dfa:	44 9a       	sbi	0x08, 4	; 8
    4dfc:	ec ce       	rjmp	.-552    	; 0x4bd6 <__vector_18+0x56>
ISR(TIMER1_COMPB_vect){

	uint16_t LCD_delay = 100;	//50us

	if (LCD_Rst_Flg) {
		switch(LCD_Rst_Flg){
    4dfe:	14 30       	cpi	r17, 0x04	; 4
    4e00:	09 f0       	breq	.+2      	; 0x4e04 <__vector_18+0x284>
    4e02:	87 cf       	rjmp	.-242    	; 0x4d12 <__vector_18+0x192>
					LCD_FuncSet1();
				#endif
				break;
			case 4:
				#ifdef Port_LCD_DB0	
					Send(0b00111000);	//; 8-bits DL, 2 lines, 5x7 dots
    4e04:	88 e3       	ldi	r24, 0x38	; 56
    4e06:	0e 94 21 25 	call	0x4a42	; 0x4a42 <Send>
    4e0a:	e5 ce       	rjmp	.-566    	; 0x4bd6 <__vector_18+0x56>
				break;
			case 8:{
					static uint8_t i,j;
					LCD_Rst_Flg = 7;
					Send(prb(CGRAM_LCD[i]+j));
					if(j<7) j++;
    4e0c:	0f 5f       	subi	r16, 0xFF	; 255
    4e0e:	00 93 e0 02 	sts	0x02E0, r16
    4e12:	e1 ce       	rjmp	.-574    	; 0x4bd6 <__vector_18+0x56>
					else{
						j=0;
						if(i<7)i++;
						else{i=0;LCD_Rst_Flg = 8;}
    4e14:	10 92 e1 02 	sts	0x02E1, r1
    4e18:	10 93 cd 04 	sts	0x04CD, r17
    4e1c:	dc ce       	rjmp	.-584    	; 0x4bd6 <__vector_18+0x56>

00004e1e <LCDBackLightOn>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    4e1e:	9f b7       	in	r25, 0x3f	; 63
    4e20:	90 78       	andi	r25, 0x80	; 128
    4e22:	90 93 e5 02 	sts	0x02E5, r25
	cli();
    4e26:	f8 94       	cli
	void LCDBackLightOn(void){
		IntOff();	
		#ifdef BACKLIGHT_INVERSION
			PORT_BACKLIGHT &= ~BACKLIGHT;
		#else
			PORT_BACKLIGHT |= BACKLIGHT;
    4e28:	80 91 0b 01 	lds	r24, 0x010B
    4e2c:	80 64       	ori	r24, 0x40	; 64
    4e2e:	80 93 0b 01 	sts	0x010B, r24

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    4e32:	99 23       	and	r25, r25
    4e34:	09 f0       	breq	.+2      	; 0x4e38 <LCDBackLightOn+0x1a>
		sei();
    4e36:	78 94       	sei
    4e38:	08 95       	ret

00004e3a <LCDBackLightOff>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    4e3a:	9f b7       	in	r25, 0x3f	; 63
    4e3c:	90 78       	andi	r25, 0x80	; 128
    4e3e:	90 93 e5 02 	sts	0x02E5, r25
	cli();
    4e42:	f8 94       	cli
	void LCDBackLightOff(void){
		IntOff();	
		#ifdef BACKLIGHT_INVERSION
			PORT_BACKLIGHT |= BACKLIGHT;
		#else
			PORT_BACKLIGHT &= ~BACKLIGHT;
    4e44:	80 91 0b 01 	lds	r24, 0x010B
    4e48:	8f 7b       	andi	r24, 0xBF	; 191
    4e4a:	80 93 0b 01 	sts	0x010B, r24

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    4e4e:	99 23       	and	r25, r25
    4e50:	09 f0       	breq	.+2      	; 0x4e54 <LCDBackLightOff+0x1a>
		sei();
    4e52:	78 94       	sei
    4e54:	08 95       	ret

00004e56 <LCDBackLightControl>:
				StartTimer16(TD_BackLight, 3000);
				break;			
		}
	}
	void LCDBackLightControl(void){
		switch(BackLightMode){
    4e56:	80 91 49 06 	lds	r24, 0x0649
    4e5a:	81 30       	cpi	r24, 0x01	; 1
    4e5c:	29 f0       	breq	.+10     	; 0x4e68 <LCDBackLightControl+0x12>
    4e5e:	82 30       	cpi	r24, 0x02	; 2
    4e60:	61 f0       	breq	.+24     	; 0x4e7a <LCDBackLightControl+0x24>
		case 1: if(Timer16Stopp(TD_BackLight)) LCDBackLightOff();
			break;
		case 2:
			break;
		default: LCDBackLightOn();
    4e62:	0e 94 0f 27 	call	0x4e1e	; 0x4e1e <LCDBackLightOn>
    4e66:	08 95       	ret
				break;			
		}
	}
	void LCDBackLightControl(void){
		switch(BackLightMode){
		case 1: if(Timer16Stopp(TD_BackLight)) LCDBackLightOff();
    4e68:	80 91 cf 04 	lds	r24, 0x04CF
    4e6c:	0e 94 41 1b 	call	0x3682	; 0x3682 <Timer16Stopp>
    4e70:	88 23       	and	r24, r24
    4e72:	c9 f3       	breq	.-14     	; 0x4e66 <LCDBackLightControl+0x10>
    4e74:	0e 94 1d 27 	call	0x4e3a	; 0x4e3a <LCDBackLightOff>
    4e78:	08 95       	ret
    4e7a:	08 95       	ret

00004e7c <StartTimer0>:
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
		TCCR0  = ((((1<<WGM01) &~(1<<WGM00)  &~(1<<COM01)  &~(1<<COM00)) |(1<<CS02)) &~(1<<CS01)) |(1<<CS00);
	#elif defined (__AVR_ATmega128__)
		TCCR0  =   ((1<<WGM01) &~(1<<WGM00)  &~(1<<COM01)  &~(1<<COM00)) |(1<<CS02)   |(1<<CS01)  |(1<<CS00);
	#elif defined (__AVR_ATmega1280__)  || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TCCR0A =    (1<<WGM01) &~(1<<WGM00)  &~(1<<COM0A1) &~(1<<COM0A0) &~(1<<COM0B1) &~(1<<COM0B0);
    4e7c:	82 e0       	ldi	r24, 0x02	; 2
    4e7e:	84 bd       	out	0x24, r24	; 36
		TCCR0B = ((~(1<<WGM02)                                           |(1<<CS02)) &~(1<<CS01)) |(1<<CS00);
    4e80:	85 ef       	ldi	r24, 0xF5	; 245
    4e82:	85 bd       	out	0x25, r24	; 37
	#endif
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__)
		TIMSK |=(1<<OCIE0);
	#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TIMSK0 |=(1<<OCIE0A);
    4e84:	ee e6       	ldi	r30, 0x6E	; 110
    4e86:	f0 e0       	ldi	r31, 0x00	; 0
    4e88:	80 81       	ld	r24, Z
    4e8a:	82 60       	ori	r24, 0x02	; 2
    4e8c:	80 83       	st	Z, r24
	#endif
}
    4e8e:	08 95       	ret

00004e90 <StartTimer2>:
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
		TCCR2  =   ((1<<WGM21) &~(1<<WGM20)  &~(1<<COM21)  &~(1<<COM20)) |(1<<CS22)   |(1<<CS21)  |(1<<CS20);
	#elif defined (__AVR_ATmega128__)
		TCCR2  = ((((1<<WGM21) &~(1<<WGM20)  &~(1<<COM21)  &~(1<<COM20)) |(1<<CS22)) &~(1<<CS21)) |(1<<CS20);
	#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TCCR2A =    (1<<WGM21) &~(1<<WGM20)  &~(1<<COM2A1) &~(1<<COM2A0) &~(1<<COM2B1) &~(1<<COM2B0);
    4e90:	82 e0       	ldi	r24, 0x02	; 2
    4e92:	80 93 b0 00 	sts	0x00B0, r24
		TCCR2B =   ~(1<<WGM22)                                           |(1<<CS22)   |(1<<CS21)  |(1<<CS20);
    4e96:	87 ef       	ldi	r24, 0xF7	; 247
    4e98:	80 93 b1 00 	sts	0x00B1, r24
	#endif
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__)
		TIMSK |=(1<<OCIE2);
	#elif  defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TIMSK2 |=(1<<OCIE2A);
    4e9c:	e0 e7       	ldi	r30, 0x70	; 112
    4e9e:	f0 e0       	ldi	r31, 0x00	; 0
    4ea0:	80 81       	ld	r24, Z
    4ea2:	82 60       	ori	r24, 0x02	; 2
    4ea4:	80 83       	st	Z, r24
	#endif
}
    4ea6:	08 95       	ret

00004ea8 <StartTimer4>:
#if defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
	//static void
	void
	StartTimer4(void)
	{
		TCCR4A = 0;
    4ea8:	10 92 a0 00 	sts	0x00A0, r1
		TCCR4B = (1<<WGM42) | (1<<CS42) | (0<<CS41) | (1<<CS40);	// clk/1024
    4eac:	8d e0       	ldi	r24, 0x0D	; 13
    4eae:	80 93 a1 00 	sts	0x00A1, r24
		TIMSK4 |=(1<<OCIE4A);
    4eb2:	e2 e7       	ldi	r30, 0x72	; 114
    4eb4:	f0 e0       	ldi	r31, 0x00	; 0
    4eb6:	80 81       	ld	r24, Z
    4eb8:	82 60       	ori	r24, 0x02	; 2
    4eba:	80 83       	st	Z, r24
	}
    4ebc:	08 95       	ret

00004ebe <MB_Timer_ISR>:
// ~~~

// ~~~~~~~~~~~~~~~~~~~
static void
MB_Timer_ISR(tc_t *tc)
{
    4ebe:	bc 01       	movw	r22, r24

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    4ec0:	e7 ef       	ldi	r30, 0xF7	; 247
    4ec2:	fb e2       	ldi	r31, 0x2B	; 43
    4ec4:	85 91       	lpm	r24, Z+
    4ec6:	94 91       	lpm	r25, Z+
	#if defined (__AVR_ATxmega128A1__)
		tc->INTCTRLA = (tc->INTCTRLA &~TC1_OVFINTLVL_gm) |TC_OVFINTLVL_OFF_gc;
		tc->CTRLA = TC_CLKSEL_OFF_gc;
	#endif
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Timer[MB_N]tc_f)!=tc; MB_N++);
    4ec8:	68 17       	cp	r22, r24
    4eca:	79 07       	cpc	r23, r25
    4ecc:	09 f4       	brne	.+2      	; 0x4ed0 <MB_Timer_ISR+0x12>
    4ece:	54 c0       	rjmp	.+168    	; 0x4f78 <MB_Timer_ISR+0xba>
    4ed0:	20 e0       	ldi	r18, 0x00	; 0
    4ed2:	2f 5f       	subi	r18, 0xFF	; 255
    4ed4:	42 2f       	mov	r20, r18
    4ed6:	50 e0       	ldi	r21, 0x00	; 0
    4ed8:	fa 01       	movw	r30, r20
    4eda:	ee 0f       	add	r30, r30
    4edc:	ff 1f       	adc	r31, r31
    4ede:	e4 0f       	add	r30, r20
    4ee0:	f5 1f       	adc	r31, r21
    4ee2:	ee 0f       	add	r30, r30
    4ee4:	ff 1f       	adc	r31, r31
    4ee6:	e9 50       	subi	r30, 0x09	; 9
    4ee8:	f4 4d       	sbci	r31, 0xD4	; 212
    4eea:	85 91       	lpm	r24, Z+
    4eec:	94 91       	lpm	r25, Z+
    4eee:	68 17       	cp	r22, r24
    4ef0:	79 07       	cpc	r23, r25
    4ef2:	79 f7       	brne	.-34     	; 0x4ed2 <MB_Timer_ISR+0x14>
    4ef4:	fa 01       	movw	r30, r20

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    4ef6:	ea 50       	subi	r30, 0x0A	; 10
    4ef8:	f4 4d       	sbci	r31, 0xD4	; 212
    4efa:	84 91       	lpm	r24, Z+

	
	switch (prb(MB_Role+MB_N)){
    4efc:	88 23       	and	r24, r24
    4efe:	f9 f4       	brne	.+62     	; 0x4f3e <MB_Timer_ISR+0x80>
	case Role_Slave:
		if(MB_Frame[MB_N][0]==MB_NativeAddr[MB_N]){	// Slave     -   MB_TimerFlag
    4f00:	f4 2f       	mov	r31, r20
    4f02:	ee 27       	eor	r30, r30
    4f04:	e7 5e       	subi	r30, 0xE7	; 231
    4f06:	f4 4f       	sbci	r31, 0xF4	; 244
    4f08:	da 01       	movw	r26, r20
    4f0a:	a9 52       	subi	r26, 0x29	; 41
    4f0c:	ba 4f       	sbci	r27, 0xFA	; 250
    4f0e:	90 81       	ld	r25, Z
    4f10:	8c 91       	ld	r24, X
    4f12:	98 17       	cp	r25, r24
    4f14:	21 f1       	breq	.+72     	; 0x4f5e <MB_Timer_ISR+0xa0>
			MB_TimerFlag |= (1<<MB_N);
		}
		else{
			MB_State[MB_N] = MB_Idle;
    4f16:	fa 01       	movw	r30, r20
    4f18:	e7 54       	subi	r30, 0x47	; 71
    4f1a:	fa 4f       	sbci	r31, 0xFA	; 250
    4f1c:	81 e0       	ldi	r24, 0x01	; 1
    4f1e:	80 83       	st	Z, r24
			MB_CPT[MB_N][0]++;
    4f20:	fa 01       	movw	r30, r20
    4f22:	e2 95       	swap	r30
    4f24:	f2 95       	swap	r31
    4f26:	f0 7f       	andi	r31, 0xF0	; 240
    4f28:	fe 27       	eor	r31, r30
    4f2a:	e0 7f       	andi	r30, 0xF0	; 240
    4f2c:	fe 27       	eor	r31, r30
    4f2e:	ec 51       	subi	r30, 0x1C	; 28
    4f30:	f7 4f       	sbci	r31, 0xF7	; 247
    4f32:	80 81       	ld	r24, Z
    4f34:	91 81       	ldd	r25, Z+1	; 0x01
    4f36:	01 96       	adiw	r24, 0x01	; 1
    4f38:	91 83       	std	Z+1, r25	; 0x01
    4f3a:	80 83       	st	Z, r24
    4f3c:	08 95       	ret
	#endif
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Timer[MB_N]tc_f)!=tc; MB_N++);

	
	switch (prb(MB_Role+MB_N)){
    4f3e:	81 30       	cpi	r24, 0x01	; 1
    4f40:	09 f0       	breq	.+2      	; 0x4f44 <MB_Timer_ISR+0x86>
    4f42:	08 95       	ret
			MB_State[MB_N] = MB_Idle;
			MB_CPT[MB_N][0]++;
		}
		break;
	case Role_Master:
		MB_TimerFlag |= (1<<MB_N);
    4f44:	20 91 d8 08 	lds	r18, 0x08D8
    4f48:	81 e0       	ldi	r24, 0x01	; 1
    4f4a:	90 e0       	ldi	r25, 0x00	; 0
    4f4c:	02 c0       	rjmp	.+4      	; 0x4f52 <MB_Timer_ISR+0x94>
    4f4e:	88 0f       	add	r24, r24
    4f50:	99 1f       	adc	r25, r25
    4f52:	4a 95       	dec	r20
    4f54:	e2 f7       	brpl	.-8      	; 0x4f4e <MB_Timer_ISR+0x90>
    4f56:	28 2b       	or	r18, r24
    4f58:	20 93 d8 08 	sts	0x08D8, r18
    4f5c:	08 95       	ret

	
	switch (prb(MB_Role+MB_N)){
	case Role_Slave:
		if(MB_Frame[MB_N][0]==MB_NativeAddr[MB_N]){	// Slave     -   MB_TimerFlag
			MB_TimerFlag |= (1<<MB_N);
    4f5e:	20 91 d8 08 	lds	r18, 0x08D8
    4f62:	81 e0       	ldi	r24, 0x01	; 1
    4f64:	90 e0       	ldi	r25, 0x00	; 0
    4f66:	02 c0       	rjmp	.+4      	; 0x4f6c <MB_Timer_ISR+0xae>
    4f68:	88 0f       	add	r24, r24
    4f6a:	99 1f       	adc	r25, r25
    4f6c:	4a 95       	dec	r20
    4f6e:	e2 f7       	brpl	.-8      	; 0x4f68 <MB_Timer_ISR+0xaa>
    4f70:	28 2b       	or	r18, r24
    4f72:	20 93 d8 08 	sts	0x08D8, r18
    4f76:	08 95       	ret
	#if defined (__AVR_ATxmega128A1__)
		tc->INTCTRLA = (tc->INTCTRLA &~TC1_OVFINTLVL_gm) |TC_OVFINTLVL_OFF_gc;
		tc->CTRLA = TC_CLKSEL_OFF_gc;
	#endif
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Timer[MB_N]tc_f)!=tc; MB_N++);
    4f78:	40 e0       	ldi	r20, 0x00	; 0
    4f7a:	50 e0       	ldi	r21, 0x00	; 0
    4f7c:	e0 e0       	ldi	r30, 0x00	; 0
    4f7e:	f0 e0       	ldi	r31, 0x00	; 0
    4f80:	ba cf       	rjmp	.-140    	; 0x4ef6 <MB_Timer_ISR+0x38>

00004f82 <__vector_21>:
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#elif  defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) ||defined (__AVR_ATmega2561__)
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ISR(TIMER0_COMPA_vect)
{
    4f82:	1f 92       	push	r1
    4f84:	0f 92       	push	r0
    4f86:	0f b6       	in	r0, 0x3f	; 63
    4f88:	0f 92       	push	r0
    4f8a:	0b b6       	in	r0, 0x3b	; 59
    4f8c:	0f 92       	push	r0
    4f8e:	11 24       	eor	r1, r1
    4f90:	2f 93       	push	r18
    4f92:	3f 93       	push	r19
    4f94:	4f 93       	push	r20
    4f96:	5f 93       	push	r21
    4f98:	6f 93       	push	r22
    4f9a:	7f 93       	push	r23
    4f9c:	8f 93       	push	r24
    4f9e:	9f 93       	push	r25
    4fa0:	af 93       	push	r26
    4fa2:	bf 93       	push	r27
    4fa4:	ef 93       	push	r30
    4fa6:	ff 93       	push	r31
	TCCR0B &=~(1<<CS02) &~(1<<CS01) &~(1<<CS00);
    4fa8:	85 b5       	in	r24, 0x25	; 37
    4faa:	88 7f       	andi	r24, 0xF8	; 248
    4fac:	85 bd       	out	0x25, r24	; 37
	TIMSK0 &=~(1<<OCIE0A);
    4fae:	ee e6       	ldi	r30, 0x6E	; 110
    4fb0:	f0 e0       	ldi	r31, 0x00	; 0
    4fb2:	80 81       	ld	r24, Z
    4fb4:	8d 7f       	andi	r24, 0xFD	; 253
    4fb6:	80 83       	st	Z, r24
	MB_Timer_ISR(&TCNT0);
    4fb8:	86 e4       	ldi	r24, 0x46	; 70
    4fba:	90 e0       	ldi	r25, 0x00	; 0
    4fbc:	0e 94 5f 27 	call	0x4ebe	; 0x4ebe <MB_Timer_ISR>
}
    4fc0:	ff 91       	pop	r31
    4fc2:	ef 91       	pop	r30
    4fc4:	bf 91       	pop	r27
    4fc6:	af 91       	pop	r26
    4fc8:	9f 91       	pop	r25
    4fca:	8f 91       	pop	r24
    4fcc:	7f 91       	pop	r23
    4fce:	6f 91       	pop	r22
    4fd0:	5f 91       	pop	r21
    4fd2:	4f 91       	pop	r20
    4fd4:	3f 91       	pop	r19
    4fd6:	2f 91       	pop	r18
    4fd8:	0f 90       	pop	r0
    4fda:	0b be       	out	0x3b, r0	; 59
    4fdc:	0f 90       	pop	r0
    4fde:	0f be       	out	0x3f, r0	; 63
    4fe0:	0f 90       	pop	r0
    4fe2:	1f 90       	pop	r1
    4fe4:	18 95       	reti

00004fe6 <__vector_13>:

// ~~~~~~~~~~~~~~~~~~~
ISR(TIMER2_COMPA_vect)
{
    4fe6:	1f 92       	push	r1
    4fe8:	0f 92       	push	r0
    4fea:	0f b6       	in	r0, 0x3f	; 63
    4fec:	0f 92       	push	r0
    4fee:	0b b6       	in	r0, 0x3b	; 59
    4ff0:	0f 92       	push	r0
    4ff2:	11 24       	eor	r1, r1
    4ff4:	2f 93       	push	r18
    4ff6:	3f 93       	push	r19
    4ff8:	4f 93       	push	r20
    4ffa:	5f 93       	push	r21
    4ffc:	6f 93       	push	r22
    4ffe:	7f 93       	push	r23
    5000:	8f 93       	push	r24
    5002:	9f 93       	push	r25
    5004:	af 93       	push	r26
    5006:	bf 93       	push	r27
    5008:	ef 93       	push	r30
    500a:	ff 93       	push	r31
	TCCR2B &=~(1<<CS22) &~(1<<CS21) &~(1<<CS20);
    500c:	e1 eb       	ldi	r30, 0xB1	; 177
    500e:	f0 e0       	ldi	r31, 0x00	; 0
    5010:	80 81       	ld	r24, Z
    5012:	88 7f       	andi	r24, 0xF8	; 248
    5014:	80 83       	st	Z, r24
	TIMSK2 &=~(1<<OCIE2A);
    5016:	e0 e7       	ldi	r30, 0x70	; 112
    5018:	f0 e0       	ldi	r31, 0x00	; 0
    501a:	80 81       	ld	r24, Z
    501c:	8d 7f       	andi	r24, 0xFD	; 253
    501e:	80 83       	st	Z, r24
	MB_Timer_ISR(&TCNT2);
    5020:	82 eb       	ldi	r24, 0xB2	; 178
    5022:	90 e0       	ldi	r25, 0x00	; 0
    5024:	0e 94 5f 27 	call	0x4ebe	; 0x4ebe <MB_Timer_ISR>
}
    5028:	ff 91       	pop	r31
    502a:	ef 91       	pop	r30
    502c:	bf 91       	pop	r27
    502e:	af 91       	pop	r26
    5030:	9f 91       	pop	r25
    5032:	8f 91       	pop	r24
    5034:	7f 91       	pop	r23
    5036:	6f 91       	pop	r22
    5038:	5f 91       	pop	r21
    503a:	4f 91       	pop	r20
    503c:	3f 91       	pop	r19
    503e:	2f 91       	pop	r18
    5040:	0f 90       	pop	r0
    5042:	0b be       	out	0x3b, r0	; 59
    5044:	0f 90       	pop	r0
    5046:	0f be       	out	0x3f, r0	; 63
    5048:	0f 90       	pop	r0
    504a:	1f 90       	pop	r1
    504c:	18 95       	reti

0000504e <__vector_42>:
// ~~~~~~~~~~~~~~~~~~~
ISR(TIMER4_COMPA_vect)
{
    504e:	1f 92       	push	r1
    5050:	0f 92       	push	r0
    5052:	0f b6       	in	r0, 0x3f	; 63
    5054:	0f 92       	push	r0
    5056:	0b b6       	in	r0, 0x3b	; 59
    5058:	0f 92       	push	r0
    505a:	11 24       	eor	r1, r1
    505c:	2f 93       	push	r18
    505e:	3f 93       	push	r19
    5060:	4f 93       	push	r20
    5062:	5f 93       	push	r21
    5064:	6f 93       	push	r22
    5066:	7f 93       	push	r23
    5068:	8f 93       	push	r24
    506a:	9f 93       	push	r25
    506c:	af 93       	push	r26
    506e:	bf 93       	push	r27
    5070:	ef 93       	push	r30
    5072:	ff 93       	push	r31
	TCCR4B &=~(1<<CS42) &~(1<<CS41) &~(1<<CS40);
    5074:	e1 ea       	ldi	r30, 0xA1	; 161
    5076:	f0 e0       	ldi	r31, 0x00	; 0
    5078:	80 81       	ld	r24, Z
    507a:	88 7f       	andi	r24, 0xF8	; 248
    507c:	80 83       	st	Z, r24
	TIMSK4 &=~(1<<OCIE4A);
    507e:	e2 e7       	ldi	r30, 0x72	; 114
    5080:	f0 e0       	ldi	r31, 0x00	; 0
    5082:	80 81       	ld	r24, Z
    5084:	8d 7f       	andi	r24, 0xFD	; 253
    5086:	80 83       	st	Z, r24
	MB_Timer_ISR((uint8_t*)&TCNT4);
    5088:	84 ea       	ldi	r24, 0xA4	; 164
    508a:	90 e0       	ldi	r25, 0x00	; 0
    508c:	0e 94 5f 27 	call	0x4ebe	; 0x4ebe <MB_Timer_ISR>
}
    5090:	ff 91       	pop	r31
    5092:	ef 91       	pop	r30
    5094:	bf 91       	pop	r27
    5096:	af 91       	pop	r26
    5098:	9f 91       	pop	r25
    509a:	8f 91       	pop	r24
    509c:	7f 91       	pop	r23
    509e:	6f 91       	pop	r22
    50a0:	5f 91       	pop	r21
    50a2:	4f 91       	pop	r20
    50a4:	3f 91       	pop	r19
    50a6:	2f 91       	pop	r18
    50a8:	0f 90       	pop	r0
    50aa:	0b be       	out	0x3b, r0	; 59
    50ac:	0f 90       	pop	r0
    50ae:	0f be       	out	0x3f, r0	; 63
    50b0:	0f 90       	pop	r0
    50b2:	1f 90       	pop	r1
    50b4:	18 95       	reti

000050b6 <MBRecept>:
		#endif
		MB_Err &=(1<<MB_N);
		return;
	}
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		Buf = USART_Reg(MB_N, ucsra);
    50b6:	68 2f       	mov	r22, r24
    50b8:	70 e0       	ldi	r23, 0x00	; 0

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    50ba:	9b 01       	movw	r18, r22
    50bc:	22 0f       	add	r18, r18
    50be:	33 1f       	adc	r19, r19
    50c0:	cb 01       	movw	r24, r22
    50c2:	88 0f       	add	r24, r24
    50c4:	99 1f       	adc	r25, r25
    50c6:	88 0f       	add	r24, r24
    50c8:	99 1f       	adc	r25, r25
    50ca:	88 0f       	add	r24, r24
    50cc:	99 1f       	adc	r25, r25
    50ce:	28 0f       	add	r18, r24
    50d0:	39 1f       	adc	r19, r25
    50d2:	22 0f       	add	r18, r18
    50d4:	33 1f       	adc	r19, r19
    50d6:	2c 51       	subi	r18, 0x1C	; 28
    50d8:	34 4d       	sbci	r19, 0xD4	; 212
    50da:	f9 01       	movw	r30, r18
    50dc:	a5 91       	lpm	r26, Z+
    50de:	b4 91       	lpm	r27, Z+
    50e0:	3c 91       	ld	r19, X
		MB_Frame[MB_N][MB_Frame_Sz[MB_N]++] = USART_Reg(MB_N, udr);
    50e2:	ab 01       	movw	r20, r22
    50e4:	45 50       	subi	r20, 0x05	; 5
    50e6:	59 4f       	sbci	r21, 0xF9	; 249
    50e8:	fa 01       	movw	r30, r20
    50ea:	20 81       	ld	r18, Z
    50ec:	cb 01       	movw	r24, r22
    50ee:	88 0f       	add	r24, r24
    50f0:	99 1f       	adc	r25, r25
    50f2:	88 0f       	add	r24, r24
    50f4:	99 1f       	adc	r25, r25
    50f6:	fc 01       	movw	r30, r24
    50f8:	ee 0f       	add	r30, r30
    50fa:	ff 1f       	adc	r31, r31
    50fc:	ee 0f       	add	r30, r30
    50fe:	ff 1f       	adc	r31, r31
    5100:	e8 0f       	add	r30, r24
    5102:	f9 1f       	adc	r31, r25
    5104:	ee 51       	subi	r30, 0x1E	; 30
    5106:	f4 4d       	sbci	r31, 0xD4	; 212
    5108:	a5 91       	lpm	r26, Z+
    510a:	b4 91       	lpm	r27, Z+
    510c:	f6 2f       	mov	r31, r22
    510e:	ee 27       	eor	r30, r30
    5110:	e2 0f       	add	r30, r18
    5112:	f1 1d       	adc	r31, r1
    5114:	e7 5e       	subi	r30, 0xE7	; 231
    5116:	f4 4f       	sbci	r31, 0xF4	; 244
    5118:	8c 91       	ld	r24, X
    511a:	80 83       	st	Z, r24
    511c:	2f 5f       	subi	r18, 0xFF	; 255
    511e:	fa 01       	movw	r30, r20
    5120:	20 83       	st	Z, r18
	#elif defined (__AVR_ATxmega128A1__)
		USART_t *usart = prp(&MB_Port[MB_N].usart);
		Buf = usart->STATUS;
		MB_Frame[MB_N][MB_Frame_Sz[MB_N]++] = usart->DATA;
	#endif
	if (Buf &(1<<3))
    5122:	23 2f       	mov	r18, r19
    5124:	30 e0       	ldi	r19, 0x00	; 0
    5126:	23 ff       	sbrs	r18, 3
    5128:	0e c0       	rjmp	.+28     	; 0x5146 <MBRecept+0x90>
		MB_CPT[MB_N][7]++;
    512a:	fb 01       	movw	r30, r22
    512c:	e2 95       	swap	r30
    512e:	f2 95       	swap	r31
    5130:	f0 7f       	andi	r31, 0xF0	; 240
    5132:	fe 27       	eor	r31, r30
    5134:	e0 7f       	andi	r30, 0xF0	; 240
    5136:	fe 27       	eor	r31, r30
    5138:	ec 51       	subi	r30, 0x1C	; 28
    513a:	f7 4f       	sbci	r31, 0xF7	; 247
    513c:	86 85       	ldd	r24, Z+14	; 0x0e
    513e:	97 85       	ldd	r25, Z+15	; 0x0f
    5140:	01 96       	adiw	r24, 0x01	; 1
    5142:	97 87       	std	Z+15, r25	; 0x0f
    5144:	86 87       	std	Z+14, r24	; 0x0e
	if (Buf &((1<<4) |(1<<3) |(1<<2)))
    5146:	2c 71       	andi	r18, 0x1C	; 28
    5148:	30 70       	andi	r19, 0x00	; 0
    514a:	23 2b       	or	r18, r19
    514c:	61 f0       	breq	.+24     	; 0x5166 <MBRecept+0xb0>
		MB_Err |=(1<<MB_N);
    514e:	81 e0       	ldi	r24, 0x01	; 1
    5150:	90 e0       	ldi	r25, 0x00	; 0
    5152:	02 c0       	rjmp	.+4      	; 0x5158 <MBRecept+0xa2>
    5154:	88 0f       	add	r24, r24
    5156:	99 1f       	adc	r25, r25
    5158:	6a 95       	dec	r22
    515a:	e2 f7       	brpl	.-8      	; 0x5154 <MBRecept+0x9e>
    515c:	20 91 d0 04 	lds	r18, 0x04D0
    5160:	28 2b       	or	r18, r24
    5162:	20 93 d0 04 	sts	0x04D0, r18
    5166:	08 95       	ret

00005168 <MB_Transm>:
}

// ~~~~~~~~~~~~~~~~~~~~
void
MB_Transm(uint8_t MB_N)
{
    5168:	af 92       	push	r10
    516a:	bf 92       	push	r11
    516c:	cf 92       	push	r12
    516e:	df 92       	push	r13
    5170:	ef 92       	push	r14
    5172:	ff 92       	push	r15
    5174:	0f 93       	push	r16
    5176:	1f 93       	push	r17
	MB_State[MB_N] = MB_Trans;
    5178:	e8 2e       	mov	r14, r24
    517a:	ff 24       	eor	r15, r15
    517c:	f7 01       	movw	r30, r14
    517e:	e7 54       	subi	r30, 0x47	; 71
    5180:	fa 4f       	sbci	r31, 0xFA	; 250
    5182:	83 e0       	ldi	r24, 0x03	; 3
    5184:	80 83       	st	Z, r24
    5186:	57 01       	movw	r10, r14
    5188:	aa 0c       	add	r10, r10
    518a:	bb 1c       	adc	r11, r11
    518c:	aa 0c       	add	r10, r10
    518e:	bb 1c       	adc	r11, r11
    5190:	85 01       	movw	r16, r10
    5192:	00 0f       	add	r16, r16
    5194:	11 1f       	adc	r17, r17
    5196:	00 0f       	add	r16, r16
    5198:	11 1f       	adc	r17, r17
    519a:	0a 0d       	add	r16, r10
    519c:	1b 1d       	adc	r17, r11
    519e:	04 5f       	subi	r16, 0xF4	; 244
    51a0:	1f 4f       	sbci	r17, 0xFF	; 255
    51a2:	82 ee       	ldi	r24, 0xE2	; 226
    51a4:	c8 2e       	mov	r12, r24
    51a6:	8b e2       	ldi	r24, 0x2B	; 43
    51a8:	d8 2e       	mov	r13, r24
    51aa:	c6 01       	movw	r24, r12
    51ac:	80 0f       	add	r24, r16
    51ae:	91 1f       	adc	r25, r17
    51b0:	0c 50       	subi	r16, 0x0C	; 12
    51b2:	10 40       	sbci	r17, 0x00	; 0
    51b4:	fc 01       	movw	r30, r24
    51b6:	25 91       	lpm	r18, Z+
    51b8:	34 91       	lpm	r19, Z+
	USART_Func(MB_N, RS485);
    51ba:	f9 01       	movw	r30, r18
    51bc:	19 95       	eicall
    51be:	f6 01       	movw	r30, r12
    51c0:	e0 0f       	add	r30, r16
    51c2:	f1 1f       	adc	r31, r17
    51c4:	a5 91       	lpm	r26, Z+
    51c6:	b4 91       	lpm	r27, Z+
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		//USART_Reg(MB_N, ucsrb) |=(1<<6);
		USART_Reg(MB_N, udr) = MB_Frame[MB_N][0];
    51c8:	fe 2d       	mov	r31, r14
    51ca:	ee 27       	eor	r30, r30
    51cc:	e7 5e       	subi	r30, 0xE7	; 231
    51ce:	f4 4f       	sbci	r31, 0xF4	; 244
    51d0:	80 81       	ld	r24, Z
    51d2:	8c 93       	st	X, r24
    51d4:	97 01       	movw	r18, r14
    51d6:	22 0f       	add	r18, r18
    51d8:	33 1f       	adc	r19, r19
    51da:	c7 01       	movw	r24, r14
    51dc:	88 0f       	add	r24, r24
    51de:	99 1f       	adc	r25, r25
    51e0:	88 0f       	add	r24, r24
    51e2:	99 1f       	adc	r25, r25
    51e4:	88 0f       	add	r24, r24
    51e6:	99 1f       	adc	r25, r25
    51e8:	28 0f       	add	r18, r24
    51ea:	39 1f       	adc	r19, r25
    51ec:	2f 5f       	subi	r18, 0xFF	; 255
    51ee:	3f 4f       	sbci	r19, 0xFF	; 255
    51f0:	22 0f       	add	r18, r18
    51f2:	33 1f       	adc	r19, r19
    51f4:	2c 0d       	add	r18, r12
    51f6:	3d 1d       	adc	r19, r13
    51f8:	f9 01       	movw	r30, r18
    51fa:	a5 91       	lpm	r26, Z+
    51fc:	b4 91       	lpm	r27, Z+

		USART_Reg(MB_N, ucsra) |=(1<<6);	//Clear TxC pending interrupt		
    51fe:	8c 91       	ld	r24, X
    5200:	80 64       	ori	r24, 0x40	; 64
    5202:	8c 93       	st	X, r24
    5204:	c5 01       	movw	r24, r10
    5206:	8e 0d       	add	r24, r14
    5208:	9f 1d       	adc	r25, r15
    520a:	01 96       	adiw	r24, 0x01	; 1
    520c:	88 0f       	add	r24, r24
    520e:	99 1f       	adc	r25, r25
    5210:	88 0f       	add	r24, r24
    5212:	99 1f       	adc	r25, r25
    5214:	8c 0d       	add	r24, r12
    5216:	9d 1d       	adc	r25, r13
    5218:	fc 01       	movw	r30, r24
    521a:	a5 91       	lpm	r26, Z+
    521c:	b4 91       	lpm	r27, Z+
		USART_Reg(MB_N, ucsrb) |=(1<<5);
    521e:	8c 91       	ld	r24, X
    5220:	80 62       	ori	r24, 0x20	; 32
    5222:	8c 93       	st	X, r24
	#elif defined (__AVR_ATxmega128A1__)
		USART_t *usart = prp(&MB_Port[MB_N].usart);
		usart->CTRLA = (usart->CTRLA &~USART_TXCINTLVL_gm) |USART_TXCINTLVL_HI_gc;
		usart->DATA = MB_Frame[MB_N][0];
	#endif
}
    5224:	1f 91       	pop	r17
    5226:	0f 91       	pop	r16
    5228:	ff 90       	pop	r15
    522a:	ef 90       	pop	r14
    522c:	df 90       	pop	r13
    522e:	cf 90       	pop	r12
    5230:	bf 90       	pop	r11
    5232:	af 90       	pop	r10
    5234:	08 95       	ret

00005236 <Modbus_RX>:

// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_RX(usart_t *usart)
{
    5236:	cf 93       	push	r28
    5238:	df 93       	push	r29
    523a:	dc 01       	movw	r26, r24
    523c:	e2 ee       	ldi	r30, 0xE2	; 226
    523e:	fb e2       	ldi	r31, 0x2B	; 43
    5240:	85 91       	lpm	r24, Z+
    5242:	94 91       	lpm	r25, Z+
// ~~~~~~~~~~~~~~~~~~~~~~
static uint8_t
MB_Port_N(usart_t *usart)
{
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Port[MB_N].usart_field)!=usart; MB_N++);
    5244:	a8 17       	cp	r26, r24
    5246:	b9 07       	cpc	r27, r25
    5248:	09 f4       	brne	.+2      	; 0x524c <Modbus_RX+0x16>
    524a:	6e c0       	rjmp	.+220    	; 0x5328 <Modbus_RX+0xf2>
    524c:	30 e0       	ldi	r19, 0x00	; 0
    524e:	3f 5f       	subi	r19, 0xFF	; 255
    5250:	c3 2f       	mov	r28, r19
    5252:	d0 e0       	ldi	r29, 0x00	; 0
    5254:	ce 01       	movw	r24, r28
    5256:	88 0f       	add	r24, r24
    5258:	99 1f       	adc	r25, r25
    525a:	88 0f       	add	r24, r24
    525c:	99 1f       	adc	r25, r25
    525e:	fc 01       	movw	r30, r24
    5260:	ee 0f       	add	r30, r30
    5262:	ff 1f       	adc	r31, r31
    5264:	ee 0f       	add	r30, r30
    5266:	ff 1f       	adc	r31, r31
    5268:	e8 0f       	add	r30, r24
    526a:	f9 1f       	adc	r31, r25
    526c:	ee 51       	subi	r30, 0x1E	; 30
    526e:	f4 4d       	sbci	r31, 0xD4	; 212
    5270:	85 91       	lpm	r24, Z+
    5272:	94 91       	lpm	r25, Z+
    5274:	a8 17       	cp	r26, r24
    5276:	b9 07       	cpc	r27, r25
    5278:	51 f7       	brne	.-44     	; 0x524e <Modbus_RX+0x18>
// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_RX(usart_t *usart)
{
	uint8_t MB_N = MB_Port_N(usart);
	switch (MB_State[MB_N]) {
    527a:	fe 01       	movw	r30, r28
    527c:	e7 54       	subi	r30, 0x47	; 71
    527e:	fa 4f       	sbci	r31, 0xFA	; 250
    5280:	80 81       	ld	r24, Z
    5282:	82 30       	cpi	r24, 0x02	; 2
    5284:	19 f1       	breq	.+70     	; 0x52cc <Modbus_RX+0x96>
    5286:	83 30       	cpi	r24, 0x03	; 3
    5288:	28 f0       	brcs	.+10     	; 0x5294 <Modbus_RX+0x5e>
    528a:	86 30       	cpi	r24, 0x06	; 6
    528c:	d8 f0       	brcs	.+54     	; 0x52c4 <Modbus_RX+0x8e>
	case MB_Trans: case MB_Proc: 
	case MB_NoReply: // MB_NoReply    MB_Recept ..  MB_M_Cycle   MB_Trans
		usart_data(usart);
		break;
	}
}
    528e:	df 91       	pop	r29
    5290:	cf 91       	pop	r28
    5292:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_RX(usart_t *usart)
{
	uint8_t MB_N = MB_Port_N(usart);
	switch (MB_State[MB_N]) {
    5294:	88 23       	and	r24, r24
    5296:	f1 f4       	brne	.+60     	; 0x52d4 <Modbus_RX+0x9e>
	case MB_Initi:
		MB_Frame[MB_N][0] = usart_data(usart);
    5298:	8c 91       	ld	r24, X
    529a:	fc 2f       	mov	r31, r28
    529c:	ee 27       	eor	r30, r30
    529e:	e7 5e       	subi	r30, 0xE7	; 231
    52a0:	f4 4f       	sbci	r31, 0xF4	; 244
    52a2:	80 83       	st	Z, r24
    52a4:	ce 01       	movw	r24, r28
    52a6:	88 0f       	add	r24, r24
    52a8:	99 1f       	adc	r25, r25
    52aa:	8c 0f       	add	r24, r28
    52ac:	9d 1f       	adc	r25, r29
    52ae:	88 0f       	add	r24, r24
    52b0:	99 1f       	adc	r25, r25
    52b2:	89 50       	subi	r24, 0x09	; 9
    52b4:	94 4d       	sbci	r25, 0xD4	; 212
    52b6:	fc 01       	movw	r30, r24
    52b8:	a5 91       	lpm	r26, Z+
    52ba:	b4 91       	lpm	r27, Z+
		break;
	case MB_Recept:
		/*if(TCNT2>=prb(&(BR_Tbl+MB_BitRate_RAM[MB_N])->Time15))
			MB_Err &=(1<<MB_N);*/
		MBRecept(MB_N);
		MB_ClearTimer(MB_N);
    52bc:	1c 92       	st	X, r1
	case MB_Trans: case MB_Proc: 
	case MB_NoReply: // MB_NoReply    MB_Recept ..  MB_M_Cycle   MB_Trans
		usart_data(usart);
		break;
	}
}
    52be:	df 91       	pop	r29
    52c0:	cf 91       	pop	r28
    52c2:	08 95       	ret
		MBRecept(MB_N);
		MB_ClearTimer(MB_N);
		break;
	case MB_Trans: case MB_Proc: 
	case MB_NoReply: // MB_NoReply    MB_Recept ..  MB_M_Cycle   MB_Trans
		usart_data(usart);
    52c4:	8c 91       	ld	r24, X
		break;
	}
}
    52c6:	df 91       	pop	r29
    52c8:	cf 91       	pop	r28
    52ca:	08 95       	ret
		MB_StartTimer(MB_N);
		break;
	case MB_Recept:
		/*if(TCNT2>=prb(&(BR_Tbl+MB_BitRate_RAM[MB_N])->Time15))
			MB_Err &=(1<<MB_N);*/
		MBRecept(MB_N);
    52cc:	83 2f       	mov	r24, r19
    52ce:	0e 94 5b 28 	call	0x50b6	; 0x50b6 <MBRecept>
    52d2:	e8 cf       	rjmp	.-48     	; 0x52a4 <Modbus_RX+0x6e>
// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_RX(usart_t *usart)
{
	uint8_t MB_N = MB_Port_N(usart);
	switch (MB_State[MB_N]) {
    52d4:	81 30       	cpi	r24, 0x01	; 1
    52d6:	d9 f6       	brne	.-74     	; 0x528e <Modbus_RX+0x58>
	case MB_Initi:
		MB_Frame[MB_N][0] = usart_data(usart);
		MB_ClearTimer(MB_N);
		break;
	case MB_Idle: 
		MB_State[MB_N] = MB_Recept;
    52d8:	82 e0       	ldi	r24, 0x02	; 2
    52da:	80 83       	st	Z, r24
		MB_Err &=~(1<<MB_N);
    52dc:	81 e0       	ldi	r24, 0x01	; 1
    52de:	90 e0       	ldi	r25, 0x00	; 0
    52e0:	0c 2e       	mov	r0, r28
    52e2:	02 c0       	rjmp	.+4      	; 0x52e8 <Modbus_RX+0xb2>
    52e4:	88 0f       	add	r24, r24
    52e6:	99 1f       	adc	r25, r25
    52e8:	0a 94       	dec	r0
    52ea:	e2 f7       	brpl	.-8      	; 0x52e4 <Modbus_RX+0xae>
    52ec:	80 95       	com	r24
    52ee:	20 91 d0 04 	lds	r18, 0x04D0
    52f2:	28 23       	and	r18, r24
    52f4:	20 93 d0 04 	sts	0x04D0, r18
		MB_Frame_Sz[MB_N] = 0;
    52f8:	fe 01       	movw	r30, r28
    52fa:	e5 50       	subi	r30, 0x05	; 5
    52fc:	f9 4f       	sbci	r31, 0xF9	; 249
    52fe:	10 82       	st	Z, r1
		MBRecept(MB_N);
    5300:	83 2f       	mov	r24, r19
    5302:	0e 94 5b 28 	call	0x50b6	; 0x50b6 <MBRecept>
    5306:	ce 01       	movw	r24, r28
    5308:	88 0f       	add	r24, r24
    530a:	99 1f       	adc	r25, r25
    530c:	8c 0f       	add	r24, r28
    530e:	9d 1f       	adc	r25, r29
    5310:	88 0f       	add	r24, r24
    5312:	99 1f       	adc	r25, r25
    5314:	85 50       	subi	r24, 0x05	; 5
    5316:	94 4d       	sbci	r25, 0xD4	; 212
    5318:	fc 01       	movw	r30, r24
    531a:	25 91       	lpm	r18, Z+
    531c:	34 91       	lpm	r19, Z+
		MB_StartTimer(MB_N);
    531e:	f9 01       	movw	r30, r18
    5320:	19 95       	eicall
	case MB_Trans: case MB_Proc: 
	case MB_NoReply: // MB_NoReply    MB_Recept ..  MB_M_Cycle   MB_Trans
		usart_data(usart);
		break;
	}
}
    5322:	df 91       	pop	r29
    5324:	cf 91       	pop	r28
    5326:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~
static uint8_t
MB_Port_N(usart_t *usart)
{
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Port[MB_N].usart_field)!=usart; MB_N++);
    5328:	30 e0       	ldi	r19, 0x00	; 0
    532a:	c0 e0       	ldi	r28, 0x00	; 0
    532c:	d0 e0       	ldi	r29, 0x00	; 0
    532e:	a5 cf       	rjmp	.-182    	; 0x527a <Modbus_RX+0x44>

00005330 <CommErr>:
}

// ~~~~~~~~~~~~~~~~~~
uint8_t
CommErr(uint8_t MB_N)
{
    5330:	0f 93       	push	r16
    5332:	1f 93       	push	r17
    5334:	cf 93       	push	r28
    5336:	df 93       	push	r29
    5338:	38 2f       	mov	r19, r24
	uint8_t Sz = MB_Frame_Sz[MB_N]-2;
    533a:	c8 2f       	mov	r28, r24
    533c:	d0 e0       	ldi	r29, 0x00	; 0
    533e:	fe 01       	movw	r30, r28
    5340:	e5 50       	subi	r30, 0x05	; 5
    5342:	f9 4f       	sbci	r31, 0xF9	; 249
    5344:	20 81       	ld	r18, Z
	uint8_t Err = MB_Err &(1<<MB_N) || MB_Frame_Sz[MB_N]<3 || *(uint16_t*)(MB_Frame[MB_N]+Sz)!=CRC(rrb, MB_Frame[MB_N], Sz);
    5346:	80 91 d0 04 	lds	r24, 0x04D0
    534a:	90 e0       	ldi	r25, 0x00	; 0
    534c:	03 2e       	mov	r0, r19
    534e:	02 c0       	rjmp	.+4      	; 0x5354 <CommErr+0x24>
    5350:	95 95       	asr	r25
    5352:	87 95       	ror	r24
    5354:	0a 94       	dec	r0
    5356:	e2 f7       	brpl	.-8      	; 0x5350 <CommErr+0x20>
    5358:	80 ff       	sbrs	r24, 0
    535a:	29 c0       	rjmp	.+82     	; 0x53ae <CommErr+0x7e>
	if (Err) {
		MB_CPT[MB_N][1]++;
    535c:	fe 01       	movw	r30, r28
    535e:	ee 0f       	add	r30, r30
    5360:	ff 1f       	adc	r31, r31
    5362:	ee 0f       	add	r30, r30
    5364:	ff 1f       	adc	r31, r31
    5366:	ee 0f       	add	r30, r30
    5368:	ff 1f       	adc	r31, r31
    536a:	ee 0f       	add	r30, r30
    536c:	ff 1f       	adc	r31, r31
    536e:	ea 51       	subi	r30, 0x1A	; 26
    5370:	f7 4f       	sbci	r31, 0xF7	; 247
    5372:	80 81       	ld	r24, Z
    5374:	91 81       	ldd	r25, Z+1	; 0x01
    5376:	01 96       	adiw	r24, 0x01	; 1
    5378:	91 83       	std	Z+1, r25	; 0x01
    537a:	80 83       	st	Z, r24
    537c:	ce 01       	movw	r24, r28
    537e:	88 0f       	add	r24, r24
    5380:	99 1f       	adc	r25, r25
    5382:	88 0f       	add	r24, r24
    5384:	99 1f       	adc	r25, r25
    5386:	9c 01       	movw	r18, r24
    5388:	22 0f       	add	r18, r18
    538a:	33 1f       	adc	r19, r19
    538c:	22 0f       	add	r18, r18
    538e:	33 1f       	adc	r19, r19
    5390:	28 0f       	add	r18, r24
    5392:	39 1f       	adc	r19, r25
    5394:	2e 50       	subi	r18, 0x0E	; 14
    5396:	34 4d       	sbci	r19, 0xD4	; 212
    5398:	f9 01       	movw	r30, r18
    539a:	85 91       	lpm	r24, Z+
    539c:	94 91       	lpm	r25, Z+
		USART_Func(MB_N, LED_Err_On);
    539e:	fc 01       	movw	r30, r24
    53a0:	19 95       	eicall
    53a2:	81 e0       	ldi	r24, 0x01	; 1
	else {
		MB_CPT[MB_N][0]++;
		USART_Func(MB_N, LED_Err_Off);
	}
	return Err;
}
    53a4:	df 91       	pop	r29
    53a6:	cf 91       	pop	r28
    53a8:	1f 91       	pop	r17
    53aa:	0f 91       	pop	r16
    53ac:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~
uint8_t
CommErr(uint8_t MB_N)
{
	uint8_t Sz = MB_Frame_Sz[MB_N]-2;
	uint8_t Err = MB_Err &(1<<MB_N) || MB_Frame_Sz[MB_N]<3 || *(uint16_t*)(MB_Frame[MB_N]+Sz)!=CRC(rrb, MB_Frame[MB_N], Sz);
    53ae:	23 30       	cpi	r18, 0x03	; 3
    53b0:	a8 f2       	brcs	.-86     	; 0x535c <CommErr+0x2c>

// ~~~~~~~~~~~~~~~~~~
uint8_t
CommErr(uint8_t MB_N)
{
	uint8_t Sz = MB_Frame_Sz[MB_N]-2;
    53b2:	22 50       	subi	r18, 0x02	; 2
	uint8_t Err = MB_Err &(1<<MB_N) || MB_Frame_Sz[MB_N]<3 || *(uint16_t*)(MB_Frame[MB_N]+Sz)!=CRC(rrb, MB_Frame[MB_N], Sz);
    53b4:	73 2f       	mov	r23, r19
    53b6:	60 e0       	ldi	r22, 0x00	; 0
    53b8:	fb 01       	movw	r30, r22
    53ba:	e2 0f       	add	r30, r18
    53bc:	f1 1d       	adc	r31, r1
    53be:	e7 5e       	subi	r30, 0xE7	; 231
    53c0:	f4 4f       	sbci	r31, 0xF4	; 244
    53c2:	00 81       	ld	r16, Z
    53c4:	11 81       	ldd	r17, Z+1	; 0x01
    53c6:	67 5e       	subi	r22, 0xE7	; 231
    53c8:	74 4f       	sbci	r23, 0xF4	; 244
    53ca:	30 e0       	ldi	r19, 0x00	; 0
    53cc:	40 e0       	ldi	r20, 0x00	; 0
    53ce:	50 e0       	ldi	r21, 0x00	; 0
    53d0:	8a e4       	ldi	r24, 0x4A	; 74
    53d2:	98 e1       	ldi	r25, 0x18	; 24
    53d4:	0e 94 bd 18 	call	0x317a	; 0x317a <CRC>
    53d8:	08 17       	cp	r16, r24
    53da:	19 07       	cpc	r17, r25
    53dc:	09 f0       	breq	.+2      	; 0x53e0 <CommErr+0xb0>
    53de:	be cf       	rjmp	.-132    	; 0x535c <CommErr+0x2c>
	if (Err) {
		MB_CPT[MB_N][1]++;
		USART_Func(MB_N, LED_Err_On);
	}
	else {
		MB_CPT[MB_N][0]++;
    53e0:	fe 01       	movw	r30, r28
    53e2:	e2 95       	swap	r30
    53e4:	f2 95       	swap	r31
    53e6:	f0 7f       	andi	r31, 0xF0	; 240
    53e8:	fe 27       	eor	r31, r30
    53ea:	e0 7f       	andi	r30, 0xF0	; 240
    53ec:	fe 27       	eor	r31, r30
    53ee:	ec 51       	subi	r30, 0x1C	; 28
    53f0:	f7 4f       	sbci	r31, 0xF7	; 247
    53f2:	80 81       	ld	r24, Z
    53f4:	91 81       	ldd	r25, Z+1	; 0x01
    53f6:	01 96       	adiw	r24, 0x01	; 1
    53f8:	91 83       	std	Z+1, r25	; 0x01
    53fa:	80 83       	st	Z, r24
    53fc:	ce 01       	movw	r24, r28
    53fe:	88 0f       	add	r24, r24
    5400:	99 1f       	adc	r25, r25
    5402:	88 0f       	add	r24, r24
    5404:	99 1f       	adc	r25, r25
    5406:	9c 01       	movw	r18, r24
    5408:	22 0f       	add	r18, r18
    540a:	33 1f       	adc	r19, r19
    540c:	22 0f       	add	r18, r18
    540e:	33 1f       	adc	r19, r19
    5410:	28 0f       	add	r18, r24
    5412:	39 1f       	adc	r19, r25
    5414:	2c 50       	subi	r18, 0x0C	; 12
    5416:	34 4d       	sbci	r19, 0xD4	; 212
    5418:	f9 01       	movw	r30, r18
    541a:	85 91       	lpm	r24, Z+
    541c:	94 91       	lpm	r25, Z+
		USART_Func(MB_N, LED_Err_Off);
    541e:	fc 01       	movw	r30, r24
    5420:	19 95       	eicall
    5422:	80 e0       	ldi	r24, 0x00	; 0
    5424:	bf cf       	rjmp	.-130    	; 0x53a4 <CommErr+0x74>

00005426 <SetCRC_MB>:
}

// ~~~~~~~~~~~~~~~~~~~~
void
SetCRC_MB(uint8_t MB_N)
{
    5426:	df 92       	push	r13
    5428:	ef 92       	push	r14
    542a:	ff 92       	push	r15
    542c:	0f 93       	push	r16
    542e:	1f 93       	push	r17
	uint8_t Sz = MB_Frame_Sz[MB_N]-2;
    5430:	eb ef       	ldi	r30, 0xFB	; 251
    5432:	f6 e0       	ldi	r31, 0x06	; 6
    5434:	e8 0f       	add	r30, r24
    5436:	f1 1d       	adc	r31, r1
    5438:	d0 80       	ld	r13, Z
    543a:	9e ef       	ldi	r25, 0xFE	; 254
    543c:	d9 0e       	add	r13, r25
	*(uint16_t*)(MB_Frame[MB_N]+Sz) = CRC(rrb, MB_Frame[MB_N], Sz);
    543e:	18 2f       	mov	r17, r24
    5440:	00 e0       	ldi	r16, 0x00	; 0
    5442:	89 e1       	ldi	r24, 0x19	; 25
    5444:	e8 2e       	mov	r14, r24
    5446:	8b e0       	ldi	r24, 0x0B	; 11
    5448:	f8 2e       	mov	r15, r24
    544a:	b7 01       	movw	r22, r14
    544c:	60 0f       	add	r22, r16
    544e:	71 1f       	adc	r23, r17
    5450:	2d 2d       	mov	r18, r13
    5452:	30 e0       	ldi	r19, 0x00	; 0
    5454:	40 e0       	ldi	r20, 0x00	; 0
    5456:	50 e0       	ldi	r21, 0x00	; 0
    5458:	8a e4       	ldi	r24, 0x4A	; 74
    545a:	98 e1       	ldi	r25, 0x18	; 24
    545c:	0e 94 bd 18 	call	0x317a	; 0x317a <CRC>
    5460:	0d 0d       	add	r16, r13
    5462:	11 1d       	adc	r17, r1
    5464:	e0 0e       	add	r14, r16
    5466:	f1 1e       	adc	r15, r17
    5468:	f7 01       	movw	r30, r14
    546a:	91 83       	std	Z+1, r25	; 0x01
    546c:	80 83       	st	Z, r24
}
    546e:	1f 91       	pop	r17
    5470:	0f 91       	pop	r16
    5472:	ff 90       	pop	r15
    5474:	ef 90       	pop	r14
    5476:	df 90       	pop	r13
    5478:	08 95       	ret

0000547a <MB_FrameReg>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
MB_FrameReg(uint8_t MB_N, uint8_t i)
{
	return MB_Frame[MB_N][i]<<8 | MB_Frame[MB_N][i+1];
    547a:	70 e0       	ldi	r23, 0x00	; 0
    547c:	a9 e1       	ldi	r26, 0x19	; 25
    547e:	bb e0       	ldi	r27, 0x0B	; 11
    5480:	f8 2f       	mov	r31, r24
    5482:	e0 e0       	ldi	r30, 0x00	; 0
    5484:	ea 0f       	add	r30, r26
    5486:	fb 1f       	adc	r31, r27
    5488:	e6 0f       	add	r30, r22
    548a:	f7 1f       	adc	r31, r23
    548c:	41 81       	ldd	r20, Z+1	; 0x01
    548e:	50 e0       	ldi	r21, 0x00	; 0
    5490:	38 2f       	mov	r19, r24
    5492:	20 e0       	ldi	r18, 0x00	; 0
    5494:	26 0f       	add	r18, r22
    5496:	37 1f       	adc	r19, r23
    5498:	a2 0f       	add	r26, r18
    549a:	b3 1f       	adc	r27, r19
    549c:	9c 91       	ld	r25, X
    549e:	80 e0       	ldi	r24, 0x00	; 0
    54a0:	48 2b       	or	r20, r24
    54a2:	59 2b       	or	r21, r25
}
    54a4:	ca 01       	movw	r24, r20
    54a6:	08 95       	ret

000054a8 <MB_CPT_Clear>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~
void
MB_CPT_Clear(uint8_t MB_N)
{
    54a8:	90 e0       	ldi	r25, 0x00	; 0
    54aa:	20 e0       	ldi	r18, 0x00	; 0
    54ac:	30 e0       	ldi	r19, 0x00	; 0
    54ae:	88 0f       	add	r24, r24
    54b0:	99 1f       	adc	r25, r25
    54b2:	88 0f       	add	r24, r24
    54b4:	99 1f       	adc	r25, r25
    54b6:	88 0f       	add	r24, r24
    54b8:	99 1f       	adc	r25, r25
	for (uint8_t i=0; i<8; MB_CPT[MB_N][i++]=0);
    54ba:	fc 01       	movw	r30, r24
    54bc:	e2 0f       	add	r30, r18
    54be:	f3 1f       	adc	r31, r19
    54c0:	ee 0f       	add	r30, r30
    54c2:	ff 1f       	adc	r31, r31
    54c4:	ec 51       	subi	r30, 0x1C	; 28
    54c6:	f7 4f       	sbci	r31, 0xF7	; 247
    54c8:	11 82       	std	Z+1, r1	; 0x01
    54ca:	10 82       	st	Z, r1
    54cc:	2f 5f       	subi	r18, 0xFF	; 255
    54ce:	3f 4f       	sbci	r19, 0xFF	; 255
    54d0:	28 30       	cpi	r18, 0x08	; 8
    54d2:	31 05       	cpc	r19, r1
    54d4:	91 f7       	brne	.-28     	; 0x54ba <MB_CPT_Clear+0x12>
}
    54d6:	08 95       	ret

000054d8 <MB_S_Timer_ISR>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_S_Timer_ISR(uint8_t MB_N)
{
    54d8:	2f 92       	push	r2
    54da:	3f 92       	push	r3
    54dc:	4f 92       	push	r4
    54de:	5f 92       	push	r5
    54e0:	6f 92       	push	r6
    54e2:	7f 92       	push	r7
    54e4:	8f 92       	push	r8
    54e6:	9f 92       	push	r9
    54e8:	af 92       	push	r10
    54ea:	bf 92       	push	r11
    54ec:	cf 92       	push	r12
    54ee:	df 92       	push	r13
    54f0:	ef 92       	push	r14
    54f2:	ff 92       	push	r15
    54f4:	0f 93       	push	r16
    54f6:	1f 93       	push	r17
    54f8:	df 93       	push	r29
    54fa:	cf 93       	push	r28
    54fc:	cd b7       	in	r28, 0x3d	; 61
    54fe:	de b7       	in	r29, 0x3e	; 62
    5500:	29 97       	sbiw	r28, 0x09	; 9
    5502:	0f b6       	in	r0, 0x3f	; 63
    5504:	f8 94       	cli
    5506:	de bf       	out	0x3e, r29	; 62
    5508:	0f be       	out	0x3f, r0	; 63
    550a:	cd bf       	out	0x3d, r28	; 61
    550c:	d8 2e       	mov	r13, r24
	switch (MB_State[MB_N]) {
    550e:	28 2f       	mov	r18, r24
    5510:	30 e0       	ldi	r19, 0x00	; 0
    5512:	39 87       	std	Y+9, r19	; 0x09
    5514:	28 87       	std	Y+8, r18	; 0x08
    5516:	89 01       	movw	r16, r18
    5518:	07 54       	subi	r16, 0x47	; 71
    551a:	1a 4f       	sbci	r17, 0xFA	; 250
    551c:	d8 01       	movw	r26, r16
    551e:	8c 91       	ld	r24, X
    5520:	88 23       	and	r24, r24
    5522:	b9 f1       	breq	.+110    	; 0x5592 <MB_S_Timer_ISR+0xba>
    5524:	82 30       	cpi	r24, 0x02	; 2
    5526:	c9 f0       	breq	.+50     	; 0x555a <MB_S_Timer_ISR+0x82>
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
		MB_S_CtrlProc(MB_N);
		break;
	}
}
    5528:	29 96       	adiw	r28, 0x09	; 9
    552a:	0f b6       	in	r0, 0x3f	; 63
    552c:	f8 94       	cli
    552e:	de bf       	out	0x3e, r29	; 62
    5530:	0f be       	out	0x3f, r0	; 63
    5532:	cd bf       	out	0x3d, r28	; 61
    5534:	cf 91       	pop	r28
    5536:	df 91       	pop	r29
    5538:	1f 91       	pop	r17
    553a:	0f 91       	pop	r16
    553c:	ff 90       	pop	r15
    553e:	ef 90       	pop	r14
    5540:	df 90       	pop	r13
    5542:	cf 90       	pop	r12
    5544:	bf 90       	pop	r11
    5546:	af 90       	pop	r10
    5548:	9f 90       	pop	r9
    554a:	8f 90       	pop	r8
    554c:	7f 90       	pop	r7
    554e:	6f 90       	pop	r6
    5550:	5f 90       	pop	r5
    5552:	4f 90       	pop	r4
    5554:	3f 90       	pop	r3
    5556:	2f 90       	pop	r2
    5558:	08 95       	ret
	switch (MB_State[MB_N]) {
	case MB_Initi:
		MB_State[MB_N] = MB_Idle;
		break;
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
    555a:	84 e0       	ldi	r24, 0x04	; 4
    555c:	d8 01       	movw	r26, r16
    555e:	8c 93       	st	X, r24

// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
MB_S_CtrlProc(uint8_t MB_N)
{
	if (CommErr(MB_N)) {
    5560:	8d 2d       	mov	r24, r13
    5562:	0e 94 98 29 	call	0x5330	; 0x5330 <CommErr>
    5566:	88 23       	and	r24, r24
    5568:	a1 f4       	brne	.+40     	; 0x5592 <MB_S_Timer_ISR+0xba>
		MB_State[MB_N] = MB_Idle;
		return;
	}
	if (MB_Frame[MB_N][0]!=0 && MB_Frame[MB_N][0]!=MB_NativeAddr[MB_N]) {
    556a:	28 85       	ldd	r18, Y+8	; 0x08
    556c:	39 85       	ldd	r19, Y+9	; 0x09
    556e:	f2 2e       	mov	r15, r18
    5570:	ee 24       	eor	r14, r14
    5572:	f7 01       	movw	r30, r14
    5574:	e7 5e       	subi	r30, 0xE7	; 231
    5576:	f4 4f       	sbci	r31, 0xF4	; 244
    5578:	90 81       	ld	r25, Z
    557a:	99 23       	and	r25, r25
    557c:	71 f0       	breq	.+28     	; 0x559a <MB_S_Timer_ISR+0xc2>
    557e:	f9 01       	movw	r30, r18
    5580:	e9 52       	subi	r30, 0x29	; 41
    5582:	fa 4f       	sbci	r31, 0xFA	; 250
    5584:	80 81       	ld	r24, Z
    5586:	98 17       	cp	r25, r24
    5588:	41 f0       	breq	.+16     	; 0x559a <MB_S_Timer_ISR+0xc2>
		MB_State[MB_N] = MB_Idle;
    558a:	81 e0       	ldi	r24, 0x01	; 1
    558c:	d8 01       	movw	r26, r16
    558e:	8c 93       	st	X, r24
    5590:	cb cf       	rjmp	.-106    	; 0x5528 <MB_S_Timer_ISR+0x50>
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
MB_S_CtrlProc(uint8_t MB_N)
{
	if (CommErr(MB_N)) {
		MB_State[MB_N] = MB_Idle;
    5592:	81 e0       	ldi	r24, 0x01	; 1
    5594:	f8 01       	movw	r30, r16
    5596:	80 83       	st	Z, r24
    5598:	c7 cf       	rjmp	.-114    	; 0x5528 <MB_S_Timer_ISR+0x50>
    559a:	28 84       	ldd	r2, Y+8	; 0x08
    559c:	39 84       	ldd	r3, Y+9	; 0x09
    559e:	22 0c       	add	r2, r2
    55a0:	33 1c       	adc	r3, r3
    55a2:	22 0c       	add	r2, r2
    55a4:	33 1c       	adc	r3, r3
    55a6:	51 01       	movw	r10, r2
    55a8:	aa 0c       	add	r10, r10
    55aa:	bb 1c       	adc	r11, r11
    55ac:	aa 0c       	add	r10, r10
    55ae:	bb 1c       	adc	r11, r11
    55b0:	a2 0c       	add	r10, r2
    55b2:	b3 1c       	adc	r11, r3
    55b4:	e0 ef       	ldi	r30, 0xF0	; 240
    55b6:	fb e2       	ldi	r31, 0x2B	; 43
    55b8:	ae 0e       	add	r10, r30
    55ba:	bf 1e       	adc	r11, r31
    55bc:	f5 01       	movw	r30, r10
    55be:	25 91       	lpm	r18, Z+
    55c0:	34 91       	lpm	r19, Z+
	}
	if (MB_Frame[MB_N][0]!=0 && MB_Frame[MB_N][0]!=MB_NativeAddr[MB_N]) {
		MB_State[MB_N] = MB_Idle;
		return;
	}
	USART_Func(MB_N, LED);
    55c2:	f9 01       	movw	r30, r18
    55c4:	19 95       	eicall
	MB_CPT[MB_N][3]++;
    55c6:	68 84       	ldd	r6, Y+8	; 0x08
    55c8:	79 84       	ldd	r7, Y+9	; 0x09
    55ca:	62 94       	swap	r6
    55cc:	72 94       	swap	r7
    55ce:	b0 ef       	ldi	r27, 0xF0	; 240
    55d0:	7b 22       	and	r7, r27
    55d2:	76 24       	eor	r7, r6
    55d4:	6b 22       	and	r6, r27
    55d6:	76 24       	eor	r7, r6
    55d8:	f3 01       	movw	r30, r6
    55da:	ec 51       	subi	r30, 0x1C	; 28
    55dc:	f7 4f       	sbci	r31, 0xF7	; 247
    55de:	86 81       	ldd	r24, Z+6	; 0x06
    55e0:	97 81       	ldd	r25, Z+7	; 0x07
    55e2:	01 96       	adiw	r24, 0x01	; 1
    55e4:	97 83       	std	Z+7, r25	; 0x07
    55e6:	86 83       	std	Z+6, r24	; 0x06

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
MB_FrameReg(uint8_t MB_N, uint8_t i)
{
	return MB_Frame[MB_N][i]<<8 | MB_Frame[MB_N][i+1];
    55e8:	68 85       	ldd	r22, Y+8	; 0x08
    55ea:	79 85       	ldd	r23, Y+9	; 0x09
    55ec:	76 95       	lsr	r23
    55ee:	76 2f       	mov	r23, r22
    55f0:	66 27       	eor	r22, r22
    55f2:	77 95       	ror	r23
    55f4:	67 95       	ror	r22
    55f6:	db 01       	movw	r26, r22
    55f8:	aa 0f       	add	r26, r26
    55fa:	bb 1f       	adc	r27, r27
    55fc:	a5 5e       	subi	r26, 0xE5	; 229
    55fe:	b4 4f       	sbci	r27, 0xF4	; 244
    5600:	9c 91       	ld	r25, X
    5602:	80 e0       	ldi	r24, 0x00	; 0
    5604:	a7 01       	movw	r20, r14
    5606:	47 5e       	subi	r20, 0xE7	; 231
    5608:	54 4f       	sbci	r21, 0xF4	; 244
    560a:	fa 01       	movw	r30, r20
    560c:	23 81       	ldd	r18, Z+3	; 0x03
    560e:	82 2e       	mov	r8, r18
    5610:	99 24       	eor	r9, r9
    5612:	88 2a       	or	r8, r24
    5614:	99 2a       	or	r9, r25
inline static uint8_t
Process(uint8_t MB_N)
{
	uint8_t Err;
	uint16_t StartAddr = MB_FrameReg(MB_N, 2);
	switch (MB_Frame[MB_N][1]) {
    5616:	31 81       	ldd	r19, Z+1	; 0x01
    5618:	35 30       	cpi	r19, 0x05	; 5
    561a:	08 f0       	brcs	.+2      	; 0x561e <MB_S_Timer_ISR+0x146>
    561c:	52 c0       	rjmp	.+164    	; 0x56c2 <MB_S_Timer_ISR+0x1ea>
    561e:	33 30       	cpi	r19, 0x03	; 3
    5620:	08 f4       	brcc	.+2      	; 0x5624 <MB_S_Timer_ISR+0x14c>
    5622:	72 c0       	rjmp	.+228    	; 0x5708 <MB_S_Timer_ISR+0x230>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_ReadReg(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame[MB_N][0]==0)
    5624:	fa 01       	movw	r30, r20
    5626:	80 81       	ld	r24, Z
    5628:	88 23       	and	r24, r24
    562a:	09 f4       	brne	.+2      	; 0x562e <MB_S_Timer_ISR+0x156>
    562c:	5c c0       	rjmp	.+184    	; 0x56e6 <MB_S_Timer_ISR+0x20e>
		return 0xFF;
	if (MB_Frame_Sz[MB_N]!=8)
    562e:	2b ef       	ldi	r18, 0xFB	; 251
    5630:	42 2e       	mov	r4, r18
    5632:	26 e0       	ldi	r18, 0x06	; 6
    5634:	52 2e       	mov	r5, r18
    5636:	88 85       	ldd	r24, Y+8	; 0x08
    5638:	99 85       	ldd	r25, Y+9	; 0x09
    563a:	48 0e       	add	r4, r24
    563c:	59 1e       	adc	r5, r25
    563e:	f2 01       	movw	r30, r4
    5640:	80 81       	ld	r24, Z
    5642:	88 30       	cpi	r24, 0x08	; 8
    5644:	09 f4       	brne	.+2      	; 0x5648 <MB_S_Timer_ISR+0x170>
    5646:	27 c2       	rjmp	.+1102   	; 0x5a96 <MB_S_Timer_ISR+0x5be>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_PresetSingle(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame_Sz[MB_N]!=8)
		return MB_Frame[MB_N][2]=IllegData;
    5648:	83 e0       	ldi	r24, 0x03	; 3
    564a:	8c 93       	st	X, r24
    564c:	93 e0       	ldi	r25, 0x03	; 3
		break;
	default:
		Err = MB_Frame[MB_N][2] = IllegFunc;
		break;
	}
	if (MB_Frame[MB_N][0]) {
    564e:	f7 01       	movw	r30, r14
    5650:	e7 5e       	subi	r30, 0xE7	; 231
    5652:	f4 4f       	sbci	r31, 0xF4	; 244
    5654:	80 81       	ld	r24, Z
    5656:	88 23       	and	r24, r24
    5658:	81 f0       	breq	.+32     	; 0x567a <MB_S_Timer_ISR+0x1a2>
		if (Err) {
    565a:	99 23       	and	r25, r25
    565c:	49 f0       	breq	.+18     	; 0x5670 <MB_S_Timer_ISR+0x198>
			MB_Frame[MB_N][1] |=(1<<7);
    565e:	81 81       	ldd	r24, Z+1	; 0x01
    5660:	80 68       	ori	r24, 0x80	; 128
    5662:	81 83       	std	Z+1, r24	; 0x01
			MB_Frame_Sz[MB_N] = 5;
    5664:	e8 85       	ldd	r30, Y+8	; 0x08
    5666:	f9 85       	ldd	r31, Y+9	; 0x09
    5668:	e5 50       	subi	r30, 0x05	; 5
    566a:	f9 4f       	sbci	r31, 0xF9	; 249
    566c:	85 e0       	ldi	r24, 0x05	; 5
    566e:	80 83       	st	Z, r24
		}
		SetCRC_MB(MB_N);
    5670:	8d 2d       	mov	r24, r13
    5672:	9d 83       	std	Y+5, r25	; 0x05
    5674:	0e 94 13 2a 	call	0x5426	; 0x5426 <SetCRC_MB>
    5678:	9d 81       	ldd	r25, Y+5	; 0x05
		MB_State[MB_N] = MB_Idle;
		return;
	}
	USART_Func(MB_N, LED);
	MB_CPT[MB_N][3]++;
	if (Process(MB_N))
    567a:	99 23       	and	r25, r25
    567c:	a1 f5       	brne	.+104    	; 0x56e6 <MB_S_Timer_ISR+0x20e>
		MB_CPT[MB_N][2]++;
	if (MB_Frame[MB_N][0])
    567e:	29 e1       	ldi	r18, 0x19	; 25
    5680:	3b e0       	ldi	r19, 0x0B	; 11
    5682:	e2 0e       	add	r14, r18
    5684:	f3 1e       	adc	r15, r19
    5686:	d7 01       	movw	r26, r14
    5688:	8c 91       	ld	r24, X
    568a:	88 23       	and	r24, r24
    568c:	c9 f5       	brne	.+114    	; 0x5700 <MB_S_Timer_ISR+0x228>
		MB_Transm(MB_N);
	else {
		MB_CPT[MB_N][4]++;
    568e:	e8 85       	ldd	r30, Y+8	; 0x08
    5690:	f9 85       	ldd	r31, Y+9	; 0x09
    5692:	ee 0f       	add	r30, r30
    5694:	ff 1f       	adc	r31, r31
    5696:	ee 0f       	add	r30, r30
    5698:	ff 1f       	adc	r31, r31
    569a:	ee 0f       	add	r30, r30
    569c:	ff 1f       	adc	r31, r31
    569e:	ee 0f       	add	r30, r30
    56a0:	ff 1f       	adc	r31, r31
    56a2:	e4 51       	subi	r30, 0x14	; 20
    56a4:	f7 4f       	sbci	r31, 0xF7	; 247
    56a6:	80 81       	ld	r24, Z
    56a8:	91 81       	ldd	r25, Z+1	; 0x01
    56aa:	01 96       	adiw	r24, 0x01	; 1
    56ac:	91 83       	std	Z+1, r25	; 0x01
    56ae:	80 83       	st	Z, r24
		MB_State[MB_N] = MB_Idle;
    56b0:	81 e0       	ldi	r24, 0x01	; 1
    56b2:	f8 01       	movw	r30, r16
    56b4:	80 83       	st	Z, r24
    56b6:	f5 01       	movw	r30, r10
    56b8:	85 91       	lpm	r24, Z+
    56ba:	94 91       	lpm	r25, Z+
		USART_Func(MB_N, LED);
    56bc:	fc 01       	movw	r30, r24
    56be:	19 95       	eicall
    56c0:	33 cf       	rjmp	.-410    	; 0x5528 <MB_S_Timer_ISR+0x50>
inline static uint8_t
Process(uint8_t MB_N)
{
	uint8_t Err;
	uint16_t StartAddr = MB_FrameReg(MB_N, 2);
	switch (MB_Frame[MB_N][1]) {
    56c2:	3f 30       	cpi	r19, 0x0F	; 15
    56c4:	09 f4       	brne	.+2      	; 0x56c8 <MB_S_Timer_ISR+0x1f0>
    56c6:	1e c1       	rjmp	.+572    	; 0x5904 <MB_S_Timer_ISR+0x42c>
    56c8:	30 31       	cpi	r19, 0x10	; 16
    56ca:	09 f4       	brne	.+2      	; 0x56ce <MB_S_Timer_ISR+0x1f6>
    56cc:	fc c0       	rjmp	.+504    	; 0x58c6 <MB_S_Timer_ISR+0x3ee>
    56ce:	36 30       	cpi	r19, 0x06	; 6
    56d0:	09 f4       	brne	.+2      	; 0x56d4 <MB_S_Timer_ISR+0x1fc>
    56d2:	bd c0       	rjmp	.+378    	; 0x584e <MB_S_Timer_ISR+0x376>
		break;
	case 0x10:
		Err = MB_S_Preset(MB_N, StartAddr);
		break;
	default:
		Err = MB_Frame[MB_N][2] = IllegFunc;
    56d4:	66 0f       	add	r22, r22
    56d6:	77 1f       	adc	r23, r23
    56d8:	65 5e       	subi	r22, 0xE5	; 229
    56da:	74 4f       	sbci	r23, 0xF4	; 244
    56dc:	81 e0       	ldi	r24, 0x01	; 1
    56de:	fb 01       	movw	r30, r22
    56e0:	80 83       	st	Z, r24
    56e2:	91 e0       	ldi	r25, 0x01	; 1
    56e4:	b4 cf       	rjmp	.-152    	; 0x564e <MB_S_Timer_ISR+0x176>
		return;
	}
	USART_Func(MB_N, LED);
	MB_CPT[MB_N][3]++;
	if (Process(MB_N))
		MB_CPT[MB_N][2]++;
    56e6:	f1 01       	movw	r30, r2
    56e8:	ee 0f       	add	r30, r30
    56ea:	ff 1f       	adc	r31, r31
    56ec:	ee 0f       	add	r30, r30
    56ee:	ff 1f       	adc	r31, r31
    56f0:	e8 51       	subi	r30, 0x18	; 24
    56f2:	f7 4f       	sbci	r31, 0xF7	; 247
    56f4:	80 81       	ld	r24, Z
    56f6:	91 81       	ldd	r25, Z+1	; 0x01
    56f8:	01 96       	adiw	r24, 0x01	; 1
    56fa:	91 83       	std	Z+1, r25	; 0x01
    56fc:	80 83       	st	Z, r24
    56fe:	bf cf       	rjmp	.-130    	; 0x567e <MB_S_Timer_ISR+0x1a6>
	if (MB_Frame[MB_N][0])
		MB_Transm(MB_N);
    5700:	8d 2d       	mov	r24, r13
    5702:	0e 94 b4 28 	call	0x5168	; 0x5168 <MB_Transm>
    5706:	10 cf       	rjmp	.-480    	; 0x5528 <MB_S_Timer_ISR+0x50>
inline static uint8_t
Process(uint8_t MB_N)
{
	uint8_t Err;
	uint16_t StartAddr = MB_FrameReg(MB_N, 2);
	switch (MB_Frame[MB_N][1]) {
    5708:	31 30       	cpi	r19, 0x01	; 1
    570a:	20 f3       	brcs	.-56     	; 0x56d4 <MB_S_Timer_ISR+0x1fc>
*/
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_ReadDiscr(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame[MB_N][0]==0)
    570c:	fa 01       	movw	r30, r20
    570e:	80 81       	ld	r24, Z
    5710:	88 23       	and	r24, r24
    5712:	49 f3       	breq	.-46     	; 0x56e6 <MB_S_Timer_ISR+0x20e>
		return 0xFF;
	if (MB_Frame_Sz[MB_N]!=8)
    5714:	eb ef       	ldi	r30, 0xFB	; 251
    5716:	4e 2e       	mov	r4, r30
    5718:	e6 e0       	ldi	r30, 0x06	; 6
    571a:	5e 2e       	mov	r5, r30
    571c:	88 85       	ldd	r24, Y+8	; 0x08
    571e:	99 85       	ldd	r25, Y+9	; 0x09
    5720:	48 0e       	add	r4, r24
    5722:	59 1e       	adc	r5, r25
    5724:	f2 01       	movw	r30, r4
    5726:	80 81       	ld	r24, Z
    5728:	88 30       	cpi	r24, 0x08	; 8
    572a:	09 f0       	breq	.+2      	; 0x572e <MB_S_Timer_ISR+0x256>
    572c:	8d cf       	rjmp	.-230    	; 0x5648 <MB_S_Timer_ISR+0x170>
    572e:	88 85       	ldd	r24, Y+8	; 0x08
    5730:	99 85       	ldd	r25, Y+9	; 0x09
    5732:	f8 2f       	mov	r31, r24
    5734:	ee 27       	eor	r30, r30
    5736:	e3 5e       	subi	r30, 0xE3	; 227
    5738:	f4 4f       	sbci	r31, 0xF4	; 244
    573a:	90 81       	ld	r25, Z
    573c:	80 e0       	ldi	r24, 0x00	; 0
    573e:	da 01       	movw	r26, r20
    5740:	15 96       	adiw	r26, 0x05	; 5
    5742:	2c 91       	ld	r18, X
    5744:	a2 2f       	mov	r26, r18
    5746:	b0 e0       	ldi	r27, 0x00	; 0
    5748:	a8 2b       	or	r26, r24
    574a:	b9 2b       	or	r27, r25
		return MB_Frame[MB_N][2]=IllegData;
	uint16_t Qt = MB_FrameReg(MB_N, 4);
	if (StartAddr+Qt>(MB_Frame[MB_N][1]==1?prw(&Modbus_Map[MB_N].Coil_Qt):prw(&Modbus_Map[MB_N].Input_Qt)))
    574c:	31 30       	cpi	r19, 0x01	; 1
    574e:	09 f4       	brne	.+2      	; 0x5752 <MB_S_Timer_ISR+0x27a>
    5750:	44 c2       	rjmp	.+1160   	; 0x5bda <MB_S_Timer_ISR+0x702>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    5752:	f3 01       	movw	r30, r6
    5754:	e8 5f       	subi	r30, 0xF8	; 248
    5756:	fc 4f       	sbci	r31, 0xFC	; 252
    5758:	45 91       	lpm	r20, Z+
    575a:	54 91       	lpm	r21, Z+
    575c:	cd 01       	movw	r24, r26
    575e:	88 0d       	add	r24, r8
    5760:	99 1d       	adc	r25, r9
    5762:	48 17       	cp	r20, r24
    5764:	59 07       	cpc	r21, r25
    5766:	08 f4       	brcc	.+2      	; 0x576a <MB_S_Timer_ISR+0x292>
    5768:	8d c1       	rjmp	.+794    	; 0x5a84 <MB_S_Timer_ISR+0x5ac>
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
    576a:	31 30       	cpi	r19, 0x01	; 1
    576c:	09 f4       	brne	.+2      	; 0x5770 <MB_S_Timer_ISR+0x298>
    576e:	4a c2       	rjmp	.+1172   	; 0x5c04 <MB_S_Timer_ISR+0x72c>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5770:	f1 01       	movw	r30, r2
    5772:	ee 0f       	add	r30, r30
    5774:	ff 1f       	adc	r31, r31
    5776:	ee 0f       	add	r30, r30
    5778:	ff 1f       	adc	r31, r31
    577a:	ea 5f       	subi	r30, 0xFA	; 250
    577c:	fc 4f       	sbci	r31, 0xFC	; 252
    577e:	85 91       	lpm	r24, Z+
    5780:	94 91       	lpm	r25, Z+
    5782:	28 2f       	mov	r18, r24
    5784:	89 2f       	mov	r24, r25
    5786:	62 2e       	mov	r6, r18
    5788:	78 2e       	mov	r7, r24
	MB_Frame[MB_N][2] = Qt/8+(Qt%8>0);
    578a:	20 e0       	ldi	r18, 0x00	; 0
    578c:	cd 01       	movw	r24, r26
    578e:	87 70       	andi	r24, 0x07	; 7
    5790:	90 70       	andi	r25, 0x00	; 0
    5792:	89 2b       	or	r24, r25
    5794:	09 f0       	breq	.+2      	; 0x5798 <MB_S_Timer_ISR+0x2c0>
    5796:	21 e0       	ldi	r18, 0x01	; 1
    5798:	cd 01       	movw	r24, r26
    579a:	96 95       	lsr	r25
    579c:	87 95       	ror	r24
    579e:	96 95       	lsr	r25
    57a0:	87 95       	ror	r24
    57a2:	96 95       	lsr	r25
    57a4:	87 95       	ror	r24
    57a6:	82 0f       	add	r24, r18
    57a8:	66 0f       	add	r22, r22
    57aa:	77 1f       	adc	r23, r23
    57ac:	65 5e       	subi	r22, 0xE5	; 229
    57ae:	74 4f       	sbci	r23, 0xF4	; 244
    57b0:	fb 01       	movw	r30, r22
    57b2:	80 83       	st	Z, r24
	MB_Frame_Sz[MB_N] = MB_Frame[MB_N][2]+5;
    57b4:	8b 5f       	subi	r24, 0xFB	; 251
    57b6:	f2 01       	movw	r30, r4
    57b8:	80 83       	st	Z, r24
	for (uint8_t i=0; i<Qt; i++) {
    57ba:	10 97       	sbiw	r26, 0x00	; 0
    57bc:	09 f4       	brne	.+2      	; 0x57c0 <MB_S_Timer_ISR+0x2e8>
    57be:	22 c1       	rjmp	.+580    	; 0x5a04 <MB_S_Timer_ISR+0x52c>
    57c0:	60 e0       	ldi	r22, 0x00	; 0
    57c2:	20 e0       	ldi	r18, 0x00	; 0
    57c4:	30 e0       	ldi	r19, 0x00	; 0
    57c6:	80 e0       	ldi	r24, 0x00	; 0
    57c8:	90 e0       	ldi	r25, 0x00	; 0
		uint16_t j = StartAddr+i;
		uint8_t Byte=3+i/8, Bit=1<<i%8;
    57ca:	e1 e0       	ldi	r30, 0x01	; 1
    57cc:	4e 2e       	mov	r4, r30
    57ce:	51 2c       	mov	r5, r1
    57d0:	10 c0       	rjmp	.+32     	; 0x57f2 <MB_S_Timer_ISR+0x31a>
		if (Discr[j/8] &(1<<j%8))
			MB_Frame[MB_N][Byte] |=Bit;
    57d2:	f7 01       	movw	r30, r14
    57d4:	e4 0f       	add	r30, r20
    57d6:	f1 1d       	adc	r31, r1
    57d8:	e7 5e       	subi	r30, 0xE7	; 231
    57da:	f4 4f       	sbci	r31, 0xF4	; 244
    57dc:	80 81       	ld	r24, Z
    57de:	85 2b       	or	r24, r21
    57e0:	80 83       	st	Z, r24
	if (StartAddr+Qt>(MB_Frame[MB_N][1]==1?prw(&Modbus_Map[MB_N].Coil_Qt):prw(&Modbus_Map[MB_N].Input_Qt)))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
	MB_Frame[MB_N][2] = Qt/8+(Qt%8>0);
	MB_Frame_Sz[MB_N] = MB_Frame[MB_N][2]+5;
	for (uint8_t i=0; i<Qt; i++) {
    57e2:	6f 5f       	subi	r22, 0xFF	; 255
    57e4:	86 2f       	mov	r24, r22
    57e6:	90 e0       	ldi	r25, 0x00	; 0
    57e8:	9c 01       	movw	r18, r24
    57ea:	8a 17       	cp	r24, r26
    57ec:	9b 07       	cpc	r25, r27
    57ee:	08 f0       	brcs	.+2      	; 0x57f2 <MB_S_Timer_ISR+0x31a>
    57f0:	09 c1       	rjmp	.+530    	; 0x5a04 <MB_S_Timer_ISR+0x52c>
		uint16_t j = StartAddr+i;
    57f2:	28 0d       	add	r18, r8
    57f4:	39 1d       	adc	r19, r9
		uint8_t Byte=3+i/8, Bit=1<<i%8;
    57f6:	46 2f       	mov	r20, r22
    57f8:	46 95       	lsr	r20
    57fa:	46 95       	lsr	r20
    57fc:	46 95       	lsr	r20
    57fe:	4d 5f       	subi	r20, 0xFD	; 253
    5800:	87 70       	andi	r24, 0x07	; 7
    5802:	90 70       	andi	r25, 0x00	; 0
    5804:	f2 01       	movw	r30, r4
    5806:	02 c0       	rjmp	.+4      	; 0x580c <MB_S_Timer_ISR+0x334>
    5808:	ee 0f       	add	r30, r30
    580a:	ff 1f       	adc	r31, r31
    580c:	8a 95       	dec	r24
    580e:	e2 f7       	brpl	.-8      	; 0x5808 <MB_S_Timer_ISR+0x330>
    5810:	5e 2f       	mov	r21, r30
		if (Discr[j/8] &(1<<j%8))
    5812:	f9 01       	movw	r30, r18
    5814:	f6 95       	lsr	r31
    5816:	e7 95       	ror	r30
    5818:	f6 95       	lsr	r31
    581a:	e7 95       	ror	r30
    581c:	f6 95       	lsr	r31
    581e:	e7 95       	ror	r30
    5820:	e6 0d       	add	r30, r6
    5822:	f7 1d       	adc	r31, r7
    5824:	80 81       	ld	r24, Z
    5826:	90 e0       	ldi	r25, 0x00	; 0
    5828:	27 70       	andi	r18, 0x07	; 7
    582a:	30 70       	andi	r19, 0x00	; 0
    582c:	02 c0       	rjmp	.+4      	; 0x5832 <MB_S_Timer_ISR+0x35a>
    582e:	95 95       	asr	r25
    5830:	87 95       	ror	r24
    5832:	2a 95       	dec	r18
    5834:	e2 f7       	brpl	.-8      	; 0x582e <MB_S_Timer_ISR+0x356>
    5836:	80 fd       	sbrc	r24, 0
    5838:	cc cf       	rjmp	.-104    	; 0x57d2 <MB_S_Timer_ISR+0x2fa>
			MB_Frame[MB_N][Byte] |=Bit;
		else
			MB_Frame[MB_N][Byte] &=~Bit;
    583a:	f7 01       	movw	r30, r14
    583c:	e4 0f       	add	r30, r20
    583e:	f1 1d       	adc	r31, r1
    5840:	e7 5e       	subi	r30, 0xE7	; 231
    5842:	f4 4f       	sbci	r31, 0xF4	; 244
    5844:	50 95       	com	r21
    5846:	80 81       	ld	r24, Z
    5848:	58 23       	and	r21, r24
    584a:	50 83       	st	Z, r21
    584c:	ca cf       	rjmp	.-108    	; 0x57e2 <MB_S_Timer_ISR+0x30a>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_PresetSingle(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame_Sz[MB_N]!=8)
    584e:	68 85       	ldd	r22, Y+8	; 0x08
    5850:	79 85       	ldd	r23, Y+9	; 0x09
    5852:	65 50       	subi	r22, 0x05	; 5
    5854:	79 4f       	sbci	r23, 0xF9	; 249
    5856:	fb 01       	movw	r30, r22
    5858:	c0 80       	ld	r12, Z
    585a:	f8 e0       	ldi	r31, 0x08	; 8
    585c:	cf 16       	cp	r12, r31
    585e:	09 f0       	breq	.+2      	; 0x5862 <MB_S_Timer_ISR+0x38a>
    5860:	f3 ce       	rjmp	.-538    	; 0x5648 <MB_S_Timer_ISR+0x170>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    5862:	f3 01       	movw	r30, r6
    5864:	e4 5f       	subi	r30, 0xF4	; 244
    5866:	fc 4f       	sbci	r31, 0xFC	; 252
    5868:	25 91       	lpm	r18, Z+
    586a:	34 91       	lpm	r19, Z+
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+1>prw(&Modbus_Map[MB_N].HoldReg_Qt))
    586c:	c4 01       	movw	r24, r8
    586e:	01 96       	adiw	r24, 0x01	; 1
    5870:	28 17       	cp	r18, r24
    5872:	39 07       	cpc	r19, r25
    5874:	08 f4       	brcc	.+2      	; 0x5878 <MB_S_Timer_ISR+0x3a0>
    5876:	02 c1       	rjmp	.+516    	; 0x5a7c <MB_S_Timer_ISR+0x5a4>
		return MB_Frame[MB_N][2]=IllegAddr;
	MB_Frame_Sz[MB_N] = 8;
    5878:	db 01       	movw	r26, r22
    587a:	cc 92       	st	X, r12

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    587c:	e8 85       	ldd	r30, Y+8	; 0x08
    587e:	f9 85       	ldd	r31, Y+9	; 0x09
    5880:	ee 0f       	add	r30, r30
    5882:	ff 1f       	adc	r31, r31
    5884:	ee 0f       	add	r30, r30
    5886:	ff 1f       	adc	r31, r31
    5888:	ee 0f       	add	r30, r30
    588a:	ff 1f       	adc	r31, r31
    588c:	ee 0f       	add	r30, r30
    588e:	ff 1f       	adc	r31, r31
    5890:	e6 5f       	subi	r30, 0xF6	; 246
    5892:	fc 4f       	sbci	r31, 0xFC	; 252
    5894:	85 91       	lpm	r24, Z+
    5896:	94 91       	lpm	r25, Z+
	*((uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+StartAddr) = MB_FrameReg(MB_N, 4);
    5898:	88 0c       	add	r8, r8
    589a:	99 1c       	adc	r9, r9
    589c:	88 0e       	add	r8, r24
    589e:	99 1e       	adc	r9, r25
    58a0:	28 85       	ldd	r18, Y+8	; 0x08
    58a2:	39 85       	ldd	r19, Y+9	; 0x09
    58a4:	f2 2f       	mov	r31, r18
    58a6:	ee 27       	eor	r30, r30
    58a8:	e3 5e       	subi	r30, 0xE3	; 227
    58aa:	f4 4f       	sbci	r31, 0xF4	; 244
    58ac:	90 81       	ld	r25, Z
    58ae:	80 e0       	ldi	r24, 0x00	; 0
    58b0:	da 01       	movw	r26, r20
    58b2:	15 96       	adiw	r26, 0x05	; 5
    58b4:	2c 91       	ld	r18, X
    58b6:	30 e0       	ldi	r19, 0x00	; 0
    58b8:	82 2b       	or	r24, r18
    58ba:	93 2b       	or	r25, r19
    58bc:	f4 01       	movw	r30, r8
    58be:	91 83       	std	Z+1, r25	; 0x01
    58c0:	80 83       	st	Z, r24
    58c2:	90 e0       	ldi	r25, 0x00	; 0
    58c4:	c4 ce       	rjmp	.-632    	; 0x564e <MB_S_Timer_ISR+0x176>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_Preset(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][6]+9 || MB_Frame[MB_N][5]*2!=MB_Frame[MB_N][6])
    58c6:	fa 01       	movw	r30, r20
    58c8:	86 81       	ldd	r24, Z+6	; 0x06
    58ca:	28 2f       	mov	r18, r24
    58cc:	30 e0       	ldi	r19, 0x00	; 0
    58ce:	3f 83       	std	Y+7, r19	; 0x07
    58d0:	2e 83       	std	Y+6, r18	; 0x06
    58d2:	8b ef       	ldi	r24, 0xFB	; 251
    58d4:	48 2e       	mov	r4, r24
    58d6:	86 e0       	ldi	r24, 0x06	; 6
    58d8:	58 2e       	mov	r5, r24
    58da:	88 85       	ldd	r24, Y+8	; 0x08
    58dc:	99 85       	ldd	r25, Y+9	; 0x09
    58de:	48 0e       	add	r4, r24
    58e0:	59 1e       	adc	r5, r25
    58e2:	f2 01       	movw	r30, r4
    58e4:	80 81       	ld	r24, Z
    58e6:	90 e0       	ldi	r25, 0x00	; 0
    58e8:	27 5f       	subi	r18, 0xF7	; 247
    58ea:	3f 4f       	sbci	r19, 0xFF	; 255
    58ec:	82 17       	cp	r24, r18
    58ee:	93 07       	cpc	r25, r19
    58f0:	99 f1       	breq	.+102    	; 0x5958 <MB_S_Timer_ISR+0x480>
		return MB_Frame[MB_N][2]=IllegData;
    58f2:	66 0f       	add	r22, r22
    58f4:	77 1f       	adc	r23, r23
    58f6:	65 5e       	subi	r22, 0xE5	; 229
    58f8:	74 4f       	sbci	r23, 0xF4	; 244
    58fa:	83 e0       	ldi	r24, 0x03	; 3
    58fc:	db 01       	movw	r26, r22
    58fe:	8c 93       	st	X, r24
    5900:	93 e0       	ldi	r25, 0x03	; 3
    5902:	a5 ce       	rjmp	.-694    	; 0x564e <MB_S_Timer_ISR+0x176>
    5904:	28 85       	ldd	r18, Y+8	; 0x08
    5906:	39 85       	ldd	r19, Y+9	; 0x09
    5908:	f2 2f       	mov	r31, r18
    590a:	ee 27       	eor	r30, r30
    590c:	e3 5e       	subi	r30, 0xE3	; 227
    590e:	f4 4f       	sbci	r31, 0xF4	; 244
    5910:	e0 81       	ld	r30, Z
    5912:	da 01       	movw	r26, r20
    5914:	15 96       	adiw	r26, 0x05	; 5
    5916:	fc 91       	ld	r31, X
    5918:	15 97       	sbiw	r26, 0x05	; 5
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_Force(uint8_t MB_N, uint16_t StartAddr)
{
	uint16_t Qt = MB_FrameReg(MB_N, 4);
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][6]+9 || Qt/8+(Qt%8>0)!=MB_Frame[MB_N][6])
    591a:	16 96       	adiw	r26, 0x06	; 6
    591c:	2c 91       	ld	r18, X
    591e:	ab ef       	ldi	r26, 0xFB	; 251
    5920:	4a 2e       	mov	r4, r26
    5922:	a6 e0       	ldi	r26, 0x06	; 6
    5924:	5a 2e       	mov	r5, r26
    5926:	88 85       	ldd	r24, Y+8	; 0x08
    5928:	99 85       	ldd	r25, Y+9	; 0x09
    592a:	48 0e       	add	r4, r24
    592c:	59 1e       	adc	r5, r25
    592e:	d2 01       	movw	r26, r4
    5930:	8c 91       	ld	r24, X
    5932:	90 e0       	ldi	r25, 0x00	; 0
    5934:	42 2f       	mov	r20, r18
    5936:	50 e0       	ldi	r21, 0x00	; 0
    5938:	9a 01       	movw	r18, r20
    593a:	27 5f       	subi	r18, 0xF7	; 247
    593c:	3f 4f       	sbci	r19, 0xFF	; 255
    593e:	82 17       	cp	r24, r18
    5940:	93 07       	cpc	r25, r19
    5942:	09 f4       	brne	.+2      	; 0x5946 <MB_S_Timer_ISR+0x46e>
    5944:	61 c0       	rjmp	.+194    	; 0x5a08 <MB_S_Timer_ISR+0x530>
		return MB_Frame[MB_N][2]=IllegData;
    5946:	66 0f       	add	r22, r22
    5948:	77 1f       	adc	r23, r23
    594a:	65 5e       	subi	r22, 0xE5	; 229
    594c:	74 4f       	sbci	r23, 0xF4	; 244
    594e:	83 e0       	ldi	r24, 0x03	; 3
    5950:	fb 01       	movw	r30, r22
    5952:	80 83       	st	Z, r24
    5954:	93 e0       	ldi	r25, 0x03	; 3
    5956:	7b ce       	rjmp	.-778    	; 0x564e <MB_S_Timer_ISR+0x176>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_Preset(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][6]+9 || MB_Frame[MB_N][5]*2!=MB_Frame[MB_N][6])
    5958:	9a 01       	movw	r18, r20
    595a:	2b 5f       	subi	r18, 0xFB	; 251
    595c:	3f 4f       	sbci	r19, 0xFF	; 255
    595e:	3c 83       	std	Y+4, r19	; 0x04
    5960:	2b 83       	std	Y+3, r18	; 0x03
    5962:	fa 01       	movw	r30, r20
    5964:	c5 80       	ldd	r12, Z+5	; 0x05
    5966:	2c 2d       	mov	r18, r12
    5968:	30 e0       	ldi	r19, 0x00	; 0
    596a:	c9 01       	movw	r24, r18
    596c:	88 0f       	add	r24, r24
    596e:	99 1f       	adc	r25, r25
    5970:	ee 81       	ldd	r30, Y+6	; 0x06
    5972:	ff 81       	ldd	r31, Y+7	; 0x07
    5974:	e8 17       	cp	r30, r24
    5976:	f9 07       	cpc	r31, r25
    5978:	09 f0       	breq	.+2      	; 0x597c <MB_S_Timer_ISR+0x4a4>
    597a:	bb cf       	rjmp	.-138    	; 0x58f2 <MB_S_Timer_ISR+0x41a>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    597c:	f3 01       	movw	r30, r6
    597e:	e4 5f       	subi	r30, 0xF4	; 244
    5980:	fc 4f       	sbci	r31, 0xFC	; 252
    5982:	85 91       	lpm	r24, Z+
    5984:	94 91       	lpm	r25, Z+
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+MB_Frame[MB_N][5]>prw(&Modbus_Map[MB_N].HoldReg_Qt))
    5986:	28 0d       	add	r18, r8
    5988:	39 1d       	adc	r19, r9
    598a:	82 17       	cp	r24, r18
    598c:	93 07       	cpc	r25, r19
    598e:	08 f4       	brcc	.+2      	; 0x5992 <MB_S_Timer_ISR+0x4ba>
    5990:	75 c0       	rjmp	.+234    	; 0x5a7c <MB_S_Timer_ISR+0x5a4>
		return MB_Frame[MB_N][2]=IllegAddr;
	MB_Frame_Sz[MB_N] = 8;
    5992:	88 e0       	ldi	r24, 0x08	; 8
    5994:	f2 01       	movw	r30, r4
    5996:	80 83       	st	Z, r24

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5998:	e8 85       	ldd	r30, Y+8	; 0x08
    599a:	f9 85       	ldd	r31, Y+9	; 0x09
    599c:	ee 0f       	add	r30, r30
    599e:	ff 1f       	adc	r31, r31
    59a0:	ee 0f       	add	r30, r30
    59a2:	ff 1f       	adc	r31, r31
    59a4:	ee 0f       	add	r30, r30
    59a6:	ff 1f       	adc	r31, r31
    59a8:	ee 0f       	add	r30, r30
    59aa:	ff 1f       	adc	r31, r31
    59ac:	e6 5f       	subi	r30, 0xF6	; 246
    59ae:	fc 4f       	sbci	r31, 0xFC	; 252
    59b0:	45 90       	lpm	r4, Z+
    59b2:	54 90       	lpm	r5, Z+
	uint16_t *HoldReg = prp(&Modbus_Map[MB_N].HoldReg);
	for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    59b4:	cc 20       	and	r12, r12
    59b6:	31 f1       	breq	.+76     	; 0x5a04 <MB_S_Timer_ISR+0x52c>
    59b8:	60 e0       	ldi	r22, 0x00	; 0
    59ba:	6b 80       	ldd	r6, Y+3	; 0x03
    59bc:	7c 80       	ldd	r7, Y+4	; 0x04
    59be:	a6 2f       	mov	r26, r22
    59c0:	b0 e0       	ldi	r27, 0x00	; 0
    59c2:	cd 01       	movw	r24, r26
    59c4:	88 0f       	add	r24, r24
    59c6:	99 1f       	adc	r25, r25
    59c8:	89 5f       	subi	r24, 0xF9	; 249
    59ca:	28 2f       	mov	r18, r24
    59cc:	30 e0       	ldi	r19, 0x00	; 0
		uint8_t j = i*2;
		HoldReg[StartAddr+i] = MB_FrameReg(MB_N, 7+j);
    59ce:	a8 0d       	add	r26, r8
    59d0:	b9 1d       	adc	r27, r9
    59d2:	aa 0f       	add	r26, r26
    59d4:	bb 1f       	adc	r27, r27
    59d6:	a4 0d       	add	r26, r4
    59d8:	b5 1d       	adc	r27, r5
    59da:	fa 01       	movw	r30, r20
    59dc:	e2 0f       	add	r30, r18
    59de:	f3 1f       	adc	r31, r19
    59e0:	81 81       	ldd	r24, Z+1	; 0x01
    59e2:	90 e0       	ldi	r25, 0x00	; 0
    59e4:	2e 0d       	add	r18, r14
    59e6:	3f 1d       	adc	r19, r15
    59e8:	27 5e       	subi	r18, 0xE7	; 231
    59ea:	34 4f       	sbci	r19, 0xF4	; 244
    59ec:	f9 01       	movw	r30, r18
    59ee:	30 81       	ld	r19, Z
    59f0:	20 e0       	ldi	r18, 0x00	; 0
    59f2:	82 2b       	or	r24, r18
    59f4:	93 2b       	or	r25, r19
    59f6:	8d 93       	st	X+, r24
    59f8:	9c 93       	st	X, r25
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+MB_Frame[MB_N][5]>prw(&Modbus_Map[MB_N].HoldReg_Qt))
		return MB_Frame[MB_N][2]=IllegAddr;
	MB_Frame_Sz[MB_N] = 8;
	uint16_t *HoldReg = prp(&Modbus_Map[MB_N].HoldReg);
	for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    59fa:	6f 5f       	subi	r22, 0xFF	; 255
    59fc:	d3 01       	movw	r26, r6
    59fe:	8c 91       	ld	r24, X
    5a00:	68 17       	cp	r22, r24
    5a02:	e8 f2       	brcs	.-70     	; 0x59be <MB_S_Timer_ISR+0x4e6>
		break;
	case 0x10:
		Err = MB_S_Preset(MB_N, StartAddr);
		break;
	default:
		Err = MB_Frame[MB_N][2] = IllegFunc;
    5a04:	90 e0       	ldi	r25, 0x00	; 0
    5a06:	23 ce       	rjmp	.-954    	; 0x564e <MB_S_Timer_ISR+0x176>
    5a08:	9e 2f       	mov	r25, r30
    5a0a:	80 e0       	ldi	r24, 0x00	; 0
    5a0c:	af 2f       	mov	r26, r31
    5a0e:	b0 e0       	ldi	r27, 0x00	; 0
    5a10:	a8 2b       	or	r26, r24
    5a12:	b9 2b       	or	r27, r25
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_Force(uint8_t MB_N, uint16_t StartAddr)
{
	uint16_t Qt = MB_FrameReg(MB_N, 4);
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][6]+9 || Qt/8+(Qt%8>0)!=MB_Frame[MB_N][6])
    5a14:	20 e0       	ldi	r18, 0x00	; 0
    5a16:	30 e0       	ldi	r19, 0x00	; 0
    5a18:	cd 01       	movw	r24, r26
    5a1a:	87 70       	andi	r24, 0x07	; 7
    5a1c:	90 70       	andi	r25, 0x00	; 0
    5a1e:	89 2b       	or	r24, r25
    5a20:	11 f0       	breq	.+4      	; 0x5a26 <MB_S_Timer_ISR+0x54e>
    5a22:	21 e0       	ldi	r18, 0x01	; 1
    5a24:	30 e0       	ldi	r19, 0x00	; 0
    5a26:	cd 01       	movw	r24, r26
    5a28:	96 95       	lsr	r25
    5a2a:	87 95       	ror	r24
    5a2c:	96 95       	lsr	r25
    5a2e:	87 95       	ror	r24
    5a30:	96 95       	lsr	r25
    5a32:	87 95       	ror	r24
    5a34:	28 0f       	add	r18, r24
    5a36:	39 1f       	adc	r19, r25
    5a38:	24 17       	cp	r18, r20
    5a3a:	35 07       	cpc	r19, r21
    5a3c:	09 f0       	breq	.+2      	; 0x5a40 <MB_S_Timer_ISR+0x568>
    5a3e:	83 cf       	rjmp	.-250    	; 0x5946 <MB_S_Timer_ISR+0x46e>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    5a40:	e8 85       	ldd	r30, Y+8	; 0x08
    5a42:	f9 85       	ldd	r31, Y+9	; 0x09
    5a44:	ee 0f       	add	r30, r30
    5a46:	ff 1f       	adc	r31, r31
    5a48:	ee 0f       	add	r30, r30
    5a4a:	ff 1f       	adc	r31, r31
    5a4c:	ee 0f       	add	r30, r30
    5a4e:	ff 1f       	adc	r31, r31
    5a50:	ee 0f       	add	r30, r30
    5a52:	ff 1f       	adc	r31, r31
    5a54:	ec 5f       	subi	r30, 0xFC	; 252
    5a56:	fc 4f       	sbci	r31, 0xFC	; 252
    5a58:	25 91       	lpm	r18, Z+
    5a5a:	34 91       	lpm	r19, Z+
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+Qt > prw(&Modbus_Map[MB_N].Coil_Qt))
    5a5c:	cd 01       	movw	r24, r26
    5a5e:	88 0d       	add	r24, r8
    5a60:	99 1d       	adc	r25, r9
    5a62:	28 17       	cp	r18, r24
    5a64:	39 07       	cpc	r19, r25
    5a66:	08 f0       	brcs	.+2      	; 0x5a6a <MB_S_Timer_ISR+0x592>
    5a68:	5d c0       	rjmp	.+186    	; 0x5b24 <MB_S_Timer_ISR+0x64c>
		return MB_Frame[MB_N][2]=IllegAddr;
    5a6a:	66 0f       	add	r22, r22
    5a6c:	77 1f       	adc	r23, r23
    5a6e:	65 5e       	subi	r22, 0xE5	; 229
    5a70:	74 4f       	sbci	r23, 0xF4	; 244
    5a72:	82 e0       	ldi	r24, 0x02	; 2
    5a74:	db 01       	movw	r26, r22
    5a76:	8c 93       	st	X, r24
    5a78:	92 e0       	ldi	r25, 0x02	; 2
    5a7a:	e9 cd       	rjmp	.-1070   	; 0x564e <MB_S_Timer_ISR+0x176>
MB_S_Preset(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][6]+9 || MB_Frame[MB_N][5]*2!=MB_Frame[MB_N][6])
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+MB_Frame[MB_N][5]>prw(&Modbus_Map[MB_N].HoldReg_Qt))
		return MB_Frame[MB_N][2]=IllegAddr;
    5a7c:	82 e0       	ldi	r24, 0x02	; 2
    5a7e:	8c 93       	st	X, r24
    5a80:	92 e0       	ldi	r25, 0x02	; 2
    5a82:	e5 cd       	rjmp	.-1078   	; 0x564e <MB_S_Timer_ISR+0x176>
	if (MB_Frame[MB_N][0]==0)
		return 0xFF;
	if (MB_Frame_Sz[MB_N]!=8)
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+MB_Frame[MB_N][5]>(MB_Frame[MB_N][1]==3?prw(&Modbus_Map[MB_N].HoldReg_Qt):prw(&Modbus_Map[MB_N].InReg_Qt)))
		return MB_Frame[MB_N][2]=IllegAddr;
    5a84:	66 0f       	add	r22, r22
    5a86:	77 1f       	adc	r23, r23
    5a88:	65 5e       	subi	r22, 0xE5	; 229
    5a8a:	74 4f       	sbci	r23, 0xF4	; 244
    5a8c:	82 e0       	ldi	r24, 0x02	; 2
    5a8e:	fb 01       	movw	r30, r22
    5a90:	80 83       	st	Z, r24
    5a92:	92 e0       	ldi	r25, 0x02	; 2
    5a94:	dc cd       	rjmp	.-1096   	; 0x564e <MB_S_Timer_ISR+0x176>
{
	if (MB_Frame[MB_N][0]==0)
		return 0xFF;
	if (MB_Frame_Sz[MB_N]!=8)
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+MB_Frame[MB_N][5]>(MB_Frame[MB_N][1]==3?prw(&Modbus_Map[MB_N].HoldReg_Qt):prw(&Modbus_Map[MB_N].InReg_Qt)))
    5a96:	da 01       	movw	r26, r20
    5a98:	15 96       	adiw	r26, 0x05	; 5
    5a9a:	8c 91       	ld	r24, X
    5a9c:	33 30       	cpi	r19, 0x03	; 3
    5a9e:	09 f4       	brne	.+2      	; 0x5aa2 <MB_S_Timer_ISR+0x5ca>
    5aa0:	ab c0       	rjmp	.+342    	; 0x5bf8 <MB_S_Timer_ISR+0x720>
    5aa2:	f3 01       	movw	r30, r6
    5aa4:	e0 5f       	subi	r30, 0xF0	; 240
    5aa6:	fc 4f       	sbci	r31, 0xFC	; 252
    5aa8:	45 91       	lpm	r20, Z+
    5aaa:	54 91       	lpm	r21, Z+
    5aac:	a8 2f       	mov	r26, r24
    5aae:	b0 e0       	ldi	r27, 0x00	; 0
    5ab0:	c4 01       	movw	r24, r8
    5ab2:	8a 0f       	add	r24, r26
    5ab4:	9b 1f       	adc	r25, r27
    5ab6:	48 17       	cp	r20, r24
    5ab8:	59 07       	cpc	r21, r25
    5aba:	20 f3       	brcs	.-56     	; 0x5a84 <MB_S_Timer_ISR+0x5ac>
		return MB_Frame[MB_N][2]=IllegAddr;
	uint16_t *Reg = (uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg)) + StartAddr;
    5abc:	33 30       	cpi	r19, 0x03	; 3
    5abe:	09 f4       	brne	.+2      	; 0x5ac2 <MB_S_Timer_ISR+0x5ea>
    5ac0:	a9 c0       	rjmp	.+338    	; 0x5c14 <MB_S_Timer_ISR+0x73c>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5ac2:	f3 01       	movw	r30, r6
    5ac4:	e2 5f       	subi	r30, 0xF2	; 242
    5ac6:	fc 4f       	sbci	r31, 0xFC	; 252
    5ac8:	85 91       	lpm	r24, Z+
    5aca:	94 91       	lpm	r25, Z+
    5acc:	94 01       	movw	r18, r8
    5ace:	22 0f       	add	r18, r18
    5ad0:	33 1f       	adc	r19, r19
    5ad2:	28 0f       	add	r18, r24
    5ad4:	39 1f       	adc	r19, r25
	MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][2] = MB_Frame[MB_N][5]*2) + 5;
    5ad6:	cd 01       	movw	r24, r26
    5ad8:	88 0f       	add	r24, r24
    5ada:	99 1f       	adc	r25, r25
    5adc:	66 0f       	add	r22, r22
    5ade:	77 1f       	adc	r23, r23
    5ae0:	65 5e       	subi	r22, 0xE5	; 229
    5ae2:	74 4f       	sbci	r23, 0xF4	; 244
    5ae4:	db 01       	movw	r26, r22
    5ae6:	8c 93       	st	X, r24
    5ae8:	8b 5f       	subi	r24, 0xFB	; 251
    5aea:	f2 01       	movw	r30, r4
    5aec:	80 83       	st	Z, r24
	uint8_t Qt = MB_Frame[MB_N][5];
    5aee:	f7 01       	movw	r30, r14
    5af0:	e7 5e       	subi	r30, 0xE7	; 231
    5af2:	f4 4f       	sbci	r31, 0xF4	; 244
    5af4:	45 81       	ldd	r20, Z+5	; 0x05
	for (uint8_t i=0; i<Qt; i++) {
    5af6:	44 23       	and	r20, r20
    5af8:	09 f4       	brne	.+2      	; 0x5afc <MB_S_Timer_ISR+0x624>
    5afa:	84 cf       	rjmp	.-248    	; 0x5a04 <MB_S_Timer_ISR+0x52c>
    5afc:	d9 01       	movw	r26, r18
    5afe:	90 e0       	ldi	r25, 0x00	; 0
		uint8_t j = i*2;
		MB_Frame[MB_N][3+j] = Reg[i]>>8;
    5b00:	9f 01       	movw	r18, r30
    5b02:	89 2f       	mov	r24, r25
    5b04:	88 0f       	add	r24, r24
    5b06:	f9 01       	movw	r30, r18
    5b08:	e8 0f       	add	r30, r24
    5b0a:	f1 1d       	adc	r31, r1
    5b0c:	11 96       	adiw	r26, 0x01	; 1
    5b0e:	8c 91       	ld	r24, X
    5b10:	11 97       	sbiw	r26, 0x01	; 1
    5b12:	83 83       	std	Z+3, r24	; 0x03
		MB_Frame[MB_N][4+j] = Reg[i];
    5b14:	8c 91       	ld	r24, X
    5b16:	84 83       	std	Z+4, r24	; 0x04
	if (StartAddr+MB_Frame[MB_N][5]>(MB_Frame[MB_N][1]==3?prw(&Modbus_Map[MB_N].HoldReg_Qt):prw(&Modbus_Map[MB_N].InReg_Qt)))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint16_t *Reg = (uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg)) + StartAddr;
	MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][2] = MB_Frame[MB_N][5]*2) + 5;
	uint8_t Qt = MB_Frame[MB_N][5];
	for (uint8_t i=0; i<Qt; i++) {
    5b18:	9f 5f       	subi	r25, 0xFF	; 255
    5b1a:	12 96       	adiw	r26, 0x02	; 2
    5b1c:	94 17       	cp	r25, r20
    5b1e:	88 f3       	brcs	.-30     	; 0x5b02 <MB_S_Timer_ISR+0x62a>
		break;
	case 0x10:
		Err = MB_S_Preset(MB_N, StartAddr);
		break;
	default:
		Err = MB_Frame[MB_N][2] = IllegFunc;
    5b20:	90 e0       	ldi	r25, 0x00	; 0
    5b22:	95 cd       	rjmp	.-1238   	; 0x564e <MB_S_Timer_ISR+0x176>
    5b24:	93 01       	movw	r18, r6
    5b26:	2e 5f       	subi	r18, 0xFE	; 254
    5b28:	3c 4f       	sbci	r19, 0xFC	; 252
    5b2a:	f9 01       	movw	r30, r18
    5b2c:	85 91       	lpm	r24, Z+
    5b2e:	94 91       	lpm	r25, Z+
    5b30:	9a 83       	std	Y+2, r25	; 0x02
    5b32:	89 83       	std	Y+1, r24	; 0x01
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][6]+9 || Qt/8+(Qt%8>0)!=MB_Frame[MB_N][6])
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+Qt > prw(&Modbus_Map[MB_N].Coil_Qt))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Coil = prp(&Modbus_Map[MB_N].Coil);
	MB_Frame_Sz[MB_N] = 8;
    5b34:	88 e0       	ldi	r24, 0x08	; 8
    5b36:	f2 01       	movw	r30, r4
    5b38:	80 83       	st	Z, r24
	for (uint8_t i=0; i<Qt; i++) {
    5b3a:	10 97       	sbiw	r26, 0x00	; 0
    5b3c:	09 f4       	brne	.+2      	; 0x5b40 <MB_S_Timer_ISR+0x668>
    5b3e:	62 cf       	rjmp	.-316    	; 0x5a04 <MB_S_Timer_ISR+0x52c>
    5b40:	cc 24       	eor	r12, r12
    5b42:	80 e0       	ldi	r24, 0x00	; 0
    5b44:	90 e0       	ldi	r25, 0x00	; 0
    5b46:	20 e0       	ldi	r18, 0x00	; 0
    5b48:	30 e0       	ldi	r19, 0x00	; 0
		uint16_t j = StartAddr+i;
		uint16_t Byte=j/8, Bit=1<<j%8;
    5b4a:	e1 e0       	ldi	r30, 0x01	; 1
    5b4c:	4e 2e       	mov	r4, r30
    5b4e:	51 2c       	mov	r5, r1
		if (MB_Frame[MB_N][7+i/8] &(1<<i%8))
    5b50:	79 e1       	ldi	r23, 0x19	; 25
    5b52:	67 2e       	mov	r6, r23
    5b54:	7b e0       	ldi	r23, 0x0B	; 11
    5b56:	77 2e       	mov	r7, r23
    5b58:	6e 0c       	add	r6, r14
    5b5a:	7f 1c       	adc	r7, r15
    5b5c:	10 c0       	rjmp	.+32     	; 0x5b7e <MB_S_Timer_ISR+0x6a6>
			Coil[Byte] |=Bit;
    5b5e:	29 81       	ldd	r18, Y+1	; 0x01
    5b60:	3a 81       	ldd	r19, Y+2	; 0x02
    5b62:	24 0f       	add	r18, r20
    5b64:	35 1f       	adc	r19, r21
    5b66:	f9 01       	movw	r30, r18
    5b68:	80 81       	ld	r24, Z
    5b6a:	86 2b       	or	r24, r22
    5b6c:	80 83       	st	Z, r24
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+Qt > prw(&Modbus_Map[MB_N].Coil_Qt))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Coil = prp(&Modbus_Map[MB_N].Coil);
	MB_Frame_Sz[MB_N] = 8;
	for (uint8_t i=0; i<Qt; i++) {
    5b6e:	c3 94       	inc	r12
    5b70:	2c 2d       	mov	r18, r12
    5b72:	30 e0       	ldi	r19, 0x00	; 0
    5b74:	c9 01       	movw	r24, r18
    5b76:	2a 17       	cp	r18, r26
    5b78:	3b 07       	cpc	r19, r27
    5b7a:	08 f0       	brcs	.+2      	; 0x5b7e <MB_S_Timer_ISR+0x6a6>
    5b7c:	43 cf       	rjmp	.-378    	; 0x5a04 <MB_S_Timer_ISR+0x52c>
		uint16_t j = StartAddr+i;
    5b7e:	88 0d       	add	r24, r8
    5b80:	99 1d       	adc	r25, r9
		uint16_t Byte=j/8, Bit=1<<j%8;
    5b82:	ac 01       	movw	r20, r24
    5b84:	56 95       	lsr	r21
    5b86:	47 95       	ror	r20
    5b88:	56 95       	lsr	r21
    5b8a:	47 95       	ror	r20
    5b8c:	56 95       	lsr	r21
    5b8e:	47 95       	ror	r20
    5b90:	87 70       	andi	r24, 0x07	; 7
    5b92:	90 70       	andi	r25, 0x00	; 0
    5b94:	b2 01       	movw	r22, r4
    5b96:	02 c0       	rjmp	.+4      	; 0x5b9c <MB_S_Timer_ISR+0x6c4>
    5b98:	66 0f       	add	r22, r22
    5b9a:	77 1f       	adc	r23, r23
    5b9c:	8a 95       	dec	r24
    5b9e:	e2 f7       	brpl	.-8      	; 0x5b98 <MB_S_Timer_ISR+0x6c0>
		if (MB_Frame[MB_N][7+i/8] &(1<<i%8))
    5ba0:	8c 2d       	mov	r24, r12
    5ba2:	86 95       	lsr	r24
    5ba4:	86 95       	lsr	r24
    5ba6:	86 95       	lsr	r24
    5ba8:	f3 01       	movw	r30, r6
    5baa:	e8 0f       	add	r30, r24
    5bac:	f1 1d       	adc	r31, r1
    5bae:	87 81       	ldd	r24, Z+7	; 0x07
    5bb0:	90 e0       	ldi	r25, 0x00	; 0
    5bb2:	27 70       	andi	r18, 0x07	; 7
    5bb4:	30 70       	andi	r19, 0x00	; 0
    5bb6:	02 c0       	rjmp	.+4      	; 0x5bbc <MB_S_Timer_ISR+0x6e4>
    5bb8:	95 95       	asr	r25
    5bba:	87 95       	ror	r24
    5bbc:	2a 95       	dec	r18
    5bbe:	e2 f7       	brpl	.-8      	; 0x5bb8 <MB_S_Timer_ISR+0x6e0>
    5bc0:	80 fd       	sbrc	r24, 0
    5bc2:	cd cf       	rjmp	.-102    	; 0x5b5e <MB_S_Timer_ISR+0x686>
			Coil[Byte] |=Bit;
		else
			Coil[Byte] &=~Bit;
    5bc4:	29 81       	ldd	r18, Y+1	; 0x01
    5bc6:	3a 81       	ldd	r19, Y+2	; 0x02
    5bc8:	24 0f       	add	r18, r20
    5bca:	35 1f       	adc	r19, r21
    5bcc:	96 2f       	mov	r25, r22
    5bce:	90 95       	com	r25
    5bd0:	f9 01       	movw	r30, r18
    5bd2:	80 81       	ld	r24, Z
    5bd4:	89 23       	and	r24, r25
    5bd6:	80 83       	st	Z, r24
    5bd8:	ca cf       	rjmp	.-108    	; 0x5b6e <MB_S_Timer_ISR+0x696>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    5bda:	e8 85       	ldd	r30, Y+8	; 0x08
    5bdc:	f9 85       	ldd	r31, Y+9	; 0x09
    5bde:	ee 0f       	add	r30, r30
    5be0:	ff 1f       	adc	r31, r31
    5be2:	ee 0f       	add	r30, r30
    5be4:	ff 1f       	adc	r31, r31
    5be6:	ee 0f       	add	r30, r30
    5be8:	ff 1f       	adc	r31, r31
    5bea:	ee 0f       	add	r30, r30
    5bec:	ff 1f       	adc	r31, r31
    5bee:	ec 5f       	subi	r30, 0xFC	; 252
    5bf0:	fc 4f       	sbci	r31, 0xFC	; 252
    5bf2:	45 91       	lpm	r20, Z+
    5bf4:	54 91       	lpm	r21, Z+
    5bf6:	b2 cd       	rjmp	.-1180   	; 0x575c <MB_S_Timer_ISR+0x284>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5bf8:	f3 01       	movw	r30, r6
    5bfa:	e4 5f       	subi	r30, 0xF4	; 244
    5bfc:	fc 4f       	sbci	r31, 0xFC	; 252
    5bfe:	45 91       	lpm	r20, Z+
    5c00:	54 91       	lpm	r21, Z+
    5c02:	54 cf       	rjmp	.-344    	; 0x5aac <MB_S_Timer_ISR+0x5d4>
    5c04:	f3 01       	movw	r30, r6
    5c06:	ee 5f       	subi	r30, 0xFE	; 254
    5c08:	fc 4f       	sbci	r31, 0xFC	; 252
    5c0a:	85 91       	lpm	r24, Z+
    5c0c:	94 91       	lpm	r25, Z+
    5c0e:	28 2f       	mov	r18, r24
    5c10:	89 2f       	mov	r24, r25
    5c12:	b9 cd       	rjmp	.-1166   	; 0x5786 <MB_S_Timer_ISR+0x2ae>
    5c14:	e8 85       	ldd	r30, Y+8	; 0x08
    5c16:	f9 85       	ldd	r31, Y+9	; 0x09
    5c18:	ee 0f       	add	r30, r30
    5c1a:	ff 1f       	adc	r31, r31
    5c1c:	ee 0f       	add	r30, r30
    5c1e:	ff 1f       	adc	r31, r31
    5c20:	ee 0f       	add	r30, r30
    5c22:	ff 1f       	adc	r31, r31
    5c24:	ee 0f       	add	r30, r30
    5c26:	ff 1f       	adc	r31, r31
    5c28:	e6 5f       	subi	r30, 0xF6	; 246
    5c2a:	fc 4f       	sbci	r31, 0xFC	; 252
    5c2c:	85 91       	lpm	r24, Z+
    5c2e:	94 91       	lpm	r25, Z+
    5c30:	4d cf       	rjmp	.-358    	; 0x5acc <MB_S_Timer_ISR+0x5f4>

00005c32 <MB_S_Tx>:
    5c32:	94 e1       	ldi	r25, 0x14	; 20
    5c34:	89 9f       	mul	r24, r25
    5c36:	c0 01       	movw	r24, r0
    5c38:	11 24       	eor	r1, r1
    5c3a:	80 51       	subi	r24, 0x10	; 16
    5c3c:	94 4d       	sbci	r25, 0xD4	; 212
    5c3e:	fc 01       	movw	r30, r24
    5c40:	25 91       	lpm	r18, Z+
    5c42:	34 91       	lpm	r19, Z+

// ~~~~~~~~~~~~~~~~~~
void
MB_S_Tx(uint8_t MB_N)
{
	USART_Func(MB_N, LED);
    5c44:	f9 01       	movw	r30, r18
    5c46:	19 95       	eicall
}
    5c48:	08 95       	ret

00005c4a <MB_Slave_Off>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
MB_Slave_Off(uint8_t MB_N, uint8_t S_N)
{
    5c4a:	21 e0       	ldi	r18, 0x01	; 1
    5c4c:	30 e0       	ldi	r19, 0x00	; 0
    5c4e:	40 e0       	ldi	r20, 0x00	; 0
    5c50:	50 e0       	ldi	r21, 0x00	; 0
    5c52:	04 c0       	rjmp	.+8      	; 0x5c5c <MB_Slave_Off+0x12>
    5c54:	22 0f       	add	r18, r18
    5c56:	33 1f       	adc	r19, r19
    5c58:	44 1f       	adc	r20, r20
    5c5a:	55 1f       	adc	r21, r21
    5c5c:	6a 95       	dec	r22
    5c5e:	d2 f7       	brpl	.-12     	; 0x5c54 <MB_Slave_Off+0xa>
    5c60:	e8 2f       	mov	r30, r24
    5c62:	f0 e0       	ldi	r31, 0x00	; 0
    5c64:	ee 0f       	add	r30, r30
    5c66:	ff 1f       	adc	r31, r31
    5c68:	ee 0f       	add	r30, r30
    5c6a:	ff 1f       	adc	r31, r31
    5c6c:	e5 52       	subi	r30, 0x25	; 37
    5c6e:	f7 4f       	sbci	r31, 0xF7	; 247
    5c70:	80 81       	ld	r24, Z
    5c72:	91 81       	ldd	r25, Z+1	; 0x01
    5c74:	a2 81       	ldd	r26, Z+2	; 0x02
    5c76:	b3 81       	ldd	r27, Z+3	; 0x03
    5c78:	28 23       	and	r18, r24
    5c7a:	39 23       	and	r19, r25
    5c7c:	4a 23       	and	r20, r26
    5c7e:	5b 23       	and	r21, r27
	return SlaveOff[MB_N] &((uint32_t)1<<S_N);
}
    5c80:	b9 01       	movw	r22, r18
    5c82:	ca 01       	movw	r24, r20
    5c84:	08 95       	ret

00005c86 <GetReg>:
}

// ~~~~~~~~~~~~~~~~~
static uint16_t*
GetReg(uint8_t MB_N)
{
    5c86:	98 2f       	mov	r25, r24
	return MB_SingleState[MB_N]!=MB_SingleExec?(uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+prw(&GetQuery(MB_N)->AllocAddr):MB_SingleQuery[MB_N].Buf;
    5c88:	a8 2f       	mov	r26, r24
    5c8a:	b0 e0       	ldi	r27, 0x00	; 0
    5c8c:	fd 01       	movw	r30, r26
    5c8e:	ea 55       	subi	r30, 0x5A	; 90
    5c90:	f9 4f       	sbci	r31, 0xF9	; 249
    5c92:	80 81       	ld	r24, Z
    5c94:	82 30       	cpi	r24, 0x02	; 2
    5c96:	09 f4       	brne	.+2      	; 0x5c9a <GetReg+0x14>
    5c98:	39 c0       	rjmp	.+114    	; 0x5d0c <GetReg+0x86>
    5c9a:	fd 01       	movw	r30, r26
    5c9c:	ee 0f       	add	r30, r30
    5c9e:	ff 1f       	adc	r31, r31
    5ca0:	ee 0f       	add	r30, r30
    5ca2:	ff 1f       	adc	r31, r31
    5ca4:	ee 0f       	add	r30, r30
    5ca6:	ff 1f       	adc	r31, r31
    5ca8:	ee 0f       	add	r30, r30
    5caa:	ff 1f       	adc	r31, r31
    5cac:	e6 5f       	subi	r30, 0xF6	; 246
    5cae:	fc 4f       	sbci	r31, 0xFC	; 252
    5cb0:	45 91       	lpm	r20, Z+
    5cb2:	54 91       	lpm	r21, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    5cb4:	83 e0       	ldi	r24, 0x03	; 3
    5cb6:	98 9f       	mul	r25, r24
    5cb8:	f0 01       	movw	r30, r0
    5cba:	11 24       	eor	r1, r1
    5cbc:	e1 5f       	subi	r30, 0xF1	; 241
    5cbe:	f6 4d       	sbci	r31, 0xD6	; 214
    5cc0:	25 91       	lpm	r18, Z+
    5cc2:	34 91       	lpm	r19, Z+
    5cc4:	fd 01       	movw	r30, r26
    5cc6:	e5 5b       	subi	r30, 0xB5	; 181
    5cc8:	f9 4f       	sbci	r31, 0xF9	; 249
    5cca:	80 81       	ld	r24, Z
    5ccc:	90 e0       	ldi	r25, 0x00	; 0
    5cce:	88 0f       	add	r24, r24
    5cd0:	99 1f       	adc	r25, r25
    5cd2:	88 0f       	add	r24, r24
    5cd4:	99 1f       	adc	r25, r25
    5cd6:	28 0f       	add	r18, r24
    5cd8:	39 1f       	adc	r19, r25
    5cda:	2f 5f       	subi	r18, 0xFF	; 255
    5cdc:	3f 4f       	sbci	r19, 0xFF	; 255
    5cde:	f9 01       	movw	r30, r18
    5ce0:	65 91       	lpm	r22, Z+
    5ce2:	74 91       	lpm	r23, Z+
    5ce4:	a4 5b       	subi	r26, 0xB4	; 180
    5ce6:	b9 4f       	sbci	r27, 0xF9	; 249
    5ce8:	8c 91       	ld	r24, X
    5cea:	27 e0       	ldi	r18, 0x07	; 7
    5cec:	82 9f       	mul	r24, r18
    5cee:	c0 01       	movw	r24, r0
    5cf0:	11 24       	eor	r1, r1
    5cf2:	68 0f       	add	r22, r24
    5cf4:	79 1f       	adc	r23, r25
    5cf6:	6b 5f       	subi	r22, 0xFB	; 251
    5cf8:	7f 4f       	sbci	r23, 0xFF	; 255
    5cfa:	fb 01       	movw	r30, r22
    5cfc:	85 91       	lpm	r24, Z+
    5cfe:	94 91       	lpm	r25, Z+
    5d00:	88 0f       	add	r24, r24
    5d02:	99 1f       	adc	r25, r25
    5d04:	48 0f       	add	r20, r24
    5d06:	59 1f       	adc	r21, r25
}
    5d08:	ca 01       	movw	r24, r20
    5d0a:	08 95       	ret

// ~~~~~~~~~~~~~~~~~
static uint16_t*
GetReg(uint8_t MB_N)
{
	return MB_SingleState[MB_N]!=MB_SingleExec?(uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+prw(&GetQuery(MB_N)->AllocAddr):MB_SingleQuery[MB_N].Buf;
    5d0c:	aa 0f       	add	r26, r26
    5d0e:	bb 1f       	adc	r27, r27
    5d10:	aa 0f       	add	r26, r26
    5d12:	bb 1f       	adc	r27, r27
    5d14:	aa 0f       	add	r26, r26
    5d16:	bb 1f       	adc	r27, r27
    5d18:	af 52       	subi	r26, 0x2F	; 47
    5d1a:	bb 4f       	sbci	r27, 0xFB	; 251
    5d1c:	16 96       	adiw	r26, 0x06	; 6
    5d1e:	4d 91       	ld	r20, X+
    5d20:	5c 91       	ld	r21, X
    5d22:	17 97       	sbiw	r26, 0x07	; 7
}
    5d24:	ca 01       	movw	r24, r20
    5d26:	08 95       	ret

00005d28 <FormData>:

// ~~~~~~~~~~~~~~~~~~~
static void
FormData(uint8_t MB_N)
{
    5d28:	cf 92       	push	r12
    5d2a:	df 92       	push	r13
    5d2c:	ef 92       	push	r14
    5d2e:	ff 92       	push	r15
    5d30:	0f 93       	push	r16
    5d32:	1f 93       	push	r17
    5d34:	cf 93       	push	r28
    5d36:	df 93       	push	r29
    5d38:	e8 2e       	mov	r14, r24
	uint16_t Qt;
	uint16_t *Reg;
	switch (MB_Frame[MB_N][1]) {
    5d3a:	c8 2f       	mov	r28, r24
    5d3c:	d0 e0       	ldi	r29, 0x00	; 0
    5d3e:	7c 2f       	mov	r23, r28
    5d40:	66 27       	eor	r22, r22
    5d42:	8b 01       	movw	r16, r22
    5d44:	07 5e       	subi	r16, 0xE7	; 231
    5d46:	14 4f       	sbci	r17, 0xF4	; 244
    5d48:	f8 01       	movw	r30, r16
    5d4a:	81 81       	ldd	r24, Z+1	; 0x01
    5d4c:	86 30       	cpi	r24, 0x06	; 6
    5d4e:	09 f4       	brne	.+2      	; 0x5d52 <FormData+0x2a>
    5d50:	4b c0       	rjmp	.+150    	; 0x5de8 <FormData+0xc0>
    5d52:	87 30       	cpi	r24, 0x07	; 7
    5d54:	88 f0       	brcs	.+34     	; 0x5d78 <FormData+0x50>
    5d56:	8f 30       	cpi	r24, 0x0F	; 15
    5d58:	09 f4       	brne	.+2      	; 0x5d5c <FormData+0x34>
    5d5a:	5b c0       	rjmp	.+182    	; 0x5e12 <FormData+0xea>
    5d5c:	80 31       	cpi	r24, 0x10	; 16
    5d5e:	a1 f0       	breq	.+40     	; 0x5d88 <FormData+0x60>
			MB_Frame[MB_N][7+j] = Reg[i]>>8;
			MB_Frame[MB_N][8+j] = Reg[i];
		}
		break;
	}
	SetCRC_MB(MB_N);
    5d60:	8e 2d       	mov	r24, r14
    5d62:	0e 94 13 2a 	call	0x5426	; 0x5426 <SetCRC_MB>
}
    5d66:	df 91       	pop	r29
    5d68:	cf 91       	pop	r28
    5d6a:	1f 91       	pop	r17
    5d6c:	0f 91       	pop	r16
    5d6e:	ff 90       	pop	r15
    5d70:	ef 90       	pop	r14
    5d72:	df 90       	pop	r13
    5d74:	cf 90       	pop	r12
    5d76:	08 95       	ret
static void
FormData(uint8_t MB_N)
{
	uint16_t Qt;
	uint16_t *Reg;
	switch (MB_Frame[MB_N][1]) {
    5d78:	81 50       	subi	r24, 0x01	; 1
    5d7a:	84 30       	cpi	r24, 0x04	; 4
    5d7c:	88 f7       	brcc	.-30     	; 0x5d60 <FormData+0x38>
	case 1: case 2: case 3: case 4:
		MB_Frame_Sz[MB_N] = 8;
    5d7e:	c5 50       	subi	r28, 0x05	; 5
    5d80:	d9 4f       	sbci	r29, 0xF9	; 249
    5d82:	88 e0       	ldi	r24, 0x08	; 8
    5d84:	88 83       	st	Y, r24
    5d86:	ec cf       	rjmp	.-40     	; 0x5d60 <FormData+0x38>
			else
				MB_Frame[MB_N][Byte] &=~Bit;
		}
		break;
	case 0x10:
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = MB_Frame[MB_N][5]*2) + 9;
    5d88:	55 e0       	ldi	r21, 0x05	; 5
    5d8a:	c5 2e       	mov	r12, r21
    5d8c:	d1 2c       	mov	r13, r1
    5d8e:	c0 0e       	add	r12, r16
    5d90:	d1 1e       	adc	r13, r17
    5d92:	f8 01       	movw	r30, r16
    5d94:	85 81       	ldd	r24, Z+5	; 0x05
    5d96:	90 e0       	ldi	r25, 0x00	; 0
    5d98:	88 0f       	add	r24, r24
    5d9a:	99 1f       	adc	r25, r25
    5d9c:	86 83       	std	Z+6, r24	; 0x06
    5d9e:	c5 50       	subi	r28, 0x05	; 5
    5da0:	d9 4f       	sbci	r29, 0xF9	; 249
    5da2:	87 5f       	subi	r24, 0xF7	; 247
    5da4:	88 83       	st	Y, r24
		Reg = GetReg(MB_N);
    5da6:	8e 2d       	mov	r24, r14
    5da8:	0e 94 43 2e 	call	0x5c86	; 0x5c86 <GetReg>
    5dac:	bc 01       	movw	r22, r24
		for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    5dae:	f8 01       	movw	r30, r16
    5db0:	85 81       	ldd	r24, Z+5	; 0x05
    5db2:	88 23       	and	r24, r24
    5db4:	a9 f2       	breq	.-86     	; 0x5d60 <FormData+0x38>
    5db6:	20 e0       	ldi	r18, 0x00	; 0
			uint8_t j = i*2;
			MB_Frame[MB_N][7+j] = Reg[i]>>8;
    5db8:	a8 01       	movw	r20, r16
		}
		break;
	case 0x10:
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = MB_Frame[MB_N][5]*2) + 9;
		Reg = GetReg(MB_N);
		for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    5dba:	e6 01       	movw	r28, r12
			uint8_t j = i*2;
			MB_Frame[MB_N][7+j] = Reg[i]>>8;
    5dbc:	82 2f       	mov	r24, r18
    5dbe:	90 e0       	ldi	r25, 0x00	; 0
    5dc0:	88 0f       	add	r24, r24
    5dc2:	99 1f       	adc	r25, r25
    5dc4:	fb 01       	movw	r30, r22
    5dc6:	e8 0f       	add	r30, r24
    5dc8:	f9 1f       	adc	r31, r25
    5dca:	da 01       	movw	r26, r20
    5dcc:	a8 0f       	add	r26, r24
    5dce:	b1 1d       	adc	r27, r1
    5dd0:	81 81       	ldd	r24, Z+1	; 0x01
    5dd2:	17 96       	adiw	r26, 0x07	; 7
    5dd4:	8c 93       	st	X, r24
    5dd6:	17 97       	sbiw	r26, 0x07	; 7
			MB_Frame[MB_N][8+j] = Reg[i];
    5dd8:	80 81       	ld	r24, Z
    5dda:	18 96       	adiw	r26, 0x08	; 8
    5ddc:	8c 93       	st	X, r24
		}
		break;
	case 0x10:
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = MB_Frame[MB_N][5]*2) + 9;
		Reg = GetReg(MB_N);
		for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    5dde:	2f 5f       	subi	r18, 0xFF	; 255
    5de0:	88 81       	ld	r24, Y
    5de2:	28 17       	cp	r18, r24
    5de4:	58 f3       	brcs	.-42     	; 0x5dbc <FormData+0x94>
    5de6:	bc cf       	rjmp	.-136    	; 0x5d60 <FormData+0x38>
		MB_Frame_Sz[MB_N] = 8;
		MB_Frame[MB_N][5] = 0;
		break;
	*/
	case 6:
		MB_Frame_Sz[MB_N] = 8;
    5de8:	fe 01       	movw	r30, r28
    5dea:	e5 50       	subi	r30, 0x05	; 5
    5dec:	f9 4f       	sbci	r31, 0xF9	; 249
    5dee:	88 e0       	ldi	r24, 0x08	; 8
    5df0:	80 83       	st	Z, r24
		Reg = GetReg(MB_N);
    5df2:	8e 2d       	mov	r24, r14
    5df4:	0e 94 43 2e 	call	0x5c86	; 0x5c86 <GetReg>
    5df8:	dc 01       	movw	r26, r24
		MB_Frame[MB_N][4] = *Reg>>8;
    5dfa:	fc 2f       	mov	r31, r28
    5dfc:	ee 27       	eor	r30, r30
    5dfe:	e3 5e       	subi	r30, 0xE3	; 227
    5e00:	f4 4f       	sbci	r31, 0xF4	; 244
    5e02:	11 96       	adiw	r26, 0x01	; 1
    5e04:	8c 91       	ld	r24, X
    5e06:	11 97       	sbiw	r26, 0x01	; 1
    5e08:	80 83       	st	Z, r24
		MB_Frame[MB_N][5] = *Reg;
    5e0a:	8c 91       	ld	r24, X
    5e0c:	f8 01       	movw	r30, r16
    5e0e:	85 83       	std	Z+5, r24	; 0x05
    5e10:	a7 cf       	rjmp	.-178    	; 0x5d60 <FormData+0x38>
    5e12:	fc 2f       	mov	r31, r28
    5e14:	ee 27       	eor	r30, r30
    5e16:	e3 5e       	subi	r30, 0xE3	; 227
    5e18:	f4 4f       	sbci	r31, 0xF4	; 244
    5e1a:	90 81       	ld	r25, Z
    5e1c:	80 e0       	ldi	r24, 0x00	; 0
    5e1e:	f8 01       	movw	r30, r16
    5e20:	25 81       	ldd	r18, Z+5	; 0x05
    5e22:	02 2f       	mov	r16, r18
    5e24:	10 e0       	ldi	r17, 0x00	; 0
    5e26:	08 2b       	or	r16, r24
    5e28:	19 2b       	or	r17, r25
		break;
	case 0x0F:
		Qt = MB_FrameReg(MB_N, 4);
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = Qt/8 + (Qt%8>0)) + 9;
    5e2a:	98 01       	movw	r18, r16
    5e2c:	36 95       	lsr	r19
    5e2e:	27 95       	ror	r18
    5e30:	36 95       	lsr	r19
    5e32:	27 95       	ror	r18
    5e34:	36 95       	lsr	r19
    5e36:	27 95       	ror	r18
    5e38:	40 e0       	ldi	r20, 0x00	; 0
    5e3a:	c8 01       	movw	r24, r16
    5e3c:	87 70       	andi	r24, 0x07	; 7
    5e3e:	90 70       	andi	r25, 0x00	; 0
    5e40:	89 2b       	or	r24, r25
    5e42:	09 f0       	breq	.+2      	; 0x5e46 <FormData+0x11e>
    5e44:	8b c0       	rjmp	.+278    	; 0x5f5c <FormData+0x234>
    5e46:	84 2f       	mov	r24, r20
    5e48:	82 0f       	add	r24, r18
    5e4a:	fb 01       	movw	r30, r22
    5e4c:	e7 5e       	subi	r30, 0xE7	; 231
    5e4e:	f4 4f       	sbci	r31, 0xF4	; 244
    5e50:	86 83       	std	Z+6, r24	; 0x06
    5e52:	de 01       	movw	r26, r28
    5e54:	a5 50       	subi	r26, 0x05	; 5
    5e56:	b9 4f       	sbci	r27, 0xF9	; 249
    5e58:	87 5f       	subi	r24, 0xF7	; 247
    5e5a:	8c 93       	st	X, r24
		MB_Frame[MB_N][7+Qt/8] = 0;
    5e5c:	e2 0f       	add	r30, r18
    5e5e:	f3 1f       	adc	r31, r19
    5e60:	17 82       	std	Z+7, r1	; 0x07
		uint8_t *Discr;
		uint8_t Pin;
		if (MB_SingleState[MB_N]!=MB_SingleExec) {
    5e62:	fe 01       	movw	r30, r28
    5e64:	ea 55       	subi	r30, 0x5A	; 90
    5e66:	f9 4f       	sbci	r31, 0xF9	; 249
    5e68:	80 81       	ld	r24, Z
    5e6a:	82 30       	cpi	r24, 0x02	; 2
    5e6c:	09 f4       	brne	.+2      	; 0x5e70 <FormData+0x148>
    5e6e:	78 c0       	rjmp	.+240    	; 0x5f60 <FormData+0x238>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5e70:	fe 01       	movw	r30, r28
    5e72:	e2 95       	swap	r30
    5e74:	f2 95       	swap	r31
    5e76:	f0 7f       	andi	r31, 0xF0	; 240
    5e78:	fe 27       	eor	r31, r30
    5e7a:	e0 7f       	andi	r30, 0xF0	; 240
    5e7c:	fe 27       	eor	r31, r30
    5e7e:	ee 5f       	subi	r30, 0xFE	; 254
    5e80:	fc 4f       	sbci	r31, 0xFC	; 252
			Discr = prp(&Modbus_Map[MB_N].Coil);
    5e82:	a5 91       	lpm	r26, Z+
    5e84:	b4 91       	lpm	r27, Z+
    5e86:	83 e0       	ldi	r24, 0x03	; 3
    5e88:	e8 9e       	mul	r14, r24
    5e8a:	f0 01       	movw	r30, r0
    5e8c:	11 24       	eor	r1, r1
    5e8e:	e1 5f       	subi	r30, 0xF1	; 241
    5e90:	f6 4d       	sbci	r31, 0xD6	; 214
    5e92:	25 91       	lpm	r18, Z+
    5e94:	34 91       	lpm	r19, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    5e96:	fe 01       	movw	r30, r28
    5e98:	e5 5b       	subi	r30, 0xB5	; 181
    5e9a:	f9 4f       	sbci	r31, 0xF9	; 249
    5e9c:	80 81       	ld	r24, Z
    5e9e:	90 e0       	ldi	r25, 0x00	; 0
    5ea0:	88 0f       	add	r24, r24
    5ea2:	99 1f       	adc	r25, r25
    5ea4:	88 0f       	add	r24, r24
    5ea6:	99 1f       	adc	r25, r25
    5ea8:	28 0f       	add	r18, r24
    5eaa:	39 1f       	adc	r19, r25
    5eac:	2f 5f       	subi	r18, 0xFF	; 255
    5eae:	3f 4f       	sbci	r19, 0xFF	; 255
    5eb0:	f9 01       	movw	r30, r18
    5eb2:	45 91       	lpm	r20, Z+
    5eb4:	54 91       	lpm	r21, Z+
    5eb6:	c4 5b       	subi	r28, 0xB4	; 180
    5eb8:	d9 4f       	sbci	r29, 0xF9	; 249
    5eba:	88 81       	ld	r24, Y
    5ebc:	27 e0       	ldi	r18, 0x07	; 7
    5ebe:	82 9f       	mul	r24, r18
    5ec0:	c0 01       	movw	r24, r0
    5ec2:	11 24       	eor	r1, r1
    5ec4:	48 0f       	add	r20, r24
    5ec6:	59 1f       	adc	r21, r25
    5ec8:	4b 5f       	subi	r20, 0xFB	; 251
    5eca:	5f 4f       	sbci	r21, 0xFF	; 255
    5ecc:	fa 01       	movw	r30, r20
    5ece:	85 91       	lpm	r24, Z+
    5ed0:	94 91       	lpm	r25, Z+
			Pin = prw(&GetQuery(MB_N)->AllocAddr);
    5ed2:	f8 2e       	mov	r15, r24
		}
		else {
			Discr = MB_SingleQuery[MB_N].Buf;
			Pin = 0;
		}
		for (uint8_t i=0; i<Qt; i++) {
    5ed4:	01 15       	cp	r16, r1
    5ed6:	11 05       	cpc	r17, r1
    5ed8:	09 f4       	brne	.+2      	; 0x5edc <FormData+0x1b4>
    5eda:	42 cf       	rjmp	.-380    	; 0x5d60 <FormData+0x38>
    5edc:	50 e0       	ldi	r21, 0x00	; 0
    5ede:	80 e0       	ldi	r24, 0x00	; 0
    5ee0:	90 e0       	ldi	r25, 0x00	; 0
			uint8_t j = Pin+i;
			uint8_t Byte=7+i/8, Bit=1<<i%8;
    5ee2:	c1 e0       	ldi	r28, 0x01	; 1
    5ee4:	d0 e0       	ldi	r29, 0x00	; 0
    5ee6:	0f c0       	rjmp	.+30     	; 0x5f06 <FormData+0x1de>
			if (Discr[j/8] &(1<<j%8))
				MB_Frame[MB_N][Byte] |=Bit;
    5ee8:	fb 01       	movw	r30, r22
    5eea:	e3 0f       	add	r30, r19
    5eec:	f1 1d       	adc	r31, r1
    5eee:	e7 5e       	subi	r30, 0xE7	; 231
    5ef0:	f4 4f       	sbci	r31, 0xF4	; 244
    5ef2:	80 81       	ld	r24, Z
    5ef4:	84 2b       	or	r24, r20
    5ef6:	80 83       	st	Z, r24
		}
		else {
			Discr = MB_SingleQuery[MB_N].Buf;
			Pin = 0;
		}
		for (uint8_t i=0; i<Qt; i++) {
    5ef8:	5f 5f       	subi	r21, 0xFF	; 255
    5efa:	85 2f       	mov	r24, r21
    5efc:	90 e0       	ldi	r25, 0x00	; 0
    5efe:	80 17       	cp	r24, r16
    5f00:	91 07       	cpc	r25, r17
    5f02:	08 f0       	brcs	.+2      	; 0x5f06 <FormData+0x1de>
    5f04:	2d cf       	rjmp	.-422    	; 0x5d60 <FormData+0x38>
    5f06:	25 2f       	mov	r18, r21
    5f08:	2f 0d       	add	r18, r15
			uint8_t j = Pin+i;
			uint8_t Byte=7+i/8, Bit=1<<i%8;
    5f0a:	35 2f       	mov	r19, r21
    5f0c:	36 95       	lsr	r19
    5f0e:	36 95       	lsr	r19
    5f10:	36 95       	lsr	r19
    5f12:	39 5f       	subi	r19, 0xF9	; 249
    5f14:	87 70       	andi	r24, 0x07	; 7
    5f16:	90 70       	andi	r25, 0x00	; 0
    5f18:	fe 01       	movw	r30, r28
    5f1a:	02 c0       	rjmp	.+4      	; 0x5f20 <FormData+0x1f8>
    5f1c:	ee 0f       	add	r30, r30
    5f1e:	ff 1f       	adc	r31, r31
    5f20:	8a 95       	dec	r24
    5f22:	e2 f7       	brpl	.-8      	; 0x5f1c <FormData+0x1f4>
    5f24:	4e 2f       	mov	r20, r30
			if (Discr[j/8] &(1<<j%8))
    5f26:	82 2f       	mov	r24, r18
    5f28:	86 95       	lsr	r24
    5f2a:	86 95       	lsr	r24
    5f2c:	86 95       	lsr	r24
    5f2e:	fd 01       	movw	r30, r26
    5f30:	e8 0f       	add	r30, r24
    5f32:	f1 1d       	adc	r31, r1
    5f34:	80 81       	ld	r24, Z
    5f36:	90 e0       	ldi	r25, 0x00	; 0
    5f38:	27 70       	andi	r18, 0x07	; 7
    5f3a:	02 c0       	rjmp	.+4      	; 0x5f40 <FormData+0x218>
    5f3c:	95 95       	asr	r25
    5f3e:	87 95       	ror	r24
    5f40:	2a 95       	dec	r18
    5f42:	e2 f7       	brpl	.-8      	; 0x5f3c <FormData+0x214>
    5f44:	80 fd       	sbrc	r24, 0
    5f46:	d0 cf       	rjmp	.-96     	; 0x5ee8 <FormData+0x1c0>
				MB_Frame[MB_N][Byte] |=Bit;
			else
				MB_Frame[MB_N][Byte] &=~Bit;
    5f48:	fb 01       	movw	r30, r22
    5f4a:	e3 0f       	add	r30, r19
    5f4c:	f1 1d       	adc	r31, r1
    5f4e:	e7 5e       	subi	r30, 0xE7	; 231
    5f50:	f4 4f       	sbci	r31, 0xF4	; 244
    5f52:	40 95       	com	r20
    5f54:	80 81       	ld	r24, Z
    5f56:	48 23       	and	r20, r24
    5f58:	40 83       	st	Z, r20
    5f5a:	ce cf       	rjmp	.-100    	; 0x5ef8 <FormData+0x1d0>
		MB_Frame[MB_N][4] = *Reg>>8;
		MB_Frame[MB_N][5] = *Reg;
		break;
	case 0x0F:
		Qt = MB_FrameReg(MB_N, 4);
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = Qt/8 + (Qt%8>0)) + 9;
    5f5c:	41 e0       	ldi	r20, 0x01	; 1
    5f5e:	73 cf       	rjmp	.-282    	; 0x5e46 <FormData+0x11e>
		if (MB_SingleState[MB_N]!=MB_SingleExec) {
			Discr = prp(&Modbus_Map[MB_N].Coil);
			Pin = prw(&GetQuery(MB_N)->AllocAddr);
		}
		else {
			Discr = MB_SingleQuery[MB_N].Buf;
    5f60:	cc 0f       	add	r28, r28
    5f62:	dd 1f       	adc	r29, r29
    5f64:	cc 0f       	add	r28, r28
    5f66:	dd 1f       	adc	r29, r29
    5f68:	cc 0f       	add	r28, r28
    5f6a:	dd 1f       	adc	r29, r29
    5f6c:	cf 52       	subi	r28, 0x2F	; 47
    5f6e:	db 4f       	sbci	r29, 0xFB	; 251
    5f70:	ae 81       	ldd	r26, Y+6	; 0x06
    5f72:	bf 81       	ldd	r27, Y+7	; 0x07
    5f74:	ff 24       	eor	r15, r15
    5f76:	ae cf       	rjmp	.-164    	; 0x5ed4 <FormData+0x1ac>

00005f78 <FormQuery>:
}

// ~~~~~~~~~~~~~~~~~~~~
static void
FormQuery(uint8_t MB_N)
{
    5f78:	cf 93       	push	r28
    5f7a:	df 93       	push	r29

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5f7c:	93 e0       	ldi	r25, 0x03	; 3
    5f7e:	89 9f       	mul	r24, r25
    5f80:	f0 01       	movw	r30, r0
    5f82:	11 24       	eor	r1, r1
    5f84:	e1 5f       	subi	r30, 0xF1	; 241
    5f86:	f6 4d       	sbci	r31, 0xD6	; 214
    5f88:	65 91       	lpm	r22, Z+
    5f8a:	74 91       	lpm	r23, Z+

// ~~~~~~~~~~~~~~~~~~~
static MB_Slave*
GetSlave(uint8_t MB_N)
{
	return (MB_Slave*)prp(&(MB_Master_List+MB_N)->SlaveList)+CurrSlave[MB_N];
    5f8c:	48 2f       	mov	r20, r24
    5f8e:	50 e0       	ldi	r21, 0x00	; 0
    5f90:	fa 01       	movw	r30, r20
    5f92:	e5 5b       	subi	r30, 0xB5	; 181
    5f94:	f9 4f       	sbci	r31, 0xF9	; 249
    5f96:	20 81       	ld	r18, Z
    5f98:	30 e0       	ldi	r19, 0x00	; 0
    5f9a:	22 0f       	add	r18, r18
    5f9c:	33 1f       	adc	r19, r19
    5f9e:	22 0f       	add	r18, r18
    5fa0:	33 1f       	adc	r19, r19
    5fa2:	62 0f       	add	r22, r18
    5fa4:	73 1f       	adc	r23, r19
    5fa6:	fb 01       	movw	r30, r22
    5fa8:	31 96       	adiw	r30, 0x01	; 1
    5faa:	c5 91       	lpm	r28, Z+
    5fac:	d4 91       	lpm	r29, Z+
// ~~~~~~~~~~~~~~~~~~~~
static void
FormQuery(uint8_t MB_N)
{
	MB_Slave *Slave = GetSlave(MB_N);
	MB_Query *Query = (MB_Query*)prp(&Slave->QueryList)+CurrQuery[MB_N];
    5fae:	fa 01       	movw	r30, r20
    5fb0:	e4 5b       	subi	r30, 0xB4	; 180
    5fb2:	f9 4f       	sbci	r31, 0xF9	; 249
    5fb4:	20 81       	ld	r18, Z
    5fb6:	97 e0       	ldi	r25, 0x07	; 7
    5fb8:	29 9f       	mul	r18, r25
    5fba:	90 01       	movw	r18, r0
    5fbc:	11 24       	eor	r1, r1
    5fbe:	c2 0f       	add	r28, r18
    5fc0:	d3 1f       	adc	r29, r19

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    5fc2:	fb 01       	movw	r30, r22
    5fc4:	94 91       	lpm	r25, Z+

	MB_Frame[MB_N][0] = prb(&Slave->Addr);
    5fc6:	29 e1       	ldi	r18, 0x19	; 25
    5fc8:	3b e0       	ldi	r19, 0x0B	; 11
    5fca:	b4 2f       	mov	r27, r20
    5fcc:	aa 27       	eor	r26, r26
    5fce:	a2 0f       	add	r26, r18
    5fd0:	b3 1f       	adc	r27, r19
    5fd2:	9c 93       	st	X, r25
    5fd4:	fe 01       	movw	r30, r28
    5fd6:	94 91       	lpm	r25, Z+
	MB_Frame[MB_N][1] = prb(&Query->Func);
    5fd8:	11 96       	adiw	r26, 0x01	; 1
    5fda:	9c 93       	st	X, r25
    5fdc:	11 97       	sbiw	r26, 0x01	; 1
	MB_Frame[MB_N][2] = prb((uint8_t*)&Query->StartAddr+1);
    5fde:	be 01       	movw	r22, r28
    5fe0:	6f 5f       	subi	r22, 0xFF	; 255
    5fe2:	7f 4f       	sbci	r23, 0xFF	; 255
    5fe4:	6f 5f       	subi	r22, 0xFF	; 255
    5fe6:	7f 4f       	sbci	r23, 0xFF	; 255
    5fe8:	fb 01       	movw	r30, r22
    5fea:	94 91       	lpm	r25, Z+
    5fec:	61 50       	subi	r22, 0x01	; 1
    5fee:	70 40       	sbci	r23, 0x00	; 0
    5ff0:	fd 01       	movw	r30, r26
    5ff2:	92 83       	std	Z+2, r25	; 0x02
    5ff4:	fb 01       	movw	r30, r22
    5ff6:	94 91       	lpm	r25, Z+
	MB_Frame[MB_N][3] = prb((uint8_t*)&Query->StartAddr);
    5ff8:	13 96       	adiw	r26, 0x03	; 3
    5ffa:	9c 93       	st	X, r25
    5ffc:	13 97       	sbiw	r26, 0x03	; 3
    5ffe:	24 96       	adiw	r28, 0x04	; 4
    6000:	fe 01       	movw	r30, r28
    6002:	94 91       	lpm	r25, Z+
	MB_Frame[MB_N][4] = prb((uint8_t*)&Query->Qt+1);
    6004:	fd 01       	movw	r30, r26
    6006:	94 83       	std	Z+4, r25	; 0x04
    6008:	21 97       	sbiw	r28, 0x01	; 1
    600a:	fe 01       	movw	r30, r28
    600c:	94 91       	lpm	r25, Z+
	MB_Frame[MB_N][5] = prb((uint8_t*)&Query->Qt);
    600e:	15 96       	adiw	r26, 0x05	; 5
    6010:	9c 93       	st	X, r25

	FormData(MB_N);
    6012:	0e 94 94 2e 	call	0x5d28	; 0x5d28 <FormData>
}
    6016:	df 91       	pop	r29
    6018:	cf 91       	pop	r28
    601a:	08 95       	ret

0000601c <FormSingle>:

// ~~~~~~~~~~~~~~~~~~~~~
static void
FormSingle(uint8_t MB_N)
{
    601c:	1f 93       	push	r17
    601e:	cf 93       	push	r28
    6020:	df 93       	push	r29
	MB_Frame[MB_N][0] = MB_SingleQuery[MB_N].Addr;
    6022:	a8 2f       	mov	r26, r24
    6024:	b0 e0       	ldi	r27, 0x00	; 0
    6026:	69 e1       	ldi	r22, 0x19	; 25
    6028:	7b e0       	ldi	r23, 0x0B	; 11
    602a:	5a 2f       	mov	r21, r26
    602c:	44 27       	eor	r20, r20
    602e:	46 0f       	add	r20, r22
    6030:	57 1f       	adc	r21, r23
    6032:	21 ed       	ldi	r18, 0xD1	; 209
    6034:	34 e0       	ldi	r19, 0x04	; 4
    6036:	fd 01       	movw	r30, r26
    6038:	ee 0f       	add	r30, r30
    603a:	ff 1f       	adc	r31, r31
    603c:	ee 0f       	add	r30, r30
    603e:	ff 1f       	adc	r31, r31
    6040:	ee 0f       	add	r30, r30
    6042:	ff 1f       	adc	r31, r31
    6044:	e2 0f       	add	r30, r18
    6046:	f3 1f       	adc	r31, r19
    6048:	90 81       	ld	r25, Z
    604a:	ea 01       	movw	r28, r20
    604c:	98 83       	st	Y, r25
	MB_Frame[MB_N][1] = MB_SingleQuery[MB_N].Func;
    604e:	91 81       	ldd	r25, Z+1	; 0x01
    6050:	99 83       	std	Y+1, r25	; 0x01
	MB_Frame[MB_N][2] = MB_SingleQuery[MB_N].StartAddr>>8;
    6052:	fd 01       	movw	r30, r26
    6054:	ee 0f       	add	r30, r30
    6056:	ff 1f       	adc	r31, r31
    6058:	ee 0f       	add	r30, r30
    605a:	ff 1f       	adc	r31, r31
    605c:	ee 0f       	add	r30, r30
    605e:	ff 1f       	adc	r31, r31
    6060:	32 96       	adiw	r30, 0x02	; 2
    6062:	e2 0f       	add	r30, r18
    6064:	f3 1f       	adc	r31, r19
    6066:	10 81       	ld	r17, Z
    6068:	91 81       	ldd	r25, Z+1	; 0x01
    606a:	fa 01       	movw	r30, r20
    606c:	92 83       	std	Z+2, r25	; 0x02
	MB_Frame[MB_N][3] = MB_SingleQuery[MB_N].StartAddr;
    606e:	1b 83       	std	Y+3, r17	; 0x03
	MB_Frame[MB_N][4] = MB_SingleQuery[MB_N].Qt>>8;
    6070:	fd 01       	movw	r30, r26
    6072:	ee 0f       	add	r30, r30
    6074:	ff 1f       	adc	r31, r31
    6076:	ee 0f       	add	r30, r30
    6078:	ff 1f       	adc	r31, r31
    607a:	ee 0f       	add	r30, r30
    607c:	ff 1f       	adc	r31, r31
    607e:	34 96       	adiw	r30, 0x04	; 4
    6080:	e2 0f       	add	r30, r18
    6082:	f3 1f       	adc	r31, r19
    6084:	10 81       	ld	r17, Z
    6086:	91 81       	ldd	r25, Z+1	; 0x01
    6088:	9c 83       	std	Y+4, r25	; 0x04
	MB_Frame[MB_N][5] = MB_SingleQuery[MB_N].Qt;
    608a:	1d 83       	std	Y+5, r17	; 0x05
	
	MB_SingleState[MB_N] = MB_SingleExec;
    608c:	aa 55       	subi	r26, 0x5A	; 90
    608e:	b9 4f       	sbci	r27, 0xF9	; 249
    6090:	92 e0       	ldi	r25, 0x02	; 2
    6092:	9c 93       	st	X, r25
	FormData(MB_N);
    6094:	0e 94 94 2e 	call	0x5d28	; 0x5d28 <FormData>
}
    6098:	df 91       	pop	r29
    609a:	cf 91       	pop	r28
    609c:	1f 91       	pop	r17
    609e:	08 95       	ret

000060a0 <NextSlave>:

// ~~~~~~~~~~~~~~~~~~~~
static uint8_t
NextSlave(uint8_t MB_N)
{
    60a0:	2f 92       	push	r2
    60a2:	3f 92       	push	r3
    60a4:	4f 92       	push	r4
    60a6:	5f 92       	push	r5
    60a8:	6f 92       	push	r6
    60aa:	7f 92       	push	r7
    60ac:	8f 92       	push	r8
    60ae:	9f 92       	push	r9
    60b0:	af 92       	push	r10
    60b2:	bf 92       	push	r11
    60b4:	cf 92       	push	r12
    60b6:	df 92       	push	r13
    60b8:	ef 92       	push	r14
    60ba:	ff 92       	push	r15
    60bc:	0f 93       	push	r16
    60be:	1f 93       	push	r17
    60c0:	df 93       	push	r29
    60c2:	cf 93       	push	r28
    60c4:	00 d0       	rcall	.+0      	; 0x60c6 <NextSlave+0x26>
    60c6:	00 d0       	rcall	.+0      	; 0x60c8 <NextSlave+0x28>
    60c8:	cd b7       	in	r28, 0x3d	; 61
    60ca:	de b7       	in	r29, 0x3e	; 62
    60cc:	68 2e       	mov	r6, r24
    60ce:	e3 e0       	ldi	r30, 0x03	; 3
    60d0:	8e 9f       	mul	r24, r30
    60d2:	f0 01       	movw	r30, r0
    60d4:	11 24       	eor	r1, r1
    60d6:	ef 5e       	subi	r30, 0xEF	; 239
    60d8:	f6 4d       	sbci	r31, 0xD6	; 214
    60da:	04 91       	lpm	r16, Z+
    60dc:	c8 2e       	mov	r12, r24
    60de:	dd 24       	eor	r13, r13
    60e0:	a6 01       	movw	r20, r12
    60e2:	45 5b       	subi	r20, 0xB5	; 181
    60e4:	59 4f       	sbci	r21, 0xF9	; 249
    60e6:	5e 83       	std	Y+6, r21	; 0x06
    60e8:	4d 83       	std	Y+5, r20	; 0x05
    60ea:	fa 01       	movw	r30, r20
    60ec:	20 81       	ld	r18, Z
    60ee:	16 01       	movw	r2, r12
    60f0:	22 0c       	add	r2, r2
    60f2:	33 1c       	adc	r3, r3
    60f4:	22 0c       	add	r2, r2
    60f6:	33 1c       	adc	r3, r3
    60f8:	f1 01       	movw	r30, r2
    60fa:	e5 52       	subi	r30, 0x25	; 37
    60fc:	fb 4f       	sbci	r31, 0xFB	; 251
    60fe:	80 80       	ld	r8, Z
    6100:	91 80       	ldd	r9, Z+1	; 0x01
    6102:	a2 80       	ldd	r10, Z+2	; 0x02
    6104:	b3 80       	ldd	r11, Z+3	; 0x03
	do
		if (++CurrSlave[MB_N]==SlaveQt) {
			CurrSlave[MB_N] = 0;
			Over = 1;

			if ((MB_Master_Cycle[MB_N]=0xFFFF-GetTimer16(TD_MB_Cycle+MB_N))>MB_Master_MaxCycle[MB_N])
    6106:	70 90 df 04 	lds	r7, 0x04DF
    610a:	f2 e0       	ldi	r31, 0x02	; 2
    610c:	7f 0e       	add	r7, r31
    610e:	47 2d       	mov	r20, r7
    6110:	48 0f       	add	r20, r24
    6112:	4a 83       	std	Y+2, r20	; 0x02
    6114:	5e ef       	ldi	r21, 0xFE	; 254
    6116:	75 0e       	add	r7, r21
// ~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
GetTimer16(uint8_t TimerN)
{
	IntOff();
	uint16_t Time = Timer16[TimerN];
    6118:	e4 2e       	mov	r14, r20
    611a:	ff 24       	eor	r15, r15
    611c:	19 82       	std	Y+1, r1	; 0x01
    611e:	10 e0       	ldi	r17, 0x00	; 0
    6120:	ee 0c       	add	r14, r14
    6122:	ff 1c       	adc	r15, r15
    6124:	86 e4       	ldi	r24, 0x46	; 70
    6126:	93 e0       	ldi	r25, 0x03	; 3
    6128:	e8 0e       	add	r14, r24
    612a:	f9 1e       	adc	r15, r25
    612c:	c6 01       	movw	r24, r12
    612e:	88 0f       	add	r24, r24
    6130:	99 1f       	adc	r25, r25
    6132:	fc 01       	movw	r30, r24
    6134:	e8 59       	subi	r30, 0x98	; 152
    6136:	f8 4f       	sbci	r31, 0xF8	; 248
    6138:	fc 83       	std	Y+4, r31	; 0x04
    613a:	eb 83       	std	Y+3, r30	; 0x03
    613c:	f5 eb       	ldi	r31, 0xB5	; 181
    613e:	4f 2e       	mov	r4, r31
    6140:	f6 e0       	ldi	r31, 0x06	; 6
    6142:	5f 2e       	mov	r5, r31
    6144:	48 0e       	add	r4, r24
    6146:	59 1e       	adc	r5, r25
    6148:	14 c0       	rjmp	.+40     	; 0x6172 <NextSlave+0xd2>
				MB_Master_MaxCycle[MB_N] = MB_Master_Cycle[MB_N];
			StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
		}
	while (SlaveSkip[MB_N] &((uint32_t)1<<CurrSlave[MB_N]) && ++i<SlaveQt);
    614a:	ed 81       	ldd	r30, Y+5	; 0x05
    614c:	fe 81       	ldd	r31, Y+6	; 0x06
    614e:	20 81       	ld	r18, Z
    6150:	d5 01       	movw	r26, r10
    6152:	c4 01       	movw	r24, r8
    6154:	02 2e       	mov	r0, r18
    6156:	04 c0       	rjmp	.+8      	; 0x6160 <NextSlave+0xc0>
    6158:	b6 95       	lsr	r27
    615a:	a7 95       	ror	r26
    615c:	97 95       	ror	r25
    615e:	87 95       	ror	r24
    6160:	0a 94       	dec	r0
    6162:	d2 f7       	brpl	.-12     	; 0x6158 <NextSlave+0xb8>
    6164:	81 70       	andi	r24, 0x01	; 1
    6166:	90 70       	andi	r25, 0x00	; 0
    6168:	88 23       	and	r24, r24
    616a:	61 f1       	breq	.+88     	; 0x61c4 <NextSlave+0x124>
    616c:	1f 5f       	subi	r17, 0xFF	; 255
    616e:	10 17       	cp	r17, r16
    6170:	48 f5       	brcc	.+82     	; 0x61c4 <NextSlave+0x124>
{
	uint8_t Over = 0;
	uint8_t i = 0;
	uint8_t SlaveQt = prb(&(MB_Master_List+MB_N)->SlaveQt);
	do
		if (++CurrSlave[MB_N]==SlaveQt) {
    6172:	82 2f       	mov	r24, r18
    6174:	8f 5f       	subi	r24, 0xFF	; 255
    6176:	ed 81       	ldd	r30, Y+5	; 0x05
    6178:	fe 81       	ldd	r31, Y+6	; 0x06
    617a:	80 83       	st	Z, r24
    617c:	80 17       	cp	r24, r16
    617e:	29 f7       	brne	.-54     	; 0x614a <NextSlave+0xaa>
			CurrSlave[MB_N] = 0;
    6180:	10 82       	st	Z, r1

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    6182:	8f b7       	in	r24, 0x3f	; 63
    6184:	80 78       	andi	r24, 0x80	; 128
    6186:	80 93 e5 02 	sts	0x02E5, r24
	cli();
    618a:	f8 94       	cli
    618c:	f7 01       	movw	r30, r14
    618e:	20 81       	ld	r18, Z
    6190:	31 81       	ldd	r19, Z+1	; 0x01

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    6192:	88 23       	and	r24, r24
    6194:	09 f0       	breq	.+2      	; 0x6198 <NextSlave+0xf8>
		sei();
    6196:	78 94       	sei
			Over = 1;

			if ((MB_Master_Cycle[MB_N]=0xFFFF-GetTimer16(TD_MB_Cycle+MB_N))>MB_Master_MaxCycle[MB_N])
    6198:	20 95       	com	r18
    619a:	30 95       	com	r19
    619c:	eb 81       	ldd	r30, Y+3	; 0x03
    619e:	fc 81       	ldd	r31, Y+4	; 0x04
    61a0:	31 83       	std	Z+1, r19	; 0x01
    61a2:	20 83       	st	Z, r18
    61a4:	f2 01       	movw	r30, r4
    61a6:	80 81       	ld	r24, Z
    61a8:	91 81       	ldd	r25, Z+1	; 0x01
    61aa:	82 17       	cp	r24, r18
    61ac:	93 07       	cpc	r25, r19
    61ae:	10 f4       	brcc	.+4      	; 0x61b4 <NextSlave+0x114>
				MB_Master_MaxCycle[MB_N] = MB_Master_Cycle[MB_N];
    61b0:	31 83       	std	Z+1, r19	; 0x01
    61b2:	20 83       	st	Z, r18
			StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
    61b4:	8a 81       	ldd	r24, Y+2	; 0x02
    61b6:	6f ef       	ldi	r22, 0xFF	; 255
    61b8:	7f ef       	ldi	r23, 0xFF	; 255
    61ba:	0e 94 05 1a 	call	0x340a	; 0x340a <StartTimer16>
    61be:	f1 e0       	ldi	r31, 0x01	; 1
    61c0:	f9 83       	std	Y+1, r31	; 0x01
    61c2:	c3 cf       	rjmp	.-122    	; 0x614a <NextSlave+0xaa>
		}
	while (SlaveSkip[MB_N] &((uint32_t)1<<CurrSlave[MB_N]) && ++i<SlaveQt);
	if (i==SlaveQt) {
    61c4:	10 17       	cp	r17, r16
    61c6:	01 f1       	breq	.+64     	; 0x6208 <NextSlave+0x168>
		SlavesOn(MB_N);
		if (++CurrSlave[MB_N]==SlaveQt)
			CurrSlave[MB_N] = 0;
	}
	CurrQuery[MB_N] = 0;
    61c8:	4c e4       	ldi	r20, 0x4C	; 76
    61ca:	56 e0       	ldi	r21, 0x06	; 6
    61cc:	c4 0e       	add	r12, r20
    61ce:	d5 1e       	adc	r13, r21
    61d0:	f6 01       	movw	r30, r12
    61d2:	10 82       	st	Z, r1
	return Over;
}
    61d4:	89 81       	ldd	r24, Y+1	; 0x01
    61d6:	26 96       	adiw	r28, 0x06	; 6
    61d8:	0f b6       	in	r0, 0x3f	; 63
    61da:	f8 94       	cli
    61dc:	de bf       	out	0x3e, r29	; 62
    61de:	0f be       	out	0x3f, r0	; 63
    61e0:	cd bf       	out	0x3d, r28	; 61
    61e2:	cf 91       	pop	r28
    61e4:	df 91       	pop	r29
    61e6:	1f 91       	pop	r17
    61e8:	0f 91       	pop	r16
    61ea:	ff 90       	pop	r15
    61ec:	ef 90       	pop	r14
    61ee:	df 90       	pop	r13
    61f0:	cf 90       	pop	r12
    61f2:	bf 90       	pop	r11
    61f4:	af 90       	pop	r10
    61f6:	9f 90       	pop	r9
    61f8:	8f 90       	pop	r8
    61fa:	7f 90       	pop	r7
    61fc:	6f 90       	pop	r6
    61fe:	5f 90       	pop	r5
    6200:	4f 90       	pop	r4
    6202:	3f 90       	pop	r3
    6204:	2f 90       	pop	r2
    6206:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~
static void
SlavesOn(uint8_t MB_N)
{
	SlaveSkip[MB_N] = 0;
    6208:	4b ed       	ldi	r20, 0xDB	; 219
    620a:	54 e0       	ldi	r21, 0x04	; 4
    620c:	24 0e       	add	r2, r20
    620e:	35 1e       	adc	r3, r21
    6210:	f1 01       	movw	r30, r2
    6212:	10 82       	st	Z, r1
    6214:	11 82       	std	Z+1, r1	; 0x01
    6216:	12 82       	std	Z+2, r1	; 0x02
    6218:	13 82       	std	Z+3, r1	; 0x03
	StartTimer16(TD_MB_SlaveOff+MB_N, 100*MB_M_TimeOff[MB_N]);
    621a:	73 94       	inc	r7
    621c:	f6 01       	movw	r30, r12
    621e:	ea 52       	subi	r30, 0x2A	; 42
    6220:	fa 4f       	sbci	r31, 0xFA	; 250
    6222:	60 81       	ld	r22, Z
    6224:	84 e6       	ldi	r24, 0x64	; 100
    6226:	68 9f       	mul	r22, r24
    6228:	b0 01       	movw	r22, r0
    622a:	11 24       	eor	r1, r1
    622c:	87 2d       	mov	r24, r7
    622e:	86 0d       	add	r24, r6
    6230:	0e 94 05 1a 	call	0x340a	; 0x340a <StartTimer16>
			StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
		}
	while (SlaveSkip[MB_N] &((uint32_t)1<<CurrSlave[MB_N]) && ++i<SlaveQt);
	if (i==SlaveQt) {
		SlavesOn(MB_N);
		if (++CurrSlave[MB_N]==SlaveQt)
    6234:	ed 81       	ldd	r30, Y+5	; 0x05
    6236:	fe 81       	ldd	r31, Y+6	; 0x06
    6238:	80 81       	ld	r24, Z
    623a:	8f 5f       	subi	r24, 0xFF	; 255
    623c:	80 83       	st	Z, r24
    623e:	18 17       	cp	r17, r24
    6240:	19 f6       	brne	.-122    	; 0x61c8 <NextSlave+0x128>
			CurrSlave[MB_N] = 0;
    6242:	10 82       	st	Z, r1
    6244:	c1 cf       	rjmp	.-126    	; 0x61c8 <NextSlave+0x128>

00006246 <FailSlave>:
}

// ~~~~~~~~~~~~~~~~~~~~
static uint8_t
FailSlave(uint8_t MB_N)
{
    6246:	ef 92       	push	r14
    6248:	ff 92       	push	r15
    624a:	1f 93       	push	r17
    624c:	cf 93       	push	r28
    624e:	df 93       	push	r29
    6250:	18 2f       	mov	r17, r24
	uint8_t Over = 0;
	if (MB_SingleState[MB_N]==MB_SingleExec)
    6252:	68 2f       	mov	r22, r24
    6254:	70 e0       	ldi	r23, 0x00	; 0
    6256:	fb 01       	movw	r30, r22
    6258:	ea 55       	subi	r30, 0x5A	; 90
    625a:	f9 4f       	sbci	r31, 0xF9	; 249
    625c:	80 81       	ld	r24, Z
    625e:	82 30       	cpi	r24, 0x02	; 2
    6260:	19 f1       	breq	.+70     	; 0x62a8 <FailSlave+0x62>
		MB_SingleState[MB_N] = MB_SingleIdle;
	else{
		MB_CPT[MB_N][4]++;	// -    
    6262:	fb 01       	movw	r30, r22
    6264:	ee 0f       	add	r30, r30
    6266:	ff 1f       	adc	r31, r31
    6268:	ee 0f       	add	r30, r30
    626a:	ff 1f       	adc	r31, r31
    626c:	ee 0f       	add	r30, r30
    626e:	ff 1f       	adc	r31, r31
    6270:	ee 0f       	add	r30, r30
    6272:	ff 1f       	adc	r31, r31
    6274:	e4 51       	subi	r30, 0x14	; 20
    6276:	f7 4f       	sbci	r31, 0xF7	; 247
    6278:	80 81       	ld	r24, Z
    627a:	91 81       	ldd	r25, Z+1	; 0x01
    627c:	01 96       	adiw	r24, 0x01	; 1
    627e:	91 83       	std	Z+1, r25	; 0x01
    6280:	80 83       	st	Z, r24
		if (++Try[MB_N]==MB_M_Try[MB_N]) {
    6282:	eb 01       	movw	r28, r22
    6284:	c6 52       	subi	r28, 0x26	; 38
    6286:	db 4f       	sbci	r29, 0xFB	; 251
    6288:	88 81       	ld	r24, Y
    628a:	8f 5f       	subi	r24, 0xFF	; 255
    628c:	88 83       	st	Y, r24
    628e:	fb 01       	movw	r30, r22
    6290:	ef 50       	subi	r30, 0x0F	; 15
    6292:	f9 4f       	sbci	r31, 0xF9	; 249
    6294:	90 81       	ld	r25, Z
    6296:	89 17       	cp	r24, r25
    6298:	79 f0       	breq	.+30     	; 0x62b8 <FailSlave+0x72>
    629a:	80 e0       	ldi	r24, 0x00	; 0
			Try[MB_N] = 0;
			Over = NextSlave(MB_N);
		}
	}
	return Over;
}
    629c:	df 91       	pop	r29
    629e:	cf 91       	pop	r28
    62a0:	1f 91       	pop	r17
    62a2:	ff 90       	pop	r15
    62a4:	ef 90       	pop	r14
    62a6:	08 95       	ret
static uint8_t
FailSlave(uint8_t MB_N)
{
	uint8_t Over = 0;
	if (MB_SingleState[MB_N]==MB_SingleExec)
		MB_SingleState[MB_N] = MB_SingleIdle;
    62a8:	10 82       	st	Z, r1
    62aa:	80 e0       	ldi	r24, 0x00	; 0
			Try[MB_N] = 0;
			Over = NextSlave(MB_N);
		}
	}
	return Over;
}
    62ac:	df 91       	pop	r29
    62ae:	cf 91       	pop	r28
    62b0:	1f 91       	pop	r17
    62b2:	ff 90       	pop	r15
    62b4:	ef 90       	pop	r14
    62b6:	08 95       	ret
	if (MB_SingleState[MB_N]==MB_SingleExec)
		MB_SingleState[MB_N] = MB_SingleIdle;
	else{
		MB_CPT[MB_N][4]++;	// -    
		if (++Try[MB_N]==MB_M_Try[MB_N]) {
			uint32_t S_N = (uint32_t)1<<CurrSlave[MB_N];
    62b8:	fb 01       	movw	r30, r22
    62ba:	e5 5b       	subi	r30, 0xB5	; 181
    62bc:	f9 4f       	sbci	r31, 0xF9	; 249
    62be:	21 e0       	ldi	r18, 0x01	; 1
    62c0:	30 e0       	ldi	r19, 0x00	; 0
    62c2:	40 e0       	ldi	r20, 0x00	; 0
    62c4:	50 e0       	ldi	r21, 0x00	; 0
    62c6:	00 80       	ld	r0, Z
    62c8:	04 c0       	rjmp	.+8      	; 0x62d2 <FailSlave+0x8c>
    62ca:	22 0f       	add	r18, r18
    62cc:	33 1f       	adc	r19, r19
    62ce:	44 1f       	adc	r20, r20
    62d0:	55 1f       	adc	r21, r21
    62d2:	0a 94       	dec	r0
    62d4:	d2 f7       	brpl	.-12     	; 0x62ca <FailSlave+0x84>
			SlaveOff[MB_N] |=S_N;
    62d6:	7b 01       	movw	r14, r22
    62d8:	ee 0c       	add	r14, r14
    62da:	ff 1c       	adc	r15, r15
    62dc:	ee 0c       	add	r14, r14
    62de:	ff 1c       	adc	r15, r15
    62e0:	b7 01       	movw	r22, r14
    62e2:	65 52       	subi	r22, 0x25	; 37
    62e4:	77 4f       	sbci	r23, 0xF7	; 247
    62e6:	fb 01       	movw	r30, r22
    62e8:	80 81       	ld	r24, Z
    62ea:	91 81       	ldd	r25, Z+1	; 0x01
    62ec:	a2 81       	ldd	r26, Z+2	; 0x02
    62ee:	b3 81       	ldd	r27, Z+3	; 0x03
    62f0:	82 2b       	or	r24, r18
    62f2:	93 2b       	or	r25, r19
    62f4:	a4 2b       	or	r26, r20
    62f6:	b5 2b       	or	r27, r21
    62f8:	80 83       	st	Z, r24
    62fa:	91 83       	std	Z+1, r25	; 0x01
    62fc:	a2 83       	std	Z+2, r26	; 0x02
    62fe:	b3 83       	std	Z+3, r27	; 0x03
			SlaveSkip[MB_N] |=S_N;
    6300:	f7 01       	movw	r30, r14
    6302:	e5 52       	subi	r30, 0x25	; 37
    6304:	fb 4f       	sbci	r31, 0xFB	; 251
    6306:	80 81       	ld	r24, Z
    6308:	91 81       	ldd	r25, Z+1	; 0x01
    630a:	a2 81       	ldd	r26, Z+2	; 0x02
    630c:	b3 81       	ldd	r27, Z+3	; 0x03
    630e:	28 2b       	or	r18, r24
    6310:	39 2b       	or	r19, r25
    6312:	4a 2b       	or	r20, r26
    6314:	5b 2b       	or	r21, r27
    6316:	20 83       	st	Z, r18
    6318:	31 83       	std	Z+1, r19	; 0x01
    631a:	42 83       	std	Z+2, r20	; 0x02
    631c:	53 83       	std	Z+3, r21	; 0x03
			Try[MB_N] = 0;
    631e:	18 82       	st	Y, r1
			Over = NextSlave(MB_N);
    6320:	81 2f       	mov	r24, r17
    6322:	0e 94 50 30 	call	0x60a0	; 0x60a0 <NextSlave>
		}
	}
	return Over;
}
    6326:	df 91       	pop	r29
    6328:	cf 91       	pop	r28
    632a:	1f 91       	pop	r17
    632c:	ff 90       	pop	r15
    632e:	ef 90       	pop	r14
    6330:	08 95       	ret

00006332 <MB_M_Timer_ISR>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_M_Timer_ISR(uint8_t MB_N)
{
    6332:	4f 92       	push	r4
    6334:	5f 92       	push	r5
    6336:	6f 92       	push	r6
    6338:	7f 92       	push	r7
    633a:	8f 92       	push	r8
    633c:	9f 92       	push	r9
    633e:	af 92       	push	r10
    6340:	bf 92       	push	r11
    6342:	cf 92       	push	r12
    6344:	df 92       	push	r13
    6346:	ef 92       	push	r14
    6348:	ff 92       	push	r15
    634a:	0f 93       	push	r16
    634c:	1f 93       	push	r17
    634e:	cf 93       	push	r28
    6350:	df 93       	push	r29
    6352:	18 2f       	mov	r17, r24
	switch (MB_State[MB_N]) {
    6354:	c8 2f       	mov	r28, r24
    6356:	d0 e0       	ldi	r29, 0x00	; 0
    6358:	fe 01       	movw	r30, r28
    635a:	e7 54       	subi	r30, 0x47	; 71
    635c:	fa 4f       	sbci	r31, 0xFA	; 250
    635e:	80 81       	ld	r24, Z
    6360:	88 23       	and	r24, r24
    6362:	f9 f4       	brne	.+62     	; 0x63a2 <MB_M_Timer_ISR+0x70>
	case MB_Initi:
		StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
    6364:	80 91 df 04 	lds	r24, 0x04DF
    6368:	8e 5f       	subi	r24, 0xFE	; 254
    636a:	81 0f       	add	r24, r17
    636c:	6f ef       	ldi	r22, 0xFF	; 255
    636e:	7f ef       	ldi	r23, 0xFF	; 255
    6370:	0e 94 05 1a 	call	0x340a	; 0x340a <StartTimer16>
		FormQuery(MB_N);
    6374:	81 2f       	mov	r24, r17
    6376:	0e 94 bc 2f 	call	0x5f78	; 0x5f78 <FormQuery>
		MB_Transm(MB_N);
    637a:	81 2f       	mov	r24, r17
    637c:	0e 94 b4 28 	call	0x5168	; 0x5168 <MB_Transm>
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
		MB_M_CtrlProc(MB_N);
		break;
	}
}
    6380:	df 91       	pop	r29
    6382:	cf 91       	pop	r28
    6384:	1f 91       	pop	r17
    6386:	0f 91       	pop	r16
    6388:	ff 90       	pop	r15
    638a:	ef 90       	pop	r14
    638c:	df 90       	pop	r13
    638e:	cf 90       	pop	r12
    6390:	bf 90       	pop	r11
    6392:	af 90       	pop	r10
    6394:	9f 90       	pop	r9
    6396:	8f 90       	pop	r8
    6398:	7f 90       	pop	r7
    639a:	6f 90       	pop	r6
    639c:	5f 90       	pop	r5
    639e:	4f 90       	pop	r4
    63a0:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_M_Timer_ISR(uint8_t MB_N)
{
	switch (MB_State[MB_N]) {
    63a2:	82 30       	cpi	r24, 0x02	; 2
    63a4:	69 f7       	brne	.-38     	; 0x6380 <MB_M_Timer_ISR+0x4e>
		StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
		FormQuery(MB_N);
		MB_Transm(MB_N);
		break;
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
    63a6:	84 e0       	ldi	r24, 0x04	; 4
    63a8:	80 83       	st	Z, r24
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
MB_M_CtrlProc(uint8_t MB_N)
{
	uint8_t Over = 0;
	LastProcSingle = MB_SingleState[MB_N]==MB_SingleExec;
    63aa:	e6 ea       	ldi	r30, 0xA6	; 166
    63ac:	ae 2e       	mov	r10, r30
    63ae:	e6 e0       	ldi	r30, 0x06	; 6
    63b0:	be 2e       	mov	r11, r30
    63b2:	ac 0e       	add	r10, r28
    63b4:	bd 1e       	adc	r11, r29
    63b6:	d5 01       	movw	r26, r10
    63b8:	8c 91       	ld	r24, X
    63ba:	90 e0       	ldi	r25, 0x00	; 0
    63bc:	82 30       	cpi	r24, 0x02	; 2
    63be:	09 f4       	brne	.+2      	; 0x63c2 <MB_M_Timer_ISR+0x90>
    63c0:	4e c0       	rjmp	.+156    	; 0x645e <MB_M_Timer_ISR+0x12c>
    63c2:	90 93 d9 04 	sts	0x04D9, r25
	if (CommErr(MB_N))
    63c6:	81 2f       	mov	r24, r17
    63c8:	0e 94 98 29 	call	0x5330	; 0x5330 <CommErr>
    63cc:	88 23       	and	r24, r24
    63ce:	91 f5       	brne	.+100    	; 0x6434 <MB_M_Timer_ISR+0x102>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    63d0:	7e 01       	movw	r14, r28
    63d2:	ee 0c       	add	r14, r14
    63d4:	ff 1c       	adc	r15, r15
    63d6:	ee 0c       	add	r14, r14
    63d8:	ff 1c       	adc	r15, r15
    63da:	c7 01       	movw	r24, r14
    63dc:	88 0f       	add	r24, r24
    63de:	99 1f       	adc	r25, r25
    63e0:	88 0f       	add	r24, r24
    63e2:	99 1f       	adc	r25, r25
    63e4:	8e 0d       	add	r24, r14
    63e6:	9f 1d       	adc	r25, r15
    63e8:	80 51       	subi	r24, 0x10	; 16
    63ea:	94 4d       	sbci	r25, 0xD4	; 212
    63ec:	fc 01       	movw	r30, r24
    63ee:	25 91       	lpm	r18, Z+
    63f0:	34 91       	lpm	r19, Z+
		Over = FailSlave(MB_N);
	else {
		USART_Func(MB_N, LED);
    63f2:	f9 01       	movw	r30, r18
    63f4:	19 95       	eicall
		MB_Slave *Slave;
		MB_Query *Query;
		uint8_t Addr, Func;
		if (LastProcSingle) {
    63f6:	80 91 d9 04 	lds	r24, 0x04D9
    63fa:	88 23       	and	r24, r24
    63fc:	91 f1       	breq	.+100    	; 0x6462 <MB_M_Timer_ISR+0x130>
			Addr = MB_SingleQuery[MB_N].Addr;
    63fe:	fe 01       	movw	r30, r28
    6400:	ee 0f       	add	r30, r30
    6402:	ff 1f       	adc	r31, r31
    6404:	ee 0f       	add	r30, r30
    6406:	ff 1f       	adc	r31, r31
    6408:	ee 0f       	add	r30, r30
    640a:	ff 1f       	adc	r31, r31
    640c:	ef 52       	subi	r30, 0x2F	; 47
    640e:	fb 4f       	sbci	r31, 0xFB	; 251
    6410:	20 81       	ld	r18, Z
			Func = MB_SingleQuery[MB_N].Func;
    6412:	91 81       	ldd	r25, Z+1	; 0x01
    6414:	40 e0       	ldi	r20, 0x00	; 0
    6416:	50 e0       	ldi	r21, 0x00	; 0
    6418:	60 e0       	ldi	r22, 0x00	; 0
    641a:	70 e0       	ldi	r23, 0x00	; 0
			Slave = GetSlave(MB_N);
			Query = (MB_Query*)prp(&Slave->QueryList)+CurrQuery[MB_N];
			Addr = prb(&Slave->Addr);
			Func = prb(&Query->Func);
		}
		if (MB_Frame[MB_N][0]!=Addr || MB_Frame[MB_N][1]!=Func)
    641c:	dc 2e       	mov	r13, r28
    641e:	cc 24       	eor	r12, r12
    6420:	f6 01       	movw	r30, r12
    6422:	e7 5e       	subi	r30, 0xE7	; 231
    6424:	f4 4f       	sbci	r31, 0xF4	; 244
    6426:	80 81       	ld	r24, Z
    6428:	82 17       	cp	r24, r18
    642a:	21 f4       	brne	.+8      	; 0x6434 <MB_M_Timer_ISR+0x102>
    642c:	a1 81       	ldd	r26, Z+1	; 0x01
    642e:	a9 17       	cp	r26, r25
    6430:	09 f4       	brne	.+2      	; 0x6434 <MB_M_Timer_ISR+0x102>
    6432:	3d c0       	rjmp	.+122    	; 0x64ae <MB_M_Timer_ISR+0x17c>
				Err = MB_M_Force(MB_N, Query);
				break;
			}
			if (Err) {
				MB_CPT[MB_N][2]++;
				Over = FailSlave(MB_N);
    6434:	81 2f       	mov	r24, r17
    6436:	0e 94 23 31 	call	0x6246	; 0x6246 <FailSlave>
    643a:	98 2f       	mov	r25, r24
			}
		}
		/*if (Over)
			USART_Func(MB_N, LED);*/
	}
	StartTimer16(TD_MB_Idle+MB_N, Over?MB_M_Period[MB_N]:MB_M_Pause_Min);
    643c:	80 91 df 04 	lds	r24, 0x04DF
    6440:	81 0f       	add	r24, r17
    6442:	99 23       	and	r25, r25
    6444:	49 f0       	breq	.+18     	; 0x6458 <MB_M_Timer_ISR+0x126>
    6446:	cc 0f       	add	r28, r28
    6448:	dd 1f       	adc	r29, r29
    644a:	cc 55       	subi	r28, 0x5C	; 92
    644c:	d9 4f       	sbci	r29, 0xF9	; 249
    644e:	68 81       	ld	r22, Y
    6450:	79 81       	ldd	r23, Y+1	; 0x01
    6452:	0e 94 05 1a 	call	0x340a	; 0x340a <StartTimer16>
    6456:	94 cf       	rjmp	.-216    	; 0x6380 <MB_M_Timer_ISR+0x4e>
    6458:	65 e0       	ldi	r22, 0x05	; 5
    645a:	70 e0       	ldi	r23, 0x00	; 0
    645c:	fa cf       	rjmp	.-12     	; 0x6452 <MB_M_Timer_ISR+0x120>
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
MB_M_CtrlProc(uint8_t MB_N)
{
	uint8_t Over = 0;
	LastProcSingle = MB_SingleState[MB_N]==MB_SingleExec;
    645e:	91 e0       	ldi	r25, 0x01	; 1
    6460:	b0 cf       	rjmp	.-160    	; 0x63c2 <MB_M_Timer_ISR+0x90>
    6462:	83 e0       	ldi	r24, 0x03	; 3
    6464:	18 9f       	mul	r17, r24
    6466:	f0 01       	movw	r30, r0
    6468:	11 24       	eor	r1, r1
    646a:	e1 5f       	subi	r30, 0xF1	; 241
    646c:	f6 4d       	sbci	r31, 0xD6	; 214
    646e:	65 91       	lpm	r22, Z+
    6470:	74 91       	lpm	r23, Z+

// ~~~~~~~~~~~~~~~~~~~
static MB_Slave*
GetSlave(uint8_t MB_N)
{
	return (MB_Slave*)prp(&(MB_Master_List+MB_N)->SlaveList)+CurrSlave[MB_N];
    6472:	fe 01       	movw	r30, r28
    6474:	e5 5b       	subi	r30, 0xB5	; 181
    6476:	f9 4f       	sbci	r31, 0xF9	; 249
    6478:	80 81       	ld	r24, Z
    647a:	90 e0       	ldi	r25, 0x00	; 0
    647c:	88 0f       	add	r24, r24
    647e:	99 1f       	adc	r25, r25
    6480:	88 0f       	add	r24, r24
    6482:	99 1f       	adc	r25, r25
    6484:	68 0f       	add	r22, r24
    6486:	79 1f       	adc	r23, r25
    6488:	fb 01       	movw	r30, r22
    648a:	31 96       	adiw	r30, 0x01	; 1
    648c:	45 91       	lpm	r20, Z+
    648e:	54 91       	lpm	r21, Z+
			Addr = MB_SingleQuery[MB_N].Addr;
			Func = MB_SingleQuery[MB_N].Func;
		}
		else {
			Slave = GetSlave(MB_N);
			Query = (MB_Query*)prp(&Slave->QueryList)+CurrQuery[MB_N];
    6490:	fe 01       	movw	r30, r28
    6492:	e4 5b       	subi	r30, 0xB4	; 180
    6494:	f9 4f       	sbci	r31, 0xF9	; 249
    6496:	80 81       	ld	r24, Z
    6498:	27 e0       	ldi	r18, 0x07	; 7
    649a:	82 9f       	mul	r24, r18
    649c:	c0 01       	movw	r24, r0
    649e:	11 24       	eor	r1, r1
    64a0:	48 0f       	add	r20, r24
    64a2:	59 1f       	adc	r21, r25

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    64a4:	fb 01       	movw	r30, r22
    64a6:	24 91       	lpm	r18, Z+
		}
		if (MB_Frame[MB_N][0]!=Addr || MB_Frame[MB_N][1]!=Func)
			Over = FailSlave(MB_N);
		else {
			uint8_t Err;
			switch (Func) {
    64a8:	fa 01       	movw	r30, r20
    64aa:	94 91       	lpm	r25, Z+
    64ac:	b7 cf       	rjmp	.-146    	; 0x641c <MB_M_Timer_ISR+0xea>
    64ae:	95 30       	cpi	r25, 0x05	; 5
    64b0:	18 f5       	brcc	.+70     	; 0x64f8 <MB_M_Timer_ISR+0x1c6>
    64b2:	93 30       	cpi	r25, 0x03	; 3
    64b4:	08 f4       	brcc	.+2      	; 0x64b8 <MB_M_Timer_ISR+0x186>
    64b6:	ad c0       	rjmp	.+346    	; 0x6612 <MB_M_Timer_ISR+0x2e0>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_M_ReadReg(uint8_t MB_N, MB_Query *Query)
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || (LastProcSingle?MB_SingleQuery[MB_N].Qt:prw(&Query->Qt))*2!=MB_Frame[MB_N][2])
    64b8:	fc 2f       	mov	r31, r28
    64ba:	ee 27       	eor	r30, r30
    64bc:	e5 5e       	subi	r30, 0xE5	; 229
    64be:	f4 4f       	sbci	r31, 0xF4	; 244
    64c0:	b0 81       	ld	r27, Z
    64c2:	fe 01       	movw	r30, r28
    64c4:	e5 50       	subi	r30, 0x05	; 5
    64c6:	f9 4f       	sbci	r31, 0xF9	; 249
    64c8:	80 81       	ld	r24, Z
    64ca:	90 e0       	ldi	r25, 0x00	; 0
    64cc:	8b 2e       	mov	r8, r27
    64ce:	99 24       	eor	r9, r9
    64d0:	94 01       	movw	r18, r8
    64d2:	2b 5f       	subi	r18, 0xFB	; 251
    64d4:	3f 4f       	sbci	r19, 0xFF	; 255
    64d6:	82 17       	cp	r24, r18
    64d8:	93 07       	cpc	r25, r19
    64da:	09 f4       	brne	.+2      	; 0x64de <MB_M_Timer_ISR+0x1ac>
    64dc:	94 c1       	rjmp	.+808    	; 0x6806 <MB_M_Timer_ISR+0x4d4>
			case 0x0F: case 0x10:
				Err = MB_M_Force(MB_N, Query);
				break;
			}
			if (Err) {
				MB_CPT[MB_N][2]++;
    64de:	f7 01       	movw	r30, r14
    64e0:	ee 0f       	add	r30, r30
    64e2:	ff 1f       	adc	r31, r31
    64e4:	ee 0f       	add	r30, r30
    64e6:	ff 1f       	adc	r31, r31
    64e8:	e8 51       	subi	r30, 0x18	; 24
    64ea:	f7 4f       	sbci	r31, 0xF7	; 247
    64ec:	80 81       	ld	r24, Z
    64ee:	91 81       	ldd	r25, Z+1	; 0x01
    64f0:	01 96       	adiw	r24, 0x01	; 1
    64f2:	91 83       	std	Z+1, r25	; 0x01
    64f4:	80 83       	st	Z, r24
    64f6:	9e cf       	rjmp	.-196    	; 0x6434 <MB_M_Timer_ISR+0x102>
		}
		if (MB_Frame[MB_N][0]!=Addr || MB_Frame[MB_N][1]!=Func)
			Over = FailSlave(MB_N);
		else {
			uint8_t Err;
			switch (Func) {
    64f8:	96 30       	cpi	r25, 0x06	; 6
    64fa:	09 f4       	brne	.+2      	; 0x64fe <MB_M_Timer_ISR+0x1cc>
    64fc:	18 c1       	rjmp	.+560    	; 0x672e <MB_M_Timer_ISR+0x3fc>
    64fe:	96 30       	cpi	r25, 0x06	; 6
    6500:	08 f4       	brcc	.+2      	; 0x6504 <MB_M_Timer_ISR+0x1d2>
    6502:	43 c0       	rjmp	.+134    	; 0x658a <MB_M_Timer_ISR+0x258>
    6504:	9f 50       	subi	r25, 0x0F	; 15
    6506:	92 30       	cpi	r25, 0x02	; 2
    6508:	08 f0       	brcs	.+2      	; 0x650c <MB_M_Timer_ISR+0x1da>
    650a:	3f c0       	rjmp	.+126    	; 0x658a <MB_M_Timer_ISR+0x258>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_M_Force(uint8_t MB_N, MB_Query *Query)
{
	uint16_t StartAddr, Qt;
	if (LastProcSingle) {
    650c:	80 91 d9 04 	lds	r24, 0x04D9
    6510:	88 23       	and	r24, r24
    6512:	09 f4       	brne	.+2      	; 0x6516 <MB_M_Timer_ISR+0x1e4>
    6514:	4e c1       	rjmp	.+668    	; 0x67b2 <MB_M_Timer_ISR+0x480>
		StartAddr	= MB_SingleQuery[MB_N].StartAddr;
    6516:	f7 01       	movw	r30, r14
    6518:	ee 0f       	add	r30, r30
    651a:	ff 1f       	adc	r31, r31
    651c:	ed 52       	subi	r30, 0x2D	; 45
    651e:	fb 4f       	sbci	r31, 0xFB	; 251
    6520:	80 80       	ld	r8, Z
    6522:	91 80       	ldd	r9, Z+1	; 0x01
		Qt				= MB_SingleQuery[MB_N].Qt;
    6524:	fe 01       	movw	r30, r28
    6526:	ee 0f       	add	r30, r30
    6528:	ff 1f       	adc	r31, r31
    652a:	ee 0f       	add	r30, r30
    652c:	ff 1f       	adc	r31, r31
    652e:	ee 0f       	add	r30, r30
    6530:	ff 1f       	adc	r31, r31
    6532:	eb 52       	subi	r30, 0x2B	; 43
    6534:	fb 4f       	sbci	r31, 0xFB	; 251
    6536:	40 81       	ld	r20, Z
    6538:	51 81       	ldd	r21, Z+1	; 0x01
	}
	else {
		StartAddr	= prw(&Query->StartAddr);
		Qt				= prw(&Query->Qt);
	}
	return MB_Frame_Sz[MB_N]!=8 || MB_FrameReg(MB_N, 2)!=StartAddr || MB_FrameReg(MB_N, 4)!=Qt;
    653a:	fe 01       	movw	r30, r28
    653c:	e5 50       	subi	r30, 0x05	; 5
    653e:	f9 4f       	sbci	r31, 0xF9	; 249
    6540:	80 81       	ld	r24, Z
    6542:	88 30       	cpi	r24, 0x08	; 8
    6544:	61 f6       	brne	.-104    	; 0x64de <MB_M_Timer_ISR+0x1ac>
    6546:	fc 2f       	mov	r31, r28
    6548:	ee 27       	eor	r30, r30
    654a:	e5 5e       	subi	r30, 0xE5	; 229
    654c:	f4 4f       	sbci	r31, 0xF4	; 244
    654e:	30 81       	ld	r19, Z
    6550:	20 e0       	ldi	r18, 0x00	; 0
    6552:	d6 01       	movw	r26, r12
    6554:	a7 5e       	subi	r26, 0xE7	; 231
    6556:	b4 4f       	sbci	r27, 0xF4	; 244
    6558:	13 96       	adiw	r26, 0x03	; 3
    655a:	8c 91       	ld	r24, X
    655c:	13 97       	sbiw	r26, 0x03	; 3
    655e:	90 e0       	ldi	r25, 0x00	; 0
    6560:	28 2b       	or	r18, r24
    6562:	39 2b       	or	r19, r25
    6564:	28 15       	cp	r18, r8
    6566:	39 05       	cpc	r19, r9
    6568:	09 f0       	breq	.+2      	; 0x656c <MB_M_Timer_ISR+0x23a>
    656a:	b9 cf       	rjmp	.-142    	; 0x64de <MB_M_Timer_ISR+0x1ac>
    656c:	fc 2f       	mov	r31, r28
    656e:	ee 27       	eor	r30, r30
    6570:	e3 5e       	subi	r30, 0xE3	; 227
    6572:	f4 4f       	sbci	r31, 0xF4	; 244
    6574:	90 81       	ld	r25, Z
    6576:	80 e0       	ldi	r24, 0x00	; 0
    6578:	15 96       	adiw	r26, 0x05	; 5
    657a:	2c 91       	ld	r18, X
    657c:	30 e0       	ldi	r19, 0x00	; 0
    657e:	82 2b       	or	r24, r18
    6580:	93 2b       	or	r25, r19
    6582:	84 17       	cp	r24, r20
    6584:	95 07       	cpc	r25, r21
    6586:	09 f0       	breq	.+2      	; 0x658a <MB_M_Timer_ISR+0x258>
    6588:	aa cf       	rjmp	.-172    	; 0x64de <MB_M_Timer_ISR+0x1ac>
			}
			if (Err) {
				MB_CPT[MB_N][2]++;
				Over = FailSlave(MB_N);
			}
			else if (LastProcSingle)
    658a:	80 91 d9 04 	lds	r24, 0x04D9
    658e:	88 23       	and	r24, r24
    6590:	41 f0       	breq	.+16     	; 0x65a2 <MB_M_Timer_ISR+0x270>
				MB_SingleState[MB_N] = MB_SingleIdle;
    6592:	d5 01       	movw	r26, r10
    6594:	1c 92       	st	X, r1
			}
		}
		/*if (Over)
			USART_Func(MB_N, LED);*/
	}
	StartTimer16(TD_MB_Idle+MB_N, Over?MB_M_Period[MB_N]:MB_M_Pause_Min);
    6596:	80 91 df 04 	lds	r24, 0x04DF
    659a:	81 0f       	add	r24, r17
    659c:	65 e0       	ldi	r22, 0x05	; 5
    659e:	70 e0       	ldi	r23, 0x00	; 0
    65a0:	58 cf       	rjmp	.-336    	; 0x6452 <MB_M_Timer_ISR+0x120>
				Over = FailSlave(MB_N);
			}
			else if (LastProcSingle)
				MB_SingleState[MB_N] = MB_SingleIdle;
			else {
				SlaveOff[MB_N] &=~((uint32_t)1<<CurrSlave[MB_N]);
    65a2:	eb ed       	ldi	r30, 0xDB	; 219
    65a4:	f8 e0       	ldi	r31, 0x08	; 8
    65a6:	ee 0e       	add	r14, r30
    65a8:	ff 1e       	adc	r15, r31
    65aa:	9e 01       	movw	r18, r28
    65ac:	25 5b       	subi	r18, 0xB5	; 181
    65ae:	39 4f       	sbci	r19, 0xF9	; 249
    65b0:	81 e0       	ldi	r24, 0x01	; 1
    65b2:	90 e0       	ldi	r25, 0x00	; 0
    65b4:	a0 e0       	ldi	r26, 0x00	; 0
    65b6:	b0 e0       	ldi	r27, 0x00	; 0
    65b8:	f9 01       	movw	r30, r18
    65ba:	00 80       	ld	r0, Z
    65bc:	04 c0       	rjmp	.+8      	; 0x65c6 <MB_M_Timer_ISR+0x294>
    65be:	88 0f       	add	r24, r24
    65c0:	99 1f       	adc	r25, r25
    65c2:	aa 1f       	adc	r26, r26
    65c4:	bb 1f       	adc	r27, r27
    65c6:	0a 94       	dec	r0
    65c8:	d2 f7       	brpl	.-12     	; 0x65be <MB_M_Timer_ISR+0x28c>
    65ca:	80 95       	com	r24
    65cc:	90 95       	com	r25
    65ce:	a0 95       	com	r26
    65d0:	b0 95       	com	r27
    65d2:	f7 01       	movw	r30, r14
    65d4:	20 81       	ld	r18, Z
    65d6:	31 81       	ldd	r19, Z+1	; 0x01
    65d8:	42 81       	ldd	r20, Z+2	; 0x02
    65da:	53 81       	ldd	r21, Z+3	; 0x03
    65dc:	82 23       	and	r24, r18
    65de:	93 23       	and	r25, r19
    65e0:	a4 23       	and	r26, r20
    65e2:	b5 23       	and	r27, r21
    65e4:	80 83       	st	Z, r24
    65e6:	91 83       	std	Z+1, r25	; 0x01
    65e8:	a2 83       	std	Z+2, r26	; 0x02
    65ea:	b3 83       	std	Z+3, r27	; 0x03
				if (++CurrQuery[MB_N]==prb(&Slave->QueryQt))
    65ec:	fe 01       	movw	r30, r28
    65ee:	e4 5b       	subi	r30, 0xB4	; 180
    65f0:	f9 4f       	sbci	r31, 0xF9	; 249
    65f2:	80 81       	ld	r24, Z
    65f4:	8f 5f       	subi	r24, 0xFF	; 255
    65f6:	80 83       	st	Z, r24
    65f8:	6d 5f       	subi	r22, 0xFD	; 253
    65fa:	7f 4f       	sbci	r23, 0xFF	; 255
    65fc:	fb 01       	movw	r30, r22
    65fe:	94 91       	lpm	r25, Z+
    6600:	89 17       	cp	r24, r25
    6602:	09 f4       	brne	.+2      	; 0x6606 <MB_M_Timer_ISR+0x2d4>
    6604:	55 c1       	rjmp	.+682    	; 0x68b0 <MB_M_Timer_ISR+0x57e>
    6606:	90 e0       	ldi	r25, 0x00	; 0
					Over = NextSlave(MB_N);
				Try[MB_N] = 0;
    6608:	fe 01       	movw	r30, r28
    660a:	e6 52       	subi	r30, 0x26	; 38
    660c:	fb 4f       	sbci	r31, 0xFB	; 251
    660e:	10 82       	st	Z, r1
    6610:	15 cf       	rjmp	.-470    	; 0x643c <MB_M_Timer_ISR+0x10a>
		}
		if (MB_Frame[MB_N][0]!=Addr || MB_Frame[MB_N][1]!=Func)
			Over = FailSlave(MB_N);
		else {
			uint8_t Err;
			switch (Func) {
    6612:	91 30       	cpi	r25, 0x01	; 1
    6614:	08 f4       	brcc	.+2      	; 0x6618 <MB_M_Timer_ISR+0x2e6>
    6616:	b9 cf       	rjmp	.-142    	; 0x658a <MB_M_Timer_ISR+0x258>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_M_ReadDiscr(uint8_t MB_N, MB_Query *Query)
{
	uint8_t Qt = LastProcSingle ? MB_SingleQuery[MB_N].Qt : prb((uint8_t*)&Query->Qt);
    6618:	80 91 d9 04 	lds	r24, 0x04D9
    661c:	88 23       	and	r24, r24
    661e:	09 f4       	brne	.+2      	; 0x6622 <MB_M_Timer_ISR+0x2f0>
    6620:	eb c0       	rjmp	.+470    	; 0x67f8 <MB_M_Timer_ISR+0x4c6>
    6622:	fe 01       	movw	r30, r28
    6624:	ee 0f       	add	r30, r30
    6626:	ff 1f       	adc	r31, r31
    6628:	ee 0f       	add	r30, r30
    662a:	ff 1f       	adc	r31, r31
    662c:	ee 0f       	add	r30, r30
    662e:	ff 1f       	adc	r31, r31
    6630:	eb 52       	subi	r30, 0x2B	; 43
    6632:	fb 4f       	sbci	r31, 0xFB	; 251
    6634:	b0 81       	ld	r27, Z
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || Qt/8+((Qt%8)>0)!=MB_Frame[MB_N][2])
    6636:	fc 2f       	mov	r31, r28
    6638:	ee 27       	eor	r30, r30
    663a:	e5 5e       	subi	r30, 0xE5	; 229
    663c:	f4 4f       	sbci	r31, 0xF4	; 244
    663e:	80 81       	ld	r24, Z
    6640:	88 2e       	mov	r8, r24
    6642:	99 24       	eor	r9, r9
    6644:	fe 01       	movw	r30, r28
    6646:	e5 50       	subi	r30, 0x05	; 5
    6648:	f9 4f       	sbci	r31, 0xF9	; 249
    664a:	80 81       	ld	r24, Z
    664c:	90 e0       	ldi	r25, 0x00	; 0
    664e:	94 01       	movw	r18, r8
    6650:	2b 5f       	subi	r18, 0xFB	; 251
    6652:	3f 4f       	sbci	r19, 0xFF	; 255
    6654:	82 17       	cp	r24, r18
    6656:	93 07       	cpc	r25, r19
    6658:	09 f0       	breq	.+2      	; 0x665c <MB_M_Timer_ISR+0x32a>
    665a:	41 cf       	rjmp	.-382    	; 0x64de <MB_M_Timer_ISR+0x1ac>
    665c:	20 e0       	ldi	r18, 0x00	; 0
    665e:	30 e0       	ldi	r19, 0x00	; 0
    6660:	6b 2e       	mov	r6, r27
    6662:	77 24       	eor	r7, r7
    6664:	c3 01       	movw	r24, r6
    6666:	87 70       	andi	r24, 0x07	; 7
    6668:	90 70       	andi	r25, 0x00	; 0
    666a:	18 16       	cp	r1, r24
    666c:	19 06       	cpc	r1, r25
    666e:	14 f4       	brge	.+4      	; 0x6674 <MB_M_Timer_ISR+0x342>
    6670:	21 e0       	ldi	r18, 0x01	; 1
    6672:	30 e0       	ldi	r19, 0x00	; 0
    6674:	b6 95       	lsr	r27
    6676:	b6 95       	lsr	r27
    6678:	b6 95       	lsr	r27
    667a:	2b 0f       	add	r18, r27
    667c:	31 1d       	adc	r19, r1
    667e:	82 16       	cp	r8, r18
    6680:	93 06       	cpc	r9, r19
    6682:	09 f0       	breq	.+2      	; 0x6686 <MB_M_Timer_ISR+0x354>
    6684:	2c cf       	rjmp	.-424    	; 0x64de <MB_M_Timer_ISR+0x1ac>
		return 1;
	uint8_t *Discr;
	uint8_t Pin;
	if (LastProcSingle) {
    6686:	80 91 d9 04 	lds	r24, 0x04D9
    668a:	88 23       	and	r24, r24
    668c:	09 f4       	brne	.+2      	; 0x6690 <MB_M_Timer_ISR+0x35e>
    668e:	1d c1       	rjmp	.+570    	; 0x68ca <MB_M_Timer_ISR+0x598>
		Discr = MB_SingleQuery[MB_N].Buf;
    6690:	fe 01       	movw	r30, r28
    6692:	ee 0f       	add	r30, r30
    6694:	ff 1f       	adc	r31, r31
    6696:	ee 0f       	add	r30, r30
    6698:	ff 1f       	adc	r31, r31
    669a:	ee 0f       	add	r30, r30
    669c:	ff 1f       	adc	r31, r31
    669e:	ef 52       	subi	r30, 0x2F	; 47
    66a0:	fb 4f       	sbci	r31, 0xFB	; 251
    66a2:	86 80       	ldd	r8, Z+6	; 0x06
    66a4:	97 80       	ldd	r9, Z+7	; 0x07
    66a6:	00 e0       	ldi	r16, 0x00	; 0
	}
	else {
		Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
		Pin = prw(&Query->AllocAddr);
	}
	for (uint16_t i=0; i<Qt; i++) {
    66a8:	61 14       	cp	r6, r1
    66aa:	71 04       	cpc	r7, r1
    66ac:	09 f4       	brne	.+2      	; 0x66b0 <MB_M_Timer_ISR+0x37e>
    66ae:	6d cf       	rjmp	.-294    	; 0x658a <MB_M_Timer_ISR+0x258>
    66b0:	40 e0       	ldi	r20, 0x00	; 0
    66b2:	50 e0       	ldi	r21, 0x00	; 0
		uint8_t j = Pin+i;
		uint8_t Byte=j/8, Bit=1<<j%8;
    66b4:	21 e0       	ldi	r18, 0x01	; 1
    66b6:	42 2e       	mov	r4, r18
    66b8:	51 2c       	mov	r5, r1
		if (MB_Frame[MB_N][3+i/8] &(1<<i%8))
    66ba:	89 e1       	ldi	r24, 0x19	; 25
    66bc:	9b e0       	ldi	r25, 0x0B	; 11
    66be:	c8 0e       	add	r12, r24
    66c0:	d9 1e       	adc	r13, r25
    66c2:	0c c0       	rjmp	.+24     	; 0x66dc <MB_M_Timer_ISR+0x3aa>
			Discr[Byte] |=Bit;
    66c4:	f4 01       	movw	r30, r8
    66c6:	eb 0f       	add	r30, r27
    66c8:	f1 1d       	adc	r31, r1
    66ca:	80 81       	ld	r24, Z
    66cc:	8a 2b       	or	r24, r26
    66ce:	80 83       	st	Z, r24
	}
	else {
		Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
		Pin = prw(&Query->AllocAddr);
	}
	for (uint16_t i=0; i<Qt; i++) {
    66d0:	4f 5f       	subi	r20, 0xFF	; 255
    66d2:	5f 4f       	sbci	r21, 0xFF	; 255
    66d4:	46 15       	cp	r20, r6
    66d6:	57 05       	cpc	r21, r7
    66d8:	08 f0       	brcs	.+2      	; 0x66dc <MB_M_Timer_ISR+0x3aa>
    66da:	57 cf       	rjmp	.-338    	; 0x658a <MB_M_Timer_ISR+0x258>
    66dc:	80 2f       	mov	r24, r16
    66de:	84 0f       	add	r24, r20
		uint8_t j = Pin+i;
		uint8_t Byte=j/8, Bit=1<<j%8;
    66e0:	b8 2f       	mov	r27, r24
    66e2:	b6 95       	lsr	r27
    66e4:	b6 95       	lsr	r27
    66e6:	b6 95       	lsr	r27
    66e8:	87 70       	andi	r24, 0x07	; 7
    66ea:	a4 2d       	mov	r26, r4
    66ec:	01 c0       	rjmp	.+2      	; 0x66f0 <MB_M_Timer_ISR+0x3be>
    66ee:	aa 0f       	add	r26, r26
    66f0:	8a 95       	dec	r24
    66f2:	ea f7       	brpl	.-6      	; 0x66ee <MB_M_Timer_ISR+0x3bc>
		if (MB_Frame[MB_N][3+i/8] &(1<<i%8))
    66f4:	fa 01       	movw	r30, r20
    66f6:	f6 95       	lsr	r31
    66f8:	e7 95       	ror	r30
    66fa:	f6 95       	lsr	r31
    66fc:	e7 95       	ror	r30
    66fe:	f6 95       	lsr	r31
    6700:	e7 95       	ror	r30
    6702:	ec 0d       	add	r30, r12
    6704:	fd 1d       	adc	r31, r13
    6706:	83 81       	ldd	r24, Z+3	; 0x03
    6708:	90 e0       	ldi	r25, 0x00	; 0
    670a:	9a 01       	movw	r18, r20
    670c:	27 70       	andi	r18, 0x07	; 7
    670e:	30 70       	andi	r19, 0x00	; 0
    6710:	02 c0       	rjmp	.+4      	; 0x6716 <MB_M_Timer_ISR+0x3e4>
    6712:	95 95       	asr	r25
    6714:	87 95       	ror	r24
    6716:	2a 95       	dec	r18
    6718:	e2 f7       	brpl	.-8      	; 0x6712 <MB_M_Timer_ISR+0x3e0>
    671a:	80 fd       	sbrc	r24, 0
    671c:	d3 cf       	rjmp	.-90     	; 0x66c4 <MB_M_Timer_ISR+0x392>
			Discr[Byte] |=Bit;
		else
			Discr[Byte] &=~Bit;
    671e:	f4 01       	movw	r30, r8
    6720:	eb 0f       	add	r30, r27
    6722:	f1 1d       	adc	r31, r1
    6724:	a0 95       	com	r26
    6726:	80 81       	ld	r24, Z
    6728:	8a 23       	and	r24, r26
    672a:	80 83       	st	Z, r24
    672c:	d1 cf       	rjmp	.-94     	; 0x66d0 <MB_M_Timer_ISR+0x39e>
inline static uint8_t
MB_M_PresetSingle(uint8_t MB_N, MB_Query *Query)
{
	uint16_t StartAddr;
	uint16_t *Reg;
	if (LastProcSingle) {
    672e:	80 91 d9 04 	lds	r24, 0x04D9
    6732:	88 23       	and	r24, r24
    6734:	09 f4       	brne	.+2      	; 0x6738 <MB_M_Timer_ISR+0x406>
    6736:	46 c0       	rjmp	.+140    	; 0x67c4 <MB_M_Timer_ISR+0x492>
		StartAddr = MB_SingleQuery[MB_N].StartAddr;
    6738:	f7 01       	movw	r30, r14
    673a:	ee 0f       	add	r30, r30
    673c:	ff 1f       	adc	r31, r31
    673e:	ed 52       	subi	r30, 0x2D	; 45
    6740:	fb 4f       	sbci	r31, 0xFB	; 251
    6742:	80 80       	ld	r8, Z
    6744:	91 80       	ldd	r9, Z+1	; 0x01
		Reg = MB_SingleQuery[MB_N].Buf;
    6746:	fe 01       	movw	r30, r28
    6748:	ee 0f       	add	r30, r30
    674a:	ff 1f       	adc	r31, r31
    674c:	ee 0f       	add	r30, r30
    674e:	ff 1f       	adc	r31, r31
    6750:	ee 0f       	add	r30, r30
    6752:	ff 1f       	adc	r31, r31
    6754:	ef 52       	subi	r30, 0x2F	; 47
    6756:	fb 4f       	sbci	r31, 0xFB	; 251
    6758:	a6 81       	ldd	r26, Z+6	; 0x06
    675a:	b7 81       	ldd	r27, Z+7	; 0x07
	}
	else {
		StartAddr = prw(&Query->StartAddr);
		Reg = (uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+prw(&Query->AllocAddr);
	}
	return MB_Frame_Sz[MB_N]!=8 || MB_FrameReg(MB_N, 2)!=StartAddr || MB_FrameReg(MB_N, 4)!=*Reg;
    675c:	fe 01       	movw	r30, r28
    675e:	e5 50       	subi	r30, 0x05	; 5
    6760:	f9 4f       	sbci	r31, 0xF9	; 249
    6762:	80 81       	ld	r24, Z
    6764:	88 30       	cpi	r24, 0x08	; 8
    6766:	09 f0       	breq	.+2      	; 0x676a <MB_M_Timer_ISR+0x438>
    6768:	ba ce       	rjmp	.-652    	; 0x64de <MB_M_Timer_ISR+0x1ac>
    676a:	fc 2f       	mov	r31, r28
    676c:	ee 27       	eor	r30, r30
    676e:	e5 5e       	subi	r30, 0xE5	; 229
    6770:	f4 4f       	sbci	r31, 0xF4	; 244
    6772:	30 81       	ld	r19, Z
    6774:	20 e0       	ldi	r18, 0x00	; 0
    6776:	a6 01       	movw	r20, r12
    6778:	47 5e       	subi	r20, 0xE7	; 231
    677a:	54 4f       	sbci	r21, 0xF4	; 244
    677c:	fa 01       	movw	r30, r20
    677e:	83 81       	ldd	r24, Z+3	; 0x03
    6780:	90 e0       	ldi	r25, 0x00	; 0
    6782:	28 2b       	or	r18, r24
    6784:	39 2b       	or	r19, r25
    6786:	28 15       	cp	r18, r8
    6788:	39 05       	cpc	r19, r9
    678a:	09 f0       	breq	.+2      	; 0x678e <MB_M_Timer_ISR+0x45c>
    678c:	a8 ce       	rjmp	.-688    	; 0x64de <MB_M_Timer_ISR+0x1ac>
    678e:	fc 2f       	mov	r31, r28
    6790:	ee 27       	eor	r30, r30
    6792:	e3 5e       	subi	r30, 0xE3	; 227
    6794:	f4 4f       	sbci	r31, 0xF4	; 244
    6796:	30 81       	ld	r19, Z
    6798:	20 e0       	ldi	r18, 0x00	; 0
    679a:	fa 01       	movw	r30, r20
    679c:	85 81       	ldd	r24, Z+5	; 0x05
    679e:	90 e0       	ldi	r25, 0x00	; 0
    67a0:	28 2b       	or	r18, r24
    67a2:	39 2b       	or	r19, r25
    67a4:	8d 91       	ld	r24, X+
    67a6:	9c 91       	ld	r25, X
    67a8:	28 17       	cp	r18, r24
    67aa:	39 07       	cpc	r19, r25
    67ac:	09 f0       	breq	.+2      	; 0x67b0 <MB_M_Timer_ISR+0x47e>
    67ae:	97 ce       	rjmp	.-722    	; 0x64de <MB_M_Timer_ISR+0x1ac>
    67b0:	ec ce       	rjmp	.-552    	; 0x658a <MB_M_Timer_ISR+0x258>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    67b2:	fa 01       	movw	r30, r20
    67b4:	31 96       	adiw	r30, 0x01	; 1
    67b6:	85 90       	lpm	r8, Z+
    67b8:	94 90       	lpm	r9, Z+

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    67ba:	fa 01       	movw	r30, r20
    67bc:	33 96       	adiw	r30, 0x03	; 3
    67be:	45 91       	lpm	r20, Z+
    67c0:	54 91       	lpm	r21, Z+
    67c2:	bb ce       	rjmp	.-650    	; 0x653a <MB_M_Timer_ISR+0x208>
    67c4:	fa 01       	movw	r30, r20
    67c6:	31 96       	adiw	r30, 0x01	; 1
    67c8:	85 90       	lpm	r8, Z+
    67ca:	94 90       	lpm	r9, Z+
    67cc:	fe 01       	movw	r30, r28
    67ce:	ee 0f       	add	r30, r30
    67d0:	ff 1f       	adc	r31, r31
    67d2:	ee 0f       	add	r30, r30
    67d4:	ff 1f       	adc	r31, r31
    67d6:	ee 0f       	add	r30, r30
    67d8:	ff 1f       	adc	r31, r31
    67da:	ee 0f       	add	r30, r30
    67dc:	ff 1f       	adc	r31, r31
    67de:	e6 5f       	subi	r30, 0xF6	; 246
    67e0:	fc 4f       	sbci	r31, 0xFC	; 252
    67e2:	a5 91       	lpm	r26, Z+
    67e4:	b4 91       	lpm	r27, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    67e6:	fa 01       	movw	r30, r20
    67e8:	35 96       	adiw	r30, 0x05	; 5
    67ea:	85 91       	lpm	r24, Z+
    67ec:	94 91       	lpm	r25, Z+
		StartAddr = MB_SingleQuery[MB_N].StartAddr;
		Reg = MB_SingleQuery[MB_N].Buf;
	}
	else {
		StartAddr = prw(&Query->StartAddr);
		Reg = (uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+prw(&Query->AllocAddr);
    67ee:	88 0f       	add	r24, r24
    67f0:	99 1f       	adc	r25, r25
    67f2:	a8 0f       	add	r26, r24
    67f4:	b9 1f       	adc	r27, r25
    67f6:	b2 cf       	rjmp	.-156    	; 0x675c <MB_M_Timer_ISR+0x42a>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    67f8:	4d 5f       	subi	r20, 0xFD	; 253
    67fa:	5f 4f       	sbci	r21, 0xFF	; 255
    67fc:	fa 01       	movw	r30, r20
    67fe:	b4 91       	lpm	r27, Z+
    6800:	43 50       	subi	r20, 0x03	; 3
    6802:	50 40       	sbci	r21, 0x00	; 0
    6804:	18 cf       	rjmp	.-464    	; 0x6636 <MB_M_Timer_ISR+0x304>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_M_ReadReg(uint8_t MB_N, MB_Query *Query)
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || (LastProcSingle?MB_SingleQuery[MB_N].Qt:prw(&Query->Qt))*2!=MB_Frame[MB_N][2])
    6806:	80 91 d9 04 	lds	r24, 0x04D9
    680a:	88 23       	and	r24, r24
    680c:	09 f4       	brne	.+2      	; 0x6810 <MB_M_Timer_ISR+0x4de>
    680e:	55 c0       	rjmp	.+170    	; 0x68ba <MB_M_Timer_ISR+0x588>
    6810:	fe 01       	movw	r30, r28
    6812:	ee 0f       	add	r30, r30
    6814:	ff 1f       	adc	r31, r31
    6816:	ee 0f       	add	r30, r30
    6818:	ff 1f       	adc	r31, r31
    681a:	ee 0f       	add	r30, r30
    681c:	ff 1f       	adc	r31, r31
    681e:	eb 52       	subi	r30, 0x2B	; 43
    6820:	fb 4f       	sbci	r31, 0xFB	; 251
    6822:	20 81       	ld	r18, Z
    6824:	31 81       	ldd	r19, Z+1	; 0x01
    6826:	22 0f       	add	r18, r18
    6828:	33 1f       	adc	r19, r19
    682a:	82 16       	cp	r8, r18
    682c:	93 06       	cpc	r9, r19
    682e:	09 f0       	breq	.+2      	; 0x6832 <MB_M_Timer_ISR+0x500>
    6830:	56 ce       	rjmp	.-852    	; 0x64de <MB_M_Timer_ISR+0x1ac>
		return 1;
	uint16_t *Reg = LastProcSingle ?
		MB_SingleQuery[MB_N].Buf
	:
		(uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg))+prw(&Query->AllocAddr);
    6832:	80 91 d9 04 	lds	r24, 0x04D9
    6836:	88 23       	and	r24, r24
    6838:	09 f4       	brne	.+2      	; 0x683c <MB_M_Timer_ISR+0x50a>
    683a:	5e c0       	rjmp	.+188    	; 0x68f8 <MB_M_Timer_ISR+0x5c6>
    683c:	fe 01       	movw	r30, r28
    683e:	ee 0f       	add	r30, r30
    6840:	ff 1f       	adc	r31, r31
    6842:	ee 0f       	add	r30, r30
    6844:	ff 1f       	adc	r31, r31
    6846:	ee 0f       	add	r30, r30
    6848:	ff 1f       	adc	r31, r31
    684a:	ef 52       	subi	r30, 0x2F	; 47
    684c:	fb 4f       	sbci	r31, 0xFB	; 251
    684e:	26 81       	ldd	r18, Z+6	; 0x06
    6850:	37 81       	ldd	r19, Z+7	; 0x07
	for (int8_t j=MB_Frame[MB_N][2]/2-1; j>=0; j--) {
    6852:	4b 2f       	mov	r20, r27
    6854:	46 95       	lsr	r20
    6856:	41 50       	subi	r20, 0x01	; 1
    6858:	47 fd       	sbrc	r20, 7
    685a:	97 ce       	rjmp	.-722    	; 0x658a <MB_M_Timer_ISR+0x258>
    685c:	84 2f       	mov	r24, r20
    685e:	99 27       	eor	r25, r25
    6860:	87 fd       	sbrc	r24, 7
    6862:	90 95       	com	r25
    6864:	88 0f       	add	r24, r24
    6866:	99 1f       	adc	r25, r25
    6868:	58 2f       	mov	r21, r24
    686a:	5d 5f       	subi	r21, 0xFD	; 253
    686c:	28 0f       	add	r18, r24
    686e:	39 1f       	adc	r19, r25
		int8_t i = j*2;
		Reg[j] = MB_FrameReg(MB_N, 3+i);
    6870:	89 e1       	ldi	r24, 0x19	; 25
    6872:	88 2e       	mov	r8, r24
    6874:	8b e0       	ldi	r24, 0x0B	; 11
    6876:	98 2e       	mov	r9, r24
    6878:	8c 0c       	add	r8, r12
    687a:	9d 1c       	adc	r9, r13
    687c:	e5 2f       	mov	r30, r21
    687e:	f0 e0       	ldi	r31, 0x00	; 0
    6880:	d4 01       	movw	r26, r8
    6882:	ae 0f       	add	r26, r30
    6884:	bf 1f       	adc	r27, r31
    6886:	11 96       	adiw	r26, 0x01	; 1
    6888:	8c 91       	ld	r24, X
    688a:	90 e0       	ldi	r25, 0x00	; 0
    688c:	ec 0d       	add	r30, r12
    688e:	fd 1d       	adc	r31, r13
    6890:	e7 5e       	subi	r30, 0xE7	; 231
    6892:	f4 4f       	sbci	r31, 0xF4	; 244
    6894:	f0 81       	ld	r31, Z
    6896:	e0 e0       	ldi	r30, 0x00	; 0
    6898:	8e 2b       	or	r24, r30
    689a:	9f 2b       	or	r25, r31
    689c:	d9 01       	movw	r26, r18
    689e:	8d 93       	st	X+, r24
    68a0:	9c 93       	st	X, r25
		return 1;
	uint16_t *Reg = LastProcSingle ?
		MB_SingleQuery[MB_N].Buf
	:
		(uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg))+prw(&Query->AllocAddr);
	for (int8_t j=MB_Frame[MB_N][2]/2-1; j>=0; j--) {
    68a2:	41 50       	subi	r20, 0x01	; 1
    68a4:	52 50       	subi	r21, 0x02	; 2
    68a6:	22 50       	subi	r18, 0x02	; 2
    68a8:	30 40       	sbci	r19, 0x00	; 0
    68aa:	47 ff       	sbrs	r20, 7
    68ac:	e7 cf       	rjmp	.-50     	; 0x687c <MB_M_Timer_ISR+0x54a>
    68ae:	6d ce       	rjmp	.-806    	; 0x658a <MB_M_Timer_ISR+0x258>
			else if (LastProcSingle)
				MB_SingleState[MB_N] = MB_SingleIdle;
			else {
				SlaveOff[MB_N] &=~((uint32_t)1<<CurrSlave[MB_N]);
				if (++CurrQuery[MB_N]==prb(&Slave->QueryQt))
					Over = NextSlave(MB_N);
    68b0:	81 2f       	mov	r24, r17
    68b2:	0e 94 50 30 	call	0x60a0	; 0x60a0 <NextSlave>
    68b6:	98 2f       	mov	r25, r24
    68b8:	a7 ce       	rjmp	.-690    	; 0x6608 <MB_M_Timer_ISR+0x2d6>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    68ba:	ca 01       	movw	r24, r20
    68bc:	03 96       	adiw	r24, 0x03	; 3
    68be:	fc 01       	movw	r30, r24
    68c0:	25 91       	lpm	r18, Z+
    68c2:	34 91       	lpm	r19, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_M_ReadReg(uint8_t MB_N, MB_Query *Query)
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || (LastProcSingle?MB_SingleQuery[MB_N].Qt:prw(&Query->Qt))*2!=MB_Frame[MB_N][2])
    68c4:	22 0f       	add	r18, r18
    68c6:	33 1f       	adc	r19, r19
    68c8:	b0 cf       	rjmp	.-160    	; 0x682a <MB_M_Timer_ISR+0x4f8>
	if (LastProcSingle) {
		Discr = MB_SingleQuery[MB_N].Buf;
		Pin = 0;
	}
	else {
		Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
    68ca:	a1 30       	cpi	r26, 0x01	; 1
    68cc:	59 f1       	breq	.+86     	; 0x6924 <MB_M_Timer_ISR+0x5f2>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    68ce:	f7 01       	movw	r30, r14
    68d0:	ee 0f       	add	r30, r30
    68d2:	ff 1f       	adc	r31, r31
    68d4:	ee 0f       	add	r30, r30
    68d6:	ff 1f       	adc	r31, r31
    68d8:	ea 5f       	subi	r30, 0xFA	; 250
    68da:	fc 4f       	sbci	r31, 0xFC	; 252
    68dc:	85 91       	lpm	r24, Z+
    68de:	94 91       	lpm	r25, Z+
    68e0:	e8 2f       	mov	r30, r24
    68e2:	89 2f       	mov	r24, r25
    68e4:	2e 2f       	mov	r18, r30
    68e6:	38 2f       	mov	r19, r24
    68e8:	c9 01       	movw	r24, r18
    68ea:	4c 01       	movw	r8, r24

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    68ec:	fa 01       	movw	r30, r20
    68ee:	35 96       	adiw	r30, 0x05	; 5
    68f0:	85 91       	lpm	r24, Z+
    68f2:	94 91       	lpm	r25, Z+
		Pin = prw(&Query->AllocAddr);
    68f4:	08 2f       	mov	r16, r24
    68f6:	d8 ce       	rjmp	.-592    	; 0x66a8 <MB_M_Timer_ISR+0x376>
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || (LastProcSingle?MB_SingleQuery[MB_N].Qt:prw(&Query->Qt))*2!=MB_Frame[MB_N][2])
		return 1;
	uint16_t *Reg = LastProcSingle ?
		MB_SingleQuery[MB_N].Buf
	:
		(uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg))+prw(&Query->AllocAddr);
    68f8:	a3 30       	cpi	r26, 0x03	; 3
    68fa:	11 f1       	breq	.+68     	; 0x6940 <MB_M_Timer_ISR+0x60e>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    68fc:	fe 01       	movw	r30, r28
    68fe:	e2 95       	swap	r30
    6900:	f2 95       	swap	r31
    6902:	f0 7f       	andi	r31, 0xF0	; 240
    6904:	fe 27       	eor	r31, r30
    6906:	e0 7f       	andi	r30, 0xF0	; 240
    6908:	fe 27       	eor	r31, r30
    690a:	e2 5f       	subi	r30, 0xF2	; 242
    690c:	fc 4f       	sbci	r31, 0xFC	; 252
    690e:	85 91       	lpm	r24, Z+
    6910:	94 91       	lpm	r25, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    6912:	fa 01       	movw	r30, r20
    6914:	35 96       	adiw	r30, 0x05	; 5
    6916:	25 91       	lpm	r18, Z+
    6918:	34 91       	lpm	r19, Z+
    691a:	22 0f       	add	r18, r18
    691c:	33 1f       	adc	r19, r19
    691e:	28 0f       	add	r18, r24
    6920:	39 1f       	adc	r19, r25
    6922:	97 cf       	rjmp	.-210    	; 0x6852 <MB_M_Timer_ISR+0x520>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6924:	fe 01       	movw	r30, r28
    6926:	e2 95       	swap	r30
    6928:	f2 95       	swap	r31
    692a:	f0 7f       	andi	r31, 0xF0	; 240
    692c:	fe 27       	eor	r31, r30
    692e:	e0 7f       	andi	r30, 0xF0	; 240
    6930:	fe 27       	eor	r31, r30
    6932:	ee 5f       	subi	r30, 0xFE	; 254
    6934:	fc 4f       	sbci	r31, 0xFC	; 252
    6936:	85 91       	lpm	r24, Z+
    6938:	94 91       	lpm	r25, Z+
    693a:	e8 2f       	mov	r30, r24
    693c:	89 2f       	mov	r24, r25
    693e:	d2 cf       	rjmp	.-92     	; 0x68e4 <MB_M_Timer_ISR+0x5b2>

// ~~~~~~~~~~~~~~~~~~
void
MB_M_Tx(uint8_t MB_N)
{
	StartTimer16(TD_MB_Idle+MB_N, MB_M_Timeout[MB_N]);
    6940:	fe 01       	movw	r30, r28
    6942:	ee 0f       	add	r30, r30
    6944:	ff 1f       	adc	r31, r31
    6946:	ee 0f       	add	r30, r30
    6948:	ff 1f       	adc	r31, r31
    694a:	ee 0f       	add	r30, r30
    694c:	ff 1f       	adc	r31, r31
    694e:	ee 0f       	add	r30, r30
    6950:	ff 1f       	adc	r31, r31
    6952:	e6 5f       	subi	r30, 0xF6	; 246
    6954:	fc 4f       	sbci	r31, 0xFC	; 252
    6956:	85 91       	lpm	r24, Z+
    6958:	94 91       	lpm	r25, Z+
    695a:	db cf       	rjmp	.-74     	; 0x6912 <MB_M_Timer_ISR+0x5e0>

0000695c <MB_M_Tx>:
    695c:	90 91 df 04 	lds	r25, 0x04DF
    6960:	e7 ed       	ldi	r30, 0xD7	; 215
    6962:	f8 e0       	ldi	r31, 0x08	; 8
    6964:	e8 0f       	add	r30, r24
    6966:	f1 1d       	adc	r31, r1
    6968:	60 81       	ld	r22, Z
    696a:	89 0f       	add	r24, r25
    696c:	70 e0       	ldi	r23, 0x00	; 0
    696e:	0e 94 05 1a 	call	0x340a	; 0x340a <StartTimer16>
}
    6972:	08 95       	ret

00006974 <Modbus_TX>:
}

// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_TX(usart_t *usart)
{
    6974:	cf 92       	push	r12
    6976:	df 92       	push	r13
    6978:	ef 92       	push	r14
    697a:	ff 92       	push	r15
    697c:	1f 93       	push	r17
    697e:	cf 93       	push	r28
    6980:	df 93       	push	r29
    6982:	dc 01       	movw	r26, r24
    6984:	e2 ee       	ldi	r30, 0xE2	; 226
    6986:	fb e2       	ldi	r31, 0x2B	; 43
    6988:	85 91       	lpm	r24, Z+
    698a:	94 91       	lpm	r25, Z+
// ~~~~~~~~~~~~~~~~~~~~~~
static uint8_t
MB_Port_N(usart_t *usart)
{
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Port[MB_N].usart_field)!=usart; MB_N++);
    698c:	a8 17       	cp	r26, r24
    698e:	b9 07       	cpc	r27, r25
    6990:	09 f4       	brne	.+2      	; 0x6994 <Modbus_TX+0x20>
    6992:	c0 c0       	rjmp	.+384    	; 0x6b14 <Modbus_TX+0x1a0>
    6994:	10 e0       	ldi	r17, 0x00	; 0
    6996:	1f 5f       	subi	r17, 0xFF	; 255
    6998:	c1 2f       	mov	r28, r17
    699a:	d0 e0       	ldi	r29, 0x00	; 0
    699c:	ce 01       	movw	r24, r28
    699e:	88 0f       	add	r24, r24
    69a0:	99 1f       	adc	r25, r25
    69a2:	88 0f       	add	r24, r24
    69a4:	99 1f       	adc	r25, r25
    69a6:	fc 01       	movw	r30, r24
    69a8:	ee 0f       	add	r30, r30
    69aa:	ff 1f       	adc	r31, r31
    69ac:	ee 0f       	add	r30, r30
    69ae:	ff 1f       	adc	r31, r31
    69b0:	e8 0f       	add	r30, r24
    69b2:	f9 1f       	adc	r31, r25
    69b4:	ee 51       	subi	r30, 0x1E	; 30
    69b6:	f4 4d       	sbci	r31, 0xD4	; 212
    69b8:	85 91       	lpm	r24, Z+
    69ba:	94 91       	lpm	r25, Z+
    69bc:	a8 17       	cp	r26, r24
    69be:	b9 07       	cpc	r27, r25
    69c0:	51 f7       	brne	.-44     	; 0x6996 <Modbus_TX+0x22>
void
Modbus_TX(usart_t *usart)
{
	uint8_t MB_N = MB_Port_N(usart);
	static uint8_t Count[Modbus_Qt];
	if (Count[MB_N] == MB_Frame_Sz[MB_N]-2){
    69c2:	2d ed       	ldi	r18, 0xDD	; 221
    69c4:	c2 2e       	mov	r12, r18
    69c6:	22 e0       	ldi	r18, 0x02	; 2
    69c8:	d2 2e       	mov	r13, r18
    69ca:	cc 0e       	add	r12, r28
    69cc:	dd 1e       	adc	r13, r29
    69ce:	f6 01       	movw	r30, r12
    69d0:	50 81       	ld	r21, Z
    69d2:	be 01       	movw	r22, r28
    69d4:	65 50       	subi	r22, 0x05	; 5
    69d6:	79 4f       	sbci	r23, 0xF9	; 249
    69d8:	fb 01       	movw	r30, r22
    69da:	40 81       	ld	r20, Z
    69dc:	25 2f       	mov	r18, r21
    69de:	30 e0       	ldi	r19, 0x00	; 0
    69e0:	84 2f       	mov	r24, r20
    69e2:	90 e0       	ldi	r25, 0x00	; 0
    69e4:	02 97       	sbiw	r24, 0x02	; 2
    69e6:	28 17       	cp	r18, r24
    69e8:	39 07       	cpc	r19, r25
    69ea:	09 f4       	brne	.+2      	; 0x69ee <Modbus_TX+0x7a>
    69ec:	55 c0       	rjmp	.+170    	; 0x6a98 <Modbus_TX+0x124>
		USART_Reg(MB_N, ucsrb) &=~(1<<5);
		USART_Reg(MB_N, ucsrb) |=(1<<6);
		USART_Reg(MB_N, ucsra) |=(1<<6);	//Clear TxC pending interrupt		
	}
	if (++Count[MB_N]<MB_Frame_Sz[MB_N]) {
    69ee:	25 2f       	mov	r18, r21
    69f0:	2f 5f       	subi	r18, 0xFF	; 255
    69f2:	f6 01       	movw	r30, r12
    69f4:	20 83       	st	Z, r18
    69f6:	24 17       	cp	r18, r20
    69f8:	80 f4       	brcc	.+32     	; 0x6a1a <Modbus_TX+0xa6>
		usart_data(usart) = MB_Frame[MB_N][Count[MB_N]];
    69fa:	fc 2f       	mov	r31, r28
    69fc:	ee 27       	eor	r30, r30
    69fe:	e2 0f       	add	r30, r18
    6a00:	f1 1d       	adc	r31, r1
    6a02:	e7 5e       	subi	r30, 0xE7	; 231
    6a04:	f4 4f       	sbci	r31, 0xF4	; 244
    6a06:	80 81       	ld	r24, Z
    6a08:	8c 93       	st	X, r24
		break;
	case Role_Master:
		MB_M_Tx(MB_N);
		break;
	}
}
    6a0a:	df 91       	pop	r29
    6a0c:	cf 91       	pop	r28
    6a0e:	1f 91       	pop	r17
    6a10:	ff 90       	pop	r15
    6a12:	ef 90       	pop	r14
    6a14:	df 90       	pop	r13
    6a16:	cf 90       	pop	r12
    6a18:	08 95       	ret
    6a1a:	9e 01       	movw	r18, r28
    6a1c:	22 0f       	add	r18, r18
    6a1e:	33 1f       	adc	r19, r19
    6a20:	22 0f       	add	r18, r18
    6a22:	33 1f       	adc	r19, r19
    6a24:	c9 01       	movw	r24, r18
    6a26:	8c 0f       	add	r24, r28
    6a28:	9d 1f       	adc	r25, r29
    6a2a:	88 0f       	add	r24, r24
    6a2c:	99 1f       	adc	r25, r25
    6a2e:	88 0f       	add	r24, r24
    6a30:	99 1f       	adc	r25, r25
    6a32:	8a 51       	subi	r24, 0x1A	; 26
    6a34:	94 4d       	sbci	r25, 0xD4	; 212
    6a36:	fc 01       	movw	r30, r24
    6a38:	a5 91       	lpm	r26, Z+
    6a3a:	b4 91       	lpm	r27, Z+
	}

	void MB_S_Tx(uint8_t);
	void MB_M_Tx(uint8_t);
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		USART_Reg(MB_N, ucsrb) &=~((1<<6)|(1<<5)); 	// .  USART Data Register Empty Interrupt
    6a3c:	8c 91       	ld	r24, X
    6a3e:	8f 79       	andi	r24, 0x9F	; 159
    6a40:	8c 93       	st	X, r24
    6a42:	79 01       	movw	r14, r18
    6a44:	ee 0c       	add	r14, r14
    6a46:	ff 1c       	adc	r15, r15
    6a48:	ee 0c       	add	r14, r14
    6a4a:	ff 1c       	adc	r15, r15
    6a4c:	e2 0e       	add	r14, r18
    6a4e:	f3 1e       	adc	r15, r19
    6a50:	c7 01       	movw	r24, r14
    6a52:	82 51       	subi	r24, 0x12	; 18
    6a54:	94 4d       	sbci	r25, 0xD4	; 212
    6a56:	fc 01       	movw	r30, r24
    6a58:	25 91       	lpm	r18, Z+
    6a5a:	34 91       	lpm	r19, Z+
	#elif defined (__AVR_ATxmega128A1__)
		usart->CTRLA = (usart->CTRLA &~USART_TXCINTLVL_gm) |USART_TXCINTLVL_OFF_gc;
	#endif
	USART_Func(MB_N, RS485);
    6a5c:	f9 01       	movw	r30, r18
    6a5e:	19 95       	eicall
	Count[MB_N] = 0;
    6a60:	f6 01       	movw	r30, r12
    6a62:	10 82       	st	Z, r1
	//StartTime3_5();
	MB_State[MB_N] = MB_Idle;
    6a64:	c7 54       	subi	r28, 0x47	; 71
    6a66:	da 4f       	sbci	r29, 0xFA	; 250
    6a68:	81 e0       	ldi	r24, 0x01	; 1
    6a6a:	88 83       	st	Y, r24

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    6a6c:	e1 2f       	mov	r30, r17
    6a6e:	f0 e0       	ldi	r31, 0x00	; 0
    6a70:	ea 50       	subi	r30, 0x0A	; 10
    6a72:	f4 4d       	sbci	r31, 0xD4	; 212
    6a74:	84 91       	lpm	r24, Z+
	switch (prb(MB_Role+MB_N)) {
    6a76:	88 23       	and	r24, r24
    6a78:	09 f4       	brne	.+2      	; 0x6a7c <Modbus_TX+0x108>
    6a7a:	3c c0       	rjmp	.+120    	; 0x6af4 <Modbus_TX+0x180>
    6a7c:	81 30       	cpi	r24, 0x01	; 1
    6a7e:	09 f0       	breq	.+2      	; 0x6a82 <Modbus_TX+0x10e>
    6a80:	c4 cf       	rjmp	.-120    	; 0x6a0a <Modbus_TX+0x96>
	case Role_Slave:
		MB_S_Tx(MB_N);
		break;
	case Role_Master:
		MB_M_Tx(MB_N);
    6a82:	81 2f       	mov	r24, r17
    6a84:	0e 94 ae 34 	call	0x695c	; 0x695c <MB_M_Tx>
		break;
	}
}
    6a88:	df 91       	pop	r29
    6a8a:	cf 91       	pop	r28
    6a8c:	1f 91       	pop	r17
    6a8e:	ff 90       	pop	r15
    6a90:	ef 90       	pop	r14
    6a92:	df 90       	pop	r13
    6a94:	cf 90       	pop	r12
    6a96:	08 95       	ret

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6a98:	fe 01       	movw	r30, r28
    6a9a:	ee 0f       	add	r30, r30
    6a9c:	ff 1f       	adc	r31, r31
    6a9e:	ee 0f       	add	r30, r30
    6aa0:	ff 1f       	adc	r31, r31
    6aa2:	ec 0f       	add	r30, r28
    6aa4:	fd 1f       	adc	r31, r29
    6aa6:	ee 0f       	add	r30, r30
    6aa8:	ff 1f       	adc	r31, r31
    6aaa:	ee 0f       	add	r30, r30
    6aac:	ff 1f       	adc	r31, r31
    6aae:	ea 51       	subi	r30, 0x1A	; 26
    6ab0:	f4 4d       	sbci	r31, 0xD4	; 212
    6ab2:	25 91       	lpm	r18, Z+
    6ab4:	34 91       	lpm	r19, Z+
Modbus_TX(usart_t *usart)
{
	uint8_t MB_N = MB_Port_N(usart);
	static uint8_t Count[Modbus_Qt];
	if (Count[MB_N] == MB_Frame_Sz[MB_N]-2){
		USART_Reg(MB_N, ucsrb) &=~(1<<5);
    6ab6:	f9 01       	movw	r30, r18
    6ab8:	80 81       	ld	r24, Z
    6aba:	8f 7d       	andi	r24, 0xDF	; 223
		USART_Reg(MB_N, ucsrb) |=(1<<6);
    6abc:	80 64       	ori	r24, 0x40	; 64
    6abe:	80 83       	st	Z, r24
    6ac0:	9e 01       	movw	r18, r28
    6ac2:	22 0f       	add	r18, r18
    6ac4:	33 1f       	adc	r19, r19
    6ac6:	ce 01       	movw	r24, r28
    6ac8:	88 0f       	add	r24, r24
    6aca:	99 1f       	adc	r25, r25
    6acc:	88 0f       	add	r24, r24
    6ace:	99 1f       	adc	r25, r25
    6ad0:	88 0f       	add	r24, r24
    6ad2:	99 1f       	adc	r25, r25
    6ad4:	28 0f       	add	r18, r24
    6ad6:	39 1f       	adc	r19, r25
    6ad8:	22 0f       	add	r18, r18
    6ada:	33 1f       	adc	r19, r19
    6adc:	2c 51       	subi	r18, 0x1C	; 28
    6ade:	34 4d       	sbci	r19, 0xD4	; 212
    6ae0:	f9 01       	movw	r30, r18
    6ae2:	e5 90       	lpm	r14, Z+
    6ae4:	f4 90       	lpm	r15, Z+
		USART_Reg(MB_N, ucsra) |=(1<<6);	//Clear TxC pending interrupt		
    6ae6:	f7 01       	movw	r30, r14
    6ae8:	80 81       	ld	r24, Z
    6aea:	80 64       	ori	r24, 0x40	; 64
    6aec:	80 83       	st	Z, r24
    6aee:	fb 01       	movw	r30, r22
    6af0:	40 81       	ld	r20, Z
    6af2:	7d cf       	rjmp	.-262    	; 0x69ee <Modbus_TX+0x7a>
    6af4:	c7 01       	movw	r24, r14
    6af6:	80 51       	subi	r24, 0x10	; 16
    6af8:	94 4d       	sbci	r25, 0xD4	; 212
    6afa:	fc 01       	movw	r30, r24
    6afc:	25 91       	lpm	r18, Z+
    6afe:	34 91       	lpm	r19, Z+

// ~~~~~~~~~~~~~~~~~~
void
MB_S_Tx(uint8_t MB_N)
{
	USART_Func(MB_N, LED);
    6b00:	f9 01       	movw	r30, r18
    6b02:	19 95       	eicall
		break;
	case Role_Master:
		MB_M_Tx(MB_N);
		break;
	}
}
    6b04:	df 91       	pop	r29
    6b06:	cf 91       	pop	r28
    6b08:	1f 91       	pop	r17
    6b0a:	ff 90       	pop	r15
    6b0c:	ef 90       	pop	r14
    6b0e:	df 90       	pop	r13
    6b10:	cf 90       	pop	r12
    6b12:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~
static uint8_t
MB_Port_N(usart_t *usart)
{
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Port[MB_N].usart_field)!=usart; MB_N++);
    6b14:	10 e0       	ldi	r17, 0x00	; 0
    6b16:	c0 e0       	ldi	r28, 0x00	; 0
    6b18:	d0 e0       	ldi	r29, 0x00	; 0
    6b1a:	53 cf       	rjmp	.-346    	; 0x69c2 <Modbus_TX+0x4e>

00006b1c <MB_SingleRun>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_SingleRun(uint8_t MB_N, uint8_t Addr, uint8_t Func, uint16_t StartAddr, uint16_t Qt, void *Buf)
{
    6b1c:	df 92       	push	r13
    6b1e:	ef 92       	push	r14
    6b20:	ff 92       	push	r15
    6b22:	0f 93       	push	r16
    6b24:	1f 93       	push	r17
    6b26:	cf 93       	push	r28
    6b28:	df 93       	push	r29
    6b2a:	d8 2e       	mov	r13, r24
    6b2c:	94 2f       	mov	r25, r20
    6b2e:	a9 01       	movw	r20, r18
	if (MB_SingleState[MB_N]!=MB_SingleIdle)
    6b30:	c8 2f       	mov	r28, r24
    6b32:	d0 e0       	ldi	r29, 0x00	; 0
    6b34:	9e 01       	movw	r18, r28
    6b36:	2a 55       	subi	r18, 0x5A	; 90
    6b38:	39 4f       	sbci	r19, 0xF9	; 249
    6b3a:	f9 01       	movw	r30, r18
    6b3c:	80 81       	ld	r24, Z
    6b3e:	88 23       	and	r24, r24
    6b40:	91 f5       	brne	.+100    	; 0x6ba6 <MB_SingleRun+0x8a>
		return;

	MB_SingleQuery[MB_N].Addr				= Addr;
    6b42:	de 01       	movw	r26, r28
    6b44:	aa 0f       	add	r26, r26
    6b46:	bb 1f       	adc	r27, r27
    6b48:	aa 0f       	add	r26, r26
    6b4a:	bb 1f       	adc	r27, r27
    6b4c:	aa 0f       	add	r26, r26
    6b4e:	bb 1f       	adc	r27, r27
    6b50:	af 52       	subi	r26, 0x2F	; 47
    6b52:	bb 4f       	sbci	r27, 0xFB	; 251
    6b54:	6c 93       	st	X, r22
	MB_SingleQuery[MB_N].Func				= Func;
    6b56:	11 96       	adiw	r26, 0x01	; 1
    6b58:	9c 93       	st	X, r25
    6b5a:	11 97       	sbiw	r26, 0x01	; 1
	MB_SingleQuery[MB_N].StartAddr	= StartAddr;
    6b5c:	be 01       	movw	r22, r28
    6b5e:	66 0f       	add	r22, r22
    6b60:	77 1f       	adc	r23, r23
    6b62:	66 0f       	add	r22, r22
    6b64:	77 1f       	adc	r23, r23
    6b66:	fb 01       	movw	r30, r22
    6b68:	ee 0f       	add	r30, r30
    6b6a:	ff 1f       	adc	r31, r31
    6b6c:	ed 52       	subi	r30, 0x2D	; 45
    6b6e:	fb 4f       	sbci	r31, 0xFB	; 251
    6b70:	51 83       	std	Z+1, r21	; 0x01
    6b72:	40 83       	st	Z, r20
	MB_SingleQuery[MB_N].Qt					= Qt;
    6b74:	ae 01       	movw	r20, r28
    6b76:	44 0f       	add	r20, r20
    6b78:	55 1f       	adc	r21, r21
    6b7a:	fa 01       	movw	r30, r20
    6b7c:	ee 0f       	add	r30, r30
    6b7e:	ff 1f       	adc	r31, r31
    6b80:	ee 0f       	add	r30, r30
    6b82:	ff 1f       	adc	r31, r31
    6b84:	eb 52       	subi	r30, 0x2B	; 43
    6b86:	fb 4f       	sbci	r31, 0xFB	; 251
    6b88:	11 83       	std	Z+1, r17	; 0x01
    6b8a:	00 83       	st	Z, r16
	MB_SingleQuery[MB_N].Buf				= Buf;
    6b8c:	17 96       	adiw	r26, 0x07	; 7
    6b8e:	fc 92       	st	X, r15
    6b90:	ee 92       	st	-X, r14
    6b92:	16 97       	sbiw	r26, 0x06	; 6

	MB_SingleState[MB_N] = MB_SingleStart;
    6b94:	81 e0       	ldi	r24, 0x01	; 1
    6b96:	f9 01       	movw	r30, r18
    6b98:	80 83       	st	Z, r24
	if (MB_State[MB_N]==MB_Proc && !LastProcSingle) {
    6b9a:	fe 01       	movw	r30, r28
    6b9c:	e7 54       	subi	r30, 0x47	; 71
    6b9e:	fa 4f       	sbci	r31, 0xFA	; 250
    6ba0:	80 81       	ld	r24, Z
    6ba2:	84 30       	cpi	r24, 0x04	; 4
    6ba4:	41 f0       	breq	.+16     	; 0x6bb6 <MB_SingleRun+0x9a>
			IntOff();
			MB_Transm(MB_N);
			IntOn();
		}
	}
}
    6ba6:	df 91       	pop	r29
    6ba8:	cf 91       	pop	r28
    6baa:	1f 91       	pop	r17
    6bac:	0f 91       	pop	r16
    6bae:	ff 90       	pop	r15
    6bb0:	ef 90       	pop	r14
    6bb2:	df 90       	pop	r13
    6bb4:	08 95       	ret
	MB_SingleQuery[MB_N].StartAddr	= StartAddr;
	MB_SingleQuery[MB_N].Qt					= Qt;
	MB_SingleQuery[MB_N].Buf				= Buf;

	MB_SingleState[MB_N] = MB_SingleStart;
	if (MB_State[MB_N]==MB_Proc && !LastProcSingle) {
    6bb6:	80 91 d9 04 	lds	r24, 0x04D9
    6bba:	88 23       	and	r24, r24
    6bbc:	a1 f7       	brne	.-24     	; 0x6ba6 <MB_SingleRun+0x8a>
		uint16_t T = (CurrSlave[MB_N]==0 ? MB_M_Period[MB_N] : MB_M_Timeout[MB_N]) - GetTimer16(TD_MB_Idle+MB_N);
    6bbe:	fe 01       	movw	r30, r28
    6bc0:	e5 5b       	subi	r30, 0xB5	; 181
    6bc2:	f9 4f       	sbci	r31, 0xF9	; 249
    6bc4:	80 81       	ld	r24, Z
    6bc6:	88 23       	and	r24, r24
    6bc8:	09 f0       	breq	.+2      	; 0x6bcc <MB_SingleRun+0xb0>
    6bca:	4d c0       	rjmp	.+154    	; 0x6c66 <MB_SingleRun+0x14a>
    6bcc:	4c 55       	subi	r20, 0x5C	; 92
    6bce:	59 4f       	sbci	r21, 0xF9	; 249
    6bd0:	fa 01       	movw	r30, r20
    6bd2:	40 81       	ld	r20, Z
    6bd4:	51 81       	ldd	r21, Z+1	; 0x01
    6bd6:	20 91 df 04 	lds	r18, 0x04DF
    6bda:	2d 0d       	add	r18, r13

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    6bdc:	8f b7       	in	r24, 0x3f	; 63
    6bde:	80 78       	andi	r24, 0x80	; 128
    6be0:	80 93 e5 02 	sts	0x02E5, r24
	cli();
    6be4:	f8 94       	cli
    6be6:	e2 2f       	mov	r30, r18
    6be8:	f0 e0       	ldi	r31, 0x00	; 0
    6bea:	ee 0f       	add	r30, r30
    6bec:	ff 1f       	adc	r31, r31
    6bee:	ea 5b       	subi	r30, 0xBA	; 186
    6bf0:	fc 4f       	sbci	r31, 0xFC	; 252
    6bf2:	a0 81       	ld	r26, Z
    6bf4:	b1 81       	ldd	r27, Z+1	; 0x01

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    6bf6:	88 23       	and	r24, r24
    6bf8:	09 f0       	breq	.+2      	; 0x6bfc <MB_SingleRun+0xe0>
		sei();
    6bfa:	78 94       	sei
    6bfc:	ca 01       	movw	r24, r20
    6bfe:	8a 1b       	sub	r24, r26
    6c00:	9b 0b       	sbc	r25, r27
		if (T<MB_M_Pause_Min)
    6c02:	85 30       	cpi	r24, 0x05	; 5
    6c04:	91 05       	cpc	r25, r1
    6c06:	a8 f1       	brcs	.+106    	; 0x6c72 <MB_SingleRun+0x156>

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    6c08:	8f b7       	in	r24, 0x3f	; 63
    6c0a:	80 78       	andi	r24, 0x80	; 128
    6c0c:	80 93 e5 02 	sts	0x02E5, r24
	cli();
    6c10:	f8 94       	cli
    6c12:	cb 01       	movw	r24, r22
    6c14:	88 0f       	add	r24, r24
    6c16:	99 1f       	adc	r25, r25
    6c18:	88 0f       	add	r24, r24
    6c1a:	99 1f       	adc	r25, r25
    6c1c:	86 0f       	add	r24, r22
    6c1e:	97 1f       	adc	r25, r23
    6c20:	80 51       	subi	r24, 0x10	; 16
    6c22:	94 4d       	sbci	r25, 0xD4	; 212
    6c24:	fc 01       	movw	r30, r24
    6c26:	25 91       	lpm	r18, Z+
    6c28:	34 91       	lpm	r19, Z+
			StartTimer16(TD_MB_Idle+MB_N, MB_M_Pause_Min-T);
		else {
			IntOff();
			USART_Func(MB_N, LED);
    6c2a:	f9 01       	movw	r30, r18
    6c2c:	19 95       	eicall

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    6c2e:	80 91 e5 02 	lds	r24, 0x02E5
    6c32:	88 23       	and	r24, r24
    6c34:	09 f0       	breq	.+2      	; 0x6c38 <MB_SingleRun+0x11c>
		sei();
    6c36:	78 94       	sei
			IntOn();
			ResetTimer16(TD_MB_Idle+MB_N);
    6c38:	80 91 df 04 	lds	r24, 0x04DF
    6c3c:	8d 0d       	add	r24, r13
    6c3e:	0e 94 eb 1b 	call	0x37d6	; 0x37d6 <ResetTimer16>
			FormSingle(MB_N);
    6c42:	8d 2d       	mov	r24, r13
    6c44:	0e 94 0e 30 	call	0x601c	; 0x601c <FormSingle>

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    6c48:	8f b7       	in	r24, 0x3f	; 63
    6c4a:	80 78       	andi	r24, 0x80	; 128
    6c4c:	80 93 e5 02 	sts	0x02E5, r24
	cli();
    6c50:	f8 94       	cli
			IntOff();
			MB_Transm(MB_N);
    6c52:	8d 2d       	mov	r24, r13
    6c54:	0e 94 b4 28 	call	0x5168	; 0x5168 <MB_Transm>

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    6c58:	80 91 e5 02 	lds	r24, 0x02E5
    6c5c:	88 23       	and	r24, r24
    6c5e:	09 f4       	brne	.+2      	; 0x6c62 <MB_SingleRun+0x146>
    6c60:	a2 cf       	rjmp	.-188    	; 0x6ba6 <MB_SingleRun+0x8a>
		sei();
    6c62:	78 94       	sei
    6c64:	a0 cf       	rjmp	.-192    	; 0x6ba6 <MB_SingleRun+0x8a>
	MB_SingleQuery[MB_N].Qt					= Qt;
	MB_SingleQuery[MB_N].Buf				= Buf;

	MB_SingleState[MB_N] = MB_SingleStart;
	if (MB_State[MB_N]==MB_Proc && !LastProcSingle) {
		uint16_t T = (CurrSlave[MB_N]==0 ? MB_M_Period[MB_N] : MB_M_Timeout[MB_N]) - GetTimer16(TD_MB_Idle+MB_N);
    6c66:	c9 52       	subi	r28, 0x29	; 41
    6c68:	d7 4f       	sbci	r29, 0xF7	; 247
    6c6a:	88 81       	ld	r24, Y
    6c6c:	48 2f       	mov	r20, r24
    6c6e:	50 e0       	ldi	r21, 0x00	; 0
    6c70:	b2 cf       	rjmp	.-156    	; 0x6bd6 <MB_SingleRun+0xba>
		if (T<MB_M_Pause_Min)
			StartTimer16(TD_MB_Idle+MB_N, MB_M_Pause_Min-T);
    6c72:	65 e0       	ldi	r22, 0x05	; 5
    6c74:	70 e0       	ldi	r23, 0x00	; 0
    6c76:	68 1b       	sub	r22, r24
    6c78:	79 0b       	sbc	r23, r25
    6c7a:	82 2f       	mov	r24, r18
    6c7c:	0e 94 05 1a 	call	0x340a	; 0x340a <StartTimer16>
    6c80:	92 cf       	rjmp	.-220    	; 0x6ba6 <MB_SingleRun+0x8a>

00006c82 <MB_Master_MaxCycle_Clear>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_Master_MaxCycle_Clear(uint8_t MB_N)
{
	MB_Master_MaxCycle[MB_N] = 0;
    6c82:	e8 2f       	mov	r30, r24
    6c84:	f0 e0       	ldi	r31, 0x00	; 0
    6c86:	ee 0f       	add	r30, r30
    6c88:	ff 1f       	adc	r31, r31
    6c8a:	eb 54       	subi	r30, 0x4B	; 75
    6c8c:	f9 4f       	sbci	r31, 0xF9	; 249
    6c8e:	11 82       	std	Z+1, r1	; 0x01
    6c90:	10 82       	st	Z, r1
}
    6c92:	08 95       	ret

00006c94 <MB_M_Cycle>:

// ~~~~~~~~~~~~~~~~~~~~~
void
MB_M_Cycle(uint8_t MB_N)
{
    6c94:	ff 92       	push	r15
    6c96:	0f 93       	push	r16
    6c98:	1f 93       	push	r17
    6c9a:	cf 93       	push	r28
    6c9c:	df 93       	push	r29
    6c9e:	f8 2e       	mov	r15, r24
	if (Timer16Stopp(TD_MB_SlaveOff+MB_N))
    6ca0:	10 91 df 04 	lds	r17, 0x04DF
    6ca4:	18 0f       	add	r17, r24
    6ca6:	01 2f       	mov	r16, r17
    6ca8:	0f 5f       	subi	r16, 0xFF	; 255
    6caa:	80 2f       	mov	r24, r16
    6cac:	0e 94 41 1b 	call	0x3682	; 0x3682 <Timer16Stopp>
    6cb0:	88 23       	and	r24, r24
    6cb2:	d9 f4       	brne	.+54     	; 0x6cea <MB_M_Cycle+0x56>
		SlavesOn(MB_N);

	if (Timer16Stopp(TD_MB_Idle+MB_N)){
    6cb4:	81 2f       	mov	r24, r17
    6cb6:	0e 94 41 1b 	call	0x3682	; 0x3682 <Timer16Stopp>
    6cba:	88 23       	and	r24, r24
    6cbc:	81 f0       	breq	.+32     	; 0x6cde <MB_M_Cycle+0x4a>
		cli();
    6cbe:	f8 94       	cli
		if(MB_State[MB_N] == MB_Idle) MB_State[MB_N] = MB_NoReply;
    6cc0:	cf 2d       	mov	r28, r15
    6cc2:	d0 e0       	ldi	r29, 0x00	; 0
    6cc4:	fe 01       	movw	r30, r28
    6cc6:	e7 54       	subi	r30, 0x47	; 71
    6cc8:	fa 4f       	sbci	r31, 0xFA	; 250
    6cca:	80 81       	ld	r24, Z
    6ccc:	81 30       	cpi	r24, 0x01	; 1
    6cce:	29 f1       	breq	.+74     	; 0x6d1a <MB_M_Cycle+0x86>
		sei();
    6cd0:	78 94       	sei
	}
	else return;
	
	switch (MB_State[MB_N]) {
    6cd2:	80 81       	ld	r24, Z
    6cd4:	84 30       	cpi	r24, 0x04	; 4
    6cd6:	39 f1       	breq	.+78     	; 0x6d26 <MB_M_Cycle+0x92>
    6cd8:	85 30       	cpi	r24, 0x05	; 5
    6cda:	09 f4       	brne	.+2      	; 0x6cde <MB_M_Cycle+0x4a>
    6cdc:	52 c0       	rjmp	.+164    	; 0x6d82 <MB_M_Cycle+0xee>
		cli();
		MB_Transm(MB_N);
		sei();
		break;
	}
}
    6cde:	df 91       	pop	r29
    6ce0:	cf 91       	pop	r28
    6ce2:	1f 91       	pop	r17
    6ce4:	0f 91       	pop	r16
    6ce6:	ff 90       	pop	r15
    6ce8:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~
static void
SlavesOn(uint8_t MB_N)
{
	SlaveSkip[MB_N] = 0;
    6cea:	af 2d       	mov	r26, r15
    6cec:	b0 e0       	ldi	r27, 0x00	; 0
    6cee:	fd 01       	movw	r30, r26
    6cf0:	ee 0f       	add	r30, r30
    6cf2:	ff 1f       	adc	r31, r31
    6cf4:	ee 0f       	add	r30, r30
    6cf6:	ff 1f       	adc	r31, r31
    6cf8:	e5 52       	subi	r30, 0x25	; 37
    6cfa:	fb 4f       	sbci	r31, 0xFB	; 251
    6cfc:	10 82       	st	Z, r1
    6cfe:	11 82       	std	Z+1, r1	; 0x01
    6d00:	12 82       	std	Z+2, r1	; 0x02
    6d02:	13 82       	std	Z+3, r1	; 0x03
	StartTimer16(TD_MB_SlaveOff+MB_N, 100*MB_M_TimeOff[MB_N]);
    6d04:	aa 52       	subi	r26, 0x2A	; 42
    6d06:	ba 4f       	sbci	r27, 0xFA	; 250
    6d08:	6c 91       	ld	r22, X
    6d0a:	84 e6       	ldi	r24, 0x64	; 100
    6d0c:	68 9f       	mul	r22, r24
    6d0e:	b0 01       	movw	r22, r0
    6d10:	11 24       	eor	r1, r1
    6d12:	80 2f       	mov	r24, r16
    6d14:	0e 94 05 1a 	call	0x340a	; 0x340a <StartTimer16>
    6d18:	cd cf       	rjmp	.-102    	; 0x6cb4 <MB_M_Cycle+0x20>
	if (Timer16Stopp(TD_MB_SlaveOff+MB_N))
		SlavesOn(MB_N);

	if (Timer16Stopp(TD_MB_Idle+MB_N)){
		cli();
		if(MB_State[MB_N] == MB_Idle) MB_State[MB_N] = MB_NoReply;
    6d1a:	85 e0       	ldi	r24, 0x05	; 5
    6d1c:	80 83       	st	Z, r24
		sei();
    6d1e:	78 94       	sei
	}
	else return;
	
	switch (MB_State[MB_N]) {
    6d20:	80 81       	ld	r24, Z
    6d22:	84 30       	cpi	r24, 0x04	; 4
    6d24:	c9 f6       	brne	.-78     	; 0x6cd8 <MB_M_Cycle+0x44>
		cli();
		MB_Transm(MB_N);
		sei();
		break;
	case MB_Proc:
		cli();
    6d26:	f8 94       	cli
    6d28:	ce 01       	movw	r24, r28
    6d2a:	88 0f       	add	r24, r24
    6d2c:	99 1f       	adc	r25, r25
    6d2e:	88 0f       	add	r24, r24
    6d30:	99 1f       	adc	r25, r25
    6d32:	9c 01       	movw	r18, r24
    6d34:	22 0f       	add	r18, r18
    6d36:	33 1f       	adc	r19, r19
    6d38:	22 0f       	add	r18, r18
    6d3a:	33 1f       	adc	r19, r19
    6d3c:	28 0f       	add	r18, r24
    6d3e:	39 1f       	adc	r19, r25
    6d40:	20 51       	subi	r18, 0x10	; 16
    6d42:	34 4d       	sbci	r19, 0xD4	; 212
    6d44:	f9 01       	movw	r30, r18
    6d46:	85 91       	lpm	r24, Z+
    6d48:	94 91       	lpm	r25, Z+
		USART_Func(MB_N, LED);
    6d4a:	fc 01       	movw	r30, r24
    6d4c:	19 95       	eicall
		sei();
    6d4e:	78 94       	sei
		switch (MB_SingleState[MB_N]) {
    6d50:	ca 55       	subi	r28, 0x5A	; 90
    6d52:	d9 4f       	sbci	r29, 0xF9	; 249
    6d54:	88 81       	ld	r24, Y
    6d56:	88 23       	and	r24, r24
    6d58:	b1 f1       	breq	.+108    	; 0x6dc6 <MB_M_Cycle+0x132>
    6d5a:	81 30       	cpi	r24, 0x01	; 1
    6d5c:	81 f1       	breq	.+96     	; 0x6dbe <MB_M_Cycle+0x12a>
				FormQuery(MB_N);
			else
				FormSingle(MB_N);
			break;
		}
		StartTimer16(TD_MB_Idle+MB_N, 0xFFFF);	//     
    6d5e:	80 91 df 04 	lds	r24, 0x04DF
    6d62:	8f 0d       	add	r24, r15
    6d64:	6f ef       	ldi	r22, 0xFF	; 255
    6d66:	7f ef       	ldi	r23, 0xFF	; 255
    6d68:	0e 94 05 1a 	call	0x340a	; 0x340a <StartTimer16>
		cli();
    6d6c:	f8 94       	cli
		MB_Transm(MB_N);
    6d6e:	8f 2d       	mov	r24, r15
    6d70:	0e 94 b4 28 	call	0x5168	; 0x5168 <MB_Transm>
		sei();
    6d74:	78 94       	sei
		break;
	}
}
    6d76:	df 91       	pop	r29
    6d78:	cf 91       	pop	r28
    6d7a:	1f 91       	pop	r17
    6d7c:	0f 91       	pop	r16
    6d7e:	ff 90       	pop	r15
    6d80:	08 95       	ret
	}
	else return;
	
	switch (MB_State[MB_N]) {
	case MB_NoReply:
		FailSlave(MB_N);
    6d82:	8f 2d       	mov	r24, r15
    6d84:	0e 94 23 31 	call	0x6246	; 0x6246 <FailSlave>
		switch (MB_SingleState[MB_N]) {
    6d88:	fe 01       	movw	r30, r28
    6d8a:	ea 55       	subi	r30, 0x5A	; 90
    6d8c:	f9 4f       	sbci	r31, 0xF9	; 249
    6d8e:	e0 81       	ld	r30, Z
    6d90:	ee 23       	and	r30, r30
    6d92:	e9 f4       	brne	.+58     	; 0x6dce <MB_M_Cycle+0x13a>
		case MB_SingleIdle:
			FormQuery(MB_N);
    6d94:	8f 2d       	mov	r24, r15
    6d96:	0e 94 bc 2f 	call	0x5f78	; 0x5f78 <FormQuery>
		case MB_SingleStart:
			if (Try[MB_N]==0)
				FormSingle(MB_N);
			break;
		}
		StartTimer16(TD_MB_Idle+MB_N, 0xFFFF);	//     
    6d9a:	80 91 df 04 	lds	r24, 0x04DF
    6d9e:	8f 0d       	add	r24, r15
    6da0:	6f ef       	ldi	r22, 0xFF	; 255
    6da2:	7f ef       	ldi	r23, 0xFF	; 255
    6da4:	0e 94 05 1a 	call	0x340a	; 0x340a <StartTimer16>
		cli();
    6da8:	f8 94       	cli
		MB_Transm(MB_N);
    6daa:	8f 2d       	mov	r24, r15
    6dac:	0e 94 b4 28 	call	0x5168	; 0x5168 <MB_Transm>
		sei();
    6db0:	78 94       	sei
		cli();
		MB_Transm(MB_N);
		sei();
		break;
	}
}
    6db2:	df 91       	pop	r29
    6db4:	cf 91       	pop	r28
    6db6:	1f 91       	pop	r17
    6db8:	0f 91       	pop	r16
    6dba:	ff 90       	pop	r15
    6dbc:	08 95       	ret
		switch (MB_SingleState[MB_N]) {
		case MB_SingleIdle:
			FormQuery(MB_N);
			break;
		case MB_SingleStart:
			if (LastProcSingle)
    6dbe:	80 91 d9 04 	lds	r24, 0x04D9
    6dc2:	88 23       	and	r24, r24
    6dc4:	79 f0       	breq	.+30     	; 0x6de4 <MB_M_Cycle+0x150>
				FormQuery(MB_N);
    6dc6:	8f 2d       	mov	r24, r15
    6dc8:	0e 94 bc 2f 	call	0x5f78	; 0x5f78 <FormQuery>
    6dcc:	c8 cf       	rjmp	.-112    	; 0x6d5e <MB_M_Cycle+0xca>
	else return;
	
	switch (MB_State[MB_N]) {
	case MB_NoReply:
		FailSlave(MB_N);
		switch (MB_SingleState[MB_N]) {
    6dce:	e1 30       	cpi	r30, 0x01	; 1
    6dd0:	21 f7       	brne	.-56     	; 0x6d9a <MB_M_Cycle+0x106>
		case MB_SingleIdle:
			FormQuery(MB_N);
			break;
		case MB_SingleStart:
			if (Try[MB_N]==0)
    6dd2:	c6 52       	subi	r28, 0x26	; 38
    6dd4:	db 4f       	sbci	r29, 0xFB	; 251
    6dd6:	88 81       	ld	r24, Y
    6dd8:	88 23       	and	r24, r24
    6dda:	f9 f6       	brne	.-66     	; 0x6d9a <MB_M_Cycle+0x106>
				FormSingle(MB_N);
    6ddc:	8f 2d       	mov	r24, r15
    6dde:	0e 94 0e 30 	call	0x601c	; 0x601c <FormSingle>
    6de2:	db cf       	rjmp	.-74     	; 0x6d9a <MB_M_Cycle+0x106>
			break;
		case MB_SingleStart:
			if (LastProcSingle)
				FormQuery(MB_N);
			else
				FormSingle(MB_N);
    6de4:	8f 2d       	mov	r24, r15
    6de6:	0e 94 0e 30 	call	0x601c	; 0x601c <FormSingle>
    6dea:	b9 cf       	rjmp	.-142    	; 0x6d5e <MB_M_Cycle+0xca>

00006dec <MB_Cycle>:
}

// ~~~~~~~~~~~
void
MB_Cycle(void)
{
    6dec:	cf 93       	push	r28
    6dee:	df 93       	push	r29
	void MB_S_Timer_ISR(uint8_t);
	void MB_M_Timer_ISR(uint8_t);

	for (uint8_t MB_N=0; MB_N<Modbus_Qt; MB_N++){
		if(MB_TimerFlag & (1<<MB_N)){
    6df0:	80 91 d8 08 	lds	r24, 0x08D8
    6df4:	80 fd       	sbrc	r24, 0
    6df6:	0c c0       	rjmp	.+24     	; 0x6e10 <MB_Cycle+0x24>
    6df8:	c6 ef       	ldi	r28, 0xF6	; 246
    6dfa:	db e2       	ldi	r29, 0x2B	; 43

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    6dfc:	fe 01       	movw	r30, r28
    6dfe:	84 91       	lpm	r24, Z+
	}

	void MB_M_Cycle(uint8_t);

	for (uint8_t MB_N=0; MB_N<Modbus_Qt; MB_N++)
		if (prb(MB_Role+MB_N)==Role_Master)
    6e00:	81 30       	cpi	r24, 0x01	; 1
    6e02:	19 f4       	brne	.+6      	; 0x6e0a <MB_Cycle+0x1e>
			MB_M_Cycle(MB_N);
    6e04:	80 e0       	ldi	r24, 0x00	; 0
    6e06:	0e 94 4a 36 	call	0x6c94	; 0x6c94 <MB_M_Cycle>
}
    6e0a:	df 91       	pop	r29
    6e0c:	cf 91       	pop	r28
    6e0e:	08 95       	ret
	void MB_S_Timer_ISR(uint8_t);
	void MB_M_Timer_ISR(uint8_t);

	for (uint8_t MB_N=0; MB_N<Modbus_Qt; MB_N++){
		if(MB_TimerFlag & (1<<MB_N)){
			cli();
    6e10:	f8 94       	cli
			MB_TimerFlag &= ~(1<<MB_N);
    6e12:	80 91 d8 08 	lds	r24, 0x08D8
    6e16:	8e 7f       	andi	r24, 0xFE	; 254
    6e18:	80 93 d8 08 	sts	0x08D8, r24
			sei();
    6e1c:	78 94       	sei
    6e1e:	c6 ef       	ldi	r28, 0xF6	; 246
    6e20:	db e2       	ldi	r29, 0x2B	; 43
    6e22:	fe 01       	movw	r30, r28
    6e24:	84 91       	lpm	r24, Z+
			switch (prb(MB_Role+MB_N)) {
    6e26:	88 23       	and	r24, r24
    6e28:	21 f4       	brne	.+8      	; 0x6e32 <MB_Cycle+0x46>
			case Role_Slave:
				MB_S_Timer_ISR(MB_N);
    6e2a:	80 e0       	ldi	r24, 0x00	; 0
    6e2c:	0e 94 6c 2a 	call	0x54d8	; 0x54d8 <MB_S_Timer_ISR>
    6e30:	e5 cf       	rjmp	.-54     	; 0x6dfc <MB_Cycle+0x10>
	for (uint8_t MB_N=0; MB_N<Modbus_Qt; MB_N++){
		if(MB_TimerFlag & (1<<MB_N)){
			cli();
			MB_TimerFlag &= ~(1<<MB_N);
			sei();
			switch (prb(MB_Role+MB_N)) {
    6e32:	81 30       	cpi	r24, 0x01	; 1
    6e34:	19 f7       	brne	.-58     	; 0x6dfc <MB_Cycle+0x10>
			case Role_Slave:
				MB_S_Timer_ISR(MB_N);
				break;
			case Role_Master:
				MB_M_Timer_ISR(MB_N);
    6e36:	80 e0       	ldi	r24, 0x00	; 0
    6e38:	0e 94 99 31 	call	0x6332	; 0x6332 <MB_M_Timer_ISR>
    6e3c:	df cf       	rjmp	.-66     	; 0x6dfc <MB_Cycle+0x10>

00006e3e <SetIP>:
	uint8_t IP3;
	uint8_t IP4;
} IP_Addr;

//~~~~~~~~~~~~~~
void SetIP(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
    6e3e:	0f 93       	push	r16
    6e40:	fc 01       	movw	r30, r24
	IP->IP1 = IP1;
    6e42:	60 83       	st	Z, r22
	IP->IP2 = IP2;
    6e44:	41 83       	std	Z+1, r20	; 0x01
	IP->IP3 = IP3;
    6e46:	22 83       	std	Z+2, r18	; 0x02
	IP->IP4 = IP4;
    6e48:	03 83       	std	Z+3, r16	; 0x03
}
    6e4a:	0f 91       	pop	r16
    6e4c:	08 95       	ret

00006e4e <IP_compare_Const>:
uint8_t IP_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
    6e4e:	0f 93       	push	r16
    6e50:	fc 01       	movw	r30, r24
	if((IP->IP1 == IP1) && (IP->IP2 == IP2) && (IP->IP3 == IP3) && (IP->IP4 == IP4)) return 1;
    6e52:	80 81       	ld	r24, Z
    6e54:	86 17       	cp	r24, r22
    6e56:	21 f0       	breq	.+8      	; 0x6e60 <IP_compare_Const+0x12>
    6e58:	20 e0       	ldi	r18, 0x00	; 0
	else return 0;
}
    6e5a:	82 2f       	mov	r24, r18
    6e5c:	0f 91       	pop	r16
    6e5e:	08 95       	ret
	IP->IP2 = IP2;
	IP->IP3 = IP3;
	IP->IP4 = IP4;
}
uint8_t IP_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	if((IP->IP1 == IP1) && (IP->IP2 == IP2) && (IP->IP3 == IP3) && (IP->IP4 == IP4)) return 1;
    6e60:	81 81       	ldd	r24, Z+1	; 0x01
    6e62:	84 17       	cp	r24, r20
    6e64:	c9 f7       	brne	.-14     	; 0x6e58 <IP_compare_Const+0xa>
    6e66:	82 81       	ldd	r24, Z+2	; 0x02
    6e68:	82 17       	cp	r24, r18
    6e6a:	b1 f7       	brne	.-20     	; 0x6e58 <IP_compare_Const+0xa>
    6e6c:	20 e0       	ldi	r18, 0x00	; 0
    6e6e:	83 81       	ldd	r24, Z+3	; 0x03
    6e70:	80 13       	cpse	r24, r16
    6e72:	21 e0       	ldi	r18, 0x01	; 1
    6e74:	81 e0       	ldi	r24, 0x01	; 1
    6e76:	28 27       	eor	r18, r24
    6e78:	f0 cf       	rjmp	.-32     	; 0x6e5a <IP_compare_Const+0xc>

00006e7a <InitFIFO>:
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    6e7a:	8f ef       	ldi	r24, 0xFF	; 255
    6e7c:	80 93 f0 06 	sts	0x06F0, r24
	GSM_RX_FIFO_End = 255;
    6e80:	80 93 4a 06 	sts	0x064A, r24
	GSM_RxCharN = 0;
    6e84:	10 92 0e 0b 	sts	0x0B0E, r1
	GSM_RX_FIFOOverFlow = 0;
    6e88:	10 92 c1 08 	sts	0x08C1, r1
	GSM_RX_FIFOMax = 0;
    6e8c:	10 92 c7 08 	sts	0x08C7, r1
}
    6e90:	08 95       	ret

00006e92 <GetByteFromFIFO>:
// ~~~~~~~~~~~
void GetByteFromFIFO(uint8_t *ReadBuf, uint8_t *Index, uint8_t ReadBuf_Sz){
    6e92:	0f 93       	push	r16
    6e94:	1f 93       	push	r17
    6e96:	cf 93       	push	r28
    6e98:	df 93       	push	r29
    6e9a:	8c 01       	movw	r16, r24
    6e9c:	eb 01       	movw	r28, r22

	//Reset *Index if read buffer overflow
	if(*Index >= ReadBuf_Sz){
    6e9e:	88 81       	ld	r24, Y
    6ea0:	84 17       	cp	r24, r20
    6ea2:	08 f0       	brcs	.+2      	; 0x6ea6 <GetByteFromFIFO+0x14>
		*Index = 0;
    6ea4:	18 82       	st	Y, r1
		//TODO  
	}	

	if(GSM_RX_FIFO_Begin > GSM_RX_FIFO_End){
    6ea6:	80 91 f0 06 	lds	r24, 0x06F0
    6eaa:	e0 91 4a 06 	lds	r30, 0x064A
    6eae:	e8 17       	cp	r30, r24
    6eb0:	f8 f4       	brcc	.+62     	; 0x6ef0 <GetByteFromFIFO+0x5e>
		if((GSM_RX_FIFO_End != 255)&&(GSM_RX_FIFO_End != 255))			
    6eb2:	ef 3f       	cpi	r30, 0xFF	; 255
    6eb4:	61 f0       	breq	.+24     	; 0x6ece <GetByteFromFIFO+0x3c>
			if(GSM_RX_FIFOMax < (GSM_RX_FIFO_Begin - GSM_RX_FIFO_End))
    6eb6:	20 91 c7 08 	lds	r18, 0x08C7
    6eba:	80 91 f0 06 	lds	r24, 0x06F0
    6ebe:	30 e0       	ldi	r19, 0x00	; 0
    6ec0:	90 e0       	ldi	r25, 0x00	; 0
    6ec2:	8e 1b       	sub	r24, r30
    6ec4:	91 09       	sbc	r25, r1
    6ec6:	28 17       	cp	r18, r24
    6ec8:	39 07       	cpc	r19, r25
    6eca:	0c f4       	brge	.+2      	; 0x6ece <GetByteFromFIFO+0x3c>
    6ecc:	46 c0       	rjmp	.+140    	; 0x6f5a <GetByteFromFIFO+0xc8>
				GSM_RX_FIFOMax =  GSM_RX_FIFO_Begin - GSM_RX_FIFO_End;
		GSM_RX_FIFO_End++;
    6ece:	ef 5f       	subi	r30, 0xFF	; 255
    6ed0:	e0 93 4a 06 	sts	0x064A, r30
		ReadBuf[*Index] = GSM_RX_FIFO[GSM_RX_FIFO_End];
    6ed4:	88 81       	ld	r24, Y
    6ed6:	d8 01       	movw	r26, r16
    6ed8:	a8 0f       	add	r26, r24
    6eda:	b1 1d       	adc	r27, r1
    6edc:	f0 e0       	ldi	r31, 0x00	; 0
    6ede:	e8 52       	subi	r30, 0x28	; 40
    6ee0:	fa 4f       	sbci	r31, 0xFA	; 250
    6ee2:	80 81       	ld	r24, Z
    6ee4:	8c 93       	st	X, r24
		*Index=*Index+1;
    6ee6:	88 81       	ld	r24, Y
    6ee8:	8f 5f       	subi	r24, 0xFF	; 255
    6eea:	88 83       	st	Y, r24
    6eec:	e0 91 4a 06 	lds	r30, 0x064A
	}
	if(GSM_RX_FIFO_End > GSM_RX_FIFO_Begin){
    6ef0:	80 91 f0 06 	lds	r24, 0x06F0
    6ef4:	8e 17       	cp	r24, r30
    6ef6:	28 f5       	brcc	.+74     	; 0x6f42 <GetByteFromFIFO+0xb0>
		if((GSM_RX_FIFO_End != 255)&&(GSM_RX_FIFO_End != 255))
    6ef8:	ef 3f       	cpi	r30, 0xFF	; 255
    6efa:	99 f0       	breq	.+38     	; 0x6f22 <GetByteFromFIFO+0x90>
			if(GSM_RX_FIFOMax < (GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End  + GSM_RX_FIFO_Begin))
    6efc:	20 91 c7 08 	lds	r18, 0x08C7
    6f00:	80 91 f0 06 	lds	r24, 0x06F0
    6f04:	30 e0       	ldi	r19, 0x00	; 0
    6f06:	90 e0       	ldi	r25, 0x00	; 0
    6f08:	8c 59       	subi	r24, 0x9C	; 156
    6f0a:	9f 4f       	sbci	r25, 0xFF	; 255
    6f0c:	8e 1b       	sub	r24, r30
    6f0e:	91 09       	sbc	r25, r1
    6f10:	28 17       	cp	r18, r24
    6f12:	39 07       	cpc	r19, r25
    6f14:	dc f0       	brlt	.+54     	; 0x6f4c <GetByteFromFIFO+0xba>
				GSM_RX_FIFOMax = GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End  + GSM_RX_FIFO_Begin;
		GSM_RX_FIFO_End++;
    6f16:	8e 2f       	mov	r24, r30
    6f18:	8f 5f       	subi	r24, 0xFF	; 255
    6f1a:	80 93 4a 06 	sts	0x064A, r24
		if(GSM_RX_FIFO_End >= GSM_RX_FIFO_SIZE) GSM_RX_FIFO_End = 0;
    6f1e:	84 36       	cpi	r24, 0x64	; 100
    6f20:	10 f0       	brcs	.+4      	; 0x6f26 <GetByteFromFIFO+0x94>
    6f22:	10 92 4a 06 	sts	0x064A, r1
		ReadBuf[*Index] = GSM_RX_FIFO[GSM_RX_FIFO_End];
    6f26:	88 81       	ld	r24, Y
    6f28:	08 0f       	add	r16, r24
    6f2a:	11 1d       	adc	r17, r1
    6f2c:	e0 91 4a 06 	lds	r30, 0x064A
    6f30:	f0 e0       	ldi	r31, 0x00	; 0
    6f32:	e8 52       	subi	r30, 0x28	; 40
    6f34:	fa 4f       	sbci	r31, 0xFA	; 250
    6f36:	80 81       	ld	r24, Z
    6f38:	f8 01       	movw	r30, r16
    6f3a:	80 83       	st	Z, r24
		*Index=*Index+1;
    6f3c:	88 81       	ld	r24, Y
    6f3e:	8f 5f       	subi	r24, 0xFF	; 255
    6f40:	88 83       	st	Y, r24
	}
}
    6f42:	df 91       	pop	r29
    6f44:	cf 91       	pop	r28
    6f46:	1f 91       	pop	r17
    6f48:	0f 91       	pop	r16
    6f4a:	08 95       	ret
		*Index=*Index+1;
	}
	if(GSM_RX_FIFO_End > GSM_RX_FIFO_Begin){
		if((GSM_RX_FIFO_End != 255)&&(GSM_RX_FIFO_End != 255))
			if(GSM_RX_FIFOMax < (GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End  + GSM_RX_FIFO_Begin))
				GSM_RX_FIFOMax = GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End  + GSM_RX_FIFO_Begin;
    6f4c:	80 91 f0 06 	lds	r24, 0x06F0
    6f50:	8c 59       	subi	r24, 0x9C	; 156
    6f52:	8e 1b       	sub	r24, r30
    6f54:	80 93 c7 08 	sts	0x08C7, r24
    6f58:	de cf       	rjmp	.-68     	; 0x6f16 <GetByteFromFIFO+0x84>
	}	

	if(GSM_RX_FIFO_Begin > GSM_RX_FIFO_End){
		if((GSM_RX_FIFO_End != 255)&&(GSM_RX_FIFO_End != 255))			
			if(GSM_RX_FIFOMax < (GSM_RX_FIFO_Begin - GSM_RX_FIFO_End))
				GSM_RX_FIFOMax =  GSM_RX_FIFO_Begin - GSM_RX_FIFO_End;
    6f5a:	80 91 f0 06 	lds	r24, 0x06F0
    6f5e:	8e 1b       	sub	r24, r30
    6f60:	80 93 c7 08 	sts	0x08C7, r24
    6f64:	b4 cf       	rjmp	.-152    	; 0x6ece <GetByteFromFIFO+0x3c>

00006f66 <GetStringFromFIFO>:
//        
uint8_t GetStringFromFIFO(void){

	uint8_t StrLength = 0;

	while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    6f66:	90 91 f0 06 	lds	r25, 0x06F0
    6f6a:	80 91 4a 06 	lds	r24, 0x064A
    6f6e:	98 17       	cp	r25, r24
    6f70:	39 f1       	breq	.+78     	; 0x6fc0 <GetStringFromFIFO+0x5a>
		
		GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);
    6f72:	8f e8       	ldi	r24, 0x8F	; 143
    6f74:	97 e0       	ldi	r25, 0x07	; 7
    6f76:	6e e0       	ldi	r22, 0x0E	; 14
    6f78:	7b e0       	ldi	r23, 0x0B	; 11
    6f7a:	44 e6       	ldi	r20, 0x64	; 100
    6f7c:	0e 94 49 37 	call	0x6e92	; 0x6e92 <GetByteFromFIFO>

		//   : xxxxxxxxxxxxxxxx<CR><LF>
		//	'\r' CR - carridge return 0x0D
		//	'\n' LF - line feed 0x0A
		//   xxxxxxxxxxxxxxxx<\0>
		if( (GSM_RxCharN >= 2) && (GSM_RxStr[GSM_RxCharN-2]== '\r') && (GSM_RxStr[GSM_RxCharN-1]== '\n') ){
    6f80:	80 91 0e 0b 	lds	r24, 0x0B0E
    6f84:	82 30       	cpi	r24, 0x02	; 2
    6f86:	78 f3       	brcs	.-34     	; 0x6f66 <GetStringFromFIFO>
    6f88:	e0 91 0e 0b 	lds	r30, 0x0B0E
    6f8c:	f0 e0       	ldi	r31, 0x00	; 0
    6f8e:	e3 57       	subi	r30, 0x73	; 115
    6f90:	f8 4f       	sbci	r31, 0xF8	; 248
    6f92:	80 81       	ld	r24, Z
    6f94:	8d 30       	cpi	r24, 0x0D	; 13
    6f96:	39 f7       	brne	.-50     	; 0x6f66 <GetStringFromFIFO>
    6f98:	e0 91 0e 0b 	lds	r30, 0x0B0E
    6f9c:	f0 e0       	ldi	r31, 0x00	; 0
    6f9e:	e2 57       	subi	r30, 0x72	; 114
    6fa0:	f8 4f       	sbci	r31, 0xF8	; 248
    6fa2:	80 81       	ld	r24, Z
    6fa4:	8a 30       	cpi	r24, 0x0A	; 10
    6fa6:	f9 f6       	brne	.-66     	; 0x6f66 <GetStringFromFIFO>
			GSM_RxStr[GSM_RxCharN-2] = '\0';
    6fa8:	e0 91 0e 0b 	lds	r30, 0x0B0E
    6fac:	f0 e0       	ldi	r31, 0x00	; 0
    6fae:	e3 57       	subi	r30, 0x73	; 115
    6fb0:	f8 4f       	sbci	r31, 0xF8	; 248
    6fb2:	10 82       	st	Z, r1
			StrLength = GSM_RxCharN-1;
    6fb4:	80 91 0e 0b 	lds	r24, 0x0B0E
    6fb8:	81 50       	subi	r24, 0x01	; 1
			GSM_RxCharN = 0;
    6fba:	10 92 0e 0b 	sts	0x0B0E, r1
    6fbe:	08 95       	ret
//        
uint8_t GetStringFromFIFO(void){

	uint8_t StrLength = 0;

	while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    6fc0:	80 e0       	ldi	r24, 0x00	; 0
		}

	}//while
	
	return StrLength;
}
    6fc2:	08 95       	ret

00006fc4 <GetStringFromFIFOwithOverflowDetect>:

uint8_t GetStringFromFIFOwithOverflowDetect(void){
    6fc4:	04 c0       	rjmp	.+8      	; 0x6fce <GetStringFromFIFOwithOverflowDetect+0xa>

		//   : xxxxxxxxxxxxxxxx<CR><LF>
		//	'\r' CR - carridge return 0x0D
		//	'\n' LF - line feed 0x0A
		//   xxxxxxxxxxxxxxxx<\0>
		if( ((GSM_RxCharN >= 2) && (GSM_RxStr[GSM_RxCharN-2]== '\r') && (GSM_RxStr[GSM_RxCharN-1]== '\n'))||(GSM_RxCharN==GSM_RXSTR_SIZE-1) ){
    6fc6:	80 91 0e 0b 	lds	r24, 0x0B0E
    6fca:	83 36       	cpi	r24, 0x63	; 99
    6fcc:	09 f1       	breq	.+66     	; 0x7010 <GetStringFromFIFOwithOverflowDetect+0x4c>

uint8_t GetStringFromFIFOwithOverflowDetect(void){

	uint8_t StrLength = 0;

	while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    6fce:	90 91 f0 06 	lds	r25, 0x06F0
    6fd2:	80 91 4a 06 	lds	r24, 0x064A
    6fd6:	98 17       	cp	r25, r24
    6fd8:	39 f1       	breq	.+78     	; 0x7028 <GetStringFromFIFOwithOverflowDetect+0x64>
		
		GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);
    6fda:	8f e8       	ldi	r24, 0x8F	; 143
    6fdc:	97 e0       	ldi	r25, 0x07	; 7
    6fde:	6e e0       	ldi	r22, 0x0E	; 14
    6fe0:	7b e0       	ldi	r23, 0x0B	; 11
    6fe2:	44 e6       	ldi	r20, 0x64	; 100
    6fe4:	0e 94 49 37 	call	0x6e92	; 0x6e92 <GetByteFromFIFO>

		//   : xxxxxxxxxxxxxxxx<CR><LF>
		//	'\r' CR - carridge return 0x0D
		//	'\n' LF - line feed 0x0A
		//   xxxxxxxxxxxxxxxx<\0>
		if( ((GSM_RxCharN >= 2) && (GSM_RxStr[GSM_RxCharN-2]== '\r') && (GSM_RxStr[GSM_RxCharN-1]== '\n'))||(GSM_RxCharN==GSM_RXSTR_SIZE-1) ){
    6fe8:	80 91 0e 0b 	lds	r24, 0x0B0E
    6fec:	82 30       	cpi	r24, 0x02	; 2
    6fee:	58 f3       	brcs	.-42     	; 0x6fc6 <GetStringFromFIFOwithOverflowDetect+0x2>
    6ff0:	e0 91 0e 0b 	lds	r30, 0x0B0E
    6ff4:	f0 e0       	ldi	r31, 0x00	; 0
    6ff6:	e3 57       	subi	r30, 0x73	; 115
    6ff8:	f8 4f       	sbci	r31, 0xF8	; 248
    6ffa:	80 81       	ld	r24, Z
    6ffc:	8d 30       	cpi	r24, 0x0D	; 13
    6ffe:	19 f7       	brne	.-58     	; 0x6fc6 <GetStringFromFIFOwithOverflowDetect+0x2>
    7000:	e0 91 0e 0b 	lds	r30, 0x0B0E
    7004:	f0 e0       	ldi	r31, 0x00	; 0
    7006:	e2 57       	subi	r30, 0x72	; 114
    7008:	f8 4f       	sbci	r31, 0xF8	; 248
    700a:	80 81       	ld	r24, Z
    700c:	8a 30       	cpi	r24, 0x0A	; 10
    700e:	d9 f6       	brne	.-74     	; 0x6fc6 <GetStringFromFIFOwithOverflowDetect+0x2>
			GSM_RxStr[GSM_RxCharN-2] = '\0';
    7010:	e0 91 0e 0b 	lds	r30, 0x0B0E
    7014:	f0 e0       	ldi	r31, 0x00	; 0
    7016:	e3 57       	subi	r30, 0x73	; 115
    7018:	f8 4f       	sbci	r31, 0xF8	; 248
    701a:	10 82       	st	Z, r1
			StrLength = GSM_RxCharN-1;
    701c:	80 91 0e 0b 	lds	r24, 0x0B0E
    7020:	81 50       	subi	r24, 0x01	; 1
			GSM_RxCharN = 0;
    7022:	10 92 0e 0b 	sts	0x0B0E, r1
    7026:	08 95       	ret

uint8_t GetStringFromFIFOwithOverflowDetect(void){

	uint8_t StrLength = 0;

	while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    7028:	80 e0       	ldi	r24, 0x00	; 0
		}

	}//while
	
	return StrLength;
}
    702a:	08 95       	ret

0000702c <ForceEndStringFromFIFO>:
// ~~~~~~~~~~~
//    GSM_RxStr  <CR><LF>
uint8_t ForceEndStringFromFIFO(void){
	uint8_t StrLength;
	if(GSM_RxCharN > GSM_RXSTR_SIZE-1) GSM_RxCharN = GSM_RXSTR_SIZE-1;
    702c:	80 91 0e 0b 	lds	r24, 0x0B0E
    7030:	84 36       	cpi	r24, 0x64	; 100
    7032:	18 f0       	brcs	.+6      	; 0x703a <ForceEndStringFromFIFO+0xe>
    7034:	83 e6       	ldi	r24, 0x63	; 99
    7036:	80 93 0e 0b 	sts	0x0B0E, r24
	StrLength = GSM_RxCharN;
    703a:	80 91 0e 0b 	lds	r24, 0x0B0E
	GSM_RxStr[GSM_RxCharN]='\0';
    703e:	e0 91 0e 0b 	lds	r30, 0x0B0E
    7042:	f0 e0       	ldi	r31, 0x00	; 0
    7044:	e1 57       	subi	r30, 0x71	; 113
    7046:	f8 4f       	sbci	r31, 0xF8	; 248
    7048:	10 82       	st	Z, r1
	GSM_RxCharN = 0;
    704a:	10 92 0e 0b 	sts	0x0B0E, r1
	return StrLength;
}
    704e:	08 95       	ret

00007050 <GetDataFromFIFO>:

// ~~~~~~~~~~~
uint8_t GetDataFromFIFO(const uint8_t Amount){
    7050:	1f 93       	push	r17
    7052:	18 2f       	mov	r17, r24

	while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    7054:	90 91 f0 06 	lds	r25, 0x06F0
    7058:	80 91 4a 06 	lds	r24, 0x064A
    705c:	98 17       	cp	r25, r24
    705e:	81 f0       	breq	.+32     	; 0x7080 <GetDataFromFIFO+0x30>
		GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);
    7060:	8f e8       	ldi	r24, 0x8F	; 143
    7062:	97 e0       	ldi	r25, 0x07	; 7
    7064:	6e e0       	ldi	r22, 0x0E	; 14
    7066:	7b e0       	ldi	r23, 0x0B	; 11
    7068:	44 e6       	ldi	r20, 0x64	; 100
    706a:	0e 94 49 37 	call	0x6e92	; 0x6e92 <GetByteFromFIFO>
		if(GSM_RxCharN >= Amount){
    706e:	80 91 0e 0b 	lds	r24, 0x0B0E
    7072:	81 17       	cp	r24, r17
    7074:	78 f3       	brcs	.-34     	; 0x7054 <GetDataFromFIFO+0x4>
			GSM_RxCharN = 0;
    7076:	10 92 0e 0b 	sts	0x0B0E, r1
			return Amount;
		}
	}//while
	return GSM_RxCharN;
}
    707a:	81 2f       	mov	r24, r17
    707c:	1f 91       	pop	r17
    707e:	08 95       	ret
		if(GSM_RxCharN >= Amount){
			GSM_RxCharN = 0;
			return Amount;
		}
	}//while
	return GSM_RxCharN;
    7080:	10 91 0e 0b 	lds	r17, 0x0B0E
}
    7084:	81 2f       	mov	r24, r17
    7086:	1f 91       	pop	r17
    7088:	08 95       	ret

0000708a <GSM_Init>:
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    708a:	8f ef       	ldi	r24, 0xFF	; 255
    708c:	80 93 f0 06 	sts	0x06F0, r24
	GSM_RX_FIFO_End = 255;
    7090:	80 93 4a 06 	sts	0x064A, r24
	GSM_RxCharN = 0;
    7094:	10 92 0e 0b 	sts	0x0B0E, r1
	GSM_RX_FIFOOverFlow = 0;
    7098:	10 92 c1 08 	sts	0x08C1, r1
	GSM_RX_FIFOMax = 0;
    709c:	10 92 c7 08 	sts	0x08C7, r1
		USART_GSM.BAUDCTRLB = 0x00 + USART_BSCALE0_bm;
		USART_GSM.CTRLA = USART_RXCINTLVL_HI_gc;
		USART_GSM.CTRLB = (1<<USART_RXEN_bp) | (1<<USART_TXEN_bp) | (0<<USART_CLK2X_bp) | (0 << USART_MPCM_bp) | (0 << USART_TXB8_bp);
		USART_GSM.CTRLC = USART_CMODE_ASYNCHRONOUS_gc | USART_PMODE_DISABLED_gc | (0<< USART_SBMODE_bp) | USART_CHSIZE_8BIT_gc;
	#else
		UCSR_GSM_A = ~(1<<U2X_GSM) &~(1<<MPCM_GSM);
    70a0:	8c ef       	ldi	r24, 0xFC	; 252
    70a2:	80 93 d0 00 	sts	0x00D0, r24
		UCSR_GSM_B =  (1<<RXCIE_GSM) | (0<<TXCIE_GSM) | (0<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    70a6:	88 e9       	ldi	r24, 0x98	; 152
    70a8:	80 93 d1 00 	sts	0x00D1, r24
		#if defined (__AVR_ATmega2561__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__)			
			UCSR_GSM_C = (0<<UMSEL_GSM_1) | (0<<UMSEL_GSM_0) | (0<<UPM_GSM_1) | (0<<UPM_GSM_0) | (0<<USBS_GSM) | (1<<UCSZ_GSM_1) | (1<<UCSZ_GSM_0) | (0<<UCPOL_GSM);
    70ac:	86 e0       	ldi	r24, 0x06	; 6
    70ae:	80 93 d2 00 	sts	0x00D2, r24
		#else
			UCSR_GSM_C = ((~(1<<UMSEL_GSM) &~(1<<UPM_GSM_1) &~(1<<UPM_GSM_0) &~(1<<USBS_GSM)) |(1<<UCSZ_GSM_1) |(1<<UCSZ_GSM_0)) &~(1<<UCPOL_GSM);
		#endif
		UBRR_GSM_H = 0x00;
    70b2:	10 92 d5 00 	sts	0x00D5, r1
		UBRR_GSM_L = 0x67;	// 9600
    70b6:	87 e6       	ldi	r24, 0x67	; 103
    70b8:	80 93 d4 00 	sts	0x00D4, r24
#endif

//  gsm_sim900r.h   PWRCNTRL
#ifdef vmd2_3
	void GSM_PWRCNTRL_Config(void){
		cli();
    70bc:	f8 94       	cli
		DDRL|=(1<<PL5);
    70be:	ea e0       	ldi	r30, 0x0A	; 10
    70c0:	f1 e0       	ldi	r31, 0x01	; 1
    70c2:	80 81       	ld	r24, Z
    70c4:	80 62       	ori	r24, 0x20	; 32
    70c6:	80 83       	st	Z, r24
		sei();
    70c8:	78 94       	sei
		cli();
		PORTL|=(1<<PL5);
		sei();
	}
	void GSM_PWRCNTRL_ON(void){
		cli();
    70ca:	f8 94       	cli
		PORTL &= ~(1<<PL5);
    70cc:	eb e0       	ldi	r30, 0x0B	; 11
    70ce:	f1 e0       	ldi	r31, 0x01	; 1
    70d0:	80 81       	ld	r24, Z
    70d2:	8f 7d       	andi	r24, 0xDF	; 223
    70d4:	80 83       	st	Z, r24
		sei();
    70d6:	78 94       	sei

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    70d8:	80 91 cd 02 	lds	r24, 0x02CD
	VacantTimer16Sys += n;
    70dc:	98 2f       	mov	r25, r24
    70de:	9f 5f       	subi	r25, 0xFF	; 255
	GSM_PWRCNTRL_ON();
	#ifdef GSM_HW_FLOW_CONTROL
		GSM_CTS_RTS_Config();
	#endif

	TD_GSM = Timer16SysAlloc(1);
    70e0:	80 93 e0 04 	sts	0x04E0, r24
    70e4:	29 2f       	mov	r18, r25
    70e6:	2f 5f       	subi	r18, 0xFF	; 255
	TD_TCP_Connect = Timer16SysAlloc(1);
    70e8:	90 93 e1 04 	sts	0x04E1, r25

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer32SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer32Sys;
    70ec:	90 91 ce 02 	lds	r25, 0x02CE
	VacantTimer32Sys += n;
    70f0:	89 2f       	mov	r24, r25
    70f2:	8f 5f       	subi	r24, 0xFF	; 255
	TD_GSM_Reset = Timer32SysAlloc(1);
    70f4:	90 93 e2 04 	sts	0x04E2, r25
// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
	VacantTimer16Sys += n;
    70f8:	92 2f       	mov	r25, r18
    70fa:	9f 5f       	subi	r25, 0xFF	; 255
	TD_5min_timer = Timer16SysAlloc(1);
    70fc:	20 93 e3 04 	sts	0x04E3, r18
// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer32SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer32Sys;
	VacantTimer32Sys += n;
    7100:	8f 5f       	subi	r24, 0xFF	; 255
    7102:	80 93 ce 02 	sts	0x02CE, r24
    7106:	81 50       	subi	r24, 0x01	; 1
	TD_1hour_resetGPRS_timer = Timer32SysAlloc(1);
    7108:	80 93 e4 04 	sts	0x04E4, r24
// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
	VacantTimer16Sys += n;
    710c:	89 2f       	mov	r24, r25
    710e:	8f 5f       	subi	r24, 0xFF	; 255
	TD_CheckModem = Timer16SysAlloc(1);
    7110:	90 93 e5 04 	sts	0x04E5, r25
    7114:	9e 5f       	subi	r25, 0xFE	; 254
	TD_CleanFIFO = Timer16SysAlloc(1);
    7116:	80 93 e6 04 	sts	0x04E6, r24
    711a:	8e 5f       	subi	r24, 0xFE	; 254
	TD_data_start_delay = Timer16SysAlloc(1);
    711c:	90 93 e7 04 	sts	0x04E7, r25
    7120:	8f 5f       	subi	r24, 0xFF	; 255
    7122:	80 93 cd 02 	sts	0x02CD, r24
    7126:	81 50       	subi	r24, 0x01	; 1
	TD_timer_after_page_transfer = Timer16SysAlloc(1);
    7128:	80 93 e8 04 	sts	0x04E8, r24

/*	for (uint8_t i=0; i<4; i++)
		GPRS_ServerAddr[i] = erb(GPRS_ServerAddr_EE+i);
*/
	GSM_Control = GSM_CNTL_AUTO;
    712c:	10 92 80 07 	sts	0x0780, r1
	GSM_State = GSM_PowerOn;
    7130:	10 92 ac 06 	sts	0x06AC, r1



}
    7134:	08 95       	ret

00007136 <GSM_RX>:
// ~~~~~~~~~
void
GSM_RX(void)
{
	char Char = UDR_GSM;
    7136:	90 91 d6 00 	lds	r25, 0x00D6

	//---FIFO
	GSM_RX_FIFO_Begin++;
    713a:	80 91 f0 06 	lds	r24, 0x06F0
    713e:	8f 5f       	subi	r24, 0xFF	; 255
    7140:	80 93 f0 06 	sts	0x06F0, r24
	if(GSM_RX_FIFO_Begin >= GSM_RX_FIFO_SIZE) GSM_RX_FIFO_Begin = 0;
    7144:	80 91 f0 06 	lds	r24, 0x06F0
    7148:	84 36       	cpi	r24, 0x64	; 100
    714a:	10 f0       	brcs	.+4      	; 0x7150 <GSM_RX+0x1a>
    714c:	10 92 f0 06 	sts	0x06F0, r1
	GSM_RX_FIFO[GSM_RX_FIFO_Begin] = Char;
    7150:	e0 91 f0 06 	lds	r30, 0x06F0
    7154:	f0 e0       	ldi	r31, 0x00	; 0
    7156:	e8 52       	subi	r30, 0x28	; 40
    7158:	fa 4f       	sbci	r31, 0xFA	; 250
    715a:	90 83       	st	Z, r25
	if(GSM_RX_FIFO_Begin == GSM_RX_FIFO_End){
    715c:	90 91 f0 06 	lds	r25, 0x06F0
    7160:	80 91 4a 06 	lds	r24, 0x064A
    7164:	98 13       	cpse	r25, r24
    7166:	08 95       	ret
		GSM_RX_FIFOOverFlow = 1;
    7168:	81 e0       	ldi	r24, 0x01	; 1
    716a:	80 93 c1 08 	sts	0x08C1, r24
		GSM_RX_FIFOMax = GSM_RX_FIFO_SIZE;
    716e:	84 e6       	ldi	r24, 0x64	; 100
    7170:	80 93 c7 08 	sts	0x08C7, r24
    7174:	08 95       	ret

00007176 <GSM_Wait_Char>:
		else return 1;
	}
	else return 0;
}
// ~~~~~~~~~
uint8_t GSM_Wait_Char(char Char, uint8_t RestoreCMD){
    7176:	0f 93       	push	r16
    7178:	1f 93       	push	r17
    717a:	08 2f       	mov	r16, r24
    717c:	16 2f       	mov	r17, r22
	if(Timer16Stopp(TD_GSM)){
    717e:	80 91 e0 04 	lds	r24, 0x04E0
    7182:	0e 94 41 1b 	call	0x3682	; 0x3682 <Timer16Stopp>
    7186:	88 23       	and	r24, r24
    7188:	39 f0       	breq	.+14     	; 0x7198 <GSM_Wait_Char+0x22>
		GSM_State = RestoreCMD;
    718a:	10 93 ac 06 	sts	0x06AC, r17
    718e:	90 e0       	ldi	r25, 0x00	; 0
	if(GetDataFromFIFO(1)){
		if(GSM_RxStr[0] == Char)	return 1;
		else return 0;
	}
	else return 0;
}
    7190:	89 2f       	mov	r24, r25
    7192:	1f 91       	pop	r17
    7194:	0f 91       	pop	r16
    7196:	08 95       	ret
	if(Timer16Stopp(TD_GSM)){
		GSM_State = RestoreCMD;
		return 0;
	}
	//   
	if(GetDataFromFIFO(1)){
    7198:	81 e0       	ldi	r24, 0x01	; 1
    719a:	0e 94 28 38 	call	0x7050	; 0x7050 <GetDataFromFIFO>
    719e:	88 23       	and	r24, r24
    71a0:	39 f0       	breq	.+14     	; 0x71b0 <GSM_Wait_Char+0x3a>
    71a2:	90 e0       	ldi	r25, 0x00	; 0
    71a4:	80 91 8f 07 	lds	r24, 0x078F
    71a8:	80 17       	cp	r24, r16
    71aa:	91 f7       	brne	.-28     	; 0x7190 <GSM_Wait_Char+0x1a>
    71ac:	91 e0       	ldi	r25, 0x01	; 1
    71ae:	f0 cf       	rjmp	.-32     	; 0x7190 <GSM_Wait_Char+0x1a>
    71b0:	90 e0       	ldi	r25, 0x00	; 0
		if(GSM_RxStr[0] == Char)	return 1;
		else return 0;
	}
	else return 0;
}
    71b2:	89 2f       	mov	r24, r25
    71b4:	1f 91       	pop	r17
    71b6:	0f 91       	pop	r16
    71b8:	08 95       	ret

000071ba <GSM_SendFirstChar>:
// ~~~~~~~~~
void GSM_SendFirstChar(void){

	UDR_GSM = GSM_TxStr[0];
    71ba:	80 91 f8 09 	lds	r24, 0x09F8
    71be:	80 93 d6 00 	sts	0x00D6, r24
	#ifdef GSM_DEBUG
		GPRS_TerminalProcess(GSM_TxStr[0]);
	#endif

	GSM_TxCharN = 1;
    71c2:	81 e0       	ldi	r24, 0x01	; 1
    71c4:	80 93 17 0b 	sts	0x0B17, r24
	cli();
    71c8:	f8 94       	cli
	GSM_Flag &=~(1<<flg_TxCStr);	
    71ca:	80 91 cf 02 	lds	r24, 0x02CF
    71ce:	8e 7f       	andi	r24, 0xFE	; 254
    71d0:	80 93 cf 02 	sts	0x02CF, r24
	sei();
    71d4:	78 94       	sei
	cli();
    71d6:	f8 94       	cli
	#if defined (__AVR_ATxmega128A1__)
		USART_GSM.CTRLA = USART_RXCINTLVL_HI_gc | USART_DREINTLVL_HI_gc;
	#else
		UCSR_GSM_B =  (1<<RXCIE_GSM) | (0<<TXCIE_GSM) | (1<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    71d8:	88 eb       	ldi	r24, 0xB8	; 184
    71da:	80 93 d1 00 	sts	0x00D1, r24
	#endif
	
	sei();	
    71de:	78 94       	sei
}
    71e0:	08 95       	ret

000071e2 <GSM_DRE>:
		StartTimer16(TD_GSM, Timeout);
	}
}
// ~~~~~~~~~
void GSM_DRE(void){
	if(GSM_TxCharN < GSMTxSz){
    71e2:	90 91 17 0b 	lds	r25, 0x0B17
    71e6:	80 91 6b 07 	lds	r24, 0x076B
    71ea:	98 17       	cp	r25, r24
    71ec:	20 f0       	brcs	.+8      	; 0x71f6 <GSM_DRE+0x14>
	}
	else{
		#if defined (__AVR_ATxmega128A1__)
			USART_GSM.CTRLA = USART_RXCINTLVL_HI_gc | USART_TXCINTLVL_HI_gc;
		#else
			UCSR_GSM_B =  (1<<RXCIE_GSM) | (1<<TXCIE_GSM) | (0<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    71ee:	88 ed       	ldi	r24, 0xD8	; 216
    71f0:	80 93 d1 00 	sts	0x00D1, r24
    71f4:	08 95       	ret
	}
}
// ~~~~~~~~~
void GSM_DRE(void){
	if(GSM_TxCharN < GSMTxSz){
		UDR_GSM = GSM_TxStr[GSM_TxCharN];
    71f6:	e0 91 17 0b 	lds	r30, 0x0B17
    71fa:	f0 e0       	ldi	r31, 0x00	; 0
    71fc:	e8 50       	subi	r30, 0x08	; 8
    71fe:	f6 4f       	sbci	r31, 0xF6	; 246
    7200:	80 81       	ld	r24, Z
    7202:	80 93 d6 00 	sts	0x00D6, r24
		#ifdef GSM_DEBUG
			GPRS_TerminalProcess(GSM_TxStr[GSM_TxCharN]);
		#endif
		GSM_TxCharN++;
    7206:	80 91 17 0b 	lds	r24, 0x0B17
    720a:	8f 5f       	subi	r24, 0xFF	; 255
    720c:	80 93 17 0b 	sts	0x0B17, r24
    7210:	08 95       	ret

00007212 <GSM_TX>:
}
// ~~~~~~~~~
void
GSM_TX(void)
{
	GSM_Flag |=(1<<flg_TxCStr);
    7212:	80 91 cf 02 	lds	r24, 0x02CF
    7216:	81 60       	ori	r24, 0x01	; 1
    7218:	80 93 cf 02 	sts	0x02CF, r24
	if(dataSendFlg){
    721c:	80 91 da 02 	lds	r24, 0x02DA
    7220:	88 23       	and	r24, r24
    7222:	21 f0       	breq	.+8      	; 0x722c <GSM_TX+0x1a>
	dataSendFlg=0;
    7224:	10 92 da 02 	sts	0x02DA, r1
	GPRS_FlgSz_Out=0;
    7228:	10 92 63 07 	sts	0x0763, r1
	}
	#if defined (__AVR_ATxmega128A1__)
		USART_GSM.CTRLA = USART_RXCINTLVL_HI_gc;
	#else
		UCSR_GSM_B =  (1<<RXCIE_GSM) | (0<<TXCIE_GSM) | (0<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    722c:	88 e9       	ldi	r24, 0x98	; 152
    722e:	80 93 d1 00 	sts	0x00D1, r24
	#endif
}
    7232:	08 95       	ret

00007234 <GSM_Reset>:
GSM_Reset(void)
{
/*	IntOff();
	GSM_State = GSM_Restart;
	IntOn();*/
}
    7234:	08 95       	ret

00007236 <GSM_GotoNextVega>:

uint8_t GSM_GotoNextVega(void){
 return 0;
}
    7236:	80 e0       	ldi	r24, 0x00	; 0
    7238:	08 95       	ret

0000723a <GPRS_ServerAddr_Save>:
// ~~~~~~~~~~~~~~~~~~~~~~~~
void
GPRS_ServerAddr_Save(void)
{

}
    723a:	08 95       	ret

0000723c <__vector_25>:
#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__)
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	#ifdef vmd2_3
		// ~~~~~~~~~~
		// USART0 - PORT0
		Modbus_ISR(0)
    723c:	1f 92       	push	r1
    723e:	0f 92       	push	r0
    7240:	0f b6       	in	r0, 0x3f	; 63
    7242:	0f 92       	push	r0
    7244:	0b b6       	in	r0, 0x3b	; 59
    7246:	0f 92       	push	r0
    7248:	11 24       	eor	r1, r1
    724a:	2f 93       	push	r18
    724c:	3f 93       	push	r19
    724e:	4f 93       	push	r20
    7250:	5f 93       	push	r21
    7252:	6f 93       	push	r22
    7254:	7f 93       	push	r23
    7256:	8f 93       	push	r24
    7258:	9f 93       	push	r25
    725a:	af 93       	push	r26
    725c:	bf 93       	push	r27
    725e:	ef 93       	push	r30
    7260:	ff 93       	push	r31
    7262:	86 ec       	ldi	r24, 0xC6	; 198
    7264:	90 e0       	ldi	r25, 0x00	; 0
    7266:	0e 94 1b 29 	call	0x5236	; 0x5236 <Modbus_RX>
    726a:	ff 91       	pop	r31
    726c:	ef 91       	pop	r30
    726e:	bf 91       	pop	r27
    7270:	af 91       	pop	r26
    7272:	9f 91       	pop	r25
    7274:	8f 91       	pop	r24
    7276:	7f 91       	pop	r23
    7278:	6f 91       	pop	r22
    727a:	5f 91       	pop	r21
    727c:	4f 91       	pop	r20
    727e:	3f 91       	pop	r19
    7280:	2f 91       	pop	r18
    7282:	0f 90       	pop	r0
    7284:	0b be       	out	0x3b, r0	; 59
    7286:	0f 90       	pop	r0
    7288:	0f be       	out	0x3f, r0	; 63
    728a:	0f 90       	pop	r0
    728c:	1f 90       	pop	r1
    728e:	18 95       	reti

00007290 <__vector_27>:
    7290:	1f 92       	push	r1
    7292:	0f 92       	push	r0
    7294:	0f b6       	in	r0, 0x3f	; 63
    7296:	0f 92       	push	r0
    7298:	0b b6       	in	r0, 0x3b	; 59
    729a:	0f 92       	push	r0
    729c:	11 24       	eor	r1, r1
    729e:	2f 93       	push	r18
    72a0:	3f 93       	push	r19
    72a2:	4f 93       	push	r20
    72a4:	5f 93       	push	r21
    72a6:	6f 93       	push	r22
    72a8:	7f 93       	push	r23
    72aa:	8f 93       	push	r24
    72ac:	9f 93       	push	r25
    72ae:	af 93       	push	r26
    72b0:	bf 93       	push	r27
    72b2:	ef 93       	push	r30
    72b4:	ff 93       	push	r31
    72b6:	86 ec       	ldi	r24, 0xC6	; 198
    72b8:	90 e0       	ldi	r25, 0x00	; 0
    72ba:	0e 94 ba 34 	call	0x6974	; 0x6974 <Modbus_TX>
    72be:	ff 91       	pop	r31
    72c0:	ef 91       	pop	r30
    72c2:	bf 91       	pop	r27
    72c4:	af 91       	pop	r26
    72c6:	9f 91       	pop	r25
    72c8:	8f 91       	pop	r24
    72ca:	7f 91       	pop	r23
    72cc:	6f 91       	pop	r22
    72ce:	5f 91       	pop	r21
    72d0:	4f 91       	pop	r20
    72d2:	3f 91       	pop	r19
    72d4:	2f 91       	pop	r18
    72d6:	0f 90       	pop	r0
    72d8:	0b be       	out	0x3b, r0	; 59
    72da:	0f 90       	pop	r0
    72dc:	0f be       	out	0x3f, r0	; 63
    72de:	0f 90       	pop	r0
    72e0:	1f 90       	pop	r1
    72e2:	18 95       	reti

000072e4 <__vector_26>:
    72e4:	1f 92       	push	r1
    72e6:	0f 92       	push	r0
    72e8:	0f b6       	in	r0, 0x3f	; 63
    72ea:	0f 92       	push	r0
    72ec:	0b b6       	in	r0, 0x3b	; 59
    72ee:	0f 92       	push	r0
    72f0:	11 24       	eor	r1, r1
    72f2:	2f 93       	push	r18
    72f4:	3f 93       	push	r19
    72f6:	4f 93       	push	r20
    72f8:	5f 93       	push	r21
    72fa:	6f 93       	push	r22
    72fc:	7f 93       	push	r23
    72fe:	8f 93       	push	r24
    7300:	9f 93       	push	r25
    7302:	af 93       	push	r26
    7304:	bf 93       	push	r27
    7306:	ef 93       	push	r30
    7308:	ff 93       	push	r31
    730a:	86 ec       	ldi	r24, 0xC6	; 198
    730c:	90 e0       	ldi	r25, 0x00	; 0
    730e:	0e 94 ba 34 	call	0x6974	; 0x6974 <Modbus_TX>
    7312:	ff 91       	pop	r31
    7314:	ef 91       	pop	r30
    7316:	bf 91       	pop	r27
    7318:	af 91       	pop	r26
    731a:	9f 91       	pop	r25
    731c:	8f 91       	pop	r24
    731e:	7f 91       	pop	r23
    7320:	6f 91       	pop	r22
    7322:	5f 91       	pop	r21
    7324:	4f 91       	pop	r20
    7326:	3f 91       	pop	r19
    7328:	2f 91       	pop	r18
    732a:	0f 90       	pop	r0
    732c:	0b be       	out	0x3b, r0	; 59
    732e:	0f 90       	pop	r0
    7330:	0f be       	out	0x3f, r0	; 63
    7332:	0f 90       	pop	r0
    7334:	1f 90       	pop	r1
    7336:	18 95       	reti

00007338 <__vector_36>:

		// ~~~~~~~~~~
		// USART1 - PORT1
		Modbus_ISR(1)
    7338:	1f 92       	push	r1
    733a:	0f 92       	push	r0
    733c:	0f b6       	in	r0, 0x3f	; 63
    733e:	0f 92       	push	r0
    7340:	0b b6       	in	r0, 0x3b	; 59
    7342:	0f 92       	push	r0
    7344:	11 24       	eor	r1, r1
    7346:	2f 93       	push	r18
    7348:	3f 93       	push	r19
    734a:	4f 93       	push	r20
    734c:	5f 93       	push	r21
    734e:	6f 93       	push	r22
    7350:	7f 93       	push	r23
    7352:	8f 93       	push	r24
    7354:	9f 93       	push	r25
    7356:	af 93       	push	r26
    7358:	bf 93       	push	r27
    735a:	ef 93       	push	r30
    735c:	ff 93       	push	r31
    735e:	8e ec       	ldi	r24, 0xCE	; 206
    7360:	90 e0       	ldi	r25, 0x00	; 0
    7362:	0e 94 1b 29 	call	0x5236	; 0x5236 <Modbus_RX>
    7366:	ff 91       	pop	r31
    7368:	ef 91       	pop	r30
    736a:	bf 91       	pop	r27
    736c:	af 91       	pop	r26
    736e:	9f 91       	pop	r25
    7370:	8f 91       	pop	r24
    7372:	7f 91       	pop	r23
    7374:	6f 91       	pop	r22
    7376:	5f 91       	pop	r21
    7378:	4f 91       	pop	r20
    737a:	3f 91       	pop	r19
    737c:	2f 91       	pop	r18
    737e:	0f 90       	pop	r0
    7380:	0b be       	out	0x3b, r0	; 59
    7382:	0f 90       	pop	r0
    7384:	0f be       	out	0x3f, r0	; 63
    7386:	0f 90       	pop	r0
    7388:	1f 90       	pop	r1
    738a:	18 95       	reti

0000738c <__vector_38>:
    738c:	1f 92       	push	r1
    738e:	0f 92       	push	r0
    7390:	0f b6       	in	r0, 0x3f	; 63
    7392:	0f 92       	push	r0
    7394:	0b b6       	in	r0, 0x3b	; 59
    7396:	0f 92       	push	r0
    7398:	11 24       	eor	r1, r1
    739a:	2f 93       	push	r18
    739c:	3f 93       	push	r19
    739e:	4f 93       	push	r20
    73a0:	5f 93       	push	r21
    73a2:	6f 93       	push	r22
    73a4:	7f 93       	push	r23
    73a6:	8f 93       	push	r24
    73a8:	9f 93       	push	r25
    73aa:	af 93       	push	r26
    73ac:	bf 93       	push	r27
    73ae:	ef 93       	push	r30
    73b0:	ff 93       	push	r31
    73b2:	8e ec       	ldi	r24, 0xCE	; 206
    73b4:	90 e0       	ldi	r25, 0x00	; 0
    73b6:	0e 94 ba 34 	call	0x6974	; 0x6974 <Modbus_TX>
    73ba:	ff 91       	pop	r31
    73bc:	ef 91       	pop	r30
    73be:	bf 91       	pop	r27
    73c0:	af 91       	pop	r26
    73c2:	9f 91       	pop	r25
    73c4:	8f 91       	pop	r24
    73c6:	7f 91       	pop	r23
    73c8:	6f 91       	pop	r22
    73ca:	5f 91       	pop	r21
    73cc:	4f 91       	pop	r20
    73ce:	3f 91       	pop	r19
    73d0:	2f 91       	pop	r18
    73d2:	0f 90       	pop	r0
    73d4:	0b be       	out	0x3b, r0	; 59
    73d6:	0f 90       	pop	r0
    73d8:	0f be       	out	0x3f, r0	; 63
    73da:	0f 90       	pop	r0
    73dc:	1f 90       	pop	r1
    73de:	18 95       	reti

000073e0 <__vector_37>:
    73e0:	1f 92       	push	r1
    73e2:	0f 92       	push	r0
    73e4:	0f b6       	in	r0, 0x3f	; 63
    73e6:	0f 92       	push	r0
    73e8:	0b b6       	in	r0, 0x3b	; 59
    73ea:	0f 92       	push	r0
    73ec:	11 24       	eor	r1, r1
    73ee:	2f 93       	push	r18
    73f0:	3f 93       	push	r19
    73f2:	4f 93       	push	r20
    73f4:	5f 93       	push	r21
    73f6:	6f 93       	push	r22
    73f8:	7f 93       	push	r23
    73fa:	8f 93       	push	r24
    73fc:	9f 93       	push	r25
    73fe:	af 93       	push	r26
    7400:	bf 93       	push	r27
    7402:	ef 93       	push	r30
    7404:	ff 93       	push	r31
    7406:	8e ec       	ldi	r24, 0xCE	; 206
    7408:	90 e0       	ldi	r25, 0x00	; 0
    740a:	0e 94 ba 34 	call	0x6974	; 0x6974 <Modbus_TX>
    740e:	ff 91       	pop	r31
    7410:	ef 91       	pop	r30
    7412:	bf 91       	pop	r27
    7414:	af 91       	pop	r26
    7416:	9f 91       	pop	r25
    7418:	8f 91       	pop	r24
    741a:	7f 91       	pop	r23
    741c:	6f 91       	pop	r22
    741e:	5f 91       	pop	r21
    7420:	4f 91       	pop	r20
    7422:	3f 91       	pop	r19
    7424:	2f 91       	pop	r18
    7426:	0f 90       	pop	r0
    7428:	0b be       	out	0x3b, r0	; 59
    742a:	0f 90       	pop	r0
    742c:	0f be       	out	0x3f, r0	; 63
    742e:	0f 90       	pop	r0
    7430:	1f 90       	pop	r1
    7432:	18 95       	reti

00007434 <__vector_52>:

		// USART2 - PORT2 (only GSM)
		#ifdef GSM
			#ifndef SIM300DZ
				ISR(USART2_UDRE_vect) {GSM_DRE();}
    7434:	1f 92       	push	r1
    7436:	0f 92       	push	r0
    7438:	0f b6       	in	r0, 0x3f	; 63
    743a:	0f 92       	push	r0
    743c:	0b b6       	in	r0, 0x3b	; 59
    743e:	0f 92       	push	r0
    7440:	11 24       	eor	r1, r1
    7442:	2f 93       	push	r18
    7444:	3f 93       	push	r19
    7446:	4f 93       	push	r20
    7448:	5f 93       	push	r21
    744a:	6f 93       	push	r22
    744c:	7f 93       	push	r23
    744e:	8f 93       	push	r24
    7450:	9f 93       	push	r25
    7452:	af 93       	push	r26
    7454:	bf 93       	push	r27
    7456:	ef 93       	push	r30
    7458:	ff 93       	push	r31
    745a:	0e 94 f1 38 	call	0x71e2	; 0x71e2 <GSM_DRE>
    745e:	ff 91       	pop	r31
    7460:	ef 91       	pop	r30
    7462:	bf 91       	pop	r27
    7464:	af 91       	pop	r26
    7466:	9f 91       	pop	r25
    7468:	8f 91       	pop	r24
    746a:	7f 91       	pop	r23
    746c:	6f 91       	pop	r22
    746e:	5f 91       	pop	r21
    7470:	4f 91       	pop	r20
    7472:	3f 91       	pop	r19
    7474:	2f 91       	pop	r18
    7476:	0f 90       	pop	r0
    7478:	0b be       	out	0x3b, r0	; 59
    747a:	0f 90       	pop	r0
    747c:	0f be       	out	0x3f, r0	; 63
    747e:	0f 90       	pop	r0
    7480:	1f 90       	pop	r1
    7482:	18 95       	reti

00007484 <__vector_53>:
			#endif
			ISR(USART2_TX_vect) {GSM_TX();}
    7484:	1f 92       	push	r1
    7486:	0f 92       	push	r0
    7488:	0f b6       	in	r0, 0x3f	; 63
    748a:	0f 92       	push	r0
    748c:	0b b6       	in	r0, 0x3b	; 59
    748e:	0f 92       	push	r0
    7490:	11 24       	eor	r1, r1
    7492:	2f 93       	push	r18
    7494:	3f 93       	push	r19
    7496:	4f 93       	push	r20
    7498:	5f 93       	push	r21
    749a:	6f 93       	push	r22
    749c:	7f 93       	push	r23
    749e:	8f 93       	push	r24
    74a0:	9f 93       	push	r25
    74a2:	af 93       	push	r26
    74a4:	bf 93       	push	r27
    74a6:	ef 93       	push	r30
    74a8:	ff 93       	push	r31
    74aa:	0e 94 09 39 	call	0x7212	; 0x7212 <GSM_TX>
    74ae:	ff 91       	pop	r31
    74b0:	ef 91       	pop	r30
    74b2:	bf 91       	pop	r27
    74b4:	af 91       	pop	r26
    74b6:	9f 91       	pop	r25
    74b8:	8f 91       	pop	r24
    74ba:	7f 91       	pop	r23
    74bc:	6f 91       	pop	r22
    74be:	5f 91       	pop	r21
    74c0:	4f 91       	pop	r20
    74c2:	3f 91       	pop	r19
    74c4:	2f 91       	pop	r18
    74c6:	0f 90       	pop	r0
    74c8:	0b be       	out	0x3b, r0	; 59
    74ca:	0f 90       	pop	r0
    74cc:	0f be       	out	0x3f, r0	; 63
    74ce:	0f 90       	pop	r0
    74d0:	1f 90       	pop	r1
    74d2:	18 95       	reti

000074d4 <__vector_51>:
			ISR(USART2_RX_vect) {GSM_RX();}
    74d4:	1f 92       	push	r1
    74d6:	0f 92       	push	r0
    74d8:	0f b6       	in	r0, 0x3f	; 63
    74da:	0f 92       	push	r0
    74dc:	0b b6       	in	r0, 0x3b	; 59
    74de:	0f 92       	push	r0
    74e0:	11 24       	eor	r1, r1
    74e2:	2f 93       	push	r18
    74e4:	3f 93       	push	r19
    74e6:	4f 93       	push	r20
    74e8:	5f 93       	push	r21
    74ea:	6f 93       	push	r22
    74ec:	7f 93       	push	r23
    74ee:	8f 93       	push	r24
    74f0:	9f 93       	push	r25
    74f2:	af 93       	push	r26
    74f4:	bf 93       	push	r27
    74f6:	ef 93       	push	r30
    74f8:	ff 93       	push	r31
    74fa:	0e 94 9b 38 	call	0x7136	; 0x7136 <GSM_RX>
    74fe:	ff 91       	pop	r31
    7500:	ef 91       	pop	r30
    7502:	bf 91       	pop	r27
    7504:	af 91       	pop	r26
    7506:	9f 91       	pop	r25
    7508:	8f 91       	pop	r24
    750a:	7f 91       	pop	r23
    750c:	6f 91       	pop	r22
    750e:	5f 91       	pop	r21
    7510:	4f 91       	pop	r20
    7512:	3f 91       	pop	r19
    7514:	2f 91       	pop	r18
    7516:	0f 90       	pop	r0
    7518:	0b be       	out	0x3b, r0	; 59
    751a:	0f 90       	pop	r0
    751c:	0f be       	out	0x3f, r0	; 63
    751e:	0f 90       	pop	r0
    7520:	1f 90       	pop	r1
    7522:	18 95       	reti

00007524 <KeypadInit>:
		for (uint8_t str=0; str<sizeof(KeyStr); str++) {
			uint8_t KS = prb(KeyStr+str);
			DDR_Key &=~KS;
			PortKey |=KS;
		}*/
		DDR_KeyROW1 |= KeyROW1;
    7524:	81 9a       	sbi	0x10, 1	; 16
		DDR_KeyROW2 |= KeyROW2;
    7526:	80 9a       	sbi	0x10, 0	; 16
		PortKeyROW1 |= KeyROW1;
    7528:	89 9a       	sbi	0x11, 1	; 17
		PortKeyROW2 |= KeyROW2;
    752a:	88 9a       	sbi	0x11, 0	; 17
		
		DDR_KeySTR1 &= ~KeySTR1;
    752c:	85 98       	cbi	0x10, 5	; 16
		DDR_KeySTR2 &= ~KeySTR2;
    752e:	84 98       	cbi	0x10, 4	; 16
		DDR_KeySTR3 &= ~KeySTR3;
    7530:	82 98       	cbi	0x10, 2	; 16
		PortKeySTR1 |= KeySTR1;
    7532:	8d 9a       	sbi	0x11, 5	; 17
		PortKeySTR2 |= KeySTR2;
    7534:	8c 9a       	sbi	0x11, 4	; 17
		PortKeySTR3 |= KeySTR3;
    7536:	8a 9a       	sbi	0x11, 2	; 17
}

uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    7538:	80 91 cc 02 	lds	r24, 0x02CC
	VacantTimer8Sys += n;
    753c:	8f 5f       	subi	r24, 0xFF	; 255
    753e:	80 93 cc 02 	sts	0x02CC, r24
    7542:	81 50       	subi	r24, 0x01	; 1
		PORTJ.DIRCLR = (1<<7);
		for (uint8_t str=1; str<sizeof(KeyStr); str++)
			PORTK.DIRCLR = prb(KeyStr+str);
		PORTJ.PIN7CTRL = PORTK.PIN0CTRL = PORTK.PIN1CTRL = PORTK.PIN2CTRL = PORTK.PIN3CTRL = PORT_OPC_PULLUP_gc;
	#endif
	TD_Keypad = Timer8SysAlloc(1);
    7544:	80 93 ea 04 	sts	0x04EA, r24
}
    7548:	08 95       	ret

0000754a <KeypadIn>:
	return KeyPressedNonFilter = Key;
}
// ~~~~~~~~~~~
uint8_t
KeypadIn(void)
{
    754a:	0f 93       	push	r16
    754c:	1f 93       	push	r17
			}
		}
		RowOff(KR);
	}*/

	cli(); PortKeyROW1 &= ~KeyROW1; sei();
    754e:	f8 94       	cli
    7550:	89 98       	cbi	0x11, 1	; 17
    7552:	78 94       	sei
    7554:	85 e3       	ldi	r24, 0x35	; 53
    7556:	8a 95       	dec	r24
    7558:	f1 f7       	brne	.-4      	; 0x7556 <KeypadIn+0xc>
	_delay_us(10);		// By trial
	if(!(PIN_KeySTR1 & (KeySTR1))){ Key=2; PresKeysQuant++;} 
    755a:	7d 99       	sbic	0x0f, 5	; 15
    755c:	38 c0       	rjmp	.+112    	; 0x75ce <KeypadIn+0x84>
    755e:	91 e0       	ldi	r25, 0x01	; 1
    7560:	02 e0       	ldi	r16, 0x02	; 2
	if(!(PIN_KeySTR2 & (KeySTR2))){ Key=6; PresKeysQuant++;} 
    7562:	7c 99       	sbic	0x0f, 4	; 15
    7564:	02 c0       	rjmp	.+4      	; 0x756a <KeypadIn+0x20>
    7566:	9f 5f       	subi	r25, 0xFF	; 255
    7568:	06 e0       	ldi	r16, 0x06	; 6
	if(!(PIN_KeySTR3 & (KeySTR3))){ Key=4; PresKeysQuant++;} 
    756a:	7a 99       	sbic	0x0f, 2	; 15
    756c:	02 c0       	rjmp	.+4      	; 0x7572 <KeypadIn+0x28>
    756e:	9f 5f       	subi	r25, 0xFF	; 255
    7570:	04 e0       	ldi	r16, 0x04	; 4
	cli(); PortKeyROW1 |= KeyROW1; sei();	
    7572:	f8 94       	cli
    7574:	89 9a       	sbi	0x11, 1	; 17
    7576:	78 94       	sei

	cli(); PortKeyROW2 &= ~KeyROW2; sei();
    7578:	f8 94       	cli
    757a:	88 98       	cbi	0x11, 0	; 17
    757c:	78 94       	sei
    757e:	85 e3       	ldi	r24, 0x35	; 53
    7580:	8a 95       	dec	r24
    7582:	f1 f7       	brne	.-4      	; 0x7580 <KeypadIn+0x36>
	_delay_us(10);		// By trial
	if(!(PIN_KeySTR1 & (KeySTR1))){ Key=1; PresKeysQuant++;}
    7584:	7d 99       	sbic	0x0f, 5	; 15
    7586:	02 c0       	rjmp	.+4      	; 0x758c <KeypadIn+0x42>
    7588:	9f 5f       	subi	r25, 0xFF	; 255
    758a:	01 e0       	ldi	r16, 0x01	; 1
	if(!(PIN_KeySTR2 & (KeySTR2))){ Key=5; PresKeysQuant++;}
    758c:	7c 99       	sbic	0x0f, 4	; 15
    758e:	02 c0       	rjmp	.+4      	; 0x7594 <KeypadIn+0x4a>
    7590:	9f 5f       	subi	r25, 0xFF	; 255
    7592:	05 e0       	ldi	r16, 0x05	; 5
	if(!(PIN_KeySTR3 & (KeySTR3))){ Key=3; PresKeysQuant++;}
    7594:	7a 99       	sbic	0x0f, 2	; 15
    7596:	02 c0       	rjmp	.+4      	; 0x759c <KeypadIn+0x52>
    7598:	9f 5f       	subi	r25, 0xFF	; 255
    759a:	03 e0       	ldi	r16, 0x03	; 3
	cli(); PortKeyROW2 |= KeyROW2; sei();
    759c:	f8 94       	cli
    759e:	88 9a       	sbi	0x11, 0	; 17
    75a0:	78 94       	sei
	if(PresKeysQuant!=1) Key = 0;
    75a2:	91 30       	cpi	r25, 0x01	; 1
    75a4:	09 f4       	brne	.+2      	; 0x75a8 <KeypadIn+0x5e>
    75a6:	4a c0       	rjmp	.+148    	; 0x763c <KeypadIn+0xf2>

	return KeyPressedNonFilter = Key;
    75a8:	10 92 bf 08 	sts	0x08BF, r1
    75ac:	00 e0       	ldi	r16, 0x00	; 0
{
	static uint8_t PrevKey;
	uint8_t KeyResult = 0;
	uint8_t Key = KeypadScan();	//   
	if(Key) KeyPressedCounter++;
	if(Key != PrevKey){			//     -   
    75ae:	80 91 dc 02 	lds	r24, 0x02DC
    75b2:	80 17       	cp	r24, r16
    75b4:	11 f0       	breq	.+4      	; 0x75ba <KeypadIn+0x70>
		PrevKey = 0;
    75b6:	10 92 dc 02 	sts	0x02DC, r1
	}
	
	if (Timer8Stopp(TD_Keypad)) {
    75ba:	10 91 ea 04 	lds	r17, 0x04EA
    75be:	81 2f       	mov	r24, r17
    75c0:	0e 94 1e 1b 	call	0x363c	; 0x363c <Timer8Stopp>
    75c4:	88 23       	and	r24, r24
    75c6:	31 f4       	brne	.+12     	; 0x75d4 <KeypadIn+0x8a>
					for(I=0;I<=(KeyQuantity/8);I++) *((uint8_t*)RKEY+I) = 0;
				}
		#endif
	}
	return KeyResult;
}
    75c8:	1f 91       	pop	r17
    75ca:	0f 91       	pop	r16
    75cc:	08 95       	ret
		RowOff(KR);
	}*/

	cli(); PortKeyROW1 &= ~KeyROW1; sei();
	_delay_us(10);		// By trial
	if(!(PIN_KeySTR1 & (KeySTR1))){ Key=2; PresKeysQuant++;} 
    75ce:	90 e0       	ldi	r25, 0x00	; 0
    75d0:	00 e0       	ldi	r16, 0x00	; 0
    75d2:	c7 cf       	rjmp	.-114    	; 0x7562 <KeypadIn+0x18>
	if(Key != PrevKey){			//     -   
		PrevKey = 0;
	}
	
	if (Timer8Stopp(TD_Keypad)) {
		StartTimer8(TD_Keypad, 6);	// By trial keystroke time == 70-180 ms
    75d4:	81 2f       	mov	r24, r17
    75d6:	66 e0       	ldi	r22, 0x06	; 6
    75d8:	0e 94 ca 19 	call	0x3394	; 0x3394 <StartTimer8>
		if (Key != PrevKey) {
    75dc:	80 91 dc 02 	lds	r24, 0x02DC
    75e0:	80 17       	cp	r24, r16
    75e2:	09 f4       	brne	.+2      	; 0x75e6 <KeypadIn+0x9c>
    75e4:	44 c0       	rjmp	.+136    	; 0x766e <KeypadIn+0x124>
				PrevKey = Key;
    75e6:	00 93 dc 02 	sts	0x02DC, r16
				Key = 0;
				KeyStroke = 0;
    75ea:	10 92 e9 04 	sts	0x04E9, r1

		#ifdef RKEY
			#ifdef QslRD
				if(!*(uint8_t*)RNUM)
			#endif
				if (KeyResult==0) {
    75ee:	40 e0       	ldi	r20, 0x00	; 0
    75f0:	50 e0       	ldi	r21, 0x00	; 0
					uint8_t I = 0;
					while (1<<(I++ & 0b00000111) != *((uint8_t*)RKEY+(I>>3)) && I<=KeyQuantity);
    75f2:	a1 e0       	ldi	r26, 0x01	; 1
    75f4:	b0 e0       	ldi	r27, 0x00	; 0

		#ifdef RKEY
			#ifdef QslRD
				if(!*(uint8_t*)RNUM)
			#endif
				if (KeyResult==0) {
    75f6:	e4 2f       	mov	r30, r20
    75f8:	64 2f       	mov	r22, r20
    75fa:	6f 5f       	subi	r22, 0xFF	; 255
					uint8_t I = 0;
					while (1<<(I++ & 0b00000111) != *((uint8_t*)RKEY+(I>>3)) && I<=KeyQuantity);
    75fc:	9a 01       	movw	r18, r20
    75fe:	27 70       	andi	r18, 0x07	; 7
    7600:	30 70       	andi	r19, 0x00	; 0
    7602:	cd 01       	movw	r24, r26
    7604:	02 c0       	rjmp	.+4      	; 0x760a <KeypadIn+0xc0>
    7606:	88 0f       	add	r24, r24
    7608:	99 1f       	adc	r25, r25
    760a:	2a 95       	dec	r18
    760c:	e2 f7       	brpl	.-8      	; 0x7606 <KeypadIn+0xbc>
    760e:	9c 01       	movw	r18, r24
    7610:	e6 95       	lsr	r30
    7612:	e6 95       	lsr	r30
    7614:	e6 95       	lsr	r30
    7616:	f0 e0       	ldi	r31, 0x00	; 0
    7618:	e1 59       	subi	r30, 0x91	; 145
    761a:	f8 4f       	sbci	r31, 0xF8	; 248
    761c:	80 81       	ld	r24, Z
    761e:	90 e0       	ldi	r25, 0x00	; 0
    7620:	28 17       	cp	r18, r24
    7622:	39 07       	cpc	r19, r25
    7624:	b1 f1       	breq	.+108    	; 0x7692 <KeypadIn+0x148>
    7626:	4f 5f       	subi	r20, 0xFF	; 255
    7628:	5f 4f       	sbci	r21, 0xFF	; 255
    762a:	47 30       	cpi	r20, 0x07	; 7
    762c:	51 05       	cpc	r21, r1
    762e:	19 f7       	brne	.-58     	; 0x75f6 <KeypadIn+0xac>
					if (I<=KeyQuantity)
    7630:	80 e0       	ldi	r24, 0x00	; 0
						KeyResult = I;
					for(I=0;I<=(KeyQuantity/8);I++) *((uint8_t*)RKEY+I) = 0;
    7632:	10 92 6f 07 	sts	0x076F, r1
				}
		#endif
	}
	return KeyResult;
}
    7636:	1f 91       	pop	r17
    7638:	0f 91       	pop	r16
    763a:	08 95       	ret
	if(!(PIN_KeySTR2 & (KeySTR2))){ Key=5; PresKeysQuant++;}
	if(!(PIN_KeySTR3 & (KeySTR3))){ Key=3; PresKeysQuant++;}
	cli(); PortKeyROW2 |= KeyROW2; sei();
	if(PresKeysQuant!=1) Key = 0;

	return KeyPressedNonFilter = Key;
    763c:	00 93 bf 08 	sts	0x08BF, r16
KeypadIn(void)
{
	static uint8_t PrevKey;
	uint8_t KeyResult = 0;
	uint8_t Key = KeypadScan();	//   
	if(Key) KeyPressedCounter++;
    7640:	00 23       	and	r16, r16
    7642:	09 f4       	brne	.+2      	; 0x7646 <KeypadIn+0xfc>
    7644:	b4 cf       	rjmp	.-152    	; 0x75ae <KeypadIn+0x64>
    7646:	80 91 ec 06 	lds	r24, 0x06EC
    764a:	90 91 ed 06 	lds	r25, 0x06ED
    764e:	a0 91 ee 06 	lds	r26, 0x06EE
    7652:	b0 91 ef 06 	lds	r27, 0x06EF
    7656:	01 96       	adiw	r24, 0x01	; 1
    7658:	a1 1d       	adc	r26, r1
    765a:	b1 1d       	adc	r27, r1
    765c:	80 93 ec 06 	sts	0x06EC, r24
    7660:	90 93 ed 06 	sts	0x06ED, r25
    7664:	a0 93 ee 06 	sts	0x06EE, r26
    7668:	b0 93 ef 06 	sts	0x06EF, r27
    766c:	a0 cf       	rjmp	.-192    	; 0x75ae <KeypadIn+0x64>
				PrevKey = Key;
				Key = 0;
				KeyStroke = 0;
		}
		else{
			KeyPressed = KeyResult = Key;
    766e:	00 93 62 07 	sts	0x0762, r16
			if(KeyStroke<0xFF && ++KeyStroke>1 && KeyStroke<=0xF) KeyResult = 0;
    7672:	90 91 e9 04 	lds	r25, 0x04E9
    7676:	9f 3f       	cpi	r25, 0xFF	; 255
    7678:	41 f0       	breq	.+16     	; 0x768a <KeypadIn+0x140>
    767a:	9f 5f       	subi	r25, 0xFF	; 255
    767c:	90 93 e9 04 	sts	0x04E9, r25
    7680:	92 30       	cpi	r25, 0x02	; 2
    7682:	18 f0       	brcs	.+6      	; 0x768a <KeypadIn+0x140>
    7684:	90 31       	cpi	r25, 0x10	; 16
    7686:	08 f4       	brcc	.+2      	; 0x768a <KeypadIn+0x140>
    7688:	b2 cf       	rjmp	.-156    	; 0x75ee <KeypadIn+0xa4>

		#ifdef RKEY
			#ifdef QslRD
				if(!*(uint8_t*)RNUM)
			#endif
				if (KeyResult==0) {
    768a:	88 23       	and	r24, r24
    768c:	09 f0       	breq	.+2      	; 0x7690 <KeypadIn+0x146>
    768e:	9c cf       	rjmp	.-200    	; 0x75c8 <KeypadIn+0x7e>
    7690:	ae cf       	rjmp	.-164    	; 0x75ee <KeypadIn+0xa4>
					uint8_t I = 0;
					while (1<<(I++ & 0b00000111) != *((uint8_t*)RKEY+(I>>3)) && I<=KeyQuantity);
					if (I<=KeyQuantity)
    7692:	67 30       	cpi	r22, 0x07	; 7
    7694:	68 f6       	brcc	.-102    	; 0x7630 <KeypadIn+0xe6>
    7696:	86 2f       	mov	r24, r22
    7698:	cc cf       	rjmp	.-104    	; 0x7632 <KeypadIn+0xe8>

0000769a <InitBufStr>:
static uint8_t Minus;
// ~~~~~~~~~~~
char BufStr[LCDXSz+1];
uint8_t CurrFieldSize;

void InitBufStr(OutField *Field){
    769a:	ea eb       	ldi	r30, 0xBA	; 186
    769c:	f5 e0       	ldi	r31, 0x05	; 5
	for(uint8_t i =0; i<LCDXSz; i++) BufStr[i]=' ';
    769e:	80 e2       	ldi	r24, 0x20	; 32
    76a0:	81 93       	st	Z+, r24
    76a2:	95 e0       	ldi	r25, 0x05	; 5
    76a4:	ee 3c       	cpi	r30, 0xCE	; 206
    76a6:	f9 07       	cpc	r31, r25
    76a8:	d9 f7       	brne	.-10     	; 0x76a0 <InitBufStr+0x6>
	BufStr[LCDXSz] ='\0';
    76aa:	10 82       	st	Z, r1
	CurrFieldSize = 0;
    76ac:	10 92 70 07 	sts	0x0770, r1
	MultiSymbol = 0;
    76b0:	10 92 eb 04 	sts	0x04EB, r1
}
    76b4:	08 95       	ret

000076b6 <EventFunc>:

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    76b6:	fc 01       	movw	r30, r24
    76b8:	85 91       	lpm	r24, Z+
    76ba:	94 91       	lpm	r25, Z+
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
EventFunc(const MenuEvent *Event)
{
	MenuEvent Func = prp(Event);
	if (Func)
    76bc:	00 97       	sbiw	r24, 0x00	; 0
    76be:	11 f0       	breq	.+4      	; 0x76c4 <EventFunc+0xe>
		Func();
    76c0:	fc 01       	movw	r30, r24
    76c2:	19 95       	eicall
    76c4:	08 95       	ret

000076c6 <KeyFunc>:
    76c6:	fc 01       	movw	r30, r24
    76c8:	85 91       	lpm	r24, Z+
    76ca:	94 91       	lpm	r25, Z+
// ~~~~~~~~~~~~~~~~~~~~~~~~
static uint8_t
KeyFunc(const MenuKey *Key)
{
	MenuKey Func=prp(Key);
	return Func && Func()==CustomKey;
    76cc:	00 97       	sbiw	r24, 0x00	; 0
    76ce:	51 f0       	breq	.+20     	; 0x76e4 <KeyFunc+0x1e>
    76d0:	fc 01       	movw	r30, r24
    76d2:	19 95       	eicall
    76d4:	90 e0       	ldi	r25, 0x00	; 0
    76d6:	81 30       	cpi	r24, 0x01	; 1
    76d8:	09 f0       	breq	.+2      	; 0x76dc <KeyFunc+0x16>
    76da:	91 e0       	ldi	r25, 0x01	; 1
    76dc:	81 e0       	ldi	r24, 0x01	; 1
    76de:	98 27       	eor	r25, r24
}
    76e0:	89 2f       	mov	r24, r25
    76e2:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~~~
static uint8_t
KeyFunc(const MenuKey *Key)
{
	MenuKey Func=prp(Key);
	return Func && Func()==CustomKey;
    76e4:	90 e0       	ldi	r25, 0x00	; 0
}
    76e6:	89 2f       	mov	r24, r25
    76e8:	08 95       	ret

000076ea <GotoMenu>:

// ~~~~~~~~~~~~~~~~~~~~~
void
GotoMenu(MenuPage *Menu)
{
    76ea:	cf 93       	push	r28
    76ec:	df 93       	push	r29
    76ee:	ec 01       	movw	r28, r24
	EventFunc(&CurrPage->Exit);
    76f0:	80 91 d1 02 	lds	r24, 0x02D1
    76f4:	90 91 d2 02 	lds	r25, 0x02D2
    76f8:	0a 96       	adiw	r24, 0x0a	; 10
    76fa:	0e 94 5b 3b 	call	0x76b6	; 0x76b6 <EventFunc>
    76fe:	fe 01       	movw	r30, r28
    7700:	34 96       	adiw	r30, 0x04	; 4
    7702:	85 91       	lpm	r24, Z+
    7704:	94 91       	lpm	r25, Z+
	if(prp(&Menu->OutPage))
    7706:	89 2b       	or	r24, r25
    7708:	c9 f0       	breq	.+50     	; 0x773c <GotoMenu+0x52>
		MenuDepth=0;
    770a:	10 92 6a 07 	sts	0x076A, r1
	else {
		MenuStack[MenuDepth].Page = CurrPage;
		MenuStack[MenuDepth].Line = CurrLine;
		MenuStack[MenuDepth++].LCD = CurrLCD;
	}
	CurrPage = Menu;
    770e:	d0 93 d2 02 	sts	0x02D2, r29
    7712:	c0 93 d1 02 	sts	0x02D1, r28

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    7716:	23 96       	adiw	r28, 0x03	; 3
    7718:	fe 01       	movw	r30, r28
    771a:	84 91       	lpm	r24, Z+
	CurrLine = CurrLCD = GetFix();
    771c:	80 93 96 08 	sts	0x0896, r24
    7720:	80 93 79 07 	sts	0x0779, r24
	CurrField = CurrPos = NullPos;
    7724:	8f ef       	ldi	r24, 0xFF	; 255
    7726:	80 93 d4 02 	sts	0x02D4, r24
    772a:	80 93 d3 02 	sts	0x02D3, r24
	EventFunc(&CurrPage->Load);
    772e:	ce 01       	movw	r24, r28
    7730:	03 96       	adiw	r24, 0x03	; 3
    7732:	0e 94 5b 3b 	call	0x76b6	; 0x76b6 <EventFunc>
}
    7736:	df 91       	pop	r29
    7738:	cf 91       	pop	r28
    773a:	08 95       	ret
{
	EventFunc(&CurrPage->Exit);
	if(prp(&Menu->OutPage))
		MenuDepth=0;
	else {
		MenuStack[MenuDepth].Page = CurrPage;
    773c:	20 91 6a 07 	lds	r18, 0x076A
    7740:	e2 2f       	mov	r30, r18
    7742:	f0 e0       	ldi	r31, 0x00	; 0
    7744:	ee 0f       	add	r30, r30
    7746:	ff 1f       	adc	r31, r31
    7748:	ee 0f       	add	r30, r30
    774a:	ff 1f       	adc	r31, r31
    774c:	df 01       	movw	r26, r30
    774e:	a9 56       	subi	r26, 0x69	; 105
    7750:	b7 4f       	sbci	r27, 0xF7	; 247
    7752:	80 91 d1 02 	lds	r24, 0x02D1
    7756:	90 91 d2 02 	lds	r25, 0x02D2
    775a:	11 96       	adiw	r26, 0x01	; 1
    775c:	9c 93       	st	X, r25
    775e:	8e 93       	st	-X, r24
		MenuStack[MenuDepth].Line = CurrLine;
    7760:	80 91 79 07 	lds	r24, 0x0779
    7764:	13 96       	adiw	r26, 0x03	; 3
    7766:	8c 93       	st	X, r24
		MenuStack[MenuDepth++].LCD = CurrLCD;
    7768:	e7 56       	subi	r30, 0x67	; 103
    776a:	f7 4f       	sbci	r31, 0xF7	; 247
    776c:	80 91 96 08 	lds	r24, 0x0896
    7770:	80 83       	st	Z, r24
    7772:	2f 5f       	subi	r18, 0xFF	; 255
    7774:	20 93 6a 07 	sts	0x076A, r18
    7778:	ca cf       	rjmp	.-108    	; 0x770e <GotoMenu+0x24>

0000777a <HideMsg>:

// ~~~~~~~~~~
uint8_t
HideMsg(void)
{
	if (CurrMsg) {
    777a:	80 91 ec 04 	lds	r24, 0x04EC
    777e:	90 91 ed 04 	lds	r25, 0x04ED
    7782:	00 97       	sbiw	r24, 0x00	; 0
    7784:	51 f0       	breq	.+20     	; 0x779a <HideMsg+0x20>
		EventFunc(&CurrMsg->Exit);
    7786:	80 5a       	subi	r24, 0xA0	; 160
    7788:	9f 4f       	sbci	r25, 0xFF	; 255
    778a:	0e 94 5b 3b 	call	0x76b6	; 0x76b6 <EventFunc>
		CurrMsg = NULL;
    778e:	10 92 ed 04 	sts	0x04ED, r1
    7792:	10 92 ec 04 	sts	0x04EC, r1
    7796:	81 e0       	ldi	r24, 0x01	; 1
		return 1;
	}
	else
		return 0;
}
    7798:	08 95       	ret

// ~~~~~~~~~~
uint8_t
HideMsg(void)
{
	if (CurrMsg) {
    779a:	80 e0       	ldi	r24, 0x00	; 0
    779c:	08 95       	ret

0000779e <ShowMsg>:
}

// ~~~~~~~~~~~~~~~~~~
void
ShowMsg(MsgPage *Msg)
{
    779e:	0f 93       	push	r16
    77a0:	1f 93       	push	r17
    77a2:	8c 01       	movw	r16, r24
	HideMsg();
    77a4:	0e 94 bd 3b 	call	0x777a	; 0x777a <HideMsg>
	CurrMsg = Msg;
    77a8:	10 93 ed 04 	sts	0x04ED, r17
    77ac:	00 93 ec 04 	sts	0x04EC, r16
	EventFunc(&CurrMsg->Load);
    77b0:	c8 01       	movw	r24, r16
    77b2:	84 5a       	subi	r24, 0xA4	; 164
    77b4:	9f 4f       	sbci	r25, 0xFF	; 255
    77b6:	0e 94 5b 3b 	call	0x76b6	; 0x76b6 <EventFunc>
}
    77ba:	1f 91       	pop	r17
    77bc:	0f 91       	pop	r16
    77be:	08 95       	ret

000077c0 <MenuInit>:

// ~~~~~~~~~~~
void
MenuInit(void)
{
	CurrLCD = CurrLine = GetFix();
    77c0:	e0 91 d1 02 	lds	r30, 0x02D1
    77c4:	f0 91 d2 02 	lds	r31, 0x02D2
    77c8:	33 96       	adiw	r30, 0x03	; 3
    77ca:	84 91       	lpm	r24, Z+
    77cc:	80 93 79 07 	sts	0x0779, r24
    77d0:	80 93 96 08 	sts	0x0896, r24
	#ifdef InitMsg
		ShowMsg(&InitMsg);
	#endif
	EventFunc(&CurrPage->Load);
    77d4:	cf 01       	movw	r24, r30
    77d6:	03 96       	adiw	r24, 0x03	; 3
    77d8:	0e 94 5b 3b 	call	0x76b6	; 0x76b6 <EventFunc>
}
    77dc:	08 95       	ret

000077de <PosBlink>:
}

// ~~~~~~~~~~~~~~~~~~~~~
static void
PosBlink(T_Param *Param, char Cursor)
{
    77de:	fc 01       	movw	r30, r24
	CurrX=Param->Pos+Param->Size-CurrPos-(Param->Prec&&CurrPos>=Param->Prec?2:1)-LCD_Buf[Y1];
    77e0:	20 81       	ld	r18, Z
    77e2:	33 81       	ldd	r19, Z+3	; 0x03
    77e4:	90 91 d4 02 	lds	r25, 0x02D4
    77e8:	82 81       	ldd	r24, Z+2	; 0x02
    77ea:	88 23       	and	r24, r24
    77ec:	11 f0       	breq	.+4      	; 0x77f2 <PosBlink+0x14>
    77ee:	98 17       	cp	r25, r24
    77f0:	a0 f4       	brcc	.+40     	; 0x781a <PosBlink+0x3c>
    77f2:	4f ef       	ldi	r20, 0xFF	; 255
    77f4:	39 1b       	sub	r19, r25
    77f6:	32 0f       	add	r19, r18
    77f8:	8f e4       	ldi	r24, 0x4F	; 79
    77fa:	96 e0       	ldi	r25, 0x06	; 6
    77fc:	38 1b       	sub	r19, r24
    77fe:	80 91 f3 09 	lds	r24, 0x09F3
    7802:	25 e1       	ldi	r18, 0x15	; 21
    7804:	82 9f       	mul	r24, r18
    7806:	c0 01       	movw	r24, r0
    7808:	11 24       	eor	r1, r1
    780a:	38 1b       	sub	r19, r24
    780c:	34 0f       	add	r19, r20
    780e:	30 93 b0 06 	sts	0x06B0, r19
	StrSize=1;
    7812:	81 e0       	ldi	r24, 0x01	; 1
    7814:	80 93 a3 06 	sts	0x06A3, r24
}
    7818:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~~~
static void
PosBlink(T_Param *Param, char Cursor)
{
	CurrX=Param->Pos+Param->Size-CurrPos-(Param->Prec&&CurrPos>=Param->Prec?2:1)-LCD_Buf[Y1];
    781a:	4e ef       	ldi	r20, 0xFE	; 254
    781c:	eb cf       	rjmp	.-42     	; 0x77f4 <PosBlink+0x16>

0000781e <GetCurrFieldSize>:

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    781e:	e0 91 d1 02 	lds	r30, 0x02D1
    7822:	f0 91 d2 02 	lds	r31, 0x02D2
    7826:	45 91       	lpm	r20, Z+
    7828:	54 91       	lpm	r21, Z+
}
// ~~~~~~~~~~~~~~~~~~~~~~~
// Return size of CurrField. Use to determine size of Text, EE_Text OutField vars
uint8_t GetCurrFieldSize(void){
	uint8_t Size;
	MenuLine *Line=GetLine+CurrLine;
    782a:	80 91 79 07 	lds	r24, 0x0779
    782e:	2b e1       	ldi	r18, 0x1B	; 27
    7830:	82 9f       	mul	r24, r18
    7832:	c0 01       	movw	r24, r0
    7834:	11 24       	eor	r1, r1
    7836:	48 0f       	add	r20, r24
    7838:	59 1f       	adc	r21, r25
		while(prc(CurrStr+X)=='}'){
			X++;
			Size++;
		}
		if(Size){
			if(OF_N == CurrField) return Size;
    783a:	30 91 d3 02 	lds	r19, 0x02D3
    783e:	90 e0       	ldi	r25, 0x00	; 0
    7840:	20 e0       	ldi	r18, 0x00	; 0

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    7842:	fa 01       	movw	r30, r20
    7844:	e9 0f       	add	r30, r25
    7846:	f1 1d       	adc	r31, r1
    7848:	e4 91       	lpm	r30, Z+
	MenuLine *Line=GetLine+CurrLine;
	PGM_P CurrStr=(PGM_P)(Line->Str);
	uint8_t OF_N = 0;
	for(uint8_t X=0; X<LCDXSz; X++){
		Size = 0;
		while(prc(CurrStr+X)=='}'){
    784a:	ed 37       	cpi	r30, 0x7D	; 125
    784c:	71 f4       	brne	.+28     	; 0x786a <GetCurrFieldSize+0x4c>
			X++;
			Size++;
		}
		if(Size){
			if(OF_N == CurrField) return Size;
    784e:	80 e0       	ldi	r24, 0x00	; 0
	PGM_P CurrStr=(PGM_P)(Line->Str);
	uint8_t OF_N = 0;
	for(uint8_t X=0; X<LCDXSz; X++){
		Size = 0;
		while(prc(CurrStr+X)=='}'){
			X++;
    7850:	9f 5f       	subi	r25, 0xFF	; 255
			Size++;
    7852:	8f 5f       	subi	r24, 0xFF	; 255
    7854:	fa 01       	movw	r30, r20
    7856:	e9 0f       	add	r30, r25
    7858:	f1 1d       	adc	r31, r1
    785a:	e4 91       	lpm	r30, Z+
	MenuLine *Line=GetLine+CurrLine;
	PGM_P CurrStr=(PGM_P)(Line->Str);
	uint8_t OF_N = 0;
	for(uint8_t X=0; X<LCDXSz; X++){
		Size = 0;
		while(prc(CurrStr+X)=='}'){
    785c:	ed 37       	cpi	r30, 0x7D	; 125
    785e:	c1 f3       	breq	.-16     	; 0x7850 <GetCurrFieldSize+0x32>
			X++;
			Size++;
		}
		if(Size){
    7860:	88 23       	and	r24, r24
    7862:	19 f0       	breq	.+6      	; 0x786a <GetCurrFieldSize+0x4c>
			if(OF_N == CurrField) return Size;
    7864:	23 17       	cp	r18, r19
    7866:	29 f0       	breq	.+10     	; 0x7872 <GetCurrFieldSize+0x54>
			OF_N++;
    7868:	2f 5f       	subi	r18, 0xFF	; 255
uint8_t GetCurrFieldSize(void){
	uint8_t Size;
	MenuLine *Line=GetLine+CurrLine;
	PGM_P CurrStr=(PGM_P)(Line->Str);
	uint8_t OF_N = 0;
	for(uint8_t X=0; X<LCDXSz; X++){
    786a:	9f 5f       	subi	r25, 0xFF	; 255
    786c:	94 31       	cpi	r25, 0x14	; 20
    786e:	48 f3       	brcs	.-46     	; 0x7842 <GetCurrFieldSize+0x24>
		Size = 0;
		while(prc(CurrStr+X)=='}'){
    7870:	80 e0       	ldi	r24, 0x00	; 0
			if(OF_N == CurrField) return Size;
			OF_N++;
		}
	}
	return 0;
}
    7872:	08 95       	ret

00007874 <Inc>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
static int32_t
Inc(int8_t Dir, uint32_t Buf)
{
    7874:	5f 92       	push	r5
    7876:	6f 92       	push	r6
    7878:	7f 92       	push	r7
    787a:	8f 92       	push	r8
    787c:	9f 92       	push	r9
    787e:	af 92       	push	r10
    7880:	bf 92       	push	r11
    7882:	cf 92       	push	r12
    7884:	df 92       	push	r13
    7886:	ef 92       	push	r14
    7888:	ff 92       	push	r15
    788a:	0f 93       	push	r16
    788c:	1f 93       	push	r17
    788e:	cf 93       	push	r28
    7890:	df 93       	push	r29
    7892:	58 2e       	mov	r5, r24
    7894:	3a 01       	movw	r6, r20
    7896:	4b 01       	movw	r8, r22
	uint32_t Pos = PowL10(CurrPos);
    7898:	d0 90 d4 02 	lds	r13, 0x02D4
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
	uint32_t Pow = 1;
	while(Exp--)
    789c:	dd 20       	and	r13, r13
    789e:	09 f4       	brne	.+2      	; 0x78a2 <Inc+0x2e>
    78a0:	5f c0       	rjmp	.+190    	; 0x7960 <Inc+0xec>
    78a2:	61 e0       	ldi	r22, 0x01	; 1
    78a4:	e6 2e       	mov	r14, r22
    78a6:	f1 2c       	mov	r15, r1
    78a8:	01 2d       	mov	r16, r1
    78aa:	11 2d       	mov	r17, r1
		Pow *= 10;
    78ac:	c8 01       	movw	r24, r16
    78ae:	b7 01       	movw	r22, r14
    78b0:	2a e0       	ldi	r18, 0x0A	; 10
    78b2:	30 e0       	ldi	r19, 0x00	; 0
    78b4:	40 e0       	ldi	r20, 0x00	; 0
    78b6:	50 e0       	ldi	r21, 0x00	; 0
    78b8:	0e 94 3f 7d 	call	0xfa7e	; 0xfa7e <__mulsi3>
    78bc:	7b 01       	movw	r14, r22
    78be:	8c 01       	movw	r16, r24
    78c0:	da 94       	dec	r13
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
	uint32_t Pow = 1;
	while(Exp--)
    78c2:	a1 f7       	brne	.-24     	; 0x78ac <Inc+0x38>
    78c4:	5b 01       	movw	r10, r22
    78c6:	6c 01       	movw	r12, r24
	uint8_t Dig=Buf%(Pos*10)/Pos;
	if(Dig==(Dir==1?9:0)) {
    78c8:	81 e0       	ldi	r24, 0x01	; 1
    78ca:	58 16       	cp	r5, r24
    78cc:	09 f4       	brne	.+2      	; 0x78d0 <Inc+0x5c>
    78ce:	45 c0       	rjmp	.+138    	; 0x795a <Inc+0xe6>
    78d0:	c0 e0       	ldi	r28, 0x00	; 0
    78d2:	d0 e0       	ldi	r29, 0x00	; 0
    78d4:	c8 01       	movw	r24, r16
    78d6:	b7 01       	movw	r22, r14
    78d8:	2a e0       	ldi	r18, 0x0A	; 10
    78da:	30 e0       	ldi	r19, 0x00	; 0
    78dc:	40 e0       	ldi	r20, 0x00	; 0
    78de:	50 e0       	ldi	r21, 0x00	; 0
    78e0:	0e 94 3f 7d 	call	0xfa7e	; 0xfa7e <__mulsi3>
    78e4:	9b 01       	movw	r18, r22
    78e6:	ac 01       	movw	r20, r24
    78e8:	c4 01       	movw	r24, r8
    78ea:	b3 01       	movw	r22, r6
    78ec:	0e 94 91 7d 	call	0xfb22	; 0xfb22 <__udivmodsi4>
    78f0:	a8 01       	movw	r20, r16
    78f2:	97 01       	movw	r18, r14
    78f4:	0e 94 91 7d 	call	0xfb22	; 0xfb22 <__udivmodsi4>
    78f8:	30 e0       	ldi	r19, 0x00	; 0
    78fa:	2c 17       	cp	r18, r28
    78fc:	3d 07       	cpc	r19, r29
    78fe:	99 f4       	brne	.+38     	; 0x7926 <Inc+0xb2>
			Dir = -Dir;
    7900:	51 94       	neg	r5
			Pos *= 9;
    7902:	57 01       	movw	r10, r14
    7904:	68 01       	movw	r12, r16
    7906:	aa 0c       	add	r10, r10
    7908:	bb 1c       	adc	r11, r11
    790a:	cc 1c       	adc	r12, r12
    790c:	dd 1c       	adc	r13, r13
    790e:	aa 0c       	add	r10, r10
    7910:	bb 1c       	adc	r11, r11
    7912:	cc 1c       	adc	r12, r12
    7914:	dd 1c       	adc	r13, r13
    7916:	aa 0c       	add	r10, r10
    7918:	bb 1c       	adc	r11, r11
    791a:	cc 1c       	adc	r12, r12
    791c:	dd 1c       	adc	r13, r13
    791e:	ae 0c       	add	r10, r14
    7920:	bf 1c       	adc	r11, r15
    7922:	c0 1e       	adc	r12, r16
    7924:	d1 1e       	adc	r13, r17
    7926:	65 2d       	mov	r22, r5
    7928:	77 27       	eor	r23, r23
    792a:	67 fd       	sbrc	r22, 7
    792c:	70 95       	com	r23
    792e:	87 2f       	mov	r24, r23
    7930:	97 2f       	mov	r25, r23
    7932:	a6 01       	movw	r20, r12
    7934:	95 01       	movw	r18, r10
    7936:	0e 94 3f 7d 	call	0xfa7e	; 0xfa7e <__mulsi3>
	}
	return Pos*Dir;
}
    793a:	df 91       	pop	r29
    793c:	cf 91       	pop	r28
    793e:	1f 91       	pop	r17
    7940:	0f 91       	pop	r16
    7942:	ff 90       	pop	r15
    7944:	ef 90       	pop	r14
    7946:	df 90       	pop	r13
    7948:	cf 90       	pop	r12
    794a:	bf 90       	pop	r11
    794c:	af 90       	pop	r10
    794e:	9f 90       	pop	r9
    7950:	8f 90       	pop	r8
    7952:	7f 90       	pop	r7
    7954:	6f 90       	pop	r6
    7956:	5f 90       	pop	r5
    7958:	08 95       	ret
static int32_t
Inc(int8_t Dir, uint32_t Buf)
{
	uint32_t Pos = PowL10(CurrPos);
	uint8_t Dig=Buf%(Pos*10)/Pos;
	if(Dig==(Dir==1?9:0)) {
    795a:	c9 e0       	ldi	r28, 0x09	; 9
    795c:	d0 e0       	ldi	r29, 0x00	; 0
    795e:	ba cf       	rjmp	.-140    	; 0x78d4 <Inc+0x60>
    7960:	e1 e0       	ldi	r30, 0x01	; 1
    7962:	ee 2e       	mov	r14, r30
    7964:	f1 2c       	mov	r15, r1
    7966:	01 2d       	mov	r16, r1
    7968:	11 2d       	mov	r17, r1
    796a:	71 e0       	ldi	r23, 0x01	; 1
    796c:	a7 2e       	mov	r10, r23
    796e:	b1 2c       	mov	r11, r1
    7970:	c1 2c       	mov	r12, r1
    7972:	d1 2c       	mov	r13, r1
    7974:	a9 cf       	rjmp	.-174    	; 0x78c8 <Inc+0x54>

00007976 <MenuRight>:

// ~~~~~~~~~~~~
void
MenuRight(void)
{
}
    7976:	08 95       	ret

00007978 <MenuLeft>:

// ~~~~~~~~~~~~~
void
MenuLeft(void)
{
}
    7978:	08 95       	ret

0000797a <MenuEnter>:

// ~~~~~~~~~~~~
void
MenuEnter(void)
{
}
    797a:	08 95       	ret

0000797c <MenuEsc>:

// ~~~~~~~~~~
void
MenuEsc(void)
{
}
    797c:	08 95       	ret

0000797e <DI_State>:
} DigInput;

// ~~~~~~~~~~~~~~~~~~
uint8_t
DI_State(uint8_t D_N)
{
    797e:	28 2f       	mov	r18, r24
    7980:	86 95       	lsr	r24
    7982:	86 95       	lsr	r24
    7984:	86 95       	lsr	r24
    7986:	e2 ef       	ldi	r30, 0xF2	; 242
    7988:	f6 e0       	ldi	r31, 0x06	; 6
    798a:	e8 0f       	add	r30, r24
    798c:	f1 1d       	adc	r31, r1
    798e:	80 81       	ld	r24, Z
    7990:	90 e0       	ldi	r25, 0x00	; 0
    7992:	27 70       	andi	r18, 0x07	; 7
    7994:	02 c0       	rjmp	.+4      	; 0x799a <DI_State+0x1c>
    7996:	95 95       	asr	r25
    7998:	87 95       	ror	r24
    799a:	2a 95       	dec	r18
    799c:	e2 f7       	brpl	.-8      	; 0x7996 <DI_State+0x18>
	return (DigInput.State[D_N/8] &(1<<D_N%8)) != 0;
}
    799e:	81 70       	andi	r24, 0x01	; 1
    79a0:	08 95       	ret

000079a2 <DI_Front>:

// ~~~~~~~~~~~~~~~~~~
uint8_t
DI_Front(uint8_t D_N)
{
    79a2:	e8 2f       	mov	r30, r24
	uint8_t Byte=D_N/8, Bit=1<<D_N%8;
    79a4:	28 2f       	mov	r18, r24
    79a6:	27 70       	andi	r18, 0x07	; 7
    79a8:	81 e0       	ldi	r24, 0x01	; 1
    79aa:	90 e0       	ldi	r25, 0x00	; 0
    79ac:	01 c0       	rjmp	.+2      	; 0x79b0 <DI_Front+0xe>
    79ae:	88 0f       	add	r24, r24
    79b0:	2a 95       	dec	r18
    79b2:	ea f7       	brpl	.-6      	; 0x79ae <DI_Front+0xc>
	uint8_t State = DigInput.State[Byte] &Bit;
    79b4:	e6 95       	lsr	r30
    79b6:	e6 95       	lsr	r30
    79b8:	e6 95       	lsr	r30
    79ba:	f0 e0       	ldi	r31, 0x00	; 0
    79bc:	ee 50       	subi	r30, 0x0E	; 14
    79be:	f9 4f       	sbci	r31, 0xF9	; 249
    79c0:	90 81       	ld	r25, Z
    79c2:	98 23       	and	r25, r24
	return DigInput.StateOld[Byte] &Bit ? State?NoFront:FallFront : State?RiseFront:NoFront;
    79c4:	23 81       	ldd	r18, Z+3	; 0x03
    79c6:	82 23       	and	r24, r18
    79c8:	21 f0       	breq	.+8      	; 0x79d2 <DI_Front+0x30>
    79ca:	99 23       	and	r25, r25
    79cc:	41 f4       	brne	.+16     	; 0x79de <DI_Front+0x3c>
    79ce:	82 e0       	ldi	r24, 0x02	; 2
    79d0:	08 95       	ret
    79d2:	89 2f       	mov	r24, r25
    79d4:	99 23       	and	r25, r25
    79d6:	09 f4       	brne	.+2      	; 0x79da <DI_Front+0x38>
}
    79d8:	08 95       	ret
uint8_t
DI_Front(uint8_t D_N)
{
	uint8_t Byte=D_N/8, Bit=1<<D_N%8;
	uint8_t State = DigInput.State[Byte] &Bit;
	return DigInput.StateOld[Byte] &Bit ? State?NoFront:FallFront : State?RiseFront:NoFront;
    79da:	81 e0       	ldi	r24, 0x01	; 1
}
    79dc:	08 95       	ret
uint8_t
DI_Front(uint8_t D_N)
{
	uint8_t Byte=D_N/8, Bit=1<<D_N%8;
	uint8_t State = DigInput.State[Byte] &Bit;
	return DigInput.StateOld[Byte] &Bit ? State?NoFront:FallFront : State?RiseFront:NoFront;
    79de:	80 e0       	ldi	r24, 0x00	; 0
    79e0:	08 95       	ret

000079e2 <DI_Status>:
}

// ~~~~~~~~~~~~~~~~~~~
uint8_t
DI_Status(uint8_t D_N)
{
    79e2:	28 2f       	mov	r18, r24
    79e4:	86 95       	lsr	r24
    79e6:	86 95       	lsr	r24
    79e8:	86 95       	lsr	r24
    79ea:	e2 ef       	ldi	r30, 0xF2	; 242
    79ec:	f6 e0       	ldi	r31, 0x06	; 6
    79ee:	e8 0f       	add	r30, r24
    79f0:	f1 1d       	adc	r31, r1
    79f2:	86 81       	ldd	r24, Z+6	; 0x06
    79f4:	90 e0       	ldi	r25, 0x00	; 0
    79f6:	27 70       	andi	r18, 0x07	; 7
    79f8:	02 c0       	rjmp	.+4      	; 0x79fe <DI_Status+0x1c>
    79fa:	95 95       	asr	r25
    79fc:	87 95       	ror	r24
    79fe:	2a 95       	dec	r18
    7a00:	e2 f7       	brpl	.-8      	; 0x79fa <DI_Status+0x18>
	return (DigInput.Status[D_N/8] &(1<<D_N%8)) != 0;
}
    7a02:	81 70       	andi	r24, 0x01	; 1
    7a04:	08 95       	ret

00007a06 <DI_Init>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

// ~~~~~~~~~~
void
DI_Init(void)
{
    7a06:	20 e0       	ldi	r18, 0x00	; 0
    7a08:	30 e0       	ldi	r19, 0x00	; 0
// ~~~~~~~~~~~~~~~
static void
DI_Init_Hard(void)
{
	for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
		cli();
    7a0a:	f8 94       	cli

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    7a0c:	a9 01       	movw	r20, r18
    7a0e:	44 0f       	add	r20, r20
    7a10:	55 1f       	adc	r21, r21
    7a12:	44 0f       	add	r20, r20
    7a14:	55 1f       	adc	r21, r21
    7a16:	44 0f       	add	r20, r20
    7a18:	55 1f       	adc	r21, r21
    7a1a:	ca 01       	movw	r24, r20
    7a1c:	89 5f       	subi	r24, 0xF9	; 249
    7a1e:	94 4d       	sbci	r25, 0xD4	; 212
    7a20:	fc 01       	movw	r30, r24
    7a22:	a5 91       	lpm	r26, Z+
    7a24:	b4 91       	lpm	r27, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    7a26:	43 5f       	subi	r20, 0xF3	; 243
    7a28:	54 4d       	sbci	r21, 0xD4	; 212
    7a2a:	fa 01       	movw	r30, r20
    7a2c:	44 91       	lpm	r20, Z+
		*(uint8_t*)prp(&DI_M[D_N].DDR) &=~prb(&DI_M[D_N].P);
    7a2e:	94 2f       	mov	r25, r20
    7a30:	90 95       	com	r25
    7a32:	8c 91       	ld	r24, X
    7a34:	89 23       	and	r24, r25
    7a36:	8c 93       	st	X, r24

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    7a38:	c9 01       	movw	r24, r18
    7a3a:	88 0f       	add	r24, r24
    7a3c:	99 1f       	adc	r25, r25
    7a3e:	88 0f       	add	r24, r24
    7a40:	99 1f       	adc	r25, r25
    7a42:	88 0f       	add	r24, r24
    7a44:	99 1f       	adc	r25, r25
    7a46:	87 5f       	subi	r24, 0xF7	; 247
    7a48:	94 4d       	sbci	r25, 0xD4	; 212
    7a4a:	fc 01       	movw	r30, r24
    7a4c:	a5 91       	lpm	r26, Z+
    7a4e:	b4 91       	lpm	r27, Z+
		*(uint8_t*)prp(&DI_M[D_N].PORT) |=prb(&DI_M[D_N].P);
    7a50:	8c 91       	ld	r24, X
    7a52:	84 2b       	or	r24, r20
    7a54:	8c 93       	st	X, r24
		sei();
    7a56:	78 94       	sei
    7a58:	2f 5f       	subi	r18, 0xFF	; 255
    7a5a:	3f 4f       	sbci	r19, 0xFF	; 255

// ~~~~~~~~~~~~~~~
static void
DI_Init_Hard(void)
{
	for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
    7a5c:	22 31       	cpi	r18, 0x12	; 18
    7a5e:	31 05       	cpc	r19, r1
    7a60:	a1 f6       	brne	.-88     	; 0x7a0a <DI_Init+0x4>
{
	DI_Init_Hard();
	#ifdef HSC_Reg
		HSC_Init();
	#endif
}
    7a62:	08 95       	ret

00007a64 <DO_State>:
} DigOutput;

// ~~~~~~~~~~~~~~~~~~
uint8_t
DO_State(uint8_t D_N)
{
    7a64:	90 e0       	ldi	r25, 0x00	; 0
    7a66:	e8 2f       	mov	r30, r24
    7a68:	e6 95       	lsr	r30
    7a6a:	e6 95       	lsr	r30
    7a6c:	e6 95       	lsr	r30
    7a6e:	f0 e0       	ldi	r31, 0x00	; 0
    7a70:	e7 57       	subi	r30, 0x77	; 119
    7a72:	f8 4f       	sbci	r31, 0xF8	; 248
    7a74:	40 81       	ld	r20, Z
    7a76:	50 e0       	ldi	r21, 0x00	; 0
    7a78:	87 70       	andi	r24, 0x07	; 7
    7a7a:	21 e0       	ldi	r18, 0x01	; 1
    7a7c:	30 e0       	ldi	r19, 0x00	; 0
    7a7e:	02 c0       	rjmp	.+4      	; 0x7a84 <DO_State+0x20>
    7a80:	22 0f       	add	r18, r18
    7a82:	33 1f       	adc	r19, r19
    7a84:	8a 95       	dec	r24
    7a86:	e2 f7       	brpl	.-8      	; 0x7a80 <DO_State+0x1c>
    7a88:	42 23       	and	r20, r18
    7a8a:	53 23       	and	r21, r19
    7a8c:	14 16       	cp	r1, r20
    7a8e:	15 06       	cpc	r1, r21
    7a90:	0c f4       	brge	.+2      	; 0x7a94 <DO_State+0x30>
    7a92:	91 e0       	ldi	r25, 0x01	; 1
	return (DigOutput.State[D_N/8] &(1<<D_N%8)) > 0;
}
    7a94:	89 2f       	mov	r24, r25
    7a96:	08 95       	ret

00007a98 <DO_Front>:

// ~~~~~~~~~~~~~~~~~~
uint8_t
DO_Front(uint8_t D_N)
{
    7a98:	e8 2f       	mov	r30, r24
	uint8_t Byte=D_N/8, Bit=1<<D_N%8;
    7a9a:	28 2f       	mov	r18, r24
    7a9c:	27 70       	andi	r18, 0x07	; 7
    7a9e:	81 e0       	ldi	r24, 0x01	; 1
    7aa0:	90 e0       	ldi	r25, 0x00	; 0
    7aa2:	01 c0       	rjmp	.+2      	; 0x7aa6 <DO_Front+0xe>
    7aa4:	88 0f       	add	r24, r24
    7aa6:	2a 95       	dec	r18
    7aa8:	ea f7       	brpl	.-6      	; 0x7aa4 <DO_Front+0xc>
	uint8_t State = DigOutput.State[Byte] &Bit;
    7aaa:	e6 95       	lsr	r30
    7aac:	e6 95       	lsr	r30
    7aae:	e6 95       	lsr	r30
    7ab0:	f0 e0       	ldi	r31, 0x00	; 0
    7ab2:	e7 57       	subi	r30, 0x77	; 119
    7ab4:	f8 4f       	sbci	r31, 0xF8	; 248
    7ab6:	90 81       	ld	r25, Z
    7ab8:	98 23       	and	r25, r24
	return DigOutput.StateOld[Byte] &Bit ? State?NoFront:FallFront : State?RiseFront:NoFront;
    7aba:	22 81       	ldd	r18, Z+2	; 0x02
    7abc:	82 23       	and	r24, r18
    7abe:	21 f0       	breq	.+8      	; 0x7ac8 <DO_Front+0x30>
    7ac0:	99 23       	and	r25, r25
    7ac2:	41 f4       	brne	.+16     	; 0x7ad4 <DO_Front+0x3c>
    7ac4:	82 e0       	ldi	r24, 0x02	; 2
    7ac6:	08 95       	ret
    7ac8:	89 2f       	mov	r24, r25
    7aca:	99 23       	and	r25, r25
    7acc:	09 f4       	brne	.+2      	; 0x7ad0 <DO_Front+0x38>
}
    7ace:	08 95       	ret
uint8_t
DO_Front(uint8_t D_N)
{
	uint8_t Byte=D_N/8, Bit=1<<D_N%8;
	uint8_t State = DigOutput.State[Byte] &Bit;
	return DigOutput.StateOld[Byte] &Bit ? State?NoFront:FallFront : State?RiseFront:NoFront;
    7ad0:	81 e0       	ldi	r24, 0x01	; 1
}
    7ad2:	08 95       	ret
uint8_t
DO_Front(uint8_t D_N)
{
	uint8_t Byte=D_N/8, Bit=1<<D_N%8;
	uint8_t State = DigOutput.State[Byte] &Bit;
	return DigOutput.StateOld[Byte] &Bit ? State?NoFront:FallFront : State?RiseFront:NoFront;
    7ad4:	80 e0       	ldi	r24, 0x00	; 0
    7ad6:	08 95       	ret

00007ad8 <SetDigOut>:

// ~~~~~~~~~~~~~~~~~~~
void
SetDigOut(uint8_t D_N)
{
	DigOutput.Buf[D_N/8] |=(1<<D_N%8);
    7ad8:	98 2f       	mov	r25, r24
    7ada:	96 95       	lsr	r25
    7adc:	96 95       	lsr	r25
    7ade:	96 95       	lsr	r25
    7ae0:	e9 e8       	ldi	r30, 0x89	; 137
    7ae2:	f7 e0       	ldi	r31, 0x07	; 7
    7ae4:	e9 0f       	add	r30, r25
    7ae6:	f1 1d       	adc	r31, r1
    7ae8:	87 70       	andi	r24, 0x07	; 7
    7aea:	21 e0       	ldi	r18, 0x01	; 1
    7aec:	30 e0       	ldi	r19, 0x00	; 0
    7aee:	02 c0       	rjmp	.+4      	; 0x7af4 <SetDigOut+0x1c>
    7af0:	22 0f       	add	r18, r18
    7af2:	33 1f       	adc	r19, r19
    7af4:	8a 95       	dec	r24
    7af6:	e2 f7       	brpl	.-8      	; 0x7af0 <SetDigOut+0x18>
    7af8:	84 81       	ldd	r24, Z+4	; 0x04
    7afa:	82 2b       	or	r24, r18
    7afc:	84 83       	std	Z+4, r24	; 0x04
}
    7afe:	08 95       	ret

00007b00 <ResDigOut>:

// ~~~~~~~~~~~~~~~~~~~
void
ResDigOut(uint8_t D_N)
{
	DigOutput.Buf[D_N/8] &=~(1<<D_N%8);
    7b00:	98 2f       	mov	r25, r24
    7b02:	96 95       	lsr	r25
    7b04:	96 95       	lsr	r25
    7b06:	96 95       	lsr	r25
    7b08:	e9 e8       	ldi	r30, 0x89	; 137
    7b0a:	f7 e0       	ldi	r31, 0x07	; 7
    7b0c:	e9 0f       	add	r30, r25
    7b0e:	f1 1d       	adc	r31, r1
    7b10:	87 70       	andi	r24, 0x07	; 7
    7b12:	21 e0       	ldi	r18, 0x01	; 1
    7b14:	30 e0       	ldi	r19, 0x00	; 0
    7b16:	02 c0       	rjmp	.+4      	; 0x7b1c <ResDigOut+0x1c>
    7b18:	22 0f       	add	r18, r18
    7b1a:	33 1f       	adc	r19, r19
    7b1c:	8a 95       	dec	r24
    7b1e:	e2 f7       	brpl	.-8      	; 0x7b18 <ResDigOut+0x18>
    7b20:	20 95       	com	r18
    7b22:	84 81       	ldd	r24, Z+4	; 0x04
    7b24:	28 23       	and	r18, r24
    7b26:	24 83       	std	Z+4, r18	; 0x04
}
    7b28:	08 95       	ret

00007b2a <TogDigOut>:

// ~~~~~~~~~~~~~~~~~~~
void
TogDigOut(uint8_t D_N)
{
	DigOutput.Buf[D_N/8] ^=(1<<D_N%8);
    7b2a:	98 2f       	mov	r25, r24
    7b2c:	96 95       	lsr	r25
    7b2e:	96 95       	lsr	r25
    7b30:	96 95       	lsr	r25
    7b32:	e9 e8       	ldi	r30, 0x89	; 137
    7b34:	f7 e0       	ldi	r31, 0x07	; 7
    7b36:	e9 0f       	add	r30, r25
    7b38:	f1 1d       	adc	r31, r1
    7b3a:	87 70       	andi	r24, 0x07	; 7
    7b3c:	21 e0       	ldi	r18, 0x01	; 1
    7b3e:	30 e0       	ldi	r19, 0x00	; 0
    7b40:	02 c0       	rjmp	.+4      	; 0x7b46 <TogDigOut+0x1c>
    7b42:	22 0f       	add	r18, r18
    7b44:	33 1f       	adc	r19, r19
    7b46:	8a 95       	dec	r24
    7b48:	e2 f7       	brpl	.-8      	; 0x7b42 <TogDigOut+0x18>
    7b4a:	84 81       	ldd	r24, Z+4	; 0x04
    7b4c:	82 27       	eor	r24, r18
    7b4e:	84 83       	std	Z+4, r24	; 0x04
}
    7b50:	08 95       	ret

00007b52 <SetAllDigOut>:

// ~~~~~~~~~~~~~~~
void
SetAllDigOut(void)
{
	for (uint8_t i=0; i<DO_Reg; DigOutput.Buf[i++]=0xFF);
    7b52:	8f ef       	ldi	r24, 0xFF	; 255
    7b54:	80 93 8d 07 	sts	0x078D, r24
    7b58:	80 93 8e 07 	sts	0x078E, r24
}
    7b5c:	08 95       	ret

00007b5e <DO_Enable>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    7b5e:	8f b7       	in	r24, 0x3f	; 63
    7b60:	80 78       	andi	r24, 0x80	; 128
    7b62:	80 93 e5 02 	sts	0x02E5, r24
	cli();
    7b66:	f8 94       	cli
void
DO_Enable(void)
{
	#ifdef Enable
		IntOff();
		PortEnable |=Enable;
    7b68:	46 9a       	sbi	0x08, 6	; 8

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    7b6a:	88 23       	and	r24, r24
    7b6c:	09 f0       	breq	.+2      	; 0x7b70 <DO_Enable+0x12>
		sei();
    7b6e:	78 94       	sei
    7b70:	08 95       	ret

00007b72 <DO_Disable>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    7b72:	8f b7       	in	r24, 0x3f	; 63
    7b74:	80 78       	andi	r24, 0x80	; 128
    7b76:	80 93 e5 02 	sts	0x02E5, r24
	cli();
    7b7a:	f8 94       	cli
void
DO_Disable()
{
	#ifdef Enable
		IntOff();
		PortEnable &=~Enable;
    7b7c:	46 98       	cbi	0x08, 6	; 8

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    7b7e:	88 23       	and	r24, r24
    7b80:	09 f0       	breq	.+2      	; 0x7b84 <DO_Disable+0x12>
		sei();
    7b82:	78 94       	sei
    7b84:	08 95       	ret

00007b86 <DigitOut>:

// ~~~~~~~~~~~
void
DigitOut(void)
{
	memcpy(DigOutput.StateOld, DigOutput.State, DO_Reg+DO_Reg_Ext);
    7b86:	90 91 89 07 	lds	r25, 0x0789
    7b8a:	80 91 8a 07 	lds	r24, 0x078A
    7b8e:	80 93 8c 07 	sts	0x078C, r24
    7b92:	90 93 8b 07 	sts	0x078B, r25
	memcpy(DigOutput.State, DigOutput.Buf, DO_Reg);
    7b96:	90 91 8d 07 	lds	r25, 0x078D
    7b9a:	80 91 8e 07 	lds	r24, 0x078E
    7b9e:	80 93 8a 07 	sts	0x078A, r24
    7ba2:	90 93 89 07 	sts	0x0789, r25
    7ba6:	20 e1       	ldi	r18, 0x10	; 16
    7ba8:	35 e0       	ldi	r19, 0x05	; 5
    7baa:	10 c0       	rjmp	.+32     	; 0x7bcc <DigitOut+0x46>
	uint8_t N = DO_Reg*8;
	while (N) {
		uint8_t D_N = prb(M+--N);
		cli();
		if (DigOutput.State[D_N/8] &(1<<D_N%8))
			PortData  |=Data;
    7bac:	47 9a       	sbi	0x08, 7	; 8
		else
			PortData &=~Data;
		sei();
    7bae:	78 94       	sei
    7bb0:	83 2f       	mov	r24, r19
    7bb2:	8a 95       	dec	r24
    7bb4:	f1 f7       	brne	.-4      	; 0x7bb2 <DigitOut+0x2c>
		_delay_us(1);				// 125 ns needs at 5V
		cli();
    7bb6:	f8 94       	cli
		PortClock |=Clock;
    7bb8:	45 9a       	sbi	0x08, 5	; 8
		sei();
    7bba:	78 94       	sei
    7bbc:	83 2f       	mov	r24, r19
    7bbe:	8a 95       	dec	r24
    7bc0:	f1 f7       	brne	.-4      	; 0x7bbe <DigitOut+0x38>
		_delay_us(1);				// 200 ns needs at 5V
		cli();
    7bc2:	f8 94       	cli
		PortClock &=~Clock;
    7bc4:	45 98       	cbi	0x08, 5	; 8
		sei();
    7bc6:	78 94       	sei
DigitOut_Hard(void)
{
	static prog_uint8_t M[DO_Reg*8] = DO_Map;

	uint8_t N = DO_Reg*8;
	while (N) {
    7bc8:	22 23       	and	r18, r18
    7bca:	d1 f0       	breq	.+52     	; 0x7c00 <DigitOut+0x7a>
		uint8_t D_N = prb(M+--N);
    7bcc:	21 50       	subi	r18, 0x01	; 1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    7bce:	e2 2f       	mov	r30, r18
    7bd0:	f0 e0       	ldi	r31, 0x00	; 0
    7bd2:	e9 50       	subi	r30, 0x09	; 9
    7bd4:	f5 4d       	sbci	r31, 0xD5	; 213
    7bd6:	e4 91       	lpm	r30, Z+
		cli();
    7bd8:	f8 94       	cli
		if (DigOutput.State[D_N/8] &(1<<D_N%8))
    7bda:	ae 2f       	mov	r26, r30
    7bdc:	a6 95       	lsr	r26
    7bde:	a6 95       	lsr	r26
    7be0:	a6 95       	lsr	r26
    7be2:	b0 e0       	ldi	r27, 0x00	; 0
    7be4:	a7 57       	subi	r26, 0x77	; 119
    7be6:	b8 4f       	sbci	r27, 0xF8	; 248
    7be8:	8c 91       	ld	r24, X
    7bea:	90 e0       	ldi	r25, 0x00	; 0
    7bec:	e7 70       	andi	r30, 0x07	; 7
    7bee:	02 c0       	rjmp	.+4      	; 0x7bf4 <DigitOut+0x6e>
    7bf0:	95 95       	asr	r25
    7bf2:	87 95       	ror	r24
    7bf4:	ea 95       	dec	r30
    7bf6:	e2 f7       	brpl	.-8      	; 0x7bf0 <DigitOut+0x6a>
    7bf8:	80 fd       	sbrc	r24, 0
    7bfa:	d8 cf       	rjmp	.-80     	; 0x7bac <DigitOut+0x26>
			PortData  |=Data;
		else
			PortData &=~Data;
    7bfc:	47 98       	cbi	0x08, 7	; 8
    7bfe:	d7 cf       	rjmp	.-82     	; 0x7bae <DigitOut+0x28>
		_delay_us(1);				// 200 ns needs at 5V
		cli();
		PortClock &=~Clock;
		sei();
	}
	cli();
    7c00:	f8 94       	cli
	PortStrobe |=Strobe;
    7c02:	80 91 05 01 	lds	r24, 0x0105
    7c06:	81 60       	ori	r24, 0x01	; 1
    7c08:	80 93 05 01 	sts	0x0105, r24
	sei();
    7c0c:	78 94       	sei
    7c0e:	85 e0       	ldi	r24, 0x05	; 5
    7c10:	8a 95       	dec	r24
    7c12:	f1 f7       	brne	.-4      	; 0x7c10 <DigitOut+0x8a>
	_delay_us(1);					// 200 ns needs at 5V
	cli();
    7c14:	f8 94       	cli
	PortStrobe &=~Strobe;
    7c16:	80 91 05 01 	lds	r24, 0x0105
    7c1a:	8e 7f       	andi	r24, 0xFE	; 254
    7c1c:	80 93 05 01 	sts	0x0105, r24
	sei();
    7c20:	78 94       	sei
				DigOutput.State[j] = (DigOutput_Ext)[i];
			(DigOutput_Ext)[i+DO_Reg_Ext] = DigOutput.Buf[j];
			IntOn();
		}
	#endif
}
    7c22:	08 95       	ret

00007c24 <DO_Init>:

// ~~~~~~~~~~~~~~~
static void
DO_Init_Hard(void)
{
	cli();
    7c24:	f8 94       	cli
	DDR_Strobe |= Strobe;
    7c26:	e4 e0       	ldi	r30, 0x04	; 4
    7c28:	f1 e0       	ldi	r31, 0x01	; 1
    7c2a:	80 81       	ld	r24, Z
    7c2c:	81 60       	ori	r24, 0x01	; 1
    7c2e:	80 83       	st	Z, r24
	DDR_Data |= Data;
    7c30:	3f 9a       	sbi	0x07, 7	; 7
	DDR_Enable |= Enable;
    7c32:	3e 9a       	sbi	0x07, 6	; 7
	DDR_Clock |=Clock;
    7c34:	3d 9a       	sbi	0x07, 5	; 7
	PortStrobe &=~Strobe;
    7c36:	e5 e0       	ldi	r30, 0x05	; 5
    7c38:	f1 e0       	ldi	r31, 0x01	; 1
    7c3a:	80 81       	ld	r24, Z
    7c3c:	8e 7f       	andi	r24, 0xFE	; 254
    7c3e:	80 83       	st	Z, r24
	PortClock &=~Clock;
    7c40:	45 98       	cbi	0x08, 5	; 8
	sei();
    7c42:	78 94       	sei
// ~~~~~~~~~~
void
DO_Init(void)
{
	DO_Init_Hard();
	DigitOut();		// Clear all
    7c44:	0e 94 c3 3d 	call	0x7b86	; 0x7b86 <DigitOut>
	DO_Enable();
    7c48:	0e 94 af 3d 	call	0x7b5e	; 0x7b5e <DO_Enable>
}
    7c4c:	08 95       	ret

00007c4e <AI_Init>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    7c4e:	e0 91 f7 04 	lds	r30, 0x04F7
    7c52:	f0 e0       	ldi	r31, 0x00	; 0
    7c54:	ee 0f       	add	r30, r30
    7c56:	ff 1f       	adc	r31, r31
    7c58:	e9 51       	subi	r30, 0x19	; 25
    7c5a:	f5 4d       	sbci	r31, 0xD5	; 213
    7c5c:	85 91       	lpm	r24, Z+
    7c5e:	94 91       	lpm	r25, Z+
// ~~~~~~~~~~~
static void
SetMuxAI(void)
{
	static prog_uint16_t Mux[] = AI_Mux;
	ADMUX = (uint8_t) prw(Mux+AI_N);
    7c60:	80 93 7c 00 	sts	0x007C, r24
	#ifdef MUX5
		ADCSRB = (uint8_t) (prw(Mux+AI_N)>>8);
    7c64:	90 93 7b 00 	sts	0x007B, r25
		#ifdef AN_C
			DDR_AN_C |=AN_C;
		#endif
	#endif
	SetMuxAI();
	ADCSRA = (((((1<<ADEN) |(1<<ADSC)) &~(1<<AD_Mode)) |(1<<ADIF)) &~(1<<ADIE)) |(1<<ADPS2) |(1<<ADPS1) |(1<<ADPS0);
    7c68:	87 ed       	ldi	r24, 0xD7	; 215
    7c6a:	80 93 7a 00 	sts	0x007A, r24
		}
	#endif
	#ifdef InitAI_10ms
		TD_InnADC = Timer8SysAlloc(AI_Reg);
	#endif
}
    7c6e:	08 95       	ret

00007c70 <AnalogIn>:

// ~~~~~~~~~~~
uint8_t
AnalogIn(void)
{
	if (ADCSRA &(1<<ADSC))
    7c70:	80 91 7a 00 	lds	r24, 0x007A
    7c74:	86 fd       	sbrc	r24, 6
    7c76:	2c c0       	rjmp	.+88     	; 0x7cd0 <AnalogIn+0x60>
		return AI_Reg;
	AnalogInput[AI_N] = ADCL;
    7c78:	50 91 f7 04 	lds	r21, 0x04F7
    7c7c:	65 2f       	mov	r22, r21
    7c7e:	20 91 78 00 	lds	r18, 0x0078
	AnalogInput[AI_N] |= ADCH<<8;
    7c82:	40 91 79 00 	lds	r20, 0x0079
    7c86:	e5 2f       	mov	r30, r21
    7c88:	f0 e0       	ldi	r31, 0x00	; 0
    7c8a:	ee 0f       	add	r30, r30
    7c8c:	ff 1f       	adc	r31, r31
    7c8e:	e4 50       	subi	r30, 0x04	; 4
    7c90:	f5 4f       	sbci	r31, 0xF5	; 245
    7c92:	94 2f       	mov	r25, r20
    7c94:	80 e0       	ldi	r24, 0x00	; 0
    7c96:	30 e0       	ldi	r19, 0x00	; 0
    7c98:	82 2b       	or	r24, r18
    7c9a:	93 2b       	or	r25, r19
    7c9c:	91 83       	std	Z+1, r25	; 0x01
    7c9e:	80 83       	st	Z, r24
		}
		else
			Chan = AI_Reg;
	#endif

	if (++AI_N == AI_Reg)
    7ca0:	5f 5f       	subi	r21, 0xFF	; 255
    7ca2:	50 93 f7 04 	sts	0x04F7, r21
    7ca6:	58 30       	cpi	r21, 0x08	; 8
    7ca8:	b1 f0       	breq	.+44     	; 0x7cd6 <AnalogIn+0x66>
    7caa:	e5 2f       	mov	r30, r21
    7cac:	f0 e0       	ldi	r31, 0x00	; 0
    7cae:	ee 0f       	add	r30, r30
    7cb0:	ff 1f       	adc	r31, r31
    7cb2:	e9 51       	subi	r30, 0x19	; 25
    7cb4:	f5 4d       	sbci	r31, 0xD5	; 213
    7cb6:	85 91       	lpm	r24, Z+
    7cb8:	94 91       	lpm	r25, Z+
// ~~~~~~~~~~~
static void
SetMuxAI(void)
{
	static prog_uint16_t Mux[] = AI_Mux;
	ADMUX = (uint8_t) prw(Mux+AI_N);
    7cba:	80 93 7c 00 	sts	0x007C, r24
	#ifdef MUX5
		ADCSRB = (uint8_t) (prw(Mux+AI_N)>>8);
    7cbe:	90 93 7b 00 	sts	0x007B, r25
	#endif

	if (++AI_N == AI_Reg)
		AI_N = 0;
	SetMuxAI();
	ADCSRA |=(1<<ADSC);
    7cc2:	80 91 7a 00 	lds	r24, 0x007A
    7cc6:	80 64       	ori	r24, 0x40	; 64
    7cc8:	80 93 7a 00 	sts	0x007A, r24
			IntOn();
		}
	#endif

	return Chan;
}
    7ccc:	86 2f       	mov	r24, r22
    7cce:	08 95       	ret

// ~~~~~~~~~~~
uint8_t
AnalogIn(void)
{
	if (ADCSRA &(1<<ADSC))
    7cd0:	68 e0       	ldi	r22, 0x08	; 8
			IntOn();
		}
	#endif

	return Chan;
}
    7cd2:	86 2f       	mov	r24, r22
    7cd4:	08 95       	ret
		else
			Chan = AI_Reg;
	#endif

	if (++AI_N == AI_Reg)
		AI_N = 0;
    7cd6:	10 92 f7 04 	sts	0x04F7, r1
    7cda:	50 e0       	ldi	r21, 0x00	; 0
    7cdc:	e6 cf       	rjmp	.-52     	; 0x7caa <AnalogIn+0x3a>

00007cde <Thermode>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
int16_t
Thermode(uint8_t T_Fami, uint8_t T_Type, uint16_t Code)
{
	if (T_Type==ThermOff)
    7cde:	66 23       	and	r22, r22
    7ce0:	f9 f0       	breq	.+62     	; 0x7d20 <Thermode+0x42>
		return Therm_Off_Mark;
	if (T_Fami==Thermis)
    7ce2:	88 23       	and	r24, r24
    7ce4:	91 f4       	brne	.+36     	; 0x7d0a <Thermode+0x2c>
		switch(T_Type) {
    7ce6:	64 30       	cpi	r22, 0x04	; 4
    7ce8:	d9 f1       	breq	.+118    	; 0x7d60 <Thermode+0x82>
    7cea:	65 30       	cpi	r22, 0x05	; 5
    7cec:	60 f5       	brcc	.+88     	; 0x7d46 <Thermode+0x68>
    7cee:	62 30       	cpi	r22, 0x02	; 2
    7cf0:	09 f4       	brne	.+2      	; 0x7cf4 <Thermode+0x16>
    7cf2:	4b c0       	rjmp	.+150    	; 0x7d8a <Thermode+0xac>
    7cf4:	63 30       	cpi	r22, 0x03	; 3
    7cf6:	d8 f5       	brcc	.+118    	; 0x7d6e <Thermode+0x90>
    7cf8:	61 30       	cpi	r22, 0x01	; 1
    7cfa:	a1 f4       	brne	.+40     	; 0x7d24 <Thermode+0x46>
		case TSM100:
			return ThermCalc(TSM100);
    7cfc:	8f e9       	ldi	r24, 0x9F	; 159
    7cfe:	99 e2       	ldi	r25, 0x29	; 41
    7d00:	ba 01       	movw	r22, r20
    7d02:	0e 94 2c 21 	call	0x4258	; 0x4258 <PGM_uBrokLine>
    7d06:	ac 01       	movw	r20, r24
    7d08:	0d c0       	rjmp	.+26     	; 0x7d24 <Thermode+0x46>
#endif
		default:
			return Code;
		}
	else	// T_Fami==Thermoc
		switch(T_Type) {
    7d0a:	61 30       	cpi	r22, 0x01	; 1
    7d0c:	69 f0       	breq	.+26     	; 0x7d28 <Thermode+0x4a>
    7d0e:	62 30       	cpi	r22, 0x02	; 2
    7d10:	49 f4       	brne	.+18     	; 0x7d24 <Thermode+0x46>
		case TC_K:
			return .1851*Code;
#endif
#if	TerInput==ADC_Input
		case TC_B:
			return ThermCalc(TC_B_);
    7d12:	83 ea       	ldi	r24, 0xA3	; 163
    7d14:	9a e2       	ldi	r25, 0x2A	; 42
    7d16:	ba 01       	movw	r22, r20
    7d18:	0e 94 2c 21 	call	0x4258	; 0x4258 <PGM_uBrokLine>
    7d1c:	ac 01       	movw	r20, r24
    7d1e:	02 c0       	rjmp	.+4      	; 0x7d24 <Thermode+0x46>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
int16_t
Thermode(uint8_t T_Fami, uint8_t T_Type, uint16_t Code)
{
	if (T_Type==ThermOff)
    7d20:	40 e0       	ldi	r20, 0x00	; 0
    7d22:	50 e8       	ldi	r21, 0x80	; 128
			return ThermCalc(TC_B_);
#endif
		default:
			return Code;
		}
}
    7d24:	ca 01       	movw	r24, r20
    7d26:	08 95       	ret
			return ThermCalc(TC_J_) + InnerTer;
		case TC_L:
			return ThermCalc(TC_L_) + InnerTer;
#else
		case TC_K:
			return .1851*Code;
    7d28:	ba 01       	movw	r22, r20
    7d2a:	80 e0       	ldi	r24, 0x00	; 0
    7d2c:	90 e0       	ldi	r25, 0x00	; 0
    7d2e:	0e 94 f2 77 	call	0xefe4	; 0xefe4 <__floatunsisf>
    7d32:	2b ed       	ldi	r18, 0xDB	; 219
    7d34:	3a e8       	ldi	r19, 0x8A	; 138
    7d36:	4d e3       	ldi	r20, 0x3D	; 61
    7d38:	5e e3       	ldi	r21, 0x3E	; 62
    7d3a:	0e 94 2f 78 	call	0xf05e	; 0xf05e <__mulsf3>
    7d3e:	0e 94 c2 7c 	call	0xf984	; 0xf984 <__fixsfsi>
    7d42:	ab 01       	movw	r20, r22
    7d44:	ef cf       	rjmp	.-34     	; 0x7d24 <Thermode+0x46>
Thermode(uint8_t T_Fami, uint8_t T_Type, uint16_t Code)
{
	if (T_Type==ThermOff)
		return Therm_Off_Mark;
	if (T_Fami==Thermis)
		switch(T_Type) {
    7d46:	66 30       	cpi	r22, 0x06	; 6
    7d48:	39 f1       	breq	.+78     	; 0x7d98 <Thermode+0xba>
    7d4a:	66 30       	cpi	r22, 0x06	; 6
    7d4c:	b8 f0       	brcs	.+46     	; 0x7d7c <Thermode+0x9e>
    7d4e:	67 30       	cpi	r22, 0x07	; 7
    7d50:	49 f7       	brne	.-46     	; 0x7d24 <Thermode+0x46>
			return ThermCalc(Pt100);
#if	TerInput==ADC_Input
		case Gr21:
			return ThermCalc(Gr21);
		case Gr23:
			return ThermCalc(Gr23);
    7d52:	83 e8       	ldi	r24, 0x83	; 131
    7d54:	9a e2       	ldi	r25, 0x2A	; 42
    7d56:	ba 01       	movw	r22, r20
    7d58:	0e 94 2c 21 	call	0x4258	; 0x4258 <PGM_uBrokLine>
    7d5c:	ac 01       	movw	r20, r24
    7d5e:	e2 cf       	rjmp	.-60     	; 0x7d24 <Thermode+0x46>
		case TSM50:
			return ThermCalc(TSM50);
		case TSP100:
			return ThermCalc(TSP100);
		case TSP50:
			return ThermCalc(TSP50);
    7d60:	83 e1       	ldi	r24, 0x13	; 19
    7d62:	9a e2       	ldi	r25, 0x2A	; 42
    7d64:	ba 01       	movw	r22, r20
    7d66:	0e 94 2c 21 	call	0x4258	; 0x4258 <PGM_uBrokLine>
    7d6a:	ac 01       	movw	r20, r24
    7d6c:	db cf       	rjmp	.-74     	; 0x7d24 <Thermode+0x46>
		case TSM100:
			return ThermCalc(TSM100);
		case TSM50:
			return ThermCalc(TSM50);
		case TSP100:
			return ThermCalc(TSP100);
    7d6e:	8b ee       	ldi	r24, 0xEB	; 235
    7d70:	99 e2       	ldi	r25, 0x29	; 41
    7d72:	ba 01       	movw	r22, r20
    7d74:	0e 94 2c 21 	call	0x4258	; 0x4258 <PGM_uBrokLine>
    7d78:	ac 01       	movw	r20, r24
    7d7a:	d4 cf       	rjmp	.-88     	; 0x7d24 <Thermode+0x46>
		case TSP50:
			return ThermCalc(TSP50);
		case Pt100:
			return ThermCalc(Pt100);
    7d7c:	87 e3       	ldi	r24, 0x37	; 55
    7d7e:	9a e2       	ldi	r25, 0x2A	; 42
    7d80:	ba 01       	movw	r22, r20
    7d82:	0e 94 2c 21 	call	0x4258	; 0x4258 <PGM_uBrokLine>
    7d86:	ac 01       	movw	r20, r24
    7d88:	cd cf       	rjmp	.-102    	; 0x7d24 <Thermode+0x46>
	if (T_Fami==Thermis)
		switch(T_Type) {
		case TSM100:
			return ThermCalc(TSM100);
		case TSM50:
			return ThermCalc(TSM50);
    7d8a:	8f eb       	ldi	r24, 0xBF	; 191
    7d8c:	99 e2       	ldi	r25, 0x29	; 41
    7d8e:	ba 01       	movw	r22, r20
    7d90:	0e 94 2c 21 	call	0x4258	; 0x4258 <PGM_uBrokLine>
    7d94:	ac 01       	movw	r20, r24
    7d96:	c6 cf       	rjmp	.-116    	; 0x7d24 <Thermode+0x46>
			return ThermCalc(TSP50);
		case Pt100:
			return ThermCalc(Pt100);
#if	TerInput==ADC_Input
		case Gr21:
			return ThermCalc(Gr21);
    7d98:	8f e5       	ldi	r24, 0x5F	; 95
    7d9a:	9a e2       	ldi	r25, 0x2A	; 42
    7d9c:	ba 01       	movw	r22, r20
    7d9e:	0e 94 2c 21 	call	0x4258	; 0x4258 <PGM_uBrokLine>
    7da2:	ac 01       	movw	r20, r24
    7da4:	bf cf       	rjmp	.-130    	; 0x7d24 <Thermode+0x46>

00007da6 <ThermExt>:
			IntOff();
			Temperature[TerReg+i] = (Temperature_Ext)[i];
			IntOn();
		}
	#endif
}
    7da6:	08 95       	ret

00007da8 <Therm_ADC_Off>:

// ~~~~~~~~~~~~~~~~
void
Therm_ADC_Off(void)
{
	for (uint8_t i=0; i<TerReg; Temperature[i++]=ADC_Off_Mark);
    7da8:	81 e0       	ldi	r24, 0x01	; 1
    7daa:	90 e8       	ldi	r25, 0x80	; 128
    7dac:	90 93 3d 06 	sts	0x063D, r25
    7db0:	80 93 3c 06 	sts	0x063C, r24
    7db4:	90 93 3f 06 	sts	0x063F, r25
    7db8:	80 93 3e 06 	sts	0x063E, r24
    7dbc:	90 93 41 06 	sts	0x0641, r25
    7dc0:	80 93 40 06 	sts	0x0640, r24
    7dc4:	90 93 43 06 	sts	0x0643, r25
    7dc8:	80 93 42 06 	sts	0x0642, r24
    7dcc:	90 93 45 06 	sts	0x0645, r25
    7dd0:	80 93 44 06 	sts	0x0644, r24
    7dd4:	90 93 47 06 	sts	0x0647, r25
    7dd8:	80 93 46 06 	sts	0x0646, r24
}
    7ddc:	08 95       	ret

00007dde <ThermWrong>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
ThermWrong(uint8_t T_Fami, uint8_t T_Type, int16_t Ter)
{
	uint8_t TW = ThermNorm;
	if (T_Type!=ThermOff && T_Type<=prb(MaxThermType+T_Fami)) {
    7dde:	66 23       	and	r22, r22
    7de0:	31 f1       	breq	.+76     	; 0x7e2e <ThermWrong+0x50>
    7de2:	28 2f       	mov	r18, r24
    7de4:	30 e0       	ldi	r19, 0x00	; 0

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    7de6:	f9 01       	movw	r30, r18
    7de8:	e7 56       	subi	r30, 0x67	; 103
    7dea:	f6 4d       	sbci	r31, 0xD6	; 214
    7dec:	e4 91       	lpm	r30, Z+
    7dee:	e6 17       	cp	r30, r22
    7df0:	f0 f0       	brcs	.+60     	; 0x7e2e <ThermWrong+0x50>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    7df2:	f9 01       	movw	r30, r18
    7df4:	ee 0f       	add	r30, r30
    7df6:	ff 1f       	adc	r31, r31
    7df8:	e5 56       	subi	r30, 0x65	; 101
    7dfa:	f6 4d       	sbci	r31, 0xD6	; 214
    7dfc:	25 91       	lpm	r18, Z+
    7dfe:	34 91       	lpm	r19, Z+
		TerLim *T_L = prp(TerLimType+T_Fami);
		if (Ter<(int16_t)prw(&T_L[T_Type].Low))
    7e00:	86 2f       	mov	r24, r22
    7e02:	90 e0       	ldi	r25, 0x00	; 0
    7e04:	88 0f       	add	r24, r24
    7e06:	99 1f       	adc	r25, r25
    7e08:	88 0f       	add	r24, r24
    7e0a:	99 1f       	adc	r25, r25
    7e0c:	28 0f       	add	r18, r24
    7e0e:	39 1f       	adc	r19, r25

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    7e10:	f9 01       	movw	r30, r18
    7e12:	85 91       	lpm	r24, Z+
    7e14:	94 91       	lpm	r25, Z+
    7e16:	48 17       	cp	r20, r24
    7e18:	59 07       	cpc	r21, r25
    7e1a:	5c f0       	brlt	.+22     	; 0x7e32 <ThermWrong+0x54>
    7e1c:	f9 01       	movw	r30, r18
    7e1e:	32 96       	adiw	r30, 0x02	; 2
    7e20:	85 91       	lpm	r24, Z+
    7e22:	94 91       	lpm	r25, Z+
			TW = ThermUnder;
		else if(Ter>(int16_t)prw(&T_L[T_Type].Upp))
    7e24:	84 17       	cp	r24, r20
    7e26:	95 07       	cpc	r25, r21
    7e28:	14 f4       	brge	.+4      	; 0x7e2e <ThermWrong+0x50>
    7e2a:	82 e0       	ldi	r24, 0x02	; 2
    7e2c:	08 95       	ret
    7e2e:	80 e0       	ldi	r24, 0x00	; 0
			TW = ThermOver;
	}
	return TW;
}
    7e30:	08 95       	ret
ThermWrong(uint8_t T_Fami, uint8_t T_Type, int16_t Ter)
{
	uint8_t TW = ThermNorm;
	if (T_Type!=ThermOff && T_Type<=prb(MaxThermType+T_Fami)) {
		TerLim *T_L = prp(TerLimType+T_Fami);
		if (Ter<(int16_t)prw(&T_L[T_Type].Low))
    7e32:	81 e0       	ldi	r24, 0x01	; 1
    7e34:	08 95       	ret

00007e36 <Key_MB0_CPT_Clear>:
	{" BAUD: }}}}}bps     ", NULL, F_MB##N##_Baud}																														\
};																																																					\
MenuPage MenuModbus##N = {SetMenu(L_MB##N), 1};

#if Modbus_Qt == 1
	M_Modbus(0)
    7e36:	80 e0       	ldi	r24, 0x00	; 0
    7e38:	90 e0       	ldi	r25, 0x00	; 0

// ~~~~~~~~~~~~~~~~~~~~~~~
void
MB_CPT_Clear(uint8_t MB_N)
{
	for (uint8_t i=0; i<8; MB_CPT[MB_N][i++]=0);
    7e3a:	fc 01       	movw	r30, r24
    7e3c:	ee 0f       	add	r30, r30
    7e3e:	ff 1f       	adc	r31, r31
    7e40:	ec 51       	subi	r30, 0x1C	; 28
    7e42:	f7 4f       	sbci	r31, 0xF7	; 247
    7e44:	11 82       	std	Z+1, r1	; 0x01
    7e46:	10 82       	st	Z, r1
    7e48:	01 96       	adiw	r24, 0x01	; 1
    7e4a:	88 30       	cpi	r24, 0x08	; 8
    7e4c:	91 05       	cpc	r25, r1
    7e4e:	a9 f7       	brne	.-22     	; 0x7e3a <Key_MB0_CPT_Clear+0x4>
    7e50:	81 e0       	ldi	r24, 0x01	; 1
    7e52:	08 95       	ret

00007e54 <ResetGSMState>:
	#ifdef GSM_DEBUG
		MenuPage MenuGSMConsole;
	#endif

	void ResetGSMState(void){
		GSM_State = GSM_ReStart1;
    7e54:	83 e3       	ldi	r24, 0x33	; 51
    7e56:	80 93 ac 06 	sts	0x06AC, r24
	}
    7e5a:	08 95       	ret

00007e5c <Key_MaxScanCycle_Clear>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
InField F_ScanCycle[] = { {Byte, &ScanCycle} };
InField F_ScanCyclePerSec[] = { {Word, &ScanPerSec} }; 
InField F_MaxScanCycle[] = {{Byte, &MaxScanCycle}};

uint8_t Key_MaxScanCycle_Clear(void) {if(CurrLine==3) MaxScanCycle_Clear(); return StandartKey;}
    7e5c:	80 91 79 07 	lds	r24, 0x0779
    7e60:	83 30       	cpi	r24, 0x03	; 3
    7e62:	11 f4       	brne	.+4      	; 0x7e68 <Key_MaxScanCycle_Clear+0xc>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
void
MaxScanCycle_Clear(void)
{
	MaxScanCycle = 0;
    7e64:	10 92 a8 06 	sts	0x06A8, r1
    7e68:	80 e0       	ldi	r24, 0x00	; 0
    7e6a:	08 95       	ret

00007e6c <ApplInit>:
void
ApplInit(void)
{
	

}
    7e6c:	08 95       	ret

00007e6e <ApplCycle>:
// ~~~~~~~~~~~~
void
ApplCycle(void)
{

}
    7e6e:	08 95       	ret

00007e70 <StartKey>:
// ~~~~~~~~~~~
void
StartKey(void)
{	

}
    7e70:	08 95       	ret

00007e72 <StopKey>:
// ~~~~~~~~~~
void
StopKey(void)
{
	
}
    7e72:	08 95       	ret

00007e74 <Menu_ConfirmationRest_Enter>:
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	//		   
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	uint8_t Menu_ConfirmationRest_Enter(){

		eeprom_write_byte((uint8_t*)E2END, 0xBB);
    7e74:	8f ef       	ldi	r24, 0xFF	; 255
    7e76:	9f e0       	ldi	r25, 0x0F	; 15
    7e78:	6b eb       	ldi	r22, 0xBB	; 187
    7e7a:	0e 94 21 7d 	call	0xfa42	; 0xfa42 <__eewr_byte_m2560>
		eeprom_write_byte(&MemCheck_stor.ReprogFlg, 0);
    7e7e:	8c e3       	ldi	r24, 0x3C	; 60
    7e80:	91 e0       	ldi	r25, 0x01	; 1
    7e82:	60 e0       	ldi	r22, 0x00	; 0
    7e84:	0e 94 21 7d 	call	0xfa42	; 0xfa42 <__eewr_byte_m2560>
    7e88:	ff cf       	rjmp	.-2      	; 0x7e88 <Menu_ConfirmationRest_Enter+0x14>

00007e8a <Menu_ConfirmationSave_Enter>:
	//		   
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	uint8_t Menu_ConfirmationSave_Enter(){

		//  backup-
		eeprom_write_byte((uint8_t*)E2END, 0xAA);
    7e8a:	8f ef       	ldi	r24, 0xFF	; 255
    7e8c:	9f e0       	ldi	r25, 0x0F	; 15
    7e8e:	6a ea       	ldi	r22, 0xAA	; 170
    7e90:	0e 94 21 7d 	call	0xfa42	; 0xfa42 <__eewr_byte_m2560>
		eeprom_write_byte(&DateBackUp.Day, Tm_MDay);
    7e94:	80 e0       	ldi	r24, 0x00	; 0
    7e96:	90 e0       	ldi	r25, 0x00	; 0
    7e98:	60 91 0d 0b 	lds	r22, 0x0B0D
    7e9c:	0e 94 21 7d 	call	0xfa42	; 0xfa42 <__eewr_byte_m2560>
		eeprom_write_byte(&DateBackUp.Month, Tm_Mon);
    7ea0:	81 e0       	ldi	r24, 0x01	; 1
    7ea2:	90 e0       	ldi	r25, 0x00	; 0
    7ea4:	60 91 7b 07 	lds	r22, 0x077B
    7ea8:	0e 94 21 7d 	call	0xfa42	; 0xfa42 <__eewr_byte_m2560>
		#ifdef M41T56
			eeprom_write_byte(&DateBackUp.Year, Tm_Year);
    7eac:	82 e0       	ldi	r24, 0x02	; 2
    7eae:	90 e0       	ldi	r25, 0x00	; 0
    7eb0:	60 91 d5 05 	lds	r22, 0x05D5
    7eb4:	0e 94 21 7d 	call	0xfa42	; 0xfa42 <__eewr_byte_m2560>
		#else
			eeprom_write_byte(&DateBackUp.Year, erb(&Tm_Year));
		#endif
		eeprom_write_byte(&MemCheck_stor.ReprogFlg, 0);
    7eb8:	8c e3       	ldi	r24, 0x3C	; 60
    7eba:	91 e0       	ldi	r25, 0x01	; 1
    7ebc:	60 e0       	ldi	r22, 0x00	; 0
    7ebe:	0e 94 21 7d 	call	0xfa42	; 0xfa42 <__eewr_byte_m2560>
    7ec2:	ff cf       	rjmp	.-2      	; 0x7ec2 <Menu_ConfirmationSave_Enter+0x38>

00007ec4 <GSM_SendData>:
	GSMTxSz = Size;
	memcpy(GSM_TxStr, Data_Out, GSMTxSz);
	GSM_SendFirstChar();
}
// ~~~~~~~~~
void GSM_SendData(uint8_t *Data_Out, uint8_t Size){
    7ec4:	58 2f       	mov	r21, r24
    7ec6:	79 2f       	mov	r23, r25
	GSMTxSz = Size;
    7ec8:	60 93 6b 07 	sts	0x076B, r22
	memcpy(GSM_TxStr, Data_Out, GSMTxSz);
    7ecc:	40 91 6b 07 	lds	r20, 0x076B
    7ed0:	28 ef       	ldi	r18, 0xF8	; 248
    7ed2:	39 e0       	ldi	r19, 0x09	; 9
    7ed4:	c9 01       	movw	r24, r18
    7ed6:	65 2f       	mov	r22, r21
    7ed8:	50 e0       	ldi	r21, 0x00	; 0
    7eda:	0e 94 25 7a 	call	0xf44a	; 0xf44a <memcpy>
	GSM_SendFirstChar();
    7ede:	0e 94 dd 38 	call	0x71ba	; 0x71ba <GSM_SendFirstChar>
}
    7ee2:	08 95       	ret

00007ee4 <GSM_AddHeaderSendData>:
	GSMTxSz++;
	GSM_SendFirstChar();
}
// ~~~~~~~~~
//   + CntrZ
void GSM_AddHeaderSendData(uint8_t *Data_Out, uint8_t Size){
    7ee4:	58 2f       	mov	r21, r24
    7ee6:	79 2f       	mov	r23, r25
	GSMTxSz = Size;
    7ee8:	60 93 6b 07 	sts	0x076B, r22
	memcpy(GSM_TxStr, Data_Out, GSMTxSz);
    7eec:	40 91 6b 07 	lds	r20, 0x076B
    7ef0:	28 ef       	ldi	r18, 0xF8	; 248
    7ef2:	39 e0       	ldi	r19, 0x09	; 9
    7ef4:	c9 01       	movw	r24, r18
    7ef6:	65 2f       	mov	r22, r21
    7ef8:	50 e0       	ldi	r21, 0x00	; 0
    7efa:	0e 94 25 7a 	call	0xf44a	; 0xf44a <memcpy>
	GSM_SendFirstChar();
    7efe:	0e 94 dd 38 	call	0x71ba	; 0x71ba <GSM_SendFirstChar>
}
    7f02:	08 95       	ret

00007f04 <PresicionHanler>:
		ew##ty3((ty2*)Var, Min);						\
	else																	\
		ew##ty3((ty2*)Var, (ty2)Buf)
// ~~~~~~~~~~~~~~~~~~~~~~~
//Change BufStr due to precision for correct sscanf reading BufStr
void PresicionHanler(OutField *Field){
    7f04:	cf 93       	push	r28
    7f06:	df 93       	push	r29

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    7f08:	ec 01       	movw	r28, r24
    7f0a:	2f 96       	adiw	r28, 0x0f	; 15
    7f0c:	fe 01       	movw	r30, r28
    7f0e:	84 91       	lpm	r24, Z+
	if(prb(&Field->Prec)){
    7f10:	88 23       	and	r24, r24
    7f12:	19 f4       	brne	.+6      	; 0x7f1a <PresicionHanler+0x16>
			}
			p++;
		}
	}
	
}
    7f14:	df 91       	pop	r29
    7f16:	cf 91       	pop	r28
    7f18:	08 95       	ret
		ew##ty3((ty2*)Var, (ty2)Buf)
// ~~~~~~~~~~~~~~~~~~~~~~~
//Change BufStr due to precision for correct sscanf reading BufStr
void PresicionHanler(OutField *Field){
	if(prb(&Field->Prec)){
		char *p = strchr(BufStr,'.');	//seek for first decimal point
    7f1a:	8a eb       	ldi	r24, 0xBA	; 186
    7f1c:	95 e0       	ldi	r25, 0x05	; 5
    7f1e:	6e e2       	ldi	r22, 0x2E	; 46
    7f20:	70 e0       	ldi	r23, 0x00	; 0
    7f22:	0e 94 2e 7a 	call	0xf45c	; 0xf45c <strchr>
		if(p==NULL){
    7f26:	00 97       	sbiw	r24, 0x00	; 0
    7f28:	01 f1       	breq	.+64     	; 0x7f6a <PresicionHanler+0x66>
    7f2a:	fe 01       	movw	r30, r28
    7f2c:	24 91       	lpm	r18, Z+
			p = strchr(BufStr,' ');	//else seek for first space
		}
	  	for(uint8_t i=0; i<prb(&Field->Prec); i++){
    7f2e:	22 23       	and	r18, r18
    7f30:	89 f3       	breq	.-30     	; 0x7f14 <PresicionHanler+0x10>
    7f32:	fc 01       	movw	r30, r24
    7f34:	dc 01       	movw	r26, r24
    7f36:	11 96       	adiw	r26, 0x01	; 1
    7f38:	30 e0       	ldi	r19, 0x00	; 0
			if(*p == '.'){
				if(isdigit(*(p+1))){
					*p= *(p+1);
					*(p+1) = '.';
				}
				else *p='0'; 
    7f3a:	60 e3       	ldi	r22, 0x30	; 48
    7f3c:	52 2f       	mov	r21, r18
    7f3e:	07 c0       	rjmp	.+14     	; 0x7f4e <PresicionHanler+0x4a>
		if(p==NULL){
			p = strchr(BufStr,' ');	//else seek for first space
		}
	  	for(uint8_t i=0; i<prb(&Field->Prec); i++){
			if(*p == ' ') *p='0'; 
			if(*p == '.'){
    7f40:	2e 32       	cpi	r18, 0x2E	; 46
    7f42:	51 f0       	breq	.+20     	; 0x7f58 <PresicionHanler+0x54>
	if(prb(&Field->Prec)){
		char *p = strchr(BufStr,'.');	//seek for first decimal point
		if(p==NULL){
			p = strchr(BufStr,' ');	//else seek for first space
		}
	  	for(uint8_t i=0; i<prb(&Field->Prec); i++){
    7f44:	3f 5f       	subi	r19, 0xFF	; 255
    7f46:	31 96       	adiw	r30, 0x01	; 1
    7f48:	11 96       	adiw	r26, 0x01	; 1
    7f4a:	35 17       	cp	r19, r21
    7f4c:	18 f7       	brcc	.-58     	; 0x7f14 <PresicionHanler+0x10>
			if(*p == ' ') *p='0'; 
    7f4e:	20 81       	ld	r18, Z
    7f50:	20 32       	cpi	r18, 0x20	; 32
    7f52:	b1 f7       	brne	.-20     	; 0x7f40 <PresicionHanler+0x3c>
			if(*p == '.'){
				if(isdigit(*(p+1))){
					*p= *(p+1);
					*(p+1) = '.';
				}
				else *p='0'; 
    7f54:	60 83       	st	Z, r22
    7f56:	f6 cf       	rjmp	.-20     	; 0x7f44 <PresicionHanler+0x40>
			p = strchr(BufStr,' ');	//else seek for first space
		}
	  	for(uint8_t i=0; i<prb(&Field->Prec); i++){
			if(*p == ' ') *p='0'; 
			if(*p == '.'){
				if(isdigit(*(p+1))){
    7f58:	4c 91       	ld	r20, X
    7f5a:	84 2f       	mov	r24, r20
    7f5c:	90 e0       	ldi	r25, 0x00	; 0
    7f5e:	c0 97       	sbiw	r24, 0x30	; 48
    7f60:	0a 97       	sbiw	r24, 0x0a	; 10
    7f62:	c0 f7       	brcc	.-16     	; 0x7f54 <PresicionHanler+0x50>
					*p= *(p+1);
    7f64:	40 83       	st	Z, r20
					*(p+1) = '.';
    7f66:	2c 93       	st	X, r18
    7f68:	ed cf       	rjmp	.-38     	; 0x7f44 <PresicionHanler+0x40>
//Change BufStr due to precision for correct sscanf reading BufStr
void PresicionHanler(OutField *Field){
	if(prb(&Field->Prec)){
		char *p = strchr(BufStr,'.');	//seek for first decimal point
		if(p==NULL){
			p = strchr(BufStr,' ');	//else seek for first space
    7f6a:	8a eb       	ldi	r24, 0xBA	; 186
    7f6c:	95 e0       	ldi	r25, 0x05	; 5
    7f6e:	60 e2       	ldi	r22, 0x20	; 32
    7f70:	70 e0       	ldi	r23, 0x00	; 0
    7f72:	0e 94 2e 7a 	call	0xf45c	; 0xf45c <strchr>
    7f76:	d9 cf       	rjmp	.-78     	; 0x7f2a <PresicionHanler+0x26>

00007f78 <GetMultiSymbol>:
	}
	return 0;
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~
//    MultiSymbol   
uint8_t GetMultiSymbol(PGM_P Str_P, char Char){
    7f78:	1f 93       	push	r17
    7f7a:	18 2f       	mov	r17, r24
	PGM_P ptr_P= strchr_P(Str_P, Char);
    7f7c:	70 e0       	ldi	r23, 0x00	; 0
    7f7e:	0e 94 ce 79 	call	0xf39c	; 0xf39c <strchr_P>
	if(ptr_P) return (uint8_t)(ptr_P - Str_P);
    7f82:	00 97       	sbiw	r24, 0x00	; 0
    7f84:	19 f0       	breq	.+6      	; 0x7f8c <GetMultiSymbol+0x14>
    7f86:	81 1b       	sub	r24, r17
	else return 0;
}
    7f88:	1f 91       	pop	r17
    7f8a:	08 95       	ret
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~
//    MultiSymbol   
uint8_t GetMultiSymbol(PGM_P Str_P, char Char){
	PGM_P ptr_P= strchr_P(Str_P, Char);
	if(ptr_P) return (uint8_t)(ptr_P - Str_P);
    7f8c:	80 e0       	ldi	r24, 0x00	; 0
	else return 0;
}
    7f8e:	1f 91       	pop	r17
    7f90:	08 95       	ret

00007f92 <PutEnum>:
} T_Param;

// ~~~~~~~~~~~~~~~~~~~~
void
PutEnum(T_Param *Param)
{
    7f92:	0f 93       	push	r16
    7f94:	1f 93       	push	r17
    7f96:	cf 93       	push	r28
    7f98:	df 93       	push	r29
    7f9a:	8c 01       	movw	r16, r24

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    7f9c:	dc 01       	movw	r26, r24
    7f9e:	14 96       	adiw	r26, 0x04	; 4
    7fa0:	ed 91       	ld	r30, X+
    7fa2:	fc 91       	ld	r31, X
    7fa4:	15 97       	sbiw	r26, 0x05	; 5
    7fa6:	65 91       	lpm	r22, Z+
    7fa8:	74 91       	lpm	r23, Z+
	strcpy_P(Param->Pos, prp(Param->Txt));
    7faa:	8d 91       	ld	r24, X+
    7fac:	9c 91       	ld	r25, X
    7fae:	0e 94 e2 79 	call	0xf3c4	; 0xf3c4 <strcpy_P>
	for(uint8_t i=strlen(Param->Pos); i<Param->Size; *(Param->Pos+i++)=' ');
    7fb2:	f8 01       	movw	r30, r16
    7fb4:	c0 81       	ld	r28, Z
    7fb6:	d1 81       	ldd	r29, Z+1	; 0x01
    7fb8:	fe 01       	movw	r30, r28
    7fba:	01 90       	ld	r0, Z+
    7fbc:	00 20       	and	r0, r0
    7fbe:	e9 f7       	brne	.-6      	; 0x7fba <PutEnum+0x28>
    7fc0:	31 97       	sbiw	r30, 0x01	; 1
    7fc2:	ec 1b       	sub	r30, r28
    7fc4:	d8 01       	movw	r26, r16
    7fc6:	13 96       	adiw	r26, 0x03	; 3
    7fc8:	8c 91       	ld	r24, X
    7fca:	e8 17       	cp	r30, r24
    7fcc:	70 f4       	brcc	.+28     	; 0x7fea <PutEnum+0x58>
    7fce:	90 e2       	ldi	r25, 0x20	; 32
    7fd0:	02 c0       	rjmp	.+4      	; 0x7fd6 <PutEnum+0x44>
    7fd2:	cd 91       	ld	r28, X+
    7fd4:	dc 91       	ld	r29, X
    7fd6:	ce 0f       	add	r28, r30
    7fd8:	d1 1d       	adc	r29, r1
    7fda:	98 83       	st	Y, r25
    7fdc:	ef 5f       	subi	r30, 0xFF	; 255
    7fde:	d8 01       	movw	r26, r16
    7fe0:	13 96       	adiw	r26, 0x03	; 3
    7fe2:	8c 91       	ld	r24, X
    7fe4:	13 97       	sbiw	r26, 0x03	; 3
    7fe6:	e8 17       	cp	r30, r24
    7fe8:	a0 f3       	brcs	.-24     	; 0x7fd2 <PutEnum+0x40>
}
    7fea:	df 91       	pop	r29
    7fec:	cf 91       	pop	r28
    7fee:	1f 91       	pop	r17
    7ff0:	0f 91       	pop	r16
    7ff2:	08 95       	ret

00007ff4 <Put_sbVal>:
}

// ~~~~~~~~~~~~~~~~~~~~~~
void
Put_sbVal(T_Param *Param)
{
    7ff4:	6f 92       	push	r6
    7ff6:	7f 92       	push	r7
    7ff8:	8f 92       	push	r8
    7ffa:	9f 92       	push	r9
    7ffc:	af 92       	push	r10
    7ffe:	bf 92       	push	r11
    8000:	cf 92       	push	r12
    8002:	df 92       	push	r13
    8004:	ef 92       	push	r14
    8006:	ff 92       	push	r15
    8008:	0f 93       	push	r16
    800a:	1f 93       	push	r17
    800c:	df 93       	push	r29
    800e:	cf 93       	push	r28
    8010:	cd b7       	in	r28, 0x3d	; 61
    8012:	de b7       	in	r29, 0x3e	; 62
    8014:	2c 97       	sbiw	r28, 0x0c	; 12
    8016:	0f b6       	in	r0, 0x3f	; 63
    8018:	f8 94       	cli
    801a:	de bf       	out	0x3e, r29	; 62
    801c:	0f be       	out	0x3f, r0	; 63
    801e:	cd bf       	out	0x3d, r28	; 61
    8020:	5c 01       	movw	r10, r24
	char Format[] = "%0+ li.%. u";
    8022:	be 01       	movw	r22, r28
    8024:	6f 5f       	subi	r22, 0xFF	; 255
    8026:	7f 4f       	sbci	r23, 0xFF	; 255
    8028:	db 01       	movw	r26, r22
    802a:	e0 e0       	ldi	r30, 0x00	; 0
    802c:	f2 e0       	ldi	r31, 0x02	; 2
    802e:	8c e0       	ldi	r24, 0x0C	; 12
    8030:	01 90       	ld	r0, Z+
    8032:	0d 92       	st	X+, r0
    8034:	81 50       	subi	r24, 0x01	; 1
    8036:	e1 f7       	brne	.-8      	; 0x8030 <Put_sbVal+0x3c>
	Format[3] = '0'+Param->Size;
    8038:	d5 01       	movw	r26, r10
    803a:	13 96       	adiw	r26, 0x03	; 3
    803c:	2c 91       	ld	r18, X
    803e:	13 97       	sbiw	r26, 0x03	; 3
    8040:	20 5d       	subi	r18, 0xD0	; 208
    8042:	2c 83       	std	Y+4, r18	; 0x04
	if(Param->Prec) {
    8044:	12 96       	adiw	r26, 0x02	; 2
    8046:	9c 91       	ld	r25, X
    8048:	99 23       	and	r25, r25
    804a:	09 f4       	brne	.+2      	; 0x804e <Put_sbVal+0x5a>
    804c:	8d c0       	rjmp	.+282    	; 0x8168 <Put_sbVal+0x174>
		Format[3] -= Param->Prec+1;
    804e:	89 2f       	mov	r24, r25
    8050:	80 95       	com	r24
    8052:	82 0f       	add	r24, r18
    8054:	8c 83       	std	Y+4, r24	; 0x04
		Format[9] = '0'+Param->Prec;
    8056:	90 5d       	subi	r25, 0xD0	; 208
    8058:	9a 87       	std	Y+10, r25	; 0x0a
    805a:	90 53       	subi	r25, 0x30	; 48
		int16_t Div=Pow10(Param->Prec);
    805c:	49 2f       	mov	r20, r25
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    805e:	21 e0       	ldi	r18, 0x01	; 1
    8060:	30 e0       	ldi	r19, 0x00	; 0
		Pow *= 10;
    8062:	c9 01       	movw	r24, r18
    8064:	88 0f       	add	r24, r24
    8066:	99 1f       	adc	r25, r25
    8068:	22 0f       	add	r18, r18
    806a:	33 1f       	adc	r19, r19
    806c:	22 0f       	add	r18, r18
    806e:	33 1f       	adc	r19, r19
    8070:	22 0f       	add	r18, r18
    8072:	33 1f       	adc	r19, r19
    8074:	28 0f       	add	r18, r24
    8076:	39 1f       	adc	r19, r25
    8078:	41 50       	subi	r20, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    807a:	99 f7       	brne	.-26     	; 0x8062 <Put_sbVal+0x6e>
    807c:	39 01       	movw	r6, r18
    807e:	88 24       	eor	r8, r8
    8080:	77 fc       	sbrc	r7, 7
    8082:	80 94       	com	r8
    8084:	98 2c       	mov	r9, r8
		sprintf(Param->Pos, Format, sF_Buf/Div, (uint32_t)labs(sF_Buf)%Div);
    8086:	10 91 f2 04 	lds	r17, 0x04F2
    808a:	00 91 f3 04 	lds	r16, 0x04F3
    808e:	f0 90 f4 04 	lds	r15, 0x04F4
    8092:	e0 90 f5 04 	lds	r14, 0x04F5
    8096:	ed b7       	in	r30, 0x3d	; 61
    8098:	fe b7       	in	r31, 0x3e	; 62
    809a:	3c 97       	sbiw	r30, 0x0c	; 12
    809c:	0f b6       	in	r0, 0x3f	; 63
    809e:	f8 94       	cli
    80a0:	fe bf       	out	0x3e, r31	; 62
    80a2:	0f be       	out	0x3f, r0	; 63
    80a4:	ed bf       	out	0x3d, r30	; 61
    80a6:	cd b6       	in	r12, 0x3d	; 61
    80a8:	de b6       	in	r13, 0x3e	; 62
    80aa:	08 94       	sec
    80ac:	c1 1c       	adc	r12, r1
    80ae:	d1 1c       	adc	r13, r1
    80b0:	d5 01       	movw	r26, r10
    80b2:	8d 91       	ld	r24, X+
    80b4:	9c 91       	ld	r25, X
    80b6:	92 83       	std	Z+2, r25	; 0x02
    80b8:	81 83       	std	Z+1, r24	; 0x01
    80ba:	f6 01       	movw	r30, r12
    80bc:	73 83       	std	Z+3, r23	; 0x03
    80be:	62 83       	std	Z+2, r22	; 0x02
    80c0:	61 2f       	mov	r22, r17
    80c2:	70 2f       	mov	r23, r16
    80c4:	8f 2d       	mov	r24, r15
    80c6:	9e 2d       	mov	r25, r14
    80c8:	a4 01       	movw	r20, r8
    80ca:	93 01       	movw	r18, r6
    80cc:	0e 94 b3 7d 	call	0xfb66	; 0xfb66 <__divmodsi4>
    80d0:	d6 01       	movw	r26, r12
    80d2:	14 96       	adiw	r26, 0x04	; 4
    80d4:	2d 93       	st	X+, r18
    80d6:	3d 93       	st	X+, r19
    80d8:	4d 93       	st	X+, r20
    80da:	5c 93       	st	X, r21
    80dc:	17 97       	sbiw	r26, 0x07	; 7
    80de:	21 2f       	mov	r18, r17
    80e0:	30 2f       	mov	r19, r16
    80e2:	4f 2d       	mov	r20, r15
    80e4:	5e 2d       	mov	r21, r14
    80e6:	c9 01       	movw	r24, r18
    80e8:	da 01       	movw	r26, r20
    80ea:	bc 01       	movw	r22, r24
    80ec:	cd 01       	movw	r24, r26
    80ee:	97 fd       	sbrc	r25, 7
    80f0:	77 c0       	rjmp	.+238    	; 0x81e0 <Put_sbVal+0x1ec>
    80f2:	a4 01       	movw	r20, r8
    80f4:	93 01       	movw	r18, r6
    80f6:	0e 94 91 7d 	call	0xfb22	; 0xfb22 <__udivmodsi4>
    80fa:	f6 01       	movw	r30, r12
    80fc:	60 87       	std	Z+8, r22	; 0x08
    80fe:	71 87       	std	Z+9, r23	; 0x09
    8100:	82 87       	std	Z+10, r24	; 0x0a
    8102:	93 87       	std	Z+11, r25	; 0x0b
    8104:	0e 94 d5 7a 	call	0xf5aa	; 0xf5aa <sprintf>
		if(sF_Buf<0) {
    8108:	8d b7       	in	r24, 0x3d	; 61
    810a:	9e b7       	in	r25, 0x3e	; 62
    810c:	0c 96       	adiw	r24, 0x0c	; 12
    810e:	0f b6       	in	r0, 0x3f	; 63
    8110:	f8 94       	cli
    8112:	9e bf       	out	0x3e, r25	; 62
    8114:	0f be       	out	0x3f, r0	; 63
    8116:	8d bf       	out	0x3d, r24	; 61
    8118:	80 91 f2 04 	lds	r24, 0x04F2
    811c:	90 91 f3 04 	lds	r25, 0x04F3
    8120:	a0 91 f4 04 	lds	r26, 0x04F4
    8124:	b0 91 f5 04 	lds	r27, 0x04F5
    8128:	b7 fd       	sbrc	r27, 7
    812a:	4a c0       	rjmp	.+148    	; 0x81c0 <Put_sbVal+0x1cc>
	}
	else {
		Format[6] = '\0';
		sprintf(Param->Pos, Format, sF_Buf);
	}
	if(Minus)
    812c:	80 91 f6 04 	lds	r24, 0x04F6
    8130:	88 23       	and	r24, r24
    8132:	29 f0       	breq	.+10     	; 0x813e <Put_sbVal+0x14a>
		*Param->Pos = '-';
    8134:	d5 01       	movw	r26, r10
    8136:	ed 91       	ld	r30, X+
    8138:	fc 91       	ld	r31, X
    813a:	8d e2       	ldi	r24, 0x2D	; 45
    813c:	80 83       	st	Z, r24
}
    813e:	2c 96       	adiw	r28, 0x0c	; 12
    8140:	0f b6       	in	r0, 0x3f	; 63
    8142:	f8 94       	cli
    8144:	de bf       	out	0x3e, r29	; 62
    8146:	0f be       	out	0x3f, r0	; 63
    8148:	cd bf       	out	0x3d, r28	; 61
    814a:	cf 91       	pop	r28
    814c:	df 91       	pop	r29
    814e:	1f 91       	pop	r17
    8150:	0f 91       	pop	r16
    8152:	ff 90       	pop	r15
    8154:	ef 90       	pop	r14
    8156:	df 90       	pop	r13
    8158:	cf 90       	pop	r12
    815a:	bf 90       	pop	r11
    815c:	af 90       	pop	r10
    815e:	9f 90       	pop	r9
    8160:	8f 90       	pop	r8
    8162:	7f 90       	pop	r7
    8164:	6f 90       	pop	r6
    8166:	08 95       	ret
				Param->Pos++;
			*Param->Pos = '-';
		}
	}
	else {
		Format[6] = '\0';
    8168:	1f 82       	std	Y+7, r1	; 0x07
		sprintf(Param->Pos, Format, sF_Buf);
    816a:	ed b7       	in	r30, 0x3d	; 61
    816c:	fe b7       	in	r31, 0x3e	; 62
    816e:	38 97       	sbiw	r30, 0x08	; 8
    8170:	0f b6       	in	r0, 0x3f	; 63
    8172:	f8 94       	cli
    8174:	fe bf       	out	0x3e, r31	; 62
    8176:	0f be       	out	0x3f, r0	; 63
    8178:	ed bf       	out	0x3d, r30	; 61
    817a:	31 96       	adiw	r30, 0x01	; 1
    817c:	d5 01       	movw	r26, r10
    817e:	8d 91       	ld	r24, X+
    8180:	9c 91       	ld	r25, X
    8182:	ad b7       	in	r26, 0x3d	; 61
    8184:	be b7       	in	r27, 0x3e	; 62
    8186:	12 96       	adiw	r26, 0x02	; 2
    8188:	9c 93       	st	X, r25
    818a:	8e 93       	st	-X, r24
    818c:	11 97       	sbiw	r26, 0x01	; 1
    818e:	73 83       	std	Z+3, r23	; 0x03
    8190:	62 83       	std	Z+2, r22	; 0x02
    8192:	80 91 f2 04 	lds	r24, 0x04F2
    8196:	90 91 f3 04 	lds	r25, 0x04F3
    819a:	a0 91 f4 04 	lds	r26, 0x04F4
    819e:	b0 91 f5 04 	lds	r27, 0x04F5
    81a2:	84 83       	std	Z+4, r24	; 0x04
    81a4:	95 83       	std	Z+5, r25	; 0x05
    81a6:	a6 83       	std	Z+6, r26	; 0x06
    81a8:	b7 83       	std	Z+7, r27	; 0x07
    81aa:	0e 94 d5 7a 	call	0xf5aa	; 0xf5aa <sprintf>
    81ae:	ed b7       	in	r30, 0x3d	; 61
    81b0:	fe b7       	in	r31, 0x3e	; 62
    81b2:	38 96       	adiw	r30, 0x08	; 8
    81b4:	0f b6       	in	r0, 0x3f	; 63
    81b6:	f8 94       	cli
    81b8:	fe bf       	out	0x3e, r31	; 62
    81ba:	0f be       	out	0x3f, r0	; 63
    81bc:	ed bf       	out	0x3d, r30	; 61
    81be:	b6 cf       	rjmp	.-148    	; 0x812c <Put_sbVal+0x138>
		Format[3] -= Param->Prec+1;
		Format[9] = '0'+Param->Prec;
		int16_t Div=Pow10(Param->Prec);
		sprintf(Param->Pos, Format, sF_Buf/Div, (uint32_t)labs(sF_Buf)%Div);
		if(sF_Buf<0) {
			while(*Param->Pos==' ')
    81c0:	d5 01       	movw	r26, r10
    81c2:	ed 91       	ld	r30, X+
    81c4:	fc 91       	ld	r31, X
    81c6:	80 81       	ld	r24, Z
    81c8:	80 32       	cpi	r24, 0x20	; 32
    81ca:	39 f4       	brne	.+14     	; 0x81da <Put_sbVal+0x1e6>
				Param->Pos++;
    81cc:	31 96       	adiw	r30, 0x01	; 1
    81ce:	d5 01       	movw	r26, r10
    81d0:	ed 93       	st	X+, r30
    81d2:	fc 93       	st	X, r31
		Format[3] -= Param->Prec+1;
		Format[9] = '0'+Param->Prec;
		int16_t Div=Pow10(Param->Prec);
		sprintf(Param->Pos, Format, sF_Buf/Div, (uint32_t)labs(sF_Buf)%Div);
		if(sF_Buf<0) {
			while(*Param->Pos==' ')
    81d4:	80 81       	ld	r24, Z
    81d6:	80 32       	cpi	r24, 0x20	; 32
    81d8:	c9 f3       	breq	.-14     	; 0x81cc <Put_sbVal+0x1d8>
				Param->Pos++;
			*Param->Pos = '-';
    81da:	8d e2       	ldi	r24, 0x2D	; 45
    81dc:	80 83       	st	Z, r24
    81de:	a6 cf       	rjmp	.-180    	; 0x812c <Put_sbVal+0x138>
	Format[3] = '0'+Param->Size;
	if(Param->Prec) {
		Format[3] -= Param->Prec+1;
		Format[9] = '0'+Param->Prec;
		int16_t Div=Pow10(Param->Prec);
		sprintf(Param->Pos, Format, sF_Buf/Div, (uint32_t)labs(sF_Buf)%Div);
    81e0:	90 95       	com	r25
    81e2:	80 95       	com	r24
    81e4:	70 95       	com	r23
    81e6:	61 95       	neg	r22
    81e8:	7f 4f       	sbci	r23, 0xFF	; 255
    81ea:	8f 4f       	sbci	r24, 0xFF	; 255
    81ec:	9f 4f       	sbci	r25, 0xFF	; 255
    81ee:	81 cf       	rjmp	.-254    	; 0x80f2 <Put_sbVal+0xfe>

000081f0 <Put_bVal>:
}

// ~~~~~~~~~~~~~~~~~~~~~
void
Put_bVal(T_Param *Param)
{
    81f0:	6f 92       	push	r6
    81f2:	7f 92       	push	r7
    81f4:	8f 92       	push	r8
    81f6:	9f 92       	push	r9
    81f8:	af 92       	push	r10
    81fa:	bf 92       	push	r11
    81fc:	cf 92       	push	r12
    81fe:	df 92       	push	r13
    8200:	ef 92       	push	r14
    8202:	ff 92       	push	r15
    8204:	0f 93       	push	r16
    8206:	1f 93       	push	r17
    8208:	df 93       	push	r29
    820a:	cf 93       	push	r28
    820c:	cd b7       	in	r28, 0x3d	; 61
    820e:	de b7       	in	r29, 0x3e	; 62
    8210:	2b 97       	sbiw	r28, 0x0b	; 11
    8212:	0f b6       	in	r0, 0x3f	; 63
    8214:	f8 94       	cli
    8216:	de bf       	out	0x3e, r29	; 62
    8218:	0f be       	out	0x3f, r0	; 63
    821a:	cd bf       	out	0x3d, r28	; 61
    821c:	bc 01       	movw	r22, r24
	char Format[] = "%0 li.%. u";
    821e:	3e 01       	movw	r6, r28
    8220:	08 94       	sec
    8222:	61 1c       	adc	r6, r1
    8224:	71 1c       	adc	r7, r1
    8226:	d3 01       	movw	r26, r6
    8228:	ec e0       	ldi	r30, 0x0C	; 12
    822a:	f2 e0       	ldi	r31, 0x02	; 2
    822c:	8b e0       	ldi	r24, 0x0B	; 11
    822e:	01 90       	ld	r0, Z+
    8230:	0d 92       	st	X+, r0
    8232:	81 50       	subi	r24, 0x01	; 1
    8234:	e1 f7       	brne	.-8      	; 0x822e <Put_bVal+0x3e>
	Format[2] = '0'+Param->Size;
    8236:	db 01       	movw	r26, r22
    8238:	13 96       	adiw	r26, 0x03	; 3
    823a:	2c 91       	ld	r18, X
    823c:	13 97       	sbiw	r26, 0x03	; 3
    823e:	20 5d       	subi	r18, 0xD0	; 208
    8240:	2b 83       	std	Y+3, r18	; 0x03
	if(Param->Prec) {
    8242:	12 96       	adiw	r26, 0x02	; 2
    8244:	9c 91       	ld	r25, X
    8246:	99 23       	and	r25, r25
    8248:	09 f4       	brne	.+2      	; 0x824c <Put_bVal+0x5c>
    824a:	6d c0       	rjmp	.+218    	; 0x8326 <Put_bVal+0x136>
		Format[2] -= Param->Prec+1;
    824c:	89 2f       	mov	r24, r25
    824e:	80 95       	com	r24
    8250:	82 0f       	add	r24, r18
    8252:	8b 83       	std	Y+3, r24	; 0x03
		Format[8] = '0'+Param->Prec;
    8254:	90 5d       	subi	r25, 0xD0	; 208
    8256:	99 87       	std	Y+9, r25	; 0x09
    8258:	90 53       	subi	r25, 0x30	; 48
		uint16_t Div=Pow10(Param->Prec);
    825a:	49 2f       	mov	r20, r25
    825c:	21 e0       	ldi	r18, 0x01	; 1
    825e:	30 e0       	ldi	r19, 0x00	; 0
		Pow *= 10;
    8260:	c9 01       	movw	r24, r18
    8262:	88 0f       	add	r24, r24
    8264:	99 1f       	adc	r25, r25
    8266:	22 0f       	add	r18, r18
    8268:	33 1f       	adc	r19, r19
    826a:	22 0f       	add	r18, r18
    826c:	33 1f       	adc	r19, r19
    826e:	22 0f       	add	r18, r18
    8270:	33 1f       	adc	r19, r19
    8272:	28 0f       	add	r18, r24
    8274:	39 1f       	adc	r19, r25
    8276:	41 50       	subi	r20, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    8278:	99 f7       	brne	.-26     	; 0x8260 <Put_bVal+0x70>
    827a:	49 01       	movw	r8, r18
    827c:	aa 24       	eor	r10, r10
    827e:	bb 24       	eor	r11, r11
		sprintf(Param->Pos, Format, F_Buf/Div, F_Buf%Div);
    8280:	c0 90 ee 04 	lds	r12, 0x04EE
    8284:	d0 90 ef 04 	lds	r13, 0x04EF
    8288:	e0 90 f0 04 	lds	r14, 0x04F0
    828c:	f0 90 f1 04 	lds	r15, 0x04F1
    8290:	ed b7       	in	r30, 0x3d	; 61
    8292:	fe b7       	in	r31, 0x3e	; 62
    8294:	3c 97       	sbiw	r30, 0x0c	; 12
    8296:	0f b6       	in	r0, 0x3f	; 63
    8298:	f8 94       	cli
    829a:	fe bf       	out	0x3e, r31	; 62
    829c:	0f be       	out	0x3f, r0	; 63
    829e:	ed bf       	out	0x3d, r30	; 61
    82a0:	0d b7       	in	r16, 0x3d	; 61
    82a2:	1e b7       	in	r17, 0x3e	; 62
    82a4:	0f 5f       	subi	r16, 0xFF	; 255
    82a6:	1f 4f       	sbci	r17, 0xFF	; 255
    82a8:	db 01       	movw	r26, r22
    82aa:	8d 91       	ld	r24, X+
    82ac:	9c 91       	ld	r25, X
    82ae:	92 83       	std	Z+2, r25	; 0x02
    82b0:	81 83       	std	Z+1, r24	; 0x01
    82b2:	f8 01       	movw	r30, r16
    82b4:	73 82       	std	Z+3, r7	; 0x03
    82b6:	62 82       	std	Z+2, r6	; 0x02
    82b8:	c7 01       	movw	r24, r14
    82ba:	b6 01       	movw	r22, r12
    82bc:	a5 01       	movw	r20, r10
    82be:	94 01       	movw	r18, r8
    82c0:	0e 94 91 7d 	call	0xfb22	; 0xfb22 <__udivmodsi4>
    82c4:	d8 01       	movw	r26, r16
    82c6:	14 96       	adiw	r26, 0x04	; 4
    82c8:	2d 93       	st	X+, r18
    82ca:	3d 93       	st	X+, r19
    82cc:	4d 93       	st	X+, r20
    82ce:	5c 93       	st	X, r21
    82d0:	17 97       	sbiw	r26, 0x07	; 7
    82d2:	c7 01       	movw	r24, r14
    82d4:	b6 01       	movw	r22, r12
    82d6:	a5 01       	movw	r20, r10
    82d8:	94 01       	movw	r18, r8
    82da:	0e 94 91 7d 	call	0xfb22	; 0xfb22 <__udivmodsi4>
    82de:	f8 01       	movw	r30, r16
    82e0:	60 87       	std	Z+8, r22	; 0x08
    82e2:	71 87       	std	Z+9, r23	; 0x09
    82e4:	82 87       	std	Z+10, r24	; 0x0a
    82e6:	93 87       	std	Z+11, r25	; 0x0b
    82e8:	0e 94 d5 7a 	call	0xf5aa	; 0xf5aa <sprintf>
    82ec:	8d b7       	in	r24, 0x3d	; 61
    82ee:	9e b7       	in	r25, 0x3e	; 62
    82f0:	0c 96       	adiw	r24, 0x0c	; 12
    82f2:	0f b6       	in	r0, 0x3f	; 63
    82f4:	f8 94       	cli
    82f6:	9e bf       	out	0x3e, r25	; 62
    82f8:	0f be       	out	0x3f, r0	; 63
    82fa:	8d bf       	out	0x3d, r24	; 61
	}
	else{
		Format[5] = '\0';
		sprintf(Param->Pos, Format, F_Buf);
	}
}
    82fc:	2b 96       	adiw	r28, 0x0b	; 11
    82fe:	0f b6       	in	r0, 0x3f	; 63
    8300:	f8 94       	cli
    8302:	de bf       	out	0x3e, r29	; 62
    8304:	0f be       	out	0x3f, r0	; 63
    8306:	cd bf       	out	0x3d, r28	; 61
    8308:	cf 91       	pop	r28
    830a:	df 91       	pop	r29
    830c:	1f 91       	pop	r17
    830e:	0f 91       	pop	r16
    8310:	ff 90       	pop	r15
    8312:	ef 90       	pop	r14
    8314:	df 90       	pop	r13
    8316:	cf 90       	pop	r12
    8318:	bf 90       	pop	r11
    831a:	af 90       	pop	r10
    831c:	9f 90       	pop	r9
    831e:	8f 90       	pop	r8
    8320:	7f 90       	pop	r7
    8322:	6f 90       	pop	r6
    8324:	08 95       	ret
		Format[8] = '0'+Param->Prec;
		uint16_t Div=Pow10(Param->Prec);
		sprintf(Param->Pos, Format, F_Buf/Div, F_Buf%Div);
	}
	else{
		Format[5] = '\0';
    8326:	1e 82       	std	Y+6, r1	; 0x06
		sprintf(Param->Pos, Format, F_Buf);
    8328:	ad b7       	in	r26, 0x3d	; 61
    832a:	be b7       	in	r27, 0x3e	; 62
    832c:	18 97       	sbiw	r26, 0x08	; 8
    832e:	0f b6       	in	r0, 0x3f	; 63
    8330:	f8 94       	cli
    8332:	be bf       	out	0x3e, r27	; 62
    8334:	0f be       	out	0x3f, r0	; 63
    8336:	ad bf       	out	0x3d, r26	; 61
    8338:	ed b7       	in	r30, 0x3d	; 61
    833a:	fe b7       	in	r31, 0x3e	; 62
    833c:	31 96       	adiw	r30, 0x01	; 1
    833e:	db 01       	movw	r26, r22
    8340:	8d 91       	ld	r24, X+
    8342:	9c 91       	ld	r25, X
    8344:	ad b7       	in	r26, 0x3d	; 61
    8346:	be b7       	in	r27, 0x3e	; 62
    8348:	12 96       	adiw	r26, 0x02	; 2
    834a:	9c 93       	st	X, r25
    834c:	8e 93       	st	-X, r24
    834e:	11 97       	sbiw	r26, 0x01	; 1
    8350:	73 82       	std	Z+3, r7	; 0x03
    8352:	62 82       	std	Z+2, r6	; 0x02
    8354:	80 91 ee 04 	lds	r24, 0x04EE
    8358:	90 91 ef 04 	lds	r25, 0x04EF
    835c:	a0 91 f0 04 	lds	r26, 0x04F0
    8360:	b0 91 f1 04 	lds	r27, 0x04F1
    8364:	84 83       	std	Z+4, r24	; 0x04
    8366:	95 83       	std	Z+5, r25	; 0x05
    8368:	a6 83       	std	Z+6, r26	; 0x06
    836a:	b7 83       	std	Z+7, r27	; 0x07
    836c:	0e 94 d5 7a 	call	0xf5aa	; 0xf5aa <sprintf>
    8370:	ed b7       	in	r30, 0x3d	; 61
    8372:	fe b7       	in	r31, 0x3e	; 62
    8374:	38 96       	adiw	r30, 0x08	; 8
    8376:	0f b6       	in	r0, 0x3f	; 63
    8378:	f8 94       	cli
    837a:	fe bf       	out	0x3e, r31	; 62
    837c:	0f be       	out	0x3f, r0	; 63
    837e:	ed bf       	out	0x3d, r30	; 61
    8380:	bd cf       	rjmp	.-134    	; 0x82fc <Put_bVal+0x10c>

00008382 <Put_TextValAlignLeft>:
	char Format[8];
	//char Format[8] = "%10.10s";
	sprintf(Format,"%%%u.%us", Param->Size, Param->Size);
	sprintf(Param->Pos, Format, Val);
}
void Put_TextValAlignLeft(char* Val, T_Param *Param){
    8382:	cf 92       	push	r12
    8384:	df 92       	push	r13
    8386:	ef 92       	push	r14
    8388:	ff 92       	push	r15
    838a:	0f 93       	push	r16
    838c:	1f 93       	push	r17
    838e:	df 93       	push	r29
    8390:	cf 93       	push	r28
    8392:	cd b7       	in	r28, 0x3d	; 61
    8394:	de b7       	in	r29, 0x3e	; 62
    8396:	29 97       	sbiw	r28, 0x09	; 9
    8398:	0f b6       	in	r0, 0x3f	; 63
    839a:	f8 94       	cli
    839c:	de bf       	out	0x3e, r29	; 62
    839e:	0f be       	out	0x3f, r0	; 63
    83a0:	cd bf       	out	0x3d, r28	; 61
    83a2:	6c 01       	movw	r12, r24
    83a4:	7b 01       	movw	r14, r22
	char Format[9];
	//char Format[8] = "%10.10s";
	sprintf(Format,"%%-%u.%us", Param->Size, Param->Size);
    83a6:	db 01       	movw	r26, r22
    83a8:	13 96       	adiw	r26, 0x03	; 3
    83aa:	2c 91       	ld	r18, X
    83ac:	ed b7       	in	r30, 0x3d	; 61
    83ae:	fe b7       	in	r31, 0x3e	; 62
    83b0:	38 97       	sbiw	r30, 0x08	; 8
    83b2:	0f b6       	in	r0, 0x3f	; 63
    83b4:	f8 94       	cli
    83b6:	fe bf       	out	0x3e, r31	; 62
    83b8:	0f be       	out	0x3f, r0	; 63
    83ba:	ed bf       	out	0x3d, r30	; 61
    83bc:	31 96       	adiw	r30, 0x01	; 1
    83be:	8e 01       	movw	r16, r28
    83c0:	0f 5f       	subi	r16, 0xFF	; 255
    83c2:	1f 4f       	sbci	r17, 0xFF	; 255
    83c4:	ad b7       	in	r26, 0x3d	; 61
    83c6:	be b7       	in	r27, 0x3e	; 62
    83c8:	12 96       	adiw	r26, 0x02	; 2
    83ca:	1c 93       	st	X, r17
    83cc:	0e 93       	st	-X, r16
    83ce:	11 97       	sbiw	r26, 0x01	; 1
    83d0:	87 e1       	ldi	r24, 0x17	; 23
    83d2:	92 e0       	ldi	r25, 0x02	; 2
    83d4:	93 83       	std	Z+3, r25	; 0x03
    83d6:	82 83       	std	Z+2, r24	; 0x02
    83d8:	24 83       	std	Z+4, r18	; 0x04
    83da:	15 82       	std	Z+5, r1	; 0x05
    83dc:	26 83       	std	Z+6, r18	; 0x06
    83de:	17 82       	std	Z+7, r1	; 0x07
    83e0:	0e 94 d5 7a 	call	0xf5aa	; 0xf5aa <sprintf>
	sprintf(Param->Pos, Format, Val);
    83e4:	0f 90       	pop	r0
    83e6:	0f 90       	pop	r0
    83e8:	ed b7       	in	r30, 0x3d	; 61
    83ea:	fe b7       	in	r31, 0x3e	; 62
    83ec:	31 96       	adiw	r30, 0x01	; 1
    83ee:	d7 01       	movw	r26, r14
    83f0:	8d 91       	ld	r24, X+
    83f2:	9c 91       	ld	r25, X
    83f4:	ad b7       	in	r26, 0x3d	; 61
    83f6:	be b7       	in	r27, 0x3e	; 62
    83f8:	12 96       	adiw	r26, 0x02	; 2
    83fa:	9c 93       	st	X, r25
    83fc:	8e 93       	st	-X, r24
    83fe:	11 97       	sbiw	r26, 0x01	; 1
    8400:	13 83       	std	Z+3, r17	; 0x03
    8402:	02 83       	std	Z+2, r16	; 0x02
    8404:	d5 82       	std	Z+5, r13	; 0x05
    8406:	c4 82       	std	Z+4, r12	; 0x04
    8408:	0e 94 d5 7a 	call	0xf5aa	; 0xf5aa <sprintf>
    840c:	ed b7       	in	r30, 0x3d	; 61
    840e:	fe b7       	in	r31, 0x3e	; 62
    8410:	36 96       	adiw	r30, 0x06	; 6
    8412:	0f b6       	in	r0, 0x3f	; 63
    8414:	f8 94       	cli
    8416:	fe bf       	out	0x3e, r31	; 62
    8418:	0f be       	out	0x3f, r0	; 63
    841a:	ed bf       	out	0x3d, r30	; 61
}
    841c:	29 96       	adiw	r28, 0x09	; 9
    841e:	0f b6       	in	r0, 0x3f	; 63
    8420:	f8 94       	cli
    8422:	de bf       	out	0x3e, r29	; 62
    8424:	0f be       	out	0x3f, r0	; 63
    8426:	cd bf       	out	0x3d, r28	; 61
    8428:	cf 91       	pop	r28
    842a:	df 91       	pop	r29
    842c:	1f 91       	pop	r17
    842e:	0f 91       	pop	r16
    8430:	ff 90       	pop	r15
    8432:	ef 90       	pop	r14
    8434:	df 90       	pop	r13
    8436:	cf 90       	pop	r12
    8438:	08 95       	ret

0000843a <Put_TextValAlignRight>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Put_TextVal -  
// if, for example, Filed width =12 -> sprintf(Param->Pos,"%12.12s",Val)
// min and max width = Param->Size and align right
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void Put_TextValAlignRight(char* Val, T_Param *Param){
    843a:	cf 92       	push	r12
    843c:	df 92       	push	r13
    843e:	ef 92       	push	r14
    8440:	ff 92       	push	r15
    8442:	0f 93       	push	r16
    8444:	1f 93       	push	r17
    8446:	df 93       	push	r29
    8448:	cf 93       	push	r28
    844a:	cd b7       	in	r28, 0x3d	; 61
    844c:	de b7       	in	r29, 0x3e	; 62
    844e:	28 97       	sbiw	r28, 0x08	; 8
    8450:	0f b6       	in	r0, 0x3f	; 63
    8452:	f8 94       	cli
    8454:	de bf       	out	0x3e, r29	; 62
    8456:	0f be       	out	0x3f, r0	; 63
    8458:	cd bf       	out	0x3d, r28	; 61
    845a:	6c 01       	movw	r12, r24
    845c:	7b 01       	movw	r14, r22
	char Format[8];
	//char Format[8] = "%10.10s";
	sprintf(Format,"%%%u.%us", Param->Size, Param->Size);
    845e:	db 01       	movw	r26, r22
    8460:	13 96       	adiw	r26, 0x03	; 3
    8462:	2c 91       	ld	r18, X
    8464:	ed b7       	in	r30, 0x3d	; 61
    8466:	fe b7       	in	r31, 0x3e	; 62
    8468:	38 97       	sbiw	r30, 0x08	; 8
    846a:	0f b6       	in	r0, 0x3f	; 63
    846c:	f8 94       	cli
    846e:	fe bf       	out	0x3e, r31	; 62
    8470:	0f be       	out	0x3f, r0	; 63
    8472:	ed bf       	out	0x3d, r30	; 61
    8474:	31 96       	adiw	r30, 0x01	; 1
    8476:	8e 01       	movw	r16, r28
    8478:	0f 5f       	subi	r16, 0xFF	; 255
    847a:	1f 4f       	sbci	r17, 0xFF	; 255
    847c:	ad b7       	in	r26, 0x3d	; 61
    847e:	be b7       	in	r27, 0x3e	; 62
    8480:	12 96       	adiw	r26, 0x02	; 2
    8482:	1c 93       	st	X, r17
    8484:	0e 93       	st	-X, r16
    8486:	11 97       	sbiw	r26, 0x01	; 1
    8488:	81 e2       	ldi	r24, 0x21	; 33
    848a:	92 e0       	ldi	r25, 0x02	; 2
    848c:	93 83       	std	Z+3, r25	; 0x03
    848e:	82 83       	std	Z+2, r24	; 0x02
    8490:	24 83       	std	Z+4, r18	; 0x04
    8492:	15 82       	std	Z+5, r1	; 0x05
    8494:	26 83       	std	Z+6, r18	; 0x06
    8496:	17 82       	std	Z+7, r1	; 0x07
    8498:	0e 94 d5 7a 	call	0xf5aa	; 0xf5aa <sprintf>
	sprintf(Param->Pos, Format, Val);
    849c:	0f 90       	pop	r0
    849e:	0f 90       	pop	r0
    84a0:	ed b7       	in	r30, 0x3d	; 61
    84a2:	fe b7       	in	r31, 0x3e	; 62
    84a4:	31 96       	adiw	r30, 0x01	; 1
    84a6:	d7 01       	movw	r26, r14
    84a8:	8d 91       	ld	r24, X+
    84aa:	9c 91       	ld	r25, X
    84ac:	ad b7       	in	r26, 0x3d	; 61
    84ae:	be b7       	in	r27, 0x3e	; 62
    84b0:	12 96       	adiw	r26, 0x02	; 2
    84b2:	9c 93       	st	X, r25
    84b4:	8e 93       	st	-X, r24
    84b6:	11 97       	sbiw	r26, 0x01	; 1
    84b8:	13 83       	std	Z+3, r17	; 0x03
    84ba:	02 83       	std	Z+2, r16	; 0x02
    84bc:	d5 82       	std	Z+5, r13	; 0x05
    84be:	c4 82       	std	Z+4, r12	; 0x04
    84c0:	0e 94 d5 7a 	call	0xf5aa	; 0xf5aa <sprintf>
    84c4:	ed b7       	in	r30, 0x3d	; 61
    84c6:	fe b7       	in	r31, 0x3e	; 62
    84c8:	36 96       	adiw	r30, 0x06	; 6
    84ca:	0f b6       	in	r0, 0x3f	; 63
    84cc:	f8 94       	cli
    84ce:	fe bf       	out	0x3e, r31	; 62
    84d0:	0f be       	out	0x3f, r0	; 63
    84d2:	ed bf       	out	0x3d, r30	; 61
}
    84d4:	28 96       	adiw	r28, 0x08	; 8
    84d6:	0f b6       	in	r0, 0x3f	; 63
    84d8:	f8 94       	cli
    84da:	de bf       	out	0x3e, r29	; 62
    84dc:	0f be       	out	0x3f, r0	; 63
    84de:	cd bf       	out	0x3d, r28	; 61
    84e0:	cf 91       	pop	r28
    84e2:	df 91       	pop	r29
    84e4:	1f 91       	pop	r17
    84e6:	0f 91       	pop	r16
    84e8:	ff 90       	pop	r15
    84ea:	ef 90       	pop	r14
    84ec:	df 90       	pop	r13
    84ee:	cf 90       	pop	r12
    84f0:	08 95       	ret

000084f2 <Put_GFVal>:
// Trailing zeros are removed from the fractional part of the result; 
// a decimal point appears only if it is followed by at least one digit.
// Max presicion - 8digits Why???
// Therefore Max Field size - 9
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void Put_GFVal(float Val, T_Param *Param){
    84f2:	ef 92       	push	r14
    84f4:	ff 92       	push	r15
    84f6:	0f 93       	push	r16
    84f8:	1f 93       	push	r17
    84fa:	df 93       	push	r29
    84fc:	cf 93       	push	r28
    84fe:	cd b7       	in	r28, 0x3d	; 61
    8500:	de b7       	in	r29, 0x3e	; 62
    8502:	2f 97       	sbiw	r28, 0x0f	; 15
    8504:	0f b6       	in	r0, 0x3f	; 63
    8506:	f8 94       	cli
    8508:	de bf       	out	0x3e, r29	; 62
    850a:	0f be       	out	0x3f, r0	; 63
    850c:	cd bf       	out	0x3d, r28	; 61
    850e:	7b 01       	movw	r14, r22
    8510:	8c 01       	movw	r16, r24
    8512:	9a 01       	movw	r18, r20
	if(Param->Size < 10){
    8514:	da 01       	movw	r26, r20
    8516:	13 96       	adiw	r26, 0x03	; 3
    8518:	8c 91       	ld	r24, X
    851a:	8a 30       	cpi	r24, 0x0A	; 10
    851c:	08 f4       	brcc	.+2      	; 0x8520 <Put_GFVal+0x2e>
    851e:	44 c0       	rjmp	.+136    	; 0x85a8 <Put_GFVal+0xb6>
		Format[2] = '0'+Param->Size;
		Format[4] = '0'+Param->Prec;
		sprintf(Param->Pos, Format, Val);
	}
	else{
		char Format[] = "%+1 . g";
    8520:	ae 01       	movw	r20, r28
    8522:	48 5f       	subi	r20, 0xF8	; 248
    8524:	5f 4f       	sbci	r21, 0xFF	; 255
    8526:	da 01       	movw	r26, r20
    8528:	ea e2       	ldi	r30, 0x2A	; 42
    852a:	f2 e0       	ldi	r31, 0x02	; 2
    852c:	88 e0       	ldi	r24, 0x08	; 8
    852e:	01 90       	ld	r0, Z+
    8530:	0d 92       	st	X+, r0
    8532:	81 50       	subi	r24, 0x01	; 1
    8534:	e1 f7       	brne	.-8      	; 0x852e <Put_GFVal+0x3c>
		Format[3] = '0'+Param->Size-10;	
    8536:	d9 01       	movw	r26, r18
    8538:	13 96       	adiw	r26, 0x03	; 3
    853a:	8c 91       	ld	r24, X
    853c:	13 97       	sbiw	r26, 0x03	; 3
    853e:	8a 5d       	subi	r24, 0xDA	; 218
    8540:	8b 87       	std	Y+11, r24	; 0x0b
		Format[5] = '0'+Param->Prec;
    8542:	12 96       	adiw	r26, 0x02	; 2
    8544:	8c 91       	ld	r24, X
    8546:	12 97       	sbiw	r26, 0x02	; 2
    8548:	80 5d       	subi	r24, 0xD0	; 208
    854a:	8d 87       	std	Y+13, r24	; 0x0d
		sprintf(Param->Pos, Format, Val);
    854c:	ed b7       	in	r30, 0x3d	; 61
    854e:	fe b7       	in	r31, 0x3e	; 62
    8550:	38 97       	sbiw	r30, 0x08	; 8
    8552:	0f b6       	in	r0, 0x3f	; 63
    8554:	f8 94       	cli
    8556:	fe bf       	out	0x3e, r31	; 62
    8558:	0f be       	out	0x3f, r0	; 63
    855a:	ed bf       	out	0x3d, r30	; 61
    855c:	31 96       	adiw	r30, 0x01	; 1
    855e:	8d 91       	ld	r24, X+
    8560:	9c 91       	ld	r25, X
    8562:	ad b7       	in	r26, 0x3d	; 61
    8564:	be b7       	in	r27, 0x3e	; 62
    8566:	12 96       	adiw	r26, 0x02	; 2
    8568:	9c 93       	st	X, r25
    856a:	8e 93       	st	-X, r24
    856c:	11 97       	sbiw	r26, 0x01	; 1
    856e:	53 83       	std	Z+3, r21	; 0x03
    8570:	42 83       	std	Z+2, r20	; 0x02
    8572:	e4 82       	std	Z+4, r14	; 0x04
    8574:	f5 82       	std	Z+5, r15	; 0x05
    8576:	06 83       	std	Z+6, r16	; 0x06
    8578:	17 83       	std	Z+7, r17	; 0x07
    857a:	0e 94 d5 7a 	call	0xf5aa	; 0xf5aa <sprintf>
    857e:	ed b7       	in	r30, 0x3d	; 61
    8580:	fe b7       	in	r31, 0x3e	; 62
    8582:	38 96       	adiw	r30, 0x08	; 8
    8584:	0f b6       	in	r0, 0x3f	; 63
    8586:	f8 94       	cli
    8588:	fe bf       	out	0x3e, r31	; 62
    858a:	0f be       	out	0x3f, r0	; 63
    858c:	ed bf       	out	0x3d, r30	; 61
	}
}
    858e:	2f 96       	adiw	r28, 0x0f	; 15
    8590:	0f b6       	in	r0, 0x3f	; 63
    8592:	f8 94       	cli
    8594:	de bf       	out	0x3e, r29	; 62
    8596:	0f be       	out	0x3f, r0	; 63
    8598:	cd bf       	out	0x3d, r28	; 61
    859a:	cf 91       	pop	r28
    859c:	df 91       	pop	r29
    859e:	1f 91       	pop	r17
    85a0:	0f 91       	pop	r16
    85a2:	ff 90       	pop	r15
    85a4:	ef 90       	pop	r14
    85a6:	08 95       	ret
// Max presicion - 8digits Why???
// Therefore Max Field size - 9
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void Put_GFVal(float Val, T_Param *Param){
	if(Param->Size < 10){
		char Format[] = "%+ . g";
    85a8:	ae 01       	movw	r20, r28
    85aa:	4f 5f       	subi	r20, 0xFF	; 255
    85ac:	5f 4f       	sbci	r21, 0xFF	; 255
    85ae:	da 01       	movw	r26, r20
    85b0:	e2 e3       	ldi	r30, 0x32	; 50
    85b2:	f2 e0       	ldi	r31, 0x02	; 2
    85b4:	87 e0       	ldi	r24, 0x07	; 7
    85b6:	01 90       	ld	r0, Z+
    85b8:	0d 92       	st	X+, r0
    85ba:	81 50       	subi	r24, 0x01	; 1
    85bc:	e1 f7       	brne	.-8      	; 0x85b6 <Put_GFVal+0xc4>
		Format[2] = '0'+Param->Size;
    85be:	f9 01       	movw	r30, r18
    85c0:	83 81       	ldd	r24, Z+3	; 0x03
    85c2:	80 5d       	subi	r24, 0xD0	; 208
    85c4:	8b 83       	std	Y+3, r24	; 0x03
		Format[4] = '0'+Param->Prec;
    85c6:	82 81       	ldd	r24, Z+2	; 0x02
    85c8:	80 5d       	subi	r24, 0xD0	; 208
    85ca:	8d 83       	std	Y+5, r24	; 0x05
		sprintf(Param->Pos, Format, Val);
    85cc:	8d b7       	in	r24, 0x3d	; 61
    85ce:	9e b7       	in	r25, 0x3e	; 62
    85d0:	08 97       	sbiw	r24, 0x08	; 8
    85d2:	0f b6       	in	r0, 0x3f	; 63
    85d4:	f8 94       	cli
    85d6:	9e bf       	out	0x3e, r25	; 62
    85d8:	0f be       	out	0x3f, r0	; 63
    85da:	8d bf       	out	0x3d, r24	; 61
    85dc:	ed b7       	in	r30, 0x3d	; 61
    85de:	fe b7       	in	r31, 0x3e	; 62
    85e0:	31 96       	adiw	r30, 0x01	; 1
    85e2:	d9 01       	movw	r26, r18
    85e4:	bc cf       	rjmp	.-136    	; 0x855e <Put_GFVal+0x6c>

000085e6 <Put_FFVal>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Put_FVal -  The double argument is rounded and converted to decimal notation in the format "[-]ddd.ddd"
// Max presicion - 8digits Why???
// Therefore Max Field size - 9
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void Put_FFVal(float Val, T_Param *Param){
    85e6:	ef 92       	push	r14
    85e8:	ff 92       	push	r15
    85ea:	0f 93       	push	r16
    85ec:	1f 93       	push	r17
    85ee:	df 93       	push	r29
    85f0:	cf 93       	push	r28
    85f2:	cd b7       	in	r28, 0x3d	; 61
    85f4:	de b7       	in	r29, 0x3e	; 62
    85f6:	27 97       	sbiw	r28, 0x07	; 7
    85f8:	0f b6       	in	r0, 0x3f	; 63
    85fa:	f8 94       	cli
    85fc:	de bf       	out	0x3e, r29	; 62
    85fe:	0f be       	out	0x3f, r0	; 63
    8600:	cd bf       	out	0x3d, r28	; 61
    8602:	7b 01       	movw	r14, r22
    8604:	8c 01       	movw	r16, r24
    8606:	9a 01       	movw	r18, r20
	char Format[] = "%+ . f";
    8608:	ae 01       	movw	r20, r28
    860a:	4f 5f       	subi	r20, 0xFF	; 255
    860c:	5f 4f       	sbci	r21, 0xFF	; 255
    860e:	da 01       	movw	r26, r20
    8610:	e9 e3       	ldi	r30, 0x39	; 57
    8612:	f2 e0       	ldi	r31, 0x02	; 2
    8614:	87 e0       	ldi	r24, 0x07	; 7
    8616:	01 90       	ld	r0, Z+
    8618:	0d 92       	st	X+, r0
    861a:	81 50       	subi	r24, 0x01	; 1
    861c:	e1 f7       	brne	.-8      	; 0x8616 <Put_FFVal+0x30>
	Format[2] = '0'+Param->Size;
    861e:	d9 01       	movw	r26, r18
    8620:	13 96       	adiw	r26, 0x03	; 3
    8622:	8c 91       	ld	r24, X
    8624:	13 97       	sbiw	r26, 0x03	; 3
    8626:	80 5d       	subi	r24, 0xD0	; 208
    8628:	8b 83       	std	Y+3, r24	; 0x03
	Format[4] = '0'+Param->Prec;	
    862a:	12 96       	adiw	r26, 0x02	; 2
    862c:	8c 91       	ld	r24, X
    862e:	12 97       	sbiw	r26, 0x02	; 2
    8630:	80 5d       	subi	r24, 0xD0	; 208
    8632:	8d 83       	std	Y+5, r24	; 0x05
	sprintf(Param->Pos, Format, Val);
    8634:	ed b7       	in	r30, 0x3d	; 61
    8636:	fe b7       	in	r31, 0x3e	; 62
    8638:	38 97       	sbiw	r30, 0x08	; 8
    863a:	0f b6       	in	r0, 0x3f	; 63
    863c:	f8 94       	cli
    863e:	fe bf       	out	0x3e, r31	; 62
    8640:	0f be       	out	0x3f, r0	; 63
    8642:	ed bf       	out	0x3d, r30	; 61
    8644:	31 96       	adiw	r30, 0x01	; 1
    8646:	8d 91       	ld	r24, X+
    8648:	9c 91       	ld	r25, X
    864a:	ad b7       	in	r26, 0x3d	; 61
    864c:	be b7       	in	r27, 0x3e	; 62
    864e:	12 96       	adiw	r26, 0x02	; 2
    8650:	9c 93       	st	X, r25
    8652:	8e 93       	st	-X, r24
    8654:	11 97       	sbiw	r26, 0x01	; 1
    8656:	53 83       	std	Z+3, r21	; 0x03
    8658:	42 83       	std	Z+2, r20	; 0x02
    865a:	e4 82       	std	Z+4, r14	; 0x04
    865c:	f5 82       	std	Z+5, r15	; 0x05
    865e:	06 83       	std	Z+6, r16	; 0x06
    8660:	17 83       	std	Z+7, r17	; 0x07
    8662:	0e 94 d5 7a 	call	0xf5aa	; 0xf5aa <sprintf>
    8666:	ed b7       	in	r30, 0x3d	; 61
    8668:	fe b7       	in	r31, 0x3e	; 62
    866a:	38 96       	adiw	r30, 0x08	; 8
    866c:	0f b6       	in	r0, 0x3f	; 63
    866e:	f8 94       	cli
    8670:	fe bf       	out	0x3e, r31	; 62
    8672:	0f be       	out	0x3f, r0	; 63
    8674:	ed bf       	out	0x3d, r30	; 61
}
    8676:	27 96       	adiw	r28, 0x07	; 7
    8678:	0f b6       	in	r0, 0x3f	; 63
    867a:	f8 94       	cli
    867c:	de bf       	out	0x3e, r29	; 62
    867e:	0f be       	out	0x3f, r0	; 63
    8680:	cd bf       	out	0x3d, r28	; 61
    8682:	cf 91       	pop	r28
    8684:	df 91       	pop	r29
    8686:	1f 91       	pop	r17
    8688:	0f 91       	pop	r16
    868a:	ff 90       	pop	r15
    868c:	ef 90       	pop	r14
    868e:	08 95       	ret

00008690 <Put_zDVal>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Put_zDVal - print unsigned Longint with leading zeroes in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void 
Put_zDVal(uint32_t Val, T_Param *Param)
{
    8690:	2f 92       	push	r2
    8692:	3f 92       	push	r3
    8694:	4f 92       	push	r4
    8696:	5f 92       	push	r5
    8698:	6f 92       	push	r6
    869a:	7f 92       	push	r7
    869c:	8f 92       	push	r8
    869e:	9f 92       	push	r9
    86a0:	af 92       	push	r10
    86a2:	bf 92       	push	r11
    86a4:	cf 92       	push	r12
    86a6:	df 92       	push	r13
    86a8:	ef 92       	push	r14
    86aa:	ff 92       	push	r15
    86ac:	0f 93       	push	r16
    86ae:	1f 93       	push	r17
    86b0:	df 93       	push	r29
    86b2:	cf 93       	push	r28
    86b4:	cd b7       	in	r28, 0x3d	; 61
    86b6:	de b7       	in	r29, 0x3e	; 62
    86b8:	2c 97       	sbiw	r28, 0x0c	; 12
    86ba:	0f b6       	in	r0, 0x3f	; 63
    86bc:	f8 94       	cli
    86be:	de bf       	out	0x3e, r29	; 62
    86c0:	0f be       	out	0x3f, r0	; 63
    86c2:	cd bf       	out	0x3d, r28	; 61
    86c4:	1b 01       	movw	r2, r22
    86c6:	2c 01       	movw	r4, r24
    86c8:	3a 01       	movw	r6, r20
	uint32_t Idx = 0xFFFFFFFF-Val;
	if(Param->Txt && Idx<2) {
    86ca:	da 01       	movw	r26, r20
    86cc:	14 96       	adiw	r26, 0x04	; 4
    86ce:	2d 91       	ld	r18, X+
    86d0:	3c 91       	ld	r19, X
    86d2:	15 97       	sbiw	r26, 0x05	; 5
    86d4:	21 15       	cp	r18, r1
    86d6:	31 05       	cpc	r19, r1
    86d8:	61 f0       	breq	.+24     	; 0x86f2 <Put_zDVal+0x62>
// Put_zDVal - print unsigned Longint with leading zeroes in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void 
Put_zDVal(uint32_t Val, T_Param *Param)
{
	uint32_t Idx = 0xFFFFFFFF-Val;
    86da:	dc 01       	movw	r26, r24
    86dc:	cb 01       	movw	r24, r22
    86de:	80 95       	com	r24
    86e0:	90 95       	com	r25
    86e2:	a0 95       	com	r26
    86e4:	b0 95       	com	r27
	if(Param->Txt && Idx<2) {
    86e6:	82 30       	cpi	r24, 0x02	; 2
    86e8:	91 05       	cpc	r25, r1
    86ea:	a1 05       	cpc	r26, r1
    86ec:	b1 05       	cpc	r27, r1
    86ee:	08 f4       	brcc	.+2      	; 0x86f2 <Put_zDVal+0x62>
    86f0:	e5 c0       	rjmp	.+458    	; 0x88bc <Put_zDVal+0x22c>
		Param->Txt += Idx;
		PutEnum(Param);
		return;
	}

	if(Param->Size==10 && Param->Prec==0){
    86f2:	d3 01       	movw	r26, r6
    86f4:	13 96       	adiw	r26, 0x03	; 3
    86f6:	8c 91       	ld	r24, X
    86f8:	13 97       	sbiw	r26, 0x03	; 3
    86fa:	8a 30       	cpi	r24, 0x0A	; 10
    86fc:	09 f4       	brne	.+2      	; 0x8700 <Put_zDVal+0x70>
    86fe:	72 c0       	rjmp	.+228    	; 0x87e4 <Put_zDVal+0x154>
		sprintf(Param->Pos, "%010lu", Val);
		return;
	}
	char Format[] = "%0 lu.%. lu";
    8700:	de 01       	movw	r26, r28
    8702:	11 96       	adiw	r26, 0x01	; 1
    8704:	e7 e4       	ldi	r30, 0x47	; 71
    8706:	f2 e0       	ldi	r31, 0x02	; 2
    8708:	8c e0       	ldi	r24, 0x0C	; 12
    870a:	01 90       	ld	r0, Z+
    870c:	0d 92       	st	X+, r0
    870e:	81 50       	subi	r24, 0x01	; 1
    8710:	e1 f7       	brne	.-8      	; 0x870a <Put_zDVal+0x7a>
	Format[2] = '0'+Param->Size;
    8712:	d3 01       	movw	r26, r6
    8714:	13 96       	adiw	r26, 0x03	; 3
    8716:	2c 91       	ld	r18, X
    8718:	13 97       	sbiw	r26, 0x03	; 3
    871a:	20 5d       	subi	r18, 0xD0	; 208
    871c:	2b 83       	std	Y+3, r18	; 0x03
	if(Param->Prec) {
    871e:	12 96       	adiw	r26, 0x02	; 2
    8720:	9c 91       	ld	r25, X
    8722:	99 23       	and	r25, r25
    8724:	09 f4       	brne	.+2      	; 0x8728 <Put_zDVal+0x98>
    8726:	a0 c0       	rjmp	.+320    	; 0x8868 <Put_zDVal+0x1d8>
		Format[2] -= Param->Prec+1;
    8728:	89 2f       	mov	r24, r25
    872a:	80 95       	com	r24
    872c:	82 0f       	add	r24, r18
    872e:	8b 83       	std	Y+3, r24	; 0x03
		Format[8] = '0'+Param->Prec;
    8730:	90 5d       	subi	r25, 0xD0	; 208
    8732:	99 87       	std	Y+9, r25	; 0x09
    8734:	90 53       	subi	r25, 0x30	; 48
		uint32_t Div=PowL10(Param->Prec);
    8736:	09 2f       	mov	r16, r25
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
	uint32_t Pow = 1;
	while(Exp--)
    8738:	61 e0       	ldi	r22, 0x01	; 1
    873a:	86 2e       	mov	r8, r22
    873c:	91 2c       	mov	r9, r1
    873e:	a1 2c       	mov	r10, r1
    8740:	b1 2c       	mov	r11, r1
		Pow *= 10;
    8742:	c5 01       	movw	r24, r10
    8744:	b4 01       	movw	r22, r8
    8746:	2a e0       	ldi	r18, 0x0A	; 10
    8748:	30 e0       	ldi	r19, 0x00	; 0
    874a:	40 e0       	ldi	r20, 0x00	; 0
    874c:	50 e0       	ldi	r21, 0x00	; 0
    874e:	0e 94 3f 7d 	call	0xfa7e	; 0xfa7e <__mulsi3>
    8752:	4b 01       	movw	r8, r22
    8754:	5c 01       	movw	r10, r24
    8756:	01 50       	subi	r16, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
	uint32_t Pow = 1;
	while(Exp--)
    8758:	a1 f7       	brne	.-24     	; 0x8742 <Put_zDVal+0xb2>
    875a:	c2 01       	movw	r24, r4
    875c:	b1 01       	movw	r22, r2
    875e:	94 01       	movw	r18, r8
    8760:	a5 01       	movw	r20, r10
    8762:	0e 94 91 7d 	call	0xfb22	; 0xfb22 <__udivmodsi4>
    8766:	f6 2e       	mov	r15, r22
    8768:	e7 2e       	mov	r14, r23
    876a:	d8 2e       	mov	r13, r24
    876c:	c9 2e       	mov	r12, r25
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
    876e:	ed b7       	in	r30, 0x3d	; 61
    8770:	fe b7       	in	r31, 0x3e	; 62
    8772:	3c 97       	sbiw	r30, 0x0c	; 12
    8774:	0f b6       	in	r0, 0x3f	; 63
    8776:	f8 94       	cli
    8778:	fe bf       	out	0x3e, r31	; 62
    877a:	0f be       	out	0x3f, r0	; 63
    877c:	ed bf       	out	0x3d, r30	; 61
    877e:	0d b7       	in	r16, 0x3d	; 61
    8780:	1e b7       	in	r17, 0x3e	; 62
    8782:	0f 5f       	subi	r16, 0xFF	; 255
    8784:	1f 4f       	sbci	r17, 0xFF	; 255
    8786:	d3 01       	movw	r26, r6
    8788:	8d 91       	ld	r24, X+
    878a:	9c 91       	ld	r25, X
    878c:	92 83       	std	Z+2, r25	; 0x02
    878e:	81 83       	std	Z+1, r24	; 0x01
    8790:	81 e0       	ldi	r24, 0x01	; 1
    8792:	90 e0       	ldi	r25, 0x00	; 0
    8794:	8c 0f       	add	r24, r28
    8796:	9d 1f       	adc	r25, r29
    8798:	f8 01       	movw	r30, r16
    879a:	93 83       	std	Z+3, r25	; 0x03
    879c:	82 83       	std	Z+2, r24	; 0x02
    879e:	c2 01       	movw	r24, r4
    87a0:	b1 01       	movw	r22, r2
    87a2:	a5 01       	movw	r20, r10
    87a4:	94 01       	movw	r18, r8
    87a6:	0e 94 91 7d 	call	0xfb22	; 0xfb22 <__udivmodsi4>
    87aa:	d8 01       	movw	r26, r16
    87ac:	14 96       	adiw	r26, 0x04	; 4
    87ae:	2d 93       	st	X+, r18
    87b0:	3d 93       	st	X+, r19
    87b2:	4d 93       	st	X+, r20
    87b4:	5c 93       	st	X, r21
    87b6:	17 97       	sbiw	r26, 0x07	; 7
    87b8:	18 96       	adiw	r26, 0x08	; 8
    87ba:	fc 92       	st	X, r15
    87bc:	18 97       	sbiw	r26, 0x08	; 8
    87be:	19 96       	adiw	r26, 0x09	; 9
    87c0:	ec 92       	st	X, r14
    87c2:	19 97       	sbiw	r26, 0x09	; 9
    87c4:	1a 96       	adiw	r26, 0x0a	; 10
    87c6:	dc 92       	st	X, r13
    87c8:	1a 97       	sbiw	r26, 0x0a	; 10
    87ca:	1b 96       	adiw	r26, 0x0b	; 11
    87cc:	cc 92       	st	X, r12
    87ce:	0e 94 d5 7a 	call	0xf5aa	; 0xf5aa <sprintf>
    87d2:	ed b7       	in	r30, 0x3d	; 61
    87d4:	fe b7       	in	r31, 0x3e	; 62
    87d6:	3c 96       	adiw	r30, 0x0c	; 12
    87d8:	0f b6       	in	r0, 0x3f	; 63
    87da:	f8 94       	cli
    87dc:	fe bf       	out	0x3e, r31	; 62
    87de:	0f be       	out	0x3f, r0	; 63
    87e0:	ed bf       	out	0x3d, r30	; 61
    87e2:	29 c0       	rjmp	.+82     	; 0x8836 <Put_zDVal+0x1a6>
		Param->Txt += Idx;
		PutEnum(Param);
		return;
	}

	if(Param->Size==10 && Param->Prec==0){
    87e4:	12 96       	adiw	r26, 0x02	; 2
    87e6:	8c 91       	ld	r24, X
    87e8:	12 97       	sbiw	r26, 0x02	; 2
    87ea:	88 23       	and	r24, r24
    87ec:	09 f0       	breq	.+2      	; 0x87f0 <Put_zDVal+0x160>
    87ee:	88 cf       	rjmp	.-240    	; 0x8700 <Put_zDVal+0x70>
		sprintf(Param->Pos, "%010lu", Val);
    87f0:	ed b7       	in	r30, 0x3d	; 61
    87f2:	fe b7       	in	r31, 0x3e	; 62
    87f4:	38 97       	sbiw	r30, 0x08	; 8
    87f6:	0f b6       	in	r0, 0x3f	; 63
    87f8:	f8 94       	cli
    87fa:	fe bf       	out	0x3e, r31	; 62
    87fc:	0f be       	out	0x3f, r0	; 63
    87fe:	ed bf       	out	0x3d, r30	; 61
    8800:	31 96       	adiw	r30, 0x01	; 1
    8802:	8d 91       	ld	r24, X+
    8804:	9c 91       	ld	r25, X
    8806:	ad b7       	in	r26, 0x3d	; 61
    8808:	be b7       	in	r27, 0x3e	; 62
    880a:	12 96       	adiw	r26, 0x02	; 2
    880c:	9c 93       	st	X, r25
    880e:	8e 93       	st	-X, r24
    8810:	11 97       	sbiw	r26, 0x01	; 1
    8812:	80 e4       	ldi	r24, 0x40	; 64
    8814:	92 e0       	ldi	r25, 0x02	; 2
    8816:	93 83       	std	Z+3, r25	; 0x03
    8818:	82 83       	std	Z+2, r24	; 0x02
    881a:	24 82       	std	Z+4, r2	; 0x04
    881c:	35 82       	std	Z+5, r3	; 0x05
    881e:	46 82       	std	Z+6, r4	; 0x06
    8820:	57 82       	std	Z+7, r5	; 0x07
    8822:	0e 94 d5 7a 	call	0xf5aa	; 0xf5aa <sprintf>
    8826:	ed b7       	in	r30, 0x3d	; 61
    8828:	fe b7       	in	r31, 0x3e	; 62
    882a:	38 96       	adiw	r30, 0x08	; 8
    882c:	0f b6       	in	r0, 0x3f	; 63
    882e:	f8 94       	cli
    8830:	fe bf       	out	0x3e, r31	; 62
    8832:	0f be       	out	0x3f, r0	; 63
    8834:	ed bf       	out	0x3d, r30	; 61
	}
	else {
		Format[5] = '\0';
		sprintf(Param->Pos, Format, Val);
	}
}
    8836:	2c 96       	adiw	r28, 0x0c	; 12
    8838:	0f b6       	in	r0, 0x3f	; 63
    883a:	f8 94       	cli
    883c:	de bf       	out	0x3e, r29	; 62
    883e:	0f be       	out	0x3f, r0	; 63
    8840:	cd bf       	out	0x3d, r28	; 61
    8842:	cf 91       	pop	r28
    8844:	df 91       	pop	r29
    8846:	1f 91       	pop	r17
    8848:	0f 91       	pop	r16
    884a:	ff 90       	pop	r15
    884c:	ef 90       	pop	r14
    884e:	df 90       	pop	r13
    8850:	cf 90       	pop	r12
    8852:	bf 90       	pop	r11
    8854:	af 90       	pop	r10
    8856:	9f 90       	pop	r9
    8858:	8f 90       	pop	r8
    885a:	7f 90       	pop	r7
    885c:	6f 90       	pop	r6
    885e:	5f 90       	pop	r5
    8860:	4f 90       	pop	r4
    8862:	3f 90       	pop	r3
    8864:	2f 90       	pop	r2
    8866:	08 95       	ret
		Format[8] = '0'+Param->Prec;
		uint32_t Div=PowL10(Param->Prec);
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
	}
	else {
		Format[5] = '\0';
    8868:	1e 82       	std	Y+6, r1	; 0x06
		sprintf(Param->Pos, Format, Val);
    886a:	8d b7       	in	r24, 0x3d	; 61
    886c:	9e b7       	in	r25, 0x3e	; 62
    886e:	08 97       	sbiw	r24, 0x08	; 8
    8870:	0f b6       	in	r0, 0x3f	; 63
    8872:	f8 94       	cli
    8874:	9e bf       	out	0x3e, r25	; 62
    8876:	0f be       	out	0x3f, r0	; 63
    8878:	8d bf       	out	0x3d, r24	; 61
    887a:	ed b7       	in	r30, 0x3d	; 61
    887c:	fe b7       	in	r31, 0x3e	; 62
    887e:	31 96       	adiw	r30, 0x01	; 1
    8880:	d3 01       	movw	r26, r6
    8882:	8d 91       	ld	r24, X+
    8884:	9c 91       	ld	r25, X
    8886:	ad b7       	in	r26, 0x3d	; 61
    8888:	be b7       	in	r27, 0x3e	; 62
    888a:	12 96       	adiw	r26, 0x02	; 2
    888c:	9c 93       	st	X, r25
    888e:	8e 93       	st	-X, r24
    8890:	11 97       	sbiw	r26, 0x01	; 1
    8892:	81 e0       	ldi	r24, 0x01	; 1
    8894:	90 e0       	ldi	r25, 0x00	; 0
    8896:	8c 0f       	add	r24, r28
    8898:	9d 1f       	adc	r25, r29
    889a:	93 83       	std	Z+3, r25	; 0x03
    889c:	82 83       	std	Z+2, r24	; 0x02
    889e:	24 82       	std	Z+4, r2	; 0x04
    88a0:	35 82       	std	Z+5, r3	; 0x05
    88a2:	46 82       	std	Z+6, r4	; 0x06
    88a4:	57 82       	std	Z+7, r5	; 0x07
    88a6:	0e 94 d5 7a 	call	0xf5aa	; 0xf5aa <sprintf>
    88aa:	ad b7       	in	r26, 0x3d	; 61
    88ac:	be b7       	in	r27, 0x3e	; 62
    88ae:	18 96       	adiw	r26, 0x08	; 8
    88b0:	0f b6       	in	r0, 0x3f	; 63
    88b2:	f8 94       	cli
    88b4:	be bf       	out	0x3e, r27	; 62
    88b6:	0f be       	out	0x3f, r0	; 63
    88b8:	ad bf       	out	0x3d, r26	; 61
    88ba:	bd cf       	rjmp	.-134    	; 0x8836 <Put_zDVal+0x1a6>
void 
Put_zDVal(uint32_t Val, T_Param *Param)
{
	uint32_t Idx = 0xFFFFFFFF-Val;
	if(Param->Txt && Idx<2) {
		Param->Txt += Idx;
    88bc:	88 0f       	add	r24, r24
    88be:	99 1f       	adc	r25, r25
    88c0:	28 0f       	add	r18, r24
    88c2:	39 1f       	adc	r19, r25
    88c4:	fa 01       	movw	r30, r20
    88c6:	35 83       	std	Z+5, r19	; 0x05
    88c8:	24 83       	std	Z+4, r18	; 0x04
		PutEnum(Param);
    88ca:	ca 01       	movw	r24, r20
    88cc:	0e 94 c9 3f 	call	0x7f92	; 0x7f92 <PutEnum>
    88d0:	b2 cf       	rjmp	.-156    	; 0x8836 <Put_zDVal+0x1a6>

000088d2 <Put_sDVal>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Put_sDVal - print signed Longint in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_sDVal(int32_t Val, T_Param *Param)
{
    88d2:	cf 92       	push	r12
    88d4:	df 92       	push	r13
    88d6:	ef 92       	push	r14
    88d8:	ff 92       	push	r15
    88da:	0f 93       	push	r16
    88dc:	1f 93       	push	r17
    88de:	df 93       	push	r29
    88e0:	cf 93       	push	r28
    88e2:	cd b7       	in	r28, 0x3d	; 61
    88e4:	de b7       	in	r29, 0x3e	; 62
    88e6:	2d 97       	sbiw	r28, 0x0d	; 13
    88e8:	0f b6       	in	r0, 0x3f	; 63
    88ea:	f8 94       	cli
    88ec:	de bf       	out	0x3e, r29	; 62
    88ee:	0f be       	out	0x3f, r0	; 63
    88f0:	cd bf       	out	0x3d, r28	; 61
    88f2:	6b 01       	movw	r12, r22
    88f4:	7c 01       	movw	r14, r24
    88f6:	8a 01       	movw	r16, r20
	uint32_t Idx = 0x80000000+Val;
	if(Param->Txt && Idx<2) {
    88f8:	da 01       	movw	r26, r20
    88fa:	14 96       	adiw	r26, 0x04	; 4
    88fc:	2d 91       	ld	r18, X+
    88fe:	3c 91       	ld	r19, X
    8900:	15 97       	sbiw	r26, 0x05	; 5
    8902:	21 15       	cp	r18, r1
    8904:	31 05       	cpc	r19, r1
    8906:	61 f0       	breq	.+24     	; 0x8920 <Put_sDVal+0x4e>
// Put_sDVal - print signed Longint in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_sDVal(int32_t Val, T_Param *Param)
{
	uint32_t Idx = 0x80000000+Val;
    8908:	dc 01       	movw	r26, r24
    890a:	cb 01       	movw	r24, r22
    890c:	80 50       	subi	r24, 0x00	; 0
    890e:	90 40       	sbci	r25, 0x00	; 0
    8910:	a0 40       	sbci	r26, 0x00	; 0
    8912:	b0 48       	sbci	r27, 0x80	; 128
	if(Param->Txt && Idx<2) {
    8914:	82 30       	cpi	r24, 0x02	; 2
    8916:	91 05       	cpc	r25, r1
    8918:	a1 05       	cpc	r26, r1
    891a:	b1 05       	cpc	r27, r1
    891c:	08 f4       	brcc	.+2      	; 0x8920 <Put_sDVal+0x4e>
    891e:	f7 c0       	rjmp	.+494    	; 0x8b0e <Put_sDVal+0x23c>
		Param->Txt += Idx;
		PutEnum(Param);
		return;
	}
	// standart specificator to print Longint in string
	if(Param->Size>9){
    8920:	d8 01       	movw	r26, r16
    8922:	13 96       	adiw	r26, 0x03	; 3
    8924:	8c 91       	ld	r24, X
    8926:	8a 30       	cpi	r24, 0x0A	; 10
    8928:	f8 f0       	brcs	.+62     	; 0x8968 <Put_sDVal+0x96>
		char Format[] = "%+1 ld";
    892a:	9e 01       	movw	r18, r28
    892c:	29 5f       	subi	r18, 0xF9	; 249
    892e:	3f 4f       	sbci	r19, 0xFF	; 255
    8930:	d9 01       	movw	r26, r18
    8932:	e3 e5       	ldi	r30, 0x53	; 83
    8934:	f2 e0       	ldi	r31, 0x02	; 2
    8936:	87 e0       	ldi	r24, 0x07	; 7
    8938:	01 90       	ld	r0, Z+
    893a:	0d 92       	st	X+, r0
    893c:	81 50       	subi	r24, 0x01	; 1
    893e:	e1 f7       	brne	.-8      	; 0x8938 <Put_sDVal+0x66>
		Format[3] = '0'+Param->Size%10;
    8940:	f8 01       	movw	r30, r16
    8942:	83 81       	ldd	r24, Z+3	; 0x03
    8944:	6a e0       	ldi	r22, 0x0A	; 10
    8946:	0e 94 5e 7d 	call	0xfabc	; 0xfabc <__udivmodqi4>
    894a:	90 5d       	subi	r25, 0xD0	; 208
    894c:	9a 87       	std	Y+10, r25	; 0x0a
		sprintf(Param->Pos, Format, Val);
    894e:	8d b7       	in	r24, 0x3d	; 61
    8950:	9e b7       	in	r25, 0x3e	; 62
    8952:	08 97       	sbiw	r24, 0x08	; 8
    8954:	0f b6       	in	r0, 0x3f	; 63
    8956:	f8 94       	cli
    8958:	9e bf       	out	0x3e, r25	; 62
    895a:	0f be       	out	0x3f, r0	; 63
    895c:	8d bf       	out	0x3d, r24	; 61
    895e:	ed b7       	in	r30, 0x3d	; 61
    8960:	fe b7       	in	r31, 0x3e	; 62
    8962:	31 96       	adiw	r30, 0x01	; 1
    8964:	d8 01       	movw	r26, r16
    8966:	1a c0       	rjmp	.+52     	; 0x899c <Put_sDVal+0xca>
	}
	else{
		char Format[] = "%+ ld";
    8968:	9e 01       	movw	r18, r28
    896a:	2f 5f       	subi	r18, 0xFF	; 255
    896c:	3f 4f       	sbci	r19, 0xFF	; 255
    896e:	d9 01       	movw	r26, r18
    8970:	ea e5       	ldi	r30, 0x5A	; 90
    8972:	f2 e0       	ldi	r31, 0x02	; 2
    8974:	86 e0       	ldi	r24, 0x06	; 6
    8976:	01 90       	ld	r0, Z+
    8978:	0d 92       	st	X+, r0
    897a:	81 50       	subi	r24, 0x01	; 1
    897c:	e1 f7       	brne	.-8      	; 0x8976 <Put_sDVal+0xa4>
		Format[2] = '0'+Param->Size;
    897e:	d8 01       	movw	r26, r16
    8980:	13 96       	adiw	r26, 0x03	; 3
    8982:	8c 91       	ld	r24, X
    8984:	13 97       	sbiw	r26, 0x03	; 3
    8986:	80 5d       	subi	r24, 0xD0	; 208
    8988:	8b 83       	std	Y+3, r24	; 0x03
		sprintf(Param->Pos, Format, Val);
    898a:	ed b7       	in	r30, 0x3d	; 61
    898c:	fe b7       	in	r31, 0x3e	; 62
    898e:	38 97       	sbiw	r30, 0x08	; 8
    8990:	0f b6       	in	r0, 0x3f	; 63
    8992:	f8 94       	cli
    8994:	fe bf       	out	0x3e, r31	; 62
    8996:	0f be       	out	0x3f, r0	; 63
    8998:	ed bf       	out	0x3d, r30	; 61
    899a:	31 96       	adiw	r30, 0x01	; 1
    899c:	8d 91       	ld	r24, X+
    899e:	9c 91       	ld	r25, X
    89a0:	ad b7       	in	r26, 0x3d	; 61
    89a2:	be b7       	in	r27, 0x3e	; 62
    89a4:	12 96       	adiw	r26, 0x02	; 2
    89a6:	9c 93       	st	X, r25
    89a8:	8e 93       	st	-X, r24
    89aa:	11 97       	sbiw	r26, 0x01	; 1
    89ac:	33 83       	std	Z+3, r19	; 0x03
    89ae:	22 83       	std	Z+2, r18	; 0x02
    89b0:	c4 82       	std	Z+4, r12	; 0x04
    89b2:	d5 82       	std	Z+5, r13	; 0x05
    89b4:	e6 82       	std	Z+6, r14	; 0x06
    89b6:	f7 82       	std	Z+7, r15	; 0x07
    89b8:	0e 94 d5 7a 	call	0xf5aa	; 0xf5aa <sprintf>
    89bc:	ed b7       	in	r30, 0x3d	; 61
    89be:	fe b7       	in	r31, 0x3e	; 62
    89c0:	38 96       	adiw	r30, 0x08	; 8
    89c2:	0f b6       	in	r0, 0x3f	; 63
    89c4:	f8 94       	cli
    89c6:	fe bf       	out	0x3e, r31	; 62
    89c8:	0f be       	out	0x3f, r0	; 63
    89ca:	ed bf       	out	0x3d, r30	; 61
	}
	//Delete sign if zero
	if(!Val)Param->Pos[Param->Size-2] = ' ';
    89cc:	c1 14       	cp	r12, r1
    89ce:	d1 04       	cpc	r13, r1
    89d0:	e1 04       	cpc	r14, r1
    89d2:	f1 04       	cpc	r15, r1
    89d4:	59 f4       	brne	.+22     	; 0x89ec <Put_sDVal+0x11a>
    89d6:	d8 01       	movw	r26, r16
    89d8:	13 96       	adiw	r26, 0x03	; 3
    89da:	8c 91       	ld	r24, X
    89dc:	13 97       	sbiw	r26, 0x03	; 3
    89de:	ed 91       	ld	r30, X+
    89e0:	fc 91       	ld	r31, X
    89e2:	e8 0f       	add	r30, r24
    89e4:	f1 1d       	adc	r31, r1
    89e6:	32 97       	sbiw	r30, 0x02	; 2
    89e8:	80 e2       	ldi	r24, 0x20	; 32
    89ea:	80 83       	st	Z, r24

	if(Param->Prec){
    89ec:	f8 01       	movw	r30, r16
    89ee:	92 81       	ldd	r25, Z+2	; 0x02
    89f0:	99 23       	and	r25, r25
    89f2:	09 f4       	brne	.+2      	; 0x89f6 <Put_sDVal+0x124>
    89f4:	41 c0       	rjmp	.+130    	; 0x8a78 <Put_sDVal+0x1a6>
		//Insert decimal point
		for(uint8_t i=0; i< Param->Size - Param->Prec; i++){
    89f6:	83 81       	ldd	r24, Z+3	; 0x03
    89f8:	28 2f       	mov	r18, r24
    89fa:	30 e0       	ldi	r19, 0x00	; 0
    89fc:	29 1b       	sub	r18, r25
    89fe:	31 09       	sbc	r19, r1
    8a00:	12 16       	cp	r1, r18
    8a02:	13 06       	cpc	r1, r19
    8a04:	d4 f4       	brge	.+52     	; 0x8a3a <Put_sDVal+0x168>
    8a06:	40 e0       	ldi	r20, 0x00	; 0
    8a08:	80 e0       	ldi	r24, 0x00	; 0
    8a0a:	90 e0       	ldi	r25, 0x00	; 0
			Param->Pos[i] = Param->Pos[i+1];
    8a0c:	d8 01       	movw	r26, r16
    8a0e:	ed 91       	ld	r30, X+
    8a10:	fc 91       	ld	r31, X
    8a12:	11 97       	sbiw	r26, 0x01	; 1
    8a14:	e8 0f       	add	r30, r24
    8a16:	f9 1f       	adc	r31, r25
    8a18:	81 81       	ldd	r24, Z+1	; 0x01
    8a1a:	80 83       	st	Z, r24
	//Delete sign if zero
	if(!Val)Param->Pos[Param->Size-2] = ' ';

	if(Param->Prec){
		//Insert decimal point
		for(uint8_t i=0; i< Param->Size - Param->Prec; i++){
    8a1c:	4f 5f       	subi	r20, 0xFF	; 255
    8a1e:	13 96       	adiw	r26, 0x03	; 3
    8a20:	8c 91       	ld	r24, X
    8a22:	13 97       	sbiw	r26, 0x03	; 3
    8a24:	28 2f       	mov	r18, r24
    8a26:	30 e0       	ldi	r19, 0x00	; 0
    8a28:	12 96       	adiw	r26, 0x02	; 2
    8a2a:	8c 91       	ld	r24, X
    8a2c:	28 1b       	sub	r18, r24
    8a2e:	31 09       	sbc	r19, r1
    8a30:	84 2f       	mov	r24, r20
    8a32:	90 e0       	ldi	r25, 0x00	; 0
    8a34:	82 17       	cp	r24, r18
    8a36:	93 07       	cpc	r25, r19
    8a38:	4c f3       	brlt	.-46     	; 0x8a0c <Put_sDVal+0x13a>
			Param->Pos[i] = Param->Pos[i+1];
		}
		Param->Pos[Param->Size - Param->Prec-1] = '.';
    8a3a:	d8 01       	movw	r26, r16
    8a3c:	ed 91       	ld	r30, X+
    8a3e:	fc 91       	ld	r31, X
    8a40:	11 97       	sbiw	r26, 0x01	; 1
    8a42:	e2 0f       	add	r30, r18
    8a44:	f3 1f       	adc	r31, r19
    8a46:	31 97       	sbiw	r30, 0x01	; 1
    8a48:	8e e2       	ldi	r24, 0x2E	; 46
    8a4a:	80 83       	st	Z, r24
		//Fill zeros and shift sign for correct view
		char c = Param->Pos[Param->Size - Param->Prec-2];
    8a4c:	4d 91       	ld	r20, X+
    8a4e:	5c 91       	ld	r21, X
    8a50:	11 97       	sbiw	r26, 0x01	; 1
    8a52:	13 96       	adiw	r26, 0x03	; 3
    8a54:	9c 91       	ld	r25, X
    8a56:	13 97       	sbiw	r26, 0x03	; 3
    8a58:	e9 2f       	mov	r30, r25
    8a5a:	f0 e0       	ldi	r31, 0x00	; 0
    8a5c:	12 96       	adiw	r26, 0x02	; 2
    8a5e:	8c 91       	ld	r24, X
    8a60:	e8 1b       	sub	r30, r24
    8a62:	f1 09       	sbc	r31, r1
    8a64:	e4 0f       	add	r30, r20
    8a66:	f5 1f       	adc	r31, r21
    8a68:	32 97       	sbiw	r30, 0x02	; 2
    8a6a:	e0 81       	ld	r30, Z
		if(c ==' ' || c =='+' || c =='-'){
    8a6c:	e0 32       	cpi	r30, 0x20	; 32
    8a6e:	99 f0       	breq	.+38     	; 0x8a96 <Put_sDVal+0x1c4>
    8a70:	eb 32       	cpi	r30, 0x2B	; 43
    8a72:	89 f0       	breq	.+34     	; 0x8a96 <Put_sDVal+0x1c4>
    8a74:	ed 32       	cpi	r30, 0x2D	; 45
    8a76:	79 f0       	breq	.+30     	; 0x8a96 <Put_sDVal+0x1c4>
				}
			}
		}
	}

}
    8a78:	2d 96       	adiw	r28, 0x0d	; 13
    8a7a:	0f b6       	in	r0, 0x3f	; 63
    8a7c:	f8 94       	cli
    8a7e:	de bf       	out	0x3e, r29	; 62
    8a80:	0f be       	out	0x3f, r0	; 63
    8a82:	cd bf       	out	0x3d, r28	; 61
    8a84:	cf 91       	pop	r28
    8a86:	df 91       	pop	r29
    8a88:	1f 91       	pop	r17
    8a8a:	0f 91       	pop	r16
    8a8c:	ff 90       	pop	r15
    8a8e:	ef 90       	pop	r14
    8a90:	df 90       	pop	r13
    8a92:	cf 90       	pop	r12
    8a94:	08 95       	ret
		}
		Param->Pos[Param->Size - Param->Prec-1] = '.';
		//Fill zeros and shift sign for correct view
		char c = Param->Pos[Param->Size - Param->Prec-2];
		if(c ==' ' || c =='+' || c =='-'){
			for(uint8_t i=Param->Size-1; i>1; i--){
    8a96:	e9 2f       	mov	r30, r25
    8a98:	e1 50       	subi	r30, 0x01	; 1
    8a9a:	e2 30       	cpi	r30, 0x02	; 2
    8a9c:	68 f3       	brcs	.-38     	; 0x8a78 <Put_sDVal+0x1a6>
				if(Param->Pos[i] == ' '|| Param->Pos[i] == '+' || Param->Pos[i] == '-' ) Param->Pos[i]='0';
    8a9e:	90 e3       	ldi	r25, 0x30	; 48
    8aa0:	09 c0       	rjmp	.+18     	; 0x8ab4 <Put_sDVal+0x1e2>
    8aa2:	8b 32       	cpi	r24, 0x2B	; 43
    8aa4:	79 f0       	breq	.+30     	; 0x8ac4 <Put_sDVal+0x1f2>
    8aa6:	8d 32       	cpi	r24, 0x2D	; 45
    8aa8:	69 f0       	breq	.+26     	; 0x8ac4 <Put_sDVal+0x1f2>
				if(Param->Pos[i] == '.'){
    8aaa:	8e 32       	cpi	r24, 0x2E	; 46
    8aac:	a9 f0       	breq	.+42     	; 0x8ad8 <Put_sDVal+0x206>
		}
		Param->Pos[Param->Size - Param->Prec-1] = '.';
		//Fill zeros and shift sign for correct view
		char c = Param->Pos[Param->Size - Param->Prec-2];
		if(c ==' ' || c =='+' || c =='-'){
			for(uint8_t i=Param->Size-1; i>1; i--){
    8aae:	e1 50       	subi	r30, 0x01	; 1
    8ab0:	e2 30       	cpi	r30, 0x02	; 2
    8ab2:	10 f3       	brcs	.-60     	; 0x8a78 <Put_sDVal+0x1a6>
				if(Param->Pos[i] == ' '|| Param->Pos[i] == '+' || Param->Pos[i] == '-' ) Param->Pos[i]='0';
    8ab4:	2e 2f       	mov	r18, r30
    8ab6:	30 e0       	ldi	r19, 0x00	; 0
    8ab8:	da 01       	movw	r26, r20
    8aba:	a2 0f       	add	r26, r18
    8abc:	b3 1f       	adc	r27, r19
    8abe:	8c 91       	ld	r24, X
    8ac0:	80 32       	cpi	r24, 0x20	; 32
    8ac2:	79 f7       	brne	.-34     	; 0x8aa2 <Put_sDVal+0x1d0>
    8ac4:	9c 93       	st	X, r25
    8ac6:	d8 01       	movw	r26, r16
    8ac8:	4d 91       	ld	r20, X+
    8aca:	5c 91       	ld	r21, X
    8acc:	da 01       	movw	r26, r20
    8ace:	a2 0f       	add	r26, r18
    8ad0:	b3 1f       	adc	r27, r19
    8ad2:	8c 91       	ld	r24, X
				if(Param->Pos[i] == '.'){
    8ad4:	8e 32       	cpi	r24, 0x2E	; 46
    8ad6:	59 f7       	brne	.-42     	; 0x8aae <Put_sDVal+0x1dc>
					Param->Pos[i-1]='0';
    8ad8:	11 97       	sbiw	r26, 0x01	; 1
    8ada:	80 e3       	ldi	r24, 0x30	; 48
    8adc:	8c 93       	st	X, r24
					if(Val>0)Param->Pos[i-2]='+';
    8ade:	1c 14       	cp	r1, r12
    8ae0:	1d 04       	cpc	r1, r13
    8ae2:	1e 04       	cpc	r1, r14
    8ae4:	1f 04       	cpc	r1, r15
    8ae6:	44 f4       	brge	.+16     	; 0x8af8 <Put_sDVal+0x226>
    8ae8:	d8 01       	movw	r26, r16
    8aea:	ed 91       	ld	r30, X+
    8aec:	fc 91       	ld	r31, X
    8aee:	e2 0f       	add	r30, r18
    8af0:	f3 1f       	adc	r31, r19
    8af2:	32 97       	sbiw	r30, 0x02	; 2
    8af4:	8b e2       	ldi	r24, 0x2B	; 43
    8af6:	80 83       	st	Z, r24
					if(Val<0)Param->Pos[i-2]='-';
    8af8:	f7 fe       	sbrs	r15, 7
    8afa:	be cf       	rjmp	.-132    	; 0x8a78 <Put_sDVal+0x1a6>
    8afc:	d8 01       	movw	r26, r16
    8afe:	ed 91       	ld	r30, X+
    8b00:	fc 91       	ld	r31, X
    8b02:	e2 0f       	add	r30, r18
    8b04:	f3 1f       	adc	r31, r19
    8b06:	32 97       	sbiw	r30, 0x02	; 2
    8b08:	8d e2       	ldi	r24, 0x2D	; 45
    8b0a:	80 83       	st	Z, r24
    8b0c:	b5 cf       	rjmp	.-150    	; 0x8a78 <Put_sDVal+0x1a6>
void
Put_sDVal(int32_t Val, T_Param *Param)
{
	uint32_t Idx = 0x80000000+Val;
	if(Param->Txt && Idx<2) {
		Param->Txt += Idx;
    8b0e:	88 0f       	add	r24, r24
    8b10:	99 1f       	adc	r25, r25
    8b12:	28 0f       	add	r18, r24
    8b14:	39 1f       	adc	r19, r25
    8b16:	fa 01       	movw	r30, r20
    8b18:	35 83       	std	Z+5, r19	; 0x05
    8b1a:	24 83       	std	Z+4, r18	; 0x04
		PutEnum(Param);
    8b1c:	ca 01       	movw	r24, r20
    8b1e:	0e 94 c9 3f 	call	0x7f92	; 0x7f92 <PutEnum>
    8b22:	aa cf       	rjmp	.-172    	; 0x8a78 <Put_sDVal+0x1a6>

00008b24 <PutDVal>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// PutDVal - print unsigned Longint in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
PutDVal(uint32_t Val, T_Param *Param)
{
    8b24:	2f 92       	push	r2
    8b26:	3f 92       	push	r3
    8b28:	4f 92       	push	r4
    8b2a:	5f 92       	push	r5
    8b2c:	6f 92       	push	r6
    8b2e:	7f 92       	push	r7
    8b30:	8f 92       	push	r8
    8b32:	9f 92       	push	r9
    8b34:	af 92       	push	r10
    8b36:	bf 92       	push	r11
    8b38:	cf 92       	push	r12
    8b3a:	df 92       	push	r13
    8b3c:	ef 92       	push	r14
    8b3e:	ff 92       	push	r15
    8b40:	0f 93       	push	r16
    8b42:	1f 93       	push	r17
    8b44:	df 93       	push	r29
    8b46:	cf 93       	push	r28
    8b48:	cd b7       	in	r28, 0x3d	; 61
    8b4a:	de b7       	in	r29, 0x3e	; 62
    8b4c:	2b 97       	sbiw	r28, 0x0b	; 11
    8b4e:	0f b6       	in	r0, 0x3f	; 63
    8b50:	f8 94       	cli
    8b52:	de bf       	out	0x3e, r29	; 62
    8b54:	0f be       	out	0x3f, r0	; 63
    8b56:	cd bf       	out	0x3d, r28	; 61
    8b58:	1b 01       	movw	r2, r22
    8b5a:	2c 01       	movw	r4, r24
    8b5c:	3a 01       	movw	r6, r20
	uint32_t Idx = 0xFFFFFFFF-Val;
	if(Param->Txt && Idx<2) {
    8b5e:	da 01       	movw	r26, r20
    8b60:	14 96       	adiw	r26, 0x04	; 4
    8b62:	2d 91       	ld	r18, X+
    8b64:	3c 91       	ld	r19, X
    8b66:	15 97       	sbiw	r26, 0x05	; 5
    8b68:	21 15       	cp	r18, r1
    8b6a:	31 05       	cpc	r19, r1
    8b6c:	61 f0       	breq	.+24     	; 0x8b86 <PutDVal+0x62>
// PutDVal - print unsigned Longint in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
PutDVal(uint32_t Val, T_Param *Param)
{
	uint32_t Idx = 0xFFFFFFFF-Val;
    8b6e:	dc 01       	movw	r26, r24
    8b70:	cb 01       	movw	r24, r22
    8b72:	80 95       	com	r24
    8b74:	90 95       	com	r25
    8b76:	a0 95       	com	r26
    8b78:	b0 95       	com	r27
	if(Param->Txt && Idx<2) {
    8b7a:	82 30       	cpi	r24, 0x02	; 2
    8b7c:	91 05       	cpc	r25, r1
    8b7e:	a1 05       	cpc	r26, r1
    8b80:	b1 05       	cpc	r27, r1
    8b82:	08 f4       	brcc	.+2      	; 0x8b86 <PutDVal+0x62>
    8b84:	e5 c0       	rjmp	.+458    	; 0x8d50 <PutDVal+0x22c>
		Param->Txt += Idx;
		PutEnum(Param);
		return;
	}

	if(Param->Size==10 && Param->Prec==0){
    8b86:	d3 01       	movw	r26, r6
    8b88:	13 96       	adiw	r26, 0x03	; 3
    8b8a:	8c 91       	ld	r24, X
    8b8c:	13 97       	sbiw	r26, 0x03	; 3
    8b8e:	8a 30       	cpi	r24, 0x0A	; 10
    8b90:	09 f4       	brne	.+2      	; 0x8b94 <PutDVal+0x70>
    8b92:	72 c0       	rjmp	.+228    	; 0x8c78 <PutDVal+0x154>
		sprintf(Param->Pos, "%10lu", Val);
		return;
	}
	char Format[] = "% lu.%. lu";
    8b94:	de 01       	movw	r26, r28
    8b96:	11 96       	adiw	r26, 0x01	; 1
    8b98:	e6 e6       	ldi	r30, 0x66	; 102
    8b9a:	f2 e0       	ldi	r31, 0x02	; 2
    8b9c:	8b e0       	ldi	r24, 0x0B	; 11
    8b9e:	01 90       	ld	r0, Z+
    8ba0:	0d 92       	st	X+, r0
    8ba2:	81 50       	subi	r24, 0x01	; 1
    8ba4:	e1 f7       	brne	.-8      	; 0x8b9e <PutDVal+0x7a>
	Format[1] = '0'+Param->Size;
    8ba6:	d3 01       	movw	r26, r6
    8ba8:	13 96       	adiw	r26, 0x03	; 3
    8baa:	2c 91       	ld	r18, X
    8bac:	13 97       	sbiw	r26, 0x03	; 3
    8bae:	20 5d       	subi	r18, 0xD0	; 208
    8bb0:	2a 83       	std	Y+2, r18	; 0x02
	if(Param->Prec) {
    8bb2:	12 96       	adiw	r26, 0x02	; 2
    8bb4:	9c 91       	ld	r25, X
    8bb6:	99 23       	and	r25, r25
    8bb8:	09 f4       	brne	.+2      	; 0x8bbc <PutDVal+0x98>
    8bba:	a0 c0       	rjmp	.+320    	; 0x8cfc <PutDVal+0x1d8>
		Format[1] -= Param->Prec+1;
    8bbc:	89 2f       	mov	r24, r25
    8bbe:	80 95       	com	r24
    8bc0:	82 0f       	add	r24, r18
    8bc2:	8a 83       	std	Y+2, r24	; 0x02
		Format[7] = '0'+Param->Prec;
    8bc4:	90 5d       	subi	r25, 0xD0	; 208
    8bc6:	98 87       	std	Y+8, r25	; 0x08
    8bc8:	90 53       	subi	r25, 0x30	; 48
		uint32_t Div=PowL10(Param->Prec);
    8bca:	09 2f       	mov	r16, r25
    8bcc:	f1 e0       	ldi	r31, 0x01	; 1
    8bce:	8f 2e       	mov	r8, r31
    8bd0:	91 2c       	mov	r9, r1
    8bd2:	a1 2c       	mov	r10, r1
    8bd4:	b1 2c       	mov	r11, r1
		Pow *= 10;
    8bd6:	c5 01       	movw	r24, r10
    8bd8:	b4 01       	movw	r22, r8
    8bda:	2a e0       	ldi	r18, 0x0A	; 10
    8bdc:	30 e0       	ldi	r19, 0x00	; 0
    8bde:	40 e0       	ldi	r20, 0x00	; 0
    8be0:	50 e0       	ldi	r21, 0x00	; 0
    8be2:	0e 94 3f 7d 	call	0xfa7e	; 0xfa7e <__mulsi3>
    8be6:	4b 01       	movw	r8, r22
    8be8:	5c 01       	movw	r10, r24
    8bea:	01 50       	subi	r16, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
	uint32_t Pow = 1;
	while(Exp--)
    8bec:	a1 f7       	brne	.-24     	; 0x8bd6 <PutDVal+0xb2>
    8bee:	c2 01       	movw	r24, r4
    8bf0:	b1 01       	movw	r22, r2
    8bf2:	94 01       	movw	r18, r8
    8bf4:	a5 01       	movw	r20, r10
    8bf6:	0e 94 91 7d 	call	0xfb22	; 0xfb22 <__udivmodsi4>
    8bfa:	f6 2e       	mov	r15, r22
    8bfc:	e7 2e       	mov	r14, r23
    8bfe:	d8 2e       	mov	r13, r24
    8c00:	c9 2e       	mov	r12, r25
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
    8c02:	ed b7       	in	r30, 0x3d	; 61
    8c04:	fe b7       	in	r31, 0x3e	; 62
    8c06:	3c 97       	sbiw	r30, 0x0c	; 12
    8c08:	0f b6       	in	r0, 0x3f	; 63
    8c0a:	f8 94       	cli
    8c0c:	fe bf       	out	0x3e, r31	; 62
    8c0e:	0f be       	out	0x3f, r0	; 63
    8c10:	ed bf       	out	0x3d, r30	; 61
    8c12:	0d b7       	in	r16, 0x3d	; 61
    8c14:	1e b7       	in	r17, 0x3e	; 62
    8c16:	0f 5f       	subi	r16, 0xFF	; 255
    8c18:	1f 4f       	sbci	r17, 0xFF	; 255
    8c1a:	d3 01       	movw	r26, r6
    8c1c:	8d 91       	ld	r24, X+
    8c1e:	9c 91       	ld	r25, X
    8c20:	92 83       	std	Z+2, r25	; 0x02
    8c22:	81 83       	std	Z+1, r24	; 0x01
    8c24:	81 e0       	ldi	r24, 0x01	; 1
    8c26:	90 e0       	ldi	r25, 0x00	; 0
    8c28:	8c 0f       	add	r24, r28
    8c2a:	9d 1f       	adc	r25, r29
    8c2c:	f8 01       	movw	r30, r16
    8c2e:	93 83       	std	Z+3, r25	; 0x03
    8c30:	82 83       	std	Z+2, r24	; 0x02
    8c32:	c2 01       	movw	r24, r4
    8c34:	b1 01       	movw	r22, r2
    8c36:	a5 01       	movw	r20, r10
    8c38:	94 01       	movw	r18, r8
    8c3a:	0e 94 91 7d 	call	0xfb22	; 0xfb22 <__udivmodsi4>
    8c3e:	d8 01       	movw	r26, r16
    8c40:	14 96       	adiw	r26, 0x04	; 4
    8c42:	2d 93       	st	X+, r18
    8c44:	3d 93       	st	X+, r19
    8c46:	4d 93       	st	X+, r20
    8c48:	5c 93       	st	X, r21
    8c4a:	17 97       	sbiw	r26, 0x07	; 7
    8c4c:	18 96       	adiw	r26, 0x08	; 8
    8c4e:	fc 92       	st	X, r15
    8c50:	18 97       	sbiw	r26, 0x08	; 8
    8c52:	19 96       	adiw	r26, 0x09	; 9
    8c54:	ec 92       	st	X, r14
    8c56:	19 97       	sbiw	r26, 0x09	; 9
    8c58:	1a 96       	adiw	r26, 0x0a	; 10
    8c5a:	dc 92       	st	X, r13
    8c5c:	1a 97       	sbiw	r26, 0x0a	; 10
    8c5e:	1b 96       	adiw	r26, 0x0b	; 11
    8c60:	cc 92       	st	X, r12
    8c62:	0e 94 d5 7a 	call	0xf5aa	; 0xf5aa <sprintf>
    8c66:	ed b7       	in	r30, 0x3d	; 61
    8c68:	fe b7       	in	r31, 0x3e	; 62
    8c6a:	3c 96       	adiw	r30, 0x0c	; 12
    8c6c:	0f b6       	in	r0, 0x3f	; 63
    8c6e:	f8 94       	cli
    8c70:	fe bf       	out	0x3e, r31	; 62
    8c72:	0f be       	out	0x3f, r0	; 63
    8c74:	ed bf       	out	0x3d, r30	; 61
    8c76:	29 c0       	rjmp	.+82     	; 0x8cca <PutDVal+0x1a6>
		Param->Txt += Idx;
		PutEnum(Param);
		return;
	}

	if(Param->Size==10 && Param->Prec==0){
    8c78:	12 96       	adiw	r26, 0x02	; 2
    8c7a:	8c 91       	ld	r24, X
    8c7c:	12 97       	sbiw	r26, 0x02	; 2
    8c7e:	88 23       	and	r24, r24
    8c80:	09 f0       	breq	.+2      	; 0x8c84 <PutDVal+0x160>
    8c82:	88 cf       	rjmp	.-240    	; 0x8b94 <PutDVal+0x70>
		sprintf(Param->Pos, "%10lu", Val);
    8c84:	ed b7       	in	r30, 0x3d	; 61
    8c86:	fe b7       	in	r31, 0x3e	; 62
    8c88:	38 97       	sbiw	r30, 0x08	; 8
    8c8a:	0f b6       	in	r0, 0x3f	; 63
    8c8c:	f8 94       	cli
    8c8e:	fe bf       	out	0x3e, r31	; 62
    8c90:	0f be       	out	0x3f, r0	; 63
    8c92:	ed bf       	out	0x3d, r30	; 61
    8c94:	31 96       	adiw	r30, 0x01	; 1
    8c96:	8d 91       	ld	r24, X+
    8c98:	9c 91       	ld	r25, X
    8c9a:	ad b7       	in	r26, 0x3d	; 61
    8c9c:	be b7       	in	r27, 0x3e	; 62
    8c9e:	12 96       	adiw	r26, 0x02	; 2
    8ca0:	9c 93       	st	X, r25
    8ca2:	8e 93       	st	-X, r24
    8ca4:	11 97       	sbiw	r26, 0x01	; 1
    8ca6:	80 e6       	ldi	r24, 0x60	; 96
    8ca8:	92 e0       	ldi	r25, 0x02	; 2
    8caa:	93 83       	std	Z+3, r25	; 0x03
    8cac:	82 83       	std	Z+2, r24	; 0x02
    8cae:	24 82       	std	Z+4, r2	; 0x04
    8cb0:	35 82       	std	Z+5, r3	; 0x05
    8cb2:	46 82       	std	Z+6, r4	; 0x06
    8cb4:	57 82       	std	Z+7, r5	; 0x07
    8cb6:	0e 94 d5 7a 	call	0xf5aa	; 0xf5aa <sprintf>
    8cba:	ed b7       	in	r30, 0x3d	; 61
    8cbc:	fe b7       	in	r31, 0x3e	; 62
    8cbe:	38 96       	adiw	r30, 0x08	; 8
    8cc0:	0f b6       	in	r0, 0x3f	; 63
    8cc2:	f8 94       	cli
    8cc4:	fe bf       	out	0x3e, r31	; 62
    8cc6:	0f be       	out	0x3f, r0	; 63
    8cc8:	ed bf       	out	0x3d, r30	; 61
	}
	else {
		Format[4] = '\0';
		sprintf(Param->Pos, Format, Val);
	}
}
    8cca:	2b 96       	adiw	r28, 0x0b	; 11
    8ccc:	0f b6       	in	r0, 0x3f	; 63
    8cce:	f8 94       	cli
    8cd0:	de bf       	out	0x3e, r29	; 62
    8cd2:	0f be       	out	0x3f, r0	; 63
    8cd4:	cd bf       	out	0x3d, r28	; 61
    8cd6:	cf 91       	pop	r28
    8cd8:	df 91       	pop	r29
    8cda:	1f 91       	pop	r17
    8cdc:	0f 91       	pop	r16
    8cde:	ff 90       	pop	r15
    8ce0:	ef 90       	pop	r14
    8ce2:	df 90       	pop	r13
    8ce4:	cf 90       	pop	r12
    8ce6:	bf 90       	pop	r11
    8ce8:	af 90       	pop	r10
    8cea:	9f 90       	pop	r9
    8cec:	8f 90       	pop	r8
    8cee:	7f 90       	pop	r7
    8cf0:	6f 90       	pop	r6
    8cf2:	5f 90       	pop	r5
    8cf4:	4f 90       	pop	r4
    8cf6:	3f 90       	pop	r3
    8cf8:	2f 90       	pop	r2
    8cfa:	08 95       	ret
		Format[7] = '0'+Param->Prec;
		uint32_t Div=PowL10(Param->Prec);
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
	}
	else {
		Format[4] = '\0';
    8cfc:	1d 82       	std	Y+5, r1	; 0x05
		sprintf(Param->Pos, Format, Val);
    8cfe:	8d b7       	in	r24, 0x3d	; 61
    8d00:	9e b7       	in	r25, 0x3e	; 62
    8d02:	08 97       	sbiw	r24, 0x08	; 8
    8d04:	0f b6       	in	r0, 0x3f	; 63
    8d06:	f8 94       	cli
    8d08:	9e bf       	out	0x3e, r25	; 62
    8d0a:	0f be       	out	0x3f, r0	; 63
    8d0c:	8d bf       	out	0x3d, r24	; 61
    8d0e:	ed b7       	in	r30, 0x3d	; 61
    8d10:	fe b7       	in	r31, 0x3e	; 62
    8d12:	31 96       	adiw	r30, 0x01	; 1
    8d14:	d3 01       	movw	r26, r6
    8d16:	8d 91       	ld	r24, X+
    8d18:	9c 91       	ld	r25, X
    8d1a:	ad b7       	in	r26, 0x3d	; 61
    8d1c:	be b7       	in	r27, 0x3e	; 62
    8d1e:	12 96       	adiw	r26, 0x02	; 2
    8d20:	9c 93       	st	X, r25
    8d22:	8e 93       	st	-X, r24
    8d24:	11 97       	sbiw	r26, 0x01	; 1
    8d26:	81 e0       	ldi	r24, 0x01	; 1
    8d28:	90 e0       	ldi	r25, 0x00	; 0
    8d2a:	8c 0f       	add	r24, r28
    8d2c:	9d 1f       	adc	r25, r29
    8d2e:	93 83       	std	Z+3, r25	; 0x03
    8d30:	82 83       	std	Z+2, r24	; 0x02
    8d32:	24 82       	std	Z+4, r2	; 0x04
    8d34:	35 82       	std	Z+5, r3	; 0x05
    8d36:	46 82       	std	Z+6, r4	; 0x06
    8d38:	57 82       	std	Z+7, r5	; 0x07
    8d3a:	0e 94 d5 7a 	call	0xf5aa	; 0xf5aa <sprintf>
    8d3e:	ad b7       	in	r26, 0x3d	; 61
    8d40:	be b7       	in	r27, 0x3e	; 62
    8d42:	18 96       	adiw	r26, 0x08	; 8
    8d44:	0f b6       	in	r0, 0x3f	; 63
    8d46:	f8 94       	cli
    8d48:	be bf       	out	0x3e, r27	; 62
    8d4a:	0f be       	out	0x3f, r0	; 63
    8d4c:	ad bf       	out	0x3d, r26	; 61
    8d4e:	bd cf       	rjmp	.-134    	; 0x8cca <PutDVal+0x1a6>
void
PutDVal(uint32_t Val, T_Param *Param)
{
	uint32_t Idx = 0xFFFFFFFF-Val;
	if(Param->Txt && Idx<2) {
		Param->Txt += Idx;
    8d50:	88 0f       	add	r24, r24
    8d52:	99 1f       	adc	r25, r25
    8d54:	28 0f       	add	r18, r24
    8d56:	39 1f       	adc	r19, r25
    8d58:	fa 01       	movw	r30, r20
    8d5a:	35 83       	std	Z+5, r19	; 0x05
    8d5c:	24 83       	std	Z+4, r18	; 0x04
		PutEnum(Param);
    8d5e:	ca 01       	movw	r24, r20
    8d60:	0e 94 c9 3f 	call	0x7f92	; 0x7f92 <PutEnum>
    8d64:	b2 cf       	rjmp	.-156    	; 0x8cca <PutDVal+0x1a6>

00008d66 <Put_zVal_h>:
	}
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_zVal_h(uint32_t Val, char Type, T_Param *Param)
{
    8d66:	1f 93       	push	r17
    8d68:	17 2f       	mov	r17, r23
    8d6a:	58 2f       	mov	r21, r24
    8d6c:	79 2f       	mov	r23, r25
    8d6e:	d9 01       	movw	r26, r18
	if(Type=='b') sprintf(Param->Pos, "%02hx", (uint8_t)Val);
    8d70:	42 36       	cpi	r20, 0x62	; 98
    8d72:	71 f1       	breq	.+92     	; 0x8dd0 <Put_zVal_h+0x6a>
	if(Type=='w') sprintf(Param->Pos, "%04x", (uint16_t)Val);
    8d74:	47 37       	cpi	r20, 0x77	; 119
    8d76:	09 f4       	brne	.+2      	; 0x8d7a <Put_zVal_h+0x14>
    8d78:	4a c0       	rjmp	.+148    	; 0x8e0e <Put_zVal_h+0xa8>
	if(Type=='l') sprintf(Param->Pos, "%08lx", Val);
    8d7a:	4c 36       	cpi	r20, 0x6C	; 108
    8d7c:	11 f0       	breq	.+4      	; 0x8d82 <Put_zVal_h+0x1c>
}
    8d7e:	1f 91       	pop	r17
    8d80:	08 95       	ret
void
Put_zVal_h(uint32_t Val, char Type, T_Param *Param)
{
	if(Type=='b') sprintf(Param->Pos, "%02hx", (uint8_t)Val);
	if(Type=='w') sprintf(Param->Pos, "%04x", (uint16_t)Val);
	if(Type=='l') sprintf(Param->Pos, "%08lx", Val);
    8d82:	8d b7       	in	r24, 0x3d	; 61
    8d84:	9e b7       	in	r25, 0x3e	; 62
    8d86:	08 97       	sbiw	r24, 0x08	; 8
    8d88:	0f b6       	in	r0, 0x3f	; 63
    8d8a:	f8 94       	cli
    8d8c:	9e bf       	out	0x3e, r25	; 62
    8d8e:	0f be       	out	0x3f, r0	; 63
    8d90:	8d bf       	out	0x3d, r24	; 61
    8d92:	ed b7       	in	r30, 0x3d	; 61
    8d94:	fe b7       	in	r31, 0x3e	; 62
    8d96:	31 96       	adiw	r30, 0x01	; 1
    8d98:	8d 91       	ld	r24, X+
    8d9a:	9c 91       	ld	r25, X
    8d9c:	ad b7       	in	r26, 0x3d	; 61
    8d9e:	be b7       	in	r27, 0x3e	; 62
    8da0:	12 96       	adiw	r26, 0x02	; 2
    8da2:	9c 93       	st	X, r25
    8da4:	8e 93       	st	-X, r24
    8da6:	11 97       	sbiw	r26, 0x01	; 1
    8da8:	8c e7       	ldi	r24, 0x7C	; 124
    8daa:	92 e0       	ldi	r25, 0x02	; 2
    8dac:	93 83       	std	Z+3, r25	; 0x03
    8dae:	82 83       	std	Z+2, r24	; 0x02
    8db0:	64 83       	std	Z+4, r22	; 0x04
    8db2:	15 83       	std	Z+5, r17	; 0x05
    8db4:	56 83       	std	Z+6, r21	; 0x06
    8db6:	77 83       	std	Z+7, r23	; 0x07
    8db8:	0e 94 d5 7a 	call	0xf5aa	; 0xf5aa <sprintf>
    8dbc:	8d b7       	in	r24, 0x3d	; 61
    8dbe:	9e b7       	in	r25, 0x3e	; 62
    8dc0:	08 96       	adiw	r24, 0x08	; 8
    8dc2:	0f b6       	in	r0, 0x3f	; 63
    8dc4:	f8 94       	cli
    8dc6:	9e bf       	out	0x3e, r25	; 62
    8dc8:	0f be       	out	0x3f, r0	; 63
    8dca:	8d bf       	out	0x3d, r24	; 61
}
    8dcc:	1f 91       	pop	r17
    8dce:	08 95       	ret
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_zVal_h(uint32_t Val, char Type, T_Param *Param)
{
	if(Type=='b') sprintf(Param->Pos, "%02hx", (uint8_t)Val);
    8dd0:	00 d0       	rcall	.+0      	; 0x8dd2 <Put_zVal_h+0x6c>
    8dd2:	00 d0       	rcall	.+0      	; 0x8dd4 <Put_zVal_h+0x6e>
    8dd4:	ed b7       	in	r30, 0x3d	; 61
    8dd6:	fe b7       	in	r31, 0x3e	; 62
    8dd8:	31 96       	adiw	r30, 0x01	; 1
    8dda:	8d 91       	ld	r24, X+
    8ddc:	9c 91       	ld	r25, X
    8dde:	ad b7       	in	r26, 0x3d	; 61
    8de0:	be b7       	in	r27, 0x3e	; 62
    8de2:	12 96       	adiw	r26, 0x02	; 2
    8de4:	9c 93       	st	X, r25
    8de6:	8e 93       	st	-X, r24
    8de8:	11 97       	sbiw	r26, 0x01	; 1
    8dea:	81 e7       	ldi	r24, 0x71	; 113
    8dec:	92 e0       	ldi	r25, 0x02	; 2
    8dee:	93 83       	std	Z+3, r25	; 0x03
    8df0:	82 83       	std	Z+2, r24	; 0x02
    8df2:	64 83       	std	Z+4, r22	; 0x04
    8df4:	15 82       	std	Z+5, r1	; 0x05
    8df6:	0e 94 d5 7a 	call	0xf5aa	; 0xf5aa <sprintf>
    8dfa:	8d b7       	in	r24, 0x3d	; 61
    8dfc:	9e b7       	in	r25, 0x3e	; 62
    8dfe:	06 96       	adiw	r24, 0x06	; 6
    8e00:	0f b6       	in	r0, 0x3f	; 63
    8e02:	f8 94       	cli
    8e04:	9e bf       	out	0x3e, r25	; 62
    8e06:	0f be       	out	0x3f, r0	; 63
    8e08:	8d bf       	out	0x3d, r24	; 61
	if(Type=='w') sprintf(Param->Pos, "%04x", (uint16_t)Val);
	if(Type=='l') sprintf(Param->Pos, "%08lx", Val);
}
    8e0a:	1f 91       	pop	r17
    8e0c:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_zVal_h(uint32_t Val, char Type, T_Param *Param)
{
	if(Type=='b') sprintf(Param->Pos, "%02hx", (uint8_t)Val);
	if(Type=='w') sprintf(Param->Pos, "%04x", (uint16_t)Val);
    8e0e:	00 d0       	rcall	.+0      	; 0x8e10 <Put_zVal_h+0xaa>
    8e10:	00 d0       	rcall	.+0      	; 0x8e12 <Put_zVal_h+0xac>
    8e12:	ed b7       	in	r30, 0x3d	; 61
    8e14:	fe b7       	in	r31, 0x3e	; 62
    8e16:	31 96       	adiw	r30, 0x01	; 1
    8e18:	8d 91       	ld	r24, X+
    8e1a:	9c 91       	ld	r25, X
    8e1c:	ad b7       	in	r26, 0x3d	; 61
    8e1e:	be b7       	in	r27, 0x3e	; 62
    8e20:	12 96       	adiw	r26, 0x02	; 2
    8e22:	9c 93       	st	X, r25
    8e24:	8e 93       	st	-X, r24
    8e26:	11 97       	sbiw	r26, 0x01	; 1
    8e28:	87 e7       	ldi	r24, 0x77	; 119
    8e2a:	92 e0       	ldi	r25, 0x02	; 2
    8e2c:	93 83       	std	Z+3, r25	; 0x03
    8e2e:	82 83       	std	Z+2, r24	; 0x02
    8e30:	64 83       	std	Z+4, r22	; 0x04
    8e32:	15 83       	std	Z+5, r17	; 0x05
    8e34:	0e 94 d5 7a 	call	0xf5aa	; 0xf5aa <sprintf>
    8e38:	8d b7       	in	r24, 0x3d	; 61
    8e3a:	9e b7       	in	r25, 0x3e	; 62
    8e3c:	06 96       	adiw	r24, 0x06	; 6
    8e3e:	0f b6       	in	r0, 0x3f	; 63
    8e40:	f8 94       	cli
    8e42:	9e bf       	out	0x3e, r25	; 62
    8e44:	0f be       	out	0x3f, r0	; 63
    8e46:	8d bf       	out	0x3d, r24	; 61
	if(Type=='l') sprintf(Param->Pos, "%08lx", Val);
}
    8e48:	1f 91       	pop	r17
    8e4a:	08 95       	ret

00008e4c <Put_zVal>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_zVal(uint16_t Val, char Type, T_Param *Param)
{
    8e4c:	af 92       	push	r10
    8e4e:	bf 92       	push	r11
    8e50:	cf 92       	push	r12
    8e52:	df 92       	push	r13
    8e54:	ef 92       	push	r14
    8e56:	ff 92       	push	r15
    8e58:	0f 93       	push	r16
    8e5a:	1f 93       	push	r17
    8e5c:	df 93       	push	r29
    8e5e:	cf 93       	push	r28
    8e60:	cd b7       	in	r28, 0x3d	; 61
    8e62:	de b7       	in	r29, 0x3e	; 62
    8e64:	2a 97       	sbiw	r28, 0x0a	; 10
    8e66:	0f b6       	in	r0, 0x3f	; 63
    8e68:	f8 94       	cli
    8e6a:	de bf       	out	0x3e, r29	; 62
    8e6c:	0f be       	out	0x3f, r0	; 63
    8e6e:	cd bf       	out	0x3d, r28	; 61
    8e70:	6c 01       	movw	r12, r24
    8e72:	7a 01       	movw	r14, r20
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
    8e74:	67 37       	cpi	r22, 0x77	; 119
    8e76:	09 f4       	brne	.+2      	; 0x8e7a <Put_zVal+0x2e>
    8e78:	79 c0       	rjmp	.+242    	; 0x8f6c <Put_zVal+0x120>
    8e7a:	8f ef       	ldi	r24, 0xFF	; 255
    8e7c:	90 e0       	ldi	r25, 0x00	; 0
	if(Param->Txt && Idx<2) {
    8e7e:	d7 01       	movw	r26, r14
    8e80:	14 96       	adiw	r26, 0x04	; 4
    8e82:	2d 91       	ld	r18, X+
    8e84:	3c 91       	ld	r19, X
    8e86:	15 97       	sbiw	r26, 0x05	; 5
    8e88:	21 15       	cp	r18, r1
    8e8a:	31 05       	cpc	r19, r1
    8e8c:	31 f0       	breq	.+12     	; 0x8e9a <Put_zVal+0x4e>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_zVal(uint16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
    8e8e:	8c 19       	sub	r24, r12
    8e90:	9d 09       	sbc	r25, r13
	if(Param->Txt && Idx<2) {
    8e92:	82 30       	cpi	r24, 0x02	; 2
    8e94:	91 05       	cpc	r25, r1
    8e96:	08 f4       	brcc	.+2      	; 0x8e9a <Put_zVal+0x4e>
    8e98:	8a c0       	rjmp	.+276    	; 0x8fae <Put_zVal+0x162>
		Param->Txt += Idx;
		PutEnum(Param);
		return;
	}
	char Format[] = "%0 u.%. u";
    8e9a:	5e 01       	movw	r10, r28
    8e9c:	08 94       	sec
    8e9e:	a1 1c       	adc	r10, r1
    8ea0:	b1 1c       	adc	r11, r1
    8ea2:	d5 01       	movw	r26, r10
    8ea4:	e2 e8       	ldi	r30, 0x82	; 130
    8ea6:	f2 e0       	ldi	r31, 0x02	; 2
    8ea8:	8a e0       	ldi	r24, 0x0A	; 10
    8eaa:	01 90       	ld	r0, Z+
    8eac:	0d 92       	st	X+, r0
    8eae:	81 50       	subi	r24, 0x01	; 1
    8eb0:	e1 f7       	brne	.-8      	; 0x8eaa <Put_zVal+0x5e>
	Format[2] = '0'+Param->Size;
    8eb2:	f7 01       	movw	r30, r14
    8eb4:	23 81       	ldd	r18, Z+3	; 0x03
    8eb6:	20 5d       	subi	r18, 0xD0	; 208
    8eb8:	2b 83       	std	Y+3, r18	; 0x03
	if(Param->Prec) {
    8eba:	92 81       	ldd	r25, Z+2	; 0x02
    8ebc:	99 23       	and	r25, r25
    8ebe:	09 f4       	brne	.+2      	; 0x8ec2 <Put_zVal+0x76>
    8ec0:	58 c0       	rjmp	.+176    	; 0x8f72 <Put_zVal+0x126>
		Format[2] -= Param->Prec+1;
    8ec2:	89 2f       	mov	r24, r25
    8ec4:	80 95       	com	r24
    8ec6:	82 0f       	add	r24, r18
    8ec8:	8b 83       	std	Y+3, r24	; 0x03
		Format[7] = '0'+Param->Prec;
    8eca:	90 5d       	subi	r25, 0xD0	; 208
    8ecc:	98 87       	std	Y+8, r25	; 0x08
    8ece:	90 53       	subi	r25, 0x30	; 48
		uint16_t Div=Pow10(Param->Prec);
    8ed0:	29 2f       	mov	r18, r25
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    8ed2:	01 e0       	ldi	r16, 0x01	; 1
    8ed4:	10 e0       	ldi	r17, 0x00	; 0
		Pow *= 10;
    8ed6:	c8 01       	movw	r24, r16
    8ed8:	88 0f       	add	r24, r24
    8eda:	99 1f       	adc	r25, r25
    8edc:	00 0f       	add	r16, r16
    8ede:	11 1f       	adc	r17, r17
    8ee0:	00 0f       	add	r16, r16
    8ee2:	11 1f       	adc	r17, r17
    8ee4:	00 0f       	add	r16, r16
    8ee6:	11 1f       	adc	r17, r17
    8ee8:	08 0f       	add	r16, r24
    8eea:	19 1f       	adc	r17, r25
    8eec:	21 50       	subi	r18, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    8eee:	99 f7       	brne	.-26     	; 0x8ed6 <Put_zVal+0x8a>
    8ef0:	c6 01       	movw	r24, r12
    8ef2:	b8 01       	movw	r22, r16
    8ef4:	0e 94 6a 7d 	call	0xfad4	; 0xfad4 <__udivmodhi4>
    8ef8:	9c 01       	movw	r18, r24
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
    8efa:	8d b7       	in	r24, 0x3d	; 61
    8efc:	9e b7       	in	r25, 0x3e	; 62
    8efe:	08 97       	sbiw	r24, 0x08	; 8
    8f00:	0f b6       	in	r0, 0x3f	; 63
    8f02:	f8 94       	cli
    8f04:	9e bf       	out	0x3e, r25	; 62
    8f06:	0f be       	out	0x3f, r0	; 63
    8f08:	8d bf       	out	0x3d, r24	; 61
    8f0a:	ed b7       	in	r30, 0x3d	; 61
    8f0c:	fe b7       	in	r31, 0x3e	; 62
    8f0e:	31 96       	adiw	r30, 0x01	; 1
    8f10:	d7 01       	movw	r26, r14
    8f12:	8d 91       	ld	r24, X+
    8f14:	9c 91       	ld	r25, X
    8f16:	ad b7       	in	r26, 0x3d	; 61
    8f18:	be b7       	in	r27, 0x3e	; 62
    8f1a:	12 96       	adiw	r26, 0x02	; 2
    8f1c:	9c 93       	st	X, r25
    8f1e:	8e 93       	st	-X, r24
    8f20:	11 97       	sbiw	r26, 0x01	; 1
    8f22:	b3 82       	std	Z+3, r11	; 0x03
    8f24:	a2 82       	std	Z+2, r10	; 0x02
    8f26:	c6 01       	movw	r24, r12
    8f28:	b8 01       	movw	r22, r16
    8f2a:	0e 94 6a 7d 	call	0xfad4	; 0xfad4 <__udivmodhi4>
    8f2e:	75 83       	std	Z+5, r23	; 0x05
    8f30:	64 83       	std	Z+4, r22	; 0x04
    8f32:	26 83       	std	Z+6, r18	; 0x06
    8f34:	37 83       	std	Z+7, r19	; 0x07
    8f36:	0e 94 d5 7a 	call	0xf5aa	; 0xf5aa <sprintf>
    8f3a:	ed b7       	in	r30, 0x3d	; 61
    8f3c:	fe b7       	in	r31, 0x3e	; 62
    8f3e:	38 96       	adiw	r30, 0x08	; 8
    8f40:	0f b6       	in	r0, 0x3f	; 63
    8f42:	f8 94       	cli
    8f44:	fe bf       	out	0x3e, r31	; 62
    8f46:	0f be       	out	0x3f, r0	; 63
    8f48:	ed bf       	out	0x3d, r30	; 61
	}
	else {
		Format[4] = '\0';
		sprintf(Param->Pos, Format, Val);
	}
}
    8f4a:	2a 96       	adiw	r28, 0x0a	; 10
    8f4c:	0f b6       	in	r0, 0x3f	; 63
    8f4e:	f8 94       	cli
    8f50:	de bf       	out	0x3e, r29	; 62
    8f52:	0f be       	out	0x3f, r0	; 63
    8f54:	cd bf       	out	0x3d, r28	; 61
    8f56:	cf 91       	pop	r28
    8f58:	df 91       	pop	r29
    8f5a:	1f 91       	pop	r17
    8f5c:	0f 91       	pop	r16
    8f5e:	ff 90       	pop	r15
    8f60:	ef 90       	pop	r14
    8f62:	df 90       	pop	r13
    8f64:	cf 90       	pop	r12
    8f66:	bf 90       	pop	r11
    8f68:	af 90       	pop	r10
    8f6a:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_zVal(uint16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
    8f6c:	8f ef       	ldi	r24, 0xFF	; 255
    8f6e:	9f ef       	ldi	r25, 0xFF	; 255
    8f70:	86 cf       	rjmp	.-244    	; 0x8e7e <Put_zVal+0x32>
		Format[7] = '0'+Param->Prec;
		uint16_t Div=Pow10(Param->Prec);
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
	}
	else {
		Format[4] = '\0';
    8f72:	1d 82       	std	Y+5, r1	; 0x05
		sprintf(Param->Pos, Format, Val);
    8f74:	00 d0       	rcall	.+0      	; 0x8f76 <Put_zVal+0x12a>
    8f76:	00 d0       	rcall	.+0      	; 0x8f78 <Put_zVal+0x12c>
    8f78:	ed b7       	in	r30, 0x3d	; 61
    8f7a:	fe b7       	in	r31, 0x3e	; 62
    8f7c:	31 96       	adiw	r30, 0x01	; 1
    8f7e:	d7 01       	movw	r26, r14
    8f80:	8d 91       	ld	r24, X+
    8f82:	9c 91       	ld	r25, X
    8f84:	ad b7       	in	r26, 0x3d	; 61
    8f86:	be b7       	in	r27, 0x3e	; 62
    8f88:	12 96       	adiw	r26, 0x02	; 2
    8f8a:	9c 93       	st	X, r25
    8f8c:	8e 93       	st	-X, r24
    8f8e:	11 97       	sbiw	r26, 0x01	; 1
    8f90:	b3 82       	std	Z+3, r11	; 0x03
    8f92:	a2 82       	std	Z+2, r10	; 0x02
    8f94:	d5 82       	std	Z+5, r13	; 0x05
    8f96:	c4 82       	std	Z+4, r12	; 0x04
    8f98:	0e 94 d5 7a 	call	0xf5aa	; 0xf5aa <sprintf>
    8f9c:	ed b7       	in	r30, 0x3d	; 61
    8f9e:	fe b7       	in	r31, 0x3e	; 62
    8fa0:	36 96       	adiw	r30, 0x06	; 6
    8fa2:	0f b6       	in	r0, 0x3f	; 63
    8fa4:	f8 94       	cli
    8fa6:	fe bf       	out	0x3e, r31	; 62
    8fa8:	0f be       	out	0x3f, r0	; 63
    8faa:	ed bf       	out	0x3d, r30	; 61
    8fac:	ce cf       	rjmp	.-100    	; 0x8f4a <Put_zVal+0xfe>
void
Put_zVal(uint16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
	if(Param->Txt && Idx<2) {
		Param->Txt += Idx;
    8fae:	88 0f       	add	r24, r24
    8fb0:	99 1f       	adc	r25, r25
    8fb2:	28 0f       	add	r18, r24
    8fb4:	39 1f       	adc	r19, r25
    8fb6:	15 96       	adiw	r26, 0x05	; 5
    8fb8:	3c 93       	st	X, r19
    8fba:	2e 93       	st	-X, r18
    8fbc:	14 97       	sbiw	r26, 0x04	; 4
		PutEnum(Param);
    8fbe:	c7 01       	movw	r24, r14
    8fc0:	0e 94 c9 3f 	call	0x7f92	; 0x7f92 <PutEnum>
    8fc4:	c2 cf       	rjmp	.-124    	; 0x8f4a <Put_zVal+0xfe>

00008fc6 <Put_sVal>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_sVal(int16_t Val, char Type, T_Param *Param)
{
    8fc6:	af 92       	push	r10
    8fc8:	bf 92       	push	r11
    8fca:	cf 92       	push	r12
    8fcc:	df 92       	push	r13
    8fce:	ef 92       	push	r14
    8fd0:	ff 92       	push	r15
    8fd2:	0f 93       	push	r16
    8fd4:	1f 93       	push	r17
    8fd6:	df 93       	push	r29
    8fd8:	cf 93       	push	r28
    8fda:	cd b7       	in	r28, 0x3d	; 61
    8fdc:	de b7       	in	r29, 0x3e	; 62
    8fde:	2a 97       	sbiw	r28, 0x0a	; 10
    8fe0:	0f b6       	in	r0, 0x3f	; 63
    8fe2:	f8 94       	cli
    8fe4:	de bf       	out	0x3e, r29	; 62
    8fe6:	0f be       	out	0x3f, r0	; 63
    8fe8:	cd bf       	out	0x3d, r28	; 61
    8fea:	6c 01       	movw	r12, r24
    8fec:	7a 01       	movw	r14, r20
	uint16_t Idx = (Type=='w'?0x8000:0x80)+Val;
    8fee:	67 37       	cpi	r22, 0x77	; 119
    8ff0:	09 f4       	brne	.+2      	; 0x8ff4 <Put_sVal+0x2e>
    8ff2:	81 c0       	rjmp	.+258    	; 0x90f6 <Put_sVal+0x130>
    8ff4:	80 e8       	ldi	r24, 0x80	; 128
    8ff6:	90 e0       	ldi	r25, 0x00	; 0
	if(Param->Txt && Idx<2) {
    8ff8:	d7 01       	movw	r26, r14
    8ffa:	14 96       	adiw	r26, 0x04	; 4
    8ffc:	2d 91       	ld	r18, X+
    8ffe:	3c 91       	ld	r19, X
    9000:	15 97       	sbiw	r26, 0x05	; 5
    9002:	21 15       	cp	r18, r1
    9004:	31 05       	cpc	r19, r1
    9006:	31 f0       	breq	.+12     	; 0x9014 <Put_sVal+0x4e>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_sVal(int16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0x8000:0x80)+Val;
    9008:	8c 0d       	add	r24, r12
    900a:	9d 1d       	adc	r25, r13
	if(Param->Txt && Idx<2) {
    900c:	82 30       	cpi	r24, 0x02	; 2
    900e:	91 05       	cpc	r25, r1
    9010:	08 f4       	brcc	.+2      	; 0x9014 <Put_sVal+0x4e>
    9012:	ac c0       	rjmp	.+344    	; 0x916c <Put_sVal+0x1a6>
		Param->Txt += Idx;
		PutEnum(Param);
		return;
	}
	char Format[] = "%+ d.%. u";
    9014:	5e 01       	movw	r10, r28
    9016:	08 94       	sec
    9018:	a1 1c       	adc	r10, r1
    901a:	b1 1c       	adc	r11, r1
    901c:	d5 01       	movw	r26, r10
    901e:	ec e8       	ldi	r30, 0x8C	; 140
    9020:	f2 e0       	ldi	r31, 0x02	; 2
    9022:	8a e0       	ldi	r24, 0x0A	; 10
    9024:	01 90       	ld	r0, Z+
    9026:	0d 92       	st	X+, r0
    9028:	81 50       	subi	r24, 0x01	; 1
    902a:	e1 f7       	brne	.-8      	; 0x9024 <Put_sVal+0x5e>
	if(Val==0)
    902c:	c1 14       	cp	r12, r1
    902e:	d1 04       	cpc	r13, r1
    9030:	09 f4       	brne	.+2      	; 0x9034 <Put_sVal+0x6e>
    9032:	64 c0       	rjmp	.+200    	; 0x90fc <Put_sVal+0x136>
		Format[1] = ' ';
	Format[2] = '0'+Param->Size;
    9034:	f7 01       	movw	r30, r14
    9036:	23 81       	ldd	r18, Z+3	; 0x03
    9038:	20 5d       	subi	r18, 0xD0	; 208
    903a:	2b 83       	std	Y+3, r18	; 0x03
	if(Param->Prec) {
    903c:	92 81       	ldd	r25, Z+2	; 0x02
    903e:	99 23       	and	r25, r25
    9040:	09 f4       	brne	.+2      	; 0x9044 <Put_sVal+0x7e>
    9042:	66 c0       	rjmp	.+204    	; 0x9110 <Put_sVal+0x14a>
		Format[2] -= Param->Prec+1;
    9044:	89 2f       	mov	r24, r25
    9046:	80 95       	com	r24
    9048:	82 0f       	add	r24, r18
    904a:	8b 83       	std	Y+3, r24	; 0x03
		Format[7] = '0'+Param->Prec;
    904c:	90 5d       	subi	r25, 0xD0	; 208
    904e:	98 87       	std	Y+8, r25	; 0x08
    9050:	90 53       	subi	r25, 0x30	; 48
		int16_t Div=Pow10(Param->Prec);
    9052:	29 2f       	mov	r18, r25
    9054:	01 e0       	ldi	r16, 0x01	; 1
    9056:	10 e0       	ldi	r17, 0x00	; 0
		Pow *= 10;
    9058:	c8 01       	movw	r24, r16
    905a:	88 0f       	add	r24, r24
    905c:	99 1f       	adc	r25, r25
    905e:	00 0f       	add	r16, r16
    9060:	11 1f       	adc	r17, r17
    9062:	00 0f       	add	r16, r16
    9064:	11 1f       	adc	r17, r17
    9066:	00 0f       	add	r16, r16
    9068:	11 1f       	adc	r17, r17
    906a:	08 0f       	add	r16, r24
    906c:	19 1f       	adc	r17, r25
    906e:	21 50       	subi	r18, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    9070:	99 f7       	brne	.-26     	; 0x9058 <Put_sVal+0x92>
    9072:	c6 01       	movw	r24, r12
    9074:	d7 fc       	sbrc	r13, 7
    9076:	86 c0       	rjmp	.+268    	; 0x9184 <Put_sVal+0x1be>
    9078:	b8 01       	movw	r22, r16
    907a:	0e 94 6a 7d 	call	0xfad4	; 0xfad4 <__udivmodhi4>
    907e:	9c 01       	movw	r18, r24
		sprintf(Param->Pos, Format, Val/Div, (uint16_t)abs(Val)%Div);
    9080:	8d b7       	in	r24, 0x3d	; 61
    9082:	9e b7       	in	r25, 0x3e	; 62
    9084:	08 97       	sbiw	r24, 0x08	; 8
    9086:	0f b6       	in	r0, 0x3f	; 63
    9088:	f8 94       	cli
    908a:	9e bf       	out	0x3e, r25	; 62
    908c:	0f be       	out	0x3f, r0	; 63
    908e:	8d bf       	out	0x3d, r24	; 61
    9090:	ed b7       	in	r30, 0x3d	; 61
    9092:	fe b7       	in	r31, 0x3e	; 62
    9094:	31 96       	adiw	r30, 0x01	; 1
    9096:	d7 01       	movw	r26, r14
    9098:	8d 91       	ld	r24, X+
    909a:	9c 91       	ld	r25, X
    909c:	ad b7       	in	r26, 0x3d	; 61
    909e:	be b7       	in	r27, 0x3e	; 62
    90a0:	12 96       	adiw	r26, 0x02	; 2
    90a2:	9c 93       	st	X, r25
    90a4:	8e 93       	st	-X, r24
    90a6:	11 97       	sbiw	r26, 0x01	; 1
    90a8:	b3 82       	std	Z+3, r11	; 0x03
    90aa:	a2 82       	std	Z+2, r10	; 0x02
    90ac:	c6 01       	movw	r24, r12
    90ae:	b8 01       	movw	r22, r16
    90b0:	0e 94 7e 7d 	call	0xfafc	; 0xfafc <__divmodhi4>
    90b4:	75 83       	std	Z+5, r23	; 0x05
    90b6:	64 83       	std	Z+4, r22	; 0x04
    90b8:	26 83       	std	Z+6, r18	; 0x06
    90ba:	37 83       	std	Z+7, r19	; 0x07
    90bc:	0e 94 d5 7a 	call	0xf5aa	; 0xf5aa <sprintf>
		if(Val<0) {
    90c0:	ed b7       	in	r30, 0x3d	; 61
    90c2:	fe b7       	in	r31, 0x3e	; 62
    90c4:	38 96       	adiw	r30, 0x08	; 8
    90c6:	0f b6       	in	r0, 0x3f	; 63
    90c8:	f8 94       	cli
    90ca:	fe bf       	out	0x3e, r31	; 62
    90cc:	0f be       	out	0x3f, r0	; 63
    90ce:	ed bf       	out	0x3d, r30	; 61
    90d0:	d7 fc       	sbrc	r13, 7
    90d2:	3c c0       	rjmp	.+120    	; 0x914c <Put_sVal+0x186>
	}
	else {
		Format[4] = '\0';
		sprintf(Param->Pos, Format, Val);
	}
}
    90d4:	2a 96       	adiw	r28, 0x0a	; 10
    90d6:	0f b6       	in	r0, 0x3f	; 63
    90d8:	f8 94       	cli
    90da:	de bf       	out	0x3e, r29	; 62
    90dc:	0f be       	out	0x3f, r0	; 63
    90de:	cd bf       	out	0x3d, r28	; 61
    90e0:	cf 91       	pop	r28
    90e2:	df 91       	pop	r29
    90e4:	1f 91       	pop	r17
    90e6:	0f 91       	pop	r16
    90e8:	ff 90       	pop	r15
    90ea:	ef 90       	pop	r14
    90ec:	df 90       	pop	r13
    90ee:	cf 90       	pop	r12
    90f0:	bf 90       	pop	r11
    90f2:	af 90       	pop	r10
    90f4:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_sVal(int16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0x8000:0x80)+Val;
    90f6:	80 e0       	ldi	r24, 0x00	; 0
    90f8:	90 e8       	ldi	r25, 0x80	; 128
    90fa:	7e cf       	rjmp	.-260    	; 0x8ff8 <Put_sVal+0x32>
		PutEnum(Param);
		return;
	}
	char Format[] = "%+ d.%. u";
	if(Val==0)
		Format[1] = ' ';
    90fc:	80 e2       	ldi	r24, 0x20	; 32
    90fe:	8a 83       	std	Y+2, r24	; 0x02
	Format[2] = '0'+Param->Size;
    9100:	f7 01       	movw	r30, r14
    9102:	23 81       	ldd	r18, Z+3	; 0x03
    9104:	20 5d       	subi	r18, 0xD0	; 208
    9106:	2b 83       	std	Y+3, r18	; 0x03
	if(Param->Prec) {
    9108:	92 81       	ldd	r25, Z+2	; 0x02
    910a:	99 23       	and	r25, r25
    910c:	09 f0       	breq	.+2      	; 0x9110 <Put_sVal+0x14a>
    910e:	9a cf       	rjmp	.-204    	; 0x9044 <Put_sVal+0x7e>
				Param->Pos++;
			*Param->Pos = '-';
		}
	}
	else {
		Format[4] = '\0';
    9110:	1d 82       	std	Y+5, r1	; 0x05
		sprintf(Param->Pos, Format, Val);
    9112:	00 d0       	rcall	.+0      	; 0x9114 <Put_sVal+0x14e>
    9114:	00 d0       	rcall	.+0      	; 0x9116 <Put_sVal+0x150>
    9116:	ed b7       	in	r30, 0x3d	; 61
    9118:	fe b7       	in	r31, 0x3e	; 62
    911a:	31 96       	adiw	r30, 0x01	; 1
    911c:	d7 01       	movw	r26, r14
    911e:	8d 91       	ld	r24, X+
    9120:	9c 91       	ld	r25, X
    9122:	ad b7       	in	r26, 0x3d	; 61
    9124:	be b7       	in	r27, 0x3e	; 62
    9126:	12 96       	adiw	r26, 0x02	; 2
    9128:	9c 93       	st	X, r25
    912a:	8e 93       	st	-X, r24
    912c:	11 97       	sbiw	r26, 0x01	; 1
    912e:	b3 82       	std	Z+3, r11	; 0x03
    9130:	a2 82       	std	Z+2, r10	; 0x02
    9132:	d5 82       	std	Z+5, r13	; 0x05
    9134:	c4 82       	std	Z+4, r12	; 0x04
    9136:	0e 94 d5 7a 	call	0xf5aa	; 0xf5aa <sprintf>
    913a:	ed b7       	in	r30, 0x3d	; 61
    913c:	fe b7       	in	r31, 0x3e	; 62
    913e:	36 96       	adiw	r30, 0x06	; 6
    9140:	0f b6       	in	r0, 0x3f	; 63
    9142:	f8 94       	cli
    9144:	fe bf       	out	0x3e, r31	; 62
    9146:	0f be       	out	0x3f, r0	; 63
    9148:	ed bf       	out	0x3d, r30	; 61
    914a:	c4 cf       	rjmp	.-120    	; 0x90d4 <Put_sVal+0x10e>
		Format[2] -= Param->Prec+1;
		Format[7] = '0'+Param->Prec;
		int16_t Div=Pow10(Param->Prec);
		sprintf(Param->Pos, Format, Val/Div, (uint16_t)abs(Val)%Div);
		if(Val<0) {
			while(*Param->Pos==' ')
    914c:	d7 01       	movw	r26, r14
    914e:	ed 91       	ld	r30, X+
    9150:	fc 91       	ld	r31, X
    9152:	80 81       	ld	r24, Z
    9154:	80 32       	cpi	r24, 0x20	; 32
    9156:	39 f4       	brne	.+14     	; 0x9166 <Put_sVal+0x1a0>
				Param->Pos++;
    9158:	31 96       	adiw	r30, 0x01	; 1
    915a:	d7 01       	movw	r26, r14
    915c:	ed 93       	st	X+, r30
    915e:	fc 93       	st	X, r31
		Format[2] -= Param->Prec+1;
		Format[7] = '0'+Param->Prec;
		int16_t Div=Pow10(Param->Prec);
		sprintf(Param->Pos, Format, Val/Div, (uint16_t)abs(Val)%Div);
		if(Val<0) {
			while(*Param->Pos==' ')
    9160:	80 81       	ld	r24, Z
    9162:	80 32       	cpi	r24, 0x20	; 32
    9164:	c9 f3       	breq	.-14     	; 0x9158 <Put_sVal+0x192>
				Param->Pos++;
			*Param->Pos = '-';
    9166:	8d e2       	ldi	r24, 0x2D	; 45
    9168:	80 83       	st	Z, r24
    916a:	b4 cf       	rjmp	.-152    	; 0x90d4 <Put_sVal+0x10e>
void
Put_sVal(int16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0x8000:0x80)+Val;
	if(Param->Txt && Idx<2) {
		Param->Txt += Idx;
    916c:	88 0f       	add	r24, r24
    916e:	99 1f       	adc	r25, r25
    9170:	28 0f       	add	r18, r24
    9172:	39 1f       	adc	r19, r25
    9174:	15 96       	adiw	r26, 0x05	; 5
    9176:	3c 93       	st	X, r19
    9178:	2e 93       	st	-X, r18
    917a:	14 97       	sbiw	r26, 0x04	; 4
		PutEnum(Param);
    917c:	c7 01       	movw	r24, r14
    917e:	0e 94 c9 3f 	call	0x7f92	; 0x7f92 <PutEnum>
    9182:	a8 cf       	rjmp	.-176    	; 0x90d4 <Put_sVal+0x10e>
    9184:	88 27       	eor	r24, r24
    9186:	99 27       	eor	r25, r25
    9188:	8c 19       	sub	r24, r12
    918a:	9d 09       	sbc	r25, r13
    918c:	75 cf       	rjmp	.-278    	; 0x9078 <Put_sVal+0xb2>

0000918e <PutVal>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
PutVal(uint16_t Val, char Type, T_Param *Param)
{
    918e:	af 92       	push	r10
    9190:	bf 92       	push	r11
    9192:	cf 92       	push	r12
    9194:	df 92       	push	r13
    9196:	ef 92       	push	r14
    9198:	ff 92       	push	r15
    919a:	0f 93       	push	r16
    919c:	1f 93       	push	r17
    919e:	df 93       	push	r29
    91a0:	cf 93       	push	r28
    91a2:	cd b7       	in	r28, 0x3d	; 61
    91a4:	de b7       	in	r29, 0x3e	; 62
    91a6:	29 97       	sbiw	r28, 0x09	; 9
    91a8:	0f b6       	in	r0, 0x3f	; 63
    91aa:	f8 94       	cli
    91ac:	de bf       	out	0x3e, r29	; 62
    91ae:	0f be       	out	0x3f, r0	; 63
    91b0:	cd bf       	out	0x3d, r28	; 61
    91b2:	6c 01       	movw	r12, r24
    91b4:	7a 01       	movw	r14, r20
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
    91b6:	67 37       	cpi	r22, 0x77	; 119
    91b8:	09 f4       	brne	.+2      	; 0x91bc <PutVal+0x2e>
    91ba:	79 c0       	rjmp	.+242    	; 0x92ae <PutVal+0x120>
    91bc:	8f ef       	ldi	r24, 0xFF	; 255
    91be:	90 e0       	ldi	r25, 0x00	; 0
	if(Param->Txt && Idx<2) {
    91c0:	d7 01       	movw	r26, r14
    91c2:	14 96       	adiw	r26, 0x04	; 4
    91c4:	2d 91       	ld	r18, X+
    91c6:	3c 91       	ld	r19, X
    91c8:	15 97       	sbiw	r26, 0x05	; 5
    91ca:	21 15       	cp	r18, r1
    91cc:	31 05       	cpc	r19, r1
    91ce:	31 f0       	breq	.+12     	; 0x91dc <PutVal+0x4e>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
PutVal(uint16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
    91d0:	8c 19       	sub	r24, r12
    91d2:	9d 09       	sbc	r25, r13
	if(Param->Txt && Idx<2) {
    91d4:	82 30       	cpi	r24, 0x02	; 2
    91d6:	91 05       	cpc	r25, r1
    91d8:	08 f4       	brcc	.+2      	; 0x91dc <PutVal+0x4e>
    91da:	8a c0       	rjmp	.+276    	; 0x92f0 <PutVal+0x162>
		Param->Txt += Idx;
		PutEnum(Param);
		return;
	}
	char Format[] = "% u.%. u";
    91dc:	5e 01       	movw	r10, r28
    91de:	08 94       	sec
    91e0:	a1 1c       	adc	r10, r1
    91e2:	b1 1c       	adc	r11, r1
    91e4:	d5 01       	movw	r26, r10
    91e6:	e6 e9       	ldi	r30, 0x96	; 150
    91e8:	f2 e0       	ldi	r31, 0x02	; 2
    91ea:	89 e0       	ldi	r24, 0x09	; 9
    91ec:	01 90       	ld	r0, Z+
    91ee:	0d 92       	st	X+, r0
    91f0:	81 50       	subi	r24, 0x01	; 1
    91f2:	e1 f7       	brne	.-8      	; 0x91ec <PutVal+0x5e>
	Format[1] = '0'+Param->Size;
    91f4:	f7 01       	movw	r30, r14
    91f6:	23 81       	ldd	r18, Z+3	; 0x03
    91f8:	20 5d       	subi	r18, 0xD0	; 208
    91fa:	2a 83       	std	Y+2, r18	; 0x02
	if(Param->Prec) {
    91fc:	92 81       	ldd	r25, Z+2	; 0x02
    91fe:	99 23       	and	r25, r25
    9200:	09 f4       	brne	.+2      	; 0x9204 <PutVal+0x76>
    9202:	58 c0       	rjmp	.+176    	; 0x92b4 <PutVal+0x126>
		Format[1] -= Param->Prec+1;
    9204:	89 2f       	mov	r24, r25
    9206:	80 95       	com	r24
    9208:	82 0f       	add	r24, r18
    920a:	8a 83       	std	Y+2, r24	; 0x02
		Format[6] = '0'+Param->Prec;
    920c:	90 5d       	subi	r25, 0xD0	; 208
    920e:	9f 83       	std	Y+7, r25	; 0x07
    9210:	90 53       	subi	r25, 0x30	; 48
		uint16_t Div=Pow10(Param->Prec);
    9212:	29 2f       	mov	r18, r25
    9214:	01 e0       	ldi	r16, 0x01	; 1
    9216:	10 e0       	ldi	r17, 0x00	; 0
		Pow *= 10;
    9218:	c8 01       	movw	r24, r16
    921a:	88 0f       	add	r24, r24
    921c:	99 1f       	adc	r25, r25
    921e:	00 0f       	add	r16, r16
    9220:	11 1f       	adc	r17, r17
    9222:	00 0f       	add	r16, r16
    9224:	11 1f       	adc	r17, r17
    9226:	00 0f       	add	r16, r16
    9228:	11 1f       	adc	r17, r17
    922a:	08 0f       	add	r16, r24
    922c:	19 1f       	adc	r17, r25
    922e:	21 50       	subi	r18, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    9230:	99 f7       	brne	.-26     	; 0x9218 <PutVal+0x8a>
    9232:	c6 01       	movw	r24, r12
    9234:	b8 01       	movw	r22, r16
    9236:	0e 94 6a 7d 	call	0xfad4	; 0xfad4 <__udivmodhi4>
    923a:	9c 01       	movw	r18, r24
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
    923c:	8d b7       	in	r24, 0x3d	; 61
    923e:	9e b7       	in	r25, 0x3e	; 62
    9240:	08 97       	sbiw	r24, 0x08	; 8
    9242:	0f b6       	in	r0, 0x3f	; 63
    9244:	f8 94       	cli
    9246:	9e bf       	out	0x3e, r25	; 62
    9248:	0f be       	out	0x3f, r0	; 63
    924a:	8d bf       	out	0x3d, r24	; 61
    924c:	ed b7       	in	r30, 0x3d	; 61
    924e:	fe b7       	in	r31, 0x3e	; 62
    9250:	31 96       	adiw	r30, 0x01	; 1
    9252:	d7 01       	movw	r26, r14
    9254:	8d 91       	ld	r24, X+
    9256:	9c 91       	ld	r25, X
    9258:	ad b7       	in	r26, 0x3d	; 61
    925a:	be b7       	in	r27, 0x3e	; 62
    925c:	12 96       	adiw	r26, 0x02	; 2
    925e:	9c 93       	st	X, r25
    9260:	8e 93       	st	-X, r24
    9262:	11 97       	sbiw	r26, 0x01	; 1
    9264:	b3 82       	std	Z+3, r11	; 0x03
    9266:	a2 82       	std	Z+2, r10	; 0x02
    9268:	c6 01       	movw	r24, r12
    926a:	b8 01       	movw	r22, r16
    926c:	0e 94 6a 7d 	call	0xfad4	; 0xfad4 <__udivmodhi4>
    9270:	75 83       	std	Z+5, r23	; 0x05
    9272:	64 83       	std	Z+4, r22	; 0x04
    9274:	26 83       	std	Z+6, r18	; 0x06
    9276:	37 83       	std	Z+7, r19	; 0x07
    9278:	0e 94 d5 7a 	call	0xf5aa	; 0xf5aa <sprintf>
    927c:	ed b7       	in	r30, 0x3d	; 61
    927e:	fe b7       	in	r31, 0x3e	; 62
    9280:	38 96       	adiw	r30, 0x08	; 8
    9282:	0f b6       	in	r0, 0x3f	; 63
    9284:	f8 94       	cli
    9286:	fe bf       	out	0x3e, r31	; 62
    9288:	0f be       	out	0x3f, r0	; 63
    928a:	ed bf       	out	0x3d, r30	; 61
	}
	else {
		Format[3] = '\0';
		sprintf(Param->Pos, Format, Val);
	}
}
    928c:	29 96       	adiw	r28, 0x09	; 9
    928e:	0f b6       	in	r0, 0x3f	; 63
    9290:	f8 94       	cli
    9292:	de bf       	out	0x3e, r29	; 62
    9294:	0f be       	out	0x3f, r0	; 63
    9296:	cd bf       	out	0x3d, r28	; 61
    9298:	cf 91       	pop	r28
    929a:	df 91       	pop	r29
    929c:	1f 91       	pop	r17
    929e:	0f 91       	pop	r16
    92a0:	ff 90       	pop	r15
    92a2:	ef 90       	pop	r14
    92a4:	df 90       	pop	r13
    92a6:	cf 90       	pop	r12
    92a8:	bf 90       	pop	r11
    92aa:	af 90       	pop	r10
    92ac:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
PutVal(uint16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
    92ae:	8f ef       	ldi	r24, 0xFF	; 255
    92b0:	9f ef       	ldi	r25, 0xFF	; 255
    92b2:	86 cf       	rjmp	.-244    	; 0x91c0 <PutVal+0x32>
		Format[6] = '0'+Param->Prec;
		uint16_t Div=Pow10(Param->Prec);
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
	}
	else {
		Format[3] = '\0';
    92b4:	1c 82       	std	Y+4, r1	; 0x04
		sprintf(Param->Pos, Format, Val);
    92b6:	00 d0       	rcall	.+0      	; 0x92b8 <PutVal+0x12a>
    92b8:	00 d0       	rcall	.+0      	; 0x92ba <PutVal+0x12c>
    92ba:	ed b7       	in	r30, 0x3d	; 61
    92bc:	fe b7       	in	r31, 0x3e	; 62
    92be:	31 96       	adiw	r30, 0x01	; 1
    92c0:	d7 01       	movw	r26, r14
    92c2:	8d 91       	ld	r24, X+
    92c4:	9c 91       	ld	r25, X
    92c6:	ad b7       	in	r26, 0x3d	; 61
    92c8:	be b7       	in	r27, 0x3e	; 62
    92ca:	12 96       	adiw	r26, 0x02	; 2
    92cc:	9c 93       	st	X, r25
    92ce:	8e 93       	st	-X, r24
    92d0:	11 97       	sbiw	r26, 0x01	; 1
    92d2:	b3 82       	std	Z+3, r11	; 0x03
    92d4:	a2 82       	std	Z+2, r10	; 0x02
    92d6:	d5 82       	std	Z+5, r13	; 0x05
    92d8:	c4 82       	std	Z+4, r12	; 0x04
    92da:	0e 94 d5 7a 	call	0xf5aa	; 0xf5aa <sprintf>
    92de:	ed b7       	in	r30, 0x3d	; 61
    92e0:	fe b7       	in	r31, 0x3e	; 62
    92e2:	36 96       	adiw	r30, 0x06	; 6
    92e4:	0f b6       	in	r0, 0x3f	; 63
    92e6:	f8 94       	cli
    92e8:	fe bf       	out	0x3e, r31	; 62
    92ea:	0f be       	out	0x3f, r0	; 63
    92ec:	ed bf       	out	0x3d, r30	; 61
    92ee:	ce cf       	rjmp	.-100    	; 0x928c <PutVal+0xfe>
void
PutVal(uint16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
	if(Param->Txt && Idx<2) {
		Param->Txt += Idx;
    92f0:	88 0f       	add	r24, r24
    92f2:	99 1f       	adc	r25, r25
    92f4:	28 0f       	add	r18, r24
    92f6:	39 1f       	adc	r19, r25
    92f8:	15 96       	adiw	r26, 0x05	; 5
    92fa:	3c 93       	st	X, r19
    92fc:	2e 93       	st	-X, r18
    92fe:	14 97       	sbiw	r26, 0x04	; 4
		PutEnum(Param);
    9300:	c7 01       	movw	r24, r14
    9302:	0e 94 c9 3f 	call	0x7f92	; 0x7f92 <PutEnum>
    9306:	c2 cf       	rjmp	.-124    	; 0x928c <PutVal+0xfe>

00009308 <GSM_Wait_Response_P>:
//	}
	if(strcmp(GSM_RxStr, Str))return 0;
	else return 1;
}
// ~~~~~~~~~
uint8_t GSM_Wait_Response_P(prog_char *Str_P, uint8_t RestoreCMD){
    9308:	1f 93       	push	r17
    930a:	cf 93       	push	r28
    930c:	df 93       	push	r29
    930e:	ec 01       	movw	r28, r24
    9310:	16 2f       	mov	r17, r22
	
	if(Timer16Stopp(TD_GSM) && RestoreCMD){
    9312:	80 91 e0 04 	lds	r24, 0x04E0
    9316:	0e 94 41 1b 	call	0x3682	; 0x3682 <Timer16Stopp>
    931a:	88 23       	and	r24, r24
    931c:	11 f0       	breq	.+4      	; 0x9322 <GSM_Wait_Response_P+0x1a>
    931e:	11 23       	and	r17, r17
    9320:	51 f4       	brne	.+20     	; 0x9336 <GSM_Wait_Response_P+0x2e>
		GSM_State = RestoreCMD;
		return 0;
	}
	//  
	if(GetStringFromFIFO()){
    9322:	0e 94 b3 37 	call	0x6f66	; 0x6f66 <GetStringFromFIFO>
    9326:	88 23       	and	r24, r24
    9328:	71 f4       	brne	.+28     	; 0x9346 <GSM_Wait_Response_P+0x3e>
    932a:	20 e0       	ldi	r18, 0x00	; 0
		if(strcmp_P(GSM_RxStr, Str_P)) return 0;
		else return 1;
	}
	else return 0;
}
    932c:	82 2f       	mov	r24, r18
    932e:	df 91       	pop	r29
    9330:	cf 91       	pop	r28
    9332:	1f 91       	pop	r17
    9334:	08 95       	ret
}
// ~~~~~~~~~
uint8_t GSM_Wait_Response_P(prog_char *Str_P, uint8_t RestoreCMD){
	
	if(Timer16Stopp(TD_GSM) && RestoreCMD){
		GSM_State = RestoreCMD;
    9336:	10 93 ac 06 	sts	0x06AC, r17
    933a:	20 e0       	ldi	r18, 0x00	; 0
	if(GetStringFromFIFO()){
		if(strcmp_P(GSM_RxStr, Str_P)) return 0;
		else return 1;
	}
	else return 0;
}
    933c:	82 2f       	mov	r24, r18
    933e:	df 91       	pop	r29
    9340:	cf 91       	pop	r28
    9342:	1f 91       	pop	r17
    9344:	08 95       	ret
		GSM_State = RestoreCMD;
		return 0;
	}
	//  
	if(GetStringFromFIFO()){
		if(strcmp_P(GSM_RxStr, Str_P)) return 0;
    9346:	8f e8       	ldi	r24, 0x8F	; 143
    9348:	97 e0       	ldi	r25, 0x07	; 7
    934a:	be 01       	movw	r22, r28
    934c:	0e 94 d9 79 	call	0xf3b2	; 0xf3b2 <strcmp_P>
    9350:	20 e0       	ldi	r18, 0x00	; 0
    9352:	89 2b       	or	r24, r25
    9354:	59 f7       	brne	.-42     	; 0x932c <GSM_Wait_Response_P+0x24>
    9356:	21 e0       	ldi	r18, 0x01	; 1
		else return 1;
	}
	else return 0;
}
    9358:	82 2f       	mov	r24, r18
    935a:	df 91       	pop	r29
    935c:	cf 91       	pop	r28
    935e:	1f 91       	pop	r17
    9360:	08 95       	ret

00009362 <GSM_SendCR>:
	
	sei();	
}
// ~~~~~~~~~
//   + CR
void GSM_SendCR(prog_char *Str_P){
    9362:	ef 92       	push	r14
    9364:	ff 92       	push	r15
    9366:	0f 93       	push	r16
    9368:	1f 93       	push	r17
    936a:	7c 01       	movw	r14, r24
	GSMTxSz = strlen_P(Str_P);
    936c:	0e 94 e9 79 	call	0xf3d2	; 0xf3d2 <strlen_P>
    9370:	80 93 6b 07 	sts	0x076B, r24
	sprintf_P(GSM_TxStr, Str_P);
    9374:	00 d0       	rcall	.+0      	; 0x9376 <GSM_SendCR+0x14>
    9376:	0f 92       	push	r0
    9378:	08 ef       	ldi	r16, 0xF8	; 248
    937a:	19 e0       	ldi	r17, 0x09	; 9
    937c:	ed b7       	in	r30, 0x3d	; 61
    937e:	fe b7       	in	r31, 0x3e	; 62
    9380:	12 83       	std	Z+2, r17	; 0x02
    9382:	01 83       	std	Z+1, r16	; 0x01
    9384:	f4 82       	std	Z+4, r15	; 0x04
    9386:	e3 82       	std	Z+3, r14	; 0x03
    9388:	0e 94 06 7b 	call	0xf60c	; 0xf60c <sprintf_P>
	sprintf(GSM_TxStr + GSMTxSz, "\r");
    938c:	80 91 6b 07 	lds	r24, 0x076B
    9390:	08 0f       	add	r16, r24
    9392:	11 1d       	adc	r17, r1
    9394:	8d e0       	ldi	r24, 0x0D	; 13
    9396:	90 e0       	ldi	r25, 0x00	; 0
    9398:	f8 01       	movw	r30, r16
    939a:	91 83       	std	Z+1, r25	; 0x01
    939c:	80 83       	st	Z, r24
	GSMTxSz++;
    939e:	80 91 6b 07 	lds	r24, 0x076B
    93a2:	8f 5f       	subi	r24, 0xFF	; 255
    93a4:	80 93 6b 07 	sts	0x076B, r24
	GSM_SendFirstChar();
    93a8:	0f 90       	pop	r0
    93aa:	0f 90       	pop	r0
    93ac:	0f 90       	pop	r0
    93ae:	0f 90       	pop	r0
    93b0:	0e 94 dd 38 	call	0x71ba	; 0x71ba <GSM_SendFirstChar>
}
    93b4:	1f 91       	pop	r17
    93b6:	0f 91       	pop	r16
    93b8:	ff 90       	pop	r15
    93ba:	ef 90       	pop	r14
    93bc:	08 95       	ret

000093be <GSM_Execute_Command>:
	GSMTxSz = Size;
	memcpy(GSM_TxStr, Data_Out, GSMTxSz);
	GSM_SendFirstChar();
}
// ~~~~~~~~~
void GSM_Execute_Command(prog_char *Str_P, uint16_t Timeout){
    93be:	cf 93       	push	r28
    93c0:	df 93       	push	r29
    93c2:	9c 01       	movw	r18, r24
    93c4:	eb 01       	movw	r28, r22
	if(GSM_Flag & (1<<flg_TxCStr)){
    93c6:	80 91 cf 02 	lds	r24, 0x02CF
    93ca:	80 ff       	sbrs	r24, 0
    93cc:	08 c0       	rjmp	.+16     	; 0x93de <GSM_Execute_Command+0x20>
		GSM_SendCR(Str_P);
    93ce:	c9 01       	movw	r24, r18
    93d0:	0e 94 b1 49 	call	0x9362	; 0x9362 <GSM_SendCR>
		StartTimer16(TD_GSM, Timeout);
    93d4:	80 91 e0 04 	lds	r24, 0x04E0
    93d8:	be 01       	movw	r22, r28
    93da:	0e 94 05 1a 	call	0x340a	; 0x340a <StartTimer16>
	}
}
    93de:	df 91       	pop	r29
    93e0:	cf 91       	pop	r28
    93e2:	08 95       	ret

000093e4 <GSM_Wait_Response>:
	#endif

}
// ~~~~~~~~~
//   GetStringFromFIFO()!
uint8_t GSM_Wait_Response(char *Str, uint8_t RestoreCMD){
    93e4:	bc 01       	movw	r22, r24
//	if(Timer16Stopp(TD_GSM) && RestoreCMD){
//		GSM_State = RestoreCMD;
//		return 0;
//	}
	if(strcmp(GSM_RxStr, Str))return 0;
    93e6:	8f e8       	ldi	r24, 0x8F	; 143
    93e8:	97 e0       	ldi	r25, 0x07	; 7
    93ea:	0e 94 39 7a 	call	0xf472	; 0xf472 <strcmp>
    93ee:	9c 01       	movw	r18, r24
    93f0:	80 e0       	ldi	r24, 0x00	; 0
    93f2:	23 2b       	or	r18, r19
    93f4:	09 f4       	brne	.+2      	; 0x93f8 <GSM_Wait_Response+0x14>
    93f6:	81 e0       	ldi	r24, 0x01	; 1
	else return 1;
}
    93f8:	08 95       	ret

000093fa <DigiFilt>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
DigiFilt(const uint16_t *Array, uint8_t Edge)
{
    93fa:	6f 92       	push	r6
    93fc:	7f 92       	push	r7
    93fe:	8f 92       	push	r8
    9400:	9f 92       	push	r9
    9402:	bf 92       	push	r11
    9404:	cf 92       	push	r12
    9406:	df 92       	push	r13
    9408:	ef 92       	push	r14
    940a:	ff 92       	push	r15
    940c:	0f 93       	push	r16
    940e:	1f 93       	push	r17
    9410:	df 93       	push	r29
    9412:	cf 93       	push	r28
    9414:	cd b7       	in	r28, 0x3d	; 61
    9416:	de b7       	in	r29, 0x3e	; 62
    9418:	28 2f       	mov	r18, r24
    941a:	79 2f       	mov	r23, r25
    941c:	e6 2e       	mov	r14, r22
				Buf[i] = Buf[j];
				Buf[j] = Swap;
			}
	for(i=Edge; i<_Edge; Sum+=Buf[i++]);
	return Sum/(Edge*2);
}
    941e:	6d b6       	in	r6, 0x3d	; 61
    9420:	7e b6       	in	r7, 0x3e	; 62

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
DigiFilt(const uint16_t *Array, uint8_t Edge)
{
	uint8_t Sz = Edge*4;
    9422:	86 2e       	mov	r8, r22
    9424:	99 24       	eor	r9, r9
    9426:	f6 2e       	mov	r15, r22
    9428:	ff 0c       	add	r15, r15
    942a:	ff 0c       	add	r15, r15
	uint8_t _Edge = Sz-Edge;
    942c:	bf 2c       	mov	r11, r15
    942e:	b6 1a       	sub	r11, r22
	uint16_t Buf[Sz];
    9430:	ef 2d       	mov	r30, r15
    9432:	f0 e0       	ldi	r31, 0x00	; 0
    9434:	ee 0f       	add	r30, r30
    9436:	ff 1f       	adc	r31, r31
    9438:	8d b7       	in	r24, 0x3d	; 61
    943a:	9e b7       	in	r25, 0x3e	; 62
    943c:	8e 1b       	sub	r24, r30
    943e:	9f 0b       	sbc	r25, r31
    9440:	0f b6       	in	r0, 0x3f	; 63
    9442:	f8 94       	cli
    9444:	9e bf       	out	0x3e, r25	; 62
    9446:	0f be       	out	0x3f, r0	; 63
    9448:	8d bf       	out	0x3d, r24	; 61
    944a:	0d b7       	in	r16, 0x3d	; 61
    944c:	1e b7       	in	r17, 0x3e	; 62
    944e:	0f 5f       	subi	r16, 0xFF	; 255
    9450:	1f 4f       	sbci	r17, 0xFF	; 255
	uint32_t Sum = 0;
	uint16_t Swap;
	uint8_t i, j;
	memcpy(Buf, Array, Sz*2);
    9452:	c8 01       	movw	r24, r16
    9454:	62 2f       	mov	r22, r18
    9456:	af 01       	movw	r20, r30
    9458:	0e 94 25 7a 	call	0xf44a	; 0xf44a <memcpy>
	for(i=0; i<Edge; i++)
    945c:	ee 20       	and	r14, r14
    945e:	09 f1       	breq	.+66     	; 0x94a2 <DigiFilt+0xa8>
    9460:	d8 01       	movw	r26, r16
    9462:	80 e0       	ldi	r24, 0x00	; 0
		for(j=i+1; j<Sz; j++)
    9464:	58 2f       	mov	r21, r24
    9466:	5f 5f       	subi	r21, 0xFF	; 255
    9468:	5f 15       	cp	r21, r15
    946a:	b8 f4       	brcc	.+46     	; 0x949a <DigiFilt+0xa0>
    946c:	45 2f       	mov	r20, r21
			if(Buf[j] < Buf[i]) {
    946e:	e4 2f       	mov	r30, r20
    9470:	f0 e0       	ldi	r31, 0x00	; 0
    9472:	ee 0f       	add	r30, r30
    9474:	ff 1f       	adc	r31, r31
    9476:	e0 0f       	add	r30, r16
    9478:	f1 1f       	adc	r31, r17
    947a:	20 81       	ld	r18, Z
    947c:	31 81       	ldd	r19, Z+1	; 0x01
    947e:	8d 91       	ld	r24, X+
    9480:	9c 91       	ld	r25, X
    9482:	11 97       	sbiw	r26, 0x01	; 1
    9484:	28 17       	cp	r18, r24
    9486:	39 07       	cpc	r19, r25
    9488:	28 f4       	brcc	.+10     	; 0x9494 <DigiFilt+0x9a>
				Swap = Buf[i];
				Buf[i] = Buf[j];
    948a:	11 96       	adiw	r26, 0x01	; 1
    948c:	3c 93       	st	X, r19
    948e:	2e 93       	st	-X, r18
				Buf[j] = Swap;
    9490:	91 83       	std	Z+1, r25	; 0x01
    9492:	80 83       	st	Z, r24
	uint32_t Sum = 0;
	uint16_t Swap;
	uint8_t i, j;
	memcpy(Buf, Array, Sz*2);
	for(i=0; i<Edge; i++)
		for(j=i+1; j<Sz; j++)
    9494:	4f 5f       	subi	r20, 0xFF	; 255
    9496:	4f 15       	cp	r20, r15
    9498:	50 f3       	brcs	.-44     	; 0x946e <DigiFilt+0x74>
    949a:	12 96       	adiw	r26, 0x02	; 2
    949c:	85 2f       	mov	r24, r21
	uint16_t Buf[Sz];
	uint32_t Sum = 0;
	uint16_t Swap;
	uint8_t i, j;
	memcpy(Buf, Array, Sz*2);
	for(i=0; i<Edge; i++)
    949e:	5e 15       	cp	r21, r14
    94a0:	08 f3       	brcs	.-62     	; 0x9464 <DigiFilt+0x6a>
			if(Buf[j] < Buf[i]) {
				Swap = Buf[i];
				Buf[i] = Buf[j];
				Buf[j] = Swap;
			}
	for(i=Sz-1; i>=_Edge; i--)
    94a2:	ef 2d       	mov	r30, r15
    94a4:	e1 50       	subi	r30, 0x01	; 1
    94a6:	eb 15       	cp	r30, r11
    94a8:	10 f1       	brcs	.+68     	; 0x94ee <DigiFilt+0xf4>
		for(j=i-1; j>=Edge; j--)
    94aa:	5e 2f       	mov	r21, r30
    94ac:	51 50       	subi	r21, 0x01	; 1
    94ae:	5e 15       	cp	r21, r14
    94b0:	d8 f0       	brcs	.+54     	; 0x94e8 <DigiFilt+0xee>
    94b2:	f0 e0       	ldi	r31, 0x00	; 0
    94b4:	45 2f       	mov	r20, r21
    94b6:	ee 0f       	add	r30, r30
    94b8:	ff 1f       	adc	r31, r31
			if(Buf[j] > Buf[i]) {
    94ba:	e0 0f       	add	r30, r16
    94bc:	f1 1f       	adc	r31, r17
    94be:	a4 2f       	mov	r26, r20
    94c0:	b0 e0       	ldi	r27, 0x00	; 0
    94c2:	aa 0f       	add	r26, r26
    94c4:	bb 1f       	adc	r27, r27
    94c6:	a0 0f       	add	r26, r16
    94c8:	b1 1f       	adc	r27, r17
    94ca:	2d 91       	ld	r18, X+
    94cc:	3c 91       	ld	r19, X
    94ce:	11 97       	sbiw	r26, 0x01	; 1
    94d0:	80 81       	ld	r24, Z
    94d2:	91 81       	ldd	r25, Z+1	; 0x01
    94d4:	82 17       	cp	r24, r18
    94d6:	93 07       	cpc	r25, r19
    94d8:	20 f4       	brcc	.+8      	; 0x94e2 <DigiFilt+0xe8>
				Swap = Buf[i];
				Buf[i] = Buf[j];
    94da:	31 83       	std	Z+1, r19	; 0x01
    94dc:	20 83       	st	Z, r18
				Buf[j] = Swap;
    94de:	8d 93       	st	X+, r24
    94e0:	9c 93       	st	X, r25
				Swap = Buf[i];
				Buf[i] = Buf[j];
				Buf[j] = Swap;
			}
	for(i=Sz-1; i>=_Edge; i--)
		for(j=i-1; j>=Edge; j--)
    94e2:	41 50       	subi	r20, 0x01	; 1
    94e4:	4e 15       	cp	r20, r14
    94e6:	58 f7       	brcc	.-42     	; 0x94be <DigiFilt+0xc4>
    94e8:	e5 2f       	mov	r30, r21
			if(Buf[j] < Buf[i]) {
				Swap = Buf[i];
				Buf[i] = Buf[j];
				Buf[j] = Swap;
			}
	for(i=Sz-1; i>=_Edge; i--)
    94ea:	5b 15       	cp	r21, r11
    94ec:	f0 f6       	brcc	.-68     	; 0x94aa <DigiFilt+0xb0>
			if(Buf[j] > Buf[i]) {
				Swap = Buf[i];
				Buf[i] = Buf[j];
				Buf[j] = Swap;
			}
	for(i=Edge; i<_Edge; Sum+=Buf[i++]);
    94ee:	eb 14       	cp	r14, r11
    94f0:	a0 f5       	brcc	.+104    	; 0x955a <DigiFilt+0x160>
    94f2:	6e 2d       	mov	r22, r14
    94f4:	cc 24       	eor	r12, r12
    94f6:	dd 24       	eor	r13, r13
    94f8:	76 01       	movw	r14, r12
    94fa:	e6 2f       	mov	r30, r22
    94fc:	f0 e0       	ldi	r31, 0x00	; 0
    94fe:	ee 0f       	add	r30, r30
    9500:	ff 1f       	adc	r31, r31
    9502:	e0 0f       	add	r30, r16
    9504:	f1 1f       	adc	r31, r17
    9506:	80 81       	ld	r24, Z
    9508:	91 81       	ldd	r25, Z+1	; 0x01
    950a:	a0 e0       	ldi	r26, 0x00	; 0
    950c:	b0 e0       	ldi	r27, 0x00	; 0
    950e:	c8 0e       	add	r12, r24
    9510:	d9 1e       	adc	r13, r25
    9512:	ea 1e       	adc	r14, r26
    9514:	fb 1e       	adc	r15, r27
    9516:	6f 5f       	subi	r22, 0xFF	; 255
    9518:	6b 15       	cp	r22, r11
    951a:	78 f3       	brcs	.-34     	; 0x94fa <DigiFilt+0x100>
    951c:	88 0c       	add	r8, r8
    951e:	99 1c       	adc	r9, r9
    9520:	94 01       	movw	r18, r8
    9522:	44 27       	eor	r20, r20
    9524:	37 fd       	sbrc	r19, 7
    9526:	40 95       	com	r20
    9528:	54 2f       	mov	r21, r20
    952a:	c7 01       	movw	r24, r14
    952c:	b6 01       	movw	r22, r12
    952e:	0e 94 91 7d 	call	0xfb22	; 0xfb22 <__udivmodsi4>
    9532:	c9 01       	movw	r24, r18
	return Sum/(Edge*2);
}
    9534:	0f b6       	in	r0, 0x3f	; 63
    9536:	f8 94       	cli
    9538:	7e be       	out	0x3e, r7	; 62
    953a:	0f be       	out	0x3f, r0	; 63
    953c:	6d be       	out	0x3d, r6	; 61
    953e:	cf 91       	pop	r28
    9540:	df 91       	pop	r29
    9542:	1f 91       	pop	r17
    9544:	0f 91       	pop	r16
    9546:	ff 90       	pop	r15
    9548:	ef 90       	pop	r14
    954a:	df 90       	pop	r13
    954c:	cf 90       	pop	r12
    954e:	bf 90       	pop	r11
    9550:	9f 90       	pop	r9
    9552:	8f 90       	pop	r8
    9554:	7f 90       	pop	r7
    9556:	6f 90       	pop	r6
    9558:	08 95       	ret
			if(Buf[j] > Buf[i]) {
				Swap = Buf[i];
				Buf[i] = Buf[j];
				Buf[j] = Swap;
			}
	for(i=Edge; i<_Edge; Sum+=Buf[i++]);
    955a:	cc 24       	eor	r12, r12
    955c:	dd 24       	eor	r13, r13
    955e:	76 01       	movw	r14, r12
    9560:	dd cf       	rjmp	.-70     	; 0x951c <DigiFilt+0x122>

00009562 <MemFailReset>:

// ~~~~~~~~~~~~~~~
void
MemFailReset(void)
{
	if (MemFail &(1<<MemFail_EEPROM)) {
    9562:	80 91 c5 08 	lds	r24, 0x08C5
    9566:	81 ff       	sbrs	r24, 1
    9568:	08 95       	ret
		MemFail &=~(1<<MemFail_EEPROM);
    956a:	8d 7f       	andi	r24, 0xFD	; 253
    956c:	80 93 c5 08 	sts	0x08C5, r24
		eeprom_write_word(&MemCheck_stor.CRC_EEPROM_stor, CRC_EEPROM_calc());
    9570:	0e 94 e0 18 	call	0x31c0	; 0x31c0 <CRC_EEPROM_calc>
    9574:	bc 01       	movw	r22, r24
    9576:	8a e3       	ldi	r24, 0x3A	; 58
    9578:	91 e0       	ldi	r25, 0x01	; 1
    957a:	0e 94 37 7d 	call	0xfa6e	; 0xfa6e <__eewr_word_m2560>
    957e:	08 95       	ret

00009580 <Key_Mem>:
		MenuPage Menu_BackUp = { SetMenu(Menu_BackUp_List), 1, NULL,
				NULL, NULL, NULL, Menu_BackUp_Enter, NULL, NULL, NULL};
#endif

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t Key_Mem(void) {if(CurrLine==3) MemFailReset(); return StandartKey;}
    9580:	80 91 79 07 	lds	r24, 0x0779
    9584:	83 30       	cpi	r24, 0x03	; 3
    9586:	11 f0       	breq	.+4      	; 0x958c <Key_Mem+0xc>
    9588:	80 e0       	ldi	r24, 0x00	; 0
    958a:	08 95       	ret
    958c:	0e 94 b1 4a 	call	0x9562	; 0x9562 <MemFailReset>
    9590:	80 e0       	ldi	r24, 0x00	; 0
    9592:	08 95       	ret

00009594 <CRC_EEPROM_upd>:
// ~~~~~~~~~~~~~~~~~
// Duration: 48 ms
static void
CRC_EEPROM_upd(void)
{
	if (!(MemFail &(1<<MemFail_EEPROM)))
    9594:	80 91 c5 08 	lds	r24, 0x08C5
    9598:	81 fd       	sbrc	r24, 1
    959a:	08 95       	ret
		eeprom_write_word(&MemCheck_stor.CRC_EEPROM_stor, CRC_EEPROM_calc());
    959c:	0e 94 e0 18 	call	0x31c0	; 0x31c0 <CRC_EEPROM_calc>
    95a0:	bc 01       	movw	r22, r24
    95a2:	8a e3       	ldi	r24, 0x3A	; 58
    95a4:	91 e0       	ldi	r25, 0x01	; 1
    95a6:	0e 94 37 7d 	call	0xfa6e	; 0xfa6e <__eewr_word_m2560>
    95aa:	08 95       	ret

000095ac <ewb>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ewb(uint8_t *addr, uint8_t val)
{
	//IntOff();
	eeprom_write_byte(addr, val);
    95ac:	0e 94 21 7d 	call	0xfa42	; 0xfa42 <__eewr_byte_m2560>
	CRC_EEPROM_upd();
    95b0:	0e 94 ca 4a 	call	0x9594	; 0x9594 <CRC_EEPROM_upd>
	//IntOn();
}
    95b4:	08 95       	ret

000095b6 <MB_M_TimeOff_Set>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_M_TimeOff_Set(uint8_t MB_N)
{
	ewb(&MB_M_Param_EE[MB_N].TimeOff, MB_M_TimeOff[MB_N]);
    95b6:	e8 2f       	mov	r30, r24
    95b8:	f0 e0       	ldi	r31, 0x00	; 0
    95ba:	cf 01       	movw	r24, r30
    95bc:	88 0f       	add	r24, r24
    95be:	99 1f       	adc	r25, r25
    95c0:	88 0f       	add	r24, r24
    95c2:	99 1f       	adc	r25, r25
    95c4:	8e 0f       	add	r24, r30
    95c6:	9f 1f       	adc	r25, r31
    95c8:	ea 52       	subi	r30, 0x2A	; 42
    95ca:	fa 4f       	sbci	r31, 0xFA	; 250
    95cc:	8a 5c       	subi	r24, 0xCA	; 202
    95ce:	9e 4f       	sbci	r25, 0xFE	; 254
    95d0:	60 81       	ld	r22, Z
    95d2:	0e 94 d6 4a 	call	0x95ac	; 0x95ac <ewb>
}
    95d6:	08 95       	ret

000095d8 <MB_M_Try_Set>:

// ~~~~~~~~~~~~~~~~~~~~~~~
void
MB_M_Try_Set(uint8_t MB_N)
{
	ewb(&MB_M_Param_EE[MB_N].Try, MB_M_Try[MB_N]);
    95d8:	e8 2f       	mov	r30, r24
    95da:	f0 e0       	ldi	r31, 0x00	; 0
    95dc:	cf 01       	movw	r24, r30
    95de:	88 0f       	add	r24, r24
    95e0:	99 1f       	adc	r25, r25
    95e2:	88 0f       	add	r24, r24
    95e4:	99 1f       	adc	r25, r25
    95e6:	8e 0f       	add	r24, r30
    95e8:	9f 1f       	adc	r25, r31
    95ea:	ef 50       	subi	r30, 0x0F	; 15
    95ec:	f9 4f       	sbci	r31, 0xF9	; 249
    95ee:	8b 5c       	subi	r24, 0xCB	; 203
    95f0:	9e 4f       	sbci	r25, 0xFE	; 254
    95f2:	60 81       	ld	r22, Z
    95f4:	0e 94 d6 4a 	call	0x95ac	; 0x95ac <ewb>
}
    95f8:	08 95       	ret

000095fa <MB_M_Timeout_Set>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_M_Timeout_Set(uint8_t MB_N)
{
	ewb(&MB_M_Param_EE[MB_N].Timeout, MB_M_Timeout[MB_N]);
    95fa:	e8 2f       	mov	r30, r24
    95fc:	f0 e0       	ldi	r31, 0x00	; 0
    95fe:	cf 01       	movw	r24, r30
    9600:	88 0f       	add	r24, r24
    9602:	99 1f       	adc	r25, r25
    9604:	88 0f       	add	r24, r24
    9606:	99 1f       	adc	r25, r25
    9608:	8e 0f       	add	r24, r30
    960a:	9f 1f       	adc	r25, r31
    960c:	e9 52       	subi	r30, 0x29	; 41
    960e:	f7 4f       	sbci	r31, 0xF7	; 247
    9610:	8c 5c       	subi	r24, 0xCC	; 204
    9612:	9e 4f       	sbci	r25, 0xFE	; 254
    9614:	60 81       	ld	r22, Z
    9616:	0e 94 d6 4a 	call	0x95ac	; 0x95ac <ewb>
}
    961a:	08 95       	ret

0000961c <Set_MB_Addr>:
	static uint8_t EEMEM MB_NativeAddr_EE[Modbus_Qt] = Init_MB_NativeAddr;
	// ~~~~~~~~~~~~~~~~~~~~~~
	void
	Set_MB_Addr(uint8_t MB_N)
	{
		ewb(MB_NativeAddr_EE+MB_N, MB_NativeAddr[MB_N]);
    961c:	e8 2f       	mov	r30, r24
    961e:	f0 e0       	ldi	r31, 0x00	; 0
    9620:	cf 01       	movw	r24, r30
    9622:	89 5c       	subi	r24, 0xC9	; 201
    9624:	9e 4f       	sbci	r25, 0xFE	; 254
    9626:	e9 52       	subi	r30, 0x29	; 41
    9628:	fa 4f       	sbci	r31, 0xFA	; 250
    962a:	60 81       	ld	r22, Z
    962c:	0e 94 d6 4a 	call	0x95ac	; 0x95ac <ewb>
	}
    9630:	08 95       	ret

00009632 <eww>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
eww(uint16_t *addr, uint16_t val)
{
	//IntOff();
	eeprom_write_word(addr, val);
    9632:	0e 94 37 7d 	call	0xfa6e	; 0xfa6e <__eewr_word_m2560>
	CRC_EEPROM_upd();
    9636:	0e 94 ca 4a 	call	0x9594	; 0x9594 <CRC_EEPROM_upd>
	//IntOn();
}
    963a:	08 95       	ret

0000963c <MB_M_Period_Set>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_M_Period_Set(uint8_t MB_N)
{
	eww(&MB_M_Param_EE[MB_N].Period, MB_M_Period[MB_N]);
    963c:	e8 2f       	mov	r30, r24
    963e:	f0 e0       	ldi	r31, 0x00	; 0
    9640:	cf 01       	movw	r24, r30
    9642:	88 0f       	add	r24, r24
    9644:	99 1f       	adc	r25, r25
    9646:	88 0f       	add	r24, r24
    9648:	99 1f       	adc	r25, r25
    964a:	8e 0f       	add	r24, r30
    964c:	9f 1f       	adc	r25, r31
    964e:	ee 0f       	add	r30, r30
    9650:	ff 1f       	adc	r31, r31
    9652:	ec 55       	subi	r30, 0x5C	; 92
    9654:	f9 4f       	sbci	r31, 0xF9	; 249
    9656:	60 81       	ld	r22, Z
    9658:	71 81       	ldd	r23, Z+1	; 0x01
    965a:	8e 5c       	subi	r24, 0xCE	; 206
    965c:	9e 4f       	sbci	r25, 0xFE	; 254
    965e:	0e 94 19 4b 	call	0x9632	; 0x9632 <eww>
}
    9662:	08 95       	ret

00009664 <OnTimeSave>:

// ~~~~~~~~~~~~~
void
OnTimeSave(void)
{
	ewb(&Timer1min_EE, Timer1min);
    9664:	8d e3       	ldi	r24, 0x3D	; 61
    9666:	91 e0       	ldi	r25, 0x01	; 1
    9668:	60 91 a7 06 	lds	r22, 0x06A7
    966c:	0e 94 d6 4a 	call	0x95ac	; 0x95ac <ewb>
	eww(&Timer1hour_EE, Timer1hour);
    9670:	60 91 19 0c 	lds	r22, 0x0C19
    9674:	70 91 1a 0c 	lds	r23, 0x0C1A
    9678:	8e e3       	ldi	r24, 0x3E	; 62
    967a:	91 e0       	ldi	r25, 0x01	; 1
    967c:	0e 94 19 4b 	call	0x9632	; 0x9632 <eww>
}
    9680:	08 95       	ret

00009682 <TimersInc>:
		HSC_Process();
	#endif
}
void 
TimersInc(void)
{
    9682:	ef 92       	push	r14
    9684:	ff 92       	push	r15
    9686:	0f 93       	push	r16
    9688:	1f 93       	push	r17
    968a:	cf 93       	push	r28
    968c:	df 93       	push	r29
	uint8_t i, TickCounterVar;	
	cli();
    968e:	f8 94       	cli
	TickCounterVar = TickCounter;
    9690:	e0 90 c8 04 	lds	r14, 0x04C8
	TickCounter = 0;
    9694:	10 92 c8 04 	sts	0x04C8, r1
	sei();
    9698:	78 94       	sei
	for(uint8_t j=0;j<TickCounterVar;j++){
    969a:	ee 20       	and	r14, r14
    969c:	09 f4       	brne	.+2      	; 0x96a0 <TimersInc+0x1e>
    969e:	c8 c0       	rjmp	.+400    	; 0x9830 <TimersInc+0x1ae>
    96a0:	ff 24       	eor	r15, r15
		LiveTime++;
	 	for (i=0; i<Timer8TotNumber; i++){
			cli();
			if (!(Timer8Flg[i/8] &(1<<i%8)) && --Timer8[i]==0)
				Timer8Flg[i/8] |=(1<<i%8);
    96a2:	01 e0       	ldi	r16, 0x01	; 1
    96a4:	10 e0       	ldi	r17, 0x00	; 0
	cli();
	TickCounterVar = TickCounter;
	TickCounter = 0;
	sei();
	for(uint8_t j=0;j<TickCounterVar;j++){
		LiveTime++;
    96a6:	80 91 74 07 	lds	r24, 0x0774
    96aa:	90 91 75 07 	lds	r25, 0x0775
    96ae:	a0 91 76 07 	lds	r26, 0x0776
    96b2:	b0 91 77 07 	lds	r27, 0x0777
    96b6:	01 96       	adiw	r24, 0x01	; 1
    96b8:	a1 1d       	adc	r26, r1
    96ba:	b1 1d       	adc	r27, r1
    96bc:	80 93 74 07 	sts	0x0774, r24
    96c0:	90 93 75 07 	sts	0x0775, r25
    96c4:	a0 93 76 07 	sts	0x0776, r26
    96c8:	b0 93 77 07 	sts	0x0777, r27
    96cc:	40 e0       	ldi	r20, 0x00	; 0
    96ce:	50 e0       	ldi	r21, 0x00	; 0
	 	for (i=0; i<Timer8TotNumber; i++){
			cli();
    96d0:	f8 94       	cli
			if (!(Timer8Flg[i/8] &(1<<i%8)) && --Timer8[i]==0)
    96d2:	84 2f       	mov	r24, r20
    96d4:	86 95       	lsr	r24
    96d6:	86 95       	lsr	r24
    96d8:	86 95       	lsr	r24
    96da:	a8 2f       	mov	r26, r24
    96dc:	b0 e0       	ldi	r27, 0x00	; 0
    96de:	a8 55       	subi	r26, 0x58	; 88
    96e0:	bb 4f       	sbci	r27, 0xFB	; 251
    96e2:	8c 91       	ld	r24, X
    96e4:	ba 01       	movw	r22, r20
    96e6:	67 70       	andi	r22, 0x07	; 7
    96e8:	70 70       	andi	r23, 0x00	; 0
    96ea:	90 e0       	ldi	r25, 0x00	; 0
    96ec:	06 2e       	mov	r0, r22
    96ee:	02 c0       	rjmp	.+4      	; 0x96f4 <TimersInc+0x72>
    96f0:	95 95       	asr	r25
    96f2:	87 95       	ror	r24
    96f4:	0a 94       	dec	r0
    96f6:	e2 f7       	brpl	.-8      	; 0x96f0 <TimersInc+0x6e>
    96f8:	80 fd       	sbrc	r24, 0
    96fa:	12 c0       	rjmp	.+36     	; 0x9720 <TimersInc+0x9e>
    96fc:	fa 01       	movw	r30, r20
    96fe:	e2 51       	subi	r30, 0x12	; 18
    9700:	fd 4f       	sbci	r31, 0xFD	; 253
    9702:	80 81       	ld	r24, Z
    9704:	81 50       	subi	r24, 0x01	; 1
    9706:	80 83       	st	Z, r24
    9708:	80 81       	ld	r24, Z
    970a:	88 23       	and	r24, r24
    970c:	49 f4       	brne	.+18     	; 0x9720 <TimersInc+0x9e>
				Timer8Flg[i/8] |=(1<<i%8);
    970e:	2c 91       	ld	r18, X
    9710:	c8 01       	movw	r24, r16
    9712:	02 c0       	rjmp	.+4      	; 0x9718 <TimersInc+0x96>
    9714:	88 0f       	add	r24, r24
    9716:	99 1f       	adc	r25, r25
    9718:	6a 95       	dec	r22
    971a:	e2 f7       	brpl	.-8      	; 0x9714 <TimersInc+0x92>
    971c:	28 2b       	or	r18, r24
    971e:	2c 93       	st	X, r18
			sei();
    9720:	78 94       	sei
    9722:	4f 5f       	subi	r20, 0xFF	; 255
    9724:	5f 4f       	sbci	r21, 0xFF	; 255
	TickCounterVar = TickCounter;
	TickCounter = 0;
	sei();
	for(uint8_t j=0;j<TickCounterVar;j++){
		LiveTime++;
	 	for (i=0; i<Timer8TotNumber; i++){
    9726:	48 35       	cpi	r20, 0x58	; 88
    9728:	51 05       	cpc	r21, r1
    972a:	91 f6       	brne	.-92     	; 0x96d0 <TimersInc+0x4e>
    972c:	40 e0       	ldi	r20, 0x00	; 0
    972e:	50 e0       	ldi	r21, 0x00	; 0
			if (!(Timer8Flg[i/8] &(1<<i%8)) && --Timer8[i]==0)
				Timer8Flg[i/8] |=(1<<i%8);
			sei();
		}
		for (i=0; i<Timer16TotNumber; i++){
			cli();
    9730:	f8 94       	cli
			if (!(Timer16Flg[i/8] &(1<<i%8)) && --Timer16[i]==0)
    9732:	84 2f       	mov	r24, r20
    9734:	86 95       	lsr	r24
    9736:	86 95       	lsr	r24
    9738:	86 95       	lsr	r24
    973a:	a8 2f       	mov	r26, r24
    973c:	b0 e0       	ldi	r27, 0x00	; 0
    973e:	ac 54       	subi	r26, 0x4C	; 76
    9740:	bb 4f       	sbci	r27, 0xFB	; 251
    9742:	8c 91       	ld	r24, X
    9744:	ba 01       	movw	r22, r20
    9746:	67 70       	andi	r22, 0x07	; 7
    9748:	70 70       	andi	r23, 0x00	; 0
    974a:	90 e0       	ldi	r25, 0x00	; 0
    974c:	06 2e       	mov	r0, r22
    974e:	02 c0       	rjmp	.+4      	; 0x9754 <TimersInc+0xd2>
    9750:	95 95       	asr	r25
    9752:	87 95       	ror	r24
    9754:	0a 94       	dec	r0
    9756:	e2 f7       	brpl	.-8      	; 0x9750 <TimersInc+0xce>
    9758:	80 fd       	sbrc	r24, 0
    975a:	17 c0       	rjmp	.+46     	; 0x978a <TimersInc+0x108>
    975c:	fa 01       	movw	r30, r20
    975e:	ee 0f       	add	r30, r30
    9760:	ff 1f       	adc	r31, r31
    9762:	ea 5b       	subi	r30, 0xBA	; 186
    9764:	fc 4f       	sbci	r31, 0xFC	; 252
    9766:	80 81       	ld	r24, Z
    9768:	91 81       	ldd	r25, Z+1	; 0x01
    976a:	01 97       	sbiw	r24, 0x01	; 1
    976c:	91 83       	std	Z+1, r25	; 0x01
    976e:	80 83       	st	Z, r24
    9770:	80 81       	ld	r24, Z
    9772:	91 81       	ldd	r25, Z+1	; 0x01
    9774:	89 2b       	or	r24, r25
    9776:	49 f4       	brne	.+18     	; 0x978a <TimersInc+0x108>
				Timer16Flg[i/8] |=(1<<i%8);
    9778:	2c 91       	ld	r18, X
    977a:	c8 01       	movw	r24, r16
    977c:	02 c0       	rjmp	.+4      	; 0x9782 <TimersInc+0x100>
    977e:	88 0f       	add	r24, r24
    9780:	99 1f       	adc	r25, r25
    9782:	6a 95       	dec	r22
    9784:	e2 f7       	brpl	.-8      	; 0x977e <TimersInc+0xfc>
    9786:	28 2b       	or	r18, r24
    9788:	2c 93       	st	X, r18
			sei();
    978a:	78 94       	sei
    978c:	4f 5f       	subi	r20, 0xFF	; 255
    978e:	5f 4f       	sbci	r21, 0xFF	; 255
			cli();
			if (!(Timer8Flg[i/8] &(1<<i%8)) && --Timer8[i]==0)
				Timer8Flg[i/8] |=(1<<i%8);
			sei();
		}
		for (i=0; i<Timer16TotNumber; i++){
    9790:	40 36       	cpi	r20, 0x60	; 96
    9792:	51 05       	cpc	r21, r1
    9794:	69 f6       	brne	.-102    	; 0x9730 <TimersInc+0xae>
    9796:	40 e0       	ldi	r20, 0x00	; 0
    9798:	50 e0       	ldi	r21, 0x00	; 0
			if (!(Timer16Flg[i/8] &(1<<i%8)) && --Timer16[i]==0)
				Timer16Flg[i/8] |=(1<<i%8);
			sei();
		}
		for (i=0; i<Timer32TotNumber; i++){
			cli();
    979a:	f8 94       	cli
			if (!(Timer32Flg[i/8] &(1<<i%8)) && --Timer32[i]==0)
    979c:	84 2f       	mov	r24, r20
    979e:	86 95       	lsr	r24
    97a0:	86 95       	lsr	r24
    97a2:	86 95       	lsr	r24
    97a4:	c8 2f       	mov	r28, r24
    97a6:	d0 e0       	ldi	r29, 0x00	; 0
    97a8:	cf 53       	subi	r28, 0x3F	; 63
    97aa:	db 4f       	sbci	r29, 0xFB	; 251
    97ac:	88 81       	ld	r24, Y
    97ae:	ba 01       	movw	r22, r20
    97b0:	67 70       	andi	r22, 0x07	; 7
    97b2:	70 70       	andi	r23, 0x00	; 0
    97b4:	90 e0       	ldi	r25, 0x00	; 0
    97b6:	06 2e       	mov	r0, r22
    97b8:	02 c0       	rjmp	.+4      	; 0x97be <TimersInc+0x13c>
    97ba:	95 95       	asr	r25
    97bc:	87 95       	ror	r24
    97be:	0a 94       	dec	r0
    97c0:	e2 f7       	brpl	.-8      	; 0x97ba <TimersInc+0x138>
    97c2:	80 fd       	sbrc	r24, 0
    97c4:	23 c0       	rjmp	.+70     	; 0x980c <TimersInc+0x18a>
    97c6:	fa 01       	movw	r30, r20
    97c8:	ee 0f       	add	r30, r30
    97ca:	ff 1f       	adc	r31, r31
    97cc:	ee 0f       	add	r30, r30
    97ce:	ff 1f       	adc	r31, r31
    97d0:	ea 5f       	subi	r30, 0xFA	; 250
    97d2:	fb 4f       	sbci	r31, 0xFB	; 251
    97d4:	80 81       	ld	r24, Z
    97d6:	91 81       	ldd	r25, Z+1	; 0x01
    97d8:	a2 81       	ldd	r26, Z+2	; 0x02
    97da:	b3 81       	ldd	r27, Z+3	; 0x03
    97dc:	01 97       	sbiw	r24, 0x01	; 1
    97de:	a1 09       	sbc	r26, r1
    97e0:	b1 09       	sbc	r27, r1
    97e2:	80 83       	st	Z, r24
    97e4:	91 83       	std	Z+1, r25	; 0x01
    97e6:	a2 83       	std	Z+2, r26	; 0x02
    97e8:	b3 83       	std	Z+3, r27	; 0x03
    97ea:	80 81       	ld	r24, Z
    97ec:	91 81       	ldd	r25, Z+1	; 0x01
    97ee:	a2 81       	ldd	r26, Z+2	; 0x02
    97f0:	b3 81       	ldd	r27, Z+3	; 0x03
    97f2:	00 97       	sbiw	r24, 0x00	; 0
    97f4:	a1 05       	cpc	r26, r1
    97f6:	b1 05       	cpc	r27, r1
    97f8:	49 f4       	brne	.+18     	; 0x980c <TimersInc+0x18a>
				Timer32Flg[i/8] |=(1<<i%8);	
    97fa:	28 81       	ld	r18, Y
    97fc:	c8 01       	movw	r24, r16
    97fe:	02 c0       	rjmp	.+4      	; 0x9804 <TimersInc+0x182>
    9800:	88 0f       	add	r24, r24
    9802:	99 1f       	adc	r25, r25
    9804:	6a 95       	dec	r22
    9806:	e2 f7       	brpl	.-8      	; 0x9800 <TimersInc+0x17e>
    9808:	28 2b       	or	r18, r24
    980a:	28 83       	st	Y, r18
			sei();
    980c:	78 94       	sei
    980e:	4f 5f       	subi	r20, 0xFF	; 255
    9810:	5f 4f       	sbci	r21, 0xFF	; 255
			cli();
			if (!(Timer16Flg[i/8] &(1<<i%8)) && --Timer16[i]==0)
				Timer16Flg[i/8] |=(1<<i%8);
			sei();
		}
		for (i=0; i<Timer32TotNumber; i++){
    9812:	48 32       	cpi	r20, 0x28	; 40
    9814:	51 05       	cpc	r21, r1
    9816:	09 f0       	breq	.+2      	; 0x981a <TimersInc+0x198>
    9818:	c0 cf       	rjmp	.-128    	; 0x979a <TimersInc+0x118>
			sei();
		}

		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		static uint8_t Timer10ms;
		if (++Timer10ms==100) {
    981a:	80 91 e4 02 	lds	r24, 0x02E4
    981e:	8f 5f       	subi	r24, 0xFF	; 255
    9820:	80 93 e4 02 	sts	0x02E4, r24
    9824:	84 36       	cpi	r24, 0x64	; 100
    9826:	59 f0       	breq	.+22     	; 0x983e <TimersInc+0x1bc>
	uint8_t i, TickCounterVar;	
	cli();
	TickCounterVar = TickCounter;
	TickCounter = 0;
	sei();
	for(uint8_t j=0;j<TickCounterVar;j++){
    9828:	f3 94       	inc	r15
    982a:	fe 14       	cp	r15, r14
    982c:	08 f4       	brcc	.+2      	; 0x9830 <TimersInc+0x1ae>
    982e:	3b cf       	rjmp	.-394    	; 0x96a6 <TimersInc+0x24>
 			ScanCount = 0;
			RT();
		}
		#endif
	}
}
    9830:	df 91       	pop	r29
    9832:	cf 91       	pop	r28
    9834:	1f 91       	pop	r17
    9836:	0f 91       	pop	r16
    9838:	ff 90       	pop	r15
    983a:	ef 90       	pop	r14
    983c:	08 95       	ret
		}

		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		static uint8_t Timer10ms;
		if (++Timer10ms==100) {
			Timer10ms = 0;
    983e:	10 92 e4 02 	sts	0x02E4, r1
			ScanPerSec = ScanCount;
    9842:	80 91 64 07 	lds	r24, 0x0764
    9846:	90 91 65 07 	lds	r25, 0x0765
    984a:	90 93 7e 07 	sts	0x077E, r25
    984e:	80 93 7d 07 	sts	0x077D, r24
 			ScanCount = 0;
    9852:	10 92 65 07 	sts	0x0765, r1
    9856:	10 92 64 07 	sts	0x0764, r1

// ~~~~~~~~~~~~~~~
inline static void
RT(void)
{
	if (++Timer1s==60) {
    985a:	80 91 c8 08 	lds	r24, 0x08C8
    985e:	8f 5f       	subi	r24, 0xFF	; 255
    9860:	80 93 c8 08 	sts	0x08C8, r24
    9864:	8c 33       	cpi	r24, 0x3C	; 60
    9866:	01 f7       	brne	.-64     	; 0x9828 <TimersInc+0x1a6>
		Timer1s = 0;
    9868:	10 92 c8 08 	sts	0x08C8, r1
		if (++Timer1min==60) {
    986c:	80 91 a7 06 	lds	r24, 0x06A7
    9870:	8f 5f       	subi	r24, 0xFF	; 255
    9872:	80 93 a7 06 	sts	0x06A7, r24
    9876:	8c 33       	cpi	r24, 0x3C	; 60
    9878:	b9 f6       	brne	.-82     	; 0x9828 <TimersInc+0x1a6>
			Timer1min = 0;
    987a:	10 92 a7 06 	sts	0x06A7, r1
			++Timer1hour;
    987e:	80 91 19 0c 	lds	r24, 0x0C19
    9882:	90 91 1a 0c 	lds	r25, 0x0C1A
    9886:	01 96       	adiw	r24, 0x01	; 1
    9888:	90 93 1a 0c 	sts	0x0C1A, r25
    988c:	80 93 19 0c 	sts	0x0C19, r24
			OnTimeSave();
    9890:	0e 94 32 4b 	call	0x9664	; 0x9664 <OnTimeSave>
    9894:	c9 cf       	rjmp	.-110    	; 0x9828 <TimersInc+0x1a6>

00009896 <ewbl>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ewbl(const void *src, void *dst, size_t n)
{
	//IntOff();
	eeprom_write_block(src, dst, n);
    9896:	0e 94 17 7d 	call	0xfa2e	; 0xfa2e <__eewr_block_m2560>
	CRC_EEPROM_upd();
    989a:	0e 94 ca 4a 	call	0x9594	; 0x9594 <CRC_EEPROM_upd>
	//IntOn();
}
    989e:	08 95       	ret

000098a0 <ewd>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ewd(uint32_t *addr, uint32_t val)
{
	//IntOff();
	eeprom_write_dword(addr, val);
    98a0:	0e 94 2f 7d 	call	0xfa5e	; 0xfa5e <__eewr_dword_m2560>
	CRC_EEPROM_upd();
    98a4:	0e 94 ca 4a 	call	0x9594	; 0x9594 <CRC_EEPROM_upd>
	//IntOn();
}
    98a8:	08 95       	ret

000098aa <erbl>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    98aa:	0e 94 f3 7c 	call	0xf9e6	; 0xf9e6 <__eerd_block_m2560>
	//IntOn();
}
    98ae:	08 95       	ret

000098b0 <erd>:
// ~~~~~~~~~~~~~~~~~~~~~~
uint32_t
erd(const uint32_t *addr)
{
	//IntOff();
	uint32_t word = eeprom_read_dword(addr);
    98b0:	0e 94 0b 7d 	call	0xfa16	; 0xfa16 <__eerd_dword_m2560>
	//IntOn();
	return word;
}
    98b4:	08 95       	ret

000098b6 <erw>:
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    98b6:	0e 94 11 7d 	call	0xfa22	; 0xfa22 <__eerd_word_m2560>
	//IntOn();
	return word;
}
    98ba:	08 95       	ret

000098bc <EE_InterBrokLine>:
	uint8_t WiAbsc, uint16_t (*TblAbsc)[WiAbsc], uint8_t Absc,
	uint8_t WiOrdi, uint16_t (*TblOrdi)[WiOrdi], uint8_t Ordi,
	uint8_t Len,
	int16_t x
)
{
    98bc:	2f 92       	push	r2
    98be:	3f 92       	push	r3
    98c0:	4f 92       	push	r4
    98c2:	5f 92       	push	r5
    98c4:	6f 92       	push	r6
    98c6:	7f 92       	push	r7
    98c8:	8f 92       	push	r8
    98ca:	9f 92       	push	r9
    98cc:	af 92       	push	r10
    98ce:	bf 92       	push	r11
    98d0:	cf 92       	push	r12
    98d2:	df 92       	push	r13
    98d4:	ef 92       	push	r14
    98d6:	ff 92       	push	r15
    98d8:	0f 93       	push	r16
    98da:	1f 93       	push	r17
    98dc:	df 93       	push	r29
    98de:	cf 93       	push	r28
    98e0:	cd b7       	in	r28, 0x3d	; 61
    98e2:	de b7       	in	r29, 0x3e	; 62
    98e4:	2e 97       	sbiw	r28, 0x0e	; 14
    98e6:	0f b6       	in	r0, 0x3f	; 63
    98e8:	f8 94       	cli
    98ea:	de bf       	out	0x3e, r29	; 62
    98ec:	0f be       	out	0x3f, r0	; 63
    98ee:	cd bf       	out	0x3d, r28	; 61
    98f0:	f8 2e       	mov	r15, r24
    98f2:	2b 01       	movw	r4, r22
    98f4:	2d 87       	std	Y+13, r18	; 0x0d
    98f6:	18 01       	movw	r2, r16
    98f8:	ee 86       	std	Y+14, r14	; 0x0e
    98fa:	0c 2d       	mov	r16, r12
	LineGraph Segm;
	uint8_t i = 0;
	Segm.x2 = (int16_t)erw(TblAbsc[0]+Absc);
    98fc:	c4 2e       	mov	r12, r20
    98fe:	dd 24       	eor	r13, r13
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    9900:	c6 01       	movw	r24, r12
    9902:	88 0f       	add	r24, r24
    9904:	99 1f       	adc	r25, r25
    9906:	86 0f       	add	r24, r22
    9908:	97 1f       	adc	r25, r23
    990a:	0e 94 11 7d 	call	0xfa22	; 0xfa22 <__eerd_word_m2560>
    990e:	aa 27       	eor	r26, r26
    9910:	97 fd       	sbrc	r25, 7
    9912:	a0 95       	com	r26
    9914:	ba 2f       	mov	r27, r26
    9916:	8d 83       	std	Y+5, r24	; 0x05
    9918:	9e 83       	std	Y+6, r25	; 0x06
    991a:	af 83       	std	Y+7, r26	; 0x07
    991c:	b8 87       	std	Y+8, r27	; 0x08
    991e:	ef 2c       	mov	r14, r15
    9920:	ff 24       	eor	r15, r15
    9922:	35 01       	movw	r6, r10
    9924:	88 24       	eor	r8, r8
    9926:	77 fc       	sbrc	r7, 7
    9928:	80 94       	com	r8
    992a:	98 2c       	mov	r9, r8
    992c:	10 e0       	ldi	r17, 0x00	; 0
    992e:	9c 01       	movw	r18, r24
    9930:	ad 01       	movw	r20, r26
	do {
		Segm.x1 = Segm.x2;
    9932:	29 83       	std	Y+1, r18	; 0x01
    9934:	3a 83       	std	Y+2, r19	; 0x02
    9936:	4b 83       	std	Y+3, r20	; 0x03
    9938:	5c 83       	std	Y+4, r21	; 0x04
		Segm.x2 = (int16_t)erw(TblAbsc[++i]+Absc);
    993a:	1f 5f       	subi	r17, 0xFF	; 255
    993c:	a1 2e       	mov	r10, r17
    993e:	bb 24       	eor	r11, r11
    9940:	ae 9c       	mul	r10, r14
    9942:	c0 01       	movw	r24, r0
    9944:	af 9c       	mul	r10, r15
    9946:	90 0d       	add	r25, r0
    9948:	be 9c       	mul	r11, r14
    994a:	90 0d       	add	r25, r0
    994c:	11 24       	eor	r1, r1
    994e:	8c 0d       	add	r24, r12
    9950:	9d 1d       	adc	r25, r13
    9952:	88 0f       	add	r24, r24
    9954:	99 1f       	adc	r25, r25
    9956:	84 0d       	add	r24, r4
    9958:	95 1d       	adc	r25, r5
    995a:	0e 94 11 7d 	call	0xfa22	; 0xfa22 <__eerd_word_m2560>
    995e:	9c 01       	movw	r18, r24
    9960:	44 27       	eor	r20, r20
    9962:	37 fd       	sbrc	r19, 7
    9964:	40 95       	com	r20
    9966:	54 2f       	mov	r21, r20
    9968:	2d 83       	std	Y+5, r18	; 0x05
    996a:	3e 83       	std	Y+6, r19	; 0x06
    996c:	4f 83       	std	Y+7, r20	; 0x07
    996e:	58 87       	std	Y+8, r21	; 0x08
	} while(x>Segm.x2 && i<Len);
    9970:	26 15       	cp	r18, r6
    9972:	37 05       	cpc	r19, r7
    9974:	48 05       	cpc	r20, r8
    9976:	59 05       	cpc	r21, r9
    9978:	14 f4       	brge	.+4      	; 0x997e <EE_InterBrokLine+0xc2>
    997a:	10 17       	cp	r17, r16
    997c:	d0 f2       	brcs	.-76     	; 0x9932 <EE_InterBrokLine+0x76>
	Segm.y1 = (int16_t)erw(TblOrdi[i-1]+Ordi);
    997e:	8d 85       	ldd	r24, Y+13	; 0x0d
    9980:	08 2f       	mov	r16, r24
    9982:	10 e0       	ldi	r17, 0x00	; 0
    9984:	8e 85       	ldd	r24, Y+14	; 0x0e
    9986:	e8 2e       	mov	r14, r24
    9988:	ff 24       	eor	r15, r15
    998a:	08 94       	sec
    998c:	a1 08       	sbc	r10, r1
    998e:	b1 08       	sbc	r11, r1
    9990:	a0 9e       	mul	r10, r16
    9992:	c0 01       	movw	r24, r0
    9994:	a1 9e       	mul	r10, r17
    9996:	90 0d       	add	r25, r0
    9998:	b0 9e       	mul	r11, r16
    999a:	90 0d       	add	r25, r0
    999c:	11 24       	eor	r1, r1
    999e:	08 94       	sec
    99a0:	a1 1c       	adc	r10, r1
    99a2:	b1 1c       	adc	r11, r1
    99a4:	8e 0d       	add	r24, r14
    99a6:	9f 1d       	adc	r25, r15
    99a8:	88 0f       	add	r24, r24
    99aa:	99 1f       	adc	r25, r25
    99ac:	82 0d       	add	r24, r2
    99ae:	93 1d       	adc	r25, r3
    99b0:	0e 94 11 7d 	call	0xfa22	; 0xfa22 <__eerd_word_m2560>
    99b4:	9a 87       	std	Y+10, r25	; 0x0a
    99b6:	89 87       	std	Y+9, r24	; 0x09
    99b8:	a0 9e       	mul	r10, r16
    99ba:	c0 01       	movw	r24, r0
    99bc:	a1 9e       	mul	r10, r17
    99be:	90 0d       	add	r25, r0
    99c0:	b0 9e       	mul	r11, r16
    99c2:	90 0d       	add	r25, r0
    99c4:	11 24       	eor	r1, r1
    99c6:	8e 0d       	add	r24, r14
    99c8:	9f 1d       	adc	r25, r15
    99ca:	88 0f       	add	r24, r24
    99cc:	99 1f       	adc	r25, r25
    99ce:	82 0d       	add	r24, r2
    99d0:	93 1d       	adc	r25, r3
    99d2:	0e 94 11 7d 	call	0xfa22	; 0xfa22 <__eerd_word_m2560>
	Segm.y2 = (int16_t)erw(TblOrdi[i]+Ordi);
    99d6:	9c 87       	std	Y+12, r25	; 0x0c
    99d8:	8b 87       	std	Y+11, r24	; 0x0b
	return LineFunc(&Segm, x);
    99da:	ce 01       	movw	r24, r28
    99dc:	01 96       	adiw	r24, 0x01	; 1
    99de:	b4 01       	movw	r22, r8
    99e0:	a3 01       	movw	r20, r6
    99e2:	0e 94 30 20 	call	0x4060	; 0x4060 <LineFunc>
}
    99e6:	2e 96       	adiw	r28, 0x0e	; 14
    99e8:	0f b6       	in	r0, 0x3f	; 63
    99ea:	f8 94       	cli
    99ec:	de bf       	out	0x3e, r29	; 62
    99ee:	0f be       	out	0x3f, r0	; 63
    99f0:	cd bf       	out	0x3d, r28	; 61
    99f2:	cf 91       	pop	r28
    99f4:	df 91       	pop	r29
    99f6:	1f 91       	pop	r17
    99f8:	0f 91       	pop	r16
    99fa:	ff 90       	pop	r15
    99fc:	ef 90       	pop	r14
    99fe:	df 90       	pop	r13
    9a00:	cf 90       	pop	r12
    9a02:	bf 90       	pop	r11
    9a04:	af 90       	pop	r10
    9a06:	9f 90       	pop	r9
    9a08:	8f 90       	pop	r8
    9a0a:	7f 90       	pop	r7
    9a0c:	6f 90       	pop	r6
    9a0e:	5f 90       	pop	r5
    9a10:	4f 90       	pop	r4
    9a12:	3f 90       	pop	r3
    9a14:	2f 90       	pop	r2
    9a16:	08 95       	ret

00009a18 <MemCheck>:
}

// ~~~~~~~~~~~
uint8_t
MemCheck(void)
{
    9a18:	0f 93       	push	r16
    9a1a:	1f 93       	push	r17
//	uint8_t T = Timer32Stopp(TD_Mem);
//	if (T) {
//		StartTimer32(TD_Mem, 360000);
		if (!(MemFail &(1<<MemFail_Flash)) && CRC_Flash_calc()!=erw(&MemCheck_stor.CRC_Flash_stor))
    9a1c:	80 91 c5 08 	lds	r24, 0x08C5
    9a20:	80 ff       	sbrs	r24, 0
    9a22:	17 c0       	rjmp	.+46     	; 0x9a52 <MemCheck+0x3a>
			MemFail |=(1<<MemFail_Flash);
		if (!(MemFail &(1<<MemFail_EEPROM)) && CRC_EEPROM_calc()!=erw(&MemCheck_stor.CRC_EEPROM_stor))
    9a24:	81 ff       	sbrs	r24, 1
    9a26:	03 c0       	rjmp	.+6      	; 0x9a2e <MemCheck+0x16>
			MemFail |=(1<<MemFail_EEPROM);
//	}
//	return T && MemFail;
	return MemFail;
}
    9a28:	1f 91       	pop	r17
    9a2a:	0f 91       	pop	r16
    9a2c:	08 95       	ret
//	uint8_t T = Timer32Stopp(TD_Mem);
//	if (T) {
//		StartTimer32(TD_Mem, 360000);
		if (!(MemFail &(1<<MemFail_Flash)) && CRC_Flash_calc()!=erw(&MemCheck_stor.CRC_Flash_stor))
			MemFail |=(1<<MemFail_Flash);
		if (!(MemFail &(1<<MemFail_EEPROM)) && CRC_EEPROM_calc()!=erw(&MemCheck_stor.CRC_EEPROM_stor))
    9a2e:	0e 94 e0 18 	call	0x31c0	; 0x31c0 <CRC_EEPROM_calc>
    9a32:	8c 01       	movw	r16, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    9a34:	8a e3       	ldi	r24, 0x3A	; 58
    9a36:	91 e0       	ldi	r25, 0x01	; 1
    9a38:	0e 94 11 7d 	call	0xfa22	; 0xfa22 <__eerd_word_m2560>
//	uint8_t T = Timer32Stopp(TD_Mem);
//	if (T) {
//		StartTimer32(TD_Mem, 360000);
		if (!(MemFail &(1<<MemFail_Flash)) && CRC_Flash_calc()!=erw(&MemCheck_stor.CRC_Flash_stor))
			MemFail |=(1<<MemFail_Flash);
		if (!(MemFail &(1<<MemFail_EEPROM)) && CRC_EEPROM_calc()!=erw(&MemCheck_stor.CRC_EEPROM_stor))
    9a3c:	08 17       	cp	r16, r24
    9a3e:	19 07       	cpc	r17, r25
    9a40:	d9 f0       	breq	.+54     	; 0x9a78 <MemCheck+0x60>
			MemFail |=(1<<MemFail_EEPROM);
    9a42:	80 91 c5 08 	lds	r24, 0x08C5
    9a46:	82 60       	ori	r24, 0x02	; 2
    9a48:	80 93 c5 08 	sts	0x08C5, r24
//	}
//	return T && MemFail;
	return MemFail;
}
    9a4c:	1f 91       	pop	r17
    9a4e:	0f 91       	pop	r16
    9a50:	08 95       	ret
MemCheck(void)
{
//	uint8_t T = Timer32Stopp(TD_Mem);
//	if (T) {
//		StartTimer32(TD_Mem, 360000);
		if (!(MemFail &(1<<MemFail_Flash)) && CRC_Flash_calc()!=erw(&MemCheck_stor.CRC_Flash_stor))
    9a52:	0e 94 c6 18 	call	0x318c	; 0x318c <CRC_Flash_calc>
    9a56:	8c 01       	movw	r16, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    9a58:	88 e3       	ldi	r24, 0x38	; 56
    9a5a:	91 e0       	ldi	r25, 0x01	; 1
    9a5c:	0e 94 11 7d 	call	0xfa22	; 0xfa22 <__eerd_word_m2560>
MemCheck(void)
{
//	uint8_t T = Timer32Stopp(TD_Mem);
//	if (T) {
//		StartTimer32(TD_Mem, 360000);
		if (!(MemFail &(1<<MemFail_Flash)) && CRC_Flash_calc()!=erw(&MemCheck_stor.CRC_Flash_stor))
    9a60:	08 17       	cp	r16, r24
    9a62:	19 07       	cpc	r17, r25
    9a64:	31 f0       	breq	.+12     	; 0x9a72 <MemCheck+0x5a>
			MemFail |=(1<<MemFail_Flash);
    9a66:	80 91 c5 08 	lds	r24, 0x08C5
    9a6a:	81 60       	ori	r24, 0x01	; 1
    9a6c:	80 93 c5 08 	sts	0x08C5, r24
    9a70:	d9 cf       	rjmp	.-78     	; 0x9a24 <MemCheck+0xc>
    9a72:	80 91 c5 08 	lds	r24, 0x08C5
    9a76:	d6 cf       	rjmp	.-84     	; 0x9a24 <MemCheck+0xc>
    9a78:	80 91 c5 08 	lds	r24, 0x08C5
    9a7c:	d5 cf       	rjmp	.-86     	; 0x9a28 <MemCheck+0x10>

00009a7e <MemCheckMsg>:

// ~~~~~~~~~~~~~~
void
MemCheckMsg(void)
{
	if(MemCheck())
    9a7e:	0e 94 0c 4d 	call	0x9a18	; 0x9a18 <MemCheck>
    9a82:	88 23       	and	r24, r24
    9a84:	09 f4       	brne	.+2      	; 0x9a88 <MemCheckMsg+0xa>
    9a86:	08 95       	ret

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    9a88:	80 91 c5 08 	lds	r24, 0x08C5
    9a8c:	e8 2f       	mov	r30, r24
    9a8e:	f0 e0       	ldi	r31, 0x00	; 0
    9a90:	ee 0f       	add	r30, r30
    9a92:	ff 1f       	adc	r31, r31
    9a94:	e5 5e       	subi	r30, 0xE5	; 229
    9a96:	f8 4e       	sbci	r31, 0xE8	; 232
		ShowMsg(prp(MsgErrMemo+MemFail));
    9a98:	85 91       	lpm	r24, Z+
    9a9a:	94 91       	lpm	r25, Z+
    9a9c:	0e 94 cf 3b 	call	0x779e	; 0x779e <ShowMsg>
    9aa0:	08 95       	ret

00009aa2 <erb>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    9aa2:	0e 94 03 7d 	call	0xfa06	; 0xfa06 <__eerd_byte_m2560>
	//IntOn();
	return byte;
}
    9aa6:	08 95       	ret

00009aa8 <ThermChanWrong>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
ThermChanWrong(uint8_t ChanN)
{
    9aa8:	ff 92       	push	r15
    9aaa:	0f 93       	push	r16
    9aac:	1f 93       	push	r17
	return ThermWrong(prb(ThermFami+ChanN), erb(ThermType+ChanN), Temperature[ChanN]);
    9aae:	08 2f       	mov	r16, r24
    9ab0:	10 e0       	ldi	r17, 0x00	; 0

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    9ab2:	f8 01       	movw	r30, r16
    9ab4:	ef 57       	subi	r30, 0x7F	; 127
    9ab6:	f9 4f       	sbci	r31, 0xF9	; 249
    9ab8:	f4 90       	lpm	r15, Z+
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    9aba:	c8 01       	movw	r24, r16
    9abc:	89 5e       	subi	r24, 0xE9	; 233
    9abe:	9e 4f       	sbci	r25, 0xFE	; 254
    9ac0:	0e 94 03 7d 	call	0xfa06	; 0xfa06 <__eerd_byte_m2560>
    9ac4:	68 2f       	mov	r22, r24
    9ac6:	00 0f       	add	r16, r16
    9ac8:	11 1f       	adc	r17, r17
    9aca:	04 5c       	subi	r16, 0xC4	; 196
    9acc:	19 4f       	sbci	r17, 0xF9	; 249
    9ace:	f8 01       	movw	r30, r16
    9ad0:	40 81       	ld	r20, Z
    9ad2:	51 81       	ldd	r21, Z+1	; 0x01
    9ad4:	8f 2d       	mov	r24, r15
    9ad6:	0e 94 ef 3e 	call	0x7dde	; 0x7dde <ThermWrong>
}
    9ada:	1f 91       	pop	r17
    9adc:	0f 91       	pop	r16
    9ade:	ff 90       	pop	r15
    9ae0:	08 95       	ret

00009ae2 <ThermChan>:
}

// ~~~~~~~~~~~~~~~~~~~~~
void
ThermChan(uint8_t ChanN)
{
    9ae2:	8f 92       	push	r8
    9ae4:	9f 92       	push	r9
    9ae6:	af 92       	push	r10
    9ae8:	bf 92       	push	r11
    9aea:	cf 92       	push	r12
    9aec:	df 92       	push	r13
    9aee:	ef 92       	push	r14
    9af0:	ff 92       	push	r15
    9af2:	0f 93       	push	r16
    9af4:	1f 93       	push	r17
    9af6:	cf 93       	push	r28
    9af8:	df 93       	push	r29
	if (ChanN>=TerReg)
    9afa:	86 30       	cpi	r24, 0x06	; 6
    9afc:	08 f0       	brcs	.+2      	; 0x9b00 <ThermChan+0x1e>
    9afe:	4c c0       	rjmp	.+152    	; 0x9b98 <ThermChan+0xb6>
		return;
    9b00:	e8 2e       	mov	r14, r24
    9b02:	ff 24       	eor	r15, r15
    9b04:	d7 01       	movw	r26, r14
    9b06:	aa 0f       	add	r26, r26
    9b08:	bb 1f       	adc	r27, r27
    9b0a:	a2 95       	swap	r26
    9b0c:	b2 95       	swap	r27
    9b0e:	b0 7f       	andi	r27, 0xF0	; 240
    9b10:	ba 27       	eor	r27, r26
    9b12:	a0 7f       	andi	r26, 0xF0	; 240
    9b14:	ba 27       	eor	r27, r26
    9b16:	fd 01       	movw	r30, r26
    9b18:	ec 5e       	subi	r30, 0xEC	; 236
    9b1a:	fa 4f       	sbci	r31, 0xFA	; 250
    9b1c:	2f e0       	ldi	r18, 0x0F	; 15
	for (uint8_t i=TerFiltLev*4-1; i; i--)
		TerBuf[ChanN][i] = TerBuf[ChanN][i-1];
    9b1e:	80 81       	ld	r24, Z
    9b20:	91 81       	ldd	r25, Z+1	; 0x01
    9b22:	93 83       	std	Z+3, r25	; 0x03
    9b24:	82 83       	std	Z+2, r24	; 0x02
void
ThermChan(uint8_t ChanN)
{
	if (ChanN>=TerReg)
		return;
	for (uint8_t i=TerFiltLev*4-1; i; i--)
    9b26:	21 50       	subi	r18, 0x01	; 1
    9b28:	32 97       	sbiw	r30, 0x02	; 2
    9b2a:	22 23       	and	r18, r18
    9b2c:	c1 f7       	brne	.-16     	; 0x9b1e <ThermChan+0x3c>
		TerBuf[ChanN][i] = TerBuf[ChanN][i-1];
	TerBuf[ChanN][0] = TerInput[ChanN];
    9b2e:	a8 50       	subi	r26, 0x08	; 8
    9b30:	bb 4f       	sbci	r27, 0xFB	; 251
    9b32:	47 01       	movw	r8, r14
    9b34:	88 0c       	add	r8, r8
    9b36:	99 1c       	adc	r9, r9
    9b38:	f4 01       	movw	r30, r8
    9b3a:	e7 53       	subi	r30, 0x37	; 55
    9b3c:	f7 4f       	sbci	r31, 0xF7	; 247
    9b3e:	80 81       	ld	r24, Z
    9b40:	91 81       	ldd	r25, Z+1	; 0x01
    9b42:	8d 93       	st	X+, r24
    9b44:	9c 93       	st	X, r25

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    9b46:	f7 01       	movw	r30, r14
    9b48:	ef 57       	subi	r30, 0x7F	; 127
    9b4a:	f9 4f       	sbci	r31, 0xF9	; 249
    9b4c:	c4 90       	lpm	r12, Z+
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    9b4e:	c7 01       	movw	r24, r14
    9b50:	89 5e       	subi	r24, 0xE9	; 233
    9b52:	9e 4f       	sbci	r25, 0xFE	; 254
    9b54:	0e 94 03 7d 	call	0xfa06	; 0xfa06 <__eerd_byte_m2560>
    9b58:	18 2f       	mov	r17, r24
	int16_t Ter = Thermode(prb(ThermFami+ChanN), erb(ThermType+ChanN), DigiFilt(TerBuf[ChanN],TerFiltLev));
    9b5a:	c7 01       	movw	r24, r14
    9b5c:	88 0f       	add	r24, r24
    9b5e:	99 1f       	adc	r25, r25
    9b60:	82 95       	swap	r24
    9b62:	92 95       	swap	r25
    9b64:	90 7f       	andi	r25, 0xF0	; 240
    9b66:	98 27       	eor	r25, r24
    9b68:	80 7f       	andi	r24, 0xF0	; 240
    9b6a:	98 27       	eor	r25, r24
    9b6c:	88 50       	subi	r24, 0x08	; 8
    9b6e:	9b 4f       	sbci	r25, 0xFB	; 251
    9b70:	64 e0       	ldi	r22, 0x04	; 4
    9b72:	0e 94 fd 49 	call	0x93fa	; 0x93fa <DigiFilt>
    9b76:	ac 01       	movw	r20, r24
    9b78:	8c 2d       	mov	r24, r12
    9b7a:	61 2f       	mov	r22, r17
    9b7c:	0e 94 6f 3e 	call	0x7cde	; 0x7cde <Thermode>
    9b80:	ec 01       	movw	r28, r24
	if (Ter!=Therm_Off_Mark)
    9b82:	80 e8       	ldi	r24, 0x80	; 128
    9b84:	c0 30       	cpi	r28, 0x00	; 0
    9b86:	d8 07       	cpc	r29, r24
    9b88:	a1 f4       	brne	.+40     	; 0x9bb2 <ThermChan+0xd0>
		Ter = (Ter+(int8_t)erb(&ThermCorr[ChanN].D))*(erw(&ThermCorr[ChanN].A)/1000.0);
	Temperature[ChanN] = Ter;
    9b8a:	ec e3       	ldi	r30, 0x3C	; 60
    9b8c:	f6 e0       	ldi	r31, 0x06	; 6
    9b8e:	8e 0e       	add	r8, r30
    9b90:	9f 1e       	adc	r9, r31
    9b92:	f4 01       	movw	r30, r8
    9b94:	d1 83       	std	Z+1, r29	; 0x01
    9b96:	c0 83       	st	Z, r28
}
    9b98:	df 91       	pop	r29
    9b9a:	cf 91       	pop	r28
    9b9c:	1f 91       	pop	r17
    9b9e:	0f 91       	pop	r16
    9ba0:	ff 90       	pop	r15
    9ba2:	ef 90       	pop	r14
    9ba4:	df 90       	pop	r13
    9ba6:	cf 90       	pop	r12
    9ba8:	bf 90       	pop	r11
    9baa:	af 90       	pop	r10
    9bac:	9f 90       	pop	r9
    9bae:	8f 90       	pop	r8
    9bb0:	08 95       	ret
    9bb2:	64 01       	movw	r12, r8
    9bb4:	ce 0c       	add	r12, r14
    9bb6:	df 1c       	adc	r13, r15
    9bb8:	c6 01       	movw	r24, r12
    9bba:	83 5e       	subi	r24, 0xE3	; 227
    9bbc:	9e 4f       	sbci	r25, 0xFE	; 254
    9bbe:	0e 94 03 7d 	call	0xfa06	; 0xfa06 <__eerd_byte_m2560>
    9bc2:	e8 2e       	mov	r14, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    9bc4:	c6 01       	movw	r24, r12
    9bc6:	82 5e       	subi	r24, 0xE2	; 226
    9bc8:	9e 4f       	sbci	r25, 0xFE	; 254
    9bca:	0e 94 11 7d 	call	0xfa22	; 0xfa22 <__eerd_word_m2560>
    9bce:	5c 01       	movw	r10, r24
	for (uint8_t i=TerFiltLev*4-1; i; i--)
		TerBuf[ChanN][i] = TerBuf[ChanN][i-1];
	TerBuf[ChanN][0] = TerInput[ChanN];
	int16_t Ter = Thermode(prb(ThermFami+ChanN), erb(ThermType+ChanN), DigiFilt(TerBuf[ChanN],TerFiltLev));
	if (Ter!=Therm_Off_Mark)
		Ter = (Ter+(int8_t)erb(&ThermCorr[ChanN].D))*(erw(&ThermCorr[ChanN].A)/1000.0);
    9bd0:	ff 24       	eor	r15, r15
    9bd2:	e7 fc       	sbrc	r14, 7
    9bd4:	f0 94       	com	r15
    9bd6:	ec 0e       	add	r14, r28
    9bd8:	fd 1e       	adc	r15, r29
    9bda:	00 27       	eor	r16, r16
    9bdc:	f7 fc       	sbrc	r15, 7
    9bde:	00 95       	com	r16
    9be0:	10 2f       	mov	r17, r16
    9be2:	c8 01       	movw	r24, r16
    9be4:	b7 01       	movw	r22, r14
    9be6:	0e 94 f4 77 	call	0xefe8	; 0xefe8 <__floatsisf>
    9bea:	7b 01       	movw	r14, r22
    9bec:	8c 01       	movw	r16, r24
    9bee:	cc 24       	eor	r12, r12
    9bf0:	dd 24       	eor	r13, r13
    9bf2:	c6 01       	movw	r24, r12
    9bf4:	b5 01       	movw	r22, r10
    9bf6:	0e 94 f2 77 	call	0xefe4	; 0xefe4 <__floatunsisf>
    9bfa:	20 e0       	ldi	r18, 0x00	; 0
    9bfc:	30 e0       	ldi	r19, 0x00	; 0
    9bfe:	4a e7       	ldi	r20, 0x7A	; 122
    9c00:	54 e4       	ldi	r21, 0x44	; 68
    9c02:	0e 94 5a 7c 	call	0xf8b4	; 0xf8b4 <__divsf3>
    9c06:	9b 01       	movw	r18, r22
    9c08:	ac 01       	movw	r20, r24
    9c0a:	c8 01       	movw	r24, r16
    9c0c:	b7 01       	movw	r22, r14
    9c0e:	0e 94 2f 78 	call	0xf05e	; 0xf05e <__mulsf3>
    9c12:	0e 94 c2 7c 	call	0xf984	; 0xf984 <__fixsfsi>
    9c16:	eb 01       	movw	r28, r22
    9c18:	b8 cf       	rjmp	.-144    	; 0x9b8a <ThermChan+0xa8>

00009c1a <ThermInit>:
}

// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
ThermInit(uint8_t ChanN)
{
    9c1a:	ef 92       	push	r14
    9c1c:	ff 92       	push	r15
    9c1e:	0f 93       	push	r16
    9c20:	1f 93       	push	r17
    9c22:	cf 93       	push	r28
    9c24:	df 93       	push	r29
    9c26:	f8 2e       	mov	r15, r24
	if (ChanN<TerReg) {
    9c28:	85 e0       	ldi	r24, 0x05	; 5
    9c2a:	8f 15       	cp	r24, r15
    9c2c:	68 f1       	brcs	.+90     	; 0x9c88 <ThermInit+0x6e>
    9c2e:	8f 2d       	mov	r24, r15
    9c30:	90 e0       	ldi	r25, 0x00	; 0
    9c32:	8c 01       	movw	r16, r24
    9c34:	00 0f       	add	r16, r16
    9c36:	11 1f       	adc	r17, r17
    9c38:	f8 01       	movw	r30, r16
    9c3a:	e7 53       	subi	r30, 0x37	; 55
    9c3c:	f7 4f       	sbci	r31, 0xF7	; 247
    9c3e:	c0 81       	ld	r28, Z
    9c40:	d1 81       	ldd	r29, Z+1	; 0x01
    9c42:	fc 01       	movw	r30, r24
    9c44:	ee 0f       	add	r30, r30
    9c46:	ff 1f       	adc	r31, r31
    9c48:	e2 95       	swap	r30
    9c4a:	f2 95       	swap	r31
    9c4c:	f0 7f       	andi	r31, 0xF0	; 240
    9c4e:	fe 27       	eor	r31, r30
    9c50:	e0 7f       	andi	r30, 0xF0	; 240
    9c52:	fe 27       	eor	r31, r30
    9c54:	e8 50       	subi	r30, 0x08	; 8
    9c56:	fb 4f       	sbci	r31, 0xFB	; 251
    9c58:	20 e0       	ldi	r18, 0x00	; 0
		for (uint8_t i=0; i<TerFiltLev*4; TerBuf[ChanN][i++]=TerInput[ChanN]);
    9c5a:	c1 93       	st	Z+, r28
    9c5c:	d1 93       	st	Z+, r29
    9c5e:	2f 5f       	subi	r18, 0xFF	; 255
    9c60:	20 31       	cpi	r18, 0x10	; 16
    9c62:	d9 f7       	brne	.-10     	; 0x9c5a <ThermInit+0x40>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    9c64:	fc 01       	movw	r30, r24
    9c66:	ef 57       	subi	r30, 0x7F	; 127
    9c68:	f9 4f       	sbci	r31, 0xF9	; 249
    9c6a:	e4 90       	lpm	r14, Z+
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    9c6c:	89 5e       	subi	r24, 0xE9	; 233
    9c6e:	9e 4f       	sbci	r25, 0xFE	; 254
    9c70:	0e 94 03 7d 	call	0xfa06	; 0xfa06 <__eerd_byte_m2560>
    9c74:	68 2f       	mov	r22, r24
		Temperature[ChanN] = Thermode(prb(ThermFami+ChanN), erb(ThermType+ChanN), TerInput[ChanN]);
    9c76:	8e 2d       	mov	r24, r14
    9c78:	ae 01       	movw	r20, r28
    9c7a:	0e 94 6f 3e 	call	0x7cde	; 0x7cde <Thermode>
    9c7e:	04 5c       	subi	r16, 0xC4	; 196
    9c80:	19 4f       	sbci	r17, 0xF9	; 249
    9c82:	f8 01       	movw	r30, r16
    9c84:	91 83       	std	Z+1, r25	; 0x01
    9c86:	80 83       	st	Z, r24
    9c88:	80 e0       	ldi	r24, 0x00	; 0
    9c8a:	f5 e0       	ldi	r31, 0x05	; 5
    9c8c:	ff 12       	cpse	r15, r31
    9c8e:	81 e0       	ldi	r24, 0x01	; 1
	}
	return ChanN!=TerReg-1;
}
    9c90:	df 91       	pop	r29
    9c92:	cf 91       	pop	r28
    9c94:	1f 91       	pop	r17
    9c96:	0f 91       	pop	r16
    9c98:	ff 90       	pop	r15
    9c9a:	ef 90       	pop	r14
    9c9c:	08 95       	ret

00009c9e <DigitIn>:
}

// ~~~~~~~~~~
void
DigitIn(void)
{
    9c9e:	cf 93       	push	r28
    9ca0:	df 93       	push	r29
	memcpy(DigInput.StateOld, DigInput.State, DI_Reg+DI_Reg_Ext);
    9ca2:	e5 ef       	ldi	r30, 0xF5	; 245
    9ca4:	f6 e0       	ldi	r31, 0x06	; 6
    9ca6:	df 01       	movw	r26, r30
    9ca8:	13 97       	sbiw	r26, 0x03	; 3
    9caa:	83 e0       	ldi	r24, 0x03	; 3
    9cac:	0d 90       	ld	r0, X+
    9cae:	01 92       	st	Z+, r0
    9cb0:	81 50       	subi	r24, 0x01	; 1
    9cb2:	e1 f7       	brne	.-8      	; 0x9cac <DigitIn+0xe>
    9cb4:	84 e1       	ldi	r24, 0x14	; 20
    9cb6:	91 e0       	ldi	r25, 0x01	; 1
    9cb8:	0e 94 03 7d 	call	0xfa06	; 0xfa06 <__eerd_byte_m2560>
	for (uint8_t i=0; i<DI_Reg; i++)
		DigInput.Status[i] = DigInput.State[i]^erb(DI_Invers+i);
    9cbc:	90 91 f2 06 	lds	r25, 0x06F2
    9cc0:	98 27       	eor	r25, r24
    9cc2:	90 93 f8 06 	sts	0x06F8, r25
    9cc6:	85 e1       	ldi	r24, 0x15	; 21
    9cc8:	91 e0       	ldi	r25, 0x01	; 1
    9cca:	0e 94 03 7d 	call	0xfa06	; 0xfa06 <__eerd_byte_m2560>
    9cce:	90 91 f3 06 	lds	r25, 0x06F3
    9cd2:	98 27       	eor	r25, r24
    9cd4:	90 93 f9 06 	sts	0x06F9, r25
    9cd8:	86 e1       	ldi	r24, 0x16	; 22
    9cda:	91 e0       	ldi	r25, 0x01	; 1
    9cdc:	0e 94 03 7d 	call	0xfa06	; 0xfa06 <__eerd_byte_m2560>
    9ce0:	90 91 f4 06 	lds	r25, 0x06F4
    9ce4:	98 27       	eor	r25, r24
    9ce6:	90 93 fa 06 	sts	0x06FA, r25
    9cea:	40 e0       	ldi	r20, 0x00	; 0
    9cec:	50 e0       	ldi	r21, 0x00	; 0
#else
	static void
	DigitIn_Hard(void)
	{
		for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
			uint8_t Byte=D_N/8, Bit=1<<D_N%8;
    9cee:	a1 e0       	ldi	r26, 0x01	; 1
    9cf0:	b0 e0       	ldi	r27, 0x00	; 0
    9cf2:	1b c0       	rjmp	.+54     	; 0x9d2a <DigitIn+0x8c>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    9cf4:	c9 01       	movw	r24, r18
    9cf6:	85 5f       	subi	r24, 0xF5	; 245
    9cf8:	94 4d       	sbci	r25, 0xD4	; 212
    9cfa:	fc 01       	movw	r30, r24
    9cfc:	c5 91       	lpm	r28, Z+
    9cfe:	d4 91       	lpm	r29, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    9d00:	23 5f       	subi	r18, 0xF3	; 243
    9d02:	34 4d       	sbci	r19, 0xD4	; 212
    9d04:	f9 01       	movw	r30, r18
    9d06:	84 91       	lpm	r24, Z+
			if(prb(&DI_M[D_N].Inversion)){
				if (*(uint8_t*)prp(&DI_M[D_N].PIN) & prb(&DI_M[D_N].P))
    9d08:	98 81       	ld	r25, Y
    9d0a:	89 23       	and	r24, r25
    9d0c:	09 f4       	brne	.+2      	; 0x9d10 <DigitIn+0x72>
    9d0e:	3d c0       	rjmp	.+122    	; 0x9d8a <DigitIn+0xec>
			}
			else{
				if (*(uint8_t*)prp(&DI_M[D_N].PIN) & prb(&DI_M[D_N].P))
					DigInput.State[Byte] &=~Bit;
				else
					DigInput.State[Byte]  |=Bit;
    9d10:	e7 2f       	mov	r30, r23
    9d12:	f0 e0       	ldi	r31, 0x00	; 0
    9d14:	ee 50       	subi	r30, 0x0E	; 14
    9d16:	f9 4f       	sbci	r31, 0xF9	; 249
    9d18:	80 81       	ld	r24, Z
    9d1a:	86 2b       	or	r24, r22
    9d1c:	80 83       	st	Z, r24
    9d1e:	4f 5f       	subi	r20, 0xFF	; 255
    9d20:	5f 4f       	sbci	r21, 0xFF	; 255
	void DigitIn_Hard(void);
#else
	static void
	DigitIn_Hard(void)
	{
		for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
    9d22:	42 31       	cpi	r20, 0x12	; 18
    9d24:	51 05       	cpc	r21, r1
    9d26:	09 f4       	brne	.+2      	; 0x9d2a <DigitIn+0x8c>
    9d28:	3e c0       	rjmp	.+124    	; 0x9da6 <DigitIn+0x108>
			uint8_t Byte=D_N/8, Bit=1<<D_N%8;
    9d2a:	74 2f       	mov	r23, r20
    9d2c:	76 95       	lsr	r23
    9d2e:	76 95       	lsr	r23
    9d30:	76 95       	lsr	r23
    9d32:	ca 01       	movw	r24, r20
    9d34:	87 70       	andi	r24, 0x07	; 7
    9d36:	90 70       	andi	r25, 0x00	; 0
    9d38:	9d 01       	movw	r18, r26
    9d3a:	02 c0       	rjmp	.+4      	; 0x9d40 <DigitIn+0xa2>
    9d3c:	22 0f       	add	r18, r18
    9d3e:	33 1f       	adc	r19, r19
    9d40:	8a 95       	dec	r24
    9d42:	e2 f7       	brpl	.-8      	; 0x9d3c <DigitIn+0x9e>
    9d44:	62 2f       	mov	r22, r18
    9d46:	9a 01       	movw	r18, r20
    9d48:	22 0f       	add	r18, r18
    9d4a:	33 1f       	adc	r19, r19
    9d4c:	22 0f       	add	r18, r18
    9d4e:	33 1f       	adc	r19, r19
    9d50:	22 0f       	add	r18, r18
    9d52:	33 1f       	adc	r19, r19
    9d54:	f9 01       	movw	r30, r18
    9d56:	e2 5f       	subi	r30, 0xF2	; 242
    9d58:	f4 4d       	sbci	r31, 0xD4	; 212
    9d5a:	e4 91       	lpm	r30, Z+
			if(prb(&DI_M[D_N].Inversion)){
    9d5c:	ee 23       	and	r30, r30
    9d5e:	09 f0       	breq	.+2      	; 0x9d62 <DigitIn+0xc4>
    9d60:	c9 cf       	rjmp	.-110    	; 0x9cf4 <DigitIn+0x56>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    9d62:	ca 01       	movw	r24, r20
    9d64:	88 0f       	add	r24, r24
    9d66:	99 1f       	adc	r25, r25
    9d68:	88 0f       	add	r24, r24
    9d6a:	99 1f       	adc	r25, r25
    9d6c:	88 0f       	add	r24, r24
    9d6e:	99 1f       	adc	r25, r25
    9d70:	85 5f       	subi	r24, 0xF5	; 245
    9d72:	94 4d       	sbci	r25, 0xD4	; 212
    9d74:	fc 01       	movw	r30, r24
    9d76:	c5 91       	lpm	r28, Z+
    9d78:	d4 91       	lpm	r29, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    9d7a:	23 5f       	subi	r18, 0xF3	; 243
    9d7c:	34 4d       	sbci	r19, 0xD4	; 212
    9d7e:	f9 01       	movw	r30, r18
    9d80:	84 91       	lpm	r24, Z+
					DigInput.State[Byte] |=Bit;
				else
					DigInput.State[Byte] &=~Bit;
			}
			else{
				if (*(uint8_t*)prp(&DI_M[D_N].PIN) & prb(&DI_M[D_N].P))
    9d82:	98 81       	ld	r25, Y
    9d84:	89 23       	and	r24, r25
    9d86:	09 f4       	brne	.+2      	; 0x9d8a <DigitIn+0xec>
    9d88:	c3 cf       	rjmp	.-122    	; 0x9d10 <DigitIn+0x72>
					DigInput.State[Byte] &=~Bit;
    9d8a:	e7 2f       	mov	r30, r23
    9d8c:	f0 e0       	ldi	r31, 0x00	; 0
    9d8e:	ee 50       	subi	r30, 0x0E	; 14
    9d90:	f9 4f       	sbci	r31, 0xF9	; 249
    9d92:	60 95       	com	r22
    9d94:	80 81       	ld	r24, Z
    9d96:	68 23       	and	r22, r24
    9d98:	60 83       	st	Z, r22
				else
					DigInput.State[Byte]  |=Bit;
    9d9a:	4f 5f       	subi	r20, 0xFF	; 255
    9d9c:	5f 4f       	sbci	r21, 0xFF	; 255
	void DigitIn_Hard(void);
#else
	static void
	DigitIn_Hard(void)
	{
		for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
    9d9e:	42 31       	cpi	r20, 0x12	; 18
    9da0:	51 05       	cpc	r21, r1
    9da2:	09 f0       	breq	.+2      	; 0x9da6 <DigitIn+0x108>
    9da4:	c2 cf       	rjmp	.-124    	; 0x9d2a <DigitIn+0x8c>
			DigInput.State[j]		= (DigInput_Ext)[i];
			DigInput.Status[j]	= (DigInput_Ext)[i+DI_Reg_Ext];
			IntOn();
		}
	#endif
}
    9da6:	df 91       	pop	r29
    9da8:	cf 91       	pop	r28
    9daa:	08 95       	ret

00009dac <Field2Buf>:
	else return 0;
}
// ~~~~~~~~~~~~~~~~~~~~~~~
static void
Field2Buf(OutField *Field)
{
    9dac:	6f 92       	push	r6
    9dae:	7f 92       	push	r7
    9db0:	8f 92       	push	r8
    9db2:	9f 92       	push	r9
    9db4:	af 92       	push	r10
    9db6:	bf 92       	push	r11
    9db8:	cf 92       	push	r12
    9dba:	df 92       	push	r13
    9dbc:	ef 92       	push	r14
    9dbe:	ff 92       	push	r15
    9dc0:	0f 93       	push	r16
    9dc2:	1f 93       	push	r17
    9dc4:	df 93       	push	r29
    9dc6:	cf 93       	push	r28
    9dc8:	cd b7       	in	r28, 0x3d	; 61
    9dca:	de b7       	in	r29, 0x3e	; 62
    9dcc:	6f 97       	sbiw	r28, 0x1f	; 31
    9dce:	0f b6       	in	r0, 0x3f	; 63
    9dd0:	f8 94       	cli
    9dd2:	de bf       	out	0x3e, r29	; 62
    9dd4:	0f be       	out	0x3f, r0	; 63
    9dd6:	cd bf       	out	0x3d, r28	; 61
    9dd8:	7c 01       	movw	r14, r24

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    9dda:	fc 01       	movw	r30, r24
    9ddc:	31 96       	adiw	r30, 0x01	; 1
    9dde:	c5 90       	lpm	r12, Z+
    9de0:	d4 90       	lpm	r13, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    9de2:	bf e0       	ldi	r27, 0x0F	; 15
    9de4:	8b 2e       	mov	r8, r27
    9de6:	91 2c       	mov	r9, r1
    9de8:	88 0e       	add	r8, r24
    9dea:	99 1e       	adc	r9, r25
    9dec:	f4 01       	movw	r30, r8
    9dee:	24 91       	lpm	r18, Z+
	void *Var = prp(&Field->Var);
	uint8_t BitN=prb(&Field->Prec), Mask=1<<BitN%8, *BitVar=(uint8_t*)Var+BitN/8;
    9df0:	32 2f       	mov	r19, r18
    9df2:	37 70       	andi	r19, 0x07	; 7
    9df4:	81 e0       	ldi	r24, 0x01	; 1
    9df6:	90 e0       	ldi	r25, 0x00	; 0
    9df8:	18 2f       	mov	r17, r24
    9dfa:	01 c0       	rjmp	.+2      	; 0x9dfe <Field2Buf+0x52>
    9dfc:	11 0f       	add	r17, r17
    9dfe:	3a 95       	dec	r19
    9e00:	ea f7       	brpl	.-6      	; 0x9dfc <Field2Buf+0x50>
    9e02:	26 95       	lsr	r18
    9e04:	26 95       	lsr	r18
    9e06:	26 95       	lsr	r18
    9e08:	56 01       	movw	r10, r12
    9e0a:	a2 0e       	add	r10, r18
    9e0c:	b1 1c       	adc	r11, r1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    9e0e:	a7 e0       	ldi	r26, 0x07	; 7
    9e10:	6a 2e       	mov	r6, r26
    9e12:	71 2c       	mov	r7, r1
    9e14:	6e 0c       	add	r6, r14
    9e16:	7f 1c       	adc	r7, r15
    9e18:	f3 01       	movw	r30, r6
    9e1a:	65 91       	lpm	r22, Z+
    9e1c:	75 91       	lpm	r23, Z+
    9e1e:	85 91       	lpm	r24, Z+
    9e20:	94 91       	lpm	r25, Z+
	uint8_t Pos=Log10(prd(&Field->Max));
    9e22:	0e 94 f3 1f 	call	0x3fe6	; 0x3fe6 <Log10>
    9e26:	08 2f       	mov	r16, r24

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    9e28:	f7 01       	movw	r30, r14
    9e2a:	84 91       	lpm	r24, Z+
	uint8_t Oldstyle = 0;

	switch(prb(&Field->Type)) {
    9e2c:	e8 2f       	mov	r30, r24
    9e2e:	f0 e0       	ldi	r31, 0x00	; 0
    9e30:	e1 32       	cpi	r30, 0x21	; 33
    9e32:	f1 05       	cpc	r31, r1
    9e34:	08 f4       	brcc	.+2      	; 0x9e38 <Field2Buf+0x8c>
    9e36:	6e c0       	rjmp	.+220    	; 0x9f14 <Field2Buf+0x168>
		F_Buf = (erb(BitVar) &Mask) > 0;
		Oldstyle = 1;
		break;
	}

	Minus=0;
    9e38:	10 92 f6 04 	sts	0x04F6, r1
	if(Oldstyle) return;

	InitBufStr(Field);
    9e3c:	c7 01       	movw	r24, r14
    9e3e:	0e 94 4d 3b 	call	0x769a	; 0x769a <InitBufStr>
	CurrFieldSize = GetCurrFieldSize();
    9e42:	0e 94 0f 3c 	call	0x781e	; 0x781e <GetCurrFieldSize>
    9e46:	48 2f       	mov	r20, r24
    9e48:	80 93 70 07 	sts	0x0770, r24
	CurrPos = CurrFieldSize - 1;
    9e4c:	41 50       	subi	r20, 0x01	; 1
    9e4e:	40 93 d4 02 	sts	0x02D4, r20
    9e52:	4f 5f       	subi	r20, 0xFF	; 255
	float fTemp;
	T_Param Param;
	Param.Size = CurrFieldSize;
    9e54:	48 87       	std	Y+8, r20	; 0x08
	Param.Pos = BufStr;
    9e56:	8a eb       	ldi	r24, 0xBA	; 186
    9e58:	95 e0       	ldi	r25, 0x05	; 5
    9e5a:	9e 83       	std	Y+6, r25	; 0x06
    9e5c:	8d 83       	std	Y+5, r24	; 0x05
    9e5e:	f4 01       	movw	r30, r8
    9e60:	84 91       	lpm	r24, Z+
	Param.Prec = prb(&Field->Prec);
    9e62:	8f 83       	std	Y+7, r24	; 0x07
	Param.Txt = NULL;
    9e64:	1a 86       	std	Y+10, r1	; 0x0a
    9e66:	19 86       	std	Y+9, r1	; 0x09
    9e68:	f7 01       	movw	r30, r14
    9e6a:	84 91       	lpm	r24, Z+

	switch(prb(&Field->Type)) {
    9e6c:	85 31       	cpi	r24, 0x15	; 21
    9e6e:	09 f4       	brne	.+2      	; 0x9e72 <Field2Buf+0xc6>
    9e70:	74 c1       	rjmp	.+744    	; 0xa15a <Field2Buf+0x3ae>
    9e72:	86 31       	cpi	r24, 0x16	; 22
    9e74:	08 f4       	brcc	.+2      	; 0x9e78 <Field2Buf+0xcc>
    9e76:	56 c1       	rjmp	.+684    	; 0xa124 <Field2Buf+0x378>
    9e78:	8b 31       	cpi	r24, 0x1B	; 27
    9e7a:	09 f4       	brne	.+2      	; 0x9e7e <Field2Buf+0xd2>
    9e7c:	fe c1       	rjmp	.+1020   	; 0xa27a <Field2Buf+0x4ce>
    9e7e:	8c 31       	cpi	r24, 0x1C	; 28
    9e80:	08 f0       	brcs	.+2      	; 0x9e84 <Field2Buf+0xd8>
    9e82:	b7 c1       	rjmp	.+878    	; 0xa1f2 <Field2Buf+0x446>
    9e84:	89 31       	cpi	r24, 0x19	; 25
    9e86:	09 f4       	brne	.+2      	; 0x9e8a <Field2Buf+0xde>
    9e88:	92 c1       	rjmp	.+804    	; 0xa1ae <Field2Buf+0x402>
    9e8a:	8a 31       	cpi	r24, 0x1A	; 26
    9e8c:	09 f0       	breq	.+2      	; 0x9e90 <Field2Buf+0xe4>
    9e8e:	5b c0       	rjmp	.+182    	; 0x9f46 <Field2Buf+0x19a>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    9e90:	7e 01       	movw	r14, r28
    9e92:	08 94       	sec
    9e94:	e1 1c       	adc	r14, r1
    9e96:	f1 1c       	adc	r15, r1
    9e98:	c7 01       	movw	r24, r14
    9e9a:	b6 01       	movw	r22, r12
    9e9c:	44 e0       	ldi	r20, 0x04	; 4
    9e9e:	50 e0       	ldi	r21, 0x00	; 0
    9ea0:	0e 94 f3 7c 	call	0xf9e6	; 0xf9e6 <__eerd_block_m2560>
		Put_FFVal(*(float*)Var, &Param);
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
		break;
	case EE_FFloat:
		erbl(&fTemp, Var, 4);
		Put_FFVal(fTemp, &Param);
    9ea4:	69 81       	ldd	r22, Y+1	; 0x01
    9ea6:	7a 81       	ldd	r23, Y+2	; 0x02
    9ea8:	8b 81       	ldd	r24, Y+3	; 0x03
    9eaa:	9c 81       	ldd	r25, Y+4	; 0x04
    9eac:	8e 01       	movw	r16, r28
    9eae:	0b 5f       	subi	r16, 0xFB	; 251
    9eb0:	1f 4f       	sbci	r17, 0xFF	; 255
    9eb2:	a8 01       	movw	r20, r16
    9eb4:	0e 94 f3 42 	call	0x85e6	; 0x85e6 <Put_FFVal>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
    9eb8:	82 e7       	ldi	r24, 0x72	; 114
    9eba:	96 e0       	ldi	r25, 0x06	; 6
    9ebc:	60 91 ba 05 	lds	r22, 0x05BA
    9ec0:	0e 94 bc 3f 	call	0x7f78	; 0x7f78 <GetMultiSymbol>
    9ec4:	80 93 eb 04 	sts	0x04EB, r24
	case GFloat:
		Put_GFVal(*(float*)Var, &Param);
    9ec8:	f6 01       	movw	r30, r12
    9eca:	60 81       	ld	r22, Z
    9ecc:	71 81       	ldd	r23, Z+1	; 0x01
    9ece:	82 81       	ldd	r24, Z+2	; 0x02
    9ed0:	93 81       	ldd	r25, Z+3	; 0x03
    9ed2:	a8 01       	movw	r20, r16
    9ed4:	0e 94 79 42 	call	0x84f2	; 0x84f2 <Put_GFVal>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
    9ed8:	82 e7       	ldi	r24, 0x72	; 114
    9eda:	96 e0       	ldi	r25, 0x06	; 6
    9edc:	60 91 ba 05 	lds	r22, 0x05BA
    9ee0:	0e 94 bc 3f 	call	0x7f78	; 0x7f78 <GetMultiSymbol>
    9ee4:	80 93 eb 04 	sts	0x04EB, r24
    9ee8:	c7 01       	movw	r24, r14
    9eea:	b6 01       	movw	r22, r12
    9eec:	44 e0       	ldi	r20, 0x04	; 4
    9eee:	50 e0       	ldi	r21, 0x00	; 0
    9ef0:	0e 94 f3 7c 	call	0xf9e6	; 0xf9e6 <__eerd_block_m2560>
	case EE_GFloat:
		erbl(&fTemp, Var, 4);
		Put_GFVal(fTemp, &Param);
    9ef4:	69 81       	ldd	r22, Y+1	; 0x01
    9ef6:	7a 81       	ldd	r23, Y+2	; 0x02
    9ef8:	8b 81       	ldd	r24, Y+3	; 0x03
    9efa:	9c 81       	ldd	r25, Y+4	; 0x04
    9efc:	a8 01       	movw	r20, r16
    9efe:	0e 94 79 42 	call	0x84f2	; 0x84f2 <Put_GFVal>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
    9f02:	82 e7       	ldi	r24, 0x72	; 114
    9f04:	96 e0       	ldi	r25, 0x06	; 6
    9f06:	60 91 ba 05 	lds	r22, 0x05BA
    9f0a:	0e 94 bc 3f 	call	0x7f78	; 0x7f78 <GetMultiSymbol>
    9f0e:	80 93 eb 04 	sts	0x04EB, r24
    9f12:	19 c0       	rjmp	.+50     	; 0x9f46 <Field2Buf+0x19a>
	void *Var = prp(&Field->Var);
	uint8_t BitN=prb(&Field->Prec), Mask=1<<BitN%8, *BitVar=(uint8_t*)Var+BitN/8;
	uint8_t Pos=Log10(prd(&Field->Max));
	uint8_t Oldstyle = 0;

	switch(prb(&Field->Type)) {
    9f14:	ee 58       	subi	r30, 0x8E	; 142
    9f16:	ff 4f       	sbci	r31, 0xFF	; 255
    9f18:	ee 0f       	add	r30, r30
    9f1a:	ff 1f       	adc	r31, r31
    9f1c:	05 90       	lpm	r0, Z+
    9f1e:	f4 91       	lpm	r31, Z+
    9f20:	e0 2d       	mov	r30, r0
    9f22:	19 94       	eijmp
	case Byte: case z_Byte:
		F_Buf = *(uint8_t*)Var;
    9f24:	f6 01       	movw	r30, r12
    9f26:	80 81       	ld	r24, Z
    9f28:	90 e0       	ldi	r25, 0x00	; 0
    9f2a:	a0 e0       	ldi	r26, 0x00	; 0
    9f2c:	b0 e0       	ldi	r27, 0x00	; 0
    9f2e:	80 93 ee 04 	sts	0x04EE, r24
    9f32:	90 93 ef 04 	sts	0x04EF, r25
    9f36:	a0 93 f0 04 	sts	0x04F0, r26
    9f3a:	b0 93 f1 04 	sts	0x04F1, r27
		CurrPos = Pos;
    9f3e:	00 93 d4 02 	sts	0x02D4, r16
		F_Buf = (erb(BitVar) &Mask) > 0;
		Oldstyle = 1;
		break;
	}

	Minus=0;
    9f42:	10 92 f6 04 	sts	0x04F6, r1
				MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[0]);
			else MultiSymbol = GetMultiSymbol(Symbols_P, BufStr[0]);
		}
		break;
	}
}
    9f46:	6f 96       	adiw	r28, 0x1f	; 31
    9f48:	0f b6       	in	r0, 0x3f	; 63
    9f4a:	f8 94       	cli
    9f4c:	de bf       	out	0x3e, r29	; 62
    9f4e:	0f be       	out	0x3f, r0	; 63
    9f50:	cd bf       	out	0x3d, r28	; 61
    9f52:	cf 91       	pop	r28
    9f54:	df 91       	pop	r29
    9f56:	1f 91       	pop	r17
    9f58:	0f 91       	pop	r16
    9f5a:	ff 90       	pop	r15
    9f5c:	ef 90       	pop	r14
    9f5e:	df 90       	pop	r13
    9f60:	cf 90       	pop	r12
    9f62:	bf 90       	pop	r11
    9f64:	af 90       	pop	r10
    9f66:	9f 90       	pop	r9
    9f68:	8f 90       	pop	r8
    9f6a:	7f 90       	pop	r7
    9f6c:	6f 90       	pop	r6
    9f6e:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    9f70:	c6 01       	movw	r24, r12
    9f72:	0e 94 03 7d 	call	0xfa06	; 0xfa06 <__eerd_byte_m2560>
		sF_Buf = *(int8_t*)Var;
		CurrPos = Pos+1;
		Oldstyle = 1;
		break;
	case EE_Byte: case z_EE_Byte:
		F_Buf = erb((uint8_t*)Var);
    9f76:	90 e0       	ldi	r25, 0x00	; 0
    9f78:	a0 e0       	ldi	r26, 0x00	; 0
    9f7a:	b0 e0       	ldi	r27, 0x00	; 0
    9f7c:	80 93 ee 04 	sts	0x04EE, r24
    9f80:	90 93 ef 04 	sts	0x04EF, r25
    9f84:	a0 93 f0 04 	sts	0x04F0, r26
    9f88:	b0 93 f1 04 	sts	0x04F1, r27
		CurrPos = Pos;
    9f8c:	00 93 d4 02 	sts	0x02D4, r16
    9f90:	d8 cf       	rjmp	.-80     	; 0x9f42 <Field2Buf+0x196>
		F_Buf = *(uint8_t*)Var;
		CurrPos = Pos;
		Oldstyle = 1;
		break;
	case s_Byte:
		sF_Buf = *(int8_t*)Var;
    9f92:	f6 01       	movw	r30, r12
    9f94:	80 81       	ld	r24, Z
    9f96:	99 27       	eor	r25, r25
    9f98:	87 fd       	sbrc	r24, 7
    9f9a:	90 95       	com	r25
    9f9c:	a9 2f       	mov	r26, r25
    9f9e:	b9 2f       	mov	r27, r25
    9fa0:	80 93 f2 04 	sts	0x04F2, r24
    9fa4:	90 93 f3 04 	sts	0x04F3, r25
    9fa8:	a0 93 f4 04 	sts	0x04F4, r26
    9fac:	b0 93 f5 04 	sts	0x04F5, r27
		CurrPos = Pos+1;
    9fb0:	0f 5f       	subi	r16, 0xFF	; 255
    9fb2:	00 93 d4 02 	sts	0x02D4, r16
    9fb6:	c5 cf       	rjmp	.-118    	; 0x9f42 <Field2Buf+0x196>
    9fb8:	c6 01       	movw	r24, r12
    9fba:	0e 94 03 7d 	call	0xfa06	; 0xfa06 <__eerd_byte_m2560>
		F_Buf = erb((uint8_t*)Var);
		CurrPos = Pos;
		Oldstyle = 1;
		break;
	case s_EE_Byte:
		sF_Buf = (int8_t)erb((uint8_t*)Var);
    9fbe:	99 27       	eor	r25, r25
    9fc0:	87 fd       	sbrc	r24, 7
    9fc2:	90 95       	com	r25
    9fc4:	a9 2f       	mov	r26, r25
    9fc6:	b9 2f       	mov	r27, r25
    9fc8:	80 93 f2 04 	sts	0x04F2, r24
    9fcc:	90 93 f3 04 	sts	0x04F3, r25
    9fd0:	a0 93 f4 04 	sts	0x04F4, r26
    9fd4:	b0 93 f5 04 	sts	0x04F5, r27
		CurrPos = Pos+1;
    9fd8:	0f 5f       	subi	r16, 0xFF	; 255
    9fda:	00 93 d4 02 	sts	0x02D4, r16
    9fde:	b1 cf       	rjmp	.-158    	; 0x9f42 <Field2Buf+0x196>
		Oldstyle = 1;
		break;

	case Word: case z_Word:
		F_Buf = *(uint16_t*)Var;
    9fe0:	f6 01       	movw	r30, r12
    9fe2:	80 81       	ld	r24, Z
    9fe4:	91 81       	ldd	r25, Z+1	; 0x01
    9fe6:	a0 e0       	ldi	r26, 0x00	; 0
    9fe8:	b0 e0       	ldi	r27, 0x00	; 0
    9fea:	80 93 ee 04 	sts	0x04EE, r24
    9fee:	90 93 ef 04 	sts	0x04EF, r25
    9ff2:	a0 93 f0 04 	sts	0x04F0, r26
    9ff6:	b0 93 f1 04 	sts	0x04F1, r27
		CurrPos = Pos;
    9ffa:	00 93 d4 02 	sts	0x02D4, r16
    9ffe:	a1 cf       	rjmp	.-190    	; 0x9f42 <Field2Buf+0x196>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    a000:	c6 01       	movw	r24, r12
    a002:	0e 94 11 7d 	call	0xfa22	; 0xfa22 <__eerd_word_m2560>
		Oldstyle = 1;
		break;
	case EE_Word: case z_EE_Word:
		F_Buf = erw((uint16_t*)Var);
    a006:	a0 e0       	ldi	r26, 0x00	; 0
    a008:	b0 e0       	ldi	r27, 0x00	; 0
    a00a:	80 93 ee 04 	sts	0x04EE, r24
    a00e:	90 93 ef 04 	sts	0x04EF, r25
    a012:	a0 93 f0 04 	sts	0x04F0, r26
    a016:	b0 93 f1 04 	sts	0x04F1, r27
		CurrPos = Pos;
    a01a:	00 93 d4 02 	sts	0x02D4, r16
    a01e:	91 cf       	rjmp	.-222    	; 0x9f42 <Field2Buf+0x196>
		Oldstyle = 1;
		break;
	case s_Word:
		sF_Buf = *(int16_t*)Var;
    a020:	f6 01       	movw	r30, r12
    a022:	80 81       	ld	r24, Z
    a024:	91 81       	ldd	r25, Z+1	; 0x01
    a026:	aa 27       	eor	r26, r26
    a028:	97 fd       	sbrc	r25, 7
    a02a:	a0 95       	com	r26
    a02c:	ba 2f       	mov	r27, r26
    a02e:	80 93 f2 04 	sts	0x04F2, r24
    a032:	90 93 f3 04 	sts	0x04F3, r25
    a036:	a0 93 f4 04 	sts	0x04F4, r26
    a03a:	b0 93 f5 04 	sts	0x04F5, r27
		CurrPos = Pos+1;
    a03e:	0f 5f       	subi	r16, 0xFF	; 255
    a040:	00 93 d4 02 	sts	0x02D4, r16
    a044:	7e cf       	rjmp	.-260    	; 0x9f42 <Field2Buf+0x196>
    a046:	c6 01       	movw	r24, r12
    a048:	0e 94 11 7d 	call	0xfa22	; 0xfa22 <__eerd_word_m2560>
		Oldstyle = 1;
		break;
	case s_EE_Word:
		sF_Buf = (int16_t)erw((uint16_t*)Var);
    a04c:	aa 27       	eor	r26, r26
    a04e:	97 fd       	sbrc	r25, 7
    a050:	a0 95       	com	r26
    a052:	ba 2f       	mov	r27, r26
    a054:	80 93 f2 04 	sts	0x04F2, r24
    a058:	90 93 f3 04 	sts	0x04F3, r25
    a05c:	a0 93 f4 04 	sts	0x04F4, r26
    a060:	b0 93 f5 04 	sts	0x04F5, r27
		CurrPos = Pos+1;
    a064:	0f 5f       	subi	r16, 0xFF	; 255
    a066:	00 93 d4 02 	sts	0x02D4, r16
    a06a:	6b cf       	rjmp	.-298    	; 0x9f42 <Field2Buf+0x196>
		Oldstyle = 1;
		break;
	case c_Word: case zc_Word:
		F_Buf = *(uint16_t*)Var;
    a06c:	f6 01       	movw	r30, r12
    a06e:	80 81       	ld	r24, Z
    a070:	91 81       	ldd	r25, Z+1	; 0x01
    a072:	a0 e0       	ldi	r26, 0x00	; 0
    a074:	b0 e0       	ldi	r27, 0x00	; 0
    a076:	80 93 ee 04 	sts	0x04EE, r24
    a07a:	90 93 ef 04 	sts	0x04EF, r25
    a07e:	a0 93 f0 04 	sts	0x04F0, r26
    a082:	b0 93 f1 04 	sts	0x04F1, r27
    a086:	5d cf       	rjmp	.-326    	; 0x9f42 <Field2Buf+0x196>
		Oldstyle = 1;
		break;

	case Enum:
		F_Buf = *(uint8_t*)Var;
    a088:	f6 01       	movw	r30, r12
    a08a:	80 81       	ld	r24, Z
    a08c:	90 e0       	ldi	r25, 0x00	; 0
    a08e:	a0 e0       	ldi	r26, 0x00	; 0
    a090:	b0 e0       	ldi	r27, 0x00	; 0
    a092:	80 93 ee 04 	sts	0x04EE, r24
    a096:	90 93 ef 04 	sts	0x04EF, r25
    a09a:	a0 93 f0 04 	sts	0x04F0, r26
    a09e:	b0 93 f1 04 	sts	0x04F1, r27
    a0a2:	4f cf       	rjmp	.-354    	; 0x9f42 <Field2Buf+0x196>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    a0a4:	c6 01       	movw	r24, r12
    a0a6:	0e 94 03 7d 	call	0xfa06	; 0xfa06 <__eerd_byte_m2560>
		Oldstyle = 1;
		break;
	case EE_Enum:
		F_Buf = erb((uint8_t*)Var);
    a0aa:	90 e0       	ldi	r25, 0x00	; 0
    a0ac:	a0 e0       	ldi	r26, 0x00	; 0
    a0ae:	b0 e0       	ldi	r27, 0x00	; 0
    a0b0:	80 93 ee 04 	sts	0x04EE, r24
    a0b4:	90 93 ef 04 	sts	0x04EF, r25
    a0b8:	a0 93 f0 04 	sts	0x04F0, r26
    a0bc:	b0 93 f1 04 	sts	0x04F1, r27
    a0c0:	40 cf       	rjmp	.-384    	; 0x9f42 <Field2Buf+0x196>
		Oldstyle = 1;
		break;
	case Bit:
		F_Buf = (*BitVar &Mask) > 0;
    a0c2:	20 e0       	ldi	r18, 0x00	; 0
    a0c4:	30 e0       	ldi	r19, 0x00	; 0
    a0c6:	40 e0       	ldi	r20, 0x00	; 0
    a0c8:	50 e0       	ldi	r21, 0x00	; 0
    a0ca:	f5 01       	movw	r30, r10
    a0cc:	80 81       	ld	r24, Z
    a0ce:	81 23       	and	r24, r17
    a0d0:	21 f5       	brne	.+72     	; 0xa11a <Field2Buf+0x36e>
    a0d2:	20 93 ee 04 	sts	0x04EE, r18
    a0d6:	30 93 ef 04 	sts	0x04EF, r19
    a0da:	40 93 f0 04 	sts	0x04F0, r20
    a0de:	50 93 f1 04 	sts	0x04F1, r21
    a0e2:	2f cf       	rjmp	.-418    	; 0x9f42 <Field2Buf+0x196>
    a0e4:	c5 01       	movw	r24, r10
    a0e6:	0e 94 03 7d 	call	0xfa06	; 0xfa06 <__eerd_byte_m2560>
		Oldstyle = 1;
		break;
	case EE_Bit:
		F_Buf = (erb(BitVar) &Mask) > 0;
    a0ea:	10 92 ee 04 	sts	0x04EE, r1
    a0ee:	10 92 ef 04 	sts	0x04EF, r1
    a0f2:	10 92 f0 04 	sts	0x04F0, r1
    a0f6:	10 92 f1 04 	sts	0x04F1, r1
    a0fa:	18 23       	and	r17, r24
    a0fc:	09 f4       	brne	.+2      	; 0xa100 <Field2Buf+0x354>
    a0fe:	21 cf       	rjmp	.-446    	; 0x9f42 <Field2Buf+0x196>
    a100:	81 e0       	ldi	r24, 0x01	; 1
    a102:	90 e0       	ldi	r25, 0x00	; 0
    a104:	a0 e0       	ldi	r26, 0x00	; 0
    a106:	b0 e0       	ldi	r27, 0x00	; 0
    a108:	80 93 ee 04 	sts	0x04EE, r24
    a10c:	90 93 ef 04 	sts	0x04EF, r25
    a110:	a0 93 f0 04 	sts	0x04F0, r26
    a114:	b0 93 f1 04 	sts	0x04F1, r27
    a118:	14 cf       	rjmp	.-472    	; 0x9f42 <Field2Buf+0x196>
	case EE_Enum:
		F_Buf = erb((uint8_t*)Var);
		Oldstyle = 1;
		break;
	case Bit:
		F_Buf = (*BitVar &Mask) > 0;
    a11a:	21 e0       	ldi	r18, 0x01	; 1
    a11c:	30 e0       	ldi	r19, 0x00	; 0
    a11e:	40 e0       	ldi	r20, 0x00	; 0
    a120:	50 e0       	ldi	r21, 0x00	; 0
    a122:	d7 cf       	rjmp	.-82     	; 0xa0d2 <Field2Buf+0x326>
	Param.Size = CurrFieldSize;
	Param.Pos = BufStr;
	Param.Prec = prb(&Field->Prec);
	Param.Txt = NULL;

	switch(prb(&Field->Type)) {
    a124:	82 31       	cpi	r24, 0x12	; 18
    a126:	51 f1       	breq	.+84     	; 0xa17c <Field2Buf+0x3d0>
    a128:	83 31       	cpi	r24, 0x13	; 19
    a12a:	08 f0       	brcs	.+2      	; 0xa12e <Field2Buf+0x382>
    a12c:	53 c0       	rjmp	.+166    	; 0xa1d4 <Field2Buf+0x428>
    a12e:	80 31       	cpi	r24, 0x10	; 16
    a130:	c1 f1       	breq	.+112    	; 0xa1a2 <Field2Buf+0x3f6>
    a132:	81 31       	cpi	r24, 0x11	; 17
    a134:	09 f0       	breq	.+2      	; 0xa138 <Field2Buf+0x38c>
    a136:	07 cf       	rjmp	.-498    	; 0x9f46 <Field2Buf+0x19a>
// ~~~~~~~~~~~~~~~~~~~~~~
uint32_t
erd(const uint32_t *addr)
{
	//IntOff();
	uint32_t word = eeprom_read_dword(addr);
    a138:	c6 01       	movw	r24, r12
    a13a:	0e 94 0b 7d 	call	0xfa16	; 0xfa16 <__eerd_dword_m2560>
	case z_Longint:
		Put_zDVal(*(uint32_t*)Var, &Param);
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
		break;
	case EE_Longint: 
		PutDVal(erd((uint32_t*)Var), &Param);
    a13e:	ae 01       	movw	r20, r28
    a140:	4b 5f       	subi	r20, 0xFB	; 251
    a142:	5f 4f       	sbci	r21, 0xFF	; 255
    a144:	0e 94 92 45 	call	0x8b24	; 0x8b24 <PutDVal>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
    a148:	82 e7       	ldi	r24, 0x72	; 114
    a14a:	96 e0       	ldi	r25, 0x06	; 6
    a14c:	60 91 ba 05 	lds	r22, 0x05BA
    a150:	0e 94 bc 3f 	call	0x7f78	; 0x7f78 <GetMultiSymbol>
    a154:	80 93 eb 04 	sts	0x04EB, r24
    a158:	f6 ce       	rjmp	.-532    	; 0x9f46 <Field2Buf+0x19a>
    a15a:	c6 01       	movw	r24, r12
    a15c:	0e 94 0b 7d 	call	0xfa16	; 0xfa16 <__eerd_dword_m2560>
		break;
	case z_EE_Longint:
		Put_zDVal(erd((uint32_t*)Var), &Param);
    a160:	ae 01       	movw	r20, r28
    a162:	4b 5f       	subi	r20, 0xFB	; 251
    a164:	5f 4f       	sbci	r21, 0xFF	; 255
    a166:	0e 94 48 43 	call	0x8690	; 0x8690 <Put_zDVal>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
    a16a:	82 e7       	ldi	r24, 0x72	; 114
    a16c:	96 e0       	ldi	r25, 0x06	; 6
    a16e:	60 91 ba 05 	lds	r22, 0x05BA
    a172:	0e 94 bc 3f 	call	0x7f78	; 0x7f78 <GetMultiSymbol>
    a176:	80 93 eb 04 	sts	0x04EB, r24
    a17a:	e5 ce       	rjmp	.-566    	; 0x9f46 <Field2Buf+0x19a>
		break;
	case s_Longint:
		Put_sDVal(*(int32_t*)Var, &Param);
    a17c:	f6 01       	movw	r30, r12
    a17e:	60 81       	ld	r22, Z
    a180:	71 81       	ldd	r23, Z+1	; 0x01
    a182:	82 81       	ldd	r24, Z+2	; 0x02
    a184:	93 81       	ldd	r25, Z+3	; 0x03
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
		break;
	case s_EE_Longint:
		Put_sDVal((int32_t)erd((uint32_t*)Var), &Param);
    a186:	ae 01       	movw	r20, r28
    a188:	4b 5f       	subi	r20, 0xFB	; 251
    a18a:	5f 4f       	sbci	r21, 0xFF	; 255
    a18c:	0e 94 69 44 	call	0x88d2	; 0x88d2 <Put_sDVal>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
    a190:	82 e7       	ldi	r24, 0x72	; 114
    a192:	96 e0       	ldi	r25, 0x06	; 6
    a194:	60 91 ba 05 	lds	r22, 0x05BA
    a198:	0e 94 bc 3f 	call	0x7f78	; 0x7f78 <GetMultiSymbol>
    a19c:	80 93 eb 04 	sts	0x04EB, r24
    a1a0:	d2 ce       	rjmp	.-604    	; 0x9f46 <Field2Buf+0x19a>
	Param.Prec = prb(&Field->Prec);
	Param.Txt = NULL;

	switch(prb(&Field->Type)) {
	case Longint:
		PutDVal(*(uint32_t*)Var, &Param);
    a1a2:	f6 01       	movw	r30, r12
    a1a4:	60 81       	ld	r22, Z
    a1a6:	71 81       	ldd	r23, Z+1	; 0x01
    a1a8:	82 81       	ldd	r24, Z+2	; 0x02
    a1aa:	93 81       	ldd	r25, Z+3	; 0x03
    a1ac:	c8 cf       	rjmp	.-112    	; 0xa13e <Field2Buf+0x392>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
		break;


	case FFloat:
		Put_FFVal(*(float*)Var, &Param);
    a1ae:	f6 01       	movw	r30, r12
    a1b0:	60 81       	ld	r22, Z
    a1b2:	71 81       	ldd	r23, Z+1	; 0x01
    a1b4:	82 81       	ldd	r24, Z+2	; 0x02
    a1b6:	93 81       	ldd	r25, Z+3	; 0x03
    a1b8:	ae 01       	movw	r20, r28
    a1ba:	4b 5f       	subi	r20, 0xFB	; 251
    a1bc:	5f 4f       	sbci	r21, 0xFF	; 255
    a1be:	0e 94 f3 42 	call	0x85e6	; 0x85e6 <Put_FFVal>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
    a1c2:	82 e7       	ldi	r24, 0x72	; 114
    a1c4:	96 e0       	ldi	r25, 0x06	; 6
    a1c6:	60 91 ba 05 	lds	r22, 0x05BA
    a1ca:	0e 94 bc 3f 	call	0x7f78	; 0x7f78 <GetMultiSymbol>
    a1ce:	80 93 eb 04 	sts	0x04EB, r24
    a1d2:	b9 ce       	rjmp	.-654    	; 0x9f46 <Field2Buf+0x19a>
	Param.Size = CurrFieldSize;
	Param.Pos = BufStr;
	Param.Prec = prb(&Field->Prec);
	Param.Txt = NULL;

	switch(prb(&Field->Type)) {
    a1d4:	83 31       	cpi	r24, 0x13	; 19
    a1d6:	49 f0       	breq	.+18     	; 0xa1ea <Field2Buf+0x43e>
    a1d8:	84 31       	cpi	r24, 0x14	; 20
    a1da:	09 f0       	breq	.+2      	; 0xa1de <Field2Buf+0x432>
    a1dc:	b4 ce       	rjmp	.-664    	; 0x9f46 <Field2Buf+0x19a>
	case Longint:
		PutDVal(*(uint32_t*)Var, &Param);
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
		break;
	case z_Longint:
		Put_zDVal(*(uint32_t*)Var, &Param);
    a1de:	f6 01       	movw	r30, r12
    a1e0:	60 81       	ld	r22, Z
    a1e2:	71 81       	ldd	r23, Z+1	; 0x01
    a1e4:	82 81       	ldd	r24, Z+2	; 0x02
    a1e6:	93 81       	ldd	r25, Z+3	; 0x03
    a1e8:	bb cf       	rjmp	.-138    	; 0xa160 <Field2Buf+0x3b4>
    a1ea:	c6 01       	movw	r24, r12
    a1ec:	0e 94 0b 7d 	call	0xfa16	; 0xfa16 <__eerd_dword_m2560>
    a1f0:	ca cf       	rjmp	.-108    	; 0xa186 <Field2Buf+0x3da>
	Param.Size = CurrFieldSize;
	Param.Pos = BufStr;
	Param.Prec = prb(&Field->Prec);
	Param.Txt = NULL;

	switch(prb(&Field->Type)) {
    a1f2:	81 32       	cpi	r24, 0x21	; 33
    a1f4:	69 f0       	breq	.+26     	; 0xa210 <Field2Buf+0x464>
    a1f6:	82 32       	cpi	r24, 0x22	; 34
    a1f8:	69 f1       	breq	.+90     	; 0xa254 <Field2Buf+0x4a8>
    a1fa:	8c 31       	cpi	r24, 0x1C	; 28
    a1fc:	09 f0       	breq	.+2      	; 0xa200 <Field2Buf+0x454>
    a1fe:	a3 ce       	rjmp	.-698    	; 0x9f46 <Field2Buf+0x19a>
    a200:	8e 01       	movw	r16, r28
    a202:	0b 5f       	subi	r16, 0xFB	; 251
    a204:	1f 4f       	sbci	r17, 0xFF	; 255
    a206:	7e 01       	movw	r14, r28
    a208:	08 94       	sec
    a20a:	e1 1c       	adc	r14, r1
    a20c:	f1 1c       	adc	r15, r1
    a20e:	6c ce       	rjmp	.-808    	; 0x9ee8 <Field2Buf+0x13c>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
		break;


	case Text:
		Put_TextValAlignLeft((char*)Var, &Param);
    a210:	c6 01       	movw	r24, r12
		
		break;
	case EE_Text:{
			char TempStr[LCDXSz+1];
			erbl(TempStr, Var, CurrFieldSize);
			Put_TextValAlignLeft(TempStr, &Param);
    a212:	be 01       	movw	r22, r28
    a214:	6b 5f       	subi	r22, 0xFB	; 251
    a216:	7f 4f       	sbci	r23, 0xFF	; 255
    a218:	0e 94 c1 41 	call	0x8382	; 0x8382 <Put_TextValAlignLeft>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    a21c:	f7 01       	movw	r30, r14
    a21e:	33 96       	adiw	r30, 0x03	; 3
    a220:	85 91       	lpm	r24, Z+
    a222:	95 91       	lpm	r25, Z+
    a224:	a5 91       	lpm	r26, Z+
    a226:	b4 91       	lpm	r27, Z+
			if( (prd(&Field->Min) == DIGIT) && (prd(&Field->Max) == DIGIT) )
    a228:	00 97       	sbiw	r24, 0x00	; 0
    a22a:	a1 05       	cpc	r26, r1
    a22c:	b1 05       	cpc	r27, r1
    a22e:	49 f4       	brne	.+18     	; 0xa242 <Field2Buf+0x496>
    a230:	f3 01       	movw	r30, r6
    a232:	85 91       	lpm	r24, Z+
    a234:	95 91       	lpm	r25, Z+
    a236:	a5 91       	lpm	r26, Z+
    a238:	b4 91       	lpm	r27, Z+
    a23a:	00 97       	sbiw	r24, 0x00	; 0
    a23c:	a1 05       	cpc	r26, r1
    a23e:	b1 05       	cpc	r27, r1
    a240:	99 f0       	breq	.+38     	; 0xa268 <Field2Buf+0x4bc>
				MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[0]);
			else MultiSymbol = GetMultiSymbol(Symbols_P, BufStr[0]);
    a242:	89 ec       	ldi	r24, 0xC9	; 201
    a244:	95 e0       	ldi	r25, 0x05	; 5
    a246:	60 91 ba 05 	lds	r22, 0x05BA
    a24a:	0e 94 bc 3f 	call	0x7f78	; 0x7f78 <GetMultiSymbol>
    a24e:	80 93 eb 04 	sts	0x04EB, r24
    a252:	79 ce       	rjmp	.-782    	; 0x9f46 <Field2Buf+0x19a>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    a254:	8e 01       	movw	r16, r28
    a256:	05 5f       	subi	r16, 0xF5	; 245
    a258:	1f 4f       	sbci	r17, 0xFF	; 255
    a25a:	c8 01       	movw	r24, r16
    a25c:	b6 01       	movw	r22, r12
    a25e:	50 e0       	ldi	r21, 0x00	; 0
    a260:	0e 94 f3 7c 	call	0xf9e6	; 0xf9e6 <__eerd_block_m2560>
		
		break;
	case EE_Text:{
			char TempStr[LCDXSz+1];
			erbl(TempStr, Var, CurrFieldSize);
			Put_TextValAlignLeft(TempStr, &Param);
    a264:	c8 01       	movw	r24, r16
    a266:	d5 cf       	rjmp	.-86     	; 0xa212 <Field2Buf+0x466>
			if( (prd(&Field->Min) == DIGIT) && (prd(&Field->Max) == DIGIT) )
				MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[0]);
    a268:	87 e6       	ldi	r24, 0x67	; 103
    a26a:	96 e0       	ldi	r25, 0x06	; 6
    a26c:	60 91 ba 05 	lds	r22, 0x05BA
    a270:	0e 94 bc 3f 	call	0x7f78	; 0x7f78 <GetMultiSymbol>
    a274:	80 93 eb 04 	sts	0x04EB, r24
    a278:	66 ce       	rjmp	.-820    	; 0x9f46 <Field2Buf+0x19a>
    a27a:	8e 01       	movw	r16, r28
    a27c:	0b 5f       	subi	r16, 0xFB	; 251
    a27e:	1f 4f       	sbci	r17, 0xFF	; 255
    a280:	7e 01       	movw	r14, r28
    a282:	08 94       	sec
    a284:	e1 1c       	adc	r14, r1
    a286:	f1 1c       	adc	r15, r1
    a288:	1f ce       	rjmp	.-962    	; 0x9ec8 <Field2Buf+0x11c>

0000a28a <MenuEscLeft>:
}

// ~~~~~~~~~~~~~~
void
MenuEscLeft(void)
{
    a28a:	0f 93       	push	r16
    a28c:	1f 93       	push	r17
    a28e:	cf 93       	push	r28
    a290:	df 93       	push	r29
//	1) Hide current Message
	if(HideMsg()||KeyFunc(&CurrPage->Esc))
    a292:	0e 94 bd 3b 	call	0x777a	; 0x777a <HideMsg>
    a296:	88 23       	and	r24, r24
    a298:	29 f0       	breq	.+10     	; 0xa2a4 <MenuEscLeft+0x1a>
		else
			CurrPage=prp(&CurrPage->OutPage);
		CurrLine=CurrLCD=GetFix();
	}
	EventFunc(&CurrPage->Load);
}
    a29a:	df 91       	pop	r29
    a29c:	cf 91       	pop	r28
    a29e:	1f 91       	pop	r17
    a2a0:	0f 91       	pop	r16
    a2a2:	08 95       	ret
// ~~~~~~~~~~~~~~
void
MenuEscLeft(void)
{
//	1) Hide current Message
	if(HideMsg()||KeyFunc(&CurrPage->Esc))
    a2a4:	80 91 d1 02 	lds	r24, 0x02D1
    a2a8:	90 91 d2 02 	lds	r25, 0x02D2
    a2ac:	0e 96       	adiw	r24, 0x0e	; 14
    a2ae:	0e 94 63 3b 	call	0x76c6	; 0x76c6 <KeyFunc>
    a2b2:	88 23       	and	r24, r24
    a2b4:	91 f7       	brne	.-28     	; 0xa29a <MenuEscLeft+0x10>
		return;

// 2) Variable
	if(CurrField!=NullPos) {
    a2b6:	30 91 d3 02 	lds	r19, 0x02D3
    a2ba:	3f 3f       	cpi	r19, 0xFF	; 255
    a2bc:	09 f4       	brne	.+2      	; 0xa2c0 <MenuEscLeft+0x36>
    a2be:	c8 c0       	rjmp	.+400    	; 0xa450 <MenuEscLeft+0x1c6>
		if(CurrPos!=NullPos) {
    a2c0:	40 91 d4 02 	lds	r20, 0x02D4
    a2c4:	4f 3f       	cpi	r20, 0xFF	; 255
    a2c6:	09 f4       	brne	.+2      	; 0xa2ca <MenuEscLeft+0x40>
    a2c8:	5a c0       	rjmp	.+180    	; 0xa37e <MenuEscLeft+0xf4>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    a2ca:	80 91 d1 02 	lds	r24, 0x02D1
    a2ce:	90 91 d2 02 	lds	r25, 0x02D2
    a2d2:	fc 01       	movw	r30, r24
    a2d4:	65 91       	lpm	r22, Z+
    a2d6:	74 91       	lpm	r23, Z+
			OutField *Field=GetField;
    a2d8:	80 91 79 07 	lds	r24, 0x0779
    a2dc:	2b e1       	ldi	r18, 0x1B	; 27
    a2de:	82 9f       	mul	r24, r18
    a2e0:	c0 01       	movw	r24, r0
    a2e2:	11 24       	eor	r1, r1
    a2e4:	68 0f       	add	r22, r24
    a2e6:	79 1f       	adc	r23, r25
    a2e8:	69 5e       	subi	r22, 0xE9	; 233
    a2ea:	7f 4f       	sbci	r23, 0xFF	; 255
    a2ec:	fb 01       	movw	r30, r22
    a2ee:	c5 91       	lpm	r28, Z+
    a2f0:	d4 91       	lpm	r29, Z+
    a2f2:	83 2f       	mov	r24, r19
    a2f4:	90 e0       	ldi	r25, 0x00	; 0
    a2f6:	82 95       	swap	r24
    a2f8:	92 95       	swap	r25
    a2fa:	90 7f       	andi	r25, 0xF0	; 240
    a2fc:	98 27       	eor	r25, r24
    a2fe:	80 7f       	andi	r24, 0xF0	; 240
    a300:	98 27       	eor	r25, r24
    a302:	c8 0f       	add	r28, r24
    a304:	d9 1f       	adc	r29, r25

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    a306:	fe 01       	movw	r30, r28
    a308:	14 91       	lpm	r17, Z+
			uint8_t Type=prb(&Field->Type);
			uint8_t Pos;

			if( (Type == Text) || (Type == EE_Text) ||
    a30a:	01 2f       	mov	r16, r17
    a30c:	01 52       	subi	r16, 0x21	; 33
    a30e:	02 30       	cpi	r16, 0x02	; 2
    a310:	00 f1       	brcs	.+64     	; 0xa352 <MenuEscLeft+0xc8>
    a312:	10 31       	cpi	r17, 0x10	; 16
    a314:	f1 f0       	breq	.+60     	; 0xa352 <MenuEscLeft+0xc8>
    a316:	11 31       	cpi	r17, 0x11	; 17
    a318:	e1 f0       	breq	.+56     	; 0xa352 <MenuEscLeft+0xc8>
    a31a:	12 31       	cpi	r17, 0x12	; 18
    a31c:	d1 f0       	breq	.+52     	; 0xa352 <MenuEscLeft+0xc8>
    a31e:	13 31       	cpi	r17, 0x13	; 19
    a320:	c1 f0       	breq	.+48     	; 0xa352 <MenuEscLeft+0xc8>
    a322:	14 31       	cpi	r17, 0x14	; 20
    a324:	b1 f0       	breq	.+44     	; 0xa352 <MenuEscLeft+0xc8>
    a326:	15 31       	cpi	r17, 0x15	; 21
    a328:	a1 f0       	breq	.+40     	; 0xa352 <MenuEscLeft+0xc8>
    a32a:	19 31       	cpi	r17, 0x19	; 25
    a32c:	91 f0       	breq	.+36     	; 0xa352 <MenuEscLeft+0xc8>
    a32e:	1a 31       	cpi	r17, 0x1A	; 26
    a330:	81 f0       	breq	.+32     	; 0xa352 <MenuEscLeft+0xc8>
    a332:	1b 31       	cpi	r17, 0x1B	; 27
    a334:	71 f0       	breq	.+28     	; 0xa352 <MenuEscLeft+0xc8>
    a336:	1c 31       	cpi	r17, 0x1C	; 28
    a338:	61 f0       	breq	.+24     	; 0xa352 <MenuEscLeft+0xc8>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    a33a:	fe 01       	movw	r30, r28
    a33c:	37 96       	adiw	r30, 0x07	; 7
    a33e:	65 91       	lpm	r22, Z+
    a340:	75 91       	lpm	r23, Z+
    a342:	85 91       	lpm	r24, Z+
    a344:	94 91       	lpm	r25, Z+
			 (Type == Longint) || (Type == EE_Longint)|| (Type == s_Longint) || (Type == s_EE_Longint) || (Type == z_Longint) || (Type == z_EE_Longint) ||
			 (Type == FFloat) || (Type == EE_FFloat) || (Type == GFloat) || (Type == EE_GFloat) ) 
			 	Pos = CurrFieldSize-1;
			else Pos=Log10(prd(&Field->Max));
    a346:	0e 94 f3 1f 	call	0x3fe6	; 0x3fe6 <Log10>
    a34a:	98 2f       	mov	r25, r24
    a34c:	40 91 d4 02 	lds	r20, 0x02D4
    a350:	03 c0       	rjmp	.+6      	; 0xa358 <MenuEscLeft+0xce>
			uint8_t Pos;

			if( (Type == Text) || (Type == EE_Text) ||
			 (Type == Longint) || (Type == EE_Longint)|| (Type == s_Longint) || (Type == s_EE_Longint) || (Type == z_Longint) || (Type == z_EE_Longint) ||
			 (Type == FFloat) || (Type == EE_FFloat) || (Type == GFloat) || (Type == EE_GFloat) ) 
			 	Pos = CurrFieldSize-1;
    a352:	90 91 70 07 	lds	r25, 0x0770
    a356:	91 50       	subi	r25, 0x01	; 1
			else Pos=Log10(prd(&Field->Max));

			if(Type==s_Byte || Type==s_EE_Byte || Type==s_Word || Type==s_EE_Word)
    a358:	81 2f       	mov	r24, r17
    a35a:	82 50       	subi	r24, 0x02	; 2
    a35c:	82 30       	cpi	r24, 0x02	; 2
    a35e:	b0 f1       	brcs	.+108    	; 0xa3cc <MenuEscLeft+0x142>
    a360:	19 30       	cpi	r17, 0x09	; 9
    a362:	a1 f1       	breq	.+104    	; 0xa3cc <MenuEscLeft+0x142>
    a364:	1a 30       	cpi	r17, 0x0A	; 10
    a366:	91 f1       	breq	.+100    	; 0xa3cc <MenuEscLeft+0x142>
				Pos++;
			if(++CurrPos>Pos)
    a368:	24 2f       	mov	r18, r20
    a36a:	2f 5f       	subi	r18, 0xFF	; 255
    a36c:	20 93 d4 02 	sts	0x02D4, r18
    a370:	92 17       	cp	r25, r18
    a372:	70 f5       	brcc	.+92     	; 0xa3d0 <MenuEscLeft+0x146>
				CurrPos = NullPos;
    a374:	8f ef       	ldi	r24, 0xFF	; 255
    a376:	80 93 d4 02 	sts	0x02D4, r24
    a37a:	30 91 d3 02 	lds	r19, 0x02D3
				}
				return;
			}
		}
		//     
		if(--CurrField!=NullPos)
    a37e:	31 50       	subi	r19, 0x01	; 1
    a380:	30 93 d3 02 	sts	0x02D3, r19
    a384:	3f 3f       	cpi	r19, 0xFF	; 255
    a386:	09 f4       	brne	.+2      	; 0xa38a <MenuEscLeft+0x100>
    a388:	88 cf       	rjmp	.-240    	; 0xa29a <MenuEscLeft+0x10>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    a38a:	80 91 d1 02 	lds	r24, 0x02D1
    a38e:	90 91 d2 02 	lds	r25, 0x02D2
    a392:	fc 01       	movw	r30, r24
    a394:	45 91       	lpm	r20, Z+
    a396:	54 91       	lpm	r21, Z+
			Field2Buf(GetField);
    a398:	80 91 79 07 	lds	r24, 0x0779
    a39c:	2b e1       	ldi	r18, 0x1B	; 27
    a39e:	82 9f       	mul	r24, r18
    a3a0:	c0 01       	movw	r24, r0
    a3a2:	11 24       	eor	r1, r1
    a3a4:	48 0f       	add	r20, r24
    a3a6:	59 1f       	adc	r21, r25
    a3a8:	49 5e       	subi	r20, 0xE9	; 233
    a3aa:	5f 4f       	sbci	r21, 0xFF	; 255
    a3ac:	fa 01       	movw	r30, r20
    a3ae:	85 91       	lpm	r24, Z+
    a3b0:	94 91       	lpm	r25, Z+
    a3b2:	23 2f       	mov	r18, r19
    a3b4:	30 e0       	ldi	r19, 0x00	; 0
    a3b6:	22 95       	swap	r18
    a3b8:	32 95       	swap	r19
    a3ba:	30 7f       	andi	r19, 0xF0	; 240
    a3bc:	32 27       	eor	r19, r18
    a3be:	20 7f       	andi	r18, 0xF0	; 240
    a3c0:	32 27       	eor	r19, r18
    a3c2:	82 0f       	add	r24, r18
    a3c4:	93 1f       	adc	r25, r19
    a3c6:	0e 94 d6 4e 	call	0x9dac	; 0x9dac <Field2Buf>
    a3ca:	67 cf       	rjmp	.-306    	; 0xa29a <MenuEscLeft+0x10>
			 (Type == FFloat) || (Type == EE_FFloat) || (Type == GFloat) || (Type == EE_GFloat) ) 
			 	Pos = CurrFieldSize-1;
			else Pos=Log10(prd(&Field->Max));

			if(Type==s_Byte || Type==s_EE_Byte || Type==s_Word || Type==s_EE_Word)
				Pos++;
    a3cc:	9f 5f       	subi	r25, 0xFF	; 255
    a3ce:	cc cf       	rjmp	.-104    	; 0xa368 <MenuEscLeft+0xde>
			if(++CurrPos>Pos)
				CurrPos = NullPos;
			else{
				switch(Type){
    a3d0:	1d 31       	cpi	r17, 0x1D	; 29
    a3d2:	40 f1       	brcs	.+80     	; 0xa424 <MenuEscLeft+0x19a>
    a3d4:	02 30       	cpi	r16, 0x02	; 2
    a3d6:	08 f0       	brcs	.+2      	; 0xa3da <MenuEscLeft+0x150>
    a3d8:	60 cf       	rjmp	.-320    	; 0xa29a <MenuEscLeft+0x10>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    a3da:	fe 01       	movw	r30, r28
    a3dc:	33 96       	adiw	r30, 0x03	; 3
    a3de:	85 91       	lpm	r24, Z+
    a3e0:	95 91       	lpm	r25, Z+
    a3e2:	a5 91       	lpm	r26, Z+
    a3e4:	b4 91       	lpm	r27, Z+
				case Text: case EE_Text:
					if( (prd(&Field->Min) == DIGIT) && (prd(&Field->Max) == DIGIT) )
    a3e6:	00 97       	sbiw	r24, 0x00	; 0
    a3e8:	a1 05       	cpc	r26, r1
    a3ea:	b1 05       	cpc	r27, r1
    a3ec:	59 f4       	brne	.+22     	; 0xa404 <MenuEscLeft+0x17a>
    a3ee:	fe 01       	movw	r30, r28
    a3f0:	37 96       	adiw	r30, 0x07	; 7
    a3f2:	85 91       	lpm	r24, Z+
    a3f4:	95 91       	lpm	r25, Z+
    a3f6:	a5 91       	lpm	r26, Z+
    a3f8:	b4 91       	lpm	r27, Z+
    a3fa:	00 97       	sbiw	r24, 0x00	; 0
    a3fc:	a1 05       	cpc	r26, r1
    a3fe:	b1 05       	cpc	r27, r1
    a400:	09 f4       	brne	.+2      	; 0xa404 <MenuEscLeft+0x17a>
    a402:	6f c0       	rjmp	.+222    	; 0xa4e2 <MenuEscLeft+0x258>
						MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[CurrFieldSize - 1 - CurrPos]);
					else MultiSymbol = GetMultiSymbol(Symbols_P, BufStr[CurrFieldSize - 1 - CurrPos]);
    a404:	e0 91 70 07 	lds	r30, 0x0770
    a408:	f0 e0       	ldi	r31, 0x00	; 0
    a40a:	31 97       	sbiw	r30, 0x01	; 1
    a40c:	e2 1b       	sub	r30, r18
    a40e:	f1 09       	sbc	r31, r1
    a410:	e6 54       	subi	r30, 0x46	; 70
    a412:	fa 4f       	sbci	r31, 0xFA	; 250
    a414:	89 ec       	ldi	r24, 0xC9	; 201
    a416:	95 e0       	ldi	r25, 0x05	; 5
    a418:	60 81       	ld	r22, Z
    a41a:	0e 94 bc 3f 	call	0x7f78	; 0x7f78 <GetMultiSymbol>
    a41e:	80 93 eb 04 	sts	0x04EB, r24
    a422:	3b cf       	rjmp	.-394    	; 0xa29a <MenuEscLeft+0x10>
			if(Type==s_Byte || Type==s_EE_Byte || Type==s_Word || Type==s_EE_Word)
				Pos++;
			if(++CurrPos>Pos)
				CurrPos = NullPos;
			else{
				switch(Type){
    a424:	19 31       	cpi	r17, 0x19	; 25
    a426:	20 f4       	brcc	.+8      	; 0xa430 <MenuEscLeft+0x1a6>
    a428:	10 51       	subi	r17, 0x10	; 16
    a42a:	16 30       	cpi	r17, 0x06	; 6
    a42c:	08 f0       	brcs	.+2      	; 0xa430 <MenuEscLeft+0x1a6>
    a42e:	35 cf       	rjmp	.-406    	; 0xa29a <MenuEscLeft+0x10>
						MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[CurrFieldSize - 1 - CurrPos]);
					else MultiSymbol = GetMultiSymbol(Symbols_P, BufStr[CurrFieldSize - 1 - CurrPos]);
					break;
				case Longint: case z_Longint: case EE_Longint: case z_EE_Longint: case s_Longint: case s_EE_Longint:
				case FFloat: case EE_FFloat: case GFloat: case EE_GFloat:
					MultiSymbol = GetMultiSymbol(Digits_P, BufStr[CurrFieldSize - 1 - CurrPos]);
    a430:	e0 91 70 07 	lds	r30, 0x0770
    a434:	f0 e0       	ldi	r31, 0x00	; 0
    a436:	31 97       	sbiw	r30, 0x01	; 1
    a438:	e2 1b       	sub	r30, r18
    a43a:	f1 09       	sbc	r31, r1
    a43c:	e6 54       	subi	r30, 0x46	; 70
    a43e:	fa 4f       	sbci	r31, 0xFA	; 250
    a440:	82 e7       	ldi	r24, 0x72	; 114
    a442:	96 e0       	ldi	r25, 0x06	; 6
    a444:	60 81       	ld	r22, Z
    a446:	0e 94 bc 3f 	call	0x7f78	; 0x7f78 <GetMultiSymbol>
    a44a:	80 93 eb 04 	sts	0x04EB, r24
    a44e:	25 cf       	rjmp	.-438    	; 0xa29a <MenuEscLeft+0x10>
			Field2Buf(GetField);
		return;
	}

// 3) Go to menu
	EventFunc(&CurrPage->Exit);
    a450:	80 91 d1 02 	lds	r24, 0x02D1
    a454:	90 91 d2 02 	lds	r25, 0x02D2
    a458:	0a 96       	adiw	r24, 0x0a	; 10
    a45a:	0e 94 5b 3b 	call	0x76b6	; 0x76b6 <EventFunc>
	if(MenuDepth) {
    a45e:	e0 91 6a 07 	lds	r30, 0x076A
    a462:	ee 23       	and	r30, r30
    a464:	21 f1       	breq	.+72     	; 0xa4ae <MenuEscLeft+0x224>
		CurrPage=MenuStack[--MenuDepth].Page;
    a466:	e1 50       	subi	r30, 0x01	; 1
    a468:	e0 93 6a 07 	sts	0x076A, r30
    a46c:	f0 e0       	ldi	r31, 0x00	; 0
    a46e:	ee 0f       	add	r30, r30
    a470:	ff 1f       	adc	r31, r31
    a472:	ee 0f       	add	r30, r30
    a474:	ff 1f       	adc	r31, r31
    a476:	df 01       	movw	r26, r30
    a478:	a9 56       	subi	r26, 0x69	; 105
    a47a:	b7 4f       	sbci	r27, 0xF7	; 247
    a47c:	9c 91       	ld	r25, X
    a47e:	11 96       	adiw	r26, 0x01	; 1
    a480:	2c 91       	ld	r18, X
    a482:	11 97       	sbiw	r26, 0x01	; 1
    a484:	90 93 d1 02 	sts	0x02D1, r25
    a488:	20 93 d2 02 	sts	0x02D2, r18
		CurrLine=MenuStack[MenuDepth].Line;
    a48c:	13 96       	adiw	r26, 0x03	; 3
    a48e:	8c 91       	ld	r24, X
    a490:	80 93 79 07 	sts	0x0779, r24
		CurrLCD=MenuStack[MenuDepth].LCD;
    a494:	e7 56       	subi	r30, 0x67	; 103
    a496:	f7 4f       	sbci	r31, 0xF7	; 247
    a498:	80 81       	ld	r24, Z
    a49a:	80 93 96 08 	sts	0x0896, r24
    a49e:	e9 2f       	mov	r30, r25
    a4a0:	f2 2f       	mov	r31, r18
    a4a2:	9f 01       	movw	r18, r30
		}
		else
			CurrPage=prp(&CurrPage->OutPage);
		CurrLine=CurrLCD=GetFix();
	}
	EventFunc(&CurrPage->Load);
    a4a4:	c9 01       	movw	r24, r18
    a4a6:	06 96       	adiw	r24, 0x06	; 6
    a4a8:	0e 94 5b 3b 	call	0x76b6	; 0x76b6 <EventFunc>
    a4ac:	f6 ce       	rjmp	.-532    	; 0xa29a <MenuEscLeft+0x10>
		CurrPage=MenuStack[--MenuDepth].Page;
		CurrLine=MenuStack[MenuDepth].Line;
		CurrLCD=MenuStack[MenuDepth].LCD;
	}
	else {
		if(NextPage) {
    a4ae:	e0 91 d0 05 	lds	r30, 0x05D0
    a4b2:	f0 91 d1 05 	lds	r31, 0x05D1
    a4b6:	30 97       	sbiw	r30, 0x00	; 0
    a4b8:	21 f1       	breq	.+72     	; 0xa502 <MenuEscLeft+0x278>
			CurrPage=NextPage;
    a4ba:	f0 93 d2 02 	sts	0x02D2, r31
    a4be:	e0 93 d1 02 	sts	0x02D1, r30
			NextPage=NULL;
    a4c2:	10 92 d1 05 	sts	0x05D1, r1
    a4c6:	10 92 d0 05 	sts	0x05D0, r1
    a4ca:	9f 01       	movw	r18, r30

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    a4cc:	2d 5f       	subi	r18, 0xFD	; 253
    a4ce:	3f 4f       	sbci	r19, 0xFF	; 255
    a4d0:	f9 01       	movw	r30, r18
    a4d2:	84 91       	lpm	r24, Z+
    a4d4:	23 50       	subi	r18, 0x03	; 3
    a4d6:	30 40       	sbci	r19, 0x00	; 0
		}
		else
			CurrPage=prp(&CurrPage->OutPage);
		CurrLine=CurrLCD=GetFix();
    a4d8:	80 93 96 08 	sts	0x0896, r24
    a4dc:	80 93 79 07 	sts	0x0779, r24
    a4e0:	e1 cf       	rjmp	.-62     	; 0xa4a4 <MenuEscLeft+0x21a>
				CurrPos = NullPos;
			else{
				switch(Type){
				case Text: case EE_Text:
					if( (prd(&Field->Min) == DIGIT) && (prd(&Field->Max) == DIGIT) )
						MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[CurrFieldSize - 1 - CurrPos]);
    a4e2:	e0 91 70 07 	lds	r30, 0x0770
    a4e6:	f0 e0       	ldi	r31, 0x00	; 0
    a4e8:	31 97       	sbiw	r30, 0x01	; 1
    a4ea:	e2 1b       	sub	r30, r18
    a4ec:	f1 09       	sbc	r31, r1
    a4ee:	e6 54       	subi	r30, 0x46	; 70
    a4f0:	fa 4f       	sbci	r31, 0xFA	; 250
    a4f2:	87 e6       	ldi	r24, 0x67	; 103
    a4f4:	96 e0       	ldi	r25, 0x06	; 6
    a4f6:	60 81       	ld	r22, Z
    a4f8:	0e 94 bc 3f 	call	0x7f78	; 0x7f78 <GetMultiSymbol>
    a4fc:	80 93 eb 04 	sts	0x04EB, r24
    a500:	cc ce       	rjmp	.-616    	; 0xa29a <MenuEscLeft+0x10>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    a502:	80 91 d1 02 	lds	r24, 0x02D1
    a506:	90 91 d2 02 	lds	r25, 0x02D2
    a50a:	04 96       	adiw	r24, 0x04	; 4
		if(NextPage) {
			CurrPage=NextPage;
			NextPage=NULL;
		}
		else
			CurrPage=prp(&CurrPage->OutPage);
    a50c:	fc 01       	movw	r30, r24
    a50e:	25 91       	lpm	r18, Z+
    a510:	34 91       	lpm	r19, Z+
    a512:	30 93 d2 02 	sts	0x02D2, r19
    a516:	20 93 d1 02 	sts	0x02D1, r18
    a51a:	d8 cf       	rjmp	.-80     	; 0xa4cc <MenuEscLeft+0x242>

0000a51c <Buf2Field>:
// ~~~~~~~~~~~~~~~~~~~~~~~
//       
//     -
static void
Buf2Field(OutField *Field)
{
    a51c:	3f 92       	push	r3
    a51e:	4f 92       	push	r4
    a520:	5f 92       	push	r5
    a522:	6f 92       	push	r6
    a524:	7f 92       	push	r7
    a526:	8f 92       	push	r8
    a528:	9f 92       	push	r9
    a52a:	af 92       	push	r10
    a52c:	bf 92       	push	r11
    a52e:	cf 92       	push	r12
    a530:	df 92       	push	r13
    a532:	ef 92       	push	r14
    a534:	ff 92       	push	r15
    a536:	0f 93       	push	r16
    a538:	1f 93       	push	r17
    a53a:	df 93       	push	r29
    a53c:	cf 93       	push	r28
    a53e:	cd b7       	in	r28, 0x3d	; 61
    a540:	de b7       	in	r29, 0x3e	; 62
    a542:	6d 97       	sbiw	r28, 0x1d	; 29
    a544:	0f b6       	in	r0, 0x3f	; 63
    a546:	f8 94       	cli
    a548:	de bf       	out	0x3e, r29	; 62
    a54a:	0f be       	out	0x3f, r0	; 63
    a54c:	cd bf       	out	0x3d, r28	; 61
    a54e:	6c 01       	movw	r12, r24
    a550:	fc 01       	movw	r30, r24
    a552:	31 96       	adiw	r30, 0x01	; 1
    a554:	45 90       	lpm	r4, Z+
    a556:	54 90       	lpm	r5, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    a558:	2f e0       	ldi	r18, 0x0F	; 15
    a55a:	30 e0       	ldi	r19, 0x00	; 0
    a55c:	c2 0e       	add	r12, r18
    a55e:	d3 1e       	adc	r13, r19
    a560:	f6 01       	movw	r30, r12
    a562:	24 91       	lpm	r18, Z+
    a564:	81 ef       	ldi	r24, 0xF1	; 241
    a566:	9f ef       	ldi	r25, 0xFF	; 255
    a568:	c8 0e       	add	r12, r24
    a56a:	d9 1e       	adc	r13, r25
	void *Var = prp(&Field->Var);
	uint8_t BitN=prb(&Field->Prec), Mask=1<<BitN%8, *BitVar=(uint8_t*)Var+BitN/8;
    a56c:	32 2f       	mov	r19, r18
    a56e:	37 70       	andi	r19, 0x07	; 7
    a570:	81 e0       	ldi	r24, 0x01	; 1
    a572:	90 e0       	ldi	r25, 0x00	; 0
    a574:	38 2e       	mov	r3, r24
    a576:	01 c0       	rjmp	.+2      	; 0xa57a <Buf2Field+0x5e>
    a578:	33 0c       	add	r3, r3
    a57a:	3a 95       	dec	r19
    a57c:	ea f7       	brpl	.-6      	; 0xa578 <Buf2Field+0x5c>
    a57e:	26 95       	lsr	r18
    a580:	26 95       	lsr	r18
    a582:	26 95       	lsr	r18
    a584:	32 01       	movw	r6, r4
    a586:	62 0e       	add	r6, r18
    a588:	71 1c       	adc	r7, r1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    a58a:	f6 01       	movw	r30, r12
    a58c:	33 96       	adiw	r30, 0x03	; 3
    a58e:	85 90       	lpm	r8, Z+
    a590:	95 90       	lpm	r9, Z+
    a592:	a5 90       	lpm	r10, Z+
    a594:	b4 90       	lpm	r11, Z+
	uint8_t EE_BitVar;
	uint32_t Min=prd(&Field->Min), Max=prd(&Field->Max);

	uint32_t Temp=0;
    a596:	f6 01       	movw	r30, r12
    a598:	37 96       	adiw	r30, 0x07	; 7
    a59a:	e5 90       	lpm	r14, Z+
    a59c:	f5 90       	lpm	r15, Z+
    a59e:	05 91       	lpm	r16, Z+
    a5a0:	14 91       	lpm	r17, Z+
    a5a2:	19 82       	std	Y+1, r1	; 0x01
    a5a4:	1a 82       	std	Y+2, r1	; 0x02
    a5a6:	1b 82       	std	Y+3, r1	; 0x03
    a5a8:	1c 82       	std	Y+4, r1	; 0x04
	float fTemp=0;
    a5aa:	80 e0       	ldi	r24, 0x00	; 0
    a5ac:	90 e0       	ldi	r25, 0x00	; 0
    a5ae:	a0 e0       	ldi	r26, 0x00	; 0
    a5b0:	b0 e0       	ldi	r27, 0x00	; 0
    a5b2:	8d 83       	std	Y+5, r24	; 0x05
    a5b4:	9e 83       	std	Y+6, r25	; 0x06
    a5b6:	af 83       	std	Y+7, r26	; 0x07
    a5b8:	b8 87       	std	Y+8, r27	; 0x08

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    a5ba:	f6 01       	movw	r30, r12
    a5bc:	84 91       	lpm	r24, Z+

	switch(prb(&Field->Type)) {
    a5be:	e8 2f       	mov	r30, r24
    a5c0:	f0 e0       	ldi	r31, 0x00	; 0
    a5c2:	e3 32       	cpi	r30, 0x23	; 35
    a5c4:	f1 05       	cpc	r31, r1
    a5c6:	08 f0       	brcs	.+2      	; 0xa5ca <Buf2Field+0xae>
    a5c8:	3f c0       	rjmp	.+126    	; 0xa648 <Buf2Field+0x12c>
    a5ca:	ed 56       	subi	r30, 0x6D	; 109
    a5cc:	ff 4f       	sbci	r31, 0xFF	; 255
    a5ce:	ee 0f       	add	r30, r30
    a5d0:	ff 1f       	adc	r31, r31
    a5d2:	05 90       	lpm	r0, Z+
    a5d4:	f4 91       	lpm	r31, Z+
    a5d6:	e0 2d       	mov	r30, r0
    a5d8:	19 94       	eijmp
		PresicionHanler(Field);
		sscanf(BufStr,"%lud", (uint32_t*)&Temp);
		SetField32(Temp, uint32_t);
		break;
	case EE_Longint: case z_EE_Longint:
		PresicionHanler(Field);
    a5da:	c6 01       	movw	r24, r12
    a5dc:	0e 94 82 3f 	call	0x7f04	; 0x7f04 <PresicionHanler>
		if(sscanf(BufStr,"%lud", (uint32_t*)&Temp) == 1){
    a5e0:	00 d0       	rcall	.+0      	; 0xa5e2 <Buf2Field+0xc6>
    a5e2:	00 d0       	rcall	.+0      	; 0xa5e4 <Buf2Field+0xc8>
    a5e4:	ed b7       	in	r30, 0x3d	; 61
    a5e6:	fe b7       	in	r31, 0x3e	; 62
    a5e8:	31 96       	adiw	r30, 0x01	; 1
    a5ea:	8a eb       	ldi	r24, 0xBA	; 186
    a5ec:	95 e0       	ldi	r25, 0x05	; 5
    a5ee:	ad b7       	in	r26, 0x3d	; 61
    a5f0:	be b7       	in	r27, 0x3e	; 62
    a5f2:	12 96       	adiw	r26, 0x02	; 2
    a5f4:	9c 93       	st	X, r25
    a5f6:	8e 93       	st	-X, r24
    a5f8:	11 97       	sbiw	r26, 0x01	; 1
    a5fa:	8f e9       	ldi	r24, 0x9F	; 159
    a5fc:	92 e0       	ldi	r25, 0x02	; 2
    a5fe:	93 83       	std	Z+3, r25	; 0x03
    a600:	82 83       	std	Z+2, r24	; 0x02
    a602:	ce 01       	movw	r24, r28
    a604:	01 96       	adiw	r24, 0x01	; 1
    a606:	95 83       	std	Z+5, r25	; 0x05
    a608:	84 83       	std	Z+4, r24	; 0x04
    a60a:	0e 94 37 7b 	call	0xf66e	; 0xf66e <sscanf>
    a60e:	ed b7       	in	r30, 0x3d	; 61
    a610:	fe b7       	in	r31, 0x3e	; 62
    a612:	36 96       	adiw	r30, 0x06	; 6
    a614:	0f b6       	in	r0, 0x3f	; 63
    a616:	f8 94       	cli
    a618:	fe bf       	out	0x3e, r31	; 62
    a61a:	0f be       	out	0x3f, r0	; 63
    a61c:	ed bf       	out	0x3d, r30	; 61
    a61e:	01 97       	sbiw	r24, 0x01	; 1
    a620:	99 f4       	brne	.+38     	; 0xa648 <Buf2Field+0x12c>
			SetEEField32(Temp, uint32_t, uint32_t, d);
    a622:	49 81       	ldd	r20, Y+1	; 0x01
    a624:	5a 81       	ldd	r21, Y+2	; 0x02
    a626:	6b 81       	ldd	r22, Y+3	; 0x03
    a628:	7c 81       	ldd	r23, Y+4	; 0x04
    a62a:	e4 16       	cp	r14, r20
    a62c:	f5 06       	cpc	r15, r21
    a62e:	06 07       	cpc	r16, r22
    a630:	17 07       	cpc	r17, r23
    a632:	08 f4       	brcc	.+2      	; 0xa636 <Buf2Field+0x11a>
    a634:	cc c2       	rjmp	.+1432   	; 0xabce <Buf2Field+0x6b2>
    a636:	48 15       	cp	r20, r8
    a638:	59 05       	cpc	r21, r9
    a63a:	6a 05       	cpc	r22, r10
    a63c:	7b 05       	cpc	r23, r11
    a63e:	08 f4       	brcc	.+2      	; 0xa642 <Buf2Field+0x126>
    a640:	f8 c1       	rjmp	.+1008   	; 0xaa32 <Buf2Field+0x516>
		SetField32(Temp, int32_t);
		break;
	case s_EE_Longint:
		PresicionHanler(Field);
		if(sscanf(BufStr,"%ld", (int32_t*)&Temp) == 1){
			SetEEField32(Temp, int32_t, uint32_t, d);
    a642:	c2 01       	movw	r24, r4
    a644:	0e 94 50 4c 	call	0x98a0	; 0x98a0 <ewd>
			ewbl(TempStr, Var, Width);
		}
		break;

	}
	EventFunc(&Field->Act);
    a648:	c6 01       	movw	r24, r12
    a64a:	0b 96       	adiw	r24, 0x0b	; 11
    a64c:	0e 94 5b 3b 	call	0x76b6	; 0x76b6 <EventFunc>
}
    a650:	6d 96       	adiw	r28, 0x1d	; 29
    a652:	0f b6       	in	r0, 0x3f	; 63
    a654:	f8 94       	cli
    a656:	de bf       	out	0x3e, r29	; 62
    a658:	0f be       	out	0x3f, r0	; 63
    a65a:	cd bf       	out	0x3d, r28	; 61
    a65c:	cf 91       	pop	r28
    a65e:	df 91       	pop	r29
    a660:	1f 91       	pop	r17
    a662:	0f 91       	pop	r16
    a664:	ff 90       	pop	r15
    a666:	ef 90       	pop	r14
    a668:	df 90       	pop	r13
    a66a:	cf 90       	pop	r12
    a66c:	bf 90       	pop	r11
    a66e:	af 90       	pop	r10
    a670:	9f 90       	pop	r9
    a672:	8f 90       	pop	r8
    a674:	7f 90       	pop	r7
    a676:	6f 90       	pop	r6
    a678:	5f 90       	pop	r5
    a67a:	4f 90       	pop	r4
    a67c:	3f 90       	pop	r3
    a67e:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    a680:	8e 01       	movw	r16, r28
    a682:	07 5f       	subi	r16, 0xF7	; 247
    a684:	1f 4f       	sbci	r17, 0xFF	; 255
    a686:	c8 01       	movw	r24, r16
    a688:	b2 01       	movw	r22, r4
    a68a:	45 e1       	ldi	r20, 0x15	; 21
    a68c:	50 e0       	ldi	r21, 0x00	; 0
    a68e:	0e 94 f3 7c 	call	0xf9e6	; 0xf9e6 <__eerd_block_m2560>
		}
		break;
	case EE_Text:{
			char TempStr[LCDXSz+1];
			erbl(TempStr, Var, LCDXSz+1);
			uint8_t Width = strlen(TempStr);
    a692:	d8 01       	movw	r26, r16
    a694:	0d 90       	ld	r0, X+
    a696:	00 20       	and	r0, r0
    a698:	e9 f7       	brne	.-6      	; 0xa694 <Buf2Field+0x178>
    a69a:	7d 01       	movw	r14, r26
    a69c:	08 94       	sec
    a69e:	e1 08       	sbc	r14, r1
    a6a0:	f1 08       	sbc	r15, r1
    a6a2:	e0 1a       	sub	r14, r16
    a6a4:	f1 0a       	sbc	r15, r17
			memcpy(TempStr, BufStr, Width);
    a6a6:	2a eb       	ldi	r18, 0xBA	; 186
    a6a8:	35 e0       	ldi	r19, 0x05	; 5
    a6aa:	c8 01       	movw	r24, r16
    a6ac:	b9 01       	movw	r22, r18
    a6ae:	4e 2d       	mov	r20, r14
    a6b0:	50 e0       	ldi	r21, 0x00	; 0
    a6b2:	0e 94 25 7a 	call	0xf44a	; 0xf44a <memcpy>
			ewbl(TempStr, Var, Width);
    a6b6:	c8 01       	movw	r24, r16
    a6b8:	b2 01       	movw	r22, r4
    a6ba:	4e 2d       	mov	r20, r14
    a6bc:	50 e0       	ldi	r21, 0x00	; 0
    a6be:	0e 94 4b 4c 	call	0x9896	; 0x9896 <ewbl>
    a6c2:	c2 cf       	rjmp	.-124    	; 0xa648 <Buf2Field+0x12c>
	uint32_t Temp=0;
	float fTemp=0;

	switch(prb(&Field->Type)) {
	case Byte: case z_Byte: case Enum:
		SetField(F_Buf, uint8_t);
    a6c4:	20 91 ee 04 	lds	r18, 0x04EE
    a6c8:	30 91 ef 04 	lds	r19, 0x04EF
    a6cc:	40 91 f0 04 	lds	r20, 0x04F0
    a6d0:	50 91 f1 04 	lds	r21, 0x04F1
    a6d4:	8e 2d       	mov	r24, r14
    a6d6:	90 e0       	ldi	r25, 0x00	; 0
    a6d8:	a0 e0       	ldi	r26, 0x00	; 0
    a6da:	b0 e0       	ldi	r27, 0x00	; 0
    a6dc:	82 17       	cp	r24, r18
    a6de:	93 07       	cpc	r25, r19
    a6e0:	a4 07       	cpc	r26, r20
    a6e2:	b5 07       	cpc	r27, r21
    a6e4:	08 f4       	brcc	.+2      	; 0xa6e8 <Buf2Field+0x1cc>
    a6e6:	50 c2       	rjmp	.+1184   	; 0xab88 <Buf2Field+0x66c>
    a6e8:	88 2d       	mov	r24, r8
    a6ea:	90 e0       	ldi	r25, 0x00	; 0
    a6ec:	a0 e0       	ldi	r26, 0x00	; 0
    a6ee:	b0 e0       	ldi	r27, 0x00	; 0
    a6f0:	28 17       	cp	r18, r24
    a6f2:	39 07       	cpc	r19, r25
    a6f4:	4a 07       	cpc	r20, r26
    a6f6:	5b 07       	cpc	r21, r27
    a6f8:	08 f0       	brcs	.+2      	; 0xa6fc <Buf2Field+0x1e0>
    a6fa:	66 c2       	rjmp	.+1228   	; 0xabc8 <Buf2Field+0x6ac>
    a6fc:	f2 01       	movw	r30, r4
    a6fe:	80 82       	st	Z, r8
    a700:	a3 cf       	rjmp	.-186    	; 0xa648 <Buf2Field+0x12c>
		break;
	case s_Byte:
		SetField(sF_Buf, int8_t);
		break;
	case EE_Byte: case z_EE_Byte: case EE_Enum:
		SetEEField(F_Buf, uint8_t, uint8_t, b);
    a702:	20 91 ee 04 	lds	r18, 0x04EE
    a706:	30 91 ef 04 	lds	r19, 0x04EF
    a70a:	40 91 f0 04 	lds	r20, 0x04F0
    a70e:	50 91 f1 04 	lds	r21, 0x04F1
    a712:	8e 2d       	mov	r24, r14
    a714:	90 e0       	ldi	r25, 0x00	; 0
    a716:	a0 e0       	ldi	r26, 0x00	; 0
    a718:	b0 e0       	ldi	r27, 0x00	; 0
    a71a:	82 17       	cp	r24, r18
    a71c:	93 07       	cpc	r25, r19
    a71e:	a4 07       	cpc	r26, r20
    a720:	b5 07       	cpc	r27, r21
    a722:	08 f4       	brcc	.+2      	; 0xa726 <Buf2Field+0x20a>
    a724:	41 c2       	rjmp	.+1154   	; 0xaba8 <Buf2Field+0x68c>
    a726:	88 2d       	mov	r24, r8
    a728:	90 e0       	ldi	r25, 0x00	; 0
    a72a:	a0 e0       	ldi	r26, 0x00	; 0
    a72c:	b0 e0       	ldi	r27, 0x00	; 0
    a72e:	28 17       	cp	r18, r24
    a730:	39 07       	cpc	r19, r25
    a732:	4a 07       	cpc	r20, r26
    a734:	5b 07       	cpc	r21, r27
    a736:	08 f4       	brcc	.+2      	; 0xa73a <Buf2Field+0x21e>
    a738:	48 c0       	rjmp	.+144    	; 0xa7ca <Buf2Field+0x2ae>
		break;
	case s_EE_Byte:
		SetEEField(sF_Buf, int8_t, uint8_t, b);
    a73a:	c2 01       	movw	r24, r4
    a73c:	62 2f       	mov	r22, r18
    a73e:	0e 94 d6 4a 	call	0x95ac	; 0x95ac <ewb>
    a742:	82 cf       	rjmp	.-252    	; 0xa648 <Buf2Field+0x12c>
	switch(prb(&Field->Type)) {
	case Byte: case z_Byte: case Enum:
		SetField(F_Buf, uint8_t);
		break;
	case s_Byte:
		SetField(sF_Buf, int8_t);
    a744:	20 91 f2 04 	lds	r18, 0x04F2
    a748:	30 91 f3 04 	lds	r19, 0x04F3
    a74c:	40 91 f4 04 	lds	r20, 0x04F4
    a750:	50 91 f5 04 	lds	r21, 0x04F5
    a754:	8e 2d       	mov	r24, r14
    a756:	99 27       	eor	r25, r25
    a758:	87 fd       	sbrc	r24, 7
    a75a:	90 95       	com	r25
    a75c:	a9 2f       	mov	r26, r25
    a75e:	b9 2f       	mov	r27, r25
    a760:	82 17       	cp	r24, r18
    a762:	93 07       	cpc	r25, r19
    a764:	a4 07       	cpc	r26, r20
    a766:	b5 07       	cpc	r27, r21
    a768:	0c f4       	brge	.+2      	; 0xa76c <Buf2Field+0x250>
    a76a:	08 c2       	rjmp	.+1040   	; 0xab7c <Buf2Field+0x660>
    a76c:	88 2d       	mov	r24, r8
    a76e:	99 27       	eor	r25, r25
    a770:	87 fd       	sbrc	r24, 7
    a772:	90 95       	com	r25
    a774:	a9 2f       	mov	r26, r25
    a776:	b9 2f       	mov	r27, r25
    a778:	28 17       	cp	r18, r24
    a77a:	39 07       	cpc	r19, r25
    a77c:	4a 07       	cpc	r20, r26
    a77e:	5b 07       	cpc	r21, r27
    a780:	0c f0       	brlt	.+2      	; 0xa784 <Buf2Field+0x268>
    a782:	17 c2       	rjmp	.+1070   	; 0xabb2 <Buf2Field+0x696>
    a784:	d2 01       	movw	r26, r4
    a786:	8c 92       	st	X, r8
    a788:	5f cf       	rjmp	.-322    	; 0xa648 <Buf2Field+0x12c>
		break;
	case EE_Byte: case z_EE_Byte: case EE_Enum:
		SetEEField(F_Buf, uint8_t, uint8_t, b);
		break;
	case s_EE_Byte:
		SetEEField(sF_Buf, int8_t, uint8_t, b);
    a78a:	20 91 f2 04 	lds	r18, 0x04F2
    a78e:	30 91 f3 04 	lds	r19, 0x04F3
    a792:	40 91 f4 04 	lds	r20, 0x04F4
    a796:	50 91 f5 04 	lds	r21, 0x04F5
    a79a:	8e 2d       	mov	r24, r14
    a79c:	99 27       	eor	r25, r25
    a79e:	87 fd       	sbrc	r24, 7
    a7a0:	90 95       	com	r25
    a7a2:	a9 2f       	mov	r26, r25
    a7a4:	b9 2f       	mov	r27, r25
    a7a6:	82 17       	cp	r24, r18
    a7a8:	93 07       	cpc	r25, r19
    a7aa:	a4 07       	cpc	r26, r20
    a7ac:	b5 07       	cpc	r27, r21
    a7ae:	0c f4       	brge	.+2      	; 0xa7b2 <Buf2Field+0x296>
    a7b0:	fb c1       	rjmp	.+1014   	; 0xaba8 <Buf2Field+0x68c>
    a7b2:	88 2d       	mov	r24, r8
    a7b4:	99 27       	eor	r25, r25
    a7b6:	87 fd       	sbrc	r24, 7
    a7b8:	90 95       	com	r25
    a7ba:	a9 2f       	mov	r26, r25
    a7bc:	b9 2f       	mov	r27, r25
    a7be:	28 17       	cp	r18, r24
    a7c0:	39 07       	cpc	r19, r25
    a7c2:	4a 07       	cpc	r20, r26
    a7c4:	5b 07       	cpc	r21, r27
    a7c6:	0c f0       	brlt	.+2      	; 0xa7ca <Buf2Field+0x2ae>
    a7c8:	b8 cf       	rjmp	.-144    	; 0xa73a <Buf2Field+0x21e>
    a7ca:	c2 01       	movw	r24, r4
    a7cc:	68 2d       	mov	r22, r8
    a7ce:	0e 94 d6 4a 	call	0x95ac	; 0x95ac <ewb>
    a7d2:	3a cf       	rjmp	.-396    	; 0xa648 <Buf2Field+0x12c>
		break;
	case Word: case z_Word:
		SetField(F_Buf, uint16_t);
    a7d4:	20 91 ee 04 	lds	r18, 0x04EE
    a7d8:	30 91 ef 04 	lds	r19, 0x04EF
    a7dc:	40 91 f0 04 	lds	r20, 0x04F0
    a7e0:	50 91 f1 04 	lds	r21, 0x04F1
    a7e4:	c7 01       	movw	r24, r14
    a7e6:	a0 e0       	ldi	r26, 0x00	; 0
    a7e8:	b0 e0       	ldi	r27, 0x00	; 0
    a7ea:	82 17       	cp	r24, r18
    a7ec:	93 07       	cpc	r25, r19
    a7ee:	a4 07       	cpc	r26, r20
    a7f0:	b5 07       	cpc	r27, r21
    a7f2:	08 f4       	brcc	.+2      	; 0xa7f6 <Buf2Field+0x2da>
    a7f4:	cc c1       	rjmp	.+920    	; 0xab8e <Buf2Field+0x672>
    a7f6:	c4 01       	movw	r24, r8
    a7f8:	a0 e0       	ldi	r26, 0x00	; 0
    a7fa:	b0 e0       	ldi	r27, 0x00	; 0
    a7fc:	28 17       	cp	r18, r24
    a7fe:	39 07       	cpc	r19, r25
    a800:	4a 07       	cpc	r20, r26
    a802:	5b 07       	cpc	r21, r27
    a804:	08 f0       	brcs	.+2      	; 0xa808 <Buf2Field+0x2ec>
    a806:	d8 c1       	rjmp	.+944    	; 0xabb8 <Buf2Field+0x69c>
    a808:	f2 01       	movw	r30, r4
    a80a:	91 82       	std	Z+1, r9	; 0x01
    a80c:	80 82       	st	Z, r8
    a80e:	1c cf       	rjmp	.-456    	; 0xa648 <Buf2Field+0x12c>
		break;
	case EE_Word: case z_EE_Word:
		SetEEField(F_Buf, uint16_t, uint16_t, w);
    a810:	20 91 ee 04 	lds	r18, 0x04EE
    a814:	30 91 ef 04 	lds	r19, 0x04EF
    a818:	40 91 f0 04 	lds	r20, 0x04F0
    a81c:	50 91 f1 04 	lds	r21, 0x04F1
    a820:	c7 01       	movw	r24, r14
    a822:	a0 e0       	ldi	r26, 0x00	; 0
    a824:	b0 e0       	ldi	r27, 0x00	; 0
    a826:	82 17       	cp	r24, r18
    a828:	93 07       	cpc	r25, r19
    a82a:	a4 07       	cpc	r26, r20
    a82c:	b5 07       	cpc	r27, r21
    a82e:	08 f4       	brcc	.+2      	; 0xa832 <Buf2Field+0x316>
    a830:	b6 c1       	rjmp	.+876    	; 0xab9e <Buf2Field+0x682>
    a832:	c4 01       	movw	r24, r8
    a834:	a0 e0       	ldi	r26, 0x00	; 0
    a836:	b0 e0       	ldi	r27, 0x00	; 0
    a838:	28 17       	cp	r18, r24
    a83a:	39 07       	cpc	r19, r25
    a83c:	4a 07       	cpc	r20, r26
    a83e:	5b 07       	cpc	r21, r27
    a840:	08 f4       	brcc	.+2      	; 0xa844 <Buf2Field+0x328>
    a842:	45 c0       	rjmp	.+138    	; 0xa8ce <Buf2Field+0x3b2>
		break;
	case s_Word:
		SetField(sF_Buf, int16_t);
		break;
	case s_EE_Word:
		SetEEField(sF_Buf, int16_t, uint16_t, w);
    a844:	c2 01       	movw	r24, r4
    a846:	b9 01       	movw	r22, r18
    a848:	0e 94 19 4b 	call	0x9632	; 0x9632 <eww>
    a84c:	fd ce       	rjmp	.-518    	; 0xa648 <Buf2Field+0x12c>
		break;
	case EE_Word: case z_EE_Word:
		SetEEField(F_Buf, uint16_t, uint16_t, w);
		break;
	case s_Word:
		SetField(sF_Buf, int16_t);
    a84e:	20 91 f2 04 	lds	r18, 0x04F2
    a852:	30 91 f3 04 	lds	r19, 0x04F3
    a856:	40 91 f4 04 	lds	r20, 0x04F4
    a85a:	50 91 f5 04 	lds	r21, 0x04F5
    a85e:	c7 01       	movw	r24, r14
    a860:	aa 27       	eor	r26, r26
    a862:	97 fd       	sbrc	r25, 7
    a864:	a0 95       	com	r26
    a866:	ba 2f       	mov	r27, r26
    a868:	82 17       	cp	r24, r18
    a86a:	93 07       	cpc	r25, r19
    a86c:	a4 07       	cpc	r26, r20
    a86e:	b5 07       	cpc	r27, r21
    a870:	0c f4       	brge	.+2      	; 0xa874 <Buf2Field+0x358>
    a872:	91 c1       	rjmp	.+802    	; 0xab96 <Buf2Field+0x67a>
    a874:	c4 01       	movw	r24, r8
    a876:	aa 27       	eor	r26, r26
    a878:	97 fd       	sbrc	r25, 7
    a87a:	a0 95       	com	r26
    a87c:	ba 2f       	mov	r27, r26
    a87e:	28 17       	cp	r18, r24
    a880:	39 07       	cpc	r19, r25
    a882:	4a 07       	cpc	r20, r26
    a884:	5b 07       	cpc	r21, r27
    a886:	0c f0       	brlt	.+2      	; 0xa88a <Buf2Field+0x36e>
    a888:	9b c1       	rjmp	.+822    	; 0xabc0 <Buf2Field+0x6a4>
    a88a:	d2 01       	movw	r26, r4
    a88c:	8d 92       	st	X+, r8
    a88e:	9c 92       	st	X, r9
    a890:	db ce       	rjmp	.-586    	; 0xa648 <Buf2Field+0x12c>
		break;
	case s_EE_Word:
		SetEEField(sF_Buf, int16_t, uint16_t, w);
    a892:	20 91 f2 04 	lds	r18, 0x04F2
    a896:	30 91 f3 04 	lds	r19, 0x04F3
    a89a:	40 91 f4 04 	lds	r20, 0x04F4
    a89e:	50 91 f5 04 	lds	r21, 0x04F5
    a8a2:	c7 01       	movw	r24, r14
    a8a4:	aa 27       	eor	r26, r26
    a8a6:	97 fd       	sbrc	r25, 7
    a8a8:	a0 95       	com	r26
    a8aa:	ba 2f       	mov	r27, r26
    a8ac:	82 17       	cp	r24, r18
    a8ae:	93 07       	cpc	r25, r19
    a8b0:	a4 07       	cpc	r26, r20
    a8b2:	b5 07       	cpc	r27, r21
    a8b4:	0c f4       	brge	.+2      	; 0xa8b8 <Buf2Field+0x39c>
    a8b6:	73 c1       	rjmp	.+742    	; 0xab9e <Buf2Field+0x682>
    a8b8:	c4 01       	movw	r24, r8
    a8ba:	aa 27       	eor	r26, r26
    a8bc:	97 fd       	sbrc	r25, 7
    a8be:	a0 95       	com	r26
    a8c0:	ba 2f       	mov	r27, r26
    a8c2:	28 17       	cp	r18, r24
    a8c4:	39 07       	cpc	r19, r25
    a8c6:	4a 07       	cpc	r20, r26
    a8c8:	5b 07       	cpc	r21, r27
    a8ca:	0c f0       	brlt	.+2      	; 0xa8ce <Buf2Field+0x3b2>
    a8cc:	bb cf       	rjmp	.-138    	; 0xa844 <Buf2Field+0x328>
    a8ce:	c2 01       	movw	r24, r4
    a8d0:	b4 01       	movw	r22, r8
    a8d2:	0e 94 19 4b 	call	0x9632	; 0x9632 <eww>
    a8d6:	b8 ce       	rjmp	.-656    	; 0xa648 <Buf2Field+0x12c>
		break;
	case c_Word: case zc_Word:
		*(uint16_t*)Var = F_Buf;
    a8d8:	80 91 ee 04 	lds	r24, 0x04EE
    a8dc:	90 91 ef 04 	lds	r25, 0x04EF
    a8e0:	d2 01       	movw	r26, r4
    a8e2:	8d 93       	st	X+, r24
    a8e4:	9c 93       	st	X, r25
    a8e6:	b0 ce       	rjmp	.-672    	; 0xa648 <Buf2Field+0x12c>
		break;


	case Longint: case z_Longint:
		//if(Limit_uByteVar(Temp)) sscanf(BufStr,"%ud", (unsigned short int*)&Temp);
		PresicionHanler(Field);
    a8e8:	c6 01       	movw	r24, r12
    a8ea:	0e 94 82 3f 	call	0x7f04	; 0x7f04 <PresicionHanler>
		sscanf(BufStr,"%lud", (uint32_t*)&Temp);
    a8ee:	00 d0       	rcall	.+0      	; 0xa8f0 <Buf2Field+0x3d4>
    a8f0:	00 d0       	rcall	.+0      	; 0xa8f2 <Buf2Field+0x3d6>
    a8f2:	ed b7       	in	r30, 0x3d	; 61
    a8f4:	fe b7       	in	r31, 0x3e	; 62
    a8f6:	31 96       	adiw	r30, 0x01	; 1
    a8f8:	8a eb       	ldi	r24, 0xBA	; 186
    a8fa:	95 e0       	ldi	r25, 0x05	; 5
    a8fc:	ad b7       	in	r26, 0x3d	; 61
    a8fe:	be b7       	in	r27, 0x3e	; 62
    a900:	12 96       	adiw	r26, 0x02	; 2
    a902:	9c 93       	st	X, r25
    a904:	8e 93       	st	-X, r24
    a906:	11 97       	sbiw	r26, 0x01	; 1
    a908:	8f e9       	ldi	r24, 0x9F	; 159
    a90a:	92 e0       	ldi	r25, 0x02	; 2
    a90c:	93 83       	std	Z+3, r25	; 0x03
    a90e:	82 83       	std	Z+2, r24	; 0x02
    a910:	ce 01       	movw	r24, r28
    a912:	01 96       	adiw	r24, 0x01	; 1
    a914:	95 83       	std	Z+5, r25	; 0x05
    a916:	84 83       	std	Z+4, r24	; 0x04
    a918:	0e 94 37 7b 	call	0xf66e	; 0xf66e <sscanf>
		SetField32(Temp, uint32_t);
    a91c:	89 81       	ldd	r24, Y+1	; 0x01
    a91e:	9a 81       	ldd	r25, Y+2	; 0x02
    a920:	ab 81       	ldd	r26, Y+3	; 0x03
    a922:	bc 81       	ldd	r27, Y+4	; 0x04
    a924:	ed b7       	in	r30, 0x3d	; 61
    a926:	fe b7       	in	r31, 0x3e	; 62
    a928:	36 96       	adiw	r30, 0x06	; 6
    a92a:	0f b6       	in	r0, 0x3f	; 63
    a92c:	f8 94       	cli
    a92e:	fe bf       	out	0x3e, r31	; 62
    a930:	0f be       	out	0x3f, r0	; 63
    a932:	ed bf       	out	0x3d, r30	; 61
    a934:	e8 16       	cp	r14, r24
    a936:	f9 06       	cpc	r15, r25
    a938:	0a 07       	cpc	r16, r26
    a93a:	1b 07       	cpc	r17, r27
    a93c:	08 f4       	brcc	.+2      	; 0xa940 <Buf2Field+0x424>
    a93e:	17 c1       	rjmp	.+558    	; 0xab6e <Buf2Field+0x652>
    a940:	88 15       	cp	r24, r8
    a942:	99 05       	cpc	r25, r9
    a944:	aa 05       	cpc	r26, r10
    a946:	bb 05       	cpc	r27, r11
    a948:	b8 f1       	brcs	.+110    	; 0xa9b8 <Buf2Field+0x49c>
		break;
	case s_Longint:
		PresicionHanler(Field);
		//if(Limit_sByteVar(Temp)) sscanf(BufStr,"%hd", (short int*)&Temp);
		sscanf(BufStr,"%ld", (int32_t*)&Temp);
		SetField32(Temp, int32_t);
    a94a:	f2 01       	movw	r30, r4
    a94c:	80 83       	st	Z, r24
    a94e:	91 83       	std	Z+1, r25	; 0x01
    a950:	a2 83       	std	Z+2, r26	; 0x02
    a952:	b3 83       	std	Z+3, r27	; 0x03
    a954:	79 ce       	rjmp	.-782    	; 0xa648 <Buf2Field+0x12c>
		if(sscanf(BufStr,"%lud", (uint32_t*)&Temp) == 1){
			SetEEField32(Temp, uint32_t, uint32_t, d);
		}		
		break;
	case s_Longint:
		PresicionHanler(Field);
    a956:	c6 01       	movw	r24, r12
    a958:	0e 94 82 3f 	call	0x7f04	; 0x7f04 <PresicionHanler>
		//if(Limit_sByteVar(Temp)) sscanf(BufStr,"%hd", (short int*)&Temp);
		sscanf(BufStr,"%ld", (int32_t*)&Temp);
    a95c:	00 d0       	rcall	.+0      	; 0xa95e <Buf2Field+0x442>
    a95e:	00 d0       	rcall	.+0      	; 0xa960 <Buf2Field+0x444>
    a960:	ed b7       	in	r30, 0x3d	; 61
    a962:	fe b7       	in	r31, 0x3e	; 62
    a964:	31 96       	adiw	r30, 0x01	; 1
    a966:	8a eb       	ldi	r24, 0xBA	; 186
    a968:	95 e0       	ldi	r25, 0x05	; 5
    a96a:	ad b7       	in	r26, 0x3d	; 61
    a96c:	be b7       	in	r27, 0x3e	; 62
    a96e:	12 96       	adiw	r26, 0x02	; 2
    a970:	9c 93       	st	X, r25
    a972:	8e 93       	st	-X, r24
    a974:	11 97       	sbiw	r26, 0x01	; 1
    a976:	84 ea       	ldi	r24, 0xA4	; 164
    a978:	92 e0       	ldi	r25, 0x02	; 2
    a97a:	93 83       	std	Z+3, r25	; 0x03
    a97c:	82 83       	std	Z+2, r24	; 0x02
    a97e:	ce 01       	movw	r24, r28
    a980:	01 96       	adiw	r24, 0x01	; 1
    a982:	95 83       	std	Z+5, r25	; 0x05
    a984:	84 83       	std	Z+4, r24	; 0x04
    a986:	0e 94 37 7b 	call	0xf66e	; 0xf66e <sscanf>
		SetField32(Temp, int32_t);
    a98a:	89 81       	ldd	r24, Y+1	; 0x01
    a98c:	9a 81       	ldd	r25, Y+2	; 0x02
    a98e:	ab 81       	ldd	r26, Y+3	; 0x03
    a990:	bc 81       	ldd	r27, Y+4	; 0x04
    a992:	ed b7       	in	r30, 0x3d	; 61
    a994:	fe b7       	in	r31, 0x3e	; 62
    a996:	36 96       	adiw	r30, 0x06	; 6
    a998:	0f b6       	in	r0, 0x3f	; 63
    a99a:	f8 94       	cli
    a99c:	fe bf       	out	0x3e, r31	; 62
    a99e:	0f be       	out	0x3f, r0	; 63
    a9a0:	ed bf       	out	0x3d, r30	; 61
    a9a2:	e8 16       	cp	r14, r24
    a9a4:	f9 06       	cpc	r15, r25
    a9a6:	0a 07       	cpc	r16, r26
    a9a8:	1b 07       	cpc	r17, r27
    a9aa:	0c f4       	brge	.+2      	; 0xa9ae <Buf2Field+0x492>
    a9ac:	e0 c0       	rjmp	.+448    	; 0xab6e <Buf2Field+0x652>
    a9ae:	88 15       	cp	r24, r8
    a9b0:	99 05       	cpc	r25, r9
    a9b2:	aa 05       	cpc	r26, r10
    a9b4:	bb 05       	cpc	r27, r11
    a9b6:	4c f6       	brge	.-110    	; 0xa94a <Buf2Field+0x42e>
    a9b8:	f2 01       	movw	r30, r4
    a9ba:	80 82       	st	Z, r8
    a9bc:	91 82       	std	Z+1, r9	; 0x01
    a9be:	a2 82       	std	Z+2, r10	; 0x02
    a9c0:	b3 82       	std	Z+3, r11	; 0x03
    a9c2:	42 ce       	rjmp	.-892    	; 0xa648 <Buf2Field+0x12c>
		break;
	case s_EE_Longint:
		PresicionHanler(Field);
    a9c4:	c6 01       	movw	r24, r12
    a9c6:	0e 94 82 3f 	call	0x7f04	; 0x7f04 <PresicionHanler>
		if(sscanf(BufStr,"%ld", (int32_t*)&Temp) == 1){
    a9ca:	00 d0       	rcall	.+0      	; 0xa9cc <Buf2Field+0x4b0>
    a9cc:	00 d0       	rcall	.+0      	; 0xa9ce <Buf2Field+0x4b2>
    a9ce:	ed b7       	in	r30, 0x3d	; 61
    a9d0:	fe b7       	in	r31, 0x3e	; 62
    a9d2:	31 96       	adiw	r30, 0x01	; 1
    a9d4:	8a eb       	ldi	r24, 0xBA	; 186
    a9d6:	95 e0       	ldi	r25, 0x05	; 5
    a9d8:	ad b7       	in	r26, 0x3d	; 61
    a9da:	be b7       	in	r27, 0x3e	; 62
    a9dc:	12 96       	adiw	r26, 0x02	; 2
    a9de:	9c 93       	st	X, r25
    a9e0:	8e 93       	st	-X, r24
    a9e2:	11 97       	sbiw	r26, 0x01	; 1
    a9e4:	84 ea       	ldi	r24, 0xA4	; 164
    a9e6:	92 e0       	ldi	r25, 0x02	; 2
    a9e8:	93 83       	std	Z+3, r25	; 0x03
    a9ea:	82 83       	std	Z+2, r24	; 0x02
    a9ec:	ce 01       	movw	r24, r28
    a9ee:	01 96       	adiw	r24, 0x01	; 1
    a9f0:	95 83       	std	Z+5, r25	; 0x05
    a9f2:	84 83       	std	Z+4, r24	; 0x04
    a9f4:	0e 94 37 7b 	call	0xf66e	; 0xf66e <sscanf>
    a9f8:	ed b7       	in	r30, 0x3d	; 61
    a9fa:	fe b7       	in	r31, 0x3e	; 62
    a9fc:	36 96       	adiw	r30, 0x06	; 6
    a9fe:	0f b6       	in	r0, 0x3f	; 63
    aa00:	f8 94       	cli
    aa02:	fe bf       	out	0x3e, r31	; 62
    aa04:	0f be       	out	0x3f, r0	; 63
    aa06:	ed bf       	out	0x3d, r30	; 61
    aa08:	01 97       	sbiw	r24, 0x01	; 1
    aa0a:	09 f0       	breq	.+2      	; 0xaa0e <Buf2Field+0x4f2>
    aa0c:	1d ce       	rjmp	.-966    	; 0xa648 <Buf2Field+0x12c>
			SetEEField32(Temp, int32_t, uint32_t, d);
    aa0e:	49 81       	ldd	r20, Y+1	; 0x01
    aa10:	5a 81       	ldd	r21, Y+2	; 0x02
    aa12:	6b 81       	ldd	r22, Y+3	; 0x03
    aa14:	7c 81       	ldd	r23, Y+4	; 0x04
    aa16:	ca 01       	movw	r24, r20
    aa18:	db 01       	movw	r26, r22
    aa1a:	e8 16       	cp	r14, r24
    aa1c:	f9 06       	cpc	r15, r25
    aa1e:	0a 07       	cpc	r16, r26
    aa20:	1b 07       	cpc	r17, r27
    aa22:	0c f4       	brge	.+2      	; 0xaa26 <Buf2Field+0x50a>
    aa24:	d4 c0       	rjmp	.+424    	; 0xabce <Buf2Field+0x6b2>
    aa26:	88 15       	cp	r24, r8
    aa28:	99 05       	cpc	r25, r9
    aa2a:	aa 05       	cpc	r26, r10
    aa2c:	bb 05       	cpc	r27, r11
    aa2e:	0c f0       	brlt	.+2      	; 0xaa32 <Buf2Field+0x516>
    aa30:	08 ce       	rjmp	.-1008   	; 0xa642 <Buf2Field+0x126>
    aa32:	c2 01       	movw	r24, r4
    aa34:	b5 01       	movw	r22, r10
    aa36:	a4 01       	movw	r20, r8
    aa38:	0e 94 50 4c 	call	0x98a0	; 0x98a0 <ewd>
    aa3c:	05 ce       	rjmp	.-1014   	; 0xa648 <Buf2Field+0x12c>
		}
		break;


	case FFloat: case GFloat:
		sscanf(BufStr,"%f", &fTemp);
    aa3e:	00 d0       	rcall	.+0      	; 0xaa40 <Buf2Field+0x524>
    aa40:	00 d0       	rcall	.+0      	; 0xaa42 <Buf2Field+0x526>
    aa42:	ed b7       	in	r30, 0x3d	; 61
    aa44:	fe b7       	in	r31, 0x3e	; 62
    aa46:	31 96       	adiw	r30, 0x01	; 1
    aa48:	8a eb       	ldi	r24, 0xBA	; 186
    aa4a:	95 e0       	ldi	r25, 0x05	; 5
    aa4c:	ad b7       	in	r26, 0x3d	; 61
    aa4e:	be b7       	in	r27, 0x3e	; 62
    aa50:	12 96       	adiw	r26, 0x02	; 2
    aa52:	9c 93       	st	X, r25
    aa54:	8e 93       	st	-X, r24
    aa56:	11 97       	sbiw	r26, 0x01	; 1
    aa58:	88 ea       	ldi	r24, 0xA8	; 168
    aa5a:	92 e0       	ldi	r25, 0x02	; 2
    aa5c:	93 83       	std	Z+3, r25	; 0x03
    aa5e:	82 83       	std	Z+2, r24	; 0x02
    aa60:	ce 01       	movw	r24, r28
    aa62:	05 96       	adiw	r24, 0x05	; 5
    aa64:	95 83       	std	Z+5, r25	; 0x05
    aa66:	84 83       	std	Z+4, r24	; 0x04
    aa68:	0e 94 37 7b 	call	0xf66e	; 0xf66e <sscanf>
		*(float*)Var = fTemp;
    aa6c:	8d 81       	ldd	r24, Y+5	; 0x05
    aa6e:	9e 81       	ldd	r25, Y+6	; 0x06
    aa70:	af 81       	ldd	r26, Y+7	; 0x07
    aa72:	b8 85       	ldd	r27, Y+8	; 0x08
    aa74:	f2 01       	movw	r30, r4
    aa76:	80 83       	st	Z, r24
    aa78:	91 83       	std	Z+1, r25	; 0x01
    aa7a:	a2 83       	std	Z+2, r26	; 0x02
    aa7c:	b3 83       	std	Z+3, r27	; 0x03
    aa7e:	2d b7       	in	r18, 0x3d	; 61
    aa80:	3e b7       	in	r19, 0x3e	; 62
    aa82:	2a 5f       	subi	r18, 0xFA	; 250
    aa84:	3f 4f       	sbci	r19, 0xFF	; 255
    aa86:	0f b6       	in	r0, 0x3f	; 63
    aa88:	f8 94       	cli
    aa8a:	3e bf       	out	0x3e, r19	; 62
    aa8c:	0f be       	out	0x3f, r0	; 63
    aa8e:	2d bf       	out	0x3d, r18	; 61
    aa90:	db cd       	rjmp	.-1098   	; 0xa648 <Buf2Field+0x12c>
		break;
	case EE_FFloat: case EE_GFloat:
		if(sscanf(BufStr,"%f", &fTemp) == 1){
    aa92:	00 d0       	rcall	.+0      	; 0xaa94 <Buf2Field+0x578>
    aa94:	00 d0       	rcall	.+0      	; 0xaa96 <Buf2Field+0x57a>
    aa96:	ed b7       	in	r30, 0x3d	; 61
    aa98:	fe b7       	in	r31, 0x3e	; 62
    aa9a:	31 96       	adiw	r30, 0x01	; 1
    aa9c:	8a eb       	ldi	r24, 0xBA	; 186
    aa9e:	95 e0       	ldi	r25, 0x05	; 5
    aaa0:	ad b7       	in	r26, 0x3d	; 61
    aaa2:	be b7       	in	r27, 0x3e	; 62
    aaa4:	12 96       	adiw	r26, 0x02	; 2
    aaa6:	9c 93       	st	X, r25
    aaa8:	8e 93       	st	-X, r24
    aaaa:	11 97       	sbiw	r26, 0x01	; 1
    aaac:	88 ea       	ldi	r24, 0xA8	; 168
    aaae:	92 e0       	ldi	r25, 0x02	; 2
    aab0:	93 83       	std	Z+3, r25	; 0x03
    aab2:	82 83       	std	Z+2, r24	; 0x02
    aab4:	8e 01       	movw	r16, r28
    aab6:	0b 5f       	subi	r16, 0xFB	; 251
    aab8:	1f 4f       	sbci	r17, 0xFF	; 255
    aaba:	15 83       	std	Z+5, r17	; 0x05
    aabc:	04 83       	std	Z+4, r16	; 0x04
    aabe:	0e 94 37 7b 	call	0xf66e	; 0xf66e <sscanf>
    aac2:	ed b7       	in	r30, 0x3d	; 61
    aac4:	fe b7       	in	r31, 0x3e	; 62
    aac6:	36 96       	adiw	r30, 0x06	; 6
    aac8:	0f b6       	in	r0, 0x3f	; 63
    aaca:	f8 94       	cli
    aacc:	fe bf       	out	0x3e, r31	; 62
    aace:	0f be       	out	0x3f, r0	; 63
    aad0:	ed bf       	out	0x3d, r30	; 61
    aad2:	01 97       	sbiw	r24, 0x01	; 1
    aad4:	09 f0       	breq	.+2      	; 0xaad8 <Buf2Field+0x5bc>
    aad6:	b8 cd       	rjmp	.-1168   	; 0xa648 <Buf2Field+0x12c>
			ewbl(&fTemp, (float*)Var, 4);
    aad8:	c8 01       	movw	r24, r16
    aada:	b2 01       	movw	r22, r4
    aadc:	44 e0       	ldi	r20, 0x04	; 4
    aade:	50 e0       	ldi	r21, 0x00	; 0
    aae0:	0e 94 4b 4c 	call	0x9896	; 0x9896 <ewbl>
    aae4:	b1 cd       	rjmp	.-1182   	; 0xa648 <Buf2Field+0x12c>
		}
		break;


	case Bit:
		if(F_Buf)
    aae6:	80 91 ee 04 	lds	r24, 0x04EE
    aaea:	90 91 ef 04 	lds	r25, 0x04EF
    aaee:	a0 91 f0 04 	lds	r26, 0x04F0
    aaf2:	b0 91 f1 04 	lds	r27, 0x04F1
    aaf6:	00 97       	sbiw	r24, 0x00	; 0
    aaf8:	a1 05       	cpc	r26, r1
    aafa:	b1 05       	cpc	r27, r1
    aafc:	91 f1       	breq	.+100    	; 0xab62 <Buf2Field+0x646>
			*BitVar |=Mask;
    aafe:	d3 01       	movw	r26, r6
    ab00:	8c 91       	ld	r24, X
    ab02:	83 29       	or	r24, r3
    ab04:	8c 93       	st	X, r24
    ab06:	a0 cd       	rjmp	.-1216   	; 0xa648 <Buf2Field+0x12c>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    ab08:	c3 01       	movw	r24, r6
    ab0a:	0e 94 03 7d 	call	0xfa06	; 0xfa06 <__eerd_byte_m2560>
    ab0e:	28 2f       	mov	r18, r24
		else
			*BitVar &=~Mask;
		break;
	case EE_Bit:
		EE_BitVar=erb(BitVar);
		ewb(BitVar, F_Buf ? EE_BitVar |Mask : EE_BitVar &~Mask);
    ab10:	80 91 ee 04 	lds	r24, 0x04EE
    ab14:	90 91 ef 04 	lds	r25, 0x04EF
    ab18:	a0 91 f0 04 	lds	r26, 0x04F0
    ab1c:	b0 91 f1 04 	lds	r27, 0x04F1
    ab20:	00 97       	sbiw	r24, 0x00	; 0
    ab22:	a1 05       	cpc	r26, r1
    ab24:	b1 05       	cpc	r27, r1
    ab26:	d1 f4       	brne	.+52     	; 0xab5c <Buf2Field+0x640>
    ab28:	63 2d       	mov	r22, r3
    ab2a:	60 95       	com	r22
    ab2c:	62 23       	and	r22, r18
    ab2e:	c3 01       	movw	r24, r6
    ab30:	0e 94 d6 4a 	call	0x95ac	; 0x95ac <ewb>
    ab34:	89 cd       	rjmp	.-1262   	; 0xa648 <Buf2Field+0x12c>
		break;


	case Text:{
		//    
		uint8_t Field_width = strlen((char*)Var);
    ab36:	f2 01       	movw	r30, r4
    ab38:	01 90       	ld	r0, Z+
    ab3a:	00 20       	and	r0, r0
    ab3c:	e9 f7       	brne	.-6      	; 0xab38 <Buf2Field+0x61c>
    ab3e:	31 97       	sbiw	r30, 0x01	; 1
    ab40:	4e 2f       	mov	r20, r30
    ab42:	44 19       	sub	r20, r4
		if(Field_width > LCDXSz) Field_width = LCDXSz+1;
    ab44:	45 31       	cpi	r20, 0x15	; 21
    ab46:	e8 f0       	brcs	.+58     	; 0xab82 <Buf2Field+0x666>
    ab48:	e5 e1       	ldi	r30, 0x15	; 21
    ab4a:	f0 e0       	ldi	r31, 0x00	; 0
		memcpy(Var,BufStr,Field_width);
    ab4c:	2a eb       	ldi	r18, 0xBA	; 186
    ab4e:	35 e0       	ldi	r19, 0x05	; 5
    ab50:	c2 01       	movw	r24, r4
    ab52:	b9 01       	movw	r22, r18
    ab54:	af 01       	movw	r20, r30
    ab56:	0e 94 25 7a 	call	0xf44a	; 0xf44a <memcpy>
    ab5a:	76 cd       	rjmp	.-1300   	; 0xa648 <Buf2Field+0x12c>
		else
			*BitVar &=~Mask;
		break;
	case EE_Bit:
		EE_BitVar=erb(BitVar);
		ewb(BitVar, F_Buf ? EE_BitVar |Mask : EE_BitVar &~Mask);
    ab5c:	63 2d       	mov	r22, r3
    ab5e:	62 2b       	or	r22, r18
    ab60:	e6 cf       	rjmp	.-52     	; 0xab2e <Buf2Field+0x612>

	case Bit:
		if(F_Buf)
			*BitVar |=Mask;
		else
			*BitVar &=~Mask;
    ab62:	30 94       	com	r3
    ab64:	f3 01       	movw	r30, r6
    ab66:	80 81       	ld	r24, Z
    ab68:	83 21       	and	r24, r3
    ab6a:	80 83       	st	Z, r24
    ab6c:	6d cd       	rjmp	.-1318   	; 0xa648 <Buf2Field+0x12c>
		break;
	case s_Longint:
		PresicionHanler(Field);
		//if(Limit_sByteVar(Temp)) sscanf(BufStr,"%hd", (short int*)&Temp);
		sscanf(BufStr,"%ld", (int32_t*)&Temp);
		SetField32(Temp, int32_t);
    ab6e:	d2 01       	movw	r26, r4
    ab70:	ed 92       	st	X+, r14
    ab72:	fd 92       	st	X+, r15
    ab74:	0d 93       	st	X+, r16
    ab76:	1c 93       	st	X, r17
    ab78:	13 97       	sbiw	r26, 0x03	; 3
    ab7a:	66 cd       	rjmp	.-1332   	; 0xa648 <Buf2Field+0x12c>
	switch(prb(&Field->Type)) {
	case Byte: case z_Byte: case Enum:
		SetField(F_Buf, uint8_t);
		break;
	case s_Byte:
		SetField(sF_Buf, int8_t);
    ab7c:	f2 01       	movw	r30, r4
    ab7e:	e0 82       	st	Z, r14
    ab80:	63 cd       	rjmp	.-1338   	; 0xa648 <Buf2Field+0x12c>


	case Text:{
		//    
		uint8_t Field_width = strlen((char*)Var);
		if(Field_width > LCDXSz) Field_width = LCDXSz+1;
    ab82:	e4 2f       	mov	r30, r20
    ab84:	f0 e0       	ldi	r31, 0x00	; 0
    ab86:	e2 cf       	rjmp	.-60     	; 0xab4c <Buf2Field+0x630>
	uint32_t Temp=0;
	float fTemp=0;

	switch(prb(&Field->Type)) {
	case Byte: case z_Byte: case Enum:
		SetField(F_Buf, uint8_t);
    ab88:	d2 01       	movw	r26, r4
    ab8a:	ec 92       	st	X, r14
    ab8c:	5d cd       	rjmp	.-1350   	; 0xa648 <Buf2Field+0x12c>
		break;
	case s_EE_Byte:
		SetEEField(sF_Buf, int8_t, uint8_t, b);
		break;
	case Word: case z_Word:
		SetField(F_Buf, uint16_t);
    ab8e:	d2 01       	movw	r26, r4
    ab90:	ed 92       	st	X+, r14
    ab92:	fc 92       	st	X, r15
    ab94:	59 cd       	rjmp	.-1358   	; 0xa648 <Buf2Field+0x12c>
		break;
	case EE_Word: case z_EE_Word:
		SetEEField(F_Buf, uint16_t, uint16_t, w);
		break;
	case s_Word:
		SetField(sF_Buf, int16_t);
    ab96:	f2 01       	movw	r30, r4
    ab98:	f1 82       	std	Z+1, r15	; 0x01
    ab9a:	e0 82       	st	Z, r14
    ab9c:	55 cd       	rjmp	.-1366   	; 0xa648 <Buf2Field+0x12c>
		break;
	case s_EE_Word:
		SetEEField(sF_Buf, int16_t, uint16_t, w);
    ab9e:	c2 01       	movw	r24, r4
    aba0:	b7 01       	movw	r22, r14
    aba2:	0e 94 19 4b 	call	0x9632	; 0x9632 <eww>
    aba6:	50 cd       	rjmp	.-1376   	; 0xa648 <Buf2Field+0x12c>
		break;
	case EE_Byte: case z_EE_Byte: case EE_Enum:
		SetEEField(F_Buf, uint8_t, uint8_t, b);
		break;
	case s_EE_Byte:
		SetEEField(sF_Buf, int8_t, uint8_t, b);
    aba8:	c2 01       	movw	r24, r4
    abaa:	6e 2d       	mov	r22, r14
    abac:	0e 94 d6 4a 	call	0x95ac	; 0x95ac <ewb>
    abb0:	4b cd       	rjmp	.-1386   	; 0xa648 <Buf2Field+0x12c>
	switch(prb(&Field->Type)) {
	case Byte: case z_Byte: case Enum:
		SetField(F_Buf, uint8_t);
		break;
	case s_Byte:
		SetField(sF_Buf, int8_t);
    abb2:	f2 01       	movw	r30, r4
    abb4:	20 83       	st	Z, r18
    abb6:	48 cd       	rjmp	.-1392   	; 0xa648 <Buf2Field+0x12c>
		break;
	case s_EE_Byte:
		SetEEField(sF_Buf, int8_t, uint8_t, b);
		break;
	case Word: case z_Word:
		SetField(F_Buf, uint16_t);
    abb8:	d2 01       	movw	r26, r4
    abba:	2d 93       	st	X+, r18
    abbc:	3c 93       	st	X, r19
    abbe:	44 cd       	rjmp	.-1400   	; 0xa648 <Buf2Field+0x12c>
		break;
	case EE_Word: case z_EE_Word:
		SetEEField(F_Buf, uint16_t, uint16_t, w);
		break;
	case s_Word:
		SetField(sF_Buf, int16_t);
    abc0:	f2 01       	movw	r30, r4
    abc2:	31 83       	std	Z+1, r19	; 0x01
    abc4:	20 83       	st	Z, r18
    abc6:	40 cd       	rjmp	.-1408   	; 0xa648 <Buf2Field+0x12c>
	uint32_t Temp=0;
	float fTemp=0;

	switch(prb(&Field->Type)) {
	case Byte: case z_Byte: case Enum:
		SetField(F_Buf, uint8_t);
    abc8:	d2 01       	movw	r26, r4
    abca:	2c 93       	st	X, r18
    abcc:	3d cd       	rjmp	.-1414   	; 0xa648 <Buf2Field+0x12c>
		SetField32(Temp, int32_t);
		break;
	case s_EE_Longint:
		PresicionHanler(Field);
		if(sscanf(BufStr,"%ld", (int32_t*)&Temp) == 1){
			SetEEField32(Temp, int32_t, uint32_t, d);
    abce:	c2 01       	movw	r24, r4
    abd0:	b8 01       	movw	r22, r16
    abd2:	a7 01       	movw	r20, r14
    abd4:	0e 94 50 4c 	call	0x98a0	; 0x98a0 <ewd>
    abd8:	37 cd       	rjmp	.-1426   	; 0xa648 <Buf2Field+0x12c>

0000abda <MenuEnterRight>:
}

// ~~~~~~~~~~~~~~~~~
void
MenuEnterRight(void)
{
    abda:	ef 92       	push	r14
    abdc:	ff 92       	push	r15
    abde:	0f 93       	push	r16
    abe0:	1f 93       	push	r17
    abe2:	cf 93       	push	r28
    abe4:	df 93       	push	r29
//	1) Hide current Message
	if(HideMsg()||KeyFunc(&CurrPage->Enter))
    abe6:	0e 94 bd 3b 	call	0x777a	; 0x777a <HideMsg>
    abea:	88 23       	and	r24, r24
    abec:	39 f0       	breq	.+14     	; 0xabfc <MenuEnterRight+0x22>
	if(NextPage || (NextPage=prp(&Line->InnPage))) {
		GotoMenu(NextPage);
		NextPage=NULL;
		return;
	}
}
    abee:	df 91       	pop	r29
    abf0:	cf 91       	pop	r28
    abf2:	1f 91       	pop	r17
    abf4:	0f 91       	pop	r16
    abf6:	ff 90       	pop	r15
    abf8:	ef 90       	pop	r14
    abfa:	08 95       	ret
// ~~~~~~~~~~~~~~~~~
void
MenuEnterRight(void)
{
//	1) Hide current Message
	if(HideMsg()||KeyFunc(&CurrPage->Enter))
    abfc:	80 91 d1 02 	lds	r24, 0x02D1
    ac00:	90 91 d2 02 	lds	r25, 0x02D2
    ac04:	0c 96       	adiw	r24, 0x0c	; 12
    ac06:	0e 94 63 3b 	call	0x76c6	; 0x76c6 <KeyFunc>
    ac0a:	88 23       	and	r24, r24
    ac0c:	81 f7       	brne	.-32     	; 0xabee <MenuEnterRight+0x14>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    ac0e:	40 91 d1 02 	lds	r20, 0x02D1
    ac12:	50 91 d2 02 	lds	r21, 0x02D2
    ac16:	fa 01       	movw	r30, r20
    ac18:	c5 91       	lpm	r28, Z+
    ac1a:	d4 91       	lpm	r29, Z+
		return;

	MenuLine *Line=GetLine+CurrLine;
    ac1c:	90 91 79 07 	lds	r25, 0x0779
    ac20:	8b e1       	ldi	r24, 0x1B	; 27
    ac22:	98 9f       	mul	r25, r24
    ac24:	b0 01       	movw	r22, r0
    ac26:	11 24       	eor	r1, r1
    ac28:	c6 0f       	add	r28, r22
    ac2a:	d7 1f       	adc	r29, r23
    ac2c:	fe 01       	movw	r30, r28
    ac2e:	77 96       	adiw	r30, 0x17	; 23
    ac30:	e5 90       	lpm	r14, Z+
    ac32:	f4 90       	lpm	r15, Z+
	OutField *Field=prp(&Line->OF_List);

// 2) Variable
	if(Field){
    ac34:	e1 14       	cp	r14, r1
    ac36:	f1 04       	cpc	r15, r1
    ac38:	09 f4       	brne	.+2      	; 0xac3c <MenuEnterRight+0x62>
    ac3a:	93 c0       	rjmp	.+294    	; 0xad62 <MenuEnterRight+0x188>
    ac3c:	10 e0       	ldi	r17, 0x00	; 0
    ac3e:	30 e0       	ldi	r19, 0x00	; 0
    ac40:	80 e0       	ldi	r24, 0x00	; 0
    ac42:	90 e0       	ldi	r25, 0x00	; 0
    ac44:	05 c0       	rjmp	.+10     	; 0xac50 <MenuEnterRight+0x76>
		uint8_t i=0;
		while(i<LCDXSz) {
			Char1 = Char2;
			Char2 = prc(CurrStr+i++);
			if (Char2=='}' && Char1!='}')
				FieldNumber++;
    ac46:	01 96       	adiw	r24, 0x01	; 1
	// Define variable quantity 
		uint8_t FieldNumber = 0;
		PGM_P CurrStr=(PGM_P)(Line->Str);
		char Char1, Char2=0;
		uint8_t i=0;
		while(i<LCDXSz) {
    ac48:	84 31       	cpi	r24, 0x14	; 20
    ac4a:	91 05       	cpc	r25, r1
    ac4c:	71 f0       	breq	.+28     	; 0xac6a <MenuEnterRight+0x90>
    ac4e:	32 2f       	mov	r19, r18

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    ac50:	fe 01       	movw	r30, r28
    ac52:	e8 0f       	add	r30, r24
    ac54:	f9 1f       	adc	r31, r25
    ac56:	24 91       	lpm	r18, Z+
			Char1 = Char2;
			Char2 = prc(CurrStr+i++);
			if (Char2=='}' && Char1!='}')
    ac58:	2d 37       	cpi	r18, 0x7D	; 125
    ac5a:	a9 f7       	brne	.-22     	; 0xac46 <MenuEnterRight+0x6c>
    ac5c:	3d 37       	cpi	r19, 0x7D	; 125
    ac5e:	99 f3       	breq	.-26     	; 0xac46 <MenuEnterRight+0x6c>
				FieldNumber++;
    ac60:	1f 5f       	subi	r17, 0xFF	; 255
    ac62:	01 96       	adiw	r24, 0x01	; 1
	// Define variable quantity 
		uint8_t FieldNumber = 0;
		PGM_P CurrStr=(PGM_P)(Line->Str);
		char Char1, Char2=0;
		uint8_t i=0;
		while(i<LCDXSz) {
    ac64:	84 31       	cpi	r24, 0x14	; 20
    ac66:	91 05       	cpc	r25, r1
    ac68:	91 f7       	brne	.-28     	; 0xac4e <MenuEnterRight+0x74>
			Char2 = prc(CurrStr+i++);
			if (Char2=='}' && Char1!='}')
				FieldNumber++;
		}
		//    Bit (:)   
		if(FieldNumber==1 && prb(&Field->Type)==Bit) {
    ac6a:	11 30       	cpi	r17, 0x01	; 1
    ac6c:	09 f4       	brne	.+2      	; 0xac70 <MenuEnterRight+0x96>
    ac6e:	b8 c0       	rjmp	.+368    	; 0xade0 <MenuEnterRight+0x206>
			EventFunc(&Field->Act);
			return;
		}

	//    
		if(CurrPos!=NullPos && --CurrPos!=NullPos){
    ac70:	80 91 d4 02 	lds	r24, 0x02D4
    ac74:	8f 3f       	cpi	r24, 0xFF	; 255
    ac76:	09 f4       	brne	.+2      	; 0xac7a <MenuEnterRight+0xa0>
    ac78:	4a c0       	rjmp	.+148    	; 0xad0e <MenuEnterRight+0x134>
    ac7a:	08 2f       	mov	r16, r24
    ac7c:	01 50       	subi	r16, 0x01	; 1
    ac7e:	00 93 d4 02 	sts	0x02D4, r16
    ac82:	0f 3f       	cpi	r16, 0xFF	; 255
    ac84:	09 f4       	brne	.+2      	; 0xac88 <MenuEnterRight+0xae>
    ac86:	43 c0       	rjmp	.+134    	; 0xad0e <MenuEnterRight+0x134>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    ac88:	fa 01       	movw	r30, r20
    ac8a:	45 91       	lpm	r20, Z+
    ac8c:	54 91       	lpm	r21, Z+
			OutField *Field1=GetField;
    ac8e:	46 0f       	add	r20, r22
    ac90:	57 1f       	adc	r21, r23
    ac92:	49 5e       	subi	r20, 0xE9	; 233
    ac94:	5f 4f       	sbci	r21, 0xFF	; 255
    ac96:	fa 01       	movw	r30, r20
    ac98:	25 91       	lpm	r18, Z+
    ac9a:	34 91       	lpm	r19, Z+
    ac9c:	80 91 d3 02 	lds	r24, 0x02D3
    aca0:	90 e0       	ldi	r25, 0x00	; 0
    aca2:	82 95       	swap	r24
    aca4:	92 95       	swap	r25
    aca6:	90 7f       	andi	r25, 0xF0	; 240
    aca8:	98 27       	eor	r25, r24
    acaa:	80 7f       	andi	r24, 0xF0	; 240
    acac:	98 27       	eor	r25, r24
    acae:	28 0f       	add	r18, r24
    acb0:	39 1f       	adc	r19, r25

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    acb2:	f9 01       	movw	r30, r18
    acb4:	84 91       	lpm	r24, Z+
			switch(prb(&Field1->Type)){
    acb6:	8d 31       	cpi	r24, 0x1D	; 29
    acb8:	08 f4       	brcc	.+2      	; 0xacbc <MenuEnterRight+0xe2>
    acba:	67 c0       	rjmp	.+206    	; 0xad8a <MenuEnterRight+0x1b0>
    acbc:	81 52       	subi	r24, 0x21	; 33
    acbe:	82 30       	cpi	r24, 0x02	; 2
    acc0:	08 f0       	brcs	.+2      	; 0xacc4 <MenuEnterRight+0xea>
    acc2:	95 cf       	rjmp	.-214    	; 0xabee <MenuEnterRight+0x14>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    acc4:	f9 01       	movw	r30, r18
    acc6:	33 96       	adiw	r30, 0x03	; 3
    acc8:	85 91       	lpm	r24, Z+
    acca:	95 91       	lpm	r25, Z+
    accc:	a5 91       	lpm	r26, Z+
    acce:	b4 91       	lpm	r27, Z+
			case Text: case EE_Text:
				if( (prd(&Field1->Min) == DIGIT) && (prd(&Field1->Max) == DIGIT) )
    acd0:	00 97       	sbiw	r24, 0x00	; 0
    acd2:	a1 05       	cpc	r26, r1
    acd4:	b1 05       	cpc	r27, r1
    acd6:	59 f4       	brne	.+22     	; 0xacee <MenuEnterRight+0x114>
    acd8:	f9 01       	movw	r30, r18
    acda:	37 96       	adiw	r30, 0x07	; 7
    acdc:	85 91       	lpm	r24, Z+
    acde:	95 91       	lpm	r25, Z+
    ace0:	a5 91       	lpm	r26, Z+
    ace2:	b4 91       	lpm	r27, Z+
    ace4:	00 97       	sbiw	r24, 0x00	; 0
    ace6:	a1 05       	cpc	r26, r1
    ace8:	b1 05       	cpc	r27, r1
    acea:	09 f4       	brne	.+2      	; 0xacee <MenuEnterRight+0x114>
    acec:	a3 c0       	rjmp	.+326    	; 0xae34 <MenuEnterRight+0x25a>
					MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[CurrFieldSize - 1 - CurrPos]);
				else MultiSymbol = GetMultiSymbol(Symbols_P, BufStr[CurrFieldSize - 1 - CurrPos]);
    acee:	e0 91 70 07 	lds	r30, 0x0770
    acf2:	f0 e0       	ldi	r31, 0x00	; 0
    acf4:	31 97       	sbiw	r30, 0x01	; 1
    acf6:	e0 1b       	sub	r30, r16
    acf8:	f1 09       	sbc	r31, r1
    acfa:	e6 54       	subi	r30, 0x46	; 70
    acfc:	fa 4f       	sbci	r31, 0xFA	; 250
    acfe:	89 ec       	ldi	r24, 0xC9	; 201
    ad00:	95 e0       	ldi	r25, 0x05	; 5
    ad02:	60 81       	ld	r22, Z
    ad04:	0e 94 bc 3f 	call	0x7f78	; 0x7f78 <GetMultiSymbol>
    ad08:	80 93 eb 04 	sts	0x04EB, r24
    ad0c:	70 cf       	rjmp	.-288    	; 0xabee <MenuEnterRight+0x14>
				break;		
			}
			return;
		}

		if(CurrField!=NullPos) {
    ad0e:	80 91 d3 02 	lds	r24, 0x02D3
    ad12:	8f 3f       	cpi	r24, 0xFF	; 255
    ad14:	81 f0       	breq	.+32     	; 0xad36 <MenuEnterRight+0x15c>
			Buf2Field(Field+CurrField);
    ad16:	90 e0       	ldi	r25, 0x00	; 0
    ad18:	82 95       	swap	r24
    ad1a:	92 95       	swap	r25
    ad1c:	90 7f       	andi	r25, 0xF0	; 240
    ad1e:	98 27       	eor	r25, r24
    ad20:	80 7f       	andi	r24, 0xF0	; 240
    ad22:	98 27       	eor	r25, r24
    ad24:	8e 0d       	add	r24, r14
    ad26:	9f 1d       	adc	r25, r15
    ad28:	0e 94 8e 52 	call	0xa51c	; 0xa51c <Buf2Field>
			if(CurrField==NullPos)
    ad2c:	80 91 d3 02 	lds	r24, 0x02D3
    ad30:	8f 3f       	cpi	r24, 0xFF	; 255
    ad32:	09 f4       	brne	.+2      	; 0xad36 <MenuEnterRight+0x15c>
    ad34:	5c cf       	rjmp	.-328    	; 0xabee <MenuEnterRight+0x14>
				return;
		}
		//     
		if(++CurrField==FieldNumber)
    ad36:	8f 5f       	subi	r24, 0xFF	; 255
    ad38:	80 93 d3 02 	sts	0x02D3, r24
    ad3c:	18 17       	cp	r17, r24
    ad3e:	d9 f1       	breq	.+118    	; 0xadb6 <MenuEnterRight+0x1dc>
			CurrField=NullPos;
		else
			Field2Buf(Field+CurrField);
    ad40:	90 e0       	ldi	r25, 0x00	; 0
    ad42:	82 95       	swap	r24
    ad44:	92 95       	swap	r25
    ad46:	90 7f       	andi	r25, 0xF0	; 240
    ad48:	98 27       	eor	r25, r24
    ad4a:	80 7f       	andi	r24, 0xF0	; 240
    ad4c:	98 27       	eor	r25, r24
    ad4e:	8e 0d       	add	r24, r14
    ad50:	9f 1d       	adc	r25, r15
    ad52:	0e 94 d6 4e 	call	0x9dac	; 0x9dac <Field2Buf>
    ad56:	40 91 d1 02 	lds	r20, 0x02D1
    ad5a:	50 91 d2 02 	lds	r21, 0x02D2
    ad5e:	90 91 79 07 	lds	r25, 0x0779

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    ad62:	4e 5f       	subi	r20, 0xFE	; 254
    ad64:	5f 4f       	sbci	r21, 0xFF	; 255
    ad66:	fa 01       	movw	r30, r20
    ad68:	84 91       	lpm	r24, Z+
	}

// 3) Go to menu
	if( CurrLine >= prb(&CurrPage->LineNumber) )
    ad6a:	98 17       	cp	r25, r24
    ad6c:	08 f0       	brcs	.+2      	; 0xad70 <MenuEnterRight+0x196>
    ad6e:	3f cf       	rjmp	.-386    	; 0xabee <MenuEnterRight+0x14>
		return;

	if(NextPage || (NextPage=prp(&Line->InnPage))) {
    ad70:	80 91 d0 05 	lds	r24, 0x05D0
    ad74:	90 91 d1 05 	lds	r25, 0x05D1
    ad78:	00 97       	sbiw	r24, 0x00	; 0
    ad7a:	39 f1       	breq	.+78     	; 0xadca <MenuEnterRight+0x1f0>
		GotoMenu(NextPage);
    ad7c:	0e 94 75 3b 	call	0x76ea	; 0x76ea <GotoMenu>
		NextPage=NULL;
    ad80:	10 92 d1 05 	sts	0x05D1, r1
    ad84:	10 92 d0 05 	sts	0x05D0, r1
    ad88:	32 cf       	rjmp	.-412    	; 0xabee <MenuEnterRight+0x14>
		}

	//    
		if(CurrPos!=NullPos && --CurrPos!=NullPos){
			OutField *Field1=GetField;
			switch(prb(&Field1->Type)){
    ad8a:	89 31       	cpi	r24, 0x19	; 25
    ad8c:	20 f4       	brcc	.+8      	; 0xad96 <MenuEnterRight+0x1bc>
    ad8e:	80 51       	subi	r24, 0x10	; 16
    ad90:	86 30       	cpi	r24, 0x06	; 6
    ad92:	08 f0       	brcs	.+2      	; 0xad96 <MenuEnterRight+0x1bc>
    ad94:	2c cf       	rjmp	.-424    	; 0xabee <MenuEnterRight+0x14>
					MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[CurrFieldSize - 1 - CurrPos]);
				else MultiSymbol = GetMultiSymbol(Symbols_P, BufStr[CurrFieldSize - 1 - CurrPos]);
				break;
			case Longint: case z_Longint: case EE_Longint: case z_EE_Longint: case s_Longint: case s_EE_Longint:
			case FFloat: case EE_FFloat: case GFloat: case EE_GFloat:
				MultiSymbol = GetMultiSymbol(Digits_P, BufStr[CurrFieldSize - 1 - CurrPos]);
    ad96:	e0 91 70 07 	lds	r30, 0x0770
    ad9a:	f0 e0       	ldi	r31, 0x00	; 0
    ad9c:	31 97       	sbiw	r30, 0x01	; 1
    ad9e:	e0 1b       	sub	r30, r16
    ada0:	f1 09       	sbc	r31, r1
    ada2:	e6 54       	subi	r30, 0x46	; 70
    ada4:	fa 4f       	sbci	r31, 0xFA	; 250
    ada6:	82 e7       	ldi	r24, 0x72	; 114
    ada8:	96 e0       	ldi	r25, 0x06	; 6
    adaa:	60 81       	ld	r22, Z
    adac:	0e 94 bc 3f 	call	0x7f78	; 0x7f78 <GetMultiSymbol>
    adb0:	80 93 eb 04 	sts	0x04EB, r24
    adb4:	1c cf       	rjmp	.-456    	; 0xabee <MenuEnterRight+0x14>
			if(CurrField==NullPos)
				return;
		}
		//     
		if(++CurrField==FieldNumber)
			CurrField=NullPos;
    adb6:	8f ef       	ldi	r24, 0xFF	; 255
    adb8:	80 93 d3 02 	sts	0x02D3, r24
    adbc:	40 91 d1 02 	lds	r20, 0x02D1
    adc0:	50 91 d2 02 	lds	r21, 0x02D2
    adc4:	90 91 79 07 	lds	r25, 0x0779
    adc8:	cc cf       	rjmp	.-104    	; 0xad62 <MenuEnterRight+0x188>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    adca:	fe 01       	movw	r30, r28
    adcc:	79 96       	adiw	r30, 0x19	; 25
    adce:	85 91       	lpm	r24, Z+
    add0:	94 91       	lpm	r25, Z+

// 3) Go to menu
	if( CurrLine >= prb(&CurrPage->LineNumber) )
		return;

	if(NextPage || (NextPage=prp(&Line->InnPage))) {
    add2:	90 93 d1 05 	sts	0x05D1, r25
    add6:	80 93 d0 05 	sts	0x05D0, r24
    adda:	00 97       	sbiw	r24, 0x00	; 0
    addc:	79 f6       	brne	.-98     	; 0xad7c <MenuEnterRight+0x1a2>
    adde:	07 cf       	rjmp	.-498    	; 0xabee <MenuEnterRight+0x14>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    ade0:	f7 01       	movw	r30, r14
    ade2:	84 91       	lpm	r24, Z+
			Char2 = prc(CurrStr+i++);
			if (Char2=='}' && Char1!='}')
				FieldNumber++;
		}
		//    Bit (:)   
		if(FieldNumber==1 && prb(&Field->Type)==Bit) {
    ade4:	8f 31       	cpi	r24, 0x1F	; 31
    ade6:	09 f0       	breq	.+2      	; 0xadea <MenuEnterRight+0x210>
    ade8:	43 cf       	rjmp	.-378    	; 0xac70 <MenuEnterRight+0x96>
    adea:	8f e0       	ldi	r24, 0x0F	; 15
    adec:	90 e0       	ldi	r25, 0x00	; 0
    adee:	e8 0e       	add	r14, r24
    adf0:	f9 1e       	adc	r15, r25
    adf2:	f7 01       	movw	r30, r14
    adf4:	24 91       	lpm	r18, Z+
    adf6:	81 ef       	ldi	r24, 0xF1	; 241
    adf8:	9f ef       	ldi	r25, 0xFF	; 255
    adfa:	e8 0e       	add	r14, r24
    adfc:	f9 1e       	adc	r15, r25

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    adfe:	c7 01       	movw	r24, r14
    ae00:	01 96       	adiw	r24, 0x01	; 1
    ae02:	fc 01       	movw	r30, r24
    ae04:	a5 91       	lpm	r26, Z+
    ae06:	b4 91       	lpm	r27, Z+
			uint8_t BitN=prb(&Field->Prec);
			*((uint8_t*)prp(&Field->Var)+BitN/8) ^=(1<<BitN%8);
    ae08:	82 2f       	mov	r24, r18
    ae0a:	86 95       	lsr	r24
    ae0c:	86 95       	lsr	r24
    ae0e:	86 95       	lsr	r24
    ae10:	a8 0f       	add	r26, r24
    ae12:	b1 1d       	adc	r27, r1
    ae14:	27 70       	andi	r18, 0x07	; 7
    ae16:	81 e0       	ldi	r24, 0x01	; 1
    ae18:	90 e0       	ldi	r25, 0x00	; 0
    ae1a:	02 c0       	rjmp	.+4      	; 0xae20 <MenuEnterRight+0x246>
    ae1c:	88 0f       	add	r24, r24
    ae1e:	99 1f       	adc	r25, r25
    ae20:	2a 95       	dec	r18
    ae22:	e2 f7       	brpl	.-8      	; 0xae1c <MenuEnterRight+0x242>
    ae24:	2c 91       	ld	r18, X
    ae26:	28 27       	eor	r18, r24
    ae28:	2c 93       	st	X, r18
			EventFunc(&Field->Act);
    ae2a:	c7 01       	movw	r24, r14
    ae2c:	0b 96       	adiw	r24, 0x0b	; 11
    ae2e:	0e 94 5b 3b 	call	0x76b6	; 0x76b6 <EventFunc>
    ae32:	dd ce       	rjmp	.-582    	; 0xabee <MenuEnterRight+0x14>
		if(CurrPos!=NullPos && --CurrPos!=NullPos){
			OutField *Field1=GetField;
			switch(prb(&Field1->Type)){
			case Text: case EE_Text:
				if( (prd(&Field1->Min) == DIGIT) && (prd(&Field1->Max) == DIGIT) )
					MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[CurrFieldSize - 1 - CurrPos]);
    ae34:	e0 91 70 07 	lds	r30, 0x0770
    ae38:	f0 e0       	ldi	r31, 0x00	; 0
    ae3a:	31 97       	sbiw	r30, 0x01	; 1
    ae3c:	e0 1b       	sub	r30, r16
    ae3e:	f1 09       	sbc	r31, r1
    ae40:	e6 54       	subi	r30, 0x46	; 70
    ae42:	fa 4f       	sbci	r31, 0xFA	; 250
    ae44:	87 e6       	ldi	r24, 0x67	; 103
    ae46:	96 e0       	ldi	r25, 0x06	; 6
    ae48:	60 81       	ld	r22, Z
    ae4a:	0e 94 bc 3f 	call	0x7f78	; 0x7f78 <GetMultiSymbol>
    ae4e:	80 93 eb 04 	sts	0x04EB, r24
    ae52:	cd ce       	rjmp	.-614    	; 0xabee <MenuEnterRight+0x14>

0000ae54 <MenuUD>:
	return Pos*Dir;
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
MenuUD(const MenuKey *Key, int8_t Dir, uint8_t LimLine, uint8_t LimLCD, uint8_t LimVar)
{
    ae54:	af 92       	push	r10
    ae56:	bf 92       	push	r11
    ae58:	cf 92       	push	r12
    ae5a:	df 92       	push	r13
    ae5c:	ef 92       	push	r14
    ae5e:	ff 92       	push	r15
    ae60:	0f 93       	push	r16
    ae62:	1f 93       	push	r17
    ae64:	cf 93       	push	r28
    ae66:	df 93       	push	r29
    ae68:	fc 01       	movw	r30, r24
    ae6a:	e6 2e       	mov	r14, r22
    ae6c:	14 2f       	mov	r17, r20
    ae6e:	f2 2e       	mov	r15, r18
	if(CurrMsg || KeyFunc(Key))
    ae70:	80 91 ec 04 	lds	r24, 0x04EC
    ae74:	90 91 ed 04 	lds	r25, 0x04ED
    ae78:	89 2b       	or	r24, r25
    ae7a:	59 f0       	breq	.+22     	; 0xae92 <MenuUD+0x3e>
		else 		{if(--MultiSymbol == 255) MultiSymbol = strlen_P(Digits_P)-1;}
		if(CurrPos!=NullPos)
			BufStr[CurrFieldSize - 1 - CurrPos] = prc(Digits_P + MultiSymbol);
		break;
	}
}
    ae7c:	df 91       	pop	r29
    ae7e:	cf 91       	pop	r28
    ae80:	1f 91       	pop	r17
    ae82:	0f 91       	pop	r16
    ae84:	ff 90       	pop	r15
    ae86:	ef 90       	pop	r14
    ae88:	df 90       	pop	r13
    ae8a:	cf 90       	pop	r12
    ae8c:	bf 90       	pop	r11
    ae8e:	af 90       	pop	r10
    ae90:	08 95       	ret
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
MenuUD(const MenuKey *Key, int8_t Dir, uint8_t LimLine, uint8_t LimLCD, uint8_t LimVar)
{
	if(CurrMsg || KeyFunc(Key))
    ae92:	cf 01       	movw	r24, r30
    ae94:	0e 94 63 3b 	call	0x76c6	; 0x76c6 <KeyFunc>
    ae98:	88 23       	and	r24, r24
    ae9a:	81 f7       	brne	.-32     	; 0xae7c <MenuUD+0x28>
		return;
	if(CurrField==NullPos) {
    ae9c:	30 91 d3 02 	lds	r19, 0x02D3
    aea0:	3f 3f       	cpi	r19, 0xFF	; 255
    aea2:	09 f4       	brne	.+2      	; 0xaea6 <MenuUD+0x52>
    aea4:	48 c1       	rjmp	.+656    	; 0xb136 <MenuUD+0x2e2>
			if(LimLCD)
				CurrLCD -= Dir;
		}
		return;
	}
	Blink=0;
    aea6:	10 92 c6 08 	sts	0x08C6, r1
    aeaa:	80 91 d1 02 	lds	r24, 0x02D1
    aeae:	90 91 d2 02 	lds	r25, 0x02D2
    aeb2:	fc 01       	movw	r30, r24
    aeb4:	45 91       	lpm	r20, Z+
    aeb6:	54 91       	lpm	r21, Z+
	OutField *Field=GetField;
    aeb8:	80 91 79 07 	lds	r24, 0x0779
    aebc:	2b e1       	ldi	r18, 0x1B	; 27
    aebe:	82 9f       	mul	r24, r18
    aec0:	c0 01       	movw	r24, r0
    aec2:	11 24       	eor	r1, r1
    aec4:	48 0f       	add	r20, r24
    aec6:	59 1f       	adc	r21, r25
    aec8:	49 5e       	subi	r20, 0xE9	; 233
    aeca:	5f 4f       	sbci	r21, 0xFF	; 255
    aecc:	fa 01       	movw	r30, r20
    aece:	c5 91       	lpm	r28, Z+
    aed0:	d4 91       	lpm	r29, Z+
    aed2:	83 2f       	mov	r24, r19
    aed4:	90 e0       	ldi	r25, 0x00	; 0
    aed6:	82 95       	swap	r24
    aed8:	92 95       	swap	r25
    aeda:	90 7f       	andi	r25, 0xF0	; 240
    aedc:	98 27       	eor	r25, r24
    aede:	80 7f       	andi	r24, 0xF0	; 240
    aee0:	98 27       	eor	r25, r24
    aee2:	c8 0f       	add	r28, r24
    aee4:	d9 1f       	adc	r29, r25

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    aee6:	fe 01       	movw	r30, r28
    aee8:	84 91       	lpm	r24, Z+
	switch(prb(&Field->Type)) {
    aeea:	e8 2f       	mov	r30, r24
    aeec:	f0 e0       	ldi	r31, 0x00	; 0
    aeee:	e3 32       	cpi	r30, 0x23	; 35
    aef0:	f1 05       	cpc	r31, r1
    aef2:	08 f0       	brcs	.+2      	; 0xaef6 <MenuUD+0xa2>
    aef4:	c3 cf       	rjmp	.-122    	; 0xae7c <MenuUD+0x28>
    aef6:	ea 54       	subi	r30, 0x4A	; 74
    aef8:	ff 4f       	sbci	r31, 0xFF	; 255
    aefa:	ee 0f       	add	r30, r30
    aefc:	ff 1f       	adc	r31, r31
    aefe:	05 90       	lpm	r0, Z+
    af00:	f4 91       	lpm	r31, Z+
    af02:	e0 2d       	mov	r30, r0
    af04:	19 94       	eijmp

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    af06:	fe 01       	movw	r30, r28
    af08:	33 96       	adiw	r30, 0x03	; 3
    af0a:	85 91       	lpm	r24, Z+
    af0c:	95 91       	lpm	r25, Z+
    af0e:	a5 91       	lpm	r26, Z+
    af10:	b4 91       	lpm	r27, Z+
		break;
	case Bit: case EE_Bit:
		F_Buf = !F_Buf;
		break;
	case Text: case EE_Text:
		if( (prd(&Field->Min) == DIGIT) && (prd(&Field->Max) == DIGIT) ){
    af12:	00 97       	sbiw	r24, 0x00	; 0
    af14:	a1 05       	cpc	r26, r1
    af16:	b1 05       	cpc	r27, r1
    af18:	09 f0       	breq	.+2      	; 0xaf1c <MenuUD+0xc8>
    af1a:	1e c1       	rjmp	.+572    	; 0xb158 <MenuUD+0x304>
    af1c:	fe 01       	movw	r30, r28
    af1e:	37 96       	adiw	r30, 0x07	; 7
    af20:	85 91       	lpm	r24, Z+
    af22:	95 91       	lpm	r25, Z+
    af24:	a5 91       	lpm	r26, Z+
    af26:	b4 91       	lpm	r27, Z+
    af28:	00 97       	sbiw	r24, 0x00	; 0
    af2a:	a1 05       	cpc	r26, r1
    af2c:	b1 05       	cpc	r27, r1
    af2e:	09 f0       	breq	.+2      	; 0xaf32 <MenuUD+0xde>
    af30:	13 c1       	rjmp	.+550    	; 0xb158 <MenuUD+0x304>
			if(Dir==1){	if(++MultiSymbol > 9) MultiSymbol = 0;}
    af32:	31 e0       	ldi	r19, 0x01	; 1
    af34:	e3 16       	cp	r14, r19
    af36:	09 f4       	brne	.+2      	; 0xaf3a <MenuUD+0xe6>
    af38:	92 c1       	rjmp	.+804    	; 0xb25e <MenuUD+0x40a>
			else{		if(--MultiSymbol == 255) MultiSymbol = 9;}
    af3a:	80 91 eb 04 	lds	r24, 0x04EB
    af3e:	81 50       	subi	r24, 0x01	; 1
    af40:	80 93 eb 04 	sts	0x04EB, r24
    af44:	8f 3f       	cpi	r24, 0xFF	; 255
    af46:	09 f4       	brne	.+2      	; 0xaf4a <MenuUD+0xf6>
    af48:	93 c1       	rjmp	.+806    	; 0xb270 <MenuUD+0x41c>
		}
		else{
			if(Dir==1){	if(++MultiSymbol >= strlen_P(Symbols_P)) MultiSymbol = 0;}
			else{		if(--MultiSymbol == 255) MultiSymbol = strlen_P(Symbols_P)-1;}
		}
		if(CurrPos!=NullPos)
    af4a:	90 91 d4 02 	lds	r25, 0x02D4
    af4e:	9f 3f       	cpi	r25, 0xFF	; 255
    af50:	09 f4       	brne	.+2      	; 0xaf54 <MenuUD+0x100>
    af52:	94 cf       	rjmp	.-216    	; 0xae7c <MenuUD+0x28>

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    af54:	80 91 eb 04 	lds	r24, 0x04EB
    af58:	e8 2f       	mov	r30, r24
    af5a:	f0 e0       	ldi	r31, 0x00	; 0
    af5c:	e7 53       	subi	r30, 0x37	; 55
    af5e:	fa 4f       	sbci	r31, 0xFA	; 250
	case Longint: case z_Longint: case EE_Longint: case z_EE_Longint: case s_Longint: case s_EE_Longint:
	case FFloat: case EE_FFloat: case GFloat: case EE_GFloat:
		if(Dir==1)	{if(++MultiSymbol >= strlen_P(Digits_P)) MultiSymbol = 0;}
		else 		{if(--MultiSymbol == 255) MultiSymbol = strlen_P(Digits_P)-1;}
		if(CurrPos!=NullPos)
			BufStr[CurrFieldSize - 1 - CurrPos] = prc(Digits_P + MultiSymbol);
    af60:	84 91       	lpm	r24, Z+
    af62:	e0 91 70 07 	lds	r30, 0x0770
    af66:	f0 e0       	ldi	r31, 0x00	; 0
    af68:	31 97       	sbiw	r30, 0x01	; 1
    af6a:	e9 1b       	sub	r30, r25
    af6c:	f1 09       	sbc	r31, r1
    af6e:	e6 54       	subi	r30, 0x46	; 70
    af70:	fa 4f       	sbci	r31, 0xFA	; 250
    af72:	80 83       	st	Z, r24
    af74:	83 cf       	rjmp	.-250    	; 0xae7c <MenuUD+0x28>
	case Enum: case EE_Enum:
		if(LimVar)
			F_Buf += Dir;
		break;
	case Bit: case EE_Bit:
		F_Buf = !F_Buf;
    af76:	20 e0       	ldi	r18, 0x00	; 0
    af78:	30 e0       	ldi	r19, 0x00	; 0
    af7a:	40 e0       	ldi	r20, 0x00	; 0
    af7c:	50 e0       	ldi	r21, 0x00	; 0
    af7e:	80 91 ee 04 	lds	r24, 0x04EE
    af82:	90 91 ef 04 	lds	r25, 0x04EF
    af86:	a0 91 f0 04 	lds	r26, 0x04F0
    af8a:	b0 91 f1 04 	lds	r27, 0x04F1
    af8e:	00 97       	sbiw	r24, 0x00	; 0
    af90:	a1 05       	cpc	r26, r1
    af92:	b1 05       	cpc	r27, r1
    af94:	21 f4       	brne	.+8      	; 0xaf9e <MenuUD+0x14a>
    af96:	21 e0       	ldi	r18, 0x01	; 1
    af98:	30 e0       	ldi	r19, 0x00	; 0
    af9a:	40 e0       	ldi	r20, 0x00	; 0
    af9c:	50 e0       	ldi	r21, 0x00	; 0
    af9e:	20 93 ee 04 	sts	0x04EE, r18
    afa2:	30 93 ef 04 	sts	0x04EF, r19
    afa6:	40 93 f0 04 	sts	0x04F0, r20
    afaa:	50 93 f1 04 	sts	0x04F1, r21
    afae:	66 cf       	rjmp	.-308    	; 0xae7c <MenuUD+0x28>
			Buf2Field(Field);
			Field2Buf(Field);
		}
		break;
	case Enum: case EE_Enum:
		if(LimVar)
    afb0:	00 23       	and	r16, r16
    afb2:	09 f4       	brne	.+2      	; 0xafb6 <MenuUD+0x162>
    afb4:	63 cf       	rjmp	.-314    	; 0xae7c <MenuUD+0x28>
			F_Buf += Dir;
    afb6:	2e 2d       	mov	r18, r14
    afb8:	33 27       	eor	r19, r19
    afba:	27 fd       	sbrc	r18, 7
    afbc:	30 95       	com	r19
    afbe:	43 2f       	mov	r20, r19
    afc0:	53 2f       	mov	r21, r19
    afc2:	80 91 ee 04 	lds	r24, 0x04EE
    afc6:	90 91 ef 04 	lds	r25, 0x04EF
    afca:	a0 91 f0 04 	lds	r26, 0x04F0
    afce:	b0 91 f1 04 	lds	r27, 0x04F1
    afd2:	82 0f       	add	r24, r18
    afd4:	93 1f       	adc	r25, r19
    afd6:	a4 1f       	adc	r26, r20
    afd8:	b5 1f       	adc	r27, r21
    afda:	80 93 ee 04 	sts	0x04EE, r24
    afde:	90 93 ef 04 	sts	0x04EF, r25
    afe2:	a0 93 f0 04 	sts	0x04F0, r26
    afe6:	b0 93 f1 04 	sts	0x04F1, r27
    afea:	48 cf       	rjmp	.-368    	; 0xae7c <MenuUD+0x28>
		if(CurrPos!=NullPos)
			BufStr[CurrFieldSize - 1 - CurrPos] = prc(Symbols_P + MultiSymbol);
		break;
	case Longint: case z_Longint: case EE_Longint: case z_EE_Longint: case s_Longint: case s_EE_Longint:
	case FFloat: case EE_FFloat: case GFloat: case EE_GFloat:
		if(Dir==1)	{if(++MultiSymbol >= strlen_P(Digits_P)) MultiSymbol = 0;}
    afec:	51 e0       	ldi	r21, 0x01	; 1
    afee:	e5 16       	cp	r14, r21
    aff0:	09 f4       	brne	.+2      	; 0xaff4 <MenuUD+0x1a0>
    aff2:	fb c0       	rjmp	.+502    	; 0xb1ea <MenuUD+0x396>
		else 		{if(--MultiSymbol == 255) MultiSymbol = strlen_P(Digits_P)-1;}
    aff4:	80 91 eb 04 	lds	r24, 0x04EB
    aff8:	81 50       	subi	r24, 0x01	; 1
    affa:	80 93 eb 04 	sts	0x04EB, r24
    affe:	8f 3f       	cpi	r24, 0xFF	; 255
    b000:	09 f4       	brne	.+2      	; 0xb004 <MenuUD+0x1b0>
    b002:	14 c1       	rjmp	.+552    	; 0xb22c <MenuUD+0x3d8>
		if(CurrPos!=NullPos)
    b004:	90 91 d4 02 	lds	r25, 0x02D4
    b008:	9f 3f       	cpi	r25, 0xFF	; 255
    b00a:	09 f4       	brne	.+2      	; 0xb00e <MenuUD+0x1ba>
    b00c:	37 cf       	rjmp	.-402    	; 0xae7c <MenuUD+0x28>
    b00e:	80 91 eb 04 	lds	r24, 0x04EB
    b012:	e8 2f       	mov	r30, r24
    b014:	f0 e0       	ldi	r31, 0x00	; 0
    b016:	ee 58       	subi	r30, 0x8E	; 142
    b018:	f9 4f       	sbci	r31, 0xF9	; 249
    b01a:	a2 cf       	rjmp	.-188    	; 0xaf60 <MenuUD+0x10c>
			sF_Buf += Inc(Dir, sF_Buf);
		else if(sF_Buf<0 || sF_Buf==0 && Minus)
			Minus = (sF_Buf-=Inc(Dir, -sF_Buf))==0;
		break;
	case c_Word: case zc_Word:
		if(LimVar) {
    b01c:	00 23       	and	r16, r16
    b01e:	09 f4       	brne	.+2      	; 0xb022 <MenuUD+0x1ce>
    b020:	2d cf       	rjmp	.-422    	; 0xae7c <MenuUD+0x28>
			F_Buf += Dir;
    b022:	2e 2d       	mov	r18, r14
    b024:	33 27       	eor	r19, r19
    b026:	27 fd       	sbrc	r18, 7
    b028:	30 95       	com	r19
    b02a:	43 2f       	mov	r20, r19
    b02c:	53 2f       	mov	r21, r19
    b02e:	80 91 ee 04 	lds	r24, 0x04EE
    b032:	90 91 ef 04 	lds	r25, 0x04EF
    b036:	a0 91 f0 04 	lds	r26, 0x04F0
    b03a:	b0 91 f1 04 	lds	r27, 0x04F1
    b03e:	82 0f       	add	r24, r18
    b040:	93 1f       	adc	r25, r19
    b042:	a4 1f       	adc	r26, r20
    b044:	b5 1f       	adc	r27, r21
    b046:	80 93 ee 04 	sts	0x04EE, r24
    b04a:	90 93 ef 04 	sts	0x04EF, r25
    b04e:	a0 93 f0 04 	sts	0x04F0, r26
    b052:	b0 93 f1 04 	sts	0x04F1, r27
			Buf2Field(Field);
    b056:	ce 01       	movw	r24, r28
    b058:	0e 94 8e 52 	call	0xa51c	; 0xa51c <Buf2Field>
			Field2Buf(Field);
    b05c:	ce 01       	movw	r24, r28
    b05e:	0e 94 d6 4e 	call	0x9dac	; 0x9dac <Field2Buf>
    b062:	0c cf       	rjmp	.-488    	; 0xae7c <MenuUD+0x28>
	case Word: case EE_Word: case z_Word: case z_EE_Word:
		F_Buf += Inc(Dir, F_Buf);
		break;
	case s_Byte: case s_EE_Byte:
	case s_Word: case s_EE_Word:
		if(CurrPos==Log10(prd(&Field->Max))+1) {
    b064:	00 91 d4 02 	lds	r16, 0x02D4
    b068:	10 e0       	ldi	r17, 0x00	; 0

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    b06a:	fe 01       	movw	r30, r28
    b06c:	37 96       	adiw	r30, 0x07	; 7
    b06e:	65 91       	lpm	r22, Z+
    b070:	75 91       	lpm	r23, Z+
    b072:	85 91       	lpm	r24, Z+
    b074:	94 91       	lpm	r25, Z+
    b076:	0e 94 f3 1f 	call	0x3fe6	; 0x3fe6 <Log10>
    b07a:	90 e0       	ldi	r25, 0x00	; 0
    b07c:	01 96       	adiw	r24, 0x01	; 1
    b07e:	08 17       	cp	r16, r24
    b080:	19 07       	cpc	r17, r25
    b082:	09 f4       	brne	.+2      	; 0xb086 <MenuUD+0x232>
    b084:	9c c0       	rjmp	.+312    	; 0xb1be <MenuUD+0x36a>
			if(sF_Buf==0)
				Minus = !Minus;
			else
				sF_Buf = -sF_Buf;
		}
		else if(sF_Buf>0 || sF_Buf==0 && !Minus)
    b086:	a0 90 f2 04 	lds	r10, 0x04F2
    b08a:	b0 90 f3 04 	lds	r11, 0x04F3
    b08e:	c0 90 f4 04 	lds	r12, 0x04F4
    b092:	d0 90 f5 04 	lds	r13, 0x04F5
    b096:	1a 14       	cp	r1, r10
    b098:	1b 04       	cpc	r1, r11
    b09a:	1c 04       	cpc	r1, r12
    b09c:	1d 04       	cpc	r1, r13
    b09e:	0c f4       	brge	.+2      	; 0xb0a2 <MenuUD+0x24e>
    b0a0:	74 c0       	rjmp	.+232    	; 0xb18a <MenuUD+0x336>
    b0a2:	a1 14       	cp	r10, r1
    b0a4:	b1 04       	cpc	r11, r1
    b0a6:	c1 04       	cpc	r12, r1
    b0a8:	d1 04       	cpc	r13, r1
    b0aa:	09 f4       	brne	.+2      	; 0xb0ae <MenuUD+0x25a>
    b0ac:	69 c0       	rjmp	.+210    	; 0xb180 <MenuUD+0x32c>
			sF_Buf += Inc(Dir, sF_Buf);
		else if(sF_Buf<0 || sF_Buf==0 && Minus)
			Minus = (sF_Buf-=Inc(Dir, -sF_Buf))==0;
    b0ae:	44 27       	eor	r20, r20
    b0b0:	55 27       	eor	r21, r21
    b0b2:	ba 01       	movw	r22, r20
    b0b4:	4a 19       	sub	r20, r10
    b0b6:	5b 09       	sbc	r21, r11
    b0b8:	6c 09       	sbc	r22, r12
    b0ba:	7d 09       	sbc	r23, r13
    b0bc:	8e 2d       	mov	r24, r14
    b0be:	0e 94 3a 3c 	call	0x7874	; 0x7874 <Inc>
    b0c2:	a6 01       	movw	r20, r12
    b0c4:	95 01       	movw	r18, r10
    b0c6:	26 1b       	sub	r18, r22
    b0c8:	37 0b       	sbc	r19, r23
    b0ca:	48 0b       	sbc	r20, r24
    b0cc:	59 0b       	sbc	r21, r25
    b0ce:	20 93 f2 04 	sts	0x04F2, r18
    b0d2:	30 93 f3 04 	sts	0x04F3, r19
    b0d6:	40 93 f4 04 	sts	0x04F4, r20
    b0da:	50 93 f5 04 	sts	0x04F5, r21
    b0de:	10 92 f6 04 	sts	0x04F6, r1
    b0e2:	21 15       	cp	r18, r1
    b0e4:	31 05       	cpc	r19, r1
    b0e6:	41 05       	cpc	r20, r1
    b0e8:	51 05       	cpc	r21, r1
    b0ea:	09 f0       	breq	.+2      	; 0xb0ee <MenuUD+0x29a>
    b0ec:	c7 ce       	rjmp	.-626    	; 0xae7c <MenuUD+0x28>
    b0ee:	81 e0       	ldi	r24, 0x01	; 1
    b0f0:	80 93 f6 04 	sts	0x04F6, r24
    b0f4:	c3 ce       	rjmp	.-634    	; 0xae7c <MenuUD+0x28>
	Blink=0;
	OutField *Field=GetField;
	switch(prb(&Field->Type)) {
	case Byte: case EE_Byte: case z_Byte: case z_EE_Byte:
	case Word: case EE_Word: case z_Word: case z_EE_Word:
		F_Buf += Inc(Dir, F_Buf);
    b0f6:	40 91 ee 04 	lds	r20, 0x04EE
    b0fa:	50 91 ef 04 	lds	r21, 0x04EF
    b0fe:	60 91 f0 04 	lds	r22, 0x04F0
    b102:	70 91 f1 04 	lds	r23, 0x04F1
    b106:	8e 2d       	mov	r24, r14
    b108:	0e 94 3a 3c 	call	0x7874	; 0x7874 <Inc>
    b10c:	20 91 ee 04 	lds	r18, 0x04EE
    b110:	30 91 ef 04 	lds	r19, 0x04EF
    b114:	40 91 f0 04 	lds	r20, 0x04F0
    b118:	50 91 f1 04 	lds	r21, 0x04F1
    b11c:	26 0f       	add	r18, r22
    b11e:	37 1f       	adc	r19, r23
    b120:	48 1f       	adc	r20, r24
    b122:	59 1f       	adc	r21, r25
    b124:	20 93 ee 04 	sts	0x04EE, r18
    b128:	30 93 ef 04 	sts	0x04EF, r19
    b12c:	40 93 f0 04 	sts	0x04F0, r20
    b130:	50 93 f1 04 	sts	0x04F1, r21
    b134:	a3 ce       	rjmp	.-698    	; 0xae7c <MenuUD+0x28>
MenuUD(const MenuKey *Key, int8_t Dir, uint8_t LimLine, uint8_t LimLCD, uint8_t LimVar)
{
	if(CurrMsg || KeyFunc(Key))
		return;
	if(CurrField==NullPos) {
		if(LimLine) {
    b136:	11 23       	and	r17, r17
    b138:	09 f4       	brne	.+2      	; 0xb13c <MenuUD+0x2e8>
    b13a:	a0 ce       	rjmp	.-704    	; 0xae7c <MenuUD+0x28>
			CurrLine -= Dir;
    b13c:	80 91 79 07 	lds	r24, 0x0779
    b140:	8e 19       	sub	r24, r14
    b142:	80 93 79 07 	sts	0x0779, r24
			if(LimLCD)
    b146:	ff 20       	and	r15, r15
    b148:	09 f4       	brne	.+2      	; 0xb14c <MenuUD+0x2f8>
    b14a:	98 ce       	rjmp	.-720    	; 0xae7c <MenuUD+0x28>
				CurrLCD -= Dir;
    b14c:	80 91 96 08 	lds	r24, 0x0896
    b150:	8e 19       	sub	r24, r14
    b152:	80 93 96 08 	sts	0x0896, r24
    b156:	92 ce       	rjmp	.-732    	; 0xae7c <MenuUD+0x28>
		if( (prd(&Field->Min) == DIGIT) && (prd(&Field->Max) == DIGIT) ){
			if(Dir==1){	if(++MultiSymbol > 9) MultiSymbol = 0;}
			else{		if(--MultiSymbol == 255) MultiSymbol = 9;}
		}
		else{
			if(Dir==1){	if(++MultiSymbol >= strlen_P(Symbols_P)) MultiSymbol = 0;}
    b158:	41 e0       	ldi	r20, 0x01	; 1
    b15a:	e4 16       	cp	r14, r20
    b15c:	09 f4       	brne	.+2      	; 0xb160 <MenuUD+0x30c>
    b15e:	6e c0       	rjmp	.+220    	; 0xb23c <MenuUD+0x3e8>
			else{		if(--MultiSymbol == 255) MultiSymbol = strlen_P(Symbols_P)-1;}
    b160:	80 91 eb 04 	lds	r24, 0x04EB
    b164:	81 50       	subi	r24, 0x01	; 1
    b166:	80 93 eb 04 	sts	0x04EB, r24
    b16a:	8f 3f       	cpi	r24, 0xFF	; 255
    b16c:	09 f0       	breq	.+2      	; 0xb170 <MenuUD+0x31c>
    b16e:	ed ce       	rjmp	.-550    	; 0xaf4a <MenuUD+0xf6>
    b170:	89 ec       	ldi	r24, 0xC9	; 201
    b172:	95 e0       	ldi	r25, 0x05	; 5
    b174:	0e 94 e9 79 	call	0xf3d2	; 0xf3d2 <strlen_P>
    b178:	81 50       	subi	r24, 0x01	; 1
    b17a:	80 93 eb 04 	sts	0x04EB, r24
    b17e:	e5 ce       	rjmp	.-566    	; 0xaf4a <MenuUD+0xf6>
			if(sF_Buf==0)
				Minus = !Minus;
			else
				sF_Buf = -sF_Buf;
		}
		else if(sF_Buf>0 || sF_Buf==0 && !Minus)
    b180:	80 91 f6 04 	lds	r24, 0x04F6
    b184:	88 23       	and	r24, r24
    b186:	09 f0       	breq	.+2      	; 0xb18a <MenuUD+0x336>
    b188:	92 cf       	rjmp	.-220    	; 0xb0ae <MenuUD+0x25a>
			sF_Buf += Inc(Dir, sF_Buf);
    b18a:	8e 2d       	mov	r24, r14
    b18c:	b6 01       	movw	r22, r12
    b18e:	a5 01       	movw	r20, r10
    b190:	0e 94 3a 3c 	call	0x7874	; 0x7874 <Inc>
    b194:	20 91 f2 04 	lds	r18, 0x04F2
    b198:	30 91 f3 04 	lds	r19, 0x04F3
    b19c:	40 91 f4 04 	lds	r20, 0x04F4
    b1a0:	50 91 f5 04 	lds	r21, 0x04F5
    b1a4:	26 0f       	add	r18, r22
    b1a6:	37 1f       	adc	r19, r23
    b1a8:	48 1f       	adc	r20, r24
    b1aa:	59 1f       	adc	r21, r25
    b1ac:	20 93 f2 04 	sts	0x04F2, r18
    b1b0:	30 93 f3 04 	sts	0x04F3, r19
    b1b4:	40 93 f4 04 	sts	0x04F4, r20
    b1b8:	50 93 f5 04 	sts	0x04F5, r21
    b1bc:	5f ce       	rjmp	.-834    	; 0xae7c <MenuUD+0x28>
		F_Buf += Inc(Dir, F_Buf);
		break;
	case s_Byte: case s_EE_Byte:
	case s_Word: case s_EE_Word:
		if(CurrPos==Log10(prd(&Field->Max))+1) {
			if(sF_Buf==0)
    b1be:	20 91 f2 04 	lds	r18, 0x04F2
    b1c2:	30 91 f3 04 	lds	r19, 0x04F3
    b1c6:	40 91 f4 04 	lds	r20, 0x04F4
    b1ca:	50 91 f5 04 	lds	r21, 0x04F5
    b1ce:	21 15       	cp	r18, r1
    b1d0:	31 05       	cpc	r19, r1
    b1d2:	41 05       	cpc	r20, r1
    b1d4:	51 05       	cpc	r21, r1
    b1d6:	d1 f4       	brne	.+52     	; 0xb20c <MenuUD+0x3b8>
				Minus = !Minus;
    b1d8:	90 e0       	ldi	r25, 0x00	; 0
    b1da:	80 91 f6 04 	lds	r24, 0x04F6
    b1de:	88 23       	and	r24, r24
    b1e0:	09 f4       	brne	.+2      	; 0xb1e4 <MenuUD+0x390>
    b1e2:	91 e0       	ldi	r25, 0x01	; 1
    b1e4:	90 93 f6 04 	sts	0x04F6, r25
    b1e8:	49 ce       	rjmp	.-878    	; 0xae7c <MenuUD+0x28>
		if(CurrPos!=NullPos)
			BufStr[CurrFieldSize - 1 - CurrPos] = prc(Symbols_P + MultiSymbol);
		break;
	case Longint: case z_Longint: case EE_Longint: case z_EE_Longint: case s_Longint: case s_EE_Longint:
	case FFloat: case EE_FFloat: case GFloat: case EE_GFloat:
		if(Dir==1)	{if(++MultiSymbol >= strlen_P(Digits_P)) MultiSymbol = 0;}
    b1ea:	00 91 eb 04 	lds	r16, 0x04EB
    b1ee:	0f 5f       	subi	r16, 0xFF	; 255
    b1f0:	00 93 eb 04 	sts	0x04EB, r16
    b1f4:	82 e7       	ldi	r24, 0x72	; 114
    b1f6:	96 e0       	ldi	r25, 0x06	; 6
    b1f8:	0e 94 e9 79 	call	0xf3d2	; 0xf3d2 <strlen_P>
    b1fc:	10 e0       	ldi	r17, 0x00	; 0
    b1fe:	08 17       	cp	r16, r24
    b200:	19 07       	cpc	r17, r25
    b202:	08 f4       	brcc	.+2      	; 0xb206 <MenuUD+0x3b2>
    b204:	ff ce       	rjmp	.-514    	; 0xb004 <MenuUD+0x1b0>
    b206:	10 92 eb 04 	sts	0x04EB, r1
    b20a:	fc ce       	rjmp	.-520    	; 0xb004 <MenuUD+0x1b0>
	case s_Word: case s_EE_Word:
		if(CurrPos==Log10(prd(&Field->Max))+1) {
			if(sF_Buf==0)
				Minus = !Minus;
			else
				sF_Buf = -sF_Buf;
    b20c:	88 27       	eor	r24, r24
    b20e:	99 27       	eor	r25, r25
    b210:	dc 01       	movw	r26, r24
    b212:	82 1b       	sub	r24, r18
    b214:	93 0b       	sbc	r25, r19
    b216:	a4 0b       	sbc	r26, r20
    b218:	b5 0b       	sbc	r27, r21
    b21a:	80 93 f2 04 	sts	0x04F2, r24
    b21e:	90 93 f3 04 	sts	0x04F3, r25
    b222:	a0 93 f4 04 	sts	0x04F4, r26
    b226:	b0 93 f5 04 	sts	0x04F5, r27
    b22a:	28 ce       	rjmp	.-944    	; 0xae7c <MenuUD+0x28>
			BufStr[CurrFieldSize - 1 - CurrPos] = prc(Symbols_P + MultiSymbol);
		break;
	case Longint: case z_Longint: case EE_Longint: case z_EE_Longint: case s_Longint: case s_EE_Longint:
	case FFloat: case EE_FFloat: case GFloat: case EE_GFloat:
		if(Dir==1)	{if(++MultiSymbol >= strlen_P(Digits_P)) MultiSymbol = 0;}
		else 		{if(--MultiSymbol == 255) MultiSymbol = strlen_P(Digits_P)-1;}
    b22c:	82 e7       	ldi	r24, 0x72	; 114
    b22e:	96 e0       	ldi	r25, 0x06	; 6
    b230:	0e 94 e9 79 	call	0xf3d2	; 0xf3d2 <strlen_P>
    b234:	81 50       	subi	r24, 0x01	; 1
    b236:	80 93 eb 04 	sts	0x04EB, r24
    b23a:	e4 ce       	rjmp	.-568    	; 0xb004 <MenuUD+0x1b0>
		if( (prd(&Field->Min) == DIGIT) && (prd(&Field->Max) == DIGIT) ){
			if(Dir==1){	if(++MultiSymbol > 9) MultiSymbol = 0;}
			else{		if(--MultiSymbol == 255) MultiSymbol = 9;}
		}
		else{
			if(Dir==1){	if(++MultiSymbol >= strlen_P(Symbols_P)) MultiSymbol = 0;}
    b23c:	00 91 eb 04 	lds	r16, 0x04EB
    b240:	0f 5f       	subi	r16, 0xFF	; 255
    b242:	00 93 eb 04 	sts	0x04EB, r16
    b246:	89 ec       	ldi	r24, 0xC9	; 201
    b248:	95 e0       	ldi	r25, 0x05	; 5
    b24a:	0e 94 e9 79 	call	0xf3d2	; 0xf3d2 <strlen_P>
    b24e:	10 e0       	ldi	r17, 0x00	; 0
    b250:	08 17       	cp	r16, r24
    b252:	19 07       	cpc	r17, r25
    b254:	08 f4       	brcc	.+2      	; 0xb258 <MenuUD+0x404>
    b256:	79 ce       	rjmp	.-782    	; 0xaf4a <MenuUD+0xf6>
    b258:	10 92 eb 04 	sts	0x04EB, r1
    b25c:	76 ce       	rjmp	.-788    	; 0xaf4a <MenuUD+0xf6>
	case Bit: case EE_Bit:
		F_Buf = !F_Buf;
		break;
	case Text: case EE_Text:
		if( (prd(&Field->Min) == DIGIT) && (prd(&Field->Max) == DIGIT) ){
			if(Dir==1){	if(++MultiSymbol > 9) MultiSymbol = 0;}
    b25e:	80 91 eb 04 	lds	r24, 0x04EB
    b262:	8f 5f       	subi	r24, 0xFF	; 255
    b264:	80 93 eb 04 	sts	0x04EB, r24
    b268:	8a 30       	cpi	r24, 0x0A	; 10
    b26a:	08 f4       	brcc	.+2      	; 0xb26e <MenuUD+0x41a>
    b26c:	6e ce       	rjmp	.-804    	; 0xaf4a <MenuUD+0xf6>
    b26e:	f4 cf       	rjmp	.-24     	; 0xb258 <MenuUD+0x404>
			else{		if(--MultiSymbol == 255) MultiSymbol = 9;}
    b270:	89 e0       	ldi	r24, 0x09	; 9
    b272:	80 93 eb 04 	sts	0x04EB, r24
    b276:	69 ce       	rjmp	.-814    	; 0xaf4a <MenuUD+0xf6>

0000b278 <MenuDown>:
}

// ~~~~~~~~~~~
void
MenuDown(void)
{
    b278:	ef 92       	push	r14
    b27a:	ff 92       	push	r15
    b27c:	0f 93       	push	r16
    b27e:	1f 93       	push	r17
    b280:	cf 93       	push	r28
    b282:	df 93       	push	r29
	MenuUD(&CurrPage->Down, -1, prb(&CurrPage->LineNumber)-CurrLine>1, CurrLCD<LCDYSz-1, F_Buf>prd(&GetField->Min));
    b284:	c0 91 d1 02 	lds	r28, 0x02D1
    b288:	d0 91 d2 02 	lds	r29, 0x02D2

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    b28c:	22 96       	adiw	r28, 0x02	; 2
    b28e:	fe 01       	movw	r30, r28
    b290:	24 91       	lpm	r18, Z+
    b292:	22 97       	sbiw	r28, 0x02	; 2
    b294:	40 91 79 07 	lds	r20, 0x0779

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    b298:	fe 01       	movw	r30, r28
    b29a:	65 91       	lpm	r22, Z+
    b29c:	74 91       	lpm	r23, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    b29e:	8b e1       	ldi	r24, 0x1B	; 27
    b2a0:	48 9f       	mul	r20, r24
    b2a2:	c0 01       	movw	r24, r0
    b2a4:	11 24       	eor	r1, r1
    b2a6:	68 0f       	add	r22, r24
    b2a8:	79 1f       	adc	r23, r25
    b2aa:	69 5e       	subi	r22, 0xE9	; 233
    b2ac:	7f 4f       	sbci	r23, 0xFF	; 255
    b2ae:	fb 01       	movw	r30, r22
    b2b0:	a5 91       	lpm	r26, Z+
    b2b2:	b4 91       	lpm	r27, Z+
    b2b4:	80 91 d3 02 	lds	r24, 0x02D3
    b2b8:	90 e0       	ldi	r25, 0x00	; 0
    b2ba:	82 95       	swap	r24
    b2bc:	92 95       	swap	r25
    b2be:	90 7f       	andi	r25, 0xF0	; 240
    b2c0:	98 27       	eor	r25, r24
    b2c2:	80 7f       	andi	r24, 0xF0	; 240
    b2c4:	98 27       	eor	r25, r24
    b2c6:	a8 0f       	add	r26, r24
    b2c8:	b9 1f       	adc	r27, r25
    b2ca:	13 96       	adiw	r26, 0x03	; 3
    b2cc:	fd 01       	movw	r30, r26
    b2ce:	e5 90       	lpm	r14, Z+
    b2d0:	f5 90       	lpm	r15, Z+
    b2d2:	05 91       	lpm	r16, Z+
    b2d4:	14 91       	lpm	r17, Z+
    b2d6:	fe 01       	movw	r30, r28
    b2d8:	72 96       	adiw	r30, 0x12	; 18
    b2da:	50 e0       	ldi	r21, 0x00	; 0
    b2dc:	30 e0       	ldi	r19, 0x00	; 0
    b2de:	24 1b       	sub	r18, r20
    b2e0:	31 09       	sbc	r19, r1
    b2e2:	22 30       	cpi	r18, 0x02	; 2
    b2e4:	31 05       	cpc	r19, r1
    b2e6:	0c f0       	brlt	.+2      	; 0xb2ea <MenuDown+0x72>
    b2e8:	51 e0       	ldi	r21, 0x01	; 1
    b2ea:	20 e0       	ldi	r18, 0x00	; 0
    b2ec:	80 91 96 08 	lds	r24, 0x0896
    b2f0:	83 30       	cpi	r24, 0x03	; 3
    b2f2:	08 f4       	brcc	.+2      	; 0xb2f6 <MenuDown+0x7e>
    b2f4:	21 e0       	ldi	r18, 0x01	; 1
    b2f6:	30 e0       	ldi	r19, 0x00	; 0
    b2f8:	80 91 ee 04 	lds	r24, 0x04EE
    b2fc:	90 91 ef 04 	lds	r25, 0x04EF
    b300:	a0 91 f0 04 	lds	r26, 0x04F0
    b304:	b0 91 f1 04 	lds	r27, 0x04F1
    b308:	e8 16       	cp	r14, r24
    b30a:	f9 06       	cpc	r15, r25
    b30c:	0a 07       	cpc	r16, r26
    b30e:	1b 07       	cpc	r17, r27
    b310:	08 f4       	brcc	.+2      	; 0xb314 <MenuDown+0x9c>
    b312:	31 e0       	ldi	r19, 0x01	; 1
    b314:	cf 01       	movw	r24, r30
    b316:	6f ef       	ldi	r22, 0xFF	; 255
    b318:	45 2f       	mov	r20, r21
    b31a:	03 2f       	mov	r16, r19
    b31c:	0e 94 2a 57 	call	0xae54	; 0xae54 <MenuUD>
}
    b320:	df 91       	pop	r29
    b322:	cf 91       	pop	r28
    b324:	1f 91       	pop	r17
    b326:	0f 91       	pop	r16
    b328:	ff 90       	pop	r15
    b32a:	ef 90       	pop	r14
    b32c:	08 95       	ret

0000b32e <MenuUp>:
}

// ~~~~~~~~~
void
MenuUp(void)
{
    b32e:	ef 92       	push	r14
    b330:	ff 92       	push	r15
    b332:	0f 93       	push	r16
    b334:	1f 93       	push	r17
	uint8_t Fix=GetFix();
    b336:	a0 91 d1 02 	lds	r26, 0x02D1
    b33a:	b0 91 d2 02 	lds	r27, 0x02D2

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    b33e:	13 96       	adiw	r26, 0x03	; 3
    b340:	fd 01       	movw	r30, r26
    b342:	34 91       	lpm	r19, Z+
    b344:	13 97       	sbiw	r26, 0x03	; 3
	MenuUD(&CurrPage->Up, 1, CurrLine>Fix, CurrLCD>Fix, F_Buf<prd(&GetField->Max));
    b346:	20 91 79 07 	lds	r18, 0x0779

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    b34a:	fd 01       	movw	r30, r26
    b34c:	45 91       	lpm	r20, Z+
    b34e:	54 91       	lpm	r21, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    b350:	8b e1       	ldi	r24, 0x1B	; 27
    b352:	28 9f       	mul	r18, r24
    b354:	c0 01       	movw	r24, r0
    b356:	11 24       	eor	r1, r1
    b358:	48 0f       	add	r20, r24
    b35a:	59 1f       	adc	r21, r25
    b35c:	49 5e       	subi	r20, 0xE9	; 233
    b35e:	5f 4f       	sbci	r21, 0xFF	; 255
    b360:	fa 01       	movw	r30, r20
    b362:	65 91       	lpm	r22, Z+
    b364:	74 91       	lpm	r23, Z+
    b366:	80 91 d3 02 	lds	r24, 0x02D3
    b36a:	90 e0       	ldi	r25, 0x00	; 0
    b36c:	82 95       	swap	r24
    b36e:	92 95       	swap	r25
    b370:	90 7f       	andi	r25, 0xF0	; 240
    b372:	98 27       	eor	r25, r24
    b374:	80 7f       	andi	r24, 0xF0	; 240
    b376:	98 27       	eor	r25, r24
    b378:	68 0f       	add	r22, r24
    b37a:	79 1f       	adc	r23, r25
    b37c:	69 5f       	subi	r22, 0xF9	; 249
    b37e:	7f 4f       	sbci	r23, 0xFF	; 255
    b380:	fb 01       	movw	r30, r22
    b382:	e5 90       	lpm	r14, Z+
    b384:	f5 90       	lpm	r15, Z+
    b386:	05 91       	lpm	r16, Z+
    b388:	14 91       	lpm	r17, Z+
    b38a:	fd 01       	movw	r30, r26
    b38c:	70 96       	adiw	r30, 0x10	; 16
    b38e:	40 e0       	ldi	r20, 0x00	; 0
    b390:	32 17       	cp	r19, r18
    b392:	08 f4       	brcc	.+2      	; 0xb396 <MenuUp+0x68>
    b394:	41 e0       	ldi	r20, 0x01	; 1
    b396:	20 e0       	ldi	r18, 0x00	; 0
    b398:	80 91 96 08 	lds	r24, 0x0896
    b39c:	38 17       	cp	r19, r24
    b39e:	08 f4       	brcc	.+2      	; 0xb3a2 <MenuUp+0x74>
    b3a0:	21 e0       	ldi	r18, 0x01	; 1
    b3a2:	30 e0       	ldi	r19, 0x00	; 0
    b3a4:	80 91 ee 04 	lds	r24, 0x04EE
    b3a8:	90 91 ef 04 	lds	r25, 0x04EF
    b3ac:	a0 91 f0 04 	lds	r26, 0x04F0
    b3b0:	b0 91 f1 04 	lds	r27, 0x04F1
    b3b4:	8e 15       	cp	r24, r14
    b3b6:	9f 05       	cpc	r25, r15
    b3b8:	a0 07       	cpc	r26, r16
    b3ba:	b1 07       	cpc	r27, r17
    b3bc:	08 f4       	brcc	.+2      	; 0xb3c0 <MenuUp+0x92>
    b3be:	31 e0       	ldi	r19, 0x01	; 1
    b3c0:	cf 01       	movw	r24, r30
    b3c2:	61 e0       	ldi	r22, 0x01	; 1
    b3c4:	03 2f       	mov	r16, r19
    b3c6:	0e 94 2a 57 	call	0xae54	; 0xae54 <MenuUD>
}
    b3ca:	1f 91       	pop	r17
    b3cc:	0f 91       	pop	r16
    b3ce:	ff 90       	pop	r15
    b3d0:	ef 90       	pop	r14
    b3d2:	08 95       	ret

0000b3d4 <PutField>:
	sprintf(Param->Pos, Format, Val);
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
PutField(uint8_t Type, void *Var, T_Param *Param)
{
    b3d4:	af 92       	push	r10
    b3d6:	bf 92       	push	r11
    b3d8:	cf 92       	push	r12
    b3da:	df 92       	push	r13
    b3dc:	ef 92       	push	r14
    b3de:	ff 92       	push	r15
    b3e0:	0f 93       	push	r16
    b3e2:	1f 93       	push	r17
    b3e4:	df 93       	push	r29
    b3e6:	cf 93       	push	r28
    b3e8:	cd b7       	in	r28, 0x3d	; 61
    b3ea:	de b7       	in	r29, 0x3e	; 62
    b3ec:	69 97       	sbiw	r28, 0x19	; 25
    b3ee:	0f b6       	in	r0, 0x3f	; 63
    b3f0:	f8 94       	cli
    b3f2:	de bf       	out	0x3e, r29	; 62
    b3f4:	0f be       	out	0x3f, r0	; 63
    b3f6:	cd bf       	out	0x3d, r28	; 61
    b3f8:	db 01       	movw	r26, r22
    b3fa:	7a 01       	movw	r14, r20
	float fTemp;

	switch(Type) {
    b3fc:	e8 2f       	mov	r30, r24
    b3fe:	f0 e0       	ldi	r31, 0x00	; 0
    b400:	e3 32       	cpi	r30, 0x23	; 35
    b402:	f1 05       	cpc	r31, r1
    b404:	88 f5       	brcc	.+98     	; 0xb468 <PutField+0x94>
    b406:	e7 52       	subi	r30, 0x27	; 39
    b408:	ff 4f       	sbci	r31, 0xFF	; 255
    b40a:	ee 0f       	add	r30, r30
    b40c:	ff 1f       	adc	r31, r31
    b40e:	05 90       	lpm	r0, Z+
    b410:	f4 91       	lpm	r31, Z+
    b412:	e0 2d       	mov	r30, r0
    b414:	19 94       	eijmp
		break;
	case Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((*((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
		break;
	case EE_Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((erb((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
    b416:	fa 01       	movw	r30, r20
    b418:	a0 80       	ld	r10, Z
    b41a:	b1 80       	ldd	r11, Z+1	; 0x01
    b41c:	c4 80       	ldd	r12, Z+4	; 0x04
    b41e:	d5 80       	ldd	r13, Z+5	; 0x05
    b420:	12 81       	ldd	r17, Z+2	; 0x02
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    b422:	81 2f       	mov	r24, r17
    b424:	86 95       	lsr	r24
    b426:	86 95       	lsr	r24
    b428:	86 95       	lsr	r24
    b42a:	9b 01       	movw	r18, r22
    b42c:	28 0f       	add	r18, r24
    b42e:	31 1d       	adc	r19, r1
    b430:	c9 01       	movw	r24, r18
    b432:	0e 94 03 7d 	call	0xfa06	; 0xfa06 <__eerd_byte_m2560>
    b436:	17 70       	andi	r17, 0x07	; 7
    b438:	21 e0       	ldi	r18, 0x01	; 1
    b43a:	30 e0       	ldi	r19, 0x00	; 0
    b43c:	02 c0       	rjmp	.+4      	; 0xb442 <PutField+0x6e>
    b43e:	22 0f       	add	r18, r18
    b440:	33 1f       	adc	r19, r19
    b442:	1a 95       	dec	r17
    b444:	e2 f7       	brpl	.-8      	; 0xb43e <PutField+0x6a>
    b446:	90 e0       	ldi	r25, 0x00	; 0
    b448:	28 23       	and	r18, r24
    b44a:	39 23       	and	r19, r25
    b44c:	12 16       	cp	r1, r18
    b44e:	13 06       	cpc	r1, r19
    b450:	0c f0       	brlt	.+2      	; 0xb454 <PutField+0x80>
    b452:	3f c1       	rjmp	.+638    	; 0xb6d2 <PutField+0x2fe>
    b454:	82 e0       	ldi	r24, 0x02	; 2
    b456:	90 e0       	ldi	r25, 0x00	; 0

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    b458:	f6 01       	movw	r30, r12
    b45a:	e8 0f       	add	r30, r24
    b45c:	f9 1f       	adc	r31, r25
    b45e:	65 91       	lpm	r22, Z+
    b460:	74 91       	lpm	r23, Z+
    b462:	c5 01       	movw	r24, r10
    b464:	0e 94 e2 79 	call	0xf3c4	; 0xf3c4 <strcpy_P>
			erbl(TempStr, Var, Param->Size);
			Put_TextValAlignRight(TempStr, Param);
		}
		break;
	}
}
    b468:	69 96       	adiw	r28, 0x19	; 25
    b46a:	0f b6       	in	r0, 0x3f	; 63
    b46c:	f8 94       	cli
    b46e:	de bf       	out	0x3e, r29	; 62
    b470:	0f be       	out	0x3f, r0	; 63
    b472:	cd bf       	out	0x3d, r28	; 61
    b474:	cf 91       	pop	r28
    b476:	df 91       	pop	r29
    b478:	1f 91       	pop	r17
    b47a:	0f 91       	pop	r16
    b47c:	ff 90       	pop	r15
    b47e:	ef 90       	pop	r14
    b480:	df 90       	pop	r13
    b482:	cf 90       	pop	r12
    b484:	bf 90       	pop	r11
    b486:	af 90       	pop	r10
    b488:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    b48a:	8e 01       	movw	r16, r28
    b48c:	0b 5f       	subi	r16, 0xFB	; 251
    b48e:	1f 4f       	sbci	r17, 0xFF	; 255
    b490:	fa 01       	movw	r30, r20
    b492:	43 81       	ldd	r20, Z+3	; 0x03
    b494:	c8 01       	movw	r24, r16
    b496:	50 e0       	ldi	r21, 0x00	; 0
    b498:	0e 94 f3 7c 	call	0xf9e6	; 0xf9e6 <__eerd_block_m2560>
		Put_TextValAlignRight(Var, Param);
		break;
	case EE_Text:{
			char TempStr[LCDXSz+1];
			erbl(TempStr, Var, Param->Size);
			Put_TextValAlignRight(TempStr, Param);
    b49c:	c8 01       	movw	r24, r16
    b49e:	b7 01       	movw	r22, r14
    b4a0:	0e 94 1d 42 	call	0x843a	; 0x843a <Put_TextValAlignRight>
    b4a4:	e1 cf       	rjmp	.-62     	; 0xb468 <PutField+0x94>
	case EE_Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((erb((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
		break;

	case Text:
		Put_TextValAlignRight(Var, Param);
    b4a6:	cb 01       	movw	r24, r22
    b4a8:	ba 01       	movw	r22, r20
    b4aa:	0e 94 1d 42 	call	0x843a	; 0x843a <Put_TextValAlignRight>
    b4ae:	dc cf       	rjmp	.-72     	; 0xb468 <PutField+0x94>
	case EE_Enum:
		Param->Txt += erb((uint8_t*)Var);
		PutEnum(Param);
		break;
	case Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((*((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
    b4b0:	fa 01       	movw	r30, r20
    b4b2:	00 81       	ld	r16, Z
    b4b4:	11 81       	ldd	r17, Z+1	; 0x01
    b4b6:	64 81       	ldd	r22, Z+4	; 0x04
    b4b8:	75 81       	ldd	r23, Z+5	; 0x05
    b4ba:	42 81       	ldd	r20, Z+2	; 0x02
    b4bc:	84 2f       	mov	r24, r20
    b4be:	86 95       	lsr	r24
    b4c0:	86 95       	lsr	r24
    b4c2:	86 95       	lsr	r24
    b4c4:	a8 0f       	add	r26, r24
    b4c6:	b1 1d       	adc	r27, r1
    b4c8:	2c 91       	ld	r18, X
    b4ca:	30 e0       	ldi	r19, 0x00	; 0
    b4cc:	47 70       	andi	r20, 0x07	; 7
    b4ce:	81 e0       	ldi	r24, 0x01	; 1
    b4d0:	90 e0       	ldi	r25, 0x00	; 0
    b4d2:	02 c0       	rjmp	.+4      	; 0xb4d8 <PutField+0x104>
    b4d4:	88 0f       	add	r24, r24
    b4d6:	99 1f       	adc	r25, r25
    b4d8:	4a 95       	dec	r20
    b4da:	e2 f7       	brpl	.-8      	; 0xb4d4 <PutField+0x100>
    b4dc:	28 23       	and	r18, r24
    b4de:	39 23       	and	r19, r25
    b4e0:	12 16       	cp	r1, r18
    b4e2:	13 06       	cpc	r1, r19
    b4e4:	0c f0       	brlt	.+2      	; 0xb4e8 <PutField+0x114>
    b4e6:	f8 c0       	rjmp	.+496    	; 0xb6d8 <PutField+0x304>
    b4e8:	82 e0       	ldi	r24, 0x02	; 2
    b4ea:	90 e0       	ldi	r25, 0x00	; 0

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    b4ec:	fb 01       	movw	r30, r22
    b4ee:	e8 0f       	add	r30, r24
    b4f0:	f9 1f       	adc	r31, r25
    b4f2:	65 91       	lpm	r22, Z+
    b4f4:	74 91       	lpm	r23, Z+
    b4f6:	c8 01       	movw	r24, r16
    b4f8:	0e 94 e2 79 	call	0xf3c4	; 0xf3c4 <strcpy_P>
    b4fc:	b5 cf       	rjmp	.-150    	; 0xb468 <PutField+0x94>
		Put_GFVal(fTemp, Param);
		break;


	case Enum:
		Param->Txt += *(uint8_t*)Var;
    b4fe:	2c 91       	ld	r18, X
    b500:	30 e0       	ldi	r19, 0x00	; 0
    b502:	22 0f       	add	r18, r18
    b504:	33 1f       	adc	r19, r19
    b506:	f7 01       	movw	r30, r14
    b508:	84 81       	ldd	r24, Z+4	; 0x04
    b50a:	95 81       	ldd	r25, Z+5	; 0x05
    b50c:	82 0f       	add	r24, r18
    b50e:	93 1f       	adc	r25, r19
    b510:	95 83       	std	Z+5, r25	; 0x05
    b512:	84 83       	std	Z+4, r24	; 0x04
		PutEnum(Param);
    b514:	c7 01       	movw	r24, r14
    b516:	0e 94 c9 3f 	call	0x7f92	; 0x7f92 <PutEnum>
    b51a:	a6 cf       	rjmp	.-180    	; 0xb468 <PutField+0x94>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    b51c:	cb 01       	movw	r24, r22
    b51e:	0e 94 03 7d 	call	0xfa06	; 0xfa06 <__eerd_byte_m2560>
		break;
	case EE_Enum:
		Param->Txt += erb((uint8_t*)Var);
    b522:	90 e0       	ldi	r25, 0x00	; 0
    b524:	88 0f       	add	r24, r24
    b526:	99 1f       	adc	r25, r25
    b528:	f7 01       	movw	r30, r14
    b52a:	24 81       	ldd	r18, Z+4	; 0x04
    b52c:	35 81       	ldd	r19, Z+5	; 0x05
    b52e:	28 0f       	add	r18, r24
    b530:	39 1f       	adc	r19, r25
    b532:	35 83       	std	Z+5, r19	; 0x05
    b534:	24 83       	std	Z+4, r18	; 0x04
		PutEnum(Param);
    b536:	c7 01       	movw	r24, r14
    b538:	0e 94 c9 3f 	call	0x7f92	; 0x7f92 <PutEnum>
    b53c:	95 cf       	rjmp	.-214    	; 0xb468 <PutField+0x94>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    b53e:	ce 01       	movw	r24, r28
    b540:	01 96       	adiw	r24, 0x01	; 1
    b542:	44 e0       	ldi	r20, 0x04	; 4
    b544:	50 e0       	ldi	r21, 0x00	; 0
    b546:	0e 94 f3 7c 	call	0xf9e6	; 0xf9e6 <__eerd_block_m2560>
	case GFloat:
		Put_GFVal(*(float*)Var, Param);
		break;			
	case EE_GFloat:
		erbl(&fTemp, Var, 4);
		Put_GFVal(fTemp, Param);
    b54a:	69 81       	ldd	r22, Y+1	; 0x01
    b54c:	7a 81       	ldd	r23, Y+2	; 0x02
    b54e:	8b 81       	ldd	r24, Y+3	; 0x03
    b550:	9c 81       	ldd	r25, Y+4	; 0x04
    b552:	a7 01       	movw	r20, r14
    b554:	0e 94 79 42 	call	0x84f2	; 0x84f2 <Put_GFVal>
    b558:	87 cf       	rjmp	.-242    	; 0xb468 <PutField+0x94>
	case EE_FFloat:
		erbl(&fTemp, Var, 4);
		Put_FFVal(fTemp, Param);
		break;
	case GFloat:
		Put_GFVal(*(float*)Var, Param);
    b55a:	6d 91       	ld	r22, X+
    b55c:	7d 91       	ld	r23, X+
    b55e:	8d 91       	ld	r24, X+
    b560:	9c 91       	ld	r25, X
    b562:	0e 94 79 42 	call	0x84f2	; 0x84f2 <Put_GFVal>
    b566:	80 cf       	rjmp	.-256    	; 0xb468 <PutField+0x94>
    b568:	ce 01       	movw	r24, r28
    b56a:	01 96       	adiw	r24, 0x01	; 1
    b56c:	44 e0       	ldi	r20, 0x04	; 4
    b56e:	50 e0       	ldi	r21, 0x00	; 0
    b570:	0e 94 f3 7c 	call	0xf9e6	; 0xf9e6 <__eerd_block_m2560>
	case FFloat:
		Put_FFVal(*(float*)Var, Param);
		break;			
	case EE_FFloat:
		erbl(&fTemp, Var, 4);
		Put_FFVal(fTemp, Param);
    b574:	69 81       	ldd	r22, Y+1	; 0x01
    b576:	7a 81       	ldd	r23, Y+2	; 0x02
    b578:	8b 81       	ldd	r24, Y+3	; 0x03
    b57a:	9c 81       	ldd	r25, Y+4	; 0x04
    b57c:	a7 01       	movw	r20, r14
    b57e:	0e 94 f3 42 	call	0x85e6	; 0x85e6 <Put_FFVal>
    b582:	72 cf       	rjmp	.-284    	; 0xb468 <PutField+0x94>
		Put_zDVal(erd((uint32_t*)Var), Param);
		break;

		
	case FFloat:
		Put_FFVal(*(float*)Var, Param);
    b584:	6d 91       	ld	r22, X+
    b586:	7d 91       	ld	r23, X+
    b588:	8d 91       	ld	r24, X+
    b58a:	9c 91       	ld	r25, X
    b58c:	0e 94 f3 42 	call	0x85e6	; 0x85e6 <Put_FFVal>
    b590:	6b cf       	rjmp	.-298    	; 0xb468 <PutField+0x94>
		break;
	case zh_Word:
		Put_zVal_h(*(uint16_t*)Var, 'w', Param);
		break;
	case zh_Longint:
		Put_zVal_h(*(uint32_t*)Var, 'l', Param);
    b592:	6d 91       	ld	r22, X+
    b594:	7d 91       	ld	r23, X+
    b596:	8d 91       	ld	r24, X+
    b598:	9c 91       	ld	r25, X
    b59a:	4c e6       	ldi	r20, 0x6C	; 108
    b59c:	97 01       	movw	r18, r14
    b59e:	0e 94 b3 46 	call	0x8d66	; 0x8d66 <Put_zVal_h>
    b5a2:	62 cf       	rjmp	.-316    	; 0xb468 <PutField+0x94>
// ~~~~~~~~~~~~~~~~~~~~~~
uint32_t
erd(const uint32_t *addr)
{
	//IntOff();
	uint32_t word = eeprom_read_dword(addr);
    b5a4:	cb 01       	movw	r24, r22
    b5a6:	0e 94 0b 7d 	call	0xfa16	; 0xfa16 <__eerd_dword_m2560>
		break;
	case z_Longint: case zc_Longint:
		Put_zDVal(*(uint32_t*)Var, Param);
		break;
	case z_EE_Longint:
		Put_zDVal(erd((uint32_t*)Var), Param);
    b5aa:	a7 01       	movw	r20, r14
    b5ac:	0e 94 48 43 	call	0x8690	; 0x8690 <Put_zDVal>
    b5b0:	5b cf       	rjmp	.-330    	; 0xb468 <PutField+0x94>
		break;
	case s_EE_Longint:
		Put_sDVal((int32_t)erd((uint32_t*)Var), Param);
		break;
	case z_Longint: case zc_Longint:
		Put_zDVal(*(uint32_t*)Var, Param);
    b5b2:	6d 91       	ld	r22, X+
    b5b4:	7d 91       	ld	r23, X+
    b5b6:	8d 91       	ld	r24, X+
    b5b8:	9c 91       	ld	r25, X
    b5ba:	0e 94 48 43 	call	0x8690	; 0x8690 <Put_zDVal>
    b5be:	54 cf       	rjmp	.-344    	; 0xb468 <PutField+0x94>
    b5c0:	cb 01       	movw	r24, r22
    b5c2:	0e 94 0b 7d 	call	0xfa16	; 0xfa16 <__eerd_dword_m2560>
		break;
	case s_Longint:
		Put_sDVal(*(int32_t*)Var, Param);
		break;
	case s_EE_Longint:
		Put_sDVal((int32_t)erd((uint32_t*)Var), Param);
    b5c6:	a7 01       	movw	r20, r14
    b5c8:	0e 94 69 44 	call	0x88d2	; 0x88d2 <Put_sDVal>
    b5cc:	4d cf       	rjmp	.-358    	; 0xb468 <PutField+0x94>
		break;
	case EE_Longint:
		PutDVal(erd((uint32_t*)Var), Param);
		break;
	case s_Longint:
		Put_sDVal(*(int32_t*)Var, Param);
    b5ce:	6d 91       	ld	r22, X+
    b5d0:	7d 91       	ld	r23, X+
    b5d2:	8d 91       	ld	r24, X+
    b5d4:	9c 91       	ld	r25, X
    b5d6:	0e 94 69 44 	call	0x88d2	; 0x88d2 <Put_sDVal>
    b5da:	46 cf       	rjmp	.-372    	; 0xb468 <PutField+0x94>
    b5dc:	cb 01       	movw	r24, r22
    b5de:	0e 94 0b 7d 	call	0xfa16	; 0xfa16 <__eerd_dword_m2560>

	case Longint: case c_Longint:
		PutDVal(*(uint32_t*)Var, Param);
		break;
	case EE_Longint:
		PutDVal(erd((uint32_t*)Var), Param);
    b5e2:	a7 01       	movw	r20, r14
    b5e4:	0e 94 92 45 	call	0x8b24	; 0x8b24 <PutDVal>
    b5e8:	3f cf       	rjmp	.-386    	; 0xb468 <PutField+0x94>
		Put_zVal(erw((uint16_t*)Var), 'w', Param);
		break;


	case Longint: case c_Longint:
		PutDVal(*(uint32_t*)Var, Param);
    b5ea:	6d 91       	ld	r22, X+
    b5ec:	7d 91       	ld	r23, X+
    b5ee:	8d 91       	ld	r24, X+
    b5f0:	9c 91       	ld	r25, X
    b5f2:	0e 94 92 45 	call	0x8b24	; 0x8b24 <PutDVal>
    b5f6:	38 cf       	rjmp	.-400    	; 0xb468 <PutField+0x94>

	case zh_Byte:
		Put_zVal_h(*(uint8_t*)Var, 'b', Param);
		break;
	case zh_Word:
		Put_zVal_h(*(uint16_t*)Var, 'w', Param);
    b5f8:	6d 91       	ld	r22, X+
    b5fa:	7c 91       	ld	r23, X
    b5fc:	80 e0       	ldi	r24, 0x00	; 0
    b5fe:	90 e0       	ldi	r25, 0x00	; 0
    b600:	47 e7       	ldi	r20, 0x77	; 119
    b602:	97 01       	movw	r18, r14
    b604:	0e 94 b3 46 	call	0x8d66	; 0x8d66 <Put_zVal_h>
    b608:	2f cf       	rjmp	.-418    	; 0xb468 <PutField+0x94>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    b60a:	cb 01       	movw	r24, r22
    b60c:	0e 94 11 7d 	call	0xfa22	; 0xfa22 <__eerd_word_m2560>
		break;
	case z_Word: case zc_Word:
		Put_zVal(*(uint16_t*)Var, 'w', Param);
		break;
	case z_EE_Word:
		Put_zVal(erw((uint16_t*)Var), 'w', Param);
    b610:	67 e7       	ldi	r22, 0x77	; 119
    b612:	a7 01       	movw	r20, r14
    b614:	0e 94 26 47 	call	0x8e4c	; 0x8e4c <Put_zVal>
    b618:	27 cf       	rjmp	.-434    	; 0xb468 <PutField+0x94>
		break;
	case s_EE_Word:
		Put_sVal((int16_t)erw((uint16_t*)Var), 'w', Param);
		break;
	case z_Word: case zc_Word:
		Put_zVal(*(uint16_t*)Var, 'w', Param);
    b61a:	8d 91       	ld	r24, X+
    b61c:	9c 91       	ld	r25, X
    b61e:	67 e7       	ldi	r22, 0x77	; 119
    b620:	0e 94 26 47 	call	0x8e4c	; 0x8e4c <Put_zVal>
    b624:	21 cf       	rjmp	.-446    	; 0xb468 <PutField+0x94>
    b626:	cb 01       	movw	r24, r22
    b628:	0e 94 11 7d 	call	0xfa22	; 0xfa22 <__eerd_word_m2560>
		break;
	case s_Word:
		Put_sVal(*(int16_t*)Var, 'w', Param);
		break;
	case s_EE_Word:
		Put_sVal((int16_t)erw((uint16_t*)Var), 'w', Param);
    b62c:	67 e7       	ldi	r22, 0x77	; 119
    b62e:	a7 01       	movw	r20, r14
    b630:	0e 94 e3 47 	call	0x8fc6	; 0x8fc6 <Put_sVal>
    b634:	19 cf       	rjmp	.-462    	; 0xb468 <PutField+0x94>
		break;
	case EE_Word:
		PutVal(erw((uint16_t*)Var), 'w', Param);
		break;
	case s_Word:
		Put_sVal(*(int16_t*)Var, 'w', Param);
    b636:	8d 91       	ld	r24, X+
    b638:	9c 91       	ld	r25, X
    b63a:	67 e7       	ldi	r22, 0x77	; 119
    b63c:	0e 94 e3 47 	call	0x8fc6	; 0x8fc6 <Put_sVal>
    b640:	13 cf       	rjmp	.-474    	; 0xb468 <PutField+0x94>
    b642:	cb 01       	movw	r24, r22
    b644:	0e 94 11 7d 	call	0xfa22	; 0xfa22 <__eerd_word_m2560>

	case Word: case c_Word:
		PutVal(*(uint16_t*)Var, 'w', Param);
		break;
	case EE_Word:
		PutVal(erw((uint16_t*)Var), 'w', Param);
    b648:	67 e7       	ldi	r22, 0x77	; 119
    b64a:	a7 01       	movw	r20, r14
    b64c:	0e 94 c7 48 	call	0x918e	; 0x918e <PutVal>
    b650:	0b cf       	rjmp	.-490    	; 0xb468 <PutField+0x94>
	case zh_Longint:
		Put_zVal_h(*(uint32_t*)Var, 'l', Param);
		break;

	case Word: case c_Word:
		PutVal(*(uint16_t*)Var, 'w', Param);
    b652:	8d 91       	ld	r24, X+
    b654:	9c 91       	ld	r25, X
    b656:	67 e7       	ldi	r22, 0x77	; 119
    b658:	0e 94 c7 48 	call	0x918e	; 0x918e <PutVal>
    b65c:	05 cf       	rjmp	.-502    	; 0xb468 <PutField+0x94>
	case z_EE_Byte:
		Put_zVal(erb((uint8_t*)Var), 'b', Param);
		break;

	case zh_Byte:
		Put_zVal_h(*(uint8_t*)Var, 'b', Param);
    b65e:	6c 91       	ld	r22, X
    b660:	70 e0       	ldi	r23, 0x00	; 0
    b662:	80 e0       	ldi	r24, 0x00	; 0
    b664:	90 e0       	ldi	r25, 0x00	; 0
    b666:	42 e6       	ldi	r20, 0x62	; 98
    b668:	97 01       	movw	r18, r14
    b66a:	0e 94 b3 46 	call	0x8d66	; 0x8d66 <Put_zVal_h>
    b66e:	fc ce       	rjmp	.-520    	; 0xb468 <PutField+0x94>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    b670:	cb 01       	movw	r24, r22
    b672:	0e 94 03 7d 	call	0xfa06	; 0xfa06 <__eerd_byte_m2560>
		break;
	case z_Byte:
		Put_zVal(*(uint8_t*)Var, 'b', Param);
		break;
	case z_EE_Byte:
		Put_zVal(erb((uint8_t*)Var), 'b', Param);
    b676:	90 e0       	ldi	r25, 0x00	; 0
    b678:	62 e6       	ldi	r22, 0x62	; 98
    b67a:	a7 01       	movw	r20, r14
    b67c:	0e 94 26 47 	call	0x8e4c	; 0x8e4c <Put_zVal>
    b680:	f3 ce       	rjmp	.-538    	; 0xb468 <PutField+0x94>
		break;
	case s_EE_Byte:
		Put_sVal((int8_t)erb((uint8_t*)Var), 'b', Param);
		break;
	case z_Byte:
		Put_zVal(*(uint8_t*)Var, 'b', Param);
    b682:	8c 91       	ld	r24, X
    b684:	90 e0       	ldi	r25, 0x00	; 0
    b686:	62 e6       	ldi	r22, 0x62	; 98
    b688:	0e 94 26 47 	call	0x8e4c	; 0x8e4c <Put_zVal>
    b68c:	ed ce       	rjmp	.-550    	; 0xb468 <PutField+0x94>
    b68e:	cb 01       	movw	r24, r22
    b690:	0e 94 03 7d 	call	0xfa06	; 0xfa06 <__eerd_byte_m2560>
		break;
	case s_Byte:
		Put_sVal(*(int8_t*)Var, 'b', Param);
		break;
	case s_EE_Byte:
		Put_sVal((int8_t)erb((uint8_t*)Var), 'b', Param);
    b694:	99 27       	eor	r25, r25
    b696:	87 fd       	sbrc	r24, 7
    b698:	90 95       	com	r25
    b69a:	62 e6       	ldi	r22, 0x62	; 98
    b69c:	a7 01       	movw	r20, r14
    b69e:	0e 94 e3 47 	call	0x8fc6	; 0x8fc6 <Put_sVal>
    b6a2:	e2 ce       	rjmp	.-572    	; 0xb468 <PutField+0x94>
		break;
	case EE_Byte:
		PutVal(erb((uint8_t*)Var), 'b', Param);
		break;
	case s_Byte:
		Put_sVal(*(int8_t*)Var, 'b', Param);
    b6a4:	8c 91       	ld	r24, X
    b6a6:	99 27       	eor	r25, r25
    b6a8:	87 fd       	sbrc	r24, 7
    b6aa:	90 95       	com	r25
    b6ac:	62 e6       	ldi	r22, 0x62	; 98
    b6ae:	0e 94 e3 47 	call	0x8fc6	; 0x8fc6 <Put_sVal>
    b6b2:	da ce       	rjmp	.-588    	; 0xb468 <PutField+0x94>
    b6b4:	cb 01       	movw	r24, r22
    b6b6:	0e 94 03 7d 	call	0xfa06	; 0xfa06 <__eerd_byte_m2560>
	switch(Type) {
	case Byte:
		PutVal(*(uint8_t*)Var, 'b', Param);
		break;
	case EE_Byte:
		PutVal(erb((uint8_t*)Var), 'b', Param);
    b6ba:	90 e0       	ldi	r25, 0x00	; 0
    b6bc:	62 e6       	ldi	r22, 0x62	; 98
    b6be:	a7 01       	movw	r20, r14
    b6c0:	0e 94 c7 48 	call	0x918e	; 0x918e <PutVal>
    b6c4:	d1 ce       	rjmp	.-606    	; 0xb468 <PutField+0x94>
{
	float fTemp;

	switch(Type) {
	case Byte:
		PutVal(*(uint8_t*)Var, 'b', Param);
    b6c6:	8c 91       	ld	r24, X
    b6c8:	90 e0       	ldi	r25, 0x00	; 0
    b6ca:	62 e6       	ldi	r22, 0x62	; 98
    b6cc:	0e 94 c7 48 	call	0x918e	; 0x918e <PutVal>
    b6d0:	cb ce       	rjmp	.-618    	; 0xb468 <PutField+0x94>
		break;
	case Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((*((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
		break;
	case EE_Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((erb((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
    b6d2:	80 e0       	ldi	r24, 0x00	; 0
    b6d4:	90 e0       	ldi	r25, 0x00	; 0
    b6d6:	c0 ce       	rjmp	.-640    	; 0xb458 <PutField+0x84>
	case EE_Enum:
		Param->Txt += erb((uint8_t*)Var);
		PutEnum(Param);
		break;
	case Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((*((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
    b6d8:	80 e0       	ldi	r24, 0x00	; 0
    b6da:	90 e0       	ldi	r25, 0x00	; 0
    b6dc:	07 cf       	rjmp	.-498    	; 0xb4ec <PutField+0x118>

0000b6de <PutLine>:
	PosBlink(Param,'_');
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
PutLine(uint8_t LineN, uint8_t Y)
{
    b6de:	2f 92       	push	r2
    b6e0:	3f 92       	push	r3
    b6e2:	4f 92       	push	r4
    b6e4:	5f 92       	push	r5
    b6e6:	6f 92       	push	r6
    b6e8:	7f 92       	push	r7
    b6ea:	8f 92       	push	r8
    b6ec:	9f 92       	push	r9
    b6ee:	af 92       	push	r10
    b6f0:	bf 92       	push	r11
    b6f2:	cf 92       	push	r12
    b6f4:	df 92       	push	r13
    b6f6:	ef 92       	push	r14
    b6f8:	ff 92       	push	r15
    b6fa:	0f 93       	push	r16
    b6fc:	1f 93       	push	r17
    b6fe:	df 93       	push	r29
    b700:	cf 93       	push	r28
    b702:	cd b7       	in	r28, 0x3d	; 61
    b704:	de b7       	in	r29, 0x3e	; 62
    b706:	60 97       	sbiw	r28, 0x10	; 16
    b708:	0f b6       	in	r0, 0x3f	; 63
    b70a:	f8 94       	cli
    b70c:	de bf       	out	0x3e, r29	; 62
    b70e:	0f be       	out	0x3f, r0	; 63
    b710:	cd bf       	out	0x3d, r28	; 61
    b712:	8f 87       	std	Y+15, r24	; 0x0f
    b714:	68 8b       	std	Y+16, r22	; 0x10

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    b716:	e0 91 d1 02 	lds	r30, 0x02D1
    b71a:	f0 91 d2 02 	lds	r31, 0x02D2
    b71e:	e5 90       	lpm	r14, Z+
    b720:	f4 90       	lpm	r15, Z+
	MenuLine *Line=GetLine+LineN;
    b722:	8b e1       	ldi	r24, 0x1B	; 27
    b724:	2f 85       	ldd	r18, Y+15	; 0x0f
    b726:	28 9f       	mul	r18, r24
    b728:	c0 01       	movw	r24, r0
    b72a:	11 24       	eor	r1, r1
    b72c:	e8 0e       	add	r14, r24
    b72e:	f9 1e       	adc	r15, r25
	PGM_P CurrStr=(PGM_P)(Line->Str);
    b730:	be 2c       	mov	r11, r14
    b732:	af 2c       	mov	r10, r15
    b734:	f7 01       	movw	r30, r14
    b736:	75 96       	adiw	r30, 0x15	; 21
    b738:	c5 90       	lpm	r12, Z+
    b73a:	d4 90       	lpm	r13, Z+

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    b73c:	f7 01       	movw	r30, r14
    b73e:	77 96       	adiw	r30, 0x17	; 23
    b740:	85 91       	lpm	r24, Z+
    b742:	94 91       	lpm	r25, Z+
    b744:	9e 87       	std	Y+14, r25	; 0x0e
    b746:	8d 87       	std	Y+13, r24	; 0x0d
    b748:	87 01       	movw	r16, r14
    b74a:	f7 01       	movw	r30, r14
    b74c:	84 91       	lpm	r24, Z+
	uint8_t X;
	uint8_t X0=0;
	uint8_t X1=LCDXSz;
	int8_t Xs = 0;
	//--- ">>" Align right
	if(prc(CurrStr+0) == '>' && prc(CurrStr+1) == '>'){
    b74e:	8e 33       	cpi	r24, 0x3E	; 62
    b750:	09 f4       	brne	.+2      	; 0xb754 <PutLine+0x76>
    b752:	a6 c1       	rjmp	.+844    	; 0xbaa0 <PutLine+0x3c2>
		X0 = LCDXSz - strlen_P(CurrStr) + 2;
		Xs = X0-2;
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';
    b754:	50 e0       	ldi	r21, 0x00	; 0
    b756:	40 e0       	ldi	r20, 0x00	; 0
    b758:	f8 01       	movw	r30, r16
    b75a:	84 91       	lpm	r24, Z+
	}
	//--- "<<" Align left
	if(prc(CurrStr+0) == '<' && prc(CurrStr+1) == '<'){
    b75c:	8c 33       	cpi	r24, 0x3C	; 60
    b75e:	09 f4       	brne	.+2      	; 0xb762 <PutLine+0x84>
    b760:	8a c1       	rjmp	.+788    	; 0xba76 <PutLine+0x398>
		X1 = strlen_P(CurrStr) - 2;
    b762:	84 e1       	ldi	r24, 0x14	; 20
    b764:	98 2e       	mov	r9, r24
    b766:	f8 01       	movw	r30, r16
    b768:	84 91       	lpm	r24, Z+
		X0 = 0;
		Xs = X0-2;
	}
	//--- "<>" Align center
	if(prc(CurrStr+0) == '<' && prc(CurrStr+1) == '>'){
    b76a:	8c 33       	cpi	r24, 0x3C	; 60
    b76c:	09 f4       	brne	.+2      	; 0xb770 <PutLine+0x92>
    b76e:	56 c1       	rjmp	.+684    	; 0xba1c <PutLine+0x33e>
		Xs = X0-2;
		X1 = X0 + (strlen_P(CurrStr) - 2);
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';		
	}
	//---
	for(X=X0; X<X1; X++){
    b770:	49 15       	cp	r20, r9
    b772:	08 f0       	brcs	.+2      	; 0xb776 <PutLine+0x98>
    b774:	ac c0       	rjmp	.+344    	; 0xb8ce <PutLine+0x1f0>
static void
PutLine(uint8_t LineN, uint8_t Y)
{
	MenuLine *Line=GetLine+LineN;
	PGM_P CurrStr=(PGM_P)(Line->Str);
	InField *IF = prp(&Line->IF_List);
    b776:	88 89       	ldd	r24, Y+16	; 0x10
    b778:	28 2f       	mov	r18, r24
    b77a:	30 e0       	ldi	r19, 0x00	; 0
    b77c:	c9 01       	movw	r24, r18
    b77e:	88 0f       	add	r24, r24
    b780:	99 1f       	adc	r25, r25
    b782:	82 0f       	add	r24, r18
    b784:	93 1f       	adc	r25, r19
    b786:	5c 01       	movw	r10, r24
    b788:	aa 0c       	add	r10, r10
    b78a:	bb 1c       	adc	r11, r11
    b78c:	aa 0c       	add	r10, r10
    b78e:	bb 1c       	adc	r11, r11
    b790:	aa 0c       	add	r10, r10
    b792:	bb 1c       	adc	r11, r11
    b794:	a8 1a       	sub	r10, r24
    b796:	b9 0a       	sbc	r11, r25
    b798:	25 2e       	mov	r2, r21
    b79a:	33 24       	eor	r3, r3
    b79c:	27 fc       	sbrc	r2, 7
    b79e:	30 94       	com	r3
    b7a0:	04 2f       	mov	r16, r20
    b7a2:	88 24       	eor	r8, r8
		switch(Char=prc(CurrStr+X-Xs)) {
		case '{':
			while((Char=prc(CurrStr + X - Xs + ++Param.Size))=='{');
			Param.Prec = prb(&IF->Prec);
			Param.Txt = prp(&IF->EnumList);
			PutField(prb(&IF->Type), prp(&IF->Var), &Param);
    b7a4:	3e 01       	movw	r6, r28
    b7a6:	08 94       	sec
    b7a8:	61 1c       	adc	r6, r1
    b7aa:	71 1c       	adc	r7, r1
			else
				PutField(prb(&(OF+OF_N)->Type), prp(&(OF+OF_N)->Var), &Param);
			OF_N++;
			break;
		}
		LCD_Buf[Y][X+=Param.Size] = Char;
    b7ac:	25 01       	movw	r4, r10
    b7ae:	11 c0       	rjmp	.+34     	; 0xb7d2 <PutLine+0xf4>
	for(X=X0; X<X1; X++){
		char Char;
		T_Param Param;
		Param.Pos = LCD_Buf[Y]+X;
		Param.Size = 0;
		switch(Char=prc(CurrStr+X-Xs)) {
    b7b0:	1d 37       	cpi	r17, 0x7D	; 125
    b7b2:	09 f4       	brne	.+2      	; 0xb7b6 <PutLine+0xd8>
    b7b4:	4c c0       	rjmp	.+152    	; 0xb84e <PutLine+0x170>
    b7b6:	30 e0       	ldi	r19, 0x00	; 0
			else
				PutField(prb(&(OF+OF_N)->Type), prp(&(OF+OF_N)->Var), &Param);
			OF_N++;
			break;
		}
		LCD_Buf[Y][X+=Param.Size] = Char;
    b7b8:	80 2f       	mov	r24, r16
    b7ba:	83 0f       	add	r24, r19
    b7bc:	f2 01       	movw	r30, r4
    b7be:	e8 0f       	add	r30, r24
    b7c0:	f1 1d       	adc	r31, r1
    b7c2:	e1 5b       	subi	r30, 0xB1	; 177
    b7c4:	f9 4f       	sbci	r31, 0xF9	; 249
    b7c6:	10 83       	st	Z, r17
		Xs = X0-2;
		X1 = X0 + (strlen_P(CurrStr) - 2);
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';		
	}
	//---
	for(X=X0; X<X1; X++){
    b7c8:	08 2f       	mov	r16, r24
    b7ca:	0f 5f       	subi	r16, 0xFF	; 255
    b7cc:	09 15       	cp	r16, r9
    b7ce:	08 f0       	brcs	.+2      	; 0xb7d2 <PutLine+0xf4>
    b7d0:	7e c0       	rjmp	.+252    	; 0xb8ce <PutLine+0x1f0>
		char Char;
		T_Param Param;
		Param.Pos = LCD_Buf[Y]+X;
    b7d2:	80 2f       	mov	r24, r16
    b7d4:	90 e0       	ldi	r25, 0x00	; 0
    b7d6:	9c 01       	movw	r18, r24
    b7d8:	2a 0d       	add	r18, r10
    b7da:	3b 1d       	adc	r19, r11
    b7dc:	21 5b       	subi	r18, 0xB1	; 177
    b7de:	39 4f       	sbci	r19, 0xF9	; 249
    b7e0:	3a 83       	std	Y+2, r19	; 0x02
    b7e2:	29 83       	std	Y+1, r18	; 0x01
		Param.Size = 0;
		switch(Char=prc(CurrStr+X-Xs)) {
    b7e4:	82 19       	sub	r24, r2
    b7e6:	93 09       	sbc	r25, r3
    b7e8:	f7 01       	movw	r30, r14
    b7ea:	e8 0f       	add	r30, r24
    b7ec:	f9 1f       	adc	r31, r25
    b7ee:	14 91       	lpm	r17, Z+
    b7f0:	1b 37       	cpi	r17, 0x7B	; 123
    b7f2:	f1 f6       	brne	.-68     	; 0xb7b0 <PutLine+0xd2>
    b7f4:	21 e0       	ldi	r18, 0x01	; 1
    b7f6:	01 c0       	rjmp	.+2      	; 0xb7fa <PutLine+0x11c>
		case '{':
			while((Char=prc(CurrStr + X - Xs + ++Param.Size))=='{');
    b7f8:	23 2f       	mov	r18, r19
    b7fa:	fc 01       	movw	r30, r24
    b7fc:	e2 0f       	add	r30, r18
    b7fe:	f1 1d       	adc	r31, r1
    b800:	ee 0d       	add	r30, r14
    b802:	ff 1d       	adc	r31, r15
    b804:	14 91       	lpm	r17, Z+
    b806:	32 2f       	mov	r19, r18
    b808:	3f 5f       	subi	r19, 0xFF	; 255
    b80a:	1b 37       	cpi	r17, 0x7B	; 123
    b80c:	a9 f3       	breq	.-22     	; 0xb7f8 <PutLine+0x11a>
    b80e:	2c 83       	std	Y+4, r18	; 0x04

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    b810:	a5 e0       	ldi	r26, 0x05	; 5
    b812:	b0 e0       	ldi	r27, 0x00	; 0
    b814:	ca 0e       	add	r12, r26
    b816:	db 1e       	adc	r13, r27
    b818:	f6 01       	movw	r30, r12
    b81a:	84 91       	lpm	r24, Z+
    b81c:	2b ef       	ldi	r18, 0xFB	; 251
    b81e:	3f ef       	ldi	r19, 0xFF	; 255
    b820:	c2 0e       	add	r12, r18
    b822:	d3 1e       	adc	r13, r19
			Param.Prec = prb(&IF->Prec);
    b824:	8b 83       	std	Y+3, r24	; 0x03

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    b826:	f6 01       	movw	r30, r12
    b828:	33 96       	adiw	r30, 0x03	; 3
    b82a:	85 91       	lpm	r24, Z+
    b82c:	94 91       	lpm	r25, Z+
			Param.Txt = prp(&IF->EnumList);
    b82e:	9e 83       	std	Y+6, r25	; 0x06
    b830:	8d 83       	std	Y+5, r24	; 0x05

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    b832:	f6 01       	movw	r30, r12
    b834:	84 91       	lpm	r24, Z+

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    b836:	31 96       	adiw	r30, 0x01	; 1
    b838:	65 91       	lpm	r22, Z+
    b83a:	74 91       	lpm	r23, Z+
			PutField(prb(&IF->Type), prp(&IF->Var), &Param);
    b83c:	a3 01       	movw	r20, r6
    b83e:	0e 94 ea 59 	call	0xb3d4	; 0xb3d4 <PutField>
			IF++;
    b842:	26 e0       	ldi	r18, 0x06	; 6
    b844:	30 e0       	ldi	r19, 0x00	; 0
    b846:	c2 0e       	add	r12, r18
    b848:	d3 1e       	adc	r13, r19
    b84a:	3c 81       	ldd	r19, Y+4	; 0x04
    b84c:	b5 cf       	rjmp	.-150    	; 0xb7b8 <PutLine+0xda>
			break;
    b84e:	21 e0       	ldi	r18, 0x01	; 1
    b850:	01 c0       	rjmp	.+2      	; 0xb854 <PutLine+0x176>
		case '}':
			while((Char=prc(CurrStr+X - Xs + ++Param.Size))=='}');
    b852:	23 2f       	mov	r18, r19

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    b854:	fc 01       	movw	r30, r24
    b856:	e2 0f       	add	r30, r18
    b858:	f1 1d       	adc	r31, r1
    b85a:	ee 0d       	add	r30, r14
    b85c:	ff 1d       	adc	r31, r15
    b85e:	14 91       	lpm	r17, Z+
    b860:	32 2f       	mov	r19, r18
    b862:	3f 5f       	subi	r19, 0xFF	; 255
    b864:	1d 37       	cpi	r17, 0x7D	; 125
    b866:	a9 f3       	breq	.-22     	; 0xb852 <PutLine+0x174>
    b868:	2c 83       	std	Y+4, r18	; 0x04
			Y1=Y;
    b86a:	38 89       	ldd	r19, Y+16	; 0x10
    b86c:	30 93 f3 09 	sts	0x09F3, r19
			Param.Prec = prb(&(OF+OF_N)->Prec);
    b870:	48 2d       	mov	r20, r8
    b872:	50 e0       	ldi	r21, 0x00	; 0
    b874:	42 95       	swap	r20
    b876:	52 95       	swap	r21
    b878:	50 7f       	andi	r21, 0xF0	; 240
    b87a:	54 27       	eor	r21, r20
    b87c:	40 7f       	andi	r20, 0xF0	; 240
    b87e:	54 27       	eor	r21, r20
    b880:	8d 85       	ldd	r24, Y+13	; 0x0d
    b882:	9e 85       	ldd	r25, Y+14	; 0x0e
    b884:	48 0f       	add	r20, r24
    b886:	59 1f       	adc	r21, r25

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    b888:	41 5f       	subi	r20, 0xF1	; 241
    b88a:	5f 4f       	sbci	r21, 0xFF	; 255
    b88c:	fa 01       	movw	r30, r20
    b88e:	84 91       	lpm	r24, Z+
    b890:	4f 50       	subi	r20, 0x0F	; 15
    b892:	50 40       	sbci	r21, 0x00	; 0
    b894:	8b 83       	std	Y+3, r24	; 0x03

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    b896:	ca 01       	movw	r24, r20
    b898:	0d 96       	adiw	r24, 0x0d	; 13
    b89a:	fc 01       	movw	r30, r24
    b89c:	25 91       	lpm	r18, Z+
    b89e:	34 91       	lpm	r19, Z+
			Param.Txt = prp(&(OF+OF_N)->EnumList);
    b8a0:	3e 83       	std	Y+6, r19	; 0x06
    b8a2:	2d 83       	std	Y+5, r18	; 0x05
			if(LineN==CurrLine && OF_N==CurrField)
    b8a4:	80 91 79 07 	lds	r24, 0x0779
    b8a8:	ff 85       	ldd	r31, Y+15	; 0x0f
    b8aa:	f8 17       	cp	r31, r24
    b8ac:	29 f4       	brne	.+10     	; 0xb8b8 <PutLine+0x1da>
    b8ae:	80 91 d3 02 	lds	r24, 0x02D3
    b8b2:	88 16       	cp	r8, r24
    b8b4:	09 f4       	brne	.+2      	; 0xb8b8 <PutLine+0x1da>
    b8b6:	43 c0       	rjmp	.+134    	; 0xb93e <PutLine+0x260>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    b8b8:	fa 01       	movw	r30, r20
    b8ba:	84 91       	lpm	r24, Z+

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    b8bc:	31 96       	adiw	r30, 0x01	; 1
    b8be:	65 91       	lpm	r22, Z+
    b8c0:	74 91       	lpm	r23, Z+
				}
				else{ 
					PutBuf(prb(&(OF+OF_N)->Type), &Param);
				}			
			else
				PutField(prb(&(OF+OF_N)->Type), prp(&(OF+OF_N)->Var), &Param);
    b8c2:	a3 01       	movw	r20, r6
    b8c4:	0e 94 ea 59 	call	0xb3d4	; 0xb3d4 <PutField>
    b8c8:	3c 81       	ldd	r19, Y+4	; 0x04
			OF_N++;
    b8ca:	83 94       	inc	r8
    b8cc:	75 cf       	rjmp	.-278    	; 0xb7b8 <PutLine+0xda>
		}
		LCD_Buf[Y][X+=Param.Size] = Char;

	}
	X=X1;
	for(;X<LCDXSz; X++) LCD_Buf[Y][X] = ' ';
    b8ce:	f3 e1       	ldi	r31, 0x13	; 19
    b8d0:	f9 15       	cp	r31, r9
    b8d2:	e0 f0       	brcs	.+56     	; 0xb90c <PutLine+0x22e>
    b8d4:	88 89       	ldd	r24, Y+16	; 0x10
    b8d6:	28 2f       	mov	r18, r24
    b8d8:	30 e0       	ldi	r19, 0x00	; 0
    b8da:	49 2d       	mov	r20, r9
    b8dc:	c9 01       	movw	r24, r18
    b8de:	88 0f       	add	r24, r24
    b8e0:	99 1f       	adc	r25, r25
    b8e2:	82 0f       	add	r24, r18
    b8e4:	93 1f       	adc	r25, r19
    b8e6:	9c 01       	movw	r18, r24
    b8e8:	22 0f       	add	r18, r18
    b8ea:	33 1f       	adc	r19, r19
    b8ec:	22 0f       	add	r18, r18
    b8ee:	33 1f       	adc	r19, r19
    b8f0:	22 0f       	add	r18, r18
    b8f2:	33 1f       	adc	r19, r19
    b8f4:	28 1b       	sub	r18, r24
    b8f6:	39 0b       	sbc	r19, r25
    b8f8:	80 e2       	ldi	r24, 0x20	; 32
    b8fa:	f9 01       	movw	r30, r18
    b8fc:	e4 0f       	add	r30, r20
    b8fe:	f1 1d       	adc	r31, r1
    b900:	e1 5b       	subi	r30, 0xB1	; 177
    b902:	f9 4f       	sbci	r31, 0xF9	; 249
    b904:	80 83       	st	Z, r24
    b906:	4f 5f       	subi	r20, 0xFF	; 255
    b908:	44 31       	cpi	r20, 0x14	; 20
    b90a:	b8 f3       	brcs	.-18     	; 0xb8fa <PutLine+0x21c>

}
    b90c:	60 96       	adiw	r28, 0x10	; 16
    b90e:	0f b6       	in	r0, 0x3f	; 63
    b910:	f8 94       	cli
    b912:	de bf       	out	0x3e, r29	; 62
    b914:	0f be       	out	0x3f, r0	; 63
    b916:	cd bf       	out	0x3d, r28	; 61
    b918:	cf 91       	pop	r28
    b91a:	df 91       	pop	r29
    b91c:	1f 91       	pop	r17
    b91e:	0f 91       	pop	r16
    b920:	ff 90       	pop	r15
    b922:	ef 90       	pop	r14
    b924:	df 90       	pop	r13
    b926:	cf 90       	pop	r12
    b928:	bf 90       	pop	r11
    b92a:	af 90       	pop	r10
    b92c:	9f 90       	pop	r9
    b92e:	8f 90       	pop	r8
    b930:	7f 90       	pop	r7
    b932:	6f 90       	pop	r6
    b934:	5f 90       	pop	r5
    b936:	4f 90       	pop	r4
    b938:	3f 90       	pop	r3
    b93a:	2f 90       	pop	r2
    b93c:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    b93e:	fa 01       	movw	r30, r20
    b940:	84 91       	lpm	r24, Z+
			Y1=Y;
			Param.Prec = prb(&(OF+OF_N)->Prec);
			Param.Txt = prp(&(OF+OF_N)->EnumList);
			if(LineN==CurrLine && OF_N==CurrField)
				//add new
				if( (prb(&(OF+OF_N)->Type) == Text) || (prb(&(OF+OF_N)->Type) == EE_Text ) ||
    b942:	81 32       	cpi	r24, 0x21	; 33
    b944:	61 f1       	breq	.+88     	; 0xb99e <PutLine+0x2c0>
    b946:	82 32       	cpi	r24, 0x22	; 34
    b948:	51 f1       	breq	.+84     	; 0xb99e <PutLine+0x2c0>
    b94a:	80 31       	cpi	r24, 0x10	; 16
    b94c:	41 f1       	breq	.+80     	; 0xb99e <PutLine+0x2c0>
    b94e:	84 31       	cpi	r24, 0x14	; 20
    b950:	31 f1       	breq	.+76     	; 0xb99e <PutLine+0x2c0>
    b952:	81 31       	cpi	r24, 0x11	; 17
    b954:	21 f1       	breq	.+72     	; 0xb99e <PutLine+0x2c0>
    b956:	85 31       	cpi	r24, 0x15	; 21
    b958:	11 f1       	breq	.+68     	; 0xb99e <PutLine+0x2c0>
    b95a:	82 31       	cpi	r24, 0x12	; 18
    b95c:	01 f1       	breq	.+64     	; 0xb99e <PutLine+0x2c0>
    b95e:	83 31       	cpi	r24, 0x13	; 19
    b960:	f1 f0       	breq	.+60     	; 0xb99e <PutLine+0x2c0>
    b962:	89 31       	cpi	r24, 0x19	; 25
    b964:	e1 f0       	breq	.+56     	; 0xb99e <PutLine+0x2c0>
    b966:	8b 31       	cpi	r24, 0x1B	; 27
    b968:	d1 f0       	breq	.+52     	; 0xb99e <PutLine+0x2c0>
    b96a:	8a 31       	cpi	r24, 0x1A	; 26
    b96c:	c1 f0       	breq	.+48     	; 0xb99e <PutLine+0x2c0>
    b96e:	8c 31       	cpi	r24, 0x1C	; 28
    b970:	b1 f0       	breq	.+44     	; 0xb99e <PutLine+0x2c0>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
PutBuf(uint8_t Type, T_Param *Param)
{
	switch(Type) {
    b972:	89 30       	cpi	r24, 0x09	; 9
    b974:	08 f0       	brcs	.+2      	; 0xb978 <PutLine+0x29a>
    b976:	b7 c0       	rjmp	.+366    	; 0xbae6 <PutLine+0x408>
    b978:	87 30       	cpi	r24, 0x07	; 7
    b97a:	08 f0       	brcs	.+2      	; 0xb97e <PutLine+0x2a0>
    b97c:	b9 c0       	rjmp	.+370    	; 0xbaf0 <PutLine+0x412>
    b97e:	84 30       	cpi	r24, 0x04	; 4
    b980:	08 f0       	brcs	.+2      	; 0xb984 <PutLine+0x2a6>
    b982:	e5 c0       	rjmp	.+458    	; 0xbb4e <PutLine+0x470>
    b984:	82 30       	cpi	r24, 0x02	; 2
    b986:	08 f4       	brcc	.+2      	; 0xb98a <PutLine+0x2ac>
    b988:	b3 c0       	rjmp	.+358    	; 0xbaf0 <PutLine+0x412>
		Put_bVal(Param);
		PosBlink(Param,' ');
		break;
	case s_Byte: case s_EE_Byte:
	case s_Word: case s_EE_Word:
		Put_sbVal(Param);
    b98a:	c3 01       	movw	r24, r6
    b98c:	0e 94 fa 3f 	call	0x7ff4	; 0x7ff4 <Put_sbVal>
		PosBlink(Param,' ');
    b990:	c3 01       	movw	r24, r6
    b992:	60 e2       	ldi	r22, 0x20	; 32
    b994:	0e 94 ef 3b 	call	0x77de	; 0x77de <PosBlink>
    b998:	3c 81       	ldd	r19, Y+4	; 0x04
				else{ 
					PutBuf(prb(&(OF+OF_N)->Type), &Param);
				}			
			else
				PutField(prb(&(OF+OF_N)->Type), prp(&(OF+OF_N)->Var), &Param);
			OF_N++;
    b99a:	83 94       	inc	r8
    b99c:	0d cf       	rjmp	.-486    	; 0xb7b8 <PutLine+0xda>
// When use BufStr for variable edit
inline static void
PutBufStr(uint8_t Type, T_Param *Param)
{	
	char Format[6];
	sprintf(Format,"%%.%us", Param->Size);
    b99e:	00 d0       	rcall	.+0      	; 0xb9a0 <PutLine+0x2c2>
    b9a0:	00 d0       	rcall	.+0      	; 0xb9a2 <PutLine+0x2c4>
    b9a2:	ed b7       	in	r30, 0x3d	; 61
    b9a4:	fe b7       	in	r31, 0x3e	; 62
    b9a6:	31 96       	adiw	r30, 0x01	; 1
    b9a8:	27 e0       	ldi	r18, 0x07	; 7
    b9aa:	30 e0       	ldi	r19, 0x00	; 0
    b9ac:	2c 0f       	add	r18, r28
    b9ae:	3d 1f       	adc	r19, r29
    b9b0:	ad b7       	in	r26, 0x3d	; 61
    b9b2:	be b7       	in	r27, 0x3e	; 62
    b9b4:	12 96       	adiw	r26, 0x02	; 2
    b9b6:	3c 93       	st	X, r19
    b9b8:	2e 93       	st	-X, r18
    b9ba:	11 97       	sbiw	r26, 0x01	; 1
    b9bc:	8b ea       	ldi	r24, 0xAB	; 171
    b9be:	92 e0       	ldi	r25, 0x02	; 2
    b9c0:	93 83       	std	Z+3, r25	; 0x03
    b9c2:	82 83       	std	Z+2, r24	; 0x02
    b9c4:	8c 81       	ldd	r24, Y+4	; 0x04
    b9c6:	84 83       	std	Z+4, r24	; 0x04
    b9c8:	15 82       	std	Z+5, r1	; 0x05
    b9ca:	0e 94 d5 7a 	call	0xf5aa	; 0xf5aa <sprintf>
	sprintf(Param->Pos, Format, BufStr);
    b9ce:	ed b7       	in	r30, 0x3d	; 61
    b9d0:	fe b7       	in	r31, 0x3e	; 62
    b9d2:	31 96       	adiw	r30, 0x01	; 1
    b9d4:	89 81       	ldd	r24, Y+1	; 0x01
    b9d6:	9a 81       	ldd	r25, Y+2	; 0x02
    b9d8:	ad b7       	in	r26, 0x3d	; 61
    b9da:	be b7       	in	r27, 0x3e	; 62
    b9dc:	12 96       	adiw	r26, 0x02	; 2
    b9de:	9c 93       	st	X, r25
    b9e0:	8e 93       	st	-X, r24
    b9e2:	11 97       	sbiw	r26, 0x01	; 1
    b9e4:	27 e0       	ldi	r18, 0x07	; 7
    b9e6:	30 e0       	ldi	r19, 0x00	; 0
    b9e8:	2c 0f       	add	r18, r28
    b9ea:	3d 1f       	adc	r19, r29
    b9ec:	33 83       	std	Z+3, r19	; 0x03
    b9ee:	22 83       	std	Z+2, r18	; 0x02
    b9f0:	8a eb       	ldi	r24, 0xBA	; 186
    b9f2:	95 e0       	ldi	r25, 0x05	; 5
    b9f4:	95 83       	std	Z+5, r25	; 0x05
    b9f6:	84 83       	std	Z+4, r24	; 0x04
    b9f8:	0e 94 d5 7a 	call	0xf5aa	; 0xf5aa <sprintf>
	Param->Prec = 0;
    b9fc:	1b 82       	std	Y+3, r1	; 0x03
	PosBlink(Param,'_');
    b9fe:	ad b7       	in	r26, 0x3d	; 61
    ba00:	be b7       	in	r27, 0x3e	; 62
    ba02:	16 96       	adiw	r26, 0x06	; 6
    ba04:	0f b6       	in	r0, 0x3f	; 63
    ba06:	f8 94       	cli
    ba08:	be bf       	out	0x3e, r27	; 62
    ba0a:	0f be       	out	0x3f, r0	; 63
    ba0c:	ad bf       	out	0x3d, r26	; 61
    ba0e:	c3 01       	movw	r24, r6
    ba10:	6f e5       	ldi	r22, 0x5F	; 95
    ba12:	0e 94 ef 3b 	call	0x77de	; 0x77de <PosBlink>
    ba16:	3c 81       	ldd	r19, Y+4	; 0x04
				else{ 
					PutBuf(prb(&(OF+OF_N)->Type), &Param);
				}			
			else
				PutField(prb(&(OF+OF_N)->Type), prp(&(OF+OF_N)->Var), &Param);
			OF_N++;
    ba18:	83 94       	inc	r8
    ba1a:	ce ce       	rjmp	.-612    	; 0xb7b8 <PutLine+0xda>

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    ba1c:	08 94       	sec
    ba1e:	e1 1c       	adc	r14, r1
    ba20:	f1 1c       	adc	r15, r1
    ba22:	f7 01       	movw	r30, r14
    ba24:	84 91       	lpm	r24, Z+
    ba26:	08 94       	sec
    ba28:	e1 08       	sbc	r14, r1
    ba2a:	f1 08       	sbc	r15, r1
		X1 = strlen_P(CurrStr) - 2;
		X0 = 0;
		Xs = X0-2;
	}
	//--- "<>" Align center
	if(prc(CurrStr+0) == '<' && prc(CurrStr+1) == '>'){
    ba2c:	8e 33       	cpi	r24, 0x3E	; 62
    ba2e:	09 f0       	breq	.+2      	; 0xba32 <PutLine+0x354>
    ba30:	9f ce       	rjmp	.-706    	; 0xb770 <PutLine+0x92>
		X0 = (LCDXSz - strlen_P(CurrStr) + 2) / 2;
    ba32:	8b 2d       	mov	r24, r11
    ba34:	9a 2d       	mov	r25, r10
    ba36:	0e 94 e9 79 	call	0xf3d2	; 0xf3d2 <strlen_P>
    ba3a:	26 e1       	ldi	r18, 0x16	; 22
    ba3c:	30 e0       	ldi	r19, 0x00	; 0
    ba3e:	28 1b       	sub	r18, r24
    ba40:	39 0b       	sbc	r19, r25
    ba42:	36 95       	lsr	r19
    ba44:	27 95       	ror	r18
    ba46:	42 2f       	mov	r20, r18
		Xs = X0-2;
    ba48:	52 2f       	mov	r21, r18
    ba4a:	52 50       	subi	r21, 0x02	; 2
		X1 = X0 + (strlen_P(CurrStr) - 2);
    ba4c:	be ef       	ldi	r27, 0xFE	; 254
    ba4e:	9b 2e       	mov	r9, r27
    ba50:	98 0e       	add	r9, r24
    ba52:	92 0e       	add	r9, r18
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';		
    ba54:	22 23       	and	r18, r18
    ba56:	09 f4       	brne	.+2      	; 0xba5a <PutLine+0x37c>
    ba58:	8b ce       	rjmp	.-746    	; 0xb770 <PutLine+0x92>
    ba5a:	85 e1       	ldi	r24, 0x15	; 21
    ba5c:	28 89       	ldd	r18, Y+16	; 0x10
    ba5e:	28 9f       	mul	r18, r24
    ba60:	f0 01       	movw	r30, r0
    ba62:	11 24       	eor	r1, r1
    ba64:	e1 5b       	subi	r30, 0xB1	; 177
    ba66:	f9 4f       	sbci	r31, 0xF9	; 249
    ba68:	80 e0       	ldi	r24, 0x00	; 0
    ba6a:	90 e2       	ldi	r25, 0x20	; 32
    ba6c:	91 93       	st	Z+, r25
    ba6e:	8f 5f       	subi	r24, 0xFF	; 255
    ba70:	84 17       	cp	r24, r20
    ba72:	e0 f3       	brcs	.-8      	; 0xba6c <PutLine+0x38e>
    ba74:	7d ce       	rjmp	.-774    	; 0xb770 <PutLine+0x92>
    ba76:	08 94       	sec
    ba78:	e1 1c       	adc	r14, r1
    ba7a:	f1 1c       	adc	r15, r1
    ba7c:	f7 01       	movw	r30, r14
    ba7e:	84 91       	lpm	r24, Z+
    ba80:	08 94       	sec
    ba82:	e1 08       	sbc	r14, r1
    ba84:	f1 08       	sbc	r15, r1
		X0 = LCDXSz - strlen_P(CurrStr) + 2;
		Xs = X0-2;
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';
	}
	//--- "<<" Align left
	if(prc(CurrStr+0) == '<' && prc(CurrStr+1) == '<'){
    ba86:	8c 33       	cpi	r24, 0x3C	; 60
    ba88:	09 f0       	breq	.+2      	; 0xba8c <PutLine+0x3ae>
    ba8a:	6b ce       	rjmp	.-810    	; 0xb762 <PutLine+0x84>
		X1 = strlen_P(CurrStr) - 2;
    ba8c:	8b 2d       	mov	r24, r11
    ba8e:	9a 2d       	mov	r25, r10
    ba90:	0e 94 e9 79 	call	0xf3d2	; 0xf3d2 <strlen_P>
    ba94:	9e ef       	ldi	r25, 0xFE	; 254
    ba96:	99 2e       	mov	r9, r25
    ba98:	98 0e       	add	r9, r24
    ba9a:	5e ef       	ldi	r21, 0xFE	; 254
    ba9c:	40 e0       	ldi	r20, 0x00	; 0
    ba9e:	63 ce       	rjmp	.-826    	; 0xb766 <PutLine+0x88>
    baa0:	08 94       	sec
    baa2:	e1 1c       	adc	r14, r1
    baa4:	f1 1c       	adc	r15, r1
    baa6:	f7 01       	movw	r30, r14
    baa8:	84 91       	lpm	r24, Z+
    baaa:	08 94       	sec
    baac:	e1 08       	sbc	r14, r1
    baae:	f1 08       	sbc	r15, r1
	uint8_t X;
	uint8_t X0=0;
	uint8_t X1=LCDXSz;
	int8_t Xs = 0;
	//--- ">>" Align right
	if(prc(CurrStr+0) == '>' && prc(CurrStr+1) == '>'){
    bab0:	8e 33       	cpi	r24, 0x3E	; 62
    bab2:	09 f0       	breq	.+2      	; 0xbab6 <PutLine+0x3d8>
    bab4:	4f ce       	rjmp	.-866    	; 0xb754 <PutLine+0x76>
		X0 = LCDXSz - strlen_P(CurrStr) + 2;
    bab6:	c7 01       	movw	r24, r14
    bab8:	0e 94 e9 79 	call	0xf3d2	; 0xf3d2 <strlen_P>
    babc:	46 e1       	ldi	r20, 0x16	; 22
    babe:	48 1b       	sub	r20, r24
		Xs = X0-2;
    bac0:	54 2f       	mov	r21, r20
    bac2:	52 50       	subi	r21, 0x02	; 2
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';
    bac4:	44 23       	and	r20, r20
    bac6:	09 f4       	brne	.+2      	; 0xbaca <PutLine+0x3ec>
    bac8:	47 ce       	rjmp	.-882    	; 0xb758 <PutLine+0x7a>
    baca:	85 e1       	ldi	r24, 0x15	; 21
    bacc:	28 89       	ldd	r18, Y+16	; 0x10
    bace:	28 9f       	mul	r18, r24
    bad0:	f0 01       	movw	r30, r0
    bad2:	11 24       	eor	r1, r1
    bad4:	e1 5b       	subi	r30, 0xB1	; 177
    bad6:	f9 4f       	sbci	r31, 0xF9	; 249
    bad8:	80 e0       	ldi	r24, 0x00	; 0
    bada:	90 e2       	ldi	r25, 0x20	; 32
    badc:	91 93       	st	Z+, r25
    bade:	8f 5f       	subi	r24, 0xFF	; 255
    bae0:	84 17       	cp	r24, r20
    bae2:	e0 f3       	brcs	.-8      	; 0xbadc <PutLine+0x3fe>
    bae4:	39 ce       	rjmp	.-910    	; 0xb758 <PutLine+0x7a>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
PutBuf(uint8_t Type, T_Param *Param)
{
	switch(Type) {
    bae6:	8d 30       	cpi	r24, 0x0D	; 13
    bae8:	68 f4       	brcc	.+26     	; 0xbb04 <PutLine+0x426>
    baea:	8b 30       	cpi	r24, 0x0B	; 11
    baec:	08 f4       	brcc	.+2      	; 0xbaf0 <PutLine+0x412>
    baee:	4d cf       	rjmp	.-358    	; 0xb98a <PutLine+0x2ac>
	case Byte: case EE_Byte: case z_Byte: case z_EE_Byte:
	case Word: case EE_Word: case z_Word: case z_EE_Word:
		Put_bVal(Param);
    baf0:	c3 01       	movw	r24, r6
    baf2:	0e 94 f8 40 	call	0x81f0	; 0x81f0 <Put_bVal>
		PosBlink(Param,' ');
    baf6:	c3 01       	movw	r24, r6
    baf8:	60 e2       	ldi	r22, 0x20	; 32
    bafa:	0e 94 ef 3b 	call	0x77de	; 0x77de <PosBlink>
    bafe:	3c 81       	ldd	r19, Y+4	; 0x04
				else{ 
					PutBuf(prb(&(OF+OF_N)->Type), &Param);
				}			
			else
				PutField(prb(&(OF+OF_N)->Type), prp(&(OF+OF_N)->Var), &Param);
			OF_N++;
    bb00:	83 94       	inc	r8
    bb02:	5a ce       	rjmp	.-844    	; 0xb7b8 <PutLine+0xda>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
PutBuf(uint8_t Type, T_Param *Param)
{
	switch(Type) {
    bb04:	8e 30       	cpi	r24, 0x0E	; 14
    bb06:	b9 f1       	breq	.+110    	; 0xbb76 <PutLine+0x498>
    bb08:	8e 30       	cpi	r24, 0x0E	; 14
    bb0a:	28 f1       	brcs	.+74     	; 0xbb56 <PutLine+0x478>
    bb0c:	8d 51       	subi	r24, 0x1D	; 29
    bb0e:	84 30       	cpi	r24, 0x04	; 4
    bb10:	08 f0       	brcs	.+2      	; 0xbb14 <PutLine+0x436>
    bb12:	da ce       	rjmp	.-588    	; 0xb8c8 <PutLine+0x1ea>
	case zc_Word:
		Put_zVal(F_Buf, 'w', Param);
		ValBlink(Param->Pos, Param->Size);
		break;
	case Enum: case EE_Enum: case Bit: case EE_Bit:
		Param->Txt += (uint8_t)F_Buf;
    bb14:	80 91 ee 04 	lds	r24, 0x04EE
    bb18:	90 e0       	ldi	r25, 0x00	; 0
    bb1a:	88 0f       	add	r24, r24
    bb1c:	99 1f       	adc	r25, r25
    bb1e:	28 0f       	add	r18, r24
    bb20:	39 1f       	adc	r19, r25
    bb22:	3e 83       	std	Y+6, r19	; 0x06
    bb24:	2d 83       	std	Y+5, r18	; 0x05
		PutEnum(Param);
    bb26:	c3 01       	movw	r24, r6
    bb28:	0e 94 c9 3f 	call	0x7f92	; 0x7f92 <PutEnum>
		ValBlink(Param->Pos, Param->Size);
    bb2c:	3c 81       	ldd	r19, Y+4	; 0x04

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
ValBlink(char *Pos, uint8_t Sz)
{
	CurrX=Pos-LCD_Buf[Y1];
    bb2e:	80 91 f3 09 	lds	r24, 0x09F3
    bb32:	f5 e1       	ldi	r31, 0x15	; 21
    bb34:	8f 9f       	mul	r24, r31
    bb36:	c0 01       	movw	r24, r0
    bb38:	11 24       	eor	r1, r1
    bb3a:	81 5b       	subi	r24, 0xB1	; 177
    bb3c:	99 4f       	sbci	r25, 0xF9	; 249
    bb3e:	29 81       	ldd	r18, Y+1	; 0x01
    bb40:	28 1b       	sub	r18, r24
    bb42:	20 93 b0 06 	sts	0x06B0, r18
	StrSize=Sz; 
    bb46:	30 93 a3 06 	sts	0x06A3, r19
				else{ 
					PutBuf(prb(&(OF+OF_N)->Type), &Param);
				}			
			else
				PutField(prb(&(OF+OF_N)->Type), prp(&(OF+OF_N)->Var), &Param);
			OF_N++;
    bb4a:	83 94       	inc	r8
    bb4c:	35 ce       	rjmp	.-918    	; 0xb7b8 <PutLine+0xda>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
PutBuf(uint8_t Type, T_Param *Param)
{
	switch(Type) {
    bb4e:	86 30       	cpi	r24, 0x06	; 6
    bb50:	78 f2       	brcs	.-98     	; 0xbaf0 <PutLine+0x412>
    bb52:	3c 81       	ldd	r19, Y+4	; 0x04
    bb54:	ba ce       	rjmp	.-652    	; 0xb8ca <PutLine+0x1ec>
	case s_Word: case s_EE_Word:
		Put_sbVal(Param);
		PosBlink(Param,' ');
		break;
	case c_Word:
		PutVal(F_Buf, 'w', Param);
    bb56:	80 91 ee 04 	lds	r24, 0x04EE
    bb5a:	90 91 ef 04 	lds	r25, 0x04EF
    bb5e:	67 e7       	ldi	r22, 0x77	; 119
    bb60:	a3 01       	movw	r20, r6
    bb62:	0e 94 c7 48 	call	0x918e	; 0x918e <PutVal>
		ValBlink(Param->Pos, Param->Size);
    bb66:	3c 81       	ldd	r19, Y+4	; 0x04

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
ValBlink(char *Pos, uint8_t Sz)
{
	CurrX=Pos-LCD_Buf[Y1];
    bb68:	80 91 f3 09 	lds	r24, 0x09F3
    bb6c:	b5 e1       	ldi	r27, 0x15	; 21
    bb6e:	8b 9f       	mul	r24, r27
    bb70:	c0 01       	movw	r24, r0
    bb72:	11 24       	eor	r1, r1
    bb74:	e2 cf       	rjmp	.-60     	; 0xbb3a <PutLine+0x45c>
	case c_Word:
		PutVal(F_Buf, 'w', Param);
		ValBlink(Param->Pos, Param->Size);
		break;
	case zc_Word:
		Put_zVal(F_Buf, 'w', Param);
    bb76:	80 91 ee 04 	lds	r24, 0x04EE
    bb7a:	90 91 ef 04 	lds	r25, 0x04EF
    bb7e:	67 e7       	ldi	r22, 0x77	; 119
    bb80:	a3 01       	movw	r20, r6
    bb82:	0e 94 26 47 	call	0x8e4c	; 0x8e4c <Put_zVal>
		ValBlink(Param->Pos, Param->Size);
    bb86:	3c 81       	ldd	r19, Y+4	; 0x04

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
ValBlink(char *Pos, uint8_t Sz)
{
	CurrX=Pos-LCD_Buf[Y1];
    bb88:	80 91 f3 09 	lds	r24, 0x09F3
    bb8c:	e5 e1       	ldi	r30, 0x15	; 21
    bb8e:	8e 9f       	mul	r24, r30
    bb90:	c0 01       	movw	r24, r0
    bb92:	11 24       	eor	r1, r1
    bb94:	d2 cf       	rjmp	.-92     	; 0xbb3a <PutLine+0x45c>

0000bb96 <MenuOut>:
	while(X<LCDXSz)	LCD_Buf[Y][X++] = ' ';
}
// ~~~~~~~~~~
void
MenuOut(void)
{
    bb96:	2f 92       	push	r2
    bb98:	3f 92       	push	r3
    bb9a:	4f 92       	push	r4
    bb9c:	5f 92       	push	r5
    bb9e:	6f 92       	push	r6
    bba0:	7f 92       	push	r7
    bba2:	8f 92       	push	r8
    bba4:	9f 92       	push	r9
    bba6:	af 92       	push	r10
    bba8:	bf 92       	push	r11
    bbaa:	cf 92       	push	r12
    bbac:	df 92       	push	r13
    bbae:	ef 92       	push	r14
    bbb0:	ff 92       	push	r15
    bbb2:	0f 93       	push	r16
    bbb4:	1f 93       	push	r17
    bbb6:	df 93       	push	r29
    bbb8:	cf 93       	push	r28
    bbba:	cd b7       	in	r28, 0x3d	; 61
    bbbc:	de b7       	in	r29, 0x3e	; 62
    bbbe:	2a 97       	sbiw	r28, 0x0a	; 10
    bbc0:	0f b6       	in	r0, 0x3f	; 63
    bbc2:	f8 94       	cli
    bbc4:	de bf       	out	0x3e, r29	; 62
    bbc6:	0f be       	out	0x3f, r0	; 63
    bbc8:	cd bf       	out	0x3d, r28	; 61
	uint8_t Y;
	if(CurrMsg) {
    bbca:	a0 90 ec 04 	lds	r10, 0x04EC
    bbce:	b0 90 ed 04 	lds	r11, 0x04ED
    bbd2:	a1 14       	cp	r10, r1
    bbd4:	b1 04       	cpc	r11, r1
    bbd6:	09 f4       	brne	.+2      	; 0xbbda <MenuOut+0x44>
    bbd8:	6a c1       	rjmp	.+724    	; 0xbeae <MenuOut+0x318>
    bbda:	22 24       	eor	r2, r2
    bbdc:	33 24       	eor	r3, r3
    bbde:	18 86       	std	Y+8, r1	; 0x08
    bbe0:	1f 82       	std	Y+7, r1	; 0x07
	int8_t Xs = 0;
	//--- ">>" Align right
	if(prc(CurrStr+0) == '>' && prc(CurrStr+1) == '>'){
		X0 = LCDXSz - strlen_P(CurrStr) + 2;
		Xs = X0-2;
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';
    bbe2:	80 e2       	ldi	r24, 0x20	; 32
    bbe4:	48 2e       	mov	r4, r24
	#if TypeLCD==840
		const MsgLine *Line=(MsgLine*)prp(&CurrMsg->LineList)+Y;
	#else
		const MsgLine *Line=CurrMsg->LineList+Y;		
	#endif
	PGM_P CurrStr=(PGM_P)(Line->Str);
    bbe6:	91 01       	movw	r18, r2
    bbe8:	22 0f       	add	r18, r18
    bbea:	33 1f       	adc	r19, r19
    bbec:	3a 87       	std	Y+10, r19	; 0x0a
    bbee:	29 87       	std	Y+9, r18	; 0x09
    bbf0:	49 01       	movw	r8, r18
    bbf2:	82 0c       	add	r8, r2
    bbf4:	93 1c       	adc	r9, r3
    bbf6:	64 01       	movw	r12, r8
    bbf8:	cc 0c       	add	r12, r12
    bbfa:	dd 1c       	adc	r13, r13
    bbfc:	cc 0c       	add	r12, r12
    bbfe:	dd 1c       	adc	r13, r13
    bc00:	cc 0c       	add	r12, r12
    bc02:	dd 1c       	adc	r13, r13
    bc04:	96 01       	movw	r18, r12
    bc06:	22 19       	sub	r18, r2
    bc08:	33 09       	sbc	r19, r3
    bc0a:	75 01       	movw	r14, r10
    bc0c:	e2 0e       	add	r14, r18
    bc0e:	f3 1e       	adc	r15, r19

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    bc10:	2b 5e       	subi	r18, 0xEB	; 235
    bc12:	3f 4f       	sbci	r19, 0xFF	; 255
    bc14:	c5 01       	movw	r24, r10
    bc16:	82 0f       	add	r24, r18
    bc18:	93 1f       	adc	r25, r19
    bc1a:	25 51       	subi	r18, 0x15	; 21
    bc1c:	30 40       	sbci	r19, 0x00	; 0
    bc1e:	fc 01       	movw	r30, r24
    bc20:	65 90       	lpm	r6, Z+
    bc22:	74 90       	lpm	r7, Z+

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    bc24:	f7 01       	movw	r30, r14
    bc26:	84 91       	lpm	r24, Z+
	uint8_t X;
	uint8_t X0=0;
	uint8_t X1=LCDXSz;
	int8_t Xs = 0;
	//--- ">>" Align right
	if(prc(CurrStr+0) == '>' && prc(CurrStr+1) == '>'){
    bc28:	8e 33       	cpi	r24, 0x3E	; 62
    bc2a:	09 f4       	brne	.+2      	; 0xbc2e <MenuOut+0x98>
    bc2c:	b3 c0       	rjmp	.+358    	; 0xbd94 <MenuOut+0x1fe>
		X0 = LCDXSz - strlen_P(CurrStr) + 2;
		Xs = X0-2;
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';
    bc2e:	90 e0       	ldi	r25, 0x00	; 0
    bc30:	00 e0       	ldi	r16, 0x00	; 0
    bc32:	f7 01       	movw	r30, r14
    bc34:	84 91       	lpm	r24, Z+
	}
	//--- "<<" Align left
	if(prc(CurrStr+0) == '<' && prc(CurrStr+1) == '<'){
    bc36:	8c 33       	cpi	r24, 0x3C	; 60
    bc38:	09 f4       	brne	.+2      	; 0xbc3c <MenuOut+0xa6>
    bc3a:	cd c0       	rjmp	.+410    	; 0xbdd6 <MenuOut+0x240>
		X1 = strlen_P(CurrStr) - 2;
    bc3c:	f4 e1       	ldi	r31, 0x14	; 20
    bc3e:	5f 2e       	mov	r5, r31
    bc40:	f7 01       	movw	r30, r14
    bc42:	84 91       	lpm	r24, Z+
		X0 = 0;
		Xs = X0-2;
	}
	//--- "<>" Align center
	if(prc(CurrStr+0) == '<' && prc(CurrStr+1) == '>'){
    bc44:	8c 33       	cpi	r24, 0x3C	; 60
    bc46:	09 f4       	brne	.+2      	; 0xbc4a <MenuOut+0xb4>
    bc48:	e6 c0       	rjmp	.+460    	; 0xbe16 <MenuOut+0x280>
		X1 = X0 + (strlen_P(CurrStr) - 2);
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';		
	}
	//---

	for(X=X0; X<X1; X++){
    bc4a:	05 15       	cp	r16, r5
    bc4c:	08 f0       	brcs	.+2      	; 0xbc50 <MenuOut+0xba>
    bc4e:	73 c0       	rjmp	.+230    	; 0xbd36 <MenuOut+0x1a0>
		const MsgLine *Line=(MsgLine*)prp(&CurrMsg->LineList)+Y;
	#else
		const MsgLine *Line=CurrMsg->LineList+Y;		
	#endif
	PGM_P CurrStr=(PGM_P)(Line->Str);
	InField *IF = prp(&Line->IF_List);
    bc50:	73 01       	movw	r14, r6
    bc52:	69 2e       	mov	r6, r25
    bc54:	77 24       	eor	r7, r7
    bc56:	67 fc       	sbrc	r6, 7
    bc58:	70 94       	com	r7
    bc5a:	29 85       	ldd	r18, Y+9	; 0x09
    bc5c:	3a 85       	ldd	r19, Y+10	; 0x0a
    bc5e:	22 0d       	add	r18, r2
    bc60:	33 1d       	adc	r19, r3
    bc62:	c9 01       	movw	r24, r18
    bc64:	88 0f       	add	r24, r24
    bc66:	99 1f       	adc	r25, r25
    bc68:	88 0f       	add	r24, r24
    bc6a:	99 1f       	adc	r25, r25
    bc6c:	88 0f       	add	r24, r24
    bc6e:	99 1f       	adc	r25, r25
    bc70:	6c 01       	movw	r12, r24
    bc72:	c2 18       	sub	r12, r2
    bc74:	d3 08       	sbc	r13, r3
			Param.Txt = prp(&IF->EnumList);
			PutField(prb(&IF->Type), prp(&IF->Var), &Param);
			IF++;
			X += Param.Size;
		}
		LCD_Buf[Y][X] = Char;
    bc76:	4c 01       	movw	r8, r24
    bc78:	82 1a       	sub	r8, r18
    bc7a:	93 0a       	sbc	r9, r19
    bc7c:	09 c0       	rjmp	.+18     	; 0xbc90 <MenuOut+0xfa>
    bc7e:	a8 0d       	add	r26, r8
    bc80:	b9 1d       	adc	r27, r9
    bc82:	a1 5b       	subi	r26, 0xB1	; 177
    bc84:	b9 4f       	sbci	r27, 0xF9	; 249
    bc86:	1c 93       	st	X, r17
		X1 = X0 + (strlen_P(CurrStr) - 2);
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';		
	}
	//---

	for(X=X0; X<X1; X++){
    bc88:	0f 5f       	subi	r16, 0xFF	; 255
    bc8a:	05 15       	cp	r16, r5
    bc8c:	08 f0       	brcs	.+2      	; 0xbc90 <MenuOut+0xfa>
    bc8e:	4f c0       	rjmp	.+158    	; 0xbd2e <MenuOut+0x198>
		char Char;
		if((Char=prc(CurrStr+X-Xs))=='{') {
    bc90:	a0 2f       	mov	r26, r16
    bc92:	b0 e0       	ldi	r27, 0x00	; 0
    bc94:	9d 01       	movw	r18, r26
    bc96:	26 19       	sub	r18, r6
    bc98:	37 09       	sbc	r19, r7
    bc9a:	f6 01       	movw	r30, r12
    bc9c:	e2 0f       	add	r30, r18
    bc9e:	f3 1f       	adc	r31, r19
    bca0:	ea 0d       	add	r30, r10
    bca2:	fb 1d       	adc	r31, r11
    bca4:	14 91       	lpm	r17, Z+
    bca6:	1b 37       	cpi	r17, 0x7B	; 123
    bca8:	51 f7       	brne	.-44     	; 0xbc7e <MenuOut+0xe8>
			T_Param Param;
			Param.Pos = LCD_Buf[Y]+X;
    bcaa:	8f 81       	ldd	r24, Y+7	; 0x07
    bcac:	98 85       	ldd	r25, Y+8	; 0x08
    bcae:	a8 0f       	add	r26, r24
    bcb0:	b9 1f       	adc	r27, r25
    bcb2:	a1 5b       	subi	r26, 0xB1	; 177
    bcb4:	b9 4f       	sbci	r27, 0xF9	; 249
    bcb6:	ba 83       	std	Y+2, r27	; 0x02
    bcb8:	a9 83       	std	Y+1, r26	; 0x01
    bcba:	81 e0       	ldi	r24, 0x01	; 1
    bcbc:	f9 01       	movw	r30, r18
    bcbe:	e8 0f       	add	r30, r24
    bcc0:	f1 1d       	adc	r31, r1
    bcc2:	ec 0d       	add	r30, r12
    bcc4:	fd 1d       	adc	r31, r13
    bcc6:	ea 0d       	add	r30, r10
    bcc8:	fb 1d       	adc	r31, r11
    bcca:	14 91       	lpm	r17, Z+
    bccc:	98 2f       	mov	r25, r24
    bcce:	8f 5f       	subi	r24, 0xFF	; 255
			Param.Size = 0;
			while((Char=prc(CurrStr+X-Xs+ ++Param.Size))=='{');
    bcd0:	1b 37       	cpi	r17, 0x7B	; 123
    bcd2:	a1 f3       	breq	.-24     	; 0xbcbc <MenuOut+0x126>
    bcd4:	9c 83       	std	Y+4, r25	; 0x04

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    bcd6:	e5 e0       	ldi	r30, 0x05	; 5
    bcd8:	f0 e0       	ldi	r31, 0x00	; 0
    bcda:	ee 0e       	add	r14, r30
    bcdc:	ff 1e       	adc	r15, r31
    bcde:	f7 01       	movw	r30, r14
    bce0:	84 91       	lpm	r24, Z+
    bce2:	2b ef       	ldi	r18, 0xFB	; 251
    bce4:	3f ef       	ldi	r19, 0xFF	; 255
    bce6:	e2 0e       	add	r14, r18
    bce8:	f3 1e       	adc	r15, r19
			Param.Prec = prb(&IF->Prec);
    bcea:	8b 83       	std	Y+3, r24	; 0x03

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    bcec:	f7 01       	movw	r30, r14
    bcee:	33 96       	adiw	r30, 0x03	; 3
    bcf0:	85 91       	lpm	r24, Z+
    bcf2:	94 91       	lpm	r25, Z+
			Param.Txt = prp(&IF->EnumList);
    bcf4:	9e 83       	std	Y+6, r25	; 0x06
    bcf6:	8d 83       	std	Y+5, r24	; 0x05

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    bcf8:	f7 01       	movw	r30, r14
    bcfa:	84 91       	lpm	r24, Z+

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    bcfc:	31 96       	adiw	r30, 0x01	; 1
    bcfe:	65 91       	lpm	r22, Z+
    bd00:	74 91       	lpm	r23, Z+
			PutField(prb(&IF->Type), prp(&IF->Var), &Param);
    bd02:	ae 01       	movw	r20, r28
    bd04:	4f 5f       	subi	r20, 0xFF	; 255
    bd06:	5f 4f       	sbci	r21, 0xFF	; 255
    bd08:	0e 94 ea 59 	call	0xb3d4	; 0xb3d4 <PutField>
			IF++;
    bd0c:	26 e0       	ldi	r18, 0x06	; 6
    bd0e:	30 e0       	ldi	r19, 0x00	; 0
    bd10:	e2 0e       	add	r14, r18
    bd12:	f3 1e       	adc	r15, r19
			X += Param.Size;
    bd14:	8c 81       	ldd	r24, Y+4	; 0x04
    bd16:	08 0f       	add	r16, r24
    bd18:	a0 2f       	mov	r26, r16
    bd1a:	b0 e0       	ldi	r27, 0x00	; 0
		}
		LCD_Buf[Y][X] = Char;
    bd1c:	a8 0d       	add	r26, r8
    bd1e:	b9 1d       	adc	r27, r9
    bd20:	a1 5b       	subi	r26, 0xB1	; 177
    bd22:	b9 4f       	sbci	r27, 0xF9	; 249
    bd24:	1c 93       	st	X, r17
		X1 = X0 + (strlen_P(CurrStr) - 2);
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';		
	}
	//---

	for(X=X0; X<X1; X++){
    bd26:	0f 5f       	subi	r16, 0xFF	; 255
    bd28:	05 15       	cp	r16, r5
    bd2a:	08 f4       	brcc	.+2      	; 0xbd2e <MenuOut+0x198>
    bd2c:	b1 cf       	rjmp	.-158    	; 0xbc90 <MenuOut+0xfa>
    bd2e:	a0 90 ec 04 	lds	r10, 0x04EC
    bd32:	b0 90 ed 04 	lds	r11, 0x04ED
			X += Param.Size;
		}
		LCD_Buf[Y][X] = Char;
	}
	X=X1;
	for(;X<LCDXSz; X++) LCD_Buf[Y][X] = ' ';
    bd36:	33 e1       	ldi	r19, 0x13	; 19
    bd38:	35 15       	cp	r19, r5
    bd3a:	08 f0       	brcs	.+2      	; 0xbd3e <MenuOut+0x1a8>
    bd3c:	9f c0       	rjmp	.+318    	; 0xbe7c <MenuOut+0x2e6>
    bd3e:	08 94       	sec
    bd40:	21 1c       	adc	r2, r1
    bd42:	31 1c       	adc	r3, r1
    bd44:	ef 81       	ldd	r30, Y+7	; 0x07
    bd46:	f8 85       	ldd	r31, Y+8	; 0x08
    bd48:	75 96       	adiw	r30, 0x15	; 21
    bd4a:	f8 87       	std	Y+8, r31	; 0x08
    bd4c:	ef 83       	std	Y+7, r30	; 0x07
void
MenuOut(void)
{
	uint8_t Y;
	if(CurrMsg) {
		for(Y=0; Y<LCDYSz; PutMsgLine(Y++));
    bd4e:	f4 e0       	ldi	r31, 0x04	; 4
    bd50:	2f 16       	cp	r2, r31
    bd52:	31 04       	cpc	r3, r1
    bd54:	09 f0       	breq	.+2      	; 0xbd58 <MenuOut+0x1c2>
    bd56:	47 cf       	rjmp	.-370    	; 0xbbe6 <MenuOut+0x50>
		EventFunc(&CurrMsg->Run);
    bd58:	c5 01       	movw	r24, r10
    bd5a:	82 5a       	subi	r24, 0xA2	; 162
    bd5c:	9f 4f       	sbci	r25, 0xFF	; 255
    bd5e:	0e 94 5b 3b 	call	0x76b6	; 0x76b6 <EventFunc>
	if(prb(&CurrPage->LineNumber)>LCDYSz || Fix<LCDYSz-1 || prp(&(GetLine+CurrLine)->OF_List))
		LCD_Buf[CurrLCD][0] = CharCursor;
	if(++Blink>16)
		Blink=0;
	EventFunc(&CurrPage->Run);
}
    bd62:	2a 96       	adiw	r28, 0x0a	; 10
    bd64:	0f b6       	in	r0, 0x3f	; 63
    bd66:	f8 94       	cli
    bd68:	de bf       	out	0x3e, r29	; 62
    bd6a:	0f be       	out	0x3f, r0	; 63
    bd6c:	cd bf       	out	0x3d, r28	; 61
    bd6e:	cf 91       	pop	r28
    bd70:	df 91       	pop	r29
    bd72:	1f 91       	pop	r17
    bd74:	0f 91       	pop	r16
    bd76:	ff 90       	pop	r15
    bd78:	ef 90       	pop	r14
    bd7a:	df 90       	pop	r13
    bd7c:	cf 90       	pop	r12
    bd7e:	bf 90       	pop	r11
    bd80:	af 90       	pop	r10
    bd82:	9f 90       	pop	r9
    bd84:	8f 90       	pop	r8
    bd86:	7f 90       	pop	r7
    bd88:	6f 90       	pop	r6
    bd8a:	5f 90       	pop	r5
    bd8c:	4f 90       	pop	r4
    bd8e:	3f 90       	pop	r3
    bd90:	2f 90       	pop	r2
    bd92:	08 95       	ret

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    bd94:	f9 01       	movw	r30, r18
    bd96:	31 96       	adiw	r30, 0x01	; 1
    bd98:	ea 0d       	add	r30, r10
    bd9a:	fb 1d       	adc	r31, r11
    bd9c:	e4 91       	lpm	r30, Z+
	uint8_t X;
	uint8_t X0=0;
	uint8_t X1=LCDXSz;
	int8_t Xs = 0;
	//--- ">>" Align right
	if(prc(CurrStr+0) == '>' && prc(CurrStr+1) == '>'){
    bd9e:	ee 33       	cpi	r30, 0x3E	; 62
    bda0:	09 f0       	breq	.+2      	; 0xbda4 <MenuOut+0x20e>
    bda2:	45 cf       	rjmp	.-374    	; 0xbc2e <MenuOut+0x98>
		X0 = LCDXSz - strlen_P(CurrStr) + 2;
    bda4:	c7 01       	movw	r24, r14
    bda6:	0e 94 e9 79 	call	0xf3d2	; 0xf3d2 <strlen_P>
    bdaa:	06 e1       	ldi	r16, 0x16	; 22
    bdac:	08 1b       	sub	r16, r24
		Xs = X0-2;
    bdae:	90 2f       	mov	r25, r16
    bdb0:	92 50       	subi	r25, 0x02	; 2
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';
    bdb2:	00 23       	and	r16, r16
    bdb4:	09 f4       	brne	.+2      	; 0xbdb8 <MenuOut+0x222>
    bdb6:	3d cf       	rjmp	.-390    	; 0xbc32 <MenuOut+0x9c>
    bdb8:	f6 01       	movw	r30, r12
    bdba:	e8 19       	sub	r30, r8
    bdbc:	f9 09       	sbc	r31, r9
    bdbe:	e1 5b       	subi	r30, 0xB1	; 177
    bdc0:	f9 4f       	sbci	r31, 0xF9	; 249
    bdc2:	80 e0       	ldi	r24, 0x00	; 0
    bdc4:	41 92       	st	Z+, r4
    bdc6:	8f 5f       	subi	r24, 0xFF	; 255
    bdc8:	80 17       	cp	r24, r16
    bdca:	e0 f3       	brcs	.-8      	; 0xbdc4 <MenuOut+0x22e>
    bdcc:	f7 01       	movw	r30, r14
    bdce:	84 91       	lpm	r24, Z+
	}
	//--- "<<" Align left
	if(prc(CurrStr+0) == '<' && prc(CurrStr+1) == '<'){
    bdd0:	8c 33       	cpi	r24, 0x3C	; 60
    bdd2:	09 f0       	breq	.+2      	; 0xbdd6 <MenuOut+0x240>
    bdd4:	33 cf       	rjmp	.-410    	; 0xbc3c <MenuOut+0xa6>
    bdd6:	e9 85       	ldd	r30, Y+9	; 0x09
    bdd8:	fa 85       	ldd	r31, Y+10	; 0x0a
    bdda:	e2 0d       	add	r30, r2
    bddc:	f3 1d       	adc	r31, r3
    bdde:	ee 0f       	add	r30, r30
    bde0:	ff 1f       	adc	r31, r31
    bde2:	ee 0f       	add	r30, r30
    bde4:	ff 1f       	adc	r31, r31
    bde6:	ee 0f       	add	r30, r30
    bde8:	ff 1f       	adc	r31, r31
    bdea:	e2 19       	sub	r30, r2
    bdec:	f3 09       	sbc	r31, r3
    bdee:	31 96       	adiw	r30, 0x01	; 1
    bdf0:	ea 0d       	add	r30, r10
    bdf2:	fb 1d       	adc	r31, r11
    bdf4:	e4 91       	lpm	r30, Z+
    bdf6:	ec 33       	cpi	r30, 0x3C	; 60
    bdf8:	09 f0       	breq	.+2      	; 0xbdfc <MenuOut+0x266>
    bdfa:	20 cf       	rjmp	.-448    	; 0xbc3c <MenuOut+0xa6>
		X1 = strlen_P(CurrStr) - 2;
    bdfc:	c7 01       	movw	r24, r14
    bdfe:	0e 94 e9 79 	call	0xf3d2	; 0xf3d2 <strlen_P>
    be02:	ae ef       	ldi	r26, 0xFE	; 254
    be04:	5a 2e       	mov	r5, r26
    be06:	58 0e       	add	r5, r24
    be08:	9e ef       	ldi	r25, 0xFE	; 254
    be0a:	00 e0       	ldi	r16, 0x00	; 0
    be0c:	f7 01       	movw	r30, r14
    be0e:	84 91       	lpm	r24, Z+
		X0 = 0;
		Xs = X0-2;
	}
	//--- "<>" Align center
	if(prc(CurrStr+0) == '<' && prc(CurrStr+1) == '>'){
    be10:	8c 33       	cpi	r24, 0x3C	; 60
    be12:	09 f0       	breq	.+2      	; 0xbe16 <MenuOut+0x280>
    be14:	1a cf       	rjmp	.-460    	; 0xbc4a <MenuOut+0xb4>
    be16:	89 84       	ldd	r8, Y+9	; 0x09
    be18:	9a 84       	ldd	r9, Y+10	; 0x0a
    be1a:	82 0c       	add	r8, r2
    be1c:	93 1c       	adc	r9, r3
    be1e:	64 01       	movw	r12, r8
    be20:	cc 0c       	add	r12, r12
    be22:	dd 1c       	adc	r13, r13
    be24:	cc 0c       	add	r12, r12
    be26:	dd 1c       	adc	r13, r13
    be28:	cc 0c       	add	r12, r12
    be2a:	dd 1c       	adc	r13, r13
    be2c:	f6 01       	movw	r30, r12
    be2e:	e2 19       	sub	r30, r2
    be30:	f3 09       	sbc	r31, r3
    be32:	31 96       	adiw	r30, 0x01	; 1
    be34:	ea 0d       	add	r30, r10
    be36:	fb 1d       	adc	r31, r11
    be38:	e4 91       	lpm	r30, Z+
    be3a:	ee 33       	cpi	r30, 0x3E	; 62
    be3c:	09 f0       	breq	.+2      	; 0xbe40 <MenuOut+0x2aa>
    be3e:	05 cf       	rjmp	.-502    	; 0xbc4a <MenuOut+0xb4>
		X0 = (LCDXSz - strlen_P(CurrStr) + 2) / 2;
    be40:	c7 01       	movw	r24, r14
    be42:	0e 94 e9 79 	call	0xf3d2	; 0xf3d2 <strlen_P>
    be46:	26 e1       	ldi	r18, 0x16	; 22
    be48:	30 e0       	ldi	r19, 0x00	; 0
    be4a:	28 1b       	sub	r18, r24
    be4c:	39 0b       	sbc	r19, r25
    be4e:	36 95       	lsr	r19
    be50:	27 95       	ror	r18
    be52:	02 2f       	mov	r16, r18
		Xs = X0-2;
    be54:	92 2f       	mov	r25, r18
    be56:	92 50       	subi	r25, 0x02	; 2
		X1 = X0 + (strlen_P(CurrStr) - 2);
    be58:	6e ef       	ldi	r22, 0xFE	; 254
    be5a:	56 2e       	mov	r5, r22
    be5c:	58 0e       	add	r5, r24
    be5e:	52 0e       	add	r5, r18
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';		
    be60:	22 23       	and	r18, r18
    be62:	09 f4       	brne	.+2      	; 0xbe66 <MenuOut+0x2d0>
    be64:	f2 ce       	rjmp	.-540    	; 0xbc4a <MenuOut+0xb4>
    be66:	f6 01       	movw	r30, r12
    be68:	e8 19       	sub	r30, r8
    be6a:	f9 09       	sbc	r31, r9
    be6c:	e1 5b       	subi	r30, 0xB1	; 177
    be6e:	f9 4f       	sbci	r31, 0xF9	; 249
    be70:	80 e0       	ldi	r24, 0x00	; 0
    be72:	41 92       	st	Z+, r4
    be74:	8f 5f       	subi	r24, 0xFF	; 255
    be76:	80 17       	cp	r24, r16
    be78:	e0 f3       	brcs	.-8      	; 0xbe72 <MenuOut+0x2dc>
    be7a:	e7 ce       	rjmp	.-562    	; 0xbc4a <MenuOut+0xb4>
			X += Param.Size;
		}
		LCD_Buf[Y][X] = Char;
	}
	X=X1;
	for(;X<LCDXSz; X++) LCD_Buf[Y][X] = ' ';
    be7c:	89 85       	ldd	r24, Y+9	; 0x09
    be7e:	9a 85       	ldd	r25, Y+10	; 0x0a
    be80:	82 0d       	add	r24, r2
    be82:	93 1d       	adc	r25, r3
    be84:	9c 01       	movw	r18, r24
    be86:	22 0f       	add	r18, r18
    be88:	33 1f       	adc	r19, r19
    be8a:	22 0f       	add	r18, r18
    be8c:	33 1f       	adc	r19, r19
    be8e:	22 0f       	add	r18, r18
    be90:	33 1f       	adc	r19, r19
    be92:	28 1b       	sub	r18, r24
    be94:	39 0b       	sbc	r19, r25
    be96:	f9 01       	movw	r30, r18
    be98:	e5 0d       	add	r30, r5
    be9a:	f1 1d       	adc	r31, r1
    be9c:	e1 5b       	subi	r30, 0xB1	; 177
    be9e:	f9 4f       	sbci	r31, 0xF9	; 249
    bea0:	40 82       	st	Z, r4
    bea2:	53 94       	inc	r5
    bea4:	83 e1       	ldi	r24, 0x13	; 19
    bea6:	85 15       	cp	r24, r5
    bea8:	08 f4       	brcc	.+2      	; 0xbeac <MenuOut+0x316>
    beaa:	49 cf       	rjmp	.-366    	; 0xbd3e <MenuOut+0x1a8>
    beac:	f4 cf       	rjmp	.-24     	; 0xbe96 <MenuOut+0x300>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    beae:	40 91 d1 02 	lds	r20, 0x02D1
    beb2:	50 91 d2 02 	lds	r21, 0x02D2
    beb6:	4d 5f       	subi	r20, 0xFD	; 253
    beb8:	5f 4f       	sbci	r21, 0xFF	; 255
    beba:	fa 01       	movw	r30, r20
    bebc:	e4 90       	lpm	r14, Z+
    bebe:	43 50       	subi	r20, 0x03	; 3
    bec0:	50 40       	sbci	r21, 0x00	; 0
		for(Y=0; Y<LCDYSz; PutMsgLine(Y++));
		EventFunc(&CurrMsg->Run);
		return;
	}
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
    bec2:	c0 90 79 07 	lds	r12, 0x0779
    bec6:	d0 90 96 08 	lds	r13, 0x0896
	for(Y=0; Y<Fix; Y++)
    beca:	ee 20       	and	r14, r14
    becc:	09 f4       	brne	.+2      	; 0xbed0 <MenuOut+0x33a>
    bece:	a6 c0       	rjmp	.+332    	; 0xc01c <MenuOut+0x486>
    bed0:	00 e0       	ldi	r16, 0x00	; 0
    bed2:	10 e0       	ldi	r17, 0x00	; 0
// ~~~~~~~~~~~~~~~~~~
inline static void
PutBlankLine(uint8_t Y)
{
	uint8_t X=0;
	while(X<LCDXSz)	LCD_Buf[Y][X++] = ' ';
    bed4:	80 e2       	ldi	r24, 0x20	; 32
    bed6:	f8 2e       	mov	r15, r24
    bed8:	4e 5f       	subi	r20, 0xFE	; 254
    beda:	5f 4f       	sbci	r21, 0xFF	; 255
    bedc:	fa 01       	movw	r30, r20
    bede:	84 91       	lpm	r24, Z+
    bee0:	42 50       	subi	r20, 0x02	; 2
    bee2:	50 40       	sbci	r21, 0x00	; 0
		return;
	}
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
    bee4:	08 17       	cp	r16, r24
    bee6:	08 f4       	brcc	.+2      	; 0xbeea <MenuOut+0x354>
    bee8:	69 c0       	rjmp	.+210    	; 0xbfbc <MenuOut+0x426>
    beea:	c8 01       	movw	r24, r16
    beec:	88 0f       	add	r24, r24
    beee:	99 1f       	adc	r25, r25
    bef0:	80 0f       	add	r24, r16
    bef2:	91 1f       	adc	r25, r17
    bef4:	fc 01       	movw	r30, r24
    bef6:	ee 0f       	add	r30, r30
    bef8:	ff 1f       	adc	r31, r31
    befa:	ee 0f       	add	r30, r30
    befc:	ff 1f       	adc	r31, r31
    befe:	ee 0f       	add	r30, r30
    bf00:	ff 1f       	adc	r31, r31
    bf02:	e8 1b       	sub	r30, r24
    bf04:	f9 0b       	sbc	r31, r25
    bf06:	e1 5b       	subi	r30, 0xB1	; 177
    bf08:	f9 4f       	sbci	r31, 0xF9	; 249
    bf0a:	80 e0       	ldi	r24, 0x00	; 0
// ~~~~~~~~~~~~~~~~~~
inline static void
PutBlankLine(uint8_t Y)
{
	uint8_t X=0;
	while(X<LCDXSz)	LCD_Buf[Y][X++] = ' ';
    bf0c:	f1 92       	st	Z+, r15
    bf0e:	8f 5f       	subi	r24, 0xFF	; 255
    bf10:	84 31       	cpi	r24, 0x14	; 20
    bf12:	e1 f7       	brne	.-8      	; 0xbf0c <MenuOut+0x376>
	}
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Y, Y);
    bf14:	0f 5f       	subi	r16, 0xFF	; 255
    bf16:	1f 4f       	sbci	r17, 0xFF	; 255
		EventFunc(&CurrMsg->Run);
		return;
	}
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
    bf18:	0e 15       	cp	r16, r14
    bf1a:	f0 f2       	brcs	.-68     	; 0xbed8 <MenuOut+0x342>
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Y, Y);
	for(; Y<LCDYSz; Y++)
    bf1c:	f3 e0       	ldi	r31, 0x03	; 3
    bf1e:	fe 15       	cp	r31, r14
    bf20:	f0 f0       	brcs	.+60     	; 0xbf5e <MenuOut+0x3c8>
    bf22:	1e 2d       	mov	r17, r14
		EventFunc(&CurrMsg->Run);
		return;
	}
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
    bf24:	fc 2c       	mov	r15, r12
    bf26:	fd 18       	sub	r15, r13
    bf28:	f1 0e       	add	r15, r17
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Y, Y);
	for(; Y<LCDYSz; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
    bf2a:	95 e1       	ldi	r25, 0x15	; 21
    bf2c:	d9 2e       	mov	r13, r25
// ~~~~~~~~~~~~~~~~~~
inline static void
PutBlankLine(uint8_t Y)
{
	uint8_t X=0;
	while(X<LCDXSz)	LCD_Buf[Y][X++] = ' ';
    bf2e:	00 e2       	ldi	r16, 0x20	; 32
    bf30:	4e 5f       	subi	r20, 0xFE	; 254
    bf32:	5f 4f       	sbci	r21, 0xFF	; 255
    bf34:	fa 01       	movw	r30, r20
    bf36:	84 91       	lpm	r24, Z+
    bf38:	42 50       	subi	r20, 0x02	; 2
    bf3a:	50 40       	sbci	r21, 0x00	; 0
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Y, Y);
	for(; Y<LCDYSz; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
    bf3c:	18 17       	cp	r17, r24
    bf3e:	08 f4       	brcc	.+2      	; 0xbf42 <MenuOut+0x3ac>
    bf40:	4b c0       	rjmp	.+150    	; 0xbfd8 <MenuOut+0x442>
    bf42:	1d 9d       	mul	r17, r13
    bf44:	f0 01       	movw	r30, r0
    bf46:	11 24       	eor	r1, r1
    bf48:	e1 5b       	subi	r30, 0xB1	; 177
    bf4a:	f9 4f       	sbci	r31, 0xF9	; 249
    bf4c:	80 e0       	ldi	r24, 0x00	; 0
// ~~~~~~~~~~~~~~~~~~
inline static void
PutBlankLine(uint8_t Y)
{
	uint8_t X=0;
	while(X<LCDXSz)	LCD_Buf[Y][X++] = ' ';
    bf4e:	01 93       	st	Z+, r16
    bf50:	8f 5f       	subi	r24, 0xFF	; 255
    bf52:	84 31       	cpi	r24, 0x14	; 20
    bf54:	e1 f7       	brne	.-8      	; 0xbf4e <MenuOut+0x3b8>
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Y, Y);
	for(; Y<LCDYSz; Y++)
    bf56:	1f 5f       	subi	r17, 0xFF	; 255
    bf58:	f3 94       	inc	r15
    bf5a:	14 30       	cpi	r17, 0x04	; 4
    bf5c:	48 f3       	brcs	.-46     	; 0xbf30 <MenuOut+0x39a>
    bf5e:	4e 5f       	subi	r20, 0xFE	; 254
    bf60:	5f 4f       	sbci	r21, 0xFF	; 255
    bf62:	fa 01       	movw	r30, r20
    bf64:	84 91       	lpm	r24, Z+
    bf66:	42 50       	subi	r20, 0x02	; 2
    bf68:	50 40       	sbci	r21, 0x00	; 0
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Dist+Y, Y);
	if(prb(&CurrPage->LineNumber)>LCDYSz || Fix<LCDYSz-1 || prp(&(GetLine+CurrLine)->OF_List))
    bf6a:	85 30       	cpi	r24, 0x05	; 5
    bf6c:	20 f4       	brcc	.+8      	; 0xbf76 <MenuOut+0x3e0>
    bf6e:	f2 e0       	ldi	r31, 0x02	; 2
    bf70:	fe 15       	cp	r31, r14
    bf72:	08 f4       	brcc	.+2      	; 0xbf76 <MenuOut+0x3e0>
    bf74:	3f c0       	rjmp	.+126    	; 0xbff4 <MenuOut+0x45e>
		LCD_Buf[CurrLCD][0] = CharCursor;
    bf76:	80 91 96 08 	lds	r24, 0x0896
    bf7a:	90 e0       	ldi	r25, 0x00	; 0
    bf7c:	9c 01       	movw	r18, r24
    bf7e:	22 0f       	add	r18, r18
    bf80:	33 1f       	adc	r19, r19
    bf82:	28 0f       	add	r18, r24
    bf84:	39 1f       	adc	r19, r25
    bf86:	f9 01       	movw	r30, r18
    bf88:	ee 0f       	add	r30, r30
    bf8a:	ff 1f       	adc	r31, r31
    bf8c:	ee 0f       	add	r30, r30
    bf8e:	ff 1f       	adc	r31, r31
    bf90:	ee 0f       	add	r30, r30
    bf92:	ff 1f       	adc	r31, r31
    bf94:	e2 1b       	sub	r30, r18
    bf96:	f3 0b       	sbc	r31, r19
    bf98:	e1 5b       	subi	r30, 0xB1	; 177
    bf9a:	f9 4f       	sbci	r31, 0xF9	; 249
    bf9c:	80 e1       	ldi	r24, 0x10	; 16
    bf9e:	80 83       	st	Z, r24
	if(++Blink>16)
    bfa0:	80 91 c6 08 	lds	r24, 0x08C6
    bfa4:	8f 5f       	subi	r24, 0xFF	; 255
    bfa6:	80 93 c6 08 	sts	0x08C6, r24
    bfaa:	81 31       	cpi	r24, 0x11	; 17
    bfac:	10 f0       	brcs	.+4      	; 0xbfb2 <MenuOut+0x41c>
		Blink=0;
    bfae:	10 92 c6 08 	sts	0x08C6, r1
	EventFunc(&CurrPage->Run);
    bfb2:	ca 01       	movw	r24, r20
    bfb4:	08 96       	adiw	r24, 0x08	; 8
    bfb6:	0e 94 5b 3b 	call	0x76b6	; 0x76b6 <EventFunc>
    bfba:	d3 ce       	rjmp	.-602    	; 0xbd62 <MenuOut+0x1cc>
	}
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Y, Y);
    bfbc:	80 2f       	mov	r24, r16
    bfbe:	60 2f       	mov	r22, r16
    bfc0:	0e 94 6f 5b 	call	0xb6de	; 0xb6de <PutLine>
    bfc4:	40 91 d1 02 	lds	r20, 0x02D1
    bfc8:	50 91 d2 02 	lds	r21, 0x02D2
    bfcc:	0f 5f       	subi	r16, 0xFF	; 255
    bfce:	1f 4f       	sbci	r17, 0xFF	; 255
		EventFunc(&CurrMsg->Run);
		return;
	}
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
    bfd0:	0e 15       	cp	r16, r14
    bfd2:	08 f4       	brcc	.+2      	; 0xbfd6 <MenuOut+0x440>
    bfd4:	81 cf       	rjmp	.-254    	; 0xbed8 <MenuOut+0x342>
    bfd6:	a2 cf       	rjmp	.-188    	; 0xbf1c <MenuOut+0x386>
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Y, Y);
	for(; Y<LCDYSz; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Dist+Y, Y);
    bfd8:	8f 2d       	mov	r24, r15
    bfda:	61 2f       	mov	r22, r17
    bfdc:	0e 94 6f 5b 	call	0xb6de	; 0xb6de <PutLine>
    bfe0:	40 91 d1 02 	lds	r20, 0x02D1
    bfe4:	50 91 d2 02 	lds	r21, 0x02D2
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Y, Y);
	for(; Y<LCDYSz; Y++)
    bfe8:	1f 5f       	subi	r17, 0xFF	; 255
    bfea:	f3 94       	inc	r15
    bfec:	14 30       	cpi	r17, 0x04	; 4
    bfee:	08 f4       	brcc	.+2      	; 0xbff2 <MenuOut+0x45c>
    bff0:	9f cf       	rjmp	.-194    	; 0xbf30 <MenuOut+0x39a>
    bff2:	b5 cf       	rjmp	.-150    	; 0xbf5e <MenuOut+0x3c8>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    bff4:	fa 01       	movw	r30, r20
    bff6:	65 91       	lpm	r22, Z+
    bff8:	74 91       	lpm	r23, Z+
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Dist+Y, Y);
	if(prb(&CurrPage->LineNumber)>LCDYSz || Fix<LCDYSz-1 || prp(&(GetLine+CurrLine)->OF_List))
    bffa:	80 91 79 07 	lds	r24, 0x0779
    bffe:	2b e1       	ldi	r18, 0x1B	; 27
    c000:	82 9f       	mul	r24, r18
    c002:	c0 01       	movw	r24, r0
    c004:	11 24       	eor	r1, r1
    c006:	68 0f       	add	r22, r24
    c008:	79 1f       	adc	r23, r25
    c00a:	69 5e       	subi	r22, 0xE9	; 233
    c00c:	7f 4f       	sbci	r23, 0xFF	; 255
    c00e:	fb 01       	movw	r30, r22
    c010:	85 91       	lpm	r24, Z+
    c012:	94 91       	lpm	r25, Z+
    c014:	89 2b       	or	r24, r25
    c016:	09 f0       	breq	.+2      	; 0xc01a <MenuOut+0x484>
    c018:	ae cf       	rjmp	.-164    	; 0xbf76 <MenuOut+0x3e0>
    c01a:	c2 cf       	rjmp	.-124    	; 0xbfa0 <MenuOut+0x40a>
		EventFunc(&CurrMsg->Run);
		return;
	}
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
    c01c:	10 e0       	ldi	r17, 0x00	; 0
    c01e:	82 cf       	rjmp	.-252    	; 0xbf24 <MenuOut+0x38e>

0000c020 <LCD_Sweep>:

// ~~~~~~~~~~~~
static void
LCD_Sweep(void)
{
	if(LCD_Rdy()) {
    c020:	0e 94 72 25 	call	0x4ae4	; 0x4ae4 <LCD_Rdy>
    c024:	88 23       	and	r24, r24
    c026:	09 f4       	brne	.+2      	; 0xc02a <LCD_Sweep+0xa>
    c028:	08 95       	ret
		MenuOut();
    c02a:	0e 94 cb 5d 	call	0xbb96	; 0xbb96 <MenuOut>
		LCD_Out();
    c02e:	0e 94 88 25 	call	0x4b10	; 0x4b10 <LCD_Out>
    c032:	08 95       	ret

0000c034 <strcpy_EE>:
	}//while
	return GSM_RxCharN;
}
// ~~~~~~~~~~~
//    EEPROM   RAM     '\0'    EEPROM
uint8_t strcpy_EE(char* str_RAM, uint8_t* str_EE){
    c034:	cf 92       	push	r12
    c036:	df 92       	push	r13
    c038:	ef 92       	push	r14
    c03a:	ff 92       	push	r15
    c03c:	1f 93       	push	r17
    c03e:	cf 93       	push	r28
    c040:	df 93       	push	r29
    c042:	6c 01       	movw	r12, r24
    c044:	7b 01       	movw	r14, r22
    c046:	10 e0       	ldi	r17, 0x00	; 0
    c048:	06 c0       	rjmp	.+12     	; 0xc056 <strcpy_EE+0x22>
	uint8_t i=0;
	while( (erb(&str_EE[i])!='\0') && (erb(&str_EE[i])!=' ') ){
    c04a:	80 32       	cpi	r24, 0x20	; 32
    c04c:	69 f0       	breq	.+26     	; 0xc068 <strcpy_EE+0x34>
		str_RAM[i] = (char)erb(&str_EE[i]);
    c04e:	cc 0d       	add	r28, r12
    c050:	dd 1d       	adc	r29, r13
    c052:	88 83       	st	Y, r24
		i++;
    c054:	1f 5f       	subi	r17, 0xFF	; 255
}
// ~~~~~~~~~~~
//    EEPROM   RAM     '\0'    EEPROM
uint8_t strcpy_EE(char* str_RAM, uint8_t* str_EE){
	uint8_t i=0;
	while( (erb(&str_EE[i])!='\0') && (erb(&str_EE[i])!=' ') ){
    c056:	c1 2f       	mov	r28, r17
    c058:	d0 e0       	ldi	r29, 0x00	; 0
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    c05a:	c7 01       	movw	r24, r14
    c05c:	8c 0f       	add	r24, r28
    c05e:	9d 1f       	adc	r25, r29
    c060:	0e 94 03 7d 	call	0xfa06	; 0xfa06 <__eerd_byte_m2560>
    c064:	88 23       	and	r24, r24
    c066:	89 f7       	brne	.-30     	; 0xc04a <strcpy_EE+0x16>
		str_RAM[i] = (char)erb(&str_EE[i]);
		i++;
	}
	return i;	
}
    c068:	81 2f       	mov	r24, r17
    c06a:	df 91       	pop	r29
    c06c:	cf 91       	pop	r28
    c06e:	1f 91       	pop	r17
    c070:	ff 90       	pop	r15
    c072:	ef 90       	pop	r14
    c074:	df 90       	pop	r13
    c076:	cf 90       	pop	r12
    c078:	08 95       	ret

0000c07a <GSM_Cycle>:
	}//switch
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
void
GSM_Cycle(void)
{
    c07a:	7f 92       	push	r7
    c07c:	8f 92       	push	r8
    c07e:	9f 92       	push	r9
    c080:	af 92       	push	r10
    c082:	bf 92       	push	r11
    c084:	cf 92       	push	r12
    c086:	df 92       	push	r13
    c088:	ef 92       	push	r14
    c08a:	ff 92       	push	r15
    c08c:	0f 93       	push	r16
    c08e:	1f 93       	push	r17
    c090:	df 93       	push	r29
    c092:	cf 93       	push	r28
    c094:	cd b7       	in	r28, 0x3d	; 61
    c096:	de b7       	in	r29, 0x3e	; 62
    c098:	64 97       	sbiw	r28, 0x14	; 20
    c09a:	0f b6       	in	r0, 0x3f	; 63
    c09c:	f8 94       	cli
    c09e:	de bf       	out	0x3e, r29	; 62
    c0a0:	0f be       	out	0x3f, r0	; 63
    c0a2:	cd bf       	out	0x3d, r28	; 61
	switch(GSM_Control){
    c0a4:	80 91 80 07 	lds	r24, 0x0780
    c0a8:	88 23       	and	r24, r24
    c0aa:	d9 f4       	brne	.+54     	; 0xc0e2 <GSM_Cycle+0x68>
uint8_t counter=0;

// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Auto(){

	switch(GSM_State){
    c0ac:	80 91 ac 06 	lds	r24, 0x06AC
    c0b0:	e8 2f       	mov	r30, r24
    c0b2:	f0 e0       	ldi	r31, 0x00	; 0
    c0b4:	e3 34       	cpi	r30, 0x43	; 67
    c0b6:	f1 05       	cpc	r31, r1
    c0b8:	50 f1       	brcs	.+84     	; 0xc10e <GSM_Cycle+0x94>
			break;	
		case GSM_CNTL_CONFIG:
			GSM_Config();
			break;								
	}
}
    c0ba:	64 96       	adiw	r28, 0x14	; 20
    c0bc:	0f b6       	in	r0, 0x3f	; 63
    c0be:	f8 94       	cli
    c0c0:	de bf       	out	0x3e, r29	; 62
    c0c2:	0f be       	out	0x3f, r0	; 63
    c0c4:	cd bf       	out	0x3d, r28	; 61
    c0c6:	cf 91       	pop	r28
    c0c8:	df 91       	pop	r29
    c0ca:	1f 91       	pop	r17
    c0cc:	0f 91       	pop	r16
    c0ce:	ff 90       	pop	r15
    c0d0:	ef 90       	pop	r14
    c0d2:	df 90       	pop	r13
    c0d4:	cf 90       	pop	r12
    c0d6:	bf 90       	pop	r11
    c0d8:	af 90       	pop	r10
    c0da:	9f 90       	pop	r9
    c0dc:	8f 90       	pop	r8
    c0de:	7f 90       	pop	r7
    c0e0:	08 95       	ret
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
void
GSM_Cycle(void)
{
	switch(GSM_Control){
    c0e2:	82 30       	cpi	r24, 0x02	; 2
    c0e4:	51 f7       	brne	.-44     	; 0xc0ba <GSM_Cycle+0x40>
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Manual(){}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Config(){
	switch(GSM_State){
    c0e6:	80 91 ac 06 	lds	r24, 0x06AC
    c0ea:	84 30       	cpi	r24, 0x04	; 4
    c0ec:	09 f4       	brne	.+2      	; 0xc0f0 <GSM_Cycle+0x76>
    c0ee:	54 c6       	rjmp	.+3240   	; 0xcd98 <GSM_Cycle+0xd1e>
    c0f0:	85 30       	cpi	r24, 0x05	; 5
    c0f2:	a8 f0       	brcs	.+42     	; 0xc11e <GSM_Cycle+0xa4>
    c0f4:	86 30       	cpi	r24, 0x06	; 6
    c0f6:	09 f4       	brne	.+2      	; 0xc0fa <GSM_Cycle+0x80>
    c0f8:	2d c6       	rjmp	.+3162   	; 0xcd54 <GSM_Cycle+0xcda>
    c0fa:	86 30       	cpi	r24, 0x06	; 6
    c0fc:	30 f1       	brcs	.+76     	; 0xc14a <GSM_Cycle+0xd0>
    c0fe:	87 30       	cpi	r24, 0x07	; 7
    c100:	09 f4       	brne	.+2      	; 0xc104 <GSM_Cycle+0x8a>
    c102:	1b c6       	rjmp	.+3126   	; 0xcd3a <GSM_Cycle+0xcc0>
    c104:	88 30       	cpi	r24, 0x08	; 8
    c106:	c9 f2       	breq	.-78     	; 0xc0ba <GSM_Cycle+0x40>
			if(Timer16Stopp(TD_GSM)) GSM_State++;
			break;
		case GSM_FINISH:			
			break;
		default:
			GSM_State = GSM_CFG_START;
    c108:	10 92 ac 06 	sts	0x06AC, r1
    c10c:	d6 cf       	rjmp	.-84     	; 0xc0ba <GSM_Cycle+0x40>
uint8_t counter=0;

// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Auto(){

	switch(GSM_State){
    c10e:	e4 50       	subi	r30, 0x04	; 4
    c110:	ff 4f       	sbci	r31, 0xFF	; 255
    c112:	ee 0f       	add	r30, r30
    c114:	ff 1f       	adc	r31, r31
    c116:	05 90       	lpm	r0, Z+
    c118:	f4 91       	lpm	r31, Z+
    c11a:	e0 2d       	mov	r30, r0
    c11c:	19 94       	eijmp
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Manual(){}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Config(){
	switch(GSM_State){
    c11e:	81 30       	cpi	r24, 0x01	; 1
    c120:	09 f4       	brne	.+2      	; 0xc124 <GSM_Cycle+0xaa>
    c122:	f9 c5       	rjmp	.+3058   	; 0xcd16 <GSM_Cycle+0xc9c>
    c124:	81 30       	cpi	r24, 0x01	; 1
    c126:	e8 f0       	brcs	.+58     	; 0xc162 <GSM_Cycle+0xe8>
    c128:	82 30       	cpi	r24, 0x02	; 2
    c12a:	09 f4       	brne	.+2      	; 0xc12e <GSM_Cycle+0xb4>
    c12c:	27 c6       	rjmp	.+3150   	; 0xcd7c <GSM_Cycle+0xd02>
    c12e:	83 30       	cpi	r24, 0x03	; 3
    c130:	59 f7       	brne	.-42     	; 0xc108 <GSM_Cycle+0x8e>
			break;
		case GSM_CFG_WAIT_AT_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_CFG_SEND_AT)) GSM_State++;
			break;
		case GSM_CFG_SEND_IPR:
			GSM_Execute_Command(AT_IPR9600, 100); GSM_State++;
    c132:	89 e3       	ldi	r24, 0x39	; 57
    c134:	94 e0       	ldi	r25, 0x04	; 4
    c136:	64 e6       	ldi	r22, 0x64	; 100
    c138:	70 e0       	ldi	r23, 0x00	; 0
    c13a:	0e 94 df 49 	call	0x93be	; 0x93be <GSM_Execute_Command>
    c13e:	80 91 ac 06 	lds	r24, 0x06AC
    c142:	8f 5f       	subi	r24, 0xFF	; 255
    c144:	80 93 ac 06 	sts	0x06AC, r24
    c148:	b8 cf       	rjmp	.-144    	; 0xc0ba <GSM_Cycle+0x40>
				StartTimer16(TD_GSM,200);
				GSM_State++;
			}
			break;
		case GSM_CFG_SEND_ATW:
			GSM_Execute_Command(AT_W, 100); GSM_State++;
    c14a:	85 e4       	ldi	r24, 0x45	; 69
    c14c:	94 e0       	ldi	r25, 0x04	; 4
    c14e:	64 e6       	ldi	r22, 0x64	; 100
    c150:	70 e0       	ldi	r23, 0x00	; 0
    c152:	0e 94 df 49 	call	0x93be	; 0x93be <GSM_Execute_Command>
    c156:	80 91 ac 06 	lds	r24, 0x06AC
    c15a:	8f 5f       	subi	r24, 0xFF	; 255
    c15c:	80 93 ac 06 	sts	0x06AC, r24
    c160:	ac cf       	rjmp	.-168    	; 0xc0ba <GSM_Cycle+0x40>
inline static void GSM_Manual(){}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Config(){
	switch(GSM_State){
		case GSM_CFG_START:
			StartTimer16(TD_GSM,200);
    c162:	80 91 e0 04 	lds	r24, 0x04E0
    c166:	68 ec       	ldi	r22, 0xC8	; 200
    c168:	70 e0       	ldi	r23, 0x00	; 0
    c16a:	0e 94 05 1a 	call	0x340a	; 0x340a <StartTimer16>
		cli();
		PORTL|=(1<<PL5);
		sei();
	}
	void GSM_PWRCNTRL_ON(void){
		cli();
    c16e:	f8 94       	cli
		PORTL &= ~(1<<PL5);
    c170:	80 91 0b 01 	lds	r24, 0x010B
    c174:	8f 7d       	andi	r24, 0xDF	; 223
    c176:	80 93 0b 01 	sts	0x010B, r24
		sei();
    c17a:	78 94       	sei
			GSM_PWRCNTRL_ON();
			GSM_State++;
    c17c:	80 91 ac 06 	lds	r24, 0x06AC
    c180:	8f 5f       	subi	r24, 0xFF	; 255
    c182:	80 93 ac 06 	sts	0x06AC, r24
    c186:	99 cf       	rjmp	.-206    	; 0xc0ba <GSM_Cycle+0x40>
			break;
		case GSM_SEND_CGMM:
			GSM_Execute_Command(AT_CGMM,5000*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CGMM_READ:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
    c188:	80 91 e0 04 	lds	r24, 0x04E0
    c18c:	0e 94 41 1b 	call	0x3682	; 0x3682 <Timer16Stopp>
    c190:	88 23       	and	r24, r24
    c192:	19 f0       	breq	.+6      	; 0xc19a <GSM_Cycle+0x120>
    c194:	83 e3       	ldi	r24, 0x33	; 51
    c196:	80 93 ac 06 	sts	0x06AC, r24
			if(GetStringFromFIFO()){
    c19a:	0e 94 b3 37 	call	0x6f66	; 0x6f66 <GetStringFromFIFO>
    c19e:	88 23       	and	r24, r24
    c1a0:	31 f1       	breq	.+76     	; 0xc1ee <GSM_Cycle+0x174>
				if(!strcmp_P(GSM_RxStr, GSM_SIMCOM_SIM900R)) GSM_Modem = SIMCOM_SIM900R;
    c1a2:	8f e8       	ldi	r24, 0x8F	; 143
    c1a4:	97 e0       	ldi	r25, 0x07	; 7
    c1a6:	6d e2       	ldi	r22, 0x2D	; 45
    c1a8:	73 e0       	ldi	r23, 0x03	; 3
    c1aa:	0e 94 d9 79 	call	0xf3b2	; 0xf3b2 <strcmp_P>
    c1ae:	89 2b       	or	r24, r25
    c1b0:	19 f4       	brne	.+6      	; 0xc1b8 <GSM_Cycle+0x13e>
    c1b2:	81 e0       	ldi	r24, 0x01	; 1
    c1b4:	80 93 ea 06 	sts	0x06EA, r24
				if(!strcmp_P(GSM_RxStr, GSM_SIMCOM_SIM800)) GSM_Modem = SIMCOM_SIM800;
    c1b8:	8f e8       	ldi	r24, 0x8F	; 143
    c1ba:	97 e0       	ldi	r25, 0x07	; 7
    c1bc:	6c e3       	ldi	r22, 0x3C	; 60
    c1be:	73 e0       	ldi	r23, 0x03	; 3
    c1c0:	0e 94 d9 79 	call	0xf3b2	; 0xf3b2 <strcmp_P>
    c1c4:	89 2b       	or	r24, r25
    c1c6:	19 f4       	brne	.+6      	; 0xc1ce <GSM_Cycle+0x154>
    c1c8:	82 e0       	ldi	r24, 0x02	; 2
    c1ca:	80 93 ea 06 	sts	0x06EA, r24
				if(!strcmp_P(GSM_RxStr, GSM_SIMCOM_SIM800C)) GSM_Modem = SIMCOM_SIM800;
    c1ce:	8f e8       	ldi	r24, 0x8F	; 143
    c1d0:	97 e0       	ldi	r25, 0x07	; 7
    c1d2:	6a e4       	ldi	r22, 0x4A	; 74
    c1d4:	73 e0       	ldi	r23, 0x03	; 3
    c1d6:	0e 94 d9 79 	call	0xf3b2	; 0xf3b2 <strcmp_P>
    c1da:	89 2b       	or	r24, r25
    c1dc:	11 f0       	breq	.+4      	; 0xc1e2 <GSM_Cycle+0x168>
    c1de:	0c 94 4f 69 	jmp	0xd29e	; 0xd29e <GSM_Cycle+0x1224>
    c1e2:	82 e0       	ldi	r24, 0x02	; 2
    c1e4:	80 93 ea 06 	sts	0x06EA, r24
				//Add here new model GSM-modem
				if(GSM_Modem != NOT_RECOGNIZED) GSM_State = GSM_WAIT_CALL_READY;
    c1e8:	86 e0       	ldi	r24, 0x06	; 6
    c1ea:	80 93 ac 06 	sts	0x06AC, r24
			}
		case GSM_WAIT_CFUN:
			if(GSM_Wait_Response_P(URC_CFUN, GSM_ReStart1)) GSM_State++;
    c1ee:	8d e5       	ldi	r24, 0x5D	; 93
    c1f0:	93 e0       	ldi	r25, 0x03	; 3
    c1f2:	63 e3       	ldi	r22, 0x33	; 51
    c1f4:	0e 94 84 49 	call	0x9308	; 0x9308 <GSM_Wait_Response_P>
    c1f8:	88 23       	and	r24, r24
    c1fa:	09 f4       	brne	.+2      	; 0xc1fe <GSM_Cycle+0x184>
    c1fc:	5e cf       	rjmp	.-324    	; 0xc0ba <GSM_Cycle+0x40>
    c1fe:	80 91 ac 06 	lds	r24, 0x06AC
    c202:	8f 5f       	subi	r24, 0xFF	; 255
    c204:	80 93 ac 06 	sts	0x06AC, r24
    c208:	58 cf       	rjmp	.-336    	; 0xc0ba <GSM_Cycle+0x40>
		case GSM_WAIT_R2D_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;

		case GSM_WAIT_R2D_CONNECT:
			if(GSM_Wait_Response_P(RESP_CONNECT, GSM_ReStart1)){ 				
    c20a:	86 ec       	ldi	r24, 0xC6	; 198
    c20c:	93 e0       	ldi	r25, 0x03	; 3
    c20e:	63 e3       	ldi	r22, 0x33	; 51
    c210:	0e 94 84 49 	call	0x9308	; 0x9308 <GSM_Wait_Response_P>
    c214:	88 23       	and	r24, r24
    c216:	09 f4       	brne	.+2      	; 0xc21a <GSM_Cycle+0x1a0>
    c218:	50 cf       	rjmp	.-352    	; 0xc0ba <GSM_Cycle+0x40>
				GSM_State=GSM_ProtocolMode;
    c21a:	8b e3       	ldi	r24, 0x3B	; 59
    c21c:	80 93 ac 06 	sts	0x06AC, r24
				StartTimer16(TD_timer_after_page_transfer,100);
    c220:	80 91 e8 04 	lds	r24, 0x04E8
    c224:	64 e6       	ldi	r22, 0x64	; 100
    c226:	70 e0       	ldi	r23, 0x00	; 0
    c228:	0e 94 05 1a 	call	0x340a	; 0x340a <StartTimer16>
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    c22c:	8f ef       	ldi	r24, 0xFF	; 255
    c22e:	80 93 f0 06 	sts	0x06F0, r24
	GSM_RX_FIFO_End = 255;
    c232:	80 93 4a 06 	sts	0x064A, r24
	GSM_RxCharN = 0;
    c236:	10 92 0e 0b 	sts	0x0B0E, r1
	GSM_RX_FIFOOverFlow = 0;
    c23a:	10 92 c1 08 	sts	0x08C1, r1
	GSM_RX_FIFOMax = 0;
    c23e:	10 92 c7 08 	sts	0x08C7, r1
    c242:	3b cf       	rjmp	.-394    	; 0xc0ba <GSM_Cycle+0x40>
		case GSM_WAIT_CPIN_READY:
			if(GSM_Wait_Response_P(URC_CPIN_READY, GSM_ReStart1)) GSM_State++;
			break;

		case GSM_WAIT_CALL_READY:
			if(GSM_Wait_Response_P(URC_CALL_READY, GSM_ReStart1)){
    c244:	83 e7       	ldi	r24, 0x73	; 115
    c246:	93 e0       	ldi	r25, 0x03	; 3
    c248:	63 e3       	ldi	r22, 0x33	; 51
    c24a:	0e 94 84 49 	call	0x9308	; 0x9308 <GSM_Wait_Response_P>
    c24e:	88 23       	and	r24, r24
    c250:	09 f4       	brne	.+2      	; 0xc254 <GSM_Cycle+0x1da>
    c252:	33 cf       	rjmp	.-410    	; 0xc0ba <GSM_Cycle+0x40>
				if(GSM_Modem == SIMCOM_SIM800) GSM_State = GSM_WAIT_SMS_READY;
    c254:	80 91 ea 06 	lds	r24, 0x06EA
    c258:	82 30       	cpi	r24, 0x02	; 2
    c25a:	11 f4       	brne	.+4      	; 0xc260 <GSM_Cycle+0x1e6>
    c25c:	0c 94 45 69 	jmp	0xd28a	; 0xd28a <GSM_Cycle+0x1210>
				else GSM_State = GSM_SEND_E0;
    c260:	88 e0       	ldi	r24, 0x08	; 8
    c262:	80 93 ac 06 	sts	0x06AC, r24
    c266:	29 cf       	rjmp	.-430    	; 0xc0ba <GSM_Cycle+0x40>
			GSM_State=GSM_WAIT_R2D_CONNECT;
		
			break;

		case GSM_WAIT_R2D_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    c268:	83 ec       	ldi	r24, 0xC3	; 195
    c26a:	93 e0       	ldi	r25, 0x03	; 3
    c26c:	63 e3       	ldi	r22, 0x33	; 51
    c26e:	0e 94 84 49 	call	0x9308	; 0x9308 <GSM_Wait_Response_P>
    c272:	88 23       	and	r24, r24
    c274:	09 f4       	brne	.+2      	; 0xc278 <GSM_Cycle+0x1fe>
    c276:	21 cf       	rjmp	.-446    	; 0xc0ba <GSM_Cycle+0x40>
    c278:	80 91 ac 06 	lds	r24, 0x06AC
    c27c:	8f 5f       	subi	r24, 0xFF	; 255
    c27e:	80 93 ac 06 	sts	0x06AC, r24
    c282:	1b cf       	rjmp	.-458    	; 0xc0ba <GSM_Cycle+0x40>

		case GSM_SEND_CSTT:
			GSM_Execute_Command(AT_CSTT, 300*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CSTT_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    c284:	83 ec       	ldi	r24, 0xC3	; 195
    c286:	93 e0       	ldi	r25, 0x03	; 3
    c288:	63 e3       	ldi	r22, 0x33	; 51
    c28a:	0e 94 84 49 	call	0x9308	; 0x9308 <GSM_Wait_Response_P>
    c28e:	88 23       	and	r24, r24
    c290:	09 f4       	brne	.+2      	; 0xc294 <GSM_Cycle+0x21a>
    c292:	13 cf       	rjmp	.-474    	; 0xc0ba <GSM_Cycle+0x40>
    c294:	80 91 ac 06 	lds	r24, 0x06AC
    c298:	8f 5f       	subi	r24, 0xFF	; 255
    c29a:	80 93 ac 06 	sts	0x06AC, r24
    c29e:	0d cf       	rjmp	.-486    	; 0xc0ba <GSM_Cycle+0x40>
		case GSM_WAIT_CIPTKA_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;

		case GSM_SEND_CSTT:
			GSM_Execute_Command(AT_CSTT, 300*GSM_DEBUG_DELAY); GSM_State++;
    c2a0:	8b e0       	ldi	r24, 0x0B	; 11
    c2a2:	95 e0       	ldi	r25, 0x05	; 5
    c2a4:	6c e2       	ldi	r22, 0x2C	; 44
    c2a6:	71 e0       	ldi	r23, 0x01	; 1
    c2a8:	0e 94 df 49 	call	0x93be	; 0x93be <GSM_Execute_Command>
    c2ac:	80 91 ac 06 	lds	r24, 0x06AC
    c2b0:	8f 5f       	subi	r24, 0xFF	; 255
    c2b2:	80 93 ac 06 	sts	0x06AC, r24
    c2b6:	01 cf       	rjmp	.-510    	; 0xc0ba <GSM_Cycle+0x40>

		case GSM_SEND_CIPTKA:
			GSM_Execute_Command(AT_CIPTKA, 1000*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CIPTKA_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    c2b8:	83 ec       	ldi	r24, 0xC3	; 195
    c2ba:	93 e0       	ldi	r25, 0x03	; 3
    c2bc:	63 e3       	ldi	r22, 0x33	; 51
    c2be:	0e 94 84 49 	call	0x9308	; 0x9308 <GSM_Wait_Response_P>
    c2c2:	88 23       	and	r24, r24
    c2c4:	09 f4       	brne	.+2      	; 0xc2c8 <GSM_Cycle+0x24e>
    c2c6:	f9 ce       	rjmp	.-526    	; 0xc0ba <GSM_Cycle+0x40>
    c2c8:	80 91 ac 06 	lds	r24, 0x06AC
    c2cc:	8f 5f       	subi	r24, 0xFF	; 255
    c2ce:	80 93 ac 06 	sts	0x06AC, r24
    c2d2:	f3 ce       	rjmp	.-538    	; 0xc0ba <GSM_Cycle+0x40>
			 else GSM_State=GSM_SEND_CSTT;
			 }
			break;

		case GSM_SEND_CIPTKA:
			GSM_Execute_Command(AT_CIPTKA, 1000*GSM_DEBUG_DELAY); GSM_State++;
    c2d4:	85 e2       	ldi	r24, 0x25	; 37
    c2d6:	95 e0       	ldi	r25, 0x05	; 5
    c2d8:	68 ee       	ldi	r22, 0xE8	; 232
    c2da:	73 e0       	ldi	r23, 0x03	; 3
    c2dc:	0e 94 df 49 	call	0x93be	; 0x93be <GSM_Execute_Command>
    c2e0:	80 91 ac 06 	lds	r24, 0x06AC
    c2e4:	8f 5f       	subi	r24, 0xFF	; 255
    c2e6:	80 93 ac 06 	sts	0x06AC, r24
    c2ea:	e7 ce       	rjmp	.-562    	; 0xc0ba <GSM_Cycle+0x40>
				StartTimer16(TD_GSM, 300*GSM_DEBUG_DELAY);
			}
			GSM_State++;
			break;
		case GSM_WAIT_CIPCSGP_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    c2ec:	83 ec       	ldi	r24, 0xC3	; 195
    c2ee:	93 e0       	ldi	r25, 0x03	; 3
    c2f0:	63 e3       	ldi	r22, 0x33	; 51
    c2f2:	0e 94 84 49 	call	0x9308	; 0x9308 <GSM_Wait_Response_P>
    c2f6:	88 23       	and	r24, r24
    c2f8:	09 f4       	brne	.+2      	; 0xc2fc <GSM_Cycle+0x282>
    c2fa:	df ce       	rjmp	.-578    	; 0xc0ba <GSM_Cycle+0x40>
			 if(GSM_Modem == SIMCOM_SIM800)GSM_State++;
    c2fc:	80 91 ea 06 	lds	r24, 0x06EA
    c300:	82 30       	cpi	r24, 0x02	; 2
    c302:	09 f4       	brne	.+2      	; 0xc306 <GSM_Cycle+0x28c>
    c304:	bb c7       	rjmp	.+3958   	; 0xd27c <GSM_Cycle+0x1202>
			 else GSM_State=GSM_SEND_CSTT;
    c306:	8e e1       	ldi	r24, 0x1E	; 30
    c308:	80 93 ac 06 	sts	0x06AC, r24
    c30c:	d6 ce       	rjmp	.-596    	; 0xc0ba <GSM_Cycle+0x40>
			if(GSM_Wait_Response_P(RESP_OK, GSM_SEND_CGATT)) GSM_State++;
			break;

		case GSM_SEND_CIPCSGP:
			//GSM_Execute_Command(AT_CIPCSGP, 300*GSM_DEBUG_DELAY); GSM_State++;
			if(GSM_Flag & (1<<flg_TxCStr)){
    c30e:	80 91 cf 02 	lds	r24, 0x02CF
    c312:	80 fd       	sbrc	r24, 0
    c314:	06 c7       	rjmp	.+3596   	; 0xd122 <GSM_Cycle+0x10a8>
				GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn_psw);
				sprintf(GSM_TxStr + GSMTxSz, "\"\r");	GSMTxSz = GSMTxSz+2;
				GSM_SendFirstChar();
				StartTimer16(TD_GSM, 300*GSM_DEBUG_DELAY);
			}
			GSM_State++;
    c316:	80 91 ac 06 	lds	r24, 0x06AC
    c31a:	8f 5f       	subi	r24, 0xFF	; 255
    c31c:	80 93 ac 06 	sts	0x06AC, r24
    c320:	cc ce       	rjmp	.-616    	; 0xc0ba <GSM_Cycle+0x40>
			break;
		case GSM_SEND_CGATT:
			GSM_Execute_Command(AT_CGATT, 500*GSM_DEBUG_DELAY); GSM_Temp++; GSM_State++;
			break;
		case GSM_WAIT_CGATT_OK:
			if(GSM_Temp>20) GSM_State = GSM_ReStart1;
    c322:	80 91 d2 05 	lds	r24, 0x05D2
    c326:	85 31       	cpi	r24, 0x15	; 21
    c328:	18 f0       	brcs	.+6      	; 0xc330 <GSM_Cycle+0x2b6>
    c32a:	83 e3       	ldi	r24, 0x33	; 51
    c32c:	80 93 ac 06 	sts	0x06AC, r24
			if(GSM_Wait_Response_P(RESP_OK, GSM_SEND_CGATT)) GSM_State++;
    c330:	83 ec       	ldi	r24, 0xC3	; 195
    c332:	93 e0       	ldi	r25, 0x03	; 3
    c334:	68 e1       	ldi	r22, 0x18	; 24
    c336:	0e 94 84 49 	call	0x9308	; 0x9308 <GSM_Wait_Response_P>
    c33a:	88 23       	and	r24, r24
    c33c:	09 f4       	brne	.+2      	; 0xc340 <GSM_Cycle+0x2c6>
    c33e:	bd ce       	rjmp	.-646    	; 0xc0ba <GSM_Cycle+0x40>
    c340:	80 91 ac 06 	lds	r24, 0x06AC
    c344:	8f 5f       	subi	r24, 0xFF	; 255
    c346:	80 93 ac 06 	sts	0x06AC, r24
    c34a:	b7 ce       	rjmp	.-658    	; 0xc0ba <GSM_Cycle+0x40>
				GSM_State++;
				GSM_Temp = 0;
			}
			break;
		case GSM_SEND_CGATT:
			GSM_Execute_Command(AT_CGATT, 500*GSM_DEBUG_DELAY); GSM_Temp++; GSM_State++;
    c34c:	81 ef       	ldi	r24, 0xF1	; 241
    c34e:	94 e0       	ldi	r25, 0x04	; 4
    c350:	64 ef       	ldi	r22, 0xF4	; 244
    c352:	71 e0       	ldi	r23, 0x01	; 1
    c354:	0e 94 df 49 	call	0x93be	; 0x93be <GSM_Execute_Command>
    c358:	80 91 d2 05 	lds	r24, 0x05D2
    c35c:	8f 5f       	subi	r24, 0xFF	; 255
    c35e:	80 93 d2 05 	sts	0x05D2, r24
    c362:	80 91 ac 06 	lds	r24, 0x06AC
    c366:	8f 5f       	subi	r24, 0xFF	; 255
    c368:	80 93 ac 06 	sts	0x06AC, r24
    c36c:	a6 ce       	rjmp	.-692    	; 0xc0ba <GSM_Cycle+0x40>
			}
			break;

		//------------------------
		case GSM_WAIT_1:
			GetStringFromFIFO();		//     FIFO
    c36e:	0e 94 b3 37 	call	0x6f66	; 0x6f66 <GetStringFromFIFO>
			if(Timer16Stopp(TD_GSM)){
    c372:	80 91 e0 04 	lds	r24, 0x04E0
    c376:	0e 94 41 1b 	call	0x3682	; 0x3682 <Timer16Stopp>
    c37a:	88 23       	and	r24, r24
    c37c:	09 f4       	brne	.+2      	; 0xc380 <GSM_Cycle+0x306>
    c37e:	9d ce       	rjmp	.-710    	; 0xc0ba <GSM_Cycle+0x40>
				GSM_State++;
    c380:	80 91 ac 06 	lds	r24, 0x06AC
    c384:	8f 5f       	subi	r24, 0xFF	; 255
    c386:	80 93 ac 06 	sts	0x06AC, r24
				GSM_Temp = 0;
    c38a:	10 92 d2 05 	sts	0x05D2, r1
    c38e:	95 ce       	rjmp	.-726    	; 0xc0ba <GSM_Cycle+0x40>
			if(GSM_MultiCon) GSM_Execute_Command(AT_CIPMODE_0, 100*GSM_DEBUG_DELAY);
			else GSM_Execute_Command(AT_CIPMODE_1, 100*GSM_DEBUG_DELAY);
			GSM_State++;
			break;
		case GSM_WAIT_CIPMODE_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    c390:	83 ec       	ldi	r24, 0xC3	; 195
    c392:	93 e0       	ldi	r25, 0x03	; 3
    c394:	63 e3       	ldi	r22, 0x33	; 51
    c396:	0e 94 84 49 	call	0x9308	; 0x9308 <GSM_Wait_Response_P>
    c39a:	88 23       	and	r24, r24
    c39c:	09 f4       	brne	.+2      	; 0xc3a0 <GSM_Cycle+0x326>
    c39e:	8d ce       	rjmp	.-742    	; 0xc0ba <GSM_Cycle+0x40>
				GSM_State++;
    c3a0:	80 91 ac 06 	lds	r24, 0x06AC
    c3a4:	8f 5f       	subi	r24, 0xFF	; 255
    c3a6:	80 93 ac 06 	sts	0x06AC, r24
				// between "Call Ready" and "+CMGS"; 8 sec min needs; for kyivstar vpni only
				StartTimer16(TD_GSM, 1000);
    c3aa:	80 91 e0 04 	lds	r24, 0x04E0
    c3ae:	68 ee       	ldi	r22, 0xE8	; 232
    c3b0:	73 e0       	ldi	r23, 0x03	; 3
    c3b2:	0e 94 05 1a 	call	0x340a	; 0x340a <StartTimer16>
    c3b6:	81 ce       	rjmp	.-766    	; 0xc0ba <GSM_Cycle+0x40>
				}
				else GSM_State++;
			}
			break;
		case GSM_SEND_CIPMODE:
			if(GSM_MultiCon) GSM_Execute_Command(AT_CIPMODE_0, 100*GSM_DEBUG_DELAY);
    c3b8:	80 91 21 0c 	lds	r24, 0x0C21
    c3bc:	88 23       	and	r24, r24
    c3be:	09 f4       	brne	.+2      	; 0xc3c2 <GSM_Cycle+0x348>
    c3c0:	e3 c5       	rjmp	.+3014   	; 0xcf88 <GSM_Cycle+0xf0e>
    c3c2:	8f eb       	ldi	r24, 0xBF	; 191
    c3c4:	94 e0       	ldi	r25, 0x04	; 4
    c3c6:	64 e6       	ldi	r22, 0x64	; 100
    c3c8:	70 e0       	ldi	r23, 0x00	; 0
    c3ca:	0e 94 df 49 	call	0x93be	; 0x93be <GSM_Execute_Command>
			else GSM_Execute_Command(AT_CIPMODE_1, 100*GSM_DEBUG_DELAY);
			GSM_State++;
    c3ce:	80 91 ac 06 	lds	r24, 0x06AC
    c3d2:	8f 5f       	subi	r24, 0xFF	; 255
    c3d4:	80 93 ac 06 	sts	0x06AC, r24
    c3d8:	70 ce       	rjmp	.-800    	; 0xc0ba <GSM_Cycle+0x40>
			if(GSM_MultiCon) GSM_Execute_Command(AT_CIPMUX_1, 100*GSM_DEBUG_DELAY);
			else GSM_Execute_Command(AT_CIPMUX_0, 100*GSM_DEBUG_DELAY);
			GSM_State++; 
			break;
		case GSM_WAIT_CIPMUX_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    c3da:	83 ec       	ldi	r24, 0xC3	; 195
    c3dc:	93 e0       	ldi	r25, 0x03	; 3
    c3de:	63 e3       	ldi	r22, 0x33	; 51
    c3e0:	0e 94 84 49 	call	0x9308	; 0x9308 <GSM_Wait_Response_P>
    c3e4:	88 23       	and	r24, r24
    c3e6:	09 f4       	brne	.+2      	; 0xc3ea <GSM_Cycle+0x370>
    c3e8:	68 ce       	rjmp	.-816    	; 0xc0ba <GSM_Cycle+0x40>
				if(GSM_MultiCon){
    c3ea:	80 91 21 0c 	lds	r24, 0x0C21
    c3ee:	88 23       	and	r24, r24
    c3f0:	09 f0       	breq	.+2      	; 0xc3f4 <GSM_Cycle+0x37a>
    c3f2:	39 c7       	rjmp	.+3698   	; 0xd266 <GSM_Cycle+0x11ec>
					GSM_State = GSM_WAIT_1;
					// between "Call Ready" and "+CMGS"; 8 sec min needs; for kyivstar vpni only
					StartTimer16(TD_GSM, 1000);
				}
				else GSM_State++;
    c3f4:	80 91 ac 06 	lds	r24, 0x06AC
    c3f8:	8f 5f       	subi	r24, 0xFF	; 255
    c3fa:	80 93 ac 06 	sts	0x06AC, r24
    c3fe:	5d ce       	rjmp	.-838    	; 0xc0ba <GSM_Cycle+0x40>
		case GSM_WAIT_CSMP_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State=GSM_SEND_ATD_Check_Ballance;
			break;
		//------------------------
		case GSM_SEND_CIPMUX:
			if(GSM_MultiCon) GSM_Execute_Command(AT_CIPMUX_1, 100*GSM_DEBUG_DELAY);
    c400:	80 91 21 0c 	lds	r24, 0x0C21
    c404:	88 23       	and	r24, r24
    c406:	09 f4       	brne	.+2      	; 0xc40a <GSM_Cycle+0x390>
    c408:	b8 c5       	rjmp	.+2928   	; 0xcf7a <GSM_Cycle+0xf00>
    c40a:	85 ee       	ldi	r24, 0xE5	; 229
    c40c:	94 e0       	ldi	r25, 0x04	; 4
    c40e:	64 e6       	ldi	r22, 0x64	; 100
    c410:	70 e0       	ldi	r23, 0x00	; 0
    c412:	0e 94 df 49 	call	0x93be	; 0x93be <GSM_Execute_Command>
			else GSM_Execute_Command(AT_CIPMUX_0, 100*GSM_DEBUG_DELAY);
			GSM_State++; 
    c416:	80 91 ac 06 	lds	r24, 0x06AC
    c41a:	8f 5f       	subi	r24, 0xFF	; 255
    c41c:	80 93 ac 06 	sts	0x06AC, r24
    c420:	4c ce       	rjmp	.-872    	; 0xc0ba <GSM_Cycle+0x40>
			break;
		case GSM_WAIT_CMGF_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;
		case GSM_SEND_CSMP:
			GSM_Execute_Command(AT_CSMP, 100*GSM_DEBUG_DELAY); GSM_State++;
    c422:	81 ea       	ldi	r24, 0xA1	; 161
    c424:	94 e0       	ldi	r25, 0x04	; 4
    c426:	64 e6       	ldi	r22, 0x64	; 100
    c428:	70 e0       	ldi	r23, 0x00	; 0
    c42a:	0e 94 df 49 	call	0x93be	; 0x93be <GSM_Execute_Command>
    c42e:	80 91 ac 06 	lds	r24, 0x06AC
    c432:	8f 5f       	subi	r24, 0xFF	; 255
    c434:	80 93 ac 06 	sts	0x06AC, r24
    c438:	40 ce       	rjmp	.-896    	; 0xc0ba <GSM_Cycle+0x40>
			break;
		case GSM_WAIT_CSMP_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State=GSM_SEND_ATD_Check_Ballance;
    c43a:	83 ec       	ldi	r24, 0xC3	; 195
    c43c:	93 e0       	ldi	r25, 0x03	; 3
    c43e:	63 e3       	ldi	r22, 0x33	; 51
    c440:	0e 94 84 49 	call	0x9308	; 0x9308 <GSM_Wait_Response_P>
    c444:	88 23       	and	r24, r24
    c446:	09 f4       	brne	.+2      	; 0xc44a <GSM_Cycle+0x3d0>
    c448:	38 ce       	rjmp	.-912    	; 0xc0ba <GSM_Cycle+0x40>
    c44a:	85 e3       	ldi	r24, 0x35	; 53
    c44c:	80 93 ac 06 	sts	0x06AC, r24
    c450:	34 ce       	rjmp	.-920    	; 0xc0ba <GSM_Cycle+0x40>

		case GSM_SEND_CMGF:
			GSM_Execute_Command(AT_CMGF,100*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CMGF_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    c452:	83 ec       	ldi	r24, 0xC3	; 195
    c454:	93 e0       	ldi	r25, 0x03	; 3
    c456:	63 e3       	ldi	r22, 0x33	; 51
    c458:	0e 94 84 49 	call	0x9308	; 0x9308 <GSM_Wait_Response_P>
    c45c:	88 23       	and	r24, r24
    c45e:	09 f4       	brne	.+2      	; 0xc462 <GSM_Cycle+0x3e8>
    c460:	2c ce       	rjmp	.-936    	; 0xc0ba <GSM_Cycle+0x40>
    c462:	80 91 ac 06 	lds	r24, 0x06AC
    c466:	8f 5f       	subi	r24, 0xFF	; 255
    c468:	80 93 ac 06 	sts	0x06AC, r24
    c46c:	26 ce       	rjmp	.-948    	; 0xc0ba <GSM_Cycle+0x40>
		case GSM_IDLE:
			break;


		case GSM_SEND_CMGF:
			GSM_Execute_Command(AT_CMGF,100*GSM_DEBUG_DELAY); GSM_State++;
    c46e:	87 e9       	ldi	r24, 0x97	; 151
    c470:	94 e0       	ldi	r25, 0x04	; 4
    c472:	64 e6       	ldi	r22, 0x64	; 100
    c474:	70 e0       	ldi	r23, 0x00	; 0
    c476:	0e 94 df 49 	call	0x93be	; 0x93be <GSM_Execute_Command>
    c47a:	80 91 ac 06 	lds	r24, 0x06AC
    c47e:	8f 5f       	subi	r24, 0xFF	; 255
    c480:	80 93 ac 06 	sts	0x06AC, r24
    c484:	1a ce       	rjmp	.-972    	; 0xc0ba <GSM_Cycle+0x40>
			break;
		case GSM_SEND_DDET101:
			GSM_Execute_Command(AT_DDET101,100*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_DDET101_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    c486:	83 ec       	ldi	r24, 0xC3	; 195
    c488:	93 e0       	ldi	r25, 0x03	; 3
    c48a:	63 e3       	ldi	r22, 0x33	; 51
    c48c:	0e 94 84 49 	call	0x9308	; 0x9308 <GSM_Wait_Response_P>
    c490:	88 23       	and	r24, r24
    c492:	09 f4       	brne	.+2      	; 0xc496 <GSM_Cycle+0x41c>
    c494:	12 ce       	rjmp	.-988    	; 0xc0ba <GSM_Cycle+0x40>
    c496:	80 91 ac 06 	lds	r24, 0x06AC
    c49a:	8f 5f       	subi	r24, 0xFF	; 255
    c49c:	80 93 ac 06 	sts	0x06AC, r24
    c4a0:	0c ce       	rjmp	.-1000   	; 0xc0ba <GSM_Cycle+0x40>
			break;
		case GSM_WAIT_CLCC_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;
		case GSM_SEND_DDET101:
			GSM_Execute_Command(AT_DDET101,100*GSM_DEBUG_DELAY); GSM_State++;
    c4a2:	89 e5       	ldi	r24, 0x59	; 89
    c4a4:	94 e0       	ldi	r25, 0x04	; 4
    c4a6:	64 e6       	ldi	r22, 0x64	; 100
    c4a8:	70 e0       	ldi	r23, 0x00	; 0
    c4aa:	0e 94 df 49 	call	0x93be	; 0x93be <GSM_Execute_Command>
    c4ae:	80 91 ac 06 	lds	r24, 0x06AC
    c4b2:	8f 5f       	subi	r24, 0xFF	; 255
    c4b4:	80 93 ac 06 	sts	0x06AC, r24
    c4b8:	00 ce       	rjmp	.-1024   	; 0xc0ba <GSM_Cycle+0x40>
			break;
		case GSM_SEND_CLCC1:
			GSM_Execute_Command(AT_CLCC1,100*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CLCC_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    c4ba:	83 ec       	ldi	r24, 0xC3	; 195
    c4bc:	93 e0       	ldi	r25, 0x03	; 3
    c4be:	63 e3       	ldi	r22, 0x33	; 51
    c4c0:	0e 94 84 49 	call	0x9308	; 0x9308 <GSM_Wait_Response_P>
    c4c4:	88 23       	and	r24, r24
    c4c6:	09 f4       	brne	.+2      	; 0xc4ca <GSM_Cycle+0x450>
    c4c8:	f8 cd       	rjmp	.-1040   	; 0xc0ba <GSM_Cycle+0x40>
    c4ca:	80 91 ac 06 	lds	r24, 0x06AC
    c4ce:	8f 5f       	subi	r24, 0xFF	; 255
    c4d0:	80 93 ac 06 	sts	0x06AC, r24
    c4d4:	f2 cd       	rjmp	.-1052   	; 0xc0ba <GSM_Cycle+0x40>
			break;
		case GSM_WAIT_E0_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;
		case GSM_SEND_CLCC1:
			GSM_Execute_Command(AT_CLCC1,100*GSM_DEBUG_DELAY); GSM_State++;
    c4d6:	8f e4       	ldi	r24, 0x4F	; 79
    c4d8:	94 e0       	ldi	r25, 0x04	; 4
    c4da:	64 e6       	ldi	r22, 0x64	; 100
    c4dc:	70 e0       	ldi	r23, 0x00	; 0
    c4de:	0e 94 df 49 	call	0x93be	; 0x93be <GSM_Execute_Command>
    c4e2:	80 91 ac 06 	lds	r24, 0x06AC
    c4e6:	8f 5f       	subi	r24, 0xFF	; 255
    c4e8:	80 93 ac 06 	sts	0x06AC, r24
    c4ec:	e6 cd       	rjmp	.-1076   	; 0xc0ba <GSM_Cycle+0x40>
		//------------------------
		case GSM_SEND_E0:
			GSM_Execute_Command(AT_E0,100*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_E0_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    c4ee:	83 ec       	ldi	r24, 0xC3	; 195
    c4f0:	93 e0       	ldi	r25, 0x03	; 3
    c4f2:	63 e3       	ldi	r22, 0x33	; 51
    c4f4:	0e 94 84 49 	call	0x9308	; 0x9308 <GSM_Wait_Response_P>
    c4f8:	88 23       	and	r24, r24
    c4fa:	09 f4       	brne	.+2      	; 0xc4fe <GSM_Cycle+0x484>
    c4fc:	de cd       	rjmp	.-1092   	; 0xc0ba <GSM_Cycle+0x40>
    c4fe:	80 91 ac 06 	lds	r24, 0x06AC
    c502:	8f 5f       	subi	r24, 0xFF	; 255
    c504:	80 93 ac 06 	sts	0x06AC, r24
    c508:	d8 cd       	rjmp	.-1104   	; 0xc0ba <GSM_Cycle+0x40>
		case GSM_WAIT_SMS_READY:
			if(GSM_Wait_Response_P(URC_SMS_READY, GSM_ReStart1))GSM_State++;
			break;
		//------------------------
		case GSM_SEND_E0:
			GSM_Execute_Command(AT_E0,100*GSM_DEBUG_DELAY); GSM_State++;
    c50a:	8a e4       	ldi	r24, 0x4A	; 74
    c50c:	94 e0       	ldi	r25, 0x04	; 4
    c50e:	64 e6       	ldi	r22, 0x64	; 100
    c510:	70 e0       	ldi	r23, 0x00	; 0
    c512:	0e 94 df 49 	call	0x93be	; 0x93be <GSM_Execute_Command>
    c516:	80 91 ac 06 	lds	r24, 0x06AC
    c51a:	8f 5f       	subi	r24, 0xFF	; 255
    c51c:	80 93 ac 06 	sts	0x06AC, r24
    c520:	cc cd       	rjmp	.-1128   	; 0xc0ba <GSM_Cycle+0x40>
				if(GSM_Modem == SIMCOM_SIM800) GSM_State = GSM_WAIT_SMS_READY;
				else GSM_State = GSM_SEND_E0;
			}
			break;
		case GSM_WAIT_SMS_READY:
			if(GSM_Wait_Response_P(URC_SMS_READY, GSM_ReStart1))GSM_State++;
    c522:	8e e7       	ldi	r24, 0x7E	; 126
    c524:	93 e0       	ldi	r25, 0x03	; 3
    c526:	63 e3       	ldi	r22, 0x33	; 51
    c528:	0e 94 84 49 	call	0x9308	; 0x9308 <GSM_Wait_Response_P>
    c52c:	88 23       	and	r24, r24
    c52e:	09 f4       	brne	.+2      	; 0xc532 <GSM_Cycle+0x4b8>
    c530:	c4 cd       	rjmp	.-1144   	; 0xc0ba <GSM_Cycle+0x40>
    c532:	80 91 ac 06 	lds	r24, 0x06AC
    c536:	8f 5f       	subi	r24, 0xFF	; 255
    c538:	80 93 ac 06 	sts	0x06AC, r24
    c53c:	be cd       	rjmp	.-1156   	; 0xc0ba <GSM_Cycle+0x40>

		case GSM_WAIT_RDY:
			if(GSM_Wait_Response_P(URC_RDY, GSM_ReStart1)) GSM_State++;
			break;
		case GSM_SEND_CGMM:
			GSM_Execute_Command(AT_CGMM,5000*GSM_DEBUG_DELAY); GSM_State++;
    c53e:	87 e6       	ldi	r24, 0x67	; 103
    c540:	94 e0       	ldi	r25, 0x04	; 4
    c542:	68 e8       	ldi	r22, 0x88	; 136
    c544:	73 e1       	ldi	r23, 0x13	; 19
    c546:	0e 94 df 49 	call	0x93be	; 0x93be <GSM_Execute_Command>
    c54a:	80 91 ac 06 	lds	r24, 0x06AC
    c54e:	8f 5f       	subi	r24, 0xFF	; 255
    c550:	80 93 ac 06 	sts	0x06AC, r24
    c554:	b2 cd       	rjmp	.-1180   	; 0xc0ba <GSM_Cycle+0x40>
			GSM_Modem = NOT_RECOGNIZED;
			GSM_State = GSM_WAIT_RDY;
			break;

		case GSM_WAIT_RDY:
			if(GSM_Wait_Response_P(URC_RDY, GSM_ReStart1)) GSM_State++;
    c556:	89 e5       	ldi	r24, 0x59	; 89
    c558:	93 e0       	ldi	r25, 0x03	; 3
    c55a:	63 e3       	ldi	r22, 0x33	; 51
    c55c:	0e 94 84 49 	call	0x9308	; 0x9308 <GSM_Wait_Response_P>
    c560:	88 23       	and	r24, r24
    c562:	09 f4       	brne	.+2      	; 0xc566 <GSM_Cycle+0x4ec>
    c564:	aa cd       	rjmp	.-1196   	; 0xc0ba <GSM_Cycle+0x40>
    c566:	80 91 ac 06 	lds	r24, 0x06AC
    c56a:	8f 5f       	subi	r24, 0xFF	; 255
    c56c:	80 93 ac 06 	sts	0x06AC, r24
    c570:	a4 cd       	rjmp	.-1208   	; 0xc0ba <GSM_Cycle+0x40>
inline static void GSM_Auto(){

	switch(GSM_State){

		case GSM_PowerOn:
			StartTimer16(TD_GSM,1000*GSM_DEBUG_DELAY);
    c572:	80 91 e0 04 	lds	r24, 0x04E0
    c576:	68 ee       	ldi	r22, 0xE8	; 232
    c578:	73 e0       	ldi	r23, 0x03	; 3
    c57a:	0e 94 05 1a 	call	0x340a	; 0x340a <StartTimer16>
			StartTimer32(TD_GSM_Reset, 24UL*60UL*6000);	//    24 
    c57e:	80 91 e2 04 	lds	r24, 0x04E2
    c582:	40 e0       	ldi	r20, 0x00	; 0
    c584:	56 ed       	ldi	r21, 0xD6	; 214
    c586:	63 e8       	ldi	r22, 0x83	; 131
    c588:	70 e0       	ldi	r23, 0x00	; 0
    c58a:	0e 94 44 1a 	call	0x3488	; 0x3488 <StartTimer32>
			StartTimer32(TD_1hour_resetGPRS_timer, 360000); //     
    c58e:	80 91 e4 04 	lds	r24, 0x04E4
    c592:	40 e4       	ldi	r20, 0x40	; 64
    c594:	5e e7       	ldi	r21, 0x7E	; 126
    c596:	65 e0       	ldi	r22, 0x05	; 5
    c598:	70 e0       	ldi	r23, 0x00	; 0
    c59a:	0e 94 44 1a 	call	0x3488	; 0x3488 <StartTimer32>
			StartTimer16(TD_CheckModem,6000);//      5 	
    c59e:	80 91 e5 04 	lds	r24, 0x04E5
    c5a2:	60 e7       	ldi	r22, 0x70	; 112
    c5a4:	77 e1       	ldi	r23, 0x17	; 23
    c5a6:	0e 94 05 1a 	call	0x340a	; 0x340a <StartTimer16>
		cli();
		PORTL|=(1<<PL5);
		sei();
	}
	void GSM_PWRCNTRL_ON(void){
		cli();
    c5aa:	f8 94       	cli
		PORTL &= ~(1<<PL5);
    c5ac:	80 91 0b 01 	lds	r24, 0x010B
    c5b0:	8f 7d       	andi	r24, 0xDF	; 223
    c5b2:	80 93 0b 01 	sts	0x010B, r24
		sei();
    c5b6:	78 94       	sei
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    c5b8:	8f ef       	ldi	r24, 0xFF	; 255
    c5ba:	80 93 f0 06 	sts	0x06F0, r24
	GSM_RX_FIFO_End = 255;
    c5be:	80 93 4a 06 	sts	0x064A, r24
	GSM_RxCharN = 0;
    c5c2:	10 92 0e 0b 	sts	0x0B0E, r1
	GSM_RX_FIFOOverFlow = 0;
    c5c6:	10 92 c1 08 	sts	0x08C1, r1
	GSM_RX_FIFOMax = 0;
    c5ca:	10 92 c7 08 	sts	0x08C7, r1
			StartTimer32(TD_GSM_Reset, 24UL*60UL*6000);	//    24 
			StartTimer32(TD_1hour_resetGPRS_timer, 360000); //     
			StartTimer16(TD_CheckModem,6000);//      5 	
			GSM_PWRCNTRL_ON();
			InitFIFO();
			counter=0;
    c5ce:	10 92 db 02 	sts	0x02DB, r1
			GSM_Modem = NOT_RECOGNIZED;
    c5d2:	10 92 ea 06 	sts	0x06EA, r1
			GSM_State = GSM_WAIT_RDY;
    c5d6:	81 e0       	ldi	r24, 0x01	; 1
    c5d8:	80 93 ac 06 	sts	0x06AC, r24
    c5dc:	6e cd       	rjmp	.-1316   	; 0xc0ba <GSM_Cycle+0x40>
			}
		case GSM_WAIT_CFUN:
			if(GSM_Wait_Response_P(URC_CFUN, GSM_ReStart1)) GSM_State++;
			break;
		case GSM_WAIT_CPIN_READY:
			if(GSM_Wait_Response_P(URC_CPIN_READY, GSM_ReStart1)) GSM_State++;
    c5de:	86 e6       	ldi	r24, 0x66	; 102
    c5e0:	93 e0       	ldi	r25, 0x03	; 3
    c5e2:	63 e3       	ldi	r22, 0x33	; 51
    c5e4:	0e 94 84 49 	call	0x9308	; 0x9308 <GSM_Wait_Response_P>
    c5e8:	88 23       	and	r24, r24
    c5ea:	09 f4       	brne	.+2      	; 0xc5ee <GSM_Cycle+0x574>
    c5ec:	66 cd       	rjmp	.-1332   	; 0xc0ba <GSM_Cycle+0x40>
    c5ee:	80 91 ac 06 	lds	r24, 0x06AC
    c5f2:	8f 5f       	subi	r24, 0xFF	; 255
    c5f4:	80 93 ac 06 	sts	0x06AC, r24
    c5f8:	60 cd       	rjmp	.-1344   	; 0xc0ba <GSM_Cycle+0x40>
			break;
		case GSM_ShutWait_:
			if(GSM_Wait_Response_P(RESP_SHUT_OK, GSM_ReStart1)) GSM_State++;
			break;
		case GSM_SEND_CGATT0:
			GSM_Execute_Command(AT_CGATT_0, 1000*GSM_DEBUG_DELAY); GSM_State++;
    c5fa:	83 eb       	ldi	r24, 0xB3	; 179
    c5fc:	95 e0       	ldi	r25, 0x05	; 5
    c5fe:	68 ee       	ldi	r22, 0xE8	; 232
    c600:	73 e0       	ldi	r23, 0x03	; 3
    c602:	0e 94 df 49 	call	0x93be	; 0x93be <GSM_Execute_Command>
    c606:	80 91 ac 06 	lds	r24, 0x06AC
    c60a:	8f 5f       	subi	r24, 0xFF	; 255
    c60c:	80 93 ac 06 	sts	0x06AC, r24
    c610:	54 cd       	rjmp	.-1368   	; 0xc0ba <GSM_Cycle+0x40>
		//------------------------
		case GSM_CIPSHUT_:
			GSM_Execute_Command(AT_CIPSHUT, 1000*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_ShutWait_:
			if(GSM_Wait_Response_P(RESP_SHUT_OK, GSM_ReStart1)) GSM_State++;
    c612:	8b e1       	ldi	r24, 0x1B	; 27
    c614:	94 e0       	ldi	r25, 0x04	; 4
    c616:	63 e3       	ldi	r22, 0x33	; 51
    c618:	0e 94 84 49 	call	0x9308	; 0x9308 <GSM_Wait_Response_P>
    c61c:	88 23       	and	r24, r24
    c61e:	09 f4       	brne	.+2      	; 0xc622 <GSM_Cycle+0x5a8>
    c620:	4c cd       	rjmp	.-1384   	; 0xc0ba <GSM_Cycle+0x40>
    c622:	80 91 ac 06 	lds	r24, 0x06AC
    c626:	8f 5f       	subi	r24, 0xFF	; 255
    c628:	80 93 ac 06 	sts	0x06AC, r24
    c62c:	46 cd       	rjmp	.-1396   	; 0xc0ba <GSM_Cycle+0x40>
		//------------------------


		//------------------------
		case GSM_CIPSHUT_:
			GSM_Execute_Command(AT_CIPSHUT, 1000*GSM_DEBUG_DELAY); GSM_State++;
    c62e:	88 ea       	ldi	r24, 0xA8	; 168
    c630:	95 e0       	ldi	r25, 0x05	; 5
    c632:	68 ee       	ldi	r22, 0xE8	; 232
    c634:	73 e0       	ldi	r23, 0x03	; 3
    c636:	0e 94 df 49 	call	0x93be	; 0x93be <GSM_Execute_Command>
    c63a:	80 91 ac 06 	lds	r24, 0x06AC
    c63e:	8f 5f       	subi	r24, 0xFF	; 255
    c640:	80 93 ac 06 	sts	0x06AC, r24
    c644:	3a cd       	rjmp	.-1420   	; 0xc0ba <GSM_Cycle+0x40>
			SMS_Data_Out[SMS_FlgSz_Out] = 0x1A;	// SMS Data end - char Ctrl-Z
			GSM_SendData((uint8_t *)SMS_Data_Out, SMS_FlgSz_Out+1);
			GSM_State++;
			break;		
		case GSM_WAIT_CMGS_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    c646:	83 ec       	ldi	r24, 0xC3	; 195
    c648:	93 e0       	ldi	r25, 0x03	; 3
    c64a:	63 e3       	ldi	r22, 0x33	; 51
    c64c:	0e 94 84 49 	call	0x9308	; 0x9308 <GSM_Wait_Response_P>
    c650:	88 23       	and	r24, r24
    c652:	09 f4       	brne	.+2      	; 0xc656 <GSM_Cycle+0x5dc>
    c654:	32 cd       	rjmp	.-1436   	; 0xc0ba <GSM_Cycle+0x40>
				if(++TempNum>=MaxTelephDirSz){
    c656:	80 91 d3 05 	lds	r24, 0x05D3
    c65a:	8f 5f       	subi	r24, 0xFF	; 255
    c65c:	80 93 d3 05 	sts	0x05D3, r24
    c660:	83 30       	cpi	r24, 0x03	; 3
    c662:	08 f4       	brcc	.+2      	; 0xc666 <GSM_Cycle+0x5ec>
    c664:	ef c5       	rjmp	.+3038   	; 0xd244 <GSM_Cycle+0x11ca>
					GSM_State = GSM_Return2dataMode;
    c666:	80 e4       	ldi	r24, 0x40	; 64
    c668:	80 93 ac 06 	sts	0x06AC, r24
					SMS_FlgSz_Out = 0;
    c66c:	10 92 78 07 	sts	0x0778, r1
    c670:	24 cd       	rjmp	.-1464   	; 0xc0ba <GSM_Cycle+0x40>
			break;
		case GSM_WAIT_SMS_Inv:
			if(GSM_Wait_Char('>', GSM_ReStart1)) GSM_State++;
			break;
		case GSM_SEND_SMS_DATA:
			SMS_Data_Out[SMS_FlgSz_Out] = 0x1A;	// SMS Data end - char Ctrl-Z
    c672:	60 91 78 07 	lds	r22, 0x0778
    c676:	e6 2f       	mov	r30, r22
    c678:	f0 e0       	ldi	r31, 0x00	; 0
    c67a:	e4 50       	subi	r30, 0x04	; 4
    c67c:	f9 4f       	sbci	r31, 0xF9	; 249
    c67e:	8a e1       	ldi	r24, 0x1A	; 26
    c680:	80 83       	st	Z, r24
			GSM_SendData((uint8_t *)SMS_Data_Out, SMS_FlgSz_Out+1);
    c682:	6f 5f       	subi	r22, 0xFF	; 255
    c684:	8c ef       	ldi	r24, 0xFC	; 252
    c686:	96 e0       	ldi	r25, 0x06	; 6
    c688:	0e 94 62 3f 	call	0x7ec4	; 0x7ec4 <GSM_SendData>
			GSM_State++;
    c68c:	80 91 ac 06 	lds	r24, 0x06AC
    c690:	8f 5f       	subi	r24, 0xFF	; 255
    c692:	80 93 ac 06 	sts	0x06AC, r24
    c696:	11 cd       	rjmp	.-1502   	; 0xc0ba <GSM_Cycle+0x40>
			}
			break;

		//------------------------
		case GSM_SEND_CMGS:
			if(GSM_Flag & (1<<flg_TxCStr)){			
    c698:	80 91 cf 02 	lds	r24, 0x02CF
    c69c:	80 ff       	sbrs	r24, 0
    c69e:	0d cd       	rjmp	.-1510   	; 0xc0ba <GSM_Cycle+0x40>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    c6a0:	38 ef       	ldi	r19, 0xF8	; 248
    c6a2:	e3 2e       	mov	r14, r19
    c6a4:	39 e0       	ldi	r19, 0x09	; 9
    c6a6:	f3 2e       	mov	r15, r19
    c6a8:	60 91 d3 05 	lds	r22, 0x05D3
    c6ac:	8d e0       	ldi	r24, 0x0D	; 13
    c6ae:	68 9f       	mul	r22, r24
    c6b0:	b0 01       	movw	r22, r0
    c6b2:	11 24       	eor	r1, r1
    c6b4:	6b 53       	subi	r22, 0x3B	; 59
    c6b6:	7f 4f       	sbci	r23, 0xFF	; 255
    c6b8:	c7 01       	movw	r24, r14
    c6ba:	4d e0       	ldi	r20, 0x0D	; 13
    c6bc:	50 e0       	ldi	r21, 0x00	; 0
    c6be:	0e 94 f3 7c 	call	0xf9e6	; 0xf9e6 <__eerd_block_m2560>
				erbl(GSM_TxStr, SMS_Number+TempNum, MaxTelephN);
				GSMTxSz = strlen(GSM_TxStr);
    c6c2:	f7 01       	movw	r30, r14
    c6c4:	01 90       	ld	r0, Z+
    c6c6:	00 20       	and	r0, r0
    c6c8:	e9 f7       	brne	.-6      	; 0xc6c4 <GSM_Cycle+0x64a>
    c6ca:	31 97       	sbiw	r30, 0x01	; 1
    c6cc:	ee 19       	sub	r30, r14
    c6ce:	ff 09       	sbc	r31, r15
    c6d0:	e0 93 6b 07 	sts	0x076B, r30
				uint8_t j=0;
				for(uint8_t i=0; i<GSMTxSz; i++)
    c6d4:	80 91 6b 07 	lds	r24, 0x076B
    c6d8:	88 23       	and	r24, r24
    c6da:	91 f0       	breq	.+36     	; 0xc700 <GSM_Cycle+0x686>
    c6dc:	90 e0       	ldi	r25, 0x00	; 0
    c6de:	20 e0       	ldi	r18, 0x00	; 0
					if(GSM_TxStr[i] != '0') j++;
    c6e0:	e9 2f       	mov	r30, r25
    c6e2:	f0 e0       	ldi	r31, 0x00	; 0
    c6e4:	e8 50       	subi	r30, 0x08	; 8
    c6e6:	f6 4f       	sbci	r31, 0xF6	; 246
    c6e8:	80 81       	ld	r24, Z
    c6ea:	80 33       	cpi	r24, 0x30	; 48
    c6ec:	09 f0       	breq	.+2      	; 0xc6f0 <GSM_Cycle+0x676>
    c6ee:	2f 5f       	subi	r18, 0xFF	; 255
		case GSM_SEND_CMGS:
			if(GSM_Flag & (1<<flg_TxCStr)){			
				erbl(GSM_TxStr, SMS_Number+TempNum, MaxTelephN);
				GSMTxSz = strlen(GSM_TxStr);
				uint8_t j=0;
				for(uint8_t i=0; i<GSMTxSz; i++)
    c6f0:	9f 5f       	subi	r25, 0xFF	; 255
    c6f2:	80 91 6b 07 	lds	r24, 0x076B
    c6f6:	98 17       	cp	r25, r24
    c6f8:	98 f3       	brcs	.-26     	; 0xc6e0 <GSM_Cycle+0x666>
					if(GSM_TxStr[i] != '0') j++;
				if(j){
    c6fa:	22 23       	and	r18, r18
    c6fc:	09 f0       	breq	.+2      	; 0xc700 <GSM_Cycle+0x686>
    c6fe:	ea c5       	rjmp	.+3028   	; 0xd2d4 <GSM_Cycle+0x125a>
					GSM_SendFirstChar();
					StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
					GSM_State++;
				}
				else{
					TempNum++;
    c700:	80 91 d3 05 	lds	r24, 0x05D3
    c704:	8f 5f       	subi	r24, 0xFF	; 255
    c706:	80 93 d3 05 	sts	0x05D3, r24
					if(TempNum>=MaxTelephDirSz){
    c70a:	83 30       	cpi	r24, 0x03	; 3
    c70c:	08 f4       	brcc	.+2      	; 0xc710 <GSM_Cycle+0x696>
    c70e:	d5 cc       	rjmp	.-1622   	; 0xc0ba <GSM_Cycle+0x40>
						//StartTimer16(TD_GSM,150);

						GSM_State = GSM_Return2dataMode;
    c710:	80 e4       	ldi	r24, 0x40	; 64
    c712:	80 93 ac 06 	sts	0x06AC, r24
				
						SMS_FlgSz_Out = 0;
    c716:	10 92 78 07 	sts	0x0778, r1
    c71a:	cf cc       	rjmp	.-1634   	; 0xc0ba <GSM_Cycle+0x40>
			break;

		case GSM_AnalyzeURC:			//  
			
			// 
			if( (strstr_P(GSM_RxStr, URC_CLOSED+2) != NULL) ){
    c71c:	0f e8       	ldi	r16, 0x8F	; 143
    c71e:	17 e0       	ldi	r17, 0x07	; 7
    c720:	c8 01       	movw	r24, r16
    c722:	66 ea       	ldi	r22, 0xA6	; 166
    c724:	73 e0       	ldi	r23, 0x03	; 3
    c726:	0e 94 0b 7a 	call	0xf416	; 0xf416 <strstr_P>
    c72a:	89 2b       	or	r24, r25
    c72c:	09 f4       	brne	.+2      	; 0xc730 <GSM_Cycle+0x6b6>
    c72e:	2a c6       	rjmp	.+3156   	; 0xd384 <GSM_Cycle+0x130a>
				GSM_State =GSM_ReStart1;
    c730:	83 e3       	ldi	r24, 0x33	; 51
    c732:	80 93 ac 06 	sts	0x06AC, r24
    c736:	c1 cc       	rjmp	.-1662   	; 0xc0ba <GSM_Cycle+0x40>
					}					
				}
			}
			break;
		case GSM_WAIT_SMS_Inv:
			if(GSM_Wait_Char('>', GSM_ReStart1)) GSM_State++;
    c738:	8e e3       	ldi	r24, 0x3E	; 62
    c73a:	63 e3       	ldi	r22, 0x33	; 51
    c73c:	0e 94 bb 38 	call	0x7176	; 0x7176 <GSM_Wait_Char>
    c740:	88 23       	and	r24, r24
    c742:	09 f4       	brne	.+2      	; 0xc746 <GSM_Cycle+0x6cc>
    c744:	ba cc       	rjmp	.-1676   	; 0xc0ba <GSM_Cycle+0x40>
    c746:	80 91 ac 06 	lds	r24, 0x06AC
    c74a:	8f 5f       	subi	r24, 0xFF	; 255
    c74c:	80 93 ac 06 	sts	0x06AC, r24
    c750:	b4 cc       	rjmp	.-1688   	; 0xc0ba <GSM_Cycle+0x40>
				counter=1;

			}
			#endif	

			if(GetStringFromFIFO()){
    c752:	0e 94 b3 37 	call	0x6f66	; 0x6f66 <GetStringFromFIFO>
    c756:	88 23       	and	r24, r24
    c758:	09 f4       	brne	.+2      	; 0xc75c <GSM_Cycle+0x6e2>
    c75a:	af cc       	rjmp	.-1698   	; 0xc0ba <GSM_Cycle+0x40>
				GSM_State = GSM_AnalyzeURC;
    c75c:	88 e2       	ldi	r24, 0x28	; 40
    c75e:	80 93 ac 06 	sts	0x06AC, r24
				TempNum = 0;
    c762:	10 92 d3 05 	sts	0x05D3, r1
    c766:	a9 cc       	rjmp	.-1710   	; 0xc0ba <GSM_Cycle+0x40>

		case GSM_WAIT_CIPSTART_TCP_CLIENT_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;
		case GSM_WAIT_CIPSTART_TCP_CLIENT_CONNECT:
			if(GSM_Wait_Response_P(RESP_CONNECT, GSM_ReStart1)){
    c768:	86 ec       	ldi	r24, 0xC6	; 198
    c76a:	93 e0       	ldi	r25, 0x03	; 3
    c76c:	63 e3       	ldi	r22, 0x33	; 51
    c76e:	0e 94 84 49 	call	0x9308	; 0x9308 <GSM_Wait_Response_P>
    c772:	88 23       	and	r24, r24
    c774:	09 f4       	brne	.+2      	; 0xc778 <GSM_Cycle+0x6fe>
    c776:	a1 cc       	rjmp	.-1726   	; 0xc0ba <GSM_Cycle+0x40>
				 GSM_State = GSM_WAIT_IDENTIFICATION;
    c778:	87 e2       	ldi	r24, 0x27	; 39
    c77a:	80 93 ac 06 	sts	0x06AC, r24
				 StartTimer16(TD_GSM, 1000*GSM_DEBUG_DELAY);
    c77e:	80 91 e0 04 	lds	r24, 0x04E0
    c782:	68 ee       	ldi	r22, 0xE8	; 232
    c784:	73 e0       	ldi	r23, 0x03	; 3
    c786:	0e 94 05 1a 	call	0x340a	; 0x340a <StartTimer16>
    c78a:	97 cc       	rjmp	.-1746   	; 0xc0ba <GSM_Cycle+0x40>
				}
		
			break;

		case GSM_WAIT_CIPSTART_TCP_CLIENT_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    c78c:	83 ec       	ldi	r24, 0xC3	; 195
    c78e:	93 e0       	ldi	r25, 0x03	; 3
    c790:	63 e3       	ldi	r22, 0x33	; 51
    c792:	0e 94 84 49 	call	0x9308	; 0x9308 <GSM_Wait_Response_P>
    c796:	88 23       	and	r24, r24
    c798:	09 f4       	brne	.+2      	; 0xc79c <GSM_Cycle+0x722>
    c79a:	8f cc       	rjmp	.-1762   	; 0xc0ba <GSM_Cycle+0x40>
    c79c:	80 91 ac 06 	lds	r24, 0x06AC
    c7a0:	8f 5f       	subi	r24, 0xFF	; 255
    c7a2:	80 93 ac 06 	sts	0x06AC, r24
    c7a6:	89 cc       	rjmp	.-1774   	; 0xc0ba <GSM_Cycle+0x40>
			}			
			break;
		//------------------------
		case GSM_SEND_CIPSTART_TCP_CLIENT:
	
				if(GSM_Flag & (1<<flg_TxCStr)){
    c7a8:	80 91 cf 02 	lds	r24, 0x02CF
    c7ac:	80 ff       	sbrs	r24, 0
    c7ae:	85 cc       	rjmp	.-1782   	; 0xc0ba <GSM_Cycle+0x40>
					GSMTxSz = strlen_P(AT_CIPSTART_TCP_CLIENT);
    c7b0:	4c e4       	ldi	r20, 0x4C	; 76
    c7b2:	e4 2e       	mov	r14, r20
    c7b4:	45 e0       	ldi	r20, 0x05	; 5
    c7b6:	f4 2e       	mov	r15, r20
    c7b8:	c7 01       	movw	r24, r14
    c7ba:	0e 94 e9 79 	call	0xf3d2	; 0xf3d2 <strlen_P>
    c7be:	80 93 6b 07 	sts	0x076B, r24
					sprintf_P(GSM_TxStr, AT_CIPSTART_TCP_CLIENT);
    c7c2:	00 d0       	rcall	.+0      	; 0xc7c4 <GSM_Cycle+0x74a>
    c7c4:	0f 92       	push	r0
    c7c6:	08 ef       	ldi	r16, 0xF8	; 248
    c7c8:	19 e0       	ldi	r17, 0x09	; 9
    c7ca:	ad b7       	in	r26, 0x3d	; 61
    c7cc:	be b7       	in	r27, 0x3e	; 62
    c7ce:	12 96       	adiw	r26, 0x02	; 2
    c7d0:	1c 93       	st	X, r17
    c7d2:	0e 93       	st	-X, r16
    c7d4:	11 97       	sbiw	r26, 0x01	; 1
    c7d6:	14 96       	adiw	r26, 0x04	; 4
    c7d8:	fc 92       	st	X, r15
    c7da:	ee 92       	st	-X, r14
    c7dc:	13 97       	sbiw	r26, 0x03	; 3
    c7de:	0e 94 06 7b 	call	0xf60c	; 0xf60c <sprintf_P>
					//GSM_TxStr[12] = 0x30+TempNum;
					sprintf(GSM_TxStr + GSMTxSz, "\"%u.%u.%u.%u\",\"%u\"\r",(unsigned int)erb(&TCP_ServerIP[0].IP1), (unsigned int)erb(&TCP_ServerIP[0].IP2), 
    c7e2:	b0 90 6b 07 	lds	r11, 0x076B
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    c7e6:	0f 90       	pop	r0
    c7e8:	0f 90       	pop	r0
    c7ea:	0f 90       	pop	r0
    c7ec:	0f 90       	pop	r0
    c7ee:	81 e9       	ldi	r24, 0x91	; 145
    c7f0:	90 e0       	ldi	r25, 0x00	; 0
    c7f2:	0e 94 03 7d 	call	0xfa06	; 0xfa06 <__eerd_byte_m2560>
    c7f6:	f8 2e       	mov	r15, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    c7f8:	82 e9       	ldi	r24, 0x92	; 146
    c7fa:	90 e0       	ldi	r25, 0x00	; 0
    c7fc:	0e 94 03 7d 	call	0xfa06	; 0xfa06 <__eerd_byte_m2560>
    c800:	e8 2e       	mov	r14, r24
    c802:	83 e9       	ldi	r24, 0x93	; 147
    c804:	90 e0       	ldi	r25, 0x00	; 0
    c806:	0e 94 03 7d 	call	0xfa06	; 0xfa06 <__eerd_byte_m2560>
    c80a:	d8 2e       	mov	r13, r24
    c80c:	84 e9       	ldi	r24, 0x94	; 148
    c80e:	90 e0       	ldi	r25, 0x00	; 0
    c810:	0e 94 03 7d 	call	0xfa06	; 0xfa06 <__eerd_byte_m2560>
    c814:	c8 2e       	mov	r12, r24
    c816:	89 ea       	ldi	r24, 0xA9	; 169
    c818:	90 e0       	ldi	r25, 0x00	; 0
    c81a:	0e 94 11 7d 	call	0xfa22	; 0xfa22 <__eerd_word_m2560>
    c81e:	ed b7       	in	r30, 0x3d	; 61
    c820:	fe b7       	in	r31, 0x3e	; 62
    c822:	3e 97       	sbiw	r30, 0x0e	; 14
    c824:	0f b6       	in	r0, 0x3f	; 63
    c826:	f8 94       	cli
    c828:	fe bf       	out	0x3e, r31	; 62
    c82a:	0f be       	out	0x3f, r0	; 63
    c82c:	ed bf       	out	0x3d, r30	; 61
    c82e:	31 96       	adiw	r30, 0x01	; 1
    c830:	2b 2d       	mov	r18, r11
    c832:	30 e0       	ldi	r19, 0x00	; 0
    c834:	20 0f       	add	r18, r16
    c836:	31 1f       	adc	r19, r17
    c838:	ad b7       	in	r26, 0x3d	; 61
    c83a:	be b7       	in	r27, 0x3e	; 62
    c83c:	12 96       	adiw	r26, 0x02	; 2
    c83e:	3c 93       	st	X, r19
    c840:	2e 93       	st	-X, r18
    c842:	11 97       	sbiw	r26, 0x01	; 1
    c844:	25 eb       	ldi	r18, 0xB5	; 181
    c846:	32 e0       	ldi	r19, 0x02	; 2
    c848:	33 83       	std	Z+3, r19	; 0x03
    c84a:	22 83       	std	Z+2, r18	; 0x02
    c84c:	f4 82       	std	Z+4, r15	; 0x04
    c84e:	15 82       	std	Z+5, r1	; 0x05
    c850:	e6 82       	std	Z+6, r14	; 0x06
    c852:	17 82       	std	Z+7, r1	; 0x07
    c854:	d0 86       	std	Z+8, r13	; 0x08
    c856:	11 86       	std	Z+9, r1	; 0x09
    c858:	c2 86       	std	Z+10, r12	; 0x0a
    c85a:	13 86       	std	Z+11, r1	; 0x0b
    c85c:	95 87       	std	Z+13, r25	; 0x0d
    c85e:	84 87       	std	Z+12, r24	; 0x0c
    c860:	0e 94 d5 7a 	call	0xf5aa	; 0xf5aa <sprintf>
						(unsigned int)erb(&TCP_ServerIP[0].IP3), (unsigned int)erb(&TCP_ServerIP[0].IP4), (unsigned int)erw(&TCP_ServerPort[0]));
					GSMTxSz = strlen(GSM_TxStr);
    c864:	f8 01       	movw	r30, r16
    c866:	01 90       	ld	r0, Z+
    c868:	00 20       	and	r0, r0
    c86a:	e9 f7       	brne	.-6      	; 0xc866 <GSM_Cycle+0x7ec>
    c86c:	8f 01       	movw	r16, r30
    c86e:	01 50       	subi	r16, 0x01	; 1
    c870:	10 40       	sbci	r17, 0x00	; 0
    c872:	08 5f       	subi	r16, 0xF8	; 248
    c874:	19 40       	sbci	r17, 0x09	; 9
    c876:	00 93 6b 07 	sts	0x076B, r16
					GSM_SendFirstChar();
    c87a:	2d b7       	in	r18, 0x3d	; 61
    c87c:	3e b7       	in	r19, 0x3e	; 62
    c87e:	22 5f       	subi	r18, 0xF2	; 242
    c880:	3f 4f       	sbci	r19, 0xFF	; 255
    c882:	0f b6       	in	r0, 0x3f	; 63
    c884:	f8 94       	cli
    c886:	3e bf       	out	0x3e, r19	; 62
    c888:	0f be       	out	0x3f, r0	; 63
    c88a:	2d bf       	out	0x3d, r18	; 61
    c88c:	0e 94 dd 38 	call	0x71ba	; 0x71ba <GSM_SendFirstChar>
					StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    c890:	80 91 e0 04 	lds	r24, 0x04E0
    c894:	64 ef       	ldi	r22, 0xF4	; 244
    c896:	71 e0       	ldi	r23, 0x01	; 1
    c898:	0e 94 05 1a 	call	0x340a	; 0x340a <StartTimer16>
					GSM_State++;
    c89c:	80 91 ac 06 	lds	r24, 0x06AC
    c8a0:	8f 5f       	subi	r24, 0xFF	; 255
    c8a2:	80 93 ac 06 	sts	0x06AC, r24
    c8a6:	09 cc       	rjmp	.-2030   	; 0xc0ba <GSM_Cycle+0x40>

		case GSM_SEND_CIFSR:
			GSM_Execute_Command(AT_CIFSR, 1000*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CIFSR_OK:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
    c8a8:	80 91 e0 04 	lds	r24, 0x04E0
    c8ac:	0e 94 41 1b 	call	0x3682	; 0x3682 <Timer16Stopp>
    c8b0:	88 23       	and	r24, r24
    c8b2:	19 f0       	breq	.+6      	; 0xc8ba <GSM_Cycle+0x840>
    c8b4:	83 e3       	ldi	r24, 0x33	; 51
    c8b6:	80 93 ac 06 	sts	0x06AC, r24
			if(GetStringFromFIFO()){
    c8ba:	0e 94 b3 37 	call	0x6f66	; 0x6f66 <GetStringFromFIFO>
    c8be:	88 23       	and	r24, r24
    c8c0:	09 f4       	brne	.+2      	; 0xc8c4 <GSM_Cycle+0x84a>
    c8c2:	fb cb       	rjmp	.-2058   	; 0xc0ba <GSM_Cycle+0x40>
	uint8_t IP4;
} IP_Addr;

//~~~~~~~~~~~~~~
void SetIP(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	IP->IP1 = IP1;
    c8c4:	4f ed       	ldi	r20, 0xDF	; 223
    c8c6:	58 e0       	ldi	r21, 0x08	; 8
    c8c8:	10 92 df 08 	sts	0x08DF, r1
	IP->IP2 = IP2;
    c8cc:	ba 01       	movw	r22, r20
    c8ce:	6f 5f       	subi	r22, 0xFF	; 255
    c8d0:	7f 4f       	sbci	r23, 0xFF	; 255
    c8d2:	10 92 e0 08 	sts	0x08E0, r1
	IP->IP3 = IP3;
    c8d6:	8a 01       	movw	r16, r20
    c8d8:	0e 5f       	subi	r16, 0xFE	; 254
    c8da:	1f 4f       	sbci	r17, 0xFF	; 255
    c8dc:	10 92 e1 08 	sts	0x08E1, r1
	IP->IP4 = IP4;
    c8e0:	e3 e0       	ldi	r30, 0x03	; 3
    c8e2:	ee 2e       	mov	r14, r30
    c8e4:	f1 2c       	mov	r15, r1
    c8e6:	e4 0e       	add	r14, r20
    c8e8:	f5 1e       	adc	r15, r21
    c8ea:	10 92 e2 08 	sts	0x08E2, r1
    c8ee:	20 e0       	ldi	r18, 0x00	; 0
    c8f0:	af e8       	ldi	r26, 0x8F	; 143
    c8f2:	b7 e0       	ldi	r27, 0x07	; 7
				SetIP(&GSM_MyIP,0,0,0,0);
				for(uint8_t i=0; i<strlen(GSM_RxStr); i++)
					if(!isdigit(GSM_RxStr[i])) GSM_RxStr[i] = ' ';
    c8f4:	30 e2       	ldi	r19, 0x20	; 32
			break;
		case GSM_WAIT_CIFSR_OK:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
			if(GetStringFromFIFO()){
				SetIP(&GSM_MyIP,0,0,0,0);
				for(uint8_t i=0; i<strlen(GSM_RxStr); i++)
    c8f6:	fd 01       	movw	r30, r26
    c8f8:	01 90       	ld	r0, Z+
    c8fa:	00 20       	and	r0, r0
    c8fc:	e9 f7       	brne	.-6      	; 0xc8f8 <GSM_Cycle+0x87e>
    c8fe:	31 97       	sbiw	r30, 0x01	; 1
    c900:	ef 58       	subi	r30, 0x8F	; 143
    c902:	f7 40       	sbci	r31, 0x07	; 7
    c904:	82 2f       	mov	r24, r18
    c906:	90 e0       	ldi	r25, 0x00	; 0
    c908:	8e 17       	cp	r24, r30
    c90a:	9f 07       	cpc	r25, r31
    c90c:	08 f0       	brcs	.+2      	; 0xc910 <GSM_Cycle+0x896>
    c90e:	fb c2       	rjmp	.+1526   	; 0xcf06 <GSM_Cycle+0xe8c>
					if(!isdigit(GSM_RxStr[i])) GSM_RxStr[i] = ' ';
    c910:	fc 01       	movw	r30, r24
    c912:	e1 57       	subi	r30, 0x71	; 113
    c914:	f8 4f       	sbci	r31, 0xF8	; 248
    c916:	80 81       	ld	r24, Z
    c918:	90 e0       	ldi	r25, 0x00	; 0
    c91a:	c0 97       	sbiw	r24, 0x30	; 48
    c91c:	0a 97       	sbiw	r24, 0x0a	; 10
    c91e:	08 f0       	brcs	.+2      	; 0xc922 <GSM_Cycle+0x8a8>
    c920:	30 83       	st	Z, r19
			break;
		case GSM_WAIT_CIFSR_OK:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
			if(GetStringFromFIFO()){
				SetIP(&GSM_MyIP,0,0,0,0);
				for(uint8_t i=0; i<strlen(GSM_RxStr); i++)
    c922:	2f 5f       	subi	r18, 0xFF	; 255
    c924:	e8 cf       	rjmp	.-48     	; 0xc8f6 <GSM_Cycle+0x87c>
			break;

	

		case GSM_SEND_CIFSR:
			GSM_Execute_Command(AT_CIFSR, 1000*GSM_DEBUG_DELAY); GSM_State++;
    c926:	8c e1       	ldi	r24, 0x1C	; 28
    c928:	95 e0       	ldi	r25, 0x05	; 5
    c92a:	68 ee       	ldi	r22, 0xE8	; 232
    c92c:	73 e0       	ldi	r23, 0x03	; 3
    c92e:	0e 94 df 49 	call	0x93be	; 0x93be <GSM_Execute_Command>
    c932:	80 91 ac 06 	lds	r24, 0x06AC
    c936:	8f 5f       	subi	r24, 0xFF	; 255
    c938:	80 93 ac 06 	sts	0x06AC, r24
    c93c:	be cb       	rjmp	.-2180   	; 0xc0ba <GSM_Cycle+0x40>

		case GSM_SEND_CIICR:
			GSM_Execute_Command(AT_CIICR, 12000*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CIICR_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    c93e:	83 ec       	ldi	r24, 0xC3	; 195
    c940:	93 e0       	ldi	r25, 0x03	; 3
    c942:	63 e3       	ldi	r22, 0x33	; 51
    c944:	0e 94 84 49 	call	0x9308	; 0x9308 <GSM_Wait_Response_P>
    c948:	88 23       	and	r24, r24
    c94a:	09 f4       	brne	.+2      	; 0xc94e <GSM_Cycle+0x8d4>
    c94c:	b6 cb       	rjmp	.-2196   	; 0xc0ba <GSM_Cycle+0x40>
    c94e:	80 91 ac 06 	lds	r24, 0x06AC
    c952:	8f 5f       	subi	r24, 0xFF	; 255
    c954:	80 93 ac 06 	sts	0x06AC, r24
    c958:	b0 cb       	rjmp	.-2208   	; 0xc0ba <GSM_Cycle+0x40>
		case GSM_WAIT_CSTT_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;

		case GSM_SEND_CIICR:
			GSM_Execute_Command(AT_CIICR, 12000*GSM_DEBUG_DELAY); GSM_State++;
    c95a:	83 e1       	ldi	r24, 0x13	; 19
    c95c:	95 e0       	ldi	r25, 0x05	; 5
    c95e:	60 ee       	ldi	r22, 0xE0	; 224
    c960:	7e e2       	ldi	r23, 0x2E	; 46
    c962:	0e 94 df 49 	call	0x93be	; 0x93be <GSM_Execute_Command>
    c966:	80 91 ac 06 	lds	r24, 0x06AC
    c96a:	8f 5f       	subi	r24, 0xFF	; 255
    c96c:	80 93 ac 06 	sts	0x06AC, r24
    c970:	a4 cb       	rjmp	.-2232   	; 0xc0ba <GSM_Cycle+0x40>
				GSM_Execute_Command(AT_CSQ, 500*GSM_DEBUG_DELAY); 
				InitFIFO();
				GSM_State++;
			break;
		case GSM_WAIT_CSQ:
				if(Timer16Stopp(TD_GSM)){
    c972:	80 91 e0 04 	lds	r24, 0x04E0
    c976:	0e 94 41 1b 	call	0x3682	; 0x3682 <Timer16Stopp>
    c97a:	88 23       	and	r24, r24
    c97c:	09 f4       	brne	.+2      	; 0xc980 <GSM_Cycle+0x906>
    c97e:	91 c3       	rjmp	.+1826   	; 0xd0a2 <GSM_Cycle+0x1028>
						GSM_State = GSM_ReStart1;
    c980:	83 e3       	ldi	r24, 0x33	; 51
    c982:	80 93 ac 06 	sts	0x06AC, r24
    c986:	99 cb       	rjmp	.-2254   	; 0xc0ba <GSM_Cycle+0x40>
			}	
			break;

		//------------------------   GSM-
		case GSM_SEND_CSQ:
				GSM_Execute_Command(AT_CSQ, 500*GSM_DEBUG_DELAY); 
    c988:	8e eb       	ldi	r24, 0xBE	; 190
    c98a:	95 e0       	ldi	r25, 0x05	; 5
    c98c:	64 ef       	ldi	r22, 0xF4	; 244
    c98e:	71 e0       	ldi	r23, 0x01	; 1
    c990:	0e 94 df 49 	call	0x93be	; 0x93be <GSM_Execute_Command>
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    c994:	8f ef       	ldi	r24, 0xFF	; 255
    c996:	80 93 f0 06 	sts	0x06F0, r24
	GSM_RX_FIFO_End = 255;
    c99a:	80 93 4a 06 	sts	0x064A, r24
	GSM_RxCharN = 0;
    c99e:	10 92 0e 0b 	sts	0x0B0E, r1
	GSM_RX_FIFOOverFlow = 0;
    c9a2:	10 92 c1 08 	sts	0x08C1, r1
	GSM_RX_FIFOMax = 0;
    c9a6:	10 92 c7 08 	sts	0x08C7, r1

		//------------------------   GSM-
		case GSM_SEND_CSQ:
				GSM_Execute_Command(AT_CSQ, 500*GSM_DEBUG_DELAY); 
				InitFIFO();
				GSM_State++;
    c9aa:	80 91 ac 06 	lds	r24, 0x06AC
    c9ae:	8f 5f       	subi	r24, 0xFF	; 255
    c9b0:	80 93 ac 06 	sts	0x06AC, r24
    c9b4:	82 cb       	rjmp	.-2300   	; 0xc0ba <GSM_Cycle+0x40>
			break;
		case GSM_WAIT_ATD_Check_Ballance_OK:
			if(GSM_Wait_Response_P(RESP_OK,GSM_SEND_CSQ)) GSM_State++;
			break;
		case GSM_WAIT_Ballance:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_SEND_CSQ;
    c9b6:	80 91 e0 04 	lds	r24, 0x04E0
    c9ba:	0e 94 41 1b 	call	0x3682	; 0x3682 <Timer16Stopp>
    c9be:	88 23       	and	r24, r24
    c9c0:	19 f0       	breq	.+6      	; 0xc9c8 <GSM_Cycle+0x94e>
    c9c2:	88 e3       	ldi	r24, 0x38	; 56
    c9c4:	80 93 ac 06 	sts	0x06AC, r24
			GSM_RxStr[GSM_RXSTR_SIZE-1]='\0';
    c9c8:	10 92 f2 07 	sts	0x07F2, r1
		
				GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);

				if(GSM_RxCharN >= 90){

					GSM_State = GSM_SEND_CSQ;
    c9cc:	18 e3       	ldi	r17, 0x38	; 56
			if(GSM_Wait_Response_P(RESP_OK,GSM_SEND_CSQ)) GSM_State++;
			break;
		case GSM_WAIT_Ballance:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_SEND_CSQ;
			GSM_RxStr[GSM_RXSTR_SIZE-1]='\0';
			while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    c9ce:	90 91 f0 06 	lds	r25, 0x06F0
    c9d2:	80 91 4a 06 	lds	r24, 0x064A
    c9d6:	98 17       	cp	r25, r24
    c9d8:	09 f4       	brne	.+2      	; 0xc9dc <GSM_Cycle+0x962>
    c9da:	f2 c1       	rjmp	.+996    	; 0xcdc0 <GSM_Cycle+0xd46>
				
		
				GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);
    c9dc:	8f e8       	ldi	r24, 0x8F	; 143
    c9de:	97 e0       	ldi	r25, 0x07	; 7
    c9e0:	6e e0       	ldi	r22, 0x0E	; 14
    c9e2:	7b e0       	ldi	r23, 0x0B	; 11
    c9e4:	44 e6       	ldi	r20, 0x64	; 100
    c9e6:	0e 94 49 37 	call	0x6e92	; 0x6e92 <GetByteFromFIFO>

				if(GSM_RxCharN >= 90){
    c9ea:	80 91 0e 0b 	lds	r24, 0x0B0E
    c9ee:	8a 35       	cpi	r24, 0x5A	; 90
    c9f0:	70 f3       	brcs	.-36     	; 0xc9ce <GSM_Cycle+0x954>

					GSM_State = GSM_SEND_CSQ;
    c9f2:	10 93 ac 06 	sts	0x06AC, r17
    c9f6:	eb cf       	rjmp	.-42     	; 0xc9ce <GSM_Cycle+0x954>
			}
			GSM_State++;	
			GSM_Temp = 0;
			break;
		case GSM_WAIT_ATD_Check_Ballance_OK:
			if(GSM_Wait_Response_P(RESP_OK,GSM_SEND_CSQ)) GSM_State++;
    c9f8:	83 ec       	ldi	r24, 0xC3	; 195
    c9fa:	93 e0       	ldi	r25, 0x03	; 3
    c9fc:	68 e3       	ldi	r22, 0x38	; 56
    c9fe:	0e 94 84 49 	call	0x9308	; 0x9308 <GSM_Wait_Response_P>
    ca02:	88 23       	and	r24, r24
    ca04:	09 f4       	brne	.+2      	; 0xca08 <GSM_Cycle+0x98e>
    ca06:	59 cb       	rjmp	.-2382   	; 0xc0ba <GSM_Cycle+0x40>
    ca08:	80 91 ac 06 	lds	r24, 0x06AC
    ca0c:	8f 5f       	subi	r24, 0xFF	; 255
    ca0e:	80 93 ac 06 	sts	0x06AC, r24
    ca12:	53 cb       	rjmp	.-2394   	; 0xc0ba <GSM_Cycle+0x40>
			break;
		//------------------------    


		case GSM_SEND_ATD_Check_Ballance:	
			if(GSM_Flag & (1<<flg_TxCStr)){
    ca14:	80 91 cf 02 	lds	r24, 0x02CF
    ca18:	80 ff       	sbrs	r24, 0
    ca1a:	4b c0       	rjmp	.+150    	; 0xcab2 <GSM_Cycle+0xa38>
				sprintf_P(GSM_TxStr, AT_CUSD101);	
    ca1c:	00 d0       	rcall	.+0      	; 0xca1e <GSM_Cycle+0x9a4>
    ca1e:	0f 92       	push	r0
    ca20:	88 ef       	ldi	r24, 0xF8	; 248
    ca22:	99 e0       	ldi	r25, 0x09	; 9
    ca24:	ad b7       	in	r26, 0x3d	; 61
    ca26:	be b7       	in	r27, 0x3e	; 62
    ca28:	12 96       	adiw	r26, 0x02	; 2
    ca2a:	9c 93       	st	X, r25
    ca2c:	8e 93       	st	-X, r24
    ca2e:	11 97       	sbiw	r26, 0x01	; 1
    ca30:	0b e8       	ldi	r16, 0x8B	; 139
    ca32:	14 e0       	ldi	r17, 0x04	; 4
    ca34:	14 96       	adiw	r26, 0x04	; 4
    ca36:	1c 93       	st	X, r17
    ca38:	0e 93       	st	-X, r16
    ca3a:	13 97       	sbiw	r26, 0x03	; 3
    ca3c:	0e 94 06 7b 	call	0xf60c	; 0xf60c <sprintf_P>
				GSMTxSz = strlen_P(AT_CUSD101);
    ca40:	0f 90       	pop	r0
    ca42:	0f 90       	pop	r0
    ca44:	0f 90       	pop	r0
    ca46:	0f 90       	pop	r0
    ca48:	c8 01       	movw	r24, r16
    ca4a:	0e 94 e9 79 	call	0xf3d2	; 0xf3d2 <strlen_P>
    ca4e:	80 93 6b 07 	sts	0x076B, r24
				GSMTxSz += strcpy_EE(GSM_TxStr+GSMTxSz,GPRS_checkballancerequest);
    ca52:	80 91 6b 07 	lds	r24, 0x076B
    ca56:	90 e0       	ldi	r25, 0x00	; 0
    ca58:	88 50       	subi	r24, 0x08	; 8
    ca5a:	96 4f       	sbci	r25, 0xF6	; 246
    ca5c:	61 e3       	ldi	r22, 0x31	; 49
    ca5e:	70 e0       	ldi	r23, 0x00	; 0
    ca60:	0e 94 1a 60 	call	0xc034	; 0xc034 <strcpy_EE>
    ca64:	90 91 6b 07 	lds	r25, 0x076B
    ca68:	98 0f       	add	r25, r24
    ca6a:	90 93 6b 07 	sts	0x076B, r25
				GSM_TxStr[GSMTxSz]='"';
    ca6e:	e0 91 6b 07 	lds	r30, 0x076B
    ca72:	f0 e0       	ldi	r31, 0x00	; 0
    ca74:	e8 50       	subi	r30, 0x08	; 8
    ca76:	f6 4f       	sbci	r31, 0xF6	; 246
    ca78:	82 e2       	ldi	r24, 0x22	; 34
    ca7a:	80 83       	st	Z, r24
				GSM_TxStr[GSMTxSz+1]='\r';
    ca7c:	e0 91 6b 07 	lds	r30, 0x076B
    ca80:	f0 e0       	ldi	r31, 0x00	; 0
    ca82:	e8 50       	subi	r30, 0x08	; 8
    ca84:	f6 4f       	sbci	r31, 0xF6	; 246
    ca86:	8d e0       	ldi	r24, 0x0D	; 13
    ca88:	81 83       	std	Z+1, r24	; 0x01
				GSM_TxStr[GSMTxSz+2]='\n';
    ca8a:	e0 91 6b 07 	lds	r30, 0x076B
    ca8e:	f0 e0       	ldi	r31, 0x00	; 0
    ca90:	e8 50       	subi	r30, 0x08	; 8
    ca92:	f6 4f       	sbci	r31, 0xF6	; 246
    ca94:	8a e0       	ldi	r24, 0x0A	; 10
    ca96:	82 83       	std	Z+2, r24	; 0x02
				GSMTxSz+=3;
    ca98:	80 91 6b 07 	lds	r24, 0x076B
    ca9c:	8d 5f       	subi	r24, 0xFD	; 253
    ca9e:	80 93 6b 07 	sts	0x076B, r24
				GSM_SendFirstChar();
    caa2:	0e 94 dd 38 	call	0x71ba	; 0x71ba <GSM_SendFirstChar>
				StartTimer16(TD_GSM, 1000);
    caa6:	80 91 e0 04 	lds	r24, 0x04E0
    caaa:	68 ee       	ldi	r22, 0xE8	; 232
    caac:	73 e0       	ldi	r23, 0x03	; 3
    caae:	0e 94 05 1a 	call	0x340a	; 0x340a <StartTimer16>
			}
			GSM_State++;	
    cab2:	80 91 ac 06 	lds	r24, 0x06AC
    cab6:	8f 5f       	subi	r24, 0xFF	; 255
    cab8:	80 93 ac 06 	sts	0x06AC, r24
			GSM_Temp = 0;
    cabc:	10 92 d2 05 	sts	0x05D2, r1
    cac0:	fc ca       	rjmp	.-2568   	; 0xc0ba <GSM_Cycle+0x40>
			SetIP(&GSM_ClientIP,0,0,0,0);
			GSM_Flag |=(1<<flg_TxCStr);
			GSM_State++;
			break;
		case GSM_ReStart2:
			if(Timer16Stopp(TD_GSM)){
    cac2:	80 91 e0 04 	lds	r24, 0x04E0
    cac6:	0e 94 41 1b 	call	0x3682	; 0x3682 <Timer16Stopp>
    caca:	88 23       	and	r24, r24
    cacc:	09 f4       	brne	.+2      	; 0xcad0 <GSM_Cycle+0xa56>
    cace:	f5 ca       	rjmp	.-2582   	; 0xc0ba <GSM_Cycle+0x40>
				GSM_State = GSM_PowerOn;
    cad0:	10 92 ac 06 	sts	0x06AC, r1
    cad4:	f2 ca       	rjmp	.-2588   	; 0xc0ba <GSM_Cycle+0x40>
		//------------------------

		
		//------------------------
		case GSM_ReStart1:
			GSM_ReStartN++;
    cad6:	80 91 e3 08 	lds	r24, 0x08E3
    cada:	8f 5f       	subi	r24, 0xFF	; 255
    cadc:	80 93 e3 08 	sts	0x08E3, r24
		cli();
		DDRL|=(1<<PL5);
		sei();
	}
	void GSM_PWRCNTRL_OFF(void){
		cli();
    cae0:	f8 94       	cli
		PORTL|=(1<<PL5);
    cae2:	80 91 0b 01 	lds	r24, 0x010B
    cae6:	80 62       	ori	r24, 0x20	; 32
    cae8:	80 93 0b 01 	sts	0x010B, r24
		sei();
    caec:	78 94       	sei
			GSM_PWRCNTRL_OFF();
			StartTimer16(TD_GSM,1000);
    caee:	80 91 e0 04 	lds	r24, 0x04E0
    caf2:	68 ee       	ldi	r22, 0xE8	; 232
    caf4:	73 e0       	ldi	r23, 0x03	; 3
    caf6:	0e 94 05 1a 	call	0x340a	; 0x340a <StartTimer16>
			RxBufOverFlow = 0;
    cafa:	10 92 f7 0a 	sts	0x0AF7, r1
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    cafe:	8f ef       	ldi	r24, 0xFF	; 255
    cb00:	80 93 f0 06 	sts	0x06F0, r24
	GSM_RX_FIFO_End = 255;
    cb04:	80 93 4a 06 	sts	0x064A, r24
	GSM_RxCharN = 0;
    cb08:	10 92 0e 0b 	sts	0x0B0E, r1
	GSM_RX_FIFOOverFlow = 0;
    cb0c:	10 92 c1 08 	sts	0x08C1, r1
	GSM_RX_FIFOMax = 0;
    cb10:	10 92 c7 08 	sts	0x08C7, r1
    cb14:	ef e8       	ldi	r30, 0x8F	; 143
    cb16:	f7 e0       	ldi	r31, 0x07	; 7
			RxBufOverFlow = 0;
		//	WebSession=0;
			InitFIFO();
			for(int i=0;i<GSM_RXSTR_SIZE;i++)
			{
				GSM_RxStr[i]=0;	
    cb18:	11 92       	st	Z+, r1
			GSM_PWRCNTRL_OFF();
			StartTimer16(TD_GSM,1000);
			RxBufOverFlow = 0;
		//	WebSession=0;
			InitFIFO();
			for(int i=0;i<GSM_RXSTR_SIZE;i++)
    cb1a:	27 e0       	ldi	r18, 0x07	; 7
    cb1c:	e3 3f       	cpi	r30, 0xF3	; 243
    cb1e:	f2 07       	cpc	r31, r18
    cb20:	d9 f7       	brne	.-10     	; 0xcb18 <GSM_Cycle+0xa9e>
			{
				GSM_RxStr[i]=0;	
			}
			SMS_FlgSz_Out = 0;	// ..          -  
    cb22:	10 92 78 07 	sts	0x0778, r1
			GSM_ActiveConnection = NO_CONNECTION;
    cb26:	8f ef       	ldi	r24, 0xFF	; 255
    cb28:	80 93 d0 02 	sts	0x02D0, r24
	uint8_t IP4;
} IP_Addr;

//~~~~~~~~~~~~~~
void SetIP(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	IP->IP1 = IP1;
    cb2c:	10 92 f8 0a 	sts	0x0AF8, r1
	IP->IP2 = IP2;
    cb30:	10 92 f9 0a 	sts	0x0AF9, r1
	IP->IP3 = IP3;
    cb34:	10 92 fa 0a 	sts	0x0AFA, r1
	IP->IP4 = IP4;
    cb38:	10 92 fb 0a 	sts	0x0AFB, r1
			SetIP(&GSM_ClientIP,0,0,0,0);
			GSM_Flag |=(1<<flg_TxCStr);
    cb3c:	80 91 cf 02 	lds	r24, 0x02CF
    cb40:	81 60       	ori	r24, 0x01	; 1
    cb42:	80 93 cf 02 	sts	0x02CF, r24
			GSM_State++;
    cb46:	80 91 ac 06 	lds	r24, 0x06AC
    cb4a:	8f 5f       	subi	r24, 0xFF	; 255
    cb4c:	80 93 ac 06 	sts	0x06AC, r24
    cb50:	b4 ca       	rjmp	.-2712   	; 0xc0ba <GSM_Cycle+0x40>
			break;
		case GSM_SEND_CGATT0:
			GSM_Execute_Command(AT_CGATT_0, 1000*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CGATT0_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    cb52:	83 ec       	ldi	r24, 0xC3	; 195
    cb54:	93 e0       	ldi	r25, 0x03	; 3
    cb56:	63 e3       	ldi	r22, 0x33	; 51
    cb58:	0e 94 84 49 	call	0x9308	; 0x9308 <GSM_Wait_Response_P>
    cb5c:	88 23       	and	r24, r24
    cb5e:	09 f4       	brne	.+2      	; 0xcb62 <GSM_Cycle+0xae8>
    cb60:	ac ca       	rjmp	.-2728   	; 0xc0ba <GSM_Cycle+0x40>
				StartTimer16(TD_GSM, 1000);
    cb62:	80 91 e0 04 	lds	r24, 0x04E0
    cb66:	68 ee       	ldi	r22, 0xE8	; 232
    cb68:	73 e0       	ldi	r23, 0x03	; 3
    cb6a:	0e 94 05 1a 	call	0x340a	; 0x340a <StartTimer16>
			 	GSM_State = GSM_SEND_ATD_Check_Ballance;
    cb6e:	85 e3       	ldi	r24, 0x35	; 53
    cb70:	80 93 ac 06 	sts	0x06AC, r24
    cb74:	a2 ca       	rjmp	.-2748   	; 0xc0ba <GSM_Cycle+0x40>
				GSM_State =GSM_ReStart1;
				break;
			}			
			break;
		case GSM_Swtch2CommandMode:
			StartTimer16(TD_GSM,100);	// min 1000ms before +++
    cb76:	80 91 e0 04 	lds	r24, 0x04E0
    cb7a:	64 e6       	ldi	r22, 0x64	; 100
    cb7c:	70 e0       	ldi	r23, 0x00	; 0
    cb7e:	0e 94 05 1a 	call	0x340a	; 0x340a <StartTimer16>
//IF WEB			WebClose();
			GSM_State++;
    cb82:	80 91 ac 06 	lds	r24, 0x06AC
    cb86:	8f 5f       	subi	r24, 0xFF	; 255
    cb88:	80 93 ac 06 	sts	0x06AC, r24
    cb8c:	96 ca       	rjmp	.-2772   	; 0xc0ba <GSM_Cycle+0x40>
			}
			break;

		case GSM_DataMode:
			// -----    
			if(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){	// if FIFO not empty
    cb8e:	90 91 f0 06 	lds	r25, 0x06F0
    cb92:	80 91 4a 06 	lds	r24, 0x064A
    cb96:	98 17       	cp	r25, r24
    cb98:	09 f4       	brne	.+2      	; 0xcb9c <GSM_Cycle+0xb22>
    cb9a:	76 c2       	rjmp	.+1260   	; 0xd088 <GSM_Cycle+0x100e>
    cb9c:	83 ec       	ldi	r24, 0xC3	; 195
    cb9e:	90 e0       	ldi	r25, 0x00	; 0
    cba0:	0e 94 11 7d 	call	0xfa22	; 0xfa22 <__eerd_word_m2560>
    cba4:	bc 01       	movw	r22, r24
				StartTimer16(TD_TCP_Connect, erw(&TCP_CONNECT_timeout));	//   
    cba6:	80 91 e1 04 	lds	r24, 0x04E1
    cbaa:	0e 94 05 1a 	call	0x340a	; 0x340a <StartTimer16>
    cbae:	85 ca       	rjmp	.-2806   	; 0xc0ba <GSM_Cycle+0x40>
		//------------------------

		//-----------

		case GSM_ProtocolMode:
			if( (strstr_P(GSM_RxStr, URC_CLOSED+2) != NULL) ){
    cbb0:	8f e8       	ldi	r24, 0x8F	; 143
    cbb2:	97 e0       	ldi	r25, 0x07	; 7
    cbb4:	66 ea       	ldi	r22, 0xA6	; 166
    cbb6:	73 e0       	ldi	r23, 0x03	; 3
    cbb8:	0e 94 0b 7a 	call	0xf416	; 0xf416 <strstr_P>
    cbbc:	89 2b       	or	r24, r25
    cbbe:	a9 f0       	breq	.+42     	; 0xcbea <GSM_Cycle+0xb70>
					GSM_State =GSM_ReStart1;
    cbc0:	83 e3       	ldi	r24, 0x33	; 51
    cbc2:	80 93 ac 06 	sts	0x06AC, r24
    cbc6:	79 ca       	rjmp	.-2830   	; 0xc0ba <GSM_Cycle+0x40>

			while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){	
					GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);
					if(GSM_RxCharN==2)
						{
							if(!strncmp_P(GSM_RxStr, PSTR("\r\n"), 2)) {GSM_RxCharN=0;}
    cbc8:	8f e8       	ldi	r24, 0x8F	; 143
    cbca:	97 e0       	ldi	r25, 0x07	; 7
    cbcc:	6b ea       	ldi	r22, 0xAB	; 171
    cbce:	7b e2       	ldi	r23, 0x2B	; 43
    cbd0:	42 e0       	ldi	r20, 0x02	; 2
    cbd2:	50 e0       	ldi	r21, 0x00	; 0
    cbd4:	0e 94 f2 79 	call	0xf3e4	; 0xf3e4 <strncmp_P>
    cbd8:	89 2b       	or	r24, r25
    cbda:	11 f4       	brne	.+4      	; 0xcbe0 <GSM_Cycle+0xb66>
    cbdc:	10 92 0e 0b 	sts	0x0B0E, r1
						}
					if(GSM_RxCharN >= 4){
    cbe0:	80 91 0e 0b 	lds	r24, 0x0B0E
    cbe4:	84 30       	cpi	r24, 0x04	; 4
    cbe6:	08 f0       	brcs	.+2      	; 0xcbea <GSM_Cycle+0xb70>
    cbe8:	da c1       	rjmp	.+948    	; 0xcf9e <GSM_Cycle+0xf24>
					break;
			}



			while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){	
    cbea:	90 91 f0 06 	lds	r25, 0x06F0
    cbee:	80 91 4a 06 	lds	r24, 0x064A
    cbf2:	98 17       	cp	r25, r24
    cbf4:	09 f4       	brne	.+2      	; 0xcbf8 <GSM_Cycle+0xb7e>
    cbf6:	15 c2       	rjmp	.+1066   	; 0xd022 <GSM_Cycle+0xfa8>
					GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);
    cbf8:	8f e8       	ldi	r24, 0x8F	; 143
    cbfa:	97 e0       	ldi	r25, 0x07	; 7
    cbfc:	6e e0       	ldi	r22, 0x0E	; 14
    cbfe:	7b e0       	ldi	r23, 0x0B	; 11
    cc00:	44 e6       	ldi	r20, 0x64	; 100
    cc02:	0e 94 49 37 	call	0x6e92	; 0x6e92 <GetByteFromFIFO>
					if(GSM_RxCharN==2)
    cc06:	80 91 0e 0b 	lds	r24, 0x0B0E
    cc0a:	82 30       	cpi	r24, 0x02	; 2
    cc0c:	49 f7       	brne	.-46     	; 0xcbe0 <GSM_Cycle+0xb66>
    cc0e:	dc cf       	rjmp	.-72     	; 0xcbc8 <GSM_Cycle+0xb4e>
				StartTimer16(TD_GSM,1000);	// min 500ms after +++
				GSM_State++;
			}
			break;
		case GSM_WAIT_D2C_SWITCH_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) {
    cc10:	83 ec       	ldi	r24, 0xC3	; 195
    cc12:	93 e0       	ldi	r25, 0x03	; 3
    cc14:	63 e3       	ldi	r22, 0x33	; 51
    cc16:	0e 94 84 49 	call	0x9308	; 0x9308 <GSM_Wait_Response_P>
    cc1a:	88 23       	and	r24, r24
    cc1c:	09 f4       	brne	.+2      	; 0xcc20 <GSM_Cycle+0xba6>
    cc1e:	4d ca       	rjmp	.-2918   	; 0xc0ba <GSM_Cycle+0x40>

				switch(CommandModeDestination){
    cc20:	80 91 61 07 	lds	r24, 0x0761
    cc24:	82 30       	cpi	r24, 0x02	; 2
    cc26:	09 f4       	brne	.+2      	; 0xcc2a <GSM_Cycle+0xbb0>
    cc28:	4e c3       	rjmp	.+1692   	; 0xd2c6 <GSM_Cycle+0x124c>
    cc2a:	83 30       	cpi	r24, 0x03	; 3
    cc2c:	08 f0       	brcs	.+2      	; 0xcc30 <GSM_Cycle+0xbb6>
    cc2e:	0f c3       	rjmp	.+1566   	; 0xd24e <GSM_Cycle+0x11d4>
    cc30:	81 30       	cpi	r24, 0x01	; 1
    cc32:	09 f4       	brne	.+2      	; 0xcc36 <GSM_Cycle+0xbbc>
    cc34:	43 c3       	rjmp	.+1670   	; 0xd2bc <GSM_Cycle+0x1242>
						break;
					case 5:	
						GSM_State = GSM_SEND_CSQ;
						counter=0;	
						break;
					default:GSM_State = GSM_Return2dataMode;
    cc36:	80 e4       	ldi	r24, 0x40	; 64
    cc38:	80 93 ac 06 	sts	0x06AC, r24
    cc3c:	3e ca       	rjmp	.-2948   	; 0xc0ba <GSM_Cycle+0x40>
			break;

		//----  data mode
		case GSM_Return2dataMode:

			CommandModeDestination=0;
    cc3e:	10 92 61 07 	sts	0x0761, r1
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    cc42:	8f ef       	ldi	r24, 0xFF	; 255
    cc44:	80 93 f0 06 	sts	0x06F0, r24
	GSM_RX_FIFO_End = 255;
    cc48:	80 93 4a 06 	sts	0x064A, r24
	GSM_RxCharN = 0;
    cc4c:	10 92 0e 0b 	sts	0x0B0E, r1
	GSM_RX_FIFOOverFlow = 0;
    cc50:	10 92 c1 08 	sts	0x08C1, r1
	GSM_RX_FIFOMax = 0;
    cc54:	10 92 c7 08 	sts	0x08C7, r1
    cc58:	ef e8       	ldi	r30, 0x8F	; 143
    cc5a:	f7 e0       	ldi	r31, 0x07	; 7

			CommandModeDestination=0;
			InitFIFO();
			for(int i=0;i<GSM_RXSTR_SIZE;i++)
			{
				GSM_RxStr[i]=0;	
    cc5c:	11 92       	st	Z+, r1
		//----  data mode
		case GSM_Return2dataMode:

			CommandModeDestination=0;
			InitFIFO();
			for(int i=0;i<GSM_RXSTR_SIZE;i++)
    cc5e:	b7 e0       	ldi	r27, 0x07	; 7
    cc60:	e3 3f       	cpi	r30, 0xF3	; 243
    cc62:	fb 07       	cpc	r31, r27
    cc64:	d9 f7       	brne	.-10     	; 0xcc5c <GSM_Cycle+0xbe2>
			{
				GSM_RxStr[i]=0;	
			}
			GSM_Execute_Command(ATO, 600*GSM_DEBUG_DELAY); //GSM_State++;
    cc66:	85 ec       	ldi	r24, 0xC5	; 197
    cc68:	95 e0       	ldi	r25, 0x05	; 5
    cc6a:	68 e5       	ldi	r22, 0x58	; 88
    cc6c:	72 e0       	ldi	r23, 0x02	; 2
    cc6e:	0e 94 df 49 	call	0x93be	; 0x93be <GSM_Execute_Command>
			GSM_State=GSM_WAIT_R2D_CONNECT;
    cc72:	82 e4       	ldi	r24, 0x42	; 66
    cc74:	80 93 ac 06 	sts	0x06AC, r24
    cc78:	20 ca       	rjmp	.-3008   	; 0xc0ba <GSM_Cycle+0x40>
						}
					}
				}
			break;
		case GSM_WAIT_CSQ_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) {
    cc7a:	83 ec       	ldi	r24, 0xC3	; 195
    cc7c:	93 e0       	ldi	r25, 0x03	; 3
    cc7e:	63 e3       	ldi	r22, 0x33	; 51
    cc80:	0e 94 84 49 	call	0x9308	; 0x9308 <GSM_Wait_Response_P>
    cc84:	88 23       	and	r24, r24
    cc86:	09 f4       	brne	.+2      	; 0xcc8a <GSM_Cycle+0xc10>
    cc88:	18 ca       	rjmp	.-3024   	; 0xc0ba <GSM_Cycle+0x40>
				if(CommandModeDestination==5){
    cc8a:	80 91 61 07 	lds	r24, 0x0761
    cc8e:	85 30       	cpi	r24, 0x05	; 5
    cc90:	09 f4       	brne	.+2      	; 0xcc94 <GSM_Cycle+0xc1a>
    cc92:	00 c3       	rjmp	.+1536   	; 0xd294 <GSM_Cycle+0x121a>
					GSM_State  = GSM_Return2dataMode;
				}
				else{
					GSM_State=GSM_SEND_CIPMUX;
    cc94:	83 e1       	ldi	r24, 0x13	; 19
    cc96:	80 93 ac 06 	sts	0x06AC, r24
    cc9a:	0f ca       	rjmp	.-3042   	; 0xc0ba <GSM_Cycle+0x40>
//IF WEB			WebClose();
			GSM_State++;

			break;
		case GSM_Swtch2CommandModePlus:
			if(Timer16Stopp(TD_GSM)){
    cc9c:	80 91 e0 04 	lds	r24, 0x04E0
    cca0:	0e 94 41 1b 	call	0x3682	; 0x3682 <Timer16Stopp>
    cca4:	88 23       	and	r24, r24
    cca6:	09 f4       	brne	.+2      	; 0xccaa <GSM_Cycle+0xc30>
    cca8:	08 ca       	rjmp	.-3056   	; 0xc0ba <GSM_Cycle+0x40>
    ccaa:	ef e8       	ldi	r30, 0x8F	; 143
    ccac:	f7 e0       	ldi	r31, 0x07	; 7
				for(int i=0;i<GSM_RXSTR_SIZE;i++)
				{
					GSM_RxStr[i]=0;	
    ccae:	11 92       	st	Z+, r1
			GSM_State++;

			break;
		case GSM_Swtch2CommandModePlus:
			if(Timer16Stopp(TD_GSM)){
				for(int i=0;i<GSM_RXSTR_SIZE;i++)
    ccb0:	27 e0       	ldi	r18, 0x07	; 7
    ccb2:	e3 3f       	cpi	r30, 0xF3	; 243
    ccb4:	f2 07       	cpc	r31, r18
    ccb6:	d9 f7       	brne	.-10     	; 0xccae <GSM_Cycle+0xc34>
				{
					GSM_RxStr[i]=0;	
				}
				sprintf_P(GSM_TxStr, ESC_SEQ);
    ccb8:	00 d0       	rcall	.+0      	; 0xccba <GSM_Cycle+0xc40>
    ccba:	0f 92       	push	r0
    ccbc:	08 ef       	ldi	r16, 0xF8	; 248
    ccbe:	19 e0       	ldi	r17, 0x09	; 9
    ccc0:	ad b7       	in	r26, 0x3d	; 61
    ccc2:	be b7       	in	r27, 0x3e	; 62
    ccc4:	12 96       	adiw	r26, 0x02	; 2
    ccc6:	1c 93       	st	X, r17
    ccc8:	0e 93       	st	-X, r16
    ccca:	11 97       	sbiw	r26, 0x01	; 1
    cccc:	83 e2       	ldi	r24, 0x23	; 35
    ccce:	94 e0       	ldi	r25, 0x04	; 4
    ccd0:	14 96       	adiw	r26, 0x04	; 4
    ccd2:	9c 93       	st	X, r25
    ccd4:	8e 93       	st	-X, r24
    ccd6:	13 97       	sbiw	r26, 0x03	; 3
    ccd8:	0e 94 06 7b 	call	0xf60c	; 0xf60c <sprintf_P>
				GSMTxSz = strlen(GSM_TxStr);
    ccdc:	f8 01       	movw	r30, r16
    ccde:	01 90       	ld	r0, Z+
    cce0:	00 20       	and	r0, r0
    cce2:	e9 f7       	brne	.-6      	; 0xccde <GSM_Cycle+0xc64>
    cce4:	8f 01       	movw	r16, r30
    cce6:	01 50       	subi	r16, 0x01	; 1
    cce8:	10 40       	sbci	r17, 0x00	; 0
    ccea:	08 5f       	subi	r16, 0xF8	; 248
    ccec:	19 40       	sbci	r17, 0x09	; 9
    ccee:	00 93 6b 07 	sts	0x076B, r16
				GSM_SendFirstChar();
    ccf2:	0f 90       	pop	r0
    ccf4:	0f 90       	pop	r0
    ccf6:	0f 90       	pop	r0
    ccf8:	0f 90       	pop	r0
    ccfa:	0e 94 dd 38 	call	0x71ba	; 0x71ba <GSM_SendFirstChar>
				StartTimer16(TD_GSM,1000);	// min 500ms after +++
    ccfe:	80 91 e0 04 	lds	r24, 0x04E0
    cd02:	68 ee       	ldi	r22, 0xE8	; 232
    cd04:	73 e0       	ldi	r23, 0x03	; 3
    cd06:	0e 94 05 1a 	call	0x340a	; 0x340a <StartTimer16>
				GSM_State++;
    cd0a:	80 91 ac 06 	lds	r24, 0x06AC
    cd0e:	8f 5f       	subi	r24, 0xFF	; 255
    cd10:	80 93 ac 06 	sts	0x06AC, r24
    cd14:	d2 c9       	rjmp	.-3164   	; 0xc0ba <GSM_Cycle+0x40>
			StartTimer16(TD_GSM,200);
			GSM_PWRCNTRL_ON();
			GSM_State++;
			break;
		case GSM_CFG_SEND_AT:
			if(Timer16Stopp(TD_GSM)) GSM_Execute_Command(AT_AT, 100); GSM_State++;
    cd16:	80 91 e0 04 	lds	r24, 0x04E0
    cd1a:	0e 94 41 1b 	call	0x3682	; 0x3682 <Timer16Stopp>
    cd1e:	88 23       	and	r24, r24
    cd20:	31 f0       	breq	.+12     	; 0xcd2e <GSM_Cycle+0xcb4>
    cd22:	86 e3       	ldi	r24, 0x36	; 54
    cd24:	94 e0       	ldi	r25, 0x04	; 4
    cd26:	64 e6       	ldi	r22, 0x64	; 100
    cd28:	70 e0       	ldi	r23, 0x00	; 0
    cd2a:	0e 94 df 49 	call	0x93be	; 0x93be <GSM_Execute_Command>
    cd2e:	80 91 ac 06 	lds	r24, 0x06AC
    cd32:	8f 5f       	subi	r24, 0xFF	; 255
    cd34:	80 93 ac 06 	sts	0x06AC, r24
    cd38:	c0 c9       	rjmp	.-3200   	; 0xc0ba <GSM_Cycle+0x40>
				StartTimer16(TD_GSM,200);
				GSM_State++;
			}
			break;
		case GSM_SAVE_IPR:
			if(Timer16Stopp(TD_GSM)) GSM_State++;
    cd3a:	80 91 e0 04 	lds	r24, 0x04E0
    cd3e:	0e 94 41 1b 	call	0x3682	; 0x3682 <Timer16Stopp>
    cd42:	88 23       	and	r24, r24
    cd44:	09 f4       	brne	.+2      	; 0xcd48 <GSM_Cycle+0xcce>
    cd46:	b9 c9       	rjmp	.-3214   	; 0xc0ba <GSM_Cycle+0x40>
    cd48:	80 91 ac 06 	lds	r24, 0x06AC
    cd4c:	8f 5f       	subi	r24, 0xFF	; 255
    cd4e:	80 93 ac 06 	sts	0x06AC, r24
    cd52:	b3 c9       	rjmp	.-3226   	; 0xc0ba <GSM_Cycle+0x40>
			break;
		case GSM_CFG_SEND_ATW:
			GSM_Execute_Command(AT_W, 100); GSM_State++;
			break;
		case GSM_CFG_WAIT_ATW_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_CFG_SEND_AT)){
    cd54:	83 ec       	ldi	r24, 0xC3	; 195
    cd56:	93 e0       	ldi	r25, 0x03	; 3
    cd58:	61 e0       	ldi	r22, 0x01	; 1
    cd5a:	0e 94 84 49 	call	0x9308	; 0x9308 <GSM_Wait_Response_P>
    cd5e:	88 23       	and	r24, r24
    cd60:	09 f4       	brne	.+2      	; 0xcd64 <GSM_Cycle+0xcea>
    cd62:	ab c9       	rjmp	.-3242   	; 0xc0ba <GSM_Cycle+0x40>
				StartTimer16(TD_GSM,200);
    cd64:	80 91 e0 04 	lds	r24, 0x04E0
    cd68:	68 ec       	ldi	r22, 0xC8	; 200
    cd6a:	70 e0       	ldi	r23, 0x00	; 0
    cd6c:	0e 94 05 1a 	call	0x340a	; 0x340a <StartTimer16>
				GSM_State++;
    cd70:	80 91 ac 06 	lds	r24, 0x06AC
    cd74:	8f 5f       	subi	r24, 0xFF	; 255
    cd76:	80 93 ac 06 	sts	0x06AC, r24
    cd7a:	9f c9       	rjmp	.-3266   	; 0xc0ba <GSM_Cycle+0x40>
			break;
		case GSM_CFG_SEND_AT:
			if(Timer16Stopp(TD_GSM)) GSM_Execute_Command(AT_AT, 100); GSM_State++;
			break;
		case GSM_CFG_WAIT_AT_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_CFG_SEND_AT)) GSM_State++;
    cd7c:	83 ec       	ldi	r24, 0xC3	; 195
    cd7e:	93 e0       	ldi	r25, 0x03	; 3
    cd80:	61 e0       	ldi	r22, 0x01	; 1
    cd82:	0e 94 84 49 	call	0x9308	; 0x9308 <GSM_Wait_Response_P>
    cd86:	88 23       	and	r24, r24
    cd88:	09 f4       	brne	.+2      	; 0xcd8c <GSM_Cycle+0xd12>
    cd8a:	97 c9       	rjmp	.-3282   	; 0xc0ba <GSM_Cycle+0x40>
    cd8c:	80 91 ac 06 	lds	r24, 0x06AC
    cd90:	8f 5f       	subi	r24, 0xFF	; 255
    cd92:	80 93 ac 06 	sts	0x06AC, r24
    cd96:	91 c9       	rjmp	.-3294   	; 0xc0ba <GSM_Cycle+0x40>
			break;
		case GSM_CFG_SEND_IPR:
			GSM_Execute_Command(AT_IPR9600, 100); GSM_State++;
			break;
		case GSM_CFG_WAIT_IPR_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_CFG_SEND_AT)){
    cd98:	83 ec       	ldi	r24, 0xC3	; 195
    cd9a:	93 e0       	ldi	r25, 0x03	; 3
    cd9c:	61 e0       	ldi	r22, 0x01	; 1
    cd9e:	0e 94 84 49 	call	0x9308	; 0x9308 <GSM_Wait_Response_P>
    cda2:	88 23       	and	r24, r24
    cda4:	09 f4       	brne	.+2      	; 0xcda8 <GSM_Cycle+0xd2e>
    cda6:	89 c9       	rjmp	.-3310   	; 0xc0ba <GSM_Cycle+0x40>
				StartTimer16(TD_GSM,200);
    cda8:	80 91 e0 04 	lds	r24, 0x04E0
    cdac:	68 ec       	ldi	r22, 0xC8	; 200
    cdae:	70 e0       	ldi	r23, 0x00	; 0
    cdb0:	0e 94 05 1a 	call	0x340a	; 0x340a <StartTimer16>
				GSM_State++;
    cdb4:	80 91 ac 06 	lds	r24, 0x06AC
    cdb8:	8f 5f       	subi	r24, 0xFF	; 255
    cdba:	80 93 ac 06 	sts	0x06AC, r24
    cdbe:	7d c9       	rjmp	.-3334   	; 0xc0ba <GSM_Cycle+0x40>
			if(GSM_Wait_Response_P(RESP_OK,GSM_SEND_CSQ)) GSM_State++;
			break;
		case GSM_WAIT_Ballance:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_SEND_CSQ;
			GSM_RxStr[GSM_RXSTR_SIZE-1]='\0';
			while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    cdc0:	00 e0       	ldi	r16, 0x00	; 0
    cdc2:	6e 01       	movw	r12, r28
    cdc4:	08 94       	sec
    cdc6:	c1 1c       	adc	r12, r1
    cdc8:	d1 1c       	adc	r13, r1
    cdca:	09 c0       	rjmp	.+18     	; 0xcdde <GSM_Cycle+0xd64>
				}

			}//while
			char buf[20];
			uint8_t i=0;
			while( (erb(&GPRS_currency[i])!='\0') && ((erb(&GPRS_currency[i])!=' ')||i==0) ){
    cdcc:	80 32       	cpi	r24, 0x20	; 32
    cdce:	11 f4       	brne	.+4      	; 0xcdd4 <GSM_Cycle+0xd5a>
    cdd0:	00 23       	and	r16, r16
    cdd2:	71 f4       	brne	.+28     	; 0xcdf0 <GSM_Cycle+0xd76>
				buf[i] = (char)erb(&GPRS_currency[i]);
    cdd4:	ec 0c       	add	r14, r12
    cdd6:	fd 1c       	adc	r15, r13
    cdd8:	f7 01       	movw	r30, r14
    cdda:	80 83       	st	Z, r24
				i++;
    cddc:	0f 5f       	subi	r16, 0xFF	; 255
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    cdde:	e0 2e       	mov	r14, r16
    cde0:	ff 24       	eor	r15, r15
    cde2:	c7 01       	movw	r24, r14
    cde4:	8b 5b       	subi	r24, 0xBB	; 187
    cde6:	9f 4f       	sbci	r25, 0xFF	; 255
    cde8:	0e 94 03 7d 	call	0xfa06	; 0xfa06 <__eerd_byte_m2560>
				}

			}//while
			char buf[20];
			uint8_t i=0;
			while( (erb(&GPRS_currency[i])!='\0') && ((erb(&GPRS_currency[i])!=' ')||i==0) ){
    cdec:	88 23       	and	r24, r24
    cdee:	71 f7       	brne	.-36     	; 0xcdcc <GSM_Cycle+0xd52>
				buf[i] = (char)erb(&GPRS_currency[i]);
				i++;
			}
			buf[i]='\0';
    cdf0:	ec 0c       	add	r14, r12
    cdf2:	fd 1c       	adc	r15, r13
    cdf4:	d7 01       	movw	r26, r14
    cdf6:	1c 92       	st	X, r1
			char *istr=strstr(GSM_RxStr, buf);
    cdf8:	8f e8       	ldi	r24, 0x8F	; 143
    cdfa:	97 e0       	ldi	r25, 0x07	; 7
    cdfc:	b6 01       	movw	r22, r12
    cdfe:	0e 94 4d 7a 	call	0xf49a	; 0xf49a <strstr>
			if(istr)
    ce02:	00 97       	sbiw	r24, 0x00	; 0
    ce04:	09 f4       	brne	.+2      	; 0xce08 <GSM_Cycle+0xd8e>
    ce06:	59 c9       	rjmp	.-3406   	; 0xc0ba <GSM_Cycle+0x40>
			{
					Ballance=*(istr-1)-0x30;
    ce08:	fc 01       	movw	r30, r24
    ce0a:	82 91       	ld	r24, -Z
    ce0c:	90 e0       	ldi	r25, 0x00	; 0
    ce0e:	c0 97       	sbiw	r24, 0x30	; 48
    ce10:	aa 27       	eor	r26, r26
    ce12:	97 fd       	sbrc	r25, 7
    ce14:	a0 95       	com	r26
    ce16:	ba 2f       	mov	r27, r26
    ce18:	80 93 b1 06 	sts	0x06B1, r24
    ce1c:	90 93 b2 06 	sts	0x06B2, r25
    ce20:	a0 93 b3 06 	sts	0x06B3, r26
    ce24:	b0 93 b4 06 	sts	0x06B4, r27
					Ballance+=(*(istr-2)-0x30)*10;
    ce28:	22 91       	ld	r18, -Z
    ce2a:	8f 01       	movw	r16, r30
    ce2c:	4a e0       	ldi	r20, 0x0A	; 10
    ce2e:	24 9f       	mul	r18, r20
    ce30:	90 01       	movw	r18, r0
    ce32:	11 24       	eor	r1, r1
    ce34:	20 5e       	subi	r18, 0xE0	; 224
    ce36:	31 40       	sbci	r19, 0x01	; 1
    ce38:	49 01       	movw	r8, r18
    ce3a:	aa 24       	eor	r10, r10
    ce3c:	97 fc       	sbrc	r9, 7
    ce3e:	a0 94       	com	r10
    ce40:	ba 2c       	mov	r11, r10
    ce42:	88 0e       	add	r8, r24
    ce44:	99 1e       	adc	r9, r25
    ce46:	aa 1e       	adc	r10, r26
    ce48:	bb 1e       	adc	r11, r27
    ce4a:	80 92 b1 06 	sts	0x06B1, r8
    ce4e:	90 92 b2 06 	sts	0x06B2, r9
    ce52:	a0 92 b3 06 	sts	0x06B3, r10
    ce56:	b0 92 b4 06 	sts	0x06B4, r11
					uint8_t charnum=4;
					uint32_t razr=100;
					while((*(istr-charnum)>=0x30)&&(*(istr-charnum)<=0x39)){
    ce5a:	02 50       	subi	r16, 0x02	; 2
    ce5c:	10 40       	sbci	r17, 0x00	; 0
    ce5e:	d8 01       	movw	r26, r16
    ce60:	6c 91       	ld	r22, X
    ce62:	0c 5f       	subi	r16, 0xFC	; 252
    ce64:	1f 4f       	sbci	r17, 0xFF	; 255
    ce66:	86 2f       	mov	r24, r22
    ce68:	80 53       	subi	r24, 0x30	; 48
    ce6a:	8a 30       	cpi	r24, 0x0A	; 10
    ce6c:	88 f5       	brcc	.+98     	; 0xced0 <GSM_Cycle+0xe56>
    ce6e:	24 e0       	ldi	r18, 0x04	; 4
    ce70:	72 2e       	mov	r7, r18
    ce72:	94 e6       	ldi	r25, 0x64	; 100
    ce74:	c9 2e       	mov	r12, r25
    ce76:	d1 2c       	mov	r13, r1
    ce78:	e1 2c       	mov	r14, r1
    ce7a:	f1 2c       	mov	r15, r1
						Ballance+=(*(istr-charnum)-0x30)*razr;
    ce7c:	70 e0       	ldi	r23, 0x00	; 0
    ce7e:	60 53       	subi	r22, 0x30	; 48
    ce80:	70 40       	sbci	r23, 0x00	; 0
    ce82:	88 27       	eor	r24, r24
    ce84:	77 fd       	sbrc	r23, 7
    ce86:	80 95       	com	r24
    ce88:	98 2f       	mov	r25, r24
    ce8a:	a7 01       	movw	r20, r14
    ce8c:	96 01       	movw	r18, r12
    ce8e:	0e 94 3f 7d 	call	0xfa7e	; 0xfa7e <__mulsi3>
    ce92:	86 0e       	add	r8, r22
    ce94:	97 1e       	adc	r9, r23
    ce96:	a8 1e       	adc	r10, r24
    ce98:	b9 1e       	adc	r11, r25
    ce9a:	80 92 b1 06 	sts	0x06B1, r8
    ce9e:	90 92 b2 06 	sts	0x06B2, r9
    cea2:	a0 92 b3 06 	sts	0x06B3, r10
    cea6:	b0 92 b4 06 	sts	0x06B4, r11
						razr*=10;
    ceaa:	c7 01       	movw	r24, r14
    ceac:	b6 01       	movw	r22, r12
    ceae:	2a e0       	ldi	r18, 0x0A	; 10
    ceb0:	30 e0       	ldi	r19, 0x00	; 0
    ceb2:	40 e0       	ldi	r20, 0x00	; 0
    ceb4:	50 e0       	ldi	r21, 0x00	; 0
    ceb6:	0e 94 3f 7d 	call	0xfa7e	; 0xfa7e <__mulsi3>
    ceba:	6b 01       	movw	r12, r22
    cebc:	7c 01       	movw	r14, r24
						charnum++;	
    cebe:	73 94       	inc	r7
			{
					Ballance=*(istr-1)-0x30;
					Ballance+=(*(istr-2)-0x30)*10;
					uint8_t charnum=4;
					uint32_t razr=100;
					while((*(istr-charnum)>=0x30)&&(*(istr-charnum)<=0x39)){
    cec0:	f8 01       	movw	r30, r16
    cec2:	e7 19       	sub	r30, r7
    cec4:	f1 09       	sbc	r31, r1
    cec6:	60 81       	ld	r22, Z
    cec8:	86 2f       	mov	r24, r22
    ceca:	80 53       	subi	r24, 0x30	; 48
    cecc:	8a 30       	cpi	r24, 0x0A	; 10
    cece:	b0 f2       	brcs	.-84     	; 0xce7c <GSM_Cycle+0xe02>
						Ballance+=(*(istr-charnum)-0x30)*razr;
						razr*=10;
						charnum++;	
					}
					if(*(istr-charnum)==0x2D)
    ced0:	6d 32       	cpi	r22, 0x2D	; 45
    ced2:	09 f0       	breq	.+2      	; 0xced6 <GSM_Cycle+0xe5c>
    ced4:	f2 c8       	rjmp	.-3612   	; 0xc0ba <GSM_Cycle+0x40>
					{
						Ballance*=-1;
    ced6:	80 91 b1 06 	lds	r24, 0x06B1
    ceda:	90 91 b2 06 	lds	r25, 0x06B2
    cede:	a0 91 b3 06 	lds	r26, 0x06B3
    cee2:	b0 91 b4 06 	lds	r27, 0x06B4
    cee6:	b0 95       	com	r27
    cee8:	a0 95       	com	r26
    ceea:	90 95       	com	r25
    ceec:	81 95       	neg	r24
    ceee:	9f 4f       	sbci	r25, 0xFF	; 255
    cef0:	af 4f       	sbci	r26, 0xFF	; 255
    cef2:	bf 4f       	sbci	r27, 0xFF	; 255
    cef4:	80 93 b1 06 	sts	0x06B1, r24
    cef8:	90 93 b2 06 	sts	0x06B2, r25
    cefc:	a0 93 b3 06 	sts	0x06B3, r26
    cf00:	b0 93 b4 06 	sts	0x06B4, r27
    cf04:	da c8       	rjmp	.-3660   	; 0xc0ba <GSM_Cycle+0x40>
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
			if(GetStringFromFIFO()){
				SetIP(&GSM_MyIP,0,0,0,0);
				for(uint8_t i=0; i<strlen(GSM_RxStr); i++)
					if(!isdigit(GSM_RxStr[i])) GSM_RxStr[i] = ' ';
				sscanf_P(GSM_RxStr,PSTR("%hhu %hhu %hhu %hhu"), (unsigned char*)&GSM_MyIP.IP1, (unsigned char*)&GSM_MyIP.IP2, (unsigned char*)&GSM_MyIP.IP3, (unsigned char*)&GSM_MyIP.IP4);
    cf06:	ed b7       	in	r30, 0x3d	; 61
    cf08:	fe b7       	in	r31, 0x3e	; 62
    cf0a:	3c 97       	sbiw	r30, 0x0c	; 12
    cf0c:	0f b6       	in	r0, 0x3f	; 63
    cf0e:	f8 94       	cli
    cf10:	fe bf       	out	0x3e, r31	; 62
    cf12:	0f be       	out	0x3f, r0	; 63
    cf14:	ed bf       	out	0x3d, r30	; 61
    cf16:	31 96       	adiw	r30, 0x01	; 1
    cf18:	8f e8       	ldi	r24, 0x8F	; 143
    cf1a:	97 e0       	ldi	r25, 0x07	; 7
    cf1c:	ad b7       	in	r26, 0x3d	; 61
    cf1e:	be b7       	in	r27, 0x3e	; 62
    cf20:	12 96       	adiw	r26, 0x02	; 2
    cf22:	9c 93       	st	X, r25
    cf24:	8e 93       	st	-X, r24
    cf26:	11 97       	sbiw	r26, 0x01	; 1
    cf28:	8e ec       	ldi	r24, 0xCE	; 206
    cf2a:	9b e2       	ldi	r25, 0x2B	; 43
    cf2c:	93 83       	std	Z+3, r25	; 0x03
    cf2e:	82 83       	std	Z+2, r24	; 0x02
    cf30:	55 83       	std	Z+5, r21	; 0x05
    cf32:	44 83       	std	Z+4, r20	; 0x04
    cf34:	77 83       	std	Z+7, r23	; 0x07
    cf36:	66 83       	std	Z+6, r22	; 0x06
    cf38:	11 87       	std	Z+9, r17	; 0x09
    cf3a:	00 87       	std	Z+8, r16	; 0x08
    cf3c:	f3 86       	std	Z+11, r15	; 0x0b
    cf3e:	e2 86       	std	Z+10, r14	; 0x0a
    cf40:	0e 94 5a 7b 	call	0xf6b4	; 0xf6b4 <sscanf_P>
}
uint8_t IP_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	if((IP->IP1 == IP1) && (IP->IP2 == IP2) && (IP->IP3 == IP3) && (IP->IP4 == IP4)) return 1;
    cf44:	ed b7       	in	r30, 0x3d	; 61
    cf46:	fe b7       	in	r31, 0x3e	; 62
    cf48:	3c 96       	adiw	r30, 0x0c	; 12
    cf4a:	0f b6       	in	r0, 0x3f	; 63
    cf4c:	f8 94       	cli
    cf4e:	fe bf       	out	0x3e, r31	; 62
    cf50:	0f be       	out	0x3f, r0	; 63
    cf52:	ed bf       	out	0x3d, r30	; 61
    cf54:	80 91 df 08 	lds	r24, 0x08DF
    cf58:	88 23       	and	r24, r24
    cf5a:	e9 f4       	brne	.+58     	; 0xcf96 <GSM_Cycle+0xf1c>
    cf5c:	80 91 e0 08 	lds	r24, 0x08E0
    cf60:	88 23       	and	r24, r24
    cf62:	c9 f4       	brne	.+50     	; 0xcf96 <GSM_Cycle+0xf1c>
    cf64:	80 91 e1 08 	lds	r24, 0x08E1
    cf68:	88 23       	and	r24, r24
    cf6a:	a9 f4       	brne	.+42     	; 0xcf96 <GSM_Cycle+0xf1c>
    cf6c:	80 91 e2 08 	lds	r24, 0x08E2
    cf70:	88 23       	and	r24, r24
    cf72:	89 f4       	brne	.+34     	; 0xcf96 <GSM_Cycle+0xf1c>
				if(!IP_compare_Const(&GSM_MyIP,0,0,0,0)){
				  GSM_State = GSM_SEND_CIPSTART_TCP_CLIENT;
				}
				TempNum=0;	//
    cf74:	10 92 d3 05 	sts	0x05D3, r1
    cf78:	a0 c8       	rjmp	.-3776   	; 0xc0ba <GSM_Cycle+0x40>
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State=GSM_SEND_ATD_Check_Ballance;
			break;
		//------------------------
		case GSM_SEND_CIPMUX:
			if(GSM_MultiCon) GSM_Execute_Command(AT_CIPMUX_1, 100*GSM_DEBUG_DELAY);
			else GSM_Execute_Command(AT_CIPMUX_0, 100*GSM_DEBUG_DELAY);
    cf7a:	89 ed       	ldi	r24, 0xD9	; 217
    cf7c:	94 e0       	ldi	r25, 0x04	; 4
    cf7e:	64 e6       	ldi	r22, 0x64	; 100
    cf80:	70 e0       	ldi	r23, 0x00	; 0
    cf82:	0e 94 df 49 	call	0x93be	; 0x93be <GSM_Execute_Command>
    cf86:	47 ca       	rjmp	.-2930   	; 0xc416 <GSM_Cycle+0x39c>
				else GSM_State++;
			}
			break;
		case GSM_SEND_CIPMODE:
			if(GSM_MultiCon) GSM_Execute_Command(AT_CIPMODE_0, 100*GSM_DEBUG_DELAY);
			else GSM_Execute_Command(AT_CIPMODE_1, 100*GSM_DEBUG_DELAY);
    cf88:	8c ec       	ldi	r24, 0xCC	; 204
    cf8a:	94 e0       	ldi	r25, 0x04	; 4
    cf8c:	64 e6       	ldi	r22, 0x64	; 100
    cf8e:	70 e0       	ldi	r23, 0x00	; 0
    cf90:	0e 94 df 49 	call	0x93be	; 0x93be <GSM_Execute_Command>
    cf94:	1c ca       	rjmp	.-3016   	; 0xc3ce <GSM_Cycle+0x354>
				SetIP(&GSM_MyIP,0,0,0,0);
				for(uint8_t i=0; i<strlen(GSM_RxStr); i++)
					if(!isdigit(GSM_RxStr[i])) GSM_RxStr[i] = ' ';
				sscanf_P(GSM_RxStr,PSTR("%hhu %hhu %hhu %hhu"), (unsigned char*)&GSM_MyIP.IP1, (unsigned char*)&GSM_MyIP.IP2, (unsigned char*)&GSM_MyIP.IP3, (unsigned char*)&GSM_MyIP.IP4);
				if(!IP_compare_Const(&GSM_MyIP,0,0,0,0)){
				  GSM_State = GSM_SEND_CIPSTART_TCP_CLIENT;
    cf96:	84 e2       	ldi	r24, 0x24	; 36
    cf98:	80 93 ac 06 	sts	0x06AC, r24
    cf9c:	eb cf       	rjmp	.-42     	; 0xcf74 <GSM_Cycle+0xefa>
					if(GSM_RxCharN==2)
						{
							if(!strncmp_P(GSM_RxStr, PSTR("\r\n"), 2)) {GSM_RxCharN=0;}
						}
					if(GSM_RxCharN >= 4){
						AppProtocol = 0;
    cf9e:	10 92 95 08 	sts	0x0895, r1
						if(!strncmp_P(GSM_RxStr, PSTR("GET "), 4)) {AppProtocol = _HTTP;GSM_State = GSM_DataMode;break;}//GET
    cfa2:	8f e8       	ldi	r24, 0x8F	; 143
    cfa4:	97 e0       	ldi	r25, 0x07	; 7
    cfa6:	66 ea       	ldi	r22, 0xA6	; 166
    cfa8:	7b e2       	ldi	r23, 0x2B	; 43
    cfaa:	44 e0       	ldi	r20, 0x04	; 4
    cfac:	50 e0       	ldi	r21, 0x00	; 0
    cfae:	0e 94 f2 79 	call	0xf3e4	; 0xf3e4 <strncmp_P>
    cfb2:	89 2b       	or	r24, r25
    cfb4:	09 f4       	brne	.+2      	; 0xcfb8 <GSM_Cycle+0xf3e>
    cfb6:	78 c2       	rjmp	.+1264   	; 0xd4a8 <GSM_Cycle+0x142e>
						if(!strncmp_P(GSM_RxStr, PSTR("POST"), 4)) {AppProtocol = _HTTP;GSM_State = GSM_DataMode;break;}//POST
    cfb8:	8f e8       	ldi	r24, 0x8F	; 143
    cfba:	97 e0       	ldi	r25, 0x07	; 7
    cfbc:	61 ea       	ldi	r22, 0xA1	; 161
    cfbe:	7b e2       	ldi	r23, 0x2B	; 43
    cfc0:	44 e0       	ldi	r20, 0x04	; 4
    cfc2:	50 e0       	ldi	r21, 0x00	; 0
    cfc4:	0e 94 f2 79 	call	0xf3e4	; 0xf3e4 <strncmp_P>
    cfc8:	89 2b       	or	r24, r25
    cfca:	09 f4       	brne	.+2      	; 0xcfce <GSM_Cycle+0xf54>
    cfcc:	6d c2       	rjmp	.+1242   	; 0xd4a8 <GSM_Cycle+0x142e>
						if(!strncmp_P(GSM_RxStr, PSTR("CLOS"), 4)) {AppProtocol = _HTTP;GSM_State = GSM_ReStart1;break;}// 
    cfce:	8f e8       	ldi	r24, 0x8F	; 143
    cfd0:	97 e0       	ldi	r25, 0x07	; 7
    cfd2:	6c e9       	ldi	r22, 0x9C	; 156
    cfd4:	7b e2       	ldi	r23, 0x2B	; 43
    cfd6:	44 e0       	ldi	r20, 0x04	; 4
    cfd8:	50 e0       	ldi	r21, 0x00	; 0
    cfda:	0e 94 f2 79 	call	0xf3e4	; 0xf3e4 <strncmp_P>
    cfde:	89 2b       	or	r24, r25
    cfe0:	09 f4       	brne	.+2      	; 0xcfe4 <GSM_Cycle+0xf6a>
    cfe2:	69 c2       	rjmp	.+1234   	; 0xd4b6 <GSM_Cycle+0x143c>
						if(!strncmp_P(GSM_RxStr, PSTR("+PDP"), 4)) {AppProtocol = _HTTP;GSM_State = GSM_ReStart1;break;}//GPRS 
    cfe4:	8f e8       	ldi	r24, 0x8F	; 143
    cfe6:	97 e0       	ldi	r25, 0x07	; 7
    cfe8:	67 e9       	ldi	r22, 0x97	; 151
    cfea:	7b e2       	ldi	r23, 0x2B	; 43
    cfec:	44 e0       	ldi	r20, 0x04	; 4
    cfee:	50 e0       	ldi	r21, 0x00	; 0
    cff0:	0e 94 f2 79 	call	0xf3e4	; 0xf3e4 <strncmp_P>
    cff4:	89 2b       	or	r24, r25
    cff6:	09 f4       	brne	.+2      	; 0xcffa <GSM_Cycle+0xf80>
    cff8:	5e c2       	rjmp	.+1212   	; 0xd4b6 <GSM_Cycle+0x143c>
						if( (GSM_RxStr[0]==0) && (GSM_RxStr[1]==0)){AppProtocol = _HTTP;GSM_State = GSM_ReStart1;break;}//  
    cffa:	80 91 8f 07 	lds	r24, 0x078F
    cffe:	88 23       	and	r24, r24
    d000:	29 f4       	brne	.+10     	; 0xd00c <GSM_Cycle+0xf92>
    d002:	80 91 90 07 	lds	r24, 0x0790
    d006:	88 23       	and	r24, r24
    d008:	09 f4       	brne	.+2      	; 0xd00c <GSM_Cycle+0xf92>
    d00a:	55 c2       	rjmp	.+1194   	; 0xd4b6 <GSM_Cycle+0x143c>
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    d00c:	8f ef       	ldi	r24, 0xFF	; 255
    d00e:	80 93 f0 06 	sts	0x06F0, r24
	GSM_RX_FIFO_End = 255;
    d012:	80 93 4a 06 	sts	0x064A, r24
	GSM_RxCharN = 0;
    d016:	10 92 0e 0b 	sts	0x0B0E, r1
	GSM_RX_FIFOOverFlow = 0;
    d01a:	10 92 c1 08 	sts	0x08C1, r1
	GSM_RX_FIFOMax = 0;
    d01e:	10 92 c7 08 	sts	0x08C7, r1
						StartTimer16(TD_CleanFIFO,500);
						//break;
					}
				}//while
				//GSM_RxCharN=0;
				if(Timer16Stopp(TD_CleanFIFO)&&(GSM_RX_FIFO_Begin == GSM_RX_FIFO_End)){
    d022:	80 91 e6 04 	lds	r24, 0x04E6
    d026:	0e 94 41 1b 	call	0x3682	; 0x3682 <Timer16Stopp>
    d02a:	88 23       	and	r24, r24
    d02c:	39 f0       	breq	.+14     	; 0xd03c <GSM_Cycle+0xfc2>
    d02e:	90 91 f0 06 	lds	r25, 0x06F0
    d032:	80 91 4a 06 	lds	r24, 0x064A
    d036:	98 17       	cp	r25, r24
    d038:	09 f4       	brne	.+2      	; 0xd03c <GSM_Cycle+0xfc2>
    d03a:	c1 c1       	rjmp	.+898    	; 0xd3be <GSM_Cycle+0x1344>
					StartTimer16(TD_CleanFIFO,500);
					InitFIFO();
				}

				if(Timer16Stopp(TD_data_start_delay)){
    d03c:	80 91 e7 04 	lds	r24, 0x04E7
    d040:	0e 94 41 1b 	call	0x3682	; 0x3682 <Timer16Stopp>
    d044:	88 23       	and	r24, r24
    d046:	09 f4       	brne	.+2      	; 0xd04a <GSM_Cycle+0xfd0>
    d048:	38 c8       	rjmp	.-3984   	; 0xc0ba <GSM_Cycle+0x40>
					if(GPRS_FlgSz_Out && (GPRS_FlgSz_Out <= GPRS_Out_MaxSz)&&(GSM_Flag&(1<<flg_TxCStr))&&Timer16Stopp(TD_timer_after_page_transfer)&&(!dataSendFlg)){			
    d04a:	80 91 63 07 	lds	r24, 0x0763
    d04e:	88 23       	and	r24, r24
    d050:	09 f4       	brne	.+2      	; 0xd054 <GSM_Cycle+0xfda>
    d052:	33 c8       	rjmp	.-3994   	; 0xc0ba <GSM_Cycle+0x40>
    d054:	80 91 cf 02 	lds	r24, 0x02CF
    d058:	80 ff       	sbrs	r24, 0
    d05a:	2f c8       	rjmp	.-4002   	; 0xc0ba <GSM_Cycle+0x40>
    d05c:	80 91 e8 04 	lds	r24, 0x04E8
    d060:	0e 94 41 1b 	call	0x3682	; 0x3682 <Timer16Stopp>
    d064:	88 23       	and	r24, r24
    d066:	09 f4       	brne	.+2      	; 0xd06a <GSM_Cycle+0xff0>
    d068:	28 c8       	rjmp	.-4016   	; 0xc0ba <GSM_Cycle+0x40>
    d06a:	80 91 da 02 	lds	r24, 0x02DA
    d06e:	88 23       	and	r24, r24
    d070:	09 f0       	breq	.+2      	; 0xd074 <GSM_Cycle+0xffa>
    d072:	23 c8       	rjmp	.-4026   	; 0xc0ba <GSM_Cycle+0x40>
							dataSendFlg=1;
    d074:	81 e0       	ldi	r24, 0x01	; 1
    d076:	80 93 da 02 	sts	0x02DA, r24
							GSM_AddHeaderSendData(GPRS_Data_Out, GPRS_FlgSz_Out);
    d07a:	84 ef       	ldi	r24, 0xF4	; 244
    d07c:	98 e0       	ldi	r25, 0x08	; 8
    d07e:	60 91 63 07 	lds	r22, 0x0763
    d082:	0e 94 72 3f 	call	0x7ee4	; 0x7ee4 <GSM_AddHeaderSendData>
    d086:	19 c8       	rjmp	.-4046   	; 0xc0ba <GSM_Cycle+0x40>
		/*	if(Timer16Stopp(TD_TCP_Connect)){	//        CommandMode
				GSM_State = GSM_Swtch2CommandMode;
				break;
			}*/
			//StartTimer16(TD_CheckModem,1000);
			if( (strstr_P(GSM_RxStr, URC_CLOSED+2) != NULL) ){
    d088:	8f e8       	ldi	r24, 0x8F	; 143
    d08a:	97 e0       	ldi	r25, 0x07	; 7
    d08c:	66 ea       	ldi	r22, 0xA6	; 166
    d08e:	73 e0       	ldi	r23, 0x03	; 3
    d090:	0e 94 0b 7a 	call	0xf416	; 0xf416 <strstr_P>
    d094:	89 2b       	or	r24, r25
    d096:	09 f4       	brne	.+2      	; 0xd09a <GSM_Cycle+0x1020>
    d098:	10 c8       	rjmp	.-4064   	; 0xc0ba <GSM_Cycle+0x40>
				GSM_State =GSM_ReStart1;
    d09a:	83 e3       	ldi	r24, 0x33	; 51
    d09c:	80 93 ac 06 	sts	0x06AC, r24
    d0a0:	0c c8       	rjmp	.-4072   	; 0xc0ba <GSM_Cycle+0x40>
		case GSM_WAIT_CSQ:
				if(Timer16Stopp(TD_GSM)){
						GSM_State = GSM_ReStart1;
				}
				else{				
					if(GetStringFromFIFO()){
    d0a2:	0e 94 b3 37 	call	0x6f66	; 0x6f66 <GetStringFromFIFO>
    d0a6:	88 23       	and	r24, r24
    d0a8:	11 f4       	brne	.+4      	; 0xd0ae <GSM_Cycle+0x1034>
    d0aa:	0c 94 5d 60 	jmp	0xc0ba	; 0xc0ba <GSM_Cycle+0x40>
						GSM_RSSI = 255; GSM_BER = 255;
    d0ae:	8f ef       	ldi	r24, 0xFF	; 255
    d0b0:	80 93 a9 06 	sts	0x06A9, r24
    d0b4:	80 93 7a 07 	sts	0x077A, r24
						if(strstr_P(GSM_RxStr, RESP_CSQ) != NULL ){
    d0b8:	0f e8       	ldi	r16, 0x8F	; 143
    d0ba:	17 e0       	ldi	r17, 0x07	; 7
    d0bc:	c8 01       	movw	r24, r16
    d0be:	65 e1       	ldi	r22, 0x15	; 21
    d0c0:	74 e0       	ldi	r23, 0x04	; 4
    d0c2:	0e 94 0b 7a 	call	0xf416	; 0xf416 <strstr_P>
    d0c6:	89 2b       	or	r24, r25
    d0c8:	11 f4       	brne	.+4      	; 0xd0ce <GSM_Cycle+0x1054>
    d0ca:	0c 94 5d 60 	jmp	0xc0ba	; 0xc0ba <GSM_Cycle+0x40>
							sscanf_P(GSM_RxStr,PSTR("+CSQ: %hhu,%hhu"), (unsigned char*)&GSM_RSSI, (unsigned char*)&GSM_BER);
    d0ce:	ed b7       	in	r30, 0x3d	; 61
    d0d0:	fe b7       	in	r31, 0x3e	; 62
    d0d2:	38 97       	sbiw	r30, 0x08	; 8
    d0d4:	0f b6       	in	r0, 0x3f	; 63
    d0d6:	f8 94       	cli
    d0d8:	fe bf       	out	0x3e, r31	; 62
    d0da:	0f be       	out	0x3f, r0	; 63
    d0dc:	ed bf       	out	0x3d, r30	; 61
    d0de:	31 96       	adiw	r30, 0x01	; 1
    d0e0:	ad b7       	in	r26, 0x3d	; 61
    d0e2:	be b7       	in	r27, 0x3e	; 62
    d0e4:	12 96       	adiw	r26, 0x02	; 2
    d0e6:	1c 93       	st	X, r17
    d0e8:	0e 93       	st	-X, r16
    d0ea:	11 97       	sbiw	r26, 0x01	; 1
    d0ec:	8e ea       	ldi	r24, 0xAE	; 174
    d0ee:	9b e2       	ldi	r25, 0x2B	; 43
    d0f0:	93 83       	std	Z+3, r25	; 0x03
    d0f2:	82 83       	std	Z+2, r24	; 0x02
    d0f4:	89 ea       	ldi	r24, 0xA9	; 169
    d0f6:	96 e0       	ldi	r25, 0x06	; 6
    d0f8:	95 83       	std	Z+5, r25	; 0x05
    d0fa:	84 83       	std	Z+4, r24	; 0x04
    d0fc:	8a e7       	ldi	r24, 0x7A	; 122
    d0fe:	97 e0       	ldi	r25, 0x07	; 7
    d100:	97 83       	std	Z+7, r25	; 0x07
    d102:	86 83       	std	Z+6, r24	; 0x06
    d104:	0e 94 5a 7b 	call	0xf6b4	; 0xf6b4 <sscanf_P>
									
								GSM_State = GSM_WAIT_CSQ_OK;
    d108:	8a e3       	ldi	r24, 0x3A	; 58
    d10a:	80 93 ac 06 	sts	0x06AC, r24
    d10e:	ed b7       	in	r30, 0x3d	; 61
    d110:	fe b7       	in	r31, 0x3e	; 62
    d112:	38 96       	adiw	r30, 0x08	; 8
    d114:	0f b6       	in	r0, 0x3f	; 63
    d116:	f8 94       	cli
    d118:	fe bf       	out	0x3e, r31	; 62
    d11a:	0f be       	out	0x3f, r0	; 63
    d11c:	ed bf       	out	0x3d, r30	; 61
    d11e:	0c 94 5d 60 	jmp	0xc0ba	; 0xc0ba <GSM_Cycle+0x40>
			break;

		case GSM_SEND_CIPCSGP:
			//GSM_Execute_Command(AT_CIPCSGP, 300*GSM_DEBUG_DELAY); GSM_State++;
			if(GSM_Flag & (1<<flg_TxCStr)){
				sprintf_P(GSM_TxStr, AT_CIPCSGP);	GSMTxSz = strlen_P(AT_CIPCSGP);
    d122:	00 d0       	rcall	.+0      	; 0xd124 <GSM_Cycle+0x10aa>
    d124:	0f 92       	push	r0
    d126:	88 ef       	ldi	r24, 0xF8	; 248
    d128:	99 e0       	ldi	r25, 0x09	; 9
    d12a:	ad b7       	in	r26, 0x3d	; 61
    d12c:	be b7       	in	r27, 0x3e	; 62
    d12e:	12 96       	adiw	r26, 0x02	; 2
    d130:	9c 93       	st	X, r25
    d132:	8e 93       	st	-X, r24
    d134:	11 97       	sbiw	r26, 0x01	; 1
    d136:	0c ef       	ldi	r16, 0xFC	; 252
    d138:	14 e0       	ldi	r17, 0x04	; 4
    d13a:	14 96       	adiw	r26, 0x04	; 4
    d13c:	1c 93       	st	X, r17
    d13e:	0e 93       	st	-X, r16
    d140:	13 97       	sbiw	r26, 0x03	; 3
    d142:	0e 94 06 7b 	call	0xf60c	; 0xf60c <sprintf_P>
    d146:	0f 90       	pop	r0
    d148:	0f 90       	pop	r0
    d14a:	0f 90       	pop	r0
    d14c:	0f 90       	pop	r0
    d14e:	c8 01       	movw	r24, r16
    d150:	0e 94 e9 79 	call	0xf3d2	; 0xf3d2 <strlen_P>
    d154:	80 93 6b 07 	sts	0x076B, r24
				#if LCDXSz==40
					GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn);
				#else
					GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn1);
    d158:	80 91 6b 07 	lds	r24, 0x076B
    d15c:	90 e0       	ldi	r25, 0x00	; 0
    d15e:	88 50       	subi	r24, 0x08	; 8
    d160:	96 4f       	sbci	r25, 0xF6	; 246
    d162:	69 e0       	ldi	r22, 0x09	; 9
    d164:	70 e0       	ldi	r23, 0x00	; 0
    d166:	0e 94 1a 60 	call	0xc034	; 0xc034 <strcpy_EE>
    d16a:	90 91 6b 07 	lds	r25, 0x076B
    d16e:	98 0f       	add	r25, r24
    d170:	90 93 6b 07 	sts	0x076B, r25
					GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn2);
    d174:	80 91 6b 07 	lds	r24, 0x076B
    d178:	90 e0       	ldi	r25, 0x00	; 0
    d17a:	88 50       	subi	r24, 0x08	; 8
    d17c:	96 4f       	sbci	r25, 0xF6	; 246
    d17e:	6d e1       	ldi	r22, 0x1D	; 29
    d180:	70 e0       	ldi	r23, 0x00	; 0
    d182:	0e 94 1a 60 	call	0xc034	; 0xc034 <strcpy_EE>
    d186:	90 91 6b 07 	lds	r25, 0x076B
    d18a:	98 0f       	add	r25, r24
    d18c:	90 93 6b 07 	sts	0x076B, r25
				#endif
				sprintf(GSM_TxStr + GSMTxSz, "\",\"");	GSMTxSz = GSMTxSz+3;				
    d190:	e0 91 6b 07 	lds	r30, 0x076B
    d194:	f0 e0       	ldi	r31, 0x00	; 0
    d196:	e8 50       	subi	r30, 0x08	; 8
    d198:	f6 4f       	sbci	r31, 0xF6	; 246
    d19a:	a2 e2       	ldi	r26, 0x22	; 34
    d19c:	ea 2e       	mov	r14, r26
    d19e:	ac e2       	ldi	r26, 0x2C	; 44
    d1a0:	fa 2e       	mov	r15, r26
    d1a2:	a2 e2       	ldi	r26, 0x22	; 34
    d1a4:	0a 2f       	mov	r16, r26
    d1a6:	11 2d       	mov	r17, r1
    d1a8:	e0 82       	st	Z, r14
    d1aa:	f1 82       	std	Z+1, r15	; 0x01
    d1ac:	02 83       	std	Z+2, r16	; 0x02
    d1ae:	13 83       	std	Z+3, r17	; 0x03
    d1b0:	80 91 6b 07 	lds	r24, 0x076B
    d1b4:	8d 5f       	subi	r24, 0xFD	; 253
    d1b6:	80 93 6b 07 	sts	0x076B, r24
				GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn_user_name);
    d1ba:	80 91 6b 07 	lds	r24, 0x076B
    d1be:	90 e0       	ldi	r25, 0x00	; 0
    d1c0:	88 50       	subi	r24, 0x08	; 8
    d1c2:	96 4f       	sbci	r25, 0xF6	; 246
    d1c4:	69 e5       	ldi	r22, 0x59	; 89
    d1c6:	70 e0       	ldi	r23, 0x00	; 0
    d1c8:	0e 94 1a 60 	call	0xc034	; 0xc034 <strcpy_EE>
    d1cc:	90 91 6b 07 	lds	r25, 0x076B
    d1d0:	98 0f       	add	r25, r24
    d1d2:	90 93 6b 07 	sts	0x076B, r25
				sprintf(GSM_TxStr + GSMTxSz, "\",\"");	GSMTxSz = GSMTxSz+3;
    d1d6:	e0 91 6b 07 	lds	r30, 0x076B
    d1da:	f0 e0       	ldi	r31, 0x00	; 0
    d1dc:	e8 50       	subi	r30, 0x08	; 8
    d1de:	f6 4f       	sbci	r31, 0xF6	; 246
    d1e0:	e0 82       	st	Z, r14
    d1e2:	f1 82       	std	Z+1, r15	; 0x01
    d1e4:	02 83       	std	Z+2, r16	; 0x02
    d1e6:	13 83       	std	Z+3, r17	; 0x03
    d1e8:	80 91 6b 07 	lds	r24, 0x076B
    d1ec:	8d 5f       	subi	r24, 0xFD	; 253
    d1ee:	80 93 6b 07 	sts	0x076B, r24
				GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn_psw);
    d1f2:	80 91 6b 07 	lds	r24, 0x076B
    d1f6:	90 e0       	ldi	r25, 0x00	; 0
    d1f8:	88 50       	subi	r24, 0x08	; 8
    d1fa:	96 4f       	sbci	r25, 0xF6	; 246
    d1fc:	6d e6       	ldi	r22, 0x6D	; 109
    d1fe:	70 e0       	ldi	r23, 0x00	; 0
    d200:	0e 94 1a 60 	call	0xc034	; 0xc034 <strcpy_EE>
    d204:	90 91 6b 07 	lds	r25, 0x076B
    d208:	98 0f       	add	r25, r24
    d20a:	90 93 6b 07 	sts	0x076B, r25
				sprintf(GSM_TxStr + GSMTxSz, "\"\r");	GSMTxSz = GSMTxSz+2;
    d20e:	80 91 6b 07 	lds	r24, 0x076B
    d212:	e8 2f       	mov	r30, r24
    d214:	f0 e0       	ldi	r31, 0x00	; 0
    d216:	e8 50       	subi	r30, 0x08	; 8
    d218:	f6 4f       	sbci	r31, 0xF6	; 246
    d21a:	a2 eb       	ldi	r26, 0xB2	; 178
    d21c:	b2 e0       	ldi	r27, 0x02	; 2
    d21e:	83 e0       	ldi	r24, 0x03	; 3
    d220:	0d 90       	ld	r0, X+
    d222:	01 92       	st	Z+, r0
    d224:	81 50       	subi	r24, 0x01	; 1
    d226:	e1 f7       	brne	.-8      	; 0xd220 <GSM_Cycle+0x11a6>
    d228:	80 91 6b 07 	lds	r24, 0x076B
    d22c:	8e 5f       	subi	r24, 0xFE	; 254
    d22e:	80 93 6b 07 	sts	0x076B, r24
				GSM_SendFirstChar();
    d232:	0e 94 dd 38 	call	0x71ba	; 0x71ba <GSM_SendFirstChar>
				StartTimer16(TD_GSM, 300*GSM_DEBUG_DELAY);
    d236:	80 91 e0 04 	lds	r24, 0x04E0
    d23a:	6c e2       	ldi	r22, 0x2C	; 44
    d23c:	71 e0       	ldi	r23, 0x01	; 1
    d23e:	0e 94 05 1a 	call	0x340a	; 0x340a <StartTimer16>
    d242:	69 c8       	rjmp	.-3886   	; 0xc316 <GSM_Cycle+0x29c>
				if(++TempNum>=MaxTelephDirSz){
					GSM_State = GSM_Return2dataMode;
					SMS_FlgSz_Out = 0;
					//StartTimer16(TD_GSM,150);
				}
				else GSM_State = GSM_SEND_CMGS;
    d244:	89 e2       	ldi	r24, 0x29	; 41
    d246:	80 93 ac 06 	sts	0x06AC, r24
    d24a:	0c 94 5d 60 	jmp	0xc0ba	; 0xc0ba <GSM_Cycle+0x40>
			}
			break;
		case GSM_WAIT_D2C_SWITCH_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) {

				switch(CommandModeDestination){
    d24e:	84 30       	cpi	r24, 0x04	; 4
    d250:	71 f1       	breq	.+92     	; 0xd2ae <GSM_Cycle+0x1234>
    d252:	85 30       	cpi	r24, 0x05	; 5
    d254:	09 f0       	breq	.+2      	; 0xd258 <GSM_Cycle+0x11de>
    d256:	ef cc       	rjmp	.-1570   	; 0xcc36 <GSM_Cycle+0xbbc>
					case 4:	
						GSM_State = GSM_SEND_ATD_Check_Ballance;
						counter=0;	
						break;
					case 5:	
						GSM_State = GSM_SEND_CSQ;
    d258:	88 e3       	ldi	r24, 0x38	; 56
    d25a:	80 93 ac 06 	sts	0x06AC, r24
						counter=0;	
    d25e:	10 92 db 02 	sts	0x02DB, r1
    d262:	0c 94 5d 60 	jmp	0xc0ba	; 0xc0ba <GSM_Cycle+0x40>
			GSM_State++; 
			break;
		case GSM_WAIT_CIPMUX_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
				if(GSM_MultiCon){
					GSM_State = GSM_WAIT_1;
    d266:	87 e1       	ldi	r24, 0x17	; 23
    d268:	80 93 ac 06 	sts	0x06AC, r24
					// between "Call Ready" and "+CMGS"; 8 sec min needs; for kyivstar vpni only
					StartTimer16(TD_GSM, 1000);
    d26c:	80 91 e0 04 	lds	r24, 0x04E0
    d270:	68 ee       	ldi	r22, 0xE8	; 232
    d272:	73 e0       	ldi	r23, 0x03	; 3
    d274:	0e 94 05 1a 	call	0x340a	; 0x340a <StartTimer16>
    d278:	0c 94 5d 60 	jmp	0xc0ba	; 0xc0ba <GSM_Cycle+0x40>
			}
			GSM_State++;
			break;
		case GSM_WAIT_CIPCSGP_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
			 if(GSM_Modem == SIMCOM_SIM800)GSM_State++;
    d27c:	80 91 ac 06 	lds	r24, 0x06AC
    d280:	8f 5f       	subi	r24, 0xFF	; 255
    d282:	80 93 ac 06 	sts	0x06AC, r24
    d286:	0c 94 5d 60 	jmp	0xc0ba	; 0xc0ba <GSM_Cycle+0x40>
			if(GSM_Wait_Response_P(URC_CPIN_READY, GSM_ReStart1)) GSM_State++;
			break;

		case GSM_WAIT_CALL_READY:
			if(GSM_Wait_Response_P(URC_CALL_READY, GSM_ReStart1)){
				if(GSM_Modem == SIMCOM_SIM800) GSM_State = GSM_WAIT_SMS_READY;
    d28a:	87 e0       	ldi	r24, 0x07	; 7
    d28c:	80 93 ac 06 	sts	0x06AC, r24
    d290:	0c 94 5d 60 	jmp	0xc0ba	; 0xc0ba <GSM_Cycle+0x40>
				}
			break;
		case GSM_WAIT_CSQ_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) {
				if(CommandModeDestination==5){
					GSM_State  = GSM_Return2dataMode;
    d294:	80 e4       	ldi	r24, 0x40	; 64
    d296:	80 93 ac 06 	sts	0x06AC, r24
    d29a:	0c 94 5d 60 	jmp	0xc0ba	; 0xc0ba <GSM_Cycle+0x40>
			if(GetStringFromFIFO()){
				if(!strcmp_P(GSM_RxStr, GSM_SIMCOM_SIM900R)) GSM_Modem = SIMCOM_SIM900R;
				if(!strcmp_P(GSM_RxStr, GSM_SIMCOM_SIM800)) GSM_Modem = SIMCOM_SIM800;
				if(!strcmp_P(GSM_RxStr, GSM_SIMCOM_SIM800C)) GSM_Modem = SIMCOM_SIM800;
				//Add here new model GSM-modem
				if(GSM_Modem != NOT_RECOGNIZED) GSM_State = GSM_WAIT_CALL_READY;
    d29e:	80 91 ea 06 	lds	r24, 0x06EA
    d2a2:	88 23       	and	r24, r24
    d2a4:	11 f4       	brne	.+4      	; 0xd2aa <GSM_Cycle+0x1230>
    d2a6:	0c 94 f7 60 	jmp	0xc1ee	; 0xc1ee <GSM_Cycle+0x174>
    d2aa:	0c 94 f4 60 	jmp	0xc1e8	; 0xc1e8 <GSM_Cycle+0x16e>
					case 2:	
						GSM_State = GSM_CIPSHUT_;
						counter=0;	
						break;						
					case 4:	
						GSM_State = GSM_SEND_ATD_Check_Ballance;
    d2ae:	85 e3       	ldi	r24, 0x35	; 53
    d2b0:	80 93 ac 06 	sts	0x06AC, r24
						counter=0;	
    d2b4:	10 92 db 02 	sts	0x02DB, r1
    d2b8:	0c 94 5d 60 	jmp	0xc0ba	; 0xc0ba <GSM_Cycle+0x40>
			break;
		case GSM_WAIT_D2C_SWITCH_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) {

				switch(CommandModeDestination){
					case 1:	GSM_State = GSM_SEND_CMGS;
    d2bc:	89 e2       	ldi	r24, 0x29	; 41
    d2be:	80 93 ac 06 	sts	0x06AC, r24
    d2c2:	0c 94 5d 60 	jmp	0xc0ba	; 0xc0ba <GSM_Cycle+0x40>
						break;
					case 2:	
						GSM_State = GSM_CIPSHUT_;
    d2c6:	8d e2       	ldi	r24, 0x2D	; 45
    d2c8:	80 93 ac 06 	sts	0x06AC, r24
						counter=0;	
    d2cc:	10 92 db 02 	sts	0x02DB, r1
    d2d0:	0c 94 5d 60 	jmp	0xc0ba	; 0xc0ba <GSM_Cycle+0x40>
				GSMTxSz = strlen(GSM_TxStr);
				uint8_t j=0;
				for(uint8_t i=0; i<GSMTxSz; i++)
					if(GSM_TxStr[i] != '0') j++;
				if(j){
					GSMTxSz = strlen_P(AT_CMGS);
    d2d4:	04 eb       	ldi	r16, 0xB4	; 180
    d2d6:	14 e0       	ldi	r17, 0x04	; 4
    d2d8:	c8 01       	movw	r24, r16
    d2da:	0e 94 e9 79 	call	0xf3d2	; 0xf3d2 <strlen_P>
    d2de:	80 93 6b 07 	sts	0x076B, r24
					sprintf_P(GSM_TxStr, AT_CMGS);
    d2e2:	00 d0       	rcall	.+0      	; 0xd2e4 <GSM_Cycle+0x126a>
    d2e4:	0f 92       	push	r0
    d2e6:	ad b7       	in	r26, 0x3d	; 61
    d2e8:	be b7       	in	r27, 0x3e	; 62
    d2ea:	12 96       	adiw	r26, 0x02	; 2
    d2ec:	fc 92       	st	X, r15
    d2ee:	ee 92       	st	-X, r14
    d2f0:	11 97       	sbiw	r26, 0x01	; 1
    d2f2:	14 96       	adiw	r26, 0x04	; 4
    d2f4:	1c 93       	st	X, r17
    d2f6:	0e 93       	st	-X, r16
    d2f8:	13 97       	sbiw	r26, 0x03	; 3
    d2fa:	0e 94 06 7b 	call	0xf60c	; 0xf60c <sprintf_P>
					erbl(GSM_TxStr+GSMTxSz, SMS_Number+TempNum, MaxTelephN);
    d2fe:	80 91 6b 07 	lds	r24, 0x076B
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    d302:	0f 90       	pop	r0
    d304:	0f 90       	pop	r0
    d306:	0f 90       	pop	r0
    d308:	0f 90       	pop	r0
    d30a:	90 e0       	ldi	r25, 0x00	; 0
    d30c:	60 91 d3 05 	lds	r22, 0x05D3
    d310:	2d e0       	ldi	r18, 0x0D	; 13
    d312:	62 9f       	mul	r22, r18
    d314:	b0 01       	movw	r22, r0
    d316:	11 24       	eor	r1, r1
    d318:	6b 53       	subi	r22, 0x3B	; 59
    d31a:	7f 4f       	sbci	r23, 0xFF	; 255
    d31c:	88 50       	subi	r24, 0x08	; 8
    d31e:	96 4f       	sbci	r25, 0xF6	; 246
    d320:	4d e0       	ldi	r20, 0x0D	; 13
    d322:	50 e0       	ldi	r21, 0x00	; 0
    d324:	0e 94 f3 7c 	call	0xf9e6	; 0xf9e6 <__eerd_block_m2560>
					GSMTxSz = strlen(GSM_TxStr);
    d328:	f7 01       	movw	r30, r14
    d32a:	01 90       	ld	r0, Z+
    d32c:	00 20       	and	r0, r0
    d32e:	e9 f7       	brne	.-6      	; 0xd32a <GSM_Cycle+0x12b0>
    d330:	31 97       	sbiw	r30, 0x01	; 1
    d332:	e8 5f       	subi	r30, 0xF8	; 248
    d334:	f9 40       	sbci	r31, 0x09	; 9
    d336:	e0 93 6b 07 	sts	0x076B, r30
					sprintf(GSM_TxStr + GSMTxSz, "\"\r");
    d33a:	80 91 6b 07 	lds	r24, 0x076B
    d33e:	e8 2f       	mov	r30, r24
    d340:	f0 e0       	ldi	r31, 0x00	; 0
    d342:	e8 50       	subi	r30, 0x08	; 8
    d344:	f6 4f       	sbci	r31, 0xF6	; 246
    d346:	a2 eb       	ldi	r26, 0xB2	; 178
    d348:	b2 e0       	ldi	r27, 0x02	; 2
    d34a:	83 e0       	ldi	r24, 0x03	; 3
    d34c:	0d 90       	ld	r0, X+
    d34e:	01 92       	st	Z+, r0
    d350:	81 50       	subi	r24, 0x01	; 1
    d352:	e1 f7       	brne	.-8      	; 0xd34c <GSM_Cycle+0x12d2>
					GSMTxSz = strlen(GSM_TxStr);
    d354:	f7 01       	movw	r30, r14
    d356:	01 90       	ld	r0, Z+
    d358:	00 20       	and	r0, r0
    d35a:	e9 f7       	brne	.-6      	; 0xd356 <GSM_Cycle+0x12dc>
    d35c:	31 97       	sbiw	r30, 0x01	; 1
    d35e:	e8 5f       	subi	r30, 0xF8	; 248
    d360:	f9 40       	sbci	r31, 0x09	; 9
    d362:	e0 93 6b 07 	sts	0x076B, r30
					GSM_SendFirstChar();
    d366:	0e 94 dd 38 	call	0x71ba	; 0x71ba <GSM_SendFirstChar>
					StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    d36a:	80 91 e0 04 	lds	r24, 0x04E0
    d36e:	64 ef       	ldi	r22, 0xF4	; 244
    d370:	71 e0       	ldi	r23, 0x01	; 1
    d372:	0e 94 05 1a 	call	0x340a	; 0x340a <StartTimer16>
					GSM_State++;
    d376:	80 91 ac 06 	lds	r24, 0x06AC
    d37a:	8f 5f       	subi	r24, 0xFF	; 255
    d37c:	80 93 ac 06 	sts	0x06AC, r24
    d380:	0c 94 5d 60 	jmp	0xc0ba	; 0xc0ba <GSM_Cycle+0x40>
				GSM_State = GSM_ProtocolMode;
				InitFIFO();
				break;
			}
*/			
			if( (strstr_P(GSM_RxStr, PSTR("OK")) != NULL) ){
    d384:	c8 01       	movw	r24, r16
    d386:	6b ec       	ldi	r22, 0xCB	; 203
    d388:	7b e2       	ldi	r23, 0x2B	; 43
    d38a:	0e 94 0b 7a 	call	0xf416	; 0xf416 <strstr_P>
    d38e:	89 2b       	or	r24, r25
    d390:	41 f1       	breq	.+80     	; 0xd3e2 <GSM_Cycle+0x1368>
				StartTimer16(TD_data_start_delay,100);
    d392:	80 91 e7 04 	lds	r24, 0x04E7
    d396:	64 e6       	ldi	r22, 0x64	; 100
    d398:	70 e0       	ldi	r23, 0x00	; 0
    d39a:	0e 94 05 1a 	call	0x340a	; 0x340a <StartTimer16>
				GSM_State = GSM_ProtocolMode;
    d39e:	8b e3       	ldi	r24, 0x3B	; 59
    d3a0:	80 93 ac 06 	sts	0x06AC, r24
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    d3a4:	8f ef       	ldi	r24, 0xFF	; 255
    d3a6:	80 93 f0 06 	sts	0x06F0, r24
	GSM_RX_FIFO_End = 255;
    d3aa:	80 93 4a 06 	sts	0x064A, r24
	GSM_RxCharN = 0;
    d3ae:	10 92 0e 0b 	sts	0x0B0E, r1
	GSM_RX_FIFOOverFlow = 0;
    d3b2:	10 92 c1 08 	sts	0x08C1, r1
	GSM_RX_FIFOMax = 0;
    d3b6:	10 92 c7 08 	sts	0x08C7, r1
    d3ba:	0c 94 5d 60 	jmp	0xc0ba	; 0xc0ba <GSM_Cycle+0x40>
						//break;
					}
				}//while
				//GSM_RxCharN=0;
				if(Timer16Stopp(TD_CleanFIFO)&&(GSM_RX_FIFO_Begin == GSM_RX_FIFO_End)){
					StartTimer16(TD_CleanFIFO,500);
    d3be:	80 91 e6 04 	lds	r24, 0x04E6
    d3c2:	64 ef       	ldi	r22, 0xF4	; 244
    d3c4:	71 e0       	ldi	r23, 0x01	; 1
    d3c6:	0e 94 05 1a 	call	0x340a	; 0x340a <StartTimer16>
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    d3ca:	8f ef       	ldi	r24, 0xFF	; 255
    d3cc:	80 93 f0 06 	sts	0x06F0, r24
	GSM_RX_FIFO_End = 255;
    d3d0:	80 93 4a 06 	sts	0x064A, r24
	GSM_RxCharN = 0;
    d3d4:	10 92 0e 0b 	sts	0x0B0E, r1
	GSM_RX_FIFOOverFlow = 0;
    d3d8:	10 92 c1 08 	sts	0x08C1, r1
	GSM_RX_FIFOMax = 0;
    d3dc:	10 92 c7 08 	sts	0x08C7, r1
    d3e0:	2d ce       	rjmp	.-934    	; 0xd03c <GSM_Cycle+0xfc2>
				break;
			}


			//  
			if( (strstr_P(GSM_RxStr, URC_CONNECT) != NULL) ){
    d3e2:	c8 01       	movw	r24, r16
    d3e4:	62 e9       	ldi	r22, 0x92	; 146
    d3e6:	73 e0       	ldi	r23, 0x03	; 3
    d3e8:	0e 94 0b 7a 	call	0xf416	; 0xf416 <strstr_P>
    d3ec:	89 2b       	or	r24, r25
    d3ee:	b1 f0       	breq	.+44     	; 0xd41c <GSM_Cycle+0x13a2>

				GSM_State = GSM_ProtocolMode;
    d3f0:	8b e3       	ldi	r24, 0x3B	; 59
    d3f2:	80 93 ac 06 	sts	0x06AC, r24
    d3f6:	f8 01       	movw	r30, r16
				for(int i=0;i<GSM_RXSTR_SIZE;i++)
				{
					GSM_RxStr[i]=0;	
    d3f8:	11 92       	st	Z+, r1

			//  
			if( (strstr_P(GSM_RxStr, URC_CONNECT) != NULL) ){

				GSM_State = GSM_ProtocolMode;
				for(int i=0;i<GSM_RXSTR_SIZE;i++)
    d3fa:	37 e0       	ldi	r19, 0x07	; 7
    d3fc:	e3 3f       	cpi	r30, 0xF3	; 243
    d3fe:	f3 07       	cpc	r31, r19
    d400:	d9 f7       	brne	.-10     	; 0xd3f8 <GSM_Cycle+0x137e>
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    d402:	8f ef       	ldi	r24, 0xFF	; 255
    d404:	80 93 f0 06 	sts	0x06F0, r24
	GSM_RX_FIFO_End = 255;
    d408:	80 93 4a 06 	sts	0x064A, r24
	GSM_RxCharN = 0;
    d40c:	10 92 0e 0b 	sts	0x0B0E, r1
	GSM_RX_FIFOOverFlow = 0;
    d410:	10 92 c1 08 	sts	0x08C1, r1
	GSM_RX_FIFOMax = 0;
    d414:	10 92 c7 08 	sts	0x08C7, r1
    d418:	0c 94 5d 60 	jmp	0xc0ba	; 0xc0ba <GSM_Cycle+0x40>

				break;
			}

			//  
			if(strstr_P(GSM_RxStr, URC_CLOSED) != NULL){
    d41c:	c8 01       	movw	r24, r16
    d41e:	64 ea       	ldi	r22, 0xA4	; 164
    d420:	73 e0       	ldi	r23, 0x03	; 3
    d422:	0e 94 0b 7a 	call	0xf416	; 0xf416 <strstr_P>
    d426:	89 2b       	or	r24, r25
    d428:	99 f1       	breq	.+102    	; 0xd490 <GSM_Cycle+0x1416>
				//  
				sscanf_P(GSM_RxStr,PSTR("%hhu, CLOSED"),(unsigned char*)&TempNum);
    d42a:	00 d0       	rcall	.+0      	; 0xd42c <GSM_Cycle+0x13b2>
    d42c:	00 d0       	rcall	.+0      	; 0xd42e <GSM_Cycle+0x13b4>
    d42e:	ed b7       	in	r30, 0x3d	; 61
    d430:	fe b7       	in	r31, 0x3e	; 62
    d432:	31 96       	adiw	r30, 0x01	; 1
    d434:	ad b7       	in	r26, 0x3d	; 61
    d436:	be b7       	in	r27, 0x3e	; 62
    d438:	12 96       	adiw	r26, 0x02	; 2
    d43a:	1c 93       	st	X, r17
    d43c:	0e 93       	st	-X, r16
    d43e:	11 97       	sbiw	r26, 0x01	; 1
    d440:	8e eb       	ldi	r24, 0xBE	; 190
    d442:	9b e2       	ldi	r25, 0x2B	; 43
    d444:	93 83       	std	Z+3, r25	; 0x03
    d446:	82 83       	std	Z+2, r24	; 0x02
    d448:	83 ed       	ldi	r24, 0xD3	; 211
    d44a:	95 e0       	ldi	r25, 0x05	; 5
    d44c:	95 83       	std	Z+5, r25	; 0x05
    d44e:	84 83       	std	Z+4, r24	; 0x04
    d450:	0e 94 5a 7b 	call	0xf6b4	; 0xf6b4 <sscanf_P>
				if(GSM_ActiveConnection == TempNum){
    d454:	ed b7       	in	r30, 0x3d	; 61
    d456:	fe b7       	in	r31, 0x3e	; 62
    d458:	36 96       	adiw	r30, 0x06	; 6
    d45a:	0f b6       	in	r0, 0x3f	; 63
    d45c:	f8 94       	cli
    d45e:	fe bf       	out	0x3e, r31	; 62
    d460:	0f be       	out	0x3f, r0	; 63
    d462:	ed bf       	out	0x3d, r30	; 61
    d464:	90 91 d0 02 	lds	r25, 0x02D0
    d468:	80 91 d3 05 	lds	r24, 0x05D3
    d46c:	98 17       	cp	r25, r24
    d46e:	59 f4       	brne	.+22     	; 0xd486 <GSM_Cycle+0x140c>
					GSM_ActiveConnection = NO_CONNECTION;
    d470:	8f ef       	ldi	r24, 0xFF	; 255
    d472:	80 93 d0 02 	sts	0x02D0, r24
	uint8_t IP4;
} IP_Addr;

//~~~~~~~~~~~~~~
void SetIP(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	IP->IP1 = IP1;
    d476:	10 92 f8 0a 	sts	0x0AF8, r1
	IP->IP2 = IP2;
    d47a:	10 92 f9 0a 	sts	0x0AF9, r1
	IP->IP3 = IP3;
    d47e:	10 92 fa 0a 	sts	0x0AFA, r1
	IP->IP4 = IP4;
    d482:	10 92 fb 0a 	sts	0x0AFB, r1
					SetIP(&GSM_ClientIP,0,0,0,0);
				}

				GSM_State = GSM_ReStart1;
    d486:	83 e3       	ldi	r24, 0x33	; 51
    d488:	80 93 ac 06 	sts	0x06AC, r24
    d48c:	0c 94 5d 60 	jmp	0xc0ba	; 0xc0ba <GSM_Cycle+0x40>
				break;
			}

			// +PDP DEACT
			if( (strstr_P(GSM_RxStr, URC_PDPDEACT) != NULL) ){
    d490:	c8 01       	movw	r24, r16
    d492:	6d ea       	ldi	r22, 0xAD	; 173
    d494:	73 e0       	ldi	r23, 0x03	; 3
    d496:	0e 94 0b 7a 	call	0xf416	; 0xf416 <strstr_P>
    d49a:	89 2b       	or	r24, r25
    d49c:	99 f0       	breq	.+38     	; 0xd4c4 <GSM_Cycle+0x144a>
				GSM_State = GSM_SEND_E0;
    d49e:	88 e0       	ldi	r24, 0x08	; 8
    d4a0:	80 93 ac 06 	sts	0x06AC, r24
    d4a4:	0c 94 5d 60 	jmp	0xc0ba	; 0xc0ba <GSM_Cycle+0x40>
							if(!strncmp_P(GSM_RxStr, PSTR("\r\n"), 2)) {GSM_RxCharN=0;}
						}
					if(GSM_RxCharN >= 4){
						AppProtocol = 0;
						if(!strncmp_P(GSM_RxStr, PSTR("GET "), 4)) {AppProtocol = _HTTP;GSM_State = GSM_DataMode;break;}//GET
						if(!strncmp_P(GSM_RxStr, PSTR("POST"), 4)) {AppProtocol = _HTTP;GSM_State = GSM_DataMode;break;}//POST
    d4a8:	81 e0       	ldi	r24, 0x01	; 1
    d4aa:	80 93 95 08 	sts	0x0895, r24
    d4ae:	8c e3       	ldi	r24, 0x3C	; 60
    d4b0:	80 93 ac 06 	sts	0x06AC, r24
    d4b4:	b6 cd       	rjmp	.-1172   	; 0xd022 <GSM_Cycle+0xfa8>
						if(!strncmp_P(GSM_RxStr, PSTR("CLOS"), 4)) {AppProtocol = _HTTP;GSM_State = GSM_ReStart1;break;}// 
						if(!strncmp_P(GSM_RxStr, PSTR("+PDP"), 4)) {AppProtocol = _HTTP;GSM_State = GSM_ReStart1;break;}//GPRS 
						if( (GSM_RxStr[0]==0) && (GSM_RxStr[1]==0)){AppProtocol = _HTTP;GSM_State = GSM_ReStart1;break;}//  
    d4b6:	81 e0       	ldi	r24, 0x01	; 1
    d4b8:	80 93 95 08 	sts	0x0895, r24
    d4bc:	83 e3       	ldi	r24, 0x33	; 51
    d4be:	80 93 ac 06 	sts	0x06AC, r24
    d4c2:	af cd       	rjmp	.-1186   	; 0xd022 <GSM_Cycle+0xfa8>
			}



			//      
			if(strstr_P(GSM_RxStr, RESP_CSQ) != NULL ){
    d4c4:	c8 01       	movw	r24, r16
    d4c6:	65 e1       	ldi	r22, 0x15	; 21
    d4c8:	74 e0       	ldi	r23, 0x04	; 4
    d4ca:	0e 94 0b 7a 	call	0xf416	; 0xf416 <strstr_P>
    d4ce:	89 2b       	or	r24, r25
    d4d0:	29 f0       	breq	.+10     	; 0xd4dc <GSM_Cycle+0x1462>
				GSM_State = GSM_WAIT_CSQ;
    d4d2:	89 e3       	ldi	r24, 0x39	; 57
    d4d4:	80 93 ac 06 	sts	0x06AC, r24
    d4d8:	0c 94 5d 60 	jmp	0xc0ba	; 0xc0ba <GSM_Cycle+0x40>
				break;
			}

			// 
			GSM_State = GSM_WAIT_IDENTIFICATION;
    d4dc:	87 e2       	ldi	r24, 0x27	; 39
    d4de:	80 93 ac 06 	sts	0x06AC, r24
    d4e2:	0c 94 5d 60 	jmp	0xc0ba	; 0xc0ba <GSM_Cycle+0x40>

0000d4e6 <USART_Cycle>:

// ~~~~~~~~~~~~~~
void
USART_Cycle(void)
{
	MB_Cycle();
    d4e6:	0e 94 f6 36 	call	0x6dec	; 0x6dec <MB_Cycle>
	#ifdef GSM
		GSM_Cycle();
    d4ea:	0e 94 3d 60 	call	0xc07a	; 0xc07a <GSM_Cycle>
	#endif
	#ifdef UDP_EASY
		UDP_RxProcess();
	#endif
}
    d4ee:	08 95       	ret

0000d4f0 <IP_E_compare_Const>:
}
uint8_t IP_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	if((IP->IP1 == IP1) && (IP->IP2 == IP2) && (IP->IP3 == IP3) && (IP->IP4 == IP4)) return 1;
	else return 0;
}
uint8_t IP_E_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
    d4f0:	ef 92       	push	r14
    d4f2:	ff 92       	push	r15
    d4f4:	0f 93       	push	r16
    d4f6:	1f 93       	push	r17
    d4f8:	cf 93       	push	r28
    d4fa:	df 93       	push	r29
    d4fc:	ec 01       	movw	r28, r24
    d4fe:	16 2f       	mov	r17, r22
    d500:	f4 2e       	mov	r15, r20
    d502:	e2 2e       	mov	r14, r18
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    d504:	0e 94 03 7d 	call	0xfa06	; 0xfa06 <__eerd_byte_m2560>
	if((erb(&IP->IP1) == IP1) && (erb(&IP->IP2) == IP2) && (erb(&IP->IP3) == IP3) && (erb(&IP->IP4) == IP4)) return 1;
    d508:	18 17       	cp	r17, r24
    d50a:	49 f0       	breq	.+18     	; 0xd51e <IP_E_compare_Const+0x2e>
	else return 0;
}
    d50c:	90 e0       	ldi	r25, 0x00	; 0
    d50e:	89 2f       	mov	r24, r25
    d510:	df 91       	pop	r29
    d512:	cf 91       	pop	r28
    d514:	1f 91       	pop	r17
    d516:	0f 91       	pop	r16
    d518:	ff 90       	pop	r15
    d51a:	ef 90       	pop	r14
    d51c:	08 95       	ret
    d51e:	ce 01       	movw	r24, r28
    d520:	01 96       	adiw	r24, 0x01	; 1
    d522:	0e 94 03 7d 	call	0xfa06	; 0xfa06 <__eerd_byte_m2560>
uint8_t IP_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	if((IP->IP1 == IP1) && (IP->IP2 == IP2) && (IP->IP3 == IP3) && (IP->IP4 == IP4)) return 1;
	else return 0;
}
uint8_t IP_E_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	if((erb(&IP->IP1) == IP1) && (erb(&IP->IP2) == IP2) && (erb(&IP->IP3) == IP3) && (erb(&IP->IP4) == IP4)) return 1;
    d526:	f8 16       	cp	r15, r24
    d528:	89 f7       	brne	.-30     	; 0xd50c <IP_E_compare_Const+0x1c>
    d52a:	ce 01       	movw	r24, r28
    d52c:	02 96       	adiw	r24, 0x02	; 2
    d52e:	0e 94 03 7d 	call	0xfa06	; 0xfa06 <__eerd_byte_m2560>
    d532:	e8 16       	cp	r14, r24
    d534:	59 f7       	brne	.-42     	; 0xd50c <IP_E_compare_Const+0x1c>
    d536:	ce 01       	movw	r24, r28
    d538:	03 96       	adiw	r24, 0x03	; 3
    d53a:	0e 94 03 7d 	call	0xfa06	; 0xfa06 <__eerd_byte_m2560>
    d53e:	90 e0       	ldi	r25, 0x00	; 0
    d540:	08 13       	cpse	r16, r24
    d542:	91 e0       	ldi	r25, 0x01	; 1
    d544:	81 e0       	ldi	r24, 0x01	; 1
    d546:	98 27       	eor	r25, r24
    d548:	e2 cf       	rjmp	.-60     	; 0xd50e <IP_E_compare_Const+0x1e>

0000d54a <MB_M_Init>:
}

// ~~~~~~~~~~~~~~~~~~~~
void
MB_M_Init(uint8_t MB_N)
{
    d54a:	cf 92       	push	r12
    d54c:	df 92       	push	r13
    d54e:	ef 92       	push	r14
    d550:	ff 92       	push	r15
    d552:	0f 93       	push	r16
    d554:	1f 93       	push	r17
	MB_M_Period[MB_N]		= erw(&MB_M_Param_EE[MB_N].Period);
    d556:	e8 2e       	mov	r14, r24
    d558:	ff 24       	eor	r15, r15
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    d55a:	87 01       	movw	r16, r14
    d55c:	00 0f       	add	r16, r16
    d55e:	11 1f       	adc	r17, r17
    d560:	00 0f       	add	r16, r16
    d562:	11 1f       	adc	r17, r17
    d564:	0e 0d       	add	r16, r14
    d566:	1f 1d       	adc	r17, r15
    d568:	82 e3       	ldi	r24, 0x32	; 50
    d56a:	c8 2e       	mov	r12, r24
    d56c:	81 e0       	ldi	r24, 0x01	; 1
    d56e:	d8 2e       	mov	r13, r24
    d570:	c6 01       	movw	r24, r12
    d572:	80 0f       	add	r24, r16
    d574:	91 1f       	adc	r25, r17
    d576:	0e 94 11 7d 	call	0xfa22	; 0xfa22 <__eerd_word_m2560>
    d57a:	f7 01       	movw	r30, r14
    d57c:	ee 0f       	add	r30, r30
    d57e:	ff 1f       	adc	r31, r31
    d580:	ec 55       	subi	r30, 0x5C	; 92
    d582:	f9 4f       	sbci	r31, 0xF9	; 249
    d584:	91 83       	std	Z+1, r25	; 0x01
    d586:	80 83       	st	Z, r24
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    d588:	0e 5f       	subi	r16, 0xFE	; 254
    d58a:	1f 4f       	sbci	r17, 0xFF	; 255
    d58c:	c6 01       	movw	r24, r12
    d58e:	80 0f       	add	r24, r16
    d590:	91 1f       	adc	r25, r17
    d592:	0e 94 03 7d 	call	0xfa06	; 0xfa06 <__eerd_byte_m2560>
	MB_M_Timeout[MB_N]	= erb(&MB_M_Param_EE[MB_N].Timeout);
    d596:	f7 01       	movw	r30, r14
    d598:	e9 52       	subi	r30, 0x29	; 41
    d59a:	f7 4f       	sbci	r31, 0xF7	; 247
    d59c:	80 83       	st	Z, r24
    d59e:	0f 5f       	subi	r16, 0xFF	; 255
    d5a0:	1f 4f       	sbci	r17, 0xFF	; 255
    d5a2:	c6 01       	movw	r24, r12
    d5a4:	80 0f       	add	r24, r16
    d5a6:	91 1f       	adc	r25, r17
    d5a8:	0e 94 03 7d 	call	0xfa06	; 0xfa06 <__eerd_byte_m2560>
	MB_M_Try[MB_N]			= erb(&MB_M_Param_EE[MB_N].Try);
    d5ac:	f7 01       	movw	r30, r14
    d5ae:	ef 50       	subi	r30, 0x0F	; 15
    d5b0:	f9 4f       	sbci	r31, 0xF9	; 249
    d5b2:	80 83       	st	Z, r24
    d5b4:	0f 5f       	subi	r16, 0xFF	; 255
    d5b6:	1f 4f       	sbci	r17, 0xFF	; 255
    d5b8:	c6 01       	movw	r24, r12
    d5ba:	80 0f       	add	r24, r16
    d5bc:	91 1f       	adc	r25, r17
    d5be:	0e 94 03 7d 	call	0xfa06	; 0xfa06 <__eerd_byte_m2560>
	MB_M_TimeOff[MB_N]	= erb(&MB_M_Param_EE[MB_N].TimeOff);
    d5c2:	26 ed       	ldi	r18, 0xD6	; 214
    d5c4:	35 e0       	ldi	r19, 0x05	; 5
    d5c6:	e2 0e       	add	r14, r18
    d5c8:	f3 1e       	adc	r15, r19
    d5ca:	f7 01       	movw	r30, r14
    d5cc:	80 83       	st	Z, r24

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    d5ce:	80 91 cd 02 	lds	r24, 0x02CD
	VacantTimer16Sys += n;
    d5d2:	8d 5f       	subi	r24, 0xFD	; 253
    d5d4:	80 93 cd 02 	sts	0x02CD, r24
    d5d8:	83 50       	subi	r24, 0x03	; 3

	TD_MB = Timer16SysAlloc(Modbus_Qt*3);
    d5da:	80 93 df 04 	sts	0x04DF, r24
}
    d5de:	1f 91       	pop	r17
    d5e0:	0f 91       	pop	r16
    d5e2:	ff 90       	pop	r15
    d5e4:	ef 90       	pop	r14
    d5e6:	df 90       	pop	r13
    d5e8:	cf 90       	pop	r12
    d5ea:	08 95       	ret

0000d5ec <MB_S_Init>:
}

// ~~~~~~~~~~~~~~~~~~~~
void
MB_S_Init(uint8_t MB_N)
{
    d5ec:	0f 93       	push	r16
    d5ee:	1f 93       	push	r17
    d5f0:	08 2f       	mov	r16, r24
    d5f2:	10 e0       	ldi	r17, 0x00	; 0
    d5f4:	c8 01       	movw	r24, r16
    d5f6:	89 5c       	subi	r24, 0xC9	; 201
    d5f8:	9e 4f       	sbci	r25, 0xFE	; 254
    d5fa:	0e 94 03 7d 	call	0xfa06	; 0xfa06 <__eerd_byte_m2560>
	#ifndef MB_ADDR_DIP_SW
		MB_NativeAddr[MB_N] = erb(MB_NativeAddr_EE+MB_N);
    d5fe:	09 52       	subi	r16, 0x29	; 41
    d600:	1a 4f       	sbci	r17, 0xFA	; 250
    d602:	f8 01       	movw	r30, r16
    d604:	80 83       	st	Z, r24
	#endif
}
    d606:	1f 91       	pop	r17
    d608:	0f 91       	pop	r16
    d60a:	08 95       	ret

0000d60c <SetBAUD>:
}

// ~~~~~~~~~~~~~~~~~~
void
SetBAUD(uint8_t MB_N)
{
    d60c:	ef 92       	push	r14
    d60e:	ff 92       	push	r15
    d610:	0f 93       	push	r16
    d612:	1f 93       	push	r17
	BR_Val *ptrBR_Val = BR_Tbl + (MB_BitRate_RAM[MB_N] = erb(&MB_Param[MB_N].BitRate));
    d614:	08 2f       	mov	r16, r24
    d616:	10 e0       	ldi	r17, 0x00	; 0
    d618:	78 01       	movw	r14, r16
    d61a:	ee 0c       	add	r14, r14
    d61c:	ff 1c       	adc	r15, r15
    d61e:	e0 0e       	add	r14, r16
    d620:	f1 1e       	adc	r15, r17
    d622:	c7 01       	movw	r24, r14
    d624:	8a 5f       	subi	r24, 0xFA	; 250
    d626:	9f 4f       	sbci	r25, 0xFF	; 255
    d628:	0e 94 03 7d 	call	0xfa06	; 0xfa06 <__eerd_byte_m2560>
    d62c:	98 2f       	mov	r25, r24
    d62e:	f8 01       	movw	r30, r16
    d630:	e4 58       	subi	r30, 0x84	; 132
    d632:	f8 4f       	sbci	r31, 0xF8	; 248
    d634:	80 83       	st	Z, r24
    d636:	83 e0       	ldi	r24, 0x03	; 3
    d638:	98 9f       	mul	r25, r24
    d63a:	b0 01       	movw	r22, r0
    d63c:	11 24       	eor	r1, r1
    d63e:	6e 5e       	subi	r22, 0xEE	; 238
    d640:	7c 4f       	sbci	r23, 0xFC	; 252

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    d642:	00 0f       	add	r16, r16
    d644:	11 1f       	adc	r17, r17
    d646:	00 0f       	add	r16, r16
    d648:	11 1f       	adc	r17, r17
    d64a:	c8 01       	movw	r24, r16
    d64c:	88 0f       	add	r24, r24
    d64e:	99 1f       	adc	r25, r25
    d650:	88 0f       	add	r24, r24
    d652:	99 1f       	adc	r25, r25
    d654:	80 0f       	add	r24, r16
    d656:	91 1f       	adc	r25, r17
    d658:	0a 96       	adiw	r24, 0x0a	; 10
    d65a:	42 ee       	ldi	r20, 0xE2	; 226
    d65c:	5b e2       	ldi	r21, 0x2B	; 43
    d65e:	9a 01       	movw	r18, r20
    d660:	28 0f       	add	r18, r24
    d662:	39 1f       	adc	r19, r25
    d664:	f9 01       	movw	r30, r18
    d666:	a5 91       	lpm	r26, Z+
    d668:	b4 91       	lpm	r27, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    d66a:	fb 01       	movw	r30, r22
    d66c:	24 91       	lpm	r18, Z+
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		USART_Reg(MB_N, ubrrl) = prb((uint8_t*)&ptrBR_Val->UBRR);
    d66e:	2c 93       	st	X, r18

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    d670:	02 97       	sbiw	r24, 0x02	; 2
    d672:	84 0f       	add	r24, r20
    d674:	95 1f       	adc	r25, r21
    d676:	fc 01       	movw	r30, r24
    d678:	a5 91       	lpm	r26, Z+
    d67a:	b4 91       	lpm	r27, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    d67c:	6f 5f       	subi	r22, 0xFF	; 255
    d67e:	7f 4f       	sbci	r23, 0xFF	; 255
    d680:	fb 01       	movw	r30, r22
    d682:	84 91       	lpm	r24, Z+
		USART_Reg(MB_N, ubrrh) = prb((uint8_t*)&ptrBR_Val->UBRR+1);
    d684:	8c 93       	st	X, r24

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    d686:	c7 01       	movw	r24, r14
    d688:	88 0f       	add	r24, r24
    d68a:	99 1f       	adc	r25, r25
    d68c:	87 50       	subi	r24, 0x07	; 7
    d68e:	94 4d       	sbci	r25, 0xD4	; 212
    d690:	fc 01       	movw	r30, r24
    d692:	a5 91       	lpm	r26, Z+
    d694:	b4 91       	lpm	r27, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    d696:	6f 5f       	subi	r22, 0xFF	; 255
    d698:	7f 4f       	sbci	r23, 0xFF	; 255
    d69a:	fb 01       	movw	r30, r22
    d69c:	84 91       	lpm	r24, Z+

		*(uint8_t*)prp(&MB_Timer[MB_N].OCR) = prb(&ptrBR_Val->Time35);
    d69e:	8c 93       	st	X, r24
		usart->BAUDCTRLA = prb((uint8_t*)&ptrBR_Val->UBRR);
		usart->BAUDCTRLB = prb((uint8_t*)&ptrBR_Val->UBRR+1) + USART_BSCALE0_bm;

		((TC1_t*)prp(MB_Timer+MB_N))->PER = prw(&ptrBR_Val->Time35);
	#endif
}
    d6a0:	1f 91       	pop	r17
    d6a2:	0f 91       	pop	r16
    d6a4:	ff 90       	pop	r15
    d6a6:	ef 90       	pop	r14
    d6a8:	08 95       	ret

0000d6aa <Key_MB0_BitRate>:
	{" BAUD: }}}}}bps     ", NULL, F_MB##N##_Baud}																														\
};																																																					\
MenuPage MenuModbus##N = {SetMenu(L_MB##N), 1};

#if Modbus_Qt == 1
	M_Modbus(0)
    d6aa:	80 e0       	ldi	r24, 0x00	; 0
    d6ac:	0e 94 06 6b 	call	0xd60c	; 0xd60c <SetBAUD>
    d6b0:	08 95       	ret

0000d6b2 <SetParity>:
// ~~~

// ~~~~~~~~~~~~~~~~~~~~
void
SetParity(uint8_t MB_N)
{
    d6b2:	ff 92       	push	r15
    d6b4:	0f 93       	push	r16
    d6b6:	1f 93       	push	r17
    d6b8:	cf 93       	push	r28
    d6ba:	df 93       	push	r29
	uint8_t Parity = erb(&MB_Param[MB_N].Parity), S_B = erb(&MB_Param[MB_N].StopBits);
    d6bc:	c8 2f       	mov	r28, r24
    d6be:	d0 e0       	ldi	r29, 0x00	; 0
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    d6c0:	8e 01       	movw	r16, r28
    d6c2:	00 0f       	add	r16, r16
    d6c4:	11 1f       	adc	r17, r17
    d6c6:	0c 0f       	add	r16, r28
    d6c8:	1d 1f       	adc	r17, r29
    d6ca:	c8 01       	movw	r24, r16
    d6cc:	8c 5f       	subi	r24, 0xFC	; 252
    d6ce:	9f 4f       	sbci	r25, 0xFF	; 255
    d6d0:	0e 94 03 7d 	call	0xfa06	; 0xfa06 <__eerd_byte_m2560>
    d6d4:	f8 2e       	mov	r15, r24
    d6d6:	0b 5f       	subi	r16, 0xFB	; 251
    d6d8:	1f 4f       	sbci	r17, 0xFF	; 255
    d6da:	c8 01       	movw	r24, r16
    d6dc:	0e 94 03 7d 	call	0xfa06	; 0xfa06 <__eerd_byte_m2560>
    d6e0:	48 2f       	mov	r20, r24
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		uint8_t ucsrc = (~(1<<6) |(1<<2) |(1<<1)) &~(1<<0);
		if (Parity==NoParity) {
    d6e2:	ff 20       	and	r15, r15
    d6e4:	e1 f4       	brne	.+56     	; 0xd71e <SetParity+0x6c>
			ucsrc &=~(1<<5) &~(1<<4);
			switch (S_B) {
    d6e6:	81 30       	cpi	r24, 0x01	; 1
    d6e8:	09 f4       	brne	.+2      	; 0xd6ec <SetParity+0x3a>
    d6ea:	3d c0       	rjmp	.+122    	; 0xd766 <SetParity+0xb4>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    d6ec:	ce 01       	movw	r24, r28
    d6ee:	88 0f       	add	r24, r24
    d6f0:	99 1f       	adc	r25, r25
    d6f2:	88 0f       	add	r24, r24
    d6f4:	99 1f       	adc	r25, r25
    d6f6:	9c 01       	movw	r18, r24
    d6f8:	22 0f       	add	r18, r18
    d6fa:	33 1f       	adc	r19, r19
    d6fc:	22 0f       	add	r18, r18
    d6fe:	33 1f       	adc	r19, r19
    d700:	28 0f       	add	r18, r24
    d702:	39 1f       	adc	r19, r25
    d704:	28 51       	subi	r18, 0x18	; 24
    d706:	34 4d       	sbci	r19, 0xD4	; 212
    d708:	f9 01       	movw	r30, r18
    d70a:	a5 91       	lpm	r26, Z+
    d70c:	b4 91       	lpm	r27, Z+
		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
			ucsrc  |=(1<<7);
		#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
			ucsrc &=~(1<<7);
		#endif
		USART_Reg(MB_N, ucsrc) = ucsrc;
    d70e:	8e e0       	ldi	r24, 0x0E	; 14
    d710:	8c 93       	st	X, r24
			}
		}
	#endif
	if (Parity!=NoParity && S_B!=1)
		ewb(&MB_Param[MB_N].StopBits, 1);
}
    d712:	df 91       	pop	r29
    d714:	cf 91       	pop	r28
    d716:	1f 91       	pop	r17
    d718:	0f 91       	pop	r16
    d71a:	ff 90       	pop	r15
    d71c:	08 95       	ret
				break;
			}
		}
		else {
			ucsrc &=~(1<<3);
			switch (Parity) {
    d71e:	81 e0       	ldi	r24, 0x01	; 1
    d720:	f8 16       	cp	r15, r24
    d722:	f9 f0       	breq	.+62     	; 0xd762 <SetParity+0xb0>
			}
		}
	#endif
	if (Parity!=NoParity && S_B!=1)
		ewb(&MB_Param[MB_N].StopBits, 1);
}
    d724:	56 e3       	ldi	r21, 0x36	; 54
    d726:	ce 01       	movw	r24, r28
    d728:	88 0f       	add	r24, r24
    d72a:	99 1f       	adc	r25, r25
    d72c:	88 0f       	add	r24, r24
    d72e:	99 1f       	adc	r25, r25
    d730:	9c 01       	movw	r18, r24
    d732:	22 0f       	add	r18, r18
    d734:	33 1f       	adc	r19, r19
    d736:	22 0f       	add	r18, r18
    d738:	33 1f       	adc	r19, r19
    d73a:	28 0f       	add	r18, r24
    d73c:	39 1f       	adc	r19, r25
    d73e:	28 51       	subi	r18, 0x18	; 24
    d740:	34 4d       	sbci	r19, 0xD4	; 212
    d742:	f9 01       	movw	r30, r18
    d744:	a5 91       	lpm	r26, Z+
    d746:	b4 91       	lpm	r27, Z+
		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
			ucsrc  |=(1<<7);
		#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
			ucsrc &=~(1<<7);
		#endif
		USART_Reg(MB_N, ucsrc) = ucsrc;
    d748:	5c 93       	st	X, r21
				usart->CTRLC |=USART_PMODE_ODD_gc;
				break;
			}
		}
	#endif
	if (Parity!=NoParity && S_B!=1)
    d74a:	41 30       	cpi	r20, 0x01	; 1
    d74c:	21 f0       	breq	.+8      	; 0xd756 <SetParity+0xa4>
		ewb(&MB_Param[MB_N].StopBits, 1);
    d74e:	c8 01       	movw	r24, r16
    d750:	61 e0       	ldi	r22, 0x01	; 1
    d752:	0e 94 d6 4a 	call	0x95ac	; 0x95ac <ewb>
}
    d756:	df 91       	pop	r29
    d758:	cf 91       	pop	r28
    d75a:	1f 91       	pop	r17
    d75c:	0f 91       	pop	r16
    d75e:	ff 90       	pop	r15
    d760:	08 95       	ret
				break;
			}
		}
		else {
			ucsrc &=~(1<<3);
			switch (Parity) {
    d762:	56 e2       	ldi	r21, 0x26	; 38
    d764:	e0 cf       	rjmp	.-64     	; 0xd726 <SetParity+0x74>
    d766:	ce 01       	movw	r24, r28
    d768:	88 0f       	add	r24, r24
    d76a:	99 1f       	adc	r25, r25
    d76c:	88 0f       	add	r24, r24
    d76e:	99 1f       	adc	r25, r25
    d770:	9c 01       	movw	r18, r24
    d772:	22 0f       	add	r18, r18
    d774:	33 1f       	adc	r19, r19
    d776:	22 0f       	add	r18, r18
    d778:	33 1f       	adc	r19, r19
    d77a:	28 0f       	add	r18, r24
    d77c:	39 1f       	adc	r19, r25
    d77e:	28 51       	subi	r18, 0x18	; 24
    d780:	34 4d       	sbci	r19, 0xD4	; 212
    d782:	f9 01       	movw	r30, r18
    d784:	a5 91       	lpm	r26, Z+
    d786:	b4 91       	lpm	r27, Z+
		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
			ucsrc  |=(1<<7);
		#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
			ucsrc &=~(1<<7);
		#endif
		USART_Reg(MB_N, ucsrc) = ucsrc;
    d788:	86 e0       	ldi	r24, 0x06	; 6
    d78a:	8c 93       	st	X, r24
			}
		}
	#endif
	if (Parity!=NoParity && S_B!=1)
		ewb(&MB_Param[MB_N].StopBits, 1);
}
    d78c:	df 91       	pop	r29
    d78e:	cf 91       	pop	r28
    d790:	1f 91       	pop	r17
    d792:	0f 91       	pop	r16
    d794:	ff 90       	pop	r15
    d796:	08 95       	ret

0000d798 <Key_MB0_Parity>:
    d798:	80 e0       	ldi	r24, 0x00	; 0
    d79a:	0e 94 59 6b 	call	0xd6b2	; 0xd6b2 <SetParity>
    d79e:	08 95       	ret

0000d7a0 <MB_Init>:

// ~~~~~~~~~~
void
MB_Init(void)
{
	MB_PLC_Init();
    d7a0:	0e 94 2f 1d 	call	0x3a5e	; 0x3a5e <MB_PLC_Init>
		PORTE.DIR |=(1<<3);
	#endif
	for (uint8_t MB_N=0; MB_N<Modbus_Qt; MB_N++) {
		void MB_S_Init(uint8_t);
		void MB_M_Init(uint8_t);
		MB_State[MB_N] = MB_Initi;
    d7a4:	10 92 b9 05 	sts	0x05B9, r1
    d7a8:	84 ee       	ldi	r24, 0xE4	; 228
    d7aa:	9b e2       	ldi	r25, 0x2B	; 43
    d7ac:	fc 01       	movw	r30, r24
    d7ae:	a5 91       	lpm	r26, Z+
    d7b0:	b4 91       	lpm	r27, Z+
		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
			USART_Reg(MB_N, ucsra) = ~(1<<1) &~(1<<0);
    d7b2:	8c ef       	ldi	r24, 0xFC	; 252
    d7b4:	8c 93       	st	X, r24
    d7b6:	86 ee       	ldi	r24, 0xE6	; 230
    d7b8:	9b e2       	ldi	r25, 0x2B	; 43
    d7ba:	fc 01       	movw	r30, r24
    d7bc:	a5 91       	lpm	r26, Z+
    d7be:	b4 91       	lpm	r27, Z+
			USART_Reg(MB_N, ucsrb) = (((1<<7) &~(1<<6) &~(1<<5)) |(1<<4) |(1<<3)) &~(1<<2);
    d7c0:	88 e9       	ldi	r24, 0x98	; 152
    d7c2:	8c 93       	st	X, r24
			tc->CTRLD = TC_EVACT_OFF_gc;
			//tc->CTRLE = TC1_BYTEM_bm;
			tc->INTCTRLA |=TC_ERRINTLVL_OFF_gc;
			tc->INTCTRLB = 0;
		#endif
		SetParity(MB_N);
    d7c4:	80 e0       	ldi	r24, 0x00	; 0
    d7c6:	0e 94 59 6b 	call	0xd6b2	; 0xd6b2 <SetParity>
		SetBAUD(MB_N);
    d7ca:	80 e0       	ldi	r24, 0x00	; 0
    d7cc:	0e 94 06 6b 	call	0xd60c	; 0xd60c <SetBAUD>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    d7d0:	e6 ef       	ldi	r30, 0xF6	; 246
    d7d2:	fb e2       	ldi	r31, 0x2B	; 43
    d7d4:	84 91       	lpm	r24, Z+
		switch (prb(MB_Role+MB_N)) {
    d7d6:	88 23       	and	r24, r24
    d7d8:	59 f4       	brne	.+22     	; 0xd7f0 <MB_Init+0x50>
		case Role_Slave:
			MB_S_Init(MB_N);
    d7da:	80 e0       	ldi	r24, 0x00	; 0
    d7dc:	0e 94 f6 6a 	call	0xd5ec	; 0xd5ec <MB_S_Init>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    d7e0:	8b ef       	ldi	r24, 0xFB	; 251
    d7e2:	9b e2       	ldi	r25, 0x2B	; 43
    d7e4:	fc 01       	movw	r30, r24
    d7e6:	25 91       	lpm	r18, Z+
    d7e8:	34 91       	lpm	r19, Z+
			break;
		case Role_Master:
			MB_M_Init(MB_N);
			break;
		}
		MB_StartTimer(MB_N);
    d7ea:	f9 01       	movw	r30, r18
    d7ec:	19 95       	eicall
	}
}
    d7ee:	08 95       	ret
			tc->INTCTRLA |=TC_ERRINTLVL_OFF_gc;
			tc->INTCTRLB = 0;
		#endif
		SetParity(MB_N);
		SetBAUD(MB_N);
		switch (prb(MB_Role+MB_N)) {
    d7f0:	81 30       	cpi	r24, 0x01	; 1
    d7f2:	b1 f7       	brne	.-20     	; 0xd7e0 <MB_Init+0x40>
		case Role_Slave:
			MB_S_Init(MB_N);
			break;
		case Role_Master:
			MB_M_Init(MB_N);
    d7f4:	80 e0       	ldi	r24, 0x00	; 0
    d7f6:	0e 94 a5 6a 	call	0xd54a	; 0xd54a <MB_M_Init>
    d7fa:	f2 cf       	rjmp	.-28     	; 0xd7e0 <MB_Init+0x40>

0000d7fc <USART_Init>:

// ~~~~~~~~~~~~~
void
USART_Init(void)
{
	MB_Init();
    d7fc:	0e 94 d0 6b 	call	0xd7a0	; 0xd7a0 <MB_Init>
	#ifdef GSM
		GSM_Init();
    d800:	0e 94 45 38 	call	0x708a	; 0x708a <GSM_Init>
	#endif
	#ifdef UDP_EASY
		UDP_Init();
	#endif
}
    d804:	08 95       	ret

0000d806 <LCDBackLightStartTimer>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    d806:	81 e3       	ldi	r24, 0x31	; 49
    d808:	91 e0       	ldi	r25, 0x01	; 1
    d80a:	0e 94 03 7d 	call	0xfa06	; 0xfa06 <__eerd_byte_m2560>
			PORT_BACKLIGHT &= ~BACKLIGHT;
		#endif
		IntOn();
	}
	void LCDBackLightStartTimer(void){
		switch(erb(&BackLightTimeEE)){
    d80e:	82 30       	cpi	r24, 0x02	; 2
    d810:	e9 f0       	breq	.+58     	; 0xd84c <LCDBackLightStartTimer+0x46>
    d812:	83 30       	cpi	r24, 0x03	; 3
    d814:	58 f0       	brcs	.+22     	; 0xd82c <LCDBackLightStartTimer+0x26>
    d816:	83 30       	cpi	r24, 0x03	; 3
    d818:	01 f1       	breq	.+64     	; 0xd85a <LCDBackLightStartTimer+0x54>
    d81a:	84 30       	cpi	r24, 0x04	; 4
    d81c:	81 f0       	breq	.+32     	; 0xd83e <LCDBackLightStartTimer+0x38>
				break;	
			case BCKLT_10min:
				StartTimer16(TD_BackLight, 60000);
				break;
			default:
				StartTimer16(TD_BackLight, 3000);
    d81e:	80 91 cf 04 	lds	r24, 0x04CF
    d822:	68 eb       	ldi	r22, 0xB8	; 184
    d824:	7b e0       	ldi	r23, 0x0B	; 11
    d826:	0e 94 05 1a 	call	0x340a	; 0x340a <StartTimer16>
    d82a:	08 95       	ret
			PORT_BACKLIGHT &= ~BACKLIGHT;
		#endif
		IntOn();
	}
	void LCDBackLightStartTimer(void){
		switch(erb(&BackLightTimeEE)){
    d82c:	88 23       	and	r24, r24
    d82e:	b9 f7       	brne	.-18     	; 0xd81e <LCDBackLightStartTimer+0x18>
			case BCKLT_10sec:
				StartTimer16(TD_BackLight, 1000);
    d830:	80 91 cf 04 	lds	r24, 0x04CF
    d834:	68 ee       	ldi	r22, 0xE8	; 232
    d836:	73 e0       	ldi	r23, 0x03	; 3
    d838:	0e 94 05 1a 	call	0x340a	; 0x340a <StartTimer16>
    d83c:	08 95       	ret
				break;
			case BCKLT_3min:
				StartTimer16(TD_BackLight, 18000);
				break;	
			case BCKLT_10min:
				StartTimer16(TD_BackLight, 60000);
    d83e:	80 91 cf 04 	lds	r24, 0x04CF
    d842:	60 e6       	ldi	r22, 0x60	; 96
    d844:	7a ee       	ldi	r23, 0xEA	; 234
    d846:	0e 94 05 1a 	call	0x340a	; 0x340a <StartTimer16>
    d84a:	08 95       	ret
				break;
			case BCKLT_30sec:
				StartTimer16(TD_BackLight, 3000);
				break;
			case BCKLT_1min:
				StartTimer16(TD_BackLight, 6000);
    d84c:	80 91 cf 04 	lds	r24, 0x04CF
    d850:	60 e7       	ldi	r22, 0x70	; 112
    d852:	77 e1       	ldi	r23, 0x17	; 23
    d854:	0e 94 05 1a 	call	0x340a	; 0x340a <StartTimer16>
    d858:	08 95       	ret
				break;
			case BCKLT_3min:
				StartTimer16(TD_BackLight, 18000);
    d85a:	80 91 cf 04 	lds	r24, 0x04CF
    d85e:	60 e5       	ldi	r22, 0x50	; 80
    d860:	76 e4       	ldi	r23, 0x46	; 70
    d862:	0e 94 05 1a 	call	0x340a	; 0x340a <StartTimer16>
    d866:	08 95       	ret

0000d868 <LCDBackLightInit>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    d868:	9f b7       	in	r25, 0x3f	; 63
    d86a:	90 78       	andi	r25, 0x80	; 128
    d86c:	90 93 e5 02 	sts	0x02E5, r25
	cli();
    d870:	f8 94       	cli
	enum BACKLIGHT_TIMES{ BCKLT_10sec, BCKLT_30sec, BCKLT_1min,  BCKLT_3min,  BCKLT_10min};
	static uint8_t EEMEM BackLightTimeEE = BCKLT_10sec;

	void LCDBackLightInit(void){
		IntOff();	
		DDR_BACKLIGHT |= BACKLIGHT;
    d872:	80 91 0a 01 	lds	r24, 0x010A
    d876:	80 64       	ori	r24, 0x40	; 64
    d878:	80 93 0a 01 	sts	0x010A, r24

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    d87c:	99 23       	and	r25, r25
    d87e:	09 f0       	breq	.+2      	; 0xd882 <LCDBackLightInit+0x1a>
		sei();
    d880:	78 94       	sei

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    d882:	80 91 cd 02 	lds	r24, 0x02CD
	VacantTimer16Sys += n;
    d886:	8f 5f       	subi	r24, 0xFF	; 255
    d888:	80 93 cd 02 	sts	0x02CD, r24
    d88c:	81 50       	subi	r24, 0x01	; 1
		IntOn();	
		TD_BackLight = Timer16SysAlloc(1);
    d88e:	80 93 cf 04 	sts	0x04CF, r24
		if(BackLightMode != 2){
    d892:	80 91 49 06 	lds	r24, 0x0649
    d896:	82 30       	cpi	r24, 0x02	; 2
    d898:	21 f0       	breq	.+8      	; 0xd8a2 <LCDBackLightInit+0x3a>
			LCDBackLightOn();
    d89a:	0e 94 0f 27 	call	0x4e1e	; 0x4e1e <LCDBackLightOn>
			LCDBackLightStartTimer();
    d89e:	0e 94 03 6c 	call	0xd806	; 0xd806 <LCDBackLightStartTimer>
    d8a2:	08 95       	ret

0000d8a4 <LCD_Init>:
}

// ~~~~~~~~~~~~
void
LCD_Init (void)
{
    d8a4:	ef 92       	push	r14
    d8a6:	ff 92       	push	r15
    d8a8:	1f 93       	push	r17
    d8aa:	cf 93       	push	r28
    d8ac:	df 93       	push	r29
	uint8_t i, j;

	// LCD pins
	#ifdef Port_LCD_RW
		Port_LCD_RW &= ~LCD_RW;
    d8ae:	43 98       	cbi	0x08, 3	; 8
		DDR_LCD_RW |= LCD_RW;
    d8b0:	3b 9a       	sbi	0x07, 3	; 7
	#endif

	Port_LCD_RS &= ~LCD_RS;	
    d8b2:	44 98       	cbi	0x08, 4	; 8
	DDR_LCD_RS |=LCD_RS;
    d8b4:	3c 9a       	sbi	0x07, 4	; 7

	Port_LCD_E &= ~LCD_E;	
    d8b6:	42 98       	cbi	0x08, 2	; 8
	DDR_LCD_E |=LCD_E;
    d8b8:	3a 9a       	sbi	0x07, 2	; 7

	#ifdef Port_LCD_DB0	
		DDR_LCD_DB0 |=DB0;
    d8ba:	39 9a       	sbi	0x07, 1	; 7
		DDR_LCD_DB1 |=DB1;
    d8bc:	38 9a       	sbi	0x07, 0	; 7
		DDR_LCD_DB2 |=DB2;
    d8be:	99 9a       	sbi	0x13, 1	; 19
		DDR_LCD_DB3 |=DB3;
    d8c0:	98 9a       	sbi	0x13, 0	; 19
	#endif
	DDR_LCD_DB4 |=DB4;
    d8c2:	57 9a       	sbi	0x0a, 7	; 10
	DDR_LCD_DB5 |=DB5;
    d8c4:	56 9a       	sbi	0x0a, 6	; 10
	DDR_LCD_DB6 |=DB6;
    d8c6:	55 9a       	sbi	0x0a, 5	; 10
	DDR_LCD_DB7 |=DB7;
    d8c8:	80 91 0a 01 	lds	r24, 0x010A
    d8cc:	80 68       	ori	r24, 0x80	; 128
    d8ce:	80 93 0a 01 	sts	0x010A, r24
    d8d2:	21 e3       	ldi	r18, 0x31	; 49
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    d8d4:	40 ea       	ldi	r20, 0xA0	; 160
    d8d6:	5f e0       	ldi	r21, 0x0F	; 15
    d8d8:	ca 01       	movw	r24, r20
    d8da:	01 97       	sbiw	r24, 0x01	; 1
    d8dc:	f1 f7       	brne	.-4      	; 0xd8da <LCD_Init+0x36>

// ~~~~~~~~~~~~~~~~~~~~
void
Delay_ms(uint8_t Delay)
{
	while (Delay--)
    d8de:	21 50       	subi	r18, 0x01	; 1
    d8e0:	d8 f7       	brcc	.-10     	; 0xd8d8 <LCD_Init+0x34>
#endif
// ~~~~~~~~~~~
static void
LCD_Rst0(void)
{
	cli();
    d8e2:	f8 94       	cli
	Port_LCD_RS &=~LCD_RS;
    d8e4:	44 98       	cbi	0x08, 4	; 8
	LCD_FuncSet0();
    d8e6:	0e 94 69 25 	call	0x4ad2	; 0x4ad2 <LCD_FuncSet0>
	sei();
    d8ea:	78 94       	sei
    d8ec:	80 ea       	ldi	r24, 0xA0	; 160
    d8ee:	9f e0       	ldi	r25, 0x0F	; 15
    d8f0:	fc 01       	movw	r30, r24
    d8f2:	31 97       	sbiw	r30, 0x01	; 1
    d8f4:	f1 f7       	brne	.-4      	; 0xd8f2 <LCD_Init+0x4e>
    d8f6:	fc 01       	movw	r30, r24
    d8f8:	31 97       	sbiw	r30, 0x01	; 1
    d8fa:	f1 f7       	brne	.-4      	; 0xd8f8 <LCD_Init+0x54>
    d8fc:	fc 01       	movw	r30, r24
    d8fe:	31 97       	sbiw	r30, 0x01	; 1
    d900:	f1 f7       	brne	.-4      	; 0xd8fe <LCD_Init+0x5a>
    d902:	fc 01       	movw	r30, r24
    d904:	31 97       	sbiw	r30, 0x01	; 1
    d906:	f1 f7       	brne	.-4      	; 0xd904 <LCD_Init+0x60>
    d908:	01 97       	sbiw	r24, 0x01	; 1
    d90a:	f1 f7       	brne	.-4      	; 0xd908 <LCD_Init+0x64>

// ~~~~~~~~~~~
static void
LCD_Rst1(void)
{
	LCD_FuncSet0();
    d90c:	0e 94 69 25 	call	0x4ad2	; 0x4ad2 <LCD_FuncSet0>
	Delay_us(200);				// 100 us needs
    d910:	88 ec       	ldi	r24, 0xC8	; 200
    d912:	90 e0       	ldi	r25, 0x00	; 0
    d914:	0e 94 17 1d 	call	0x3a2e	; 0x3a2e <Delay_us>
	LCD_FuncSet0();
    d918:	0e 94 69 25 	call	0x4ad2	; 0x4ad2 <LCD_FuncSet0>
	Delay_us(LCD_Delay);
    d91c:	82 e3       	ldi	r24, 0x32	; 50
    d91e:	90 e0       	ldi	r25, 0x00	; 0
    d920:	0e 94 17 1d 	call	0x3a2e	; 0x3a2e <Delay_us>
	#ifdef Port_LCD_DB0	
		LCD_FuncSet0();
    d924:	0e 94 69 25 	call	0x4ad2	; 0x4ad2 <LCD_FuncSet0>
	#else
		LCD_FuncSet1();
	#endif
//// BF(Busy flag) can be checked follow
	Delay_us(LCD_Delay);
    d928:	82 e3       	ldi	r24, 0x32	; 50
    d92a:	90 e0       	ldi	r25, 0x00	; 0
    d92c:	0e 94 17 1d 	call	0x3a2e	; 0x3a2e <Delay_us>
	Port_LCD_RS |=LCD_RS;
    d930:	44 9a       	sbi	0x08, 4	; 8

	LCD_Rst0();
	Delay_ms(5);		// 4.1 ms needs
	LCD_Rst1();

	Port_LCD_RS &=~LCD_RS;
    d932:	44 98       	cbi	0x08, 4	; 8

	#ifdef Port_LCD_DB0	
		Send_I(0b00111000);	//; 8-bits DL, 2 lines, 5x7 dots
    d934:	88 e3       	ldi	r24, 0x38	; 56
    d936:	0e 94 62 25 	call	0x4ac4	; 0x4ac4 <Send_I>
	#else
		Send_I(0b00101000);	//; 4-bits DL, 2 lines, 5x7 dots
	#endif
	Send_I(0b00001100);	//; Display on, cursor off, blink off	
    d93a:	8c e0       	ldi	r24, 0x0C	; 12
    d93c:	0e 94 62 25 	call	0x4ac4	; 0x4ac4 <Send_I>
	Send_I(0b00000110);	//; cursor shift right, no display shift
    d940:	86 e0       	ldi	r24, 0x06	; 6
    d942:	0e 94 62 25 	call	0x4ac4	; 0x4ac4 <Send_I>


	Send_I(0b01000000);	//;    CG RAM   0.
    d946:	80 e4       	ldi	r24, 0x40	; 64
    d948:	0e 94 62 25 	call	0x4ac4	; 0x4ac4 <Send_I>
	Port_LCD_RS |=LCD_RS;
    d94c:	44 9a       	sbi	0x08, 4	; 8
    d94e:	79 e0       	ldi	r23, 0x09	; 9
    d950:	e7 2e       	mov	r14, r23
    d952:	7c e2       	ldi	r23, 0x2C	; 44
    d954:	f7 2e       	mov	r15, r23
	for (i=0; i<8; i++)
    d956:	e7 01       	movw	r28, r14
    d958:	10 e0       	ldi	r17, 0x00	; 0

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    d95a:	fe 01       	movw	r30, r28
    d95c:	84 91       	lpm	r24, Z+
		for (j=0; j<8; j++)
			Send_I(prb(CGRAM_LCD[i]+j));
    d95e:	0e 94 62 25 	call	0x4ac4	; 0x4ac4 <Send_I>


	Send_I(0b01000000);	//;    CG RAM   0.
	Port_LCD_RS |=LCD_RS;
	for (i=0; i<8; i++)
		for (j=0; j<8; j++)
    d962:	1f 5f       	subi	r17, 0xFF	; 255
    d964:	21 96       	adiw	r28, 0x01	; 1
    d966:	18 30       	cpi	r17, 0x08	; 8
    d968:	c1 f7       	brne	.-16     	; 0xd95a <LCD_Init+0xb6>
    d96a:	88 e0       	ldi	r24, 0x08	; 8
    d96c:	90 e0       	ldi	r25, 0x00	; 0
    d96e:	e8 0e       	add	r14, r24
    d970:	f9 1e       	adc	r15, r25
	Send_I(0b00000110);	//; cursor shift right, no display shift


	Send_I(0b01000000);	//;    CG RAM   0.
	Port_LCD_RS |=LCD_RS;
	for (i=0; i<8; i++)
    d972:	99 e4       	ldi	r25, 0x49	; 73
    d974:	e9 16       	cp	r14, r25
    d976:	9c e2       	ldi	r25, 0x2C	; 44
    d978:	f9 06       	cpc	r15, r25
    d97a:	69 f7       	brne	.-38     	; 0xd956 <LCD_Init+0xb2>
		for (j=0; j<8; j++)
			Send_I(prb(CGRAM_LCD[i]+j));

	Port_LCD_RS &=~LCD_RS;
    d97c:	44 98       	cbi	0x08, 4	; 8
	Send(0b00000001);
    d97e:	81 e0       	ldi	r24, 0x01	; 1
    d980:	0e 94 21 25 	call	0x4a42	; 0x4a42 <Send>
    d984:	80 ea       	ldi	r24, 0xA0	; 160
    d986:	9f e0       	ldi	r25, 0x0F	; 15
    d988:	fc 01       	movw	r30, r24
    d98a:	31 97       	sbiw	r30, 0x01	; 1
    d98c:	f1 f7       	brne	.-4      	; 0xd98a <LCD_Init+0xe6>
    d98e:	fc 01       	movw	r30, r24
    d990:	31 97       	sbiw	r30, 0x01	; 1
    d992:	f1 f7       	brne	.-4      	; 0xd990 <LCD_Init+0xec>
    d994:	fc 01       	movw	r30, r24
    d996:	31 97       	sbiw	r30, 0x01	; 1
    d998:	f1 f7       	brne	.-4      	; 0xd996 <LCD_Init+0xf2>
    d99a:	fc 01       	movw	r30, r24
    d99c:	31 97       	sbiw	r30, 0x01	; 1
    d99e:	f1 f7       	brne	.-4      	; 0xd99c <LCD_Init+0xf8>
    d9a0:	01 97       	sbiw	r24, 0x01	; 1
    d9a2:	f1 f7       	brne	.-4      	; 0xd9a0 <LCD_Init+0xfc>
	Delay_ms(5);				// By trial
	Port_LCD_RS |=LCD_RS;
    d9a4:	44 9a       	sbi	0x08, 4	; 8
}

uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    d9a6:	80 91 cc 02 	lds	r24, 0x02CC
	VacantTimer8Sys += n;
    d9aa:	8f 5f       	subi	r24, 0xFF	; 255
    d9ac:	80 93 cc 02 	sts	0x02CC, r24
    d9b0:	81 50       	subi	r24, 0x01	; 1

	// Frame Timer
	TD_LCD = Timer8SysAlloc(1);
    d9b2:	80 93 ce 04 	sts	0x04CE, r24
    d9b6:	20 e0       	ldi	r18, 0x00	; 0
    d9b8:	30 e0       	ldi	r19, 0x00	; 0

	for (i=0; i<LCDYSz; i++)
		for (j=0; j<LCDXSz; j++)
			LCD_Buf[i][j] = ' ';
    d9ba:	40 e2       	ldi	r20, 0x20	; 32
	Port_LCD_RS |=LCD_RS;

	// Frame Timer
	TD_LCD = Timer8SysAlloc(1);

	for (i=0; i<LCDYSz; i++)
    d9bc:	c9 01       	movw	r24, r18
    d9be:	88 0f       	add	r24, r24
    d9c0:	99 1f       	adc	r25, r25
    d9c2:	82 0f       	add	r24, r18
    d9c4:	93 1f       	adc	r25, r19
    d9c6:	fc 01       	movw	r30, r24
    d9c8:	ee 0f       	add	r30, r30
    d9ca:	ff 1f       	adc	r31, r31
    d9cc:	ee 0f       	add	r30, r30
    d9ce:	ff 1f       	adc	r31, r31
    d9d0:	ee 0f       	add	r30, r30
    d9d2:	ff 1f       	adc	r31, r31
    d9d4:	e8 1b       	sub	r30, r24
    d9d6:	f9 0b       	sbc	r31, r25
    d9d8:	e1 5b       	subi	r30, 0xB1	; 177
    d9da:	f9 4f       	sbci	r31, 0xF9	; 249
    d9dc:	80 e0       	ldi	r24, 0x00	; 0
		for (j=0; j<LCDXSz; j++)
			LCD_Buf[i][j] = ' ';
    d9de:	41 93       	st	Z+, r20

	// Frame Timer
	TD_LCD = Timer8SysAlloc(1);

	for (i=0; i<LCDYSz; i++)
		for (j=0; j<LCDXSz; j++)
    d9e0:	8f 5f       	subi	r24, 0xFF	; 255
    d9e2:	84 31       	cpi	r24, 0x14	; 20
    d9e4:	e1 f7       	brne	.-8      	; 0xd9de <LCD_Init+0x13a>
    d9e6:	2f 5f       	subi	r18, 0xFF	; 255
    d9e8:	3f 4f       	sbci	r19, 0xFF	; 255
	Port_LCD_RS |=LCD_RS;

	// Frame Timer
	TD_LCD = Timer8SysAlloc(1);

	for (i=0; i<LCDYSz; i++)
    d9ea:	24 30       	cpi	r18, 0x04	; 4
    d9ec:	31 05       	cpc	r19, r1
    d9ee:	31 f7       	brne	.-52     	; 0xd9bc <LCD_Init+0x118>
		for (j=0; j<LCDXSz; j++)
			LCD_Buf[i][j] = ' ';

	#ifdef RTYP
		#ifndef QslRD
			*(uint8_t*)RTYP = R_PLC_Type;
    d9f0:	87 e0       	ldi	r24, 0x07	; 7
    d9f2:	80 93 3f 08 	sts	0x083F, r24
		#endif	
	#endif

	#ifdef BACKLIGHT
		LCDBackLightInit();
    d9f6:	0e 94 34 6c 	call	0xd868	; 0xd868 <LCDBackLightInit>
	#endif
}
    d9fa:	df 91       	pop	r29
    d9fc:	cf 91       	pop	r28
    d9fe:	1f 91       	pop	r17
    da00:	ff 90       	pop	r15
    da02:	ef 90       	pop	r14
    da04:	08 95       	ret

0000da06 <RTC_Summer_Time>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    da06:	83 e0       	ldi	r24, 0x03	; 3
    da08:	90 e0       	ldi	r25, 0x00	; 0
    da0a:	0e 94 03 7d 	call	0xfa06	; 0xfa06 <__eerd_byte_m2560>
	
	return 0;
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void RTC_Summer_Time(void){
	if(erb(&SummerTime)){
    da0e:	88 23       	and	r24, r24
    da10:	31 f0       	breq	.+12     	; 0xda1e <RTC_Summer_Time+0x18>
		//   ()  02:00:00   03:00:00    
		if( (Tm_Mon == 3) && (Tm_WDay == 0) && (Tm_MDay>=25) && (Tm_Hour == 2) ){
    da12:	90 91 7b 07 	lds	r25, 0x077B
    da16:	93 30       	cpi	r25, 0x03	; 3
    da18:	b1 f0       	breq	.+44     	; 0xda46 <RTC_Summer_Time+0x40>
				Tm_Hour=3;
				SetHour();
		}

		//   ()  04:00:00   03:00:00    
		if( (Tm_Mon == 10) && (Tm_WDay == 0) && (Tm_MDay>=25) ){
    da1a:	9a 30       	cpi	r25, 0x0A	; 10
    da1c:	09 f0       	breq	.+2      	; 0xda20 <RTC_Summer_Time+0x1a>
    da1e:	08 95       	ret
    da20:	80 91 4e 06 	lds	r24, 0x064E
    da24:	88 23       	and	r24, r24
    da26:	d9 f7       	brne	.-10     	; 0xda1e <RTC_Summer_Time+0x18>
    da28:	80 91 0d 0b 	lds	r24, 0x0B0D
    da2c:	89 31       	cpi	r24, 0x19	; 25
    da2e:	b8 f3       	brcs	.-18     	; 0xda1e <RTC_Summer_Time+0x18>
				if(Tm_Hour == 4){
    da30:	80 91 b8 05 	lds	r24, 0x05B8
    da34:	84 30       	cpi	r24, 0x04	; 4
    da36:	d1 f0       	breq	.+52     	; 0xda6c <RTC_Summer_Time+0x66>
						Tm_Hour=3;
						SetHour();
						NotSummerTimeFlag = 1;
					}
				}
				if(Tm_Hour < 2) NotSummerTimeFlag = 0;
    da38:	82 30       	cpi	r24, 0x02	; 2
    da3a:	38 f1       	brcs	.+78     	; 0xda8a <RTC_Summer_Time+0x84>
				if(Tm_Hour >= 5) NotSummerTimeFlag = 0;
    da3c:	85 30       	cpi	r24, 0x05	; 5
    da3e:	78 f3       	brcs	.-34     	; 0xda1e <RTC_Summer_Time+0x18>
    da40:	10 92 d4 05 	sts	0x05D4, r1
    da44:	08 95       	ret
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void RTC_Summer_Time(void){
	if(erb(&SummerTime)){
		//   ()  02:00:00   03:00:00    
		if( (Tm_Mon == 3) && (Tm_WDay == 0) && (Tm_MDay>=25) && (Tm_Hour == 2) ){
    da46:	80 91 4e 06 	lds	r24, 0x064E
    da4a:	88 23       	and	r24, r24
    da4c:	41 f7       	brne	.-48     	; 0xda1e <RTC_Summer_Time+0x18>
    da4e:	80 91 0d 0b 	lds	r24, 0x0B0D
    da52:	89 31       	cpi	r24, 0x19	; 25
    da54:	20 f3       	brcs	.-56     	; 0xda1e <RTC_Summer_Time+0x18>
    da56:	80 91 b8 05 	lds	r24, 0x05B8
    da5a:	82 30       	cpi	r24, 0x02	; 2
    da5c:	01 f7       	brne	.-64     	; 0xda1e <RTC_Summer_Time+0x18>
				Tm_Hour=3;
    da5e:	90 93 b8 05 	sts	0x05B8, r25
				SetHour();
    da62:	0e 94 f5 22 	call	0x45ea	; 0x45ea <SetHour>
    da66:	90 91 7b 07 	lds	r25, 0x077B
    da6a:	d7 cf       	rjmp	.-82     	; 0xda1a <RTC_Summer_Time+0x14>
		}

		//   ()  04:00:00   03:00:00    
		if( (Tm_Mon == 10) && (Tm_WDay == 0) && (Tm_MDay>=25) ){
				if(Tm_Hour == 4){
					if(!NotSummerTimeFlag){
    da6c:	80 91 d4 05 	lds	r24, 0x05D4
    da70:	88 23       	and	r24, r24
    da72:	a9 f6       	brne	.-86     	; 0xda1e <RTC_Summer_Time+0x18>
						Tm_Hour=3;
    da74:	83 e0       	ldi	r24, 0x03	; 3
    da76:	80 93 b8 05 	sts	0x05B8, r24
						SetHour();
    da7a:	0e 94 f5 22 	call	0x45ea	; 0x45ea <SetHour>
						NotSummerTimeFlag = 1;
    da7e:	81 e0       	ldi	r24, 0x01	; 1
    da80:	80 93 d4 05 	sts	0x05D4, r24
    da84:	80 91 b8 05 	lds	r24, 0x05B8
    da88:	d7 cf       	rjmp	.-82     	; 0xda38 <RTC_Summer_Time+0x32>
					}
				}
				if(Tm_Hour < 2) NotSummerTimeFlag = 0;
    da8a:	10 92 d4 05 	sts	0x05D4, r1
    da8e:	d6 cf       	rjmp	.-84     	; 0xda3c <RTC_Summer_Time+0x36>

0000da90 <TWI_In>:
}

// ~~~~~~~~~
void
TWI_In(void)
{
    da90:	cf 92       	push	r12
    da92:	ef 92       	push	r14
    da94:	0f 93       	push	r16
	if(Timer8Stopp(TD_TWI_Poll)){
    da96:	00 91 c9 04 	lds	r16, 0x04C9
    da9a:	80 2f       	mov	r24, r16
    da9c:	0e 94 1e 1b 	call	0x363c	; 0x363c <Timer8Stopp>
    daa0:	88 23       	and	r24, r24
    daa2:	e1 f0       	breq	.+56     	; 0xdadc <TWI_In+0x4c>

		if (TWI_Phase == PCF_START){
    daa4:	80 91 73 07 	lds	r24, 0x0773
    daa8:	88 23       	and	r24, r24
    daaa:	99 f1       	breq	.+102    	; 0xdb12 <TWI_In+0x82>
			StartTWI();		// Send Start
			TWI_Phase++;
			StartTimer8(TD_TWI_Timeout,40);
			return;
		}
		if(Timer8Stopp(TD_TWI_Timeout)){	// 
    daac:	80 91 ca 04 	lds	r24, 0x04CA
    dab0:	0e 94 1e 1b 	call	0x363c	; 0x363c <Timer8Stopp>
    dab4:	88 23       	and	r24, r24
    dab6:	09 f0       	breq	.+2      	; 0xdaba <TWI_In+0x2a>
    dab8:	4e c0       	rjmp	.+156    	; 0xdb56 <TWI_In+0xc6>
			TWI_Error();
			return;
		}

		if (!(TWCR &(1<<TWINT))) return;
    daba:	80 91 bc 00 	lds	r24, 0x00BC
    dabe:	87 ff       	sbrs	r24, 7
    dac0:	33 c0       	rjmp	.+102    	; 0xdb28 <TWI_In+0x98>

		switch(TWI_Phase) {
    dac2:	40 91 73 07 	lds	r20, 0x0773
    dac6:	84 2f       	mov	r24, r20
    dac8:	90 e0       	ldi	r25, 0x00	; 0
    daca:	fc 01       	movw	r30, r24
    dacc:	31 97       	sbiw	r30, 0x01	; 1
    dace:	e1 31       	cpi	r30, 0x11	; 17
    dad0:	f1 05       	cpc	r31, r1
    dad2:	08 f4       	brcc	.+2      	; 0xdad6 <TWI_In+0x46>
    dad4:	46 c0       	rjmp	.+140    	; 0xdb62 <TWI_In+0xd2>
			Tm_WDay = SetWeekday(Tm_Year, Tm_Mon, Tm_MDay);
			StartTimer8(TD_TWI_Poll, 49);
			TWI_Phase = 0xFF;
			break;
		}
		TWI_Phase++;
    dad6:	4f 5f       	subi	r20, 0xFF	; 255
    dad8:	40 93 73 07 	sts	0x0773, r20
	}//Timer8Stopp(TD_TWI)

	if( Timer16Stopp(TD_RTC_Check) && (TWI_Phase == PCF_START) ){
    dadc:	00 91 cb 04 	lds	r16, 0x04CB
    dae0:	80 2f       	mov	r24, r16
    dae2:	0e 94 41 1b 	call	0x3682	; 0x3682 <Timer16Stopp>
    dae6:	88 23       	and	r24, r24
    dae8:	f9 f0       	breq	.+62     	; 0xdb28 <TWI_In+0x98>
    daea:	80 91 73 07 	lds	r24, 0x0773
    daee:	88 23       	and	r24, r24
    daf0:	d9 f4       	brne	.+54     	; 0xdb28 <TWI_In+0x98>
		StartTimer16(TD_RTC_Check, 300);
    daf2:	80 2f       	mov	r24, r16
    daf4:	6c e2       	ldi	r22, 0x2C	; 44
    daf6:	71 e0       	ldi	r23, 0x01	; 1
    daf8:	0e 94 05 1a 	call	0x340a	; 0x340a <StartTimer16>
		if(RTC_Check() || PFC_Stop_bit){
    dafc:	0e 94 1a 24 	call	0x4834	; 0x4834 <RTC_Check>
    db00:	88 23       	and	r24, r24
    db02:	b1 f4       	brne	.+44     	; 0xdb30 <TWI_In+0xa0>
    db04:	80 91 cc 04 	lds	r24, 0x04CC
    db08:	88 23       	and	r24, r24
    db0a:	91 f4       	brne	.+36     	; 0xdb30 <TWI_In+0xa0>
			// RTC
			SetDateTime(TrueTime_Year, TrueTime_Mon, TrueTime_MDay, TrueTime_WDay, TrueTime_Hour, TrueTime_Min, TrueTime_Sec);
		}
		else RTC_GetTrueTime();
    db0c:	0e 94 d1 23 	call	0x47a2	; 0x47a2 <RTC_GetTrueTime>
    db10:	1f c0       	rjmp	.+62     	; 0xdb50 <TWI_In+0xc0>
TWI_In(void)
{
	if(Timer8Stopp(TD_TWI_Poll)){

		if (TWI_Phase == PCF_START){
			StartTWI();		// Send Start
    db12:	84 ea       	ldi	r24, 0xA4	; 164
    db14:	80 93 bc 00 	sts	0x00BC, r24
			TWI_Phase++;
    db18:	81 e0       	ldi	r24, 0x01	; 1
    db1a:	80 93 73 07 	sts	0x0773, r24
			StartTimer8(TD_TWI_Timeout,40);
    db1e:	80 91 ca 04 	lds	r24, 0x04CA
    db22:	68 e2       	ldi	r22, 0x28	; 40
    db24:	0e 94 ca 19 	call	0x3394	; 0x3394 <StartTimer8>
		}
		else RTC_GetTrueTime();

		RTC_Summer_Time();
	}
}
    db28:	0f 91       	pop	r16
    db2a:	ef 90       	pop	r14
    db2c:	cf 90       	pop	r12
    db2e:	08 95       	ret

	if( Timer16Stopp(TD_RTC_Check) && (TWI_Phase == PCF_START) ){
		StartTimer16(TD_RTC_Check, 300);
		if(RTC_Check() || PFC_Stop_bit){
			// RTC
			SetDateTime(TrueTime_Year, TrueTime_Mon, TrueTime_MDay, TrueTime_WDay, TrueTime_Hour, TrueTime_Min, TrueTime_Sec);
    db30:	80 91 71 07 	lds	r24, 0x0771
    db34:	60 91 c3 08 	lds	r22, 0x08C3
    db38:	40 91 4d 06 	lds	r20, 0x064D
    db3c:	20 91 0c 0b 	lds	r18, 0x0B0C
    db40:	00 91 cf 05 	lds	r16, 0x05CF
    db44:	e0 90 c4 08 	lds	r14, 0x08C4
    db48:	c0 90 c2 08 	lds	r12, 0x08C2
    db4c:	0e 94 1d 23 	call	0x463a	; 0x463a <SetDateTime>
		}
		else RTC_GetTrueTime();

		RTC_Summer_Time();
    db50:	0e 94 03 6d 	call	0xda06	; 0xda06 <RTC_Summer_Time>
    db54:	e9 cf       	rjmp	.-46     	; 0xdb28 <TWI_In+0x98>
			Tm_Mon = DecodBCD(TWDR & 0b00011111);
			if(Tm_Mon > 12) Tm_Mon = 0;	//
			RunTWI();		//NACK
			break;
		case PCF_Year:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_NACK){ TWI_Error(); return;}
    db56:	0e 94 52 22 	call	0x44a4	; 0x44a4 <TWI_Error>
		}
		else RTC_GetTrueTime();

		RTC_Summer_Time();
	}
}
    db5a:	0f 91       	pop	r16
    db5c:	ef 90       	pop	r14
    db5e:	cf 90       	pop	r12
    db60:	08 95       	ret
			return;
		}

		if (!(TWCR &(1<<TWINT))) return;

		switch(TWI_Phase) {
    db62:	e1 5c       	subi	r30, 0xC1	; 193
    db64:	fe 4f       	sbci	r31, 0xFE	; 254
    db66:	ee 0f       	add	r30, r30
    db68:	ff 1f       	adc	r31, r31
    db6a:	05 90       	lpm	r0, Z+
    db6c:	f4 91       	lpm	r31, Z+
    db6e:	e0 2d       	mov	r30, r0
    db70:	19 94       	eijmp
		case PFC_ACKN:
			AcknTWI();
			break;

		case PCF_Se:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
    db72:	80 91 b9 00 	lds	r24, 0x00B9
    db76:	88 7f       	andi	r24, 0xF8	; 248
    db78:	80 35       	cpi	r24, 0x50	; 80
    db7a:	69 f7       	brne	.-38     	; 0xdb56 <TWI_In+0xc6>
			Tm_Sec = DecodBCD(TWDR & 0b01111111);	// exclude ST bit
    db7c:	20 91 bb 00 	lds	r18, 0x00BB
    db80:	82 2f       	mov	r24, r18
    db82:	8f 77       	andi	r24, 0x7F	; 127
    db84:	82 95       	swap	r24
    db86:	8f 70       	andi	r24, 0x0F	; 15
    db88:	3a e0       	ldi	r19, 0x0A	; 10
    db8a:	83 9f       	mul	r24, r19
    db8c:	c0 01       	movw	r24, r0
    db8e:	11 24       	eor	r1, r1
    db90:	2f 70       	andi	r18, 0x0F	; 15
    db92:	28 0f       	add	r18, r24
    db94:	20 93 ad 06 	sts	0x06AD, r18
			PFC_Stop_bit = TWDR & 0b10000000;
    db98:	80 91 bb 00 	lds	r24, 0x00BB
    db9c:	80 78       	andi	r24, 0x80	; 128
    db9e:	80 93 cc 04 	sts	0x04CC, r24
/*			if(PFC_Stop_bit) NoTickCnt++;
			else NoTickCnt=0;*/
			AcknTWI();
    dba2:	84 ec       	ldi	r24, 0xC4	; 196
    dba4:	80 93 bc 00 	sts	0x00BC, r24
    dba8:	96 cf       	rjmp	.-212    	; 0xdad6 <TWI_In+0x46>

		case PCF_REAP_START1:
			StartTWI();
			break;
		case PCF_CHECK_REAP_START1:
			if( (TWSR & 0b11111000) != TWI_STATUS_RP_START){ TWI_Error(); return;}
    dbaa:	80 91 b9 00 	lds	r24, 0x00B9
    dbae:	88 7f       	andi	r24, 0xF8	; 248
    dbb0:	80 31       	cpi	r24, 0x10	; 16
    dbb2:	89 f6       	brne	.-94     	; 0xdb56 <TWI_In+0xc6>
    dbb4:	48 e0       	ldi	r20, 0x08	; 8
			else TWI_Phase++;

		case PCF_SLA_R:
			SLA_R(PCF_SLA);
    dbb6:	81 ed       	ldi	r24, 0xD1	; 209
    dbb8:	80 93 bb 00 	sts	0x00BB, r24
			RunTWI();
    dbbc:	84 e8       	ldi	r24, 0x84	; 132
    dbbe:	80 93 bc 00 	sts	0x00BC, r24
    dbc2:	89 cf       	rjmp	.-238    	; 0xdad6 <TWI_In+0x46>
		case PCF_Addr:
			TWDR = AddrSec;
			RunTWI();
			break;
		case PCF_CHECK_Addr:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATATX_ACK){ TWI_Error(); return;}
    dbc4:	80 91 b9 00 	lds	r24, 0x00B9
    dbc8:	88 7f       	andi	r24, 0xF8	; 248
    dbca:	88 32       	cpi	r24, 0x28	; 40
    dbcc:	21 f6       	brne	.-120    	; 0xdb56 <TWI_In+0xc6>
    dbce:	46 e0       	ldi	r20, 0x06	; 6
			else TWI_Phase++;

		case PCF_REAP_START1:
			StartTWI();
    dbd0:	84 ea       	ldi	r24, 0xA4	; 164
    dbd2:	80 93 bc 00 	sts	0x00BC, r24
    dbd6:	7f cf       	rjmp	.-258    	; 0xdad6 <TWI_In+0x46>
		case PCF_SLA_W:
			SLA_W(PCF_SLA);
			RunTWI();
			break;
		case PCF_CHECK_SLA_W:
			if( (TWSR & 0b11111000) != TWI_STATUS_SLAW_ACK){ TWI_Error(); return;}
    dbd8:	80 91 b9 00 	lds	r24, 0x00B9
    dbdc:	88 7f       	andi	r24, 0xF8	; 248
    dbde:	88 31       	cpi	r24, 0x18	; 24
    dbe0:	09 f0       	breq	.+2      	; 0xdbe4 <TWI_In+0x154>
    dbe2:	b9 cf       	rjmp	.-142    	; 0xdb56 <TWI_In+0xc6>
    dbe4:	44 e0       	ldi	r20, 0x04	; 4
			else TWI_Phase++;

		case PCF_Addr:
			TWDR = AddrSec;
    dbe6:	10 92 bb 00 	sts	0x00BB, r1
			RunTWI();
    dbea:	84 e8       	ldi	r24, 0x84	; 132
    dbec:	80 93 bc 00 	sts	0x00BC, r24
    dbf0:	72 cf       	rjmp	.-284    	; 0xdad6 <TWI_In+0x46>
		if (!(TWCR &(1<<TWINT))) return;

		switch(TWI_Phase) {
		
		case PCF_CHECK_START:
			if( (TWSR & 0b11111000) != TWI_STATUS_START){ TWI_Error(); return;}
    dbf2:	80 91 b9 00 	lds	r24, 0x00B9
    dbf6:	88 7f       	andi	r24, 0xF8	; 248
    dbf8:	88 30       	cpi	r24, 0x08	; 8
    dbfa:	09 f0       	breq	.+2      	; 0xdbfe <TWI_In+0x16e>
    dbfc:	ac cf       	rjmp	.-168    	; 0xdb56 <TWI_In+0xc6>
    dbfe:	42 e0       	ldi	r20, 0x02	; 2
			else TWI_Phase++;
			
		case PCF_SLA_W:
			SLA_W(PCF_SLA);
    dc00:	80 ed       	ldi	r24, 0xD0	; 208
    dc02:	80 93 bb 00 	sts	0x00BB, r24
			RunTWI();
    dc06:	84 e8       	ldi	r24, 0x84	; 132
    dc08:	80 93 bc 00 	sts	0x00BC, r24
    dc0c:	64 cf       	rjmp	.-312    	; 0xdad6 <TWI_In+0x46>
		case PCF_SLA_R:
			SLA_R(PCF_SLA);
			RunTWI();
			break;
		case PCF_CHECK_SLA_R:
			if( (TWSR & 0b11111000) != TWI_STATUS_SLAR_ACK){ TWI_Error(); return;}
    dc0e:	80 91 b9 00 	lds	r24, 0x00B9
    dc12:	88 7f       	andi	r24, 0xF8	; 248
    dc14:	80 34       	cpi	r24, 0x40	; 64
    dc16:	09 f0       	breq	.+2      	; 0xdc1a <TWI_In+0x18a>
    dc18:	9e cf       	rjmp	.-196    	; 0xdb56 <TWI_In+0xc6>
    dc1a:	4a e0       	ldi	r20, 0x0A	; 10
    dc1c:	c2 cf       	rjmp	.-124    	; 0xdba2 <TWI_In+0x112>
			Tm_Mon = DecodBCD(TWDR & 0b00011111);
			if(Tm_Mon > 12) Tm_Mon = 0;	//
			RunTWI();		//NACK
			break;
		case PCF_Year:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_NACK){ TWI_Error(); return;}
    dc1e:	80 91 b9 00 	lds	r24, 0x00B9
    dc22:	88 7f       	andi	r24, 0xF8	; 248
    dc24:	88 35       	cpi	r24, 0x58	; 88
    dc26:	09 f0       	breq	.+2      	; 0xdc2a <TWI_In+0x19a>
    dc28:	96 cf       	rjmp	.-212    	; 0xdb56 <TWI_In+0xc6>
			Tm_Year = DecodBCD(TWDR);
    dc2a:	80 91 bb 00 	lds	r24, 0x00BB

// ~~~~~~~~~~~~~~~~~~
uint8_t
DecodBCD(uint8_t BCD)
{
	return 10*(BCD>>4)+(BCD&0x0F);
    dc2e:	28 2f       	mov	r18, r24
    dc30:	22 95       	swap	r18
    dc32:	2f 70       	andi	r18, 0x0F	; 15
    dc34:	9a e0       	ldi	r25, 0x0A	; 10
    dc36:	29 9f       	mul	r18, r25
    dc38:	90 01       	movw	r18, r0
    dc3a:	11 24       	eor	r1, r1
    dc3c:	8f 70       	andi	r24, 0x0F	; 15
    dc3e:	82 0f       	add	r24, r18
    dc40:	80 93 d5 05 	sts	0x05D5, r24
			StopTWI();
    dc44:	94 e9       	ldi	r25, 0x94	; 148
    dc46:	90 93 bc 00 	sts	0x00BC, r25
			Tm_WDay = SetWeekday(Tm_Year, Tm_Mon, Tm_MDay);
    dc4a:	60 91 7b 07 	lds	r22, 0x077B
    dc4e:	40 91 0d 0b 	lds	r20, 0x0B0D
    dc52:	0e 94 b5 22 	call	0x456a	; 0x456a <SetWeekday>
    dc56:	80 93 4e 06 	sts	0x064E, r24
			StartTimer8(TD_TWI_Poll, 49);
    dc5a:	80 2f       	mov	r24, r16
    dc5c:	61 e3       	ldi	r22, 0x31	; 49
    dc5e:	0e 94 ca 19 	call	0x3394	; 0x3394 <StartTimer8>
    dc62:	4f ef       	ldi	r20, 0xFF	; 255
    dc64:	38 cf       	rjmp	.-400    	; 0xdad6 <TWI_In+0x46>
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
			Tm_MDay = DecodBCD(TWDR & 0b00111111);
			AcknTWI();
			break;
		case PCF_Mo:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
    dc66:	80 91 b9 00 	lds	r24, 0x00B9
    dc6a:	88 7f       	andi	r24, 0xF8	; 248
    dc6c:	80 35       	cpi	r24, 0x50	; 80
    dc6e:	09 f0       	breq	.+2      	; 0xdc72 <TWI_In+0x1e2>
    dc70:	72 cf       	rjmp	.-284    	; 0xdb56 <TWI_In+0xc6>
			Tm_Mon = DecodBCD(TWDR & 0b00011111);
    dc72:	80 91 bb 00 	lds	r24, 0x00BB
    dc76:	28 2f       	mov	r18, r24
    dc78:	2f 71       	andi	r18, 0x1F	; 31
    dc7a:	22 95       	swap	r18
    dc7c:	2f 70       	andi	r18, 0x0F	; 15
    dc7e:	9a e0       	ldi	r25, 0x0A	; 10
    dc80:	29 9f       	mul	r18, r25
    dc82:	90 01       	movw	r18, r0
    dc84:	11 24       	eor	r1, r1
    dc86:	8f 70       	andi	r24, 0x0F	; 15
    dc88:	82 0f       	add	r24, r18
    dc8a:	80 93 7b 07 	sts	0x077B, r24
			if(Tm_Mon > 12) Tm_Mon = 0;	//
    dc8e:	8d 30       	cpi	r24, 0x0D	; 13
    dc90:	10 f0       	brcs	.+4      	; 0xdc96 <TWI_In+0x206>
    dc92:	10 92 7b 07 	sts	0x077B, r1
			RunTWI();		//NACK
    dc96:	84 e8       	ldi	r24, 0x84	; 132
    dc98:	80 93 bc 00 	sts	0x00BC, r24
    dc9c:	1c cf       	rjmp	.-456    	; 0xdad6 <TWI_In+0x46>
			TWDR;
			//Tm_WDay = DecodBCD(TWDR & 0b00000111); Ignore 
			AcknTWI();
			break;
		case PCF_MDay:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
    dc9e:	80 91 b9 00 	lds	r24, 0x00B9
    dca2:	88 7f       	andi	r24, 0xF8	; 248
    dca4:	80 35       	cpi	r24, 0x50	; 80
    dca6:	09 f0       	breq	.+2      	; 0xdcaa <TWI_In+0x21a>
    dca8:	56 cf       	rjmp	.-340    	; 0xdb56 <TWI_In+0xc6>
			Tm_MDay = DecodBCD(TWDR & 0b00111111);
    dcaa:	20 91 bb 00 	lds	r18, 0x00BB
    dcae:	82 2f       	mov	r24, r18
    dcb0:	8f 73       	andi	r24, 0x3F	; 63
    dcb2:	82 95       	swap	r24
    dcb4:	8f 70       	andi	r24, 0x0F	; 15
    dcb6:	3a e0       	ldi	r19, 0x0A	; 10
    dcb8:	83 9f       	mul	r24, r19
    dcba:	c0 01       	movw	r24, r0
    dcbc:	11 24       	eor	r1, r1
    dcbe:	2f 70       	andi	r18, 0x0F	; 15
    dcc0:	28 0f       	add	r18, r24
    dcc2:	20 93 0d 0b 	sts	0x0B0D, r18
			AcknTWI();
    dcc6:	84 ec       	ldi	r24, 0xC4	; 196
    dcc8:	80 93 bc 00 	sts	0x00BC, r24
    dccc:	04 cf       	rjmp	.-504    	; 0xdad6 <TWI_In+0x46>
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
			Tm_Hour = DecodBCD(TWDR & 0b00111111);
			AcknTWI();
			break;
		case PCF_WDay:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
    dcce:	80 91 b9 00 	lds	r24, 0x00B9
    dcd2:	88 7f       	andi	r24, 0xF8	; 248
    dcd4:	80 35       	cpi	r24, 0x50	; 80
    dcd6:	09 f0       	breq	.+2      	; 0xdcda <TWI_In+0x24a>
    dcd8:	3e cf       	rjmp	.-388    	; 0xdb56 <TWI_In+0xc6>
			TWDR;
    dcda:	80 91 bb 00 	lds	r24, 0x00BB
			//Tm_WDay = DecodBCD(TWDR & 0b00000111); Ignore 
			AcknTWI();
    dcde:	84 ec       	ldi	r24, 0xC4	; 196
    dce0:	80 93 bc 00 	sts	0x00BC, r24
    dce4:	f8 ce       	rjmp	.-528    	; 0xdad6 <TWI_In+0x46>
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
			Tm_Min = DecodBCD(TWDR & 0b01111111);
			AcknTWI();
			break;
		case PCF_Ho:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
    dce6:	80 91 b9 00 	lds	r24, 0x00B9
    dcea:	88 7f       	andi	r24, 0xF8	; 248
    dcec:	80 35       	cpi	r24, 0x50	; 80
    dcee:	09 f0       	breq	.+2      	; 0xdcf2 <TWI_In+0x262>
    dcf0:	32 cf       	rjmp	.-412    	; 0xdb56 <TWI_In+0xc6>
			Tm_Hour = DecodBCD(TWDR & 0b00111111);
    dcf2:	20 91 bb 00 	lds	r18, 0x00BB
    dcf6:	82 2f       	mov	r24, r18
    dcf8:	8f 73       	andi	r24, 0x3F	; 63
    dcfa:	82 95       	swap	r24
    dcfc:	8f 70       	andi	r24, 0x0F	; 15
    dcfe:	3a e0       	ldi	r19, 0x0A	; 10
    dd00:	83 9f       	mul	r24, r19
    dd02:	c0 01       	movw	r24, r0
    dd04:	11 24       	eor	r1, r1
    dd06:	2f 70       	andi	r18, 0x0F	; 15
    dd08:	28 0f       	add	r18, r24
    dd0a:	20 93 b8 05 	sts	0x05B8, r18
			AcknTWI();
    dd0e:	84 ec       	ldi	r24, 0xC4	; 196
    dd10:	80 93 bc 00 	sts	0x00BC, r24
    dd14:	e0 ce       	rjmp	.-576    	; 0xdad6 <TWI_In+0x46>
/*			if(PFC_Stop_bit) NoTickCnt++;
			else NoTickCnt=0;*/
			AcknTWI();
			break;
		case PCF_Mi:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
    dd16:	80 91 b9 00 	lds	r24, 0x00B9
    dd1a:	88 7f       	andi	r24, 0xF8	; 248
    dd1c:	80 35       	cpi	r24, 0x50	; 80
    dd1e:	09 f0       	breq	.+2      	; 0xdd22 <TWI_In+0x292>
    dd20:	1a cf       	rjmp	.-460    	; 0xdb56 <TWI_In+0xc6>
			Tm_Min = DecodBCD(TWDR & 0b01111111);
    dd22:	20 91 bb 00 	lds	r18, 0x00BB
    dd26:	82 2f       	mov	r24, r18
    dd28:	8f 77       	andi	r24, 0x7F	; 127
    dd2a:	82 95       	swap	r24
    dd2c:	8f 70       	andi	r24, 0x0F	; 15
    dd2e:	3a e0       	ldi	r19, 0x0A	; 10
    dd30:	83 9f       	mul	r24, r19
    dd32:	c0 01       	movw	r24, r0
    dd34:	11 24       	eor	r1, r1
    dd36:	2f 70       	andi	r18, 0x0F	; 15
    dd38:	28 0f       	add	r18, r24
    dd3a:	20 93 48 06 	sts	0x0648, r18
			AcknTWI();
    dd3e:	84 ec       	ldi	r24, 0xC4	; 196
    dd40:	80 93 bc 00 	sts	0x00BC, r24
    dd44:	c8 ce       	rjmp	.-624    	; 0xdad6 <TWI_In+0x46>

0000dd46 <TimeInit>:

// ~~~~~~~~
void
WdtOn(void)
{
	wdt_reset();
    dd46:	a8 95       	wdr
	wdt_enable(WDTO_2S);
    dd48:	2f e0       	ldi	r18, 0x0F	; 15
    dd4a:	88 e1       	ldi	r24, 0x18	; 24
    dd4c:	90 e0       	ldi	r25, 0x00	; 0
    dd4e:	0f b6       	in	r0, 0x3f	; 63
    dd50:	f8 94       	cli
    dd52:	a8 95       	wdr
    dd54:	80 93 60 00 	sts	0x0060, r24
    dd58:	0f be       	out	0x3f, r0	; 63
    dd5a:	20 93 60 00 	sts	0x0060, r18

	// WDT
	WdtOn();

	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TCCR1A = 0;
    dd5e:	10 92 80 00 	sts	0x0080, r1
		TCCR1B = (((~(1<<WGM13) |(1<<WGM12)) &~(1<<CS12)) |(1<<CS11)) &~(1<<CS10);
    dd62:	8a ee       	ldi	r24, 0xEA	; 234
    dd64:	80 93 81 00 	sts	0x0081, r24
		OCR1A = 20000;
    dd68:	80 e2       	ldi	r24, 0x20	; 32
    dd6a:	9e e4       	ldi	r25, 0x4E	; 78
    dd6c:	90 93 89 00 	sts	0x0089, r25
    dd70:	80 93 88 00 	sts	0x0088, r24
		TCC0.CTRLE = ~TC0_BYTEM_bm;
	#endif
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__)
		TIMSK |=(1<<OCIE1A);
	#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TIMSK1 |=(1<<OCIE1A);
    dd74:	80 91 6f 00 	lds	r24, 0x006F
    dd78:	82 60       	ori	r24, 0x02	; 2
    dd7a:	80 93 6f 00 	sts	0x006F, r24
    dd7e:	80 e0       	ldi	r24, 0x00	; 0
    dd80:	90 e0       	ldi	r25, 0x00	; 0
	#endif

	// Program timers (10 ms)
	uint8_t i;
	for (i=0; i<sizeof(Timer8Flg); i++)
		Timer8Flg[i] = 0xFF;
    dd82:	2f ef       	ldi	r18, 0xFF	; 255
    dd84:	fc 01       	movw	r30, r24
    dd86:	e8 55       	subi	r30, 0x58	; 88
    dd88:	fb 4f       	sbci	r31, 0xFB	; 251
    dd8a:	20 83       	st	Z, r18
    dd8c:	01 96       	adiw	r24, 0x01	; 1
		TCC0.INTCTRLB = 0;
	#endif

	// Program timers (10 ms)
	uint8_t i;
	for (i=0; i<sizeof(Timer8Flg); i++)
    dd8e:	8c 30       	cpi	r24, 0x0C	; 12
    dd90:	91 05       	cpc	r25, r1
    dd92:	c1 f7       	brne	.-16     	; 0xdd84 <TimeInit+0x3e>
    dd94:	80 e0       	ldi	r24, 0x00	; 0
    dd96:	90 e0       	ldi	r25, 0x00	; 0
		Timer8Flg[i] = 0xFF;
	for (i=0; i<sizeof(Timer16Flg); i++)
		Timer16Flg[i] = 0xFF;
    dd98:	3f ef       	ldi	r19, 0xFF	; 255
    dd9a:	fc 01       	movw	r30, r24
    dd9c:	ec 54       	subi	r30, 0x4C	; 76
    dd9e:	fb 4f       	sbci	r31, 0xFB	; 251
    dda0:	2f ef       	ldi	r18, 0xFF	; 255
    dda2:	30 83       	st	Z, r19
    dda4:	01 96       	adiw	r24, 0x01	; 1

	// Program timers (10 ms)
	uint8_t i;
	for (i=0; i<sizeof(Timer8Flg); i++)
		Timer8Flg[i] = 0xFF;
	for (i=0; i<sizeof(Timer16Flg); i++)
    dda6:	8d 30       	cpi	r24, 0x0D	; 13
    dda8:	91 05       	cpc	r25, r1
    ddaa:	b9 f7       	brne	.-18     	; 0xdd9a <TimeInit+0x54>
		Timer16Flg[i] = 0xFF;
	for (i=0; i<sizeof(Timer32Flg); i++)
		Timer32Flg[i] = 0xFF;
    ddac:	20 93 c1 04 	sts	0x04C1, r18
    ddb0:	20 93 c2 04 	sts	0x04C2, r18
    ddb4:	20 93 c3 04 	sts	0x04C3, r18
    ddb8:	20 93 c4 04 	sts	0x04C4, r18
    ddbc:	20 93 c5 04 	sts	0x04C5, r18
    ddc0:	20 93 c6 04 	sts	0x04C6, r18
    ddc4:	8d e3       	ldi	r24, 0x3D	; 61
    ddc6:	91 e0       	ldi	r25, 0x01	; 1
    ddc8:	0e 94 03 7d 	call	0xfa06	; 0xfa06 <__eerd_byte_m2560>

	// 1 s
	Timer1min = erb(&Timer1min_EE);
    ddcc:	80 93 a7 06 	sts	0x06A7, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    ddd0:	8e e3       	ldi	r24, 0x3E	; 62
    ddd2:	91 e0       	ldi	r25, 0x01	; 1
    ddd4:	0e 94 11 7d 	call	0xfa22	; 0xfa22 <__eerd_word_m2560>
	Timer1hour = erw(&Timer1hour_EE);
    ddd8:	90 93 1a 0c 	sts	0x0C1A, r25
    dddc:	80 93 19 0c 	sts	0x0C19, r24

	// Application
	#ifdef InitTimer
		StartTimer16(InitTimer, InitTime);
	#endif
}
    dde0:	08 95       	ret

0000dde2 <MemCheckInit>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    dde2:	8c e3       	ldi	r24, 0x3C	; 60
    dde4:	91 e0       	ldi	r25, 0x01	; 1
    dde6:	0e 94 03 7d 	call	0xfa06	; 0xfa06 <__eerd_byte_m2560>
// ~~~~~~~~~~~~~~~
void
MemCheckInit(void)
{
//	TD_Mem = Timer32SysAlloc(1);
	if (!erb(&MemCheck_stor.ReprogFlg)) {
    ddea:	81 11       	cpse	r24, r1
    ddec:	08 95       	ret
		eeprom_write_word(&MemCheck_stor.CRC_Flash_stor, CRC_Flash_calc());
    ddee:	0e 94 c6 18 	call	0x318c	; 0x318c <CRC_Flash_calc>
    ddf2:	bc 01       	movw	r22, r24
    ddf4:	88 e3       	ldi	r24, 0x38	; 56
    ddf6:	91 e0       	ldi	r25, 0x01	; 1
    ddf8:	0e 94 37 7d 	call	0xfa6e	; 0xfa6e <__eewr_word_m2560>
		eeprom_write_word(&MemCheck_stor.CRC_EEPROM_stor, CRC_EEPROM_calc());
    ddfc:	0e 94 e0 18 	call	0x31c0	; 0x31c0 <CRC_EEPROM_calc>
    de00:	bc 01       	movw	r22, r24
    de02:	8a e3       	ldi	r24, 0x3A	; 58
    de04:	91 e0       	ldi	r25, 0x01	; 1
    de06:	0e 94 37 7d 	call	0xfa6e	; 0xfa6e <__eewr_word_m2560>
		eeprom_write_byte(&MemCheck_stor.ReprogFlg, 1);
    de0a:	8c e3       	ldi	r24, 0x3C	; 60
    de0c:	91 e0       	ldi	r25, 0x01	; 1
    de0e:	61 e0       	ldi	r22, 0x01	; 1
    de10:	0e 94 21 7d 	call	0xfa42	; 0xfa42 <__eewr_byte_m2560>
    de14:	08 95       	ret

0000de16 <main>:
}

// ~~~~~~~
int
main(void)
{
    de16:	cf 93       	push	r28
    de18:	df 93       	push	r29
	TimeInit();
    de1a:	0e 94 a3 6e 	call	0xdd46	; 0xdd46 <TimeInit>
	TimersInc();
    de1e:	0e 94 41 4b 	call	0x9682	; 0x9682 <TimersInc>
	MemCheckInit();
    de22:	0e 94 f1 6e 	call	0xdde2	; 0xdde2 <MemCheckInit>
	LED_Init();
    de26:	0e 94 f3 24 	call	0x49e6	; 0x49e6 <LED_Init>

	LCD_Init();
    de2a:	0e 94 52 6c 	call	0xd8a4	; 0xd8a4 <LCD_Init>

	KeypadInit();
    de2e:	0e 94 92 3a 	call	0x7524	; 0x7524 <KeypadInit>
	MenuInit();
    de32:	0e 94 e0 3b 	call	0x77c0	; 0x77c0 <MenuInit>
InterruInit(void)
{
	#ifdef PMIC
		PMIC.CTRL = (uint8_t)(~PMIC_RREN_bm &~PMIC_IVSEL_bm) |PMIC_HILVLEN_bm |PMIC_MEDLVLEN_bm |PMIC_LOLVLEN_bm;
	#endif
	sei();
    de36:	78 94       	sei
	InterruInit();
	DigitInit();
    de38:	0e 94 03 3d 	call	0x7a06	; 0x7a06 <DI_Init>
    de3c:	0e 94 12 3e 	call	0x7c24	; 0x7c24 <DO_Init>
	HSC_Init();

	AI_Init();
    de40:	0e 94 27 3e 	call	0x7c4e	; 0x7c4e <AI_Init>

	SPI_Init();
    de44:	0e 94 7b 1f 	call	0x3ef6	; 0x3ef6 <SPI_Init>

	PWM_Init();
    de48:	0e 94 47 1d 	call	0x3a8e	; 0x3a8e <PWM_Init>
	TWI_Init();
    de4c:	0e 94 36 22 	call	0x446c	; 0x446c <TWI_Init>
#ifdef QslRD
	SlaveRD_Init();
#endif

	do {
		TimersInc();
    de50:	0e 94 41 4b 	call	0x9682	; 0x9682 <TimersInc>
		wdt_reset();
    de54:	a8 95       	wdr
		DigitIn();
    de56:	0e 94 4f 4e 	call	0x9c9e	; 0x9c9e <DigitIn>
		TWI_In();
    de5a:	0e 94 48 6d 	call	0xda90	; 0xda90 <TWI_In>
	StopTWI();
	TWI_Phase = PCF_START;
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t RTC_Ready(void){
	if(TWI_Phase == PCF_START) return 1;
    de5e:	80 91 73 07 	lds	r24, 0x0773
    de62:	88 23       	and	r24, r24
    de64:	11 f4       	brne	.+4      	; 0xde6a <main+0x54>
		if(RTC_Ready()) RTC_GetTrueTime();
    de66:	0e 94 d1 23 	call	0x47a2	; 0x47a2 <RTC_GetTrueTime>
		LCD_Sweep();
    de6a:	0e 94 10 60 	call	0xc020	; 0xc020 <LCD_Sweep>
	#ifdef TerIdx
	} while(ThermInit(AnalogIn()-TerIdx) || !RTC_Ready());
	#elif !defined ADC_Miss
		AnalogIn();
    de6e:	0e 94 38 3e 	call	0x7c70	; 0x7c70 <AnalogIn>
	} while( (ADC_OK&&ThermInit(ADC_In())) || !RTC_Ready() );
    de72:	80 91 d9 08 	lds	r24, 0x08D9
    de76:	90 91 da 08 	lds	r25, 0x08DA
    de7a:	89 2b       	or	r24, r25
    de7c:	69 f4       	brne	.+26     	; 0xde98 <main+0x82>
    de7e:	80 91 66 07 	lds	r24, 0x0766
    de82:	90 91 67 07 	lds	r25, 0x0767
    de86:	89 2b       	or	r24, r25
    de88:	39 f4       	brne	.+14     	; 0xde98 <main+0x82>
    de8a:	80 91 ae 06 	lds	r24, 0x06AE
    de8e:	90 91 af 06 	lds	r25, 0x06AF
    de92:	89 2b       	or	r24, r25
    de94:	09 f4       	brne	.+2      	; 0xde98 <main+0x82>
    de96:	68 c0       	rjmp	.+208    	; 0xdf68 <main+0x152>
    de98:	80 91 73 07 	lds	r24, 0x0773
    de9c:	88 23       	and	r24, r24
    de9e:	c1 f6       	brne	.-80     	; 0xde50 <main+0x3a>
	#else
	} while((AnalogIn()!=AI_Reg-1) || !RTC_Ready());
	#endif

	MemCheckMsg();
    dea0:	0e 94 3f 4d 	call	0x9a7e	; 0x9a7e <MemCheckMsg>

	ApplInit();

	USART_Init();
    dea4:	0e 94 fe 6b 	call	0xd7fc	; 0xd7fc <USART_Init>
	ScanCycleInit();
    dea8:	0e 94 8b 1c 	call	0x3916	; 0x3916 <ScanCycleInit>
	if(TimerAllocError()) ShowMsg(&MsgErr41);
    deac:	0e 94 6f 1c 	call	0x38de	; 0x38de <TimerAllocError>
    deb0:	88 23       	and	r24, r24
    deb2:	09 f0       	breq	.+2      	; 0xdeb6 <main+0xa0>
    deb4:	61 c0       	rjmp	.+194    	; 0xdf78 <main+0x162>

// ~~~~~~~~~~~~~~~~
void
Therm_ADC_Off(void)
{
	for (uint8_t i=0; i<TerReg; Temperature[i++]=ADC_Off_Mark);
    deb6:	c1 e0       	ldi	r28, 0x01	; 1
    deb8:	d0 e8       	ldi	r29, 0x80	; 128
    deba:	10 c0       	rjmp	.+32     	; 0xdedc <main+0xc6>
			if(ADC_Work&&ADC_Phase==ADC_OFF) {
				Therm_ADC_Off();
				ShowMsg(&MsgErr21);
				ADC_Work = 0;
			}
			ThermChan(ADC_In());
    debc:	0e 94 d2 1d 	call	0x3ba4	; 0x3ba4 <ADC_In>
    dec0:	0e 94 71 4d 	call	0x9ae2	; 0x9ae2 <ThermChan>
		#endif
		ThermExt();
		TWI_In();
    dec4:	0e 94 48 6d 	call	0xda90	; 0xda90 <TWI_In>

		USART_Cycle();
    dec8:	0e 94 73 6a 	call	0xd4e6	; 0xd4e6 <USART_Cycle>
#ifdef QslRD
		SlaveRD();
#endif
		ApplCycle();
		
		LCD_Sweep();
    decc:	0e 94 10 60 	call	0xc020	; 0xc020 <LCD_Sweep>
		DigitOut();
    ded0:	0e 94 c3 3d 	call	0x7b86	; 0x7b86 <DigitOut>
		DAC_Out();
		PWM_Out();
    ded4:	0e 94 66 1d 	call	0x3acc	; 0x3acc <PWM_Out>
		#ifdef BACKLIGHT
			LCDBackLightControl();
    ded8:	0e 94 2b 27 	call	0x4e56	; 0x4e56 <LCDBackLightControl>
	USART_Init();
	ScanCycleInit();
	if(TimerAllocError()) ShowMsg(&MsgErr41);

	for(;;) {	
		TimersInc();
    dedc:	0e 94 41 4b 	call	0x9682	; 0x9682 <TimersInc>
		TimeCycle();
    dee0:	0e 94 eb 1c 	call	0x39d6	; 0x39d6 <TimeCycle>
// ~~~~~~~~~~~~~~
static void
KeypadSweep(void)
{
	static T_KeyAct KeyAct[] PROGMEM = KEYS;
	T_KeyAct KA = prp(KeyAct+KeypadIn());
    dee4:	0e 94 a5 3a 	call	0x754a	; 0x754a <KeypadIn>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    dee8:	e8 2f       	mov	r30, r24
    deea:	f0 e0       	ldi	r31, 0x00	; 0
    deec:	ee 0f       	add	r30, r30
    deee:	ff 1f       	adc	r31, r31
    def0:	e5 57       	subi	r30, 0x75	; 117
    def2:	f6 4d       	sbci	r31, 0xD6	; 214
    def4:	85 91       	lpm	r24, Z+
    def6:	94 91       	lpm	r25, Z+
	if(KA){
    def8:	00 97       	sbiw	r24, 0x00	; 0
    defa:	31 f0       	breq	.+12     	; 0xdf08 <main+0xf2>
		KA();
    defc:	fc 01       	movw	r30, r24
    defe:	19 95       	eicall
		#ifdef BACKLIGHT
			if(BackLightMode == 1){
    df00:	80 91 49 06 	lds	r24, 0x0649
    df04:	81 30       	cpi	r24, 0x01	; 1
    df06:	59 f1       	breq	.+86     	; 0xdf5e <main+0x148>
	for(;;) {	
		TimersInc();
		TimeCycle();

		KeypadSweep();
		DigitIn();
    df08:	0e 94 4f 4e 	call	0x9c9e	; 0x9c9e <DigitIn>
		HSC_In();
		#ifdef TerIdx
			ThermChan(AnalogIn()-TerIdx);
		#else
			AnalogIn();
    df0c:	0e 94 38 3e 	call	0x7c70	; 0x7c70 <AnalogIn>
		#endif
		#if !defined ADC_Miss && !defined TerIdx
			static uint8_t ADC_Work = 1;
			if(ADC_Work&&ADC_Phase==ADC_OFF) {
    df10:	80 91 d5 02 	lds	r24, 0x02D5
    df14:	88 23       	and	r24, r24
    df16:	91 f2       	breq	.-92     	; 0xdebc <main+0xa6>
    df18:	80 91 18 0b 	lds	r24, 0x0B18
    df1c:	84 30       	cpi	r24, 0x04	; 4
    df1e:	71 f6       	brne	.-100    	; 0xdebc <main+0xa6>
    df20:	d0 93 3d 06 	sts	0x063D, r29
    df24:	c0 93 3c 06 	sts	0x063C, r28
    df28:	d0 93 3f 06 	sts	0x063F, r29
    df2c:	c0 93 3e 06 	sts	0x063E, r28
    df30:	d0 93 41 06 	sts	0x0641, r29
    df34:	c0 93 40 06 	sts	0x0640, r28
    df38:	d0 93 43 06 	sts	0x0643, r29
    df3c:	c0 93 42 06 	sts	0x0642, r28
    df40:	d0 93 45 06 	sts	0x0645, r29
    df44:	c0 93 44 06 	sts	0x0644, r28
    df48:	d0 93 47 06 	sts	0x0647, r29
    df4c:	c0 93 46 06 	sts	0x0646, r28
				Therm_ADC_Off();
				ShowMsg(&MsgErr21);
    df50:	8e e3       	ldi	r24, 0x3E	; 62
    df52:	98 e0       	ldi	r25, 0x08	; 8
    df54:	0e 94 cf 3b 	call	0x779e	; 0x779e <ShowMsg>
				ADC_Work = 0;
    df58:	10 92 d5 02 	sts	0x02D5, r1
    df5c:	af cf       	rjmp	.-162    	; 0xdebc <main+0xa6>
	T_KeyAct KA = prp(KeyAct+KeypadIn());
	if(KA){
		KA();
		#ifdef BACKLIGHT
			if(BackLightMode == 1){
				LCDBackLightOn();
    df5e:	0e 94 0f 27 	call	0x4e1e	; 0x4e1e <LCDBackLightOn>
				LCDBackLightStartTimer();
    df62:	0e 94 03 6c 	call	0xd806	; 0xd806 <LCDBackLightStartTimer>
    df66:	d0 cf       	rjmp	.-96     	; 0xdf08 <main+0xf2>
		LCD_Sweep();
	#ifdef TerIdx
	} while(ThermInit(AnalogIn()-TerIdx) || !RTC_Ready());
	#elif !defined ADC_Miss
		AnalogIn();
	} while( (ADC_OK&&ThermInit(ADC_In())) || !RTC_Ready() );
    df68:	0e 94 d2 1d 	call	0x3ba4	; 0x3ba4 <ADC_In>
    df6c:	0e 94 0d 4e 	call	0x9c1a	; 0x9c1a <ThermInit>
    df70:	88 23       	and	r24, r24
    df72:	09 f0       	breq	.+2      	; 0xdf76 <main+0x160>
    df74:	6d cf       	rjmp	.-294    	; 0xde50 <main+0x3a>
    df76:	90 cf       	rjmp	.-224    	; 0xde98 <main+0x82>

	ApplInit();

	USART_Init();
	ScanCycleInit();
	if(TimerAllocError()) ShowMsg(&MsgErr41);
    df78:	83 ef       	ldi	r24, 0xF3	; 243
    df7a:	99 e1       	ldi	r25, 0x19	; 25
    df7c:	0e 94 cf 3b 	call	0x779e	; 0x779e <ShowMsg>
    df80:	9a cf       	rjmp	.-204    	; 0xdeb6 <main+0xa0>

0000df82 <EEMEMBackUpOk>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    df82:	80 e0       	ldi	r24, 0x00	; 0
    df84:	90 e0       	ldi	r25, 0x00	; 0
    df86:	0e 94 03 7d 	call	0xfa06	; 0xfa06 <__eerd_byte_m2560>
	uint8_t Month;
	uint8_t Year;
}DateBackUp EEMEM = {0xFF,0xFF,0xFF};

uint8_t EEMEMBackUpOk(void){
	if( (erb(&DateBackUp.Day)==0xFF) || (erb(&DateBackUp.Month)==0xFF) || (erb(&DateBackUp.Year)== 0xFF) ) return 0;
    df8a:	8f 3f       	cpi	r24, 0xFF	; 255
    df8c:	81 f0       	breq	.+32     	; 0xdfae <EEMEMBackUpOk+0x2c>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    df8e:	81 e0       	ldi	r24, 0x01	; 1
    df90:	90 e0       	ldi	r25, 0x00	; 0
    df92:	0e 94 03 7d 	call	0xfa06	; 0xfa06 <__eerd_byte_m2560>
	uint8_t Month;
	uint8_t Year;
}DateBackUp EEMEM = {0xFF,0xFF,0xFF};

uint8_t EEMEMBackUpOk(void){
	if( (erb(&DateBackUp.Day)==0xFF) || (erb(&DateBackUp.Month)==0xFF) || (erb(&DateBackUp.Year)== 0xFF) ) return 0;
    df96:	8f 3f       	cpi	r24, 0xFF	; 255
    df98:	51 f0       	breq	.+20     	; 0xdfae <EEMEMBackUpOk+0x2c>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    df9a:	82 e0       	ldi	r24, 0x02	; 2
    df9c:	90 e0       	ldi	r25, 0x00	; 0
    df9e:	0e 94 03 7d 	call	0xfa06	; 0xfa06 <__eerd_byte_m2560>
    dfa2:	90 e0       	ldi	r25, 0x00	; 0
    dfa4:	8f 3f       	cpi	r24, 0xFF	; 255
    dfa6:	21 f0       	breq	.+8      	; 0xdfb0 <EEMEMBackUpOk+0x2e>
    dfa8:	91 e0       	ldi	r25, 0x01	; 1
}DateBackUp EEMEM = {0xFF,0xFF,0xFF};

uint8_t EEMEMBackUpOk(void){
	if( (erb(&DateBackUp.Day)==0xFF) || (erb(&DateBackUp.Month)==0xFF) || (erb(&DateBackUp.Year)== 0xFF) ) return 0;
	else return 1;
}
    dfaa:	89 2f       	mov	r24, r25
    dfac:	08 95       	ret
	uint8_t Month;
	uint8_t Year;
}DateBackUp EEMEM = {0xFF,0xFF,0xFF};

uint8_t EEMEMBackUpOk(void){
	if( (erb(&DateBackUp.Day)==0xFF) || (erb(&DateBackUp.Month)==0xFF) || (erb(&DateBackUp.Year)== 0xFF) ) return 0;
    dfae:	90 e0       	ldi	r25, 0x00	; 0
	else return 1;
}
    dfb0:	89 2f       	mov	r24, r25
    dfb2:	08 95       	ret

0000dfb4 <Menu_BackUp_Enter>:
			NULL, NULL, NULL, Menu_ConfirmationRest_Enter, NULL, NULL, NULL};
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	//		  
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	uint8_t Menu_BackUp_Enter(){
		switch(CurrLine){
    dfb4:	80 91 79 07 	lds	r24, 0x0779
    dfb8:	82 30       	cpi	r24, 0x02	; 2
    dfba:	11 f0       	breq	.+4      	; 0xdfc0 <Menu_BackUp_Enter+0xc>
			}
			NextPage = &Menu_ConfirmationRestore;
			break;
		}
		return StandartKey;
	}
    dfbc:	80 e0       	ldi	r24, 0x00	; 0
    dfbe:	08 95       	ret
	//		  
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	uint8_t Menu_BackUp_Enter(){
		switch(CurrLine){
		case 2:
			if(!EEMEMBackUpOk()){
    dfc0:	0e 94 c1 6f 	call	0xdf82	; 0xdf82 <EEMEMBackUpOk>
    dfc4:	88 23       	and	r24, r24
    dfc6:	59 f4       	brne	.+22     	; 0xdfde <Menu_BackUp_Enter+0x2a>
				//   EEPROM,   BackUp- -  
				if(MemFail & 1<<MemFail_EEPROM){
    dfc8:	80 91 c5 08 	lds	r24, 0x08C5
    dfcc:	81 ff       	sbrs	r24, 1
    dfce:	0f c0       	rjmp	.+30     	; 0xdfee <Menu_BackUp_Enter+0x3a>
					MemFailReset();
    dfd0:	0e 94 b1 4a 	call	0x9562	; 0x9562 <MemFailReset>
					ShowMsg(&Msg_EEWarning);
    dfd4:	8f ef       	ldi	r24, 0xFF	; 255
    dfd6:	92 e1       	ldi	r25, 0x12	; 18
    dfd8:	0e 94 cf 3b 	call	0x779e	; 0x779e <ShowMsg>
    dfdc:	ef cf       	rjmp	.-34     	; 0xdfbc <Menu_BackUp_Enter+0x8>
				}
				else ShowMsg(&Msg_NoBackUp);
				break;
			}
			NextPage = &Menu_ConfirmationRestore;
    dfde:	8f ea       	ldi	r24, 0xAF	; 175
    dfe0:	94 e1       	ldi	r25, 0x14	; 20
    dfe2:	90 93 d1 05 	sts	0x05D1, r25
    dfe6:	80 93 d0 05 	sts	0x05D0, r24
			break;
		}
		return StandartKey;
	}
    dfea:	80 e0       	ldi	r24, 0x00	; 0
    dfec:	08 95       	ret
				//   EEPROM,   BackUp- -  
				if(MemFail & 1<<MemFail_EEPROM){
					MemFailReset();
					ShowMsg(&Msg_EEWarning);
				}
				else ShowMsg(&Msg_NoBackUp);
    dfee:	81 e6       	ldi	r24, 0x61	; 97
    dff0:	93 e1       	ldi	r25, 0x13	; 19
    dff2:	0e 94 cf 3b 	call	0x779e	; 0x779e <ShowMsg>
    dff6:	e2 cf       	rjmp	.-60     	; 0xdfbc <Menu_BackUp_Enter+0x8>

0000dff8 <vfprintf>:
    dff8:	2f 92       	push	r2
    dffa:	3f 92       	push	r3
    dffc:	4f 92       	push	r4
    dffe:	5f 92       	push	r5
    e000:	6f 92       	push	r6
    e002:	7f 92       	push	r7
    e004:	8f 92       	push	r8
    e006:	9f 92       	push	r9
    e008:	af 92       	push	r10
    e00a:	bf 92       	push	r11
    e00c:	cf 92       	push	r12
    e00e:	df 92       	push	r13
    e010:	ef 92       	push	r14
    e012:	ff 92       	push	r15
    e014:	0f 93       	push	r16
    e016:	1f 93       	push	r17
    e018:	df 93       	push	r29
    e01a:	cf 93       	push	r28
    e01c:	cd b7       	in	r28, 0x3d	; 61
    e01e:	de b7       	in	r29, 0x3e	; 62
    e020:	61 97       	sbiw	r28, 0x11	; 17
    e022:	0f b6       	in	r0, 0x3f	; 63
    e024:	f8 94       	cli
    e026:	de bf       	out	0x3e, r29	; 62
    e028:	0f be       	out	0x3f, r0	; 63
    e02a:	cd bf       	out	0x3d, r28	; 61
    e02c:	3c 01       	movw	r6, r24
    e02e:	7f 87       	std	Y+15, r23	; 0x0f
    e030:	6e 87       	std	Y+14, r22	; 0x0e
    e032:	6a 01       	movw	r12, r20
    e034:	fc 01       	movw	r30, r24
    e036:	17 82       	std	Z+7, r1	; 0x07
    e038:	16 82       	std	Z+6, r1	; 0x06
    e03a:	83 81       	ldd	r24, Z+3	; 0x03
    e03c:	81 fd       	sbrc	r24, 1
    e03e:	03 c0       	rjmp	.+6      	; 0xe046 <vfprintf+0x4e>
    e040:	6f ef       	ldi	r22, 0xFF	; 255
    e042:	7f ef       	ldi	r23, 0xFF	; 255
    e044:	6f c3       	rjmp	.+1758   	; 0xe724 <vfprintf+0x72c>
    e046:	9e 01       	movw	r18, r28
    e048:	2f 5f       	subi	r18, 0xFF	; 255
    e04a:	3f 4f       	sbci	r19, 0xFF	; 255
    e04c:	39 8b       	std	Y+17, r19	; 0x11
    e04e:	28 8b       	std	Y+16, r18	; 0x10
    e050:	f3 01       	movw	r30, r6
    e052:	23 81       	ldd	r18, Z+3	; 0x03
    e054:	ee 85       	ldd	r30, Y+14	; 0x0e
    e056:	ff 85       	ldd	r31, Y+15	; 0x0f
    e058:	23 fd       	sbrc	r18, 3
    e05a:	85 91       	lpm	r24, Z+
    e05c:	23 ff       	sbrs	r18, 3
    e05e:	81 91       	ld	r24, Z+
    e060:	ff 87       	std	Y+15, r31	; 0x0f
    e062:	ee 87       	std	Y+14, r30	; 0x0e
    e064:	88 23       	and	r24, r24
    e066:	09 f4       	brne	.+2      	; 0xe06a <vfprintf+0x72>
    e068:	5a c3       	rjmp	.+1716   	; 0xe71e <vfprintf+0x726>
    e06a:	85 32       	cpi	r24, 0x25	; 37
    e06c:	51 f4       	brne	.+20     	; 0xe082 <vfprintf+0x8a>
    e06e:	ee 85       	ldd	r30, Y+14	; 0x0e
    e070:	ff 85       	ldd	r31, Y+15	; 0x0f
    e072:	23 fd       	sbrc	r18, 3
    e074:	85 91       	lpm	r24, Z+
    e076:	23 ff       	sbrs	r18, 3
    e078:	81 91       	ld	r24, Z+
    e07a:	ff 87       	std	Y+15, r31	; 0x0f
    e07c:	ee 87       	std	Y+14, r30	; 0x0e
    e07e:	85 32       	cpi	r24, 0x25	; 37
    e080:	29 f4       	brne	.+10     	; 0xe08c <vfprintf+0x94>
    e082:	90 e0       	ldi	r25, 0x00	; 0
    e084:	b3 01       	movw	r22, r6
    e086:	0e 94 a9 7a 	call	0xf552	; 0xf552 <fputc>
    e08a:	e2 cf       	rjmp	.-60     	; 0xe050 <vfprintf+0x58>
    e08c:	98 2f       	mov	r25, r24
    e08e:	10 e0       	ldi	r17, 0x00	; 0
    e090:	88 24       	eor	r8, r8
    e092:	99 24       	eor	r9, r9
    e094:	10 32       	cpi	r17, 0x20	; 32
    e096:	b0 f4       	brcc	.+44     	; 0xe0c4 <vfprintf+0xcc>
    e098:	9b 32       	cpi	r25, 0x2B	; 43
    e09a:	69 f0       	breq	.+26     	; 0xe0b6 <vfprintf+0xbe>
    e09c:	9c 32       	cpi	r25, 0x2C	; 44
    e09e:	28 f4       	brcc	.+10     	; 0xe0aa <vfprintf+0xb2>
    e0a0:	90 32       	cpi	r25, 0x20	; 32
    e0a2:	51 f0       	breq	.+20     	; 0xe0b8 <vfprintf+0xc0>
    e0a4:	93 32       	cpi	r25, 0x23	; 35
    e0a6:	71 f4       	brne	.+28     	; 0xe0c4 <vfprintf+0xcc>
    e0a8:	0b c0       	rjmp	.+22     	; 0xe0c0 <vfprintf+0xc8>
    e0aa:	9d 32       	cpi	r25, 0x2D	; 45
    e0ac:	39 f0       	breq	.+14     	; 0xe0bc <vfprintf+0xc4>
    e0ae:	90 33       	cpi	r25, 0x30	; 48
    e0b0:	49 f4       	brne	.+18     	; 0xe0c4 <vfprintf+0xcc>
    e0b2:	11 60       	ori	r17, 0x01	; 1
    e0b4:	28 c0       	rjmp	.+80     	; 0xe106 <vfprintf+0x10e>
    e0b6:	12 60       	ori	r17, 0x02	; 2
    e0b8:	14 60       	ori	r17, 0x04	; 4
    e0ba:	25 c0       	rjmp	.+74     	; 0xe106 <vfprintf+0x10e>
    e0bc:	18 60       	ori	r17, 0x08	; 8
    e0be:	23 c0       	rjmp	.+70     	; 0xe106 <vfprintf+0x10e>
    e0c0:	10 61       	ori	r17, 0x10	; 16
    e0c2:	21 c0       	rjmp	.+66     	; 0xe106 <vfprintf+0x10e>
    e0c4:	17 fd       	sbrc	r17, 7
    e0c6:	2a c0       	rjmp	.+84     	; 0xe11c <vfprintf+0x124>
    e0c8:	89 2f       	mov	r24, r25
    e0ca:	80 53       	subi	r24, 0x30	; 48
    e0cc:	8a 30       	cpi	r24, 0x0A	; 10
    e0ce:	78 f4       	brcc	.+30     	; 0xe0ee <vfprintf+0xf6>
    e0d0:	16 ff       	sbrs	r17, 6
    e0d2:	06 c0       	rjmp	.+12     	; 0xe0e0 <vfprintf+0xe8>
    e0d4:	fa e0       	ldi	r31, 0x0A	; 10
    e0d6:	9f 9e       	mul	r9, r31
    e0d8:	90 2c       	mov	r9, r0
    e0da:	11 24       	eor	r1, r1
    e0dc:	98 0e       	add	r9, r24
    e0de:	13 c0       	rjmp	.+38     	; 0xe106 <vfprintf+0x10e>
    e0e0:	3a e0       	ldi	r19, 0x0A	; 10
    e0e2:	83 9e       	mul	r8, r19
    e0e4:	80 2c       	mov	r8, r0
    e0e6:	11 24       	eor	r1, r1
    e0e8:	88 0e       	add	r8, r24
    e0ea:	10 62       	ori	r17, 0x20	; 32
    e0ec:	0c c0       	rjmp	.+24     	; 0xe106 <vfprintf+0x10e>
    e0ee:	9e 32       	cpi	r25, 0x2E	; 46
    e0f0:	21 f4       	brne	.+8      	; 0xe0fa <vfprintf+0x102>
    e0f2:	16 fd       	sbrc	r17, 6
    e0f4:	14 c3       	rjmp	.+1576   	; 0xe71e <vfprintf+0x726>
    e0f6:	10 64       	ori	r17, 0x40	; 64
    e0f8:	06 c0       	rjmp	.+12     	; 0xe106 <vfprintf+0x10e>
    e0fa:	9c 36       	cpi	r25, 0x6C	; 108
    e0fc:	11 f4       	brne	.+4      	; 0xe102 <vfprintf+0x10a>
    e0fe:	10 68       	ori	r17, 0x80	; 128
    e100:	02 c0       	rjmp	.+4      	; 0xe106 <vfprintf+0x10e>
    e102:	98 36       	cpi	r25, 0x68	; 104
    e104:	59 f4       	brne	.+22     	; 0xe11c <vfprintf+0x124>
    e106:	ee 85       	ldd	r30, Y+14	; 0x0e
    e108:	ff 85       	ldd	r31, Y+15	; 0x0f
    e10a:	23 fd       	sbrc	r18, 3
    e10c:	95 91       	lpm	r25, Z+
    e10e:	23 ff       	sbrs	r18, 3
    e110:	91 91       	ld	r25, Z+
    e112:	ff 87       	std	Y+15, r31	; 0x0f
    e114:	ee 87       	std	Y+14, r30	; 0x0e
    e116:	99 23       	and	r25, r25
    e118:	09 f0       	breq	.+2      	; 0xe11c <vfprintf+0x124>
    e11a:	bc cf       	rjmp	.-136    	; 0xe094 <vfprintf+0x9c>
    e11c:	89 2f       	mov	r24, r25
    e11e:	85 54       	subi	r24, 0x45	; 69
    e120:	83 30       	cpi	r24, 0x03	; 3
    e122:	20 f4       	brcc	.+8      	; 0xe12c <vfprintf+0x134>
    e124:	81 2f       	mov	r24, r17
    e126:	80 61       	ori	r24, 0x10	; 16
    e128:	90 5e       	subi	r25, 0xE0	; 224
    e12a:	07 c0       	rjmp	.+14     	; 0xe13a <vfprintf+0x142>
    e12c:	89 2f       	mov	r24, r25
    e12e:	85 56       	subi	r24, 0x65	; 101
    e130:	83 30       	cpi	r24, 0x03	; 3
    e132:	08 f0       	brcs	.+2      	; 0xe136 <vfprintf+0x13e>
    e134:	9f c1       	rjmp	.+830    	; 0xe474 <vfprintf+0x47c>
    e136:	81 2f       	mov	r24, r17
    e138:	8f 7e       	andi	r24, 0xEF	; 239
    e13a:	86 fd       	sbrc	r24, 6
    e13c:	02 c0       	rjmp	.+4      	; 0xe142 <vfprintf+0x14a>
    e13e:	76 e0       	ldi	r23, 0x06	; 6
    e140:	97 2e       	mov	r9, r23
    e142:	6f e3       	ldi	r22, 0x3F	; 63
    e144:	f6 2e       	mov	r15, r22
    e146:	f8 22       	and	r15, r24
    e148:	95 36       	cpi	r25, 0x65	; 101
    e14a:	19 f4       	brne	.+6      	; 0xe152 <vfprintf+0x15a>
    e14c:	f0 e4       	ldi	r31, 0x40	; 64
    e14e:	ff 2a       	or	r15, r31
    e150:	07 c0       	rjmp	.+14     	; 0xe160 <vfprintf+0x168>
    e152:	96 36       	cpi	r25, 0x66	; 102
    e154:	19 f4       	brne	.+6      	; 0xe15c <vfprintf+0x164>
    e156:	20 e8       	ldi	r18, 0x80	; 128
    e158:	f2 2a       	or	r15, r18
    e15a:	02 c0       	rjmp	.+4      	; 0xe160 <vfprintf+0x168>
    e15c:	91 10       	cpse	r9, r1
    e15e:	9a 94       	dec	r9
    e160:	f7 fe       	sbrs	r15, 7
    e162:	0a c0       	rjmp	.+20     	; 0xe178 <vfprintf+0x180>
    e164:	3b e3       	ldi	r19, 0x3B	; 59
    e166:	39 15       	cp	r19, r9
    e168:	18 f4       	brcc	.+6      	; 0xe170 <vfprintf+0x178>
    e16a:	5c e3       	ldi	r21, 0x3C	; 60
    e16c:	b5 2e       	mov	r11, r21
    e16e:	02 c0       	rjmp	.+4      	; 0xe174 <vfprintf+0x17c>
    e170:	b9 2c       	mov	r11, r9
    e172:	b3 94       	inc	r11
    e174:	27 e0       	ldi	r18, 0x07	; 7
    e176:	09 c0       	rjmp	.+18     	; 0xe18a <vfprintf+0x192>
    e178:	47 e0       	ldi	r20, 0x07	; 7
    e17a:	49 15       	cp	r20, r9
    e17c:	20 f4       	brcc	.+8      	; 0xe186 <vfprintf+0x18e>
    e17e:	bb 24       	eor	r11, r11
    e180:	47 e0       	ldi	r20, 0x07	; 7
    e182:	94 2e       	mov	r9, r20
    e184:	f7 cf       	rjmp	.-18     	; 0xe174 <vfprintf+0x17c>
    e186:	29 2d       	mov	r18, r9
    e188:	bb 24       	eor	r11, r11
    e18a:	c6 01       	movw	r24, r12
    e18c:	04 96       	adiw	r24, 0x04	; 4
    e18e:	9d 87       	std	Y+13, r25	; 0x0d
    e190:	8c 87       	std	Y+12, r24	; 0x0c
    e192:	f6 01       	movw	r30, r12
    e194:	60 81       	ld	r22, Z
    e196:	71 81       	ldd	r23, Z+1	; 0x01
    e198:	82 81       	ldd	r24, Z+2	; 0x02
    e19a:	93 81       	ldd	r25, Z+3	; 0x03
    e19c:	ae 01       	movw	r20, r28
    e19e:	4f 5f       	subi	r20, 0xFF	; 255
    e1a0:	5f 4f       	sbci	r21, 0xFF	; 255
    e1a2:	0b 2d       	mov	r16, r11
    e1a4:	0e 94 e6 78 	call	0xf1cc	; 0xf1cc <__ftoa_engine>
    e1a8:	6c 01       	movw	r12, r24
    e1aa:	09 81       	ldd	r16, Y+1	; 0x01
    e1ac:	20 2e       	mov	r2, r16
    e1ae:	33 24       	eor	r3, r3
    e1b0:	00 ff       	sbrs	r16, 0
    e1b2:	04 c0       	rjmp	.+8      	; 0xe1bc <vfprintf+0x1c4>
    e1b4:	03 fd       	sbrc	r16, 3
    e1b6:	02 c0       	rjmp	.+4      	; 0xe1bc <vfprintf+0x1c4>
    e1b8:	1d e2       	ldi	r17, 0x2D	; 45
    e1ba:	09 c0       	rjmp	.+18     	; 0xe1ce <vfprintf+0x1d6>
    e1bc:	f1 fe       	sbrs	r15, 1
    e1be:	02 c0       	rjmp	.+4      	; 0xe1c4 <vfprintf+0x1cc>
    e1c0:	1b e2       	ldi	r17, 0x2B	; 43
    e1c2:	05 c0       	rjmp	.+10     	; 0xe1ce <vfprintf+0x1d6>
    e1c4:	f2 fc       	sbrc	r15, 2
    e1c6:	02 c0       	rjmp	.+4      	; 0xe1cc <vfprintf+0x1d4>
    e1c8:	10 e0       	ldi	r17, 0x00	; 0
    e1ca:	01 c0       	rjmp	.+2      	; 0xe1ce <vfprintf+0x1d6>
    e1cc:	10 e2       	ldi	r17, 0x20	; 32
    e1ce:	c1 01       	movw	r24, r2
    e1d0:	8c 70       	andi	r24, 0x0C	; 12
    e1d2:	90 70       	andi	r25, 0x00	; 0
    e1d4:	89 2b       	or	r24, r25
    e1d6:	b9 f1       	breq	.+110    	; 0xe246 <vfprintf+0x24e>
    e1d8:	11 23       	and	r17, r17
    e1da:	11 f4       	brne	.+4      	; 0xe1e0 <vfprintf+0x1e8>
    e1dc:	83 e0       	ldi	r24, 0x03	; 3
    e1de:	01 c0       	rjmp	.+2      	; 0xe1e2 <vfprintf+0x1ea>
    e1e0:	84 e0       	ldi	r24, 0x04	; 4
    e1e2:	88 15       	cp	r24, r8
    e1e4:	10 f0       	brcs	.+4      	; 0xe1ea <vfprintf+0x1f2>
    e1e6:	88 24       	eor	r8, r8
    e1e8:	0a c0       	rjmp	.+20     	; 0xe1fe <vfprintf+0x206>
    e1ea:	88 1a       	sub	r8, r24
    e1ec:	f3 fc       	sbrc	r15, 3
    e1ee:	07 c0       	rjmp	.+14     	; 0xe1fe <vfprintf+0x206>
    e1f0:	80 e2       	ldi	r24, 0x20	; 32
    e1f2:	90 e0       	ldi	r25, 0x00	; 0
    e1f4:	b3 01       	movw	r22, r6
    e1f6:	0e 94 a9 7a 	call	0xf552	; 0xf552 <fputc>
    e1fa:	8a 94       	dec	r8
    e1fc:	c9 f7       	brne	.-14     	; 0xe1f0 <vfprintf+0x1f8>
    e1fe:	11 23       	and	r17, r17
    e200:	29 f0       	breq	.+10     	; 0xe20c <vfprintf+0x214>
    e202:	81 2f       	mov	r24, r17
    e204:	90 e0       	ldi	r25, 0x00	; 0
    e206:	b3 01       	movw	r22, r6
    e208:	0e 94 a9 7a 	call	0xf552	; 0xf552 <fputc>
    e20c:	23 fe       	sbrs	r2, 3
    e20e:	03 c0       	rjmp	.+6      	; 0xe216 <vfprintf+0x21e>
    e210:	00 ea       	ldi	r16, 0xA0	; 160
    e212:	12 e0       	ldi	r17, 0x02	; 2
    e214:	0e c0       	rjmp	.+28     	; 0xe232 <vfprintf+0x23a>
    e216:	04 ea       	ldi	r16, 0xA4	; 164
    e218:	12 e0       	ldi	r17, 0x02	; 2
    e21a:	0b c0       	rjmp	.+22     	; 0xe232 <vfprintf+0x23a>
    e21c:	e1 14       	cp	r14, r1
    e21e:	f1 04       	cpc	r15, r1
    e220:	09 f0       	breq	.+2      	; 0xe224 <vfprintf+0x22c>
    e222:	80 52       	subi	r24, 0x20	; 32
    e224:	90 e0       	ldi	r25, 0x00	; 0
    e226:	b3 01       	movw	r22, r6
    e228:	0e 94 a9 7a 	call	0xf552	; 0xf552 <fputc>
    e22c:	0f 5f       	subi	r16, 0xFF	; 255
    e22e:	1f 4f       	sbci	r17, 0xFF	; 255
    e230:	05 c0       	rjmp	.+10     	; 0xe23c <vfprintf+0x244>
    e232:	ef 2c       	mov	r14, r15
    e234:	ff 24       	eor	r15, r15
    e236:	f0 e1       	ldi	r31, 0x10	; 16
    e238:	ef 22       	and	r14, r31
    e23a:	ff 24       	eor	r15, r15
    e23c:	f8 01       	movw	r30, r16
    e23e:	84 91       	lpm	r24, Z+
    e240:	88 23       	and	r24, r24
    e242:	61 f7       	brne	.-40     	; 0xe21c <vfprintf+0x224>
    e244:	14 c1       	rjmp	.+552    	; 0xe46e <vfprintf+0x476>
    e246:	f7 fe       	sbrs	r15, 7
    e248:	12 c0       	rjmp	.+36     	; 0xe26e <vfprintf+0x276>
    e24a:	bc 0c       	add	r11, r12
    e24c:	24 fe       	sbrs	r2, 4
    e24e:	04 c0       	rjmp	.+8      	; 0xe258 <vfprintf+0x260>
    e250:	8a 81       	ldd	r24, Y+2	; 0x02
    e252:	81 33       	cpi	r24, 0x31	; 49
    e254:	09 f4       	brne	.+2      	; 0xe258 <vfprintf+0x260>
    e256:	ba 94       	dec	r11
    e258:	1b 14       	cp	r1, r11
    e25a:	1c f0       	brlt	.+6      	; 0xe262 <vfprintf+0x26a>
    e25c:	bb 24       	eor	r11, r11
    e25e:	b3 94       	inc	r11
    e260:	2d c0       	rjmp	.+90     	; 0xe2bc <vfprintf+0x2c4>
    e262:	f8 e0       	ldi	r31, 0x08	; 8
    e264:	fb 15       	cp	r31, r11
    e266:	50 f5       	brcc	.+84     	; 0xe2bc <vfprintf+0x2c4>
    e268:	38 e0       	ldi	r19, 0x08	; 8
    e26a:	b3 2e       	mov	r11, r19
    e26c:	27 c0       	rjmp	.+78     	; 0xe2bc <vfprintf+0x2c4>
    e26e:	f6 fc       	sbrc	r15, 6
    e270:	25 c0       	rjmp	.+74     	; 0xe2bc <vfprintf+0x2c4>
    e272:	89 2d       	mov	r24, r9
    e274:	90 e0       	ldi	r25, 0x00	; 0
    e276:	8c 15       	cp	r24, r12
    e278:	9d 05       	cpc	r25, r13
    e27a:	4c f0       	brlt	.+18     	; 0xe28e <vfprintf+0x296>
    e27c:	2c ef       	ldi	r18, 0xFC	; 252
    e27e:	c2 16       	cp	r12, r18
    e280:	2f ef       	ldi	r18, 0xFF	; 255
    e282:	d2 06       	cpc	r13, r18
    e284:	24 f0       	brlt	.+8      	; 0xe28e <vfprintf+0x296>
    e286:	30 e8       	ldi	r19, 0x80	; 128
    e288:	f3 2a       	or	r15, r19
    e28a:	01 c0       	rjmp	.+2      	; 0xe28e <vfprintf+0x296>
    e28c:	9a 94       	dec	r9
    e28e:	99 20       	and	r9, r9
    e290:	49 f0       	breq	.+18     	; 0xe2a4 <vfprintf+0x2ac>
    e292:	e2 e0       	ldi	r30, 0x02	; 2
    e294:	f0 e0       	ldi	r31, 0x00	; 0
    e296:	ec 0f       	add	r30, r28
    e298:	fd 1f       	adc	r31, r29
    e29a:	e9 0d       	add	r30, r9
    e29c:	f1 1d       	adc	r31, r1
    e29e:	80 81       	ld	r24, Z
    e2a0:	80 33       	cpi	r24, 0x30	; 48
    e2a2:	a1 f3       	breq	.-24     	; 0xe28c <vfprintf+0x294>
    e2a4:	f7 fe       	sbrs	r15, 7
    e2a6:	0a c0       	rjmp	.+20     	; 0xe2bc <vfprintf+0x2c4>
    e2a8:	b9 2c       	mov	r11, r9
    e2aa:	b3 94       	inc	r11
    e2ac:	89 2d       	mov	r24, r9
    e2ae:	90 e0       	ldi	r25, 0x00	; 0
    e2b0:	c8 16       	cp	r12, r24
    e2b2:	d9 06       	cpc	r13, r25
    e2b4:	14 f0       	brlt	.+4      	; 0xe2ba <vfprintf+0x2c2>
    e2b6:	99 24       	eor	r9, r9
    e2b8:	01 c0       	rjmp	.+2      	; 0xe2bc <vfprintf+0x2c4>
    e2ba:	9c 18       	sub	r9, r12
    e2bc:	f7 fc       	sbrc	r15, 7
    e2be:	03 c0       	rjmp	.+6      	; 0xe2c6 <vfprintf+0x2ce>
    e2c0:	25 e0       	ldi	r18, 0x05	; 5
    e2c2:	30 e0       	ldi	r19, 0x00	; 0
    e2c4:	09 c0       	rjmp	.+18     	; 0xe2d8 <vfprintf+0x2e0>
    e2c6:	1c 14       	cp	r1, r12
    e2c8:	1d 04       	cpc	r1, r13
    e2ca:	1c f0       	brlt	.+6      	; 0xe2d2 <vfprintf+0x2da>
    e2cc:	21 e0       	ldi	r18, 0x01	; 1
    e2ce:	30 e0       	ldi	r19, 0x00	; 0
    e2d0:	03 c0       	rjmp	.+6      	; 0xe2d8 <vfprintf+0x2e0>
    e2d2:	96 01       	movw	r18, r12
    e2d4:	2f 5f       	subi	r18, 0xFF	; 255
    e2d6:	3f 4f       	sbci	r19, 0xFF	; 255
    e2d8:	11 23       	and	r17, r17
    e2da:	11 f0       	breq	.+4      	; 0xe2e0 <vfprintf+0x2e8>
    e2dc:	2f 5f       	subi	r18, 0xFF	; 255
    e2de:	3f 4f       	sbci	r19, 0xFF	; 255
    e2e0:	99 20       	and	r9, r9
    e2e2:	29 f0       	breq	.+10     	; 0xe2ee <vfprintf+0x2f6>
    e2e4:	89 2d       	mov	r24, r9
    e2e6:	90 e0       	ldi	r25, 0x00	; 0
    e2e8:	01 96       	adiw	r24, 0x01	; 1
    e2ea:	28 0f       	add	r18, r24
    e2ec:	39 1f       	adc	r19, r25
    e2ee:	88 2d       	mov	r24, r8
    e2f0:	90 e0       	ldi	r25, 0x00	; 0
    e2f2:	28 17       	cp	r18, r24
    e2f4:	39 07       	cpc	r19, r25
    e2f6:	14 f0       	brlt	.+4      	; 0xe2fc <vfprintf+0x304>
    e2f8:	88 24       	eor	r8, r8
    e2fa:	01 c0       	rjmp	.+2      	; 0xe2fe <vfprintf+0x306>
    e2fc:	82 1a       	sub	r8, r18
    e2fe:	4f 2c       	mov	r4, r15
    e300:	55 24       	eor	r5, r5
    e302:	c2 01       	movw	r24, r4
    e304:	89 70       	andi	r24, 0x09	; 9
    e306:	90 70       	andi	r25, 0x00	; 0
    e308:	89 2b       	or	r24, r25
    e30a:	39 f0       	breq	.+14     	; 0xe31a <vfprintf+0x322>
    e30c:	08 c0       	rjmp	.+16     	; 0xe31e <vfprintf+0x326>
    e30e:	80 e2       	ldi	r24, 0x20	; 32
    e310:	90 e0       	ldi	r25, 0x00	; 0
    e312:	b3 01       	movw	r22, r6
    e314:	0e 94 a9 7a 	call	0xf552	; 0xf552 <fputc>
    e318:	8a 94       	dec	r8
    e31a:	88 20       	and	r8, r8
    e31c:	c1 f7       	brne	.-16     	; 0xe30e <vfprintf+0x316>
    e31e:	11 23       	and	r17, r17
    e320:	29 f0       	breq	.+10     	; 0xe32c <vfprintf+0x334>
    e322:	81 2f       	mov	r24, r17
    e324:	90 e0       	ldi	r25, 0x00	; 0
    e326:	b3 01       	movw	r22, r6
    e328:	0e 94 a9 7a 	call	0xf552	; 0xf552 <fputc>
    e32c:	43 fe       	sbrs	r4, 3
    e32e:	07 c0       	rjmp	.+14     	; 0xe33e <vfprintf+0x346>
    e330:	08 c0       	rjmp	.+16     	; 0xe342 <vfprintf+0x34a>
    e332:	80 e3       	ldi	r24, 0x30	; 48
    e334:	90 e0       	ldi	r25, 0x00	; 0
    e336:	b3 01       	movw	r22, r6
    e338:	0e 94 a9 7a 	call	0xf552	; 0xf552 <fputc>
    e33c:	8a 94       	dec	r8
    e33e:	88 20       	and	r8, r8
    e340:	c1 f7       	brne	.-16     	; 0xe332 <vfprintf+0x33a>
    e342:	f7 fe       	sbrs	r15, 7
    e344:	46 c0       	rjmp	.+140    	; 0xe3d2 <vfprintf+0x3da>
    e346:	86 01       	movw	r16, r12
    e348:	d7 fe       	sbrs	r13, 7
    e34a:	02 c0       	rjmp	.+4      	; 0xe350 <vfprintf+0x358>
    e34c:	00 e0       	ldi	r16, 0x00	; 0
    e34e:	10 e0       	ldi	r17, 0x00	; 0
    e350:	76 01       	movw	r14, r12
    e352:	08 94       	sec
    e354:	e1 1c       	adc	r14, r1
    e356:	f1 1c       	adc	r15, r1
    e358:	e0 1a       	sub	r14, r16
    e35a:	f1 0a       	sbc	r15, r17
    e35c:	41 e0       	ldi	r20, 0x01	; 1
    e35e:	50 e0       	ldi	r21, 0x00	; 0
    e360:	4c 0f       	add	r20, r28
    e362:	5d 1f       	adc	r21, r29
    e364:	e4 0e       	add	r14, r20
    e366:	f5 1e       	adc	r15, r21
    e368:	26 01       	movw	r4, r12
    e36a:	4b 18       	sub	r4, r11
    e36c:	51 08       	sbc	r5, r1
    e36e:	89 2d       	mov	r24, r9
    e370:	90 e0       	ldi	r25, 0x00	; 0
    e372:	aa 24       	eor	r10, r10
    e374:	bb 24       	eor	r11, r11
    e376:	a8 1a       	sub	r10, r24
    e378:	b9 0a       	sbc	r11, r25
    e37a:	5f ef       	ldi	r21, 0xFF	; 255
    e37c:	0f 3f       	cpi	r16, 0xFF	; 255
    e37e:	15 07       	cpc	r17, r21
    e380:	29 f4       	brne	.+10     	; 0xe38c <vfprintf+0x394>
    e382:	8e e2       	ldi	r24, 0x2E	; 46
    e384:	90 e0       	ldi	r25, 0x00	; 0
    e386:	b3 01       	movw	r22, r6
    e388:	0e 94 a9 7a 	call	0xf552	; 0xf552 <fputc>
    e38c:	c0 16       	cp	r12, r16
    e38e:	d1 06       	cpc	r13, r17
    e390:	34 f0       	brlt	.+12     	; 0xe39e <vfprintf+0x3a6>
    e392:	40 16       	cp	r4, r16
    e394:	51 06       	cpc	r5, r17
    e396:	1c f4       	brge	.+6      	; 0xe39e <vfprintf+0x3a6>
    e398:	f7 01       	movw	r30, r14
    e39a:	80 81       	ld	r24, Z
    e39c:	01 c0       	rjmp	.+2      	; 0xe3a0 <vfprintf+0x3a8>
    e39e:	80 e3       	ldi	r24, 0x30	; 48
    e3a0:	01 50       	subi	r16, 0x01	; 1
    e3a2:	10 40       	sbci	r17, 0x00	; 0
    e3a4:	08 94       	sec
    e3a6:	e1 1c       	adc	r14, r1
    e3a8:	f1 1c       	adc	r15, r1
    e3aa:	0a 15       	cp	r16, r10
    e3ac:	1b 05       	cpc	r17, r11
    e3ae:	2c f0       	brlt	.+10     	; 0xe3ba <vfprintf+0x3c2>
    e3b0:	90 e0       	ldi	r25, 0x00	; 0
    e3b2:	b3 01       	movw	r22, r6
    e3b4:	0e 94 a9 7a 	call	0xf552	; 0xf552 <fputc>
    e3b8:	e0 cf       	rjmp	.-64     	; 0xe37a <vfprintf+0x382>
    e3ba:	0c 15       	cp	r16, r12
    e3bc:	1d 05       	cpc	r17, r13
    e3be:	39 f4       	brne	.+14     	; 0xe3ce <vfprintf+0x3d6>
    e3c0:	9a 81       	ldd	r25, Y+2	; 0x02
    e3c2:	96 33       	cpi	r25, 0x36	; 54
    e3c4:	18 f4       	brcc	.+6      	; 0xe3cc <vfprintf+0x3d4>
    e3c6:	95 33       	cpi	r25, 0x35	; 53
    e3c8:	11 f4       	brne	.+4      	; 0xe3ce <vfprintf+0x3d6>
    e3ca:	24 fe       	sbrs	r2, 4
    e3cc:	81 e3       	ldi	r24, 0x31	; 49
    e3ce:	90 e0       	ldi	r25, 0x00	; 0
    e3d0:	4b c0       	rjmp	.+150    	; 0xe468 <vfprintf+0x470>
    e3d2:	8a 81       	ldd	r24, Y+2	; 0x02
    e3d4:	81 33       	cpi	r24, 0x31	; 49
    e3d6:	09 f0       	breq	.+2      	; 0xe3da <vfprintf+0x3e2>
    e3d8:	0f 7e       	andi	r16, 0xEF	; 239
    e3da:	90 e0       	ldi	r25, 0x00	; 0
    e3dc:	b3 01       	movw	r22, r6
    e3de:	0e 94 a9 7a 	call	0xf552	; 0xf552 <fputc>
    e3e2:	99 20       	and	r9, r9
    e3e4:	a1 f0       	breq	.+40     	; 0xe40e <vfprintf+0x416>
    e3e6:	8e e2       	ldi	r24, 0x2E	; 46
    e3e8:	90 e0       	ldi	r25, 0x00	; 0
    e3ea:	b3 01       	movw	r22, r6
    e3ec:	0e 94 a9 7a 	call	0xf552	; 0xf552 <fputc>
    e3f0:	12 e0       	ldi	r17, 0x02	; 2
    e3f2:	e1 e0       	ldi	r30, 0x01	; 1
    e3f4:	f0 e0       	ldi	r31, 0x00	; 0
    e3f6:	ec 0f       	add	r30, r28
    e3f8:	fd 1f       	adc	r31, r29
    e3fa:	e1 0f       	add	r30, r17
    e3fc:	f1 1d       	adc	r31, r1
    e3fe:	1f 5f       	subi	r17, 0xFF	; 255
    e400:	80 81       	ld	r24, Z
    e402:	90 e0       	ldi	r25, 0x00	; 0
    e404:	b3 01       	movw	r22, r6
    e406:	0e 94 a9 7a 	call	0xf552	; 0xf552 <fputc>
    e40a:	9a 94       	dec	r9
    e40c:	91 f7       	brne	.-28     	; 0xe3f2 <vfprintf+0x3fa>
    e40e:	44 fc       	sbrc	r4, 4
    e410:	03 c0       	rjmp	.+6      	; 0xe418 <vfprintf+0x420>
    e412:	85 e6       	ldi	r24, 0x65	; 101
    e414:	90 e0       	ldi	r25, 0x00	; 0
    e416:	02 c0       	rjmp	.+4      	; 0xe41c <vfprintf+0x424>
    e418:	85 e4       	ldi	r24, 0x45	; 69
    e41a:	90 e0       	ldi	r25, 0x00	; 0
    e41c:	b3 01       	movw	r22, r6
    e41e:	0e 94 a9 7a 	call	0xf552	; 0xf552 <fputc>
    e422:	d7 fc       	sbrc	r13, 7
    e424:	05 c0       	rjmp	.+10     	; 0xe430 <vfprintf+0x438>
    e426:	c1 14       	cp	r12, r1
    e428:	d1 04       	cpc	r13, r1
    e42a:	41 f4       	brne	.+16     	; 0xe43c <vfprintf+0x444>
    e42c:	04 ff       	sbrs	r16, 4
    e42e:	06 c0       	rjmp	.+12     	; 0xe43c <vfprintf+0x444>
    e430:	d0 94       	com	r13
    e432:	c1 94       	neg	r12
    e434:	d1 08       	sbc	r13, r1
    e436:	d3 94       	inc	r13
    e438:	8d e2       	ldi	r24, 0x2D	; 45
    e43a:	01 c0       	rjmp	.+2      	; 0xe43e <vfprintf+0x446>
    e43c:	8b e2       	ldi	r24, 0x2B	; 43
    e43e:	90 e0       	ldi	r25, 0x00	; 0
    e440:	b3 01       	movw	r22, r6
    e442:	0e 94 a9 7a 	call	0xf552	; 0xf552 <fputc>
    e446:	80 e3       	ldi	r24, 0x30	; 48
    e448:	05 c0       	rjmp	.+10     	; 0xe454 <vfprintf+0x45c>
    e44a:	8f 5f       	subi	r24, 0xFF	; 255
    e44c:	26 ef       	ldi	r18, 0xF6	; 246
    e44e:	3f ef       	ldi	r19, 0xFF	; 255
    e450:	c2 0e       	add	r12, r18
    e452:	d3 1e       	adc	r13, r19
    e454:	3a e0       	ldi	r19, 0x0A	; 10
    e456:	c3 16       	cp	r12, r19
    e458:	d1 04       	cpc	r13, r1
    e45a:	bc f7       	brge	.-18     	; 0xe44a <vfprintf+0x452>
    e45c:	90 e0       	ldi	r25, 0x00	; 0
    e45e:	b3 01       	movw	r22, r6
    e460:	0e 94 a9 7a 	call	0xf552	; 0xf552 <fputc>
    e464:	c6 01       	movw	r24, r12
    e466:	c0 96       	adiw	r24, 0x30	; 48
    e468:	b3 01       	movw	r22, r6
    e46a:	0e 94 a9 7a 	call	0xf552	; 0xf552 <fputc>
    e46e:	cc 84       	ldd	r12, Y+12	; 0x0c
    e470:	dd 84       	ldd	r13, Y+13	; 0x0d
    e472:	52 c1       	rjmp	.+676    	; 0xe718 <vfprintf+0x720>
    e474:	93 36       	cpi	r25, 0x63	; 99
    e476:	31 f0       	breq	.+12     	; 0xe484 <vfprintf+0x48c>
    e478:	93 37       	cpi	r25, 0x73	; 115
    e47a:	99 f0       	breq	.+38     	; 0xe4a2 <vfprintf+0x4aa>
    e47c:	93 35       	cpi	r25, 0x53	; 83
    e47e:	09 f0       	breq	.+2      	; 0xe482 <vfprintf+0x48a>
    e480:	59 c0       	rjmp	.+178    	; 0xe534 <vfprintf+0x53c>
    e482:	23 c0       	rjmp	.+70     	; 0xe4ca <vfprintf+0x4d2>
    e484:	f6 01       	movw	r30, r12
    e486:	80 81       	ld	r24, Z
    e488:	89 83       	std	Y+1, r24	; 0x01
    e48a:	5e 01       	movw	r10, r28
    e48c:	08 94       	sec
    e48e:	a1 1c       	adc	r10, r1
    e490:	b1 1c       	adc	r11, r1
    e492:	22 e0       	ldi	r18, 0x02	; 2
    e494:	30 e0       	ldi	r19, 0x00	; 0
    e496:	c2 0e       	add	r12, r18
    e498:	d3 1e       	adc	r13, r19
    e49a:	21 e0       	ldi	r18, 0x01	; 1
    e49c:	e2 2e       	mov	r14, r18
    e49e:	f1 2c       	mov	r15, r1
    e4a0:	12 c0       	rjmp	.+36     	; 0xe4c6 <vfprintf+0x4ce>
    e4a2:	f6 01       	movw	r30, r12
    e4a4:	a0 80       	ld	r10, Z
    e4a6:	b1 80       	ldd	r11, Z+1	; 0x01
    e4a8:	16 fd       	sbrc	r17, 6
    e4aa:	03 c0       	rjmp	.+6      	; 0xe4b2 <vfprintf+0x4ba>
    e4ac:	6f ef       	ldi	r22, 0xFF	; 255
    e4ae:	7f ef       	ldi	r23, 0xFF	; 255
    e4b0:	02 c0       	rjmp	.+4      	; 0xe4b6 <vfprintf+0x4be>
    e4b2:	69 2d       	mov	r22, r9
    e4b4:	70 e0       	ldi	r23, 0x00	; 0
    e4b6:	22 e0       	ldi	r18, 0x02	; 2
    e4b8:	30 e0       	ldi	r19, 0x00	; 0
    e4ba:	c2 0e       	add	r12, r18
    e4bc:	d3 1e       	adc	r13, r19
    e4be:	c5 01       	movw	r24, r10
    e4c0:	0e 94 42 7a 	call	0xf484	; 0xf484 <strnlen>
    e4c4:	7c 01       	movw	r14, r24
    e4c6:	1f 77       	andi	r17, 0x7F	; 127
    e4c8:	13 c0       	rjmp	.+38     	; 0xe4f0 <vfprintf+0x4f8>
    e4ca:	f6 01       	movw	r30, r12
    e4cc:	a0 80       	ld	r10, Z
    e4ce:	b1 80       	ldd	r11, Z+1	; 0x01
    e4d0:	16 fd       	sbrc	r17, 6
    e4d2:	03 c0       	rjmp	.+6      	; 0xe4da <vfprintf+0x4e2>
    e4d4:	6f ef       	ldi	r22, 0xFF	; 255
    e4d6:	7f ef       	ldi	r23, 0xFF	; 255
    e4d8:	02 c0       	rjmp	.+4      	; 0xe4de <vfprintf+0x4e6>
    e4da:	69 2d       	mov	r22, r9
    e4dc:	70 e0       	ldi	r23, 0x00	; 0
    e4de:	22 e0       	ldi	r18, 0x02	; 2
    e4e0:	30 e0       	ldi	r19, 0x00	; 0
    e4e2:	c2 0e       	add	r12, r18
    e4e4:	d3 1e       	adc	r13, r19
    e4e6:	c5 01       	movw	r24, r10
    e4e8:	0e 94 00 7a 	call	0xf400	; 0xf400 <strnlen_P>
    e4ec:	7c 01       	movw	r14, r24
    e4ee:	10 68       	ori	r17, 0x80	; 128
    e4f0:	13 ff       	sbrs	r17, 3
    e4f2:	07 c0       	rjmp	.+14     	; 0xe502 <vfprintf+0x50a>
    e4f4:	1b c0       	rjmp	.+54     	; 0xe52c <vfprintf+0x534>
    e4f6:	80 e2       	ldi	r24, 0x20	; 32
    e4f8:	90 e0       	ldi	r25, 0x00	; 0
    e4fa:	b3 01       	movw	r22, r6
    e4fc:	0e 94 a9 7a 	call	0xf552	; 0xf552 <fputc>
    e500:	8a 94       	dec	r8
    e502:	88 2d       	mov	r24, r8
    e504:	90 e0       	ldi	r25, 0x00	; 0
    e506:	e8 16       	cp	r14, r24
    e508:	f9 06       	cpc	r15, r25
    e50a:	a8 f3       	brcs	.-22     	; 0xe4f6 <vfprintf+0x4fe>
    e50c:	0f c0       	rjmp	.+30     	; 0xe52c <vfprintf+0x534>
    e50e:	f5 01       	movw	r30, r10
    e510:	17 fd       	sbrc	r17, 7
    e512:	85 91       	lpm	r24, Z+
    e514:	17 ff       	sbrs	r17, 7
    e516:	81 91       	ld	r24, Z+
    e518:	5f 01       	movw	r10, r30
    e51a:	90 e0       	ldi	r25, 0x00	; 0
    e51c:	b3 01       	movw	r22, r6
    e51e:	0e 94 a9 7a 	call	0xf552	; 0xf552 <fputc>
    e522:	81 10       	cpse	r8, r1
    e524:	8a 94       	dec	r8
    e526:	08 94       	sec
    e528:	e1 08       	sbc	r14, r1
    e52a:	f1 08       	sbc	r15, r1
    e52c:	e1 14       	cp	r14, r1
    e52e:	f1 04       	cpc	r15, r1
    e530:	71 f7       	brne	.-36     	; 0xe50e <vfprintf+0x516>
    e532:	f2 c0       	rjmp	.+484    	; 0xe718 <vfprintf+0x720>
    e534:	94 36       	cpi	r25, 0x64	; 100
    e536:	11 f0       	breq	.+4      	; 0xe53c <vfprintf+0x544>
    e538:	99 36       	cpi	r25, 0x69	; 105
    e53a:	89 f5       	brne	.+98     	; 0xe59e <vfprintf+0x5a6>
    e53c:	17 ff       	sbrs	r17, 7
    e53e:	08 c0       	rjmp	.+16     	; 0xe550 <vfprintf+0x558>
    e540:	f6 01       	movw	r30, r12
    e542:	20 81       	ld	r18, Z
    e544:	31 81       	ldd	r19, Z+1	; 0x01
    e546:	42 81       	ldd	r20, Z+2	; 0x02
    e548:	53 81       	ldd	r21, Z+3	; 0x03
    e54a:	84 e0       	ldi	r24, 0x04	; 4
    e54c:	90 e0       	ldi	r25, 0x00	; 0
    e54e:	0a c0       	rjmp	.+20     	; 0xe564 <vfprintf+0x56c>
    e550:	f6 01       	movw	r30, r12
    e552:	80 81       	ld	r24, Z
    e554:	91 81       	ldd	r25, Z+1	; 0x01
    e556:	9c 01       	movw	r18, r24
    e558:	44 27       	eor	r20, r20
    e55a:	37 fd       	sbrc	r19, 7
    e55c:	40 95       	com	r20
    e55e:	54 2f       	mov	r21, r20
    e560:	82 e0       	ldi	r24, 0x02	; 2
    e562:	90 e0       	ldi	r25, 0x00	; 0
    e564:	c8 0e       	add	r12, r24
    e566:	d9 1e       	adc	r13, r25
    e568:	9f e6       	ldi	r25, 0x6F	; 111
    e56a:	f9 2e       	mov	r15, r25
    e56c:	f1 22       	and	r15, r17
    e56e:	57 ff       	sbrs	r21, 7
    e570:	09 c0       	rjmp	.+18     	; 0xe584 <vfprintf+0x58c>
    e572:	50 95       	com	r21
    e574:	40 95       	com	r20
    e576:	30 95       	com	r19
    e578:	21 95       	neg	r18
    e57a:	3f 4f       	sbci	r19, 0xFF	; 255
    e57c:	4f 4f       	sbci	r20, 0xFF	; 255
    e57e:	5f 4f       	sbci	r21, 0xFF	; 255
    e580:	90 e8       	ldi	r25, 0x80	; 128
    e582:	f9 2a       	or	r15, r25
    e584:	ca 01       	movw	r24, r20
    e586:	b9 01       	movw	r22, r18
    e588:	ae 01       	movw	r20, r28
    e58a:	4f 5f       	subi	r20, 0xFF	; 255
    e58c:	5f 4f       	sbci	r21, 0xFF	; 255
    e58e:	2a e0       	ldi	r18, 0x0A	; 10
    e590:	30 e0       	ldi	r19, 0x00	; 0
    e592:	0e 94 97 7b 	call	0xf72e	; 0xf72e <__ultoa_invert>
    e596:	e8 2e       	mov	r14, r24
    e598:	e8 89       	ldd	r30, Y+16	; 0x10
    e59a:	ee 1a       	sub	r14, r30
    e59c:	41 c0       	rjmp	.+130    	; 0xe620 <vfprintf+0x628>
    e59e:	95 37       	cpi	r25, 0x75	; 117
    e5a0:	21 f4       	brne	.+8      	; 0xe5aa <vfprintf+0x5b2>
    e5a2:	1f 7e       	andi	r17, 0xEF	; 239
    e5a4:	2a e0       	ldi	r18, 0x0A	; 10
    e5a6:	30 e0       	ldi	r19, 0x00	; 0
    e5a8:	1c c0       	rjmp	.+56     	; 0xe5e2 <vfprintf+0x5ea>
    e5aa:	19 7f       	andi	r17, 0xF9	; 249
    e5ac:	9f 36       	cpi	r25, 0x6F	; 111
    e5ae:	61 f0       	breq	.+24     	; 0xe5c8 <vfprintf+0x5d0>
    e5b0:	90 37       	cpi	r25, 0x70	; 112
    e5b2:	20 f4       	brcc	.+8      	; 0xe5bc <vfprintf+0x5c4>
    e5b4:	98 35       	cpi	r25, 0x58	; 88
    e5b6:	09 f0       	breq	.+2      	; 0xe5ba <vfprintf+0x5c2>
    e5b8:	b2 c0       	rjmp	.+356    	; 0xe71e <vfprintf+0x726>
    e5ba:	0f c0       	rjmp	.+30     	; 0xe5da <vfprintf+0x5e2>
    e5bc:	90 37       	cpi	r25, 0x70	; 112
    e5be:	39 f0       	breq	.+14     	; 0xe5ce <vfprintf+0x5d6>
    e5c0:	98 37       	cpi	r25, 0x78	; 120
    e5c2:	09 f0       	breq	.+2      	; 0xe5c6 <vfprintf+0x5ce>
    e5c4:	ac c0       	rjmp	.+344    	; 0xe71e <vfprintf+0x726>
    e5c6:	04 c0       	rjmp	.+8      	; 0xe5d0 <vfprintf+0x5d8>
    e5c8:	28 e0       	ldi	r18, 0x08	; 8
    e5ca:	30 e0       	ldi	r19, 0x00	; 0
    e5cc:	0a c0       	rjmp	.+20     	; 0xe5e2 <vfprintf+0x5ea>
    e5ce:	10 61       	ori	r17, 0x10	; 16
    e5d0:	14 fd       	sbrc	r17, 4
    e5d2:	14 60       	ori	r17, 0x04	; 4
    e5d4:	20 e1       	ldi	r18, 0x10	; 16
    e5d6:	30 e0       	ldi	r19, 0x00	; 0
    e5d8:	04 c0       	rjmp	.+8      	; 0xe5e2 <vfprintf+0x5ea>
    e5da:	14 fd       	sbrc	r17, 4
    e5dc:	16 60       	ori	r17, 0x06	; 6
    e5de:	20 e1       	ldi	r18, 0x10	; 16
    e5e0:	32 e0       	ldi	r19, 0x02	; 2
    e5e2:	17 ff       	sbrs	r17, 7
    e5e4:	08 c0       	rjmp	.+16     	; 0xe5f6 <vfprintf+0x5fe>
    e5e6:	f6 01       	movw	r30, r12
    e5e8:	60 81       	ld	r22, Z
    e5ea:	71 81       	ldd	r23, Z+1	; 0x01
    e5ec:	82 81       	ldd	r24, Z+2	; 0x02
    e5ee:	93 81       	ldd	r25, Z+3	; 0x03
    e5f0:	44 e0       	ldi	r20, 0x04	; 4
    e5f2:	50 e0       	ldi	r21, 0x00	; 0
    e5f4:	08 c0       	rjmp	.+16     	; 0xe606 <vfprintf+0x60e>
    e5f6:	f6 01       	movw	r30, r12
    e5f8:	80 81       	ld	r24, Z
    e5fa:	91 81       	ldd	r25, Z+1	; 0x01
    e5fc:	bc 01       	movw	r22, r24
    e5fe:	80 e0       	ldi	r24, 0x00	; 0
    e600:	90 e0       	ldi	r25, 0x00	; 0
    e602:	42 e0       	ldi	r20, 0x02	; 2
    e604:	50 e0       	ldi	r21, 0x00	; 0
    e606:	c4 0e       	add	r12, r20
    e608:	d5 1e       	adc	r13, r21
    e60a:	ae 01       	movw	r20, r28
    e60c:	4f 5f       	subi	r20, 0xFF	; 255
    e60e:	5f 4f       	sbci	r21, 0xFF	; 255
    e610:	0e 94 97 7b 	call	0xf72e	; 0xf72e <__ultoa_invert>
    e614:	e8 2e       	mov	r14, r24
    e616:	58 89       	ldd	r21, Y+16	; 0x10
    e618:	e5 1a       	sub	r14, r21
    e61a:	8f e7       	ldi	r24, 0x7F	; 127
    e61c:	f8 2e       	mov	r15, r24
    e61e:	f1 22       	and	r15, r17
    e620:	f6 fe       	sbrs	r15, 6
    e622:	0b c0       	rjmp	.+22     	; 0xe63a <vfprintf+0x642>
    e624:	8e ef       	ldi	r24, 0xFE	; 254
    e626:	f8 22       	and	r15, r24
    e628:	e9 14       	cp	r14, r9
    e62a:	38 f4       	brcc	.+14     	; 0xe63a <vfprintf+0x642>
    e62c:	f4 fe       	sbrs	r15, 4
    e62e:	07 c0       	rjmp	.+14     	; 0xe63e <vfprintf+0x646>
    e630:	f2 fc       	sbrc	r15, 2
    e632:	05 c0       	rjmp	.+10     	; 0xe63e <vfprintf+0x646>
    e634:	9f ee       	ldi	r25, 0xEF	; 239
    e636:	f9 22       	and	r15, r25
    e638:	02 c0       	rjmp	.+4      	; 0xe63e <vfprintf+0x646>
    e63a:	1e 2d       	mov	r17, r14
    e63c:	01 c0       	rjmp	.+2      	; 0xe640 <vfprintf+0x648>
    e63e:	19 2d       	mov	r17, r9
    e640:	f4 fe       	sbrs	r15, 4
    e642:	0d c0       	rjmp	.+26     	; 0xe65e <vfprintf+0x666>
    e644:	fe 01       	movw	r30, r28
    e646:	ee 0d       	add	r30, r14
    e648:	f1 1d       	adc	r31, r1
    e64a:	80 81       	ld	r24, Z
    e64c:	80 33       	cpi	r24, 0x30	; 48
    e64e:	19 f4       	brne	.+6      	; 0xe656 <vfprintf+0x65e>
    e650:	e9 ee       	ldi	r30, 0xE9	; 233
    e652:	fe 22       	and	r15, r30
    e654:	08 c0       	rjmp	.+16     	; 0xe666 <vfprintf+0x66e>
    e656:	1f 5f       	subi	r17, 0xFF	; 255
    e658:	f2 fe       	sbrs	r15, 2
    e65a:	05 c0       	rjmp	.+10     	; 0xe666 <vfprintf+0x66e>
    e65c:	03 c0       	rjmp	.+6      	; 0xe664 <vfprintf+0x66c>
    e65e:	8f 2d       	mov	r24, r15
    e660:	86 78       	andi	r24, 0x86	; 134
    e662:	09 f0       	breq	.+2      	; 0xe666 <vfprintf+0x66e>
    e664:	1f 5f       	subi	r17, 0xFF	; 255
    e666:	0f 2d       	mov	r16, r15
    e668:	f3 fc       	sbrc	r15, 3
    e66a:	14 c0       	rjmp	.+40     	; 0xe694 <vfprintf+0x69c>
    e66c:	f0 fe       	sbrs	r15, 0
    e66e:	0f c0       	rjmp	.+30     	; 0xe68e <vfprintf+0x696>
    e670:	18 15       	cp	r17, r8
    e672:	10 f0       	brcs	.+4      	; 0xe678 <vfprintf+0x680>
    e674:	9e 2c       	mov	r9, r14
    e676:	0b c0       	rjmp	.+22     	; 0xe68e <vfprintf+0x696>
    e678:	9e 2c       	mov	r9, r14
    e67a:	98 0c       	add	r9, r8
    e67c:	91 1a       	sub	r9, r17
    e67e:	18 2d       	mov	r17, r8
    e680:	06 c0       	rjmp	.+12     	; 0xe68e <vfprintf+0x696>
    e682:	80 e2       	ldi	r24, 0x20	; 32
    e684:	90 e0       	ldi	r25, 0x00	; 0
    e686:	b3 01       	movw	r22, r6
    e688:	0e 94 a9 7a 	call	0xf552	; 0xf552 <fputc>
    e68c:	1f 5f       	subi	r17, 0xFF	; 255
    e68e:	18 15       	cp	r17, r8
    e690:	c0 f3       	brcs	.-16     	; 0xe682 <vfprintf+0x68a>
    e692:	04 c0       	rjmp	.+8      	; 0xe69c <vfprintf+0x6a4>
    e694:	18 15       	cp	r17, r8
    e696:	10 f4       	brcc	.+4      	; 0xe69c <vfprintf+0x6a4>
    e698:	81 1a       	sub	r8, r17
    e69a:	01 c0       	rjmp	.+2      	; 0xe69e <vfprintf+0x6a6>
    e69c:	88 24       	eor	r8, r8
    e69e:	04 ff       	sbrs	r16, 4
    e6a0:	0f c0       	rjmp	.+30     	; 0xe6c0 <vfprintf+0x6c8>
    e6a2:	80 e3       	ldi	r24, 0x30	; 48
    e6a4:	90 e0       	ldi	r25, 0x00	; 0
    e6a6:	b3 01       	movw	r22, r6
    e6a8:	0e 94 a9 7a 	call	0xf552	; 0xf552 <fputc>
    e6ac:	02 ff       	sbrs	r16, 2
    e6ae:	1d c0       	rjmp	.+58     	; 0xe6ea <vfprintf+0x6f2>
    e6b0:	01 fd       	sbrc	r16, 1
    e6b2:	03 c0       	rjmp	.+6      	; 0xe6ba <vfprintf+0x6c2>
    e6b4:	88 e7       	ldi	r24, 0x78	; 120
    e6b6:	90 e0       	ldi	r25, 0x00	; 0
    e6b8:	0e c0       	rjmp	.+28     	; 0xe6d6 <vfprintf+0x6de>
    e6ba:	88 e5       	ldi	r24, 0x58	; 88
    e6bc:	90 e0       	ldi	r25, 0x00	; 0
    e6be:	0b c0       	rjmp	.+22     	; 0xe6d6 <vfprintf+0x6de>
    e6c0:	80 2f       	mov	r24, r16
    e6c2:	86 78       	andi	r24, 0x86	; 134
    e6c4:	91 f0       	breq	.+36     	; 0xe6ea <vfprintf+0x6f2>
    e6c6:	01 ff       	sbrs	r16, 1
    e6c8:	02 c0       	rjmp	.+4      	; 0xe6ce <vfprintf+0x6d6>
    e6ca:	8b e2       	ldi	r24, 0x2B	; 43
    e6cc:	01 c0       	rjmp	.+2      	; 0xe6d0 <vfprintf+0x6d8>
    e6ce:	80 e2       	ldi	r24, 0x20	; 32
    e6d0:	f7 fc       	sbrc	r15, 7
    e6d2:	8d e2       	ldi	r24, 0x2D	; 45
    e6d4:	90 e0       	ldi	r25, 0x00	; 0
    e6d6:	b3 01       	movw	r22, r6
    e6d8:	0e 94 a9 7a 	call	0xf552	; 0xf552 <fputc>
    e6dc:	06 c0       	rjmp	.+12     	; 0xe6ea <vfprintf+0x6f2>
    e6de:	80 e3       	ldi	r24, 0x30	; 48
    e6e0:	90 e0       	ldi	r25, 0x00	; 0
    e6e2:	b3 01       	movw	r22, r6
    e6e4:	0e 94 a9 7a 	call	0xf552	; 0xf552 <fputc>
    e6e8:	9a 94       	dec	r9
    e6ea:	e9 14       	cp	r14, r9
    e6ec:	c0 f3       	brcs	.-16     	; 0xe6de <vfprintf+0x6e6>
    e6ee:	ea 94       	dec	r14
    e6f0:	e1 e0       	ldi	r30, 0x01	; 1
    e6f2:	f0 e0       	ldi	r31, 0x00	; 0
    e6f4:	ec 0f       	add	r30, r28
    e6f6:	fd 1f       	adc	r31, r29
    e6f8:	ee 0d       	add	r30, r14
    e6fa:	f1 1d       	adc	r31, r1
    e6fc:	80 81       	ld	r24, Z
    e6fe:	90 e0       	ldi	r25, 0x00	; 0
    e700:	b3 01       	movw	r22, r6
    e702:	0e 94 a9 7a 	call	0xf552	; 0xf552 <fputc>
    e706:	ee 20       	and	r14, r14
    e708:	91 f7       	brne	.-28     	; 0xe6ee <vfprintf+0x6f6>
    e70a:	06 c0       	rjmp	.+12     	; 0xe718 <vfprintf+0x720>
    e70c:	80 e2       	ldi	r24, 0x20	; 32
    e70e:	90 e0       	ldi	r25, 0x00	; 0
    e710:	b3 01       	movw	r22, r6
    e712:	0e 94 a9 7a 	call	0xf552	; 0xf552 <fputc>
    e716:	8a 94       	dec	r8
    e718:	88 20       	and	r8, r8
    e71a:	c1 f7       	brne	.-16     	; 0xe70c <vfprintf+0x714>
    e71c:	99 cc       	rjmp	.-1742   	; 0xe050 <vfprintf+0x58>
    e71e:	f3 01       	movw	r30, r6
    e720:	66 81       	ldd	r22, Z+6	; 0x06
    e722:	77 81       	ldd	r23, Z+7	; 0x07
    e724:	cb 01       	movw	r24, r22
    e726:	61 96       	adiw	r28, 0x11	; 17
    e728:	0f b6       	in	r0, 0x3f	; 63
    e72a:	f8 94       	cli
    e72c:	de bf       	out	0x3e, r29	; 62
    e72e:	0f be       	out	0x3f, r0	; 63
    e730:	cd bf       	out	0x3d, r28	; 61
    e732:	cf 91       	pop	r28
    e734:	df 91       	pop	r29
    e736:	1f 91       	pop	r17
    e738:	0f 91       	pop	r16
    e73a:	ff 90       	pop	r15
    e73c:	ef 90       	pop	r14
    e73e:	df 90       	pop	r13
    e740:	cf 90       	pop	r12
    e742:	bf 90       	pop	r11
    e744:	af 90       	pop	r10
    e746:	9f 90       	pop	r9
    e748:	8f 90       	pop	r8
    e74a:	7f 90       	pop	r7
    e74c:	6f 90       	pop	r6
    e74e:	5f 90       	pop	r5
    e750:	4f 90       	pop	r4
    e752:	3f 90       	pop	r3
    e754:	2f 90       	pop	r2
    e756:	08 95       	ret

0000e758 <putval>:
    e758:	fc 01       	movw	r30, r24
    e75a:	20 fd       	sbrc	r18, 0
    e75c:	08 c0       	rjmp	.+16     	; 0xe76e <putval+0x16>
    e75e:	23 fd       	sbrc	r18, 3
    e760:	05 c0       	rjmp	.+10     	; 0xe76c <putval+0x14>
    e762:	22 ff       	sbrs	r18, 2
    e764:	02 c0       	rjmp	.+4      	; 0xe76a <putval+0x12>
    e766:	73 83       	std	Z+3, r23	; 0x03
    e768:	62 83       	std	Z+2, r22	; 0x02
    e76a:	51 83       	std	Z+1, r21	; 0x01
    e76c:	40 83       	st	Z, r20
    e76e:	08 95       	ret

0000e770 <mulacc>:
    e770:	ef 92       	push	r14
    e772:	ff 92       	push	r15
    e774:	0f 93       	push	r16
    e776:	1f 93       	push	r17
    e778:	44 ff       	sbrs	r20, 4
    e77a:	02 c0       	rjmp	.+4      	; 0xe780 <mulacc+0x10>
    e77c:	33 e0       	ldi	r19, 0x03	; 3
    e77e:	11 c0       	rjmp	.+34     	; 0xe7a2 <mulacc+0x32>
    e780:	46 ff       	sbrs	r20, 6
    e782:	02 c0       	rjmp	.+4      	; 0xe788 <mulacc+0x18>
    e784:	34 e0       	ldi	r19, 0x04	; 4
    e786:	0d c0       	rjmp	.+26     	; 0xe7a2 <mulacc+0x32>
    e788:	db 01       	movw	r26, r22
    e78a:	fc 01       	movw	r30, r24
    e78c:	aa 0f       	add	r26, r26
    e78e:	bb 1f       	adc	r27, r27
    e790:	ee 1f       	adc	r30, r30
    e792:	ff 1f       	adc	r31, r31
    e794:	10 94       	com	r1
    e796:	d1 f7       	brne	.-12     	; 0xe78c <mulacc+0x1c>
    e798:	6a 0f       	add	r22, r26
    e79a:	7b 1f       	adc	r23, r27
    e79c:	8e 1f       	adc	r24, r30
    e79e:	9f 1f       	adc	r25, r31
    e7a0:	31 e0       	ldi	r19, 0x01	; 1
    e7a2:	66 0f       	add	r22, r22
    e7a4:	77 1f       	adc	r23, r23
    e7a6:	88 1f       	adc	r24, r24
    e7a8:	99 1f       	adc	r25, r25
    e7aa:	31 50       	subi	r19, 0x01	; 1
    e7ac:	d1 f7       	brne	.-12     	; 0xe7a2 <mulacc+0x32>
    e7ae:	7b 01       	movw	r14, r22
    e7b0:	8c 01       	movw	r16, r24
    e7b2:	e2 0e       	add	r14, r18
    e7b4:	f1 1c       	adc	r15, r1
    e7b6:	01 1d       	adc	r16, r1
    e7b8:	11 1d       	adc	r17, r1
    e7ba:	a8 01       	movw	r20, r16
    e7bc:	97 01       	movw	r18, r14
    e7be:	b7 01       	movw	r22, r14
    e7c0:	ca 01       	movw	r24, r20
    e7c2:	1f 91       	pop	r17
    e7c4:	0f 91       	pop	r16
    e7c6:	ff 90       	pop	r15
    e7c8:	ef 90       	pop	r14
    e7ca:	08 95       	ret

0000e7cc <skip_spaces>:
    e7cc:	0f 93       	push	r16
    e7ce:	1f 93       	push	r17
    e7d0:	cf 93       	push	r28
    e7d2:	df 93       	push	r29
    e7d4:	8c 01       	movw	r16, r24
    e7d6:	c8 01       	movw	r24, r16
    e7d8:	0e 94 67 7a 	call	0xf4ce	; 0xf4ce <fgetc>
    e7dc:	ec 01       	movw	r28, r24
    e7de:	97 fd       	sbrc	r25, 7
    e7e0:	08 c0       	rjmp	.+16     	; 0xe7f2 <skip_spaces+0x26>
    e7e2:	0e 94 be 79 	call	0xf37c	; 0xf37c <isspace>
    e7e6:	89 2b       	or	r24, r25
    e7e8:	b1 f7       	brne	.-20     	; 0xe7d6 <skip_spaces+0xa>
    e7ea:	ce 01       	movw	r24, r28
    e7ec:	b8 01       	movw	r22, r16
    e7ee:	0e 94 7d 7b 	call	0xf6fa	; 0xf6fa <ungetc>
    e7f2:	ce 01       	movw	r24, r28
    e7f4:	df 91       	pop	r29
    e7f6:	cf 91       	pop	r28
    e7f8:	1f 91       	pop	r17
    e7fa:	0f 91       	pop	r16
    e7fc:	08 95       	ret

0000e7fe <conv_int>:
    e7fe:	8f 92       	push	r8
    e800:	9f 92       	push	r9
    e802:	af 92       	push	r10
    e804:	bf 92       	push	r11
    e806:	df 92       	push	r13
    e808:	ef 92       	push	r14
    e80a:	ff 92       	push	r15
    e80c:	0f 93       	push	r16
    e80e:	1f 93       	push	r17
    e810:	cf 93       	push	r28
    e812:	df 93       	push	r29
    e814:	5c 01       	movw	r10, r24
    e816:	eb 01       	movw	r28, r22
    e818:	4a 01       	movw	r8, r20
    e81a:	12 2f       	mov	r17, r18
    e81c:	0e 94 67 7a 	call	0xf4ce	; 0xf4ce <fgetc>
    e820:	ac 01       	movw	r20, r24
    e822:	8b 32       	cpi	r24, 0x2B	; 43
    e824:	19 f0       	breq	.+6      	; 0xe82c <conv_int+0x2e>
    e826:	8d 32       	cpi	r24, 0x2D	; 45
    e828:	51 f4       	brne	.+20     	; 0xe83e <conv_int+0x40>
    e82a:	10 68       	ori	r17, 0x80	; 128
    e82c:	21 97       	sbiw	r28, 0x01	; 1
    e82e:	09 f4       	brne	.+2      	; 0xe832 <conv_int+0x34>
    e830:	6d c0       	rjmp	.+218    	; 0xe90c <conv_int+0x10e>
    e832:	c5 01       	movw	r24, r10
    e834:	0e 94 67 7a 	call	0xf4ce	; 0xf4ce <fgetc>
    e838:	ac 01       	movw	r20, r24
    e83a:	97 fd       	sbrc	r25, 7
    e83c:	67 c0       	rjmp	.+206    	; 0xe90c <conv_int+0x10e>
    e83e:	6d ef       	ldi	r22, 0xFD	; 253
    e840:	d6 2e       	mov	r13, r22
    e842:	d1 22       	and	r13, r17
    e844:	8d 2d       	mov	r24, r13
    e846:	80 73       	andi	r24, 0x30	; 48
    e848:	01 f5       	brne	.+64     	; 0xe88a <conv_int+0x8c>
    e84a:	40 33       	cpi	r20, 0x30	; 48
    e84c:	f1 f4       	brne	.+60     	; 0xe88a <conv_int+0x8c>
    e84e:	21 97       	sbiw	r28, 0x01	; 1
    e850:	09 f4       	brne	.+2      	; 0xe854 <conv_int+0x56>
    e852:	47 c0       	rjmp	.+142    	; 0xe8e2 <conv_int+0xe4>
    e854:	c5 01       	movw	r24, r10
    e856:	0e 94 67 7a 	call	0xf4ce	; 0xf4ce <fgetc>
    e85a:	ac 01       	movw	r20, r24
    e85c:	97 fd       	sbrc	r25, 7
    e85e:	41 c0       	rjmp	.+130    	; 0xe8e2 <conv_int+0xe4>
    e860:	82 e0       	ldi	r24, 0x02	; 2
    e862:	d8 2a       	or	r13, r24
    e864:	48 37       	cpi	r20, 0x78	; 120
    e866:	11 f0       	breq	.+4      	; 0xe86c <conv_int+0x6e>
    e868:	48 35       	cpi	r20, 0x58	; 88
    e86a:	59 f4       	brne	.+22     	; 0xe882 <conv_int+0x84>
    e86c:	80 e4       	ldi	r24, 0x40	; 64
    e86e:	d8 2a       	or	r13, r24
    e870:	21 97       	sbiw	r28, 0x01	; 1
    e872:	b9 f1       	breq	.+110    	; 0xe8e2 <conv_int+0xe4>
    e874:	c5 01       	movw	r24, r10
    e876:	0e 94 67 7a 	call	0xf4ce	; 0xf4ce <fgetc>
    e87a:	ac 01       	movw	r20, r24
    e87c:	99 23       	and	r25, r25
    e87e:	2c f4       	brge	.+10     	; 0xe88a <conv_int+0x8c>
    e880:	30 c0       	rjmp	.+96     	; 0xe8e2 <conv_int+0xe4>
    e882:	d6 fc       	sbrc	r13, 6
    e884:	02 c0       	rjmp	.+4      	; 0xe88a <conv_int+0x8c>
    e886:	80 e1       	ldi	r24, 0x10	; 16
    e888:	d8 2a       	or	r13, r24
    e88a:	ee 24       	eor	r14, r14
    e88c:	ff 24       	eor	r15, r15
    e88e:	87 01       	movw	r16, r14
    e890:	24 2f       	mov	r18, r20
    e892:	20 53       	subi	r18, 0x30	; 48
    e894:	28 30       	cpi	r18, 0x08	; 8
    e896:	88 f0       	brcs	.+34     	; 0xe8ba <conv_int+0xbc>
    e898:	d4 fc       	sbrc	r13, 4
    e89a:	09 c0       	rjmp	.+18     	; 0xe8ae <conv_int+0xb0>
    e89c:	2a 30       	cpi	r18, 0x0A	; 10
    e89e:	68 f0       	brcs	.+26     	; 0xe8ba <conv_int+0xbc>
    e8a0:	d6 fe       	sbrs	r13, 6
    e8a2:	05 c0       	rjmp	.+10     	; 0xe8ae <conv_int+0xb0>
    e8a4:	2f 7d       	andi	r18, 0xDF	; 223
    e8a6:	82 2f       	mov	r24, r18
    e8a8:	81 51       	subi	r24, 0x11	; 17
    e8aa:	86 30       	cpi	r24, 0x06	; 6
    e8ac:	28 f0       	brcs	.+10     	; 0xe8b8 <conv_int+0xba>
    e8ae:	ca 01       	movw	r24, r20
    e8b0:	b5 01       	movw	r22, r10
    e8b2:	0e 94 7d 7b 	call	0xf6fa	; 0xf6fa <ungetc>
    e8b6:	12 c0       	rjmp	.+36     	; 0xe8dc <conv_int+0xde>
    e8b8:	27 50       	subi	r18, 0x07	; 7
    e8ba:	c8 01       	movw	r24, r16
    e8bc:	b7 01       	movw	r22, r14
    e8be:	4d 2d       	mov	r20, r13
    e8c0:	0e 94 b8 73 	call	0xe770	; 0xe770 <mulacc>
    e8c4:	7b 01       	movw	r14, r22
    e8c6:	8c 01       	movw	r16, r24
    e8c8:	82 e0       	ldi	r24, 0x02	; 2
    e8ca:	d8 2a       	or	r13, r24
    e8cc:	21 97       	sbiw	r28, 0x01	; 1
    e8ce:	61 f0       	breq	.+24     	; 0xe8e8 <conv_int+0xea>
    e8d0:	c5 01       	movw	r24, r10
    e8d2:	0e 94 67 7a 	call	0xf4ce	; 0xf4ce <fgetc>
    e8d6:	ac 01       	movw	r20, r24
    e8d8:	97 ff       	sbrs	r25, 7
    e8da:	da cf       	rjmp	.-76     	; 0xe890 <conv_int+0x92>
    e8dc:	d1 fc       	sbrc	r13, 1
    e8de:	04 c0       	rjmp	.+8      	; 0xe8e8 <conv_int+0xea>
    e8e0:	15 c0       	rjmp	.+42     	; 0xe90c <conv_int+0x10e>
    e8e2:	ee 24       	eor	r14, r14
    e8e4:	ff 24       	eor	r15, r15
    e8e6:	87 01       	movw	r16, r14
    e8e8:	d7 fe       	sbrs	r13, 7
    e8ea:	08 c0       	rjmp	.+16     	; 0xe8fc <conv_int+0xfe>
    e8ec:	10 95       	com	r17
    e8ee:	00 95       	com	r16
    e8f0:	f0 94       	com	r15
    e8f2:	e0 94       	com	r14
    e8f4:	e1 1c       	adc	r14, r1
    e8f6:	f1 1c       	adc	r15, r1
    e8f8:	01 1d       	adc	r16, r1
    e8fa:	11 1d       	adc	r17, r1
    e8fc:	c4 01       	movw	r24, r8
    e8fe:	b8 01       	movw	r22, r16
    e900:	a7 01       	movw	r20, r14
    e902:	2d 2d       	mov	r18, r13
    e904:	0e 94 ac 73 	call	0xe758	; 0xe758 <putval>
    e908:	81 e0       	ldi	r24, 0x01	; 1
    e90a:	01 c0       	rjmp	.+2      	; 0xe90e <conv_int+0x110>
    e90c:	80 e0       	ldi	r24, 0x00	; 0
    e90e:	df 91       	pop	r29
    e910:	cf 91       	pop	r28
    e912:	1f 91       	pop	r17
    e914:	0f 91       	pop	r16
    e916:	ff 90       	pop	r15
    e918:	ef 90       	pop	r14
    e91a:	df 90       	pop	r13
    e91c:	bf 90       	pop	r11
    e91e:	af 90       	pop	r10
    e920:	9f 90       	pop	r9
    e922:	8f 90       	pop	r8
    e924:	08 95       	ret

0000e926 <conv_brk>:
    e926:	6f 92       	push	r6
    e928:	7f 92       	push	r7
    e92a:	8f 92       	push	r8
    e92c:	9f 92       	push	r9
    e92e:	af 92       	push	r10
    e930:	bf 92       	push	r11
    e932:	cf 92       	push	r12
    e934:	df 92       	push	r13
    e936:	ef 92       	push	r14
    e938:	ff 92       	push	r15
    e93a:	0f 93       	push	r16
    e93c:	1f 93       	push	r17
    e93e:	df 93       	push	r29
    e940:	cf 93       	push	r28
    e942:	cd b7       	in	r28, 0x3d	; 61
    e944:	de b7       	in	r29, 0x3e	; 62
    e946:	a0 97       	sbiw	r28, 0x20	; 32
    e948:	0f b6       	in	r0, 0x3f	; 63
    e94a:	f8 94       	cli
    e94c:	de bf       	out	0x3e, r29	; 62
    e94e:	0f be       	out	0x3f, r0	; 63
    e950:	cd bf       	out	0x3d, r28	; 61
    e952:	5c 01       	movw	r10, r24
    e954:	6b 01       	movw	r12, r22
    e956:	8a 01       	movw	r16, r20
    e958:	79 01       	movw	r14, r18
    e95a:	fe 01       	movw	r30, r28
    e95c:	31 96       	adiw	r30, 0x01	; 1
    e95e:	80 e2       	ldi	r24, 0x20	; 32
    e960:	df 01       	movw	r26, r30
    e962:	1d 92       	st	X+, r1
    e964:	8a 95       	dec	r24
    e966:	e9 f7       	brne	.-6      	; 0xe962 <conv_brk+0x3c>
    e968:	70 e0       	ldi	r23, 0x00	; 0
    e96a:	30 e0       	ldi	r19, 0x00	; 0
    e96c:	60 e0       	ldi	r22, 0x00	; 0
    e96e:	40 e0       	ldi	r20, 0x00	; 0
    e970:	50 e0       	ldi	r21, 0x00	; 0
    e972:	3f 01       	movw	r6, r30
    e974:	a1 e0       	ldi	r26, 0x01	; 1
    e976:	b0 e0       	ldi	r27, 0x00	; 0
    e978:	f5 01       	movw	r30, r10
    e97a:	83 81       	ldd	r24, Z+3	; 0x03
    e97c:	f7 01       	movw	r30, r14
    e97e:	83 fd       	sbrc	r24, 3
    e980:	25 91       	lpm	r18, Z+
    e982:	83 ff       	sbrs	r24, 3
    e984:	21 91       	ld	r18, Z+
    e986:	7f 01       	movw	r14, r30
    e988:	22 23       	and	r18, r18
    e98a:	09 f4       	brne	.+2      	; 0xe98e <conv_brk+0x68>
    e98c:	81 c0       	rjmp	.+258    	; 0xea90 <conv_brk+0x16a>
    e98e:	2e 35       	cpi	r18, 0x5E	; 94
    e990:	19 f4       	brne	.+6      	; 0xe998 <conv_brk+0x72>
    e992:	41 15       	cp	r20, r1
    e994:	51 05       	cpc	r21, r1
    e996:	69 f1       	breq	.+90     	; 0xe9f2 <conv_brk+0xcc>
    e998:	87 2f       	mov	r24, r23
    e99a:	90 e0       	ldi	r25, 0x00	; 0
    e99c:	84 17       	cp	r24, r20
    e99e:	95 07       	cpc	r25, r21
    e9a0:	44 f4       	brge	.+16     	; 0xe9b2 <conv_brk+0x8c>
    e9a2:	2d 35       	cpi	r18, 0x5D	; 93
    e9a4:	51 f1       	breq	.+84     	; 0xe9fa <conv_brk+0xd4>
    e9a6:	2d 32       	cpi	r18, 0x2D	; 45
    e9a8:	21 f4       	brne	.+8      	; 0xe9b2 <conv_brk+0x8c>
    e9aa:	33 23       	and	r19, r19
    e9ac:	29 f4       	brne	.+10     	; 0xe9b8 <conv_brk+0x92>
    e9ae:	31 e0       	ldi	r19, 0x01	; 1
    e9b0:	21 c0       	rjmp	.+66     	; 0xe9f4 <conv_brk+0xce>
    e9b2:	33 23       	and	r19, r19
    e9b4:	09 f4       	brne	.+2      	; 0xe9b8 <conv_brk+0x92>
    e9b6:	62 2f       	mov	r22, r18
    e9b8:	32 2f       	mov	r19, r18
    e9ba:	83 2f       	mov	r24, r19
    e9bc:	86 95       	lsr	r24
    e9be:	86 95       	lsr	r24
    e9c0:	86 95       	lsr	r24
    e9c2:	f3 01       	movw	r30, r6
    e9c4:	e8 0f       	add	r30, r24
    e9c6:	f1 1d       	adc	r31, r1
    e9c8:	83 2f       	mov	r24, r19
    e9ca:	87 70       	andi	r24, 0x07	; 7
    e9cc:	4d 01       	movw	r8, r26
    e9ce:	02 c0       	rjmp	.+4      	; 0xe9d4 <conv_brk+0xae>
    e9d0:	88 0c       	add	r8, r8
    e9d2:	99 1c       	adc	r9, r9
    e9d4:	8a 95       	dec	r24
    e9d6:	e2 f7       	brpl	.-8      	; 0xe9d0 <conv_brk+0xaa>
    e9d8:	20 81       	ld	r18, Z
    e9da:	28 29       	or	r18, r8
    e9dc:	20 83       	st	Z, r18
    e9de:	36 17       	cp	r19, r22
    e9e0:	11 f4       	brne	.+4      	; 0xe9e6 <conv_brk+0xc0>
    e9e2:	30 e0       	ldi	r19, 0x00	; 0
    e9e4:	07 c0       	rjmp	.+14     	; 0xe9f4 <conv_brk+0xce>
    e9e6:	36 17       	cp	r19, r22
    e9e8:	10 f4       	brcc	.+4      	; 0xe9ee <conv_brk+0xc8>
    e9ea:	3f 5f       	subi	r19, 0xFF	; 255
    e9ec:	e6 cf       	rjmp	.-52     	; 0xe9ba <conv_brk+0x94>
    e9ee:	31 50       	subi	r19, 0x01	; 1
    e9f0:	e4 cf       	rjmp	.-56     	; 0xe9ba <conv_brk+0x94>
    e9f2:	71 e0       	ldi	r23, 0x01	; 1
    e9f4:	4f 5f       	subi	r20, 0xFF	; 255
    e9f6:	5f 4f       	sbci	r21, 0xFF	; 255
    e9f8:	bf cf       	rjmp	.-130    	; 0xe978 <conv_brk+0x52>
    e9fa:	33 23       	and	r19, r19
    e9fc:	19 f0       	breq	.+6      	; 0xea04 <conv_brk+0xde>
    e9fe:	8e 81       	ldd	r24, Y+6	; 0x06
    ea00:	80 62       	ori	r24, 0x20	; 32
    ea02:	8e 83       	std	Y+6, r24	; 0x06
    ea04:	77 23       	and	r23, r23
    ea06:	59 f0       	breq	.+22     	; 0xea1e <conv_brk+0xf8>
    ea08:	fe 01       	movw	r30, r28
    ea0a:	31 96       	adiw	r30, 0x01	; 1
    ea0c:	9e 01       	movw	r18, r28
    ea0e:	2f 5d       	subi	r18, 0xDF	; 223
    ea10:	3f 4f       	sbci	r19, 0xFF	; 255
    ea12:	80 81       	ld	r24, Z
    ea14:	80 95       	com	r24
    ea16:	81 93       	st	Z+, r24
    ea18:	e2 17       	cp	r30, r18
    ea1a:	f3 07       	cpc	r31, r19
    ea1c:	d1 f7       	brne	.-12     	; 0xea12 <conv_brk+0xec>
    ea1e:	99 24       	eor	r9, r9
    ea20:	93 94       	inc	r9
    ea22:	3e 01       	movw	r6, r28
    ea24:	08 94       	sec
    ea26:	61 1c       	adc	r6, r1
    ea28:	71 1c       	adc	r7, r1
    ea2a:	c5 01       	movw	r24, r10
    ea2c:	0e 94 67 7a 	call	0xf4ce	; 0xf4ce <fgetc>
    ea30:	ac 01       	movw	r20, r24
    ea32:	97 fd       	sbrc	r25, 7
    ea34:	25 c0       	rjmp	.+74     	; 0xea80 <conv_brk+0x15a>
    ea36:	86 95       	lsr	r24
    ea38:	86 95       	lsr	r24
    ea3a:	86 95       	lsr	r24
    ea3c:	f3 01       	movw	r30, r6
    ea3e:	e8 0f       	add	r30, r24
    ea40:	f1 1d       	adc	r31, r1
    ea42:	80 81       	ld	r24, Z
    ea44:	90 e0       	ldi	r25, 0x00	; 0
    ea46:	9a 01       	movw	r18, r20
    ea48:	27 70       	andi	r18, 0x07	; 7
    ea4a:	30 70       	andi	r19, 0x00	; 0
    ea4c:	02 c0       	rjmp	.+4      	; 0xea52 <conv_brk+0x12c>
    ea4e:	95 95       	asr	r25
    ea50:	87 95       	ror	r24
    ea52:	2a 95       	dec	r18
    ea54:	e2 f7       	brpl	.-8      	; 0xea4e <conv_brk+0x128>
    ea56:	80 fd       	sbrc	r24, 0
    ea58:	05 c0       	rjmp	.+10     	; 0xea64 <conv_brk+0x13e>
    ea5a:	ca 01       	movw	r24, r20
    ea5c:	b5 01       	movw	r22, r10
    ea5e:	0e 94 7d 7b 	call	0xf6fa	; 0xf6fa <ungetc>
    ea62:	0e c0       	rjmp	.+28     	; 0xea80 <conv_brk+0x15a>
    ea64:	01 15       	cp	r16, r1
    ea66:	11 05       	cpc	r17, r1
    ea68:	19 f0       	breq	.+6      	; 0xea70 <conv_brk+0x14a>
    ea6a:	d8 01       	movw	r26, r16
    ea6c:	4d 93       	st	X+, r20
    ea6e:	8d 01       	movw	r16, r26
    ea70:	08 94       	sec
    ea72:	c1 08       	sbc	r12, r1
    ea74:	d1 08       	sbc	r13, r1
    ea76:	99 24       	eor	r9, r9
    ea78:	c1 14       	cp	r12, r1
    ea7a:	d1 04       	cpc	r13, r1
    ea7c:	b1 f6       	brne	.-84     	; 0xea2a <conv_brk+0x104>
    ea7e:	02 c0       	rjmp	.+4      	; 0xea84 <conv_brk+0x15e>
    ea80:	99 20       	and	r9, r9
    ea82:	31 f4       	brne	.+12     	; 0xea90 <conv_brk+0x16a>
    ea84:	01 15       	cp	r16, r1
    ea86:	11 05       	cpc	r17, r1
    ea88:	29 f0       	breq	.+10     	; 0xea94 <conv_brk+0x16e>
    ea8a:	f8 01       	movw	r30, r16
    ea8c:	10 82       	st	Z, r1
    ea8e:	02 c0       	rjmp	.+4      	; 0xea94 <conv_brk+0x16e>
    ea90:	ee 24       	eor	r14, r14
    ea92:	ff 24       	eor	r15, r15
    ea94:	c7 01       	movw	r24, r14
    ea96:	a0 96       	adiw	r28, 0x20	; 32
    ea98:	0f b6       	in	r0, 0x3f	; 63
    ea9a:	f8 94       	cli
    ea9c:	de bf       	out	0x3e, r29	; 62
    ea9e:	0f be       	out	0x3f, r0	; 63
    eaa0:	cd bf       	out	0x3d, r28	; 61
    eaa2:	cf 91       	pop	r28
    eaa4:	df 91       	pop	r29
    eaa6:	1f 91       	pop	r17
    eaa8:	0f 91       	pop	r16
    eaaa:	ff 90       	pop	r15
    eaac:	ef 90       	pop	r14
    eaae:	df 90       	pop	r13
    eab0:	cf 90       	pop	r12
    eab2:	bf 90       	pop	r11
    eab4:	af 90       	pop	r10
    eab6:	9f 90       	pop	r9
    eab8:	8f 90       	pop	r8
    eaba:	7f 90       	pop	r7
    eabc:	6f 90       	pop	r6
    eabe:	08 95       	ret

0000eac0 <conv_flt>:
    eac0:	2f 92       	push	r2
    eac2:	3f 92       	push	r3
    eac4:	5f 92       	push	r5
    eac6:	6f 92       	push	r6
    eac8:	7f 92       	push	r7
    eaca:	8f 92       	push	r8
    eacc:	9f 92       	push	r9
    eace:	af 92       	push	r10
    ead0:	bf 92       	push	r11
    ead2:	cf 92       	push	r12
    ead4:	df 92       	push	r13
    ead6:	ef 92       	push	r14
    ead8:	ff 92       	push	r15
    eada:	0f 93       	push	r16
    eadc:	1f 93       	push	r17
    eade:	cf 93       	push	r28
    eae0:	df 93       	push	r29
    eae2:	3c 01       	movw	r6, r24
    eae4:	7b 01       	movw	r14, r22
    eae6:	1a 01       	movw	r2, r20
    eae8:	0e 94 67 7a 	call	0xf4ce	; 0xf4ce <fgetc>
    eaec:	ec 01       	movw	r28, r24
    eaee:	8b 32       	cpi	r24, 0x2B	; 43
    eaf0:	39 f0       	breq	.+14     	; 0xeb00 <conv_flt+0x40>
    eaf2:	8d 32       	cpi	r24, 0x2D	; 45
    eaf4:	11 f0       	breq	.+4      	; 0xeafa <conv_flt+0x3a>
    eaf6:	55 24       	eor	r5, r5
    eaf8:	11 c0       	rjmp	.+34     	; 0xeb1c <conv_flt+0x5c>
    eafa:	b0 e8       	ldi	r27, 0x80	; 128
    eafc:	5b 2e       	mov	r5, r27
    eafe:	01 c0       	rjmp	.+2      	; 0xeb02 <conv_flt+0x42>
    eb00:	55 24       	eor	r5, r5
    eb02:	08 94       	sec
    eb04:	e1 08       	sbc	r14, r1
    eb06:	f1 08       	sbc	r15, r1
    eb08:	e1 14       	cp	r14, r1
    eb0a:	f1 04       	cpc	r15, r1
    eb0c:	09 f4       	brne	.+2      	; 0xeb10 <conv_flt+0x50>
    eb0e:	18 c1       	rjmp	.+560    	; 0xed40 <conv_flt+0x280>
    eb10:	c3 01       	movw	r24, r6
    eb12:	0e 94 67 7a 	call	0xf4ce	; 0xf4ce <fgetc>
    eb16:	ec 01       	movw	r28, r24
    eb18:	97 fd       	sbrc	r25, 7
    eb1a:	12 c1       	rjmp	.+548    	; 0xed40 <conv_flt+0x280>
    eb1c:	ce 01       	movw	r24, r28
    eb1e:	0e 94 c6 79 	call	0xf38c	; 0xf38c <tolower>
    eb22:	89 36       	cpi	r24, 0x69	; 105
    eb24:	91 05       	cpc	r25, r1
    eb26:	21 f0       	breq	.+8      	; 0xeb30 <conv_flt+0x70>
    eb28:	8e 36       	cpi	r24, 0x6E	; 110
    eb2a:	91 05       	cpc	r25, r1
    eb2c:	99 f5       	brne	.+102    	; 0xeb94 <conv_flt+0xd4>
    eb2e:	1d c0       	rjmp	.+58     	; 0xeb6a <conv_flt+0xaa>
    eb30:	0d eb       	ldi	r16, 0xBD	; 189
    eb32:	12 e0       	ldi	r17, 0x02	; 2
    eb34:	1c c0       	rjmp	.+56     	; 0xeb6e <conv_flt+0xae>
    eb36:	08 94       	sec
    eb38:	e1 08       	sbc	r14, r1
    eb3a:	f1 08       	sbc	r15, r1
    eb3c:	e1 14       	cp	r14, r1
    eb3e:	f1 04       	cpc	r15, r1
    eb40:	71 f0       	breq	.+28     	; 0xeb5e <conv_flt+0x9e>
    eb42:	c3 01       	movw	r24, r6
    eb44:	0e 94 67 7a 	call	0xf4ce	; 0xf4ce <fgetc>
    eb48:	ec 01       	movw	r28, r24
    eb4a:	97 fd       	sbrc	r25, 7
    eb4c:	08 c0       	rjmp	.+16     	; 0xeb5e <conv_flt+0x9e>
    eb4e:	0e 94 c6 79 	call	0xf38c	; 0xf38c <tolower>
    eb52:	d8 16       	cp	r13, r24
    eb54:	61 f0       	breq	.+24     	; 0xeb6e <conv_flt+0xae>
    eb56:	ce 01       	movw	r24, r28
    eb58:	b3 01       	movw	r22, r6
    eb5a:	0e 94 7d 7b 	call	0xf6fa	; 0xf6fa <ungetc>
    eb5e:	22 e0       	ldi	r18, 0x02	; 2
    eb60:	00 3c       	cpi	r16, 0xC0	; 192
    eb62:	12 07       	cpc	r17, r18
    eb64:	09 f0       	breq	.+2      	; 0xeb68 <conv_flt+0xa8>
    eb66:	ec c0       	rjmp	.+472    	; 0xed40 <conv_flt+0x280>
    eb68:	08 c0       	rjmp	.+16     	; 0xeb7a <conv_flt+0xba>
    eb6a:	0a eb       	ldi	r16, 0xBA	; 186
    eb6c:	12 e0       	ldi	r17, 0x02	; 2
    eb6e:	f8 01       	movw	r30, r16
    eb70:	0f 5f       	subi	r16, 0xFF	; 255
    eb72:	1f 4f       	sbci	r17, 0xFF	; 255
    eb74:	d4 90       	lpm	r13, Z+
    eb76:	dd 20       	and	r13, r13
    eb78:	f1 f6       	brne	.-68     	; 0xeb36 <conv_flt+0x76>
    eb7a:	0d 5b       	subi	r16, 0xBD	; 189
    eb7c:	12 40       	sbci	r17, 0x02	; 2
    eb7e:	29 f0       	breq	.+10     	; 0xeb8a <conv_flt+0xca>
    eb80:	80 e0       	ldi	r24, 0x00	; 0
    eb82:	90 e0       	ldi	r25, 0x00	; 0
    eb84:	a0 e8       	ldi	r26, 0x80	; 128
    eb86:	bf e7       	ldi	r27, 0x7F	; 127
    eb88:	cf c0       	rjmp	.+414    	; 0xed28 <conv_flt+0x268>
    eb8a:	80 e0       	ldi	r24, 0x00	; 0
    eb8c:	90 e0       	ldi	r25, 0x00	; 0
    eb8e:	a0 ec       	ldi	r26, 0xC0	; 192
    eb90:	bf e7       	ldi	r27, 0x7F	; 127
    eb92:	ca c0       	rjmp	.+404    	; 0xed28 <conv_flt+0x268>
    eb94:	cc 24       	eor	r12, r12
    eb96:	dd 24       	eor	r13, r13
    eb98:	88 24       	eor	r8, r8
    eb9a:	99 24       	eor	r9, r9
    eb9c:	54 01       	movw	r10, r8
    eb9e:	ae 01       	movw	r20, r28
    eba0:	40 53       	subi	r20, 0x30	; 48
    eba2:	24 2f       	mov	r18, r20
    eba4:	4a 30       	cpi	r20, 0x0A	; 10
    eba6:	38 f5       	brcc	.+78     	; 0xebf6 <conv_flt+0x136>
    eba8:	52 e0       	ldi	r21, 0x02	; 2
    ebaa:	55 2a       	or	r5, r21
    ebac:	85 2d       	mov	r24, r5
    ebae:	90 e0       	ldi	r25, 0x00	; 0
    ebb0:	ac 01       	movw	r20, r24
    ebb2:	48 70       	andi	r20, 0x08	; 8
    ebb4:	50 70       	andi	r21, 0x00	; 0
    ebb6:	52 fe       	sbrs	r5, 2
    ebb8:	06 c0       	rjmp	.+12     	; 0xebc6 <conv_flt+0x106>
    ebba:	45 2b       	or	r20, r21
    ebbc:	11 f5       	brne	.+68     	; 0xec02 <conv_flt+0x142>
    ebbe:	08 94       	sec
    ebc0:	c1 1c       	adc	r12, r1
    ebc2:	d1 1c       	adc	r13, r1
    ebc4:	1e c0       	rjmp	.+60     	; 0xec02 <conv_flt+0x142>
    ebc6:	45 2b       	or	r20, r21
    ebc8:	19 f0       	breq	.+6      	; 0xebd0 <conv_flt+0x110>
    ebca:	08 94       	sec
    ebcc:	c1 08       	sbc	r12, r1
    ebce:	d1 08       	sbc	r13, r1
    ebd0:	c5 01       	movw	r24, r10
    ebd2:	b4 01       	movw	r22, r8
    ebd4:	40 e2       	ldi	r20, 0x20	; 32
    ebd6:	0e 94 b8 73 	call	0xe770	; 0xe770 <mulacc>
    ebda:	4b 01       	movw	r8, r22
    ebdc:	5c 01       	movw	r10, r24
    ebde:	88 e9       	ldi	r24, 0x98	; 152
    ebe0:	88 16       	cp	r8, r24
    ebe2:	89 e9       	ldi	r24, 0x99	; 153
    ebe4:	98 06       	cpc	r9, r24
    ebe6:	89 e9       	ldi	r24, 0x99	; 153
    ebe8:	a8 06       	cpc	r10, r24
    ebea:	89 e1       	ldi	r24, 0x19	; 25
    ebec:	b8 06       	cpc	r11, r24
    ebee:	48 f0       	brcs	.+18     	; 0xec02 <conv_flt+0x142>
    ebf0:	94 e0       	ldi	r25, 0x04	; 4
    ebf2:	59 2a       	or	r5, r25
    ebf4:	06 c0       	rjmp	.+12     	; 0xec02 <conv_flt+0x142>
    ebf6:	4e 3f       	cpi	r20, 0xFE	; 254
    ebf8:	81 f4       	brne	.+32     	; 0xec1a <conv_flt+0x15a>
    ebfa:	53 fc       	sbrc	r5, 3
    ebfc:	0e c0       	rjmp	.+28     	; 0xec1a <conv_flt+0x15a>
    ebfe:	e8 e0       	ldi	r30, 0x08	; 8
    ec00:	5e 2a       	or	r5, r30
    ec02:	08 94       	sec
    ec04:	e1 08       	sbc	r14, r1
    ec06:	f1 08       	sbc	r15, r1
    ec08:	e1 14       	cp	r14, r1
    ec0a:	f1 04       	cpc	r15, r1
    ec0c:	31 f0       	breq	.+12     	; 0xec1a <conv_flt+0x15a>
    ec0e:	c3 01       	movw	r24, r6
    ec10:	0e 94 67 7a 	call	0xf4ce	; 0xf4ce <fgetc>
    ec14:	ec 01       	movw	r28, r24
    ec16:	97 ff       	sbrs	r25, 7
    ec18:	c2 cf       	rjmp	.-124    	; 0xeb9e <conv_flt+0xde>
    ec1a:	51 fe       	sbrs	r5, 1
    ec1c:	91 c0       	rjmp	.+290    	; 0xed40 <conv_flt+0x280>
    ec1e:	c5 36       	cpi	r28, 0x65	; 101
    ec20:	19 f0       	breq	.+6      	; 0xec28 <conv_flt+0x168>
    ec22:	c5 34       	cpi	r28, 0x45	; 69
    ec24:	09 f0       	breq	.+2      	; 0xec28 <conv_flt+0x168>
    ec26:	46 c0       	rjmp	.+140    	; 0xecb4 <conv_flt+0x1f4>
    ec28:	08 94       	sec
    ec2a:	e1 08       	sbc	r14, r1
    ec2c:	f1 08       	sbc	r15, r1
    ec2e:	e1 14       	cp	r14, r1
    ec30:	f1 04       	cpc	r15, r1
    ec32:	09 f4       	brne	.+2      	; 0xec36 <conv_flt+0x176>
    ec34:	85 c0       	rjmp	.+266    	; 0xed40 <conv_flt+0x280>
    ec36:	c3 01       	movw	r24, r6
    ec38:	0e 94 67 7a 	call	0xf4ce	; 0xf4ce <fgetc>
    ec3c:	ec 01       	movw	r28, r24
    ec3e:	97 fd       	sbrc	r25, 7
    ec40:	7f c0       	rjmp	.+254    	; 0xed40 <conv_flt+0x280>
    ec42:	8b 32       	cpi	r24, 0x2B	; 43
    ec44:	21 f0       	breq	.+8      	; 0xec4e <conv_flt+0x18e>
    ec46:	8d 32       	cpi	r24, 0x2D	; 45
    ec48:	69 f4       	brne	.+26     	; 0xec64 <conv_flt+0x1a4>
    ec4a:	f0 e1       	ldi	r31, 0x10	; 16
    ec4c:	5f 2a       	or	r5, r31
    ec4e:	08 94       	sec
    ec50:	e1 08       	sbc	r14, r1
    ec52:	f1 08       	sbc	r15, r1
    ec54:	e1 14       	cp	r14, r1
    ec56:	f1 04       	cpc	r15, r1
    ec58:	09 f4       	brne	.+2      	; 0xec5c <conv_flt+0x19c>
    ec5a:	72 c0       	rjmp	.+228    	; 0xed40 <conv_flt+0x280>
    ec5c:	c3 01       	movw	r24, r6
    ec5e:	0e 94 67 7a 	call	0xf4ce	; 0xf4ce <fgetc>
    ec62:	ec 01       	movw	r28, r24
    ec64:	ce 01       	movw	r24, r28
    ec66:	c0 97       	sbiw	r24, 0x30	; 48
    ec68:	0a 97       	sbiw	r24, 0x0a	; 10
    ec6a:	08 f0       	brcs	.+2      	; 0xec6e <conv_flt+0x1ae>
    ec6c:	69 c0       	rjmp	.+210    	; 0xed40 <conv_flt+0x280>
    ec6e:	00 e0       	ldi	r16, 0x00	; 0
    ec70:	10 e0       	ldi	r17, 0x00	; 0
    ec72:	b8 01       	movw	r22, r16
    ec74:	88 27       	eor	r24, r24
    ec76:	77 fd       	sbrc	r23, 7
    ec78:	80 95       	com	r24
    ec7a:	98 2f       	mov	r25, r24
    ec7c:	ae 01       	movw	r20, r28
    ec7e:	40 53       	subi	r20, 0x30	; 48
    ec80:	24 2f       	mov	r18, r20
    ec82:	40 e2       	ldi	r20, 0x20	; 32
    ec84:	0e 94 b8 73 	call	0xe770	; 0xe770 <mulacc>
    ec88:	8b 01       	movw	r16, r22
    ec8a:	08 94       	sec
    ec8c:	e1 08       	sbc	r14, r1
    ec8e:	f1 08       	sbc	r15, r1
    ec90:	e1 14       	cp	r14, r1
    ec92:	f1 04       	cpc	r15, r1
    ec94:	39 f0       	breq	.+14     	; 0xeca4 <conv_flt+0x1e4>
    ec96:	c3 01       	movw	r24, r6
    ec98:	0e 94 67 7a 	call	0xf4ce	; 0xf4ce <fgetc>
    ec9c:	ec 01       	movw	r28, r24
    ec9e:	c0 97       	sbiw	r24, 0x30	; 48
    eca0:	0a 97       	sbiw	r24, 0x0a	; 10
    eca2:	38 f3       	brcs	.-50     	; 0xec72 <conv_flt+0x1b2>
    eca4:	b8 01       	movw	r22, r16
    eca6:	54 fe       	sbrs	r5, 4
    eca8:	03 c0       	rjmp	.+6      	; 0xecb0 <conv_flt+0x1f0>
    ecaa:	70 95       	com	r23
    ecac:	61 95       	neg	r22
    ecae:	7f 4f       	sbci	r23, 0xFF	; 255
    ecb0:	c6 0e       	add	r12, r22
    ecb2:	d7 1e       	adc	r13, r23
    ecb4:	ef 28       	or	r14, r15
    ecb6:	31 f0       	breq	.+12     	; 0xecc4 <conv_flt+0x204>
    ecb8:	d7 fd       	sbrc	r29, 7
    ecba:	04 c0       	rjmp	.+8      	; 0xecc4 <conv_flt+0x204>
    ecbc:	ce 01       	movw	r24, r28
    ecbe:	b3 01       	movw	r22, r6
    ecc0:	0e 94 7d 7b 	call	0xf6fa	; 0xf6fa <ungetc>
    ecc4:	c5 01       	movw	r24, r10
    ecc6:	b4 01       	movw	r22, r8
    ecc8:	0e 94 f2 77 	call	0xefe4	; 0xefe4 <__floatunsisf>
    eccc:	d7 fe       	sbrs	r13, 7
    ecce:	0d c0       	rjmp	.+26     	; 0xecea <conv_flt+0x22a>
    ecd0:	a9 ed       	ldi	r26, 0xD9	; 217
    ecd2:	ea 2e       	mov	r14, r26
    ecd4:	a2 e0       	ldi	r26, 0x02	; 2
    ecd6:	fa 2e       	mov	r15, r26
    ecd8:	d0 94       	com	r13
    ecda:	c1 94       	neg	r12
    ecdc:	d1 08       	sbc	r13, r1
    ecde:	d3 94       	inc	r13
    ece0:	c0 e2       	ldi	r28, 0x20	; 32
    ece2:	d0 e0       	ldi	r29, 0x00	; 0
    ece4:	00 e0       	ldi	r16, 0x00	; 0
    ece6:	10 e0       	ldi	r17, 0x00	; 0
    ece8:	0e c0       	rjmp	.+28     	; 0xed06 <conv_flt+0x246>
    ecea:	f1 ef       	ldi	r31, 0xF1	; 241
    ecec:	ef 2e       	mov	r14, r31
    ecee:	f2 e0       	ldi	r31, 0x02	; 2
    ecf0:	ff 2e       	mov	r15, r31
    ecf2:	f6 cf       	rjmp	.-20     	; 0xece0 <conv_flt+0x220>
    ecf4:	f7 01       	movw	r30, r14
    ecf6:	25 91       	lpm	r18, Z+
    ecf8:	35 91       	lpm	r19, Z+
    ecfa:	45 91       	lpm	r20, Z+
    ecfc:	54 91       	lpm	r21, Z+
    ecfe:	0e 94 2f 78 	call	0xf05e	; 0xf05e <__mulsf3>
    ed02:	cc 1a       	sub	r12, r28
    ed04:	dd 0a       	sbc	r13, r29
    ed06:	cc 16       	cp	r12, r28
    ed08:	dd 06       	cpc	r13, r29
    ed0a:	a0 f7       	brcc	.-24     	; 0xecf4 <conv_flt+0x234>
    ed0c:	d6 95       	lsr	r29
    ed0e:	c7 95       	ror	r28
    ed10:	0f 5f       	subi	r16, 0xFF	; 255
    ed12:	1f 4f       	sbci	r17, 0xFF	; 255
    ed14:	06 30       	cpi	r16, 0x06	; 6
    ed16:	11 05       	cpc	r17, r1
    ed18:	29 f0       	breq	.+10     	; 0xed24 <conv_flt+0x264>
    ed1a:	ec ef       	ldi	r30, 0xFC	; 252
    ed1c:	ff ef       	ldi	r31, 0xFF	; 255
    ed1e:	ee 0e       	add	r14, r30
    ed20:	ff 1e       	adc	r15, r31
    ed22:	f1 cf       	rjmp	.-30     	; 0xed06 <conv_flt+0x246>
    ed24:	dc 01       	movw	r26, r24
    ed26:	cb 01       	movw	r24, r22
    ed28:	57 fc       	sbrc	r5, 7
    ed2a:	b0 58       	subi	r27, 0x80	; 128
    ed2c:	21 14       	cp	r2, r1
    ed2e:	31 04       	cpc	r3, r1
    ed30:	29 f0       	breq	.+10     	; 0xed3c <conv_flt+0x27c>
    ed32:	f1 01       	movw	r30, r2
    ed34:	80 83       	st	Z, r24
    ed36:	91 83       	std	Z+1, r25	; 0x01
    ed38:	a2 83       	std	Z+2, r26	; 0x02
    ed3a:	b3 83       	std	Z+3, r27	; 0x03
    ed3c:	81 e0       	ldi	r24, 0x01	; 1
    ed3e:	01 c0       	rjmp	.+2      	; 0xed42 <conv_flt+0x282>
    ed40:	80 e0       	ldi	r24, 0x00	; 0
    ed42:	df 91       	pop	r29
    ed44:	cf 91       	pop	r28
    ed46:	1f 91       	pop	r17
    ed48:	0f 91       	pop	r16
    ed4a:	ff 90       	pop	r15
    ed4c:	ef 90       	pop	r14
    ed4e:	df 90       	pop	r13
    ed50:	cf 90       	pop	r12
    ed52:	bf 90       	pop	r11
    ed54:	af 90       	pop	r10
    ed56:	9f 90       	pop	r9
    ed58:	8f 90       	pop	r8
    ed5a:	7f 90       	pop	r7
    ed5c:	6f 90       	pop	r6
    ed5e:	5f 90       	pop	r5
    ed60:	3f 90       	pop	r3
    ed62:	2f 90       	pop	r2
    ed64:	08 95       	ret

0000ed66 <vfscanf>:
    ed66:	5f 92       	push	r5
    ed68:	6f 92       	push	r6
    ed6a:	7f 92       	push	r7
    ed6c:	8f 92       	push	r8
    ed6e:	9f 92       	push	r9
    ed70:	af 92       	push	r10
    ed72:	bf 92       	push	r11
    ed74:	cf 92       	push	r12
    ed76:	df 92       	push	r13
    ed78:	ef 92       	push	r14
    ed7a:	ff 92       	push	r15
    ed7c:	0f 93       	push	r16
    ed7e:	1f 93       	push	r17
    ed80:	cf 93       	push	r28
    ed82:	df 93       	push	r29
    ed84:	4c 01       	movw	r8, r24
    ed86:	5b 01       	movw	r10, r22
    ed88:	3a 01       	movw	r6, r20
    ed8a:	fc 01       	movw	r30, r24
    ed8c:	17 82       	std	Z+7, r1	; 0x07
    ed8e:	16 82       	std	Z+6, r1	; 0x06
    ed90:	55 24       	eor	r5, r5
    ed92:	04 c1       	rjmp	.+520    	; 0xef9c <vfscanf+0x236>
    ed94:	81 2f       	mov	r24, r17
    ed96:	90 e0       	ldi	r25, 0x00	; 0
    ed98:	0e 94 be 79 	call	0xf37c	; 0xf37c <isspace>
    ed9c:	89 2b       	or	r24, r25
    ed9e:	21 f0       	breq	.+8      	; 0xeda8 <vfscanf+0x42>
    eda0:	c4 01       	movw	r24, r8
    eda2:	0e 94 e6 73 	call	0xe7cc	; 0xe7cc <skip_spaces>
    eda6:	fa c0       	rjmp	.+500    	; 0xef9c <vfscanf+0x236>
    eda8:	15 32       	cpi	r17, 0x25	; 37
    edaa:	49 f4       	brne	.+18     	; 0xedbe <vfscanf+0x58>
    edac:	f5 01       	movw	r30, r10
    edae:	f3 fc       	sbrc	r15, 3
    edb0:	65 91       	lpm	r22, Z+
    edb2:	f3 fe       	sbrs	r15, 3
    edb4:	61 91       	ld	r22, Z+
    edb6:	5f 01       	movw	r10, r30
    edb8:	65 32       	cpi	r22, 0x25	; 37
    edba:	69 f4       	brne	.+26     	; 0xedd6 <vfscanf+0x70>
    edbc:	15 e2       	ldi	r17, 0x25	; 37
    edbe:	c4 01       	movw	r24, r8
    edc0:	0e 94 67 7a 	call	0xf4ce	; 0xf4ce <fgetc>
    edc4:	97 fd       	sbrc	r25, 7
    edc6:	f6 c0       	rjmp	.+492    	; 0xefb4 <vfscanf+0x24e>
    edc8:	18 17       	cp	r17, r24
    edca:	09 f4       	brne	.+2      	; 0xedce <vfscanf+0x68>
    edcc:	e7 c0       	rjmp	.+462    	; 0xef9c <vfscanf+0x236>
    edce:	b4 01       	movw	r22, r8
    edd0:	0e 94 7d 7b 	call	0xf6fa	; 0xf6fa <ungetc>
    edd4:	f4 c0       	rjmp	.+488    	; 0xefbe <vfscanf+0x258>
    edd6:	6a 32       	cpi	r22, 0x2A	; 42
    edd8:	19 f0       	breq	.+6      	; 0xede0 <vfscanf+0x7a>
    edda:	16 2f       	mov	r17, r22
    eddc:	00 e0       	ldi	r16, 0x00	; 0
    edde:	06 c0       	rjmp	.+12     	; 0xedec <vfscanf+0x86>
    ede0:	f3 fc       	sbrc	r15, 3
    ede2:	15 91       	lpm	r17, Z+
    ede4:	f3 fe       	sbrs	r15, 3
    ede6:	11 91       	ld	r17, Z+
    ede8:	5f 01       	movw	r10, r30
    edea:	01 e0       	ldi	r16, 0x01	; 1
    edec:	cc 24       	eor	r12, r12
    edee:	dd 24       	eor	r13, r13
    edf0:	0e c0       	rjmp	.+28     	; 0xee0e <vfscanf+0xa8>
    edf2:	02 60       	ori	r16, 0x02	; 2
    edf4:	b6 01       	movw	r22, r12
    edf6:	80 e0       	ldi	r24, 0x00	; 0
    edf8:	90 e0       	ldi	r25, 0x00	; 0
    edfa:	40 e2       	ldi	r20, 0x20	; 32
    edfc:	0e 94 b8 73 	call	0xe770	; 0xe770 <mulacc>
    ee00:	6b 01       	movw	r12, r22
    ee02:	f5 01       	movw	r30, r10
    ee04:	f3 fc       	sbrc	r15, 3
    ee06:	15 91       	lpm	r17, Z+
    ee08:	f3 fe       	sbrs	r15, 3
    ee0a:	11 91       	ld	r17, Z+
    ee0c:	5f 01       	movw	r10, r30
    ee0e:	21 2f       	mov	r18, r17
    ee10:	20 53       	subi	r18, 0x30	; 48
    ee12:	2a 30       	cpi	r18, 0x0A	; 10
    ee14:	70 f3       	brcs	.-36     	; 0xedf2 <vfscanf+0x8c>
    ee16:	01 fd       	sbrc	r16, 1
    ee18:	04 c0       	rjmp	.+8      	; 0xee22 <vfscanf+0xbc>
    ee1a:	cc 24       	eor	r12, r12
    ee1c:	ca 94       	dec	r12
    ee1e:	dc 2c       	mov	r13, r12
    ee20:	04 c0       	rjmp	.+8      	; 0xee2a <vfscanf+0xc4>
    ee22:	c1 14       	cp	r12, r1
    ee24:	d1 04       	cpc	r13, r1
    ee26:	09 f4       	brne	.+2      	; 0xee2a <vfscanf+0xc4>
    ee28:	ca c0       	rjmp	.+404    	; 0xefbe <vfscanf+0x258>
    ee2a:	18 36       	cpi	r17, 0x68	; 104
    ee2c:	21 f0       	breq	.+8      	; 0xee36 <vfscanf+0xd0>
    ee2e:	1c 36       	cpi	r17, 0x6C	; 108
    ee30:	99 f4       	brne	.+38     	; 0xee58 <vfscanf+0xf2>
    ee32:	f5 01       	movw	r30, r10
    ee34:	0b c0       	rjmp	.+22     	; 0xee4c <vfscanf+0xe6>
    ee36:	f5 01       	movw	r30, r10
    ee38:	f3 fc       	sbrc	r15, 3
    ee3a:	65 91       	lpm	r22, Z+
    ee3c:	f3 fe       	sbrs	r15, 3
    ee3e:	61 91       	ld	r22, Z+
    ee40:	68 36       	cpi	r22, 0x68	; 104
    ee42:	19 f0       	breq	.+6      	; 0xee4a <vfscanf+0xe4>
    ee44:	5f 01       	movw	r10, r30
    ee46:	16 2f       	mov	r17, r22
    ee48:	07 c0       	rjmp	.+14     	; 0xee58 <vfscanf+0xf2>
    ee4a:	08 60       	ori	r16, 0x08	; 8
    ee4c:	04 60       	ori	r16, 0x04	; 4
    ee4e:	f3 fc       	sbrc	r15, 3
    ee50:	15 91       	lpm	r17, Z+
    ee52:	f3 fe       	sbrs	r15, 3
    ee54:	11 91       	ld	r17, Z+
    ee56:	5f 01       	movw	r10, r30
    ee58:	11 23       	and	r17, r17
    ee5a:	09 f4       	brne	.+2      	; 0xee5e <vfscanf+0xf8>
    ee5c:	b0 c0       	rjmp	.+352    	; 0xefbe <vfscanf+0x258>
    ee5e:	88 ea       	ldi	r24, 0xA8	; 168
    ee60:	92 e0       	ldi	r25, 0x02	; 2
    ee62:	61 2f       	mov	r22, r17
    ee64:	70 e0       	ldi	r23, 0x00	; 0
    ee66:	0e 94 ce 79 	call	0xf39c	; 0xf39c <strchr_P>
    ee6a:	89 2b       	or	r24, r25
    ee6c:	09 f4       	brne	.+2      	; 0xee70 <vfscanf+0x10a>
    ee6e:	a7 c0       	rjmp	.+334    	; 0xefbe <vfscanf+0x258>
    ee70:	80 2f       	mov	r24, r16
    ee72:	00 ff       	sbrs	r16, 0
    ee74:	03 c0       	rjmp	.+6      	; 0xee7c <vfscanf+0x116>
    ee76:	ee 24       	eor	r14, r14
    ee78:	ff 24       	eor	r15, r15
    ee7a:	07 c0       	rjmp	.+14     	; 0xee8a <vfscanf+0x124>
    ee7c:	f3 01       	movw	r30, r6
    ee7e:	e0 80       	ld	r14, Z
    ee80:	f1 80       	ldd	r15, Z+1	; 0x01
    ee82:	22 e0       	ldi	r18, 0x02	; 2
    ee84:	30 e0       	ldi	r19, 0x00	; 0
    ee86:	62 0e       	add	r6, r18
    ee88:	73 1e       	adc	r7, r19
    ee8a:	1e 36       	cpi	r17, 0x6E	; 110
    ee8c:	51 f4       	brne	.+20     	; 0xeea2 <vfscanf+0x13c>
    ee8e:	f4 01       	movw	r30, r8
    ee90:	46 81       	ldd	r20, Z+6	; 0x06
    ee92:	57 81       	ldd	r21, Z+7	; 0x07
    ee94:	60 e0       	ldi	r22, 0x00	; 0
    ee96:	70 e0       	ldi	r23, 0x00	; 0
    ee98:	c7 01       	movw	r24, r14
    ee9a:	20 2f       	mov	r18, r16
    ee9c:	0e 94 ac 73 	call	0xe758	; 0xe758 <putval>
    eea0:	7d c0       	rjmp	.+250    	; 0xef9c <vfscanf+0x236>
    eea2:	13 36       	cpi	r17, 0x63	; 99
    eea4:	b9 f4       	brne	.+46     	; 0xeed4 <vfscanf+0x16e>
    eea6:	81 fd       	sbrc	r24, 1
    eea8:	03 c0       	rjmp	.+6      	; 0xeeb0 <vfscanf+0x14a>
    eeaa:	11 e0       	ldi	r17, 0x01	; 1
    eeac:	c1 2e       	mov	r12, r17
    eeae:	d1 2c       	mov	r13, r1
    eeb0:	c4 01       	movw	r24, r8
    eeb2:	0e 94 67 7a 	call	0xf4ce	; 0xf4ce <fgetc>
    eeb6:	97 fd       	sbrc	r25, 7
    eeb8:	7d c0       	rjmp	.+250    	; 0xefb4 <vfscanf+0x24e>
    eeba:	e1 14       	cp	r14, r1
    eebc:	f1 04       	cpc	r15, r1
    eebe:	19 f0       	breq	.+6      	; 0xeec6 <vfscanf+0x160>
    eec0:	f7 01       	movw	r30, r14
    eec2:	81 93       	st	Z+, r24
    eec4:	7f 01       	movw	r14, r30
    eec6:	08 94       	sec
    eec8:	c1 08       	sbc	r12, r1
    eeca:	d1 08       	sbc	r13, r1
    eecc:	c1 14       	cp	r12, r1
    eece:	d1 04       	cpc	r13, r1
    eed0:	79 f7       	brne	.-34     	; 0xeeb0 <vfscanf+0x14a>
    eed2:	62 c0       	rjmp	.+196    	; 0xef98 <vfscanf+0x232>
    eed4:	1b 35       	cpi	r17, 0x5B	; 91
    eed6:	59 f4       	brne	.+22     	; 0xeeee <vfscanf+0x188>
    eed8:	c4 01       	movw	r24, r8
    eeda:	b6 01       	movw	r22, r12
    eedc:	a7 01       	movw	r20, r14
    eede:	95 01       	movw	r18, r10
    eee0:	0e 94 93 74 	call	0xe926	; 0xe926 <conv_brk>
    eee4:	5c 01       	movw	r10, r24
    eee6:	00 97       	sbiw	r24, 0x00	; 0
    eee8:	09 f0       	breq	.+2      	; 0xeeec <vfscanf+0x186>
    eeea:	56 c0       	rjmp	.+172    	; 0xef98 <vfscanf+0x232>
    eeec:	50 c0       	rjmp	.+160    	; 0xef8e <vfscanf+0x228>
    eeee:	c4 01       	movw	r24, r8
    eef0:	0e 94 e6 73 	call	0xe7cc	; 0xe7cc <skip_spaces>
    eef4:	97 fd       	sbrc	r25, 7
    eef6:	5e c0       	rjmp	.+188    	; 0xefb4 <vfscanf+0x24e>
    eef8:	1f 36       	cpi	r17, 0x6F	; 111
    eefa:	d1 f1       	breq	.+116    	; 0xef70 <vfscanf+0x20a>
    eefc:	10 37       	cpi	r17, 0x70	; 112
    eefe:	38 f4       	brcc	.+14     	; 0xef0e <vfscanf+0x1a8>
    ef00:	14 36       	cpi	r17, 0x64	; 100
    ef02:	a1 f1       	breq	.+104    	; 0xef6c <vfscanf+0x206>
    ef04:	19 36       	cpi	r17, 0x69	; 105
    ef06:	a9 f1       	breq	.+106    	; 0xef72 <vfscanf+0x20c>
    ef08:	18 35       	cpi	r17, 0x58	; 88
    ef0a:	d1 f5       	brne	.+116    	; 0xef80 <vfscanf+0x21a>
    ef0c:	2d c0       	rjmp	.+90     	; 0xef68 <vfscanf+0x202>
    ef0e:	13 37       	cpi	r17, 0x73	; 115
    ef10:	51 f0       	breq	.+20     	; 0xef26 <vfscanf+0x1c0>
    ef12:	14 37       	cpi	r17, 0x74	; 116
    ef14:	18 f4       	brcc	.+6      	; 0xef1c <vfscanf+0x1b6>
    ef16:	10 37       	cpi	r17, 0x70	; 112
    ef18:	99 f5       	brne	.+102    	; 0xef80 <vfscanf+0x21a>
    ef1a:	26 c0       	rjmp	.+76     	; 0xef68 <vfscanf+0x202>
    ef1c:	15 37       	cpi	r17, 0x75	; 117
    ef1e:	31 f1       	breq	.+76     	; 0xef6c <vfscanf+0x206>
    ef20:	18 37       	cpi	r17, 0x78	; 120
    ef22:	71 f5       	brne	.+92     	; 0xef80 <vfscanf+0x21a>
    ef24:	21 c0       	rjmp	.+66     	; 0xef68 <vfscanf+0x202>
    ef26:	c4 01       	movw	r24, r8
    ef28:	0e 94 67 7a 	call	0xf4ce	; 0xf4ce <fgetc>
    ef2c:	ec 01       	movw	r28, r24
    ef2e:	97 fd       	sbrc	r25, 7
    ef30:	15 c0       	rjmp	.+42     	; 0xef5c <vfscanf+0x1f6>
    ef32:	0e 94 be 79 	call	0xf37c	; 0xf37c <isspace>
    ef36:	89 2b       	or	r24, r25
    ef38:	29 f0       	breq	.+10     	; 0xef44 <vfscanf+0x1de>
    ef3a:	ce 01       	movw	r24, r28
    ef3c:	b4 01       	movw	r22, r8
    ef3e:	0e 94 7d 7b 	call	0xf6fa	; 0xf6fa <ungetc>
    ef42:	0c c0       	rjmp	.+24     	; 0xef5c <vfscanf+0x1f6>
    ef44:	e1 14       	cp	r14, r1
    ef46:	f1 04       	cpc	r15, r1
    ef48:	19 f0       	breq	.+6      	; 0xef50 <vfscanf+0x1ea>
    ef4a:	f7 01       	movw	r30, r14
    ef4c:	c1 93       	st	Z+, r28
    ef4e:	7f 01       	movw	r14, r30
    ef50:	08 94       	sec
    ef52:	c1 08       	sbc	r12, r1
    ef54:	d1 08       	sbc	r13, r1
    ef56:	c1 14       	cp	r12, r1
    ef58:	d1 04       	cpc	r13, r1
    ef5a:	29 f7       	brne	.-54     	; 0xef26 <vfscanf+0x1c0>
    ef5c:	e1 14       	cp	r14, r1
    ef5e:	f1 04       	cpc	r15, r1
    ef60:	d9 f0       	breq	.+54     	; 0xef98 <vfscanf+0x232>
    ef62:	f7 01       	movw	r30, r14
    ef64:	10 82       	st	Z, r1
    ef66:	18 c0       	rjmp	.+48     	; 0xef98 <vfscanf+0x232>
    ef68:	00 64       	ori	r16, 0x40	; 64
    ef6a:	03 c0       	rjmp	.+6      	; 0xef72 <vfscanf+0x20c>
    ef6c:	00 62       	ori	r16, 0x20	; 32
    ef6e:	01 c0       	rjmp	.+2      	; 0xef72 <vfscanf+0x20c>
    ef70:	00 61       	ori	r16, 0x10	; 16
    ef72:	c4 01       	movw	r24, r8
    ef74:	b6 01       	movw	r22, r12
    ef76:	a7 01       	movw	r20, r14
    ef78:	20 2f       	mov	r18, r16
    ef7a:	0e 94 ff 73 	call	0xe7fe	; 0xe7fe <conv_int>
    ef7e:	05 c0       	rjmp	.+10     	; 0xef8a <vfscanf+0x224>
    ef80:	c4 01       	movw	r24, r8
    ef82:	b6 01       	movw	r22, r12
    ef84:	a7 01       	movw	r20, r14
    ef86:	0e 94 60 75 	call	0xeac0	; 0xeac0 <conv_flt>
    ef8a:	88 23       	and	r24, r24
    ef8c:	29 f4       	brne	.+10     	; 0xef98 <vfscanf+0x232>
    ef8e:	f4 01       	movw	r30, r8
    ef90:	83 81       	ldd	r24, Z+3	; 0x03
    ef92:	80 73       	andi	r24, 0x30	; 48
    ef94:	79 f4       	brne	.+30     	; 0xefb4 <vfscanf+0x24e>
    ef96:	13 c0       	rjmp	.+38     	; 0xefbe <vfscanf+0x258>
    ef98:	00 ff       	sbrs	r16, 0
    ef9a:	53 94       	inc	r5
    ef9c:	f4 01       	movw	r30, r8
    ef9e:	f3 80       	ldd	r15, Z+3	; 0x03
    efa0:	f5 01       	movw	r30, r10
    efa2:	f3 fc       	sbrc	r15, 3
    efa4:	15 91       	lpm	r17, Z+
    efa6:	f3 fe       	sbrs	r15, 3
    efa8:	11 91       	ld	r17, Z+
    efaa:	5f 01       	movw	r10, r30
    efac:	11 23       	and	r17, r17
    efae:	09 f0       	breq	.+2      	; 0xefb2 <vfscanf+0x24c>
    efb0:	f1 ce       	rjmp	.-542    	; 0xed94 <vfscanf+0x2e>
    efb2:	05 c0       	rjmp	.+10     	; 0xefbe <vfscanf+0x258>
    efb4:	55 20       	and	r5, r5
    efb6:	19 f4       	brne	.+6      	; 0xefbe <vfscanf+0x258>
    efb8:	2f ef       	ldi	r18, 0xFF	; 255
    efba:	3f ef       	ldi	r19, 0xFF	; 255
    efbc:	02 c0       	rjmp	.+4      	; 0xefc2 <vfscanf+0x25c>
    efbe:	25 2d       	mov	r18, r5
    efc0:	30 e0       	ldi	r19, 0x00	; 0
    efc2:	c9 01       	movw	r24, r18
    efc4:	df 91       	pop	r29
    efc6:	cf 91       	pop	r28
    efc8:	1f 91       	pop	r17
    efca:	0f 91       	pop	r16
    efcc:	ff 90       	pop	r15
    efce:	ef 90       	pop	r14
    efd0:	df 90       	pop	r13
    efd2:	cf 90       	pop	r12
    efd4:	bf 90       	pop	r11
    efd6:	af 90       	pop	r10
    efd8:	9f 90       	pop	r9
    efda:	8f 90       	pop	r8
    efdc:	7f 90       	pop	r7
    efde:	6f 90       	pop	r6
    efe0:	5f 90       	pop	r5
    efe2:	08 95       	ret

0000efe4 <__floatunsisf>:
    efe4:	e8 94       	clt
    efe6:	09 c0       	rjmp	.+18     	; 0xeffa <__floatsisf+0x12>

0000efe8 <__floatsisf>:
    efe8:	97 fb       	bst	r25, 7
    efea:	3e f4       	brtc	.+14     	; 0xeffa <__floatsisf+0x12>
    efec:	90 95       	com	r25
    efee:	80 95       	com	r24
    eff0:	70 95       	com	r23
    eff2:	61 95       	neg	r22
    eff4:	7f 4f       	sbci	r23, 0xFF	; 255
    eff6:	8f 4f       	sbci	r24, 0xFF	; 255
    eff8:	9f 4f       	sbci	r25, 0xFF	; 255
    effa:	99 23       	and	r25, r25
    effc:	a9 f0       	breq	.+42     	; 0xf028 <__floatsisf+0x40>
    effe:	f9 2f       	mov	r31, r25
    f000:	96 e9       	ldi	r25, 0x96	; 150
    f002:	bb 27       	eor	r27, r27
    f004:	93 95       	inc	r25
    f006:	f6 95       	lsr	r31
    f008:	87 95       	ror	r24
    f00a:	77 95       	ror	r23
    f00c:	67 95       	ror	r22
    f00e:	b7 95       	ror	r27
    f010:	f1 11       	cpse	r31, r1
    f012:	f8 cf       	rjmp	.-16     	; 0xf004 <__floatsisf+0x1c>
    f014:	fa f4       	brpl	.+62     	; 0xf054 <__floatsisf+0x6c>
    f016:	bb 0f       	add	r27, r27
    f018:	11 f4       	brne	.+4      	; 0xf01e <__floatsisf+0x36>
    f01a:	60 ff       	sbrs	r22, 0
    f01c:	1b c0       	rjmp	.+54     	; 0xf054 <__floatsisf+0x6c>
    f01e:	6f 5f       	subi	r22, 0xFF	; 255
    f020:	7f 4f       	sbci	r23, 0xFF	; 255
    f022:	8f 4f       	sbci	r24, 0xFF	; 255
    f024:	9f 4f       	sbci	r25, 0xFF	; 255
    f026:	16 c0       	rjmp	.+44     	; 0xf054 <__floatsisf+0x6c>
    f028:	88 23       	and	r24, r24
    f02a:	11 f0       	breq	.+4      	; 0xf030 <__floatsisf+0x48>
    f02c:	96 e9       	ldi	r25, 0x96	; 150
    f02e:	11 c0       	rjmp	.+34     	; 0xf052 <__floatsisf+0x6a>
    f030:	77 23       	and	r23, r23
    f032:	21 f0       	breq	.+8      	; 0xf03c <__floatsisf+0x54>
    f034:	9e e8       	ldi	r25, 0x8E	; 142
    f036:	87 2f       	mov	r24, r23
    f038:	76 2f       	mov	r23, r22
    f03a:	05 c0       	rjmp	.+10     	; 0xf046 <__floatsisf+0x5e>
    f03c:	66 23       	and	r22, r22
    f03e:	71 f0       	breq	.+28     	; 0xf05c <__floatsisf+0x74>
    f040:	96 e8       	ldi	r25, 0x86	; 134
    f042:	86 2f       	mov	r24, r22
    f044:	70 e0       	ldi	r23, 0x00	; 0
    f046:	60 e0       	ldi	r22, 0x00	; 0
    f048:	2a f0       	brmi	.+10     	; 0xf054 <__floatsisf+0x6c>
    f04a:	9a 95       	dec	r25
    f04c:	66 0f       	add	r22, r22
    f04e:	77 1f       	adc	r23, r23
    f050:	88 1f       	adc	r24, r24
    f052:	da f7       	brpl	.-10     	; 0xf04a <__floatsisf+0x62>
    f054:	88 0f       	add	r24, r24
    f056:	96 95       	lsr	r25
    f058:	87 95       	ror	r24
    f05a:	97 f9       	bld	r25, 7
    f05c:	08 95       	ret

0000f05e <__mulsf3>:
    f05e:	0b d0       	rcall	.+22     	; 0xf076 <__mulsf3x>
    f060:	78 c0       	rjmp	.+240    	; 0xf152 <__fp_round>
    f062:	69 d0       	rcall	.+210    	; 0xf136 <__fp_pscA>
    f064:	28 f0       	brcs	.+10     	; 0xf070 <__mulsf3+0x12>
    f066:	6e d0       	rcall	.+220    	; 0xf144 <__fp_pscB>
    f068:	18 f0       	brcs	.+6      	; 0xf070 <__mulsf3+0x12>
    f06a:	95 23       	and	r25, r21
    f06c:	09 f0       	breq	.+2      	; 0xf070 <__mulsf3+0x12>
    f06e:	5a c0       	rjmp	.+180    	; 0xf124 <__fp_inf>
    f070:	5f c0       	rjmp	.+190    	; 0xf130 <__fp_nan>
    f072:	11 24       	eor	r1, r1
    f074:	a2 c0       	rjmp	.+324    	; 0xf1ba <__fp_szero>

0000f076 <__mulsf3x>:
    f076:	7e d0       	rcall	.+252    	; 0xf174 <__fp_split3>
    f078:	a0 f3       	brcs	.-24     	; 0xf062 <__mulsf3+0x4>

0000f07a <__mulsf3_pse>:
    f07a:	95 9f       	mul	r25, r21
    f07c:	d1 f3       	breq	.-12     	; 0xf072 <__mulsf3+0x14>
    f07e:	95 0f       	add	r25, r21
    f080:	50 e0       	ldi	r21, 0x00	; 0
    f082:	55 1f       	adc	r21, r21
    f084:	62 9f       	mul	r22, r18
    f086:	f0 01       	movw	r30, r0
    f088:	72 9f       	mul	r23, r18
    f08a:	bb 27       	eor	r27, r27
    f08c:	f0 0d       	add	r31, r0
    f08e:	b1 1d       	adc	r27, r1
    f090:	63 9f       	mul	r22, r19
    f092:	aa 27       	eor	r26, r26
    f094:	f0 0d       	add	r31, r0
    f096:	b1 1d       	adc	r27, r1
    f098:	aa 1f       	adc	r26, r26
    f09a:	64 9f       	mul	r22, r20
    f09c:	66 27       	eor	r22, r22
    f09e:	b0 0d       	add	r27, r0
    f0a0:	a1 1d       	adc	r26, r1
    f0a2:	66 1f       	adc	r22, r22
    f0a4:	82 9f       	mul	r24, r18
    f0a6:	22 27       	eor	r18, r18
    f0a8:	b0 0d       	add	r27, r0
    f0aa:	a1 1d       	adc	r26, r1
    f0ac:	62 1f       	adc	r22, r18
    f0ae:	73 9f       	mul	r23, r19
    f0b0:	b0 0d       	add	r27, r0
    f0b2:	a1 1d       	adc	r26, r1
    f0b4:	62 1f       	adc	r22, r18
    f0b6:	83 9f       	mul	r24, r19
    f0b8:	a0 0d       	add	r26, r0
    f0ba:	61 1d       	adc	r22, r1
    f0bc:	22 1f       	adc	r18, r18
    f0be:	74 9f       	mul	r23, r20
    f0c0:	33 27       	eor	r19, r19
    f0c2:	a0 0d       	add	r26, r0
    f0c4:	61 1d       	adc	r22, r1
    f0c6:	23 1f       	adc	r18, r19
    f0c8:	84 9f       	mul	r24, r20
    f0ca:	60 0d       	add	r22, r0
    f0cc:	21 1d       	adc	r18, r1
    f0ce:	82 2f       	mov	r24, r18
    f0d0:	76 2f       	mov	r23, r22
    f0d2:	6a 2f       	mov	r22, r26
    f0d4:	11 24       	eor	r1, r1
    f0d6:	9f 57       	subi	r25, 0x7F	; 127
    f0d8:	50 40       	sbci	r21, 0x00	; 0
    f0da:	8a f0       	brmi	.+34     	; 0xf0fe <__mulsf3_pse+0x84>
    f0dc:	e1 f0       	breq	.+56     	; 0xf116 <__mulsf3_pse+0x9c>
    f0de:	88 23       	and	r24, r24
    f0e0:	4a f0       	brmi	.+18     	; 0xf0f4 <__mulsf3_pse+0x7a>
    f0e2:	ee 0f       	add	r30, r30
    f0e4:	ff 1f       	adc	r31, r31
    f0e6:	bb 1f       	adc	r27, r27
    f0e8:	66 1f       	adc	r22, r22
    f0ea:	77 1f       	adc	r23, r23
    f0ec:	88 1f       	adc	r24, r24
    f0ee:	91 50       	subi	r25, 0x01	; 1
    f0f0:	50 40       	sbci	r21, 0x00	; 0
    f0f2:	a9 f7       	brne	.-22     	; 0xf0de <__mulsf3_pse+0x64>
    f0f4:	9e 3f       	cpi	r25, 0xFE	; 254
    f0f6:	51 05       	cpc	r21, r1
    f0f8:	70 f0       	brcs	.+28     	; 0xf116 <__mulsf3_pse+0x9c>
    f0fa:	14 c0       	rjmp	.+40     	; 0xf124 <__fp_inf>
    f0fc:	5e c0       	rjmp	.+188    	; 0xf1ba <__fp_szero>
    f0fe:	5f 3f       	cpi	r21, 0xFF	; 255
    f100:	ec f3       	brlt	.-6      	; 0xf0fc <__mulsf3_pse+0x82>
    f102:	98 3e       	cpi	r25, 0xE8	; 232
    f104:	dc f3       	brlt	.-10     	; 0xf0fc <__mulsf3_pse+0x82>
    f106:	86 95       	lsr	r24
    f108:	77 95       	ror	r23
    f10a:	67 95       	ror	r22
    f10c:	b7 95       	ror	r27
    f10e:	f7 95       	ror	r31
    f110:	e7 95       	ror	r30
    f112:	9f 5f       	subi	r25, 0xFF	; 255
    f114:	c1 f7       	brne	.-16     	; 0xf106 <__mulsf3_pse+0x8c>
    f116:	fe 2b       	or	r31, r30
    f118:	88 0f       	add	r24, r24
    f11a:	91 1d       	adc	r25, r1
    f11c:	96 95       	lsr	r25
    f11e:	87 95       	ror	r24
    f120:	97 f9       	bld	r25, 7
    f122:	08 95       	ret

0000f124 <__fp_inf>:
    f124:	97 f9       	bld	r25, 7
    f126:	9f 67       	ori	r25, 0x7F	; 127
    f128:	80 e8       	ldi	r24, 0x80	; 128
    f12a:	70 e0       	ldi	r23, 0x00	; 0
    f12c:	60 e0       	ldi	r22, 0x00	; 0
    f12e:	08 95       	ret

0000f130 <__fp_nan>:
    f130:	9f ef       	ldi	r25, 0xFF	; 255
    f132:	80 ec       	ldi	r24, 0xC0	; 192
    f134:	08 95       	ret

0000f136 <__fp_pscA>:
    f136:	00 24       	eor	r0, r0
    f138:	0a 94       	dec	r0
    f13a:	16 16       	cp	r1, r22
    f13c:	17 06       	cpc	r1, r23
    f13e:	18 06       	cpc	r1, r24
    f140:	09 06       	cpc	r0, r25
    f142:	08 95       	ret

0000f144 <__fp_pscB>:
    f144:	00 24       	eor	r0, r0
    f146:	0a 94       	dec	r0
    f148:	12 16       	cp	r1, r18
    f14a:	13 06       	cpc	r1, r19
    f14c:	14 06       	cpc	r1, r20
    f14e:	05 06       	cpc	r0, r21
    f150:	08 95       	ret

0000f152 <__fp_round>:
    f152:	09 2e       	mov	r0, r25
    f154:	03 94       	inc	r0
    f156:	00 0c       	add	r0, r0
    f158:	11 f4       	brne	.+4      	; 0xf15e <__fp_round+0xc>
    f15a:	88 23       	and	r24, r24
    f15c:	52 f0       	brmi	.+20     	; 0xf172 <__fp_round+0x20>
    f15e:	bb 0f       	add	r27, r27
    f160:	40 f4       	brcc	.+16     	; 0xf172 <__fp_round+0x20>
    f162:	bf 2b       	or	r27, r31
    f164:	11 f4       	brne	.+4      	; 0xf16a <__fp_round+0x18>
    f166:	60 ff       	sbrs	r22, 0
    f168:	04 c0       	rjmp	.+8      	; 0xf172 <__fp_round+0x20>
    f16a:	6f 5f       	subi	r22, 0xFF	; 255
    f16c:	7f 4f       	sbci	r23, 0xFF	; 255
    f16e:	8f 4f       	sbci	r24, 0xFF	; 255
    f170:	9f 4f       	sbci	r25, 0xFF	; 255
    f172:	08 95       	ret

0000f174 <__fp_split3>:
    f174:	57 fd       	sbrc	r21, 7
    f176:	90 58       	subi	r25, 0x80	; 128
    f178:	44 0f       	add	r20, r20
    f17a:	55 1f       	adc	r21, r21
    f17c:	59 f0       	breq	.+22     	; 0xf194 <__fp_splitA+0x10>
    f17e:	5f 3f       	cpi	r21, 0xFF	; 255
    f180:	71 f0       	breq	.+28     	; 0xf19e <__fp_splitA+0x1a>
    f182:	47 95       	ror	r20

0000f184 <__fp_splitA>:
    f184:	88 0f       	add	r24, r24
    f186:	97 fb       	bst	r25, 7
    f188:	99 1f       	adc	r25, r25
    f18a:	61 f0       	breq	.+24     	; 0xf1a4 <__fp_splitA+0x20>
    f18c:	9f 3f       	cpi	r25, 0xFF	; 255
    f18e:	79 f0       	breq	.+30     	; 0xf1ae <__fp_splitA+0x2a>
    f190:	87 95       	ror	r24
    f192:	08 95       	ret
    f194:	12 16       	cp	r1, r18
    f196:	13 06       	cpc	r1, r19
    f198:	14 06       	cpc	r1, r20
    f19a:	55 1f       	adc	r21, r21
    f19c:	f2 cf       	rjmp	.-28     	; 0xf182 <__fp_split3+0xe>
    f19e:	46 95       	lsr	r20
    f1a0:	f1 df       	rcall	.-30     	; 0xf184 <__fp_splitA>
    f1a2:	08 c0       	rjmp	.+16     	; 0xf1b4 <__fp_splitA+0x30>
    f1a4:	16 16       	cp	r1, r22
    f1a6:	17 06       	cpc	r1, r23
    f1a8:	18 06       	cpc	r1, r24
    f1aa:	99 1f       	adc	r25, r25
    f1ac:	f1 cf       	rjmp	.-30     	; 0xf190 <__fp_splitA+0xc>
    f1ae:	86 95       	lsr	r24
    f1b0:	71 05       	cpc	r23, r1
    f1b2:	61 05       	cpc	r22, r1
    f1b4:	08 94       	sec
    f1b6:	08 95       	ret

0000f1b8 <__fp_zero>:
    f1b8:	e8 94       	clt

0000f1ba <__fp_szero>:
    f1ba:	bb 27       	eor	r27, r27
    f1bc:	66 27       	eor	r22, r22
    f1be:	77 27       	eor	r23, r23
    f1c0:	cb 01       	movw	r24, r22
    f1c2:	97 f9       	bld	r25, 7
    f1c4:	08 95       	ret

0000f1c6 <exit>:
    f1c6:	f8 94       	cli
    f1c8:	0c 94 ce 7d 	jmp	0xfb9c	; 0xfb9c <_exit>

0000f1cc <__ftoa_engine>:
    f1cc:	28 30       	cpi	r18, 0x08	; 8
    f1ce:	08 f0       	brcs	.+2      	; 0xf1d2 <__ftoa_engine+0x6>
    f1d0:	27 e0       	ldi	r18, 0x07	; 7
    f1d2:	33 27       	eor	r19, r19
    f1d4:	da 01       	movw	r26, r20
    f1d6:	99 0f       	add	r25, r25
    f1d8:	31 1d       	adc	r19, r1
    f1da:	87 fd       	sbrc	r24, 7
    f1dc:	91 60       	ori	r25, 0x01	; 1
    f1de:	00 96       	adiw	r24, 0x00	; 0
    f1e0:	61 05       	cpc	r22, r1
    f1e2:	71 05       	cpc	r23, r1
    f1e4:	39 f4       	brne	.+14     	; 0xf1f4 <__ftoa_engine+0x28>
    f1e6:	32 60       	ori	r19, 0x02	; 2
    f1e8:	2e 5f       	subi	r18, 0xFE	; 254
    f1ea:	3d 93       	st	X+, r19
    f1ec:	30 e3       	ldi	r19, 0x30	; 48
    f1ee:	2a 95       	dec	r18
    f1f0:	e1 f7       	brne	.-8      	; 0xf1ea <__ftoa_engine+0x1e>
    f1f2:	08 95       	ret
    f1f4:	9f 3f       	cpi	r25, 0xFF	; 255
    f1f6:	30 f0       	brcs	.+12     	; 0xf204 <__ftoa_engine+0x38>
    f1f8:	80 38       	cpi	r24, 0x80	; 128
    f1fa:	71 05       	cpc	r23, r1
    f1fc:	61 05       	cpc	r22, r1
    f1fe:	09 f0       	breq	.+2      	; 0xf202 <__ftoa_engine+0x36>
    f200:	3c 5f       	subi	r19, 0xFC	; 252
    f202:	3c 5f       	subi	r19, 0xFC	; 252
    f204:	3d 93       	st	X+, r19
    f206:	91 30       	cpi	r25, 0x01	; 1
    f208:	08 f0       	brcs	.+2      	; 0xf20c <__ftoa_engine+0x40>
    f20a:	80 68       	ori	r24, 0x80	; 128
    f20c:	91 1d       	adc	r25, r1
    f20e:	df 93       	push	r29
    f210:	cf 93       	push	r28
    f212:	1f 93       	push	r17
    f214:	0f 93       	push	r16
    f216:	ff 92       	push	r15
    f218:	ef 92       	push	r14
    f21a:	19 2f       	mov	r17, r25
    f21c:	98 7f       	andi	r25, 0xF8	; 248
    f21e:	96 95       	lsr	r25
    f220:	e9 2f       	mov	r30, r25
    f222:	96 95       	lsr	r25
    f224:	96 95       	lsr	r25
    f226:	e9 0f       	add	r30, r25
    f228:	ff 27       	eor	r31, r31
    f22a:	e2 55       	subi	r30, 0x52	; 82
    f22c:	f0 4d       	sbci	r31, 0xD0	; 208
    f22e:	99 27       	eor	r25, r25
    f230:	33 27       	eor	r19, r19
    f232:	ee 24       	eor	r14, r14
    f234:	ff 24       	eor	r15, r15
    f236:	a7 01       	movw	r20, r14
    f238:	e7 01       	movw	r28, r14
    f23a:	05 90       	lpm	r0, Z+
    f23c:	08 94       	sec
    f23e:	07 94       	ror	r0
    f240:	28 f4       	brcc	.+10     	; 0xf24c <__ftoa_engine+0x80>
    f242:	36 0f       	add	r19, r22
    f244:	e7 1e       	adc	r14, r23
    f246:	f8 1e       	adc	r15, r24
    f248:	49 1f       	adc	r20, r25
    f24a:	51 1d       	adc	r21, r1
    f24c:	66 0f       	add	r22, r22
    f24e:	77 1f       	adc	r23, r23
    f250:	88 1f       	adc	r24, r24
    f252:	99 1f       	adc	r25, r25
    f254:	06 94       	lsr	r0
    f256:	a1 f7       	brne	.-24     	; 0xf240 <__ftoa_engine+0x74>
    f258:	05 90       	lpm	r0, Z+
    f25a:	07 94       	ror	r0
    f25c:	28 f4       	brcc	.+10     	; 0xf268 <__ftoa_engine+0x9c>
    f25e:	e7 0e       	add	r14, r23
    f260:	f8 1e       	adc	r15, r24
    f262:	49 1f       	adc	r20, r25
    f264:	56 1f       	adc	r21, r22
    f266:	c1 1d       	adc	r28, r1
    f268:	77 0f       	add	r23, r23
    f26a:	88 1f       	adc	r24, r24
    f26c:	99 1f       	adc	r25, r25
    f26e:	66 1f       	adc	r22, r22
    f270:	06 94       	lsr	r0
    f272:	a1 f7       	brne	.-24     	; 0xf25c <__ftoa_engine+0x90>
    f274:	05 90       	lpm	r0, Z+
    f276:	07 94       	ror	r0
    f278:	28 f4       	brcc	.+10     	; 0xf284 <__ftoa_engine+0xb8>
    f27a:	f8 0e       	add	r15, r24
    f27c:	49 1f       	adc	r20, r25
    f27e:	56 1f       	adc	r21, r22
    f280:	c7 1f       	adc	r28, r23
    f282:	d1 1d       	adc	r29, r1
    f284:	88 0f       	add	r24, r24
    f286:	99 1f       	adc	r25, r25
    f288:	66 1f       	adc	r22, r22
    f28a:	77 1f       	adc	r23, r23
    f28c:	06 94       	lsr	r0
    f28e:	a1 f7       	brne	.-24     	; 0xf278 <__ftoa_engine+0xac>
    f290:	05 90       	lpm	r0, Z+
    f292:	07 94       	ror	r0
    f294:	20 f4       	brcc	.+8      	; 0xf29e <__ftoa_engine+0xd2>
    f296:	49 0f       	add	r20, r25
    f298:	56 1f       	adc	r21, r22
    f29a:	c7 1f       	adc	r28, r23
    f29c:	d8 1f       	adc	r29, r24
    f29e:	99 0f       	add	r25, r25
    f2a0:	66 1f       	adc	r22, r22
    f2a2:	77 1f       	adc	r23, r23
    f2a4:	88 1f       	adc	r24, r24
    f2a6:	06 94       	lsr	r0
    f2a8:	a9 f7       	brne	.-22     	; 0xf294 <__ftoa_engine+0xc8>
    f2aa:	84 91       	lpm	r24, Z+
    f2ac:	10 95       	com	r17
    f2ae:	17 70       	andi	r17, 0x07	; 7
    f2b0:	41 f0       	breq	.+16     	; 0xf2c2 <__ftoa_engine+0xf6>
    f2b2:	d6 95       	lsr	r29
    f2b4:	c7 95       	ror	r28
    f2b6:	57 95       	ror	r21
    f2b8:	47 95       	ror	r20
    f2ba:	f7 94       	ror	r15
    f2bc:	e7 94       	ror	r14
    f2be:	1a 95       	dec	r17
    f2c0:	c1 f7       	brne	.-16     	; 0xf2b2 <__ftoa_engine+0xe6>
    f2c2:	e4 e5       	ldi	r30, 0x54	; 84
    f2c4:	ff e2       	ldi	r31, 0x2F	; 47
    f2c6:	68 94       	set
    f2c8:	15 90       	lpm	r1, Z+
    f2ca:	15 91       	lpm	r17, Z+
    f2cc:	35 91       	lpm	r19, Z+
    f2ce:	65 91       	lpm	r22, Z+
    f2d0:	95 91       	lpm	r25, Z+
    f2d2:	05 90       	lpm	r0, Z+
    f2d4:	7f e2       	ldi	r23, 0x2F	; 47
    f2d6:	73 95       	inc	r23
    f2d8:	e1 18       	sub	r14, r1
    f2da:	f1 0a       	sbc	r15, r17
    f2dc:	43 0b       	sbc	r20, r19
    f2de:	56 0b       	sbc	r21, r22
    f2e0:	c9 0b       	sbc	r28, r25
    f2e2:	d0 09       	sbc	r29, r0
    f2e4:	c0 f7       	brcc	.-16     	; 0xf2d6 <__ftoa_engine+0x10a>
    f2e6:	e1 0c       	add	r14, r1
    f2e8:	f1 1e       	adc	r15, r17
    f2ea:	43 1f       	adc	r20, r19
    f2ec:	56 1f       	adc	r21, r22
    f2ee:	c9 1f       	adc	r28, r25
    f2f0:	d0 1d       	adc	r29, r0
    f2f2:	7e f4       	brtc	.+30     	; 0xf312 <__ftoa_engine+0x146>
    f2f4:	70 33       	cpi	r23, 0x30	; 48
    f2f6:	11 f4       	brne	.+4      	; 0xf2fc <__ftoa_engine+0x130>
    f2f8:	8a 95       	dec	r24
    f2fa:	e6 cf       	rjmp	.-52     	; 0xf2c8 <__ftoa_engine+0xfc>
    f2fc:	e8 94       	clt
    f2fe:	01 50       	subi	r16, 0x01	; 1
    f300:	30 f0       	brcs	.+12     	; 0xf30e <__ftoa_engine+0x142>
    f302:	08 0f       	add	r16, r24
    f304:	0a f4       	brpl	.+2      	; 0xf308 <__ftoa_engine+0x13c>
    f306:	00 27       	eor	r16, r16
    f308:	02 17       	cp	r16, r18
    f30a:	08 f4       	brcc	.+2      	; 0xf30e <__ftoa_engine+0x142>
    f30c:	20 2f       	mov	r18, r16
    f30e:	23 95       	inc	r18
    f310:	02 2f       	mov	r16, r18
    f312:	7a 33       	cpi	r23, 0x3A	; 58
    f314:	28 f0       	brcs	.+10     	; 0xf320 <__ftoa_engine+0x154>
    f316:	79 e3       	ldi	r23, 0x39	; 57
    f318:	7d 93       	st	X+, r23
    f31a:	2a 95       	dec	r18
    f31c:	e9 f7       	brne	.-6      	; 0xf318 <__ftoa_engine+0x14c>
    f31e:	10 c0       	rjmp	.+32     	; 0xf340 <__ftoa_engine+0x174>
    f320:	7d 93       	st	X+, r23
    f322:	2a 95       	dec	r18
    f324:	89 f6       	brne	.-94     	; 0xf2c8 <__ftoa_engine+0xfc>
    f326:	06 94       	lsr	r0
    f328:	97 95       	ror	r25
    f32a:	67 95       	ror	r22
    f32c:	37 95       	ror	r19
    f32e:	17 95       	ror	r17
    f330:	17 94       	ror	r1
    f332:	e1 18       	sub	r14, r1
    f334:	f1 0a       	sbc	r15, r17
    f336:	43 0b       	sbc	r20, r19
    f338:	56 0b       	sbc	r21, r22
    f33a:	c9 0b       	sbc	r28, r25
    f33c:	d0 09       	sbc	r29, r0
    f33e:	98 f0       	brcs	.+38     	; 0xf366 <__ftoa_engine+0x19a>
    f340:	23 95       	inc	r18
    f342:	7e 91       	ld	r23, -X
    f344:	73 95       	inc	r23
    f346:	7a 33       	cpi	r23, 0x3A	; 58
    f348:	08 f0       	brcs	.+2      	; 0xf34c <__ftoa_engine+0x180>
    f34a:	70 e3       	ldi	r23, 0x30	; 48
    f34c:	7c 93       	st	X, r23
    f34e:	20 13       	cpse	r18, r16
    f350:	b8 f7       	brcc	.-18     	; 0xf340 <__ftoa_engine+0x174>
    f352:	7e 91       	ld	r23, -X
    f354:	70 61       	ori	r23, 0x10	; 16
    f356:	7d 93       	st	X+, r23
    f358:	30 f0       	brcs	.+12     	; 0xf366 <__ftoa_engine+0x19a>
    f35a:	83 95       	inc	r24
    f35c:	71 e3       	ldi	r23, 0x31	; 49
    f35e:	7d 93       	st	X+, r23
    f360:	70 e3       	ldi	r23, 0x30	; 48
    f362:	2a 95       	dec	r18
    f364:	e1 f7       	brne	.-8      	; 0xf35e <__ftoa_engine+0x192>
    f366:	11 24       	eor	r1, r1
    f368:	ef 90       	pop	r14
    f36a:	ff 90       	pop	r15
    f36c:	0f 91       	pop	r16
    f36e:	1f 91       	pop	r17
    f370:	cf 91       	pop	r28
    f372:	df 91       	pop	r29
    f374:	99 27       	eor	r25, r25
    f376:	87 fd       	sbrc	r24, 7
    f378:	90 95       	com	r25
    f37a:	08 95       	ret

0000f37c <isspace>:
    f37c:	91 11       	cpse	r25, r1
    f37e:	7c c3       	rjmp	.+1784   	; 0xfa78 <__ctype_isfalse>
    f380:	80 32       	cpi	r24, 0x20	; 32
    f382:	19 f0       	breq	.+6      	; 0xf38a <isspace+0xe>
    f384:	89 50       	subi	r24, 0x09	; 9
    f386:	85 50       	subi	r24, 0x05	; 5
    f388:	d0 f7       	brcc	.-12     	; 0xf37e <isspace+0x2>
    f38a:	08 95       	ret

0000f38c <tolower>:
    f38c:	91 11       	cpse	r25, r1
    f38e:	08 95       	ret
    f390:	81 54       	subi	r24, 0x41	; 65
    f392:	8a 51       	subi	r24, 0x1A	; 26
    f394:	08 f4       	brcc	.+2      	; 0xf398 <tolower+0xc>
    f396:	80 5e       	subi	r24, 0xE0	; 224
    f398:	85 5a       	subi	r24, 0xA5	; 165
    f39a:	08 95       	ret

0000f39c <strchr_P>:
    f39c:	fc 01       	movw	r30, r24
    f39e:	05 90       	lpm	r0, Z+
    f3a0:	06 16       	cp	r0, r22
    f3a2:	21 f0       	breq	.+8      	; 0xf3ac <strchr_P+0x10>
    f3a4:	00 20       	and	r0, r0
    f3a6:	d9 f7       	brne	.-10     	; 0xf39e <strchr_P+0x2>
    f3a8:	c0 01       	movw	r24, r0
    f3aa:	08 95       	ret
    f3ac:	31 97       	sbiw	r30, 0x01	; 1
    f3ae:	cf 01       	movw	r24, r30
    f3b0:	08 95       	ret

0000f3b2 <strcmp_P>:
    f3b2:	fb 01       	movw	r30, r22
    f3b4:	dc 01       	movw	r26, r24
    f3b6:	8d 91       	ld	r24, X+
    f3b8:	05 90       	lpm	r0, Z+
    f3ba:	80 19       	sub	r24, r0
    f3bc:	01 10       	cpse	r0, r1
    f3be:	d9 f3       	breq	.-10     	; 0xf3b6 <strcmp_P+0x4>
    f3c0:	99 0b       	sbc	r25, r25
    f3c2:	08 95       	ret

0000f3c4 <strcpy_P>:
    f3c4:	fb 01       	movw	r30, r22
    f3c6:	dc 01       	movw	r26, r24
    f3c8:	05 90       	lpm	r0, Z+
    f3ca:	0d 92       	st	X+, r0
    f3cc:	00 20       	and	r0, r0
    f3ce:	e1 f7       	brne	.-8      	; 0xf3c8 <strcpy_P+0x4>
    f3d0:	08 95       	ret

0000f3d2 <strlen_P>:
    f3d2:	fc 01       	movw	r30, r24
    f3d4:	05 90       	lpm	r0, Z+
    f3d6:	00 20       	and	r0, r0
    f3d8:	e9 f7       	brne	.-6      	; 0xf3d4 <strlen_P+0x2>
    f3da:	80 95       	com	r24
    f3dc:	90 95       	com	r25
    f3de:	8e 0f       	add	r24, r30
    f3e0:	9f 1f       	adc	r25, r31
    f3e2:	08 95       	ret

0000f3e4 <strncmp_P>:
    f3e4:	fb 01       	movw	r30, r22
    f3e6:	dc 01       	movw	r26, r24
    f3e8:	41 50       	subi	r20, 0x01	; 1
    f3ea:	50 40       	sbci	r21, 0x00	; 0
    f3ec:	30 f0       	brcs	.+12     	; 0xf3fa <strncmp_P+0x16>
    f3ee:	8d 91       	ld	r24, X+
    f3f0:	05 90       	lpm	r0, Z+
    f3f2:	80 19       	sub	r24, r0
    f3f4:	19 f4       	brne	.+6      	; 0xf3fc <strncmp_P+0x18>
    f3f6:	00 20       	and	r0, r0
    f3f8:	b9 f7       	brne	.-18     	; 0xf3e8 <strncmp_P+0x4>
    f3fa:	88 1b       	sub	r24, r24
    f3fc:	99 0b       	sbc	r25, r25
    f3fe:	08 95       	ret

0000f400 <strnlen_P>:
    f400:	fc 01       	movw	r30, r24
    f402:	05 90       	lpm	r0, Z+
    f404:	61 50       	subi	r22, 0x01	; 1
    f406:	70 40       	sbci	r23, 0x00	; 0
    f408:	01 10       	cpse	r0, r1
    f40a:	d8 f7       	brcc	.-10     	; 0xf402 <strnlen_P+0x2>
    f40c:	80 95       	com	r24
    f40e:	90 95       	com	r25
    f410:	8e 0f       	add	r24, r30
    f412:	9f 1f       	adc	r25, r31
    f414:	08 95       	ret

0000f416 <strstr_P>:
    f416:	fb 01       	movw	r30, r22
    f418:	55 91       	lpm	r21, Z+
    f41a:	55 23       	and	r21, r21
    f41c:	a9 f0       	breq	.+42     	; 0xf448 <strstr_P+0x32>
    f41e:	bf 01       	movw	r22, r30
    f420:	dc 01       	movw	r26, r24
    f422:	4d 91       	ld	r20, X+
    f424:	45 17       	cp	r20, r21
    f426:	41 11       	cpse	r20, r1
    f428:	e1 f7       	brne	.-8      	; 0xf422 <strstr_P+0xc>
    f42a:	59 f4       	brne	.+22     	; 0xf442 <strstr_P+0x2c>
    f42c:	cd 01       	movw	r24, r26
    f42e:	05 90       	lpm	r0, Z+
    f430:	00 20       	and	r0, r0
    f432:	49 f0       	breq	.+18     	; 0xf446 <strstr_P+0x30>
    f434:	4d 91       	ld	r20, X+
    f436:	40 15       	cp	r20, r0
    f438:	41 11       	cpse	r20, r1
    f43a:	c9 f3       	breq	.-14     	; 0xf42e <strstr_P+0x18>
    f43c:	fb 01       	movw	r30, r22
    f43e:	41 11       	cpse	r20, r1
    f440:	ef cf       	rjmp	.-34     	; 0xf420 <strstr_P+0xa>
    f442:	81 e0       	ldi	r24, 0x01	; 1
    f444:	90 e0       	ldi	r25, 0x00	; 0
    f446:	01 97       	sbiw	r24, 0x01	; 1
    f448:	08 95       	ret

0000f44a <memcpy>:
    f44a:	fb 01       	movw	r30, r22
    f44c:	dc 01       	movw	r26, r24
    f44e:	02 c0       	rjmp	.+4      	; 0xf454 <memcpy+0xa>
    f450:	01 90       	ld	r0, Z+
    f452:	0d 92       	st	X+, r0
    f454:	41 50       	subi	r20, 0x01	; 1
    f456:	50 40       	sbci	r21, 0x00	; 0
    f458:	d8 f7       	brcc	.-10     	; 0xf450 <memcpy+0x6>
    f45a:	08 95       	ret

0000f45c <strchr>:
    f45c:	fc 01       	movw	r30, r24
    f45e:	81 91       	ld	r24, Z+
    f460:	86 17       	cp	r24, r22
    f462:	21 f0       	breq	.+8      	; 0xf46c <strchr+0x10>
    f464:	88 23       	and	r24, r24
    f466:	d9 f7       	brne	.-10     	; 0xf45e <strchr+0x2>
    f468:	99 27       	eor	r25, r25
    f46a:	08 95       	ret
    f46c:	31 97       	sbiw	r30, 0x01	; 1
    f46e:	cf 01       	movw	r24, r30
    f470:	08 95       	ret

0000f472 <strcmp>:
    f472:	fb 01       	movw	r30, r22
    f474:	dc 01       	movw	r26, r24
    f476:	8d 91       	ld	r24, X+
    f478:	01 90       	ld	r0, Z+
    f47a:	80 19       	sub	r24, r0
    f47c:	01 10       	cpse	r0, r1
    f47e:	d9 f3       	breq	.-10     	; 0xf476 <strcmp+0x4>
    f480:	99 0b       	sbc	r25, r25
    f482:	08 95       	ret

0000f484 <strnlen>:
    f484:	fc 01       	movw	r30, r24
    f486:	61 50       	subi	r22, 0x01	; 1
    f488:	70 40       	sbci	r23, 0x00	; 0
    f48a:	01 90       	ld	r0, Z+
    f48c:	01 10       	cpse	r0, r1
    f48e:	d8 f7       	brcc	.-10     	; 0xf486 <strnlen+0x2>
    f490:	80 95       	com	r24
    f492:	90 95       	com	r25
    f494:	8e 0f       	add	r24, r30
    f496:	9f 1f       	adc	r25, r31
    f498:	08 95       	ret

0000f49a <strstr>:
    f49a:	fb 01       	movw	r30, r22
    f49c:	51 91       	ld	r21, Z+
    f49e:	55 23       	and	r21, r21
    f4a0:	a9 f0       	breq	.+42     	; 0xf4cc <strstr+0x32>
    f4a2:	bf 01       	movw	r22, r30
    f4a4:	dc 01       	movw	r26, r24
    f4a6:	4d 91       	ld	r20, X+
    f4a8:	45 17       	cp	r20, r21
    f4aa:	41 11       	cpse	r20, r1
    f4ac:	e1 f7       	brne	.-8      	; 0xf4a6 <strstr+0xc>
    f4ae:	59 f4       	brne	.+22     	; 0xf4c6 <strstr+0x2c>
    f4b0:	cd 01       	movw	r24, r26
    f4b2:	01 90       	ld	r0, Z+
    f4b4:	00 20       	and	r0, r0
    f4b6:	49 f0       	breq	.+18     	; 0xf4ca <strstr+0x30>
    f4b8:	4d 91       	ld	r20, X+
    f4ba:	40 15       	cp	r20, r0
    f4bc:	41 11       	cpse	r20, r1
    f4be:	c9 f3       	breq	.-14     	; 0xf4b2 <strstr+0x18>
    f4c0:	fb 01       	movw	r30, r22
    f4c2:	41 11       	cpse	r20, r1
    f4c4:	ef cf       	rjmp	.-34     	; 0xf4a4 <strstr+0xa>
    f4c6:	81 e0       	ldi	r24, 0x01	; 1
    f4c8:	90 e0       	ldi	r25, 0x00	; 0
    f4ca:	01 97       	sbiw	r24, 0x01	; 1
    f4cc:	08 95       	ret

0000f4ce <fgetc>:
    f4ce:	cf 93       	push	r28
    f4d0:	df 93       	push	r29
    f4d2:	ec 01       	movw	r28, r24
    f4d4:	4b 81       	ldd	r20, Y+3	; 0x03
    f4d6:	40 ff       	sbrs	r20, 0
    f4d8:	1a c0       	rjmp	.+52     	; 0xf50e <fgetc+0x40>
    f4da:	46 ff       	sbrs	r20, 6
    f4dc:	0a c0       	rjmp	.+20     	; 0xf4f2 <fgetc+0x24>
    f4de:	4f 7b       	andi	r20, 0xBF	; 191
    f4e0:	4b 83       	std	Y+3, r20	; 0x03
    f4e2:	8e 81       	ldd	r24, Y+6	; 0x06
    f4e4:	9f 81       	ldd	r25, Y+7	; 0x07
    f4e6:	01 96       	adiw	r24, 0x01	; 1
    f4e8:	9f 83       	std	Y+7, r25	; 0x07
    f4ea:	8e 83       	std	Y+6, r24	; 0x06
    f4ec:	8a 81       	ldd	r24, Y+2	; 0x02
    f4ee:	28 2f       	mov	r18, r24
    f4f0:	2b c0       	rjmp	.+86     	; 0xf548 <fgetc+0x7a>
    f4f2:	42 ff       	sbrs	r20, 2
    f4f4:	13 c0       	rjmp	.+38     	; 0xf51c <fgetc+0x4e>
    f4f6:	e8 81       	ld	r30, Y
    f4f8:	f9 81       	ldd	r31, Y+1	; 0x01
    f4fa:	80 81       	ld	r24, Z
    f4fc:	28 2f       	mov	r18, r24
    f4fe:	33 27       	eor	r19, r19
    f500:	27 fd       	sbrc	r18, 7
    f502:	30 95       	com	r19
    f504:	21 15       	cp	r18, r1
    f506:	31 05       	cpc	r19, r1
    f508:	29 f4       	brne	.+10     	; 0xf514 <fgetc+0x46>
    f50a:	40 62       	ori	r20, 0x20	; 32
    f50c:	4b 83       	std	Y+3, r20	; 0x03
    f50e:	2f ef       	ldi	r18, 0xFF	; 255
    f510:	3f ef       	ldi	r19, 0xFF	; 255
    f512:	1b c0       	rjmp	.+54     	; 0xf54a <fgetc+0x7c>
    f514:	31 96       	adiw	r30, 0x01	; 1
    f516:	f9 83       	std	Y+1, r31	; 0x01
    f518:	e8 83       	st	Y, r30
    f51a:	11 c0       	rjmp	.+34     	; 0xf53e <fgetc+0x70>
    f51c:	ea 85       	ldd	r30, Y+10	; 0x0a
    f51e:	fb 85       	ldd	r31, Y+11	; 0x0b
    f520:	ce 01       	movw	r24, r28
    f522:	19 95       	eicall
    f524:	9c 01       	movw	r18, r24
    f526:	97 ff       	sbrs	r25, 7
    f528:	0a c0       	rjmp	.+20     	; 0xf53e <fgetc+0x70>
    f52a:	9b 81       	ldd	r25, Y+3	; 0x03
    f52c:	2f 5f       	subi	r18, 0xFF	; 255
    f52e:	3f 4f       	sbci	r19, 0xFF	; 255
    f530:	11 f0       	breq	.+4      	; 0xf536 <fgetc+0x68>
    f532:	80 e2       	ldi	r24, 0x20	; 32
    f534:	01 c0       	rjmp	.+2      	; 0xf538 <fgetc+0x6a>
    f536:	80 e1       	ldi	r24, 0x10	; 16
    f538:	89 2b       	or	r24, r25
    f53a:	8b 83       	std	Y+3, r24	; 0x03
    f53c:	e8 cf       	rjmp	.-48     	; 0xf50e <fgetc+0x40>
    f53e:	8e 81       	ldd	r24, Y+6	; 0x06
    f540:	9f 81       	ldd	r25, Y+7	; 0x07
    f542:	01 96       	adiw	r24, 0x01	; 1
    f544:	9f 83       	std	Y+7, r25	; 0x07
    f546:	8e 83       	std	Y+6, r24	; 0x06
    f548:	30 e0       	ldi	r19, 0x00	; 0
    f54a:	c9 01       	movw	r24, r18
    f54c:	df 91       	pop	r29
    f54e:	cf 91       	pop	r28
    f550:	08 95       	ret

0000f552 <fputc>:
    f552:	0f 93       	push	r16
    f554:	1f 93       	push	r17
    f556:	cf 93       	push	r28
    f558:	df 93       	push	r29
    f55a:	8c 01       	movw	r16, r24
    f55c:	eb 01       	movw	r28, r22
    f55e:	8b 81       	ldd	r24, Y+3	; 0x03
    f560:	81 ff       	sbrs	r24, 1
    f562:	1b c0       	rjmp	.+54     	; 0xf59a <fputc+0x48>
    f564:	82 ff       	sbrs	r24, 2
    f566:	0d c0       	rjmp	.+26     	; 0xf582 <fputc+0x30>
    f568:	2e 81       	ldd	r18, Y+6	; 0x06
    f56a:	3f 81       	ldd	r19, Y+7	; 0x07
    f56c:	8c 81       	ldd	r24, Y+4	; 0x04
    f56e:	9d 81       	ldd	r25, Y+5	; 0x05
    f570:	28 17       	cp	r18, r24
    f572:	39 07       	cpc	r19, r25
    f574:	64 f4       	brge	.+24     	; 0xf58e <fputc+0x3c>
    f576:	e8 81       	ld	r30, Y
    f578:	f9 81       	ldd	r31, Y+1	; 0x01
    f57a:	01 93       	st	Z+, r16
    f57c:	f9 83       	std	Y+1, r31	; 0x01
    f57e:	e8 83       	st	Y, r30
    f580:	06 c0       	rjmp	.+12     	; 0xf58e <fputc+0x3c>
    f582:	e8 85       	ldd	r30, Y+8	; 0x08
    f584:	f9 85       	ldd	r31, Y+9	; 0x09
    f586:	80 2f       	mov	r24, r16
    f588:	19 95       	eicall
    f58a:	89 2b       	or	r24, r25
    f58c:	31 f4       	brne	.+12     	; 0xf59a <fputc+0x48>
    f58e:	8e 81       	ldd	r24, Y+6	; 0x06
    f590:	9f 81       	ldd	r25, Y+7	; 0x07
    f592:	01 96       	adiw	r24, 0x01	; 1
    f594:	9f 83       	std	Y+7, r25	; 0x07
    f596:	8e 83       	std	Y+6, r24	; 0x06
    f598:	02 c0       	rjmp	.+4      	; 0xf59e <fputc+0x4c>
    f59a:	0f ef       	ldi	r16, 0xFF	; 255
    f59c:	1f ef       	ldi	r17, 0xFF	; 255
    f59e:	c8 01       	movw	r24, r16
    f5a0:	df 91       	pop	r29
    f5a2:	cf 91       	pop	r28
    f5a4:	1f 91       	pop	r17
    f5a6:	0f 91       	pop	r16
    f5a8:	08 95       	ret

0000f5aa <sprintf>:
    f5aa:	0f 93       	push	r16
    f5ac:	1f 93       	push	r17
    f5ae:	df 93       	push	r29
    f5b0:	cf 93       	push	r28
    f5b2:	cd b7       	in	r28, 0x3d	; 61
    f5b4:	de b7       	in	r29, 0x3e	; 62
    f5b6:	2e 97       	sbiw	r28, 0x0e	; 14
    f5b8:	0f b6       	in	r0, 0x3f	; 63
    f5ba:	f8 94       	cli
    f5bc:	de bf       	out	0x3e, r29	; 62
    f5be:	0f be       	out	0x3f, r0	; 63
    f5c0:	cd bf       	out	0x3d, r28	; 61
    f5c2:	0e 89       	ldd	r16, Y+22	; 0x16
    f5c4:	1f 89       	ldd	r17, Y+23	; 0x17
    f5c6:	86 e0       	ldi	r24, 0x06	; 6
    f5c8:	8c 83       	std	Y+4, r24	; 0x04
    f5ca:	1a 83       	std	Y+2, r17	; 0x02
    f5cc:	09 83       	std	Y+1, r16	; 0x01
    f5ce:	8f ef       	ldi	r24, 0xFF	; 255
    f5d0:	9f e7       	ldi	r25, 0x7F	; 127
    f5d2:	9e 83       	std	Y+6, r25	; 0x06
    f5d4:	8d 83       	std	Y+5, r24	; 0x05
    f5d6:	9e 01       	movw	r18, r28
    f5d8:	26 5e       	subi	r18, 0xE6	; 230
    f5da:	3f 4f       	sbci	r19, 0xFF	; 255
    f5dc:	ce 01       	movw	r24, r28
    f5de:	01 96       	adiw	r24, 0x01	; 1
    f5e0:	68 8d       	ldd	r22, Y+24	; 0x18
    f5e2:	79 8d       	ldd	r23, Y+25	; 0x19
    f5e4:	a9 01       	movw	r20, r18
    f5e6:	0e 94 fc 6f 	call	0xdff8	; 0xdff8 <vfprintf>
    f5ea:	2f 81       	ldd	r18, Y+7	; 0x07
    f5ec:	38 85       	ldd	r19, Y+8	; 0x08
    f5ee:	02 0f       	add	r16, r18
    f5f0:	13 1f       	adc	r17, r19
    f5f2:	f8 01       	movw	r30, r16
    f5f4:	10 82       	st	Z, r1
    f5f6:	2e 96       	adiw	r28, 0x0e	; 14
    f5f8:	0f b6       	in	r0, 0x3f	; 63
    f5fa:	f8 94       	cli
    f5fc:	de bf       	out	0x3e, r29	; 62
    f5fe:	0f be       	out	0x3f, r0	; 63
    f600:	cd bf       	out	0x3d, r28	; 61
    f602:	cf 91       	pop	r28
    f604:	df 91       	pop	r29
    f606:	1f 91       	pop	r17
    f608:	0f 91       	pop	r16
    f60a:	08 95       	ret

0000f60c <sprintf_P>:
    f60c:	0f 93       	push	r16
    f60e:	1f 93       	push	r17
    f610:	df 93       	push	r29
    f612:	cf 93       	push	r28
    f614:	cd b7       	in	r28, 0x3d	; 61
    f616:	de b7       	in	r29, 0x3e	; 62
    f618:	2e 97       	sbiw	r28, 0x0e	; 14
    f61a:	0f b6       	in	r0, 0x3f	; 63
    f61c:	f8 94       	cli
    f61e:	de bf       	out	0x3e, r29	; 62
    f620:	0f be       	out	0x3f, r0	; 63
    f622:	cd bf       	out	0x3d, r28	; 61
    f624:	0e 89       	ldd	r16, Y+22	; 0x16
    f626:	1f 89       	ldd	r17, Y+23	; 0x17
    f628:	8e e0       	ldi	r24, 0x0E	; 14
    f62a:	8c 83       	std	Y+4, r24	; 0x04
    f62c:	1a 83       	std	Y+2, r17	; 0x02
    f62e:	09 83       	std	Y+1, r16	; 0x01
    f630:	8f ef       	ldi	r24, 0xFF	; 255
    f632:	9f e7       	ldi	r25, 0x7F	; 127
    f634:	9e 83       	std	Y+6, r25	; 0x06
    f636:	8d 83       	std	Y+5, r24	; 0x05
    f638:	9e 01       	movw	r18, r28
    f63a:	26 5e       	subi	r18, 0xE6	; 230
    f63c:	3f 4f       	sbci	r19, 0xFF	; 255
    f63e:	ce 01       	movw	r24, r28
    f640:	01 96       	adiw	r24, 0x01	; 1
    f642:	68 8d       	ldd	r22, Y+24	; 0x18
    f644:	79 8d       	ldd	r23, Y+25	; 0x19
    f646:	a9 01       	movw	r20, r18
    f648:	0e 94 fc 6f 	call	0xdff8	; 0xdff8 <vfprintf>
    f64c:	2f 81       	ldd	r18, Y+7	; 0x07
    f64e:	38 85       	ldd	r19, Y+8	; 0x08
    f650:	02 0f       	add	r16, r18
    f652:	13 1f       	adc	r17, r19
    f654:	f8 01       	movw	r30, r16
    f656:	10 82       	st	Z, r1
    f658:	2e 96       	adiw	r28, 0x0e	; 14
    f65a:	0f b6       	in	r0, 0x3f	; 63
    f65c:	f8 94       	cli
    f65e:	de bf       	out	0x3e, r29	; 62
    f660:	0f be       	out	0x3f, r0	; 63
    f662:	cd bf       	out	0x3d, r28	; 61
    f664:	cf 91       	pop	r28
    f666:	df 91       	pop	r29
    f668:	1f 91       	pop	r17
    f66a:	0f 91       	pop	r16
    f66c:	08 95       	ret

0000f66e <sscanf>:
    f66e:	df 93       	push	r29
    f670:	cf 93       	push	r28
    f672:	cd b7       	in	r28, 0x3d	; 61
    f674:	de b7       	in	r29, 0x3e	; 62
    f676:	2e 97       	sbiw	r28, 0x0e	; 14
    f678:	0f b6       	in	r0, 0x3f	; 63
    f67a:	f8 94       	cli
    f67c:	de bf       	out	0x3e, r29	; 62
    f67e:	0f be       	out	0x3f, r0	; 63
    f680:	cd bf       	out	0x3d, r28	; 61
    f682:	85 e0       	ldi	r24, 0x05	; 5
    f684:	8c 83       	std	Y+4, r24	; 0x04
    f686:	8c 89       	ldd	r24, Y+20	; 0x14
    f688:	9d 89       	ldd	r25, Y+21	; 0x15
    f68a:	9a 83       	std	Y+2, r25	; 0x02
    f68c:	89 83       	std	Y+1, r24	; 0x01
    f68e:	9e 01       	movw	r18, r28
    f690:	28 5e       	subi	r18, 0xE8	; 232
    f692:	3f 4f       	sbci	r19, 0xFF	; 255
    f694:	ce 01       	movw	r24, r28
    f696:	01 96       	adiw	r24, 0x01	; 1
    f698:	6e 89       	ldd	r22, Y+22	; 0x16
    f69a:	7f 89       	ldd	r23, Y+23	; 0x17
    f69c:	a9 01       	movw	r20, r18
    f69e:	0e 94 b3 76 	call	0xed66	; 0xed66 <vfscanf>
    f6a2:	2e 96       	adiw	r28, 0x0e	; 14
    f6a4:	0f b6       	in	r0, 0x3f	; 63
    f6a6:	f8 94       	cli
    f6a8:	de bf       	out	0x3e, r29	; 62
    f6aa:	0f be       	out	0x3f, r0	; 63
    f6ac:	cd bf       	out	0x3d, r28	; 61
    f6ae:	cf 91       	pop	r28
    f6b0:	df 91       	pop	r29
    f6b2:	08 95       	ret

0000f6b4 <sscanf_P>:
    f6b4:	df 93       	push	r29
    f6b6:	cf 93       	push	r28
    f6b8:	cd b7       	in	r28, 0x3d	; 61
    f6ba:	de b7       	in	r29, 0x3e	; 62
    f6bc:	2e 97       	sbiw	r28, 0x0e	; 14
    f6be:	0f b6       	in	r0, 0x3f	; 63
    f6c0:	f8 94       	cli
    f6c2:	de bf       	out	0x3e, r29	; 62
    f6c4:	0f be       	out	0x3f, r0	; 63
    f6c6:	cd bf       	out	0x3d, r28	; 61
    f6c8:	8d e0       	ldi	r24, 0x0D	; 13
    f6ca:	8c 83       	std	Y+4, r24	; 0x04
    f6cc:	8c 89       	ldd	r24, Y+20	; 0x14
    f6ce:	9d 89       	ldd	r25, Y+21	; 0x15
    f6d0:	9a 83       	std	Y+2, r25	; 0x02
    f6d2:	89 83       	std	Y+1, r24	; 0x01
    f6d4:	9e 01       	movw	r18, r28
    f6d6:	28 5e       	subi	r18, 0xE8	; 232
    f6d8:	3f 4f       	sbci	r19, 0xFF	; 255
    f6da:	ce 01       	movw	r24, r28
    f6dc:	01 96       	adiw	r24, 0x01	; 1
    f6de:	6e 89       	ldd	r22, Y+22	; 0x16
    f6e0:	7f 89       	ldd	r23, Y+23	; 0x17
    f6e2:	a9 01       	movw	r20, r18
    f6e4:	0e 94 b3 76 	call	0xed66	; 0xed66 <vfscanf>
    f6e8:	2e 96       	adiw	r28, 0x0e	; 14
    f6ea:	0f b6       	in	r0, 0x3f	; 63
    f6ec:	f8 94       	cli
    f6ee:	de bf       	out	0x3e, r29	; 62
    f6f0:	0f be       	out	0x3f, r0	; 63
    f6f2:	cd bf       	out	0x3d, r28	; 61
    f6f4:	cf 91       	pop	r28
    f6f6:	df 91       	pop	r29
    f6f8:	08 95       	ret

0000f6fa <ungetc>:
    f6fa:	9c 01       	movw	r18, r24
    f6fc:	fb 01       	movw	r30, r22
    f6fe:	83 81       	ldd	r24, Z+3	; 0x03
    f700:	80 ff       	sbrs	r24, 0
    f702:	11 c0       	rjmp	.+34     	; 0xf726 <ungetc+0x2c>
    f704:	86 fd       	sbrc	r24, 6
    f706:	0f c0       	rjmp	.+30     	; 0xf726 <ungetc+0x2c>
    f708:	9f ef       	ldi	r25, 0xFF	; 255
    f70a:	2f 3f       	cpi	r18, 0xFF	; 255
    f70c:	39 07       	cpc	r19, r25
    f70e:	59 f0       	breq	.+22     	; 0xf726 <ungetc+0x2c>
    f710:	22 83       	std	Z+2, r18	; 0x02
    f712:	80 64       	ori	r24, 0x40	; 64
    f714:	8f 7d       	andi	r24, 0xDF	; 223
    f716:	83 83       	std	Z+3, r24	; 0x03
    f718:	86 81       	ldd	r24, Z+6	; 0x06
    f71a:	97 81       	ldd	r25, Z+7	; 0x07
    f71c:	01 97       	sbiw	r24, 0x01	; 1
    f71e:	97 83       	std	Z+7, r25	; 0x07
    f720:	86 83       	std	Z+6, r24	; 0x06
    f722:	30 e0       	ldi	r19, 0x00	; 0
    f724:	02 c0       	rjmp	.+4      	; 0xf72a <ungetc+0x30>
    f726:	2f ef       	ldi	r18, 0xFF	; 255
    f728:	3f ef       	ldi	r19, 0xFF	; 255
    f72a:	c9 01       	movw	r24, r18
    f72c:	08 95       	ret

0000f72e <__ultoa_invert>:
    f72e:	fa 01       	movw	r30, r20
    f730:	aa 27       	eor	r26, r26
    f732:	28 30       	cpi	r18, 0x08	; 8
    f734:	51 f1       	breq	.+84     	; 0xf78a <__ultoa_invert+0x5c>
    f736:	20 31       	cpi	r18, 0x10	; 16
    f738:	81 f1       	breq	.+96     	; 0xf79a <__ultoa_invert+0x6c>
    f73a:	e8 94       	clt
    f73c:	6f 93       	push	r22
    f73e:	6e 7f       	andi	r22, 0xFE	; 254
    f740:	6e 5f       	subi	r22, 0xFE	; 254
    f742:	7f 4f       	sbci	r23, 0xFF	; 255
    f744:	8f 4f       	sbci	r24, 0xFF	; 255
    f746:	9f 4f       	sbci	r25, 0xFF	; 255
    f748:	af 4f       	sbci	r26, 0xFF	; 255
    f74a:	b1 e0       	ldi	r27, 0x01	; 1
    f74c:	3e d0       	rcall	.+124    	; 0xf7ca <__ultoa_invert+0x9c>
    f74e:	b4 e0       	ldi	r27, 0x04	; 4
    f750:	3c d0       	rcall	.+120    	; 0xf7ca <__ultoa_invert+0x9c>
    f752:	67 0f       	add	r22, r23
    f754:	78 1f       	adc	r23, r24
    f756:	89 1f       	adc	r24, r25
    f758:	9a 1f       	adc	r25, r26
    f75a:	a1 1d       	adc	r26, r1
    f75c:	68 0f       	add	r22, r24
    f75e:	79 1f       	adc	r23, r25
    f760:	8a 1f       	adc	r24, r26
    f762:	91 1d       	adc	r25, r1
    f764:	a1 1d       	adc	r26, r1
    f766:	6a 0f       	add	r22, r26
    f768:	71 1d       	adc	r23, r1
    f76a:	81 1d       	adc	r24, r1
    f76c:	91 1d       	adc	r25, r1
    f76e:	a1 1d       	adc	r26, r1
    f770:	20 d0       	rcall	.+64     	; 0xf7b2 <__ultoa_invert+0x84>
    f772:	09 f4       	brne	.+2      	; 0xf776 <__ultoa_invert+0x48>
    f774:	68 94       	set
    f776:	3f 91       	pop	r19
    f778:	2a e0       	ldi	r18, 0x0A	; 10
    f77a:	26 9f       	mul	r18, r22
    f77c:	11 24       	eor	r1, r1
    f77e:	30 19       	sub	r19, r0
    f780:	30 5d       	subi	r19, 0xD0	; 208
    f782:	31 93       	st	Z+, r19
    f784:	de f6       	brtc	.-74     	; 0xf73c <__ultoa_invert+0xe>
    f786:	cf 01       	movw	r24, r30
    f788:	08 95       	ret
    f78a:	46 2f       	mov	r20, r22
    f78c:	47 70       	andi	r20, 0x07	; 7
    f78e:	40 5d       	subi	r20, 0xD0	; 208
    f790:	41 93       	st	Z+, r20
    f792:	b3 e0       	ldi	r27, 0x03	; 3
    f794:	0f d0       	rcall	.+30     	; 0xf7b4 <__ultoa_invert+0x86>
    f796:	c9 f7       	brne	.-14     	; 0xf78a <__ultoa_invert+0x5c>
    f798:	f6 cf       	rjmp	.-20     	; 0xf786 <__ultoa_invert+0x58>
    f79a:	46 2f       	mov	r20, r22
    f79c:	4f 70       	andi	r20, 0x0F	; 15
    f79e:	40 5d       	subi	r20, 0xD0	; 208
    f7a0:	4a 33       	cpi	r20, 0x3A	; 58
    f7a2:	18 f0       	brcs	.+6      	; 0xf7aa <__ultoa_invert+0x7c>
    f7a4:	49 5d       	subi	r20, 0xD9	; 217
    f7a6:	31 fd       	sbrc	r19, 1
    f7a8:	40 52       	subi	r20, 0x20	; 32
    f7aa:	41 93       	st	Z+, r20
    f7ac:	02 d0       	rcall	.+4      	; 0xf7b2 <__ultoa_invert+0x84>
    f7ae:	a9 f7       	brne	.-22     	; 0xf79a <__ultoa_invert+0x6c>
    f7b0:	ea cf       	rjmp	.-44     	; 0xf786 <__ultoa_invert+0x58>
    f7b2:	b4 e0       	ldi	r27, 0x04	; 4
    f7b4:	a6 95       	lsr	r26
    f7b6:	97 95       	ror	r25
    f7b8:	87 95       	ror	r24
    f7ba:	77 95       	ror	r23
    f7bc:	67 95       	ror	r22
    f7be:	ba 95       	dec	r27
    f7c0:	c9 f7       	brne	.-14     	; 0xf7b4 <__ultoa_invert+0x86>
    f7c2:	00 97       	sbiw	r24, 0x00	; 0
    f7c4:	61 05       	cpc	r22, r1
    f7c6:	71 05       	cpc	r23, r1
    f7c8:	08 95       	ret
    f7ca:	9b 01       	movw	r18, r22
    f7cc:	ac 01       	movw	r20, r24
    f7ce:	0a 2e       	mov	r0, r26
    f7d0:	06 94       	lsr	r0
    f7d2:	57 95       	ror	r21
    f7d4:	47 95       	ror	r20
    f7d6:	37 95       	ror	r19
    f7d8:	27 95       	ror	r18
    f7da:	ba 95       	dec	r27
    f7dc:	c9 f7       	brne	.-14     	; 0xf7d0 <__ultoa_invert+0xa2>
    f7de:	62 0f       	add	r22, r18
    f7e0:	73 1f       	adc	r23, r19
    f7e2:	84 1f       	adc	r24, r20
    f7e4:	95 1f       	adc	r25, r21
    f7e6:	a0 1d       	adc	r26, r0
    f7e8:	08 95       	ret

0000f7ea <__subsf3>:
    f7ea:	50 58       	subi	r21, 0x80	; 128

0000f7ec <__addsf3>:
    f7ec:	bb 27       	eor	r27, r27
    f7ee:	aa 27       	eor	r26, r26
    f7f0:	0e d0       	rcall	.+28     	; 0xf80e <__addsf3x>
    f7f2:	af cc       	rjmp	.-1698   	; 0xf152 <__fp_round>
    f7f4:	a0 dc       	rcall	.-1728   	; 0xf136 <__fp_pscA>
    f7f6:	30 f0       	brcs	.+12     	; 0xf804 <__addsf3+0x18>
    f7f8:	a5 dc       	rcall	.-1718   	; 0xf144 <__fp_pscB>
    f7fa:	20 f0       	brcs	.+8      	; 0xf804 <__addsf3+0x18>
    f7fc:	31 f4       	brne	.+12     	; 0xf80a <__addsf3+0x1e>
    f7fe:	9f 3f       	cpi	r25, 0xFF	; 255
    f800:	11 f4       	brne	.+4      	; 0xf806 <__addsf3+0x1a>
    f802:	1e f4       	brtc	.+6      	; 0xf80a <__addsf3+0x1e>
    f804:	95 cc       	rjmp	.-1750   	; 0xf130 <__fp_nan>
    f806:	0e f4       	brtc	.+2      	; 0xf80a <__addsf3+0x1e>
    f808:	e0 95       	com	r30
    f80a:	e7 fb       	bst	r30, 7
    f80c:	8b cc       	rjmp	.-1770   	; 0xf124 <__fp_inf>

0000f80e <__addsf3x>:
    f80e:	e9 2f       	mov	r30, r25
    f810:	b1 dc       	rcall	.-1694   	; 0xf174 <__fp_split3>
    f812:	80 f3       	brcs	.-32     	; 0xf7f4 <__addsf3+0x8>
    f814:	ba 17       	cp	r27, r26
    f816:	62 07       	cpc	r22, r18
    f818:	73 07       	cpc	r23, r19
    f81a:	84 07       	cpc	r24, r20
    f81c:	95 07       	cpc	r25, r21
    f81e:	18 f0       	brcs	.+6      	; 0xf826 <__addsf3x+0x18>
    f820:	71 f4       	brne	.+28     	; 0xf83e <__addsf3x+0x30>
    f822:	9e f5       	brtc	.+102    	; 0xf88a <__addsf3x+0x7c>
    f824:	c9 cc       	rjmp	.-1646   	; 0xf1b8 <__fp_zero>
    f826:	0e f4       	brtc	.+2      	; 0xf82a <__addsf3x+0x1c>
    f828:	e0 95       	com	r30
    f82a:	0b 2e       	mov	r0, r27
    f82c:	ba 2f       	mov	r27, r26
    f82e:	a0 2d       	mov	r26, r0
    f830:	0b 01       	movw	r0, r22
    f832:	b9 01       	movw	r22, r18
    f834:	90 01       	movw	r18, r0
    f836:	0c 01       	movw	r0, r24
    f838:	ca 01       	movw	r24, r20
    f83a:	a0 01       	movw	r20, r0
    f83c:	11 24       	eor	r1, r1
    f83e:	ff 27       	eor	r31, r31
    f840:	59 1b       	sub	r21, r25
    f842:	99 f0       	breq	.+38     	; 0xf86a <__addsf3x+0x5c>
    f844:	59 3f       	cpi	r21, 0xF9	; 249
    f846:	50 f4       	brcc	.+20     	; 0xf85c <__addsf3x+0x4e>
    f848:	50 3e       	cpi	r21, 0xE0	; 224
    f84a:	68 f1       	brcs	.+90     	; 0xf8a6 <__addsf3x+0x98>
    f84c:	1a 16       	cp	r1, r26
    f84e:	f0 40       	sbci	r31, 0x00	; 0
    f850:	a2 2f       	mov	r26, r18
    f852:	23 2f       	mov	r18, r19
    f854:	34 2f       	mov	r19, r20
    f856:	44 27       	eor	r20, r20
    f858:	58 5f       	subi	r21, 0xF8	; 248
    f85a:	f3 cf       	rjmp	.-26     	; 0xf842 <__addsf3x+0x34>
    f85c:	46 95       	lsr	r20
    f85e:	37 95       	ror	r19
    f860:	27 95       	ror	r18
    f862:	a7 95       	ror	r26
    f864:	f0 40       	sbci	r31, 0x00	; 0
    f866:	53 95       	inc	r21
    f868:	c9 f7       	brne	.-14     	; 0xf85c <__addsf3x+0x4e>
    f86a:	7e f4       	brtc	.+30     	; 0xf88a <__addsf3x+0x7c>
    f86c:	1f 16       	cp	r1, r31
    f86e:	ba 0b       	sbc	r27, r26
    f870:	62 0b       	sbc	r22, r18
    f872:	73 0b       	sbc	r23, r19
    f874:	84 0b       	sbc	r24, r20
    f876:	ba f0       	brmi	.+46     	; 0xf8a6 <__addsf3x+0x98>
    f878:	91 50       	subi	r25, 0x01	; 1
    f87a:	a1 f0       	breq	.+40     	; 0xf8a4 <__addsf3x+0x96>
    f87c:	ff 0f       	add	r31, r31
    f87e:	bb 1f       	adc	r27, r27
    f880:	66 1f       	adc	r22, r22
    f882:	77 1f       	adc	r23, r23
    f884:	88 1f       	adc	r24, r24
    f886:	c2 f7       	brpl	.-16     	; 0xf878 <__addsf3x+0x6a>
    f888:	0e c0       	rjmp	.+28     	; 0xf8a6 <__addsf3x+0x98>
    f88a:	ba 0f       	add	r27, r26
    f88c:	62 1f       	adc	r22, r18
    f88e:	73 1f       	adc	r23, r19
    f890:	84 1f       	adc	r24, r20
    f892:	48 f4       	brcc	.+18     	; 0xf8a6 <__addsf3x+0x98>
    f894:	87 95       	ror	r24
    f896:	77 95       	ror	r23
    f898:	67 95       	ror	r22
    f89a:	b7 95       	ror	r27
    f89c:	f7 95       	ror	r31
    f89e:	9e 3f       	cpi	r25, 0xFE	; 254
    f8a0:	08 f0       	brcs	.+2      	; 0xf8a4 <__addsf3x+0x96>
    f8a2:	b3 cf       	rjmp	.-154    	; 0xf80a <__addsf3+0x1e>
    f8a4:	93 95       	inc	r25
    f8a6:	88 0f       	add	r24, r24
    f8a8:	08 f0       	brcs	.+2      	; 0xf8ac <__addsf3x+0x9e>
    f8aa:	99 27       	eor	r25, r25
    f8ac:	ee 0f       	add	r30, r30
    f8ae:	97 95       	ror	r25
    f8b0:	87 95       	ror	r24
    f8b2:	08 95       	ret

0000f8b4 <__divsf3>:
    f8b4:	0c d0       	rcall	.+24     	; 0xf8ce <__divsf3x>
    f8b6:	4d cc       	rjmp	.-1894   	; 0xf152 <__fp_round>
    f8b8:	45 dc       	rcall	.-1910   	; 0xf144 <__fp_pscB>
    f8ba:	40 f0       	brcs	.+16     	; 0xf8cc <__divsf3+0x18>
    f8bc:	3c dc       	rcall	.-1928   	; 0xf136 <__fp_pscA>
    f8be:	30 f0       	brcs	.+12     	; 0xf8cc <__divsf3+0x18>
    f8c0:	21 f4       	brne	.+8      	; 0xf8ca <__divsf3+0x16>
    f8c2:	5f 3f       	cpi	r21, 0xFF	; 255
    f8c4:	19 f0       	breq	.+6      	; 0xf8cc <__divsf3+0x18>
    f8c6:	2e cc       	rjmp	.-1956   	; 0xf124 <__fp_inf>
    f8c8:	51 11       	cpse	r21, r1
    f8ca:	77 cc       	rjmp	.-1810   	; 0xf1ba <__fp_szero>
    f8cc:	31 cc       	rjmp	.-1950   	; 0xf130 <__fp_nan>

0000f8ce <__divsf3x>:
    f8ce:	52 dc       	rcall	.-1884   	; 0xf174 <__fp_split3>
    f8d0:	98 f3       	brcs	.-26     	; 0xf8b8 <__divsf3+0x4>

0000f8d2 <__divsf3_pse>:
    f8d2:	99 23       	and	r25, r25
    f8d4:	c9 f3       	breq	.-14     	; 0xf8c8 <__divsf3+0x14>
    f8d6:	55 23       	and	r21, r21
    f8d8:	b1 f3       	breq	.-20     	; 0xf8c6 <__divsf3+0x12>
    f8da:	95 1b       	sub	r25, r21
    f8dc:	55 0b       	sbc	r21, r21
    f8de:	bb 27       	eor	r27, r27
    f8e0:	aa 27       	eor	r26, r26
    f8e2:	62 17       	cp	r22, r18
    f8e4:	73 07       	cpc	r23, r19
    f8e6:	84 07       	cpc	r24, r20
    f8e8:	38 f0       	brcs	.+14     	; 0xf8f8 <__divsf3_pse+0x26>
    f8ea:	9f 5f       	subi	r25, 0xFF	; 255
    f8ec:	5f 4f       	sbci	r21, 0xFF	; 255
    f8ee:	22 0f       	add	r18, r18
    f8f0:	33 1f       	adc	r19, r19
    f8f2:	44 1f       	adc	r20, r20
    f8f4:	aa 1f       	adc	r26, r26
    f8f6:	a9 f3       	breq	.-22     	; 0xf8e2 <__divsf3_pse+0x10>
    f8f8:	33 d0       	rcall	.+102    	; 0xf960 <__divsf3_pse+0x8e>
    f8fa:	0e 2e       	mov	r0, r30
    f8fc:	3a f0       	brmi	.+14     	; 0xf90c <__divsf3_pse+0x3a>
    f8fe:	e0 e8       	ldi	r30, 0x80	; 128
    f900:	30 d0       	rcall	.+96     	; 0xf962 <__divsf3_pse+0x90>
    f902:	91 50       	subi	r25, 0x01	; 1
    f904:	50 40       	sbci	r21, 0x00	; 0
    f906:	e6 95       	lsr	r30
    f908:	00 1c       	adc	r0, r0
    f90a:	ca f7       	brpl	.-14     	; 0xf8fe <__divsf3_pse+0x2c>
    f90c:	29 d0       	rcall	.+82     	; 0xf960 <__divsf3_pse+0x8e>
    f90e:	fe 2f       	mov	r31, r30
    f910:	27 d0       	rcall	.+78     	; 0xf960 <__divsf3_pse+0x8e>
    f912:	66 0f       	add	r22, r22
    f914:	77 1f       	adc	r23, r23
    f916:	88 1f       	adc	r24, r24
    f918:	bb 1f       	adc	r27, r27
    f91a:	26 17       	cp	r18, r22
    f91c:	37 07       	cpc	r19, r23
    f91e:	48 07       	cpc	r20, r24
    f920:	ab 07       	cpc	r26, r27
    f922:	b0 e8       	ldi	r27, 0x80	; 128
    f924:	09 f0       	breq	.+2      	; 0xf928 <__divsf3_pse+0x56>
    f926:	bb 0b       	sbc	r27, r27
    f928:	80 2d       	mov	r24, r0
    f92a:	bf 01       	movw	r22, r30
    f92c:	ff 27       	eor	r31, r31
    f92e:	93 58       	subi	r25, 0x83	; 131
    f930:	5f 4f       	sbci	r21, 0xFF	; 255
    f932:	2a f0       	brmi	.+10     	; 0xf93e <__divsf3_pse+0x6c>
    f934:	9e 3f       	cpi	r25, 0xFE	; 254
    f936:	51 05       	cpc	r21, r1
    f938:	68 f0       	brcs	.+26     	; 0xf954 <__divsf3_pse+0x82>
    f93a:	f4 cb       	rjmp	.-2072   	; 0xf124 <__fp_inf>
    f93c:	3e cc       	rjmp	.-1924   	; 0xf1ba <__fp_szero>
    f93e:	5f 3f       	cpi	r21, 0xFF	; 255
    f940:	ec f3       	brlt	.-6      	; 0xf93c <__divsf3_pse+0x6a>
    f942:	98 3e       	cpi	r25, 0xE8	; 232
    f944:	dc f3       	brlt	.-10     	; 0xf93c <__divsf3_pse+0x6a>
    f946:	86 95       	lsr	r24
    f948:	77 95       	ror	r23
    f94a:	67 95       	ror	r22
    f94c:	b7 95       	ror	r27
    f94e:	f7 95       	ror	r31
    f950:	9f 5f       	subi	r25, 0xFF	; 255
    f952:	c9 f7       	brne	.-14     	; 0xf946 <__divsf3_pse+0x74>
    f954:	88 0f       	add	r24, r24
    f956:	91 1d       	adc	r25, r1
    f958:	96 95       	lsr	r25
    f95a:	87 95       	ror	r24
    f95c:	97 f9       	bld	r25, 7
    f95e:	08 95       	ret
    f960:	e1 e0       	ldi	r30, 0x01	; 1
    f962:	66 0f       	add	r22, r22
    f964:	77 1f       	adc	r23, r23
    f966:	88 1f       	adc	r24, r24
    f968:	bb 1f       	adc	r27, r27
    f96a:	62 17       	cp	r22, r18
    f96c:	73 07       	cpc	r23, r19
    f96e:	84 07       	cpc	r24, r20
    f970:	ba 07       	cpc	r27, r26
    f972:	20 f0       	brcs	.+8      	; 0xf97c <__divsf3_pse+0xaa>
    f974:	62 1b       	sub	r22, r18
    f976:	73 0b       	sbc	r23, r19
    f978:	84 0b       	sbc	r24, r20
    f97a:	ba 0b       	sbc	r27, r26
    f97c:	ee 1f       	adc	r30, r30
    f97e:	88 f7       	brcc	.-30     	; 0xf962 <__divsf3_pse+0x90>
    f980:	e0 95       	com	r30
    f982:	08 95       	ret

0000f984 <__fixsfsi>:
    f984:	04 d0       	rcall	.+8      	; 0xf98e <__fixunssfsi>
    f986:	68 94       	set
    f988:	b1 11       	cpse	r27, r1
    f98a:	17 cc       	rjmp	.-2002   	; 0xf1ba <__fp_szero>
    f98c:	08 95       	ret

0000f98e <__fixunssfsi>:
    f98e:	fa db       	rcall	.-2060   	; 0xf184 <__fp_splitA>
    f990:	88 f0       	brcs	.+34     	; 0xf9b4 <__fixunssfsi+0x26>
    f992:	9f 57       	subi	r25, 0x7F	; 127
    f994:	90 f0       	brcs	.+36     	; 0xf9ba <__fixunssfsi+0x2c>
    f996:	b9 2f       	mov	r27, r25
    f998:	99 27       	eor	r25, r25
    f99a:	b7 51       	subi	r27, 0x17	; 23
    f99c:	a0 f0       	brcs	.+40     	; 0xf9c6 <__fixunssfsi+0x38>
    f99e:	d1 f0       	breq	.+52     	; 0xf9d4 <__fixunssfsi+0x46>
    f9a0:	66 0f       	add	r22, r22
    f9a2:	77 1f       	adc	r23, r23
    f9a4:	88 1f       	adc	r24, r24
    f9a6:	99 1f       	adc	r25, r25
    f9a8:	1a f0       	brmi	.+6      	; 0xf9b0 <__fixunssfsi+0x22>
    f9aa:	ba 95       	dec	r27
    f9ac:	c9 f7       	brne	.-14     	; 0xf9a0 <__fixunssfsi+0x12>
    f9ae:	12 c0       	rjmp	.+36     	; 0xf9d4 <__fixunssfsi+0x46>
    f9b0:	b1 30       	cpi	r27, 0x01	; 1
    f9b2:	81 f0       	breq	.+32     	; 0xf9d4 <__fixunssfsi+0x46>
    f9b4:	01 dc       	rcall	.-2046   	; 0xf1b8 <__fp_zero>
    f9b6:	b1 e0       	ldi	r27, 0x01	; 1
    f9b8:	08 95       	ret
    f9ba:	fe cb       	rjmp	.-2052   	; 0xf1b8 <__fp_zero>
    f9bc:	67 2f       	mov	r22, r23
    f9be:	78 2f       	mov	r23, r24
    f9c0:	88 27       	eor	r24, r24
    f9c2:	b8 5f       	subi	r27, 0xF8	; 248
    f9c4:	39 f0       	breq	.+14     	; 0xf9d4 <__fixunssfsi+0x46>
    f9c6:	b9 3f       	cpi	r27, 0xF9	; 249
    f9c8:	cc f3       	brlt	.-14     	; 0xf9bc <__fixunssfsi+0x2e>
    f9ca:	86 95       	lsr	r24
    f9cc:	77 95       	ror	r23
    f9ce:	67 95       	ror	r22
    f9d0:	b3 95       	inc	r27
    f9d2:	d9 f7       	brne	.-10     	; 0xf9ca <__fixunssfsi+0x3c>
    f9d4:	3e f4       	brtc	.+14     	; 0xf9e4 <__fixunssfsi+0x56>
    f9d6:	90 95       	com	r25
    f9d8:	80 95       	com	r24
    f9da:	70 95       	com	r23
    f9dc:	61 95       	neg	r22
    f9de:	7f 4f       	sbci	r23, 0xFF	; 255
    f9e0:	8f 4f       	sbci	r24, 0xFF	; 255
    f9e2:	9f 4f       	sbci	r25, 0xFF	; 255
    f9e4:	08 95       	ret

0000f9e6 <__eerd_block_m2560>:
    f9e6:	dc 01       	movw	r26, r24
    f9e8:	cb 01       	movw	r24, r22

0000f9ea <__eerd_blraw_m2560>:
    f9ea:	fc 01       	movw	r30, r24
    f9ec:	f9 99       	sbic	0x1f, 1	; 31
    f9ee:	fe cf       	rjmp	.-4      	; 0xf9ec <__eerd_blraw_m2560+0x2>
    f9f0:	06 c0       	rjmp	.+12     	; 0xf9fe <__eerd_blraw_m2560+0x14>
    f9f2:	f2 bd       	out	0x22, r31	; 34
    f9f4:	e1 bd       	out	0x21, r30	; 33
    f9f6:	f8 9a       	sbi	0x1f, 0	; 31
    f9f8:	31 96       	adiw	r30, 0x01	; 1
    f9fa:	00 b4       	in	r0, 0x20	; 32
    f9fc:	0d 92       	st	X+, r0
    f9fe:	41 50       	subi	r20, 0x01	; 1
    fa00:	50 40       	sbci	r21, 0x00	; 0
    fa02:	b8 f7       	brcc	.-18     	; 0xf9f2 <__eerd_blraw_m2560+0x8>
    fa04:	08 95       	ret

0000fa06 <__eerd_byte_m2560>:
    fa06:	f9 99       	sbic	0x1f, 1	; 31
    fa08:	fe cf       	rjmp	.-4      	; 0xfa06 <__eerd_byte_m2560>
    fa0a:	92 bd       	out	0x22, r25	; 34
    fa0c:	81 bd       	out	0x21, r24	; 33
    fa0e:	f8 9a       	sbi	0x1f, 0	; 31
    fa10:	99 27       	eor	r25, r25
    fa12:	80 b5       	in	r24, 0x20	; 32
    fa14:	08 95       	ret

0000fa16 <__eerd_dword_m2560>:
    fa16:	a6 e1       	ldi	r26, 0x16	; 22
    fa18:	b0 e0       	ldi	r27, 0x00	; 0
    fa1a:	44 e0       	ldi	r20, 0x04	; 4
    fa1c:	50 e0       	ldi	r21, 0x00	; 0
    fa1e:	0c 94 f5 7c 	jmp	0xf9ea	; 0xf9ea <__eerd_blraw_m2560>

0000fa22 <__eerd_word_m2560>:
    fa22:	a8 e1       	ldi	r26, 0x18	; 24
    fa24:	b0 e0       	ldi	r27, 0x00	; 0
    fa26:	42 e0       	ldi	r20, 0x02	; 2
    fa28:	50 e0       	ldi	r21, 0x00	; 0
    fa2a:	0c 94 f5 7c 	jmp	0xf9ea	; 0xf9ea <__eerd_blraw_m2560>

0000fa2e <__eewr_block_m2560>:
    fa2e:	dc 01       	movw	r26, r24
    fa30:	cb 01       	movw	r24, r22
    fa32:	03 c0       	rjmp	.+6      	; 0xfa3a <__eewr_block_m2560+0xc>
    fa34:	2d 91       	ld	r18, X+
    fa36:	0e 94 22 7d 	call	0xfa44	; 0xfa44 <__eewr_r18_m2560>
    fa3a:	41 50       	subi	r20, 0x01	; 1
    fa3c:	50 40       	sbci	r21, 0x00	; 0
    fa3e:	d0 f7       	brcc	.-12     	; 0xfa34 <__eewr_block_m2560+0x6>
    fa40:	08 95       	ret

0000fa42 <__eewr_byte_m2560>:
    fa42:	26 2f       	mov	r18, r22

0000fa44 <__eewr_r18_m2560>:
    fa44:	f9 99       	sbic	0x1f, 1	; 31
    fa46:	fe cf       	rjmp	.-4      	; 0xfa44 <__eewr_r18_m2560>
    fa48:	1f ba       	out	0x1f, r1	; 31
    fa4a:	92 bd       	out	0x22, r25	; 34
    fa4c:	81 bd       	out	0x21, r24	; 33
    fa4e:	20 bd       	out	0x20, r18	; 32
    fa50:	0f b6       	in	r0, 0x3f	; 63
    fa52:	f8 94       	cli
    fa54:	fa 9a       	sbi	0x1f, 2	; 31
    fa56:	f9 9a       	sbi	0x1f, 1	; 31
    fa58:	0f be       	out	0x3f, r0	; 63
    fa5a:	01 96       	adiw	r24, 0x01	; 1
    fa5c:	08 95       	ret

0000fa5e <__eewr_dword_m2560>:
    fa5e:	24 2f       	mov	r18, r20
    fa60:	0e 94 22 7d 	call	0xfa44	; 0xfa44 <__eewr_r18_m2560>
    fa64:	25 2f       	mov	r18, r21
    fa66:	0e 94 22 7d 	call	0xfa44	; 0xfa44 <__eewr_r18_m2560>
    fa6a:	0c 94 37 7d 	jmp	0xfa6e	; 0xfa6e <__eewr_word_m2560>

0000fa6e <__eewr_word_m2560>:
    fa6e:	0e 94 21 7d 	call	0xfa42	; 0xfa42 <__eewr_byte_m2560>
    fa72:	27 2f       	mov	r18, r23
    fa74:	0c 94 22 7d 	jmp	0xfa44	; 0xfa44 <__eewr_r18_m2560>

0000fa78 <__ctype_isfalse>:
    fa78:	99 27       	eor	r25, r25
    fa7a:	88 27       	eor	r24, r24

0000fa7c <__ctype_istrue>:
    fa7c:	08 95       	ret

0000fa7e <__mulsi3>:
    fa7e:	62 9f       	mul	r22, r18
    fa80:	d0 01       	movw	r26, r0
    fa82:	73 9f       	mul	r23, r19
    fa84:	f0 01       	movw	r30, r0
    fa86:	82 9f       	mul	r24, r18
    fa88:	e0 0d       	add	r30, r0
    fa8a:	f1 1d       	adc	r31, r1
    fa8c:	64 9f       	mul	r22, r20
    fa8e:	e0 0d       	add	r30, r0
    fa90:	f1 1d       	adc	r31, r1
    fa92:	92 9f       	mul	r25, r18
    fa94:	f0 0d       	add	r31, r0
    fa96:	83 9f       	mul	r24, r19
    fa98:	f0 0d       	add	r31, r0
    fa9a:	74 9f       	mul	r23, r20
    fa9c:	f0 0d       	add	r31, r0
    fa9e:	65 9f       	mul	r22, r21
    faa0:	f0 0d       	add	r31, r0
    faa2:	99 27       	eor	r25, r25
    faa4:	72 9f       	mul	r23, r18
    faa6:	b0 0d       	add	r27, r0
    faa8:	e1 1d       	adc	r30, r1
    faaa:	f9 1f       	adc	r31, r25
    faac:	63 9f       	mul	r22, r19
    faae:	b0 0d       	add	r27, r0
    fab0:	e1 1d       	adc	r30, r1
    fab2:	f9 1f       	adc	r31, r25
    fab4:	bd 01       	movw	r22, r26
    fab6:	cf 01       	movw	r24, r30
    fab8:	11 24       	eor	r1, r1
    faba:	08 95       	ret

0000fabc <__udivmodqi4>:
    fabc:	99 1b       	sub	r25, r25
    fabe:	79 e0       	ldi	r23, 0x09	; 9
    fac0:	04 c0       	rjmp	.+8      	; 0xfaca <__udivmodqi4_ep>

0000fac2 <__udivmodqi4_loop>:
    fac2:	99 1f       	adc	r25, r25
    fac4:	96 17       	cp	r25, r22
    fac6:	08 f0       	brcs	.+2      	; 0xfaca <__udivmodqi4_ep>
    fac8:	96 1b       	sub	r25, r22

0000faca <__udivmodqi4_ep>:
    faca:	88 1f       	adc	r24, r24
    facc:	7a 95       	dec	r23
    face:	c9 f7       	brne	.-14     	; 0xfac2 <__udivmodqi4_loop>
    fad0:	80 95       	com	r24
    fad2:	08 95       	ret

0000fad4 <__udivmodhi4>:
    fad4:	aa 1b       	sub	r26, r26
    fad6:	bb 1b       	sub	r27, r27
    fad8:	51 e1       	ldi	r21, 0x11	; 17
    fada:	07 c0       	rjmp	.+14     	; 0xfaea <__udivmodhi4_ep>

0000fadc <__udivmodhi4_loop>:
    fadc:	aa 1f       	adc	r26, r26
    fade:	bb 1f       	adc	r27, r27
    fae0:	a6 17       	cp	r26, r22
    fae2:	b7 07       	cpc	r27, r23
    fae4:	10 f0       	brcs	.+4      	; 0xfaea <__udivmodhi4_ep>
    fae6:	a6 1b       	sub	r26, r22
    fae8:	b7 0b       	sbc	r27, r23

0000faea <__udivmodhi4_ep>:
    faea:	88 1f       	adc	r24, r24
    faec:	99 1f       	adc	r25, r25
    faee:	5a 95       	dec	r21
    faf0:	a9 f7       	brne	.-22     	; 0xfadc <__udivmodhi4_loop>
    faf2:	80 95       	com	r24
    faf4:	90 95       	com	r25
    faf6:	bc 01       	movw	r22, r24
    faf8:	cd 01       	movw	r24, r26
    fafa:	08 95       	ret

0000fafc <__divmodhi4>:
    fafc:	97 fb       	bst	r25, 7
    fafe:	09 2e       	mov	r0, r25
    fb00:	07 26       	eor	r0, r23
    fb02:	0a d0       	rcall	.+20     	; 0xfb18 <__divmodhi4_neg1>
    fb04:	77 fd       	sbrc	r23, 7
    fb06:	04 d0       	rcall	.+8      	; 0xfb10 <__divmodhi4_neg2>
    fb08:	e5 df       	rcall	.-54     	; 0xfad4 <__udivmodhi4>
    fb0a:	06 d0       	rcall	.+12     	; 0xfb18 <__divmodhi4_neg1>
    fb0c:	00 20       	and	r0, r0
    fb0e:	1a f4       	brpl	.+6      	; 0xfb16 <__divmodhi4_exit>

0000fb10 <__divmodhi4_neg2>:
    fb10:	70 95       	com	r23
    fb12:	61 95       	neg	r22
    fb14:	7f 4f       	sbci	r23, 0xFF	; 255

0000fb16 <__divmodhi4_exit>:
    fb16:	08 95       	ret

0000fb18 <__divmodhi4_neg1>:
    fb18:	f6 f7       	brtc	.-4      	; 0xfb16 <__divmodhi4_exit>
    fb1a:	90 95       	com	r25
    fb1c:	81 95       	neg	r24
    fb1e:	9f 4f       	sbci	r25, 0xFF	; 255
    fb20:	08 95       	ret

0000fb22 <__udivmodsi4>:
    fb22:	a1 e2       	ldi	r26, 0x21	; 33
    fb24:	1a 2e       	mov	r1, r26
    fb26:	aa 1b       	sub	r26, r26
    fb28:	bb 1b       	sub	r27, r27
    fb2a:	fd 01       	movw	r30, r26
    fb2c:	0d c0       	rjmp	.+26     	; 0xfb48 <__udivmodsi4_ep>

0000fb2e <__udivmodsi4_loop>:
    fb2e:	aa 1f       	adc	r26, r26
    fb30:	bb 1f       	adc	r27, r27
    fb32:	ee 1f       	adc	r30, r30
    fb34:	ff 1f       	adc	r31, r31
    fb36:	a2 17       	cp	r26, r18
    fb38:	b3 07       	cpc	r27, r19
    fb3a:	e4 07       	cpc	r30, r20
    fb3c:	f5 07       	cpc	r31, r21
    fb3e:	20 f0       	brcs	.+8      	; 0xfb48 <__udivmodsi4_ep>
    fb40:	a2 1b       	sub	r26, r18
    fb42:	b3 0b       	sbc	r27, r19
    fb44:	e4 0b       	sbc	r30, r20
    fb46:	f5 0b       	sbc	r31, r21

0000fb48 <__udivmodsi4_ep>:
    fb48:	66 1f       	adc	r22, r22
    fb4a:	77 1f       	adc	r23, r23
    fb4c:	88 1f       	adc	r24, r24
    fb4e:	99 1f       	adc	r25, r25
    fb50:	1a 94       	dec	r1
    fb52:	69 f7       	brne	.-38     	; 0xfb2e <__udivmodsi4_loop>
    fb54:	60 95       	com	r22
    fb56:	70 95       	com	r23
    fb58:	80 95       	com	r24
    fb5a:	90 95       	com	r25
    fb5c:	9b 01       	movw	r18, r22
    fb5e:	ac 01       	movw	r20, r24
    fb60:	bd 01       	movw	r22, r26
    fb62:	cf 01       	movw	r24, r30
    fb64:	08 95       	ret

0000fb66 <__divmodsi4>:
    fb66:	97 fb       	bst	r25, 7
    fb68:	09 2e       	mov	r0, r25
    fb6a:	05 26       	eor	r0, r21
    fb6c:	0e d0       	rcall	.+28     	; 0xfb8a <__divmodsi4_neg1>
    fb6e:	57 fd       	sbrc	r21, 7
    fb70:	04 d0       	rcall	.+8      	; 0xfb7a <__divmodsi4_neg2>
    fb72:	d7 df       	rcall	.-82     	; 0xfb22 <__udivmodsi4>
    fb74:	0a d0       	rcall	.+20     	; 0xfb8a <__divmodsi4_neg1>
    fb76:	00 1c       	adc	r0, r0
    fb78:	38 f4       	brcc	.+14     	; 0xfb88 <__divmodsi4_exit>

0000fb7a <__divmodsi4_neg2>:
    fb7a:	50 95       	com	r21
    fb7c:	40 95       	com	r20
    fb7e:	30 95       	com	r19
    fb80:	21 95       	neg	r18
    fb82:	3f 4f       	sbci	r19, 0xFF	; 255
    fb84:	4f 4f       	sbci	r20, 0xFF	; 255
    fb86:	5f 4f       	sbci	r21, 0xFF	; 255

0000fb88 <__divmodsi4_exit>:
    fb88:	08 95       	ret

0000fb8a <__divmodsi4_neg1>:
    fb8a:	f6 f7       	brtc	.-4      	; 0xfb88 <__divmodsi4_exit>
    fb8c:	90 95       	com	r25
    fb8e:	80 95       	com	r24
    fb90:	70 95       	com	r23
    fb92:	61 95       	neg	r22
    fb94:	7f 4f       	sbci	r23, 0xFF	; 255
    fb96:	8f 4f       	sbci	r24, 0xFF	; 255
    fb98:	9f 4f       	sbci	r25, 0xFF	; 255
    fb9a:	08 95       	ret

0000fb9c <_exit>:
    fb9c:	f8 94       	cli

0000fb9e <__stop_program>:
    fb9e:	ff cf       	rjmp	.-2      	; 0xfb9e <__stop_program>
