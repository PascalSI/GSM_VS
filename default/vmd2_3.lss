
vmd2_3.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000da  00800200  00011dd4  00011e88  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00011dd4  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000099a  008002da  008002da  00011f62  2**0
                  ALLOC
  3 .eeprom       000001a0  00810000  00810000  00011f62  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .debug_aranges 00000020  00000000  00000000  00012102  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 00003f96  00000000  00000000  00012122  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000107e5  00000000  00000000  000160b8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000074e  00000000  00000000  0002689d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00008f57  00000000  00000000  00026feb  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001310  00000000  00000000  0002ff44  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000465c  00000000  00000000  00031254  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00008517  00000000  00000000  000358b0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00001128  00000000  00000000  0003ddc7  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 7c 22 	jmp	0x44f8	; 0x44f8 <__ctors_end>
       4:	0c 94 9d 22 	jmp	0x453a	; 0x453a <__bad_interrupt>
       8:	0c 94 9d 22 	jmp	0x453a	; 0x453a <__bad_interrupt>
       c:	0c 94 9d 22 	jmp	0x453a	; 0x453a <__bad_interrupt>
      10:	0c 94 9d 22 	jmp	0x453a	; 0x453a <__bad_interrupt>
      14:	0c 94 9d 22 	jmp	0x453a	; 0x453a <__bad_interrupt>
      18:	0c 94 9d 22 	jmp	0x453a	; 0x453a <__bad_interrupt>
      1c:	0c 94 9d 22 	jmp	0x453a	; 0x453a <__bad_interrupt>
      20:	0c 94 9d 22 	jmp	0x453a	; 0x453a <__bad_interrupt>
      24:	0c 94 9d 22 	jmp	0x453a	; 0x453a <__bad_interrupt>
      28:	0c 94 9d 22 	jmp	0x453a	; 0x453a <__bad_interrupt>
      2c:	0c 94 9d 22 	jmp	0x453a	; 0x453a <__bad_interrupt>
      30:	0c 94 9d 22 	jmp	0x453a	; 0x453a <__bad_interrupt>
      34:	0c 94 48 32 	jmp	0x6490	; 0x6490 <__vector_13>
      38:	0c 94 9d 22 	jmp	0x453a	; 0x453a <__bad_interrupt>
      3c:	0c 94 9d 22 	jmp	0x453a	; 0x453a <__bad_interrupt>
      40:	0c 94 9d 22 	jmp	0x453a	; 0x453a <__bad_interrupt>
      44:	0c 94 ec 26 	jmp	0x4dd8	; 0x4dd8 <__vector_17>
      48:	0c 94 15 30 	jmp	0x602a	; 0x602a <__vector_18>
      4c:	0c 94 9d 22 	jmp	0x453a	; 0x453a <__bad_interrupt>
      50:	0c 94 9d 22 	jmp	0x453a	; 0x453a <__bad_interrupt>
      54:	0c 94 16 32 	jmp	0x642c	; 0x642c <__vector_21>
      58:	0c 94 9d 22 	jmp	0x453a	; 0x453a <__bad_interrupt>
      5c:	0c 94 9d 22 	jmp	0x453a	; 0x453a <__bad_interrupt>
      60:	0c 94 9d 22 	jmp	0x453a	; 0x453a <__bad_interrupt>
      64:	0c 94 85 43 	jmp	0x870a	; 0x870a <__vector_25>
      68:	0c 94 d9 43 	jmp	0x87b2	; 0x87b2 <__vector_26>
      6c:	0c 94 af 43 	jmp	0x875e	; 0x875e <__vector_27>
      70:	0c 94 9d 22 	jmp	0x453a	; 0x453a <__bad_interrupt>
      74:	0c 94 9d 22 	jmp	0x453a	; 0x453a <__bad_interrupt>
      78:	0c 94 9d 22 	jmp	0x453a	; 0x453a <__bad_interrupt>
      7c:	0c 94 9d 22 	jmp	0x453a	; 0x453a <__bad_interrupt>
      80:	0c 94 9d 22 	jmp	0x453a	; 0x453a <__bad_interrupt>
      84:	0c 94 9d 22 	jmp	0x453a	; 0x453a <__bad_interrupt>
      88:	0c 94 9d 22 	jmp	0x453a	; 0x453a <__bad_interrupt>
      8c:	0c 94 9d 22 	jmp	0x453a	; 0x453a <__bad_interrupt>
      90:	0c 94 03 44 	jmp	0x8806	; 0x8806 <__vector_36>
      94:	0c 94 57 44 	jmp	0x88ae	; 0x88ae <__vector_37>
      98:	0c 94 2d 44 	jmp	0x885a	; 0x885a <__vector_38>
      9c:	0c 94 9d 22 	jmp	0x453a	; 0x453a <__bad_interrupt>
      a0:	0c 94 9d 22 	jmp	0x453a	; 0x453a <__bad_interrupt>
      a4:	0c 94 9d 22 	jmp	0x453a	; 0x453a <__bad_interrupt>
      a8:	0c 94 7c 32 	jmp	0x64f8	; 0x64f8 <__vector_42>
      ac:	0c 94 9d 22 	jmp	0x453a	; 0x453a <__bad_interrupt>
      b0:	0c 94 9d 22 	jmp	0x453a	; 0x453a <__bad_interrupt>
      b4:	0c 94 9d 22 	jmp	0x453a	; 0x453a <__bad_interrupt>
      b8:	0c 94 9d 22 	jmp	0x453a	; 0x453a <__bad_interrupt>
      bc:	0c 94 9d 22 	jmp	0x453a	; 0x453a <__bad_interrupt>
      c0:	0c 94 9d 22 	jmp	0x453a	; 0x453a <__bad_interrupt>
      c4:	0c 94 9d 22 	jmp	0x453a	; 0x453a <__bad_interrupt>
      c8:	0c 94 9d 22 	jmp	0x453a	; 0x453a <__bad_interrupt>
      cc:	0c 94 d1 44 	jmp	0x89a2	; 0x89a2 <__vector_51>
      d0:	0c 94 81 44 	jmp	0x8902	; 0x8902 <__vector_52>
      d4:	0c 94 a9 44 	jmp	0x8952	; 0x8952 <__vector_53>
      d8:	0c 94 9d 22 	jmp	0x453a	; 0x453a <__bad_interrupt>
      dc:	0c 94 9d 22 	jmp	0x453a	; 0x453a <__bad_interrupt>
      e0:	0c 94 9d 22 	jmp	0x453a	; 0x453a <__bad_interrupt>
      e4:	31 5c       	subi	r19, 0xC1	; 193
      e6:	57 5c       	subi	r21, 0xC7	; 199
      e8:	68 5c       	subi	r22, 0xC8	; 200
      ea:	7b 5c       	subi	r23, 0xCB	; 203
      ec:	31 5c       	subi	r19, 0xC1	; 193
      ee:	57 5c       	subi	r21, 0xC7	; 199
      f0:	bb 5b       	subi	r27, 0xBB	; 187
      f2:	8f 5c       	subi	r24, 0xCF	; 207
      f4:	9f 5c       	subi	r25, 0xCF	; 207
      f6:	af 5c       	subi	r26, 0xCF	; 207
      f8:	c2 5c       	subi	r28, 0xC2	; 194
      fa:	8f 5c       	subi	r24, 0xCF	; 207
      fc:	9f 5c       	subi	r25, 0xCF	; 207
      fe:	d5 5c       	subi	r29, 0xC5	; 197
     100:	d5 5c       	subi	r29, 0xC5	; 197
     102:	bb 5b       	subi	r27, 0xBB	; 187
     104:	bb 5b       	subi	r27, 0xBB	; 187
     106:	bb 5b       	subi	r27, 0xBB	; 187
     108:	bb 5b       	subi	r27, 0xBB	; 187
     10a:	bb 5b       	subi	r27, 0xBB	; 187
     10c:	bb 5b       	subi	r27, 0xBB	; 187
     10e:	bb 5b       	subi	r27, 0xBB	; 187
     110:	bb 5b       	subi	r27, 0xBB	; 187
     112:	bb 5b       	subi	r27, 0xBB	; 187
     114:	bb 5b       	subi	r27, 0xBB	; 187
     116:	bb 5b       	subi	r27, 0xBB	; 187
     118:	bb 5b       	subi	r27, 0xBB	; 187
     11a:	bb 5b       	subi	r27, 0xBB	; 187
     11c:	bb 5b       	subi	r27, 0xBB	; 187
     11e:	e3 5c       	subi	r30, 0xC3	; 195
     120:	f1 5c       	subi	r31, 0xC1	; 193
     122:	00 5d       	subi	r16, 0xD0	; 208
     124:	11 5d       	subi	r17, 0xD1	; 209
     126:	01 60       	ori	r16, 0x01	; 1
     128:	20 60       	ori	r18, 0x00	; 0
     12a:	41 60       	ori	r20, 0x01	; 1
     12c:	64 60       	ori	r22, 0x04	; 4
     12e:	01 60       	ori	r16, 0x01	; 1
     130:	20 60       	ori	r18, 0x00	; 0
     132:	c3 5f       	subi	r28, 0xF3	; 243
     134:	89 60       	ori	r24, 0x09	; 9
     136:	a7 60       	ori	r26, 0x07	; 7
     138:	c6 60       	ori	r28, 0x06	; 6
     13a:	e8 60       	ori	r30, 0x08	; 8
     13c:	89 60       	ori	r24, 0x09	; 9
     13e:	a7 60       	ori	r26, 0x07	; 7
     140:	0b 61       	ori	r16, 0x1B	; 27
     142:	0b 61       	ori	r16, 0x1B	; 27
     144:	c3 5f       	subi	r28, 0xF3	; 243
     146:	13 61       	ori	r17, 0x13	; 19
     148:	8c 5f       	subi	r24, 0xFC	; 252
     14a:	4a 61       	ori	r20, 0x1A	; 26
     14c:	81 61       	ori	r24, 0x11	; 17
     14e:	13 61       	ori	r17, 0x13	; 19
     150:	8c 5f       	subi	r24, 0xFC	; 252
     152:	c3 5f       	subi	r28, 0xF3	; 243
     154:	c3 5f       	subi	r28, 0xF3	; 243
     156:	c3 5f       	subi	r28, 0xF3	; 243
     158:	be 61       	ori	r27, 0x1E	; 30
     15a:	e8 61       	ori	r30, 0x18	; 24
     15c:	be 61       	ori	r27, 0x1E	; 30
     15e:	e8 61       	ori	r30, 0x18	; 24
     160:	01 60       	ori	r16, 0x01	; 1
     162:	20 60       	ori	r18, 0x00	; 0
     164:	12 62       	ori	r17, 0x22	; 34
     166:	23 62       	ori	r18, 0x23	; 35
     168:	3a 62       	ori	r19, 0x2A	; 42
     16a:	df 5f       	subi	r29, 0xFF	; 255
     16c:	1a 65       	ori	r17, 0x5A	; 90
     16e:	1a 65       	ori	r17, 0x5A	; 90
     170:	d1 64       	ori	r29, 0x41	; 65
     172:	d1 64       	ori	r29, 0x41	; 65
     174:	1a 65       	ori	r17, 0x5A	; 90
     176:	1a 65       	ori	r17, 0x5A	; 90
     178:	dd 63       	ori	r29, 0x3D	; 61
     17a:	1a 65       	ori	r17, 0x5A	; 90
     17c:	1a 65       	ori	r17, 0x5A	; 90
     17e:	d1 64       	ori	r29, 0x41	; 65
     180:	d1 64       	ori	r29, 0x41	; 65
     182:	1a 65       	ori	r17, 0x5A	; 90
     184:	1a 65       	ori	r17, 0x5A	; 90
     186:	ad 64       	ori	r26, 0x4D	; 77
     188:	ad 64       	ori	r26, 0x4D	; 77
     18a:	dd 63       	ori	r29, 0x3D	; 61
     18c:	95 64       	ori	r25, 0x45	; 69
     18e:	95 64       	ori	r25, 0x45	; 69
     190:	95 64       	ori	r25, 0x45	; 69
     192:	95 64       	ori	r25, 0x45	; 69
     194:	95 64       	ori	r25, 0x45	; 69
     196:	95 64       	ori	r25, 0x45	; 69
     198:	dd 63       	ori	r29, 0x3D	; 61
     19a:	dd 63       	ori	r29, 0x3D	; 61
     19c:	dd 63       	ori	r29, 0x3D	; 61
     19e:	95 64       	ori	r25, 0x45	; 69
     1a0:	95 64       	ori	r25, 0x45	; 69
     1a2:	95 64       	ori	r25, 0x45	; 69
     1a4:	95 64       	ori	r25, 0x45	; 69
     1a6:	77 64       	ori	r23, 0x47	; 71
     1a8:	77 64       	ori	r23, 0x47	; 71
     1aa:	5a 64       	ori	r21, 0x4A	; 74
     1ac:	5a 64       	ori	r21, 0x4A	; 74
     1ae:	22 64       	ori	r18, 0x42	; 66
     1b0:	22 64       	ori	r18, 0x42	; 66
     1b2:	02 68       	ori	r16, 0x82	; 130
     1b4:	f9 67       	ori	r31, 0x79	; 121
     1b6:	f1 67       	ori	r31, 0x71	; 113
     1b8:	e6 67       	ori	r30, 0x76	; 118
     1ba:	e0 67       	ori	r30, 0x70	; 112
     1bc:	d7 67       	ori	r29, 0x77	; 119
     1be:	ce 67       	ori	r28, 0x7E	; 126
     1c0:	c8 67       	ori	r28, 0x78	; 120
     1c2:	c0 67       	ori	r28, 0x70	; 112
     1c4:	ba 67       	ori	r27, 0x7A	; 122
     1c6:	b2 67       	ori	r27, 0x72	; 114
     1c8:	ac 67       	ori	r26, 0x7C	; 124
     1ca:	a4 67       	ori	r26, 0x74	; 116
     1cc:	c8 67       	ori	r28, 0x78	; 120
     1ce:	ac 67       	ori	r26, 0x7C	; 124
     1d0:	9b 67       	ori	r25, 0x7B	; 123
     1d2:	94 67       	ori	r25, 0x74	; 116
     1d4:	8d 67       	ori	r24, 0x7D	; 125
     1d6:	86 67       	ori	r24, 0x76	; 118
     1d8:	7f 67       	ori	r23, 0x7F	; 127
     1da:	78 67       	ori	r23, 0x78	; 120
     1dc:	71 67       	ori	r23, 0x71	; 113
     1de:	94 67       	ori	r25, 0x74	; 116
     1e0:	78 67       	ori	r23, 0x78	; 120
     1e2:	68 67       	ori	r22, 0x78	; 120
     1e4:	61 67       	ori	r22, 0x71	; 113
     1e6:	53 67       	ori	r21, 0x73	; 115
     1e8:	4c 67       	ori	r20, 0x7C	; 124
     1ea:	3e 67       	ori	r19, 0x7E	; 126
     1ec:	1e 67       	ori	r17, 0x7E	; 126
     1ee:	2d 67       	ori	r18, 0x7D	; 125
     1f0:	f7 66       	ori	r31, 0x67	; 103
     1f2:	aa 66       	ori	r26, 0x6A	; 106
     1f4:	f2 66       	ori	r31, 0x62	; 98
     1f6:	e4 66       	ori	r30, 0x64	; 100
     1f8:	09 73       	andi	r16, 0x39	; 57
     1fa:	fb 72       	andi	r31, 0x2B	; 43
     1fc:	ef 72       	andi	r30, 0x2F	; 47
     1fe:	68 6d       	ori	r22, 0xD8	; 216
     200:	9b 6d       	ori	r25, 0xDB	; 219
     202:	50 73       	andi	r21, 0x30	; 48
     204:	3f 73       	andi	r19, 0x3F	; 63
     206:	e1 72       	andi	r30, 0x21	; 33
     208:	d5 72       	andi	r29, 0x25	; 37
     20a:	c7 72       	andi	r28, 0x27	; 39
     20c:	bb 72       	andi	r27, 0x2B	; 43
     20e:	ad 72       	andi	r26, 0x2D	; 45
     210:	a1 72       	andi	r26, 0x21	; 33
     212:	93 72       	andi	r25, 0x23	; 35
     214:	8b 72       	andi	r24, 0x2B	; 43
     216:	24 72       	andi	r18, 0x24	; 36
     218:	13 72       	andi	r17, 0x23	; 35
     21a:	74 71       	andi	r23, 0x14	; 20
     21c:	5b 71       	andi	r21, 0x1B	; 27
     21e:	fe 71       	andi	r31, 0x1E	; 30
     220:	8c 71       	andi	r24, 0x1C	; 28
     222:	49 71       	andi	r20, 0x19	; 25
     224:	37 71       	andi	r19, 0x17	; 23
     226:	16 71       	andi	r17, 0x16	; 22
     228:	04 71       	andi	r16, 0x14	; 20
     22a:	ec 70       	andi	r30, 0x0C	; 12
     22c:	d5 70       	andi	r29, 0x05	; 5
     22e:	b0 70       	andi	r27, 0x00	; 0
     230:	9e 70       	andi	r25, 0x0E	; 14
     232:	7a 70       	andi	r23, 0x0A	; 10
     234:	68 70       	andi	r22, 0x08	; 8
     236:	55 74       	andi	r21, 0x45	; 69
     238:	30 74       	andi	r19, 0x40	; 64
     23a:	1e 74       	andi	r17, 0x4E	; 78
     23c:	0c 74       	andi	r16, 0x4C	; 76
     23e:	eb 73       	andi	r30, 0x3B	; 59
     240:	d3 73       	andi	r29, 0x33	; 51
     242:	c1 73       	andi	r28, 0x31	; 49
     244:	b5 73       	andi	r27, 0x35	; 53
     246:	90 74       	andi	r25, 0x40	; 64
     248:	84 74       	andi	r24, 0x44	; 68
     24a:	78 74       	andi	r23, 0x48	; 72
     24c:	67 74       	andi	r22, 0x47	; 71
     24e:	94 73       	andi	r25, 0x34	; 52
     250:	83 73       	andi	r24, 0x33	; 51
     252:	6f 73       	andi	r22, 0x3F	; 63
     254:	5e 73       	andi	r21, 0x3E	; 62
     256:	0b 76       	andi	r16, 0x6B	; 107
     258:	ca 75       	andi	r28, 0x5A	; 90
     25a:	bf 75       	andi	r27, 0x5F	; 95
     25c:	ac 75       	andi	r26, 0x5C	; 92
     25e:	f1 75       	andi	r31, 0x51	; 81
     260:	e1 75       	andi	r30, 0x51	; 81
     262:	fe 75       	andi	r31, 0x5E	; 94
     264:	a7 73       	andi	r26, 0x37	; 55
     266:	f8 74       	andi	r31, 0x48	; 72
     268:	e9 74       	andi	r30, 0x49	; 73
     26a:	dd 74       	andi	r29, 0x4D	; 77
     26c:	9e 74       	andi	r25, 0x4E	; 78
     26e:	15 75       	andi	r17, 0x55	; 85
     270:	05 75       	andi	r16, 0x55	; 85
     272:	98 75       	andi	r25, 0x58	; 88
     274:	5d 70       	andi	r21, 0x0D	; 13
     276:	1d 70       	andi	r17, 0x0D	; 13
     278:	da 6f       	ori	r29, 0xFA	; 250
     27a:	cd 6f       	ori	r28, 0xFD	; 253
     27c:	ba 6f       	ori	r27, 0xFA	; 250
     27e:	46 70       	andi	r20, 0x06	; 6
     280:	2c 70       	andi	r18, 0x0C	; 12
     282:	38 70       	andi	r19, 0x08	; 8
     284:	b7 6e       	ori	r27, 0xE7	; 231
     286:	62 6f       	ori	r22, 0xF2	; 242
     288:	fc 6c       	ori	r31, 0xCC	; 204
     28a:	fc 6c       	ori	r31, 0xCC	; 204
     28c:	24 6f       	ori	r18, 0xF4	; 244
     28e:	1a 6f       	ori	r17, 0xFA	; 250
     290:	c3 6e       	ori	r28, 0xE3	; 227
     292:	95 6f       	ori	r25, 0xF5	; 245
     294:	74 6f       	ori	r23, 0xF4	; 244
     296:	a3 6f       	ori	r26, 0xF3	; 243
     298:	ab 6e       	ori	r26, 0xEB	; 235
     29a:	99 6e       	ori	r25, 0xE9	; 233
     29c:	67 6e       	ori	r22, 0xE7	; 231
     29e:	55 6e       	ori	r21, 0xE5	; 229
     2a0:	49 6e       	ori	r20, 0xE9	; 233
     2a2:	0c 6e       	ori	r16, 0xEC	; 236
     2a4:	f2 6d       	ori	r31, 0xD2	; 210
     2a6:	d4 6d       	ori	r29, 0xD4	; 212
     2a8:	c6 6d       	ori	r28, 0xD6	; 214
     2aa:	a9 6d       	ori	r26, 0xD9	; 217
     2ac:	0f 7f       	andi	r16, 0xFF	; 255
     2ae:	16 7f       	andi	r17, 0xF6	; 246
     2b0:	02 7f       	andi	r16, 0xF2	; 242
     2b2:	09 7f       	andi	r16, 0xF9	; 249
     2b4:	f8 7e       	andi	r31, 0xE8	; 232
     2b6:	fe 7e       	andi	r31, 0xEE	; 238
     2b8:	eb 7e       	andi	r30, 0xEB	; 235
     2ba:	f1 7e       	andi	r31, 0xE1	; 225
     2bc:	1d 7f       	andi	r17, 0xFD	; 253
     2be:	e7 7e       	andi	r30, 0xE7	; 231
     2c0:	cf 7e       	andi	r28, 0xEF	; 239
     2c2:	a1 7f       	andi	r26, 0xF1	; 241
     2c4:	89 7f       	andi	r24, 0xF9	; 249
     2c6:	7d 7f       	andi	r23, 0xFD	; 253
     2c8:	65 7f       	andi	r22, 0xF5	; 245
     2ca:	49 7f       	andi	r20, 0xF9	; 249
     2cc:	25 7f       	andi	r18, 0xF5	; 245

000002ce <__c.1790>:
     2ce:	6e 61 6e 00                                         nan.

000002d2 <__c.1788>:
     2d2:	69 6e 66 00                                         inf.

000002d6 <__c.2085>:
     2d6:	63 64 69 6e 6f 70 73 75 78 58 5b 65 66 67 45 46     cdinopsuxX[efgEF
     2e6:	47 00                                               G.

000002e8 <pstr_an>:
     2e8:	61 6e 00                                            an.

000002eb <pstr_nfinity>:
     2eb:	6e 66 69 6e 69 74 79 00                             nfinity.

000002f3 <pwr_m10>:
     2f3:	cd cc cc 3d 0a d7 23 3c 17 b7 d1 38 77 cc 2b 32     ...=..#<...8w.+2
     303:	95 95 e6 24 1f b1 4f 0a                             ...$..O.

0000030b <pwr_p10>:
     30b:	00 00 20 41 00 00 c8 42 00 40 1c 46 20 bc be 4c     .. A...B.@.F ..L
     31b:	ca 1b 0e 5a ae c5 9d 74                             ...Z...t

00000323 <DaysMonth>:
     323:	00 1f 1c 1f 1e 1f 1e 1f 1f 1e 1f 1e 1f              .............

00000330 <Modbus_Map>:
     330:	bc 07 20 00 46 0a 20 00 61 0b 04 00 45 08 50 00     .. .F. .a...E.P.

00000340 <BR_Tbl>:
     340:	42 03 ff a0 01 fb cf 00 7d 67 00 3f 44 00 2a 33     B.......}g.?D.*3
     350:	00 1f 22 00 1b 19 00 1b 10 00 1b                    .."........

0000035b <GSM_SIMCOM_SIM900R>:
     35b:	53 49 4d 43 4f 4d 5f 53 49 4d 39 30 30 52 00        SIMCOM_SIM900R.

0000036a <GSM_SIMCOM_SIM800>:
     36a:	53 49 4d 43 4f 4d 5f 53 49 4d 38 30 30 00           SIMCOM_SIM800.

00000378 <GSM_SIMCOM_SIM800C>:
     378:	53 49 4d 43 4f 4d 5f 53 49 4d 38 30 30 43 00        SIMCOM_SIM800C.

00000387 <URC_RDY>:
     387:	52 44 59 00                                         RDY.

0000038b <URC_CFUN>:
     38b:	2b 43 46 55 4e 3a 20 31 00                          +CFUN: 1.

00000394 <URC_CPIN_READY>:
     394:	2b 43 50 49 4e 3a 20 52 45 41 44 59 00              +CPIN: READY.

000003a1 <URC_CALL_READY>:
     3a1:	43 61 6c 6c 20 52 65 61 64 79 00                    Call Ready.

000003ac <URC_SMS_READY>:
     3ac:	53 4d 53 20 52 65 61 64 79 00                       SMS Ready.

000003b6 <URC_REMOTE_IP>:
     3b6:	52 45 4d 4f 54 45 20 49 50 00                       REMOTE IP.

000003c0 <URC_CONNECT>:
     3c0:	43 4f 4e 4e 45 43 54 00                             CONNECT.

000003c8 <URC_RECEIVE>:
     3c8:	2b 52 45 43 45 49 56 45 2c 00                       +RECEIVE,.

000003d2 <URC_CLOSED>:
     3d2:	2c 20 43 4c 4f 53 45 44 00                          , CLOSED.

000003db <URC_PDPDEACT>:
     3db:	2b 50 44 50 20 44 45 41 43 54 00                    +PDP DEACT.

000003e6 <URC_NO_CARRIER>:
     3e6:	4e 4f 20 43 41 52 52 49 45 52 00                    NO CARRIER.

000003f1 <RESP_OK>:
     3f1:	4f 4b 00                                            OK.

000003f4 <RESP_CONNECT>:
     3f4:	43 4f 4e 4e 45 43 54 00                             CONNECT.

000003fc <RESP_CONNECT_OK>:
     3fc:	78 2c 20 43 4f 4e 4e 45 43 54 20 4f 4b 00           x, CONNECT OK.

0000040a <RESP_SERVER_OK>:
     40a:	53 45 52 56 45 52 20 4f 4b 00                       SERVER OK.

00000414 <RESP_SERVER_CLOSE>:
     414:	53 45 52 56 45 52 20 43 4c 4f 53 45 00              SERVER CLOSE.

00000421 <RESP_Invitation>:
     421:	3e 00                                               >.

00000423 <RESP_SEND_OK>:
     423:	78 2c 20 53 45 4e 44 20 4f 4b 00                    x, SEND OK.

0000042e <RESP_CLOSE_OK>:
     42e:	43 4c 4f 53 45 20 4f 4b 00                          CLOSE OK.

00000437 <RESP_CLOSE_OK_FAST>:
     437:	78 2c 20 43 4c 4f 53 45 20 4f 4b 00                 x, CLOSE OK.

00000443 <RESP_CSQ>:
     443:	2b 43 53 51 3a 00                                   +CSQ:.

00000449 <RESP_SHUT_OK>:
     449:	53 48 55 54 20 4f 4b 00                             SHUT OK.

00000451 <RESP_CREC_0>:
     451:	2b 43 52 45 43 3a 20 30 00                          +CREC: 0.

0000045a <ESC_SEQ>:
     45a:	2b 2b 2b 00                                         +++.

0000045e <IDENTIFICATION>:
     45e:	49 44 45 4e 54 49 46 49 43 41 54 49 4f 4e 00        IDENTIFICATION.

0000046d <AT_AT>:
     46d:	41 54 00                                            AT.

00000470 <AT_IPR9600>:
     470:	41 54 2b 49 50 52 3d 39 36 30 30 00                 AT+IPR=9600.

0000047c <AT_W>:
     47c:	41 54 26 57 00                                      AT&W.

00000481 <AT_E0>:
     481:	41 54 45 30 00                                      ATE0.

00000486 <AT_CLCC1>:
     486:	41 54 2b 43 4c 43 43 3d 31 00                       AT+CLCC=1.

00000490 <AT_DDET101>:
     490:	41 54 2b 44 44 45 54 3d 31 2c 30 2c 31 00           AT+DDET=1,0,1.

0000049e <AT_CGMM>:
     49e:	41 54 2b 43 47 4d 4d 00                             AT+CGMM.

000004a6 <AT_CCID>:
     4a6:	41 54 2b 43 43 49 44 00                             AT+CCID.

000004ae <AT_IFC>:
     4ae:	41 54 2b 49 46 43 3d 32 2c 32 00                    AT+IFC=2,2.

000004b9 <ATD101>:
     4b9:	41 54 44 2a 31 30 31 23 00                          ATD*101#.

000004c2 <ATD_PLUS>:
     4c2:	41 54 44 2b 00                                      ATD+.

000004c7 <AT_CUSD101>:
     4c7:	41 54 2b 43 55 53 44 3d 31 2c 22 00                 AT+CUSD=1,".

000004d3 <AT_CMGF>:
     4d3:	41 54 2b 43 4d 47 46 3d 31 00                       AT+CMGF=1.

000004dd <AT_CSMP>:
     4dd:	41 54 2b 43 53 4d 50 3d 31 37 2c 31 36 37 2c 30     AT+CSMP=17,167,0
     4ed:	2c 30 00                                            ,0.

000004f0 <AT_CMGS>:
     4f0:	41 54 2b 43 4d 47 53 3d 22 2b 00                    AT+CMGS="+.

000004fb <AT_CIPMODE_0>:
     4fb:	41 54 2b 43 49 50 4d 4f 44 45 3d 30 00              AT+CIPMODE=0.

00000508 <AT_CIPMODE_1>:
     508:	41 54 2b 43 49 50 4d 4f 44 45 3d 31 00              AT+CIPMODE=1.

00000515 <AT_CIPMUX_0>:
     515:	41 54 2b 43 49 50 4d 55 58 3d 30 00                 AT+CIPMUX=0.

00000521 <AT_CIPMUX_1>:
     521:	41 54 2b 43 49 50 4d 55 58 3d 31 00                 AT+CIPMUX=1.

0000052d <AT_CGATT>:
     52d:	41 54 2b 43 47 41 54 54 3d 31 00                    AT+CGATT=1.

00000538 <AT_CIPCSGP>:
     538:	41 54 2b 43 49 50 43 53 47 50 3d 31 2c 22 00        AT+CIPCSGP=1,".

00000547 <AT_CSTT>:
     547:	41 54 2b 43 53 54 54 00                             AT+CSTT.

0000054f <AT_CIICR>:
     54f:	41 54 2b 43 49 49 43 52 00                          AT+CIICR.

00000558 <AT_CIFSR>:
     558:	41 54 2b 43 49 46 53 52 00                          AT+CIFSR.

00000561 <AT_CIPTKA>:
     561:	41 54 2b 43 49 50 54 4b 41 3d 31 2c 33 30 2c 33     AT+CIPTKA=1,30,3
     571:	30 2c 31 00                                         0,1.

00000575 <AT_CIPSTART>:
     575:	41 54 2b 43 49 50 53 54 41 52 54 3d 22 55 44 50     AT+CIPSTART="UDP
     585:	22 2c 00                                            ",.

00000588 <AT_CIPSTART_TCP_CLIENT>:
     588:	41 54 2b 43 49 50 53 54 41 52 54 3d 22 54 43 50     AT+CIPSTART="TCP
     598:	22 2c 00                                            ",.

0000059b <AT_CIPSERVER>:
     59b:	41 54 2b 43 49 50 53 45 52 56 45 52 3d 31 2c 00     AT+CIPSERVER=1,.

000005ab <AT_SERVERCLOSE>:
     5ab:	41 54 2b 43 49 50 53 45 52 56 45 52 3d 30 00        AT+CIPSERVER=0.

000005ba <AT_CIPSEND>:
     5ba:	41 54 2b 43 49 50 53 45 4e 44 3d 00                 AT+CIPSEND=.

000005c6 <AT_CIPCLOSE_1>:
     5c6:	41 54 2b 43 49 50 43 4c 4f 53 45 3d 78 2c 31 00     AT+CIPCLOSE=x,1.

000005d6 <AT_CIPCLOSE>:
     5d6:	41 54 2b 43 49 50 43 4c 4f 53 45 3d 31 00           AT+CIPCLOSE=1.

000005e4 <AT_CIPSHUT>:
     5e4:	41 54 2b 43 49 50 53 48 55 54 00                    AT+CIPSHUT.

000005ef <AT_CGATT_0>:
     5ef:	41 54 2b 43 47 41 54 54 3d 30 00                    AT+CGATT=0.

000005fa <AT_CSQ>:
     5fa:	41 54 2b 43 53 51 00                                AT+CSQ.

00000601 <ATO>:
     601:	41 54 4f 00                                         ATO.

00000605 <Symbols_P>:
     605:	30 31 32 33 34 35 36 37 38 39 61 62 63 64 65 66     0123456789abcdef
     615:	67 68 69 6a 6b 6c 6d 6e 6f 70 71 72 73 74 75 76     ghijklmnopqrstuv
     625:	77 78 79 7a 41 42 43 44 45 46 47 48 49 4a 4b 4c     wxyzABCDEFGHIJKL
     635:	4d 4e 4f 50 51 52 53 54 55 56 57 58 59 5a e0 e1     MNOPQRSTUVWXYZ..
     645:	e2 e3 e4 e5 b8 ba e6 e7 e8 b3 bf e9 ea eb ec ed     ................
     655:	ee ef f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 fa fb fc fd     ................
     665:	fe ff c0 c1 c2 c3 c4 c5 a8 aa c6 c7 c8 b2 af c9     ................
     675:	ca cb cc cd ce cf d0 d1 d2 d3 d4 d5 d6 d7 d8 d9     ................
     685:	da db dc dd de df 20 2b 2d 3d 3c 3e 24 25 26 2e     ...... +-=<>$%&.
     695:	2c 3f 21 27 40 3a 28 29 22 7c 2a 23 2f 00           ,?!'@:()"|*#/.

000006a3 <OnlyDigits_P>:
     6a3:	30 31 32 33 34 35 36 37 38 39 00                    0123456789.

000006ae <Digits_P>:
     6ae:	30 31 32 33 34 35 36 37 38 39 65 2b 2d 2e 00        0123456789e+-..

000006bd <ThermFami>:
     6bd:	00 00 00 00 00 00                                   ......

000006c3 <TermisLim>:
     6c3:	00 00 00 00 0c fe 08 07 0c fe 08 07 0c fe 70 17     ..............p.
     6d3:	0c fe 70 17 0c fe 70 17 0c fe 70 17 0c fe 08 07     ..p...p...p.....

000006e3 <TermocLim>:
     6e3:	00 00 00 00 30 f8 e0 2e 70 17 50 46 30 f8 4c 1d     ....0...p.PF0.L.
     6f3:	30 f8 70 17                                         0.p.

000006f7 <Fail_Str>:
     6f7:	d1 e1 ee e9 20 00                                   .... .

000006fd <Norm_Str>:
     6fd:	cd ee f0 ec e0 00                                   ......

00000703 <DI_NO_Str>:
     703:	ed e5 f2 20 00                                      ... .

00000708 <DI_OK_Str>:
     708:	ed ee f0 ec 00                                      .....

0000070d <DI_Sta_Tbl>:
     70d:	03 07 08 07                                         ....

00000711 <DI_Op_Str>:
     711:	f0 e0 e7 ec 00                                      .....

00000716 <DI_Cl_Str>:
     716:	e7 e0 ec ea 00                                      .....

0000071b <DI_Tbl>:
     71b:	11 07 16 07                                         ....

0000071f <DI_Inv_Cl_Str>:
     71f:	ed 2e e7 2e 00                                      .....

00000724 <DI_Inv_Op_Str>:
     724:	ed 2e f0 2e 00                                      .....

00000729 <DI_Inv_Tbl>:
     729:	1f 07 24 07                                         ..$.

0000072d <DO_Op_Str>:
     72d:	e2 fb ea eb 00                                      .....

00000732 <DO_Cl_Str>:
     732:	e2 ea eb 20 00                                      ... .

00000737 <DO_Tbl>:
     737:	2d 07 32 07                                         -.2.

0000073b <F_ADC_3>:
     73b:	07 b4 07 00 00 00                                   ......

00000741 <F_ADC_4>:
     741:	07 2b 09 00 00 00                                   .+....

00000747 <F_ADC_5>:
     747:	07 f8 06 00 00 00                                   ......

0000074d <List_ADC_Err>:
     74d:	20 2d 2d 2d 20 41 44 43 20 65 72 72 6f 72 73 20      --- ADC errors 
     75d:	2d 2d 2d 20 00 00 00 00 00 00 00 20 52 65 61 64     --- ....... Read
     76d:	20 66 61 69 6c 3a 20 20 20 20 7b 7b 7b 7b 7b 00      fail:    {{{{{.
     77d:	3b 07 00 00 00 00 20 43 61 6c 69 62 72 20 66 61     ;..... Calibr fa
     78d:	69 6c 3a 20 20 7b 7b 7b 7b 7b 00 41 07 00 00 00     il:  {{{{{.A....
     79d:	00 20 43 61 6c 69 62 72 20 62 72 65 61 6b 3a 20     . Calibr break: 
     7ad:	7b 7b 7b 7b 7b 00 47 07 00 00 00 00                 {{{{{.G.....

000007b9 <Menu_ADC_Err>:
     7b9:	4d 07 04 03 00 00 00 00 00 00 00 00 00 00 00 00     M...............
     7c9:	00 00 00 00                                         ....

000007cd <F_ADC_1>:
     7cd:	1d 6a 0b 47 24 00                                   .j.G$.

000007d3 <F_ADC_2>:
     7d3:	00 b3 06 00 00 00 00 12 09 00 00 00                 ............

000007df <List_ADC>:
     7df:	20 d0 e5 e6 e8 ec 3a 20 7b 7b 7b 7b 7b 7b 7b 7b      .....: {{{{{{{{
     7ef:	7b 7b 7b 7b 00 cd 07 00 00 00 00 20 c2 f0 e5 ec     {{{{....... ....
     7ff:	ff 3a 7b 7b 30 ec f1 20 ca e0 ed e0 eb 3a 7b 00     .:{{0.. .....:{.
     80f:	d3 07 00 00 00 00 20 2d 20 ca e0 ed e0 eb fb 20     ...... - ...... 
     81f:	2d 20 20 20 20 20 20 20 20 20 00 00 00 00 00 68     -         .....h
     82f:	23 20 2d 20 ca e0 eb e8 e1 f0 ee e2 ea e0 20 2d     # - .......... -
     83f:	20 20 20 20 20 00 00 00 00 00 0c 24 20 2d 20 ce          ......$ - .
     84f:	f8 e8 e1 ea e8 20 2d 20 20 20 20 20 20 20 20 20     ..... -         
     85f:	00 00 00 00 00 b9 07                                .......

00000866 <MenuADC>:
     866:	df 07 05 02 00 00 00 00 00 00 00 00 00 00 00 00     ................
     876:	00 00 00 00                                         ....

0000087a <MsgErr21>:
     87a:	20 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f      _______________
     88a:	5f 5f 5f 20 00 00 00 20 49 6e 74 65 72 6e 61 6c     ___ ... Internal
     89a:	20 65 72 72 6f 72 20 32 31 3a 20 00 00 00 20 20      error 21: ...  
     8aa:	20 20 20 20 41 44 43 20 6f 66 66 20 20 20 20 20         ADC off     
     8ba:	20 20 00 00 00 20 20 20 20 20 20 20 20 20 20 20       ...           
     8ca:	20 20 20 20 20 20 20 20 20 00 00 00 00 00 00 00              .......
	...

000008dc <Therm_Off_Str>:
     8dc:	20 20 20 78 20 20 20 00                                x   .

000008e4 <ADC_Off_Str>:
     8e4:	2d 2d 2d 2d 2d 2d 2d 00                             -------.

000008ec <ThermTbl>:
     8ec:	dc 08 e4 08                                         ....

000008f0 <ThermOff_Str>:
     8f0:	ce f2 ea eb 2e 00                                   ......

000008f6 <TSM100_Str>:
     8f6:	d2 d1 cc 31 30 30 00                                ...100.

000008fd <TSM50_Str>:
     8fd:	d2 d1 cc 35 30 00                                   ...50.

00000903 <TSP100_Str>:
     903:	d2 d1 cf 31 30 30 00                                ...100.

0000090a <TSP50_Str>:
     90a:	d2 d1 cf 35 30 00                                   ...50.

00000910 <Pt100_Str>:
     910:	50 74 31 30 30 00                                   Pt100.

00000916 <Gr21_Str>:
     916:	c3 f0 32 31 00                                      ..21.

0000091b <Gr23_Str>:
     91b:	c3 f0 32 33 00                                      ..23.

00000920 <RTD_Name_List>:
     920:	f0 08 f6 08 fd 08 03 09 0a 09 10 09 16 09 1b 09     ................

00000930 <TC_K_Str>:
     930:	54 58 41 00                                         TXA.

00000934 <TC_B_Str>:
     934:	54 cf d0 00                                         T...

00000938 <TC_J_Str>:
     938:	54 c6 ca 00                                         T...

0000093c <TC_L_Str>:
     93c:	54 58 ca 00                                         TX..

00000940 <TC_Name_List>:
     940:	f0 08 30 09 34 09 38 09 3c 09                       ..0.4.8.<.

0000094a <NoPariStr>:
     94a:	ed e5 f2 00                                         ....

0000094e <EvenPariStr>:
     94e:	f7 e5 f2 ed fb e9 00                                .......

00000955 <OddPariStr>:
     955:	ed e5 f7 e5 f2 ed fb e9 00                          .........

0000095e <MBPariTbl>:
     95e:	4a 09 4e 09 55 09                                   J.N.U.

00000964 <BR_Str1200>:
     964:	31 32 30 30 00                                      1200.

00000969 <BR_Str2400>:
     969:	32 34 30 30 00                                      2400.

0000096e <BR_Str4800>:
     96e:	34 38 30 30 00                                      4800.

00000973 <BR_Str9600>:
     973:	39 36 30 30 00                                      9600.

00000978 <BR_Str14400>:
     978:	31 34 34 30 30 00                                   14400.

0000097e <BR_Str19200>:
     97e:	31 39 32 30 30 00                                   19200.

00000984 <BR_Str28800>:
     984:	32 38 38 30 30 00                                   28800.

0000098a <BR_Str38400>:
     98a:	33 38 34 30 30 00                                   38400.

00000990 <BR_Str57600>:
     990:	35 37 36 30 30 00                                   57600.

00000996 <BaudTbl>:
     996:	64 09 69 09 6e 09 73 09 78 09 7e 09 84 09 8a 09     d.i.n.s.x.~.....
     9a6:	90 09                                               ..

000009a8 <F_MB0_Pari>:
     9a8:	1e 04 00 00 00 00 00 02 00 00 00 e2 7c 5e 09 00     ............|^..

000009b8 <F_MB0_Stopbits>:
     9b8:	01 05 00 01 00 00 00 02 00 00 00 e2 7c 00 00 00     ............|...

000009c8 <F_MB0_Baud>:
     9c8:	1e 06 00 00 00 00 00 08 00 00 00 6b 7c 96 09 00     ...........k|...

000009d8 <MB0_CPT_04>:
     9d8:	0b 36 09 00 00 00 0b 3e 09 00 00 00                 .6.....>....

000009e4 <MB0_CPT_15>:
     9e4:	0b 38 09 00 00 00 0b 40 09 00 00 00                 .8.....@....

000009f0 <MB0_CPT_26>:
     9f0:	0b 3a 09 00 00 00 0b 42 09 00 00 00                 .:.....B....

000009fc <MB0_CPT_37>:
     9fc:	0b 3c 09 00 00 00 0b 44 09 00 00 00                 .<.....D....

00000a08 <List_MB0_CPT>:
     a08:	43 50 31 3a 7b 7b 7b 7b 7b 20 20 43 50 35 3a 7b     CP1:{{{{{  CP5:{
     a18:	7b 7b 7b 7b 00 d8 09 00 00 00 00 43 50 32 3a 7b     {{{{.......CP2:{
     a28:	7b 7b 7b 7b 20 20 43 50 36 3a 7b 7b 7b 7b 7b 00     {{{{  CP6:{{{{{.
     a38:	e4 09 00 00 00 00 43 50 33 3a 7b 7b 7b 7b 7b 20     ......CP3:{{{{{ 
     a48:	20 43 50 37 3a 7b 7b 7b 7b 7b 00 f0 09 00 00 00      CP7:{{{{{......
     a58:	00 43 50 34 3a 7b 7b 7b 7b 7b 20 20 43 50 38 3a     .CP4:{{{{{  CP8:
     a68:	7b 7b 7b 7b 7b 00 fc 09 00 00 00 00                 {{{{{.......

00000a74 <M_MB0_CPT>:
     a74:	08 0a 04 03 00 00 00 00 00 00 00 00 82 49 00 00     .............I..
     a84:	00 00 00 00                                         ....

00000a88 <L_MB0>:
     a88:	20 2d 2d 2d 2d 20 4d 6f 64 62 75 73 20 30 20 2d      ---- Modbus 0 -
     a98:	2d 2d 2d 20 00 00 00 00 00 00 00 20 d1 f7 e5 f2     --- ....... ....
     aa8:	f7 e8 ea e8 20 28 f1 e1 f0 ee f1 3a 2d 3e 29 00     .... (.....:->).
     ab8:	00 00 00 00 74 0a 20 cf e0 f0 e8 f2 e5 f2 3a 20     ....t. .......: 
     ac8:	7d 7d 7d 7d 7d 7d 7d 7d 20 20 00 00 00 a8 09 00     }}}}}}}}  ......
     ad8:	00 20 d1 f2 ee ef 2d e1 e8 f2 fb 3a 20 7d 20 20     . ....-....: }  
     ae8:	20 20 20 20 20 00 00 00 b8 09 00 00 20 42 41 55          ....... BAU
     af8:	44 3a 20 7d 7d 7d 7d 7d 62 70 73 20 20 20 20 20     D: }}}}}bps     
     b08:	00 00 00 c8 09 00 00                                .......

00000b0f <MenuModbus0>:
     b0f:	88 0a 05 01 00 00 00 00 00 00 00 00 00 00 00 00     ................
     b1f:	00 00 00 00                                         ....

00000b23 <List_Modbus>:
     b23:	20 4d 6f 64 62 75 73 20 30 20 20 20 20 20 20 20      Modbus 0       
     b33:	20 20 20 20 00 00 00 00 00 0f 0b 20 20 20 20 58         .......    X
     b43:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 00                    .
     b53:	00 00 00 00 00 00 20 20 20 20 58 20 20 20 20 20     ......    X     
     b63:	20 20 20 20 20 20 20 20 20 20 00 00 00 00 00 00               ......
     b73:	00 20 20 20 20 58 20 20 20 20 20 20 20 20 20 20     .    X          
     b83:	20 20 20 20 20 00 00 00 00 00 00 00                      .......

00000b8f <MenuModbus>:
     b8f:	23 0b 04 00 00 00 00 00 00 00 00 00 00 00 00 00     #...............
     b9f:	00 00 00 00                                         ....

00000ba3 <N_Str>:
     ba3:	cd e5 f2 00                                         ....

00000ba7 <Y_Str>:
     ba7:	c4 e0 00                                            ...

00000baa <YN_Tbl>:
     baa:	a3 0b a7 0b                                         ....

00000bae <F_SummerTime>:
     bae:	1e 03 00 00 00 00 00 01 00 00 00 00 00 aa 0b 00     ................

00000bbe <F_WDay>:
     bbe:	00 57 06 00 00 00                                   .W....

00000bc4 <F_DateTime>:
     bc4:	04 5f 0b 01 00 00 00 1f 00 00 00 54 2d 00 00 00     ._.........T-...
     bd4:	04 cc 07 01 00 00 00 0c 00 00 00 5e 2d 00 00 00     ...........^-...
     be4:	04 de 05 00 00 00 00 63 00 00 00 68 2d 00 00 00     .......c...h-...
     bf4:	04 c1 05 00 00 00 00 17 00 00 00 4a 2d 00 00 00     ...........J-...
     c04:	04 51 06 00 00 00 00 3b 00 00 00 40 2d 00 00 00     .Q.....;...@-...
     c14:	04 f7 06 00 00 00 00 3b 00 00 00 36 2d 00 00 00     .......;...6-...

00000c24 <GSM_CNTL_AUTO_Str>:
     c24:	61 75 74 6f 20 20 00                                auto  .

00000c2b <GSM_CNTL_MANUAL_Str>:
     c2b:	6d 61 6e 75 61 6c 00                                manual.

00000c32 <GSM_CNTL_CONFIG_Str>:
     c32:	63 6f 6e 66 69 67 00                                config.

00000c39 <GSM_ControlList>:
     c39:	24 0c 2b 0c 32 0c                                   $.+.2.

00000c3f <GSM_Not_Recognize_Str>:
     c3f:	6e 6f 74 20 72 65 63 6f 67 00                       not recog.

00000c49 <GSM_SIMCOM_SIM900R_Str>:
     c49:	53 49 4d 39 30 30 52 20 20 00                       SIM900R  .

00000c53 <GSM_SIMCOM_SIM800_Str>:
     c53:	53 49 4d 38 30 30 20 20 20 00                       SIM800   .

00000c5d <GSM_ModemList>:
     c5d:	3f 0c 49 0c 53 0c                                   ?.I.S.

00000c63 <MenuGSM_Modem_State>:
     c63:	1d 34 07 5d 0c 00 00 f6 06 00 00 00                 .4.]........

00000c6f <MenuGSM_State>:
     c6f:	00 f6 06 00 00 00                                   ......

00000c75 <MenuGSM_GSM_Cont>:
     c75:	1d d1 07 00 00 00 00 02 00 00 00 91 49 39 0c 00     ............I9..

00000c85 <MenuGSM_GSM_MyIP>:
     c85:	00 31 09 00 00 00 00 32 09 00 00 00 00 33 09 00     .1.....2.....3..
     c95:	00 00 00 34 09 00 00 00                             ...4....

00000c9d <MenuGSM_ClientIP>:
     c9d:	00 4a 0b 00 00 00 00 4b 0b 00 00 00 00 4c 0b 00     .J.....K.....L..
     cad:	00 00 00 4d 0b 00 00 00                             ...M....

00000cb5 <MenuGSM_ActiveCon>:
     cb5:	00 d3 02 00 00 00                                   ......

00000cbb <MenuGSM_FIFOMax>:
     cbb:	00 19 09 00 00 00                                   ......

00000cc1 <MenuGSM_APN1>:
     cc1:	22 09 00 00 00 00 00 06 00 00 00 00 00 00 00 00     "...............

00000cd1 <MenuGSM_APN2>:
     cd1:	22 1d 00 00 00 00 00 06 00 00 00 00 00 00 00 00     "...............

00000ce1 <MenuGSM_APN_USER_NAME>:
     ce1:	22 59 00 00 00 00 00 06 00 00 00 00 00 00 00 00     "Y..............

00000cf1 <MenuGSM_APN_PASSWORD>:
     cf1:	22 6d 00 00 00 00 00 06 00 00 00 00 00 00 00 00     "m..............

00000d01 <MenuGSM_IPUDP1>:
     d01:	01 81 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     d11:	01 82 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     d21:	01 83 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     d31:	01 84 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00000d41 <MenuGSM_IPUDP2>:
     d41:	01 85 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     d51:	01 86 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     d61:	01 87 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     d71:	01 88 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00000d81 <MenuGSM_IPUDP3>:
     d81:	01 89 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     d91:	01 8a 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     da1:	01 8b 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     db1:	01 8c 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00000dc1 <MenuGSM_IPUDP4>:
     dc1:	01 8d 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     dd1:	01 8e 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     de1:	01 8f 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     df1:	01 90 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00000e01 <MenuGSM_PortUDP1>:
     e01:	08 a1 00 00 00 00 00 ff ff 00 00 00 00 00 00 00     ................

00000e11 <MenuGSM_PortUDP2>:
     e11:	08 a3 00 00 00 00 00 ff ff 00 00 00 00 00 00 00     ................

00000e21 <MenuGSM_PortUDP3>:
     e21:	08 a5 00 00 00 00 00 ff ff 00 00 00 00 00 00 00     ................

00000e31 <MenuGSM_PortUDP4>:
     e31:	08 a7 00 00 00 00 00 ff ff 00 00 00 00 00 00 00     ................

00000e41 <MenuGSM_IPTCP1>:
     e41:	01 b3 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     e51:	01 b4 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     e61:	01 b5 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     e71:	01 b6 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00000e81 <MenuGSM_IPTCP2>:
     e81:	01 b7 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     e91:	01 b8 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     ea1:	01 b9 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     eb1:	01 ba 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00000ec1 <MenuGSM_IPTCP3>:
     ec1:	01 bb 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     ed1:	01 bc 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     ee1:	01 bd 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     ef1:	01 be 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00000f01 <MenuGSM_IPTCP4>:
     f01:	01 bf 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     f11:	01 c0 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     f21:	01 c1 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     f31:	01 c2 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00000f41 <MenuGSM_TCPPort>:
     f41:	08 b1 00 00 00 00 00 ff ff 00 00 00 00 00 00 00     ................

00000f51 <MenuGSM_TCPTimeout>:
     f51:	08 c3 00 64 00 00 00 ff ff 00 00 00 00 00 00 02     ...d............

00000f61 <MenuGSM_SMS>:
     f61:	01 13 01 00 00 00 00 01 00 00 00 00 00 00 00 00     ................

00000f71 <MenuGSM_VegaSN>:
     f71:	08 07 00 00 00 00 00 ff ff 00 00 00 00 00 00 00     ................

00000f81 <ListGSM>:
     f81:	20 cc ee e4 e5 ec 20 7b 7b 7b 7b 7b 7b 7b 7b 7b      ..... {{{{{{{{{
     f91:	20 7b 7b 7b 00 63 0c 00 00 00 00 20 43 6f 6e 74      {{{.c..... Cont
     fa1:	72 6f 6c 20 6d 6f 64 65 3a 7d 7d 7d 7d 7d 7d 00     rol mode:}}}}}}.
     fb1:	00 00 75 0c 00 00 20 4d 79 49 50 7b 7b 7b 2e 7b     ..u... MyIP{{{.{
     fc1:	7b 7b 2e 7b 7b 7b 2e 7b 7b 7b 00 85 0c 00 00 00     {{.{{{.{{{......
     fd1:	00 20 43 6c 49 50 7b 7b 7b 2e 7b 7b 7b 2e 7b 7b     . ClIP{{{.{{{.{{
     fe1:	7b 2e 7b 7b 7b 00 9d 0c 00 00 00 00 20 41 63 74     {.{{{....... Act
     ff1:	69 76 65 20 63 6f 6e 65 63 74 69 6f 6e 7b 7b 7b     ive conection{{{
    1001:	00 b5 0c 00 00 00 00 20 46 49 46 4f 3a 6d 61 78     ....... FIFO:max
    1011:	20 7b 7b 2f 37 30 62 79 74 65 20 00 bb 0c 00 00      {{/70byte .....
    1021:	00 00 20 2d 2d 2d 2d 2d 2d 2d 41 50 4e 2d 2d 2d     .. -------APN---
    1031:	2d 2d 2d 2d 2d 2d 00 00 00 00 00 00 00 20 7d 7d     ------....... }}
    1041:	7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d     }}}}}}}}}}}}}}}}
    1051:	7d 00 00 00 c1 0c 00 00 20 7d 7d 7d 7d 7d 7d 7d     }....... }}}}}}}
    1061:	7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 00 00 00 d1     }}}}}}}}}}}}....
    1071:	0c 00 00 20 2d 2d 2d 41 50 4e 2d 55 53 45 52 20     ... ---APN-USER 
    1081:	4e 41 4d 45 2d 2d 2d 00 00 00 00 00 00 00 20 7d     NAME---....... }
    1091:	7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d     }}}}}}}}}}}}}}}}
    10a1:	7d 7d 00 00 00 e1 0c 00 00 20 2d 2d 2d 41 50 4e     }}....... ---APN
    10b1:	2d 50 41 53 53 57 4f 52 44 2d 2d 2d 2d 00 00 00     -PASSWORD----...
    10c1:	00 00 00 00 20 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d     .... }}}}}}}}}}}
    10d1:	7d 7d 7d 7d 7d 7d 7d 7d 00 00 00 f1 0c 00 00 20     }}}}}}}}....... 
    10e1:	2d 2d 53 65 6e 64 20 55 44 50 20 74 6f 20 49 50     --Send UDP to IP
    10f1:	2d 2d 2d 00 00 00 00 00 00 00 20 49 50 31 3a 7d     ---....... IP1:}
    1101:	7d 7d 2e 7d 7d 7d 2e 7d 7d 7d 2e 7d 7d 7d 00 00     }}.}}}.}}}.}}}..
    1111:	00 01 0d 00 00 20 49 50 32 3a 7d 7d 7d 2e 7d 7d     ..... IP2:}}}.}}
    1121:	7d 2e 7d 7d 7d 2e 7d 7d 7d 00 00 00 41 0d 00 00     }.}}}.}}}...A...
    1131:	20 49 50 33 3a 7d 7d 7d 2e 7d 7d 7d 2e 7d 7d 7d      IP3:}}}.}}}.}}}
    1141:	2e 7d 7d 7d 00 00 00 81 0d 00 00 20 49 50 34 3a     .}}}....... IP4:
    1151:	7d 7d 7d 2e 7d 7d 7d 2e 7d 7d 7d 2e 7d 7d 7d 00     }}}.}}}.}}}.}}}.
    1161:	00 00 c1 0d 00 00 20 2d 2d 2d 2d 20 55 44 50 20     ...... ---- UDP 
    1171:	50 6f 72 74 20 2d 2d 2d 2d 2d 00 00 00 00 00 00     Port -----......
    1181:	00 20 49 50 31 20 50 6f 72 74 3a 7d 7d 7d 7d 7d     . IP1 Port:}}}}}
    1191:	20 20 20 20 20 00 00 00 01 0e 00 00 20 49 50 32          ....... IP2
    11a1:	20 50 6f 72 74 3a 7d 7d 7d 7d 7d 20 20 20 20 20      Port:}}}}}     
    11b1:	00 00 00 11 0e 00 00 20 49 50 33 20 50 6f 72 74     ....... IP3 Port
    11c1:	3a 7d 7d 7d 7d 7d 20 20 20 20 20 00 00 00 21 0e     :}}}}}     ...!.
    11d1:	00 00 20 49 50 34 20 50 6f 72 74 3a 7d 7d 7d 7d     .. IP4 Port:}}}}
    11e1:	7d 20 20 20 20 20 00 00 00 31 0e 00 00 20 2d 20     }     ...1... - 
    11f1:	54 43 50 20 49 50 20 46 69 72 65 77 61 6c 6c 2d     TCP IP Firewall-
    1201:	2d 00 00 00 00 00 00 00 20 49 50 31 3a 7d 7d 7d     -....... IP1:}}}
    1211:	2e 7d 7d 7d 2e 7d 7d 7d 2e 7d 7d 7d 00 00 00 41     .}}}.}}}.}}}...A
    1221:	0e 00 00 20 49 50 32 3a 7d 7d 7d 2e 7d 7d 7d 2e     ... IP2:}}}.}}}.
    1231:	7d 7d 7d 2e 7d 7d 7d 00 00 00 81 0e 00 00 20 49     }}}.}}}....... I
    1241:	50 33 3a 7d 7d 7d 2e 7d 7d 7d 2e 7d 7d 7d 2e 7d     P3:}}}.}}}.}}}.}
    1251:	7d 7d 00 00 00 c1 0e 00 00 20 49 50 34 3a 7d 7d     }}....... IP4:}}
    1261:	7d 2e 7d 7d 7d 2e 7d 7d 7d 2e 7d 7d 7d 00 00 00     }.}}}.}}}.}}}...
    1271:	01 0f 00 00 20 54 43 50 53 65 72 76 65 72 50 6f     .... TCPServerPo
    1281:	72 74 3a 7d 7d 7d 7d 7d 00 00 00 41 0f 00 00 20     rt:}}}}}...A... 
    1291:	54 69 6d 65 6f 75 74 20 54 43 50 3a 7d 7d 7d 7d     Timeout TCP:}}}}
    12a1:	7d 7d 63 00 00 00 51 0f 00 00 20 2d 2d 2d 2d 2d     }}c...Q... -----
    12b1:	2d 2d 20 53 4d 53 20 2d 2d 2d 2d 2d 2d 2d 00 00     -- SMS -------..
    12c1:	00 00 00 00 00 20 d0 e0 f1 f1 fb eb ea e0 20 53     ..... ........ S
    12d1:	4d 53 3a 20 20 20 7d 7d 7d 00 00 00 61 0f 00 00     MS:   }}}...a...
    12e1:	20 2d 2d 49 64 65 6e 74 69 66 69 63 61 74 69 6f      --Identificatio
    12f1:	6e 2d 2d 2d 00 00 00 00 00 00 00 20 56 65 67 61     n---....... Vega
    1301:	20 53 2f 4e 3a 20 20 20 20 20 7d 7d 7d 7d 7d 00      S/N:     }}}}}.
    1311:	00 00 71 0f 00 00                                   ..q...

00001317 <MenuGSM>:
    1317:	81 0f 22 00 00 00 00 00 00 00 00 00 00 00 00 00     ..".............
    1327:	00 00 00 00                                         ....

0000132b <Mem_OK_Tbl>:
    132b:	fd 06 f7 06                                         ....

0000132f <F_Ok_Flash>:
    132f:	1f 17 09 2b 13 00                                   ...+..

00001335 <F_Ok_EEPROM>:
    1335:	1f 17 09 2b 13 01                                   ...+..

0000133b <Msg_EEWarning>:
    133b:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    134b:	20 20 20 20 00 00 00 20 cf e5 f0 e5 e4 20 ef f0         ... ..... ..
    135b:	ee e4 ee eb e6 e5 ed e8 e5 ec 20 00 00 00 f0 e0     .......... .....
    136b:	e1 ee f2 fb 20 ef f0 ee e2 e5 f0 fc f2 e5 20 e2     .... ......... .
    137b:	f1 e5 00 00 00 20 20 20 20 20 20 ed e0 f1 f2 f0     .....      .....
    138b:	ee e9 ea e8 20 20 20 20 20 00 00 00 00 00 00 00     ....     .......
	...

0000139d <Msg_NoBackUp>:
    139d:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    13ad:	20 20 20 20 00 00 00 d1 ee f5 f0 e0 ed b8 ed ed         ............
    13bd:	fb f5 20 ed e0 f1 f2 f0 ee e5 ea 00 00 00 20 20     .. ...........  
    13cd:	20 20 ed e5 20 ee e1 ed e0 f0 f3 e6 e5 ed ee 20       .. .......... 
    13dd:	20 20 00 00 00 20 20 20 20 20 20 20 20 20 20 20       ...           
    13ed:	20 20 20 20 20 20 20 20 20 00 00 00 00 00 00 00              .......
	...

000013ff <Menu_ConfirmationSave_List>:
    13ff:	d1 ee f5 f0 e0 ed e8 f2 fc 20 ed e0 f1 f2 f0 ee     ......... ......
    140f:	e9 ea e8 3f 00 00 00 00 00 00 00 20 20 20 c4 e0     ...?.......   ..
    141f:	20 2d 20 ea ed ee ef ea e0 20 c2 d5 ce c4 20 00      - ...... .... .
    142f:	00 00 00 00 00 00 20 20 cd e5 f2 20 2d 20 ea ed     ......  ... - ..
    143f:	ee ef ea e0 20 c2 db d5 ce c4 00 00 00 00 00 00     .... ...........
    144f:	00 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20     .               
    145f:	20 20 20 20 20 00 00 00 00 00 00 00                      .......

0000146b <Menu_ConfirmationSave>:
    146b:	ff 13 04 03 00 00 00 00 00 00 00 00 cb 4a 00 00     .............J..
    147b:	00 00 00 00                                         ....

0000147f <Menu_ConfirmationRest_List>:
    147f:	c2 ee f1 f2 e0 ed ee e2 2e 20 ed e0 f1 f2 f0 ee     ......... ......
    148f:	e9 ea e8 3f 00 00 00 00 00 00 00 20 20 20 c4 e0     ...?.......   ..
    149f:	20 2d 20 ea ed ee ef ea e0 20 c2 d5 ce c4 20 00      - ...... .... .
    14af:	00 00 00 00 00 00 20 20 cd e5 f2 20 2d 20 ea ed     ......  ... - ..
    14bf:	ee ef ea e0 20 c2 db d5 ce c4 00 00 00 00 00 00     .... ...........
    14cf:	00 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20     .               
    14df:	20 20 20 20 20 00 00 00 00 00 00 00                      .......

000014eb <Menu_ConfirmationRestore>:
    14eb:	7f 14 04 03 00 00 00 00 00 00 00 00 c0 4a 00 00     .............J..
    14fb:	00 00 00 00                                         ....

000014ff <NoBackUp_Str>:
    14ff:	2d 2d 00                                            --.

00001502 <BackUp_Tbl>:
    1502:	ff 14                                               ..

00001504 <Menu_BackUp_IField>:
    1504:	05 00 00 02 15 00 05 01 00 02 15 00 05 02 00 02     ................
    1514:	15 00                                               ..

00001516 <Menu_BackUp_List>:
    1516:	d3 f1 f2 ed 2f d0 e5 e7 e5 f0 e2 ed e0 ff 20 ea     ..../......... .
    1526:	ee ef e8 ff 00 00 00 00 00 00 00 20 d1 ee f5 f0     ........... ....
    1536:	e0 ed e8 f2 fc 20 20 20 20 20 20 20 20 20 20 00     .....          .
    1546:	00 00 00 00 6b 14 20 c2 ee f1 f2 e0 ed ee e2 3a     ....k. ........:
    1556:	7b 7b 2e 7b 7b 2e 32 30 7b 7b 00 04 15 00 00 00     {{.{{.20{{......
    1566:	00 20 d1 ee f1 f2 2e 45 45 50 52 4f 4d 3a 20 7b     . .....EEPROM: {
    1576:	7b 7b 7b 7b 20 00 35 13 00 00 00 00                 {{{{ .5.....

00001582 <Menu_BackUp>:
    1582:	16 15 04 01 00 00 00 00 00 00 00 00 f4 80 00 00     ................
    1592:	00 00 00 00                                         ....

00001596 <ListMem>:
    1596:	20 2d 2d 2d 2d 2d 20 4d 65 6d 6f 72 79 20 2d 2d      ----- Memory --
    15a6:	2d 2d 2d 20 00 00 00 00 00 00 00 20 46 6c 61 73     --- ....... Flas
    15b6:	68 3a 20 20 7b 7b 7b 7b 7b 20 20 20 20 20 20 00     h:  {{{{{      .
    15c6:	2f 13 00 00 00 00 20 45 45 50 52 4f 4d 3a 20 7b     /..... EEPROM: {
    15d6:	7b 7b 7b 7b 20 20 20 20 20 20 00 35 13 00 00 00     {{{{      .5....
    15e6:	00 20 52 65 73 65 74 20 45 45 50 52 4f 4d 20 66     . Reset EEPROM f
    15f6:	61 69 6c 20 20 00 00 00 00 00 00 00 20 42 61 63     ail  ....... Bac
    1606:	6b 55 70 20 45 45 50 52 4f 4d 20 20 20 20 20 20     kUp EEPROM      
    1616:	00 00 00 00 00 82 15                                .......

0000161d <MenuMem>:
    161d:	96 15 05 01 00 00 00 00 00 00 00 00 7e 56 00 00     ............~V..
    162d:	00 00 00 00                                         ....

00001631 <MsgErr11>:
    1631:	20 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f      _______________
    1641:	5f 5f 5f 20 00 00 00 20 49 6e 74 65 72 6e 61 6c     ___ ... Internal
    1651:	20 65 72 72 6f 72 20 31 31 3a 20 00 00 00 20 20      error 11: ...  
    1661:	20 20 20 46 6c 61 73 68 20 66 61 69 6c 20 20 20        Flash fail   
    1671:	20 20 00 00 00 20 20 20 20 20 20 20 20 20 20 20       ...           
    1681:	20 20 20 20 20 20 20 20 20 00 00 00 00 00 00 00              .......
	...

00001693 <MsgErr12>:
    1693:	20 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f      _______________
    16a3:	5f 5f 5f 20 00 00 00 20 49 6e 74 65 72 6e 61 6c     ___ ... Internal
    16b3:	20 65 72 72 6f 72 20 31 32 3a 20 00 00 00 20 20      error 12: ...  
    16c3:	20 20 45 45 50 52 4f 4d 20 66 61 69 6c 20 20 20       EEPROM fail   
    16d3:	20 20 00 00 00 20 20 20 20 20 20 20 20 20 20 20       ...           
    16e3:	20 20 20 20 20 20 20 20 20 00 00 00 00 00 00 00              .......
	...

000016f5 <MsgErr13>:
    16f5:	20 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f      _______________
    1705:	5f 5f 5f 20 00 00 00 20 49 6e 74 65 72 6e 61 6c     ___ ... Internal
    1715:	20 65 72 72 6f 72 20 31 33 3a 20 00 00 00 20 54      error 13: ... T
    1725:	6f 74 61 6c 20 6d 65 6d 6f 72 79 20 66 61 69 6c     otal memory fail
    1735:	20 20 00 00 00 20 20 20 20 20 20 20 20 20 20 20       ...           
    1745:	20 20 20 20 20 20 20 20 20 00 00 00 00 00 00 00              .......
	...

00001757 <MsgErrMemo>:
    1757:	00 00 31 16 93 16 f5 16                             ..1.....

0000175f <F_ScanCycle>:
    175f:	00 ae 07 00 00 00                                   ......

00001765 <F_ScanCyclePerSec>:
    1765:	07 ce 07 00 00 00                                   ......

0000176b <F_MaxScanCycle>:
    176b:	00 b1 06 00 00 00                                   ......

00001771 <ListScanCycle>:
    1771:	20 2d 2d 2d 20 53 63 61 6e 20 43 79 63 6c 65 20      --- Scan Cycle 
    1781:	2d 2d 2d 20 00 00 00 00 00 00 00 20 53 63 61 6e     --- ....... Scan
    1791:	43 79 63 6c 65 3a 20 20 20 7b 7b 7b 30 6d 73 00     Cycle:   {{{0ms.
    17a1:	5f 17 00 00 00 00 20 53 63 61 6e 43 79 63 6c 50     _..... ScanCyclP
    17b1:	65 72 53 65 63 3a 7b 7b 7b 7b 00 65 17 00 00 00     erSec:{{{{.e....
    17c1:	00 20 4d 61 78 53 63 61 6e 43 79 63 6c 65 3a 7b     . MaxScanCycle:{
    17d1:	7b 7b 30 6d 73 00 6b 17 00 00 00 00                 {{0ms.k.....

000017dd <MenuScanCycle>:
    17dd:	71 17 04 01 00 00 00 00 00 00 00 00 95 49 00 00     q............I..
    17ed:	00 00 00 00                                         ....

000017f1 <F_WT>:
    17f1:	0b 6b 0c 00 00 00 04 b0 06 00 00 00                 .k..........

000017fd <sec10_Str>:
    17fd:	31 30 20 f1 e5 ea 00                                10 ....

00001804 <sec30_Str>:
    1804:	33 30 20 f1 e5 ea 00                                30 ....

0000180b <min1_Str>:
    180b:	31 20 ec e8 ed 20 00                                1 ... .

00001812 <min3_Str>:
    1812:	33 20 ec e8 ed 20 00                                3 ... .

00001819 <min10_Str>:
    1819:	31 30 20 ec e8 ed 00                                10 ....

00001820 <BCKLT_Tbl>:
    1820:	fd 17 04 18 0b 18 12 18 19 18                       ..........

0000182a <F_Backlight>:
    182a:	1e 91 01 00 00 00 00 04 00 00 00 00 00 20 18 00     ............. ..

0000183a <F_IonT>:
    183a:	08 2f 01 00 00 00 00 ff 03 00 00 00 00 00 00 00     ./..............

0000184a <F_Menu_EMICounter>:
    184a:	10 3a 07 00 00 00                                   .:....

00001850 <ListSyst>:
    1850:	20 2d 20 d1 eb f3 e6 e5 e1 ed ee e5 20 ec e5 ed      - ......... ...
    1860:	fe 20 2d 20 00 00 00 00 00 00 00 20 c4 e8 f1 ea     . - ....... ....
    1870:	f0 e5 f2 ed fb e5 20 e2 f5 ee e4 fb 20 20 20 00     ...... .....   .
    1880:	00 00 00 00 6f 1e 20 c4 e8 f1 ea f0 e5 f2 ed fb     ....o. .........
    1890:	e5 20 e2 fb f5 ee e4 fb 20 20 00 00 00 00 00 33     . ......  .....3
    18a0:	21 20 c0 ed e0 eb ee e3 ee e2 fb e5 20 e2 f5 ee     ! .......... ...
    18b0:	e4 fb 20 20 20 00 00 00 00 00 e3 21 20 c0 ed e0     ..   ......! ...
    18c0:	eb ee e3 ee e2 fb e5 20 e2 fb f5 ee e4 fb 20 20     ....... ......  
    18d0:	00 00 00 00 00 a3 22 20 c0 d6 cf 20 20 20 20 20     ......" ...     
    18e0:	20 20 20 20 20 20 20 20 20 20 20 00 00 00 00 00                .....
    18f0:	66 08 20 d2 e5 f0 ec ee e4 e0 f2 f7 e8 ea e8 20     f. ............ 
    1900:	20 20 20 20 20 20 00 00 00 00 00 37 29 20 4d 6f           .....7) Mo
    1910:	64 62 75 73 20 20 20 20 20 20 20 20 20 20 20 20     dbus            
    1920:	20 00 00 00 00 00 8f 0b 20 cc ee e4 e5 ec 20 20      ....... .....  
    1930:	20 20 20 20 20 20 20 20 20 20 20 20 00 00 00 00                 ....
    1940:	00 17 13 20 7b 20 7d 7d 2e 7d 7d 2e 7d 7d 20 7d     ... { }}.}}.}} }
    1950:	7d 3a 7d 7d 3a 7d 7d 00 be 0b c4 0b 00 00 20 c0     }:}}:}}....... .
    1960:	e2 f2 ee cf e5 f0 e5 f5 cb e5 f2 ed c2 f0 3a 7d     ..............:}
    1970:	7d 7d 00 00 00 ae 0b 00 00 20 cd e0 f0 e0 e1 ee     }}....... ......
    1980:	f2 ea e0 3a 7b 7b 7b 7b 7b f7 7b 7b ec 00 f1 17     ...:{{{{{.{{....
    1990:	00 00 00 00 20 d1 ee f1 f2 ee ff ed e8 e5 20 ef     .... ......... .
    19a0:	e0 ec ff f2 e8 20 20 20 00 00 00 00 00 1d 16 20     .....   ....... 
    19b0:	53 63 61 6e 20 43 79 63 6c 65 3a 20 20 7b 7b 7b     Scan Cycle:  {{{
    19c0:	30 6d 73 00 5f 17 00 00 dd 17 20 cf ee f0 ee e3     0ms._..... .....
    19d0:	20 e8 ee ed ee e4 2e 3a 20 20 7d 7d 7d 7d 00 00      ......:  }}}}..
    19e0:	00 3a 18 00 00 20 cf ee e4 f1 e2 e5 f2 ea e0 c6     .:... ..........
    19f0:	ca c8 3a 7d 7d 7d 7d 7d 7d 00 00 00 2a 18 00 00     ..:}}}}}}...*...
    1a00:	20 d1 f7 b8 f2 2e dd cc cd 3a 7b 7b 7b 7b 7b 7b      ........:{{{{{{
    1a10:	7b 7b 7b 7b 00 4a 18 00 00 00 00                    {{{{.J.....

00001a1b <MenuSyst>:
    1a1b:	50 18 11 01 00 00 00 00 00 00 00 00 00 00 00 00     P...............
    1a2b:	00 00 00 00                                         ....

00001a2f <MsgErr41>:
    1a2f:	20 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f      _______________
    1a3f:	5f 5f 5f 20 00 00 00 20 49 6e 74 65 72 6e 61 6c     ___ ... Internal
    1a4f:	20 65 72 72 6f 72 20 34 31 3a 20 00 00 00 54 69      error 41: ...Ti
    1a5f:	6d 65 72 20 61 6c 6c 6f 63 61 74 69 6f 6e 20 65     mer allocation e
    1a6f:	72 72 00 00 00 20 20 20 20 20 20 20 20 20 20 20     rr...           
    1a7f:	20 20 20 20 20 20 20 20 20 00 00 00 00 00 00 00              .......
	...

00001a91 <F_DI1>:
    1a91:	1f 40 07 1b 07 00 1f 46 07 0d 07 00                 .@.....F....

00001a9d <F_DI2>:
    1a9d:	1f 40 07 1b 07 01 1f 46 07 0d 07 01                 .@.....F....

00001aa9 <F_DI3>:
    1aa9:	1f 40 07 1b 07 02 1f 46 07 0d 07 02                 .@.....F....

00001ab5 <F_DI4>:
    1ab5:	1f 40 07 1b 07 03 1f 46 07 0d 07 03                 .@.....F....

00001ac1 <F_DI5>:
    1ac1:	1f 40 07 1b 07 04 1f 46 07 0d 07 04                 .@.....F....

00001acd <F_DI6>:
    1acd:	1f 40 07 1b 07 05 1f 46 07 0d 07 05                 .@.....F....

00001ad9 <F_DI7>:
    1ad9:	1f 40 07 1b 07 06 1f 46 07 0d 07 06                 .@.....F....

00001ae5 <F_DI8>:
    1ae5:	1f 40 07 1b 07 07 1f 46 07 0d 07 07                 .@.....F....

00001af1 <F_DI9>:
    1af1:	1f 40 07 1b 07 08 1f 46 07 0d 07 08                 .@.....F....

00001afd <F_DI10>:
    1afd:	1f 40 07 1b 07 09 1f 46 07 0d 07 09                 .@.....F....

00001b09 <F_DI11>:
    1b09:	1f 40 07 1b 07 0a 1f 46 07 0d 07 0a                 .@.....F....

00001b15 <F_DI12>:
    1b15:	1f 40 07 1b 07 0b 1f 46 07 0d 07 0b                 .@.....F....

00001b21 <F_DI13>:
    1b21:	1f 40 07 1b 07 0c 1f 46 07 0d 07 0c                 .@.....F....

00001b2d <F_DI14>:
    1b2d:	1f 40 07 1b 07 0d 1f 46 07 0d 07 0d                 .@.....F....

00001b39 <F_DI15>:
    1b39:	1f 40 07 1b 07 0e 1f 46 07 0d 07 0e                 .@.....F....

00001b45 <F_DI16>:
    1b45:	1f 40 07 1b 07 0f 1f 46 07 0d 07 0f                 .@.....F....

00001b51 <F_DI17>:
    1b51:	1f 40 07 1b 07 10 1f 46 07 0d 07 10                 .@.....F....

00001b5d <F_DI18>:
    1b5d:	1f 40 07 1b 07 11 1f 46 07 0d 07 11                 .@.....F....

00001b69 <F_DII1>:
    1b69:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 00      ............)..

00001b79 <F_DII2>:
    1b79:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 01      ............)..

00001b89 <F_DII3>:
    1b89:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 02      ............)..

00001b99 <F_DII4>:
    1b99:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 03      ............)..

00001ba9 <F_DII5>:
    1ba9:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 04      ............)..

00001bb9 <F_DII6>:
    1bb9:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 05      ............)..

00001bc9 <F_DII7>:
    1bc9:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 06      ............)..

00001bd9 <F_DII8>:
    1bd9:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 07      ............)..

00001be9 <F_DII9>:
    1be9:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 08      ............)..

00001bf9 <F_DII10>:
    1bf9:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 09      ............)..

00001c09 <F_DII11>:
    1c09:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 0a      ............)..

00001c19 <F_DII12>:
    1c19:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 0b      ............)..

00001c29 <F_DII13>:
    1c29:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 0c      ............)..

00001c39 <F_DII14>:
    1c39:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 0d      ............)..

00001c49 <F_DII15>:
    1c49:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 0e      ............)..

00001c59 <F_DII16>:
    1c59:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 0f      ............)..

00001c69 <F_DII17>:
    1c69:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 10      ............)..

00001c79 <F_DII18>:
    1c79:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 11      ............)..

00001c89 <ListDI>:
    1c89:	20 4e 31 3a 20 20 7b 7b 7b 7b 20 7d 7d 7d 7d 20      N1:  {{{{ }}}} 
    1c99:	7b 7b 7b 7b 00 91 1a 69 1b 00 00 20 4e 32 3a 20     {{{{...i... N2: 
    1ca9:	20 7b 7b 7b 7b 20 7d 7d 7d 7d 20 7b 7b 7b 7b 00      {{{{ }}}} {{{{.
    1cb9:	9d 1a 79 1b 00 00 20 4e 33 3a 20 20 7b 7b 7b 7b     ..y... N3:  {{{{
    1cc9:	20 7d 7d 7d 7d 20 7b 7b 7b 7b 00 a9 1a 89 1b 00      }}}} {{{{......
    1cd9:	00 20 4e 34 3a 20 20 7b 7b 7b 7b 20 7d 7d 7d 7d     . N4:  {{{{ }}}}
    1ce9:	20 7b 7b 7b 7b 00 b5 1a 99 1b 00 00 20 4e 35 3a      {{{{....... N5:
    1cf9:	20 20 7b 7b 7b 7b 20 7d 7d 7d 7d 20 7b 7b 7b 7b       {{{{ }}}} {{{{
    1d09:	00 c1 1a a9 1b 00 00 20 4e 36 3a 20 20 7b 7b 7b     ....... N6:  {{{
    1d19:	7b 20 7d 7d 7d 7d 20 7b 7b 7b 7b 00 cd 1a b9 1b     { }}}} {{{{.....
    1d29:	00 00 20 4e 37 3a 20 20 7b 7b 7b 7b 20 7d 7d 7d     .. N7:  {{{{ }}}
    1d39:	7d 20 7b 7b 7b 7b 00 d9 1a c9 1b 00 00 20 4e 38     } {{{{....... N8
    1d49:	3a 20 20 7b 7b 7b 7b 20 7d 7d 7d 7d 20 7b 7b 7b     :  {{{{ }}}} {{{
    1d59:	7b 00 e5 1a d9 1b 00 00 20 4e 39 3a 20 20 7b 7b     {....... N9:  {{
    1d69:	7b 7b 20 7d 7d 7d 7d 20 7b 7b 7b 7b 00 f1 1a e9     {{ }}}} {{{{....
    1d79:	1b 00 00 20 4e 31 30 3a 20 7b 7b 7b 7b 20 7d 7d     ... N10: {{{{ }}
    1d89:	7d 7d 20 7b 7b 7b 7b 00 fd 1a f9 1b 00 00 20 4e     }} {{{{....... N
    1d99:	31 31 3a 20 7b 7b 7b 7b 20 7d 7d 7d 7d 20 7b 7b     11: {{{{ }}}} {{
    1da9:	7b 7b 00 09 1b 09 1c 00 00 20 4e 31 32 3a 20 7b     {{....... N12: {
    1db9:	7b 7b 7b 20 7d 7d 7d 7d 20 7b 7b 7b 7b 00 15 1b     {{{ }}}} {{{{...
    1dc9:	19 1c 00 00 20 4e 31 33 3a 20 7b 7b 7b 7b 20 7d     .... N13: {{{{ }
    1dd9:	7d 7d 7d 20 7b 7b 7b 7b 00 21 1b 29 1c 00 00 20     }}} {{{{.!.)... 
    1de9:	4e 31 34 3a 20 7b 7b 7b 7b 20 7d 7d 7d 7d 20 7b     N14: {{{{ }}}} {
    1df9:	7b 7b 7b 00 2d 1b 39 1c 00 00 20 4e 31 35 3a 20     {{{.-.9... N15: 
    1e09:	7b 7b 7b 7b 20 7d 7d 7d 7d 20 7b 7b 7b 7b 00 39     {{{{ }}}} {{{{.9
    1e19:	1b 49 1c 00 00 20 4e 31 36 3a 20 7b 7b 7b 7b 20     .I... N16: {{{{ 
    1e29:	7d 7d 7d 7d 20 7b 7b 7b 7b 00 45 1b 59 1c 00 00     }}}} {{{{.E.Y...
    1e39:	20 4e 31 37 3a 20 7b 7b 7b 7b 20 7d 7d 7d 7d 20      N17: {{{{ }}}} 
    1e49:	7b 7b 7b 7b 00 51 1b 69 1c 00 00 20 4e 31 38 3a     {{{{.Q.i... N18:
    1e59:	20 7b 7b 7b 7b 20 7d 7d 7d 7d 20 7b 7b 7b 7b 00      {{{{ }}}} {{{{.
    1e69:	5d 1b 79 1c 00 00                                   ].y...

00001e6f <MenuDI>:
    1e6f:	89 1c 12 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1e7f:	00 00 00 00                                         ....

00001e83 <F_DO1>:
    1e83:	1f df 07 00 00 00 00 00 00 00 00 00 00 37 07 00     .............7..

00001e93 <F_DO2>:
    1e93:	1f df 07 00 00 00 00 00 00 00 00 00 00 37 07 01     .............7..

00001ea3 <F_DO3>:
    1ea3:	1f df 07 00 00 00 00 00 00 00 00 00 00 37 07 02     .............7..

00001eb3 <F_DO4>:
    1eb3:	1f df 07 00 00 00 00 00 00 00 00 00 00 37 07 03     .............7..

00001ec3 <F_DO5>:
    1ec3:	1f df 07 00 00 00 00 00 00 00 00 00 00 37 07 04     .............7..

00001ed3 <F_DO6>:
    1ed3:	1f df 07 00 00 00 00 00 00 00 00 00 00 37 07 05     .............7..

00001ee3 <F_DO7>:
    1ee3:	1f df 07 00 00 00 00 00 00 00 00 00 00 37 07 06     .............7..

00001ef3 <F_DO8>:
    1ef3:	1f df 07 00 00 00 00 00 00 00 00 00 00 37 07 07     .............7..

00001f03 <F_DO9>:
    1f03:	1f df 07 00 00 00 00 00 00 00 00 00 00 37 07 08     .............7..

00001f13 <F_DO10>:
    1f13:	1f df 07 00 00 00 00 00 00 00 00 00 00 37 07 09     .............7..

00001f23 <F_DO11>:
    1f23:	1f df 07 00 00 00 00 00 00 00 00 00 00 37 07 0a     .............7..

00001f33 <F_DO12>:
    1f33:	1f df 07 00 00 00 00 00 00 00 00 00 00 37 07 0b     .............7..

00001f43 <F_DO13>:
    1f43:	1f df 07 00 00 00 00 00 00 00 00 00 00 37 07 0c     .............7..

00001f53 <F_DO14>:
    1f53:	1f df 07 00 00 00 00 00 00 00 00 00 00 37 07 0d     .............7..

00001f63 <F_DO15>:
    1f63:	1f df 07 00 00 00 00 00 00 00 00 00 00 37 07 0e     .............7..

00001f73 <F_DO16>:
    1f73:	1f df 07 00 00 00 00 00 00 00 00 00 00 37 07 0f     .............7..

00001f83 <ListDO>:
    1f83:	20 c2 fb f5 ee e4 20 4e 31 3a 20 20 20 20 20 7d      ..... N1:     }
    1f93:	7d 7d 7d 20 00 00 00 83 1e 00 00 20 c2 fb f5 ee     }}} ....... ....
    1fa3:	e4 20 4e 32 3a 20 20 20 20 20 7d 7d 7d 7d 20 00     . N2:     }}}} .
    1fb3:	00 00 93 1e 00 00 20 c2 fb f5 ee e4 20 4e 33 3a     ...... ..... N3:
    1fc3:	20 20 20 20 20 7d 7d 7d 7d 20 00 00 00 a3 1e 00          }}}} ......
    1fd3:	00 20 c2 fb f5 ee e4 20 4e 34 3a 20 20 20 20 20     . ..... N4:     
    1fe3:	7d 7d 7d 7d 20 00 00 00 b3 1e 00 00 20 c2 fb f5     }}}} ....... ...
    1ff3:	ee e4 20 4e 35 3a 20 20 20 20 20 7d 7d 7d 7d 20     .. N5:     }}}} 
    2003:	00 00 00 c3 1e 00 00 20 c2 fb f5 ee e4 20 4e 36     ....... ..... N6
    2013:	3a 20 20 20 20 20 7d 7d 7d 7d 20 00 00 00 d3 1e     :     }}}} .....
    2023:	00 00 20 c2 fb f5 ee e4 20 4e 37 3a 20 20 20 20     .. ..... N7:    
    2033:	20 7d 7d 7d 7d 20 00 00 00 e3 1e 00 00 20 c2 fb      }}}} ....... ..
    2043:	f5 ee e4 20 4e 38 3a 20 20 20 20 20 7d 7d 7d 7d     ... N8:     }}}}
    2053:	20 00 00 00 f3 1e 00 00 20 c2 fb f5 ee e4 20 4e      ....... ..... N
    2063:	39 3a 20 20 20 20 20 7d 7d 7d 7d 20 00 00 00 03     9:     }}}} ....
    2073:	1f 00 00 20 c2 fb f5 ee e4 20 4e 31 30 3a 20 20     ... ..... N10:  
    2083:	20 20 7d 7d 7d 7d 20 00 00 00 13 1f 00 00 20 c2       }}}} ....... .
    2093:	fb f5 ee e4 20 4e 31 31 3a 20 20 20 20 7d 7d 7d     .... N11:    }}}
    20a3:	7d 20 00 00 00 23 1f 00 00 20 c2 fb f5 ee e4 20     } ...#... ..... 
    20b3:	4e 31 32 3a 20 20 20 20 7d 7d 7d 7d 20 00 00 00     N12:    }}}} ...
    20c3:	33 1f 00 00 20 c2 fb f5 ee e4 20 4e 31 33 3a 20     3... ..... N13: 
    20d3:	20 20 20 7d 7d 7d 7d 20 00 00 00 43 1f 00 00 20        }}}} ...C... 
    20e3:	c2 fb f5 ee e4 20 4e 31 34 3a 20 20 20 20 7d 7d     ..... N14:    }}
    20f3:	7d 7d 20 00 00 00 53 1f 00 00 20 c2 fb f5 ee e4     }} ...S... .....
    2103:	20 4e 31 35 3a 20 20 20 20 7d 7d 7d 7d 20 00 00      N15:    }}}} ..
    2113:	00 63 1f 00 00 20 c2 fb f5 ee e4 20 4e 31 36 3a     .c... ..... N16:
    2123:	20 20 20 20 7d 7d 7d 7d 20 00 00 00 73 1f 00 00         }}}} ...s...

00002133 <MenuDO>:
    2133:	83 1f 10 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2143:	00 00 00 00                                         ....

00002147 <F_AI12>:
    2147:	0b 4e 0b 00 00 00 0b 50 0b 00 00 00                 .N.....P....

00002153 <F_AI34>:
    2153:	0b 52 0b 00 00 00 0b 54 0b 00 00 00                 .R.....T....

0000215f <F_AI56>:
    215f:	0b 56 0b 00 00 00 0b 58 0b 00 00 00                 .V.....X....

0000216b <F_AI78>:
    216b:	0b 5a 0b 00 00 00 0b 5c 0b 00 00 00                 .Z.....\....

00002177 <ListAI>:
    2177:	20 4e 31 3a 20 7b 7b 7b 7b 7b 20 4e 32 3a 20 7b      N1: {{{{{ N2: {
    2187:	7b 7b 7b 7b 00 47 21 00 00 00 00 20 4e 33 3a 20     {{{{.G!.... N3: 
    2197:	7b 7b 7b 7b 7b 20 4e 34 3a 20 7b 7b 7b 7b 7b 00     {{{{{ N4: {{{{{.
    21a7:	53 21 00 00 00 00 20 4e 35 3a 20 7b 7b 7b 7b 7b     S!.... N5: {{{{{
    21b7:	20 4e 36 3a 20 7b 7b 7b 7b 7b 00 5f 21 00 00 00      N6: {{{{{._!...
    21c7:	00 20 4e 37 3a 20 7b 7b 7b 7b 7b 20 4e 38 3a 20     . N7: {{{{{ N8: 
    21d7:	7b 7b 7b 7b 7b 00 6b 21 00 00 00 00                 {{{{{.k!....

000021e3 <MenuAI>:
    21e3:	77 21 04 03 00 00 00 00 00 00 00 00 00 00 00 00     w!..............
    21f3:	00 00 00 00                                         ....

000021f7 <F_AO1>:
    21f7:	0e d2 07 00 00 00 00 ff 03 00 00 00 00 00 00 00     ................

00002207 <F_AO2>:
    2207:	0e d4 07 00 00 00 00 ff 03 00 00 00 00 00 00 00     ................

00002217 <F_AO3>:
    2217:	0e d6 07 00 00 00 00 ff 03 00 00 00 00 00 00 00     ................

00002227 <F_AO4>:
    2227:	0e d8 07 00 00 00 00 ff 03 00 00 00 00 00 00 00     ................

00002237 <ListAO>:
    2237:	20 c2 fb f5 ee e4 20 4e 31 3a 20 20 20 20 20 7d      ..... N1:     }
    2247:	7d 7d 7d 7d 00 00 00 f7 21 00 00 20 c2 fb f5 ee     }}}}....!.. ....
    2257:	e4 20 4e 32 3a 20 20 20 20 20 7d 7d 7d 7d 7d 00     . N2:     }}}}}.
    2267:	00 00 07 22 00 00 20 c2 fb f5 ee e4 20 4e 33 3a     ...".. ..... N3:
    2277:	20 20 20 20 20 7d 7d 7d 7d 7d 00 00 00 17 22 00          }}}}}....".
    2287:	00 20 c2 fb f5 ee e4 20 4e 34 3a 20 20 20 20 20     . ..... N4:     
    2297:	7d 7d 7d 7d 7d 00 00 00 27 22 00 00                 }}}}}...'"..

000022a3 <MenuAO>:
    22a3:	37 22 04 00 00 00 00 00 00 00 00 00 00 00 00 00     7"..............
    22b3:	00 00 00 00                                         ....

000022b7 <F_ADC12>:
    22b7:	07 1b 09 00 00 00 07 1d 09 00 00 00                 ............

000022c3 <F_ADC34>:
    22c3:	07 1f 09 00 00 00 07 21 09 00 00 00                 .......!....

000022cf <F_ADC56>:
    22cf:	07 23 09 00 00 00 07 25 09 00 00 00                 .#.....%....

000022db <F_ADC_Ref>:
    22db:	07 27 09 00 00 00                                   .'....

000022e1 <List_ADC_Chan>:
    22e1:	20 2d 2d 2d 20 ca e0 ed e0 eb fb 20 c0 d6 cf 20      --- ...... ... 
    22f1:	2d 2d 2d 20 00 00 00 00 00 00 00 20 4e 31 3a 20     --- ....... N1: 
    2301:	7b 7b 7b 7b 7b 20 4e 32 3a 20 7b 7b 7b 7b 7b 00     {{{{{ N2: {{{{{.
    2311:	b7 22 00 00 00 00 20 4e 33 3a 20 7b 7b 7b 7b 7b     .".... N3: {{{{{
    2321:	20 4e 34 3a 20 7b 7b 7b 7b 7b 00 c3 22 00 00 00      N4: {{{{{.."...
    2331:	00 20 4e 35 3a 20 7b 7b 7b 7b 7b 20 4e 36 3a 20     . N5: {{{{{ N6: 
    2341:	7b 7b 7b 7b 7b 00 cf 22 00 00 00 00 20 ce ef ee     {{{{{..".... ...
    2351:	f0 ed 2e 20 ea e0 ed e0 eb 3a 20 7b 7b 7b 7b 7b     ... .....: {{{{{
    2361:	00 db 22 00 00 00 00                                .."....

00002368 <Menu_ADC_Ch>:
    2368:	e1 22 05 01 00 00 00 00 00 00 00 00 00 00 00 00     ."..............
    2378:	00 00 00 00                                         ....

0000237c <F_ADC_Zero>:
    237c:	00 6f 0c 00 00 00 04 6e 0c 00 00 00 04 6d 0c 00     .o.....n.....m..
	...

0000238e <F_ADC_Full>:
    238e:	00 72 0c 00 00 00 04 71 0c 00 00 00 04 70 0c 00     .r.....q.....p..
	...

000023a0 <List_ADC_Cali>:
    23a0:	20 2d 2d 2d 20 ca e0 eb e8 e1 f0 ee e2 ea e0 20      --- .......... 
    23b0:	2d 2d 2d 20 00 00 00 00 00 00 00 20 5a 65 72 6f     --- ....... Zero
    23c0:	3a 20 20 7b 7b 7b 20 7b 7b 7b 20 7b 7b 7b 20 00     :  {{{ {{{ {{{ .
    23d0:	7c 23 00 00 00 00 20 46 75 6c 6c 3a 20 20 7b 7b     |#.... Full:  {{
    23e0:	7b 20 7b 7b 7b 20 7b 7b 7b 20 00 8e 23 00 00 00     { {{{ {{{ ..#...
    23f0:	00 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20     .               
    2400:	20 20 20 20 20 00 00 00 00 00 00 00                      .......

0000240c <Menu_ADC_Cali>:
    240c:	a0 23 04 03 00 00 00 00 00 00 00 00 00 00 00 00     .#..............
    241c:	00 00 00 00                                         ....

00002420 <ADC_Rt_Str>:
    2420:	52 65 73 65 74 00                                   Reset.

00002426 <ADC_I1_Str>:
    2426:	49 6e 69 74 69 61 6c 69 73 61 74 00                 Initialisat.

00002432 <ADC_C1_Str>:
    2432:	43 61 6c 69 62 72 61 74 69 6f 6e 00                 Calibration.

0000243e <ADC_Re_Str>:
    243e:	52 65 61 64 00                                      Read.

00002443 <ADC_Of_Str>:
    2443:	4f 66 66 00                                         Off.

00002447 <ADC_Tbl>:
    2447:	20 24 26 24 32 24 3e 24 43 24                        $&$2$>$C$

00002451 <F_Therm1>:
    2451:	09 45 06 ec 08 01                                   .E....

00002457 <F_Therm2>:
    2457:	09 47 06 ec 08 01                                   .G....

0000245d <F_Therm3>:
    245d:	09 49 06 ec 08 01                                   .I....

00002463 <F_Therm4>:
    2463:	09 4b 06 ec 08 01                                   .K....

00002469 <F_Therm5>:
    2469:	09 4d 06 ec 08 01                                   .M....

0000246f <F_Therm6>:
    246f:	09 4f 06 ec 08 01                                   .O....

00002475 <F_Thermis1>:
    2475:	1e 17 01 00 00 00 00 07 00 00 00 00 00 20 09 00     ............. ..

00002485 <F_Thermis2>:
    2485:	1e 18 01 00 00 00 00 07 00 00 00 00 00 20 09 00     ............. ..

00002495 <F_Thermis3>:
    2495:	1e 19 01 00 00 00 00 07 00 00 00 00 00 20 09 00     ............. ..

000024a5 <F_Thermis4>:
    24a5:	1e 1a 01 00 00 00 00 07 00 00 00 00 00 20 09 00     ............. ..

000024b5 <F_Thermis5>:
    24b5:	1e 1b 01 00 00 00 00 07 00 00 00 00 00 20 09 00     ............. ..

000024c5 <F_Thermis6>:
    24c5:	1e 1c 01 00 00 00 00 07 00 00 00 00 00 20 09 00     ............. ..

000024d5 <F_ThermisD1>:
    24d5:	03 1d 01 80 ff ff ff 7f 00 00 00 00 00 00 00 01     ................

000024e5 <F_ThermisD2>:
    24e5:	03 20 01 80 ff ff ff 7f 00 00 00 00 00 00 00 01     . ..............

000024f5 <F_ThermisD3>:
    24f5:	03 23 01 80 ff ff ff 7f 00 00 00 00 00 00 00 01     .#..............

00002505 <F_ThermisD4>:
    2505:	03 26 01 80 ff ff ff 7f 00 00 00 00 00 00 00 01     .&..............

00002515 <F_ThermisD5>:
    2515:	03 29 01 80 ff ff ff 7f 00 00 00 00 00 00 00 01     .)..............

00002525 <F_ThermisD6>:
    2525:	03 2c 01 80 ff ff ff 7f 00 00 00 00 00 00 00 01     .,..............

00002535 <F_ThermisA1>:
    2535:	08 1e 01 84 03 00 00 4c 04 00 00 00 00 00 00 03     .......L........

00002545 <F_ThermisA2>:
    2545:	08 21 01 84 03 00 00 4c 04 00 00 00 00 00 00 03     .!.....L........

00002555 <F_ThermisA3>:
    2555:	08 24 01 84 03 00 00 4c 04 00 00 00 00 00 00 03     .$.....L........

00002565 <F_ThermisA4>:
    2565:	08 27 01 84 03 00 00 4c 04 00 00 00 00 00 00 03     .'.....L........

00002575 <F_ThermisA5>:
    2575:	08 2a 01 84 03 00 00 4c 04 00 00 00 00 00 00 03     .*.....L........

00002585 <F_ThermisA6>:
    2585:	08 2d 01 84 03 00 00 4c 04 00 00 00 00 00 00 03     .-.....L........

00002595 <ListTherm1>:
    2595:	20 ca e0 ed e0 eb 20 4e 31 3a 20 7b 7b 7b 7b 7b      ..... N1: {{{{{
    25a5:	7b 7b 7c 43 00 51 24 00 00 00 00 20 d2 e5 f0 ec     {{|C.Q$.... ....
    25b5:	ee e4 e0 f2 f7 e8 ea 3a 20 7d 7d 7d 7d 7d 7d 00     .......: }}}}}}.
    25c5:	00 00 75 24 00 00 20 d1 e4 e2 e8 e3 3a 20 20 20     ..u$.. .....:   
    25d5:	20 20 20 7d 7d 7d 7d 7d 7c 43 00 00 00 d5 24 00        }}}}}|C....$.
    25e5:	00 20 ca ee fd f4 f4 e8 f6 e8 e5 ed f2 3a 20 20     . ...........:  
    25f5:	7d 7d 7d 7d 7d 00 00 00 35 25 00 00                 }}}}}...5%..

00002601 <MenuTherm1>:
    2601:	95 25 04 01 00 00 00 00 00 00 00 00 00 00 00 00     .%..............
    2611:	00 00 00 00                                         ....

00002615 <ListTherm2>:
    2615:	20 ca e0 ed e0 eb 20 4e 32 3a 20 7b 7b 7b 7b 7b      ..... N2: {{{{{
    2625:	7b 7b 7c 43 00 57 24 00 00 00 00 20 d2 e5 f0 ec     {{|C.W$.... ....
    2635:	ee e4 e0 f2 f7 e8 ea 3a 20 7d 7d 7d 7d 7d 7d 00     .......: }}}}}}.
    2645:	00 00 85 24 00 00 20 d1 e4 e2 e8 e3 3a 20 20 20     ...$.. .....:   
    2655:	20 20 20 7d 7d 7d 7d 7d 7c 43 00 00 00 e5 24 00        }}}}}|C....$.
    2665:	00 20 ca ee fd f4 f4 e8 f6 e8 e5 ed f2 3a 20 20     . ...........:  
    2675:	7d 7d 7d 7d 7d 00 00 00 45 25 00 00                 }}}}}...E%..

00002681 <MenuTherm2>:
    2681:	15 26 04 01 00 00 00 00 00 00 00 00 00 00 00 00     .&..............
    2691:	00 00 00 00                                         ....

00002695 <ListTherm3>:
    2695:	20 ca e0 ed e0 eb 20 4e 33 3a 20 7b 7b 7b 7b 7b      ..... N3: {{{{{
    26a5:	7b 7b 7c 43 00 5d 24 00 00 00 00 20 d2 e5 f0 ec     {{|C.]$.... ....
    26b5:	ee e4 e0 f2 f7 e8 ea 3a 20 7d 7d 7d 7d 7d 7d 00     .......: }}}}}}.
    26c5:	00 00 95 24 00 00 20 d1 e4 e2 e8 e3 3a 20 20 20     ...$.. .....:   
    26d5:	20 20 20 7d 7d 7d 7d 7d 7c 43 00 00 00 f5 24 00        }}}}}|C....$.
    26e5:	00 20 ca ee fd f4 f4 e8 f6 e8 e5 ed f2 3a 20 20     . ...........:  
    26f5:	7d 7d 7d 7d 7d 00 00 00 55 25 00 00                 }}}}}...U%..

00002701 <MenuTherm3>:
    2701:	95 26 04 01 00 00 00 00 00 00 00 00 00 00 00 00     .&..............
    2711:	00 00 00 00                                         ....

00002715 <ListTherm4>:
    2715:	20 ca e0 ed e0 eb 20 4e 34 3a 20 7b 7b 7b 7b 7b      ..... N4: {{{{{
    2725:	7b 7b 7c 43 00 63 24 00 00 00 00 20 d2 e5 f0 ec     {{|C.c$.... ....
    2735:	ee e4 e0 f2 f7 e8 ea 3a 20 7d 7d 7d 7d 7d 7d 00     .......: }}}}}}.
    2745:	00 00 a5 24 00 00 20 d1 e4 e2 e8 e3 3a 20 20 20     ...$.. .....:   
    2755:	20 20 20 7d 7d 7d 7d 7d 7c 43 00 00 00 05 25 00        }}}}}|C....%.
    2765:	00 20 ca ee fd f4 f4 e8 f6 e8 e5 ed f2 3a 20 20     . ...........:  
    2775:	7d 7d 7d 7d 7d 00 00 00 65 25 00 00                 }}}}}...e%..

00002781 <MenuTherm4>:
    2781:	15 27 04 01 00 00 00 00 00 00 00 00 00 00 00 00     .'..............
    2791:	00 00 00 00                                         ....

00002795 <ListTherm5>:
    2795:	20 ca e0 ed e0 eb 20 4e 35 3a 20 7b 7b 7b 7b 7b      ..... N5: {{{{{
    27a5:	7b 7b 7c 43 00 69 24 00 00 00 00 20 d2 e5 f0 ec     {{|C.i$.... ....
    27b5:	ee e4 e0 f2 f7 e8 ea 3a 20 7d 7d 7d 7d 7d 7d 00     .......: }}}}}}.
    27c5:	00 00 b5 24 00 00 20 d1 e4 e2 e8 e3 3a 20 20 20     ...$.. .....:   
    27d5:	20 20 20 7d 7d 7d 7d 7d 7c 43 00 00 00 15 25 00        }}}}}|C....%.
    27e5:	00 20 ca ee fd f4 f4 e8 f6 e8 e5 ed f2 3a 20 20     . ...........:  
    27f5:	7d 7d 7d 7d 7d 00 00 00 75 25 00 00                 }}}}}...u%..

00002801 <MenuTherm5>:
    2801:	95 27 04 01 00 00 00 00 00 00 00 00 00 00 00 00     .'..............
    2811:	00 00 00 00                                         ....

00002815 <ListTherm6>:
    2815:	20 ca e0 ed e0 eb 20 4e 36 3a 20 7b 7b 7b 7b 7b      ..... N6: {{{{{
    2825:	7b 7b 7c 43 00 6f 24 00 00 00 00 20 d2 e5 f0 ec     {{|C.o$.... ....
    2835:	ee e4 e0 f2 f7 e8 ea 3a 20 7d 7d 7d 7d 7d 7d 00     .......: }}}}}}.
    2845:	00 00 c5 24 00 00 20 d1 e4 e2 e8 e3 3a 20 20 20     ...$.. .....:   
    2855:	20 20 20 7d 7d 7d 7d 7d 7c 43 00 00 00 25 25 00        }}}}}|C...%%.
    2865:	00 20 ca ee fd f4 f4 e8 f6 e8 e5 ed f2 3a 20 20     . ...........:  
    2875:	7d 7d 7d 7d 7d 00 00 00 85 25 00 00                 }}}}}....%..

00002881 <MenuTherm6>:
    2881:	15 28 04 01 00 00 00 00 00 00 00 00 00 00 00 00     .(..............
    2891:	00 00 00 00                                         ....

00002895 <List_Therm>:
    2895:	20 ca e0 ed e0 eb 20 4e 31 3a 20 7b 7b 7b 7b 7b      ..... N1: {{{{{
    28a5:	7b 7b 7c 43 00 51 24 00 00 01 26 20 ca e0 ed e0     {{|C.Q$...& ....
    28b5:	eb 20 4e 32 3a 20 7b 7b 7b 7b 7b 7b 7b 7c 43 00     . N2: {{{{{{{|C.
    28c5:	57 24 00 00 81 26 20 ca e0 ed e0 eb 20 4e 33 3a     W$...& ..... N3:
    28d5:	20 7b 7b 7b 7b 7b 7b 7b 7c 43 00 5d 24 00 00 01      {{{{{{{|C.]$...
    28e5:	27 20 ca e0 ed e0 eb 20 4e 34 3a 20 7b 7b 7b 7b     ' ..... N4: {{{{
    28f5:	7b 7b 7b 7c 43 00 63 24 00 00 81 27 20 ca e0 ed     {{{|C.c$...' ...
    2905:	e0 eb 20 4e 35 3a 20 7b 7b 7b 7b 7b 7b 7b 7c 43     .. N5: {{{{{{{|C
    2915:	00 69 24 00 00 01 28 20 ca e0 ed e0 eb 20 4e 36     .i$...( ..... N6
    2925:	3a 20 7b 7b 7b 7b 7b 7b 7b 7c 43 00 6f 24 00 00     : {{{{{{{|C.o$..
    2935:	81 28                                               .(

00002937 <MenuTherm>:
    2937:	95 28 06 00 00 00 00 00 00 00 00 00 00 00 00 00     .(..............
    2947:	00 00 00 00                                         ....

0000294b <MB_Master_List>:
    294b:	00 00 00                                            ...

0000294e <Channel0_Name_InField>:
    294e:	00 b6 06 00 00 00                                   ......

00002954 <Channel0_DI_State_InField>:
    2954:	00 b7 06 00 00 00                                   ......

0000295a <Channel0_Alarm_State_InField>:
    295a:	00 b8 06 00 00 00                                   ......

00002960 <Channel0_debounceTimeout_OutField>:
    2960:	08 31 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .1..............

00002970 <Channel0_calling_delay_OutField>:
    2970:	08 51 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .Q..............

00002980 <Channel0_calling_retry_delay_OutField>:
    2980:	08 71 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .q..............

00002990 <Channel0>:
    2990:	20 cd ee ec e5 f0 20 ea e0 ed e0 eb e0 20 20 20      ..... ......   
    29a0:	20 7b 7b 7b 00 4e 29 00 00 00 00 20 d1 ee f1 f2      {{{.N).... ....
    29b0:	ee ff ed e8 e5 20 e2 f5 ee e4 e0 20 7b 7b 7b 00     ..... ..... {{{.
    29c0:	54 29 00 00 00 00 20 d1 ee f1 f2 ee ff ed e8 e5     T).... .........
    29d0:	20 ea e0 ed e0 eb e0 7b 7b 7b 00 5a 29 00 00 00      ......{{{.Z)...
    29e0:	00 20 d2 e0 ed f2 e8 e4 f0 e5 e1 e5 e7 e3 20 20     . ............  
    29f0:	7d 7d 7d 7d 7d 00 00 00 60 29 00 00 20 d2 e4 ee     }}}}}...`).. ...
    2a00:	e7 e2 ee ed e0 20 20 20 20 20 20 7d 7d 7d 7d 7d     .....      }}}}}
    2a10:	00 00 00 70 29 00 00 20 d2 ef ee e2 f2 2e e4 ee     ...p).. ........
    2a20:	e7 e2 ee ed e0 20 7d 7d 7d 7d 7d 00 00 00 80 29     ..... }}}}}....)
	...

00002a32 <Channel0_Page>:
    2a32:	90 29 06 00 00 00 00 00 00 00 00 00 00 00 00 00     .)..............
    2a42:	00 00 00 00                                         ....

00002a46 <Channel1_Name_InField>:
    2a46:	00 ba 06 00 00 00                                   ......

00002a4c <Channel1_DI_State_InField>:
    2a4c:	00 bb 06 00 00 00                                   ......

00002a52 <Channel1_Alarm_State_InField>:
    2a52:	00 bc 06 00 00 00                                   ......

00002a58 <Channel1_debounceTimeout_OutField>:
    2a58:	08 33 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .3..............

00002a68 <Channel1_calling_delay_OutField>:
    2a68:	08 53 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .S..............

00002a78 <Channel1_calling_retry_delay_OutField>:
    2a78:	08 73 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .s..............

00002a88 <Channel1>:
    2a88:	20 cd ee ec e5 f0 20 ea e0 ed e0 eb e0 20 20 20      ..... ......   
    2a98:	20 7b 7b 7b 00 46 2a 00 00 00 00 20 d1 ee f1 f2      {{{.F*.... ....
    2aa8:	ee ff ed e8 e5 20 e2 f5 ee e4 e0 20 7b 7b 7b 00     ..... ..... {{{.
    2ab8:	4c 2a 00 00 00 00 20 d1 ee f1 f2 ee ff ed e8 e5     L*.... .........
    2ac8:	20 ea e0 ed e0 eb e0 7b 7b 7b 00 52 2a 00 00 00      ......{{{.R*...
    2ad8:	00 20 d2 e0 ed f2 e8 e4 f0 e5 e1 e5 e7 e3 20 20     . ............  
    2ae8:	7d 7d 7d 7d 7d 00 00 00 58 2a 00 00 20 d2 e4 ee     }}}}}...X*.. ...
    2af8:	e7 e2 ee ed e0 20 20 20 20 20 20 7d 7d 7d 7d 7d     .....      }}}}}
    2b08:	00 00 00 68 2a 00 00 20 d2 ef ee e2 f2 2e e4 ee     ...h*.. ........
    2b18:	e7 e2 ee ed e0 20 7d 7d 7d 7d 7d 00 00 00 78 2a     ..... }}}}}...x*
	...

00002b2a <Channel1_Page>:
    2b2a:	88 2a 06 00 00 00 00 00 00 00 00 00 00 00 00 00     .*..............
    2b3a:	00 00 00 00                                         ....

00002b3e <Channel2_Name_InField>:
    2b3e:	00 be 06 00 00 00                                   ......

00002b44 <Channel2_DI_State_InField>:
    2b44:	00 bf 06 00 00 00                                   ......

00002b4a <Channel2_Alarm_State_InField>:
    2b4a:	00 c0 06 00 00 00                                   ......

00002b50 <Channel2_debounceTimeout_OutField>:
    2b50:	08 35 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .5..............

00002b60 <Channel2_calling_delay_OutField>:
    2b60:	08 55 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .U..............

00002b70 <Channel2_calling_retry_delay_OutField>:
    2b70:	08 75 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .u..............

00002b80 <Channel2>:
    2b80:	20 cd ee ec e5 f0 20 ea e0 ed e0 eb e0 20 20 20      ..... ......   
    2b90:	20 7b 7b 7b 00 3e 2b 00 00 00 00 20 d1 ee f1 f2      {{{.>+.... ....
    2ba0:	ee ff ed e8 e5 20 e2 f5 ee e4 e0 20 7b 7b 7b 00     ..... ..... {{{.
    2bb0:	44 2b 00 00 00 00 20 d1 ee f1 f2 ee ff ed e8 e5     D+.... .........
    2bc0:	20 ea e0 ed e0 eb e0 7b 7b 7b 00 4a 2b 00 00 00      ......{{{.J+...
    2bd0:	00 20 d2 e0 ed f2 e8 e4 f0 e5 e1 e5 e7 e3 20 20     . ............  
    2be0:	7d 7d 7d 7d 7d 00 00 00 50 2b 00 00 20 d2 e4 ee     }}}}}...P+.. ...
    2bf0:	e7 e2 ee ed e0 20 20 20 20 20 20 7d 7d 7d 7d 7d     .....      }}}}}
    2c00:	00 00 00 60 2b 00 00 20 d2 ef ee e2 f2 2e e4 ee     ...`+.. ........
    2c10:	e7 e2 ee ed e0 20 7d 7d 7d 7d 7d 00 00 00 70 2b     ..... }}}}}...p+
	...

00002c22 <Channel2_Page>:
    2c22:	80 2b 06 00 00 00 00 00 00 00 00 00 00 00 00 00     .+..............
    2c32:	00 00 00 00                                         ....

00002c36 <Channel3_Name_InField>:
    2c36:	00 c2 06 00 00 00                                   ......

00002c3c <Channel3_DI_State_InField>:
    2c3c:	00 c3 06 00 00 00                                   ......

00002c42 <Channel3_Alarm_State_InField>:
    2c42:	00 c4 06 00 00 00                                   ......

00002c48 <Channel3_debounceTimeout_OutField>:
    2c48:	08 37 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .7..............

00002c58 <Channel3_calling_delay_OutField>:
    2c58:	08 57 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .W..............

00002c68 <Channel3_calling_retry_delay_OutField>:
    2c68:	08 77 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .w..............

00002c78 <Channel3>:
    2c78:	20 cd ee ec e5 f0 20 ea e0 ed e0 eb e0 20 20 20      ..... ......   
    2c88:	20 7b 7b 7b 00 36 2c 00 00 00 00 20 d1 ee f1 f2      {{{.6,.... ....
    2c98:	ee ff ed e8 e5 20 e2 f5 ee e4 e0 20 7b 7b 7b 00     ..... ..... {{{.
    2ca8:	3c 2c 00 00 00 00 20 d1 ee f1 f2 ee ff ed e8 e5     <,.... .........
    2cb8:	20 ea e0 ed e0 eb e0 7b 7b 7b 00 42 2c 00 00 00      ......{{{.B,...
    2cc8:	00 20 d2 e0 ed f2 e8 e4 f0 e5 e1 e5 e7 e3 20 20     . ............  
    2cd8:	7d 7d 7d 7d 7d 00 00 00 48 2c 00 00 20 d2 e4 ee     }}}}}...H,.. ...
    2ce8:	e7 e2 ee ed e0 20 20 20 20 20 20 7d 7d 7d 7d 7d     .....      }}}}}
    2cf8:	00 00 00 58 2c 00 00 20 d2 ef ee e2 f2 2e e4 ee     ...X,.. ........
    2d08:	e7 e2 ee ed e0 20 7d 7d 7d 7d 7d 00 00 00 68 2c     ..... }}}}}...h,
	...

00002d1a <Channel3_Page>:
    2d1a:	78 2c 06 00 00 00 00 00 00 00 00 00 00 00 00 00     x,..............
    2d2a:	00 00 00 00                                         ....

00002d2e <Channel4_Name_InField>:
    2d2e:	00 c6 06 00 00 00                                   ......

00002d34 <Channel4_DI_State_InField>:
    2d34:	00 c7 06 00 00 00                                   ......

00002d3a <Channel4_Alarm_State_InField>:
    2d3a:	00 c8 06 00 00 00                                   ......

00002d40 <Channel4_debounceTimeout_OutField>:
    2d40:	08 39 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .9..............

00002d50 <Channel4_calling_delay_OutField>:
    2d50:	08 59 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .Y..............

00002d60 <Channel4_calling_retry_delay_OutField>:
    2d60:	08 79 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .y..............

00002d70 <Channel4>:
    2d70:	20 cd ee ec e5 f0 20 ea e0 ed e0 eb e0 20 20 20      ..... ......   
    2d80:	20 7b 7b 7b 00 2e 2d 00 00 00 00 20 d1 ee f1 f2      {{{..-.... ....
    2d90:	ee ff ed e8 e5 20 e2 f5 ee e4 e0 20 7b 7b 7b 00     ..... ..... {{{.
    2da0:	34 2d 00 00 00 00 20 d1 ee f1 f2 ee ff ed e8 e5     4-.... .........
    2db0:	20 ea e0 ed e0 eb e0 7b 7b 7b 00 3a 2d 00 00 00      ......{{{.:-...
    2dc0:	00 20 d2 e0 ed f2 e8 e4 f0 e5 e1 e5 e7 e3 20 20     . ............  
    2dd0:	7d 7d 7d 7d 7d 00 00 00 40 2d 00 00 20 d2 e4 ee     }}}}}...@-.. ...
    2de0:	e7 e2 ee ed e0 20 20 20 20 20 20 7d 7d 7d 7d 7d     .....      }}}}}
    2df0:	00 00 00 50 2d 00 00 20 d2 ef ee e2 f2 2e e4 ee     ...P-.. ........
    2e00:	e7 e2 ee ed e0 20 7d 7d 7d 7d 7d 00 00 00 60 2d     ..... }}}}}...`-
	...

00002e12 <Channel4_Page>:
    2e12:	70 2d 06 00 00 00 00 00 00 00 00 00 00 00 00 00     p-..............
    2e22:	00 00 00 00                                         ....

00002e26 <Channel5_Name_InField>:
    2e26:	00 ca 06 00 00 00                                   ......

00002e2c <Channel5_DI_State_InField>:
    2e2c:	00 cb 06 00 00 00                                   ......

00002e32 <Channel5_Alarm_State_InField>:
    2e32:	00 cc 06 00 00 00                                   ......

00002e38 <Channel5_debounceTimeout_OutField>:
    2e38:	08 3b 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .;..............

00002e48 <Channel5_calling_delay_OutField>:
    2e48:	08 5b 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .[..............

00002e58 <Channel5_calling_retry_delay_OutField>:
    2e58:	08 7b 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .{..............

00002e68 <Channel5>:
    2e68:	20 cd ee ec e5 f0 20 ea e0 ed e0 eb e0 20 20 20      ..... ......   
    2e78:	20 7b 7b 7b 00 26 2e 00 00 00 00 20 d1 ee f1 f2      {{{.&..... ....
    2e88:	ee ff ed e8 e5 20 e2 f5 ee e4 e0 20 7b 7b 7b 00     ..... ..... {{{.
    2e98:	2c 2e 00 00 00 00 20 d1 ee f1 f2 ee ff ed e8 e5     ,..... .........
    2ea8:	20 ea e0 ed e0 eb e0 7b 7b 7b 00 32 2e 00 00 00      ......{{{.2....
    2eb8:	00 20 d2 e0 ed f2 e8 e4 f0 e5 e1 e5 e7 e3 20 20     . ............  
    2ec8:	7d 7d 7d 7d 7d 00 00 00 38 2e 00 00 20 d2 e4 ee     }}}}}...8... ...
    2ed8:	e7 e2 ee ed e0 20 20 20 20 20 20 7d 7d 7d 7d 7d     .....      }}}}}
    2ee8:	00 00 00 48 2e 00 00 20 d2 ef ee e2 f2 2e e4 ee     ...H... ........
    2ef8:	e7 e2 ee ed e0 20 7d 7d 7d 7d 7d 00 00 00 58 2e     ..... }}}}}...X.
	...

00002f0a <Channel5_Page>:
    2f0a:	68 2e 06 00 00 00 00 00 00 00 00 00 00 00 00 00     h...............
    2f1a:	00 00 00 00                                         ....

00002f1e <Channel6_Name_InField>:
    2f1e:	00 ce 06 00 00 00                                   ......

00002f24 <Channel6_DI_State_InField>:
    2f24:	00 cf 06 00 00 00                                   ......

00002f2a <Channel6_Alarm_State_InField>:
    2f2a:	00 d0 06 00 00 00                                   ......

00002f30 <Channel6_debounceTimeout_OutField>:
    2f30:	08 3d 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .=..............

00002f40 <Channel6_calling_delay_OutField>:
    2f40:	08 5d 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .]..............

00002f50 <Channel6_calling_retry_delay_OutField>:
    2f50:	08 7d 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .}..............

00002f60 <Channel6>:
    2f60:	20 cd ee ec e5 f0 20 ea e0 ed e0 eb e0 20 20 20      ..... ......   
    2f70:	20 7b 7b 7b 00 1e 2f 00 00 00 00 20 d1 ee f1 f2      {{{../.... ....
    2f80:	ee ff ed e8 e5 20 e2 f5 ee e4 e0 20 7b 7b 7b 00     ..... ..... {{{.
    2f90:	24 2f 00 00 00 00 20 d1 ee f1 f2 ee ff ed e8 e5     $/.... .........
    2fa0:	20 ea e0 ed e0 eb e0 7b 7b 7b 00 2a 2f 00 00 00      ......{{{.*/...
    2fb0:	00 20 d2 e0 ed f2 e8 e4 f0 e5 e1 e5 e7 e3 20 20     . ............  
    2fc0:	7d 7d 7d 7d 7d 00 00 00 30 2f 00 00 20 d2 e4 ee     }}}}}...0/.. ...
    2fd0:	e7 e2 ee ed e0 20 20 20 20 20 20 7d 7d 7d 7d 7d     .....      }}}}}
    2fe0:	00 00 00 40 2f 00 00 20 d2 ef ee e2 f2 2e e4 ee     ...@/.. ........
    2ff0:	e7 e2 ee ed e0 20 7d 7d 7d 7d 7d 00 00 00 50 2f     ..... }}}}}...P/
	...

00003002 <Channel6_Page>:
    3002:	60 2f 06 00 00 00 00 00 00 00 00 00 00 00 00 00     `/..............
    3012:	00 00 00 00                                         ....

00003016 <Channel7_Name_InField>:
    3016:	00 d2 06 00 00 00                                   ......

0000301c <Channel7_DI_State_InField>:
    301c:	00 d3 06 00 00 00                                   ......

00003022 <Channel7_Alarm_State_InField>:
    3022:	00 d4 06 00 00 00                                   ......

00003028 <Channel7_debounceTimeout_OutField>:
    3028:	08 3f 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .?..............

00003038 <Channel7_calling_delay_OutField>:
    3038:	08 5f 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     ._..............

00003048 <Channel7_calling_retry_delay_OutField>:
    3048:	08 7f 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     ................

00003058 <Channel7>:
    3058:	20 cd ee ec e5 f0 20 ea e0 ed e0 eb e0 20 20 20      ..... ......   
    3068:	20 7b 7b 7b 00 16 30 00 00 00 00 20 d1 ee f1 f2      {{{..0.... ....
    3078:	ee ff ed e8 e5 20 e2 f5 ee e4 e0 20 7b 7b 7b 00     ..... ..... {{{.
    3088:	1c 30 00 00 00 00 20 d1 ee f1 f2 ee ff ed e8 e5     .0.... .........
    3098:	20 ea e0 ed e0 eb e0 7b 7b 7b 00 22 30 00 00 00      ......{{{."0...
    30a8:	00 20 d2 e0 ed f2 e8 e4 f0 e5 e1 e5 e7 e3 20 20     . ............  
    30b8:	7d 7d 7d 7d 7d 00 00 00 28 30 00 00 20 d2 e4 ee     }}}}}...(0.. ...
    30c8:	e7 e2 ee ed e0 20 20 20 20 20 20 7d 7d 7d 7d 7d     .....      }}}}}
    30d8:	00 00 00 38 30 00 00 20 d2 ef ee e2 f2 2e e4 ee     ...80.. ........
    30e8:	e7 e2 ee ed e0 20 7d 7d 7d 7d 7d 00 00 00 48 30     ..... }}}}}...H0
	...

000030fa <Channel7_Page>:
    30fa:	58 30 06 00 00 00 00 00 00 00 00 00 00 00 00 00     X0..............
    310a:	00 00 00 00                                         ....

0000310e <Channel8_Name_InField>:
    310e:	00 d6 06 00 00 00                                   ......

00003114 <Channel8_DI_State_InField>:
    3114:	00 d7 06 00 00 00                                   ......

0000311a <Channel8_Alarm_State_InField>:
    311a:	00 d8 06 00 00 00                                   ......

00003120 <Channel8_debounceTimeout_OutField>:
    3120:	08 41 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .A..............

00003130 <Channel8_calling_delay_OutField>:
    3130:	08 61 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .a..............

00003140 <Channel8_calling_retry_delay_OutField>:
    3140:	08 81 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     ................

00003150 <Channel8>:
    3150:	20 cd ee ec e5 f0 20 ea e0 ed e0 eb e0 20 20 20      ..... ......   
    3160:	20 7b 7b 7b 00 0e 31 00 00 00 00 20 d1 ee f1 f2      {{{..1.... ....
    3170:	ee ff ed e8 e5 20 e2 f5 ee e4 e0 20 7b 7b 7b 00     ..... ..... {{{.
    3180:	14 31 00 00 00 00 20 d1 ee f1 f2 ee ff ed e8 e5     .1.... .........
    3190:	20 ea e0 ed e0 eb e0 7b 7b 7b 00 1a 31 00 00 00      ......{{{..1...
    31a0:	00 20 d2 e0 ed f2 e8 e4 f0 e5 e1 e5 e7 e3 20 20     . ............  
    31b0:	7d 7d 7d 7d 7d 00 00 00 20 31 00 00 20 d2 e4 ee     }}}}}... 1.. ...
    31c0:	e7 e2 ee ed e0 20 20 20 20 20 20 7d 7d 7d 7d 7d     .....      }}}}}
    31d0:	00 00 00 30 31 00 00 20 d2 ef ee e2 f2 2e e4 ee     ...01.. ........
    31e0:	e7 e2 ee ed e0 20 7d 7d 7d 7d 7d 00 00 00 40 31     ..... }}}}}...@1
	...

000031f2 <Channel8_Page>:
    31f2:	50 31 06 00 00 00 00 00 00 00 00 00 00 00 00 00     P1..............
    3202:	00 00 00 00                                         ....

00003206 <Channel9_Name_InField>:
    3206:	00 da 06 00 00 00                                   ......

0000320c <Channel9_DI_State_InField>:
    320c:	00 db 06 00 00 00                                   ......

00003212 <Channel9_Alarm_State_InField>:
    3212:	00 dc 06 00 00 00                                   ......

00003218 <Channel9_debounceTimeout_OutField>:
    3218:	08 43 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .C..............

00003228 <Channel9_calling_delay_OutField>:
    3228:	08 63 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .c..............

00003238 <Channel9_calling_retry_delay_OutField>:
    3238:	08 83 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     ................

00003248 <Channel9>:
    3248:	20 cd ee ec e5 f0 20 ea e0 ed e0 eb e0 20 20 20      ..... ......   
    3258:	20 7b 7b 7b 00 06 32 00 00 00 00 20 d1 ee f1 f2      {{{..2.... ....
    3268:	ee ff ed e8 e5 20 e2 f5 ee e4 e0 20 7b 7b 7b 00     ..... ..... {{{.
    3278:	0c 32 00 00 00 00 20 d1 ee f1 f2 ee ff ed e8 e5     .2.... .........
    3288:	20 ea e0 ed e0 eb e0 7b 7b 7b 00 12 32 00 00 00      ......{{{..2...
    3298:	00 20 d2 e0 ed f2 e8 e4 f0 e5 e1 e5 e7 e3 20 20     . ............  
    32a8:	7d 7d 7d 7d 7d 00 00 00 18 32 00 00 20 d2 e4 ee     }}}}}....2.. ...
    32b8:	e7 e2 ee ed e0 20 20 20 20 20 20 7d 7d 7d 7d 7d     .....      }}}}}
    32c8:	00 00 00 28 32 00 00 20 d2 ef ee e2 f2 2e e4 ee     ...(2.. ........
    32d8:	e7 e2 ee ed e0 20 7d 7d 7d 7d 7d 00 00 00 38 32     ..... }}}}}...82
	...

000032ea <Channel9_Page>:
    32ea:	48 32 06 00 00 00 00 00 00 00 00 00 00 00 00 00     H2..............
    32fa:	00 00 00 00                                         ....

000032fe <Channel10_Name_InField>:
    32fe:	00 de 06 00 00 00                                   ......

00003304 <Channel10_DI_State_InField>:
    3304:	00 df 06 00 00 00                                   ......

0000330a <Channel10_Alarm_State_InField>:
    330a:	00 e0 06 00 00 00                                   ......

00003310 <Channel10_debounceTimeout_OutField>:
    3310:	08 45 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .E..............

00003320 <Channel10_calling_delay_OutField>:
    3320:	08 65 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .e..............

00003330 <Channel10_calling_retry_delay_OutField>:
    3330:	08 85 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     ................

00003340 <Channel10>:
    3340:	20 cd ee ec e5 f0 20 ea e0 ed e0 eb e0 20 20 20      ..... ......   
    3350:	20 7b 7b 7b 00 fe 32 00 00 00 00 20 d1 ee f1 f2      {{{..2.... ....
    3360:	ee ff ed e8 e5 20 e2 f5 ee e4 e0 20 7b 7b 7b 00     ..... ..... {{{.
    3370:	04 33 00 00 00 00 20 d1 ee f1 f2 ee ff ed e8 e5     .3.... .........
    3380:	20 ea e0 ed e0 eb e0 7b 7b 7b 00 0a 33 00 00 00      ......{{{..3...
    3390:	00 20 d2 e0 ed f2 e8 e4 f0 e5 e1 e5 e7 e3 20 20     . ............  
    33a0:	7d 7d 7d 7d 7d 00 00 00 10 33 00 00 20 d2 e4 ee     }}}}}....3.. ...
    33b0:	e7 e2 ee ed e0 20 20 20 20 20 20 7d 7d 7d 7d 7d     .....      }}}}}
    33c0:	00 00 00 20 33 00 00 20 d2 ef ee e2 f2 2e e4 ee     ... 3.. ........
    33d0:	e7 e2 ee ed e0 20 7d 7d 7d 7d 7d 00 00 00 30 33     ..... }}}}}...03
	...

000033e2 <Channel10_Page>:
    33e2:	40 33 06 00 00 00 00 00 00 00 00 00 00 00 00 00     @3..............
    33f2:	00 00 00 00                                         ....

000033f6 <Channel11_Name_InField>:
    33f6:	00 e2 06 00 00 00                                   ......

000033fc <Channel11_DI_State_InField>:
    33fc:	00 e3 06 00 00 00                                   ......

00003402 <Channel11_Alarm_State_InField>:
    3402:	00 e4 06 00 00 00                                   ......

00003408 <Channel11_debounceTimeout_OutField>:
    3408:	08 47 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .G..............

00003418 <Channel11_calling_delay_OutField>:
    3418:	08 67 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .g..............

00003428 <Channel11_calling_retry_delay_OutField>:
    3428:	08 87 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     ................

00003438 <Channel11>:
    3438:	20 cd ee ec e5 f0 20 ea e0 ed e0 eb e0 20 20 20      ..... ......   
    3448:	20 7b 7b 7b 00 f6 33 00 00 00 00 20 d1 ee f1 f2      {{{..3.... ....
    3458:	ee ff ed e8 e5 20 e2 f5 ee e4 e0 20 7b 7b 7b 00     ..... ..... {{{.
    3468:	fc 33 00 00 00 00 20 d1 ee f1 f2 ee ff ed e8 e5     .3.... .........
    3478:	20 ea e0 ed e0 eb e0 7b 7b 7b 00 02 34 00 00 00      ......{{{..4...
    3488:	00 20 d2 e0 ed f2 e8 e4 f0 e5 e1 e5 e7 e3 20 20     . ............  
    3498:	7d 7d 7d 7d 7d 00 00 00 08 34 00 00 20 d2 e4 ee     }}}}}....4.. ...
    34a8:	e7 e2 ee ed e0 20 20 20 20 20 20 7d 7d 7d 7d 7d     .....      }}}}}
    34b8:	00 00 00 18 34 00 00 20 d2 ef ee e2 f2 2e e4 ee     ....4.. ........
    34c8:	e7 e2 ee ed e0 20 7d 7d 7d 7d 7d 00 00 00 28 34     ..... }}}}}...(4
	...

000034da <Channel11_Page>:
    34da:	38 34 06 00 00 00 00 00 00 00 00 00 00 00 00 00     84..............
    34ea:	00 00 00 00                                         ....

000034ee <Channel12_Name_InField>:
    34ee:	00 e6 06 00 00 00                                   ......

000034f4 <Channel12_DI_State_InField>:
    34f4:	00 e7 06 00 00 00                                   ......

000034fa <Channel12_Alarm_State_InField>:
    34fa:	00 e8 06 00 00 00                                   ......

00003500 <Channel12_debounceTimeout_OutField>:
    3500:	08 49 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .I..............

00003510 <Channel12_calling_delay_OutField>:
    3510:	08 69 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .i..............

00003520 <Channel12_calling_retry_delay_OutField>:
    3520:	08 89 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     ................

00003530 <Channel12>:
    3530:	20 cd ee ec e5 f0 20 ea e0 ed e0 eb e0 20 20 20      ..... ......   
    3540:	20 7b 7b 7b 00 ee 34 00 00 00 00 20 d1 ee f1 f2      {{{..4.... ....
    3550:	ee ff ed e8 e5 20 e2 f5 ee e4 e0 20 7b 7b 7b 00     ..... ..... {{{.
    3560:	f4 34 00 00 00 00 20 d1 ee f1 f2 ee ff ed e8 e5     .4.... .........
    3570:	20 ea e0 ed e0 eb e0 7b 7b 7b 00 fa 34 00 00 00      ......{{{..4...
    3580:	00 20 d2 e0 ed f2 e8 e4 f0 e5 e1 e5 e7 e3 20 20     . ............  
    3590:	7d 7d 7d 7d 7d 00 00 00 00 35 00 00 20 d2 e4 ee     }}}}}....5.. ...
    35a0:	e7 e2 ee ed e0 20 20 20 20 20 20 7d 7d 7d 7d 7d     .....      }}}}}
    35b0:	00 00 00 10 35 00 00 20 d2 ef ee e2 f2 2e e4 ee     ....5.. ........
    35c0:	e7 e2 ee ed e0 20 7d 7d 7d 7d 7d 00 00 00 20 35     ..... }}}}}... 5
	...

000035d2 <Channel12_Page>:
    35d2:	30 35 06 00 00 00 00 00 00 00 00 00 00 00 00 00     05..............
    35e2:	00 00 00 00                                         ....

000035e6 <Channel13_Name_InField>:
    35e6:	00 ea 06 00 00 00                                   ......

000035ec <Channel13_DI_State_InField>:
    35ec:	00 eb 06 00 00 00                                   ......

000035f2 <Channel13_Alarm_State_InField>:
    35f2:	00 ec 06 00 00 00                                   ......

000035f8 <Channel13_debounceTimeout_OutField>:
    35f8:	08 4b 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .K..............

00003608 <Channel13_calling_delay_OutField>:
    3608:	08 6b 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .k..............

00003618 <Channel13_calling_retry_delay_OutField>:
    3618:	08 8b 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     ................

00003628 <Channel13>:
    3628:	20 cd ee ec e5 f0 20 ea e0 ed e0 eb e0 20 20 20      ..... ......   
    3638:	20 7b 7b 7b 00 e6 35 00 00 00 00 20 d1 ee f1 f2      {{{..5.... ....
    3648:	ee ff ed e8 e5 20 e2 f5 ee e4 e0 20 7b 7b 7b 00     ..... ..... {{{.
    3658:	ec 35 00 00 00 00 20 d1 ee f1 f2 ee ff ed e8 e5     .5.... .........
    3668:	20 ea e0 ed e0 eb e0 7b 7b 7b 00 f2 35 00 00 00      ......{{{..5...
    3678:	00 20 d2 e0 ed f2 e8 e4 f0 e5 e1 e5 e7 e3 20 20     . ............  
    3688:	7d 7d 7d 7d 7d 00 00 00 f8 35 00 00 20 d2 e4 ee     }}}}}....5.. ...
    3698:	e7 e2 ee ed e0 20 20 20 20 20 20 7d 7d 7d 7d 7d     .....      }}}}}
    36a8:	00 00 00 08 36 00 00 20 d2 ef ee e2 f2 2e e4 ee     ....6.. ........
    36b8:	e7 e2 ee ed e0 20 7d 7d 7d 7d 7d 00 00 00 18 36     ..... }}}}}....6
	...

000036ca <Channel13_Page>:
    36ca:	28 36 06 00 00 00 00 00 00 00 00 00 00 00 00 00     (6..............
    36da:	00 00 00 00                                         ....

000036de <Channel14_Name_InField>:
    36de:	00 ee 06 00 00 00                                   ......

000036e4 <Channel14_DI_State_InField>:
    36e4:	00 ef 06 00 00 00                                   ......

000036ea <Channel14_Alarm_State_InField>:
    36ea:	00 f0 06 00 00 00                                   ......

000036f0 <Channel14_debounceTimeout_OutField>:
    36f0:	08 4d 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .M..............

00003700 <Channel14_calling_delay_OutField>:
    3700:	08 6d 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .m..............

00003710 <Channel14_calling_retry_delay_OutField>:
    3710:	08 8d 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     ................

00003720 <Channel14>:
    3720:	20 cd ee ec e5 f0 20 ea e0 ed e0 eb e0 20 20 20      ..... ......   
    3730:	20 7b 7b 7b 00 de 36 00 00 00 00 20 d1 ee f1 f2      {{{..6.... ....
    3740:	ee ff ed e8 e5 20 e2 f5 ee e4 e0 20 7b 7b 7b 00     ..... ..... {{{.
    3750:	e4 36 00 00 00 00 20 d1 ee f1 f2 ee ff ed e8 e5     .6.... .........
    3760:	20 ea e0 ed e0 eb e0 7b 7b 7b 00 ea 36 00 00 00      ......{{{..6...
    3770:	00 20 d2 e0 ed f2 e8 e4 f0 e5 e1 e5 e7 e3 20 20     . ............  
    3780:	7d 7d 7d 7d 7d 00 00 00 f0 36 00 00 20 d2 e4 ee     }}}}}....6.. ...
    3790:	e7 e2 ee ed e0 20 20 20 20 20 20 7d 7d 7d 7d 7d     .....      }}}}}
    37a0:	00 00 00 00 37 00 00 20 d2 ef ee e2 f2 2e e4 ee     ....7.. ........
    37b0:	e7 e2 ee ed e0 20 7d 7d 7d 7d 7d 00 00 00 10 37     ..... }}}}}....7
	...

000037c2 <Channel14_Page>:
    37c2:	20 37 06 00 00 00 00 00 00 00 00 00 00 00 00 00      7..............
    37d2:	00 00 00 00                                         ....

000037d6 <Channel15_Name_InField>:
    37d6:	00 f2 06 00 00 00                                   ......

000037dc <Channel15_DI_State_InField>:
    37dc:	00 f3 06 00 00 00                                   ......

000037e2 <Channel15_Alarm_State_InField>:
    37e2:	00 f4 06 00 00 00                                   ......

000037e8 <Channel15_debounceTimeout_OutField>:
    37e8:	08 4f 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .O..............

000037f8 <Channel15_calling_delay_OutField>:
    37f8:	08 6f 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .o..............

00003808 <Channel15_calling_retry_delay_OutField>:
    3808:	08 8f 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     ................

00003818 <Channel15>:
    3818:	20 cd ee ec e5 f0 20 ea e0 ed e0 eb e0 20 20 20      ..... ......   
    3828:	20 7b 7b 7b 00 d6 37 00 00 00 00 20 d1 ee f1 f2      {{{..7.... ....
    3838:	ee ff ed e8 e5 20 e2 f5 ee e4 e0 20 7b 7b 7b 00     ..... ..... {{{.
    3848:	dc 37 00 00 00 00 20 d1 ee f1 f2 ee ff ed e8 e5     .7.... .........
    3858:	20 ea e0 ed e0 eb e0 7b 7b 7b 00 e2 37 00 00 00      ......{{{..7...
    3868:	00 20 d2 e0 ed f2 e8 e4 f0 e5 e1 e5 e7 e3 20 20     . ............  
    3878:	7d 7d 7d 7d 7d 00 00 00 e8 37 00 00 20 d2 e4 ee     }}}}}....7.. ...
    3888:	e7 e2 ee ed e0 20 20 20 20 20 20 7d 7d 7d 7d 7d     .....      }}}}}
    3898:	00 00 00 f8 37 00 00 20 d2 ef ee e2 f2 2e e4 ee     ....7.. ........
    38a8:	e7 e2 ee ed e0 20 7d 7d 7d 7d 7d 00 00 00 08 38     ..... }}}}}....8
	...

000038ba <Channel15_Page>:
    38ba:	18 38 06 00 00 00 00 00 00 00 00 00 00 00 00 00     .8..............
    38ca:	00 00 00 00                                         ....

000038ce <ChannelSettingsList>:
    38ce:	20 ca e0 ed e0 eb 20 31 20 20 20 20 20 20 20 20      ..... 1        
    38de:	20 20 20 20 00 00 00 00 00 32 2a 20 ca e0 ed e0         .....2* ....
    38ee:	eb 20 32 20 20 20 20 20 20 20 20 20 20 20 20 00     . 2            .
    38fe:	00 00 00 00 2a 2b 20 ca e0 ed e0 eb 20 33 20 20     ....*+ ..... 3  
    390e:	20 20 20 20 20 20 20 20 20 20 00 00 00 00 00 22               ....."
    391e:	2c 20 ca e0 ed e0 eb 20 34 20 20 20 20 20 20 20     , ..... 4       
    392e:	20 20 20 20 20 00 00 00 00 00 1a 2d 20 ca e0 ed          ......- ...
    393e:	e0 eb 20 35 20 20 20 20 20 20 20 20 20 20 20 20     .. 5            
    394e:	00 00 00 00 00 12 2e 20 ca e0 ed e0 eb 20 36 20     ....... ..... 6 
    395e:	20 20 20 20 20 20 20 20 20 20 20 00 00 00 00 00                .....
    396e:	0a 2f 20 ca e0 ed e0 eb 20 37 20 20 20 20 20 20     ./ ..... 7      
    397e:	20 20 20 20 20 20 00 00 00 00 00 02 30 20 ca e0           ......0 ..
    398e:	ed e0 eb 20 38 20 20 20 20 20 20 20 20 20 20 20     ... 8           
    399e:	20 00 00 00 00 00 fa 30 20 ca e0 ed e0 eb 20 39      ......0 ..... 9
    39ae:	20 20 20 20 20 20 20 20 20 20 20 20 00 00 00 00                 ....
    39be:	00 f2 31 20 ca e0 ed e0 eb 20 31 30 20 20 20 20     ..1 ..... 10    
    39ce:	20 20 20 20 20 20 20 00 00 00 00 00 ea 32 20 ca            ......2 .
    39de:	e0 ed e0 eb 20 31 31 20 20 20 20 20 20 20 20 20     .... 11         
    39ee:	20 20 00 00 00 00 00 e2 33 20 ca e0 ed e0 eb 20       ......3 ..... 
    39fe:	31 32 20 20 20 20 20 20 20 20 20 20 20 00 00 00     12           ...
    3a0e:	00 00 da 34 20 ca e0 ed e0 eb 20 31 33 20 20 20     ...4 ..... 13   
    3a1e:	20 20 20 20 20 20 20 20 00 00 00 00 00 d2 35 20             ......5 
    3a2e:	ca e0 ed e0 eb 20 31 34 20 20 20 20 20 20 20 20     ..... 14        
    3a3e:	20 20 20 00 00 00 00 00 ca 36 20 ca e0 ed e0 eb        ......6 .....
    3a4e:	20 31 35 20 20 20 20 20 20 20 20 20 20 20 00 00      15           ..
    3a5e:	00 00 00 c2 37 20 ca e0 ed e0 eb 20 31 36 20 20     ....7 ..... 16  
    3a6e:	20 20 20 20 20 20 20 20 20 00 00 00 00 00 ba 38              ......8

00003a7e <ChannelSettingsMenu>:
    3a7e:	ce 38 10 00 fe 3b 00 00 00 00 00 00 00 00 00 00     .8...;..........
    3a8e:	00 00 00 00                                         ....

00003a92 <MenuModem>:
    3a92:	81 0f 22 00 fe 3b 00 00 00 00 00 00 00 00 00 00     .."..;..........
    3aa2:	00 00 00 00                                         ....

00003aa6 <Field_TransmitterState>:
    3aa6:	00 b7 06 00 00 00                                   ......

00003aac <CallNum1_OutField>:
    3aac:	22 ec 00 00 00 00 00 06 00 00 00 00 00 00 00 00     "...............

00003abc <CallNum2_OutField>:
    3abc:	22 f9 00 00 00 00 00 06 00 00 00 00 00 00 00 00     "...............

00003acc <CallNum3_OutField>:
    3acc:	22 06 01 00 00 00 00 06 00 00 00 00 00 00 00 00     "...............

00003adc <PhoneNums>:
    3adc:	20 2d cd ee ec e5 f0 e0 20 f2 e5 eb e5 f4 ee ed      -...... .......
    3aec:	ee e2 2d 20 00 00 00 00 00 fe 3b 20 4e 31 3a 2b     ..- ......; N1:+
    3afc:	7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 20 20 20 00     }}}}}}}}}}}}   .
    3b0c:	00 00 ac 3a 00 00 20 4e 32 3a 2b 7d 7d 7d 7d 7d     ...:.. N2:+}}}}}
    3b1c:	7d 7d 7d 7d 7d 7d 7d 20 20 20 00 00 00 bc 3a 00     }}}}}}}   ....:.
    3b2c:	00 20 4e 33 3a 2b 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d     . N3:+}}}}}}}}}}
    3b3c:	7d 7d 20 20 20 00 00 00 cc 3a 00 00                 }}   ....:..

00003b48 <PhoneNums_Page>:
    3b48:	dc 3a 04 00 00 00 00 00 00 00 00 00 00 00 00 00     .:..............
    3b58:	00 00 00 00                                         ....

00003b5c <Menu0List>:
    3b5c:	20 2d 47 53 4d 2d f1 e8 e3 ed e0 eb e8 e7 e0 f2      -GSM-..........
    3b6c:	ee f0 2d 20 00 00 00 00 00 fe 3b 20 d1 eb f3 e6     ..- ......; ....
    3b7c:	e5 e1 ed ee e5 20 20 20 20 20 20 20 20 20 20 00     .....          .
    3b8c:	00 00 00 00 1b 1a 20 cc ee e4 e5 ec 20 20 20 20     ...... .....    
    3b9c:	20 20 20 20 20 20 20 20 20 20 00 00 00 00 00 92               ......
    3bac:	3a 20 cd ee ec e5 f0 e0 20 f2 e5 eb e5 f4 ee ed     : ...... .......
    3bbc:	ee e2 20 20 20 00 00 00 00 00 48 3b 20 cd e0 f1     ..   .....H; ...
    3bcc:	f2 f0 ee e9 ea e0 20 ea e0 ed e0 eb ee e2 20 20     ...... .......  
    3bdc:	00 00 00 00 00 7e 3a 20 d1 ee f1 f2 2e 6f e1 e7     .....~: .....o..
    3bec:	e2 ee ed e0 20 20 20 20 7b 7b 7b 00 a6 3a 00 00     ....    {{{..:..
	...

00003bfe <Menu0>:
    3bfe:	5c 3b 06 00 fe 3b 00 00 00 00 00 00 00 00 00 00     \;...;..........
    3c0e:	00 00 00 00                                         ....

00003c12 <KeyAct.9481>:
    3c12:	00 00 be 4a bf 4a 8c 62 e4 5d 36 66 db 65           ...J.J.b.]6f.e

00003c20 <MaxThermType>:
    3c20:	07 02                                               ..

00003c22 <TerLimType>:
    3c22:	c3 06 e3 06                                         ....

00003c26 <TSM100Tbl>:
    3c26:	00 00 e1 f6 91 08 30 f8 0e 28 18 fc a2 37 0c fe     ......0..(...7..
    3c36:	ea 46 00 00 49 65 e8 03 a6 83 d0 07 ff ff f4 17     .F..Ie..........

00003c46 <TSM50Tbl>:
    3c46:	00 00 df f6 46 04 30 f8 13 0c 24 fa fe 13 18 fc     ....F.0...$.....
    3c56:	c6 1b 0c fe 6b 23 00 00 03 2b f4 01 9a 32 e8 03     ....k#...+...2..
    3c66:	30 3a dc 05 c9 41 d0 07 ff ff bd 38                 0:...A.....8

00003c72 <TSP100Tbl>:
    3c72:	00 00 f6 f5 c2 38 0c fe e2 46 00 00 b6 62 e8 03     .....8...F...b..
    3c82:	96 7d d0 07 ae 97 b8 0b ea b0 a0 0f 54 c9 88 13     .}..........T...
    3c92:	e2 e0 70 17 ff ff 97 1e                             ..p.....

00003c9a <TSP50Tbl>:
    3c9a:	00 00 1f f6 5f 1c 0c fe 56 31 e8 03 d0 3e d0 07     ...._...V1...>..
    3caa:	d2 4b b8 0b 70 58 a0 0f aa 64 88 13 6c 70 70 17     .K..pX...d..lpp.
    3cba:	ff ff 0e 47                                         ...G

00003cbe <Pt100Tbl>:
    3cbe:	00 00 20 f6 fe 38 0c fe 48 62 e8 03 c4 7c d0 07     .. ..8..Hb...|..
    3cce:	6e 96 b8 0b 50 af a0 0f 56 c7 88 13 94 de 70 17     n...P...V.....p.
    3cde:	f6 f4 58 1b ff ff 8b 1f                             ..X.....

00003ce6 <Gr21Tbl>:
    3ce6:	00 00 1e f6 1c 1a 0c fe 64 2d e8 03 c6 39 d0 07     ........d-...9..
    3cf6:	c4 45 b8 0b 68 51 a0 0f 9e 5c 88 13 7a 67 70 17     .E..hQ...\..zgp.
    3d06:	ff ff ce 4f                                         ...O

00003d0a <Gr23Tbl>:
    3d0a:	00 00 d5 f6 7d 1d 0c fe 8b 25 00 00 8f 2d f4 01     ....}....%...-..
    3d1a:	92 35 e8 03 95 3d dc 05 63 42 08 07 ff ff 3e 35     .5...=..cB....>5

00003d2a <TC_B_Tbl>:
    3d2a:	00 00 90 01 99 01 dc 05 7c 07 b8 0b 8e 15 88 13     ........|.......
    3d3a:	1b 1f 70 17 30 2a 58 1b c4 36 40 1f b6 44 28 23     ..p.0*X..6@..D(#
    3d4a:	f2 53 10 27 5a 64 f8 2a d0 75 e0 2e 40 88 c8 32     .S.'Zd.*.u..@..2
    3d5a:	78 9b b0 36 50 af 98 3a 82 c3 80 3e d2 d7 68 42     x..6P..:...>..hB
    3d6a:	ff ff 38 4a                                         ..8J

00003d6e <Mux.8930>:
    3d6e:	06 00 07 00 00 08 01 08 02 08 03 08 04 08 05 08     ................

00003d7e <M.8855>:
    3d7e:	00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f     ................

00003d8e <DI_M>:
    3d8e:	07 01 08 01 06 01 40 00 07 01 08 01 06 01 80 00     ......@.........
    3d9e:	04 01 05 01 03 01 80 00 21 00 22 00 20 00 01 00     ........!.". ...
    3dae:	21 00 22 00 20 00 02 00 21 00 22 00 20 00 04 00     !.". ...!.". ...
    3dbe:	21 00 22 00 20 00 08 00 21 00 22 00 20 00 10 00     !.". ...!.". ...
    3dce:	21 00 22 00 20 00 20 00 21 00 22 00 20 00 40 00     !.". . .!.". .@.
    3dde:	21 00 22 00 20 00 80 00 33 00 34 00 32 00 04 00     !.". ...3.4.2...
    3dee:	04 01 05 01 03 01 40 00 04 01 05 01 03 01 20 00     ......@....... .
    3dfe:	04 01 05 01 03 01 10 00 04 01 05 01 03 01 08 00     ................
    3e0e:	04 01 05 01 03 01 02 01 04 01 05 01 03 01 04 01     ................

00003e1e <__c.6222>:
    3e1e:	2b 50 44 50 00                                      +PDP.

00003e23 <__c.6220>:
    3e23:	43 4c 4f 53 00                                      CLOS.

00003e28 <__c.6218>:
    3e28:	50 4f 53 54 00                                      POST.

00003e2d <__c.6215>:
    3e2d:	47 45 54 20 00                                      GET .

00003e32 <__c.6213>:
    3e32:	0d 0a 00                                            ...

00003e35 <__c.6209>:
    3e35:	2b 43 53 51 3a 20 25 68 68 75 2c 25 68 68 75 00     +CSQ: %hhu,%hhu.

00003e45 <__c.6162>:
    3e45:	25 68 68 75 2c 20 43 4c 4f 53 45 44 00              %hhu, CLOSED.

00003e52 <__c.6156>:
    3e52:	4f 4b 00                                            OK.

00003e55 <__c.6149>:
    3e55:	25 68 68 75 20 25 68 68 75 20 25 68 68 75 20 25     %hhu %hhu %hhu %
    3e65:	68 68 75 00                                         hhu.

00003e69 <__c.6122>:
    3e69:	4e 4f 20 43 41 52 52 49 45 52 00                    NO CARRIER.

00003e74 <__c.6120>:
    3e74:	42 55 53 59 00                                      BUSY.

00003e79 <__c.6118>:
    3e79:	4f 4b 00                                            OK.

00003e7c <__c.6115>:
    3e7c:	2b 43 4c 43 43 3a 20 31 2c 30 2c 36 2c 00           +CLCC: 1,0,6,.

00003e8a <__c.6112>:
    3e8a:	41 54 48 0d 00                                      ATH..

00003e8f <__c.6107>:
    3e8f:	41 54 2b 43 52 45 43 3d 34 2c 22 43 3a 5c 55 73     AT+CREC=4,"C:\Us
    3e9f:	65 72 5c 4e 6f 74 43 6f 6e 66 69 72 6d 2e 61 6d     er\NotConfirm.am
    3eaf:	72 22 2c 30 2c 31 30 30 0d 00                       r",0,100..

00003eb9 <__c.6102>:
    3eb9:	41 54 2b 43 52 45 43 3d 34 2c 22 43 3a 5c 55 73     AT+CREC=4,"C:\Us
    3ec9:	65 72 5c 43 6f 6e 66 69 72 6d 2e 61 6d 72 22 2c     er\Confirm.amr",
    3ed9:	30 2c 31 30 30 0d 00                                0,100..

00003ee0 <__c.6099>:
    3ee0:	2b 43 52 45 43 3a 20 30 00                          +CREC: 0.

00003ee9 <__c.6096>:
    3ee9:	41 54 2b 43 52 45 43 3d 35 0d 00                    AT+CREC=5..

00003ef4 <__c.6093>:
    3ef4:	2b 43 4c 43 43 3a 20 33 2c 30 2c 36 00              +CLCC: 3,0,6.

00003f01 <__c.6091>:
    3f01:	2b 43 4c 43 43 3a 20 32 2c 30 2c 36 00              +CLCC: 2,0,6.

00003f0e <__c.6089>:
    3f0e:	2b 43 4c 43 43 3a 20 31 2c 30 2c 36 00              +CLCC: 1,0,6.

00003f1b <__c.6087>:
    3f1b:	2b 44 54 4d 46 3a 20 31 00                          +DTMF: 1.

00003f24 <__c.6084>:
    3f24:	2b 43 52 45 43 3a 20 30 00                          +CREC: 0.

00003f2d <__c.6080>:
    3f2d:	41 54 2b 43 52 45 43 3d 34 2c 22 43 3a 5c 55 73     AT+CREC=4,"C:\Us
    3f3d:	65 72 5c 43 6f 6e 66 69 72 6d 52 65 71 75 65 73     er\ConfirmReques
    3f4d:	74 2e 61 6d 72 22 2c 30 2c 31 30 30 0d 00           t.amr",0,100..

00003f5b <__c.6077>:
    3f5b:	2b 43 52 45 43 3a 20 30 00                          +CREC: 0.

00003f64 <__c.6073>:
    3f64:	2e 61 6d 72 22 2c 30 2c 31 30 30 0d 00              .amr",0,100..

00003f71 <__c.6071>:
    3f71:	41 54 2b 43 52 45 43 3d 34 2c 22 43 3a 5c 55 73     AT+CREC=4,"C:\Us
    3f81:	65 72 5c 41 6c 61 72 6d 00                          er\Alarm.

00003f8a <__c.6068>:
    3f8a:	2b 43 4c 43 43 3a 20 31 2c 30 2c 36 2c 00           +CLCC: 1,0,6,.

00003f98 <__c.6066>:
    3f98:	2b 43 4c 43 43 3a 20 31 2c 30 2c 36 2c 00           +CLCC: 1,0,6,.

00003fa6 <__c.6064>:
    3fa6:	2b 43 4c 43 43 3a 20 31 2c 30 2c 36 2c 00           +CLCC: 1,0,6,.

00003fb4 <__c.6062>:
    3fb4:	2b 43 4c 43 43 3a 20 31 2c 30 2c 30 2c 00           +CLCC: 1,0,0,.

00003fc2 <__c.6060>:
    3fc2:	2b 43 4c 43 43 3a 20 31 2c 30 2c 30 2c 00           +CLCC: 1,0,0,.

00003fd0 <__c.6058>:
    3fd0:	2b 43 4c 43 43 3a 20 31 2c 30 2c 30 2c 00           +CLCC: 1,0,0,.

00003fde <__c.6055>:
    3fde:	2b 43 4c 43 43 3a 20 33 2c 30 2c 33 2c 00           +CLCC: 3,0,3,.

00003fec <__c.6053>:
    3fec:	2b 43 4c 43 43 3a 20 32 2c 30 2c 33 2c 00           +CLCC: 2,0,3,.

00003ffa <__c.6051>:
    3ffa:	2b 43 4c 43 43 3a 20 31 2c 30 2c 33 2c 00           +CLCC: 1,0,3,.

00004008 <__c.6049>:
    4008:	2b 43 4c 43 43 3a 20 33 2c 30 2c 36 2c 00           +CLCC: 3,0,6,.

00004016 <__c.6047>:
    4016:	2b 43 4c 43 43 3a 20 32 2c 30 2c 36 2c 00           +CLCC: 2,0,6,.

00004024 <__c.6045>:
    4024:	2b 43 4c 43 43 3a 20 31 2c 30 2c 36 2c 00           +CLCC: 1,0,6,.

00004032 <__c.6042>:
    4032:	2b 43 4c 43 43 3a 20 33 2c 30 2c 32 2c 00           +CLCC: 3,0,2,.

00004040 <__c.6040>:
    4040:	2b 43 4c 43 43 3a 20 32 2c 30 2c 32 2c 00           +CLCC: 2,0,2,.

0000404e <__c.6038>:
    404e:	2b 43 4c 43 43 3a 20 31 2c 30 2c 32 2c 00           +CLCC: 1,0,2,.

0000405c <__c.5999>:
    405c:	2b 43 4c 43 43 3a 20 33 2c 30 2c 36 00              +CLCC: 3,0,6.

00004069 <__c.5997>:
    4069:	2b 43 4c 43 43 3a 20 32 2c 30 2c 36 00              +CLCC: 2,0,6.

00004076 <__c.5995>:
    4076:	2b 43 4c 43 43 3a 20 31 2c 30 2c 36 00              +CLCC: 1,0,6.

00004083 <__c.5993>:
    4083:	2b 44 54 4d 46 3a 20 31 00                          +DTMF: 1.

0000408c <MB_Port>:
    408c:	ce 00 c8 00 c9 00 ca 00 cd 00 cc 00 8e 27 94 27     .............'.'
    409c:	98 27 99 27                                         .'.'

000040a0 <MB_Role>:
	...

000040a1 <MB_Timer>:
    40a1:	46 00 47 00 93 31 b2 00 b3 00 9d 31 a4 00 a8 00     F.G..1.....1....
    40b1:	a9 31                                               .1

000040b3 <CGRAM_LCD>:
    40b3:	00 04 06 1f 06 04 00 00 06 09 09 06 00 00 00 00     ................
    40c3:	00 08 08 0e 0f 1f 0f 06 00 00 0e 11 1c 11 0e 00     ................
    40d3:	0e 11 10 1c 10 11 0e 00 0a 00 0c 04 04 04 0e 00     ................
    40e3:	0a 0e 04 04 04 04 0e 00 00 00 00 00 00 00 00 00     ................

000040f3 <Win2LCD>:
    40f3:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    4103:	00 02 ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    4113:	20 21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f      !"#$%&'()*+,-./
    4123:	30 31 32 33 34 35 36 37 38 39 3a 3b 3c 3d 3e 3f     0123456789:;<=>?
    4133:	40 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e 4f     @ABCDEFGHIJKLMNO
    4143:	50 51 52 53 54 55 56 57 58 59 5a 5b 5c 5d 5e 5f     PQRSTUVWXYZ[\]^_
    4153:	60 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e 6f     `abcdefghijklmno
    4163:	70 71 72 73 74 75 76 77 78 79 7a 7b 01 7d e9 7f     pqrstuvwxyz{.}..
    4173:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    4183:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    4193:	ff ff ff ff ff ff ff d9 a2 ff 04 ff ff ff ff 06     ................
    41a3:	ff ff 49 69 ff ff ff da b5 ff 03 ff ff ff ff 05     ..Ii............
    41b3:	41 a0 42 a1 e0 45 a3 a4 a5 a6 4b a7 4d 48 4f a8     A.B..E....K.MHO.
    41c3:	50 43 54 a9 aa 58 e1 ab ac e2 ad ae 62 af b0 b1     PCT..X......b...
    41d3:	61 b2 b3 b4 e3 65 b6 b7 b8 b9 ba bb bc bd 6f be     a....e........o.
    41e3:	70 63 bf 79 e4 78 e5 c0 c1 e6 c2 c3 c4 c5 c6 c7     pc.y.x..........

000041f3 <LineAddr.3690>:
    41f3:	80 c0 94 d4                                         ....

000041f7 <Mux>:
    41f7:	00 01 02 03 04 05 06                                .......

000041fe <aCRCLo.1496>:
    41fe:	00 c0 c1 01 c3 03 02 c2 c6 06 07 c7 05 c5 c4 04     ................
    420e:	cc 0c 0d cd 0f cf ce 0e 0a ca cb 0b c9 09 08 c8     ................
    421e:	d8 18 19 d9 1b db da 1a 1e de df 1f dd 1d 1c dc     ................
    422e:	14 d4 d5 15 d7 17 16 d6 d2 12 13 d3 11 d1 d0 10     ................
    423e:	f0 30 31 f1 33 f3 f2 32 36 f6 f7 37 f5 35 34 f4     .01.3..26..7.54.
    424e:	3c fc fd 3d ff 3f 3e fe fa 3a 3b fb 39 f9 f8 38     <..=.?>..:;.9..8
    425e:	28 e8 e9 29 eb 2b 2a ea ee 2e 2f ef 2d ed ec 2c     (..).+*.../.-..,
    426e:	e4 24 25 e5 27 e7 e6 26 22 e2 e3 23 e1 21 20 e0     .$%.'..&"..#.! .
    427e:	a0 60 61 a1 63 a3 a2 62 66 a6 a7 67 a5 65 64 a4     .`a.c..bf..g.ed.
    428e:	6c ac ad 6d af 6f 6e ae aa 6a 6b ab 69 a9 a8 68     l..m.on..jk.i..h
    429e:	78 b8 b9 79 bb 7b 7a ba be 7e 7f bf 7d bd bc 7c     x..y.{z..~..}..|
    42ae:	b4 74 75 b5 77 b7 b6 76 72 b2 b3 73 b1 71 70 b0     .tu.w..vr..s.qp.
    42be:	50 90 91 51 93 53 52 92 96 56 57 97 55 95 94 54     P..Q.SR..VW.U..T
    42ce:	9c 5c 5d 9d 5f 9f 9e 5e 5a 9a 9b 5b 99 59 58 98     .\]._..^Z..[.YX.
    42de:	88 48 49 89 4b 8b 8a 4a 4e 8e 8f 4f 8d 4d 4c 8c     .HI.K..JN..O.ML.
    42ee:	44 84 85 45 87 47 46 86 82 42 43 83 41 81 80 40     D..E.GF..BC.A..@

000042fe <aCRCHi.1495>:
    42fe:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    430e:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    431e:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    432e:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    433e:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    434e:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    435e:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    436e:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    437e:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    438e:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    439e:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    43ae:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    43be:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    43ce:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    43de:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    43ee:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    43fe:	00 40 7a 10 f3 5a 00 a0 72 4e 18 09 00 10 a5 d4     .@z..Z..rN......
    440e:	e8 00 00 e8 76 48 17 00 00 e4 0b 54 02 00 00 ca     ....vH.....T....
    441e:	9a 3b 00 00 00 e1 f5 05 00 00 80 96 98 00 00 00     .;..............
    442e:	40 42 0f 00 00 00 a0 86 01 00 00 00 10 27 00 00     @B...........'..
    443e:	00 00 e8 03 00 00 00 00 64 00 00 00 00 00 0a 00     ........d.......
    444e:	00 00 00 00 01 00 00 00 00 00 2c 76 d8 88 dc 67     ..........,v...g
    445e:	4f 08 23 df c1 df ae 59 e1 b1 b7 96 e5 e3 e4 53     O.#....Y.......S
    446e:	c6 3a e6 51 99 76 96 e8 e6 c2 84 26 eb 89 8c 9b     .:.Q.v.....&....
    447e:	62 ed 40 7c 6f fc ef bc 9c 9f 40 f2 ba a5 6f a5     b.@|o.....@...o.
    448e:	f4 90 05 5a 2a f7 5c 93 6b 6c f9 67 6d c1 1b fc     ...Z*.\.kl.gm...
    449e:	e0 e4 0d 47 fe f5 20 e6 b5 00 d0 ed 90 2e 03 00     ...G.. .........
    44ae:	94 35 77 05 00 80 84 1e 08 00 00 20 4e 0a 00 00     .5w........ N...
    44be:	00 c8 0c 33 33 33 33 0f 98 6e 12 83 11 41 ef 8d     ...3333..n...A..
    44ce:	21 14 89 3b e6 55 16 cf fe e6 db 18 d1 84 4b 38     !..;.U........K8
    44de:	1b f7 7c 1d 90 1d a4 bb e4 24 20 32 84 72 5e 22     ..|......$ 2.r^"
    44ee:	81 00 c9 f1 24 ec a1 e5 3d 27                       ....$...='

000044f8 <__ctors_end>:
    44f8:	11 24       	eor	r1, r1
    44fa:	1f be       	out	0x3f, r1	; 63
    44fc:	cf ef       	ldi	r28, 0xFF	; 255
    44fe:	d1 e2       	ldi	r29, 0x21	; 33
    4500:	de bf       	out	0x3e, r29	; 62
    4502:	cd bf       	out	0x3d, r28	; 61
    4504:	00 e0       	ldi	r16, 0x00	; 0
    4506:	0c bf       	out	0x3c, r16	; 60

00004508 <__do_copy_data>:
    4508:	12 e0       	ldi	r17, 0x02	; 2
    450a:	a0 e0       	ldi	r26, 0x00	; 0
    450c:	b2 e0       	ldi	r27, 0x02	; 2
    450e:	e4 ed       	ldi	r30, 0xD4	; 212
    4510:	fd e1       	ldi	r31, 0x1D	; 29
    4512:	01 e0       	ldi	r16, 0x01	; 1
    4514:	0b bf       	out	0x3b, r16	; 59
    4516:	02 c0       	rjmp	.+4      	; 0x451c <__do_copy_data+0x14>
    4518:	07 90       	elpm	r0, Z+
    451a:	0d 92       	st	X+, r0
    451c:	aa 3d       	cpi	r26, 0xDA	; 218
    451e:	b1 07       	cpc	r27, r17
    4520:	d9 f7       	brne	.-10     	; 0x4518 <__do_copy_data+0x10>

00004522 <__do_clear_bss>:
    4522:	1c e0       	ldi	r17, 0x0C	; 12
    4524:	aa ed       	ldi	r26, 0xDA	; 218
    4526:	b2 e0       	ldi	r27, 0x02	; 2
    4528:	01 c0       	rjmp	.+2      	; 0x452c <.do_clear_bss_start>

0000452a <.do_clear_bss_loop>:
    452a:	1d 92       	st	X+, r1

0000452c <.do_clear_bss_start>:
    452c:	a4 37       	cpi	r26, 0x74	; 116
    452e:	b1 07       	cpc	r27, r17
    4530:	e1 f7       	brne	.-8      	; 0x452a <.do_clear_bss_loop>
    4532:	0e 94 21 80 	call	0x10042	; 0x10042 <main>
    4536:	0c 94 fd 89 	jmp	0x113fa	; 0x113fa <exit>

0000453a <__bad_interrupt>:
    453a:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000453e <rrb>:
#include <stdint.h>

// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
rrb(const uint8_t *addr)
{
    453e:	fc 01       	movw	r30, r24
	return *addr;
}
    4540:	80 81       	ld	r24, Z
    4542:	08 95       	ret

00004544 <prb>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    4544:	fc 01       	movw	r30, r24
    4546:	84 91       	lpm	r24, Z+
}
    4548:	08 95       	ret

0000454a <prw>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    454a:	fc 01       	movw	r30, r24
    454c:	25 91       	lpm	r18, Z+
    454e:	34 91       	lpm	r19, Z+
}
    4550:	c9 01       	movw	r24, r18
    4552:	08 95       	ret

00004554 <prd>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    4554:	fc 01       	movw	r30, r24
    4556:	25 91       	lpm	r18, Z+
    4558:	35 91       	lpm	r19, Z+
    455a:	45 91       	lpm	r20, Z+
    455c:	54 91       	lpm	r21, Z+
}
    455e:	b9 01       	movw	r22, r18
    4560:	ca 01       	movw	r24, r20
    4562:	08 95       	ret

00004564 <prb_f>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#if FLASHEND>0xFFFF
uint8_t
prb_f(const prog_uint8_t *addr)
{
	return pgm_read_byte_far((uint16_t)addr+0x10000);
    4564:	a0 e0       	ldi	r26, 0x00	; 0
    4566:	b0 e0       	ldi	r27, 0x00	; 0
    4568:	80 50       	subi	r24, 0x00	; 0
    456a:	90 40       	sbci	r25, 0x00	; 0
    456c:	af 4f       	sbci	r26, 0xFF	; 255
    456e:	bf 4f       	sbci	r27, 0xFF	; 255
}
    4570:	ab bf       	out	0x3b, r26	; 59
    4572:	fc 01       	movw	r30, r24
    4574:	87 91       	elpm	r24, Z+
    4576:	08 95       	ret

00004578 <prc>:

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    4578:	fc 01       	movw	r30, r24
    457a:	84 91       	lpm	r24, Z+
}
    457c:	08 95       	ret

0000457e <prp>:

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    457e:	fc 01       	movw	r30, r24
    4580:	25 91       	lpm	r18, Z+
    4582:	34 91       	lpm	r19, Z+
}
    4584:	c9 01       	movw	r24, r18
    4586:	08 95       	ret

00004588 <CRC_Seed>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
CRC_Seed(uint8_t (*GetByte)(const uint8_t*), const uint8_t *Block, uint32_t Sz, uint16_t Seed)
{
    4588:	6f 92       	push	r6
    458a:	7f 92       	push	r7
    458c:	8f 92       	push	r8
    458e:	9f 92       	push	r9
    4590:	af 92       	push	r10
    4592:	bf 92       	push	r11
    4594:	cf 92       	push	r12
    4596:	df 92       	push	r13
    4598:	ef 92       	push	r14
    459a:	ff 92       	push	r15
    459c:	0f 93       	push	r16
    459e:	1f 93       	push	r17
    45a0:	cf 93       	push	r28
    45a2:	df 93       	push	r29
    45a4:	3c 01       	movw	r6, r24
    45a6:	eb 01       	movw	r28, r22
    45a8:	49 01       	movw	r8, r18
    45aa:	5a 01       	movw	r10, r20
    45ac:	c1 2e       	mov	r12, r17
		0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54,
		0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98,
		0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
		0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 0x40
	};
	uint8_t CRCHi=Seed>>8, CRCLo=Seed;
    45ae:	d0 2e       	mov	r13, r16
	for (uint32_t i=0; i<Sz; i++) {
    45b0:	21 15       	cp	r18, r1
    45b2:	31 05       	cpc	r19, r1
    45b4:	41 05       	cpc	r20, r1
    45b6:	51 05       	cpc	r21, r1
    45b8:	f9 f0       	breq	.+62     	; 0x45f8 <CRC_Seed+0x70>
    45ba:	ee 24       	eor	r14, r14
    45bc:	ff 24       	eor	r15, r15
    45be:	87 01       	movw	r16, r14
		uint8_t j = CRCLo^GetByte(Block+i);
    45c0:	ce 01       	movw	r24, r28
    45c2:	8e 0d       	add	r24, r14
    45c4:	9f 1d       	adc	r25, r15
    45c6:	f3 01       	movw	r30, r6
    45c8:	19 95       	eicall
		CRCLo = CRCHi^prb(aCRCHi+j);
    45ca:	d8 26       	eor	r13, r24
    45cc:	2d 2d       	mov	r18, r13
    45ce:	30 e0       	ldi	r19, 0x00	; 0

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    45d0:	c9 01       	movw	r24, r18
    45d2:	82 50       	subi	r24, 0x02	; 2
    45d4:	9d 4b       	sbci	r25, 0xBD	; 189
    45d6:	fc 01       	movw	r30, r24
    45d8:	d4 90       	lpm	r13, Z+
		0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 0x40
	};
	uint8_t CRCHi=Seed>>8, CRCLo=Seed;
	for (uint32_t i=0; i<Sz; i++) {
		uint8_t j = CRCLo^GetByte(Block+i);
		CRCLo = CRCHi^prb(aCRCHi+j);
    45da:	dc 24       	eor	r13, r12

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    45dc:	22 50       	subi	r18, 0x02	; 2
    45de:	3e 4b       	sbci	r19, 0xBE	; 190
    45e0:	f9 01       	movw	r30, r18
    45e2:	c4 90       	lpm	r12, Z+
		0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98,
		0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
		0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 0x40
	};
	uint8_t CRCHi=Seed>>8, CRCLo=Seed;
	for (uint32_t i=0; i<Sz; i++) {
    45e4:	08 94       	sec
    45e6:	e1 1c       	adc	r14, r1
    45e8:	f1 1c       	adc	r15, r1
    45ea:	01 1d       	adc	r16, r1
    45ec:	11 1d       	adc	r17, r1
    45ee:	e8 14       	cp	r14, r8
    45f0:	f9 04       	cpc	r15, r9
    45f2:	0a 05       	cpc	r16, r10
    45f4:	1b 05       	cpc	r17, r11
    45f6:	20 f3       	brcs	.-56     	; 0x45c0 <CRC_Seed+0x38>
    45f8:	9c 2d       	mov	r25, r12
    45fa:	80 e0       	ldi	r24, 0x00	; 0
    45fc:	2d 2d       	mov	r18, r13
    45fe:	30 e0       	ldi	r19, 0x00	; 0
    4600:	28 2b       	or	r18, r24
    4602:	39 2b       	or	r19, r25
		uint8_t j = CRCLo^GetByte(Block+i);
		CRCLo = CRCHi^prb(aCRCHi+j);
		CRCHi = prb(aCRCLo+j);
	}
	return CRCHi<<8|CRCLo;
}
    4604:	c9 01       	movw	r24, r18
    4606:	df 91       	pop	r29
    4608:	cf 91       	pop	r28
    460a:	1f 91       	pop	r17
    460c:	0f 91       	pop	r16
    460e:	ff 90       	pop	r15
    4610:	ef 90       	pop	r14
    4612:	df 90       	pop	r13
    4614:	cf 90       	pop	r12
    4616:	bf 90       	pop	r11
    4618:	af 90       	pop	r10
    461a:	9f 90       	pop	r9
    461c:	8f 90       	pop	r8
    461e:	7f 90       	pop	r7
    4620:	6f 90       	pop	r6
    4622:	08 95       	ret

00004624 <CRC>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
CRC(uint8_t (*GetByte)(const uint8_t*), const uint8_t *Block, uint32_t Sz)
{
    4624:	0f 93       	push	r16
    4626:	1f 93       	push	r17
	return CRC_Seed(GetByte, Block, Sz, 0xFFFF);
    4628:	0f ef       	ldi	r16, 0xFF	; 255
    462a:	1f ef       	ldi	r17, 0xFF	; 255
    462c:	0e 94 c4 22 	call	0x4588	; 0x4588 <CRC_Seed>
}
    4630:	1f 91       	pop	r17
    4632:	0f 91       	pop	r16
    4634:	08 95       	ret

00004636 <CRC_Flash_calc>:

// ~~~~~~~~~~~~~~~~~
static uint16_t
CRC_Flash_calc(void)
{
    4636:	0f 93       	push	r16
    4638:	1f 93       	push	r17
	#if FLASHEND<0xFFFF
		return CRC(prb, NULL, (uint32_t)FLASHEND+1);
	#else
		return CRC_Seed(prb_f, NULL, FLASHEND-0xFFFF, CRC(prb, NULL, 0x10000));
    463a:	82 ea       	ldi	r24, 0xA2	; 162
    463c:	92 e2       	ldi	r25, 0x22	; 34
    463e:	60 e0       	ldi	r22, 0x00	; 0
    4640:	70 e0       	ldi	r23, 0x00	; 0
    4642:	20 e0       	ldi	r18, 0x00	; 0
    4644:	30 e0       	ldi	r19, 0x00	; 0
    4646:	41 e0       	ldi	r20, 0x01	; 1
    4648:	50 e0       	ldi	r21, 0x00	; 0
    464a:	0e 94 12 23 	call	0x4624	; 0x4624 <CRC>
    464e:	8c 01       	movw	r16, r24
    4650:	82 eb       	ldi	r24, 0xB2	; 178
    4652:	92 e2       	ldi	r25, 0x22	; 34
    4654:	60 e0       	ldi	r22, 0x00	; 0
    4656:	70 e0       	ldi	r23, 0x00	; 0
    4658:	20 e0       	ldi	r18, 0x00	; 0
    465a:	30 e0       	ldi	r19, 0x00	; 0
    465c:	43 e0       	ldi	r20, 0x03	; 3
    465e:	50 e0       	ldi	r21, 0x00	; 0
    4660:	0e 94 c4 22 	call	0x4588	; 0x4588 <CRC_Seed>
	#endif
}
    4664:	1f 91       	pop	r17
    4666:	0f 91       	pop	r16
    4668:	08 95       	ret

0000466a <CRC_EEPROM_calc>:

// ~~~~~~~~~~~~~~~~~~
static uint16_t
CRC_EEPROM_calc(void)
{
    466a:	cf 92       	push	r12
    466c:	df 92       	push	r13
    466e:	ef 92       	push	r14
    4670:	ff 92       	push	r15
    4672:	0f 93       	push	r16
    4674:	1f 93       	push	r17
	return
    4676:	90 ef       	ldi	r25, 0xF0	; 240
    4678:	c9 2e       	mov	r12, r25
    467a:	99 e5       	ldi	r25, 0x59	; 89
    467c:	d9 2e       	mov	r13, r25
    467e:	88 e9       	ldi	r24, 0x98	; 152
    4680:	e8 2e       	mov	r14, r24
    4682:	81 e0       	ldi	r24, 0x01	; 1
    4684:	f8 2e       	mov	r15, r24
    4686:	97 01       	movw	r18, r14
    4688:	40 e0       	ldi	r20, 0x00	; 0
    468a:	50 e0       	ldi	r21, 0x00	; 0
    468c:	c6 01       	movw	r24, r12
    468e:	60 e0       	ldi	r22, 0x00	; 0
    4690:	70 e0       	ldi	r23, 0x00	; 0
    4692:	0e 94 12 23 	call	0x4624	; 0x4624 <CRC>
    4696:	8c 01       	movw	r16, r24
    4698:	2b ef       	ldi	r18, 0xFB	; 251
    469a:	3f e0       	ldi	r19, 0x0F	; 15
    469c:	2e 19       	sub	r18, r14
    469e:	3f 09       	sbc	r19, r15
    46a0:	40 e0       	ldi	r20, 0x00	; 0
    46a2:	50 e0       	ldi	r21, 0x00	; 0
    46a4:	c6 01       	movw	r24, r12
    46a6:	65 e0       	ldi	r22, 0x05	; 5
    46a8:	70 e0       	ldi	r23, 0x00	; 0
    46aa:	e6 0e       	add	r14, r22
    46ac:	f7 1e       	adc	r15, r23
    46ae:	b7 01       	movw	r22, r14
    46b0:	0e 94 c4 22 	call	0x4588	; 0x4588 <CRC_Seed>
		CRC_Seed(erb, (uint8_t*)&MemCheck_stor+sizeof(MemCheck_stor), E2END-((uint16_t)&MemCheck_stor-1)-sizeof(MemCheck_stor),
			CRC(erb, NULL, (uint16_t)&MemCheck_stor));
}
    46b4:	1f 91       	pop	r17
    46b6:	0f 91       	pop	r16
    46b8:	ff 90       	pop	r15
    46ba:	ef 90       	pop	r14
    46bc:	df 90       	pop	r13
    46be:	cf 90       	pop	r12
    46c0:	08 95       	ret

000046c2 <InterruInit>:
InterruInit(void)
{
	#ifdef PMIC
		PMIC.CTRL = (uint8_t)(~PMIC_RREN_bm &~PMIC_IVSEL_bm) |PMIC_HILVLEN_bm |PMIC_MEDLVLEN_bm |PMIC_LOLVLEN_bm;
	#endif
	sei();
    46c2:	78 94       	sei
}
    46c4:	08 95       	ret

000046c6 <IntOff>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    46c6:	8f b7       	in	r24, 0x3f	; 63
    46c8:	80 78       	andi	r24, 0x80	; 128
    46ca:	80 93 ee 02 	sts	0x02EE, r24
	cli();
    46ce:	f8 94       	cli
	return interru_enub_flg;
}
    46d0:	08 95       	ret

000046d2 <IntOn>:

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    46d2:	80 91 ee 02 	lds	r24, 0x02EE
    46d6:	88 23       	and	r24, r24
    46d8:	09 f0       	breq	.+2      	; 0x46dc <IntOn+0xa>
		sei();
    46da:	78 94       	sei
	return interru_enub_flg;
}
    46dc:	08 95       	ret

000046de <WdtOn>:

// ~~~~~~~~
void
WdtOn(void)
{
	wdt_reset();
    46de:	a8 95       	wdr
	wdt_enable(WDTO_2S);
    46e0:	2f e0       	ldi	r18, 0x0F	; 15
    46e2:	88 e1       	ldi	r24, 0x18	; 24
    46e4:	90 e0       	ldi	r25, 0x00	; 0
    46e6:	0f b6       	in	r0, 0x3f	; 63
    46e8:	f8 94       	cli
    46ea:	a8 95       	wdr
    46ec:	80 93 60 00 	sts	0x0060, r24
    46f0:	0f be       	out	0x3f, r0	; 63
    46f2:	20 93 60 00 	sts	0x0060, r18
}
    46f6:	08 95       	ret

000046f8 <Timer8_ISR_Alloc>:

// ~~~~~~~~~~~~~~
uint8_t
Timer8_ISR_Alloc(void)
{
	uint8_t N = VacantTimer8_ISR;
    46f8:	80 91 da 02 	lds	r24, 0x02DA
	VacantTimer8_ISR++;
    46fc:	8f 5f       	subi	r24, 0xFF	; 255
    46fe:	80 93 da 02 	sts	0x02DA, r24
    4702:	81 50       	subi	r24, 0x01	; 1
	return N;
}
    4704:	08 95       	ret

00004706 <Timer8Alloc>:

uint8_t
Timer8Alloc(void)
{
	uint8_t N = VacantTimer8;
    4706:	80 91 cc 02 	lds	r24, 0x02CC
	VacantTimer8++;
    470a:	8f 5f       	subi	r24, 0xFF	; 255
    470c:	80 93 cc 02 	sts	0x02CC, r24
    4710:	81 50       	subi	r24, 0x01	; 1
	return N;
}
    4712:	08 95       	ret

00004714 <Timer16Alloc>:

// ~~~~~~~~~~~~~~~
uint8_t
Timer16Alloc(void)
{
	uint8_t N = VacantTimer16;
    4714:	80 91 cd 02 	lds	r24, 0x02CD
	VacantTimer16++;
    4718:	8f 5f       	subi	r24, 0xFF	; 255
    471a:	80 93 cd 02 	sts	0x02CD, r24
    471e:	81 50       	subi	r24, 0x01	; 1
	return N;
}
    4720:	08 95       	ret

00004722 <Timer32Alloc>:

// ~~~~~~~~~~~~~~~
uint8_t
Timer32Alloc(void)
{
	uint8_t N = VacantTimer32;
    4722:	80 91 ce 02 	lds	r24, 0x02CE
	VacantTimer32++;
    4726:	8f 5f       	subi	r24, 0xFF	; 255
    4728:	80 93 ce 02 	sts	0x02CE, r24
    472c:	81 50       	subi	r24, 0x01	; 1
	return N;
}
    472e:	08 95       	ret

00004730 <Timer8_ISR_AppAlloc>:
// ~~~~~~~~~~~~~~

uint8_t
Timer8_ISR_AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    4730:	88 23       	and	r24, r24
    4732:	39 f0       	breq	.+14     	; 0x4742 <Timer8_ISR_AppAlloc+0x12>
	uint8_t N = VacantTimer8_ISR;
    4734:	90 91 da 02 	lds	r25, 0x02DA
	VacantTimer8_ISR+=n;
    4738:	89 0f       	add	r24, r25
    473a:	80 93 da 02 	sts	0x02DA, r24
	return N;
}
    473e:	89 2f       	mov	r24, r25
    4740:	08 95       	ret
// ~~~~~~~~~~~~~~

uint8_t
Timer8_ISR_AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    4742:	90 e0       	ldi	r25, 0x00	; 0
	uint8_t N = VacantTimer8_ISR;
	VacantTimer8_ISR+=n;
	return N;
}
    4744:	89 2f       	mov	r24, r25
    4746:	08 95       	ret

00004748 <Timer8AppAlloc>:

uint8_t
Timer8AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    4748:	88 23       	and	r24, r24
    474a:	39 f0       	breq	.+14     	; 0x475a <Timer8AppAlloc+0x12>
	uint8_t N = VacantTimer8;
    474c:	90 91 cc 02 	lds	r25, 0x02CC
	VacantTimer8+=n;
    4750:	89 0f       	add	r24, r25
    4752:	80 93 cc 02 	sts	0x02CC, r24
	return N;
}
    4756:	89 2f       	mov	r24, r25
    4758:	08 95       	ret
}

uint8_t
Timer8AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    475a:	90 e0       	ldi	r25, 0x00	; 0
	uint8_t N = VacantTimer8;
	VacantTimer8+=n;
	return N;
}
    475c:	89 2f       	mov	r24, r25
    475e:	08 95       	ret

00004760 <Timer16AppAlloc>:

// ~~~~~~~~~~~~~~~
uint8_t
Timer16AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    4760:	88 23       	and	r24, r24
    4762:	39 f0       	breq	.+14     	; 0x4772 <Timer16AppAlloc+0x12>
	uint8_t N = VacantTimer16;
    4764:	90 91 cd 02 	lds	r25, 0x02CD
	VacantTimer16+=n;
    4768:	89 0f       	add	r24, r25
    476a:	80 93 cd 02 	sts	0x02CD, r24
	return N;
}
    476e:	89 2f       	mov	r24, r25
    4770:	08 95       	ret

// ~~~~~~~~~~~~~~~
uint8_t
Timer16AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    4772:	90 e0       	ldi	r25, 0x00	; 0
	uint8_t N = VacantTimer16;
	VacantTimer16+=n;
	return N;
}
    4774:	89 2f       	mov	r24, r25
    4776:	08 95       	ret

00004778 <Timer32AppAlloc>:

// ~~~~~~~~~~~~~~~
uint8_t
Timer32AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    4778:	88 23       	and	r24, r24
    477a:	39 f0       	breq	.+14     	; 0x478a <Timer32AppAlloc+0x12>
	uint8_t N = VacantTimer32;
    477c:	90 91 ce 02 	lds	r25, 0x02CE
	VacantTimer32+=n;
    4780:	89 0f       	add	r24, r25
    4782:	80 93 ce 02 	sts	0x02CE, r24
	return N;
}
    4786:	89 2f       	mov	r24, r25
    4788:	08 95       	ret

// ~~~~~~~~~~~~~~~
uint8_t
Timer32AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    478a:	90 e0       	ldi	r25, 0x00	; 0
	uint8_t N = VacantTimer32;
	VacantTimer32+=n;
	return N;
}
    478c:	89 2f       	mov	r24, r25
    478e:	08 95       	ret

00004790 <Timer8_ISR_SysAlloc>:

// ~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer8_ISR_SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys_ISR;
    4790:	90 91 db 02 	lds	r25, 0x02DB
	VacantTimer8Sys_ISR += n;
    4794:	89 0f       	add	r24, r25
    4796:	80 93 db 02 	sts	0x02DB, r24
	return N;
}
    479a:	89 2f       	mov	r24, r25
    479c:	08 95       	ret

0000479e <Timer8SysAlloc>:

uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    479e:	90 91 cf 02 	lds	r25, 0x02CF
	VacantTimer8Sys += n;
    47a2:	89 0f       	add	r24, r25
    47a4:	80 93 cf 02 	sts	0x02CF, r24
	return N;
}
    47a8:	89 2f       	mov	r24, r25
    47aa:	08 95       	ret

000047ac <Timer16SysAlloc>:

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    47ac:	90 91 d0 02 	lds	r25, 0x02D0
	VacantTimer16Sys += n;
    47b0:	89 0f       	add	r24, r25
    47b2:	80 93 d0 02 	sts	0x02D0, r24
	return N;
}
    47b6:	89 2f       	mov	r24, r25
    47b8:	08 95       	ret

000047ba <Timer32SysAlloc>:

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer32SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer32Sys;
    47ba:	90 91 d1 02 	lds	r25, 0x02D1
	VacantTimer32Sys += n;
    47be:	89 0f       	add	r24, r25
    47c0:	80 93 d1 02 	sts	0x02D1, r24
	return N;
}
    47c4:	89 2f       	mov	r24, r25
    47c6:	08 95       	ret

000047c8 <StartTimer8_ISR>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
StartTimer8_ISR(uint8_t TimerN, uint8_t Timeout)
{
    47c8:	98 2f       	mov	r25, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    47ca:	3f b7       	in	r19, 0x3f	; 63
    47cc:	30 78       	andi	r19, 0x80	; 128
    47ce:	30 93 ee 02 	sts	0x02EE, r19
	cli();
    47d2:	f8 94       	cli
	IntOff();
	if ((Timer8_ISR[TimerN]=Timeout)>0)
    47d4:	48 2f       	mov	r20, r24
    47d6:	50 e0       	ldi	r21, 0x00	; 0
    47d8:	fa 01       	movw	r30, r20
    47da:	e1 51       	subi	r30, 0x11	; 17
    47dc:	fd 4f       	sbci	r31, 0xFD	; 253
    47de:	60 83       	st	Z, r22
    47e0:	80 81       	ld	r24, Z
    47e2:	88 23       	and	r24, r24
    47e4:	c1 f0       	breq	.+48     	; 0x4816 <StartTimer8_ISR+0x4e>
		Timer8_ISR_Flg[TimerN/8] &=~(1<<TimerN%8);
    47e6:	96 95       	lsr	r25
    47e8:	96 95       	lsr	r25
    47ea:	96 95       	lsr	r25
    47ec:	e9 2f       	mov	r30, r25
    47ee:	f0 e0       	ldi	r31, 0x00	; 0
    47f0:	e1 55       	subi	r30, 0x51	; 81
    47f2:	fb 4f       	sbci	r31, 0xFB	; 251
    47f4:	20 81       	ld	r18, Z
    47f6:	47 70       	andi	r20, 0x07	; 7
    47f8:	50 70       	andi	r21, 0x00	; 0
    47fa:	81 e0       	ldi	r24, 0x01	; 1
    47fc:	90 e0       	ldi	r25, 0x00	; 0
    47fe:	02 c0       	rjmp	.+4      	; 0x4804 <StartTimer8_ISR+0x3c>
    4800:	88 0f       	add	r24, r24
    4802:	99 1f       	adc	r25, r25
    4804:	4a 95       	dec	r20
    4806:	e2 f7       	brpl	.-8      	; 0x4800 <StartTimer8_ISR+0x38>
    4808:	80 95       	com	r24
    480a:	82 23       	and	r24, r18
    480c:	80 83       	st	Z, r24

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    480e:	33 23       	and	r19, r19
    4810:	09 f0       	breq	.+2      	; 0x4814 <StartTimer8_ISR+0x4c>
		sei();
    4812:	78 94       	sei
    4814:	08 95       	ret
	else
		Timer8_ISR_Flg[TimerN/8] |=(1<<TimerN%8);
    4816:	96 95       	lsr	r25
    4818:	96 95       	lsr	r25
    481a:	96 95       	lsr	r25
    481c:	e9 2f       	mov	r30, r25
    481e:	f0 e0       	ldi	r31, 0x00	; 0
    4820:	e1 55       	subi	r30, 0x51	; 81
    4822:	fb 4f       	sbci	r31, 0xFB	; 251
    4824:	20 81       	ld	r18, Z
    4826:	47 70       	andi	r20, 0x07	; 7
    4828:	50 70       	andi	r21, 0x00	; 0
    482a:	81 e0       	ldi	r24, 0x01	; 1
    482c:	90 e0       	ldi	r25, 0x00	; 0
    482e:	02 c0       	rjmp	.+4      	; 0x4834 <StartTimer8_ISR+0x6c>
    4830:	88 0f       	add	r24, r24
    4832:	99 1f       	adc	r25, r25
    4834:	4a 95       	dec	r20
    4836:	e2 f7       	brpl	.-8      	; 0x4830 <StartTimer8_ISR+0x68>
    4838:	28 2b       	or	r18, r24
    483a:	20 83       	st	Z, r18
    483c:	e8 cf       	rjmp	.-48     	; 0x480e <StartTimer8_ISR+0x46>

0000483e <StartTimer8>:
}


void
StartTimer8(uint8_t TimerN, uint8_t Timeout)
{
    483e:	98 2f       	mov	r25, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    4840:	3f b7       	in	r19, 0x3f	; 63
    4842:	30 78       	andi	r19, 0x80	; 128
    4844:	30 93 ee 02 	sts	0x02EE, r19
	cli();
    4848:	f8 94       	cli
	IntOff();
	if ((Timer8[TimerN]=Timeout)>0)
    484a:	48 2f       	mov	r20, r24
    484c:	50 e0       	ldi	r21, 0x00	; 0
    484e:	fa 01       	movw	r30, r20
    4850:	e9 50       	subi	r30, 0x09	; 9
    4852:	fd 4f       	sbci	r31, 0xFD	; 253
    4854:	60 83       	st	Z, r22
    4856:	80 81       	ld	r24, Z
    4858:	88 23       	and	r24, r24
    485a:	c1 f0       	breq	.+48     	; 0x488c <StartTimer8+0x4e>
		Timer8Flg[TimerN/8] &=~(1<<TimerN%8);
    485c:	96 95       	lsr	r25
    485e:	96 95       	lsr	r25
    4860:	96 95       	lsr	r25
    4862:	e9 2f       	mov	r30, r25
    4864:	f0 e0       	ldi	r31, 0x00	; 0
    4866:	ef 54       	subi	r30, 0x4F	; 79
    4868:	fb 4f       	sbci	r31, 0xFB	; 251
    486a:	20 81       	ld	r18, Z
    486c:	47 70       	andi	r20, 0x07	; 7
    486e:	50 70       	andi	r21, 0x00	; 0
    4870:	81 e0       	ldi	r24, 0x01	; 1
    4872:	90 e0       	ldi	r25, 0x00	; 0
    4874:	02 c0       	rjmp	.+4      	; 0x487a <StartTimer8+0x3c>
    4876:	88 0f       	add	r24, r24
    4878:	99 1f       	adc	r25, r25
    487a:	4a 95       	dec	r20
    487c:	e2 f7       	brpl	.-8      	; 0x4876 <StartTimer8+0x38>
    487e:	80 95       	com	r24
    4880:	82 23       	and	r24, r18
    4882:	80 83       	st	Z, r24

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    4884:	33 23       	and	r19, r19
    4886:	09 f0       	breq	.+2      	; 0x488a <StartTimer8+0x4c>
		sei();
    4888:	78 94       	sei
    488a:	08 95       	ret
	else
		Timer8Flg[TimerN/8] |=(1<<TimerN%8);
    488c:	96 95       	lsr	r25
    488e:	96 95       	lsr	r25
    4890:	96 95       	lsr	r25
    4892:	e9 2f       	mov	r30, r25
    4894:	f0 e0       	ldi	r31, 0x00	; 0
    4896:	ef 54       	subi	r30, 0x4F	; 79
    4898:	fb 4f       	sbci	r31, 0xFB	; 251
    489a:	20 81       	ld	r18, Z
    489c:	47 70       	andi	r20, 0x07	; 7
    489e:	50 70       	andi	r21, 0x00	; 0
    48a0:	81 e0       	ldi	r24, 0x01	; 1
    48a2:	90 e0       	ldi	r25, 0x00	; 0
    48a4:	02 c0       	rjmp	.+4      	; 0x48aa <StartTimer8+0x6c>
    48a6:	88 0f       	add	r24, r24
    48a8:	99 1f       	adc	r25, r25
    48aa:	4a 95       	dec	r20
    48ac:	e2 f7       	brpl	.-8      	; 0x48a6 <StartTimer8+0x68>
    48ae:	28 2b       	or	r18, r24
    48b0:	20 83       	st	Z, r18
    48b2:	e8 cf       	rjmp	.-48     	; 0x4884 <StartTimer8+0x46>

000048b4 <StartTimer16>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
StartTimer16(uint8_t TimerN, uint16_t Timeout)
{
    48b4:	28 2f       	mov	r18, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    48b6:	3f b7       	in	r19, 0x3f	; 63
    48b8:	30 78       	andi	r19, 0x80	; 128
    48ba:	30 93 ee 02 	sts	0x02EE, r19
	cli();
    48be:	f8 94       	cli
	IntOff();
	if ((Timer16[TimerN]=Timeout)>0)
    48c0:	48 2f       	mov	r20, r24
    48c2:	50 e0       	ldi	r21, 0x00	; 0
    48c4:	fa 01       	movw	r30, r20
    48c6:	ee 0f       	add	r30, r30
    48c8:	ff 1f       	adc	r31, r31
    48ca:	e1 5b       	subi	r30, 0xB1	; 177
    48cc:	fc 4f       	sbci	r31, 0xFC	; 252
    48ce:	71 83       	std	Z+1, r23	; 0x01
    48d0:	60 83       	st	Z, r22
    48d2:	80 81       	ld	r24, Z
    48d4:	91 81       	ldd	r25, Z+1	; 0x01
    48d6:	89 2b       	or	r24, r25
    48d8:	c1 f0       	breq	.+48     	; 0x490a <StartTimer16+0x56>
		Timer16Flg[TimerN/8] &=~(1<<TimerN%8);
    48da:	26 95       	lsr	r18
    48dc:	26 95       	lsr	r18
    48de:	26 95       	lsr	r18
    48e0:	e2 2f       	mov	r30, r18
    48e2:	f0 e0       	ldi	r31, 0x00	; 0
    48e4:	e3 54       	subi	r30, 0x43	; 67
    48e6:	fb 4f       	sbci	r31, 0xFB	; 251
    48e8:	20 81       	ld	r18, Z
    48ea:	47 70       	andi	r20, 0x07	; 7
    48ec:	50 70       	andi	r21, 0x00	; 0
    48ee:	81 e0       	ldi	r24, 0x01	; 1
    48f0:	90 e0       	ldi	r25, 0x00	; 0
    48f2:	02 c0       	rjmp	.+4      	; 0x48f8 <StartTimer16+0x44>
    48f4:	88 0f       	add	r24, r24
    48f6:	99 1f       	adc	r25, r25
    48f8:	4a 95       	dec	r20
    48fa:	e2 f7       	brpl	.-8      	; 0x48f4 <StartTimer16+0x40>
    48fc:	80 95       	com	r24
    48fe:	82 23       	and	r24, r18
    4900:	80 83       	st	Z, r24

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    4902:	33 23       	and	r19, r19
    4904:	09 f0       	breq	.+2      	; 0x4908 <StartTimer16+0x54>
		sei();
    4906:	78 94       	sei
    4908:	08 95       	ret
	else
		Timer16Flg[TimerN/8] |=(1<<TimerN%8);
    490a:	26 95       	lsr	r18
    490c:	26 95       	lsr	r18
    490e:	26 95       	lsr	r18
    4910:	e2 2f       	mov	r30, r18
    4912:	f0 e0       	ldi	r31, 0x00	; 0
    4914:	e3 54       	subi	r30, 0x43	; 67
    4916:	fb 4f       	sbci	r31, 0xFB	; 251
    4918:	20 81       	ld	r18, Z
    491a:	47 70       	andi	r20, 0x07	; 7
    491c:	50 70       	andi	r21, 0x00	; 0
    491e:	81 e0       	ldi	r24, 0x01	; 1
    4920:	90 e0       	ldi	r25, 0x00	; 0
    4922:	02 c0       	rjmp	.+4      	; 0x4928 <StartTimer16+0x74>
    4924:	88 0f       	add	r24, r24
    4926:	99 1f       	adc	r25, r25
    4928:	4a 95       	dec	r20
    492a:	e2 f7       	brpl	.-8      	; 0x4924 <StartTimer16+0x70>
    492c:	28 2b       	or	r18, r24
    492e:	20 83       	st	Z, r18
    4930:	e8 cf       	rjmp	.-48     	; 0x4902 <StartTimer16+0x4e>

00004932 <StartTimer32>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
StartTimer32(uint8_t TimerN, uint32_t Timeout)
{
    4932:	cf 93       	push	r28
    4934:	df 93       	push	r29
    4936:	28 2f       	mov	r18, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    4938:	3f b7       	in	r19, 0x3f	; 63
    493a:	30 78       	andi	r19, 0x80	; 128
    493c:	30 93 ee 02 	sts	0x02EE, r19
	cli();
    4940:	f8 94       	cli
	IntOff();
	if ((Timer32[TimerN]=Timeout)>0)
    4942:	c8 2f       	mov	r28, r24
    4944:	d0 e0       	ldi	r29, 0x00	; 0
    4946:	fe 01       	movw	r30, r28
    4948:	ee 0f       	add	r30, r30
    494a:	ff 1f       	adc	r31, r31
    494c:	ee 0f       	add	r30, r30
    494e:	ff 1f       	adc	r31, r31
    4950:	e1 5f       	subi	r30, 0xF1	; 241
    4952:	fb 4f       	sbci	r31, 0xFB	; 251
    4954:	40 83       	st	Z, r20
    4956:	51 83       	std	Z+1, r21	; 0x01
    4958:	62 83       	std	Z+2, r22	; 0x02
    495a:	73 83       	std	Z+3, r23	; 0x03
    495c:	80 81       	ld	r24, Z
    495e:	91 81       	ldd	r25, Z+1	; 0x01
    4960:	a2 81       	ldd	r26, Z+2	; 0x02
    4962:	b3 81       	ldd	r27, Z+3	; 0x03
    4964:	00 97       	sbiw	r24, 0x00	; 0
    4966:	a1 05       	cpc	r26, r1
    4968:	b1 05       	cpc	r27, r1
    496a:	d1 f0       	breq	.+52     	; 0x49a0 <StartTimer32+0x6e>
		Timer32Flg[TimerN/8] &=~(1<<TimerN%8);
    496c:	26 95       	lsr	r18
    496e:	26 95       	lsr	r18
    4970:	26 95       	lsr	r18
    4972:	e2 2f       	mov	r30, r18
    4974:	f0 e0       	ldi	r31, 0x00	; 0
    4976:	e6 53       	subi	r30, 0x36	; 54
    4978:	fb 4f       	sbci	r31, 0xFB	; 251
    497a:	20 81       	ld	r18, Z
    497c:	c7 70       	andi	r28, 0x07	; 7
    497e:	d0 70       	andi	r29, 0x00	; 0
    4980:	81 e0       	ldi	r24, 0x01	; 1
    4982:	90 e0       	ldi	r25, 0x00	; 0
    4984:	02 c0       	rjmp	.+4      	; 0x498a <StartTimer32+0x58>
    4986:	88 0f       	add	r24, r24
    4988:	99 1f       	adc	r25, r25
    498a:	ca 95       	dec	r28
    498c:	e2 f7       	brpl	.-8      	; 0x4986 <StartTimer32+0x54>
    498e:	80 95       	com	r24
    4990:	82 23       	and	r24, r18
    4992:	80 83       	st	Z, r24

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    4994:	33 23       	and	r19, r19
    4996:	09 f0       	breq	.+2      	; 0x499a <StartTimer32+0x68>
		sei();
    4998:	78 94       	sei
	else
		Timer32Flg[TimerN/8] |=(1<<TimerN%8);
	IntOn();
}
    499a:	df 91       	pop	r29
    499c:	cf 91       	pop	r28
    499e:	08 95       	ret
{
	IntOff();
	if ((Timer32[TimerN]=Timeout)>0)
		Timer32Flg[TimerN/8] &=~(1<<TimerN%8);
	else
		Timer32Flg[TimerN/8] |=(1<<TimerN%8);
    49a0:	26 95       	lsr	r18
    49a2:	26 95       	lsr	r18
    49a4:	26 95       	lsr	r18
    49a6:	e2 2f       	mov	r30, r18
    49a8:	f0 e0       	ldi	r31, 0x00	; 0
    49aa:	e6 53       	subi	r30, 0x36	; 54
    49ac:	fb 4f       	sbci	r31, 0xFB	; 251
    49ae:	20 81       	ld	r18, Z
    49b0:	c7 70       	andi	r28, 0x07	; 7
    49b2:	d0 70       	andi	r29, 0x00	; 0
    49b4:	81 e0       	ldi	r24, 0x01	; 1
    49b6:	90 e0       	ldi	r25, 0x00	; 0
    49b8:	02 c0       	rjmp	.+4      	; 0x49be <StartTimer32+0x8c>
    49ba:	88 0f       	add	r24, r24
    49bc:	99 1f       	adc	r25, r25
    49be:	ca 95       	dec	r28
    49c0:	e2 f7       	brpl	.-8      	; 0x49ba <StartTimer32+0x88>
    49c2:	28 2b       	or	r18, r24
    49c4:	20 83       	st	Z, r18
    49c6:	e6 cf       	rjmp	.-52     	; 0x4994 <StartTimer32+0x62>

000049c8 <StopTimer8_ISR>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    49c8:	4f b7       	in	r20, 0x3f	; 63
    49ca:	40 78       	andi	r20, 0x80	; 128
    49cc:	40 93 ee 02 	sts	0x02EE, r20
	cli();
    49d0:	f8 94       	cli
// ~~~~~~~~~~~~~~~~~~~~~~~
void
StopTimer8_ISR(uint8_t TimerN)
{
	IntOff();
	Timer8_ISR_Flg[TimerN/8] |=(1<<TimerN%8);
    49d2:	e8 2f       	mov	r30, r24
    49d4:	e6 95       	lsr	r30
    49d6:	e6 95       	lsr	r30
    49d8:	e6 95       	lsr	r30
    49da:	f0 e0       	ldi	r31, 0x00	; 0
    49dc:	e1 55       	subi	r30, 0x51	; 81
    49de:	fb 4f       	sbci	r31, 0xFB	; 251
    49e0:	90 81       	ld	r25, Z
    49e2:	87 70       	andi	r24, 0x07	; 7
    49e4:	21 e0       	ldi	r18, 0x01	; 1
    49e6:	30 e0       	ldi	r19, 0x00	; 0
    49e8:	02 c0       	rjmp	.+4      	; 0x49ee <StopTimer8_ISR+0x26>
    49ea:	22 0f       	add	r18, r18
    49ec:	33 1f       	adc	r19, r19
    49ee:	8a 95       	dec	r24
    49f0:	e2 f7       	brpl	.-8      	; 0x49ea <StopTimer8_ISR+0x22>
    49f2:	92 2b       	or	r25, r18
    49f4:	90 83       	st	Z, r25

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    49f6:	44 23       	and	r20, r20
    49f8:	09 f0       	breq	.+2      	; 0x49fc <StopTimer8_ISR+0x34>
		sei();
    49fa:	78 94       	sei
    49fc:	08 95       	ret

000049fe <StopTimer8>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    49fe:	4f b7       	in	r20, 0x3f	; 63
    4a00:	40 78       	andi	r20, 0x80	; 128
    4a02:	40 93 ee 02 	sts	0x02EE, r20
	cli();
    4a06:	f8 94       	cli

void
StopTimer8(uint8_t TimerN)
{
	IntOff();
	Timer8Flg[TimerN/8] |=(1<<TimerN%8);
    4a08:	e8 2f       	mov	r30, r24
    4a0a:	e6 95       	lsr	r30
    4a0c:	e6 95       	lsr	r30
    4a0e:	e6 95       	lsr	r30
    4a10:	f0 e0       	ldi	r31, 0x00	; 0
    4a12:	ef 54       	subi	r30, 0x4F	; 79
    4a14:	fb 4f       	sbci	r31, 0xFB	; 251
    4a16:	90 81       	ld	r25, Z
    4a18:	87 70       	andi	r24, 0x07	; 7
    4a1a:	21 e0       	ldi	r18, 0x01	; 1
    4a1c:	30 e0       	ldi	r19, 0x00	; 0
    4a1e:	02 c0       	rjmp	.+4      	; 0x4a24 <StopTimer8+0x26>
    4a20:	22 0f       	add	r18, r18
    4a22:	33 1f       	adc	r19, r19
    4a24:	8a 95       	dec	r24
    4a26:	e2 f7       	brpl	.-8      	; 0x4a20 <StopTimer8+0x22>
    4a28:	92 2b       	or	r25, r18
    4a2a:	90 83       	st	Z, r25

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    4a2c:	44 23       	and	r20, r20
    4a2e:	09 f0       	breq	.+2      	; 0x4a32 <StopTimer8+0x34>
		sei();
    4a30:	78 94       	sei
    4a32:	08 95       	ret

00004a34 <StopTimer16>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    4a34:	4f b7       	in	r20, 0x3f	; 63
    4a36:	40 78       	andi	r20, 0x80	; 128
    4a38:	40 93 ee 02 	sts	0x02EE, r20
	cli();
    4a3c:	f8 94       	cli
// ~~~~~~~~~~~~~~~~~~~~~~~~
void
StopTimer16(uint8_t TimerN)
{
	IntOff();
	Timer16Flg[TimerN/8] |=1<<TimerN%8;
    4a3e:	e8 2f       	mov	r30, r24
    4a40:	e6 95       	lsr	r30
    4a42:	e6 95       	lsr	r30
    4a44:	e6 95       	lsr	r30
    4a46:	f0 e0       	ldi	r31, 0x00	; 0
    4a48:	e3 54       	subi	r30, 0x43	; 67
    4a4a:	fb 4f       	sbci	r31, 0xFB	; 251
    4a4c:	90 81       	ld	r25, Z
    4a4e:	87 70       	andi	r24, 0x07	; 7
    4a50:	21 e0       	ldi	r18, 0x01	; 1
    4a52:	30 e0       	ldi	r19, 0x00	; 0
    4a54:	02 c0       	rjmp	.+4      	; 0x4a5a <StopTimer16+0x26>
    4a56:	22 0f       	add	r18, r18
    4a58:	33 1f       	adc	r19, r19
    4a5a:	8a 95       	dec	r24
    4a5c:	e2 f7       	brpl	.-8      	; 0x4a56 <StopTimer16+0x22>
    4a5e:	92 2b       	or	r25, r18
    4a60:	90 83       	st	Z, r25

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    4a62:	44 23       	and	r20, r20
    4a64:	09 f0       	breq	.+2      	; 0x4a68 <StopTimer16+0x34>
		sei();
    4a66:	78 94       	sei
    4a68:	08 95       	ret

00004a6a <StopTimer32>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    4a6a:	4f b7       	in	r20, 0x3f	; 63
    4a6c:	40 78       	andi	r20, 0x80	; 128
    4a6e:	40 93 ee 02 	sts	0x02EE, r20
	cli();
    4a72:	f8 94       	cli
// ~~~~~~~~~~~~~~~~~~~~~~~~
void
StopTimer32(uint8_t TimerN)
{
	IntOff();
	Timer32Flg[TimerN/8] |=1<<TimerN%8;
    4a74:	e8 2f       	mov	r30, r24
    4a76:	e6 95       	lsr	r30
    4a78:	e6 95       	lsr	r30
    4a7a:	e6 95       	lsr	r30
    4a7c:	f0 e0       	ldi	r31, 0x00	; 0
    4a7e:	e6 53       	subi	r30, 0x36	; 54
    4a80:	fb 4f       	sbci	r31, 0xFB	; 251
    4a82:	90 81       	ld	r25, Z
    4a84:	87 70       	andi	r24, 0x07	; 7
    4a86:	21 e0       	ldi	r18, 0x01	; 1
    4a88:	30 e0       	ldi	r19, 0x00	; 0
    4a8a:	02 c0       	rjmp	.+4      	; 0x4a90 <StopTimer32+0x26>
    4a8c:	22 0f       	add	r18, r18
    4a8e:	33 1f       	adc	r19, r19
    4a90:	8a 95       	dec	r24
    4a92:	e2 f7       	brpl	.-8      	; 0x4a8c <StopTimer32+0x22>
    4a94:	92 2b       	or	r25, r18
    4a96:	90 83       	st	Z, r25

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    4a98:	44 23       	and	r20, r20
    4a9a:	09 f0       	breq	.+2      	; 0x4a9e <StopTimer32+0x34>
		sei();
    4a9c:	78 94       	sei
    4a9e:	08 95       	ret

00004aa0 <Timer8Stopp_ISR>:
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer8Stopp_ISR(uint8_t TimerN)
{
	return (Timer8_ISR_Flg[TimerN/8] &(1<<TimerN%8)) && Timer8_ISR[TimerN]==0;
    4aa0:	e8 2f       	mov	r30, r24
    4aa2:	e6 95       	lsr	r30
    4aa4:	e6 95       	lsr	r30
    4aa6:	e6 95       	lsr	r30
    4aa8:	f0 e0       	ldi	r31, 0x00	; 0
    4aaa:	e1 55       	subi	r30, 0x51	; 81
    4aac:	fb 4f       	sbci	r31, 0xFB	; 251
    4aae:	20 81       	ld	r18, Z
    4ab0:	e8 2f       	mov	r30, r24
    4ab2:	f0 e0       	ldi	r31, 0x00	; 0
    4ab4:	30 e0       	ldi	r19, 0x00	; 0
    4ab6:	cf 01       	movw	r24, r30
    4ab8:	87 70       	andi	r24, 0x07	; 7
    4aba:	90 70       	andi	r25, 0x00	; 0
    4abc:	02 c0       	rjmp	.+4      	; 0x4ac2 <Timer8Stopp_ISR+0x22>
    4abe:	35 95       	asr	r19
    4ac0:	27 95       	ror	r18
    4ac2:	8a 95       	dec	r24
    4ac4:	e2 f7       	brpl	.-8      	; 0x4abe <Timer8Stopp_ISR+0x1e>
    4ac6:	20 fd       	sbrc	r18, 0
    4ac8:	02 c0       	rjmp	.+4      	; 0x4ace <Timer8Stopp_ISR+0x2e>
    4aca:	80 e0       	ldi	r24, 0x00	; 0
    4acc:	08 95       	ret
    4ace:	e1 51       	subi	r30, 0x11	; 17
    4ad0:	fd 4f       	sbci	r31, 0xFD	; 253
    4ad2:	90 81       	ld	r25, Z
    4ad4:	99 23       	and	r25, r25
    4ad6:	19 f4       	brne	.+6      	; 0x4ade <Timer8Stopp_ISR+0x3e>
    4ad8:	81 e0       	ldi	r24, 0x01	; 1
    4ada:	89 27       	eor	r24, r25
}
    4adc:	08 95       	ret
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer8Stopp_ISR(uint8_t TimerN)
{
	return (Timer8_ISR_Flg[TimerN/8] &(1<<TimerN%8)) && Timer8_ISR[TimerN]==0;
    4ade:	91 e0       	ldi	r25, 0x01	; 1
    4ae0:	81 e0       	ldi	r24, 0x01	; 1
    4ae2:	89 27       	eor	r24, r25
}
    4ae4:	08 95       	ret

00004ae6 <Timer8Stopp>:

// ~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer8Stopp(uint8_t TimerN)
{
	return (Timer8Flg[TimerN/8] &(1<<TimerN%8)) && Timer8[TimerN]==0;
    4ae6:	e8 2f       	mov	r30, r24
    4ae8:	e6 95       	lsr	r30
    4aea:	e6 95       	lsr	r30
    4aec:	e6 95       	lsr	r30
    4aee:	f0 e0       	ldi	r31, 0x00	; 0
    4af0:	ef 54       	subi	r30, 0x4F	; 79
    4af2:	fb 4f       	sbci	r31, 0xFB	; 251
    4af4:	20 81       	ld	r18, Z
    4af6:	e8 2f       	mov	r30, r24
    4af8:	f0 e0       	ldi	r31, 0x00	; 0
    4afa:	30 e0       	ldi	r19, 0x00	; 0
    4afc:	cf 01       	movw	r24, r30
    4afe:	87 70       	andi	r24, 0x07	; 7
    4b00:	90 70       	andi	r25, 0x00	; 0
    4b02:	02 c0       	rjmp	.+4      	; 0x4b08 <Timer8Stopp+0x22>
    4b04:	35 95       	asr	r19
    4b06:	27 95       	ror	r18
    4b08:	8a 95       	dec	r24
    4b0a:	e2 f7       	brpl	.-8      	; 0x4b04 <Timer8Stopp+0x1e>
    4b0c:	20 fd       	sbrc	r18, 0
    4b0e:	02 c0       	rjmp	.+4      	; 0x4b14 <Timer8Stopp+0x2e>
    4b10:	80 e0       	ldi	r24, 0x00	; 0
    4b12:	08 95       	ret
    4b14:	e9 50       	subi	r30, 0x09	; 9
    4b16:	fd 4f       	sbci	r31, 0xFD	; 253
    4b18:	90 81       	ld	r25, Z
    4b1a:	99 23       	and	r25, r25
    4b1c:	19 f4       	brne	.+6      	; 0x4b24 <Timer8Stopp+0x3e>
    4b1e:	81 e0       	ldi	r24, 0x01	; 1
    4b20:	89 27       	eor	r24, r25
}
    4b22:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer8Stopp(uint8_t TimerN)
{
	return (Timer8Flg[TimerN/8] &(1<<TimerN%8)) && Timer8[TimerN]==0;
    4b24:	91 e0       	ldi	r25, 0x01	; 1
    4b26:	81 e0       	ldi	r24, 0x01	; 1
    4b28:	89 27       	eor	r24, r25
}
    4b2a:	08 95       	ret

00004b2c <Timer16Stopp>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    4b2c:	4f b7       	in	r20, 0x3f	; 63
    4b2e:	40 78       	andi	r20, 0x80	; 128
    4b30:	40 93 ee 02 	sts	0x02EE, r20
	cli();
    4b34:	f8 94       	cli
// ~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16Stopp(uint8_t TimerN)
{
	IntOff();
	uint8_t T_S = (Timer16Flg[TimerN/8] &(1<<TimerN%8)) && Timer16[TimerN]==0;
    4b36:	e8 2f       	mov	r30, r24
    4b38:	e6 95       	lsr	r30
    4b3a:	e6 95       	lsr	r30
    4b3c:	e6 95       	lsr	r30
    4b3e:	f0 e0       	ldi	r31, 0x00	; 0
    4b40:	e3 54       	subi	r30, 0x43	; 67
    4b42:	fb 4f       	sbci	r31, 0xFB	; 251
    4b44:	20 81       	ld	r18, Z
    4b46:	e8 2f       	mov	r30, r24
    4b48:	f0 e0       	ldi	r31, 0x00	; 0
    4b4a:	30 e0       	ldi	r19, 0x00	; 0
    4b4c:	cf 01       	movw	r24, r30
    4b4e:	87 70       	andi	r24, 0x07	; 7
    4b50:	90 70       	andi	r25, 0x00	; 0
    4b52:	02 c0       	rjmp	.+4      	; 0x4b58 <Timer16Stopp+0x2c>
    4b54:	35 95       	asr	r19
    4b56:	27 95       	ror	r18
    4b58:	8a 95       	dec	r24
    4b5a:	e2 f7       	brpl	.-8      	; 0x4b54 <Timer16Stopp+0x28>
    4b5c:	20 fd       	sbrc	r18, 0
    4b5e:	06 c0       	rjmp	.+12     	; 0x4b6c <Timer16Stopp+0x40>
    4b60:	20 e0       	ldi	r18, 0x00	; 0

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    4b62:	44 23       	and	r20, r20
    4b64:	09 f0       	breq	.+2      	; 0x4b68 <Timer16Stopp+0x3c>
		sei();
    4b66:	78 94       	sei
	IntOn();
	return T_S;
}
    4b68:	82 2f       	mov	r24, r18
    4b6a:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16Stopp(uint8_t TimerN)
{
	IntOff();
	uint8_t T_S = (Timer16Flg[TimerN/8] &(1<<TimerN%8)) && Timer16[TimerN]==0;
    4b6c:	ee 0f       	add	r30, r30
    4b6e:	ff 1f       	adc	r31, r31
    4b70:	e1 5b       	subi	r30, 0xB1	; 177
    4b72:	fc 4f       	sbci	r31, 0xFC	; 252
    4b74:	80 81       	ld	r24, Z
    4b76:	91 81       	ldd	r25, Z+1	; 0x01
    4b78:	20 e0       	ldi	r18, 0x00	; 0
    4b7a:	89 2b       	or	r24, r25
    4b7c:	19 f4       	brne	.+6      	; 0x4b84 <Timer16Stopp+0x58>
    4b7e:	81 e0       	ldi	r24, 0x01	; 1
    4b80:	28 27       	eor	r18, r24
    4b82:	ef cf       	rjmp	.-34     	; 0x4b62 <Timer16Stopp+0x36>
    4b84:	21 e0       	ldi	r18, 0x01	; 1
    4b86:	81 e0       	ldi	r24, 0x01	; 1
    4b88:	28 27       	eor	r18, r24
    4b8a:	eb cf       	rjmp	.-42     	; 0x4b62 <Timer16Stopp+0x36>

00004b8c <Timer32Stopp>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    4b8c:	4f b7       	in	r20, 0x3f	; 63
    4b8e:	40 78       	andi	r20, 0x80	; 128
    4b90:	40 93 ee 02 	sts	0x02EE, r20
	cli();
    4b94:	f8 94       	cli
// ~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer32Stopp(uint8_t TimerN)
{
	IntOff();
	uint8_t T_S = (Timer32Flg[TimerN/8] &(1<<TimerN%8)) && Timer32[TimerN]==0;
    4b96:	e8 2f       	mov	r30, r24
    4b98:	e6 95       	lsr	r30
    4b9a:	e6 95       	lsr	r30
    4b9c:	e6 95       	lsr	r30
    4b9e:	f0 e0       	ldi	r31, 0x00	; 0
    4ba0:	e6 53       	subi	r30, 0x36	; 54
    4ba2:	fb 4f       	sbci	r31, 0xFB	; 251
    4ba4:	20 81       	ld	r18, Z
    4ba6:	e8 2f       	mov	r30, r24
    4ba8:	f0 e0       	ldi	r31, 0x00	; 0
    4baa:	30 e0       	ldi	r19, 0x00	; 0
    4bac:	cf 01       	movw	r24, r30
    4bae:	87 70       	andi	r24, 0x07	; 7
    4bb0:	90 70       	andi	r25, 0x00	; 0
    4bb2:	02 c0       	rjmp	.+4      	; 0x4bb8 <Timer32Stopp+0x2c>
    4bb4:	35 95       	asr	r19
    4bb6:	27 95       	ror	r18
    4bb8:	8a 95       	dec	r24
    4bba:	e2 f7       	brpl	.-8      	; 0x4bb4 <Timer32Stopp+0x28>
    4bbc:	20 fd       	sbrc	r18, 0
    4bbe:	06 c0       	rjmp	.+12     	; 0x4bcc <Timer32Stopp+0x40>
    4bc0:	20 e0       	ldi	r18, 0x00	; 0

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    4bc2:	44 23       	and	r20, r20
    4bc4:	09 f0       	breq	.+2      	; 0x4bc8 <Timer32Stopp+0x3c>
		sei();
    4bc6:	78 94       	sei
	IntOn();
	return T_S;
}
    4bc8:	82 2f       	mov	r24, r18
    4bca:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer32Stopp(uint8_t TimerN)
{
	IntOff();
	uint8_t T_S = (Timer32Flg[TimerN/8] &(1<<TimerN%8)) && Timer32[TimerN]==0;
    4bcc:	ee 0f       	add	r30, r30
    4bce:	ff 1f       	adc	r31, r31
    4bd0:	ee 0f       	add	r30, r30
    4bd2:	ff 1f       	adc	r31, r31
    4bd4:	e1 5f       	subi	r30, 0xF1	; 241
    4bd6:	fb 4f       	sbci	r31, 0xFB	; 251
    4bd8:	80 81       	ld	r24, Z
    4bda:	91 81       	ldd	r25, Z+1	; 0x01
    4bdc:	a2 81       	ldd	r26, Z+2	; 0x02
    4bde:	b3 81       	ldd	r27, Z+3	; 0x03
    4be0:	20 e0       	ldi	r18, 0x00	; 0
    4be2:	00 97       	sbiw	r24, 0x00	; 0
    4be4:	a1 05       	cpc	r26, r1
    4be6:	b1 05       	cpc	r27, r1
    4be8:	19 f4       	brne	.+6      	; 0x4bf0 <Timer32Stopp+0x64>
    4bea:	81 e0       	ldi	r24, 0x01	; 1
    4bec:	28 27       	eor	r18, r24
    4bee:	e9 cf       	rjmp	.-46     	; 0x4bc2 <Timer32Stopp+0x36>
    4bf0:	21 e0       	ldi	r18, 0x01	; 1
    4bf2:	81 e0       	ldi	r24, 0x01	; 1
    4bf4:	28 27       	eor	r18, r24
    4bf6:	e5 cf       	rjmp	.-54     	; 0x4bc2 <Timer32Stopp+0x36>

00004bf8 <ResetTimer8_ISR>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    4bf8:	5f b7       	in	r21, 0x3f	; 63
    4bfa:	50 78       	andi	r21, 0x80	; 128
    4bfc:	50 93 ee 02 	sts	0x02EE, r21
	cli();
    4c00:	f8 94       	cli
//~~~~~~~~~~~~~~~~~~~~~~~~~
void
ResetTimer8_ISR(uint8_t TimerN)
{
	IntOff();
	Timer8_ISR_Flg[TimerN/8] |=(1<<TimerN%8);
    4c02:	e8 2f       	mov	r30, r24
    4c04:	e6 95       	lsr	r30
    4c06:	e6 95       	lsr	r30
    4c08:	e6 95       	lsr	r30
    4c0a:	f0 e0       	ldi	r31, 0x00	; 0
    4c0c:	e1 55       	subi	r30, 0x51	; 81
    4c0e:	fb 4f       	sbci	r31, 0xFB	; 251
    4c10:	40 81       	ld	r20, Z
    4c12:	a8 2f       	mov	r26, r24
    4c14:	b0 e0       	ldi	r27, 0x00	; 0
    4c16:	9d 01       	movw	r18, r26
    4c18:	27 70       	andi	r18, 0x07	; 7
    4c1a:	30 70       	andi	r19, 0x00	; 0
    4c1c:	81 e0       	ldi	r24, 0x01	; 1
    4c1e:	90 e0       	ldi	r25, 0x00	; 0
    4c20:	02 c0       	rjmp	.+4      	; 0x4c26 <ResetTimer8_ISR+0x2e>
    4c22:	88 0f       	add	r24, r24
    4c24:	99 1f       	adc	r25, r25
    4c26:	2a 95       	dec	r18
    4c28:	e2 f7       	brpl	.-8      	; 0x4c22 <ResetTimer8_ISR+0x2a>
    4c2a:	48 2b       	or	r20, r24
    4c2c:	40 83       	st	Z, r20

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    4c2e:	55 23       	and	r21, r21
    4c30:	09 f0       	breq	.+2      	; 0x4c34 <ResetTimer8_ISR+0x3c>
		sei();
    4c32:	78 94       	sei
	IntOn();
	Timer8_ISR[TimerN] = 0;
    4c34:	a1 51       	subi	r26, 0x11	; 17
    4c36:	bd 4f       	sbci	r27, 0xFD	; 253
    4c38:	1c 92       	st	X, r1
}
    4c3a:	08 95       	ret

00004c3c <ResetTimer8>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    4c3c:	5f b7       	in	r21, 0x3f	; 63
    4c3e:	50 78       	andi	r21, 0x80	; 128
    4c40:	50 93 ee 02 	sts	0x02EE, r21
	cli();
    4c44:	f8 94       	cli

void
ResetTimer8(uint8_t TimerN)
{
	IntOff();
	Timer8Flg[TimerN/8] |=(1<<TimerN%8);
    4c46:	e8 2f       	mov	r30, r24
    4c48:	e6 95       	lsr	r30
    4c4a:	e6 95       	lsr	r30
    4c4c:	e6 95       	lsr	r30
    4c4e:	f0 e0       	ldi	r31, 0x00	; 0
    4c50:	ef 54       	subi	r30, 0x4F	; 79
    4c52:	fb 4f       	sbci	r31, 0xFB	; 251
    4c54:	40 81       	ld	r20, Z
    4c56:	a8 2f       	mov	r26, r24
    4c58:	b0 e0       	ldi	r27, 0x00	; 0
    4c5a:	9d 01       	movw	r18, r26
    4c5c:	27 70       	andi	r18, 0x07	; 7
    4c5e:	30 70       	andi	r19, 0x00	; 0
    4c60:	81 e0       	ldi	r24, 0x01	; 1
    4c62:	90 e0       	ldi	r25, 0x00	; 0
    4c64:	02 c0       	rjmp	.+4      	; 0x4c6a <ResetTimer8+0x2e>
    4c66:	88 0f       	add	r24, r24
    4c68:	99 1f       	adc	r25, r25
    4c6a:	2a 95       	dec	r18
    4c6c:	e2 f7       	brpl	.-8      	; 0x4c66 <ResetTimer8+0x2a>
    4c6e:	48 2b       	or	r20, r24
    4c70:	40 83       	st	Z, r20

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    4c72:	55 23       	and	r21, r21
    4c74:	09 f0       	breq	.+2      	; 0x4c78 <ResetTimer8+0x3c>
		sei();
    4c76:	78 94       	sei
	IntOn();
	Timer8[TimerN] = 0;
    4c78:	a9 50       	subi	r26, 0x09	; 9
    4c7a:	bd 4f       	sbci	r27, 0xFD	; 253
    4c7c:	1c 92       	st	X, r1
}
    4c7e:	08 95       	ret

00004c80 <ResetTimer16>:

//~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ResetTimer16(uint8_t TimerN)
{
    4c80:	e8 2f       	mov	r30, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    4c82:	5f b7       	in	r21, 0x3f	; 63
    4c84:	50 78       	andi	r21, 0x80	; 128
    4c86:	50 93 ee 02 	sts	0x02EE, r21
	cli();
    4c8a:	f8 94       	cli
	IntOff();
	Timer16Flg[TimerN/8] |=1<<TimerN%8;
    4c8c:	a8 2f       	mov	r26, r24
    4c8e:	a6 95       	lsr	r26
    4c90:	a6 95       	lsr	r26
    4c92:	a6 95       	lsr	r26
    4c94:	b0 e0       	ldi	r27, 0x00	; 0
    4c96:	a3 54       	subi	r26, 0x43	; 67
    4c98:	bb 4f       	sbci	r27, 0xFB	; 251
    4c9a:	4c 91       	ld	r20, X
    4c9c:	f0 e0       	ldi	r31, 0x00	; 0
    4c9e:	9f 01       	movw	r18, r30
    4ca0:	27 70       	andi	r18, 0x07	; 7
    4ca2:	30 70       	andi	r19, 0x00	; 0
    4ca4:	81 e0       	ldi	r24, 0x01	; 1
    4ca6:	90 e0       	ldi	r25, 0x00	; 0
    4ca8:	02 c0       	rjmp	.+4      	; 0x4cae <ResetTimer16+0x2e>
    4caa:	88 0f       	add	r24, r24
    4cac:	99 1f       	adc	r25, r25
    4cae:	2a 95       	dec	r18
    4cb0:	e2 f7       	brpl	.-8      	; 0x4caa <ResetTimer16+0x2a>
    4cb2:	48 2b       	or	r20, r24
    4cb4:	4c 93       	st	X, r20
	Timer16[TimerN] = 0;
    4cb6:	ee 0f       	add	r30, r30
    4cb8:	ff 1f       	adc	r31, r31
    4cba:	e1 5b       	subi	r30, 0xB1	; 177
    4cbc:	fc 4f       	sbci	r31, 0xFC	; 252
    4cbe:	11 82       	std	Z+1, r1	; 0x01
    4cc0:	10 82       	st	Z, r1

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    4cc2:	55 23       	and	r21, r21
    4cc4:	09 f0       	breq	.+2      	; 0x4cc8 <ResetTimer16+0x48>
		sei();
    4cc6:	78 94       	sei
    4cc8:	08 95       	ret

00004cca <ResetTimer32>:
}

//~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ResetTimer32(uint8_t TimerN)
{
    4cca:	e8 2f       	mov	r30, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    4ccc:	5f b7       	in	r21, 0x3f	; 63
    4cce:	50 78       	andi	r21, 0x80	; 128
    4cd0:	50 93 ee 02 	sts	0x02EE, r21
	cli();
    4cd4:	f8 94       	cli
	IntOff();
	Timer32Flg[TimerN/8] |=1<<TimerN%8;
    4cd6:	a8 2f       	mov	r26, r24
    4cd8:	a6 95       	lsr	r26
    4cda:	a6 95       	lsr	r26
    4cdc:	a6 95       	lsr	r26
    4cde:	b0 e0       	ldi	r27, 0x00	; 0
    4ce0:	a6 53       	subi	r26, 0x36	; 54
    4ce2:	bb 4f       	sbci	r27, 0xFB	; 251
    4ce4:	4c 91       	ld	r20, X
    4ce6:	f0 e0       	ldi	r31, 0x00	; 0
    4ce8:	9f 01       	movw	r18, r30
    4cea:	27 70       	andi	r18, 0x07	; 7
    4cec:	30 70       	andi	r19, 0x00	; 0
    4cee:	81 e0       	ldi	r24, 0x01	; 1
    4cf0:	90 e0       	ldi	r25, 0x00	; 0
    4cf2:	02 c0       	rjmp	.+4      	; 0x4cf8 <ResetTimer32+0x2e>
    4cf4:	88 0f       	add	r24, r24
    4cf6:	99 1f       	adc	r25, r25
    4cf8:	2a 95       	dec	r18
    4cfa:	e2 f7       	brpl	.-8      	; 0x4cf4 <ResetTimer32+0x2a>
    4cfc:	48 2b       	or	r20, r24
    4cfe:	4c 93       	st	X, r20
	Timer32[TimerN] = 0;
    4d00:	ee 0f       	add	r30, r30
    4d02:	ff 1f       	adc	r31, r31
    4d04:	ee 0f       	add	r30, r30
    4d06:	ff 1f       	adc	r31, r31
    4d08:	e1 5f       	subi	r30, 0xF1	; 241
    4d0a:	fb 4f       	sbci	r31, 0xFB	; 251
    4d0c:	10 82       	st	Z, r1
    4d0e:	11 82       	std	Z+1, r1	; 0x01
    4d10:	12 82       	std	Z+2, r1	; 0x02
    4d12:	13 82       	std	Z+3, r1	; 0x03

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    4d14:	55 23       	and	r21, r21
    4d16:	09 f0       	breq	.+2      	; 0x4d1a <ResetTimer32+0x50>
		sei();
    4d18:	78 94       	sei
    4d1a:	08 95       	ret

00004d1c <GetTimer8_ISR>:

// ~~~~~~~~~~~~~~~~~~~~~~
uint8_t
GetTimer8_ISR(uint8_t TimerN)
{
	return Timer8_ISR[TimerN];
    4d1c:	ef ee       	ldi	r30, 0xEF	; 239
    4d1e:	f2 e0       	ldi	r31, 0x02	; 2
    4d20:	e8 0f       	add	r30, r24
    4d22:	f1 1d       	adc	r31, r1
    4d24:	80 81       	ld	r24, Z
}
    4d26:	08 95       	ret

00004d28 <GetTimer8>:
uint8_t
GetTimer8(uint8_t TimerN)
{
	return Timer8[TimerN];
    4d28:	e7 ef       	ldi	r30, 0xF7	; 247
    4d2a:	f2 e0       	ldi	r31, 0x02	; 2
    4d2c:	e8 0f       	add	r30, r24
    4d2e:	f1 1d       	adc	r31, r1
    4d30:	80 81       	ld	r24, Z
}
    4d32:	08 95       	ret

00004d34 <GetTimer16>:

// ~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
GetTimer16(uint8_t TimerN)
{
    4d34:	e8 2f       	mov	r30, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    4d36:	8f b7       	in	r24, 0x3f	; 63
    4d38:	80 78       	andi	r24, 0x80	; 128
    4d3a:	80 93 ee 02 	sts	0x02EE, r24
	cli();
    4d3e:	f8 94       	cli
	IntOff();
	uint16_t Time = Timer16[TimerN];
    4d40:	f0 e0       	ldi	r31, 0x00	; 0
    4d42:	ee 0f       	add	r30, r30
    4d44:	ff 1f       	adc	r31, r31
    4d46:	e1 5b       	subi	r30, 0xB1	; 177
    4d48:	fc 4f       	sbci	r31, 0xFC	; 252
    4d4a:	01 90       	ld	r0, Z+
    4d4c:	f0 81       	ld	r31, Z
    4d4e:	e0 2d       	mov	r30, r0

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    4d50:	88 23       	and	r24, r24
    4d52:	09 f0       	breq	.+2      	; 0x4d56 <GetTimer16+0x22>
		sei();
    4d54:	78 94       	sei
	IntOn();
	return Time;
}
    4d56:	cf 01       	movw	r24, r30
    4d58:	08 95       	ret

00004d5a <GetTimer32>:

// ~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
GetTimer32(uint8_t TimerN)
{
    4d5a:	e8 2f       	mov	r30, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    4d5c:	8f b7       	in	r24, 0x3f	; 63
    4d5e:	80 78       	andi	r24, 0x80	; 128
    4d60:	80 93 ee 02 	sts	0x02EE, r24
	cli();
    4d64:	f8 94       	cli
	IntOff();
	uint32_t Time = Timer32[TimerN];
    4d66:	f0 e0       	ldi	r31, 0x00	; 0
    4d68:	ee 0f       	add	r30, r30
    4d6a:	ff 1f       	adc	r31, r31
    4d6c:	ee 0f       	add	r30, r30
    4d6e:	ff 1f       	adc	r31, r31
    4d70:	e1 5f       	subi	r30, 0xF1	; 241
    4d72:	fb 4f       	sbci	r31, 0xFB	; 251
    4d74:	20 81       	ld	r18, Z
    4d76:	31 81       	ldd	r19, Z+1	; 0x01
    4d78:	42 81       	ldd	r20, Z+2	; 0x02
    4d7a:	53 81       	ldd	r21, Z+3	; 0x03

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    4d7c:	88 23       	and	r24, r24
    4d7e:	09 f0       	breq	.+2      	; 0x4d82 <GetTimer32+0x28>
		sei();
    4d80:	78 94       	sei
	IntOn();
	return Time;
}
    4d82:	b9 01       	movw	r22, r18
    4d84:	ca 01       	movw	r24, r20
    4d86:	08 95       	ret

00004d88 <TimerAllocError>:
// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t TimerAllocError(void){
	return ( (VacantTimer8Sys >=  Timer8TotNumber) || (VacantTimer16Sys >=  Timer16TotNumber) || (VacantTimer32Sys >=  Timer32TotNumber) ||
    4d88:	80 91 cf 02 	lds	r24, 0x02CF
    4d8c:	88 35       	cpi	r24, 0x58	; 88
    4d8e:	a8 f4       	brcc	.+42     	; 0x4dba <TimerAllocError+0x32>
    4d90:	80 91 d0 02 	lds	r24, 0x02D0
    4d94:	80 36       	cpi	r24, 0x60	; 96
    4d96:	88 f4       	brcc	.+34     	; 0x4dba <TimerAllocError+0x32>
    4d98:	80 91 d1 02 	lds	r24, 0x02D1
    4d9c:	88 32       	cpi	r24, 0x28	; 40
    4d9e:	68 f4       	brcc	.+26     	; 0x4dba <TimerAllocError+0x32>
    4da0:	80 91 cc 02 	lds	r24, 0x02CC
    4da4:	80 34       	cpi	r24, 0x40	; 64
    4da6:	48 f4       	brcc	.+18     	; 0x4dba <TimerAllocError+0x32>
    4da8:	80 91 cd 02 	lds	r24, 0x02CD
    4dac:	88 34       	cpi	r24, 0x48	; 72
    4dae:	28 f4       	brcc	.+10     	; 0x4dba <TimerAllocError+0x32>
    4db0:	90 e0       	ldi	r25, 0x00	; 0
    4db2:	80 91 ce 02 	lds	r24, 0x02CE
    4db6:	80 32       	cpi	r24, 0x20	; 32
    4db8:	08 f0       	brcs	.+2      	; 0x4dbc <TimerAllocError+0x34>
    4dba:	91 e0       	ldi	r25, 0x01	; 1
		 Timer8AllocErr() || Timer16AllocErr() || Timer32AllocErr() );
}
    4dbc:	89 2f       	mov	r24, r25
    4dbe:	08 95       	ret

00004dc0 <ScanCycleInit>:
}

uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    4dc0:	80 91 cf 02 	lds	r24, 0x02CF
	VacantTimer8Sys += n;
    4dc4:	8f 5f       	subi	r24, 0xFF	; 255
    4dc6:	80 93 cf 02 	sts	0x02CF, r24
    4dca:	81 50       	subi	r24, 0x01	; 1

// ~~~~~~~~~~~~~~~~
void
ScanCycleInit(void)
{
	TD_Scan = Timer8SysAlloc(1);
    4dcc:	80 93 d0 04 	sts	0x04D0, r24
	StartTimer8(TD_Scan, 0xFF);
    4dd0:	6f ef       	ldi	r22, 0xFF	; 255
    4dd2:	0e 94 1f 24 	call	0x483e	; 0x483e <StartTimer8>
}
    4dd6:	08 95       	ret

00004dd8 <__vector_17>:
#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
	ISR(TIMER1_COMPA_vect)
#elif defined (__AVR_ATxmega128A1__)
	ISR(TCC0_OVF_vect)
#endif
{
    4dd8:	1f 92       	push	r1
    4dda:	0f 92       	push	r0
    4ddc:	0f b6       	in	r0, 0x3f	; 63
    4dde:	0f 92       	push	r0
    4de0:	0b b6       	in	r0, 0x3b	; 59
    4de2:	0f 92       	push	r0
    4de4:	11 24       	eor	r1, r1
    4de6:	2f 93       	push	r18
    4de8:	4f 93       	push	r20
    4dea:	5f 93       	push	r21
    4dec:	6f 93       	push	r22
    4dee:	7f 93       	push	r23
    4df0:	8f 93       	push	r24
    4df2:	9f 93       	push	r25
    4df4:	af 93       	push	r26
    4df6:	bf 93       	push	r27
    4df8:	ef 93       	push	r30
    4dfa:	ff 93       	push	r31
	TickCounter++;
    4dfc:	80 91 d1 04 	lds	r24, 0x04D1
    4e00:	8f 5f       	subi	r24, 0xFF	; 255
    4e02:	80 93 d1 04 	sts	0x04D1, r24
    4e06:	40 e0       	ldi	r20, 0x00	; 0
    4e08:	50 e0       	ldi	r21, 0x00	; 0
	uint8_t i;
	for (i=0; i<Timer8_ISR_TotNumber; i++)
			if (!(Timer8_ISR_Flg[i/8] &(1<<i%8)) && --Timer8_ISR[i]==0)
				Timer8_ISR_Flg[i/8] |=(1<<i%8);
    4e0a:	a1 e0       	ldi	r26, 0x01	; 1
    4e0c:	b0 e0       	ldi	r27, 0x00	; 0
#endif
{
	TickCounter++;
	uint8_t i;
	for (i=0; i<Timer8_ISR_TotNumber; i++)
			if (!(Timer8_ISR_Flg[i/8] &(1<<i%8)) && --Timer8_ISR[i]==0)
    4e0e:	80 91 af 04 	lds	r24, 0x04AF
    4e12:	ba 01       	movw	r22, r20
    4e14:	67 70       	andi	r22, 0x07	; 7
    4e16:	70 70       	andi	r23, 0x00	; 0
    4e18:	90 e0       	ldi	r25, 0x00	; 0
    4e1a:	06 2e       	mov	r0, r22
    4e1c:	02 c0       	rjmp	.+4      	; 0x4e22 <__vector_17+0x4a>
    4e1e:	95 95       	asr	r25
    4e20:	87 95       	ror	r24
    4e22:	0a 94       	dec	r0
    4e24:	e2 f7       	brpl	.-8      	; 0x4e1e <__vector_17+0x46>
    4e26:	80 fd       	sbrc	r24, 0
    4e28:	14 c0       	rjmp	.+40     	; 0x4e52 <__vector_17+0x7a>
    4e2a:	fa 01       	movw	r30, r20
    4e2c:	e1 51       	subi	r30, 0x11	; 17
    4e2e:	fd 4f       	sbci	r31, 0xFD	; 253
    4e30:	80 81       	ld	r24, Z
    4e32:	81 50       	subi	r24, 0x01	; 1
    4e34:	80 83       	st	Z, r24
    4e36:	80 81       	ld	r24, Z
    4e38:	88 23       	and	r24, r24
    4e3a:	59 f4       	brne	.+22     	; 0x4e52 <__vector_17+0x7a>
				Timer8_ISR_Flg[i/8] |=(1<<i%8);
    4e3c:	20 91 af 04 	lds	r18, 0x04AF
    4e40:	cd 01       	movw	r24, r26
    4e42:	02 c0       	rjmp	.+4      	; 0x4e48 <__vector_17+0x70>
    4e44:	88 0f       	add	r24, r24
    4e46:	99 1f       	adc	r25, r25
    4e48:	6a 95       	dec	r22
    4e4a:	e2 f7       	brpl	.-8      	; 0x4e44 <__vector_17+0x6c>
    4e4c:	28 2b       	or	r18, r24
    4e4e:	20 93 af 04 	sts	0x04AF, r18
    4e52:	4f 5f       	subi	r20, 0xFF	; 255
    4e54:	5f 4f       	sbci	r21, 0xFF	; 255
	ISR(TCC0_OVF_vect)
#endif
{
	TickCounter++;
	uint8_t i;
	for (i=0; i<Timer8_ISR_TotNumber; i++)
    4e56:	48 30       	cpi	r20, 0x08	; 8
    4e58:	51 05       	cpc	r21, r1
    4e5a:	c9 f6       	brne	.-78     	; 0x4e0e <__vector_17+0x36>
				Timer8_ISR_Flg[i/8] |=(1<<i%8);

	#ifdef HIGH_SPEED_COUNTER
		HSC_Process();
	#endif
}
    4e5c:	ff 91       	pop	r31
    4e5e:	ef 91       	pop	r30
    4e60:	bf 91       	pop	r27
    4e62:	af 91       	pop	r26
    4e64:	9f 91       	pop	r25
    4e66:	8f 91       	pop	r24
    4e68:	7f 91       	pop	r23
    4e6a:	6f 91       	pop	r22
    4e6c:	5f 91       	pop	r21
    4e6e:	4f 91       	pop	r20
    4e70:	2f 91       	pop	r18
    4e72:	0f 90       	pop	r0
    4e74:	0b be       	out	0x3b, r0	; 59
    4e76:	0f 90       	pop	r0
    4e78:	0f be       	out	0x3f, r0	; 63
    4e7a:	0f 90       	pop	r0
    4e7c:	1f 90       	pop	r1
    4e7e:	18 95       	reti

00004e80 <TimeCycle>:
// ~~~~~~~~~~~~
void
TimeCycle(void)
{
	// WDT
	wdt_reset();
    4e80:	a8 95       	wdr

	// Scan cycle
	ScanCount++;
    4e82:	80 91 b2 07 	lds	r24, 0x07B2
    4e86:	90 91 b3 07 	lds	r25, 0x07B3
    4e8a:	01 96       	adiw	r24, 0x01	; 1
    4e8c:	90 93 b3 07 	sts	0x07B3, r25
    4e90:	80 93 b2 07 	sts	0x07B2, r24
	if ((ScanCycle=0xFF-Timer8[TD_Scan])>MaxScanCycle)
    4e94:	90 91 d0 04 	lds	r25, 0x04D0
    4e98:	e9 2f       	mov	r30, r25
    4e9a:	f0 e0       	ldi	r31, 0x00	; 0
    4e9c:	e9 50       	subi	r30, 0x09	; 9
    4e9e:	fd 4f       	sbci	r31, 0xFD	; 253
    4ea0:	e0 81       	ld	r30, Z
    4ea2:	e0 95       	com	r30
    4ea4:	e0 93 ae 07 	sts	0x07AE, r30
    4ea8:	80 91 b1 06 	lds	r24, 0x06B1
    4eac:	8e 17       	cp	r24, r30
    4eae:	10 f4       	brcc	.+4      	; 0x4eb4 <TimeCycle+0x34>
		MaxScanCycle = ScanCycle;
    4eb0:	e0 93 b1 06 	sts	0x06B1, r30
	StartTimer8(TD_Scan, 0xFF);
    4eb4:	89 2f       	mov	r24, r25
    4eb6:	6f ef       	ldi	r22, 0xFF	; 255
    4eb8:	0e 94 1f 24 	call	0x483e	; 0x483e <StartTimer8>
}
    4ebc:	08 95       	ret

00004ebe <MaxScanCycle_Clear>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
void
MaxScanCycle_Clear(void)
{
	MaxScanCycle = 0;
    4ebe:	10 92 b1 06 	sts	0x06B1, r1
}
    4ec2:	08 95       	ret

00004ec4 <Delay_ms>:

// ~~~~~~~~~~~~~~~~~~~~
void
Delay_ms(uint8_t Delay)
{
	while (Delay--)
    4ec4:	88 23       	and	r24, r24
    4ec6:	39 f0       	breq	.+14     	; 0x4ed6 <Delay_ms+0x12>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    4ec8:	20 ea       	ldi	r18, 0xA0	; 160
    4eca:	3f e0       	ldi	r19, 0x0F	; 15
    4ecc:	f9 01       	movw	r30, r18
    4ece:	31 97       	sbiw	r30, 0x01	; 1
    4ed0:	f1 f7       	brne	.-4      	; 0x4ece <Delay_ms+0xa>
    4ed2:	81 50       	subi	r24, 0x01	; 1
    4ed4:	d9 f7       	brne	.-10     	; 0x4ecc <Delay_ms+0x8>
    4ed6:	08 95       	ret

00004ed8 <Delay_us>:
{
	/*uint8_t i;
	for(i=Delay/Delay_us_Max; i; i--)
		_delay_us(Delay_us_Max);*/
	//_delay_us(Delay%Delay_us_Max);
	Delay *= .8;	// By trial
    4ed8:	a0 e0       	ldi	r26, 0x00	; 0
    4eda:	b0 e0       	ldi	r27, 0x00	; 0
    4edc:	bc 01       	movw	r22, r24
    4ede:	cd 01       	movw	r24, r26
    4ee0:	0e 94 0c 89 	call	0x11218	; 0x11218 <__floatunsisf>
    4ee4:	2d ec       	ldi	r18, 0xCD	; 205
    4ee6:	3c ec       	ldi	r19, 0xCC	; 204
    4ee8:	4c e4       	ldi	r20, 0x4C	; 76
    4eea:	5f e3       	ldi	r21, 0x3F	; 63
    4eec:	0e 94 49 89 	call	0x11292	; 0x11292 <__mulsf3>
    4ef0:	0e 94 e1 8d 	call	0x11bc2	; 0x11bc2 <__fixunssfsi>
    4ef4:	cb 01       	movw	r24, r22
	while (Delay--)
    4ef6:	67 2b       	or	r22, r23
    4ef8:	31 f0       	breq	.+12     	; 0x4f06 <Delay_us+0x2e>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    4efa:	35 e0       	ldi	r19, 0x05	; 5
    4efc:	23 2f       	mov	r18, r19
    4efe:	2a 95       	dec	r18
    4f00:	f1 f7       	brne	.-4      	; 0x4efe <Delay_us+0x26>
    4f02:	01 97       	sbiw	r24, 0x01	; 1
    4f04:	d9 f7       	brne	.-10     	; 0x4efc <Delay_us+0x24>
    4f06:	08 95       	ret

00004f08 <MB_PLC_Init>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#if defined vmd2_3
	void MB_PLC_Init(void)
	{
		// RS485
		DDRE |=(1<<PE2); PORTE &=~(1<<PE2);
    4f08:	6a 9a       	sbi	0x0d, 2	; 13
    4f0a:	72 98       	cbi	0x0e, 2	; 14
		DDRD |=(1<<PD4); PORTD &=~(1<<PD4);
    4f0c:	54 9a       	sbi	0x0a, 4	; 10
    4f0e:	5c 98       	cbi	0x0b, 4	; 11
	#ifndef GSM
		DDRL |=(1<<PL5); PORTL &=~(1<<PL5);
	#endif
	}
    4f10:	08 95       	ret

00004f12 <RS485_0>:
	void RS485_0(void) {PORTE ^=(1<<PE2);}
    4f12:	8e b1       	in	r24, 0x0e	; 14
    4f14:	94 e0       	ldi	r25, 0x04	; 4
    4f16:	89 27       	eor	r24, r25
    4f18:	8e b9       	out	0x0e, r24	; 14
    4f1a:	08 95       	ret

00004f1c <RS485_1>:
	void RS485_1(void) {PORTD ^=(1<<PD4);}
    4f1c:	8b b1       	in	r24, 0x0b	; 11
    4f1e:	90 e1       	ldi	r25, 0x10	; 16
    4f20:	89 27       	eor	r24, r25
    4f22:	8b b9       	out	0x0b, r24	; 11
    4f24:	08 95       	ret

00004f26 <MB_LED0>:
	}
	void RS485_0(void) {PORTE ^=(1<<PE2);}
	void RS485_1(void) {PORTC ^=(1<<PC0);}
#endif

void MB_LED0(void) {}
    4f26:	08 95       	ret

00004f28 <MB_LED1>:
void MB_LED1(void) {}
    4f28:	08 95       	ret

00004f2a <MB_LED2>:
void MB_LED2(void) {}
    4f2a:	08 95       	ret

00004f2c <MB_LED_Err_On_0>:

void MB_LED_Err_On_0(void)	{}
    4f2c:	08 95       	ret

00004f2e <MB_LED_Err_Off_0>:
void MB_LED_Err_Off_0(void)	{}
    4f2e:	08 95       	ret

00004f30 <MB_LED_Err_On_1>:
void MB_LED_Err_On_1(void)	{}
    4f30:	08 95       	ret

00004f32 <MB_LED_Err_Off_1>:
void MB_LED_Err_Off_1(void)	{}	
    4f32:	08 95       	ret

00004f34 <MB_LED_Err_On_2>:
void MB_LED_Err_On_2(void)	{}
    4f34:	08 95       	ret

00004f36 <MB_LED_Err_Off_2>:
void MB_LED_Err_Off_2(void)	{}
    4f36:	08 95       	ret

00004f38 <PWM_Init>:

// ~~~~~~~~~~~
void
PWM_Init(void)
{
	TCCR3A = (1<<COM3A1) | (0<<COM3A0) | (1<<COM3B1) | (0<<COM3B0) | (0<<COM3C1) | (0<<COM3C0) | (1<<WGM31) | (0<<WGM30);
    4f38:	32 ea       	ldi	r19, 0xA2	; 162
    4f3a:	30 93 90 00 	sts	0x0090, r19
	TCCR3B = (0<<CS32) | (0<<CS31) | (1<<CS30) | (1<<WGM33) | (1<<WGM32);	// Fpwm = 244Hz
    4f3e:	29 e1       	ldi	r18, 0x19	; 25
    4f40:	20 93 91 00 	sts	0x0091, r18
	ICR3 = PWM_PERIOD_TC3;
    4f44:	8f ef       	ldi	r24, 0xFF	; 255
    4f46:	9f ef       	ldi	r25, 0xFF	; 255
    4f48:	90 93 97 00 	sts	0x0097, r25
    4f4c:	80 93 96 00 	sts	0x0096, r24
	DDRE |= (1<<PE3) | (1<<PE4);
    4f50:	8d b1       	in	r24, 0x0d	; 13
    4f52:	88 61       	ori	r24, 0x18	; 24
    4f54:	8d b9       	out	0x0d, r24	; 13

	TCCR5A = (1<<COM5A1) | (0<<COM5A0) | (1<<COM5B1) | (0<<COM5B0) | (0<<COM5C1) | (0<<COM5C0) | (1<<WGM51) | (0<<WGM50);
    4f56:	30 93 20 01 	sts	0x0120, r19
	TCCR5B = (0<<CS52) | (0<<CS51) | (1<<CS50) | (1<<WGM53) | (1<<WGM52);	// Fpwm = 244Hz
    4f5a:	20 93 21 01 	sts	0x0121, r18
	ICR5 = PWM_PERIOD_TC5;
    4f5e:	8e e7       	ldi	r24, 0x7E	; 126
    4f60:	9c e0       	ldi	r25, 0x0C	; 12
    4f62:	90 93 27 01 	sts	0x0127, r25
    4f66:	80 93 26 01 	sts	0x0126, r24
	DDRL |= (1<<PL3) | (1<<PL4);
    4f6a:	ea e0       	ldi	r30, 0x0A	; 10
    4f6c:	f1 e0       	ldi	r31, 0x01	; 1
    4f6e:	80 81       	ld	r24, Z
    4f70:	88 61       	ori	r24, 0x18	; 24
    4f72:	80 83       	st	Z, r24
}
    4f74:	08 95       	ret

00004f76 <PWM_Out>:
void
PWM_Out(void)
{
	uint16_t Buf;

	Buf = Coef_AO_PWM_TC3*DAC_Output[0];
    4f76:	60 91 d2 07 	lds	r22, 0x07D2
    4f7a:	70 91 d3 07 	lds	r23, 0x07D3
    4f7e:	80 e0       	ldi	r24, 0x00	; 0
    4f80:	90 e0       	ldi	r25, 0x00	; 0
    4f82:	0e 94 0c 89 	call	0x11218	; 0x11218 <__floatunsisf>
    4f86:	28 e8       	ldi	r18, 0x88	; 136
    4f88:	3f e1       	ldi	r19, 0x1F	; 31
    4f8a:	40 e8       	ldi	r20, 0x80	; 128
    4f8c:	52 e4       	ldi	r21, 0x42	; 66
    4f8e:	0e 94 49 89 	call	0x11292	; 0x11292 <__mulsf3>
    4f92:	0e 94 e1 8d 	call	0x11bc2	; 0x11bc2 <__fixunssfsi>
    4f96:	26 2f       	mov	r18, r22

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    4f98:	9f b7       	in	r25, 0x3f	; 63
	cli();
    4f9a:	f8 94       	cli
	IntOff();
	OCR3AH = Buf>>8;
    4f9c:	70 93 99 00 	sts	0x0099, r23
	OCR3AL = Buf;
    4fa0:	20 93 98 00 	sts	0x0098, r18

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    4fa4:	97 ff       	sbrs	r25, 7
    4fa6:	01 c0       	rjmp	.+2      	; 0x4faa <PWM_Out+0x34>
		sei();
    4fa8:	78 94       	sei
	IntOn();

	Buf = Coef_AO_PWM_TC3*DAC_Output[1];
    4faa:	60 91 d4 07 	lds	r22, 0x07D4
    4fae:	70 91 d5 07 	lds	r23, 0x07D5
    4fb2:	80 e0       	ldi	r24, 0x00	; 0
    4fb4:	90 e0       	ldi	r25, 0x00	; 0
    4fb6:	0e 94 0c 89 	call	0x11218	; 0x11218 <__floatunsisf>
    4fba:	28 e8       	ldi	r18, 0x88	; 136
    4fbc:	3f e1       	ldi	r19, 0x1F	; 31
    4fbe:	40 e8       	ldi	r20, 0x80	; 128
    4fc0:	52 e4       	ldi	r21, 0x42	; 66
    4fc2:	0e 94 49 89 	call	0x11292	; 0x11292 <__mulsf3>
    4fc6:	0e 94 e1 8d 	call	0x11bc2	; 0x11bc2 <__fixunssfsi>
    4fca:	26 2f       	mov	r18, r22

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    4fcc:	9f b7       	in	r25, 0x3f	; 63
	cli();
    4fce:	f8 94       	cli
	IntOff();
	OCR3BH = Buf>>8;
    4fd0:	70 93 9b 00 	sts	0x009B, r23
	OCR3BL = Buf;
    4fd4:	20 93 9a 00 	sts	0x009A, r18

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    4fd8:	97 ff       	sbrs	r25, 7
    4fda:	01 c0       	rjmp	.+2      	; 0x4fde <PWM_Out+0x68>
		sei();
    4fdc:	78 94       	sei
	IntOn();


	Buf = Coef_AO_PWM_TC5*DAC_Output[2];
    4fde:	60 91 d6 07 	lds	r22, 0x07D6
    4fe2:	70 91 d7 07 	lds	r23, 0x07D7
    4fe6:	80 e0       	ldi	r24, 0x00	; 0
    4fe8:	90 e0       	ldi	r25, 0x00	; 0
    4fea:	0e 94 0c 89 	call	0x11218	; 0x11218 <__floatunsisf>
    4fee:	25 e0       	ldi	r18, 0x05	; 5
    4ff0:	32 e1       	ldi	r19, 0x12	; 18
    4ff2:	48 e4       	ldi	r20, 0x48	; 72
    4ff4:	50 e4       	ldi	r21, 0x40	; 64
    4ff6:	0e 94 49 89 	call	0x11292	; 0x11292 <__mulsf3>
    4ffa:	0e 94 e1 8d 	call	0x11bc2	; 0x11bc2 <__fixunssfsi>
    4ffe:	26 2f       	mov	r18, r22

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    5000:	9f b7       	in	r25, 0x3f	; 63
	cli();
    5002:	f8 94       	cli
	IntOff();
	OCR5AH = Buf>>8;
    5004:	70 93 29 01 	sts	0x0129, r23
	OCR5AL = Buf;
    5008:	20 93 28 01 	sts	0x0128, r18

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    500c:	97 ff       	sbrs	r25, 7
    500e:	01 c0       	rjmp	.+2      	; 0x5012 <PWM_Out+0x9c>
		sei();
    5010:	78 94       	sei
	IntOn();

	Buf = Coef_AO_PWM_TC5*DAC_Output[3];
    5012:	60 91 d8 07 	lds	r22, 0x07D8
    5016:	70 91 d9 07 	lds	r23, 0x07D9
    501a:	80 e0       	ldi	r24, 0x00	; 0
    501c:	90 e0       	ldi	r25, 0x00	; 0
    501e:	0e 94 0c 89 	call	0x11218	; 0x11218 <__floatunsisf>
    5022:	25 e0       	ldi	r18, 0x05	; 5
    5024:	32 e1       	ldi	r19, 0x12	; 18
    5026:	48 e4       	ldi	r20, 0x48	; 72
    5028:	50 e4       	ldi	r21, 0x40	; 64
    502a:	0e 94 49 89 	call	0x11292	; 0x11292 <__mulsf3>
    502e:	0e 94 e1 8d 	call	0x11bc2	; 0x11bc2 <__fixunssfsi>
    5032:	26 2f       	mov	r18, r22

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    5034:	8f b7       	in	r24, 0x3f	; 63
    5036:	80 78       	andi	r24, 0x80	; 128
    5038:	80 93 ee 02 	sts	0x02EE, r24
	cli();
    503c:	f8 94       	cli
	IntOff();
	OCR5BH = Buf>>8;
    503e:	70 93 2b 01 	sts	0x012B, r23
	OCR5BL = Buf;
    5042:	20 93 2a 01 	sts	0x012A, r18

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    5046:	88 23       	and	r24, r24
    5048:	09 f0       	breq	.+2      	; 0x504c <PWM_Out+0xd6>
		sei();
    504a:	78 94       	sei
    504c:	08 95       	ret

0000504e <ADC_In>:
}

// ~~~~~~~~~
uint8_t
ADC_In(void)
{
    504e:	1f 93       	push	r17

// ~~~~~~~~~~~~~~~
inline static void
ADC_Select(void)
{
	SPCR |=(1<<CPOL);
    5050:	8c b5       	in	r24, 0x2c	; 44
    5052:	88 60       	ori	r24, 0x08	; 8
    5054:	8c bd       	out	0x2c, r24	; 44
	#ifdef CS_ADC
		cli();
    5056:	f8 94       	cli
		PortCS_ADC &=~CS_ADC;
    5058:	80 91 02 01 	lds	r24, 0x0102
    505c:	87 7f       	andi	r24, 0xF7	; 247
    505e:	80 93 02 01 	sts	0x0102, r24
		sei();
    5062:	78 94       	sei
ADC_In(void)
{
	uint8_t Chan = ADC_Reg;
	ADC_Select();

	switch(ADC_Phase) {
    5064:	80 91 6a 0b 	lds	r24, 0x0B6A
    5068:	81 30       	cpi	r24, 0x01	; 1
    506a:	09 f4       	brne	.+2      	; 0x506e <ADC_In+0x20>
    506c:	ec c0       	rjmp	.+472    	; 0x5246 <ADC_In+0x1f8>
    506e:	81 30       	cpi	r24, 0x01	; 1
    5070:	30 f5       	brcc	.+76     	; 0x50be <ADC_In+0x70>

// ~~~~~~~~~~~~~~~
inline static void
ADC_Rst(void)
{
	cli();
    5072:	f8 94       	cli
	PortRESET_PER &=~RESET_PER;
    5074:	80 91 02 01 	lds	r24, 0x0102
    5078:	8f 7e       	andi	r24, 0xEF	; 239
    507a:	80 93 02 01 	sts	0x0102, r24
	sei();
    507e:	78 94       	sei
    5080:	85 e0       	ldi	r24, 0x05	; 5
    5082:	8a 95       	dec	r24
    5084:	f1 f7       	brne	.-4      	; 0x5082 <ADC_In+0x34>
	_delay_us(1);							// 100 ns needs
	cli();
    5086:	f8 94       	cli
	PortRESET_PER |=RESET_PER;
    5088:	80 91 02 01 	lds	r24, 0x0102
    508c:	80 61       	ori	r24, 0x10	; 16
    508e:	80 93 02 01 	sts	0x0102, r24
	sei();
    5092:	78 94       	sei
	StartTimer8_ISR(TD_ADC, 4);		// 16 ms needs
    5094:	80 91 39 07 	lds	r24, 0x0739
    5098:	64 e0       	ldi	r22, 0x04	; 4
	WaitSPI();
	SPDR = SR;
	WaitSPI();
	SPDR = SetpVal(CaliMode) &~ADC_FSYNC;
	WaitSPI();
	StartTimer8_ISR(TD_ADC, 36);
    509a:	0e 94 e4 23 	call	0x47c8	; 0x47c8 <StartTimer8_ISR>
	ADC_Phase++;
    509e:	80 91 6a 0b 	lds	r24, 0x0B6A
    50a2:	8f 5f       	subi	r24, 0xFF	; 255
    50a4:	80 93 6a 0b 	sts	0x0B6A, r24
    50a8:	17 e0       	ldi	r17, 0x07	; 7
// ~~~~~~~~~~~~~~~
inline static void
ADC_Desel(void)
{
	#ifdef CS_ADC
		cli();
    50aa:	f8 94       	cli
		PortCS_ADC |=CS_ADC;
    50ac:	80 91 02 01 	lds	r24, 0x0102
    50b0:	88 60       	ori	r24, 0x08	; 8
    50b2:	80 93 02 01 	sts	0x0102, r24
		sei();
    50b6:	78 94       	sei
			IntOn();
		}
	#endif

	return Chan;
}
    50b8:	81 2f       	mov	r24, r17
    50ba:	1f 91       	pop	r17
    50bc:	08 95       	ret
ADC_In(void)
{
	uint8_t Chan = ADC_Reg;
	ADC_Select();

	switch(ADC_Phase) {
    50be:	82 30       	cpi	r24, 0x02	; 2
    50c0:	09 f4       	brne	.+2      	; 0x50c4 <ADC_In+0x76>
    50c2:	d2 c0       	rjmp	.+420    	; 0x5268 <ADC_In+0x21a>
    50c4:	83 30       	cpi	r24, 0x03	; 3
    50c6:	11 f0       	breq	.+4      	; 0x50cc <ADC_In+0x7e>
				StartTimer8_ISR(TD_ADC, ADC10ms);
			}
		}
		else if(Timer8Stopp_ISR(TD_ADC)) {
			ADC_ReadFail++;
			ADC_Phase = RST;
    50c8:	17 e0       	ldi	r17, 0x07	; 7
    50ca:	ef cf       	rjmp	.-34     	; 0x50aa <ADC_In+0x5c>
		default:
			SPDR = ADC_IN1(Reg);
			break;
		}
	#else
		SPDR = ADC_IN1(Reg);
    50cc:	88 e0       	ldi	r24, 0x08	; 8
    50ce:	8e bd       	out	0x2e, r24	; 46

// ~~~~~~~~~~~
static void
WaitADC2(void)
{
	WaitSPI();
    50d0:	0d b4       	in	r0, 0x2d	; 45
    50d2:	07 fe       	sbrs	r0, 7
    50d4:	fd cf       	rjmp	.-6      	; 0x50d0 <ADC_In+0x82>
	SPDR = 0;
    50d6:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    50d8:	0d b4       	in	r0, 0x2d	; 45
    50da:	07 fe       	sbrs	r0, 7
    50dc:	fd cf       	rjmp	.-6      	; 0x50d8 <ADC_In+0x8a>
			StartTimer8_ISR(TD_ADC, ADC10ms);
		break;
	case READ:
		ADC_IN(CommReg);
		WaitADC2();
		if(!(SPDR &ADC_DRDY)) {
    50de:	0e b4       	in	r0, 0x2e	; 46
    50e0:	07 fc       	sbrc	r0, 7
    50e2:	da c0       	rjmp	.+436    	; 0x5298 <ADC_In+0x24a>
		default:
			SPDR = ADC_IN1(Reg);
			break;
		}
	#else
		SPDR = ADC_IN1(Reg);
    50e4:	88 e3       	ldi	r24, 0x38	; 56
    50e6:	8e bd       	out	0x2e, r24	; 46

// ~~~~~~~~~~~
static void
WaitADC2(void)
{
	WaitSPI();
    50e8:	0d b4       	in	r0, 0x2d	; 45
    50ea:	07 fe       	sbrs	r0, 7
    50ec:	fd cf       	rjmp	.-6      	; 0x50e8 <ADC_In+0x9a>
	SPDR = 0;
    50ee:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    50f0:	0d b4       	in	r0, 0x2d	; 45
    50f2:	07 fe       	sbrs	r0, 7
    50f4:	fd cf       	rjmp	.-6      	; 0x50f0 <ADC_In+0xa2>
		WaitADC2();
		if(!(SPDR &ADC_DRDY)) {
			uint16_t Buf;
			ADC_IN(DataReg);
			WaitADC2();
			Buf = SPDR<<8;
    50f6:	3e b5       	in	r19, 0x2e	; 46

// ~~~~~~~~~~~
static void
WaitADC1(void)
{
	SPDR = 0;
    50f8:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    50fa:	0d b4       	in	r0, 0x2d	; 45
    50fc:	07 fe       	sbrs	r0, 7
    50fe:	fd cf       	rjmp	.-6      	; 0x50fa <ADC_In+0xac>
			uint16_t Buf;
			ADC_IN(DataReg);
			WaitADC2();
			Buf = SPDR<<8;
			WaitADC1();
			Buf += SPDR;
    5100:	2e b5       	in	r18, 0x2e	; 46
		WaitADC2();
		if(!(SPDR &ADC_DRDY)) {
			uint16_t Buf;
			ADC_IN(DataReg);
			WaitADC2();
			Buf = SPDR<<8;
    5102:	93 2f       	mov	r25, r19
    5104:	80 e0       	ldi	r24, 0x00	; 0
			WaitADC1();
			Buf += SPDR;
    5106:	ac 01       	movw	r20, r24
    5108:	42 0f       	add	r20, r18
    510a:	51 1d       	adc	r21, r1
    510c:	9a 01       	movw	r18, r20
			#ifdef ADC_Ref_Chan
				if (ADC_Chan==sizeof(Mux)-1 && ADC_Input[sizeof(Mux)-1]!=0 && (Buf<ADC_Ref-ADC_Ref_d || Buf>ADC_Ref+ADC_Ref_d)) {
    510e:	10 91 12 09 	lds	r17, 0x0912
    5112:	16 30       	cpi	r17, 0x06	; 6
    5114:	09 f4       	brne	.+2      	; 0x5118 <ADC_In+0xca>
    5116:	19 c1       	rjmp	.+562    	; 0x534a <ADC_In+0x2fc>
		default:
			SPDR = ADC_IN1(Reg);
			break;
		}
	#else
		SPDR = ADC_IN1(Reg);
    5118:	80 e1       	ldi	r24, 0x10	; 16
    511a:	8e bd       	out	0x2e, r24	; 46
{
	Scale *Scl;
	int8_t i;

	ADC_IN(SetpReg);
	WaitSPI();
    511c:	0d b4       	in	r0, 0x2d	; 45
    511e:	07 fe       	sbrs	r0, 7
    5120:	fd cf       	rjmp	.-6      	; 0x511c <ADC_In+0xce>
	SPDR = SetpVal(NormMode) |ADC_FSYNC;
    5122:	87 e0       	ldi	r24, 0x07	; 7
    5124:	8e bd       	out	0x2e, r24	; 46
	WaitSPI();
    5126:	0d b4       	in	r0, 0x2d	; 45
    5128:	07 fe       	sbrs	r0, 7
    512a:	fd cf       	rjmp	.-6      	; 0x5126 <ADC_In+0xd8>
	ADC_Time = ADC10ms-Timer8_ISR[TD_ADC];
    512c:	40 91 39 07 	lds	r20, 0x0739
    5130:	e4 2f       	mov	r30, r20
    5132:	f0 e0       	ldi	r31, 0x00	; 0
    5134:	e1 51       	subi	r30, 0x11	; 17
    5136:	fd 4f       	sbci	r31, 0xFD	; 253
    5138:	90 81       	ld	r25, Z
    513a:	84 e1       	ldi	r24, 0x14	; 20
    513c:	89 1b       	sub	r24, r25
    513e:	80 93 b3 06 	sts	0x06B3, r24
		default:
			SPDR = ADC_IN1(Reg);
			break;
		}
	#else
		SPDR = ADC_IN1(Reg);
    5142:	88 e6       	ldi	r24, 0x68	; 104
    5144:	8e bd       	out	0x2e, r24	; 46

// ~~~~~~~~~~~
static void
WaitADC2(void)
{
	WaitSPI();
    5146:	0d b4       	in	r0, 0x2d	; 45
    5148:	07 fe       	sbrs	r0, 7
    514a:	fd cf       	rjmp	.-6      	; 0x5146 <ADC_In+0xf8>
	SPDR = 0;
    514c:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    514e:	0d b4       	in	r0, 0x2d	; 45
    5150:	07 fe       	sbrs	r0, 7
    5152:	fd cf       	rjmp	.-6      	; 0x514e <ADC_In+0x100>
    5154:	ef e6       	ldi	r30, 0x6F	; 111
    5156:	fc e0       	ldi	r31, 0x0C	; 12
		Scl=&ADC_Scale1;
	#endif
	ADC_IN(ZeroReg);
	WaitADC2();
	for(i=2; i>=0; i--) {
		Scl->Zero[i] = SPDR;
    5158:	8e b5       	in	r24, 0x2e	; 46
    515a:	80 83       	st	Z, r24

// ~~~~~~~~~~~
static void
WaitADC1(void)
{
	SPDR = 0;
    515c:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    515e:	0d b4       	in	r0, 0x2d	; 45
    5160:	07 fe       	sbrs	r0, 7
    5162:	fd cf       	rjmp	.-6      	; 0x515e <ADC_In+0x110>
    5164:	31 97       	sbiw	r30, 0x01	; 1
	#else
		Scl=&ADC_Scale1;
	#endif
	ADC_IN(ZeroReg);
	WaitADC2();
	for(i=2; i>=0; i--) {
    5166:	8c e0       	ldi	r24, 0x0C	; 12
    5168:	ec 36       	cpi	r30, 0x6C	; 108
    516a:	f8 07       	cpc	r31, r24
    516c:	a9 f7       	brne	.-22     	; 0x5158 <ADC_In+0x10a>

// ~~~~~~~~~~~
static void
WaitADC1(void)
{
	SPDR = 0;
    516e:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    5170:	0d b4       	in	r0, 0x2d	; 45
    5172:	07 fe       	sbrs	r0, 7
    5174:	fd cf       	rjmp	.-6      	; 0x5170 <ADC_In+0x122>
		default:
			SPDR = ADC_IN1(Reg);
			break;
		}
	#else
		SPDR = ADC_IN1(Reg);
    5176:	88 e7       	ldi	r24, 0x78	; 120
    5178:	8e bd       	out	0x2e, r24	; 46

// ~~~~~~~~~~~
static void
WaitADC2(void)
{
	WaitSPI();
    517a:	0d b4       	in	r0, 0x2d	; 45
    517c:	07 fe       	sbrs	r0, 7
    517e:	fd cf       	rjmp	.-6      	; 0x517a <ADC_In+0x12c>
	SPDR = 0;
    5180:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    5182:	0d b4       	in	r0, 0x2d	; 45
    5184:	07 fe       	sbrs	r0, 7
    5186:	fd cf       	rjmp	.-6      	; 0x5182 <ADC_In+0x134>
    5188:	e2 e7       	ldi	r30, 0x72	; 114
    518a:	fc e0       	ldi	r31, 0x0C	; 12
	}
	WaitADC1();
	ADC_IN(FullReg);
	WaitADC2();
	for(i=2; i>=0; i--) {
		Scl->Full[i] = SPDR;
    518c:	8e b5       	in	r24, 0x2e	; 46
    518e:	80 83       	st	Z, r24

// ~~~~~~~~~~~
static void
WaitADC1(void)
{
	SPDR = 0;
    5190:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    5192:	0d b4       	in	r0, 0x2d	; 45
    5194:	07 fe       	sbrs	r0, 7
    5196:	fd cf       	rjmp	.-6      	; 0x5192 <ADC_In+0x144>
    5198:	31 97       	sbiw	r30, 0x01	; 1
		WaitADC1();
	}
	WaitADC1();
	ADC_IN(FullReg);
	WaitADC2();
	for(i=2; i>=0; i--) {
    519a:	5c e0       	ldi	r21, 0x0C	; 12
    519c:	ef 36       	cpi	r30, 0x6F	; 111
    519e:	f5 07       	cpc	r31, r21
    51a0:	a9 f7       	brne	.-22     	; 0x518c <ADC_In+0x13e>

// ~~~~~~~~~~~
static void
WaitADC1(void)
{
	SPDR = 0;
    51a2:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    51a4:	0d b4       	in	r0, 0x2d	; 45
    51a6:	07 fe       	sbrs	r0, 7
    51a8:	fd cf       	rjmp	.-6      	; 0x51a4 <ADC_In+0x156>
	for(i=2; i>=0; i--) {
		Scl->Full[i] = SPDR;
		WaitADC1();
	}
	WaitADC1();
	return Scl->Zero[2]<25 || Scl->Zero[2]>27 || Scl->Full[2]<200 || Scl->Full[2]>203;
    51aa:	80 91 6f 0c 	lds	r24, 0x0C6F
    51ae:	89 51       	subi	r24, 0x19	; 25
    51b0:	83 30       	cpi	r24, 0x03	; 3
    51b2:	08 f0       	brcs	.+2      	; 0x51b6 <ADC_In+0x168>
    51b4:	85 c0       	rjmp	.+266    	; 0x52c0 <ADC_In+0x272>
    51b6:	80 91 72 0c 	lds	r24, 0x0C72
    51ba:	88 3c       	cpi	r24, 0xC8	; 200
    51bc:	08 f4       	brcc	.+2      	; 0x51c0 <ADC_In+0x172>
    51be:	80 c0       	rjmp	.+256    	; 0x52c0 <ADC_In+0x272>
    51c0:	8c 3c       	cpi	r24, 0xCC	; 204
    51c2:	08 f0       	brcs	.+2      	; 0x51c6 <ADC_In+0x178>
    51c4:	7d c0       	rjmp	.+250    	; 0x52c0 <ADC_In+0x272>
			if(ADC_Check()) {
				ADC_Break++;
				ADC_Phase = RST;
			}
			else {
				ADC_Input[ADC_Chan] = Buf;
    51c6:	e1 2f       	mov	r30, r17
    51c8:	f0 e0       	ldi	r31, 0x00	; 0
    51ca:	ee 0f       	add	r30, r30
    51cc:	ff 1f       	adc	r31, r31
    51ce:	e5 5e       	subi	r30, 0xE5	; 229
    51d0:	f6 4f       	sbci	r31, 0xF6	; 246
    51d2:	31 83       	std	Z+1, r19	; 0x01
    51d4:	20 83       	st	Z, r18

// ~~~~~~~~~~~~~~~
inline static void
SetMux(void)
{
	if(++ADC_Chan == ADC_Reg)
    51d6:	81 2f       	mov	r24, r17
    51d8:	8f 5f       	subi	r24, 0xFF	; 255
    51da:	80 93 12 09 	sts	0x0912, r24
    51de:	87 30       	cpi	r24, 0x07	; 7
    51e0:	11 f4       	brne	.+4      	; 0x51e6 <ADC_In+0x198>
		ADC_Chan = 0;
    51e2:	10 92 12 09 	sts	0x0912, r1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    51e6:	e0 91 12 09 	lds	r30, 0x0912
    51ea:	f0 e0       	ldi	r31, 0x00	; 0
    51ec:	e9 50       	subi	r30, 0x09	; 9
    51ee:	fe 4b       	sbci	r31, 0xBE	; 190
    51f0:	94 91       	lpm	r25, Z+
		#if ADC_Reg>8
			if(ADC_Chan>=sizeof(Mux))
				return;
		#endif
		uint8_t Addr = prb(Mux+ADC_Chan);
		cli();
    51f2:	f8 94       	cli
		if (Addr/4){
    51f4:	94 30       	cpi	r25, 0x04	; 4
    51f6:	08 f4       	brcc	.+2      	; 0x51fa <ADC_In+0x1ac>
    51f8:	ca c0       	rjmp	.+404    	; 0x538e <ADC_In+0x340>
			Port_INH|=INH;
    51fa:	77 9a       	sbi	0x0e, 7	; 14
			#ifdef Port_INH2
				Port_INH2 &=~INH2;
    51fc:	80 91 02 01 	lds	r24, 0x0102
    5200:	8b 7f       	andi	r24, 0xFB	; 251
    5202:	80 93 02 01 	sts	0x0102, r24
			Port_INH &=~INH;
			#ifdef Port_INH2
				Port_INH2|=INH2;
			#endif
		}
		if (Addr%4/2)	Port_TER_B	|=TER_B;	else Port_TER_B	&=~TER_B;
    5206:	29 2f       	mov	r18, r25
    5208:	30 e0       	ldi	r19, 0x00	; 0
    520a:	c9 01       	movw	r24, r18
    520c:	83 70       	andi	r24, 0x03	; 3
    520e:	90 70       	andi	r25, 0x00	; 0
    5210:	01 96       	adiw	r24, 0x01	; 1
    5212:	03 97       	sbiw	r24, 0x03	; 3
    5214:	08 f4       	brcc	.+2      	; 0x5218 <ADC_In+0x1ca>
    5216:	b9 c0       	rjmp	.+370    	; 0x538a <ADC_In+0x33c>
    5218:	76 9a       	sbi	0x0e, 6	; 14
		if (Addr%2)		Port_TER_A	|=TER_A;	else Port_TER_A	&=~TER_A;
    521a:	20 ff       	sbrs	r18, 0
    521c:	b4 c0       	rjmp	.+360    	; 0x5386 <ADC_In+0x338>
    521e:	75 9a       	sbi	0x0e, 5	; 14
		sei();
    5220:	78 94       	sei
    5222:	85 e5       	ldi	r24, 0x55	; 85
    5224:	8a 95       	dec	r24
    5226:	f1 f7       	brne	.-4      	; 0x5224 <ADC_In+0x1d6>
		default:
			SPDR = ADC_IN1(Reg);
			break;
		}
	#else
		SPDR = ADC_IN1(Reg);
    5228:	80 e1       	ldi	r24, 0x10	; 16
    522a:	8e bd       	out	0x2e, r24	; 46
			else {
				ADC_Input[ADC_Chan] = Buf;
				Chan = ADC_Chan;
				SetMux();
				ADC_IN(SetpReg);
				WaitSPI();
    522c:	0d b4       	in	r0, 0x2d	; 45
    522e:	07 fe       	sbrs	r0, 7
    5230:	fd cf       	rjmp	.-6      	; 0x522c <ADC_In+0x1de>
				SPDR = SetpVal(NormMode) &~ADC_FSYNC;
    5232:	86 e0       	ldi	r24, 0x06	; 6
    5234:	8e bd       	out	0x2e, r24	; 46
				WaitSPI();
    5236:	0d b4       	in	r0, 0x2d	; 45
    5238:	07 fe       	sbrs	r0, 7
    523a:	fd cf       	rjmp	.-6      	; 0x5236 <ADC_In+0x1e8>
				StartTimer8_ISR(TD_ADC, ADC10ms);
    523c:	84 2f       	mov	r24, r20
    523e:	64 e1       	ldi	r22, 0x14	; 20
    5240:	0e 94 e4 23 	call	0x47c8	; 0x47c8 <StartTimer8_ISR>
    5244:	32 cf       	rjmp	.-412    	; 0x50aa <ADC_In+0x5c>

// ~~~~~~~~~~~~~~~
inline static void
ADC_Init1(void)
{
	if(!Timer8Stopp_ISR(TD_ADC))
    5246:	80 91 39 07 	lds	r24, 0x0739
    524a:	0e 94 50 25 	call	0x4aa0	; 0x4aa0 <Timer8Stopp_ISR>
    524e:	88 23       	and	r24, r24
    5250:	09 f4       	brne	.+2      	; 0x5254 <ADC_In+0x206>
    5252:	3a cf       	rjmp	.-396    	; 0x50c8 <ADC_In+0x7a>
    5254:	81 e0       	ldi	r24, 0x01	; 1
		return;
	uint8_t i = 0;
	while(i++<8) {	// 4 x 0xFF needs
		SPDR = 0xFF;
    5256:	9f ef       	ldi	r25, 0xFF	; 255
    5258:	9e bd       	out	0x2e, r25	; 46
		WaitSPI();
    525a:	0d b4       	in	r0, 0x2d	; 45
    525c:	07 fe       	sbrs	r0, 7
    525e:	fd cf       	rjmp	.-6      	; 0x525a <ADC_In+0x20c>
ADC_Init1(void)
{
	if(!Timer8Stopp_ISR(TD_ADC))
		return;
	uint8_t i = 0;
	while(i++<8) {	// 4 x 0xFF needs
    5260:	88 30       	cpi	r24, 0x08	; 8
    5262:	d9 f1       	breq	.+118    	; 0x52da <ADC_In+0x28c>
    5264:	8f 5f       	subi	r24, 0xFF	; 255
    5266:	f8 cf       	rjmp	.-16     	; 0x5258 <ADC_In+0x20a>
// ~~~~~~~~~~~~~~~
static void
Calibr(uint8_t CR)
{
	static uint8_t Try;
	SPDR = CR;
    5268:	88 e0       	ldi	r24, 0x08	; 8
    526a:	8e bd       	out	0x2e, r24	; 46

// ~~~~~~~~~~~
static void
WaitADC2(void)
{
	WaitSPI();
    526c:	0d b4       	in	r0, 0x2d	; 45
    526e:	07 fe       	sbrs	r0, 7
    5270:	fd cf       	rjmp	.-6      	; 0x526c <ADC_In+0x21e>
	SPDR = 0;
    5272:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    5274:	0d b4       	in	r0, 0x2d	; 45
    5276:	07 fe       	sbrs	r0, 7
    5278:	fd cf       	rjmp	.-6      	; 0x5274 <ADC_In+0x226>
Calibr(uint8_t CR)
{
	static uint8_t Try;
	SPDR = CR;
	WaitADC2();
	if(!(SPDR &ADC_DRDY)) {
    527a:	0e b4       	in	r0, 0x2e	; 46
    527c:	07 fc       	sbrc	r0, 7
    527e:	45 c0       	rjmp	.+138    	; 0x530a <ADC_In+0x2bc>
		Try = 0;
    5280:	10 92 ec 02 	sts	0x02EC, r1
		ADC_Phase++;
    5284:	83 e0       	ldi	r24, 0x03	; 3
    5286:	80 93 6a 0b 	sts	0x0B6A, r24
		break;
	case CALI3:
		Calibr(ADC_IN3(CommReg));
#endif
		if (ADC_Phase==READ)
			StartTimer8_ISR(TD_ADC, ADC10ms);
    528a:	80 91 39 07 	lds	r24, 0x0739
    528e:	64 e1       	ldi	r22, 0x14	; 20
    5290:	0e 94 e4 23 	call	0x47c8	; 0x47c8 <StartTimer8_ISR>
    5294:	17 e0       	ldi	r17, 0x07	; 7
    5296:	09 cf       	rjmp	.-494    	; 0x50aa <ADC_In+0x5c>
				SPDR = SetpVal(NormMode) &~ADC_FSYNC;
				WaitSPI();
				StartTimer8_ISR(TD_ADC, ADC10ms);
			}
		}
		else if(Timer8Stopp_ISR(TD_ADC)) {
    5298:	80 91 39 07 	lds	r24, 0x0739
    529c:	0e 94 50 25 	call	0x4aa0	; 0x4aa0 <Timer8Stopp_ISR>
    52a0:	88 23       	and	r24, r24
    52a2:	09 f4       	brne	.+2      	; 0x52a6 <ADC_In+0x258>
    52a4:	11 cf       	rjmp	.-478    	; 0x50c8 <ADC_In+0x7a>
			ADC_ReadFail++;
    52a6:	80 91 b4 07 	lds	r24, 0x07B4
    52aa:	90 91 b5 07 	lds	r25, 0x07B5
    52ae:	01 96       	adiw	r24, 0x01	; 1
    52b0:	90 93 b5 07 	sts	0x07B5, r25
    52b4:	80 93 b4 07 	sts	0x07B4, r24
			ADC_Phase = RST;
    52b8:	10 92 6a 0b 	sts	0x0B6A, r1
    52bc:	17 e0       	ldi	r17, 0x07	; 7
    52be:	f5 ce       	rjmp	.-534    	; 0x50aa <ADC_In+0x5c>
					ADC_Chan--;
				}
				else
			#endif
			if(ADC_Check()) {
				ADC_Break++;
    52c0:	80 91 f8 06 	lds	r24, 0x06F8
    52c4:	90 91 f9 06 	lds	r25, 0x06F9
    52c8:	01 96       	adiw	r24, 0x01	; 1
    52ca:	90 93 f9 06 	sts	0x06F9, r25
    52ce:	80 93 f8 06 	sts	0x06F8, r24
				ADC_Phase = RST;
    52d2:	10 92 6a 0b 	sts	0x0B6A, r1
    52d6:	17 e0       	ldi	r17, 0x07	; 7
    52d8:	e8 ce       	rjmp	.-560    	; 0x50aa <ADC_In+0x5c>

// ~~~~~~~~~~~~~~~~~~~~~~~~~
static void
Init(uint8_t CR, uint8_t SR)
{
	SPDR = CR;
    52da:	80 e2       	ldi	r24, 0x20	; 32
    52dc:	8e bd       	out	0x2e, r24	; 46
	WaitSPI();
    52de:	0d b4       	in	r0, 0x2d	; 45
    52e0:	07 fe       	sbrs	r0, 7
    52e2:	fd cf       	rjmp	.-6      	; 0x52de <ADC_In+0x290>
	SPDR=ClckVal;
    52e4:	84 e0       	ldi	r24, 0x04	; 4
    52e6:	8e bd       	out	0x2e, r24	; 46
	WaitSPI();
    52e8:	0d b4       	in	r0, 0x2d	; 45
    52ea:	07 fe       	sbrs	r0, 7
    52ec:	fd cf       	rjmp	.-6      	; 0x52e8 <ADC_In+0x29a>
	SPDR = SR;
    52ee:	80 e1       	ldi	r24, 0x10	; 16
    52f0:	8e bd       	out	0x2e, r24	; 46
	WaitSPI();
    52f2:	0d b4       	in	r0, 0x2d	; 45
    52f4:	07 fe       	sbrs	r0, 7
    52f6:	fd cf       	rjmp	.-6      	; 0x52f2 <ADC_In+0x2a4>
	SPDR = SetpVal(CaliMode) &~ADC_FSYNC;
    52f8:	86 e4       	ldi	r24, 0x46	; 70
    52fa:	8e bd       	out	0x2e, r24	; 46
	WaitSPI();
    52fc:	0d b4       	in	r0, 0x2d	; 45
    52fe:	07 fe       	sbrs	r0, 7
    5300:	fd cf       	rjmp	.-6      	; 0x52fc <ADC_In+0x2ae>
	StartTimer8_ISR(TD_ADC, 36);
    5302:	80 91 39 07 	lds	r24, 0x0739
    5306:	64 e2       	ldi	r22, 0x24	; 36
    5308:	c8 ce       	rjmp	.-624    	; 0x509a <ADC_In+0x4c>
	WaitADC2();
	if(!(SPDR &ADC_DRDY)) {
		Try = 0;
		ADC_Phase++;
	}
	else if(Timer8Stopp_ISR(TD_ADC)) {
    530a:	80 91 39 07 	lds	r24, 0x0739
    530e:	0e 94 50 25 	call	0x4aa0	; 0x4aa0 <Timer8Stopp_ISR>
    5312:	88 23       	and	r24, r24
    5314:	99 f0       	breq	.+38     	; 0x533c <ADC_In+0x2ee>
		ADC_Fail++;
    5316:	80 91 2b 09 	lds	r24, 0x092B
    531a:	90 91 2c 09 	lds	r25, 0x092C
    531e:	01 96       	adiw	r24, 0x01	; 1
    5320:	90 93 2c 09 	sts	0x092C, r25
    5324:	80 93 2b 09 	sts	0x092B, r24
		ADC_Phase = ++Try<27 ? RST : ADC_OFF;
    5328:	80 91 ec 02 	lds	r24, 0x02EC
    532c:	8f 5f       	subi	r24, 0xFF	; 255
    532e:	80 93 ec 02 	sts	0x02EC, r24
    5332:	8b 31       	cpi	r24, 0x1B	; 27
    5334:	98 f1       	brcs	.+102    	; 0x539c <ADC_In+0x34e>
    5336:	84 e0       	ldi	r24, 0x04	; 4
    5338:	80 93 6a 0b 	sts	0x0B6A, r24
		Init(ADC_IN3(ClckReg), ADC_IN3(SetpReg));
		break;
	case CALI3:
		Calibr(ADC_IN3(CommReg));
#endif
		if (ADC_Phase==READ)
    533c:	80 91 6a 0b 	lds	r24, 0x0B6A
    5340:	83 30       	cpi	r24, 0x03	; 3
    5342:	09 f4       	brne	.+2      	; 0x5346 <ADC_In+0x2f8>
    5344:	a2 cf       	rjmp	.-188    	; 0x528a <ADC_In+0x23c>
				StartTimer8_ISR(TD_ADC, ADC10ms);
			}
		}
		else if(Timer8Stopp_ISR(TD_ADC)) {
			ADC_ReadFail++;
			ADC_Phase = RST;
    5346:	17 e0       	ldi	r17, 0x07	; 7
    5348:	b0 ce       	rjmp	.-672    	; 0x50aa <ADC_In+0x5c>
			WaitADC2();
			Buf = SPDR<<8;
			WaitADC1();
			Buf += SPDR;
			#ifdef ADC_Ref_Chan
				if (ADC_Chan==sizeof(Mux)-1 && ADC_Input[sizeof(Mux)-1]!=0 && (Buf<ADC_Ref-ADC_Ref_d || Buf>ADC_Ref+ADC_Ref_d)) {
    534a:	80 91 27 09 	lds	r24, 0x0927
    534e:	90 91 28 09 	lds	r25, 0x0928
    5352:	89 2b       	or	r24, r25
    5354:	09 f4       	brne	.+2      	; 0x5358 <ADC_In+0x30a>
    5356:	e0 ce       	rjmp	.-576    	; 0x5118 <ADC_In+0xca>
    5358:	ca 01       	movw	r24, r20
    535a:	80 58       	subi	r24, 0x80	; 128
    535c:	9e 43       	sbci	r25, 0x3E	; 62
    535e:	81 5a       	subi	r24, 0xA1	; 161
    5360:	9f 40       	sbci	r25, 0x0F	; 15
    5362:	08 f4       	brcc	.+2      	; 0x5366 <ADC_In+0x318>
    5364:	d9 ce       	rjmp	.-590    	; 0x5118 <ADC_In+0xca>
					ADC_Break++;
    5366:	80 91 f8 06 	lds	r24, 0x06F8
    536a:	90 91 f9 06 	lds	r25, 0x06F9
    536e:	01 96       	adiw	r24, 0x01	; 1
    5370:	90 93 f9 06 	sts	0x06F9, r25
    5374:	80 93 f8 06 	sts	0x06F8, r24
					ADC_Phase = RST;
    5378:	10 92 6a 0b 	sts	0x0B6A, r1
					ADC_Chan--;
    537c:	85 e0       	ldi	r24, 0x05	; 5
    537e:	80 93 12 09 	sts	0x0912, r24
    5382:	17 e0       	ldi	r17, 0x07	; 7
    5384:	92 ce       	rjmp	.-732    	; 0x50aa <ADC_In+0x5c>
			#ifdef Port_INH2
				Port_INH2|=INH2;
			#endif
		}
		if (Addr%4/2)	Port_TER_B	|=TER_B;	else Port_TER_B	&=~TER_B;
		if (Addr%2)		Port_TER_A	|=TER_A;	else Port_TER_A	&=~TER_A;
    5386:	75 98       	cbi	0x0e, 5	; 14
    5388:	4b cf       	rjmp	.-362    	; 0x5220 <ADC_In+0x1d2>
			Port_INH &=~INH;
			#ifdef Port_INH2
				Port_INH2|=INH2;
			#endif
		}
		if (Addr%4/2)	Port_TER_B	|=TER_B;	else Port_TER_B	&=~TER_B;
    538a:	76 98       	cbi	0x0e, 6	; 14
    538c:	46 cf       	rjmp	.-372    	; 0x521a <ADC_In+0x1cc>
			#ifdef Port_INH2
				Port_INH2 &=~INH2;
			#endif
		}
		else{
			Port_INH &=~INH;
    538e:	77 98       	cbi	0x0e, 7	; 14
			#ifdef Port_INH2
				Port_INH2|=INH2;
    5390:	80 91 02 01 	lds	r24, 0x0102
    5394:	84 60       	ori	r24, 0x04	; 4
    5396:	80 93 02 01 	sts	0x0102, r24
    539a:	35 cf       	rjmp	.-406    	; 0x5206 <ADC_In+0x1b8>
		Try = 0;
		ADC_Phase++;
	}
	else if(Timer8Stopp_ISR(TD_ADC)) {
		ADC_Fail++;
		ADC_Phase = ++Try<27 ? RST : ADC_OFF;
    539c:	80 e0       	ldi	r24, 0x00	; 0
    539e:	cc cf       	rjmp	.-104    	; 0x5338 <ADC_In+0x2ea>

000053a0 <SPI_Init>:
// Total
// ~~~~~~~~~~~
void
SPI_Init(void)
{
	cli();
    53a0:	f8 94       	cli
	#if defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		DDRB = (DDRB &~(1<<DDB3)) |(1<<DDB2) |(1<<DDB1) |(1<<DDB0);
    53a2:	84 b1       	in	r24, 0x04	; 4
    53a4:	80 7f       	andi	r24, 0xF0	; 240
    53a6:	87 60       	ori	r24, 0x07	; 7
    53a8:	84 b9       	out	0x04, r24	; 4
		PORTB |=1<<PB3;
    53aa:	2b 9a       	sbi	0x05, 3	; 5
	#elif defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
		DDRB = (DDRB &~(1<<DDB6)) |(1<<DDB5) |(1<<DDB7) |(1<<DDB4);
		PORTB |=1<<PB6;
	#endif
	SPCR = (uint8_t)((~(1<<SPIE) |(1<<SPE)) &~(1<<DORD)) |(1<<MSTR) |(1<<CPHA) |(1<<SPR1) |(1<<SPR0);
    53ac:	8f e5       	ldi	r24, 0x5F	; 95
    53ae:	8c bd       	out	0x2c, r24	; 44
	sei();
    53b0:	78 94       	sei
		PortCS_DAC_2 |=CS_DAC_2;
		sei();
	#endif

	#ifndef ADC_Miss
		cli();
    53b2:	f8 94       	cli
		#ifdef CS_ADC
			DDR_CS_ADC |=CS_ADC;
    53b4:	80 91 01 01 	lds	r24, 0x0101
    53b8:	88 60       	ori	r24, 0x08	; 8
    53ba:	80 93 01 01 	sts	0x0101, r24
			PortCS_ADC |=CS_ADC;
    53be:	80 91 02 01 	lds	r24, 0x0102
    53c2:	88 60       	ori	r24, 0x08	; 8
    53c4:	80 93 02 01 	sts	0x0102, r24
		#endif
		DDR_RESET_PER |=RESET_PER;
    53c8:	80 91 01 01 	lds	r24, 0x0101
    53cc:	80 61       	ori	r24, 0x10	; 16
    53ce:	80 93 01 01 	sts	0x0101, r24
		#ifdef ADC_Mux
			DDR_INH |=INH;
    53d2:	6f 9a       	sbi	0x0d, 7	; 13
			#ifdef DDR_INH2			
				DDR_INH2 |=INH2;
    53d4:	80 91 01 01 	lds	r24, 0x0101
    53d8:	84 60       	ori	r24, 0x04	; 4
    53da:	80 93 01 01 	sts	0x0101, r24
			#endif
			DDR_TER_A |=TER_A;
    53de:	6d 9a       	sbi	0x0d, 5	; 13
			DDR_TER_B |=TER_B;
    53e0:	6e 9a       	sbi	0x0d, 6	; 13
		#endif
		sei();
    53e2:	78 94       	sei

// ~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer8_ISR_SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys_ISR;
    53e4:	80 91 db 02 	lds	r24, 0x02DB
	VacantTimer8Sys_ISR += n;
    53e8:	8f 5f       	subi	r24, 0xFF	; 255
    53ea:	80 93 db 02 	sts	0x02DB, r24
    53ee:	81 50       	subi	r24, 0x01	; 1

		TD_ADC = Timer8_ISR_SysAlloc(1);
    53f0:	80 93 39 07 	sts	0x0739, r24


		ADC_Chan = ADC_Reg-1;		// Ignore 1-st measurement after calibration
    53f4:	86 e0       	ldi	r24, 0x06	; 6
    53f6:	80 93 12 09 	sts	0x0912, r24

		while(ADC_In()==ADC_Reg && ADC_OK);
    53fa:	0e 94 27 28 	call	0x504e	; 0x504e <ADC_In>
    53fe:	87 30       	cpi	r24, 0x07	; 7
    5400:	91 f4       	brne	.+36     	; 0x5426 <SPI_Init+0x86>
    5402:	80 91 2b 09 	lds	r24, 0x092B
    5406:	90 91 2c 09 	lds	r25, 0x092C
    540a:	89 2b       	or	r24, r25
    540c:	61 f4       	brne	.+24     	; 0x5426 <SPI_Init+0x86>
    540e:	80 91 b4 07 	lds	r24, 0x07B4
    5412:	90 91 b5 07 	lds	r25, 0x07B5
    5416:	89 2b       	or	r24, r25
    5418:	31 f4       	brne	.+12     	; 0x5426 <SPI_Init+0x86>
    541a:	80 91 f8 06 	lds	r24, 0x06F8
    541e:	90 91 f9 06 	lds	r25, 0x06F9
    5422:	89 2b       	or	r24, r25
    5424:	51 f3       	breq	.-44     	; 0x53fa <SPI_Init+0x5a>
    5426:	08 95       	ret

00005428 <Pow10>:
#include <string.h>

// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
    5428:	48 2f       	mov	r20, r24
	uint16_t Pow = 1;
	while(Exp--)
    542a:	88 23       	and	r24, r24
    542c:	89 f0       	breq	.+34     	; 0x5450 <Pow10+0x28>
    542e:	21 e0       	ldi	r18, 0x01	; 1
    5430:	30 e0       	ldi	r19, 0x00	; 0
		Pow *= 10;
    5432:	c9 01       	movw	r24, r18
    5434:	88 0f       	add	r24, r24
    5436:	99 1f       	adc	r25, r25
    5438:	22 0f       	add	r18, r18
    543a:	33 1f       	adc	r19, r19
    543c:	22 0f       	add	r18, r18
    543e:	33 1f       	adc	r19, r19
    5440:	22 0f       	add	r18, r18
    5442:	33 1f       	adc	r19, r19
    5444:	28 0f       	add	r18, r24
    5446:	39 1f       	adc	r19, r25
    5448:	41 50       	subi	r20, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    544a:	99 f7       	brne	.-26     	; 0x5432 <Pow10+0xa>
		Pow *= 10;
	return Pow;
}
    544c:	c9 01       	movw	r24, r18
    544e:	08 95       	ret
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    5450:	21 e0       	ldi	r18, 0x01	; 1
    5452:	30 e0       	ldi	r19, 0x00	; 0
    5454:	fb cf       	rjmp	.-10     	; 0x544c <Pow10+0x24>

00005456 <PowL10>:
	return Pow;
}
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
    5456:	1f 93       	push	r17
    5458:	18 2f       	mov	r17, r24
	uint32_t Pow = 1;
	while(Exp--)
    545a:	88 23       	and	r24, r24
    545c:	a1 f0       	breq	.+40     	; 0x5486 <PowL10+0x30>
    545e:	21 e0       	ldi	r18, 0x01	; 1
    5460:	30 e0       	ldi	r19, 0x00	; 0
    5462:	40 e0       	ldi	r20, 0x00	; 0
    5464:	50 e0       	ldi	r21, 0x00	; 0
		Pow *= 10;
    5466:	ca 01       	movw	r24, r20
    5468:	b9 01       	movw	r22, r18
    546a:	2a e0       	ldi	r18, 0x0A	; 10
    546c:	30 e0       	ldi	r19, 0x00	; 0
    546e:	40 e0       	ldi	r20, 0x00	; 0
    5470:	50 e0       	ldi	r21, 0x00	; 0
    5472:	0e 94 59 8e 	call	0x11cb2	; 0x11cb2 <__mulsi3>
    5476:	9b 01       	movw	r18, r22
    5478:	ac 01       	movw	r20, r24
    547a:	11 50       	subi	r17, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
	uint32_t Pow = 1;
	while(Exp--)
    547c:	a1 f7       	brne	.-24     	; 0x5466 <PowL10+0x10>
		Pow *= 10;
	return Pow;
}
    547e:	b9 01       	movw	r22, r18
    5480:	ca 01       	movw	r24, r20
    5482:	1f 91       	pop	r17
    5484:	08 95       	ret
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
	uint32_t Pow = 1;
	while(Exp--)
    5486:	21 e0       	ldi	r18, 0x01	; 1
    5488:	30 e0       	ldi	r19, 0x00	; 0
    548a:	40 e0       	ldi	r20, 0x00	; 0
    548c:	50 e0       	ldi	r21, 0x00	; 0
    548e:	f7 cf       	rjmp	.-18     	; 0x547e <PowL10+0x28>

00005490 <Log10>:
	return Pow;
}
// ~~~~~~~~~~~~~~~~~
uint8_t
Log10(uint32_t Numb)
{
    5490:	1f 93       	push	r17
	uint8_t Pos;
	for(Pos=0; Numb/=10; Pos++);
    5492:	2a e0       	ldi	r18, 0x0A	; 10
    5494:	30 e0       	ldi	r19, 0x00	; 0
    5496:	40 e0       	ldi	r20, 0x00	; 0
    5498:	50 e0       	ldi	r21, 0x00	; 0
    549a:	0e 94 ab 8e 	call	0x11d56	; 0x11d56 <__udivmodsi4>
    549e:	c9 01       	movw	r24, r18
    54a0:	da 01       	movw	r26, r20
    54a2:	bc 01       	movw	r22, r24
    54a4:	cd 01       	movw	r24, r26
    54a6:	61 15       	cp	r22, r1
    54a8:	71 05       	cpc	r23, r1
    54aa:	81 05       	cpc	r24, r1
    54ac:	91 05       	cpc	r25, r1
    54ae:	a1 f0       	breq	.+40     	; 0x54d8 <Log10+0x48>
    54b0:	10 e0       	ldi	r17, 0x00	; 0
    54b2:	1f 5f       	subi	r17, 0xFF	; 255
    54b4:	2a e0       	ldi	r18, 0x0A	; 10
    54b6:	30 e0       	ldi	r19, 0x00	; 0
    54b8:	40 e0       	ldi	r20, 0x00	; 0
    54ba:	50 e0       	ldi	r21, 0x00	; 0
    54bc:	0e 94 ab 8e 	call	0x11d56	; 0x11d56 <__udivmodsi4>
    54c0:	c9 01       	movw	r24, r18
    54c2:	da 01       	movw	r26, r20
    54c4:	bc 01       	movw	r22, r24
    54c6:	cd 01       	movw	r24, r26
    54c8:	61 15       	cp	r22, r1
    54ca:	71 05       	cpc	r23, r1
    54cc:	81 05       	cpc	r24, r1
    54ce:	91 05       	cpc	r25, r1
    54d0:	81 f7       	brne	.-32     	; 0x54b2 <Log10+0x22>
	return Pos;
}
    54d2:	81 2f       	mov	r24, r17
    54d4:	1f 91       	pop	r17
    54d6:	08 95       	ret
// ~~~~~~~~~~~~~~~~~
uint8_t
Log10(uint32_t Numb)
{
	uint8_t Pos;
	for(Pos=0; Numb/=10; Pos++);
    54d8:	10 e0       	ldi	r17, 0x00	; 0
    54da:	fb cf       	rjmp	.-10     	; 0x54d2 <Log10+0x42>

000054dc <CodBCD>:
// ~~~~~~~~~~~~~~~~~~~~

// ~~~~~~~~~~~~~~~~~~~
uint8_t
CodBCD(uint8_t Number)
{
    54dc:	28 2f       	mov	r18, r24
    54de:	6a e0       	ldi	r22, 0x0A	; 10
    54e0:	0e 94 78 8e 	call	0x11cf0	; 0x11cf0 <__udivmodqi4>
    54e4:	38 2f       	mov	r19, r24
    54e6:	32 95       	swap	r19
    54e8:	30 7f       	andi	r19, 0xF0	; 240
    54ea:	82 2f       	mov	r24, r18
    54ec:	0e 94 78 8e 	call	0x11cf0	; 0x11cf0 <__udivmodqi4>
	return (Number/10<<4)+Number%10;
}
    54f0:	83 2f       	mov	r24, r19
    54f2:	89 0f       	add	r24, r25
    54f4:	08 95       	ret

000054f6 <DecodBCD>:

// ~~~~~~~~~~~~~~~~~~
uint8_t
DecodBCD(uint8_t BCD)
{
    54f6:	28 2f       	mov	r18, r24
    54f8:	22 95       	swap	r18
    54fa:	2f 70       	andi	r18, 0x0F	; 15
    54fc:	9a e0       	ldi	r25, 0x0A	; 10
    54fe:	29 9f       	mul	r18, r25
    5500:	90 01       	movw	r18, r0
    5502:	11 24       	eor	r1, r1
    5504:	8f 70       	andi	r24, 0x0F	; 15
	return 10*(BCD>>4)+(BCD&0x0F);
}
    5506:	82 0f       	add	r24, r18
    5508:	08 95       	ret

0000550a <LineFunc>:
} uLineGraph;

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
int16_t
LineFunc(const LineGraph *LG, int32_t x)
{
    550a:	2f 92       	push	r2
    550c:	3f 92       	push	r3
    550e:	4f 92       	push	r4
    5510:	5f 92       	push	r5
    5512:	6f 92       	push	r6
    5514:	7f 92       	push	r7
    5516:	8f 92       	push	r8
    5518:	9f 92       	push	r9
    551a:	af 92       	push	r10
    551c:	bf 92       	push	r11
    551e:	cf 92       	push	r12
    5520:	df 92       	push	r13
    5522:	ef 92       	push	r14
    5524:	ff 92       	push	r15
    5526:	0f 93       	push	r16
    5528:	1f 93       	push	r17
    552a:	cf 93       	push	r28
    552c:	df 93       	push	r29
    552e:	ec 01       	movw	r28, r24
    5530:	7a 01       	movw	r14, r20
    5532:	8b 01       	movw	r16, r22
	int16_t y;
	if (LG->x1==LG->x2)
    5534:	28 80       	ld	r2, Y
    5536:	39 80       	ldd	r3, Y+1	; 0x01
    5538:	4a 80       	ldd	r4, Y+2	; 0x02
    553a:	5b 80       	ldd	r5, Y+3	; 0x03
    553c:	6c 81       	ldd	r22, Y+4	; 0x04
    553e:	7d 81       	ldd	r23, Y+5	; 0x05
    5540:	8e 81       	ldd	r24, Y+6	; 0x06
    5542:	9f 81       	ldd	r25, Y+7	; 0x07
    5544:	26 16       	cp	r2, r22
    5546:	37 06       	cpc	r3, r23
    5548:	48 06       	cpc	r4, r24
    554a:	59 06       	cpc	r5, r25
    554c:	09 f4       	brne	.+2      	; 0x5550 <LineFunc+0x46>
    554e:	58 c0       	rjmp	.+176    	; 0x5600 <LineFunc+0xf6>
		y = LG->y1;
	else {
		float x1=LG->x1, x2=LG->x2, y1=LG->y1, y2=LG->y2;
    5550:	0e 94 0e 89 	call	0x1121c	; 0x1121c <__floatsisf>
    5554:	5b 01       	movw	r10, r22
    5556:	6c 01       	movw	r12, r24
    5558:	6a 85       	ldd	r22, Y+10	; 0x0a
    555a:	7b 85       	ldd	r23, Y+11	; 0x0b
    555c:	88 27       	eor	r24, r24
    555e:	77 fd       	sbrc	r23, 7
    5560:	80 95       	com	r24
    5562:	98 2f       	mov	r25, r24
    5564:	0e 94 0e 89 	call	0x1121c	; 0x1121c <__floatsisf>
    5568:	3b 01       	movw	r6, r22
    556a:	4c 01       	movw	r8, r24
		y = (x-x2)*(y2-y1)/(x2-x1)+y2;
    556c:	c8 01       	movw	r24, r16
    556e:	b7 01       	movw	r22, r14
    5570:	0e 94 0e 89 	call	0x1121c	; 0x1121c <__floatsisf>
    5574:	a6 01       	movw	r20, r12
    5576:	95 01       	movw	r18, r10
    5578:	0e 94 0f 8d 	call	0x11a1e	; 0x11a1e <__subsf3>
    557c:	7b 01       	movw	r14, r22
    557e:	8c 01       	movw	r16, r24
    5580:	68 85       	ldd	r22, Y+8	; 0x08
    5582:	79 85       	ldd	r23, Y+9	; 0x09
    5584:	88 27       	eor	r24, r24
    5586:	77 fd       	sbrc	r23, 7
    5588:	80 95       	com	r24
    558a:	98 2f       	mov	r25, r24
    558c:	0e 94 0e 89 	call	0x1121c	; 0x1121c <__floatsisf>
    5590:	9b 01       	movw	r18, r22
    5592:	ac 01       	movw	r20, r24
    5594:	c4 01       	movw	r24, r8
    5596:	b3 01       	movw	r22, r6
    5598:	0e 94 0f 8d 	call	0x11a1e	; 0x11a1e <__subsf3>
    559c:	9b 01       	movw	r18, r22
    559e:	ac 01       	movw	r20, r24
    55a0:	c8 01       	movw	r24, r16
    55a2:	b7 01       	movw	r22, r14
    55a4:	0e 94 49 89 	call	0x11292	; 0x11292 <__mulsf3>
    55a8:	7b 01       	movw	r14, r22
    55aa:	8c 01       	movw	r16, r24
    55ac:	c2 01       	movw	r24, r4
    55ae:	b1 01       	movw	r22, r2
    55b0:	0e 94 0e 89 	call	0x1121c	; 0x1121c <__floatsisf>
    55b4:	9b 01       	movw	r18, r22
    55b6:	ac 01       	movw	r20, r24
    55b8:	c6 01       	movw	r24, r12
    55ba:	b5 01       	movw	r22, r10
    55bc:	0e 94 0f 8d 	call	0x11a1e	; 0x11a1e <__subsf3>
    55c0:	9b 01       	movw	r18, r22
    55c2:	ac 01       	movw	r20, r24
    55c4:	c8 01       	movw	r24, r16
    55c6:	b7 01       	movw	r22, r14
    55c8:	0e 94 74 8d 	call	0x11ae8	; 0x11ae8 <__divsf3>
    55cc:	a4 01       	movw	r20, r8
    55ce:	93 01       	movw	r18, r6
    55d0:	0e 94 10 8d 	call	0x11a20	; 0x11a20 <__addsf3>
    55d4:	0e 94 dc 8d 	call	0x11bb8	; 0x11bb8 <__fixsfsi>
    55d8:	cb 01       	movw	r24, r22
	}
	return y;
}
    55da:	df 91       	pop	r29
    55dc:	cf 91       	pop	r28
    55de:	1f 91       	pop	r17
    55e0:	0f 91       	pop	r16
    55e2:	ff 90       	pop	r15
    55e4:	ef 90       	pop	r14
    55e6:	df 90       	pop	r13
    55e8:	cf 90       	pop	r12
    55ea:	bf 90       	pop	r11
    55ec:	af 90       	pop	r10
    55ee:	9f 90       	pop	r9
    55f0:	8f 90       	pop	r8
    55f2:	7f 90       	pop	r7
    55f4:	6f 90       	pop	r6
    55f6:	5f 90       	pop	r5
    55f8:	4f 90       	pop	r4
    55fa:	3f 90       	pop	r3
    55fc:	2f 90       	pop	r2
    55fe:	08 95       	ret
int16_t
LineFunc(const LineGraph *LG, int32_t x)
{
	int16_t y;
	if (LG->x1==LG->x2)
		y = LG->y1;
    5600:	88 85       	ldd	r24, Y+8	; 0x08
    5602:	99 85       	ldd	r25, Y+9	; 0x09
    5604:	ea cf       	rjmp	.-44     	; 0x55da <LineFunc+0xd0>

00005606 <uLineFunc>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
int16_t
uLineFunc(const uLineGraph *LG, uint32_t x)
{
    5606:	2f 92       	push	r2
    5608:	3f 92       	push	r3
    560a:	4f 92       	push	r4
    560c:	5f 92       	push	r5
    560e:	6f 92       	push	r6
    5610:	7f 92       	push	r7
    5612:	8f 92       	push	r8
    5614:	9f 92       	push	r9
    5616:	af 92       	push	r10
    5618:	bf 92       	push	r11
    561a:	cf 92       	push	r12
    561c:	df 92       	push	r13
    561e:	ef 92       	push	r14
    5620:	ff 92       	push	r15
    5622:	0f 93       	push	r16
    5624:	1f 93       	push	r17
    5626:	cf 93       	push	r28
    5628:	df 93       	push	r29
    562a:	ec 01       	movw	r28, r24
    562c:	7a 01       	movw	r14, r20
    562e:	8b 01       	movw	r16, r22
	int16_t y;
	if (LG->x1==LG->x2)
    5630:	28 80       	ld	r2, Y
    5632:	39 80       	ldd	r3, Y+1	; 0x01
    5634:	4a 80       	ldd	r4, Y+2	; 0x02
    5636:	5b 80       	ldd	r5, Y+3	; 0x03
    5638:	6c 81       	ldd	r22, Y+4	; 0x04
    563a:	7d 81       	ldd	r23, Y+5	; 0x05
    563c:	8e 81       	ldd	r24, Y+6	; 0x06
    563e:	9f 81       	ldd	r25, Y+7	; 0x07
    5640:	26 16       	cp	r2, r22
    5642:	37 06       	cpc	r3, r23
    5644:	48 06       	cpc	r4, r24
    5646:	59 06       	cpc	r5, r25
    5648:	09 f4       	brne	.+2      	; 0x564c <uLineFunc+0x46>
    564a:	58 c0       	rjmp	.+176    	; 0x56fc <uLineFunc+0xf6>
		y = LG->y1;
	else {
		float x1=LG->x1, x2=LG->x2, y1=LG->y1, y2=LG->y2;
    564c:	0e 94 0c 89 	call	0x11218	; 0x11218 <__floatunsisf>
    5650:	5b 01       	movw	r10, r22
    5652:	6c 01       	movw	r12, r24
    5654:	6a 85       	ldd	r22, Y+10	; 0x0a
    5656:	7b 85       	ldd	r23, Y+11	; 0x0b
    5658:	88 27       	eor	r24, r24
    565a:	77 fd       	sbrc	r23, 7
    565c:	80 95       	com	r24
    565e:	98 2f       	mov	r25, r24
    5660:	0e 94 0e 89 	call	0x1121c	; 0x1121c <__floatsisf>
    5664:	3b 01       	movw	r6, r22
    5666:	4c 01       	movw	r8, r24
		y = (x-x2)*(y2-y1)/(x2-x1)+y2;
    5668:	c8 01       	movw	r24, r16
    566a:	b7 01       	movw	r22, r14
    566c:	0e 94 0c 89 	call	0x11218	; 0x11218 <__floatunsisf>
    5670:	a6 01       	movw	r20, r12
    5672:	95 01       	movw	r18, r10
    5674:	0e 94 0f 8d 	call	0x11a1e	; 0x11a1e <__subsf3>
    5678:	7b 01       	movw	r14, r22
    567a:	8c 01       	movw	r16, r24
    567c:	68 85       	ldd	r22, Y+8	; 0x08
    567e:	79 85       	ldd	r23, Y+9	; 0x09
    5680:	88 27       	eor	r24, r24
    5682:	77 fd       	sbrc	r23, 7
    5684:	80 95       	com	r24
    5686:	98 2f       	mov	r25, r24
    5688:	0e 94 0e 89 	call	0x1121c	; 0x1121c <__floatsisf>
    568c:	9b 01       	movw	r18, r22
    568e:	ac 01       	movw	r20, r24
    5690:	c4 01       	movw	r24, r8
    5692:	b3 01       	movw	r22, r6
    5694:	0e 94 0f 8d 	call	0x11a1e	; 0x11a1e <__subsf3>
    5698:	9b 01       	movw	r18, r22
    569a:	ac 01       	movw	r20, r24
    569c:	c8 01       	movw	r24, r16
    569e:	b7 01       	movw	r22, r14
    56a0:	0e 94 49 89 	call	0x11292	; 0x11292 <__mulsf3>
    56a4:	7b 01       	movw	r14, r22
    56a6:	8c 01       	movw	r16, r24
    56a8:	c2 01       	movw	r24, r4
    56aa:	b1 01       	movw	r22, r2
    56ac:	0e 94 0c 89 	call	0x11218	; 0x11218 <__floatunsisf>
    56b0:	9b 01       	movw	r18, r22
    56b2:	ac 01       	movw	r20, r24
    56b4:	c6 01       	movw	r24, r12
    56b6:	b5 01       	movw	r22, r10
    56b8:	0e 94 0f 8d 	call	0x11a1e	; 0x11a1e <__subsf3>
    56bc:	9b 01       	movw	r18, r22
    56be:	ac 01       	movw	r20, r24
    56c0:	c8 01       	movw	r24, r16
    56c2:	b7 01       	movw	r22, r14
    56c4:	0e 94 74 8d 	call	0x11ae8	; 0x11ae8 <__divsf3>
    56c8:	a4 01       	movw	r20, r8
    56ca:	93 01       	movw	r18, r6
    56cc:	0e 94 10 8d 	call	0x11a20	; 0x11a20 <__addsf3>
    56d0:	0e 94 dc 8d 	call	0x11bb8	; 0x11bb8 <__fixsfsi>
    56d4:	cb 01       	movw	r24, r22
	}
	return y;
}
    56d6:	df 91       	pop	r29
    56d8:	cf 91       	pop	r28
    56da:	1f 91       	pop	r17
    56dc:	0f 91       	pop	r16
    56de:	ff 90       	pop	r15
    56e0:	ef 90       	pop	r14
    56e2:	df 90       	pop	r13
    56e4:	cf 90       	pop	r12
    56e6:	bf 90       	pop	r11
    56e8:	af 90       	pop	r10
    56ea:	9f 90       	pop	r9
    56ec:	8f 90       	pop	r8
    56ee:	7f 90       	pop	r7
    56f0:	6f 90       	pop	r6
    56f2:	5f 90       	pop	r5
    56f4:	4f 90       	pop	r4
    56f6:	3f 90       	pop	r3
    56f8:	2f 90       	pop	r2
    56fa:	08 95       	ret
int16_t
uLineFunc(const uLineGraph *LG, uint32_t x)
{
	int16_t y;
	if (LG->x1==LG->x2)
		y = LG->y1;
    56fc:	88 85       	ldd	r24, Y+8	; 0x08
    56fe:	99 85       	ldd	r25, Y+9	; 0x09
    5700:	ea cf       	rjmp	.-44     	; 0x56d6 <uLineFunc+0xd0>

00005702 <PGM_uBrokLine>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
int16_t
PGM_uBrokLine(PGM_uDataPoint *Brok, uint16_t x)
{
    5702:	af 92       	push	r10
    5704:	bf 92       	push	r11
    5706:	cf 92       	push	r12
    5708:	df 92       	push	r13
    570a:	ef 92       	push	r14
    570c:	ff 92       	push	r15
    570e:	0f 93       	push	r16
    5710:	1f 93       	push	r17
    5712:	df 93       	push	r29
    5714:	cf 93       	push	r28
    5716:	cd b7       	in	r28, 0x3d	; 61
    5718:	de b7       	in	r29, 0x3e	; 62
    571a:	2c 97       	sbiw	r28, 0x0c	; 12
    571c:	0f b6       	in	r0, 0x3f	; 63
    571e:	f8 94       	cli
    5720:	de bf       	out	0x3e, r29	; 62
    5722:	0f be       	out	0x3f, r0	; 63
    5724:	cd bf       	out	0x3d, r28	; 61
    5726:	dc 01       	movw	r26, r24

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    5728:	fc 01       	movw	r30, r24
    572a:	85 91       	lpm	r24, Z+
    572c:	94 91       	lpm	r25, Z+
	uLineGraph Segm;
	Segm.x2 = prw(&Brok->x);
    572e:	7c 01       	movw	r14, r24
    5730:	00 e0       	ldi	r16, 0x00	; 0
    5732:	10 e0       	ldi	r17, 0x00	; 0
    5734:	5b 01       	movw	r10, r22
    5736:	cc 24       	eor	r12, r12
    5738:	dd 24       	eor	r13, r13
	do {
		Segm.x1 = Segm.x2;
		Segm.x2 = prw(&(++Brok)->x);
    573a:	cd 01       	movw	r24, r26
    573c:	04 96       	adiw	r24, 0x04	; 4
    573e:	fc 01       	movw	r30, r24
    5740:	25 91       	lpm	r18, Z+
    5742:	34 91       	lpm	r19, Z+
    5744:	ad 01       	movw	r20, r26
    5746:	b7 01       	movw	r22, r14
    5748:	f8 01       	movw	r30, r16
    574a:	dc 01       	movw	r26, r24
    574c:	79 01       	movw	r14, r18
    574e:	00 e0       	ldi	r16, 0x00	; 0
    5750:	10 e0       	ldi	r17, 0x00	; 0
	} while(x>Segm.x2);
    5752:	ea 14       	cp	r14, r10
    5754:	fb 04       	cpc	r15, r11
    5756:	0c 05       	cpc	r16, r12
    5758:	1d 05       	cpc	r17, r13
    575a:	78 f3       	brcs	.-34     	; 0x573a <PGM_uBrokLine+0x38>
    575c:	ca 01       	movw	r24, r20
    575e:	9b 01       	movw	r18, r22
    5760:	af 01       	movw	r20, r30
    5762:	69 83       	std	Y+1, r22	; 0x01
    5764:	3a 83       	std	Y+2, r19	; 0x02
    5766:	eb 83       	std	Y+3, r30	; 0x03
    5768:	5c 83       	std	Y+4, r21	; 0x04
    576a:	ed 82       	std	Y+5, r14	; 0x05
    576c:	fe 82       	std	Y+6, r15	; 0x06
    576e:	0f 83       	std	Y+7, r16	; 0x07
    5770:	18 87       	std	Y+8, r17	; 0x08
    5772:	fc 01       	movw	r30, r24
    5774:	32 96       	adiw	r30, 0x02	; 2
    5776:	85 91       	lpm	r24, Z+
    5778:	94 91       	lpm	r25, Z+
	Segm.y1 = (int16_t)prw(&(Brok-1)->y);
    577a:	9a 87       	std	Y+10, r25	; 0x0a
    577c:	89 87       	std	Y+9, r24	; 0x09
    577e:	fd 01       	movw	r30, r26
    5780:	32 96       	adiw	r30, 0x02	; 2
    5782:	85 91       	lpm	r24, Z+
    5784:	94 91       	lpm	r25, Z+
	Segm.y2 = (int16_t)prw(&Brok->y);
    5786:	9c 87       	std	Y+12, r25	; 0x0c
    5788:	8b 87       	std	Y+11, r24	; 0x0b
	return uLineFunc(&Segm, x);
    578a:	ce 01       	movw	r24, r28
    578c:	01 96       	adiw	r24, 0x01	; 1
    578e:	b6 01       	movw	r22, r12
    5790:	a5 01       	movw	r20, r10
    5792:	0e 94 03 2b 	call	0x5606	; 0x5606 <uLineFunc>
}
    5796:	2c 96       	adiw	r28, 0x0c	; 12
    5798:	0f b6       	in	r0, 0x3f	; 63
    579a:	f8 94       	cli
    579c:	de bf       	out	0x3e, r29	; 62
    579e:	0f be       	out	0x3f, r0	; 63
    57a0:	cd bf       	out	0x3d, r28	; 61
    57a2:	cf 91       	pop	r28
    57a4:	df 91       	pop	r29
    57a6:	1f 91       	pop	r17
    57a8:	0f 91       	pop	r16
    57aa:	ff 90       	pop	r15
    57ac:	ef 90       	pop	r14
    57ae:	df 90       	pop	r13
    57b0:	cf 90       	pop	r12
    57b2:	bf 90       	pop	r11
    57b4:	af 90       	pop	r10
    57b6:	08 95       	ret

000057b8 <InterBrokLine>:
	uint8_t WiAbsc, int16_t (*TblAbsc)[WiAbsc], uint8_t Absc,
	uint8_t WiOrdi, int16_t (*TblOrdi)[WiOrdi], uint8_t Ordi,
	uint8_t Len,
	int16_t x
)
{
    57b8:	2f 92       	push	r2
    57ba:	3f 92       	push	r3
    57bc:	4f 92       	push	r4
    57be:	5f 92       	push	r5
    57c0:	6f 92       	push	r6
    57c2:	7f 92       	push	r7
    57c4:	8f 92       	push	r8
    57c6:	9f 92       	push	r9
    57c8:	af 92       	push	r10
    57ca:	bf 92       	push	r11
    57cc:	cf 92       	push	r12
    57ce:	df 92       	push	r13
    57d0:	ef 92       	push	r14
    57d2:	ff 92       	push	r15
    57d4:	0f 93       	push	r16
    57d6:	1f 93       	push	r17
    57d8:	df 93       	push	r29
    57da:	cf 93       	push	r28
    57dc:	cd b7       	in	r28, 0x3d	; 61
    57de:	de b7       	in	r29, 0x3e	; 62
    57e0:	2e 97       	sbiw	r28, 0x0e	; 14
    57e2:	0f b6       	in	r0, 0x3f	; 63
    57e4:	f8 94       	cli
    57e6:	de bf       	out	0x3e, r29	; 62
    57e8:	0f be       	out	0x3f, r0	; 63
    57ea:	cd bf       	out	0x3d, r28	; 61
    57ec:	2b 01       	movw	r4, r22
    57ee:	2d 87       	std	Y+13, r18	; 0x0d
    57f0:	18 01       	movw	r2, r16
    57f2:	ee 86       	std	Y+14, r14	; 0x0e
    57f4:	7c 2d       	mov	r23, r12
	LineGraph Segm;
	uint8_t i = 0;
	Segm.x2=TblAbsc[0][Absc];
    57f6:	c4 2e       	mov	r12, r20
    57f8:	dd 24       	eor	r13, r13
    57fa:	cc 0c       	add	r12, r12
    57fc:	dd 1c       	adc	r13, r13
    57fe:	f2 01       	movw	r30, r4
    5800:	ec 0d       	add	r30, r12
    5802:	fd 1d       	adc	r31, r13
    5804:	20 81       	ld	r18, Z
    5806:	31 81       	ldd	r19, Z+1	; 0x01
    5808:	79 01       	movw	r14, r18
    580a:	00 27       	eor	r16, r16
    580c:	f7 fc       	sbrc	r15, 7
    580e:	00 95       	com	r16
    5810:	10 2f       	mov	r17, r16
    5812:	ed 82       	std	Y+5, r14	; 0x05
    5814:	fe 82       	std	Y+6, r15	; 0x06
    5816:	0f 83       	std	Y+7, r16	; 0x07
    5818:	18 87       	std	Y+8, r17	; 0x08
    581a:	a8 2f       	mov	r26, r24
    581c:	b0 e0       	ldi	r27, 0x00	; 0
    581e:	aa 0f       	add	r26, r26
    5820:	bb 1f       	adc	r27, r27
    5822:	35 01       	movw	r6, r10
    5824:	88 24       	eor	r8, r8
    5826:	77 fc       	sbrc	r7, 7
    5828:	80 94       	com	r8
    582a:	98 2c       	mov	r9, r8
    582c:	60 e0       	ldi	r22, 0x00	; 0
    582e:	02 c0       	rjmp	.+4      	; 0x5834 <InterBrokLine+0x7c>
	do {
		Segm.x1 = Segm.x2;
		Segm.x2 = TblAbsc[++i][Absc];
	} while(x>Segm.x2 && i<Len);
    5830:	79 01       	movw	r14, r18
    5832:	8a 01       	movw	r16, r20
	LineGraph Segm;
	uint8_t i = 0;
	Segm.x2=TblAbsc[0][Absc];
	do {
		Segm.x1 = Segm.x2;
		Segm.x2 = TblAbsc[++i][Absc];
    5834:	6f 5f       	subi	r22, 0xFF	; 255
    5836:	a6 2e       	mov	r10, r22
    5838:	bb 24       	eor	r11, r11
    583a:	aa 9e       	mul	r10, r26
    583c:	f0 01       	movw	r30, r0
    583e:	ab 9e       	mul	r10, r27
    5840:	f0 0d       	add	r31, r0
    5842:	ba 9e       	mul	r11, r26
    5844:	f0 0d       	add	r31, r0
    5846:	11 24       	eor	r1, r1
    5848:	e4 0d       	add	r30, r4
    584a:	f5 1d       	adc	r31, r5
    584c:	ec 0d       	add	r30, r12
    584e:	fd 1d       	adc	r31, r13
    5850:	80 81       	ld	r24, Z
    5852:	91 81       	ldd	r25, Z+1	; 0x01
    5854:	9c 01       	movw	r18, r24
    5856:	44 27       	eor	r20, r20
    5858:	37 fd       	sbrc	r19, 7
    585a:	40 95       	com	r20
    585c:	54 2f       	mov	r21, r20
	} while(x>Segm.x2 && i<Len);
    585e:	26 15       	cp	r18, r6
    5860:	37 05       	cpc	r19, r7
    5862:	48 05       	cpc	r20, r8
    5864:	59 05       	cpc	r21, r9
    5866:	14 f4       	brge	.+4      	; 0x586c <InterBrokLine+0xb4>
    5868:	67 17       	cp	r22, r23
    586a:	10 f3       	brcs	.-60     	; 0x5830 <InterBrokLine+0x78>
    586c:	e9 82       	std	Y+1, r14	; 0x01
    586e:	fa 82       	std	Y+2, r15	; 0x02
    5870:	0b 83       	std	Y+3, r16	; 0x03
    5872:	1c 83       	std	Y+4, r17	; 0x04
    5874:	2d 83       	std	Y+5, r18	; 0x05
    5876:	3e 83       	std	Y+6, r19	; 0x06
    5878:	4f 83       	std	Y+7, r20	; 0x07
    587a:	58 87       	std	Y+8, r21	; 0x08
	Segm.y1 = TblOrdi[i-1][Ordi];
    587c:	8d 85       	ldd	r24, Y+13	; 0x0d
    587e:	28 2f       	mov	r18, r24
    5880:	30 e0       	ldi	r19, 0x00	; 0
    5882:	22 0f       	add	r18, r18
    5884:	33 1f       	adc	r19, r19
    5886:	8e 85       	ldd	r24, Y+14	; 0x0e
    5888:	a8 2f       	mov	r26, r24
    588a:	b0 e0       	ldi	r27, 0x00	; 0
    588c:	08 94       	sec
    588e:	a1 08       	sbc	r10, r1
    5890:	b1 08       	sbc	r11, r1
    5892:	a2 9e       	mul	r10, r18
    5894:	f0 01       	movw	r30, r0
    5896:	a3 9e       	mul	r10, r19
    5898:	f0 0d       	add	r31, r0
    589a:	b2 9e       	mul	r11, r18
    589c:	f0 0d       	add	r31, r0
    589e:	11 24       	eor	r1, r1
    58a0:	08 94       	sec
    58a2:	a1 1c       	adc	r10, r1
    58a4:	b1 1c       	adc	r11, r1
    58a6:	e2 0d       	add	r30, r2
    58a8:	f3 1d       	adc	r31, r3
    58aa:	aa 0f       	add	r26, r26
    58ac:	bb 1f       	adc	r27, r27
    58ae:	ea 0f       	add	r30, r26
    58b0:	fb 1f       	adc	r31, r27
    58b2:	80 81       	ld	r24, Z
    58b4:	91 81       	ldd	r25, Z+1	; 0x01
    58b6:	9a 87       	std	Y+10, r25	; 0x0a
    58b8:	89 87       	std	Y+9, r24	; 0x09
	Segm.y2 = TblOrdi[i][Ordi];
    58ba:	a2 9e       	mul	r10, r18
    58bc:	c0 01       	movw	r24, r0
    58be:	a3 9e       	mul	r10, r19
    58c0:	90 0d       	add	r25, r0
    58c2:	b2 9e       	mul	r11, r18
    58c4:	90 0d       	add	r25, r0
    58c6:	11 24       	eor	r1, r1
    58c8:	82 0d       	add	r24, r2
    58ca:	93 1d       	adc	r25, r3
    58cc:	a8 0f       	add	r26, r24
    58ce:	b9 1f       	adc	r27, r25
    58d0:	8d 91       	ld	r24, X+
    58d2:	9c 91       	ld	r25, X
    58d4:	9c 87       	std	Y+12, r25	; 0x0c
    58d6:	8b 87       	std	Y+11, r24	; 0x0b
	return LineFunc(&Segm, x);
    58d8:	ce 01       	movw	r24, r28
    58da:	01 96       	adiw	r24, 0x01	; 1
    58dc:	b4 01       	movw	r22, r8
    58de:	a3 01       	movw	r20, r6
    58e0:	0e 94 85 2a 	call	0x550a	; 0x550a <LineFunc>
}
    58e4:	2e 96       	adiw	r28, 0x0e	; 14
    58e6:	0f b6       	in	r0, 0x3f	; 63
    58e8:	f8 94       	cli
    58ea:	de bf       	out	0x3e, r29	; 62
    58ec:	0f be       	out	0x3f, r0	; 63
    58ee:	cd bf       	out	0x3d, r28	; 61
    58f0:	cf 91       	pop	r28
    58f2:	df 91       	pop	r29
    58f4:	1f 91       	pop	r17
    58f6:	0f 91       	pop	r16
    58f8:	ff 90       	pop	r15
    58fa:	ef 90       	pop	r14
    58fc:	df 90       	pop	r13
    58fe:	cf 90       	pop	r12
    5900:	bf 90       	pop	r11
    5902:	af 90       	pop	r10
    5904:	9f 90       	pop	r9
    5906:	8f 90       	pop	r8
    5908:	7f 90       	pop	r7
    590a:	6f 90       	pop	r6
    590c:	5f 90       	pop	r5
    590e:	4f 90       	pop	r4
    5910:	3f 90       	pop	r3
    5912:	2f 90       	pop	r2
    5914:	08 95       	ret

00005916 <TWI_Init>:
}

uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    5916:	90 91 cf 02 	lds	r25, 0x02CF
	VacantTimer8Sys += n;
    591a:	89 2f       	mov	r24, r25
    591c:	8f 5f       	subi	r24, 0xFF	; 255

// ~~~~~~~~~~~
void
TWI_Init(void)
{
	TD_TWI_Poll = Timer8SysAlloc(1);
    591e:	90 93 d2 04 	sts	0x04D2, r25
    5922:	8f 5f       	subi	r24, 0xFF	; 255
    5924:	80 93 cf 02 	sts	0x02CF, r24
    5928:	81 50       	subi	r24, 0x01	; 1
	TD_TWI_Timeout = Timer8SysAlloc(1);
    592a:	80 93 d3 04 	sts	0x04D3, r24

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    592e:	80 91 d0 02 	lds	r24, 0x02D0
	VacantTimer16Sys += n;
    5932:	8f 5f       	subi	r24, 0xFF	; 255
    5934:	80 93 d0 02 	sts	0x02D0, r24
    5938:	81 50       	subi	r24, 0x01	; 1
	TD_RTC_Check = Timer16SysAlloc(1);
    593a:	80 93 d4 04 	sts	0x04D4, r24
	StartTimer16(TD_RTC_Check, 300);
    593e:	6c e2       	ldi	r22, 0x2C	; 44
    5940:	71 e0       	ldi	r23, 0x01	; 1
    5942:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
	TWBR = 144;	//50
    5946:	80 e9       	ldi	r24, 0x90	; 144
    5948:	80 93 b8 00 	sts	0x00B8, r24
}
    594c:	08 95       	ret

0000594e <TWI_Error>:
// ~~~~~~~~~~~
void
TWI_Error(void)
{
	TWI_Error_Counter++;
    594e:	80 91 e5 08 	lds	r24, 0x08E5
    5952:	90 91 e6 08 	lds	r25, 0x08E6
    5956:	01 96       	adiw	r24, 0x01	; 1
    5958:	90 93 e6 08 	sts	0x08E6, r25
    595c:	80 93 e5 08 	sts	0x08E5, r24
	//StopTWI();
	PowerOffTWI();
    5960:	10 92 bc 00 	sts	0x00BC, r1
	TWI_Phase = PCF_START;
    5964:	10 92 c3 07 	sts	0x07C3, r1
	StartTimer8(TD_TWI_Poll, 49);
    5968:	80 91 d2 04 	lds	r24, 0x04D2
    596c:	61 e3       	ldi	r22, 0x31	; 49
    596e:	0e 94 1f 24 	call	0x483e	; 0x483e <StartTimer8>
}
    5972:	08 95       	ret

00005974 <WriteRTC>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
WriteRTC(uint8_t Addr, uint8_t Dat)
{
    5974:	bf 92       	push	r11
    5976:	cf 92       	push	r12
    5978:	df 92       	push	r13
    597a:	ef 92       	push	r14
    597c:	ff 92       	push	r15
    597e:	0f 93       	push	r16
    5980:	1f 93       	push	r17
/*	if (!(TWCR &(1<<TWINT))){ //Wait for the end of current TWI operation and isuue STOP
		_delay_us(100);
		StopTWI();
		_delay_us(50);
	}*/
	PowerOffTWI();
    5982:	4c eb       	ldi	r20, 0xBC	; 188
    5984:	c4 2e       	mov	r12, r20
    5986:	d1 2c       	mov	r13, r1
    5988:	f6 01       	movw	r30, r12
    598a:	10 82       	st	Z, r1
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    598c:	e0 e9       	ldi	r30, 0x90	; 144
    598e:	f1 e0       	ldi	r31, 0x01	; 1
    5990:	31 97       	sbiw	r30, 0x01	; 1
    5992:	f1 f7       	brne	.-4      	; 0x5990 <WriteRTC+0x1c>
	_delay_us(100);
	//_delay_us(150);_delay_us(150);
	StartTWI();
    5994:	94 ea       	ldi	r25, 0xA4	; 164
    5996:	f6 01       	movw	r30, r12
    5998:	90 83       	st	Z, r25
    599a:	08 e5       	ldi	r16, 0x58	; 88
    599c:	12 e0       	ldi	r17, 0x02	; 2
    599e:	f8 01       	movw	r30, r16
    59a0:	31 97       	sbiw	r30, 0x01	; 1
    59a2:	f1 f7       	brne	.-4      	; 0x59a0 <WriteRTC+0x2c>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = SLA_W(PCF_SLA);
    59a4:	f8 01       	movw	r30, r16
    59a6:	31 97       	sbiw	r30, 0x01	; 1
    59a8:	f1 f7       	brne	.-4      	; 0x59a6 <WriteRTC+0x32>
    59aa:	3b eb       	ldi	r19, 0xBB	; 187
    59ac:	e3 2e       	mov	r14, r19
    59ae:	f1 2c       	mov	r15, r1
    59b0:	90 ed       	ldi	r25, 0xD0	; 208
    59b2:	f7 01       	movw	r30, r14
    59b4:	90 83       	st	Z, r25
    59b6:	90 81       	ld	r25, Z
    59b8:	90 83       	st	Z, r25
	RunTWI();
    59ba:	24 e8       	ldi	r18, 0x84	; 132
    59bc:	b2 2e       	mov	r11, r18
    59be:	f6 01       	movw	r30, r12
    59c0:	b0 82       	st	Z, r11
    59c2:	f8 01       	movw	r30, r16
    59c4:	31 97       	sbiw	r30, 0x01	; 1
    59c6:	f1 f7       	brne	.-4      	; 0x59c4 <WriteRTC+0x50>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = AddrSec+Addr;
    59c8:	f8 01       	movw	r30, r16
    59ca:	31 97       	sbiw	r30, 0x01	; 1
    59cc:	f1 f7       	brne	.-4      	; 0x59ca <WriteRTC+0x56>
    59ce:	f7 01       	movw	r30, r14
    59d0:	80 83       	st	Z, r24
	RunTWI();
    59d2:	f6 01       	movw	r30, r12
    59d4:	b0 82       	st	Z, r11
    59d6:	c8 01       	movw	r24, r16
    59d8:	01 97       	sbiw	r24, 0x01	; 1
    59da:	f1 f7       	brne	.-4      	; 0x59d8 <WriteRTC+0x64>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = CodBCD(Dat);
    59dc:	c8 01       	movw	r24, r16
    59de:	01 97       	sbiw	r24, 0x01	; 1
    59e0:	f1 f7       	brne	.-4      	; 0x59de <WriteRTC+0x6a>
    59e2:	86 2f       	mov	r24, r22
    59e4:	0e 94 6e 2a 	call	0x54dc	; 0x54dc <CodBCD>
    59e8:	f7 01       	movw	r30, r14
    59ea:	80 83       	st	Z, r24
	RunTWI();
    59ec:	f6 01       	movw	r30, r12
    59ee:	b0 82       	st	Z, r11
    59f0:	c8 01       	movw	r24, r16
    59f2:	01 97       	sbiw	r24, 0x01	; 1
    59f4:	f1 f7       	brne	.-4      	; 0x59f2 <WriteRTC+0x7e>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	StopTWI();
    59f6:	c8 01       	movw	r24, r16
    59f8:	01 97       	sbiw	r24, 0x01	; 1
    59fa:	f1 f7       	brne	.-4      	; 0x59f8 <WriteRTC+0x84>
    59fc:	84 e9       	ldi	r24, 0x94	; 148
    59fe:	80 83       	st	Z, r24
	TWI_Phase = PCF_START;
    5a00:	10 92 c3 07 	sts	0x07C3, r1
}
    5a04:	1f 91       	pop	r17
    5a06:	0f 91       	pop	r16
    5a08:	ff 90       	pop	r15
    5a0a:	ef 90       	pop	r14
    5a0c:	df 90       	pop	r13
    5a0e:	cf 90       	pop	r12
    5a10:	bf 90       	pop	r11
    5a12:	08 95       	ret

00005a14 <SetWeekday>:
*/

// ~~~~~~~~~~~~~~~
// 31.12.00 was Su
uint8_t SetWeekday(uint8_t Year, uint8_t Month, uint8_t MDay)
{
    5a14:	a6 2f       	mov	r26, r22
	uint8_t DayCount;
	uint8_t LastYear = Year-1;
    5a16:	b8 2f       	mov	r27, r24
    5a18:	b1 50       	subi	r27, 0x01	; 1

	DayCount = (LastYear+LastYear/4);
    5a1a:	5b 2f       	mov	r21, r27
    5a1c:	56 95       	lsr	r21
    5a1e:	56 95       	lsr	r21
    5a20:	5b 0f       	add	r21, r27
	for (uint8_t i=1; i<Month; DayCount+=prb(DaysMonth+i++)%7);
    5a22:	62 30       	cpi	r22, 0x02	; 2
    5a24:	88 f0       	brcs	.+34     	; 0x5a48 <SetWeekday+0x34>
    5a26:	e4 e2       	ldi	r30, 0x24	; 36
    5a28:	f3 e0       	ldi	r31, 0x03	; 3
    5a2a:	a2 50       	subi	r26, 0x02	; 2
    5a2c:	2a 2f       	mov	r18, r26
    5a2e:	30 e0       	ldi	r19, 0x00	; 0
    5a30:	ae 5f       	subi	r26, 0xFE	; 254
    5a32:	2b 5d       	subi	r18, 0xDB	; 219
    5a34:	3c 4f       	sbci	r19, 0xFC	; 252

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    5a36:	84 91       	lpm	r24, Z+
    5a38:	67 e0       	ldi	r22, 0x07	; 7
    5a3a:	0e 94 78 8e 	call	0x11cf0	; 0x11cf0 <__udivmodqi4>
    5a3e:	59 0f       	add	r21, r25
    5a40:	31 96       	adiw	r30, 0x01	; 1
    5a42:	e2 17       	cp	r30, r18
    5a44:	f3 07       	cpc	r31, r19
    5a46:	b9 f7       	brne	.-18     	; 0x5a36 <SetWeekday+0x22>
    5a48:	25 2f       	mov	r18, r21
	if (LastYear%4==3 && Month>2)
    5a4a:	b3 70       	andi	r27, 0x03	; 3
    5a4c:	b3 30       	cpi	r27, 0x03	; 3
    5a4e:	51 f0       	breq	.+20     	; 0x5a64 <SetWeekday+0x50>
		DayCount++;
    5a50:	84 2f       	mov	r24, r20
    5a52:	67 e0       	ldi	r22, 0x07	; 7
    5a54:	0e 94 78 8e 	call	0x11cf0	; 0x11cf0 <__udivmodqi4>
    5a58:	82 2f       	mov	r24, r18
    5a5a:	89 0f       	add	r24, r25
    5a5c:	0e 94 78 8e 	call	0x11cf0	; 0x11cf0 <__udivmodqi4>
	DayCount += MDay%7;
	return DayCount%7;
}
    5a60:	89 2f       	mov	r24, r25
    5a62:	08 95       	ret
	uint8_t DayCount;
	uint8_t LastYear = Year-1;

	DayCount = (LastYear+LastYear/4);
	for (uint8_t i=1; i<Month; DayCount+=prb(DaysMonth+i++)%7);
	if (LastYear%4==3 && Month>2)
    5a64:	a3 30       	cpi	r26, 0x03	; 3
    5a66:	a0 f3       	brcs	.-24     	; 0x5a50 <SetWeekday+0x3c>
		DayCount++;
    5a68:	2f 5f       	subi	r18, 0xFF	; 255
    5a6a:	f2 cf       	rjmp	.-28     	; 0x5a50 <SetWeekday+0x3c>

00005a6c <SetSec>:
}
// ~~~~~~~~~
void
SetSec(void)
{
	WriteRTC(0, Tm_Sec);
    5a6c:	80 e0       	ldi	r24, 0x00	; 0
    5a6e:	60 91 f7 06 	lds	r22, 0x06F7
    5a72:	0e 94 ba 2c 	call	0x5974	; 0x5974 <WriteRTC>
	TrueTime_Sec = Tm_Sec;
    5a76:	80 91 f7 06 	lds	r24, 0x06F7
    5a7a:	80 93 14 09 	sts	0x0914, r24
}
    5a7e:	08 95       	ret

00005a80 <SetMin>:

// ~~~~~~~~~
void
SetMin(void)
{
	WriteRTC(1, Tm_Min);
    5a80:	81 e0       	ldi	r24, 0x01	; 1
    5a82:	60 91 51 06 	lds	r22, 0x0651
    5a86:	0e 94 ba 2c 	call	0x5974	; 0x5974 <WriteRTC>
	TrueTime_Min = Tm_Min;
    5a8a:	80 91 51 06 	lds	r24, 0x0651
    5a8e:	80 93 16 09 	sts	0x0916, r24
}
    5a92:	08 95       	ret

00005a94 <SetHour>:

// ~~~~~~~~~~
void
SetHour(void)
{
	WriteRTC(2,  Tm_Hour);
    5a94:	82 e0       	ldi	r24, 0x02	; 2
    5a96:	60 91 c1 05 	lds	r22, 0x05C1
    5a9a:	0e 94 ba 2c 	call	0x5974	; 0x5974 <WriteRTC>
	TrueTime_Hour = Tm_Hour;
    5a9e:	80 91 c1 05 	lds	r24, 0x05C1
    5aa2:	80 93 d8 05 	sts	0x05D8, r24
}
    5aa6:	08 95       	ret

00005aa8 <SetMDay>:
// ~~~~~~~~~~
void
SetMDay(void)
{
	WriteRTC(4,  Tm_MDay);
    5aa8:	84 e0       	ldi	r24, 0x04	; 4
    5aaa:	60 91 5f 0b 	lds	r22, 0x0B5F
    5aae:	0e 94 ba 2c 	call	0x5974	; 0x5974 <WriteRTC>
	TrueTime_MDay = Tm_MDay;
    5ab2:	80 91 5f 0b 	lds	r24, 0x0B5F
    5ab6:	80 93 56 06 	sts	0x0656, r24
}
    5aba:	08 95       	ret

00005abc <SetMon>:
// ~~~~~~~~~
void
SetMon(void)
{
	WriteRTC(5, Tm_Mon);
    5abc:	85 e0       	ldi	r24, 0x05	; 5
    5abe:	60 91 cc 07 	lds	r22, 0x07CC
    5ac2:	0e 94 ba 2c 	call	0x5974	; 0x5974 <WriteRTC>
	TrueTime_Mon = Tm_Mon;
    5ac6:	80 91 cc 07 	lds	r24, 0x07CC
    5aca:	80 93 15 09 	sts	0x0915, r24
}
    5ace:	08 95       	ret

00005ad0 <SetYear>:
// ~~~~~~~~~~~~~
void
SetYear(void)
{
	WriteRTC(6, Tm_Year);
    5ad0:	86 e0       	ldi	r24, 0x06	; 6
    5ad2:	60 91 de 05 	lds	r22, 0x05DE
    5ad6:	0e 94 ba 2c 	call	0x5974	; 0x5974 <WriteRTC>
	TrueTime_Year = Tm_Year;
    5ada:	80 91 de 05 	lds	r24, 0x05DE
    5ade:	80 93 c1 07 	sts	0x07C1, r24
}
    5ae2:	08 95       	ret

00005ae4 <SetDateTime>:
// ~~~~~~~~~~~~~
void
SetDateTime(uint8_t Year, uint8_t Month, uint8_t Day, uint8_t WDay, uint8_t Hour, uint8_t Min, uint8_t Sec){
    5ae4:	5f 92       	push	r5
    5ae6:	6f 92       	push	r6
    5ae8:	7f 92       	push	r7
    5aea:	8f 92       	push	r8
    5aec:	9f 92       	push	r9
    5aee:	af 92       	push	r10
    5af0:	bf 92       	push	r11
    5af2:	cf 92       	push	r12
    5af4:	df 92       	push	r13
    5af6:	ef 92       	push	r14
    5af8:	ff 92       	push	r15
    5afa:	0f 93       	push	r16
    5afc:	1f 93       	push	r17
    5afe:	58 2e       	mov	r5, r24
    5b00:	66 2e       	mov	r6, r22
    5b02:	74 2e       	mov	r7, r20
    5b04:	f2 2e       	mov	r15, r18
    5b06:	8c 2d       	mov	r24, r12
	PowerOffTWI();
    5b08:	7c eb       	ldi	r23, 0xBC	; 188
    5b0a:	87 2e       	mov	r8, r23
    5b0c:	91 2c       	mov	r9, r1
    5b0e:	f4 01       	movw	r30, r8
    5b10:	10 82       	st	Z, r1
    5b12:	e0 e9       	ldi	r30, 0x90	; 144
    5b14:	f1 e0       	ldi	r31, 0x01	; 1
    5b16:	31 97       	sbiw	r30, 0x01	; 1
    5b18:	f1 f7       	brne	.-4      	; 0x5b16 <SetDateTime+0x32>
	_delay_us(100);
	//_delay_us(150);_delay_us(150);
	StartTWI();
    5b1a:	94 ea       	ldi	r25, 0xA4	; 164
    5b1c:	f4 01       	movw	r30, r8
    5b1e:	90 83       	st	Z, r25
    5b20:	68 e5       	ldi	r22, 0x58	; 88
    5b22:	c6 2e       	mov	r12, r22
    5b24:	62 e0       	ldi	r22, 0x02	; 2
    5b26:	d6 2e       	mov	r13, r22
    5b28:	f6 01       	movw	r30, r12
    5b2a:	31 97       	sbiw	r30, 0x01	; 1
    5b2c:	f1 f7       	brne	.-4      	; 0x5b2a <SetDateTime+0x46>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = SLA_W(PCF_SLA);
    5b2e:	f6 01       	movw	r30, r12
    5b30:	31 97       	sbiw	r30, 0x01	; 1
    5b32:	f1 f7       	brne	.-4      	; 0x5b30 <SetDateTime+0x4c>
    5b34:	5b eb       	ldi	r21, 0xBB	; 187
    5b36:	a5 2e       	mov	r10, r21
    5b38:	b1 2c       	mov	r11, r1
    5b3a:	90 ed       	ldi	r25, 0xD0	; 208
    5b3c:	f5 01       	movw	r30, r10
    5b3e:	90 83       	st	Z, r25
    5b40:	90 81       	ld	r25, Z
    5b42:	90 83       	st	Z, r25
	RunTWI();
    5b44:	14 e8       	ldi	r17, 0x84	; 132
    5b46:	f4 01       	movw	r30, r8
    5b48:	10 83       	st	Z, r17
    5b4a:	f6 01       	movw	r30, r12
    5b4c:	31 97       	sbiw	r30, 0x01	; 1
    5b4e:	f1 f7       	brne	.-4      	; 0x5b4c <SetDateTime+0x68>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = AddrSec;
    5b50:	f6 01       	movw	r30, r12
    5b52:	31 97       	sbiw	r30, 0x01	; 1
    5b54:	f1 f7       	brne	.-4      	; 0x5b52 <SetDateTime+0x6e>
    5b56:	f5 01       	movw	r30, r10
    5b58:	10 82       	st	Z, r1
	RunTWI();
    5b5a:	f4 01       	movw	r30, r8
    5b5c:	10 83       	st	Z, r17
    5b5e:	f6 01       	movw	r30, r12
    5b60:	31 97       	sbiw	r30, 0x01	; 1
    5b62:	f1 f7       	brne	.-4      	; 0x5b60 <SetDateTime+0x7c>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = CodBCD(Sec);
    5b64:	f6 01       	movw	r30, r12
    5b66:	31 97       	sbiw	r30, 0x01	; 1
    5b68:	f1 f7       	brne	.-4      	; 0x5b66 <SetDateTime+0x82>
    5b6a:	0e 94 6e 2a 	call	0x54dc	; 0x54dc <CodBCD>
    5b6e:	f5 01       	movw	r30, r10
    5b70:	80 83       	st	Z, r24
	RunTWI();
    5b72:	f4 01       	movw	r30, r8
    5b74:	10 83       	st	Z, r17
    5b76:	c6 01       	movw	r24, r12
    5b78:	01 97       	sbiw	r24, 0x01	; 1
    5b7a:	f1 f7       	brne	.-4      	; 0x5b78 <SetDateTime+0x94>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = CodBCD(Min);
    5b7c:	c6 01       	movw	r24, r12
    5b7e:	01 97       	sbiw	r24, 0x01	; 1
    5b80:	f1 f7       	brne	.-4      	; 0x5b7e <SetDateTime+0x9a>
    5b82:	8e 2d       	mov	r24, r14
    5b84:	0e 94 6e 2a 	call	0x54dc	; 0x54dc <CodBCD>
    5b88:	f5 01       	movw	r30, r10
    5b8a:	80 83       	st	Z, r24
	RunTWI();
    5b8c:	f4 01       	movw	r30, r8
    5b8e:	10 83       	st	Z, r17
    5b90:	c6 01       	movw	r24, r12
    5b92:	01 97       	sbiw	r24, 0x01	; 1
    5b94:	f1 f7       	brne	.-4      	; 0x5b92 <SetDateTime+0xae>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = CodBCD(Hour);
    5b96:	c6 01       	movw	r24, r12
    5b98:	01 97       	sbiw	r24, 0x01	; 1
    5b9a:	f1 f7       	brne	.-4      	; 0x5b98 <SetDateTime+0xb4>
    5b9c:	80 2f       	mov	r24, r16
    5b9e:	0e 94 6e 2a 	call	0x54dc	; 0x54dc <CodBCD>
    5ba2:	f5 01       	movw	r30, r10
    5ba4:	80 83       	st	Z, r24
	RunTWI();
    5ba6:	f4 01       	movw	r30, r8
    5ba8:	10 83       	st	Z, r17
    5baa:	c6 01       	movw	r24, r12
    5bac:	01 97       	sbiw	r24, 0x01	; 1
    5bae:	f1 f7       	brne	.-4      	; 0x5bac <SetDateTime+0xc8>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = WDay;
    5bb0:	c6 01       	movw	r24, r12
    5bb2:	01 97       	sbiw	r24, 0x01	; 1
    5bb4:	f1 f7       	brne	.-4      	; 0x5bb2 <SetDateTime+0xce>
    5bb6:	f5 01       	movw	r30, r10
    5bb8:	f0 82       	st	Z, r15
	RunTWI();
    5bba:	f4 01       	movw	r30, r8
    5bbc:	10 83       	st	Z, r17
    5bbe:	c6 01       	movw	r24, r12
    5bc0:	01 97       	sbiw	r24, 0x01	; 1
    5bc2:	f1 f7       	brne	.-4      	; 0x5bc0 <SetDateTime+0xdc>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = CodBCD(Day);
    5bc4:	c6 01       	movw	r24, r12
    5bc6:	01 97       	sbiw	r24, 0x01	; 1
    5bc8:	f1 f7       	brne	.-4      	; 0x5bc6 <SetDateTime+0xe2>
    5bca:	87 2d       	mov	r24, r7
    5bcc:	0e 94 6e 2a 	call	0x54dc	; 0x54dc <CodBCD>
    5bd0:	f5 01       	movw	r30, r10
    5bd2:	80 83       	st	Z, r24
	RunTWI();
    5bd4:	f4 01       	movw	r30, r8
    5bd6:	10 83       	st	Z, r17
    5bd8:	c6 01       	movw	r24, r12
    5bda:	01 97       	sbiw	r24, 0x01	; 1
    5bdc:	f1 f7       	brne	.-4      	; 0x5bda <SetDateTime+0xf6>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = CodBCD(Month);
    5bde:	c6 01       	movw	r24, r12
    5be0:	01 97       	sbiw	r24, 0x01	; 1
    5be2:	f1 f7       	brne	.-4      	; 0x5be0 <SetDateTime+0xfc>
    5be4:	86 2d       	mov	r24, r6
    5be6:	0e 94 6e 2a 	call	0x54dc	; 0x54dc <CodBCD>
    5bea:	f5 01       	movw	r30, r10
    5bec:	80 83       	st	Z, r24
	RunTWI();
    5bee:	f4 01       	movw	r30, r8
    5bf0:	10 83       	st	Z, r17
    5bf2:	c6 01       	movw	r24, r12
    5bf4:	01 97       	sbiw	r24, 0x01	; 1
    5bf6:	f1 f7       	brne	.-4      	; 0x5bf4 <SetDateTime+0x110>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = CodBCD(Year);
    5bf8:	c6 01       	movw	r24, r12
    5bfa:	01 97       	sbiw	r24, 0x01	; 1
    5bfc:	f1 f7       	brne	.-4      	; 0x5bfa <SetDateTime+0x116>
    5bfe:	85 2d       	mov	r24, r5
    5c00:	0e 94 6e 2a 	call	0x54dc	; 0x54dc <CodBCD>
    5c04:	f5 01       	movw	r30, r10
    5c06:	80 83       	st	Z, r24
	RunTWI();
    5c08:	f4 01       	movw	r30, r8
    5c0a:	10 83       	st	Z, r17
    5c0c:	c6 01       	movw	r24, r12
    5c0e:	01 97       	sbiw	r24, 0x01	; 1
    5c10:	f1 f7       	brne	.-4      	; 0x5c0e <SetDateTime+0x12a>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	StopTWI();
    5c12:	c6 01       	movw	r24, r12
    5c14:	01 97       	sbiw	r24, 0x01	; 1
    5c16:	f1 f7       	brne	.-4      	; 0x5c14 <SetDateTime+0x130>
    5c18:	84 e9       	ldi	r24, 0x94	; 148
    5c1a:	80 83       	st	Z, r24
	TWI_Phase = PCF_START;
    5c1c:	10 92 c3 07 	sts	0x07C3, r1
}
    5c20:	1f 91       	pop	r17
    5c22:	0f 91       	pop	r16
    5c24:	ff 90       	pop	r15
    5c26:	ef 90       	pop	r14
    5c28:	df 90       	pop	r13
    5c2a:	cf 90       	pop	r12
    5c2c:	bf 90       	pop	r11
    5c2e:	af 90       	pop	r10
    5c30:	9f 90       	pop	r9
    5c32:	8f 90       	pop	r8
    5c34:	7f 90       	pop	r7
    5c36:	6f 90       	pop	r6
    5c38:	5f 90       	pop	r5
    5c3a:	08 95       	ret

00005c3c <RTC_Ready>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t RTC_Ready(void){
    5c3c:	90 e0       	ldi	r25, 0x00	; 0
    5c3e:	80 91 c3 07 	lds	r24, 0x07C3
    5c42:	88 23       	and	r24, r24
    5c44:	09 f4       	brne	.+2      	; 0x5c48 <RTC_Ready+0xc>
    5c46:	91 e0       	ldi	r25, 0x01	; 1
	if(TWI_Phase == PCF_START) return 1;
	else return 0;
}
    5c48:	89 2f       	mov	r24, r25
    5c4a:	08 95       	ret

00005c4c <RTC_GetTrueTime>:
void RTC_GetTrueTime(void){
	TrueTime_Sec = Tm_Sec;
    5c4c:	80 91 f7 06 	lds	r24, 0x06F7
    5c50:	80 93 14 09 	sts	0x0914, r24
	TrueTime_Min = Tm_Min;
    5c54:	80 91 51 06 	lds	r24, 0x0651
    5c58:	80 93 16 09 	sts	0x0916, r24
	TrueTime_Hour = Tm_Hour;
    5c5c:	80 91 c1 05 	lds	r24, 0x05C1
    5c60:	80 93 d8 05 	sts	0x05D8, r24
	TrueTime_MDay = Tm_MDay;
    5c64:	40 91 5f 0b 	lds	r20, 0x0B5F
    5c68:	40 93 56 06 	sts	0x0656, r20
	TrueTime_Mon = Tm_Mon;
    5c6c:	60 91 cc 07 	lds	r22, 0x07CC
    5c70:	60 93 15 09 	sts	0x0915, r22
	TrueTime_Year = Tm_Year;
    5c74:	80 91 de 05 	lds	r24, 0x05DE
    5c78:	80 93 c1 07 	sts	0x07C1, r24
	TrueTime_WDay = SetWeekday(TrueTime_Year, TrueTime_Mon, TrueTime_MDay);
    5c7c:	0e 94 0a 2d 	call	0x5a14	; 0x5a14 <SetWeekday>
    5c80:	80 93 5e 0b 	sts	0x0B5E, r24
}
    5c84:	08 95       	ret

00005c86 <RTC_SetTrueTime>:
void RTC_SetTrueTime(uint8_t Year, uint8_t Month, uint8_t Day, uint8_t WDay, uint8_t Hour, uint8_t Min, uint8_t Sec){
    5c86:	8f 92       	push	r8
    5c88:	9f 92       	push	r9
    5c8a:	af 92       	push	r10
    5c8c:	bf 92       	push	r11
    5c8e:	cf 92       	push	r12
    5c90:	df 92       	push	r13
    5c92:	ef 92       	push	r14
    5c94:	ff 92       	push	r15
    5c96:	0f 93       	push	r16
    5c98:	1f 93       	push	r17
    5c9a:	88 2e       	mov	r8, r24
    5c9c:	a6 2e       	mov	r10, r22
    5c9e:	b4 2e       	mov	r11, r20
    5ca0:	92 2e       	mov	r9, r18
    5ca2:	d0 2e       	mov	r13, r16
    5ca4:	fe 2c       	mov	r15, r14
    5ca6:	1c 2d       	mov	r17, r12
	SetDateTime(Year, Month, Day, WDay, Hour, Min, Sec);
    5ca8:	0e 94 72 2d 	call	0x5ae4	; 0x5ae4 <SetDateTime>
	TrueTime_Sec = Sec;
    5cac:	10 93 14 09 	sts	0x0914, r17
	TrueTime_Min = Min;
    5cb0:	f0 92 16 09 	sts	0x0916, r15
	TrueTime_Hour = Hour;
    5cb4:	d0 92 d8 05 	sts	0x05D8, r13
	TrueTime_MDay = Day;
    5cb8:	b0 92 56 06 	sts	0x0656, r11
	TrueTime_Mon = Month;
    5cbc:	a0 92 15 09 	sts	0x0915, r10
	TrueTime_Year = Year;
    5cc0:	80 92 c1 07 	sts	0x07C1, r8
	TrueTime_WDay = WDay;
    5cc4:	90 92 5e 0b 	sts	0x0B5E, r9
}
    5cc8:	1f 91       	pop	r17
    5cca:	0f 91       	pop	r16
    5ccc:	ff 90       	pop	r15
    5cce:	ef 90       	pop	r14
    5cd0:	df 90       	pop	r13
    5cd2:	cf 90       	pop	r12
    5cd4:	bf 90       	pop	r11
    5cd6:	af 90       	pop	r10
    5cd8:	9f 90       	pop	r9
    5cda:	8f 90       	pop	r8
    5cdc:	08 95       	ret

00005cde <RTC_Check>:

//  3 

uint8_t RTC_Check(void){

	if( (Tm_Year == TrueTime_Year)  && (Tm_Mon == TrueTime_Mon) && (Tm_MDay == TrueTime_MDay) &&
    5cde:	50 91 de 05 	lds	r21, 0x05DE
    5ce2:	40 91 c1 07 	lds	r20, 0x07C1
    5ce6:	54 17       	cp	r21, r20
    5ce8:	59 f1       	breq	.+86     	; 0x5d40 <RTC_Check+0x62>
    5cea:	90 91 14 09 	lds	r25, 0x0914
			(Tm_Hour == TrueTime_Hour) && (Tm_Min == TrueTime_Min) && (Tm_Sec == TrueTime_Sec) ) return 1;

	if(TrueTime_Sec>55){
    5cee:	98 33       	cpi	r25, 0x38	; 56
    5cf0:	58 f0       	brcs	.+22     	; 0x5d08 <RTC_Check+0x2a>
		if(TrueTime_Min == 59){
    5cf2:	80 91 16 09 	lds	r24, 0x0916
    5cf6:	8b 33       	cpi	r24, 0x3B	; 59
    5cf8:	09 f4       	brne	.+2      	; 0x5cfc <RTC_Check+0x1e>
    5cfa:	5a c0       	rjmp	.+180    	; 0x5db0 <RTC_Check+0xd2>
			else{
				if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ) return 1;
			}
		}
		else{
			if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ||
    5cfc:	54 17       	cp	r21, r20
    5cfe:	09 f4       	brne	.+2      	; 0x5d02 <RTC_Check+0x24>
    5d00:	40 c0       	rjmp	.+128    	; 0x5d82 <RTC_Check+0xa4>
				(Tm_Hour != TrueTime_Hour) ) return 1;		
		}
	}
	else{
		if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ||
    5d02:	21 e0       	ldi	r18, 0x01	; 1
			(Tm_Hour != TrueTime_Hour) || (Tm_Min != TrueTime_Min) ) return 1;
	}
	
	return 0;
}
    5d04:	82 2f       	mov	r24, r18
    5d06:	08 95       	ret
			if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ||
				(Tm_Hour != TrueTime_Hour) ) return 1;		
		}
	}
	else{
		if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ||
    5d08:	54 17       	cp	r21, r20
    5d0a:	d9 f7       	brne	.-10     	; 0x5d02 <RTC_Check+0x24>
    5d0c:	90 91 cc 07 	lds	r25, 0x07CC
    5d10:	80 91 15 09 	lds	r24, 0x0915
    5d14:	98 17       	cp	r25, r24
    5d16:	a9 f7       	brne	.-22     	; 0x5d02 <RTC_Check+0x24>
    5d18:	90 91 5f 0b 	lds	r25, 0x0B5F
    5d1c:	80 91 56 06 	lds	r24, 0x0656
    5d20:	98 17       	cp	r25, r24
    5d22:	79 f7       	brne	.-34     	; 0x5d02 <RTC_Check+0x24>
    5d24:	90 91 c1 05 	lds	r25, 0x05C1
    5d28:	80 91 d8 05 	lds	r24, 0x05D8
    5d2c:	98 17       	cp	r25, r24
    5d2e:	49 f7       	brne	.-46     	; 0x5d02 <RTC_Check+0x24>
    5d30:	20 e0       	ldi	r18, 0x00	; 0
    5d32:	90 91 51 06 	lds	r25, 0x0651
    5d36:	80 91 16 09 	lds	r24, 0x0916
    5d3a:	98 17       	cp	r25, r24
    5d3c:	11 f7       	brne	.-60     	; 0x5d02 <RTC_Check+0x24>
    5d3e:	e2 cf       	rjmp	.-60     	; 0x5d04 <RTC_Check+0x26>

//  3 

uint8_t RTC_Check(void){

	if( (Tm_Year == TrueTime_Year)  && (Tm_Mon == TrueTime_Mon) && (Tm_MDay == TrueTime_MDay) &&
    5d40:	90 91 cc 07 	lds	r25, 0x07CC
    5d44:	80 91 15 09 	lds	r24, 0x0915
    5d48:	98 17       	cp	r25, r24
    5d4a:	79 f6       	brne	.-98     	; 0x5cea <RTC_Check+0xc>
    5d4c:	90 91 5f 0b 	lds	r25, 0x0B5F
    5d50:	80 91 56 06 	lds	r24, 0x0656
    5d54:	98 17       	cp	r25, r24
    5d56:	49 f6       	brne	.-110    	; 0x5cea <RTC_Check+0xc>
    5d58:	90 91 c1 05 	lds	r25, 0x05C1
    5d5c:	80 91 d8 05 	lds	r24, 0x05D8
    5d60:	98 17       	cp	r25, r24
    5d62:	19 f6       	brne	.-122    	; 0x5cea <RTC_Check+0xc>
    5d64:	90 91 51 06 	lds	r25, 0x0651
    5d68:	80 91 16 09 	lds	r24, 0x0916
    5d6c:	98 17       	cp	r25, r24
    5d6e:	09 f0       	breq	.+2      	; 0x5d72 <RTC_Check+0x94>
    5d70:	bc cf       	rjmp	.-136    	; 0x5cea <RTC_Check+0xc>
    5d72:	80 91 f7 06 	lds	r24, 0x06F7
    5d76:	90 91 14 09 	lds	r25, 0x0914
    5d7a:	89 17       	cp	r24, r25
    5d7c:	09 f0       	breq	.+2      	; 0x5d80 <RTC_Check+0xa2>
    5d7e:	b7 cf       	rjmp	.-146    	; 0x5cee <RTC_Check+0x10>
    5d80:	c0 cf       	rjmp	.-128    	; 0x5d02 <RTC_Check+0x24>
			else{
				if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ) return 1;
			}
		}
		else{
			if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ||
    5d82:	90 91 cc 07 	lds	r25, 0x07CC
    5d86:	80 91 15 09 	lds	r24, 0x0915
    5d8a:	98 17       	cp	r25, r24
    5d8c:	09 f0       	breq	.+2      	; 0x5d90 <RTC_Check+0xb2>
    5d8e:	b9 cf       	rjmp	.-142    	; 0x5d02 <RTC_Check+0x24>
    5d90:	90 91 5f 0b 	lds	r25, 0x0B5F
    5d94:	80 91 56 06 	lds	r24, 0x0656
    5d98:	98 17       	cp	r25, r24
    5d9a:	09 f0       	breq	.+2      	; 0x5d9e <RTC_Check+0xc0>
    5d9c:	b2 cf       	rjmp	.-156    	; 0x5d02 <RTC_Check+0x24>
    5d9e:	20 e0       	ldi	r18, 0x00	; 0
    5da0:	90 91 c1 05 	lds	r25, 0x05C1
    5da4:	80 91 d8 05 	lds	r24, 0x05D8
    5da8:	98 17       	cp	r25, r24
    5daa:	09 f0       	breq	.+2      	; 0x5dae <RTC_Check+0xd0>
    5dac:	aa cf       	rjmp	.-172    	; 0x5d02 <RTC_Check+0x24>
    5dae:	aa cf       	rjmp	.-172    	; 0x5d04 <RTC_Check+0x26>
	if( (Tm_Year == TrueTime_Year)  && (Tm_Mon == TrueTime_Mon) && (Tm_MDay == TrueTime_MDay) &&
			(Tm_Hour == TrueTime_Hour) && (Tm_Min == TrueTime_Min) && (Tm_Sec == TrueTime_Sec) ) return 1;

	if(TrueTime_Sec>55){
		if(TrueTime_Min == 59){
			if(TrueTime_Hour == 23){
    5db0:	80 91 d8 05 	lds	r24, 0x05D8
    5db4:	87 31       	cpi	r24, 0x17	; 23
    5db6:	99 f0       	breq	.+38     	; 0x5dde <RTC_Check+0x100>
				else{
					if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) ) return 1;
				}
			}
			else{
				if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ) return 1;
    5db8:	54 17       	cp	r21, r20
    5dba:	09 f0       	breq	.+2      	; 0x5dbe <RTC_Check+0xe0>
    5dbc:	a2 cf       	rjmp	.-188    	; 0x5d02 <RTC_Check+0x24>
    5dbe:	90 91 cc 07 	lds	r25, 0x07CC
    5dc2:	80 91 15 09 	lds	r24, 0x0915
    5dc6:	98 17       	cp	r25, r24
    5dc8:	09 f0       	breq	.+2      	; 0x5dcc <RTC_Check+0xee>
    5dca:	9b cf       	rjmp	.-202    	; 0x5d02 <RTC_Check+0x24>
    5dcc:	20 e0       	ldi	r18, 0x00	; 0
    5dce:	90 91 5f 0b 	lds	r25, 0x0B5F
    5dd2:	80 91 56 06 	lds	r24, 0x0656
    5dd6:	98 17       	cp	r25, r24
    5dd8:	09 f0       	breq	.+2      	; 0x5ddc <RTC_Check+0xfe>
    5dda:	93 cf       	rjmp	.-218    	; 0x5d02 <RTC_Check+0x24>
    5ddc:	93 cf       	rjmp	.-218    	; 0x5d04 <RTC_Check+0x26>
			(Tm_Hour == TrueTime_Hour) && (Tm_Min == TrueTime_Min) && (Tm_Sec == TrueTime_Sec) ) return 1;

	if(TrueTime_Sec>55){
		if(TrueTime_Min == 59){
			if(TrueTime_Hour == 23){
				if(TrueTime_MDay >= 28){
    5dde:	80 91 56 06 	lds	r24, 0x0656
    5de2:	8c 31       	cpi	r24, 0x1C	; 28
    5de4:	48 f0       	brcs	.+18     	; 0x5df8 <RTC_Check+0x11a>
					if(TrueTime_Mon == 12){
    5de6:	80 91 15 09 	lds	r24, 0x0915
    5dea:	8c 30       	cpi	r24, 0x0C	; 12
    5dec:	89 f0       	breq	.+34     	; 0x5e10 <RTC_Check+0x132>
						if( ((TrueTime_Year+1) == Tm_Year) || (TrueTime_Year==Tm_Year) || ((TrueTime_Year==99) && (Tm_Year==0)) ) return 0;
    5dee:	20 e0       	ldi	r18, 0x00	; 0
    5df0:	54 17       	cp	r21, r20
    5df2:	09 f0       	breq	.+2      	; 0x5df6 <RTC_Check+0x118>
    5df4:	86 cf       	rjmp	.-244    	; 0x5d02 <RTC_Check+0x24>
    5df6:	86 cf       	rjmp	.-244    	; 0x5d04 <RTC_Check+0x26>
					else{
						if(Tm_Year!= TrueTime_Year) return 1;
					}
				}
				else{
					if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) ) return 1;
    5df8:	54 17       	cp	r21, r20
    5dfa:	09 f0       	breq	.+2      	; 0x5dfe <RTC_Check+0x120>
    5dfc:	82 cf       	rjmp	.-252    	; 0x5d02 <RTC_Check+0x24>
    5dfe:	20 e0       	ldi	r18, 0x00	; 0
    5e00:	90 91 cc 07 	lds	r25, 0x07CC
    5e04:	80 91 15 09 	lds	r24, 0x0915
    5e08:	98 17       	cp	r25, r24
    5e0a:	09 f0       	breq	.+2      	; 0x5e0e <RTC_Check+0x130>
    5e0c:	7a cf       	rjmp	.-268    	; 0x5d02 <RTC_Check+0x24>
    5e0e:	7a cf       	rjmp	.-268    	; 0x5d04 <RTC_Check+0x26>
	if(TrueTime_Sec>55){
		if(TrueTime_Min == 59){
			if(TrueTime_Hour == 23){
				if(TrueTime_MDay >= 28){
					if(TrueTime_Mon == 12){
						if( ((TrueTime_Year+1) == Tm_Year) || (TrueTime_Year==Tm_Year) || ((TrueTime_Year==99) && (Tm_Year==0)) ) return 0;
    5e10:	84 2f       	mov	r24, r20
    5e12:	90 e0       	ldi	r25, 0x00	; 0
    5e14:	01 96       	adiw	r24, 0x01	; 1
    5e16:	25 2f       	mov	r18, r21
    5e18:	30 e0       	ldi	r19, 0x00	; 0
    5e1a:	82 17       	cp	r24, r18
    5e1c:	93 07       	cpc	r25, r19
    5e1e:	61 f0       	breq	.+24     	; 0x5e38 <RTC_Check+0x15a>
    5e20:	54 17       	cp	r21, r20
    5e22:	51 f0       	breq	.+20     	; 0x5e38 <RTC_Check+0x15a>
    5e24:	43 36       	cpi	r20, 0x63	; 99
    5e26:	09 f0       	breq	.+2      	; 0x5e2a <RTC_Check+0x14c>
    5e28:	6c cf       	rjmp	.-296    	; 0x5d02 <RTC_Check+0x24>
    5e2a:	20 e0       	ldi	r18, 0x00	; 0
    5e2c:	55 23       	and	r21, r21
    5e2e:	09 f4       	brne	.+2      	; 0x5e32 <RTC_Check+0x154>
    5e30:	21 e0       	ldi	r18, 0x01	; 1
    5e32:	81 e0       	ldi	r24, 0x01	; 1
    5e34:	28 27       	eor	r18, r24
    5e36:	66 cf       	rjmp	.-308    	; 0x5d04 <RTC_Check+0x26>
			if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ||
				(Tm_Hour != TrueTime_Hour) ) return 1;		
		}
	}
	else{
		if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ||
    5e38:	20 e0       	ldi	r18, 0x00	; 0
    5e3a:	64 cf       	rjmp	.-312    	; 0x5d04 <RTC_Check+0x26>

00005e3c <GSM_PWRCNTRL_Config>:
#endif

//  gsm_sim900r.h   PWRCNTRL
#ifdef vmd2_3
	void GSM_PWRCNTRL_Config(void){
		cli();
    5e3c:	f8 94       	cli
		DDRL|=(1<<PL5);
    5e3e:	ea e0       	ldi	r30, 0x0A	; 10
    5e40:	f1 e0       	ldi	r31, 0x01	; 1
    5e42:	80 81       	ld	r24, Z
    5e44:	80 62       	ori	r24, 0x20	; 32
    5e46:	80 83       	st	Z, r24
		sei();
    5e48:	78 94       	sei
	}
    5e4a:	08 95       	ret

00005e4c <GSM_PWRCNTRL_OFF>:
	void GSM_PWRCNTRL_OFF(void){
		cli();
    5e4c:	f8 94       	cli
		PORTL|=(1<<PL5);
    5e4e:	eb e0       	ldi	r30, 0x0B	; 11
    5e50:	f1 e0       	ldi	r31, 0x01	; 1
    5e52:	80 81       	ld	r24, Z
    5e54:	80 62       	ori	r24, 0x20	; 32
    5e56:	80 83       	st	Z, r24
		sei();
    5e58:	78 94       	sei
	}
    5e5a:	08 95       	ret

00005e5c <GSM_PWRCNTRL_ON>:
	void GSM_PWRCNTRL_ON(void){
		cli();
    5e5c:	f8 94       	cli
		PORTL &= ~(1<<PL5);
    5e5e:	eb e0       	ldi	r30, 0x0B	; 11
    5e60:	f1 e0       	ldi	r31, 0x01	; 1
    5e62:	80 81       	ld	r24, Z
    5e64:	8f 7d       	andi	r24, 0xDF	; 223
    5e66:	80 83       	st	Z, r24
		sei();
    5e68:	78 94       	sei
	}
    5e6a:	08 95       	ret

00005e6c <GSM_CTS_RTS_Config>:

	void GSM_CTS_RTS_Config(void){
		cli();
    5e6c:	f8 94       	cli
		//TS
		DDRB &=~(1<<PB6);
    5e6e:	26 98       	cbi	0x04, 6	; 4
		PORTB |=(1<<PB6);	//pull'up
    5e70:	2e 9a       	sbi	0x05, 6	; 5
		//RTS
		DDRG |= (1<<PG5);
    5e72:	9d 9a       	sbi	0x13, 5	; 19
		PORTG &= ~(1<<PG5);
    5e74:	a5 98       	cbi	0x14, 5	; 20
		sei();
    5e76:	78 94       	sei
	}
    5e78:	08 95       	ret

00005e7a <GSM_CTS_State>:
	uint8_t GSM_CTS_State(void){
		return PINB & (1<<PB6);
    5e7a:	83 b1       	in	r24, 0x03	; 3
	}
    5e7c:	80 74       	andi	r24, 0x40	; 64
    5e7e:	08 95       	ret

00005e80 <GSM_RTS_OFF>:
	void GSM_RTS_OFF(void){
		cli();
    5e80:	f8 94       	cli
		PORTG &= ~(1<<PG5);
    5e82:	a5 98       	cbi	0x14, 5	; 20
		sei();
    5e84:	78 94       	sei
	}
    5e86:	08 95       	ret

00005e88 <GSM_RTS_ON>:
	void GSM_RTS_ON(void){
		cli();
    5e88:	f8 94       	cli
		PORTG |= (1<<PG5);
    5e8a:	a5 9a       	sbi	0x14, 5	; 20
		sei();
    5e8c:	78 94       	sei
	}
    5e8e:	08 95       	ret

00005e90 <LED_Init>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    5e90:	8f b7       	in	r24, 0x3f	; 63
    5e92:	80 78       	andi	r24, 0x80	; 128
    5e94:	80 93 ee 02 	sts	0x02EE, r24
	cli();
    5e98:	f8 94       	cli
//~~~~~~~~~~~~
void
LED_Init(void)
{
	IntOff();
	DDR_LED |=PinLED;
    5e9a:	83 9a       	sbi	0x10, 3	; 16
	LED_Rst();
    5e9c:	8b 98       	cbi	0x11, 3	; 17

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    5e9e:	88 23       	and	r24, r24
    5ea0:	09 f0       	breq	.+2      	; 0x5ea4 <LED_Init+0x14>
		sei();
    5ea2:	78 94       	sei
    5ea4:	08 95       	ret

00005ea6 <LED_On>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    5ea6:	8f b7       	in	r24, 0x3f	; 63
    5ea8:	80 78       	andi	r24, 0x80	; 128
    5eaa:	80 93 ee 02 	sts	0x02EE, r24
	cli();
    5eae:	f8 94       	cli
// ~~~~~~~~~
void
LED_On(void)
{
	IntOff();
	LED_Set();
    5eb0:	8b 9a       	sbi	0x11, 3	; 17

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    5eb2:	88 23       	and	r24, r24
    5eb4:	09 f0       	breq	.+2      	; 0x5eb8 <LED_On+0x12>
		sei();
    5eb6:	78 94       	sei
    5eb8:	08 95       	ret

00005eba <LED_Off>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    5eba:	8f b7       	in	r24, 0x3f	; 63
    5ebc:	80 78       	andi	r24, 0x80	; 128
    5ebe:	80 93 ee 02 	sts	0x02EE, r24
	cli();
    5ec2:	f8 94       	cli
// ~~~~~~~~~~
void
LED_Off(void)
{
	IntOff();
	LED_Rst();
    5ec4:	8b 98       	cbi	0x11, 3	; 17

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    5ec6:	88 23       	and	r24, r24
    5ec8:	09 f0       	breq	.+2      	; 0x5ecc <LED_Off+0x12>
		sei();
    5eca:	78 94       	sei
    5ecc:	08 95       	ret

00005ece <LED_Toggle>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    5ece:	8f b7       	in	r24, 0x3f	; 63
    5ed0:	80 78       	andi	r24, 0x80	; 128
    5ed2:	80 93 ee 02 	sts	0x02EE, r24
	cli();
    5ed6:	f8 94       	cli
// ~~~~~~~~~~~~~
uint8_t
LED_Toggle(void)
{
	IntOff();
	LED_Inv();
    5ed8:	91 b3       	in	r25, 0x11	; 17
    5eda:	28 e0       	ldi	r18, 0x08	; 8
    5edc:	92 27       	eor	r25, r18
    5ede:	91 bb       	out	0x11, r25	; 17

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    5ee0:	88 23       	and	r24, r24
    5ee2:	09 f0       	breq	.+2      	; 0x5ee6 <LED_Toggle+0x18>
		sei();
    5ee4:	78 94       	sei
	IntOn();
	return PortLED &PinLED;
    5ee6:	81 b3       	in	r24, 0x11	; 17
}
    5ee8:	88 70       	andi	r24, 0x08	; 8
    5eea:	08 95       	ret

00005eec <Send>:
#ifdef Port_LCD_DB0	//8-bit width data bus
	// ~~~~~~~~~~~~~~
	static void
	Send(uint8_t Val)
	{
		if (Val &(1<<0)) Port_LCD_DB0 |=DB0; else Port_LCD_DB0 &=~DB0;
    5eec:	98 2f       	mov	r25, r24
    5eee:	80 ff       	sbrs	r24, 0
    5ef0:	23 c0       	rjmp	.+70     	; 0x5f38 <Send+0x4c>
    5ef2:	41 9a       	sbi	0x08, 1	; 8
		if (Val &(1<<1)) Port_LCD_DB1 |=DB1; else Port_LCD_DB1 &=~DB1;
    5ef4:	91 ff       	sbrs	r25, 1
    5ef6:	23 c0       	rjmp	.+70     	; 0x5f3e <Send+0x52>
    5ef8:	40 9a       	sbi	0x08, 0	; 8
		if (Val &(1<<2)) Port_LCD_DB2 |=DB2; else Port_LCD_DB2 &=~DB2;
    5efa:	92 ff       	sbrs	r25, 2
    5efc:	23 c0       	rjmp	.+70     	; 0x5f44 <Send+0x58>
    5efe:	a1 9a       	sbi	0x14, 1	; 20
		if (Val &(1<<3)) Port_LCD_DB3 |=DB3; else Port_LCD_DB3 &=~DB3;
    5f00:	93 ff       	sbrs	r25, 3
    5f02:	23 c0       	rjmp	.+70     	; 0x5f4a <Send+0x5e>
    5f04:	a0 9a       	sbi	0x14, 0	; 20
		if (Val &(1<<4)) Port_LCD_DB4 |=DB4; else Port_LCD_DB4 &=~DB4;
    5f06:	94 ff       	sbrs	r25, 4
    5f08:	23 c0       	rjmp	.+70     	; 0x5f50 <Send+0x64>
    5f0a:	5f 9a       	sbi	0x0b, 7	; 11
		if (Val &(1<<5)) Port_LCD_DB5 |=DB5; else Port_LCD_DB5 &=~DB5;
    5f0c:	95 ff       	sbrs	r25, 5
    5f0e:	23 c0       	rjmp	.+70     	; 0x5f56 <Send+0x6a>
    5f10:	5e 9a       	sbi	0x0b, 6	; 11
		if (Val &(1<<6)) Port_LCD_DB6 |=DB6; else Port_LCD_DB6 &=~DB6;
    5f12:	96 ff       	sbrs	r25, 6
    5f14:	23 c0       	rjmp	.+70     	; 0x5f5c <Send+0x70>
    5f16:	5d 9a       	sbi	0x0b, 5	; 11
		if (Val &(1<<7)) Port_LCD_DB7 |=DB7; else Port_LCD_DB7 &=~DB7;
    5f18:	87 fd       	sbrc	r24, 7
    5f1a:	23 c0       	rjmp	.+70     	; 0x5f62 <Send+0x76>
    5f1c:	80 91 0b 01 	lds	r24, 0x010B
    5f20:	8f 77       	andi	r24, 0x7F	; 127
    5f22:	80 93 0b 01 	sts	0x010B, r24

		Port_LCD_E |=LCD_E;
    5f26:	42 9a       	sbi	0x08, 2	; 8
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    5f28:	85 e0       	ldi	r24, 0x05	; 5
    5f2a:	98 2f       	mov	r25, r24
    5f2c:	9a 95       	dec	r25
    5f2e:	f1 f7       	brne	.-4      	; 0x5f2c <Send+0x40>
		_delay_us(1);		// 450 ns needs
		Port_LCD_E &=~LCD_E;
    5f30:	42 98       	cbi	0x08, 2	; 8
    5f32:	8a 95       	dec	r24
    5f34:	f1 f7       	brne	.-4      	; 0x5f32 <Send+0x46>
		_delay_us(1);		// 10 ns needs
	}
    5f36:	08 95       	ret
#ifdef Port_LCD_DB0	//8-bit width data bus
	// ~~~~~~~~~~~~~~
	static void
	Send(uint8_t Val)
	{
		if (Val &(1<<0)) Port_LCD_DB0 |=DB0; else Port_LCD_DB0 &=~DB0;
    5f38:	41 98       	cbi	0x08, 1	; 8
		if (Val &(1<<1)) Port_LCD_DB1 |=DB1; else Port_LCD_DB1 &=~DB1;
    5f3a:	91 fd       	sbrc	r25, 1
    5f3c:	dd cf       	rjmp	.-70     	; 0x5ef8 <Send+0xc>
    5f3e:	40 98       	cbi	0x08, 0	; 8
		if (Val &(1<<2)) Port_LCD_DB2 |=DB2; else Port_LCD_DB2 &=~DB2;
    5f40:	92 fd       	sbrc	r25, 2
    5f42:	dd cf       	rjmp	.-70     	; 0x5efe <Send+0x12>
    5f44:	a1 98       	cbi	0x14, 1	; 20
		if (Val &(1<<3)) Port_LCD_DB3 |=DB3; else Port_LCD_DB3 &=~DB3;
    5f46:	93 fd       	sbrc	r25, 3
    5f48:	dd cf       	rjmp	.-70     	; 0x5f04 <Send+0x18>
    5f4a:	a0 98       	cbi	0x14, 0	; 20
		if (Val &(1<<4)) Port_LCD_DB4 |=DB4; else Port_LCD_DB4 &=~DB4;
    5f4c:	94 fd       	sbrc	r25, 4
    5f4e:	dd cf       	rjmp	.-70     	; 0x5f0a <Send+0x1e>
    5f50:	5f 98       	cbi	0x0b, 7	; 11
		if (Val &(1<<5)) Port_LCD_DB5 |=DB5; else Port_LCD_DB5 &=~DB5;
    5f52:	95 fd       	sbrc	r25, 5
    5f54:	dd cf       	rjmp	.-70     	; 0x5f10 <Send+0x24>
    5f56:	5e 98       	cbi	0x0b, 6	; 11
		if (Val &(1<<6)) Port_LCD_DB6 |=DB6; else Port_LCD_DB6 &=~DB6;
    5f58:	96 fd       	sbrc	r25, 6
    5f5a:	dd cf       	rjmp	.-70     	; 0x5f16 <Send+0x2a>
    5f5c:	5d 98       	cbi	0x0b, 5	; 11
		if (Val &(1<<7)) Port_LCD_DB7 |=DB7; else Port_LCD_DB7 &=~DB7;
    5f5e:	87 ff       	sbrs	r24, 7
    5f60:	dd cf       	rjmp	.-70     	; 0x5f1c <Send+0x30>
    5f62:	80 91 0b 01 	lds	r24, 0x010B
    5f66:	80 68       	ori	r24, 0x80	; 128
    5f68:	80 93 0b 01 	sts	0x010B, r24
    5f6c:	dc cf       	rjmp	.-72     	; 0x5f26 <Send+0x3a>

00005f6e <Send_I>:
#endif
// ~~~~~~~~~~~~~~~~
static void
Send_I(uint8_t Val)
{
	Send(Val);
    5f6e:	0e 94 76 2f 	call	0x5eec	; 0x5eec <Send>
	Delay_us(LCD_Delay);
    5f72:	82 e3       	ldi	r24, 0x32	; 50
    5f74:	90 e0       	ldi	r25, 0x00	; 0
    5f76:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <Delay_us>
}
    5f7a:	08 95       	ret

00005f7c <LCD_FuncSet0>:

// ~~~~~~~~~~~
static void
LCD_FuncSet0(void)
{
	Port_LCD_DB4  |=DB4;
    5f7c:	5f 9a       	sbi	0x0b, 7	; 11
	Port_LCD_DB5  |=DB5;
    5f7e:	5e 9a       	sbi	0x0b, 6	; 11
	Port_LCD_DB6 &=~DB6;
    5f80:	5d 98       	cbi	0x0b, 5	; 11
	Port_LCD_DB7 &=~DB7;
    5f82:	eb e0       	ldi	r30, 0x0B	; 11
    5f84:	f1 e0       	ldi	r31, 0x01	; 1
    5f86:	80 81       	ld	r24, Z
    5f88:	8f 77       	andi	r24, 0x7F	; 127
    5f8a:	80 83       	st	Z, r24
}
    5f8c:	08 95       	ret

00005f8e <LCD_Rdy>:
}

// ~~~~~~~~~~
uint8_t
LCD_Rdy(void)
{
    5f8e:	1f 93       	push	r17
	uint8_t Rdy = Timer8Stopp(TD_LCD);
    5f90:	10 91 d7 04 	lds	r17, 0x04D7
    5f94:	81 2f       	mov	r24, r17
    5f96:	0e 94 73 25 	call	0x4ae6	; 0x4ae6 <Timer8Stopp>
	Rdy = Rdy && !(TIMSK_LCD &(1<<OCIE1B));
    5f9a:	88 23       	and	r24, r24
    5f9c:	29 f0       	breq	.+10     	; 0x5fa8 <LCD_Rdy+0x1a>
    5f9e:	80 91 6f 00 	lds	r24, 0x006F
    5fa2:	82 ff       	sbrs	r24, 2
    5fa4:	03 c0       	rjmp	.+6      	; 0x5fac <LCD_Rdy+0x1e>
    5fa6:	80 e0       	ldi	r24, 0x00	; 0
	if (Rdy)
		StartTimer8(TD_LCD, 6);
	return Rdy;
}
    5fa8:	1f 91       	pop	r17
    5faa:	08 95       	ret
LCD_Rdy(void)
{
	uint8_t Rdy = Timer8Stopp(TD_LCD);
	Rdy = Rdy && !(TIMSK_LCD &(1<<OCIE1B));
	if (Rdy)
		StartTimer8(TD_LCD, 6);
    5fac:	81 2f       	mov	r24, r17
    5fae:	66 e0       	ldi	r22, 0x06	; 6
    5fb0:	0e 94 1f 24 	call	0x483e	; 0x483e <StartTimer8>
    5fb4:	81 e0       	ldi	r24, 0x01	; 1
	return Rdy;
}
    5fb6:	1f 91       	pop	r17
    5fb8:	08 95       	ret

00005fba <LCD_Out>:
LCD_Out(void)
{
	static uint8_t N;
	uint16_t LCD_delay = 100;	//50us

	if( (N>=20) && !LCD_Rst_Flg ){
    5fba:	90 91 eb 02 	lds	r25, 0x02EB
    5fbe:	94 31       	cpi	r25, 0x14	; 20
    5fc0:	20 f0       	brcs	.+8      	; 0x5fca <LCD_Out+0x10>
    5fc2:	80 91 d6 04 	lds	r24, 0x04D6
    5fc6:	88 23       	and	r24, r24
    5fc8:	19 f1       	breq	.+70     	; 0x6010 <LCD_Out+0x56>
		LCD_Rst0();
		LCD_Rst_Flg = 1;
		LCD_delay = 10000;	//5ms
	}
	else {
		N++;
    5fca:	9f 5f       	subi	r25, 0xFF	; 255
    5fcc:	90 93 eb 02 	sts	0x02EB, r25
    5fd0:	24 e6       	ldi	r18, 0x64	; 100
    5fd2:	30 e0       	ldi	r19, 0x00	; 0
	}

	cli();
    5fd4:	f8 94       	cli
	LCD_delay = TCNT1 + LCD_delay;
    5fd6:	80 91 84 00 	lds	r24, 0x0084
    5fda:	90 91 85 00 	lds	r25, 0x0085
    5fde:	82 0f       	add	r24, r18
    5fe0:	93 1f       	adc	r25, r19
	if(LCD_delay >= 20000) OCR1B = LCD_delay - 20000;
    5fe2:	2e e4       	ldi	r18, 0x4E	; 78
    5fe4:	80 32       	cpi	r24, 0x20	; 32
    5fe6:	92 07       	cpc	r25, r18
    5fe8:	60 f4       	brcc	.+24     	; 0x6002 <LCD_Out+0x48>
	else OCR1B = LCD_delay;
    5fea:	90 93 8b 00 	sts	0x008B, r25
    5fee:	80 93 8a 00 	sts	0x008A, r24
	TIFR_LCD |= (1<<OCF1B);
    5ff2:	b2 9a       	sbi	0x16, 2	; 22
	TIMSK_LCD |= (1<<OCIE1B);
    5ff4:	80 91 6f 00 	lds	r24, 0x006F
    5ff8:	84 60       	ori	r24, 0x04	; 4
    5ffa:	80 93 6f 00 	sts	0x006F, r24
	sei();
    5ffe:	78 94       	sei
}
    6000:	08 95       	ret
		N++;
	}

	cli();
	LCD_delay = TCNT1 + LCD_delay;
	if(LCD_delay >= 20000) OCR1B = LCD_delay - 20000;
    6002:	80 52       	subi	r24, 0x20	; 32
    6004:	9e 44       	sbci	r25, 0x4E	; 78
    6006:	90 93 8b 00 	sts	0x008B, r25
    600a:	80 93 8a 00 	sts	0x008A, r24
    600e:	f1 cf       	rjmp	.-30     	; 0x5ff2 <LCD_Out+0x38>
{
	static uint8_t N;
	uint16_t LCD_delay = 100;	//50us

	if( (N>=20) && !LCD_Rst_Flg ){
		N = 0;
    6010:	10 92 eb 02 	sts	0x02EB, r1
#endif
// ~~~~~~~~~~~
static void
LCD_Rst0(void)
{
	cli();
    6014:	f8 94       	cli
	Port_LCD_RS &=~LCD_RS;
    6016:	44 98       	cbi	0x08, 4	; 8
	LCD_FuncSet0();
    6018:	0e 94 be 2f 	call	0x5f7c	; 0x5f7c <LCD_FuncSet0>
	sei();
    601c:	78 94       	sei
	uint16_t LCD_delay = 100;	//50us

	if( (N>=20) && !LCD_Rst_Flg ){
		N = 0;
		LCD_Rst0();
		LCD_Rst_Flg = 1;
    601e:	81 e0       	ldi	r24, 0x01	; 1
    6020:	80 93 d6 04 	sts	0x04D6, r24
    6024:	20 e1       	ldi	r18, 0x10	; 16
    6026:	37 e2       	ldi	r19, 0x27	; 39
    6028:	d5 cf       	rjmp	.-86     	; 0x5fd4 <LCD_Out+0x1a>

0000602a <__vector_18>:
	sei();
}

// ~~~~~~~~~~~~~~~~~~~~~~
// 40 us needs
ISR(TIMER1_COMPB_vect){
    602a:	1f 92       	push	r1
    602c:	0f 92       	push	r0
    602e:	0f b6       	in	r0, 0x3f	; 63
    6030:	0f 92       	push	r0
    6032:	0b b6       	in	r0, 0x3b	; 59
    6034:	0f 92       	push	r0
    6036:	11 24       	eor	r1, r1
    6038:	ff 92       	push	r15
    603a:	0f 93       	push	r16
    603c:	1f 93       	push	r17
    603e:	2f 93       	push	r18
    6040:	3f 93       	push	r19
    6042:	4f 93       	push	r20
    6044:	5f 93       	push	r21
    6046:	6f 93       	push	r22
    6048:	7f 93       	push	r23
    604a:	8f 93       	push	r24
    604c:	9f 93       	push	r25
    604e:	af 93       	push	r26
    6050:	bf 93       	push	r27
    6052:	ef 93       	push	r30
    6054:	ff 93       	push	r31

	uint16_t LCD_delay = 100;	//50us

	if (LCD_Rst_Flg) {
    6056:	80 91 d6 04 	lds	r24, 0x04D6
    605a:	88 23       	and	r24, r24
    605c:	f1 f0       	breq	.+60     	; 0x609a <__vector_18+0x70>
		switch(LCD_Rst_Flg){
    605e:	10 91 d6 04 	lds	r17, 0x04D6
    6062:	15 30       	cpi	r17, 0x05	; 5
    6064:	09 f4       	brne	.+2      	; 0x6068 <__vector_18+0x3e>
    6066:	b5 c0       	rjmp	.+362    	; 0x61d2 <__vector_18+0x1a8>
    6068:	16 30       	cpi	r17, 0x06	; 6
    606a:	08 f4       	brcc	.+2      	; 0x606e <__vector_18+0x44>
    606c:	a1 c0       	rjmp	.+322    	; 0x61b0 <__vector_18+0x186>
    606e:	17 30       	cpi	r17, 0x07	; 7
    6070:	09 f4       	brne	.+2      	; 0x6074 <__vector_18+0x4a>
    6072:	15 c1       	rjmp	.+554    	; 0x629e <__vector_18+0x274>
    6074:	17 30       	cpi	r17, 0x07	; 7
    6076:	08 f0       	brcs	.+2      	; 0x607a <__vector_18+0x50>
    6078:	dc c0       	rjmp	.+440    	; 0x6232 <__vector_18+0x208>
				break;
			case 5:
				Send(0b00001100);	//; Display on, cursor off, blink off	
				break;
			case 6:
				Send(0b00000110);	//; cursor shift right, no display shift
    607a:	86 e0       	ldi	r24, 0x06	; 6
    607c:	0e 94 76 2f 	call	0x5eec	; 0x5eec <Send>
				#endif
				Port_LCD_RS |=LCD_RS;
			default:
				LCD_Rst_Flg = 255;
		}
		if(LCD_Rst_Flg==1) LCD_delay = 400;	//200us
    6080:	80 91 d6 04 	lds	r24, 0x04D6
    6084:	81 30       	cpi	r24, 0x01	; 1
    6086:	09 f4       	brne	.+2      	; 0x608a <__vector_18+0x60>
    6088:	a1 c0       	rjmp	.+322    	; 0x61cc <__vector_18+0x1a2>
    608a:	24 e6       	ldi	r18, 0x64	; 100
    608c:	30 e0       	ldi	r19, 0x00	; 0

		LCD_Rst_Flg++;
    608e:	80 91 d6 04 	lds	r24, 0x04D6
    6092:	8f 5f       	subi	r24, 0xFF	; 255
    6094:	80 93 d6 04 	sts	0x04D6, r24
    6098:	5f c0       	rjmp	.+190    	; 0x6158 <__vector_18+0x12e>
	else {
		static uint8_t X, Y;
		static prog_uint8_t LineAddr[] = {128, 192, 148, 212};
		unsigned char cursor_symb;
		
		if (X<LCDXSz) {
    609a:	10 91 e8 02 	lds	r17, 0x02E8
    609e:	14 31       	cpi	r17, 0x14	; 20
    60a0:	08 f0       	brcs	.+2      	; 0x60a4 <__vector_18+0x7a>
    60a2:	45 c0       	rjmp	.+138    	; 0x612e <__vector_18+0x104>
			if((X>=CurrX)&&(X<(CurrX+StrSize))&&(Y==CurrLCD)){
    60a4:	80 91 fa 06 	lds	r24, 0x06FA
    60a8:	18 17       	cp	r17, r24
    60aa:	08 f4       	brcc	.+2      	; 0x60ae <__vector_18+0x84>
    60ac:	96 c0       	rjmp	.+300    	; 0x61da <__vector_18+0x1b0>
    60ae:	61 2f       	mov	r22, r17
    60b0:	70 e0       	ldi	r23, 0x00	; 0
    60b2:	20 91 ac 06 	lds	r18, 0x06AC
    60b6:	90 e0       	ldi	r25, 0x00	; 0
    60b8:	82 0f       	add	r24, r18
    60ba:	91 1d       	adc	r25, r1
    60bc:	68 17       	cp	r22, r24
    60be:	79 07       	cpc	r23, r25
    60c0:	0c f4       	brge	.+2      	; 0x60c4 <__vector_18+0x9a>
    60c2:	e4 c0       	rjmp	.+456    	; 0x628c <__vector_18+0x262>
    60c4:	e0 91 e7 02 	lds	r30, 0x02E7
    60c8:	20 e0       	ldi	r18, 0x00	; 0
			else
			{
				cursor_symb=0;
			}

			Send(
    60ca:	4e 2f       	mov	r20, r30
    60cc:	50 e0       	ldi	r21, 0x00	; 0
    60ce:	90 91 18 09 	lds	r25, 0x0918
    60d2:	89 2f       	mov	r24, r25
    60d4:	88 50       	subi	r24, 0x08	; 8
    60d6:	83 30       	cpi	r24, 0x03	; 3
    60d8:	18 f0       	brcs	.+6      	; 0x60e0 <__vector_18+0xb6>
    60da:	9e 30       	cpi	r25, 0x0E	; 14
    60dc:	08 f4       	brcc	.+2      	; 0x60e0 <__vector_18+0xb6>
    60de:	91 c0       	rjmp	.+290    	; 0x6202 <__vector_18+0x1d8>
    60e0:	22 23       	and	r18, r18
    60e2:	09 f4       	brne	.+2      	; 0x60e6 <__vector_18+0xbc>
    60e4:	8e c0       	rjmp	.+284    	; 0x6202 <__vector_18+0x1d8>
    60e6:	80 91 d6 02 	lds	r24, 0x02D6
    60ea:	8f 3f       	cpi	r24, 0xFF	; 255
    60ec:	09 f4       	brne	.+2      	; 0x60f0 <__vector_18+0xc6>
    60ee:	89 c0       	rjmp	.+274    	; 0x6202 <__vector_18+0x1d8>
    60f0:	e2 2f       	mov	r30, r18
    60f2:	f0 e0       	ldi	r31, 0x00	; 0
    60f4:	ed 50       	subi	r30, 0x0D	; 13
    60f6:	ff 4b       	sbci	r31, 0xBF	; 191
    60f8:	24 91       	lpm	r18, Z+
    60fa:	fa 01       	movw	r30, r20
    60fc:	ee 0f       	add	r30, r30
    60fe:	ff 1f       	adc	r31, r31
    6100:	ee 0f       	add	r30, r30
    6102:	ff 1f       	adc	r31, r31
    6104:	cf 01       	movw	r24, r30
    6106:	88 0f       	add	r24, r24
    6108:	99 1f       	adc	r25, r25
    610a:	88 0f       	add	r24, r24
    610c:	99 1f       	adc	r25, r25
    610e:	e8 0f       	add	r30, r24
    6110:	f9 1f       	adc	r31, r25
    6112:	e6 0f       	add	r30, r22
    6114:	f7 1f       	adc	r31, r23
    6116:	ed 56       	subi	r30, 0x6D	; 109
    6118:	f7 4f       	sbci	r31, 0xF7	; 247
    611a:	20 83       	st	Z, r18
    611c:	82 2f       	mov	r24, r18
    611e:	0e 94 76 2f 	call	0x5eec	; 0x5eec <Send>
				#ifndef QslRD
					*((uint8_t*)RMON+Y*LCDXSz+X) =
				#endif
			#endif
				(((Blink>=8 && Blink<=10 )|| Blink>=14)&&cursor_symb&&(CurrField!=255))?prb(Win2LCD+(unsigned char)cursor_symb):(prb(Win2LCD+(unsigned char)LCD_Buf[Y][X])));
				X++;
    6122:	1f 5f       	subi	r17, 0xFF	; 255
    6124:	10 93 e8 02 	sts	0x02E8, r17
    6128:	24 e6       	ldi	r18, 0x64	; 100
    612a:	30 e0       	ldi	r19, 0x00	; 0
    612c:	15 c0       	rjmp	.+42     	; 0x6158 <__vector_18+0x12e>
		}
		else {
			X = 0;
    612e:	10 92 e8 02 	sts	0x02E8, r1
			if (++Y==LCDYSz) {
    6132:	e0 91 e7 02 	lds	r30, 0x02E7
    6136:	ef 5f       	subi	r30, 0xFF	; 255
    6138:	e0 93 e7 02 	sts	0x02E7, r30
    613c:	e4 30       	cpi	r30, 0x04	; 4
    613e:	09 f4       	brne	.+2      	; 0x6142 <__vector_18+0x118>
    6140:	51 c0       	rjmp	.+162    	; 0x61e4 <__vector_18+0x1ba>
				Y = 0;
				TIMSK_LCD &= ~(1<<OCIE1B);	//stop Output CompareB interrups
			}
			Port_LCD_RS &=~LCD_RS;
    6142:	44 98       	cbi	0x08, 4	; 8
    6144:	f0 e0       	ldi	r31, 0x00	; 0
    6146:	ed 50       	subi	r30, 0x0D	; 13
    6148:	fe 4b       	sbci	r31, 0xBE	; 190
    614a:	e4 91       	lpm	r30, Z+
			Send(prb(LineAddr+Y));
    614c:	8e 2f       	mov	r24, r30
    614e:	0e 94 76 2f 	call	0x5eec	; 0x5eec <Send>
			Port_LCD_RS |=LCD_RS;
    6152:	44 9a       	sbi	0x08, 4	; 8
    6154:	24 e6       	ldi	r18, 0x64	; 100
    6156:	30 e0       	ldi	r19, 0x00	; 0
		}
	}
	LCD_delay = TCNT1 + LCD_delay;
    6158:	80 91 84 00 	lds	r24, 0x0084
    615c:	90 91 85 00 	lds	r25, 0x0085
    6160:	82 0f       	add	r24, r18
    6162:	93 1f       	adc	r25, r19
	if(LCD_delay >= 20000) OCR1B = LCD_delay - 20000;
    6164:	2e e4       	ldi	r18, 0x4E	; 78
    6166:	80 32       	cpi	r24, 0x20	; 32
    6168:	92 07       	cpc	r25, r18
    616a:	d8 f4       	brcc	.+54     	; 0x61a2 <__vector_18+0x178>
	else OCR1B = LCD_delay;
    616c:	90 93 8b 00 	sts	0x008B, r25
    6170:	80 93 8a 00 	sts	0x008A, r24
	TIFR_LCD |= (1<<OCF1B);
    6174:	b2 9a       	sbi	0x16, 2	; 22
}
    6176:	ff 91       	pop	r31
    6178:	ef 91       	pop	r30
    617a:	bf 91       	pop	r27
    617c:	af 91       	pop	r26
    617e:	9f 91       	pop	r25
    6180:	8f 91       	pop	r24
    6182:	7f 91       	pop	r23
    6184:	6f 91       	pop	r22
    6186:	5f 91       	pop	r21
    6188:	4f 91       	pop	r20
    618a:	3f 91       	pop	r19
    618c:	2f 91       	pop	r18
    618e:	1f 91       	pop	r17
    6190:	0f 91       	pop	r16
    6192:	ff 90       	pop	r15
    6194:	0f 90       	pop	r0
    6196:	0b be       	out	0x3b, r0	; 59
    6198:	0f 90       	pop	r0
    619a:	0f be       	out	0x3f, r0	; 63
    619c:	0f 90       	pop	r0
    619e:	1f 90       	pop	r1
    61a0:	18 95       	reti
			Send(prb(LineAddr+Y));
			Port_LCD_RS |=LCD_RS;
		}
	}
	LCD_delay = TCNT1 + LCD_delay;
	if(LCD_delay >= 20000) OCR1B = LCD_delay - 20000;
    61a2:	80 52       	subi	r24, 0x20	; 32
    61a4:	9e 44       	sbci	r25, 0x4E	; 78
    61a6:	90 93 8b 00 	sts	0x008B, r25
    61aa:	80 93 8a 00 	sts	0x008A, r24
    61ae:	e2 cf       	rjmp	.-60     	; 0x6174 <__vector_18+0x14a>
ISR(TIMER1_COMPB_vect){

	uint16_t LCD_delay = 100;	//50us

	if (LCD_Rst_Flg) {
		switch(LCD_Rst_Flg){
    61b0:	12 30       	cpi	r17, 0x02	; 2
    61b2:	21 f1       	breq	.+72     	; 0x61fc <__vector_18+0x1d2>
    61b4:	13 30       	cpi	r17, 0x03	; 3
    61b6:	f8 f4       	brcc	.+62     	; 0x61f6 <__vector_18+0x1cc>
    61b8:	11 30       	cpi	r17, 0x01	; 1
    61ba:	01 f1       	breq	.+64     	; 0x61fc <__vector_18+0x1d2>
				#else
					Send(0b00000010);	//RETURN HOME					
				#endif
				Port_LCD_RS |=LCD_RS;
			default:
				LCD_Rst_Flg = 255;
    61bc:	8f ef       	ldi	r24, 0xFF	; 255
    61be:	80 93 d6 04 	sts	0x04D6, r24
		}
		if(LCD_Rst_Flg==1) LCD_delay = 400;	//200us
    61c2:	80 91 d6 04 	lds	r24, 0x04D6
    61c6:	81 30       	cpi	r24, 0x01	; 1
    61c8:	09 f0       	breq	.+2      	; 0x61cc <__vector_18+0x1a2>
    61ca:	5f cf       	rjmp	.-322    	; 0x608a <__vector_18+0x60>
    61cc:	20 e9       	ldi	r18, 0x90	; 144
    61ce:	31 e0       	ldi	r19, 0x01	; 1
    61d0:	5e cf       	rjmp	.-324    	; 0x608e <__vector_18+0x64>
				#else
					Send(0b00101000);	//; 4-bits DL, 2 lines, 5x7 dots
				#endif
				break;
			case 5:
				Send(0b00001100);	//; Display on, cursor off, blink off	
    61d2:	8c e0       	ldi	r24, 0x0C	; 12
    61d4:	0e 94 76 2f 	call	0x5eec	; 0x5eec <Send>
    61d8:	53 cf       	rjmp	.-346    	; 0x6080 <__vector_18+0x56>
    61da:	61 2f       	mov	r22, r17
    61dc:	70 e0       	ldi	r23, 0x00	; 0
    61de:	e0 91 e7 02 	lds	r30, 0x02E7
    61e2:	72 cf       	rjmp	.-284    	; 0x60c8 <__vector_18+0x9e>
				X++;
		}
		else {
			X = 0;
			if (++Y==LCDYSz) {
				Y = 0;
    61e4:	10 92 e7 02 	sts	0x02E7, r1
				TIMSK_LCD &= ~(1<<OCIE1B);	//stop Output CompareB interrups
    61e8:	80 91 6f 00 	lds	r24, 0x006F
    61ec:	8b 7f       	andi	r24, 0xFB	; 251
    61ee:	80 93 6f 00 	sts	0x006F, r24
    61f2:	e0 e0       	ldi	r30, 0x00	; 0
    61f4:	a6 cf       	rjmp	.-180    	; 0x6142 <__vector_18+0x118>
ISR(TIMER1_COMPB_vect){

	uint16_t LCD_delay = 100;	//50us

	if (LCD_Rst_Flg) {
		switch(LCD_Rst_Flg){
    61f6:	13 30       	cpi	r17, 0x03	; 3
    61f8:	09 f0       	breq	.+2      	; 0x61fc <__vector_18+0x1d2>
    61fa:	56 c0       	rjmp	.+172    	; 0x62a8 <__vector_18+0x27e>
			case 2:
				LCD_FuncSet0();
				break;
			case 3:
				#ifdef Port_LCD_DB0	
					LCD_FuncSet0();
    61fc:	0e 94 be 2f 	call	0x5f7c	; 0x5f7c <LCD_FuncSet0>
    6200:	3f cf       	rjmp	.-386    	; 0x6080 <__vector_18+0x56>
			else
			{
				cursor_symb=0;
			}

			Send(
    6202:	ca 01       	movw	r24, r20
    6204:	88 0f       	add	r24, r24
    6206:	99 1f       	adc	r25, r25
    6208:	84 0f       	add	r24, r20
    620a:	95 1f       	adc	r25, r21
    620c:	fc 01       	movw	r30, r24
    620e:	ee 0f       	add	r30, r30
    6210:	ff 1f       	adc	r31, r31
    6212:	ee 0f       	add	r30, r30
    6214:	ff 1f       	adc	r31, r31
    6216:	ee 0f       	add	r30, r30
    6218:	ff 1f       	adc	r31, r31
    621a:	e8 1b       	sub	r30, r24
    621c:	f9 0b       	sbc	r31, r25
    621e:	e6 0f       	add	r30, r22
    6220:	f7 1f       	adc	r31, r23
    6222:	e8 5a       	subi	r30, 0xA8	; 168
    6224:	f9 4f       	sbci	r31, 0xF9	; 249
    6226:	e0 81       	ld	r30, Z
    6228:	f0 e0       	ldi	r31, 0x00	; 0
    622a:	ed 50       	subi	r30, 0x0D	; 13
    622c:	ff 4b       	sbci	r31, 0xBF	; 191
    622e:	24 91       	lpm	r18, Z+
    6230:	64 cf       	rjmp	.-312    	; 0x60fa <__vector_18+0xd0>
ISR(TIMER1_COMPB_vect){

	uint16_t LCD_delay = 100;	//50us

	if (LCD_Rst_Flg) {
		switch(LCD_Rst_Flg){
    6232:	18 30       	cpi	r17, 0x08	; 8
    6234:	49 f0       	breq	.+18     	; 0x6248 <__vector_18+0x21e>
    6236:	19 30       	cpi	r17, 0x09	; 9
    6238:	09 f0       	breq	.+2      	; 0x623c <__vector_18+0x212>
    623a:	c0 cf       	rjmp	.-128    	; 0x61bc <__vector_18+0x192>
						else{i=0;LCD_Rst_Flg = 8;}
					}
				}
				break;
			case 9:
				Port_LCD_RS &=~LCD_RS;
    623c:	44 98       	cbi	0x08, 4	; 8
				#ifdef NOT_USE_LCD_RETURN_HOME_CMD
					Send(128);			//     
				#else
					Send(0b00000010);	//RETURN HOME					
    623e:	82 e0       	ldi	r24, 0x02	; 2
    6240:	0e 94 76 2f 	call	0x5eec	; 0x5eec <Send>
				#endif
				Port_LCD_RS |=LCD_RS;
    6244:	44 9a       	sbi	0x08, 4	; 8
    6246:	ba cf       	rjmp	.-140    	; 0x61bc <__vector_18+0x192>
				Send(0b01000000);	//;    CG RAM   0.
				Port_LCD_RS |=LCD_RS;
				break;
			case 8:{
					static uint8_t i,j;
					LCD_Rst_Flg = 7;
    6248:	87 e0       	ldi	r24, 0x07	; 7
    624a:	80 93 d6 04 	sts	0x04D6, r24
					Send(prb(CGRAM_LCD[i]+j));
    624e:	f0 90 ea 02 	lds	r15, 0x02EA
    6252:	00 91 e9 02 	lds	r16, 0x02E9
    6256:	ef 2d       	mov	r30, r15
    6258:	f0 e0       	ldi	r31, 0x00	; 0
    625a:	ee 0f       	add	r30, r30
    625c:	ff 1f       	adc	r31, r31
    625e:	ee 0f       	add	r30, r30
    6260:	ff 1f       	adc	r31, r31
    6262:	ee 0f       	add	r30, r30
    6264:	ff 1f       	adc	r31, r31
    6266:	e0 0f       	add	r30, r16
    6268:	f1 1d       	adc	r31, r1
    626a:	ed 54       	subi	r30, 0x4D	; 77
    626c:	ff 4b       	sbci	r31, 0xBF	; 191
    626e:	e4 91       	lpm	r30, Z+
    6270:	8e 2f       	mov	r24, r30
    6272:	0e 94 76 2f 	call	0x5eec	; 0x5eec <Send>
					if(j<7) j++;
    6276:	07 30       	cpi	r16, 0x07	; 7
    6278:	f0 f0       	brcs	.+60     	; 0x62b6 <__vector_18+0x28c>
					else{
						j=0;
    627a:	10 92 e9 02 	sts	0x02E9, r1
						if(i<7)i++;
    627e:	26 e0       	ldi	r18, 0x06	; 6
    6280:	2f 15       	cp	r18, r15
    6282:	e8 f0       	brcs	.+58     	; 0x62be <__vector_18+0x294>
    6284:	f3 94       	inc	r15
    6286:	f0 92 ea 02 	sts	0x02EA, r15
    628a:	fa ce       	rjmp	.-524    	; 0x6080 <__vector_18+0x56>
		static uint8_t X, Y;
		static prog_uint8_t LineAddr[] = {128, 192, 148, 212};
		unsigned char cursor_symb;
		
		if (X<LCDXSz) {
			if((X>=CurrX)&&(X<(CurrX+StrSize))&&(Y==CurrLCD)){
    628c:	e0 91 e7 02 	lds	r30, 0x02E7
    6290:	80 91 e8 08 	lds	r24, 0x08E8
    6294:	e8 17       	cp	r30, r24
    6296:	09 f0       	breq	.+2      	; 0x629a <__vector_18+0x270>
    6298:	17 cf       	rjmp	.-466    	; 0x60c8 <__vector_18+0x9e>
    629a:	2f e5       	ldi	r18, 0x5F	; 95
    629c:	16 cf       	rjmp	.-468    	; 0x60ca <__vector_18+0xa0>
				break;
			case 6:
				Send(0b00000110);	//; cursor shift right, no display shift
				break;
			case 7:
				Send(0b01000000);	//;    CG RAM   0.
    629e:	80 e4       	ldi	r24, 0x40	; 64
    62a0:	0e 94 76 2f 	call	0x5eec	; 0x5eec <Send>
				Port_LCD_RS |=LCD_RS;
    62a4:	44 9a       	sbi	0x08, 4	; 8
    62a6:	ec ce       	rjmp	.-552    	; 0x6080 <__vector_18+0x56>
ISR(TIMER1_COMPB_vect){

	uint16_t LCD_delay = 100;	//50us

	if (LCD_Rst_Flg) {
		switch(LCD_Rst_Flg){
    62a8:	14 30       	cpi	r17, 0x04	; 4
    62aa:	09 f0       	breq	.+2      	; 0x62ae <__vector_18+0x284>
    62ac:	87 cf       	rjmp	.-242    	; 0x61bc <__vector_18+0x192>
					LCD_FuncSet1();
				#endif
				break;
			case 4:
				#ifdef Port_LCD_DB0	
					Send(0b00111000);	//; 8-bits DL, 2 lines, 5x7 dots
    62ae:	88 e3       	ldi	r24, 0x38	; 56
    62b0:	0e 94 76 2f 	call	0x5eec	; 0x5eec <Send>
    62b4:	e5 ce       	rjmp	.-566    	; 0x6080 <__vector_18+0x56>
				break;
			case 8:{
					static uint8_t i,j;
					LCD_Rst_Flg = 7;
					Send(prb(CGRAM_LCD[i]+j));
					if(j<7) j++;
    62b6:	0f 5f       	subi	r16, 0xFF	; 255
    62b8:	00 93 e9 02 	sts	0x02E9, r16
    62bc:	e1 ce       	rjmp	.-574    	; 0x6080 <__vector_18+0x56>
					else{
						j=0;
						if(i<7)i++;
						else{i=0;LCD_Rst_Flg = 8;}
    62be:	10 92 ea 02 	sts	0x02EA, r1
    62c2:	10 93 d6 04 	sts	0x04D6, r17
    62c6:	dc ce       	rjmp	.-584    	; 0x6080 <__vector_18+0x56>

000062c8 <LCDBackLightOn>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    62c8:	9f b7       	in	r25, 0x3f	; 63
    62ca:	90 78       	andi	r25, 0x80	; 128
    62cc:	90 93 ee 02 	sts	0x02EE, r25
	cli();
    62d0:	f8 94       	cli
	void LCDBackLightOn(void){
		IntOff();	
		#ifdef BACKLIGHT_INVERSION
			PORT_BACKLIGHT &= ~BACKLIGHT;
		#else
			PORT_BACKLIGHT |= BACKLIGHT;
    62d2:	80 91 0b 01 	lds	r24, 0x010B
    62d6:	80 64       	ori	r24, 0x40	; 64
    62d8:	80 93 0b 01 	sts	0x010B, r24

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    62dc:	99 23       	and	r25, r25
    62de:	09 f0       	breq	.+2      	; 0x62e2 <LCDBackLightOn+0x1a>
		sei();
    62e0:	78 94       	sei
    62e2:	08 95       	ret

000062e4 <LCDBackLightOff>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    62e4:	9f b7       	in	r25, 0x3f	; 63
    62e6:	90 78       	andi	r25, 0x80	; 128
    62e8:	90 93 ee 02 	sts	0x02EE, r25
	cli();
    62ec:	f8 94       	cli
	void LCDBackLightOff(void){
		IntOff();	
		#ifdef BACKLIGHT_INVERSION
			PORT_BACKLIGHT |= BACKLIGHT;
		#else
			PORT_BACKLIGHT &= ~BACKLIGHT;
    62ee:	80 91 0b 01 	lds	r24, 0x010B
    62f2:	8f 7b       	andi	r24, 0xBF	; 191
    62f4:	80 93 0b 01 	sts	0x010B, r24

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    62f8:	99 23       	and	r25, r25
    62fa:	09 f0       	breq	.+2      	; 0x62fe <LCDBackLightOff+0x1a>
		sei();
    62fc:	78 94       	sei
    62fe:	08 95       	ret

00006300 <LCDBackLightControl>:
				StartTimer16(TD_BackLight, 3000);
				break;			
		}
	}
	void LCDBackLightControl(void){
		switch(BackLightMode){
    6300:	80 91 52 06 	lds	r24, 0x0652
    6304:	81 30       	cpi	r24, 0x01	; 1
    6306:	29 f0       	breq	.+10     	; 0x6312 <LCDBackLightControl+0x12>
    6308:	82 30       	cpi	r24, 0x02	; 2
    630a:	61 f0       	breq	.+24     	; 0x6324 <LCDBackLightControl+0x24>
		case 1: if(Timer16Stopp(TD_BackLight)) LCDBackLightOff();
			break;
		case 2:
			break;
		default: LCDBackLightOn();
    630c:	0e 94 64 31 	call	0x62c8	; 0x62c8 <LCDBackLightOn>
    6310:	08 95       	ret
				break;			
		}
	}
	void LCDBackLightControl(void){
		switch(BackLightMode){
		case 1: if(Timer16Stopp(TD_BackLight)) LCDBackLightOff();
    6312:	80 91 d8 04 	lds	r24, 0x04D8
    6316:	0e 94 96 25 	call	0x4b2c	; 0x4b2c <Timer16Stopp>
    631a:	88 23       	and	r24, r24
    631c:	c9 f3       	breq	.-14     	; 0x6310 <LCDBackLightControl+0x10>
    631e:	0e 94 72 31 	call	0x62e4	; 0x62e4 <LCDBackLightOff>
    6322:	08 95       	ret
    6324:	08 95       	ret

00006326 <StartTimer0>:
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
		TCCR0  = ((((1<<WGM01) &~(1<<WGM00)  &~(1<<COM01)  &~(1<<COM00)) |(1<<CS02)) &~(1<<CS01)) |(1<<CS00);
	#elif defined (__AVR_ATmega128__)
		TCCR0  =   ((1<<WGM01) &~(1<<WGM00)  &~(1<<COM01)  &~(1<<COM00)) |(1<<CS02)   |(1<<CS01)  |(1<<CS00);
	#elif defined (__AVR_ATmega1280__)  || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TCCR0A =    (1<<WGM01) &~(1<<WGM00)  &~(1<<COM0A1) &~(1<<COM0A0) &~(1<<COM0B1) &~(1<<COM0B0);
    6326:	82 e0       	ldi	r24, 0x02	; 2
    6328:	84 bd       	out	0x24, r24	; 36
		TCCR0B = ((~(1<<WGM02)                                           |(1<<CS02)) &~(1<<CS01)) |(1<<CS00);
    632a:	85 ef       	ldi	r24, 0xF5	; 245
    632c:	85 bd       	out	0x25, r24	; 37
	#endif
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__)
		TIMSK |=(1<<OCIE0);
	#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TIMSK0 |=(1<<OCIE0A);
    632e:	ee e6       	ldi	r30, 0x6E	; 110
    6330:	f0 e0       	ldi	r31, 0x00	; 0
    6332:	80 81       	ld	r24, Z
    6334:	82 60       	ori	r24, 0x02	; 2
    6336:	80 83       	st	Z, r24
	#endif
}
    6338:	08 95       	ret

0000633a <StartTimer2>:
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
		TCCR2  =   ((1<<WGM21) &~(1<<WGM20)  &~(1<<COM21)  &~(1<<COM20)) |(1<<CS22)   |(1<<CS21)  |(1<<CS20);
	#elif defined (__AVR_ATmega128__)
		TCCR2  = ((((1<<WGM21) &~(1<<WGM20)  &~(1<<COM21)  &~(1<<COM20)) |(1<<CS22)) &~(1<<CS21)) |(1<<CS20);
	#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TCCR2A =    (1<<WGM21) &~(1<<WGM20)  &~(1<<COM2A1) &~(1<<COM2A0) &~(1<<COM2B1) &~(1<<COM2B0);
    633a:	82 e0       	ldi	r24, 0x02	; 2
    633c:	80 93 b0 00 	sts	0x00B0, r24
		TCCR2B =   ~(1<<WGM22)                                           |(1<<CS22)   |(1<<CS21)  |(1<<CS20);
    6340:	87 ef       	ldi	r24, 0xF7	; 247
    6342:	80 93 b1 00 	sts	0x00B1, r24
	#endif
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__)
		TIMSK |=(1<<OCIE2);
	#elif  defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TIMSK2 |=(1<<OCIE2A);
    6346:	e0 e7       	ldi	r30, 0x70	; 112
    6348:	f0 e0       	ldi	r31, 0x00	; 0
    634a:	80 81       	ld	r24, Z
    634c:	82 60       	ori	r24, 0x02	; 2
    634e:	80 83       	st	Z, r24
	#endif
}
    6350:	08 95       	ret

00006352 <StartTimer4>:
#if defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
	//static void
	void
	StartTimer4(void)
	{
		TCCR4A = 0;
    6352:	10 92 a0 00 	sts	0x00A0, r1
		TCCR4B = (1<<WGM42) | (1<<CS42) | (0<<CS41) | (1<<CS40);	// clk/1024
    6356:	8d e0       	ldi	r24, 0x0D	; 13
    6358:	80 93 a1 00 	sts	0x00A1, r24
		TIMSK4 |=(1<<OCIE4A);
    635c:	e2 e7       	ldi	r30, 0x72	; 114
    635e:	f0 e0       	ldi	r31, 0x00	; 0
    6360:	80 81       	ld	r24, Z
    6362:	82 60       	ori	r24, 0x02	; 2
    6364:	80 83       	st	Z, r24
	}
    6366:	08 95       	ret

00006368 <MB_Timer_ISR>:
// ~~~

// ~~~~~~~~~~~~~~~~~~~
static void
MB_Timer_ISR(tc_t *tc)
{
    6368:	bc 01       	movw	r22, r24

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    636a:	e1 ea       	ldi	r30, 0xA1	; 161
    636c:	f0 e4       	ldi	r31, 0x40	; 64
    636e:	85 91       	lpm	r24, Z+
    6370:	94 91       	lpm	r25, Z+
	#if defined (__AVR_ATxmega128A1__)
		tc->INTCTRLA = (tc->INTCTRLA &~TC1_OVFINTLVL_gm) |TC_OVFINTLVL_OFF_gc;
		tc->CTRLA = TC_CLKSEL_OFF_gc;
	#endif
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Timer[MB_N]tc_f)!=tc; MB_N++);
    6372:	68 17       	cp	r22, r24
    6374:	79 07       	cpc	r23, r25
    6376:	09 f4       	brne	.+2      	; 0x637a <MB_Timer_ISR+0x12>
    6378:	54 c0       	rjmp	.+168    	; 0x6422 <MB_Timer_ISR+0xba>
    637a:	20 e0       	ldi	r18, 0x00	; 0
    637c:	2f 5f       	subi	r18, 0xFF	; 255
    637e:	42 2f       	mov	r20, r18
    6380:	50 e0       	ldi	r21, 0x00	; 0
    6382:	fa 01       	movw	r30, r20
    6384:	ee 0f       	add	r30, r30
    6386:	ff 1f       	adc	r31, r31
    6388:	e4 0f       	add	r30, r20
    638a:	f5 1f       	adc	r31, r21
    638c:	ee 0f       	add	r30, r30
    638e:	ff 1f       	adc	r31, r31
    6390:	ef 55       	subi	r30, 0x5F	; 95
    6392:	ff 4b       	sbci	r31, 0xBF	; 191
    6394:	85 91       	lpm	r24, Z+
    6396:	94 91       	lpm	r25, Z+
    6398:	68 17       	cp	r22, r24
    639a:	79 07       	cpc	r23, r25
    639c:	79 f7       	brne	.-34     	; 0x637c <MB_Timer_ISR+0x14>
    639e:	fa 01       	movw	r30, r20

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    63a0:	e0 56       	subi	r30, 0x60	; 96
    63a2:	ff 4b       	sbci	r31, 0xBF	; 191
    63a4:	84 91       	lpm	r24, Z+

	
	switch (prb(MB_Role+MB_N)){
    63a6:	88 23       	and	r24, r24
    63a8:	f9 f4       	brne	.+62     	; 0x63e8 <MB_Timer_ISR+0x80>
	case Role_Slave:
		if(MB_Frame[MB_N][0]==MB_NativeAddr[MB_N]){	// Slave     -   MB_TimerFlag
    63aa:	f4 2f       	mov	r31, r20
    63ac:	ee 27       	eor	r30, r30
    63ae:	e5 59       	subi	r30, 0x95	; 149
    63b0:	f4 4f       	sbci	r31, 0xF4	; 244
    63b2:	da 01       	movw	r26, r20
    63b4:	a0 52       	subi	r26, 0x20	; 32
    63b6:	ba 4f       	sbci	r27, 0xFA	; 250
    63b8:	90 81       	ld	r25, Z
    63ba:	8c 91       	ld	r24, X
    63bc:	98 17       	cp	r25, r24
    63be:	21 f1       	breq	.+72     	; 0x6408 <MB_Timer_ISR+0xa0>
			MB_TimerFlag |= (1<<MB_N);
		}
		else{
			MB_State[MB_N] = MB_Idle;
    63c0:	fa 01       	movw	r30, r20
    63c2:	ee 53       	subi	r30, 0x3E	; 62
    63c4:	fa 4f       	sbci	r31, 0xFA	; 250
    63c6:	81 e0       	ldi	r24, 0x01	; 1
    63c8:	80 83       	st	Z, r24
			MB_CPT[MB_N][0]++;
    63ca:	fa 01       	movw	r30, r20
    63cc:	e2 95       	swap	r30
    63ce:	f2 95       	swap	r31
    63d0:	f0 7f       	andi	r31, 0xF0	; 240
    63d2:	fe 27       	eor	r31, r30
    63d4:	e0 7f       	andi	r30, 0xF0	; 240
    63d6:	fe 27       	eor	r31, r30
    63d8:	ea 5c       	subi	r30, 0xCA	; 202
    63da:	f6 4f       	sbci	r31, 0xF6	; 246
    63dc:	80 81       	ld	r24, Z
    63de:	91 81       	ldd	r25, Z+1	; 0x01
    63e0:	01 96       	adiw	r24, 0x01	; 1
    63e2:	91 83       	std	Z+1, r25	; 0x01
    63e4:	80 83       	st	Z, r24
    63e6:	08 95       	ret
	#endif
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Timer[MB_N]tc_f)!=tc; MB_N++);

	
	switch (prb(MB_Role+MB_N)){
    63e8:	81 30       	cpi	r24, 0x01	; 1
    63ea:	09 f0       	breq	.+2      	; 0x63ee <MB_Timer_ISR+0x86>
    63ec:	08 95       	ret
			MB_State[MB_N] = MB_Idle;
			MB_CPT[MB_N][0]++;
		}
		break;
	case Role_Master:
		MB_TimerFlag |= (1<<MB_N);
    63ee:	20 91 2a 09 	lds	r18, 0x092A
    63f2:	81 e0       	ldi	r24, 0x01	; 1
    63f4:	90 e0       	ldi	r25, 0x00	; 0
    63f6:	02 c0       	rjmp	.+4      	; 0x63fc <MB_Timer_ISR+0x94>
    63f8:	88 0f       	add	r24, r24
    63fa:	99 1f       	adc	r25, r25
    63fc:	4a 95       	dec	r20
    63fe:	e2 f7       	brpl	.-8      	; 0x63f8 <MB_Timer_ISR+0x90>
    6400:	28 2b       	or	r18, r24
    6402:	20 93 2a 09 	sts	0x092A, r18
    6406:	08 95       	ret

	
	switch (prb(MB_Role+MB_N)){
	case Role_Slave:
		if(MB_Frame[MB_N][0]==MB_NativeAddr[MB_N]){	// Slave     -   MB_TimerFlag
			MB_TimerFlag |= (1<<MB_N);
    6408:	20 91 2a 09 	lds	r18, 0x092A
    640c:	81 e0       	ldi	r24, 0x01	; 1
    640e:	90 e0       	ldi	r25, 0x00	; 0
    6410:	02 c0       	rjmp	.+4      	; 0x6416 <MB_Timer_ISR+0xae>
    6412:	88 0f       	add	r24, r24
    6414:	99 1f       	adc	r25, r25
    6416:	4a 95       	dec	r20
    6418:	e2 f7       	brpl	.-8      	; 0x6412 <MB_Timer_ISR+0xaa>
    641a:	28 2b       	or	r18, r24
    641c:	20 93 2a 09 	sts	0x092A, r18
    6420:	08 95       	ret
	#if defined (__AVR_ATxmega128A1__)
		tc->INTCTRLA = (tc->INTCTRLA &~TC1_OVFINTLVL_gm) |TC_OVFINTLVL_OFF_gc;
		tc->CTRLA = TC_CLKSEL_OFF_gc;
	#endif
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Timer[MB_N]tc_f)!=tc; MB_N++);
    6422:	40 e0       	ldi	r20, 0x00	; 0
    6424:	50 e0       	ldi	r21, 0x00	; 0
    6426:	e0 e0       	ldi	r30, 0x00	; 0
    6428:	f0 e0       	ldi	r31, 0x00	; 0
    642a:	ba cf       	rjmp	.-140    	; 0x63a0 <MB_Timer_ISR+0x38>

0000642c <__vector_21>:
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#elif  defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) ||defined (__AVR_ATmega2561__)
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ISR(TIMER0_COMPA_vect)
{
    642c:	1f 92       	push	r1
    642e:	0f 92       	push	r0
    6430:	0f b6       	in	r0, 0x3f	; 63
    6432:	0f 92       	push	r0
    6434:	0b b6       	in	r0, 0x3b	; 59
    6436:	0f 92       	push	r0
    6438:	11 24       	eor	r1, r1
    643a:	2f 93       	push	r18
    643c:	3f 93       	push	r19
    643e:	4f 93       	push	r20
    6440:	5f 93       	push	r21
    6442:	6f 93       	push	r22
    6444:	7f 93       	push	r23
    6446:	8f 93       	push	r24
    6448:	9f 93       	push	r25
    644a:	af 93       	push	r26
    644c:	bf 93       	push	r27
    644e:	ef 93       	push	r30
    6450:	ff 93       	push	r31
	TCCR0B &=~(1<<CS02) &~(1<<CS01) &~(1<<CS00);
    6452:	85 b5       	in	r24, 0x25	; 37
    6454:	88 7f       	andi	r24, 0xF8	; 248
    6456:	85 bd       	out	0x25, r24	; 37
	TIMSK0 &=~(1<<OCIE0A);
    6458:	ee e6       	ldi	r30, 0x6E	; 110
    645a:	f0 e0       	ldi	r31, 0x00	; 0
    645c:	80 81       	ld	r24, Z
    645e:	8d 7f       	andi	r24, 0xFD	; 253
    6460:	80 83       	st	Z, r24
	MB_Timer_ISR(&TCNT0);
    6462:	86 e4       	ldi	r24, 0x46	; 70
    6464:	90 e0       	ldi	r25, 0x00	; 0
    6466:	0e 94 b4 31 	call	0x6368	; 0x6368 <MB_Timer_ISR>
}
    646a:	ff 91       	pop	r31
    646c:	ef 91       	pop	r30
    646e:	bf 91       	pop	r27
    6470:	af 91       	pop	r26
    6472:	9f 91       	pop	r25
    6474:	8f 91       	pop	r24
    6476:	7f 91       	pop	r23
    6478:	6f 91       	pop	r22
    647a:	5f 91       	pop	r21
    647c:	4f 91       	pop	r20
    647e:	3f 91       	pop	r19
    6480:	2f 91       	pop	r18
    6482:	0f 90       	pop	r0
    6484:	0b be       	out	0x3b, r0	; 59
    6486:	0f 90       	pop	r0
    6488:	0f be       	out	0x3f, r0	; 63
    648a:	0f 90       	pop	r0
    648c:	1f 90       	pop	r1
    648e:	18 95       	reti

00006490 <__vector_13>:

// ~~~~~~~~~~~~~~~~~~~
ISR(TIMER2_COMPA_vect)
{
    6490:	1f 92       	push	r1
    6492:	0f 92       	push	r0
    6494:	0f b6       	in	r0, 0x3f	; 63
    6496:	0f 92       	push	r0
    6498:	0b b6       	in	r0, 0x3b	; 59
    649a:	0f 92       	push	r0
    649c:	11 24       	eor	r1, r1
    649e:	2f 93       	push	r18
    64a0:	3f 93       	push	r19
    64a2:	4f 93       	push	r20
    64a4:	5f 93       	push	r21
    64a6:	6f 93       	push	r22
    64a8:	7f 93       	push	r23
    64aa:	8f 93       	push	r24
    64ac:	9f 93       	push	r25
    64ae:	af 93       	push	r26
    64b0:	bf 93       	push	r27
    64b2:	ef 93       	push	r30
    64b4:	ff 93       	push	r31
	TCCR2B &=~(1<<CS22) &~(1<<CS21) &~(1<<CS20);
    64b6:	e1 eb       	ldi	r30, 0xB1	; 177
    64b8:	f0 e0       	ldi	r31, 0x00	; 0
    64ba:	80 81       	ld	r24, Z
    64bc:	88 7f       	andi	r24, 0xF8	; 248
    64be:	80 83       	st	Z, r24
	TIMSK2 &=~(1<<OCIE2A);
    64c0:	e0 e7       	ldi	r30, 0x70	; 112
    64c2:	f0 e0       	ldi	r31, 0x00	; 0
    64c4:	80 81       	ld	r24, Z
    64c6:	8d 7f       	andi	r24, 0xFD	; 253
    64c8:	80 83       	st	Z, r24
	MB_Timer_ISR(&TCNT2);
    64ca:	82 eb       	ldi	r24, 0xB2	; 178
    64cc:	90 e0       	ldi	r25, 0x00	; 0
    64ce:	0e 94 b4 31 	call	0x6368	; 0x6368 <MB_Timer_ISR>
}
    64d2:	ff 91       	pop	r31
    64d4:	ef 91       	pop	r30
    64d6:	bf 91       	pop	r27
    64d8:	af 91       	pop	r26
    64da:	9f 91       	pop	r25
    64dc:	8f 91       	pop	r24
    64de:	7f 91       	pop	r23
    64e0:	6f 91       	pop	r22
    64e2:	5f 91       	pop	r21
    64e4:	4f 91       	pop	r20
    64e6:	3f 91       	pop	r19
    64e8:	2f 91       	pop	r18
    64ea:	0f 90       	pop	r0
    64ec:	0b be       	out	0x3b, r0	; 59
    64ee:	0f 90       	pop	r0
    64f0:	0f be       	out	0x3f, r0	; 63
    64f2:	0f 90       	pop	r0
    64f4:	1f 90       	pop	r1
    64f6:	18 95       	reti

000064f8 <__vector_42>:
// ~~~~~~~~~~~~~~~~~~~
ISR(TIMER4_COMPA_vect)
{
    64f8:	1f 92       	push	r1
    64fa:	0f 92       	push	r0
    64fc:	0f b6       	in	r0, 0x3f	; 63
    64fe:	0f 92       	push	r0
    6500:	0b b6       	in	r0, 0x3b	; 59
    6502:	0f 92       	push	r0
    6504:	11 24       	eor	r1, r1
    6506:	2f 93       	push	r18
    6508:	3f 93       	push	r19
    650a:	4f 93       	push	r20
    650c:	5f 93       	push	r21
    650e:	6f 93       	push	r22
    6510:	7f 93       	push	r23
    6512:	8f 93       	push	r24
    6514:	9f 93       	push	r25
    6516:	af 93       	push	r26
    6518:	bf 93       	push	r27
    651a:	ef 93       	push	r30
    651c:	ff 93       	push	r31
	TCCR4B &=~(1<<CS42) &~(1<<CS41) &~(1<<CS40);
    651e:	e1 ea       	ldi	r30, 0xA1	; 161
    6520:	f0 e0       	ldi	r31, 0x00	; 0
    6522:	80 81       	ld	r24, Z
    6524:	88 7f       	andi	r24, 0xF8	; 248
    6526:	80 83       	st	Z, r24
	TIMSK4 &=~(1<<OCIE4A);
    6528:	e2 e7       	ldi	r30, 0x72	; 114
    652a:	f0 e0       	ldi	r31, 0x00	; 0
    652c:	80 81       	ld	r24, Z
    652e:	8d 7f       	andi	r24, 0xFD	; 253
    6530:	80 83       	st	Z, r24
	MB_Timer_ISR((uint8_t*)&TCNT4);
    6532:	84 ea       	ldi	r24, 0xA4	; 164
    6534:	90 e0       	ldi	r25, 0x00	; 0
    6536:	0e 94 b4 31 	call	0x6368	; 0x6368 <MB_Timer_ISR>
}
    653a:	ff 91       	pop	r31
    653c:	ef 91       	pop	r30
    653e:	bf 91       	pop	r27
    6540:	af 91       	pop	r26
    6542:	9f 91       	pop	r25
    6544:	8f 91       	pop	r24
    6546:	7f 91       	pop	r23
    6548:	6f 91       	pop	r22
    654a:	5f 91       	pop	r21
    654c:	4f 91       	pop	r20
    654e:	3f 91       	pop	r19
    6550:	2f 91       	pop	r18
    6552:	0f 90       	pop	r0
    6554:	0b be       	out	0x3b, r0	; 59
    6556:	0f 90       	pop	r0
    6558:	0f be       	out	0x3f, r0	; 63
    655a:	0f 90       	pop	r0
    655c:	1f 90       	pop	r1
    655e:	18 95       	reti

00006560 <MBRecept>:
		#endif
		MB_Err &=(1<<MB_N);
		return;
	}
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		Buf = USART_Reg(MB_N, ucsra);
    6560:	68 2f       	mov	r22, r24
    6562:	70 e0       	ldi	r23, 0x00	; 0

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6564:	9b 01       	movw	r18, r22
    6566:	22 0f       	add	r18, r18
    6568:	33 1f       	adc	r19, r19
    656a:	cb 01       	movw	r24, r22
    656c:	88 0f       	add	r24, r24
    656e:	99 1f       	adc	r25, r25
    6570:	88 0f       	add	r24, r24
    6572:	99 1f       	adc	r25, r25
    6574:	88 0f       	add	r24, r24
    6576:	99 1f       	adc	r25, r25
    6578:	28 0f       	add	r18, r24
    657a:	39 1f       	adc	r19, r25
    657c:	22 0f       	add	r18, r18
    657e:	33 1f       	adc	r19, r19
    6580:	22 57       	subi	r18, 0x72	; 114
    6582:	3f 4b       	sbci	r19, 0xBF	; 191
    6584:	f9 01       	movw	r30, r18
    6586:	a5 91       	lpm	r26, Z+
    6588:	b4 91       	lpm	r27, Z+
    658a:	3c 91       	ld	r19, X
		MB_Frame[MB_N][MB_Frame_Sz[MB_N]++] = USART_Reg(MB_N, udr);
    658c:	ab 01       	movw	r20, r22
    658e:	47 5b       	subi	r20, 0xB7	; 183
    6590:	58 4f       	sbci	r21, 0xF8	; 248
    6592:	fa 01       	movw	r30, r20
    6594:	20 81       	ld	r18, Z
    6596:	cb 01       	movw	r24, r22
    6598:	88 0f       	add	r24, r24
    659a:	99 1f       	adc	r25, r25
    659c:	88 0f       	add	r24, r24
    659e:	99 1f       	adc	r25, r25
    65a0:	fc 01       	movw	r30, r24
    65a2:	ee 0f       	add	r30, r30
    65a4:	ff 1f       	adc	r31, r31
    65a6:	ee 0f       	add	r30, r30
    65a8:	ff 1f       	adc	r31, r31
    65aa:	e8 0f       	add	r30, r24
    65ac:	f9 1f       	adc	r31, r25
    65ae:	e4 57       	subi	r30, 0x74	; 116
    65b0:	ff 4b       	sbci	r31, 0xBF	; 191
    65b2:	a5 91       	lpm	r26, Z+
    65b4:	b4 91       	lpm	r27, Z+
    65b6:	f6 2f       	mov	r31, r22
    65b8:	ee 27       	eor	r30, r30
    65ba:	e2 0f       	add	r30, r18
    65bc:	f1 1d       	adc	r31, r1
    65be:	e5 59       	subi	r30, 0x95	; 149
    65c0:	f4 4f       	sbci	r31, 0xF4	; 244
    65c2:	8c 91       	ld	r24, X
    65c4:	80 83       	st	Z, r24
    65c6:	2f 5f       	subi	r18, 0xFF	; 255
    65c8:	fa 01       	movw	r30, r20
    65ca:	20 83       	st	Z, r18
	#elif defined (__AVR_ATxmega128A1__)
		USART_t *usart = prp(&MB_Port[MB_N].usart);
		Buf = usart->STATUS;
		MB_Frame[MB_N][MB_Frame_Sz[MB_N]++] = usart->DATA;
	#endif
	if (Buf &(1<<3))
    65cc:	23 2f       	mov	r18, r19
    65ce:	30 e0       	ldi	r19, 0x00	; 0
    65d0:	23 ff       	sbrs	r18, 3
    65d2:	0e c0       	rjmp	.+28     	; 0x65f0 <MBRecept+0x90>
		MB_CPT[MB_N][7]++;
    65d4:	fb 01       	movw	r30, r22
    65d6:	e2 95       	swap	r30
    65d8:	f2 95       	swap	r31
    65da:	f0 7f       	andi	r31, 0xF0	; 240
    65dc:	fe 27       	eor	r31, r30
    65de:	e0 7f       	andi	r30, 0xF0	; 240
    65e0:	fe 27       	eor	r31, r30
    65e2:	ea 5c       	subi	r30, 0xCA	; 202
    65e4:	f6 4f       	sbci	r31, 0xF6	; 246
    65e6:	86 85       	ldd	r24, Z+14	; 0x0e
    65e8:	97 85       	ldd	r25, Z+15	; 0x0f
    65ea:	01 96       	adiw	r24, 0x01	; 1
    65ec:	97 87       	std	Z+15, r25	; 0x0f
    65ee:	86 87       	std	Z+14, r24	; 0x0e
	if (Buf &((1<<4) |(1<<3) |(1<<2)))
    65f0:	2c 71       	andi	r18, 0x1C	; 28
    65f2:	30 70       	andi	r19, 0x00	; 0
    65f4:	23 2b       	or	r18, r19
    65f6:	61 f0       	breq	.+24     	; 0x6610 <MBRecept+0xb0>
		MB_Err |=(1<<MB_N);
    65f8:	81 e0       	ldi	r24, 0x01	; 1
    65fa:	90 e0       	ldi	r25, 0x00	; 0
    65fc:	02 c0       	rjmp	.+4      	; 0x6602 <MBRecept+0xa2>
    65fe:	88 0f       	add	r24, r24
    6600:	99 1f       	adc	r25, r25
    6602:	6a 95       	dec	r22
    6604:	e2 f7       	brpl	.-8      	; 0x65fe <MBRecept+0x9e>
    6606:	20 91 d9 04 	lds	r18, 0x04D9
    660a:	28 2b       	or	r18, r24
    660c:	20 93 d9 04 	sts	0x04D9, r18
    6610:	08 95       	ret

00006612 <MB_Transm>:
}

// ~~~~~~~~~~~~~~~~~~~~
void
MB_Transm(uint8_t MB_N)
{
    6612:	af 92       	push	r10
    6614:	bf 92       	push	r11
    6616:	cf 92       	push	r12
    6618:	df 92       	push	r13
    661a:	ef 92       	push	r14
    661c:	ff 92       	push	r15
    661e:	0f 93       	push	r16
    6620:	1f 93       	push	r17
	MB_State[MB_N] = MB_Trans;
    6622:	e8 2e       	mov	r14, r24
    6624:	ff 24       	eor	r15, r15
    6626:	f7 01       	movw	r30, r14
    6628:	ee 53       	subi	r30, 0x3E	; 62
    662a:	fa 4f       	sbci	r31, 0xFA	; 250
    662c:	83 e0       	ldi	r24, 0x03	; 3
    662e:	80 83       	st	Z, r24
    6630:	57 01       	movw	r10, r14
    6632:	aa 0c       	add	r10, r10
    6634:	bb 1c       	adc	r11, r11
    6636:	aa 0c       	add	r10, r10
    6638:	bb 1c       	adc	r11, r11
    663a:	85 01       	movw	r16, r10
    663c:	00 0f       	add	r16, r16
    663e:	11 1f       	adc	r17, r17
    6640:	00 0f       	add	r16, r16
    6642:	11 1f       	adc	r17, r17
    6644:	0a 0d       	add	r16, r10
    6646:	1b 1d       	adc	r17, r11
    6648:	04 5f       	subi	r16, 0xF4	; 244
    664a:	1f 4f       	sbci	r17, 0xFF	; 255
    664c:	8c e8       	ldi	r24, 0x8C	; 140
    664e:	c8 2e       	mov	r12, r24
    6650:	80 e4       	ldi	r24, 0x40	; 64
    6652:	d8 2e       	mov	r13, r24
    6654:	c6 01       	movw	r24, r12
    6656:	80 0f       	add	r24, r16
    6658:	91 1f       	adc	r25, r17
    665a:	0c 50       	subi	r16, 0x0C	; 12
    665c:	10 40       	sbci	r17, 0x00	; 0
    665e:	fc 01       	movw	r30, r24
    6660:	25 91       	lpm	r18, Z+
    6662:	34 91       	lpm	r19, Z+
	USART_Func(MB_N, RS485);
    6664:	f9 01       	movw	r30, r18
    6666:	19 95       	eicall
    6668:	f6 01       	movw	r30, r12
    666a:	e0 0f       	add	r30, r16
    666c:	f1 1f       	adc	r31, r17
    666e:	a5 91       	lpm	r26, Z+
    6670:	b4 91       	lpm	r27, Z+
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		//USART_Reg(MB_N, ucsrb) |=(1<<6);
		USART_Reg(MB_N, udr) = MB_Frame[MB_N][0];
    6672:	fe 2d       	mov	r31, r14
    6674:	ee 27       	eor	r30, r30
    6676:	e5 59       	subi	r30, 0x95	; 149
    6678:	f4 4f       	sbci	r31, 0xF4	; 244
    667a:	80 81       	ld	r24, Z
    667c:	8c 93       	st	X, r24
    667e:	97 01       	movw	r18, r14
    6680:	22 0f       	add	r18, r18
    6682:	33 1f       	adc	r19, r19
    6684:	c7 01       	movw	r24, r14
    6686:	88 0f       	add	r24, r24
    6688:	99 1f       	adc	r25, r25
    668a:	88 0f       	add	r24, r24
    668c:	99 1f       	adc	r25, r25
    668e:	88 0f       	add	r24, r24
    6690:	99 1f       	adc	r25, r25
    6692:	28 0f       	add	r18, r24
    6694:	39 1f       	adc	r19, r25
    6696:	2f 5f       	subi	r18, 0xFF	; 255
    6698:	3f 4f       	sbci	r19, 0xFF	; 255
    669a:	22 0f       	add	r18, r18
    669c:	33 1f       	adc	r19, r19
    669e:	2c 0d       	add	r18, r12
    66a0:	3d 1d       	adc	r19, r13
    66a2:	f9 01       	movw	r30, r18
    66a4:	a5 91       	lpm	r26, Z+
    66a6:	b4 91       	lpm	r27, Z+

		USART_Reg(MB_N, ucsra) |=(1<<6);	//Clear TxC pending interrupt		
    66a8:	8c 91       	ld	r24, X
    66aa:	80 64       	ori	r24, 0x40	; 64
    66ac:	8c 93       	st	X, r24
    66ae:	c5 01       	movw	r24, r10
    66b0:	8e 0d       	add	r24, r14
    66b2:	9f 1d       	adc	r25, r15
    66b4:	01 96       	adiw	r24, 0x01	; 1
    66b6:	88 0f       	add	r24, r24
    66b8:	99 1f       	adc	r25, r25
    66ba:	88 0f       	add	r24, r24
    66bc:	99 1f       	adc	r25, r25
    66be:	8c 0d       	add	r24, r12
    66c0:	9d 1d       	adc	r25, r13
    66c2:	fc 01       	movw	r30, r24
    66c4:	a5 91       	lpm	r26, Z+
    66c6:	b4 91       	lpm	r27, Z+
		USART_Reg(MB_N, ucsrb) |=(1<<5);
    66c8:	8c 91       	ld	r24, X
    66ca:	80 62       	ori	r24, 0x20	; 32
    66cc:	8c 93       	st	X, r24
	#elif defined (__AVR_ATxmega128A1__)
		USART_t *usart = prp(&MB_Port[MB_N].usart);
		usart->CTRLA = (usart->CTRLA &~USART_TXCINTLVL_gm) |USART_TXCINTLVL_HI_gc;
		usart->DATA = MB_Frame[MB_N][0];
	#endif
}
    66ce:	1f 91       	pop	r17
    66d0:	0f 91       	pop	r16
    66d2:	ff 90       	pop	r15
    66d4:	ef 90       	pop	r14
    66d6:	df 90       	pop	r13
    66d8:	cf 90       	pop	r12
    66da:	bf 90       	pop	r11
    66dc:	af 90       	pop	r10
    66de:	08 95       	ret

000066e0 <Modbus_RX>:

// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_RX(usart_t *usart)
{
    66e0:	cf 93       	push	r28
    66e2:	df 93       	push	r29
    66e4:	dc 01       	movw	r26, r24
    66e6:	ec e8       	ldi	r30, 0x8C	; 140
    66e8:	f0 e4       	ldi	r31, 0x40	; 64
    66ea:	85 91       	lpm	r24, Z+
    66ec:	94 91       	lpm	r25, Z+
// ~~~~~~~~~~~~~~~~~~~~~~
static uint8_t
MB_Port_N(usart_t *usart)
{
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Port[MB_N].usart_field)!=usart; MB_N++);
    66ee:	a8 17       	cp	r26, r24
    66f0:	b9 07       	cpc	r27, r25
    66f2:	09 f4       	brne	.+2      	; 0x66f6 <Modbus_RX+0x16>
    66f4:	6e c0       	rjmp	.+220    	; 0x67d2 <Modbus_RX+0xf2>
    66f6:	30 e0       	ldi	r19, 0x00	; 0
    66f8:	3f 5f       	subi	r19, 0xFF	; 255
    66fa:	c3 2f       	mov	r28, r19
    66fc:	d0 e0       	ldi	r29, 0x00	; 0
    66fe:	ce 01       	movw	r24, r28
    6700:	88 0f       	add	r24, r24
    6702:	99 1f       	adc	r25, r25
    6704:	88 0f       	add	r24, r24
    6706:	99 1f       	adc	r25, r25
    6708:	fc 01       	movw	r30, r24
    670a:	ee 0f       	add	r30, r30
    670c:	ff 1f       	adc	r31, r31
    670e:	ee 0f       	add	r30, r30
    6710:	ff 1f       	adc	r31, r31
    6712:	e8 0f       	add	r30, r24
    6714:	f9 1f       	adc	r31, r25
    6716:	e4 57       	subi	r30, 0x74	; 116
    6718:	ff 4b       	sbci	r31, 0xBF	; 191
    671a:	85 91       	lpm	r24, Z+
    671c:	94 91       	lpm	r25, Z+
    671e:	a8 17       	cp	r26, r24
    6720:	b9 07       	cpc	r27, r25
    6722:	51 f7       	brne	.-44     	; 0x66f8 <Modbus_RX+0x18>
// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_RX(usart_t *usart)
{
	uint8_t MB_N = MB_Port_N(usart);
	switch (MB_State[MB_N]) {
    6724:	fe 01       	movw	r30, r28
    6726:	ee 53       	subi	r30, 0x3E	; 62
    6728:	fa 4f       	sbci	r31, 0xFA	; 250
    672a:	80 81       	ld	r24, Z
    672c:	82 30       	cpi	r24, 0x02	; 2
    672e:	19 f1       	breq	.+70     	; 0x6776 <Modbus_RX+0x96>
    6730:	83 30       	cpi	r24, 0x03	; 3
    6732:	28 f0       	brcs	.+10     	; 0x673e <Modbus_RX+0x5e>
    6734:	86 30       	cpi	r24, 0x06	; 6
    6736:	d8 f0       	brcs	.+54     	; 0x676e <Modbus_RX+0x8e>
	case MB_Trans: case MB_Proc: 
	case MB_NoReply: // MB_NoReply    MB_Recept ..  MB_M_Cycle   MB_Trans
		usart_data(usart);
		break;
	}
}
    6738:	df 91       	pop	r29
    673a:	cf 91       	pop	r28
    673c:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_RX(usart_t *usart)
{
	uint8_t MB_N = MB_Port_N(usart);
	switch (MB_State[MB_N]) {
    673e:	88 23       	and	r24, r24
    6740:	f1 f4       	brne	.+60     	; 0x677e <Modbus_RX+0x9e>
	case MB_Initi:
		MB_Frame[MB_N][0] = usart_data(usart);
    6742:	8c 91       	ld	r24, X
    6744:	fc 2f       	mov	r31, r28
    6746:	ee 27       	eor	r30, r30
    6748:	e5 59       	subi	r30, 0x95	; 149
    674a:	f4 4f       	sbci	r31, 0xF4	; 244
    674c:	80 83       	st	Z, r24
    674e:	ce 01       	movw	r24, r28
    6750:	88 0f       	add	r24, r24
    6752:	99 1f       	adc	r25, r25
    6754:	8c 0f       	add	r24, r28
    6756:	9d 1f       	adc	r25, r29
    6758:	88 0f       	add	r24, r24
    675a:	99 1f       	adc	r25, r25
    675c:	8f 55       	subi	r24, 0x5F	; 95
    675e:	9f 4b       	sbci	r25, 0xBF	; 191
    6760:	fc 01       	movw	r30, r24
    6762:	a5 91       	lpm	r26, Z+
    6764:	b4 91       	lpm	r27, Z+
		break;
	case MB_Recept:
		/*if(TCNT2>=prb(&(BR_Tbl+MB_BitRate_RAM[MB_N])->Time15))
			MB_Err &=(1<<MB_N);*/
		MBRecept(MB_N);
		MB_ClearTimer(MB_N);
    6766:	1c 92       	st	X, r1
	case MB_Trans: case MB_Proc: 
	case MB_NoReply: // MB_NoReply    MB_Recept ..  MB_M_Cycle   MB_Trans
		usart_data(usart);
		break;
	}
}
    6768:	df 91       	pop	r29
    676a:	cf 91       	pop	r28
    676c:	08 95       	ret
		MBRecept(MB_N);
		MB_ClearTimer(MB_N);
		break;
	case MB_Trans: case MB_Proc: 
	case MB_NoReply: // MB_NoReply    MB_Recept ..  MB_M_Cycle   MB_Trans
		usart_data(usart);
    676e:	8c 91       	ld	r24, X
		break;
	}
}
    6770:	df 91       	pop	r29
    6772:	cf 91       	pop	r28
    6774:	08 95       	ret
		MB_StartTimer(MB_N);
		break;
	case MB_Recept:
		/*if(TCNT2>=prb(&(BR_Tbl+MB_BitRate_RAM[MB_N])->Time15))
			MB_Err &=(1<<MB_N);*/
		MBRecept(MB_N);
    6776:	83 2f       	mov	r24, r19
    6778:	0e 94 b0 32 	call	0x6560	; 0x6560 <MBRecept>
    677c:	e8 cf       	rjmp	.-48     	; 0x674e <Modbus_RX+0x6e>
// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_RX(usart_t *usart)
{
	uint8_t MB_N = MB_Port_N(usart);
	switch (MB_State[MB_N]) {
    677e:	81 30       	cpi	r24, 0x01	; 1
    6780:	d9 f6       	brne	.-74     	; 0x6738 <Modbus_RX+0x58>
	case MB_Initi:
		MB_Frame[MB_N][0] = usart_data(usart);
		MB_ClearTimer(MB_N);
		break;
	case MB_Idle: 
		MB_State[MB_N] = MB_Recept;
    6782:	82 e0       	ldi	r24, 0x02	; 2
    6784:	80 83       	st	Z, r24
		MB_Err &=~(1<<MB_N);
    6786:	81 e0       	ldi	r24, 0x01	; 1
    6788:	90 e0       	ldi	r25, 0x00	; 0
    678a:	0c 2e       	mov	r0, r28
    678c:	02 c0       	rjmp	.+4      	; 0x6792 <Modbus_RX+0xb2>
    678e:	88 0f       	add	r24, r24
    6790:	99 1f       	adc	r25, r25
    6792:	0a 94       	dec	r0
    6794:	e2 f7       	brpl	.-8      	; 0x678e <Modbus_RX+0xae>
    6796:	80 95       	com	r24
    6798:	20 91 d9 04 	lds	r18, 0x04D9
    679c:	28 23       	and	r18, r24
    679e:	20 93 d9 04 	sts	0x04D9, r18
		MB_Frame_Sz[MB_N] = 0;
    67a2:	fe 01       	movw	r30, r28
    67a4:	e7 5b       	subi	r30, 0xB7	; 183
    67a6:	f8 4f       	sbci	r31, 0xF8	; 248
    67a8:	10 82       	st	Z, r1
		MBRecept(MB_N);
    67aa:	83 2f       	mov	r24, r19
    67ac:	0e 94 b0 32 	call	0x6560	; 0x6560 <MBRecept>
    67b0:	ce 01       	movw	r24, r28
    67b2:	88 0f       	add	r24, r24
    67b4:	99 1f       	adc	r25, r25
    67b6:	8c 0f       	add	r24, r28
    67b8:	9d 1f       	adc	r25, r29
    67ba:	88 0f       	add	r24, r24
    67bc:	99 1f       	adc	r25, r25
    67be:	8b 55       	subi	r24, 0x5B	; 91
    67c0:	9f 4b       	sbci	r25, 0xBF	; 191
    67c2:	fc 01       	movw	r30, r24
    67c4:	25 91       	lpm	r18, Z+
    67c6:	34 91       	lpm	r19, Z+
		MB_StartTimer(MB_N);
    67c8:	f9 01       	movw	r30, r18
    67ca:	19 95       	eicall
	case MB_Trans: case MB_Proc: 
	case MB_NoReply: // MB_NoReply    MB_Recept ..  MB_M_Cycle   MB_Trans
		usart_data(usart);
		break;
	}
}
    67cc:	df 91       	pop	r29
    67ce:	cf 91       	pop	r28
    67d0:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~
static uint8_t
MB_Port_N(usart_t *usart)
{
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Port[MB_N].usart_field)!=usart; MB_N++);
    67d2:	30 e0       	ldi	r19, 0x00	; 0
    67d4:	c0 e0       	ldi	r28, 0x00	; 0
    67d6:	d0 e0       	ldi	r29, 0x00	; 0
    67d8:	a5 cf       	rjmp	.-182    	; 0x6724 <Modbus_RX+0x44>

000067da <CommErr>:
}

// ~~~~~~~~~~~~~~~~~~
uint8_t
CommErr(uint8_t MB_N)
{
    67da:	0f 93       	push	r16
    67dc:	1f 93       	push	r17
    67de:	cf 93       	push	r28
    67e0:	df 93       	push	r29
    67e2:	38 2f       	mov	r19, r24
	uint8_t Sz = MB_Frame_Sz[MB_N]-2;
    67e4:	c8 2f       	mov	r28, r24
    67e6:	d0 e0       	ldi	r29, 0x00	; 0
    67e8:	fe 01       	movw	r30, r28
    67ea:	e7 5b       	subi	r30, 0xB7	; 183
    67ec:	f8 4f       	sbci	r31, 0xF8	; 248
    67ee:	20 81       	ld	r18, Z
	uint8_t Err = MB_Err &(1<<MB_N) || MB_Frame_Sz[MB_N]<3 || *(uint16_t*)(MB_Frame[MB_N]+Sz)!=CRC(rrb, MB_Frame[MB_N], Sz);
    67f0:	80 91 d9 04 	lds	r24, 0x04D9
    67f4:	90 e0       	ldi	r25, 0x00	; 0
    67f6:	03 2e       	mov	r0, r19
    67f8:	02 c0       	rjmp	.+4      	; 0x67fe <CommErr+0x24>
    67fa:	95 95       	asr	r25
    67fc:	87 95       	ror	r24
    67fe:	0a 94       	dec	r0
    6800:	e2 f7       	brpl	.-8      	; 0x67fa <CommErr+0x20>
    6802:	80 ff       	sbrs	r24, 0
    6804:	29 c0       	rjmp	.+82     	; 0x6858 <CommErr+0x7e>
	if (Err) {
		MB_CPT[MB_N][1]++;
    6806:	fe 01       	movw	r30, r28
    6808:	ee 0f       	add	r30, r30
    680a:	ff 1f       	adc	r31, r31
    680c:	ee 0f       	add	r30, r30
    680e:	ff 1f       	adc	r31, r31
    6810:	ee 0f       	add	r30, r30
    6812:	ff 1f       	adc	r31, r31
    6814:	ee 0f       	add	r30, r30
    6816:	ff 1f       	adc	r31, r31
    6818:	e8 5c       	subi	r30, 0xC8	; 200
    681a:	f6 4f       	sbci	r31, 0xF6	; 246
    681c:	80 81       	ld	r24, Z
    681e:	91 81       	ldd	r25, Z+1	; 0x01
    6820:	01 96       	adiw	r24, 0x01	; 1
    6822:	91 83       	std	Z+1, r25	; 0x01
    6824:	80 83       	st	Z, r24
    6826:	ce 01       	movw	r24, r28
    6828:	88 0f       	add	r24, r24
    682a:	99 1f       	adc	r25, r25
    682c:	88 0f       	add	r24, r24
    682e:	99 1f       	adc	r25, r25
    6830:	9c 01       	movw	r18, r24
    6832:	22 0f       	add	r18, r18
    6834:	33 1f       	adc	r19, r19
    6836:	22 0f       	add	r18, r18
    6838:	33 1f       	adc	r19, r19
    683a:	28 0f       	add	r18, r24
    683c:	39 1f       	adc	r19, r25
    683e:	24 56       	subi	r18, 0x64	; 100
    6840:	3f 4b       	sbci	r19, 0xBF	; 191
    6842:	f9 01       	movw	r30, r18
    6844:	85 91       	lpm	r24, Z+
    6846:	94 91       	lpm	r25, Z+
		USART_Func(MB_N, LED_Err_On);
    6848:	fc 01       	movw	r30, r24
    684a:	19 95       	eicall
    684c:	81 e0       	ldi	r24, 0x01	; 1
	else {
		MB_CPT[MB_N][0]++;
		USART_Func(MB_N, LED_Err_Off);
	}
	return Err;
}
    684e:	df 91       	pop	r29
    6850:	cf 91       	pop	r28
    6852:	1f 91       	pop	r17
    6854:	0f 91       	pop	r16
    6856:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~
uint8_t
CommErr(uint8_t MB_N)
{
	uint8_t Sz = MB_Frame_Sz[MB_N]-2;
	uint8_t Err = MB_Err &(1<<MB_N) || MB_Frame_Sz[MB_N]<3 || *(uint16_t*)(MB_Frame[MB_N]+Sz)!=CRC(rrb, MB_Frame[MB_N], Sz);
    6858:	23 30       	cpi	r18, 0x03	; 3
    685a:	a8 f2       	brcs	.-86     	; 0x6806 <CommErr+0x2c>

// ~~~~~~~~~~~~~~~~~~
uint8_t
CommErr(uint8_t MB_N)
{
	uint8_t Sz = MB_Frame_Sz[MB_N]-2;
    685c:	22 50       	subi	r18, 0x02	; 2
	uint8_t Err = MB_Err &(1<<MB_N) || MB_Frame_Sz[MB_N]<3 || *(uint16_t*)(MB_Frame[MB_N]+Sz)!=CRC(rrb, MB_Frame[MB_N], Sz);
    685e:	73 2f       	mov	r23, r19
    6860:	60 e0       	ldi	r22, 0x00	; 0
    6862:	fb 01       	movw	r30, r22
    6864:	e2 0f       	add	r30, r18
    6866:	f1 1d       	adc	r31, r1
    6868:	e5 59       	subi	r30, 0x95	; 149
    686a:	f4 4f       	sbci	r31, 0xF4	; 244
    686c:	00 81       	ld	r16, Z
    686e:	11 81       	ldd	r17, Z+1	; 0x01
    6870:	65 59       	subi	r22, 0x95	; 149
    6872:	74 4f       	sbci	r23, 0xF4	; 244
    6874:	30 e0       	ldi	r19, 0x00	; 0
    6876:	40 e0       	ldi	r20, 0x00	; 0
    6878:	50 e0       	ldi	r21, 0x00	; 0
    687a:	8f e9       	ldi	r24, 0x9F	; 159
    687c:	92 e2       	ldi	r25, 0x22	; 34
    687e:	0e 94 12 23 	call	0x4624	; 0x4624 <CRC>
    6882:	08 17       	cp	r16, r24
    6884:	19 07       	cpc	r17, r25
    6886:	09 f0       	breq	.+2      	; 0x688a <CommErr+0xb0>
    6888:	be cf       	rjmp	.-132    	; 0x6806 <CommErr+0x2c>
	if (Err) {
		MB_CPT[MB_N][1]++;
		USART_Func(MB_N, LED_Err_On);
	}
	else {
		MB_CPT[MB_N][0]++;
    688a:	fe 01       	movw	r30, r28
    688c:	e2 95       	swap	r30
    688e:	f2 95       	swap	r31
    6890:	f0 7f       	andi	r31, 0xF0	; 240
    6892:	fe 27       	eor	r31, r30
    6894:	e0 7f       	andi	r30, 0xF0	; 240
    6896:	fe 27       	eor	r31, r30
    6898:	ea 5c       	subi	r30, 0xCA	; 202
    689a:	f6 4f       	sbci	r31, 0xF6	; 246
    689c:	80 81       	ld	r24, Z
    689e:	91 81       	ldd	r25, Z+1	; 0x01
    68a0:	01 96       	adiw	r24, 0x01	; 1
    68a2:	91 83       	std	Z+1, r25	; 0x01
    68a4:	80 83       	st	Z, r24
    68a6:	ce 01       	movw	r24, r28
    68a8:	88 0f       	add	r24, r24
    68aa:	99 1f       	adc	r25, r25
    68ac:	88 0f       	add	r24, r24
    68ae:	99 1f       	adc	r25, r25
    68b0:	9c 01       	movw	r18, r24
    68b2:	22 0f       	add	r18, r18
    68b4:	33 1f       	adc	r19, r19
    68b6:	22 0f       	add	r18, r18
    68b8:	33 1f       	adc	r19, r19
    68ba:	28 0f       	add	r18, r24
    68bc:	39 1f       	adc	r19, r25
    68be:	22 56       	subi	r18, 0x62	; 98
    68c0:	3f 4b       	sbci	r19, 0xBF	; 191
    68c2:	f9 01       	movw	r30, r18
    68c4:	85 91       	lpm	r24, Z+
    68c6:	94 91       	lpm	r25, Z+
		USART_Func(MB_N, LED_Err_Off);
    68c8:	fc 01       	movw	r30, r24
    68ca:	19 95       	eicall
    68cc:	80 e0       	ldi	r24, 0x00	; 0
    68ce:	bf cf       	rjmp	.-130    	; 0x684e <CommErr+0x74>

000068d0 <SetCRC_MB>:
}

// ~~~~~~~~~~~~~~~~~~~~
void
SetCRC_MB(uint8_t MB_N)
{
    68d0:	df 92       	push	r13
    68d2:	ef 92       	push	r14
    68d4:	ff 92       	push	r15
    68d6:	0f 93       	push	r16
    68d8:	1f 93       	push	r17
	uint8_t Sz = MB_Frame_Sz[MB_N]-2;
    68da:	e9 e4       	ldi	r30, 0x49	; 73
    68dc:	f7 e0       	ldi	r31, 0x07	; 7
    68de:	e8 0f       	add	r30, r24
    68e0:	f1 1d       	adc	r31, r1
    68e2:	d0 80       	ld	r13, Z
    68e4:	9e ef       	ldi	r25, 0xFE	; 254
    68e6:	d9 0e       	add	r13, r25
	*(uint16_t*)(MB_Frame[MB_N]+Sz) = CRC(rrb, MB_Frame[MB_N], Sz);
    68e8:	18 2f       	mov	r17, r24
    68ea:	00 e0       	ldi	r16, 0x00	; 0
    68ec:	8b e6       	ldi	r24, 0x6B	; 107
    68ee:	e8 2e       	mov	r14, r24
    68f0:	8b e0       	ldi	r24, 0x0B	; 11
    68f2:	f8 2e       	mov	r15, r24
    68f4:	b7 01       	movw	r22, r14
    68f6:	60 0f       	add	r22, r16
    68f8:	71 1f       	adc	r23, r17
    68fa:	2d 2d       	mov	r18, r13
    68fc:	30 e0       	ldi	r19, 0x00	; 0
    68fe:	40 e0       	ldi	r20, 0x00	; 0
    6900:	50 e0       	ldi	r21, 0x00	; 0
    6902:	8f e9       	ldi	r24, 0x9F	; 159
    6904:	92 e2       	ldi	r25, 0x22	; 34
    6906:	0e 94 12 23 	call	0x4624	; 0x4624 <CRC>
    690a:	0d 0d       	add	r16, r13
    690c:	11 1d       	adc	r17, r1
    690e:	e0 0e       	add	r14, r16
    6910:	f1 1e       	adc	r15, r17
    6912:	f7 01       	movw	r30, r14
    6914:	91 83       	std	Z+1, r25	; 0x01
    6916:	80 83       	st	Z, r24
}
    6918:	1f 91       	pop	r17
    691a:	0f 91       	pop	r16
    691c:	ff 90       	pop	r15
    691e:	ef 90       	pop	r14
    6920:	df 90       	pop	r13
    6922:	08 95       	ret

00006924 <MB_FrameReg>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
MB_FrameReg(uint8_t MB_N, uint8_t i)
{
	return MB_Frame[MB_N][i]<<8 | MB_Frame[MB_N][i+1];
    6924:	70 e0       	ldi	r23, 0x00	; 0
    6926:	ab e6       	ldi	r26, 0x6B	; 107
    6928:	bb e0       	ldi	r27, 0x0B	; 11
    692a:	f8 2f       	mov	r31, r24
    692c:	e0 e0       	ldi	r30, 0x00	; 0
    692e:	ea 0f       	add	r30, r26
    6930:	fb 1f       	adc	r31, r27
    6932:	e6 0f       	add	r30, r22
    6934:	f7 1f       	adc	r31, r23
    6936:	41 81       	ldd	r20, Z+1	; 0x01
    6938:	50 e0       	ldi	r21, 0x00	; 0
    693a:	38 2f       	mov	r19, r24
    693c:	20 e0       	ldi	r18, 0x00	; 0
    693e:	26 0f       	add	r18, r22
    6940:	37 1f       	adc	r19, r23
    6942:	a2 0f       	add	r26, r18
    6944:	b3 1f       	adc	r27, r19
    6946:	9c 91       	ld	r25, X
    6948:	80 e0       	ldi	r24, 0x00	; 0
    694a:	48 2b       	or	r20, r24
    694c:	59 2b       	or	r21, r25
}
    694e:	ca 01       	movw	r24, r20
    6950:	08 95       	ret

00006952 <MB_CPT_Clear>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~
void
MB_CPT_Clear(uint8_t MB_N)
{
    6952:	90 e0       	ldi	r25, 0x00	; 0
    6954:	20 e0       	ldi	r18, 0x00	; 0
    6956:	30 e0       	ldi	r19, 0x00	; 0
    6958:	88 0f       	add	r24, r24
    695a:	99 1f       	adc	r25, r25
    695c:	88 0f       	add	r24, r24
    695e:	99 1f       	adc	r25, r25
    6960:	88 0f       	add	r24, r24
    6962:	99 1f       	adc	r25, r25
	for (uint8_t i=0; i<8; MB_CPT[MB_N][i++]=0);
    6964:	fc 01       	movw	r30, r24
    6966:	e2 0f       	add	r30, r18
    6968:	f3 1f       	adc	r31, r19
    696a:	ee 0f       	add	r30, r30
    696c:	ff 1f       	adc	r31, r31
    696e:	ea 5c       	subi	r30, 0xCA	; 202
    6970:	f6 4f       	sbci	r31, 0xF6	; 246
    6972:	11 82       	std	Z+1, r1	; 0x01
    6974:	10 82       	st	Z, r1
    6976:	2f 5f       	subi	r18, 0xFF	; 255
    6978:	3f 4f       	sbci	r19, 0xFF	; 255
    697a:	28 30       	cpi	r18, 0x08	; 8
    697c:	31 05       	cpc	r19, r1
    697e:	91 f7       	brne	.-28     	; 0x6964 <MB_CPT_Clear+0x12>
}
    6980:	08 95       	ret

00006982 <MB_S_Timer_ISR>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_S_Timer_ISR(uint8_t MB_N)
{
    6982:	2f 92       	push	r2
    6984:	3f 92       	push	r3
    6986:	4f 92       	push	r4
    6988:	5f 92       	push	r5
    698a:	6f 92       	push	r6
    698c:	7f 92       	push	r7
    698e:	8f 92       	push	r8
    6990:	9f 92       	push	r9
    6992:	af 92       	push	r10
    6994:	bf 92       	push	r11
    6996:	cf 92       	push	r12
    6998:	df 92       	push	r13
    699a:	ef 92       	push	r14
    699c:	ff 92       	push	r15
    699e:	0f 93       	push	r16
    69a0:	1f 93       	push	r17
    69a2:	df 93       	push	r29
    69a4:	cf 93       	push	r28
    69a6:	cd b7       	in	r28, 0x3d	; 61
    69a8:	de b7       	in	r29, 0x3e	; 62
    69aa:	29 97       	sbiw	r28, 0x09	; 9
    69ac:	0f b6       	in	r0, 0x3f	; 63
    69ae:	f8 94       	cli
    69b0:	de bf       	out	0x3e, r29	; 62
    69b2:	0f be       	out	0x3f, r0	; 63
    69b4:	cd bf       	out	0x3d, r28	; 61
    69b6:	d8 2e       	mov	r13, r24
	switch (MB_State[MB_N]) {
    69b8:	28 2f       	mov	r18, r24
    69ba:	30 e0       	ldi	r19, 0x00	; 0
    69bc:	39 87       	std	Y+9, r19	; 0x09
    69be:	28 87       	std	Y+8, r18	; 0x08
    69c0:	89 01       	movw	r16, r18
    69c2:	0e 53       	subi	r16, 0x3E	; 62
    69c4:	1a 4f       	sbci	r17, 0xFA	; 250
    69c6:	d8 01       	movw	r26, r16
    69c8:	8c 91       	ld	r24, X
    69ca:	88 23       	and	r24, r24
    69cc:	b9 f1       	breq	.+110    	; 0x6a3c <MB_S_Timer_ISR+0xba>
    69ce:	82 30       	cpi	r24, 0x02	; 2
    69d0:	c9 f0       	breq	.+50     	; 0x6a04 <MB_S_Timer_ISR+0x82>
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
		MB_S_CtrlProc(MB_N);
		break;
	}
}
    69d2:	29 96       	adiw	r28, 0x09	; 9
    69d4:	0f b6       	in	r0, 0x3f	; 63
    69d6:	f8 94       	cli
    69d8:	de bf       	out	0x3e, r29	; 62
    69da:	0f be       	out	0x3f, r0	; 63
    69dc:	cd bf       	out	0x3d, r28	; 61
    69de:	cf 91       	pop	r28
    69e0:	df 91       	pop	r29
    69e2:	1f 91       	pop	r17
    69e4:	0f 91       	pop	r16
    69e6:	ff 90       	pop	r15
    69e8:	ef 90       	pop	r14
    69ea:	df 90       	pop	r13
    69ec:	cf 90       	pop	r12
    69ee:	bf 90       	pop	r11
    69f0:	af 90       	pop	r10
    69f2:	9f 90       	pop	r9
    69f4:	8f 90       	pop	r8
    69f6:	7f 90       	pop	r7
    69f8:	6f 90       	pop	r6
    69fa:	5f 90       	pop	r5
    69fc:	4f 90       	pop	r4
    69fe:	3f 90       	pop	r3
    6a00:	2f 90       	pop	r2
    6a02:	08 95       	ret
	switch (MB_State[MB_N]) {
	case MB_Initi:
		MB_State[MB_N] = MB_Idle;
		break;
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
    6a04:	84 e0       	ldi	r24, 0x04	; 4
    6a06:	d8 01       	movw	r26, r16
    6a08:	8c 93       	st	X, r24

// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
MB_S_CtrlProc(uint8_t MB_N)
{
	if (CommErr(MB_N)) {
    6a0a:	8d 2d       	mov	r24, r13
    6a0c:	0e 94 ed 33 	call	0x67da	; 0x67da <CommErr>
    6a10:	88 23       	and	r24, r24
    6a12:	a1 f4       	brne	.+40     	; 0x6a3c <MB_S_Timer_ISR+0xba>
		MB_State[MB_N] = MB_Idle;
		return;
	}
	if (MB_Frame[MB_N][0]!=0 && MB_Frame[MB_N][0]!=MB_NativeAddr[MB_N]) {
    6a14:	28 85       	ldd	r18, Y+8	; 0x08
    6a16:	39 85       	ldd	r19, Y+9	; 0x09
    6a18:	f2 2e       	mov	r15, r18
    6a1a:	ee 24       	eor	r14, r14
    6a1c:	f7 01       	movw	r30, r14
    6a1e:	e5 59       	subi	r30, 0x95	; 149
    6a20:	f4 4f       	sbci	r31, 0xF4	; 244
    6a22:	90 81       	ld	r25, Z
    6a24:	99 23       	and	r25, r25
    6a26:	71 f0       	breq	.+28     	; 0x6a44 <MB_S_Timer_ISR+0xc2>
    6a28:	f9 01       	movw	r30, r18
    6a2a:	e0 52       	subi	r30, 0x20	; 32
    6a2c:	fa 4f       	sbci	r31, 0xFA	; 250
    6a2e:	80 81       	ld	r24, Z
    6a30:	98 17       	cp	r25, r24
    6a32:	41 f0       	breq	.+16     	; 0x6a44 <MB_S_Timer_ISR+0xc2>
		MB_State[MB_N] = MB_Idle;
    6a34:	81 e0       	ldi	r24, 0x01	; 1
    6a36:	d8 01       	movw	r26, r16
    6a38:	8c 93       	st	X, r24
    6a3a:	cb cf       	rjmp	.-106    	; 0x69d2 <MB_S_Timer_ISR+0x50>
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
MB_S_CtrlProc(uint8_t MB_N)
{
	if (CommErr(MB_N)) {
		MB_State[MB_N] = MB_Idle;
    6a3c:	81 e0       	ldi	r24, 0x01	; 1
    6a3e:	f8 01       	movw	r30, r16
    6a40:	80 83       	st	Z, r24
    6a42:	c7 cf       	rjmp	.-114    	; 0x69d2 <MB_S_Timer_ISR+0x50>
    6a44:	28 84       	ldd	r2, Y+8	; 0x08
    6a46:	39 84       	ldd	r3, Y+9	; 0x09
    6a48:	22 0c       	add	r2, r2
    6a4a:	33 1c       	adc	r3, r3
    6a4c:	22 0c       	add	r2, r2
    6a4e:	33 1c       	adc	r3, r3
    6a50:	51 01       	movw	r10, r2
    6a52:	aa 0c       	add	r10, r10
    6a54:	bb 1c       	adc	r11, r11
    6a56:	aa 0c       	add	r10, r10
    6a58:	bb 1c       	adc	r11, r11
    6a5a:	a2 0c       	add	r10, r2
    6a5c:	b3 1c       	adc	r11, r3
    6a5e:	ea e9       	ldi	r30, 0x9A	; 154
    6a60:	f0 e4       	ldi	r31, 0x40	; 64
    6a62:	ae 0e       	add	r10, r30
    6a64:	bf 1e       	adc	r11, r31
    6a66:	f5 01       	movw	r30, r10
    6a68:	25 91       	lpm	r18, Z+
    6a6a:	34 91       	lpm	r19, Z+
	}
	if (MB_Frame[MB_N][0]!=0 && MB_Frame[MB_N][0]!=MB_NativeAddr[MB_N]) {
		MB_State[MB_N] = MB_Idle;
		return;
	}
	USART_Func(MB_N, LED);
    6a6c:	f9 01       	movw	r30, r18
    6a6e:	19 95       	eicall
	MB_CPT[MB_N][3]++;
    6a70:	68 84       	ldd	r6, Y+8	; 0x08
    6a72:	79 84       	ldd	r7, Y+9	; 0x09
    6a74:	62 94       	swap	r6
    6a76:	72 94       	swap	r7
    6a78:	b0 ef       	ldi	r27, 0xF0	; 240
    6a7a:	7b 22       	and	r7, r27
    6a7c:	76 24       	eor	r7, r6
    6a7e:	6b 22       	and	r6, r27
    6a80:	76 24       	eor	r7, r6
    6a82:	f3 01       	movw	r30, r6
    6a84:	ea 5c       	subi	r30, 0xCA	; 202
    6a86:	f6 4f       	sbci	r31, 0xF6	; 246
    6a88:	86 81       	ldd	r24, Z+6	; 0x06
    6a8a:	97 81       	ldd	r25, Z+7	; 0x07
    6a8c:	01 96       	adiw	r24, 0x01	; 1
    6a8e:	97 83       	std	Z+7, r25	; 0x07
    6a90:	86 83       	std	Z+6, r24	; 0x06

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
MB_FrameReg(uint8_t MB_N, uint8_t i)
{
	return MB_Frame[MB_N][i]<<8 | MB_Frame[MB_N][i+1];
    6a92:	68 85       	ldd	r22, Y+8	; 0x08
    6a94:	79 85       	ldd	r23, Y+9	; 0x09
    6a96:	76 95       	lsr	r23
    6a98:	76 2f       	mov	r23, r22
    6a9a:	66 27       	eor	r22, r22
    6a9c:	77 95       	ror	r23
    6a9e:	67 95       	ror	r22
    6aa0:	db 01       	movw	r26, r22
    6aa2:	aa 0f       	add	r26, r26
    6aa4:	bb 1f       	adc	r27, r27
    6aa6:	a3 59       	subi	r26, 0x93	; 147
    6aa8:	b4 4f       	sbci	r27, 0xF4	; 244
    6aaa:	9c 91       	ld	r25, X
    6aac:	80 e0       	ldi	r24, 0x00	; 0
    6aae:	a7 01       	movw	r20, r14
    6ab0:	45 59       	subi	r20, 0x95	; 149
    6ab2:	54 4f       	sbci	r21, 0xF4	; 244
    6ab4:	fa 01       	movw	r30, r20
    6ab6:	23 81       	ldd	r18, Z+3	; 0x03
    6ab8:	82 2e       	mov	r8, r18
    6aba:	99 24       	eor	r9, r9
    6abc:	88 2a       	or	r8, r24
    6abe:	99 2a       	or	r9, r25
inline static uint8_t
Process(uint8_t MB_N)
{
	uint8_t Err;
	uint16_t StartAddr = MB_FrameReg(MB_N, 2);
	switch (MB_Frame[MB_N][1]) {
    6ac0:	31 81       	ldd	r19, Z+1	; 0x01
    6ac2:	35 30       	cpi	r19, 0x05	; 5
    6ac4:	08 f0       	brcs	.+2      	; 0x6ac8 <MB_S_Timer_ISR+0x146>
    6ac6:	52 c0       	rjmp	.+164    	; 0x6b6c <MB_S_Timer_ISR+0x1ea>
    6ac8:	33 30       	cpi	r19, 0x03	; 3
    6aca:	08 f4       	brcc	.+2      	; 0x6ace <MB_S_Timer_ISR+0x14c>
    6acc:	72 c0       	rjmp	.+228    	; 0x6bb2 <MB_S_Timer_ISR+0x230>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_ReadReg(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame[MB_N][0]==0)
    6ace:	fa 01       	movw	r30, r20
    6ad0:	80 81       	ld	r24, Z
    6ad2:	88 23       	and	r24, r24
    6ad4:	09 f4       	brne	.+2      	; 0x6ad8 <MB_S_Timer_ISR+0x156>
    6ad6:	5c c0       	rjmp	.+184    	; 0x6b90 <MB_S_Timer_ISR+0x20e>
		return 0xFF;
	if (MB_Frame_Sz[MB_N]!=8)
    6ad8:	29 e4       	ldi	r18, 0x49	; 73
    6ada:	42 2e       	mov	r4, r18
    6adc:	27 e0       	ldi	r18, 0x07	; 7
    6ade:	52 2e       	mov	r5, r18
    6ae0:	88 85       	ldd	r24, Y+8	; 0x08
    6ae2:	99 85       	ldd	r25, Y+9	; 0x09
    6ae4:	48 0e       	add	r4, r24
    6ae6:	59 1e       	adc	r5, r25
    6ae8:	f2 01       	movw	r30, r4
    6aea:	80 81       	ld	r24, Z
    6aec:	88 30       	cpi	r24, 0x08	; 8
    6aee:	09 f4       	brne	.+2      	; 0x6af2 <MB_S_Timer_ISR+0x170>
    6af0:	27 c2       	rjmp	.+1102   	; 0x6f40 <MB_S_Timer_ISR+0x5be>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_PresetSingle(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame_Sz[MB_N]!=8)
		return MB_Frame[MB_N][2]=IllegData;
    6af2:	83 e0       	ldi	r24, 0x03	; 3
    6af4:	8c 93       	st	X, r24
    6af6:	93 e0       	ldi	r25, 0x03	; 3
		break;
	default:
		Err = MB_Frame[MB_N][2] = IllegFunc;
		break;
	}
	if (MB_Frame[MB_N][0]) {
    6af8:	f7 01       	movw	r30, r14
    6afa:	e5 59       	subi	r30, 0x95	; 149
    6afc:	f4 4f       	sbci	r31, 0xF4	; 244
    6afe:	80 81       	ld	r24, Z
    6b00:	88 23       	and	r24, r24
    6b02:	81 f0       	breq	.+32     	; 0x6b24 <MB_S_Timer_ISR+0x1a2>
		if (Err) {
    6b04:	99 23       	and	r25, r25
    6b06:	49 f0       	breq	.+18     	; 0x6b1a <MB_S_Timer_ISR+0x198>
			MB_Frame[MB_N][1] |=(1<<7);
    6b08:	81 81       	ldd	r24, Z+1	; 0x01
    6b0a:	80 68       	ori	r24, 0x80	; 128
    6b0c:	81 83       	std	Z+1, r24	; 0x01
			MB_Frame_Sz[MB_N] = 5;
    6b0e:	e8 85       	ldd	r30, Y+8	; 0x08
    6b10:	f9 85       	ldd	r31, Y+9	; 0x09
    6b12:	e7 5b       	subi	r30, 0xB7	; 183
    6b14:	f8 4f       	sbci	r31, 0xF8	; 248
    6b16:	85 e0       	ldi	r24, 0x05	; 5
    6b18:	80 83       	st	Z, r24
		}
		SetCRC_MB(MB_N);
    6b1a:	8d 2d       	mov	r24, r13
    6b1c:	9d 83       	std	Y+5, r25	; 0x05
    6b1e:	0e 94 68 34 	call	0x68d0	; 0x68d0 <SetCRC_MB>
    6b22:	9d 81       	ldd	r25, Y+5	; 0x05
		MB_State[MB_N] = MB_Idle;
		return;
	}
	USART_Func(MB_N, LED);
	MB_CPT[MB_N][3]++;
	if (Process(MB_N))
    6b24:	99 23       	and	r25, r25
    6b26:	a1 f5       	brne	.+104    	; 0x6b90 <MB_S_Timer_ISR+0x20e>
		MB_CPT[MB_N][2]++;
	if (MB_Frame[MB_N][0])
    6b28:	2b e6       	ldi	r18, 0x6B	; 107
    6b2a:	3b e0       	ldi	r19, 0x0B	; 11
    6b2c:	e2 0e       	add	r14, r18
    6b2e:	f3 1e       	adc	r15, r19
    6b30:	d7 01       	movw	r26, r14
    6b32:	8c 91       	ld	r24, X
    6b34:	88 23       	and	r24, r24
    6b36:	c9 f5       	brne	.+114    	; 0x6baa <MB_S_Timer_ISR+0x228>
		MB_Transm(MB_N);
	else {
		MB_CPT[MB_N][4]++;
    6b38:	e8 85       	ldd	r30, Y+8	; 0x08
    6b3a:	f9 85       	ldd	r31, Y+9	; 0x09
    6b3c:	ee 0f       	add	r30, r30
    6b3e:	ff 1f       	adc	r31, r31
    6b40:	ee 0f       	add	r30, r30
    6b42:	ff 1f       	adc	r31, r31
    6b44:	ee 0f       	add	r30, r30
    6b46:	ff 1f       	adc	r31, r31
    6b48:	ee 0f       	add	r30, r30
    6b4a:	ff 1f       	adc	r31, r31
    6b4c:	e2 5c       	subi	r30, 0xC2	; 194
    6b4e:	f6 4f       	sbci	r31, 0xF6	; 246
    6b50:	80 81       	ld	r24, Z
    6b52:	91 81       	ldd	r25, Z+1	; 0x01
    6b54:	01 96       	adiw	r24, 0x01	; 1
    6b56:	91 83       	std	Z+1, r25	; 0x01
    6b58:	80 83       	st	Z, r24
		MB_State[MB_N] = MB_Idle;
    6b5a:	81 e0       	ldi	r24, 0x01	; 1
    6b5c:	f8 01       	movw	r30, r16
    6b5e:	80 83       	st	Z, r24
    6b60:	f5 01       	movw	r30, r10
    6b62:	85 91       	lpm	r24, Z+
    6b64:	94 91       	lpm	r25, Z+
		USART_Func(MB_N, LED);
    6b66:	fc 01       	movw	r30, r24
    6b68:	19 95       	eicall
    6b6a:	33 cf       	rjmp	.-410    	; 0x69d2 <MB_S_Timer_ISR+0x50>
inline static uint8_t
Process(uint8_t MB_N)
{
	uint8_t Err;
	uint16_t StartAddr = MB_FrameReg(MB_N, 2);
	switch (MB_Frame[MB_N][1]) {
    6b6c:	3f 30       	cpi	r19, 0x0F	; 15
    6b6e:	09 f4       	brne	.+2      	; 0x6b72 <MB_S_Timer_ISR+0x1f0>
    6b70:	1e c1       	rjmp	.+572    	; 0x6dae <MB_S_Timer_ISR+0x42c>
    6b72:	30 31       	cpi	r19, 0x10	; 16
    6b74:	09 f4       	brne	.+2      	; 0x6b78 <MB_S_Timer_ISR+0x1f6>
    6b76:	fc c0       	rjmp	.+504    	; 0x6d70 <MB_S_Timer_ISR+0x3ee>
    6b78:	36 30       	cpi	r19, 0x06	; 6
    6b7a:	09 f4       	brne	.+2      	; 0x6b7e <MB_S_Timer_ISR+0x1fc>
    6b7c:	bd c0       	rjmp	.+378    	; 0x6cf8 <MB_S_Timer_ISR+0x376>
		break;
	case 0x10:
		Err = MB_S_Preset(MB_N, StartAddr);
		break;
	default:
		Err = MB_Frame[MB_N][2] = IllegFunc;
    6b7e:	66 0f       	add	r22, r22
    6b80:	77 1f       	adc	r23, r23
    6b82:	63 59       	subi	r22, 0x93	; 147
    6b84:	74 4f       	sbci	r23, 0xF4	; 244
    6b86:	81 e0       	ldi	r24, 0x01	; 1
    6b88:	fb 01       	movw	r30, r22
    6b8a:	80 83       	st	Z, r24
    6b8c:	91 e0       	ldi	r25, 0x01	; 1
    6b8e:	b4 cf       	rjmp	.-152    	; 0x6af8 <MB_S_Timer_ISR+0x176>
		return;
	}
	USART_Func(MB_N, LED);
	MB_CPT[MB_N][3]++;
	if (Process(MB_N))
		MB_CPT[MB_N][2]++;
    6b90:	f1 01       	movw	r30, r2
    6b92:	ee 0f       	add	r30, r30
    6b94:	ff 1f       	adc	r31, r31
    6b96:	ee 0f       	add	r30, r30
    6b98:	ff 1f       	adc	r31, r31
    6b9a:	e6 5c       	subi	r30, 0xC6	; 198
    6b9c:	f6 4f       	sbci	r31, 0xF6	; 246
    6b9e:	80 81       	ld	r24, Z
    6ba0:	91 81       	ldd	r25, Z+1	; 0x01
    6ba2:	01 96       	adiw	r24, 0x01	; 1
    6ba4:	91 83       	std	Z+1, r25	; 0x01
    6ba6:	80 83       	st	Z, r24
    6ba8:	bf cf       	rjmp	.-130    	; 0x6b28 <MB_S_Timer_ISR+0x1a6>
	if (MB_Frame[MB_N][0])
		MB_Transm(MB_N);
    6baa:	8d 2d       	mov	r24, r13
    6bac:	0e 94 09 33 	call	0x6612	; 0x6612 <MB_Transm>
    6bb0:	10 cf       	rjmp	.-480    	; 0x69d2 <MB_S_Timer_ISR+0x50>
inline static uint8_t
Process(uint8_t MB_N)
{
	uint8_t Err;
	uint16_t StartAddr = MB_FrameReg(MB_N, 2);
	switch (MB_Frame[MB_N][1]) {
    6bb2:	31 30       	cpi	r19, 0x01	; 1
    6bb4:	20 f3       	brcs	.-56     	; 0x6b7e <MB_S_Timer_ISR+0x1fc>
*/
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_ReadDiscr(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame[MB_N][0]==0)
    6bb6:	fa 01       	movw	r30, r20
    6bb8:	80 81       	ld	r24, Z
    6bba:	88 23       	and	r24, r24
    6bbc:	49 f3       	breq	.-46     	; 0x6b90 <MB_S_Timer_ISR+0x20e>
		return 0xFF;
	if (MB_Frame_Sz[MB_N]!=8)
    6bbe:	e9 e4       	ldi	r30, 0x49	; 73
    6bc0:	4e 2e       	mov	r4, r30
    6bc2:	e7 e0       	ldi	r30, 0x07	; 7
    6bc4:	5e 2e       	mov	r5, r30
    6bc6:	88 85       	ldd	r24, Y+8	; 0x08
    6bc8:	99 85       	ldd	r25, Y+9	; 0x09
    6bca:	48 0e       	add	r4, r24
    6bcc:	59 1e       	adc	r5, r25
    6bce:	f2 01       	movw	r30, r4
    6bd0:	80 81       	ld	r24, Z
    6bd2:	88 30       	cpi	r24, 0x08	; 8
    6bd4:	09 f0       	breq	.+2      	; 0x6bd8 <MB_S_Timer_ISR+0x256>
    6bd6:	8d cf       	rjmp	.-230    	; 0x6af2 <MB_S_Timer_ISR+0x170>
    6bd8:	88 85       	ldd	r24, Y+8	; 0x08
    6bda:	99 85       	ldd	r25, Y+9	; 0x09
    6bdc:	f8 2f       	mov	r31, r24
    6bde:	ee 27       	eor	r30, r30
    6be0:	e1 59       	subi	r30, 0x91	; 145
    6be2:	f4 4f       	sbci	r31, 0xF4	; 244
    6be4:	90 81       	ld	r25, Z
    6be6:	80 e0       	ldi	r24, 0x00	; 0
    6be8:	da 01       	movw	r26, r20
    6bea:	15 96       	adiw	r26, 0x05	; 5
    6bec:	2c 91       	ld	r18, X
    6bee:	a2 2f       	mov	r26, r18
    6bf0:	b0 e0       	ldi	r27, 0x00	; 0
    6bf2:	a8 2b       	or	r26, r24
    6bf4:	b9 2b       	or	r27, r25
		return MB_Frame[MB_N][2]=IllegData;
	uint16_t Qt = MB_FrameReg(MB_N, 4);
	if (StartAddr+Qt>(MB_Frame[MB_N][1]==1?prw(&Modbus_Map[MB_N].Coil_Qt):prw(&Modbus_Map[MB_N].Input_Qt)))
    6bf6:	31 30       	cpi	r19, 0x01	; 1
    6bf8:	09 f4       	brne	.+2      	; 0x6bfc <MB_S_Timer_ISR+0x27a>
    6bfa:	44 c2       	rjmp	.+1160   	; 0x7084 <MB_S_Timer_ISR+0x702>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    6bfc:	f3 01       	movw	r30, r6
    6bfe:	ea 5c       	subi	r30, 0xCA	; 202
    6c00:	fc 4f       	sbci	r31, 0xFC	; 252
    6c02:	45 91       	lpm	r20, Z+
    6c04:	54 91       	lpm	r21, Z+
    6c06:	cd 01       	movw	r24, r26
    6c08:	88 0d       	add	r24, r8
    6c0a:	99 1d       	adc	r25, r9
    6c0c:	48 17       	cp	r20, r24
    6c0e:	59 07       	cpc	r21, r25
    6c10:	08 f4       	brcc	.+2      	; 0x6c14 <MB_S_Timer_ISR+0x292>
    6c12:	8d c1       	rjmp	.+794    	; 0x6f2e <MB_S_Timer_ISR+0x5ac>
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
    6c14:	31 30       	cpi	r19, 0x01	; 1
    6c16:	09 f4       	brne	.+2      	; 0x6c1a <MB_S_Timer_ISR+0x298>
    6c18:	4a c2       	rjmp	.+1172   	; 0x70ae <MB_S_Timer_ISR+0x72c>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6c1a:	f1 01       	movw	r30, r2
    6c1c:	ee 0f       	add	r30, r30
    6c1e:	ff 1f       	adc	r31, r31
    6c20:	ee 0f       	add	r30, r30
    6c22:	ff 1f       	adc	r31, r31
    6c24:	ec 5c       	subi	r30, 0xCC	; 204
    6c26:	fc 4f       	sbci	r31, 0xFC	; 252
    6c28:	85 91       	lpm	r24, Z+
    6c2a:	94 91       	lpm	r25, Z+
    6c2c:	28 2f       	mov	r18, r24
    6c2e:	89 2f       	mov	r24, r25
    6c30:	62 2e       	mov	r6, r18
    6c32:	78 2e       	mov	r7, r24
	MB_Frame[MB_N][2] = Qt/8+(Qt%8>0);
    6c34:	20 e0       	ldi	r18, 0x00	; 0
    6c36:	cd 01       	movw	r24, r26
    6c38:	87 70       	andi	r24, 0x07	; 7
    6c3a:	90 70       	andi	r25, 0x00	; 0
    6c3c:	89 2b       	or	r24, r25
    6c3e:	09 f0       	breq	.+2      	; 0x6c42 <MB_S_Timer_ISR+0x2c0>
    6c40:	21 e0       	ldi	r18, 0x01	; 1
    6c42:	cd 01       	movw	r24, r26
    6c44:	96 95       	lsr	r25
    6c46:	87 95       	ror	r24
    6c48:	96 95       	lsr	r25
    6c4a:	87 95       	ror	r24
    6c4c:	96 95       	lsr	r25
    6c4e:	87 95       	ror	r24
    6c50:	82 0f       	add	r24, r18
    6c52:	66 0f       	add	r22, r22
    6c54:	77 1f       	adc	r23, r23
    6c56:	63 59       	subi	r22, 0x93	; 147
    6c58:	74 4f       	sbci	r23, 0xF4	; 244
    6c5a:	fb 01       	movw	r30, r22
    6c5c:	80 83       	st	Z, r24
	MB_Frame_Sz[MB_N] = MB_Frame[MB_N][2]+5;
    6c5e:	8b 5f       	subi	r24, 0xFB	; 251
    6c60:	f2 01       	movw	r30, r4
    6c62:	80 83       	st	Z, r24
	for (uint8_t i=0; i<Qt; i++) {
    6c64:	10 97       	sbiw	r26, 0x00	; 0
    6c66:	09 f4       	brne	.+2      	; 0x6c6a <MB_S_Timer_ISR+0x2e8>
    6c68:	22 c1       	rjmp	.+580    	; 0x6eae <MB_S_Timer_ISR+0x52c>
    6c6a:	60 e0       	ldi	r22, 0x00	; 0
    6c6c:	20 e0       	ldi	r18, 0x00	; 0
    6c6e:	30 e0       	ldi	r19, 0x00	; 0
    6c70:	80 e0       	ldi	r24, 0x00	; 0
    6c72:	90 e0       	ldi	r25, 0x00	; 0
		uint16_t j = StartAddr+i;
		uint8_t Byte=3+i/8, Bit=1<<i%8;
    6c74:	e1 e0       	ldi	r30, 0x01	; 1
    6c76:	4e 2e       	mov	r4, r30
    6c78:	51 2c       	mov	r5, r1
    6c7a:	10 c0       	rjmp	.+32     	; 0x6c9c <MB_S_Timer_ISR+0x31a>
		if (Discr[j/8] &(1<<j%8))
			MB_Frame[MB_N][Byte] |=Bit;
    6c7c:	f7 01       	movw	r30, r14
    6c7e:	e4 0f       	add	r30, r20
    6c80:	f1 1d       	adc	r31, r1
    6c82:	e5 59       	subi	r30, 0x95	; 149
    6c84:	f4 4f       	sbci	r31, 0xF4	; 244
    6c86:	80 81       	ld	r24, Z
    6c88:	85 2b       	or	r24, r21
    6c8a:	80 83       	st	Z, r24
	if (StartAddr+Qt>(MB_Frame[MB_N][1]==1?prw(&Modbus_Map[MB_N].Coil_Qt):prw(&Modbus_Map[MB_N].Input_Qt)))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
	MB_Frame[MB_N][2] = Qt/8+(Qt%8>0);
	MB_Frame_Sz[MB_N] = MB_Frame[MB_N][2]+5;
	for (uint8_t i=0; i<Qt; i++) {
    6c8c:	6f 5f       	subi	r22, 0xFF	; 255
    6c8e:	86 2f       	mov	r24, r22
    6c90:	90 e0       	ldi	r25, 0x00	; 0
    6c92:	9c 01       	movw	r18, r24
    6c94:	8a 17       	cp	r24, r26
    6c96:	9b 07       	cpc	r25, r27
    6c98:	08 f0       	brcs	.+2      	; 0x6c9c <MB_S_Timer_ISR+0x31a>
    6c9a:	09 c1       	rjmp	.+530    	; 0x6eae <MB_S_Timer_ISR+0x52c>
		uint16_t j = StartAddr+i;
    6c9c:	28 0d       	add	r18, r8
    6c9e:	39 1d       	adc	r19, r9
		uint8_t Byte=3+i/8, Bit=1<<i%8;
    6ca0:	46 2f       	mov	r20, r22
    6ca2:	46 95       	lsr	r20
    6ca4:	46 95       	lsr	r20
    6ca6:	46 95       	lsr	r20
    6ca8:	4d 5f       	subi	r20, 0xFD	; 253
    6caa:	87 70       	andi	r24, 0x07	; 7
    6cac:	90 70       	andi	r25, 0x00	; 0
    6cae:	f2 01       	movw	r30, r4
    6cb0:	02 c0       	rjmp	.+4      	; 0x6cb6 <MB_S_Timer_ISR+0x334>
    6cb2:	ee 0f       	add	r30, r30
    6cb4:	ff 1f       	adc	r31, r31
    6cb6:	8a 95       	dec	r24
    6cb8:	e2 f7       	brpl	.-8      	; 0x6cb2 <MB_S_Timer_ISR+0x330>
    6cba:	5e 2f       	mov	r21, r30
		if (Discr[j/8] &(1<<j%8))
    6cbc:	f9 01       	movw	r30, r18
    6cbe:	f6 95       	lsr	r31
    6cc0:	e7 95       	ror	r30
    6cc2:	f6 95       	lsr	r31
    6cc4:	e7 95       	ror	r30
    6cc6:	f6 95       	lsr	r31
    6cc8:	e7 95       	ror	r30
    6cca:	e6 0d       	add	r30, r6
    6ccc:	f7 1d       	adc	r31, r7
    6cce:	80 81       	ld	r24, Z
    6cd0:	90 e0       	ldi	r25, 0x00	; 0
    6cd2:	27 70       	andi	r18, 0x07	; 7
    6cd4:	30 70       	andi	r19, 0x00	; 0
    6cd6:	02 c0       	rjmp	.+4      	; 0x6cdc <MB_S_Timer_ISR+0x35a>
    6cd8:	95 95       	asr	r25
    6cda:	87 95       	ror	r24
    6cdc:	2a 95       	dec	r18
    6cde:	e2 f7       	brpl	.-8      	; 0x6cd8 <MB_S_Timer_ISR+0x356>
    6ce0:	80 fd       	sbrc	r24, 0
    6ce2:	cc cf       	rjmp	.-104    	; 0x6c7c <MB_S_Timer_ISR+0x2fa>
			MB_Frame[MB_N][Byte] |=Bit;
		else
			MB_Frame[MB_N][Byte] &=~Bit;
    6ce4:	f7 01       	movw	r30, r14
    6ce6:	e4 0f       	add	r30, r20
    6ce8:	f1 1d       	adc	r31, r1
    6cea:	e5 59       	subi	r30, 0x95	; 149
    6cec:	f4 4f       	sbci	r31, 0xF4	; 244
    6cee:	50 95       	com	r21
    6cf0:	80 81       	ld	r24, Z
    6cf2:	58 23       	and	r21, r24
    6cf4:	50 83       	st	Z, r21
    6cf6:	ca cf       	rjmp	.-108    	; 0x6c8c <MB_S_Timer_ISR+0x30a>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_PresetSingle(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame_Sz[MB_N]!=8)
    6cf8:	68 85       	ldd	r22, Y+8	; 0x08
    6cfa:	79 85       	ldd	r23, Y+9	; 0x09
    6cfc:	67 5b       	subi	r22, 0xB7	; 183
    6cfe:	78 4f       	sbci	r23, 0xF8	; 248
    6d00:	fb 01       	movw	r30, r22
    6d02:	c0 80       	ld	r12, Z
    6d04:	f8 e0       	ldi	r31, 0x08	; 8
    6d06:	cf 16       	cp	r12, r31
    6d08:	09 f0       	breq	.+2      	; 0x6d0c <MB_S_Timer_ISR+0x38a>
    6d0a:	f3 ce       	rjmp	.-538    	; 0x6af2 <MB_S_Timer_ISR+0x170>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    6d0c:	f3 01       	movw	r30, r6
    6d0e:	e6 5c       	subi	r30, 0xC6	; 198
    6d10:	fc 4f       	sbci	r31, 0xFC	; 252
    6d12:	25 91       	lpm	r18, Z+
    6d14:	34 91       	lpm	r19, Z+
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+1>prw(&Modbus_Map[MB_N].HoldReg_Qt))
    6d16:	c4 01       	movw	r24, r8
    6d18:	01 96       	adiw	r24, 0x01	; 1
    6d1a:	28 17       	cp	r18, r24
    6d1c:	39 07       	cpc	r19, r25
    6d1e:	08 f4       	brcc	.+2      	; 0x6d22 <MB_S_Timer_ISR+0x3a0>
    6d20:	02 c1       	rjmp	.+516    	; 0x6f26 <MB_S_Timer_ISR+0x5a4>
		return MB_Frame[MB_N][2]=IllegAddr;
	MB_Frame_Sz[MB_N] = 8;
    6d22:	db 01       	movw	r26, r22
    6d24:	cc 92       	st	X, r12

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6d26:	e8 85       	ldd	r30, Y+8	; 0x08
    6d28:	f9 85       	ldd	r31, Y+9	; 0x09
    6d2a:	ee 0f       	add	r30, r30
    6d2c:	ff 1f       	adc	r31, r31
    6d2e:	ee 0f       	add	r30, r30
    6d30:	ff 1f       	adc	r31, r31
    6d32:	ee 0f       	add	r30, r30
    6d34:	ff 1f       	adc	r31, r31
    6d36:	ee 0f       	add	r30, r30
    6d38:	ff 1f       	adc	r31, r31
    6d3a:	e8 5c       	subi	r30, 0xC8	; 200
    6d3c:	fc 4f       	sbci	r31, 0xFC	; 252
    6d3e:	85 91       	lpm	r24, Z+
    6d40:	94 91       	lpm	r25, Z+
	*((uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+StartAddr) = MB_FrameReg(MB_N, 4);
    6d42:	88 0c       	add	r8, r8
    6d44:	99 1c       	adc	r9, r9
    6d46:	88 0e       	add	r8, r24
    6d48:	99 1e       	adc	r9, r25
    6d4a:	28 85       	ldd	r18, Y+8	; 0x08
    6d4c:	39 85       	ldd	r19, Y+9	; 0x09
    6d4e:	f2 2f       	mov	r31, r18
    6d50:	ee 27       	eor	r30, r30
    6d52:	e1 59       	subi	r30, 0x91	; 145
    6d54:	f4 4f       	sbci	r31, 0xF4	; 244
    6d56:	90 81       	ld	r25, Z
    6d58:	80 e0       	ldi	r24, 0x00	; 0
    6d5a:	da 01       	movw	r26, r20
    6d5c:	15 96       	adiw	r26, 0x05	; 5
    6d5e:	2c 91       	ld	r18, X
    6d60:	30 e0       	ldi	r19, 0x00	; 0
    6d62:	82 2b       	or	r24, r18
    6d64:	93 2b       	or	r25, r19
    6d66:	f4 01       	movw	r30, r8
    6d68:	91 83       	std	Z+1, r25	; 0x01
    6d6a:	80 83       	st	Z, r24
    6d6c:	90 e0       	ldi	r25, 0x00	; 0
    6d6e:	c4 ce       	rjmp	.-632    	; 0x6af8 <MB_S_Timer_ISR+0x176>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_Preset(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][6]+9 || MB_Frame[MB_N][5]*2!=MB_Frame[MB_N][6])
    6d70:	fa 01       	movw	r30, r20
    6d72:	86 81       	ldd	r24, Z+6	; 0x06
    6d74:	28 2f       	mov	r18, r24
    6d76:	30 e0       	ldi	r19, 0x00	; 0
    6d78:	3f 83       	std	Y+7, r19	; 0x07
    6d7a:	2e 83       	std	Y+6, r18	; 0x06
    6d7c:	89 e4       	ldi	r24, 0x49	; 73
    6d7e:	48 2e       	mov	r4, r24
    6d80:	87 e0       	ldi	r24, 0x07	; 7
    6d82:	58 2e       	mov	r5, r24
    6d84:	88 85       	ldd	r24, Y+8	; 0x08
    6d86:	99 85       	ldd	r25, Y+9	; 0x09
    6d88:	48 0e       	add	r4, r24
    6d8a:	59 1e       	adc	r5, r25
    6d8c:	f2 01       	movw	r30, r4
    6d8e:	80 81       	ld	r24, Z
    6d90:	90 e0       	ldi	r25, 0x00	; 0
    6d92:	27 5f       	subi	r18, 0xF7	; 247
    6d94:	3f 4f       	sbci	r19, 0xFF	; 255
    6d96:	82 17       	cp	r24, r18
    6d98:	93 07       	cpc	r25, r19
    6d9a:	99 f1       	breq	.+102    	; 0x6e02 <MB_S_Timer_ISR+0x480>
		return MB_Frame[MB_N][2]=IllegData;
    6d9c:	66 0f       	add	r22, r22
    6d9e:	77 1f       	adc	r23, r23
    6da0:	63 59       	subi	r22, 0x93	; 147
    6da2:	74 4f       	sbci	r23, 0xF4	; 244
    6da4:	83 e0       	ldi	r24, 0x03	; 3
    6da6:	db 01       	movw	r26, r22
    6da8:	8c 93       	st	X, r24
    6daa:	93 e0       	ldi	r25, 0x03	; 3
    6dac:	a5 ce       	rjmp	.-694    	; 0x6af8 <MB_S_Timer_ISR+0x176>
    6dae:	28 85       	ldd	r18, Y+8	; 0x08
    6db0:	39 85       	ldd	r19, Y+9	; 0x09
    6db2:	f2 2f       	mov	r31, r18
    6db4:	ee 27       	eor	r30, r30
    6db6:	e1 59       	subi	r30, 0x91	; 145
    6db8:	f4 4f       	sbci	r31, 0xF4	; 244
    6dba:	e0 81       	ld	r30, Z
    6dbc:	da 01       	movw	r26, r20
    6dbe:	15 96       	adiw	r26, 0x05	; 5
    6dc0:	fc 91       	ld	r31, X
    6dc2:	15 97       	sbiw	r26, 0x05	; 5
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_Force(uint8_t MB_N, uint16_t StartAddr)
{
	uint16_t Qt = MB_FrameReg(MB_N, 4);
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][6]+9 || Qt/8+(Qt%8>0)!=MB_Frame[MB_N][6])
    6dc4:	16 96       	adiw	r26, 0x06	; 6
    6dc6:	2c 91       	ld	r18, X
    6dc8:	a9 e4       	ldi	r26, 0x49	; 73
    6dca:	4a 2e       	mov	r4, r26
    6dcc:	a7 e0       	ldi	r26, 0x07	; 7
    6dce:	5a 2e       	mov	r5, r26
    6dd0:	88 85       	ldd	r24, Y+8	; 0x08
    6dd2:	99 85       	ldd	r25, Y+9	; 0x09
    6dd4:	48 0e       	add	r4, r24
    6dd6:	59 1e       	adc	r5, r25
    6dd8:	d2 01       	movw	r26, r4
    6dda:	8c 91       	ld	r24, X
    6ddc:	90 e0       	ldi	r25, 0x00	; 0
    6dde:	42 2f       	mov	r20, r18
    6de0:	50 e0       	ldi	r21, 0x00	; 0
    6de2:	9a 01       	movw	r18, r20
    6de4:	27 5f       	subi	r18, 0xF7	; 247
    6de6:	3f 4f       	sbci	r19, 0xFF	; 255
    6de8:	82 17       	cp	r24, r18
    6dea:	93 07       	cpc	r25, r19
    6dec:	09 f4       	brne	.+2      	; 0x6df0 <MB_S_Timer_ISR+0x46e>
    6dee:	61 c0       	rjmp	.+194    	; 0x6eb2 <MB_S_Timer_ISR+0x530>
		return MB_Frame[MB_N][2]=IllegData;
    6df0:	66 0f       	add	r22, r22
    6df2:	77 1f       	adc	r23, r23
    6df4:	63 59       	subi	r22, 0x93	; 147
    6df6:	74 4f       	sbci	r23, 0xF4	; 244
    6df8:	83 e0       	ldi	r24, 0x03	; 3
    6dfa:	fb 01       	movw	r30, r22
    6dfc:	80 83       	st	Z, r24
    6dfe:	93 e0       	ldi	r25, 0x03	; 3
    6e00:	7b ce       	rjmp	.-778    	; 0x6af8 <MB_S_Timer_ISR+0x176>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_Preset(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][6]+9 || MB_Frame[MB_N][5]*2!=MB_Frame[MB_N][6])
    6e02:	9a 01       	movw	r18, r20
    6e04:	2b 5f       	subi	r18, 0xFB	; 251
    6e06:	3f 4f       	sbci	r19, 0xFF	; 255
    6e08:	3c 83       	std	Y+4, r19	; 0x04
    6e0a:	2b 83       	std	Y+3, r18	; 0x03
    6e0c:	fa 01       	movw	r30, r20
    6e0e:	c5 80       	ldd	r12, Z+5	; 0x05
    6e10:	2c 2d       	mov	r18, r12
    6e12:	30 e0       	ldi	r19, 0x00	; 0
    6e14:	c9 01       	movw	r24, r18
    6e16:	88 0f       	add	r24, r24
    6e18:	99 1f       	adc	r25, r25
    6e1a:	ee 81       	ldd	r30, Y+6	; 0x06
    6e1c:	ff 81       	ldd	r31, Y+7	; 0x07
    6e1e:	e8 17       	cp	r30, r24
    6e20:	f9 07       	cpc	r31, r25
    6e22:	09 f0       	breq	.+2      	; 0x6e26 <MB_S_Timer_ISR+0x4a4>
    6e24:	bb cf       	rjmp	.-138    	; 0x6d9c <MB_S_Timer_ISR+0x41a>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    6e26:	f3 01       	movw	r30, r6
    6e28:	e6 5c       	subi	r30, 0xC6	; 198
    6e2a:	fc 4f       	sbci	r31, 0xFC	; 252
    6e2c:	85 91       	lpm	r24, Z+
    6e2e:	94 91       	lpm	r25, Z+
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+MB_Frame[MB_N][5]>prw(&Modbus_Map[MB_N].HoldReg_Qt))
    6e30:	28 0d       	add	r18, r8
    6e32:	39 1d       	adc	r19, r9
    6e34:	82 17       	cp	r24, r18
    6e36:	93 07       	cpc	r25, r19
    6e38:	08 f4       	brcc	.+2      	; 0x6e3c <MB_S_Timer_ISR+0x4ba>
    6e3a:	75 c0       	rjmp	.+234    	; 0x6f26 <MB_S_Timer_ISR+0x5a4>
		return MB_Frame[MB_N][2]=IllegAddr;
	MB_Frame_Sz[MB_N] = 8;
    6e3c:	88 e0       	ldi	r24, 0x08	; 8
    6e3e:	f2 01       	movw	r30, r4
    6e40:	80 83       	st	Z, r24

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6e42:	e8 85       	ldd	r30, Y+8	; 0x08
    6e44:	f9 85       	ldd	r31, Y+9	; 0x09
    6e46:	ee 0f       	add	r30, r30
    6e48:	ff 1f       	adc	r31, r31
    6e4a:	ee 0f       	add	r30, r30
    6e4c:	ff 1f       	adc	r31, r31
    6e4e:	ee 0f       	add	r30, r30
    6e50:	ff 1f       	adc	r31, r31
    6e52:	ee 0f       	add	r30, r30
    6e54:	ff 1f       	adc	r31, r31
    6e56:	e8 5c       	subi	r30, 0xC8	; 200
    6e58:	fc 4f       	sbci	r31, 0xFC	; 252
    6e5a:	45 90       	lpm	r4, Z+
    6e5c:	54 90       	lpm	r5, Z+
	uint16_t *HoldReg = prp(&Modbus_Map[MB_N].HoldReg);
	for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    6e5e:	cc 20       	and	r12, r12
    6e60:	31 f1       	breq	.+76     	; 0x6eae <MB_S_Timer_ISR+0x52c>
    6e62:	60 e0       	ldi	r22, 0x00	; 0
    6e64:	6b 80       	ldd	r6, Y+3	; 0x03
    6e66:	7c 80       	ldd	r7, Y+4	; 0x04
    6e68:	a6 2f       	mov	r26, r22
    6e6a:	b0 e0       	ldi	r27, 0x00	; 0
    6e6c:	cd 01       	movw	r24, r26
    6e6e:	88 0f       	add	r24, r24
    6e70:	99 1f       	adc	r25, r25
    6e72:	89 5f       	subi	r24, 0xF9	; 249
    6e74:	28 2f       	mov	r18, r24
    6e76:	30 e0       	ldi	r19, 0x00	; 0
		uint8_t j = i*2;
		HoldReg[StartAddr+i] = MB_FrameReg(MB_N, 7+j);
    6e78:	a8 0d       	add	r26, r8
    6e7a:	b9 1d       	adc	r27, r9
    6e7c:	aa 0f       	add	r26, r26
    6e7e:	bb 1f       	adc	r27, r27
    6e80:	a4 0d       	add	r26, r4
    6e82:	b5 1d       	adc	r27, r5
    6e84:	fa 01       	movw	r30, r20
    6e86:	e2 0f       	add	r30, r18
    6e88:	f3 1f       	adc	r31, r19
    6e8a:	81 81       	ldd	r24, Z+1	; 0x01
    6e8c:	90 e0       	ldi	r25, 0x00	; 0
    6e8e:	2e 0d       	add	r18, r14
    6e90:	3f 1d       	adc	r19, r15
    6e92:	25 59       	subi	r18, 0x95	; 149
    6e94:	34 4f       	sbci	r19, 0xF4	; 244
    6e96:	f9 01       	movw	r30, r18
    6e98:	30 81       	ld	r19, Z
    6e9a:	20 e0       	ldi	r18, 0x00	; 0
    6e9c:	82 2b       	or	r24, r18
    6e9e:	93 2b       	or	r25, r19
    6ea0:	8d 93       	st	X+, r24
    6ea2:	9c 93       	st	X, r25
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+MB_Frame[MB_N][5]>prw(&Modbus_Map[MB_N].HoldReg_Qt))
		return MB_Frame[MB_N][2]=IllegAddr;
	MB_Frame_Sz[MB_N] = 8;
	uint16_t *HoldReg = prp(&Modbus_Map[MB_N].HoldReg);
	for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    6ea4:	6f 5f       	subi	r22, 0xFF	; 255
    6ea6:	d3 01       	movw	r26, r6
    6ea8:	8c 91       	ld	r24, X
    6eaa:	68 17       	cp	r22, r24
    6eac:	e8 f2       	brcs	.-70     	; 0x6e68 <MB_S_Timer_ISR+0x4e6>
		break;
	case 0x10:
		Err = MB_S_Preset(MB_N, StartAddr);
		break;
	default:
		Err = MB_Frame[MB_N][2] = IllegFunc;
    6eae:	90 e0       	ldi	r25, 0x00	; 0
    6eb0:	23 ce       	rjmp	.-954    	; 0x6af8 <MB_S_Timer_ISR+0x176>
    6eb2:	9e 2f       	mov	r25, r30
    6eb4:	80 e0       	ldi	r24, 0x00	; 0
    6eb6:	af 2f       	mov	r26, r31
    6eb8:	b0 e0       	ldi	r27, 0x00	; 0
    6eba:	a8 2b       	or	r26, r24
    6ebc:	b9 2b       	or	r27, r25
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_Force(uint8_t MB_N, uint16_t StartAddr)
{
	uint16_t Qt = MB_FrameReg(MB_N, 4);
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][6]+9 || Qt/8+(Qt%8>0)!=MB_Frame[MB_N][6])
    6ebe:	20 e0       	ldi	r18, 0x00	; 0
    6ec0:	30 e0       	ldi	r19, 0x00	; 0
    6ec2:	cd 01       	movw	r24, r26
    6ec4:	87 70       	andi	r24, 0x07	; 7
    6ec6:	90 70       	andi	r25, 0x00	; 0
    6ec8:	89 2b       	or	r24, r25
    6eca:	11 f0       	breq	.+4      	; 0x6ed0 <MB_S_Timer_ISR+0x54e>
    6ecc:	21 e0       	ldi	r18, 0x01	; 1
    6ece:	30 e0       	ldi	r19, 0x00	; 0
    6ed0:	cd 01       	movw	r24, r26
    6ed2:	96 95       	lsr	r25
    6ed4:	87 95       	ror	r24
    6ed6:	96 95       	lsr	r25
    6ed8:	87 95       	ror	r24
    6eda:	96 95       	lsr	r25
    6edc:	87 95       	ror	r24
    6ede:	28 0f       	add	r18, r24
    6ee0:	39 1f       	adc	r19, r25
    6ee2:	24 17       	cp	r18, r20
    6ee4:	35 07       	cpc	r19, r21
    6ee6:	09 f0       	breq	.+2      	; 0x6eea <MB_S_Timer_ISR+0x568>
    6ee8:	83 cf       	rjmp	.-250    	; 0x6df0 <MB_S_Timer_ISR+0x46e>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    6eea:	e8 85       	ldd	r30, Y+8	; 0x08
    6eec:	f9 85       	ldd	r31, Y+9	; 0x09
    6eee:	ee 0f       	add	r30, r30
    6ef0:	ff 1f       	adc	r31, r31
    6ef2:	ee 0f       	add	r30, r30
    6ef4:	ff 1f       	adc	r31, r31
    6ef6:	ee 0f       	add	r30, r30
    6ef8:	ff 1f       	adc	r31, r31
    6efa:	ee 0f       	add	r30, r30
    6efc:	ff 1f       	adc	r31, r31
    6efe:	ee 5c       	subi	r30, 0xCE	; 206
    6f00:	fc 4f       	sbci	r31, 0xFC	; 252
    6f02:	25 91       	lpm	r18, Z+
    6f04:	34 91       	lpm	r19, Z+
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+Qt > prw(&Modbus_Map[MB_N].Coil_Qt))
    6f06:	cd 01       	movw	r24, r26
    6f08:	88 0d       	add	r24, r8
    6f0a:	99 1d       	adc	r25, r9
    6f0c:	28 17       	cp	r18, r24
    6f0e:	39 07       	cpc	r19, r25
    6f10:	08 f0       	brcs	.+2      	; 0x6f14 <MB_S_Timer_ISR+0x592>
    6f12:	5d c0       	rjmp	.+186    	; 0x6fce <MB_S_Timer_ISR+0x64c>
		return MB_Frame[MB_N][2]=IllegAddr;
    6f14:	66 0f       	add	r22, r22
    6f16:	77 1f       	adc	r23, r23
    6f18:	63 59       	subi	r22, 0x93	; 147
    6f1a:	74 4f       	sbci	r23, 0xF4	; 244
    6f1c:	82 e0       	ldi	r24, 0x02	; 2
    6f1e:	db 01       	movw	r26, r22
    6f20:	8c 93       	st	X, r24
    6f22:	92 e0       	ldi	r25, 0x02	; 2
    6f24:	e9 cd       	rjmp	.-1070   	; 0x6af8 <MB_S_Timer_ISR+0x176>
MB_S_Preset(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][6]+9 || MB_Frame[MB_N][5]*2!=MB_Frame[MB_N][6])
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+MB_Frame[MB_N][5]>prw(&Modbus_Map[MB_N].HoldReg_Qt))
		return MB_Frame[MB_N][2]=IllegAddr;
    6f26:	82 e0       	ldi	r24, 0x02	; 2
    6f28:	8c 93       	st	X, r24
    6f2a:	92 e0       	ldi	r25, 0x02	; 2
    6f2c:	e5 cd       	rjmp	.-1078   	; 0x6af8 <MB_S_Timer_ISR+0x176>
	if (MB_Frame[MB_N][0]==0)
		return 0xFF;
	if (MB_Frame_Sz[MB_N]!=8)
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+MB_Frame[MB_N][5]>(MB_Frame[MB_N][1]==3?prw(&Modbus_Map[MB_N].HoldReg_Qt):prw(&Modbus_Map[MB_N].InReg_Qt)))
		return MB_Frame[MB_N][2]=IllegAddr;
    6f2e:	66 0f       	add	r22, r22
    6f30:	77 1f       	adc	r23, r23
    6f32:	63 59       	subi	r22, 0x93	; 147
    6f34:	74 4f       	sbci	r23, 0xF4	; 244
    6f36:	82 e0       	ldi	r24, 0x02	; 2
    6f38:	fb 01       	movw	r30, r22
    6f3a:	80 83       	st	Z, r24
    6f3c:	92 e0       	ldi	r25, 0x02	; 2
    6f3e:	dc cd       	rjmp	.-1096   	; 0x6af8 <MB_S_Timer_ISR+0x176>
{
	if (MB_Frame[MB_N][0]==0)
		return 0xFF;
	if (MB_Frame_Sz[MB_N]!=8)
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+MB_Frame[MB_N][5]>(MB_Frame[MB_N][1]==3?prw(&Modbus_Map[MB_N].HoldReg_Qt):prw(&Modbus_Map[MB_N].InReg_Qt)))
    6f40:	da 01       	movw	r26, r20
    6f42:	15 96       	adiw	r26, 0x05	; 5
    6f44:	8c 91       	ld	r24, X
    6f46:	33 30       	cpi	r19, 0x03	; 3
    6f48:	09 f4       	brne	.+2      	; 0x6f4c <MB_S_Timer_ISR+0x5ca>
    6f4a:	ab c0       	rjmp	.+342    	; 0x70a2 <MB_S_Timer_ISR+0x720>
    6f4c:	f3 01       	movw	r30, r6
    6f4e:	e2 5c       	subi	r30, 0xC2	; 194
    6f50:	fc 4f       	sbci	r31, 0xFC	; 252
    6f52:	45 91       	lpm	r20, Z+
    6f54:	54 91       	lpm	r21, Z+
    6f56:	a8 2f       	mov	r26, r24
    6f58:	b0 e0       	ldi	r27, 0x00	; 0
    6f5a:	c4 01       	movw	r24, r8
    6f5c:	8a 0f       	add	r24, r26
    6f5e:	9b 1f       	adc	r25, r27
    6f60:	48 17       	cp	r20, r24
    6f62:	59 07       	cpc	r21, r25
    6f64:	20 f3       	brcs	.-56     	; 0x6f2e <MB_S_Timer_ISR+0x5ac>
		return MB_Frame[MB_N][2]=IllegAddr;
	uint16_t *Reg = (uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg)) + StartAddr;
    6f66:	33 30       	cpi	r19, 0x03	; 3
    6f68:	09 f4       	brne	.+2      	; 0x6f6c <MB_S_Timer_ISR+0x5ea>
    6f6a:	a9 c0       	rjmp	.+338    	; 0x70be <MB_S_Timer_ISR+0x73c>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6f6c:	f3 01       	movw	r30, r6
    6f6e:	e4 5c       	subi	r30, 0xC4	; 196
    6f70:	fc 4f       	sbci	r31, 0xFC	; 252
    6f72:	85 91       	lpm	r24, Z+
    6f74:	94 91       	lpm	r25, Z+
    6f76:	94 01       	movw	r18, r8
    6f78:	22 0f       	add	r18, r18
    6f7a:	33 1f       	adc	r19, r19
    6f7c:	28 0f       	add	r18, r24
    6f7e:	39 1f       	adc	r19, r25
	MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][2] = MB_Frame[MB_N][5]*2) + 5;
    6f80:	cd 01       	movw	r24, r26
    6f82:	88 0f       	add	r24, r24
    6f84:	99 1f       	adc	r25, r25
    6f86:	66 0f       	add	r22, r22
    6f88:	77 1f       	adc	r23, r23
    6f8a:	63 59       	subi	r22, 0x93	; 147
    6f8c:	74 4f       	sbci	r23, 0xF4	; 244
    6f8e:	db 01       	movw	r26, r22
    6f90:	8c 93       	st	X, r24
    6f92:	8b 5f       	subi	r24, 0xFB	; 251
    6f94:	f2 01       	movw	r30, r4
    6f96:	80 83       	st	Z, r24
	uint8_t Qt = MB_Frame[MB_N][5];
    6f98:	f7 01       	movw	r30, r14
    6f9a:	e5 59       	subi	r30, 0x95	; 149
    6f9c:	f4 4f       	sbci	r31, 0xF4	; 244
    6f9e:	45 81       	ldd	r20, Z+5	; 0x05
	for (uint8_t i=0; i<Qt; i++) {
    6fa0:	44 23       	and	r20, r20
    6fa2:	09 f4       	brne	.+2      	; 0x6fa6 <MB_S_Timer_ISR+0x624>
    6fa4:	84 cf       	rjmp	.-248    	; 0x6eae <MB_S_Timer_ISR+0x52c>
    6fa6:	d9 01       	movw	r26, r18
    6fa8:	90 e0       	ldi	r25, 0x00	; 0
		uint8_t j = i*2;
		MB_Frame[MB_N][3+j] = Reg[i]>>8;
    6faa:	9f 01       	movw	r18, r30
    6fac:	89 2f       	mov	r24, r25
    6fae:	88 0f       	add	r24, r24
    6fb0:	f9 01       	movw	r30, r18
    6fb2:	e8 0f       	add	r30, r24
    6fb4:	f1 1d       	adc	r31, r1
    6fb6:	11 96       	adiw	r26, 0x01	; 1
    6fb8:	8c 91       	ld	r24, X
    6fba:	11 97       	sbiw	r26, 0x01	; 1
    6fbc:	83 83       	std	Z+3, r24	; 0x03
		MB_Frame[MB_N][4+j] = Reg[i];
    6fbe:	8c 91       	ld	r24, X
    6fc0:	84 83       	std	Z+4, r24	; 0x04
	if (StartAddr+MB_Frame[MB_N][5]>(MB_Frame[MB_N][1]==3?prw(&Modbus_Map[MB_N].HoldReg_Qt):prw(&Modbus_Map[MB_N].InReg_Qt)))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint16_t *Reg = (uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg)) + StartAddr;
	MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][2] = MB_Frame[MB_N][5]*2) + 5;
	uint8_t Qt = MB_Frame[MB_N][5];
	for (uint8_t i=0; i<Qt; i++) {
    6fc2:	9f 5f       	subi	r25, 0xFF	; 255
    6fc4:	12 96       	adiw	r26, 0x02	; 2
    6fc6:	94 17       	cp	r25, r20
    6fc8:	88 f3       	brcs	.-30     	; 0x6fac <MB_S_Timer_ISR+0x62a>
		break;
	case 0x10:
		Err = MB_S_Preset(MB_N, StartAddr);
		break;
	default:
		Err = MB_Frame[MB_N][2] = IllegFunc;
    6fca:	90 e0       	ldi	r25, 0x00	; 0
    6fcc:	95 cd       	rjmp	.-1238   	; 0x6af8 <MB_S_Timer_ISR+0x176>
    6fce:	93 01       	movw	r18, r6
    6fd0:	20 5d       	subi	r18, 0xD0	; 208
    6fd2:	3c 4f       	sbci	r19, 0xFC	; 252
    6fd4:	f9 01       	movw	r30, r18
    6fd6:	85 91       	lpm	r24, Z+
    6fd8:	94 91       	lpm	r25, Z+
    6fda:	9a 83       	std	Y+2, r25	; 0x02
    6fdc:	89 83       	std	Y+1, r24	; 0x01
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][6]+9 || Qt/8+(Qt%8>0)!=MB_Frame[MB_N][6])
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+Qt > prw(&Modbus_Map[MB_N].Coil_Qt))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Coil = prp(&Modbus_Map[MB_N].Coil);
	MB_Frame_Sz[MB_N] = 8;
    6fde:	88 e0       	ldi	r24, 0x08	; 8
    6fe0:	f2 01       	movw	r30, r4
    6fe2:	80 83       	st	Z, r24
	for (uint8_t i=0; i<Qt; i++) {
    6fe4:	10 97       	sbiw	r26, 0x00	; 0
    6fe6:	09 f4       	brne	.+2      	; 0x6fea <MB_S_Timer_ISR+0x668>
    6fe8:	62 cf       	rjmp	.-316    	; 0x6eae <MB_S_Timer_ISR+0x52c>
    6fea:	cc 24       	eor	r12, r12
    6fec:	80 e0       	ldi	r24, 0x00	; 0
    6fee:	90 e0       	ldi	r25, 0x00	; 0
    6ff0:	20 e0       	ldi	r18, 0x00	; 0
    6ff2:	30 e0       	ldi	r19, 0x00	; 0
		uint16_t j = StartAddr+i;
		uint16_t Byte=j/8, Bit=1<<j%8;
    6ff4:	e1 e0       	ldi	r30, 0x01	; 1
    6ff6:	4e 2e       	mov	r4, r30
    6ff8:	51 2c       	mov	r5, r1
		if (MB_Frame[MB_N][7+i/8] &(1<<i%8))
    6ffa:	7b e6       	ldi	r23, 0x6B	; 107
    6ffc:	67 2e       	mov	r6, r23
    6ffe:	7b e0       	ldi	r23, 0x0B	; 11
    7000:	77 2e       	mov	r7, r23
    7002:	6e 0c       	add	r6, r14
    7004:	7f 1c       	adc	r7, r15
    7006:	10 c0       	rjmp	.+32     	; 0x7028 <MB_S_Timer_ISR+0x6a6>
			Coil[Byte] |=Bit;
    7008:	29 81       	ldd	r18, Y+1	; 0x01
    700a:	3a 81       	ldd	r19, Y+2	; 0x02
    700c:	24 0f       	add	r18, r20
    700e:	35 1f       	adc	r19, r21
    7010:	f9 01       	movw	r30, r18
    7012:	80 81       	ld	r24, Z
    7014:	86 2b       	or	r24, r22
    7016:	80 83       	st	Z, r24
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+Qt > prw(&Modbus_Map[MB_N].Coil_Qt))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Coil = prp(&Modbus_Map[MB_N].Coil);
	MB_Frame_Sz[MB_N] = 8;
	for (uint8_t i=0; i<Qt; i++) {
    7018:	c3 94       	inc	r12
    701a:	2c 2d       	mov	r18, r12
    701c:	30 e0       	ldi	r19, 0x00	; 0
    701e:	c9 01       	movw	r24, r18
    7020:	2a 17       	cp	r18, r26
    7022:	3b 07       	cpc	r19, r27
    7024:	08 f0       	brcs	.+2      	; 0x7028 <MB_S_Timer_ISR+0x6a6>
    7026:	43 cf       	rjmp	.-378    	; 0x6eae <MB_S_Timer_ISR+0x52c>
		uint16_t j = StartAddr+i;
    7028:	88 0d       	add	r24, r8
    702a:	99 1d       	adc	r25, r9
		uint16_t Byte=j/8, Bit=1<<j%8;
    702c:	ac 01       	movw	r20, r24
    702e:	56 95       	lsr	r21
    7030:	47 95       	ror	r20
    7032:	56 95       	lsr	r21
    7034:	47 95       	ror	r20
    7036:	56 95       	lsr	r21
    7038:	47 95       	ror	r20
    703a:	87 70       	andi	r24, 0x07	; 7
    703c:	90 70       	andi	r25, 0x00	; 0
    703e:	b2 01       	movw	r22, r4
    7040:	02 c0       	rjmp	.+4      	; 0x7046 <MB_S_Timer_ISR+0x6c4>
    7042:	66 0f       	add	r22, r22
    7044:	77 1f       	adc	r23, r23
    7046:	8a 95       	dec	r24
    7048:	e2 f7       	brpl	.-8      	; 0x7042 <MB_S_Timer_ISR+0x6c0>
		if (MB_Frame[MB_N][7+i/8] &(1<<i%8))
    704a:	8c 2d       	mov	r24, r12
    704c:	86 95       	lsr	r24
    704e:	86 95       	lsr	r24
    7050:	86 95       	lsr	r24
    7052:	f3 01       	movw	r30, r6
    7054:	e8 0f       	add	r30, r24
    7056:	f1 1d       	adc	r31, r1
    7058:	87 81       	ldd	r24, Z+7	; 0x07
    705a:	90 e0       	ldi	r25, 0x00	; 0
    705c:	27 70       	andi	r18, 0x07	; 7
    705e:	30 70       	andi	r19, 0x00	; 0
    7060:	02 c0       	rjmp	.+4      	; 0x7066 <MB_S_Timer_ISR+0x6e4>
    7062:	95 95       	asr	r25
    7064:	87 95       	ror	r24
    7066:	2a 95       	dec	r18
    7068:	e2 f7       	brpl	.-8      	; 0x7062 <MB_S_Timer_ISR+0x6e0>
    706a:	80 fd       	sbrc	r24, 0
    706c:	cd cf       	rjmp	.-102    	; 0x7008 <MB_S_Timer_ISR+0x686>
			Coil[Byte] |=Bit;
		else
			Coil[Byte] &=~Bit;
    706e:	29 81       	ldd	r18, Y+1	; 0x01
    7070:	3a 81       	ldd	r19, Y+2	; 0x02
    7072:	24 0f       	add	r18, r20
    7074:	35 1f       	adc	r19, r21
    7076:	96 2f       	mov	r25, r22
    7078:	90 95       	com	r25
    707a:	f9 01       	movw	r30, r18
    707c:	80 81       	ld	r24, Z
    707e:	89 23       	and	r24, r25
    7080:	80 83       	st	Z, r24
    7082:	ca cf       	rjmp	.-108    	; 0x7018 <MB_S_Timer_ISR+0x696>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    7084:	e8 85       	ldd	r30, Y+8	; 0x08
    7086:	f9 85       	ldd	r31, Y+9	; 0x09
    7088:	ee 0f       	add	r30, r30
    708a:	ff 1f       	adc	r31, r31
    708c:	ee 0f       	add	r30, r30
    708e:	ff 1f       	adc	r31, r31
    7090:	ee 0f       	add	r30, r30
    7092:	ff 1f       	adc	r31, r31
    7094:	ee 0f       	add	r30, r30
    7096:	ff 1f       	adc	r31, r31
    7098:	ee 5c       	subi	r30, 0xCE	; 206
    709a:	fc 4f       	sbci	r31, 0xFC	; 252
    709c:	45 91       	lpm	r20, Z+
    709e:	54 91       	lpm	r21, Z+
    70a0:	b2 cd       	rjmp	.-1180   	; 0x6c06 <MB_S_Timer_ISR+0x284>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    70a2:	f3 01       	movw	r30, r6
    70a4:	e6 5c       	subi	r30, 0xC6	; 198
    70a6:	fc 4f       	sbci	r31, 0xFC	; 252
    70a8:	45 91       	lpm	r20, Z+
    70aa:	54 91       	lpm	r21, Z+
    70ac:	54 cf       	rjmp	.-344    	; 0x6f56 <MB_S_Timer_ISR+0x5d4>
    70ae:	f3 01       	movw	r30, r6
    70b0:	e0 5d       	subi	r30, 0xD0	; 208
    70b2:	fc 4f       	sbci	r31, 0xFC	; 252
    70b4:	85 91       	lpm	r24, Z+
    70b6:	94 91       	lpm	r25, Z+
    70b8:	28 2f       	mov	r18, r24
    70ba:	89 2f       	mov	r24, r25
    70bc:	b9 cd       	rjmp	.-1166   	; 0x6c30 <MB_S_Timer_ISR+0x2ae>
    70be:	e8 85       	ldd	r30, Y+8	; 0x08
    70c0:	f9 85       	ldd	r31, Y+9	; 0x09
    70c2:	ee 0f       	add	r30, r30
    70c4:	ff 1f       	adc	r31, r31
    70c6:	ee 0f       	add	r30, r30
    70c8:	ff 1f       	adc	r31, r31
    70ca:	ee 0f       	add	r30, r30
    70cc:	ff 1f       	adc	r31, r31
    70ce:	ee 0f       	add	r30, r30
    70d0:	ff 1f       	adc	r31, r31
    70d2:	e8 5c       	subi	r30, 0xC8	; 200
    70d4:	fc 4f       	sbci	r31, 0xFC	; 252
    70d6:	85 91       	lpm	r24, Z+
    70d8:	94 91       	lpm	r25, Z+
    70da:	4d cf       	rjmp	.-358    	; 0x6f76 <MB_S_Timer_ISR+0x5f4>

000070dc <MB_S_Tx>:
    70dc:	94 e1       	ldi	r25, 0x14	; 20
    70de:	89 9f       	mul	r24, r25
    70e0:	c0 01       	movw	r24, r0
    70e2:	11 24       	eor	r1, r1
    70e4:	86 56       	subi	r24, 0x66	; 102
    70e6:	9f 4b       	sbci	r25, 0xBF	; 191
    70e8:	fc 01       	movw	r30, r24
    70ea:	25 91       	lpm	r18, Z+
    70ec:	34 91       	lpm	r19, Z+

// ~~~~~~~~~~~~~~~~~~
void
MB_S_Tx(uint8_t MB_N)
{
	USART_Func(MB_N, LED);
    70ee:	f9 01       	movw	r30, r18
    70f0:	19 95       	eicall
}
    70f2:	08 95       	ret

000070f4 <MB_Slave_Off>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
MB_Slave_Off(uint8_t MB_N, uint8_t S_N)
{
    70f4:	21 e0       	ldi	r18, 0x01	; 1
    70f6:	30 e0       	ldi	r19, 0x00	; 0
    70f8:	40 e0       	ldi	r20, 0x00	; 0
    70fa:	50 e0       	ldi	r21, 0x00	; 0
    70fc:	04 c0       	rjmp	.+8      	; 0x7106 <MB_Slave_Off+0x12>
    70fe:	22 0f       	add	r18, r18
    7100:	33 1f       	adc	r19, r19
    7102:	44 1f       	adc	r20, r20
    7104:	55 1f       	adc	r21, r21
    7106:	6a 95       	dec	r22
    7108:	d2 f7       	brpl	.-12     	; 0x70fe <MB_Slave_Off+0xa>
    710a:	e8 2f       	mov	r30, r24
    710c:	f0 e0       	ldi	r31, 0x00	; 0
    710e:	ee 0f       	add	r30, r30
    7110:	ff 1f       	adc	r31, r31
    7112:	ee 0f       	add	r30, r30
    7114:	ff 1f       	adc	r31, r31
    7116:	e3 5d       	subi	r30, 0xD3	; 211
    7118:	f6 4f       	sbci	r31, 0xF6	; 246
    711a:	80 81       	ld	r24, Z
    711c:	91 81       	ldd	r25, Z+1	; 0x01
    711e:	a2 81       	ldd	r26, Z+2	; 0x02
    7120:	b3 81       	ldd	r27, Z+3	; 0x03
    7122:	28 23       	and	r18, r24
    7124:	39 23       	and	r19, r25
    7126:	4a 23       	and	r20, r26
    7128:	5b 23       	and	r21, r27
	return SlaveOff[MB_N] &((uint32_t)1<<S_N);
}
    712a:	b9 01       	movw	r22, r18
    712c:	ca 01       	movw	r24, r20
    712e:	08 95       	ret

00007130 <GetReg>:
}

// ~~~~~~~~~~~~~~~~~
static uint16_t*
GetReg(uint8_t MB_N)
{
    7130:	98 2f       	mov	r25, r24
	return MB_SingleState[MB_N]!=MB_SingleExec?(uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+prw(&GetQuery(MB_N)->AllocAddr):MB_SingleQuery[MB_N].Buf;
    7132:	a8 2f       	mov	r26, r24
    7134:	b0 e0       	ldi	r27, 0x00	; 0
    7136:	fd 01       	movw	r30, r26
    7138:	e1 55       	subi	r30, 0x51	; 81
    713a:	f9 4f       	sbci	r31, 0xF9	; 249
    713c:	80 81       	ld	r24, Z
    713e:	82 30       	cpi	r24, 0x02	; 2
    7140:	09 f4       	brne	.+2      	; 0x7144 <GetReg+0x14>
    7142:	39 c0       	rjmp	.+114    	; 0x71b6 <GetReg+0x86>
    7144:	fd 01       	movw	r30, r26
    7146:	ee 0f       	add	r30, r30
    7148:	ff 1f       	adc	r31, r31
    714a:	ee 0f       	add	r30, r30
    714c:	ff 1f       	adc	r31, r31
    714e:	ee 0f       	add	r30, r30
    7150:	ff 1f       	adc	r31, r31
    7152:	ee 0f       	add	r30, r30
    7154:	ff 1f       	adc	r31, r31
    7156:	e8 5c       	subi	r30, 0xC8	; 200
    7158:	fc 4f       	sbci	r31, 0xFC	; 252
    715a:	45 91       	lpm	r20, Z+
    715c:	54 91       	lpm	r21, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    715e:	83 e0       	ldi	r24, 0x03	; 3
    7160:	98 9f       	mul	r25, r24
    7162:	f0 01       	movw	r30, r0
    7164:	11 24       	eor	r1, r1
    7166:	e5 5b       	subi	r30, 0xB5	; 181
    7168:	f6 4d       	sbci	r31, 0xD6	; 214
    716a:	25 91       	lpm	r18, Z+
    716c:	34 91       	lpm	r19, Z+
    716e:	fd 01       	movw	r30, r26
    7170:	ec 5a       	subi	r30, 0xAC	; 172
    7172:	f9 4f       	sbci	r31, 0xF9	; 249
    7174:	80 81       	ld	r24, Z
    7176:	90 e0       	ldi	r25, 0x00	; 0
    7178:	88 0f       	add	r24, r24
    717a:	99 1f       	adc	r25, r25
    717c:	88 0f       	add	r24, r24
    717e:	99 1f       	adc	r25, r25
    7180:	28 0f       	add	r18, r24
    7182:	39 1f       	adc	r19, r25
    7184:	2f 5f       	subi	r18, 0xFF	; 255
    7186:	3f 4f       	sbci	r19, 0xFF	; 255
    7188:	f9 01       	movw	r30, r18
    718a:	65 91       	lpm	r22, Z+
    718c:	74 91       	lpm	r23, Z+
    718e:	ab 5a       	subi	r26, 0xAB	; 171
    7190:	b9 4f       	sbci	r27, 0xF9	; 249
    7192:	8c 91       	ld	r24, X
    7194:	27 e0       	ldi	r18, 0x07	; 7
    7196:	82 9f       	mul	r24, r18
    7198:	c0 01       	movw	r24, r0
    719a:	11 24       	eor	r1, r1
    719c:	68 0f       	add	r22, r24
    719e:	79 1f       	adc	r23, r25
    71a0:	6b 5f       	subi	r22, 0xFB	; 251
    71a2:	7f 4f       	sbci	r23, 0xFF	; 255
    71a4:	fb 01       	movw	r30, r22
    71a6:	85 91       	lpm	r24, Z+
    71a8:	94 91       	lpm	r25, Z+
    71aa:	88 0f       	add	r24, r24
    71ac:	99 1f       	adc	r25, r25
    71ae:	48 0f       	add	r20, r24
    71b0:	59 1f       	adc	r21, r25
}
    71b2:	ca 01       	movw	r24, r20
    71b4:	08 95       	ret

// ~~~~~~~~~~~~~~~~~
static uint16_t*
GetReg(uint8_t MB_N)
{
	return MB_SingleState[MB_N]!=MB_SingleExec?(uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+prw(&GetQuery(MB_N)->AllocAddr):MB_SingleQuery[MB_N].Buf;
    71b6:	aa 0f       	add	r26, r26
    71b8:	bb 1f       	adc	r27, r27
    71ba:	aa 0f       	add	r26, r26
    71bc:	bb 1f       	adc	r27, r27
    71be:	aa 0f       	add	r26, r26
    71c0:	bb 1f       	adc	r27, r27
    71c2:	a6 52       	subi	r26, 0x26	; 38
    71c4:	bb 4f       	sbci	r27, 0xFB	; 251
    71c6:	16 96       	adiw	r26, 0x06	; 6
    71c8:	4d 91       	ld	r20, X+
    71ca:	5c 91       	ld	r21, X
    71cc:	17 97       	sbiw	r26, 0x07	; 7
}
    71ce:	ca 01       	movw	r24, r20
    71d0:	08 95       	ret

000071d2 <FormData>:

// ~~~~~~~~~~~~~~~~~~~
static void
FormData(uint8_t MB_N)
{
    71d2:	cf 92       	push	r12
    71d4:	df 92       	push	r13
    71d6:	ef 92       	push	r14
    71d8:	ff 92       	push	r15
    71da:	0f 93       	push	r16
    71dc:	1f 93       	push	r17
    71de:	cf 93       	push	r28
    71e0:	df 93       	push	r29
    71e2:	e8 2e       	mov	r14, r24
	uint16_t Qt;
	uint16_t *Reg;
	switch (MB_Frame[MB_N][1]) {
    71e4:	c8 2f       	mov	r28, r24
    71e6:	d0 e0       	ldi	r29, 0x00	; 0
    71e8:	7c 2f       	mov	r23, r28
    71ea:	66 27       	eor	r22, r22
    71ec:	8b 01       	movw	r16, r22
    71ee:	05 59       	subi	r16, 0x95	; 149
    71f0:	14 4f       	sbci	r17, 0xF4	; 244
    71f2:	f8 01       	movw	r30, r16
    71f4:	81 81       	ldd	r24, Z+1	; 0x01
    71f6:	86 30       	cpi	r24, 0x06	; 6
    71f8:	09 f4       	brne	.+2      	; 0x71fc <FormData+0x2a>
    71fa:	4b c0       	rjmp	.+150    	; 0x7292 <FormData+0xc0>
    71fc:	87 30       	cpi	r24, 0x07	; 7
    71fe:	88 f0       	brcs	.+34     	; 0x7222 <FormData+0x50>
    7200:	8f 30       	cpi	r24, 0x0F	; 15
    7202:	09 f4       	brne	.+2      	; 0x7206 <FormData+0x34>
    7204:	5b c0       	rjmp	.+182    	; 0x72bc <FormData+0xea>
    7206:	80 31       	cpi	r24, 0x10	; 16
    7208:	a1 f0       	breq	.+40     	; 0x7232 <FormData+0x60>
			MB_Frame[MB_N][7+j] = Reg[i]>>8;
			MB_Frame[MB_N][8+j] = Reg[i];
		}
		break;
	}
	SetCRC_MB(MB_N);
    720a:	8e 2d       	mov	r24, r14
    720c:	0e 94 68 34 	call	0x68d0	; 0x68d0 <SetCRC_MB>
}
    7210:	df 91       	pop	r29
    7212:	cf 91       	pop	r28
    7214:	1f 91       	pop	r17
    7216:	0f 91       	pop	r16
    7218:	ff 90       	pop	r15
    721a:	ef 90       	pop	r14
    721c:	df 90       	pop	r13
    721e:	cf 90       	pop	r12
    7220:	08 95       	ret
static void
FormData(uint8_t MB_N)
{
	uint16_t Qt;
	uint16_t *Reg;
	switch (MB_Frame[MB_N][1]) {
    7222:	81 50       	subi	r24, 0x01	; 1
    7224:	84 30       	cpi	r24, 0x04	; 4
    7226:	88 f7       	brcc	.-30     	; 0x720a <FormData+0x38>
	case 1: case 2: case 3: case 4:
		MB_Frame_Sz[MB_N] = 8;
    7228:	c7 5b       	subi	r28, 0xB7	; 183
    722a:	d8 4f       	sbci	r29, 0xF8	; 248
    722c:	88 e0       	ldi	r24, 0x08	; 8
    722e:	88 83       	st	Y, r24
    7230:	ec cf       	rjmp	.-40     	; 0x720a <FormData+0x38>
			else
				MB_Frame[MB_N][Byte] &=~Bit;
		}
		break;
	case 0x10:
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = MB_Frame[MB_N][5]*2) + 9;
    7232:	55 e0       	ldi	r21, 0x05	; 5
    7234:	c5 2e       	mov	r12, r21
    7236:	d1 2c       	mov	r13, r1
    7238:	c0 0e       	add	r12, r16
    723a:	d1 1e       	adc	r13, r17
    723c:	f8 01       	movw	r30, r16
    723e:	85 81       	ldd	r24, Z+5	; 0x05
    7240:	90 e0       	ldi	r25, 0x00	; 0
    7242:	88 0f       	add	r24, r24
    7244:	99 1f       	adc	r25, r25
    7246:	86 83       	std	Z+6, r24	; 0x06
    7248:	c7 5b       	subi	r28, 0xB7	; 183
    724a:	d8 4f       	sbci	r29, 0xF8	; 248
    724c:	87 5f       	subi	r24, 0xF7	; 247
    724e:	88 83       	st	Y, r24
		Reg = GetReg(MB_N);
    7250:	8e 2d       	mov	r24, r14
    7252:	0e 94 98 38 	call	0x7130	; 0x7130 <GetReg>
    7256:	bc 01       	movw	r22, r24
		for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    7258:	f8 01       	movw	r30, r16
    725a:	85 81       	ldd	r24, Z+5	; 0x05
    725c:	88 23       	and	r24, r24
    725e:	a9 f2       	breq	.-86     	; 0x720a <FormData+0x38>
    7260:	20 e0       	ldi	r18, 0x00	; 0
			uint8_t j = i*2;
			MB_Frame[MB_N][7+j] = Reg[i]>>8;
    7262:	a8 01       	movw	r20, r16
		}
		break;
	case 0x10:
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = MB_Frame[MB_N][5]*2) + 9;
		Reg = GetReg(MB_N);
		for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    7264:	e6 01       	movw	r28, r12
			uint8_t j = i*2;
			MB_Frame[MB_N][7+j] = Reg[i]>>8;
    7266:	82 2f       	mov	r24, r18
    7268:	90 e0       	ldi	r25, 0x00	; 0
    726a:	88 0f       	add	r24, r24
    726c:	99 1f       	adc	r25, r25
    726e:	fb 01       	movw	r30, r22
    7270:	e8 0f       	add	r30, r24
    7272:	f9 1f       	adc	r31, r25
    7274:	da 01       	movw	r26, r20
    7276:	a8 0f       	add	r26, r24
    7278:	b1 1d       	adc	r27, r1
    727a:	81 81       	ldd	r24, Z+1	; 0x01
    727c:	17 96       	adiw	r26, 0x07	; 7
    727e:	8c 93       	st	X, r24
    7280:	17 97       	sbiw	r26, 0x07	; 7
			MB_Frame[MB_N][8+j] = Reg[i];
    7282:	80 81       	ld	r24, Z
    7284:	18 96       	adiw	r26, 0x08	; 8
    7286:	8c 93       	st	X, r24
		}
		break;
	case 0x10:
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = MB_Frame[MB_N][5]*2) + 9;
		Reg = GetReg(MB_N);
		for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    7288:	2f 5f       	subi	r18, 0xFF	; 255
    728a:	88 81       	ld	r24, Y
    728c:	28 17       	cp	r18, r24
    728e:	58 f3       	brcs	.-42     	; 0x7266 <FormData+0x94>
    7290:	bc cf       	rjmp	.-136    	; 0x720a <FormData+0x38>
		MB_Frame_Sz[MB_N] = 8;
		MB_Frame[MB_N][5] = 0;
		break;
	*/
	case 6:
		MB_Frame_Sz[MB_N] = 8;
    7292:	fe 01       	movw	r30, r28
    7294:	e7 5b       	subi	r30, 0xB7	; 183
    7296:	f8 4f       	sbci	r31, 0xF8	; 248
    7298:	88 e0       	ldi	r24, 0x08	; 8
    729a:	80 83       	st	Z, r24
		Reg = GetReg(MB_N);
    729c:	8e 2d       	mov	r24, r14
    729e:	0e 94 98 38 	call	0x7130	; 0x7130 <GetReg>
    72a2:	dc 01       	movw	r26, r24
		MB_Frame[MB_N][4] = *Reg>>8;
    72a4:	fc 2f       	mov	r31, r28
    72a6:	ee 27       	eor	r30, r30
    72a8:	e1 59       	subi	r30, 0x91	; 145
    72aa:	f4 4f       	sbci	r31, 0xF4	; 244
    72ac:	11 96       	adiw	r26, 0x01	; 1
    72ae:	8c 91       	ld	r24, X
    72b0:	11 97       	sbiw	r26, 0x01	; 1
    72b2:	80 83       	st	Z, r24
		MB_Frame[MB_N][5] = *Reg;
    72b4:	8c 91       	ld	r24, X
    72b6:	f8 01       	movw	r30, r16
    72b8:	85 83       	std	Z+5, r24	; 0x05
    72ba:	a7 cf       	rjmp	.-178    	; 0x720a <FormData+0x38>
    72bc:	fc 2f       	mov	r31, r28
    72be:	ee 27       	eor	r30, r30
    72c0:	e1 59       	subi	r30, 0x91	; 145
    72c2:	f4 4f       	sbci	r31, 0xF4	; 244
    72c4:	90 81       	ld	r25, Z
    72c6:	80 e0       	ldi	r24, 0x00	; 0
    72c8:	f8 01       	movw	r30, r16
    72ca:	25 81       	ldd	r18, Z+5	; 0x05
    72cc:	02 2f       	mov	r16, r18
    72ce:	10 e0       	ldi	r17, 0x00	; 0
    72d0:	08 2b       	or	r16, r24
    72d2:	19 2b       	or	r17, r25
		break;
	case 0x0F:
		Qt = MB_FrameReg(MB_N, 4);
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = Qt/8 + (Qt%8>0)) + 9;
    72d4:	98 01       	movw	r18, r16
    72d6:	36 95       	lsr	r19
    72d8:	27 95       	ror	r18
    72da:	36 95       	lsr	r19
    72dc:	27 95       	ror	r18
    72de:	36 95       	lsr	r19
    72e0:	27 95       	ror	r18
    72e2:	40 e0       	ldi	r20, 0x00	; 0
    72e4:	c8 01       	movw	r24, r16
    72e6:	87 70       	andi	r24, 0x07	; 7
    72e8:	90 70       	andi	r25, 0x00	; 0
    72ea:	89 2b       	or	r24, r25
    72ec:	09 f0       	breq	.+2      	; 0x72f0 <FormData+0x11e>
    72ee:	8b c0       	rjmp	.+278    	; 0x7406 <FormData+0x234>
    72f0:	84 2f       	mov	r24, r20
    72f2:	82 0f       	add	r24, r18
    72f4:	fb 01       	movw	r30, r22
    72f6:	e5 59       	subi	r30, 0x95	; 149
    72f8:	f4 4f       	sbci	r31, 0xF4	; 244
    72fa:	86 83       	std	Z+6, r24	; 0x06
    72fc:	de 01       	movw	r26, r28
    72fe:	a7 5b       	subi	r26, 0xB7	; 183
    7300:	b8 4f       	sbci	r27, 0xF8	; 248
    7302:	87 5f       	subi	r24, 0xF7	; 247
    7304:	8c 93       	st	X, r24
		MB_Frame[MB_N][7+Qt/8] = 0;
    7306:	e2 0f       	add	r30, r18
    7308:	f3 1f       	adc	r31, r19
    730a:	17 82       	std	Z+7, r1	; 0x07
		uint8_t *Discr;
		uint8_t Pin;
		if (MB_SingleState[MB_N]!=MB_SingleExec) {
    730c:	fe 01       	movw	r30, r28
    730e:	e1 55       	subi	r30, 0x51	; 81
    7310:	f9 4f       	sbci	r31, 0xF9	; 249
    7312:	80 81       	ld	r24, Z
    7314:	82 30       	cpi	r24, 0x02	; 2
    7316:	09 f4       	brne	.+2      	; 0x731a <FormData+0x148>
    7318:	78 c0       	rjmp	.+240    	; 0x740a <FormData+0x238>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    731a:	fe 01       	movw	r30, r28
    731c:	e2 95       	swap	r30
    731e:	f2 95       	swap	r31
    7320:	f0 7f       	andi	r31, 0xF0	; 240
    7322:	fe 27       	eor	r31, r30
    7324:	e0 7f       	andi	r30, 0xF0	; 240
    7326:	fe 27       	eor	r31, r30
    7328:	e0 5d       	subi	r30, 0xD0	; 208
    732a:	fc 4f       	sbci	r31, 0xFC	; 252
			Discr = prp(&Modbus_Map[MB_N].Coil);
    732c:	a5 91       	lpm	r26, Z+
    732e:	b4 91       	lpm	r27, Z+
    7330:	83 e0       	ldi	r24, 0x03	; 3
    7332:	e8 9e       	mul	r14, r24
    7334:	f0 01       	movw	r30, r0
    7336:	11 24       	eor	r1, r1
    7338:	e5 5b       	subi	r30, 0xB5	; 181
    733a:	f6 4d       	sbci	r31, 0xD6	; 214
    733c:	25 91       	lpm	r18, Z+
    733e:	34 91       	lpm	r19, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    7340:	fe 01       	movw	r30, r28
    7342:	ec 5a       	subi	r30, 0xAC	; 172
    7344:	f9 4f       	sbci	r31, 0xF9	; 249
    7346:	80 81       	ld	r24, Z
    7348:	90 e0       	ldi	r25, 0x00	; 0
    734a:	88 0f       	add	r24, r24
    734c:	99 1f       	adc	r25, r25
    734e:	88 0f       	add	r24, r24
    7350:	99 1f       	adc	r25, r25
    7352:	28 0f       	add	r18, r24
    7354:	39 1f       	adc	r19, r25
    7356:	2f 5f       	subi	r18, 0xFF	; 255
    7358:	3f 4f       	sbci	r19, 0xFF	; 255
    735a:	f9 01       	movw	r30, r18
    735c:	45 91       	lpm	r20, Z+
    735e:	54 91       	lpm	r21, Z+
    7360:	cb 5a       	subi	r28, 0xAB	; 171
    7362:	d9 4f       	sbci	r29, 0xF9	; 249
    7364:	88 81       	ld	r24, Y
    7366:	27 e0       	ldi	r18, 0x07	; 7
    7368:	82 9f       	mul	r24, r18
    736a:	c0 01       	movw	r24, r0
    736c:	11 24       	eor	r1, r1
    736e:	48 0f       	add	r20, r24
    7370:	59 1f       	adc	r21, r25
    7372:	4b 5f       	subi	r20, 0xFB	; 251
    7374:	5f 4f       	sbci	r21, 0xFF	; 255
    7376:	fa 01       	movw	r30, r20
    7378:	85 91       	lpm	r24, Z+
    737a:	94 91       	lpm	r25, Z+
			Pin = prw(&GetQuery(MB_N)->AllocAddr);
    737c:	f8 2e       	mov	r15, r24
		}
		else {
			Discr = MB_SingleQuery[MB_N].Buf;
			Pin = 0;
		}
		for (uint8_t i=0; i<Qt; i++) {
    737e:	01 15       	cp	r16, r1
    7380:	11 05       	cpc	r17, r1
    7382:	09 f4       	brne	.+2      	; 0x7386 <FormData+0x1b4>
    7384:	42 cf       	rjmp	.-380    	; 0x720a <FormData+0x38>
    7386:	50 e0       	ldi	r21, 0x00	; 0
    7388:	80 e0       	ldi	r24, 0x00	; 0
    738a:	90 e0       	ldi	r25, 0x00	; 0
			uint8_t j = Pin+i;
			uint8_t Byte=7+i/8, Bit=1<<i%8;
    738c:	c1 e0       	ldi	r28, 0x01	; 1
    738e:	d0 e0       	ldi	r29, 0x00	; 0
    7390:	0f c0       	rjmp	.+30     	; 0x73b0 <FormData+0x1de>
			if (Discr[j/8] &(1<<j%8))
				MB_Frame[MB_N][Byte] |=Bit;
    7392:	fb 01       	movw	r30, r22
    7394:	e3 0f       	add	r30, r19
    7396:	f1 1d       	adc	r31, r1
    7398:	e5 59       	subi	r30, 0x95	; 149
    739a:	f4 4f       	sbci	r31, 0xF4	; 244
    739c:	80 81       	ld	r24, Z
    739e:	84 2b       	or	r24, r20
    73a0:	80 83       	st	Z, r24
		}
		else {
			Discr = MB_SingleQuery[MB_N].Buf;
			Pin = 0;
		}
		for (uint8_t i=0; i<Qt; i++) {
    73a2:	5f 5f       	subi	r21, 0xFF	; 255
    73a4:	85 2f       	mov	r24, r21
    73a6:	90 e0       	ldi	r25, 0x00	; 0
    73a8:	80 17       	cp	r24, r16
    73aa:	91 07       	cpc	r25, r17
    73ac:	08 f0       	brcs	.+2      	; 0x73b0 <FormData+0x1de>
    73ae:	2d cf       	rjmp	.-422    	; 0x720a <FormData+0x38>
    73b0:	25 2f       	mov	r18, r21
    73b2:	2f 0d       	add	r18, r15
			uint8_t j = Pin+i;
			uint8_t Byte=7+i/8, Bit=1<<i%8;
    73b4:	35 2f       	mov	r19, r21
    73b6:	36 95       	lsr	r19
    73b8:	36 95       	lsr	r19
    73ba:	36 95       	lsr	r19
    73bc:	39 5f       	subi	r19, 0xF9	; 249
    73be:	87 70       	andi	r24, 0x07	; 7
    73c0:	90 70       	andi	r25, 0x00	; 0
    73c2:	fe 01       	movw	r30, r28
    73c4:	02 c0       	rjmp	.+4      	; 0x73ca <FormData+0x1f8>
    73c6:	ee 0f       	add	r30, r30
    73c8:	ff 1f       	adc	r31, r31
    73ca:	8a 95       	dec	r24
    73cc:	e2 f7       	brpl	.-8      	; 0x73c6 <FormData+0x1f4>
    73ce:	4e 2f       	mov	r20, r30
			if (Discr[j/8] &(1<<j%8))
    73d0:	82 2f       	mov	r24, r18
    73d2:	86 95       	lsr	r24
    73d4:	86 95       	lsr	r24
    73d6:	86 95       	lsr	r24
    73d8:	fd 01       	movw	r30, r26
    73da:	e8 0f       	add	r30, r24
    73dc:	f1 1d       	adc	r31, r1
    73de:	80 81       	ld	r24, Z
    73e0:	90 e0       	ldi	r25, 0x00	; 0
    73e2:	27 70       	andi	r18, 0x07	; 7
    73e4:	02 c0       	rjmp	.+4      	; 0x73ea <FormData+0x218>
    73e6:	95 95       	asr	r25
    73e8:	87 95       	ror	r24
    73ea:	2a 95       	dec	r18
    73ec:	e2 f7       	brpl	.-8      	; 0x73e6 <FormData+0x214>
    73ee:	80 fd       	sbrc	r24, 0
    73f0:	d0 cf       	rjmp	.-96     	; 0x7392 <FormData+0x1c0>
				MB_Frame[MB_N][Byte] |=Bit;
			else
				MB_Frame[MB_N][Byte] &=~Bit;
    73f2:	fb 01       	movw	r30, r22
    73f4:	e3 0f       	add	r30, r19
    73f6:	f1 1d       	adc	r31, r1
    73f8:	e5 59       	subi	r30, 0x95	; 149
    73fa:	f4 4f       	sbci	r31, 0xF4	; 244
    73fc:	40 95       	com	r20
    73fe:	80 81       	ld	r24, Z
    7400:	48 23       	and	r20, r24
    7402:	40 83       	st	Z, r20
    7404:	ce cf       	rjmp	.-100    	; 0x73a2 <FormData+0x1d0>
		MB_Frame[MB_N][4] = *Reg>>8;
		MB_Frame[MB_N][5] = *Reg;
		break;
	case 0x0F:
		Qt = MB_FrameReg(MB_N, 4);
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = Qt/8 + (Qt%8>0)) + 9;
    7406:	41 e0       	ldi	r20, 0x01	; 1
    7408:	73 cf       	rjmp	.-282    	; 0x72f0 <FormData+0x11e>
		if (MB_SingleState[MB_N]!=MB_SingleExec) {
			Discr = prp(&Modbus_Map[MB_N].Coil);
			Pin = prw(&GetQuery(MB_N)->AllocAddr);
		}
		else {
			Discr = MB_SingleQuery[MB_N].Buf;
    740a:	cc 0f       	add	r28, r28
    740c:	dd 1f       	adc	r29, r29
    740e:	cc 0f       	add	r28, r28
    7410:	dd 1f       	adc	r29, r29
    7412:	cc 0f       	add	r28, r28
    7414:	dd 1f       	adc	r29, r29
    7416:	c6 52       	subi	r28, 0x26	; 38
    7418:	db 4f       	sbci	r29, 0xFB	; 251
    741a:	ae 81       	ldd	r26, Y+6	; 0x06
    741c:	bf 81       	ldd	r27, Y+7	; 0x07
    741e:	ff 24       	eor	r15, r15
    7420:	ae cf       	rjmp	.-164    	; 0x737e <FormData+0x1ac>

00007422 <FormQuery>:
}

// ~~~~~~~~~~~~~~~~~~~~
static void
FormQuery(uint8_t MB_N)
{
    7422:	cf 93       	push	r28
    7424:	df 93       	push	r29

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    7426:	93 e0       	ldi	r25, 0x03	; 3
    7428:	89 9f       	mul	r24, r25
    742a:	f0 01       	movw	r30, r0
    742c:	11 24       	eor	r1, r1
    742e:	e5 5b       	subi	r30, 0xB5	; 181
    7430:	f6 4d       	sbci	r31, 0xD6	; 214
    7432:	65 91       	lpm	r22, Z+
    7434:	74 91       	lpm	r23, Z+

// ~~~~~~~~~~~~~~~~~~~
static MB_Slave*
GetSlave(uint8_t MB_N)
{
	return (MB_Slave*)prp(&(MB_Master_List+MB_N)->SlaveList)+CurrSlave[MB_N];
    7436:	48 2f       	mov	r20, r24
    7438:	50 e0       	ldi	r21, 0x00	; 0
    743a:	fa 01       	movw	r30, r20
    743c:	ec 5a       	subi	r30, 0xAC	; 172
    743e:	f9 4f       	sbci	r31, 0xF9	; 249
    7440:	20 81       	ld	r18, Z
    7442:	30 e0       	ldi	r19, 0x00	; 0
    7444:	22 0f       	add	r18, r18
    7446:	33 1f       	adc	r19, r19
    7448:	22 0f       	add	r18, r18
    744a:	33 1f       	adc	r19, r19
    744c:	62 0f       	add	r22, r18
    744e:	73 1f       	adc	r23, r19
    7450:	fb 01       	movw	r30, r22
    7452:	31 96       	adiw	r30, 0x01	; 1
    7454:	c5 91       	lpm	r28, Z+
    7456:	d4 91       	lpm	r29, Z+
// ~~~~~~~~~~~~~~~~~~~~
static void
FormQuery(uint8_t MB_N)
{
	MB_Slave *Slave = GetSlave(MB_N);
	MB_Query *Query = (MB_Query*)prp(&Slave->QueryList)+CurrQuery[MB_N];
    7458:	fa 01       	movw	r30, r20
    745a:	eb 5a       	subi	r30, 0xAB	; 171
    745c:	f9 4f       	sbci	r31, 0xF9	; 249
    745e:	20 81       	ld	r18, Z
    7460:	97 e0       	ldi	r25, 0x07	; 7
    7462:	29 9f       	mul	r18, r25
    7464:	90 01       	movw	r18, r0
    7466:	11 24       	eor	r1, r1
    7468:	c2 0f       	add	r28, r18
    746a:	d3 1f       	adc	r29, r19

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    746c:	fb 01       	movw	r30, r22
    746e:	94 91       	lpm	r25, Z+

	MB_Frame[MB_N][0] = prb(&Slave->Addr);
    7470:	2b e6       	ldi	r18, 0x6B	; 107
    7472:	3b e0       	ldi	r19, 0x0B	; 11
    7474:	b4 2f       	mov	r27, r20
    7476:	aa 27       	eor	r26, r26
    7478:	a2 0f       	add	r26, r18
    747a:	b3 1f       	adc	r27, r19
    747c:	9c 93       	st	X, r25
    747e:	fe 01       	movw	r30, r28
    7480:	94 91       	lpm	r25, Z+
	MB_Frame[MB_N][1] = prb(&Query->Func);
    7482:	11 96       	adiw	r26, 0x01	; 1
    7484:	9c 93       	st	X, r25
    7486:	11 97       	sbiw	r26, 0x01	; 1
	MB_Frame[MB_N][2] = prb((uint8_t*)&Query->StartAddr+1);
    7488:	be 01       	movw	r22, r28
    748a:	6f 5f       	subi	r22, 0xFF	; 255
    748c:	7f 4f       	sbci	r23, 0xFF	; 255
    748e:	6f 5f       	subi	r22, 0xFF	; 255
    7490:	7f 4f       	sbci	r23, 0xFF	; 255
    7492:	fb 01       	movw	r30, r22
    7494:	94 91       	lpm	r25, Z+
    7496:	61 50       	subi	r22, 0x01	; 1
    7498:	70 40       	sbci	r23, 0x00	; 0
    749a:	fd 01       	movw	r30, r26
    749c:	92 83       	std	Z+2, r25	; 0x02
    749e:	fb 01       	movw	r30, r22
    74a0:	94 91       	lpm	r25, Z+
	MB_Frame[MB_N][3] = prb((uint8_t*)&Query->StartAddr);
    74a2:	13 96       	adiw	r26, 0x03	; 3
    74a4:	9c 93       	st	X, r25
    74a6:	13 97       	sbiw	r26, 0x03	; 3
    74a8:	24 96       	adiw	r28, 0x04	; 4
    74aa:	fe 01       	movw	r30, r28
    74ac:	94 91       	lpm	r25, Z+
	MB_Frame[MB_N][4] = prb((uint8_t*)&Query->Qt+1);
    74ae:	fd 01       	movw	r30, r26
    74b0:	94 83       	std	Z+4, r25	; 0x04
    74b2:	21 97       	sbiw	r28, 0x01	; 1
    74b4:	fe 01       	movw	r30, r28
    74b6:	94 91       	lpm	r25, Z+
	MB_Frame[MB_N][5] = prb((uint8_t*)&Query->Qt);
    74b8:	15 96       	adiw	r26, 0x05	; 5
    74ba:	9c 93       	st	X, r25

	FormData(MB_N);
    74bc:	0e 94 e9 38 	call	0x71d2	; 0x71d2 <FormData>
}
    74c0:	df 91       	pop	r29
    74c2:	cf 91       	pop	r28
    74c4:	08 95       	ret

000074c6 <FormSingle>:

// ~~~~~~~~~~~~~~~~~~~~~
static void
FormSingle(uint8_t MB_N)
{
    74c6:	1f 93       	push	r17
    74c8:	cf 93       	push	r28
    74ca:	df 93       	push	r29
	MB_Frame[MB_N][0] = MB_SingleQuery[MB_N].Addr;
    74cc:	a8 2f       	mov	r26, r24
    74ce:	b0 e0       	ldi	r27, 0x00	; 0
    74d0:	6b e6       	ldi	r22, 0x6B	; 107
    74d2:	7b e0       	ldi	r23, 0x0B	; 11
    74d4:	5a 2f       	mov	r21, r26
    74d6:	44 27       	eor	r20, r20
    74d8:	46 0f       	add	r20, r22
    74da:	57 1f       	adc	r21, r23
    74dc:	2a ed       	ldi	r18, 0xDA	; 218
    74de:	34 e0       	ldi	r19, 0x04	; 4
    74e0:	fd 01       	movw	r30, r26
    74e2:	ee 0f       	add	r30, r30
    74e4:	ff 1f       	adc	r31, r31
    74e6:	ee 0f       	add	r30, r30
    74e8:	ff 1f       	adc	r31, r31
    74ea:	ee 0f       	add	r30, r30
    74ec:	ff 1f       	adc	r31, r31
    74ee:	e2 0f       	add	r30, r18
    74f0:	f3 1f       	adc	r31, r19
    74f2:	90 81       	ld	r25, Z
    74f4:	ea 01       	movw	r28, r20
    74f6:	98 83       	st	Y, r25
	MB_Frame[MB_N][1] = MB_SingleQuery[MB_N].Func;
    74f8:	91 81       	ldd	r25, Z+1	; 0x01
    74fa:	99 83       	std	Y+1, r25	; 0x01
	MB_Frame[MB_N][2] = MB_SingleQuery[MB_N].StartAddr>>8;
    74fc:	fd 01       	movw	r30, r26
    74fe:	ee 0f       	add	r30, r30
    7500:	ff 1f       	adc	r31, r31
    7502:	ee 0f       	add	r30, r30
    7504:	ff 1f       	adc	r31, r31
    7506:	ee 0f       	add	r30, r30
    7508:	ff 1f       	adc	r31, r31
    750a:	32 96       	adiw	r30, 0x02	; 2
    750c:	e2 0f       	add	r30, r18
    750e:	f3 1f       	adc	r31, r19
    7510:	10 81       	ld	r17, Z
    7512:	91 81       	ldd	r25, Z+1	; 0x01
    7514:	fa 01       	movw	r30, r20
    7516:	92 83       	std	Z+2, r25	; 0x02
	MB_Frame[MB_N][3] = MB_SingleQuery[MB_N].StartAddr;
    7518:	1b 83       	std	Y+3, r17	; 0x03
	MB_Frame[MB_N][4] = MB_SingleQuery[MB_N].Qt>>8;
    751a:	fd 01       	movw	r30, r26
    751c:	ee 0f       	add	r30, r30
    751e:	ff 1f       	adc	r31, r31
    7520:	ee 0f       	add	r30, r30
    7522:	ff 1f       	adc	r31, r31
    7524:	ee 0f       	add	r30, r30
    7526:	ff 1f       	adc	r31, r31
    7528:	34 96       	adiw	r30, 0x04	; 4
    752a:	e2 0f       	add	r30, r18
    752c:	f3 1f       	adc	r31, r19
    752e:	10 81       	ld	r17, Z
    7530:	91 81       	ldd	r25, Z+1	; 0x01
    7532:	9c 83       	std	Y+4, r25	; 0x04
	MB_Frame[MB_N][5] = MB_SingleQuery[MB_N].Qt;
    7534:	1d 83       	std	Y+5, r17	; 0x05
	
	MB_SingleState[MB_N] = MB_SingleExec;
    7536:	a1 55       	subi	r26, 0x51	; 81
    7538:	b9 4f       	sbci	r27, 0xF9	; 249
    753a:	92 e0       	ldi	r25, 0x02	; 2
    753c:	9c 93       	st	X, r25
	FormData(MB_N);
    753e:	0e 94 e9 38 	call	0x71d2	; 0x71d2 <FormData>
}
    7542:	df 91       	pop	r29
    7544:	cf 91       	pop	r28
    7546:	1f 91       	pop	r17
    7548:	08 95       	ret

0000754a <NextSlave>:

// ~~~~~~~~~~~~~~~~~~~~
static uint8_t
NextSlave(uint8_t MB_N)
{
    754a:	2f 92       	push	r2
    754c:	3f 92       	push	r3
    754e:	4f 92       	push	r4
    7550:	5f 92       	push	r5
    7552:	6f 92       	push	r6
    7554:	7f 92       	push	r7
    7556:	8f 92       	push	r8
    7558:	9f 92       	push	r9
    755a:	af 92       	push	r10
    755c:	bf 92       	push	r11
    755e:	cf 92       	push	r12
    7560:	df 92       	push	r13
    7562:	ef 92       	push	r14
    7564:	ff 92       	push	r15
    7566:	0f 93       	push	r16
    7568:	1f 93       	push	r17
    756a:	df 93       	push	r29
    756c:	cf 93       	push	r28
    756e:	00 d0       	rcall	.+0      	; 0x7570 <NextSlave+0x26>
    7570:	00 d0       	rcall	.+0      	; 0x7572 <NextSlave+0x28>
    7572:	cd b7       	in	r28, 0x3d	; 61
    7574:	de b7       	in	r29, 0x3e	; 62
    7576:	68 2e       	mov	r6, r24
    7578:	e3 e0       	ldi	r30, 0x03	; 3
    757a:	8e 9f       	mul	r24, r30
    757c:	f0 01       	movw	r30, r0
    757e:	11 24       	eor	r1, r1
    7580:	e3 5b       	subi	r30, 0xB3	; 179
    7582:	f6 4d       	sbci	r31, 0xD6	; 214
    7584:	04 91       	lpm	r16, Z+
    7586:	c8 2e       	mov	r12, r24
    7588:	dd 24       	eor	r13, r13
    758a:	a6 01       	movw	r20, r12
    758c:	4c 5a       	subi	r20, 0xAC	; 172
    758e:	59 4f       	sbci	r21, 0xF9	; 249
    7590:	5e 83       	std	Y+6, r21	; 0x06
    7592:	4d 83       	std	Y+5, r20	; 0x05
    7594:	fa 01       	movw	r30, r20
    7596:	20 81       	ld	r18, Z
    7598:	16 01       	movw	r2, r12
    759a:	22 0c       	add	r2, r2
    759c:	33 1c       	adc	r3, r3
    759e:	22 0c       	add	r2, r2
    75a0:	33 1c       	adc	r3, r3
    75a2:	f1 01       	movw	r30, r2
    75a4:	ec 51       	subi	r30, 0x1C	; 28
    75a6:	fb 4f       	sbci	r31, 0xFB	; 251
    75a8:	80 80       	ld	r8, Z
    75aa:	91 80       	ldd	r9, Z+1	; 0x01
    75ac:	a2 80       	ldd	r10, Z+2	; 0x02
    75ae:	b3 80       	ldd	r11, Z+3	; 0x03
	do
		if (++CurrSlave[MB_N]==SlaveQt) {
			CurrSlave[MB_N] = 0;
			Over = 1;

			if ((MB_Master_Cycle[MB_N]=0xFFFF-GetTimer16(TD_MB_Cycle+MB_N))>MB_Master_MaxCycle[MB_N])
    75b0:	70 90 e8 04 	lds	r7, 0x04E8
    75b4:	f2 e0       	ldi	r31, 0x02	; 2
    75b6:	7f 0e       	add	r7, r31
    75b8:	47 2d       	mov	r20, r7
    75ba:	48 0f       	add	r20, r24
    75bc:	4a 83       	std	Y+2, r20	; 0x02
    75be:	5e ef       	ldi	r21, 0xFE	; 254
    75c0:	75 0e       	add	r7, r21
// ~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
GetTimer16(uint8_t TimerN)
{
	IntOff();
	uint16_t Time = Timer16[TimerN];
    75c2:	e4 2e       	mov	r14, r20
    75c4:	ff 24       	eor	r15, r15
    75c6:	19 82       	std	Y+1, r1	; 0x01
    75c8:	10 e0       	ldi	r17, 0x00	; 0
    75ca:	ee 0c       	add	r14, r14
    75cc:	ff 1c       	adc	r15, r15
    75ce:	8f e4       	ldi	r24, 0x4F	; 79
    75d0:	93 e0       	ldi	r25, 0x03	; 3
    75d2:	e8 0e       	add	r14, r24
    75d4:	f9 1e       	adc	r15, r25
    75d6:	c6 01       	movw	r24, r12
    75d8:	88 0f       	add	r24, r24
    75da:	99 1f       	adc	r25, r25
    75dc:	fc 01       	movw	r30, r24
    75de:	e8 54       	subi	r30, 0x48	; 72
    75e0:	f8 4f       	sbci	r31, 0xF8	; 248
    75e2:	fc 83       	std	Y+4, r31	; 0x04
    75e4:	eb 83       	std	Y+3, r30	; 0x03
    75e6:	ff ef       	ldi	r31, 0xFF	; 255
    75e8:	4f 2e       	mov	r4, r31
    75ea:	f6 e0       	ldi	r31, 0x06	; 6
    75ec:	5f 2e       	mov	r5, r31
    75ee:	48 0e       	add	r4, r24
    75f0:	59 1e       	adc	r5, r25
    75f2:	14 c0       	rjmp	.+40     	; 0x761c <NextSlave+0xd2>
				MB_Master_MaxCycle[MB_N] = MB_Master_Cycle[MB_N];
			StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
		}
	while (SlaveSkip[MB_N] &((uint32_t)1<<CurrSlave[MB_N]) && ++i<SlaveQt);
    75f4:	ed 81       	ldd	r30, Y+5	; 0x05
    75f6:	fe 81       	ldd	r31, Y+6	; 0x06
    75f8:	20 81       	ld	r18, Z
    75fa:	d5 01       	movw	r26, r10
    75fc:	c4 01       	movw	r24, r8
    75fe:	02 2e       	mov	r0, r18
    7600:	04 c0       	rjmp	.+8      	; 0x760a <NextSlave+0xc0>
    7602:	b6 95       	lsr	r27
    7604:	a7 95       	ror	r26
    7606:	97 95       	ror	r25
    7608:	87 95       	ror	r24
    760a:	0a 94       	dec	r0
    760c:	d2 f7       	brpl	.-12     	; 0x7602 <NextSlave+0xb8>
    760e:	81 70       	andi	r24, 0x01	; 1
    7610:	90 70       	andi	r25, 0x00	; 0
    7612:	88 23       	and	r24, r24
    7614:	61 f1       	breq	.+88     	; 0x766e <NextSlave+0x124>
    7616:	1f 5f       	subi	r17, 0xFF	; 255
    7618:	10 17       	cp	r17, r16
    761a:	48 f5       	brcc	.+82     	; 0x766e <NextSlave+0x124>
{
	uint8_t Over = 0;
	uint8_t i = 0;
	uint8_t SlaveQt = prb(&(MB_Master_List+MB_N)->SlaveQt);
	do
		if (++CurrSlave[MB_N]==SlaveQt) {
    761c:	82 2f       	mov	r24, r18
    761e:	8f 5f       	subi	r24, 0xFF	; 255
    7620:	ed 81       	ldd	r30, Y+5	; 0x05
    7622:	fe 81       	ldd	r31, Y+6	; 0x06
    7624:	80 83       	st	Z, r24
    7626:	80 17       	cp	r24, r16
    7628:	29 f7       	brne	.-54     	; 0x75f4 <NextSlave+0xaa>
			CurrSlave[MB_N] = 0;
    762a:	10 82       	st	Z, r1

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    762c:	8f b7       	in	r24, 0x3f	; 63
    762e:	80 78       	andi	r24, 0x80	; 128
    7630:	80 93 ee 02 	sts	0x02EE, r24
	cli();
    7634:	f8 94       	cli
    7636:	f7 01       	movw	r30, r14
    7638:	20 81       	ld	r18, Z
    763a:	31 81       	ldd	r19, Z+1	; 0x01

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    763c:	88 23       	and	r24, r24
    763e:	09 f0       	breq	.+2      	; 0x7642 <NextSlave+0xf8>
		sei();
    7640:	78 94       	sei
			Over = 1;

			if ((MB_Master_Cycle[MB_N]=0xFFFF-GetTimer16(TD_MB_Cycle+MB_N))>MB_Master_MaxCycle[MB_N])
    7642:	20 95       	com	r18
    7644:	30 95       	com	r19
    7646:	eb 81       	ldd	r30, Y+3	; 0x03
    7648:	fc 81       	ldd	r31, Y+4	; 0x04
    764a:	31 83       	std	Z+1, r19	; 0x01
    764c:	20 83       	st	Z, r18
    764e:	f2 01       	movw	r30, r4
    7650:	80 81       	ld	r24, Z
    7652:	91 81       	ldd	r25, Z+1	; 0x01
    7654:	82 17       	cp	r24, r18
    7656:	93 07       	cpc	r25, r19
    7658:	10 f4       	brcc	.+4      	; 0x765e <NextSlave+0x114>
				MB_Master_MaxCycle[MB_N] = MB_Master_Cycle[MB_N];
    765a:	31 83       	std	Z+1, r19	; 0x01
    765c:	20 83       	st	Z, r18
			StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
    765e:	8a 81       	ldd	r24, Y+2	; 0x02
    7660:	6f ef       	ldi	r22, 0xFF	; 255
    7662:	7f ef       	ldi	r23, 0xFF	; 255
    7664:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
    7668:	f1 e0       	ldi	r31, 0x01	; 1
    766a:	f9 83       	std	Y+1, r31	; 0x01
    766c:	c3 cf       	rjmp	.-122    	; 0x75f4 <NextSlave+0xaa>
		}
	while (SlaveSkip[MB_N] &((uint32_t)1<<CurrSlave[MB_N]) && ++i<SlaveQt);
	if (i==SlaveQt) {
    766e:	10 17       	cp	r17, r16
    7670:	01 f1       	breq	.+64     	; 0x76b2 <NextSlave+0x168>
		SlavesOn(MB_N);
		if (++CurrSlave[MB_N]==SlaveQt)
			CurrSlave[MB_N] = 0;
	}
	CurrQuery[MB_N] = 0;
    7672:	45 e5       	ldi	r20, 0x55	; 85
    7674:	56 e0       	ldi	r21, 0x06	; 6
    7676:	c4 0e       	add	r12, r20
    7678:	d5 1e       	adc	r13, r21
    767a:	f6 01       	movw	r30, r12
    767c:	10 82       	st	Z, r1
	return Over;
}
    767e:	89 81       	ldd	r24, Y+1	; 0x01
    7680:	26 96       	adiw	r28, 0x06	; 6
    7682:	0f b6       	in	r0, 0x3f	; 63
    7684:	f8 94       	cli
    7686:	de bf       	out	0x3e, r29	; 62
    7688:	0f be       	out	0x3f, r0	; 63
    768a:	cd bf       	out	0x3d, r28	; 61
    768c:	cf 91       	pop	r28
    768e:	df 91       	pop	r29
    7690:	1f 91       	pop	r17
    7692:	0f 91       	pop	r16
    7694:	ff 90       	pop	r15
    7696:	ef 90       	pop	r14
    7698:	df 90       	pop	r13
    769a:	cf 90       	pop	r12
    769c:	bf 90       	pop	r11
    769e:	af 90       	pop	r10
    76a0:	9f 90       	pop	r9
    76a2:	8f 90       	pop	r8
    76a4:	7f 90       	pop	r7
    76a6:	6f 90       	pop	r6
    76a8:	5f 90       	pop	r5
    76aa:	4f 90       	pop	r4
    76ac:	3f 90       	pop	r3
    76ae:	2f 90       	pop	r2
    76b0:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~
static void
SlavesOn(uint8_t MB_N)
{
	SlaveSkip[MB_N] = 0;
    76b2:	44 ee       	ldi	r20, 0xE4	; 228
    76b4:	54 e0       	ldi	r21, 0x04	; 4
    76b6:	24 0e       	add	r2, r20
    76b8:	35 1e       	adc	r3, r21
    76ba:	f1 01       	movw	r30, r2
    76bc:	10 82       	st	Z, r1
    76be:	11 82       	std	Z+1, r1	; 0x01
    76c0:	12 82       	std	Z+2, r1	; 0x02
    76c2:	13 82       	std	Z+3, r1	; 0x03
	StartTimer16(TD_MB_SlaveOff+MB_N, 100*MB_M_TimeOff[MB_N]);
    76c4:	73 94       	inc	r7
    76c6:	f6 01       	movw	r30, r12
    76c8:	e1 52       	subi	r30, 0x21	; 33
    76ca:	fa 4f       	sbci	r31, 0xFA	; 250
    76cc:	60 81       	ld	r22, Z
    76ce:	84 e6       	ldi	r24, 0x64	; 100
    76d0:	68 9f       	mul	r22, r24
    76d2:	b0 01       	movw	r22, r0
    76d4:	11 24       	eor	r1, r1
    76d6:	87 2d       	mov	r24, r7
    76d8:	86 0d       	add	r24, r6
    76da:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
			StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
		}
	while (SlaveSkip[MB_N] &((uint32_t)1<<CurrSlave[MB_N]) && ++i<SlaveQt);
	if (i==SlaveQt) {
		SlavesOn(MB_N);
		if (++CurrSlave[MB_N]==SlaveQt)
    76de:	ed 81       	ldd	r30, Y+5	; 0x05
    76e0:	fe 81       	ldd	r31, Y+6	; 0x06
    76e2:	80 81       	ld	r24, Z
    76e4:	8f 5f       	subi	r24, 0xFF	; 255
    76e6:	80 83       	st	Z, r24
    76e8:	18 17       	cp	r17, r24
    76ea:	19 f6       	brne	.-122    	; 0x7672 <NextSlave+0x128>
			CurrSlave[MB_N] = 0;
    76ec:	10 82       	st	Z, r1
    76ee:	c1 cf       	rjmp	.-126    	; 0x7672 <NextSlave+0x128>

000076f0 <FailSlave>:
}

// ~~~~~~~~~~~~~~~~~~~~
static uint8_t
FailSlave(uint8_t MB_N)
{
    76f0:	ef 92       	push	r14
    76f2:	ff 92       	push	r15
    76f4:	1f 93       	push	r17
    76f6:	cf 93       	push	r28
    76f8:	df 93       	push	r29
    76fa:	18 2f       	mov	r17, r24
	uint8_t Over = 0;
	if (MB_SingleState[MB_N]==MB_SingleExec)
    76fc:	68 2f       	mov	r22, r24
    76fe:	70 e0       	ldi	r23, 0x00	; 0
    7700:	fb 01       	movw	r30, r22
    7702:	e1 55       	subi	r30, 0x51	; 81
    7704:	f9 4f       	sbci	r31, 0xF9	; 249
    7706:	80 81       	ld	r24, Z
    7708:	82 30       	cpi	r24, 0x02	; 2
    770a:	19 f1       	breq	.+70     	; 0x7752 <FailSlave+0x62>
		MB_SingleState[MB_N] = MB_SingleIdle;
	else{
		MB_CPT[MB_N][4]++;	// -    
    770c:	fb 01       	movw	r30, r22
    770e:	ee 0f       	add	r30, r30
    7710:	ff 1f       	adc	r31, r31
    7712:	ee 0f       	add	r30, r30
    7714:	ff 1f       	adc	r31, r31
    7716:	ee 0f       	add	r30, r30
    7718:	ff 1f       	adc	r31, r31
    771a:	ee 0f       	add	r30, r30
    771c:	ff 1f       	adc	r31, r31
    771e:	e2 5c       	subi	r30, 0xC2	; 194
    7720:	f6 4f       	sbci	r31, 0xF6	; 246
    7722:	80 81       	ld	r24, Z
    7724:	91 81       	ldd	r25, Z+1	; 0x01
    7726:	01 96       	adiw	r24, 0x01	; 1
    7728:	91 83       	std	Z+1, r25	; 0x01
    772a:	80 83       	st	Z, r24
		if (++Try[MB_N]==MB_M_Try[MB_N]) {
    772c:	eb 01       	movw	r28, r22
    772e:	cd 51       	subi	r28, 0x1D	; 29
    7730:	db 4f       	sbci	r29, 0xFB	; 251
    7732:	88 81       	ld	r24, Y
    7734:	8f 5f       	subi	r24, 0xFF	; 255
    7736:	88 83       	st	Y, r24
    7738:	fb 01       	movw	r30, r22
    773a:	e1 5c       	subi	r30, 0xC1	; 193
    773c:	f8 4f       	sbci	r31, 0xF8	; 248
    773e:	90 81       	ld	r25, Z
    7740:	89 17       	cp	r24, r25
    7742:	79 f0       	breq	.+30     	; 0x7762 <FailSlave+0x72>
    7744:	80 e0       	ldi	r24, 0x00	; 0
			Try[MB_N] = 0;
			Over = NextSlave(MB_N);
		}
	}
	return Over;
}
    7746:	df 91       	pop	r29
    7748:	cf 91       	pop	r28
    774a:	1f 91       	pop	r17
    774c:	ff 90       	pop	r15
    774e:	ef 90       	pop	r14
    7750:	08 95       	ret
static uint8_t
FailSlave(uint8_t MB_N)
{
	uint8_t Over = 0;
	if (MB_SingleState[MB_N]==MB_SingleExec)
		MB_SingleState[MB_N] = MB_SingleIdle;
    7752:	10 82       	st	Z, r1
    7754:	80 e0       	ldi	r24, 0x00	; 0
			Try[MB_N] = 0;
			Over = NextSlave(MB_N);
		}
	}
	return Over;
}
    7756:	df 91       	pop	r29
    7758:	cf 91       	pop	r28
    775a:	1f 91       	pop	r17
    775c:	ff 90       	pop	r15
    775e:	ef 90       	pop	r14
    7760:	08 95       	ret
	if (MB_SingleState[MB_N]==MB_SingleExec)
		MB_SingleState[MB_N] = MB_SingleIdle;
	else{
		MB_CPT[MB_N][4]++;	// -    
		if (++Try[MB_N]==MB_M_Try[MB_N]) {
			uint32_t S_N = (uint32_t)1<<CurrSlave[MB_N];
    7762:	fb 01       	movw	r30, r22
    7764:	ec 5a       	subi	r30, 0xAC	; 172
    7766:	f9 4f       	sbci	r31, 0xF9	; 249
    7768:	21 e0       	ldi	r18, 0x01	; 1
    776a:	30 e0       	ldi	r19, 0x00	; 0
    776c:	40 e0       	ldi	r20, 0x00	; 0
    776e:	50 e0       	ldi	r21, 0x00	; 0
    7770:	00 80       	ld	r0, Z
    7772:	04 c0       	rjmp	.+8      	; 0x777c <FailSlave+0x8c>
    7774:	22 0f       	add	r18, r18
    7776:	33 1f       	adc	r19, r19
    7778:	44 1f       	adc	r20, r20
    777a:	55 1f       	adc	r21, r21
    777c:	0a 94       	dec	r0
    777e:	d2 f7       	brpl	.-12     	; 0x7774 <FailSlave+0x84>
			SlaveOff[MB_N] |=S_N;
    7780:	7b 01       	movw	r14, r22
    7782:	ee 0c       	add	r14, r14
    7784:	ff 1c       	adc	r15, r15
    7786:	ee 0c       	add	r14, r14
    7788:	ff 1c       	adc	r15, r15
    778a:	b7 01       	movw	r22, r14
    778c:	63 5d       	subi	r22, 0xD3	; 211
    778e:	76 4f       	sbci	r23, 0xF6	; 246
    7790:	fb 01       	movw	r30, r22
    7792:	80 81       	ld	r24, Z
    7794:	91 81       	ldd	r25, Z+1	; 0x01
    7796:	a2 81       	ldd	r26, Z+2	; 0x02
    7798:	b3 81       	ldd	r27, Z+3	; 0x03
    779a:	82 2b       	or	r24, r18
    779c:	93 2b       	or	r25, r19
    779e:	a4 2b       	or	r26, r20
    77a0:	b5 2b       	or	r27, r21
    77a2:	80 83       	st	Z, r24
    77a4:	91 83       	std	Z+1, r25	; 0x01
    77a6:	a2 83       	std	Z+2, r26	; 0x02
    77a8:	b3 83       	std	Z+3, r27	; 0x03
			SlaveSkip[MB_N] |=S_N;
    77aa:	f7 01       	movw	r30, r14
    77ac:	ec 51       	subi	r30, 0x1C	; 28
    77ae:	fb 4f       	sbci	r31, 0xFB	; 251
    77b0:	80 81       	ld	r24, Z
    77b2:	91 81       	ldd	r25, Z+1	; 0x01
    77b4:	a2 81       	ldd	r26, Z+2	; 0x02
    77b6:	b3 81       	ldd	r27, Z+3	; 0x03
    77b8:	28 2b       	or	r18, r24
    77ba:	39 2b       	or	r19, r25
    77bc:	4a 2b       	or	r20, r26
    77be:	5b 2b       	or	r21, r27
    77c0:	20 83       	st	Z, r18
    77c2:	31 83       	std	Z+1, r19	; 0x01
    77c4:	42 83       	std	Z+2, r20	; 0x02
    77c6:	53 83       	std	Z+3, r21	; 0x03
			Try[MB_N] = 0;
    77c8:	18 82       	st	Y, r1
			Over = NextSlave(MB_N);
    77ca:	81 2f       	mov	r24, r17
    77cc:	0e 94 a5 3a 	call	0x754a	; 0x754a <NextSlave>
		}
	}
	return Over;
}
    77d0:	df 91       	pop	r29
    77d2:	cf 91       	pop	r28
    77d4:	1f 91       	pop	r17
    77d6:	ff 90       	pop	r15
    77d8:	ef 90       	pop	r14
    77da:	08 95       	ret

000077dc <MB_M_Timer_ISR>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_M_Timer_ISR(uint8_t MB_N)
{
    77dc:	4f 92       	push	r4
    77de:	5f 92       	push	r5
    77e0:	6f 92       	push	r6
    77e2:	7f 92       	push	r7
    77e4:	8f 92       	push	r8
    77e6:	9f 92       	push	r9
    77e8:	af 92       	push	r10
    77ea:	bf 92       	push	r11
    77ec:	cf 92       	push	r12
    77ee:	df 92       	push	r13
    77f0:	ef 92       	push	r14
    77f2:	ff 92       	push	r15
    77f4:	0f 93       	push	r16
    77f6:	1f 93       	push	r17
    77f8:	cf 93       	push	r28
    77fa:	df 93       	push	r29
    77fc:	18 2f       	mov	r17, r24
	switch (MB_State[MB_N]) {
    77fe:	c8 2f       	mov	r28, r24
    7800:	d0 e0       	ldi	r29, 0x00	; 0
    7802:	fe 01       	movw	r30, r28
    7804:	ee 53       	subi	r30, 0x3E	; 62
    7806:	fa 4f       	sbci	r31, 0xFA	; 250
    7808:	80 81       	ld	r24, Z
    780a:	88 23       	and	r24, r24
    780c:	f9 f4       	brne	.+62     	; 0x784c <MB_M_Timer_ISR+0x70>
	case MB_Initi:
		StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
    780e:	80 91 e8 04 	lds	r24, 0x04E8
    7812:	8e 5f       	subi	r24, 0xFE	; 254
    7814:	81 0f       	add	r24, r17
    7816:	6f ef       	ldi	r22, 0xFF	; 255
    7818:	7f ef       	ldi	r23, 0xFF	; 255
    781a:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
		FormQuery(MB_N);
    781e:	81 2f       	mov	r24, r17
    7820:	0e 94 11 3a 	call	0x7422	; 0x7422 <FormQuery>
		MB_Transm(MB_N);
    7824:	81 2f       	mov	r24, r17
    7826:	0e 94 09 33 	call	0x6612	; 0x6612 <MB_Transm>
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
		MB_M_CtrlProc(MB_N);
		break;
	}
}
    782a:	df 91       	pop	r29
    782c:	cf 91       	pop	r28
    782e:	1f 91       	pop	r17
    7830:	0f 91       	pop	r16
    7832:	ff 90       	pop	r15
    7834:	ef 90       	pop	r14
    7836:	df 90       	pop	r13
    7838:	cf 90       	pop	r12
    783a:	bf 90       	pop	r11
    783c:	af 90       	pop	r10
    783e:	9f 90       	pop	r9
    7840:	8f 90       	pop	r8
    7842:	7f 90       	pop	r7
    7844:	6f 90       	pop	r6
    7846:	5f 90       	pop	r5
    7848:	4f 90       	pop	r4
    784a:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_M_Timer_ISR(uint8_t MB_N)
{
	switch (MB_State[MB_N]) {
    784c:	82 30       	cpi	r24, 0x02	; 2
    784e:	69 f7       	brne	.-38     	; 0x782a <MB_M_Timer_ISR+0x4e>
		StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
		FormQuery(MB_N);
		MB_Transm(MB_N);
		break;
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
    7850:	84 e0       	ldi	r24, 0x04	; 4
    7852:	80 83       	st	Z, r24
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
MB_M_CtrlProc(uint8_t MB_N)
{
	uint8_t Over = 0;
	LastProcSingle = MB_SingleState[MB_N]==MB_SingleExec;
    7854:	ef ea       	ldi	r30, 0xAF	; 175
    7856:	ae 2e       	mov	r10, r30
    7858:	e6 e0       	ldi	r30, 0x06	; 6
    785a:	be 2e       	mov	r11, r30
    785c:	ac 0e       	add	r10, r28
    785e:	bd 1e       	adc	r11, r29
    7860:	d5 01       	movw	r26, r10
    7862:	8c 91       	ld	r24, X
    7864:	90 e0       	ldi	r25, 0x00	; 0
    7866:	82 30       	cpi	r24, 0x02	; 2
    7868:	09 f4       	brne	.+2      	; 0x786c <MB_M_Timer_ISR+0x90>
    786a:	4e c0       	rjmp	.+156    	; 0x7908 <MB_M_Timer_ISR+0x12c>
    786c:	90 93 e2 04 	sts	0x04E2, r25
	if (CommErr(MB_N))
    7870:	81 2f       	mov	r24, r17
    7872:	0e 94 ed 33 	call	0x67da	; 0x67da <CommErr>
    7876:	88 23       	and	r24, r24
    7878:	91 f5       	brne	.+100    	; 0x78de <MB_M_Timer_ISR+0x102>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    787a:	7e 01       	movw	r14, r28
    787c:	ee 0c       	add	r14, r14
    787e:	ff 1c       	adc	r15, r15
    7880:	ee 0c       	add	r14, r14
    7882:	ff 1c       	adc	r15, r15
    7884:	c7 01       	movw	r24, r14
    7886:	88 0f       	add	r24, r24
    7888:	99 1f       	adc	r25, r25
    788a:	88 0f       	add	r24, r24
    788c:	99 1f       	adc	r25, r25
    788e:	8e 0d       	add	r24, r14
    7890:	9f 1d       	adc	r25, r15
    7892:	86 56       	subi	r24, 0x66	; 102
    7894:	9f 4b       	sbci	r25, 0xBF	; 191
    7896:	fc 01       	movw	r30, r24
    7898:	25 91       	lpm	r18, Z+
    789a:	34 91       	lpm	r19, Z+
		Over = FailSlave(MB_N);
	else {
		USART_Func(MB_N, LED);
    789c:	f9 01       	movw	r30, r18
    789e:	19 95       	eicall
		MB_Slave *Slave;
		MB_Query *Query;
		uint8_t Addr, Func;
		if (LastProcSingle) {
    78a0:	80 91 e2 04 	lds	r24, 0x04E2
    78a4:	88 23       	and	r24, r24
    78a6:	91 f1       	breq	.+100    	; 0x790c <MB_M_Timer_ISR+0x130>
			Addr = MB_SingleQuery[MB_N].Addr;
    78a8:	fe 01       	movw	r30, r28
    78aa:	ee 0f       	add	r30, r30
    78ac:	ff 1f       	adc	r31, r31
    78ae:	ee 0f       	add	r30, r30
    78b0:	ff 1f       	adc	r31, r31
    78b2:	ee 0f       	add	r30, r30
    78b4:	ff 1f       	adc	r31, r31
    78b6:	e6 52       	subi	r30, 0x26	; 38
    78b8:	fb 4f       	sbci	r31, 0xFB	; 251
    78ba:	20 81       	ld	r18, Z
			Func = MB_SingleQuery[MB_N].Func;
    78bc:	91 81       	ldd	r25, Z+1	; 0x01
    78be:	40 e0       	ldi	r20, 0x00	; 0
    78c0:	50 e0       	ldi	r21, 0x00	; 0
    78c2:	60 e0       	ldi	r22, 0x00	; 0
    78c4:	70 e0       	ldi	r23, 0x00	; 0
			Slave = GetSlave(MB_N);
			Query = (MB_Query*)prp(&Slave->QueryList)+CurrQuery[MB_N];
			Addr = prb(&Slave->Addr);
			Func = prb(&Query->Func);
		}
		if (MB_Frame[MB_N][0]!=Addr || MB_Frame[MB_N][1]!=Func)
    78c6:	dc 2e       	mov	r13, r28
    78c8:	cc 24       	eor	r12, r12
    78ca:	f6 01       	movw	r30, r12
    78cc:	e5 59       	subi	r30, 0x95	; 149
    78ce:	f4 4f       	sbci	r31, 0xF4	; 244
    78d0:	80 81       	ld	r24, Z
    78d2:	82 17       	cp	r24, r18
    78d4:	21 f4       	brne	.+8      	; 0x78de <MB_M_Timer_ISR+0x102>
    78d6:	a1 81       	ldd	r26, Z+1	; 0x01
    78d8:	a9 17       	cp	r26, r25
    78da:	09 f4       	brne	.+2      	; 0x78de <MB_M_Timer_ISR+0x102>
    78dc:	3d c0       	rjmp	.+122    	; 0x7958 <MB_M_Timer_ISR+0x17c>
				Err = MB_M_Force(MB_N, Query);
				break;
			}
			if (Err) {
				MB_CPT[MB_N][2]++;
				Over = FailSlave(MB_N);
    78de:	81 2f       	mov	r24, r17
    78e0:	0e 94 78 3b 	call	0x76f0	; 0x76f0 <FailSlave>
    78e4:	98 2f       	mov	r25, r24
			}
		}
		/*if (Over)
			USART_Func(MB_N, LED);*/
	}
	StartTimer16(TD_MB_Idle+MB_N, Over?MB_M_Period[MB_N]:MB_M_Pause_Min);
    78e6:	80 91 e8 04 	lds	r24, 0x04E8
    78ea:	81 0f       	add	r24, r17
    78ec:	99 23       	and	r25, r25
    78ee:	49 f0       	breq	.+18     	; 0x7902 <MB_M_Timer_ISR+0x126>
    78f0:	cc 0f       	add	r28, r28
    78f2:	dd 1f       	adc	r29, r29
    78f4:	c3 55       	subi	r28, 0x53	; 83
    78f6:	d9 4f       	sbci	r29, 0xF9	; 249
    78f8:	68 81       	ld	r22, Y
    78fa:	79 81       	ldd	r23, Y+1	; 0x01
    78fc:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
    7900:	94 cf       	rjmp	.-216    	; 0x782a <MB_M_Timer_ISR+0x4e>
    7902:	65 e0       	ldi	r22, 0x05	; 5
    7904:	70 e0       	ldi	r23, 0x00	; 0
    7906:	fa cf       	rjmp	.-12     	; 0x78fc <MB_M_Timer_ISR+0x120>
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
MB_M_CtrlProc(uint8_t MB_N)
{
	uint8_t Over = 0;
	LastProcSingle = MB_SingleState[MB_N]==MB_SingleExec;
    7908:	91 e0       	ldi	r25, 0x01	; 1
    790a:	b0 cf       	rjmp	.-160    	; 0x786c <MB_M_Timer_ISR+0x90>
    790c:	83 e0       	ldi	r24, 0x03	; 3
    790e:	18 9f       	mul	r17, r24
    7910:	f0 01       	movw	r30, r0
    7912:	11 24       	eor	r1, r1
    7914:	e5 5b       	subi	r30, 0xB5	; 181
    7916:	f6 4d       	sbci	r31, 0xD6	; 214
    7918:	65 91       	lpm	r22, Z+
    791a:	74 91       	lpm	r23, Z+

// ~~~~~~~~~~~~~~~~~~~
static MB_Slave*
GetSlave(uint8_t MB_N)
{
	return (MB_Slave*)prp(&(MB_Master_List+MB_N)->SlaveList)+CurrSlave[MB_N];
    791c:	fe 01       	movw	r30, r28
    791e:	ec 5a       	subi	r30, 0xAC	; 172
    7920:	f9 4f       	sbci	r31, 0xF9	; 249
    7922:	80 81       	ld	r24, Z
    7924:	90 e0       	ldi	r25, 0x00	; 0
    7926:	88 0f       	add	r24, r24
    7928:	99 1f       	adc	r25, r25
    792a:	88 0f       	add	r24, r24
    792c:	99 1f       	adc	r25, r25
    792e:	68 0f       	add	r22, r24
    7930:	79 1f       	adc	r23, r25
    7932:	fb 01       	movw	r30, r22
    7934:	31 96       	adiw	r30, 0x01	; 1
    7936:	45 91       	lpm	r20, Z+
    7938:	54 91       	lpm	r21, Z+
			Addr = MB_SingleQuery[MB_N].Addr;
			Func = MB_SingleQuery[MB_N].Func;
		}
		else {
			Slave = GetSlave(MB_N);
			Query = (MB_Query*)prp(&Slave->QueryList)+CurrQuery[MB_N];
    793a:	fe 01       	movw	r30, r28
    793c:	eb 5a       	subi	r30, 0xAB	; 171
    793e:	f9 4f       	sbci	r31, 0xF9	; 249
    7940:	80 81       	ld	r24, Z
    7942:	27 e0       	ldi	r18, 0x07	; 7
    7944:	82 9f       	mul	r24, r18
    7946:	c0 01       	movw	r24, r0
    7948:	11 24       	eor	r1, r1
    794a:	48 0f       	add	r20, r24
    794c:	59 1f       	adc	r21, r25

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    794e:	fb 01       	movw	r30, r22
    7950:	24 91       	lpm	r18, Z+
		}
		if (MB_Frame[MB_N][0]!=Addr || MB_Frame[MB_N][1]!=Func)
			Over = FailSlave(MB_N);
		else {
			uint8_t Err;
			switch (Func) {
    7952:	fa 01       	movw	r30, r20
    7954:	94 91       	lpm	r25, Z+
    7956:	b7 cf       	rjmp	.-146    	; 0x78c6 <MB_M_Timer_ISR+0xea>
    7958:	95 30       	cpi	r25, 0x05	; 5
    795a:	18 f5       	brcc	.+70     	; 0x79a2 <MB_M_Timer_ISR+0x1c6>
    795c:	93 30       	cpi	r25, 0x03	; 3
    795e:	08 f4       	brcc	.+2      	; 0x7962 <MB_M_Timer_ISR+0x186>
    7960:	ad c0       	rjmp	.+346    	; 0x7abc <MB_M_Timer_ISR+0x2e0>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_M_ReadReg(uint8_t MB_N, MB_Query *Query)
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || (LastProcSingle?MB_SingleQuery[MB_N].Qt:prw(&Query->Qt))*2!=MB_Frame[MB_N][2])
    7962:	fc 2f       	mov	r31, r28
    7964:	ee 27       	eor	r30, r30
    7966:	e3 59       	subi	r30, 0x93	; 147
    7968:	f4 4f       	sbci	r31, 0xF4	; 244
    796a:	b0 81       	ld	r27, Z
    796c:	fe 01       	movw	r30, r28
    796e:	e7 5b       	subi	r30, 0xB7	; 183
    7970:	f8 4f       	sbci	r31, 0xF8	; 248
    7972:	80 81       	ld	r24, Z
    7974:	90 e0       	ldi	r25, 0x00	; 0
    7976:	8b 2e       	mov	r8, r27
    7978:	99 24       	eor	r9, r9
    797a:	94 01       	movw	r18, r8
    797c:	2b 5f       	subi	r18, 0xFB	; 251
    797e:	3f 4f       	sbci	r19, 0xFF	; 255
    7980:	82 17       	cp	r24, r18
    7982:	93 07       	cpc	r25, r19
    7984:	09 f4       	brne	.+2      	; 0x7988 <MB_M_Timer_ISR+0x1ac>
    7986:	94 c1       	rjmp	.+808    	; 0x7cb0 <MB_M_Timer_ISR+0x4d4>
			case 0x0F: case 0x10:
				Err = MB_M_Force(MB_N, Query);
				break;
			}
			if (Err) {
				MB_CPT[MB_N][2]++;
    7988:	f7 01       	movw	r30, r14
    798a:	ee 0f       	add	r30, r30
    798c:	ff 1f       	adc	r31, r31
    798e:	ee 0f       	add	r30, r30
    7990:	ff 1f       	adc	r31, r31
    7992:	e6 5c       	subi	r30, 0xC6	; 198
    7994:	f6 4f       	sbci	r31, 0xF6	; 246
    7996:	80 81       	ld	r24, Z
    7998:	91 81       	ldd	r25, Z+1	; 0x01
    799a:	01 96       	adiw	r24, 0x01	; 1
    799c:	91 83       	std	Z+1, r25	; 0x01
    799e:	80 83       	st	Z, r24
    79a0:	9e cf       	rjmp	.-196    	; 0x78de <MB_M_Timer_ISR+0x102>
		}
		if (MB_Frame[MB_N][0]!=Addr || MB_Frame[MB_N][1]!=Func)
			Over = FailSlave(MB_N);
		else {
			uint8_t Err;
			switch (Func) {
    79a2:	96 30       	cpi	r25, 0x06	; 6
    79a4:	09 f4       	brne	.+2      	; 0x79a8 <MB_M_Timer_ISR+0x1cc>
    79a6:	18 c1       	rjmp	.+560    	; 0x7bd8 <MB_M_Timer_ISR+0x3fc>
    79a8:	96 30       	cpi	r25, 0x06	; 6
    79aa:	08 f4       	brcc	.+2      	; 0x79ae <MB_M_Timer_ISR+0x1d2>
    79ac:	43 c0       	rjmp	.+134    	; 0x7a34 <MB_M_Timer_ISR+0x258>
    79ae:	9f 50       	subi	r25, 0x0F	; 15
    79b0:	92 30       	cpi	r25, 0x02	; 2
    79b2:	08 f0       	brcs	.+2      	; 0x79b6 <MB_M_Timer_ISR+0x1da>
    79b4:	3f c0       	rjmp	.+126    	; 0x7a34 <MB_M_Timer_ISR+0x258>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_M_Force(uint8_t MB_N, MB_Query *Query)
{
	uint16_t StartAddr, Qt;
	if (LastProcSingle) {
    79b6:	80 91 e2 04 	lds	r24, 0x04E2
    79ba:	88 23       	and	r24, r24
    79bc:	09 f4       	brne	.+2      	; 0x79c0 <MB_M_Timer_ISR+0x1e4>
    79be:	4e c1       	rjmp	.+668    	; 0x7c5c <MB_M_Timer_ISR+0x480>
		StartAddr	= MB_SingleQuery[MB_N].StartAddr;
    79c0:	f7 01       	movw	r30, r14
    79c2:	ee 0f       	add	r30, r30
    79c4:	ff 1f       	adc	r31, r31
    79c6:	e4 52       	subi	r30, 0x24	; 36
    79c8:	fb 4f       	sbci	r31, 0xFB	; 251
    79ca:	80 80       	ld	r8, Z
    79cc:	91 80       	ldd	r9, Z+1	; 0x01
		Qt				= MB_SingleQuery[MB_N].Qt;
    79ce:	fe 01       	movw	r30, r28
    79d0:	ee 0f       	add	r30, r30
    79d2:	ff 1f       	adc	r31, r31
    79d4:	ee 0f       	add	r30, r30
    79d6:	ff 1f       	adc	r31, r31
    79d8:	ee 0f       	add	r30, r30
    79da:	ff 1f       	adc	r31, r31
    79dc:	e2 52       	subi	r30, 0x22	; 34
    79de:	fb 4f       	sbci	r31, 0xFB	; 251
    79e0:	40 81       	ld	r20, Z
    79e2:	51 81       	ldd	r21, Z+1	; 0x01
	}
	else {
		StartAddr	= prw(&Query->StartAddr);
		Qt				= prw(&Query->Qt);
	}
	return MB_Frame_Sz[MB_N]!=8 || MB_FrameReg(MB_N, 2)!=StartAddr || MB_FrameReg(MB_N, 4)!=Qt;
    79e4:	fe 01       	movw	r30, r28
    79e6:	e7 5b       	subi	r30, 0xB7	; 183
    79e8:	f8 4f       	sbci	r31, 0xF8	; 248
    79ea:	80 81       	ld	r24, Z
    79ec:	88 30       	cpi	r24, 0x08	; 8
    79ee:	61 f6       	brne	.-104    	; 0x7988 <MB_M_Timer_ISR+0x1ac>
    79f0:	fc 2f       	mov	r31, r28
    79f2:	ee 27       	eor	r30, r30
    79f4:	e3 59       	subi	r30, 0x93	; 147
    79f6:	f4 4f       	sbci	r31, 0xF4	; 244
    79f8:	30 81       	ld	r19, Z
    79fa:	20 e0       	ldi	r18, 0x00	; 0
    79fc:	d6 01       	movw	r26, r12
    79fe:	a5 59       	subi	r26, 0x95	; 149
    7a00:	b4 4f       	sbci	r27, 0xF4	; 244
    7a02:	13 96       	adiw	r26, 0x03	; 3
    7a04:	8c 91       	ld	r24, X
    7a06:	13 97       	sbiw	r26, 0x03	; 3
    7a08:	90 e0       	ldi	r25, 0x00	; 0
    7a0a:	28 2b       	or	r18, r24
    7a0c:	39 2b       	or	r19, r25
    7a0e:	28 15       	cp	r18, r8
    7a10:	39 05       	cpc	r19, r9
    7a12:	09 f0       	breq	.+2      	; 0x7a16 <MB_M_Timer_ISR+0x23a>
    7a14:	b9 cf       	rjmp	.-142    	; 0x7988 <MB_M_Timer_ISR+0x1ac>
    7a16:	fc 2f       	mov	r31, r28
    7a18:	ee 27       	eor	r30, r30
    7a1a:	e1 59       	subi	r30, 0x91	; 145
    7a1c:	f4 4f       	sbci	r31, 0xF4	; 244
    7a1e:	90 81       	ld	r25, Z
    7a20:	80 e0       	ldi	r24, 0x00	; 0
    7a22:	15 96       	adiw	r26, 0x05	; 5
    7a24:	2c 91       	ld	r18, X
    7a26:	30 e0       	ldi	r19, 0x00	; 0
    7a28:	82 2b       	or	r24, r18
    7a2a:	93 2b       	or	r25, r19
    7a2c:	84 17       	cp	r24, r20
    7a2e:	95 07       	cpc	r25, r21
    7a30:	09 f0       	breq	.+2      	; 0x7a34 <MB_M_Timer_ISR+0x258>
    7a32:	aa cf       	rjmp	.-172    	; 0x7988 <MB_M_Timer_ISR+0x1ac>
			}
			if (Err) {
				MB_CPT[MB_N][2]++;
				Over = FailSlave(MB_N);
			}
			else if (LastProcSingle)
    7a34:	80 91 e2 04 	lds	r24, 0x04E2
    7a38:	88 23       	and	r24, r24
    7a3a:	41 f0       	breq	.+16     	; 0x7a4c <MB_M_Timer_ISR+0x270>
				MB_SingleState[MB_N] = MB_SingleIdle;
    7a3c:	d5 01       	movw	r26, r10
    7a3e:	1c 92       	st	X, r1
			}
		}
		/*if (Over)
			USART_Func(MB_N, LED);*/
	}
	StartTimer16(TD_MB_Idle+MB_N, Over?MB_M_Period[MB_N]:MB_M_Pause_Min);
    7a40:	80 91 e8 04 	lds	r24, 0x04E8
    7a44:	81 0f       	add	r24, r17
    7a46:	65 e0       	ldi	r22, 0x05	; 5
    7a48:	70 e0       	ldi	r23, 0x00	; 0
    7a4a:	58 cf       	rjmp	.-336    	; 0x78fc <MB_M_Timer_ISR+0x120>
				Over = FailSlave(MB_N);
			}
			else if (LastProcSingle)
				MB_SingleState[MB_N] = MB_SingleIdle;
			else {
				SlaveOff[MB_N] &=~((uint32_t)1<<CurrSlave[MB_N]);
    7a4c:	ed e2       	ldi	r30, 0x2D	; 45
    7a4e:	f9 e0       	ldi	r31, 0x09	; 9
    7a50:	ee 0e       	add	r14, r30
    7a52:	ff 1e       	adc	r15, r31
    7a54:	9e 01       	movw	r18, r28
    7a56:	2c 5a       	subi	r18, 0xAC	; 172
    7a58:	39 4f       	sbci	r19, 0xF9	; 249
    7a5a:	81 e0       	ldi	r24, 0x01	; 1
    7a5c:	90 e0       	ldi	r25, 0x00	; 0
    7a5e:	a0 e0       	ldi	r26, 0x00	; 0
    7a60:	b0 e0       	ldi	r27, 0x00	; 0
    7a62:	f9 01       	movw	r30, r18
    7a64:	00 80       	ld	r0, Z
    7a66:	04 c0       	rjmp	.+8      	; 0x7a70 <MB_M_Timer_ISR+0x294>
    7a68:	88 0f       	add	r24, r24
    7a6a:	99 1f       	adc	r25, r25
    7a6c:	aa 1f       	adc	r26, r26
    7a6e:	bb 1f       	adc	r27, r27
    7a70:	0a 94       	dec	r0
    7a72:	d2 f7       	brpl	.-12     	; 0x7a68 <MB_M_Timer_ISR+0x28c>
    7a74:	80 95       	com	r24
    7a76:	90 95       	com	r25
    7a78:	a0 95       	com	r26
    7a7a:	b0 95       	com	r27
    7a7c:	f7 01       	movw	r30, r14
    7a7e:	20 81       	ld	r18, Z
    7a80:	31 81       	ldd	r19, Z+1	; 0x01
    7a82:	42 81       	ldd	r20, Z+2	; 0x02
    7a84:	53 81       	ldd	r21, Z+3	; 0x03
    7a86:	82 23       	and	r24, r18
    7a88:	93 23       	and	r25, r19
    7a8a:	a4 23       	and	r26, r20
    7a8c:	b5 23       	and	r27, r21
    7a8e:	80 83       	st	Z, r24
    7a90:	91 83       	std	Z+1, r25	; 0x01
    7a92:	a2 83       	std	Z+2, r26	; 0x02
    7a94:	b3 83       	std	Z+3, r27	; 0x03
				if (++CurrQuery[MB_N]==prb(&Slave->QueryQt))
    7a96:	fe 01       	movw	r30, r28
    7a98:	eb 5a       	subi	r30, 0xAB	; 171
    7a9a:	f9 4f       	sbci	r31, 0xF9	; 249
    7a9c:	80 81       	ld	r24, Z
    7a9e:	8f 5f       	subi	r24, 0xFF	; 255
    7aa0:	80 83       	st	Z, r24
    7aa2:	6d 5f       	subi	r22, 0xFD	; 253
    7aa4:	7f 4f       	sbci	r23, 0xFF	; 255
    7aa6:	fb 01       	movw	r30, r22
    7aa8:	94 91       	lpm	r25, Z+
    7aaa:	89 17       	cp	r24, r25
    7aac:	09 f4       	brne	.+2      	; 0x7ab0 <MB_M_Timer_ISR+0x2d4>
    7aae:	55 c1       	rjmp	.+682    	; 0x7d5a <MB_M_Timer_ISR+0x57e>
    7ab0:	90 e0       	ldi	r25, 0x00	; 0
					Over = NextSlave(MB_N);
				Try[MB_N] = 0;
    7ab2:	fe 01       	movw	r30, r28
    7ab4:	ed 51       	subi	r30, 0x1D	; 29
    7ab6:	fb 4f       	sbci	r31, 0xFB	; 251
    7ab8:	10 82       	st	Z, r1
    7aba:	15 cf       	rjmp	.-470    	; 0x78e6 <MB_M_Timer_ISR+0x10a>
		}
		if (MB_Frame[MB_N][0]!=Addr || MB_Frame[MB_N][1]!=Func)
			Over = FailSlave(MB_N);
		else {
			uint8_t Err;
			switch (Func) {
    7abc:	91 30       	cpi	r25, 0x01	; 1
    7abe:	08 f4       	brcc	.+2      	; 0x7ac2 <MB_M_Timer_ISR+0x2e6>
    7ac0:	b9 cf       	rjmp	.-142    	; 0x7a34 <MB_M_Timer_ISR+0x258>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_M_ReadDiscr(uint8_t MB_N, MB_Query *Query)
{
	uint8_t Qt = LastProcSingle ? MB_SingleQuery[MB_N].Qt : prb((uint8_t*)&Query->Qt);
    7ac2:	80 91 e2 04 	lds	r24, 0x04E2
    7ac6:	88 23       	and	r24, r24
    7ac8:	09 f4       	brne	.+2      	; 0x7acc <MB_M_Timer_ISR+0x2f0>
    7aca:	eb c0       	rjmp	.+470    	; 0x7ca2 <MB_M_Timer_ISR+0x4c6>
    7acc:	fe 01       	movw	r30, r28
    7ace:	ee 0f       	add	r30, r30
    7ad0:	ff 1f       	adc	r31, r31
    7ad2:	ee 0f       	add	r30, r30
    7ad4:	ff 1f       	adc	r31, r31
    7ad6:	ee 0f       	add	r30, r30
    7ad8:	ff 1f       	adc	r31, r31
    7ada:	e2 52       	subi	r30, 0x22	; 34
    7adc:	fb 4f       	sbci	r31, 0xFB	; 251
    7ade:	b0 81       	ld	r27, Z
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || Qt/8+((Qt%8)>0)!=MB_Frame[MB_N][2])
    7ae0:	fc 2f       	mov	r31, r28
    7ae2:	ee 27       	eor	r30, r30
    7ae4:	e3 59       	subi	r30, 0x93	; 147
    7ae6:	f4 4f       	sbci	r31, 0xF4	; 244
    7ae8:	80 81       	ld	r24, Z
    7aea:	88 2e       	mov	r8, r24
    7aec:	99 24       	eor	r9, r9
    7aee:	fe 01       	movw	r30, r28
    7af0:	e7 5b       	subi	r30, 0xB7	; 183
    7af2:	f8 4f       	sbci	r31, 0xF8	; 248
    7af4:	80 81       	ld	r24, Z
    7af6:	90 e0       	ldi	r25, 0x00	; 0
    7af8:	94 01       	movw	r18, r8
    7afa:	2b 5f       	subi	r18, 0xFB	; 251
    7afc:	3f 4f       	sbci	r19, 0xFF	; 255
    7afe:	82 17       	cp	r24, r18
    7b00:	93 07       	cpc	r25, r19
    7b02:	09 f0       	breq	.+2      	; 0x7b06 <MB_M_Timer_ISR+0x32a>
    7b04:	41 cf       	rjmp	.-382    	; 0x7988 <MB_M_Timer_ISR+0x1ac>
    7b06:	20 e0       	ldi	r18, 0x00	; 0
    7b08:	30 e0       	ldi	r19, 0x00	; 0
    7b0a:	6b 2e       	mov	r6, r27
    7b0c:	77 24       	eor	r7, r7
    7b0e:	c3 01       	movw	r24, r6
    7b10:	87 70       	andi	r24, 0x07	; 7
    7b12:	90 70       	andi	r25, 0x00	; 0
    7b14:	18 16       	cp	r1, r24
    7b16:	19 06       	cpc	r1, r25
    7b18:	14 f4       	brge	.+4      	; 0x7b1e <MB_M_Timer_ISR+0x342>
    7b1a:	21 e0       	ldi	r18, 0x01	; 1
    7b1c:	30 e0       	ldi	r19, 0x00	; 0
    7b1e:	b6 95       	lsr	r27
    7b20:	b6 95       	lsr	r27
    7b22:	b6 95       	lsr	r27
    7b24:	2b 0f       	add	r18, r27
    7b26:	31 1d       	adc	r19, r1
    7b28:	82 16       	cp	r8, r18
    7b2a:	93 06       	cpc	r9, r19
    7b2c:	09 f0       	breq	.+2      	; 0x7b30 <MB_M_Timer_ISR+0x354>
    7b2e:	2c cf       	rjmp	.-424    	; 0x7988 <MB_M_Timer_ISR+0x1ac>
		return 1;
	uint8_t *Discr;
	uint8_t Pin;
	if (LastProcSingle) {
    7b30:	80 91 e2 04 	lds	r24, 0x04E2
    7b34:	88 23       	and	r24, r24
    7b36:	09 f4       	brne	.+2      	; 0x7b3a <MB_M_Timer_ISR+0x35e>
    7b38:	1d c1       	rjmp	.+570    	; 0x7d74 <MB_M_Timer_ISR+0x598>
		Discr = MB_SingleQuery[MB_N].Buf;
    7b3a:	fe 01       	movw	r30, r28
    7b3c:	ee 0f       	add	r30, r30
    7b3e:	ff 1f       	adc	r31, r31
    7b40:	ee 0f       	add	r30, r30
    7b42:	ff 1f       	adc	r31, r31
    7b44:	ee 0f       	add	r30, r30
    7b46:	ff 1f       	adc	r31, r31
    7b48:	e6 52       	subi	r30, 0x26	; 38
    7b4a:	fb 4f       	sbci	r31, 0xFB	; 251
    7b4c:	86 80       	ldd	r8, Z+6	; 0x06
    7b4e:	97 80       	ldd	r9, Z+7	; 0x07
    7b50:	00 e0       	ldi	r16, 0x00	; 0
	}
	else {
		Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
		Pin = prw(&Query->AllocAddr);
	}
	for (uint16_t i=0; i<Qt; i++) {
    7b52:	61 14       	cp	r6, r1
    7b54:	71 04       	cpc	r7, r1
    7b56:	09 f4       	brne	.+2      	; 0x7b5a <MB_M_Timer_ISR+0x37e>
    7b58:	6d cf       	rjmp	.-294    	; 0x7a34 <MB_M_Timer_ISR+0x258>
    7b5a:	40 e0       	ldi	r20, 0x00	; 0
    7b5c:	50 e0       	ldi	r21, 0x00	; 0
		uint8_t j = Pin+i;
		uint8_t Byte=j/8, Bit=1<<j%8;
    7b5e:	21 e0       	ldi	r18, 0x01	; 1
    7b60:	42 2e       	mov	r4, r18
    7b62:	51 2c       	mov	r5, r1
		if (MB_Frame[MB_N][3+i/8] &(1<<i%8))
    7b64:	8b e6       	ldi	r24, 0x6B	; 107
    7b66:	9b e0       	ldi	r25, 0x0B	; 11
    7b68:	c8 0e       	add	r12, r24
    7b6a:	d9 1e       	adc	r13, r25
    7b6c:	0c c0       	rjmp	.+24     	; 0x7b86 <MB_M_Timer_ISR+0x3aa>
			Discr[Byte] |=Bit;
    7b6e:	f4 01       	movw	r30, r8
    7b70:	eb 0f       	add	r30, r27
    7b72:	f1 1d       	adc	r31, r1
    7b74:	80 81       	ld	r24, Z
    7b76:	8a 2b       	or	r24, r26
    7b78:	80 83       	st	Z, r24
	}
	else {
		Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
		Pin = prw(&Query->AllocAddr);
	}
	for (uint16_t i=0; i<Qt; i++) {
    7b7a:	4f 5f       	subi	r20, 0xFF	; 255
    7b7c:	5f 4f       	sbci	r21, 0xFF	; 255
    7b7e:	46 15       	cp	r20, r6
    7b80:	57 05       	cpc	r21, r7
    7b82:	08 f0       	brcs	.+2      	; 0x7b86 <MB_M_Timer_ISR+0x3aa>
    7b84:	57 cf       	rjmp	.-338    	; 0x7a34 <MB_M_Timer_ISR+0x258>
    7b86:	80 2f       	mov	r24, r16
    7b88:	84 0f       	add	r24, r20
		uint8_t j = Pin+i;
		uint8_t Byte=j/8, Bit=1<<j%8;
    7b8a:	b8 2f       	mov	r27, r24
    7b8c:	b6 95       	lsr	r27
    7b8e:	b6 95       	lsr	r27
    7b90:	b6 95       	lsr	r27
    7b92:	87 70       	andi	r24, 0x07	; 7
    7b94:	a4 2d       	mov	r26, r4
    7b96:	01 c0       	rjmp	.+2      	; 0x7b9a <MB_M_Timer_ISR+0x3be>
    7b98:	aa 0f       	add	r26, r26
    7b9a:	8a 95       	dec	r24
    7b9c:	ea f7       	brpl	.-6      	; 0x7b98 <MB_M_Timer_ISR+0x3bc>
		if (MB_Frame[MB_N][3+i/8] &(1<<i%8))
    7b9e:	fa 01       	movw	r30, r20
    7ba0:	f6 95       	lsr	r31
    7ba2:	e7 95       	ror	r30
    7ba4:	f6 95       	lsr	r31
    7ba6:	e7 95       	ror	r30
    7ba8:	f6 95       	lsr	r31
    7baa:	e7 95       	ror	r30
    7bac:	ec 0d       	add	r30, r12
    7bae:	fd 1d       	adc	r31, r13
    7bb0:	83 81       	ldd	r24, Z+3	; 0x03
    7bb2:	90 e0       	ldi	r25, 0x00	; 0
    7bb4:	9a 01       	movw	r18, r20
    7bb6:	27 70       	andi	r18, 0x07	; 7
    7bb8:	30 70       	andi	r19, 0x00	; 0
    7bba:	02 c0       	rjmp	.+4      	; 0x7bc0 <MB_M_Timer_ISR+0x3e4>
    7bbc:	95 95       	asr	r25
    7bbe:	87 95       	ror	r24
    7bc0:	2a 95       	dec	r18
    7bc2:	e2 f7       	brpl	.-8      	; 0x7bbc <MB_M_Timer_ISR+0x3e0>
    7bc4:	80 fd       	sbrc	r24, 0
    7bc6:	d3 cf       	rjmp	.-90     	; 0x7b6e <MB_M_Timer_ISR+0x392>
			Discr[Byte] |=Bit;
		else
			Discr[Byte] &=~Bit;
    7bc8:	f4 01       	movw	r30, r8
    7bca:	eb 0f       	add	r30, r27
    7bcc:	f1 1d       	adc	r31, r1
    7bce:	a0 95       	com	r26
    7bd0:	80 81       	ld	r24, Z
    7bd2:	8a 23       	and	r24, r26
    7bd4:	80 83       	st	Z, r24
    7bd6:	d1 cf       	rjmp	.-94     	; 0x7b7a <MB_M_Timer_ISR+0x39e>
inline static uint8_t
MB_M_PresetSingle(uint8_t MB_N, MB_Query *Query)
{
	uint16_t StartAddr;
	uint16_t *Reg;
	if (LastProcSingle) {
    7bd8:	80 91 e2 04 	lds	r24, 0x04E2
    7bdc:	88 23       	and	r24, r24
    7bde:	09 f4       	brne	.+2      	; 0x7be2 <MB_M_Timer_ISR+0x406>
    7be0:	46 c0       	rjmp	.+140    	; 0x7c6e <MB_M_Timer_ISR+0x492>
		StartAddr = MB_SingleQuery[MB_N].StartAddr;
    7be2:	f7 01       	movw	r30, r14
    7be4:	ee 0f       	add	r30, r30
    7be6:	ff 1f       	adc	r31, r31
    7be8:	e4 52       	subi	r30, 0x24	; 36
    7bea:	fb 4f       	sbci	r31, 0xFB	; 251
    7bec:	80 80       	ld	r8, Z
    7bee:	91 80       	ldd	r9, Z+1	; 0x01
		Reg = MB_SingleQuery[MB_N].Buf;
    7bf0:	fe 01       	movw	r30, r28
    7bf2:	ee 0f       	add	r30, r30
    7bf4:	ff 1f       	adc	r31, r31
    7bf6:	ee 0f       	add	r30, r30
    7bf8:	ff 1f       	adc	r31, r31
    7bfa:	ee 0f       	add	r30, r30
    7bfc:	ff 1f       	adc	r31, r31
    7bfe:	e6 52       	subi	r30, 0x26	; 38
    7c00:	fb 4f       	sbci	r31, 0xFB	; 251
    7c02:	a6 81       	ldd	r26, Z+6	; 0x06
    7c04:	b7 81       	ldd	r27, Z+7	; 0x07
	}
	else {
		StartAddr = prw(&Query->StartAddr);
		Reg = (uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+prw(&Query->AllocAddr);
	}
	return MB_Frame_Sz[MB_N]!=8 || MB_FrameReg(MB_N, 2)!=StartAddr || MB_FrameReg(MB_N, 4)!=*Reg;
    7c06:	fe 01       	movw	r30, r28
    7c08:	e7 5b       	subi	r30, 0xB7	; 183
    7c0a:	f8 4f       	sbci	r31, 0xF8	; 248
    7c0c:	80 81       	ld	r24, Z
    7c0e:	88 30       	cpi	r24, 0x08	; 8
    7c10:	09 f0       	breq	.+2      	; 0x7c14 <MB_M_Timer_ISR+0x438>
    7c12:	ba ce       	rjmp	.-652    	; 0x7988 <MB_M_Timer_ISR+0x1ac>
    7c14:	fc 2f       	mov	r31, r28
    7c16:	ee 27       	eor	r30, r30
    7c18:	e3 59       	subi	r30, 0x93	; 147
    7c1a:	f4 4f       	sbci	r31, 0xF4	; 244
    7c1c:	30 81       	ld	r19, Z
    7c1e:	20 e0       	ldi	r18, 0x00	; 0
    7c20:	a6 01       	movw	r20, r12
    7c22:	45 59       	subi	r20, 0x95	; 149
    7c24:	54 4f       	sbci	r21, 0xF4	; 244
    7c26:	fa 01       	movw	r30, r20
    7c28:	83 81       	ldd	r24, Z+3	; 0x03
    7c2a:	90 e0       	ldi	r25, 0x00	; 0
    7c2c:	28 2b       	or	r18, r24
    7c2e:	39 2b       	or	r19, r25
    7c30:	28 15       	cp	r18, r8
    7c32:	39 05       	cpc	r19, r9
    7c34:	09 f0       	breq	.+2      	; 0x7c38 <MB_M_Timer_ISR+0x45c>
    7c36:	a8 ce       	rjmp	.-688    	; 0x7988 <MB_M_Timer_ISR+0x1ac>
    7c38:	fc 2f       	mov	r31, r28
    7c3a:	ee 27       	eor	r30, r30
    7c3c:	e1 59       	subi	r30, 0x91	; 145
    7c3e:	f4 4f       	sbci	r31, 0xF4	; 244
    7c40:	30 81       	ld	r19, Z
    7c42:	20 e0       	ldi	r18, 0x00	; 0
    7c44:	fa 01       	movw	r30, r20
    7c46:	85 81       	ldd	r24, Z+5	; 0x05
    7c48:	90 e0       	ldi	r25, 0x00	; 0
    7c4a:	28 2b       	or	r18, r24
    7c4c:	39 2b       	or	r19, r25
    7c4e:	8d 91       	ld	r24, X+
    7c50:	9c 91       	ld	r25, X
    7c52:	28 17       	cp	r18, r24
    7c54:	39 07       	cpc	r19, r25
    7c56:	09 f0       	breq	.+2      	; 0x7c5a <MB_M_Timer_ISR+0x47e>
    7c58:	97 ce       	rjmp	.-722    	; 0x7988 <MB_M_Timer_ISR+0x1ac>
    7c5a:	ec ce       	rjmp	.-552    	; 0x7a34 <MB_M_Timer_ISR+0x258>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    7c5c:	fa 01       	movw	r30, r20
    7c5e:	31 96       	adiw	r30, 0x01	; 1
    7c60:	85 90       	lpm	r8, Z+
    7c62:	94 90       	lpm	r9, Z+

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    7c64:	fa 01       	movw	r30, r20
    7c66:	33 96       	adiw	r30, 0x03	; 3
    7c68:	45 91       	lpm	r20, Z+
    7c6a:	54 91       	lpm	r21, Z+
    7c6c:	bb ce       	rjmp	.-650    	; 0x79e4 <MB_M_Timer_ISR+0x208>
    7c6e:	fa 01       	movw	r30, r20
    7c70:	31 96       	adiw	r30, 0x01	; 1
    7c72:	85 90       	lpm	r8, Z+
    7c74:	94 90       	lpm	r9, Z+
    7c76:	fe 01       	movw	r30, r28
    7c78:	ee 0f       	add	r30, r30
    7c7a:	ff 1f       	adc	r31, r31
    7c7c:	ee 0f       	add	r30, r30
    7c7e:	ff 1f       	adc	r31, r31
    7c80:	ee 0f       	add	r30, r30
    7c82:	ff 1f       	adc	r31, r31
    7c84:	ee 0f       	add	r30, r30
    7c86:	ff 1f       	adc	r31, r31
    7c88:	e8 5c       	subi	r30, 0xC8	; 200
    7c8a:	fc 4f       	sbci	r31, 0xFC	; 252
    7c8c:	a5 91       	lpm	r26, Z+
    7c8e:	b4 91       	lpm	r27, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    7c90:	fa 01       	movw	r30, r20
    7c92:	35 96       	adiw	r30, 0x05	; 5
    7c94:	85 91       	lpm	r24, Z+
    7c96:	94 91       	lpm	r25, Z+
		StartAddr = MB_SingleQuery[MB_N].StartAddr;
		Reg = MB_SingleQuery[MB_N].Buf;
	}
	else {
		StartAddr = prw(&Query->StartAddr);
		Reg = (uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+prw(&Query->AllocAddr);
    7c98:	88 0f       	add	r24, r24
    7c9a:	99 1f       	adc	r25, r25
    7c9c:	a8 0f       	add	r26, r24
    7c9e:	b9 1f       	adc	r27, r25
    7ca0:	b2 cf       	rjmp	.-156    	; 0x7c06 <MB_M_Timer_ISR+0x42a>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    7ca2:	4d 5f       	subi	r20, 0xFD	; 253
    7ca4:	5f 4f       	sbci	r21, 0xFF	; 255
    7ca6:	fa 01       	movw	r30, r20
    7ca8:	b4 91       	lpm	r27, Z+
    7caa:	43 50       	subi	r20, 0x03	; 3
    7cac:	50 40       	sbci	r21, 0x00	; 0
    7cae:	18 cf       	rjmp	.-464    	; 0x7ae0 <MB_M_Timer_ISR+0x304>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_M_ReadReg(uint8_t MB_N, MB_Query *Query)
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || (LastProcSingle?MB_SingleQuery[MB_N].Qt:prw(&Query->Qt))*2!=MB_Frame[MB_N][2])
    7cb0:	80 91 e2 04 	lds	r24, 0x04E2
    7cb4:	88 23       	and	r24, r24
    7cb6:	09 f4       	brne	.+2      	; 0x7cba <MB_M_Timer_ISR+0x4de>
    7cb8:	55 c0       	rjmp	.+170    	; 0x7d64 <MB_M_Timer_ISR+0x588>
    7cba:	fe 01       	movw	r30, r28
    7cbc:	ee 0f       	add	r30, r30
    7cbe:	ff 1f       	adc	r31, r31
    7cc0:	ee 0f       	add	r30, r30
    7cc2:	ff 1f       	adc	r31, r31
    7cc4:	ee 0f       	add	r30, r30
    7cc6:	ff 1f       	adc	r31, r31
    7cc8:	e2 52       	subi	r30, 0x22	; 34
    7cca:	fb 4f       	sbci	r31, 0xFB	; 251
    7ccc:	20 81       	ld	r18, Z
    7cce:	31 81       	ldd	r19, Z+1	; 0x01
    7cd0:	22 0f       	add	r18, r18
    7cd2:	33 1f       	adc	r19, r19
    7cd4:	82 16       	cp	r8, r18
    7cd6:	93 06       	cpc	r9, r19
    7cd8:	09 f0       	breq	.+2      	; 0x7cdc <MB_M_Timer_ISR+0x500>
    7cda:	56 ce       	rjmp	.-852    	; 0x7988 <MB_M_Timer_ISR+0x1ac>
		return 1;
	uint16_t *Reg = LastProcSingle ?
		MB_SingleQuery[MB_N].Buf
	:
		(uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg))+prw(&Query->AllocAddr);
    7cdc:	80 91 e2 04 	lds	r24, 0x04E2
    7ce0:	88 23       	and	r24, r24
    7ce2:	09 f4       	brne	.+2      	; 0x7ce6 <MB_M_Timer_ISR+0x50a>
    7ce4:	5e c0       	rjmp	.+188    	; 0x7da2 <MB_M_Timer_ISR+0x5c6>
    7ce6:	fe 01       	movw	r30, r28
    7ce8:	ee 0f       	add	r30, r30
    7cea:	ff 1f       	adc	r31, r31
    7cec:	ee 0f       	add	r30, r30
    7cee:	ff 1f       	adc	r31, r31
    7cf0:	ee 0f       	add	r30, r30
    7cf2:	ff 1f       	adc	r31, r31
    7cf4:	e6 52       	subi	r30, 0x26	; 38
    7cf6:	fb 4f       	sbci	r31, 0xFB	; 251
    7cf8:	26 81       	ldd	r18, Z+6	; 0x06
    7cfa:	37 81       	ldd	r19, Z+7	; 0x07
	for (int8_t j=MB_Frame[MB_N][2]/2-1; j>=0; j--) {
    7cfc:	4b 2f       	mov	r20, r27
    7cfe:	46 95       	lsr	r20
    7d00:	41 50       	subi	r20, 0x01	; 1
    7d02:	47 fd       	sbrc	r20, 7
    7d04:	97 ce       	rjmp	.-722    	; 0x7a34 <MB_M_Timer_ISR+0x258>
    7d06:	84 2f       	mov	r24, r20
    7d08:	99 27       	eor	r25, r25
    7d0a:	87 fd       	sbrc	r24, 7
    7d0c:	90 95       	com	r25
    7d0e:	88 0f       	add	r24, r24
    7d10:	99 1f       	adc	r25, r25
    7d12:	58 2f       	mov	r21, r24
    7d14:	5d 5f       	subi	r21, 0xFD	; 253
    7d16:	28 0f       	add	r18, r24
    7d18:	39 1f       	adc	r19, r25
		int8_t i = j*2;
		Reg[j] = MB_FrameReg(MB_N, 3+i);
    7d1a:	8b e6       	ldi	r24, 0x6B	; 107
    7d1c:	88 2e       	mov	r8, r24
    7d1e:	8b e0       	ldi	r24, 0x0B	; 11
    7d20:	98 2e       	mov	r9, r24
    7d22:	8c 0c       	add	r8, r12
    7d24:	9d 1c       	adc	r9, r13
    7d26:	e5 2f       	mov	r30, r21
    7d28:	f0 e0       	ldi	r31, 0x00	; 0
    7d2a:	d4 01       	movw	r26, r8
    7d2c:	ae 0f       	add	r26, r30
    7d2e:	bf 1f       	adc	r27, r31
    7d30:	11 96       	adiw	r26, 0x01	; 1
    7d32:	8c 91       	ld	r24, X
    7d34:	90 e0       	ldi	r25, 0x00	; 0
    7d36:	ec 0d       	add	r30, r12
    7d38:	fd 1d       	adc	r31, r13
    7d3a:	e5 59       	subi	r30, 0x95	; 149
    7d3c:	f4 4f       	sbci	r31, 0xF4	; 244
    7d3e:	f0 81       	ld	r31, Z
    7d40:	e0 e0       	ldi	r30, 0x00	; 0
    7d42:	8e 2b       	or	r24, r30
    7d44:	9f 2b       	or	r25, r31
    7d46:	d9 01       	movw	r26, r18
    7d48:	8d 93       	st	X+, r24
    7d4a:	9c 93       	st	X, r25
		return 1;
	uint16_t *Reg = LastProcSingle ?
		MB_SingleQuery[MB_N].Buf
	:
		(uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg))+prw(&Query->AllocAddr);
	for (int8_t j=MB_Frame[MB_N][2]/2-1; j>=0; j--) {
    7d4c:	41 50       	subi	r20, 0x01	; 1
    7d4e:	52 50       	subi	r21, 0x02	; 2
    7d50:	22 50       	subi	r18, 0x02	; 2
    7d52:	30 40       	sbci	r19, 0x00	; 0
    7d54:	47 ff       	sbrs	r20, 7
    7d56:	e7 cf       	rjmp	.-50     	; 0x7d26 <MB_M_Timer_ISR+0x54a>
    7d58:	6d ce       	rjmp	.-806    	; 0x7a34 <MB_M_Timer_ISR+0x258>
			else if (LastProcSingle)
				MB_SingleState[MB_N] = MB_SingleIdle;
			else {
				SlaveOff[MB_N] &=~((uint32_t)1<<CurrSlave[MB_N]);
				if (++CurrQuery[MB_N]==prb(&Slave->QueryQt))
					Over = NextSlave(MB_N);
    7d5a:	81 2f       	mov	r24, r17
    7d5c:	0e 94 a5 3a 	call	0x754a	; 0x754a <NextSlave>
    7d60:	98 2f       	mov	r25, r24
    7d62:	a7 ce       	rjmp	.-690    	; 0x7ab2 <MB_M_Timer_ISR+0x2d6>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    7d64:	ca 01       	movw	r24, r20
    7d66:	03 96       	adiw	r24, 0x03	; 3
    7d68:	fc 01       	movw	r30, r24
    7d6a:	25 91       	lpm	r18, Z+
    7d6c:	34 91       	lpm	r19, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_M_ReadReg(uint8_t MB_N, MB_Query *Query)
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || (LastProcSingle?MB_SingleQuery[MB_N].Qt:prw(&Query->Qt))*2!=MB_Frame[MB_N][2])
    7d6e:	22 0f       	add	r18, r18
    7d70:	33 1f       	adc	r19, r19
    7d72:	b0 cf       	rjmp	.-160    	; 0x7cd4 <MB_M_Timer_ISR+0x4f8>
	if (LastProcSingle) {
		Discr = MB_SingleQuery[MB_N].Buf;
		Pin = 0;
	}
	else {
		Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
    7d74:	a1 30       	cpi	r26, 0x01	; 1
    7d76:	59 f1       	breq	.+86     	; 0x7dce <MB_M_Timer_ISR+0x5f2>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    7d78:	f7 01       	movw	r30, r14
    7d7a:	ee 0f       	add	r30, r30
    7d7c:	ff 1f       	adc	r31, r31
    7d7e:	ee 0f       	add	r30, r30
    7d80:	ff 1f       	adc	r31, r31
    7d82:	ec 5c       	subi	r30, 0xCC	; 204
    7d84:	fc 4f       	sbci	r31, 0xFC	; 252
    7d86:	85 91       	lpm	r24, Z+
    7d88:	94 91       	lpm	r25, Z+
    7d8a:	e8 2f       	mov	r30, r24
    7d8c:	89 2f       	mov	r24, r25
    7d8e:	2e 2f       	mov	r18, r30
    7d90:	38 2f       	mov	r19, r24
    7d92:	c9 01       	movw	r24, r18
    7d94:	4c 01       	movw	r8, r24

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    7d96:	fa 01       	movw	r30, r20
    7d98:	35 96       	adiw	r30, 0x05	; 5
    7d9a:	85 91       	lpm	r24, Z+
    7d9c:	94 91       	lpm	r25, Z+
		Pin = prw(&Query->AllocAddr);
    7d9e:	08 2f       	mov	r16, r24
    7da0:	d8 ce       	rjmp	.-592    	; 0x7b52 <MB_M_Timer_ISR+0x376>
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || (LastProcSingle?MB_SingleQuery[MB_N].Qt:prw(&Query->Qt))*2!=MB_Frame[MB_N][2])
		return 1;
	uint16_t *Reg = LastProcSingle ?
		MB_SingleQuery[MB_N].Buf
	:
		(uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg))+prw(&Query->AllocAddr);
    7da2:	a3 30       	cpi	r26, 0x03	; 3
    7da4:	11 f1       	breq	.+68     	; 0x7dea <MB_M_Timer_ISR+0x60e>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    7da6:	fe 01       	movw	r30, r28
    7da8:	e2 95       	swap	r30
    7daa:	f2 95       	swap	r31
    7dac:	f0 7f       	andi	r31, 0xF0	; 240
    7dae:	fe 27       	eor	r31, r30
    7db0:	e0 7f       	andi	r30, 0xF0	; 240
    7db2:	fe 27       	eor	r31, r30
    7db4:	e4 5c       	subi	r30, 0xC4	; 196
    7db6:	fc 4f       	sbci	r31, 0xFC	; 252
    7db8:	85 91       	lpm	r24, Z+
    7dba:	94 91       	lpm	r25, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    7dbc:	fa 01       	movw	r30, r20
    7dbe:	35 96       	adiw	r30, 0x05	; 5
    7dc0:	25 91       	lpm	r18, Z+
    7dc2:	34 91       	lpm	r19, Z+
    7dc4:	22 0f       	add	r18, r18
    7dc6:	33 1f       	adc	r19, r19
    7dc8:	28 0f       	add	r18, r24
    7dca:	39 1f       	adc	r19, r25
    7dcc:	97 cf       	rjmp	.-210    	; 0x7cfc <MB_M_Timer_ISR+0x520>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    7dce:	fe 01       	movw	r30, r28
    7dd0:	e2 95       	swap	r30
    7dd2:	f2 95       	swap	r31
    7dd4:	f0 7f       	andi	r31, 0xF0	; 240
    7dd6:	fe 27       	eor	r31, r30
    7dd8:	e0 7f       	andi	r30, 0xF0	; 240
    7dda:	fe 27       	eor	r31, r30
    7ddc:	e0 5d       	subi	r30, 0xD0	; 208
    7dde:	fc 4f       	sbci	r31, 0xFC	; 252
    7de0:	85 91       	lpm	r24, Z+
    7de2:	94 91       	lpm	r25, Z+
    7de4:	e8 2f       	mov	r30, r24
    7de6:	89 2f       	mov	r24, r25
    7de8:	d2 cf       	rjmp	.-92     	; 0x7d8e <MB_M_Timer_ISR+0x5b2>

// ~~~~~~~~~~~~~~~~~~
void
MB_M_Tx(uint8_t MB_N)
{
	StartTimer16(TD_MB_Idle+MB_N, MB_M_Timeout[MB_N]);
    7dea:	fe 01       	movw	r30, r28
    7dec:	ee 0f       	add	r30, r30
    7dee:	ff 1f       	adc	r31, r31
    7df0:	ee 0f       	add	r30, r30
    7df2:	ff 1f       	adc	r31, r31
    7df4:	ee 0f       	add	r30, r30
    7df6:	ff 1f       	adc	r31, r31
    7df8:	ee 0f       	add	r30, r30
    7dfa:	ff 1f       	adc	r31, r31
    7dfc:	e8 5c       	subi	r30, 0xC8	; 200
    7dfe:	fc 4f       	sbci	r31, 0xFC	; 252
    7e00:	85 91       	lpm	r24, Z+
    7e02:	94 91       	lpm	r25, Z+
    7e04:	db cf       	rjmp	.-74     	; 0x7dbc <MB_M_Timer_ISR+0x5e0>

00007e06 <MB_M_Tx>:
    7e06:	90 91 e8 04 	lds	r25, 0x04E8
    7e0a:	e9 e2       	ldi	r30, 0x29	; 41
    7e0c:	f9 e0       	ldi	r31, 0x09	; 9
    7e0e:	e8 0f       	add	r30, r24
    7e10:	f1 1d       	adc	r31, r1
    7e12:	60 81       	ld	r22, Z
    7e14:	89 0f       	add	r24, r25
    7e16:	70 e0       	ldi	r23, 0x00	; 0
    7e18:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
}
    7e1c:	08 95       	ret

00007e1e <Modbus_TX>:
}

// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_TX(usart_t *usart)
{
    7e1e:	cf 92       	push	r12
    7e20:	df 92       	push	r13
    7e22:	ef 92       	push	r14
    7e24:	ff 92       	push	r15
    7e26:	1f 93       	push	r17
    7e28:	cf 93       	push	r28
    7e2a:	df 93       	push	r29
    7e2c:	dc 01       	movw	r26, r24
    7e2e:	ec e8       	ldi	r30, 0x8C	; 140
    7e30:	f0 e4       	ldi	r31, 0x40	; 64
    7e32:	85 91       	lpm	r24, Z+
    7e34:	94 91       	lpm	r25, Z+
// ~~~~~~~~~~~~~~~~~~~~~~
static uint8_t
MB_Port_N(usart_t *usart)
{
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Port[MB_N].usart_field)!=usart; MB_N++);
    7e36:	a8 17       	cp	r26, r24
    7e38:	b9 07       	cpc	r27, r25
    7e3a:	09 f4       	brne	.+2      	; 0x7e3e <Modbus_TX+0x20>
    7e3c:	c0 c0       	rjmp	.+384    	; 0x7fbe <Modbus_TX+0x1a0>
    7e3e:	10 e0       	ldi	r17, 0x00	; 0
    7e40:	1f 5f       	subi	r17, 0xFF	; 255
    7e42:	c1 2f       	mov	r28, r17
    7e44:	d0 e0       	ldi	r29, 0x00	; 0
    7e46:	ce 01       	movw	r24, r28
    7e48:	88 0f       	add	r24, r24
    7e4a:	99 1f       	adc	r25, r25
    7e4c:	88 0f       	add	r24, r24
    7e4e:	99 1f       	adc	r25, r25
    7e50:	fc 01       	movw	r30, r24
    7e52:	ee 0f       	add	r30, r30
    7e54:	ff 1f       	adc	r31, r31
    7e56:	ee 0f       	add	r30, r30
    7e58:	ff 1f       	adc	r31, r31
    7e5a:	e8 0f       	add	r30, r24
    7e5c:	f9 1f       	adc	r31, r25
    7e5e:	e4 57       	subi	r30, 0x74	; 116
    7e60:	ff 4b       	sbci	r31, 0xBF	; 191
    7e62:	85 91       	lpm	r24, Z+
    7e64:	94 91       	lpm	r25, Z+
    7e66:	a8 17       	cp	r26, r24
    7e68:	b9 07       	cpc	r27, r25
    7e6a:	51 f7       	brne	.-44     	; 0x7e40 <Modbus_TX+0x22>
void
Modbus_TX(usart_t *usart)
{
	uint8_t MB_N = MB_Port_N(usart);
	static uint8_t Count[Modbus_Qt];
	if (Count[MB_N] == MB_Frame_Sz[MB_N]-2){
    7e6c:	26 ee       	ldi	r18, 0xE6	; 230
    7e6e:	c2 2e       	mov	r12, r18
    7e70:	22 e0       	ldi	r18, 0x02	; 2
    7e72:	d2 2e       	mov	r13, r18
    7e74:	cc 0e       	add	r12, r28
    7e76:	dd 1e       	adc	r13, r29
    7e78:	f6 01       	movw	r30, r12
    7e7a:	50 81       	ld	r21, Z
    7e7c:	be 01       	movw	r22, r28
    7e7e:	67 5b       	subi	r22, 0xB7	; 183
    7e80:	78 4f       	sbci	r23, 0xF8	; 248
    7e82:	fb 01       	movw	r30, r22
    7e84:	40 81       	ld	r20, Z
    7e86:	25 2f       	mov	r18, r21
    7e88:	30 e0       	ldi	r19, 0x00	; 0
    7e8a:	84 2f       	mov	r24, r20
    7e8c:	90 e0       	ldi	r25, 0x00	; 0
    7e8e:	02 97       	sbiw	r24, 0x02	; 2
    7e90:	28 17       	cp	r18, r24
    7e92:	39 07       	cpc	r19, r25
    7e94:	09 f4       	brne	.+2      	; 0x7e98 <Modbus_TX+0x7a>
    7e96:	55 c0       	rjmp	.+170    	; 0x7f42 <Modbus_TX+0x124>
		USART_Reg(MB_N, ucsrb) &=~(1<<5);
		USART_Reg(MB_N, ucsrb) |=(1<<6);
		USART_Reg(MB_N, ucsra) |=(1<<6);	//Clear TxC pending interrupt		
	}
	if (++Count[MB_N]<MB_Frame_Sz[MB_N]) {
    7e98:	25 2f       	mov	r18, r21
    7e9a:	2f 5f       	subi	r18, 0xFF	; 255
    7e9c:	f6 01       	movw	r30, r12
    7e9e:	20 83       	st	Z, r18
    7ea0:	24 17       	cp	r18, r20
    7ea2:	80 f4       	brcc	.+32     	; 0x7ec4 <Modbus_TX+0xa6>
		usart_data(usart) = MB_Frame[MB_N][Count[MB_N]];
    7ea4:	fc 2f       	mov	r31, r28
    7ea6:	ee 27       	eor	r30, r30
    7ea8:	e2 0f       	add	r30, r18
    7eaa:	f1 1d       	adc	r31, r1
    7eac:	e5 59       	subi	r30, 0x95	; 149
    7eae:	f4 4f       	sbci	r31, 0xF4	; 244
    7eb0:	80 81       	ld	r24, Z
    7eb2:	8c 93       	st	X, r24
		break;
	case Role_Master:
		MB_M_Tx(MB_N);
		break;
	}
}
    7eb4:	df 91       	pop	r29
    7eb6:	cf 91       	pop	r28
    7eb8:	1f 91       	pop	r17
    7eba:	ff 90       	pop	r15
    7ebc:	ef 90       	pop	r14
    7ebe:	df 90       	pop	r13
    7ec0:	cf 90       	pop	r12
    7ec2:	08 95       	ret
    7ec4:	9e 01       	movw	r18, r28
    7ec6:	22 0f       	add	r18, r18
    7ec8:	33 1f       	adc	r19, r19
    7eca:	22 0f       	add	r18, r18
    7ecc:	33 1f       	adc	r19, r19
    7ece:	c9 01       	movw	r24, r18
    7ed0:	8c 0f       	add	r24, r28
    7ed2:	9d 1f       	adc	r25, r29
    7ed4:	88 0f       	add	r24, r24
    7ed6:	99 1f       	adc	r25, r25
    7ed8:	88 0f       	add	r24, r24
    7eda:	99 1f       	adc	r25, r25
    7edc:	80 57       	subi	r24, 0x70	; 112
    7ede:	9f 4b       	sbci	r25, 0xBF	; 191
    7ee0:	fc 01       	movw	r30, r24
    7ee2:	a5 91       	lpm	r26, Z+
    7ee4:	b4 91       	lpm	r27, Z+
	}

	void MB_S_Tx(uint8_t);
	void MB_M_Tx(uint8_t);
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		USART_Reg(MB_N, ucsrb) &=~((1<<6)|(1<<5)); 	// .  USART Data Register Empty Interrupt
    7ee6:	8c 91       	ld	r24, X
    7ee8:	8f 79       	andi	r24, 0x9F	; 159
    7eea:	8c 93       	st	X, r24
    7eec:	79 01       	movw	r14, r18
    7eee:	ee 0c       	add	r14, r14
    7ef0:	ff 1c       	adc	r15, r15
    7ef2:	ee 0c       	add	r14, r14
    7ef4:	ff 1c       	adc	r15, r15
    7ef6:	e2 0e       	add	r14, r18
    7ef8:	f3 1e       	adc	r15, r19
    7efa:	c7 01       	movw	r24, r14
    7efc:	88 56       	subi	r24, 0x68	; 104
    7efe:	9f 4b       	sbci	r25, 0xBF	; 191
    7f00:	fc 01       	movw	r30, r24
    7f02:	25 91       	lpm	r18, Z+
    7f04:	34 91       	lpm	r19, Z+
	#elif defined (__AVR_ATxmega128A1__)
		usart->CTRLA = (usart->CTRLA &~USART_TXCINTLVL_gm) |USART_TXCINTLVL_OFF_gc;
	#endif
	USART_Func(MB_N, RS485);
    7f06:	f9 01       	movw	r30, r18
    7f08:	19 95       	eicall
	Count[MB_N] = 0;
    7f0a:	f6 01       	movw	r30, r12
    7f0c:	10 82       	st	Z, r1
	//StartTime3_5();
	MB_State[MB_N] = MB_Idle;
    7f0e:	ce 53       	subi	r28, 0x3E	; 62
    7f10:	da 4f       	sbci	r29, 0xFA	; 250
    7f12:	81 e0       	ldi	r24, 0x01	; 1
    7f14:	88 83       	st	Y, r24

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    7f16:	e1 2f       	mov	r30, r17
    7f18:	f0 e0       	ldi	r31, 0x00	; 0
    7f1a:	e0 56       	subi	r30, 0x60	; 96
    7f1c:	ff 4b       	sbci	r31, 0xBF	; 191
    7f1e:	84 91       	lpm	r24, Z+
	switch (prb(MB_Role+MB_N)) {
    7f20:	88 23       	and	r24, r24
    7f22:	09 f4       	brne	.+2      	; 0x7f26 <Modbus_TX+0x108>
    7f24:	3c c0       	rjmp	.+120    	; 0x7f9e <Modbus_TX+0x180>
    7f26:	81 30       	cpi	r24, 0x01	; 1
    7f28:	09 f0       	breq	.+2      	; 0x7f2c <Modbus_TX+0x10e>
    7f2a:	c4 cf       	rjmp	.-120    	; 0x7eb4 <Modbus_TX+0x96>
	case Role_Slave:
		MB_S_Tx(MB_N);
		break;
	case Role_Master:
		MB_M_Tx(MB_N);
    7f2c:	81 2f       	mov	r24, r17
    7f2e:	0e 94 03 3f 	call	0x7e06	; 0x7e06 <MB_M_Tx>
		break;
	}
}
    7f32:	df 91       	pop	r29
    7f34:	cf 91       	pop	r28
    7f36:	1f 91       	pop	r17
    7f38:	ff 90       	pop	r15
    7f3a:	ef 90       	pop	r14
    7f3c:	df 90       	pop	r13
    7f3e:	cf 90       	pop	r12
    7f40:	08 95       	ret

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    7f42:	fe 01       	movw	r30, r28
    7f44:	ee 0f       	add	r30, r30
    7f46:	ff 1f       	adc	r31, r31
    7f48:	ee 0f       	add	r30, r30
    7f4a:	ff 1f       	adc	r31, r31
    7f4c:	ec 0f       	add	r30, r28
    7f4e:	fd 1f       	adc	r31, r29
    7f50:	ee 0f       	add	r30, r30
    7f52:	ff 1f       	adc	r31, r31
    7f54:	ee 0f       	add	r30, r30
    7f56:	ff 1f       	adc	r31, r31
    7f58:	e0 57       	subi	r30, 0x70	; 112
    7f5a:	ff 4b       	sbci	r31, 0xBF	; 191
    7f5c:	25 91       	lpm	r18, Z+
    7f5e:	34 91       	lpm	r19, Z+
Modbus_TX(usart_t *usart)
{
	uint8_t MB_N = MB_Port_N(usart);
	static uint8_t Count[Modbus_Qt];
	if (Count[MB_N] == MB_Frame_Sz[MB_N]-2){
		USART_Reg(MB_N, ucsrb) &=~(1<<5);
    7f60:	f9 01       	movw	r30, r18
    7f62:	80 81       	ld	r24, Z
    7f64:	8f 7d       	andi	r24, 0xDF	; 223
		USART_Reg(MB_N, ucsrb) |=(1<<6);
    7f66:	80 64       	ori	r24, 0x40	; 64
    7f68:	80 83       	st	Z, r24
    7f6a:	9e 01       	movw	r18, r28
    7f6c:	22 0f       	add	r18, r18
    7f6e:	33 1f       	adc	r19, r19
    7f70:	ce 01       	movw	r24, r28
    7f72:	88 0f       	add	r24, r24
    7f74:	99 1f       	adc	r25, r25
    7f76:	88 0f       	add	r24, r24
    7f78:	99 1f       	adc	r25, r25
    7f7a:	88 0f       	add	r24, r24
    7f7c:	99 1f       	adc	r25, r25
    7f7e:	28 0f       	add	r18, r24
    7f80:	39 1f       	adc	r19, r25
    7f82:	22 0f       	add	r18, r18
    7f84:	33 1f       	adc	r19, r19
    7f86:	22 57       	subi	r18, 0x72	; 114
    7f88:	3f 4b       	sbci	r19, 0xBF	; 191
    7f8a:	f9 01       	movw	r30, r18
    7f8c:	e5 90       	lpm	r14, Z+
    7f8e:	f4 90       	lpm	r15, Z+
		USART_Reg(MB_N, ucsra) |=(1<<6);	//Clear TxC pending interrupt		
    7f90:	f7 01       	movw	r30, r14
    7f92:	80 81       	ld	r24, Z
    7f94:	80 64       	ori	r24, 0x40	; 64
    7f96:	80 83       	st	Z, r24
    7f98:	fb 01       	movw	r30, r22
    7f9a:	40 81       	ld	r20, Z
    7f9c:	7d cf       	rjmp	.-262    	; 0x7e98 <Modbus_TX+0x7a>
    7f9e:	c7 01       	movw	r24, r14
    7fa0:	86 56       	subi	r24, 0x66	; 102
    7fa2:	9f 4b       	sbci	r25, 0xBF	; 191
    7fa4:	fc 01       	movw	r30, r24
    7fa6:	25 91       	lpm	r18, Z+
    7fa8:	34 91       	lpm	r19, Z+

// ~~~~~~~~~~~~~~~~~~
void
MB_S_Tx(uint8_t MB_N)
{
	USART_Func(MB_N, LED);
    7faa:	f9 01       	movw	r30, r18
    7fac:	19 95       	eicall
		break;
	case Role_Master:
		MB_M_Tx(MB_N);
		break;
	}
}
    7fae:	df 91       	pop	r29
    7fb0:	cf 91       	pop	r28
    7fb2:	1f 91       	pop	r17
    7fb4:	ff 90       	pop	r15
    7fb6:	ef 90       	pop	r14
    7fb8:	df 90       	pop	r13
    7fba:	cf 90       	pop	r12
    7fbc:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~
static uint8_t
MB_Port_N(usart_t *usart)
{
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Port[MB_N].usart_field)!=usart; MB_N++);
    7fbe:	10 e0       	ldi	r17, 0x00	; 0
    7fc0:	c0 e0       	ldi	r28, 0x00	; 0
    7fc2:	d0 e0       	ldi	r29, 0x00	; 0
    7fc4:	53 cf       	rjmp	.-346    	; 0x7e6c <Modbus_TX+0x4e>

00007fc6 <MB_SingleRun>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_SingleRun(uint8_t MB_N, uint8_t Addr, uint8_t Func, uint16_t StartAddr, uint16_t Qt, void *Buf)
{
    7fc6:	df 92       	push	r13
    7fc8:	ef 92       	push	r14
    7fca:	ff 92       	push	r15
    7fcc:	0f 93       	push	r16
    7fce:	1f 93       	push	r17
    7fd0:	cf 93       	push	r28
    7fd2:	df 93       	push	r29
    7fd4:	d8 2e       	mov	r13, r24
    7fd6:	94 2f       	mov	r25, r20
    7fd8:	a9 01       	movw	r20, r18
	if (MB_SingleState[MB_N]!=MB_SingleIdle)
    7fda:	c8 2f       	mov	r28, r24
    7fdc:	d0 e0       	ldi	r29, 0x00	; 0
    7fde:	9e 01       	movw	r18, r28
    7fe0:	21 55       	subi	r18, 0x51	; 81
    7fe2:	39 4f       	sbci	r19, 0xF9	; 249
    7fe4:	f9 01       	movw	r30, r18
    7fe6:	80 81       	ld	r24, Z
    7fe8:	88 23       	and	r24, r24
    7fea:	91 f5       	brne	.+100    	; 0x8050 <MB_SingleRun+0x8a>
		return;

	MB_SingleQuery[MB_N].Addr				= Addr;
    7fec:	de 01       	movw	r26, r28
    7fee:	aa 0f       	add	r26, r26
    7ff0:	bb 1f       	adc	r27, r27
    7ff2:	aa 0f       	add	r26, r26
    7ff4:	bb 1f       	adc	r27, r27
    7ff6:	aa 0f       	add	r26, r26
    7ff8:	bb 1f       	adc	r27, r27
    7ffa:	a6 52       	subi	r26, 0x26	; 38
    7ffc:	bb 4f       	sbci	r27, 0xFB	; 251
    7ffe:	6c 93       	st	X, r22
	MB_SingleQuery[MB_N].Func				= Func;
    8000:	11 96       	adiw	r26, 0x01	; 1
    8002:	9c 93       	st	X, r25
    8004:	11 97       	sbiw	r26, 0x01	; 1
	MB_SingleQuery[MB_N].StartAddr	= StartAddr;
    8006:	be 01       	movw	r22, r28
    8008:	66 0f       	add	r22, r22
    800a:	77 1f       	adc	r23, r23
    800c:	66 0f       	add	r22, r22
    800e:	77 1f       	adc	r23, r23
    8010:	fb 01       	movw	r30, r22
    8012:	ee 0f       	add	r30, r30
    8014:	ff 1f       	adc	r31, r31
    8016:	e4 52       	subi	r30, 0x24	; 36
    8018:	fb 4f       	sbci	r31, 0xFB	; 251
    801a:	51 83       	std	Z+1, r21	; 0x01
    801c:	40 83       	st	Z, r20
	MB_SingleQuery[MB_N].Qt					= Qt;
    801e:	ae 01       	movw	r20, r28
    8020:	44 0f       	add	r20, r20
    8022:	55 1f       	adc	r21, r21
    8024:	fa 01       	movw	r30, r20
    8026:	ee 0f       	add	r30, r30
    8028:	ff 1f       	adc	r31, r31
    802a:	ee 0f       	add	r30, r30
    802c:	ff 1f       	adc	r31, r31
    802e:	e2 52       	subi	r30, 0x22	; 34
    8030:	fb 4f       	sbci	r31, 0xFB	; 251
    8032:	11 83       	std	Z+1, r17	; 0x01
    8034:	00 83       	st	Z, r16
	MB_SingleQuery[MB_N].Buf				= Buf;
    8036:	17 96       	adiw	r26, 0x07	; 7
    8038:	fc 92       	st	X, r15
    803a:	ee 92       	st	-X, r14
    803c:	16 97       	sbiw	r26, 0x06	; 6

	MB_SingleState[MB_N] = MB_SingleStart;
    803e:	81 e0       	ldi	r24, 0x01	; 1
    8040:	f9 01       	movw	r30, r18
    8042:	80 83       	st	Z, r24
	if (MB_State[MB_N]==MB_Proc && !LastProcSingle) {
    8044:	fe 01       	movw	r30, r28
    8046:	ee 53       	subi	r30, 0x3E	; 62
    8048:	fa 4f       	sbci	r31, 0xFA	; 250
    804a:	80 81       	ld	r24, Z
    804c:	84 30       	cpi	r24, 0x04	; 4
    804e:	41 f0       	breq	.+16     	; 0x8060 <MB_SingleRun+0x9a>
			IntOff();
			MB_Transm(MB_N);
			IntOn();
		}
	}
}
    8050:	df 91       	pop	r29
    8052:	cf 91       	pop	r28
    8054:	1f 91       	pop	r17
    8056:	0f 91       	pop	r16
    8058:	ff 90       	pop	r15
    805a:	ef 90       	pop	r14
    805c:	df 90       	pop	r13
    805e:	08 95       	ret
	MB_SingleQuery[MB_N].StartAddr	= StartAddr;
	MB_SingleQuery[MB_N].Qt					= Qt;
	MB_SingleQuery[MB_N].Buf				= Buf;

	MB_SingleState[MB_N] = MB_SingleStart;
	if (MB_State[MB_N]==MB_Proc && !LastProcSingle) {
    8060:	80 91 e2 04 	lds	r24, 0x04E2
    8064:	88 23       	and	r24, r24
    8066:	a1 f7       	brne	.-24     	; 0x8050 <MB_SingleRun+0x8a>
		uint16_t T = (CurrSlave[MB_N]==0 ? MB_M_Period[MB_N] : MB_M_Timeout[MB_N]) - GetTimer16(TD_MB_Idle+MB_N);
    8068:	fe 01       	movw	r30, r28
    806a:	ec 5a       	subi	r30, 0xAC	; 172
    806c:	f9 4f       	sbci	r31, 0xF9	; 249
    806e:	80 81       	ld	r24, Z
    8070:	88 23       	and	r24, r24
    8072:	09 f0       	breq	.+2      	; 0x8076 <MB_SingleRun+0xb0>
    8074:	4d c0       	rjmp	.+154    	; 0x8110 <MB_SingleRun+0x14a>
    8076:	43 55       	subi	r20, 0x53	; 83
    8078:	59 4f       	sbci	r21, 0xF9	; 249
    807a:	fa 01       	movw	r30, r20
    807c:	40 81       	ld	r20, Z
    807e:	51 81       	ldd	r21, Z+1	; 0x01
    8080:	20 91 e8 04 	lds	r18, 0x04E8
    8084:	2d 0d       	add	r18, r13

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    8086:	8f b7       	in	r24, 0x3f	; 63
    8088:	80 78       	andi	r24, 0x80	; 128
    808a:	80 93 ee 02 	sts	0x02EE, r24
	cli();
    808e:	f8 94       	cli
    8090:	e2 2f       	mov	r30, r18
    8092:	f0 e0       	ldi	r31, 0x00	; 0
    8094:	ee 0f       	add	r30, r30
    8096:	ff 1f       	adc	r31, r31
    8098:	e1 5b       	subi	r30, 0xB1	; 177
    809a:	fc 4f       	sbci	r31, 0xFC	; 252
    809c:	a0 81       	ld	r26, Z
    809e:	b1 81       	ldd	r27, Z+1	; 0x01

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    80a0:	88 23       	and	r24, r24
    80a2:	09 f0       	breq	.+2      	; 0x80a6 <MB_SingleRun+0xe0>
		sei();
    80a4:	78 94       	sei
    80a6:	ca 01       	movw	r24, r20
    80a8:	8a 1b       	sub	r24, r26
    80aa:	9b 0b       	sbc	r25, r27
		if (T<MB_M_Pause_Min)
    80ac:	85 30       	cpi	r24, 0x05	; 5
    80ae:	91 05       	cpc	r25, r1
    80b0:	a8 f1       	brcs	.+106    	; 0x811c <MB_SingleRun+0x156>

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    80b2:	8f b7       	in	r24, 0x3f	; 63
    80b4:	80 78       	andi	r24, 0x80	; 128
    80b6:	80 93 ee 02 	sts	0x02EE, r24
	cli();
    80ba:	f8 94       	cli
    80bc:	cb 01       	movw	r24, r22
    80be:	88 0f       	add	r24, r24
    80c0:	99 1f       	adc	r25, r25
    80c2:	88 0f       	add	r24, r24
    80c4:	99 1f       	adc	r25, r25
    80c6:	86 0f       	add	r24, r22
    80c8:	97 1f       	adc	r25, r23
    80ca:	86 56       	subi	r24, 0x66	; 102
    80cc:	9f 4b       	sbci	r25, 0xBF	; 191
    80ce:	fc 01       	movw	r30, r24
    80d0:	25 91       	lpm	r18, Z+
    80d2:	34 91       	lpm	r19, Z+
			StartTimer16(TD_MB_Idle+MB_N, MB_M_Pause_Min-T);
		else {
			IntOff();
			USART_Func(MB_N, LED);
    80d4:	f9 01       	movw	r30, r18
    80d6:	19 95       	eicall

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    80d8:	80 91 ee 02 	lds	r24, 0x02EE
    80dc:	88 23       	and	r24, r24
    80de:	09 f0       	breq	.+2      	; 0x80e2 <MB_SingleRun+0x11c>
		sei();
    80e0:	78 94       	sei
			IntOn();
			ResetTimer16(TD_MB_Idle+MB_N);
    80e2:	80 91 e8 04 	lds	r24, 0x04E8
    80e6:	8d 0d       	add	r24, r13
    80e8:	0e 94 40 26 	call	0x4c80	; 0x4c80 <ResetTimer16>
			FormSingle(MB_N);
    80ec:	8d 2d       	mov	r24, r13
    80ee:	0e 94 63 3a 	call	0x74c6	; 0x74c6 <FormSingle>

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    80f2:	8f b7       	in	r24, 0x3f	; 63
    80f4:	80 78       	andi	r24, 0x80	; 128
    80f6:	80 93 ee 02 	sts	0x02EE, r24
	cli();
    80fa:	f8 94       	cli
			IntOff();
			MB_Transm(MB_N);
    80fc:	8d 2d       	mov	r24, r13
    80fe:	0e 94 09 33 	call	0x6612	; 0x6612 <MB_Transm>

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    8102:	80 91 ee 02 	lds	r24, 0x02EE
    8106:	88 23       	and	r24, r24
    8108:	09 f4       	brne	.+2      	; 0x810c <MB_SingleRun+0x146>
    810a:	a2 cf       	rjmp	.-188    	; 0x8050 <MB_SingleRun+0x8a>
		sei();
    810c:	78 94       	sei
    810e:	a0 cf       	rjmp	.-192    	; 0x8050 <MB_SingleRun+0x8a>
	MB_SingleQuery[MB_N].Qt					= Qt;
	MB_SingleQuery[MB_N].Buf				= Buf;

	MB_SingleState[MB_N] = MB_SingleStart;
	if (MB_State[MB_N]==MB_Proc && !LastProcSingle) {
		uint16_t T = (CurrSlave[MB_N]==0 ? MB_M_Period[MB_N] : MB_M_Timeout[MB_N]) - GetTimer16(TD_MB_Idle+MB_N);
    8110:	c7 5d       	subi	r28, 0xD7	; 215
    8112:	d6 4f       	sbci	r29, 0xF6	; 246
    8114:	88 81       	ld	r24, Y
    8116:	48 2f       	mov	r20, r24
    8118:	50 e0       	ldi	r21, 0x00	; 0
    811a:	b2 cf       	rjmp	.-156    	; 0x8080 <MB_SingleRun+0xba>
		if (T<MB_M_Pause_Min)
			StartTimer16(TD_MB_Idle+MB_N, MB_M_Pause_Min-T);
    811c:	65 e0       	ldi	r22, 0x05	; 5
    811e:	70 e0       	ldi	r23, 0x00	; 0
    8120:	68 1b       	sub	r22, r24
    8122:	79 0b       	sbc	r23, r25
    8124:	82 2f       	mov	r24, r18
    8126:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
    812a:	92 cf       	rjmp	.-220    	; 0x8050 <MB_SingleRun+0x8a>

0000812c <MB_Master_MaxCycle_Clear>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_Master_MaxCycle_Clear(uint8_t MB_N)
{
	MB_Master_MaxCycle[MB_N] = 0;
    812c:	e8 2f       	mov	r30, r24
    812e:	f0 e0       	ldi	r31, 0x00	; 0
    8130:	ee 0f       	add	r30, r30
    8132:	ff 1f       	adc	r31, r31
    8134:	e1 50       	subi	r30, 0x01	; 1
    8136:	f9 4f       	sbci	r31, 0xF9	; 249
    8138:	11 82       	std	Z+1, r1	; 0x01
    813a:	10 82       	st	Z, r1
}
    813c:	08 95       	ret

0000813e <MB_M_Cycle>:

// ~~~~~~~~~~~~~~~~~~~~~
void
MB_M_Cycle(uint8_t MB_N)
{
    813e:	ff 92       	push	r15
    8140:	0f 93       	push	r16
    8142:	1f 93       	push	r17
    8144:	cf 93       	push	r28
    8146:	df 93       	push	r29
    8148:	f8 2e       	mov	r15, r24
	if (Timer16Stopp(TD_MB_SlaveOff+MB_N))
    814a:	10 91 e8 04 	lds	r17, 0x04E8
    814e:	18 0f       	add	r17, r24
    8150:	01 2f       	mov	r16, r17
    8152:	0f 5f       	subi	r16, 0xFF	; 255
    8154:	80 2f       	mov	r24, r16
    8156:	0e 94 96 25 	call	0x4b2c	; 0x4b2c <Timer16Stopp>
    815a:	88 23       	and	r24, r24
    815c:	d9 f4       	brne	.+54     	; 0x8194 <MB_M_Cycle+0x56>
		SlavesOn(MB_N);

	if (Timer16Stopp(TD_MB_Idle+MB_N)){
    815e:	81 2f       	mov	r24, r17
    8160:	0e 94 96 25 	call	0x4b2c	; 0x4b2c <Timer16Stopp>
    8164:	88 23       	and	r24, r24
    8166:	81 f0       	breq	.+32     	; 0x8188 <MB_M_Cycle+0x4a>
		cli();
    8168:	f8 94       	cli
		if(MB_State[MB_N] == MB_Idle) MB_State[MB_N] = MB_NoReply;
    816a:	cf 2d       	mov	r28, r15
    816c:	d0 e0       	ldi	r29, 0x00	; 0
    816e:	fe 01       	movw	r30, r28
    8170:	ee 53       	subi	r30, 0x3E	; 62
    8172:	fa 4f       	sbci	r31, 0xFA	; 250
    8174:	80 81       	ld	r24, Z
    8176:	81 30       	cpi	r24, 0x01	; 1
    8178:	29 f1       	breq	.+74     	; 0x81c4 <MB_M_Cycle+0x86>
		sei();
    817a:	78 94       	sei
	}
	else return;
	
	switch (MB_State[MB_N]) {
    817c:	80 81       	ld	r24, Z
    817e:	84 30       	cpi	r24, 0x04	; 4
    8180:	39 f1       	breq	.+78     	; 0x81d0 <MB_M_Cycle+0x92>
    8182:	85 30       	cpi	r24, 0x05	; 5
    8184:	09 f4       	brne	.+2      	; 0x8188 <MB_M_Cycle+0x4a>
    8186:	52 c0       	rjmp	.+164    	; 0x822c <MB_M_Cycle+0xee>
		cli();
		MB_Transm(MB_N);
		sei();
		break;
	}
}
    8188:	df 91       	pop	r29
    818a:	cf 91       	pop	r28
    818c:	1f 91       	pop	r17
    818e:	0f 91       	pop	r16
    8190:	ff 90       	pop	r15
    8192:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~
static void
SlavesOn(uint8_t MB_N)
{
	SlaveSkip[MB_N] = 0;
    8194:	af 2d       	mov	r26, r15
    8196:	b0 e0       	ldi	r27, 0x00	; 0
    8198:	fd 01       	movw	r30, r26
    819a:	ee 0f       	add	r30, r30
    819c:	ff 1f       	adc	r31, r31
    819e:	ee 0f       	add	r30, r30
    81a0:	ff 1f       	adc	r31, r31
    81a2:	ec 51       	subi	r30, 0x1C	; 28
    81a4:	fb 4f       	sbci	r31, 0xFB	; 251
    81a6:	10 82       	st	Z, r1
    81a8:	11 82       	std	Z+1, r1	; 0x01
    81aa:	12 82       	std	Z+2, r1	; 0x02
    81ac:	13 82       	std	Z+3, r1	; 0x03
	StartTimer16(TD_MB_SlaveOff+MB_N, 100*MB_M_TimeOff[MB_N]);
    81ae:	a1 52       	subi	r26, 0x21	; 33
    81b0:	ba 4f       	sbci	r27, 0xFA	; 250
    81b2:	6c 91       	ld	r22, X
    81b4:	84 e6       	ldi	r24, 0x64	; 100
    81b6:	68 9f       	mul	r22, r24
    81b8:	b0 01       	movw	r22, r0
    81ba:	11 24       	eor	r1, r1
    81bc:	80 2f       	mov	r24, r16
    81be:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
    81c2:	cd cf       	rjmp	.-102    	; 0x815e <MB_M_Cycle+0x20>
	if (Timer16Stopp(TD_MB_SlaveOff+MB_N))
		SlavesOn(MB_N);

	if (Timer16Stopp(TD_MB_Idle+MB_N)){
		cli();
		if(MB_State[MB_N] == MB_Idle) MB_State[MB_N] = MB_NoReply;
    81c4:	85 e0       	ldi	r24, 0x05	; 5
    81c6:	80 83       	st	Z, r24
		sei();
    81c8:	78 94       	sei
	}
	else return;
	
	switch (MB_State[MB_N]) {
    81ca:	80 81       	ld	r24, Z
    81cc:	84 30       	cpi	r24, 0x04	; 4
    81ce:	c9 f6       	brne	.-78     	; 0x8182 <MB_M_Cycle+0x44>
		cli();
		MB_Transm(MB_N);
		sei();
		break;
	case MB_Proc:
		cli();
    81d0:	f8 94       	cli
    81d2:	ce 01       	movw	r24, r28
    81d4:	88 0f       	add	r24, r24
    81d6:	99 1f       	adc	r25, r25
    81d8:	88 0f       	add	r24, r24
    81da:	99 1f       	adc	r25, r25
    81dc:	9c 01       	movw	r18, r24
    81de:	22 0f       	add	r18, r18
    81e0:	33 1f       	adc	r19, r19
    81e2:	22 0f       	add	r18, r18
    81e4:	33 1f       	adc	r19, r19
    81e6:	28 0f       	add	r18, r24
    81e8:	39 1f       	adc	r19, r25
    81ea:	26 56       	subi	r18, 0x66	; 102
    81ec:	3f 4b       	sbci	r19, 0xBF	; 191
    81ee:	f9 01       	movw	r30, r18
    81f0:	85 91       	lpm	r24, Z+
    81f2:	94 91       	lpm	r25, Z+
		USART_Func(MB_N, LED);
    81f4:	fc 01       	movw	r30, r24
    81f6:	19 95       	eicall
		sei();
    81f8:	78 94       	sei
		switch (MB_SingleState[MB_N]) {
    81fa:	c1 55       	subi	r28, 0x51	; 81
    81fc:	d9 4f       	sbci	r29, 0xF9	; 249
    81fe:	88 81       	ld	r24, Y
    8200:	88 23       	and	r24, r24
    8202:	b1 f1       	breq	.+108    	; 0x8270 <MB_M_Cycle+0x132>
    8204:	81 30       	cpi	r24, 0x01	; 1
    8206:	81 f1       	breq	.+96     	; 0x8268 <MB_M_Cycle+0x12a>
				FormQuery(MB_N);
			else
				FormSingle(MB_N);
			break;
		}
		StartTimer16(TD_MB_Idle+MB_N, 0xFFFF);	//     
    8208:	80 91 e8 04 	lds	r24, 0x04E8
    820c:	8f 0d       	add	r24, r15
    820e:	6f ef       	ldi	r22, 0xFF	; 255
    8210:	7f ef       	ldi	r23, 0xFF	; 255
    8212:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
		cli();
    8216:	f8 94       	cli
		MB_Transm(MB_N);
    8218:	8f 2d       	mov	r24, r15
    821a:	0e 94 09 33 	call	0x6612	; 0x6612 <MB_Transm>
		sei();
    821e:	78 94       	sei
		break;
	}
}
    8220:	df 91       	pop	r29
    8222:	cf 91       	pop	r28
    8224:	1f 91       	pop	r17
    8226:	0f 91       	pop	r16
    8228:	ff 90       	pop	r15
    822a:	08 95       	ret
	}
	else return;
	
	switch (MB_State[MB_N]) {
	case MB_NoReply:
		FailSlave(MB_N);
    822c:	8f 2d       	mov	r24, r15
    822e:	0e 94 78 3b 	call	0x76f0	; 0x76f0 <FailSlave>
		switch (MB_SingleState[MB_N]) {
    8232:	fe 01       	movw	r30, r28
    8234:	e1 55       	subi	r30, 0x51	; 81
    8236:	f9 4f       	sbci	r31, 0xF9	; 249
    8238:	e0 81       	ld	r30, Z
    823a:	ee 23       	and	r30, r30
    823c:	e9 f4       	brne	.+58     	; 0x8278 <MB_M_Cycle+0x13a>
		case MB_SingleIdle:
			FormQuery(MB_N);
    823e:	8f 2d       	mov	r24, r15
    8240:	0e 94 11 3a 	call	0x7422	; 0x7422 <FormQuery>
		case MB_SingleStart:
			if (Try[MB_N]==0)
				FormSingle(MB_N);
			break;
		}
		StartTimer16(TD_MB_Idle+MB_N, 0xFFFF);	//     
    8244:	80 91 e8 04 	lds	r24, 0x04E8
    8248:	8f 0d       	add	r24, r15
    824a:	6f ef       	ldi	r22, 0xFF	; 255
    824c:	7f ef       	ldi	r23, 0xFF	; 255
    824e:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
		cli();
    8252:	f8 94       	cli
		MB_Transm(MB_N);
    8254:	8f 2d       	mov	r24, r15
    8256:	0e 94 09 33 	call	0x6612	; 0x6612 <MB_Transm>
		sei();
    825a:	78 94       	sei
		cli();
		MB_Transm(MB_N);
		sei();
		break;
	}
}
    825c:	df 91       	pop	r29
    825e:	cf 91       	pop	r28
    8260:	1f 91       	pop	r17
    8262:	0f 91       	pop	r16
    8264:	ff 90       	pop	r15
    8266:	08 95       	ret
		switch (MB_SingleState[MB_N]) {
		case MB_SingleIdle:
			FormQuery(MB_N);
			break;
		case MB_SingleStart:
			if (LastProcSingle)
    8268:	80 91 e2 04 	lds	r24, 0x04E2
    826c:	88 23       	and	r24, r24
    826e:	79 f0       	breq	.+30     	; 0x828e <MB_M_Cycle+0x150>
				FormQuery(MB_N);
    8270:	8f 2d       	mov	r24, r15
    8272:	0e 94 11 3a 	call	0x7422	; 0x7422 <FormQuery>
    8276:	c8 cf       	rjmp	.-112    	; 0x8208 <MB_M_Cycle+0xca>
	else return;
	
	switch (MB_State[MB_N]) {
	case MB_NoReply:
		FailSlave(MB_N);
		switch (MB_SingleState[MB_N]) {
    8278:	e1 30       	cpi	r30, 0x01	; 1
    827a:	21 f7       	brne	.-56     	; 0x8244 <MB_M_Cycle+0x106>
		case MB_SingleIdle:
			FormQuery(MB_N);
			break;
		case MB_SingleStart:
			if (Try[MB_N]==0)
    827c:	cd 51       	subi	r28, 0x1D	; 29
    827e:	db 4f       	sbci	r29, 0xFB	; 251
    8280:	88 81       	ld	r24, Y
    8282:	88 23       	and	r24, r24
    8284:	f9 f6       	brne	.-66     	; 0x8244 <MB_M_Cycle+0x106>
				FormSingle(MB_N);
    8286:	8f 2d       	mov	r24, r15
    8288:	0e 94 63 3a 	call	0x74c6	; 0x74c6 <FormSingle>
    828c:	db cf       	rjmp	.-74     	; 0x8244 <MB_M_Cycle+0x106>
			break;
		case MB_SingleStart:
			if (LastProcSingle)
				FormQuery(MB_N);
			else
				FormSingle(MB_N);
    828e:	8f 2d       	mov	r24, r15
    8290:	0e 94 63 3a 	call	0x74c6	; 0x74c6 <FormSingle>
    8294:	b9 cf       	rjmp	.-142    	; 0x8208 <MB_M_Cycle+0xca>

00008296 <MB_Cycle>:
}

// ~~~~~~~~~~~
void
MB_Cycle(void)
{
    8296:	cf 93       	push	r28
    8298:	df 93       	push	r29
	void MB_S_Timer_ISR(uint8_t);
	void MB_M_Timer_ISR(uint8_t);

	for (uint8_t MB_N=0; MB_N<Modbus_Qt; MB_N++){
		if(MB_TimerFlag & (1<<MB_N)){
    829a:	80 91 2a 09 	lds	r24, 0x092A
    829e:	80 fd       	sbrc	r24, 0
    82a0:	0c c0       	rjmp	.+24     	; 0x82ba <MB_Cycle+0x24>
    82a2:	c0 ea       	ldi	r28, 0xA0	; 160
    82a4:	d0 e4       	ldi	r29, 0x40	; 64

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    82a6:	fe 01       	movw	r30, r28
    82a8:	84 91       	lpm	r24, Z+
	}

	void MB_M_Cycle(uint8_t);

	for (uint8_t MB_N=0; MB_N<Modbus_Qt; MB_N++)
		if (prb(MB_Role+MB_N)==Role_Master)
    82aa:	81 30       	cpi	r24, 0x01	; 1
    82ac:	19 f4       	brne	.+6      	; 0x82b4 <MB_Cycle+0x1e>
			MB_M_Cycle(MB_N);
    82ae:	80 e0       	ldi	r24, 0x00	; 0
    82b0:	0e 94 9f 40 	call	0x813e	; 0x813e <MB_M_Cycle>
}
    82b4:	df 91       	pop	r29
    82b6:	cf 91       	pop	r28
    82b8:	08 95       	ret
	void MB_S_Timer_ISR(uint8_t);
	void MB_M_Timer_ISR(uint8_t);

	for (uint8_t MB_N=0; MB_N<Modbus_Qt; MB_N++){
		if(MB_TimerFlag & (1<<MB_N)){
			cli();
    82ba:	f8 94       	cli
			MB_TimerFlag &= ~(1<<MB_N);
    82bc:	80 91 2a 09 	lds	r24, 0x092A
    82c0:	8e 7f       	andi	r24, 0xFE	; 254
    82c2:	80 93 2a 09 	sts	0x092A, r24
			sei();
    82c6:	78 94       	sei
    82c8:	c0 ea       	ldi	r28, 0xA0	; 160
    82ca:	d0 e4       	ldi	r29, 0x40	; 64
    82cc:	fe 01       	movw	r30, r28
    82ce:	84 91       	lpm	r24, Z+
			switch (prb(MB_Role+MB_N)) {
    82d0:	88 23       	and	r24, r24
    82d2:	21 f4       	brne	.+8      	; 0x82dc <MB_Cycle+0x46>
			case Role_Slave:
				MB_S_Timer_ISR(MB_N);
    82d4:	80 e0       	ldi	r24, 0x00	; 0
    82d6:	0e 94 c1 34 	call	0x6982	; 0x6982 <MB_S_Timer_ISR>
    82da:	e5 cf       	rjmp	.-54     	; 0x82a6 <MB_Cycle+0x10>
	for (uint8_t MB_N=0; MB_N<Modbus_Qt; MB_N++){
		if(MB_TimerFlag & (1<<MB_N)){
			cli();
			MB_TimerFlag &= ~(1<<MB_N);
			sei();
			switch (prb(MB_Role+MB_N)) {
    82dc:	81 30       	cpi	r24, 0x01	; 1
    82de:	19 f7       	brne	.-58     	; 0x82a6 <MB_Cycle+0x10>
			case Role_Slave:
				MB_S_Timer_ISR(MB_N);
				break;
			case Role_Master:
				MB_M_Timer_ISR(MB_N);
    82e0:	80 e0       	ldi	r24, 0x00	; 0
    82e2:	0e 94 ee 3b 	call	0x77dc	; 0x77dc <MB_M_Timer_ISR>
    82e6:	df cf       	rjmp	.-66     	; 0x82a6 <MB_Cycle+0x10>

000082e8 <SetIP>:
	uint8_t IP3;
	uint8_t IP4;
} IP_Addr;

//~~~~~~~~~~~~~~
void SetIP(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
    82e8:	0f 93       	push	r16
    82ea:	fc 01       	movw	r30, r24
	IP->IP1 = IP1;
    82ec:	60 83       	st	Z, r22
	IP->IP2 = IP2;
    82ee:	41 83       	std	Z+1, r20	; 0x01
	IP->IP3 = IP3;
    82f0:	22 83       	std	Z+2, r18	; 0x02
	IP->IP4 = IP4;
    82f2:	03 83       	std	Z+3, r16	; 0x03
}
    82f4:	0f 91       	pop	r16
    82f6:	08 95       	ret

000082f8 <IP_compare_Const>:
uint8_t IP_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
    82f8:	0f 93       	push	r16
    82fa:	fc 01       	movw	r30, r24
	if((IP->IP1 == IP1) && (IP->IP2 == IP2) && (IP->IP3 == IP3) && (IP->IP4 == IP4)) return 1;
    82fc:	80 81       	ld	r24, Z
    82fe:	86 17       	cp	r24, r22
    8300:	21 f0       	breq	.+8      	; 0x830a <IP_compare_Const+0x12>
    8302:	20 e0       	ldi	r18, 0x00	; 0
	else return 0;
}
    8304:	82 2f       	mov	r24, r18
    8306:	0f 91       	pop	r16
    8308:	08 95       	ret
	IP->IP2 = IP2;
	IP->IP3 = IP3;
	IP->IP4 = IP4;
}
uint8_t IP_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	if((IP->IP1 == IP1) && (IP->IP2 == IP2) && (IP->IP3 == IP3) && (IP->IP4 == IP4)) return 1;
    830a:	81 81       	ldd	r24, Z+1	; 0x01
    830c:	84 17       	cp	r24, r20
    830e:	c9 f7       	brne	.-14     	; 0x8302 <IP_compare_Const+0xa>
    8310:	82 81       	ldd	r24, Z+2	; 0x02
    8312:	82 17       	cp	r24, r18
    8314:	b1 f7       	brne	.-20     	; 0x8302 <IP_compare_Const+0xa>
    8316:	20 e0       	ldi	r18, 0x00	; 0
    8318:	83 81       	ldd	r24, Z+3	; 0x03
    831a:	80 13       	cpse	r24, r16
    831c:	21 e0       	ldi	r18, 0x01	; 1
    831e:	81 e0       	ldi	r24, 0x01	; 1
    8320:	28 27       	eor	r18, r24
    8322:	f0 cf       	rjmp	.-32     	; 0x8304 <IP_compare_Const+0xc>

00008324 <GSM_StartCalling>:
uint8_t numOfCheckBallanceRetry=0;

uint8_t Message[3];  // 
uint8_t GSMBusyState=0; // " " 0 -  , 1 -  
void GSM_StartCalling(uint8_t inputN,uint8_t abonentN){
	Message[0]=1;
    8324:	91 e0       	ldi	r25, 0x01	; 1
    8326:	90 93 35 07 	sts	0x0735, r25
	Message[1]=inputN;
    832a:	80 93 36 07 	sts	0x0736, r24
	Message[2]=abonentN;
    832e:	60 93 37 07 	sts	0x0737, r22
}
    8332:	08 95       	ret

00008334 <InitFIFO>:
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    8334:	8f ef       	ldi	r24, 0xFF	; 255
    8336:	80 93 3e 07 	sts	0x073E, r24
	GSM_RX_FIFO_End = 255;
    833a:	80 93 53 06 	sts	0x0653, r24
	GSM_RxCharN = 0;
    833e:	10 92 60 0b 	sts	0x0B60, r1
	GSM_RX_FIFOOverFlow = 0;
    8342:	10 92 13 09 	sts	0x0913, r1
	GSM_RX_FIFOMax = 0;
    8346:	10 92 19 09 	sts	0x0919, r1
}
    834a:	08 95       	ret

0000834c <GetByteFromFIFO>:
// ~~~~~~~~~~~
void GetByteFromFIFO(uint8_t *ReadBuf, uint8_t *Index, uint8_t ReadBuf_Sz){
    834c:	0f 93       	push	r16
    834e:	1f 93       	push	r17
    8350:	cf 93       	push	r28
    8352:	df 93       	push	r29
    8354:	8c 01       	movw	r16, r24
    8356:	eb 01       	movw	r28, r22

	//Reset *Index if read buffer overflow
	if(*Index >= ReadBuf_Sz){
    8358:	88 81       	ld	r24, Y
    835a:	84 17       	cp	r24, r20
    835c:	08 f0       	brcs	.+2      	; 0x8360 <GetByteFromFIFO+0x14>
		*Index = 0;
    835e:	18 82       	st	Y, r1
		//TODO  
	}	

	if(GSM_RX_FIFO_Begin > GSM_RX_FIFO_End){
    8360:	80 91 3e 07 	lds	r24, 0x073E
    8364:	e0 91 53 06 	lds	r30, 0x0653
    8368:	e8 17       	cp	r30, r24
    836a:	f8 f4       	brcc	.+62     	; 0x83aa <GetByteFromFIFO+0x5e>
		if((GSM_RX_FIFO_End != 255)&&(GSM_RX_FIFO_End != 255))			
    836c:	ef 3f       	cpi	r30, 0xFF	; 255
    836e:	61 f0       	breq	.+24     	; 0x8388 <GetByteFromFIFO+0x3c>
			if(GSM_RX_FIFOMax < (GSM_RX_FIFO_Begin - GSM_RX_FIFO_End))
    8370:	20 91 19 09 	lds	r18, 0x0919
    8374:	80 91 3e 07 	lds	r24, 0x073E
    8378:	30 e0       	ldi	r19, 0x00	; 0
    837a:	90 e0       	ldi	r25, 0x00	; 0
    837c:	8e 1b       	sub	r24, r30
    837e:	91 09       	sbc	r25, r1
    8380:	28 17       	cp	r18, r24
    8382:	39 07       	cpc	r19, r25
    8384:	0c f4       	brge	.+2      	; 0x8388 <GetByteFromFIFO+0x3c>
    8386:	46 c0       	rjmp	.+140    	; 0x8414 <GetByteFromFIFO+0xc8>
				GSM_RX_FIFOMax =  GSM_RX_FIFO_Begin - GSM_RX_FIFO_End;
		GSM_RX_FIFO_End++;
    8388:	ef 5f       	subi	r30, 0xFF	; 255
    838a:	e0 93 53 06 	sts	0x0653, r30
		ReadBuf[*Index] = GSM_RX_FIFO[GSM_RX_FIFO_End];
    838e:	88 81       	ld	r24, Y
    8390:	d8 01       	movw	r26, r16
    8392:	a8 0f       	add	r26, r24
    8394:	b1 1d       	adc	r27, r1
    8396:	f0 e0       	ldi	r31, 0x00	; 0
    8398:	ef 51       	subi	r30, 0x1F	; 31
    839a:	fa 4f       	sbci	r31, 0xFA	; 250
    839c:	80 81       	ld	r24, Z
    839e:	8c 93       	st	X, r24
		*Index=*Index+1;
    83a0:	88 81       	ld	r24, Y
    83a2:	8f 5f       	subi	r24, 0xFF	; 255
    83a4:	88 83       	st	Y, r24
    83a6:	e0 91 53 06 	lds	r30, 0x0653
	}
	if(GSM_RX_FIFO_End > GSM_RX_FIFO_Begin){
    83aa:	80 91 3e 07 	lds	r24, 0x073E
    83ae:	8e 17       	cp	r24, r30
    83b0:	28 f5       	brcc	.+74     	; 0x83fc <GetByteFromFIFO+0xb0>
		if((GSM_RX_FIFO_End != 255)&&(GSM_RX_FIFO_End != 255))
    83b2:	ef 3f       	cpi	r30, 0xFF	; 255
    83b4:	99 f0       	breq	.+38     	; 0x83dc <GetByteFromFIFO+0x90>
			if(GSM_RX_FIFOMax < (GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End  + GSM_RX_FIFO_Begin))
    83b6:	20 91 19 09 	lds	r18, 0x0919
    83ba:	80 91 3e 07 	lds	r24, 0x073E
    83be:	30 e0       	ldi	r19, 0x00	; 0
    83c0:	90 e0       	ldi	r25, 0x00	; 0
    83c2:	8c 59       	subi	r24, 0x9C	; 156
    83c4:	9f 4f       	sbci	r25, 0xFF	; 255
    83c6:	8e 1b       	sub	r24, r30
    83c8:	91 09       	sbc	r25, r1
    83ca:	28 17       	cp	r18, r24
    83cc:	39 07       	cpc	r19, r25
    83ce:	dc f0       	brlt	.+54     	; 0x8406 <GetByteFromFIFO+0xba>
				GSM_RX_FIFOMax = GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End  + GSM_RX_FIFO_Begin;
		GSM_RX_FIFO_End++;
    83d0:	8e 2f       	mov	r24, r30
    83d2:	8f 5f       	subi	r24, 0xFF	; 255
    83d4:	80 93 53 06 	sts	0x0653, r24
		if(GSM_RX_FIFO_End >= GSM_RX_FIFO_SIZE) GSM_RX_FIFO_End = 0;
    83d8:	84 36       	cpi	r24, 0x64	; 100
    83da:	10 f0       	brcs	.+4      	; 0x83e0 <GetByteFromFIFO+0x94>
    83dc:	10 92 53 06 	sts	0x0653, r1
		ReadBuf[*Index] = GSM_RX_FIFO[GSM_RX_FIFO_End];
    83e0:	88 81       	ld	r24, Y
    83e2:	08 0f       	add	r16, r24
    83e4:	11 1d       	adc	r17, r1
    83e6:	e0 91 53 06 	lds	r30, 0x0653
    83ea:	f0 e0       	ldi	r31, 0x00	; 0
    83ec:	ef 51       	subi	r30, 0x1F	; 31
    83ee:	fa 4f       	sbci	r31, 0xFA	; 250
    83f0:	80 81       	ld	r24, Z
    83f2:	f8 01       	movw	r30, r16
    83f4:	80 83       	st	Z, r24
		*Index=*Index+1;
    83f6:	88 81       	ld	r24, Y
    83f8:	8f 5f       	subi	r24, 0xFF	; 255
    83fa:	88 83       	st	Y, r24
	}
}
    83fc:	df 91       	pop	r29
    83fe:	cf 91       	pop	r28
    8400:	1f 91       	pop	r17
    8402:	0f 91       	pop	r16
    8404:	08 95       	ret
		*Index=*Index+1;
	}
	if(GSM_RX_FIFO_End > GSM_RX_FIFO_Begin){
		if((GSM_RX_FIFO_End != 255)&&(GSM_RX_FIFO_End != 255))
			if(GSM_RX_FIFOMax < (GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End  + GSM_RX_FIFO_Begin))
				GSM_RX_FIFOMax = GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End  + GSM_RX_FIFO_Begin;
    8406:	80 91 3e 07 	lds	r24, 0x073E
    840a:	8c 59       	subi	r24, 0x9C	; 156
    840c:	8e 1b       	sub	r24, r30
    840e:	80 93 19 09 	sts	0x0919, r24
    8412:	de cf       	rjmp	.-68     	; 0x83d0 <GetByteFromFIFO+0x84>
	}	

	if(GSM_RX_FIFO_Begin > GSM_RX_FIFO_End){
		if((GSM_RX_FIFO_End != 255)&&(GSM_RX_FIFO_End != 255))			
			if(GSM_RX_FIFOMax < (GSM_RX_FIFO_Begin - GSM_RX_FIFO_End))
				GSM_RX_FIFOMax =  GSM_RX_FIFO_Begin - GSM_RX_FIFO_End;
    8414:	80 91 3e 07 	lds	r24, 0x073E
    8418:	8e 1b       	sub	r24, r30
    841a:	80 93 19 09 	sts	0x0919, r24
    841e:	b4 cf       	rjmp	.-152    	; 0x8388 <GetByteFromFIFO+0x3c>

00008420 <GetStringFromFIFO>:
//        
uint8_t GetStringFromFIFO(void){

	uint8_t StrLength = 0;

	while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    8420:	90 91 3e 07 	lds	r25, 0x073E
    8424:	80 91 53 06 	lds	r24, 0x0653
    8428:	98 17       	cp	r25, r24
    842a:	39 f1       	breq	.+78     	; 0x847a <GetStringFromFIFO+0x5a>
		
		GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);
    842c:	81 ee       	ldi	r24, 0xE1	; 225
    842e:	97 e0       	ldi	r25, 0x07	; 7
    8430:	60 e6       	ldi	r22, 0x60	; 96
    8432:	7b e0       	ldi	r23, 0x0B	; 11
    8434:	44 e6       	ldi	r20, 0x64	; 100
    8436:	0e 94 a6 41 	call	0x834c	; 0x834c <GetByteFromFIFO>

		//   : xxxxxxxxxxxxxxxx<CR><LF>
		//	'\r' CR - carridge return 0x0D
		//	'\n' LF - line feed 0x0A
		//   xxxxxxxxxxxxxxxx<\0>
		if( (GSM_RxCharN >= 2) && (GSM_RxStr[GSM_RxCharN-2]== '\r') && (GSM_RxStr[GSM_RxCharN-1]== '\n') ){
    843a:	80 91 60 0b 	lds	r24, 0x0B60
    843e:	82 30       	cpi	r24, 0x02	; 2
    8440:	78 f3       	brcs	.-34     	; 0x8420 <GetStringFromFIFO>
    8442:	e0 91 60 0b 	lds	r30, 0x0B60
    8446:	f0 e0       	ldi	r31, 0x00	; 0
    8448:	e1 52       	subi	r30, 0x21	; 33
    844a:	f8 4f       	sbci	r31, 0xF8	; 248
    844c:	80 81       	ld	r24, Z
    844e:	8d 30       	cpi	r24, 0x0D	; 13
    8450:	39 f7       	brne	.-50     	; 0x8420 <GetStringFromFIFO>
    8452:	e0 91 60 0b 	lds	r30, 0x0B60
    8456:	f0 e0       	ldi	r31, 0x00	; 0
    8458:	e0 52       	subi	r30, 0x20	; 32
    845a:	f8 4f       	sbci	r31, 0xF8	; 248
    845c:	80 81       	ld	r24, Z
    845e:	8a 30       	cpi	r24, 0x0A	; 10
    8460:	f9 f6       	brne	.-66     	; 0x8420 <GetStringFromFIFO>
			GSM_RxStr[GSM_RxCharN-2] = '\0';
    8462:	e0 91 60 0b 	lds	r30, 0x0B60
    8466:	f0 e0       	ldi	r31, 0x00	; 0
    8468:	e1 52       	subi	r30, 0x21	; 33
    846a:	f8 4f       	sbci	r31, 0xF8	; 248
    846c:	10 82       	st	Z, r1
			StrLength = GSM_RxCharN-1;
    846e:	80 91 60 0b 	lds	r24, 0x0B60
    8472:	81 50       	subi	r24, 0x01	; 1
			GSM_RxCharN = 0;
    8474:	10 92 60 0b 	sts	0x0B60, r1
    8478:	08 95       	ret
//        
uint8_t GetStringFromFIFO(void){

	uint8_t StrLength = 0;

	while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    847a:	80 e0       	ldi	r24, 0x00	; 0
		}

	}//while
	
	return StrLength;
}
    847c:	08 95       	ret

0000847e <GetStringFromFIFOwithOverflowDetect>:

uint8_t GetStringFromFIFOwithOverflowDetect(void){
    847e:	04 c0       	rjmp	.+8      	; 0x8488 <GetStringFromFIFOwithOverflowDetect+0xa>

		//   : xxxxxxxxxxxxxxxx<CR><LF>
		//	'\r' CR - carridge return 0x0D
		//	'\n' LF - line feed 0x0A
		//   xxxxxxxxxxxxxxxx<\0>
		if( ((GSM_RxCharN >= 2) && (GSM_RxStr[GSM_RxCharN-2]== '\r') && (GSM_RxStr[GSM_RxCharN-1]== '\n'))||(GSM_RxCharN==GSM_RXSTR_SIZE-1) ){
    8480:	80 91 60 0b 	lds	r24, 0x0B60
    8484:	83 36       	cpi	r24, 0x63	; 99
    8486:	09 f1       	breq	.+66     	; 0x84ca <GetStringFromFIFOwithOverflowDetect+0x4c>

uint8_t GetStringFromFIFOwithOverflowDetect(void){

	uint8_t StrLength = 0;

	while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    8488:	90 91 3e 07 	lds	r25, 0x073E
    848c:	80 91 53 06 	lds	r24, 0x0653
    8490:	98 17       	cp	r25, r24
    8492:	39 f1       	breq	.+78     	; 0x84e2 <GetStringFromFIFOwithOverflowDetect+0x64>
		
		GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);
    8494:	81 ee       	ldi	r24, 0xE1	; 225
    8496:	97 e0       	ldi	r25, 0x07	; 7
    8498:	60 e6       	ldi	r22, 0x60	; 96
    849a:	7b e0       	ldi	r23, 0x0B	; 11
    849c:	44 e6       	ldi	r20, 0x64	; 100
    849e:	0e 94 a6 41 	call	0x834c	; 0x834c <GetByteFromFIFO>

		//   : xxxxxxxxxxxxxxxx<CR><LF>
		//	'\r' CR - carridge return 0x0D
		//	'\n' LF - line feed 0x0A
		//   xxxxxxxxxxxxxxxx<\0>
		if( ((GSM_RxCharN >= 2) && (GSM_RxStr[GSM_RxCharN-2]== '\r') && (GSM_RxStr[GSM_RxCharN-1]== '\n'))||(GSM_RxCharN==GSM_RXSTR_SIZE-1) ){
    84a2:	80 91 60 0b 	lds	r24, 0x0B60
    84a6:	82 30       	cpi	r24, 0x02	; 2
    84a8:	58 f3       	brcs	.-42     	; 0x8480 <GetStringFromFIFOwithOverflowDetect+0x2>
    84aa:	e0 91 60 0b 	lds	r30, 0x0B60
    84ae:	f0 e0       	ldi	r31, 0x00	; 0
    84b0:	e1 52       	subi	r30, 0x21	; 33
    84b2:	f8 4f       	sbci	r31, 0xF8	; 248
    84b4:	80 81       	ld	r24, Z
    84b6:	8d 30       	cpi	r24, 0x0D	; 13
    84b8:	19 f7       	brne	.-58     	; 0x8480 <GetStringFromFIFOwithOverflowDetect+0x2>
    84ba:	e0 91 60 0b 	lds	r30, 0x0B60
    84be:	f0 e0       	ldi	r31, 0x00	; 0
    84c0:	e0 52       	subi	r30, 0x20	; 32
    84c2:	f8 4f       	sbci	r31, 0xF8	; 248
    84c4:	80 81       	ld	r24, Z
    84c6:	8a 30       	cpi	r24, 0x0A	; 10
    84c8:	d9 f6       	brne	.-74     	; 0x8480 <GetStringFromFIFOwithOverflowDetect+0x2>
			GSM_RxStr[GSM_RxCharN-2] = '\0';
    84ca:	e0 91 60 0b 	lds	r30, 0x0B60
    84ce:	f0 e0       	ldi	r31, 0x00	; 0
    84d0:	e1 52       	subi	r30, 0x21	; 33
    84d2:	f8 4f       	sbci	r31, 0xF8	; 248
    84d4:	10 82       	st	Z, r1
			StrLength = GSM_RxCharN-1;
    84d6:	80 91 60 0b 	lds	r24, 0x0B60
    84da:	81 50       	subi	r24, 0x01	; 1
			GSM_RxCharN = 0;
    84dc:	10 92 60 0b 	sts	0x0B60, r1
    84e0:	08 95       	ret

uint8_t GetStringFromFIFOwithOverflowDetect(void){

	uint8_t StrLength = 0;

	while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    84e2:	80 e0       	ldi	r24, 0x00	; 0
		}

	}//while
	
	return StrLength;
}
    84e4:	08 95       	ret

000084e6 <ForceEndStringFromFIFO>:
// ~~~~~~~~~~~
//    GSM_RxStr  <CR><LF>
uint8_t ForceEndStringFromFIFO(void){
	uint8_t StrLength;
	if(GSM_RxCharN > GSM_RXSTR_SIZE-1) GSM_RxCharN = GSM_RXSTR_SIZE-1;
    84e6:	80 91 60 0b 	lds	r24, 0x0B60
    84ea:	84 36       	cpi	r24, 0x64	; 100
    84ec:	18 f0       	brcs	.+6      	; 0x84f4 <ForceEndStringFromFIFO+0xe>
    84ee:	83 e6       	ldi	r24, 0x63	; 99
    84f0:	80 93 60 0b 	sts	0x0B60, r24
	StrLength = GSM_RxCharN;
    84f4:	80 91 60 0b 	lds	r24, 0x0B60
	GSM_RxStr[GSM_RxCharN]='\0';
    84f8:	e0 91 60 0b 	lds	r30, 0x0B60
    84fc:	f0 e0       	ldi	r31, 0x00	; 0
    84fe:	ef 51       	subi	r30, 0x1F	; 31
    8500:	f8 4f       	sbci	r31, 0xF8	; 248
    8502:	10 82       	st	Z, r1
	GSM_RxCharN = 0;
    8504:	10 92 60 0b 	sts	0x0B60, r1
	return StrLength;
}
    8508:	08 95       	ret

0000850a <GetDataFromFIFO>:

// ~~~~~~~~~~~
uint8_t GetDataFromFIFO(const uint8_t Amount){
    850a:	1f 93       	push	r17
    850c:	18 2f       	mov	r17, r24

	while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    850e:	90 91 3e 07 	lds	r25, 0x073E
    8512:	80 91 53 06 	lds	r24, 0x0653
    8516:	98 17       	cp	r25, r24
    8518:	81 f0       	breq	.+32     	; 0x853a <GetDataFromFIFO+0x30>
		GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);
    851a:	81 ee       	ldi	r24, 0xE1	; 225
    851c:	97 e0       	ldi	r25, 0x07	; 7
    851e:	60 e6       	ldi	r22, 0x60	; 96
    8520:	7b e0       	ldi	r23, 0x0B	; 11
    8522:	44 e6       	ldi	r20, 0x64	; 100
    8524:	0e 94 a6 41 	call	0x834c	; 0x834c <GetByteFromFIFO>
		if(GSM_RxCharN >= Amount){
    8528:	80 91 60 0b 	lds	r24, 0x0B60
    852c:	81 17       	cp	r24, r17
    852e:	78 f3       	brcs	.-34     	; 0x850e <GetDataFromFIFO+0x4>
			GSM_RxCharN = 0;
    8530:	10 92 60 0b 	sts	0x0B60, r1
			return Amount;
		}
	}//while
	return GSM_RxCharN;
}
    8534:	81 2f       	mov	r24, r17
    8536:	1f 91       	pop	r17
    8538:	08 95       	ret
		if(GSM_RxCharN >= Amount){
			GSM_RxCharN = 0;
			return Amount;
		}
	}//while
	return GSM_RxCharN;
    853a:	10 91 60 0b 	lds	r17, 0x0B60
}
    853e:	81 2f       	mov	r24, r17
    8540:	1f 91       	pop	r17
    8542:	08 95       	ret

00008544 <GSM_Init>:
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    8544:	8f ef       	ldi	r24, 0xFF	; 255
    8546:	80 93 3e 07 	sts	0x073E, r24
	GSM_RX_FIFO_End = 255;
    854a:	80 93 53 06 	sts	0x0653, r24
	GSM_RxCharN = 0;
    854e:	10 92 60 0b 	sts	0x0B60, r1
	GSM_RX_FIFOOverFlow = 0;
    8552:	10 92 13 09 	sts	0x0913, r1
	GSM_RX_FIFOMax = 0;
    8556:	10 92 19 09 	sts	0x0919, r1
		USART_GSM.BAUDCTRLB = 0x00 + USART_BSCALE0_bm;
		USART_GSM.CTRLA = USART_RXCINTLVL_HI_gc;
		USART_GSM.CTRLB = (1<<USART_RXEN_bp) | (1<<USART_TXEN_bp) | (0<<USART_CLK2X_bp) | (0 << USART_MPCM_bp) | (0 << USART_TXB8_bp);
		USART_GSM.CTRLC = USART_CMODE_ASYNCHRONOUS_gc | USART_PMODE_DISABLED_gc | (0<< USART_SBMODE_bp) | USART_CHSIZE_8BIT_gc;
	#else
		UCSR_GSM_A = ~(1<<U2X_GSM) &~(1<<MPCM_GSM);
    855a:	8c ef       	ldi	r24, 0xFC	; 252
    855c:	80 93 d0 00 	sts	0x00D0, r24
		UCSR_GSM_B =  (1<<RXCIE_GSM) | (0<<TXCIE_GSM) | (0<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    8560:	88 e9       	ldi	r24, 0x98	; 152
    8562:	80 93 d1 00 	sts	0x00D1, r24
		#if defined (__AVR_ATmega2561__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__)			
			UCSR_GSM_C = (0<<UMSEL_GSM_1) | (0<<UMSEL_GSM_0) | (0<<UPM_GSM_1) | (0<<UPM_GSM_0) | (0<<USBS_GSM) | (1<<UCSZ_GSM_1) | (1<<UCSZ_GSM_0) | (0<<UCPOL_GSM);
    8566:	86 e0       	ldi	r24, 0x06	; 6
    8568:	80 93 d2 00 	sts	0x00D2, r24
		#else
			UCSR_GSM_C = ((~(1<<UMSEL_GSM) &~(1<<UPM_GSM_1) &~(1<<UPM_GSM_0) &~(1<<USBS_GSM)) |(1<<UCSZ_GSM_1) |(1<<UCSZ_GSM_0)) &~(1<<UCPOL_GSM);
		#endif
		UBRR_GSM_H = 0x00;
    856c:	10 92 d5 00 	sts	0x00D5, r1
		UBRR_GSM_L = 0x67;	// 9600
    8570:	87 e6       	ldi	r24, 0x67	; 103
    8572:	80 93 d4 00 	sts	0x00D4, r24
#endif

//  gsm_sim900r.h   PWRCNTRL
#ifdef vmd2_3
	void GSM_PWRCNTRL_Config(void){
		cli();
    8576:	f8 94       	cli
		DDRL|=(1<<PL5);
    8578:	ea e0       	ldi	r30, 0x0A	; 10
    857a:	f1 e0       	ldi	r31, 0x01	; 1
    857c:	80 81       	ld	r24, Z
    857e:	80 62       	ori	r24, 0x20	; 32
    8580:	80 83       	st	Z, r24
		sei();
    8582:	78 94       	sei
		cli();
		PORTL|=(1<<PL5);
		sei();
	}
	void GSM_PWRCNTRL_ON(void){
		cli();
    8584:	f8 94       	cli
		PORTL &= ~(1<<PL5);
    8586:	eb e0       	ldi	r30, 0x0B	; 11
    8588:	f1 e0       	ldi	r31, 0x01	; 1
    858a:	80 81       	ld	r24, Z
    858c:	8f 7d       	andi	r24, 0xDF	; 223
    858e:	80 83       	st	Z, r24
		sei();
    8590:	78 94       	sei

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    8592:	80 91 d0 02 	lds	r24, 0x02D0
	VacantTimer16Sys += n;
    8596:	98 2f       	mov	r25, r24
    8598:	9f 5f       	subi	r25, 0xFF	; 255
	GSM_PWRCNTRL_ON();
	#ifdef GSM_HW_FLOW_CONTROL
		GSM_CTS_RTS_Config();
	#endif

	TD_GSM = Timer16SysAlloc(1);
    859a:	80 93 e9 04 	sts	0x04E9, r24
    859e:	29 2f       	mov	r18, r25
    85a0:	2f 5f       	subi	r18, 0xFF	; 255
	TD_TCP_Connect = Timer16SysAlloc(1);
    85a2:	90 93 ea 04 	sts	0x04EA, r25

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer32SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer32Sys;
    85a6:	90 91 d1 02 	lds	r25, 0x02D1
	VacantTimer32Sys += n;
    85aa:	89 2f       	mov	r24, r25
    85ac:	8f 5f       	subi	r24, 0xFF	; 255
	TD_GSM_Reset = Timer32SysAlloc(1);
    85ae:	90 93 eb 04 	sts	0x04EB, r25
// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
	VacantTimer16Sys += n;
    85b2:	92 2f       	mov	r25, r18
    85b4:	9f 5f       	subi	r25, 0xFF	; 255
	TD_5min_timer = Timer16SysAlloc(1);
    85b6:	20 93 ec 04 	sts	0x04EC, r18
// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer32SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer32Sys;
	VacantTimer32Sys += n;
    85ba:	8f 5f       	subi	r24, 0xFF	; 255
    85bc:	80 93 d1 02 	sts	0x02D1, r24
    85c0:	81 50       	subi	r24, 0x01	; 1
	TD_1hour_resetGPRS_timer = Timer32SysAlloc(1);
    85c2:	80 93 ed 04 	sts	0x04ED, r24
// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
	VacantTimer16Sys += n;
    85c6:	89 2f       	mov	r24, r25
    85c8:	8f 5f       	subi	r24, 0xFF	; 255
	TD_CheckModem = Timer16SysAlloc(1);
    85ca:	90 93 ee 04 	sts	0x04EE, r25
    85ce:	9e 5f       	subi	r25, 0xFE	; 254
	TD_CleanFIFO = Timer16SysAlloc(1);
    85d0:	80 93 ef 04 	sts	0x04EF, r24
    85d4:	8e 5f       	subi	r24, 0xFE	; 254
	TD_data_start_delay = Timer16SysAlloc(1);
    85d6:	90 93 f0 04 	sts	0x04F0, r25
    85da:	8f 5f       	subi	r24, 0xFF	; 255
    85dc:	80 93 d0 02 	sts	0x02D0, r24
    85e0:	81 50       	subi	r24, 0x01	; 1
	TD_timer_after_page_transfer = Timer16SysAlloc(1);
    85e2:	80 93 f1 04 	sts	0x04F1, r24

/*	for (uint8_t i=0; i<4; i++)
		GPRS_ServerAddr[i] = erb(GPRS_ServerAddr_EE+i);
*/
	GSM_Control = GSM_CNTL_AUTO;
    85e6:	10 92 d1 07 	sts	0x07D1, r1
	GSM_State = GSM_PowerOn;
    85ea:	10 92 f6 06 	sts	0x06F6, r1



}
    85ee:	08 95       	ret

000085f0 <GSM_RX>:
// ~~~~~~~~~
void
GSM_RX(void)
{
	char Char = UDR_GSM;
    85f0:	90 91 d6 00 	lds	r25, 0x00D6

	//---FIFO
	GSM_RX_FIFO_Begin++;
    85f4:	80 91 3e 07 	lds	r24, 0x073E
    85f8:	8f 5f       	subi	r24, 0xFF	; 255
    85fa:	80 93 3e 07 	sts	0x073E, r24
	if(GSM_RX_FIFO_Begin >= GSM_RX_FIFO_SIZE) GSM_RX_FIFO_Begin = 0;
    85fe:	80 91 3e 07 	lds	r24, 0x073E
    8602:	84 36       	cpi	r24, 0x64	; 100
    8604:	10 f0       	brcs	.+4      	; 0x860a <GSM_RX+0x1a>
    8606:	10 92 3e 07 	sts	0x073E, r1
	GSM_RX_FIFO[GSM_RX_FIFO_Begin] = Char;
    860a:	e0 91 3e 07 	lds	r30, 0x073E
    860e:	f0 e0       	ldi	r31, 0x00	; 0
    8610:	ef 51       	subi	r30, 0x1F	; 31
    8612:	fa 4f       	sbci	r31, 0xFA	; 250
    8614:	90 83       	st	Z, r25
	if(GSM_RX_FIFO_Begin == GSM_RX_FIFO_End){
    8616:	90 91 3e 07 	lds	r25, 0x073E
    861a:	80 91 53 06 	lds	r24, 0x0653
    861e:	98 13       	cpse	r25, r24
    8620:	08 95       	ret
		GSM_RX_FIFOOverFlow = 1;
    8622:	81 e0       	ldi	r24, 0x01	; 1
    8624:	80 93 13 09 	sts	0x0913, r24
		GSM_RX_FIFOMax = GSM_RX_FIFO_SIZE;
    8628:	84 e6       	ldi	r24, 0x64	; 100
    862a:	80 93 19 09 	sts	0x0919, r24
    862e:	08 95       	ret

00008630 <GSM_Wait_Char>:
		else return 1;
	}
	else return 0;
}
// ~~~~~~~~~
uint8_t GSM_Wait_Char(char Char, uint8_t RestoreCMD){
    8630:	0f 93       	push	r16
    8632:	1f 93       	push	r17
    8634:	08 2f       	mov	r16, r24
    8636:	16 2f       	mov	r17, r22
	if(Timer16Stopp(TD_GSM)){
    8638:	80 91 e9 04 	lds	r24, 0x04E9
    863c:	0e 94 96 25 	call	0x4b2c	; 0x4b2c <Timer16Stopp>
    8640:	88 23       	and	r24, r24
    8642:	39 f0       	breq	.+14     	; 0x8652 <GSM_Wait_Char+0x22>
		GSM_State = RestoreCMD;
    8644:	10 93 f6 06 	sts	0x06F6, r17
    8648:	90 e0       	ldi	r25, 0x00	; 0
	if(GetDataFromFIFO(1)){
		if(GSM_RxStr[0] == Char)	return 1;
		else return 0;
	}
	else return 0;
}
    864a:	89 2f       	mov	r24, r25
    864c:	1f 91       	pop	r17
    864e:	0f 91       	pop	r16
    8650:	08 95       	ret
	if(Timer16Stopp(TD_GSM)){
		GSM_State = RestoreCMD;
		return 0;
	}
	//   
	if(GetDataFromFIFO(1)){
    8652:	81 e0       	ldi	r24, 0x01	; 1
    8654:	0e 94 85 42 	call	0x850a	; 0x850a <GetDataFromFIFO>
    8658:	88 23       	and	r24, r24
    865a:	39 f0       	breq	.+14     	; 0x866a <GSM_Wait_Char+0x3a>
    865c:	90 e0       	ldi	r25, 0x00	; 0
    865e:	80 91 e1 07 	lds	r24, 0x07E1
    8662:	80 17       	cp	r24, r16
    8664:	91 f7       	brne	.-28     	; 0x864a <GSM_Wait_Char+0x1a>
    8666:	91 e0       	ldi	r25, 0x01	; 1
    8668:	f0 cf       	rjmp	.-32     	; 0x864a <GSM_Wait_Char+0x1a>
    866a:	90 e0       	ldi	r25, 0x00	; 0
		if(GSM_RxStr[0] == Char)	return 1;
		else return 0;
	}
	else return 0;
}
    866c:	89 2f       	mov	r24, r25
    866e:	1f 91       	pop	r17
    8670:	0f 91       	pop	r16
    8672:	08 95       	ret

00008674 <GSM_SendFirstChar>:
// ~~~~~~~~~
void GSM_SendFirstChar(void){

	UDR_GSM = GSM_TxStr[0];
    8674:	80 91 4a 0a 	lds	r24, 0x0A4A
    8678:	80 93 d6 00 	sts	0x00D6, r24
	#ifdef GSM_DEBUG
		GPRS_TerminalProcess(GSM_TxStr[0]);
	#endif

	GSM_TxCharN = 1;
    867c:	81 e0       	ldi	r24, 0x01	; 1
    867e:	80 93 69 0b 	sts	0x0B69, r24
	cli();
    8682:	f8 94       	cli
	GSM_Flag &=~(1<<flg_TxCStr);	
    8684:	80 91 d2 02 	lds	r24, 0x02D2
    8688:	8e 7f       	andi	r24, 0xFE	; 254
    868a:	80 93 d2 02 	sts	0x02D2, r24
	sei();
    868e:	78 94       	sei
	cli();
    8690:	f8 94       	cli
	#if defined (__AVR_ATxmega128A1__)
		USART_GSM.CTRLA = USART_RXCINTLVL_HI_gc | USART_DREINTLVL_HI_gc;
	#else
		UCSR_GSM_B =  (1<<RXCIE_GSM) | (0<<TXCIE_GSM) | (1<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    8692:	88 eb       	ldi	r24, 0xB8	; 184
    8694:	80 93 d1 00 	sts	0x00D1, r24
	#endif
	
	sei();	
    8698:	78 94       	sei
}
    869a:	08 95       	ret

0000869c <GSM_DRE>:
		StartTimer16(TD_GSM, Timeout);
	}
}
// ~~~~~~~~~
void GSM_DRE(void){
	if(GSM_TxCharN < GSMTxSz){
    869c:	90 91 69 0b 	lds	r25, 0x0B69
    86a0:	80 91 bb 07 	lds	r24, 0x07BB
    86a4:	98 17       	cp	r25, r24
    86a6:	20 f0       	brcs	.+8      	; 0x86b0 <GSM_DRE+0x14>
	}
	else{
		#if defined (__AVR_ATxmega128A1__)
			USART_GSM.CTRLA = USART_RXCINTLVL_HI_gc | USART_TXCINTLVL_HI_gc;
		#else
			UCSR_GSM_B =  (1<<RXCIE_GSM) | (1<<TXCIE_GSM) | (0<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    86a8:	88 ed       	ldi	r24, 0xD8	; 216
    86aa:	80 93 d1 00 	sts	0x00D1, r24
    86ae:	08 95       	ret
	}
}
// ~~~~~~~~~
void GSM_DRE(void){
	if(GSM_TxCharN < GSMTxSz){
		UDR_GSM = GSM_TxStr[GSM_TxCharN];
    86b0:	e0 91 69 0b 	lds	r30, 0x0B69
    86b4:	f0 e0       	ldi	r31, 0x00	; 0
    86b6:	e6 5b       	subi	r30, 0xB6	; 182
    86b8:	f5 4f       	sbci	r31, 0xF5	; 245
    86ba:	80 81       	ld	r24, Z
    86bc:	80 93 d6 00 	sts	0x00D6, r24
		#ifdef GSM_DEBUG
			GPRS_TerminalProcess(GSM_TxStr[GSM_TxCharN]);
		#endif
		GSM_TxCharN++;
    86c0:	80 91 69 0b 	lds	r24, 0x0B69
    86c4:	8f 5f       	subi	r24, 0xFF	; 255
    86c6:	80 93 69 0b 	sts	0x0B69, r24
    86ca:	08 95       	ret

000086cc <GSM_TX>:
}
// ~~~~~~~~~
void
GSM_TX(void)
{
	GSM_Flag |=(1<<flg_TxCStr);
    86cc:	80 91 d2 02 	lds	r24, 0x02D2
    86d0:	81 60       	ori	r24, 0x01	; 1
    86d2:	80 93 d2 02 	sts	0x02D2, r24
	if(dataSendFlg){
    86d6:	80 91 df 02 	lds	r24, 0x02DF
    86da:	88 23       	and	r24, r24
    86dc:	21 f0       	breq	.+8      	; 0x86e6 <GSM_TX+0x1a>
	dataSendFlg=0;
    86de:	10 92 df 02 	sts	0x02DF, r1
	GPRS_FlgSz_Out=0;
    86e2:	10 92 b1 07 	sts	0x07B1, r1
	}
	#if defined (__AVR_ATxmega128A1__)
		USART_GSM.CTRLA = USART_RXCINTLVL_HI_gc;
	#else
		UCSR_GSM_B =  (1<<RXCIE_GSM) | (0<<TXCIE_GSM) | (0<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    86e6:	88 e9       	ldi	r24, 0x98	; 152
    86e8:	80 93 d1 00 	sts	0x00D1, r24
	#endif
}
    86ec:	08 95       	ret

000086ee <GSM_Reset>:
GSM_Reset(void)
{
/*	IntOff();
	GSM_State = GSM_Restart;
	IntOn();*/
}
    86ee:	08 95       	ret

000086f0 <GSM_GotoNextVega>:

uint8_t GSM_GotoNextVega(void){
 return 0;
}
    86f0:	80 e0       	ldi	r24, 0x00	; 0
    86f2:	08 95       	ret

000086f4 <GSM_GetConfirmState>:
}
uint8_t ConfirmState = 0;
uint8_t RequestRepeatCounter = 0;
uint8_t TransmitterState = 0;
uint8_t GSM_GetConfirmState(){
	if(1 == ConfirmState){
    86f4:	80 91 e1 02 	lds	r24, 0x02E1
    86f8:	81 30       	cpi	r24, 0x01	; 1
    86fa:	11 f0       	breq	.+4      	; 0x8700 <GSM_GetConfirmState+0xc>
    86fc:	80 e0       	ldi	r24, 0x00	; 0
    86fe:	08 95       	ret
		ConfirmState = 0;
    8700:	10 92 e1 02 	sts	0x02E1, r1
    8704:	81 e0       	ldi	r24, 0x01	; 1
		return 1;
	}
	else return 0;
}
    8706:	08 95       	ret

00008708 <GPRS_ServerAddr_Save>:
// ~~~~~~~~~~~~~~~~~~~~~~~~
void
GPRS_ServerAddr_Save(void)
{

}
    8708:	08 95       	ret

0000870a <__vector_25>:
#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__)
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	#ifdef vmd2_3
		// ~~~~~~~~~~
		// USART0 - PORT0
		Modbus_ISR(0)
    870a:	1f 92       	push	r1
    870c:	0f 92       	push	r0
    870e:	0f b6       	in	r0, 0x3f	; 63
    8710:	0f 92       	push	r0
    8712:	0b b6       	in	r0, 0x3b	; 59
    8714:	0f 92       	push	r0
    8716:	11 24       	eor	r1, r1
    8718:	2f 93       	push	r18
    871a:	3f 93       	push	r19
    871c:	4f 93       	push	r20
    871e:	5f 93       	push	r21
    8720:	6f 93       	push	r22
    8722:	7f 93       	push	r23
    8724:	8f 93       	push	r24
    8726:	9f 93       	push	r25
    8728:	af 93       	push	r26
    872a:	bf 93       	push	r27
    872c:	ef 93       	push	r30
    872e:	ff 93       	push	r31
    8730:	86 ec       	ldi	r24, 0xC6	; 198
    8732:	90 e0       	ldi	r25, 0x00	; 0
    8734:	0e 94 70 33 	call	0x66e0	; 0x66e0 <Modbus_RX>
    8738:	ff 91       	pop	r31
    873a:	ef 91       	pop	r30
    873c:	bf 91       	pop	r27
    873e:	af 91       	pop	r26
    8740:	9f 91       	pop	r25
    8742:	8f 91       	pop	r24
    8744:	7f 91       	pop	r23
    8746:	6f 91       	pop	r22
    8748:	5f 91       	pop	r21
    874a:	4f 91       	pop	r20
    874c:	3f 91       	pop	r19
    874e:	2f 91       	pop	r18
    8750:	0f 90       	pop	r0
    8752:	0b be       	out	0x3b, r0	; 59
    8754:	0f 90       	pop	r0
    8756:	0f be       	out	0x3f, r0	; 63
    8758:	0f 90       	pop	r0
    875a:	1f 90       	pop	r1
    875c:	18 95       	reti

0000875e <__vector_27>:
    875e:	1f 92       	push	r1
    8760:	0f 92       	push	r0
    8762:	0f b6       	in	r0, 0x3f	; 63
    8764:	0f 92       	push	r0
    8766:	0b b6       	in	r0, 0x3b	; 59
    8768:	0f 92       	push	r0
    876a:	11 24       	eor	r1, r1
    876c:	2f 93       	push	r18
    876e:	3f 93       	push	r19
    8770:	4f 93       	push	r20
    8772:	5f 93       	push	r21
    8774:	6f 93       	push	r22
    8776:	7f 93       	push	r23
    8778:	8f 93       	push	r24
    877a:	9f 93       	push	r25
    877c:	af 93       	push	r26
    877e:	bf 93       	push	r27
    8780:	ef 93       	push	r30
    8782:	ff 93       	push	r31
    8784:	86 ec       	ldi	r24, 0xC6	; 198
    8786:	90 e0       	ldi	r25, 0x00	; 0
    8788:	0e 94 0f 3f 	call	0x7e1e	; 0x7e1e <Modbus_TX>
    878c:	ff 91       	pop	r31
    878e:	ef 91       	pop	r30
    8790:	bf 91       	pop	r27
    8792:	af 91       	pop	r26
    8794:	9f 91       	pop	r25
    8796:	8f 91       	pop	r24
    8798:	7f 91       	pop	r23
    879a:	6f 91       	pop	r22
    879c:	5f 91       	pop	r21
    879e:	4f 91       	pop	r20
    87a0:	3f 91       	pop	r19
    87a2:	2f 91       	pop	r18
    87a4:	0f 90       	pop	r0
    87a6:	0b be       	out	0x3b, r0	; 59
    87a8:	0f 90       	pop	r0
    87aa:	0f be       	out	0x3f, r0	; 63
    87ac:	0f 90       	pop	r0
    87ae:	1f 90       	pop	r1
    87b0:	18 95       	reti

000087b2 <__vector_26>:
    87b2:	1f 92       	push	r1
    87b4:	0f 92       	push	r0
    87b6:	0f b6       	in	r0, 0x3f	; 63
    87b8:	0f 92       	push	r0
    87ba:	0b b6       	in	r0, 0x3b	; 59
    87bc:	0f 92       	push	r0
    87be:	11 24       	eor	r1, r1
    87c0:	2f 93       	push	r18
    87c2:	3f 93       	push	r19
    87c4:	4f 93       	push	r20
    87c6:	5f 93       	push	r21
    87c8:	6f 93       	push	r22
    87ca:	7f 93       	push	r23
    87cc:	8f 93       	push	r24
    87ce:	9f 93       	push	r25
    87d0:	af 93       	push	r26
    87d2:	bf 93       	push	r27
    87d4:	ef 93       	push	r30
    87d6:	ff 93       	push	r31
    87d8:	86 ec       	ldi	r24, 0xC6	; 198
    87da:	90 e0       	ldi	r25, 0x00	; 0
    87dc:	0e 94 0f 3f 	call	0x7e1e	; 0x7e1e <Modbus_TX>
    87e0:	ff 91       	pop	r31
    87e2:	ef 91       	pop	r30
    87e4:	bf 91       	pop	r27
    87e6:	af 91       	pop	r26
    87e8:	9f 91       	pop	r25
    87ea:	8f 91       	pop	r24
    87ec:	7f 91       	pop	r23
    87ee:	6f 91       	pop	r22
    87f0:	5f 91       	pop	r21
    87f2:	4f 91       	pop	r20
    87f4:	3f 91       	pop	r19
    87f6:	2f 91       	pop	r18
    87f8:	0f 90       	pop	r0
    87fa:	0b be       	out	0x3b, r0	; 59
    87fc:	0f 90       	pop	r0
    87fe:	0f be       	out	0x3f, r0	; 63
    8800:	0f 90       	pop	r0
    8802:	1f 90       	pop	r1
    8804:	18 95       	reti

00008806 <__vector_36>:

		// ~~~~~~~~~~
		// USART1 - PORT1
		Modbus_ISR(1)
    8806:	1f 92       	push	r1
    8808:	0f 92       	push	r0
    880a:	0f b6       	in	r0, 0x3f	; 63
    880c:	0f 92       	push	r0
    880e:	0b b6       	in	r0, 0x3b	; 59
    8810:	0f 92       	push	r0
    8812:	11 24       	eor	r1, r1
    8814:	2f 93       	push	r18
    8816:	3f 93       	push	r19
    8818:	4f 93       	push	r20
    881a:	5f 93       	push	r21
    881c:	6f 93       	push	r22
    881e:	7f 93       	push	r23
    8820:	8f 93       	push	r24
    8822:	9f 93       	push	r25
    8824:	af 93       	push	r26
    8826:	bf 93       	push	r27
    8828:	ef 93       	push	r30
    882a:	ff 93       	push	r31
    882c:	8e ec       	ldi	r24, 0xCE	; 206
    882e:	90 e0       	ldi	r25, 0x00	; 0
    8830:	0e 94 70 33 	call	0x66e0	; 0x66e0 <Modbus_RX>
    8834:	ff 91       	pop	r31
    8836:	ef 91       	pop	r30
    8838:	bf 91       	pop	r27
    883a:	af 91       	pop	r26
    883c:	9f 91       	pop	r25
    883e:	8f 91       	pop	r24
    8840:	7f 91       	pop	r23
    8842:	6f 91       	pop	r22
    8844:	5f 91       	pop	r21
    8846:	4f 91       	pop	r20
    8848:	3f 91       	pop	r19
    884a:	2f 91       	pop	r18
    884c:	0f 90       	pop	r0
    884e:	0b be       	out	0x3b, r0	; 59
    8850:	0f 90       	pop	r0
    8852:	0f be       	out	0x3f, r0	; 63
    8854:	0f 90       	pop	r0
    8856:	1f 90       	pop	r1
    8858:	18 95       	reti

0000885a <__vector_38>:
    885a:	1f 92       	push	r1
    885c:	0f 92       	push	r0
    885e:	0f b6       	in	r0, 0x3f	; 63
    8860:	0f 92       	push	r0
    8862:	0b b6       	in	r0, 0x3b	; 59
    8864:	0f 92       	push	r0
    8866:	11 24       	eor	r1, r1
    8868:	2f 93       	push	r18
    886a:	3f 93       	push	r19
    886c:	4f 93       	push	r20
    886e:	5f 93       	push	r21
    8870:	6f 93       	push	r22
    8872:	7f 93       	push	r23
    8874:	8f 93       	push	r24
    8876:	9f 93       	push	r25
    8878:	af 93       	push	r26
    887a:	bf 93       	push	r27
    887c:	ef 93       	push	r30
    887e:	ff 93       	push	r31
    8880:	8e ec       	ldi	r24, 0xCE	; 206
    8882:	90 e0       	ldi	r25, 0x00	; 0
    8884:	0e 94 0f 3f 	call	0x7e1e	; 0x7e1e <Modbus_TX>
    8888:	ff 91       	pop	r31
    888a:	ef 91       	pop	r30
    888c:	bf 91       	pop	r27
    888e:	af 91       	pop	r26
    8890:	9f 91       	pop	r25
    8892:	8f 91       	pop	r24
    8894:	7f 91       	pop	r23
    8896:	6f 91       	pop	r22
    8898:	5f 91       	pop	r21
    889a:	4f 91       	pop	r20
    889c:	3f 91       	pop	r19
    889e:	2f 91       	pop	r18
    88a0:	0f 90       	pop	r0
    88a2:	0b be       	out	0x3b, r0	; 59
    88a4:	0f 90       	pop	r0
    88a6:	0f be       	out	0x3f, r0	; 63
    88a8:	0f 90       	pop	r0
    88aa:	1f 90       	pop	r1
    88ac:	18 95       	reti

000088ae <__vector_37>:
    88ae:	1f 92       	push	r1
    88b0:	0f 92       	push	r0
    88b2:	0f b6       	in	r0, 0x3f	; 63
    88b4:	0f 92       	push	r0
    88b6:	0b b6       	in	r0, 0x3b	; 59
    88b8:	0f 92       	push	r0
    88ba:	11 24       	eor	r1, r1
    88bc:	2f 93       	push	r18
    88be:	3f 93       	push	r19
    88c0:	4f 93       	push	r20
    88c2:	5f 93       	push	r21
    88c4:	6f 93       	push	r22
    88c6:	7f 93       	push	r23
    88c8:	8f 93       	push	r24
    88ca:	9f 93       	push	r25
    88cc:	af 93       	push	r26
    88ce:	bf 93       	push	r27
    88d0:	ef 93       	push	r30
    88d2:	ff 93       	push	r31
    88d4:	8e ec       	ldi	r24, 0xCE	; 206
    88d6:	90 e0       	ldi	r25, 0x00	; 0
    88d8:	0e 94 0f 3f 	call	0x7e1e	; 0x7e1e <Modbus_TX>
    88dc:	ff 91       	pop	r31
    88de:	ef 91       	pop	r30
    88e0:	bf 91       	pop	r27
    88e2:	af 91       	pop	r26
    88e4:	9f 91       	pop	r25
    88e6:	8f 91       	pop	r24
    88e8:	7f 91       	pop	r23
    88ea:	6f 91       	pop	r22
    88ec:	5f 91       	pop	r21
    88ee:	4f 91       	pop	r20
    88f0:	3f 91       	pop	r19
    88f2:	2f 91       	pop	r18
    88f4:	0f 90       	pop	r0
    88f6:	0b be       	out	0x3b, r0	; 59
    88f8:	0f 90       	pop	r0
    88fa:	0f be       	out	0x3f, r0	; 63
    88fc:	0f 90       	pop	r0
    88fe:	1f 90       	pop	r1
    8900:	18 95       	reti

00008902 <__vector_52>:

		// USART2 - PORT2 (only GSM)
		#ifdef GSM
			#ifndef SIM300DZ
				ISR(USART2_UDRE_vect) {GSM_DRE();}
    8902:	1f 92       	push	r1
    8904:	0f 92       	push	r0
    8906:	0f b6       	in	r0, 0x3f	; 63
    8908:	0f 92       	push	r0
    890a:	0b b6       	in	r0, 0x3b	; 59
    890c:	0f 92       	push	r0
    890e:	11 24       	eor	r1, r1
    8910:	2f 93       	push	r18
    8912:	3f 93       	push	r19
    8914:	4f 93       	push	r20
    8916:	5f 93       	push	r21
    8918:	6f 93       	push	r22
    891a:	7f 93       	push	r23
    891c:	8f 93       	push	r24
    891e:	9f 93       	push	r25
    8920:	af 93       	push	r26
    8922:	bf 93       	push	r27
    8924:	ef 93       	push	r30
    8926:	ff 93       	push	r31
    8928:	0e 94 4e 43 	call	0x869c	; 0x869c <GSM_DRE>
    892c:	ff 91       	pop	r31
    892e:	ef 91       	pop	r30
    8930:	bf 91       	pop	r27
    8932:	af 91       	pop	r26
    8934:	9f 91       	pop	r25
    8936:	8f 91       	pop	r24
    8938:	7f 91       	pop	r23
    893a:	6f 91       	pop	r22
    893c:	5f 91       	pop	r21
    893e:	4f 91       	pop	r20
    8940:	3f 91       	pop	r19
    8942:	2f 91       	pop	r18
    8944:	0f 90       	pop	r0
    8946:	0b be       	out	0x3b, r0	; 59
    8948:	0f 90       	pop	r0
    894a:	0f be       	out	0x3f, r0	; 63
    894c:	0f 90       	pop	r0
    894e:	1f 90       	pop	r1
    8950:	18 95       	reti

00008952 <__vector_53>:
			#endif
			ISR(USART2_TX_vect) {GSM_TX();}
    8952:	1f 92       	push	r1
    8954:	0f 92       	push	r0
    8956:	0f b6       	in	r0, 0x3f	; 63
    8958:	0f 92       	push	r0
    895a:	0b b6       	in	r0, 0x3b	; 59
    895c:	0f 92       	push	r0
    895e:	11 24       	eor	r1, r1
    8960:	2f 93       	push	r18
    8962:	3f 93       	push	r19
    8964:	4f 93       	push	r20
    8966:	5f 93       	push	r21
    8968:	6f 93       	push	r22
    896a:	7f 93       	push	r23
    896c:	8f 93       	push	r24
    896e:	9f 93       	push	r25
    8970:	af 93       	push	r26
    8972:	bf 93       	push	r27
    8974:	ef 93       	push	r30
    8976:	ff 93       	push	r31
    8978:	0e 94 66 43 	call	0x86cc	; 0x86cc <GSM_TX>
    897c:	ff 91       	pop	r31
    897e:	ef 91       	pop	r30
    8980:	bf 91       	pop	r27
    8982:	af 91       	pop	r26
    8984:	9f 91       	pop	r25
    8986:	8f 91       	pop	r24
    8988:	7f 91       	pop	r23
    898a:	6f 91       	pop	r22
    898c:	5f 91       	pop	r21
    898e:	4f 91       	pop	r20
    8990:	3f 91       	pop	r19
    8992:	2f 91       	pop	r18
    8994:	0f 90       	pop	r0
    8996:	0b be       	out	0x3b, r0	; 59
    8998:	0f 90       	pop	r0
    899a:	0f be       	out	0x3f, r0	; 63
    899c:	0f 90       	pop	r0
    899e:	1f 90       	pop	r1
    89a0:	18 95       	reti

000089a2 <__vector_51>:
			ISR(USART2_RX_vect) {GSM_RX();}
    89a2:	1f 92       	push	r1
    89a4:	0f 92       	push	r0
    89a6:	0f b6       	in	r0, 0x3f	; 63
    89a8:	0f 92       	push	r0
    89aa:	0b b6       	in	r0, 0x3b	; 59
    89ac:	0f 92       	push	r0
    89ae:	11 24       	eor	r1, r1
    89b0:	2f 93       	push	r18
    89b2:	3f 93       	push	r19
    89b4:	4f 93       	push	r20
    89b6:	5f 93       	push	r21
    89b8:	6f 93       	push	r22
    89ba:	7f 93       	push	r23
    89bc:	8f 93       	push	r24
    89be:	9f 93       	push	r25
    89c0:	af 93       	push	r26
    89c2:	bf 93       	push	r27
    89c4:	ef 93       	push	r30
    89c6:	ff 93       	push	r31
    89c8:	0e 94 f8 42 	call	0x85f0	; 0x85f0 <GSM_RX>
    89cc:	ff 91       	pop	r31
    89ce:	ef 91       	pop	r30
    89d0:	bf 91       	pop	r27
    89d2:	af 91       	pop	r26
    89d4:	9f 91       	pop	r25
    89d6:	8f 91       	pop	r24
    89d8:	7f 91       	pop	r23
    89da:	6f 91       	pop	r22
    89dc:	5f 91       	pop	r21
    89de:	4f 91       	pop	r20
    89e0:	3f 91       	pop	r19
    89e2:	2f 91       	pop	r18
    89e4:	0f 90       	pop	r0
    89e6:	0b be       	out	0x3b, r0	; 59
    89e8:	0f 90       	pop	r0
    89ea:	0f be       	out	0x3f, r0	; 63
    89ec:	0f 90       	pop	r0
    89ee:	1f 90       	pop	r1
    89f0:	18 95       	reti

000089f2 <KeypadInit>:
		for (uint8_t str=0; str<sizeof(KeyStr); str++) {
			uint8_t KS = prb(KeyStr+str);
			DDR_Key &=~KS;
			PortKey |=KS;
		}*/
		DDR_KeyROW1 |= KeyROW1;
    89f2:	81 9a       	sbi	0x10, 1	; 16
		DDR_KeyROW2 |= KeyROW2;
    89f4:	80 9a       	sbi	0x10, 0	; 16
		PortKeyROW1 |= KeyROW1;
    89f6:	89 9a       	sbi	0x11, 1	; 17
		PortKeyROW2 |= KeyROW2;
    89f8:	88 9a       	sbi	0x11, 0	; 17
		
		DDR_KeySTR1 &= ~KeySTR1;
    89fa:	85 98       	cbi	0x10, 5	; 16
		DDR_KeySTR2 &= ~KeySTR2;
    89fc:	84 98       	cbi	0x10, 4	; 16
		DDR_KeySTR3 &= ~KeySTR3;
    89fe:	82 98       	cbi	0x10, 2	; 16
		PortKeySTR1 |= KeySTR1;
    8a00:	8d 9a       	sbi	0x11, 5	; 17
		PortKeySTR2 |= KeySTR2;
    8a02:	8c 9a       	sbi	0x11, 4	; 17
		PortKeySTR3 |= KeySTR3;
    8a04:	8a 9a       	sbi	0x11, 2	; 17
}

uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    8a06:	80 91 cf 02 	lds	r24, 0x02CF
	VacantTimer8Sys += n;
    8a0a:	8f 5f       	subi	r24, 0xFF	; 255
    8a0c:	80 93 cf 02 	sts	0x02CF, r24
    8a10:	81 50       	subi	r24, 0x01	; 1
		PORTJ.DIRCLR = (1<<7);
		for (uint8_t str=1; str<sizeof(KeyStr); str++)
			PORTK.DIRCLR = prb(KeyStr+str);
		PORTJ.PIN7CTRL = PORTK.PIN0CTRL = PORTK.PIN1CTRL = PORTK.PIN2CTRL = PORTK.PIN3CTRL = PORT_OPC_PULLUP_gc;
	#endif
	TD_Keypad = Timer8SysAlloc(1);
    8a12:	80 93 f3 04 	sts	0x04F3, r24
}
    8a16:	08 95       	ret

00008a18 <KeypadIn>:
	return KeyPressedNonFilter = Key;
}
// ~~~~~~~~~~~
uint8_t
KeypadIn(void)
{
    8a18:	0f 93       	push	r16
    8a1a:	1f 93       	push	r17
			}
		}
		RowOff(KR);
	}*/

	cli(); PortKeyROW1 &= ~KeyROW1; sei();
    8a1c:	f8 94       	cli
    8a1e:	89 98       	cbi	0x11, 1	; 17
    8a20:	78 94       	sei
    8a22:	85 e3       	ldi	r24, 0x35	; 53
    8a24:	8a 95       	dec	r24
    8a26:	f1 f7       	brne	.-4      	; 0x8a24 <KeypadIn+0xc>
	_delay_us(10);		// By trial
	if(!(PIN_KeySTR1 & (KeySTR1))){ Key=2; PresKeysQuant++;} 
    8a28:	7d 99       	sbic	0x0f, 5	; 15
    8a2a:	38 c0       	rjmp	.+112    	; 0x8a9c <KeypadIn+0x84>
    8a2c:	91 e0       	ldi	r25, 0x01	; 1
    8a2e:	02 e0       	ldi	r16, 0x02	; 2
	if(!(PIN_KeySTR2 & (KeySTR2))){ Key=6; PresKeysQuant++;} 
    8a30:	7c 99       	sbic	0x0f, 4	; 15
    8a32:	02 c0       	rjmp	.+4      	; 0x8a38 <KeypadIn+0x20>
    8a34:	9f 5f       	subi	r25, 0xFF	; 255
    8a36:	06 e0       	ldi	r16, 0x06	; 6
	if(!(PIN_KeySTR3 & (KeySTR3))){ Key=4; PresKeysQuant++;} 
    8a38:	7a 99       	sbic	0x0f, 2	; 15
    8a3a:	02 c0       	rjmp	.+4      	; 0x8a40 <KeypadIn+0x28>
    8a3c:	9f 5f       	subi	r25, 0xFF	; 255
    8a3e:	04 e0       	ldi	r16, 0x04	; 4
	cli(); PortKeyROW1 |= KeyROW1; sei();	
    8a40:	f8 94       	cli
    8a42:	89 9a       	sbi	0x11, 1	; 17
    8a44:	78 94       	sei

	cli(); PortKeyROW2 &= ~KeyROW2; sei();
    8a46:	f8 94       	cli
    8a48:	88 98       	cbi	0x11, 0	; 17
    8a4a:	78 94       	sei
    8a4c:	85 e3       	ldi	r24, 0x35	; 53
    8a4e:	8a 95       	dec	r24
    8a50:	f1 f7       	brne	.-4      	; 0x8a4e <KeypadIn+0x36>
	_delay_us(10);		// By trial
	if(!(PIN_KeySTR1 & (KeySTR1))){ Key=1; PresKeysQuant++;}
    8a52:	7d 99       	sbic	0x0f, 5	; 15
    8a54:	02 c0       	rjmp	.+4      	; 0x8a5a <KeypadIn+0x42>
    8a56:	9f 5f       	subi	r25, 0xFF	; 255
    8a58:	01 e0       	ldi	r16, 0x01	; 1
	if(!(PIN_KeySTR2 & (KeySTR2))){ Key=5; PresKeysQuant++;}
    8a5a:	7c 99       	sbic	0x0f, 4	; 15
    8a5c:	02 c0       	rjmp	.+4      	; 0x8a62 <KeypadIn+0x4a>
    8a5e:	9f 5f       	subi	r25, 0xFF	; 255
    8a60:	05 e0       	ldi	r16, 0x05	; 5
	if(!(PIN_KeySTR3 & (KeySTR3))){ Key=3; PresKeysQuant++;}
    8a62:	7a 99       	sbic	0x0f, 2	; 15
    8a64:	02 c0       	rjmp	.+4      	; 0x8a6a <KeypadIn+0x52>
    8a66:	9f 5f       	subi	r25, 0xFF	; 255
    8a68:	03 e0       	ldi	r16, 0x03	; 3
	cli(); PortKeyROW2 |= KeyROW2; sei();
    8a6a:	f8 94       	cli
    8a6c:	88 9a       	sbi	0x11, 0	; 17
    8a6e:	78 94       	sei
	if(PresKeysQuant!=1) Key = 0;
    8a70:	91 30       	cpi	r25, 0x01	; 1
    8a72:	09 f4       	brne	.+2      	; 0x8a76 <KeypadIn+0x5e>
    8a74:	4a c0       	rjmp	.+148    	; 0x8b0a <KeypadIn+0xf2>

	return KeyPressedNonFilter = Key;
    8a76:	10 92 11 09 	sts	0x0911, r1
    8a7a:	00 e0       	ldi	r16, 0x00	; 0
{
	static uint8_t PrevKey;
	uint8_t KeyResult = 0;
	uint8_t Key = KeypadScan();	//   
	if(Key) KeyPressedCounter++;
	if(Key != PrevKey){			//     -   
    8a7c:	80 91 e5 02 	lds	r24, 0x02E5
    8a80:	80 17       	cp	r24, r16
    8a82:	11 f0       	breq	.+4      	; 0x8a88 <KeypadIn+0x70>
		PrevKey = 0;
    8a84:	10 92 e5 02 	sts	0x02E5, r1
	}
	
	if (Timer8Stopp(TD_Keypad)) {
    8a88:	10 91 f3 04 	lds	r17, 0x04F3
    8a8c:	81 2f       	mov	r24, r17
    8a8e:	0e 94 73 25 	call	0x4ae6	; 0x4ae6 <Timer8Stopp>
    8a92:	88 23       	and	r24, r24
    8a94:	31 f4       	brne	.+12     	; 0x8aa2 <KeypadIn+0x8a>
					for(I=0;I<=(KeyQuantity/8);I++) *((uint8_t*)RKEY+I) = 0;
				}
		#endif
	}
	return KeyResult;
}
    8a96:	1f 91       	pop	r17
    8a98:	0f 91       	pop	r16
    8a9a:	08 95       	ret
		RowOff(KR);
	}*/

	cli(); PortKeyROW1 &= ~KeyROW1; sei();
	_delay_us(10);		// By trial
	if(!(PIN_KeySTR1 & (KeySTR1))){ Key=2; PresKeysQuant++;} 
    8a9c:	90 e0       	ldi	r25, 0x00	; 0
    8a9e:	00 e0       	ldi	r16, 0x00	; 0
    8aa0:	c7 cf       	rjmp	.-114    	; 0x8a30 <KeypadIn+0x18>
	if(Key != PrevKey){			//     -   
		PrevKey = 0;
	}
	
	if (Timer8Stopp(TD_Keypad)) {
		StartTimer8(TD_Keypad, 6);	// By trial keystroke time == 70-180 ms
    8aa2:	81 2f       	mov	r24, r17
    8aa4:	66 e0       	ldi	r22, 0x06	; 6
    8aa6:	0e 94 1f 24 	call	0x483e	; 0x483e <StartTimer8>
		if (Key != PrevKey) {
    8aaa:	80 91 e5 02 	lds	r24, 0x02E5
    8aae:	80 17       	cp	r24, r16
    8ab0:	09 f4       	brne	.+2      	; 0x8ab4 <KeypadIn+0x9c>
    8ab2:	44 c0       	rjmp	.+136    	; 0x8b3c <KeypadIn+0x124>
				PrevKey = Key;
    8ab4:	00 93 e5 02 	sts	0x02E5, r16
				Key = 0;
				KeyStroke = 0;
    8ab8:	10 92 f2 04 	sts	0x04F2, r1

		#ifdef RKEY
			#ifdef QslRD
				if(!*(uint8_t*)RNUM)
			#endif
				if (KeyResult==0) {
    8abc:	40 e0       	ldi	r20, 0x00	; 0
    8abe:	50 e0       	ldi	r21, 0x00	; 0
					uint8_t I = 0;
					while (1<<(I++ & 0b00000111) != *((uint8_t*)RKEY+(I>>3)) && I<=KeyQuantity);
    8ac0:	a1 e0       	ldi	r26, 0x01	; 1
    8ac2:	b0 e0       	ldi	r27, 0x00	; 0

		#ifdef RKEY
			#ifdef QslRD
				if(!*(uint8_t*)RNUM)
			#endif
				if (KeyResult==0) {
    8ac4:	e4 2f       	mov	r30, r20
    8ac6:	64 2f       	mov	r22, r20
    8ac8:	6f 5f       	subi	r22, 0xFF	; 255
					uint8_t I = 0;
					while (1<<(I++ & 0b00000111) != *((uint8_t*)RKEY+(I>>3)) && I<=KeyQuantity);
    8aca:	9a 01       	movw	r18, r20
    8acc:	27 70       	andi	r18, 0x07	; 7
    8ace:	30 70       	andi	r19, 0x00	; 0
    8ad0:	cd 01       	movw	r24, r26
    8ad2:	02 c0       	rjmp	.+4      	; 0x8ad8 <KeypadIn+0xc0>
    8ad4:	88 0f       	add	r24, r24
    8ad6:	99 1f       	adc	r25, r25
    8ad8:	2a 95       	dec	r18
    8ada:	e2 f7       	brpl	.-8      	; 0x8ad4 <KeypadIn+0xbc>
    8adc:	9c 01       	movw	r18, r24
    8ade:	e6 95       	lsr	r30
    8ae0:	e6 95       	lsr	r30
    8ae2:	e6 95       	lsr	r30
    8ae4:	f0 e0       	ldi	r31, 0x00	; 0
    8ae6:	e1 54       	subi	r30, 0x41	; 65
    8ae8:	f8 4f       	sbci	r31, 0xF8	; 248
    8aea:	80 81       	ld	r24, Z
    8aec:	90 e0       	ldi	r25, 0x00	; 0
    8aee:	28 17       	cp	r18, r24
    8af0:	39 07       	cpc	r19, r25
    8af2:	b1 f1       	breq	.+108    	; 0x8b60 <KeypadIn+0x148>
    8af4:	4f 5f       	subi	r20, 0xFF	; 255
    8af6:	5f 4f       	sbci	r21, 0xFF	; 255
    8af8:	47 30       	cpi	r20, 0x07	; 7
    8afa:	51 05       	cpc	r21, r1
    8afc:	19 f7       	brne	.-58     	; 0x8ac4 <KeypadIn+0xac>
					if (I<=KeyQuantity)
    8afe:	80 e0       	ldi	r24, 0x00	; 0
						KeyResult = I;
					for(I=0;I<=(KeyQuantity/8);I++) *((uint8_t*)RKEY+I) = 0;
    8b00:	10 92 bf 07 	sts	0x07BF, r1
				}
		#endif
	}
	return KeyResult;
}
    8b04:	1f 91       	pop	r17
    8b06:	0f 91       	pop	r16
    8b08:	08 95       	ret
	if(!(PIN_KeySTR2 & (KeySTR2))){ Key=5; PresKeysQuant++;}
	if(!(PIN_KeySTR3 & (KeySTR3))){ Key=3; PresKeysQuant++;}
	cli(); PortKeyROW2 |= KeyROW2; sei();
	if(PresKeysQuant!=1) Key = 0;

	return KeyPressedNonFilter = Key;
    8b0a:	00 93 11 09 	sts	0x0911, r16
KeypadIn(void)
{
	static uint8_t PrevKey;
	uint8_t KeyResult = 0;
	uint8_t Key = KeypadScan();	//   
	if(Key) KeyPressedCounter++;
    8b0e:	00 23       	and	r16, r16
    8b10:	09 f4       	brne	.+2      	; 0x8b14 <KeypadIn+0xfc>
    8b12:	b4 cf       	rjmp	.-152    	; 0x8a7c <KeypadIn+0x64>
    8b14:	80 91 3a 07 	lds	r24, 0x073A
    8b18:	90 91 3b 07 	lds	r25, 0x073B
    8b1c:	a0 91 3c 07 	lds	r26, 0x073C
    8b20:	b0 91 3d 07 	lds	r27, 0x073D
    8b24:	01 96       	adiw	r24, 0x01	; 1
    8b26:	a1 1d       	adc	r26, r1
    8b28:	b1 1d       	adc	r27, r1
    8b2a:	80 93 3a 07 	sts	0x073A, r24
    8b2e:	90 93 3b 07 	sts	0x073B, r25
    8b32:	a0 93 3c 07 	sts	0x073C, r26
    8b36:	b0 93 3d 07 	sts	0x073D, r27
    8b3a:	a0 cf       	rjmp	.-192    	; 0x8a7c <KeypadIn+0x64>
				PrevKey = Key;
				Key = 0;
				KeyStroke = 0;
		}
		else{
			KeyPressed = KeyResult = Key;
    8b3c:	00 93 b0 07 	sts	0x07B0, r16
			if(KeyStroke<0xFF && ++KeyStroke>1 && KeyStroke<=0xF) KeyResult = 0;
    8b40:	90 91 f2 04 	lds	r25, 0x04F2
    8b44:	9f 3f       	cpi	r25, 0xFF	; 255
    8b46:	41 f0       	breq	.+16     	; 0x8b58 <KeypadIn+0x140>
    8b48:	9f 5f       	subi	r25, 0xFF	; 255
    8b4a:	90 93 f2 04 	sts	0x04F2, r25
    8b4e:	92 30       	cpi	r25, 0x02	; 2
    8b50:	18 f0       	brcs	.+6      	; 0x8b58 <KeypadIn+0x140>
    8b52:	90 31       	cpi	r25, 0x10	; 16
    8b54:	08 f4       	brcc	.+2      	; 0x8b58 <KeypadIn+0x140>
    8b56:	b2 cf       	rjmp	.-156    	; 0x8abc <KeypadIn+0xa4>

		#ifdef RKEY
			#ifdef QslRD
				if(!*(uint8_t*)RNUM)
			#endif
				if (KeyResult==0) {
    8b58:	88 23       	and	r24, r24
    8b5a:	09 f0       	breq	.+2      	; 0x8b5e <KeypadIn+0x146>
    8b5c:	9c cf       	rjmp	.-200    	; 0x8a96 <KeypadIn+0x7e>
    8b5e:	ae cf       	rjmp	.-164    	; 0x8abc <KeypadIn+0xa4>
					uint8_t I = 0;
					while (1<<(I++ & 0b00000111) != *((uint8_t*)RKEY+(I>>3)) && I<=KeyQuantity);
					if (I<=KeyQuantity)
    8b60:	67 30       	cpi	r22, 0x07	; 7
    8b62:	68 f6       	brcc	.-102    	; 0x8afe <KeypadIn+0xe6>
    8b64:	86 2f       	mov	r24, r22
    8b66:	cc cf       	rjmp	.-104    	; 0x8b00 <KeypadIn+0xe8>

00008b68 <InitBufStr>:
static uint8_t Minus;
// ~~~~~~~~~~~
char BufStr[LCDXSz+1];
uint8_t CurrFieldSize;

void InitBufStr(OutField *Field){
    8b68:	e3 ec       	ldi	r30, 0xC3	; 195
    8b6a:	f5 e0       	ldi	r31, 0x05	; 5
	for(uint8_t i =0; i<LCDXSz; i++) BufStr[i]=' ';
    8b6c:	80 e2       	ldi	r24, 0x20	; 32
    8b6e:	81 93       	st	Z+, r24
    8b70:	95 e0       	ldi	r25, 0x05	; 5
    8b72:	e7 3d       	cpi	r30, 0xD7	; 215
    8b74:	f9 07       	cpc	r31, r25
    8b76:	d9 f7       	brne	.-10     	; 0x8b6e <InitBufStr+0x6>
	BufStr[LCDXSz] ='\0';
    8b78:	10 82       	st	Z, r1
	CurrFieldSize = 0;
    8b7a:	10 92 c0 07 	sts	0x07C0, r1
	MultiSymbol = 0;
    8b7e:	10 92 f4 04 	sts	0x04F4, r1
}
    8b82:	08 95       	ret

00008b84 <EventFunc>:

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    8b84:	fc 01       	movw	r30, r24
    8b86:	85 91       	lpm	r24, Z+
    8b88:	94 91       	lpm	r25, Z+
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
EventFunc(const MenuEvent *Event)
{
	MenuEvent Func = prp(Event);
	if (Func)
    8b8a:	00 97       	sbiw	r24, 0x00	; 0
    8b8c:	11 f0       	breq	.+4      	; 0x8b92 <EventFunc+0xe>
		Func();
    8b8e:	fc 01       	movw	r30, r24
    8b90:	19 95       	eicall
    8b92:	08 95       	ret

00008b94 <KeyFunc>:
    8b94:	fc 01       	movw	r30, r24
    8b96:	85 91       	lpm	r24, Z+
    8b98:	94 91       	lpm	r25, Z+
// ~~~~~~~~~~~~~~~~~~~~~~~~
static uint8_t
KeyFunc(const MenuKey *Key)
{
	MenuKey Func=prp(Key);
	return Func && Func()==CustomKey;
    8b9a:	00 97       	sbiw	r24, 0x00	; 0
    8b9c:	51 f0       	breq	.+20     	; 0x8bb2 <KeyFunc+0x1e>
    8b9e:	fc 01       	movw	r30, r24
    8ba0:	19 95       	eicall
    8ba2:	90 e0       	ldi	r25, 0x00	; 0
    8ba4:	81 30       	cpi	r24, 0x01	; 1
    8ba6:	09 f0       	breq	.+2      	; 0x8baa <KeyFunc+0x16>
    8ba8:	91 e0       	ldi	r25, 0x01	; 1
    8baa:	81 e0       	ldi	r24, 0x01	; 1
    8bac:	98 27       	eor	r25, r24
}
    8bae:	89 2f       	mov	r24, r25
    8bb0:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~~~
static uint8_t
KeyFunc(const MenuKey *Key)
{
	MenuKey Func=prp(Key);
	return Func && Func()==CustomKey;
    8bb2:	90 e0       	ldi	r25, 0x00	; 0
}
    8bb4:	89 2f       	mov	r24, r25
    8bb6:	08 95       	ret

00008bb8 <GotoMenu>:

// ~~~~~~~~~~~~~~~~~~~~~
void
GotoMenu(MenuPage *Menu)
{
    8bb8:	cf 93       	push	r28
    8bba:	df 93       	push	r29
    8bbc:	ec 01       	movw	r28, r24
	EventFunc(&CurrPage->Exit);
    8bbe:	80 91 d4 02 	lds	r24, 0x02D4
    8bc2:	90 91 d5 02 	lds	r25, 0x02D5
    8bc6:	0a 96       	adiw	r24, 0x0a	; 10
    8bc8:	0e 94 c2 45 	call	0x8b84	; 0x8b84 <EventFunc>
    8bcc:	fe 01       	movw	r30, r28
    8bce:	34 96       	adiw	r30, 0x04	; 4
    8bd0:	85 91       	lpm	r24, Z+
    8bd2:	94 91       	lpm	r25, Z+
	if(prp(&Menu->OutPage))
    8bd4:	89 2b       	or	r24, r25
    8bd6:	c9 f0       	breq	.+50     	; 0x8c0a <GotoMenu+0x52>
		MenuDepth=0;
    8bd8:	10 92 ba 07 	sts	0x07BA, r1
	else {
		MenuStack[MenuDepth].Page = CurrPage;
		MenuStack[MenuDepth].Line = CurrLine;
		MenuStack[MenuDepth++].LCD = CurrLCD;
	}
	CurrPage = Menu;
    8bdc:	d0 93 d5 02 	sts	0x02D5, r29
    8be0:	c0 93 d4 02 	sts	0x02D4, r28

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    8be4:	23 96       	adiw	r28, 0x03	; 3
    8be6:	fe 01       	movw	r30, r28
    8be8:	84 91       	lpm	r24, Z+
	CurrLine = CurrLCD = GetFix();
    8bea:	80 93 e8 08 	sts	0x08E8, r24
    8bee:	80 93 ca 07 	sts	0x07CA, r24
	CurrField = CurrPos = NullPos;
    8bf2:	8f ef       	ldi	r24, 0xFF	; 255
    8bf4:	80 93 d7 02 	sts	0x02D7, r24
    8bf8:	80 93 d6 02 	sts	0x02D6, r24
	EventFunc(&CurrPage->Load);
    8bfc:	ce 01       	movw	r24, r28
    8bfe:	03 96       	adiw	r24, 0x03	; 3
    8c00:	0e 94 c2 45 	call	0x8b84	; 0x8b84 <EventFunc>
}
    8c04:	df 91       	pop	r29
    8c06:	cf 91       	pop	r28
    8c08:	08 95       	ret
{
	EventFunc(&CurrPage->Exit);
	if(prp(&Menu->OutPage))
		MenuDepth=0;
	else {
		MenuStack[MenuDepth].Page = CurrPage;
    8c0a:	20 91 ba 07 	lds	r18, 0x07BA
    8c0e:	e2 2f       	mov	r30, r18
    8c10:	f0 e0       	ldi	r31, 0x00	; 0
    8c12:	ee 0f       	add	r30, r30
    8c14:	ff 1f       	adc	r31, r31
    8c16:	ee 0f       	add	r30, r30
    8c18:	ff 1f       	adc	r31, r31
    8c1a:	df 01       	movw	r26, r30
    8c1c:	a7 51       	subi	r26, 0x17	; 23
    8c1e:	b7 4f       	sbci	r27, 0xF7	; 247
    8c20:	80 91 d4 02 	lds	r24, 0x02D4
    8c24:	90 91 d5 02 	lds	r25, 0x02D5
    8c28:	11 96       	adiw	r26, 0x01	; 1
    8c2a:	9c 93       	st	X, r25
    8c2c:	8e 93       	st	-X, r24
		MenuStack[MenuDepth].Line = CurrLine;
    8c2e:	80 91 ca 07 	lds	r24, 0x07CA
    8c32:	13 96       	adiw	r26, 0x03	; 3
    8c34:	8c 93       	st	X, r24
		MenuStack[MenuDepth++].LCD = CurrLCD;
    8c36:	e5 51       	subi	r30, 0x15	; 21
    8c38:	f7 4f       	sbci	r31, 0xF7	; 247
    8c3a:	80 91 e8 08 	lds	r24, 0x08E8
    8c3e:	80 83       	st	Z, r24
    8c40:	2f 5f       	subi	r18, 0xFF	; 255
    8c42:	20 93 ba 07 	sts	0x07BA, r18
    8c46:	ca cf       	rjmp	.-108    	; 0x8bdc <GotoMenu+0x24>

00008c48 <HideMsg>:

// ~~~~~~~~~~
uint8_t
HideMsg(void)
{
	if (CurrMsg) {
    8c48:	80 91 f5 04 	lds	r24, 0x04F5
    8c4c:	90 91 f6 04 	lds	r25, 0x04F6
    8c50:	00 97       	sbiw	r24, 0x00	; 0
    8c52:	51 f0       	breq	.+20     	; 0x8c68 <HideMsg+0x20>
		EventFunc(&CurrMsg->Exit);
    8c54:	80 5a       	subi	r24, 0xA0	; 160
    8c56:	9f 4f       	sbci	r25, 0xFF	; 255
    8c58:	0e 94 c2 45 	call	0x8b84	; 0x8b84 <EventFunc>
		CurrMsg = NULL;
    8c5c:	10 92 f6 04 	sts	0x04F6, r1
    8c60:	10 92 f5 04 	sts	0x04F5, r1
    8c64:	81 e0       	ldi	r24, 0x01	; 1
		return 1;
	}
	else
		return 0;
}
    8c66:	08 95       	ret

// ~~~~~~~~~~
uint8_t
HideMsg(void)
{
	if (CurrMsg) {
    8c68:	80 e0       	ldi	r24, 0x00	; 0
    8c6a:	08 95       	ret

00008c6c <ShowMsg>:
}

// ~~~~~~~~~~~~~~~~~~
void
ShowMsg(MsgPage *Msg)
{
    8c6c:	0f 93       	push	r16
    8c6e:	1f 93       	push	r17
    8c70:	8c 01       	movw	r16, r24
	HideMsg();
    8c72:	0e 94 24 46 	call	0x8c48	; 0x8c48 <HideMsg>
	CurrMsg = Msg;
    8c76:	10 93 f6 04 	sts	0x04F6, r17
    8c7a:	00 93 f5 04 	sts	0x04F5, r16
	EventFunc(&CurrMsg->Load);
    8c7e:	c8 01       	movw	r24, r16
    8c80:	84 5a       	subi	r24, 0xA4	; 164
    8c82:	9f 4f       	sbci	r25, 0xFF	; 255
    8c84:	0e 94 c2 45 	call	0x8b84	; 0x8b84 <EventFunc>
}
    8c88:	1f 91       	pop	r17
    8c8a:	0f 91       	pop	r16
    8c8c:	08 95       	ret

00008c8e <MenuInit>:

// ~~~~~~~~~~~
void
MenuInit(void)
{
	CurrLCD = CurrLine = GetFix();
    8c8e:	e0 91 d4 02 	lds	r30, 0x02D4
    8c92:	f0 91 d5 02 	lds	r31, 0x02D5
    8c96:	33 96       	adiw	r30, 0x03	; 3
    8c98:	84 91       	lpm	r24, Z+
    8c9a:	80 93 ca 07 	sts	0x07CA, r24
    8c9e:	80 93 e8 08 	sts	0x08E8, r24
	#ifdef InitMsg
		ShowMsg(&InitMsg);
	#endif
	EventFunc(&CurrPage->Load);
    8ca2:	cf 01       	movw	r24, r30
    8ca4:	03 96       	adiw	r24, 0x03	; 3
    8ca6:	0e 94 c2 45 	call	0x8b84	; 0x8b84 <EventFunc>
}
    8caa:	08 95       	ret

00008cac <PosBlink>:
}

// ~~~~~~~~~~~~~~~~~~~~~
static void
PosBlink(T_Param *Param, char Cursor)
{
    8cac:	fc 01       	movw	r30, r24
	CurrX=Param->Pos+Param->Size-CurrPos-(Param->Prec&&CurrPos>=Param->Prec?2:1)-LCD_Buf[Y1];
    8cae:	20 81       	ld	r18, Z
    8cb0:	33 81       	ldd	r19, Z+3	; 0x03
    8cb2:	90 91 d7 02 	lds	r25, 0x02D7
    8cb6:	82 81       	ldd	r24, Z+2	; 0x02
    8cb8:	88 23       	and	r24, r24
    8cba:	11 f0       	breq	.+4      	; 0x8cc0 <PosBlink+0x14>
    8cbc:	98 17       	cp	r25, r24
    8cbe:	a0 f4       	brcc	.+40     	; 0x8ce8 <PosBlink+0x3c>
    8cc0:	4f ef       	ldi	r20, 0xFF	; 255
    8cc2:	39 1b       	sub	r19, r25
    8cc4:	32 0f       	add	r19, r18
    8cc6:	88 e5       	ldi	r24, 0x58	; 88
    8cc8:	96 e0       	ldi	r25, 0x06	; 6
    8cca:	38 1b       	sub	r19, r24
    8ccc:	80 91 45 0a 	lds	r24, 0x0A45
    8cd0:	25 e1       	ldi	r18, 0x15	; 21
    8cd2:	82 9f       	mul	r24, r18
    8cd4:	c0 01       	movw	r24, r0
    8cd6:	11 24       	eor	r1, r1
    8cd8:	38 1b       	sub	r19, r24
    8cda:	34 0f       	add	r19, r20
    8cdc:	30 93 fa 06 	sts	0x06FA, r19
	StrSize=1;
    8ce0:	81 e0       	ldi	r24, 0x01	; 1
    8ce2:	80 93 ac 06 	sts	0x06AC, r24
}
    8ce6:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~~~
static void
PosBlink(T_Param *Param, char Cursor)
{
	CurrX=Param->Pos+Param->Size-CurrPos-(Param->Prec&&CurrPos>=Param->Prec?2:1)-LCD_Buf[Y1];
    8ce8:	4e ef       	ldi	r20, 0xFE	; 254
    8cea:	eb cf       	rjmp	.-42     	; 0x8cc2 <PosBlink+0x16>

00008cec <GetCurrFieldSize>:

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    8cec:	e0 91 d4 02 	lds	r30, 0x02D4
    8cf0:	f0 91 d5 02 	lds	r31, 0x02D5
    8cf4:	45 91       	lpm	r20, Z+
    8cf6:	54 91       	lpm	r21, Z+
}
// ~~~~~~~~~~~~~~~~~~~~~~~
// Return size of CurrField. Use to determine size of Text, EE_Text OutField vars
uint8_t GetCurrFieldSize(void){
	uint8_t Size;
	MenuLine *Line=GetLine+CurrLine;
    8cf8:	80 91 ca 07 	lds	r24, 0x07CA
    8cfc:	2b e1       	ldi	r18, 0x1B	; 27
    8cfe:	82 9f       	mul	r24, r18
    8d00:	c0 01       	movw	r24, r0
    8d02:	11 24       	eor	r1, r1
    8d04:	48 0f       	add	r20, r24
    8d06:	59 1f       	adc	r21, r25
		while(prc(CurrStr+X)=='}'){
			X++;
			Size++;
		}
		if(Size){
			if(OF_N == CurrField) return Size;
    8d08:	30 91 d6 02 	lds	r19, 0x02D6
    8d0c:	90 e0       	ldi	r25, 0x00	; 0
    8d0e:	20 e0       	ldi	r18, 0x00	; 0

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    8d10:	fa 01       	movw	r30, r20
    8d12:	e9 0f       	add	r30, r25
    8d14:	f1 1d       	adc	r31, r1
    8d16:	e4 91       	lpm	r30, Z+
	MenuLine *Line=GetLine+CurrLine;
	PGM_P CurrStr=(PGM_P)(Line->Str);
	uint8_t OF_N = 0;
	for(uint8_t X=0; X<LCDXSz; X++){
		Size = 0;
		while(prc(CurrStr+X)=='}'){
    8d18:	ed 37       	cpi	r30, 0x7D	; 125
    8d1a:	71 f4       	brne	.+28     	; 0x8d38 <GetCurrFieldSize+0x4c>
			X++;
			Size++;
		}
		if(Size){
			if(OF_N == CurrField) return Size;
    8d1c:	80 e0       	ldi	r24, 0x00	; 0
	PGM_P CurrStr=(PGM_P)(Line->Str);
	uint8_t OF_N = 0;
	for(uint8_t X=0; X<LCDXSz; X++){
		Size = 0;
		while(prc(CurrStr+X)=='}'){
			X++;
    8d1e:	9f 5f       	subi	r25, 0xFF	; 255
			Size++;
    8d20:	8f 5f       	subi	r24, 0xFF	; 255
    8d22:	fa 01       	movw	r30, r20
    8d24:	e9 0f       	add	r30, r25
    8d26:	f1 1d       	adc	r31, r1
    8d28:	e4 91       	lpm	r30, Z+
	MenuLine *Line=GetLine+CurrLine;
	PGM_P CurrStr=(PGM_P)(Line->Str);
	uint8_t OF_N = 0;
	for(uint8_t X=0; X<LCDXSz; X++){
		Size = 0;
		while(prc(CurrStr+X)=='}'){
    8d2a:	ed 37       	cpi	r30, 0x7D	; 125
    8d2c:	c1 f3       	breq	.-16     	; 0x8d1e <GetCurrFieldSize+0x32>
			X++;
			Size++;
		}
		if(Size){
    8d2e:	88 23       	and	r24, r24
    8d30:	19 f0       	breq	.+6      	; 0x8d38 <GetCurrFieldSize+0x4c>
			if(OF_N == CurrField) return Size;
    8d32:	23 17       	cp	r18, r19
    8d34:	29 f0       	breq	.+10     	; 0x8d40 <GetCurrFieldSize+0x54>
			OF_N++;
    8d36:	2f 5f       	subi	r18, 0xFF	; 255
uint8_t GetCurrFieldSize(void){
	uint8_t Size;
	MenuLine *Line=GetLine+CurrLine;
	PGM_P CurrStr=(PGM_P)(Line->Str);
	uint8_t OF_N = 0;
	for(uint8_t X=0; X<LCDXSz; X++){
    8d38:	9f 5f       	subi	r25, 0xFF	; 255
    8d3a:	94 31       	cpi	r25, 0x14	; 20
    8d3c:	48 f3       	brcs	.-46     	; 0x8d10 <GetCurrFieldSize+0x24>
		Size = 0;
		while(prc(CurrStr+X)=='}'){
    8d3e:	80 e0       	ldi	r24, 0x00	; 0
			if(OF_N == CurrField) return Size;
			OF_N++;
		}
	}
	return 0;
}
    8d40:	08 95       	ret

00008d42 <Inc>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
static int32_t
Inc(int8_t Dir, uint32_t Buf)
{
    8d42:	5f 92       	push	r5
    8d44:	6f 92       	push	r6
    8d46:	7f 92       	push	r7
    8d48:	8f 92       	push	r8
    8d4a:	9f 92       	push	r9
    8d4c:	af 92       	push	r10
    8d4e:	bf 92       	push	r11
    8d50:	cf 92       	push	r12
    8d52:	df 92       	push	r13
    8d54:	ef 92       	push	r14
    8d56:	ff 92       	push	r15
    8d58:	0f 93       	push	r16
    8d5a:	1f 93       	push	r17
    8d5c:	cf 93       	push	r28
    8d5e:	df 93       	push	r29
    8d60:	58 2e       	mov	r5, r24
    8d62:	3a 01       	movw	r6, r20
    8d64:	4b 01       	movw	r8, r22
	uint32_t Pos = PowL10(CurrPos);
    8d66:	d0 90 d7 02 	lds	r13, 0x02D7
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
	uint32_t Pow = 1;
	while(Exp--)
    8d6a:	dd 20       	and	r13, r13
    8d6c:	09 f4       	brne	.+2      	; 0x8d70 <Inc+0x2e>
    8d6e:	5f c0       	rjmp	.+190    	; 0x8e2e <Inc+0xec>
    8d70:	61 e0       	ldi	r22, 0x01	; 1
    8d72:	e6 2e       	mov	r14, r22
    8d74:	f1 2c       	mov	r15, r1
    8d76:	01 2d       	mov	r16, r1
    8d78:	11 2d       	mov	r17, r1
		Pow *= 10;
    8d7a:	c8 01       	movw	r24, r16
    8d7c:	b7 01       	movw	r22, r14
    8d7e:	2a e0       	ldi	r18, 0x0A	; 10
    8d80:	30 e0       	ldi	r19, 0x00	; 0
    8d82:	40 e0       	ldi	r20, 0x00	; 0
    8d84:	50 e0       	ldi	r21, 0x00	; 0
    8d86:	0e 94 59 8e 	call	0x11cb2	; 0x11cb2 <__mulsi3>
    8d8a:	7b 01       	movw	r14, r22
    8d8c:	8c 01       	movw	r16, r24
    8d8e:	da 94       	dec	r13
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
	uint32_t Pow = 1;
	while(Exp--)
    8d90:	a1 f7       	brne	.-24     	; 0x8d7a <Inc+0x38>
    8d92:	5b 01       	movw	r10, r22
    8d94:	6c 01       	movw	r12, r24
	uint8_t Dig=Buf%(Pos*10)/Pos;
	if(Dig==(Dir==1?9:0)) {
    8d96:	81 e0       	ldi	r24, 0x01	; 1
    8d98:	58 16       	cp	r5, r24
    8d9a:	09 f4       	brne	.+2      	; 0x8d9e <Inc+0x5c>
    8d9c:	45 c0       	rjmp	.+138    	; 0x8e28 <Inc+0xe6>
    8d9e:	c0 e0       	ldi	r28, 0x00	; 0
    8da0:	d0 e0       	ldi	r29, 0x00	; 0
    8da2:	c8 01       	movw	r24, r16
    8da4:	b7 01       	movw	r22, r14
    8da6:	2a e0       	ldi	r18, 0x0A	; 10
    8da8:	30 e0       	ldi	r19, 0x00	; 0
    8daa:	40 e0       	ldi	r20, 0x00	; 0
    8dac:	50 e0       	ldi	r21, 0x00	; 0
    8dae:	0e 94 59 8e 	call	0x11cb2	; 0x11cb2 <__mulsi3>
    8db2:	9b 01       	movw	r18, r22
    8db4:	ac 01       	movw	r20, r24
    8db6:	c4 01       	movw	r24, r8
    8db8:	b3 01       	movw	r22, r6
    8dba:	0e 94 ab 8e 	call	0x11d56	; 0x11d56 <__udivmodsi4>
    8dbe:	a8 01       	movw	r20, r16
    8dc0:	97 01       	movw	r18, r14
    8dc2:	0e 94 ab 8e 	call	0x11d56	; 0x11d56 <__udivmodsi4>
    8dc6:	30 e0       	ldi	r19, 0x00	; 0
    8dc8:	2c 17       	cp	r18, r28
    8dca:	3d 07       	cpc	r19, r29
    8dcc:	99 f4       	brne	.+38     	; 0x8df4 <Inc+0xb2>
			Dir = -Dir;
    8dce:	51 94       	neg	r5
			Pos *= 9;
    8dd0:	57 01       	movw	r10, r14
    8dd2:	68 01       	movw	r12, r16
    8dd4:	aa 0c       	add	r10, r10
    8dd6:	bb 1c       	adc	r11, r11
    8dd8:	cc 1c       	adc	r12, r12
    8dda:	dd 1c       	adc	r13, r13
    8ddc:	aa 0c       	add	r10, r10
    8dde:	bb 1c       	adc	r11, r11
    8de0:	cc 1c       	adc	r12, r12
    8de2:	dd 1c       	adc	r13, r13
    8de4:	aa 0c       	add	r10, r10
    8de6:	bb 1c       	adc	r11, r11
    8de8:	cc 1c       	adc	r12, r12
    8dea:	dd 1c       	adc	r13, r13
    8dec:	ae 0c       	add	r10, r14
    8dee:	bf 1c       	adc	r11, r15
    8df0:	c0 1e       	adc	r12, r16
    8df2:	d1 1e       	adc	r13, r17
    8df4:	65 2d       	mov	r22, r5
    8df6:	77 27       	eor	r23, r23
    8df8:	67 fd       	sbrc	r22, 7
    8dfa:	70 95       	com	r23
    8dfc:	87 2f       	mov	r24, r23
    8dfe:	97 2f       	mov	r25, r23
    8e00:	a6 01       	movw	r20, r12
    8e02:	95 01       	movw	r18, r10
    8e04:	0e 94 59 8e 	call	0x11cb2	; 0x11cb2 <__mulsi3>
	}
	return Pos*Dir;
}
    8e08:	df 91       	pop	r29
    8e0a:	cf 91       	pop	r28
    8e0c:	1f 91       	pop	r17
    8e0e:	0f 91       	pop	r16
    8e10:	ff 90       	pop	r15
    8e12:	ef 90       	pop	r14
    8e14:	df 90       	pop	r13
    8e16:	cf 90       	pop	r12
    8e18:	bf 90       	pop	r11
    8e1a:	af 90       	pop	r10
    8e1c:	9f 90       	pop	r9
    8e1e:	8f 90       	pop	r8
    8e20:	7f 90       	pop	r7
    8e22:	6f 90       	pop	r6
    8e24:	5f 90       	pop	r5
    8e26:	08 95       	ret
static int32_t
Inc(int8_t Dir, uint32_t Buf)
{
	uint32_t Pos = PowL10(CurrPos);
	uint8_t Dig=Buf%(Pos*10)/Pos;
	if(Dig==(Dir==1?9:0)) {
    8e28:	c9 e0       	ldi	r28, 0x09	; 9
    8e2a:	d0 e0       	ldi	r29, 0x00	; 0
    8e2c:	ba cf       	rjmp	.-140    	; 0x8da2 <Inc+0x60>
    8e2e:	e1 e0       	ldi	r30, 0x01	; 1
    8e30:	ee 2e       	mov	r14, r30
    8e32:	f1 2c       	mov	r15, r1
    8e34:	01 2d       	mov	r16, r1
    8e36:	11 2d       	mov	r17, r1
    8e38:	71 e0       	ldi	r23, 0x01	; 1
    8e3a:	a7 2e       	mov	r10, r23
    8e3c:	b1 2c       	mov	r11, r1
    8e3e:	c1 2c       	mov	r12, r1
    8e40:	d1 2c       	mov	r13, r1
    8e42:	a9 cf       	rjmp	.-174    	; 0x8d96 <Inc+0x54>

00008e44 <MenuRight>:

// ~~~~~~~~~~~~
void
MenuRight(void)
{
}
    8e44:	08 95       	ret

00008e46 <MenuLeft>:

// ~~~~~~~~~~~~~
void
MenuLeft(void)
{
}
    8e46:	08 95       	ret

00008e48 <MenuEnter>:

// ~~~~~~~~~~~~
void
MenuEnter(void)
{
}
    8e48:	08 95       	ret

00008e4a <MenuEsc>:

// ~~~~~~~~~~
void
MenuEsc(void)
{
}
    8e4a:	08 95       	ret

00008e4c <DI_State>:
} DigInput;

// ~~~~~~~~~~~~~~~~~~
uint8_t
DI_State(uint8_t D_N)
{
    8e4c:	28 2f       	mov	r18, r24
    8e4e:	86 95       	lsr	r24
    8e50:	86 95       	lsr	r24
    8e52:	86 95       	lsr	r24
    8e54:	e0 e4       	ldi	r30, 0x40	; 64
    8e56:	f7 e0       	ldi	r31, 0x07	; 7
    8e58:	e8 0f       	add	r30, r24
    8e5a:	f1 1d       	adc	r31, r1
    8e5c:	80 81       	ld	r24, Z
    8e5e:	90 e0       	ldi	r25, 0x00	; 0
    8e60:	27 70       	andi	r18, 0x07	; 7
    8e62:	02 c0       	rjmp	.+4      	; 0x8e68 <DI_State+0x1c>
    8e64:	95 95       	asr	r25
    8e66:	87 95       	ror	r24
    8e68:	2a 95       	dec	r18
    8e6a:	e2 f7       	brpl	.-8      	; 0x8e64 <DI_State+0x18>
	return (DigInput.State[D_N/8] &(1<<D_N%8)) != 0;
}
    8e6c:	81 70       	andi	r24, 0x01	; 1
    8e6e:	08 95       	ret

00008e70 <DI_Front>:

// ~~~~~~~~~~~~~~~~~~
uint8_t
DI_Front(uint8_t D_N)
{
    8e70:	e8 2f       	mov	r30, r24
	uint8_t Byte=D_N/8, Bit=1<<D_N%8;
    8e72:	28 2f       	mov	r18, r24
    8e74:	27 70       	andi	r18, 0x07	; 7
    8e76:	81 e0       	ldi	r24, 0x01	; 1
    8e78:	90 e0       	ldi	r25, 0x00	; 0
    8e7a:	01 c0       	rjmp	.+2      	; 0x8e7e <DI_Front+0xe>
    8e7c:	88 0f       	add	r24, r24
    8e7e:	2a 95       	dec	r18
    8e80:	ea f7       	brpl	.-6      	; 0x8e7c <DI_Front+0xc>
	uint8_t State = DigInput.State[Byte] &Bit;
    8e82:	e6 95       	lsr	r30
    8e84:	e6 95       	lsr	r30
    8e86:	e6 95       	lsr	r30
    8e88:	f0 e0       	ldi	r31, 0x00	; 0
    8e8a:	e0 5c       	subi	r30, 0xC0	; 192
    8e8c:	f8 4f       	sbci	r31, 0xF8	; 248
    8e8e:	90 81       	ld	r25, Z
    8e90:	98 23       	and	r25, r24
	return DigInput.StateOld[Byte] &Bit ? State?NoFront:FallFront : State?RiseFront:NoFront;
    8e92:	23 81       	ldd	r18, Z+3	; 0x03
    8e94:	82 23       	and	r24, r18
    8e96:	21 f0       	breq	.+8      	; 0x8ea0 <DI_Front+0x30>
    8e98:	99 23       	and	r25, r25
    8e9a:	41 f4       	brne	.+16     	; 0x8eac <DI_Front+0x3c>
    8e9c:	82 e0       	ldi	r24, 0x02	; 2
    8e9e:	08 95       	ret
    8ea0:	89 2f       	mov	r24, r25
    8ea2:	99 23       	and	r25, r25
    8ea4:	09 f4       	brne	.+2      	; 0x8ea8 <DI_Front+0x38>
}
    8ea6:	08 95       	ret
uint8_t
DI_Front(uint8_t D_N)
{
	uint8_t Byte=D_N/8, Bit=1<<D_N%8;
	uint8_t State = DigInput.State[Byte] &Bit;
	return DigInput.StateOld[Byte] &Bit ? State?NoFront:FallFront : State?RiseFront:NoFront;
    8ea8:	81 e0       	ldi	r24, 0x01	; 1
}
    8eaa:	08 95       	ret
uint8_t
DI_Front(uint8_t D_N)
{
	uint8_t Byte=D_N/8, Bit=1<<D_N%8;
	uint8_t State = DigInput.State[Byte] &Bit;
	return DigInput.StateOld[Byte] &Bit ? State?NoFront:FallFront : State?RiseFront:NoFront;
    8eac:	80 e0       	ldi	r24, 0x00	; 0
    8eae:	08 95       	ret

00008eb0 <DI_Status>:
}

// ~~~~~~~~~~~~~~~~~~~
uint8_t
DI_Status(uint8_t D_N)
{
    8eb0:	28 2f       	mov	r18, r24
    8eb2:	86 95       	lsr	r24
    8eb4:	86 95       	lsr	r24
    8eb6:	86 95       	lsr	r24
    8eb8:	e0 e4       	ldi	r30, 0x40	; 64
    8eba:	f7 e0       	ldi	r31, 0x07	; 7
    8ebc:	e8 0f       	add	r30, r24
    8ebe:	f1 1d       	adc	r31, r1
    8ec0:	86 81       	ldd	r24, Z+6	; 0x06
    8ec2:	90 e0       	ldi	r25, 0x00	; 0
    8ec4:	27 70       	andi	r18, 0x07	; 7
    8ec6:	02 c0       	rjmp	.+4      	; 0x8ecc <DI_Status+0x1c>
    8ec8:	95 95       	asr	r25
    8eca:	87 95       	ror	r24
    8ecc:	2a 95       	dec	r18
    8ece:	e2 f7       	brpl	.-8      	; 0x8ec8 <DI_Status+0x18>
	return (DigInput.Status[D_N/8] &(1<<D_N%8)) != 0;
}
    8ed0:	81 70       	andi	r24, 0x01	; 1
    8ed2:	08 95       	ret

00008ed4 <DI_Init>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

// ~~~~~~~~~~
void
DI_Init(void)
{
    8ed4:	20 e0       	ldi	r18, 0x00	; 0
    8ed6:	30 e0       	ldi	r19, 0x00	; 0
// ~~~~~~~~~~~~~~~
static void
DI_Init_Hard(void)
{
	for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
		cli();
    8ed8:	f8 94       	cli

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    8eda:	a9 01       	movw	r20, r18
    8edc:	44 0f       	add	r20, r20
    8ede:	55 1f       	adc	r21, r21
    8ee0:	44 0f       	add	r20, r20
    8ee2:	55 1f       	adc	r21, r21
    8ee4:	44 0f       	add	r20, r20
    8ee6:	55 1f       	adc	r21, r21
    8ee8:	ca 01       	movw	r24, r20
    8eea:	82 57       	subi	r24, 0x72	; 114
    8eec:	92 4c       	sbci	r25, 0xC2	; 194
    8eee:	fc 01       	movw	r30, r24
    8ef0:	a5 91       	lpm	r26, Z+
    8ef2:	b4 91       	lpm	r27, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    8ef4:	4c 56       	subi	r20, 0x6C	; 108
    8ef6:	52 4c       	sbci	r21, 0xC2	; 194
    8ef8:	fa 01       	movw	r30, r20
    8efa:	44 91       	lpm	r20, Z+
		*(uint8_t*)prp(&DI_M[D_N].DDR) &=~prb(&DI_M[D_N].P);
    8efc:	94 2f       	mov	r25, r20
    8efe:	90 95       	com	r25
    8f00:	8c 91       	ld	r24, X
    8f02:	89 23       	and	r24, r25
    8f04:	8c 93       	st	X, r24

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    8f06:	c9 01       	movw	r24, r18
    8f08:	88 0f       	add	r24, r24
    8f0a:	99 1f       	adc	r25, r25
    8f0c:	88 0f       	add	r24, r24
    8f0e:	99 1f       	adc	r25, r25
    8f10:	88 0f       	add	r24, r24
    8f12:	99 1f       	adc	r25, r25
    8f14:	80 57       	subi	r24, 0x70	; 112
    8f16:	92 4c       	sbci	r25, 0xC2	; 194
    8f18:	fc 01       	movw	r30, r24
    8f1a:	a5 91       	lpm	r26, Z+
    8f1c:	b4 91       	lpm	r27, Z+
		*(uint8_t*)prp(&DI_M[D_N].PORT) |=prb(&DI_M[D_N].P);
    8f1e:	8c 91       	ld	r24, X
    8f20:	84 2b       	or	r24, r20
    8f22:	8c 93       	st	X, r24
		sei();
    8f24:	78 94       	sei
    8f26:	2f 5f       	subi	r18, 0xFF	; 255
    8f28:	3f 4f       	sbci	r19, 0xFF	; 255

// ~~~~~~~~~~~~~~~
static void
DI_Init_Hard(void)
{
	for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
    8f2a:	22 31       	cpi	r18, 0x12	; 18
    8f2c:	31 05       	cpc	r19, r1
    8f2e:	a1 f6       	brne	.-88     	; 0x8ed8 <DI_Init+0x4>
{
	DI_Init_Hard();
	#ifdef HSC_Reg
		HSC_Init();
	#endif
}
    8f30:	08 95       	ret

00008f32 <DO_State>:
} DigOutput;

// ~~~~~~~~~~~~~~~~~~
uint8_t
DO_State(uint8_t D_N)
{
    8f32:	90 e0       	ldi	r25, 0x00	; 0
    8f34:	e8 2f       	mov	r30, r24
    8f36:	e6 95       	lsr	r30
    8f38:	e6 95       	lsr	r30
    8f3a:	e6 95       	lsr	r30
    8f3c:	f0 e0       	ldi	r31, 0x00	; 0
    8f3e:	e5 52       	subi	r30, 0x25	; 37
    8f40:	f8 4f       	sbci	r31, 0xF8	; 248
    8f42:	40 81       	ld	r20, Z
    8f44:	50 e0       	ldi	r21, 0x00	; 0
    8f46:	87 70       	andi	r24, 0x07	; 7
    8f48:	21 e0       	ldi	r18, 0x01	; 1
    8f4a:	30 e0       	ldi	r19, 0x00	; 0
    8f4c:	02 c0       	rjmp	.+4      	; 0x8f52 <DO_State+0x20>
    8f4e:	22 0f       	add	r18, r18
    8f50:	33 1f       	adc	r19, r19
    8f52:	8a 95       	dec	r24
    8f54:	e2 f7       	brpl	.-8      	; 0x8f4e <DO_State+0x1c>
    8f56:	42 23       	and	r20, r18
    8f58:	53 23       	and	r21, r19
    8f5a:	14 16       	cp	r1, r20
    8f5c:	15 06       	cpc	r1, r21
    8f5e:	0c f4       	brge	.+2      	; 0x8f62 <DO_State+0x30>
    8f60:	91 e0       	ldi	r25, 0x01	; 1
	return (DigOutput.State[D_N/8] &(1<<D_N%8)) > 0;
}
    8f62:	89 2f       	mov	r24, r25
    8f64:	08 95       	ret

00008f66 <DO_Front>:

// ~~~~~~~~~~~~~~~~~~
uint8_t
DO_Front(uint8_t D_N)
{
    8f66:	e8 2f       	mov	r30, r24
	uint8_t Byte=D_N/8, Bit=1<<D_N%8;
    8f68:	28 2f       	mov	r18, r24
    8f6a:	27 70       	andi	r18, 0x07	; 7
    8f6c:	81 e0       	ldi	r24, 0x01	; 1
    8f6e:	90 e0       	ldi	r25, 0x00	; 0
    8f70:	01 c0       	rjmp	.+2      	; 0x8f74 <DO_Front+0xe>
    8f72:	88 0f       	add	r24, r24
    8f74:	2a 95       	dec	r18
    8f76:	ea f7       	brpl	.-6      	; 0x8f72 <DO_Front+0xc>
	uint8_t State = DigOutput.State[Byte] &Bit;
    8f78:	e6 95       	lsr	r30
    8f7a:	e6 95       	lsr	r30
    8f7c:	e6 95       	lsr	r30
    8f7e:	f0 e0       	ldi	r31, 0x00	; 0
    8f80:	e5 52       	subi	r30, 0x25	; 37
    8f82:	f8 4f       	sbci	r31, 0xF8	; 248
    8f84:	90 81       	ld	r25, Z
    8f86:	98 23       	and	r25, r24
	return DigOutput.StateOld[Byte] &Bit ? State?NoFront:FallFront : State?RiseFront:NoFront;
    8f88:	22 81       	ldd	r18, Z+2	; 0x02
    8f8a:	82 23       	and	r24, r18
    8f8c:	21 f0       	breq	.+8      	; 0x8f96 <DO_Front+0x30>
    8f8e:	99 23       	and	r25, r25
    8f90:	41 f4       	brne	.+16     	; 0x8fa2 <DO_Front+0x3c>
    8f92:	82 e0       	ldi	r24, 0x02	; 2
    8f94:	08 95       	ret
    8f96:	89 2f       	mov	r24, r25
    8f98:	99 23       	and	r25, r25
    8f9a:	09 f4       	brne	.+2      	; 0x8f9e <DO_Front+0x38>
}
    8f9c:	08 95       	ret
uint8_t
DO_Front(uint8_t D_N)
{
	uint8_t Byte=D_N/8, Bit=1<<D_N%8;
	uint8_t State = DigOutput.State[Byte] &Bit;
	return DigOutput.StateOld[Byte] &Bit ? State?NoFront:FallFront : State?RiseFront:NoFront;
    8f9e:	81 e0       	ldi	r24, 0x01	; 1
}
    8fa0:	08 95       	ret
uint8_t
DO_Front(uint8_t D_N)
{
	uint8_t Byte=D_N/8, Bit=1<<D_N%8;
	uint8_t State = DigOutput.State[Byte] &Bit;
	return DigOutput.StateOld[Byte] &Bit ? State?NoFront:FallFront : State?RiseFront:NoFront;
    8fa2:	80 e0       	ldi	r24, 0x00	; 0
    8fa4:	08 95       	ret

00008fa6 <SetDigOut>:

// ~~~~~~~~~~~~~~~~~~~
void
SetDigOut(uint8_t D_N)
{
	DigOutput.Buf[D_N/8] |=(1<<D_N%8);
    8fa6:	98 2f       	mov	r25, r24
    8fa8:	96 95       	lsr	r25
    8faa:	96 95       	lsr	r25
    8fac:	96 95       	lsr	r25
    8fae:	eb ed       	ldi	r30, 0xDB	; 219
    8fb0:	f7 e0       	ldi	r31, 0x07	; 7
    8fb2:	e9 0f       	add	r30, r25
    8fb4:	f1 1d       	adc	r31, r1
    8fb6:	87 70       	andi	r24, 0x07	; 7
    8fb8:	21 e0       	ldi	r18, 0x01	; 1
    8fba:	30 e0       	ldi	r19, 0x00	; 0
    8fbc:	02 c0       	rjmp	.+4      	; 0x8fc2 <SetDigOut+0x1c>
    8fbe:	22 0f       	add	r18, r18
    8fc0:	33 1f       	adc	r19, r19
    8fc2:	8a 95       	dec	r24
    8fc4:	e2 f7       	brpl	.-8      	; 0x8fbe <SetDigOut+0x18>
    8fc6:	84 81       	ldd	r24, Z+4	; 0x04
    8fc8:	82 2b       	or	r24, r18
    8fca:	84 83       	std	Z+4, r24	; 0x04
}
    8fcc:	08 95       	ret

00008fce <ResDigOut>:

// ~~~~~~~~~~~~~~~~~~~
void
ResDigOut(uint8_t D_N)
{
	DigOutput.Buf[D_N/8] &=~(1<<D_N%8);
    8fce:	98 2f       	mov	r25, r24
    8fd0:	96 95       	lsr	r25
    8fd2:	96 95       	lsr	r25
    8fd4:	96 95       	lsr	r25
    8fd6:	eb ed       	ldi	r30, 0xDB	; 219
    8fd8:	f7 e0       	ldi	r31, 0x07	; 7
    8fda:	e9 0f       	add	r30, r25
    8fdc:	f1 1d       	adc	r31, r1
    8fde:	87 70       	andi	r24, 0x07	; 7
    8fe0:	21 e0       	ldi	r18, 0x01	; 1
    8fe2:	30 e0       	ldi	r19, 0x00	; 0
    8fe4:	02 c0       	rjmp	.+4      	; 0x8fea <ResDigOut+0x1c>
    8fe6:	22 0f       	add	r18, r18
    8fe8:	33 1f       	adc	r19, r19
    8fea:	8a 95       	dec	r24
    8fec:	e2 f7       	brpl	.-8      	; 0x8fe6 <ResDigOut+0x18>
    8fee:	20 95       	com	r18
    8ff0:	84 81       	ldd	r24, Z+4	; 0x04
    8ff2:	28 23       	and	r18, r24
    8ff4:	24 83       	std	Z+4, r18	; 0x04
}
    8ff6:	08 95       	ret

00008ff8 <TogDigOut>:

// ~~~~~~~~~~~~~~~~~~~
void
TogDigOut(uint8_t D_N)
{
	DigOutput.Buf[D_N/8] ^=(1<<D_N%8);
    8ff8:	98 2f       	mov	r25, r24
    8ffa:	96 95       	lsr	r25
    8ffc:	96 95       	lsr	r25
    8ffe:	96 95       	lsr	r25
    9000:	eb ed       	ldi	r30, 0xDB	; 219
    9002:	f7 e0       	ldi	r31, 0x07	; 7
    9004:	e9 0f       	add	r30, r25
    9006:	f1 1d       	adc	r31, r1
    9008:	87 70       	andi	r24, 0x07	; 7
    900a:	21 e0       	ldi	r18, 0x01	; 1
    900c:	30 e0       	ldi	r19, 0x00	; 0
    900e:	02 c0       	rjmp	.+4      	; 0x9014 <TogDigOut+0x1c>
    9010:	22 0f       	add	r18, r18
    9012:	33 1f       	adc	r19, r19
    9014:	8a 95       	dec	r24
    9016:	e2 f7       	brpl	.-8      	; 0x9010 <TogDigOut+0x18>
    9018:	84 81       	ldd	r24, Z+4	; 0x04
    901a:	82 27       	eor	r24, r18
    901c:	84 83       	std	Z+4, r24	; 0x04
}
    901e:	08 95       	ret

00009020 <SetAllDigOut>:

// ~~~~~~~~~~~~~~~
void
SetAllDigOut(void)
{
	for (uint8_t i=0; i<DO_Reg; DigOutput.Buf[i++]=0xFF);
    9020:	8f ef       	ldi	r24, 0xFF	; 255
    9022:	80 93 df 07 	sts	0x07DF, r24
    9026:	80 93 e0 07 	sts	0x07E0, r24
}
    902a:	08 95       	ret

0000902c <DO_Enable>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    902c:	8f b7       	in	r24, 0x3f	; 63
    902e:	80 78       	andi	r24, 0x80	; 128
    9030:	80 93 ee 02 	sts	0x02EE, r24
	cli();
    9034:	f8 94       	cli
void
DO_Enable(void)
{
	#ifdef Enable
		IntOff();
		PortEnable |=Enable;
    9036:	46 9a       	sbi	0x08, 6	; 8

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    9038:	88 23       	and	r24, r24
    903a:	09 f0       	breq	.+2      	; 0x903e <DO_Enable+0x12>
		sei();
    903c:	78 94       	sei
    903e:	08 95       	ret

00009040 <DO_Disable>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    9040:	8f b7       	in	r24, 0x3f	; 63
    9042:	80 78       	andi	r24, 0x80	; 128
    9044:	80 93 ee 02 	sts	0x02EE, r24
	cli();
    9048:	f8 94       	cli
void
DO_Disable()
{
	#ifdef Enable
		IntOff();
		PortEnable &=~Enable;
    904a:	46 98       	cbi	0x08, 6	; 8

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    904c:	88 23       	and	r24, r24
    904e:	09 f0       	breq	.+2      	; 0x9052 <DO_Disable+0x12>
		sei();
    9050:	78 94       	sei
    9052:	08 95       	ret

00009054 <DigitOut>:

// ~~~~~~~~~~~
void
DigitOut(void)
{
	memcpy(DigOutput.StateOld, DigOutput.State, DO_Reg+DO_Reg_Ext);
    9054:	90 91 db 07 	lds	r25, 0x07DB
    9058:	80 91 dc 07 	lds	r24, 0x07DC
    905c:	80 93 de 07 	sts	0x07DE, r24
    9060:	90 93 dd 07 	sts	0x07DD, r25
	memcpy(DigOutput.State, DigOutput.Buf, DO_Reg);
    9064:	90 91 df 07 	lds	r25, 0x07DF
    9068:	80 91 e0 07 	lds	r24, 0x07E0
    906c:	80 93 dc 07 	sts	0x07DC, r24
    9070:	90 93 db 07 	sts	0x07DB, r25
    9074:	20 e1       	ldi	r18, 0x10	; 16
    9076:	35 e0       	ldi	r19, 0x05	; 5
    9078:	10 c0       	rjmp	.+32     	; 0x909a <DigitOut+0x46>
	uint8_t N = DO_Reg*8;
	while (N) {
		uint8_t D_N = prb(M+--N);
		cli();
		if (DigOutput.State[D_N/8] &(1<<D_N%8))
			PortData  |=Data;
    907a:	47 9a       	sbi	0x08, 7	; 8
		else
			PortData &=~Data;
		sei();
    907c:	78 94       	sei
    907e:	83 2f       	mov	r24, r19
    9080:	8a 95       	dec	r24
    9082:	f1 f7       	brne	.-4      	; 0x9080 <DigitOut+0x2c>
		_delay_us(1);				// 125 ns needs at 5V
		cli();
    9084:	f8 94       	cli
		PortClock |=Clock;
    9086:	45 9a       	sbi	0x08, 5	; 8
		sei();
    9088:	78 94       	sei
    908a:	83 2f       	mov	r24, r19
    908c:	8a 95       	dec	r24
    908e:	f1 f7       	brne	.-4      	; 0x908c <DigitOut+0x38>
		_delay_us(1);				// 200 ns needs at 5V
		cli();
    9090:	f8 94       	cli
		PortClock &=~Clock;
    9092:	45 98       	cbi	0x08, 5	; 8
		sei();
    9094:	78 94       	sei
DigitOut_Hard(void)
{
	static prog_uint8_t M[DO_Reg*8] = DO_Map;

	uint8_t N = DO_Reg*8;
	while (N) {
    9096:	22 23       	and	r18, r18
    9098:	d1 f0       	breq	.+52     	; 0x90ce <DigitOut+0x7a>
		uint8_t D_N = prb(M+--N);
    909a:	21 50       	subi	r18, 0x01	; 1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    909c:	e2 2f       	mov	r30, r18
    909e:	f0 e0       	ldi	r31, 0x00	; 0
    90a0:	e2 58       	subi	r30, 0x82	; 130
    90a2:	f2 4c       	sbci	r31, 0xC2	; 194
    90a4:	e4 91       	lpm	r30, Z+
		cli();
    90a6:	f8 94       	cli
		if (DigOutput.State[D_N/8] &(1<<D_N%8))
    90a8:	ae 2f       	mov	r26, r30
    90aa:	a6 95       	lsr	r26
    90ac:	a6 95       	lsr	r26
    90ae:	a6 95       	lsr	r26
    90b0:	b0 e0       	ldi	r27, 0x00	; 0
    90b2:	a5 52       	subi	r26, 0x25	; 37
    90b4:	b8 4f       	sbci	r27, 0xF8	; 248
    90b6:	8c 91       	ld	r24, X
    90b8:	90 e0       	ldi	r25, 0x00	; 0
    90ba:	e7 70       	andi	r30, 0x07	; 7
    90bc:	02 c0       	rjmp	.+4      	; 0x90c2 <DigitOut+0x6e>
    90be:	95 95       	asr	r25
    90c0:	87 95       	ror	r24
    90c2:	ea 95       	dec	r30
    90c4:	e2 f7       	brpl	.-8      	; 0x90be <DigitOut+0x6a>
    90c6:	80 fd       	sbrc	r24, 0
    90c8:	d8 cf       	rjmp	.-80     	; 0x907a <DigitOut+0x26>
			PortData  |=Data;
		else
			PortData &=~Data;
    90ca:	47 98       	cbi	0x08, 7	; 8
    90cc:	d7 cf       	rjmp	.-82     	; 0x907c <DigitOut+0x28>
		_delay_us(1);				// 200 ns needs at 5V
		cli();
		PortClock &=~Clock;
		sei();
	}
	cli();
    90ce:	f8 94       	cli
	PortStrobe |=Strobe;
    90d0:	80 91 05 01 	lds	r24, 0x0105
    90d4:	81 60       	ori	r24, 0x01	; 1
    90d6:	80 93 05 01 	sts	0x0105, r24
	sei();
    90da:	78 94       	sei
    90dc:	85 e0       	ldi	r24, 0x05	; 5
    90de:	8a 95       	dec	r24
    90e0:	f1 f7       	brne	.-4      	; 0x90de <DigitOut+0x8a>
	_delay_us(1);					// 200 ns needs at 5V
	cli();
    90e2:	f8 94       	cli
	PortStrobe &=~Strobe;
    90e4:	80 91 05 01 	lds	r24, 0x0105
    90e8:	8e 7f       	andi	r24, 0xFE	; 254
    90ea:	80 93 05 01 	sts	0x0105, r24
	sei();
    90ee:	78 94       	sei
				DigOutput.State[j] = (DigOutput_Ext)[i];
			(DigOutput_Ext)[i+DO_Reg_Ext] = DigOutput.Buf[j];
			IntOn();
		}
	#endif
}
    90f0:	08 95       	ret

000090f2 <DO_Init>:

// ~~~~~~~~~~~~~~~
static void
DO_Init_Hard(void)
{
	cli();
    90f2:	f8 94       	cli
	DDR_Strobe |= Strobe;
    90f4:	e4 e0       	ldi	r30, 0x04	; 4
    90f6:	f1 e0       	ldi	r31, 0x01	; 1
    90f8:	80 81       	ld	r24, Z
    90fa:	81 60       	ori	r24, 0x01	; 1
    90fc:	80 83       	st	Z, r24
	DDR_Data |= Data;
    90fe:	3f 9a       	sbi	0x07, 7	; 7
	DDR_Enable |= Enable;
    9100:	3e 9a       	sbi	0x07, 6	; 7
	DDR_Clock |=Clock;
    9102:	3d 9a       	sbi	0x07, 5	; 7
	PortStrobe &=~Strobe;
    9104:	e5 e0       	ldi	r30, 0x05	; 5
    9106:	f1 e0       	ldi	r31, 0x01	; 1
    9108:	80 81       	ld	r24, Z
    910a:	8e 7f       	andi	r24, 0xFE	; 254
    910c:	80 83       	st	Z, r24
	PortClock &=~Clock;
    910e:	45 98       	cbi	0x08, 5	; 8
	sei();
    9110:	78 94       	sei
// ~~~~~~~~~~
void
DO_Init(void)
{
	DO_Init_Hard();
	DigitOut();		// Clear all
    9112:	0e 94 2a 48 	call	0x9054	; 0x9054 <DigitOut>
	DO_Enable();
    9116:	0e 94 16 48 	call	0x902c	; 0x902c <DO_Enable>
}
    911a:	08 95       	ret

0000911c <AI_Init>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    911c:	e0 91 00 05 	lds	r30, 0x0500
    9120:	f0 e0       	ldi	r31, 0x00	; 0
    9122:	ee 0f       	add	r30, r30
    9124:	ff 1f       	adc	r31, r31
    9126:	e2 59       	subi	r30, 0x92	; 146
    9128:	f2 4c       	sbci	r31, 0xC2	; 194
    912a:	85 91       	lpm	r24, Z+
    912c:	94 91       	lpm	r25, Z+
// ~~~~~~~~~~~
static void
SetMuxAI(void)
{
	static prog_uint16_t Mux[] = AI_Mux;
	ADMUX = (uint8_t) prw(Mux+AI_N);
    912e:	80 93 7c 00 	sts	0x007C, r24
	#ifdef MUX5
		ADCSRB = (uint8_t) (prw(Mux+AI_N)>>8);
    9132:	90 93 7b 00 	sts	0x007B, r25
		#ifdef AN_C
			DDR_AN_C |=AN_C;
		#endif
	#endif
	SetMuxAI();
	ADCSRA = (((((1<<ADEN) |(1<<ADSC)) &~(1<<AD_Mode)) |(1<<ADIF)) &~(1<<ADIE)) |(1<<ADPS2) |(1<<ADPS1) |(1<<ADPS0);
    9136:	87 ed       	ldi	r24, 0xD7	; 215
    9138:	80 93 7a 00 	sts	0x007A, r24
		}
	#endif
	#ifdef InitAI_10ms
		TD_InnADC = Timer8SysAlloc(AI_Reg);
	#endif
}
    913c:	08 95       	ret

0000913e <AnalogIn>:

// ~~~~~~~~~~~
uint8_t
AnalogIn(void)
{
	if (ADCSRA &(1<<ADSC))
    913e:	80 91 7a 00 	lds	r24, 0x007A
    9142:	86 fd       	sbrc	r24, 6
    9144:	2c c0       	rjmp	.+88     	; 0x919e <AnalogIn+0x60>
		return AI_Reg;
	AnalogInput[AI_N] = ADCL;
    9146:	50 91 00 05 	lds	r21, 0x0500
    914a:	65 2f       	mov	r22, r21
    914c:	20 91 78 00 	lds	r18, 0x0078
	AnalogInput[AI_N] |= ADCH<<8;
    9150:	40 91 79 00 	lds	r20, 0x0079
    9154:	e5 2f       	mov	r30, r21
    9156:	f0 e0       	ldi	r31, 0x00	; 0
    9158:	ee 0f       	add	r30, r30
    915a:	ff 1f       	adc	r31, r31
    915c:	e2 5b       	subi	r30, 0xB2	; 178
    915e:	f4 4f       	sbci	r31, 0xF4	; 244
    9160:	94 2f       	mov	r25, r20
    9162:	80 e0       	ldi	r24, 0x00	; 0
    9164:	30 e0       	ldi	r19, 0x00	; 0
    9166:	82 2b       	or	r24, r18
    9168:	93 2b       	or	r25, r19
    916a:	91 83       	std	Z+1, r25	; 0x01
    916c:	80 83       	st	Z, r24
		}
		else
			Chan = AI_Reg;
	#endif

	if (++AI_N == AI_Reg)
    916e:	5f 5f       	subi	r21, 0xFF	; 255
    9170:	50 93 00 05 	sts	0x0500, r21
    9174:	58 30       	cpi	r21, 0x08	; 8
    9176:	b1 f0       	breq	.+44     	; 0x91a4 <AnalogIn+0x66>
    9178:	e5 2f       	mov	r30, r21
    917a:	f0 e0       	ldi	r31, 0x00	; 0
    917c:	ee 0f       	add	r30, r30
    917e:	ff 1f       	adc	r31, r31
    9180:	e2 59       	subi	r30, 0x92	; 146
    9182:	f2 4c       	sbci	r31, 0xC2	; 194
    9184:	85 91       	lpm	r24, Z+
    9186:	94 91       	lpm	r25, Z+
// ~~~~~~~~~~~
static void
SetMuxAI(void)
{
	static prog_uint16_t Mux[] = AI_Mux;
	ADMUX = (uint8_t) prw(Mux+AI_N);
    9188:	80 93 7c 00 	sts	0x007C, r24
	#ifdef MUX5
		ADCSRB = (uint8_t) (prw(Mux+AI_N)>>8);
    918c:	90 93 7b 00 	sts	0x007B, r25
	#endif

	if (++AI_N == AI_Reg)
		AI_N = 0;
	SetMuxAI();
	ADCSRA |=(1<<ADSC);
    9190:	80 91 7a 00 	lds	r24, 0x007A
    9194:	80 64       	ori	r24, 0x40	; 64
    9196:	80 93 7a 00 	sts	0x007A, r24
			IntOn();
		}
	#endif

	return Chan;
}
    919a:	86 2f       	mov	r24, r22
    919c:	08 95       	ret

// ~~~~~~~~~~~
uint8_t
AnalogIn(void)
{
	if (ADCSRA &(1<<ADSC))
    919e:	68 e0       	ldi	r22, 0x08	; 8
			IntOn();
		}
	#endif

	return Chan;
}
    91a0:	86 2f       	mov	r24, r22
    91a2:	08 95       	ret
		else
			Chan = AI_Reg;
	#endif

	if (++AI_N == AI_Reg)
		AI_N = 0;
    91a4:	10 92 00 05 	sts	0x0500, r1
    91a8:	50 e0       	ldi	r21, 0x00	; 0
    91aa:	e6 cf       	rjmp	.-52     	; 0x9178 <AnalogIn+0x3a>

000091ac <Thermode>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
int16_t
Thermode(uint8_t T_Fami, uint8_t T_Type, uint16_t Code)
{
	if (T_Type==ThermOff)
    91ac:	66 23       	and	r22, r22
    91ae:	f9 f0       	breq	.+62     	; 0x91ee <Thermode+0x42>
		return Therm_Off_Mark;
	if (T_Fami==Thermis)
    91b0:	88 23       	and	r24, r24
    91b2:	91 f4       	brne	.+36     	; 0x91d8 <Thermode+0x2c>
		switch(T_Type) {
    91b4:	64 30       	cpi	r22, 0x04	; 4
    91b6:	d9 f1       	breq	.+118    	; 0x922e <Thermode+0x82>
    91b8:	65 30       	cpi	r22, 0x05	; 5
    91ba:	60 f5       	brcc	.+88     	; 0x9214 <Thermode+0x68>
    91bc:	62 30       	cpi	r22, 0x02	; 2
    91be:	09 f4       	brne	.+2      	; 0x91c2 <Thermode+0x16>
    91c0:	4b c0       	rjmp	.+150    	; 0x9258 <Thermode+0xac>
    91c2:	63 30       	cpi	r22, 0x03	; 3
    91c4:	d8 f5       	brcc	.+118    	; 0x923c <Thermode+0x90>
    91c6:	61 30       	cpi	r22, 0x01	; 1
    91c8:	a1 f4       	brne	.+40     	; 0x91f2 <Thermode+0x46>
		case TSM100:
			return ThermCalc(TSM100);
    91ca:	86 e2       	ldi	r24, 0x26	; 38
    91cc:	9c e3       	ldi	r25, 0x3C	; 60
    91ce:	ba 01       	movw	r22, r20
    91d0:	0e 94 81 2b 	call	0x5702	; 0x5702 <PGM_uBrokLine>
    91d4:	ac 01       	movw	r20, r24
    91d6:	0d c0       	rjmp	.+26     	; 0x91f2 <Thermode+0x46>
#endif
		default:
			return Code;
		}
	else	// T_Fami==Thermoc
		switch(T_Type) {
    91d8:	61 30       	cpi	r22, 0x01	; 1
    91da:	69 f0       	breq	.+26     	; 0x91f6 <Thermode+0x4a>
    91dc:	62 30       	cpi	r22, 0x02	; 2
    91de:	49 f4       	brne	.+18     	; 0x91f2 <Thermode+0x46>
		case TC_K:
			return .1851*Code;
#endif
#if	TerInput==ADC_Input
		case TC_B:
			return ThermCalc(TC_B_);
    91e0:	8a e2       	ldi	r24, 0x2A	; 42
    91e2:	9d e3       	ldi	r25, 0x3D	; 61
    91e4:	ba 01       	movw	r22, r20
    91e6:	0e 94 81 2b 	call	0x5702	; 0x5702 <PGM_uBrokLine>
    91ea:	ac 01       	movw	r20, r24
    91ec:	02 c0       	rjmp	.+4      	; 0x91f2 <Thermode+0x46>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
int16_t
Thermode(uint8_t T_Fami, uint8_t T_Type, uint16_t Code)
{
	if (T_Type==ThermOff)
    91ee:	40 e0       	ldi	r20, 0x00	; 0
    91f0:	50 e8       	ldi	r21, 0x80	; 128
			return ThermCalc(TC_B_);
#endif
		default:
			return Code;
		}
}
    91f2:	ca 01       	movw	r24, r20
    91f4:	08 95       	ret
			return ThermCalc(TC_J_) + InnerTer;
		case TC_L:
			return ThermCalc(TC_L_) + InnerTer;
#else
		case TC_K:
			return .1851*Code;
    91f6:	ba 01       	movw	r22, r20
    91f8:	80 e0       	ldi	r24, 0x00	; 0
    91fa:	90 e0       	ldi	r25, 0x00	; 0
    91fc:	0e 94 0c 89 	call	0x11218	; 0x11218 <__floatunsisf>
    9200:	2b ed       	ldi	r18, 0xDB	; 219
    9202:	3a e8       	ldi	r19, 0x8A	; 138
    9204:	4d e3       	ldi	r20, 0x3D	; 61
    9206:	5e e3       	ldi	r21, 0x3E	; 62
    9208:	0e 94 49 89 	call	0x11292	; 0x11292 <__mulsf3>
    920c:	0e 94 dc 8d 	call	0x11bb8	; 0x11bb8 <__fixsfsi>
    9210:	ab 01       	movw	r20, r22
    9212:	ef cf       	rjmp	.-34     	; 0x91f2 <Thermode+0x46>
Thermode(uint8_t T_Fami, uint8_t T_Type, uint16_t Code)
{
	if (T_Type==ThermOff)
		return Therm_Off_Mark;
	if (T_Fami==Thermis)
		switch(T_Type) {
    9214:	66 30       	cpi	r22, 0x06	; 6
    9216:	39 f1       	breq	.+78     	; 0x9266 <Thermode+0xba>
    9218:	66 30       	cpi	r22, 0x06	; 6
    921a:	b8 f0       	brcs	.+46     	; 0x924a <Thermode+0x9e>
    921c:	67 30       	cpi	r22, 0x07	; 7
    921e:	49 f7       	brne	.-46     	; 0x91f2 <Thermode+0x46>
			return ThermCalc(Pt100);
#if	TerInput==ADC_Input
		case Gr21:
			return ThermCalc(Gr21);
		case Gr23:
			return ThermCalc(Gr23);
    9220:	8a e0       	ldi	r24, 0x0A	; 10
    9222:	9d e3       	ldi	r25, 0x3D	; 61
    9224:	ba 01       	movw	r22, r20
    9226:	0e 94 81 2b 	call	0x5702	; 0x5702 <PGM_uBrokLine>
    922a:	ac 01       	movw	r20, r24
    922c:	e2 cf       	rjmp	.-60     	; 0x91f2 <Thermode+0x46>
		case TSM50:
			return ThermCalc(TSM50);
		case TSP100:
			return ThermCalc(TSP100);
		case TSP50:
			return ThermCalc(TSP50);
    922e:	8a e9       	ldi	r24, 0x9A	; 154
    9230:	9c e3       	ldi	r25, 0x3C	; 60
    9232:	ba 01       	movw	r22, r20
    9234:	0e 94 81 2b 	call	0x5702	; 0x5702 <PGM_uBrokLine>
    9238:	ac 01       	movw	r20, r24
    923a:	db cf       	rjmp	.-74     	; 0x91f2 <Thermode+0x46>
		case TSM100:
			return ThermCalc(TSM100);
		case TSM50:
			return ThermCalc(TSM50);
		case TSP100:
			return ThermCalc(TSP100);
    923c:	82 e7       	ldi	r24, 0x72	; 114
    923e:	9c e3       	ldi	r25, 0x3C	; 60
    9240:	ba 01       	movw	r22, r20
    9242:	0e 94 81 2b 	call	0x5702	; 0x5702 <PGM_uBrokLine>
    9246:	ac 01       	movw	r20, r24
    9248:	d4 cf       	rjmp	.-88     	; 0x91f2 <Thermode+0x46>
		case TSP50:
			return ThermCalc(TSP50);
		case Pt100:
			return ThermCalc(Pt100);
    924a:	8e eb       	ldi	r24, 0xBE	; 190
    924c:	9c e3       	ldi	r25, 0x3C	; 60
    924e:	ba 01       	movw	r22, r20
    9250:	0e 94 81 2b 	call	0x5702	; 0x5702 <PGM_uBrokLine>
    9254:	ac 01       	movw	r20, r24
    9256:	cd cf       	rjmp	.-102    	; 0x91f2 <Thermode+0x46>
	if (T_Fami==Thermis)
		switch(T_Type) {
		case TSM100:
			return ThermCalc(TSM100);
		case TSM50:
			return ThermCalc(TSM50);
    9258:	86 e4       	ldi	r24, 0x46	; 70
    925a:	9c e3       	ldi	r25, 0x3C	; 60
    925c:	ba 01       	movw	r22, r20
    925e:	0e 94 81 2b 	call	0x5702	; 0x5702 <PGM_uBrokLine>
    9262:	ac 01       	movw	r20, r24
    9264:	c6 cf       	rjmp	.-116    	; 0x91f2 <Thermode+0x46>
			return ThermCalc(TSP50);
		case Pt100:
			return ThermCalc(Pt100);
#if	TerInput==ADC_Input
		case Gr21:
			return ThermCalc(Gr21);
    9266:	86 ee       	ldi	r24, 0xE6	; 230
    9268:	9c e3       	ldi	r25, 0x3C	; 60
    926a:	ba 01       	movw	r22, r20
    926c:	0e 94 81 2b 	call	0x5702	; 0x5702 <PGM_uBrokLine>
    9270:	ac 01       	movw	r20, r24
    9272:	bf cf       	rjmp	.-130    	; 0x91f2 <Thermode+0x46>

00009274 <ThermExt>:
			IntOff();
			Temperature[TerReg+i] = (Temperature_Ext)[i];
			IntOn();
		}
	#endif
}
    9274:	08 95       	ret

00009276 <Therm_ADC_Off>:

// ~~~~~~~~~~~~~~~~
void
Therm_ADC_Off(void)
{
	for (uint8_t i=0; i<TerReg; Temperature[i++]=ADC_Off_Mark);
    9276:	81 e0       	ldi	r24, 0x01	; 1
    9278:	90 e8       	ldi	r25, 0x80	; 128
    927a:	90 93 46 06 	sts	0x0646, r25
    927e:	80 93 45 06 	sts	0x0645, r24
    9282:	90 93 48 06 	sts	0x0648, r25
    9286:	80 93 47 06 	sts	0x0647, r24
    928a:	90 93 4a 06 	sts	0x064A, r25
    928e:	80 93 49 06 	sts	0x0649, r24
    9292:	90 93 4c 06 	sts	0x064C, r25
    9296:	80 93 4b 06 	sts	0x064B, r24
    929a:	90 93 4e 06 	sts	0x064E, r25
    929e:	80 93 4d 06 	sts	0x064D, r24
    92a2:	90 93 50 06 	sts	0x0650, r25
    92a6:	80 93 4f 06 	sts	0x064F, r24
}
    92aa:	08 95       	ret

000092ac <ThermWrong>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
ThermWrong(uint8_t T_Fami, uint8_t T_Type, int16_t Ter)
{
	uint8_t TW = ThermNorm;
	if (T_Type!=ThermOff && T_Type<=prb(MaxThermType+T_Fami)) {
    92ac:	66 23       	and	r22, r22
    92ae:	31 f1       	breq	.+76     	; 0x92fc <ThermWrong+0x50>
    92b0:	28 2f       	mov	r18, r24
    92b2:	30 e0       	ldi	r19, 0x00	; 0

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    92b4:	f9 01       	movw	r30, r18
    92b6:	e0 5e       	subi	r30, 0xE0	; 224
    92b8:	f3 4c       	sbci	r31, 0xC3	; 195
    92ba:	e4 91       	lpm	r30, Z+
    92bc:	e6 17       	cp	r30, r22
    92be:	f0 f0       	brcs	.+60     	; 0x92fc <ThermWrong+0x50>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    92c0:	f9 01       	movw	r30, r18
    92c2:	ee 0f       	add	r30, r30
    92c4:	ff 1f       	adc	r31, r31
    92c6:	ee 5d       	subi	r30, 0xDE	; 222
    92c8:	f3 4c       	sbci	r31, 0xC3	; 195
    92ca:	25 91       	lpm	r18, Z+
    92cc:	34 91       	lpm	r19, Z+
		TerLim *T_L = prp(TerLimType+T_Fami);
		if (Ter<(int16_t)prw(&T_L[T_Type].Low))
    92ce:	86 2f       	mov	r24, r22
    92d0:	90 e0       	ldi	r25, 0x00	; 0
    92d2:	88 0f       	add	r24, r24
    92d4:	99 1f       	adc	r25, r25
    92d6:	88 0f       	add	r24, r24
    92d8:	99 1f       	adc	r25, r25
    92da:	28 0f       	add	r18, r24
    92dc:	39 1f       	adc	r19, r25

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    92de:	f9 01       	movw	r30, r18
    92e0:	85 91       	lpm	r24, Z+
    92e2:	94 91       	lpm	r25, Z+
    92e4:	48 17       	cp	r20, r24
    92e6:	59 07       	cpc	r21, r25
    92e8:	5c f0       	brlt	.+22     	; 0x9300 <ThermWrong+0x54>
    92ea:	f9 01       	movw	r30, r18
    92ec:	32 96       	adiw	r30, 0x02	; 2
    92ee:	85 91       	lpm	r24, Z+
    92f0:	94 91       	lpm	r25, Z+
			TW = ThermUnder;
		else if(Ter>(int16_t)prw(&T_L[T_Type].Upp))
    92f2:	84 17       	cp	r24, r20
    92f4:	95 07       	cpc	r25, r21
    92f6:	14 f4       	brge	.+4      	; 0x92fc <ThermWrong+0x50>
    92f8:	82 e0       	ldi	r24, 0x02	; 2
    92fa:	08 95       	ret
    92fc:	80 e0       	ldi	r24, 0x00	; 0
			TW = ThermOver;
	}
	return TW;
}
    92fe:	08 95       	ret
ThermWrong(uint8_t T_Fami, uint8_t T_Type, int16_t Ter)
{
	uint8_t TW = ThermNorm;
	if (T_Type!=ThermOff && T_Type<=prb(MaxThermType+T_Fami)) {
		TerLim *T_L = prp(TerLimType+T_Fami);
		if (Ter<(int16_t)prw(&T_L[T_Type].Low))
    9300:	81 e0       	ldi	r24, 0x01	; 1
    9302:	08 95       	ret

00009304 <Key_MB0_CPT_Clear>:
	{" BAUD: }}}}}bps     ", NULL, F_MB##N##_Baud}																														\
};																																																					\
MenuPage MenuModbus##N = {SetMenu(L_MB##N), 1};

#if Modbus_Qt == 1
	M_Modbus(0)
    9304:	80 e0       	ldi	r24, 0x00	; 0
    9306:	90 e0       	ldi	r25, 0x00	; 0

// ~~~~~~~~~~~~~~~~~~~~~~~
void
MB_CPT_Clear(uint8_t MB_N)
{
	for (uint8_t i=0; i<8; MB_CPT[MB_N][i++]=0);
    9308:	fc 01       	movw	r30, r24
    930a:	ee 0f       	add	r30, r30
    930c:	ff 1f       	adc	r31, r31
    930e:	ea 5c       	subi	r30, 0xCA	; 202
    9310:	f6 4f       	sbci	r31, 0xF6	; 246
    9312:	11 82       	std	Z+1, r1	; 0x01
    9314:	10 82       	st	Z, r1
    9316:	01 96       	adiw	r24, 0x01	; 1
    9318:	88 30       	cpi	r24, 0x08	; 8
    931a:	91 05       	cpc	r25, r1
    931c:	a9 f7       	brne	.-22     	; 0x9308 <Key_MB0_CPT_Clear+0x4>
    931e:	81 e0       	ldi	r24, 0x01	; 1
    9320:	08 95       	ret

00009322 <ResetGSMState>:
	#ifdef GSM_DEBUG
		MenuPage MenuGSMConsole;
	#endif

	void ResetGSMState(void){
		GSM_State = GSM_ReStart1;
    9322:	8a e4       	ldi	r24, 0x4A	; 74
    9324:	80 93 f6 06 	sts	0x06F6, r24
	}
    9328:	08 95       	ret

0000932a <Key_MaxScanCycle_Clear>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
InField F_ScanCycle[] = { {Byte, &ScanCycle} };
InField F_ScanCyclePerSec[] = { {Word, &ScanPerSec} }; 
InField F_MaxScanCycle[] = {{Byte, &MaxScanCycle}};

uint8_t Key_MaxScanCycle_Clear(void) {if(CurrLine==3) MaxScanCycle_Clear(); return StandartKey;}
    932a:	80 91 ca 07 	lds	r24, 0x07CA
    932e:	83 30       	cpi	r24, 0x03	; 3
    9330:	11 f4       	brne	.+4      	; 0x9336 <Key_MaxScanCycle_Clear+0xc>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
void
MaxScanCycle_Clear(void)
{
	MaxScanCycle = 0;
    9332:	10 92 b1 06 	sts	0x06B1, r1
    9336:	80 e0       	ldi	r24, 0x00	; 0
    9338:	08 95       	ret

0000933a <Caller_StartCalling>:
uint8_t CallerBusyState;
uint8_t CallerMessage[2];
uint8_t CurrentAbonent;
uint8_t CurrentCall;
void Caller_StartCalling(uint8_t inputN){
	CallerMessage[0]=1;
    933a:	91 e0       	ldi	r25, 0x01	; 1
    933c:	90 93 b6 07 	sts	0x07B6, r25
	CallerMessage[1]=inputN;
    9340:	80 93 b7 07 	sts	0x07B7, r24
	CallerBusyState = 1;
    9344:	90 93 c4 07 	sts	0x07C4, r25
}
    9348:	08 95       	ret

0000934a <CallerCycle>:

void CallerCycle(){
	
	switch(Caller_state){
    934a:	80 91 e4 02 	lds	r24, 0x02E4
    934e:	81 30       	cpi	r24, 0x01	; 1
    9350:	49 f1       	breq	.+82     	; 0x93a4 <CallerCycle+0x5a>
    9352:	81 30       	cpi	r24, 0x01	; 1
    9354:	80 f4       	brcc	.+32     	; 0x9376 <CallerCycle+0x2c>
		case CALLER_IDLE:
			if(0 != CallerMessage[0]){
    9356:	80 91 b6 07 	lds	r24, 0x07B6
    935a:	88 23       	and	r24, r24
    935c:	81 f1       	breq	.+96     	; 0x93be <CallerCycle+0x74>
				CallerMessage[0] = 0;
    935e:	10 92 b6 07 	sts	0x07B6, r1
				CurrentAbonent = 0;
    9362:	10 92 38 07 	sts	0x0738, r1
				CurrentCall = 0;
    9366:	10 92 da 07 	sts	0x07DA, r1
				CallerBusyState = 1;
    936a:	81 e0       	ldi	r24, 0x01	; 1
    936c:	80 93 c4 07 	sts	0x07C4, r24
				Caller_state = CHECK_PHONE_BUSY;
    9370:	80 93 e4 02 	sts	0x02E4, r24
    9374:	08 95       	ret
	CallerBusyState = 1;
}

void CallerCycle(){
	
	switch(Caller_state){
    9376:	82 30       	cpi	r24, 0x02	; 2
    9378:	09 f0       	breq	.+2      	; 0x937c <CallerCycle+0x32>
    937a:	08 95       	ret
					break;
				}
			}
			break;
		case CALLER_ARBITR:
			GSM_StartCalling(CurrentAbonent,CallerMessage[1]);
    937c:	90 91 38 07 	lds	r25, 0x0738
    9380:	80 91 b7 07 	lds	r24, 0x07B7
uint8_t numOfCheckBallanceRetry=0;

uint8_t Message[3];  // 
uint8_t GSMBusyState=0; // " " 0 -  , 1 -  
void GSM_StartCalling(uint8_t inputN,uint8_t abonentN){
	Message[0]=1;
    9384:	21 e0       	ldi	r18, 0x01	; 1
    9386:	20 93 35 07 	sts	0x0735, r18
	Message[1]=inputN;
    938a:	90 93 36 07 	sts	0x0736, r25
	Message[2]=abonentN;
    938e:	80 93 37 07 	sts	0x0737, r24
			if(CurrentCall<2){
    9392:	80 91 da 07 	lds	r24, 0x07DA
    9396:	82 30       	cpi	r24, 0x02	; 2
    9398:	c8 f0       	brcs	.+50     	; 0x93cc <CallerCycle+0x82>
				CurrentCall++;
				Caller_state = CHECK_PHONE_BUSY;
				break;
			}
			else{
			 if(CurrentAbonent<MaxTelephDirSz-1){
    939a:	92 30       	cpi	r25, 0x02	; 2
    939c:	e8 f0       	brcs	.+58     	; 0x93d8 <CallerCycle+0x8e>
				CurrentCall = 0;
				Caller_state = CHECK_PHONE_BUSY;
				break;
			 }
			 else{
			 	Caller_state = CALLER_IDLE;
    939e:	10 92 e4 02 	sts	0x02E4, r1
    93a2:	08 95       	ret
				break;
			}
			CallerBusyState = 0;
			break;
		case CHECK_PHONE_BUSY:
			if(0 == TransmitterState){
    93a4:	80 91 e3 02 	lds	r24, 0x02E3
    93a8:	88 23       	and	r24, r24
    93aa:	61 f0       	breq	.+24     	; 0x93c4 <CallerCycle+0x7a>
}
uint8_t ConfirmState = 0;
uint8_t RequestRepeatCounter = 0;
uint8_t TransmitterState = 0;
uint8_t GSM_GetConfirmState(){
	if(1 == ConfirmState){
    93ac:	80 91 e1 02 	lds	r24, 0x02E1
    93b0:	81 30       	cpi	r24, 0x01	; 1
    93b2:	19 f7       	brne	.-58     	; 0x937a <CallerCycle+0x30>
		ConfirmState = 0;
    93b4:	10 92 e1 02 	sts	0x02E1, r1
				Caller_state = CALLER_ARBITR;
				break;
			}else 
			{
				if(1 == GSM_GetConfirmState()){
					Caller_state = CALLER_IDLE;
    93b8:	10 92 e4 02 	sts	0x02E4, r1
    93bc:	08 95       	ret
				CurrentCall = 0;
				CallerBusyState = 1;
				Caller_state = CHECK_PHONE_BUSY;
				break;
			}
			CallerBusyState = 0;
    93be:	10 92 c4 07 	sts	0x07C4, r1
    93c2:	08 95       	ret
			break;
		case CHECK_PHONE_BUSY:
			if(0 == TransmitterState){
				Caller_state = CALLER_ARBITR;
    93c4:	82 e0       	ldi	r24, 0x02	; 2
    93c6:	80 93 e4 02 	sts	0x02E4, r24
    93ca:	08 95       	ret
			}
			break;
		case CALLER_ARBITR:
			GSM_StartCalling(CurrentAbonent,CallerMessage[1]);
			if(CurrentCall<2){
				CurrentCall++;
    93cc:	8f 5f       	subi	r24, 0xFF	; 255
    93ce:	80 93 da 07 	sts	0x07DA, r24
				Caller_state = CHECK_PHONE_BUSY;
    93d2:	20 93 e4 02 	sts	0x02E4, r18
    93d6:	08 95       	ret
				break;
			}
			else{
			 if(CurrentAbonent<MaxTelephDirSz-1){
			 	CurrentAbonent++;
    93d8:	9f 5f       	subi	r25, 0xFF	; 255
    93da:	90 93 38 07 	sts	0x0738, r25
				CurrentCall = 0;
    93de:	10 92 da 07 	sts	0x07DA, r1
				Caller_state = CHECK_PHONE_BUSY;
    93e2:	20 93 e4 02 	sts	0x02E4, r18
    93e6:	08 95       	ret

000093e8 <WriteDigOut>:

}

void WriteDigOut(uint8_t DO_Num, uint8_t DO_Level)
{
	if(1 == DO_Level){
    93e8:	61 30       	cpi	r22, 0x01	; 1
    93ea:	19 f0       	breq	.+6      	; 0x93f2 <WriteDigOut+0xa>
		SetDigOut(DO_Num);
	}else
	{
		ResDigOut(DO_Num);	
    93ec:	0e 94 e7 47 	call	0x8fce	; 0x8fce <ResDigOut>
    93f0:	08 95       	ret
}

void WriteDigOut(uint8_t DO_Num, uint8_t DO_Level)
{
	if(1 == DO_Level){
		SetDigOut(DO_Num);
    93f2:	0e 94 d3 47 	call	0x8fa6	; 0x8fa6 <SetDigOut>
    93f6:	08 95       	ret

000093f8 <ModbusAppCycle>:
	{
		ResDigOut(DO_Num);	
	}
}

void ModbusAppCycle(){
    93f8:	bf 92       	push	r11
    93fa:	cf 92       	push	r12
    93fc:	df 92       	push	r13
    93fe:	ef 92       	push	r14
    9400:	ff 92       	push	r15
    9402:	0f 93       	push	r16
    9404:	1f 93       	push	r17
	MB_Input[0] = (DI_State(0)<<0)|(DI_State(1)<<1)|(DI_State(2)<<2)|(DI_State(3)<<3)|(DI_State(4)<<4)|(DI_State(5)<<5)|(DI_State(6)<<6)|(DI_State(7)<<7);
    9406:	80 e0       	ldi	r24, 0x00	; 0
    9408:	0e 94 26 47 	call	0x8e4c	; 0x8e4c <DI_State>
    940c:	b8 2e       	mov	r11, r24
    940e:	81 e0       	ldi	r24, 0x01	; 1
    9410:	0e 94 26 47 	call	0x8e4c	; 0x8e4c <DI_State>
    9414:	c8 2e       	mov	r12, r24
    9416:	82 e0       	ldi	r24, 0x02	; 2
    9418:	0e 94 26 47 	call	0x8e4c	; 0x8e4c <DI_State>
    941c:	18 2f       	mov	r17, r24
    941e:	83 e0       	ldi	r24, 0x03	; 3
    9420:	0e 94 26 47 	call	0x8e4c	; 0x8e4c <DI_State>
    9424:	d8 2e       	mov	r13, r24
    9426:	84 e0       	ldi	r24, 0x04	; 4
    9428:	0e 94 26 47 	call	0x8e4c	; 0x8e4c <DI_State>
    942c:	e8 2e       	mov	r14, r24
    942e:	85 e0       	ldi	r24, 0x05	; 5
    9430:	0e 94 26 47 	call	0x8e4c	; 0x8e4c <DI_State>
    9434:	f8 2e       	mov	r15, r24
    9436:	86 e0       	ldi	r24, 0x06	; 6
    9438:	0e 94 26 47 	call	0x8e4c	; 0x8e4c <DI_State>
    943c:	08 2f       	mov	r16, r24
    943e:	87 e0       	ldi	r24, 0x07	; 7
    9440:	0e 94 26 47 	call	0x8e4c	; 0x8e4c <DI_State>
    9444:	cc 0c       	add	r12, r12
    9446:	11 0f       	add	r17, r17
    9448:	11 0f       	add	r17, r17
    944a:	1c 29       	or	r17, r12
    944c:	1b 29       	or	r17, r11
    944e:	dd 0c       	add	r13, r13
    9450:	dd 0c       	add	r13, r13
    9452:	dd 0c       	add	r13, r13
    9454:	d1 2a       	or	r13, r17
    9456:	e2 94       	swap	r14
    9458:	40 ef       	ldi	r20, 0xF0	; 240
    945a:	e4 22       	and	r14, r20
    945c:	ed 28       	or	r14, r13
    945e:	f2 94       	swap	r15
    9460:	ff 0c       	add	r15, r15
    9462:	30 ee       	ldi	r19, 0xE0	; 224
    9464:	f3 22       	and	r15, r19
    9466:	fe 28       	or	r15, r14
    9468:	02 95       	swap	r16
    946a:	00 0f       	add	r16, r16
    946c:	00 0f       	add	r16, r16
    946e:	00 7c       	andi	r16, 0xC0	; 192
    9470:	0f 29       	or	r16, r15
    9472:	87 95       	ror	r24
    9474:	88 27       	eor	r24, r24
    9476:	87 95       	ror	r24
    9478:	80 2b       	or	r24, r16
    947a:	80 93 46 0a 	sts	0x0A46, r24
	MB_Input[1] = (DI_State(8)<<0)|(DI_State(9)<<1)|(DI_State(10)<<2)|(DI_State(11)<<3)|(DI_State(12)<<4)|(DI_State(13)<<5)|(DI_State(14)<<6)|(DI_State(15)<<7);
    947e:	88 e0       	ldi	r24, 0x08	; 8
    9480:	0e 94 26 47 	call	0x8e4c	; 0x8e4c <DI_State>
    9484:	b8 2e       	mov	r11, r24
    9486:	89 e0       	ldi	r24, 0x09	; 9
    9488:	0e 94 26 47 	call	0x8e4c	; 0x8e4c <DI_State>
    948c:	c8 2e       	mov	r12, r24
    948e:	8a e0       	ldi	r24, 0x0A	; 10
    9490:	0e 94 26 47 	call	0x8e4c	; 0x8e4c <DI_State>
    9494:	18 2f       	mov	r17, r24
    9496:	8b e0       	ldi	r24, 0x0B	; 11
    9498:	0e 94 26 47 	call	0x8e4c	; 0x8e4c <DI_State>
    949c:	d8 2e       	mov	r13, r24
    949e:	8c e0       	ldi	r24, 0x0C	; 12
    94a0:	0e 94 26 47 	call	0x8e4c	; 0x8e4c <DI_State>
    94a4:	e8 2e       	mov	r14, r24
    94a6:	8d e0       	ldi	r24, 0x0D	; 13
    94a8:	0e 94 26 47 	call	0x8e4c	; 0x8e4c <DI_State>
    94ac:	f8 2e       	mov	r15, r24
    94ae:	8e e0       	ldi	r24, 0x0E	; 14
    94b0:	0e 94 26 47 	call	0x8e4c	; 0x8e4c <DI_State>
    94b4:	08 2f       	mov	r16, r24
    94b6:	8f e0       	ldi	r24, 0x0F	; 15
    94b8:	0e 94 26 47 	call	0x8e4c	; 0x8e4c <DI_State>
    94bc:	cc 0c       	add	r12, r12
    94be:	11 0f       	add	r17, r17
    94c0:	11 0f       	add	r17, r17
    94c2:	1c 29       	or	r17, r12
    94c4:	1b 29       	or	r17, r11
    94c6:	dd 0c       	add	r13, r13
    94c8:	dd 0c       	add	r13, r13
    94ca:	dd 0c       	add	r13, r13
    94cc:	d1 2a       	or	r13, r17
    94ce:	e2 94       	swap	r14
    94d0:	20 ef       	ldi	r18, 0xF0	; 240
    94d2:	e2 22       	and	r14, r18
    94d4:	ed 28       	or	r14, r13
    94d6:	f2 94       	swap	r15
    94d8:	ff 0c       	add	r15, r15
    94da:	90 ee       	ldi	r25, 0xE0	; 224
    94dc:	f9 22       	and	r15, r25
    94de:	fe 28       	or	r15, r14
    94e0:	02 95       	swap	r16
    94e2:	00 0f       	add	r16, r16
    94e4:	00 0f       	add	r16, r16
    94e6:	00 7c       	andi	r16, 0xC0	; 192
    94e8:	0f 29       	or	r16, r15
    94ea:	87 95       	ror	r24
    94ec:	88 27       	eor	r24, r24
    94ee:	87 95       	ror	r24
    94f0:	80 2b       	or	r24, r16
    94f2:	80 93 47 0a 	sts	0x0A47, r24
	WriteDigOut(0, (MB_Coil[0])&1);
    94f6:	60 91 bc 07 	lds	r22, 0x07BC
    94fa:	61 70       	andi	r22, 0x01	; 1
    94fc:	80 e0       	ldi	r24, 0x00	; 0
    94fe:	0e 94 f4 49 	call	0x93e8	; 0x93e8 <WriteDigOut>
	WriteDigOut(1, ((MB_Coil[0])&(1<<1))>>1);
    9502:	60 91 bc 07 	lds	r22, 0x07BC
    9506:	70 e0       	ldi	r23, 0x00	; 0
    9508:	62 70       	andi	r22, 0x02	; 2
    950a:	70 70       	andi	r23, 0x00	; 0
    950c:	75 95       	asr	r23
    950e:	67 95       	ror	r22
    9510:	81 e0       	ldi	r24, 0x01	; 1
    9512:	0e 94 f4 49 	call	0x93e8	; 0x93e8 <WriteDigOut>
	WriteDigOut(2, ((MB_Coil[0])&(1<<2))>>2);
    9516:	60 91 bc 07 	lds	r22, 0x07BC
    951a:	70 e0       	ldi	r23, 0x00	; 0
    951c:	64 70       	andi	r22, 0x04	; 4
    951e:	70 70       	andi	r23, 0x00	; 0
    9520:	75 95       	asr	r23
    9522:	67 95       	ror	r22
    9524:	75 95       	asr	r23
    9526:	67 95       	ror	r22
    9528:	82 e0       	ldi	r24, 0x02	; 2
    952a:	0e 94 f4 49 	call	0x93e8	; 0x93e8 <WriteDigOut>
	WriteDigOut(3, ((MB_Coil[0])&(1<<3))>>3);
    952e:	60 91 bc 07 	lds	r22, 0x07BC
    9532:	70 e0       	ldi	r23, 0x00	; 0
    9534:	68 70       	andi	r22, 0x08	; 8
    9536:	70 70       	andi	r23, 0x00	; 0
    9538:	75 95       	asr	r23
    953a:	67 95       	ror	r22
    953c:	75 95       	asr	r23
    953e:	67 95       	ror	r22
    9540:	75 95       	asr	r23
    9542:	67 95       	ror	r22
    9544:	83 e0       	ldi	r24, 0x03	; 3
    9546:	0e 94 f4 49 	call	0x93e8	; 0x93e8 <WriteDigOut>
}
    954a:	1f 91       	pop	r17
    954c:	0f 91       	pop	r16
    954e:	ff 90       	pop	r15
    9550:	ef 90       	pop	r14
    9552:	df 90       	pop	r13
    9554:	cf 90       	pop	r12
    9556:	bf 90       	pop	r11
    9558:	08 95       	ret

0000955a <ApplInit>:

void
ApplInit(void)
{
    955a:	20 91 cd 02 	lds	r18, 0x02CD
    955e:	e6 eb       	ldi	r30, 0xB6	; 182
    9560:	f6 e0       	ldi	r31, 0x06	; 6
    9562:	92 2f       	mov	r25, r18
    9564:	81 e0       	ldi	r24, 0x01	; 1
	for(int i=0; i<16; i++){
		Channels[i].number = i+1;
    9566:	80 83       	st	Z, r24
		Channels[i].timer = Timer16Alloc();
    9568:	93 83       	std	Z+3, r25	; 0x03
    956a:	9f 5f       	subi	r25, 0xFF	; 255
    956c:	34 96       	adiw	r30, 0x04	; 4
    956e:	8f 5f       	subi	r24, 0xFF	; 255
}

void
ApplInit(void)
{
	for(int i=0; i<16; i++){
    9570:	81 31       	cpi	r24, 0x11	; 17
    9572:	c9 f7       	brne	.-14     	; 0x9566 <ApplInit+0xc>
    9574:	20 5f       	subi	r18, 0xF0	; 240
    9576:	20 93 cd 02 	sts	0x02CD, r18
		Channels[i].number = i+1;
		Channels[i].timer = Timer16Alloc();
	}

}
    957a:	08 95       	ret

0000957c <StartKey>:
// ~~~~~~~~~~~
void
StartKey(void)
{	
	
}
    957c:	08 95       	ret

0000957e <StopKey>:
// ~~~~~~~~~~
void
StopKey(void)
{
	
}
    957e:	08 95       	ret

00009580 <Menu_ConfirmationRest_Enter>:
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	//		   
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	uint8_t Menu_ConfirmationRest_Enter(){

		eeprom_write_byte((uint8_t*)E2END, 0xBB);
    9580:	8f ef       	ldi	r24, 0xFF	; 255
    9582:	9f e0       	ldi	r25, 0x0F	; 15
    9584:	6b eb       	ldi	r22, 0xBB	; 187
    9586:	0e 94 3b 8e 	call	0x11c76	; 0x11c76 <__eewr_byte_m2560>
		eeprom_write_byte(&MemCheck_stor.ReprogFlg, 0);
    958a:	8c e9       	ldi	r24, 0x9C	; 156
    958c:	91 e0       	ldi	r25, 0x01	; 1
    958e:	60 e0       	ldi	r22, 0x00	; 0
    9590:	0e 94 3b 8e 	call	0x11c76	; 0x11c76 <__eewr_byte_m2560>
    9594:	ff cf       	rjmp	.-2      	; 0x9594 <Menu_ConfirmationRest_Enter+0x14>

00009596 <Menu_ConfirmationSave_Enter>:
	//		   
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	uint8_t Menu_ConfirmationSave_Enter(){

		//  backup-
		eeprom_write_byte((uint8_t*)E2END, 0xAA);
    9596:	8f ef       	ldi	r24, 0xFF	; 255
    9598:	9f e0       	ldi	r25, 0x0F	; 15
    959a:	6a ea       	ldi	r22, 0xAA	; 170
    959c:	0e 94 3b 8e 	call	0x11c76	; 0x11c76 <__eewr_byte_m2560>
		eeprom_write_byte(&DateBackUp.Day, Tm_MDay);
    95a0:	80 e0       	ldi	r24, 0x00	; 0
    95a2:	90 e0       	ldi	r25, 0x00	; 0
    95a4:	60 91 5f 0b 	lds	r22, 0x0B5F
    95a8:	0e 94 3b 8e 	call	0x11c76	; 0x11c76 <__eewr_byte_m2560>
		eeprom_write_byte(&DateBackUp.Month, Tm_Mon);
    95ac:	81 e0       	ldi	r24, 0x01	; 1
    95ae:	90 e0       	ldi	r25, 0x00	; 0
    95b0:	60 91 cc 07 	lds	r22, 0x07CC
    95b4:	0e 94 3b 8e 	call	0x11c76	; 0x11c76 <__eewr_byte_m2560>
		#ifdef M41T56
			eeprom_write_byte(&DateBackUp.Year, Tm_Year);
    95b8:	82 e0       	ldi	r24, 0x02	; 2
    95ba:	90 e0       	ldi	r25, 0x00	; 0
    95bc:	60 91 de 05 	lds	r22, 0x05DE
    95c0:	0e 94 3b 8e 	call	0x11c76	; 0x11c76 <__eewr_byte_m2560>
		#else
			eeprom_write_byte(&DateBackUp.Year, erb(&Tm_Year));
		#endif
		eeprom_write_byte(&MemCheck_stor.ReprogFlg, 0);
    95c4:	8c e9       	ldi	r24, 0x9C	; 156
    95c6:	91 e0       	ldi	r25, 0x01	; 1
    95c8:	60 e0       	ldi	r22, 0x00	; 0
    95ca:	0e 94 3b 8e 	call	0x11c76	; 0x11c76 <__eewr_byte_m2560>
    95ce:	ff cf       	rjmp	.-2      	; 0x95ce <Menu_ConfirmationSave_Enter+0x38>

000095d0 <GSM_SendData>:
	GSMTxSz = Size;
	memcpy(GSM_TxStr, Data_Out, GSMTxSz);
	GSM_SendFirstChar();
}
// ~~~~~~~~~
void GSM_SendData(uint8_t *Data_Out, uint8_t Size){
    95d0:	58 2f       	mov	r21, r24
    95d2:	79 2f       	mov	r23, r25
	GSMTxSz = Size;
    95d4:	60 93 bb 07 	sts	0x07BB, r22
	memcpy(GSM_TxStr, Data_Out, GSMTxSz);
    95d8:	40 91 bb 07 	lds	r20, 0x07BB
    95dc:	2a e4       	ldi	r18, 0x4A	; 74
    95de:	3a e0       	ldi	r19, 0x0A	; 10
    95e0:	c9 01       	movw	r24, r18
    95e2:	65 2f       	mov	r22, r21
    95e4:	50 e0       	ldi	r21, 0x00	; 0
    95e6:	0e 94 3f 8b 	call	0x1167e	; 0x1167e <memcpy>
	GSM_SendFirstChar();
    95ea:	0e 94 3a 43 	call	0x8674	; 0x8674 <GSM_SendFirstChar>
}
    95ee:	08 95       	ret

000095f0 <GSM_AddHeaderSendData>:
	GSMTxSz++;
	GSM_SendFirstChar();
}
// ~~~~~~~~~
//   + CntrZ
void GSM_AddHeaderSendData(uint8_t *Data_Out, uint8_t Size){
    95f0:	58 2f       	mov	r21, r24
    95f2:	79 2f       	mov	r23, r25
	GSMTxSz = Size;
    95f4:	60 93 bb 07 	sts	0x07BB, r22
	memcpy(GSM_TxStr, Data_Out, GSMTxSz);
    95f8:	40 91 bb 07 	lds	r20, 0x07BB
    95fc:	2a e4       	ldi	r18, 0x4A	; 74
    95fe:	3a e0       	ldi	r19, 0x0A	; 10
    9600:	c9 01       	movw	r24, r18
    9602:	65 2f       	mov	r22, r21
    9604:	50 e0       	ldi	r21, 0x00	; 0
    9606:	0e 94 3f 8b 	call	0x1167e	; 0x1167e <memcpy>
	GSM_SendFirstChar();
    960a:	0e 94 3a 43 	call	0x8674	; 0x8674 <GSM_SendFirstChar>
}
    960e:	08 95       	ret

00009610 <PresicionHanler>:
		ew##ty3((ty2*)Var, Min);						\
	else																	\
		ew##ty3((ty2*)Var, (ty2)Buf)
// ~~~~~~~~~~~~~~~~~~~~~~~
//Change BufStr due to precision for correct sscanf reading BufStr
void PresicionHanler(OutField *Field){
    9610:	cf 93       	push	r28
    9612:	df 93       	push	r29

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    9614:	ec 01       	movw	r28, r24
    9616:	2f 96       	adiw	r28, 0x0f	; 15
    9618:	fe 01       	movw	r30, r28
    961a:	84 91       	lpm	r24, Z+
	if(prb(&Field->Prec)){
    961c:	88 23       	and	r24, r24
    961e:	19 f4       	brne	.+6      	; 0x9626 <PresicionHanler+0x16>
			}
			p++;
		}
	}
	
}
    9620:	df 91       	pop	r29
    9622:	cf 91       	pop	r28
    9624:	08 95       	ret
		ew##ty3((ty2*)Var, (ty2)Buf)
// ~~~~~~~~~~~~~~~~~~~~~~~
//Change BufStr due to precision for correct sscanf reading BufStr
void PresicionHanler(OutField *Field){
	if(prb(&Field->Prec)){
		char *p = strchr(BufStr,'.');	//seek for first decimal point
    9626:	83 ec       	ldi	r24, 0xC3	; 195
    9628:	95 e0       	ldi	r25, 0x05	; 5
    962a:	6e e2       	ldi	r22, 0x2E	; 46
    962c:	70 e0       	ldi	r23, 0x00	; 0
    962e:	0e 94 48 8b 	call	0x11690	; 0x11690 <strchr>
		if(p==NULL){
    9632:	00 97       	sbiw	r24, 0x00	; 0
    9634:	01 f1       	breq	.+64     	; 0x9676 <PresicionHanler+0x66>
    9636:	fe 01       	movw	r30, r28
    9638:	24 91       	lpm	r18, Z+
			p = strchr(BufStr,' ');	//else seek for first space
		}
	  	for(uint8_t i=0; i<prb(&Field->Prec); i++){
    963a:	22 23       	and	r18, r18
    963c:	89 f3       	breq	.-30     	; 0x9620 <PresicionHanler+0x10>
    963e:	fc 01       	movw	r30, r24
    9640:	dc 01       	movw	r26, r24
    9642:	11 96       	adiw	r26, 0x01	; 1
    9644:	30 e0       	ldi	r19, 0x00	; 0
			if(*p == '.'){
				if(isdigit(*(p+1))){
					*p= *(p+1);
					*(p+1) = '.';
				}
				else *p='0'; 
    9646:	60 e3       	ldi	r22, 0x30	; 48
    9648:	52 2f       	mov	r21, r18
    964a:	07 c0       	rjmp	.+14     	; 0x965a <PresicionHanler+0x4a>
		if(p==NULL){
			p = strchr(BufStr,' ');	//else seek for first space
		}
	  	for(uint8_t i=0; i<prb(&Field->Prec); i++){
			if(*p == ' ') *p='0'; 
			if(*p == '.'){
    964c:	2e 32       	cpi	r18, 0x2E	; 46
    964e:	51 f0       	breq	.+20     	; 0x9664 <PresicionHanler+0x54>
	if(prb(&Field->Prec)){
		char *p = strchr(BufStr,'.');	//seek for first decimal point
		if(p==NULL){
			p = strchr(BufStr,' ');	//else seek for first space
		}
	  	for(uint8_t i=0; i<prb(&Field->Prec); i++){
    9650:	3f 5f       	subi	r19, 0xFF	; 255
    9652:	31 96       	adiw	r30, 0x01	; 1
    9654:	11 96       	adiw	r26, 0x01	; 1
    9656:	35 17       	cp	r19, r21
    9658:	18 f7       	brcc	.-58     	; 0x9620 <PresicionHanler+0x10>
			if(*p == ' ') *p='0'; 
    965a:	20 81       	ld	r18, Z
    965c:	20 32       	cpi	r18, 0x20	; 32
    965e:	b1 f7       	brne	.-20     	; 0x964c <PresicionHanler+0x3c>
			if(*p == '.'){
				if(isdigit(*(p+1))){
					*p= *(p+1);
					*(p+1) = '.';
				}
				else *p='0'; 
    9660:	60 83       	st	Z, r22
    9662:	f6 cf       	rjmp	.-20     	; 0x9650 <PresicionHanler+0x40>
			p = strchr(BufStr,' ');	//else seek for first space
		}
	  	for(uint8_t i=0; i<prb(&Field->Prec); i++){
			if(*p == ' ') *p='0'; 
			if(*p == '.'){
				if(isdigit(*(p+1))){
    9664:	4c 91       	ld	r20, X
    9666:	84 2f       	mov	r24, r20
    9668:	90 e0       	ldi	r25, 0x00	; 0
    966a:	c0 97       	sbiw	r24, 0x30	; 48
    966c:	0a 97       	sbiw	r24, 0x0a	; 10
    966e:	c0 f7       	brcc	.-16     	; 0x9660 <PresicionHanler+0x50>
					*p= *(p+1);
    9670:	40 83       	st	Z, r20
					*(p+1) = '.';
    9672:	2c 93       	st	X, r18
    9674:	ed cf       	rjmp	.-38     	; 0x9650 <PresicionHanler+0x40>
//Change BufStr due to precision for correct sscanf reading BufStr
void PresicionHanler(OutField *Field){
	if(prb(&Field->Prec)){
		char *p = strchr(BufStr,'.');	//seek for first decimal point
		if(p==NULL){
			p = strchr(BufStr,' ');	//else seek for first space
    9676:	83 ec       	ldi	r24, 0xC3	; 195
    9678:	95 e0       	ldi	r25, 0x05	; 5
    967a:	60 e2       	ldi	r22, 0x20	; 32
    967c:	70 e0       	ldi	r23, 0x00	; 0
    967e:	0e 94 48 8b 	call	0x11690	; 0x11690 <strchr>
    9682:	d9 cf       	rjmp	.-78     	; 0x9636 <PresicionHanler+0x26>

00009684 <GetMultiSymbol>:
	}
	return 0;
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~
//    MultiSymbol   
uint8_t GetMultiSymbol(PGM_P Str_P, char Char){
    9684:	1f 93       	push	r17
    9686:	18 2f       	mov	r17, r24
	PGM_P ptr_P= strchr_P(Str_P, Char);
    9688:	70 e0       	ldi	r23, 0x00	; 0
    968a:	0e 94 e8 8a 	call	0x115d0	; 0x115d0 <strchr_P>
	if(ptr_P) return (uint8_t)(ptr_P - Str_P);
    968e:	00 97       	sbiw	r24, 0x00	; 0
    9690:	19 f0       	breq	.+6      	; 0x9698 <GetMultiSymbol+0x14>
    9692:	81 1b       	sub	r24, r17
	else return 0;
}
    9694:	1f 91       	pop	r17
    9696:	08 95       	ret
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~
//    MultiSymbol   
uint8_t GetMultiSymbol(PGM_P Str_P, char Char){
	PGM_P ptr_P= strchr_P(Str_P, Char);
	if(ptr_P) return (uint8_t)(ptr_P - Str_P);
    9698:	80 e0       	ldi	r24, 0x00	; 0
	else return 0;
}
    969a:	1f 91       	pop	r17
    969c:	08 95       	ret

0000969e <PutEnum>:
} T_Param;

// ~~~~~~~~~~~~~~~~~~~~
void
PutEnum(T_Param *Param)
{
    969e:	0f 93       	push	r16
    96a0:	1f 93       	push	r17
    96a2:	cf 93       	push	r28
    96a4:	df 93       	push	r29
    96a6:	8c 01       	movw	r16, r24

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    96a8:	dc 01       	movw	r26, r24
    96aa:	14 96       	adiw	r26, 0x04	; 4
    96ac:	ed 91       	ld	r30, X+
    96ae:	fc 91       	ld	r31, X
    96b0:	15 97       	sbiw	r26, 0x05	; 5
    96b2:	65 91       	lpm	r22, Z+
    96b4:	74 91       	lpm	r23, Z+
	strcpy_P(Param->Pos, prp(Param->Txt));
    96b6:	8d 91       	ld	r24, X+
    96b8:	9c 91       	ld	r25, X
    96ba:	0e 94 fc 8a 	call	0x115f8	; 0x115f8 <strcpy_P>
	for(uint8_t i=strlen(Param->Pos); i<Param->Size; *(Param->Pos+i++)=' ');
    96be:	f8 01       	movw	r30, r16
    96c0:	c0 81       	ld	r28, Z
    96c2:	d1 81       	ldd	r29, Z+1	; 0x01
    96c4:	fe 01       	movw	r30, r28
    96c6:	01 90       	ld	r0, Z+
    96c8:	00 20       	and	r0, r0
    96ca:	e9 f7       	brne	.-6      	; 0x96c6 <PutEnum+0x28>
    96cc:	31 97       	sbiw	r30, 0x01	; 1
    96ce:	ec 1b       	sub	r30, r28
    96d0:	d8 01       	movw	r26, r16
    96d2:	13 96       	adiw	r26, 0x03	; 3
    96d4:	8c 91       	ld	r24, X
    96d6:	e8 17       	cp	r30, r24
    96d8:	70 f4       	brcc	.+28     	; 0x96f6 <PutEnum+0x58>
    96da:	90 e2       	ldi	r25, 0x20	; 32
    96dc:	02 c0       	rjmp	.+4      	; 0x96e2 <PutEnum+0x44>
    96de:	cd 91       	ld	r28, X+
    96e0:	dc 91       	ld	r29, X
    96e2:	ce 0f       	add	r28, r30
    96e4:	d1 1d       	adc	r29, r1
    96e6:	98 83       	st	Y, r25
    96e8:	ef 5f       	subi	r30, 0xFF	; 255
    96ea:	d8 01       	movw	r26, r16
    96ec:	13 96       	adiw	r26, 0x03	; 3
    96ee:	8c 91       	ld	r24, X
    96f0:	13 97       	sbiw	r26, 0x03	; 3
    96f2:	e8 17       	cp	r30, r24
    96f4:	a0 f3       	brcs	.-24     	; 0x96de <PutEnum+0x40>
}
    96f6:	df 91       	pop	r29
    96f8:	cf 91       	pop	r28
    96fa:	1f 91       	pop	r17
    96fc:	0f 91       	pop	r16
    96fe:	08 95       	ret

00009700 <Put_sbVal>:
}

// ~~~~~~~~~~~~~~~~~~~~~~
void
Put_sbVal(T_Param *Param)
{
    9700:	6f 92       	push	r6
    9702:	7f 92       	push	r7
    9704:	8f 92       	push	r8
    9706:	9f 92       	push	r9
    9708:	af 92       	push	r10
    970a:	bf 92       	push	r11
    970c:	cf 92       	push	r12
    970e:	df 92       	push	r13
    9710:	ef 92       	push	r14
    9712:	ff 92       	push	r15
    9714:	0f 93       	push	r16
    9716:	1f 93       	push	r17
    9718:	df 93       	push	r29
    971a:	cf 93       	push	r28
    971c:	cd b7       	in	r28, 0x3d	; 61
    971e:	de b7       	in	r29, 0x3e	; 62
    9720:	2c 97       	sbiw	r28, 0x0c	; 12
    9722:	0f b6       	in	r0, 0x3f	; 63
    9724:	f8 94       	cli
    9726:	de bf       	out	0x3e, r29	; 62
    9728:	0f be       	out	0x3f, r0	; 63
    972a:	cd bf       	out	0x3d, r28	; 61
    972c:	5c 01       	movw	r10, r24
	char Format[] = "%0+ li.%. u";
    972e:	be 01       	movw	r22, r28
    9730:	6f 5f       	subi	r22, 0xFF	; 255
    9732:	7f 4f       	sbci	r23, 0xFF	; 255
    9734:	db 01       	movw	r26, r22
    9736:	e0 e0       	ldi	r30, 0x00	; 0
    9738:	f2 e0       	ldi	r31, 0x02	; 2
    973a:	8c e0       	ldi	r24, 0x0C	; 12
    973c:	01 90       	ld	r0, Z+
    973e:	0d 92       	st	X+, r0
    9740:	81 50       	subi	r24, 0x01	; 1
    9742:	e1 f7       	brne	.-8      	; 0x973c <Put_sbVal+0x3c>
	Format[3] = '0'+Param->Size;
    9744:	d5 01       	movw	r26, r10
    9746:	13 96       	adiw	r26, 0x03	; 3
    9748:	2c 91       	ld	r18, X
    974a:	13 97       	sbiw	r26, 0x03	; 3
    974c:	20 5d       	subi	r18, 0xD0	; 208
    974e:	2c 83       	std	Y+4, r18	; 0x04
	if(Param->Prec) {
    9750:	12 96       	adiw	r26, 0x02	; 2
    9752:	9c 91       	ld	r25, X
    9754:	99 23       	and	r25, r25
    9756:	09 f4       	brne	.+2      	; 0x975a <Put_sbVal+0x5a>
    9758:	8d c0       	rjmp	.+282    	; 0x9874 <Put_sbVal+0x174>
		Format[3] -= Param->Prec+1;
    975a:	89 2f       	mov	r24, r25
    975c:	80 95       	com	r24
    975e:	82 0f       	add	r24, r18
    9760:	8c 83       	std	Y+4, r24	; 0x04
		Format[9] = '0'+Param->Prec;
    9762:	90 5d       	subi	r25, 0xD0	; 208
    9764:	9a 87       	std	Y+10, r25	; 0x0a
    9766:	90 53       	subi	r25, 0x30	; 48
		int16_t Div=Pow10(Param->Prec);
    9768:	49 2f       	mov	r20, r25
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    976a:	21 e0       	ldi	r18, 0x01	; 1
    976c:	30 e0       	ldi	r19, 0x00	; 0
		Pow *= 10;
    976e:	c9 01       	movw	r24, r18
    9770:	88 0f       	add	r24, r24
    9772:	99 1f       	adc	r25, r25
    9774:	22 0f       	add	r18, r18
    9776:	33 1f       	adc	r19, r19
    9778:	22 0f       	add	r18, r18
    977a:	33 1f       	adc	r19, r19
    977c:	22 0f       	add	r18, r18
    977e:	33 1f       	adc	r19, r19
    9780:	28 0f       	add	r18, r24
    9782:	39 1f       	adc	r19, r25
    9784:	41 50       	subi	r20, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    9786:	99 f7       	brne	.-26     	; 0x976e <Put_sbVal+0x6e>
    9788:	39 01       	movw	r6, r18
    978a:	88 24       	eor	r8, r8
    978c:	77 fc       	sbrc	r7, 7
    978e:	80 94       	com	r8
    9790:	98 2c       	mov	r9, r8
		sprintf(Param->Pos, Format, sF_Buf/Div, (uint32_t)labs(sF_Buf)%Div);
    9792:	10 91 fb 04 	lds	r17, 0x04FB
    9796:	00 91 fc 04 	lds	r16, 0x04FC
    979a:	f0 90 fd 04 	lds	r15, 0x04FD
    979e:	e0 90 fe 04 	lds	r14, 0x04FE
    97a2:	ed b7       	in	r30, 0x3d	; 61
    97a4:	fe b7       	in	r31, 0x3e	; 62
    97a6:	3c 97       	sbiw	r30, 0x0c	; 12
    97a8:	0f b6       	in	r0, 0x3f	; 63
    97aa:	f8 94       	cli
    97ac:	fe bf       	out	0x3e, r31	; 62
    97ae:	0f be       	out	0x3f, r0	; 63
    97b0:	ed bf       	out	0x3d, r30	; 61
    97b2:	cd b6       	in	r12, 0x3d	; 61
    97b4:	de b6       	in	r13, 0x3e	; 62
    97b6:	08 94       	sec
    97b8:	c1 1c       	adc	r12, r1
    97ba:	d1 1c       	adc	r13, r1
    97bc:	d5 01       	movw	r26, r10
    97be:	8d 91       	ld	r24, X+
    97c0:	9c 91       	ld	r25, X
    97c2:	92 83       	std	Z+2, r25	; 0x02
    97c4:	81 83       	std	Z+1, r24	; 0x01
    97c6:	f6 01       	movw	r30, r12
    97c8:	73 83       	std	Z+3, r23	; 0x03
    97ca:	62 83       	std	Z+2, r22	; 0x02
    97cc:	61 2f       	mov	r22, r17
    97ce:	70 2f       	mov	r23, r16
    97d0:	8f 2d       	mov	r24, r15
    97d2:	9e 2d       	mov	r25, r14
    97d4:	a4 01       	movw	r20, r8
    97d6:	93 01       	movw	r18, r6
    97d8:	0e 94 cd 8e 	call	0x11d9a	; 0x11d9a <__divmodsi4>
    97dc:	d6 01       	movw	r26, r12
    97de:	14 96       	adiw	r26, 0x04	; 4
    97e0:	2d 93       	st	X+, r18
    97e2:	3d 93       	st	X+, r19
    97e4:	4d 93       	st	X+, r20
    97e6:	5c 93       	st	X, r21
    97e8:	17 97       	sbiw	r26, 0x07	; 7
    97ea:	21 2f       	mov	r18, r17
    97ec:	30 2f       	mov	r19, r16
    97ee:	4f 2d       	mov	r20, r15
    97f0:	5e 2d       	mov	r21, r14
    97f2:	c9 01       	movw	r24, r18
    97f4:	da 01       	movw	r26, r20
    97f6:	bc 01       	movw	r22, r24
    97f8:	cd 01       	movw	r24, r26
    97fa:	97 fd       	sbrc	r25, 7
    97fc:	77 c0       	rjmp	.+238    	; 0x98ec <Put_sbVal+0x1ec>
    97fe:	a4 01       	movw	r20, r8
    9800:	93 01       	movw	r18, r6
    9802:	0e 94 ab 8e 	call	0x11d56	; 0x11d56 <__udivmodsi4>
    9806:	f6 01       	movw	r30, r12
    9808:	60 87       	std	Z+8, r22	; 0x08
    980a:	71 87       	std	Z+9, r23	; 0x09
    980c:	82 87       	std	Z+10, r24	; 0x0a
    980e:	93 87       	std	Z+11, r25	; 0x0b
    9810:	0e 94 ef 8b 	call	0x117de	; 0x117de <sprintf>
		if(sF_Buf<0) {
    9814:	8d b7       	in	r24, 0x3d	; 61
    9816:	9e b7       	in	r25, 0x3e	; 62
    9818:	0c 96       	adiw	r24, 0x0c	; 12
    981a:	0f b6       	in	r0, 0x3f	; 63
    981c:	f8 94       	cli
    981e:	9e bf       	out	0x3e, r25	; 62
    9820:	0f be       	out	0x3f, r0	; 63
    9822:	8d bf       	out	0x3d, r24	; 61
    9824:	80 91 fb 04 	lds	r24, 0x04FB
    9828:	90 91 fc 04 	lds	r25, 0x04FC
    982c:	a0 91 fd 04 	lds	r26, 0x04FD
    9830:	b0 91 fe 04 	lds	r27, 0x04FE
    9834:	b7 fd       	sbrc	r27, 7
    9836:	4a c0       	rjmp	.+148    	; 0x98cc <Put_sbVal+0x1cc>
	}
	else {
		Format[6] = '\0';
		sprintf(Param->Pos, Format, sF_Buf);
	}
	if(Minus)
    9838:	80 91 ff 04 	lds	r24, 0x04FF
    983c:	88 23       	and	r24, r24
    983e:	29 f0       	breq	.+10     	; 0x984a <Put_sbVal+0x14a>
		*Param->Pos = '-';
    9840:	d5 01       	movw	r26, r10
    9842:	ed 91       	ld	r30, X+
    9844:	fc 91       	ld	r31, X
    9846:	8d e2       	ldi	r24, 0x2D	; 45
    9848:	80 83       	st	Z, r24
}
    984a:	2c 96       	adiw	r28, 0x0c	; 12
    984c:	0f b6       	in	r0, 0x3f	; 63
    984e:	f8 94       	cli
    9850:	de bf       	out	0x3e, r29	; 62
    9852:	0f be       	out	0x3f, r0	; 63
    9854:	cd bf       	out	0x3d, r28	; 61
    9856:	cf 91       	pop	r28
    9858:	df 91       	pop	r29
    985a:	1f 91       	pop	r17
    985c:	0f 91       	pop	r16
    985e:	ff 90       	pop	r15
    9860:	ef 90       	pop	r14
    9862:	df 90       	pop	r13
    9864:	cf 90       	pop	r12
    9866:	bf 90       	pop	r11
    9868:	af 90       	pop	r10
    986a:	9f 90       	pop	r9
    986c:	8f 90       	pop	r8
    986e:	7f 90       	pop	r7
    9870:	6f 90       	pop	r6
    9872:	08 95       	ret
				Param->Pos++;
			*Param->Pos = '-';
		}
	}
	else {
		Format[6] = '\0';
    9874:	1f 82       	std	Y+7, r1	; 0x07
		sprintf(Param->Pos, Format, sF_Buf);
    9876:	ed b7       	in	r30, 0x3d	; 61
    9878:	fe b7       	in	r31, 0x3e	; 62
    987a:	38 97       	sbiw	r30, 0x08	; 8
    987c:	0f b6       	in	r0, 0x3f	; 63
    987e:	f8 94       	cli
    9880:	fe bf       	out	0x3e, r31	; 62
    9882:	0f be       	out	0x3f, r0	; 63
    9884:	ed bf       	out	0x3d, r30	; 61
    9886:	31 96       	adiw	r30, 0x01	; 1
    9888:	d5 01       	movw	r26, r10
    988a:	8d 91       	ld	r24, X+
    988c:	9c 91       	ld	r25, X
    988e:	ad b7       	in	r26, 0x3d	; 61
    9890:	be b7       	in	r27, 0x3e	; 62
    9892:	12 96       	adiw	r26, 0x02	; 2
    9894:	9c 93       	st	X, r25
    9896:	8e 93       	st	-X, r24
    9898:	11 97       	sbiw	r26, 0x01	; 1
    989a:	73 83       	std	Z+3, r23	; 0x03
    989c:	62 83       	std	Z+2, r22	; 0x02
    989e:	80 91 fb 04 	lds	r24, 0x04FB
    98a2:	90 91 fc 04 	lds	r25, 0x04FC
    98a6:	a0 91 fd 04 	lds	r26, 0x04FD
    98aa:	b0 91 fe 04 	lds	r27, 0x04FE
    98ae:	84 83       	std	Z+4, r24	; 0x04
    98b0:	95 83       	std	Z+5, r25	; 0x05
    98b2:	a6 83       	std	Z+6, r26	; 0x06
    98b4:	b7 83       	std	Z+7, r27	; 0x07
    98b6:	0e 94 ef 8b 	call	0x117de	; 0x117de <sprintf>
    98ba:	ed b7       	in	r30, 0x3d	; 61
    98bc:	fe b7       	in	r31, 0x3e	; 62
    98be:	38 96       	adiw	r30, 0x08	; 8
    98c0:	0f b6       	in	r0, 0x3f	; 63
    98c2:	f8 94       	cli
    98c4:	fe bf       	out	0x3e, r31	; 62
    98c6:	0f be       	out	0x3f, r0	; 63
    98c8:	ed bf       	out	0x3d, r30	; 61
    98ca:	b6 cf       	rjmp	.-148    	; 0x9838 <Put_sbVal+0x138>
		Format[3] -= Param->Prec+1;
		Format[9] = '0'+Param->Prec;
		int16_t Div=Pow10(Param->Prec);
		sprintf(Param->Pos, Format, sF_Buf/Div, (uint32_t)labs(sF_Buf)%Div);
		if(sF_Buf<0) {
			while(*Param->Pos==' ')
    98cc:	d5 01       	movw	r26, r10
    98ce:	ed 91       	ld	r30, X+
    98d0:	fc 91       	ld	r31, X
    98d2:	80 81       	ld	r24, Z
    98d4:	80 32       	cpi	r24, 0x20	; 32
    98d6:	39 f4       	brne	.+14     	; 0x98e6 <Put_sbVal+0x1e6>
				Param->Pos++;
    98d8:	31 96       	adiw	r30, 0x01	; 1
    98da:	d5 01       	movw	r26, r10
    98dc:	ed 93       	st	X+, r30
    98de:	fc 93       	st	X, r31
		Format[3] -= Param->Prec+1;
		Format[9] = '0'+Param->Prec;
		int16_t Div=Pow10(Param->Prec);
		sprintf(Param->Pos, Format, sF_Buf/Div, (uint32_t)labs(sF_Buf)%Div);
		if(sF_Buf<0) {
			while(*Param->Pos==' ')
    98e0:	80 81       	ld	r24, Z
    98e2:	80 32       	cpi	r24, 0x20	; 32
    98e4:	c9 f3       	breq	.-14     	; 0x98d8 <Put_sbVal+0x1d8>
				Param->Pos++;
			*Param->Pos = '-';
    98e6:	8d e2       	ldi	r24, 0x2D	; 45
    98e8:	80 83       	st	Z, r24
    98ea:	a6 cf       	rjmp	.-180    	; 0x9838 <Put_sbVal+0x138>
	Format[3] = '0'+Param->Size;
	if(Param->Prec) {
		Format[3] -= Param->Prec+1;
		Format[9] = '0'+Param->Prec;
		int16_t Div=Pow10(Param->Prec);
		sprintf(Param->Pos, Format, sF_Buf/Div, (uint32_t)labs(sF_Buf)%Div);
    98ec:	90 95       	com	r25
    98ee:	80 95       	com	r24
    98f0:	70 95       	com	r23
    98f2:	61 95       	neg	r22
    98f4:	7f 4f       	sbci	r23, 0xFF	; 255
    98f6:	8f 4f       	sbci	r24, 0xFF	; 255
    98f8:	9f 4f       	sbci	r25, 0xFF	; 255
    98fa:	81 cf       	rjmp	.-254    	; 0x97fe <Put_sbVal+0xfe>

000098fc <Put_bVal>:
}

// ~~~~~~~~~~~~~~~~~~~~~
void
Put_bVal(T_Param *Param)
{
    98fc:	6f 92       	push	r6
    98fe:	7f 92       	push	r7
    9900:	8f 92       	push	r8
    9902:	9f 92       	push	r9
    9904:	af 92       	push	r10
    9906:	bf 92       	push	r11
    9908:	cf 92       	push	r12
    990a:	df 92       	push	r13
    990c:	ef 92       	push	r14
    990e:	ff 92       	push	r15
    9910:	0f 93       	push	r16
    9912:	1f 93       	push	r17
    9914:	df 93       	push	r29
    9916:	cf 93       	push	r28
    9918:	cd b7       	in	r28, 0x3d	; 61
    991a:	de b7       	in	r29, 0x3e	; 62
    991c:	2b 97       	sbiw	r28, 0x0b	; 11
    991e:	0f b6       	in	r0, 0x3f	; 63
    9920:	f8 94       	cli
    9922:	de bf       	out	0x3e, r29	; 62
    9924:	0f be       	out	0x3f, r0	; 63
    9926:	cd bf       	out	0x3d, r28	; 61
    9928:	bc 01       	movw	r22, r24
	char Format[] = "%0 li.%. u";
    992a:	3e 01       	movw	r6, r28
    992c:	08 94       	sec
    992e:	61 1c       	adc	r6, r1
    9930:	71 1c       	adc	r7, r1
    9932:	d3 01       	movw	r26, r6
    9934:	ec e0       	ldi	r30, 0x0C	; 12
    9936:	f2 e0       	ldi	r31, 0x02	; 2
    9938:	8b e0       	ldi	r24, 0x0B	; 11
    993a:	01 90       	ld	r0, Z+
    993c:	0d 92       	st	X+, r0
    993e:	81 50       	subi	r24, 0x01	; 1
    9940:	e1 f7       	brne	.-8      	; 0x993a <Put_bVal+0x3e>
	Format[2] = '0'+Param->Size;
    9942:	db 01       	movw	r26, r22
    9944:	13 96       	adiw	r26, 0x03	; 3
    9946:	2c 91       	ld	r18, X
    9948:	13 97       	sbiw	r26, 0x03	; 3
    994a:	20 5d       	subi	r18, 0xD0	; 208
    994c:	2b 83       	std	Y+3, r18	; 0x03
	if(Param->Prec) {
    994e:	12 96       	adiw	r26, 0x02	; 2
    9950:	9c 91       	ld	r25, X
    9952:	99 23       	and	r25, r25
    9954:	09 f4       	brne	.+2      	; 0x9958 <Put_bVal+0x5c>
    9956:	6d c0       	rjmp	.+218    	; 0x9a32 <Put_bVal+0x136>
		Format[2] -= Param->Prec+1;
    9958:	89 2f       	mov	r24, r25
    995a:	80 95       	com	r24
    995c:	82 0f       	add	r24, r18
    995e:	8b 83       	std	Y+3, r24	; 0x03
		Format[8] = '0'+Param->Prec;
    9960:	90 5d       	subi	r25, 0xD0	; 208
    9962:	99 87       	std	Y+9, r25	; 0x09
    9964:	90 53       	subi	r25, 0x30	; 48
		uint16_t Div=Pow10(Param->Prec);
    9966:	49 2f       	mov	r20, r25
    9968:	21 e0       	ldi	r18, 0x01	; 1
    996a:	30 e0       	ldi	r19, 0x00	; 0
		Pow *= 10;
    996c:	c9 01       	movw	r24, r18
    996e:	88 0f       	add	r24, r24
    9970:	99 1f       	adc	r25, r25
    9972:	22 0f       	add	r18, r18
    9974:	33 1f       	adc	r19, r19
    9976:	22 0f       	add	r18, r18
    9978:	33 1f       	adc	r19, r19
    997a:	22 0f       	add	r18, r18
    997c:	33 1f       	adc	r19, r19
    997e:	28 0f       	add	r18, r24
    9980:	39 1f       	adc	r19, r25
    9982:	41 50       	subi	r20, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    9984:	99 f7       	brne	.-26     	; 0x996c <Put_bVal+0x70>
    9986:	49 01       	movw	r8, r18
    9988:	aa 24       	eor	r10, r10
    998a:	bb 24       	eor	r11, r11
		sprintf(Param->Pos, Format, F_Buf/Div, F_Buf%Div);
    998c:	c0 90 f7 04 	lds	r12, 0x04F7
    9990:	d0 90 f8 04 	lds	r13, 0x04F8
    9994:	e0 90 f9 04 	lds	r14, 0x04F9
    9998:	f0 90 fa 04 	lds	r15, 0x04FA
    999c:	ed b7       	in	r30, 0x3d	; 61
    999e:	fe b7       	in	r31, 0x3e	; 62
    99a0:	3c 97       	sbiw	r30, 0x0c	; 12
    99a2:	0f b6       	in	r0, 0x3f	; 63
    99a4:	f8 94       	cli
    99a6:	fe bf       	out	0x3e, r31	; 62
    99a8:	0f be       	out	0x3f, r0	; 63
    99aa:	ed bf       	out	0x3d, r30	; 61
    99ac:	0d b7       	in	r16, 0x3d	; 61
    99ae:	1e b7       	in	r17, 0x3e	; 62
    99b0:	0f 5f       	subi	r16, 0xFF	; 255
    99b2:	1f 4f       	sbci	r17, 0xFF	; 255
    99b4:	db 01       	movw	r26, r22
    99b6:	8d 91       	ld	r24, X+
    99b8:	9c 91       	ld	r25, X
    99ba:	92 83       	std	Z+2, r25	; 0x02
    99bc:	81 83       	std	Z+1, r24	; 0x01
    99be:	f8 01       	movw	r30, r16
    99c0:	73 82       	std	Z+3, r7	; 0x03
    99c2:	62 82       	std	Z+2, r6	; 0x02
    99c4:	c7 01       	movw	r24, r14
    99c6:	b6 01       	movw	r22, r12
    99c8:	a5 01       	movw	r20, r10
    99ca:	94 01       	movw	r18, r8
    99cc:	0e 94 ab 8e 	call	0x11d56	; 0x11d56 <__udivmodsi4>
    99d0:	d8 01       	movw	r26, r16
    99d2:	14 96       	adiw	r26, 0x04	; 4
    99d4:	2d 93       	st	X+, r18
    99d6:	3d 93       	st	X+, r19
    99d8:	4d 93       	st	X+, r20
    99da:	5c 93       	st	X, r21
    99dc:	17 97       	sbiw	r26, 0x07	; 7
    99de:	c7 01       	movw	r24, r14
    99e0:	b6 01       	movw	r22, r12
    99e2:	a5 01       	movw	r20, r10
    99e4:	94 01       	movw	r18, r8
    99e6:	0e 94 ab 8e 	call	0x11d56	; 0x11d56 <__udivmodsi4>
    99ea:	f8 01       	movw	r30, r16
    99ec:	60 87       	std	Z+8, r22	; 0x08
    99ee:	71 87       	std	Z+9, r23	; 0x09
    99f0:	82 87       	std	Z+10, r24	; 0x0a
    99f2:	93 87       	std	Z+11, r25	; 0x0b
    99f4:	0e 94 ef 8b 	call	0x117de	; 0x117de <sprintf>
    99f8:	8d b7       	in	r24, 0x3d	; 61
    99fa:	9e b7       	in	r25, 0x3e	; 62
    99fc:	0c 96       	adiw	r24, 0x0c	; 12
    99fe:	0f b6       	in	r0, 0x3f	; 63
    9a00:	f8 94       	cli
    9a02:	9e bf       	out	0x3e, r25	; 62
    9a04:	0f be       	out	0x3f, r0	; 63
    9a06:	8d bf       	out	0x3d, r24	; 61
	}
	else{
		Format[5] = '\0';
		sprintf(Param->Pos, Format, F_Buf);
	}
}
    9a08:	2b 96       	adiw	r28, 0x0b	; 11
    9a0a:	0f b6       	in	r0, 0x3f	; 63
    9a0c:	f8 94       	cli
    9a0e:	de bf       	out	0x3e, r29	; 62
    9a10:	0f be       	out	0x3f, r0	; 63
    9a12:	cd bf       	out	0x3d, r28	; 61
    9a14:	cf 91       	pop	r28
    9a16:	df 91       	pop	r29
    9a18:	1f 91       	pop	r17
    9a1a:	0f 91       	pop	r16
    9a1c:	ff 90       	pop	r15
    9a1e:	ef 90       	pop	r14
    9a20:	df 90       	pop	r13
    9a22:	cf 90       	pop	r12
    9a24:	bf 90       	pop	r11
    9a26:	af 90       	pop	r10
    9a28:	9f 90       	pop	r9
    9a2a:	8f 90       	pop	r8
    9a2c:	7f 90       	pop	r7
    9a2e:	6f 90       	pop	r6
    9a30:	08 95       	ret
		Format[8] = '0'+Param->Prec;
		uint16_t Div=Pow10(Param->Prec);
		sprintf(Param->Pos, Format, F_Buf/Div, F_Buf%Div);
	}
	else{
		Format[5] = '\0';
    9a32:	1e 82       	std	Y+6, r1	; 0x06
		sprintf(Param->Pos, Format, F_Buf);
    9a34:	ad b7       	in	r26, 0x3d	; 61
    9a36:	be b7       	in	r27, 0x3e	; 62
    9a38:	18 97       	sbiw	r26, 0x08	; 8
    9a3a:	0f b6       	in	r0, 0x3f	; 63
    9a3c:	f8 94       	cli
    9a3e:	be bf       	out	0x3e, r27	; 62
    9a40:	0f be       	out	0x3f, r0	; 63
    9a42:	ad bf       	out	0x3d, r26	; 61
    9a44:	ed b7       	in	r30, 0x3d	; 61
    9a46:	fe b7       	in	r31, 0x3e	; 62
    9a48:	31 96       	adiw	r30, 0x01	; 1
    9a4a:	db 01       	movw	r26, r22
    9a4c:	8d 91       	ld	r24, X+
    9a4e:	9c 91       	ld	r25, X
    9a50:	ad b7       	in	r26, 0x3d	; 61
    9a52:	be b7       	in	r27, 0x3e	; 62
    9a54:	12 96       	adiw	r26, 0x02	; 2
    9a56:	9c 93       	st	X, r25
    9a58:	8e 93       	st	-X, r24
    9a5a:	11 97       	sbiw	r26, 0x01	; 1
    9a5c:	73 82       	std	Z+3, r7	; 0x03
    9a5e:	62 82       	std	Z+2, r6	; 0x02
    9a60:	80 91 f7 04 	lds	r24, 0x04F7
    9a64:	90 91 f8 04 	lds	r25, 0x04F8
    9a68:	a0 91 f9 04 	lds	r26, 0x04F9
    9a6c:	b0 91 fa 04 	lds	r27, 0x04FA
    9a70:	84 83       	std	Z+4, r24	; 0x04
    9a72:	95 83       	std	Z+5, r25	; 0x05
    9a74:	a6 83       	std	Z+6, r26	; 0x06
    9a76:	b7 83       	std	Z+7, r27	; 0x07
    9a78:	0e 94 ef 8b 	call	0x117de	; 0x117de <sprintf>
    9a7c:	ed b7       	in	r30, 0x3d	; 61
    9a7e:	fe b7       	in	r31, 0x3e	; 62
    9a80:	38 96       	adiw	r30, 0x08	; 8
    9a82:	0f b6       	in	r0, 0x3f	; 63
    9a84:	f8 94       	cli
    9a86:	fe bf       	out	0x3e, r31	; 62
    9a88:	0f be       	out	0x3f, r0	; 63
    9a8a:	ed bf       	out	0x3d, r30	; 61
    9a8c:	bd cf       	rjmp	.-134    	; 0x9a08 <Put_bVal+0x10c>

00009a8e <Put_TextValAlignLeft>:
	char Format[8];
	//char Format[8] = "%10.10s";
	sprintf(Format,"%%%u.%us", Param->Size, Param->Size);
	sprintf(Param->Pos, Format, Val);
}
void Put_TextValAlignLeft(char* Val, T_Param *Param){
    9a8e:	cf 92       	push	r12
    9a90:	df 92       	push	r13
    9a92:	ef 92       	push	r14
    9a94:	ff 92       	push	r15
    9a96:	0f 93       	push	r16
    9a98:	1f 93       	push	r17
    9a9a:	df 93       	push	r29
    9a9c:	cf 93       	push	r28
    9a9e:	cd b7       	in	r28, 0x3d	; 61
    9aa0:	de b7       	in	r29, 0x3e	; 62
    9aa2:	29 97       	sbiw	r28, 0x09	; 9
    9aa4:	0f b6       	in	r0, 0x3f	; 63
    9aa6:	f8 94       	cli
    9aa8:	de bf       	out	0x3e, r29	; 62
    9aaa:	0f be       	out	0x3f, r0	; 63
    9aac:	cd bf       	out	0x3d, r28	; 61
    9aae:	6c 01       	movw	r12, r24
    9ab0:	7b 01       	movw	r14, r22
	char Format[9];
	//char Format[8] = "%10.10s";
	sprintf(Format,"%%-%u.%us", Param->Size, Param->Size);
    9ab2:	db 01       	movw	r26, r22
    9ab4:	13 96       	adiw	r26, 0x03	; 3
    9ab6:	2c 91       	ld	r18, X
    9ab8:	ed b7       	in	r30, 0x3d	; 61
    9aba:	fe b7       	in	r31, 0x3e	; 62
    9abc:	38 97       	sbiw	r30, 0x08	; 8
    9abe:	0f b6       	in	r0, 0x3f	; 63
    9ac0:	f8 94       	cli
    9ac2:	fe bf       	out	0x3e, r31	; 62
    9ac4:	0f be       	out	0x3f, r0	; 63
    9ac6:	ed bf       	out	0x3d, r30	; 61
    9ac8:	31 96       	adiw	r30, 0x01	; 1
    9aca:	8e 01       	movw	r16, r28
    9acc:	0f 5f       	subi	r16, 0xFF	; 255
    9ace:	1f 4f       	sbci	r17, 0xFF	; 255
    9ad0:	ad b7       	in	r26, 0x3d	; 61
    9ad2:	be b7       	in	r27, 0x3e	; 62
    9ad4:	12 96       	adiw	r26, 0x02	; 2
    9ad6:	1c 93       	st	X, r17
    9ad8:	0e 93       	st	-X, r16
    9ada:	11 97       	sbiw	r26, 0x01	; 1
    9adc:	87 e1       	ldi	r24, 0x17	; 23
    9ade:	92 e0       	ldi	r25, 0x02	; 2
    9ae0:	93 83       	std	Z+3, r25	; 0x03
    9ae2:	82 83       	std	Z+2, r24	; 0x02
    9ae4:	24 83       	std	Z+4, r18	; 0x04
    9ae6:	15 82       	std	Z+5, r1	; 0x05
    9ae8:	26 83       	std	Z+6, r18	; 0x06
    9aea:	17 82       	std	Z+7, r1	; 0x07
    9aec:	0e 94 ef 8b 	call	0x117de	; 0x117de <sprintf>
	sprintf(Param->Pos, Format, Val);
    9af0:	0f 90       	pop	r0
    9af2:	0f 90       	pop	r0
    9af4:	ed b7       	in	r30, 0x3d	; 61
    9af6:	fe b7       	in	r31, 0x3e	; 62
    9af8:	31 96       	adiw	r30, 0x01	; 1
    9afa:	d7 01       	movw	r26, r14
    9afc:	8d 91       	ld	r24, X+
    9afe:	9c 91       	ld	r25, X
    9b00:	ad b7       	in	r26, 0x3d	; 61
    9b02:	be b7       	in	r27, 0x3e	; 62
    9b04:	12 96       	adiw	r26, 0x02	; 2
    9b06:	9c 93       	st	X, r25
    9b08:	8e 93       	st	-X, r24
    9b0a:	11 97       	sbiw	r26, 0x01	; 1
    9b0c:	13 83       	std	Z+3, r17	; 0x03
    9b0e:	02 83       	std	Z+2, r16	; 0x02
    9b10:	d5 82       	std	Z+5, r13	; 0x05
    9b12:	c4 82       	std	Z+4, r12	; 0x04
    9b14:	0e 94 ef 8b 	call	0x117de	; 0x117de <sprintf>
    9b18:	ed b7       	in	r30, 0x3d	; 61
    9b1a:	fe b7       	in	r31, 0x3e	; 62
    9b1c:	36 96       	adiw	r30, 0x06	; 6
    9b1e:	0f b6       	in	r0, 0x3f	; 63
    9b20:	f8 94       	cli
    9b22:	fe bf       	out	0x3e, r31	; 62
    9b24:	0f be       	out	0x3f, r0	; 63
    9b26:	ed bf       	out	0x3d, r30	; 61
}
    9b28:	29 96       	adiw	r28, 0x09	; 9
    9b2a:	0f b6       	in	r0, 0x3f	; 63
    9b2c:	f8 94       	cli
    9b2e:	de bf       	out	0x3e, r29	; 62
    9b30:	0f be       	out	0x3f, r0	; 63
    9b32:	cd bf       	out	0x3d, r28	; 61
    9b34:	cf 91       	pop	r28
    9b36:	df 91       	pop	r29
    9b38:	1f 91       	pop	r17
    9b3a:	0f 91       	pop	r16
    9b3c:	ff 90       	pop	r15
    9b3e:	ef 90       	pop	r14
    9b40:	df 90       	pop	r13
    9b42:	cf 90       	pop	r12
    9b44:	08 95       	ret

00009b46 <Put_TextValAlignRight>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Put_TextVal -  
// if, for example, Filed width =12 -> sprintf(Param->Pos,"%12.12s",Val)
// min and max width = Param->Size and align right
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void Put_TextValAlignRight(char* Val, T_Param *Param){
    9b46:	cf 92       	push	r12
    9b48:	df 92       	push	r13
    9b4a:	ef 92       	push	r14
    9b4c:	ff 92       	push	r15
    9b4e:	0f 93       	push	r16
    9b50:	1f 93       	push	r17
    9b52:	df 93       	push	r29
    9b54:	cf 93       	push	r28
    9b56:	cd b7       	in	r28, 0x3d	; 61
    9b58:	de b7       	in	r29, 0x3e	; 62
    9b5a:	28 97       	sbiw	r28, 0x08	; 8
    9b5c:	0f b6       	in	r0, 0x3f	; 63
    9b5e:	f8 94       	cli
    9b60:	de bf       	out	0x3e, r29	; 62
    9b62:	0f be       	out	0x3f, r0	; 63
    9b64:	cd bf       	out	0x3d, r28	; 61
    9b66:	6c 01       	movw	r12, r24
    9b68:	7b 01       	movw	r14, r22
	char Format[8];
	//char Format[8] = "%10.10s";
	sprintf(Format,"%%%u.%us", Param->Size, Param->Size);
    9b6a:	db 01       	movw	r26, r22
    9b6c:	13 96       	adiw	r26, 0x03	; 3
    9b6e:	2c 91       	ld	r18, X
    9b70:	ed b7       	in	r30, 0x3d	; 61
    9b72:	fe b7       	in	r31, 0x3e	; 62
    9b74:	38 97       	sbiw	r30, 0x08	; 8
    9b76:	0f b6       	in	r0, 0x3f	; 63
    9b78:	f8 94       	cli
    9b7a:	fe bf       	out	0x3e, r31	; 62
    9b7c:	0f be       	out	0x3f, r0	; 63
    9b7e:	ed bf       	out	0x3d, r30	; 61
    9b80:	31 96       	adiw	r30, 0x01	; 1
    9b82:	8e 01       	movw	r16, r28
    9b84:	0f 5f       	subi	r16, 0xFF	; 255
    9b86:	1f 4f       	sbci	r17, 0xFF	; 255
    9b88:	ad b7       	in	r26, 0x3d	; 61
    9b8a:	be b7       	in	r27, 0x3e	; 62
    9b8c:	12 96       	adiw	r26, 0x02	; 2
    9b8e:	1c 93       	st	X, r17
    9b90:	0e 93       	st	-X, r16
    9b92:	11 97       	sbiw	r26, 0x01	; 1
    9b94:	81 e2       	ldi	r24, 0x21	; 33
    9b96:	92 e0       	ldi	r25, 0x02	; 2
    9b98:	93 83       	std	Z+3, r25	; 0x03
    9b9a:	82 83       	std	Z+2, r24	; 0x02
    9b9c:	24 83       	std	Z+4, r18	; 0x04
    9b9e:	15 82       	std	Z+5, r1	; 0x05
    9ba0:	26 83       	std	Z+6, r18	; 0x06
    9ba2:	17 82       	std	Z+7, r1	; 0x07
    9ba4:	0e 94 ef 8b 	call	0x117de	; 0x117de <sprintf>
	sprintf(Param->Pos, Format, Val);
    9ba8:	0f 90       	pop	r0
    9baa:	0f 90       	pop	r0
    9bac:	ed b7       	in	r30, 0x3d	; 61
    9bae:	fe b7       	in	r31, 0x3e	; 62
    9bb0:	31 96       	adiw	r30, 0x01	; 1
    9bb2:	d7 01       	movw	r26, r14
    9bb4:	8d 91       	ld	r24, X+
    9bb6:	9c 91       	ld	r25, X
    9bb8:	ad b7       	in	r26, 0x3d	; 61
    9bba:	be b7       	in	r27, 0x3e	; 62
    9bbc:	12 96       	adiw	r26, 0x02	; 2
    9bbe:	9c 93       	st	X, r25
    9bc0:	8e 93       	st	-X, r24
    9bc2:	11 97       	sbiw	r26, 0x01	; 1
    9bc4:	13 83       	std	Z+3, r17	; 0x03
    9bc6:	02 83       	std	Z+2, r16	; 0x02
    9bc8:	d5 82       	std	Z+5, r13	; 0x05
    9bca:	c4 82       	std	Z+4, r12	; 0x04
    9bcc:	0e 94 ef 8b 	call	0x117de	; 0x117de <sprintf>
    9bd0:	ed b7       	in	r30, 0x3d	; 61
    9bd2:	fe b7       	in	r31, 0x3e	; 62
    9bd4:	36 96       	adiw	r30, 0x06	; 6
    9bd6:	0f b6       	in	r0, 0x3f	; 63
    9bd8:	f8 94       	cli
    9bda:	fe bf       	out	0x3e, r31	; 62
    9bdc:	0f be       	out	0x3f, r0	; 63
    9bde:	ed bf       	out	0x3d, r30	; 61
}
    9be0:	28 96       	adiw	r28, 0x08	; 8
    9be2:	0f b6       	in	r0, 0x3f	; 63
    9be4:	f8 94       	cli
    9be6:	de bf       	out	0x3e, r29	; 62
    9be8:	0f be       	out	0x3f, r0	; 63
    9bea:	cd bf       	out	0x3d, r28	; 61
    9bec:	cf 91       	pop	r28
    9bee:	df 91       	pop	r29
    9bf0:	1f 91       	pop	r17
    9bf2:	0f 91       	pop	r16
    9bf4:	ff 90       	pop	r15
    9bf6:	ef 90       	pop	r14
    9bf8:	df 90       	pop	r13
    9bfa:	cf 90       	pop	r12
    9bfc:	08 95       	ret

00009bfe <Put_GFVal>:
// Trailing zeros are removed from the fractional part of the result; 
// a decimal point appears only if it is followed by at least one digit.
// Max presicion - 8digits Why???
// Therefore Max Field size - 9
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void Put_GFVal(float Val, T_Param *Param){
    9bfe:	ef 92       	push	r14
    9c00:	ff 92       	push	r15
    9c02:	0f 93       	push	r16
    9c04:	1f 93       	push	r17
    9c06:	df 93       	push	r29
    9c08:	cf 93       	push	r28
    9c0a:	cd b7       	in	r28, 0x3d	; 61
    9c0c:	de b7       	in	r29, 0x3e	; 62
    9c0e:	2f 97       	sbiw	r28, 0x0f	; 15
    9c10:	0f b6       	in	r0, 0x3f	; 63
    9c12:	f8 94       	cli
    9c14:	de bf       	out	0x3e, r29	; 62
    9c16:	0f be       	out	0x3f, r0	; 63
    9c18:	cd bf       	out	0x3d, r28	; 61
    9c1a:	7b 01       	movw	r14, r22
    9c1c:	8c 01       	movw	r16, r24
    9c1e:	9a 01       	movw	r18, r20
	if(Param->Size < 10){
    9c20:	da 01       	movw	r26, r20
    9c22:	13 96       	adiw	r26, 0x03	; 3
    9c24:	8c 91       	ld	r24, X
    9c26:	8a 30       	cpi	r24, 0x0A	; 10
    9c28:	08 f4       	brcc	.+2      	; 0x9c2c <Put_GFVal+0x2e>
    9c2a:	44 c0       	rjmp	.+136    	; 0x9cb4 <Put_GFVal+0xb6>
		Format[2] = '0'+Param->Size;
		Format[4] = '0'+Param->Prec;
		sprintf(Param->Pos, Format, Val);
	}
	else{
		char Format[] = "%+1 . g";
    9c2c:	ae 01       	movw	r20, r28
    9c2e:	48 5f       	subi	r20, 0xF8	; 248
    9c30:	5f 4f       	sbci	r21, 0xFF	; 255
    9c32:	da 01       	movw	r26, r20
    9c34:	ea e2       	ldi	r30, 0x2A	; 42
    9c36:	f2 e0       	ldi	r31, 0x02	; 2
    9c38:	88 e0       	ldi	r24, 0x08	; 8
    9c3a:	01 90       	ld	r0, Z+
    9c3c:	0d 92       	st	X+, r0
    9c3e:	81 50       	subi	r24, 0x01	; 1
    9c40:	e1 f7       	brne	.-8      	; 0x9c3a <Put_GFVal+0x3c>
		Format[3] = '0'+Param->Size-10;	
    9c42:	d9 01       	movw	r26, r18
    9c44:	13 96       	adiw	r26, 0x03	; 3
    9c46:	8c 91       	ld	r24, X
    9c48:	13 97       	sbiw	r26, 0x03	; 3
    9c4a:	8a 5d       	subi	r24, 0xDA	; 218
    9c4c:	8b 87       	std	Y+11, r24	; 0x0b
		Format[5] = '0'+Param->Prec;
    9c4e:	12 96       	adiw	r26, 0x02	; 2
    9c50:	8c 91       	ld	r24, X
    9c52:	12 97       	sbiw	r26, 0x02	; 2
    9c54:	80 5d       	subi	r24, 0xD0	; 208
    9c56:	8d 87       	std	Y+13, r24	; 0x0d
		sprintf(Param->Pos, Format, Val);
    9c58:	ed b7       	in	r30, 0x3d	; 61
    9c5a:	fe b7       	in	r31, 0x3e	; 62
    9c5c:	38 97       	sbiw	r30, 0x08	; 8
    9c5e:	0f b6       	in	r0, 0x3f	; 63
    9c60:	f8 94       	cli
    9c62:	fe bf       	out	0x3e, r31	; 62
    9c64:	0f be       	out	0x3f, r0	; 63
    9c66:	ed bf       	out	0x3d, r30	; 61
    9c68:	31 96       	adiw	r30, 0x01	; 1
    9c6a:	8d 91       	ld	r24, X+
    9c6c:	9c 91       	ld	r25, X
    9c6e:	ad b7       	in	r26, 0x3d	; 61
    9c70:	be b7       	in	r27, 0x3e	; 62
    9c72:	12 96       	adiw	r26, 0x02	; 2
    9c74:	9c 93       	st	X, r25
    9c76:	8e 93       	st	-X, r24
    9c78:	11 97       	sbiw	r26, 0x01	; 1
    9c7a:	53 83       	std	Z+3, r21	; 0x03
    9c7c:	42 83       	std	Z+2, r20	; 0x02
    9c7e:	e4 82       	std	Z+4, r14	; 0x04
    9c80:	f5 82       	std	Z+5, r15	; 0x05
    9c82:	06 83       	std	Z+6, r16	; 0x06
    9c84:	17 83       	std	Z+7, r17	; 0x07
    9c86:	0e 94 ef 8b 	call	0x117de	; 0x117de <sprintf>
    9c8a:	ed b7       	in	r30, 0x3d	; 61
    9c8c:	fe b7       	in	r31, 0x3e	; 62
    9c8e:	38 96       	adiw	r30, 0x08	; 8
    9c90:	0f b6       	in	r0, 0x3f	; 63
    9c92:	f8 94       	cli
    9c94:	fe bf       	out	0x3e, r31	; 62
    9c96:	0f be       	out	0x3f, r0	; 63
    9c98:	ed bf       	out	0x3d, r30	; 61
	}
}
    9c9a:	2f 96       	adiw	r28, 0x0f	; 15
    9c9c:	0f b6       	in	r0, 0x3f	; 63
    9c9e:	f8 94       	cli
    9ca0:	de bf       	out	0x3e, r29	; 62
    9ca2:	0f be       	out	0x3f, r0	; 63
    9ca4:	cd bf       	out	0x3d, r28	; 61
    9ca6:	cf 91       	pop	r28
    9ca8:	df 91       	pop	r29
    9caa:	1f 91       	pop	r17
    9cac:	0f 91       	pop	r16
    9cae:	ff 90       	pop	r15
    9cb0:	ef 90       	pop	r14
    9cb2:	08 95       	ret
// Max presicion - 8digits Why???
// Therefore Max Field size - 9
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void Put_GFVal(float Val, T_Param *Param){
	if(Param->Size < 10){
		char Format[] = "%+ . g";
    9cb4:	ae 01       	movw	r20, r28
    9cb6:	4f 5f       	subi	r20, 0xFF	; 255
    9cb8:	5f 4f       	sbci	r21, 0xFF	; 255
    9cba:	da 01       	movw	r26, r20
    9cbc:	e2 e3       	ldi	r30, 0x32	; 50
    9cbe:	f2 e0       	ldi	r31, 0x02	; 2
    9cc0:	87 e0       	ldi	r24, 0x07	; 7
    9cc2:	01 90       	ld	r0, Z+
    9cc4:	0d 92       	st	X+, r0
    9cc6:	81 50       	subi	r24, 0x01	; 1
    9cc8:	e1 f7       	brne	.-8      	; 0x9cc2 <Put_GFVal+0xc4>
		Format[2] = '0'+Param->Size;
    9cca:	f9 01       	movw	r30, r18
    9ccc:	83 81       	ldd	r24, Z+3	; 0x03
    9cce:	80 5d       	subi	r24, 0xD0	; 208
    9cd0:	8b 83       	std	Y+3, r24	; 0x03
		Format[4] = '0'+Param->Prec;
    9cd2:	82 81       	ldd	r24, Z+2	; 0x02
    9cd4:	80 5d       	subi	r24, 0xD0	; 208
    9cd6:	8d 83       	std	Y+5, r24	; 0x05
		sprintf(Param->Pos, Format, Val);
    9cd8:	8d b7       	in	r24, 0x3d	; 61
    9cda:	9e b7       	in	r25, 0x3e	; 62
    9cdc:	08 97       	sbiw	r24, 0x08	; 8
    9cde:	0f b6       	in	r0, 0x3f	; 63
    9ce0:	f8 94       	cli
    9ce2:	9e bf       	out	0x3e, r25	; 62
    9ce4:	0f be       	out	0x3f, r0	; 63
    9ce6:	8d bf       	out	0x3d, r24	; 61
    9ce8:	ed b7       	in	r30, 0x3d	; 61
    9cea:	fe b7       	in	r31, 0x3e	; 62
    9cec:	31 96       	adiw	r30, 0x01	; 1
    9cee:	d9 01       	movw	r26, r18
    9cf0:	bc cf       	rjmp	.-136    	; 0x9c6a <Put_GFVal+0x6c>

00009cf2 <Put_FFVal>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Put_FVal -  The double argument is rounded and converted to decimal notation in the format "[-]ddd.ddd"
// Max presicion - 8digits Why???
// Therefore Max Field size - 9
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void Put_FFVal(float Val, T_Param *Param){
    9cf2:	ef 92       	push	r14
    9cf4:	ff 92       	push	r15
    9cf6:	0f 93       	push	r16
    9cf8:	1f 93       	push	r17
    9cfa:	df 93       	push	r29
    9cfc:	cf 93       	push	r28
    9cfe:	cd b7       	in	r28, 0x3d	; 61
    9d00:	de b7       	in	r29, 0x3e	; 62
    9d02:	27 97       	sbiw	r28, 0x07	; 7
    9d04:	0f b6       	in	r0, 0x3f	; 63
    9d06:	f8 94       	cli
    9d08:	de bf       	out	0x3e, r29	; 62
    9d0a:	0f be       	out	0x3f, r0	; 63
    9d0c:	cd bf       	out	0x3d, r28	; 61
    9d0e:	7b 01       	movw	r14, r22
    9d10:	8c 01       	movw	r16, r24
    9d12:	9a 01       	movw	r18, r20
	char Format[] = "%+ . f";
    9d14:	ae 01       	movw	r20, r28
    9d16:	4f 5f       	subi	r20, 0xFF	; 255
    9d18:	5f 4f       	sbci	r21, 0xFF	; 255
    9d1a:	da 01       	movw	r26, r20
    9d1c:	e9 e3       	ldi	r30, 0x39	; 57
    9d1e:	f2 e0       	ldi	r31, 0x02	; 2
    9d20:	87 e0       	ldi	r24, 0x07	; 7
    9d22:	01 90       	ld	r0, Z+
    9d24:	0d 92       	st	X+, r0
    9d26:	81 50       	subi	r24, 0x01	; 1
    9d28:	e1 f7       	brne	.-8      	; 0x9d22 <Put_FFVal+0x30>
	Format[2] = '0'+Param->Size;
    9d2a:	d9 01       	movw	r26, r18
    9d2c:	13 96       	adiw	r26, 0x03	; 3
    9d2e:	8c 91       	ld	r24, X
    9d30:	13 97       	sbiw	r26, 0x03	; 3
    9d32:	80 5d       	subi	r24, 0xD0	; 208
    9d34:	8b 83       	std	Y+3, r24	; 0x03
	Format[4] = '0'+Param->Prec;	
    9d36:	12 96       	adiw	r26, 0x02	; 2
    9d38:	8c 91       	ld	r24, X
    9d3a:	12 97       	sbiw	r26, 0x02	; 2
    9d3c:	80 5d       	subi	r24, 0xD0	; 208
    9d3e:	8d 83       	std	Y+5, r24	; 0x05
	sprintf(Param->Pos, Format, Val);
    9d40:	ed b7       	in	r30, 0x3d	; 61
    9d42:	fe b7       	in	r31, 0x3e	; 62
    9d44:	38 97       	sbiw	r30, 0x08	; 8
    9d46:	0f b6       	in	r0, 0x3f	; 63
    9d48:	f8 94       	cli
    9d4a:	fe bf       	out	0x3e, r31	; 62
    9d4c:	0f be       	out	0x3f, r0	; 63
    9d4e:	ed bf       	out	0x3d, r30	; 61
    9d50:	31 96       	adiw	r30, 0x01	; 1
    9d52:	8d 91       	ld	r24, X+
    9d54:	9c 91       	ld	r25, X
    9d56:	ad b7       	in	r26, 0x3d	; 61
    9d58:	be b7       	in	r27, 0x3e	; 62
    9d5a:	12 96       	adiw	r26, 0x02	; 2
    9d5c:	9c 93       	st	X, r25
    9d5e:	8e 93       	st	-X, r24
    9d60:	11 97       	sbiw	r26, 0x01	; 1
    9d62:	53 83       	std	Z+3, r21	; 0x03
    9d64:	42 83       	std	Z+2, r20	; 0x02
    9d66:	e4 82       	std	Z+4, r14	; 0x04
    9d68:	f5 82       	std	Z+5, r15	; 0x05
    9d6a:	06 83       	std	Z+6, r16	; 0x06
    9d6c:	17 83       	std	Z+7, r17	; 0x07
    9d6e:	0e 94 ef 8b 	call	0x117de	; 0x117de <sprintf>
    9d72:	ed b7       	in	r30, 0x3d	; 61
    9d74:	fe b7       	in	r31, 0x3e	; 62
    9d76:	38 96       	adiw	r30, 0x08	; 8
    9d78:	0f b6       	in	r0, 0x3f	; 63
    9d7a:	f8 94       	cli
    9d7c:	fe bf       	out	0x3e, r31	; 62
    9d7e:	0f be       	out	0x3f, r0	; 63
    9d80:	ed bf       	out	0x3d, r30	; 61
}
    9d82:	27 96       	adiw	r28, 0x07	; 7
    9d84:	0f b6       	in	r0, 0x3f	; 63
    9d86:	f8 94       	cli
    9d88:	de bf       	out	0x3e, r29	; 62
    9d8a:	0f be       	out	0x3f, r0	; 63
    9d8c:	cd bf       	out	0x3d, r28	; 61
    9d8e:	cf 91       	pop	r28
    9d90:	df 91       	pop	r29
    9d92:	1f 91       	pop	r17
    9d94:	0f 91       	pop	r16
    9d96:	ff 90       	pop	r15
    9d98:	ef 90       	pop	r14
    9d9a:	08 95       	ret

00009d9c <Put_zDVal>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Put_zDVal - print unsigned Longint with leading zeroes in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void 
Put_zDVal(uint32_t Val, T_Param *Param)
{
    9d9c:	2f 92       	push	r2
    9d9e:	3f 92       	push	r3
    9da0:	4f 92       	push	r4
    9da2:	5f 92       	push	r5
    9da4:	6f 92       	push	r6
    9da6:	7f 92       	push	r7
    9da8:	8f 92       	push	r8
    9daa:	9f 92       	push	r9
    9dac:	af 92       	push	r10
    9dae:	bf 92       	push	r11
    9db0:	cf 92       	push	r12
    9db2:	df 92       	push	r13
    9db4:	ef 92       	push	r14
    9db6:	ff 92       	push	r15
    9db8:	0f 93       	push	r16
    9dba:	1f 93       	push	r17
    9dbc:	df 93       	push	r29
    9dbe:	cf 93       	push	r28
    9dc0:	cd b7       	in	r28, 0x3d	; 61
    9dc2:	de b7       	in	r29, 0x3e	; 62
    9dc4:	2c 97       	sbiw	r28, 0x0c	; 12
    9dc6:	0f b6       	in	r0, 0x3f	; 63
    9dc8:	f8 94       	cli
    9dca:	de bf       	out	0x3e, r29	; 62
    9dcc:	0f be       	out	0x3f, r0	; 63
    9dce:	cd bf       	out	0x3d, r28	; 61
    9dd0:	1b 01       	movw	r2, r22
    9dd2:	2c 01       	movw	r4, r24
    9dd4:	3a 01       	movw	r6, r20
	uint32_t Idx = 0xFFFFFFFF-Val;
	if(Param->Txt && Idx<2) {
    9dd6:	da 01       	movw	r26, r20
    9dd8:	14 96       	adiw	r26, 0x04	; 4
    9dda:	2d 91       	ld	r18, X+
    9ddc:	3c 91       	ld	r19, X
    9dde:	15 97       	sbiw	r26, 0x05	; 5
    9de0:	21 15       	cp	r18, r1
    9de2:	31 05       	cpc	r19, r1
    9de4:	61 f0       	breq	.+24     	; 0x9dfe <Put_zDVal+0x62>
// Put_zDVal - print unsigned Longint with leading zeroes in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void 
Put_zDVal(uint32_t Val, T_Param *Param)
{
	uint32_t Idx = 0xFFFFFFFF-Val;
    9de6:	dc 01       	movw	r26, r24
    9de8:	cb 01       	movw	r24, r22
    9dea:	80 95       	com	r24
    9dec:	90 95       	com	r25
    9dee:	a0 95       	com	r26
    9df0:	b0 95       	com	r27
	if(Param->Txt && Idx<2) {
    9df2:	82 30       	cpi	r24, 0x02	; 2
    9df4:	91 05       	cpc	r25, r1
    9df6:	a1 05       	cpc	r26, r1
    9df8:	b1 05       	cpc	r27, r1
    9dfa:	08 f4       	brcc	.+2      	; 0x9dfe <Put_zDVal+0x62>
    9dfc:	e5 c0       	rjmp	.+458    	; 0x9fc8 <Put_zDVal+0x22c>
		Param->Txt += Idx;
		PutEnum(Param);
		return;
	}

	if(Param->Size==10 && Param->Prec==0){
    9dfe:	d3 01       	movw	r26, r6
    9e00:	13 96       	adiw	r26, 0x03	; 3
    9e02:	8c 91       	ld	r24, X
    9e04:	13 97       	sbiw	r26, 0x03	; 3
    9e06:	8a 30       	cpi	r24, 0x0A	; 10
    9e08:	09 f4       	brne	.+2      	; 0x9e0c <Put_zDVal+0x70>
    9e0a:	72 c0       	rjmp	.+228    	; 0x9ef0 <Put_zDVal+0x154>
		sprintf(Param->Pos, "%010lu", Val);
		return;
	}
	char Format[] = "%0 lu.%. lu";
    9e0c:	de 01       	movw	r26, r28
    9e0e:	11 96       	adiw	r26, 0x01	; 1
    9e10:	e7 e4       	ldi	r30, 0x47	; 71
    9e12:	f2 e0       	ldi	r31, 0x02	; 2
    9e14:	8c e0       	ldi	r24, 0x0C	; 12
    9e16:	01 90       	ld	r0, Z+
    9e18:	0d 92       	st	X+, r0
    9e1a:	81 50       	subi	r24, 0x01	; 1
    9e1c:	e1 f7       	brne	.-8      	; 0x9e16 <Put_zDVal+0x7a>
	Format[2] = '0'+Param->Size;
    9e1e:	d3 01       	movw	r26, r6
    9e20:	13 96       	adiw	r26, 0x03	; 3
    9e22:	2c 91       	ld	r18, X
    9e24:	13 97       	sbiw	r26, 0x03	; 3
    9e26:	20 5d       	subi	r18, 0xD0	; 208
    9e28:	2b 83       	std	Y+3, r18	; 0x03
	if(Param->Prec) {
    9e2a:	12 96       	adiw	r26, 0x02	; 2
    9e2c:	9c 91       	ld	r25, X
    9e2e:	99 23       	and	r25, r25
    9e30:	09 f4       	brne	.+2      	; 0x9e34 <Put_zDVal+0x98>
    9e32:	a0 c0       	rjmp	.+320    	; 0x9f74 <Put_zDVal+0x1d8>
		Format[2] -= Param->Prec+1;
    9e34:	89 2f       	mov	r24, r25
    9e36:	80 95       	com	r24
    9e38:	82 0f       	add	r24, r18
    9e3a:	8b 83       	std	Y+3, r24	; 0x03
		Format[8] = '0'+Param->Prec;
    9e3c:	90 5d       	subi	r25, 0xD0	; 208
    9e3e:	99 87       	std	Y+9, r25	; 0x09
    9e40:	90 53       	subi	r25, 0x30	; 48
		uint32_t Div=PowL10(Param->Prec);
    9e42:	09 2f       	mov	r16, r25
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
	uint32_t Pow = 1;
	while(Exp--)
    9e44:	b1 e0       	ldi	r27, 0x01	; 1
    9e46:	8b 2e       	mov	r8, r27
    9e48:	91 2c       	mov	r9, r1
    9e4a:	a1 2c       	mov	r10, r1
    9e4c:	b1 2c       	mov	r11, r1
		Pow *= 10;
    9e4e:	c5 01       	movw	r24, r10
    9e50:	b4 01       	movw	r22, r8
    9e52:	2a e0       	ldi	r18, 0x0A	; 10
    9e54:	30 e0       	ldi	r19, 0x00	; 0
    9e56:	40 e0       	ldi	r20, 0x00	; 0
    9e58:	50 e0       	ldi	r21, 0x00	; 0
    9e5a:	0e 94 59 8e 	call	0x11cb2	; 0x11cb2 <__mulsi3>
    9e5e:	4b 01       	movw	r8, r22
    9e60:	5c 01       	movw	r10, r24
    9e62:	01 50       	subi	r16, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
	uint32_t Pow = 1;
	while(Exp--)
    9e64:	a1 f7       	brne	.-24     	; 0x9e4e <Put_zDVal+0xb2>
    9e66:	c2 01       	movw	r24, r4
    9e68:	b1 01       	movw	r22, r2
    9e6a:	94 01       	movw	r18, r8
    9e6c:	a5 01       	movw	r20, r10
    9e6e:	0e 94 ab 8e 	call	0x11d56	; 0x11d56 <__udivmodsi4>
    9e72:	f6 2e       	mov	r15, r22
    9e74:	e7 2e       	mov	r14, r23
    9e76:	d8 2e       	mov	r13, r24
    9e78:	c9 2e       	mov	r12, r25
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
    9e7a:	ed b7       	in	r30, 0x3d	; 61
    9e7c:	fe b7       	in	r31, 0x3e	; 62
    9e7e:	3c 97       	sbiw	r30, 0x0c	; 12
    9e80:	0f b6       	in	r0, 0x3f	; 63
    9e82:	f8 94       	cli
    9e84:	fe bf       	out	0x3e, r31	; 62
    9e86:	0f be       	out	0x3f, r0	; 63
    9e88:	ed bf       	out	0x3d, r30	; 61
    9e8a:	0d b7       	in	r16, 0x3d	; 61
    9e8c:	1e b7       	in	r17, 0x3e	; 62
    9e8e:	0f 5f       	subi	r16, 0xFF	; 255
    9e90:	1f 4f       	sbci	r17, 0xFF	; 255
    9e92:	d3 01       	movw	r26, r6
    9e94:	8d 91       	ld	r24, X+
    9e96:	9c 91       	ld	r25, X
    9e98:	92 83       	std	Z+2, r25	; 0x02
    9e9a:	81 83       	std	Z+1, r24	; 0x01
    9e9c:	81 e0       	ldi	r24, 0x01	; 1
    9e9e:	90 e0       	ldi	r25, 0x00	; 0
    9ea0:	8c 0f       	add	r24, r28
    9ea2:	9d 1f       	adc	r25, r29
    9ea4:	f8 01       	movw	r30, r16
    9ea6:	93 83       	std	Z+3, r25	; 0x03
    9ea8:	82 83       	std	Z+2, r24	; 0x02
    9eaa:	c2 01       	movw	r24, r4
    9eac:	b1 01       	movw	r22, r2
    9eae:	a5 01       	movw	r20, r10
    9eb0:	94 01       	movw	r18, r8
    9eb2:	0e 94 ab 8e 	call	0x11d56	; 0x11d56 <__udivmodsi4>
    9eb6:	d8 01       	movw	r26, r16
    9eb8:	14 96       	adiw	r26, 0x04	; 4
    9eba:	2d 93       	st	X+, r18
    9ebc:	3d 93       	st	X+, r19
    9ebe:	4d 93       	st	X+, r20
    9ec0:	5c 93       	st	X, r21
    9ec2:	17 97       	sbiw	r26, 0x07	; 7
    9ec4:	18 96       	adiw	r26, 0x08	; 8
    9ec6:	fc 92       	st	X, r15
    9ec8:	18 97       	sbiw	r26, 0x08	; 8
    9eca:	19 96       	adiw	r26, 0x09	; 9
    9ecc:	ec 92       	st	X, r14
    9ece:	19 97       	sbiw	r26, 0x09	; 9
    9ed0:	1a 96       	adiw	r26, 0x0a	; 10
    9ed2:	dc 92       	st	X, r13
    9ed4:	1a 97       	sbiw	r26, 0x0a	; 10
    9ed6:	1b 96       	adiw	r26, 0x0b	; 11
    9ed8:	cc 92       	st	X, r12
    9eda:	0e 94 ef 8b 	call	0x117de	; 0x117de <sprintf>
    9ede:	ed b7       	in	r30, 0x3d	; 61
    9ee0:	fe b7       	in	r31, 0x3e	; 62
    9ee2:	3c 96       	adiw	r30, 0x0c	; 12
    9ee4:	0f b6       	in	r0, 0x3f	; 63
    9ee6:	f8 94       	cli
    9ee8:	fe bf       	out	0x3e, r31	; 62
    9eea:	0f be       	out	0x3f, r0	; 63
    9eec:	ed bf       	out	0x3d, r30	; 61
    9eee:	29 c0       	rjmp	.+82     	; 0x9f42 <Put_zDVal+0x1a6>
		Param->Txt += Idx;
		PutEnum(Param);
		return;
	}

	if(Param->Size==10 && Param->Prec==0){
    9ef0:	12 96       	adiw	r26, 0x02	; 2
    9ef2:	8c 91       	ld	r24, X
    9ef4:	12 97       	sbiw	r26, 0x02	; 2
    9ef6:	88 23       	and	r24, r24
    9ef8:	09 f0       	breq	.+2      	; 0x9efc <Put_zDVal+0x160>
    9efa:	88 cf       	rjmp	.-240    	; 0x9e0c <Put_zDVal+0x70>
		sprintf(Param->Pos, "%010lu", Val);
    9efc:	ed b7       	in	r30, 0x3d	; 61
    9efe:	fe b7       	in	r31, 0x3e	; 62
    9f00:	38 97       	sbiw	r30, 0x08	; 8
    9f02:	0f b6       	in	r0, 0x3f	; 63
    9f04:	f8 94       	cli
    9f06:	fe bf       	out	0x3e, r31	; 62
    9f08:	0f be       	out	0x3f, r0	; 63
    9f0a:	ed bf       	out	0x3d, r30	; 61
    9f0c:	31 96       	adiw	r30, 0x01	; 1
    9f0e:	8d 91       	ld	r24, X+
    9f10:	9c 91       	ld	r25, X
    9f12:	ad b7       	in	r26, 0x3d	; 61
    9f14:	be b7       	in	r27, 0x3e	; 62
    9f16:	12 96       	adiw	r26, 0x02	; 2
    9f18:	9c 93       	st	X, r25
    9f1a:	8e 93       	st	-X, r24
    9f1c:	11 97       	sbiw	r26, 0x01	; 1
    9f1e:	80 e4       	ldi	r24, 0x40	; 64
    9f20:	92 e0       	ldi	r25, 0x02	; 2
    9f22:	93 83       	std	Z+3, r25	; 0x03
    9f24:	82 83       	std	Z+2, r24	; 0x02
    9f26:	24 82       	std	Z+4, r2	; 0x04
    9f28:	35 82       	std	Z+5, r3	; 0x05
    9f2a:	46 82       	std	Z+6, r4	; 0x06
    9f2c:	57 82       	std	Z+7, r5	; 0x07
    9f2e:	0e 94 ef 8b 	call	0x117de	; 0x117de <sprintf>
    9f32:	ed b7       	in	r30, 0x3d	; 61
    9f34:	fe b7       	in	r31, 0x3e	; 62
    9f36:	38 96       	adiw	r30, 0x08	; 8
    9f38:	0f b6       	in	r0, 0x3f	; 63
    9f3a:	f8 94       	cli
    9f3c:	fe bf       	out	0x3e, r31	; 62
    9f3e:	0f be       	out	0x3f, r0	; 63
    9f40:	ed bf       	out	0x3d, r30	; 61
	}
	else {
		Format[5] = '\0';
		sprintf(Param->Pos, Format, Val);
	}
}
    9f42:	2c 96       	adiw	r28, 0x0c	; 12
    9f44:	0f b6       	in	r0, 0x3f	; 63
    9f46:	f8 94       	cli
    9f48:	de bf       	out	0x3e, r29	; 62
    9f4a:	0f be       	out	0x3f, r0	; 63
    9f4c:	cd bf       	out	0x3d, r28	; 61
    9f4e:	cf 91       	pop	r28
    9f50:	df 91       	pop	r29
    9f52:	1f 91       	pop	r17
    9f54:	0f 91       	pop	r16
    9f56:	ff 90       	pop	r15
    9f58:	ef 90       	pop	r14
    9f5a:	df 90       	pop	r13
    9f5c:	cf 90       	pop	r12
    9f5e:	bf 90       	pop	r11
    9f60:	af 90       	pop	r10
    9f62:	9f 90       	pop	r9
    9f64:	8f 90       	pop	r8
    9f66:	7f 90       	pop	r7
    9f68:	6f 90       	pop	r6
    9f6a:	5f 90       	pop	r5
    9f6c:	4f 90       	pop	r4
    9f6e:	3f 90       	pop	r3
    9f70:	2f 90       	pop	r2
    9f72:	08 95       	ret
		Format[8] = '0'+Param->Prec;
		uint32_t Div=PowL10(Param->Prec);
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
	}
	else {
		Format[5] = '\0';
    9f74:	1e 82       	std	Y+6, r1	; 0x06
		sprintf(Param->Pos, Format, Val);
    9f76:	8d b7       	in	r24, 0x3d	; 61
    9f78:	9e b7       	in	r25, 0x3e	; 62
    9f7a:	08 97       	sbiw	r24, 0x08	; 8
    9f7c:	0f b6       	in	r0, 0x3f	; 63
    9f7e:	f8 94       	cli
    9f80:	9e bf       	out	0x3e, r25	; 62
    9f82:	0f be       	out	0x3f, r0	; 63
    9f84:	8d bf       	out	0x3d, r24	; 61
    9f86:	ed b7       	in	r30, 0x3d	; 61
    9f88:	fe b7       	in	r31, 0x3e	; 62
    9f8a:	31 96       	adiw	r30, 0x01	; 1
    9f8c:	d3 01       	movw	r26, r6
    9f8e:	8d 91       	ld	r24, X+
    9f90:	9c 91       	ld	r25, X
    9f92:	ad b7       	in	r26, 0x3d	; 61
    9f94:	be b7       	in	r27, 0x3e	; 62
    9f96:	12 96       	adiw	r26, 0x02	; 2
    9f98:	9c 93       	st	X, r25
    9f9a:	8e 93       	st	-X, r24
    9f9c:	11 97       	sbiw	r26, 0x01	; 1
    9f9e:	81 e0       	ldi	r24, 0x01	; 1
    9fa0:	90 e0       	ldi	r25, 0x00	; 0
    9fa2:	8c 0f       	add	r24, r28
    9fa4:	9d 1f       	adc	r25, r29
    9fa6:	93 83       	std	Z+3, r25	; 0x03
    9fa8:	82 83       	std	Z+2, r24	; 0x02
    9faa:	24 82       	std	Z+4, r2	; 0x04
    9fac:	35 82       	std	Z+5, r3	; 0x05
    9fae:	46 82       	std	Z+6, r4	; 0x06
    9fb0:	57 82       	std	Z+7, r5	; 0x07
    9fb2:	0e 94 ef 8b 	call	0x117de	; 0x117de <sprintf>
    9fb6:	ad b7       	in	r26, 0x3d	; 61
    9fb8:	be b7       	in	r27, 0x3e	; 62
    9fba:	18 96       	adiw	r26, 0x08	; 8
    9fbc:	0f b6       	in	r0, 0x3f	; 63
    9fbe:	f8 94       	cli
    9fc0:	be bf       	out	0x3e, r27	; 62
    9fc2:	0f be       	out	0x3f, r0	; 63
    9fc4:	ad bf       	out	0x3d, r26	; 61
    9fc6:	bd cf       	rjmp	.-134    	; 0x9f42 <Put_zDVal+0x1a6>
void 
Put_zDVal(uint32_t Val, T_Param *Param)
{
	uint32_t Idx = 0xFFFFFFFF-Val;
	if(Param->Txt && Idx<2) {
		Param->Txt += Idx;
    9fc8:	88 0f       	add	r24, r24
    9fca:	99 1f       	adc	r25, r25
    9fcc:	28 0f       	add	r18, r24
    9fce:	39 1f       	adc	r19, r25
    9fd0:	fa 01       	movw	r30, r20
    9fd2:	35 83       	std	Z+5, r19	; 0x05
    9fd4:	24 83       	std	Z+4, r18	; 0x04
		PutEnum(Param);
    9fd6:	ca 01       	movw	r24, r20
    9fd8:	0e 94 4f 4b 	call	0x969e	; 0x969e <PutEnum>
    9fdc:	b2 cf       	rjmp	.-156    	; 0x9f42 <Put_zDVal+0x1a6>

00009fde <Put_sDVal>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Put_sDVal - print signed Longint in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_sDVal(int32_t Val, T_Param *Param)
{
    9fde:	cf 92       	push	r12
    9fe0:	df 92       	push	r13
    9fe2:	ef 92       	push	r14
    9fe4:	ff 92       	push	r15
    9fe6:	0f 93       	push	r16
    9fe8:	1f 93       	push	r17
    9fea:	df 93       	push	r29
    9fec:	cf 93       	push	r28
    9fee:	cd b7       	in	r28, 0x3d	; 61
    9ff0:	de b7       	in	r29, 0x3e	; 62
    9ff2:	2d 97       	sbiw	r28, 0x0d	; 13
    9ff4:	0f b6       	in	r0, 0x3f	; 63
    9ff6:	f8 94       	cli
    9ff8:	de bf       	out	0x3e, r29	; 62
    9ffa:	0f be       	out	0x3f, r0	; 63
    9ffc:	cd bf       	out	0x3d, r28	; 61
    9ffe:	6b 01       	movw	r12, r22
    a000:	7c 01       	movw	r14, r24
    a002:	8a 01       	movw	r16, r20
	uint32_t Idx = 0x80000000+Val;
	if(Param->Txt && Idx<2) {
    a004:	da 01       	movw	r26, r20
    a006:	14 96       	adiw	r26, 0x04	; 4
    a008:	2d 91       	ld	r18, X+
    a00a:	3c 91       	ld	r19, X
    a00c:	15 97       	sbiw	r26, 0x05	; 5
    a00e:	21 15       	cp	r18, r1
    a010:	31 05       	cpc	r19, r1
    a012:	61 f0       	breq	.+24     	; 0xa02c <Put_sDVal+0x4e>
// Put_sDVal - print signed Longint in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_sDVal(int32_t Val, T_Param *Param)
{
	uint32_t Idx = 0x80000000+Val;
    a014:	dc 01       	movw	r26, r24
    a016:	cb 01       	movw	r24, r22
    a018:	80 50       	subi	r24, 0x00	; 0
    a01a:	90 40       	sbci	r25, 0x00	; 0
    a01c:	a0 40       	sbci	r26, 0x00	; 0
    a01e:	b0 48       	sbci	r27, 0x80	; 128
	if(Param->Txt && Idx<2) {
    a020:	82 30       	cpi	r24, 0x02	; 2
    a022:	91 05       	cpc	r25, r1
    a024:	a1 05       	cpc	r26, r1
    a026:	b1 05       	cpc	r27, r1
    a028:	08 f4       	brcc	.+2      	; 0xa02c <Put_sDVal+0x4e>
    a02a:	f7 c0       	rjmp	.+494    	; 0xa21a <Put_sDVal+0x23c>
		Param->Txt += Idx;
		PutEnum(Param);
		return;
	}
	// standart specificator to print Longint in string
	if(Param->Size>9){
    a02c:	d8 01       	movw	r26, r16
    a02e:	13 96       	adiw	r26, 0x03	; 3
    a030:	8c 91       	ld	r24, X
    a032:	8a 30       	cpi	r24, 0x0A	; 10
    a034:	f8 f0       	brcs	.+62     	; 0xa074 <Put_sDVal+0x96>
		char Format[] = "%+1 ld";
    a036:	9e 01       	movw	r18, r28
    a038:	29 5f       	subi	r18, 0xF9	; 249
    a03a:	3f 4f       	sbci	r19, 0xFF	; 255
    a03c:	d9 01       	movw	r26, r18
    a03e:	e3 e5       	ldi	r30, 0x53	; 83
    a040:	f2 e0       	ldi	r31, 0x02	; 2
    a042:	87 e0       	ldi	r24, 0x07	; 7
    a044:	01 90       	ld	r0, Z+
    a046:	0d 92       	st	X+, r0
    a048:	81 50       	subi	r24, 0x01	; 1
    a04a:	e1 f7       	brne	.-8      	; 0xa044 <Put_sDVal+0x66>
		Format[3] = '0'+Param->Size%10;
    a04c:	f8 01       	movw	r30, r16
    a04e:	83 81       	ldd	r24, Z+3	; 0x03
    a050:	6a e0       	ldi	r22, 0x0A	; 10
    a052:	0e 94 78 8e 	call	0x11cf0	; 0x11cf0 <__udivmodqi4>
    a056:	90 5d       	subi	r25, 0xD0	; 208
    a058:	9a 87       	std	Y+10, r25	; 0x0a
		sprintf(Param->Pos, Format, Val);
    a05a:	8d b7       	in	r24, 0x3d	; 61
    a05c:	9e b7       	in	r25, 0x3e	; 62
    a05e:	08 97       	sbiw	r24, 0x08	; 8
    a060:	0f b6       	in	r0, 0x3f	; 63
    a062:	f8 94       	cli
    a064:	9e bf       	out	0x3e, r25	; 62
    a066:	0f be       	out	0x3f, r0	; 63
    a068:	8d bf       	out	0x3d, r24	; 61
    a06a:	ed b7       	in	r30, 0x3d	; 61
    a06c:	fe b7       	in	r31, 0x3e	; 62
    a06e:	31 96       	adiw	r30, 0x01	; 1
    a070:	d8 01       	movw	r26, r16
    a072:	1a c0       	rjmp	.+52     	; 0xa0a8 <Put_sDVal+0xca>
	}
	else{
		char Format[] = "%+ ld";
    a074:	9e 01       	movw	r18, r28
    a076:	2f 5f       	subi	r18, 0xFF	; 255
    a078:	3f 4f       	sbci	r19, 0xFF	; 255
    a07a:	d9 01       	movw	r26, r18
    a07c:	ea e5       	ldi	r30, 0x5A	; 90
    a07e:	f2 e0       	ldi	r31, 0x02	; 2
    a080:	86 e0       	ldi	r24, 0x06	; 6
    a082:	01 90       	ld	r0, Z+
    a084:	0d 92       	st	X+, r0
    a086:	81 50       	subi	r24, 0x01	; 1
    a088:	e1 f7       	brne	.-8      	; 0xa082 <Put_sDVal+0xa4>
		Format[2] = '0'+Param->Size;
    a08a:	d8 01       	movw	r26, r16
    a08c:	13 96       	adiw	r26, 0x03	; 3
    a08e:	8c 91       	ld	r24, X
    a090:	13 97       	sbiw	r26, 0x03	; 3
    a092:	80 5d       	subi	r24, 0xD0	; 208
    a094:	8b 83       	std	Y+3, r24	; 0x03
		sprintf(Param->Pos, Format, Val);
    a096:	ed b7       	in	r30, 0x3d	; 61
    a098:	fe b7       	in	r31, 0x3e	; 62
    a09a:	38 97       	sbiw	r30, 0x08	; 8
    a09c:	0f b6       	in	r0, 0x3f	; 63
    a09e:	f8 94       	cli
    a0a0:	fe bf       	out	0x3e, r31	; 62
    a0a2:	0f be       	out	0x3f, r0	; 63
    a0a4:	ed bf       	out	0x3d, r30	; 61
    a0a6:	31 96       	adiw	r30, 0x01	; 1
    a0a8:	8d 91       	ld	r24, X+
    a0aa:	9c 91       	ld	r25, X
    a0ac:	ad b7       	in	r26, 0x3d	; 61
    a0ae:	be b7       	in	r27, 0x3e	; 62
    a0b0:	12 96       	adiw	r26, 0x02	; 2
    a0b2:	9c 93       	st	X, r25
    a0b4:	8e 93       	st	-X, r24
    a0b6:	11 97       	sbiw	r26, 0x01	; 1
    a0b8:	33 83       	std	Z+3, r19	; 0x03
    a0ba:	22 83       	std	Z+2, r18	; 0x02
    a0bc:	c4 82       	std	Z+4, r12	; 0x04
    a0be:	d5 82       	std	Z+5, r13	; 0x05
    a0c0:	e6 82       	std	Z+6, r14	; 0x06
    a0c2:	f7 82       	std	Z+7, r15	; 0x07
    a0c4:	0e 94 ef 8b 	call	0x117de	; 0x117de <sprintf>
    a0c8:	ed b7       	in	r30, 0x3d	; 61
    a0ca:	fe b7       	in	r31, 0x3e	; 62
    a0cc:	38 96       	adiw	r30, 0x08	; 8
    a0ce:	0f b6       	in	r0, 0x3f	; 63
    a0d0:	f8 94       	cli
    a0d2:	fe bf       	out	0x3e, r31	; 62
    a0d4:	0f be       	out	0x3f, r0	; 63
    a0d6:	ed bf       	out	0x3d, r30	; 61
	}
	//Delete sign if zero
	if(!Val)Param->Pos[Param->Size-2] = ' ';
    a0d8:	c1 14       	cp	r12, r1
    a0da:	d1 04       	cpc	r13, r1
    a0dc:	e1 04       	cpc	r14, r1
    a0de:	f1 04       	cpc	r15, r1
    a0e0:	59 f4       	brne	.+22     	; 0xa0f8 <Put_sDVal+0x11a>
    a0e2:	d8 01       	movw	r26, r16
    a0e4:	13 96       	adiw	r26, 0x03	; 3
    a0e6:	8c 91       	ld	r24, X
    a0e8:	13 97       	sbiw	r26, 0x03	; 3
    a0ea:	ed 91       	ld	r30, X+
    a0ec:	fc 91       	ld	r31, X
    a0ee:	e8 0f       	add	r30, r24
    a0f0:	f1 1d       	adc	r31, r1
    a0f2:	32 97       	sbiw	r30, 0x02	; 2
    a0f4:	80 e2       	ldi	r24, 0x20	; 32
    a0f6:	80 83       	st	Z, r24

	if(Param->Prec){
    a0f8:	f8 01       	movw	r30, r16
    a0fa:	92 81       	ldd	r25, Z+2	; 0x02
    a0fc:	99 23       	and	r25, r25
    a0fe:	09 f4       	brne	.+2      	; 0xa102 <Put_sDVal+0x124>
    a100:	41 c0       	rjmp	.+130    	; 0xa184 <Put_sDVal+0x1a6>
		//Insert decimal point
		for(uint8_t i=0; i< Param->Size - Param->Prec; i++){
    a102:	83 81       	ldd	r24, Z+3	; 0x03
    a104:	28 2f       	mov	r18, r24
    a106:	30 e0       	ldi	r19, 0x00	; 0
    a108:	29 1b       	sub	r18, r25
    a10a:	31 09       	sbc	r19, r1
    a10c:	12 16       	cp	r1, r18
    a10e:	13 06       	cpc	r1, r19
    a110:	d4 f4       	brge	.+52     	; 0xa146 <Put_sDVal+0x168>
    a112:	40 e0       	ldi	r20, 0x00	; 0
    a114:	80 e0       	ldi	r24, 0x00	; 0
    a116:	90 e0       	ldi	r25, 0x00	; 0
			Param->Pos[i] = Param->Pos[i+1];
    a118:	d8 01       	movw	r26, r16
    a11a:	ed 91       	ld	r30, X+
    a11c:	fc 91       	ld	r31, X
    a11e:	11 97       	sbiw	r26, 0x01	; 1
    a120:	e8 0f       	add	r30, r24
    a122:	f9 1f       	adc	r31, r25
    a124:	81 81       	ldd	r24, Z+1	; 0x01
    a126:	80 83       	st	Z, r24
	//Delete sign if zero
	if(!Val)Param->Pos[Param->Size-2] = ' ';

	if(Param->Prec){
		//Insert decimal point
		for(uint8_t i=0; i< Param->Size - Param->Prec; i++){
    a128:	4f 5f       	subi	r20, 0xFF	; 255
    a12a:	13 96       	adiw	r26, 0x03	; 3
    a12c:	8c 91       	ld	r24, X
    a12e:	13 97       	sbiw	r26, 0x03	; 3
    a130:	28 2f       	mov	r18, r24
    a132:	30 e0       	ldi	r19, 0x00	; 0
    a134:	12 96       	adiw	r26, 0x02	; 2
    a136:	8c 91       	ld	r24, X
    a138:	28 1b       	sub	r18, r24
    a13a:	31 09       	sbc	r19, r1
    a13c:	84 2f       	mov	r24, r20
    a13e:	90 e0       	ldi	r25, 0x00	; 0
    a140:	82 17       	cp	r24, r18
    a142:	93 07       	cpc	r25, r19
    a144:	4c f3       	brlt	.-46     	; 0xa118 <Put_sDVal+0x13a>
			Param->Pos[i] = Param->Pos[i+1];
		}
		Param->Pos[Param->Size - Param->Prec-1] = '.';
    a146:	d8 01       	movw	r26, r16
    a148:	ed 91       	ld	r30, X+
    a14a:	fc 91       	ld	r31, X
    a14c:	11 97       	sbiw	r26, 0x01	; 1
    a14e:	e2 0f       	add	r30, r18
    a150:	f3 1f       	adc	r31, r19
    a152:	31 97       	sbiw	r30, 0x01	; 1
    a154:	8e e2       	ldi	r24, 0x2E	; 46
    a156:	80 83       	st	Z, r24
		//Fill zeros and shift sign for correct view
		char c = Param->Pos[Param->Size - Param->Prec-2];
    a158:	4d 91       	ld	r20, X+
    a15a:	5c 91       	ld	r21, X
    a15c:	11 97       	sbiw	r26, 0x01	; 1
    a15e:	13 96       	adiw	r26, 0x03	; 3
    a160:	9c 91       	ld	r25, X
    a162:	13 97       	sbiw	r26, 0x03	; 3
    a164:	e9 2f       	mov	r30, r25
    a166:	f0 e0       	ldi	r31, 0x00	; 0
    a168:	12 96       	adiw	r26, 0x02	; 2
    a16a:	8c 91       	ld	r24, X
    a16c:	e8 1b       	sub	r30, r24
    a16e:	f1 09       	sbc	r31, r1
    a170:	e4 0f       	add	r30, r20
    a172:	f5 1f       	adc	r31, r21
    a174:	32 97       	sbiw	r30, 0x02	; 2
    a176:	e0 81       	ld	r30, Z
		if(c ==' ' || c =='+' || c =='-'){
    a178:	e0 32       	cpi	r30, 0x20	; 32
    a17a:	99 f0       	breq	.+38     	; 0xa1a2 <Put_sDVal+0x1c4>
    a17c:	eb 32       	cpi	r30, 0x2B	; 43
    a17e:	89 f0       	breq	.+34     	; 0xa1a2 <Put_sDVal+0x1c4>
    a180:	ed 32       	cpi	r30, 0x2D	; 45
    a182:	79 f0       	breq	.+30     	; 0xa1a2 <Put_sDVal+0x1c4>
				}
			}
		}
	}

}
    a184:	2d 96       	adiw	r28, 0x0d	; 13
    a186:	0f b6       	in	r0, 0x3f	; 63
    a188:	f8 94       	cli
    a18a:	de bf       	out	0x3e, r29	; 62
    a18c:	0f be       	out	0x3f, r0	; 63
    a18e:	cd bf       	out	0x3d, r28	; 61
    a190:	cf 91       	pop	r28
    a192:	df 91       	pop	r29
    a194:	1f 91       	pop	r17
    a196:	0f 91       	pop	r16
    a198:	ff 90       	pop	r15
    a19a:	ef 90       	pop	r14
    a19c:	df 90       	pop	r13
    a19e:	cf 90       	pop	r12
    a1a0:	08 95       	ret
		}
		Param->Pos[Param->Size - Param->Prec-1] = '.';
		//Fill zeros and shift sign for correct view
		char c = Param->Pos[Param->Size - Param->Prec-2];
		if(c ==' ' || c =='+' || c =='-'){
			for(uint8_t i=Param->Size-1; i>1; i--){
    a1a2:	e9 2f       	mov	r30, r25
    a1a4:	e1 50       	subi	r30, 0x01	; 1
    a1a6:	e2 30       	cpi	r30, 0x02	; 2
    a1a8:	68 f3       	brcs	.-38     	; 0xa184 <Put_sDVal+0x1a6>
				if(Param->Pos[i] == ' '|| Param->Pos[i] == '+' || Param->Pos[i] == '-' ) Param->Pos[i]='0';
    a1aa:	90 e3       	ldi	r25, 0x30	; 48
    a1ac:	09 c0       	rjmp	.+18     	; 0xa1c0 <Put_sDVal+0x1e2>
    a1ae:	8b 32       	cpi	r24, 0x2B	; 43
    a1b0:	79 f0       	breq	.+30     	; 0xa1d0 <Put_sDVal+0x1f2>
    a1b2:	8d 32       	cpi	r24, 0x2D	; 45
    a1b4:	69 f0       	breq	.+26     	; 0xa1d0 <Put_sDVal+0x1f2>
				if(Param->Pos[i] == '.'){
    a1b6:	8e 32       	cpi	r24, 0x2E	; 46
    a1b8:	a9 f0       	breq	.+42     	; 0xa1e4 <Put_sDVal+0x206>
		}
		Param->Pos[Param->Size - Param->Prec-1] = '.';
		//Fill zeros and shift sign for correct view
		char c = Param->Pos[Param->Size - Param->Prec-2];
		if(c ==' ' || c =='+' || c =='-'){
			for(uint8_t i=Param->Size-1; i>1; i--){
    a1ba:	e1 50       	subi	r30, 0x01	; 1
    a1bc:	e2 30       	cpi	r30, 0x02	; 2
    a1be:	10 f3       	brcs	.-60     	; 0xa184 <Put_sDVal+0x1a6>
				if(Param->Pos[i] == ' '|| Param->Pos[i] == '+' || Param->Pos[i] == '-' ) Param->Pos[i]='0';
    a1c0:	2e 2f       	mov	r18, r30
    a1c2:	30 e0       	ldi	r19, 0x00	; 0
    a1c4:	da 01       	movw	r26, r20
    a1c6:	a2 0f       	add	r26, r18
    a1c8:	b3 1f       	adc	r27, r19
    a1ca:	8c 91       	ld	r24, X
    a1cc:	80 32       	cpi	r24, 0x20	; 32
    a1ce:	79 f7       	brne	.-34     	; 0xa1ae <Put_sDVal+0x1d0>
    a1d0:	9c 93       	st	X, r25
    a1d2:	d8 01       	movw	r26, r16
    a1d4:	4d 91       	ld	r20, X+
    a1d6:	5c 91       	ld	r21, X
    a1d8:	da 01       	movw	r26, r20
    a1da:	a2 0f       	add	r26, r18
    a1dc:	b3 1f       	adc	r27, r19
    a1de:	8c 91       	ld	r24, X
				if(Param->Pos[i] == '.'){
    a1e0:	8e 32       	cpi	r24, 0x2E	; 46
    a1e2:	59 f7       	brne	.-42     	; 0xa1ba <Put_sDVal+0x1dc>
					Param->Pos[i-1]='0';
    a1e4:	11 97       	sbiw	r26, 0x01	; 1
    a1e6:	80 e3       	ldi	r24, 0x30	; 48
    a1e8:	8c 93       	st	X, r24
					if(Val>0)Param->Pos[i-2]='+';
    a1ea:	1c 14       	cp	r1, r12
    a1ec:	1d 04       	cpc	r1, r13
    a1ee:	1e 04       	cpc	r1, r14
    a1f0:	1f 04       	cpc	r1, r15
    a1f2:	44 f4       	brge	.+16     	; 0xa204 <Put_sDVal+0x226>
    a1f4:	d8 01       	movw	r26, r16
    a1f6:	ed 91       	ld	r30, X+
    a1f8:	fc 91       	ld	r31, X
    a1fa:	e2 0f       	add	r30, r18
    a1fc:	f3 1f       	adc	r31, r19
    a1fe:	32 97       	sbiw	r30, 0x02	; 2
    a200:	8b e2       	ldi	r24, 0x2B	; 43
    a202:	80 83       	st	Z, r24
					if(Val<0)Param->Pos[i-2]='-';
    a204:	f7 fe       	sbrs	r15, 7
    a206:	be cf       	rjmp	.-132    	; 0xa184 <Put_sDVal+0x1a6>
    a208:	d8 01       	movw	r26, r16
    a20a:	ed 91       	ld	r30, X+
    a20c:	fc 91       	ld	r31, X
    a20e:	e2 0f       	add	r30, r18
    a210:	f3 1f       	adc	r31, r19
    a212:	32 97       	sbiw	r30, 0x02	; 2
    a214:	8d e2       	ldi	r24, 0x2D	; 45
    a216:	80 83       	st	Z, r24
    a218:	b5 cf       	rjmp	.-150    	; 0xa184 <Put_sDVal+0x1a6>
void
Put_sDVal(int32_t Val, T_Param *Param)
{
	uint32_t Idx = 0x80000000+Val;
	if(Param->Txt && Idx<2) {
		Param->Txt += Idx;
    a21a:	88 0f       	add	r24, r24
    a21c:	99 1f       	adc	r25, r25
    a21e:	28 0f       	add	r18, r24
    a220:	39 1f       	adc	r19, r25
    a222:	f8 01       	movw	r30, r16
    a224:	35 83       	std	Z+5, r19	; 0x05
    a226:	24 83       	std	Z+4, r18	; 0x04
		PutEnum(Param);
    a228:	c8 01       	movw	r24, r16
    a22a:	0e 94 4f 4b 	call	0x969e	; 0x969e <PutEnum>
    a22e:	aa cf       	rjmp	.-172    	; 0xa184 <Put_sDVal+0x1a6>

0000a230 <PutDVal>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// PutDVal - print unsigned Longint in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
PutDVal(uint32_t Val, T_Param *Param)
{
    a230:	2f 92       	push	r2
    a232:	3f 92       	push	r3
    a234:	4f 92       	push	r4
    a236:	5f 92       	push	r5
    a238:	6f 92       	push	r6
    a23a:	7f 92       	push	r7
    a23c:	8f 92       	push	r8
    a23e:	9f 92       	push	r9
    a240:	af 92       	push	r10
    a242:	bf 92       	push	r11
    a244:	cf 92       	push	r12
    a246:	df 92       	push	r13
    a248:	ef 92       	push	r14
    a24a:	ff 92       	push	r15
    a24c:	0f 93       	push	r16
    a24e:	1f 93       	push	r17
    a250:	df 93       	push	r29
    a252:	cf 93       	push	r28
    a254:	cd b7       	in	r28, 0x3d	; 61
    a256:	de b7       	in	r29, 0x3e	; 62
    a258:	2b 97       	sbiw	r28, 0x0b	; 11
    a25a:	0f b6       	in	r0, 0x3f	; 63
    a25c:	f8 94       	cli
    a25e:	de bf       	out	0x3e, r29	; 62
    a260:	0f be       	out	0x3f, r0	; 63
    a262:	cd bf       	out	0x3d, r28	; 61
    a264:	1b 01       	movw	r2, r22
    a266:	2c 01       	movw	r4, r24
    a268:	3a 01       	movw	r6, r20
	uint32_t Idx = 0xFFFFFFFF-Val;
	if(Param->Txt && Idx<2) {
    a26a:	da 01       	movw	r26, r20
    a26c:	14 96       	adiw	r26, 0x04	; 4
    a26e:	2d 91       	ld	r18, X+
    a270:	3c 91       	ld	r19, X
    a272:	15 97       	sbiw	r26, 0x05	; 5
    a274:	21 15       	cp	r18, r1
    a276:	31 05       	cpc	r19, r1
    a278:	61 f0       	breq	.+24     	; 0xa292 <PutDVal+0x62>
// PutDVal - print unsigned Longint in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
PutDVal(uint32_t Val, T_Param *Param)
{
	uint32_t Idx = 0xFFFFFFFF-Val;
    a27a:	dc 01       	movw	r26, r24
    a27c:	cb 01       	movw	r24, r22
    a27e:	80 95       	com	r24
    a280:	90 95       	com	r25
    a282:	a0 95       	com	r26
    a284:	b0 95       	com	r27
	if(Param->Txt && Idx<2) {
    a286:	82 30       	cpi	r24, 0x02	; 2
    a288:	91 05       	cpc	r25, r1
    a28a:	a1 05       	cpc	r26, r1
    a28c:	b1 05       	cpc	r27, r1
    a28e:	08 f4       	brcc	.+2      	; 0xa292 <PutDVal+0x62>
    a290:	e5 c0       	rjmp	.+458    	; 0xa45c <PutDVal+0x22c>
		Param->Txt += Idx;
		PutEnum(Param);
		return;
	}

	if(Param->Size==10 && Param->Prec==0){
    a292:	d3 01       	movw	r26, r6
    a294:	13 96       	adiw	r26, 0x03	; 3
    a296:	8c 91       	ld	r24, X
    a298:	13 97       	sbiw	r26, 0x03	; 3
    a29a:	8a 30       	cpi	r24, 0x0A	; 10
    a29c:	09 f4       	brne	.+2      	; 0xa2a0 <PutDVal+0x70>
    a29e:	72 c0       	rjmp	.+228    	; 0xa384 <PutDVal+0x154>
		sprintf(Param->Pos, "%10lu", Val);
		return;
	}
	char Format[] = "% lu.%. lu";
    a2a0:	de 01       	movw	r26, r28
    a2a2:	11 96       	adiw	r26, 0x01	; 1
    a2a4:	e6 e6       	ldi	r30, 0x66	; 102
    a2a6:	f2 e0       	ldi	r31, 0x02	; 2
    a2a8:	8b e0       	ldi	r24, 0x0B	; 11
    a2aa:	01 90       	ld	r0, Z+
    a2ac:	0d 92       	st	X+, r0
    a2ae:	81 50       	subi	r24, 0x01	; 1
    a2b0:	e1 f7       	brne	.-8      	; 0xa2aa <PutDVal+0x7a>
	Format[1] = '0'+Param->Size;
    a2b2:	d3 01       	movw	r26, r6
    a2b4:	13 96       	adiw	r26, 0x03	; 3
    a2b6:	2c 91       	ld	r18, X
    a2b8:	13 97       	sbiw	r26, 0x03	; 3
    a2ba:	20 5d       	subi	r18, 0xD0	; 208
    a2bc:	2a 83       	std	Y+2, r18	; 0x02
	if(Param->Prec) {
    a2be:	12 96       	adiw	r26, 0x02	; 2
    a2c0:	9c 91       	ld	r25, X
    a2c2:	99 23       	and	r25, r25
    a2c4:	09 f4       	brne	.+2      	; 0xa2c8 <PutDVal+0x98>
    a2c6:	a0 c0       	rjmp	.+320    	; 0xa408 <PutDVal+0x1d8>
		Format[1] -= Param->Prec+1;
    a2c8:	89 2f       	mov	r24, r25
    a2ca:	80 95       	com	r24
    a2cc:	82 0f       	add	r24, r18
    a2ce:	8a 83       	std	Y+2, r24	; 0x02
		Format[7] = '0'+Param->Prec;
    a2d0:	90 5d       	subi	r25, 0xD0	; 208
    a2d2:	98 87       	std	Y+8, r25	; 0x08
    a2d4:	90 53       	subi	r25, 0x30	; 48
		uint32_t Div=PowL10(Param->Prec);
    a2d6:	09 2f       	mov	r16, r25
    a2d8:	51 e0       	ldi	r21, 0x01	; 1
    a2da:	85 2e       	mov	r8, r21
    a2dc:	91 2c       	mov	r9, r1
    a2de:	a1 2c       	mov	r10, r1
    a2e0:	b1 2c       	mov	r11, r1
		Pow *= 10;
    a2e2:	c5 01       	movw	r24, r10
    a2e4:	b4 01       	movw	r22, r8
    a2e6:	2a e0       	ldi	r18, 0x0A	; 10
    a2e8:	30 e0       	ldi	r19, 0x00	; 0
    a2ea:	40 e0       	ldi	r20, 0x00	; 0
    a2ec:	50 e0       	ldi	r21, 0x00	; 0
    a2ee:	0e 94 59 8e 	call	0x11cb2	; 0x11cb2 <__mulsi3>
    a2f2:	4b 01       	movw	r8, r22
    a2f4:	5c 01       	movw	r10, r24
    a2f6:	01 50       	subi	r16, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
	uint32_t Pow = 1;
	while(Exp--)
    a2f8:	a1 f7       	brne	.-24     	; 0xa2e2 <PutDVal+0xb2>
    a2fa:	c2 01       	movw	r24, r4
    a2fc:	b1 01       	movw	r22, r2
    a2fe:	94 01       	movw	r18, r8
    a300:	a5 01       	movw	r20, r10
    a302:	0e 94 ab 8e 	call	0x11d56	; 0x11d56 <__udivmodsi4>
    a306:	f6 2e       	mov	r15, r22
    a308:	e7 2e       	mov	r14, r23
    a30a:	d8 2e       	mov	r13, r24
    a30c:	c9 2e       	mov	r12, r25
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
    a30e:	ed b7       	in	r30, 0x3d	; 61
    a310:	fe b7       	in	r31, 0x3e	; 62
    a312:	3c 97       	sbiw	r30, 0x0c	; 12
    a314:	0f b6       	in	r0, 0x3f	; 63
    a316:	f8 94       	cli
    a318:	fe bf       	out	0x3e, r31	; 62
    a31a:	0f be       	out	0x3f, r0	; 63
    a31c:	ed bf       	out	0x3d, r30	; 61
    a31e:	0d b7       	in	r16, 0x3d	; 61
    a320:	1e b7       	in	r17, 0x3e	; 62
    a322:	0f 5f       	subi	r16, 0xFF	; 255
    a324:	1f 4f       	sbci	r17, 0xFF	; 255
    a326:	d3 01       	movw	r26, r6
    a328:	8d 91       	ld	r24, X+
    a32a:	9c 91       	ld	r25, X
    a32c:	92 83       	std	Z+2, r25	; 0x02
    a32e:	81 83       	std	Z+1, r24	; 0x01
    a330:	81 e0       	ldi	r24, 0x01	; 1
    a332:	90 e0       	ldi	r25, 0x00	; 0
    a334:	8c 0f       	add	r24, r28
    a336:	9d 1f       	adc	r25, r29
    a338:	f8 01       	movw	r30, r16
    a33a:	93 83       	std	Z+3, r25	; 0x03
    a33c:	82 83       	std	Z+2, r24	; 0x02
    a33e:	c2 01       	movw	r24, r4
    a340:	b1 01       	movw	r22, r2
    a342:	a5 01       	movw	r20, r10
    a344:	94 01       	movw	r18, r8
    a346:	0e 94 ab 8e 	call	0x11d56	; 0x11d56 <__udivmodsi4>
    a34a:	d8 01       	movw	r26, r16
    a34c:	14 96       	adiw	r26, 0x04	; 4
    a34e:	2d 93       	st	X+, r18
    a350:	3d 93       	st	X+, r19
    a352:	4d 93       	st	X+, r20
    a354:	5c 93       	st	X, r21
    a356:	17 97       	sbiw	r26, 0x07	; 7
    a358:	18 96       	adiw	r26, 0x08	; 8
    a35a:	fc 92       	st	X, r15
    a35c:	18 97       	sbiw	r26, 0x08	; 8
    a35e:	19 96       	adiw	r26, 0x09	; 9
    a360:	ec 92       	st	X, r14
    a362:	19 97       	sbiw	r26, 0x09	; 9
    a364:	1a 96       	adiw	r26, 0x0a	; 10
    a366:	dc 92       	st	X, r13
    a368:	1a 97       	sbiw	r26, 0x0a	; 10
    a36a:	1b 96       	adiw	r26, 0x0b	; 11
    a36c:	cc 92       	st	X, r12
    a36e:	0e 94 ef 8b 	call	0x117de	; 0x117de <sprintf>
    a372:	ed b7       	in	r30, 0x3d	; 61
    a374:	fe b7       	in	r31, 0x3e	; 62
    a376:	3c 96       	adiw	r30, 0x0c	; 12
    a378:	0f b6       	in	r0, 0x3f	; 63
    a37a:	f8 94       	cli
    a37c:	fe bf       	out	0x3e, r31	; 62
    a37e:	0f be       	out	0x3f, r0	; 63
    a380:	ed bf       	out	0x3d, r30	; 61
    a382:	29 c0       	rjmp	.+82     	; 0xa3d6 <PutDVal+0x1a6>
		Param->Txt += Idx;
		PutEnum(Param);
		return;
	}

	if(Param->Size==10 && Param->Prec==0){
    a384:	12 96       	adiw	r26, 0x02	; 2
    a386:	8c 91       	ld	r24, X
    a388:	12 97       	sbiw	r26, 0x02	; 2
    a38a:	88 23       	and	r24, r24
    a38c:	09 f0       	breq	.+2      	; 0xa390 <PutDVal+0x160>
    a38e:	88 cf       	rjmp	.-240    	; 0xa2a0 <PutDVal+0x70>
		sprintf(Param->Pos, "%10lu", Val);
    a390:	ed b7       	in	r30, 0x3d	; 61
    a392:	fe b7       	in	r31, 0x3e	; 62
    a394:	38 97       	sbiw	r30, 0x08	; 8
    a396:	0f b6       	in	r0, 0x3f	; 63
    a398:	f8 94       	cli
    a39a:	fe bf       	out	0x3e, r31	; 62
    a39c:	0f be       	out	0x3f, r0	; 63
    a39e:	ed bf       	out	0x3d, r30	; 61
    a3a0:	31 96       	adiw	r30, 0x01	; 1
    a3a2:	8d 91       	ld	r24, X+
    a3a4:	9c 91       	ld	r25, X
    a3a6:	ad b7       	in	r26, 0x3d	; 61
    a3a8:	be b7       	in	r27, 0x3e	; 62
    a3aa:	12 96       	adiw	r26, 0x02	; 2
    a3ac:	9c 93       	st	X, r25
    a3ae:	8e 93       	st	-X, r24
    a3b0:	11 97       	sbiw	r26, 0x01	; 1
    a3b2:	80 e6       	ldi	r24, 0x60	; 96
    a3b4:	92 e0       	ldi	r25, 0x02	; 2
    a3b6:	93 83       	std	Z+3, r25	; 0x03
    a3b8:	82 83       	std	Z+2, r24	; 0x02
    a3ba:	24 82       	std	Z+4, r2	; 0x04
    a3bc:	35 82       	std	Z+5, r3	; 0x05
    a3be:	46 82       	std	Z+6, r4	; 0x06
    a3c0:	57 82       	std	Z+7, r5	; 0x07
    a3c2:	0e 94 ef 8b 	call	0x117de	; 0x117de <sprintf>
    a3c6:	ed b7       	in	r30, 0x3d	; 61
    a3c8:	fe b7       	in	r31, 0x3e	; 62
    a3ca:	38 96       	adiw	r30, 0x08	; 8
    a3cc:	0f b6       	in	r0, 0x3f	; 63
    a3ce:	f8 94       	cli
    a3d0:	fe bf       	out	0x3e, r31	; 62
    a3d2:	0f be       	out	0x3f, r0	; 63
    a3d4:	ed bf       	out	0x3d, r30	; 61
	}
	else {
		Format[4] = '\0';
		sprintf(Param->Pos, Format, Val);
	}
}
    a3d6:	2b 96       	adiw	r28, 0x0b	; 11
    a3d8:	0f b6       	in	r0, 0x3f	; 63
    a3da:	f8 94       	cli
    a3dc:	de bf       	out	0x3e, r29	; 62
    a3de:	0f be       	out	0x3f, r0	; 63
    a3e0:	cd bf       	out	0x3d, r28	; 61
    a3e2:	cf 91       	pop	r28
    a3e4:	df 91       	pop	r29
    a3e6:	1f 91       	pop	r17
    a3e8:	0f 91       	pop	r16
    a3ea:	ff 90       	pop	r15
    a3ec:	ef 90       	pop	r14
    a3ee:	df 90       	pop	r13
    a3f0:	cf 90       	pop	r12
    a3f2:	bf 90       	pop	r11
    a3f4:	af 90       	pop	r10
    a3f6:	9f 90       	pop	r9
    a3f8:	8f 90       	pop	r8
    a3fa:	7f 90       	pop	r7
    a3fc:	6f 90       	pop	r6
    a3fe:	5f 90       	pop	r5
    a400:	4f 90       	pop	r4
    a402:	3f 90       	pop	r3
    a404:	2f 90       	pop	r2
    a406:	08 95       	ret
		Format[7] = '0'+Param->Prec;
		uint32_t Div=PowL10(Param->Prec);
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
	}
	else {
		Format[4] = '\0';
    a408:	1d 82       	std	Y+5, r1	; 0x05
		sprintf(Param->Pos, Format, Val);
    a40a:	8d b7       	in	r24, 0x3d	; 61
    a40c:	9e b7       	in	r25, 0x3e	; 62
    a40e:	08 97       	sbiw	r24, 0x08	; 8
    a410:	0f b6       	in	r0, 0x3f	; 63
    a412:	f8 94       	cli
    a414:	9e bf       	out	0x3e, r25	; 62
    a416:	0f be       	out	0x3f, r0	; 63
    a418:	8d bf       	out	0x3d, r24	; 61
    a41a:	ed b7       	in	r30, 0x3d	; 61
    a41c:	fe b7       	in	r31, 0x3e	; 62
    a41e:	31 96       	adiw	r30, 0x01	; 1
    a420:	d3 01       	movw	r26, r6
    a422:	8d 91       	ld	r24, X+
    a424:	9c 91       	ld	r25, X
    a426:	ad b7       	in	r26, 0x3d	; 61
    a428:	be b7       	in	r27, 0x3e	; 62
    a42a:	12 96       	adiw	r26, 0x02	; 2
    a42c:	9c 93       	st	X, r25
    a42e:	8e 93       	st	-X, r24
    a430:	11 97       	sbiw	r26, 0x01	; 1
    a432:	81 e0       	ldi	r24, 0x01	; 1
    a434:	90 e0       	ldi	r25, 0x00	; 0
    a436:	8c 0f       	add	r24, r28
    a438:	9d 1f       	adc	r25, r29
    a43a:	93 83       	std	Z+3, r25	; 0x03
    a43c:	82 83       	std	Z+2, r24	; 0x02
    a43e:	24 82       	std	Z+4, r2	; 0x04
    a440:	35 82       	std	Z+5, r3	; 0x05
    a442:	46 82       	std	Z+6, r4	; 0x06
    a444:	57 82       	std	Z+7, r5	; 0x07
    a446:	0e 94 ef 8b 	call	0x117de	; 0x117de <sprintf>
    a44a:	ad b7       	in	r26, 0x3d	; 61
    a44c:	be b7       	in	r27, 0x3e	; 62
    a44e:	18 96       	adiw	r26, 0x08	; 8
    a450:	0f b6       	in	r0, 0x3f	; 63
    a452:	f8 94       	cli
    a454:	be bf       	out	0x3e, r27	; 62
    a456:	0f be       	out	0x3f, r0	; 63
    a458:	ad bf       	out	0x3d, r26	; 61
    a45a:	bd cf       	rjmp	.-134    	; 0xa3d6 <PutDVal+0x1a6>
void
PutDVal(uint32_t Val, T_Param *Param)
{
	uint32_t Idx = 0xFFFFFFFF-Val;
	if(Param->Txt && Idx<2) {
		Param->Txt += Idx;
    a45c:	88 0f       	add	r24, r24
    a45e:	99 1f       	adc	r25, r25
    a460:	28 0f       	add	r18, r24
    a462:	39 1f       	adc	r19, r25
    a464:	fa 01       	movw	r30, r20
    a466:	35 83       	std	Z+5, r19	; 0x05
    a468:	24 83       	std	Z+4, r18	; 0x04
		PutEnum(Param);
    a46a:	ca 01       	movw	r24, r20
    a46c:	0e 94 4f 4b 	call	0x969e	; 0x969e <PutEnum>
    a470:	b2 cf       	rjmp	.-156    	; 0xa3d6 <PutDVal+0x1a6>

0000a472 <Put_zVal_h>:
	}
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_zVal_h(uint32_t Val, char Type, T_Param *Param)
{
    a472:	1f 93       	push	r17
    a474:	17 2f       	mov	r17, r23
    a476:	58 2f       	mov	r21, r24
    a478:	79 2f       	mov	r23, r25
    a47a:	d9 01       	movw	r26, r18
	if(Type=='b') sprintf(Param->Pos, "%02hx", (uint8_t)Val);
    a47c:	42 36       	cpi	r20, 0x62	; 98
    a47e:	71 f1       	breq	.+92     	; 0xa4dc <Put_zVal_h+0x6a>
	if(Type=='w') sprintf(Param->Pos, "%04x", (uint16_t)Val);
    a480:	47 37       	cpi	r20, 0x77	; 119
    a482:	09 f4       	brne	.+2      	; 0xa486 <Put_zVal_h+0x14>
    a484:	4a c0       	rjmp	.+148    	; 0xa51a <Put_zVal_h+0xa8>
	if(Type=='l') sprintf(Param->Pos, "%08lx", Val);
    a486:	4c 36       	cpi	r20, 0x6C	; 108
    a488:	11 f0       	breq	.+4      	; 0xa48e <Put_zVal_h+0x1c>
}
    a48a:	1f 91       	pop	r17
    a48c:	08 95       	ret
void
Put_zVal_h(uint32_t Val, char Type, T_Param *Param)
{
	if(Type=='b') sprintf(Param->Pos, "%02hx", (uint8_t)Val);
	if(Type=='w') sprintf(Param->Pos, "%04x", (uint16_t)Val);
	if(Type=='l') sprintf(Param->Pos, "%08lx", Val);
    a48e:	8d b7       	in	r24, 0x3d	; 61
    a490:	9e b7       	in	r25, 0x3e	; 62
    a492:	08 97       	sbiw	r24, 0x08	; 8
    a494:	0f b6       	in	r0, 0x3f	; 63
    a496:	f8 94       	cli
    a498:	9e bf       	out	0x3e, r25	; 62
    a49a:	0f be       	out	0x3f, r0	; 63
    a49c:	8d bf       	out	0x3d, r24	; 61
    a49e:	ed b7       	in	r30, 0x3d	; 61
    a4a0:	fe b7       	in	r31, 0x3e	; 62
    a4a2:	31 96       	adiw	r30, 0x01	; 1
    a4a4:	8d 91       	ld	r24, X+
    a4a6:	9c 91       	ld	r25, X
    a4a8:	ad b7       	in	r26, 0x3d	; 61
    a4aa:	be b7       	in	r27, 0x3e	; 62
    a4ac:	12 96       	adiw	r26, 0x02	; 2
    a4ae:	9c 93       	st	X, r25
    a4b0:	8e 93       	st	-X, r24
    a4b2:	11 97       	sbiw	r26, 0x01	; 1
    a4b4:	8c e7       	ldi	r24, 0x7C	; 124
    a4b6:	92 e0       	ldi	r25, 0x02	; 2
    a4b8:	93 83       	std	Z+3, r25	; 0x03
    a4ba:	82 83       	std	Z+2, r24	; 0x02
    a4bc:	64 83       	std	Z+4, r22	; 0x04
    a4be:	15 83       	std	Z+5, r17	; 0x05
    a4c0:	56 83       	std	Z+6, r21	; 0x06
    a4c2:	77 83       	std	Z+7, r23	; 0x07
    a4c4:	0e 94 ef 8b 	call	0x117de	; 0x117de <sprintf>
    a4c8:	8d b7       	in	r24, 0x3d	; 61
    a4ca:	9e b7       	in	r25, 0x3e	; 62
    a4cc:	08 96       	adiw	r24, 0x08	; 8
    a4ce:	0f b6       	in	r0, 0x3f	; 63
    a4d0:	f8 94       	cli
    a4d2:	9e bf       	out	0x3e, r25	; 62
    a4d4:	0f be       	out	0x3f, r0	; 63
    a4d6:	8d bf       	out	0x3d, r24	; 61
}
    a4d8:	1f 91       	pop	r17
    a4da:	08 95       	ret
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_zVal_h(uint32_t Val, char Type, T_Param *Param)
{
	if(Type=='b') sprintf(Param->Pos, "%02hx", (uint8_t)Val);
    a4dc:	00 d0       	rcall	.+0      	; 0xa4de <Put_zVal_h+0x6c>
    a4de:	00 d0       	rcall	.+0      	; 0xa4e0 <Put_zVal_h+0x6e>
    a4e0:	ed b7       	in	r30, 0x3d	; 61
    a4e2:	fe b7       	in	r31, 0x3e	; 62
    a4e4:	31 96       	adiw	r30, 0x01	; 1
    a4e6:	8d 91       	ld	r24, X+
    a4e8:	9c 91       	ld	r25, X
    a4ea:	ad b7       	in	r26, 0x3d	; 61
    a4ec:	be b7       	in	r27, 0x3e	; 62
    a4ee:	12 96       	adiw	r26, 0x02	; 2
    a4f0:	9c 93       	st	X, r25
    a4f2:	8e 93       	st	-X, r24
    a4f4:	11 97       	sbiw	r26, 0x01	; 1
    a4f6:	81 e7       	ldi	r24, 0x71	; 113
    a4f8:	92 e0       	ldi	r25, 0x02	; 2
    a4fa:	93 83       	std	Z+3, r25	; 0x03
    a4fc:	82 83       	std	Z+2, r24	; 0x02
    a4fe:	64 83       	std	Z+4, r22	; 0x04
    a500:	15 82       	std	Z+5, r1	; 0x05
    a502:	0e 94 ef 8b 	call	0x117de	; 0x117de <sprintf>
    a506:	8d b7       	in	r24, 0x3d	; 61
    a508:	9e b7       	in	r25, 0x3e	; 62
    a50a:	06 96       	adiw	r24, 0x06	; 6
    a50c:	0f b6       	in	r0, 0x3f	; 63
    a50e:	f8 94       	cli
    a510:	9e bf       	out	0x3e, r25	; 62
    a512:	0f be       	out	0x3f, r0	; 63
    a514:	8d bf       	out	0x3d, r24	; 61
	if(Type=='w') sprintf(Param->Pos, "%04x", (uint16_t)Val);
	if(Type=='l') sprintf(Param->Pos, "%08lx", Val);
}
    a516:	1f 91       	pop	r17
    a518:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_zVal_h(uint32_t Val, char Type, T_Param *Param)
{
	if(Type=='b') sprintf(Param->Pos, "%02hx", (uint8_t)Val);
	if(Type=='w') sprintf(Param->Pos, "%04x", (uint16_t)Val);
    a51a:	00 d0       	rcall	.+0      	; 0xa51c <Put_zVal_h+0xaa>
    a51c:	00 d0       	rcall	.+0      	; 0xa51e <Put_zVal_h+0xac>
    a51e:	ed b7       	in	r30, 0x3d	; 61
    a520:	fe b7       	in	r31, 0x3e	; 62
    a522:	31 96       	adiw	r30, 0x01	; 1
    a524:	8d 91       	ld	r24, X+
    a526:	9c 91       	ld	r25, X
    a528:	ad b7       	in	r26, 0x3d	; 61
    a52a:	be b7       	in	r27, 0x3e	; 62
    a52c:	12 96       	adiw	r26, 0x02	; 2
    a52e:	9c 93       	st	X, r25
    a530:	8e 93       	st	-X, r24
    a532:	11 97       	sbiw	r26, 0x01	; 1
    a534:	87 e7       	ldi	r24, 0x77	; 119
    a536:	92 e0       	ldi	r25, 0x02	; 2
    a538:	93 83       	std	Z+3, r25	; 0x03
    a53a:	82 83       	std	Z+2, r24	; 0x02
    a53c:	64 83       	std	Z+4, r22	; 0x04
    a53e:	15 83       	std	Z+5, r17	; 0x05
    a540:	0e 94 ef 8b 	call	0x117de	; 0x117de <sprintf>
    a544:	8d b7       	in	r24, 0x3d	; 61
    a546:	9e b7       	in	r25, 0x3e	; 62
    a548:	06 96       	adiw	r24, 0x06	; 6
    a54a:	0f b6       	in	r0, 0x3f	; 63
    a54c:	f8 94       	cli
    a54e:	9e bf       	out	0x3e, r25	; 62
    a550:	0f be       	out	0x3f, r0	; 63
    a552:	8d bf       	out	0x3d, r24	; 61
	if(Type=='l') sprintf(Param->Pos, "%08lx", Val);
}
    a554:	1f 91       	pop	r17
    a556:	08 95       	ret

0000a558 <Put_zVal>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_zVal(uint16_t Val, char Type, T_Param *Param)
{
    a558:	af 92       	push	r10
    a55a:	bf 92       	push	r11
    a55c:	cf 92       	push	r12
    a55e:	df 92       	push	r13
    a560:	ef 92       	push	r14
    a562:	ff 92       	push	r15
    a564:	0f 93       	push	r16
    a566:	1f 93       	push	r17
    a568:	df 93       	push	r29
    a56a:	cf 93       	push	r28
    a56c:	cd b7       	in	r28, 0x3d	; 61
    a56e:	de b7       	in	r29, 0x3e	; 62
    a570:	2a 97       	sbiw	r28, 0x0a	; 10
    a572:	0f b6       	in	r0, 0x3f	; 63
    a574:	f8 94       	cli
    a576:	de bf       	out	0x3e, r29	; 62
    a578:	0f be       	out	0x3f, r0	; 63
    a57a:	cd bf       	out	0x3d, r28	; 61
    a57c:	6c 01       	movw	r12, r24
    a57e:	7a 01       	movw	r14, r20
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
    a580:	67 37       	cpi	r22, 0x77	; 119
    a582:	09 f4       	brne	.+2      	; 0xa586 <Put_zVal+0x2e>
    a584:	79 c0       	rjmp	.+242    	; 0xa678 <Put_zVal+0x120>
    a586:	8f ef       	ldi	r24, 0xFF	; 255
    a588:	90 e0       	ldi	r25, 0x00	; 0
	if(Param->Txt && Idx<2) {
    a58a:	d7 01       	movw	r26, r14
    a58c:	14 96       	adiw	r26, 0x04	; 4
    a58e:	2d 91       	ld	r18, X+
    a590:	3c 91       	ld	r19, X
    a592:	15 97       	sbiw	r26, 0x05	; 5
    a594:	21 15       	cp	r18, r1
    a596:	31 05       	cpc	r19, r1
    a598:	31 f0       	breq	.+12     	; 0xa5a6 <Put_zVal+0x4e>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_zVal(uint16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
    a59a:	8c 19       	sub	r24, r12
    a59c:	9d 09       	sbc	r25, r13
	if(Param->Txt && Idx<2) {
    a59e:	82 30       	cpi	r24, 0x02	; 2
    a5a0:	91 05       	cpc	r25, r1
    a5a2:	08 f4       	brcc	.+2      	; 0xa5a6 <Put_zVal+0x4e>
    a5a4:	8a c0       	rjmp	.+276    	; 0xa6ba <Put_zVal+0x162>
		Param->Txt += Idx;
		PutEnum(Param);
		return;
	}
	char Format[] = "%0 u.%. u";
    a5a6:	5e 01       	movw	r10, r28
    a5a8:	08 94       	sec
    a5aa:	a1 1c       	adc	r10, r1
    a5ac:	b1 1c       	adc	r11, r1
    a5ae:	d5 01       	movw	r26, r10
    a5b0:	e2 e8       	ldi	r30, 0x82	; 130
    a5b2:	f2 e0       	ldi	r31, 0x02	; 2
    a5b4:	8a e0       	ldi	r24, 0x0A	; 10
    a5b6:	01 90       	ld	r0, Z+
    a5b8:	0d 92       	st	X+, r0
    a5ba:	81 50       	subi	r24, 0x01	; 1
    a5bc:	e1 f7       	brne	.-8      	; 0xa5b6 <Put_zVal+0x5e>
	Format[2] = '0'+Param->Size;
    a5be:	f7 01       	movw	r30, r14
    a5c0:	23 81       	ldd	r18, Z+3	; 0x03
    a5c2:	20 5d       	subi	r18, 0xD0	; 208
    a5c4:	2b 83       	std	Y+3, r18	; 0x03
	if(Param->Prec) {
    a5c6:	92 81       	ldd	r25, Z+2	; 0x02
    a5c8:	99 23       	and	r25, r25
    a5ca:	09 f4       	brne	.+2      	; 0xa5ce <Put_zVal+0x76>
    a5cc:	58 c0       	rjmp	.+176    	; 0xa67e <Put_zVal+0x126>
		Format[2] -= Param->Prec+1;
    a5ce:	89 2f       	mov	r24, r25
    a5d0:	80 95       	com	r24
    a5d2:	82 0f       	add	r24, r18
    a5d4:	8b 83       	std	Y+3, r24	; 0x03
		Format[7] = '0'+Param->Prec;
    a5d6:	90 5d       	subi	r25, 0xD0	; 208
    a5d8:	98 87       	std	Y+8, r25	; 0x08
    a5da:	90 53       	subi	r25, 0x30	; 48
		uint16_t Div=Pow10(Param->Prec);
    a5dc:	29 2f       	mov	r18, r25
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    a5de:	01 e0       	ldi	r16, 0x01	; 1
    a5e0:	10 e0       	ldi	r17, 0x00	; 0
		Pow *= 10;
    a5e2:	c8 01       	movw	r24, r16
    a5e4:	88 0f       	add	r24, r24
    a5e6:	99 1f       	adc	r25, r25
    a5e8:	00 0f       	add	r16, r16
    a5ea:	11 1f       	adc	r17, r17
    a5ec:	00 0f       	add	r16, r16
    a5ee:	11 1f       	adc	r17, r17
    a5f0:	00 0f       	add	r16, r16
    a5f2:	11 1f       	adc	r17, r17
    a5f4:	08 0f       	add	r16, r24
    a5f6:	19 1f       	adc	r17, r25
    a5f8:	21 50       	subi	r18, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    a5fa:	99 f7       	brne	.-26     	; 0xa5e2 <Put_zVal+0x8a>
    a5fc:	c6 01       	movw	r24, r12
    a5fe:	b8 01       	movw	r22, r16
    a600:	0e 94 84 8e 	call	0x11d08	; 0x11d08 <__udivmodhi4>
    a604:	9c 01       	movw	r18, r24
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
    a606:	8d b7       	in	r24, 0x3d	; 61
    a608:	9e b7       	in	r25, 0x3e	; 62
    a60a:	08 97       	sbiw	r24, 0x08	; 8
    a60c:	0f b6       	in	r0, 0x3f	; 63
    a60e:	f8 94       	cli
    a610:	9e bf       	out	0x3e, r25	; 62
    a612:	0f be       	out	0x3f, r0	; 63
    a614:	8d bf       	out	0x3d, r24	; 61
    a616:	ed b7       	in	r30, 0x3d	; 61
    a618:	fe b7       	in	r31, 0x3e	; 62
    a61a:	31 96       	adiw	r30, 0x01	; 1
    a61c:	d7 01       	movw	r26, r14
    a61e:	8d 91       	ld	r24, X+
    a620:	9c 91       	ld	r25, X
    a622:	ad b7       	in	r26, 0x3d	; 61
    a624:	be b7       	in	r27, 0x3e	; 62
    a626:	12 96       	adiw	r26, 0x02	; 2
    a628:	9c 93       	st	X, r25
    a62a:	8e 93       	st	-X, r24
    a62c:	11 97       	sbiw	r26, 0x01	; 1
    a62e:	b3 82       	std	Z+3, r11	; 0x03
    a630:	a2 82       	std	Z+2, r10	; 0x02
    a632:	c6 01       	movw	r24, r12
    a634:	b8 01       	movw	r22, r16
    a636:	0e 94 84 8e 	call	0x11d08	; 0x11d08 <__udivmodhi4>
    a63a:	75 83       	std	Z+5, r23	; 0x05
    a63c:	64 83       	std	Z+4, r22	; 0x04
    a63e:	26 83       	std	Z+6, r18	; 0x06
    a640:	37 83       	std	Z+7, r19	; 0x07
    a642:	0e 94 ef 8b 	call	0x117de	; 0x117de <sprintf>
    a646:	ed b7       	in	r30, 0x3d	; 61
    a648:	fe b7       	in	r31, 0x3e	; 62
    a64a:	38 96       	adiw	r30, 0x08	; 8
    a64c:	0f b6       	in	r0, 0x3f	; 63
    a64e:	f8 94       	cli
    a650:	fe bf       	out	0x3e, r31	; 62
    a652:	0f be       	out	0x3f, r0	; 63
    a654:	ed bf       	out	0x3d, r30	; 61
	}
	else {
		Format[4] = '\0';
		sprintf(Param->Pos, Format, Val);
	}
}
    a656:	2a 96       	adiw	r28, 0x0a	; 10
    a658:	0f b6       	in	r0, 0x3f	; 63
    a65a:	f8 94       	cli
    a65c:	de bf       	out	0x3e, r29	; 62
    a65e:	0f be       	out	0x3f, r0	; 63
    a660:	cd bf       	out	0x3d, r28	; 61
    a662:	cf 91       	pop	r28
    a664:	df 91       	pop	r29
    a666:	1f 91       	pop	r17
    a668:	0f 91       	pop	r16
    a66a:	ff 90       	pop	r15
    a66c:	ef 90       	pop	r14
    a66e:	df 90       	pop	r13
    a670:	cf 90       	pop	r12
    a672:	bf 90       	pop	r11
    a674:	af 90       	pop	r10
    a676:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_zVal(uint16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
    a678:	8f ef       	ldi	r24, 0xFF	; 255
    a67a:	9f ef       	ldi	r25, 0xFF	; 255
    a67c:	86 cf       	rjmp	.-244    	; 0xa58a <Put_zVal+0x32>
		Format[7] = '0'+Param->Prec;
		uint16_t Div=Pow10(Param->Prec);
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
	}
	else {
		Format[4] = '\0';
    a67e:	1d 82       	std	Y+5, r1	; 0x05
		sprintf(Param->Pos, Format, Val);
    a680:	00 d0       	rcall	.+0      	; 0xa682 <Put_zVal+0x12a>
    a682:	00 d0       	rcall	.+0      	; 0xa684 <Put_zVal+0x12c>
    a684:	ed b7       	in	r30, 0x3d	; 61
    a686:	fe b7       	in	r31, 0x3e	; 62
    a688:	31 96       	adiw	r30, 0x01	; 1
    a68a:	d7 01       	movw	r26, r14
    a68c:	8d 91       	ld	r24, X+
    a68e:	9c 91       	ld	r25, X
    a690:	ad b7       	in	r26, 0x3d	; 61
    a692:	be b7       	in	r27, 0x3e	; 62
    a694:	12 96       	adiw	r26, 0x02	; 2
    a696:	9c 93       	st	X, r25
    a698:	8e 93       	st	-X, r24
    a69a:	11 97       	sbiw	r26, 0x01	; 1
    a69c:	b3 82       	std	Z+3, r11	; 0x03
    a69e:	a2 82       	std	Z+2, r10	; 0x02
    a6a0:	d5 82       	std	Z+5, r13	; 0x05
    a6a2:	c4 82       	std	Z+4, r12	; 0x04
    a6a4:	0e 94 ef 8b 	call	0x117de	; 0x117de <sprintf>
    a6a8:	ed b7       	in	r30, 0x3d	; 61
    a6aa:	fe b7       	in	r31, 0x3e	; 62
    a6ac:	36 96       	adiw	r30, 0x06	; 6
    a6ae:	0f b6       	in	r0, 0x3f	; 63
    a6b0:	f8 94       	cli
    a6b2:	fe bf       	out	0x3e, r31	; 62
    a6b4:	0f be       	out	0x3f, r0	; 63
    a6b6:	ed bf       	out	0x3d, r30	; 61
    a6b8:	ce cf       	rjmp	.-100    	; 0xa656 <Put_zVal+0xfe>
void
Put_zVal(uint16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
	if(Param->Txt && Idx<2) {
		Param->Txt += Idx;
    a6ba:	88 0f       	add	r24, r24
    a6bc:	99 1f       	adc	r25, r25
    a6be:	28 0f       	add	r18, r24
    a6c0:	39 1f       	adc	r19, r25
    a6c2:	15 96       	adiw	r26, 0x05	; 5
    a6c4:	3c 93       	st	X, r19
    a6c6:	2e 93       	st	-X, r18
    a6c8:	14 97       	sbiw	r26, 0x04	; 4
		PutEnum(Param);
    a6ca:	c7 01       	movw	r24, r14
    a6cc:	0e 94 4f 4b 	call	0x969e	; 0x969e <PutEnum>
    a6d0:	c2 cf       	rjmp	.-124    	; 0xa656 <Put_zVal+0xfe>

0000a6d2 <Put_sVal>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_sVal(int16_t Val, char Type, T_Param *Param)
{
    a6d2:	af 92       	push	r10
    a6d4:	bf 92       	push	r11
    a6d6:	cf 92       	push	r12
    a6d8:	df 92       	push	r13
    a6da:	ef 92       	push	r14
    a6dc:	ff 92       	push	r15
    a6de:	0f 93       	push	r16
    a6e0:	1f 93       	push	r17
    a6e2:	df 93       	push	r29
    a6e4:	cf 93       	push	r28
    a6e6:	cd b7       	in	r28, 0x3d	; 61
    a6e8:	de b7       	in	r29, 0x3e	; 62
    a6ea:	2a 97       	sbiw	r28, 0x0a	; 10
    a6ec:	0f b6       	in	r0, 0x3f	; 63
    a6ee:	f8 94       	cli
    a6f0:	de bf       	out	0x3e, r29	; 62
    a6f2:	0f be       	out	0x3f, r0	; 63
    a6f4:	cd bf       	out	0x3d, r28	; 61
    a6f6:	6c 01       	movw	r12, r24
    a6f8:	7a 01       	movw	r14, r20
	uint16_t Idx = (Type=='w'?0x8000:0x80)+Val;
    a6fa:	67 37       	cpi	r22, 0x77	; 119
    a6fc:	09 f4       	brne	.+2      	; 0xa700 <Put_sVal+0x2e>
    a6fe:	81 c0       	rjmp	.+258    	; 0xa802 <Put_sVal+0x130>
    a700:	80 e8       	ldi	r24, 0x80	; 128
    a702:	90 e0       	ldi	r25, 0x00	; 0
	if(Param->Txt && Idx<2) {
    a704:	d7 01       	movw	r26, r14
    a706:	14 96       	adiw	r26, 0x04	; 4
    a708:	2d 91       	ld	r18, X+
    a70a:	3c 91       	ld	r19, X
    a70c:	15 97       	sbiw	r26, 0x05	; 5
    a70e:	21 15       	cp	r18, r1
    a710:	31 05       	cpc	r19, r1
    a712:	31 f0       	breq	.+12     	; 0xa720 <Put_sVal+0x4e>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_sVal(int16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0x8000:0x80)+Val;
    a714:	8c 0d       	add	r24, r12
    a716:	9d 1d       	adc	r25, r13
	if(Param->Txt && Idx<2) {
    a718:	82 30       	cpi	r24, 0x02	; 2
    a71a:	91 05       	cpc	r25, r1
    a71c:	08 f4       	brcc	.+2      	; 0xa720 <Put_sVal+0x4e>
    a71e:	ac c0       	rjmp	.+344    	; 0xa878 <Put_sVal+0x1a6>
		Param->Txt += Idx;
		PutEnum(Param);
		return;
	}
	char Format[] = "%+ d.%. u";
    a720:	5e 01       	movw	r10, r28
    a722:	08 94       	sec
    a724:	a1 1c       	adc	r10, r1
    a726:	b1 1c       	adc	r11, r1
    a728:	d5 01       	movw	r26, r10
    a72a:	ec e8       	ldi	r30, 0x8C	; 140
    a72c:	f2 e0       	ldi	r31, 0x02	; 2
    a72e:	8a e0       	ldi	r24, 0x0A	; 10
    a730:	01 90       	ld	r0, Z+
    a732:	0d 92       	st	X+, r0
    a734:	81 50       	subi	r24, 0x01	; 1
    a736:	e1 f7       	brne	.-8      	; 0xa730 <Put_sVal+0x5e>
	if(Val==0)
    a738:	c1 14       	cp	r12, r1
    a73a:	d1 04       	cpc	r13, r1
    a73c:	09 f4       	brne	.+2      	; 0xa740 <Put_sVal+0x6e>
    a73e:	64 c0       	rjmp	.+200    	; 0xa808 <Put_sVal+0x136>
		Format[1] = ' ';
	Format[2] = '0'+Param->Size;
    a740:	f7 01       	movw	r30, r14
    a742:	23 81       	ldd	r18, Z+3	; 0x03
    a744:	20 5d       	subi	r18, 0xD0	; 208
    a746:	2b 83       	std	Y+3, r18	; 0x03
	if(Param->Prec) {
    a748:	92 81       	ldd	r25, Z+2	; 0x02
    a74a:	99 23       	and	r25, r25
    a74c:	09 f4       	brne	.+2      	; 0xa750 <Put_sVal+0x7e>
    a74e:	66 c0       	rjmp	.+204    	; 0xa81c <Put_sVal+0x14a>
		Format[2] -= Param->Prec+1;
    a750:	89 2f       	mov	r24, r25
    a752:	80 95       	com	r24
    a754:	82 0f       	add	r24, r18
    a756:	8b 83       	std	Y+3, r24	; 0x03
		Format[7] = '0'+Param->Prec;
    a758:	90 5d       	subi	r25, 0xD0	; 208
    a75a:	98 87       	std	Y+8, r25	; 0x08
    a75c:	90 53       	subi	r25, 0x30	; 48
		int16_t Div=Pow10(Param->Prec);
    a75e:	29 2f       	mov	r18, r25
    a760:	01 e0       	ldi	r16, 0x01	; 1
    a762:	10 e0       	ldi	r17, 0x00	; 0
		Pow *= 10;
    a764:	c8 01       	movw	r24, r16
    a766:	88 0f       	add	r24, r24
    a768:	99 1f       	adc	r25, r25
    a76a:	00 0f       	add	r16, r16
    a76c:	11 1f       	adc	r17, r17
    a76e:	00 0f       	add	r16, r16
    a770:	11 1f       	adc	r17, r17
    a772:	00 0f       	add	r16, r16
    a774:	11 1f       	adc	r17, r17
    a776:	08 0f       	add	r16, r24
    a778:	19 1f       	adc	r17, r25
    a77a:	21 50       	subi	r18, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    a77c:	99 f7       	brne	.-26     	; 0xa764 <Put_sVal+0x92>
    a77e:	c6 01       	movw	r24, r12
    a780:	d7 fc       	sbrc	r13, 7
    a782:	86 c0       	rjmp	.+268    	; 0xa890 <Put_sVal+0x1be>
    a784:	b8 01       	movw	r22, r16
    a786:	0e 94 84 8e 	call	0x11d08	; 0x11d08 <__udivmodhi4>
    a78a:	9c 01       	movw	r18, r24
		sprintf(Param->Pos, Format, Val/Div, (uint16_t)abs(Val)%Div);
    a78c:	8d b7       	in	r24, 0x3d	; 61
    a78e:	9e b7       	in	r25, 0x3e	; 62
    a790:	08 97       	sbiw	r24, 0x08	; 8
    a792:	0f b6       	in	r0, 0x3f	; 63
    a794:	f8 94       	cli
    a796:	9e bf       	out	0x3e, r25	; 62
    a798:	0f be       	out	0x3f, r0	; 63
    a79a:	8d bf       	out	0x3d, r24	; 61
    a79c:	ed b7       	in	r30, 0x3d	; 61
    a79e:	fe b7       	in	r31, 0x3e	; 62
    a7a0:	31 96       	adiw	r30, 0x01	; 1
    a7a2:	d7 01       	movw	r26, r14
    a7a4:	8d 91       	ld	r24, X+
    a7a6:	9c 91       	ld	r25, X
    a7a8:	ad b7       	in	r26, 0x3d	; 61
    a7aa:	be b7       	in	r27, 0x3e	; 62
    a7ac:	12 96       	adiw	r26, 0x02	; 2
    a7ae:	9c 93       	st	X, r25
    a7b0:	8e 93       	st	-X, r24
    a7b2:	11 97       	sbiw	r26, 0x01	; 1
    a7b4:	b3 82       	std	Z+3, r11	; 0x03
    a7b6:	a2 82       	std	Z+2, r10	; 0x02
    a7b8:	c6 01       	movw	r24, r12
    a7ba:	b8 01       	movw	r22, r16
    a7bc:	0e 94 98 8e 	call	0x11d30	; 0x11d30 <__divmodhi4>
    a7c0:	75 83       	std	Z+5, r23	; 0x05
    a7c2:	64 83       	std	Z+4, r22	; 0x04
    a7c4:	26 83       	std	Z+6, r18	; 0x06
    a7c6:	37 83       	std	Z+7, r19	; 0x07
    a7c8:	0e 94 ef 8b 	call	0x117de	; 0x117de <sprintf>
		if(Val<0) {
    a7cc:	ed b7       	in	r30, 0x3d	; 61
    a7ce:	fe b7       	in	r31, 0x3e	; 62
    a7d0:	38 96       	adiw	r30, 0x08	; 8
    a7d2:	0f b6       	in	r0, 0x3f	; 63
    a7d4:	f8 94       	cli
    a7d6:	fe bf       	out	0x3e, r31	; 62
    a7d8:	0f be       	out	0x3f, r0	; 63
    a7da:	ed bf       	out	0x3d, r30	; 61
    a7dc:	d7 fc       	sbrc	r13, 7
    a7de:	3c c0       	rjmp	.+120    	; 0xa858 <Put_sVal+0x186>
	}
	else {
		Format[4] = '\0';
		sprintf(Param->Pos, Format, Val);
	}
}
    a7e0:	2a 96       	adiw	r28, 0x0a	; 10
    a7e2:	0f b6       	in	r0, 0x3f	; 63
    a7e4:	f8 94       	cli
    a7e6:	de bf       	out	0x3e, r29	; 62
    a7e8:	0f be       	out	0x3f, r0	; 63
    a7ea:	cd bf       	out	0x3d, r28	; 61
    a7ec:	cf 91       	pop	r28
    a7ee:	df 91       	pop	r29
    a7f0:	1f 91       	pop	r17
    a7f2:	0f 91       	pop	r16
    a7f4:	ff 90       	pop	r15
    a7f6:	ef 90       	pop	r14
    a7f8:	df 90       	pop	r13
    a7fa:	cf 90       	pop	r12
    a7fc:	bf 90       	pop	r11
    a7fe:	af 90       	pop	r10
    a800:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_sVal(int16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0x8000:0x80)+Val;
    a802:	80 e0       	ldi	r24, 0x00	; 0
    a804:	90 e8       	ldi	r25, 0x80	; 128
    a806:	7e cf       	rjmp	.-260    	; 0xa704 <Put_sVal+0x32>
		PutEnum(Param);
		return;
	}
	char Format[] = "%+ d.%. u";
	if(Val==0)
		Format[1] = ' ';
    a808:	80 e2       	ldi	r24, 0x20	; 32
    a80a:	8a 83       	std	Y+2, r24	; 0x02
	Format[2] = '0'+Param->Size;
    a80c:	f7 01       	movw	r30, r14
    a80e:	23 81       	ldd	r18, Z+3	; 0x03
    a810:	20 5d       	subi	r18, 0xD0	; 208
    a812:	2b 83       	std	Y+3, r18	; 0x03
	if(Param->Prec) {
    a814:	92 81       	ldd	r25, Z+2	; 0x02
    a816:	99 23       	and	r25, r25
    a818:	09 f0       	breq	.+2      	; 0xa81c <Put_sVal+0x14a>
    a81a:	9a cf       	rjmp	.-204    	; 0xa750 <Put_sVal+0x7e>
				Param->Pos++;
			*Param->Pos = '-';
		}
	}
	else {
		Format[4] = '\0';
    a81c:	1d 82       	std	Y+5, r1	; 0x05
		sprintf(Param->Pos, Format, Val);
    a81e:	00 d0       	rcall	.+0      	; 0xa820 <Put_sVal+0x14e>
    a820:	00 d0       	rcall	.+0      	; 0xa822 <Put_sVal+0x150>
    a822:	ed b7       	in	r30, 0x3d	; 61
    a824:	fe b7       	in	r31, 0x3e	; 62
    a826:	31 96       	adiw	r30, 0x01	; 1
    a828:	d7 01       	movw	r26, r14
    a82a:	8d 91       	ld	r24, X+
    a82c:	9c 91       	ld	r25, X
    a82e:	ad b7       	in	r26, 0x3d	; 61
    a830:	be b7       	in	r27, 0x3e	; 62
    a832:	12 96       	adiw	r26, 0x02	; 2
    a834:	9c 93       	st	X, r25
    a836:	8e 93       	st	-X, r24
    a838:	11 97       	sbiw	r26, 0x01	; 1
    a83a:	b3 82       	std	Z+3, r11	; 0x03
    a83c:	a2 82       	std	Z+2, r10	; 0x02
    a83e:	d5 82       	std	Z+5, r13	; 0x05
    a840:	c4 82       	std	Z+4, r12	; 0x04
    a842:	0e 94 ef 8b 	call	0x117de	; 0x117de <sprintf>
    a846:	ed b7       	in	r30, 0x3d	; 61
    a848:	fe b7       	in	r31, 0x3e	; 62
    a84a:	36 96       	adiw	r30, 0x06	; 6
    a84c:	0f b6       	in	r0, 0x3f	; 63
    a84e:	f8 94       	cli
    a850:	fe bf       	out	0x3e, r31	; 62
    a852:	0f be       	out	0x3f, r0	; 63
    a854:	ed bf       	out	0x3d, r30	; 61
    a856:	c4 cf       	rjmp	.-120    	; 0xa7e0 <Put_sVal+0x10e>
		Format[2] -= Param->Prec+1;
		Format[7] = '0'+Param->Prec;
		int16_t Div=Pow10(Param->Prec);
		sprintf(Param->Pos, Format, Val/Div, (uint16_t)abs(Val)%Div);
		if(Val<0) {
			while(*Param->Pos==' ')
    a858:	d7 01       	movw	r26, r14
    a85a:	ed 91       	ld	r30, X+
    a85c:	fc 91       	ld	r31, X
    a85e:	80 81       	ld	r24, Z
    a860:	80 32       	cpi	r24, 0x20	; 32
    a862:	39 f4       	brne	.+14     	; 0xa872 <Put_sVal+0x1a0>
				Param->Pos++;
    a864:	31 96       	adiw	r30, 0x01	; 1
    a866:	d7 01       	movw	r26, r14
    a868:	ed 93       	st	X+, r30
    a86a:	fc 93       	st	X, r31
		Format[2] -= Param->Prec+1;
		Format[7] = '0'+Param->Prec;
		int16_t Div=Pow10(Param->Prec);
		sprintf(Param->Pos, Format, Val/Div, (uint16_t)abs(Val)%Div);
		if(Val<0) {
			while(*Param->Pos==' ')
    a86c:	80 81       	ld	r24, Z
    a86e:	80 32       	cpi	r24, 0x20	; 32
    a870:	c9 f3       	breq	.-14     	; 0xa864 <Put_sVal+0x192>
				Param->Pos++;
			*Param->Pos = '-';
    a872:	8d e2       	ldi	r24, 0x2D	; 45
    a874:	80 83       	st	Z, r24
    a876:	b4 cf       	rjmp	.-152    	; 0xa7e0 <Put_sVal+0x10e>
void
Put_sVal(int16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0x8000:0x80)+Val;
	if(Param->Txt && Idx<2) {
		Param->Txt += Idx;
    a878:	88 0f       	add	r24, r24
    a87a:	99 1f       	adc	r25, r25
    a87c:	28 0f       	add	r18, r24
    a87e:	39 1f       	adc	r19, r25
    a880:	15 96       	adiw	r26, 0x05	; 5
    a882:	3c 93       	st	X, r19
    a884:	2e 93       	st	-X, r18
    a886:	14 97       	sbiw	r26, 0x04	; 4
		PutEnum(Param);
    a888:	c7 01       	movw	r24, r14
    a88a:	0e 94 4f 4b 	call	0x969e	; 0x969e <PutEnum>
    a88e:	a8 cf       	rjmp	.-176    	; 0xa7e0 <Put_sVal+0x10e>
    a890:	88 27       	eor	r24, r24
    a892:	99 27       	eor	r25, r25
    a894:	8c 19       	sub	r24, r12
    a896:	9d 09       	sbc	r25, r13
    a898:	75 cf       	rjmp	.-278    	; 0xa784 <Put_sVal+0xb2>

0000a89a <PutVal>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
PutVal(uint16_t Val, char Type, T_Param *Param)
{
    a89a:	af 92       	push	r10
    a89c:	bf 92       	push	r11
    a89e:	cf 92       	push	r12
    a8a0:	df 92       	push	r13
    a8a2:	ef 92       	push	r14
    a8a4:	ff 92       	push	r15
    a8a6:	0f 93       	push	r16
    a8a8:	1f 93       	push	r17
    a8aa:	df 93       	push	r29
    a8ac:	cf 93       	push	r28
    a8ae:	cd b7       	in	r28, 0x3d	; 61
    a8b0:	de b7       	in	r29, 0x3e	; 62
    a8b2:	29 97       	sbiw	r28, 0x09	; 9
    a8b4:	0f b6       	in	r0, 0x3f	; 63
    a8b6:	f8 94       	cli
    a8b8:	de bf       	out	0x3e, r29	; 62
    a8ba:	0f be       	out	0x3f, r0	; 63
    a8bc:	cd bf       	out	0x3d, r28	; 61
    a8be:	6c 01       	movw	r12, r24
    a8c0:	7a 01       	movw	r14, r20
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
    a8c2:	67 37       	cpi	r22, 0x77	; 119
    a8c4:	09 f4       	brne	.+2      	; 0xa8c8 <PutVal+0x2e>
    a8c6:	79 c0       	rjmp	.+242    	; 0xa9ba <PutVal+0x120>
    a8c8:	8f ef       	ldi	r24, 0xFF	; 255
    a8ca:	90 e0       	ldi	r25, 0x00	; 0
	if(Param->Txt && Idx<2) {
    a8cc:	d7 01       	movw	r26, r14
    a8ce:	14 96       	adiw	r26, 0x04	; 4
    a8d0:	2d 91       	ld	r18, X+
    a8d2:	3c 91       	ld	r19, X
    a8d4:	15 97       	sbiw	r26, 0x05	; 5
    a8d6:	21 15       	cp	r18, r1
    a8d8:	31 05       	cpc	r19, r1
    a8da:	31 f0       	breq	.+12     	; 0xa8e8 <PutVal+0x4e>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
PutVal(uint16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
    a8dc:	8c 19       	sub	r24, r12
    a8de:	9d 09       	sbc	r25, r13
	if(Param->Txt && Idx<2) {
    a8e0:	82 30       	cpi	r24, 0x02	; 2
    a8e2:	91 05       	cpc	r25, r1
    a8e4:	08 f4       	brcc	.+2      	; 0xa8e8 <PutVal+0x4e>
    a8e6:	8a c0       	rjmp	.+276    	; 0xa9fc <PutVal+0x162>
		Param->Txt += Idx;
		PutEnum(Param);
		return;
	}
	char Format[] = "% u.%. u";
    a8e8:	5e 01       	movw	r10, r28
    a8ea:	08 94       	sec
    a8ec:	a1 1c       	adc	r10, r1
    a8ee:	b1 1c       	adc	r11, r1
    a8f0:	d5 01       	movw	r26, r10
    a8f2:	e6 e9       	ldi	r30, 0x96	; 150
    a8f4:	f2 e0       	ldi	r31, 0x02	; 2
    a8f6:	89 e0       	ldi	r24, 0x09	; 9
    a8f8:	01 90       	ld	r0, Z+
    a8fa:	0d 92       	st	X+, r0
    a8fc:	81 50       	subi	r24, 0x01	; 1
    a8fe:	e1 f7       	brne	.-8      	; 0xa8f8 <PutVal+0x5e>
	Format[1] = '0'+Param->Size;
    a900:	f7 01       	movw	r30, r14
    a902:	23 81       	ldd	r18, Z+3	; 0x03
    a904:	20 5d       	subi	r18, 0xD0	; 208
    a906:	2a 83       	std	Y+2, r18	; 0x02
	if(Param->Prec) {
    a908:	92 81       	ldd	r25, Z+2	; 0x02
    a90a:	99 23       	and	r25, r25
    a90c:	09 f4       	brne	.+2      	; 0xa910 <PutVal+0x76>
    a90e:	58 c0       	rjmp	.+176    	; 0xa9c0 <PutVal+0x126>
		Format[1] -= Param->Prec+1;
    a910:	89 2f       	mov	r24, r25
    a912:	80 95       	com	r24
    a914:	82 0f       	add	r24, r18
    a916:	8a 83       	std	Y+2, r24	; 0x02
		Format[6] = '0'+Param->Prec;
    a918:	90 5d       	subi	r25, 0xD0	; 208
    a91a:	9f 83       	std	Y+7, r25	; 0x07
    a91c:	90 53       	subi	r25, 0x30	; 48
		uint16_t Div=Pow10(Param->Prec);
    a91e:	29 2f       	mov	r18, r25
    a920:	01 e0       	ldi	r16, 0x01	; 1
    a922:	10 e0       	ldi	r17, 0x00	; 0
		Pow *= 10;
    a924:	c8 01       	movw	r24, r16
    a926:	88 0f       	add	r24, r24
    a928:	99 1f       	adc	r25, r25
    a92a:	00 0f       	add	r16, r16
    a92c:	11 1f       	adc	r17, r17
    a92e:	00 0f       	add	r16, r16
    a930:	11 1f       	adc	r17, r17
    a932:	00 0f       	add	r16, r16
    a934:	11 1f       	adc	r17, r17
    a936:	08 0f       	add	r16, r24
    a938:	19 1f       	adc	r17, r25
    a93a:	21 50       	subi	r18, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    a93c:	99 f7       	brne	.-26     	; 0xa924 <PutVal+0x8a>
    a93e:	c6 01       	movw	r24, r12
    a940:	b8 01       	movw	r22, r16
    a942:	0e 94 84 8e 	call	0x11d08	; 0x11d08 <__udivmodhi4>
    a946:	9c 01       	movw	r18, r24
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
    a948:	8d b7       	in	r24, 0x3d	; 61
    a94a:	9e b7       	in	r25, 0x3e	; 62
    a94c:	08 97       	sbiw	r24, 0x08	; 8
    a94e:	0f b6       	in	r0, 0x3f	; 63
    a950:	f8 94       	cli
    a952:	9e bf       	out	0x3e, r25	; 62
    a954:	0f be       	out	0x3f, r0	; 63
    a956:	8d bf       	out	0x3d, r24	; 61
    a958:	ed b7       	in	r30, 0x3d	; 61
    a95a:	fe b7       	in	r31, 0x3e	; 62
    a95c:	31 96       	adiw	r30, 0x01	; 1
    a95e:	d7 01       	movw	r26, r14
    a960:	8d 91       	ld	r24, X+
    a962:	9c 91       	ld	r25, X
    a964:	ad b7       	in	r26, 0x3d	; 61
    a966:	be b7       	in	r27, 0x3e	; 62
    a968:	12 96       	adiw	r26, 0x02	; 2
    a96a:	9c 93       	st	X, r25
    a96c:	8e 93       	st	-X, r24
    a96e:	11 97       	sbiw	r26, 0x01	; 1
    a970:	b3 82       	std	Z+3, r11	; 0x03
    a972:	a2 82       	std	Z+2, r10	; 0x02
    a974:	c6 01       	movw	r24, r12
    a976:	b8 01       	movw	r22, r16
    a978:	0e 94 84 8e 	call	0x11d08	; 0x11d08 <__udivmodhi4>
    a97c:	75 83       	std	Z+5, r23	; 0x05
    a97e:	64 83       	std	Z+4, r22	; 0x04
    a980:	26 83       	std	Z+6, r18	; 0x06
    a982:	37 83       	std	Z+7, r19	; 0x07
    a984:	0e 94 ef 8b 	call	0x117de	; 0x117de <sprintf>
    a988:	ed b7       	in	r30, 0x3d	; 61
    a98a:	fe b7       	in	r31, 0x3e	; 62
    a98c:	38 96       	adiw	r30, 0x08	; 8
    a98e:	0f b6       	in	r0, 0x3f	; 63
    a990:	f8 94       	cli
    a992:	fe bf       	out	0x3e, r31	; 62
    a994:	0f be       	out	0x3f, r0	; 63
    a996:	ed bf       	out	0x3d, r30	; 61
	}
	else {
		Format[3] = '\0';
		sprintf(Param->Pos, Format, Val);
	}
}
    a998:	29 96       	adiw	r28, 0x09	; 9
    a99a:	0f b6       	in	r0, 0x3f	; 63
    a99c:	f8 94       	cli
    a99e:	de bf       	out	0x3e, r29	; 62
    a9a0:	0f be       	out	0x3f, r0	; 63
    a9a2:	cd bf       	out	0x3d, r28	; 61
    a9a4:	cf 91       	pop	r28
    a9a6:	df 91       	pop	r29
    a9a8:	1f 91       	pop	r17
    a9aa:	0f 91       	pop	r16
    a9ac:	ff 90       	pop	r15
    a9ae:	ef 90       	pop	r14
    a9b0:	df 90       	pop	r13
    a9b2:	cf 90       	pop	r12
    a9b4:	bf 90       	pop	r11
    a9b6:	af 90       	pop	r10
    a9b8:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
PutVal(uint16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
    a9ba:	8f ef       	ldi	r24, 0xFF	; 255
    a9bc:	9f ef       	ldi	r25, 0xFF	; 255
    a9be:	86 cf       	rjmp	.-244    	; 0xa8cc <PutVal+0x32>
		Format[6] = '0'+Param->Prec;
		uint16_t Div=Pow10(Param->Prec);
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
	}
	else {
		Format[3] = '\0';
    a9c0:	1c 82       	std	Y+4, r1	; 0x04
		sprintf(Param->Pos, Format, Val);
    a9c2:	00 d0       	rcall	.+0      	; 0xa9c4 <PutVal+0x12a>
    a9c4:	00 d0       	rcall	.+0      	; 0xa9c6 <PutVal+0x12c>
    a9c6:	ed b7       	in	r30, 0x3d	; 61
    a9c8:	fe b7       	in	r31, 0x3e	; 62
    a9ca:	31 96       	adiw	r30, 0x01	; 1
    a9cc:	d7 01       	movw	r26, r14
    a9ce:	8d 91       	ld	r24, X+
    a9d0:	9c 91       	ld	r25, X
    a9d2:	ad b7       	in	r26, 0x3d	; 61
    a9d4:	be b7       	in	r27, 0x3e	; 62
    a9d6:	12 96       	adiw	r26, 0x02	; 2
    a9d8:	9c 93       	st	X, r25
    a9da:	8e 93       	st	-X, r24
    a9dc:	11 97       	sbiw	r26, 0x01	; 1
    a9de:	b3 82       	std	Z+3, r11	; 0x03
    a9e0:	a2 82       	std	Z+2, r10	; 0x02
    a9e2:	d5 82       	std	Z+5, r13	; 0x05
    a9e4:	c4 82       	std	Z+4, r12	; 0x04
    a9e6:	0e 94 ef 8b 	call	0x117de	; 0x117de <sprintf>
    a9ea:	ed b7       	in	r30, 0x3d	; 61
    a9ec:	fe b7       	in	r31, 0x3e	; 62
    a9ee:	36 96       	adiw	r30, 0x06	; 6
    a9f0:	0f b6       	in	r0, 0x3f	; 63
    a9f2:	f8 94       	cli
    a9f4:	fe bf       	out	0x3e, r31	; 62
    a9f6:	0f be       	out	0x3f, r0	; 63
    a9f8:	ed bf       	out	0x3d, r30	; 61
    a9fa:	ce cf       	rjmp	.-100    	; 0xa998 <PutVal+0xfe>
void
PutVal(uint16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
	if(Param->Txt && Idx<2) {
		Param->Txt += Idx;
    a9fc:	88 0f       	add	r24, r24
    a9fe:	99 1f       	adc	r25, r25
    aa00:	28 0f       	add	r18, r24
    aa02:	39 1f       	adc	r19, r25
    aa04:	15 96       	adiw	r26, 0x05	; 5
    aa06:	3c 93       	st	X, r19
    aa08:	2e 93       	st	-X, r18
    aa0a:	14 97       	sbiw	r26, 0x04	; 4
		PutEnum(Param);
    aa0c:	c7 01       	movw	r24, r14
    aa0e:	0e 94 4f 4b 	call	0x969e	; 0x969e <PutEnum>
    aa12:	c2 cf       	rjmp	.-124    	; 0xa998 <PutVal+0xfe>

0000aa14 <GSM_Wait_Response_P>:
//	}
	if(strcmp(GSM_RxStr, Str))return 0;
	else return 1;
}
// ~~~~~~~~~
uint8_t GSM_Wait_Response_P(prog_char *Str_P, uint8_t RestoreCMD){
    aa14:	1f 93       	push	r17
    aa16:	cf 93       	push	r28
    aa18:	df 93       	push	r29
    aa1a:	ec 01       	movw	r28, r24
    aa1c:	16 2f       	mov	r17, r22
	
	if(Timer16Stopp(TD_GSM) && RestoreCMD){
    aa1e:	80 91 e9 04 	lds	r24, 0x04E9
    aa22:	0e 94 96 25 	call	0x4b2c	; 0x4b2c <Timer16Stopp>
    aa26:	88 23       	and	r24, r24
    aa28:	11 f0       	breq	.+4      	; 0xaa2e <GSM_Wait_Response_P+0x1a>
    aa2a:	11 23       	and	r17, r17
    aa2c:	51 f4       	brne	.+20     	; 0xaa42 <GSM_Wait_Response_P+0x2e>
		GSM_State = RestoreCMD;
		return 0;
	}
	//  
	if(GetStringFromFIFO()){
    aa2e:	0e 94 10 42 	call	0x8420	; 0x8420 <GetStringFromFIFO>
    aa32:	88 23       	and	r24, r24
    aa34:	71 f4       	brne	.+28     	; 0xaa52 <GSM_Wait_Response_P+0x3e>
    aa36:	20 e0       	ldi	r18, 0x00	; 0
		if(strcmp_P(GSM_RxStr, Str_P)) return 0;
		else return 1;
	}
	else return 0;
}
    aa38:	82 2f       	mov	r24, r18
    aa3a:	df 91       	pop	r29
    aa3c:	cf 91       	pop	r28
    aa3e:	1f 91       	pop	r17
    aa40:	08 95       	ret
}
// ~~~~~~~~~
uint8_t GSM_Wait_Response_P(prog_char *Str_P, uint8_t RestoreCMD){
	
	if(Timer16Stopp(TD_GSM) && RestoreCMD){
		GSM_State = RestoreCMD;
    aa42:	10 93 f6 06 	sts	0x06F6, r17
    aa46:	20 e0       	ldi	r18, 0x00	; 0
	if(GetStringFromFIFO()){
		if(strcmp_P(GSM_RxStr, Str_P)) return 0;
		else return 1;
	}
	else return 0;
}
    aa48:	82 2f       	mov	r24, r18
    aa4a:	df 91       	pop	r29
    aa4c:	cf 91       	pop	r28
    aa4e:	1f 91       	pop	r17
    aa50:	08 95       	ret
		GSM_State = RestoreCMD;
		return 0;
	}
	//  
	if(GetStringFromFIFO()){
		if(strcmp_P(GSM_RxStr, Str_P)) return 0;
    aa52:	81 ee       	ldi	r24, 0xE1	; 225
    aa54:	97 e0       	ldi	r25, 0x07	; 7
    aa56:	be 01       	movw	r22, r28
    aa58:	0e 94 f3 8a 	call	0x115e6	; 0x115e6 <strcmp_P>
    aa5c:	20 e0       	ldi	r18, 0x00	; 0
    aa5e:	89 2b       	or	r24, r25
    aa60:	59 f7       	brne	.-42     	; 0xaa38 <GSM_Wait_Response_P+0x24>
    aa62:	21 e0       	ldi	r18, 0x01	; 1
		else return 1;
	}
	else return 0;
}
    aa64:	82 2f       	mov	r24, r18
    aa66:	df 91       	pop	r29
    aa68:	cf 91       	pop	r28
    aa6a:	1f 91       	pop	r17
    aa6c:	08 95       	ret

0000aa6e <GSM_SendCR>:
	
	sei();	
}
// ~~~~~~~~~
//   + CR
void GSM_SendCR(prog_char *Str_P){
    aa6e:	ef 92       	push	r14
    aa70:	ff 92       	push	r15
    aa72:	0f 93       	push	r16
    aa74:	1f 93       	push	r17
    aa76:	7c 01       	movw	r14, r24
	GSMTxSz = strlen_P(Str_P);
    aa78:	0e 94 03 8b 	call	0x11606	; 0x11606 <strlen_P>
    aa7c:	80 93 bb 07 	sts	0x07BB, r24
	sprintf_P(GSM_TxStr, Str_P);
    aa80:	00 d0       	rcall	.+0      	; 0xaa82 <GSM_SendCR+0x14>
    aa82:	0f 92       	push	r0
    aa84:	0a e4       	ldi	r16, 0x4A	; 74
    aa86:	1a e0       	ldi	r17, 0x0A	; 10
    aa88:	ed b7       	in	r30, 0x3d	; 61
    aa8a:	fe b7       	in	r31, 0x3e	; 62
    aa8c:	12 83       	std	Z+2, r17	; 0x02
    aa8e:	01 83       	std	Z+1, r16	; 0x01
    aa90:	f4 82       	std	Z+4, r15	; 0x04
    aa92:	e3 82       	std	Z+3, r14	; 0x03
    aa94:	0e 94 20 8c 	call	0x11840	; 0x11840 <sprintf_P>
	sprintf(GSM_TxStr + GSMTxSz, "\r");
    aa98:	80 91 bb 07 	lds	r24, 0x07BB
    aa9c:	08 0f       	add	r16, r24
    aa9e:	11 1d       	adc	r17, r1
    aaa0:	8d e0       	ldi	r24, 0x0D	; 13
    aaa2:	90 e0       	ldi	r25, 0x00	; 0
    aaa4:	f8 01       	movw	r30, r16
    aaa6:	91 83       	std	Z+1, r25	; 0x01
    aaa8:	80 83       	st	Z, r24
	GSMTxSz++;
    aaaa:	80 91 bb 07 	lds	r24, 0x07BB
    aaae:	8f 5f       	subi	r24, 0xFF	; 255
    aab0:	80 93 bb 07 	sts	0x07BB, r24
	GSM_SendFirstChar();
    aab4:	0f 90       	pop	r0
    aab6:	0f 90       	pop	r0
    aab8:	0f 90       	pop	r0
    aaba:	0f 90       	pop	r0
    aabc:	0e 94 3a 43 	call	0x8674	; 0x8674 <GSM_SendFirstChar>
}
    aac0:	1f 91       	pop	r17
    aac2:	0f 91       	pop	r16
    aac4:	ff 90       	pop	r15
    aac6:	ef 90       	pop	r14
    aac8:	08 95       	ret

0000aaca <GSM_Execute_Command>:
	GSMTxSz = Size;
	memcpy(GSM_TxStr, Data_Out, GSMTxSz);
	GSM_SendFirstChar();
}
// ~~~~~~~~~
void GSM_Execute_Command(prog_char *Str_P, uint16_t Timeout){
    aaca:	cf 93       	push	r28
    aacc:	df 93       	push	r29
    aace:	9c 01       	movw	r18, r24
    aad0:	eb 01       	movw	r28, r22
	if(GSM_Flag & (1<<flg_TxCStr)){
    aad2:	80 91 d2 02 	lds	r24, 0x02D2
    aad6:	80 ff       	sbrs	r24, 0
    aad8:	08 c0       	rjmp	.+16     	; 0xaaea <GSM_Execute_Command+0x20>
		GSM_SendCR(Str_P);
    aada:	c9 01       	movw	r24, r18
    aadc:	0e 94 37 55 	call	0xaa6e	; 0xaa6e <GSM_SendCR>
		StartTimer16(TD_GSM, Timeout);
    aae0:	80 91 e9 04 	lds	r24, 0x04E9
    aae4:	be 01       	movw	r22, r28
    aae6:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
	}
}
    aaea:	df 91       	pop	r29
    aaec:	cf 91       	pop	r28
    aaee:	08 95       	ret

0000aaf0 <analize_DTMF>:
uint8_t GSM_GotoNextVega(void){
 return 0;
}
uint8_t counter=0;
uint8_t analize_DTMF(){
	if((strstr_P(GSM_RxStr, PSTR("+DTMF: 1")) != NULL) ){
    aaf0:	81 ee       	ldi	r24, 0xE1	; 225
    aaf2:	97 e0       	ldi	r25, 0x07	; 7
    aaf4:	63 e8       	ldi	r22, 0x83	; 131
    aaf6:	70 e4       	ldi	r23, 0x40	; 64
    aaf8:	0e 94 25 8b 	call	0x1164a	; 0x1164a <strstr_P>
    aafc:	89 2b       	or	r24, r25
    aafe:	59 f0       	breq	.+22     	; 0xab16 <analize_DTMF+0x26>
		StartTimer16(TD_GSM,1000);
    ab00:	80 91 e9 04 	lds	r24, 0x04E9
    ab04:	68 ee       	ldi	r22, 0xE8	; 232
    ab06:	73 e0       	ldi	r23, 0x03	; 3
    ab08:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
		GSM_State = GSM_SEND_CREC_5;
    ab0c:	8b e1       	ldi	r24, 0x1B	; 27
    ab0e:	80 93 f6 06 	sts	0x06F6, r24
    ab12:	81 e0       	ldi	r24, 0x01	; 1
    ab14:	08 95       	ret
		return 1;
	}
	if((strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 2,0,6")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 3,0,6")) != NULL) ){
    ab16:	81 ee       	ldi	r24, 0xE1	; 225
    ab18:	97 e0       	ldi	r25, 0x07	; 7
    ab1a:	66 e7       	ldi	r22, 0x76	; 118
    ab1c:	70 e4       	ldi	r23, 0x40	; 64
    ab1e:	0e 94 25 8b 	call	0x1164a	; 0x1164a <strstr_P>
    ab22:	89 2b       	or	r24, r25
    ab24:	59 f0       	breq	.+22     	; 0xab3c <analize_DTMF+0x4c>
		StartTimer16(TD_GSM,2000);
    ab26:	80 91 e9 04 	lds	r24, 0x04E9
    ab2a:	60 ed       	ldi	r22, 0xD0	; 208
    ab2c:	77 e0       	ldi	r23, 0x07	; 7
    ab2e:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
		GSM_State = GSM_WAIT_DISCONNECT_CAUSE;
    ab32:	85 e2       	ldi	r24, 0x25	; 37
    ab34:	80 93 f6 06 	sts	0x06F6, r24
    ab38:	81 e0       	ldi	r24, 0x01	; 1
		return 1;
	}
	return 0;
}
    ab3a:	08 95       	ret
	if((strstr_P(GSM_RxStr, PSTR("+DTMF: 1")) != NULL) ){
		StartTimer16(TD_GSM,1000);
		GSM_State = GSM_SEND_CREC_5;
		return 1;
	}
	if((strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 2,0,6")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 3,0,6")) != NULL) ){
    ab3c:	81 ee       	ldi	r24, 0xE1	; 225
    ab3e:	97 e0       	ldi	r25, 0x07	; 7
    ab40:	69 e6       	ldi	r22, 0x69	; 105
    ab42:	70 e4       	ldi	r23, 0x40	; 64
    ab44:	0e 94 25 8b 	call	0x1164a	; 0x1164a <strstr_P>
    ab48:	89 2b       	or	r24, r25
    ab4a:	69 f7       	brne	.-38     	; 0xab26 <analize_DTMF+0x36>
    ab4c:	81 ee       	ldi	r24, 0xE1	; 225
    ab4e:	97 e0       	ldi	r25, 0x07	; 7
    ab50:	6c e5       	ldi	r22, 0x5C	; 92
    ab52:	70 e4       	ldi	r23, 0x40	; 64
    ab54:	0e 94 25 8b 	call	0x1164a	; 0x1164a <strstr_P>
    ab58:	89 2b       	or	r24, r25
    ab5a:	29 f7       	brne	.-54     	; 0xab26 <analize_DTMF+0x36>
    ab5c:	80 e0       	ldi	r24, 0x00	; 0
    ab5e:	08 95       	ret

0000ab60 <GSM_Wait_Response>:
	#endif

}
// ~~~~~~~~~
//   GetStringFromFIFO()!
uint8_t GSM_Wait_Response(char *Str, uint8_t RestoreCMD){
    ab60:	bc 01       	movw	r22, r24
//	if(Timer16Stopp(TD_GSM) && RestoreCMD){
//		GSM_State = RestoreCMD;
//		return 0;
//	}
	if(strcmp(GSM_RxStr, Str))return 0;
    ab62:	81 ee       	ldi	r24, 0xE1	; 225
    ab64:	97 e0       	ldi	r25, 0x07	; 7
    ab66:	0e 94 53 8b 	call	0x116a6	; 0x116a6 <strcmp>
    ab6a:	9c 01       	movw	r18, r24
    ab6c:	80 e0       	ldi	r24, 0x00	; 0
    ab6e:	23 2b       	or	r18, r19
    ab70:	09 f4       	brne	.+2      	; 0xab74 <GSM_Wait_Response+0x14>
    ab72:	81 e0       	ldi	r24, 0x01	; 1
	else return 1;
}
    ab74:	08 95       	ret

0000ab76 <DigiFilt>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
DigiFilt(const uint16_t *Array, uint8_t Edge)
{
    ab76:	6f 92       	push	r6
    ab78:	7f 92       	push	r7
    ab7a:	8f 92       	push	r8
    ab7c:	9f 92       	push	r9
    ab7e:	bf 92       	push	r11
    ab80:	cf 92       	push	r12
    ab82:	df 92       	push	r13
    ab84:	ef 92       	push	r14
    ab86:	ff 92       	push	r15
    ab88:	0f 93       	push	r16
    ab8a:	1f 93       	push	r17
    ab8c:	df 93       	push	r29
    ab8e:	cf 93       	push	r28
    ab90:	cd b7       	in	r28, 0x3d	; 61
    ab92:	de b7       	in	r29, 0x3e	; 62
    ab94:	28 2f       	mov	r18, r24
    ab96:	79 2f       	mov	r23, r25
    ab98:	e6 2e       	mov	r14, r22
				Buf[i] = Buf[j];
				Buf[j] = Swap;
			}
	for(i=Edge; i<_Edge; Sum+=Buf[i++]);
	return Sum/(Edge*2);
}
    ab9a:	6d b6       	in	r6, 0x3d	; 61
    ab9c:	7e b6       	in	r7, 0x3e	; 62

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
DigiFilt(const uint16_t *Array, uint8_t Edge)
{
	uint8_t Sz = Edge*4;
    ab9e:	86 2e       	mov	r8, r22
    aba0:	99 24       	eor	r9, r9
    aba2:	f6 2e       	mov	r15, r22
    aba4:	ff 0c       	add	r15, r15
    aba6:	ff 0c       	add	r15, r15
	uint8_t _Edge = Sz-Edge;
    aba8:	bf 2c       	mov	r11, r15
    abaa:	b6 1a       	sub	r11, r22
	uint16_t Buf[Sz];
    abac:	ef 2d       	mov	r30, r15
    abae:	f0 e0       	ldi	r31, 0x00	; 0
    abb0:	ee 0f       	add	r30, r30
    abb2:	ff 1f       	adc	r31, r31
    abb4:	8d b7       	in	r24, 0x3d	; 61
    abb6:	9e b7       	in	r25, 0x3e	; 62
    abb8:	8e 1b       	sub	r24, r30
    abba:	9f 0b       	sbc	r25, r31
    abbc:	0f b6       	in	r0, 0x3f	; 63
    abbe:	f8 94       	cli
    abc0:	9e bf       	out	0x3e, r25	; 62
    abc2:	0f be       	out	0x3f, r0	; 63
    abc4:	8d bf       	out	0x3d, r24	; 61
    abc6:	0d b7       	in	r16, 0x3d	; 61
    abc8:	1e b7       	in	r17, 0x3e	; 62
    abca:	0f 5f       	subi	r16, 0xFF	; 255
    abcc:	1f 4f       	sbci	r17, 0xFF	; 255
	uint32_t Sum = 0;
	uint16_t Swap;
	uint8_t i, j;
	memcpy(Buf, Array, Sz*2);
    abce:	c8 01       	movw	r24, r16
    abd0:	62 2f       	mov	r22, r18
    abd2:	af 01       	movw	r20, r30
    abd4:	0e 94 3f 8b 	call	0x1167e	; 0x1167e <memcpy>
	for(i=0; i<Edge; i++)
    abd8:	ee 20       	and	r14, r14
    abda:	09 f1       	breq	.+66     	; 0xac1e <DigiFilt+0xa8>
    abdc:	d8 01       	movw	r26, r16
    abde:	80 e0       	ldi	r24, 0x00	; 0
		for(j=i+1; j<Sz; j++)
    abe0:	58 2f       	mov	r21, r24
    abe2:	5f 5f       	subi	r21, 0xFF	; 255
    abe4:	5f 15       	cp	r21, r15
    abe6:	b8 f4       	brcc	.+46     	; 0xac16 <DigiFilt+0xa0>
    abe8:	45 2f       	mov	r20, r21
			if(Buf[j] < Buf[i]) {
    abea:	e4 2f       	mov	r30, r20
    abec:	f0 e0       	ldi	r31, 0x00	; 0
    abee:	ee 0f       	add	r30, r30
    abf0:	ff 1f       	adc	r31, r31
    abf2:	e0 0f       	add	r30, r16
    abf4:	f1 1f       	adc	r31, r17
    abf6:	20 81       	ld	r18, Z
    abf8:	31 81       	ldd	r19, Z+1	; 0x01
    abfa:	8d 91       	ld	r24, X+
    abfc:	9c 91       	ld	r25, X
    abfe:	11 97       	sbiw	r26, 0x01	; 1
    ac00:	28 17       	cp	r18, r24
    ac02:	39 07       	cpc	r19, r25
    ac04:	28 f4       	brcc	.+10     	; 0xac10 <DigiFilt+0x9a>
				Swap = Buf[i];
				Buf[i] = Buf[j];
    ac06:	11 96       	adiw	r26, 0x01	; 1
    ac08:	3c 93       	st	X, r19
    ac0a:	2e 93       	st	-X, r18
				Buf[j] = Swap;
    ac0c:	91 83       	std	Z+1, r25	; 0x01
    ac0e:	80 83       	st	Z, r24
	uint32_t Sum = 0;
	uint16_t Swap;
	uint8_t i, j;
	memcpy(Buf, Array, Sz*2);
	for(i=0; i<Edge; i++)
		for(j=i+1; j<Sz; j++)
    ac10:	4f 5f       	subi	r20, 0xFF	; 255
    ac12:	4f 15       	cp	r20, r15
    ac14:	50 f3       	brcs	.-44     	; 0xabea <DigiFilt+0x74>
    ac16:	12 96       	adiw	r26, 0x02	; 2
    ac18:	85 2f       	mov	r24, r21
	uint16_t Buf[Sz];
	uint32_t Sum = 0;
	uint16_t Swap;
	uint8_t i, j;
	memcpy(Buf, Array, Sz*2);
	for(i=0; i<Edge; i++)
    ac1a:	5e 15       	cp	r21, r14
    ac1c:	08 f3       	brcs	.-62     	; 0xabe0 <DigiFilt+0x6a>
			if(Buf[j] < Buf[i]) {
				Swap = Buf[i];
				Buf[i] = Buf[j];
				Buf[j] = Swap;
			}
	for(i=Sz-1; i>=_Edge; i--)
    ac1e:	ef 2d       	mov	r30, r15
    ac20:	e1 50       	subi	r30, 0x01	; 1
    ac22:	eb 15       	cp	r30, r11
    ac24:	10 f1       	brcs	.+68     	; 0xac6a <DigiFilt+0xf4>
		for(j=i-1; j>=Edge; j--)
    ac26:	5e 2f       	mov	r21, r30
    ac28:	51 50       	subi	r21, 0x01	; 1
    ac2a:	5e 15       	cp	r21, r14
    ac2c:	d8 f0       	brcs	.+54     	; 0xac64 <DigiFilt+0xee>
    ac2e:	f0 e0       	ldi	r31, 0x00	; 0
    ac30:	45 2f       	mov	r20, r21
    ac32:	ee 0f       	add	r30, r30
    ac34:	ff 1f       	adc	r31, r31
			if(Buf[j] > Buf[i]) {
    ac36:	e0 0f       	add	r30, r16
    ac38:	f1 1f       	adc	r31, r17
    ac3a:	a4 2f       	mov	r26, r20
    ac3c:	b0 e0       	ldi	r27, 0x00	; 0
    ac3e:	aa 0f       	add	r26, r26
    ac40:	bb 1f       	adc	r27, r27
    ac42:	a0 0f       	add	r26, r16
    ac44:	b1 1f       	adc	r27, r17
    ac46:	2d 91       	ld	r18, X+
    ac48:	3c 91       	ld	r19, X
    ac4a:	11 97       	sbiw	r26, 0x01	; 1
    ac4c:	80 81       	ld	r24, Z
    ac4e:	91 81       	ldd	r25, Z+1	; 0x01
    ac50:	82 17       	cp	r24, r18
    ac52:	93 07       	cpc	r25, r19
    ac54:	20 f4       	brcc	.+8      	; 0xac5e <DigiFilt+0xe8>
				Swap = Buf[i];
				Buf[i] = Buf[j];
    ac56:	31 83       	std	Z+1, r19	; 0x01
    ac58:	20 83       	st	Z, r18
				Buf[j] = Swap;
    ac5a:	8d 93       	st	X+, r24
    ac5c:	9c 93       	st	X, r25
				Swap = Buf[i];
				Buf[i] = Buf[j];
				Buf[j] = Swap;
			}
	for(i=Sz-1; i>=_Edge; i--)
		for(j=i-1; j>=Edge; j--)
    ac5e:	41 50       	subi	r20, 0x01	; 1
    ac60:	4e 15       	cp	r20, r14
    ac62:	58 f7       	brcc	.-42     	; 0xac3a <DigiFilt+0xc4>
    ac64:	e5 2f       	mov	r30, r21
			if(Buf[j] < Buf[i]) {
				Swap = Buf[i];
				Buf[i] = Buf[j];
				Buf[j] = Swap;
			}
	for(i=Sz-1; i>=_Edge; i--)
    ac66:	5b 15       	cp	r21, r11
    ac68:	f0 f6       	brcc	.-68     	; 0xac26 <DigiFilt+0xb0>
			if(Buf[j] > Buf[i]) {
				Swap = Buf[i];
				Buf[i] = Buf[j];
				Buf[j] = Swap;
			}
	for(i=Edge; i<_Edge; Sum+=Buf[i++]);
    ac6a:	eb 14       	cp	r14, r11
    ac6c:	a0 f5       	brcc	.+104    	; 0xacd6 <DigiFilt+0x160>
    ac6e:	6e 2d       	mov	r22, r14
    ac70:	cc 24       	eor	r12, r12
    ac72:	dd 24       	eor	r13, r13
    ac74:	76 01       	movw	r14, r12
    ac76:	e6 2f       	mov	r30, r22
    ac78:	f0 e0       	ldi	r31, 0x00	; 0
    ac7a:	ee 0f       	add	r30, r30
    ac7c:	ff 1f       	adc	r31, r31
    ac7e:	e0 0f       	add	r30, r16
    ac80:	f1 1f       	adc	r31, r17
    ac82:	80 81       	ld	r24, Z
    ac84:	91 81       	ldd	r25, Z+1	; 0x01
    ac86:	a0 e0       	ldi	r26, 0x00	; 0
    ac88:	b0 e0       	ldi	r27, 0x00	; 0
    ac8a:	c8 0e       	add	r12, r24
    ac8c:	d9 1e       	adc	r13, r25
    ac8e:	ea 1e       	adc	r14, r26
    ac90:	fb 1e       	adc	r15, r27
    ac92:	6f 5f       	subi	r22, 0xFF	; 255
    ac94:	6b 15       	cp	r22, r11
    ac96:	78 f3       	brcs	.-34     	; 0xac76 <DigiFilt+0x100>
    ac98:	88 0c       	add	r8, r8
    ac9a:	99 1c       	adc	r9, r9
    ac9c:	94 01       	movw	r18, r8
    ac9e:	44 27       	eor	r20, r20
    aca0:	37 fd       	sbrc	r19, 7
    aca2:	40 95       	com	r20
    aca4:	54 2f       	mov	r21, r20
    aca6:	c7 01       	movw	r24, r14
    aca8:	b6 01       	movw	r22, r12
    acaa:	0e 94 ab 8e 	call	0x11d56	; 0x11d56 <__udivmodsi4>
    acae:	c9 01       	movw	r24, r18
	return Sum/(Edge*2);
}
    acb0:	0f b6       	in	r0, 0x3f	; 63
    acb2:	f8 94       	cli
    acb4:	7e be       	out	0x3e, r7	; 62
    acb6:	0f be       	out	0x3f, r0	; 63
    acb8:	6d be       	out	0x3d, r6	; 61
    acba:	cf 91       	pop	r28
    acbc:	df 91       	pop	r29
    acbe:	1f 91       	pop	r17
    acc0:	0f 91       	pop	r16
    acc2:	ff 90       	pop	r15
    acc4:	ef 90       	pop	r14
    acc6:	df 90       	pop	r13
    acc8:	cf 90       	pop	r12
    acca:	bf 90       	pop	r11
    accc:	9f 90       	pop	r9
    acce:	8f 90       	pop	r8
    acd0:	7f 90       	pop	r7
    acd2:	6f 90       	pop	r6
    acd4:	08 95       	ret
			if(Buf[j] > Buf[i]) {
				Swap = Buf[i];
				Buf[i] = Buf[j];
				Buf[j] = Swap;
			}
	for(i=Edge; i<_Edge; Sum+=Buf[i++]);
    acd6:	cc 24       	eor	r12, r12
    acd8:	dd 24       	eor	r13, r13
    acda:	76 01       	movw	r14, r12
    acdc:	dd cf       	rjmp	.-70     	; 0xac98 <DigiFilt+0x122>

0000acde <MemFailReset>:

// ~~~~~~~~~~~~~~~
void
MemFailReset(void)
{
	if (MemFail &(1<<MemFail_EEPROM)) {
    acde:	80 91 17 09 	lds	r24, 0x0917
    ace2:	81 ff       	sbrs	r24, 1
    ace4:	08 95       	ret
		MemFail &=~(1<<MemFail_EEPROM);
    ace6:	8d 7f       	andi	r24, 0xFD	; 253
    ace8:	80 93 17 09 	sts	0x0917, r24
		eeprom_write_word(&MemCheck_stor.CRC_EEPROM_stor, CRC_EEPROM_calc());
    acec:	0e 94 35 23 	call	0x466a	; 0x466a <CRC_EEPROM_calc>
    acf0:	bc 01       	movw	r22, r24
    acf2:	8a e9       	ldi	r24, 0x9A	; 154
    acf4:	91 e0       	ldi	r25, 0x01	; 1
    acf6:	0e 94 51 8e 	call	0x11ca2	; 0x11ca2 <__eewr_word_m2560>
    acfa:	08 95       	ret

0000acfc <Key_Mem>:
		MenuPage Menu_BackUp = { SetMenu(Menu_BackUp_List), 1, NULL,
				NULL, NULL, NULL, Menu_BackUp_Enter, NULL, NULL, NULL};
#endif

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t Key_Mem(void) {if(CurrLine==3) MemFailReset(); return StandartKey;}
    acfc:	80 91 ca 07 	lds	r24, 0x07CA
    ad00:	83 30       	cpi	r24, 0x03	; 3
    ad02:	11 f0       	breq	.+4      	; 0xad08 <Key_Mem+0xc>
    ad04:	80 e0       	ldi	r24, 0x00	; 0
    ad06:	08 95       	ret
    ad08:	0e 94 6f 56 	call	0xacde	; 0xacde <MemFailReset>
    ad0c:	80 e0       	ldi	r24, 0x00	; 0
    ad0e:	08 95       	ret

0000ad10 <CRC_EEPROM_upd>:
// ~~~~~~~~~~~~~~~~~
// Duration: 48 ms
static void
CRC_EEPROM_upd(void)
{
	if (!(MemFail &(1<<MemFail_EEPROM)))
    ad10:	80 91 17 09 	lds	r24, 0x0917
    ad14:	81 fd       	sbrc	r24, 1
    ad16:	08 95       	ret
		eeprom_write_word(&MemCheck_stor.CRC_EEPROM_stor, CRC_EEPROM_calc());
    ad18:	0e 94 35 23 	call	0x466a	; 0x466a <CRC_EEPROM_calc>
    ad1c:	bc 01       	movw	r22, r24
    ad1e:	8a e9       	ldi	r24, 0x9A	; 154
    ad20:	91 e0       	ldi	r25, 0x01	; 1
    ad22:	0e 94 51 8e 	call	0x11ca2	; 0x11ca2 <__eewr_word_m2560>
    ad26:	08 95       	ret

0000ad28 <ewb>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ewb(uint8_t *addr, uint8_t val)
{
	//IntOff();
	eeprom_write_byte(addr, val);
    ad28:	0e 94 3b 8e 	call	0x11c76	; 0x11c76 <__eewr_byte_m2560>
	CRC_EEPROM_upd();
    ad2c:	0e 94 88 56 	call	0xad10	; 0xad10 <CRC_EEPROM_upd>
	//IntOn();
}
    ad30:	08 95       	ret

0000ad32 <MB_M_TimeOff_Set>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_M_TimeOff_Set(uint8_t MB_N)
{
	ewb(&MB_M_Param_EE[MB_N].TimeOff, MB_M_TimeOff[MB_N]);
    ad32:	e8 2f       	mov	r30, r24
    ad34:	f0 e0       	ldi	r31, 0x00	; 0
    ad36:	cf 01       	movw	r24, r30
    ad38:	88 0f       	add	r24, r24
    ad3a:	99 1f       	adc	r25, r25
    ad3c:	88 0f       	add	r24, r24
    ad3e:	99 1f       	adc	r25, r25
    ad40:	8e 0f       	add	r24, r30
    ad42:	9f 1f       	adc	r25, r31
    ad44:	e1 52       	subi	r30, 0x21	; 33
    ad46:	fa 4f       	sbci	r31, 0xFA	; 250
    ad48:	8a 56       	subi	r24, 0x6A	; 106
    ad4a:	9e 4f       	sbci	r25, 0xFE	; 254
    ad4c:	60 81       	ld	r22, Z
    ad4e:	0e 94 94 56 	call	0xad28	; 0xad28 <ewb>
}
    ad52:	08 95       	ret

0000ad54 <MB_M_Try_Set>:

// ~~~~~~~~~~~~~~~~~~~~~~~
void
MB_M_Try_Set(uint8_t MB_N)
{
	ewb(&MB_M_Param_EE[MB_N].Try, MB_M_Try[MB_N]);
    ad54:	e8 2f       	mov	r30, r24
    ad56:	f0 e0       	ldi	r31, 0x00	; 0
    ad58:	cf 01       	movw	r24, r30
    ad5a:	88 0f       	add	r24, r24
    ad5c:	99 1f       	adc	r25, r25
    ad5e:	88 0f       	add	r24, r24
    ad60:	99 1f       	adc	r25, r25
    ad62:	8e 0f       	add	r24, r30
    ad64:	9f 1f       	adc	r25, r31
    ad66:	e1 5c       	subi	r30, 0xC1	; 193
    ad68:	f8 4f       	sbci	r31, 0xF8	; 248
    ad6a:	8b 56       	subi	r24, 0x6B	; 107
    ad6c:	9e 4f       	sbci	r25, 0xFE	; 254
    ad6e:	60 81       	ld	r22, Z
    ad70:	0e 94 94 56 	call	0xad28	; 0xad28 <ewb>
}
    ad74:	08 95       	ret

0000ad76 <MB_M_Timeout_Set>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_M_Timeout_Set(uint8_t MB_N)
{
	ewb(&MB_M_Param_EE[MB_N].Timeout, MB_M_Timeout[MB_N]);
    ad76:	e8 2f       	mov	r30, r24
    ad78:	f0 e0       	ldi	r31, 0x00	; 0
    ad7a:	cf 01       	movw	r24, r30
    ad7c:	88 0f       	add	r24, r24
    ad7e:	99 1f       	adc	r25, r25
    ad80:	88 0f       	add	r24, r24
    ad82:	99 1f       	adc	r25, r25
    ad84:	8e 0f       	add	r24, r30
    ad86:	9f 1f       	adc	r25, r31
    ad88:	e7 5d       	subi	r30, 0xD7	; 215
    ad8a:	f6 4f       	sbci	r31, 0xF6	; 246
    ad8c:	8c 56       	subi	r24, 0x6C	; 108
    ad8e:	9e 4f       	sbci	r25, 0xFE	; 254
    ad90:	60 81       	ld	r22, Z
    ad92:	0e 94 94 56 	call	0xad28	; 0xad28 <ewb>
}
    ad96:	08 95       	ret

0000ad98 <Set_MB_Addr>:
	static uint8_t EEMEM MB_NativeAddr_EE[Modbus_Qt] = Init_MB_NativeAddr;
	// ~~~~~~~~~~~~~~~~~~~~~~
	void
	Set_MB_Addr(uint8_t MB_N)
	{
		ewb(MB_NativeAddr_EE+MB_N, MB_NativeAddr[MB_N]);
    ad98:	e8 2f       	mov	r30, r24
    ad9a:	f0 e0       	ldi	r31, 0x00	; 0
    ad9c:	cf 01       	movw	r24, r30
    ad9e:	89 56       	subi	r24, 0x69	; 105
    ada0:	9e 4f       	sbci	r25, 0xFE	; 254
    ada2:	e0 52       	subi	r30, 0x20	; 32
    ada4:	fa 4f       	sbci	r31, 0xFA	; 250
    ada6:	60 81       	ld	r22, Z
    ada8:	0e 94 94 56 	call	0xad28	; 0xad28 <ewb>
	}
    adac:	08 95       	ret

0000adae <eww>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
eww(uint16_t *addr, uint16_t val)
{
	//IntOff();
	eeprom_write_word(addr, val);
    adae:	0e 94 51 8e 	call	0x11ca2	; 0x11ca2 <__eewr_word_m2560>
	CRC_EEPROM_upd();
    adb2:	0e 94 88 56 	call	0xad10	; 0xad10 <CRC_EEPROM_upd>
	//IntOn();
}
    adb6:	08 95       	ret

0000adb8 <MB_M_Period_Set>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_M_Period_Set(uint8_t MB_N)
{
	eww(&MB_M_Param_EE[MB_N].Period, MB_M_Period[MB_N]);
    adb8:	e8 2f       	mov	r30, r24
    adba:	f0 e0       	ldi	r31, 0x00	; 0
    adbc:	cf 01       	movw	r24, r30
    adbe:	88 0f       	add	r24, r24
    adc0:	99 1f       	adc	r25, r25
    adc2:	88 0f       	add	r24, r24
    adc4:	99 1f       	adc	r25, r25
    adc6:	8e 0f       	add	r24, r30
    adc8:	9f 1f       	adc	r25, r31
    adca:	ee 0f       	add	r30, r30
    adcc:	ff 1f       	adc	r31, r31
    adce:	e3 55       	subi	r30, 0x53	; 83
    add0:	f9 4f       	sbci	r31, 0xF9	; 249
    add2:	60 81       	ld	r22, Z
    add4:	71 81       	ldd	r23, Z+1	; 0x01
    add6:	8e 56       	subi	r24, 0x6E	; 110
    add8:	9e 4f       	sbci	r25, 0xFE	; 254
    adda:	0e 94 d7 56 	call	0xadae	; 0xadae <eww>
}
    adde:	08 95       	ret

0000ade0 <OnTimeSave>:

// ~~~~~~~~~~~~~
void
OnTimeSave(void)
{
	ewb(&Timer1min_EE, Timer1min);
    ade0:	8d e9       	ldi	r24, 0x9D	; 157
    ade2:	91 e0       	ldi	r25, 0x01	; 1
    ade4:	60 91 b0 06 	lds	r22, 0x06B0
    ade8:	0e 94 94 56 	call	0xad28	; 0xad28 <ewb>
	eww(&Timer1hour_EE, Timer1hour);
    adec:	60 91 6b 0c 	lds	r22, 0x0C6B
    adf0:	70 91 6c 0c 	lds	r23, 0x0C6C
    adf4:	8e e9       	ldi	r24, 0x9E	; 158
    adf6:	91 e0       	ldi	r25, 0x01	; 1
    adf8:	0e 94 d7 56 	call	0xadae	; 0xadae <eww>
}
    adfc:	08 95       	ret

0000adfe <TimersInc>:
		HSC_Process();
	#endif
}
void 
TimersInc(void)
{
    adfe:	ef 92       	push	r14
    ae00:	ff 92       	push	r15
    ae02:	0f 93       	push	r16
    ae04:	1f 93       	push	r17
    ae06:	cf 93       	push	r28
    ae08:	df 93       	push	r29
	uint8_t i, TickCounterVar;	
	cli();
    ae0a:	f8 94       	cli
	TickCounterVar = TickCounter;
    ae0c:	e0 90 d1 04 	lds	r14, 0x04D1
	TickCounter = 0;
    ae10:	10 92 d1 04 	sts	0x04D1, r1
	sei();
    ae14:	78 94       	sei
	for(uint8_t j=0;j<TickCounterVar;j++){
    ae16:	ee 20       	and	r14, r14
    ae18:	09 f4       	brne	.+2      	; 0xae1c <TimersInc+0x1e>
    ae1a:	c8 c0       	rjmp	.+400    	; 0xafac <TimersInc+0x1ae>
    ae1c:	ff 24       	eor	r15, r15
		LiveTime++;
	 	for (i=0; i<Timer8TotNumber; i++){
			cli();
			if (!(Timer8Flg[i/8] &(1<<i%8)) && --Timer8[i]==0)
				Timer8Flg[i/8] |=(1<<i%8);
    ae1e:	01 e0       	ldi	r16, 0x01	; 1
    ae20:	10 e0       	ldi	r17, 0x00	; 0
	cli();
	TickCounterVar = TickCounter;
	TickCounter = 0;
	sei();
	for(uint8_t j=0;j<TickCounterVar;j++){
		LiveTime++;
    ae22:	80 91 c5 07 	lds	r24, 0x07C5
    ae26:	90 91 c6 07 	lds	r25, 0x07C6
    ae2a:	a0 91 c7 07 	lds	r26, 0x07C7
    ae2e:	b0 91 c8 07 	lds	r27, 0x07C8
    ae32:	01 96       	adiw	r24, 0x01	; 1
    ae34:	a1 1d       	adc	r26, r1
    ae36:	b1 1d       	adc	r27, r1
    ae38:	80 93 c5 07 	sts	0x07C5, r24
    ae3c:	90 93 c6 07 	sts	0x07C6, r25
    ae40:	a0 93 c7 07 	sts	0x07C7, r26
    ae44:	b0 93 c8 07 	sts	0x07C8, r27
    ae48:	40 e0       	ldi	r20, 0x00	; 0
    ae4a:	50 e0       	ldi	r21, 0x00	; 0
	 	for (i=0; i<Timer8TotNumber; i++){
			cli();
    ae4c:	f8 94       	cli
			if (!(Timer8Flg[i/8] &(1<<i%8)) && --Timer8[i]==0)
    ae4e:	84 2f       	mov	r24, r20
    ae50:	86 95       	lsr	r24
    ae52:	86 95       	lsr	r24
    ae54:	86 95       	lsr	r24
    ae56:	a8 2f       	mov	r26, r24
    ae58:	b0 e0       	ldi	r27, 0x00	; 0
    ae5a:	af 54       	subi	r26, 0x4F	; 79
    ae5c:	bb 4f       	sbci	r27, 0xFB	; 251
    ae5e:	8c 91       	ld	r24, X
    ae60:	ba 01       	movw	r22, r20
    ae62:	67 70       	andi	r22, 0x07	; 7
    ae64:	70 70       	andi	r23, 0x00	; 0
    ae66:	90 e0       	ldi	r25, 0x00	; 0
    ae68:	06 2e       	mov	r0, r22
    ae6a:	02 c0       	rjmp	.+4      	; 0xae70 <TimersInc+0x72>
    ae6c:	95 95       	asr	r25
    ae6e:	87 95       	ror	r24
    ae70:	0a 94       	dec	r0
    ae72:	e2 f7       	brpl	.-8      	; 0xae6c <TimersInc+0x6e>
    ae74:	80 fd       	sbrc	r24, 0
    ae76:	12 c0       	rjmp	.+36     	; 0xae9c <TimersInc+0x9e>
    ae78:	fa 01       	movw	r30, r20
    ae7a:	e9 50       	subi	r30, 0x09	; 9
    ae7c:	fd 4f       	sbci	r31, 0xFD	; 253
    ae7e:	80 81       	ld	r24, Z
    ae80:	81 50       	subi	r24, 0x01	; 1
    ae82:	80 83       	st	Z, r24
    ae84:	80 81       	ld	r24, Z
    ae86:	88 23       	and	r24, r24
    ae88:	49 f4       	brne	.+18     	; 0xae9c <TimersInc+0x9e>
				Timer8Flg[i/8] |=(1<<i%8);
    ae8a:	2c 91       	ld	r18, X
    ae8c:	c8 01       	movw	r24, r16
    ae8e:	02 c0       	rjmp	.+4      	; 0xae94 <TimersInc+0x96>
    ae90:	88 0f       	add	r24, r24
    ae92:	99 1f       	adc	r25, r25
    ae94:	6a 95       	dec	r22
    ae96:	e2 f7       	brpl	.-8      	; 0xae90 <TimersInc+0x92>
    ae98:	28 2b       	or	r18, r24
    ae9a:	2c 93       	st	X, r18
			sei();
    ae9c:	78 94       	sei
    ae9e:	4f 5f       	subi	r20, 0xFF	; 255
    aea0:	5f 4f       	sbci	r21, 0xFF	; 255
	TickCounterVar = TickCounter;
	TickCounter = 0;
	sei();
	for(uint8_t j=0;j<TickCounterVar;j++){
		LiveTime++;
	 	for (i=0; i<Timer8TotNumber; i++){
    aea2:	48 35       	cpi	r20, 0x58	; 88
    aea4:	51 05       	cpc	r21, r1
    aea6:	91 f6       	brne	.-92     	; 0xae4c <TimersInc+0x4e>
    aea8:	40 e0       	ldi	r20, 0x00	; 0
    aeaa:	50 e0       	ldi	r21, 0x00	; 0
			if (!(Timer8Flg[i/8] &(1<<i%8)) && --Timer8[i]==0)
				Timer8Flg[i/8] |=(1<<i%8);
			sei();
		}
		for (i=0; i<Timer16TotNumber; i++){
			cli();
    aeac:	f8 94       	cli
			if (!(Timer16Flg[i/8] &(1<<i%8)) && --Timer16[i]==0)
    aeae:	84 2f       	mov	r24, r20
    aeb0:	86 95       	lsr	r24
    aeb2:	86 95       	lsr	r24
    aeb4:	86 95       	lsr	r24
    aeb6:	a8 2f       	mov	r26, r24
    aeb8:	b0 e0       	ldi	r27, 0x00	; 0
    aeba:	a3 54       	subi	r26, 0x43	; 67
    aebc:	bb 4f       	sbci	r27, 0xFB	; 251
    aebe:	8c 91       	ld	r24, X
    aec0:	ba 01       	movw	r22, r20
    aec2:	67 70       	andi	r22, 0x07	; 7
    aec4:	70 70       	andi	r23, 0x00	; 0
    aec6:	90 e0       	ldi	r25, 0x00	; 0
    aec8:	06 2e       	mov	r0, r22
    aeca:	02 c0       	rjmp	.+4      	; 0xaed0 <TimersInc+0xd2>
    aecc:	95 95       	asr	r25
    aece:	87 95       	ror	r24
    aed0:	0a 94       	dec	r0
    aed2:	e2 f7       	brpl	.-8      	; 0xaecc <TimersInc+0xce>
    aed4:	80 fd       	sbrc	r24, 0
    aed6:	17 c0       	rjmp	.+46     	; 0xaf06 <TimersInc+0x108>
    aed8:	fa 01       	movw	r30, r20
    aeda:	ee 0f       	add	r30, r30
    aedc:	ff 1f       	adc	r31, r31
    aede:	e1 5b       	subi	r30, 0xB1	; 177
    aee0:	fc 4f       	sbci	r31, 0xFC	; 252
    aee2:	80 81       	ld	r24, Z
    aee4:	91 81       	ldd	r25, Z+1	; 0x01
    aee6:	01 97       	sbiw	r24, 0x01	; 1
    aee8:	91 83       	std	Z+1, r25	; 0x01
    aeea:	80 83       	st	Z, r24
    aeec:	80 81       	ld	r24, Z
    aeee:	91 81       	ldd	r25, Z+1	; 0x01
    aef0:	89 2b       	or	r24, r25
    aef2:	49 f4       	brne	.+18     	; 0xaf06 <TimersInc+0x108>
				Timer16Flg[i/8] |=(1<<i%8);
    aef4:	2c 91       	ld	r18, X
    aef6:	c8 01       	movw	r24, r16
    aef8:	02 c0       	rjmp	.+4      	; 0xaefe <TimersInc+0x100>
    aefa:	88 0f       	add	r24, r24
    aefc:	99 1f       	adc	r25, r25
    aefe:	6a 95       	dec	r22
    af00:	e2 f7       	brpl	.-8      	; 0xaefa <TimersInc+0xfc>
    af02:	28 2b       	or	r18, r24
    af04:	2c 93       	st	X, r18
			sei();
    af06:	78 94       	sei
    af08:	4f 5f       	subi	r20, 0xFF	; 255
    af0a:	5f 4f       	sbci	r21, 0xFF	; 255
			cli();
			if (!(Timer8Flg[i/8] &(1<<i%8)) && --Timer8[i]==0)
				Timer8Flg[i/8] |=(1<<i%8);
			sei();
		}
		for (i=0; i<Timer16TotNumber; i++){
    af0c:	40 36       	cpi	r20, 0x60	; 96
    af0e:	51 05       	cpc	r21, r1
    af10:	69 f6       	brne	.-102    	; 0xaeac <TimersInc+0xae>
    af12:	40 e0       	ldi	r20, 0x00	; 0
    af14:	50 e0       	ldi	r21, 0x00	; 0
			if (!(Timer16Flg[i/8] &(1<<i%8)) && --Timer16[i]==0)
				Timer16Flg[i/8] |=(1<<i%8);
			sei();
		}
		for (i=0; i<Timer32TotNumber; i++){
			cli();
    af16:	f8 94       	cli
			if (!(Timer32Flg[i/8] &(1<<i%8)) && --Timer32[i]==0)
    af18:	84 2f       	mov	r24, r20
    af1a:	86 95       	lsr	r24
    af1c:	86 95       	lsr	r24
    af1e:	86 95       	lsr	r24
    af20:	c8 2f       	mov	r28, r24
    af22:	d0 e0       	ldi	r29, 0x00	; 0
    af24:	c6 53       	subi	r28, 0x36	; 54
    af26:	db 4f       	sbci	r29, 0xFB	; 251
    af28:	88 81       	ld	r24, Y
    af2a:	ba 01       	movw	r22, r20
    af2c:	67 70       	andi	r22, 0x07	; 7
    af2e:	70 70       	andi	r23, 0x00	; 0
    af30:	90 e0       	ldi	r25, 0x00	; 0
    af32:	06 2e       	mov	r0, r22
    af34:	02 c0       	rjmp	.+4      	; 0xaf3a <TimersInc+0x13c>
    af36:	95 95       	asr	r25
    af38:	87 95       	ror	r24
    af3a:	0a 94       	dec	r0
    af3c:	e2 f7       	brpl	.-8      	; 0xaf36 <TimersInc+0x138>
    af3e:	80 fd       	sbrc	r24, 0
    af40:	23 c0       	rjmp	.+70     	; 0xaf88 <TimersInc+0x18a>
    af42:	fa 01       	movw	r30, r20
    af44:	ee 0f       	add	r30, r30
    af46:	ff 1f       	adc	r31, r31
    af48:	ee 0f       	add	r30, r30
    af4a:	ff 1f       	adc	r31, r31
    af4c:	e1 5f       	subi	r30, 0xF1	; 241
    af4e:	fb 4f       	sbci	r31, 0xFB	; 251
    af50:	80 81       	ld	r24, Z
    af52:	91 81       	ldd	r25, Z+1	; 0x01
    af54:	a2 81       	ldd	r26, Z+2	; 0x02
    af56:	b3 81       	ldd	r27, Z+3	; 0x03
    af58:	01 97       	sbiw	r24, 0x01	; 1
    af5a:	a1 09       	sbc	r26, r1
    af5c:	b1 09       	sbc	r27, r1
    af5e:	80 83       	st	Z, r24
    af60:	91 83       	std	Z+1, r25	; 0x01
    af62:	a2 83       	std	Z+2, r26	; 0x02
    af64:	b3 83       	std	Z+3, r27	; 0x03
    af66:	80 81       	ld	r24, Z
    af68:	91 81       	ldd	r25, Z+1	; 0x01
    af6a:	a2 81       	ldd	r26, Z+2	; 0x02
    af6c:	b3 81       	ldd	r27, Z+3	; 0x03
    af6e:	00 97       	sbiw	r24, 0x00	; 0
    af70:	a1 05       	cpc	r26, r1
    af72:	b1 05       	cpc	r27, r1
    af74:	49 f4       	brne	.+18     	; 0xaf88 <TimersInc+0x18a>
				Timer32Flg[i/8] |=(1<<i%8);	
    af76:	28 81       	ld	r18, Y
    af78:	c8 01       	movw	r24, r16
    af7a:	02 c0       	rjmp	.+4      	; 0xaf80 <TimersInc+0x182>
    af7c:	88 0f       	add	r24, r24
    af7e:	99 1f       	adc	r25, r25
    af80:	6a 95       	dec	r22
    af82:	e2 f7       	brpl	.-8      	; 0xaf7c <TimersInc+0x17e>
    af84:	28 2b       	or	r18, r24
    af86:	28 83       	st	Y, r18
			sei();
    af88:	78 94       	sei
    af8a:	4f 5f       	subi	r20, 0xFF	; 255
    af8c:	5f 4f       	sbci	r21, 0xFF	; 255
			cli();
			if (!(Timer16Flg[i/8] &(1<<i%8)) && --Timer16[i]==0)
				Timer16Flg[i/8] |=(1<<i%8);
			sei();
		}
		for (i=0; i<Timer32TotNumber; i++){
    af8e:	48 32       	cpi	r20, 0x28	; 40
    af90:	51 05       	cpc	r21, r1
    af92:	09 f0       	breq	.+2      	; 0xaf96 <TimersInc+0x198>
    af94:	c0 cf       	rjmp	.-128    	; 0xaf16 <TimersInc+0x118>
			sei();
		}

		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		static uint8_t Timer10ms;
		if (++Timer10ms==100) {
    af96:	80 91 ed 02 	lds	r24, 0x02ED
    af9a:	8f 5f       	subi	r24, 0xFF	; 255
    af9c:	80 93 ed 02 	sts	0x02ED, r24
    afa0:	84 36       	cpi	r24, 0x64	; 100
    afa2:	59 f0       	breq	.+22     	; 0xafba <TimersInc+0x1bc>
	uint8_t i, TickCounterVar;	
	cli();
	TickCounterVar = TickCounter;
	TickCounter = 0;
	sei();
	for(uint8_t j=0;j<TickCounterVar;j++){
    afa4:	f3 94       	inc	r15
    afa6:	fe 14       	cp	r15, r14
    afa8:	08 f4       	brcc	.+2      	; 0xafac <TimersInc+0x1ae>
    afaa:	3b cf       	rjmp	.-394    	; 0xae22 <TimersInc+0x24>
 			ScanCount = 0;
			RT();
		}
		#endif
	}
}
    afac:	df 91       	pop	r29
    afae:	cf 91       	pop	r28
    afb0:	1f 91       	pop	r17
    afb2:	0f 91       	pop	r16
    afb4:	ff 90       	pop	r15
    afb6:	ef 90       	pop	r14
    afb8:	08 95       	ret
		}

		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		static uint8_t Timer10ms;
		if (++Timer10ms==100) {
			Timer10ms = 0;
    afba:	10 92 ed 02 	sts	0x02ED, r1
			ScanPerSec = ScanCount;
    afbe:	80 91 b2 07 	lds	r24, 0x07B2
    afc2:	90 91 b3 07 	lds	r25, 0x07B3
    afc6:	90 93 cf 07 	sts	0x07CF, r25
    afca:	80 93 ce 07 	sts	0x07CE, r24
 			ScanCount = 0;
    afce:	10 92 b3 07 	sts	0x07B3, r1
    afd2:	10 92 b2 07 	sts	0x07B2, r1

// ~~~~~~~~~~~~~~~
inline static void
RT(void)
{
	if (++Timer1s==60) {
    afd6:	80 91 1a 09 	lds	r24, 0x091A
    afda:	8f 5f       	subi	r24, 0xFF	; 255
    afdc:	80 93 1a 09 	sts	0x091A, r24
    afe0:	8c 33       	cpi	r24, 0x3C	; 60
    afe2:	01 f7       	brne	.-64     	; 0xafa4 <TimersInc+0x1a6>
		Timer1s = 0;
    afe4:	10 92 1a 09 	sts	0x091A, r1
		if (++Timer1min==60) {
    afe8:	80 91 b0 06 	lds	r24, 0x06B0
    afec:	8f 5f       	subi	r24, 0xFF	; 255
    afee:	80 93 b0 06 	sts	0x06B0, r24
    aff2:	8c 33       	cpi	r24, 0x3C	; 60
    aff4:	b9 f6       	brne	.-82     	; 0xafa4 <TimersInc+0x1a6>
			Timer1min = 0;
    aff6:	10 92 b0 06 	sts	0x06B0, r1
			++Timer1hour;
    affa:	80 91 6b 0c 	lds	r24, 0x0C6B
    affe:	90 91 6c 0c 	lds	r25, 0x0C6C
    b002:	01 96       	adiw	r24, 0x01	; 1
    b004:	90 93 6c 0c 	sts	0x0C6C, r25
    b008:	80 93 6b 0c 	sts	0x0C6B, r24
			OnTimeSave();
    b00c:	0e 94 f0 56 	call	0xade0	; 0xade0 <OnTimeSave>
    b010:	c9 cf       	rjmp	.-110    	; 0xafa4 <TimersInc+0x1a6>

0000b012 <ewbl>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ewbl(const void *src, void *dst, size_t n)
{
	//IntOff();
	eeprom_write_block(src, dst, n);
    b012:	0e 94 31 8e 	call	0x11c62	; 0x11c62 <__eewr_block_m2560>
	CRC_EEPROM_upd();
    b016:	0e 94 88 56 	call	0xad10	; 0xad10 <CRC_EEPROM_upd>
	//IntOn();
}
    b01a:	08 95       	ret

0000b01c <ewd>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ewd(uint32_t *addr, uint32_t val)
{
	//IntOff();
	eeprom_write_dword(addr, val);
    b01c:	0e 94 49 8e 	call	0x11c92	; 0x11c92 <__eewr_dword_m2560>
	CRC_EEPROM_upd();
    b020:	0e 94 88 56 	call	0xad10	; 0xad10 <CRC_EEPROM_upd>
	//IntOn();
}
    b024:	08 95       	ret

0000b026 <erbl>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    b026:	0e 94 0d 8e 	call	0x11c1a	; 0x11c1a <__eerd_block_m2560>
	//IntOn();
}
    b02a:	08 95       	ret

0000b02c <erd>:
// ~~~~~~~~~~~~~~~~~~~~~~
uint32_t
erd(const uint32_t *addr)
{
	//IntOff();
	uint32_t word = eeprom_read_dword(addr);
    b02c:	0e 94 25 8e 	call	0x11c4a	; 0x11c4a <__eerd_dword_m2560>
	//IntOn();
	return word;
}
    b030:	08 95       	ret

0000b032 <erw>:
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    b032:	0e 94 2b 8e 	call	0x11c56	; 0x11c56 <__eerd_word_m2560>
	//IntOn();
	return word;
}
    b036:	08 95       	ret

0000b038 <ChannelProcessing>:
	CHANNEL_WRITE_LOG,		//2
	CHANNEL_WAIT_CALL,		//3
	CHANNEL_CALLING,		//4
	CHANNEL_WAIT_RECALL		//5
};
void ChannelProcessing(uint8_t chNumber){
    b038:	ef 92       	push	r14
    b03a:	ff 92       	push	r15
    b03c:	0f 93       	push	r16
    b03e:	1f 93       	push	r17
    b040:	cf 93       	push	r28
    b042:	df 93       	push	r29
	switch(Channels[chNumber].Alarm_State){
    b044:	c8 2f       	mov	r28, r24
    b046:	d0 e0       	ldi	r29, 0x00	; 0
    b048:	9e 01       	movw	r18, r28
    b04a:	22 0f       	add	r18, r18
    b04c:	33 1f       	adc	r19, r19
    b04e:	79 01       	movw	r14, r18
    b050:	ee 0c       	add	r14, r14
    b052:	ff 1c       	adc	r15, r15
    b054:	88 eb       	ldi	r24, 0xB8	; 184
    b056:	96 e0       	ldi	r25, 0x06	; 6
    b058:	e8 0e       	add	r14, r24
    b05a:	f9 1e       	adc	r15, r25
    b05c:	f7 01       	movw	r30, r14
    b05e:	80 81       	ld	r24, Z
    b060:	82 30       	cpi	r24, 0x02	; 2
    b062:	09 f4       	brne	.+2      	; 0xb066 <ChannelProcessing+0x2e>
    b064:	7b c0       	rjmp	.+246    	; 0xb15c <ChannelProcessing+0x124>
    b066:	83 30       	cpi	r24, 0x03	; 3
    b068:	c8 f0       	brcs	.+50     	; 0xb09c <ChannelProcessing+0x64>
    b06a:	84 30       	cpi	r24, 0x04	; 4
    b06c:	09 f4       	brne	.+2      	; 0xb070 <ChannelProcessing+0x38>
    b06e:	4c c0       	rjmp	.+152    	; 0xb108 <ChannelProcessing+0xd0>
    b070:	84 30       	cpi	r24, 0x04	; 4
    b072:	08 f0       	brcs	.+2      	; 0xb076 <ChannelProcessing+0x3e>
    b074:	46 c0       	rjmp	.+140    	; 0xb102 <ChannelProcessing+0xca>
				Channels[chNumber].Alarm_State = CHANNEL_WAIT_RECALL;
				StartTimer16(Channels[chNumber].timer, erw(&calling_retry_delay[chNumber])*100);
			}
			break;
		case CHANNEL_WAIT_RECALL:
			if(1 == Channels[chNumber].DI_State)
    b076:	fe 01       	movw	r30, r28
    b078:	ee 0f       	add	r30, r30
    b07a:	ff 1f       	adc	r31, r31
    b07c:	ee 0f       	add	r30, r30
    b07e:	ff 1f       	adc	r31, r31
    b080:	ea 54       	subi	r30, 0x4A	; 74
    b082:	f9 4f       	sbci	r31, 0xF9	; 249
    b084:	81 81       	ldd	r24, Z+1	; 0x01
    b086:	81 30       	cpi	r24, 0x01	; 1
    b088:	99 f1       	breq	.+102    	; 0xb0f0 <ChannelProcessing+0xb8>
			{
				Channels[chNumber].Alarm_State = CHANNEL_PINSCAN;
				break;				
			} 
			if(Timer16Stopp(Channels[chNumber].timer)){
    b08a:	83 81       	ldd	r24, Z+3	; 0x03
    b08c:	0e 94 96 25 	call	0x4b2c	; 0x4b2c <Timer16Stopp>
    b090:	88 23       	and	r24, r24
    b092:	49 f0       	breq	.+18     	; 0xb0a6 <ChannelProcessing+0x6e>
				Channels[chNumber].Alarm_State = CHANNEL_CALLING;
    b094:	84 e0       	ldi	r24, 0x04	; 4
    b096:	f7 01       	movw	r30, r14
    b098:	80 83       	st	Z, r24
    b09a:	05 c0       	rjmp	.+10     	; 0xb0a6 <ChannelProcessing+0x6e>
	CHANNEL_WAIT_CALL,		//3
	CHANNEL_CALLING,		//4
	CHANNEL_WAIT_RECALL		//5
};
void ChannelProcessing(uint8_t chNumber){
	switch(Channels[chNumber].Alarm_State){
    b09c:	88 23       	and	r24, r24
    b09e:	51 f0       	breq	.+20     	; 0xb0b4 <ChannelProcessing+0x7c>
    b0a0:	81 30       	cpi	r24, 0x01	; 1
    b0a2:	09 f4       	brne	.+2      	; 0xb0a6 <ChannelProcessing+0x6e>
    b0a4:	7c c0       	rjmp	.+248    	; 0xb19e <ChannelProcessing+0x166>
			}			
			break;

	}

}
    b0a6:	df 91       	pop	r29
    b0a8:	cf 91       	pop	r28
    b0aa:	1f 91       	pop	r17
    b0ac:	0f 91       	pop	r16
    b0ae:	ff 90       	pop	r15
    b0b0:	ef 90       	pop	r14
    b0b2:	08 95       	ret
	CHANNEL_WAIT_RECALL		//5
};
void ChannelProcessing(uint8_t chNumber){
	switch(Channels[chNumber].Alarm_State){
		case CHANNEL_PINSCAN:
			if(0 == Channels[chNumber].DI_State)
    b0b4:	cc 0f       	add	r28, r28
    b0b6:	dd 1f       	adc	r29, r29
    b0b8:	cc 0f       	add	r28, r28
    b0ba:	dd 1f       	adc	r29, r29
    b0bc:	ca 54       	subi	r28, 0x4A	; 74
    b0be:	d9 4f       	sbci	r29, 0xF9	; 249
    b0c0:	89 81       	ldd	r24, Y+1	; 0x01
    b0c2:	88 23       	and	r24, r24
    b0c4:	81 f7       	brne	.-32     	; 0xb0a6 <ChannelProcessing+0x6e>
			{
				Channels[chNumber].Alarm_State = CHANNEL_WAIT_DEBOUNCE;
    b0c6:	81 e0       	ldi	r24, 0x01	; 1
    b0c8:	f7 01       	movw	r30, r14
    b0ca:	80 83       	st	Z, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    b0cc:	c9 01       	movw	r24, r18
    b0ce:	8f 5c       	subi	r24, 0xCF	; 207
    b0d0:	9e 4f       	sbci	r25, 0xFE	; 254
    b0d2:	0e 94 2b 8e 	call	0x11c56	; 0x11c56 <__eerd_word_m2560>
				StartTimer16(Channels[chNumber].timer, erw(&debounceTimeout[chNumber])*100);
    b0d6:	24 e6       	ldi	r18, 0x64	; 100
    b0d8:	30 e0       	ldi	r19, 0x00	; 0
    b0da:	82 9f       	mul	r24, r18
    b0dc:	b0 01       	movw	r22, r0
    b0de:	83 9f       	mul	r24, r19
    b0e0:	70 0d       	add	r23, r0
    b0e2:	92 9f       	mul	r25, r18
    b0e4:	70 0d       	add	r23, r0
    b0e6:	11 24       	eor	r1, r1
    b0e8:	8b 81       	ldd	r24, Y+3	; 0x03
    b0ea:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
    b0ee:	db cf       	rjmp	.-74     	; 0xb0a6 <ChannelProcessing+0x6e>
			}
			break;
		case CHANNEL_WAIT_RECALL:
			if(1 == Channels[chNumber].DI_State)
			{
				Channels[chNumber].Alarm_State = CHANNEL_PINSCAN;
    b0f0:	f7 01       	movw	r30, r14
    b0f2:	10 82       	st	Z, r1
			}			
			break;

	}

}
    b0f4:	df 91       	pop	r29
    b0f6:	cf 91       	pop	r28
    b0f8:	1f 91       	pop	r17
    b0fa:	0f 91       	pop	r16
    b0fc:	ff 90       	pop	r15
    b0fe:	ef 90       	pop	r14
    b100:	08 95       	ret
	CHANNEL_WAIT_CALL,		//3
	CHANNEL_CALLING,		//4
	CHANNEL_WAIT_RECALL		//5
};
void ChannelProcessing(uint8_t chNumber){
	switch(Channels[chNumber].Alarm_State){
    b102:	85 30       	cpi	r24, 0x05	; 5
    b104:	81 f6       	brne	.-96     	; 0xb0a6 <ChannelProcessing+0x6e>
    b106:	b7 cf       	rjmp	.-146    	; 0xb076 <ChannelProcessing+0x3e>
			if(Timer16Stopp(Channels[chNumber].timer)){
				Channels[chNumber].Alarm_State = CHANNEL_CALLING;
			}
			break;
		case CHANNEL_CALLING:
			if(0 == CallerBusyState){
    b108:	80 91 c4 07 	lds	r24, 0x07C4
    b10c:	88 23       	and	r24, r24
    b10e:	59 f6       	brne	.-106    	; 0xb0a6 <ChannelProcessing+0x6e>
				Caller_StartCalling(Channels[chNumber].number);
    b110:	8e 01       	movw	r16, r28
    b112:	00 0f       	add	r16, r16
    b114:	11 1f       	adc	r17, r17
    b116:	00 0f       	add	r16, r16
    b118:	11 1f       	adc	r17, r17
    b11a:	0a 54       	subi	r16, 0x4A	; 74
    b11c:	19 4f       	sbci	r17, 0xF9	; 249
    b11e:	f8 01       	movw	r30, r16
    b120:	90 81       	ld	r25, Z
uint8_t CallerBusyState;
uint8_t CallerMessage[2];
uint8_t CurrentAbonent;
uint8_t CurrentCall;
void Caller_StartCalling(uint8_t inputN){
	CallerMessage[0]=1;
    b122:	81 e0       	ldi	r24, 0x01	; 1
    b124:	80 93 b6 07 	sts	0x07B6, r24
	CallerMessage[1]=inputN;
    b128:	90 93 b7 07 	sts	0x07B7, r25
	CallerBusyState = 1;
    b12c:	80 93 c4 07 	sts	0x07C4, r24
			}
			break;
		case CHANNEL_CALLING:
			if(0 == CallerBusyState){
				Caller_StartCalling(Channels[chNumber].number);
				Channels[chNumber].Alarm_State = CHANNEL_WAIT_RECALL;
    b130:	85 e0       	ldi	r24, 0x05	; 5
    b132:	f7 01       	movw	r30, r14
    b134:	80 83       	st	Z, r24
    b136:	c9 01       	movw	r24, r18
    b138:	8f 58       	subi	r24, 0x8F	; 143
    b13a:	9e 4f       	sbci	r25, 0xFE	; 254
    b13c:	0e 94 2b 8e 	call	0x11c56	; 0x11c56 <__eerd_word_m2560>
				StartTimer16(Channels[chNumber].timer, erw(&calling_retry_delay[chNumber])*100);
    b140:	24 e6       	ldi	r18, 0x64	; 100
    b142:	30 e0       	ldi	r19, 0x00	; 0
    b144:	82 9f       	mul	r24, r18
    b146:	b0 01       	movw	r22, r0
    b148:	83 9f       	mul	r24, r19
    b14a:	70 0d       	add	r23, r0
    b14c:	92 9f       	mul	r25, r18
    b14e:	70 0d       	add	r23, r0
    b150:	11 24       	eor	r1, r1
    b152:	f8 01       	movw	r30, r16
    b154:	83 81       	ldd	r24, Z+3	; 0x03
    b156:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
    b15a:	a5 cf       	rjmp	.-182    	; 0xb0a6 <ChannelProcessing+0x6e>
			if(Timer16Stopp(Channels[chNumber].timer)){
				Channels[chNumber].Alarm_State = CHANNEL_WRITE_LOG;
			}
			break;
		case CHANNEL_WRITE_LOG:
				Channels[chNumber].Alarm_State = CHANNEL_WAIT_CALL;
    b15c:	83 e0       	ldi	r24, 0x03	; 3
    b15e:	f7 01       	movw	r30, r14
    b160:	80 83       	st	Z, r24
    b162:	c9 01       	movw	r24, r18
    b164:	8f 5a       	subi	r24, 0xAF	; 175
    b166:	9e 4f       	sbci	r25, 0xFE	; 254
    b168:	0e 94 2b 8e 	call	0x11c56	; 0x11c56 <__eerd_word_m2560>
				StartTimer16(Channels[chNumber].timer, erw(&calling_delay[chNumber])*100);
    b16c:	cc 0f       	add	r28, r28
    b16e:	dd 1f       	adc	r29, r29
    b170:	cc 0f       	add	r28, r28
    b172:	dd 1f       	adc	r29, r29
    b174:	ca 54       	subi	r28, 0x4A	; 74
    b176:	d9 4f       	sbci	r29, 0xF9	; 249
    b178:	24 e6       	ldi	r18, 0x64	; 100
    b17a:	30 e0       	ldi	r19, 0x00	; 0
    b17c:	82 9f       	mul	r24, r18
    b17e:	b0 01       	movw	r22, r0
    b180:	83 9f       	mul	r24, r19
    b182:	70 0d       	add	r23, r0
    b184:	92 9f       	mul	r25, r18
    b186:	70 0d       	add	r23, r0
    b188:	11 24       	eor	r1, r1
    b18a:	8b 81       	ldd	r24, Y+3	; 0x03
    b18c:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
			}			
			break;

	}

}
    b190:	df 91       	pop	r29
    b192:	cf 91       	pop	r28
    b194:	1f 91       	pop	r17
    b196:	0f 91       	pop	r16
    b198:	ff 90       	pop	r15
    b19a:	ef 90       	pop	r14
    b19c:	08 95       	ret
				StartTimer16(Channels[chNumber].timer, erw(&debounceTimeout[chNumber])*100);
				break;
			}
			break;
		case CHANNEL_WAIT_DEBOUNCE:
			if(1 == Channels[chNumber].DI_State)
    b19e:	fe 01       	movw	r30, r28
    b1a0:	ee 0f       	add	r30, r30
    b1a2:	ff 1f       	adc	r31, r31
    b1a4:	ee 0f       	add	r30, r30
    b1a6:	ff 1f       	adc	r31, r31
    b1a8:	ea 54       	subi	r30, 0x4A	; 74
    b1aa:	f9 4f       	sbci	r31, 0xF9	; 249
    b1ac:	81 81       	ldd	r24, Z+1	; 0x01
    b1ae:	81 30       	cpi	r24, 0x01	; 1
    b1b0:	09 f4       	brne	.+2      	; 0xb1b4 <ChannelProcessing+0x17c>
    b1b2:	9e cf       	rjmp	.-196    	; 0xb0f0 <ChannelProcessing+0xb8>
			{
				Channels[chNumber].Alarm_State = CHANNEL_PINSCAN;
				break;				
			} 
			if(Timer16Stopp(Channels[chNumber].timer)){
    b1b4:	83 81       	ldd	r24, Z+3	; 0x03
    b1b6:	0e 94 96 25 	call	0x4b2c	; 0x4b2c <Timer16Stopp>
    b1ba:	88 23       	and	r24, r24
    b1bc:	09 f4       	brne	.+2      	; 0xb1c0 <ChannelProcessing+0x188>
    b1be:	73 cf       	rjmp	.-282    	; 0xb0a6 <ChannelProcessing+0x6e>
				Channels[chNumber].Alarm_State = CHANNEL_WRITE_LOG;
    b1c0:	82 e0       	ldi	r24, 0x02	; 2
    b1c2:	f7 01       	movw	r30, r14
    b1c4:	80 83       	st	Z, r24
    b1c6:	6f cf       	rjmp	.-290    	; 0xb0a6 <ChannelProcessing+0x6e>

0000b1c8 <ApplCycle>:
}

// ~~~~~~~~~~~~
void
ApplCycle(void)
{
    b1c8:	1f 93       	push	r17
    b1ca:	cf 93       	push	r28
    b1cc:	df 93       	push	r29
    b1ce:	c7 eb       	ldi	r28, 0xB7	; 183
    b1d0:	d6 e0       	ldi	r29, 0x06	; 6
    b1d2:	10 e0       	ldi	r17, 0x00	; 0
	for(uint8_t i=0; i<16; i++){
			Channels[i].DI_State = DI_State(i);
    b1d4:	81 2f       	mov	r24, r17
    b1d6:	0e 94 26 47 	call	0x8e4c	; 0x8e4c <DI_State>
    b1da:	88 83       	st	Y, r24
			ChannelProcessing(i);
    b1dc:	81 2f       	mov	r24, r17
    b1de:	0e 94 1c 58 	call	0xb038	; 0xb038 <ChannelProcessing>

// ~~~~~~~~~~~~
void
ApplCycle(void)
{
	for(uint8_t i=0; i<16; i++){
    b1e2:	1f 5f       	subi	r17, 0xFF	; 255
    b1e4:	24 96       	adiw	r28, 0x04	; 4
    b1e6:	10 31       	cpi	r17, 0x10	; 16
    b1e8:	a9 f7       	brne	.-22     	; 0xb1d4 <ApplCycle+0xc>
			Channels[i].DI_State = DI_State(i);
			ChannelProcessing(i);
	}
	CallerCycle();
    b1ea:	0e 94 a5 49 	call	0x934a	; 0x934a <CallerCycle>
	ModbusAppCycle();
    b1ee:	0e 94 fc 49 	call	0x93f8	; 0x93f8 <ModbusAppCycle>
}
    b1f2:	df 91       	pop	r29
    b1f4:	cf 91       	pop	r28
    b1f6:	1f 91       	pop	r17
    b1f8:	08 95       	ret

0000b1fa <EE_InterBrokLine>:
	uint8_t WiAbsc, uint16_t (*TblAbsc)[WiAbsc], uint8_t Absc,
	uint8_t WiOrdi, uint16_t (*TblOrdi)[WiOrdi], uint8_t Ordi,
	uint8_t Len,
	int16_t x
)
{
    b1fa:	2f 92       	push	r2
    b1fc:	3f 92       	push	r3
    b1fe:	4f 92       	push	r4
    b200:	5f 92       	push	r5
    b202:	6f 92       	push	r6
    b204:	7f 92       	push	r7
    b206:	8f 92       	push	r8
    b208:	9f 92       	push	r9
    b20a:	af 92       	push	r10
    b20c:	bf 92       	push	r11
    b20e:	cf 92       	push	r12
    b210:	df 92       	push	r13
    b212:	ef 92       	push	r14
    b214:	ff 92       	push	r15
    b216:	0f 93       	push	r16
    b218:	1f 93       	push	r17
    b21a:	df 93       	push	r29
    b21c:	cf 93       	push	r28
    b21e:	cd b7       	in	r28, 0x3d	; 61
    b220:	de b7       	in	r29, 0x3e	; 62
    b222:	2e 97       	sbiw	r28, 0x0e	; 14
    b224:	0f b6       	in	r0, 0x3f	; 63
    b226:	f8 94       	cli
    b228:	de bf       	out	0x3e, r29	; 62
    b22a:	0f be       	out	0x3f, r0	; 63
    b22c:	cd bf       	out	0x3d, r28	; 61
    b22e:	f8 2e       	mov	r15, r24
    b230:	2b 01       	movw	r4, r22
    b232:	2d 87       	std	Y+13, r18	; 0x0d
    b234:	18 01       	movw	r2, r16
    b236:	ee 86       	std	Y+14, r14	; 0x0e
    b238:	0c 2d       	mov	r16, r12
	LineGraph Segm;
	uint8_t i = 0;
	Segm.x2 = (int16_t)erw(TblAbsc[0]+Absc);
    b23a:	c4 2e       	mov	r12, r20
    b23c:	dd 24       	eor	r13, r13
    b23e:	c6 01       	movw	r24, r12
    b240:	88 0f       	add	r24, r24
    b242:	99 1f       	adc	r25, r25
    b244:	86 0f       	add	r24, r22
    b246:	97 1f       	adc	r25, r23
    b248:	0e 94 2b 8e 	call	0x11c56	; 0x11c56 <__eerd_word_m2560>
    b24c:	aa 27       	eor	r26, r26
    b24e:	97 fd       	sbrc	r25, 7
    b250:	a0 95       	com	r26
    b252:	ba 2f       	mov	r27, r26
    b254:	8d 83       	std	Y+5, r24	; 0x05
    b256:	9e 83       	std	Y+6, r25	; 0x06
    b258:	af 83       	std	Y+7, r26	; 0x07
    b25a:	b8 87       	std	Y+8, r27	; 0x08
    b25c:	ef 2c       	mov	r14, r15
    b25e:	ff 24       	eor	r15, r15
    b260:	35 01       	movw	r6, r10
    b262:	88 24       	eor	r8, r8
    b264:	77 fc       	sbrc	r7, 7
    b266:	80 94       	com	r8
    b268:	98 2c       	mov	r9, r8
    b26a:	10 e0       	ldi	r17, 0x00	; 0
    b26c:	9c 01       	movw	r18, r24
    b26e:	ad 01       	movw	r20, r26
	do {
		Segm.x1 = Segm.x2;
    b270:	29 83       	std	Y+1, r18	; 0x01
    b272:	3a 83       	std	Y+2, r19	; 0x02
    b274:	4b 83       	std	Y+3, r20	; 0x03
    b276:	5c 83       	std	Y+4, r21	; 0x04
		Segm.x2 = (int16_t)erw(TblAbsc[++i]+Absc);
    b278:	1f 5f       	subi	r17, 0xFF	; 255
    b27a:	a1 2e       	mov	r10, r17
    b27c:	bb 24       	eor	r11, r11
    b27e:	ae 9c       	mul	r10, r14
    b280:	c0 01       	movw	r24, r0
    b282:	af 9c       	mul	r10, r15
    b284:	90 0d       	add	r25, r0
    b286:	be 9c       	mul	r11, r14
    b288:	90 0d       	add	r25, r0
    b28a:	11 24       	eor	r1, r1
    b28c:	8c 0d       	add	r24, r12
    b28e:	9d 1d       	adc	r25, r13
    b290:	88 0f       	add	r24, r24
    b292:	99 1f       	adc	r25, r25
    b294:	84 0d       	add	r24, r4
    b296:	95 1d       	adc	r25, r5
    b298:	0e 94 2b 8e 	call	0x11c56	; 0x11c56 <__eerd_word_m2560>
    b29c:	9c 01       	movw	r18, r24
    b29e:	44 27       	eor	r20, r20
    b2a0:	37 fd       	sbrc	r19, 7
    b2a2:	40 95       	com	r20
    b2a4:	54 2f       	mov	r21, r20
    b2a6:	2d 83       	std	Y+5, r18	; 0x05
    b2a8:	3e 83       	std	Y+6, r19	; 0x06
    b2aa:	4f 83       	std	Y+7, r20	; 0x07
    b2ac:	58 87       	std	Y+8, r21	; 0x08
	} while(x>Segm.x2 && i<Len);
    b2ae:	26 15       	cp	r18, r6
    b2b0:	37 05       	cpc	r19, r7
    b2b2:	48 05       	cpc	r20, r8
    b2b4:	59 05       	cpc	r21, r9
    b2b6:	14 f4       	brge	.+4      	; 0xb2bc <EE_InterBrokLine+0xc2>
    b2b8:	10 17       	cp	r17, r16
    b2ba:	d0 f2       	brcs	.-76     	; 0xb270 <EE_InterBrokLine+0x76>
	Segm.y1 = (int16_t)erw(TblOrdi[i-1]+Ordi);
    b2bc:	8d 85       	ldd	r24, Y+13	; 0x0d
    b2be:	08 2f       	mov	r16, r24
    b2c0:	10 e0       	ldi	r17, 0x00	; 0
    b2c2:	8e 85       	ldd	r24, Y+14	; 0x0e
    b2c4:	e8 2e       	mov	r14, r24
    b2c6:	ff 24       	eor	r15, r15
    b2c8:	08 94       	sec
    b2ca:	a1 08       	sbc	r10, r1
    b2cc:	b1 08       	sbc	r11, r1
    b2ce:	a0 9e       	mul	r10, r16
    b2d0:	c0 01       	movw	r24, r0
    b2d2:	a1 9e       	mul	r10, r17
    b2d4:	90 0d       	add	r25, r0
    b2d6:	b0 9e       	mul	r11, r16
    b2d8:	90 0d       	add	r25, r0
    b2da:	11 24       	eor	r1, r1
    b2dc:	08 94       	sec
    b2de:	a1 1c       	adc	r10, r1
    b2e0:	b1 1c       	adc	r11, r1
    b2e2:	8e 0d       	add	r24, r14
    b2e4:	9f 1d       	adc	r25, r15
    b2e6:	88 0f       	add	r24, r24
    b2e8:	99 1f       	adc	r25, r25
    b2ea:	82 0d       	add	r24, r2
    b2ec:	93 1d       	adc	r25, r3
    b2ee:	0e 94 2b 8e 	call	0x11c56	; 0x11c56 <__eerd_word_m2560>
    b2f2:	9a 87       	std	Y+10, r25	; 0x0a
    b2f4:	89 87       	std	Y+9, r24	; 0x09
    b2f6:	a0 9e       	mul	r10, r16
    b2f8:	c0 01       	movw	r24, r0
    b2fa:	a1 9e       	mul	r10, r17
    b2fc:	90 0d       	add	r25, r0
    b2fe:	b0 9e       	mul	r11, r16
    b300:	90 0d       	add	r25, r0
    b302:	11 24       	eor	r1, r1
    b304:	8e 0d       	add	r24, r14
    b306:	9f 1d       	adc	r25, r15
    b308:	88 0f       	add	r24, r24
    b30a:	99 1f       	adc	r25, r25
    b30c:	82 0d       	add	r24, r2
    b30e:	93 1d       	adc	r25, r3
    b310:	0e 94 2b 8e 	call	0x11c56	; 0x11c56 <__eerd_word_m2560>
	Segm.y2 = (int16_t)erw(TblOrdi[i]+Ordi);
    b314:	9c 87       	std	Y+12, r25	; 0x0c
    b316:	8b 87       	std	Y+11, r24	; 0x0b
	return LineFunc(&Segm, x);
    b318:	ce 01       	movw	r24, r28
    b31a:	01 96       	adiw	r24, 0x01	; 1
    b31c:	b4 01       	movw	r22, r8
    b31e:	a3 01       	movw	r20, r6
    b320:	0e 94 85 2a 	call	0x550a	; 0x550a <LineFunc>
}
    b324:	2e 96       	adiw	r28, 0x0e	; 14
    b326:	0f b6       	in	r0, 0x3f	; 63
    b328:	f8 94       	cli
    b32a:	de bf       	out	0x3e, r29	; 62
    b32c:	0f be       	out	0x3f, r0	; 63
    b32e:	cd bf       	out	0x3d, r28	; 61
    b330:	cf 91       	pop	r28
    b332:	df 91       	pop	r29
    b334:	1f 91       	pop	r17
    b336:	0f 91       	pop	r16
    b338:	ff 90       	pop	r15
    b33a:	ef 90       	pop	r14
    b33c:	df 90       	pop	r13
    b33e:	cf 90       	pop	r12
    b340:	bf 90       	pop	r11
    b342:	af 90       	pop	r10
    b344:	9f 90       	pop	r9
    b346:	8f 90       	pop	r8
    b348:	7f 90       	pop	r7
    b34a:	6f 90       	pop	r6
    b34c:	5f 90       	pop	r5
    b34e:	4f 90       	pop	r4
    b350:	3f 90       	pop	r3
    b352:	2f 90       	pop	r2
    b354:	08 95       	ret

0000b356 <MemCheck>:
}

// ~~~~~~~~~~~
uint8_t
MemCheck(void)
{
    b356:	0f 93       	push	r16
    b358:	1f 93       	push	r17
//	uint8_t T = Timer32Stopp(TD_Mem);
//	if (T) {
//		StartTimer32(TD_Mem, 360000);
		if (!(MemFail &(1<<MemFail_Flash)) && CRC_Flash_calc()!=erw(&MemCheck_stor.CRC_Flash_stor))
    b35a:	80 91 17 09 	lds	r24, 0x0917
    b35e:	80 ff       	sbrs	r24, 0
    b360:	17 c0       	rjmp	.+46     	; 0xb390 <MemCheck+0x3a>
			MemFail |=(1<<MemFail_Flash);
		if (!(MemFail &(1<<MemFail_EEPROM)) && CRC_EEPROM_calc()!=erw(&MemCheck_stor.CRC_EEPROM_stor))
    b362:	81 ff       	sbrs	r24, 1
    b364:	03 c0       	rjmp	.+6      	; 0xb36c <MemCheck+0x16>
			MemFail |=(1<<MemFail_EEPROM);
//	}
//	return T && MemFail;
	return MemFail;
}
    b366:	1f 91       	pop	r17
    b368:	0f 91       	pop	r16
    b36a:	08 95       	ret
//	uint8_t T = Timer32Stopp(TD_Mem);
//	if (T) {
//		StartTimer32(TD_Mem, 360000);
		if (!(MemFail &(1<<MemFail_Flash)) && CRC_Flash_calc()!=erw(&MemCheck_stor.CRC_Flash_stor))
			MemFail |=(1<<MemFail_Flash);
		if (!(MemFail &(1<<MemFail_EEPROM)) && CRC_EEPROM_calc()!=erw(&MemCheck_stor.CRC_EEPROM_stor))
    b36c:	0e 94 35 23 	call	0x466a	; 0x466a <CRC_EEPROM_calc>
    b370:	8c 01       	movw	r16, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    b372:	8a e9       	ldi	r24, 0x9A	; 154
    b374:	91 e0       	ldi	r25, 0x01	; 1
    b376:	0e 94 2b 8e 	call	0x11c56	; 0x11c56 <__eerd_word_m2560>
//	uint8_t T = Timer32Stopp(TD_Mem);
//	if (T) {
//		StartTimer32(TD_Mem, 360000);
		if (!(MemFail &(1<<MemFail_Flash)) && CRC_Flash_calc()!=erw(&MemCheck_stor.CRC_Flash_stor))
			MemFail |=(1<<MemFail_Flash);
		if (!(MemFail &(1<<MemFail_EEPROM)) && CRC_EEPROM_calc()!=erw(&MemCheck_stor.CRC_EEPROM_stor))
    b37a:	08 17       	cp	r16, r24
    b37c:	19 07       	cpc	r17, r25
    b37e:	d9 f0       	breq	.+54     	; 0xb3b6 <MemCheck+0x60>
			MemFail |=(1<<MemFail_EEPROM);
    b380:	80 91 17 09 	lds	r24, 0x0917
    b384:	82 60       	ori	r24, 0x02	; 2
    b386:	80 93 17 09 	sts	0x0917, r24
//	}
//	return T && MemFail;
	return MemFail;
}
    b38a:	1f 91       	pop	r17
    b38c:	0f 91       	pop	r16
    b38e:	08 95       	ret
MemCheck(void)
{
//	uint8_t T = Timer32Stopp(TD_Mem);
//	if (T) {
//		StartTimer32(TD_Mem, 360000);
		if (!(MemFail &(1<<MemFail_Flash)) && CRC_Flash_calc()!=erw(&MemCheck_stor.CRC_Flash_stor))
    b390:	0e 94 1b 23 	call	0x4636	; 0x4636 <CRC_Flash_calc>
    b394:	8c 01       	movw	r16, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    b396:	88 e9       	ldi	r24, 0x98	; 152
    b398:	91 e0       	ldi	r25, 0x01	; 1
    b39a:	0e 94 2b 8e 	call	0x11c56	; 0x11c56 <__eerd_word_m2560>
MemCheck(void)
{
//	uint8_t T = Timer32Stopp(TD_Mem);
//	if (T) {
//		StartTimer32(TD_Mem, 360000);
		if (!(MemFail &(1<<MemFail_Flash)) && CRC_Flash_calc()!=erw(&MemCheck_stor.CRC_Flash_stor))
    b39e:	08 17       	cp	r16, r24
    b3a0:	19 07       	cpc	r17, r25
    b3a2:	31 f0       	breq	.+12     	; 0xb3b0 <MemCheck+0x5a>
			MemFail |=(1<<MemFail_Flash);
    b3a4:	80 91 17 09 	lds	r24, 0x0917
    b3a8:	81 60       	ori	r24, 0x01	; 1
    b3aa:	80 93 17 09 	sts	0x0917, r24
    b3ae:	d9 cf       	rjmp	.-78     	; 0xb362 <MemCheck+0xc>
    b3b0:	80 91 17 09 	lds	r24, 0x0917
    b3b4:	d6 cf       	rjmp	.-84     	; 0xb362 <MemCheck+0xc>
    b3b6:	80 91 17 09 	lds	r24, 0x0917
    b3ba:	d5 cf       	rjmp	.-86     	; 0xb366 <MemCheck+0x10>

0000b3bc <MemCheckMsg>:

// ~~~~~~~~~~~~~~
void
MemCheckMsg(void)
{
	if(MemCheck())
    b3bc:	0e 94 ab 59 	call	0xb356	; 0xb356 <MemCheck>
    b3c0:	88 23       	and	r24, r24
    b3c2:	09 f4       	brne	.+2      	; 0xb3c6 <MemCheckMsg+0xa>
    b3c4:	08 95       	ret

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    b3c6:	80 91 17 09 	lds	r24, 0x0917
    b3ca:	e8 2f       	mov	r30, r24
    b3cc:	f0 e0       	ldi	r31, 0x00	; 0
    b3ce:	ee 0f       	add	r30, r30
    b3d0:	ff 1f       	adc	r31, r31
    b3d2:	e9 5a       	subi	r30, 0xA9	; 169
    b3d4:	f8 4e       	sbci	r31, 0xE8	; 232
		ShowMsg(prp(MsgErrMemo+MemFail));
    b3d6:	85 91       	lpm	r24, Z+
    b3d8:	94 91       	lpm	r25, Z+
    b3da:	0e 94 36 46 	call	0x8c6c	; 0x8c6c <ShowMsg>
    b3de:	08 95       	ret

0000b3e0 <erb>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    b3e0:	0e 94 1d 8e 	call	0x11c3a	; 0x11c3a <__eerd_byte_m2560>
	//IntOn();
	return byte;
}
    b3e4:	08 95       	ret

0000b3e6 <ThermChanWrong>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
ThermChanWrong(uint8_t ChanN)
{
    b3e6:	ff 92       	push	r15
    b3e8:	0f 93       	push	r16
    b3ea:	1f 93       	push	r17
	return ThermWrong(prb(ThermFami+ChanN), erb(ThermType+ChanN), Temperature[ChanN]);
    b3ec:	08 2f       	mov	r16, r24
    b3ee:	10 e0       	ldi	r17, 0x00	; 0

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    b3f0:	f8 01       	movw	r30, r16
    b3f2:	e3 54       	subi	r30, 0x43	; 67
    b3f4:	f9 4f       	sbci	r31, 0xF9	; 249
    b3f6:	f4 90       	lpm	r15, Z+
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    b3f8:	c8 01       	movw	r24, r16
    b3fa:	89 5e       	subi	r24, 0xE9	; 233
    b3fc:	9e 4f       	sbci	r25, 0xFE	; 254
    b3fe:	0e 94 1d 8e 	call	0x11c3a	; 0x11c3a <__eerd_byte_m2560>
    b402:	68 2f       	mov	r22, r24
    b404:	00 0f       	add	r16, r16
    b406:	11 1f       	adc	r17, r17
    b408:	0b 5b       	subi	r16, 0xBB	; 187
    b40a:	19 4f       	sbci	r17, 0xF9	; 249
    b40c:	f8 01       	movw	r30, r16
    b40e:	40 81       	ld	r20, Z
    b410:	51 81       	ldd	r21, Z+1	; 0x01
    b412:	8f 2d       	mov	r24, r15
    b414:	0e 94 56 49 	call	0x92ac	; 0x92ac <ThermWrong>
}
    b418:	1f 91       	pop	r17
    b41a:	0f 91       	pop	r16
    b41c:	ff 90       	pop	r15
    b41e:	08 95       	ret

0000b420 <ThermChan>:
}

// ~~~~~~~~~~~~~~~~~~~~~
void
ThermChan(uint8_t ChanN)
{
    b420:	8f 92       	push	r8
    b422:	9f 92       	push	r9
    b424:	af 92       	push	r10
    b426:	bf 92       	push	r11
    b428:	cf 92       	push	r12
    b42a:	df 92       	push	r13
    b42c:	ef 92       	push	r14
    b42e:	ff 92       	push	r15
    b430:	0f 93       	push	r16
    b432:	1f 93       	push	r17
    b434:	cf 93       	push	r28
    b436:	df 93       	push	r29
	if (ChanN>=TerReg)
    b438:	86 30       	cpi	r24, 0x06	; 6
    b43a:	08 f0       	brcs	.+2      	; 0xb43e <ThermChan+0x1e>
    b43c:	4c c0       	rjmp	.+152    	; 0xb4d6 <ThermChan+0xb6>
		return;
    b43e:	e8 2e       	mov	r14, r24
    b440:	ff 24       	eor	r15, r15
    b442:	d7 01       	movw	r26, r14
    b444:	aa 0f       	add	r26, r26
    b446:	bb 1f       	adc	r27, r27
    b448:	a2 95       	swap	r26
    b44a:	b2 95       	swap	r27
    b44c:	b0 7f       	andi	r27, 0xF0	; 240
    b44e:	ba 27       	eor	r27, r26
    b450:	a0 7f       	andi	r26, 0xF0	; 240
    b452:	ba 27       	eor	r27, r26
    b454:	fd 01       	movw	r30, r26
    b456:	e3 5e       	subi	r30, 0xE3	; 227
    b458:	fa 4f       	sbci	r31, 0xFA	; 250
    b45a:	2f e0       	ldi	r18, 0x0F	; 15
	for (uint8_t i=TerFiltLev*4-1; i; i--)
		TerBuf[ChanN][i] = TerBuf[ChanN][i-1];
    b45c:	80 81       	ld	r24, Z
    b45e:	91 81       	ldd	r25, Z+1	; 0x01
    b460:	93 83       	std	Z+3, r25	; 0x03
    b462:	82 83       	std	Z+2, r24	; 0x02
void
ThermChan(uint8_t ChanN)
{
	if (ChanN>=TerReg)
		return;
	for (uint8_t i=TerFiltLev*4-1; i; i--)
    b464:	21 50       	subi	r18, 0x01	; 1
    b466:	32 97       	sbiw	r30, 0x02	; 2
    b468:	22 23       	and	r18, r18
    b46a:	c1 f7       	brne	.-16     	; 0xb45c <ThermChan+0x3c>
		TerBuf[ChanN][i] = TerBuf[ChanN][i-1];
	TerBuf[ChanN][0] = TerInput[ChanN];
    b46c:	af 5f       	subi	r26, 0xFF	; 255
    b46e:	ba 4f       	sbci	r27, 0xFA	; 250
    b470:	47 01       	movw	r8, r14
    b472:	88 0c       	add	r8, r8
    b474:	99 1c       	adc	r9, r9
    b476:	f4 01       	movw	r30, r8
    b478:	e5 5e       	subi	r30, 0xE5	; 229
    b47a:	f6 4f       	sbci	r31, 0xF6	; 246
    b47c:	80 81       	ld	r24, Z
    b47e:	91 81       	ldd	r25, Z+1	; 0x01
    b480:	8d 93       	st	X+, r24
    b482:	9c 93       	st	X, r25

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    b484:	f7 01       	movw	r30, r14
    b486:	e3 54       	subi	r30, 0x43	; 67
    b488:	f9 4f       	sbci	r31, 0xF9	; 249
    b48a:	c4 90       	lpm	r12, Z+
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    b48c:	c7 01       	movw	r24, r14
    b48e:	89 5e       	subi	r24, 0xE9	; 233
    b490:	9e 4f       	sbci	r25, 0xFE	; 254
    b492:	0e 94 1d 8e 	call	0x11c3a	; 0x11c3a <__eerd_byte_m2560>
    b496:	18 2f       	mov	r17, r24
	int16_t Ter = Thermode(prb(ThermFami+ChanN), erb(ThermType+ChanN), DigiFilt(TerBuf[ChanN],TerFiltLev));
    b498:	c7 01       	movw	r24, r14
    b49a:	88 0f       	add	r24, r24
    b49c:	99 1f       	adc	r25, r25
    b49e:	82 95       	swap	r24
    b4a0:	92 95       	swap	r25
    b4a2:	90 7f       	andi	r25, 0xF0	; 240
    b4a4:	98 27       	eor	r25, r24
    b4a6:	80 7f       	andi	r24, 0xF0	; 240
    b4a8:	98 27       	eor	r25, r24
    b4aa:	8f 5f       	subi	r24, 0xFF	; 255
    b4ac:	9a 4f       	sbci	r25, 0xFA	; 250
    b4ae:	64 e0       	ldi	r22, 0x04	; 4
    b4b0:	0e 94 bb 55 	call	0xab76	; 0xab76 <DigiFilt>
    b4b4:	ac 01       	movw	r20, r24
    b4b6:	8c 2d       	mov	r24, r12
    b4b8:	61 2f       	mov	r22, r17
    b4ba:	0e 94 d6 48 	call	0x91ac	; 0x91ac <Thermode>
    b4be:	ec 01       	movw	r28, r24
	if (Ter!=Therm_Off_Mark)
    b4c0:	80 e8       	ldi	r24, 0x80	; 128
    b4c2:	c0 30       	cpi	r28, 0x00	; 0
    b4c4:	d8 07       	cpc	r29, r24
    b4c6:	a1 f4       	brne	.+40     	; 0xb4f0 <ThermChan+0xd0>
		Ter = (Ter+(int8_t)erb(&ThermCorr[ChanN].D))*(erw(&ThermCorr[ChanN].A)/1000.0);
	Temperature[ChanN] = Ter;
    b4c8:	e5 e4       	ldi	r30, 0x45	; 69
    b4ca:	f6 e0       	ldi	r31, 0x06	; 6
    b4cc:	8e 0e       	add	r8, r30
    b4ce:	9f 1e       	adc	r9, r31
    b4d0:	f4 01       	movw	r30, r8
    b4d2:	d1 83       	std	Z+1, r29	; 0x01
    b4d4:	c0 83       	st	Z, r28
}
    b4d6:	df 91       	pop	r29
    b4d8:	cf 91       	pop	r28
    b4da:	1f 91       	pop	r17
    b4dc:	0f 91       	pop	r16
    b4de:	ff 90       	pop	r15
    b4e0:	ef 90       	pop	r14
    b4e2:	df 90       	pop	r13
    b4e4:	cf 90       	pop	r12
    b4e6:	bf 90       	pop	r11
    b4e8:	af 90       	pop	r10
    b4ea:	9f 90       	pop	r9
    b4ec:	8f 90       	pop	r8
    b4ee:	08 95       	ret
    b4f0:	64 01       	movw	r12, r8
    b4f2:	ce 0c       	add	r12, r14
    b4f4:	df 1c       	adc	r13, r15
    b4f6:	c6 01       	movw	r24, r12
    b4f8:	83 5e       	subi	r24, 0xE3	; 227
    b4fa:	9e 4f       	sbci	r25, 0xFE	; 254
    b4fc:	0e 94 1d 8e 	call	0x11c3a	; 0x11c3a <__eerd_byte_m2560>
    b500:	e8 2e       	mov	r14, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    b502:	c6 01       	movw	r24, r12
    b504:	82 5e       	subi	r24, 0xE2	; 226
    b506:	9e 4f       	sbci	r25, 0xFE	; 254
    b508:	0e 94 2b 8e 	call	0x11c56	; 0x11c56 <__eerd_word_m2560>
    b50c:	5c 01       	movw	r10, r24
	for (uint8_t i=TerFiltLev*4-1; i; i--)
		TerBuf[ChanN][i] = TerBuf[ChanN][i-1];
	TerBuf[ChanN][0] = TerInput[ChanN];
	int16_t Ter = Thermode(prb(ThermFami+ChanN), erb(ThermType+ChanN), DigiFilt(TerBuf[ChanN],TerFiltLev));
	if (Ter!=Therm_Off_Mark)
		Ter = (Ter+(int8_t)erb(&ThermCorr[ChanN].D))*(erw(&ThermCorr[ChanN].A)/1000.0);
    b50e:	ff 24       	eor	r15, r15
    b510:	e7 fc       	sbrc	r14, 7
    b512:	f0 94       	com	r15
    b514:	ec 0e       	add	r14, r28
    b516:	fd 1e       	adc	r15, r29
    b518:	00 27       	eor	r16, r16
    b51a:	f7 fc       	sbrc	r15, 7
    b51c:	00 95       	com	r16
    b51e:	10 2f       	mov	r17, r16
    b520:	c8 01       	movw	r24, r16
    b522:	b7 01       	movw	r22, r14
    b524:	0e 94 0e 89 	call	0x1121c	; 0x1121c <__floatsisf>
    b528:	7b 01       	movw	r14, r22
    b52a:	8c 01       	movw	r16, r24
    b52c:	cc 24       	eor	r12, r12
    b52e:	dd 24       	eor	r13, r13
    b530:	c6 01       	movw	r24, r12
    b532:	b5 01       	movw	r22, r10
    b534:	0e 94 0c 89 	call	0x11218	; 0x11218 <__floatunsisf>
    b538:	20 e0       	ldi	r18, 0x00	; 0
    b53a:	30 e0       	ldi	r19, 0x00	; 0
    b53c:	4a e7       	ldi	r20, 0x7A	; 122
    b53e:	54 e4       	ldi	r21, 0x44	; 68
    b540:	0e 94 74 8d 	call	0x11ae8	; 0x11ae8 <__divsf3>
    b544:	9b 01       	movw	r18, r22
    b546:	ac 01       	movw	r20, r24
    b548:	c8 01       	movw	r24, r16
    b54a:	b7 01       	movw	r22, r14
    b54c:	0e 94 49 89 	call	0x11292	; 0x11292 <__mulsf3>
    b550:	0e 94 dc 8d 	call	0x11bb8	; 0x11bb8 <__fixsfsi>
    b554:	eb 01       	movw	r28, r22
    b556:	b8 cf       	rjmp	.-144    	; 0xb4c8 <ThermChan+0xa8>

0000b558 <ThermInit>:
}

// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
ThermInit(uint8_t ChanN)
{
    b558:	ef 92       	push	r14
    b55a:	ff 92       	push	r15
    b55c:	0f 93       	push	r16
    b55e:	1f 93       	push	r17
    b560:	cf 93       	push	r28
    b562:	df 93       	push	r29
    b564:	f8 2e       	mov	r15, r24
	if (ChanN<TerReg) {
    b566:	85 e0       	ldi	r24, 0x05	; 5
    b568:	8f 15       	cp	r24, r15
    b56a:	68 f1       	brcs	.+90     	; 0xb5c6 <ThermInit+0x6e>
    b56c:	8f 2d       	mov	r24, r15
    b56e:	90 e0       	ldi	r25, 0x00	; 0
    b570:	8c 01       	movw	r16, r24
    b572:	00 0f       	add	r16, r16
    b574:	11 1f       	adc	r17, r17
    b576:	f8 01       	movw	r30, r16
    b578:	e5 5e       	subi	r30, 0xE5	; 229
    b57a:	f6 4f       	sbci	r31, 0xF6	; 246
    b57c:	c0 81       	ld	r28, Z
    b57e:	d1 81       	ldd	r29, Z+1	; 0x01
    b580:	fc 01       	movw	r30, r24
    b582:	ee 0f       	add	r30, r30
    b584:	ff 1f       	adc	r31, r31
    b586:	e2 95       	swap	r30
    b588:	f2 95       	swap	r31
    b58a:	f0 7f       	andi	r31, 0xF0	; 240
    b58c:	fe 27       	eor	r31, r30
    b58e:	e0 7f       	andi	r30, 0xF0	; 240
    b590:	fe 27       	eor	r31, r30
    b592:	ef 5f       	subi	r30, 0xFF	; 255
    b594:	fa 4f       	sbci	r31, 0xFA	; 250
    b596:	20 e0       	ldi	r18, 0x00	; 0
		for (uint8_t i=0; i<TerFiltLev*4; TerBuf[ChanN][i++]=TerInput[ChanN]);
    b598:	c1 93       	st	Z+, r28
    b59a:	d1 93       	st	Z+, r29
    b59c:	2f 5f       	subi	r18, 0xFF	; 255
    b59e:	20 31       	cpi	r18, 0x10	; 16
    b5a0:	d9 f7       	brne	.-10     	; 0xb598 <ThermInit+0x40>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    b5a2:	fc 01       	movw	r30, r24
    b5a4:	e3 54       	subi	r30, 0x43	; 67
    b5a6:	f9 4f       	sbci	r31, 0xF9	; 249
    b5a8:	e4 90       	lpm	r14, Z+
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    b5aa:	89 5e       	subi	r24, 0xE9	; 233
    b5ac:	9e 4f       	sbci	r25, 0xFE	; 254
    b5ae:	0e 94 1d 8e 	call	0x11c3a	; 0x11c3a <__eerd_byte_m2560>
    b5b2:	68 2f       	mov	r22, r24
		Temperature[ChanN] = Thermode(prb(ThermFami+ChanN), erb(ThermType+ChanN), TerInput[ChanN]);
    b5b4:	8e 2d       	mov	r24, r14
    b5b6:	ae 01       	movw	r20, r28
    b5b8:	0e 94 d6 48 	call	0x91ac	; 0x91ac <Thermode>
    b5bc:	0b 5b       	subi	r16, 0xBB	; 187
    b5be:	19 4f       	sbci	r17, 0xF9	; 249
    b5c0:	f8 01       	movw	r30, r16
    b5c2:	91 83       	std	Z+1, r25	; 0x01
    b5c4:	80 83       	st	Z, r24
    b5c6:	80 e0       	ldi	r24, 0x00	; 0
    b5c8:	f5 e0       	ldi	r31, 0x05	; 5
    b5ca:	ff 12       	cpse	r15, r31
    b5cc:	81 e0       	ldi	r24, 0x01	; 1
	}
	return ChanN!=TerReg-1;
}
    b5ce:	df 91       	pop	r29
    b5d0:	cf 91       	pop	r28
    b5d2:	1f 91       	pop	r17
    b5d4:	0f 91       	pop	r16
    b5d6:	ff 90       	pop	r15
    b5d8:	ef 90       	pop	r14
    b5da:	08 95       	ret

0000b5dc <DigitIn>:
}

// ~~~~~~~~~~
void
DigitIn(void)
{
    b5dc:	cf 93       	push	r28
    b5de:	df 93       	push	r29
	memcpy(DigInput.StateOld, DigInput.State, DI_Reg+DI_Reg_Ext);
    b5e0:	e3 e4       	ldi	r30, 0x43	; 67
    b5e2:	f7 e0       	ldi	r31, 0x07	; 7
    b5e4:	df 01       	movw	r26, r30
    b5e6:	13 97       	sbiw	r26, 0x03	; 3
    b5e8:	83 e0       	ldi	r24, 0x03	; 3
    b5ea:	0d 90       	ld	r0, X+
    b5ec:	01 92       	st	Z+, r0
    b5ee:	81 50       	subi	r24, 0x01	; 1
    b5f0:	e1 f7       	brne	.-8      	; 0xb5ea <DigitIn+0xe>
    b5f2:	84 e1       	ldi	r24, 0x14	; 20
    b5f4:	91 e0       	ldi	r25, 0x01	; 1
    b5f6:	0e 94 1d 8e 	call	0x11c3a	; 0x11c3a <__eerd_byte_m2560>
	for (uint8_t i=0; i<DI_Reg; i++)
		DigInput.Status[i] = DigInput.State[i]^erb(DI_Invers+i);
    b5fa:	90 91 40 07 	lds	r25, 0x0740
    b5fe:	98 27       	eor	r25, r24
    b600:	90 93 46 07 	sts	0x0746, r25
    b604:	85 e1       	ldi	r24, 0x15	; 21
    b606:	91 e0       	ldi	r25, 0x01	; 1
    b608:	0e 94 1d 8e 	call	0x11c3a	; 0x11c3a <__eerd_byte_m2560>
    b60c:	90 91 41 07 	lds	r25, 0x0741
    b610:	98 27       	eor	r25, r24
    b612:	90 93 47 07 	sts	0x0747, r25
    b616:	86 e1       	ldi	r24, 0x16	; 22
    b618:	91 e0       	ldi	r25, 0x01	; 1
    b61a:	0e 94 1d 8e 	call	0x11c3a	; 0x11c3a <__eerd_byte_m2560>
    b61e:	90 91 42 07 	lds	r25, 0x0742
    b622:	98 27       	eor	r25, r24
    b624:	90 93 48 07 	sts	0x0748, r25
    b628:	40 e0       	ldi	r20, 0x00	; 0
    b62a:	50 e0       	ldi	r21, 0x00	; 0
#else
	static void
	DigitIn_Hard(void)
	{
		for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
			uint8_t Byte=D_N/8, Bit=1<<D_N%8;
    b62c:	a1 e0       	ldi	r26, 0x01	; 1
    b62e:	b0 e0       	ldi	r27, 0x00	; 0
    b630:	1b c0       	rjmp	.+54     	; 0xb668 <DigitIn+0x8c>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    b632:	c9 01       	movw	r24, r18
    b634:	8e 56       	subi	r24, 0x6E	; 110
    b636:	92 4c       	sbci	r25, 0xC2	; 194
    b638:	fc 01       	movw	r30, r24
    b63a:	c5 91       	lpm	r28, Z+
    b63c:	d4 91       	lpm	r29, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    b63e:	2c 56       	subi	r18, 0x6C	; 108
    b640:	32 4c       	sbci	r19, 0xC2	; 194
    b642:	f9 01       	movw	r30, r18
    b644:	84 91       	lpm	r24, Z+
			if(prb(&DI_M[D_N].Inversion)){
				if (*(uint8_t*)prp(&DI_M[D_N].PIN) & prb(&DI_M[D_N].P))
    b646:	98 81       	ld	r25, Y
    b648:	89 23       	and	r24, r25
    b64a:	09 f4       	brne	.+2      	; 0xb64e <DigitIn+0x72>
    b64c:	3d c0       	rjmp	.+122    	; 0xb6c8 <DigitIn+0xec>
			}
			else{
				if (*(uint8_t*)prp(&DI_M[D_N].PIN) & prb(&DI_M[D_N].P))
					DigInput.State[Byte] &=~Bit;
				else
					DigInput.State[Byte]  |=Bit;
    b64e:	e7 2f       	mov	r30, r23
    b650:	f0 e0       	ldi	r31, 0x00	; 0
    b652:	e0 5c       	subi	r30, 0xC0	; 192
    b654:	f8 4f       	sbci	r31, 0xF8	; 248
    b656:	80 81       	ld	r24, Z
    b658:	86 2b       	or	r24, r22
    b65a:	80 83       	st	Z, r24
    b65c:	4f 5f       	subi	r20, 0xFF	; 255
    b65e:	5f 4f       	sbci	r21, 0xFF	; 255
	void DigitIn_Hard(void);
#else
	static void
	DigitIn_Hard(void)
	{
		for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
    b660:	42 31       	cpi	r20, 0x12	; 18
    b662:	51 05       	cpc	r21, r1
    b664:	09 f4       	brne	.+2      	; 0xb668 <DigitIn+0x8c>
    b666:	3e c0       	rjmp	.+124    	; 0xb6e4 <DigitIn+0x108>
			uint8_t Byte=D_N/8, Bit=1<<D_N%8;
    b668:	74 2f       	mov	r23, r20
    b66a:	76 95       	lsr	r23
    b66c:	76 95       	lsr	r23
    b66e:	76 95       	lsr	r23
    b670:	ca 01       	movw	r24, r20
    b672:	87 70       	andi	r24, 0x07	; 7
    b674:	90 70       	andi	r25, 0x00	; 0
    b676:	9d 01       	movw	r18, r26
    b678:	02 c0       	rjmp	.+4      	; 0xb67e <DigitIn+0xa2>
    b67a:	22 0f       	add	r18, r18
    b67c:	33 1f       	adc	r19, r19
    b67e:	8a 95       	dec	r24
    b680:	e2 f7       	brpl	.-8      	; 0xb67a <DigitIn+0x9e>
    b682:	62 2f       	mov	r22, r18
    b684:	9a 01       	movw	r18, r20
    b686:	22 0f       	add	r18, r18
    b688:	33 1f       	adc	r19, r19
    b68a:	22 0f       	add	r18, r18
    b68c:	33 1f       	adc	r19, r19
    b68e:	22 0f       	add	r18, r18
    b690:	33 1f       	adc	r19, r19
    b692:	f9 01       	movw	r30, r18
    b694:	eb 56       	subi	r30, 0x6B	; 107
    b696:	f2 4c       	sbci	r31, 0xC2	; 194
    b698:	e4 91       	lpm	r30, Z+
			if(prb(&DI_M[D_N].Inversion)){
    b69a:	ee 23       	and	r30, r30
    b69c:	09 f0       	breq	.+2      	; 0xb6a0 <DigitIn+0xc4>
    b69e:	c9 cf       	rjmp	.-110    	; 0xb632 <DigitIn+0x56>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    b6a0:	ca 01       	movw	r24, r20
    b6a2:	88 0f       	add	r24, r24
    b6a4:	99 1f       	adc	r25, r25
    b6a6:	88 0f       	add	r24, r24
    b6a8:	99 1f       	adc	r25, r25
    b6aa:	88 0f       	add	r24, r24
    b6ac:	99 1f       	adc	r25, r25
    b6ae:	8e 56       	subi	r24, 0x6E	; 110
    b6b0:	92 4c       	sbci	r25, 0xC2	; 194
    b6b2:	fc 01       	movw	r30, r24
    b6b4:	c5 91       	lpm	r28, Z+
    b6b6:	d4 91       	lpm	r29, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    b6b8:	2c 56       	subi	r18, 0x6C	; 108
    b6ba:	32 4c       	sbci	r19, 0xC2	; 194
    b6bc:	f9 01       	movw	r30, r18
    b6be:	84 91       	lpm	r24, Z+
					DigInput.State[Byte] |=Bit;
				else
					DigInput.State[Byte] &=~Bit;
			}
			else{
				if (*(uint8_t*)prp(&DI_M[D_N].PIN) & prb(&DI_M[D_N].P))
    b6c0:	98 81       	ld	r25, Y
    b6c2:	89 23       	and	r24, r25
    b6c4:	09 f4       	brne	.+2      	; 0xb6c8 <DigitIn+0xec>
    b6c6:	c3 cf       	rjmp	.-122    	; 0xb64e <DigitIn+0x72>
					DigInput.State[Byte] &=~Bit;
    b6c8:	e7 2f       	mov	r30, r23
    b6ca:	f0 e0       	ldi	r31, 0x00	; 0
    b6cc:	e0 5c       	subi	r30, 0xC0	; 192
    b6ce:	f8 4f       	sbci	r31, 0xF8	; 248
    b6d0:	60 95       	com	r22
    b6d2:	80 81       	ld	r24, Z
    b6d4:	68 23       	and	r22, r24
    b6d6:	60 83       	st	Z, r22
				else
					DigInput.State[Byte]  |=Bit;
    b6d8:	4f 5f       	subi	r20, 0xFF	; 255
    b6da:	5f 4f       	sbci	r21, 0xFF	; 255
	void DigitIn_Hard(void);
#else
	static void
	DigitIn_Hard(void)
	{
		for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
    b6dc:	42 31       	cpi	r20, 0x12	; 18
    b6de:	51 05       	cpc	r21, r1
    b6e0:	09 f0       	breq	.+2      	; 0xb6e4 <DigitIn+0x108>
    b6e2:	c2 cf       	rjmp	.-124    	; 0xb668 <DigitIn+0x8c>
			DigInput.State[j]		= (DigInput_Ext)[i];
			DigInput.Status[j]	= (DigInput_Ext)[i+DI_Reg_Ext];
			IntOn();
		}
	#endif
}
    b6e4:	df 91       	pop	r29
    b6e6:	cf 91       	pop	r28
    b6e8:	08 95       	ret

0000b6ea <Field2Buf>:
	else return 0;
}
// ~~~~~~~~~~~~~~~~~~~~~~~
static void
Field2Buf(OutField *Field)
{
    b6ea:	6f 92       	push	r6
    b6ec:	7f 92       	push	r7
    b6ee:	8f 92       	push	r8
    b6f0:	9f 92       	push	r9
    b6f2:	af 92       	push	r10
    b6f4:	bf 92       	push	r11
    b6f6:	cf 92       	push	r12
    b6f8:	df 92       	push	r13
    b6fa:	ef 92       	push	r14
    b6fc:	ff 92       	push	r15
    b6fe:	0f 93       	push	r16
    b700:	1f 93       	push	r17
    b702:	df 93       	push	r29
    b704:	cf 93       	push	r28
    b706:	cd b7       	in	r28, 0x3d	; 61
    b708:	de b7       	in	r29, 0x3e	; 62
    b70a:	6f 97       	sbiw	r28, 0x1f	; 31
    b70c:	0f b6       	in	r0, 0x3f	; 63
    b70e:	f8 94       	cli
    b710:	de bf       	out	0x3e, r29	; 62
    b712:	0f be       	out	0x3f, r0	; 63
    b714:	cd bf       	out	0x3d, r28	; 61
    b716:	7c 01       	movw	r14, r24

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    b718:	fc 01       	movw	r30, r24
    b71a:	31 96       	adiw	r30, 0x01	; 1
    b71c:	c5 90       	lpm	r12, Z+
    b71e:	d4 90       	lpm	r13, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    b720:	bf e0       	ldi	r27, 0x0F	; 15
    b722:	8b 2e       	mov	r8, r27
    b724:	91 2c       	mov	r9, r1
    b726:	88 0e       	add	r8, r24
    b728:	99 1e       	adc	r9, r25
    b72a:	f4 01       	movw	r30, r8
    b72c:	24 91       	lpm	r18, Z+
	void *Var = prp(&Field->Var);
	uint8_t BitN=prb(&Field->Prec), Mask=1<<BitN%8, *BitVar=(uint8_t*)Var+BitN/8;
    b72e:	32 2f       	mov	r19, r18
    b730:	37 70       	andi	r19, 0x07	; 7
    b732:	81 e0       	ldi	r24, 0x01	; 1
    b734:	90 e0       	ldi	r25, 0x00	; 0
    b736:	18 2f       	mov	r17, r24
    b738:	01 c0       	rjmp	.+2      	; 0xb73c <Field2Buf+0x52>
    b73a:	11 0f       	add	r17, r17
    b73c:	3a 95       	dec	r19
    b73e:	ea f7       	brpl	.-6      	; 0xb73a <Field2Buf+0x50>
    b740:	26 95       	lsr	r18
    b742:	26 95       	lsr	r18
    b744:	26 95       	lsr	r18
    b746:	56 01       	movw	r10, r12
    b748:	a2 0e       	add	r10, r18
    b74a:	b1 1c       	adc	r11, r1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    b74c:	a7 e0       	ldi	r26, 0x07	; 7
    b74e:	6a 2e       	mov	r6, r26
    b750:	71 2c       	mov	r7, r1
    b752:	6e 0c       	add	r6, r14
    b754:	7f 1c       	adc	r7, r15
    b756:	f3 01       	movw	r30, r6
    b758:	65 91       	lpm	r22, Z+
    b75a:	75 91       	lpm	r23, Z+
    b75c:	85 91       	lpm	r24, Z+
    b75e:	94 91       	lpm	r25, Z+
	uint8_t Pos=Log10(prd(&Field->Max));
    b760:	0e 94 48 2a 	call	0x5490	; 0x5490 <Log10>
    b764:	08 2f       	mov	r16, r24

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    b766:	f7 01       	movw	r30, r14
    b768:	84 91       	lpm	r24, Z+
	uint8_t Oldstyle = 0;

	switch(prb(&Field->Type)) {
    b76a:	e8 2f       	mov	r30, r24
    b76c:	f0 e0       	ldi	r31, 0x00	; 0
    b76e:	e1 32       	cpi	r30, 0x21	; 33
    b770:	f1 05       	cpc	r31, r1
    b772:	08 f4       	brcc	.+2      	; 0xb776 <Field2Buf+0x8c>
    b774:	6e c0       	rjmp	.+220    	; 0xb852 <Field2Buf+0x168>
		F_Buf = (erb(BitVar) &Mask) > 0;
		Oldstyle = 1;
		break;
	}

	Minus=0;
    b776:	10 92 ff 04 	sts	0x04FF, r1
	if(Oldstyle) return;

	InitBufStr(Field);
    b77a:	c7 01       	movw	r24, r14
    b77c:	0e 94 b4 45 	call	0x8b68	; 0x8b68 <InitBufStr>
	CurrFieldSize = GetCurrFieldSize();
    b780:	0e 94 76 46 	call	0x8cec	; 0x8cec <GetCurrFieldSize>
    b784:	48 2f       	mov	r20, r24
    b786:	80 93 c0 07 	sts	0x07C0, r24
	CurrPos = CurrFieldSize - 1;
    b78a:	41 50       	subi	r20, 0x01	; 1
    b78c:	40 93 d7 02 	sts	0x02D7, r20
    b790:	4f 5f       	subi	r20, 0xFF	; 255
	float fTemp;
	T_Param Param;
	Param.Size = CurrFieldSize;
    b792:	48 87       	std	Y+8, r20	; 0x08
	Param.Pos = BufStr;
    b794:	83 ec       	ldi	r24, 0xC3	; 195
    b796:	95 e0       	ldi	r25, 0x05	; 5
    b798:	9e 83       	std	Y+6, r25	; 0x06
    b79a:	8d 83       	std	Y+5, r24	; 0x05
    b79c:	f4 01       	movw	r30, r8
    b79e:	84 91       	lpm	r24, Z+
	Param.Prec = prb(&Field->Prec);
    b7a0:	8f 83       	std	Y+7, r24	; 0x07
	Param.Txt = NULL;
    b7a2:	1a 86       	std	Y+10, r1	; 0x0a
    b7a4:	19 86       	std	Y+9, r1	; 0x09
    b7a6:	f7 01       	movw	r30, r14
    b7a8:	84 91       	lpm	r24, Z+

	switch(prb(&Field->Type)) {
    b7aa:	85 31       	cpi	r24, 0x15	; 21
    b7ac:	09 f4       	brne	.+2      	; 0xb7b0 <Field2Buf+0xc6>
    b7ae:	74 c1       	rjmp	.+744    	; 0xba98 <Field2Buf+0x3ae>
    b7b0:	86 31       	cpi	r24, 0x16	; 22
    b7b2:	08 f4       	brcc	.+2      	; 0xb7b6 <Field2Buf+0xcc>
    b7b4:	56 c1       	rjmp	.+684    	; 0xba62 <Field2Buf+0x378>
    b7b6:	8b 31       	cpi	r24, 0x1B	; 27
    b7b8:	09 f4       	brne	.+2      	; 0xb7bc <Field2Buf+0xd2>
    b7ba:	fe c1       	rjmp	.+1020   	; 0xbbb8 <Field2Buf+0x4ce>
    b7bc:	8c 31       	cpi	r24, 0x1C	; 28
    b7be:	08 f0       	brcs	.+2      	; 0xb7c2 <Field2Buf+0xd8>
    b7c0:	b7 c1       	rjmp	.+878    	; 0xbb30 <Field2Buf+0x446>
    b7c2:	89 31       	cpi	r24, 0x19	; 25
    b7c4:	09 f4       	brne	.+2      	; 0xb7c8 <Field2Buf+0xde>
    b7c6:	92 c1       	rjmp	.+804    	; 0xbaec <Field2Buf+0x402>
    b7c8:	8a 31       	cpi	r24, 0x1A	; 26
    b7ca:	09 f0       	breq	.+2      	; 0xb7ce <Field2Buf+0xe4>
    b7cc:	5b c0       	rjmp	.+182    	; 0xb884 <Field2Buf+0x19a>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    b7ce:	7e 01       	movw	r14, r28
    b7d0:	08 94       	sec
    b7d2:	e1 1c       	adc	r14, r1
    b7d4:	f1 1c       	adc	r15, r1
    b7d6:	c7 01       	movw	r24, r14
    b7d8:	b6 01       	movw	r22, r12
    b7da:	44 e0       	ldi	r20, 0x04	; 4
    b7dc:	50 e0       	ldi	r21, 0x00	; 0
    b7de:	0e 94 0d 8e 	call	0x11c1a	; 0x11c1a <__eerd_block_m2560>
		Put_FFVal(*(float*)Var, &Param);
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
		break;
	case EE_FFloat:
		erbl(&fTemp, Var, 4);
		Put_FFVal(fTemp, &Param);
    b7e2:	69 81       	ldd	r22, Y+1	; 0x01
    b7e4:	7a 81       	ldd	r23, Y+2	; 0x02
    b7e6:	8b 81       	ldd	r24, Y+3	; 0x03
    b7e8:	9c 81       	ldd	r25, Y+4	; 0x04
    b7ea:	8e 01       	movw	r16, r28
    b7ec:	0b 5f       	subi	r16, 0xFB	; 251
    b7ee:	1f 4f       	sbci	r17, 0xFF	; 255
    b7f0:	a8 01       	movw	r20, r16
    b7f2:	0e 94 79 4e 	call	0x9cf2	; 0x9cf2 <Put_FFVal>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
    b7f6:	8e ea       	ldi	r24, 0xAE	; 174
    b7f8:	96 e0       	ldi	r25, 0x06	; 6
    b7fa:	60 91 c3 05 	lds	r22, 0x05C3
    b7fe:	0e 94 42 4b 	call	0x9684	; 0x9684 <GetMultiSymbol>
    b802:	80 93 f4 04 	sts	0x04F4, r24
	case GFloat:
		Put_GFVal(*(float*)Var, &Param);
    b806:	f6 01       	movw	r30, r12
    b808:	60 81       	ld	r22, Z
    b80a:	71 81       	ldd	r23, Z+1	; 0x01
    b80c:	82 81       	ldd	r24, Z+2	; 0x02
    b80e:	93 81       	ldd	r25, Z+3	; 0x03
    b810:	a8 01       	movw	r20, r16
    b812:	0e 94 ff 4d 	call	0x9bfe	; 0x9bfe <Put_GFVal>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
    b816:	8e ea       	ldi	r24, 0xAE	; 174
    b818:	96 e0       	ldi	r25, 0x06	; 6
    b81a:	60 91 c3 05 	lds	r22, 0x05C3
    b81e:	0e 94 42 4b 	call	0x9684	; 0x9684 <GetMultiSymbol>
    b822:	80 93 f4 04 	sts	0x04F4, r24
    b826:	c7 01       	movw	r24, r14
    b828:	b6 01       	movw	r22, r12
    b82a:	44 e0       	ldi	r20, 0x04	; 4
    b82c:	50 e0       	ldi	r21, 0x00	; 0
    b82e:	0e 94 0d 8e 	call	0x11c1a	; 0x11c1a <__eerd_block_m2560>
	case EE_GFloat:
		erbl(&fTemp, Var, 4);
		Put_GFVal(fTemp, &Param);
    b832:	69 81       	ldd	r22, Y+1	; 0x01
    b834:	7a 81       	ldd	r23, Y+2	; 0x02
    b836:	8b 81       	ldd	r24, Y+3	; 0x03
    b838:	9c 81       	ldd	r25, Y+4	; 0x04
    b83a:	a8 01       	movw	r20, r16
    b83c:	0e 94 ff 4d 	call	0x9bfe	; 0x9bfe <Put_GFVal>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
    b840:	8e ea       	ldi	r24, 0xAE	; 174
    b842:	96 e0       	ldi	r25, 0x06	; 6
    b844:	60 91 c3 05 	lds	r22, 0x05C3
    b848:	0e 94 42 4b 	call	0x9684	; 0x9684 <GetMultiSymbol>
    b84c:	80 93 f4 04 	sts	0x04F4, r24
    b850:	19 c0       	rjmp	.+50     	; 0xb884 <Field2Buf+0x19a>
	void *Var = prp(&Field->Var);
	uint8_t BitN=prb(&Field->Prec), Mask=1<<BitN%8, *BitVar=(uint8_t*)Var+BitN/8;
	uint8_t Pos=Log10(prd(&Field->Max));
	uint8_t Oldstyle = 0;

	switch(prb(&Field->Type)) {
    b852:	ee 58       	subi	r30, 0x8E	; 142
    b854:	ff 4f       	sbci	r31, 0xFF	; 255
    b856:	ee 0f       	add	r30, r30
    b858:	ff 1f       	adc	r31, r31
    b85a:	05 90       	lpm	r0, Z+
    b85c:	f4 91       	lpm	r31, Z+
    b85e:	e0 2d       	mov	r30, r0
    b860:	19 94       	eijmp
	case Byte: case z_Byte:
		F_Buf = *(uint8_t*)Var;
    b862:	f6 01       	movw	r30, r12
    b864:	80 81       	ld	r24, Z
    b866:	90 e0       	ldi	r25, 0x00	; 0
    b868:	a0 e0       	ldi	r26, 0x00	; 0
    b86a:	b0 e0       	ldi	r27, 0x00	; 0
    b86c:	80 93 f7 04 	sts	0x04F7, r24
    b870:	90 93 f8 04 	sts	0x04F8, r25
    b874:	a0 93 f9 04 	sts	0x04F9, r26
    b878:	b0 93 fa 04 	sts	0x04FA, r27
		CurrPos = Pos;
    b87c:	00 93 d7 02 	sts	0x02D7, r16
		F_Buf = (erb(BitVar) &Mask) > 0;
		Oldstyle = 1;
		break;
	}

	Minus=0;
    b880:	10 92 ff 04 	sts	0x04FF, r1
				MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[0]);
			else MultiSymbol = GetMultiSymbol(Symbols_P, BufStr[0]);
		}
		break;
	}
}
    b884:	6f 96       	adiw	r28, 0x1f	; 31
    b886:	0f b6       	in	r0, 0x3f	; 63
    b888:	f8 94       	cli
    b88a:	de bf       	out	0x3e, r29	; 62
    b88c:	0f be       	out	0x3f, r0	; 63
    b88e:	cd bf       	out	0x3d, r28	; 61
    b890:	cf 91       	pop	r28
    b892:	df 91       	pop	r29
    b894:	1f 91       	pop	r17
    b896:	0f 91       	pop	r16
    b898:	ff 90       	pop	r15
    b89a:	ef 90       	pop	r14
    b89c:	df 90       	pop	r13
    b89e:	cf 90       	pop	r12
    b8a0:	bf 90       	pop	r11
    b8a2:	af 90       	pop	r10
    b8a4:	9f 90       	pop	r9
    b8a6:	8f 90       	pop	r8
    b8a8:	7f 90       	pop	r7
    b8aa:	6f 90       	pop	r6
    b8ac:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    b8ae:	c6 01       	movw	r24, r12
    b8b0:	0e 94 1d 8e 	call	0x11c3a	; 0x11c3a <__eerd_byte_m2560>
		sF_Buf = *(int8_t*)Var;
		CurrPos = Pos+1;
		Oldstyle = 1;
		break;
	case EE_Byte: case z_EE_Byte:
		F_Buf = erb((uint8_t*)Var);
    b8b4:	90 e0       	ldi	r25, 0x00	; 0
    b8b6:	a0 e0       	ldi	r26, 0x00	; 0
    b8b8:	b0 e0       	ldi	r27, 0x00	; 0
    b8ba:	80 93 f7 04 	sts	0x04F7, r24
    b8be:	90 93 f8 04 	sts	0x04F8, r25
    b8c2:	a0 93 f9 04 	sts	0x04F9, r26
    b8c6:	b0 93 fa 04 	sts	0x04FA, r27
		CurrPos = Pos;
    b8ca:	00 93 d7 02 	sts	0x02D7, r16
    b8ce:	d8 cf       	rjmp	.-80     	; 0xb880 <Field2Buf+0x196>
		F_Buf = *(uint8_t*)Var;
		CurrPos = Pos;
		Oldstyle = 1;
		break;
	case s_Byte:
		sF_Buf = *(int8_t*)Var;
    b8d0:	f6 01       	movw	r30, r12
    b8d2:	80 81       	ld	r24, Z
    b8d4:	99 27       	eor	r25, r25
    b8d6:	87 fd       	sbrc	r24, 7
    b8d8:	90 95       	com	r25
    b8da:	a9 2f       	mov	r26, r25
    b8dc:	b9 2f       	mov	r27, r25
    b8de:	80 93 fb 04 	sts	0x04FB, r24
    b8e2:	90 93 fc 04 	sts	0x04FC, r25
    b8e6:	a0 93 fd 04 	sts	0x04FD, r26
    b8ea:	b0 93 fe 04 	sts	0x04FE, r27
		CurrPos = Pos+1;
    b8ee:	0f 5f       	subi	r16, 0xFF	; 255
    b8f0:	00 93 d7 02 	sts	0x02D7, r16
    b8f4:	c5 cf       	rjmp	.-118    	; 0xb880 <Field2Buf+0x196>
    b8f6:	c6 01       	movw	r24, r12
    b8f8:	0e 94 1d 8e 	call	0x11c3a	; 0x11c3a <__eerd_byte_m2560>
		F_Buf = erb((uint8_t*)Var);
		CurrPos = Pos;
		Oldstyle = 1;
		break;
	case s_EE_Byte:
		sF_Buf = (int8_t)erb((uint8_t*)Var);
    b8fc:	99 27       	eor	r25, r25
    b8fe:	87 fd       	sbrc	r24, 7
    b900:	90 95       	com	r25
    b902:	a9 2f       	mov	r26, r25
    b904:	b9 2f       	mov	r27, r25
    b906:	80 93 fb 04 	sts	0x04FB, r24
    b90a:	90 93 fc 04 	sts	0x04FC, r25
    b90e:	a0 93 fd 04 	sts	0x04FD, r26
    b912:	b0 93 fe 04 	sts	0x04FE, r27
		CurrPos = Pos+1;
    b916:	0f 5f       	subi	r16, 0xFF	; 255
    b918:	00 93 d7 02 	sts	0x02D7, r16
    b91c:	b1 cf       	rjmp	.-158    	; 0xb880 <Field2Buf+0x196>
		Oldstyle = 1;
		break;

	case Word: case z_Word:
		F_Buf = *(uint16_t*)Var;
    b91e:	f6 01       	movw	r30, r12
    b920:	80 81       	ld	r24, Z
    b922:	91 81       	ldd	r25, Z+1	; 0x01
    b924:	a0 e0       	ldi	r26, 0x00	; 0
    b926:	b0 e0       	ldi	r27, 0x00	; 0
    b928:	80 93 f7 04 	sts	0x04F7, r24
    b92c:	90 93 f8 04 	sts	0x04F8, r25
    b930:	a0 93 f9 04 	sts	0x04F9, r26
    b934:	b0 93 fa 04 	sts	0x04FA, r27
		CurrPos = Pos;
    b938:	00 93 d7 02 	sts	0x02D7, r16
    b93c:	a1 cf       	rjmp	.-190    	; 0xb880 <Field2Buf+0x196>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    b93e:	c6 01       	movw	r24, r12
    b940:	0e 94 2b 8e 	call	0x11c56	; 0x11c56 <__eerd_word_m2560>
		Oldstyle = 1;
		break;
	case EE_Word: case z_EE_Word:
		F_Buf = erw((uint16_t*)Var);
    b944:	a0 e0       	ldi	r26, 0x00	; 0
    b946:	b0 e0       	ldi	r27, 0x00	; 0
    b948:	80 93 f7 04 	sts	0x04F7, r24
    b94c:	90 93 f8 04 	sts	0x04F8, r25
    b950:	a0 93 f9 04 	sts	0x04F9, r26
    b954:	b0 93 fa 04 	sts	0x04FA, r27
		CurrPos = Pos;
    b958:	00 93 d7 02 	sts	0x02D7, r16
    b95c:	91 cf       	rjmp	.-222    	; 0xb880 <Field2Buf+0x196>
		Oldstyle = 1;
		break;
	case s_Word:
		sF_Buf = *(int16_t*)Var;
    b95e:	f6 01       	movw	r30, r12
    b960:	80 81       	ld	r24, Z
    b962:	91 81       	ldd	r25, Z+1	; 0x01
    b964:	aa 27       	eor	r26, r26
    b966:	97 fd       	sbrc	r25, 7
    b968:	a0 95       	com	r26
    b96a:	ba 2f       	mov	r27, r26
    b96c:	80 93 fb 04 	sts	0x04FB, r24
    b970:	90 93 fc 04 	sts	0x04FC, r25
    b974:	a0 93 fd 04 	sts	0x04FD, r26
    b978:	b0 93 fe 04 	sts	0x04FE, r27
		CurrPos = Pos+1;
    b97c:	0f 5f       	subi	r16, 0xFF	; 255
    b97e:	00 93 d7 02 	sts	0x02D7, r16
    b982:	7e cf       	rjmp	.-260    	; 0xb880 <Field2Buf+0x196>
    b984:	c6 01       	movw	r24, r12
    b986:	0e 94 2b 8e 	call	0x11c56	; 0x11c56 <__eerd_word_m2560>
		Oldstyle = 1;
		break;
	case s_EE_Word:
		sF_Buf = (int16_t)erw((uint16_t*)Var);
    b98a:	aa 27       	eor	r26, r26
    b98c:	97 fd       	sbrc	r25, 7
    b98e:	a0 95       	com	r26
    b990:	ba 2f       	mov	r27, r26
    b992:	80 93 fb 04 	sts	0x04FB, r24
    b996:	90 93 fc 04 	sts	0x04FC, r25
    b99a:	a0 93 fd 04 	sts	0x04FD, r26
    b99e:	b0 93 fe 04 	sts	0x04FE, r27
		CurrPos = Pos+1;
    b9a2:	0f 5f       	subi	r16, 0xFF	; 255
    b9a4:	00 93 d7 02 	sts	0x02D7, r16
    b9a8:	6b cf       	rjmp	.-298    	; 0xb880 <Field2Buf+0x196>
		Oldstyle = 1;
		break;
	case c_Word: case zc_Word:
		F_Buf = *(uint16_t*)Var;
    b9aa:	f6 01       	movw	r30, r12
    b9ac:	80 81       	ld	r24, Z
    b9ae:	91 81       	ldd	r25, Z+1	; 0x01
    b9b0:	a0 e0       	ldi	r26, 0x00	; 0
    b9b2:	b0 e0       	ldi	r27, 0x00	; 0
    b9b4:	80 93 f7 04 	sts	0x04F7, r24
    b9b8:	90 93 f8 04 	sts	0x04F8, r25
    b9bc:	a0 93 f9 04 	sts	0x04F9, r26
    b9c0:	b0 93 fa 04 	sts	0x04FA, r27
    b9c4:	5d cf       	rjmp	.-326    	; 0xb880 <Field2Buf+0x196>
		Oldstyle = 1;
		break;

	case Enum:
		F_Buf = *(uint8_t*)Var;
    b9c6:	f6 01       	movw	r30, r12
    b9c8:	80 81       	ld	r24, Z
    b9ca:	90 e0       	ldi	r25, 0x00	; 0
    b9cc:	a0 e0       	ldi	r26, 0x00	; 0
    b9ce:	b0 e0       	ldi	r27, 0x00	; 0
    b9d0:	80 93 f7 04 	sts	0x04F7, r24
    b9d4:	90 93 f8 04 	sts	0x04F8, r25
    b9d8:	a0 93 f9 04 	sts	0x04F9, r26
    b9dc:	b0 93 fa 04 	sts	0x04FA, r27
    b9e0:	4f cf       	rjmp	.-354    	; 0xb880 <Field2Buf+0x196>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    b9e2:	c6 01       	movw	r24, r12
    b9e4:	0e 94 1d 8e 	call	0x11c3a	; 0x11c3a <__eerd_byte_m2560>
		Oldstyle = 1;
		break;
	case EE_Enum:
		F_Buf = erb((uint8_t*)Var);
    b9e8:	90 e0       	ldi	r25, 0x00	; 0
    b9ea:	a0 e0       	ldi	r26, 0x00	; 0
    b9ec:	b0 e0       	ldi	r27, 0x00	; 0
    b9ee:	80 93 f7 04 	sts	0x04F7, r24
    b9f2:	90 93 f8 04 	sts	0x04F8, r25
    b9f6:	a0 93 f9 04 	sts	0x04F9, r26
    b9fa:	b0 93 fa 04 	sts	0x04FA, r27
    b9fe:	40 cf       	rjmp	.-384    	; 0xb880 <Field2Buf+0x196>
		Oldstyle = 1;
		break;
	case Bit:
		F_Buf = (*BitVar &Mask) > 0;
    ba00:	20 e0       	ldi	r18, 0x00	; 0
    ba02:	30 e0       	ldi	r19, 0x00	; 0
    ba04:	40 e0       	ldi	r20, 0x00	; 0
    ba06:	50 e0       	ldi	r21, 0x00	; 0
    ba08:	f5 01       	movw	r30, r10
    ba0a:	80 81       	ld	r24, Z
    ba0c:	81 23       	and	r24, r17
    ba0e:	21 f5       	brne	.+72     	; 0xba58 <Field2Buf+0x36e>
    ba10:	20 93 f7 04 	sts	0x04F7, r18
    ba14:	30 93 f8 04 	sts	0x04F8, r19
    ba18:	40 93 f9 04 	sts	0x04F9, r20
    ba1c:	50 93 fa 04 	sts	0x04FA, r21
    ba20:	2f cf       	rjmp	.-418    	; 0xb880 <Field2Buf+0x196>
    ba22:	c5 01       	movw	r24, r10
    ba24:	0e 94 1d 8e 	call	0x11c3a	; 0x11c3a <__eerd_byte_m2560>
		Oldstyle = 1;
		break;
	case EE_Bit:
		F_Buf = (erb(BitVar) &Mask) > 0;
    ba28:	10 92 f7 04 	sts	0x04F7, r1
    ba2c:	10 92 f8 04 	sts	0x04F8, r1
    ba30:	10 92 f9 04 	sts	0x04F9, r1
    ba34:	10 92 fa 04 	sts	0x04FA, r1
    ba38:	18 23       	and	r17, r24
    ba3a:	09 f4       	brne	.+2      	; 0xba3e <Field2Buf+0x354>
    ba3c:	21 cf       	rjmp	.-446    	; 0xb880 <Field2Buf+0x196>
    ba3e:	81 e0       	ldi	r24, 0x01	; 1
    ba40:	90 e0       	ldi	r25, 0x00	; 0
    ba42:	a0 e0       	ldi	r26, 0x00	; 0
    ba44:	b0 e0       	ldi	r27, 0x00	; 0
    ba46:	80 93 f7 04 	sts	0x04F7, r24
    ba4a:	90 93 f8 04 	sts	0x04F8, r25
    ba4e:	a0 93 f9 04 	sts	0x04F9, r26
    ba52:	b0 93 fa 04 	sts	0x04FA, r27
    ba56:	14 cf       	rjmp	.-472    	; 0xb880 <Field2Buf+0x196>
	case EE_Enum:
		F_Buf = erb((uint8_t*)Var);
		Oldstyle = 1;
		break;
	case Bit:
		F_Buf = (*BitVar &Mask) > 0;
    ba58:	21 e0       	ldi	r18, 0x01	; 1
    ba5a:	30 e0       	ldi	r19, 0x00	; 0
    ba5c:	40 e0       	ldi	r20, 0x00	; 0
    ba5e:	50 e0       	ldi	r21, 0x00	; 0
    ba60:	d7 cf       	rjmp	.-82     	; 0xba10 <Field2Buf+0x326>
	Param.Size = CurrFieldSize;
	Param.Pos = BufStr;
	Param.Prec = prb(&Field->Prec);
	Param.Txt = NULL;

	switch(prb(&Field->Type)) {
    ba62:	82 31       	cpi	r24, 0x12	; 18
    ba64:	51 f1       	breq	.+84     	; 0xbaba <Field2Buf+0x3d0>
    ba66:	83 31       	cpi	r24, 0x13	; 19
    ba68:	08 f0       	brcs	.+2      	; 0xba6c <Field2Buf+0x382>
    ba6a:	53 c0       	rjmp	.+166    	; 0xbb12 <Field2Buf+0x428>
    ba6c:	80 31       	cpi	r24, 0x10	; 16
    ba6e:	c1 f1       	breq	.+112    	; 0xbae0 <Field2Buf+0x3f6>
    ba70:	81 31       	cpi	r24, 0x11	; 17
    ba72:	09 f0       	breq	.+2      	; 0xba76 <Field2Buf+0x38c>
    ba74:	07 cf       	rjmp	.-498    	; 0xb884 <Field2Buf+0x19a>
// ~~~~~~~~~~~~~~~~~~~~~~
uint32_t
erd(const uint32_t *addr)
{
	//IntOff();
	uint32_t word = eeprom_read_dword(addr);
    ba76:	c6 01       	movw	r24, r12
    ba78:	0e 94 25 8e 	call	0x11c4a	; 0x11c4a <__eerd_dword_m2560>
	case z_Longint:
		Put_zDVal(*(uint32_t*)Var, &Param);
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
		break;
	case EE_Longint: 
		PutDVal(erd((uint32_t*)Var), &Param);
    ba7c:	ae 01       	movw	r20, r28
    ba7e:	4b 5f       	subi	r20, 0xFB	; 251
    ba80:	5f 4f       	sbci	r21, 0xFF	; 255
    ba82:	0e 94 18 51 	call	0xa230	; 0xa230 <PutDVal>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
    ba86:	8e ea       	ldi	r24, 0xAE	; 174
    ba88:	96 e0       	ldi	r25, 0x06	; 6
    ba8a:	60 91 c3 05 	lds	r22, 0x05C3
    ba8e:	0e 94 42 4b 	call	0x9684	; 0x9684 <GetMultiSymbol>
    ba92:	80 93 f4 04 	sts	0x04F4, r24
    ba96:	f6 ce       	rjmp	.-532    	; 0xb884 <Field2Buf+0x19a>
    ba98:	c6 01       	movw	r24, r12
    ba9a:	0e 94 25 8e 	call	0x11c4a	; 0x11c4a <__eerd_dword_m2560>
		break;
	case z_EE_Longint:
		Put_zDVal(erd((uint32_t*)Var), &Param);
    ba9e:	ae 01       	movw	r20, r28
    baa0:	4b 5f       	subi	r20, 0xFB	; 251
    baa2:	5f 4f       	sbci	r21, 0xFF	; 255
    baa4:	0e 94 ce 4e 	call	0x9d9c	; 0x9d9c <Put_zDVal>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
    baa8:	8e ea       	ldi	r24, 0xAE	; 174
    baaa:	96 e0       	ldi	r25, 0x06	; 6
    baac:	60 91 c3 05 	lds	r22, 0x05C3
    bab0:	0e 94 42 4b 	call	0x9684	; 0x9684 <GetMultiSymbol>
    bab4:	80 93 f4 04 	sts	0x04F4, r24
    bab8:	e5 ce       	rjmp	.-566    	; 0xb884 <Field2Buf+0x19a>
		break;
	case s_Longint:
		Put_sDVal(*(int32_t*)Var, &Param);
    baba:	f6 01       	movw	r30, r12
    babc:	60 81       	ld	r22, Z
    babe:	71 81       	ldd	r23, Z+1	; 0x01
    bac0:	82 81       	ldd	r24, Z+2	; 0x02
    bac2:	93 81       	ldd	r25, Z+3	; 0x03
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
		break;
	case s_EE_Longint:
		Put_sDVal((int32_t)erd((uint32_t*)Var), &Param);
    bac4:	ae 01       	movw	r20, r28
    bac6:	4b 5f       	subi	r20, 0xFB	; 251
    bac8:	5f 4f       	sbci	r21, 0xFF	; 255
    baca:	0e 94 ef 4f 	call	0x9fde	; 0x9fde <Put_sDVal>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
    bace:	8e ea       	ldi	r24, 0xAE	; 174
    bad0:	96 e0       	ldi	r25, 0x06	; 6
    bad2:	60 91 c3 05 	lds	r22, 0x05C3
    bad6:	0e 94 42 4b 	call	0x9684	; 0x9684 <GetMultiSymbol>
    bada:	80 93 f4 04 	sts	0x04F4, r24
    bade:	d2 ce       	rjmp	.-604    	; 0xb884 <Field2Buf+0x19a>
	Param.Prec = prb(&Field->Prec);
	Param.Txt = NULL;

	switch(prb(&Field->Type)) {
	case Longint:
		PutDVal(*(uint32_t*)Var, &Param);
    bae0:	f6 01       	movw	r30, r12
    bae2:	60 81       	ld	r22, Z
    bae4:	71 81       	ldd	r23, Z+1	; 0x01
    bae6:	82 81       	ldd	r24, Z+2	; 0x02
    bae8:	93 81       	ldd	r25, Z+3	; 0x03
    baea:	c8 cf       	rjmp	.-112    	; 0xba7c <Field2Buf+0x392>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
		break;


	case FFloat:
		Put_FFVal(*(float*)Var, &Param);
    baec:	f6 01       	movw	r30, r12
    baee:	60 81       	ld	r22, Z
    baf0:	71 81       	ldd	r23, Z+1	; 0x01
    baf2:	82 81       	ldd	r24, Z+2	; 0x02
    baf4:	93 81       	ldd	r25, Z+3	; 0x03
    baf6:	ae 01       	movw	r20, r28
    baf8:	4b 5f       	subi	r20, 0xFB	; 251
    bafa:	5f 4f       	sbci	r21, 0xFF	; 255
    bafc:	0e 94 79 4e 	call	0x9cf2	; 0x9cf2 <Put_FFVal>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
    bb00:	8e ea       	ldi	r24, 0xAE	; 174
    bb02:	96 e0       	ldi	r25, 0x06	; 6
    bb04:	60 91 c3 05 	lds	r22, 0x05C3
    bb08:	0e 94 42 4b 	call	0x9684	; 0x9684 <GetMultiSymbol>
    bb0c:	80 93 f4 04 	sts	0x04F4, r24
    bb10:	b9 ce       	rjmp	.-654    	; 0xb884 <Field2Buf+0x19a>
	Param.Size = CurrFieldSize;
	Param.Pos = BufStr;
	Param.Prec = prb(&Field->Prec);
	Param.Txt = NULL;

	switch(prb(&Field->Type)) {
    bb12:	83 31       	cpi	r24, 0x13	; 19
    bb14:	49 f0       	breq	.+18     	; 0xbb28 <Field2Buf+0x43e>
    bb16:	84 31       	cpi	r24, 0x14	; 20
    bb18:	09 f0       	breq	.+2      	; 0xbb1c <Field2Buf+0x432>
    bb1a:	b4 ce       	rjmp	.-664    	; 0xb884 <Field2Buf+0x19a>
	case Longint:
		PutDVal(*(uint32_t*)Var, &Param);
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
		break;
	case z_Longint:
		Put_zDVal(*(uint32_t*)Var, &Param);
    bb1c:	f6 01       	movw	r30, r12
    bb1e:	60 81       	ld	r22, Z
    bb20:	71 81       	ldd	r23, Z+1	; 0x01
    bb22:	82 81       	ldd	r24, Z+2	; 0x02
    bb24:	93 81       	ldd	r25, Z+3	; 0x03
    bb26:	bb cf       	rjmp	.-138    	; 0xba9e <Field2Buf+0x3b4>
    bb28:	c6 01       	movw	r24, r12
    bb2a:	0e 94 25 8e 	call	0x11c4a	; 0x11c4a <__eerd_dword_m2560>
    bb2e:	ca cf       	rjmp	.-108    	; 0xbac4 <Field2Buf+0x3da>
	Param.Size = CurrFieldSize;
	Param.Pos = BufStr;
	Param.Prec = prb(&Field->Prec);
	Param.Txt = NULL;

	switch(prb(&Field->Type)) {
    bb30:	81 32       	cpi	r24, 0x21	; 33
    bb32:	69 f0       	breq	.+26     	; 0xbb4e <Field2Buf+0x464>
    bb34:	82 32       	cpi	r24, 0x22	; 34
    bb36:	69 f1       	breq	.+90     	; 0xbb92 <Field2Buf+0x4a8>
    bb38:	8c 31       	cpi	r24, 0x1C	; 28
    bb3a:	09 f0       	breq	.+2      	; 0xbb3e <Field2Buf+0x454>
    bb3c:	a3 ce       	rjmp	.-698    	; 0xb884 <Field2Buf+0x19a>
    bb3e:	8e 01       	movw	r16, r28
    bb40:	0b 5f       	subi	r16, 0xFB	; 251
    bb42:	1f 4f       	sbci	r17, 0xFF	; 255
    bb44:	7e 01       	movw	r14, r28
    bb46:	08 94       	sec
    bb48:	e1 1c       	adc	r14, r1
    bb4a:	f1 1c       	adc	r15, r1
    bb4c:	6c ce       	rjmp	.-808    	; 0xb826 <Field2Buf+0x13c>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
		break;


	case Text:
		Put_TextValAlignLeft((char*)Var, &Param);
    bb4e:	c6 01       	movw	r24, r12
		
		break;
	case EE_Text:{
			char TempStr[LCDXSz+1];
			erbl(TempStr, Var, CurrFieldSize);
			Put_TextValAlignLeft(TempStr, &Param);
    bb50:	be 01       	movw	r22, r28
    bb52:	6b 5f       	subi	r22, 0xFB	; 251
    bb54:	7f 4f       	sbci	r23, 0xFF	; 255
    bb56:	0e 94 47 4d 	call	0x9a8e	; 0x9a8e <Put_TextValAlignLeft>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    bb5a:	f7 01       	movw	r30, r14
    bb5c:	33 96       	adiw	r30, 0x03	; 3
    bb5e:	85 91       	lpm	r24, Z+
    bb60:	95 91       	lpm	r25, Z+
    bb62:	a5 91       	lpm	r26, Z+
    bb64:	b4 91       	lpm	r27, Z+
			if( (prd(&Field->Min) == DIGIT) && (prd(&Field->Max) == DIGIT) )
    bb66:	00 97       	sbiw	r24, 0x00	; 0
    bb68:	a1 05       	cpc	r26, r1
    bb6a:	b1 05       	cpc	r27, r1
    bb6c:	49 f4       	brne	.+18     	; 0xbb80 <Field2Buf+0x496>
    bb6e:	f3 01       	movw	r30, r6
    bb70:	85 91       	lpm	r24, Z+
    bb72:	95 91       	lpm	r25, Z+
    bb74:	a5 91       	lpm	r26, Z+
    bb76:	b4 91       	lpm	r27, Z+
    bb78:	00 97       	sbiw	r24, 0x00	; 0
    bb7a:	a1 05       	cpc	r26, r1
    bb7c:	b1 05       	cpc	r27, r1
    bb7e:	99 f0       	breq	.+38     	; 0xbba6 <Field2Buf+0x4bc>
				MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[0]);
			else MultiSymbol = GetMultiSymbol(Symbols_P, BufStr[0]);
    bb80:	85 e0       	ldi	r24, 0x05	; 5
    bb82:	96 e0       	ldi	r25, 0x06	; 6
    bb84:	60 91 c3 05 	lds	r22, 0x05C3
    bb88:	0e 94 42 4b 	call	0x9684	; 0x9684 <GetMultiSymbol>
    bb8c:	80 93 f4 04 	sts	0x04F4, r24
    bb90:	79 ce       	rjmp	.-782    	; 0xb884 <Field2Buf+0x19a>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    bb92:	8e 01       	movw	r16, r28
    bb94:	05 5f       	subi	r16, 0xF5	; 245
    bb96:	1f 4f       	sbci	r17, 0xFF	; 255
    bb98:	c8 01       	movw	r24, r16
    bb9a:	b6 01       	movw	r22, r12
    bb9c:	50 e0       	ldi	r21, 0x00	; 0
    bb9e:	0e 94 0d 8e 	call	0x11c1a	; 0x11c1a <__eerd_block_m2560>
		
		break;
	case EE_Text:{
			char TempStr[LCDXSz+1];
			erbl(TempStr, Var, CurrFieldSize);
			Put_TextValAlignLeft(TempStr, &Param);
    bba2:	c8 01       	movw	r24, r16
    bba4:	d5 cf       	rjmp	.-86     	; 0xbb50 <Field2Buf+0x466>
			if( (prd(&Field->Min) == DIGIT) && (prd(&Field->Max) == DIGIT) )
				MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[0]);
    bba6:	83 ea       	ldi	r24, 0xA3	; 163
    bba8:	96 e0       	ldi	r25, 0x06	; 6
    bbaa:	60 91 c3 05 	lds	r22, 0x05C3
    bbae:	0e 94 42 4b 	call	0x9684	; 0x9684 <GetMultiSymbol>
    bbb2:	80 93 f4 04 	sts	0x04F4, r24
    bbb6:	66 ce       	rjmp	.-820    	; 0xb884 <Field2Buf+0x19a>
    bbb8:	8e 01       	movw	r16, r28
    bbba:	0b 5f       	subi	r16, 0xFB	; 251
    bbbc:	1f 4f       	sbci	r17, 0xFF	; 255
    bbbe:	7e 01       	movw	r14, r28
    bbc0:	08 94       	sec
    bbc2:	e1 1c       	adc	r14, r1
    bbc4:	f1 1c       	adc	r15, r1
    bbc6:	1f ce       	rjmp	.-962    	; 0xb806 <Field2Buf+0x11c>

0000bbc8 <MenuEscLeft>:
}

// ~~~~~~~~~~~~~~
void
MenuEscLeft(void)
{
    bbc8:	0f 93       	push	r16
    bbca:	1f 93       	push	r17
    bbcc:	cf 93       	push	r28
    bbce:	df 93       	push	r29
//	1) Hide current Message
	if(HideMsg()||KeyFunc(&CurrPage->Esc))
    bbd0:	0e 94 24 46 	call	0x8c48	; 0x8c48 <HideMsg>
    bbd4:	88 23       	and	r24, r24
    bbd6:	29 f0       	breq	.+10     	; 0xbbe2 <MenuEscLeft+0x1a>
		else
			CurrPage=prp(&CurrPage->OutPage);
		CurrLine=CurrLCD=GetFix();
	}
	EventFunc(&CurrPage->Load);
}
    bbd8:	df 91       	pop	r29
    bbda:	cf 91       	pop	r28
    bbdc:	1f 91       	pop	r17
    bbde:	0f 91       	pop	r16
    bbe0:	08 95       	ret
// ~~~~~~~~~~~~~~
void
MenuEscLeft(void)
{
//	1) Hide current Message
	if(HideMsg()||KeyFunc(&CurrPage->Esc))
    bbe2:	80 91 d4 02 	lds	r24, 0x02D4
    bbe6:	90 91 d5 02 	lds	r25, 0x02D5
    bbea:	0e 96       	adiw	r24, 0x0e	; 14
    bbec:	0e 94 ca 45 	call	0x8b94	; 0x8b94 <KeyFunc>
    bbf0:	88 23       	and	r24, r24
    bbf2:	91 f7       	brne	.-28     	; 0xbbd8 <MenuEscLeft+0x10>
		return;

// 2) Variable
	if(CurrField!=NullPos) {
    bbf4:	30 91 d6 02 	lds	r19, 0x02D6
    bbf8:	3f 3f       	cpi	r19, 0xFF	; 255
    bbfa:	09 f4       	brne	.+2      	; 0xbbfe <MenuEscLeft+0x36>
    bbfc:	c8 c0       	rjmp	.+400    	; 0xbd8e <MenuEscLeft+0x1c6>
		if(CurrPos!=NullPos) {
    bbfe:	40 91 d7 02 	lds	r20, 0x02D7
    bc02:	4f 3f       	cpi	r20, 0xFF	; 255
    bc04:	09 f4       	brne	.+2      	; 0xbc08 <MenuEscLeft+0x40>
    bc06:	5a c0       	rjmp	.+180    	; 0xbcbc <MenuEscLeft+0xf4>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    bc08:	80 91 d4 02 	lds	r24, 0x02D4
    bc0c:	90 91 d5 02 	lds	r25, 0x02D5
    bc10:	fc 01       	movw	r30, r24
    bc12:	65 91       	lpm	r22, Z+
    bc14:	74 91       	lpm	r23, Z+
			OutField *Field=GetField;
    bc16:	80 91 ca 07 	lds	r24, 0x07CA
    bc1a:	2b e1       	ldi	r18, 0x1B	; 27
    bc1c:	82 9f       	mul	r24, r18
    bc1e:	c0 01       	movw	r24, r0
    bc20:	11 24       	eor	r1, r1
    bc22:	68 0f       	add	r22, r24
    bc24:	79 1f       	adc	r23, r25
    bc26:	69 5e       	subi	r22, 0xE9	; 233
    bc28:	7f 4f       	sbci	r23, 0xFF	; 255
    bc2a:	fb 01       	movw	r30, r22
    bc2c:	c5 91       	lpm	r28, Z+
    bc2e:	d4 91       	lpm	r29, Z+
    bc30:	83 2f       	mov	r24, r19
    bc32:	90 e0       	ldi	r25, 0x00	; 0
    bc34:	82 95       	swap	r24
    bc36:	92 95       	swap	r25
    bc38:	90 7f       	andi	r25, 0xF0	; 240
    bc3a:	98 27       	eor	r25, r24
    bc3c:	80 7f       	andi	r24, 0xF0	; 240
    bc3e:	98 27       	eor	r25, r24
    bc40:	c8 0f       	add	r28, r24
    bc42:	d9 1f       	adc	r29, r25

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    bc44:	fe 01       	movw	r30, r28
    bc46:	14 91       	lpm	r17, Z+
			uint8_t Type=prb(&Field->Type);
			uint8_t Pos;

			if( (Type == Text) || (Type == EE_Text) ||
    bc48:	01 2f       	mov	r16, r17
    bc4a:	01 52       	subi	r16, 0x21	; 33
    bc4c:	02 30       	cpi	r16, 0x02	; 2
    bc4e:	00 f1       	brcs	.+64     	; 0xbc90 <MenuEscLeft+0xc8>
    bc50:	10 31       	cpi	r17, 0x10	; 16
    bc52:	f1 f0       	breq	.+60     	; 0xbc90 <MenuEscLeft+0xc8>
    bc54:	11 31       	cpi	r17, 0x11	; 17
    bc56:	e1 f0       	breq	.+56     	; 0xbc90 <MenuEscLeft+0xc8>
    bc58:	12 31       	cpi	r17, 0x12	; 18
    bc5a:	d1 f0       	breq	.+52     	; 0xbc90 <MenuEscLeft+0xc8>
    bc5c:	13 31       	cpi	r17, 0x13	; 19
    bc5e:	c1 f0       	breq	.+48     	; 0xbc90 <MenuEscLeft+0xc8>
    bc60:	14 31       	cpi	r17, 0x14	; 20
    bc62:	b1 f0       	breq	.+44     	; 0xbc90 <MenuEscLeft+0xc8>
    bc64:	15 31       	cpi	r17, 0x15	; 21
    bc66:	a1 f0       	breq	.+40     	; 0xbc90 <MenuEscLeft+0xc8>
    bc68:	19 31       	cpi	r17, 0x19	; 25
    bc6a:	91 f0       	breq	.+36     	; 0xbc90 <MenuEscLeft+0xc8>
    bc6c:	1a 31       	cpi	r17, 0x1A	; 26
    bc6e:	81 f0       	breq	.+32     	; 0xbc90 <MenuEscLeft+0xc8>
    bc70:	1b 31       	cpi	r17, 0x1B	; 27
    bc72:	71 f0       	breq	.+28     	; 0xbc90 <MenuEscLeft+0xc8>
    bc74:	1c 31       	cpi	r17, 0x1C	; 28
    bc76:	61 f0       	breq	.+24     	; 0xbc90 <MenuEscLeft+0xc8>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    bc78:	fe 01       	movw	r30, r28
    bc7a:	37 96       	adiw	r30, 0x07	; 7
    bc7c:	65 91       	lpm	r22, Z+
    bc7e:	75 91       	lpm	r23, Z+
    bc80:	85 91       	lpm	r24, Z+
    bc82:	94 91       	lpm	r25, Z+
			 (Type == Longint) || (Type == EE_Longint)|| (Type == s_Longint) || (Type == s_EE_Longint) || (Type == z_Longint) || (Type == z_EE_Longint) ||
			 (Type == FFloat) || (Type == EE_FFloat) || (Type == GFloat) || (Type == EE_GFloat) ) 
			 	Pos = CurrFieldSize-1;
			else Pos=Log10(prd(&Field->Max));
    bc84:	0e 94 48 2a 	call	0x5490	; 0x5490 <Log10>
    bc88:	98 2f       	mov	r25, r24
    bc8a:	40 91 d7 02 	lds	r20, 0x02D7
    bc8e:	03 c0       	rjmp	.+6      	; 0xbc96 <MenuEscLeft+0xce>
			uint8_t Pos;

			if( (Type == Text) || (Type == EE_Text) ||
			 (Type == Longint) || (Type == EE_Longint)|| (Type == s_Longint) || (Type == s_EE_Longint) || (Type == z_Longint) || (Type == z_EE_Longint) ||
			 (Type == FFloat) || (Type == EE_FFloat) || (Type == GFloat) || (Type == EE_GFloat) ) 
			 	Pos = CurrFieldSize-1;
    bc90:	90 91 c0 07 	lds	r25, 0x07C0
    bc94:	91 50       	subi	r25, 0x01	; 1
			else Pos=Log10(prd(&Field->Max));

			if(Type==s_Byte || Type==s_EE_Byte || Type==s_Word || Type==s_EE_Word)
    bc96:	81 2f       	mov	r24, r17
    bc98:	82 50       	subi	r24, 0x02	; 2
    bc9a:	82 30       	cpi	r24, 0x02	; 2
    bc9c:	b0 f1       	brcs	.+108    	; 0xbd0a <MenuEscLeft+0x142>
    bc9e:	19 30       	cpi	r17, 0x09	; 9
    bca0:	a1 f1       	breq	.+104    	; 0xbd0a <MenuEscLeft+0x142>
    bca2:	1a 30       	cpi	r17, 0x0A	; 10
    bca4:	91 f1       	breq	.+100    	; 0xbd0a <MenuEscLeft+0x142>
				Pos++;
			if(++CurrPos>Pos)
    bca6:	24 2f       	mov	r18, r20
    bca8:	2f 5f       	subi	r18, 0xFF	; 255
    bcaa:	20 93 d7 02 	sts	0x02D7, r18
    bcae:	92 17       	cp	r25, r18
    bcb0:	70 f5       	brcc	.+92     	; 0xbd0e <MenuEscLeft+0x146>
				CurrPos = NullPos;
    bcb2:	8f ef       	ldi	r24, 0xFF	; 255
    bcb4:	80 93 d7 02 	sts	0x02D7, r24
    bcb8:	30 91 d6 02 	lds	r19, 0x02D6
				}
				return;
			}
		}
		//     
		if(--CurrField!=NullPos)
    bcbc:	31 50       	subi	r19, 0x01	; 1
    bcbe:	30 93 d6 02 	sts	0x02D6, r19
    bcc2:	3f 3f       	cpi	r19, 0xFF	; 255
    bcc4:	09 f4       	brne	.+2      	; 0xbcc8 <MenuEscLeft+0x100>
    bcc6:	88 cf       	rjmp	.-240    	; 0xbbd8 <MenuEscLeft+0x10>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    bcc8:	80 91 d4 02 	lds	r24, 0x02D4
    bccc:	90 91 d5 02 	lds	r25, 0x02D5
    bcd0:	fc 01       	movw	r30, r24
    bcd2:	45 91       	lpm	r20, Z+
    bcd4:	54 91       	lpm	r21, Z+
			Field2Buf(GetField);
    bcd6:	80 91 ca 07 	lds	r24, 0x07CA
    bcda:	2b e1       	ldi	r18, 0x1B	; 27
    bcdc:	82 9f       	mul	r24, r18
    bcde:	c0 01       	movw	r24, r0
    bce0:	11 24       	eor	r1, r1
    bce2:	48 0f       	add	r20, r24
    bce4:	59 1f       	adc	r21, r25
    bce6:	49 5e       	subi	r20, 0xE9	; 233
    bce8:	5f 4f       	sbci	r21, 0xFF	; 255
    bcea:	fa 01       	movw	r30, r20
    bcec:	85 91       	lpm	r24, Z+
    bcee:	94 91       	lpm	r25, Z+
    bcf0:	23 2f       	mov	r18, r19
    bcf2:	30 e0       	ldi	r19, 0x00	; 0
    bcf4:	22 95       	swap	r18
    bcf6:	32 95       	swap	r19
    bcf8:	30 7f       	andi	r19, 0xF0	; 240
    bcfa:	32 27       	eor	r19, r18
    bcfc:	20 7f       	andi	r18, 0xF0	; 240
    bcfe:	32 27       	eor	r19, r18
    bd00:	82 0f       	add	r24, r18
    bd02:	93 1f       	adc	r25, r19
    bd04:	0e 94 75 5b 	call	0xb6ea	; 0xb6ea <Field2Buf>
    bd08:	67 cf       	rjmp	.-306    	; 0xbbd8 <MenuEscLeft+0x10>
			 (Type == FFloat) || (Type == EE_FFloat) || (Type == GFloat) || (Type == EE_GFloat) ) 
			 	Pos = CurrFieldSize-1;
			else Pos=Log10(prd(&Field->Max));

			if(Type==s_Byte || Type==s_EE_Byte || Type==s_Word || Type==s_EE_Word)
				Pos++;
    bd0a:	9f 5f       	subi	r25, 0xFF	; 255
    bd0c:	cc cf       	rjmp	.-104    	; 0xbca6 <MenuEscLeft+0xde>
			if(++CurrPos>Pos)
				CurrPos = NullPos;
			else{
				switch(Type){
    bd0e:	1d 31       	cpi	r17, 0x1D	; 29
    bd10:	40 f1       	brcs	.+80     	; 0xbd62 <MenuEscLeft+0x19a>
    bd12:	02 30       	cpi	r16, 0x02	; 2
    bd14:	08 f0       	brcs	.+2      	; 0xbd18 <MenuEscLeft+0x150>
    bd16:	60 cf       	rjmp	.-320    	; 0xbbd8 <MenuEscLeft+0x10>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    bd18:	fe 01       	movw	r30, r28
    bd1a:	33 96       	adiw	r30, 0x03	; 3
    bd1c:	85 91       	lpm	r24, Z+
    bd1e:	95 91       	lpm	r25, Z+
    bd20:	a5 91       	lpm	r26, Z+
    bd22:	b4 91       	lpm	r27, Z+
				case Text: case EE_Text:
					if( (prd(&Field->Min) == DIGIT) && (prd(&Field->Max) == DIGIT) )
    bd24:	00 97       	sbiw	r24, 0x00	; 0
    bd26:	a1 05       	cpc	r26, r1
    bd28:	b1 05       	cpc	r27, r1
    bd2a:	59 f4       	brne	.+22     	; 0xbd42 <MenuEscLeft+0x17a>
    bd2c:	fe 01       	movw	r30, r28
    bd2e:	37 96       	adiw	r30, 0x07	; 7
    bd30:	85 91       	lpm	r24, Z+
    bd32:	95 91       	lpm	r25, Z+
    bd34:	a5 91       	lpm	r26, Z+
    bd36:	b4 91       	lpm	r27, Z+
    bd38:	00 97       	sbiw	r24, 0x00	; 0
    bd3a:	a1 05       	cpc	r26, r1
    bd3c:	b1 05       	cpc	r27, r1
    bd3e:	09 f4       	brne	.+2      	; 0xbd42 <MenuEscLeft+0x17a>
    bd40:	6f c0       	rjmp	.+222    	; 0xbe20 <MenuEscLeft+0x258>
						MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[CurrFieldSize - 1 - CurrPos]);
					else MultiSymbol = GetMultiSymbol(Symbols_P, BufStr[CurrFieldSize - 1 - CurrPos]);
    bd42:	e0 91 c0 07 	lds	r30, 0x07C0
    bd46:	f0 e0       	ldi	r31, 0x00	; 0
    bd48:	31 97       	sbiw	r30, 0x01	; 1
    bd4a:	e2 1b       	sub	r30, r18
    bd4c:	f1 09       	sbc	r31, r1
    bd4e:	ed 53       	subi	r30, 0x3D	; 61
    bd50:	fa 4f       	sbci	r31, 0xFA	; 250
    bd52:	85 e0       	ldi	r24, 0x05	; 5
    bd54:	96 e0       	ldi	r25, 0x06	; 6
    bd56:	60 81       	ld	r22, Z
    bd58:	0e 94 42 4b 	call	0x9684	; 0x9684 <GetMultiSymbol>
    bd5c:	80 93 f4 04 	sts	0x04F4, r24
    bd60:	3b cf       	rjmp	.-394    	; 0xbbd8 <MenuEscLeft+0x10>
			if(Type==s_Byte || Type==s_EE_Byte || Type==s_Word || Type==s_EE_Word)
				Pos++;
			if(++CurrPos>Pos)
				CurrPos = NullPos;
			else{
				switch(Type){
    bd62:	19 31       	cpi	r17, 0x19	; 25
    bd64:	20 f4       	brcc	.+8      	; 0xbd6e <MenuEscLeft+0x1a6>
    bd66:	10 51       	subi	r17, 0x10	; 16
    bd68:	16 30       	cpi	r17, 0x06	; 6
    bd6a:	08 f0       	brcs	.+2      	; 0xbd6e <MenuEscLeft+0x1a6>
    bd6c:	35 cf       	rjmp	.-406    	; 0xbbd8 <MenuEscLeft+0x10>
						MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[CurrFieldSize - 1 - CurrPos]);
					else MultiSymbol = GetMultiSymbol(Symbols_P, BufStr[CurrFieldSize - 1 - CurrPos]);
					break;
				case Longint: case z_Longint: case EE_Longint: case z_EE_Longint: case s_Longint: case s_EE_Longint:
				case FFloat: case EE_FFloat: case GFloat: case EE_GFloat:
					MultiSymbol = GetMultiSymbol(Digits_P, BufStr[CurrFieldSize - 1 - CurrPos]);
    bd6e:	e0 91 c0 07 	lds	r30, 0x07C0
    bd72:	f0 e0       	ldi	r31, 0x00	; 0
    bd74:	31 97       	sbiw	r30, 0x01	; 1
    bd76:	e2 1b       	sub	r30, r18
    bd78:	f1 09       	sbc	r31, r1
    bd7a:	ed 53       	subi	r30, 0x3D	; 61
    bd7c:	fa 4f       	sbci	r31, 0xFA	; 250
    bd7e:	8e ea       	ldi	r24, 0xAE	; 174
    bd80:	96 e0       	ldi	r25, 0x06	; 6
    bd82:	60 81       	ld	r22, Z
    bd84:	0e 94 42 4b 	call	0x9684	; 0x9684 <GetMultiSymbol>
    bd88:	80 93 f4 04 	sts	0x04F4, r24
    bd8c:	25 cf       	rjmp	.-438    	; 0xbbd8 <MenuEscLeft+0x10>
			Field2Buf(GetField);
		return;
	}

// 3) Go to menu
	EventFunc(&CurrPage->Exit);
    bd8e:	80 91 d4 02 	lds	r24, 0x02D4
    bd92:	90 91 d5 02 	lds	r25, 0x02D5
    bd96:	0a 96       	adiw	r24, 0x0a	; 10
    bd98:	0e 94 c2 45 	call	0x8b84	; 0x8b84 <EventFunc>
	if(MenuDepth) {
    bd9c:	e0 91 ba 07 	lds	r30, 0x07BA
    bda0:	ee 23       	and	r30, r30
    bda2:	21 f1       	breq	.+72     	; 0xbdec <MenuEscLeft+0x224>
		CurrPage=MenuStack[--MenuDepth].Page;
    bda4:	e1 50       	subi	r30, 0x01	; 1
    bda6:	e0 93 ba 07 	sts	0x07BA, r30
    bdaa:	f0 e0       	ldi	r31, 0x00	; 0
    bdac:	ee 0f       	add	r30, r30
    bdae:	ff 1f       	adc	r31, r31
    bdb0:	ee 0f       	add	r30, r30
    bdb2:	ff 1f       	adc	r31, r31
    bdb4:	df 01       	movw	r26, r30
    bdb6:	a7 51       	subi	r26, 0x17	; 23
    bdb8:	b7 4f       	sbci	r27, 0xF7	; 247
    bdba:	9c 91       	ld	r25, X
    bdbc:	11 96       	adiw	r26, 0x01	; 1
    bdbe:	2c 91       	ld	r18, X
    bdc0:	11 97       	sbiw	r26, 0x01	; 1
    bdc2:	90 93 d4 02 	sts	0x02D4, r25
    bdc6:	20 93 d5 02 	sts	0x02D5, r18
		CurrLine=MenuStack[MenuDepth].Line;
    bdca:	13 96       	adiw	r26, 0x03	; 3
    bdcc:	8c 91       	ld	r24, X
    bdce:	80 93 ca 07 	sts	0x07CA, r24
		CurrLCD=MenuStack[MenuDepth].LCD;
    bdd2:	e5 51       	subi	r30, 0x15	; 21
    bdd4:	f7 4f       	sbci	r31, 0xF7	; 247
    bdd6:	80 81       	ld	r24, Z
    bdd8:	80 93 e8 08 	sts	0x08E8, r24
    bddc:	e9 2f       	mov	r30, r25
    bdde:	f2 2f       	mov	r31, r18
    bde0:	9f 01       	movw	r18, r30
		}
		else
			CurrPage=prp(&CurrPage->OutPage);
		CurrLine=CurrLCD=GetFix();
	}
	EventFunc(&CurrPage->Load);
    bde2:	c9 01       	movw	r24, r18
    bde4:	06 96       	adiw	r24, 0x06	; 6
    bde6:	0e 94 c2 45 	call	0x8b84	; 0x8b84 <EventFunc>
    bdea:	f6 ce       	rjmp	.-532    	; 0xbbd8 <MenuEscLeft+0x10>
		CurrPage=MenuStack[--MenuDepth].Page;
		CurrLine=MenuStack[MenuDepth].Line;
		CurrLCD=MenuStack[MenuDepth].LCD;
	}
	else {
		if(NextPage) {
    bdec:	e0 91 d9 05 	lds	r30, 0x05D9
    bdf0:	f0 91 da 05 	lds	r31, 0x05DA
    bdf4:	30 97       	sbiw	r30, 0x00	; 0
    bdf6:	21 f1       	breq	.+72     	; 0xbe40 <MenuEscLeft+0x278>
			CurrPage=NextPage;
    bdf8:	f0 93 d5 02 	sts	0x02D5, r31
    bdfc:	e0 93 d4 02 	sts	0x02D4, r30
			NextPage=NULL;
    be00:	10 92 da 05 	sts	0x05DA, r1
    be04:	10 92 d9 05 	sts	0x05D9, r1
    be08:	9f 01       	movw	r18, r30

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    be0a:	2d 5f       	subi	r18, 0xFD	; 253
    be0c:	3f 4f       	sbci	r19, 0xFF	; 255
    be0e:	f9 01       	movw	r30, r18
    be10:	84 91       	lpm	r24, Z+
    be12:	23 50       	subi	r18, 0x03	; 3
    be14:	30 40       	sbci	r19, 0x00	; 0
		}
		else
			CurrPage=prp(&CurrPage->OutPage);
		CurrLine=CurrLCD=GetFix();
    be16:	80 93 e8 08 	sts	0x08E8, r24
    be1a:	80 93 ca 07 	sts	0x07CA, r24
    be1e:	e1 cf       	rjmp	.-62     	; 0xbde2 <MenuEscLeft+0x21a>
				CurrPos = NullPos;
			else{
				switch(Type){
				case Text: case EE_Text:
					if( (prd(&Field->Min) == DIGIT) && (prd(&Field->Max) == DIGIT) )
						MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[CurrFieldSize - 1 - CurrPos]);
    be20:	e0 91 c0 07 	lds	r30, 0x07C0
    be24:	f0 e0       	ldi	r31, 0x00	; 0
    be26:	31 97       	sbiw	r30, 0x01	; 1
    be28:	e2 1b       	sub	r30, r18
    be2a:	f1 09       	sbc	r31, r1
    be2c:	ed 53       	subi	r30, 0x3D	; 61
    be2e:	fa 4f       	sbci	r31, 0xFA	; 250
    be30:	83 ea       	ldi	r24, 0xA3	; 163
    be32:	96 e0       	ldi	r25, 0x06	; 6
    be34:	60 81       	ld	r22, Z
    be36:	0e 94 42 4b 	call	0x9684	; 0x9684 <GetMultiSymbol>
    be3a:	80 93 f4 04 	sts	0x04F4, r24
    be3e:	cc ce       	rjmp	.-616    	; 0xbbd8 <MenuEscLeft+0x10>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    be40:	80 91 d4 02 	lds	r24, 0x02D4
    be44:	90 91 d5 02 	lds	r25, 0x02D5
    be48:	04 96       	adiw	r24, 0x04	; 4
		if(NextPage) {
			CurrPage=NextPage;
			NextPage=NULL;
		}
		else
			CurrPage=prp(&CurrPage->OutPage);
    be4a:	fc 01       	movw	r30, r24
    be4c:	25 91       	lpm	r18, Z+
    be4e:	34 91       	lpm	r19, Z+
    be50:	30 93 d5 02 	sts	0x02D5, r19
    be54:	20 93 d4 02 	sts	0x02D4, r18
    be58:	d8 cf       	rjmp	.-80     	; 0xbe0a <MenuEscLeft+0x242>

0000be5a <Buf2Field>:
// ~~~~~~~~~~~~~~~~~~~~~~~
//       
//     -
static void
Buf2Field(OutField *Field)
{
    be5a:	3f 92       	push	r3
    be5c:	4f 92       	push	r4
    be5e:	5f 92       	push	r5
    be60:	6f 92       	push	r6
    be62:	7f 92       	push	r7
    be64:	8f 92       	push	r8
    be66:	9f 92       	push	r9
    be68:	af 92       	push	r10
    be6a:	bf 92       	push	r11
    be6c:	cf 92       	push	r12
    be6e:	df 92       	push	r13
    be70:	ef 92       	push	r14
    be72:	ff 92       	push	r15
    be74:	0f 93       	push	r16
    be76:	1f 93       	push	r17
    be78:	df 93       	push	r29
    be7a:	cf 93       	push	r28
    be7c:	cd b7       	in	r28, 0x3d	; 61
    be7e:	de b7       	in	r29, 0x3e	; 62
    be80:	6d 97       	sbiw	r28, 0x1d	; 29
    be82:	0f b6       	in	r0, 0x3f	; 63
    be84:	f8 94       	cli
    be86:	de bf       	out	0x3e, r29	; 62
    be88:	0f be       	out	0x3f, r0	; 63
    be8a:	cd bf       	out	0x3d, r28	; 61
    be8c:	6c 01       	movw	r12, r24
    be8e:	fc 01       	movw	r30, r24
    be90:	31 96       	adiw	r30, 0x01	; 1
    be92:	45 90       	lpm	r4, Z+
    be94:	54 90       	lpm	r5, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    be96:	2f e0       	ldi	r18, 0x0F	; 15
    be98:	30 e0       	ldi	r19, 0x00	; 0
    be9a:	c2 0e       	add	r12, r18
    be9c:	d3 1e       	adc	r13, r19
    be9e:	f6 01       	movw	r30, r12
    bea0:	24 91       	lpm	r18, Z+
    bea2:	81 ef       	ldi	r24, 0xF1	; 241
    bea4:	9f ef       	ldi	r25, 0xFF	; 255
    bea6:	c8 0e       	add	r12, r24
    bea8:	d9 1e       	adc	r13, r25
	void *Var = prp(&Field->Var);
	uint8_t BitN=prb(&Field->Prec), Mask=1<<BitN%8, *BitVar=(uint8_t*)Var+BitN/8;
    beaa:	32 2f       	mov	r19, r18
    beac:	37 70       	andi	r19, 0x07	; 7
    beae:	81 e0       	ldi	r24, 0x01	; 1
    beb0:	90 e0       	ldi	r25, 0x00	; 0
    beb2:	38 2e       	mov	r3, r24
    beb4:	01 c0       	rjmp	.+2      	; 0xbeb8 <Buf2Field+0x5e>
    beb6:	33 0c       	add	r3, r3
    beb8:	3a 95       	dec	r19
    beba:	ea f7       	brpl	.-6      	; 0xbeb6 <Buf2Field+0x5c>
    bebc:	26 95       	lsr	r18
    bebe:	26 95       	lsr	r18
    bec0:	26 95       	lsr	r18
    bec2:	32 01       	movw	r6, r4
    bec4:	62 0e       	add	r6, r18
    bec6:	71 1c       	adc	r7, r1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    bec8:	f6 01       	movw	r30, r12
    beca:	33 96       	adiw	r30, 0x03	; 3
    becc:	85 90       	lpm	r8, Z+
    bece:	95 90       	lpm	r9, Z+
    bed0:	a5 90       	lpm	r10, Z+
    bed2:	b4 90       	lpm	r11, Z+
	uint8_t EE_BitVar;
	uint32_t Min=prd(&Field->Min), Max=prd(&Field->Max);

	uint32_t Temp=0;
    bed4:	f6 01       	movw	r30, r12
    bed6:	37 96       	adiw	r30, 0x07	; 7
    bed8:	e5 90       	lpm	r14, Z+
    beda:	f5 90       	lpm	r15, Z+
    bedc:	05 91       	lpm	r16, Z+
    bede:	14 91       	lpm	r17, Z+
    bee0:	19 82       	std	Y+1, r1	; 0x01
    bee2:	1a 82       	std	Y+2, r1	; 0x02
    bee4:	1b 82       	std	Y+3, r1	; 0x03
    bee6:	1c 82       	std	Y+4, r1	; 0x04
	float fTemp=0;
    bee8:	80 e0       	ldi	r24, 0x00	; 0
    beea:	90 e0       	ldi	r25, 0x00	; 0
    beec:	a0 e0       	ldi	r26, 0x00	; 0
    beee:	b0 e0       	ldi	r27, 0x00	; 0
    bef0:	8d 83       	std	Y+5, r24	; 0x05
    bef2:	9e 83       	std	Y+6, r25	; 0x06
    bef4:	af 83       	std	Y+7, r26	; 0x07
    bef6:	b8 87       	std	Y+8, r27	; 0x08

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    bef8:	f6 01       	movw	r30, r12
    befa:	84 91       	lpm	r24, Z+

	switch(prb(&Field->Type)) {
    befc:	e8 2f       	mov	r30, r24
    befe:	f0 e0       	ldi	r31, 0x00	; 0
    bf00:	e3 32       	cpi	r30, 0x23	; 35
    bf02:	f1 05       	cpc	r31, r1
    bf04:	08 f0       	brcs	.+2      	; 0xbf08 <Buf2Field+0xae>
    bf06:	3f c0       	rjmp	.+126    	; 0xbf86 <Buf2Field+0x12c>
    bf08:	ed 56       	subi	r30, 0x6D	; 109
    bf0a:	ff 4f       	sbci	r31, 0xFF	; 255
    bf0c:	ee 0f       	add	r30, r30
    bf0e:	ff 1f       	adc	r31, r31
    bf10:	05 90       	lpm	r0, Z+
    bf12:	f4 91       	lpm	r31, Z+
    bf14:	e0 2d       	mov	r30, r0
    bf16:	19 94       	eijmp
		PresicionHanler(Field);
		sscanf(BufStr,"%lud", (uint32_t*)&Temp);
		SetField32(Temp, uint32_t);
		break;
	case EE_Longint: case z_EE_Longint:
		PresicionHanler(Field);
    bf18:	c6 01       	movw	r24, r12
    bf1a:	0e 94 08 4b 	call	0x9610	; 0x9610 <PresicionHanler>
		if(sscanf(BufStr,"%lud", (uint32_t*)&Temp) == 1){
    bf1e:	00 d0       	rcall	.+0      	; 0xbf20 <Buf2Field+0xc6>
    bf20:	00 d0       	rcall	.+0      	; 0xbf22 <Buf2Field+0xc8>
    bf22:	ed b7       	in	r30, 0x3d	; 61
    bf24:	fe b7       	in	r31, 0x3e	; 62
    bf26:	31 96       	adiw	r30, 0x01	; 1
    bf28:	83 ec       	ldi	r24, 0xC3	; 195
    bf2a:	95 e0       	ldi	r25, 0x05	; 5
    bf2c:	ad b7       	in	r26, 0x3d	; 61
    bf2e:	be b7       	in	r27, 0x3e	; 62
    bf30:	12 96       	adiw	r26, 0x02	; 2
    bf32:	9c 93       	st	X, r25
    bf34:	8e 93       	st	-X, r24
    bf36:	11 97       	sbiw	r26, 0x01	; 1
    bf38:	8f e9       	ldi	r24, 0x9F	; 159
    bf3a:	92 e0       	ldi	r25, 0x02	; 2
    bf3c:	93 83       	std	Z+3, r25	; 0x03
    bf3e:	82 83       	std	Z+2, r24	; 0x02
    bf40:	ce 01       	movw	r24, r28
    bf42:	01 96       	adiw	r24, 0x01	; 1
    bf44:	95 83       	std	Z+5, r25	; 0x05
    bf46:	84 83       	std	Z+4, r24	; 0x04
    bf48:	0e 94 51 8c 	call	0x118a2	; 0x118a2 <sscanf>
    bf4c:	ed b7       	in	r30, 0x3d	; 61
    bf4e:	fe b7       	in	r31, 0x3e	; 62
    bf50:	36 96       	adiw	r30, 0x06	; 6
    bf52:	0f b6       	in	r0, 0x3f	; 63
    bf54:	f8 94       	cli
    bf56:	fe bf       	out	0x3e, r31	; 62
    bf58:	0f be       	out	0x3f, r0	; 63
    bf5a:	ed bf       	out	0x3d, r30	; 61
    bf5c:	01 97       	sbiw	r24, 0x01	; 1
    bf5e:	99 f4       	brne	.+38     	; 0xbf86 <Buf2Field+0x12c>
			SetEEField32(Temp, uint32_t, uint32_t, d);
    bf60:	49 81       	ldd	r20, Y+1	; 0x01
    bf62:	5a 81       	ldd	r21, Y+2	; 0x02
    bf64:	6b 81       	ldd	r22, Y+3	; 0x03
    bf66:	7c 81       	ldd	r23, Y+4	; 0x04
    bf68:	e4 16       	cp	r14, r20
    bf6a:	f5 06       	cpc	r15, r21
    bf6c:	06 07       	cpc	r16, r22
    bf6e:	17 07       	cpc	r17, r23
    bf70:	08 f4       	brcc	.+2      	; 0xbf74 <Buf2Field+0x11a>
    bf72:	cc c2       	rjmp	.+1432   	; 0xc50c <Buf2Field+0x6b2>
    bf74:	48 15       	cp	r20, r8
    bf76:	59 05       	cpc	r21, r9
    bf78:	6a 05       	cpc	r22, r10
    bf7a:	7b 05       	cpc	r23, r11
    bf7c:	08 f4       	brcc	.+2      	; 0xbf80 <Buf2Field+0x126>
    bf7e:	f8 c1       	rjmp	.+1008   	; 0xc370 <Buf2Field+0x516>
		SetField32(Temp, int32_t);
		break;
	case s_EE_Longint:
		PresicionHanler(Field);
		if(sscanf(BufStr,"%ld", (int32_t*)&Temp) == 1){
			SetEEField32(Temp, int32_t, uint32_t, d);
    bf80:	c2 01       	movw	r24, r4
    bf82:	0e 94 0e 58 	call	0xb01c	; 0xb01c <ewd>
			ewbl(TempStr, Var, Width);
		}
		break;

	}
	EventFunc(&Field->Act);
    bf86:	c6 01       	movw	r24, r12
    bf88:	0b 96       	adiw	r24, 0x0b	; 11
    bf8a:	0e 94 c2 45 	call	0x8b84	; 0x8b84 <EventFunc>
}
    bf8e:	6d 96       	adiw	r28, 0x1d	; 29
    bf90:	0f b6       	in	r0, 0x3f	; 63
    bf92:	f8 94       	cli
    bf94:	de bf       	out	0x3e, r29	; 62
    bf96:	0f be       	out	0x3f, r0	; 63
    bf98:	cd bf       	out	0x3d, r28	; 61
    bf9a:	cf 91       	pop	r28
    bf9c:	df 91       	pop	r29
    bf9e:	1f 91       	pop	r17
    bfa0:	0f 91       	pop	r16
    bfa2:	ff 90       	pop	r15
    bfa4:	ef 90       	pop	r14
    bfa6:	df 90       	pop	r13
    bfa8:	cf 90       	pop	r12
    bfaa:	bf 90       	pop	r11
    bfac:	af 90       	pop	r10
    bfae:	9f 90       	pop	r9
    bfb0:	8f 90       	pop	r8
    bfb2:	7f 90       	pop	r7
    bfb4:	6f 90       	pop	r6
    bfb6:	5f 90       	pop	r5
    bfb8:	4f 90       	pop	r4
    bfba:	3f 90       	pop	r3
    bfbc:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    bfbe:	8e 01       	movw	r16, r28
    bfc0:	07 5f       	subi	r16, 0xF7	; 247
    bfc2:	1f 4f       	sbci	r17, 0xFF	; 255
    bfc4:	c8 01       	movw	r24, r16
    bfc6:	b2 01       	movw	r22, r4
    bfc8:	45 e1       	ldi	r20, 0x15	; 21
    bfca:	50 e0       	ldi	r21, 0x00	; 0
    bfcc:	0e 94 0d 8e 	call	0x11c1a	; 0x11c1a <__eerd_block_m2560>
		}
		break;
	case EE_Text:{
			char TempStr[LCDXSz+1];
			erbl(TempStr, Var, LCDXSz+1);
			uint8_t Width = strlen(TempStr);
    bfd0:	d8 01       	movw	r26, r16
    bfd2:	0d 90       	ld	r0, X+
    bfd4:	00 20       	and	r0, r0
    bfd6:	e9 f7       	brne	.-6      	; 0xbfd2 <Buf2Field+0x178>
    bfd8:	7d 01       	movw	r14, r26
    bfda:	08 94       	sec
    bfdc:	e1 08       	sbc	r14, r1
    bfde:	f1 08       	sbc	r15, r1
    bfe0:	e0 1a       	sub	r14, r16
    bfe2:	f1 0a       	sbc	r15, r17
			memcpy(TempStr, BufStr, Width);
    bfe4:	23 ec       	ldi	r18, 0xC3	; 195
    bfe6:	35 e0       	ldi	r19, 0x05	; 5
    bfe8:	c8 01       	movw	r24, r16
    bfea:	b9 01       	movw	r22, r18
    bfec:	4e 2d       	mov	r20, r14
    bfee:	50 e0       	ldi	r21, 0x00	; 0
    bff0:	0e 94 3f 8b 	call	0x1167e	; 0x1167e <memcpy>
			ewbl(TempStr, Var, Width);
    bff4:	c8 01       	movw	r24, r16
    bff6:	b2 01       	movw	r22, r4
    bff8:	4e 2d       	mov	r20, r14
    bffa:	50 e0       	ldi	r21, 0x00	; 0
    bffc:	0e 94 09 58 	call	0xb012	; 0xb012 <ewbl>
    c000:	c2 cf       	rjmp	.-124    	; 0xbf86 <Buf2Field+0x12c>
	uint32_t Temp=0;
	float fTemp=0;

	switch(prb(&Field->Type)) {
	case Byte: case z_Byte: case Enum:
		SetField(F_Buf, uint8_t);
    c002:	20 91 f7 04 	lds	r18, 0x04F7
    c006:	30 91 f8 04 	lds	r19, 0x04F8
    c00a:	40 91 f9 04 	lds	r20, 0x04F9
    c00e:	50 91 fa 04 	lds	r21, 0x04FA
    c012:	8e 2d       	mov	r24, r14
    c014:	90 e0       	ldi	r25, 0x00	; 0
    c016:	a0 e0       	ldi	r26, 0x00	; 0
    c018:	b0 e0       	ldi	r27, 0x00	; 0
    c01a:	82 17       	cp	r24, r18
    c01c:	93 07       	cpc	r25, r19
    c01e:	a4 07       	cpc	r26, r20
    c020:	b5 07       	cpc	r27, r21
    c022:	08 f4       	brcc	.+2      	; 0xc026 <Buf2Field+0x1cc>
    c024:	50 c2       	rjmp	.+1184   	; 0xc4c6 <Buf2Field+0x66c>
    c026:	88 2d       	mov	r24, r8
    c028:	90 e0       	ldi	r25, 0x00	; 0
    c02a:	a0 e0       	ldi	r26, 0x00	; 0
    c02c:	b0 e0       	ldi	r27, 0x00	; 0
    c02e:	28 17       	cp	r18, r24
    c030:	39 07       	cpc	r19, r25
    c032:	4a 07       	cpc	r20, r26
    c034:	5b 07       	cpc	r21, r27
    c036:	08 f0       	brcs	.+2      	; 0xc03a <Buf2Field+0x1e0>
    c038:	66 c2       	rjmp	.+1228   	; 0xc506 <Buf2Field+0x6ac>
    c03a:	f2 01       	movw	r30, r4
    c03c:	80 82       	st	Z, r8
    c03e:	a3 cf       	rjmp	.-186    	; 0xbf86 <Buf2Field+0x12c>
		break;
	case s_Byte:
		SetField(sF_Buf, int8_t);
		break;
	case EE_Byte: case z_EE_Byte: case EE_Enum:
		SetEEField(F_Buf, uint8_t, uint8_t, b);
    c040:	20 91 f7 04 	lds	r18, 0x04F7
    c044:	30 91 f8 04 	lds	r19, 0x04F8
    c048:	40 91 f9 04 	lds	r20, 0x04F9
    c04c:	50 91 fa 04 	lds	r21, 0x04FA
    c050:	8e 2d       	mov	r24, r14
    c052:	90 e0       	ldi	r25, 0x00	; 0
    c054:	a0 e0       	ldi	r26, 0x00	; 0
    c056:	b0 e0       	ldi	r27, 0x00	; 0
    c058:	82 17       	cp	r24, r18
    c05a:	93 07       	cpc	r25, r19
    c05c:	a4 07       	cpc	r26, r20
    c05e:	b5 07       	cpc	r27, r21
    c060:	08 f4       	brcc	.+2      	; 0xc064 <Buf2Field+0x20a>
    c062:	41 c2       	rjmp	.+1154   	; 0xc4e6 <Buf2Field+0x68c>
    c064:	88 2d       	mov	r24, r8
    c066:	90 e0       	ldi	r25, 0x00	; 0
    c068:	a0 e0       	ldi	r26, 0x00	; 0
    c06a:	b0 e0       	ldi	r27, 0x00	; 0
    c06c:	28 17       	cp	r18, r24
    c06e:	39 07       	cpc	r19, r25
    c070:	4a 07       	cpc	r20, r26
    c072:	5b 07       	cpc	r21, r27
    c074:	08 f4       	brcc	.+2      	; 0xc078 <Buf2Field+0x21e>
    c076:	48 c0       	rjmp	.+144    	; 0xc108 <Buf2Field+0x2ae>
		break;
	case s_EE_Byte:
		SetEEField(sF_Buf, int8_t, uint8_t, b);
    c078:	c2 01       	movw	r24, r4
    c07a:	62 2f       	mov	r22, r18
    c07c:	0e 94 94 56 	call	0xad28	; 0xad28 <ewb>
    c080:	82 cf       	rjmp	.-252    	; 0xbf86 <Buf2Field+0x12c>
	switch(prb(&Field->Type)) {
	case Byte: case z_Byte: case Enum:
		SetField(F_Buf, uint8_t);
		break;
	case s_Byte:
		SetField(sF_Buf, int8_t);
    c082:	20 91 fb 04 	lds	r18, 0x04FB
    c086:	30 91 fc 04 	lds	r19, 0x04FC
    c08a:	40 91 fd 04 	lds	r20, 0x04FD
    c08e:	50 91 fe 04 	lds	r21, 0x04FE
    c092:	8e 2d       	mov	r24, r14
    c094:	99 27       	eor	r25, r25
    c096:	87 fd       	sbrc	r24, 7
    c098:	90 95       	com	r25
    c09a:	a9 2f       	mov	r26, r25
    c09c:	b9 2f       	mov	r27, r25
    c09e:	82 17       	cp	r24, r18
    c0a0:	93 07       	cpc	r25, r19
    c0a2:	a4 07       	cpc	r26, r20
    c0a4:	b5 07       	cpc	r27, r21
    c0a6:	0c f4       	brge	.+2      	; 0xc0aa <Buf2Field+0x250>
    c0a8:	08 c2       	rjmp	.+1040   	; 0xc4ba <Buf2Field+0x660>
    c0aa:	88 2d       	mov	r24, r8
    c0ac:	99 27       	eor	r25, r25
    c0ae:	87 fd       	sbrc	r24, 7
    c0b0:	90 95       	com	r25
    c0b2:	a9 2f       	mov	r26, r25
    c0b4:	b9 2f       	mov	r27, r25
    c0b6:	28 17       	cp	r18, r24
    c0b8:	39 07       	cpc	r19, r25
    c0ba:	4a 07       	cpc	r20, r26
    c0bc:	5b 07       	cpc	r21, r27
    c0be:	0c f0       	brlt	.+2      	; 0xc0c2 <Buf2Field+0x268>
    c0c0:	17 c2       	rjmp	.+1070   	; 0xc4f0 <Buf2Field+0x696>
    c0c2:	d2 01       	movw	r26, r4
    c0c4:	8c 92       	st	X, r8
    c0c6:	5f cf       	rjmp	.-322    	; 0xbf86 <Buf2Field+0x12c>
		break;
	case EE_Byte: case z_EE_Byte: case EE_Enum:
		SetEEField(F_Buf, uint8_t, uint8_t, b);
		break;
	case s_EE_Byte:
		SetEEField(sF_Buf, int8_t, uint8_t, b);
    c0c8:	20 91 fb 04 	lds	r18, 0x04FB
    c0cc:	30 91 fc 04 	lds	r19, 0x04FC
    c0d0:	40 91 fd 04 	lds	r20, 0x04FD
    c0d4:	50 91 fe 04 	lds	r21, 0x04FE
    c0d8:	8e 2d       	mov	r24, r14
    c0da:	99 27       	eor	r25, r25
    c0dc:	87 fd       	sbrc	r24, 7
    c0de:	90 95       	com	r25
    c0e0:	a9 2f       	mov	r26, r25
    c0e2:	b9 2f       	mov	r27, r25
    c0e4:	82 17       	cp	r24, r18
    c0e6:	93 07       	cpc	r25, r19
    c0e8:	a4 07       	cpc	r26, r20
    c0ea:	b5 07       	cpc	r27, r21
    c0ec:	0c f4       	brge	.+2      	; 0xc0f0 <Buf2Field+0x296>
    c0ee:	fb c1       	rjmp	.+1014   	; 0xc4e6 <Buf2Field+0x68c>
    c0f0:	88 2d       	mov	r24, r8
    c0f2:	99 27       	eor	r25, r25
    c0f4:	87 fd       	sbrc	r24, 7
    c0f6:	90 95       	com	r25
    c0f8:	a9 2f       	mov	r26, r25
    c0fa:	b9 2f       	mov	r27, r25
    c0fc:	28 17       	cp	r18, r24
    c0fe:	39 07       	cpc	r19, r25
    c100:	4a 07       	cpc	r20, r26
    c102:	5b 07       	cpc	r21, r27
    c104:	0c f0       	brlt	.+2      	; 0xc108 <Buf2Field+0x2ae>
    c106:	b8 cf       	rjmp	.-144    	; 0xc078 <Buf2Field+0x21e>
    c108:	c2 01       	movw	r24, r4
    c10a:	68 2d       	mov	r22, r8
    c10c:	0e 94 94 56 	call	0xad28	; 0xad28 <ewb>
    c110:	3a cf       	rjmp	.-396    	; 0xbf86 <Buf2Field+0x12c>
		break;
	case Word: case z_Word:
		SetField(F_Buf, uint16_t);
    c112:	20 91 f7 04 	lds	r18, 0x04F7
    c116:	30 91 f8 04 	lds	r19, 0x04F8
    c11a:	40 91 f9 04 	lds	r20, 0x04F9
    c11e:	50 91 fa 04 	lds	r21, 0x04FA
    c122:	c7 01       	movw	r24, r14
    c124:	a0 e0       	ldi	r26, 0x00	; 0
    c126:	b0 e0       	ldi	r27, 0x00	; 0
    c128:	82 17       	cp	r24, r18
    c12a:	93 07       	cpc	r25, r19
    c12c:	a4 07       	cpc	r26, r20
    c12e:	b5 07       	cpc	r27, r21
    c130:	08 f4       	brcc	.+2      	; 0xc134 <Buf2Field+0x2da>
    c132:	cc c1       	rjmp	.+920    	; 0xc4cc <Buf2Field+0x672>
    c134:	c4 01       	movw	r24, r8
    c136:	a0 e0       	ldi	r26, 0x00	; 0
    c138:	b0 e0       	ldi	r27, 0x00	; 0
    c13a:	28 17       	cp	r18, r24
    c13c:	39 07       	cpc	r19, r25
    c13e:	4a 07       	cpc	r20, r26
    c140:	5b 07       	cpc	r21, r27
    c142:	08 f0       	brcs	.+2      	; 0xc146 <Buf2Field+0x2ec>
    c144:	d8 c1       	rjmp	.+944    	; 0xc4f6 <Buf2Field+0x69c>
    c146:	f2 01       	movw	r30, r4
    c148:	91 82       	std	Z+1, r9	; 0x01
    c14a:	80 82       	st	Z, r8
    c14c:	1c cf       	rjmp	.-456    	; 0xbf86 <Buf2Field+0x12c>
		break;
	case EE_Word: case z_EE_Word:
		SetEEField(F_Buf, uint16_t, uint16_t, w);
    c14e:	20 91 f7 04 	lds	r18, 0x04F7
    c152:	30 91 f8 04 	lds	r19, 0x04F8
    c156:	40 91 f9 04 	lds	r20, 0x04F9
    c15a:	50 91 fa 04 	lds	r21, 0x04FA
    c15e:	c7 01       	movw	r24, r14
    c160:	a0 e0       	ldi	r26, 0x00	; 0
    c162:	b0 e0       	ldi	r27, 0x00	; 0
    c164:	82 17       	cp	r24, r18
    c166:	93 07       	cpc	r25, r19
    c168:	a4 07       	cpc	r26, r20
    c16a:	b5 07       	cpc	r27, r21
    c16c:	08 f4       	brcc	.+2      	; 0xc170 <Buf2Field+0x316>
    c16e:	b6 c1       	rjmp	.+876    	; 0xc4dc <Buf2Field+0x682>
    c170:	c4 01       	movw	r24, r8
    c172:	a0 e0       	ldi	r26, 0x00	; 0
    c174:	b0 e0       	ldi	r27, 0x00	; 0
    c176:	28 17       	cp	r18, r24
    c178:	39 07       	cpc	r19, r25
    c17a:	4a 07       	cpc	r20, r26
    c17c:	5b 07       	cpc	r21, r27
    c17e:	08 f4       	brcc	.+2      	; 0xc182 <Buf2Field+0x328>
    c180:	45 c0       	rjmp	.+138    	; 0xc20c <Buf2Field+0x3b2>
		break;
	case s_Word:
		SetField(sF_Buf, int16_t);
		break;
	case s_EE_Word:
		SetEEField(sF_Buf, int16_t, uint16_t, w);
    c182:	c2 01       	movw	r24, r4
    c184:	b9 01       	movw	r22, r18
    c186:	0e 94 d7 56 	call	0xadae	; 0xadae <eww>
    c18a:	fd ce       	rjmp	.-518    	; 0xbf86 <Buf2Field+0x12c>
		break;
	case EE_Word: case z_EE_Word:
		SetEEField(F_Buf, uint16_t, uint16_t, w);
		break;
	case s_Word:
		SetField(sF_Buf, int16_t);
    c18c:	20 91 fb 04 	lds	r18, 0x04FB
    c190:	30 91 fc 04 	lds	r19, 0x04FC
    c194:	40 91 fd 04 	lds	r20, 0x04FD
    c198:	50 91 fe 04 	lds	r21, 0x04FE
    c19c:	c7 01       	movw	r24, r14
    c19e:	aa 27       	eor	r26, r26
    c1a0:	97 fd       	sbrc	r25, 7
    c1a2:	a0 95       	com	r26
    c1a4:	ba 2f       	mov	r27, r26
    c1a6:	82 17       	cp	r24, r18
    c1a8:	93 07       	cpc	r25, r19
    c1aa:	a4 07       	cpc	r26, r20
    c1ac:	b5 07       	cpc	r27, r21
    c1ae:	0c f4       	brge	.+2      	; 0xc1b2 <Buf2Field+0x358>
    c1b0:	91 c1       	rjmp	.+802    	; 0xc4d4 <Buf2Field+0x67a>
    c1b2:	c4 01       	movw	r24, r8
    c1b4:	aa 27       	eor	r26, r26
    c1b6:	97 fd       	sbrc	r25, 7
    c1b8:	a0 95       	com	r26
    c1ba:	ba 2f       	mov	r27, r26
    c1bc:	28 17       	cp	r18, r24
    c1be:	39 07       	cpc	r19, r25
    c1c0:	4a 07       	cpc	r20, r26
    c1c2:	5b 07       	cpc	r21, r27
    c1c4:	0c f0       	brlt	.+2      	; 0xc1c8 <Buf2Field+0x36e>
    c1c6:	9b c1       	rjmp	.+822    	; 0xc4fe <Buf2Field+0x6a4>
    c1c8:	d2 01       	movw	r26, r4
    c1ca:	8d 92       	st	X+, r8
    c1cc:	9c 92       	st	X, r9
    c1ce:	db ce       	rjmp	.-586    	; 0xbf86 <Buf2Field+0x12c>
		break;
	case s_EE_Word:
		SetEEField(sF_Buf, int16_t, uint16_t, w);
    c1d0:	20 91 fb 04 	lds	r18, 0x04FB
    c1d4:	30 91 fc 04 	lds	r19, 0x04FC
    c1d8:	40 91 fd 04 	lds	r20, 0x04FD
    c1dc:	50 91 fe 04 	lds	r21, 0x04FE
    c1e0:	c7 01       	movw	r24, r14
    c1e2:	aa 27       	eor	r26, r26
    c1e4:	97 fd       	sbrc	r25, 7
    c1e6:	a0 95       	com	r26
    c1e8:	ba 2f       	mov	r27, r26
    c1ea:	82 17       	cp	r24, r18
    c1ec:	93 07       	cpc	r25, r19
    c1ee:	a4 07       	cpc	r26, r20
    c1f0:	b5 07       	cpc	r27, r21
    c1f2:	0c f4       	brge	.+2      	; 0xc1f6 <Buf2Field+0x39c>
    c1f4:	73 c1       	rjmp	.+742    	; 0xc4dc <Buf2Field+0x682>
    c1f6:	c4 01       	movw	r24, r8
    c1f8:	aa 27       	eor	r26, r26
    c1fa:	97 fd       	sbrc	r25, 7
    c1fc:	a0 95       	com	r26
    c1fe:	ba 2f       	mov	r27, r26
    c200:	28 17       	cp	r18, r24
    c202:	39 07       	cpc	r19, r25
    c204:	4a 07       	cpc	r20, r26
    c206:	5b 07       	cpc	r21, r27
    c208:	0c f0       	brlt	.+2      	; 0xc20c <Buf2Field+0x3b2>
    c20a:	bb cf       	rjmp	.-138    	; 0xc182 <Buf2Field+0x328>
    c20c:	c2 01       	movw	r24, r4
    c20e:	b4 01       	movw	r22, r8
    c210:	0e 94 d7 56 	call	0xadae	; 0xadae <eww>
    c214:	b8 ce       	rjmp	.-656    	; 0xbf86 <Buf2Field+0x12c>
		break;
	case c_Word: case zc_Word:
		*(uint16_t*)Var = F_Buf;
    c216:	80 91 f7 04 	lds	r24, 0x04F7
    c21a:	90 91 f8 04 	lds	r25, 0x04F8
    c21e:	d2 01       	movw	r26, r4
    c220:	8d 93       	st	X+, r24
    c222:	9c 93       	st	X, r25
    c224:	b0 ce       	rjmp	.-672    	; 0xbf86 <Buf2Field+0x12c>
		break;


	case Longint: case z_Longint:
		//if(Limit_uByteVar(Temp)) sscanf(BufStr,"%ud", (unsigned short int*)&Temp);
		PresicionHanler(Field);
    c226:	c6 01       	movw	r24, r12
    c228:	0e 94 08 4b 	call	0x9610	; 0x9610 <PresicionHanler>
		sscanf(BufStr,"%lud", (uint32_t*)&Temp);
    c22c:	00 d0       	rcall	.+0      	; 0xc22e <Buf2Field+0x3d4>
    c22e:	00 d0       	rcall	.+0      	; 0xc230 <Buf2Field+0x3d6>
    c230:	ed b7       	in	r30, 0x3d	; 61
    c232:	fe b7       	in	r31, 0x3e	; 62
    c234:	31 96       	adiw	r30, 0x01	; 1
    c236:	83 ec       	ldi	r24, 0xC3	; 195
    c238:	95 e0       	ldi	r25, 0x05	; 5
    c23a:	ad b7       	in	r26, 0x3d	; 61
    c23c:	be b7       	in	r27, 0x3e	; 62
    c23e:	12 96       	adiw	r26, 0x02	; 2
    c240:	9c 93       	st	X, r25
    c242:	8e 93       	st	-X, r24
    c244:	11 97       	sbiw	r26, 0x01	; 1
    c246:	8f e9       	ldi	r24, 0x9F	; 159
    c248:	92 e0       	ldi	r25, 0x02	; 2
    c24a:	93 83       	std	Z+3, r25	; 0x03
    c24c:	82 83       	std	Z+2, r24	; 0x02
    c24e:	ce 01       	movw	r24, r28
    c250:	01 96       	adiw	r24, 0x01	; 1
    c252:	95 83       	std	Z+5, r25	; 0x05
    c254:	84 83       	std	Z+4, r24	; 0x04
    c256:	0e 94 51 8c 	call	0x118a2	; 0x118a2 <sscanf>
		SetField32(Temp, uint32_t);
    c25a:	89 81       	ldd	r24, Y+1	; 0x01
    c25c:	9a 81       	ldd	r25, Y+2	; 0x02
    c25e:	ab 81       	ldd	r26, Y+3	; 0x03
    c260:	bc 81       	ldd	r27, Y+4	; 0x04
    c262:	ed b7       	in	r30, 0x3d	; 61
    c264:	fe b7       	in	r31, 0x3e	; 62
    c266:	36 96       	adiw	r30, 0x06	; 6
    c268:	0f b6       	in	r0, 0x3f	; 63
    c26a:	f8 94       	cli
    c26c:	fe bf       	out	0x3e, r31	; 62
    c26e:	0f be       	out	0x3f, r0	; 63
    c270:	ed bf       	out	0x3d, r30	; 61
    c272:	e8 16       	cp	r14, r24
    c274:	f9 06       	cpc	r15, r25
    c276:	0a 07       	cpc	r16, r26
    c278:	1b 07       	cpc	r17, r27
    c27a:	08 f4       	brcc	.+2      	; 0xc27e <Buf2Field+0x424>
    c27c:	17 c1       	rjmp	.+558    	; 0xc4ac <Buf2Field+0x652>
    c27e:	88 15       	cp	r24, r8
    c280:	99 05       	cpc	r25, r9
    c282:	aa 05       	cpc	r26, r10
    c284:	bb 05       	cpc	r27, r11
    c286:	b8 f1       	brcs	.+110    	; 0xc2f6 <Buf2Field+0x49c>
		break;
	case s_Longint:
		PresicionHanler(Field);
		//if(Limit_sByteVar(Temp)) sscanf(BufStr,"%hd", (short int*)&Temp);
		sscanf(BufStr,"%ld", (int32_t*)&Temp);
		SetField32(Temp, int32_t);
    c288:	f2 01       	movw	r30, r4
    c28a:	80 83       	st	Z, r24
    c28c:	91 83       	std	Z+1, r25	; 0x01
    c28e:	a2 83       	std	Z+2, r26	; 0x02
    c290:	b3 83       	std	Z+3, r27	; 0x03
    c292:	79 ce       	rjmp	.-782    	; 0xbf86 <Buf2Field+0x12c>
		if(sscanf(BufStr,"%lud", (uint32_t*)&Temp) == 1){
			SetEEField32(Temp, uint32_t, uint32_t, d);
		}		
		break;
	case s_Longint:
		PresicionHanler(Field);
    c294:	c6 01       	movw	r24, r12
    c296:	0e 94 08 4b 	call	0x9610	; 0x9610 <PresicionHanler>
		//if(Limit_sByteVar(Temp)) sscanf(BufStr,"%hd", (short int*)&Temp);
		sscanf(BufStr,"%ld", (int32_t*)&Temp);
    c29a:	00 d0       	rcall	.+0      	; 0xc29c <Buf2Field+0x442>
    c29c:	00 d0       	rcall	.+0      	; 0xc29e <Buf2Field+0x444>
    c29e:	ed b7       	in	r30, 0x3d	; 61
    c2a0:	fe b7       	in	r31, 0x3e	; 62
    c2a2:	31 96       	adiw	r30, 0x01	; 1
    c2a4:	83 ec       	ldi	r24, 0xC3	; 195
    c2a6:	95 e0       	ldi	r25, 0x05	; 5
    c2a8:	ad b7       	in	r26, 0x3d	; 61
    c2aa:	be b7       	in	r27, 0x3e	; 62
    c2ac:	12 96       	adiw	r26, 0x02	; 2
    c2ae:	9c 93       	st	X, r25
    c2b0:	8e 93       	st	-X, r24
    c2b2:	11 97       	sbiw	r26, 0x01	; 1
    c2b4:	84 ea       	ldi	r24, 0xA4	; 164
    c2b6:	92 e0       	ldi	r25, 0x02	; 2
    c2b8:	93 83       	std	Z+3, r25	; 0x03
    c2ba:	82 83       	std	Z+2, r24	; 0x02
    c2bc:	ce 01       	movw	r24, r28
    c2be:	01 96       	adiw	r24, 0x01	; 1
    c2c0:	95 83       	std	Z+5, r25	; 0x05
    c2c2:	84 83       	std	Z+4, r24	; 0x04
    c2c4:	0e 94 51 8c 	call	0x118a2	; 0x118a2 <sscanf>
		SetField32(Temp, int32_t);
    c2c8:	89 81       	ldd	r24, Y+1	; 0x01
    c2ca:	9a 81       	ldd	r25, Y+2	; 0x02
    c2cc:	ab 81       	ldd	r26, Y+3	; 0x03
    c2ce:	bc 81       	ldd	r27, Y+4	; 0x04
    c2d0:	ed b7       	in	r30, 0x3d	; 61
    c2d2:	fe b7       	in	r31, 0x3e	; 62
    c2d4:	36 96       	adiw	r30, 0x06	; 6
    c2d6:	0f b6       	in	r0, 0x3f	; 63
    c2d8:	f8 94       	cli
    c2da:	fe bf       	out	0x3e, r31	; 62
    c2dc:	0f be       	out	0x3f, r0	; 63
    c2de:	ed bf       	out	0x3d, r30	; 61
    c2e0:	e8 16       	cp	r14, r24
    c2e2:	f9 06       	cpc	r15, r25
    c2e4:	0a 07       	cpc	r16, r26
    c2e6:	1b 07       	cpc	r17, r27
    c2e8:	0c f4       	brge	.+2      	; 0xc2ec <Buf2Field+0x492>
    c2ea:	e0 c0       	rjmp	.+448    	; 0xc4ac <Buf2Field+0x652>
    c2ec:	88 15       	cp	r24, r8
    c2ee:	99 05       	cpc	r25, r9
    c2f0:	aa 05       	cpc	r26, r10
    c2f2:	bb 05       	cpc	r27, r11
    c2f4:	4c f6       	brge	.-110    	; 0xc288 <Buf2Field+0x42e>
    c2f6:	f2 01       	movw	r30, r4
    c2f8:	80 82       	st	Z, r8
    c2fa:	91 82       	std	Z+1, r9	; 0x01
    c2fc:	a2 82       	std	Z+2, r10	; 0x02
    c2fe:	b3 82       	std	Z+3, r11	; 0x03
    c300:	42 ce       	rjmp	.-892    	; 0xbf86 <Buf2Field+0x12c>
		break;
	case s_EE_Longint:
		PresicionHanler(Field);
    c302:	c6 01       	movw	r24, r12
    c304:	0e 94 08 4b 	call	0x9610	; 0x9610 <PresicionHanler>
		if(sscanf(BufStr,"%ld", (int32_t*)&Temp) == 1){
    c308:	00 d0       	rcall	.+0      	; 0xc30a <Buf2Field+0x4b0>
    c30a:	00 d0       	rcall	.+0      	; 0xc30c <Buf2Field+0x4b2>
    c30c:	ed b7       	in	r30, 0x3d	; 61
    c30e:	fe b7       	in	r31, 0x3e	; 62
    c310:	31 96       	adiw	r30, 0x01	; 1
    c312:	83 ec       	ldi	r24, 0xC3	; 195
    c314:	95 e0       	ldi	r25, 0x05	; 5
    c316:	ad b7       	in	r26, 0x3d	; 61
    c318:	be b7       	in	r27, 0x3e	; 62
    c31a:	12 96       	adiw	r26, 0x02	; 2
    c31c:	9c 93       	st	X, r25
    c31e:	8e 93       	st	-X, r24
    c320:	11 97       	sbiw	r26, 0x01	; 1
    c322:	84 ea       	ldi	r24, 0xA4	; 164
    c324:	92 e0       	ldi	r25, 0x02	; 2
    c326:	93 83       	std	Z+3, r25	; 0x03
    c328:	82 83       	std	Z+2, r24	; 0x02
    c32a:	ce 01       	movw	r24, r28
    c32c:	01 96       	adiw	r24, 0x01	; 1
    c32e:	95 83       	std	Z+5, r25	; 0x05
    c330:	84 83       	std	Z+4, r24	; 0x04
    c332:	0e 94 51 8c 	call	0x118a2	; 0x118a2 <sscanf>
    c336:	ed b7       	in	r30, 0x3d	; 61
    c338:	fe b7       	in	r31, 0x3e	; 62
    c33a:	36 96       	adiw	r30, 0x06	; 6
    c33c:	0f b6       	in	r0, 0x3f	; 63
    c33e:	f8 94       	cli
    c340:	fe bf       	out	0x3e, r31	; 62
    c342:	0f be       	out	0x3f, r0	; 63
    c344:	ed bf       	out	0x3d, r30	; 61
    c346:	01 97       	sbiw	r24, 0x01	; 1
    c348:	09 f0       	breq	.+2      	; 0xc34c <Buf2Field+0x4f2>
    c34a:	1d ce       	rjmp	.-966    	; 0xbf86 <Buf2Field+0x12c>
			SetEEField32(Temp, int32_t, uint32_t, d);
    c34c:	49 81       	ldd	r20, Y+1	; 0x01
    c34e:	5a 81       	ldd	r21, Y+2	; 0x02
    c350:	6b 81       	ldd	r22, Y+3	; 0x03
    c352:	7c 81       	ldd	r23, Y+4	; 0x04
    c354:	ca 01       	movw	r24, r20
    c356:	db 01       	movw	r26, r22
    c358:	e8 16       	cp	r14, r24
    c35a:	f9 06       	cpc	r15, r25
    c35c:	0a 07       	cpc	r16, r26
    c35e:	1b 07       	cpc	r17, r27
    c360:	0c f4       	brge	.+2      	; 0xc364 <Buf2Field+0x50a>
    c362:	d4 c0       	rjmp	.+424    	; 0xc50c <Buf2Field+0x6b2>
    c364:	88 15       	cp	r24, r8
    c366:	99 05       	cpc	r25, r9
    c368:	aa 05       	cpc	r26, r10
    c36a:	bb 05       	cpc	r27, r11
    c36c:	0c f0       	brlt	.+2      	; 0xc370 <Buf2Field+0x516>
    c36e:	08 ce       	rjmp	.-1008   	; 0xbf80 <Buf2Field+0x126>
    c370:	c2 01       	movw	r24, r4
    c372:	b5 01       	movw	r22, r10
    c374:	a4 01       	movw	r20, r8
    c376:	0e 94 0e 58 	call	0xb01c	; 0xb01c <ewd>
    c37a:	05 ce       	rjmp	.-1014   	; 0xbf86 <Buf2Field+0x12c>
		}
		break;


	case FFloat: case GFloat:
		sscanf(BufStr,"%f", &fTemp);
    c37c:	00 d0       	rcall	.+0      	; 0xc37e <Buf2Field+0x524>
    c37e:	00 d0       	rcall	.+0      	; 0xc380 <Buf2Field+0x526>
    c380:	ed b7       	in	r30, 0x3d	; 61
    c382:	fe b7       	in	r31, 0x3e	; 62
    c384:	31 96       	adiw	r30, 0x01	; 1
    c386:	83 ec       	ldi	r24, 0xC3	; 195
    c388:	95 e0       	ldi	r25, 0x05	; 5
    c38a:	ad b7       	in	r26, 0x3d	; 61
    c38c:	be b7       	in	r27, 0x3e	; 62
    c38e:	12 96       	adiw	r26, 0x02	; 2
    c390:	9c 93       	st	X, r25
    c392:	8e 93       	st	-X, r24
    c394:	11 97       	sbiw	r26, 0x01	; 1
    c396:	88 ea       	ldi	r24, 0xA8	; 168
    c398:	92 e0       	ldi	r25, 0x02	; 2
    c39a:	93 83       	std	Z+3, r25	; 0x03
    c39c:	82 83       	std	Z+2, r24	; 0x02
    c39e:	ce 01       	movw	r24, r28
    c3a0:	05 96       	adiw	r24, 0x05	; 5
    c3a2:	95 83       	std	Z+5, r25	; 0x05
    c3a4:	84 83       	std	Z+4, r24	; 0x04
    c3a6:	0e 94 51 8c 	call	0x118a2	; 0x118a2 <sscanf>
		*(float*)Var = fTemp;
    c3aa:	8d 81       	ldd	r24, Y+5	; 0x05
    c3ac:	9e 81       	ldd	r25, Y+6	; 0x06
    c3ae:	af 81       	ldd	r26, Y+7	; 0x07
    c3b0:	b8 85       	ldd	r27, Y+8	; 0x08
    c3b2:	f2 01       	movw	r30, r4
    c3b4:	80 83       	st	Z, r24
    c3b6:	91 83       	std	Z+1, r25	; 0x01
    c3b8:	a2 83       	std	Z+2, r26	; 0x02
    c3ba:	b3 83       	std	Z+3, r27	; 0x03
    c3bc:	2d b7       	in	r18, 0x3d	; 61
    c3be:	3e b7       	in	r19, 0x3e	; 62
    c3c0:	2a 5f       	subi	r18, 0xFA	; 250
    c3c2:	3f 4f       	sbci	r19, 0xFF	; 255
    c3c4:	0f b6       	in	r0, 0x3f	; 63
    c3c6:	f8 94       	cli
    c3c8:	3e bf       	out	0x3e, r19	; 62
    c3ca:	0f be       	out	0x3f, r0	; 63
    c3cc:	2d bf       	out	0x3d, r18	; 61
    c3ce:	db cd       	rjmp	.-1098   	; 0xbf86 <Buf2Field+0x12c>
		break;
	case EE_FFloat: case EE_GFloat:
		if(sscanf(BufStr,"%f", &fTemp) == 1){
    c3d0:	00 d0       	rcall	.+0      	; 0xc3d2 <Buf2Field+0x578>
    c3d2:	00 d0       	rcall	.+0      	; 0xc3d4 <Buf2Field+0x57a>
    c3d4:	ed b7       	in	r30, 0x3d	; 61
    c3d6:	fe b7       	in	r31, 0x3e	; 62
    c3d8:	31 96       	adiw	r30, 0x01	; 1
    c3da:	83 ec       	ldi	r24, 0xC3	; 195
    c3dc:	95 e0       	ldi	r25, 0x05	; 5
    c3de:	ad b7       	in	r26, 0x3d	; 61
    c3e0:	be b7       	in	r27, 0x3e	; 62
    c3e2:	12 96       	adiw	r26, 0x02	; 2
    c3e4:	9c 93       	st	X, r25
    c3e6:	8e 93       	st	-X, r24
    c3e8:	11 97       	sbiw	r26, 0x01	; 1
    c3ea:	88 ea       	ldi	r24, 0xA8	; 168
    c3ec:	92 e0       	ldi	r25, 0x02	; 2
    c3ee:	93 83       	std	Z+3, r25	; 0x03
    c3f0:	82 83       	std	Z+2, r24	; 0x02
    c3f2:	8e 01       	movw	r16, r28
    c3f4:	0b 5f       	subi	r16, 0xFB	; 251
    c3f6:	1f 4f       	sbci	r17, 0xFF	; 255
    c3f8:	15 83       	std	Z+5, r17	; 0x05
    c3fa:	04 83       	std	Z+4, r16	; 0x04
    c3fc:	0e 94 51 8c 	call	0x118a2	; 0x118a2 <sscanf>
    c400:	ed b7       	in	r30, 0x3d	; 61
    c402:	fe b7       	in	r31, 0x3e	; 62
    c404:	36 96       	adiw	r30, 0x06	; 6
    c406:	0f b6       	in	r0, 0x3f	; 63
    c408:	f8 94       	cli
    c40a:	fe bf       	out	0x3e, r31	; 62
    c40c:	0f be       	out	0x3f, r0	; 63
    c40e:	ed bf       	out	0x3d, r30	; 61
    c410:	01 97       	sbiw	r24, 0x01	; 1
    c412:	09 f0       	breq	.+2      	; 0xc416 <Buf2Field+0x5bc>
    c414:	b8 cd       	rjmp	.-1168   	; 0xbf86 <Buf2Field+0x12c>
			ewbl(&fTemp, (float*)Var, 4);
    c416:	c8 01       	movw	r24, r16
    c418:	b2 01       	movw	r22, r4
    c41a:	44 e0       	ldi	r20, 0x04	; 4
    c41c:	50 e0       	ldi	r21, 0x00	; 0
    c41e:	0e 94 09 58 	call	0xb012	; 0xb012 <ewbl>
    c422:	b1 cd       	rjmp	.-1182   	; 0xbf86 <Buf2Field+0x12c>
		}
		break;


	case Bit:
		if(F_Buf)
    c424:	80 91 f7 04 	lds	r24, 0x04F7
    c428:	90 91 f8 04 	lds	r25, 0x04F8
    c42c:	a0 91 f9 04 	lds	r26, 0x04F9
    c430:	b0 91 fa 04 	lds	r27, 0x04FA
    c434:	00 97       	sbiw	r24, 0x00	; 0
    c436:	a1 05       	cpc	r26, r1
    c438:	b1 05       	cpc	r27, r1
    c43a:	91 f1       	breq	.+100    	; 0xc4a0 <Buf2Field+0x646>
			*BitVar |=Mask;
    c43c:	d3 01       	movw	r26, r6
    c43e:	8c 91       	ld	r24, X
    c440:	83 29       	or	r24, r3
    c442:	8c 93       	st	X, r24
    c444:	a0 cd       	rjmp	.-1216   	; 0xbf86 <Buf2Field+0x12c>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    c446:	c3 01       	movw	r24, r6
    c448:	0e 94 1d 8e 	call	0x11c3a	; 0x11c3a <__eerd_byte_m2560>
    c44c:	28 2f       	mov	r18, r24
		else
			*BitVar &=~Mask;
		break;
	case EE_Bit:
		EE_BitVar=erb(BitVar);
		ewb(BitVar, F_Buf ? EE_BitVar |Mask : EE_BitVar &~Mask);
    c44e:	80 91 f7 04 	lds	r24, 0x04F7
    c452:	90 91 f8 04 	lds	r25, 0x04F8
    c456:	a0 91 f9 04 	lds	r26, 0x04F9
    c45a:	b0 91 fa 04 	lds	r27, 0x04FA
    c45e:	00 97       	sbiw	r24, 0x00	; 0
    c460:	a1 05       	cpc	r26, r1
    c462:	b1 05       	cpc	r27, r1
    c464:	d1 f4       	brne	.+52     	; 0xc49a <Buf2Field+0x640>
    c466:	63 2d       	mov	r22, r3
    c468:	60 95       	com	r22
    c46a:	62 23       	and	r22, r18
    c46c:	c3 01       	movw	r24, r6
    c46e:	0e 94 94 56 	call	0xad28	; 0xad28 <ewb>
    c472:	89 cd       	rjmp	.-1262   	; 0xbf86 <Buf2Field+0x12c>
		break;


	case Text:{
		//    
		uint8_t Field_width = strlen((char*)Var);
    c474:	f2 01       	movw	r30, r4
    c476:	01 90       	ld	r0, Z+
    c478:	00 20       	and	r0, r0
    c47a:	e9 f7       	brne	.-6      	; 0xc476 <Buf2Field+0x61c>
    c47c:	31 97       	sbiw	r30, 0x01	; 1
    c47e:	4e 2f       	mov	r20, r30
    c480:	44 19       	sub	r20, r4
		if(Field_width > LCDXSz) Field_width = LCDXSz+1;
    c482:	45 31       	cpi	r20, 0x15	; 21
    c484:	e8 f0       	brcs	.+58     	; 0xc4c0 <Buf2Field+0x666>
    c486:	e5 e1       	ldi	r30, 0x15	; 21
    c488:	f0 e0       	ldi	r31, 0x00	; 0
		memcpy(Var,BufStr,Field_width);
    c48a:	23 ec       	ldi	r18, 0xC3	; 195
    c48c:	35 e0       	ldi	r19, 0x05	; 5
    c48e:	c2 01       	movw	r24, r4
    c490:	b9 01       	movw	r22, r18
    c492:	af 01       	movw	r20, r30
    c494:	0e 94 3f 8b 	call	0x1167e	; 0x1167e <memcpy>
    c498:	76 cd       	rjmp	.-1300   	; 0xbf86 <Buf2Field+0x12c>
		else
			*BitVar &=~Mask;
		break;
	case EE_Bit:
		EE_BitVar=erb(BitVar);
		ewb(BitVar, F_Buf ? EE_BitVar |Mask : EE_BitVar &~Mask);
    c49a:	63 2d       	mov	r22, r3
    c49c:	62 2b       	or	r22, r18
    c49e:	e6 cf       	rjmp	.-52     	; 0xc46c <Buf2Field+0x612>

	case Bit:
		if(F_Buf)
			*BitVar |=Mask;
		else
			*BitVar &=~Mask;
    c4a0:	30 94       	com	r3
    c4a2:	f3 01       	movw	r30, r6
    c4a4:	80 81       	ld	r24, Z
    c4a6:	83 21       	and	r24, r3
    c4a8:	80 83       	st	Z, r24
    c4aa:	6d cd       	rjmp	.-1318   	; 0xbf86 <Buf2Field+0x12c>
		break;
	case s_Longint:
		PresicionHanler(Field);
		//if(Limit_sByteVar(Temp)) sscanf(BufStr,"%hd", (short int*)&Temp);
		sscanf(BufStr,"%ld", (int32_t*)&Temp);
		SetField32(Temp, int32_t);
    c4ac:	d2 01       	movw	r26, r4
    c4ae:	ed 92       	st	X+, r14
    c4b0:	fd 92       	st	X+, r15
    c4b2:	0d 93       	st	X+, r16
    c4b4:	1c 93       	st	X, r17
    c4b6:	13 97       	sbiw	r26, 0x03	; 3
    c4b8:	66 cd       	rjmp	.-1332   	; 0xbf86 <Buf2Field+0x12c>
	switch(prb(&Field->Type)) {
	case Byte: case z_Byte: case Enum:
		SetField(F_Buf, uint8_t);
		break;
	case s_Byte:
		SetField(sF_Buf, int8_t);
    c4ba:	f2 01       	movw	r30, r4
    c4bc:	e0 82       	st	Z, r14
    c4be:	63 cd       	rjmp	.-1338   	; 0xbf86 <Buf2Field+0x12c>


	case Text:{
		//    
		uint8_t Field_width = strlen((char*)Var);
		if(Field_width > LCDXSz) Field_width = LCDXSz+1;
    c4c0:	e4 2f       	mov	r30, r20
    c4c2:	f0 e0       	ldi	r31, 0x00	; 0
    c4c4:	e2 cf       	rjmp	.-60     	; 0xc48a <Buf2Field+0x630>
	uint32_t Temp=0;
	float fTemp=0;

	switch(prb(&Field->Type)) {
	case Byte: case z_Byte: case Enum:
		SetField(F_Buf, uint8_t);
    c4c6:	d2 01       	movw	r26, r4
    c4c8:	ec 92       	st	X, r14
    c4ca:	5d cd       	rjmp	.-1350   	; 0xbf86 <Buf2Field+0x12c>
		break;
	case s_EE_Byte:
		SetEEField(sF_Buf, int8_t, uint8_t, b);
		break;
	case Word: case z_Word:
		SetField(F_Buf, uint16_t);
    c4cc:	d2 01       	movw	r26, r4
    c4ce:	ed 92       	st	X+, r14
    c4d0:	fc 92       	st	X, r15
    c4d2:	59 cd       	rjmp	.-1358   	; 0xbf86 <Buf2Field+0x12c>
		break;
	case EE_Word: case z_EE_Word:
		SetEEField(F_Buf, uint16_t, uint16_t, w);
		break;
	case s_Word:
		SetField(sF_Buf, int16_t);
    c4d4:	f2 01       	movw	r30, r4
    c4d6:	f1 82       	std	Z+1, r15	; 0x01
    c4d8:	e0 82       	st	Z, r14
    c4da:	55 cd       	rjmp	.-1366   	; 0xbf86 <Buf2Field+0x12c>
		break;
	case s_EE_Word:
		SetEEField(sF_Buf, int16_t, uint16_t, w);
    c4dc:	c2 01       	movw	r24, r4
    c4de:	b7 01       	movw	r22, r14
    c4e0:	0e 94 d7 56 	call	0xadae	; 0xadae <eww>
    c4e4:	50 cd       	rjmp	.-1376   	; 0xbf86 <Buf2Field+0x12c>
		break;
	case EE_Byte: case z_EE_Byte: case EE_Enum:
		SetEEField(F_Buf, uint8_t, uint8_t, b);
		break;
	case s_EE_Byte:
		SetEEField(sF_Buf, int8_t, uint8_t, b);
    c4e6:	c2 01       	movw	r24, r4
    c4e8:	6e 2d       	mov	r22, r14
    c4ea:	0e 94 94 56 	call	0xad28	; 0xad28 <ewb>
    c4ee:	4b cd       	rjmp	.-1386   	; 0xbf86 <Buf2Field+0x12c>
	switch(prb(&Field->Type)) {
	case Byte: case z_Byte: case Enum:
		SetField(F_Buf, uint8_t);
		break;
	case s_Byte:
		SetField(sF_Buf, int8_t);
    c4f0:	f2 01       	movw	r30, r4
    c4f2:	20 83       	st	Z, r18
    c4f4:	48 cd       	rjmp	.-1392   	; 0xbf86 <Buf2Field+0x12c>
		break;
	case s_EE_Byte:
		SetEEField(sF_Buf, int8_t, uint8_t, b);
		break;
	case Word: case z_Word:
		SetField(F_Buf, uint16_t);
    c4f6:	d2 01       	movw	r26, r4
    c4f8:	2d 93       	st	X+, r18
    c4fa:	3c 93       	st	X, r19
    c4fc:	44 cd       	rjmp	.-1400   	; 0xbf86 <Buf2Field+0x12c>
		break;
	case EE_Word: case z_EE_Word:
		SetEEField(F_Buf, uint16_t, uint16_t, w);
		break;
	case s_Word:
		SetField(sF_Buf, int16_t);
    c4fe:	f2 01       	movw	r30, r4
    c500:	31 83       	std	Z+1, r19	; 0x01
    c502:	20 83       	st	Z, r18
    c504:	40 cd       	rjmp	.-1408   	; 0xbf86 <Buf2Field+0x12c>
	uint32_t Temp=0;
	float fTemp=0;

	switch(prb(&Field->Type)) {
	case Byte: case z_Byte: case Enum:
		SetField(F_Buf, uint8_t);
    c506:	d2 01       	movw	r26, r4
    c508:	2c 93       	st	X, r18
    c50a:	3d cd       	rjmp	.-1414   	; 0xbf86 <Buf2Field+0x12c>
		SetField32(Temp, int32_t);
		break;
	case s_EE_Longint:
		PresicionHanler(Field);
		if(sscanf(BufStr,"%ld", (int32_t*)&Temp) == 1){
			SetEEField32(Temp, int32_t, uint32_t, d);
    c50c:	c2 01       	movw	r24, r4
    c50e:	b8 01       	movw	r22, r16
    c510:	a7 01       	movw	r20, r14
    c512:	0e 94 0e 58 	call	0xb01c	; 0xb01c <ewd>
    c516:	37 cd       	rjmp	.-1426   	; 0xbf86 <Buf2Field+0x12c>

0000c518 <MenuEnterRight>:
}

// ~~~~~~~~~~~~~~~~~
void
MenuEnterRight(void)
{
    c518:	ef 92       	push	r14
    c51a:	ff 92       	push	r15
    c51c:	0f 93       	push	r16
    c51e:	1f 93       	push	r17
    c520:	cf 93       	push	r28
    c522:	df 93       	push	r29
//	1) Hide current Message
	if(HideMsg()||KeyFunc(&CurrPage->Enter))
    c524:	0e 94 24 46 	call	0x8c48	; 0x8c48 <HideMsg>
    c528:	88 23       	and	r24, r24
    c52a:	39 f0       	breq	.+14     	; 0xc53a <MenuEnterRight+0x22>
	if(NextPage || (NextPage=prp(&Line->InnPage))) {
		GotoMenu(NextPage);
		NextPage=NULL;
		return;
	}
}
    c52c:	df 91       	pop	r29
    c52e:	cf 91       	pop	r28
    c530:	1f 91       	pop	r17
    c532:	0f 91       	pop	r16
    c534:	ff 90       	pop	r15
    c536:	ef 90       	pop	r14
    c538:	08 95       	ret
// ~~~~~~~~~~~~~~~~~
void
MenuEnterRight(void)
{
//	1) Hide current Message
	if(HideMsg()||KeyFunc(&CurrPage->Enter))
    c53a:	80 91 d4 02 	lds	r24, 0x02D4
    c53e:	90 91 d5 02 	lds	r25, 0x02D5
    c542:	0c 96       	adiw	r24, 0x0c	; 12
    c544:	0e 94 ca 45 	call	0x8b94	; 0x8b94 <KeyFunc>
    c548:	88 23       	and	r24, r24
    c54a:	81 f7       	brne	.-32     	; 0xc52c <MenuEnterRight+0x14>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    c54c:	40 91 d4 02 	lds	r20, 0x02D4
    c550:	50 91 d5 02 	lds	r21, 0x02D5
    c554:	fa 01       	movw	r30, r20
    c556:	c5 91       	lpm	r28, Z+
    c558:	d4 91       	lpm	r29, Z+
		return;

	MenuLine *Line=GetLine+CurrLine;
    c55a:	90 91 ca 07 	lds	r25, 0x07CA
    c55e:	8b e1       	ldi	r24, 0x1B	; 27
    c560:	98 9f       	mul	r25, r24
    c562:	b0 01       	movw	r22, r0
    c564:	11 24       	eor	r1, r1
    c566:	c6 0f       	add	r28, r22
    c568:	d7 1f       	adc	r29, r23
    c56a:	fe 01       	movw	r30, r28
    c56c:	77 96       	adiw	r30, 0x17	; 23
    c56e:	e5 90       	lpm	r14, Z+
    c570:	f4 90       	lpm	r15, Z+
	OutField *Field=prp(&Line->OF_List);

// 2) Variable
	if(Field){
    c572:	e1 14       	cp	r14, r1
    c574:	f1 04       	cpc	r15, r1
    c576:	09 f4       	brne	.+2      	; 0xc57a <MenuEnterRight+0x62>
    c578:	93 c0       	rjmp	.+294    	; 0xc6a0 <MenuEnterRight+0x188>
    c57a:	10 e0       	ldi	r17, 0x00	; 0
    c57c:	30 e0       	ldi	r19, 0x00	; 0
    c57e:	80 e0       	ldi	r24, 0x00	; 0
    c580:	90 e0       	ldi	r25, 0x00	; 0
    c582:	05 c0       	rjmp	.+10     	; 0xc58e <MenuEnterRight+0x76>
		uint8_t i=0;
		while(i<LCDXSz) {
			Char1 = Char2;
			Char2 = prc(CurrStr+i++);
			if (Char2=='}' && Char1!='}')
				FieldNumber++;
    c584:	01 96       	adiw	r24, 0x01	; 1
	// Define variable quantity 
		uint8_t FieldNumber = 0;
		PGM_P CurrStr=(PGM_P)(Line->Str);
		char Char1, Char2=0;
		uint8_t i=0;
		while(i<LCDXSz) {
    c586:	84 31       	cpi	r24, 0x14	; 20
    c588:	91 05       	cpc	r25, r1
    c58a:	71 f0       	breq	.+28     	; 0xc5a8 <MenuEnterRight+0x90>
    c58c:	32 2f       	mov	r19, r18

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    c58e:	fe 01       	movw	r30, r28
    c590:	e8 0f       	add	r30, r24
    c592:	f9 1f       	adc	r31, r25
    c594:	24 91       	lpm	r18, Z+
			Char1 = Char2;
			Char2 = prc(CurrStr+i++);
			if (Char2=='}' && Char1!='}')
    c596:	2d 37       	cpi	r18, 0x7D	; 125
    c598:	a9 f7       	brne	.-22     	; 0xc584 <MenuEnterRight+0x6c>
    c59a:	3d 37       	cpi	r19, 0x7D	; 125
    c59c:	99 f3       	breq	.-26     	; 0xc584 <MenuEnterRight+0x6c>
				FieldNumber++;
    c59e:	1f 5f       	subi	r17, 0xFF	; 255
    c5a0:	01 96       	adiw	r24, 0x01	; 1
	// Define variable quantity 
		uint8_t FieldNumber = 0;
		PGM_P CurrStr=(PGM_P)(Line->Str);
		char Char1, Char2=0;
		uint8_t i=0;
		while(i<LCDXSz) {
    c5a2:	84 31       	cpi	r24, 0x14	; 20
    c5a4:	91 05       	cpc	r25, r1
    c5a6:	91 f7       	brne	.-28     	; 0xc58c <MenuEnterRight+0x74>
			Char2 = prc(CurrStr+i++);
			if (Char2=='}' && Char1!='}')
				FieldNumber++;
		}
		//    Bit (:)   
		if(FieldNumber==1 && prb(&Field->Type)==Bit) {
    c5a8:	11 30       	cpi	r17, 0x01	; 1
    c5aa:	09 f4       	brne	.+2      	; 0xc5ae <MenuEnterRight+0x96>
    c5ac:	b8 c0       	rjmp	.+368    	; 0xc71e <MenuEnterRight+0x206>
			EventFunc(&Field->Act);
			return;
		}

	//    
		if(CurrPos!=NullPos && --CurrPos!=NullPos){
    c5ae:	80 91 d7 02 	lds	r24, 0x02D7
    c5b2:	8f 3f       	cpi	r24, 0xFF	; 255
    c5b4:	09 f4       	brne	.+2      	; 0xc5b8 <MenuEnterRight+0xa0>
    c5b6:	4a c0       	rjmp	.+148    	; 0xc64c <MenuEnterRight+0x134>
    c5b8:	08 2f       	mov	r16, r24
    c5ba:	01 50       	subi	r16, 0x01	; 1
    c5bc:	00 93 d7 02 	sts	0x02D7, r16
    c5c0:	0f 3f       	cpi	r16, 0xFF	; 255
    c5c2:	09 f4       	brne	.+2      	; 0xc5c6 <MenuEnterRight+0xae>
    c5c4:	43 c0       	rjmp	.+134    	; 0xc64c <MenuEnterRight+0x134>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    c5c6:	fa 01       	movw	r30, r20
    c5c8:	45 91       	lpm	r20, Z+
    c5ca:	54 91       	lpm	r21, Z+
			OutField *Field1=GetField;
    c5cc:	46 0f       	add	r20, r22
    c5ce:	57 1f       	adc	r21, r23
    c5d0:	49 5e       	subi	r20, 0xE9	; 233
    c5d2:	5f 4f       	sbci	r21, 0xFF	; 255
    c5d4:	fa 01       	movw	r30, r20
    c5d6:	25 91       	lpm	r18, Z+
    c5d8:	34 91       	lpm	r19, Z+
    c5da:	80 91 d6 02 	lds	r24, 0x02D6
    c5de:	90 e0       	ldi	r25, 0x00	; 0
    c5e0:	82 95       	swap	r24
    c5e2:	92 95       	swap	r25
    c5e4:	90 7f       	andi	r25, 0xF0	; 240
    c5e6:	98 27       	eor	r25, r24
    c5e8:	80 7f       	andi	r24, 0xF0	; 240
    c5ea:	98 27       	eor	r25, r24
    c5ec:	28 0f       	add	r18, r24
    c5ee:	39 1f       	adc	r19, r25

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    c5f0:	f9 01       	movw	r30, r18
    c5f2:	84 91       	lpm	r24, Z+
			switch(prb(&Field1->Type)){
    c5f4:	8d 31       	cpi	r24, 0x1D	; 29
    c5f6:	08 f4       	brcc	.+2      	; 0xc5fa <MenuEnterRight+0xe2>
    c5f8:	67 c0       	rjmp	.+206    	; 0xc6c8 <MenuEnterRight+0x1b0>
    c5fa:	81 52       	subi	r24, 0x21	; 33
    c5fc:	82 30       	cpi	r24, 0x02	; 2
    c5fe:	08 f0       	brcs	.+2      	; 0xc602 <MenuEnterRight+0xea>
    c600:	95 cf       	rjmp	.-214    	; 0xc52c <MenuEnterRight+0x14>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    c602:	f9 01       	movw	r30, r18
    c604:	33 96       	adiw	r30, 0x03	; 3
    c606:	85 91       	lpm	r24, Z+
    c608:	95 91       	lpm	r25, Z+
    c60a:	a5 91       	lpm	r26, Z+
    c60c:	b4 91       	lpm	r27, Z+
			case Text: case EE_Text:
				if( (prd(&Field1->Min) == DIGIT) && (prd(&Field1->Max) == DIGIT) )
    c60e:	00 97       	sbiw	r24, 0x00	; 0
    c610:	a1 05       	cpc	r26, r1
    c612:	b1 05       	cpc	r27, r1
    c614:	59 f4       	brne	.+22     	; 0xc62c <MenuEnterRight+0x114>
    c616:	f9 01       	movw	r30, r18
    c618:	37 96       	adiw	r30, 0x07	; 7
    c61a:	85 91       	lpm	r24, Z+
    c61c:	95 91       	lpm	r25, Z+
    c61e:	a5 91       	lpm	r26, Z+
    c620:	b4 91       	lpm	r27, Z+
    c622:	00 97       	sbiw	r24, 0x00	; 0
    c624:	a1 05       	cpc	r26, r1
    c626:	b1 05       	cpc	r27, r1
    c628:	09 f4       	brne	.+2      	; 0xc62c <MenuEnterRight+0x114>
    c62a:	a3 c0       	rjmp	.+326    	; 0xc772 <MenuEnterRight+0x25a>
					MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[CurrFieldSize - 1 - CurrPos]);
				else MultiSymbol = GetMultiSymbol(Symbols_P, BufStr[CurrFieldSize - 1 - CurrPos]);
    c62c:	e0 91 c0 07 	lds	r30, 0x07C0
    c630:	f0 e0       	ldi	r31, 0x00	; 0
    c632:	31 97       	sbiw	r30, 0x01	; 1
    c634:	e0 1b       	sub	r30, r16
    c636:	f1 09       	sbc	r31, r1
    c638:	ed 53       	subi	r30, 0x3D	; 61
    c63a:	fa 4f       	sbci	r31, 0xFA	; 250
    c63c:	85 e0       	ldi	r24, 0x05	; 5
    c63e:	96 e0       	ldi	r25, 0x06	; 6
    c640:	60 81       	ld	r22, Z
    c642:	0e 94 42 4b 	call	0x9684	; 0x9684 <GetMultiSymbol>
    c646:	80 93 f4 04 	sts	0x04F4, r24
    c64a:	70 cf       	rjmp	.-288    	; 0xc52c <MenuEnterRight+0x14>
				break;		
			}
			return;
		}

		if(CurrField!=NullPos) {
    c64c:	80 91 d6 02 	lds	r24, 0x02D6
    c650:	8f 3f       	cpi	r24, 0xFF	; 255
    c652:	81 f0       	breq	.+32     	; 0xc674 <MenuEnterRight+0x15c>
			Buf2Field(Field+CurrField);
    c654:	90 e0       	ldi	r25, 0x00	; 0
    c656:	82 95       	swap	r24
    c658:	92 95       	swap	r25
    c65a:	90 7f       	andi	r25, 0xF0	; 240
    c65c:	98 27       	eor	r25, r24
    c65e:	80 7f       	andi	r24, 0xF0	; 240
    c660:	98 27       	eor	r25, r24
    c662:	8e 0d       	add	r24, r14
    c664:	9f 1d       	adc	r25, r15
    c666:	0e 94 2d 5f 	call	0xbe5a	; 0xbe5a <Buf2Field>
			if(CurrField==NullPos)
    c66a:	80 91 d6 02 	lds	r24, 0x02D6
    c66e:	8f 3f       	cpi	r24, 0xFF	; 255
    c670:	09 f4       	brne	.+2      	; 0xc674 <MenuEnterRight+0x15c>
    c672:	5c cf       	rjmp	.-328    	; 0xc52c <MenuEnterRight+0x14>
				return;
		}
		//     
		if(++CurrField==FieldNumber)
    c674:	8f 5f       	subi	r24, 0xFF	; 255
    c676:	80 93 d6 02 	sts	0x02D6, r24
    c67a:	18 17       	cp	r17, r24
    c67c:	d9 f1       	breq	.+118    	; 0xc6f4 <MenuEnterRight+0x1dc>
			CurrField=NullPos;
		else
			Field2Buf(Field+CurrField);
    c67e:	90 e0       	ldi	r25, 0x00	; 0
    c680:	82 95       	swap	r24
    c682:	92 95       	swap	r25
    c684:	90 7f       	andi	r25, 0xF0	; 240
    c686:	98 27       	eor	r25, r24
    c688:	80 7f       	andi	r24, 0xF0	; 240
    c68a:	98 27       	eor	r25, r24
    c68c:	8e 0d       	add	r24, r14
    c68e:	9f 1d       	adc	r25, r15
    c690:	0e 94 75 5b 	call	0xb6ea	; 0xb6ea <Field2Buf>
    c694:	40 91 d4 02 	lds	r20, 0x02D4
    c698:	50 91 d5 02 	lds	r21, 0x02D5
    c69c:	90 91 ca 07 	lds	r25, 0x07CA

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    c6a0:	4e 5f       	subi	r20, 0xFE	; 254
    c6a2:	5f 4f       	sbci	r21, 0xFF	; 255
    c6a4:	fa 01       	movw	r30, r20
    c6a6:	84 91       	lpm	r24, Z+
	}

// 3) Go to menu
	if( CurrLine >= prb(&CurrPage->LineNumber) )
    c6a8:	98 17       	cp	r25, r24
    c6aa:	08 f0       	brcs	.+2      	; 0xc6ae <MenuEnterRight+0x196>
    c6ac:	3f cf       	rjmp	.-386    	; 0xc52c <MenuEnterRight+0x14>
		return;

	if(NextPage || (NextPage=prp(&Line->InnPage))) {
    c6ae:	80 91 d9 05 	lds	r24, 0x05D9
    c6b2:	90 91 da 05 	lds	r25, 0x05DA
    c6b6:	00 97       	sbiw	r24, 0x00	; 0
    c6b8:	39 f1       	breq	.+78     	; 0xc708 <MenuEnterRight+0x1f0>
		GotoMenu(NextPage);
    c6ba:	0e 94 dc 45 	call	0x8bb8	; 0x8bb8 <GotoMenu>
		NextPage=NULL;
    c6be:	10 92 da 05 	sts	0x05DA, r1
    c6c2:	10 92 d9 05 	sts	0x05D9, r1
    c6c6:	32 cf       	rjmp	.-412    	; 0xc52c <MenuEnterRight+0x14>
		}

	//    
		if(CurrPos!=NullPos && --CurrPos!=NullPos){
			OutField *Field1=GetField;
			switch(prb(&Field1->Type)){
    c6c8:	89 31       	cpi	r24, 0x19	; 25
    c6ca:	20 f4       	brcc	.+8      	; 0xc6d4 <MenuEnterRight+0x1bc>
    c6cc:	80 51       	subi	r24, 0x10	; 16
    c6ce:	86 30       	cpi	r24, 0x06	; 6
    c6d0:	08 f0       	brcs	.+2      	; 0xc6d4 <MenuEnterRight+0x1bc>
    c6d2:	2c cf       	rjmp	.-424    	; 0xc52c <MenuEnterRight+0x14>
					MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[CurrFieldSize - 1 - CurrPos]);
				else MultiSymbol = GetMultiSymbol(Symbols_P, BufStr[CurrFieldSize - 1 - CurrPos]);
				break;
			case Longint: case z_Longint: case EE_Longint: case z_EE_Longint: case s_Longint: case s_EE_Longint:
			case FFloat: case EE_FFloat: case GFloat: case EE_GFloat:
				MultiSymbol = GetMultiSymbol(Digits_P, BufStr[CurrFieldSize - 1 - CurrPos]);
    c6d4:	e0 91 c0 07 	lds	r30, 0x07C0
    c6d8:	f0 e0       	ldi	r31, 0x00	; 0
    c6da:	31 97       	sbiw	r30, 0x01	; 1
    c6dc:	e0 1b       	sub	r30, r16
    c6de:	f1 09       	sbc	r31, r1
    c6e0:	ed 53       	subi	r30, 0x3D	; 61
    c6e2:	fa 4f       	sbci	r31, 0xFA	; 250
    c6e4:	8e ea       	ldi	r24, 0xAE	; 174
    c6e6:	96 e0       	ldi	r25, 0x06	; 6
    c6e8:	60 81       	ld	r22, Z
    c6ea:	0e 94 42 4b 	call	0x9684	; 0x9684 <GetMultiSymbol>
    c6ee:	80 93 f4 04 	sts	0x04F4, r24
    c6f2:	1c cf       	rjmp	.-456    	; 0xc52c <MenuEnterRight+0x14>
			if(CurrField==NullPos)
				return;
		}
		//     
		if(++CurrField==FieldNumber)
			CurrField=NullPos;
    c6f4:	8f ef       	ldi	r24, 0xFF	; 255
    c6f6:	80 93 d6 02 	sts	0x02D6, r24
    c6fa:	40 91 d4 02 	lds	r20, 0x02D4
    c6fe:	50 91 d5 02 	lds	r21, 0x02D5
    c702:	90 91 ca 07 	lds	r25, 0x07CA
    c706:	cc cf       	rjmp	.-104    	; 0xc6a0 <MenuEnterRight+0x188>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    c708:	fe 01       	movw	r30, r28
    c70a:	79 96       	adiw	r30, 0x19	; 25
    c70c:	85 91       	lpm	r24, Z+
    c70e:	94 91       	lpm	r25, Z+

// 3) Go to menu
	if( CurrLine >= prb(&CurrPage->LineNumber) )
		return;

	if(NextPage || (NextPage=prp(&Line->InnPage))) {
    c710:	90 93 da 05 	sts	0x05DA, r25
    c714:	80 93 d9 05 	sts	0x05D9, r24
    c718:	00 97       	sbiw	r24, 0x00	; 0
    c71a:	79 f6       	brne	.-98     	; 0xc6ba <MenuEnterRight+0x1a2>
    c71c:	07 cf       	rjmp	.-498    	; 0xc52c <MenuEnterRight+0x14>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    c71e:	f7 01       	movw	r30, r14
    c720:	84 91       	lpm	r24, Z+
			Char2 = prc(CurrStr+i++);
			if (Char2=='}' && Char1!='}')
				FieldNumber++;
		}
		//    Bit (:)   
		if(FieldNumber==1 && prb(&Field->Type)==Bit) {
    c722:	8f 31       	cpi	r24, 0x1F	; 31
    c724:	09 f0       	breq	.+2      	; 0xc728 <MenuEnterRight+0x210>
    c726:	43 cf       	rjmp	.-378    	; 0xc5ae <MenuEnterRight+0x96>
    c728:	8f e0       	ldi	r24, 0x0F	; 15
    c72a:	90 e0       	ldi	r25, 0x00	; 0
    c72c:	e8 0e       	add	r14, r24
    c72e:	f9 1e       	adc	r15, r25
    c730:	f7 01       	movw	r30, r14
    c732:	24 91       	lpm	r18, Z+
    c734:	81 ef       	ldi	r24, 0xF1	; 241
    c736:	9f ef       	ldi	r25, 0xFF	; 255
    c738:	e8 0e       	add	r14, r24
    c73a:	f9 1e       	adc	r15, r25

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    c73c:	c7 01       	movw	r24, r14
    c73e:	01 96       	adiw	r24, 0x01	; 1
    c740:	fc 01       	movw	r30, r24
    c742:	a5 91       	lpm	r26, Z+
    c744:	b4 91       	lpm	r27, Z+
			uint8_t BitN=prb(&Field->Prec);
			*((uint8_t*)prp(&Field->Var)+BitN/8) ^=(1<<BitN%8);
    c746:	82 2f       	mov	r24, r18
    c748:	86 95       	lsr	r24
    c74a:	86 95       	lsr	r24
    c74c:	86 95       	lsr	r24
    c74e:	a8 0f       	add	r26, r24
    c750:	b1 1d       	adc	r27, r1
    c752:	27 70       	andi	r18, 0x07	; 7
    c754:	81 e0       	ldi	r24, 0x01	; 1
    c756:	90 e0       	ldi	r25, 0x00	; 0
    c758:	02 c0       	rjmp	.+4      	; 0xc75e <MenuEnterRight+0x246>
    c75a:	88 0f       	add	r24, r24
    c75c:	99 1f       	adc	r25, r25
    c75e:	2a 95       	dec	r18
    c760:	e2 f7       	brpl	.-8      	; 0xc75a <MenuEnterRight+0x242>
    c762:	2c 91       	ld	r18, X
    c764:	28 27       	eor	r18, r24
    c766:	2c 93       	st	X, r18
			EventFunc(&Field->Act);
    c768:	c7 01       	movw	r24, r14
    c76a:	0b 96       	adiw	r24, 0x0b	; 11
    c76c:	0e 94 c2 45 	call	0x8b84	; 0x8b84 <EventFunc>
    c770:	dd ce       	rjmp	.-582    	; 0xc52c <MenuEnterRight+0x14>
		if(CurrPos!=NullPos && --CurrPos!=NullPos){
			OutField *Field1=GetField;
			switch(prb(&Field1->Type)){
			case Text: case EE_Text:
				if( (prd(&Field1->Min) == DIGIT) && (prd(&Field1->Max) == DIGIT) )
					MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[CurrFieldSize - 1 - CurrPos]);
    c772:	e0 91 c0 07 	lds	r30, 0x07C0
    c776:	f0 e0       	ldi	r31, 0x00	; 0
    c778:	31 97       	sbiw	r30, 0x01	; 1
    c77a:	e0 1b       	sub	r30, r16
    c77c:	f1 09       	sbc	r31, r1
    c77e:	ed 53       	subi	r30, 0x3D	; 61
    c780:	fa 4f       	sbci	r31, 0xFA	; 250
    c782:	83 ea       	ldi	r24, 0xA3	; 163
    c784:	96 e0       	ldi	r25, 0x06	; 6
    c786:	60 81       	ld	r22, Z
    c788:	0e 94 42 4b 	call	0x9684	; 0x9684 <GetMultiSymbol>
    c78c:	80 93 f4 04 	sts	0x04F4, r24
    c790:	cd ce       	rjmp	.-614    	; 0xc52c <MenuEnterRight+0x14>

0000c792 <MenuUD>:
	return Pos*Dir;
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
MenuUD(const MenuKey *Key, int8_t Dir, uint8_t LimLine, uint8_t LimLCD, uint8_t LimVar)
{
    c792:	af 92       	push	r10
    c794:	bf 92       	push	r11
    c796:	cf 92       	push	r12
    c798:	df 92       	push	r13
    c79a:	ef 92       	push	r14
    c79c:	ff 92       	push	r15
    c79e:	0f 93       	push	r16
    c7a0:	1f 93       	push	r17
    c7a2:	cf 93       	push	r28
    c7a4:	df 93       	push	r29
    c7a6:	fc 01       	movw	r30, r24
    c7a8:	e6 2e       	mov	r14, r22
    c7aa:	14 2f       	mov	r17, r20
    c7ac:	f2 2e       	mov	r15, r18
	if(CurrMsg || KeyFunc(Key))
    c7ae:	80 91 f5 04 	lds	r24, 0x04F5
    c7b2:	90 91 f6 04 	lds	r25, 0x04F6
    c7b6:	89 2b       	or	r24, r25
    c7b8:	59 f0       	breq	.+22     	; 0xc7d0 <MenuUD+0x3e>
		else 		{if(--MultiSymbol == 255) MultiSymbol = strlen_P(Digits_P)-1;}
		if(CurrPos!=NullPos)
			BufStr[CurrFieldSize - 1 - CurrPos] = prc(Digits_P + MultiSymbol);
		break;
	}
}
    c7ba:	df 91       	pop	r29
    c7bc:	cf 91       	pop	r28
    c7be:	1f 91       	pop	r17
    c7c0:	0f 91       	pop	r16
    c7c2:	ff 90       	pop	r15
    c7c4:	ef 90       	pop	r14
    c7c6:	df 90       	pop	r13
    c7c8:	cf 90       	pop	r12
    c7ca:	bf 90       	pop	r11
    c7cc:	af 90       	pop	r10
    c7ce:	08 95       	ret
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
MenuUD(const MenuKey *Key, int8_t Dir, uint8_t LimLine, uint8_t LimLCD, uint8_t LimVar)
{
	if(CurrMsg || KeyFunc(Key))
    c7d0:	cf 01       	movw	r24, r30
    c7d2:	0e 94 ca 45 	call	0x8b94	; 0x8b94 <KeyFunc>
    c7d6:	88 23       	and	r24, r24
    c7d8:	81 f7       	brne	.-32     	; 0xc7ba <MenuUD+0x28>
		return;
	if(CurrField==NullPos) {
    c7da:	30 91 d6 02 	lds	r19, 0x02D6
    c7de:	3f 3f       	cpi	r19, 0xFF	; 255
    c7e0:	09 f4       	brne	.+2      	; 0xc7e4 <MenuUD+0x52>
    c7e2:	48 c1       	rjmp	.+656    	; 0xca74 <MenuUD+0x2e2>
			if(LimLCD)
				CurrLCD -= Dir;
		}
		return;
	}
	Blink=0;
    c7e4:	10 92 18 09 	sts	0x0918, r1
    c7e8:	80 91 d4 02 	lds	r24, 0x02D4
    c7ec:	90 91 d5 02 	lds	r25, 0x02D5
    c7f0:	fc 01       	movw	r30, r24
    c7f2:	45 91       	lpm	r20, Z+
    c7f4:	54 91       	lpm	r21, Z+
	OutField *Field=GetField;
    c7f6:	80 91 ca 07 	lds	r24, 0x07CA
    c7fa:	2b e1       	ldi	r18, 0x1B	; 27
    c7fc:	82 9f       	mul	r24, r18
    c7fe:	c0 01       	movw	r24, r0
    c800:	11 24       	eor	r1, r1
    c802:	48 0f       	add	r20, r24
    c804:	59 1f       	adc	r21, r25
    c806:	49 5e       	subi	r20, 0xE9	; 233
    c808:	5f 4f       	sbci	r21, 0xFF	; 255
    c80a:	fa 01       	movw	r30, r20
    c80c:	c5 91       	lpm	r28, Z+
    c80e:	d4 91       	lpm	r29, Z+
    c810:	83 2f       	mov	r24, r19
    c812:	90 e0       	ldi	r25, 0x00	; 0
    c814:	82 95       	swap	r24
    c816:	92 95       	swap	r25
    c818:	90 7f       	andi	r25, 0xF0	; 240
    c81a:	98 27       	eor	r25, r24
    c81c:	80 7f       	andi	r24, 0xF0	; 240
    c81e:	98 27       	eor	r25, r24
    c820:	c8 0f       	add	r28, r24
    c822:	d9 1f       	adc	r29, r25

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    c824:	fe 01       	movw	r30, r28
    c826:	84 91       	lpm	r24, Z+
	switch(prb(&Field->Type)) {
    c828:	e8 2f       	mov	r30, r24
    c82a:	f0 e0       	ldi	r31, 0x00	; 0
    c82c:	e3 32       	cpi	r30, 0x23	; 35
    c82e:	f1 05       	cpc	r31, r1
    c830:	08 f0       	brcs	.+2      	; 0xc834 <MenuUD+0xa2>
    c832:	c3 cf       	rjmp	.-122    	; 0xc7ba <MenuUD+0x28>
    c834:	ea 54       	subi	r30, 0x4A	; 74
    c836:	ff 4f       	sbci	r31, 0xFF	; 255
    c838:	ee 0f       	add	r30, r30
    c83a:	ff 1f       	adc	r31, r31
    c83c:	05 90       	lpm	r0, Z+
    c83e:	f4 91       	lpm	r31, Z+
    c840:	e0 2d       	mov	r30, r0
    c842:	19 94       	eijmp

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    c844:	fe 01       	movw	r30, r28
    c846:	33 96       	adiw	r30, 0x03	; 3
    c848:	85 91       	lpm	r24, Z+
    c84a:	95 91       	lpm	r25, Z+
    c84c:	a5 91       	lpm	r26, Z+
    c84e:	b4 91       	lpm	r27, Z+
		break;
	case Bit: case EE_Bit:
		F_Buf = !F_Buf;
		break;
	case Text: case EE_Text:
		if( (prd(&Field->Min) == DIGIT) && (prd(&Field->Max) == DIGIT) ){
    c850:	00 97       	sbiw	r24, 0x00	; 0
    c852:	a1 05       	cpc	r26, r1
    c854:	b1 05       	cpc	r27, r1
    c856:	09 f0       	breq	.+2      	; 0xc85a <MenuUD+0xc8>
    c858:	1e c1       	rjmp	.+572    	; 0xca96 <MenuUD+0x304>
    c85a:	fe 01       	movw	r30, r28
    c85c:	37 96       	adiw	r30, 0x07	; 7
    c85e:	85 91       	lpm	r24, Z+
    c860:	95 91       	lpm	r25, Z+
    c862:	a5 91       	lpm	r26, Z+
    c864:	b4 91       	lpm	r27, Z+
    c866:	00 97       	sbiw	r24, 0x00	; 0
    c868:	a1 05       	cpc	r26, r1
    c86a:	b1 05       	cpc	r27, r1
    c86c:	09 f0       	breq	.+2      	; 0xc870 <MenuUD+0xde>
    c86e:	13 c1       	rjmp	.+550    	; 0xca96 <MenuUD+0x304>
			if(Dir==1){	if(++MultiSymbol > 9) MultiSymbol = 0;}
    c870:	31 e0       	ldi	r19, 0x01	; 1
    c872:	e3 16       	cp	r14, r19
    c874:	09 f4       	brne	.+2      	; 0xc878 <MenuUD+0xe6>
    c876:	92 c1       	rjmp	.+804    	; 0xcb9c <MenuUD+0x40a>
			else{		if(--MultiSymbol == 255) MultiSymbol = 9;}
    c878:	80 91 f4 04 	lds	r24, 0x04F4
    c87c:	81 50       	subi	r24, 0x01	; 1
    c87e:	80 93 f4 04 	sts	0x04F4, r24
    c882:	8f 3f       	cpi	r24, 0xFF	; 255
    c884:	09 f4       	brne	.+2      	; 0xc888 <MenuUD+0xf6>
    c886:	93 c1       	rjmp	.+806    	; 0xcbae <MenuUD+0x41c>
		}
		else{
			if(Dir==1){	if(++MultiSymbol >= strlen_P(Symbols_P)) MultiSymbol = 0;}
			else{		if(--MultiSymbol == 255) MultiSymbol = strlen_P(Symbols_P)-1;}
		}
		if(CurrPos!=NullPos)
    c888:	90 91 d7 02 	lds	r25, 0x02D7
    c88c:	9f 3f       	cpi	r25, 0xFF	; 255
    c88e:	09 f4       	brne	.+2      	; 0xc892 <MenuUD+0x100>
    c890:	94 cf       	rjmp	.-216    	; 0xc7ba <MenuUD+0x28>

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    c892:	80 91 f4 04 	lds	r24, 0x04F4
    c896:	e8 2f       	mov	r30, r24
    c898:	f0 e0       	ldi	r31, 0x00	; 0
    c89a:	eb 5f       	subi	r30, 0xFB	; 251
    c89c:	f9 4f       	sbci	r31, 0xF9	; 249
	case Longint: case z_Longint: case EE_Longint: case z_EE_Longint: case s_Longint: case s_EE_Longint:
	case FFloat: case EE_FFloat: case GFloat: case EE_GFloat:
		if(Dir==1)	{if(++MultiSymbol >= strlen_P(Digits_P)) MultiSymbol = 0;}
		else 		{if(--MultiSymbol == 255) MultiSymbol = strlen_P(Digits_P)-1;}
		if(CurrPos!=NullPos)
			BufStr[CurrFieldSize - 1 - CurrPos] = prc(Digits_P + MultiSymbol);
    c89e:	84 91       	lpm	r24, Z+
    c8a0:	e0 91 c0 07 	lds	r30, 0x07C0
    c8a4:	f0 e0       	ldi	r31, 0x00	; 0
    c8a6:	31 97       	sbiw	r30, 0x01	; 1
    c8a8:	e9 1b       	sub	r30, r25
    c8aa:	f1 09       	sbc	r31, r1
    c8ac:	ed 53       	subi	r30, 0x3D	; 61
    c8ae:	fa 4f       	sbci	r31, 0xFA	; 250
    c8b0:	80 83       	st	Z, r24
    c8b2:	83 cf       	rjmp	.-250    	; 0xc7ba <MenuUD+0x28>
	case Enum: case EE_Enum:
		if(LimVar)
			F_Buf += Dir;
		break;
	case Bit: case EE_Bit:
		F_Buf = !F_Buf;
    c8b4:	20 e0       	ldi	r18, 0x00	; 0
    c8b6:	30 e0       	ldi	r19, 0x00	; 0
    c8b8:	40 e0       	ldi	r20, 0x00	; 0
    c8ba:	50 e0       	ldi	r21, 0x00	; 0
    c8bc:	80 91 f7 04 	lds	r24, 0x04F7
    c8c0:	90 91 f8 04 	lds	r25, 0x04F8
    c8c4:	a0 91 f9 04 	lds	r26, 0x04F9
    c8c8:	b0 91 fa 04 	lds	r27, 0x04FA
    c8cc:	00 97       	sbiw	r24, 0x00	; 0
    c8ce:	a1 05       	cpc	r26, r1
    c8d0:	b1 05       	cpc	r27, r1
    c8d2:	21 f4       	brne	.+8      	; 0xc8dc <MenuUD+0x14a>
    c8d4:	21 e0       	ldi	r18, 0x01	; 1
    c8d6:	30 e0       	ldi	r19, 0x00	; 0
    c8d8:	40 e0       	ldi	r20, 0x00	; 0
    c8da:	50 e0       	ldi	r21, 0x00	; 0
    c8dc:	20 93 f7 04 	sts	0x04F7, r18
    c8e0:	30 93 f8 04 	sts	0x04F8, r19
    c8e4:	40 93 f9 04 	sts	0x04F9, r20
    c8e8:	50 93 fa 04 	sts	0x04FA, r21
    c8ec:	66 cf       	rjmp	.-308    	; 0xc7ba <MenuUD+0x28>
			Buf2Field(Field);
			Field2Buf(Field);
		}
		break;
	case Enum: case EE_Enum:
		if(LimVar)
    c8ee:	00 23       	and	r16, r16
    c8f0:	09 f4       	brne	.+2      	; 0xc8f4 <MenuUD+0x162>
    c8f2:	63 cf       	rjmp	.-314    	; 0xc7ba <MenuUD+0x28>
			F_Buf += Dir;
    c8f4:	2e 2d       	mov	r18, r14
    c8f6:	33 27       	eor	r19, r19
    c8f8:	27 fd       	sbrc	r18, 7
    c8fa:	30 95       	com	r19
    c8fc:	43 2f       	mov	r20, r19
    c8fe:	53 2f       	mov	r21, r19
    c900:	80 91 f7 04 	lds	r24, 0x04F7
    c904:	90 91 f8 04 	lds	r25, 0x04F8
    c908:	a0 91 f9 04 	lds	r26, 0x04F9
    c90c:	b0 91 fa 04 	lds	r27, 0x04FA
    c910:	82 0f       	add	r24, r18
    c912:	93 1f       	adc	r25, r19
    c914:	a4 1f       	adc	r26, r20
    c916:	b5 1f       	adc	r27, r21
    c918:	80 93 f7 04 	sts	0x04F7, r24
    c91c:	90 93 f8 04 	sts	0x04F8, r25
    c920:	a0 93 f9 04 	sts	0x04F9, r26
    c924:	b0 93 fa 04 	sts	0x04FA, r27
    c928:	48 cf       	rjmp	.-368    	; 0xc7ba <MenuUD+0x28>
		if(CurrPos!=NullPos)
			BufStr[CurrFieldSize - 1 - CurrPos] = prc(Symbols_P + MultiSymbol);
		break;
	case Longint: case z_Longint: case EE_Longint: case z_EE_Longint: case s_Longint: case s_EE_Longint:
	case FFloat: case EE_FFloat: case GFloat: case EE_GFloat:
		if(Dir==1)	{if(++MultiSymbol >= strlen_P(Digits_P)) MultiSymbol = 0;}
    c92a:	51 e0       	ldi	r21, 0x01	; 1
    c92c:	e5 16       	cp	r14, r21
    c92e:	09 f4       	brne	.+2      	; 0xc932 <MenuUD+0x1a0>
    c930:	fb c0       	rjmp	.+502    	; 0xcb28 <MenuUD+0x396>
		else 		{if(--MultiSymbol == 255) MultiSymbol = strlen_P(Digits_P)-1;}
    c932:	80 91 f4 04 	lds	r24, 0x04F4
    c936:	81 50       	subi	r24, 0x01	; 1
    c938:	80 93 f4 04 	sts	0x04F4, r24
    c93c:	8f 3f       	cpi	r24, 0xFF	; 255
    c93e:	09 f4       	brne	.+2      	; 0xc942 <MenuUD+0x1b0>
    c940:	14 c1       	rjmp	.+552    	; 0xcb6a <MenuUD+0x3d8>
		if(CurrPos!=NullPos)
    c942:	90 91 d7 02 	lds	r25, 0x02D7
    c946:	9f 3f       	cpi	r25, 0xFF	; 255
    c948:	09 f4       	brne	.+2      	; 0xc94c <MenuUD+0x1ba>
    c94a:	37 cf       	rjmp	.-402    	; 0xc7ba <MenuUD+0x28>
    c94c:	80 91 f4 04 	lds	r24, 0x04F4
    c950:	e8 2f       	mov	r30, r24
    c952:	f0 e0       	ldi	r31, 0x00	; 0
    c954:	e2 55       	subi	r30, 0x52	; 82
    c956:	f9 4f       	sbci	r31, 0xF9	; 249
    c958:	a2 cf       	rjmp	.-188    	; 0xc89e <MenuUD+0x10c>
			sF_Buf += Inc(Dir, sF_Buf);
		else if(sF_Buf<0 || sF_Buf==0 && Minus)
			Minus = (sF_Buf-=Inc(Dir, -sF_Buf))==0;
		break;
	case c_Word: case zc_Word:
		if(LimVar) {
    c95a:	00 23       	and	r16, r16
    c95c:	09 f4       	brne	.+2      	; 0xc960 <MenuUD+0x1ce>
    c95e:	2d cf       	rjmp	.-422    	; 0xc7ba <MenuUD+0x28>
			F_Buf += Dir;
    c960:	2e 2d       	mov	r18, r14
    c962:	33 27       	eor	r19, r19
    c964:	27 fd       	sbrc	r18, 7
    c966:	30 95       	com	r19
    c968:	43 2f       	mov	r20, r19
    c96a:	53 2f       	mov	r21, r19
    c96c:	80 91 f7 04 	lds	r24, 0x04F7
    c970:	90 91 f8 04 	lds	r25, 0x04F8
    c974:	a0 91 f9 04 	lds	r26, 0x04F9
    c978:	b0 91 fa 04 	lds	r27, 0x04FA
    c97c:	82 0f       	add	r24, r18
    c97e:	93 1f       	adc	r25, r19
    c980:	a4 1f       	adc	r26, r20
    c982:	b5 1f       	adc	r27, r21
    c984:	80 93 f7 04 	sts	0x04F7, r24
    c988:	90 93 f8 04 	sts	0x04F8, r25
    c98c:	a0 93 f9 04 	sts	0x04F9, r26
    c990:	b0 93 fa 04 	sts	0x04FA, r27
			Buf2Field(Field);
    c994:	ce 01       	movw	r24, r28
    c996:	0e 94 2d 5f 	call	0xbe5a	; 0xbe5a <Buf2Field>
			Field2Buf(Field);
    c99a:	ce 01       	movw	r24, r28
    c99c:	0e 94 75 5b 	call	0xb6ea	; 0xb6ea <Field2Buf>
    c9a0:	0c cf       	rjmp	.-488    	; 0xc7ba <MenuUD+0x28>
	case Word: case EE_Word: case z_Word: case z_EE_Word:
		F_Buf += Inc(Dir, F_Buf);
		break;
	case s_Byte: case s_EE_Byte:
	case s_Word: case s_EE_Word:
		if(CurrPos==Log10(prd(&Field->Max))+1) {
    c9a2:	00 91 d7 02 	lds	r16, 0x02D7
    c9a6:	10 e0       	ldi	r17, 0x00	; 0

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    c9a8:	fe 01       	movw	r30, r28
    c9aa:	37 96       	adiw	r30, 0x07	; 7
    c9ac:	65 91       	lpm	r22, Z+
    c9ae:	75 91       	lpm	r23, Z+
    c9b0:	85 91       	lpm	r24, Z+
    c9b2:	94 91       	lpm	r25, Z+
    c9b4:	0e 94 48 2a 	call	0x5490	; 0x5490 <Log10>
    c9b8:	90 e0       	ldi	r25, 0x00	; 0
    c9ba:	01 96       	adiw	r24, 0x01	; 1
    c9bc:	08 17       	cp	r16, r24
    c9be:	19 07       	cpc	r17, r25
    c9c0:	09 f4       	brne	.+2      	; 0xc9c4 <MenuUD+0x232>
    c9c2:	9c c0       	rjmp	.+312    	; 0xcafc <MenuUD+0x36a>
			if(sF_Buf==0)
				Minus = !Minus;
			else
				sF_Buf = -sF_Buf;
		}
		else if(sF_Buf>0 || sF_Buf==0 && !Minus)
    c9c4:	a0 90 fb 04 	lds	r10, 0x04FB
    c9c8:	b0 90 fc 04 	lds	r11, 0x04FC
    c9cc:	c0 90 fd 04 	lds	r12, 0x04FD
    c9d0:	d0 90 fe 04 	lds	r13, 0x04FE
    c9d4:	1a 14       	cp	r1, r10
    c9d6:	1b 04       	cpc	r1, r11
    c9d8:	1c 04       	cpc	r1, r12
    c9da:	1d 04       	cpc	r1, r13
    c9dc:	0c f4       	brge	.+2      	; 0xc9e0 <MenuUD+0x24e>
    c9de:	74 c0       	rjmp	.+232    	; 0xcac8 <MenuUD+0x336>
    c9e0:	a1 14       	cp	r10, r1
    c9e2:	b1 04       	cpc	r11, r1
    c9e4:	c1 04       	cpc	r12, r1
    c9e6:	d1 04       	cpc	r13, r1
    c9e8:	09 f4       	brne	.+2      	; 0xc9ec <MenuUD+0x25a>
    c9ea:	69 c0       	rjmp	.+210    	; 0xcabe <MenuUD+0x32c>
			sF_Buf += Inc(Dir, sF_Buf);
		else if(sF_Buf<0 || sF_Buf==0 && Minus)
			Minus = (sF_Buf-=Inc(Dir, -sF_Buf))==0;
    c9ec:	44 27       	eor	r20, r20
    c9ee:	55 27       	eor	r21, r21
    c9f0:	ba 01       	movw	r22, r20
    c9f2:	4a 19       	sub	r20, r10
    c9f4:	5b 09       	sbc	r21, r11
    c9f6:	6c 09       	sbc	r22, r12
    c9f8:	7d 09       	sbc	r23, r13
    c9fa:	8e 2d       	mov	r24, r14
    c9fc:	0e 94 a1 46 	call	0x8d42	; 0x8d42 <Inc>
    ca00:	a6 01       	movw	r20, r12
    ca02:	95 01       	movw	r18, r10
    ca04:	26 1b       	sub	r18, r22
    ca06:	37 0b       	sbc	r19, r23
    ca08:	48 0b       	sbc	r20, r24
    ca0a:	59 0b       	sbc	r21, r25
    ca0c:	20 93 fb 04 	sts	0x04FB, r18
    ca10:	30 93 fc 04 	sts	0x04FC, r19
    ca14:	40 93 fd 04 	sts	0x04FD, r20
    ca18:	50 93 fe 04 	sts	0x04FE, r21
    ca1c:	10 92 ff 04 	sts	0x04FF, r1
    ca20:	21 15       	cp	r18, r1
    ca22:	31 05       	cpc	r19, r1
    ca24:	41 05       	cpc	r20, r1
    ca26:	51 05       	cpc	r21, r1
    ca28:	09 f0       	breq	.+2      	; 0xca2c <MenuUD+0x29a>
    ca2a:	c7 ce       	rjmp	.-626    	; 0xc7ba <MenuUD+0x28>
    ca2c:	81 e0       	ldi	r24, 0x01	; 1
    ca2e:	80 93 ff 04 	sts	0x04FF, r24
    ca32:	c3 ce       	rjmp	.-634    	; 0xc7ba <MenuUD+0x28>
	Blink=0;
	OutField *Field=GetField;
	switch(prb(&Field->Type)) {
	case Byte: case EE_Byte: case z_Byte: case z_EE_Byte:
	case Word: case EE_Word: case z_Word: case z_EE_Word:
		F_Buf += Inc(Dir, F_Buf);
    ca34:	40 91 f7 04 	lds	r20, 0x04F7
    ca38:	50 91 f8 04 	lds	r21, 0x04F8
    ca3c:	60 91 f9 04 	lds	r22, 0x04F9
    ca40:	70 91 fa 04 	lds	r23, 0x04FA
    ca44:	8e 2d       	mov	r24, r14
    ca46:	0e 94 a1 46 	call	0x8d42	; 0x8d42 <Inc>
    ca4a:	20 91 f7 04 	lds	r18, 0x04F7
    ca4e:	30 91 f8 04 	lds	r19, 0x04F8
    ca52:	40 91 f9 04 	lds	r20, 0x04F9
    ca56:	50 91 fa 04 	lds	r21, 0x04FA
    ca5a:	26 0f       	add	r18, r22
    ca5c:	37 1f       	adc	r19, r23
    ca5e:	48 1f       	adc	r20, r24
    ca60:	59 1f       	adc	r21, r25
    ca62:	20 93 f7 04 	sts	0x04F7, r18
    ca66:	30 93 f8 04 	sts	0x04F8, r19
    ca6a:	40 93 f9 04 	sts	0x04F9, r20
    ca6e:	50 93 fa 04 	sts	0x04FA, r21
    ca72:	a3 ce       	rjmp	.-698    	; 0xc7ba <MenuUD+0x28>
MenuUD(const MenuKey *Key, int8_t Dir, uint8_t LimLine, uint8_t LimLCD, uint8_t LimVar)
{
	if(CurrMsg || KeyFunc(Key))
		return;
	if(CurrField==NullPos) {
		if(LimLine) {
    ca74:	11 23       	and	r17, r17
    ca76:	09 f4       	brne	.+2      	; 0xca7a <MenuUD+0x2e8>
    ca78:	a0 ce       	rjmp	.-704    	; 0xc7ba <MenuUD+0x28>
			CurrLine -= Dir;
    ca7a:	80 91 ca 07 	lds	r24, 0x07CA
    ca7e:	8e 19       	sub	r24, r14
    ca80:	80 93 ca 07 	sts	0x07CA, r24
			if(LimLCD)
    ca84:	ff 20       	and	r15, r15
    ca86:	09 f4       	brne	.+2      	; 0xca8a <MenuUD+0x2f8>
    ca88:	98 ce       	rjmp	.-720    	; 0xc7ba <MenuUD+0x28>
				CurrLCD -= Dir;
    ca8a:	80 91 e8 08 	lds	r24, 0x08E8
    ca8e:	8e 19       	sub	r24, r14
    ca90:	80 93 e8 08 	sts	0x08E8, r24
    ca94:	92 ce       	rjmp	.-732    	; 0xc7ba <MenuUD+0x28>
		if( (prd(&Field->Min) == DIGIT) && (prd(&Field->Max) == DIGIT) ){
			if(Dir==1){	if(++MultiSymbol > 9) MultiSymbol = 0;}
			else{		if(--MultiSymbol == 255) MultiSymbol = 9;}
		}
		else{
			if(Dir==1){	if(++MultiSymbol >= strlen_P(Symbols_P)) MultiSymbol = 0;}
    ca96:	41 e0       	ldi	r20, 0x01	; 1
    ca98:	e4 16       	cp	r14, r20
    ca9a:	09 f4       	brne	.+2      	; 0xca9e <MenuUD+0x30c>
    ca9c:	6e c0       	rjmp	.+220    	; 0xcb7a <MenuUD+0x3e8>
			else{		if(--MultiSymbol == 255) MultiSymbol = strlen_P(Symbols_P)-1;}
    ca9e:	80 91 f4 04 	lds	r24, 0x04F4
    caa2:	81 50       	subi	r24, 0x01	; 1
    caa4:	80 93 f4 04 	sts	0x04F4, r24
    caa8:	8f 3f       	cpi	r24, 0xFF	; 255
    caaa:	09 f0       	breq	.+2      	; 0xcaae <MenuUD+0x31c>
    caac:	ed ce       	rjmp	.-550    	; 0xc888 <MenuUD+0xf6>
    caae:	85 e0       	ldi	r24, 0x05	; 5
    cab0:	96 e0       	ldi	r25, 0x06	; 6
    cab2:	0e 94 03 8b 	call	0x11606	; 0x11606 <strlen_P>
    cab6:	81 50       	subi	r24, 0x01	; 1
    cab8:	80 93 f4 04 	sts	0x04F4, r24
    cabc:	e5 ce       	rjmp	.-566    	; 0xc888 <MenuUD+0xf6>
			if(sF_Buf==0)
				Minus = !Minus;
			else
				sF_Buf = -sF_Buf;
		}
		else if(sF_Buf>0 || sF_Buf==0 && !Minus)
    cabe:	80 91 ff 04 	lds	r24, 0x04FF
    cac2:	88 23       	and	r24, r24
    cac4:	09 f0       	breq	.+2      	; 0xcac8 <MenuUD+0x336>
    cac6:	92 cf       	rjmp	.-220    	; 0xc9ec <MenuUD+0x25a>
			sF_Buf += Inc(Dir, sF_Buf);
    cac8:	8e 2d       	mov	r24, r14
    caca:	b6 01       	movw	r22, r12
    cacc:	a5 01       	movw	r20, r10
    cace:	0e 94 a1 46 	call	0x8d42	; 0x8d42 <Inc>
    cad2:	20 91 fb 04 	lds	r18, 0x04FB
    cad6:	30 91 fc 04 	lds	r19, 0x04FC
    cada:	40 91 fd 04 	lds	r20, 0x04FD
    cade:	50 91 fe 04 	lds	r21, 0x04FE
    cae2:	26 0f       	add	r18, r22
    cae4:	37 1f       	adc	r19, r23
    cae6:	48 1f       	adc	r20, r24
    cae8:	59 1f       	adc	r21, r25
    caea:	20 93 fb 04 	sts	0x04FB, r18
    caee:	30 93 fc 04 	sts	0x04FC, r19
    caf2:	40 93 fd 04 	sts	0x04FD, r20
    caf6:	50 93 fe 04 	sts	0x04FE, r21
    cafa:	5f ce       	rjmp	.-834    	; 0xc7ba <MenuUD+0x28>
		F_Buf += Inc(Dir, F_Buf);
		break;
	case s_Byte: case s_EE_Byte:
	case s_Word: case s_EE_Word:
		if(CurrPos==Log10(prd(&Field->Max))+1) {
			if(sF_Buf==0)
    cafc:	20 91 fb 04 	lds	r18, 0x04FB
    cb00:	30 91 fc 04 	lds	r19, 0x04FC
    cb04:	40 91 fd 04 	lds	r20, 0x04FD
    cb08:	50 91 fe 04 	lds	r21, 0x04FE
    cb0c:	21 15       	cp	r18, r1
    cb0e:	31 05       	cpc	r19, r1
    cb10:	41 05       	cpc	r20, r1
    cb12:	51 05       	cpc	r21, r1
    cb14:	d1 f4       	brne	.+52     	; 0xcb4a <MenuUD+0x3b8>
				Minus = !Minus;
    cb16:	90 e0       	ldi	r25, 0x00	; 0
    cb18:	80 91 ff 04 	lds	r24, 0x04FF
    cb1c:	88 23       	and	r24, r24
    cb1e:	09 f4       	brne	.+2      	; 0xcb22 <MenuUD+0x390>
    cb20:	91 e0       	ldi	r25, 0x01	; 1
    cb22:	90 93 ff 04 	sts	0x04FF, r25
    cb26:	49 ce       	rjmp	.-878    	; 0xc7ba <MenuUD+0x28>
		if(CurrPos!=NullPos)
			BufStr[CurrFieldSize - 1 - CurrPos] = prc(Symbols_P + MultiSymbol);
		break;
	case Longint: case z_Longint: case EE_Longint: case z_EE_Longint: case s_Longint: case s_EE_Longint:
	case FFloat: case EE_FFloat: case GFloat: case EE_GFloat:
		if(Dir==1)	{if(++MultiSymbol >= strlen_P(Digits_P)) MultiSymbol = 0;}
    cb28:	00 91 f4 04 	lds	r16, 0x04F4
    cb2c:	0f 5f       	subi	r16, 0xFF	; 255
    cb2e:	00 93 f4 04 	sts	0x04F4, r16
    cb32:	8e ea       	ldi	r24, 0xAE	; 174
    cb34:	96 e0       	ldi	r25, 0x06	; 6
    cb36:	0e 94 03 8b 	call	0x11606	; 0x11606 <strlen_P>
    cb3a:	10 e0       	ldi	r17, 0x00	; 0
    cb3c:	08 17       	cp	r16, r24
    cb3e:	19 07       	cpc	r17, r25
    cb40:	08 f4       	brcc	.+2      	; 0xcb44 <MenuUD+0x3b2>
    cb42:	ff ce       	rjmp	.-514    	; 0xc942 <MenuUD+0x1b0>
    cb44:	10 92 f4 04 	sts	0x04F4, r1
    cb48:	fc ce       	rjmp	.-520    	; 0xc942 <MenuUD+0x1b0>
	case s_Word: case s_EE_Word:
		if(CurrPos==Log10(prd(&Field->Max))+1) {
			if(sF_Buf==0)
				Minus = !Minus;
			else
				sF_Buf = -sF_Buf;
    cb4a:	88 27       	eor	r24, r24
    cb4c:	99 27       	eor	r25, r25
    cb4e:	dc 01       	movw	r26, r24
    cb50:	82 1b       	sub	r24, r18
    cb52:	93 0b       	sbc	r25, r19
    cb54:	a4 0b       	sbc	r26, r20
    cb56:	b5 0b       	sbc	r27, r21
    cb58:	80 93 fb 04 	sts	0x04FB, r24
    cb5c:	90 93 fc 04 	sts	0x04FC, r25
    cb60:	a0 93 fd 04 	sts	0x04FD, r26
    cb64:	b0 93 fe 04 	sts	0x04FE, r27
    cb68:	28 ce       	rjmp	.-944    	; 0xc7ba <MenuUD+0x28>
			BufStr[CurrFieldSize - 1 - CurrPos] = prc(Symbols_P + MultiSymbol);
		break;
	case Longint: case z_Longint: case EE_Longint: case z_EE_Longint: case s_Longint: case s_EE_Longint:
	case FFloat: case EE_FFloat: case GFloat: case EE_GFloat:
		if(Dir==1)	{if(++MultiSymbol >= strlen_P(Digits_P)) MultiSymbol = 0;}
		else 		{if(--MultiSymbol == 255) MultiSymbol = strlen_P(Digits_P)-1;}
    cb6a:	8e ea       	ldi	r24, 0xAE	; 174
    cb6c:	96 e0       	ldi	r25, 0x06	; 6
    cb6e:	0e 94 03 8b 	call	0x11606	; 0x11606 <strlen_P>
    cb72:	81 50       	subi	r24, 0x01	; 1
    cb74:	80 93 f4 04 	sts	0x04F4, r24
    cb78:	e4 ce       	rjmp	.-568    	; 0xc942 <MenuUD+0x1b0>
		if( (prd(&Field->Min) == DIGIT) && (prd(&Field->Max) == DIGIT) ){
			if(Dir==1){	if(++MultiSymbol > 9) MultiSymbol = 0;}
			else{		if(--MultiSymbol == 255) MultiSymbol = 9;}
		}
		else{
			if(Dir==1){	if(++MultiSymbol >= strlen_P(Symbols_P)) MultiSymbol = 0;}
    cb7a:	00 91 f4 04 	lds	r16, 0x04F4
    cb7e:	0f 5f       	subi	r16, 0xFF	; 255
    cb80:	00 93 f4 04 	sts	0x04F4, r16
    cb84:	85 e0       	ldi	r24, 0x05	; 5
    cb86:	96 e0       	ldi	r25, 0x06	; 6
    cb88:	0e 94 03 8b 	call	0x11606	; 0x11606 <strlen_P>
    cb8c:	10 e0       	ldi	r17, 0x00	; 0
    cb8e:	08 17       	cp	r16, r24
    cb90:	19 07       	cpc	r17, r25
    cb92:	08 f4       	brcc	.+2      	; 0xcb96 <MenuUD+0x404>
    cb94:	79 ce       	rjmp	.-782    	; 0xc888 <MenuUD+0xf6>
    cb96:	10 92 f4 04 	sts	0x04F4, r1
    cb9a:	76 ce       	rjmp	.-788    	; 0xc888 <MenuUD+0xf6>
	case Bit: case EE_Bit:
		F_Buf = !F_Buf;
		break;
	case Text: case EE_Text:
		if( (prd(&Field->Min) == DIGIT) && (prd(&Field->Max) == DIGIT) ){
			if(Dir==1){	if(++MultiSymbol > 9) MultiSymbol = 0;}
    cb9c:	80 91 f4 04 	lds	r24, 0x04F4
    cba0:	8f 5f       	subi	r24, 0xFF	; 255
    cba2:	80 93 f4 04 	sts	0x04F4, r24
    cba6:	8a 30       	cpi	r24, 0x0A	; 10
    cba8:	08 f4       	brcc	.+2      	; 0xcbac <MenuUD+0x41a>
    cbaa:	6e ce       	rjmp	.-804    	; 0xc888 <MenuUD+0xf6>
    cbac:	f4 cf       	rjmp	.-24     	; 0xcb96 <MenuUD+0x404>
			else{		if(--MultiSymbol == 255) MultiSymbol = 9;}
    cbae:	89 e0       	ldi	r24, 0x09	; 9
    cbb0:	80 93 f4 04 	sts	0x04F4, r24
    cbb4:	69 ce       	rjmp	.-814    	; 0xc888 <MenuUD+0xf6>

0000cbb6 <MenuDown>:
}

// ~~~~~~~~~~~
void
MenuDown(void)
{
    cbb6:	ef 92       	push	r14
    cbb8:	ff 92       	push	r15
    cbba:	0f 93       	push	r16
    cbbc:	1f 93       	push	r17
    cbbe:	cf 93       	push	r28
    cbc0:	df 93       	push	r29
	MenuUD(&CurrPage->Down, -1, prb(&CurrPage->LineNumber)-CurrLine>1, CurrLCD<LCDYSz-1, F_Buf>prd(&GetField->Min));
    cbc2:	c0 91 d4 02 	lds	r28, 0x02D4
    cbc6:	d0 91 d5 02 	lds	r29, 0x02D5

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    cbca:	22 96       	adiw	r28, 0x02	; 2
    cbcc:	fe 01       	movw	r30, r28
    cbce:	24 91       	lpm	r18, Z+
    cbd0:	22 97       	sbiw	r28, 0x02	; 2
    cbd2:	40 91 ca 07 	lds	r20, 0x07CA

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    cbd6:	fe 01       	movw	r30, r28
    cbd8:	65 91       	lpm	r22, Z+
    cbda:	74 91       	lpm	r23, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    cbdc:	8b e1       	ldi	r24, 0x1B	; 27
    cbde:	48 9f       	mul	r20, r24
    cbe0:	c0 01       	movw	r24, r0
    cbe2:	11 24       	eor	r1, r1
    cbe4:	68 0f       	add	r22, r24
    cbe6:	79 1f       	adc	r23, r25
    cbe8:	69 5e       	subi	r22, 0xE9	; 233
    cbea:	7f 4f       	sbci	r23, 0xFF	; 255
    cbec:	fb 01       	movw	r30, r22
    cbee:	a5 91       	lpm	r26, Z+
    cbf0:	b4 91       	lpm	r27, Z+
    cbf2:	80 91 d6 02 	lds	r24, 0x02D6
    cbf6:	90 e0       	ldi	r25, 0x00	; 0
    cbf8:	82 95       	swap	r24
    cbfa:	92 95       	swap	r25
    cbfc:	90 7f       	andi	r25, 0xF0	; 240
    cbfe:	98 27       	eor	r25, r24
    cc00:	80 7f       	andi	r24, 0xF0	; 240
    cc02:	98 27       	eor	r25, r24
    cc04:	a8 0f       	add	r26, r24
    cc06:	b9 1f       	adc	r27, r25
    cc08:	13 96       	adiw	r26, 0x03	; 3
    cc0a:	fd 01       	movw	r30, r26
    cc0c:	e5 90       	lpm	r14, Z+
    cc0e:	f5 90       	lpm	r15, Z+
    cc10:	05 91       	lpm	r16, Z+
    cc12:	14 91       	lpm	r17, Z+
    cc14:	fe 01       	movw	r30, r28
    cc16:	72 96       	adiw	r30, 0x12	; 18
    cc18:	50 e0       	ldi	r21, 0x00	; 0
    cc1a:	30 e0       	ldi	r19, 0x00	; 0
    cc1c:	24 1b       	sub	r18, r20
    cc1e:	31 09       	sbc	r19, r1
    cc20:	22 30       	cpi	r18, 0x02	; 2
    cc22:	31 05       	cpc	r19, r1
    cc24:	0c f0       	brlt	.+2      	; 0xcc28 <MenuDown+0x72>
    cc26:	51 e0       	ldi	r21, 0x01	; 1
    cc28:	20 e0       	ldi	r18, 0x00	; 0
    cc2a:	80 91 e8 08 	lds	r24, 0x08E8
    cc2e:	83 30       	cpi	r24, 0x03	; 3
    cc30:	08 f4       	brcc	.+2      	; 0xcc34 <MenuDown+0x7e>
    cc32:	21 e0       	ldi	r18, 0x01	; 1
    cc34:	30 e0       	ldi	r19, 0x00	; 0
    cc36:	80 91 f7 04 	lds	r24, 0x04F7
    cc3a:	90 91 f8 04 	lds	r25, 0x04F8
    cc3e:	a0 91 f9 04 	lds	r26, 0x04F9
    cc42:	b0 91 fa 04 	lds	r27, 0x04FA
    cc46:	e8 16       	cp	r14, r24
    cc48:	f9 06       	cpc	r15, r25
    cc4a:	0a 07       	cpc	r16, r26
    cc4c:	1b 07       	cpc	r17, r27
    cc4e:	08 f4       	brcc	.+2      	; 0xcc52 <MenuDown+0x9c>
    cc50:	31 e0       	ldi	r19, 0x01	; 1
    cc52:	cf 01       	movw	r24, r30
    cc54:	6f ef       	ldi	r22, 0xFF	; 255
    cc56:	45 2f       	mov	r20, r21
    cc58:	03 2f       	mov	r16, r19
    cc5a:	0e 94 c9 63 	call	0xc792	; 0xc792 <MenuUD>
}
    cc5e:	df 91       	pop	r29
    cc60:	cf 91       	pop	r28
    cc62:	1f 91       	pop	r17
    cc64:	0f 91       	pop	r16
    cc66:	ff 90       	pop	r15
    cc68:	ef 90       	pop	r14
    cc6a:	08 95       	ret

0000cc6c <MenuUp>:
}

// ~~~~~~~~~
void
MenuUp(void)
{
    cc6c:	ef 92       	push	r14
    cc6e:	ff 92       	push	r15
    cc70:	0f 93       	push	r16
    cc72:	1f 93       	push	r17
	uint8_t Fix=GetFix();
    cc74:	a0 91 d4 02 	lds	r26, 0x02D4
    cc78:	b0 91 d5 02 	lds	r27, 0x02D5

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    cc7c:	13 96       	adiw	r26, 0x03	; 3
    cc7e:	fd 01       	movw	r30, r26
    cc80:	34 91       	lpm	r19, Z+
    cc82:	13 97       	sbiw	r26, 0x03	; 3
	MenuUD(&CurrPage->Up, 1, CurrLine>Fix, CurrLCD>Fix, F_Buf<prd(&GetField->Max));
    cc84:	20 91 ca 07 	lds	r18, 0x07CA

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    cc88:	fd 01       	movw	r30, r26
    cc8a:	45 91       	lpm	r20, Z+
    cc8c:	54 91       	lpm	r21, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    cc8e:	8b e1       	ldi	r24, 0x1B	; 27
    cc90:	28 9f       	mul	r18, r24
    cc92:	c0 01       	movw	r24, r0
    cc94:	11 24       	eor	r1, r1
    cc96:	48 0f       	add	r20, r24
    cc98:	59 1f       	adc	r21, r25
    cc9a:	49 5e       	subi	r20, 0xE9	; 233
    cc9c:	5f 4f       	sbci	r21, 0xFF	; 255
    cc9e:	fa 01       	movw	r30, r20
    cca0:	65 91       	lpm	r22, Z+
    cca2:	74 91       	lpm	r23, Z+
    cca4:	80 91 d6 02 	lds	r24, 0x02D6
    cca8:	90 e0       	ldi	r25, 0x00	; 0
    ccaa:	82 95       	swap	r24
    ccac:	92 95       	swap	r25
    ccae:	90 7f       	andi	r25, 0xF0	; 240
    ccb0:	98 27       	eor	r25, r24
    ccb2:	80 7f       	andi	r24, 0xF0	; 240
    ccb4:	98 27       	eor	r25, r24
    ccb6:	68 0f       	add	r22, r24
    ccb8:	79 1f       	adc	r23, r25
    ccba:	69 5f       	subi	r22, 0xF9	; 249
    ccbc:	7f 4f       	sbci	r23, 0xFF	; 255
    ccbe:	fb 01       	movw	r30, r22
    ccc0:	e5 90       	lpm	r14, Z+
    ccc2:	f5 90       	lpm	r15, Z+
    ccc4:	05 91       	lpm	r16, Z+
    ccc6:	14 91       	lpm	r17, Z+
    ccc8:	fd 01       	movw	r30, r26
    ccca:	70 96       	adiw	r30, 0x10	; 16
    cccc:	40 e0       	ldi	r20, 0x00	; 0
    ccce:	32 17       	cp	r19, r18
    ccd0:	08 f4       	brcc	.+2      	; 0xccd4 <MenuUp+0x68>
    ccd2:	41 e0       	ldi	r20, 0x01	; 1
    ccd4:	20 e0       	ldi	r18, 0x00	; 0
    ccd6:	80 91 e8 08 	lds	r24, 0x08E8
    ccda:	38 17       	cp	r19, r24
    ccdc:	08 f4       	brcc	.+2      	; 0xcce0 <MenuUp+0x74>
    ccde:	21 e0       	ldi	r18, 0x01	; 1
    cce0:	30 e0       	ldi	r19, 0x00	; 0
    cce2:	80 91 f7 04 	lds	r24, 0x04F7
    cce6:	90 91 f8 04 	lds	r25, 0x04F8
    ccea:	a0 91 f9 04 	lds	r26, 0x04F9
    ccee:	b0 91 fa 04 	lds	r27, 0x04FA
    ccf2:	8e 15       	cp	r24, r14
    ccf4:	9f 05       	cpc	r25, r15
    ccf6:	a0 07       	cpc	r26, r16
    ccf8:	b1 07       	cpc	r27, r17
    ccfa:	08 f4       	brcc	.+2      	; 0xccfe <MenuUp+0x92>
    ccfc:	31 e0       	ldi	r19, 0x01	; 1
    ccfe:	cf 01       	movw	r24, r30
    cd00:	61 e0       	ldi	r22, 0x01	; 1
    cd02:	03 2f       	mov	r16, r19
    cd04:	0e 94 c9 63 	call	0xc792	; 0xc792 <MenuUD>
}
    cd08:	1f 91       	pop	r17
    cd0a:	0f 91       	pop	r16
    cd0c:	ff 90       	pop	r15
    cd0e:	ef 90       	pop	r14
    cd10:	08 95       	ret

0000cd12 <PutField>:
	sprintf(Param->Pos, Format, Val);
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
PutField(uint8_t Type, void *Var, T_Param *Param)
{
    cd12:	af 92       	push	r10
    cd14:	bf 92       	push	r11
    cd16:	cf 92       	push	r12
    cd18:	df 92       	push	r13
    cd1a:	ef 92       	push	r14
    cd1c:	ff 92       	push	r15
    cd1e:	0f 93       	push	r16
    cd20:	1f 93       	push	r17
    cd22:	df 93       	push	r29
    cd24:	cf 93       	push	r28
    cd26:	cd b7       	in	r28, 0x3d	; 61
    cd28:	de b7       	in	r29, 0x3e	; 62
    cd2a:	69 97       	sbiw	r28, 0x19	; 25
    cd2c:	0f b6       	in	r0, 0x3f	; 63
    cd2e:	f8 94       	cli
    cd30:	de bf       	out	0x3e, r29	; 62
    cd32:	0f be       	out	0x3f, r0	; 63
    cd34:	cd bf       	out	0x3d, r28	; 61
    cd36:	db 01       	movw	r26, r22
    cd38:	7a 01       	movw	r14, r20
	float fTemp;

	switch(Type) {
    cd3a:	e8 2f       	mov	r30, r24
    cd3c:	f0 e0       	ldi	r31, 0x00	; 0
    cd3e:	e3 32       	cpi	r30, 0x23	; 35
    cd40:	f1 05       	cpc	r31, r1
    cd42:	88 f5       	brcc	.+98     	; 0xcda6 <PutField+0x94>
    cd44:	e7 52       	subi	r30, 0x27	; 39
    cd46:	ff 4f       	sbci	r31, 0xFF	; 255
    cd48:	ee 0f       	add	r30, r30
    cd4a:	ff 1f       	adc	r31, r31
    cd4c:	05 90       	lpm	r0, Z+
    cd4e:	f4 91       	lpm	r31, Z+
    cd50:	e0 2d       	mov	r30, r0
    cd52:	19 94       	eijmp
		break;
	case Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((*((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
		break;
	case EE_Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((erb((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
    cd54:	fa 01       	movw	r30, r20
    cd56:	a0 80       	ld	r10, Z
    cd58:	b1 80       	ldd	r11, Z+1	; 0x01
    cd5a:	c4 80       	ldd	r12, Z+4	; 0x04
    cd5c:	d5 80       	ldd	r13, Z+5	; 0x05
    cd5e:	12 81       	ldd	r17, Z+2	; 0x02
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    cd60:	81 2f       	mov	r24, r17
    cd62:	86 95       	lsr	r24
    cd64:	86 95       	lsr	r24
    cd66:	86 95       	lsr	r24
    cd68:	9b 01       	movw	r18, r22
    cd6a:	28 0f       	add	r18, r24
    cd6c:	31 1d       	adc	r19, r1
    cd6e:	c9 01       	movw	r24, r18
    cd70:	0e 94 1d 8e 	call	0x11c3a	; 0x11c3a <__eerd_byte_m2560>
    cd74:	17 70       	andi	r17, 0x07	; 7
    cd76:	21 e0       	ldi	r18, 0x01	; 1
    cd78:	30 e0       	ldi	r19, 0x00	; 0
    cd7a:	02 c0       	rjmp	.+4      	; 0xcd80 <PutField+0x6e>
    cd7c:	22 0f       	add	r18, r18
    cd7e:	33 1f       	adc	r19, r19
    cd80:	1a 95       	dec	r17
    cd82:	e2 f7       	brpl	.-8      	; 0xcd7c <PutField+0x6a>
    cd84:	90 e0       	ldi	r25, 0x00	; 0
    cd86:	28 23       	and	r18, r24
    cd88:	39 23       	and	r19, r25
    cd8a:	12 16       	cp	r1, r18
    cd8c:	13 06       	cpc	r1, r19
    cd8e:	0c f0       	brlt	.+2      	; 0xcd92 <PutField+0x80>
    cd90:	3f c1       	rjmp	.+638    	; 0xd010 <PutField+0x2fe>
    cd92:	82 e0       	ldi	r24, 0x02	; 2
    cd94:	90 e0       	ldi	r25, 0x00	; 0

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    cd96:	f6 01       	movw	r30, r12
    cd98:	e8 0f       	add	r30, r24
    cd9a:	f9 1f       	adc	r31, r25
    cd9c:	65 91       	lpm	r22, Z+
    cd9e:	74 91       	lpm	r23, Z+
    cda0:	c5 01       	movw	r24, r10
    cda2:	0e 94 fc 8a 	call	0x115f8	; 0x115f8 <strcpy_P>
			erbl(TempStr, Var, Param->Size);
			Put_TextValAlignRight(TempStr, Param);
		}
		break;
	}
}
    cda6:	69 96       	adiw	r28, 0x19	; 25
    cda8:	0f b6       	in	r0, 0x3f	; 63
    cdaa:	f8 94       	cli
    cdac:	de bf       	out	0x3e, r29	; 62
    cdae:	0f be       	out	0x3f, r0	; 63
    cdb0:	cd bf       	out	0x3d, r28	; 61
    cdb2:	cf 91       	pop	r28
    cdb4:	df 91       	pop	r29
    cdb6:	1f 91       	pop	r17
    cdb8:	0f 91       	pop	r16
    cdba:	ff 90       	pop	r15
    cdbc:	ef 90       	pop	r14
    cdbe:	df 90       	pop	r13
    cdc0:	cf 90       	pop	r12
    cdc2:	bf 90       	pop	r11
    cdc4:	af 90       	pop	r10
    cdc6:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    cdc8:	8e 01       	movw	r16, r28
    cdca:	0b 5f       	subi	r16, 0xFB	; 251
    cdcc:	1f 4f       	sbci	r17, 0xFF	; 255
    cdce:	fa 01       	movw	r30, r20
    cdd0:	43 81       	ldd	r20, Z+3	; 0x03
    cdd2:	c8 01       	movw	r24, r16
    cdd4:	50 e0       	ldi	r21, 0x00	; 0
    cdd6:	0e 94 0d 8e 	call	0x11c1a	; 0x11c1a <__eerd_block_m2560>
		Put_TextValAlignRight(Var, Param);
		break;
	case EE_Text:{
			char TempStr[LCDXSz+1];
			erbl(TempStr, Var, Param->Size);
			Put_TextValAlignRight(TempStr, Param);
    cdda:	c8 01       	movw	r24, r16
    cddc:	b7 01       	movw	r22, r14
    cdde:	0e 94 a3 4d 	call	0x9b46	; 0x9b46 <Put_TextValAlignRight>
    cde2:	e1 cf       	rjmp	.-62     	; 0xcda6 <PutField+0x94>
	case EE_Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((erb((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
		break;

	case Text:
		Put_TextValAlignRight(Var, Param);
    cde4:	cb 01       	movw	r24, r22
    cde6:	ba 01       	movw	r22, r20
    cde8:	0e 94 a3 4d 	call	0x9b46	; 0x9b46 <Put_TextValAlignRight>
    cdec:	dc cf       	rjmp	.-72     	; 0xcda6 <PutField+0x94>
	case EE_Enum:
		Param->Txt += erb((uint8_t*)Var);
		PutEnum(Param);
		break;
	case Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((*((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
    cdee:	fa 01       	movw	r30, r20
    cdf0:	00 81       	ld	r16, Z
    cdf2:	11 81       	ldd	r17, Z+1	; 0x01
    cdf4:	64 81       	ldd	r22, Z+4	; 0x04
    cdf6:	75 81       	ldd	r23, Z+5	; 0x05
    cdf8:	42 81       	ldd	r20, Z+2	; 0x02
    cdfa:	84 2f       	mov	r24, r20
    cdfc:	86 95       	lsr	r24
    cdfe:	86 95       	lsr	r24
    ce00:	86 95       	lsr	r24
    ce02:	a8 0f       	add	r26, r24
    ce04:	b1 1d       	adc	r27, r1
    ce06:	2c 91       	ld	r18, X
    ce08:	30 e0       	ldi	r19, 0x00	; 0
    ce0a:	47 70       	andi	r20, 0x07	; 7
    ce0c:	81 e0       	ldi	r24, 0x01	; 1
    ce0e:	90 e0       	ldi	r25, 0x00	; 0
    ce10:	02 c0       	rjmp	.+4      	; 0xce16 <PutField+0x104>
    ce12:	88 0f       	add	r24, r24
    ce14:	99 1f       	adc	r25, r25
    ce16:	4a 95       	dec	r20
    ce18:	e2 f7       	brpl	.-8      	; 0xce12 <PutField+0x100>
    ce1a:	28 23       	and	r18, r24
    ce1c:	39 23       	and	r19, r25
    ce1e:	12 16       	cp	r1, r18
    ce20:	13 06       	cpc	r1, r19
    ce22:	0c f0       	brlt	.+2      	; 0xce26 <PutField+0x114>
    ce24:	f8 c0       	rjmp	.+496    	; 0xd016 <PutField+0x304>
    ce26:	82 e0       	ldi	r24, 0x02	; 2
    ce28:	90 e0       	ldi	r25, 0x00	; 0

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    ce2a:	fb 01       	movw	r30, r22
    ce2c:	e8 0f       	add	r30, r24
    ce2e:	f9 1f       	adc	r31, r25
    ce30:	65 91       	lpm	r22, Z+
    ce32:	74 91       	lpm	r23, Z+
    ce34:	c8 01       	movw	r24, r16
    ce36:	0e 94 fc 8a 	call	0x115f8	; 0x115f8 <strcpy_P>
    ce3a:	b5 cf       	rjmp	.-150    	; 0xcda6 <PutField+0x94>
		Put_GFVal(fTemp, Param);
		break;


	case Enum:
		Param->Txt += *(uint8_t*)Var;
    ce3c:	2c 91       	ld	r18, X
    ce3e:	30 e0       	ldi	r19, 0x00	; 0
    ce40:	22 0f       	add	r18, r18
    ce42:	33 1f       	adc	r19, r19
    ce44:	f7 01       	movw	r30, r14
    ce46:	84 81       	ldd	r24, Z+4	; 0x04
    ce48:	95 81       	ldd	r25, Z+5	; 0x05
    ce4a:	82 0f       	add	r24, r18
    ce4c:	93 1f       	adc	r25, r19
    ce4e:	95 83       	std	Z+5, r25	; 0x05
    ce50:	84 83       	std	Z+4, r24	; 0x04
		PutEnum(Param);
    ce52:	c7 01       	movw	r24, r14
    ce54:	0e 94 4f 4b 	call	0x969e	; 0x969e <PutEnum>
    ce58:	a6 cf       	rjmp	.-180    	; 0xcda6 <PutField+0x94>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    ce5a:	cb 01       	movw	r24, r22
    ce5c:	0e 94 1d 8e 	call	0x11c3a	; 0x11c3a <__eerd_byte_m2560>
		break;
	case EE_Enum:
		Param->Txt += erb((uint8_t*)Var);
    ce60:	90 e0       	ldi	r25, 0x00	; 0
    ce62:	88 0f       	add	r24, r24
    ce64:	99 1f       	adc	r25, r25
    ce66:	f7 01       	movw	r30, r14
    ce68:	24 81       	ldd	r18, Z+4	; 0x04
    ce6a:	35 81       	ldd	r19, Z+5	; 0x05
    ce6c:	28 0f       	add	r18, r24
    ce6e:	39 1f       	adc	r19, r25
    ce70:	35 83       	std	Z+5, r19	; 0x05
    ce72:	24 83       	std	Z+4, r18	; 0x04
		PutEnum(Param);
    ce74:	c7 01       	movw	r24, r14
    ce76:	0e 94 4f 4b 	call	0x969e	; 0x969e <PutEnum>
    ce7a:	95 cf       	rjmp	.-214    	; 0xcda6 <PutField+0x94>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    ce7c:	ce 01       	movw	r24, r28
    ce7e:	01 96       	adiw	r24, 0x01	; 1
    ce80:	44 e0       	ldi	r20, 0x04	; 4
    ce82:	50 e0       	ldi	r21, 0x00	; 0
    ce84:	0e 94 0d 8e 	call	0x11c1a	; 0x11c1a <__eerd_block_m2560>
	case GFloat:
		Put_GFVal(*(float*)Var, Param);
		break;			
	case EE_GFloat:
		erbl(&fTemp, Var, 4);
		Put_GFVal(fTemp, Param);
    ce88:	69 81       	ldd	r22, Y+1	; 0x01
    ce8a:	7a 81       	ldd	r23, Y+2	; 0x02
    ce8c:	8b 81       	ldd	r24, Y+3	; 0x03
    ce8e:	9c 81       	ldd	r25, Y+4	; 0x04
    ce90:	a7 01       	movw	r20, r14
    ce92:	0e 94 ff 4d 	call	0x9bfe	; 0x9bfe <Put_GFVal>
    ce96:	87 cf       	rjmp	.-242    	; 0xcda6 <PutField+0x94>
	case EE_FFloat:
		erbl(&fTemp, Var, 4);
		Put_FFVal(fTemp, Param);
		break;
	case GFloat:
		Put_GFVal(*(float*)Var, Param);
    ce98:	6d 91       	ld	r22, X+
    ce9a:	7d 91       	ld	r23, X+
    ce9c:	8d 91       	ld	r24, X+
    ce9e:	9c 91       	ld	r25, X
    cea0:	0e 94 ff 4d 	call	0x9bfe	; 0x9bfe <Put_GFVal>
    cea4:	80 cf       	rjmp	.-256    	; 0xcda6 <PutField+0x94>
    cea6:	ce 01       	movw	r24, r28
    cea8:	01 96       	adiw	r24, 0x01	; 1
    ceaa:	44 e0       	ldi	r20, 0x04	; 4
    ceac:	50 e0       	ldi	r21, 0x00	; 0
    ceae:	0e 94 0d 8e 	call	0x11c1a	; 0x11c1a <__eerd_block_m2560>
	case FFloat:
		Put_FFVal(*(float*)Var, Param);
		break;			
	case EE_FFloat:
		erbl(&fTemp, Var, 4);
		Put_FFVal(fTemp, Param);
    ceb2:	69 81       	ldd	r22, Y+1	; 0x01
    ceb4:	7a 81       	ldd	r23, Y+2	; 0x02
    ceb6:	8b 81       	ldd	r24, Y+3	; 0x03
    ceb8:	9c 81       	ldd	r25, Y+4	; 0x04
    ceba:	a7 01       	movw	r20, r14
    cebc:	0e 94 79 4e 	call	0x9cf2	; 0x9cf2 <Put_FFVal>
    cec0:	72 cf       	rjmp	.-284    	; 0xcda6 <PutField+0x94>
		Put_zDVal(erd((uint32_t*)Var), Param);
		break;

		
	case FFloat:
		Put_FFVal(*(float*)Var, Param);
    cec2:	6d 91       	ld	r22, X+
    cec4:	7d 91       	ld	r23, X+
    cec6:	8d 91       	ld	r24, X+
    cec8:	9c 91       	ld	r25, X
    ceca:	0e 94 79 4e 	call	0x9cf2	; 0x9cf2 <Put_FFVal>
    cece:	6b cf       	rjmp	.-298    	; 0xcda6 <PutField+0x94>
		break;
	case zh_Word:
		Put_zVal_h(*(uint16_t*)Var, 'w', Param);
		break;
	case zh_Longint:
		Put_zVal_h(*(uint32_t*)Var, 'l', Param);
    ced0:	6d 91       	ld	r22, X+
    ced2:	7d 91       	ld	r23, X+
    ced4:	8d 91       	ld	r24, X+
    ced6:	9c 91       	ld	r25, X
    ced8:	4c e6       	ldi	r20, 0x6C	; 108
    ceda:	97 01       	movw	r18, r14
    cedc:	0e 94 39 52 	call	0xa472	; 0xa472 <Put_zVal_h>
    cee0:	62 cf       	rjmp	.-316    	; 0xcda6 <PutField+0x94>
// ~~~~~~~~~~~~~~~~~~~~~~
uint32_t
erd(const uint32_t *addr)
{
	//IntOff();
	uint32_t word = eeprom_read_dword(addr);
    cee2:	cb 01       	movw	r24, r22
    cee4:	0e 94 25 8e 	call	0x11c4a	; 0x11c4a <__eerd_dword_m2560>
		break;
	case z_Longint: case zc_Longint:
		Put_zDVal(*(uint32_t*)Var, Param);
		break;
	case z_EE_Longint:
		Put_zDVal(erd((uint32_t*)Var), Param);
    cee8:	a7 01       	movw	r20, r14
    ceea:	0e 94 ce 4e 	call	0x9d9c	; 0x9d9c <Put_zDVal>
    ceee:	5b cf       	rjmp	.-330    	; 0xcda6 <PutField+0x94>
		break;
	case s_EE_Longint:
		Put_sDVal((int32_t)erd((uint32_t*)Var), Param);
		break;
	case z_Longint: case zc_Longint:
		Put_zDVal(*(uint32_t*)Var, Param);
    cef0:	6d 91       	ld	r22, X+
    cef2:	7d 91       	ld	r23, X+
    cef4:	8d 91       	ld	r24, X+
    cef6:	9c 91       	ld	r25, X
    cef8:	0e 94 ce 4e 	call	0x9d9c	; 0x9d9c <Put_zDVal>
    cefc:	54 cf       	rjmp	.-344    	; 0xcda6 <PutField+0x94>
    cefe:	cb 01       	movw	r24, r22
    cf00:	0e 94 25 8e 	call	0x11c4a	; 0x11c4a <__eerd_dword_m2560>
		break;
	case s_Longint:
		Put_sDVal(*(int32_t*)Var, Param);
		break;
	case s_EE_Longint:
		Put_sDVal((int32_t)erd((uint32_t*)Var), Param);
    cf04:	a7 01       	movw	r20, r14
    cf06:	0e 94 ef 4f 	call	0x9fde	; 0x9fde <Put_sDVal>
    cf0a:	4d cf       	rjmp	.-358    	; 0xcda6 <PutField+0x94>
		break;
	case EE_Longint:
		PutDVal(erd((uint32_t*)Var), Param);
		break;
	case s_Longint:
		Put_sDVal(*(int32_t*)Var, Param);
    cf0c:	6d 91       	ld	r22, X+
    cf0e:	7d 91       	ld	r23, X+
    cf10:	8d 91       	ld	r24, X+
    cf12:	9c 91       	ld	r25, X
    cf14:	0e 94 ef 4f 	call	0x9fde	; 0x9fde <Put_sDVal>
    cf18:	46 cf       	rjmp	.-372    	; 0xcda6 <PutField+0x94>
    cf1a:	cb 01       	movw	r24, r22
    cf1c:	0e 94 25 8e 	call	0x11c4a	; 0x11c4a <__eerd_dword_m2560>

	case Longint: case c_Longint:
		PutDVal(*(uint32_t*)Var, Param);
		break;
	case EE_Longint:
		PutDVal(erd((uint32_t*)Var), Param);
    cf20:	a7 01       	movw	r20, r14
    cf22:	0e 94 18 51 	call	0xa230	; 0xa230 <PutDVal>
    cf26:	3f cf       	rjmp	.-386    	; 0xcda6 <PutField+0x94>
		Put_zVal(erw((uint16_t*)Var), 'w', Param);
		break;


	case Longint: case c_Longint:
		PutDVal(*(uint32_t*)Var, Param);
    cf28:	6d 91       	ld	r22, X+
    cf2a:	7d 91       	ld	r23, X+
    cf2c:	8d 91       	ld	r24, X+
    cf2e:	9c 91       	ld	r25, X
    cf30:	0e 94 18 51 	call	0xa230	; 0xa230 <PutDVal>
    cf34:	38 cf       	rjmp	.-400    	; 0xcda6 <PutField+0x94>

	case zh_Byte:
		Put_zVal_h(*(uint8_t*)Var, 'b', Param);
		break;
	case zh_Word:
		Put_zVal_h(*(uint16_t*)Var, 'w', Param);
    cf36:	6d 91       	ld	r22, X+
    cf38:	7c 91       	ld	r23, X
    cf3a:	80 e0       	ldi	r24, 0x00	; 0
    cf3c:	90 e0       	ldi	r25, 0x00	; 0
    cf3e:	47 e7       	ldi	r20, 0x77	; 119
    cf40:	97 01       	movw	r18, r14
    cf42:	0e 94 39 52 	call	0xa472	; 0xa472 <Put_zVal_h>
    cf46:	2f cf       	rjmp	.-418    	; 0xcda6 <PutField+0x94>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    cf48:	cb 01       	movw	r24, r22
    cf4a:	0e 94 2b 8e 	call	0x11c56	; 0x11c56 <__eerd_word_m2560>
		break;
	case z_Word: case zc_Word:
		Put_zVal(*(uint16_t*)Var, 'w', Param);
		break;
	case z_EE_Word:
		Put_zVal(erw((uint16_t*)Var), 'w', Param);
    cf4e:	67 e7       	ldi	r22, 0x77	; 119
    cf50:	a7 01       	movw	r20, r14
    cf52:	0e 94 ac 52 	call	0xa558	; 0xa558 <Put_zVal>
    cf56:	27 cf       	rjmp	.-434    	; 0xcda6 <PutField+0x94>
		break;
	case s_EE_Word:
		Put_sVal((int16_t)erw((uint16_t*)Var), 'w', Param);
		break;
	case z_Word: case zc_Word:
		Put_zVal(*(uint16_t*)Var, 'w', Param);
    cf58:	8d 91       	ld	r24, X+
    cf5a:	9c 91       	ld	r25, X
    cf5c:	67 e7       	ldi	r22, 0x77	; 119
    cf5e:	0e 94 ac 52 	call	0xa558	; 0xa558 <Put_zVal>
    cf62:	21 cf       	rjmp	.-446    	; 0xcda6 <PutField+0x94>
    cf64:	cb 01       	movw	r24, r22
    cf66:	0e 94 2b 8e 	call	0x11c56	; 0x11c56 <__eerd_word_m2560>
		break;
	case s_Word:
		Put_sVal(*(int16_t*)Var, 'w', Param);
		break;
	case s_EE_Word:
		Put_sVal((int16_t)erw((uint16_t*)Var), 'w', Param);
    cf6a:	67 e7       	ldi	r22, 0x77	; 119
    cf6c:	a7 01       	movw	r20, r14
    cf6e:	0e 94 69 53 	call	0xa6d2	; 0xa6d2 <Put_sVal>
    cf72:	19 cf       	rjmp	.-462    	; 0xcda6 <PutField+0x94>
		break;
	case EE_Word:
		PutVal(erw((uint16_t*)Var), 'w', Param);
		break;
	case s_Word:
		Put_sVal(*(int16_t*)Var, 'w', Param);
    cf74:	8d 91       	ld	r24, X+
    cf76:	9c 91       	ld	r25, X
    cf78:	67 e7       	ldi	r22, 0x77	; 119
    cf7a:	0e 94 69 53 	call	0xa6d2	; 0xa6d2 <Put_sVal>
    cf7e:	13 cf       	rjmp	.-474    	; 0xcda6 <PutField+0x94>
    cf80:	cb 01       	movw	r24, r22
    cf82:	0e 94 2b 8e 	call	0x11c56	; 0x11c56 <__eerd_word_m2560>

	case Word: case c_Word:
		PutVal(*(uint16_t*)Var, 'w', Param);
		break;
	case EE_Word:
		PutVal(erw((uint16_t*)Var), 'w', Param);
    cf86:	67 e7       	ldi	r22, 0x77	; 119
    cf88:	a7 01       	movw	r20, r14
    cf8a:	0e 94 4d 54 	call	0xa89a	; 0xa89a <PutVal>
    cf8e:	0b cf       	rjmp	.-490    	; 0xcda6 <PutField+0x94>
	case zh_Longint:
		Put_zVal_h(*(uint32_t*)Var, 'l', Param);
		break;

	case Word: case c_Word:
		PutVal(*(uint16_t*)Var, 'w', Param);
    cf90:	8d 91       	ld	r24, X+
    cf92:	9c 91       	ld	r25, X
    cf94:	67 e7       	ldi	r22, 0x77	; 119
    cf96:	0e 94 4d 54 	call	0xa89a	; 0xa89a <PutVal>
    cf9a:	05 cf       	rjmp	.-502    	; 0xcda6 <PutField+0x94>
	case z_EE_Byte:
		Put_zVal(erb((uint8_t*)Var), 'b', Param);
		break;

	case zh_Byte:
		Put_zVal_h(*(uint8_t*)Var, 'b', Param);
    cf9c:	6c 91       	ld	r22, X
    cf9e:	70 e0       	ldi	r23, 0x00	; 0
    cfa0:	80 e0       	ldi	r24, 0x00	; 0
    cfa2:	90 e0       	ldi	r25, 0x00	; 0
    cfa4:	42 e6       	ldi	r20, 0x62	; 98
    cfa6:	97 01       	movw	r18, r14
    cfa8:	0e 94 39 52 	call	0xa472	; 0xa472 <Put_zVal_h>
    cfac:	fc ce       	rjmp	.-520    	; 0xcda6 <PutField+0x94>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    cfae:	cb 01       	movw	r24, r22
    cfb0:	0e 94 1d 8e 	call	0x11c3a	; 0x11c3a <__eerd_byte_m2560>
		break;
	case z_Byte:
		Put_zVal(*(uint8_t*)Var, 'b', Param);
		break;
	case z_EE_Byte:
		Put_zVal(erb((uint8_t*)Var), 'b', Param);
    cfb4:	90 e0       	ldi	r25, 0x00	; 0
    cfb6:	62 e6       	ldi	r22, 0x62	; 98
    cfb8:	a7 01       	movw	r20, r14
    cfba:	0e 94 ac 52 	call	0xa558	; 0xa558 <Put_zVal>
    cfbe:	f3 ce       	rjmp	.-538    	; 0xcda6 <PutField+0x94>
		break;
	case s_EE_Byte:
		Put_sVal((int8_t)erb((uint8_t*)Var), 'b', Param);
		break;
	case z_Byte:
		Put_zVal(*(uint8_t*)Var, 'b', Param);
    cfc0:	8c 91       	ld	r24, X
    cfc2:	90 e0       	ldi	r25, 0x00	; 0
    cfc4:	62 e6       	ldi	r22, 0x62	; 98
    cfc6:	0e 94 ac 52 	call	0xa558	; 0xa558 <Put_zVal>
    cfca:	ed ce       	rjmp	.-550    	; 0xcda6 <PutField+0x94>
    cfcc:	cb 01       	movw	r24, r22
    cfce:	0e 94 1d 8e 	call	0x11c3a	; 0x11c3a <__eerd_byte_m2560>
		break;
	case s_Byte:
		Put_sVal(*(int8_t*)Var, 'b', Param);
		break;
	case s_EE_Byte:
		Put_sVal((int8_t)erb((uint8_t*)Var), 'b', Param);
    cfd2:	99 27       	eor	r25, r25
    cfd4:	87 fd       	sbrc	r24, 7
    cfd6:	90 95       	com	r25
    cfd8:	62 e6       	ldi	r22, 0x62	; 98
    cfda:	a7 01       	movw	r20, r14
    cfdc:	0e 94 69 53 	call	0xa6d2	; 0xa6d2 <Put_sVal>
    cfe0:	e2 ce       	rjmp	.-572    	; 0xcda6 <PutField+0x94>
		break;
	case EE_Byte:
		PutVal(erb((uint8_t*)Var), 'b', Param);
		break;
	case s_Byte:
		Put_sVal(*(int8_t*)Var, 'b', Param);
    cfe2:	8c 91       	ld	r24, X
    cfe4:	99 27       	eor	r25, r25
    cfe6:	87 fd       	sbrc	r24, 7
    cfe8:	90 95       	com	r25
    cfea:	62 e6       	ldi	r22, 0x62	; 98
    cfec:	0e 94 69 53 	call	0xa6d2	; 0xa6d2 <Put_sVal>
    cff0:	da ce       	rjmp	.-588    	; 0xcda6 <PutField+0x94>
    cff2:	cb 01       	movw	r24, r22
    cff4:	0e 94 1d 8e 	call	0x11c3a	; 0x11c3a <__eerd_byte_m2560>
	switch(Type) {
	case Byte:
		PutVal(*(uint8_t*)Var, 'b', Param);
		break;
	case EE_Byte:
		PutVal(erb((uint8_t*)Var), 'b', Param);
    cff8:	90 e0       	ldi	r25, 0x00	; 0
    cffa:	62 e6       	ldi	r22, 0x62	; 98
    cffc:	a7 01       	movw	r20, r14
    cffe:	0e 94 4d 54 	call	0xa89a	; 0xa89a <PutVal>
    d002:	d1 ce       	rjmp	.-606    	; 0xcda6 <PutField+0x94>
{
	float fTemp;

	switch(Type) {
	case Byte:
		PutVal(*(uint8_t*)Var, 'b', Param);
    d004:	8c 91       	ld	r24, X
    d006:	90 e0       	ldi	r25, 0x00	; 0
    d008:	62 e6       	ldi	r22, 0x62	; 98
    d00a:	0e 94 4d 54 	call	0xa89a	; 0xa89a <PutVal>
    d00e:	cb ce       	rjmp	.-618    	; 0xcda6 <PutField+0x94>
		break;
	case Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((*((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
		break;
	case EE_Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((erb((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
    d010:	80 e0       	ldi	r24, 0x00	; 0
    d012:	90 e0       	ldi	r25, 0x00	; 0
    d014:	c0 ce       	rjmp	.-640    	; 0xcd96 <PutField+0x84>
	case EE_Enum:
		Param->Txt += erb((uint8_t*)Var);
		PutEnum(Param);
		break;
	case Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((*((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
    d016:	80 e0       	ldi	r24, 0x00	; 0
    d018:	90 e0       	ldi	r25, 0x00	; 0
    d01a:	07 cf       	rjmp	.-498    	; 0xce2a <PutField+0x118>

0000d01c <PutLine>:
	PosBlink(Param,'_');
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
PutLine(uint8_t LineN, uint8_t Y)
{
    d01c:	2f 92       	push	r2
    d01e:	3f 92       	push	r3
    d020:	4f 92       	push	r4
    d022:	5f 92       	push	r5
    d024:	6f 92       	push	r6
    d026:	7f 92       	push	r7
    d028:	8f 92       	push	r8
    d02a:	9f 92       	push	r9
    d02c:	af 92       	push	r10
    d02e:	bf 92       	push	r11
    d030:	cf 92       	push	r12
    d032:	df 92       	push	r13
    d034:	ef 92       	push	r14
    d036:	ff 92       	push	r15
    d038:	0f 93       	push	r16
    d03a:	1f 93       	push	r17
    d03c:	df 93       	push	r29
    d03e:	cf 93       	push	r28
    d040:	cd b7       	in	r28, 0x3d	; 61
    d042:	de b7       	in	r29, 0x3e	; 62
    d044:	60 97       	sbiw	r28, 0x10	; 16
    d046:	0f b6       	in	r0, 0x3f	; 63
    d048:	f8 94       	cli
    d04a:	de bf       	out	0x3e, r29	; 62
    d04c:	0f be       	out	0x3f, r0	; 63
    d04e:	cd bf       	out	0x3d, r28	; 61
    d050:	8f 87       	std	Y+15, r24	; 0x0f
    d052:	68 8b       	std	Y+16, r22	; 0x10

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    d054:	e0 91 d4 02 	lds	r30, 0x02D4
    d058:	f0 91 d5 02 	lds	r31, 0x02D5
    d05c:	e5 90       	lpm	r14, Z+
    d05e:	f4 90       	lpm	r15, Z+
	MenuLine *Line=GetLine+LineN;
    d060:	8b e1       	ldi	r24, 0x1B	; 27
    d062:	2f 85       	ldd	r18, Y+15	; 0x0f
    d064:	28 9f       	mul	r18, r24
    d066:	c0 01       	movw	r24, r0
    d068:	11 24       	eor	r1, r1
    d06a:	e8 0e       	add	r14, r24
    d06c:	f9 1e       	adc	r15, r25
	PGM_P CurrStr=(PGM_P)(Line->Str);
    d06e:	be 2c       	mov	r11, r14
    d070:	af 2c       	mov	r10, r15
    d072:	f7 01       	movw	r30, r14
    d074:	75 96       	adiw	r30, 0x15	; 21
    d076:	c5 90       	lpm	r12, Z+
    d078:	d4 90       	lpm	r13, Z+

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    d07a:	f7 01       	movw	r30, r14
    d07c:	77 96       	adiw	r30, 0x17	; 23
    d07e:	85 91       	lpm	r24, Z+
    d080:	94 91       	lpm	r25, Z+
    d082:	9e 87       	std	Y+14, r25	; 0x0e
    d084:	8d 87       	std	Y+13, r24	; 0x0d
    d086:	87 01       	movw	r16, r14
    d088:	f7 01       	movw	r30, r14
    d08a:	84 91       	lpm	r24, Z+
	uint8_t X;
	uint8_t X0=0;
	uint8_t X1=LCDXSz;
	int8_t Xs = 0;
	//--- ">>" Align right
	if(prc(CurrStr+0) == '>' && prc(CurrStr+1) == '>'){
    d08c:	8e 33       	cpi	r24, 0x3E	; 62
    d08e:	09 f4       	brne	.+2      	; 0xd092 <PutLine+0x76>
    d090:	a6 c1       	rjmp	.+844    	; 0xd3de <PutLine+0x3c2>
		X0 = LCDXSz - strlen_P(CurrStr) + 2;
		Xs = X0-2;
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';
    d092:	40 e0       	ldi	r20, 0x00	; 0
    d094:	50 e0       	ldi	r21, 0x00	; 0
    d096:	f8 01       	movw	r30, r16
    d098:	84 91       	lpm	r24, Z+
	}
	//--- "<<" Align left
	if(prc(CurrStr+0) == '<' && prc(CurrStr+1) == '<'){
    d09a:	8c 33       	cpi	r24, 0x3C	; 60
    d09c:	09 f4       	brne	.+2      	; 0xd0a0 <PutLine+0x84>
    d09e:	8a c1       	rjmp	.+788    	; 0xd3b4 <PutLine+0x398>
		X1 = strlen_P(CurrStr) - 2;
    d0a0:	84 e1       	ldi	r24, 0x14	; 20
    d0a2:	98 2e       	mov	r9, r24
    d0a4:	f8 01       	movw	r30, r16
    d0a6:	84 91       	lpm	r24, Z+
		X0 = 0;
		Xs = X0-2;
	}
	//--- "<>" Align center
	if(prc(CurrStr+0) == '<' && prc(CurrStr+1) == '>'){
    d0a8:	8c 33       	cpi	r24, 0x3C	; 60
    d0aa:	09 f4       	brne	.+2      	; 0xd0ae <PutLine+0x92>
    d0ac:	56 c1       	rjmp	.+684    	; 0xd35a <PutLine+0x33e>
		Xs = X0-2;
		X1 = X0 + (strlen_P(CurrStr) - 2);
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';		
	}
	//---
	for(X=X0; X<X1; X++){
    d0ae:	49 15       	cp	r20, r9
    d0b0:	08 f0       	brcs	.+2      	; 0xd0b4 <PutLine+0x98>
    d0b2:	ac c0       	rjmp	.+344    	; 0xd20c <PutLine+0x1f0>
static void
PutLine(uint8_t LineN, uint8_t Y)
{
	MenuLine *Line=GetLine+LineN;
	PGM_P CurrStr=(PGM_P)(Line->Str);
	InField *IF = prp(&Line->IF_List);
    d0b4:	88 89       	ldd	r24, Y+16	; 0x10
    d0b6:	28 2f       	mov	r18, r24
    d0b8:	30 e0       	ldi	r19, 0x00	; 0
    d0ba:	c9 01       	movw	r24, r18
    d0bc:	88 0f       	add	r24, r24
    d0be:	99 1f       	adc	r25, r25
    d0c0:	82 0f       	add	r24, r18
    d0c2:	93 1f       	adc	r25, r19
    d0c4:	5c 01       	movw	r10, r24
    d0c6:	aa 0c       	add	r10, r10
    d0c8:	bb 1c       	adc	r11, r11
    d0ca:	aa 0c       	add	r10, r10
    d0cc:	bb 1c       	adc	r11, r11
    d0ce:	aa 0c       	add	r10, r10
    d0d0:	bb 1c       	adc	r11, r11
    d0d2:	a8 1a       	sub	r10, r24
    d0d4:	b9 0a       	sbc	r11, r25
    d0d6:	25 2e       	mov	r2, r21
    d0d8:	33 24       	eor	r3, r3
    d0da:	27 fc       	sbrc	r2, 7
    d0dc:	30 94       	com	r3
    d0de:	04 2f       	mov	r16, r20
    d0e0:	88 24       	eor	r8, r8
		switch(Char=prc(CurrStr+X-Xs)) {
		case '{':
			while((Char=prc(CurrStr + X - Xs + ++Param.Size))=='{');
			Param.Prec = prb(&IF->Prec);
			Param.Txt = prp(&IF->EnumList);
			PutField(prb(&IF->Type), prp(&IF->Var), &Param);
    d0e2:	3e 01       	movw	r6, r28
    d0e4:	08 94       	sec
    d0e6:	61 1c       	adc	r6, r1
    d0e8:	71 1c       	adc	r7, r1
			else
				PutField(prb(&(OF+OF_N)->Type), prp(&(OF+OF_N)->Var), &Param);
			OF_N++;
			break;
		}
		LCD_Buf[Y][X+=Param.Size] = Char;
    d0ea:	25 01       	movw	r4, r10
    d0ec:	11 c0       	rjmp	.+34     	; 0xd110 <PutLine+0xf4>
	for(X=X0; X<X1; X++){
		char Char;
		T_Param Param;
		Param.Pos = LCD_Buf[Y]+X;
		Param.Size = 0;
		switch(Char=prc(CurrStr+X-Xs)) {
    d0ee:	1d 37       	cpi	r17, 0x7D	; 125
    d0f0:	09 f4       	brne	.+2      	; 0xd0f4 <PutLine+0xd8>
    d0f2:	4c c0       	rjmp	.+152    	; 0xd18c <PutLine+0x170>
    d0f4:	30 e0       	ldi	r19, 0x00	; 0
			else
				PutField(prb(&(OF+OF_N)->Type), prp(&(OF+OF_N)->Var), &Param);
			OF_N++;
			break;
		}
		LCD_Buf[Y][X+=Param.Size] = Char;
    d0f6:	80 2f       	mov	r24, r16
    d0f8:	83 0f       	add	r24, r19
    d0fa:	f2 01       	movw	r30, r4
    d0fc:	e8 0f       	add	r30, r24
    d0fe:	f1 1d       	adc	r31, r1
    d100:	e8 5a       	subi	r30, 0xA8	; 168
    d102:	f9 4f       	sbci	r31, 0xF9	; 249
    d104:	10 83       	st	Z, r17
		Xs = X0-2;
		X1 = X0 + (strlen_P(CurrStr) - 2);
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';		
	}
	//---
	for(X=X0; X<X1; X++){
    d106:	08 2f       	mov	r16, r24
    d108:	0f 5f       	subi	r16, 0xFF	; 255
    d10a:	09 15       	cp	r16, r9
    d10c:	08 f0       	brcs	.+2      	; 0xd110 <PutLine+0xf4>
    d10e:	7e c0       	rjmp	.+252    	; 0xd20c <PutLine+0x1f0>
		char Char;
		T_Param Param;
		Param.Pos = LCD_Buf[Y]+X;
    d110:	80 2f       	mov	r24, r16
    d112:	90 e0       	ldi	r25, 0x00	; 0
    d114:	9c 01       	movw	r18, r24
    d116:	2a 0d       	add	r18, r10
    d118:	3b 1d       	adc	r19, r11
    d11a:	28 5a       	subi	r18, 0xA8	; 168
    d11c:	39 4f       	sbci	r19, 0xF9	; 249
    d11e:	3a 83       	std	Y+2, r19	; 0x02
    d120:	29 83       	std	Y+1, r18	; 0x01
		Param.Size = 0;
		switch(Char=prc(CurrStr+X-Xs)) {
    d122:	82 19       	sub	r24, r2
    d124:	93 09       	sbc	r25, r3
    d126:	f7 01       	movw	r30, r14
    d128:	e8 0f       	add	r30, r24
    d12a:	f9 1f       	adc	r31, r25
    d12c:	14 91       	lpm	r17, Z+
    d12e:	1b 37       	cpi	r17, 0x7B	; 123
    d130:	f1 f6       	brne	.-68     	; 0xd0ee <PutLine+0xd2>
    d132:	21 e0       	ldi	r18, 0x01	; 1
    d134:	01 c0       	rjmp	.+2      	; 0xd138 <PutLine+0x11c>
		case '{':
			while((Char=prc(CurrStr + X - Xs + ++Param.Size))=='{');
    d136:	23 2f       	mov	r18, r19
    d138:	fc 01       	movw	r30, r24
    d13a:	e2 0f       	add	r30, r18
    d13c:	f1 1d       	adc	r31, r1
    d13e:	ee 0d       	add	r30, r14
    d140:	ff 1d       	adc	r31, r15
    d142:	14 91       	lpm	r17, Z+
    d144:	32 2f       	mov	r19, r18
    d146:	3f 5f       	subi	r19, 0xFF	; 255
    d148:	1b 37       	cpi	r17, 0x7B	; 123
    d14a:	a9 f3       	breq	.-22     	; 0xd136 <PutLine+0x11a>
    d14c:	2c 83       	std	Y+4, r18	; 0x04

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    d14e:	a5 e0       	ldi	r26, 0x05	; 5
    d150:	b0 e0       	ldi	r27, 0x00	; 0
    d152:	ca 0e       	add	r12, r26
    d154:	db 1e       	adc	r13, r27
    d156:	f6 01       	movw	r30, r12
    d158:	84 91       	lpm	r24, Z+
    d15a:	2b ef       	ldi	r18, 0xFB	; 251
    d15c:	3f ef       	ldi	r19, 0xFF	; 255
    d15e:	c2 0e       	add	r12, r18
    d160:	d3 1e       	adc	r13, r19
			Param.Prec = prb(&IF->Prec);
    d162:	8b 83       	std	Y+3, r24	; 0x03

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    d164:	f6 01       	movw	r30, r12
    d166:	33 96       	adiw	r30, 0x03	; 3
    d168:	85 91       	lpm	r24, Z+
    d16a:	94 91       	lpm	r25, Z+
			Param.Txt = prp(&IF->EnumList);
    d16c:	9e 83       	std	Y+6, r25	; 0x06
    d16e:	8d 83       	std	Y+5, r24	; 0x05

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    d170:	f6 01       	movw	r30, r12
    d172:	84 91       	lpm	r24, Z+

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    d174:	31 96       	adiw	r30, 0x01	; 1
    d176:	65 91       	lpm	r22, Z+
    d178:	74 91       	lpm	r23, Z+
			PutField(prb(&IF->Type), prp(&IF->Var), &Param);
    d17a:	a3 01       	movw	r20, r6
    d17c:	0e 94 89 66 	call	0xcd12	; 0xcd12 <PutField>
			IF++;
    d180:	26 e0       	ldi	r18, 0x06	; 6
    d182:	30 e0       	ldi	r19, 0x00	; 0
    d184:	c2 0e       	add	r12, r18
    d186:	d3 1e       	adc	r13, r19
    d188:	3c 81       	ldd	r19, Y+4	; 0x04
    d18a:	b5 cf       	rjmp	.-150    	; 0xd0f6 <PutLine+0xda>
			break;
    d18c:	21 e0       	ldi	r18, 0x01	; 1
    d18e:	01 c0       	rjmp	.+2      	; 0xd192 <PutLine+0x176>
		case '}':
			while((Char=prc(CurrStr+X - Xs + ++Param.Size))=='}');
    d190:	23 2f       	mov	r18, r19

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    d192:	fc 01       	movw	r30, r24
    d194:	e2 0f       	add	r30, r18
    d196:	f1 1d       	adc	r31, r1
    d198:	ee 0d       	add	r30, r14
    d19a:	ff 1d       	adc	r31, r15
    d19c:	14 91       	lpm	r17, Z+
    d19e:	32 2f       	mov	r19, r18
    d1a0:	3f 5f       	subi	r19, 0xFF	; 255
    d1a2:	1d 37       	cpi	r17, 0x7D	; 125
    d1a4:	a9 f3       	breq	.-22     	; 0xd190 <PutLine+0x174>
    d1a6:	2c 83       	std	Y+4, r18	; 0x04
			Y1=Y;
    d1a8:	38 89       	ldd	r19, Y+16	; 0x10
    d1aa:	30 93 45 0a 	sts	0x0A45, r19
			Param.Prec = prb(&(OF+OF_N)->Prec);
    d1ae:	48 2d       	mov	r20, r8
    d1b0:	50 e0       	ldi	r21, 0x00	; 0
    d1b2:	42 95       	swap	r20
    d1b4:	52 95       	swap	r21
    d1b6:	50 7f       	andi	r21, 0xF0	; 240
    d1b8:	54 27       	eor	r21, r20
    d1ba:	40 7f       	andi	r20, 0xF0	; 240
    d1bc:	54 27       	eor	r21, r20
    d1be:	8d 85       	ldd	r24, Y+13	; 0x0d
    d1c0:	9e 85       	ldd	r25, Y+14	; 0x0e
    d1c2:	48 0f       	add	r20, r24
    d1c4:	59 1f       	adc	r21, r25

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    d1c6:	41 5f       	subi	r20, 0xF1	; 241
    d1c8:	5f 4f       	sbci	r21, 0xFF	; 255
    d1ca:	fa 01       	movw	r30, r20
    d1cc:	84 91       	lpm	r24, Z+
    d1ce:	4f 50       	subi	r20, 0x0F	; 15
    d1d0:	50 40       	sbci	r21, 0x00	; 0
    d1d2:	8b 83       	std	Y+3, r24	; 0x03

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    d1d4:	ca 01       	movw	r24, r20
    d1d6:	0d 96       	adiw	r24, 0x0d	; 13
    d1d8:	fc 01       	movw	r30, r24
    d1da:	25 91       	lpm	r18, Z+
    d1dc:	34 91       	lpm	r19, Z+
			Param.Txt = prp(&(OF+OF_N)->EnumList);
    d1de:	3e 83       	std	Y+6, r19	; 0x06
    d1e0:	2d 83       	std	Y+5, r18	; 0x05
			if(LineN==CurrLine && OF_N==CurrField)
    d1e2:	80 91 ca 07 	lds	r24, 0x07CA
    d1e6:	ff 85       	ldd	r31, Y+15	; 0x0f
    d1e8:	f8 17       	cp	r31, r24
    d1ea:	29 f4       	brne	.+10     	; 0xd1f6 <PutLine+0x1da>
    d1ec:	80 91 d6 02 	lds	r24, 0x02D6
    d1f0:	88 16       	cp	r8, r24
    d1f2:	09 f4       	brne	.+2      	; 0xd1f6 <PutLine+0x1da>
    d1f4:	43 c0       	rjmp	.+134    	; 0xd27c <PutLine+0x260>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    d1f6:	fa 01       	movw	r30, r20
    d1f8:	84 91       	lpm	r24, Z+

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    d1fa:	31 96       	adiw	r30, 0x01	; 1
    d1fc:	65 91       	lpm	r22, Z+
    d1fe:	74 91       	lpm	r23, Z+
				}
				else{ 
					PutBuf(prb(&(OF+OF_N)->Type), &Param);
				}			
			else
				PutField(prb(&(OF+OF_N)->Type), prp(&(OF+OF_N)->Var), &Param);
    d200:	a3 01       	movw	r20, r6
    d202:	0e 94 89 66 	call	0xcd12	; 0xcd12 <PutField>
    d206:	3c 81       	ldd	r19, Y+4	; 0x04
			OF_N++;
    d208:	83 94       	inc	r8
    d20a:	75 cf       	rjmp	.-278    	; 0xd0f6 <PutLine+0xda>
		}
		LCD_Buf[Y][X+=Param.Size] = Char;

	}
	X=X1;
	for(;X<LCDXSz; X++) LCD_Buf[Y][X] = ' ';
    d20c:	f3 e1       	ldi	r31, 0x13	; 19
    d20e:	f9 15       	cp	r31, r9
    d210:	e0 f0       	brcs	.+56     	; 0xd24a <PutLine+0x22e>
    d212:	88 89       	ldd	r24, Y+16	; 0x10
    d214:	28 2f       	mov	r18, r24
    d216:	30 e0       	ldi	r19, 0x00	; 0
    d218:	49 2d       	mov	r20, r9
    d21a:	c9 01       	movw	r24, r18
    d21c:	88 0f       	add	r24, r24
    d21e:	99 1f       	adc	r25, r25
    d220:	82 0f       	add	r24, r18
    d222:	93 1f       	adc	r25, r19
    d224:	9c 01       	movw	r18, r24
    d226:	22 0f       	add	r18, r18
    d228:	33 1f       	adc	r19, r19
    d22a:	22 0f       	add	r18, r18
    d22c:	33 1f       	adc	r19, r19
    d22e:	22 0f       	add	r18, r18
    d230:	33 1f       	adc	r19, r19
    d232:	28 1b       	sub	r18, r24
    d234:	39 0b       	sbc	r19, r25
    d236:	80 e2       	ldi	r24, 0x20	; 32
    d238:	f9 01       	movw	r30, r18
    d23a:	e4 0f       	add	r30, r20
    d23c:	f1 1d       	adc	r31, r1
    d23e:	e8 5a       	subi	r30, 0xA8	; 168
    d240:	f9 4f       	sbci	r31, 0xF9	; 249
    d242:	80 83       	st	Z, r24
    d244:	4f 5f       	subi	r20, 0xFF	; 255
    d246:	44 31       	cpi	r20, 0x14	; 20
    d248:	b8 f3       	brcs	.-18     	; 0xd238 <PutLine+0x21c>

}
    d24a:	60 96       	adiw	r28, 0x10	; 16
    d24c:	0f b6       	in	r0, 0x3f	; 63
    d24e:	f8 94       	cli
    d250:	de bf       	out	0x3e, r29	; 62
    d252:	0f be       	out	0x3f, r0	; 63
    d254:	cd bf       	out	0x3d, r28	; 61
    d256:	cf 91       	pop	r28
    d258:	df 91       	pop	r29
    d25a:	1f 91       	pop	r17
    d25c:	0f 91       	pop	r16
    d25e:	ff 90       	pop	r15
    d260:	ef 90       	pop	r14
    d262:	df 90       	pop	r13
    d264:	cf 90       	pop	r12
    d266:	bf 90       	pop	r11
    d268:	af 90       	pop	r10
    d26a:	9f 90       	pop	r9
    d26c:	8f 90       	pop	r8
    d26e:	7f 90       	pop	r7
    d270:	6f 90       	pop	r6
    d272:	5f 90       	pop	r5
    d274:	4f 90       	pop	r4
    d276:	3f 90       	pop	r3
    d278:	2f 90       	pop	r2
    d27a:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    d27c:	fa 01       	movw	r30, r20
    d27e:	84 91       	lpm	r24, Z+
			Y1=Y;
			Param.Prec = prb(&(OF+OF_N)->Prec);
			Param.Txt = prp(&(OF+OF_N)->EnumList);
			if(LineN==CurrLine && OF_N==CurrField)
				//add new
				if( (prb(&(OF+OF_N)->Type) == Text) || (prb(&(OF+OF_N)->Type) == EE_Text ) ||
    d280:	81 32       	cpi	r24, 0x21	; 33
    d282:	61 f1       	breq	.+88     	; 0xd2dc <PutLine+0x2c0>
    d284:	82 32       	cpi	r24, 0x22	; 34
    d286:	51 f1       	breq	.+84     	; 0xd2dc <PutLine+0x2c0>
    d288:	80 31       	cpi	r24, 0x10	; 16
    d28a:	41 f1       	breq	.+80     	; 0xd2dc <PutLine+0x2c0>
    d28c:	84 31       	cpi	r24, 0x14	; 20
    d28e:	31 f1       	breq	.+76     	; 0xd2dc <PutLine+0x2c0>
    d290:	81 31       	cpi	r24, 0x11	; 17
    d292:	21 f1       	breq	.+72     	; 0xd2dc <PutLine+0x2c0>
    d294:	85 31       	cpi	r24, 0x15	; 21
    d296:	11 f1       	breq	.+68     	; 0xd2dc <PutLine+0x2c0>
    d298:	82 31       	cpi	r24, 0x12	; 18
    d29a:	01 f1       	breq	.+64     	; 0xd2dc <PutLine+0x2c0>
    d29c:	83 31       	cpi	r24, 0x13	; 19
    d29e:	f1 f0       	breq	.+60     	; 0xd2dc <PutLine+0x2c0>
    d2a0:	89 31       	cpi	r24, 0x19	; 25
    d2a2:	e1 f0       	breq	.+56     	; 0xd2dc <PutLine+0x2c0>
    d2a4:	8b 31       	cpi	r24, 0x1B	; 27
    d2a6:	d1 f0       	breq	.+52     	; 0xd2dc <PutLine+0x2c0>
    d2a8:	8a 31       	cpi	r24, 0x1A	; 26
    d2aa:	c1 f0       	breq	.+48     	; 0xd2dc <PutLine+0x2c0>
    d2ac:	8c 31       	cpi	r24, 0x1C	; 28
    d2ae:	b1 f0       	breq	.+44     	; 0xd2dc <PutLine+0x2c0>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
PutBuf(uint8_t Type, T_Param *Param)
{
	switch(Type) {
    d2b0:	89 30       	cpi	r24, 0x09	; 9
    d2b2:	08 f0       	brcs	.+2      	; 0xd2b6 <PutLine+0x29a>
    d2b4:	b7 c0       	rjmp	.+366    	; 0xd424 <PutLine+0x408>
    d2b6:	87 30       	cpi	r24, 0x07	; 7
    d2b8:	08 f0       	brcs	.+2      	; 0xd2bc <PutLine+0x2a0>
    d2ba:	b9 c0       	rjmp	.+370    	; 0xd42e <PutLine+0x412>
    d2bc:	84 30       	cpi	r24, 0x04	; 4
    d2be:	08 f0       	brcs	.+2      	; 0xd2c2 <PutLine+0x2a6>
    d2c0:	e5 c0       	rjmp	.+458    	; 0xd48c <PutLine+0x470>
    d2c2:	82 30       	cpi	r24, 0x02	; 2
    d2c4:	08 f4       	brcc	.+2      	; 0xd2c8 <PutLine+0x2ac>
    d2c6:	b3 c0       	rjmp	.+358    	; 0xd42e <PutLine+0x412>
		Put_bVal(Param);
		PosBlink(Param,' ');
		break;
	case s_Byte: case s_EE_Byte:
	case s_Word: case s_EE_Word:
		Put_sbVal(Param);
    d2c8:	c3 01       	movw	r24, r6
    d2ca:	0e 94 80 4b 	call	0x9700	; 0x9700 <Put_sbVal>
		PosBlink(Param,' ');
    d2ce:	c3 01       	movw	r24, r6
    d2d0:	60 e2       	ldi	r22, 0x20	; 32
    d2d2:	0e 94 56 46 	call	0x8cac	; 0x8cac <PosBlink>
    d2d6:	3c 81       	ldd	r19, Y+4	; 0x04
				else{ 
					PutBuf(prb(&(OF+OF_N)->Type), &Param);
				}			
			else
				PutField(prb(&(OF+OF_N)->Type), prp(&(OF+OF_N)->Var), &Param);
			OF_N++;
    d2d8:	83 94       	inc	r8
    d2da:	0d cf       	rjmp	.-486    	; 0xd0f6 <PutLine+0xda>
// When use BufStr for variable edit
inline static void
PutBufStr(uint8_t Type, T_Param *Param)
{	
	char Format[6];
	sprintf(Format,"%%.%us", Param->Size);
    d2dc:	00 d0       	rcall	.+0      	; 0xd2de <PutLine+0x2c2>
    d2de:	00 d0       	rcall	.+0      	; 0xd2e0 <PutLine+0x2c4>
    d2e0:	ed b7       	in	r30, 0x3d	; 61
    d2e2:	fe b7       	in	r31, 0x3e	; 62
    d2e4:	31 96       	adiw	r30, 0x01	; 1
    d2e6:	27 e0       	ldi	r18, 0x07	; 7
    d2e8:	30 e0       	ldi	r19, 0x00	; 0
    d2ea:	2c 0f       	add	r18, r28
    d2ec:	3d 1f       	adc	r19, r29
    d2ee:	ad b7       	in	r26, 0x3d	; 61
    d2f0:	be b7       	in	r27, 0x3e	; 62
    d2f2:	12 96       	adiw	r26, 0x02	; 2
    d2f4:	3c 93       	st	X, r19
    d2f6:	2e 93       	st	-X, r18
    d2f8:	11 97       	sbiw	r26, 0x01	; 1
    d2fa:	8b ea       	ldi	r24, 0xAB	; 171
    d2fc:	92 e0       	ldi	r25, 0x02	; 2
    d2fe:	93 83       	std	Z+3, r25	; 0x03
    d300:	82 83       	std	Z+2, r24	; 0x02
    d302:	8c 81       	ldd	r24, Y+4	; 0x04
    d304:	84 83       	std	Z+4, r24	; 0x04
    d306:	15 82       	std	Z+5, r1	; 0x05
    d308:	0e 94 ef 8b 	call	0x117de	; 0x117de <sprintf>
	sprintf(Param->Pos, Format, BufStr);
    d30c:	ed b7       	in	r30, 0x3d	; 61
    d30e:	fe b7       	in	r31, 0x3e	; 62
    d310:	31 96       	adiw	r30, 0x01	; 1
    d312:	89 81       	ldd	r24, Y+1	; 0x01
    d314:	9a 81       	ldd	r25, Y+2	; 0x02
    d316:	ad b7       	in	r26, 0x3d	; 61
    d318:	be b7       	in	r27, 0x3e	; 62
    d31a:	12 96       	adiw	r26, 0x02	; 2
    d31c:	9c 93       	st	X, r25
    d31e:	8e 93       	st	-X, r24
    d320:	11 97       	sbiw	r26, 0x01	; 1
    d322:	27 e0       	ldi	r18, 0x07	; 7
    d324:	30 e0       	ldi	r19, 0x00	; 0
    d326:	2c 0f       	add	r18, r28
    d328:	3d 1f       	adc	r19, r29
    d32a:	33 83       	std	Z+3, r19	; 0x03
    d32c:	22 83       	std	Z+2, r18	; 0x02
    d32e:	83 ec       	ldi	r24, 0xC3	; 195
    d330:	95 e0       	ldi	r25, 0x05	; 5
    d332:	95 83       	std	Z+5, r25	; 0x05
    d334:	84 83       	std	Z+4, r24	; 0x04
    d336:	0e 94 ef 8b 	call	0x117de	; 0x117de <sprintf>
	Param->Prec = 0;
    d33a:	1b 82       	std	Y+3, r1	; 0x03
	PosBlink(Param,'_');
    d33c:	ad b7       	in	r26, 0x3d	; 61
    d33e:	be b7       	in	r27, 0x3e	; 62
    d340:	16 96       	adiw	r26, 0x06	; 6
    d342:	0f b6       	in	r0, 0x3f	; 63
    d344:	f8 94       	cli
    d346:	be bf       	out	0x3e, r27	; 62
    d348:	0f be       	out	0x3f, r0	; 63
    d34a:	ad bf       	out	0x3d, r26	; 61
    d34c:	c3 01       	movw	r24, r6
    d34e:	6f e5       	ldi	r22, 0x5F	; 95
    d350:	0e 94 56 46 	call	0x8cac	; 0x8cac <PosBlink>
    d354:	3c 81       	ldd	r19, Y+4	; 0x04
				else{ 
					PutBuf(prb(&(OF+OF_N)->Type), &Param);
				}			
			else
				PutField(prb(&(OF+OF_N)->Type), prp(&(OF+OF_N)->Var), &Param);
			OF_N++;
    d356:	83 94       	inc	r8
    d358:	ce ce       	rjmp	.-612    	; 0xd0f6 <PutLine+0xda>

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    d35a:	08 94       	sec
    d35c:	e1 1c       	adc	r14, r1
    d35e:	f1 1c       	adc	r15, r1
    d360:	f7 01       	movw	r30, r14
    d362:	84 91       	lpm	r24, Z+
    d364:	08 94       	sec
    d366:	e1 08       	sbc	r14, r1
    d368:	f1 08       	sbc	r15, r1
		X1 = strlen_P(CurrStr) - 2;
		X0 = 0;
		Xs = X0-2;
	}
	//--- "<>" Align center
	if(prc(CurrStr+0) == '<' && prc(CurrStr+1) == '>'){
    d36a:	8e 33       	cpi	r24, 0x3E	; 62
    d36c:	09 f0       	breq	.+2      	; 0xd370 <PutLine+0x354>
    d36e:	9f ce       	rjmp	.-706    	; 0xd0ae <PutLine+0x92>
		X0 = (LCDXSz - strlen_P(CurrStr) + 2) / 2;
    d370:	8b 2d       	mov	r24, r11
    d372:	9a 2d       	mov	r25, r10
    d374:	0e 94 03 8b 	call	0x11606	; 0x11606 <strlen_P>
    d378:	26 e1       	ldi	r18, 0x16	; 22
    d37a:	30 e0       	ldi	r19, 0x00	; 0
    d37c:	28 1b       	sub	r18, r24
    d37e:	39 0b       	sbc	r19, r25
    d380:	36 95       	lsr	r19
    d382:	27 95       	ror	r18
    d384:	42 2f       	mov	r20, r18
		Xs = X0-2;
    d386:	52 2f       	mov	r21, r18
    d388:	52 50       	subi	r21, 0x02	; 2
		X1 = X0 + (strlen_P(CurrStr) - 2);
    d38a:	be ef       	ldi	r27, 0xFE	; 254
    d38c:	9b 2e       	mov	r9, r27
    d38e:	98 0e       	add	r9, r24
    d390:	92 0e       	add	r9, r18
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';		
    d392:	22 23       	and	r18, r18
    d394:	09 f4       	brne	.+2      	; 0xd398 <PutLine+0x37c>
    d396:	8b ce       	rjmp	.-746    	; 0xd0ae <PutLine+0x92>
    d398:	85 e1       	ldi	r24, 0x15	; 21
    d39a:	28 89       	ldd	r18, Y+16	; 0x10
    d39c:	28 9f       	mul	r18, r24
    d39e:	f0 01       	movw	r30, r0
    d3a0:	11 24       	eor	r1, r1
    d3a2:	e8 5a       	subi	r30, 0xA8	; 168
    d3a4:	f9 4f       	sbci	r31, 0xF9	; 249
    d3a6:	80 e0       	ldi	r24, 0x00	; 0
    d3a8:	90 e2       	ldi	r25, 0x20	; 32
    d3aa:	91 93       	st	Z+, r25
    d3ac:	8f 5f       	subi	r24, 0xFF	; 255
    d3ae:	84 17       	cp	r24, r20
    d3b0:	e0 f3       	brcs	.-8      	; 0xd3aa <PutLine+0x38e>
    d3b2:	7d ce       	rjmp	.-774    	; 0xd0ae <PutLine+0x92>
    d3b4:	08 94       	sec
    d3b6:	e1 1c       	adc	r14, r1
    d3b8:	f1 1c       	adc	r15, r1
    d3ba:	f7 01       	movw	r30, r14
    d3bc:	84 91       	lpm	r24, Z+
    d3be:	08 94       	sec
    d3c0:	e1 08       	sbc	r14, r1
    d3c2:	f1 08       	sbc	r15, r1
		X0 = LCDXSz - strlen_P(CurrStr) + 2;
		Xs = X0-2;
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';
	}
	//--- "<<" Align left
	if(prc(CurrStr+0) == '<' && prc(CurrStr+1) == '<'){
    d3c4:	8c 33       	cpi	r24, 0x3C	; 60
    d3c6:	09 f0       	breq	.+2      	; 0xd3ca <PutLine+0x3ae>
    d3c8:	6b ce       	rjmp	.-810    	; 0xd0a0 <PutLine+0x84>
		X1 = strlen_P(CurrStr) - 2;
    d3ca:	8b 2d       	mov	r24, r11
    d3cc:	9a 2d       	mov	r25, r10
    d3ce:	0e 94 03 8b 	call	0x11606	; 0x11606 <strlen_P>
    d3d2:	9e ef       	ldi	r25, 0xFE	; 254
    d3d4:	99 2e       	mov	r9, r25
    d3d6:	98 0e       	add	r9, r24
    d3d8:	40 e0       	ldi	r20, 0x00	; 0
    d3da:	5e ef       	ldi	r21, 0xFE	; 254
    d3dc:	63 ce       	rjmp	.-826    	; 0xd0a4 <PutLine+0x88>
    d3de:	08 94       	sec
    d3e0:	e1 1c       	adc	r14, r1
    d3e2:	f1 1c       	adc	r15, r1
    d3e4:	f7 01       	movw	r30, r14
    d3e6:	84 91       	lpm	r24, Z+
    d3e8:	08 94       	sec
    d3ea:	e1 08       	sbc	r14, r1
    d3ec:	f1 08       	sbc	r15, r1
	uint8_t X;
	uint8_t X0=0;
	uint8_t X1=LCDXSz;
	int8_t Xs = 0;
	//--- ">>" Align right
	if(prc(CurrStr+0) == '>' && prc(CurrStr+1) == '>'){
    d3ee:	8e 33       	cpi	r24, 0x3E	; 62
    d3f0:	09 f0       	breq	.+2      	; 0xd3f4 <PutLine+0x3d8>
    d3f2:	4f ce       	rjmp	.-866    	; 0xd092 <PutLine+0x76>
		X0 = LCDXSz - strlen_P(CurrStr) + 2;
    d3f4:	c7 01       	movw	r24, r14
    d3f6:	0e 94 03 8b 	call	0x11606	; 0x11606 <strlen_P>
    d3fa:	46 e1       	ldi	r20, 0x16	; 22
    d3fc:	48 1b       	sub	r20, r24
		Xs = X0-2;
    d3fe:	54 2f       	mov	r21, r20
    d400:	52 50       	subi	r21, 0x02	; 2
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';
    d402:	44 23       	and	r20, r20
    d404:	09 f4       	brne	.+2      	; 0xd408 <PutLine+0x3ec>
    d406:	47 ce       	rjmp	.-882    	; 0xd096 <PutLine+0x7a>
    d408:	85 e1       	ldi	r24, 0x15	; 21
    d40a:	28 89       	ldd	r18, Y+16	; 0x10
    d40c:	28 9f       	mul	r18, r24
    d40e:	f0 01       	movw	r30, r0
    d410:	11 24       	eor	r1, r1
    d412:	e8 5a       	subi	r30, 0xA8	; 168
    d414:	f9 4f       	sbci	r31, 0xF9	; 249
    d416:	80 e0       	ldi	r24, 0x00	; 0
    d418:	90 e2       	ldi	r25, 0x20	; 32
    d41a:	91 93       	st	Z+, r25
    d41c:	8f 5f       	subi	r24, 0xFF	; 255
    d41e:	84 17       	cp	r24, r20
    d420:	e0 f3       	brcs	.-8      	; 0xd41a <PutLine+0x3fe>
    d422:	39 ce       	rjmp	.-910    	; 0xd096 <PutLine+0x7a>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
PutBuf(uint8_t Type, T_Param *Param)
{
	switch(Type) {
    d424:	8d 30       	cpi	r24, 0x0D	; 13
    d426:	68 f4       	brcc	.+26     	; 0xd442 <PutLine+0x426>
    d428:	8b 30       	cpi	r24, 0x0B	; 11
    d42a:	08 f4       	brcc	.+2      	; 0xd42e <PutLine+0x412>
    d42c:	4d cf       	rjmp	.-358    	; 0xd2c8 <PutLine+0x2ac>
	case Byte: case EE_Byte: case z_Byte: case z_EE_Byte:
	case Word: case EE_Word: case z_Word: case z_EE_Word:
		Put_bVal(Param);
    d42e:	c3 01       	movw	r24, r6
    d430:	0e 94 7e 4c 	call	0x98fc	; 0x98fc <Put_bVal>
		PosBlink(Param,' ');
    d434:	c3 01       	movw	r24, r6
    d436:	60 e2       	ldi	r22, 0x20	; 32
    d438:	0e 94 56 46 	call	0x8cac	; 0x8cac <PosBlink>
    d43c:	3c 81       	ldd	r19, Y+4	; 0x04
				else{ 
					PutBuf(prb(&(OF+OF_N)->Type), &Param);
				}			
			else
				PutField(prb(&(OF+OF_N)->Type), prp(&(OF+OF_N)->Var), &Param);
			OF_N++;
    d43e:	83 94       	inc	r8
    d440:	5a ce       	rjmp	.-844    	; 0xd0f6 <PutLine+0xda>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
PutBuf(uint8_t Type, T_Param *Param)
{
	switch(Type) {
    d442:	8e 30       	cpi	r24, 0x0E	; 14
    d444:	b9 f1       	breq	.+110    	; 0xd4b4 <PutLine+0x498>
    d446:	8e 30       	cpi	r24, 0x0E	; 14
    d448:	28 f1       	brcs	.+74     	; 0xd494 <PutLine+0x478>
    d44a:	8d 51       	subi	r24, 0x1D	; 29
    d44c:	84 30       	cpi	r24, 0x04	; 4
    d44e:	08 f0       	brcs	.+2      	; 0xd452 <PutLine+0x436>
    d450:	da ce       	rjmp	.-588    	; 0xd206 <PutLine+0x1ea>
	case zc_Word:
		Put_zVal(F_Buf, 'w', Param);
		ValBlink(Param->Pos, Param->Size);
		break;
	case Enum: case EE_Enum: case Bit: case EE_Bit:
		Param->Txt += (uint8_t)F_Buf;
    d452:	80 91 f7 04 	lds	r24, 0x04F7
    d456:	90 e0       	ldi	r25, 0x00	; 0
    d458:	88 0f       	add	r24, r24
    d45a:	99 1f       	adc	r25, r25
    d45c:	28 0f       	add	r18, r24
    d45e:	39 1f       	adc	r19, r25
    d460:	3e 83       	std	Y+6, r19	; 0x06
    d462:	2d 83       	std	Y+5, r18	; 0x05
		PutEnum(Param);
    d464:	c3 01       	movw	r24, r6
    d466:	0e 94 4f 4b 	call	0x969e	; 0x969e <PutEnum>
		ValBlink(Param->Pos, Param->Size);
    d46a:	3c 81       	ldd	r19, Y+4	; 0x04

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
ValBlink(char *Pos, uint8_t Sz)
{
	CurrX=Pos-LCD_Buf[Y1];
    d46c:	80 91 45 0a 	lds	r24, 0x0A45
    d470:	f5 e1       	ldi	r31, 0x15	; 21
    d472:	8f 9f       	mul	r24, r31
    d474:	c0 01       	movw	r24, r0
    d476:	11 24       	eor	r1, r1
    d478:	88 5a       	subi	r24, 0xA8	; 168
    d47a:	99 4f       	sbci	r25, 0xF9	; 249
    d47c:	29 81       	ldd	r18, Y+1	; 0x01
    d47e:	28 1b       	sub	r18, r24
    d480:	20 93 fa 06 	sts	0x06FA, r18
	StrSize=Sz; 
    d484:	30 93 ac 06 	sts	0x06AC, r19
				else{ 
					PutBuf(prb(&(OF+OF_N)->Type), &Param);
				}			
			else
				PutField(prb(&(OF+OF_N)->Type), prp(&(OF+OF_N)->Var), &Param);
			OF_N++;
    d488:	83 94       	inc	r8
    d48a:	35 ce       	rjmp	.-918    	; 0xd0f6 <PutLine+0xda>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
PutBuf(uint8_t Type, T_Param *Param)
{
	switch(Type) {
    d48c:	86 30       	cpi	r24, 0x06	; 6
    d48e:	78 f2       	brcs	.-98     	; 0xd42e <PutLine+0x412>
    d490:	3c 81       	ldd	r19, Y+4	; 0x04
    d492:	ba ce       	rjmp	.-652    	; 0xd208 <PutLine+0x1ec>
	case s_Word: case s_EE_Word:
		Put_sbVal(Param);
		PosBlink(Param,' ');
		break;
	case c_Word:
		PutVal(F_Buf, 'w', Param);
    d494:	80 91 f7 04 	lds	r24, 0x04F7
    d498:	90 91 f8 04 	lds	r25, 0x04F8
    d49c:	67 e7       	ldi	r22, 0x77	; 119
    d49e:	a3 01       	movw	r20, r6
    d4a0:	0e 94 4d 54 	call	0xa89a	; 0xa89a <PutVal>
		ValBlink(Param->Pos, Param->Size);
    d4a4:	3c 81       	ldd	r19, Y+4	; 0x04

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
ValBlink(char *Pos, uint8_t Sz)
{
	CurrX=Pos-LCD_Buf[Y1];
    d4a6:	80 91 45 0a 	lds	r24, 0x0A45
    d4aa:	b5 e1       	ldi	r27, 0x15	; 21
    d4ac:	8b 9f       	mul	r24, r27
    d4ae:	c0 01       	movw	r24, r0
    d4b0:	11 24       	eor	r1, r1
    d4b2:	e2 cf       	rjmp	.-60     	; 0xd478 <PutLine+0x45c>
	case c_Word:
		PutVal(F_Buf, 'w', Param);
		ValBlink(Param->Pos, Param->Size);
		break;
	case zc_Word:
		Put_zVal(F_Buf, 'w', Param);
    d4b4:	80 91 f7 04 	lds	r24, 0x04F7
    d4b8:	90 91 f8 04 	lds	r25, 0x04F8
    d4bc:	67 e7       	ldi	r22, 0x77	; 119
    d4be:	a3 01       	movw	r20, r6
    d4c0:	0e 94 ac 52 	call	0xa558	; 0xa558 <Put_zVal>
		ValBlink(Param->Pos, Param->Size);
    d4c4:	3c 81       	ldd	r19, Y+4	; 0x04

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
ValBlink(char *Pos, uint8_t Sz)
{
	CurrX=Pos-LCD_Buf[Y1];
    d4c6:	80 91 45 0a 	lds	r24, 0x0A45
    d4ca:	e5 e1       	ldi	r30, 0x15	; 21
    d4cc:	8e 9f       	mul	r24, r30
    d4ce:	c0 01       	movw	r24, r0
    d4d0:	11 24       	eor	r1, r1
    d4d2:	d2 cf       	rjmp	.-92     	; 0xd478 <PutLine+0x45c>

0000d4d4 <MenuOut>:
	while(X<LCDXSz)	LCD_Buf[Y][X++] = ' ';
}
// ~~~~~~~~~~
void
MenuOut(void)
{
    d4d4:	2f 92       	push	r2
    d4d6:	3f 92       	push	r3
    d4d8:	4f 92       	push	r4
    d4da:	5f 92       	push	r5
    d4dc:	6f 92       	push	r6
    d4de:	7f 92       	push	r7
    d4e0:	8f 92       	push	r8
    d4e2:	9f 92       	push	r9
    d4e4:	af 92       	push	r10
    d4e6:	bf 92       	push	r11
    d4e8:	cf 92       	push	r12
    d4ea:	df 92       	push	r13
    d4ec:	ef 92       	push	r14
    d4ee:	ff 92       	push	r15
    d4f0:	0f 93       	push	r16
    d4f2:	1f 93       	push	r17
    d4f4:	df 93       	push	r29
    d4f6:	cf 93       	push	r28
    d4f8:	cd b7       	in	r28, 0x3d	; 61
    d4fa:	de b7       	in	r29, 0x3e	; 62
    d4fc:	2a 97       	sbiw	r28, 0x0a	; 10
    d4fe:	0f b6       	in	r0, 0x3f	; 63
    d500:	f8 94       	cli
    d502:	de bf       	out	0x3e, r29	; 62
    d504:	0f be       	out	0x3f, r0	; 63
    d506:	cd bf       	out	0x3d, r28	; 61
	uint8_t Y;
	if(CurrMsg) {
    d508:	a0 90 f5 04 	lds	r10, 0x04F5
    d50c:	b0 90 f6 04 	lds	r11, 0x04F6
    d510:	a1 14       	cp	r10, r1
    d512:	b1 04       	cpc	r11, r1
    d514:	09 f4       	brne	.+2      	; 0xd518 <MenuOut+0x44>
    d516:	6a c1       	rjmp	.+724    	; 0xd7ec <MenuOut+0x318>
    d518:	22 24       	eor	r2, r2
    d51a:	33 24       	eor	r3, r3
    d51c:	18 86       	std	Y+8, r1	; 0x08
    d51e:	1f 82       	std	Y+7, r1	; 0x07
	int8_t Xs = 0;
	//--- ">>" Align right
	if(prc(CurrStr+0) == '>' && prc(CurrStr+1) == '>'){
		X0 = LCDXSz - strlen_P(CurrStr) + 2;
		Xs = X0-2;
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';
    d520:	80 e2       	ldi	r24, 0x20	; 32
    d522:	48 2e       	mov	r4, r24
	#if TypeLCD==840
		const MsgLine *Line=(MsgLine*)prp(&CurrMsg->LineList)+Y;
	#else
		const MsgLine *Line=CurrMsg->LineList+Y;		
	#endif
	PGM_P CurrStr=(PGM_P)(Line->Str);
    d524:	91 01       	movw	r18, r2
    d526:	22 0f       	add	r18, r18
    d528:	33 1f       	adc	r19, r19
    d52a:	3a 87       	std	Y+10, r19	; 0x0a
    d52c:	29 87       	std	Y+9, r18	; 0x09
    d52e:	49 01       	movw	r8, r18
    d530:	82 0c       	add	r8, r2
    d532:	93 1c       	adc	r9, r3
    d534:	64 01       	movw	r12, r8
    d536:	cc 0c       	add	r12, r12
    d538:	dd 1c       	adc	r13, r13
    d53a:	cc 0c       	add	r12, r12
    d53c:	dd 1c       	adc	r13, r13
    d53e:	cc 0c       	add	r12, r12
    d540:	dd 1c       	adc	r13, r13
    d542:	96 01       	movw	r18, r12
    d544:	22 19       	sub	r18, r2
    d546:	33 09       	sbc	r19, r3
    d548:	75 01       	movw	r14, r10
    d54a:	e2 0e       	add	r14, r18
    d54c:	f3 1e       	adc	r15, r19

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    d54e:	2b 5e       	subi	r18, 0xEB	; 235
    d550:	3f 4f       	sbci	r19, 0xFF	; 255
    d552:	c5 01       	movw	r24, r10
    d554:	82 0f       	add	r24, r18
    d556:	93 1f       	adc	r25, r19
    d558:	25 51       	subi	r18, 0x15	; 21
    d55a:	30 40       	sbci	r19, 0x00	; 0
    d55c:	fc 01       	movw	r30, r24
    d55e:	65 90       	lpm	r6, Z+
    d560:	74 90       	lpm	r7, Z+

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    d562:	f7 01       	movw	r30, r14
    d564:	84 91       	lpm	r24, Z+
	uint8_t X;
	uint8_t X0=0;
	uint8_t X1=LCDXSz;
	int8_t Xs = 0;
	//--- ">>" Align right
	if(prc(CurrStr+0) == '>' && prc(CurrStr+1) == '>'){
    d566:	8e 33       	cpi	r24, 0x3E	; 62
    d568:	09 f4       	brne	.+2      	; 0xd56c <MenuOut+0x98>
    d56a:	b3 c0       	rjmp	.+358    	; 0xd6d2 <MenuOut+0x1fe>
		X0 = LCDXSz - strlen_P(CurrStr) + 2;
		Xs = X0-2;
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';
    d56c:	90 e0       	ldi	r25, 0x00	; 0
    d56e:	00 e0       	ldi	r16, 0x00	; 0
    d570:	f7 01       	movw	r30, r14
    d572:	84 91       	lpm	r24, Z+
	}
	//--- "<<" Align left
	if(prc(CurrStr+0) == '<' && prc(CurrStr+1) == '<'){
    d574:	8c 33       	cpi	r24, 0x3C	; 60
    d576:	09 f4       	brne	.+2      	; 0xd57a <MenuOut+0xa6>
    d578:	cd c0       	rjmp	.+410    	; 0xd714 <MenuOut+0x240>
		X1 = strlen_P(CurrStr) - 2;
    d57a:	f4 e1       	ldi	r31, 0x14	; 20
    d57c:	5f 2e       	mov	r5, r31
    d57e:	f7 01       	movw	r30, r14
    d580:	84 91       	lpm	r24, Z+
		X0 = 0;
		Xs = X0-2;
	}
	//--- "<>" Align center
	if(prc(CurrStr+0) == '<' && prc(CurrStr+1) == '>'){
    d582:	8c 33       	cpi	r24, 0x3C	; 60
    d584:	09 f4       	brne	.+2      	; 0xd588 <MenuOut+0xb4>
    d586:	e6 c0       	rjmp	.+460    	; 0xd754 <MenuOut+0x280>
		X1 = X0 + (strlen_P(CurrStr) - 2);
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';		
	}
	//---

	for(X=X0; X<X1; X++){
    d588:	05 15       	cp	r16, r5
    d58a:	08 f0       	brcs	.+2      	; 0xd58e <MenuOut+0xba>
    d58c:	73 c0       	rjmp	.+230    	; 0xd674 <MenuOut+0x1a0>
		const MsgLine *Line=(MsgLine*)prp(&CurrMsg->LineList)+Y;
	#else
		const MsgLine *Line=CurrMsg->LineList+Y;		
	#endif
	PGM_P CurrStr=(PGM_P)(Line->Str);
	InField *IF = prp(&Line->IF_List);
    d58e:	73 01       	movw	r14, r6
    d590:	69 2e       	mov	r6, r25
    d592:	77 24       	eor	r7, r7
    d594:	67 fc       	sbrc	r6, 7
    d596:	70 94       	com	r7
    d598:	29 85       	ldd	r18, Y+9	; 0x09
    d59a:	3a 85       	ldd	r19, Y+10	; 0x0a
    d59c:	22 0d       	add	r18, r2
    d59e:	33 1d       	adc	r19, r3
    d5a0:	c9 01       	movw	r24, r18
    d5a2:	88 0f       	add	r24, r24
    d5a4:	99 1f       	adc	r25, r25
    d5a6:	88 0f       	add	r24, r24
    d5a8:	99 1f       	adc	r25, r25
    d5aa:	88 0f       	add	r24, r24
    d5ac:	99 1f       	adc	r25, r25
    d5ae:	6c 01       	movw	r12, r24
    d5b0:	c2 18       	sub	r12, r2
    d5b2:	d3 08       	sbc	r13, r3
			Param.Txt = prp(&IF->EnumList);
			PutField(prb(&IF->Type), prp(&IF->Var), &Param);
			IF++;
			X += Param.Size;
		}
		LCD_Buf[Y][X] = Char;
    d5b4:	4c 01       	movw	r8, r24
    d5b6:	82 1a       	sub	r8, r18
    d5b8:	93 0a       	sbc	r9, r19
    d5ba:	09 c0       	rjmp	.+18     	; 0xd5ce <MenuOut+0xfa>
    d5bc:	a8 0d       	add	r26, r8
    d5be:	b9 1d       	adc	r27, r9
    d5c0:	a8 5a       	subi	r26, 0xA8	; 168
    d5c2:	b9 4f       	sbci	r27, 0xF9	; 249
    d5c4:	1c 93       	st	X, r17
		X1 = X0 + (strlen_P(CurrStr) - 2);
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';		
	}
	//---

	for(X=X0; X<X1; X++){
    d5c6:	0f 5f       	subi	r16, 0xFF	; 255
    d5c8:	05 15       	cp	r16, r5
    d5ca:	08 f0       	brcs	.+2      	; 0xd5ce <MenuOut+0xfa>
    d5cc:	4f c0       	rjmp	.+158    	; 0xd66c <MenuOut+0x198>
		char Char;
		if((Char=prc(CurrStr+X-Xs))=='{') {
    d5ce:	a0 2f       	mov	r26, r16
    d5d0:	b0 e0       	ldi	r27, 0x00	; 0
    d5d2:	9d 01       	movw	r18, r26
    d5d4:	26 19       	sub	r18, r6
    d5d6:	37 09       	sbc	r19, r7
    d5d8:	f6 01       	movw	r30, r12
    d5da:	e2 0f       	add	r30, r18
    d5dc:	f3 1f       	adc	r31, r19
    d5de:	ea 0d       	add	r30, r10
    d5e0:	fb 1d       	adc	r31, r11
    d5e2:	14 91       	lpm	r17, Z+
    d5e4:	1b 37       	cpi	r17, 0x7B	; 123
    d5e6:	51 f7       	brne	.-44     	; 0xd5bc <MenuOut+0xe8>
			T_Param Param;
			Param.Pos = LCD_Buf[Y]+X;
    d5e8:	8f 81       	ldd	r24, Y+7	; 0x07
    d5ea:	98 85       	ldd	r25, Y+8	; 0x08
    d5ec:	a8 0f       	add	r26, r24
    d5ee:	b9 1f       	adc	r27, r25
    d5f0:	a8 5a       	subi	r26, 0xA8	; 168
    d5f2:	b9 4f       	sbci	r27, 0xF9	; 249
    d5f4:	ba 83       	std	Y+2, r27	; 0x02
    d5f6:	a9 83       	std	Y+1, r26	; 0x01
    d5f8:	81 e0       	ldi	r24, 0x01	; 1
    d5fa:	f9 01       	movw	r30, r18
    d5fc:	e8 0f       	add	r30, r24
    d5fe:	f1 1d       	adc	r31, r1
    d600:	ec 0d       	add	r30, r12
    d602:	fd 1d       	adc	r31, r13
    d604:	ea 0d       	add	r30, r10
    d606:	fb 1d       	adc	r31, r11
    d608:	14 91       	lpm	r17, Z+
    d60a:	98 2f       	mov	r25, r24
    d60c:	8f 5f       	subi	r24, 0xFF	; 255
			Param.Size = 0;
			while((Char=prc(CurrStr+X-Xs+ ++Param.Size))=='{');
    d60e:	1b 37       	cpi	r17, 0x7B	; 123
    d610:	a1 f3       	breq	.-24     	; 0xd5fa <MenuOut+0x126>
    d612:	9c 83       	std	Y+4, r25	; 0x04

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    d614:	e5 e0       	ldi	r30, 0x05	; 5
    d616:	f0 e0       	ldi	r31, 0x00	; 0
    d618:	ee 0e       	add	r14, r30
    d61a:	ff 1e       	adc	r15, r31
    d61c:	f7 01       	movw	r30, r14
    d61e:	84 91       	lpm	r24, Z+
    d620:	2b ef       	ldi	r18, 0xFB	; 251
    d622:	3f ef       	ldi	r19, 0xFF	; 255
    d624:	e2 0e       	add	r14, r18
    d626:	f3 1e       	adc	r15, r19
			Param.Prec = prb(&IF->Prec);
    d628:	8b 83       	std	Y+3, r24	; 0x03

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    d62a:	f7 01       	movw	r30, r14
    d62c:	33 96       	adiw	r30, 0x03	; 3
    d62e:	85 91       	lpm	r24, Z+
    d630:	94 91       	lpm	r25, Z+
			Param.Txt = prp(&IF->EnumList);
    d632:	9e 83       	std	Y+6, r25	; 0x06
    d634:	8d 83       	std	Y+5, r24	; 0x05

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    d636:	f7 01       	movw	r30, r14
    d638:	84 91       	lpm	r24, Z+

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    d63a:	31 96       	adiw	r30, 0x01	; 1
    d63c:	65 91       	lpm	r22, Z+
    d63e:	74 91       	lpm	r23, Z+
			PutField(prb(&IF->Type), prp(&IF->Var), &Param);
    d640:	ae 01       	movw	r20, r28
    d642:	4f 5f       	subi	r20, 0xFF	; 255
    d644:	5f 4f       	sbci	r21, 0xFF	; 255
    d646:	0e 94 89 66 	call	0xcd12	; 0xcd12 <PutField>
			IF++;
    d64a:	26 e0       	ldi	r18, 0x06	; 6
    d64c:	30 e0       	ldi	r19, 0x00	; 0
    d64e:	e2 0e       	add	r14, r18
    d650:	f3 1e       	adc	r15, r19
			X += Param.Size;
    d652:	8c 81       	ldd	r24, Y+4	; 0x04
    d654:	08 0f       	add	r16, r24
    d656:	a0 2f       	mov	r26, r16
    d658:	b0 e0       	ldi	r27, 0x00	; 0
		}
		LCD_Buf[Y][X] = Char;
    d65a:	a8 0d       	add	r26, r8
    d65c:	b9 1d       	adc	r27, r9
    d65e:	a8 5a       	subi	r26, 0xA8	; 168
    d660:	b9 4f       	sbci	r27, 0xF9	; 249
    d662:	1c 93       	st	X, r17
		X1 = X0 + (strlen_P(CurrStr) - 2);
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';		
	}
	//---

	for(X=X0; X<X1; X++){
    d664:	0f 5f       	subi	r16, 0xFF	; 255
    d666:	05 15       	cp	r16, r5
    d668:	08 f4       	brcc	.+2      	; 0xd66c <MenuOut+0x198>
    d66a:	b1 cf       	rjmp	.-158    	; 0xd5ce <MenuOut+0xfa>
    d66c:	a0 90 f5 04 	lds	r10, 0x04F5
    d670:	b0 90 f6 04 	lds	r11, 0x04F6
			X += Param.Size;
		}
		LCD_Buf[Y][X] = Char;
	}
	X=X1;
	for(;X<LCDXSz; X++) LCD_Buf[Y][X] = ' ';
    d674:	33 e1       	ldi	r19, 0x13	; 19
    d676:	35 15       	cp	r19, r5
    d678:	08 f0       	brcs	.+2      	; 0xd67c <MenuOut+0x1a8>
    d67a:	9f c0       	rjmp	.+318    	; 0xd7ba <MenuOut+0x2e6>
    d67c:	08 94       	sec
    d67e:	21 1c       	adc	r2, r1
    d680:	31 1c       	adc	r3, r1
    d682:	ef 81       	ldd	r30, Y+7	; 0x07
    d684:	f8 85       	ldd	r31, Y+8	; 0x08
    d686:	75 96       	adiw	r30, 0x15	; 21
    d688:	f8 87       	std	Y+8, r31	; 0x08
    d68a:	ef 83       	std	Y+7, r30	; 0x07
void
MenuOut(void)
{
	uint8_t Y;
	if(CurrMsg) {
		for(Y=0; Y<LCDYSz; PutMsgLine(Y++));
    d68c:	f4 e0       	ldi	r31, 0x04	; 4
    d68e:	2f 16       	cp	r2, r31
    d690:	31 04       	cpc	r3, r1
    d692:	09 f0       	breq	.+2      	; 0xd696 <MenuOut+0x1c2>
    d694:	47 cf       	rjmp	.-370    	; 0xd524 <MenuOut+0x50>
		EventFunc(&CurrMsg->Run);
    d696:	c5 01       	movw	r24, r10
    d698:	82 5a       	subi	r24, 0xA2	; 162
    d69a:	9f 4f       	sbci	r25, 0xFF	; 255
    d69c:	0e 94 c2 45 	call	0x8b84	; 0x8b84 <EventFunc>
	if(prb(&CurrPage->LineNumber)>LCDYSz || Fix<LCDYSz-1 || prp(&(GetLine+CurrLine)->OF_List))
		LCD_Buf[CurrLCD][0] = CharCursor;
	if(++Blink>16)
		Blink=0;
	EventFunc(&CurrPage->Run);
}
    d6a0:	2a 96       	adiw	r28, 0x0a	; 10
    d6a2:	0f b6       	in	r0, 0x3f	; 63
    d6a4:	f8 94       	cli
    d6a6:	de bf       	out	0x3e, r29	; 62
    d6a8:	0f be       	out	0x3f, r0	; 63
    d6aa:	cd bf       	out	0x3d, r28	; 61
    d6ac:	cf 91       	pop	r28
    d6ae:	df 91       	pop	r29
    d6b0:	1f 91       	pop	r17
    d6b2:	0f 91       	pop	r16
    d6b4:	ff 90       	pop	r15
    d6b6:	ef 90       	pop	r14
    d6b8:	df 90       	pop	r13
    d6ba:	cf 90       	pop	r12
    d6bc:	bf 90       	pop	r11
    d6be:	af 90       	pop	r10
    d6c0:	9f 90       	pop	r9
    d6c2:	8f 90       	pop	r8
    d6c4:	7f 90       	pop	r7
    d6c6:	6f 90       	pop	r6
    d6c8:	5f 90       	pop	r5
    d6ca:	4f 90       	pop	r4
    d6cc:	3f 90       	pop	r3
    d6ce:	2f 90       	pop	r2
    d6d0:	08 95       	ret

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    d6d2:	f9 01       	movw	r30, r18
    d6d4:	31 96       	adiw	r30, 0x01	; 1
    d6d6:	ea 0d       	add	r30, r10
    d6d8:	fb 1d       	adc	r31, r11
    d6da:	e4 91       	lpm	r30, Z+
	uint8_t X;
	uint8_t X0=0;
	uint8_t X1=LCDXSz;
	int8_t Xs = 0;
	//--- ">>" Align right
	if(prc(CurrStr+0) == '>' && prc(CurrStr+1) == '>'){
    d6dc:	ee 33       	cpi	r30, 0x3E	; 62
    d6de:	09 f0       	breq	.+2      	; 0xd6e2 <MenuOut+0x20e>
    d6e0:	45 cf       	rjmp	.-374    	; 0xd56c <MenuOut+0x98>
		X0 = LCDXSz - strlen_P(CurrStr) + 2;
    d6e2:	c7 01       	movw	r24, r14
    d6e4:	0e 94 03 8b 	call	0x11606	; 0x11606 <strlen_P>
    d6e8:	06 e1       	ldi	r16, 0x16	; 22
    d6ea:	08 1b       	sub	r16, r24
		Xs = X0-2;
    d6ec:	90 2f       	mov	r25, r16
    d6ee:	92 50       	subi	r25, 0x02	; 2
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';
    d6f0:	00 23       	and	r16, r16
    d6f2:	09 f4       	brne	.+2      	; 0xd6f6 <MenuOut+0x222>
    d6f4:	3d cf       	rjmp	.-390    	; 0xd570 <MenuOut+0x9c>
    d6f6:	f6 01       	movw	r30, r12
    d6f8:	e8 19       	sub	r30, r8
    d6fa:	f9 09       	sbc	r31, r9
    d6fc:	e8 5a       	subi	r30, 0xA8	; 168
    d6fe:	f9 4f       	sbci	r31, 0xF9	; 249
    d700:	80 e0       	ldi	r24, 0x00	; 0
    d702:	41 92       	st	Z+, r4
    d704:	8f 5f       	subi	r24, 0xFF	; 255
    d706:	80 17       	cp	r24, r16
    d708:	e0 f3       	brcs	.-8      	; 0xd702 <MenuOut+0x22e>
    d70a:	f7 01       	movw	r30, r14
    d70c:	84 91       	lpm	r24, Z+
	}
	//--- "<<" Align left
	if(prc(CurrStr+0) == '<' && prc(CurrStr+1) == '<'){
    d70e:	8c 33       	cpi	r24, 0x3C	; 60
    d710:	09 f0       	breq	.+2      	; 0xd714 <MenuOut+0x240>
    d712:	33 cf       	rjmp	.-410    	; 0xd57a <MenuOut+0xa6>
    d714:	e9 85       	ldd	r30, Y+9	; 0x09
    d716:	fa 85       	ldd	r31, Y+10	; 0x0a
    d718:	e2 0d       	add	r30, r2
    d71a:	f3 1d       	adc	r31, r3
    d71c:	ee 0f       	add	r30, r30
    d71e:	ff 1f       	adc	r31, r31
    d720:	ee 0f       	add	r30, r30
    d722:	ff 1f       	adc	r31, r31
    d724:	ee 0f       	add	r30, r30
    d726:	ff 1f       	adc	r31, r31
    d728:	e2 19       	sub	r30, r2
    d72a:	f3 09       	sbc	r31, r3
    d72c:	31 96       	adiw	r30, 0x01	; 1
    d72e:	ea 0d       	add	r30, r10
    d730:	fb 1d       	adc	r31, r11
    d732:	e4 91       	lpm	r30, Z+
    d734:	ec 33       	cpi	r30, 0x3C	; 60
    d736:	09 f0       	breq	.+2      	; 0xd73a <MenuOut+0x266>
    d738:	20 cf       	rjmp	.-448    	; 0xd57a <MenuOut+0xa6>
		X1 = strlen_P(CurrStr) - 2;
    d73a:	c7 01       	movw	r24, r14
    d73c:	0e 94 03 8b 	call	0x11606	; 0x11606 <strlen_P>
    d740:	ae ef       	ldi	r26, 0xFE	; 254
    d742:	5a 2e       	mov	r5, r26
    d744:	58 0e       	add	r5, r24
    d746:	9e ef       	ldi	r25, 0xFE	; 254
    d748:	00 e0       	ldi	r16, 0x00	; 0
    d74a:	f7 01       	movw	r30, r14
    d74c:	84 91       	lpm	r24, Z+
		X0 = 0;
		Xs = X0-2;
	}
	//--- "<>" Align center
	if(prc(CurrStr+0) == '<' && prc(CurrStr+1) == '>'){
    d74e:	8c 33       	cpi	r24, 0x3C	; 60
    d750:	09 f0       	breq	.+2      	; 0xd754 <MenuOut+0x280>
    d752:	1a cf       	rjmp	.-460    	; 0xd588 <MenuOut+0xb4>
    d754:	89 84       	ldd	r8, Y+9	; 0x09
    d756:	9a 84       	ldd	r9, Y+10	; 0x0a
    d758:	82 0c       	add	r8, r2
    d75a:	93 1c       	adc	r9, r3
    d75c:	64 01       	movw	r12, r8
    d75e:	cc 0c       	add	r12, r12
    d760:	dd 1c       	adc	r13, r13
    d762:	cc 0c       	add	r12, r12
    d764:	dd 1c       	adc	r13, r13
    d766:	cc 0c       	add	r12, r12
    d768:	dd 1c       	adc	r13, r13
    d76a:	f6 01       	movw	r30, r12
    d76c:	e2 19       	sub	r30, r2
    d76e:	f3 09       	sbc	r31, r3
    d770:	31 96       	adiw	r30, 0x01	; 1
    d772:	ea 0d       	add	r30, r10
    d774:	fb 1d       	adc	r31, r11
    d776:	e4 91       	lpm	r30, Z+
    d778:	ee 33       	cpi	r30, 0x3E	; 62
    d77a:	09 f0       	breq	.+2      	; 0xd77e <MenuOut+0x2aa>
    d77c:	05 cf       	rjmp	.-502    	; 0xd588 <MenuOut+0xb4>
		X0 = (LCDXSz - strlen_P(CurrStr) + 2) / 2;
    d77e:	c7 01       	movw	r24, r14
    d780:	0e 94 03 8b 	call	0x11606	; 0x11606 <strlen_P>
    d784:	26 e1       	ldi	r18, 0x16	; 22
    d786:	30 e0       	ldi	r19, 0x00	; 0
    d788:	28 1b       	sub	r18, r24
    d78a:	39 0b       	sbc	r19, r25
    d78c:	36 95       	lsr	r19
    d78e:	27 95       	ror	r18
    d790:	02 2f       	mov	r16, r18
		Xs = X0-2;
    d792:	92 2f       	mov	r25, r18
    d794:	92 50       	subi	r25, 0x02	; 2
		X1 = X0 + (strlen_P(CurrStr) - 2);
    d796:	6e ef       	ldi	r22, 0xFE	; 254
    d798:	56 2e       	mov	r5, r22
    d79a:	58 0e       	add	r5, r24
    d79c:	52 0e       	add	r5, r18
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';		
    d79e:	22 23       	and	r18, r18
    d7a0:	09 f4       	brne	.+2      	; 0xd7a4 <MenuOut+0x2d0>
    d7a2:	f2 ce       	rjmp	.-540    	; 0xd588 <MenuOut+0xb4>
    d7a4:	f6 01       	movw	r30, r12
    d7a6:	e8 19       	sub	r30, r8
    d7a8:	f9 09       	sbc	r31, r9
    d7aa:	e8 5a       	subi	r30, 0xA8	; 168
    d7ac:	f9 4f       	sbci	r31, 0xF9	; 249
    d7ae:	80 e0       	ldi	r24, 0x00	; 0
    d7b0:	41 92       	st	Z+, r4
    d7b2:	8f 5f       	subi	r24, 0xFF	; 255
    d7b4:	80 17       	cp	r24, r16
    d7b6:	e0 f3       	brcs	.-8      	; 0xd7b0 <MenuOut+0x2dc>
    d7b8:	e7 ce       	rjmp	.-562    	; 0xd588 <MenuOut+0xb4>
			X += Param.Size;
		}
		LCD_Buf[Y][X] = Char;
	}
	X=X1;
	for(;X<LCDXSz; X++) LCD_Buf[Y][X] = ' ';
    d7ba:	89 85       	ldd	r24, Y+9	; 0x09
    d7bc:	9a 85       	ldd	r25, Y+10	; 0x0a
    d7be:	82 0d       	add	r24, r2
    d7c0:	93 1d       	adc	r25, r3
    d7c2:	9c 01       	movw	r18, r24
    d7c4:	22 0f       	add	r18, r18
    d7c6:	33 1f       	adc	r19, r19
    d7c8:	22 0f       	add	r18, r18
    d7ca:	33 1f       	adc	r19, r19
    d7cc:	22 0f       	add	r18, r18
    d7ce:	33 1f       	adc	r19, r19
    d7d0:	28 1b       	sub	r18, r24
    d7d2:	39 0b       	sbc	r19, r25
    d7d4:	f9 01       	movw	r30, r18
    d7d6:	e5 0d       	add	r30, r5
    d7d8:	f1 1d       	adc	r31, r1
    d7da:	e8 5a       	subi	r30, 0xA8	; 168
    d7dc:	f9 4f       	sbci	r31, 0xF9	; 249
    d7de:	40 82       	st	Z, r4
    d7e0:	53 94       	inc	r5
    d7e2:	83 e1       	ldi	r24, 0x13	; 19
    d7e4:	85 15       	cp	r24, r5
    d7e6:	08 f4       	brcc	.+2      	; 0xd7ea <MenuOut+0x316>
    d7e8:	49 cf       	rjmp	.-366    	; 0xd67c <MenuOut+0x1a8>
    d7ea:	f4 cf       	rjmp	.-24     	; 0xd7d4 <MenuOut+0x300>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    d7ec:	40 91 d4 02 	lds	r20, 0x02D4
    d7f0:	50 91 d5 02 	lds	r21, 0x02D5
    d7f4:	4d 5f       	subi	r20, 0xFD	; 253
    d7f6:	5f 4f       	sbci	r21, 0xFF	; 255
    d7f8:	fa 01       	movw	r30, r20
    d7fa:	e4 90       	lpm	r14, Z+
    d7fc:	43 50       	subi	r20, 0x03	; 3
    d7fe:	50 40       	sbci	r21, 0x00	; 0
		for(Y=0; Y<LCDYSz; PutMsgLine(Y++));
		EventFunc(&CurrMsg->Run);
		return;
	}
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
    d800:	c0 90 ca 07 	lds	r12, 0x07CA
    d804:	d0 90 e8 08 	lds	r13, 0x08E8
	for(Y=0; Y<Fix; Y++)
    d808:	ee 20       	and	r14, r14
    d80a:	09 f4       	brne	.+2      	; 0xd80e <MenuOut+0x33a>
    d80c:	a6 c0       	rjmp	.+332    	; 0xd95a <MenuOut+0x486>
    d80e:	00 e0       	ldi	r16, 0x00	; 0
    d810:	10 e0       	ldi	r17, 0x00	; 0
// ~~~~~~~~~~~~~~~~~~
inline static void
PutBlankLine(uint8_t Y)
{
	uint8_t X=0;
	while(X<LCDXSz)	LCD_Buf[Y][X++] = ' ';
    d812:	80 e2       	ldi	r24, 0x20	; 32
    d814:	f8 2e       	mov	r15, r24
    d816:	4e 5f       	subi	r20, 0xFE	; 254
    d818:	5f 4f       	sbci	r21, 0xFF	; 255
    d81a:	fa 01       	movw	r30, r20
    d81c:	84 91       	lpm	r24, Z+
    d81e:	42 50       	subi	r20, 0x02	; 2
    d820:	50 40       	sbci	r21, 0x00	; 0
		return;
	}
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
    d822:	08 17       	cp	r16, r24
    d824:	08 f4       	brcc	.+2      	; 0xd828 <MenuOut+0x354>
    d826:	69 c0       	rjmp	.+210    	; 0xd8fa <MenuOut+0x426>
    d828:	c8 01       	movw	r24, r16
    d82a:	88 0f       	add	r24, r24
    d82c:	99 1f       	adc	r25, r25
    d82e:	80 0f       	add	r24, r16
    d830:	91 1f       	adc	r25, r17
    d832:	fc 01       	movw	r30, r24
    d834:	ee 0f       	add	r30, r30
    d836:	ff 1f       	adc	r31, r31
    d838:	ee 0f       	add	r30, r30
    d83a:	ff 1f       	adc	r31, r31
    d83c:	ee 0f       	add	r30, r30
    d83e:	ff 1f       	adc	r31, r31
    d840:	e8 1b       	sub	r30, r24
    d842:	f9 0b       	sbc	r31, r25
    d844:	e8 5a       	subi	r30, 0xA8	; 168
    d846:	f9 4f       	sbci	r31, 0xF9	; 249
    d848:	80 e0       	ldi	r24, 0x00	; 0
// ~~~~~~~~~~~~~~~~~~
inline static void
PutBlankLine(uint8_t Y)
{
	uint8_t X=0;
	while(X<LCDXSz)	LCD_Buf[Y][X++] = ' ';
    d84a:	f1 92       	st	Z+, r15
    d84c:	8f 5f       	subi	r24, 0xFF	; 255
    d84e:	84 31       	cpi	r24, 0x14	; 20
    d850:	e1 f7       	brne	.-8      	; 0xd84a <MenuOut+0x376>
	}
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Y, Y);
    d852:	0f 5f       	subi	r16, 0xFF	; 255
    d854:	1f 4f       	sbci	r17, 0xFF	; 255
		EventFunc(&CurrMsg->Run);
		return;
	}
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
    d856:	0e 15       	cp	r16, r14
    d858:	f0 f2       	brcs	.-68     	; 0xd816 <MenuOut+0x342>
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Y, Y);
	for(; Y<LCDYSz; Y++)
    d85a:	f3 e0       	ldi	r31, 0x03	; 3
    d85c:	fe 15       	cp	r31, r14
    d85e:	f0 f0       	brcs	.+60     	; 0xd89c <MenuOut+0x3c8>
    d860:	1e 2d       	mov	r17, r14
		EventFunc(&CurrMsg->Run);
		return;
	}
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
    d862:	fc 2c       	mov	r15, r12
    d864:	fd 18       	sub	r15, r13
    d866:	f1 0e       	add	r15, r17
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Y, Y);
	for(; Y<LCDYSz; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
    d868:	95 e1       	ldi	r25, 0x15	; 21
    d86a:	d9 2e       	mov	r13, r25
// ~~~~~~~~~~~~~~~~~~
inline static void
PutBlankLine(uint8_t Y)
{
	uint8_t X=0;
	while(X<LCDXSz)	LCD_Buf[Y][X++] = ' ';
    d86c:	00 e2       	ldi	r16, 0x20	; 32
    d86e:	4e 5f       	subi	r20, 0xFE	; 254
    d870:	5f 4f       	sbci	r21, 0xFF	; 255
    d872:	fa 01       	movw	r30, r20
    d874:	84 91       	lpm	r24, Z+
    d876:	42 50       	subi	r20, 0x02	; 2
    d878:	50 40       	sbci	r21, 0x00	; 0
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Y, Y);
	for(; Y<LCDYSz; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
    d87a:	18 17       	cp	r17, r24
    d87c:	08 f4       	brcc	.+2      	; 0xd880 <MenuOut+0x3ac>
    d87e:	4b c0       	rjmp	.+150    	; 0xd916 <MenuOut+0x442>
    d880:	1d 9d       	mul	r17, r13
    d882:	f0 01       	movw	r30, r0
    d884:	11 24       	eor	r1, r1
    d886:	e8 5a       	subi	r30, 0xA8	; 168
    d888:	f9 4f       	sbci	r31, 0xF9	; 249
    d88a:	80 e0       	ldi	r24, 0x00	; 0
// ~~~~~~~~~~~~~~~~~~
inline static void
PutBlankLine(uint8_t Y)
{
	uint8_t X=0;
	while(X<LCDXSz)	LCD_Buf[Y][X++] = ' ';
    d88c:	01 93       	st	Z+, r16
    d88e:	8f 5f       	subi	r24, 0xFF	; 255
    d890:	84 31       	cpi	r24, 0x14	; 20
    d892:	e1 f7       	brne	.-8      	; 0xd88c <MenuOut+0x3b8>
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Y, Y);
	for(; Y<LCDYSz; Y++)
    d894:	1f 5f       	subi	r17, 0xFF	; 255
    d896:	f3 94       	inc	r15
    d898:	14 30       	cpi	r17, 0x04	; 4
    d89a:	48 f3       	brcs	.-46     	; 0xd86e <MenuOut+0x39a>
    d89c:	4e 5f       	subi	r20, 0xFE	; 254
    d89e:	5f 4f       	sbci	r21, 0xFF	; 255
    d8a0:	fa 01       	movw	r30, r20
    d8a2:	84 91       	lpm	r24, Z+
    d8a4:	42 50       	subi	r20, 0x02	; 2
    d8a6:	50 40       	sbci	r21, 0x00	; 0
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Dist+Y, Y);
	if(prb(&CurrPage->LineNumber)>LCDYSz || Fix<LCDYSz-1 || prp(&(GetLine+CurrLine)->OF_List))
    d8a8:	85 30       	cpi	r24, 0x05	; 5
    d8aa:	20 f4       	brcc	.+8      	; 0xd8b4 <MenuOut+0x3e0>
    d8ac:	f2 e0       	ldi	r31, 0x02	; 2
    d8ae:	fe 15       	cp	r31, r14
    d8b0:	08 f4       	brcc	.+2      	; 0xd8b4 <MenuOut+0x3e0>
    d8b2:	3f c0       	rjmp	.+126    	; 0xd932 <MenuOut+0x45e>
		LCD_Buf[CurrLCD][0] = CharCursor;
    d8b4:	80 91 e8 08 	lds	r24, 0x08E8
    d8b8:	90 e0       	ldi	r25, 0x00	; 0
    d8ba:	9c 01       	movw	r18, r24
    d8bc:	22 0f       	add	r18, r18
    d8be:	33 1f       	adc	r19, r19
    d8c0:	28 0f       	add	r18, r24
    d8c2:	39 1f       	adc	r19, r25
    d8c4:	f9 01       	movw	r30, r18
    d8c6:	ee 0f       	add	r30, r30
    d8c8:	ff 1f       	adc	r31, r31
    d8ca:	ee 0f       	add	r30, r30
    d8cc:	ff 1f       	adc	r31, r31
    d8ce:	ee 0f       	add	r30, r30
    d8d0:	ff 1f       	adc	r31, r31
    d8d2:	e2 1b       	sub	r30, r18
    d8d4:	f3 0b       	sbc	r31, r19
    d8d6:	e8 5a       	subi	r30, 0xA8	; 168
    d8d8:	f9 4f       	sbci	r31, 0xF9	; 249
    d8da:	80 e1       	ldi	r24, 0x10	; 16
    d8dc:	80 83       	st	Z, r24
	if(++Blink>16)
    d8de:	80 91 18 09 	lds	r24, 0x0918
    d8e2:	8f 5f       	subi	r24, 0xFF	; 255
    d8e4:	80 93 18 09 	sts	0x0918, r24
    d8e8:	81 31       	cpi	r24, 0x11	; 17
    d8ea:	10 f0       	brcs	.+4      	; 0xd8f0 <MenuOut+0x41c>
		Blink=0;
    d8ec:	10 92 18 09 	sts	0x0918, r1
	EventFunc(&CurrPage->Run);
    d8f0:	ca 01       	movw	r24, r20
    d8f2:	08 96       	adiw	r24, 0x08	; 8
    d8f4:	0e 94 c2 45 	call	0x8b84	; 0x8b84 <EventFunc>
    d8f8:	d3 ce       	rjmp	.-602    	; 0xd6a0 <MenuOut+0x1cc>
	}
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Y, Y);
    d8fa:	80 2f       	mov	r24, r16
    d8fc:	60 2f       	mov	r22, r16
    d8fe:	0e 94 0e 68 	call	0xd01c	; 0xd01c <PutLine>
    d902:	40 91 d4 02 	lds	r20, 0x02D4
    d906:	50 91 d5 02 	lds	r21, 0x02D5
    d90a:	0f 5f       	subi	r16, 0xFF	; 255
    d90c:	1f 4f       	sbci	r17, 0xFF	; 255
		EventFunc(&CurrMsg->Run);
		return;
	}
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
    d90e:	0e 15       	cp	r16, r14
    d910:	08 f4       	brcc	.+2      	; 0xd914 <MenuOut+0x440>
    d912:	81 cf       	rjmp	.-254    	; 0xd816 <MenuOut+0x342>
    d914:	a2 cf       	rjmp	.-188    	; 0xd85a <MenuOut+0x386>
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Y, Y);
	for(; Y<LCDYSz; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Dist+Y, Y);
    d916:	8f 2d       	mov	r24, r15
    d918:	61 2f       	mov	r22, r17
    d91a:	0e 94 0e 68 	call	0xd01c	; 0xd01c <PutLine>
    d91e:	40 91 d4 02 	lds	r20, 0x02D4
    d922:	50 91 d5 02 	lds	r21, 0x02D5
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Y, Y);
	for(; Y<LCDYSz; Y++)
    d926:	1f 5f       	subi	r17, 0xFF	; 255
    d928:	f3 94       	inc	r15
    d92a:	14 30       	cpi	r17, 0x04	; 4
    d92c:	08 f4       	brcc	.+2      	; 0xd930 <MenuOut+0x45c>
    d92e:	9f cf       	rjmp	.-194    	; 0xd86e <MenuOut+0x39a>
    d930:	b5 cf       	rjmp	.-150    	; 0xd89c <MenuOut+0x3c8>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    d932:	fa 01       	movw	r30, r20
    d934:	65 91       	lpm	r22, Z+
    d936:	74 91       	lpm	r23, Z+
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Dist+Y, Y);
	if(prb(&CurrPage->LineNumber)>LCDYSz || Fix<LCDYSz-1 || prp(&(GetLine+CurrLine)->OF_List))
    d938:	80 91 ca 07 	lds	r24, 0x07CA
    d93c:	2b e1       	ldi	r18, 0x1B	; 27
    d93e:	82 9f       	mul	r24, r18
    d940:	c0 01       	movw	r24, r0
    d942:	11 24       	eor	r1, r1
    d944:	68 0f       	add	r22, r24
    d946:	79 1f       	adc	r23, r25
    d948:	69 5e       	subi	r22, 0xE9	; 233
    d94a:	7f 4f       	sbci	r23, 0xFF	; 255
    d94c:	fb 01       	movw	r30, r22
    d94e:	85 91       	lpm	r24, Z+
    d950:	94 91       	lpm	r25, Z+
    d952:	89 2b       	or	r24, r25
    d954:	09 f0       	breq	.+2      	; 0xd958 <MenuOut+0x484>
    d956:	ae cf       	rjmp	.-164    	; 0xd8b4 <MenuOut+0x3e0>
    d958:	c2 cf       	rjmp	.-124    	; 0xd8de <MenuOut+0x40a>
		EventFunc(&CurrMsg->Run);
		return;
	}
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
    d95a:	10 e0       	ldi	r17, 0x00	; 0
    d95c:	82 cf       	rjmp	.-252    	; 0xd862 <MenuOut+0x38e>

0000d95e <LCD_Sweep>:

// ~~~~~~~~~~~~
static void
LCD_Sweep(void)
{
	if(LCD_Rdy()) {
    d95e:	0e 94 c7 2f 	call	0x5f8e	; 0x5f8e <LCD_Rdy>
    d962:	88 23       	and	r24, r24
    d964:	09 f4       	brne	.+2      	; 0xd968 <LCD_Sweep+0xa>
    d966:	08 95       	ret
		MenuOut();
    d968:	0e 94 6a 6a 	call	0xd4d4	; 0xd4d4 <MenuOut>
		LCD_Out();
    d96c:	0e 94 dd 2f 	call	0x5fba	; 0x5fba <LCD_Out>
    d970:	08 95       	ret

0000d972 <strcpy_EE>:
	}//while
	return GSM_RxCharN;
}
// ~~~~~~~~~~~
//    EEPROM   RAM     '\0'    EEPROM
uint8_t strcpy_EE(char* str_RAM, uint8_t* str_EE){
    d972:	cf 92       	push	r12
    d974:	df 92       	push	r13
    d976:	ef 92       	push	r14
    d978:	ff 92       	push	r15
    d97a:	1f 93       	push	r17
    d97c:	cf 93       	push	r28
    d97e:	df 93       	push	r29
    d980:	6c 01       	movw	r12, r24
    d982:	7b 01       	movw	r14, r22
    d984:	10 e0       	ldi	r17, 0x00	; 0
    d986:	06 c0       	rjmp	.+12     	; 0xd994 <strcpy_EE+0x22>
	uint8_t i=0;
	while( (erb(&str_EE[i])!='\0') && (erb(&str_EE[i])!=' ') ){
    d988:	80 32       	cpi	r24, 0x20	; 32
    d98a:	69 f0       	breq	.+26     	; 0xd9a6 <strcpy_EE+0x34>
		str_RAM[i] = (char)erb(&str_EE[i]);
    d98c:	cc 0d       	add	r28, r12
    d98e:	dd 1d       	adc	r29, r13
    d990:	88 83       	st	Y, r24
		i++;
    d992:	1f 5f       	subi	r17, 0xFF	; 255
}
// ~~~~~~~~~~~
//    EEPROM   RAM     '\0'    EEPROM
uint8_t strcpy_EE(char* str_RAM, uint8_t* str_EE){
	uint8_t i=0;
	while( (erb(&str_EE[i])!='\0') && (erb(&str_EE[i])!=' ') ){
    d994:	c1 2f       	mov	r28, r17
    d996:	d0 e0       	ldi	r29, 0x00	; 0
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    d998:	c7 01       	movw	r24, r14
    d99a:	8c 0f       	add	r24, r28
    d99c:	9d 1f       	adc	r25, r29
    d99e:	0e 94 1d 8e 	call	0x11c3a	; 0x11c3a <__eerd_byte_m2560>
    d9a2:	88 23       	and	r24, r24
    d9a4:	89 f7       	brne	.-30     	; 0xd988 <strcpy_EE+0x16>
		str_RAM[i] = (char)erb(&str_EE[i]);
		i++;
	}
	return i;	
}
    d9a6:	81 2f       	mov	r24, r17
    d9a8:	df 91       	pop	r29
    d9aa:	cf 91       	pop	r28
    d9ac:	1f 91       	pop	r17
    d9ae:	ff 90       	pop	r15
    d9b0:	ef 90       	pop	r14
    d9b2:	df 90       	pop	r13
    d9b4:	cf 90       	pop	r12
    d9b6:	08 95       	ret

0000d9b8 <GSM_Cycle>:
	}//switch
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
void
GSM_Cycle(void)
{
    d9b8:	7f 92       	push	r7
    d9ba:	8f 92       	push	r8
    d9bc:	9f 92       	push	r9
    d9be:	af 92       	push	r10
    d9c0:	bf 92       	push	r11
    d9c2:	cf 92       	push	r12
    d9c4:	df 92       	push	r13
    d9c6:	ef 92       	push	r14
    d9c8:	ff 92       	push	r15
    d9ca:	0f 93       	push	r16
    d9cc:	1f 93       	push	r17
    d9ce:	df 93       	push	r29
    d9d0:	cf 93       	push	r28
    d9d2:	cd b7       	in	r28, 0x3d	; 61
    d9d4:	de b7       	in	r29, 0x3e	; 62
    d9d6:	65 97       	sbiw	r28, 0x15	; 21
    d9d8:	0f b6       	in	r0, 0x3f	; 63
    d9da:	f8 94       	cli
    d9dc:	de bf       	out	0x3e, r29	; 62
    d9de:	0f be       	out	0x3f, r0	; 63
    d9e0:	cd bf       	out	0x3d, r28	; 61
	switch(GSM_Control){
    d9e2:	80 91 d1 07 	lds	r24, 0x07D1
    d9e6:	88 23       	and	r24, r24
    d9e8:	d9 f4       	brne	.+54     	; 0xda20 <GSM_Cycle+0x68>
	else return 0;
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Auto(){

	switch(GSM_State){
    d9ea:	80 91 f6 06 	lds	r24, 0x06F6
    d9ee:	e8 2f       	mov	r30, r24
    d9f0:	f0 e0       	ldi	r31, 0x00	; 0
    d9f2:	ea 35       	cpi	r30, 0x5A	; 90
    d9f4:	f1 05       	cpc	r31, r1
    d9f6:	68 f1       	brcs	.+90     	; 0xda52 <GSM_Cycle+0x9a>
			break;	
		case GSM_CNTL_CONFIG:
			GSM_Config();
			break;								
	}
}
    d9f8:	65 96       	adiw	r28, 0x15	; 21
    d9fa:	0f b6       	in	r0, 0x3f	; 63
    d9fc:	f8 94       	cli
    d9fe:	de bf       	out	0x3e, r29	; 62
    da00:	0f be       	out	0x3f, r0	; 63
    da02:	cd bf       	out	0x3d, r28	; 61
    da04:	cf 91       	pop	r28
    da06:	df 91       	pop	r29
    da08:	1f 91       	pop	r17
    da0a:	0f 91       	pop	r16
    da0c:	ff 90       	pop	r15
    da0e:	ef 90       	pop	r14
    da10:	df 90       	pop	r13
    da12:	cf 90       	pop	r12
    da14:	bf 90       	pop	r11
    da16:	af 90       	pop	r10
    da18:	9f 90       	pop	r9
    da1a:	8f 90       	pop	r8
    da1c:	7f 90       	pop	r7
    da1e:	08 95       	ret
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
void
GSM_Cycle(void)
{
	switch(GSM_Control){
    da20:	82 30       	cpi	r24, 0x02	; 2
    da22:	51 f7       	brne	.-44     	; 0xd9f8 <GSM_Cycle+0x40>
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Manual(){}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Config(){
	switch(GSM_State){
    da24:	80 91 f6 06 	lds	r24, 0x06F6
    da28:	84 30       	cpi	r24, 0x04	; 4
    da2a:	11 f4       	brne	.+4      	; 0xda30 <GSM_Cycle+0x78>
    da2c:	0c 94 65 76 	jmp	0xecca	; 0xecca <GSM_Cycle+0x1312>
    da30:	85 30       	cpi	r24, 0x05	; 5
    da32:	b8 f0       	brcs	.+46     	; 0xda62 <GSM_Cycle+0xaa>
    da34:	86 30       	cpi	r24, 0x06	; 6
    da36:	11 f4       	brne	.+4      	; 0xda3c <GSM_Cycle+0x84>
    da38:	0c 94 2c 76 	jmp	0xec58	; 0xec58 <GSM_Cycle+0x12a0>
    da3c:	86 30       	cpi	r24, 0x06	; 6
    da3e:	48 f1       	brcs	.+82     	; 0xda92 <GSM_Cycle+0xda>
    da40:	87 30       	cpi	r24, 0x07	; 7
    da42:	11 f4       	brne	.+4      	; 0xda48 <GSM_Cycle+0x90>
    da44:	0c 94 1d 76 	jmp	0xec3a	; 0xec3a <GSM_Cycle+0x1282>
    da48:	88 30       	cpi	r24, 0x08	; 8
    da4a:	b1 f2       	breq	.-84     	; 0xd9f8 <GSM_Cycle+0x40>
			if(Timer16Stopp(TD_GSM)) GSM_State++;
			break;
		case GSM_FINISH:			
			break;
		default:
			GSM_State = GSM_CFG_START;
    da4c:	10 92 f6 06 	sts	0x06F6, r1
    da50:	d3 cf       	rjmp	.-90     	; 0xd9f8 <GSM_Cycle+0x40>
	else return 0;
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Auto(){

	switch(GSM_State){
    da52:	e4 50       	subi	r30, 0x04	; 4
    da54:	ff 4f       	sbci	r31, 0xFF	; 255
    da56:	ee 0f       	add	r30, r30
    da58:	ff 1f       	adc	r31, r31
    da5a:	05 90       	lpm	r0, Z+
    da5c:	f4 91       	lpm	r31, Z+
    da5e:	e0 2d       	mov	r30, r0
    da60:	19 94       	eijmp
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Manual(){}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Config(){
	switch(GSM_State){
    da62:	81 30       	cpi	r24, 0x01	; 1
    da64:	11 f4       	brne	.+4      	; 0xda6a <GSM_Cycle+0xb2>
    da66:	0c 94 52 76 	jmp	0xeca4	; 0xeca4 <GSM_Cycle+0x12ec>
    da6a:	81 30       	cpi	r24, 0x01	; 1
    da6c:	f0 f0       	brcs	.+60     	; 0xdaaa <GSM_Cycle+0xf2>
    da6e:	82 30       	cpi	r24, 0x02	; 2
    da70:	11 f4       	brne	.+4      	; 0xda76 <GSM_Cycle+0xbe>
    da72:	0c 94 42 76 	jmp	0xec84	; 0xec84 <GSM_Cycle+0x12cc>
    da76:	83 30       	cpi	r24, 0x03	; 3
    da78:	49 f7       	brne	.-46     	; 0xda4c <GSM_Cycle+0x94>
			break;
		case GSM_CFG_WAIT_AT_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_CFG_SEND_AT)) GSM_State++;
			break;
		case GSM_CFG_SEND_IPR:
			GSM_Execute_Command(AT_IPR9600, 100); GSM_State++;
    da7a:	80 e7       	ldi	r24, 0x70	; 112
    da7c:	94 e0       	ldi	r25, 0x04	; 4
    da7e:	64 e6       	ldi	r22, 0x64	; 100
    da80:	70 e0       	ldi	r23, 0x00	; 0
    da82:	0e 94 65 55 	call	0xaaca	; 0xaaca <GSM_Execute_Command>
    da86:	80 91 f6 06 	lds	r24, 0x06F6
    da8a:	8f 5f       	subi	r24, 0xFF	; 255
    da8c:	80 93 f6 06 	sts	0x06F6, r24
    da90:	b3 cf       	rjmp	.-154    	; 0xd9f8 <GSM_Cycle+0x40>
				StartTimer16(TD_GSM,200);
				GSM_State++;
			}
			break;
		case GSM_CFG_SEND_ATW:
			GSM_Execute_Command(AT_W, 100); GSM_State++;
    da92:	8c e7       	ldi	r24, 0x7C	; 124
    da94:	94 e0       	ldi	r25, 0x04	; 4
    da96:	64 e6       	ldi	r22, 0x64	; 100
    da98:	70 e0       	ldi	r23, 0x00	; 0
    da9a:	0e 94 65 55 	call	0xaaca	; 0xaaca <GSM_Execute_Command>
    da9e:	80 91 f6 06 	lds	r24, 0x06F6
    daa2:	8f 5f       	subi	r24, 0xFF	; 255
    daa4:	80 93 f6 06 	sts	0x06F6, r24
    daa8:	a7 cf       	rjmp	.-178    	; 0xd9f8 <GSM_Cycle+0x40>
inline static void GSM_Manual(){}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Config(){
	switch(GSM_State){
		case GSM_CFG_START:
			StartTimer16(TD_GSM,200);
    daaa:	80 91 e9 04 	lds	r24, 0x04E9
    daae:	68 ec       	ldi	r22, 0xC8	; 200
    dab0:	70 e0       	ldi	r23, 0x00	; 0
    dab2:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
		cli();
		PORTL|=(1<<PL5);
		sei();
	}
	void GSM_PWRCNTRL_ON(void){
		cli();
    dab6:	f8 94       	cli
		PORTL &= ~(1<<PL5);
    dab8:	80 91 0b 01 	lds	r24, 0x010B
    dabc:	8f 7d       	andi	r24, 0xDF	; 223
    dabe:	80 93 0b 01 	sts	0x010B, r24
		sei();
    dac2:	78 94       	sei
			GSM_PWRCNTRL_ON();
			GSM_State++;
    dac4:	80 91 f6 06 	lds	r24, 0x06F6
    dac8:	8f 5f       	subi	r24, 0xFF	; 255
    daca:	80 93 f6 06 	sts	0x06F6, r24
    dace:	94 cf       	rjmp	.-216    	; 0xd9f8 <GSM_Cycle+0x40>
			break;
		case GSM_SEND_CGMM:
			GSM_Execute_Command(AT_CGMM,5000*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CGMM_READ:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
    dad0:	80 91 e9 04 	lds	r24, 0x04E9
    dad4:	0e 94 96 25 	call	0x4b2c	; 0x4b2c <Timer16Stopp>
    dad8:	88 23       	and	r24, r24
    dada:	19 f0       	breq	.+6      	; 0xdae2 <GSM_Cycle+0x12a>
    dadc:	8a e4       	ldi	r24, 0x4A	; 74
    dade:	80 93 f6 06 	sts	0x06F6, r24
			if(GetStringFromFIFO()){
    dae2:	0e 94 10 42 	call	0x8420	; 0x8420 <GetStringFromFIFO>
    dae6:	88 23       	and	r24, r24
    dae8:	31 f1       	breq	.+76     	; 0xdb36 <GSM_Cycle+0x17e>
				if(!strcmp_P(GSM_RxStr, GSM_SIMCOM_SIM900R)) GSM_Modem = SIMCOM_SIM900R;
    daea:	81 ee       	ldi	r24, 0xE1	; 225
    daec:	97 e0       	ldi	r25, 0x07	; 7
    daee:	6b e5       	ldi	r22, 0x5B	; 91
    daf0:	73 e0       	ldi	r23, 0x03	; 3
    daf2:	0e 94 f3 8a 	call	0x115e6	; 0x115e6 <strcmp_P>
    daf6:	89 2b       	or	r24, r25
    daf8:	19 f4       	brne	.+6      	; 0xdb00 <GSM_Cycle+0x148>
    dafa:	81 e0       	ldi	r24, 0x01	; 1
    dafc:	80 93 34 07 	sts	0x0734, r24
				if(!strcmp_P(GSM_RxStr, GSM_SIMCOM_SIM800)) GSM_Modem = SIMCOM_SIM800;
    db00:	81 ee       	ldi	r24, 0xE1	; 225
    db02:	97 e0       	ldi	r25, 0x07	; 7
    db04:	6a e6       	ldi	r22, 0x6A	; 106
    db06:	73 e0       	ldi	r23, 0x03	; 3
    db08:	0e 94 f3 8a 	call	0x115e6	; 0x115e6 <strcmp_P>
    db0c:	89 2b       	or	r24, r25
    db0e:	19 f4       	brne	.+6      	; 0xdb16 <GSM_Cycle+0x15e>
    db10:	82 e0       	ldi	r24, 0x02	; 2
    db12:	80 93 34 07 	sts	0x0734, r24
				if(!strcmp_P(GSM_RxStr, GSM_SIMCOM_SIM800C)) GSM_Modem = SIMCOM_SIM800;
    db16:	81 ee       	ldi	r24, 0xE1	; 225
    db18:	97 e0       	ldi	r25, 0x07	; 7
    db1a:	68 e7       	ldi	r22, 0x78	; 120
    db1c:	73 e0       	ldi	r23, 0x03	; 3
    db1e:	0e 94 f3 8a 	call	0x115e6	; 0x115e6 <strcmp_P>
    db22:	89 2b       	or	r24, r25
    db24:	11 f0       	breq	.+4      	; 0xdb2a <GSM_Cycle+0x172>
    db26:	0c 94 e0 79 	jmp	0xf3c0	; 0xf3c0 <GSM_Cycle+0x1a08>
    db2a:	82 e0       	ldi	r24, 0x02	; 2
    db2c:	80 93 34 07 	sts	0x0734, r24
				//Add here new model GSM-modem
				if(GSM_Modem != NOT_RECOGNIZED) GSM_State = GSM_WAIT_CALL_READY;
    db30:	86 e0       	ldi	r24, 0x06	; 6
    db32:	80 93 f6 06 	sts	0x06F6, r24
			}
		case GSM_WAIT_CFUN:
			if(GSM_Wait_Response_P(URC_CFUN, GSM_ReStart1)) GSM_State++;
    db36:	8b e8       	ldi	r24, 0x8B	; 139
    db38:	93 e0       	ldi	r25, 0x03	; 3
    db3a:	6a e4       	ldi	r22, 0x4A	; 74
    db3c:	0e 94 0a 55 	call	0xaa14	; 0xaa14 <GSM_Wait_Response_P>
    db40:	88 23       	and	r24, r24
    db42:	09 f4       	brne	.+2      	; 0xdb46 <GSM_Cycle+0x18e>
    db44:	59 cf       	rjmp	.-334    	; 0xd9f8 <GSM_Cycle+0x40>
    db46:	80 91 f6 06 	lds	r24, 0x06F6
    db4a:	8f 5f       	subi	r24, 0xFF	; 255
    db4c:	80 93 f6 06 	sts	0x06F6, r24
    db50:	53 cf       	rjmp	.-346    	; 0xd9f8 <GSM_Cycle+0x40>
		case GSM_WAIT_R2D_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;

		case GSM_WAIT_R2D_CONNECT:
			if(GSM_Wait_Response_P(RESP_CONNECT, GSM_ReStart1)){ 				
    db52:	84 ef       	ldi	r24, 0xF4	; 244
    db54:	93 e0       	ldi	r25, 0x03	; 3
    db56:	6a e4       	ldi	r22, 0x4A	; 74
    db58:	0e 94 0a 55 	call	0xaa14	; 0xaa14 <GSM_Wait_Response_P>
    db5c:	88 23       	and	r24, r24
    db5e:	09 f4       	brne	.+2      	; 0xdb62 <GSM_Cycle+0x1aa>
    db60:	4b cf       	rjmp	.-362    	; 0xd9f8 <GSM_Cycle+0x40>
				GSM_State=GSM_ProtocolMode;
    db62:	82 e5       	ldi	r24, 0x52	; 82
    db64:	80 93 f6 06 	sts	0x06F6, r24
				StartTimer16(TD_timer_after_page_transfer,100);
    db68:	80 91 f1 04 	lds	r24, 0x04F1
    db6c:	64 e6       	ldi	r22, 0x64	; 100
    db6e:	70 e0       	ldi	r23, 0x00	; 0
    db70:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    db74:	8f ef       	ldi	r24, 0xFF	; 255
    db76:	80 93 3e 07 	sts	0x073E, r24
	GSM_RX_FIFO_End = 255;
    db7a:	80 93 53 06 	sts	0x0653, r24
	GSM_RxCharN = 0;
    db7e:	10 92 60 0b 	sts	0x0B60, r1
	GSM_RX_FIFOOverFlow = 0;
    db82:	10 92 13 09 	sts	0x0913, r1
	GSM_RX_FIFOMax = 0;
    db86:	10 92 19 09 	sts	0x0919, r1
    db8a:	36 cf       	rjmp	.-404    	; 0xd9f8 <GSM_Cycle+0x40>
			GSM_State=GSM_WAIT_R2D_CONNECT;
		
			break;

		case GSM_WAIT_R2D_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    db8c:	81 ef       	ldi	r24, 0xF1	; 241
    db8e:	93 e0       	ldi	r25, 0x03	; 3
    db90:	6a e4       	ldi	r22, 0x4A	; 74
    db92:	0e 94 0a 55 	call	0xaa14	; 0xaa14 <GSM_Wait_Response_P>
    db96:	88 23       	and	r24, r24
    db98:	09 f4       	brne	.+2      	; 0xdb9c <GSM_Cycle+0x1e4>
    db9a:	2e cf       	rjmp	.-420    	; 0xd9f8 <GSM_Cycle+0x40>
    db9c:	80 91 f6 06 	lds	r24, 0x06F6
    dba0:	8f 5f       	subi	r24, 0xFF	; 255
    dba2:	80 93 f6 06 	sts	0x06F6, r24
    dba6:	28 cf       	rjmp	.-432    	; 0xd9f8 <GSM_Cycle+0x40>
			break;

		//----  data mode
		case GSM_Return2dataMode:

			CommandModeDestination=0;
    dba8:	10 92 af 07 	sts	0x07AF, r1
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    dbac:	8f ef       	ldi	r24, 0xFF	; 255
    dbae:	80 93 3e 07 	sts	0x073E, r24
	GSM_RX_FIFO_End = 255;
    dbb2:	80 93 53 06 	sts	0x0653, r24
	GSM_RxCharN = 0;
    dbb6:	10 92 60 0b 	sts	0x0B60, r1
	GSM_RX_FIFOOverFlow = 0;
    dbba:	10 92 13 09 	sts	0x0913, r1
	GSM_RX_FIFOMax = 0;
    dbbe:	10 92 19 09 	sts	0x0919, r1
    dbc2:	e1 ee       	ldi	r30, 0xE1	; 225
    dbc4:	f7 e0       	ldi	r31, 0x07	; 7

			CommandModeDestination=0;
			InitFIFO();
			for(int i=0;i<GSM_RXSTR_SIZE;i++)
			{
				GSM_RxStr[i]=0;	
    dbc6:	11 92       	st	Z+, r1
		//----  data mode
		case GSM_Return2dataMode:

			CommandModeDestination=0;
			InitFIFO();
			for(int i=0;i<GSM_RXSTR_SIZE;i++)
    dbc8:	b8 e0       	ldi	r27, 0x08	; 8
    dbca:	e5 34       	cpi	r30, 0x45	; 69
    dbcc:	fb 07       	cpc	r31, r27
    dbce:	d9 f7       	brne	.-10     	; 0xdbc6 <GSM_Cycle+0x20e>
			{
				GSM_RxStr[i]=0;	
			}
			GSM_Execute_Command(ATO, 600*GSM_DEBUG_DELAY); //GSM_State++;
    dbd0:	81 e0       	ldi	r24, 0x01	; 1
    dbd2:	96 e0       	ldi	r25, 0x06	; 6
    dbd4:	68 e5       	ldi	r22, 0x58	; 88
    dbd6:	72 e0       	ldi	r23, 0x02	; 2
    dbd8:	0e 94 65 55 	call	0xaaca	; 0xaaca <GSM_Execute_Command>
			GSM_State=GSM_WAIT_R2D_CONNECT;
    dbdc:	89 e5       	ldi	r24, 0x59	; 89
    dbde:	80 93 f6 06 	sts	0x06F6, r24
    dbe2:	0a cf       	rjmp	.-492    	; 0xd9f8 <GSM_Cycle+0x40>
				StartTimer16(TD_GSM,1000);	// min 500ms after +++
				GSM_State++;
			}
			break;
		case GSM_WAIT_D2C_SWITCH_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) {
    dbe4:	81 ef       	ldi	r24, 0xF1	; 241
    dbe6:	93 e0       	ldi	r25, 0x03	; 3
    dbe8:	6a e4       	ldi	r22, 0x4A	; 74
    dbea:	0e 94 0a 55 	call	0xaa14	; 0xaa14 <GSM_Wait_Response_P>
    dbee:	88 23       	and	r24, r24
    dbf0:	09 f4       	brne	.+2      	; 0xdbf4 <GSM_Cycle+0x23c>
    dbf2:	02 cf       	rjmp	.-508    	; 0xd9f8 <GSM_Cycle+0x40>

				switch(CommandModeDestination){
    dbf4:	80 91 af 07 	lds	r24, 0x07AF
    dbf8:	82 30       	cpi	r24, 0x02	; 2
    dbfa:	11 f4       	brne	.+4      	; 0xdc00 <GSM_Cycle+0x248>
    dbfc:	0c 94 59 7a 	jmp	0xf4b2	; 0xf4b2 <GSM_Cycle+0x1afa>
    dc00:	83 30       	cpi	r24, 0x03	; 3
    dc02:	10 f0       	brcs	.+4      	; 0xdc08 <GSM_Cycle+0x250>
    dc04:	0c 94 c9 79 	jmp	0xf392	; 0xf392 <GSM_Cycle+0x19da>
    dc08:	81 30       	cpi	r24, 0x01	; 1
    dc0a:	11 f4       	brne	.+4      	; 0xdc10 <GSM_Cycle+0x258>
    dc0c:	0c 94 60 7a 	jmp	0xf4c0	; 0xf4c0 <GSM_Cycle+0x1b08>
						break;
					case 5:	
						GSM_State = GSM_SEND_CSQ;
						counter=0;	
						break;
					default:GSM_State = GSM_Return2dataMode;
    dc10:	87 e5       	ldi	r24, 0x57	; 87
    dc12:	80 93 f6 06 	sts	0x06F6, r24
    dc16:	f0 ce       	rjmp	.-544    	; 0xd9f8 <GSM_Cycle+0x40>
//IF WEB			WebClose();
			GSM_State++;

			break;
		case GSM_Swtch2CommandModePlus:
			if(Timer16Stopp(TD_GSM)){
    dc18:	80 91 e9 04 	lds	r24, 0x04E9
    dc1c:	0e 94 96 25 	call	0x4b2c	; 0x4b2c <Timer16Stopp>
    dc20:	88 23       	and	r24, r24
    dc22:	09 f4       	brne	.+2      	; 0xdc26 <GSM_Cycle+0x26e>
    dc24:	e9 ce       	rjmp	.-558    	; 0xd9f8 <GSM_Cycle+0x40>
    dc26:	e1 ee       	ldi	r30, 0xE1	; 225
    dc28:	f7 e0       	ldi	r31, 0x07	; 7
				for(int i=0;i<GSM_RXSTR_SIZE;i++)
				{
					GSM_RxStr[i]=0;	
    dc2a:	11 92       	st	Z+, r1
			GSM_State++;

			break;
		case GSM_Swtch2CommandModePlus:
			if(Timer16Stopp(TD_GSM)){
				for(int i=0;i<GSM_RXSTR_SIZE;i++)
    dc2c:	28 e0       	ldi	r18, 0x08	; 8
    dc2e:	e5 34       	cpi	r30, 0x45	; 69
    dc30:	f2 07       	cpc	r31, r18
    dc32:	d9 f7       	brne	.-10     	; 0xdc2a <GSM_Cycle+0x272>
				{
					GSM_RxStr[i]=0;	
				}
				sprintf_P(GSM_TxStr, ESC_SEQ);
    dc34:	00 d0       	rcall	.+0      	; 0xdc36 <GSM_Cycle+0x27e>
    dc36:	0f 92       	push	r0
    dc38:	0a e4       	ldi	r16, 0x4A	; 74
    dc3a:	1a e0       	ldi	r17, 0x0A	; 10
    dc3c:	ad b7       	in	r26, 0x3d	; 61
    dc3e:	be b7       	in	r27, 0x3e	; 62
    dc40:	12 96       	adiw	r26, 0x02	; 2
    dc42:	1c 93       	st	X, r17
    dc44:	0e 93       	st	-X, r16
    dc46:	11 97       	sbiw	r26, 0x01	; 1
    dc48:	8a e5       	ldi	r24, 0x5A	; 90
    dc4a:	94 e0       	ldi	r25, 0x04	; 4
    dc4c:	14 96       	adiw	r26, 0x04	; 4
    dc4e:	9c 93       	st	X, r25
    dc50:	8e 93       	st	-X, r24
    dc52:	13 97       	sbiw	r26, 0x03	; 3
    dc54:	0e 94 20 8c 	call	0x11840	; 0x11840 <sprintf_P>
				GSMTxSz = strlen(GSM_TxStr);
    dc58:	f8 01       	movw	r30, r16
    dc5a:	01 90       	ld	r0, Z+
    dc5c:	00 20       	and	r0, r0
    dc5e:	e9 f7       	brne	.-6      	; 0xdc5a <GSM_Cycle+0x2a2>
    dc60:	8f 01       	movw	r16, r30
    dc62:	01 50       	subi	r16, 0x01	; 1
    dc64:	10 40       	sbci	r17, 0x00	; 0
    dc66:	0a 54       	subi	r16, 0x4A	; 74
    dc68:	1a 40       	sbci	r17, 0x0A	; 10
    dc6a:	00 93 bb 07 	sts	0x07BB, r16
				GSM_SendFirstChar();
    dc6e:	0f 90       	pop	r0
    dc70:	0f 90       	pop	r0
    dc72:	0f 90       	pop	r0
    dc74:	0f 90       	pop	r0
    dc76:	0e 94 3a 43 	call	0x8674	; 0x8674 <GSM_SendFirstChar>
				StartTimer16(TD_GSM,1000);	// min 500ms after +++
    dc7a:	80 91 e9 04 	lds	r24, 0x04E9
    dc7e:	68 ee       	ldi	r22, 0xE8	; 232
    dc80:	73 e0       	ldi	r23, 0x03	; 3
    dc82:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
				GSM_State++;
    dc86:	80 91 f6 06 	lds	r24, 0x06F6
    dc8a:	8f 5f       	subi	r24, 0xFF	; 255
    dc8c:	80 93 f6 06 	sts	0x06F6, r24
    dc90:	b3 ce       	rjmp	.-666    	; 0xd9f8 <GSM_Cycle+0x40>
				GSM_State =GSM_ReStart1;
				break;
			}			
			break;
		case GSM_Swtch2CommandMode:
			StartTimer16(TD_GSM,100);	// min 1000ms before +++
    dc92:	80 91 e9 04 	lds	r24, 0x04E9
    dc96:	64 e6       	ldi	r22, 0x64	; 100
    dc98:	70 e0       	ldi	r23, 0x00	; 0
    dc9a:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
//IF WEB			WebClose();
			GSM_State++;
    dc9e:	80 91 f6 06 	lds	r24, 0x06F6
    dca2:	8f 5f       	subi	r24, 0xFF	; 255
    dca4:	80 93 f6 06 	sts	0x06F6, r24
    dca8:	a7 ce       	rjmp	.-690    	; 0xd9f8 <GSM_Cycle+0x40>
			}
			break;

		case GSM_DataMode:
			// -----    
			if(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){	// if FIFO not empty
    dcaa:	90 91 3e 07 	lds	r25, 0x073E
    dcae:	80 91 53 06 	lds	r24, 0x0653
    dcb2:	98 17       	cp	r25, r24
    dcb4:	11 f4       	brne	.+4      	; 0xdcba <GSM_Cycle+0x302>
    dcb6:	0c 94 af 78 	jmp	0xf15e	; 0xf15e <GSM_Cycle+0x17a6>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    dcba:	83 ec       	ldi	r24, 0xC3	; 195
    dcbc:	90 e0       	ldi	r25, 0x00	; 0
    dcbe:	0e 94 2b 8e 	call	0x11c56	; 0x11c56 <__eerd_word_m2560>
    dcc2:	bc 01       	movw	r22, r24
				StartTimer16(TD_TCP_Connect, erw(&TCP_CONNECT_timeout));	//   
    dcc4:	80 91 ea 04 	lds	r24, 0x04EA
    dcc8:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
    dccc:	95 ce       	rjmp	.-726    	; 0xd9f8 <GSM_Cycle+0x40>
		//------------------------

		//-----------

		case GSM_ProtocolMode:
			if( (strstr_P(GSM_RxStr, URC_CLOSED+2) != NULL) ){
    dcce:	81 ee       	ldi	r24, 0xE1	; 225
    dcd0:	97 e0       	ldi	r25, 0x07	; 7
    dcd2:	64 ed       	ldi	r22, 0xD4	; 212
    dcd4:	73 e0       	ldi	r23, 0x03	; 3
    dcd6:	0e 94 25 8b 	call	0x1164a	; 0x1164a <strstr_P>
    dcda:	89 2b       	or	r24, r25
    dcdc:	b1 f0       	breq	.+44     	; 0xdd0a <GSM_Cycle+0x352>
					GSM_State =GSM_ReStart1;
    dcde:	8a e4       	ldi	r24, 0x4A	; 74
    dce0:	80 93 f6 06 	sts	0x06F6, r24
    dce4:	89 ce       	rjmp	.-750    	; 0xd9f8 <GSM_Cycle+0x40>

			while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){	
					GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);
					if(GSM_RxCharN==2)
						{
							if(!strncmp_P(GSM_RxStr, PSTR("\r\n"), 2)) {GSM_RxCharN=0;}
    dce6:	81 ee       	ldi	r24, 0xE1	; 225
    dce8:	97 e0       	ldi	r25, 0x07	; 7
    dcea:	62 e3       	ldi	r22, 0x32	; 50
    dcec:	7e e3       	ldi	r23, 0x3E	; 62
    dcee:	42 e0       	ldi	r20, 0x02	; 2
    dcf0:	50 e0       	ldi	r21, 0x00	; 0
    dcf2:	0e 94 0c 8b 	call	0x11618	; 0x11618 <strncmp_P>
    dcf6:	89 2b       	or	r24, r25
    dcf8:	11 f4       	brne	.+4      	; 0xdcfe <GSM_Cycle+0x346>
    dcfa:	10 92 60 0b 	sts	0x0B60, r1
						}
					if(GSM_RxCharN >= 4){
    dcfe:	80 91 60 0b 	lds	r24, 0x0B60
    dd02:	84 30       	cpi	r24, 0x04	; 4
    dd04:	10 f0       	brcs	.+4      	; 0xdd0a <GSM_Cycle+0x352>
    dd06:	0c 94 23 78 	jmp	0xf046	; 0xf046 <GSM_Cycle+0x168e>
					break;
			}



			while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){	
    dd0a:	90 91 3e 07 	lds	r25, 0x073E
    dd0e:	80 91 53 06 	lds	r24, 0x0653
    dd12:	98 17       	cp	r25, r24
    dd14:	11 f4       	brne	.+4      	; 0xdd1a <GSM_Cycle+0x362>
    dd16:	0c 94 65 78 	jmp	0xf0ca	; 0xf0ca <GSM_Cycle+0x1712>
					GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);
    dd1a:	81 ee       	ldi	r24, 0xE1	; 225
    dd1c:	97 e0       	ldi	r25, 0x07	; 7
    dd1e:	60 e6       	ldi	r22, 0x60	; 96
    dd20:	7b e0       	ldi	r23, 0x0B	; 11
    dd22:	44 e6       	ldi	r20, 0x64	; 100
    dd24:	0e 94 a6 41 	call	0x834c	; 0x834c <GetByteFromFIFO>
					if(GSM_RxCharN==2)
    dd28:	80 91 60 0b 	lds	r24, 0x0B60
    dd2c:	82 30       	cpi	r24, 0x02	; 2
    dd2e:	39 f7       	brne	.-50     	; 0xdcfe <GSM_Cycle+0x346>
    dd30:	da cf       	rjmp	.-76     	; 0xdce6 <GSM_Cycle+0x32e>
						}
					}
				}
			break;
		case GSM_WAIT_CSQ_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) {
    dd32:	81 ef       	ldi	r24, 0xF1	; 241
    dd34:	93 e0       	ldi	r25, 0x03	; 3
    dd36:	6a e4       	ldi	r22, 0x4A	; 74
    dd38:	0e 94 0a 55 	call	0xaa14	; 0xaa14 <GSM_Wait_Response_P>
    dd3c:	88 23       	and	r24, r24
    dd3e:	09 f4       	brne	.+2      	; 0xdd42 <GSM_Cycle+0x38a>
    dd40:	5b ce       	rjmp	.-842    	; 0xd9f8 <GSM_Cycle+0x40>
				if(CommandModeDestination==5){
    dd42:	80 91 af 07 	lds	r24, 0x07AF
    dd46:	85 30       	cpi	r24, 0x05	; 5
    dd48:	11 f4       	brne	.+4      	; 0xdd4e <GSM_Cycle+0x396>
    dd4a:	0c 94 db 79 	jmp	0xf3b6	; 0xf3b6 <GSM_Cycle+0x19fe>
					GSM_State  = GSM_Return2dataMode;
				}
				else{
					GSM_State=GSM_SEND_CIPMUX;
    dd4e:	8a e2       	ldi	r24, 0x2A	; 42
    dd50:	80 93 f6 06 	sts	0x06F6, r24
    dd54:	51 ce       	rjmp	.-862    	; 0xd9f8 <GSM_Cycle+0x40>
				GSM_Execute_Command(AT_CSQ, 500*GSM_DEBUG_DELAY); 
				InitFIFO();
				GSM_State++;
			break;
		case GSM_WAIT_CSQ:
				if(Timer16Stopp(TD_GSM)){
    dd56:	80 91 e9 04 	lds	r24, 0x04E9
    dd5a:	0e 94 96 25 	call	0x4b2c	; 0x4b2c <Timer16Stopp>
    dd5e:	88 23       	and	r24, r24
    dd60:	11 f4       	brne	.+4      	; 0xdd66 <GSM_Cycle+0x3ae>
    dd62:	0c 94 4f 79 	jmp	0xf29e	; 0xf29e <GSM_Cycle+0x18e6>
						GSM_State = GSM_ReStart1;
    dd66:	8a e4       	ldi	r24, 0x4A	; 74
    dd68:	80 93 f6 06 	sts	0x06F6, r24
    dd6c:	45 ce       	rjmp	.-886    	; 0xd9f8 <GSM_Cycle+0x40>
			break;
		case GSM_ShutWait_:
			if(GSM_Wait_Response_P(RESP_SHUT_OK, GSM_ReStart1)) GSM_State++;
			break;
		case GSM_SEND_CGATT0:
			GSM_Execute_Command(AT_CGATT_0, 1000*GSM_DEBUG_DELAY); GSM_State++;
    dd6e:	8f ee       	ldi	r24, 0xEF	; 239
    dd70:	95 e0       	ldi	r25, 0x05	; 5
    dd72:	68 ee       	ldi	r22, 0xE8	; 232
    dd74:	73 e0       	ldi	r23, 0x03	; 3
    dd76:	0e 94 65 55 	call	0xaaca	; 0xaaca <GSM_Execute_Command>
    dd7a:	80 91 f6 06 	lds	r24, 0x06F6
    dd7e:	8f 5f       	subi	r24, 0xFF	; 255
    dd80:	80 93 f6 06 	sts	0x06F6, r24
    dd84:	39 ce       	rjmp	.-910    	; 0xd9f8 <GSM_Cycle+0x40>
			break;
		//------------------------    


		case GSM_SEND_ATD_Check_Ballance:	
			if(GSM_Flag & (1<<flg_TxCStr)){
    dd86:	80 91 d2 02 	lds	r24, 0x02D2
    dd8a:	80 ff       	sbrs	r24, 0
    dd8c:	4b c0       	rjmp	.+150    	; 0xde24 <GSM_Cycle+0x46c>
				sprintf_P(GSM_TxStr, AT_CUSD101);	
    dd8e:	00 d0       	rcall	.+0      	; 0xdd90 <GSM_Cycle+0x3d8>
    dd90:	0f 92       	push	r0
    dd92:	8a e4       	ldi	r24, 0x4A	; 74
    dd94:	9a e0       	ldi	r25, 0x0A	; 10
    dd96:	ad b7       	in	r26, 0x3d	; 61
    dd98:	be b7       	in	r27, 0x3e	; 62
    dd9a:	12 96       	adiw	r26, 0x02	; 2
    dd9c:	9c 93       	st	X, r25
    dd9e:	8e 93       	st	-X, r24
    dda0:	11 97       	sbiw	r26, 0x01	; 1
    dda2:	07 ec       	ldi	r16, 0xC7	; 199
    dda4:	14 e0       	ldi	r17, 0x04	; 4
    dda6:	14 96       	adiw	r26, 0x04	; 4
    dda8:	1c 93       	st	X, r17
    ddaa:	0e 93       	st	-X, r16
    ddac:	13 97       	sbiw	r26, 0x03	; 3
    ddae:	0e 94 20 8c 	call	0x11840	; 0x11840 <sprintf_P>
				GSMTxSz = strlen_P(AT_CUSD101);
    ddb2:	0f 90       	pop	r0
    ddb4:	0f 90       	pop	r0
    ddb6:	0f 90       	pop	r0
    ddb8:	0f 90       	pop	r0
    ddba:	c8 01       	movw	r24, r16
    ddbc:	0e 94 03 8b 	call	0x11606	; 0x11606 <strlen_P>
    ddc0:	80 93 bb 07 	sts	0x07BB, r24
				GSMTxSz += strcpy_EE(GSM_TxStr+GSMTxSz,GPRS_checkballancerequest);
    ddc4:	80 91 bb 07 	lds	r24, 0x07BB
    ddc8:	90 e0       	ldi	r25, 0x00	; 0
    ddca:	86 5b       	subi	r24, 0xB6	; 182
    ddcc:	95 4f       	sbci	r25, 0xF5	; 245
    ddce:	61 e3       	ldi	r22, 0x31	; 49
    ddd0:	70 e0       	ldi	r23, 0x00	; 0
    ddd2:	0e 94 b9 6c 	call	0xd972	; 0xd972 <strcpy_EE>
    ddd6:	90 91 bb 07 	lds	r25, 0x07BB
    ddda:	98 0f       	add	r25, r24
    dddc:	90 93 bb 07 	sts	0x07BB, r25
				GSM_TxStr[GSMTxSz]='"';
    dde0:	e0 91 bb 07 	lds	r30, 0x07BB
    dde4:	f0 e0       	ldi	r31, 0x00	; 0
    dde6:	e6 5b       	subi	r30, 0xB6	; 182
    dde8:	f5 4f       	sbci	r31, 0xF5	; 245
    ddea:	82 e2       	ldi	r24, 0x22	; 34
    ddec:	80 83       	st	Z, r24
				GSM_TxStr[GSMTxSz+1]='\r';
    ddee:	e0 91 bb 07 	lds	r30, 0x07BB
    ddf2:	f0 e0       	ldi	r31, 0x00	; 0
    ddf4:	e6 5b       	subi	r30, 0xB6	; 182
    ddf6:	f5 4f       	sbci	r31, 0xF5	; 245
    ddf8:	8d e0       	ldi	r24, 0x0D	; 13
    ddfa:	81 83       	std	Z+1, r24	; 0x01
				GSM_TxStr[GSMTxSz+2]='\n';
    ddfc:	e0 91 bb 07 	lds	r30, 0x07BB
    de00:	f0 e0       	ldi	r31, 0x00	; 0
    de02:	e6 5b       	subi	r30, 0xB6	; 182
    de04:	f5 4f       	sbci	r31, 0xF5	; 245
    de06:	8a e0       	ldi	r24, 0x0A	; 10
    de08:	82 83       	std	Z+2, r24	; 0x02
				GSMTxSz+=3;
    de0a:	80 91 bb 07 	lds	r24, 0x07BB
    de0e:	8d 5f       	subi	r24, 0xFD	; 253
    de10:	80 93 bb 07 	sts	0x07BB, r24
				GSM_SendFirstChar();
    de14:	0e 94 3a 43 	call	0x8674	; 0x8674 <GSM_SendFirstChar>
				StartTimer16(TD_GSM, 1000);
    de18:	80 91 e9 04 	lds	r24, 0x04E9
    de1c:	68 ee       	ldi	r22, 0xE8	; 232
    de1e:	73 e0       	ldi	r23, 0x03	; 3
    de20:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
			}
			GSM_State++;	
    de24:	80 91 f6 06 	lds	r24, 0x06F6
    de28:	8f 5f       	subi	r24, 0xFF	; 255
    de2a:	80 93 f6 06 	sts	0x06F6, r24
			GSM_Temp = 0;
    de2e:	10 92 db 05 	sts	0x05DB, r1
    de32:	e2 cd       	rjmp	.-1084   	; 0xd9f8 <GSM_Cycle+0x40>
			SetIP(&GSM_ClientIP,0,0,0,0);
			GSM_Flag |=(1<<flg_TxCStr);
			GSM_State++;
			break;
		case GSM_ReStart2:
			if(Timer16Stopp(TD_GSM)){
    de34:	80 91 e9 04 	lds	r24, 0x04E9
    de38:	0e 94 96 25 	call	0x4b2c	; 0x4b2c <Timer16Stopp>
    de3c:	88 23       	and	r24, r24
    de3e:	09 f4       	brne	.+2      	; 0xde42 <GSM_Cycle+0x48a>
    de40:	db cd       	rjmp	.-1098   	; 0xd9f8 <GSM_Cycle+0x40>
				GSM_State = GSM_PowerOn;
    de42:	10 92 f6 06 	sts	0x06F6, r1
    de46:	d8 cd       	rjmp	.-1104   	; 0xd9f8 <GSM_Cycle+0x40>
		//------------------------

		
		//------------------------
		case GSM_ReStart1:
			GSM_ReStartN++;
    de48:	80 91 35 09 	lds	r24, 0x0935
    de4c:	8f 5f       	subi	r24, 0xFF	; 255
    de4e:	80 93 35 09 	sts	0x0935, r24
		cli();
		DDRL|=(1<<PL5);
		sei();
	}
	void GSM_PWRCNTRL_OFF(void){
		cli();
    de52:	f8 94       	cli
		PORTL|=(1<<PL5);
    de54:	80 91 0b 01 	lds	r24, 0x010B
    de58:	80 62       	ori	r24, 0x20	; 32
    de5a:	80 93 0b 01 	sts	0x010B, r24
		sei();
    de5e:	78 94       	sei
			GSM_PWRCNTRL_OFF();
			StartTimer16(TD_GSM,1000);
    de60:	80 91 e9 04 	lds	r24, 0x04E9
    de64:	68 ee       	ldi	r22, 0xE8	; 232
    de66:	73 e0       	ldi	r23, 0x03	; 3
    de68:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
			RxBufOverFlow = 0;
    de6c:	10 92 49 0b 	sts	0x0B49, r1
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    de70:	8f ef       	ldi	r24, 0xFF	; 255
    de72:	80 93 3e 07 	sts	0x073E, r24
	GSM_RX_FIFO_End = 255;
    de76:	80 93 53 06 	sts	0x0653, r24
	GSM_RxCharN = 0;
    de7a:	10 92 60 0b 	sts	0x0B60, r1
	GSM_RX_FIFOOverFlow = 0;
    de7e:	10 92 13 09 	sts	0x0913, r1
	GSM_RX_FIFOMax = 0;
    de82:	10 92 19 09 	sts	0x0919, r1
    de86:	e1 ee       	ldi	r30, 0xE1	; 225
    de88:	f7 e0       	ldi	r31, 0x07	; 7
			RxBufOverFlow = 0;
		//	WebSession=0;
			InitFIFO();
			for(int i=0;i<GSM_RXSTR_SIZE;i++)
			{
				GSM_RxStr[i]=0;	
    de8a:	11 92       	st	Z+, r1
			GSM_PWRCNTRL_OFF();
			StartTimer16(TD_GSM,1000);
			RxBufOverFlow = 0;
		//	WebSession=0;
			InitFIFO();
			for(int i=0;i<GSM_RXSTR_SIZE;i++)
    de8c:	28 e0       	ldi	r18, 0x08	; 8
    de8e:	e5 34       	cpi	r30, 0x45	; 69
    de90:	f2 07       	cpc	r31, r18
    de92:	d9 f7       	brne	.-10     	; 0xde8a <GSM_Cycle+0x4d2>
			{
				GSM_RxStr[i]=0;	
			}
			SMS_FlgSz_Out = 0;	// ..          -  
    de94:	10 92 c9 07 	sts	0x07C9, r1
			GSM_ActiveConnection = NO_CONNECTION;
    de98:	8f ef       	ldi	r24, 0xFF	; 255
    de9a:	80 93 d3 02 	sts	0x02D3, r24
	uint8_t IP4;
} IP_Addr;

//~~~~~~~~~~~~~~
void SetIP(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	IP->IP1 = IP1;
    de9e:	10 92 4a 0b 	sts	0x0B4A, r1
	IP->IP2 = IP2;
    dea2:	10 92 4b 0b 	sts	0x0B4B, r1
	IP->IP3 = IP3;
    dea6:	10 92 4c 0b 	sts	0x0B4C, r1
	IP->IP4 = IP4;
    deaa:	10 92 4d 0b 	sts	0x0B4D, r1
			SetIP(&GSM_ClientIP,0,0,0,0);
			GSM_Flag |=(1<<flg_TxCStr);
    deae:	80 91 d2 02 	lds	r24, 0x02D2
    deb2:	81 60       	ori	r24, 0x01	; 1
    deb4:	80 93 d2 02 	sts	0x02D2, r24
			GSM_State++;
    deb8:	80 91 f6 06 	lds	r24, 0x06F6
    debc:	8f 5f       	subi	r24, 0xFF	; 255
    debe:	80 93 f6 06 	sts	0x06F6, r24
    dec2:	9a cd       	rjmp	.-1228   	; 0xd9f8 <GSM_Cycle+0x40>
			break;
		case GSM_SEND_CGATT0:
			GSM_Execute_Command(AT_CGATT_0, 1000*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CGATT0_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    dec4:	81 ef       	ldi	r24, 0xF1	; 241
    dec6:	93 e0       	ldi	r25, 0x03	; 3
    dec8:	6a e4       	ldi	r22, 0x4A	; 74
    deca:	0e 94 0a 55 	call	0xaa14	; 0xaa14 <GSM_Wait_Response_P>
    dece:	88 23       	and	r24, r24
    ded0:	09 f4       	brne	.+2      	; 0xded4 <GSM_Cycle+0x51c>
    ded2:	92 cd       	rjmp	.-1244   	; 0xd9f8 <GSM_Cycle+0x40>
				StartTimer16(TD_GSM, 1000);
    ded4:	80 91 e9 04 	lds	r24, 0x04E9
    ded8:	68 ee       	ldi	r22, 0xE8	; 232
    deda:	73 e0       	ldi	r23, 0x03	; 3
    dedc:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
			 	GSM_State = GSM_SEND_ATD_Check_Ballance;
    dee0:	8c e4       	ldi	r24, 0x4C	; 76
    dee2:	80 93 f6 06 	sts	0x06F6, r24
    dee6:	88 cd       	rjmp	.-1264   	; 0xd9f8 <GSM_Cycle+0x40>
			break;
		case GSM_WAIT_ATD_Check_Ballance_OK:
			if(GSM_Wait_Response_P(RESP_OK,GSM_SEND_CSQ)) GSM_State++;
			break;
		case GSM_WAIT_Ballance:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_SEND_CSQ;
    dee8:	80 91 e9 04 	lds	r24, 0x04E9
    deec:	0e 94 96 25 	call	0x4b2c	; 0x4b2c <Timer16Stopp>
    def0:	88 23       	and	r24, r24
    def2:	19 f0       	breq	.+6      	; 0xdefa <GSM_Cycle+0x542>
    def4:	8f e4       	ldi	r24, 0x4F	; 79
    def6:	80 93 f6 06 	sts	0x06F6, r24
			GSM_RxStr[GSM_RXSTR_SIZE-1]='\0';
    defa:	10 92 44 08 	sts	0x0844, r1
		
				GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);

				if(GSM_RxCharN >= 90){

					GSM_State = GSM_SEND_CSQ;
    defe:	1f e4       	ldi	r17, 0x4F	; 79
			if(GSM_Wait_Response_P(RESP_OK,GSM_SEND_CSQ)) GSM_State++;
			break;
		case GSM_WAIT_Ballance:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_SEND_CSQ;
			GSM_RxStr[GSM_RXSTR_SIZE-1]='\0';
			while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    df00:	90 91 3e 07 	lds	r25, 0x073E
    df04:	80 91 53 06 	lds	r24, 0x0653
    df08:	98 17       	cp	r25, r24
    df0a:	09 f4       	brne	.+2      	; 0xdf0e <GSM_Cycle+0x556>
    df0c:	f4 c6       	rjmp	.+3560   	; 0xecf6 <GSM_Cycle+0x133e>
				
		
				GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);
    df0e:	81 ee       	ldi	r24, 0xE1	; 225
    df10:	97 e0       	ldi	r25, 0x07	; 7
    df12:	60 e6       	ldi	r22, 0x60	; 96
    df14:	7b e0       	ldi	r23, 0x0B	; 11
    df16:	44 e6       	ldi	r20, 0x64	; 100
    df18:	0e 94 a6 41 	call	0x834c	; 0x834c <GetByteFromFIFO>

				if(GSM_RxCharN >= 90){
    df1c:	80 91 60 0b 	lds	r24, 0x0B60
    df20:	8a 35       	cpi	r24, 0x5A	; 90
    df22:	70 f3       	brcs	.-36     	; 0xdf00 <GSM_Cycle+0x548>

					GSM_State = GSM_SEND_CSQ;
    df24:	10 93 f6 06 	sts	0x06F6, r17
    df28:	eb cf       	rjmp	.-42     	; 0xdf00 <GSM_Cycle+0x548>
			}
			GSM_State++;	
			GSM_Temp = 0;
			break;
		case GSM_WAIT_ATD_Check_Ballance_OK:
			if(GSM_Wait_Response_P(RESP_OK,GSM_SEND_CSQ)) GSM_State++;
    df2a:	81 ef       	ldi	r24, 0xF1	; 241
    df2c:	93 e0       	ldi	r25, 0x03	; 3
    df2e:	6f e4       	ldi	r22, 0x4F	; 79
    df30:	0e 94 0a 55 	call	0xaa14	; 0xaa14 <GSM_Wait_Response_P>
    df34:	88 23       	and	r24, r24
    df36:	09 f4       	brne	.+2      	; 0xdf3a <GSM_Cycle+0x582>
    df38:	5f cd       	rjmp	.-1346   	; 0xd9f8 <GSM_Cycle+0x40>
    df3a:	80 91 f6 06 	lds	r24, 0x06F6
    df3e:	8f 5f       	subi	r24, 0xFF	; 255
    df40:	80 93 f6 06 	sts	0x06F6, r24
    df44:	59 cd       	rjmp	.-1358   	; 0xd9f8 <GSM_Cycle+0x40>
			}	
			break;

		//------------------------   GSM-
		case GSM_SEND_CSQ:
				GSM_Execute_Command(AT_CSQ, 500*GSM_DEBUG_DELAY); 
    df46:	8a ef       	ldi	r24, 0xFA	; 250
    df48:	95 e0       	ldi	r25, 0x05	; 5
    df4a:	64 ef       	ldi	r22, 0xF4	; 244
    df4c:	71 e0       	ldi	r23, 0x01	; 1
    df4e:	0e 94 65 55 	call	0xaaca	; 0xaaca <GSM_Execute_Command>
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    df52:	8f ef       	ldi	r24, 0xFF	; 255
    df54:	80 93 3e 07 	sts	0x073E, r24
	GSM_RX_FIFO_End = 255;
    df58:	80 93 53 06 	sts	0x0653, r24
	GSM_RxCharN = 0;
    df5c:	10 92 60 0b 	sts	0x0B60, r1
	GSM_RX_FIFOOverFlow = 0;
    df60:	10 92 13 09 	sts	0x0913, r1
	GSM_RX_FIFOMax = 0;
    df64:	10 92 19 09 	sts	0x0919, r1

		//------------------------   GSM-
		case GSM_SEND_CSQ:
				GSM_Execute_Command(AT_CSQ, 500*GSM_DEBUG_DELAY); 
				InitFIFO();
				GSM_State++;
    df68:	80 91 f6 06 	lds	r24, 0x06F6
    df6c:	8f 5f       	subi	r24, 0xFF	; 255
    df6e:	80 93 f6 06 	sts	0x06F6, r24
    df72:	42 cd       	rjmp	.-1404   	; 0xd9f8 <GSM_Cycle+0x40>
			break;
		case GSM_WAIT_SMS_Inv:
			if(GSM_Wait_Char('>', GSM_ReStart1)) GSM_State++;
			break;
		case GSM_SEND_SMS_DATA:
			SMS_Data_Out[SMS_FlgSz_Out] = 0x1A;	// SMS Data end - char Ctrl-Z
    df74:	60 91 c9 07 	lds	r22, 0x07C9
    df78:	e6 2f       	mov	r30, r22
    df7a:	f0 e0       	ldi	r31, 0x00	; 0
    df7c:	e6 5b       	subi	r30, 0xB6	; 182
    df7e:	f8 4f       	sbci	r31, 0xF8	; 248
    df80:	8a e1       	ldi	r24, 0x1A	; 26
    df82:	80 83       	st	Z, r24
			GSM_SendData((uint8_t *)SMS_Data_Out, SMS_FlgSz_Out+1);
    df84:	6f 5f       	subi	r22, 0xFF	; 255
    df86:	8a e4       	ldi	r24, 0x4A	; 74
    df88:	97 e0       	ldi	r25, 0x07	; 7
    df8a:	0e 94 e8 4a 	call	0x95d0	; 0x95d0 <GSM_SendData>
			GSM_State++;
    df8e:	80 91 f6 06 	lds	r24, 0x06F6
    df92:	8f 5f       	subi	r24, 0xFF	; 255
    df94:	80 93 f6 06 	sts	0x06F6, r24
    df98:	2f cd       	rjmp	.-1442   	; 0xd9f8 <GSM_Cycle+0x40>
					}					
				}
			}
			break;
		case GSM_WAIT_SMS_Inv:
			if(GSM_Wait_Char('>', GSM_ReStart1)) GSM_State++;
    df9a:	8e e3       	ldi	r24, 0x3E	; 62
    df9c:	6a e4       	ldi	r22, 0x4A	; 74
    df9e:	0e 94 18 43 	call	0x8630	; 0x8630 <GSM_Wait_Char>
    dfa2:	88 23       	and	r24, r24
    dfa4:	09 f4       	brne	.+2      	; 0xdfa8 <GSM_Cycle+0x5f0>
    dfa6:	28 cd       	rjmp	.-1456   	; 0xd9f8 <GSM_Cycle+0x40>
    dfa8:	80 91 f6 06 	lds	r24, 0x06F6
    dfac:	8f 5f       	subi	r24, 0xFF	; 255
    dfae:	80 93 f6 06 	sts	0x06F6, r24
    dfb2:	22 cd       	rjmp	.-1468   	; 0xd9f8 <GSM_Cycle+0x40>
			}
			break;

		//------------------------
		case GSM_SEND_CMGS:
			if(GSM_Flag & (1<<flg_TxCStr)){			
    dfb4:	80 91 d2 02 	lds	r24, 0x02D2
    dfb8:	80 ff       	sbrs	r24, 0
    dfba:	1e cd       	rjmp	.-1476   	; 0xd9f8 <GSM_Cycle+0x40>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    dfbc:	4a e4       	ldi	r20, 0x4A	; 74
    dfbe:	e4 2e       	mov	r14, r20
    dfc0:	4a e0       	ldi	r20, 0x0A	; 10
    dfc2:	f4 2e       	mov	r15, r20
    dfc4:	60 91 dc 05 	lds	r22, 0x05DC
    dfc8:	8d e0       	ldi	r24, 0x0D	; 13
    dfca:	68 9f       	mul	r22, r24
    dfcc:	b0 01       	movw	r22, r0
    dfce:	11 24       	eor	r1, r1
    dfd0:	6b 53       	subi	r22, 0x3B	; 59
    dfd2:	7f 4f       	sbci	r23, 0xFF	; 255
    dfd4:	c7 01       	movw	r24, r14
    dfd6:	4d e0       	ldi	r20, 0x0D	; 13
    dfd8:	50 e0       	ldi	r21, 0x00	; 0
    dfda:	0e 94 0d 8e 	call	0x11c1a	; 0x11c1a <__eerd_block_m2560>
				erbl(GSM_TxStr, SMS_Number+TempNum, MaxTelephN);
				GSMTxSz = strlen(GSM_TxStr);
    dfde:	f7 01       	movw	r30, r14
    dfe0:	01 90       	ld	r0, Z+
    dfe2:	00 20       	and	r0, r0
    dfe4:	e9 f7       	brne	.-6      	; 0xdfe0 <GSM_Cycle+0x628>
    dfe6:	31 97       	sbiw	r30, 0x01	; 1
    dfe8:	ee 19       	sub	r30, r14
    dfea:	ff 09       	sbc	r31, r15
    dfec:	e0 93 bb 07 	sts	0x07BB, r30
				uint8_t j=0;
				for(uint8_t i=0; i<GSMTxSz; i++)
    dff0:	80 91 bb 07 	lds	r24, 0x07BB
    dff4:	88 23       	and	r24, r24
    dff6:	99 f0       	breq	.+38     	; 0xe01e <GSM_Cycle+0x666>
    dff8:	90 e0       	ldi	r25, 0x00	; 0
    dffa:	20 e0       	ldi	r18, 0x00	; 0
					if(GSM_TxStr[i] != '0') j++;
    dffc:	e9 2f       	mov	r30, r25
    dffe:	f0 e0       	ldi	r31, 0x00	; 0
    e000:	e6 5b       	subi	r30, 0xB6	; 182
    e002:	f5 4f       	sbci	r31, 0xF5	; 245
    e004:	80 81       	ld	r24, Z
    e006:	80 33       	cpi	r24, 0x30	; 48
    e008:	09 f0       	breq	.+2      	; 0xe00c <GSM_Cycle+0x654>
    e00a:	2f 5f       	subi	r18, 0xFF	; 255
		case GSM_SEND_CMGS:
			if(GSM_Flag & (1<<flg_TxCStr)){			
				erbl(GSM_TxStr, SMS_Number+TempNum, MaxTelephN);
				GSMTxSz = strlen(GSM_TxStr);
				uint8_t j=0;
				for(uint8_t i=0; i<GSMTxSz; i++)
    e00c:	9f 5f       	subi	r25, 0xFF	; 255
    e00e:	80 91 bb 07 	lds	r24, 0x07BB
    e012:	98 17       	cp	r25, r24
    e014:	98 f3       	brcs	.-26     	; 0xdffc <GSM_Cycle+0x644>
					if(GSM_TxStr[i] != '0') j++;
				if(j){
    e016:	22 23       	and	r18, r18
    e018:	11 f0       	breq	.+4      	; 0xe01e <GSM_Cycle+0x666>
    e01a:	0c 94 01 7a 	jmp	0xf402	; 0xf402 <GSM_Cycle+0x1a4a>
					GSM_SendFirstChar();
					StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
					GSM_State++;
				}
				else{
					TempNum++;
    e01e:	80 91 dc 05 	lds	r24, 0x05DC
    e022:	8f 5f       	subi	r24, 0xFF	; 255
    e024:	80 93 dc 05 	sts	0x05DC, r24
					if(TempNum>=MaxTelephDirSz){
    e028:	83 30       	cpi	r24, 0x03	; 3
    e02a:	08 f4       	brcc	.+2      	; 0xe02e <GSM_Cycle+0x676>
    e02c:	e5 cc       	rjmp	.-1590   	; 0xd9f8 <GSM_Cycle+0x40>
						//StartTimer16(TD_GSM,150);

						GSM_State = GSM_Return2dataMode;
    e02e:	87 e5       	ldi	r24, 0x57	; 87
    e030:	80 93 f6 06 	sts	0x06F6, r24
				
						SMS_FlgSz_Out = 0;
    e034:	10 92 c9 07 	sts	0x07C9, r1
    e038:	df cc       	rjmp	.-1602   	; 0xd9f8 <GSM_Cycle+0x40>
			break;

		case GSM_AnalyzeURC:			//  
			
			// 
			if( (strstr_P(GSM_RxStr, URC_CLOSED+2) != NULL) ){
    e03a:	01 ee       	ldi	r16, 0xE1	; 225
    e03c:	17 e0       	ldi	r17, 0x07	; 7
    e03e:	c8 01       	movw	r24, r16
    e040:	64 ed       	ldi	r22, 0xD4	; 212
    e042:	73 e0       	ldi	r23, 0x03	; 3
    e044:	0e 94 25 8b 	call	0x1164a	; 0x1164a <strstr_P>
    e048:	89 2b       	or	r24, r25
    e04a:	11 f4       	brne	.+4      	; 0xe050 <GSM_Cycle+0x698>
    e04c:	0c 94 65 7a 	jmp	0xf4ca	; 0xf4ca <GSM_Cycle+0x1b12>
				GSM_State =GSM_ReStart1;
    e050:	8a e4       	ldi	r24, 0x4A	; 74
    e052:	80 93 f6 06 	sts	0x06F6, r24
    e056:	d0 cc       	rjmp	.-1632   	; 0xd9f8 <GSM_Cycle+0x40>
		//------------------------


		//------------------------
		case GSM_CIPSHUT_:
			GSM_Execute_Command(AT_CIPSHUT, 1000*GSM_DEBUG_DELAY); GSM_State++;
    e058:	84 ee       	ldi	r24, 0xE4	; 228
    e05a:	95 e0       	ldi	r25, 0x05	; 5
    e05c:	68 ee       	ldi	r22, 0xE8	; 232
    e05e:	73 e0       	ldi	r23, 0x03	; 3
    e060:	0e 94 65 55 	call	0xaaca	; 0xaaca <GSM_Execute_Command>
    e064:	80 91 f6 06 	lds	r24, 0x06F6
    e068:	8f 5f       	subi	r24, 0xFF	; 255
    e06a:	80 93 f6 06 	sts	0x06F6, r24
    e06e:	c4 cc       	rjmp	.-1656   	; 0xd9f8 <GSM_Cycle+0x40>
			break;
		case GSM_ShutWait_:
			if(GSM_Wait_Response_P(RESP_SHUT_OK, GSM_ReStart1)) GSM_State++;
    e070:	89 e4       	ldi	r24, 0x49	; 73
    e072:	94 e0       	ldi	r25, 0x04	; 4
    e074:	6a e4       	ldi	r22, 0x4A	; 74
    e076:	0e 94 0a 55 	call	0xaa14	; 0xaa14 <GSM_Wait_Response_P>
    e07a:	88 23       	and	r24, r24
    e07c:	09 f4       	brne	.+2      	; 0xe080 <GSM_Cycle+0x6c8>
    e07e:	bc cc       	rjmp	.-1672   	; 0xd9f8 <GSM_Cycle+0x40>
    e080:	80 91 f6 06 	lds	r24, 0x06F6
    e084:	8f 5f       	subi	r24, 0xFF	; 255
    e086:	80 93 f6 06 	sts	0x06F6, r24
    e08a:	b6 cc       	rjmp	.-1684   	; 0xd9f8 <GSM_Cycle+0x40>
			SMS_Data_Out[SMS_FlgSz_Out] = 0x1A;	// SMS Data end - char Ctrl-Z
			GSM_SendData((uint8_t *)SMS_Data_Out, SMS_FlgSz_Out+1);
			GSM_State++;
			break;		
		case GSM_WAIT_CMGS_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    e08c:	81 ef       	ldi	r24, 0xF1	; 241
    e08e:	93 e0       	ldi	r25, 0x03	; 3
    e090:	6a e4       	ldi	r22, 0x4A	; 74
    e092:	0e 94 0a 55 	call	0xaa14	; 0xaa14 <GSM_Wait_Response_P>
    e096:	88 23       	and	r24, r24
    e098:	09 f4       	brne	.+2      	; 0xe09c <GSM_Cycle+0x6e4>
    e09a:	ae cc       	rjmp	.-1700   	; 0xd9f8 <GSM_Cycle+0x40>
				if(++TempNum>=MaxTelephDirSz){
    e09c:	80 91 dc 05 	lds	r24, 0x05DC
    e0a0:	8f 5f       	subi	r24, 0xFF	; 255
    e0a2:	80 93 dc 05 	sts	0x05DC, r24
    e0a6:	83 30       	cpi	r24, 0x03	; 3
    e0a8:	10 f4       	brcc	.+4      	; 0xe0ae <GSM_Cycle+0x6f6>
    e0aa:	0c 94 c4 79 	jmp	0xf388	; 0xf388 <GSM_Cycle+0x19d0>
					GSM_State = GSM_Return2dataMode;
    e0ae:	87 e5       	ldi	r24, 0x57	; 87
    e0b0:	80 93 f6 06 	sts	0x06F6, r24
					SMS_FlgSz_Out = 0;
    e0b4:	10 92 c9 07 	sts	0x07C9, r1
    e0b8:	9f cc       	rjmp	.-1730   	; 0xd9f8 <GSM_Cycle+0x40>
				counter=1;

			}
			#endif	

			if(GetStringFromFIFO()){
    e0ba:	0e 94 10 42 	call	0x8420	; 0x8420 <GetStringFromFIFO>
    e0be:	88 23       	and	r24, r24
    e0c0:	09 f4       	brne	.+2      	; 0xe0c4 <GSM_Cycle+0x70c>
    e0c2:	9a cc       	rjmp	.-1740   	; 0xd9f8 <GSM_Cycle+0x40>
				GSM_State = GSM_AnalyzeURC;
    e0c4:	8f e3       	ldi	r24, 0x3F	; 63
    e0c6:	80 93 f6 06 	sts	0x06F6, r24
				TempNum = 0;
    e0ca:	10 92 dc 05 	sts	0x05DC, r1
    e0ce:	94 cc       	rjmp	.-1752   	; 0xd9f8 <GSM_Cycle+0x40>
			GSM_SendFirstChar();
			GSM_State = GSM_WAIT_PLAY_CONFIRM_FILE_OK;
			StartTimer16(TD_GSM, 2000);
			break;
		case GSM_WAIT_PLAY_CONFIRM_FILE_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_WAIT_PLAY_CONFIRM_FILE_OK)) 
    e0d0:	81 ef       	ldi	r24, 0xF1	; 241
    e0d2:	93 e0       	ldi	r25, 0x03	; 3
    e0d4:	6e e1       	ldi	r22, 0x1E	; 30
    e0d6:	0e 94 0a 55 	call	0xaa14	; 0xaa14 <GSM_Wait_Response_P>
    e0da:	88 23       	and	r24, r24
    e0dc:	09 f4       	brne	.+2      	; 0xe0e0 <GSM_Cycle+0x728>
    e0de:	8c cc       	rjmp	.-1768   	; 0xd9f8 <GSM_Cycle+0x40>
				{
					GSM_State = GSM_WAIT_PLAY_CONFIRM_FILE_CREC_0;
    e0e0:	8f e1       	ldi	r24, 0x1F	; 31
    e0e2:	80 93 f6 06 	sts	0x06F6, r24
					StartTimer16(TD_GSM, 20000);
    e0e6:	80 91 e9 04 	lds	r24, 0x04E9
    e0ea:	60 e2       	ldi	r22, 0x20	; 32
    e0ec:	7e e4       	ldi	r23, 0x4E	; 78
    e0ee:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
    e0f2:	82 cc       	rjmp	.-1788   	; 0xd9f8 <GSM_Cycle+0x40>
			}

			break;

		case GSM_SEND_PLAY_CONFIRM_FILE: 
			ConfirmState = 1;
    e0f4:	81 e0       	ldi	r24, 0x01	; 1
    e0f6:	80 93 e1 02 	sts	0x02E1, r24
			sprintf_P(GSM_TxStr, PSTR("AT+CREC=4,\"C:\\User\\Confirm.amr\",0,100\r"));
    e0fa:	00 d0       	rcall	.+0      	; 0xe0fc <GSM_Cycle+0x744>
    e0fc:	0f 92       	push	r0
    e0fe:	8a e4       	ldi	r24, 0x4A	; 74
    e100:	9a e0       	ldi	r25, 0x0A	; 10
    e102:	ed b7       	in	r30, 0x3d	; 61
    e104:	fe b7       	in	r31, 0x3e	; 62
    e106:	92 83       	std	Z+2, r25	; 0x02
    e108:	81 83       	std	Z+1, r24	; 0x01
    e10a:	89 eb       	ldi	r24, 0xB9	; 185
    e10c:	9e e3       	ldi	r25, 0x3E	; 62
    e10e:	94 83       	std	Z+4, r25	; 0x04
    e110:	83 83       	std	Z+3, r24	; 0x03
    e112:	0e 94 20 8c 	call	0x11840	; 0x11840 <sprintf_P>
			GSMTxSz=38;
    e116:	86 e2       	ldi	r24, 0x26	; 38
    e118:	80 93 bb 07 	sts	0x07BB, r24
			GSM_SendFirstChar();
    e11c:	0f 90       	pop	r0
    e11e:	0f 90       	pop	r0
    e120:	0f 90       	pop	r0
    e122:	0f 90       	pop	r0
    e124:	0e 94 3a 43 	call	0x8674	; 0x8674 <GSM_SendFirstChar>
			GSM_State = GSM_WAIT_PLAY_CONFIRM_FILE_OK;
    e128:	8e e1       	ldi	r24, 0x1E	; 30
    e12a:	80 93 f6 06 	sts	0x06F6, r24
			StartTimer16(TD_GSM, 2000);
    e12e:	80 91 e9 04 	lds	r24, 0x04E9
    e132:	60 ed       	ldi	r22, 0xD0	; 208
    e134:	77 e0       	ldi	r23, 0x07	; 7
    e136:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
    e13a:	5e cc       	rjmp	.-1860   	; 0xd9f8 <GSM_Cycle+0x40>
			GSM_State = GSM_WAIT_CREC_0;
			StartTimer16(TD_GSM, 1000);
			GSM_SendFirstChar();
			break;
		case GSM_WAIT_CREC_0:
			if(GetStringFromFIFO()){
    e13c:	0e 94 10 42 	call	0x8420	; 0x8420 <GetStringFromFIFO>
    e140:	88 23       	and	r24, r24
    e142:	09 f4       	brne	.+2      	; 0xe146 <GSM_Cycle+0x78e>
    e144:	8c c6       	rjmp	.+3352   	; 0xee5e <GSM_Cycle+0x14a6>
				if((strstr_P(GSM_RxStr, PSTR("+CREC: 0")) != NULL) ){
    e146:	81 ee       	ldi	r24, 0xE1	; 225
    e148:	97 e0       	ldi	r25, 0x07	; 7
    e14a:	60 ee       	ldi	r22, 0xE0	; 224
    e14c:	7e e3       	ldi	r23, 0x3E	; 62
    e14e:	0e 94 25 8b 	call	0x1164a	; 0x1164a <strstr_P>
    e152:	89 2b       	or	r24, r25
    e154:	09 f4       	brne	.+2      	; 0xe158 <GSM_Cycle+0x7a0>
    e156:	83 c6       	rjmp	.+3334   	; 0xee5e <GSM_Cycle+0x14a6>
					GSM_State = GSM_SEND_PLAY_CONFIRM_FILE;
    e158:	8d e1       	ldi	r24, 0x1D	; 29
    e15a:	80 93 f6 06 	sts	0x06F6, r24
    e15e:	4c cc       	rjmp	.-1896   	; 0xd9f8 <GSM_Cycle+0x40>
				}
			}

			break;
		case GSM_SEND_CREC_5:
			sprintf_P(GSM_TxStr, PSTR("AT+CREC=5\r"));
    e160:	00 d0       	rcall	.+0      	; 0xe162 <GSM_Cycle+0x7aa>
    e162:	0f 92       	push	r0
    e164:	8a e4       	ldi	r24, 0x4A	; 74
    e166:	9a e0       	ldi	r25, 0x0A	; 10
    e168:	ad b7       	in	r26, 0x3d	; 61
    e16a:	be b7       	in	r27, 0x3e	; 62
    e16c:	12 96       	adiw	r26, 0x02	; 2
    e16e:	9c 93       	st	X, r25
    e170:	8e 93       	st	-X, r24
    e172:	11 97       	sbiw	r26, 0x01	; 1
    e174:	89 ee       	ldi	r24, 0xE9	; 233
    e176:	9e e3       	ldi	r25, 0x3E	; 62
    e178:	14 96       	adiw	r26, 0x04	; 4
    e17a:	9c 93       	st	X, r25
    e17c:	8e 93       	st	-X, r24
    e17e:	13 97       	sbiw	r26, 0x03	; 3
    e180:	0e 94 20 8c 	call	0x11840	; 0x11840 <sprintf_P>
			GSMTxSz=10;
    e184:	8a e0       	ldi	r24, 0x0A	; 10
    e186:	80 93 bb 07 	sts	0x07BB, r24
			GSM_State = GSM_WAIT_CREC_0;
    e18a:	8c e1       	ldi	r24, 0x1C	; 28
    e18c:	80 93 f6 06 	sts	0x06F6, r24
			StartTimer16(TD_GSM, 1000);
    e190:	0f 90       	pop	r0
    e192:	0f 90       	pop	r0
    e194:	0f 90       	pop	r0
    e196:	0f 90       	pop	r0
    e198:	80 91 e9 04 	lds	r24, 0x04E9
    e19c:	68 ee       	ldi	r22, 0xE8	; 232
    e19e:	73 e0       	ldi	r23, 0x03	; 3
    e1a0:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
			GSM_SendFirstChar();
    e1a4:	0e 94 3a 43 	call	0x8674	; 0x8674 <GSM_SendFirstChar>
    e1a8:	27 cc       	rjmp	.-1970   	; 0xd9f8 <GSM_Cycle+0x40>
			if(Timer16Stopp(TD_GSM)){
				GSM_State = GSM_WAIT_MESSAGE;
			}
			break;
		case GSM_WAIT_CONFIRMRESPONSE:
			if(GetStringFromFIFO()){
    e1aa:	0e 94 10 42 	call	0x8420	; 0x8420 <GetStringFromFIFO>
    e1ae:	88 23       	and	r24, r24
    e1b0:	11 f0       	breq	.+4      	; 0xe1b6 <GSM_Cycle+0x7fe>
    e1b2:	0c 94 8f 79 	jmp	0xf31e	; 0xf31e <GSM_Cycle+0x1966>
						StartTimer16(TD_GSM,2000);
						GSM_State = GSM_WAIT_DISCONNECT_CAUSE;
						
					}
			}
			if(Timer16Stopp(TD_GSM)){
    e1b6:	80 91 e9 04 	lds	r24, 0x04E9
    e1ba:	0e 94 96 25 	call	0x4b2c	; 0x4b2c <Timer16Stopp>
    e1be:	88 23       	and	r24, r24
    e1c0:	09 f4       	brne	.+2      	; 0xe1c4 <GSM_Cycle+0x80c>
    e1c2:	1a cc       	rjmp	.-1996   	; 0xd9f8 <GSM_Cycle+0x40>
				if(RequestRepeatCounter<4){
    e1c4:	80 91 e2 02 	lds	r24, 0x02E2
    e1c8:	84 30       	cpi	r24, 0x04	; 4
    e1ca:	10 f0       	brcs	.+4      	; 0xe1d0 <GSM_Cycle+0x818>
    e1cc:	0c 94 bf 79 	jmp	0xf37e	; 0xf37e <GSM_Cycle+0x19c6>
				GSM_State = GSM_SEND_PLAY_ALARM_FILE;
    e1d0:	84 e1       	ldi	r24, 0x14	; 20
    e1d2:	80 93 f6 06 	sts	0x06F6, r24
    e1d6:	10 cc       	rjmp	.-2016   	; 0xd9f8 <GSM_Cycle+0x40>
					GSM_State = GSM_WAIT_PLAY_CONFIRMREQUEST_FILE_CREC_0;
					StartTimer16(TD_GSM, 20000);
				}
			break;
		case GSM_WAIT_PLAY_CONFIRMREQUEST_FILE_CREC_0:
			if(GetStringFromFIFO()){
    e1d8:	0e 94 10 42 	call	0x8420	; 0x8420 <GetStringFromFIFO>
    e1dc:	88 23       	and	r24, r24
    e1de:	09 f4       	brne	.+2      	; 0xe1e2 <GSM_Cycle+0x82a>
    e1e0:	51 c6       	rjmp	.+3234   	; 0xee84 <GSM_Cycle+0x14cc>
				if((strstr_P(GSM_RxStr, PSTR("+CREC: 0")) != NULL) ){
    e1e2:	81 ee       	ldi	r24, 0xE1	; 225
    e1e4:	97 e0       	ldi	r25, 0x07	; 7
    e1e6:	64 e2       	ldi	r22, 0x24	; 36
    e1e8:	7f e3       	ldi	r23, 0x3F	; 63
    e1ea:	0e 94 25 8b 	call	0x1164a	; 0x1164a <strstr_P>
    e1ee:	89 2b       	or	r24, r25
    e1f0:	09 f4       	brne	.+2      	; 0xe1f4 <GSM_Cycle+0x83c>
    e1f2:	42 c6       	rjmp	.+3204   	; 0xee78 <GSM_Cycle+0x14c0>
					GSM_State = GSM_WAIT_CONFIRMRESPONSE;
    e1f4:	8a e1       	ldi	r24, 0x1A	; 26
    e1f6:	80 93 f6 06 	sts	0x06F6, r24
					StartTimer16(TD_GSM, 200);
    e1fa:	80 91 e9 04 	lds	r24, 0x04E9
    e1fe:	68 ec       	ldi	r22, 0xC8	; 200
    e200:	70 e0       	ldi	r23, 0x00	; 0
    e202:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
    e206:	f8 cb       	rjmp	.-2064   	; 0xd9f8 <GSM_Cycle+0x40>
			GSM_SendFirstChar();
			GSM_State = GSM_WAIT_PLAY_CONFIRMREQUEST_FILE_OK;
			StartTimer16(TD_GSM, 1000);
			break;
		case GSM_WAIT_PLAY_CONFIRMREQUEST_FILE_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_WAIT_MESSAGE)) 
    e208:	81 ef       	ldi	r24, 0xF1	; 241
    e20a:	93 e0       	ldi	r25, 0x03	; 3
    e20c:	6e e0       	ldi	r22, 0x0E	; 14
    e20e:	0e 94 0a 55 	call	0xaa14	; 0xaa14 <GSM_Wait_Response_P>
    e212:	88 23       	and	r24, r24
    e214:	09 f4       	brne	.+2      	; 0xe218 <GSM_Cycle+0x860>
    e216:	f0 cb       	rjmp	.-2080   	; 0xd9f8 <GSM_Cycle+0x40>
				{
					GSM_State = GSM_WAIT_PLAY_CONFIRMREQUEST_FILE_CREC_0;
    e218:	89 e1       	ldi	r24, 0x19	; 25
    e21a:	80 93 f6 06 	sts	0x06F6, r24
					StartTimer16(TD_GSM, 20000);
    e21e:	80 91 e9 04 	lds	r24, 0x04E9
    e222:	60 e2       	ldi	r22, 0x20	; 32
    e224:	7e e4       	ldi	r23, 0x4E	; 78
    e226:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
    e22a:	e6 cb       	rjmp	.-2100   	; 0xd9f8 <GSM_Cycle+0x40>
			if(Timer16Stopp(TD_GSM)){
				GSM_State = GSM_WAIT_MESSAGE;
			}
			break;
		case GSM_SEND_PLAY_CONFIRMREQUEST_FILE: 
			sprintf_P(GSM_TxStr, PSTR("AT+CREC=4,\"C:\\User\\ConfirmRequest.amr\",0,100\r"));
    e22c:	00 d0       	rcall	.+0      	; 0xe22e <GSM_Cycle+0x876>
    e22e:	0f 92       	push	r0
    e230:	8a e4       	ldi	r24, 0x4A	; 74
    e232:	9a e0       	ldi	r25, 0x0A	; 10
    e234:	ed b7       	in	r30, 0x3d	; 61
    e236:	fe b7       	in	r31, 0x3e	; 62
    e238:	92 83       	std	Z+2, r25	; 0x02
    e23a:	81 83       	std	Z+1, r24	; 0x01
    e23c:	8d e2       	ldi	r24, 0x2D	; 45
    e23e:	9f e3       	ldi	r25, 0x3F	; 63
    e240:	94 83       	std	Z+4, r25	; 0x04
    e242:	83 83       	std	Z+3, r24	; 0x03
    e244:	0e 94 20 8c 	call	0x11840	; 0x11840 <sprintf_P>
			GSMTxSz=45;
    e248:	8d e2       	ldi	r24, 0x2D	; 45
    e24a:	80 93 bb 07 	sts	0x07BB, r24
			GSM_SendFirstChar();
    e24e:	0f 90       	pop	r0
    e250:	0f 90       	pop	r0
    e252:	0f 90       	pop	r0
    e254:	0f 90       	pop	r0
    e256:	0e 94 3a 43 	call	0x8674	; 0x8674 <GSM_SendFirstChar>
			GSM_State = GSM_WAIT_PLAY_CONFIRMREQUEST_FILE_OK;
    e25a:	88 e1       	ldi	r24, 0x18	; 24
    e25c:	80 93 f6 06 	sts	0x06F6, r24
			StartTimer16(TD_GSM, 1000);
    e260:	80 91 e9 04 	lds	r24, 0x04E9
    e264:	68 ee       	ldi	r22, 0xE8	; 232
    e266:	73 e0       	ldi	r23, 0x03	; 3
    e268:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
    e26c:	c5 cb       	rjmp	.-2166   	; 0xd9f8 <GSM_Cycle+0x40>
					GSM_State = GSM_WAIT_PLAY_ALARM_FILE_CREC_0;
					StartTimer16(TD_GSM, 20000);
				}
			break;
		case GSM_WAIT_PLAY_ALARM_FILE_CREC_0:
			if(GetStringFromFIFO()){
    e26e:	0e 94 10 42 	call	0x8420	; 0x8420 <GetStringFromFIFO>
    e272:	88 23       	and	r24, r24
    e274:	09 f4       	brne	.+2      	; 0xe278 <GSM_Cycle+0x8c0>
    e276:	19 c6       	rjmp	.+3122   	; 0xeeaa <GSM_Cycle+0x14f2>
				if((strstr_P(GSM_RxStr, PSTR("+CREC: 0")) != NULL) ){
    e278:	81 ee       	ldi	r24, 0xE1	; 225
    e27a:	97 e0       	ldi	r25, 0x07	; 7
    e27c:	6b e5       	ldi	r22, 0x5B	; 91
    e27e:	7f e3       	ldi	r23, 0x3F	; 63
    e280:	0e 94 25 8b 	call	0x1164a	; 0x1164a <strstr_P>
    e284:	89 2b       	or	r24, r25
    e286:	09 f4       	brne	.+2      	; 0xe28a <GSM_Cycle+0x8d2>
    e288:	0a c6       	rjmp	.+3092   	; 0xee9e <GSM_Cycle+0x14e6>
					GSM_State = GSM_SEND_PLAY_CONFIRMREQUEST_FILE;
    e28a:	87 e1       	ldi	r24, 0x17	; 23
    e28c:	80 93 f6 06 	sts	0x06F6, r24
    e290:	b3 cb       	rjmp	.-2202   	; 0xd9f8 <GSM_Cycle+0x40>
			GSM_SendFirstChar();
			GSM_State = GSM_WAIT_PLAY_ALARM_FILE_OK;
			StartTimer16(TD_GSM, 1000);
			break;
		case GSM_WAIT_PLAY_ALARM_FILE_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_WAIT_MESSAGE)) 
    e292:	81 ef       	ldi	r24, 0xF1	; 241
    e294:	93 e0       	ldi	r25, 0x03	; 3
    e296:	6e e0       	ldi	r22, 0x0E	; 14
    e298:	0e 94 0a 55 	call	0xaa14	; 0xaa14 <GSM_Wait_Response_P>
    e29c:	88 23       	and	r24, r24
    e29e:	09 f4       	brne	.+2      	; 0xe2a2 <GSM_Cycle+0x8ea>
    e2a0:	ab cb       	rjmp	.-2218   	; 0xd9f8 <GSM_Cycle+0x40>
				{
					GSM_State = GSM_WAIT_PLAY_ALARM_FILE_CREC_0;
    e2a2:	86 e1       	ldi	r24, 0x16	; 22
    e2a4:	80 93 f6 06 	sts	0x06F6, r24
					StartTimer16(TD_GSM, 20000);
    e2a8:	80 91 e9 04 	lds	r24, 0x04E9
    e2ac:	60 e2       	ldi	r22, 0x20	; 32
    e2ae:	7e e4       	ldi	r23, 0x4E	; 78
    e2b0:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
    e2b4:	a1 cb       	rjmp	.-2238   	; 0xd9f8 <GSM_Cycle+0x40>
			if(Timer16Stopp(TD_GSM)){
				GSM_State = GSM_WAIT_MESSAGE;
			}
			break;
		case GSM_WAIT_CCLC_3:
			if(GetStringFromFIFO()){
    e2b6:	0e 94 10 42 	call	0x8420	; 0x8420 <GetStringFromFIFO>
    e2ba:	88 23       	and	r24, r24
    e2bc:	09 f4       	brne	.+2      	; 0xe2c0 <GSM_Cycle+0x908>
    e2be:	79 c6       	rjmp	.+3314   	; 0xefb2 <GSM_Cycle+0x15fa>
				if( (strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 2,0,6,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 3,0,6,")) != NULL) ){
    e2c0:	81 ee       	ldi	r24, 0xE1	; 225
    e2c2:	97 e0       	ldi	r25, 0x07	; 7
    e2c4:	64 e2       	ldi	r22, 0x24	; 36
    e2c6:	70 e4       	ldi	r23, 0x40	; 64
    e2c8:	0e 94 25 8b 	call	0x1164a	; 0x1164a <strstr_P>
    e2cc:	89 2b       	or	r24, r25
    e2ce:	11 f4       	brne	.+4      	; 0xe2d4 <GSM_Cycle+0x91c>
    e2d0:	0c 94 83 7a 	jmp	0xf506	; 0xf506 <GSM_Cycle+0x1b4e>
					StartTimer16(TD_GSM, 6000);
    e2d4:	80 91 e9 04 	lds	r24, 0x04E9
    e2d8:	60 e7       	ldi	r22, 0x70	; 112
    e2da:	77 e1       	ldi	r23, 0x17	; 23
    e2dc:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
					GSM_State = GSM_WAIT_MESSAGE;
    e2e0:	8e e0       	ldi	r24, 0x0E	; 14
    e2e2:	80 93 f6 06 	sts	0x06F6, r24
    e2e6:	88 cb       	rjmp	.-2288   	; 0xd9f8 <GSM_Cycle+0x40>
		case GSM_WAIT_ATD_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_WAIT_MESSAGE)) GSM_State = GSM_WAIT_CCLC_2;
			StartTimer16(TD_GSM, 1000);
			break;
		case GSM_WAIT_CCLC_2:
			if(GetStringFromFIFO()){
    e2e8:	0e 94 10 42 	call	0x8420	; 0x8420 <GetStringFromFIFO>
    e2ec:	88 23       	and	r24, r24
    e2ee:	09 f4       	brne	.+2      	; 0xe2f2 <GSM_Cycle+0x93a>
    e2f0:	41 c6       	rjmp	.+3202   	; 0xef74 <GSM_Cycle+0x15bc>
				if( (strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,2,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 2,0,2,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 3,0,2,")) != NULL) ){
    e2f2:	81 ee       	ldi	r24, 0xE1	; 225
    e2f4:	97 e0       	ldi	r25, 0x07	; 7
    e2f6:	6e e4       	ldi	r22, 0x4E	; 78
    e2f8:	70 e4       	ldi	r23, 0x40	; 64
    e2fa:	0e 94 25 8b 	call	0x1164a	; 0x1164a <strstr_P>
    e2fe:	89 2b       	or	r24, r25
    e300:	09 f4       	brne	.+2      	; 0xe304 <GSM_Cycle+0x94c>
    e302:	26 c6       	rjmp	.+3148   	; 0xef50 <GSM_Cycle+0x1598>
					StartTimer16(TD_GSM, 2000);
    e304:	80 91 e9 04 	lds	r24, 0x04E9
    e308:	60 ed       	ldi	r22, 0xD0	; 208
    e30a:	77 e0       	ldi	r23, 0x07	; 7
    e30c:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
					GSM_State = GSM_WAIT_CCLC_3;
    e310:	82 e1       	ldi	r24, 0x12	; 18
    e312:	80 93 f6 06 	sts	0x06F6, r24
    e316:	70 cb       	rjmp	.-2336   	; 0xd9f8 <GSM_Cycle+0x40>
			if(Timer16Stopp(TD_GSM)){
				GSM_State = GSM_WAIT_MESSAGE;
			}
			break;
		case GSM_SEND_PLAY_ALARM_FILE: 
			RequestRepeatCounter++;
    e318:	80 91 e2 02 	lds	r24, 0x02E2
    e31c:	8f 5f       	subi	r24, 0xFF	; 255
    e31e:	80 93 e2 02 	sts	0x02E2, r24
			sprintf_P(GSM_TxStr, PSTR("AT+CREC=4,\"C:\\User\\Alarm"));
    e322:	00 d0       	rcall	.+0      	; 0xe324 <GSM_Cycle+0x96c>
    e324:	0f 92       	push	r0
    e326:	ba e4       	ldi	r27, 0x4A	; 74
    e328:	eb 2e       	mov	r14, r27
    e32a:	ba e0       	ldi	r27, 0x0A	; 10
    e32c:	fb 2e       	mov	r15, r27
    e32e:	ad b7       	in	r26, 0x3d	; 61
    e330:	be b7       	in	r27, 0x3e	; 62
    e332:	12 96       	adiw	r26, 0x02	; 2
    e334:	fc 92       	st	X, r15
    e336:	ee 92       	st	-X, r14
    e338:	11 97       	sbiw	r26, 0x01	; 1
    e33a:	81 e7       	ldi	r24, 0x71	; 113
    e33c:	9f e3       	ldi	r25, 0x3F	; 63
    e33e:	14 96       	adiw	r26, 0x04	; 4
    e340:	9c 93       	st	X, r25
    e342:	8e 93       	st	-X, r24
    e344:	13 97       	sbiw	r26, 0x03	; 3
    e346:	0e 94 20 8c 	call	0x11840	; 0x11840 <sprintf_P>
			GSMTxSz=24;
    e34a:	88 e1       	ldi	r24, 0x18	; 24
    e34c:	80 93 bb 07 	sts	0x07BB, r24
			sprintf(GSM_TxStr+GSMTxSz,"%u",Message[2]);
    e350:	80 91 bb 07 	lds	r24, 0x07BB
    e354:	0f 92       	push	r0
    e356:	0f 92       	push	r0
    e358:	ed b7       	in	r30, 0x3d	; 61
    e35a:	fe b7       	in	r31, 0x3e	; 62
    e35c:	31 96       	adiw	r30, 0x01	; 1
    e35e:	90 e0       	ldi	r25, 0x00	; 0
    e360:	8e 0d       	add	r24, r14
    e362:	9f 1d       	adc	r25, r15
    e364:	ad b7       	in	r26, 0x3d	; 61
    e366:	be b7       	in	r27, 0x3e	; 62
    e368:	12 96       	adiw	r26, 0x02	; 2
    e36a:	9c 93       	st	X, r25
    e36c:	8e 93       	st	-X, r24
    e36e:	11 97       	sbiw	r26, 0x01	; 1
    e370:	82 eb       	ldi	r24, 0xB2	; 178
    e372:	92 e0       	ldi	r25, 0x02	; 2
    e374:	93 83       	std	Z+3, r25	; 0x03
    e376:	82 83       	std	Z+2, r24	; 0x02
    e378:	80 91 37 07 	lds	r24, 0x0737
    e37c:	84 83       	std	Z+4, r24	; 0x04
    e37e:	15 82       	std	Z+5, r1	; 0x05
    e380:	0e 94 ef 8b 	call	0x117de	; 0x117de <sprintf>
			if(Message[2]>9){
    e384:	ed b7       	in	r30, 0x3d	; 61
    e386:	fe b7       	in	r31, 0x3e	; 62
    e388:	36 96       	adiw	r30, 0x06	; 6
    e38a:	0f b6       	in	r0, 0x3f	; 63
    e38c:	f8 94       	cli
    e38e:	fe bf       	out	0x3e, r31	; 62
    e390:	0f be       	out	0x3f, r0	; 63
    e392:	ed bf       	out	0x3d, r30	; 61
    e394:	80 91 37 07 	lds	r24, 0x0737
    e398:	8a 30       	cpi	r24, 0x0A	; 10
    e39a:	08 f4       	brcc	.+2      	; 0xe39e <GSM_Cycle+0x9e6>
    e39c:	36 c6       	rjmp	.+3180   	; 0xf00a <GSM_Cycle+0x1652>
				GSMTxSz+=2;
    e39e:	80 91 bb 07 	lds	r24, 0x07BB
    e3a2:	8e 5f       	subi	r24, 0xFE	; 254
    e3a4:	80 93 bb 07 	sts	0x07BB, r24
			}
			else{
				GSMTxSz++;
			};
			sprintf_P(GSM_TxStr+GSMTxSz, PSTR(".amr\",0,100\r"));
    e3a8:	80 91 bb 07 	lds	r24, 0x07BB
    e3ac:	00 d0       	rcall	.+0      	; 0xe3ae <GSM_Cycle+0x9f6>
    e3ae:	0f 92       	push	r0
    e3b0:	90 e0       	ldi	r25, 0x00	; 0
    e3b2:	86 5b       	subi	r24, 0xB6	; 182
    e3b4:	95 4f       	sbci	r25, 0xF5	; 245
    e3b6:	ad b7       	in	r26, 0x3d	; 61
    e3b8:	be b7       	in	r27, 0x3e	; 62
    e3ba:	12 96       	adiw	r26, 0x02	; 2
    e3bc:	9c 93       	st	X, r25
    e3be:	8e 93       	st	-X, r24
    e3c0:	11 97       	sbiw	r26, 0x01	; 1
    e3c2:	84 e6       	ldi	r24, 0x64	; 100
    e3c4:	9f e3       	ldi	r25, 0x3F	; 63
    e3c6:	14 96       	adiw	r26, 0x04	; 4
    e3c8:	9c 93       	st	X, r25
    e3ca:	8e 93       	st	-X, r24
    e3cc:	13 97       	sbiw	r26, 0x03	; 3
    e3ce:	0e 94 20 8c 	call	0x11840	; 0x11840 <sprintf_P>
			GSMTxSz += 12;
    e3d2:	80 91 bb 07 	lds	r24, 0x07BB
    e3d6:	84 5f       	subi	r24, 0xF4	; 244
    e3d8:	80 93 bb 07 	sts	0x07BB, r24
			GSM_SendFirstChar();
    e3dc:	0f 90       	pop	r0
    e3de:	0f 90       	pop	r0
    e3e0:	0f 90       	pop	r0
    e3e2:	0f 90       	pop	r0
    e3e4:	0e 94 3a 43 	call	0x8674	; 0x8674 <GSM_SendFirstChar>
			GSM_State = GSM_WAIT_PLAY_ALARM_FILE_OK;
    e3e8:	85 e1       	ldi	r24, 0x15	; 21
    e3ea:	80 93 f6 06 	sts	0x06F6, r24
			StartTimer16(TD_GSM, 1000);
    e3ee:	80 91 e9 04 	lds	r24, 0x04E9
    e3f2:	68 ee       	ldi	r22, 0xE8	; 232
    e3f4:	73 e0       	ldi	r23, 0x03	; 3
    e3f6:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
    e3fa:	fe ca       	rjmp	.-2564   	; 0xd9f8 <GSM_Cycle+0x40>
			if(Timer16Stopp(TD_GSM)){
				GSM_State = GSM_WAIT_MESSAGE;
			}
			break;
		case GSM_WAIT_CCLC_0:
			if(GetStringFromFIFO()){
    e3fc:	0e 94 10 42 	call	0x8420	; 0x8420 <GetStringFromFIFO>
    e400:	88 23       	and	r24, r24
    e402:	09 f4       	brne	.+2      	; 0xe406 <GSM_Cycle+0xa4e>
    e404:	f5 c5       	rjmp	.+3050   	; 0xeff0 <GSM_Cycle+0x1638>
				if((strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,0,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,0,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,0,")) != NULL) ){
    e406:	81 ee       	ldi	r24, 0xE1	; 225
    e408:	97 e0       	ldi	r25, 0x07	; 7
    e40a:	60 ed       	ldi	r22, 0xD0	; 208
    e40c:	7f e3       	ldi	r23, 0x3F	; 63
    e40e:	0e 94 25 8b 	call	0x1164a	; 0x1164a <strstr_P>
    e412:	89 2b       	or	r24, r25
    e414:	11 f4       	brne	.+4      	; 0xe41a <GSM_Cycle+0xa62>
    e416:	0c 94 cd 7a 	jmp	0xf59a	; 0xf59a <GSM_Cycle+0x1be2>
					RequestRepeatCounter = 0;
    e41a:	10 92 e2 02 	sts	0x02E2, r1
					GSM_State = GSM_SEND_PLAY_ALARM_FILE;
    e41e:	84 e1       	ldi	r24, 0x14	; 20
    e420:	80 93 f6 06 	sts	0x06F6, r24
    e424:	e9 ca       	rjmp	.-2606   	; 0xd9f8 <GSM_Cycle+0x40>
			GSM_SendFirstChar();
			GSM_State = GSM_WAIT_ATD_OK;
			StartTimer16(TD_GSM, 1000);
			break;
		case GSM_WAIT_ATD_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_WAIT_MESSAGE)) GSM_State = GSM_WAIT_CCLC_2;
    e426:	81 ef       	ldi	r24, 0xF1	; 241
    e428:	93 e0       	ldi	r25, 0x03	; 3
    e42a:	6e e0       	ldi	r22, 0x0E	; 14
    e42c:	0e 94 0a 55 	call	0xaa14	; 0xaa14 <GSM_Wait_Response_P>
    e430:	88 23       	and	r24, r24
    e432:	19 f0       	breq	.+6      	; 0xe43a <GSM_Cycle+0xa82>
    e434:	81 e1       	ldi	r24, 0x11	; 17
    e436:	80 93 f6 06 	sts	0x06F6, r24
			StartTimer16(TD_GSM, 1000);
    e43a:	80 91 e9 04 	lds	r24, 0x04E9
    e43e:	68 ee       	ldi	r22, 0xE8	; 232
    e440:	73 e0       	ldi	r23, 0x03	; 3
    e442:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
    e446:	d8 ca       	rjmp	.-2640   	; 0xd9f8 <GSM_Cycle+0x40>
				break;
			}
			TransmitterState = 0;
			break;
		case GSM_SEND_ATD:
			sprintf_P(GSM_TxStr, ATD_PLUS);	GSMTxSz = strlen_P(ATD_PLUS);
    e448:	00 d0       	rcall	.+0      	; 0xe44a <GSM_Cycle+0xa92>
    e44a:	0f 92       	push	r0
    e44c:	8a e4       	ldi	r24, 0x4A	; 74
    e44e:	9a e0       	ldi	r25, 0x0A	; 10
    e450:	ad b7       	in	r26, 0x3d	; 61
    e452:	be b7       	in	r27, 0x3e	; 62
    e454:	12 96       	adiw	r26, 0x02	; 2
    e456:	9c 93       	st	X, r25
    e458:	8e 93       	st	-X, r24
    e45a:	11 97       	sbiw	r26, 0x01	; 1
    e45c:	02 ec       	ldi	r16, 0xC2	; 194
    e45e:	14 e0       	ldi	r17, 0x04	; 4
    e460:	14 96       	adiw	r26, 0x04	; 4
    e462:	1c 93       	st	X, r17
    e464:	0e 93       	st	-X, r16
    e466:	13 97       	sbiw	r26, 0x03	; 3
    e468:	0e 94 20 8c 	call	0x11840	; 0x11840 <sprintf_P>
    e46c:	0f 90       	pop	r0
    e46e:	0f 90       	pop	r0
    e470:	0f 90       	pop	r0
    e472:	0f 90       	pop	r0
    e474:	c8 01       	movw	r24, r16
    e476:	0e 94 03 8b 	call	0x11606	; 0x11606 <strlen_P>
    e47a:	80 93 bb 07 	sts	0x07BB, r24
			erbl(GSM_TxStr+GSMTxSz, CALL_Number+Message[1], MaxTelephN);
    e47e:	80 91 bb 07 	lds	r24, 0x07BB
    e482:	90 e0       	ldi	r25, 0x00	; 0
    e484:	60 91 36 07 	lds	r22, 0x0736
    e488:	2d e0       	ldi	r18, 0x0D	; 13
    e48a:	62 9f       	mul	r22, r18
    e48c:	b0 01       	movw	r22, r0
    e48e:	11 24       	eor	r1, r1
    e490:	64 51       	subi	r22, 0x14	; 20
    e492:	7f 4f       	sbci	r23, 0xFF	; 255
    e494:	86 5b       	subi	r24, 0xB6	; 182
    e496:	95 4f       	sbci	r25, 0xF5	; 245
    e498:	4d e0       	ldi	r20, 0x0D	; 13
    e49a:	50 e0       	ldi	r21, 0x00	; 0
    e49c:	0e 94 0d 8e 	call	0x11c1a	; 0x11c1a <__eerd_block_m2560>
			GSMTxSz+=MaxTelephN-1;
    e4a0:	80 91 bb 07 	lds	r24, 0x07BB
    e4a4:	84 5f       	subi	r24, 0xF4	; 244
    e4a6:	80 93 bb 07 	sts	0x07BB, r24
			const char c=';';
    e4aa:	8b e3       	ldi	r24, 0x3B	; 59
    e4ac:	89 83       	std	Y+1, r24	; 0x01
			sprintf(GSM_TxStr+GSMTxSz,&c);GSMTxSz++;
    e4ae:	80 91 bb 07 	lds	r24, 0x07BB
    e4b2:	00 d0       	rcall	.+0      	; 0xe4b4 <GSM_Cycle+0xafc>
    e4b4:	0f 92       	push	r0
    e4b6:	90 e0       	ldi	r25, 0x00	; 0
    e4b8:	86 5b       	subi	r24, 0xB6	; 182
    e4ba:	95 4f       	sbci	r25, 0xF5	; 245
    e4bc:	ed b7       	in	r30, 0x3d	; 61
    e4be:	fe b7       	in	r31, 0x3e	; 62
    e4c0:	92 83       	std	Z+2, r25	; 0x02
    e4c2:	81 83       	std	Z+1, r24	; 0x01
    e4c4:	ce 01       	movw	r24, r28
    e4c6:	01 96       	adiw	r24, 0x01	; 1
    e4c8:	94 83       	std	Z+4, r25	; 0x04
    e4ca:	83 83       	std	Z+3, r24	; 0x03
    e4cc:	0e 94 ef 8b 	call	0x117de	; 0x117de <sprintf>
    e4d0:	80 91 bb 07 	lds	r24, 0x07BB
    e4d4:	8f 5f       	subi	r24, 0xFF	; 255
    e4d6:	80 93 bb 07 	sts	0x07BB, r24
			sprintf(GSM_TxStr + GSMTxSz, "\r");	GSMTxSz = GSMTxSz+1;
    e4da:	e0 91 bb 07 	lds	r30, 0x07BB
    e4de:	f0 e0       	ldi	r31, 0x00	; 0
    e4e0:	e6 5b       	subi	r30, 0xB6	; 182
    e4e2:	f5 4f       	sbci	r31, 0xF5	; 245
    e4e4:	8d e0       	ldi	r24, 0x0D	; 13
    e4e6:	90 e0       	ldi	r25, 0x00	; 0
    e4e8:	91 83       	std	Z+1, r25	; 0x01
    e4ea:	80 83       	st	Z, r24
    e4ec:	80 91 bb 07 	lds	r24, 0x07BB
    e4f0:	8f 5f       	subi	r24, 0xFF	; 255
    e4f2:	80 93 bb 07 	sts	0x07BB, r24
			GSM_SendFirstChar();
    e4f6:	0f 90       	pop	r0
    e4f8:	0f 90       	pop	r0
    e4fa:	0f 90       	pop	r0
    e4fc:	0f 90       	pop	r0
    e4fe:	0e 94 3a 43 	call	0x8674	; 0x8674 <GSM_SendFirstChar>
			GSM_State = GSM_WAIT_ATD_OK;
    e502:	80 e1       	ldi	r24, 0x10	; 16
    e504:	80 93 f6 06 	sts	0x06F6, r24
			StartTimer16(TD_GSM, 1000);
    e508:	80 91 e9 04 	lds	r24, 0x04E9
    e50c:	68 ee       	ldi	r22, 0xE8	; 232
    e50e:	73 e0       	ldi	r23, 0x03	; 3
    e510:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
    e514:	71 ca       	rjmp	.-2846   	; 0xd9f8 <GSM_Cycle+0x40>
		case GSM_WAIT_DDET101_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;
		case GSM_WAIT_MESSAGE:
			
			if(Message[0]==1)
    e516:	80 91 35 07 	lds	r24, 0x0735
    e51a:	81 30       	cpi	r24, 0x01	; 1
    e51c:	09 f4       	brne	.+2      	; 0xe520 <GSM_Cycle+0xb68>
    e51e:	24 c7       	rjmp	.+3656   	; 0xf368 <GSM_Cycle+0x19b0>
				ConfirmState = 0;
				TransmitterState = 1;
				GSM_State = GSM_SEND_ATD;
				break;
			}
			TransmitterState = 0;
    e520:	10 92 e3 02 	sts	0x02E3, r1
    e524:	69 ca       	rjmp	.-2862   	; 0xd9f8 <GSM_Cycle+0x40>
			break;
		case GSM_SEND_DDET101:
			GSM_Execute_Command(AT_DDET101,100*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_DDET101_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    e526:	81 ef       	ldi	r24, 0xF1	; 241
    e528:	93 e0       	ldi	r25, 0x03	; 3
    e52a:	6a e4       	ldi	r22, 0x4A	; 74
    e52c:	0e 94 0a 55 	call	0xaa14	; 0xaa14 <GSM_Wait_Response_P>
    e530:	88 23       	and	r24, r24
    e532:	09 f4       	brne	.+2      	; 0xe536 <GSM_Cycle+0xb7e>
    e534:	61 ca       	rjmp	.-2878   	; 0xd9f8 <GSM_Cycle+0x40>
    e536:	80 91 f6 06 	lds	r24, 0x06F6
    e53a:	8f 5f       	subi	r24, 0xFF	; 255
    e53c:	80 93 f6 06 	sts	0x06F6, r24
    e540:	5b ca       	rjmp	.-2890   	; 0xd9f8 <GSM_Cycle+0x40>
			break;
		case GSM_WAIT_CLCC_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;
		case GSM_SEND_DDET101:
			GSM_Execute_Command(AT_DDET101,100*GSM_DEBUG_DELAY); GSM_State++;
    e542:	80 e9       	ldi	r24, 0x90	; 144
    e544:	94 e0       	ldi	r25, 0x04	; 4
    e546:	64 e6       	ldi	r22, 0x64	; 100
    e548:	70 e0       	ldi	r23, 0x00	; 0
    e54a:	0e 94 65 55 	call	0xaaca	; 0xaaca <GSM_Execute_Command>
    e54e:	80 91 f6 06 	lds	r24, 0x06F6
    e552:	8f 5f       	subi	r24, 0xFF	; 255
    e554:	80 93 f6 06 	sts	0x06F6, r24
    e558:	4f ca       	rjmp	.-2914   	; 0xd9f8 <GSM_Cycle+0x40>
			break;
		case GSM_SEND_CLCC1:
			GSM_Execute_Command(AT_CLCC1,100*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CLCC_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    e55a:	81 ef       	ldi	r24, 0xF1	; 241
    e55c:	93 e0       	ldi	r25, 0x03	; 3
    e55e:	6a e4       	ldi	r22, 0x4A	; 74
    e560:	0e 94 0a 55 	call	0xaa14	; 0xaa14 <GSM_Wait_Response_P>
    e564:	88 23       	and	r24, r24
    e566:	09 f4       	brne	.+2      	; 0xe56a <GSM_Cycle+0xbb2>
    e568:	47 ca       	rjmp	.-2930   	; 0xd9f8 <GSM_Cycle+0x40>
    e56a:	80 91 f6 06 	lds	r24, 0x06F6
    e56e:	8f 5f       	subi	r24, 0xFF	; 255
    e570:	80 93 f6 06 	sts	0x06F6, r24
    e574:	41 ca       	rjmp	.-2942   	; 0xd9f8 <GSM_Cycle+0x40>
			break;
		case GSM_WAIT_E0_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;
		case GSM_SEND_CLCC1:
			GSM_Execute_Command(AT_CLCC1,100*GSM_DEBUG_DELAY); GSM_State++;
    e576:	86 e8       	ldi	r24, 0x86	; 134
    e578:	94 e0       	ldi	r25, 0x04	; 4
    e57a:	64 e6       	ldi	r22, 0x64	; 100
    e57c:	70 e0       	ldi	r23, 0x00	; 0
    e57e:	0e 94 65 55 	call	0xaaca	; 0xaaca <GSM_Execute_Command>
    e582:	80 91 f6 06 	lds	r24, 0x06F6
    e586:	8f 5f       	subi	r24, 0xFF	; 255
    e588:	80 93 f6 06 	sts	0x06F6, r24
    e58c:	35 ca       	rjmp	.-2966   	; 0xd9f8 <GSM_Cycle+0x40>
		//------------------------
		case GSM_SEND_E0:
			GSM_Execute_Command(AT_E0,100*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_E0_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    e58e:	81 ef       	ldi	r24, 0xF1	; 241
    e590:	93 e0       	ldi	r25, 0x03	; 3
    e592:	6a e4       	ldi	r22, 0x4A	; 74
    e594:	0e 94 0a 55 	call	0xaa14	; 0xaa14 <GSM_Wait_Response_P>
    e598:	88 23       	and	r24, r24
    e59a:	09 f4       	brne	.+2      	; 0xe59e <GSM_Cycle+0xbe6>
    e59c:	2d ca       	rjmp	.-2982   	; 0xd9f8 <GSM_Cycle+0x40>
    e59e:	80 91 f6 06 	lds	r24, 0x06F6
    e5a2:	8f 5f       	subi	r24, 0xFF	; 255
    e5a4:	80 93 f6 06 	sts	0x06F6, r24
    e5a8:	27 ca       	rjmp	.-2994   	; 0xd9f8 <GSM_Cycle+0x40>
		case GSM_WAIT_SMS_READY:
			if(GSM_Wait_Response_P(URC_SMS_READY, GSM_ReStart1))GSM_State++;
			break;
		//------------------------
		case GSM_SEND_E0:
			GSM_Execute_Command(AT_E0,100*GSM_DEBUG_DELAY); GSM_State++;
    e5aa:	81 e8       	ldi	r24, 0x81	; 129
    e5ac:	94 e0       	ldi	r25, 0x04	; 4
    e5ae:	64 e6       	ldi	r22, 0x64	; 100
    e5b0:	70 e0       	ldi	r23, 0x00	; 0
    e5b2:	0e 94 65 55 	call	0xaaca	; 0xaaca <GSM_Execute_Command>
    e5b6:	80 91 f6 06 	lds	r24, 0x06F6
    e5ba:	8f 5f       	subi	r24, 0xFF	; 255
    e5bc:	80 93 f6 06 	sts	0x06F6, r24
    e5c0:	1b ca       	rjmp	.-3018   	; 0xd9f8 <GSM_Cycle+0x40>
				if(GSM_Modem == SIMCOM_SIM800) GSM_State = GSM_WAIT_SMS_READY;
				else GSM_State = GSM_SEND_E0;
			}
			break;
		case GSM_WAIT_SMS_READY:
			if(GSM_Wait_Response_P(URC_SMS_READY, GSM_ReStart1))GSM_State++;
    e5c2:	8c ea       	ldi	r24, 0xAC	; 172
    e5c4:	93 e0       	ldi	r25, 0x03	; 3
    e5c6:	6a e4       	ldi	r22, 0x4A	; 74
    e5c8:	0e 94 0a 55 	call	0xaa14	; 0xaa14 <GSM_Wait_Response_P>
    e5cc:	88 23       	and	r24, r24
    e5ce:	09 f4       	brne	.+2      	; 0xe5d2 <GSM_Cycle+0xc1a>
    e5d0:	13 ca       	rjmp	.-3034   	; 0xd9f8 <GSM_Cycle+0x40>
    e5d2:	80 91 f6 06 	lds	r24, 0x06F6
    e5d6:	8f 5f       	subi	r24, 0xFF	; 255
    e5d8:	80 93 f6 06 	sts	0x06F6, r24
    e5dc:	0d ca       	rjmp	.-3046   	; 0xd9f8 <GSM_Cycle+0x40>

		case GSM_WAIT_RDY:
			if(GSM_Wait_Response_P(URC_RDY, GSM_ReStart1)) GSM_State++;
			break;
		case GSM_SEND_CGMM:
			GSM_Execute_Command(AT_CGMM,5000*GSM_DEBUG_DELAY); GSM_State++;
    e5de:	8e e9       	ldi	r24, 0x9E	; 158
    e5e0:	94 e0       	ldi	r25, 0x04	; 4
    e5e2:	68 e8       	ldi	r22, 0x88	; 136
    e5e4:	73 e1       	ldi	r23, 0x13	; 19
    e5e6:	0e 94 65 55 	call	0xaaca	; 0xaaca <GSM_Execute_Command>
    e5ea:	80 91 f6 06 	lds	r24, 0x06F6
    e5ee:	8f 5f       	subi	r24, 0xFF	; 255
    e5f0:	80 93 f6 06 	sts	0x06F6, r24
    e5f4:	01 ca       	rjmp	.-3070   	; 0xd9f8 <GSM_Cycle+0x40>
			GSM_Modem = NOT_RECOGNIZED;
			GSM_State = GSM_WAIT_RDY;
			break;

		case GSM_WAIT_RDY:
			if(GSM_Wait_Response_P(URC_RDY, GSM_ReStart1)) GSM_State++;
    e5f6:	87 e8       	ldi	r24, 0x87	; 135
    e5f8:	93 e0       	ldi	r25, 0x03	; 3
    e5fa:	6a e4       	ldi	r22, 0x4A	; 74
    e5fc:	0e 94 0a 55 	call	0xaa14	; 0xaa14 <GSM_Wait_Response_P>
    e600:	88 23       	and	r24, r24
    e602:	09 f4       	brne	.+2      	; 0xe606 <GSM_Cycle+0xc4e>
    e604:	f9 c9       	rjmp	.-3086   	; 0xd9f8 <GSM_Cycle+0x40>
    e606:	80 91 f6 06 	lds	r24, 0x06F6
    e60a:	8f 5f       	subi	r24, 0xFF	; 255
    e60c:	80 93 f6 06 	sts	0x06F6, r24
    e610:	f3 c9       	rjmp	.-3098   	; 0xd9f8 <GSM_Cycle+0x40>
inline static void GSM_Auto(){

	switch(GSM_State){

		case GSM_PowerOn:
			StartTimer16(TD_GSM,1000*GSM_DEBUG_DELAY);
    e612:	80 91 e9 04 	lds	r24, 0x04E9
    e616:	68 ee       	ldi	r22, 0xE8	; 232
    e618:	73 e0       	ldi	r23, 0x03	; 3
    e61a:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
			StartTimer32(TD_GSM_Reset, 24UL*60UL*6000);	//    24 
    e61e:	80 91 eb 04 	lds	r24, 0x04EB
    e622:	40 e0       	ldi	r20, 0x00	; 0
    e624:	56 ed       	ldi	r21, 0xD6	; 214
    e626:	63 e8       	ldi	r22, 0x83	; 131
    e628:	70 e0       	ldi	r23, 0x00	; 0
    e62a:	0e 94 99 24 	call	0x4932	; 0x4932 <StartTimer32>
			StartTimer32(TD_1hour_resetGPRS_timer, 360000); //     
    e62e:	80 91 ed 04 	lds	r24, 0x04ED
    e632:	40 e4       	ldi	r20, 0x40	; 64
    e634:	5e e7       	ldi	r21, 0x7E	; 126
    e636:	65 e0       	ldi	r22, 0x05	; 5
    e638:	70 e0       	ldi	r23, 0x00	; 0
    e63a:	0e 94 99 24 	call	0x4932	; 0x4932 <StartTimer32>
			StartTimer16(TD_CheckModem,6000);//      5 	
    e63e:	80 91 ee 04 	lds	r24, 0x04EE
    e642:	60 e7       	ldi	r22, 0x70	; 112
    e644:	77 e1       	ldi	r23, 0x17	; 23
    e646:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
	}
	void GSM_PWRCNTRL_ON(void){
		cli();
    e64a:	f8 94       	cli
		PORTL &= ~(1<<PL5);
    e64c:	80 91 0b 01 	lds	r24, 0x010B
    e650:	8f 7d       	andi	r24, 0xDF	; 223
    e652:	80 93 0b 01 	sts	0x010B, r24
		sei();
    e656:	78 94       	sei
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    e658:	8f ef       	ldi	r24, 0xFF	; 255
    e65a:	80 93 3e 07 	sts	0x073E, r24
	GSM_RX_FIFO_End = 255;
    e65e:	80 93 53 06 	sts	0x0653, r24
	GSM_RxCharN = 0;
    e662:	10 92 60 0b 	sts	0x0B60, r1
	GSM_RX_FIFOOverFlow = 0;
    e666:	10 92 13 09 	sts	0x0913, r1
	GSM_RX_FIFOMax = 0;
    e66a:	10 92 19 09 	sts	0x0919, r1
			StartTimer32(TD_GSM_Reset, 24UL*60UL*6000);	//    24 
			StartTimer32(TD_1hour_resetGPRS_timer, 360000); //     
			StartTimer16(TD_CheckModem,6000);//      5 	
			GSM_PWRCNTRL_ON();
			InitFIFO();
			counter=0;
    e66e:	10 92 e0 02 	sts	0x02E0, r1
			GSM_Modem = NOT_RECOGNIZED;
    e672:	10 92 34 07 	sts	0x0734, r1
			GSM_State = GSM_WAIT_RDY;
    e676:	81 e0       	ldi	r24, 0x01	; 1
    e678:	80 93 f6 06 	sts	0x06F6, r24
    e67c:	bd c9       	rjmp	.-3206   	; 0xd9f8 <GSM_Cycle+0x40>
		case GSM_WAIT_CPIN_READY:
			if(GSM_Wait_Response_P(URC_CPIN_READY, GSM_ReStart1)) GSM_State++;
			break;

		case GSM_WAIT_CALL_READY:
			if(GSM_Wait_Response_P(URC_CALL_READY, GSM_ReStart1)){
    e67e:	81 ea       	ldi	r24, 0xA1	; 161
    e680:	93 e0       	ldi	r25, 0x03	; 3
    e682:	6a e4       	ldi	r22, 0x4A	; 74
    e684:	0e 94 0a 55 	call	0xaa14	; 0xaa14 <GSM_Wait_Response_P>
    e688:	88 23       	and	r24, r24
    e68a:	09 f4       	brne	.+2      	; 0xe68e <GSM_Cycle+0xcd6>
    e68c:	b5 c9       	rjmp	.-3222   	; 0xd9f8 <GSM_Cycle+0x40>
				if(GSM_Modem == SIMCOM_SIM800) GSM_State = GSM_WAIT_SMS_READY;
    e68e:	80 91 34 07 	lds	r24, 0x0734
    e692:	82 30       	cpi	r24, 0x02	; 2
    e694:	09 f4       	brne	.+2      	; 0xe698 <GSM_Cycle+0xce0>
    e696:	8a c6       	rjmp	.+3348   	; 0xf3ac <GSM_Cycle+0x19f4>
				else GSM_State = GSM_SEND_E0;
    e698:	88 e0       	ldi	r24, 0x08	; 8
    e69a:	80 93 f6 06 	sts	0x06F6, r24
    e69e:	ac c9       	rjmp	.-3240   	; 0xd9f8 <GSM_Cycle+0x40>
			}
		case GSM_WAIT_CFUN:
			if(GSM_Wait_Response_P(URC_CFUN, GSM_ReStart1)) GSM_State++;
			break;
		case GSM_WAIT_CPIN_READY:
			if(GSM_Wait_Response_P(URC_CPIN_READY, GSM_ReStart1)) GSM_State++;
    e6a0:	84 e9       	ldi	r24, 0x94	; 148
    e6a2:	93 e0       	ldi	r25, 0x03	; 3
    e6a4:	6a e4       	ldi	r22, 0x4A	; 74
    e6a6:	0e 94 0a 55 	call	0xaa14	; 0xaa14 <GSM_Wait_Response_P>
    e6aa:	88 23       	and	r24, r24
    e6ac:	09 f4       	brne	.+2      	; 0xe6b0 <GSM_Cycle+0xcf8>
    e6ae:	a4 c9       	rjmp	.-3256   	; 0xd9f8 <GSM_Cycle+0x40>
    e6b0:	80 91 f6 06 	lds	r24, 0x06F6
    e6b4:	8f 5f       	subi	r24, 0xFF	; 255
    e6b6:	80 93 f6 06 	sts	0x06F6, r24
    e6ba:	9e c9       	rjmp	.-3268   	; 0xd9f8 <GSM_Cycle+0x40>
			}
			break;

		//------------------------
		case GSM_WAIT_1:
			GetStringFromFIFO();		//     FIFO
    e6bc:	0e 94 10 42 	call	0x8420	; 0x8420 <GetStringFromFIFO>
			if(Timer16Stopp(TD_GSM)){
    e6c0:	80 91 e9 04 	lds	r24, 0x04E9
    e6c4:	0e 94 96 25 	call	0x4b2c	; 0x4b2c <Timer16Stopp>
    e6c8:	88 23       	and	r24, r24
    e6ca:	09 f4       	brne	.+2      	; 0xe6ce <GSM_Cycle+0xd16>
    e6cc:	95 c9       	rjmp	.-3286   	; 0xd9f8 <GSM_Cycle+0x40>
				GSM_State++;
    e6ce:	80 91 f6 06 	lds	r24, 0x06F6
    e6d2:	8f 5f       	subi	r24, 0xFF	; 255
    e6d4:	80 93 f6 06 	sts	0x06F6, r24
				GSM_Temp = 0;
    e6d8:	10 92 db 05 	sts	0x05DB, r1
    e6dc:	8d c9       	rjmp	.-3302   	; 0xd9f8 <GSM_Cycle+0x40>
			if(GSM_MultiCon) GSM_Execute_Command(AT_CIPMODE_0, 100*GSM_DEBUG_DELAY);
			else GSM_Execute_Command(AT_CIPMODE_1, 100*GSM_DEBUG_DELAY);
			GSM_State++;
			break;
		case GSM_WAIT_CIPMODE_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    e6de:	81 ef       	ldi	r24, 0xF1	; 241
    e6e0:	93 e0       	ldi	r25, 0x03	; 3
    e6e2:	6a e4       	ldi	r22, 0x4A	; 74
    e6e4:	0e 94 0a 55 	call	0xaa14	; 0xaa14 <GSM_Wait_Response_P>
    e6e8:	88 23       	and	r24, r24
    e6ea:	09 f4       	brne	.+2      	; 0xe6ee <GSM_Cycle+0xd36>
    e6ec:	85 c9       	rjmp	.-3318   	; 0xd9f8 <GSM_Cycle+0x40>
				GSM_State++;
    e6ee:	80 91 f6 06 	lds	r24, 0x06F6
    e6f2:	8f 5f       	subi	r24, 0xFF	; 255
    e6f4:	80 93 f6 06 	sts	0x06F6, r24
				// between "Call Ready" and "+CMGS"; 8 sec min needs; for kyivstar vpni only
				StartTimer16(TD_GSM, 1000);
    e6f8:	80 91 e9 04 	lds	r24, 0x04E9
    e6fc:	68 ee       	ldi	r22, 0xE8	; 232
    e6fe:	73 e0       	ldi	r23, 0x03	; 3
    e700:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
    e704:	79 c9       	rjmp	.-3342   	; 0xd9f8 <GSM_Cycle+0x40>
				}
				else GSM_State++;
			}
			break;
		case GSM_SEND_CIPMODE:
			if(GSM_MultiCon) GSM_Execute_Command(AT_CIPMODE_0, 100*GSM_DEBUG_DELAY);
    e706:	80 91 73 0c 	lds	r24, 0x0C73
    e70a:	88 23       	and	r24, r24
    e70c:	09 f4       	brne	.+2      	; 0xe710 <GSM_Cycle+0xd58>
    e70e:	83 c4       	rjmp	.+2310   	; 0xf016 <GSM_Cycle+0x165e>
    e710:	8b ef       	ldi	r24, 0xFB	; 251
    e712:	94 e0       	ldi	r25, 0x04	; 4
    e714:	64 e6       	ldi	r22, 0x64	; 100
    e716:	70 e0       	ldi	r23, 0x00	; 0
    e718:	0e 94 65 55 	call	0xaaca	; 0xaaca <GSM_Execute_Command>
			else GSM_Execute_Command(AT_CIPMODE_1, 100*GSM_DEBUG_DELAY);
			GSM_State++;
    e71c:	80 91 f6 06 	lds	r24, 0x06F6
    e720:	8f 5f       	subi	r24, 0xFF	; 255
    e722:	80 93 f6 06 	sts	0x06F6, r24
    e726:	68 c9       	rjmp	.-3376   	; 0xd9f8 <GSM_Cycle+0x40>
			if(GSM_MultiCon) GSM_Execute_Command(AT_CIPMUX_1, 100*GSM_DEBUG_DELAY);
			else GSM_Execute_Command(AT_CIPMUX_0, 100*GSM_DEBUG_DELAY);
			GSM_State++; 
			break;
		case GSM_WAIT_CIPMUX_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    e728:	81 ef       	ldi	r24, 0xF1	; 241
    e72a:	93 e0       	ldi	r25, 0x03	; 3
    e72c:	6a e4       	ldi	r22, 0x4A	; 74
    e72e:	0e 94 0a 55 	call	0xaa14	; 0xaa14 <GSM_Wait_Response_P>
    e732:	88 23       	and	r24, r24
    e734:	09 f4       	brne	.+2      	; 0xe738 <GSM_Cycle+0xd80>
    e736:	60 c9       	rjmp	.-3392   	; 0xd9f8 <GSM_Cycle+0x40>
				if(GSM_MultiCon){
    e738:	80 91 73 0c 	lds	r24, 0x0C73
    e73c:	88 23       	and	r24, r24
    e73e:	09 f0       	breq	.+2      	; 0xe742 <GSM_Cycle+0xd8a>
    e740:	4e c6       	rjmp	.+3228   	; 0xf3de <GSM_Cycle+0x1a26>
					GSM_State = GSM_WAIT_1;
					// between "Call Ready" and "+CMGS"; 8 sec min needs; for kyivstar vpni only
					StartTimer16(TD_GSM, 1000);
				}
				else GSM_State++;
    e742:	80 91 f6 06 	lds	r24, 0x06F6
    e746:	8f 5f       	subi	r24, 0xFF	; 255
    e748:	80 93 f6 06 	sts	0x06F6, r24
    e74c:	55 c9       	rjmp	.-3414   	; 0xd9f8 <GSM_Cycle+0x40>

		case GSM_SEND_CSTT:
			GSM_Execute_Command(AT_CSTT, 300*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CSTT_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    e74e:	81 ef       	ldi	r24, 0xF1	; 241
    e750:	93 e0       	ldi	r25, 0x03	; 3
    e752:	6a e4       	ldi	r22, 0x4A	; 74
    e754:	0e 94 0a 55 	call	0xaa14	; 0xaa14 <GSM_Wait_Response_P>
    e758:	88 23       	and	r24, r24
    e75a:	09 f4       	brne	.+2      	; 0xe75e <GSM_Cycle+0xda6>
    e75c:	4d c9       	rjmp	.-3430   	; 0xd9f8 <GSM_Cycle+0x40>
    e75e:	80 91 f6 06 	lds	r24, 0x06F6
    e762:	8f 5f       	subi	r24, 0xFF	; 255
    e764:	80 93 f6 06 	sts	0x06F6, r24
    e768:	47 c9       	rjmp	.-3442   	; 0xd9f8 <GSM_Cycle+0x40>



///------------------------ / (  )
		case GSM_SEND_CMGF:
			GSM_Execute_Command(AT_CMGF,100*GSM_DEBUG_DELAY); GSM_State++;
    e76a:	83 ed       	ldi	r24, 0xD3	; 211
    e76c:	94 e0       	ldi	r25, 0x04	; 4
    e76e:	64 e6       	ldi	r22, 0x64	; 100
    e770:	70 e0       	ldi	r23, 0x00	; 0
    e772:	0e 94 65 55 	call	0xaaca	; 0xaaca <GSM_Execute_Command>
    e776:	80 91 f6 06 	lds	r24, 0x06F6
    e77a:	8f 5f       	subi	r24, 0xFF	; 255
    e77c:	80 93 f6 06 	sts	0x06F6, r24
    e780:	3b c9       	rjmp	.-3466   	; 0xd9f8 <GSM_Cycle+0x40>
			if(Timer16Stopp(TD_GSM)){
				GSM_State = GSM_WAIT_MESSAGE;
			}
			break;
		case GSM_WAIT_DISCONNECT_CAUSE:
			if(GetStringFromFIFO()){
    e782:	0e 94 10 42 	call	0x8420	; 0x8420 <GetStringFromFIFO>
    e786:	88 23       	and	r24, r24
    e788:	09 f4       	brne	.+2      	; 0xe78c <GSM_Cycle+0xdd4>
    e78a:	4c c4       	rjmp	.+2200   	; 0xf024 <GSM_Cycle+0x166c>
				if((strstr_P(GSM_RxStr, PSTR("OK")) != NULL) ){
    e78c:	81 ee       	ldi	r24, 0xE1	; 225
    e78e:	97 e0       	ldi	r25, 0x07	; 7
    e790:	69 e7       	ldi	r22, 0x79	; 121
    e792:	7e e3       	ldi	r23, 0x3E	; 62
    e794:	0e 94 25 8b 	call	0x1164a	; 0x1164a <strstr_P>
    e798:	89 2b       	or	r24, r25
    e79a:	09 f4       	brne	.+2      	; 0xe79e <GSM_Cycle+0xde6>
    e79c:	dc c6       	rjmp	.+3512   	; 0xf556 <GSM_Cycle+0x1b9e>
					GSM_State = GSM_WAIT_MESSAGE;
    e79e:	8e e0       	ldi	r24, 0x0E	; 14
    e7a0:	80 93 f6 06 	sts	0x06F6, r24
    e7a4:	29 c9       	rjmp	.-3502   	; 0xd9f8 <GSM_Cycle+0x40>
			GSM_SendFirstChar();
			GSM_State = GSM_WAIT_CCLC_6;
			StartTimer16(TD_GSM, 1000);
			break;	
		case GSM_WAIT_CCLC_6:
			if(GetStringFromFIFO()){
    e7a6:	0e 94 10 42 	call	0x8420	; 0x8420 <GetStringFromFIFO>
    e7aa:	88 23       	and	r24, r24
    e7ac:	09 f4       	brne	.+2      	; 0xe7b0 <GSM_Cycle+0xdf8>
    e7ae:	4a c3       	rjmp	.+1684   	; 0xee44 <GSM_Cycle+0x148c>
				if((strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6,")) != NULL) ){
    e7b0:	81 ee       	ldi	r24, 0xE1	; 225
    e7b2:	97 e0       	ldi	r25, 0x07	; 7
    e7b4:	6c e7       	ldi	r22, 0x7C	; 124
    e7b6:	7e e3       	ldi	r23, 0x3E	; 62
    e7b8:	0e 94 25 8b 	call	0x1164a	; 0x1164a <strstr_P>
    e7bc:	89 2b       	or	r24, r25
    e7be:	09 f4       	brne	.+2      	; 0xe7c2 <GSM_Cycle+0xe0a>
    e7c0:	41 c3       	rjmp	.+1666   	; 0xee44 <GSM_Cycle+0x148c>
					GSM_State = GSM_WAIT_DISCONNECT_CAUSE;
    e7c2:	85 e2       	ldi	r24, 0x25	; 37
    e7c4:	80 93 f6 06 	sts	0x06F6, r24
					StartTimer16(TD_GSM, 10000);
    e7c8:	80 91 e9 04 	lds	r24, 0x04E9
    e7cc:	60 e1       	ldi	r22, 0x10	; 16
    e7ce:	77 e2       	ldi	r23, 0x27	; 39
    e7d0:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
    e7d4:	11 c9       	rjmp	.-3550   	; 0xd9f8 <GSM_Cycle+0x40>
				GSM_State = GSM_SEND_ATH;
				StartTimer16(TD_GSM, 10000);
			}
			break;	
		case GSM_SEND_ATH:
			sprintf_P(GSM_TxStr, PSTR("ATH\r"));
    e7d6:	00 d0       	rcall	.+0      	; 0xe7d8 <GSM_Cycle+0xe20>
    e7d8:	0f 92       	push	r0
    e7da:	8a e4       	ldi	r24, 0x4A	; 74
    e7dc:	9a e0       	ldi	r25, 0x0A	; 10
    e7de:	ed b7       	in	r30, 0x3d	; 61
    e7e0:	fe b7       	in	r31, 0x3e	; 62
    e7e2:	92 83       	std	Z+2, r25	; 0x02
    e7e4:	81 83       	std	Z+1, r24	; 0x01
    e7e6:	8a e8       	ldi	r24, 0x8A	; 138
    e7e8:	9e e3       	ldi	r25, 0x3E	; 62
    e7ea:	94 83       	std	Z+4, r25	; 0x04
    e7ec:	83 83       	std	Z+3, r24	; 0x03
    e7ee:	0e 94 20 8c 	call	0x11840	; 0x11840 <sprintf_P>
			GSMTxSz = 4;
    e7f2:	84 e0       	ldi	r24, 0x04	; 4
    e7f4:	80 93 bb 07 	sts	0x07BB, r24
			GSM_SendFirstChar();
    e7f8:	0f 90       	pop	r0
    e7fa:	0f 90       	pop	r0
    e7fc:	0f 90       	pop	r0
    e7fe:	0f 90       	pop	r0
    e800:	0e 94 3a 43 	call	0x8674	; 0x8674 <GSM_SendFirstChar>
			GSM_State = GSM_WAIT_CCLC_6;
    e804:	84 e2       	ldi	r24, 0x24	; 36
    e806:	80 93 f6 06 	sts	0x06F6, r24
			StartTimer16(TD_GSM, 1000);
    e80a:	80 91 e9 04 	lds	r24, 0x04E9
    e80e:	68 ee       	ldi	r22, 0xE8	; 232
    e810:	73 e0       	ldi	r23, 0x03	; 3
    e812:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
    e816:	f0 c8       	rjmp	.-3616   	; 0xd9f8 <GSM_Cycle+0x40>
					GSM_State = GSM_WAIT_PLAY_NOTCONFIRM_FILE_CREC_0;
					StartTimer16(TD_GSM, 20000);
				}
			break;
		case GSM_WAIT_PLAY_NOTCONFIRM_FILE_CREC_0:
			if(GSM_Wait_Response_P(RESP_CREC_0, GSM_SEND_ATD)) 
    e818:	81 e5       	ldi	r24, 0x51	; 81
    e81a:	94 e0       	ldi	r25, 0x04	; 4
    e81c:	6f e0       	ldi	r22, 0x0F	; 15
    e81e:	0e 94 0a 55 	call	0xaa14	; 0xaa14 <GSM_Wait_Response_P>
    e822:	88 23       	and	r24, r24
    e824:	09 f4       	brne	.+2      	; 0xe828 <GSM_Cycle+0xe70>
    e826:	e8 c8       	rjmp	.-3632   	; 0xd9f8 <GSM_Cycle+0x40>
			{
				GSM_State = GSM_SEND_ATH;
    e828:	83 e2       	ldi	r24, 0x23	; 35
    e82a:	80 93 f6 06 	sts	0x06F6, r24
				StartTimer16(TD_GSM, 10000);
    e82e:	80 91 e9 04 	lds	r24, 0x04E9
    e832:	60 e1       	ldi	r22, 0x10	; 16
    e834:	77 e2       	ldi	r23, 0x27	; 39
    e836:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
    e83a:	de c8       	rjmp	.-3652   	; 0xd9f8 <GSM_Cycle+0x40>
			GSM_SendFirstChar();
			GSM_State = GSM_WAIT_PLAY_NOTCONFIRM_FILE_OK;
			StartTimer16(TD_GSM, 1000);
			break;
		case GSM_WAIT_PLAY_NOTCONFIRM_FILE_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_WAIT_PLAY_NOTCONFIRM_FILE_OK)) 
    e83c:	81 ef       	ldi	r24, 0xF1	; 241
    e83e:	93 e0       	ldi	r25, 0x03	; 3
    e840:	61 e2       	ldi	r22, 0x21	; 33
    e842:	0e 94 0a 55 	call	0xaa14	; 0xaa14 <GSM_Wait_Response_P>
    e846:	88 23       	and	r24, r24
    e848:	09 f4       	brne	.+2      	; 0xe84c <GSM_Cycle+0xe94>
    e84a:	d6 c8       	rjmp	.-3668   	; 0xd9f8 <GSM_Cycle+0x40>
				{
					GSM_State = GSM_WAIT_PLAY_NOTCONFIRM_FILE_CREC_0;
    e84c:	82 e2       	ldi	r24, 0x22	; 34
    e84e:	80 93 f6 06 	sts	0x06F6, r24
					StartTimer16(TD_GSM, 20000);
    e852:	80 91 e9 04 	lds	r24, 0x04E9
    e856:	60 e2       	ldi	r22, 0x20	; 32
    e858:	7e e4       	ldi	r23, 0x4E	; 78
    e85a:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
    e85e:	cc c8       	rjmp	.-3688   	; 0xd9f8 <GSM_Cycle+0x40>
				GSM_State = GSM_SEND_ATH;
				StartTimer16(TD_GSM, 10000);
			}
			break;
		case GSM_SEND_PLAY_NOTCONFIRM_FILE: 
			sprintf_P(GSM_TxStr, PSTR("AT+CREC=4,\"C:\\User\\NotConfirm.amr\",0,100\r"));
    e860:	00 d0       	rcall	.+0      	; 0xe862 <GSM_Cycle+0xeaa>
    e862:	0f 92       	push	r0
    e864:	8a e4       	ldi	r24, 0x4A	; 74
    e866:	9a e0       	ldi	r25, 0x0A	; 10
    e868:	ad b7       	in	r26, 0x3d	; 61
    e86a:	be b7       	in	r27, 0x3e	; 62
    e86c:	12 96       	adiw	r26, 0x02	; 2
    e86e:	9c 93       	st	X, r25
    e870:	8e 93       	st	-X, r24
    e872:	11 97       	sbiw	r26, 0x01	; 1
    e874:	8f e8       	ldi	r24, 0x8F	; 143
    e876:	9e e3       	ldi	r25, 0x3E	; 62
    e878:	14 96       	adiw	r26, 0x04	; 4
    e87a:	9c 93       	st	X, r25
    e87c:	8e 93       	st	-X, r24
    e87e:	13 97       	sbiw	r26, 0x03	; 3
    e880:	0e 94 20 8c 	call	0x11840	; 0x11840 <sprintf_P>
			GSMTxSz = 41;
    e884:	89 e2       	ldi	r24, 0x29	; 41
    e886:	80 93 bb 07 	sts	0x07BB, r24
			GSM_SendFirstChar();
    e88a:	0f 90       	pop	r0
    e88c:	0f 90       	pop	r0
    e88e:	0f 90       	pop	r0
    e890:	0f 90       	pop	r0
    e892:	0e 94 3a 43 	call	0x8674	; 0x8674 <GSM_SendFirstChar>
			GSM_State = GSM_WAIT_PLAY_NOTCONFIRM_FILE_OK;
    e896:	81 e2       	ldi	r24, 0x21	; 33
    e898:	80 93 f6 06 	sts	0x06F6, r24
			StartTimer16(TD_GSM, 1000);
    e89c:	80 91 e9 04 	lds	r24, 0x04E9
    e8a0:	68 ee       	ldi	r22, 0xE8	; 232
    e8a2:	73 e0       	ldi	r23, 0x03	; 3
    e8a4:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
    e8a8:	a7 c8       	rjmp	.-3762   	; 0xd9f8 <GSM_Cycle+0x40>
					GSM_State = GSM_WAIT_PLAY_CONFIRM_FILE_CREC_0;
					StartTimer16(TD_GSM, 20000);
				}
			break;
		case GSM_WAIT_PLAY_CONFIRM_FILE_CREC_0:
			if(GSM_Wait_Response_P(RESP_CREC_0, GSM_SEND_ATD)) 
    e8aa:	81 e5       	ldi	r24, 0x51	; 81
    e8ac:	94 e0       	ldi	r25, 0x04	; 4
    e8ae:	6f e0       	ldi	r22, 0x0F	; 15
    e8b0:	0e 94 0a 55 	call	0xaa14	; 0xaa14 <GSM_Wait_Response_P>
    e8b4:	88 23       	and	r24, r24
    e8b6:	09 f4       	brne	.+2      	; 0xe8ba <GSM_Cycle+0xf02>
    e8b8:	9f c8       	rjmp	.-3778   	; 0xd9f8 <GSM_Cycle+0x40>
			{
				GSM_State = GSM_SEND_ATH;
    e8ba:	83 e2       	ldi	r24, 0x23	; 35
    e8bc:	80 93 f6 06 	sts	0x06F6, r24
				StartTimer16(TD_GSM, 10000);
    e8c0:	80 91 e9 04 	lds	r24, 0x04E9
    e8c4:	60 e1       	ldi	r22, 0x10	; 16
    e8c6:	77 e2       	ldi	r23, 0x27	; 39
    e8c8:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
    e8cc:	95 c8       	rjmp	.-3798   	; 0xd9f8 <GSM_Cycle+0x40>
		case GSM_WAIT_CSMP_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State=GSM_SEND_ATD_Check_Ballance;
			break;
		//------------------------
		case GSM_SEND_CIPMUX:
			if(GSM_MultiCon) GSM_Execute_Command(AT_CIPMUX_1, 100*GSM_DEBUG_DELAY);
    e8ce:	80 91 73 0c 	lds	r24, 0x0C73
    e8d2:	88 23       	and	r24, r24
    e8d4:	09 f4       	brne	.+2      	; 0xe8d8 <GSM_Cycle+0xf20>
    e8d6:	35 c3       	rjmp	.+1642   	; 0xef42 <GSM_Cycle+0x158a>
    e8d8:	81 e2       	ldi	r24, 0x21	; 33
    e8da:	95 e0       	ldi	r25, 0x05	; 5
    e8dc:	64 e6       	ldi	r22, 0x64	; 100
    e8de:	70 e0       	ldi	r23, 0x00	; 0
    e8e0:	0e 94 65 55 	call	0xaaca	; 0xaaca <GSM_Execute_Command>
			else GSM_Execute_Command(AT_CIPMUX_0, 100*GSM_DEBUG_DELAY);
			GSM_State++; 
    e8e4:	80 91 f6 06 	lds	r24, 0x06F6
    e8e8:	8f 5f       	subi	r24, 0xFF	; 255
    e8ea:	80 93 f6 06 	sts	0x06F6, r24
    e8ee:	84 c8       	rjmp	.-3832   	; 0xd9f8 <GSM_Cycle+0x40>
			break;
		case GSM_SEND_CSMP:
			GSM_Execute_Command(AT_CSMP, 100*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CSMP_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State=GSM_SEND_ATD_Check_Ballance;
    e8f0:	81 ef       	ldi	r24, 0xF1	; 241
    e8f2:	93 e0       	ldi	r25, 0x03	; 3
    e8f4:	6a e4       	ldi	r22, 0x4A	; 74
    e8f6:	0e 94 0a 55 	call	0xaa14	; 0xaa14 <GSM_Wait_Response_P>
    e8fa:	88 23       	and	r24, r24
    e8fc:	09 f4       	brne	.+2      	; 0xe900 <GSM_Cycle+0xf48>
    e8fe:	7c c8       	rjmp	.-3848   	; 0xd9f8 <GSM_Cycle+0x40>
    e900:	8c e4       	ldi	r24, 0x4C	; 76
    e902:	80 93 f6 06 	sts	0x06F6, r24
    e906:	78 c8       	rjmp	.-3856   	; 0xd9f8 <GSM_Cycle+0x40>
			break;
		case GSM_WAIT_CMGF_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;
		case GSM_SEND_CSMP:
			GSM_Execute_Command(AT_CSMP, 100*GSM_DEBUG_DELAY); GSM_State++;
    e908:	8d ed       	ldi	r24, 0xDD	; 221
    e90a:	94 e0       	ldi	r25, 0x04	; 4
    e90c:	64 e6       	ldi	r22, 0x64	; 100
    e90e:	70 e0       	ldi	r23, 0x00	; 0
    e910:	0e 94 65 55 	call	0xaaca	; 0xaaca <GSM_Execute_Command>
    e914:	80 91 f6 06 	lds	r24, 0x06F6
    e918:	8f 5f       	subi	r24, 0xFF	; 255
    e91a:	80 93 f6 06 	sts	0x06F6, r24
    e91e:	6c c8       	rjmp	.-3880   	; 0xd9f8 <GSM_Cycle+0x40>
///------------------------ / (  )
		case GSM_SEND_CMGF:
			GSM_Execute_Command(AT_CMGF,100*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CMGF_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    e920:	81 ef       	ldi	r24, 0xF1	; 241
    e922:	93 e0       	ldi	r25, 0x03	; 3
    e924:	6a e4       	ldi	r22, 0x4A	; 74
    e926:	0e 94 0a 55 	call	0xaa14	; 0xaa14 <GSM_Wait_Response_P>
    e92a:	88 23       	and	r24, r24
    e92c:	09 f4       	brne	.+2      	; 0xe930 <GSM_Cycle+0xf78>
    e92e:	64 c8       	rjmp	.-3896   	; 0xd9f8 <GSM_Cycle+0x40>
    e930:	80 91 f6 06 	lds	r24, 0x06F6
    e934:	8f 5f       	subi	r24, 0xFF	; 255
    e936:	80 93 f6 06 	sts	0x06F6, r24
    e93a:	5e c8       	rjmp	.-3908   	; 0xd9f8 <GSM_Cycle+0x40>

		case GSM_SEND_CIFSR:
			GSM_Execute_Command(AT_CIFSR, 1000*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CIFSR_OK:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
    e93c:	80 91 e9 04 	lds	r24, 0x04E9
    e940:	0e 94 96 25 	call	0x4b2c	; 0x4b2c <Timer16Stopp>
    e944:	88 23       	and	r24, r24
    e946:	19 f0       	breq	.+6      	; 0xe94e <GSM_Cycle+0xf96>
    e948:	8a e4       	ldi	r24, 0x4A	; 74
    e94a:	80 93 f6 06 	sts	0x06F6, r24
			if(GetStringFromFIFO()){
    e94e:	0e 94 10 42 	call	0x8420	; 0x8420 <GetStringFromFIFO>
    e952:	88 23       	and	r24, r24
    e954:	09 f4       	brne	.+2      	; 0xe958 <GSM_Cycle+0xfa0>
    e956:	50 c8       	rjmp	.-3936   	; 0xd9f8 <GSM_Cycle+0x40>
	uint8_t IP4;
} IP_Addr;

//~~~~~~~~~~~~~~
void SetIP(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	IP->IP1 = IP1;
    e958:	41 e3       	ldi	r20, 0x31	; 49
    e95a:	59 e0       	ldi	r21, 0x09	; 9
    e95c:	10 92 31 09 	sts	0x0931, r1
	IP->IP2 = IP2;
    e960:	ba 01       	movw	r22, r20
    e962:	6f 5f       	subi	r22, 0xFF	; 255
    e964:	7f 4f       	sbci	r23, 0xFF	; 255
    e966:	10 92 32 09 	sts	0x0932, r1
	IP->IP3 = IP3;
    e96a:	8a 01       	movw	r16, r20
    e96c:	0e 5f       	subi	r16, 0xFE	; 254
    e96e:	1f 4f       	sbci	r17, 0xFF	; 255
    e970:	10 92 33 09 	sts	0x0933, r1
	IP->IP4 = IP4;
    e974:	e3 e0       	ldi	r30, 0x03	; 3
    e976:	ee 2e       	mov	r14, r30
    e978:	f1 2c       	mov	r15, r1
    e97a:	e4 0e       	add	r14, r20
    e97c:	f5 1e       	adc	r15, r21
    e97e:	10 92 34 09 	sts	0x0934, r1
    e982:	20 e0       	ldi	r18, 0x00	; 0
    e984:	a1 ee       	ldi	r26, 0xE1	; 225
    e986:	b7 e0       	ldi	r27, 0x07	; 7
				SetIP(&GSM_MyIP,0,0,0,0);
				for(uint8_t i=0; i<strlen(GSM_RxStr); i++)
					if(!isdigit(GSM_RxStr[i])) GSM_RxStr[i] = ' ';
    e988:	30 e2       	ldi	r19, 0x20	; 32
			break;
		case GSM_WAIT_CIFSR_OK:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
			if(GetStringFromFIFO()){
				SetIP(&GSM_MyIP,0,0,0,0);
				for(uint8_t i=0; i<strlen(GSM_RxStr); i++)
    e98a:	fd 01       	movw	r30, r26
    e98c:	01 90       	ld	r0, Z+
    e98e:	00 20       	and	r0, r0
    e990:	e9 f7       	brne	.-6      	; 0xe98c <GSM_Cycle+0xfd4>
    e992:	31 97       	sbiw	r30, 0x01	; 1
    e994:	e1 5e       	subi	r30, 0xE1	; 225
    e996:	f7 40       	sbci	r31, 0x07	; 7
    e998:	82 2f       	mov	r24, r18
    e99a:	90 e0       	ldi	r25, 0x00	; 0
    e99c:	8e 17       	cp	r24, r30
    e99e:	9f 07       	cpc	r25, r31
    e9a0:	08 f0       	brcs	.+2      	; 0xe9a4 <GSM_Cycle+0xfec>
    e9a2:	90 c2       	rjmp	.+1312   	; 0xeec4 <GSM_Cycle+0x150c>
					if(!isdigit(GSM_RxStr[i])) GSM_RxStr[i] = ' ';
    e9a4:	fc 01       	movw	r30, r24
    e9a6:	ef 51       	subi	r30, 0x1F	; 31
    e9a8:	f8 4f       	sbci	r31, 0xF8	; 248
    e9aa:	80 81       	ld	r24, Z
    e9ac:	90 e0       	ldi	r25, 0x00	; 0
    e9ae:	c0 97       	sbiw	r24, 0x30	; 48
    e9b0:	0a 97       	sbiw	r24, 0x0a	; 10
    e9b2:	08 f0       	brcs	.+2      	; 0xe9b6 <GSM_Cycle+0xffe>
    e9b4:	30 83       	st	Z, r19
			break;
		case GSM_WAIT_CIFSR_OK:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
			if(GetStringFromFIFO()){
				SetIP(&GSM_MyIP,0,0,0,0);
				for(uint8_t i=0; i<strlen(GSM_RxStr); i++)
    e9b6:	2f 5f       	subi	r18, 0xFF	; 255
    e9b8:	e8 cf       	rjmp	.-48     	; 0xe98a <GSM_Cycle+0xfd2>
			break;

	

		case GSM_SEND_CIFSR:
			GSM_Execute_Command(AT_CIFSR, 1000*GSM_DEBUG_DELAY); GSM_State++;
    e9ba:	88 e5       	ldi	r24, 0x58	; 88
    e9bc:	95 e0       	ldi	r25, 0x05	; 5
    e9be:	68 ee       	ldi	r22, 0xE8	; 232
    e9c0:	73 e0       	ldi	r23, 0x03	; 3
    e9c2:	0e 94 65 55 	call	0xaaca	; 0xaaca <GSM_Execute_Command>
    e9c6:	80 91 f6 06 	lds	r24, 0x06F6
    e9ca:	8f 5f       	subi	r24, 0xFF	; 255
    e9cc:	80 93 f6 06 	sts	0x06F6, r24
    e9d0:	13 c8       	rjmp	.-4058   	; 0xd9f8 <GSM_Cycle+0x40>

		case GSM_SEND_CIICR:
			GSM_Execute_Command(AT_CIICR, 12000*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CIICR_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    e9d2:	81 ef       	ldi	r24, 0xF1	; 241
    e9d4:	93 e0       	ldi	r25, 0x03	; 3
    e9d6:	6a e4       	ldi	r22, 0x4A	; 74
    e9d8:	0e 94 0a 55 	call	0xaa14	; 0xaa14 <GSM_Wait_Response_P>
    e9dc:	88 23       	and	r24, r24
    e9de:	09 f4       	brne	.+2      	; 0xe9e2 <GSM_Cycle+0x102a>
    e9e0:	0b c8       	rjmp	.-4074   	; 0xd9f8 <GSM_Cycle+0x40>
    e9e2:	80 91 f6 06 	lds	r24, 0x06F6
    e9e6:	8f 5f       	subi	r24, 0xFF	; 255
    e9e8:	80 93 f6 06 	sts	0x06F6, r24
    e9ec:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
		case GSM_WAIT_CSTT_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;

		case GSM_SEND_CIICR:
			GSM_Execute_Command(AT_CIICR, 12000*GSM_DEBUG_DELAY); GSM_State++;
    e9f0:	8f e4       	ldi	r24, 0x4F	; 79
    e9f2:	95 e0       	ldi	r25, 0x05	; 5
    e9f4:	60 ee       	ldi	r22, 0xE0	; 224
    e9f6:	7e e2       	ldi	r23, 0x2E	; 46
    e9f8:	0e 94 65 55 	call	0xaaca	; 0xaaca <GSM_Execute_Command>
    e9fc:	80 91 f6 06 	lds	r24, 0x06F6
    ea00:	8f 5f       	subi	r24, 0xFF	; 255
    ea02:	80 93 f6 06 	sts	0x06F6, r24
    ea06:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
				}
		
			break;

		case GSM_WAIT_CIPSTART_TCP_CLIENT_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    ea0a:	81 ef       	ldi	r24, 0xF1	; 241
    ea0c:	93 e0       	ldi	r25, 0x03	; 3
    ea0e:	6a e4       	ldi	r22, 0x4A	; 74
    ea10:	0e 94 0a 55 	call	0xaa14	; 0xaa14 <GSM_Wait_Response_P>
    ea14:	88 23       	and	r24, r24
    ea16:	11 f4       	brne	.+4      	; 0xea1c <GSM_Cycle+0x1064>
    ea18:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
    ea1c:	80 91 f6 06 	lds	r24, 0x06F6
    ea20:	8f 5f       	subi	r24, 0xFF	; 255
    ea22:	80 93 f6 06 	sts	0x06F6, r24
    ea26:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
			}			
			break;
		//------------------------
		case GSM_SEND_CIPSTART_TCP_CLIENT:
	
				if(GSM_Flag & (1<<flg_TxCStr)){
    ea2a:	80 91 d2 02 	lds	r24, 0x02D2
    ea2e:	80 fd       	sbrc	r24, 0
    ea30:	02 c0       	rjmp	.+4      	; 0xea36 <GSM_Cycle+0x107e>
    ea32:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
					GSMTxSz = strlen_P(AT_CIPSTART_TCP_CLIENT);
    ea36:	58 e8       	ldi	r21, 0x88	; 136
    ea38:	e5 2e       	mov	r14, r21
    ea3a:	55 e0       	ldi	r21, 0x05	; 5
    ea3c:	f5 2e       	mov	r15, r21
    ea3e:	c7 01       	movw	r24, r14
    ea40:	0e 94 03 8b 	call	0x11606	; 0x11606 <strlen_P>
    ea44:	80 93 bb 07 	sts	0x07BB, r24
					sprintf_P(GSM_TxStr, AT_CIPSTART_TCP_CLIENT);
    ea48:	00 d0       	rcall	.+0      	; 0xea4a <GSM_Cycle+0x1092>
    ea4a:	0f 92       	push	r0
    ea4c:	0a e4       	ldi	r16, 0x4A	; 74
    ea4e:	1a e0       	ldi	r17, 0x0A	; 10
    ea50:	ad b7       	in	r26, 0x3d	; 61
    ea52:	be b7       	in	r27, 0x3e	; 62
    ea54:	12 96       	adiw	r26, 0x02	; 2
    ea56:	1c 93       	st	X, r17
    ea58:	0e 93       	st	-X, r16
    ea5a:	11 97       	sbiw	r26, 0x01	; 1
    ea5c:	14 96       	adiw	r26, 0x04	; 4
    ea5e:	fc 92       	st	X, r15
    ea60:	ee 92       	st	-X, r14
    ea62:	13 97       	sbiw	r26, 0x03	; 3
    ea64:	0e 94 20 8c 	call	0x11840	; 0x11840 <sprintf_P>
					//GSM_TxStr[12] = 0x30+TempNum;
					sprintf(GSM_TxStr + GSMTxSz, "\"%u.%u.%u.%u\",\"%u\"\r",(unsigned int)erb(&TCP_ServerIP[0].IP1), (unsigned int)erb(&TCP_ServerIP[0].IP2), 
    ea68:	b0 90 bb 07 	lds	r11, 0x07BB
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    ea6c:	0f 90       	pop	r0
    ea6e:	0f 90       	pop	r0
    ea70:	0f 90       	pop	r0
    ea72:	0f 90       	pop	r0
    ea74:	81 e9       	ldi	r24, 0x91	; 145
    ea76:	90 e0       	ldi	r25, 0x00	; 0
    ea78:	0e 94 1d 8e 	call	0x11c3a	; 0x11c3a <__eerd_byte_m2560>
    ea7c:	f8 2e       	mov	r15, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    ea7e:	82 e9       	ldi	r24, 0x92	; 146
    ea80:	90 e0       	ldi	r25, 0x00	; 0
    ea82:	0e 94 1d 8e 	call	0x11c3a	; 0x11c3a <__eerd_byte_m2560>
    ea86:	e8 2e       	mov	r14, r24
    ea88:	83 e9       	ldi	r24, 0x93	; 147
    ea8a:	90 e0       	ldi	r25, 0x00	; 0
    ea8c:	0e 94 1d 8e 	call	0x11c3a	; 0x11c3a <__eerd_byte_m2560>
    ea90:	d8 2e       	mov	r13, r24
    ea92:	84 e9       	ldi	r24, 0x94	; 148
    ea94:	90 e0       	ldi	r25, 0x00	; 0
    ea96:	0e 94 1d 8e 	call	0x11c3a	; 0x11c3a <__eerd_byte_m2560>
    ea9a:	c8 2e       	mov	r12, r24
    ea9c:	89 ea       	ldi	r24, 0xA9	; 169
    ea9e:	90 e0       	ldi	r25, 0x00	; 0
    eaa0:	0e 94 2b 8e 	call	0x11c56	; 0x11c56 <__eerd_word_m2560>
    eaa4:	ed b7       	in	r30, 0x3d	; 61
    eaa6:	fe b7       	in	r31, 0x3e	; 62
    eaa8:	3e 97       	sbiw	r30, 0x0e	; 14
    eaaa:	0f b6       	in	r0, 0x3f	; 63
    eaac:	f8 94       	cli
    eaae:	fe bf       	out	0x3e, r31	; 62
    eab0:	0f be       	out	0x3f, r0	; 63
    eab2:	ed bf       	out	0x3d, r30	; 61
    eab4:	31 96       	adiw	r30, 0x01	; 1
    eab6:	2b 2d       	mov	r18, r11
    eab8:	30 e0       	ldi	r19, 0x00	; 0
    eaba:	20 0f       	add	r18, r16
    eabc:	31 1f       	adc	r19, r17
    eabe:	ad b7       	in	r26, 0x3d	; 61
    eac0:	be b7       	in	r27, 0x3e	; 62
    eac2:	12 96       	adiw	r26, 0x02	; 2
    eac4:	3c 93       	st	X, r19
    eac6:	2e 93       	st	-X, r18
    eac8:	11 97       	sbiw	r26, 0x01	; 1
    eaca:	28 eb       	ldi	r18, 0xB8	; 184
    eacc:	32 e0       	ldi	r19, 0x02	; 2
    eace:	33 83       	std	Z+3, r19	; 0x03
    ead0:	22 83       	std	Z+2, r18	; 0x02
    ead2:	f4 82       	std	Z+4, r15	; 0x04
    ead4:	15 82       	std	Z+5, r1	; 0x05
    ead6:	e6 82       	std	Z+6, r14	; 0x06
    ead8:	17 82       	std	Z+7, r1	; 0x07
    eada:	d0 86       	std	Z+8, r13	; 0x08
    eadc:	11 86       	std	Z+9, r1	; 0x09
    eade:	c2 86       	std	Z+10, r12	; 0x0a
    eae0:	13 86       	std	Z+11, r1	; 0x0b
    eae2:	95 87       	std	Z+13, r25	; 0x0d
    eae4:	84 87       	std	Z+12, r24	; 0x0c
    eae6:	0e 94 ef 8b 	call	0x117de	; 0x117de <sprintf>
						(unsigned int)erb(&TCP_ServerIP[0].IP3), (unsigned int)erb(&TCP_ServerIP[0].IP4), (unsigned int)erw(&TCP_ServerPort[0]));
					GSMTxSz = strlen(GSM_TxStr);
    eaea:	f8 01       	movw	r30, r16
    eaec:	01 90       	ld	r0, Z+
    eaee:	00 20       	and	r0, r0
    eaf0:	e9 f7       	brne	.-6      	; 0xeaec <GSM_Cycle+0x1134>
    eaf2:	8f 01       	movw	r16, r30
    eaf4:	01 50       	subi	r16, 0x01	; 1
    eaf6:	10 40       	sbci	r17, 0x00	; 0
    eaf8:	0a 54       	subi	r16, 0x4A	; 74
    eafa:	1a 40       	sbci	r17, 0x0A	; 10
    eafc:	00 93 bb 07 	sts	0x07BB, r16
					GSM_SendFirstChar();
    eb00:	2d b7       	in	r18, 0x3d	; 61
    eb02:	3e b7       	in	r19, 0x3e	; 62
    eb04:	22 5f       	subi	r18, 0xF2	; 242
    eb06:	3f 4f       	sbci	r19, 0xFF	; 255
    eb08:	0f b6       	in	r0, 0x3f	; 63
    eb0a:	f8 94       	cli
    eb0c:	3e bf       	out	0x3e, r19	; 62
    eb0e:	0f be       	out	0x3f, r0	; 63
    eb10:	2d bf       	out	0x3d, r18	; 61
    eb12:	0e 94 3a 43 	call	0x8674	; 0x8674 <GSM_SendFirstChar>
					StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    eb16:	80 91 e9 04 	lds	r24, 0x04E9
    eb1a:	64 ef       	ldi	r22, 0xF4	; 244
    eb1c:	71 e0       	ldi	r23, 0x01	; 1
    eb1e:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
					GSM_State++;
    eb22:	80 91 f6 06 	lds	r24, 0x06F6
    eb26:	8f 5f       	subi	r24, 0xFF	; 255
    eb28:	80 93 f6 06 	sts	0x06F6, r24
    eb2c:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>

		case GSM_WAIT_CIPSTART_TCP_CLIENT_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;
		case GSM_WAIT_CIPSTART_TCP_CLIENT_CONNECT:
			if(GSM_Wait_Response_P(RESP_CONNECT, GSM_ReStart1)){
    eb30:	84 ef       	ldi	r24, 0xF4	; 244
    eb32:	93 e0       	ldi	r25, 0x03	; 3
    eb34:	6a e4       	ldi	r22, 0x4A	; 74
    eb36:	0e 94 0a 55 	call	0xaa14	; 0xaa14 <GSM_Wait_Response_P>
    eb3a:	88 23       	and	r24, r24
    eb3c:	11 f4       	brne	.+4      	; 0xeb42 <GSM_Cycle+0x118a>
    eb3e:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
				 GSM_State = GSM_WAIT_IDENTIFICATION;
    eb42:	8e e3       	ldi	r24, 0x3E	; 62
    eb44:	80 93 f6 06 	sts	0x06F6, r24
				 StartTimer16(TD_GSM, 1000*GSM_DEBUG_DELAY);
    eb48:	80 91 e9 04 	lds	r24, 0x04E9
    eb4c:	68 ee       	ldi	r22, 0xE8	; 232
    eb4e:	73 e0       	ldi	r23, 0x03	; 3
    eb50:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
    eb54:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
				StartTimer16(TD_GSM, 300*GSM_DEBUG_DELAY);
			}
			GSM_State++;
			break;
		case GSM_WAIT_CIPCSGP_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    eb58:	81 ef       	ldi	r24, 0xF1	; 241
    eb5a:	93 e0       	ldi	r25, 0x03	; 3
    eb5c:	6a e4       	ldi	r22, 0x4A	; 74
    eb5e:	0e 94 0a 55 	call	0xaa14	; 0xaa14 <GSM_Wait_Response_P>
    eb62:	88 23       	and	r24, r24
    eb64:	11 f4       	brne	.+4      	; 0xeb6a <GSM_Cycle+0x11b2>
    eb66:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
			 if(GSM_Modem == SIMCOM_SIM800)GSM_State++;
    eb6a:	80 91 34 07 	lds	r24, 0x0734
    eb6e:	82 30       	cpi	r24, 0x02	; 2
    eb70:	09 f4       	brne	.+2      	; 0xeb74 <GSM_Cycle+0x11bc>
    eb72:	2e c4       	rjmp	.+2140   	; 0xf3d0 <GSM_Cycle+0x1a18>
			 else GSM_State=GSM_SEND_CSTT;
    eb74:	85 e3       	ldi	r24, 0x35	; 53
    eb76:	80 93 f6 06 	sts	0x06F6, r24
    eb7a:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
			if(GSM_Wait_Response_P(RESP_OK, GSM_SEND_CGATT)) GSM_State++;
			break;

		case GSM_SEND_CIPCSGP:
			//GSM_Execute_Command(AT_CIPCSGP, 300*GSM_DEBUG_DELAY); GSM_State++;
			if(GSM_Flag & (1<<flg_TxCStr)){
    eb7e:	80 91 d2 02 	lds	r24, 0x02D2
    eb82:	80 fd       	sbrc	r24, 0
    eb84:	fb c2       	rjmp	.+1526   	; 0xf17c <GSM_Cycle+0x17c4>
				GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn_psw);
				sprintf(GSM_TxStr + GSMTxSz, "\"\r");	GSMTxSz = GSMTxSz+2;
				GSM_SendFirstChar();
				StartTimer16(TD_GSM, 300*GSM_DEBUG_DELAY);
			}
			GSM_State++;
    eb86:	80 91 f6 06 	lds	r24, 0x06F6
    eb8a:	8f 5f       	subi	r24, 0xFF	; 255
    eb8c:	80 93 f6 06 	sts	0x06F6, r24
    eb90:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
			break;
		case GSM_SEND_CGATT:
			GSM_Execute_Command(AT_CGATT, 500*GSM_DEBUG_DELAY); GSM_Temp++; GSM_State++;
			break;
		case GSM_WAIT_CGATT_OK:
			if(GSM_Temp>20) GSM_State = GSM_ReStart1;
    eb94:	80 91 db 05 	lds	r24, 0x05DB
    eb98:	85 31       	cpi	r24, 0x15	; 21
    eb9a:	18 f0       	brcs	.+6      	; 0xeba2 <GSM_Cycle+0x11ea>
    eb9c:	8a e4       	ldi	r24, 0x4A	; 74
    eb9e:	80 93 f6 06 	sts	0x06F6, r24
			if(GSM_Wait_Response_P(RESP_OK, GSM_SEND_CGATT)) GSM_State++;
    eba2:	81 ef       	ldi	r24, 0xF1	; 241
    eba4:	93 e0       	ldi	r25, 0x03	; 3
    eba6:	6f e2       	ldi	r22, 0x2F	; 47
    eba8:	0e 94 0a 55 	call	0xaa14	; 0xaa14 <GSM_Wait_Response_P>
    ebac:	88 23       	and	r24, r24
    ebae:	11 f4       	brne	.+4      	; 0xebb4 <GSM_Cycle+0x11fc>
    ebb0:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
    ebb4:	80 91 f6 06 	lds	r24, 0x06F6
    ebb8:	8f 5f       	subi	r24, 0xFF	; 255
    ebba:	80 93 f6 06 	sts	0x06F6, r24
    ebbe:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>

		case GSM_SEND_CIPTKA:
			GSM_Execute_Command(AT_CIPTKA, 1000*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CIPTKA_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    ebc2:	81 ef       	ldi	r24, 0xF1	; 241
    ebc4:	93 e0       	ldi	r25, 0x03	; 3
    ebc6:	6a e4       	ldi	r22, 0x4A	; 74
    ebc8:	0e 94 0a 55 	call	0xaa14	; 0xaa14 <GSM_Wait_Response_P>
    ebcc:	88 23       	and	r24, r24
    ebce:	11 f4       	brne	.+4      	; 0xebd4 <GSM_Cycle+0x121c>
    ebd0:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
    ebd4:	80 91 f6 06 	lds	r24, 0x06F6
    ebd8:	8f 5f       	subi	r24, 0xFF	; 255
    ebda:	80 93 f6 06 	sts	0x06F6, r24
    ebde:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
			 else GSM_State=GSM_SEND_CSTT;
			 }
			break;

		case GSM_SEND_CIPTKA:
			GSM_Execute_Command(AT_CIPTKA, 1000*GSM_DEBUG_DELAY); GSM_State++;
    ebe2:	81 e6       	ldi	r24, 0x61	; 97
    ebe4:	95 e0       	ldi	r25, 0x05	; 5
    ebe6:	68 ee       	ldi	r22, 0xE8	; 232
    ebe8:	73 e0       	ldi	r23, 0x03	; 3
    ebea:	0e 94 65 55 	call	0xaaca	; 0xaaca <GSM_Execute_Command>
    ebee:	80 91 f6 06 	lds	r24, 0x06F6
    ebf2:	8f 5f       	subi	r24, 0xFF	; 255
    ebf4:	80 93 f6 06 	sts	0x06F6, r24
    ebf8:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
		case GSM_WAIT_CIPTKA_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;

		case GSM_SEND_CSTT:
			GSM_Execute_Command(AT_CSTT, 300*GSM_DEBUG_DELAY); GSM_State++;
    ebfc:	87 e4       	ldi	r24, 0x47	; 71
    ebfe:	95 e0       	ldi	r25, 0x05	; 5
    ec00:	6c e2       	ldi	r22, 0x2C	; 44
    ec02:	71 e0       	ldi	r23, 0x01	; 1
    ec04:	0e 94 65 55 	call	0xaaca	; 0xaaca <GSM_Execute_Command>
    ec08:	80 91 f6 06 	lds	r24, 0x06F6
    ec0c:	8f 5f       	subi	r24, 0xFF	; 255
    ec0e:	80 93 f6 06 	sts	0x06F6, r24
    ec12:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
				GSM_State++;
				GSM_Temp = 0;
			}
			break;
		case GSM_SEND_CGATT:
			GSM_Execute_Command(AT_CGATT, 500*GSM_DEBUG_DELAY); GSM_Temp++; GSM_State++;
    ec16:	8d e2       	ldi	r24, 0x2D	; 45
    ec18:	95 e0       	ldi	r25, 0x05	; 5
    ec1a:	64 ef       	ldi	r22, 0xF4	; 244
    ec1c:	71 e0       	ldi	r23, 0x01	; 1
    ec1e:	0e 94 65 55 	call	0xaaca	; 0xaaca <GSM_Execute_Command>
    ec22:	80 91 db 05 	lds	r24, 0x05DB
    ec26:	8f 5f       	subi	r24, 0xFF	; 255
    ec28:	80 93 db 05 	sts	0x05DB, r24
    ec2c:	80 91 f6 06 	lds	r24, 0x06F6
    ec30:	8f 5f       	subi	r24, 0xFF	; 255
    ec32:	80 93 f6 06 	sts	0x06F6, r24
    ec36:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
				StartTimer16(TD_GSM,200);
				GSM_State++;
			}
			break;
		case GSM_SAVE_IPR:
			if(Timer16Stopp(TD_GSM)) GSM_State++;
    ec3a:	80 91 e9 04 	lds	r24, 0x04E9
    ec3e:	0e 94 96 25 	call	0x4b2c	; 0x4b2c <Timer16Stopp>
    ec42:	88 23       	and	r24, r24
    ec44:	11 f4       	brne	.+4      	; 0xec4a <GSM_Cycle+0x1292>
    ec46:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
    ec4a:	80 91 f6 06 	lds	r24, 0x06F6
    ec4e:	8f 5f       	subi	r24, 0xFF	; 255
    ec50:	80 93 f6 06 	sts	0x06F6, r24
    ec54:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
			break;
		case GSM_CFG_SEND_ATW:
			GSM_Execute_Command(AT_W, 100); GSM_State++;
			break;
		case GSM_CFG_WAIT_ATW_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_CFG_SEND_AT)){
    ec58:	81 ef       	ldi	r24, 0xF1	; 241
    ec5a:	93 e0       	ldi	r25, 0x03	; 3
    ec5c:	61 e0       	ldi	r22, 0x01	; 1
    ec5e:	0e 94 0a 55 	call	0xaa14	; 0xaa14 <GSM_Wait_Response_P>
    ec62:	88 23       	and	r24, r24
    ec64:	11 f4       	brne	.+4      	; 0xec6a <GSM_Cycle+0x12b2>
    ec66:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
				StartTimer16(TD_GSM,200);
    ec6a:	80 91 e9 04 	lds	r24, 0x04E9
    ec6e:	68 ec       	ldi	r22, 0xC8	; 200
    ec70:	70 e0       	ldi	r23, 0x00	; 0
    ec72:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
				GSM_State++;
    ec76:	80 91 f6 06 	lds	r24, 0x06F6
    ec7a:	8f 5f       	subi	r24, 0xFF	; 255
    ec7c:	80 93 f6 06 	sts	0x06F6, r24
    ec80:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
			break;
		case GSM_CFG_SEND_AT:
			if(Timer16Stopp(TD_GSM)) GSM_Execute_Command(AT_AT, 100); GSM_State++;
			break;
		case GSM_CFG_WAIT_AT_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_CFG_SEND_AT)) GSM_State++;
    ec84:	81 ef       	ldi	r24, 0xF1	; 241
    ec86:	93 e0       	ldi	r25, 0x03	; 3
    ec88:	61 e0       	ldi	r22, 0x01	; 1
    ec8a:	0e 94 0a 55 	call	0xaa14	; 0xaa14 <GSM_Wait_Response_P>
    ec8e:	88 23       	and	r24, r24
    ec90:	11 f4       	brne	.+4      	; 0xec96 <GSM_Cycle+0x12de>
    ec92:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
    ec96:	80 91 f6 06 	lds	r24, 0x06F6
    ec9a:	8f 5f       	subi	r24, 0xFF	; 255
    ec9c:	80 93 f6 06 	sts	0x06F6, r24
    eca0:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
			StartTimer16(TD_GSM,200);
			GSM_PWRCNTRL_ON();
			GSM_State++;
			break;
		case GSM_CFG_SEND_AT:
			if(Timer16Stopp(TD_GSM)) GSM_Execute_Command(AT_AT, 100); GSM_State++;
    eca4:	80 91 e9 04 	lds	r24, 0x04E9
    eca8:	0e 94 96 25 	call	0x4b2c	; 0x4b2c <Timer16Stopp>
    ecac:	88 23       	and	r24, r24
    ecae:	31 f0       	breq	.+12     	; 0xecbc <GSM_Cycle+0x1304>
    ecb0:	8d e6       	ldi	r24, 0x6D	; 109
    ecb2:	94 e0       	ldi	r25, 0x04	; 4
    ecb4:	64 e6       	ldi	r22, 0x64	; 100
    ecb6:	70 e0       	ldi	r23, 0x00	; 0
    ecb8:	0e 94 65 55 	call	0xaaca	; 0xaaca <GSM_Execute_Command>
    ecbc:	80 91 f6 06 	lds	r24, 0x06F6
    ecc0:	8f 5f       	subi	r24, 0xFF	; 255
    ecc2:	80 93 f6 06 	sts	0x06F6, r24
    ecc6:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
			break;
		case GSM_CFG_SEND_IPR:
			GSM_Execute_Command(AT_IPR9600, 100); GSM_State++;
			break;
		case GSM_CFG_WAIT_IPR_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_CFG_SEND_AT)){
    ecca:	81 ef       	ldi	r24, 0xF1	; 241
    eccc:	93 e0       	ldi	r25, 0x03	; 3
    ecce:	61 e0       	ldi	r22, 0x01	; 1
    ecd0:	0e 94 0a 55 	call	0xaa14	; 0xaa14 <GSM_Wait_Response_P>
    ecd4:	88 23       	and	r24, r24
    ecd6:	11 f4       	brne	.+4      	; 0xecdc <GSM_Cycle+0x1324>
    ecd8:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
				StartTimer16(TD_GSM,200);
    ecdc:	80 91 e9 04 	lds	r24, 0x04E9
    ece0:	68 ec       	ldi	r22, 0xC8	; 200
    ece2:	70 e0       	ldi	r23, 0x00	; 0
    ece4:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
				GSM_State++;
    ece8:	80 91 f6 06 	lds	r24, 0x06F6
    ecec:	8f 5f       	subi	r24, 0xFF	; 255
    ecee:	80 93 f6 06 	sts	0x06F6, r24
    ecf2:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
			if(GSM_Wait_Response_P(RESP_OK,GSM_SEND_CSQ)) GSM_State++;
			break;
		case GSM_WAIT_Ballance:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_SEND_CSQ;
			GSM_RxStr[GSM_RXSTR_SIZE-1]='\0';
			while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    ecf6:	00 e0       	ldi	r16, 0x00	; 0
    ecf8:	32 e0       	ldi	r19, 0x02	; 2
    ecfa:	c3 2e       	mov	r12, r19
    ecfc:	d1 2c       	mov	r13, r1
    ecfe:	cc 0e       	add	r12, r28
    ed00:	dd 1e       	adc	r13, r29
    ed02:	09 c0       	rjmp	.+18     	; 0xed16 <GSM_Cycle+0x135e>
				}

			}//while
			char buf[20];
			uint8_t i=0;
			while( (erb(&GPRS_currency[i])!='\0') && ((erb(&GPRS_currency[i])!=' ')||i==0) ){
    ed04:	80 32       	cpi	r24, 0x20	; 32
    ed06:	11 f4       	brne	.+4      	; 0xed0c <GSM_Cycle+0x1354>
    ed08:	00 23       	and	r16, r16
    ed0a:	71 f4       	brne	.+28     	; 0xed28 <GSM_Cycle+0x1370>
				buf[i] = (char)erb(&GPRS_currency[i]);
    ed0c:	ec 0c       	add	r14, r12
    ed0e:	fd 1c       	adc	r15, r13
    ed10:	f7 01       	movw	r30, r14
    ed12:	80 83       	st	Z, r24
				i++;
    ed14:	0f 5f       	subi	r16, 0xFF	; 255
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    ed16:	e0 2e       	mov	r14, r16
    ed18:	ff 24       	eor	r15, r15
    ed1a:	c7 01       	movw	r24, r14
    ed1c:	8b 5b       	subi	r24, 0xBB	; 187
    ed1e:	9f 4f       	sbci	r25, 0xFF	; 255
    ed20:	0e 94 1d 8e 	call	0x11c3a	; 0x11c3a <__eerd_byte_m2560>
				}

			}//while
			char buf[20];
			uint8_t i=0;
			while( (erb(&GPRS_currency[i])!='\0') && ((erb(&GPRS_currency[i])!=' ')||i==0) ){
    ed24:	88 23       	and	r24, r24
    ed26:	71 f7       	brne	.-36     	; 0xed04 <GSM_Cycle+0x134c>
				buf[i] = (char)erb(&GPRS_currency[i]);
				i++;
			}
			buf[i]='\0';
    ed28:	ec 0c       	add	r14, r12
    ed2a:	fd 1c       	adc	r15, r13
    ed2c:	d7 01       	movw	r26, r14
    ed2e:	1c 92       	st	X, r1
			char *istr=strstr(GSM_RxStr, buf);
    ed30:	81 ee       	ldi	r24, 0xE1	; 225
    ed32:	97 e0       	ldi	r25, 0x07	; 7
    ed34:	b6 01       	movw	r22, r12
    ed36:	0e 94 67 8b 	call	0x116ce	; 0x116ce <strstr>
			if(istr)
    ed3a:	00 97       	sbiw	r24, 0x00	; 0
    ed3c:	11 f4       	brne	.+4      	; 0xed42 <GSM_Cycle+0x138a>
    ed3e:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
			{
					Ballance=*(istr-1)-0x30;
    ed42:	fc 01       	movw	r30, r24
    ed44:	82 91       	ld	r24, -Z
    ed46:	90 e0       	ldi	r25, 0x00	; 0
    ed48:	c0 97       	sbiw	r24, 0x30	; 48
    ed4a:	aa 27       	eor	r26, r26
    ed4c:	97 fd       	sbrc	r25, 7
    ed4e:	a0 95       	com	r26
    ed50:	ba 2f       	mov	r27, r26
    ed52:	80 93 fb 06 	sts	0x06FB, r24
    ed56:	90 93 fc 06 	sts	0x06FC, r25
    ed5a:	a0 93 fd 06 	sts	0x06FD, r26
    ed5e:	b0 93 fe 06 	sts	0x06FE, r27
					Ballance+=(*(istr-2)-0x30)*10;
    ed62:	22 91       	ld	r18, -Z
    ed64:	8f 01       	movw	r16, r30
    ed66:	4a e0       	ldi	r20, 0x0A	; 10
    ed68:	24 9f       	mul	r18, r20
    ed6a:	90 01       	movw	r18, r0
    ed6c:	11 24       	eor	r1, r1
    ed6e:	20 5e       	subi	r18, 0xE0	; 224
    ed70:	31 40       	sbci	r19, 0x01	; 1
    ed72:	49 01       	movw	r8, r18
    ed74:	aa 24       	eor	r10, r10
    ed76:	97 fc       	sbrc	r9, 7
    ed78:	a0 94       	com	r10
    ed7a:	ba 2c       	mov	r11, r10
    ed7c:	88 0e       	add	r8, r24
    ed7e:	99 1e       	adc	r9, r25
    ed80:	aa 1e       	adc	r10, r26
    ed82:	bb 1e       	adc	r11, r27
    ed84:	80 92 fb 06 	sts	0x06FB, r8
    ed88:	90 92 fc 06 	sts	0x06FC, r9
    ed8c:	a0 92 fd 06 	sts	0x06FD, r10
    ed90:	b0 92 fe 06 	sts	0x06FE, r11
					uint8_t charnum=4;
					uint32_t razr=100;
					while((*(istr-charnum)>=0x30)&&(*(istr-charnum)<=0x39)){
    ed94:	02 50       	subi	r16, 0x02	; 2
    ed96:	10 40       	sbci	r17, 0x00	; 0
    ed98:	d8 01       	movw	r26, r16
    ed9a:	6c 91       	ld	r22, X
    ed9c:	0c 5f       	subi	r16, 0xFC	; 252
    ed9e:	1f 4f       	sbci	r17, 0xFF	; 255
    eda0:	86 2f       	mov	r24, r22
    eda2:	80 53       	subi	r24, 0x30	; 48
    eda4:	8a 30       	cpi	r24, 0x0A	; 10
    eda6:	88 f5       	brcc	.+98     	; 0xee0a <GSM_Cycle+0x1452>
    eda8:	24 e0       	ldi	r18, 0x04	; 4
    edaa:	72 2e       	mov	r7, r18
    edac:	94 e6       	ldi	r25, 0x64	; 100
    edae:	c9 2e       	mov	r12, r25
    edb0:	d1 2c       	mov	r13, r1
    edb2:	e1 2c       	mov	r14, r1
    edb4:	f1 2c       	mov	r15, r1
						Ballance+=(*(istr-charnum)-0x30)*razr;
    edb6:	70 e0       	ldi	r23, 0x00	; 0
    edb8:	60 53       	subi	r22, 0x30	; 48
    edba:	70 40       	sbci	r23, 0x00	; 0
    edbc:	88 27       	eor	r24, r24
    edbe:	77 fd       	sbrc	r23, 7
    edc0:	80 95       	com	r24
    edc2:	98 2f       	mov	r25, r24
    edc4:	a7 01       	movw	r20, r14
    edc6:	96 01       	movw	r18, r12
    edc8:	0e 94 59 8e 	call	0x11cb2	; 0x11cb2 <__mulsi3>
    edcc:	86 0e       	add	r8, r22
    edce:	97 1e       	adc	r9, r23
    edd0:	a8 1e       	adc	r10, r24
    edd2:	b9 1e       	adc	r11, r25
    edd4:	80 92 fb 06 	sts	0x06FB, r8
    edd8:	90 92 fc 06 	sts	0x06FC, r9
    eddc:	a0 92 fd 06 	sts	0x06FD, r10
    ede0:	b0 92 fe 06 	sts	0x06FE, r11
						razr*=10;
    ede4:	c7 01       	movw	r24, r14
    ede6:	b6 01       	movw	r22, r12
    ede8:	2a e0       	ldi	r18, 0x0A	; 10
    edea:	30 e0       	ldi	r19, 0x00	; 0
    edec:	40 e0       	ldi	r20, 0x00	; 0
    edee:	50 e0       	ldi	r21, 0x00	; 0
    edf0:	0e 94 59 8e 	call	0x11cb2	; 0x11cb2 <__mulsi3>
    edf4:	6b 01       	movw	r12, r22
    edf6:	7c 01       	movw	r14, r24
						charnum++;	
    edf8:	73 94       	inc	r7
			{
					Ballance=*(istr-1)-0x30;
					Ballance+=(*(istr-2)-0x30)*10;
					uint8_t charnum=4;
					uint32_t razr=100;
					while((*(istr-charnum)>=0x30)&&(*(istr-charnum)<=0x39)){
    edfa:	f8 01       	movw	r30, r16
    edfc:	e7 19       	sub	r30, r7
    edfe:	f1 09       	sbc	r31, r1
    ee00:	60 81       	ld	r22, Z
    ee02:	86 2f       	mov	r24, r22
    ee04:	80 53       	subi	r24, 0x30	; 48
    ee06:	8a 30       	cpi	r24, 0x0A	; 10
    ee08:	b0 f2       	brcs	.-84     	; 0xedb6 <GSM_Cycle+0x13fe>
						Ballance+=(*(istr-charnum)-0x30)*razr;
						razr*=10;
						charnum++;	
					}
					if(*(istr-charnum)==0x2D)
    ee0a:	6d 32       	cpi	r22, 0x2D	; 45
    ee0c:	11 f0       	breq	.+4      	; 0xee12 <GSM_Cycle+0x145a>
    ee0e:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
					{
						Ballance*=-1;
    ee12:	80 91 fb 06 	lds	r24, 0x06FB
    ee16:	90 91 fc 06 	lds	r25, 0x06FC
    ee1a:	a0 91 fd 06 	lds	r26, 0x06FD
    ee1e:	b0 91 fe 06 	lds	r27, 0x06FE
    ee22:	b0 95       	com	r27
    ee24:	a0 95       	com	r26
    ee26:	90 95       	com	r25
    ee28:	81 95       	neg	r24
    ee2a:	9f 4f       	sbci	r25, 0xFF	; 255
    ee2c:	af 4f       	sbci	r26, 0xFF	; 255
    ee2e:	bf 4f       	sbci	r27, 0xFF	; 255
    ee30:	80 93 fb 06 	sts	0x06FB, r24
    ee34:	90 93 fc 06 	sts	0x06FC, r25
    ee38:	a0 93 fd 06 	sts	0x06FD, r26
    ee3c:	b0 93 fe 06 	sts	0x06FE, r27
    ee40:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
					GSM_State = GSM_WAIT_DISCONNECT_CAUSE;
					StartTimer16(TD_GSM, 10000);
					break;
				}
			}
			if(Timer16Stopp(TD_GSM)){
    ee44:	80 91 e9 04 	lds	r24, 0x04E9
    ee48:	0e 94 96 25 	call	0x4b2c	; 0x4b2c <Timer16Stopp>
    ee4c:	88 23       	and	r24, r24
    ee4e:	11 f4       	brne	.+4      	; 0xee54 <GSM_Cycle+0x149c>
    ee50:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
				GSM_State = GSM_WAIT_MESSAGE;
    ee54:	8e e0       	ldi	r24, 0x0E	; 14
    ee56:	80 93 f6 06 	sts	0x06F6, r24
    ee5a:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
				if((strstr_P(GSM_RxStr, PSTR("+CREC: 0")) != NULL) ){
					GSM_State = GSM_SEND_PLAY_CONFIRM_FILE;
					break;
				}
			}
			if(Timer16Stopp(TD_GSM)){
    ee5e:	80 91 e9 04 	lds	r24, 0x04E9
    ee62:	0e 94 96 25 	call	0x4b2c	; 0x4b2c <Timer16Stopp>
    ee66:	88 23       	and	r24, r24
    ee68:	11 f4       	brne	.+4      	; 0xee6e <GSM_Cycle+0x14b6>
    ee6a:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
				GSM_State = GSM_WAIT_MESSAGE;
    ee6e:	8e e0       	ldi	r24, 0x0E	; 14
    ee70:	80 93 f6 06 	sts	0x06F6, r24
    ee74:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
				if((strstr_P(GSM_RxStr, PSTR("+CREC: 0")) != NULL) ){
					GSM_State = GSM_WAIT_CONFIRMRESPONSE;
					StartTimer16(TD_GSM, 200);
					break;
				}
				if(analize_DTMF()){
    ee78:	0e 94 78 55 	call	0xaaf0	; 0xaaf0 <analize_DTMF>
    ee7c:	88 23       	and	r24, r24
    ee7e:	11 f0       	breq	.+4      	; 0xee84 <GSM_Cycle+0x14cc>
    ee80:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
					break;
				}
			}
			if(Timer16Stopp(TD_GSM)){
    ee84:	80 91 e9 04 	lds	r24, 0x04E9
    ee88:	0e 94 96 25 	call	0x4b2c	; 0x4b2c <Timer16Stopp>
    ee8c:	88 23       	and	r24, r24
    ee8e:	11 f4       	brne	.+4      	; 0xee94 <GSM_Cycle+0x14dc>
    ee90:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
				GSM_State = GSM_WAIT_MESSAGE;
    ee94:	8e e0       	ldi	r24, 0x0E	; 14
    ee96:	80 93 f6 06 	sts	0x06F6, r24
    ee9a:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
			if(GetStringFromFIFO()){
				if((strstr_P(GSM_RxStr, PSTR("+CREC: 0")) != NULL) ){
					GSM_State = GSM_SEND_PLAY_CONFIRMREQUEST_FILE;
					break;
				}
				if(analize_DTMF()){
    ee9e:	0e 94 78 55 	call	0xaaf0	; 0xaaf0 <analize_DTMF>
    eea2:	88 23       	and	r24, r24
    eea4:	11 f0       	breq	.+4      	; 0xeeaa <GSM_Cycle+0x14f2>
    eea6:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
					break;
				}
			}
			if(Timer16Stopp(TD_GSM)){
    eeaa:	80 91 e9 04 	lds	r24, 0x04E9
    eeae:	0e 94 96 25 	call	0x4b2c	; 0x4b2c <Timer16Stopp>
    eeb2:	88 23       	and	r24, r24
    eeb4:	11 f4       	brne	.+4      	; 0xeeba <GSM_Cycle+0x1502>
    eeb6:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
				GSM_State = GSM_WAIT_MESSAGE;
    eeba:	8e e0       	ldi	r24, 0x0E	; 14
    eebc:	80 93 f6 06 	sts	0x06F6, r24
    eec0:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
			if(GetStringFromFIFO()){
				SetIP(&GSM_MyIP,0,0,0,0);
				for(uint8_t i=0; i<strlen(GSM_RxStr); i++)
					if(!isdigit(GSM_RxStr[i])) GSM_RxStr[i] = ' ';
				sscanf_P(GSM_RxStr,PSTR("%hhu %hhu %hhu %hhu"), (unsigned char*)&GSM_MyIP.IP1, (unsigned char*)&GSM_MyIP.IP2, (unsigned char*)&GSM_MyIP.IP3, (unsigned char*)&GSM_MyIP.IP4);
    eec4:	ed b7       	in	r30, 0x3d	; 61
    eec6:	fe b7       	in	r31, 0x3e	; 62
    eec8:	3c 97       	sbiw	r30, 0x0c	; 12
    eeca:	0f b6       	in	r0, 0x3f	; 63
    eecc:	f8 94       	cli
    eece:	fe bf       	out	0x3e, r31	; 62
    eed0:	0f be       	out	0x3f, r0	; 63
    eed2:	ed bf       	out	0x3d, r30	; 61
    eed4:	31 96       	adiw	r30, 0x01	; 1
    eed6:	81 ee       	ldi	r24, 0xE1	; 225
    eed8:	97 e0       	ldi	r25, 0x07	; 7
    eeda:	ad b7       	in	r26, 0x3d	; 61
    eedc:	be b7       	in	r27, 0x3e	; 62
    eede:	12 96       	adiw	r26, 0x02	; 2
    eee0:	9c 93       	st	X, r25
    eee2:	8e 93       	st	-X, r24
    eee4:	11 97       	sbiw	r26, 0x01	; 1
    eee6:	85 e5       	ldi	r24, 0x55	; 85
    eee8:	9e e3       	ldi	r25, 0x3E	; 62
    eeea:	93 83       	std	Z+3, r25	; 0x03
    eeec:	82 83       	std	Z+2, r24	; 0x02
    eeee:	55 83       	std	Z+5, r21	; 0x05
    eef0:	44 83       	std	Z+4, r20	; 0x04
    eef2:	77 83       	std	Z+7, r23	; 0x07
    eef4:	66 83       	std	Z+6, r22	; 0x06
    eef6:	11 87       	std	Z+9, r17	; 0x09
    eef8:	00 87       	std	Z+8, r16	; 0x08
    eefa:	f3 86       	std	Z+11, r15	; 0x0b
    eefc:	e2 86       	std	Z+10, r14	; 0x0a
    eefe:	0e 94 74 8c 	call	0x118e8	; 0x118e8 <sscanf_P>
}
uint8_t IP_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	if((IP->IP1 == IP1) && (IP->IP2 == IP2) && (IP->IP3 == IP3) && (IP->IP4 == IP4)) return 1;
    ef02:	ed b7       	in	r30, 0x3d	; 61
    ef04:	fe b7       	in	r31, 0x3e	; 62
    ef06:	3c 96       	adiw	r30, 0x0c	; 12
    ef08:	0f b6       	in	r0, 0x3f	; 63
    ef0a:	f8 94       	cli
    ef0c:	fe bf       	out	0x3e, r31	; 62
    ef0e:	0f be       	out	0x3f, r0	; 63
    ef10:	ed bf       	out	0x3d, r30	; 61
    ef12:	80 91 31 09 	lds	r24, 0x0931
    ef16:	88 23       	and	r24, r24
    ef18:	09 f0       	breq	.+2      	; 0xef1c <GSM_Cycle+0x1564>
    ef1a:	91 c0       	rjmp	.+290    	; 0xf03e <GSM_Cycle+0x1686>
    ef1c:	80 91 32 09 	lds	r24, 0x0932
    ef20:	88 23       	and	r24, r24
    ef22:	09 f0       	breq	.+2      	; 0xef26 <GSM_Cycle+0x156e>
    ef24:	8c c0       	rjmp	.+280    	; 0xf03e <GSM_Cycle+0x1686>
    ef26:	80 91 33 09 	lds	r24, 0x0933
    ef2a:	88 23       	and	r24, r24
    ef2c:	09 f0       	breq	.+2      	; 0xef30 <GSM_Cycle+0x1578>
    ef2e:	87 c0       	rjmp	.+270    	; 0xf03e <GSM_Cycle+0x1686>
    ef30:	80 91 34 09 	lds	r24, 0x0934
    ef34:	88 23       	and	r24, r24
    ef36:	09 f0       	breq	.+2      	; 0xef3a <GSM_Cycle+0x1582>
    ef38:	82 c0       	rjmp	.+260    	; 0xf03e <GSM_Cycle+0x1686>
				if(!IP_compare_Const(&GSM_MyIP,0,0,0,0)){
				  GSM_State = GSM_SEND_CIPSTART_TCP_CLIENT;
				}
				TempNum=0;	//
    ef3a:	10 92 dc 05 	sts	0x05DC, r1
    ef3e:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State=GSM_SEND_ATD_Check_Ballance;
			break;
		//------------------------
		case GSM_SEND_CIPMUX:
			if(GSM_MultiCon) GSM_Execute_Command(AT_CIPMUX_1, 100*GSM_DEBUG_DELAY);
			else GSM_Execute_Command(AT_CIPMUX_0, 100*GSM_DEBUG_DELAY);
    ef42:	85 e1       	ldi	r24, 0x15	; 21
    ef44:	95 e0       	ldi	r25, 0x05	; 5
    ef46:	64 e6       	ldi	r22, 0x64	; 100
    ef48:	70 e0       	ldi	r23, 0x00	; 0
    ef4a:	0e 94 65 55 	call	0xaaca	; 0xaaca <GSM_Execute_Command>
    ef4e:	ca cc       	rjmp	.-1644   	; 0xe8e4 <GSM_Cycle+0xf2c>
			if(GSM_Wait_Response_P(RESP_OK, GSM_WAIT_MESSAGE)) GSM_State = GSM_WAIT_CCLC_2;
			StartTimer16(TD_GSM, 1000);
			break;
		case GSM_WAIT_CCLC_2:
			if(GetStringFromFIFO()){
				if( (strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,2,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 2,0,2,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 3,0,2,")) != NULL) ){
    ef50:	81 ee       	ldi	r24, 0xE1	; 225
    ef52:	97 e0       	ldi	r25, 0x07	; 7
    ef54:	60 e4       	ldi	r22, 0x40	; 64
    ef56:	70 e4       	ldi	r23, 0x40	; 64
    ef58:	0e 94 25 8b 	call	0x1164a	; 0x1164a <strstr_P>
    ef5c:	89 2b       	or	r24, r25
    ef5e:	09 f0       	breq	.+2      	; 0xef62 <GSM_Cycle+0x15aa>
    ef60:	d1 c9       	rjmp	.-3166   	; 0xe304 <GSM_Cycle+0x94c>
    ef62:	81 ee       	ldi	r24, 0xE1	; 225
    ef64:	97 e0       	ldi	r25, 0x07	; 7
    ef66:	62 e3       	ldi	r22, 0x32	; 50
    ef68:	70 e4       	ldi	r23, 0x40	; 64
    ef6a:	0e 94 25 8b 	call	0x1164a	; 0x1164a <strstr_P>
    ef6e:	89 2b       	or	r24, r25
    ef70:	09 f0       	breq	.+2      	; 0xef74 <GSM_Cycle+0x15bc>
    ef72:	c8 c9       	rjmp	.-3184   	; 0xe304 <GSM_Cycle+0x94c>
					StartTimer16(TD_GSM, 2000);
					GSM_State = GSM_WAIT_CCLC_3;
					break;
				}
			}
			if(Timer16Stopp(TD_GSM)){
    ef74:	80 91 e9 04 	lds	r24, 0x04E9
    ef78:	0e 94 96 25 	call	0x4b2c	; 0x4b2c <Timer16Stopp>
    ef7c:	88 23       	and	r24, r24
    ef7e:	11 f4       	brne	.+4      	; 0xef84 <GSM_Cycle+0x15cc>
    ef80:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
				GSM_State = GSM_WAIT_MESSAGE;
    ef84:	8e e0       	ldi	r24, 0x0E	; 14
    ef86:	80 93 f6 06 	sts	0x06F6, r24
    ef8a:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
				if( (strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 2,0,6,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 3,0,6,")) != NULL) ){
					StartTimer16(TD_GSM, 6000);
					GSM_State = GSM_WAIT_MESSAGE;
					break;
				}
				if( (strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,3,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 2,0,3,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 3,0,3,")) != NULL) ){
    ef8e:	81 ee       	ldi	r24, 0xE1	; 225
    ef90:	97 e0       	ldi	r25, 0x07	; 7
    ef92:	6c ee       	ldi	r22, 0xEC	; 236
    ef94:	7f e3       	ldi	r23, 0x3F	; 63
    ef96:	0e 94 25 8b 	call	0x1164a	; 0x1164a <strstr_P>
    ef9a:	89 2b       	or	r24, r25
    ef9c:	09 f0       	breq	.+2      	; 0xefa0 <GSM_Cycle+0x15e8>
    ef9e:	d0 c2       	rjmp	.+1440   	; 0xf540 <GSM_Cycle+0x1b88>
    efa0:	81 ee       	ldi	r24, 0xE1	; 225
    efa2:	97 e0       	ldi	r25, 0x07	; 7
    efa4:	6e ed       	ldi	r22, 0xDE	; 222
    efa6:	7f e3       	ldi	r23, 0x3F	; 63
    efa8:	0e 94 25 8b 	call	0x1164a	; 0x1164a <strstr_P>
    efac:	89 2b       	or	r24, r25
    efae:	09 f0       	breq	.+2      	; 0xefb2 <GSM_Cycle+0x15fa>
    efb0:	c7 c2       	rjmp	.+1422   	; 0xf540 <GSM_Cycle+0x1b88>
					GSM_State = GSM_WAIT_CCLC_0;
					break;
				}

			}
			if(Timer16Stopp(TD_GSM)){
    efb2:	80 91 e9 04 	lds	r24, 0x04E9
    efb6:	0e 94 96 25 	call	0x4b2c	; 0x4b2c <Timer16Stopp>
    efba:	88 23       	and	r24, r24
    efbc:	11 f4       	brne	.+4      	; 0xefc2 <GSM_Cycle+0x160a>
    efbe:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
				GSM_State = GSM_WAIT_MESSAGE;
    efc2:	8e e0       	ldi	r24, 0x0E	; 14
    efc4:	80 93 f6 06 	sts	0x06F6, r24
    efc8:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
				if((strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,0,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,0,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,0,")) != NULL) ){
					RequestRepeatCounter = 0;
					GSM_State = GSM_SEND_PLAY_ALARM_FILE;
					break;
				}
				if( (strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6,")) != NULL)){
    efcc:	81 ee       	ldi	r24, 0xE1	; 225
    efce:	97 e0       	ldi	r25, 0x07	; 7
    efd0:	68 e9       	ldi	r22, 0x98	; 152
    efd2:	7f e3       	ldi	r23, 0x3F	; 63
    efd4:	0e 94 25 8b 	call	0x1164a	; 0x1164a <strstr_P>
    efd8:	89 2b       	or	r24, r25
    efda:	09 f0       	breq	.+2      	; 0xefde <GSM_Cycle+0x1626>
    efdc:	fb c2       	rjmp	.+1526   	; 0xf5d4 <GSM_Cycle+0x1c1c>
    efde:	81 ee       	ldi	r24, 0xE1	; 225
    efe0:	97 e0       	ldi	r25, 0x07	; 7
    efe2:	6a e8       	ldi	r22, 0x8A	; 138
    efe4:	7f e3       	ldi	r23, 0x3F	; 63
    efe6:	0e 94 25 8b 	call	0x1164a	; 0x1164a <strstr_P>
    efea:	89 2b       	or	r24, r25
    efec:	09 f0       	breq	.+2      	; 0xeff0 <GSM_Cycle+0x1638>
    efee:	f2 c2       	rjmp	.+1508   	; 0xf5d4 <GSM_Cycle+0x1c1c>
					StartTimer16(TD_GSM, 6000);
					GSM_State = GSM_WAIT_DISCONNECT_CAUSE;
					break;
				}
			}
			if(Timer16Stopp(TD_GSM)){
    eff0:	80 91 e9 04 	lds	r24, 0x04E9
    eff4:	0e 94 96 25 	call	0x4b2c	; 0x4b2c <Timer16Stopp>
    eff8:	88 23       	and	r24, r24
    effa:	11 f4       	brne	.+4      	; 0xf000 <GSM_Cycle+0x1648>
    effc:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
				GSM_State = GSM_WAIT_MESSAGE;
    f000:	8e e0       	ldi	r24, 0x0E	; 14
    f002:	80 93 f6 06 	sts	0x06F6, r24
    f006:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
			sprintf(GSM_TxStr+GSMTxSz,"%u",Message[2]);
			if(Message[2]>9){
				GSMTxSz+=2;
			}
			else{
				GSMTxSz++;
    f00a:	80 91 bb 07 	lds	r24, 0x07BB
    f00e:	8f 5f       	subi	r24, 0xFF	; 255
    f010:	80 93 bb 07 	sts	0x07BB, r24
    f014:	c9 c9       	rjmp	.-3182   	; 0xe3a8 <GSM_Cycle+0x9f0>
				else GSM_State++;
			}
			break;
		case GSM_SEND_CIPMODE:
			if(GSM_MultiCon) GSM_Execute_Command(AT_CIPMODE_0, 100*GSM_DEBUG_DELAY);
			else GSM_Execute_Command(AT_CIPMODE_1, 100*GSM_DEBUG_DELAY);
    f016:	88 e0       	ldi	r24, 0x08	; 8
    f018:	95 e0       	ldi	r25, 0x05	; 5
    f01a:	64 e6       	ldi	r22, 0x64	; 100
    f01c:	70 e0       	ldi	r23, 0x00	; 0
    f01e:	0e 94 65 55 	call	0xaaca	; 0xaaca <GSM_Execute_Command>
    f022:	7c cb       	rjmp	.-2312   	; 0xe71c <GSM_Cycle+0xd64>
					break;
				}
				GSM_State = GSM_WAIT_MESSAGE;
				break;
			}
			if(Timer16Stopp(TD_GSM)){
    f024:	80 91 e9 04 	lds	r24, 0x04E9
    f028:	0e 94 96 25 	call	0x4b2c	; 0x4b2c <Timer16Stopp>
    f02c:	88 23       	and	r24, r24
    f02e:	11 f4       	brne	.+4      	; 0xf034 <GSM_Cycle+0x167c>
    f030:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
				GSM_State = GSM_WAIT_MESSAGE;
    f034:	8e e0       	ldi	r24, 0x0E	; 14
    f036:	80 93 f6 06 	sts	0x06F6, r24
    f03a:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
				SetIP(&GSM_MyIP,0,0,0,0);
				for(uint8_t i=0; i<strlen(GSM_RxStr); i++)
					if(!isdigit(GSM_RxStr[i])) GSM_RxStr[i] = ' ';
				sscanf_P(GSM_RxStr,PSTR("%hhu %hhu %hhu %hhu"), (unsigned char*)&GSM_MyIP.IP1, (unsigned char*)&GSM_MyIP.IP2, (unsigned char*)&GSM_MyIP.IP3, (unsigned char*)&GSM_MyIP.IP4);
				if(!IP_compare_Const(&GSM_MyIP,0,0,0,0)){
				  GSM_State = GSM_SEND_CIPSTART_TCP_CLIENT;
    f03e:	8b e3       	ldi	r24, 0x3B	; 59
    f040:	80 93 f6 06 	sts	0x06F6, r24
    f044:	7a cf       	rjmp	.-268    	; 0xef3a <GSM_Cycle+0x1582>
					if(GSM_RxCharN==2)
						{
							if(!strncmp_P(GSM_RxStr, PSTR("\r\n"), 2)) {GSM_RxCharN=0;}
						}
					if(GSM_RxCharN >= 4){
						AppProtocol = 0;
    f046:	10 92 e7 08 	sts	0x08E7, r1
						if(!strncmp_P(GSM_RxStr, PSTR("GET "), 4)) {AppProtocol = _HTTP;GSM_State = GSM_DataMode;break;}//GET
    f04a:	81 ee       	ldi	r24, 0xE1	; 225
    f04c:	97 e0       	ldi	r25, 0x07	; 7
    f04e:	6d e2       	ldi	r22, 0x2D	; 45
    f050:	7e e3       	ldi	r23, 0x3E	; 62
    f052:	44 e0       	ldi	r20, 0x04	; 4
    f054:	50 e0       	ldi	r21, 0x00	; 0
    f056:	0e 94 0c 8b 	call	0x11618	; 0x11618 <strncmp_P>
    f05a:	89 2b       	or	r24, r25
    f05c:	09 f4       	brne	.+2      	; 0xf060 <GSM_Cycle+0x16a8>
    f05e:	3b c3       	rjmp	.+1654   	; 0xf6d6 <GSM_Cycle+0x1d1e>
						if(!strncmp_P(GSM_RxStr, PSTR("POST"), 4)) {AppProtocol = _HTTP;GSM_State = GSM_DataMode;break;}//POST
    f060:	81 ee       	ldi	r24, 0xE1	; 225
    f062:	97 e0       	ldi	r25, 0x07	; 7
    f064:	68 e2       	ldi	r22, 0x28	; 40
    f066:	7e e3       	ldi	r23, 0x3E	; 62
    f068:	44 e0       	ldi	r20, 0x04	; 4
    f06a:	50 e0       	ldi	r21, 0x00	; 0
    f06c:	0e 94 0c 8b 	call	0x11618	; 0x11618 <strncmp_P>
    f070:	89 2b       	or	r24, r25
    f072:	09 f4       	brne	.+2      	; 0xf076 <GSM_Cycle+0x16be>
    f074:	30 c3       	rjmp	.+1632   	; 0xf6d6 <GSM_Cycle+0x1d1e>
						if(!strncmp_P(GSM_RxStr, PSTR("CLOS"), 4)) {AppProtocol = _HTTP;GSM_State = GSM_ReStart1;break;}// 
    f076:	81 ee       	ldi	r24, 0xE1	; 225
    f078:	97 e0       	ldi	r25, 0x07	; 7
    f07a:	63 e2       	ldi	r22, 0x23	; 35
    f07c:	7e e3       	ldi	r23, 0x3E	; 62
    f07e:	44 e0       	ldi	r20, 0x04	; 4
    f080:	50 e0       	ldi	r21, 0x00	; 0
    f082:	0e 94 0c 8b 	call	0x11618	; 0x11618 <strncmp_P>
    f086:	89 2b       	or	r24, r25
    f088:	09 f4       	brne	.+2      	; 0xf08c <GSM_Cycle+0x16d4>
    f08a:	1e c3       	rjmp	.+1596   	; 0xf6c8 <GSM_Cycle+0x1d10>
						if(!strncmp_P(GSM_RxStr, PSTR("+PDP"), 4)) {AppProtocol = _HTTP;GSM_State = GSM_ReStart1;break;}//GPRS 
    f08c:	81 ee       	ldi	r24, 0xE1	; 225
    f08e:	97 e0       	ldi	r25, 0x07	; 7
    f090:	6e e1       	ldi	r22, 0x1E	; 30
    f092:	7e e3       	ldi	r23, 0x3E	; 62
    f094:	44 e0       	ldi	r20, 0x04	; 4
    f096:	50 e0       	ldi	r21, 0x00	; 0
    f098:	0e 94 0c 8b 	call	0x11618	; 0x11618 <strncmp_P>
    f09c:	89 2b       	or	r24, r25
    f09e:	09 f4       	brne	.+2      	; 0xf0a2 <GSM_Cycle+0x16ea>
    f0a0:	13 c3       	rjmp	.+1574   	; 0xf6c8 <GSM_Cycle+0x1d10>
						if( (GSM_RxStr[0]==0) && (GSM_RxStr[1]==0)){AppProtocol = _HTTP;GSM_State = GSM_ReStart1;break;}//  
    f0a2:	80 91 e1 07 	lds	r24, 0x07E1
    f0a6:	88 23       	and	r24, r24
    f0a8:	29 f4       	brne	.+10     	; 0xf0b4 <GSM_Cycle+0x16fc>
    f0aa:	80 91 e2 07 	lds	r24, 0x07E2
    f0ae:	88 23       	and	r24, r24
    f0b0:	09 f4       	brne	.+2      	; 0xf0b4 <GSM_Cycle+0x16fc>
    f0b2:	0a c3       	rjmp	.+1556   	; 0xf6c8 <GSM_Cycle+0x1d10>
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    f0b4:	8f ef       	ldi	r24, 0xFF	; 255
    f0b6:	80 93 3e 07 	sts	0x073E, r24
	GSM_RX_FIFO_End = 255;
    f0ba:	80 93 53 06 	sts	0x0653, r24
	GSM_RxCharN = 0;
    f0be:	10 92 60 0b 	sts	0x0B60, r1
	GSM_RX_FIFOOverFlow = 0;
    f0c2:	10 92 13 09 	sts	0x0913, r1
	GSM_RX_FIFOMax = 0;
    f0c6:	10 92 19 09 	sts	0x0919, r1
						StartTimer16(TD_CleanFIFO,500);
						//break;
					}
				}//while
				//GSM_RxCharN=0;
				if(Timer16Stopp(TD_CleanFIFO)&&(GSM_RX_FIFO_Begin == GSM_RX_FIFO_End)){
    f0ca:	80 91 ef 04 	lds	r24, 0x04EF
    f0ce:	0e 94 96 25 	call	0x4b2c	; 0x4b2c <Timer16Stopp>
    f0d2:	88 23       	and	r24, r24
    f0d4:	b9 f0       	breq	.+46     	; 0xf104 <GSM_Cycle+0x174c>
    f0d6:	90 91 3e 07 	lds	r25, 0x073E
    f0da:	80 91 53 06 	lds	r24, 0x0653
    f0de:	98 17       	cp	r25, r24
    f0e0:	89 f4       	brne	.+34     	; 0xf104 <GSM_Cycle+0x174c>
					StartTimer16(TD_CleanFIFO,500);
    f0e2:	80 91 ef 04 	lds	r24, 0x04EF
    f0e6:	64 ef       	ldi	r22, 0xF4	; 244
    f0e8:	71 e0       	ldi	r23, 0x01	; 1
    f0ea:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    f0ee:	8f ef       	ldi	r24, 0xFF	; 255
    f0f0:	80 93 3e 07 	sts	0x073E, r24
	GSM_RX_FIFO_End = 255;
    f0f4:	80 93 53 06 	sts	0x0653, r24
	GSM_RxCharN = 0;
    f0f8:	10 92 60 0b 	sts	0x0B60, r1
	GSM_RX_FIFOOverFlow = 0;
    f0fc:	10 92 13 09 	sts	0x0913, r1
	GSM_RX_FIFOMax = 0;
    f100:	10 92 19 09 	sts	0x0919, r1
				if(Timer16Stopp(TD_CleanFIFO)&&(GSM_RX_FIFO_Begin == GSM_RX_FIFO_End)){
					StartTimer16(TD_CleanFIFO,500);
					InitFIFO();
				}

				if(Timer16Stopp(TD_data_start_delay)){
    f104:	80 91 f0 04 	lds	r24, 0x04F0
    f108:	0e 94 96 25 	call	0x4b2c	; 0x4b2c <Timer16Stopp>
    f10c:	88 23       	and	r24, r24
    f10e:	11 f4       	brne	.+4      	; 0xf114 <GSM_Cycle+0x175c>
    f110:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
					if(GPRS_FlgSz_Out && (GPRS_FlgSz_Out <= GPRS_Out_MaxSz)&&(GSM_Flag&(1<<flg_TxCStr))&&Timer16Stopp(TD_timer_after_page_transfer)&&(!dataSendFlg)){			
    f114:	80 91 b1 07 	lds	r24, 0x07B1
    f118:	88 23       	and	r24, r24
    f11a:	11 f4       	brne	.+4      	; 0xf120 <GSM_Cycle+0x1768>
    f11c:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
    f120:	80 91 d2 02 	lds	r24, 0x02D2
    f124:	80 fd       	sbrc	r24, 0
    f126:	02 c0       	rjmp	.+4      	; 0xf12c <GSM_Cycle+0x1774>
    f128:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
    f12c:	80 91 f1 04 	lds	r24, 0x04F1
    f130:	0e 94 96 25 	call	0x4b2c	; 0x4b2c <Timer16Stopp>
    f134:	88 23       	and	r24, r24
    f136:	11 f4       	brne	.+4      	; 0xf13c <GSM_Cycle+0x1784>
    f138:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
    f13c:	80 91 df 02 	lds	r24, 0x02DF
    f140:	88 23       	and	r24, r24
    f142:	11 f0       	breq	.+4      	; 0xf148 <GSM_Cycle+0x1790>
    f144:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
							dataSendFlg=1;
    f148:	81 e0       	ldi	r24, 0x01	; 1
    f14a:	80 93 df 02 	sts	0x02DF, r24
							GSM_AddHeaderSendData(GPRS_Data_Out, GPRS_FlgSz_Out);
    f14e:	86 e4       	ldi	r24, 0x46	; 70
    f150:	99 e0       	ldi	r25, 0x09	; 9
    f152:	60 91 b1 07 	lds	r22, 0x07B1
    f156:	0e 94 f8 4a 	call	0x95f0	; 0x95f0 <GSM_AddHeaderSendData>
    f15a:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
		/*	if(Timer16Stopp(TD_TCP_Connect)){	//        CommandMode
				GSM_State = GSM_Swtch2CommandMode;
				break;
			}*/
			//StartTimer16(TD_CheckModem,1000);
			if( (strstr_P(GSM_RxStr, URC_CLOSED+2) != NULL) ){
    f15e:	81 ee       	ldi	r24, 0xE1	; 225
    f160:	97 e0       	ldi	r25, 0x07	; 7
    f162:	64 ed       	ldi	r22, 0xD4	; 212
    f164:	73 e0       	ldi	r23, 0x03	; 3
    f166:	0e 94 25 8b 	call	0x1164a	; 0x1164a <strstr_P>
    f16a:	89 2b       	or	r24, r25
    f16c:	11 f4       	brne	.+4      	; 0xf172 <GSM_Cycle+0x17ba>
    f16e:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
				GSM_State =GSM_ReStart1;
    f172:	8a e4       	ldi	r24, 0x4A	; 74
    f174:	80 93 f6 06 	sts	0x06F6, r24
    f178:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
			break;

		case GSM_SEND_CIPCSGP:
			//GSM_Execute_Command(AT_CIPCSGP, 300*GSM_DEBUG_DELAY); GSM_State++;
			if(GSM_Flag & (1<<flg_TxCStr)){
				sprintf_P(GSM_TxStr, AT_CIPCSGP);	GSMTxSz = strlen_P(AT_CIPCSGP);
    f17c:	00 d0       	rcall	.+0      	; 0xf17e <GSM_Cycle+0x17c6>
    f17e:	0f 92       	push	r0
    f180:	8a e4       	ldi	r24, 0x4A	; 74
    f182:	9a e0       	ldi	r25, 0x0A	; 10
    f184:	ad b7       	in	r26, 0x3d	; 61
    f186:	be b7       	in	r27, 0x3e	; 62
    f188:	12 96       	adiw	r26, 0x02	; 2
    f18a:	9c 93       	st	X, r25
    f18c:	8e 93       	st	-X, r24
    f18e:	11 97       	sbiw	r26, 0x01	; 1
    f190:	08 e3       	ldi	r16, 0x38	; 56
    f192:	15 e0       	ldi	r17, 0x05	; 5
    f194:	14 96       	adiw	r26, 0x04	; 4
    f196:	1c 93       	st	X, r17
    f198:	0e 93       	st	-X, r16
    f19a:	13 97       	sbiw	r26, 0x03	; 3
    f19c:	0e 94 20 8c 	call	0x11840	; 0x11840 <sprintf_P>
    f1a0:	0f 90       	pop	r0
    f1a2:	0f 90       	pop	r0
    f1a4:	0f 90       	pop	r0
    f1a6:	0f 90       	pop	r0
    f1a8:	c8 01       	movw	r24, r16
    f1aa:	0e 94 03 8b 	call	0x11606	; 0x11606 <strlen_P>
    f1ae:	80 93 bb 07 	sts	0x07BB, r24
				#if LCDXSz==40
					GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn);
				#else
					GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn1);
    f1b2:	80 91 bb 07 	lds	r24, 0x07BB
    f1b6:	90 e0       	ldi	r25, 0x00	; 0
    f1b8:	86 5b       	subi	r24, 0xB6	; 182
    f1ba:	95 4f       	sbci	r25, 0xF5	; 245
    f1bc:	69 e0       	ldi	r22, 0x09	; 9
    f1be:	70 e0       	ldi	r23, 0x00	; 0
    f1c0:	0e 94 b9 6c 	call	0xd972	; 0xd972 <strcpy_EE>
    f1c4:	90 91 bb 07 	lds	r25, 0x07BB
    f1c8:	98 0f       	add	r25, r24
    f1ca:	90 93 bb 07 	sts	0x07BB, r25
					GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn2);
    f1ce:	80 91 bb 07 	lds	r24, 0x07BB
    f1d2:	90 e0       	ldi	r25, 0x00	; 0
    f1d4:	86 5b       	subi	r24, 0xB6	; 182
    f1d6:	95 4f       	sbci	r25, 0xF5	; 245
    f1d8:	6d e1       	ldi	r22, 0x1D	; 29
    f1da:	70 e0       	ldi	r23, 0x00	; 0
    f1dc:	0e 94 b9 6c 	call	0xd972	; 0xd972 <strcpy_EE>
    f1e0:	90 91 bb 07 	lds	r25, 0x07BB
    f1e4:	98 0f       	add	r25, r24
    f1e6:	90 93 bb 07 	sts	0x07BB, r25
				#endif
				sprintf(GSM_TxStr + GSMTxSz, "\",\"");	GSMTxSz = GSMTxSz+3;				
    f1ea:	e0 91 bb 07 	lds	r30, 0x07BB
    f1ee:	f0 e0       	ldi	r31, 0x00	; 0
    f1f0:	e6 5b       	subi	r30, 0xB6	; 182
    f1f2:	f5 4f       	sbci	r31, 0xF5	; 245
    f1f4:	a2 e2       	ldi	r26, 0x22	; 34
    f1f6:	ea 2e       	mov	r14, r26
    f1f8:	ac e2       	ldi	r26, 0x2C	; 44
    f1fa:	fa 2e       	mov	r15, r26
    f1fc:	a2 e2       	ldi	r26, 0x22	; 34
    f1fe:	0a 2f       	mov	r16, r26
    f200:	11 2d       	mov	r17, r1
    f202:	e0 82       	st	Z, r14
    f204:	f1 82       	std	Z+1, r15	; 0x01
    f206:	02 83       	std	Z+2, r16	; 0x02
    f208:	13 83       	std	Z+3, r17	; 0x03
    f20a:	80 91 bb 07 	lds	r24, 0x07BB
    f20e:	8d 5f       	subi	r24, 0xFD	; 253
    f210:	80 93 bb 07 	sts	0x07BB, r24
				GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn_user_name);
    f214:	80 91 bb 07 	lds	r24, 0x07BB
    f218:	90 e0       	ldi	r25, 0x00	; 0
    f21a:	86 5b       	subi	r24, 0xB6	; 182
    f21c:	95 4f       	sbci	r25, 0xF5	; 245
    f21e:	69 e5       	ldi	r22, 0x59	; 89
    f220:	70 e0       	ldi	r23, 0x00	; 0
    f222:	0e 94 b9 6c 	call	0xd972	; 0xd972 <strcpy_EE>
    f226:	90 91 bb 07 	lds	r25, 0x07BB
    f22a:	98 0f       	add	r25, r24
    f22c:	90 93 bb 07 	sts	0x07BB, r25
				sprintf(GSM_TxStr + GSMTxSz, "\",\"");	GSMTxSz = GSMTxSz+3;
    f230:	e0 91 bb 07 	lds	r30, 0x07BB
    f234:	f0 e0       	ldi	r31, 0x00	; 0
    f236:	e6 5b       	subi	r30, 0xB6	; 182
    f238:	f5 4f       	sbci	r31, 0xF5	; 245
    f23a:	e0 82       	st	Z, r14
    f23c:	f1 82       	std	Z+1, r15	; 0x01
    f23e:	02 83       	std	Z+2, r16	; 0x02
    f240:	13 83       	std	Z+3, r17	; 0x03
    f242:	80 91 bb 07 	lds	r24, 0x07BB
    f246:	8d 5f       	subi	r24, 0xFD	; 253
    f248:	80 93 bb 07 	sts	0x07BB, r24
				GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn_psw);
    f24c:	80 91 bb 07 	lds	r24, 0x07BB
    f250:	90 e0       	ldi	r25, 0x00	; 0
    f252:	86 5b       	subi	r24, 0xB6	; 182
    f254:	95 4f       	sbci	r25, 0xF5	; 245
    f256:	6d e6       	ldi	r22, 0x6D	; 109
    f258:	70 e0       	ldi	r23, 0x00	; 0
    f25a:	0e 94 b9 6c 	call	0xd972	; 0xd972 <strcpy_EE>
    f25e:	90 91 bb 07 	lds	r25, 0x07BB
    f262:	98 0f       	add	r25, r24
    f264:	90 93 bb 07 	sts	0x07BB, r25
				sprintf(GSM_TxStr + GSMTxSz, "\"\r");	GSMTxSz = GSMTxSz+2;
    f268:	80 91 bb 07 	lds	r24, 0x07BB
    f26c:	e8 2f       	mov	r30, r24
    f26e:	f0 e0       	ldi	r31, 0x00	; 0
    f270:	e6 5b       	subi	r30, 0xB6	; 182
    f272:	f5 4f       	sbci	r31, 0xF5	; 245
    f274:	a5 eb       	ldi	r26, 0xB5	; 181
    f276:	b2 e0       	ldi	r27, 0x02	; 2
    f278:	83 e0       	ldi	r24, 0x03	; 3
    f27a:	0d 90       	ld	r0, X+
    f27c:	01 92       	st	Z+, r0
    f27e:	81 50       	subi	r24, 0x01	; 1
    f280:	e1 f7       	brne	.-8      	; 0xf27a <GSM_Cycle+0x18c2>
    f282:	80 91 bb 07 	lds	r24, 0x07BB
    f286:	8e 5f       	subi	r24, 0xFE	; 254
    f288:	80 93 bb 07 	sts	0x07BB, r24
				GSM_SendFirstChar();
    f28c:	0e 94 3a 43 	call	0x8674	; 0x8674 <GSM_SendFirstChar>
				StartTimer16(TD_GSM, 300*GSM_DEBUG_DELAY);
    f290:	80 91 e9 04 	lds	r24, 0x04E9
    f294:	6c e2       	ldi	r22, 0x2C	; 44
    f296:	71 e0       	ldi	r23, 0x01	; 1
    f298:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
    f29c:	74 cc       	rjmp	.-1816   	; 0xeb86 <GSM_Cycle+0x11ce>
		case GSM_WAIT_CSQ:
				if(Timer16Stopp(TD_GSM)){
						GSM_State = GSM_ReStart1;
				}
				else{				
					if(GetStringFromFIFO()){
    f29e:	0e 94 10 42 	call	0x8420	; 0x8420 <GetStringFromFIFO>
    f2a2:	88 23       	and	r24, r24
    f2a4:	11 f4       	brne	.+4      	; 0xf2aa <GSM_Cycle+0x18f2>
    f2a6:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
						GSM_RSSI = 255; GSM_BER = 255;
    f2aa:	8f ef       	ldi	r24, 0xFF	; 255
    f2ac:	80 93 b2 06 	sts	0x06B2, r24
    f2b0:	80 93 cb 07 	sts	0x07CB, r24
						if(strstr_P(GSM_RxStr, RESP_CSQ) != NULL ){
    f2b4:	01 ee       	ldi	r16, 0xE1	; 225
    f2b6:	17 e0       	ldi	r17, 0x07	; 7
    f2b8:	c8 01       	movw	r24, r16
    f2ba:	63 e4       	ldi	r22, 0x43	; 67
    f2bc:	74 e0       	ldi	r23, 0x04	; 4
    f2be:	0e 94 25 8b 	call	0x1164a	; 0x1164a <strstr_P>
    f2c2:	89 2b       	or	r24, r25
    f2c4:	11 f4       	brne	.+4      	; 0xf2ca <GSM_Cycle+0x1912>
    f2c6:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
							sscanf_P(GSM_RxStr,PSTR("+CSQ: %hhu,%hhu"), (unsigned char*)&GSM_RSSI, (unsigned char*)&GSM_BER);
    f2ca:	ed b7       	in	r30, 0x3d	; 61
    f2cc:	fe b7       	in	r31, 0x3e	; 62
    f2ce:	38 97       	sbiw	r30, 0x08	; 8
    f2d0:	0f b6       	in	r0, 0x3f	; 63
    f2d2:	f8 94       	cli
    f2d4:	fe bf       	out	0x3e, r31	; 62
    f2d6:	0f be       	out	0x3f, r0	; 63
    f2d8:	ed bf       	out	0x3d, r30	; 61
    f2da:	31 96       	adiw	r30, 0x01	; 1
    f2dc:	ad b7       	in	r26, 0x3d	; 61
    f2de:	be b7       	in	r27, 0x3e	; 62
    f2e0:	12 96       	adiw	r26, 0x02	; 2
    f2e2:	1c 93       	st	X, r17
    f2e4:	0e 93       	st	-X, r16
    f2e6:	11 97       	sbiw	r26, 0x01	; 1
    f2e8:	85 e3       	ldi	r24, 0x35	; 53
    f2ea:	9e e3       	ldi	r25, 0x3E	; 62
    f2ec:	93 83       	std	Z+3, r25	; 0x03
    f2ee:	82 83       	std	Z+2, r24	; 0x02
    f2f0:	82 eb       	ldi	r24, 0xB2	; 178
    f2f2:	96 e0       	ldi	r25, 0x06	; 6
    f2f4:	95 83       	std	Z+5, r25	; 0x05
    f2f6:	84 83       	std	Z+4, r24	; 0x04
    f2f8:	8b ec       	ldi	r24, 0xCB	; 203
    f2fa:	97 e0       	ldi	r25, 0x07	; 7
    f2fc:	97 83       	std	Z+7, r25	; 0x07
    f2fe:	86 83       	std	Z+6, r24	; 0x06
    f300:	0e 94 74 8c 	call	0x118e8	; 0x118e8 <sscanf_P>
									
								GSM_State = GSM_WAIT_CSQ_OK;
    f304:	81 e5       	ldi	r24, 0x51	; 81
    f306:	80 93 f6 06 	sts	0x06F6, r24
    f30a:	ed b7       	in	r30, 0x3d	; 61
    f30c:	fe b7       	in	r31, 0x3e	; 62
    f30e:	38 96       	adiw	r30, 0x08	; 8
    f310:	0f b6       	in	r0, 0x3f	; 63
    f312:	f8 94       	cli
    f314:	fe bf       	out	0x3e, r31	; 62
    f316:	0f be       	out	0x3f, r0	; 63
    f318:	ed bf       	out	0x3d, r30	; 61
    f31a:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
				GSM_State = GSM_WAIT_MESSAGE;
			}
			break;
		case GSM_WAIT_CONFIRMRESPONSE:
			if(GetStringFromFIFO()){
					if((strstr_P(GSM_RxStr, PSTR("+DTMF: 1")) != NULL) ){
    f31e:	81 ee       	ldi	r24, 0xE1	; 225
    f320:	97 e0       	ldi	r25, 0x07	; 7
    f322:	6b e1       	ldi	r22, 0x1B	; 27
    f324:	7f e3       	ldi	r23, 0x3F	; 63
    f326:	0e 94 25 8b 	call	0x1164a	; 0x1164a <strstr_P>
    f32a:	89 2b       	or	r24, r25
    f32c:	49 f0       	breq	.+18     	; 0xf340 <GSM_Cycle+0x1988>
						StartTimer16(TD_GSM,1000);
    f32e:	80 91 e9 04 	lds	r24, 0x04E9
    f332:	68 ee       	ldi	r22, 0xE8	; 232
    f334:	73 e0       	ldi	r23, 0x03	; 3
    f336:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
						GSM_State = GSM_SEND_PLAY_CONFIRM_FILE;
    f33a:	8d e1       	ldi	r24, 0x1D	; 29
    f33c:	80 93 f6 06 	sts	0x06F6, r24
						
					}
					if((strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 2,0,6")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 3,0,6")) != NULL) ){
    f340:	81 ee       	ldi	r24, 0xE1	; 225
    f342:	97 e0       	ldi	r25, 0x07	; 7
    f344:	6e e0       	ldi	r22, 0x0E	; 14
    f346:	7f e3       	ldi	r23, 0x3F	; 63
    f348:	0e 94 25 8b 	call	0x1164a	; 0x1164a <strstr_P>
    f34c:	89 2b       	or	r24, r25
    f34e:	09 f4       	brne	.+2      	; 0xf352 <GSM_Cycle+0x199a>
    f350:	10 c1       	rjmp	.+544    	; 0xf572 <GSM_Cycle+0x1bba>
						StartTimer16(TD_GSM,2000);
    f352:	80 91 e9 04 	lds	r24, 0x04E9
    f356:	60 ed       	ldi	r22, 0xD0	; 208
    f358:	77 e0       	ldi	r23, 0x07	; 7
    f35a:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
						GSM_State = GSM_WAIT_DISCONNECT_CAUSE;
    f35e:	85 e2       	ldi	r24, 0x25	; 37
    f360:	80 93 f6 06 	sts	0x06F6, r24
    f364:	0c 94 db 70 	jmp	0xe1b6	; 0xe1b6 <GSM_Cycle+0x7fe>
			break;
		case GSM_WAIT_MESSAGE:
			
			if(Message[0]==1)
			{
				Message[0]=0;
    f368:	10 92 35 07 	sts	0x0735, r1
				ConfirmState=0;
				ConfirmState = 0;
    f36c:	10 92 e1 02 	sts	0x02E1, r1
				TransmitterState = 1;
    f370:	80 93 e3 02 	sts	0x02E3, r24
				GSM_State = GSM_SEND_ATD;
    f374:	8f e0       	ldi	r24, 0x0F	; 15
    f376:	80 93 f6 06 	sts	0x06F6, r24
    f37a:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
			if(Timer16Stopp(TD_GSM)){
				if(RequestRepeatCounter<4){
				GSM_State = GSM_SEND_PLAY_ALARM_FILE;
				}
				else{
				GSM_State = GSM_SEND_PLAY_NOTCONFIRM_FILE;				
    f37e:	80 e2       	ldi	r24, 0x20	; 32
    f380:	80 93 f6 06 	sts	0x06F6, r24
    f384:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
				if(++TempNum>=MaxTelephDirSz){
					GSM_State = GSM_Return2dataMode;
					SMS_FlgSz_Out = 0;
					//StartTimer16(TD_GSM,150);
				}
				else GSM_State = GSM_SEND_CMGS;
    f388:	80 e4       	ldi	r24, 0x40	; 64
    f38a:	80 93 f6 06 	sts	0x06F6, r24
    f38e:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
			}
			break;
		case GSM_WAIT_D2C_SWITCH_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) {

				switch(CommandModeDestination){
    f392:	84 30       	cpi	r24, 0x04	; 4
    f394:	79 f1       	breq	.+94     	; 0xf3f4 <GSM_Cycle+0x1a3c>
    f396:	85 30       	cpi	r24, 0x05	; 5
    f398:	11 f0       	breq	.+4      	; 0xf39e <GSM_Cycle+0x19e6>
    f39a:	0c 94 08 6e 	jmp	0xdc10	; 0xdc10 <GSM_Cycle+0x258>
					case 4:	
						GSM_State = GSM_SEND_ATD_Check_Ballance;
						counter=0;	
						break;
					case 5:	
						GSM_State = GSM_SEND_CSQ;
    f39e:	8f e4       	ldi	r24, 0x4F	; 79
    f3a0:	80 93 f6 06 	sts	0x06F6, r24
						counter=0;	
    f3a4:	10 92 e0 02 	sts	0x02E0, r1
    f3a8:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
			if(GSM_Wait_Response_P(URC_CPIN_READY, GSM_ReStart1)) GSM_State++;
			break;

		case GSM_WAIT_CALL_READY:
			if(GSM_Wait_Response_P(URC_CALL_READY, GSM_ReStart1)){
				if(GSM_Modem == SIMCOM_SIM800) GSM_State = GSM_WAIT_SMS_READY;
    f3ac:	87 e0       	ldi	r24, 0x07	; 7
    f3ae:	80 93 f6 06 	sts	0x06F6, r24
    f3b2:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
				}
			break;
		case GSM_WAIT_CSQ_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) {
				if(CommandModeDestination==5){
					GSM_State  = GSM_Return2dataMode;
    f3b6:	87 e5       	ldi	r24, 0x57	; 87
    f3b8:	80 93 f6 06 	sts	0x06F6, r24
    f3bc:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
			if(GetStringFromFIFO()){
				if(!strcmp_P(GSM_RxStr, GSM_SIMCOM_SIM900R)) GSM_Modem = SIMCOM_SIM900R;
				if(!strcmp_P(GSM_RxStr, GSM_SIMCOM_SIM800)) GSM_Modem = SIMCOM_SIM800;
				if(!strcmp_P(GSM_RxStr, GSM_SIMCOM_SIM800C)) GSM_Modem = SIMCOM_SIM800;
				//Add here new model GSM-modem
				if(GSM_Modem != NOT_RECOGNIZED) GSM_State = GSM_WAIT_CALL_READY;
    f3c0:	80 91 34 07 	lds	r24, 0x0734
    f3c4:	88 23       	and	r24, r24
    f3c6:	11 f4       	brne	.+4      	; 0xf3cc <GSM_Cycle+0x1a14>
    f3c8:	0c 94 9b 6d 	jmp	0xdb36	; 0xdb36 <GSM_Cycle+0x17e>
    f3cc:	0c 94 98 6d 	jmp	0xdb30	; 0xdb30 <GSM_Cycle+0x178>
			}
			GSM_State++;
			break;
		case GSM_WAIT_CIPCSGP_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
			 if(GSM_Modem == SIMCOM_SIM800)GSM_State++;
    f3d0:	80 91 f6 06 	lds	r24, 0x06F6
    f3d4:	8f 5f       	subi	r24, 0xFF	; 255
    f3d6:	80 93 f6 06 	sts	0x06F6, r24
    f3da:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
			GSM_State++; 
			break;
		case GSM_WAIT_CIPMUX_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
				if(GSM_MultiCon){
					GSM_State = GSM_WAIT_1;
    f3de:	8e e2       	ldi	r24, 0x2E	; 46
    f3e0:	80 93 f6 06 	sts	0x06F6, r24
					// between "Call Ready" and "+CMGS"; 8 sec min needs; for kyivstar vpni only
					StartTimer16(TD_GSM, 1000);
    f3e4:	80 91 e9 04 	lds	r24, 0x04E9
    f3e8:	68 ee       	ldi	r22, 0xE8	; 232
    f3ea:	73 e0       	ldi	r23, 0x03	; 3
    f3ec:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
    f3f0:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
					case 2:	
						GSM_State = GSM_CIPSHUT_;
						counter=0;	
						break;						
					case 4:	
						GSM_State = GSM_SEND_ATD_Check_Ballance;
    f3f4:	8c e4       	ldi	r24, 0x4C	; 76
    f3f6:	80 93 f6 06 	sts	0x06F6, r24
						counter=0;	
    f3fa:	10 92 e0 02 	sts	0x02E0, r1
    f3fe:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
				GSMTxSz = strlen(GSM_TxStr);
				uint8_t j=0;
				for(uint8_t i=0; i<GSMTxSz; i++)
					if(GSM_TxStr[i] != '0') j++;
				if(j){
					GSMTxSz = strlen_P(AT_CMGS);
    f402:	00 ef       	ldi	r16, 0xF0	; 240
    f404:	14 e0       	ldi	r17, 0x04	; 4
    f406:	c8 01       	movw	r24, r16
    f408:	0e 94 03 8b 	call	0x11606	; 0x11606 <strlen_P>
    f40c:	80 93 bb 07 	sts	0x07BB, r24
					sprintf_P(GSM_TxStr, AT_CMGS);
    f410:	00 d0       	rcall	.+0      	; 0xf412 <GSM_Cycle+0x1a5a>
    f412:	0f 92       	push	r0
    f414:	ad b7       	in	r26, 0x3d	; 61
    f416:	be b7       	in	r27, 0x3e	; 62
    f418:	12 96       	adiw	r26, 0x02	; 2
    f41a:	fc 92       	st	X, r15
    f41c:	ee 92       	st	-X, r14
    f41e:	11 97       	sbiw	r26, 0x01	; 1
    f420:	14 96       	adiw	r26, 0x04	; 4
    f422:	1c 93       	st	X, r17
    f424:	0e 93       	st	-X, r16
    f426:	13 97       	sbiw	r26, 0x03	; 3
    f428:	0e 94 20 8c 	call	0x11840	; 0x11840 <sprintf_P>
					erbl(GSM_TxStr+GSMTxSz, SMS_Number+TempNum, MaxTelephN);
    f42c:	80 91 bb 07 	lds	r24, 0x07BB
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    f430:	0f 90       	pop	r0
    f432:	0f 90       	pop	r0
    f434:	0f 90       	pop	r0
    f436:	0f 90       	pop	r0
    f438:	90 e0       	ldi	r25, 0x00	; 0
    f43a:	60 91 dc 05 	lds	r22, 0x05DC
    f43e:	2d e0       	ldi	r18, 0x0D	; 13
    f440:	62 9f       	mul	r22, r18
    f442:	b0 01       	movw	r22, r0
    f444:	11 24       	eor	r1, r1
    f446:	6b 53       	subi	r22, 0x3B	; 59
    f448:	7f 4f       	sbci	r23, 0xFF	; 255
    f44a:	86 5b       	subi	r24, 0xB6	; 182
    f44c:	95 4f       	sbci	r25, 0xF5	; 245
    f44e:	4d e0       	ldi	r20, 0x0D	; 13
    f450:	50 e0       	ldi	r21, 0x00	; 0
    f452:	0e 94 0d 8e 	call	0x11c1a	; 0x11c1a <__eerd_block_m2560>
					GSMTxSz = strlen(GSM_TxStr);
    f456:	f7 01       	movw	r30, r14
    f458:	01 90       	ld	r0, Z+
    f45a:	00 20       	and	r0, r0
    f45c:	e9 f7       	brne	.-6      	; 0xf458 <GSM_Cycle+0x1aa0>
    f45e:	31 97       	sbiw	r30, 0x01	; 1
    f460:	ea 54       	subi	r30, 0x4A	; 74
    f462:	fa 40       	sbci	r31, 0x0A	; 10
    f464:	e0 93 bb 07 	sts	0x07BB, r30
					sprintf(GSM_TxStr + GSMTxSz, "\"\r");
    f468:	80 91 bb 07 	lds	r24, 0x07BB
    f46c:	e8 2f       	mov	r30, r24
    f46e:	f0 e0       	ldi	r31, 0x00	; 0
    f470:	e6 5b       	subi	r30, 0xB6	; 182
    f472:	f5 4f       	sbci	r31, 0xF5	; 245
    f474:	a5 eb       	ldi	r26, 0xB5	; 181
    f476:	b2 e0       	ldi	r27, 0x02	; 2
    f478:	83 e0       	ldi	r24, 0x03	; 3
    f47a:	0d 90       	ld	r0, X+
    f47c:	01 92       	st	Z+, r0
    f47e:	81 50       	subi	r24, 0x01	; 1
    f480:	e1 f7       	brne	.-8      	; 0xf47a <GSM_Cycle+0x1ac2>
					GSMTxSz = strlen(GSM_TxStr);
    f482:	f7 01       	movw	r30, r14
    f484:	01 90       	ld	r0, Z+
    f486:	00 20       	and	r0, r0
    f488:	e9 f7       	brne	.-6      	; 0xf484 <GSM_Cycle+0x1acc>
    f48a:	31 97       	sbiw	r30, 0x01	; 1
    f48c:	ea 54       	subi	r30, 0x4A	; 74
    f48e:	fa 40       	sbci	r31, 0x0A	; 10
    f490:	e0 93 bb 07 	sts	0x07BB, r30
					GSM_SendFirstChar();
    f494:	0e 94 3a 43 	call	0x8674	; 0x8674 <GSM_SendFirstChar>
					StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    f498:	80 91 e9 04 	lds	r24, 0x04E9
    f49c:	64 ef       	ldi	r22, 0xF4	; 244
    f49e:	71 e0       	ldi	r23, 0x01	; 1
    f4a0:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
					GSM_State++;
    f4a4:	80 91 f6 06 	lds	r24, 0x06F6
    f4a8:	8f 5f       	subi	r24, 0xFF	; 255
    f4aa:	80 93 f6 06 	sts	0x06F6, r24
    f4ae:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>

				switch(CommandModeDestination){
					case 1:	GSM_State = GSM_SEND_CMGS;
						break;
					case 2:	
						GSM_State = GSM_CIPSHUT_;
    f4b2:	84 e4       	ldi	r24, 0x44	; 68
    f4b4:	80 93 f6 06 	sts	0x06F6, r24
						counter=0;	
    f4b8:	10 92 e0 02 	sts	0x02E0, r1
    f4bc:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
			break;
		case GSM_WAIT_D2C_SWITCH_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) {

				switch(CommandModeDestination){
					case 1:	GSM_State = GSM_SEND_CMGS;
    f4c0:	80 e4       	ldi	r24, 0x40	; 64
    f4c2:	80 93 f6 06 	sts	0x06F6, r24
    f4c6:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
				GSM_State = GSM_ProtocolMode;
				InitFIFO();
				break;
			}
*/			
			if( (strstr_P(GSM_RxStr, PSTR("OK")) != NULL) ){
    f4ca:	c8 01       	movw	r24, r16
    f4cc:	62 e5       	ldi	r22, 0x52	; 82
    f4ce:	7e e3       	ldi	r23, 0x3E	; 62
    f4d0:	0e 94 25 8b 	call	0x1164a	; 0x1164a <strstr_P>
    f4d4:	89 2b       	or	r24, r25
    f4d6:	09 f4       	brne	.+2      	; 0xf4da <GSM_Cycle+0x1b22>
    f4d8:	88 c0       	rjmp	.+272    	; 0xf5ea <GSM_Cycle+0x1c32>
				StartTimer16(TD_data_start_delay,100);
    f4da:	80 91 f0 04 	lds	r24, 0x04F0
    f4de:	64 e6       	ldi	r22, 0x64	; 100
    f4e0:	70 e0       	ldi	r23, 0x00	; 0
    f4e2:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
				GSM_State = GSM_ProtocolMode;
    f4e6:	82 e5       	ldi	r24, 0x52	; 82
    f4e8:	80 93 f6 06 	sts	0x06F6, r24
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    f4ec:	8f ef       	ldi	r24, 0xFF	; 255
    f4ee:	80 93 3e 07 	sts	0x073E, r24
	GSM_RX_FIFO_End = 255;
    f4f2:	80 93 53 06 	sts	0x0653, r24
	GSM_RxCharN = 0;
    f4f6:	10 92 60 0b 	sts	0x0B60, r1
	GSM_RX_FIFOOverFlow = 0;
    f4fa:	10 92 13 09 	sts	0x0913, r1
	GSM_RX_FIFOMax = 0;
    f4fe:	10 92 19 09 	sts	0x0919, r1
    f502:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
				GSM_State = GSM_WAIT_MESSAGE;
			}
			break;
		case GSM_WAIT_CCLC_3:
			if(GetStringFromFIFO()){
				if( (strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 2,0,6,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 3,0,6,")) != NULL) ){
    f506:	81 ee       	ldi	r24, 0xE1	; 225
    f508:	97 e0       	ldi	r25, 0x07	; 7
    f50a:	66 e1       	ldi	r22, 0x16	; 22
    f50c:	70 e4       	ldi	r23, 0x40	; 64
    f50e:	0e 94 25 8b 	call	0x1164a	; 0x1164a <strstr_P>
    f512:	89 2b       	or	r24, r25
    f514:	11 f0       	breq	.+4      	; 0xf51a <GSM_Cycle+0x1b62>
    f516:	0c 94 6a 71 	jmp	0xe2d4	; 0xe2d4 <GSM_Cycle+0x91c>
    f51a:	81 ee       	ldi	r24, 0xE1	; 225
    f51c:	97 e0       	ldi	r25, 0x07	; 7
    f51e:	68 e0       	ldi	r22, 0x08	; 8
    f520:	70 e4       	ldi	r23, 0x40	; 64
    f522:	0e 94 25 8b 	call	0x1164a	; 0x1164a <strstr_P>
    f526:	89 2b       	or	r24, r25
    f528:	11 f0       	breq	.+4      	; 0xf52e <GSM_Cycle+0x1b76>
    f52a:	0c 94 6a 71 	jmp	0xe2d4	; 0xe2d4 <GSM_Cycle+0x91c>
					StartTimer16(TD_GSM, 6000);
					GSM_State = GSM_WAIT_MESSAGE;
					break;
				}
				if( (strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,3,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 2,0,3,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 3,0,3,")) != NULL) ){
    f52e:	81 ee       	ldi	r24, 0xE1	; 225
    f530:	97 e0       	ldi	r25, 0x07	; 7
    f532:	6a ef       	ldi	r22, 0xFA	; 250
    f534:	7f e3       	ldi	r23, 0x3F	; 63
    f536:	0e 94 25 8b 	call	0x1164a	; 0x1164a <strstr_P>
    f53a:	89 2b       	or	r24, r25
    f53c:	09 f4       	brne	.+2      	; 0xf540 <GSM_Cycle+0x1b88>
    f53e:	27 cd       	rjmp	.-1458   	; 0xef8e <GSM_Cycle+0x15d6>
					StartTimer16(TD_GSM, 6000);
    f540:	80 91 e9 04 	lds	r24, 0x04E9
    f544:	60 e7       	ldi	r22, 0x70	; 112
    f546:	77 e1       	ldi	r23, 0x17	; 23
    f548:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
					GSM_State = GSM_WAIT_CCLC_0;
    f54c:	83 e1       	ldi	r24, 0x13	; 19
    f54e:	80 93 f6 06 	sts	0x06F6, r24
    f552:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
				if((strstr_P(GSM_RxStr, PSTR("OK")) != NULL) ){
					GSM_State = GSM_WAIT_MESSAGE;

					break;
				}
				if((strstr_P(GSM_RxStr, PSTR("BUSY")) != NULL) ){
    f556:	81 ee       	ldi	r24, 0xE1	; 225
    f558:	97 e0       	ldi	r25, 0x07	; 7
    f55a:	64 e7       	ldi	r22, 0x74	; 116
    f55c:	7e e3       	ldi	r23, 0x3E	; 62
    f55e:	0e 94 25 8b 	call	0x1164a	; 0x1164a <strstr_P>
    f562:	89 2b       	or	r24, r25
    f564:	09 f4       	brne	.+2      	; 0xf568 <GSM_Cycle+0x1bb0>
    f566:	be c0       	rjmp	.+380    	; 0xf6e4 <GSM_Cycle+0x1d2c>
					GSM_State = GSM_WAIT_MESSAGE;
    f568:	8e e0       	ldi	r24, 0x0E	; 14
    f56a:	80 93 f6 06 	sts	0x06F6, r24
    f56e:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
					if((strstr_P(GSM_RxStr, PSTR("+DTMF: 1")) != NULL) ){
						StartTimer16(TD_GSM,1000);
						GSM_State = GSM_SEND_PLAY_CONFIRM_FILE;
						
					}
					if((strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 2,0,6")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 3,0,6")) != NULL) ){
    f572:	81 ee       	ldi	r24, 0xE1	; 225
    f574:	97 e0       	ldi	r25, 0x07	; 7
    f576:	61 e0       	ldi	r22, 0x01	; 1
    f578:	7f e3       	ldi	r23, 0x3F	; 63
    f57a:	0e 94 25 8b 	call	0x1164a	; 0x1164a <strstr_P>
    f57e:	89 2b       	or	r24, r25
    f580:	09 f0       	breq	.+2      	; 0xf584 <GSM_Cycle+0x1bcc>
    f582:	e7 ce       	rjmp	.-562    	; 0xf352 <GSM_Cycle+0x199a>
    f584:	81 ee       	ldi	r24, 0xE1	; 225
    f586:	97 e0       	ldi	r25, 0x07	; 7
    f588:	64 ef       	ldi	r22, 0xF4	; 244
    f58a:	7e e3       	ldi	r23, 0x3E	; 62
    f58c:	0e 94 25 8b 	call	0x1164a	; 0x1164a <strstr_P>
    f590:	89 2b       	or	r24, r25
    f592:	09 f0       	breq	.+2      	; 0xf596 <GSM_Cycle+0x1bde>
    f594:	de ce       	rjmp	.-580    	; 0xf352 <GSM_Cycle+0x199a>
    f596:	0c 94 db 70 	jmp	0xe1b6	; 0xe1b6 <GSM_Cycle+0x7fe>
				GSM_State = GSM_WAIT_MESSAGE;
			}
			break;
		case GSM_WAIT_CCLC_0:
			if(GetStringFromFIFO()){
				if((strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,0,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,0,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,0,")) != NULL) ){
    f59a:	81 ee       	ldi	r24, 0xE1	; 225
    f59c:	97 e0       	ldi	r25, 0x07	; 7
    f59e:	62 ec       	ldi	r22, 0xC2	; 194
    f5a0:	7f e3       	ldi	r23, 0x3F	; 63
    f5a2:	0e 94 25 8b 	call	0x1164a	; 0x1164a <strstr_P>
    f5a6:	89 2b       	or	r24, r25
    f5a8:	11 f0       	breq	.+4      	; 0xf5ae <GSM_Cycle+0x1bf6>
    f5aa:	0c 94 0d 72 	jmp	0xe41a	; 0xe41a <GSM_Cycle+0xa62>
    f5ae:	81 ee       	ldi	r24, 0xE1	; 225
    f5b0:	97 e0       	ldi	r25, 0x07	; 7
    f5b2:	64 eb       	ldi	r22, 0xB4	; 180
    f5b4:	7f e3       	ldi	r23, 0x3F	; 63
    f5b6:	0e 94 25 8b 	call	0x1164a	; 0x1164a <strstr_P>
    f5ba:	89 2b       	or	r24, r25
    f5bc:	11 f0       	breq	.+4      	; 0xf5c2 <GSM_Cycle+0x1c0a>
    f5be:	0c 94 0d 72 	jmp	0xe41a	; 0xe41a <GSM_Cycle+0xa62>
					RequestRepeatCounter = 0;
					GSM_State = GSM_SEND_PLAY_ALARM_FILE;
					break;
				}
				if( (strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6,")) != NULL)){
    f5c2:	81 ee       	ldi	r24, 0xE1	; 225
    f5c4:	97 e0       	ldi	r25, 0x07	; 7
    f5c6:	66 ea       	ldi	r22, 0xA6	; 166
    f5c8:	7f e3       	ldi	r23, 0x3F	; 63
    f5ca:	0e 94 25 8b 	call	0x1164a	; 0x1164a <strstr_P>
    f5ce:	89 2b       	or	r24, r25
    f5d0:	09 f4       	brne	.+2      	; 0xf5d4 <GSM_Cycle+0x1c1c>
    f5d2:	fc cc       	rjmp	.-1544   	; 0xefcc <GSM_Cycle+0x1614>
					StartTimer16(TD_GSM, 6000);
    f5d4:	80 91 e9 04 	lds	r24, 0x04E9
    f5d8:	60 e7       	ldi	r22, 0x70	; 112
    f5da:	77 e1       	ldi	r23, 0x17	; 23
    f5dc:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
					GSM_State = GSM_WAIT_DISCONNECT_CAUSE;
    f5e0:	85 e2       	ldi	r24, 0x25	; 37
    f5e2:	80 93 f6 06 	sts	0x06F6, r24
    f5e6:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
				break;
			}


			//  
			if( (strstr_P(GSM_RxStr, URC_CONNECT) != NULL) ){
    f5ea:	c8 01       	movw	r24, r16
    f5ec:	60 ec       	ldi	r22, 0xC0	; 192
    f5ee:	73 e0       	ldi	r23, 0x03	; 3
    f5f0:	0e 94 25 8b 	call	0x1164a	; 0x1164a <strstr_P>
    f5f4:	89 2b       	or	r24, r25
    f5f6:	b1 f0       	breq	.+44     	; 0xf624 <GSM_Cycle+0x1c6c>

				GSM_State = GSM_ProtocolMode;
    f5f8:	82 e5       	ldi	r24, 0x52	; 82
    f5fa:	80 93 f6 06 	sts	0x06F6, r24
    f5fe:	f8 01       	movw	r30, r16
				for(int i=0;i<GSM_RXSTR_SIZE;i++)
				{
					GSM_RxStr[i]=0;	
    f600:	11 92       	st	Z+, r1

			//  
			if( (strstr_P(GSM_RxStr, URC_CONNECT) != NULL) ){

				GSM_State = GSM_ProtocolMode;
				for(int i=0;i<GSM_RXSTR_SIZE;i++)
    f602:	38 e0       	ldi	r19, 0x08	; 8
    f604:	e5 34       	cpi	r30, 0x45	; 69
    f606:	f3 07       	cpc	r31, r19
    f608:	d9 f7       	brne	.-10     	; 0xf600 <GSM_Cycle+0x1c48>
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    f60a:	8f ef       	ldi	r24, 0xFF	; 255
    f60c:	80 93 3e 07 	sts	0x073E, r24
	GSM_RX_FIFO_End = 255;
    f610:	80 93 53 06 	sts	0x0653, r24
	GSM_RxCharN = 0;
    f614:	10 92 60 0b 	sts	0x0B60, r1
	GSM_RX_FIFOOverFlow = 0;
    f618:	10 92 13 09 	sts	0x0913, r1
	GSM_RX_FIFOMax = 0;
    f61c:	10 92 19 09 	sts	0x0919, r1
    f620:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>

				break;
			}

			//  
			if(strstr_P(GSM_RxStr, URC_CLOSED) != NULL){
    f624:	c8 01       	movw	r24, r16
    f626:	62 ed       	ldi	r22, 0xD2	; 210
    f628:	73 e0       	ldi	r23, 0x03	; 3
    f62a:	0e 94 25 8b 	call	0x1164a	; 0x1164a <strstr_P>
    f62e:	89 2b       	or	r24, r25
    f630:	99 f1       	breq	.+102    	; 0xf698 <GSM_Cycle+0x1ce0>
				//  
				sscanf_P(GSM_RxStr,PSTR("%hhu, CLOSED"),(unsigned char*)&TempNum);
    f632:	00 d0       	rcall	.+0      	; 0xf634 <GSM_Cycle+0x1c7c>
    f634:	00 d0       	rcall	.+0      	; 0xf636 <GSM_Cycle+0x1c7e>
    f636:	ed b7       	in	r30, 0x3d	; 61
    f638:	fe b7       	in	r31, 0x3e	; 62
    f63a:	31 96       	adiw	r30, 0x01	; 1
    f63c:	ad b7       	in	r26, 0x3d	; 61
    f63e:	be b7       	in	r27, 0x3e	; 62
    f640:	12 96       	adiw	r26, 0x02	; 2
    f642:	1c 93       	st	X, r17
    f644:	0e 93       	st	-X, r16
    f646:	11 97       	sbiw	r26, 0x01	; 1
    f648:	85 e4       	ldi	r24, 0x45	; 69
    f64a:	9e e3       	ldi	r25, 0x3E	; 62
    f64c:	93 83       	std	Z+3, r25	; 0x03
    f64e:	82 83       	std	Z+2, r24	; 0x02
    f650:	8c ed       	ldi	r24, 0xDC	; 220
    f652:	95 e0       	ldi	r25, 0x05	; 5
    f654:	95 83       	std	Z+5, r25	; 0x05
    f656:	84 83       	std	Z+4, r24	; 0x04
    f658:	0e 94 74 8c 	call	0x118e8	; 0x118e8 <sscanf_P>
				if(GSM_ActiveConnection == TempNum){
    f65c:	ed b7       	in	r30, 0x3d	; 61
    f65e:	fe b7       	in	r31, 0x3e	; 62
    f660:	36 96       	adiw	r30, 0x06	; 6
    f662:	0f b6       	in	r0, 0x3f	; 63
    f664:	f8 94       	cli
    f666:	fe bf       	out	0x3e, r31	; 62
    f668:	0f be       	out	0x3f, r0	; 63
    f66a:	ed bf       	out	0x3d, r30	; 61
    f66c:	90 91 d3 02 	lds	r25, 0x02D3
    f670:	80 91 dc 05 	lds	r24, 0x05DC
    f674:	98 17       	cp	r25, r24
    f676:	59 f4       	brne	.+22     	; 0xf68e <GSM_Cycle+0x1cd6>
					GSM_ActiveConnection = NO_CONNECTION;
    f678:	8f ef       	ldi	r24, 0xFF	; 255
    f67a:	80 93 d3 02 	sts	0x02D3, r24
	uint8_t IP4;
} IP_Addr;

//~~~~~~~~~~~~~~
void SetIP(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	IP->IP1 = IP1;
    f67e:	10 92 4a 0b 	sts	0x0B4A, r1
	IP->IP2 = IP2;
    f682:	10 92 4b 0b 	sts	0x0B4B, r1
	IP->IP3 = IP3;
    f686:	10 92 4c 0b 	sts	0x0B4C, r1
	IP->IP4 = IP4;
    f68a:	10 92 4d 0b 	sts	0x0B4D, r1
					SetIP(&GSM_ClientIP,0,0,0,0);
				}

				GSM_State = GSM_ReStart1;
    f68e:	8a e4       	ldi	r24, 0x4A	; 74
    f690:	80 93 f6 06 	sts	0x06F6, r24
    f694:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
				break;
			}

			// +PDP DEACT
			if( (strstr_P(GSM_RxStr, URC_PDPDEACT) != NULL) ){
    f698:	c8 01       	movw	r24, r16
    f69a:	6b ed       	ldi	r22, 0xDB	; 219
    f69c:	73 e0       	ldi	r23, 0x03	; 3
    f69e:	0e 94 25 8b 	call	0x1164a	; 0x1164a <strstr_P>
    f6a2:	89 2b       	or	r24, r25
    f6a4:	29 f0       	breq	.+10     	; 0xf6b0 <GSM_Cycle+0x1cf8>
				GSM_State = GSM_SEND_E0;
    f6a6:	88 e0       	ldi	r24, 0x08	; 8
    f6a8:	80 93 f6 06 	sts	0x06F6, r24
    f6ac:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
			}



			//      
			if(strstr_P(GSM_RxStr, RESP_CSQ) != NULL ){
    f6b0:	c8 01       	movw	r24, r16
    f6b2:	63 e4       	ldi	r22, 0x43	; 67
    f6b4:	74 e0       	ldi	r23, 0x04	; 4
    f6b6:	0e 94 25 8b 	call	0x1164a	; 0x1164a <strstr_P>
    f6ba:	89 2b       	or	r24, r25
    f6bc:	01 f1       	breq	.+64     	; 0xf6fe <GSM_Cycle+0x1d46>
				GSM_State = GSM_WAIT_CSQ;
    f6be:	80 e5       	ldi	r24, 0x50	; 80
    f6c0:	80 93 f6 06 	sts	0x06F6, r24
    f6c4:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
						AppProtocol = 0;
						if(!strncmp_P(GSM_RxStr, PSTR("GET "), 4)) {AppProtocol = _HTTP;GSM_State = GSM_DataMode;break;}//GET
						if(!strncmp_P(GSM_RxStr, PSTR("POST"), 4)) {AppProtocol = _HTTP;GSM_State = GSM_DataMode;break;}//POST
						if(!strncmp_P(GSM_RxStr, PSTR("CLOS"), 4)) {AppProtocol = _HTTP;GSM_State = GSM_ReStart1;break;}// 
						if(!strncmp_P(GSM_RxStr, PSTR("+PDP"), 4)) {AppProtocol = _HTTP;GSM_State = GSM_ReStart1;break;}//GPRS 
						if( (GSM_RxStr[0]==0) && (GSM_RxStr[1]==0)){AppProtocol = _HTTP;GSM_State = GSM_ReStart1;break;}//  
    f6c8:	81 e0       	ldi	r24, 0x01	; 1
    f6ca:	80 93 e7 08 	sts	0x08E7, r24
    f6ce:	8a e4       	ldi	r24, 0x4A	; 74
    f6d0:	80 93 f6 06 	sts	0x06F6, r24
    f6d4:	fa cc       	rjmp	.-1548   	; 0xf0ca <GSM_Cycle+0x1712>
							if(!strncmp_P(GSM_RxStr, PSTR("\r\n"), 2)) {GSM_RxCharN=0;}
						}
					if(GSM_RxCharN >= 4){
						AppProtocol = 0;
						if(!strncmp_P(GSM_RxStr, PSTR("GET "), 4)) {AppProtocol = _HTTP;GSM_State = GSM_DataMode;break;}//GET
						if(!strncmp_P(GSM_RxStr, PSTR("POST"), 4)) {AppProtocol = _HTTP;GSM_State = GSM_DataMode;break;}//POST
    f6d6:	81 e0       	ldi	r24, 0x01	; 1
    f6d8:	80 93 e7 08 	sts	0x08E7, r24
    f6dc:	83 e5       	ldi	r24, 0x53	; 83
    f6de:	80 93 f6 06 	sts	0x06F6, r24
    f6e2:	f3 cc       	rjmp	.-1562   	; 0xf0ca <GSM_Cycle+0x1712>
				if((strstr_P(GSM_RxStr, PSTR("BUSY")) != NULL) ){
					GSM_State = GSM_WAIT_MESSAGE;

					break;
				}
				if((strstr_P(GSM_RxStr, PSTR("NO CARRIER")) != NULL) ){
    f6e4:	81 ee       	ldi	r24, 0xE1	; 225
    f6e6:	97 e0       	ldi	r25, 0x07	; 7
    f6e8:	69 e6       	ldi	r22, 0x69	; 105
    f6ea:	7e e3       	ldi	r23, 0x3E	; 62
    f6ec:	0e 94 25 8b 	call	0x1164a	; 0x1164a <strstr_P>
    f6f0:	89 2b       	or	r24, r25
    f6f2:	51 f0       	breq	.+20     	; 0xf708 <GSM_Cycle+0x1d50>
					GSM_State = GSM_WAIT_MESSAGE;
    f6f4:	8e e0       	ldi	r24, 0x0E	; 14
    f6f6:	80 93 f6 06 	sts	0x06F6, r24
    f6fa:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
				GSM_State = GSM_WAIT_CSQ;
				break;
			}

			// 
			GSM_State = GSM_WAIT_IDENTIFICATION;
    f6fe:	8e e3       	ldi	r24, 0x3E	; 62
    f700:	80 93 f6 06 	sts	0x06F6, r24
    f704:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>
				if((strstr_P(GSM_RxStr, PSTR("NO CARRIER")) != NULL) ){
					GSM_State = GSM_WAIT_MESSAGE;

					break;
				}
				GSM_State = GSM_WAIT_MESSAGE;
    f708:	8e e0       	ldi	r24, 0x0E	; 14
    f70a:	80 93 f6 06 	sts	0x06F6, r24
    f70e:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x40>

0000f712 <USART_Cycle>:

// ~~~~~~~~~~~~~~
void
USART_Cycle(void)
{
	MB_Cycle();
    f712:	0e 94 4b 41 	call	0x8296	; 0x8296 <MB_Cycle>
	#ifdef GSM
		GSM_Cycle();
    f716:	0e 94 dc 6c 	call	0xd9b8	; 0xd9b8 <GSM_Cycle>
	#endif
	#ifdef UDP_EASY
		UDP_RxProcess();
	#endif
}
    f71a:	08 95       	ret

0000f71c <IP_E_compare_Const>:
}
uint8_t IP_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	if((IP->IP1 == IP1) && (IP->IP2 == IP2) && (IP->IP3 == IP3) && (IP->IP4 == IP4)) return 1;
	else return 0;
}
uint8_t IP_E_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
    f71c:	ef 92       	push	r14
    f71e:	ff 92       	push	r15
    f720:	0f 93       	push	r16
    f722:	1f 93       	push	r17
    f724:	cf 93       	push	r28
    f726:	df 93       	push	r29
    f728:	ec 01       	movw	r28, r24
    f72a:	16 2f       	mov	r17, r22
    f72c:	f4 2e       	mov	r15, r20
    f72e:	e2 2e       	mov	r14, r18
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    f730:	0e 94 1d 8e 	call	0x11c3a	; 0x11c3a <__eerd_byte_m2560>
	if((erb(&IP->IP1) == IP1) && (erb(&IP->IP2) == IP2) && (erb(&IP->IP3) == IP3) && (erb(&IP->IP4) == IP4)) return 1;
    f734:	18 17       	cp	r17, r24
    f736:	49 f0       	breq	.+18     	; 0xf74a <IP_E_compare_Const+0x2e>
	else return 0;
}
    f738:	90 e0       	ldi	r25, 0x00	; 0
    f73a:	89 2f       	mov	r24, r25
    f73c:	df 91       	pop	r29
    f73e:	cf 91       	pop	r28
    f740:	1f 91       	pop	r17
    f742:	0f 91       	pop	r16
    f744:	ff 90       	pop	r15
    f746:	ef 90       	pop	r14
    f748:	08 95       	ret
    f74a:	ce 01       	movw	r24, r28
    f74c:	01 96       	adiw	r24, 0x01	; 1
    f74e:	0e 94 1d 8e 	call	0x11c3a	; 0x11c3a <__eerd_byte_m2560>
uint8_t IP_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	if((IP->IP1 == IP1) && (IP->IP2 == IP2) && (IP->IP3 == IP3) && (IP->IP4 == IP4)) return 1;
	else return 0;
}
uint8_t IP_E_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	if((erb(&IP->IP1) == IP1) && (erb(&IP->IP2) == IP2) && (erb(&IP->IP3) == IP3) && (erb(&IP->IP4) == IP4)) return 1;
    f752:	f8 16       	cp	r15, r24
    f754:	89 f7       	brne	.-30     	; 0xf738 <IP_E_compare_Const+0x1c>
    f756:	ce 01       	movw	r24, r28
    f758:	02 96       	adiw	r24, 0x02	; 2
    f75a:	0e 94 1d 8e 	call	0x11c3a	; 0x11c3a <__eerd_byte_m2560>
    f75e:	e8 16       	cp	r14, r24
    f760:	59 f7       	brne	.-42     	; 0xf738 <IP_E_compare_Const+0x1c>
    f762:	ce 01       	movw	r24, r28
    f764:	03 96       	adiw	r24, 0x03	; 3
    f766:	0e 94 1d 8e 	call	0x11c3a	; 0x11c3a <__eerd_byte_m2560>
    f76a:	90 e0       	ldi	r25, 0x00	; 0
    f76c:	08 13       	cpse	r16, r24
    f76e:	91 e0       	ldi	r25, 0x01	; 1
    f770:	81 e0       	ldi	r24, 0x01	; 1
    f772:	98 27       	eor	r25, r24
    f774:	e2 cf       	rjmp	.-60     	; 0xf73a <IP_E_compare_Const+0x1e>

0000f776 <MB_M_Init>:
}

// ~~~~~~~~~~~~~~~~~~~~
void
MB_M_Init(uint8_t MB_N)
{
    f776:	cf 92       	push	r12
    f778:	df 92       	push	r13
    f77a:	ef 92       	push	r14
    f77c:	ff 92       	push	r15
    f77e:	0f 93       	push	r16
    f780:	1f 93       	push	r17
	MB_M_Period[MB_N]		= erw(&MB_M_Param_EE[MB_N].Period);
    f782:	e8 2e       	mov	r14, r24
    f784:	ff 24       	eor	r15, r15
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    f786:	87 01       	movw	r16, r14
    f788:	00 0f       	add	r16, r16
    f78a:	11 1f       	adc	r17, r17
    f78c:	00 0f       	add	r16, r16
    f78e:	11 1f       	adc	r17, r17
    f790:	0e 0d       	add	r16, r14
    f792:	1f 1d       	adc	r17, r15
    f794:	32 e9       	ldi	r19, 0x92	; 146
    f796:	c3 2e       	mov	r12, r19
    f798:	31 e0       	ldi	r19, 0x01	; 1
    f79a:	d3 2e       	mov	r13, r19
    f79c:	c6 01       	movw	r24, r12
    f79e:	80 0f       	add	r24, r16
    f7a0:	91 1f       	adc	r25, r17
    f7a2:	0e 94 2b 8e 	call	0x11c56	; 0x11c56 <__eerd_word_m2560>
    f7a6:	f7 01       	movw	r30, r14
    f7a8:	ee 0f       	add	r30, r30
    f7aa:	ff 1f       	adc	r31, r31
    f7ac:	e3 55       	subi	r30, 0x53	; 83
    f7ae:	f9 4f       	sbci	r31, 0xF9	; 249
    f7b0:	91 83       	std	Z+1, r25	; 0x01
    f7b2:	80 83       	st	Z, r24
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    f7b4:	0e 5f       	subi	r16, 0xFE	; 254
    f7b6:	1f 4f       	sbci	r17, 0xFF	; 255
    f7b8:	c6 01       	movw	r24, r12
    f7ba:	80 0f       	add	r24, r16
    f7bc:	91 1f       	adc	r25, r17
    f7be:	0e 94 1d 8e 	call	0x11c3a	; 0x11c3a <__eerd_byte_m2560>
	MB_M_Timeout[MB_N]	= erb(&MB_M_Param_EE[MB_N].Timeout);
    f7c2:	f7 01       	movw	r30, r14
    f7c4:	e7 5d       	subi	r30, 0xD7	; 215
    f7c6:	f6 4f       	sbci	r31, 0xF6	; 246
    f7c8:	80 83       	st	Z, r24
    f7ca:	0f 5f       	subi	r16, 0xFF	; 255
    f7cc:	1f 4f       	sbci	r17, 0xFF	; 255
    f7ce:	c6 01       	movw	r24, r12
    f7d0:	80 0f       	add	r24, r16
    f7d2:	91 1f       	adc	r25, r17
    f7d4:	0e 94 1d 8e 	call	0x11c3a	; 0x11c3a <__eerd_byte_m2560>
	MB_M_Try[MB_N]			= erb(&MB_M_Param_EE[MB_N].Try);
    f7d8:	f7 01       	movw	r30, r14
    f7da:	e1 5c       	subi	r30, 0xC1	; 193
    f7dc:	f8 4f       	sbci	r31, 0xF8	; 248
    f7de:	80 83       	st	Z, r24
    f7e0:	0f 5f       	subi	r16, 0xFF	; 255
    f7e2:	1f 4f       	sbci	r17, 0xFF	; 255
    f7e4:	c6 01       	movw	r24, r12
    f7e6:	80 0f       	add	r24, r16
    f7e8:	91 1f       	adc	r25, r17
    f7ea:	0e 94 1d 8e 	call	0x11c3a	; 0x11c3a <__eerd_byte_m2560>
	MB_M_TimeOff[MB_N]	= erb(&MB_M_Param_EE[MB_N].TimeOff);
    f7ee:	2f ed       	ldi	r18, 0xDF	; 223
    f7f0:	35 e0       	ldi	r19, 0x05	; 5
    f7f2:	e2 0e       	add	r14, r18
    f7f4:	f3 1e       	adc	r15, r19
    f7f6:	f7 01       	movw	r30, r14
    f7f8:	80 83       	st	Z, r24

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    f7fa:	80 91 d0 02 	lds	r24, 0x02D0
	VacantTimer16Sys += n;
    f7fe:	8d 5f       	subi	r24, 0xFD	; 253
    f800:	80 93 d0 02 	sts	0x02D0, r24
    f804:	83 50       	subi	r24, 0x03	; 3

	TD_MB = Timer16SysAlloc(Modbus_Qt*3);
    f806:	80 93 e8 04 	sts	0x04E8, r24
}
    f80a:	1f 91       	pop	r17
    f80c:	0f 91       	pop	r16
    f80e:	ff 90       	pop	r15
    f810:	ef 90       	pop	r14
    f812:	df 90       	pop	r13
    f814:	cf 90       	pop	r12
    f816:	08 95       	ret

0000f818 <MB_S_Init>:
}

// ~~~~~~~~~~~~~~~~~~~~
void
MB_S_Init(uint8_t MB_N)
{
    f818:	0f 93       	push	r16
    f81a:	1f 93       	push	r17
    f81c:	08 2f       	mov	r16, r24
    f81e:	10 e0       	ldi	r17, 0x00	; 0
    f820:	c8 01       	movw	r24, r16
    f822:	89 56       	subi	r24, 0x69	; 105
    f824:	9e 4f       	sbci	r25, 0xFE	; 254
    f826:	0e 94 1d 8e 	call	0x11c3a	; 0x11c3a <__eerd_byte_m2560>
	#ifndef MB_ADDR_DIP_SW
		MB_NativeAddr[MB_N] = erb(MB_NativeAddr_EE+MB_N);
    f82a:	00 52       	subi	r16, 0x20	; 32
    f82c:	1a 4f       	sbci	r17, 0xFA	; 250
    f82e:	f8 01       	movw	r30, r16
    f830:	80 83       	st	Z, r24
	#endif
}
    f832:	1f 91       	pop	r17
    f834:	0f 91       	pop	r16
    f836:	08 95       	ret

0000f838 <SetBAUD>:
}

// ~~~~~~~~~~~~~~~~~~
void
SetBAUD(uint8_t MB_N)
{
    f838:	ef 92       	push	r14
    f83a:	ff 92       	push	r15
    f83c:	0f 93       	push	r16
    f83e:	1f 93       	push	r17
	BR_Val *ptrBR_Val = BR_Tbl + (MB_BitRate_RAM[MB_N] = erb(&MB_Param[MB_N].BitRate));
    f840:	08 2f       	mov	r16, r24
    f842:	10 e0       	ldi	r17, 0x00	; 0
    f844:	78 01       	movw	r14, r16
    f846:	ee 0c       	add	r14, r14
    f848:	ff 1c       	adc	r15, r15
    f84a:	e0 0e       	add	r14, r16
    f84c:	f1 1e       	adc	r15, r17
    f84e:	c7 01       	movw	r24, r14
    f850:	8a 5f       	subi	r24, 0xFA	; 250
    f852:	9f 4f       	sbci	r25, 0xFF	; 255
    f854:	0e 94 1d 8e 	call	0x11c3a	; 0x11c3a <__eerd_byte_m2560>
    f858:	98 2f       	mov	r25, r24
    f85a:	f8 01       	movw	r30, r16
    f85c:	e3 53       	subi	r30, 0x33	; 51
    f85e:	f8 4f       	sbci	r31, 0xF8	; 248
    f860:	80 83       	st	Z, r24
    f862:	83 e0       	ldi	r24, 0x03	; 3
    f864:	98 9f       	mul	r25, r24
    f866:	b0 01       	movw	r22, r0
    f868:	11 24       	eor	r1, r1
    f86a:	60 5c       	subi	r22, 0xC0	; 192
    f86c:	7c 4f       	sbci	r23, 0xFC	; 252

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    f86e:	00 0f       	add	r16, r16
    f870:	11 1f       	adc	r17, r17
    f872:	00 0f       	add	r16, r16
    f874:	11 1f       	adc	r17, r17
    f876:	c8 01       	movw	r24, r16
    f878:	88 0f       	add	r24, r24
    f87a:	99 1f       	adc	r25, r25
    f87c:	88 0f       	add	r24, r24
    f87e:	99 1f       	adc	r25, r25
    f880:	80 0f       	add	r24, r16
    f882:	91 1f       	adc	r25, r17
    f884:	0a 96       	adiw	r24, 0x0a	; 10
    f886:	4c e8       	ldi	r20, 0x8C	; 140
    f888:	50 e4       	ldi	r21, 0x40	; 64
    f88a:	9a 01       	movw	r18, r20
    f88c:	28 0f       	add	r18, r24
    f88e:	39 1f       	adc	r19, r25
    f890:	f9 01       	movw	r30, r18
    f892:	a5 91       	lpm	r26, Z+
    f894:	b4 91       	lpm	r27, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    f896:	fb 01       	movw	r30, r22
    f898:	24 91       	lpm	r18, Z+
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		USART_Reg(MB_N, ubrrl) = prb((uint8_t*)&ptrBR_Val->UBRR);
    f89a:	2c 93       	st	X, r18

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    f89c:	02 97       	sbiw	r24, 0x02	; 2
    f89e:	84 0f       	add	r24, r20
    f8a0:	95 1f       	adc	r25, r21
    f8a2:	fc 01       	movw	r30, r24
    f8a4:	a5 91       	lpm	r26, Z+
    f8a6:	b4 91       	lpm	r27, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    f8a8:	6f 5f       	subi	r22, 0xFF	; 255
    f8aa:	7f 4f       	sbci	r23, 0xFF	; 255
    f8ac:	fb 01       	movw	r30, r22
    f8ae:	84 91       	lpm	r24, Z+
		USART_Reg(MB_N, ubrrh) = prb((uint8_t*)&ptrBR_Val->UBRR+1);
    f8b0:	8c 93       	st	X, r24

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    f8b2:	c7 01       	movw	r24, r14
    f8b4:	88 0f       	add	r24, r24
    f8b6:	99 1f       	adc	r25, r25
    f8b8:	8d 55       	subi	r24, 0x5D	; 93
    f8ba:	9f 4b       	sbci	r25, 0xBF	; 191
    f8bc:	fc 01       	movw	r30, r24
    f8be:	a5 91       	lpm	r26, Z+
    f8c0:	b4 91       	lpm	r27, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    f8c2:	6f 5f       	subi	r22, 0xFF	; 255
    f8c4:	7f 4f       	sbci	r23, 0xFF	; 255
    f8c6:	fb 01       	movw	r30, r22
    f8c8:	84 91       	lpm	r24, Z+

		*(uint8_t*)prp(&MB_Timer[MB_N].OCR) = prb(&ptrBR_Val->Time35);
    f8ca:	8c 93       	st	X, r24
		usart->BAUDCTRLA = prb((uint8_t*)&ptrBR_Val->UBRR);
		usart->BAUDCTRLB = prb((uint8_t*)&ptrBR_Val->UBRR+1) + USART_BSCALE0_bm;

		((TC1_t*)prp(MB_Timer+MB_N))->PER = prw(&ptrBR_Val->Time35);
	#endif
}
    f8cc:	1f 91       	pop	r17
    f8ce:	0f 91       	pop	r16
    f8d0:	ff 90       	pop	r15
    f8d2:	ef 90       	pop	r14
    f8d4:	08 95       	ret

0000f8d6 <Key_MB0_BitRate>:
	{" BAUD: }}}}}bps     ", NULL, F_MB##N##_Baud}																														\
};																																																					\
MenuPage MenuModbus##N = {SetMenu(L_MB##N), 1};

#if Modbus_Qt == 1
	M_Modbus(0)
    f8d6:	80 e0       	ldi	r24, 0x00	; 0
    f8d8:	0e 94 1c 7c 	call	0xf838	; 0xf838 <SetBAUD>
    f8dc:	08 95       	ret

0000f8de <SetParity>:
// ~~~

// ~~~~~~~~~~~~~~~~~~~~
void
SetParity(uint8_t MB_N)
{
    f8de:	ff 92       	push	r15
    f8e0:	0f 93       	push	r16
    f8e2:	1f 93       	push	r17
    f8e4:	cf 93       	push	r28
    f8e6:	df 93       	push	r29
	uint8_t Parity = erb(&MB_Param[MB_N].Parity), S_B = erb(&MB_Param[MB_N].StopBits);
    f8e8:	c8 2f       	mov	r28, r24
    f8ea:	d0 e0       	ldi	r29, 0x00	; 0
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    f8ec:	8e 01       	movw	r16, r28
    f8ee:	00 0f       	add	r16, r16
    f8f0:	11 1f       	adc	r17, r17
    f8f2:	0c 0f       	add	r16, r28
    f8f4:	1d 1f       	adc	r17, r29
    f8f6:	c8 01       	movw	r24, r16
    f8f8:	8c 5f       	subi	r24, 0xFC	; 252
    f8fa:	9f 4f       	sbci	r25, 0xFF	; 255
    f8fc:	0e 94 1d 8e 	call	0x11c3a	; 0x11c3a <__eerd_byte_m2560>
    f900:	f8 2e       	mov	r15, r24
    f902:	0b 5f       	subi	r16, 0xFB	; 251
    f904:	1f 4f       	sbci	r17, 0xFF	; 255
    f906:	c8 01       	movw	r24, r16
    f908:	0e 94 1d 8e 	call	0x11c3a	; 0x11c3a <__eerd_byte_m2560>
    f90c:	48 2f       	mov	r20, r24
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		uint8_t ucsrc = (~(1<<6) |(1<<2) |(1<<1)) &~(1<<0);
		if (Parity==NoParity) {
    f90e:	ff 20       	and	r15, r15
    f910:	e1 f4       	brne	.+56     	; 0xf94a <SetParity+0x6c>
			ucsrc &=~(1<<5) &~(1<<4);
			switch (S_B) {
    f912:	81 30       	cpi	r24, 0x01	; 1
    f914:	09 f4       	brne	.+2      	; 0xf918 <SetParity+0x3a>
    f916:	3d c0       	rjmp	.+122    	; 0xf992 <SetParity+0xb4>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    f918:	ce 01       	movw	r24, r28
    f91a:	88 0f       	add	r24, r24
    f91c:	99 1f       	adc	r25, r25
    f91e:	88 0f       	add	r24, r24
    f920:	99 1f       	adc	r25, r25
    f922:	9c 01       	movw	r18, r24
    f924:	22 0f       	add	r18, r18
    f926:	33 1f       	adc	r19, r19
    f928:	22 0f       	add	r18, r18
    f92a:	33 1f       	adc	r19, r19
    f92c:	28 0f       	add	r18, r24
    f92e:	39 1f       	adc	r19, r25
    f930:	2e 56       	subi	r18, 0x6E	; 110
    f932:	3f 4b       	sbci	r19, 0xBF	; 191
    f934:	f9 01       	movw	r30, r18
    f936:	a5 91       	lpm	r26, Z+
    f938:	b4 91       	lpm	r27, Z+
		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
			ucsrc  |=(1<<7);
		#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
			ucsrc &=~(1<<7);
		#endif
		USART_Reg(MB_N, ucsrc) = ucsrc;
    f93a:	8e e0       	ldi	r24, 0x0E	; 14
    f93c:	8c 93       	st	X, r24
			}
		}
	#endif
	if (Parity!=NoParity && S_B!=1)
		ewb(&MB_Param[MB_N].StopBits, 1);
}
    f93e:	df 91       	pop	r29
    f940:	cf 91       	pop	r28
    f942:	1f 91       	pop	r17
    f944:	0f 91       	pop	r16
    f946:	ff 90       	pop	r15
    f948:	08 95       	ret
				break;
			}
		}
		else {
			ucsrc &=~(1<<3);
			switch (Parity) {
    f94a:	81 e0       	ldi	r24, 0x01	; 1
    f94c:	f8 16       	cp	r15, r24
    f94e:	f9 f0       	breq	.+62     	; 0xf98e <SetParity+0xb0>
			}
		}
	#endif
	if (Parity!=NoParity && S_B!=1)
		ewb(&MB_Param[MB_N].StopBits, 1);
}
    f950:	56 e3       	ldi	r21, 0x36	; 54
    f952:	ce 01       	movw	r24, r28
    f954:	88 0f       	add	r24, r24
    f956:	99 1f       	adc	r25, r25
    f958:	88 0f       	add	r24, r24
    f95a:	99 1f       	adc	r25, r25
    f95c:	9c 01       	movw	r18, r24
    f95e:	22 0f       	add	r18, r18
    f960:	33 1f       	adc	r19, r19
    f962:	22 0f       	add	r18, r18
    f964:	33 1f       	adc	r19, r19
    f966:	28 0f       	add	r18, r24
    f968:	39 1f       	adc	r19, r25
    f96a:	2e 56       	subi	r18, 0x6E	; 110
    f96c:	3f 4b       	sbci	r19, 0xBF	; 191
    f96e:	f9 01       	movw	r30, r18
    f970:	a5 91       	lpm	r26, Z+
    f972:	b4 91       	lpm	r27, Z+
		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
			ucsrc  |=(1<<7);
		#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
			ucsrc &=~(1<<7);
		#endif
		USART_Reg(MB_N, ucsrc) = ucsrc;
    f974:	5c 93       	st	X, r21
				usart->CTRLC |=USART_PMODE_ODD_gc;
				break;
			}
		}
	#endif
	if (Parity!=NoParity && S_B!=1)
    f976:	41 30       	cpi	r20, 0x01	; 1
    f978:	21 f0       	breq	.+8      	; 0xf982 <SetParity+0xa4>
		ewb(&MB_Param[MB_N].StopBits, 1);
    f97a:	c8 01       	movw	r24, r16
    f97c:	61 e0       	ldi	r22, 0x01	; 1
    f97e:	0e 94 94 56 	call	0xad28	; 0xad28 <ewb>
}
    f982:	df 91       	pop	r29
    f984:	cf 91       	pop	r28
    f986:	1f 91       	pop	r17
    f988:	0f 91       	pop	r16
    f98a:	ff 90       	pop	r15
    f98c:	08 95       	ret
				break;
			}
		}
		else {
			ucsrc &=~(1<<3);
			switch (Parity) {
    f98e:	56 e2       	ldi	r21, 0x26	; 38
    f990:	e0 cf       	rjmp	.-64     	; 0xf952 <SetParity+0x74>
    f992:	ce 01       	movw	r24, r28
    f994:	88 0f       	add	r24, r24
    f996:	99 1f       	adc	r25, r25
    f998:	88 0f       	add	r24, r24
    f99a:	99 1f       	adc	r25, r25
    f99c:	9c 01       	movw	r18, r24
    f99e:	22 0f       	add	r18, r18
    f9a0:	33 1f       	adc	r19, r19
    f9a2:	22 0f       	add	r18, r18
    f9a4:	33 1f       	adc	r19, r19
    f9a6:	28 0f       	add	r18, r24
    f9a8:	39 1f       	adc	r19, r25
    f9aa:	2e 56       	subi	r18, 0x6E	; 110
    f9ac:	3f 4b       	sbci	r19, 0xBF	; 191
    f9ae:	f9 01       	movw	r30, r18
    f9b0:	a5 91       	lpm	r26, Z+
    f9b2:	b4 91       	lpm	r27, Z+
		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
			ucsrc  |=(1<<7);
		#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
			ucsrc &=~(1<<7);
		#endif
		USART_Reg(MB_N, ucsrc) = ucsrc;
    f9b4:	86 e0       	ldi	r24, 0x06	; 6
    f9b6:	8c 93       	st	X, r24
			}
		}
	#endif
	if (Parity!=NoParity && S_B!=1)
		ewb(&MB_Param[MB_N].StopBits, 1);
}
    f9b8:	df 91       	pop	r29
    f9ba:	cf 91       	pop	r28
    f9bc:	1f 91       	pop	r17
    f9be:	0f 91       	pop	r16
    f9c0:	ff 90       	pop	r15
    f9c2:	08 95       	ret

0000f9c4 <Key_MB0_Parity>:
    f9c4:	80 e0       	ldi	r24, 0x00	; 0
    f9c6:	0e 94 6f 7c 	call	0xf8de	; 0xf8de <SetParity>
    f9ca:	08 95       	ret

0000f9cc <MB_Init>:

// ~~~~~~~~~~
void
MB_Init(void)
{
	MB_PLC_Init();
    f9cc:	0e 94 84 27 	call	0x4f08	; 0x4f08 <MB_PLC_Init>
		PORTE.DIR |=(1<<3);
	#endif
	for (uint8_t MB_N=0; MB_N<Modbus_Qt; MB_N++) {
		void MB_S_Init(uint8_t);
		void MB_M_Init(uint8_t);
		MB_State[MB_N] = MB_Initi;
    f9d0:	10 92 c2 05 	sts	0x05C2, r1
    f9d4:	8e e8       	ldi	r24, 0x8E	; 142
    f9d6:	90 e4       	ldi	r25, 0x40	; 64
    f9d8:	fc 01       	movw	r30, r24
    f9da:	a5 91       	lpm	r26, Z+
    f9dc:	b4 91       	lpm	r27, Z+
		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
			USART_Reg(MB_N, ucsra) = ~(1<<1) &~(1<<0);
    f9de:	8c ef       	ldi	r24, 0xFC	; 252
    f9e0:	8c 93       	st	X, r24
    f9e2:	80 e9       	ldi	r24, 0x90	; 144
    f9e4:	90 e4       	ldi	r25, 0x40	; 64
    f9e6:	fc 01       	movw	r30, r24
    f9e8:	a5 91       	lpm	r26, Z+
    f9ea:	b4 91       	lpm	r27, Z+
			USART_Reg(MB_N, ucsrb) = (((1<<7) &~(1<<6) &~(1<<5)) |(1<<4) |(1<<3)) &~(1<<2);
    f9ec:	88 e9       	ldi	r24, 0x98	; 152
    f9ee:	8c 93       	st	X, r24
			tc->CTRLD = TC_EVACT_OFF_gc;
			//tc->CTRLE = TC1_BYTEM_bm;
			tc->INTCTRLA |=TC_ERRINTLVL_OFF_gc;
			tc->INTCTRLB = 0;
		#endif
		SetParity(MB_N);
    f9f0:	80 e0       	ldi	r24, 0x00	; 0
    f9f2:	0e 94 6f 7c 	call	0xf8de	; 0xf8de <SetParity>
		SetBAUD(MB_N);
    f9f6:	80 e0       	ldi	r24, 0x00	; 0
    f9f8:	0e 94 1c 7c 	call	0xf838	; 0xf838 <SetBAUD>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    f9fc:	e0 ea       	ldi	r30, 0xA0	; 160
    f9fe:	f0 e4       	ldi	r31, 0x40	; 64
    fa00:	84 91       	lpm	r24, Z+
		switch (prb(MB_Role+MB_N)) {
    fa02:	88 23       	and	r24, r24
    fa04:	59 f4       	brne	.+22     	; 0xfa1c <MB_Init+0x50>
		case Role_Slave:
			MB_S_Init(MB_N);
    fa06:	80 e0       	ldi	r24, 0x00	; 0
    fa08:	0e 94 0c 7c 	call	0xf818	; 0xf818 <MB_S_Init>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    fa0c:	85 ea       	ldi	r24, 0xA5	; 165
    fa0e:	90 e4       	ldi	r25, 0x40	; 64
    fa10:	fc 01       	movw	r30, r24
    fa12:	25 91       	lpm	r18, Z+
    fa14:	34 91       	lpm	r19, Z+
			break;
		case Role_Master:
			MB_M_Init(MB_N);
			break;
		}
		MB_StartTimer(MB_N);
    fa16:	f9 01       	movw	r30, r18
    fa18:	19 95       	eicall
	}
}
    fa1a:	08 95       	ret
			tc->INTCTRLA |=TC_ERRINTLVL_OFF_gc;
			tc->INTCTRLB = 0;
		#endif
		SetParity(MB_N);
		SetBAUD(MB_N);
		switch (prb(MB_Role+MB_N)) {
    fa1c:	81 30       	cpi	r24, 0x01	; 1
    fa1e:	b1 f7       	brne	.-20     	; 0xfa0c <MB_Init+0x40>
		case Role_Slave:
			MB_S_Init(MB_N);
			break;
		case Role_Master:
			MB_M_Init(MB_N);
    fa20:	80 e0       	ldi	r24, 0x00	; 0
    fa22:	0e 94 bb 7b 	call	0xf776	; 0xf776 <MB_M_Init>
    fa26:	f2 cf       	rjmp	.-28     	; 0xfa0c <MB_Init+0x40>

0000fa28 <USART_Init>:

// ~~~~~~~~~~~~~
void
USART_Init(void)
{
	MB_Init();
    fa28:	0e 94 e6 7c 	call	0xf9cc	; 0xf9cc <MB_Init>
	#ifdef GSM
		GSM_Init();
    fa2c:	0e 94 a2 42 	call	0x8544	; 0x8544 <GSM_Init>
	#endif
	#ifdef UDP_EASY
		UDP_Init();
	#endif
}
    fa30:	08 95       	ret

0000fa32 <LCDBackLightStartTimer>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    fa32:	81 e9       	ldi	r24, 0x91	; 145
    fa34:	91 e0       	ldi	r25, 0x01	; 1
    fa36:	0e 94 1d 8e 	call	0x11c3a	; 0x11c3a <__eerd_byte_m2560>
			PORT_BACKLIGHT &= ~BACKLIGHT;
		#endif
		IntOn();
	}
	void LCDBackLightStartTimer(void){
		switch(erb(&BackLightTimeEE)){
    fa3a:	82 30       	cpi	r24, 0x02	; 2
    fa3c:	e9 f0       	breq	.+58     	; 0xfa78 <LCDBackLightStartTimer+0x46>
    fa3e:	83 30       	cpi	r24, 0x03	; 3
    fa40:	58 f0       	brcs	.+22     	; 0xfa58 <LCDBackLightStartTimer+0x26>
    fa42:	83 30       	cpi	r24, 0x03	; 3
    fa44:	01 f1       	breq	.+64     	; 0xfa86 <LCDBackLightStartTimer+0x54>
    fa46:	84 30       	cpi	r24, 0x04	; 4
    fa48:	81 f0       	breq	.+32     	; 0xfa6a <LCDBackLightStartTimer+0x38>
				break;	
			case BCKLT_10min:
				StartTimer16(TD_BackLight, 60000);
				break;
			default:
				StartTimer16(TD_BackLight, 3000);
    fa4a:	80 91 d8 04 	lds	r24, 0x04D8
    fa4e:	68 eb       	ldi	r22, 0xB8	; 184
    fa50:	7b e0       	ldi	r23, 0x0B	; 11
    fa52:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
    fa56:	08 95       	ret
			PORT_BACKLIGHT &= ~BACKLIGHT;
		#endif
		IntOn();
	}
	void LCDBackLightStartTimer(void){
		switch(erb(&BackLightTimeEE)){
    fa58:	88 23       	and	r24, r24
    fa5a:	b9 f7       	brne	.-18     	; 0xfa4a <LCDBackLightStartTimer+0x18>
			case BCKLT_10sec:
				StartTimer16(TD_BackLight, 1000);
    fa5c:	80 91 d8 04 	lds	r24, 0x04D8
    fa60:	68 ee       	ldi	r22, 0xE8	; 232
    fa62:	73 e0       	ldi	r23, 0x03	; 3
    fa64:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
    fa68:	08 95       	ret
				break;
			case BCKLT_3min:
				StartTimer16(TD_BackLight, 18000);
				break;	
			case BCKLT_10min:
				StartTimer16(TD_BackLight, 60000);
    fa6a:	80 91 d8 04 	lds	r24, 0x04D8
    fa6e:	60 e6       	ldi	r22, 0x60	; 96
    fa70:	7a ee       	ldi	r23, 0xEA	; 234
    fa72:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
    fa76:	08 95       	ret
				break;
			case BCKLT_30sec:
				StartTimer16(TD_BackLight, 3000);
				break;
			case BCKLT_1min:
				StartTimer16(TD_BackLight, 6000);
    fa78:	80 91 d8 04 	lds	r24, 0x04D8
    fa7c:	60 e7       	ldi	r22, 0x70	; 112
    fa7e:	77 e1       	ldi	r23, 0x17	; 23
    fa80:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
    fa84:	08 95       	ret
				break;
			case BCKLT_3min:
				StartTimer16(TD_BackLight, 18000);
    fa86:	80 91 d8 04 	lds	r24, 0x04D8
    fa8a:	60 e5       	ldi	r22, 0x50	; 80
    fa8c:	76 e4       	ldi	r23, 0x46	; 70
    fa8e:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
    fa92:	08 95       	ret

0000fa94 <LCDBackLightInit>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    fa94:	9f b7       	in	r25, 0x3f	; 63
    fa96:	90 78       	andi	r25, 0x80	; 128
    fa98:	90 93 ee 02 	sts	0x02EE, r25
	cli();
    fa9c:	f8 94       	cli
	enum BACKLIGHT_TIMES{ BCKLT_10sec, BCKLT_30sec, BCKLT_1min,  BCKLT_3min,  BCKLT_10min};
	static uint8_t EEMEM BackLightTimeEE = BCKLT_10sec;

	void LCDBackLightInit(void){
		IntOff();	
		DDR_BACKLIGHT |= BACKLIGHT;
    fa9e:	80 91 0a 01 	lds	r24, 0x010A
    faa2:	80 64       	ori	r24, 0x40	; 64
    faa4:	80 93 0a 01 	sts	0x010A, r24

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    faa8:	99 23       	and	r25, r25
    faaa:	09 f0       	breq	.+2      	; 0xfaae <LCDBackLightInit+0x1a>
		sei();
    faac:	78 94       	sei

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    faae:	80 91 d0 02 	lds	r24, 0x02D0
	VacantTimer16Sys += n;
    fab2:	8f 5f       	subi	r24, 0xFF	; 255
    fab4:	80 93 d0 02 	sts	0x02D0, r24
    fab8:	81 50       	subi	r24, 0x01	; 1
		IntOn();	
		TD_BackLight = Timer16SysAlloc(1);
    faba:	80 93 d8 04 	sts	0x04D8, r24
		if(BackLightMode != 2){
    fabe:	80 91 52 06 	lds	r24, 0x0652
    fac2:	82 30       	cpi	r24, 0x02	; 2
    fac4:	21 f0       	breq	.+8      	; 0xface <LCDBackLightInit+0x3a>
			LCDBackLightOn();
    fac6:	0e 94 64 31 	call	0x62c8	; 0x62c8 <LCDBackLightOn>
			LCDBackLightStartTimer();
    faca:	0e 94 19 7d 	call	0xfa32	; 0xfa32 <LCDBackLightStartTimer>
    face:	08 95       	ret

0000fad0 <LCD_Init>:
}

// ~~~~~~~~~~~~
void
LCD_Init (void)
{
    fad0:	ef 92       	push	r14
    fad2:	ff 92       	push	r15
    fad4:	1f 93       	push	r17
    fad6:	cf 93       	push	r28
    fad8:	df 93       	push	r29
	uint8_t i, j;

	// LCD pins
	#ifdef Port_LCD_RW
		Port_LCD_RW &= ~LCD_RW;
    fada:	43 98       	cbi	0x08, 3	; 8
		DDR_LCD_RW |= LCD_RW;
    fadc:	3b 9a       	sbi	0x07, 3	; 7
	#endif

	Port_LCD_RS &= ~LCD_RS;	
    fade:	44 98       	cbi	0x08, 4	; 8
	DDR_LCD_RS |=LCD_RS;
    fae0:	3c 9a       	sbi	0x07, 4	; 7

	Port_LCD_E &= ~LCD_E;	
    fae2:	42 98       	cbi	0x08, 2	; 8
	DDR_LCD_E |=LCD_E;
    fae4:	3a 9a       	sbi	0x07, 2	; 7

	#ifdef Port_LCD_DB0	
		DDR_LCD_DB0 |=DB0;
    fae6:	39 9a       	sbi	0x07, 1	; 7
		DDR_LCD_DB1 |=DB1;
    fae8:	38 9a       	sbi	0x07, 0	; 7
		DDR_LCD_DB2 |=DB2;
    faea:	99 9a       	sbi	0x13, 1	; 19
		DDR_LCD_DB3 |=DB3;
    faec:	98 9a       	sbi	0x13, 0	; 19
	#endif
	DDR_LCD_DB4 |=DB4;
    faee:	57 9a       	sbi	0x0a, 7	; 10
	DDR_LCD_DB5 |=DB5;
    faf0:	56 9a       	sbi	0x0a, 6	; 10
	DDR_LCD_DB6 |=DB6;
    faf2:	55 9a       	sbi	0x0a, 5	; 10
	DDR_LCD_DB7 |=DB7;
    faf4:	80 91 0a 01 	lds	r24, 0x010A
    faf8:	80 68       	ori	r24, 0x80	; 128
    fafa:	80 93 0a 01 	sts	0x010A, r24
    fafe:	21 e3       	ldi	r18, 0x31	; 49
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    fb00:	40 ea       	ldi	r20, 0xA0	; 160
    fb02:	5f e0       	ldi	r21, 0x0F	; 15
    fb04:	ca 01       	movw	r24, r20
    fb06:	01 97       	sbiw	r24, 0x01	; 1
    fb08:	f1 f7       	brne	.-4      	; 0xfb06 <LCD_Init+0x36>

// ~~~~~~~~~~~~~~~~~~~~
void
Delay_ms(uint8_t Delay)
{
	while (Delay--)
    fb0a:	21 50       	subi	r18, 0x01	; 1
    fb0c:	d8 f7       	brcc	.-10     	; 0xfb04 <LCD_Init+0x34>
#endif
// ~~~~~~~~~~~
static void
LCD_Rst0(void)
{
	cli();
    fb0e:	f8 94       	cli
	Port_LCD_RS &=~LCD_RS;
    fb10:	44 98       	cbi	0x08, 4	; 8
	LCD_FuncSet0();
    fb12:	0e 94 be 2f 	call	0x5f7c	; 0x5f7c <LCD_FuncSet0>
	sei();
    fb16:	78 94       	sei
    fb18:	80 ea       	ldi	r24, 0xA0	; 160
    fb1a:	9f e0       	ldi	r25, 0x0F	; 15
    fb1c:	fc 01       	movw	r30, r24
    fb1e:	31 97       	sbiw	r30, 0x01	; 1
    fb20:	f1 f7       	brne	.-4      	; 0xfb1e <LCD_Init+0x4e>
    fb22:	fc 01       	movw	r30, r24
    fb24:	31 97       	sbiw	r30, 0x01	; 1
    fb26:	f1 f7       	brne	.-4      	; 0xfb24 <LCD_Init+0x54>
    fb28:	fc 01       	movw	r30, r24
    fb2a:	31 97       	sbiw	r30, 0x01	; 1
    fb2c:	f1 f7       	brne	.-4      	; 0xfb2a <LCD_Init+0x5a>
    fb2e:	fc 01       	movw	r30, r24
    fb30:	31 97       	sbiw	r30, 0x01	; 1
    fb32:	f1 f7       	brne	.-4      	; 0xfb30 <LCD_Init+0x60>
    fb34:	01 97       	sbiw	r24, 0x01	; 1
    fb36:	f1 f7       	brne	.-4      	; 0xfb34 <LCD_Init+0x64>

// ~~~~~~~~~~~
static void
LCD_Rst1(void)
{
	LCD_FuncSet0();
    fb38:	0e 94 be 2f 	call	0x5f7c	; 0x5f7c <LCD_FuncSet0>
	Delay_us(200);				// 100 us needs
    fb3c:	88 ec       	ldi	r24, 0xC8	; 200
    fb3e:	90 e0       	ldi	r25, 0x00	; 0
    fb40:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <Delay_us>
	LCD_FuncSet0();
    fb44:	0e 94 be 2f 	call	0x5f7c	; 0x5f7c <LCD_FuncSet0>
	Delay_us(LCD_Delay);
    fb48:	82 e3       	ldi	r24, 0x32	; 50
    fb4a:	90 e0       	ldi	r25, 0x00	; 0
    fb4c:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <Delay_us>
	#ifdef Port_LCD_DB0	
		LCD_FuncSet0();
    fb50:	0e 94 be 2f 	call	0x5f7c	; 0x5f7c <LCD_FuncSet0>
	#else
		LCD_FuncSet1();
	#endif
//// BF(Busy flag) can be checked follow
	Delay_us(LCD_Delay);
    fb54:	82 e3       	ldi	r24, 0x32	; 50
    fb56:	90 e0       	ldi	r25, 0x00	; 0
    fb58:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <Delay_us>
	Port_LCD_RS |=LCD_RS;
    fb5c:	44 9a       	sbi	0x08, 4	; 8

	LCD_Rst0();
	Delay_ms(5);		// 4.1 ms needs
	LCD_Rst1();

	Port_LCD_RS &=~LCD_RS;
    fb5e:	44 98       	cbi	0x08, 4	; 8

	#ifdef Port_LCD_DB0	
		Send_I(0b00111000);	//; 8-bits DL, 2 lines, 5x7 dots
    fb60:	88 e3       	ldi	r24, 0x38	; 56
    fb62:	0e 94 b7 2f 	call	0x5f6e	; 0x5f6e <Send_I>
	#else
		Send_I(0b00101000);	//; 4-bits DL, 2 lines, 5x7 dots
	#endif
	Send_I(0b00001100);	//; Display on, cursor off, blink off	
    fb66:	8c e0       	ldi	r24, 0x0C	; 12
    fb68:	0e 94 b7 2f 	call	0x5f6e	; 0x5f6e <Send_I>
	Send_I(0b00000110);	//; cursor shift right, no display shift
    fb6c:	86 e0       	ldi	r24, 0x06	; 6
    fb6e:	0e 94 b7 2f 	call	0x5f6e	; 0x5f6e <Send_I>


	Send_I(0b01000000);	//;    CG RAM   0.
    fb72:	80 e4       	ldi	r24, 0x40	; 64
    fb74:	0e 94 b7 2f 	call	0x5f6e	; 0x5f6e <Send_I>
	Port_LCD_RS |=LCD_RS;
    fb78:	44 9a       	sbi	0x08, 4	; 8
    fb7a:	83 eb       	ldi	r24, 0xB3	; 179
    fb7c:	e8 2e       	mov	r14, r24
    fb7e:	80 e4       	ldi	r24, 0x40	; 64
    fb80:	f8 2e       	mov	r15, r24
	for (i=0; i<8; i++)
    fb82:	e7 01       	movw	r28, r14
    fb84:	10 e0       	ldi	r17, 0x00	; 0

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    fb86:	fe 01       	movw	r30, r28
    fb88:	84 91       	lpm	r24, Z+
		for (j=0; j<8; j++)
			Send_I(prb(CGRAM_LCD[i]+j));
    fb8a:	0e 94 b7 2f 	call	0x5f6e	; 0x5f6e <Send_I>


	Send_I(0b01000000);	//;    CG RAM   0.
	Port_LCD_RS |=LCD_RS;
	for (i=0; i<8; i++)
		for (j=0; j<8; j++)
    fb8e:	1f 5f       	subi	r17, 0xFF	; 255
    fb90:	21 96       	adiw	r28, 0x01	; 1
    fb92:	18 30       	cpi	r17, 0x08	; 8
    fb94:	c1 f7       	brne	.-16     	; 0xfb86 <LCD_Init+0xb6>
    fb96:	88 e0       	ldi	r24, 0x08	; 8
    fb98:	90 e0       	ldi	r25, 0x00	; 0
    fb9a:	e8 0e       	add	r14, r24
    fb9c:	f9 1e       	adc	r15, r25
	Send_I(0b00000110);	//; cursor shift right, no display shift


	Send_I(0b01000000);	//;    CG RAM   0.
	Port_LCD_RS |=LCD_RS;
	for (i=0; i<8; i++)
    fb9e:	93 ef       	ldi	r25, 0xF3	; 243
    fba0:	e9 16       	cp	r14, r25
    fba2:	90 e4       	ldi	r25, 0x40	; 64
    fba4:	f9 06       	cpc	r15, r25
    fba6:	69 f7       	brne	.-38     	; 0xfb82 <LCD_Init+0xb2>
		for (j=0; j<8; j++)
			Send_I(prb(CGRAM_LCD[i]+j));

	Port_LCD_RS &=~LCD_RS;
    fba8:	44 98       	cbi	0x08, 4	; 8
	Send(0b00000001);
    fbaa:	81 e0       	ldi	r24, 0x01	; 1
    fbac:	0e 94 76 2f 	call	0x5eec	; 0x5eec <Send>
    fbb0:	80 ea       	ldi	r24, 0xA0	; 160
    fbb2:	9f e0       	ldi	r25, 0x0F	; 15
    fbb4:	fc 01       	movw	r30, r24
    fbb6:	31 97       	sbiw	r30, 0x01	; 1
    fbb8:	f1 f7       	brne	.-4      	; 0xfbb6 <LCD_Init+0xe6>
    fbba:	fc 01       	movw	r30, r24
    fbbc:	31 97       	sbiw	r30, 0x01	; 1
    fbbe:	f1 f7       	brne	.-4      	; 0xfbbc <LCD_Init+0xec>
    fbc0:	fc 01       	movw	r30, r24
    fbc2:	31 97       	sbiw	r30, 0x01	; 1
    fbc4:	f1 f7       	brne	.-4      	; 0xfbc2 <LCD_Init+0xf2>
    fbc6:	fc 01       	movw	r30, r24
    fbc8:	31 97       	sbiw	r30, 0x01	; 1
    fbca:	f1 f7       	brne	.-4      	; 0xfbc8 <LCD_Init+0xf8>
    fbcc:	01 97       	sbiw	r24, 0x01	; 1
    fbce:	f1 f7       	brne	.-4      	; 0xfbcc <LCD_Init+0xfc>
	Delay_ms(5);				// By trial
	Port_LCD_RS |=LCD_RS;
    fbd0:	44 9a       	sbi	0x08, 4	; 8
}

uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    fbd2:	80 91 cf 02 	lds	r24, 0x02CF
	VacantTimer8Sys += n;
    fbd6:	8f 5f       	subi	r24, 0xFF	; 255
    fbd8:	80 93 cf 02 	sts	0x02CF, r24
    fbdc:	81 50       	subi	r24, 0x01	; 1

	// Frame Timer
	TD_LCD = Timer8SysAlloc(1);
    fbde:	80 93 d7 04 	sts	0x04D7, r24
    fbe2:	20 e0       	ldi	r18, 0x00	; 0
    fbe4:	30 e0       	ldi	r19, 0x00	; 0

	for (i=0; i<LCDYSz; i++)
		for (j=0; j<LCDXSz; j++)
			LCD_Buf[i][j] = ' ';
    fbe6:	40 e2       	ldi	r20, 0x20	; 32
	Port_LCD_RS |=LCD_RS;

	// Frame Timer
	TD_LCD = Timer8SysAlloc(1);

	for (i=0; i<LCDYSz; i++)
    fbe8:	c9 01       	movw	r24, r18
    fbea:	88 0f       	add	r24, r24
    fbec:	99 1f       	adc	r25, r25
    fbee:	82 0f       	add	r24, r18
    fbf0:	93 1f       	adc	r25, r19
    fbf2:	fc 01       	movw	r30, r24
    fbf4:	ee 0f       	add	r30, r30
    fbf6:	ff 1f       	adc	r31, r31
    fbf8:	ee 0f       	add	r30, r30
    fbfa:	ff 1f       	adc	r31, r31
    fbfc:	ee 0f       	add	r30, r30
    fbfe:	ff 1f       	adc	r31, r31
    fc00:	e8 1b       	sub	r30, r24
    fc02:	f9 0b       	sbc	r31, r25
    fc04:	e8 5a       	subi	r30, 0xA8	; 168
    fc06:	f9 4f       	sbci	r31, 0xF9	; 249
    fc08:	80 e0       	ldi	r24, 0x00	; 0
		for (j=0; j<LCDXSz; j++)
			LCD_Buf[i][j] = ' ';
    fc0a:	41 93       	st	Z+, r20

	// Frame Timer
	TD_LCD = Timer8SysAlloc(1);

	for (i=0; i<LCDYSz; i++)
		for (j=0; j<LCDXSz; j++)
    fc0c:	8f 5f       	subi	r24, 0xFF	; 255
    fc0e:	84 31       	cpi	r24, 0x14	; 20
    fc10:	e1 f7       	brne	.-8      	; 0xfc0a <LCD_Init+0x13a>
    fc12:	2f 5f       	subi	r18, 0xFF	; 255
    fc14:	3f 4f       	sbci	r19, 0xFF	; 255
	Port_LCD_RS |=LCD_RS;

	// Frame Timer
	TD_LCD = Timer8SysAlloc(1);

	for (i=0; i<LCDYSz; i++)
    fc16:	24 30       	cpi	r18, 0x04	; 4
    fc18:	31 05       	cpc	r19, r1
    fc1a:	31 f7       	brne	.-52     	; 0xfbe8 <LCD_Init+0x118>
		for (j=0; j<LCDXSz; j++)
			LCD_Buf[i][j] = ' ';

	#ifdef RTYP
		#ifndef QslRD
			*(uint8_t*)RTYP = R_PLC_Type;
    fc1c:	87 e0       	ldi	r24, 0x07	; 7
    fc1e:	80 93 91 08 	sts	0x0891, r24
		#endif	
	#endif

	#ifdef BACKLIGHT
		LCDBackLightInit();
    fc22:	0e 94 4a 7d 	call	0xfa94	; 0xfa94 <LCDBackLightInit>
	#endif
}
    fc26:	df 91       	pop	r29
    fc28:	cf 91       	pop	r28
    fc2a:	1f 91       	pop	r17
    fc2c:	ff 90       	pop	r15
    fc2e:	ef 90       	pop	r14
    fc30:	08 95       	ret

0000fc32 <RTC_Summer_Time>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    fc32:	83 e0       	ldi	r24, 0x03	; 3
    fc34:	90 e0       	ldi	r25, 0x00	; 0
    fc36:	0e 94 1d 8e 	call	0x11c3a	; 0x11c3a <__eerd_byte_m2560>
	
	return 0;
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void RTC_Summer_Time(void){
	if(erb(&SummerTime)){
    fc3a:	88 23       	and	r24, r24
    fc3c:	31 f0       	breq	.+12     	; 0xfc4a <RTC_Summer_Time+0x18>
		//   ()  02:00:00   03:00:00    
		if( (Tm_Mon == 3) && (Tm_WDay == 0) && (Tm_MDay>=25) && (Tm_Hour == 2) ){
    fc3e:	90 91 cc 07 	lds	r25, 0x07CC
    fc42:	93 30       	cpi	r25, 0x03	; 3
    fc44:	b1 f0       	breq	.+44     	; 0xfc72 <RTC_Summer_Time+0x40>
				Tm_Hour=3;
				SetHour();
		}

		//   ()  04:00:00   03:00:00    
		if( (Tm_Mon == 10) && (Tm_WDay == 0) && (Tm_MDay>=25) ){
    fc46:	9a 30       	cpi	r25, 0x0A	; 10
    fc48:	09 f0       	breq	.+2      	; 0xfc4c <RTC_Summer_Time+0x1a>
    fc4a:	08 95       	ret
    fc4c:	80 91 57 06 	lds	r24, 0x0657
    fc50:	88 23       	and	r24, r24
    fc52:	d9 f7       	brne	.-10     	; 0xfc4a <RTC_Summer_Time+0x18>
    fc54:	80 91 5f 0b 	lds	r24, 0x0B5F
    fc58:	89 31       	cpi	r24, 0x19	; 25
    fc5a:	b8 f3       	brcs	.-18     	; 0xfc4a <RTC_Summer_Time+0x18>
				if(Tm_Hour == 4){
    fc5c:	80 91 c1 05 	lds	r24, 0x05C1
    fc60:	84 30       	cpi	r24, 0x04	; 4
    fc62:	d1 f0       	breq	.+52     	; 0xfc98 <RTC_Summer_Time+0x66>
						Tm_Hour=3;
						SetHour();
						NotSummerTimeFlag = 1;
					}
				}
				if(Tm_Hour < 2) NotSummerTimeFlag = 0;
    fc64:	82 30       	cpi	r24, 0x02	; 2
    fc66:	38 f1       	brcs	.+78     	; 0xfcb6 <RTC_Summer_Time+0x84>
				if(Tm_Hour >= 5) NotSummerTimeFlag = 0;
    fc68:	85 30       	cpi	r24, 0x05	; 5
    fc6a:	78 f3       	brcs	.-34     	; 0xfc4a <RTC_Summer_Time+0x18>
    fc6c:	10 92 dd 05 	sts	0x05DD, r1
    fc70:	08 95       	ret
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void RTC_Summer_Time(void){
	if(erb(&SummerTime)){
		//   ()  02:00:00   03:00:00    
		if( (Tm_Mon == 3) && (Tm_WDay == 0) && (Tm_MDay>=25) && (Tm_Hour == 2) ){
    fc72:	80 91 57 06 	lds	r24, 0x0657
    fc76:	88 23       	and	r24, r24
    fc78:	41 f7       	brne	.-48     	; 0xfc4a <RTC_Summer_Time+0x18>
    fc7a:	80 91 5f 0b 	lds	r24, 0x0B5F
    fc7e:	89 31       	cpi	r24, 0x19	; 25
    fc80:	20 f3       	brcs	.-56     	; 0xfc4a <RTC_Summer_Time+0x18>
    fc82:	80 91 c1 05 	lds	r24, 0x05C1
    fc86:	82 30       	cpi	r24, 0x02	; 2
    fc88:	01 f7       	brne	.-64     	; 0xfc4a <RTC_Summer_Time+0x18>
				Tm_Hour=3;
    fc8a:	90 93 c1 05 	sts	0x05C1, r25
				SetHour();
    fc8e:	0e 94 4a 2d 	call	0x5a94	; 0x5a94 <SetHour>
    fc92:	90 91 cc 07 	lds	r25, 0x07CC
    fc96:	d7 cf       	rjmp	.-82     	; 0xfc46 <RTC_Summer_Time+0x14>
		}

		//   ()  04:00:00   03:00:00    
		if( (Tm_Mon == 10) && (Tm_WDay == 0) && (Tm_MDay>=25) ){
				if(Tm_Hour == 4){
					if(!NotSummerTimeFlag){
    fc98:	80 91 dd 05 	lds	r24, 0x05DD
    fc9c:	88 23       	and	r24, r24
    fc9e:	a9 f6       	brne	.-86     	; 0xfc4a <RTC_Summer_Time+0x18>
						Tm_Hour=3;
    fca0:	83 e0       	ldi	r24, 0x03	; 3
    fca2:	80 93 c1 05 	sts	0x05C1, r24
						SetHour();
    fca6:	0e 94 4a 2d 	call	0x5a94	; 0x5a94 <SetHour>
						NotSummerTimeFlag = 1;
    fcaa:	81 e0       	ldi	r24, 0x01	; 1
    fcac:	80 93 dd 05 	sts	0x05DD, r24
    fcb0:	80 91 c1 05 	lds	r24, 0x05C1
    fcb4:	d7 cf       	rjmp	.-82     	; 0xfc64 <RTC_Summer_Time+0x32>
					}
				}
				if(Tm_Hour < 2) NotSummerTimeFlag = 0;
    fcb6:	10 92 dd 05 	sts	0x05DD, r1
    fcba:	d6 cf       	rjmp	.-84     	; 0xfc68 <RTC_Summer_Time+0x36>

0000fcbc <TWI_In>:
}

// ~~~~~~~~~
void
TWI_In(void)
{
    fcbc:	cf 92       	push	r12
    fcbe:	ef 92       	push	r14
    fcc0:	0f 93       	push	r16
	if(Timer8Stopp(TD_TWI_Poll)){
    fcc2:	00 91 d2 04 	lds	r16, 0x04D2
    fcc6:	80 2f       	mov	r24, r16
    fcc8:	0e 94 73 25 	call	0x4ae6	; 0x4ae6 <Timer8Stopp>
    fccc:	88 23       	and	r24, r24
    fcce:	e1 f0       	breq	.+56     	; 0xfd08 <TWI_In+0x4c>

		if (TWI_Phase == PCF_START){
    fcd0:	80 91 c3 07 	lds	r24, 0x07C3
    fcd4:	88 23       	and	r24, r24
    fcd6:	99 f1       	breq	.+102    	; 0xfd3e <TWI_In+0x82>
			StartTWI();		// Send Start
			TWI_Phase++;
			StartTimer8(TD_TWI_Timeout,40);
			return;
		}
		if(Timer8Stopp(TD_TWI_Timeout)){	// 
    fcd8:	80 91 d3 04 	lds	r24, 0x04D3
    fcdc:	0e 94 73 25 	call	0x4ae6	; 0x4ae6 <Timer8Stopp>
    fce0:	88 23       	and	r24, r24
    fce2:	09 f0       	breq	.+2      	; 0xfce6 <TWI_In+0x2a>
    fce4:	4e c0       	rjmp	.+156    	; 0xfd82 <TWI_In+0xc6>
			TWI_Error();
			return;
		}

		if (!(TWCR &(1<<TWINT))) return;
    fce6:	80 91 bc 00 	lds	r24, 0x00BC
    fcea:	87 ff       	sbrs	r24, 7
    fcec:	33 c0       	rjmp	.+102    	; 0xfd54 <TWI_In+0x98>

		switch(TWI_Phase) {
    fcee:	40 91 c3 07 	lds	r20, 0x07C3
    fcf2:	84 2f       	mov	r24, r20
    fcf4:	90 e0       	ldi	r25, 0x00	; 0
    fcf6:	fc 01       	movw	r30, r24
    fcf8:	31 97       	sbiw	r30, 0x01	; 1
    fcfa:	e1 31       	cpi	r30, 0x11	; 17
    fcfc:	f1 05       	cpc	r31, r1
    fcfe:	08 f4       	brcc	.+2      	; 0xfd02 <TWI_In+0x46>
    fd00:	46 c0       	rjmp	.+140    	; 0xfd8e <TWI_In+0xd2>
			Tm_WDay = SetWeekday(Tm_Year, Tm_Mon, Tm_MDay);
			StartTimer8(TD_TWI_Poll, 49);
			TWI_Phase = 0xFF;
			break;
		}
		TWI_Phase++;
    fd02:	4f 5f       	subi	r20, 0xFF	; 255
    fd04:	40 93 c3 07 	sts	0x07C3, r20
	}//Timer8Stopp(TD_TWI)

	if( Timer16Stopp(TD_RTC_Check) && (TWI_Phase == PCF_START) ){
    fd08:	00 91 d4 04 	lds	r16, 0x04D4
    fd0c:	80 2f       	mov	r24, r16
    fd0e:	0e 94 96 25 	call	0x4b2c	; 0x4b2c <Timer16Stopp>
    fd12:	88 23       	and	r24, r24
    fd14:	f9 f0       	breq	.+62     	; 0xfd54 <TWI_In+0x98>
    fd16:	80 91 c3 07 	lds	r24, 0x07C3
    fd1a:	88 23       	and	r24, r24
    fd1c:	d9 f4       	brne	.+54     	; 0xfd54 <TWI_In+0x98>
		StartTimer16(TD_RTC_Check, 300);
    fd1e:	80 2f       	mov	r24, r16
    fd20:	6c e2       	ldi	r22, 0x2C	; 44
    fd22:	71 e0       	ldi	r23, 0x01	; 1
    fd24:	0e 94 5a 24 	call	0x48b4	; 0x48b4 <StartTimer16>
		if(RTC_Check() || PFC_Stop_bit){
    fd28:	0e 94 6f 2e 	call	0x5cde	; 0x5cde <RTC_Check>
    fd2c:	88 23       	and	r24, r24
    fd2e:	b1 f4       	brne	.+44     	; 0xfd5c <TWI_In+0xa0>
    fd30:	80 91 d5 04 	lds	r24, 0x04D5
    fd34:	88 23       	and	r24, r24
    fd36:	91 f4       	brne	.+36     	; 0xfd5c <TWI_In+0xa0>
			// RTC
			SetDateTime(TrueTime_Year, TrueTime_Mon, TrueTime_MDay, TrueTime_WDay, TrueTime_Hour, TrueTime_Min, TrueTime_Sec);
		}
		else RTC_GetTrueTime();
    fd38:	0e 94 26 2e 	call	0x5c4c	; 0x5c4c <RTC_GetTrueTime>
    fd3c:	1f c0       	rjmp	.+62     	; 0xfd7c <TWI_In+0xc0>
TWI_In(void)
{
	if(Timer8Stopp(TD_TWI_Poll)){

		if (TWI_Phase == PCF_START){
			StartTWI();		// Send Start
    fd3e:	84 ea       	ldi	r24, 0xA4	; 164
    fd40:	80 93 bc 00 	sts	0x00BC, r24
			TWI_Phase++;
    fd44:	81 e0       	ldi	r24, 0x01	; 1
    fd46:	80 93 c3 07 	sts	0x07C3, r24
			StartTimer8(TD_TWI_Timeout,40);
    fd4a:	80 91 d3 04 	lds	r24, 0x04D3
    fd4e:	68 e2       	ldi	r22, 0x28	; 40
    fd50:	0e 94 1f 24 	call	0x483e	; 0x483e <StartTimer8>
		}
		else RTC_GetTrueTime();

		RTC_Summer_Time();
	}
}
    fd54:	0f 91       	pop	r16
    fd56:	ef 90       	pop	r14
    fd58:	cf 90       	pop	r12
    fd5a:	08 95       	ret

	if( Timer16Stopp(TD_RTC_Check) && (TWI_Phase == PCF_START) ){
		StartTimer16(TD_RTC_Check, 300);
		if(RTC_Check() || PFC_Stop_bit){
			// RTC
			SetDateTime(TrueTime_Year, TrueTime_Mon, TrueTime_MDay, TrueTime_WDay, TrueTime_Hour, TrueTime_Min, TrueTime_Sec);
    fd5c:	80 91 c1 07 	lds	r24, 0x07C1
    fd60:	60 91 15 09 	lds	r22, 0x0915
    fd64:	40 91 56 06 	lds	r20, 0x0656
    fd68:	20 91 5e 0b 	lds	r18, 0x0B5E
    fd6c:	00 91 d8 05 	lds	r16, 0x05D8
    fd70:	e0 90 16 09 	lds	r14, 0x0916
    fd74:	c0 90 14 09 	lds	r12, 0x0914
    fd78:	0e 94 72 2d 	call	0x5ae4	; 0x5ae4 <SetDateTime>
		}
		else RTC_GetTrueTime();

		RTC_Summer_Time();
    fd7c:	0e 94 19 7e 	call	0xfc32	; 0xfc32 <RTC_Summer_Time>
    fd80:	e9 cf       	rjmp	.-46     	; 0xfd54 <TWI_In+0x98>
			Tm_Mon = DecodBCD(TWDR & 0b00011111);
			if(Tm_Mon > 12) Tm_Mon = 0;	//
			RunTWI();		//NACK
			break;
		case PCF_Year:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_NACK){ TWI_Error(); return;}
    fd82:	0e 94 a7 2c 	call	0x594e	; 0x594e <TWI_Error>
		}
		else RTC_GetTrueTime();

		RTC_Summer_Time();
	}
}
    fd86:	0f 91       	pop	r16
    fd88:	ef 90       	pop	r14
    fd8a:	cf 90       	pop	r12
    fd8c:	08 95       	ret
			return;
		}

		if (!(TWCR &(1<<TWINT))) return;

		switch(TWI_Phase) {
    fd8e:	ea 5a       	subi	r30, 0xAA	; 170
    fd90:	fe 4f       	sbci	r31, 0xFE	; 254
    fd92:	ee 0f       	add	r30, r30
    fd94:	ff 1f       	adc	r31, r31
    fd96:	05 90       	lpm	r0, Z+
    fd98:	f4 91       	lpm	r31, Z+
    fd9a:	e0 2d       	mov	r30, r0
    fd9c:	19 94       	eijmp
		case PFC_ACKN:
			AcknTWI();
			break;

		case PCF_Se:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
    fd9e:	80 91 b9 00 	lds	r24, 0x00B9
    fda2:	88 7f       	andi	r24, 0xF8	; 248
    fda4:	80 35       	cpi	r24, 0x50	; 80
    fda6:	69 f7       	brne	.-38     	; 0xfd82 <TWI_In+0xc6>
			Tm_Sec = DecodBCD(TWDR & 0b01111111);	// exclude ST bit
    fda8:	20 91 bb 00 	lds	r18, 0x00BB
    fdac:	82 2f       	mov	r24, r18
    fdae:	8f 77       	andi	r24, 0x7F	; 127
    fdb0:	82 95       	swap	r24
    fdb2:	8f 70       	andi	r24, 0x0F	; 15
    fdb4:	3a e0       	ldi	r19, 0x0A	; 10
    fdb6:	83 9f       	mul	r24, r19
    fdb8:	c0 01       	movw	r24, r0
    fdba:	11 24       	eor	r1, r1
    fdbc:	2f 70       	andi	r18, 0x0F	; 15
    fdbe:	28 0f       	add	r18, r24
    fdc0:	20 93 f7 06 	sts	0x06F7, r18
			PFC_Stop_bit = TWDR & 0b10000000;
    fdc4:	80 91 bb 00 	lds	r24, 0x00BB
    fdc8:	80 78       	andi	r24, 0x80	; 128
    fdca:	80 93 d5 04 	sts	0x04D5, r24
/*			if(PFC_Stop_bit) NoTickCnt++;
			else NoTickCnt=0;*/
			AcknTWI();
    fdce:	84 ec       	ldi	r24, 0xC4	; 196
    fdd0:	80 93 bc 00 	sts	0x00BC, r24
    fdd4:	96 cf       	rjmp	.-212    	; 0xfd02 <TWI_In+0x46>

		case PCF_REAP_START1:
			StartTWI();
			break;
		case PCF_CHECK_REAP_START1:
			if( (TWSR & 0b11111000) != TWI_STATUS_RP_START){ TWI_Error(); return;}
    fdd6:	80 91 b9 00 	lds	r24, 0x00B9
    fdda:	88 7f       	andi	r24, 0xF8	; 248
    fddc:	80 31       	cpi	r24, 0x10	; 16
    fdde:	89 f6       	brne	.-94     	; 0xfd82 <TWI_In+0xc6>
    fde0:	48 e0       	ldi	r20, 0x08	; 8
			else TWI_Phase++;

		case PCF_SLA_R:
			SLA_R(PCF_SLA);
    fde2:	81 ed       	ldi	r24, 0xD1	; 209
    fde4:	80 93 bb 00 	sts	0x00BB, r24
			RunTWI();
    fde8:	84 e8       	ldi	r24, 0x84	; 132
    fdea:	80 93 bc 00 	sts	0x00BC, r24
    fdee:	89 cf       	rjmp	.-238    	; 0xfd02 <TWI_In+0x46>
		case PCF_Addr:
			TWDR = AddrSec;
			RunTWI();
			break;
		case PCF_CHECK_Addr:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATATX_ACK){ TWI_Error(); return;}
    fdf0:	80 91 b9 00 	lds	r24, 0x00B9
    fdf4:	88 7f       	andi	r24, 0xF8	; 248
    fdf6:	88 32       	cpi	r24, 0x28	; 40
    fdf8:	21 f6       	brne	.-120    	; 0xfd82 <TWI_In+0xc6>
    fdfa:	46 e0       	ldi	r20, 0x06	; 6
			else TWI_Phase++;

		case PCF_REAP_START1:
			StartTWI();
    fdfc:	84 ea       	ldi	r24, 0xA4	; 164
    fdfe:	80 93 bc 00 	sts	0x00BC, r24
    fe02:	7f cf       	rjmp	.-258    	; 0xfd02 <TWI_In+0x46>
		case PCF_SLA_W:
			SLA_W(PCF_SLA);
			RunTWI();
			break;
		case PCF_CHECK_SLA_W:
			if( (TWSR & 0b11111000) != TWI_STATUS_SLAW_ACK){ TWI_Error(); return;}
    fe04:	80 91 b9 00 	lds	r24, 0x00B9
    fe08:	88 7f       	andi	r24, 0xF8	; 248
    fe0a:	88 31       	cpi	r24, 0x18	; 24
    fe0c:	09 f0       	breq	.+2      	; 0xfe10 <TWI_In+0x154>
    fe0e:	b9 cf       	rjmp	.-142    	; 0xfd82 <TWI_In+0xc6>
    fe10:	44 e0       	ldi	r20, 0x04	; 4
			else TWI_Phase++;

		case PCF_Addr:
			TWDR = AddrSec;
    fe12:	10 92 bb 00 	sts	0x00BB, r1
			RunTWI();
    fe16:	84 e8       	ldi	r24, 0x84	; 132
    fe18:	80 93 bc 00 	sts	0x00BC, r24
    fe1c:	72 cf       	rjmp	.-284    	; 0xfd02 <TWI_In+0x46>
		if (!(TWCR &(1<<TWINT))) return;

		switch(TWI_Phase) {
		
		case PCF_CHECK_START:
			if( (TWSR & 0b11111000) != TWI_STATUS_START){ TWI_Error(); return;}
    fe1e:	80 91 b9 00 	lds	r24, 0x00B9
    fe22:	88 7f       	andi	r24, 0xF8	; 248
    fe24:	88 30       	cpi	r24, 0x08	; 8
    fe26:	09 f0       	breq	.+2      	; 0xfe2a <TWI_In+0x16e>
    fe28:	ac cf       	rjmp	.-168    	; 0xfd82 <TWI_In+0xc6>
    fe2a:	42 e0       	ldi	r20, 0x02	; 2
			else TWI_Phase++;
			
		case PCF_SLA_W:
			SLA_W(PCF_SLA);
    fe2c:	80 ed       	ldi	r24, 0xD0	; 208
    fe2e:	80 93 bb 00 	sts	0x00BB, r24
			RunTWI();
    fe32:	84 e8       	ldi	r24, 0x84	; 132
    fe34:	80 93 bc 00 	sts	0x00BC, r24
    fe38:	64 cf       	rjmp	.-312    	; 0xfd02 <TWI_In+0x46>
		case PCF_SLA_R:
			SLA_R(PCF_SLA);
			RunTWI();
			break;
		case PCF_CHECK_SLA_R:
			if( (TWSR & 0b11111000) != TWI_STATUS_SLAR_ACK){ TWI_Error(); return;}
    fe3a:	80 91 b9 00 	lds	r24, 0x00B9
    fe3e:	88 7f       	andi	r24, 0xF8	; 248
    fe40:	80 34       	cpi	r24, 0x40	; 64
    fe42:	09 f0       	breq	.+2      	; 0xfe46 <TWI_In+0x18a>
    fe44:	9e cf       	rjmp	.-196    	; 0xfd82 <TWI_In+0xc6>
    fe46:	4a e0       	ldi	r20, 0x0A	; 10
    fe48:	c2 cf       	rjmp	.-124    	; 0xfdce <TWI_In+0x112>
			Tm_Mon = DecodBCD(TWDR & 0b00011111);
			if(Tm_Mon > 12) Tm_Mon = 0;	//
			RunTWI();		//NACK
			break;
		case PCF_Year:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_NACK){ TWI_Error(); return;}
    fe4a:	80 91 b9 00 	lds	r24, 0x00B9
    fe4e:	88 7f       	andi	r24, 0xF8	; 248
    fe50:	88 35       	cpi	r24, 0x58	; 88
    fe52:	09 f0       	breq	.+2      	; 0xfe56 <TWI_In+0x19a>
    fe54:	96 cf       	rjmp	.-212    	; 0xfd82 <TWI_In+0xc6>
			Tm_Year = DecodBCD(TWDR);
    fe56:	80 91 bb 00 	lds	r24, 0x00BB

// ~~~~~~~~~~~~~~~~~~
uint8_t
DecodBCD(uint8_t BCD)
{
	return 10*(BCD>>4)+(BCD&0x0F);
    fe5a:	28 2f       	mov	r18, r24
    fe5c:	22 95       	swap	r18
    fe5e:	2f 70       	andi	r18, 0x0F	; 15
    fe60:	9a e0       	ldi	r25, 0x0A	; 10
    fe62:	29 9f       	mul	r18, r25
    fe64:	90 01       	movw	r18, r0
    fe66:	11 24       	eor	r1, r1
    fe68:	8f 70       	andi	r24, 0x0F	; 15
    fe6a:	82 0f       	add	r24, r18
    fe6c:	80 93 de 05 	sts	0x05DE, r24
			StopTWI();
    fe70:	94 e9       	ldi	r25, 0x94	; 148
    fe72:	90 93 bc 00 	sts	0x00BC, r25
			Tm_WDay = SetWeekday(Tm_Year, Tm_Mon, Tm_MDay);
    fe76:	60 91 cc 07 	lds	r22, 0x07CC
    fe7a:	40 91 5f 0b 	lds	r20, 0x0B5F
    fe7e:	0e 94 0a 2d 	call	0x5a14	; 0x5a14 <SetWeekday>
    fe82:	80 93 57 06 	sts	0x0657, r24
			StartTimer8(TD_TWI_Poll, 49);
    fe86:	80 2f       	mov	r24, r16
    fe88:	61 e3       	ldi	r22, 0x31	; 49
    fe8a:	0e 94 1f 24 	call	0x483e	; 0x483e <StartTimer8>
    fe8e:	4f ef       	ldi	r20, 0xFF	; 255
    fe90:	38 cf       	rjmp	.-400    	; 0xfd02 <TWI_In+0x46>
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
			Tm_MDay = DecodBCD(TWDR & 0b00111111);
			AcknTWI();
			break;
		case PCF_Mo:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
    fe92:	80 91 b9 00 	lds	r24, 0x00B9
    fe96:	88 7f       	andi	r24, 0xF8	; 248
    fe98:	80 35       	cpi	r24, 0x50	; 80
    fe9a:	09 f0       	breq	.+2      	; 0xfe9e <TWI_In+0x1e2>
    fe9c:	72 cf       	rjmp	.-284    	; 0xfd82 <TWI_In+0xc6>
			Tm_Mon = DecodBCD(TWDR & 0b00011111);
    fe9e:	80 91 bb 00 	lds	r24, 0x00BB
    fea2:	28 2f       	mov	r18, r24
    fea4:	2f 71       	andi	r18, 0x1F	; 31
    fea6:	22 95       	swap	r18
    fea8:	2f 70       	andi	r18, 0x0F	; 15
    feaa:	9a e0       	ldi	r25, 0x0A	; 10
    feac:	29 9f       	mul	r18, r25
    feae:	90 01       	movw	r18, r0
    feb0:	11 24       	eor	r1, r1
    feb2:	8f 70       	andi	r24, 0x0F	; 15
    feb4:	82 0f       	add	r24, r18
    feb6:	80 93 cc 07 	sts	0x07CC, r24
			if(Tm_Mon > 12) Tm_Mon = 0;	//
    feba:	8d 30       	cpi	r24, 0x0D	; 13
    febc:	10 f0       	brcs	.+4      	; 0xfec2 <TWI_In+0x206>
    febe:	10 92 cc 07 	sts	0x07CC, r1
			RunTWI();		//NACK
    fec2:	84 e8       	ldi	r24, 0x84	; 132
    fec4:	80 93 bc 00 	sts	0x00BC, r24
    fec8:	1c cf       	rjmp	.-456    	; 0xfd02 <TWI_In+0x46>
			TWDR;
			//Tm_WDay = DecodBCD(TWDR & 0b00000111); Ignore 
			AcknTWI();
			break;
		case PCF_MDay:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
    feca:	80 91 b9 00 	lds	r24, 0x00B9
    fece:	88 7f       	andi	r24, 0xF8	; 248
    fed0:	80 35       	cpi	r24, 0x50	; 80
    fed2:	09 f0       	breq	.+2      	; 0xfed6 <TWI_In+0x21a>
    fed4:	56 cf       	rjmp	.-340    	; 0xfd82 <TWI_In+0xc6>
			Tm_MDay = DecodBCD(TWDR & 0b00111111);
    fed6:	20 91 bb 00 	lds	r18, 0x00BB
    feda:	82 2f       	mov	r24, r18
    fedc:	8f 73       	andi	r24, 0x3F	; 63
    fede:	82 95       	swap	r24
    fee0:	8f 70       	andi	r24, 0x0F	; 15
    fee2:	3a e0       	ldi	r19, 0x0A	; 10
    fee4:	83 9f       	mul	r24, r19
    fee6:	c0 01       	movw	r24, r0
    fee8:	11 24       	eor	r1, r1
    feea:	2f 70       	andi	r18, 0x0F	; 15
    feec:	28 0f       	add	r18, r24
    feee:	20 93 5f 0b 	sts	0x0B5F, r18
			AcknTWI();
    fef2:	84 ec       	ldi	r24, 0xC4	; 196
    fef4:	80 93 bc 00 	sts	0x00BC, r24
    fef8:	04 cf       	rjmp	.-504    	; 0xfd02 <TWI_In+0x46>
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
			Tm_Hour = DecodBCD(TWDR & 0b00111111);
			AcknTWI();
			break;
		case PCF_WDay:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
    fefa:	80 91 b9 00 	lds	r24, 0x00B9
    fefe:	88 7f       	andi	r24, 0xF8	; 248
    ff00:	80 35       	cpi	r24, 0x50	; 80
    ff02:	09 f0       	breq	.+2      	; 0xff06 <TWI_In+0x24a>
    ff04:	3e cf       	rjmp	.-388    	; 0xfd82 <TWI_In+0xc6>
			TWDR;
    ff06:	80 91 bb 00 	lds	r24, 0x00BB
			//Tm_WDay = DecodBCD(TWDR & 0b00000111); Ignore 
			AcknTWI();
    ff0a:	84 ec       	ldi	r24, 0xC4	; 196
    ff0c:	80 93 bc 00 	sts	0x00BC, r24
    ff10:	f8 ce       	rjmp	.-528    	; 0xfd02 <TWI_In+0x46>
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
			Tm_Min = DecodBCD(TWDR & 0b01111111);
			AcknTWI();
			break;
		case PCF_Ho:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
    ff12:	80 91 b9 00 	lds	r24, 0x00B9
    ff16:	88 7f       	andi	r24, 0xF8	; 248
    ff18:	80 35       	cpi	r24, 0x50	; 80
    ff1a:	09 f0       	breq	.+2      	; 0xff1e <TWI_In+0x262>
    ff1c:	32 cf       	rjmp	.-412    	; 0xfd82 <TWI_In+0xc6>
			Tm_Hour = DecodBCD(TWDR & 0b00111111);
    ff1e:	20 91 bb 00 	lds	r18, 0x00BB
    ff22:	82 2f       	mov	r24, r18
    ff24:	8f 73       	andi	r24, 0x3F	; 63
    ff26:	82 95       	swap	r24
    ff28:	8f 70       	andi	r24, 0x0F	; 15
    ff2a:	3a e0       	ldi	r19, 0x0A	; 10
    ff2c:	83 9f       	mul	r24, r19
    ff2e:	c0 01       	movw	r24, r0
    ff30:	11 24       	eor	r1, r1
    ff32:	2f 70       	andi	r18, 0x0F	; 15
    ff34:	28 0f       	add	r18, r24
    ff36:	20 93 c1 05 	sts	0x05C1, r18
			AcknTWI();
    ff3a:	84 ec       	ldi	r24, 0xC4	; 196
    ff3c:	80 93 bc 00 	sts	0x00BC, r24
    ff40:	e0 ce       	rjmp	.-576    	; 0xfd02 <TWI_In+0x46>
/*			if(PFC_Stop_bit) NoTickCnt++;
			else NoTickCnt=0;*/
			AcknTWI();
			break;
		case PCF_Mi:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
    ff42:	80 91 b9 00 	lds	r24, 0x00B9
    ff46:	88 7f       	andi	r24, 0xF8	; 248
    ff48:	80 35       	cpi	r24, 0x50	; 80
    ff4a:	09 f0       	breq	.+2      	; 0xff4e <TWI_In+0x292>
    ff4c:	1a cf       	rjmp	.-460    	; 0xfd82 <TWI_In+0xc6>
			Tm_Min = DecodBCD(TWDR & 0b01111111);
    ff4e:	20 91 bb 00 	lds	r18, 0x00BB
    ff52:	82 2f       	mov	r24, r18
    ff54:	8f 77       	andi	r24, 0x7F	; 127
    ff56:	82 95       	swap	r24
    ff58:	8f 70       	andi	r24, 0x0F	; 15
    ff5a:	3a e0       	ldi	r19, 0x0A	; 10
    ff5c:	83 9f       	mul	r24, r19
    ff5e:	c0 01       	movw	r24, r0
    ff60:	11 24       	eor	r1, r1
    ff62:	2f 70       	andi	r18, 0x0F	; 15
    ff64:	28 0f       	add	r18, r24
    ff66:	20 93 51 06 	sts	0x0651, r18
			AcknTWI();
    ff6a:	84 ec       	ldi	r24, 0xC4	; 196
    ff6c:	80 93 bc 00 	sts	0x00BC, r24
    ff70:	c8 ce       	rjmp	.-624    	; 0xfd02 <TWI_In+0x46>

0000ff72 <TimeInit>:

// ~~~~~~~~
void
WdtOn(void)
{
	wdt_reset();
    ff72:	a8 95       	wdr
	wdt_enable(WDTO_2S);
    ff74:	2f e0       	ldi	r18, 0x0F	; 15
    ff76:	88 e1       	ldi	r24, 0x18	; 24
    ff78:	90 e0       	ldi	r25, 0x00	; 0
    ff7a:	0f b6       	in	r0, 0x3f	; 63
    ff7c:	f8 94       	cli
    ff7e:	a8 95       	wdr
    ff80:	80 93 60 00 	sts	0x0060, r24
    ff84:	0f be       	out	0x3f, r0	; 63
    ff86:	20 93 60 00 	sts	0x0060, r18

	// WDT
	WdtOn();

	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TCCR1A = 0;
    ff8a:	10 92 80 00 	sts	0x0080, r1
		TCCR1B = (((~(1<<WGM13) |(1<<WGM12)) &~(1<<CS12)) |(1<<CS11)) &~(1<<CS10);
    ff8e:	8a ee       	ldi	r24, 0xEA	; 234
    ff90:	80 93 81 00 	sts	0x0081, r24
		OCR1A = 20000;
    ff94:	80 e2       	ldi	r24, 0x20	; 32
    ff96:	9e e4       	ldi	r25, 0x4E	; 78
    ff98:	90 93 89 00 	sts	0x0089, r25
    ff9c:	80 93 88 00 	sts	0x0088, r24
		TCC0.CTRLE = ~TC0_BYTEM_bm;
	#endif
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__)
		TIMSK |=(1<<OCIE1A);
	#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TIMSK1 |=(1<<OCIE1A);
    ffa0:	80 91 6f 00 	lds	r24, 0x006F
    ffa4:	82 60       	ori	r24, 0x02	; 2
    ffa6:	80 93 6f 00 	sts	0x006F, r24
    ffaa:	80 e0       	ldi	r24, 0x00	; 0
    ffac:	90 e0       	ldi	r25, 0x00	; 0
	#endif

	// Program timers (10 ms)
	uint8_t i;
	for (i=0; i<sizeof(Timer8Flg); i++)
		Timer8Flg[i] = 0xFF;
    ffae:	2f ef       	ldi	r18, 0xFF	; 255
    ffb0:	fc 01       	movw	r30, r24
    ffb2:	ef 54       	subi	r30, 0x4F	; 79
    ffb4:	fb 4f       	sbci	r31, 0xFB	; 251
    ffb6:	20 83       	st	Z, r18
    ffb8:	01 96       	adiw	r24, 0x01	; 1
		TCC0.INTCTRLB = 0;
	#endif

	// Program timers (10 ms)
	uint8_t i;
	for (i=0; i<sizeof(Timer8Flg); i++)
    ffba:	8c 30       	cpi	r24, 0x0C	; 12
    ffbc:	91 05       	cpc	r25, r1
    ffbe:	c1 f7       	brne	.-16     	; 0xffb0 <TimeInit+0x3e>
    ffc0:	80 e0       	ldi	r24, 0x00	; 0
    ffc2:	90 e0       	ldi	r25, 0x00	; 0
		Timer8Flg[i] = 0xFF;
	for (i=0; i<sizeof(Timer16Flg); i++)
		Timer16Flg[i] = 0xFF;
    ffc4:	3f ef       	ldi	r19, 0xFF	; 255
    ffc6:	fc 01       	movw	r30, r24
    ffc8:	e3 54       	subi	r30, 0x43	; 67
    ffca:	fb 4f       	sbci	r31, 0xFB	; 251
    ffcc:	2f ef       	ldi	r18, 0xFF	; 255
    ffce:	30 83       	st	Z, r19
    ffd0:	01 96       	adiw	r24, 0x01	; 1

	// Program timers (10 ms)
	uint8_t i;
	for (i=0; i<sizeof(Timer8Flg); i++)
		Timer8Flg[i] = 0xFF;
	for (i=0; i<sizeof(Timer16Flg); i++)
    ffd2:	8d 30       	cpi	r24, 0x0D	; 13
    ffd4:	91 05       	cpc	r25, r1
    ffd6:	b9 f7       	brne	.-18     	; 0xffc6 <TimeInit+0x54>
		Timer16Flg[i] = 0xFF;
	for (i=0; i<sizeof(Timer32Flg); i++)
		Timer32Flg[i] = 0xFF;
    ffd8:	20 93 ca 04 	sts	0x04CA, r18
    ffdc:	20 93 cb 04 	sts	0x04CB, r18
    ffe0:	20 93 cc 04 	sts	0x04CC, r18
    ffe4:	20 93 cd 04 	sts	0x04CD, r18
    ffe8:	20 93 ce 04 	sts	0x04CE, r18
    ffec:	20 93 cf 04 	sts	0x04CF, r18
    fff0:	8d e9       	ldi	r24, 0x9D	; 157
    fff2:	91 e0       	ldi	r25, 0x01	; 1
    fff4:	0e 94 1d 8e 	call	0x11c3a	; 0x11c3a <__eerd_byte_m2560>

	// 1 s
	Timer1min = erb(&Timer1min_EE);
    fff8:	80 93 b0 06 	sts	0x06B0, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    fffc:	8e e9       	ldi	r24, 0x9E	; 158
    fffe:	91 e0       	ldi	r25, 0x01	; 1
   10000:	0e 94 2b 8e 	call	0x11c56	; 0x11c56 <__eerd_word_m2560>
	Timer1hour = erw(&Timer1hour_EE);
   10004:	90 93 6c 0c 	sts	0x0C6C, r25
   10008:	80 93 6b 0c 	sts	0x0C6B, r24

	// Application
	#ifdef InitTimer
		StartTimer16(InitTimer, InitTime);
	#endif
}
   1000c:	08 95       	ret

0001000e <MemCheckInit>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
   1000e:	8c e9       	ldi	r24, 0x9C	; 156
   10010:	91 e0       	ldi	r25, 0x01	; 1
   10012:	0e 94 1d 8e 	call	0x11c3a	; 0x11c3a <__eerd_byte_m2560>
// ~~~~~~~~~~~~~~~
void
MemCheckInit(void)
{
//	TD_Mem = Timer32SysAlloc(1);
	if (!erb(&MemCheck_stor.ReprogFlg)) {
   10016:	81 11       	cpse	r24, r1
   10018:	08 95       	ret
		eeprom_write_word(&MemCheck_stor.CRC_Flash_stor, CRC_Flash_calc());
   1001a:	0e 94 1b 23 	call	0x4636	; 0x4636 <CRC_Flash_calc>
   1001e:	bc 01       	movw	r22, r24
   10020:	88 e9       	ldi	r24, 0x98	; 152
   10022:	91 e0       	ldi	r25, 0x01	; 1
   10024:	0e 94 51 8e 	call	0x11ca2	; 0x11ca2 <__eewr_word_m2560>
		eeprom_write_word(&MemCheck_stor.CRC_EEPROM_stor, CRC_EEPROM_calc());
   10028:	0e 94 35 23 	call	0x466a	; 0x466a <CRC_EEPROM_calc>
   1002c:	bc 01       	movw	r22, r24
   1002e:	8a e9       	ldi	r24, 0x9A	; 154
   10030:	91 e0       	ldi	r25, 0x01	; 1
   10032:	0e 94 51 8e 	call	0x11ca2	; 0x11ca2 <__eewr_word_m2560>
		eeprom_write_byte(&MemCheck_stor.ReprogFlg, 1);
   10036:	8c e9       	ldi	r24, 0x9C	; 156
   10038:	91 e0       	ldi	r25, 0x01	; 1
   1003a:	61 e0       	ldi	r22, 0x01	; 1
   1003c:	0e 94 3b 8e 	call	0x11c76	; 0x11c76 <__eewr_byte_m2560>
   10040:	08 95       	ret

00010042 <main>:
}

// ~~~~~~~
int
main(void)
{
   10042:	cf 93       	push	r28
   10044:	df 93       	push	r29
	TimeInit();
   10046:	0e 94 b9 7f 	call	0xff72	; 0xff72 <TimeInit>
	TimersInc();
   1004a:	0e 94 ff 56 	call	0xadfe	; 0xadfe <TimersInc>
	MemCheckInit();
   1004e:	0e 94 07 80 	call	0x1000e	; 0x1000e <MemCheckInit>
	LED_Init();
   10052:	0e 94 48 2f 	call	0x5e90	; 0x5e90 <LED_Init>

	LCD_Init();
   10056:	0e 94 68 7d 	call	0xfad0	; 0xfad0 <LCD_Init>

	KeypadInit();
   1005a:	0e 94 f9 44 	call	0x89f2	; 0x89f2 <KeypadInit>
	MenuInit();
   1005e:	0e 94 47 46 	call	0x8c8e	; 0x8c8e <MenuInit>
InterruInit(void)
{
	#ifdef PMIC
		PMIC.CTRL = (uint8_t)(~PMIC_RREN_bm &~PMIC_IVSEL_bm) |PMIC_HILVLEN_bm |PMIC_MEDLVLEN_bm |PMIC_LOLVLEN_bm;
	#endif
	sei();
   10062:	78 94       	sei
	InterruInit();
	DigitInit();
   10064:	0e 94 6a 47 	call	0x8ed4	; 0x8ed4 <DI_Init>
   10068:	0e 94 79 48 	call	0x90f2	; 0x90f2 <DO_Init>
	HSC_Init();

	AI_Init();
   1006c:	0e 94 8e 48 	call	0x911c	; 0x911c <AI_Init>

	SPI_Init();
   10070:	0e 94 d0 29 	call	0x53a0	; 0x53a0 <SPI_Init>

	PWM_Init();
   10074:	0e 94 9c 27 	call	0x4f38	; 0x4f38 <PWM_Init>
	TWI_Init();
   10078:	0e 94 8b 2c 	call	0x5916	; 0x5916 <TWI_Init>
#ifdef QslRD
	SlaveRD_Init();
#endif

	do {
		TimersInc();
   1007c:	0e 94 ff 56 	call	0xadfe	; 0xadfe <TimersInc>
		wdt_reset();
   10080:	a8 95       	wdr
		DigitIn();
   10082:	0e 94 ee 5a 	call	0xb5dc	; 0xb5dc <DigitIn>
		TWI_In();
   10086:	0e 94 5e 7e 	call	0xfcbc	; 0xfcbc <TWI_In>
	StopTWI();
	TWI_Phase = PCF_START;
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t RTC_Ready(void){
	if(TWI_Phase == PCF_START) return 1;
   1008a:	80 91 c3 07 	lds	r24, 0x07C3
   1008e:	88 23       	and	r24, r24
   10090:	11 f4       	brne	.+4      	; 0x10096 <main+0x54>
		if(RTC_Ready()) RTC_GetTrueTime();
   10092:	0e 94 26 2e 	call	0x5c4c	; 0x5c4c <RTC_GetTrueTime>
		LCD_Sweep();
   10096:	0e 94 af 6c 	call	0xd95e	; 0xd95e <LCD_Sweep>
	#ifdef TerIdx
	} while(ThermInit(AnalogIn()-TerIdx) || !RTC_Ready());
	#elif !defined ADC_Miss
		AnalogIn();
   1009a:	0e 94 9f 48 	call	0x913e	; 0x913e <AnalogIn>
	} while( (ADC_OK&&ThermInit(ADC_In())) || !RTC_Ready() );
   1009e:	80 91 2b 09 	lds	r24, 0x092B
   100a2:	90 91 2c 09 	lds	r25, 0x092C
   100a6:	89 2b       	or	r24, r25
   100a8:	69 f4       	brne	.+26     	; 0x100c4 <main+0x82>
   100aa:	80 91 b4 07 	lds	r24, 0x07B4
   100ae:	90 91 b5 07 	lds	r25, 0x07B5
   100b2:	89 2b       	or	r24, r25
   100b4:	39 f4       	brne	.+14     	; 0x100c4 <main+0x82>
   100b6:	80 91 f8 06 	lds	r24, 0x06F8
   100ba:	90 91 f9 06 	lds	r25, 0x06F9
   100be:	89 2b       	or	r24, r25
   100c0:	09 f4       	brne	.+2      	; 0x100c4 <main+0x82>
   100c2:	6c c0       	rjmp	.+216    	; 0x1019c <main+0x15a>
   100c4:	80 91 c3 07 	lds	r24, 0x07C3
   100c8:	88 23       	and	r24, r24
   100ca:	c1 f6       	brne	.-80     	; 0x1007c <main+0x3a>
	#else
	} while((AnalogIn()!=AI_Reg-1) || !RTC_Ready());
	#endif

	MemCheckMsg();
   100cc:	0e 94 de 59 	call	0xb3bc	; 0xb3bc <MemCheckMsg>

	ApplInit();
   100d0:	0e 94 ad 4a 	call	0x955a	; 0x955a <ApplInit>

	USART_Init();
   100d4:	0e 94 14 7d 	call	0xfa28	; 0xfa28 <USART_Init>
	ScanCycleInit();
   100d8:	0e 94 e0 26 	call	0x4dc0	; 0x4dc0 <ScanCycleInit>
	if(TimerAllocError()) ShowMsg(&MsgErr41);
   100dc:	0e 94 c4 26 	call	0x4d88	; 0x4d88 <TimerAllocError>
   100e0:	88 23       	and	r24, r24
   100e2:	09 f0       	breq	.+2      	; 0x100e6 <main+0xa4>
   100e4:	63 c0       	rjmp	.+198    	; 0x101ac <main+0x16a>

// ~~~~~~~~~~~~~~~~
void
Therm_ADC_Off(void)
{
	for (uint8_t i=0; i<TerReg; Temperature[i++]=ADC_Off_Mark);
   100e6:	c1 e0       	ldi	r28, 0x01	; 1
   100e8:	d0 e8       	ldi	r29, 0x80	; 128
   100ea:	12 c0       	rjmp	.+36     	; 0x10110 <main+0xce>
			if(ADC_Work&&ADC_Phase==ADC_OFF) {
				Therm_ADC_Off();
				ShowMsg(&MsgErr21);
				ADC_Work = 0;
			}
			ThermChan(ADC_In());
   100ec:	0e 94 27 28 	call	0x504e	; 0x504e <ADC_In>
   100f0:	0e 94 10 5a 	call	0xb420	; 0xb420 <ThermChan>
		#endif
		ThermExt();
		TWI_In();
   100f4:	0e 94 5e 7e 	call	0xfcbc	; 0xfcbc <TWI_In>

		USART_Cycle();
   100f8:	0e 94 89 7b 	call	0xf712	; 0xf712 <USART_Cycle>
#ifdef QslRD
		SlaveRD();
#endif
		ApplCycle();
   100fc:	0e 94 e4 58 	call	0xb1c8	; 0xb1c8 <ApplCycle>
		
		LCD_Sweep();
   10100:	0e 94 af 6c 	call	0xd95e	; 0xd95e <LCD_Sweep>
		DigitOut();
   10104:	0e 94 2a 48 	call	0x9054	; 0x9054 <DigitOut>
		DAC_Out();
		PWM_Out();
   10108:	0e 94 bb 27 	call	0x4f76	; 0x4f76 <PWM_Out>
		#ifdef BACKLIGHT
			LCDBackLightControl();
   1010c:	0e 94 80 31 	call	0x6300	; 0x6300 <LCDBackLightControl>
	USART_Init();
	ScanCycleInit();
	if(TimerAllocError()) ShowMsg(&MsgErr41);

	for(;;) {	
		TimersInc();
   10110:	0e 94 ff 56 	call	0xadfe	; 0xadfe <TimersInc>
		TimeCycle();
   10114:	0e 94 40 27 	call	0x4e80	; 0x4e80 <TimeCycle>
// ~~~~~~~~~~~~~~
static void
KeypadSweep(void)
{
	static T_KeyAct KeyAct[] PROGMEM = KEYS;
	T_KeyAct KA = prp(KeyAct+KeypadIn());
   10118:	0e 94 0c 45 	call	0x8a18	; 0x8a18 <KeypadIn>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
   1011c:	e8 2f       	mov	r30, r24
   1011e:	f0 e0       	ldi	r31, 0x00	; 0
   10120:	ee 0f       	add	r30, r30
   10122:	ff 1f       	adc	r31, r31
   10124:	ee 5e       	subi	r30, 0xEE	; 238
   10126:	f3 4c       	sbci	r31, 0xC3	; 195
   10128:	85 91       	lpm	r24, Z+
   1012a:	94 91       	lpm	r25, Z+
	if(KA){
   1012c:	00 97       	sbiw	r24, 0x00	; 0
   1012e:	31 f0       	breq	.+12     	; 0x1013c <main+0xfa>
		KA();
   10130:	fc 01       	movw	r30, r24
   10132:	19 95       	eicall
		#ifdef BACKLIGHT
			if(BackLightMode == 1){
   10134:	80 91 52 06 	lds	r24, 0x0652
   10138:	81 30       	cpi	r24, 0x01	; 1
   1013a:	59 f1       	breq	.+86     	; 0x10192 <main+0x150>
	for(;;) {	
		TimersInc();
		TimeCycle();

		KeypadSweep();
		DigitIn();
   1013c:	0e 94 ee 5a 	call	0xb5dc	; 0xb5dc <DigitIn>
		HSC_In();
		#ifdef TerIdx
			ThermChan(AnalogIn()-TerIdx);
		#else
			AnalogIn();
   10140:	0e 94 9f 48 	call	0x913e	; 0x913e <AnalogIn>
		#endif
		#if !defined ADC_Miss && !defined TerIdx
			static uint8_t ADC_Work = 1;
			if(ADC_Work&&ADC_Phase==ADC_OFF) {
   10144:	80 91 d8 02 	lds	r24, 0x02D8
   10148:	88 23       	and	r24, r24
   1014a:	81 f2       	breq	.-96     	; 0x100ec <main+0xaa>
   1014c:	80 91 6a 0b 	lds	r24, 0x0B6A
   10150:	84 30       	cpi	r24, 0x04	; 4
   10152:	61 f6       	brne	.-104    	; 0x100ec <main+0xaa>
   10154:	d0 93 46 06 	sts	0x0646, r29
   10158:	c0 93 45 06 	sts	0x0645, r28
   1015c:	d0 93 48 06 	sts	0x0648, r29
   10160:	c0 93 47 06 	sts	0x0647, r28
   10164:	d0 93 4a 06 	sts	0x064A, r29
   10168:	c0 93 49 06 	sts	0x0649, r28
   1016c:	d0 93 4c 06 	sts	0x064C, r29
   10170:	c0 93 4b 06 	sts	0x064B, r28
   10174:	d0 93 4e 06 	sts	0x064E, r29
   10178:	c0 93 4d 06 	sts	0x064D, r28
   1017c:	d0 93 50 06 	sts	0x0650, r29
   10180:	c0 93 4f 06 	sts	0x064F, r28
				Therm_ADC_Off();
				ShowMsg(&MsgErr21);
   10184:	8a e7       	ldi	r24, 0x7A	; 122
   10186:	98 e0       	ldi	r25, 0x08	; 8
   10188:	0e 94 36 46 	call	0x8c6c	; 0x8c6c <ShowMsg>
				ADC_Work = 0;
   1018c:	10 92 d8 02 	sts	0x02D8, r1
   10190:	ad cf       	rjmp	.-166    	; 0x100ec <main+0xaa>
	T_KeyAct KA = prp(KeyAct+KeypadIn());
	if(KA){
		KA();
		#ifdef BACKLIGHT
			if(BackLightMode == 1){
				LCDBackLightOn();
   10192:	0e 94 64 31 	call	0x62c8	; 0x62c8 <LCDBackLightOn>
				LCDBackLightStartTimer();
   10196:	0e 94 19 7d 	call	0xfa32	; 0xfa32 <LCDBackLightStartTimer>
   1019a:	d0 cf       	rjmp	.-96     	; 0x1013c <main+0xfa>
		LCD_Sweep();
	#ifdef TerIdx
	} while(ThermInit(AnalogIn()-TerIdx) || !RTC_Ready());
	#elif !defined ADC_Miss
		AnalogIn();
	} while( (ADC_OK&&ThermInit(ADC_In())) || !RTC_Ready() );
   1019c:	0e 94 27 28 	call	0x504e	; 0x504e <ADC_In>
   101a0:	0e 94 ac 5a 	call	0xb558	; 0xb558 <ThermInit>
   101a4:	88 23       	and	r24, r24
   101a6:	09 f0       	breq	.+2      	; 0x101aa <main+0x168>
   101a8:	69 cf       	rjmp	.-302    	; 0x1007c <main+0x3a>
   101aa:	8c cf       	rjmp	.-232    	; 0x100c4 <main+0x82>

	ApplInit();

	USART_Init();
	ScanCycleInit();
	if(TimerAllocError()) ShowMsg(&MsgErr41);
   101ac:	8f e2       	ldi	r24, 0x2F	; 47
   101ae:	9a e1       	ldi	r25, 0x1A	; 26
   101b0:	0e 94 36 46 	call	0x8c6c	; 0x8c6c <ShowMsg>
   101b4:	98 cf       	rjmp	.-208    	; 0x100e6 <main+0xa4>

000101b6 <EEMEMBackUpOk>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
   101b6:	80 e0       	ldi	r24, 0x00	; 0
   101b8:	90 e0       	ldi	r25, 0x00	; 0
   101ba:	0e 94 1d 8e 	call	0x11c3a	; 0x11c3a <__eerd_byte_m2560>
	uint8_t Month;
	uint8_t Year;
}DateBackUp EEMEM = {0xFF,0xFF,0xFF};

uint8_t EEMEMBackUpOk(void){
	if( (erb(&DateBackUp.Day)==0xFF) || (erb(&DateBackUp.Month)==0xFF) || (erb(&DateBackUp.Year)== 0xFF) ) return 0;
   101be:	8f 3f       	cpi	r24, 0xFF	; 255
   101c0:	81 f0       	breq	.+32     	; 0x101e2 <EEMEMBackUpOk+0x2c>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
   101c2:	81 e0       	ldi	r24, 0x01	; 1
   101c4:	90 e0       	ldi	r25, 0x00	; 0
   101c6:	0e 94 1d 8e 	call	0x11c3a	; 0x11c3a <__eerd_byte_m2560>
	uint8_t Month;
	uint8_t Year;
}DateBackUp EEMEM = {0xFF,0xFF,0xFF};

uint8_t EEMEMBackUpOk(void){
	if( (erb(&DateBackUp.Day)==0xFF) || (erb(&DateBackUp.Month)==0xFF) || (erb(&DateBackUp.Year)== 0xFF) ) return 0;
   101ca:	8f 3f       	cpi	r24, 0xFF	; 255
   101cc:	51 f0       	breq	.+20     	; 0x101e2 <EEMEMBackUpOk+0x2c>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
   101ce:	82 e0       	ldi	r24, 0x02	; 2
   101d0:	90 e0       	ldi	r25, 0x00	; 0
   101d2:	0e 94 1d 8e 	call	0x11c3a	; 0x11c3a <__eerd_byte_m2560>
   101d6:	90 e0       	ldi	r25, 0x00	; 0
   101d8:	8f 3f       	cpi	r24, 0xFF	; 255
   101da:	21 f0       	breq	.+8      	; 0x101e4 <EEMEMBackUpOk+0x2e>
   101dc:	91 e0       	ldi	r25, 0x01	; 1
}DateBackUp EEMEM = {0xFF,0xFF,0xFF};

uint8_t EEMEMBackUpOk(void){
	if( (erb(&DateBackUp.Day)==0xFF) || (erb(&DateBackUp.Month)==0xFF) || (erb(&DateBackUp.Year)== 0xFF) ) return 0;
	else return 1;
}
   101de:	89 2f       	mov	r24, r25
   101e0:	08 95       	ret
	uint8_t Month;
	uint8_t Year;
}DateBackUp EEMEM = {0xFF,0xFF,0xFF};

uint8_t EEMEMBackUpOk(void){
	if( (erb(&DateBackUp.Day)==0xFF) || (erb(&DateBackUp.Month)==0xFF) || (erb(&DateBackUp.Year)== 0xFF) ) return 0;
   101e2:	90 e0       	ldi	r25, 0x00	; 0
	else return 1;
}
   101e4:	89 2f       	mov	r24, r25
   101e6:	08 95       	ret

000101e8 <Menu_BackUp_Enter>:
			NULL, NULL, NULL, Menu_ConfirmationRest_Enter, NULL, NULL, NULL};
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	//		  
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	uint8_t Menu_BackUp_Enter(){
		switch(CurrLine){
   101e8:	80 91 ca 07 	lds	r24, 0x07CA
   101ec:	82 30       	cpi	r24, 0x02	; 2
   101ee:	11 f0       	breq	.+4      	; 0x101f4 <Menu_BackUp_Enter+0xc>
			}
			NextPage = &Menu_ConfirmationRestore;
			break;
		}
		return StandartKey;
	}
   101f0:	80 e0       	ldi	r24, 0x00	; 0
   101f2:	08 95       	ret
	//		  
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	uint8_t Menu_BackUp_Enter(){
		switch(CurrLine){
		case 2:
			if(!EEMEMBackUpOk()){
   101f4:	0e 94 db 80 	call	0x101b6	; 0x101b6 <EEMEMBackUpOk>
   101f8:	88 23       	and	r24, r24
   101fa:	59 f4       	brne	.+22     	; 0x10212 <Menu_BackUp_Enter+0x2a>
				//   EEPROM,   BackUp- -  
				if(MemFail & 1<<MemFail_EEPROM){
   101fc:	80 91 17 09 	lds	r24, 0x0917
   10200:	81 ff       	sbrs	r24, 1
   10202:	0f c0       	rjmp	.+30     	; 0x10222 <Menu_BackUp_Enter+0x3a>
					MemFailReset();
   10204:	0e 94 6f 56 	call	0xacde	; 0xacde <MemFailReset>
					ShowMsg(&Msg_EEWarning);
   10208:	8b e3       	ldi	r24, 0x3B	; 59
   1020a:	93 e1       	ldi	r25, 0x13	; 19
   1020c:	0e 94 36 46 	call	0x8c6c	; 0x8c6c <ShowMsg>
   10210:	ef cf       	rjmp	.-34     	; 0x101f0 <Menu_BackUp_Enter+0x8>
				}
				else ShowMsg(&Msg_NoBackUp);
				break;
			}
			NextPage = &Menu_ConfirmationRestore;
   10212:	8b ee       	ldi	r24, 0xEB	; 235
   10214:	94 e1       	ldi	r25, 0x14	; 20
   10216:	90 93 da 05 	sts	0x05DA, r25
   1021a:	80 93 d9 05 	sts	0x05D9, r24
			break;
		}
		return StandartKey;
	}
   1021e:	80 e0       	ldi	r24, 0x00	; 0
   10220:	08 95       	ret
				//   EEPROM,   BackUp- -  
				if(MemFail & 1<<MemFail_EEPROM){
					MemFailReset();
					ShowMsg(&Msg_EEWarning);
				}
				else ShowMsg(&Msg_NoBackUp);
   10222:	8d e9       	ldi	r24, 0x9D	; 157
   10224:	93 e1       	ldi	r25, 0x13	; 19
   10226:	0e 94 36 46 	call	0x8c6c	; 0x8c6c <ShowMsg>
   1022a:	e2 cf       	rjmp	.-60     	; 0x101f0 <Menu_BackUp_Enter+0x8>

0001022c <vfprintf>:
   1022c:	2f 92       	push	r2
   1022e:	3f 92       	push	r3
   10230:	4f 92       	push	r4
   10232:	5f 92       	push	r5
   10234:	6f 92       	push	r6
   10236:	7f 92       	push	r7
   10238:	8f 92       	push	r8
   1023a:	9f 92       	push	r9
   1023c:	af 92       	push	r10
   1023e:	bf 92       	push	r11
   10240:	cf 92       	push	r12
   10242:	df 92       	push	r13
   10244:	ef 92       	push	r14
   10246:	ff 92       	push	r15
   10248:	0f 93       	push	r16
   1024a:	1f 93       	push	r17
   1024c:	df 93       	push	r29
   1024e:	cf 93       	push	r28
   10250:	cd b7       	in	r28, 0x3d	; 61
   10252:	de b7       	in	r29, 0x3e	; 62
   10254:	61 97       	sbiw	r28, 0x11	; 17
   10256:	0f b6       	in	r0, 0x3f	; 63
   10258:	f8 94       	cli
   1025a:	de bf       	out	0x3e, r29	; 62
   1025c:	0f be       	out	0x3f, r0	; 63
   1025e:	cd bf       	out	0x3d, r28	; 61
   10260:	3c 01       	movw	r6, r24
   10262:	7f 87       	std	Y+15, r23	; 0x0f
   10264:	6e 87       	std	Y+14, r22	; 0x0e
   10266:	6a 01       	movw	r12, r20
   10268:	fc 01       	movw	r30, r24
   1026a:	17 82       	std	Z+7, r1	; 0x07
   1026c:	16 82       	std	Z+6, r1	; 0x06
   1026e:	83 81       	ldd	r24, Z+3	; 0x03
   10270:	81 fd       	sbrc	r24, 1
   10272:	03 c0       	rjmp	.+6      	; 0x1027a <vfprintf+0x4e>
   10274:	6f ef       	ldi	r22, 0xFF	; 255
   10276:	7f ef       	ldi	r23, 0xFF	; 255
   10278:	6f c3       	rjmp	.+1758   	; 0x10958 <vfprintf+0x72c>
   1027a:	9e 01       	movw	r18, r28
   1027c:	2f 5f       	subi	r18, 0xFF	; 255
   1027e:	3f 4f       	sbci	r19, 0xFF	; 255
   10280:	39 8b       	std	Y+17, r19	; 0x11
   10282:	28 8b       	std	Y+16, r18	; 0x10
   10284:	f3 01       	movw	r30, r6
   10286:	23 81       	ldd	r18, Z+3	; 0x03
   10288:	ee 85       	ldd	r30, Y+14	; 0x0e
   1028a:	ff 85       	ldd	r31, Y+15	; 0x0f
   1028c:	23 fd       	sbrc	r18, 3
   1028e:	85 91       	lpm	r24, Z+
   10290:	23 ff       	sbrs	r18, 3
   10292:	81 91       	ld	r24, Z+
   10294:	ff 87       	std	Y+15, r31	; 0x0f
   10296:	ee 87       	std	Y+14, r30	; 0x0e
   10298:	88 23       	and	r24, r24
   1029a:	09 f4       	brne	.+2      	; 0x1029e <vfprintf+0x72>
   1029c:	5a c3       	rjmp	.+1716   	; 0x10952 <vfprintf+0x726>
   1029e:	85 32       	cpi	r24, 0x25	; 37
   102a0:	51 f4       	brne	.+20     	; 0x102b6 <vfprintf+0x8a>
   102a2:	ee 85       	ldd	r30, Y+14	; 0x0e
   102a4:	ff 85       	ldd	r31, Y+15	; 0x0f
   102a6:	23 fd       	sbrc	r18, 3
   102a8:	85 91       	lpm	r24, Z+
   102aa:	23 ff       	sbrs	r18, 3
   102ac:	81 91       	ld	r24, Z+
   102ae:	ff 87       	std	Y+15, r31	; 0x0f
   102b0:	ee 87       	std	Y+14, r30	; 0x0e
   102b2:	85 32       	cpi	r24, 0x25	; 37
   102b4:	29 f4       	brne	.+10     	; 0x102c0 <vfprintf+0x94>
   102b6:	90 e0       	ldi	r25, 0x00	; 0
   102b8:	b3 01       	movw	r22, r6
   102ba:	0e 94 c3 8b 	call	0x11786	; 0x11786 <fputc>
   102be:	e2 cf       	rjmp	.-60     	; 0x10284 <vfprintf+0x58>
   102c0:	98 2f       	mov	r25, r24
   102c2:	10 e0       	ldi	r17, 0x00	; 0
   102c4:	88 24       	eor	r8, r8
   102c6:	99 24       	eor	r9, r9
   102c8:	10 32       	cpi	r17, 0x20	; 32
   102ca:	b0 f4       	brcc	.+44     	; 0x102f8 <vfprintf+0xcc>
   102cc:	9b 32       	cpi	r25, 0x2B	; 43
   102ce:	69 f0       	breq	.+26     	; 0x102ea <vfprintf+0xbe>
   102d0:	9c 32       	cpi	r25, 0x2C	; 44
   102d2:	28 f4       	brcc	.+10     	; 0x102de <vfprintf+0xb2>
   102d4:	90 32       	cpi	r25, 0x20	; 32
   102d6:	51 f0       	breq	.+20     	; 0x102ec <vfprintf+0xc0>
   102d8:	93 32       	cpi	r25, 0x23	; 35
   102da:	71 f4       	brne	.+28     	; 0x102f8 <vfprintf+0xcc>
   102dc:	0b c0       	rjmp	.+22     	; 0x102f4 <vfprintf+0xc8>
   102de:	9d 32       	cpi	r25, 0x2D	; 45
   102e0:	39 f0       	breq	.+14     	; 0x102f0 <vfprintf+0xc4>
   102e2:	90 33       	cpi	r25, 0x30	; 48
   102e4:	49 f4       	brne	.+18     	; 0x102f8 <vfprintf+0xcc>
   102e6:	11 60       	ori	r17, 0x01	; 1
   102e8:	28 c0       	rjmp	.+80     	; 0x1033a <vfprintf+0x10e>
   102ea:	12 60       	ori	r17, 0x02	; 2
   102ec:	14 60       	ori	r17, 0x04	; 4
   102ee:	25 c0       	rjmp	.+74     	; 0x1033a <vfprintf+0x10e>
   102f0:	18 60       	ori	r17, 0x08	; 8
   102f2:	23 c0       	rjmp	.+70     	; 0x1033a <vfprintf+0x10e>
   102f4:	10 61       	ori	r17, 0x10	; 16
   102f6:	21 c0       	rjmp	.+66     	; 0x1033a <vfprintf+0x10e>
   102f8:	17 fd       	sbrc	r17, 7
   102fa:	2a c0       	rjmp	.+84     	; 0x10350 <vfprintf+0x124>
   102fc:	89 2f       	mov	r24, r25
   102fe:	80 53       	subi	r24, 0x30	; 48
   10300:	8a 30       	cpi	r24, 0x0A	; 10
   10302:	78 f4       	brcc	.+30     	; 0x10322 <vfprintf+0xf6>
   10304:	16 ff       	sbrs	r17, 6
   10306:	06 c0       	rjmp	.+12     	; 0x10314 <vfprintf+0xe8>
   10308:	fa e0       	ldi	r31, 0x0A	; 10
   1030a:	9f 9e       	mul	r9, r31
   1030c:	90 2c       	mov	r9, r0
   1030e:	11 24       	eor	r1, r1
   10310:	98 0e       	add	r9, r24
   10312:	13 c0       	rjmp	.+38     	; 0x1033a <vfprintf+0x10e>
   10314:	3a e0       	ldi	r19, 0x0A	; 10
   10316:	83 9e       	mul	r8, r19
   10318:	80 2c       	mov	r8, r0
   1031a:	11 24       	eor	r1, r1
   1031c:	88 0e       	add	r8, r24
   1031e:	10 62       	ori	r17, 0x20	; 32
   10320:	0c c0       	rjmp	.+24     	; 0x1033a <vfprintf+0x10e>
   10322:	9e 32       	cpi	r25, 0x2E	; 46
   10324:	21 f4       	brne	.+8      	; 0x1032e <vfprintf+0x102>
   10326:	16 fd       	sbrc	r17, 6
   10328:	14 c3       	rjmp	.+1576   	; 0x10952 <vfprintf+0x726>
   1032a:	10 64       	ori	r17, 0x40	; 64
   1032c:	06 c0       	rjmp	.+12     	; 0x1033a <vfprintf+0x10e>
   1032e:	9c 36       	cpi	r25, 0x6C	; 108
   10330:	11 f4       	brne	.+4      	; 0x10336 <vfprintf+0x10a>
   10332:	10 68       	ori	r17, 0x80	; 128
   10334:	02 c0       	rjmp	.+4      	; 0x1033a <vfprintf+0x10e>
   10336:	98 36       	cpi	r25, 0x68	; 104
   10338:	59 f4       	brne	.+22     	; 0x10350 <vfprintf+0x124>
   1033a:	ee 85       	ldd	r30, Y+14	; 0x0e
   1033c:	ff 85       	ldd	r31, Y+15	; 0x0f
   1033e:	23 fd       	sbrc	r18, 3
   10340:	95 91       	lpm	r25, Z+
   10342:	23 ff       	sbrs	r18, 3
   10344:	91 91       	ld	r25, Z+
   10346:	ff 87       	std	Y+15, r31	; 0x0f
   10348:	ee 87       	std	Y+14, r30	; 0x0e
   1034a:	99 23       	and	r25, r25
   1034c:	09 f0       	breq	.+2      	; 0x10350 <vfprintf+0x124>
   1034e:	bc cf       	rjmp	.-136    	; 0x102c8 <vfprintf+0x9c>
   10350:	89 2f       	mov	r24, r25
   10352:	85 54       	subi	r24, 0x45	; 69
   10354:	83 30       	cpi	r24, 0x03	; 3
   10356:	20 f4       	brcc	.+8      	; 0x10360 <vfprintf+0x134>
   10358:	81 2f       	mov	r24, r17
   1035a:	80 61       	ori	r24, 0x10	; 16
   1035c:	90 5e       	subi	r25, 0xE0	; 224
   1035e:	07 c0       	rjmp	.+14     	; 0x1036e <vfprintf+0x142>
   10360:	89 2f       	mov	r24, r25
   10362:	85 56       	subi	r24, 0x65	; 101
   10364:	83 30       	cpi	r24, 0x03	; 3
   10366:	08 f0       	brcs	.+2      	; 0x1036a <vfprintf+0x13e>
   10368:	9f c1       	rjmp	.+830    	; 0x106a8 <vfprintf+0x47c>
   1036a:	81 2f       	mov	r24, r17
   1036c:	8f 7e       	andi	r24, 0xEF	; 239
   1036e:	86 fd       	sbrc	r24, 6
   10370:	02 c0       	rjmp	.+4      	; 0x10376 <vfprintf+0x14a>
   10372:	76 e0       	ldi	r23, 0x06	; 6
   10374:	97 2e       	mov	r9, r23
   10376:	6f e3       	ldi	r22, 0x3F	; 63
   10378:	f6 2e       	mov	r15, r22
   1037a:	f8 22       	and	r15, r24
   1037c:	95 36       	cpi	r25, 0x65	; 101
   1037e:	19 f4       	brne	.+6      	; 0x10386 <vfprintf+0x15a>
   10380:	f0 e4       	ldi	r31, 0x40	; 64
   10382:	ff 2a       	or	r15, r31
   10384:	07 c0       	rjmp	.+14     	; 0x10394 <vfprintf+0x168>
   10386:	96 36       	cpi	r25, 0x66	; 102
   10388:	19 f4       	brne	.+6      	; 0x10390 <vfprintf+0x164>
   1038a:	20 e8       	ldi	r18, 0x80	; 128
   1038c:	f2 2a       	or	r15, r18
   1038e:	02 c0       	rjmp	.+4      	; 0x10394 <vfprintf+0x168>
   10390:	91 10       	cpse	r9, r1
   10392:	9a 94       	dec	r9
   10394:	f7 fe       	sbrs	r15, 7
   10396:	0a c0       	rjmp	.+20     	; 0x103ac <vfprintf+0x180>
   10398:	3b e3       	ldi	r19, 0x3B	; 59
   1039a:	39 15       	cp	r19, r9
   1039c:	18 f4       	brcc	.+6      	; 0x103a4 <vfprintf+0x178>
   1039e:	5c e3       	ldi	r21, 0x3C	; 60
   103a0:	b5 2e       	mov	r11, r21
   103a2:	02 c0       	rjmp	.+4      	; 0x103a8 <vfprintf+0x17c>
   103a4:	b9 2c       	mov	r11, r9
   103a6:	b3 94       	inc	r11
   103a8:	27 e0       	ldi	r18, 0x07	; 7
   103aa:	09 c0       	rjmp	.+18     	; 0x103be <vfprintf+0x192>
   103ac:	47 e0       	ldi	r20, 0x07	; 7
   103ae:	49 15       	cp	r20, r9
   103b0:	20 f4       	brcc	.+8      	; 0x103ba <vfprintf+0x18e>
   103b2:	bb 24       	eor	r11, r11
   103b4:	47 e0       	ldi	r20, 0x07	; 7
   103b6:	94 2e       	mov	r9, r20
   103b8:	f7 cf       	rjmp	.-18     	; 0x103a8 <vfprintf+0x17c>
   103ba:	29 2d       	mov	r18, r9
   103bc:	bb 24       	eor	r11, r11
   103be:	c6 01       	movw	r24, r12
   103c0:	04 96       	adiw	r24, 0x04	; 4
   103c2:	9d 87       	std	Y+13, r25	; 0x0d
   103c4:	8c 87       	std	Y+12, r24	; 0x0c
   103c6:	f6 01       	movw	r30, r12
   103c8:	60 81       	ld	r22, Z
   103ca:	71 81       	ldd	r23, Z+1	; 0x01
   103cc:	82 81       	ldd	r24, Z+2	; 0x02
   103ce:	93 81       	ldd	r25, Z+3	; 0x03
   103d0:	ae 01       	movw	r20, r28
   103d2:	4f 5f       	subi	r20, 0xFF	; 255
   103d4:	5f 4f       	sbci	r21, 0xFF	; 255
   103d6:	0b 2d       	mov	r16, r11
   103d8:	0e 94 00 8a 	call	0x11400	; 0x11400 <__ftoa_engine>
   103dc:	6c 01       	movw	r12, r24
   103de:	09 81       	ldd	r16, Y+1	; 0x01
   103e0:	20 2e       	mov	r2, r16
   103e2:	33 24       	eor	r3, r3
   103e4:	00 ff       	sbrs	r16, 0
   103e6:	04 c0       	rjmp	.+8      	; 0x103f0 <vfprintf+0x1c4>
   103e8:	03 fd       	sbrc	r16, 3
   103ea:	02 c0       	rjmp	.+4      	; 0x103f0 <vfprintf+0x1c4>
   103ec:	1d e2       	ldi	r17, 0x2D	; 45
   103ee:	09 c0       	rjmp	.+18     	; 0x10402 <vfprintf+0x1d6>
   103f0:	f1 fe       	sbrs	r15, 1
   103f2:	02 c0       	rjmp	.+4      	; 0x103f8 <vfprintf+0x1cc>
   103f4:	1b e2       	ldi	r17, 0x2B	; 43
   103f6:	05 c0       	rjmp	.+10     	; 0x10402 <vfprintf+0x1d6>
   103f8:	f2 fc       	sbrc	r15, 2
   103fa:	02 c0       	rjmp	.+4      	; 0x10400 <vfprintf+0x1d4>
   103fc:	10 e0       	ldi	r17, 0x00	; 0
   103fe:	01 c0       	rjmp	.+2      	; 0x10402 <vfprintf+0x1d6>
   10400:	10 e2       	ldi	r17, 0x20	; 32
   10402:	c1 01       	movw	r24, r2
   10404:	8c 70       	andi	r24, 0x0C	; 12
   10406:	90 70       	andi	r25, 0x00	; 0
   10408:	89 2b       	or	r24, r25
   1040a:	b9 f1       	breq	.+110    	; 0x1047a <vfprintf+0x24e>
   1040c:	11 23       	and	r17, r17
   1040e:	11 f4       	brne	.+4      	; 0x10414 <vfprintf+0x1e8>
   10410:	83 e0       	ldi	r24, 0x03	; 3
   10412:	01 c0       	rjmp	.+2      	; 0x10416 <vfprintf+0x1ea>
   10414:	84 e0       	ldi	r24, 0x04	; 4
   10416:	88 15       	cp	r24, r8
   10418:	10 f0       	brcs	.+4      	; 0x1041e <vfprintf+0x1f2>
   1041a:	88 24       	eor	r8, r8
   1041c:	0a c0       	rjmp	.+20     	; 0x10432 <vfprintf+0x206>
   1041e:	88 1a       	sub	r8, r24
   10420:	f3 fc       	sbrc	r15, 3
   10422:	07 c0       	rjmp	.+14     	; 0x10432 <vfprintf+0x206>
   10424:	80 e2       	ldi	r24, 0x20	; 32
   10426:	90 e0       	ldi	r25, 0x00	; 0
   10428:	b3 01       	movw	r22, r6
   1042a:	0e 94 c3 8b 	call	0x11786	; 0x11786 <fputc>
   1042e:	8a 94       	dec	r8
   10430:	c9 f7       	brne	.-14     	; 0x10424 <vfprintf+0x1f8>
   10432:	11 23       	and	r17, r17
   10434:	29 f0       	breq	.+10     	; 0x10440 <vfprintf+0x214>
   10436:	81 2f       	mov	r24, r17
   10438:	90 e0       	ldi	r25, 0x00	; 0
   1043a:	b3 01       	movw	r22, r6
   1043c:	0e 94 c3 8b 	call	0x11786	; 0x11786 <fputc>
   10440:	23 fe       	sbrs	r2, 3
   10442:	03 c0       	rjmp	.+6      	; 0x1044a <vfprintf+0x21e>
   10444:	0e ec       	ldi	r16, 0xCE	; 206
   10446:	12 e0       	ldi	r17, 0x02	; 2
   10448:	0e c0       	rjmp	.+28     	; 0x10466 <vfprintf+0x23a>
   1044a:	02 ed       	ldi	r16, 0xD2	; 210
   1044c:	12 e0       	ldi	r17, 0x02	; 2
   1044e:	0b c0       	rjmp	.+22     	; 0x10466 <vfprintf+0x23a>
   10450:	e1 14       	cp	r14, r1
   10452:	f1 04       	cpc	r15, r1
   10454:	09 f0       	breq	.+2      	; 0x10458 <vfprintf+0x22c>
   10456:	80 52       	subi	r24, 0x20	; 32
   10458:	90 e0       	ldi	r25, 0x00	; 0
   1045a:	b3 01       	movw	r22, r6
   1045c:	0e 94 c3 8b 	call	0x11786	; 0x11786 <fputc>
   10460:	0f 5f       	subi	r16, 0xFF	; 255
   10462:	1f 4f       	sbci	r17, 0xFF	; 255
   10464:	05 c0       	rjmp	.+10     	; 0x10470 <vfprintf+0x244>
   10466:	ef 2c       	mov	r14, r15
   10468:	ff 24       	eor	r15, r15
   1046a:	f0 e1       	ldi	r31, 0x10	; 16
   1046c:	ef 22       	and	r14, r31
   1046e:	ff 24       	eor	r15, r15
   10470:	f8 01       	movw	r30, r16
   10472:	84 91       	lpm	r24, Z+
   10474:	88 23       	and	r24, r24
   10476:	61 f7       	brne	.-40     	; 0x10450 <vfprintf+0x224>
   10478:	14 c1       	rjmp	.+552    	; 0x106a2 <vfprintf+0x476>
   1047a:	f7 fe       	sbrs	r15, 7
   1047c:	12 c0       	rjmp	.+36     	; 0x104a2 <vfprintf+0x276>
   1047e:	bc 0c       	add	r11, r12
   10480:	24 fe       	sbrs	r2, 4
   10482:	04 c0       	rjmp	.+8      	; 0x1048c <vfprintf+0x260>
   10484:	8a 81       	ldd	r24, Y+2	; 0x02
   10486:	81 33       	cpi	r24, 0x31	; 49
   10488:	09 f4       	brne	.+2      	; 0x1048c <vfprintf+0x260>
   1048a:	ba 94       	dec	r11
   1048c:	1b 14       	cp	r1, r11
   1048e:	1c f0       	brlt	.+6      	; 0x10496 <vfprintf+0x26a>
   10490:	bb 24       	eor	r11, r11
   10492:	b3 94       	inc	r11
   10494:	2d c0       	rjmp	.+90     	; 0x104f0 <vfprintf+0x2c4>
   10496:	f8 e0       	ldi	r31, 0x08	; 8
   10498:	fb 15       	cp	r31, r11
   1049a:	50 f5       	brcc	.+84     	; 0x104f0 <vfprintf+0x2c4>
   1049c:	38 e0       	ldi	r19, 0x08	; 8
   1049e:	b3 2e       	mov	r11, r19
   104a0:	27 c0       	rjmp	.+78     	; 0x104f0 <vfprintf+0x2c4>
   104a2:	f6 fc       	sbrc	r15, 6
   104a4:	25 c0       	rjmp	.+74     	; 0x104f0 <vfprintf+0x2c4>
   104a6:	89 2d       	mov	r24, r9
   104a8:	90 e0       	ldi	r25, 0x00	; 0
   104aa:	8c 15       	cp	r24, r12
   104ac:	9d 05       	cpc	r25, r13
   104ae:	4c f0       	brlt	.+18     	; 0x104c2 <vfprintf+0x296>
   104b0:	2c ef       	ldi	r18, 0xFC	; 252
   104b2:	c2 16       	cp	r12, r18
   104b4:	2f ef       	ldi	r18, 0xFF	; 255
   104b6:	d2 06       	cpc	r13, r18
   104b8:	24 f0       	brlt	.+8      	; 0x104c2 <vfprintf+0x296>
   104ba:	30 e8       	ldi	r19, 0x80	; 128
   104bc:	f3 2a       	or	r15, r19
   104be:	01 c0       	rjmp	.+2      	; 0x104c2 <vfprintf+0x296>
   104c0:	9a 94       	dec	r9
   104c2:	99 20       	and	r9, r9
   104c4:	49 f0       	breq	.+18     	; 0x104d8 <vfprintf+0x2ac>
   104c6:	e2 e0       	ldi	r30, 0x02	; 2
   104c8:	f0 e0       	ldi	r31, 0x00	; 0
   104ca:	ec 0f       	add	r30, r28
   104cc:	fd 1f       	adc	r31, r29
   104ce:	e9 0d       	add	r30, r9
   104d0:	f1 1d       	adc	r31, r1
   104d2:	80 81       	ld	r24, Z
   104d4:	80 33       	cpi	r24, 0x30	; 48
   104d6:	a1 f3       	breq	.-24     	; 0x104c0 <vfprintf+0x294>
   104d8:	f7 fe       	sbrs	r15, 7
   104da:	0a c0       	rjmp	.+20     	; 0x104f0 <vfprintf+0x2c4>
   104dc:	b9 2c       	mov	r11, r9
   104de:	b3 94       	inc	r11
   104e0:	89 2d       	mov	r24, r9
   104e2:	90 e0       	ldi	r25, 0x00	; 0
   104e4:	c8 16       	cp	r12, r24
   104e6:	d9 06       	cpc	r13, r25
   104e8:	14 f0       	brlt	.+4      	; 0x104ee <vfprintf+0x2c2>
   104ea:	99 24       	eor	r9, r9
   104ec:	01 c0       	rjmp	.+2      	; 0x104f0 <vfprintf+0x2c4>
   104ee:	9c 18       	sub	r9, r12
   104f0:	f7 fc       	sbrc	r15, 7
   104f2:	03 c0       	rjmp	.+6      	; 0x104fa <vfprintf+0x2ce>
   104f4:	25 e0       	ldi	r18, 0x05	; 5
   104f6:	30 e0       	ldi	r19, 0x00	; 0
   104f8:	09 c0       	rjmp	.+18     	; 0x1050c <vfprintf+0x2e0>
   104fa:	1c 14       	cp	r1, r12
   104fc:	1d 04       	cpc	r1, r13
   104fe:	1c f0       	brlt	.+6      	; 0x10506 <vfprintf+0x2da>
   10500:	21 e0       	ldi	r18, 0x01	; 1
   10502:	30 e0       	ldi	r19, 0x00	; 0
   10504:	03 c0       	rjmp	.+6      	; 0x1050c <vfprintf+0x2e0>
   10506:	96 01       	movw	r18, r12
   10508:	2f 5f       	subi	r18, 0xFF	; 255
   1050a:	3f 4f       	sbci	r19, 0xFF	; 255
   1050c:	11 23       	and	r17, r17
   1050e:	11 f0       	breq	.+4      	; 0x10514 <vfprintf+0x2e8>
   10510:	2f 5f       	subi	r18, 0xFF	; 255
   10512:	3f 4f       	sbci	r19, 0xFF	; 255
   10514:	99 20       	and	r9, r9
   10516:	29 f0       	breq	.+10     	; 0x10522 <vfprintf+0x2f6>
   10518:	89 2d       	mov	r24, r9
   1051a:	90 e0       	ldi	r25, 0x00	; 0
   1051c:	01 96       	adiw	r24, 0x01	; 1
   1051e:	28 0f       	add	r18, r24
   10520:	39 1f       	adc	r19, r25
   10522:	88 2d       	mov	r24, r8
   10524:	90 e0       	ldi	r25, 0x00	; 0
   10526:	28 17       	cp	r18, r24
   10528:	39 07       	cpc	r19, r25
   1052a:	14 f0       	brlt	.+4      	; 0x10530 <vfprintf+0x304>
   1052c:	88 24       	eor	r8, r8
   1052e:	01 c0       	rjmp	.+2      	; 0x10532 <vfprintf+0x306>
   10530:	82 1a       	sub	r8, r18
   10532:	4f 2c       	mov	r4, r15
   10534:	55 24       	eor	r5, r5
   10536:	c2 01       	movw	r24, r4
   10538:	89 70       	andi	r24, 0x09	; 9
   1053a:	90 70       	andi	r25, 0x00	; 0
   1053c:	89 2b       	or	r24, r25
   1053e:	39 f0       	breq	.+14     	; 0x1054e <vfprintf+0x322>
   10540:	08 c0       	rjmp	.+16     	; 0x10552 <vfprintf+0x326>
   10542:	80 e2       	ldi	r24, 0x20	; 32
   10544:	90 e0       	ldi	r25, 0x00	; 0
   10546:	b3 01       	movw	r22, r6
   10548:	0e 94 c3 8b 	call	0x11786	; 0x11786 <fputc>
   1054c:	8a 94       	dec	r8
   1054e:	88 20       	and	r8, r8
   10550:	c1 f7       	brne	.-16     	; 0x10542 <vfprintf+0x316>
   10552:	11 23       	and	r17, r17
   10554:	29 f0       	breq	.+10     	; 0x10560 <vfprintf+0x334>
   10556:	81 2f       	mov	r24, r17
   10558:	90 e0       	ldi	r25, 0x00	; 0
   1055a:	b3 01       	movw	r22, r6
   1055c:	0e 94 c3 8b 	call	0x11786	; 0x11786 <fputc>
   10560:	43 fe       	sbrs	r4, 3
   10562:	07 c0       	rjmp	.+14     	; 0x10572 <vfprintf+0x346>
   10564:	08 c0       	rjmp	.+16     	; 0x10576 <vfprintf+0x34a>
   10566:	80 e3       	ldi	r24, 0x30	; 48
   10568:	90 e0       	ldi	r25, 0x00	; 0
   1056a:	b3 01       	movw	r22, r6
   1056c:	0e 94 c3 8b 	call	0x11786	; 0x11786 <fputc>
   10570:	8a 94       	dec	r8
   10572:	88 20       	and	r8, r8
   10574:	c1 f7       	brne	.-16     	; 0x10566 <vfprintf+0x33a>
   10576:	f7 fe       	sbrs	r15, 7
   10578:	46 c0       	rjmp	.+140    	; 0x10606 <vfprintf+0x3da>
   1057a:	86 01       	movw	r16, r12
   1057c:	d7 fe       	sbrs	r13, 7
   1057e:	02 c0       	rjmp	.+4      	; 0x10584 <vfprintf+0x358>
   10580:	00 e0       	ldi	r16, 0x00	; 0
   10582:	10 e0       	ldi	r17, 0x00	; 0
   10584:	76 01       	movw	r14, r12
   10586:	08 94       	sec
   10588:	e1 1c       	adc	r14, r1
   1058a:	f1 1c       	adc	r15, r1
   1058c:	e0 1a       	sub	r14, r16
   1058e:	f1 0a       	sbc	r15, r17
   10590:	41 e0       	ldi	r20, 0x01	; 1
   10592:	50 e0       	ldi	r21, 0x00	; 0
   10594:	4c 0f       	add	r20, r28
   10596:	5d 1f       	adc	r21, r29
   10598:	e4 0e       	add	r14, r20
   1059a:	f5 1e       	adc	r15, r21
   1059c:	26 01       	movw	r4, r12
   1059e:	4b 18       	sub	r4, r11
   105a0:	51 08       	sbc	r5, r1
   105a2:	89 2d       	mov	r24, r9
   105a4:	90 e0       	ldi	r25, 0x00	; 0
   105a6:	aa 24       	eor	r10, r10
   105a8:	bb 24       	eor	r11, r11
   105aa:	a8 1a       	sub	r10, r24
   105ac:	b9 0a       	sbc	r11, r25
   105ae:	5f ef       	ldi	r21, 0xFF	; 255
   105b0:	0f 3f       	cpi	r16, 0xFF	; 255
   105b2:	15 07       	cpc	r17, r21
   105b4:	29 f4       	brne	.+10     	; 0x105c0 <vfprintf+0x394>
   105b6:	8e e2       	ldi	r24, 0x2E	; 46
   105b8:	90 e0       	ldi	r25, 0x00	; 0
   105ba:	b3 01       	movw	r22, r6
   105bc:	0e 94 c3 8b 	call	0x11786	; 0x11786 <fputc>
   105c0:	c0 16       	cp	r12, r16
   105c2:	d1 06       	cpc	r13, r17
   105c4:	34 f0       	brlt	.+12     	; 0x105d2 <vfprintf+0x3a6>
   105c6:	40 16       	cp	r4, r16
   105c8:	51 06       	cpc	r5, r17
   105ca:	1c f4       	brge	.+6      	; 0x105d2 <vfprintf+0x3a6>
   105cc:	f7 01       	movw	r30, r14
   105ce:	80 81       	ld	r24, Z
   105d0:	01 c0       	rjmp	.+2      	; 0x105d4 <vfprintf+0x3a8>
   105d2:	80 e3       	ldi	r24, 0x30	; 48
   105d4:	01 50       	subi	r16, 0x01	; 1
   105d6:	10 40       	sbci	r17, 0x00	; 0
   105d8:	08 94       	sec
   105da:	e1 1c       	adc	r14, r1
   105dc:	f1 1c       	adc	r15, r1
   105de:	0a 15       	cp	r16, r10
   105e0:	1b 05       	cpc	r17, r11
   105e2:	2c f0       	brlt	.+10     	; 0x105ee <vfprintf+0x3c2>
   105e4:	90 e0       	ldi	r25, 0x00	; 0
   105e6:	b3 01       	movw	r22, r6
   105e8:	0e 94 c3 8b 	call	0x11786	; 0x11786 <fputc>
   105ec:	e0 cf       	rjmp	.-64     	; 0x105ae <vfprintf+0x382>
   105ee:	0c 15       	cp	r16, r12
   105f0:	1d 05       	cpc	r17, r13
   105f2:	39 f4       	brne	.+14     	; 0x10602 <vfprintf+0x3d6>
   105f4:	9a 81       	ldd	r25, Y+2	; 0x02
   105f6:	96 33       	cpi	r25, 0x36	; 54
   105f8:	18 f4       	brcc	.+6      	; 0x10600 <vfprintf+0x3d4>
   105fa:	95 33       	cpi	r25, 0x35	; 53
   105fc:	11 f4       	brne	.+4      	; 0x10602 <vfprintf+0x3d6>
   105fe:	24 fe       	sbrs	r2, 4
   10600:	81 e3       	ldi	r24, 0x31	; 49
   10602:	90 e0       	ldi	r25, 0x00	; 0
   10604:	4b c0       	rjmp	.+150    	; 0x1069c <vfprintf+0x470>
   10606:	8a 81       	ldd	r24, Y+2	; 0x02
   10608:	81 33       	cpi	r24, 0x31	; 49
   1060a:	09 f0       	breq	.+2      	; 0x1060e <vfprintf+0x3e2>
   1060c:	0f 7e       	andi	r16, 0xEF	; 239
   1060e:	90 e0       	ldi	r25, 0x00	; 0
   10610:	b3 01       	movw	r22, r6
   10612:	0e 94 c3 8b 	call	0x11786	; 0x11786 <fputc>
   10616:	99 20       	and	r9, r9
   10618:	a1 f0       	breq	.+40     	; 0x10642 <vfprintf+0x416>
   1061a:	8e e2       	ldi	r24, 0x2E	; 46
   1061c:	90 e0       	ldi	r25, 0x00	; 0
   1061e:	b3 01       	movw	r22, r6
   10620:	0e 94 c3 8b 	call	0x11786	; 0x11786 <fputc>
   10624:	12 e0       	ldi	r17, 0x02	; 2
   10626:	e1 e0       	ldi	r30, 0x01	; 1
   10628:	f0 e0       	ldi	r31, 0x00	; 0
   1062a:	ec 0f       	add	r30, r28
   1062c:	fd 1f       	adc	r31, r29
   1062e:	e1 0f       	add	r30, r17
   10630:	f1 1d       	adc	r31, r1
   10632:	1f 5f       	subi	r17, 0xFF	; 255
   10634:	80 81       	ld	r24, Z
   10636:	90 e0       	ldi	r25, 0x00	; 0
   10638:	b3 01       	movw	r22, r6
   1063a:	0e 94 c3 8b 	call	0x11786	; 0x11786 <fputc>
   1063e:	9a 94       	dec	r9
   10640:	91 f7       	brne	.-28     	; 0x10626 <vfprintf+0x3fa>
   10642:	44 fc       	sbrc	r4, 4
   10644:	03 c0       	rjmp	.+6      	; 0x1064c <vfprintf+0x420>
   10646:	85 e6       	ldi	r24, 0x65	; 101
   10648:	90 e0       	ldi	r25, 0x00	; 0
   1064a:	02 c0       	rjmp	.+4      	; 0x10650 <vfprintf+0x424>
   1064c:	85 e4       	ldi	r24, 0x45	; 69
   1064e:	90 e0       	ldi	r25, 0x00	; 0
   10650:	b3 01       	movw	r22, r6
   10652:	0e 94 c3 8b 	call	0x11786	; 0x11786 <fputc>
   10656:	d7 fc       	sbrc	r13, 7
   10658:	05 c0       	rjmp	.+10     	; 0x10664 <vfprintf+0x438>
   1065a:	c1 14       	cp	r12, r1
   1065c:	d1 04       	cpc	r13, r1
   1065e:	41 f4       	brne	.+16     	; 0x10670 <vfprintf+0x444>
   10660:	04 ff       	sbrs	r16, 4
   10662:	06 c0       	rjmp	.+12     	; 0x10670 <vfprintf+0x444>
   10664:	d0 94       	com	r13
   10666:	c1 94       	neg	r12
   10668:	d1 08       	sbc	r13, r1
   1066a:	d3 94       	inc	r13
   1066c:	8d e2       	ldi	r24, 0x2D	; 45
   1066e:	01 c0       	rjmp	.+2      	; 0x10672 <vfprintf+0x446>
   10670:	8b e2       	ldi	r24, 0x2B	; 43
   10672:	90 e0       	ldi	r25, 0x00	; 0
   10674:	b3 01       	movw	r22, r6
   10676:	0e 94 c3 8b 	call	0x11786	; 0x11786 <fputc>
   1067a:	80 e3       	ldi	r24, 0x30	; 48
   1067c:	05 c0       	rjmp	.+10     	; 0x10688 <vfprintf+0x45c>
   1067e:	8f 5f       	subi	r24, 0xFF	; 255
   10680:	26 ef       	ldi	r18, 0xF6	; 246
   10682:	3f ef       	ldi	r19, 0xFF	; 255
   10684:	c2 0e       	add	r12, r18
   10686:	d3 1e       	adc	r13, r19
   10688:	3a e0       	ldi	r19, 0x0A	; 10
   1068a:	c3 16       	cp	r12, r19
   1068c:	d1 04       	cpc	r13, r1
   1068e:	bc f7       	brge	.-18     	; 0x1067e <vfprintf+0x452>
   10690:	90 e0       	ldi	r25, 0x00	; 0
   10692:	b3 01       	movw	r22, r6
   10694:	0e 94 c3 8b 	call	0x11786	; 0x11786 <fputc>
   10698:	c6 01       	movw	r24, r12
   1069a:	c0 96       	adiw	r24, 0x30	; 48
   1069c:	b3 01       	movw	r22, r6
   1069e:	0e 94 c3 8b 	call	0x11786	; 0x11786 <fputc>
   106a2:	cc 84       	ldd	r12, Y+12	; 0x0c
   106a4:	dd 84       	ldd	r13, Y+13	; 0x0d
   106a6:	52 c1       	rjmp	.+676    	; 0x1094c <vfprintf+0x720>
   106a8:	93 36       	cpi	r25, 0x63	; 99
   106aa:	31 f0       	breq	.+12     	; 0x106b8 <vfprintf+0x48c>
   106ac:	93 37       	cpi	r25, 0x73	; 115
   106ae:	99 f0       	breq	.+38     	; 0x106d6 <vfprintf+0x4aa>
   106b0:	93 35       	cpi	r25, 0x53	; 83
   106b2:	09 f0       	breq	.+2      	; 0x106b6 <vfprintf+0x48a>
   106b4:	59 c0       	rjmp	.+178    	; 0x10768 <vfprintf+0x53c>
   106b6:	23 c0       	rjmp	.+70     	; 0x106fe <vfprintf+0x4d2>
   106b8:	f6 01       	movw	r30, r12
   106ba:	80 81       	ld	r24, Z
   106bc:	89 83       	std	Y+1, r24	; 0x01
   106be:	5e 01       	movw	r10, r28
   106c0:	08 94       	sec
   106c2:	a1 1c       	adc	r10, r1
   106c4:	b1 1c       	adc	r11, r1
   106c6:	22 e0       	ldi	r18, 0x02	; 2
   106c8:	30 e0       	ldi	r19, 0x00	; 0
   106ca:	c2 0e       	add	r12, r18
   106cc:	d3 1e       	adc	r13, r19
   106ce:	21 e0       	ldi	r18, 0x01	; 1
   106d0:	e2 2e       	mov	r14, r18
   106d2:	f1 2c       	mov	r15, r1
   106d4:	12 c0       	rjmp	.+36     	; 0x106fa <vfprintf+0x4ce>
   106d6:	f6 01       	movw	r30, r12
   106d8:	a0 80       	ld	r10, Z
   106da:	b1 80       	ldd	r11, Z+1	; 0x01
   106dc:	16 fd       	sbrc	r17, 6
   106de:	03 c0       	rjmp	.+6      	; 0x106e6 <vfprintf+0x4ba>
   106e0:	6f ef       	ldi	r22, 0xFF	; 255
   106e2:	7f ef       	ldi	r23, 0xFF	; 255
   106e4:	02 c0       	rjmp	.+4      	; 0x106ea <vfprintf+0x4be>
   106e6:	69 2d       	mov	r22, r9
   106e8:	70 e0       	ldi	r23, 0x00	; 0
   106ea:	22 e0       	ldi	r18, 0x02	; 2
   106ec:	30 e0       	ldi	r19, 0x00	; 0
   106ee:	c2 0e       	add	r12, r18
   106f0:	d3 1e       	adc	r13, r19
   106f2:	c5 01       	movw	r24, r10
   106f4:	0e 94 5c 8b 	call	0x116b8	; 0x116b8 <strnlen>
   106f8:	7c 01       	movw	r14, r24
   106fa:	1f 77       	andi	r17, 0x7F	; 127
   106fc:	13 c0       	rjmp	.+38     	; 0x10724 <vfprintf+0x4f8>
   106fe:	f6 01       	movw	r30, r12
   10700:	a0 80       	ld	r10, Z
   10702:	b1 80       	ldd	r11, Z+1	; 0x01
   10704:	16 fd       	sbrc	r17, 6
   10706:	03 c0       	rjmp	.+6      	; 0x1070e <vfprintf+0x4e2>
   10708:	6f ef       	ldi	r22, 0xFF	; 255
   1070a:	7f ef       	ldi	r23, 0xFF	; 255
   1070c:	02 c0       	rjmp	.+4      	; 0x10712 <vfprintf+0x4e6>
   1070e:	69 2d       	mov	r22, r9
   10710:	70 e0       	ldi	r23, 0x00	; 0
   10712:	22 e0       	ldi	r18, 0x02	; 2
   10714:	30 e0       	ldi	r19, 0x00	; 0
   10716:	c2 0e       	add	r12, r18
   10718:	d3 1e       	adc	r13, r19
   1071a:	c5 01       	movw	r24, r10
   1071c:	0e 94 1a 8b 	call	0x11634	; 0x11634 <strnlen_P>
   10720:	7c 01       	movw	r14, r24
   10722:	10 68       	ori	r17, 0x80	; 128
   10724:	13 ff       	sbrs	r17, 3
   10726:	07 c0       	rjmp	.+14     	; 0x10736 <vfprintf+0x50a>
   10728:	1b c0       	rjmp	.+54     	; 0x10760 <vfprintf+0x534>
   1072a:	80 e2       	ldi	r24, 0x20	; 32
   1072c:	90 e0       	ldi	r25, 0x00	; 0
   1072e:	b3 01       	movw	r22, r6
   10730:	0e 94 c3 8b 	call	0x11786	; 0x11786 <fputc>
   10734:	8a 94       	dec	r8
   10736:	88 2d       	mov	r24, r8
   10738:	90 e0       	ldi	r25, 0x00	; 0
   1073a:	e8 16       	cp	r14, r24
   1073c:	f9 06       	cpc	r15, r25
   1073e:	a8 f3       	brcs	.-22     	; 0x1072a <vfprintf+0x4fe>
   10740:	0f c0       	rjmp	.+30     	; 0x10760 <vfprintf+0x534>
   10742:	f5 01       	movw	r30, r10
   10744:	17 fd       	sbrc	r17, 7
   10746:	85 91       	lpm	r24, Z+
   10748:	17 ff       	sbrs	r17, 7
   1074a:	81 91       	ld	r24, Z+
   1074c:	5f 01       	movw	r10, r30
   1074e:	90 e0       	ldi	r25, 0x00	; 0
   10750:	b3 01       	movw	r22, r6
   10752:	0e 94 c3 8b 	call	0x11786	; 0x11786 <fputc>
   10756:	81 10       	cpse	r8, r1
   10758:	8a 94       	dec	r8
   1075a:	08 94       	sec
   1075c:	e1 08       	sbc	r14, r1
   1075e:	f1 08       	sbc	r15, r1
   10760:	e1 14       	cp	r14, r1
   10762:	f1 04       	cpc	r15, r1
   10764:	71 f7       	brne	.-36     	; 0x10742 <vfprintf+0x516>
   10766:	f2 c0       	rjmp	.+484    	; 0x1094c <vfprintf+0x720>
   10768:	94 36       	cpi	r25, 0x64	; 100
   1076a:	11 f0       	breq	.+4      	; 0x10770 <vfprintf+0x544>
   1076c:	99 36       	cpi	r25, 0x69	; 105
   1076e:	89 f5       	brne	.+98     	; 0x107d2 <vfprintf+0x5a6>
   10770:	17 ff       	sbrs	r17, 7
   10772:	08 c0       	rjmp	.+16     	; 0x10784 <vfprintf+0x558>
   10774:	f6 01       	movw	r30, r12
   10776:	20 81       	ld	r18, Z
   10778:	31 81       	ldd	r19, Z+1	; 0x01
   1077a:	42 81       	ldd	r20, Z+2	; 0x02
   1077c:	53 81       	ldd	r21, Z+3	; 0x03
   1077e:	84 e0       	ldi	r24, 0x04	; 4
   10780:	90 e0       	ldi	r25, 0x00	; 0
   10782:	0a c0       	rjmp	.+20     	; 0x10798 <vfprintf+0x56c>
   10784:	f6 01       	movw	r30, r12
   10786:	80 81       	ld	r24, Z
   10788:	91 81       	ldd	r25, Z+1	; 0x01
   1078a:	9c 01       	movw	r18, r24
   1078c:	44 27       	eor	r20, r20
   1078e:	37 fd       	sbrc	r19, 7
   10790:	40 95       	com	r20
   10792:	54 2f       	mov	r21, r20
   10794:	82 e0       	ldi	r24, 0x02	; 2
   10796:	90 e0       	ldi	r25, 0x00	; 0
   10798:	c8 0e       	add	r12, r24
   1079a:	d9 1e       	adc	r13, r25
   1079c:	9f e6       	ldi	r25, 0x6F	; 111
   1079e:	f9 2e       	mov	r15, r25
   107a0:	f1 22       	and	r15, r17
   107a2:	57 ff       	sbrs	r21, 7
   107a4:	09 c0       	rjmp	.+18     	; 0x107b8 <vfprintf+0x58c>
   107a6:	50 95       	com	r21
   107a8:	40 95       	com	r20
   107aa:	30 95       	com	r19
   107ac:	21 95       	neg	r18
   107ae:	3f 4f       	sbci	r19, 0xFF	; 255
   107b0:	4f 4f       	sbci	r20, 0xFF	; 255
   107b2:	5f 4f       	sbci	r21, 0xFF	; 255
   107b4:	90 e8       	ldi	r25, 0x80	; 128
   107b6:	f9 2a       	or	r15, r25
   107b8:	ca 01       	movw	r24, r20
   107ba:	b9 01       	movw	r22, r18
   107bc:	ae 01       	movw	r20, r28
   107be:	4f 5f       	subi	r20, 0xFF	; 255
   107c0:	5f 4f       	sbci	r21, 0xFF	; 255
   107c2:	2a e0       	ldi	r18, 0x0A	; 10
   107c4:	30 e0       	ldi	r19, 0x00	; 0
   107c6:	0e 94 b1 8c 	call	0x11962	; 0x11962 <__ultoa_invert>
   107ca:	e8 2e       	mov	r14, r24
   107cc:	e8 89       	ldd	r30, Y+16	; 0x10
   107ce:	ee 1a       	sub	r14, r30
   107d0:	41 c0       	rjmp	.+130    	; 0x10854 <vfprintf+0x628>
   107d2:	95 37       	cpi	r25, 0x75	; 117
   107d4:	21 f4       	brne	.+8      	; 0x107de <vfprintf+0x5b2>
   107d6:	1f 7e       	andi	r17, 0xEF	; 239
   107d8:	2a e0       	ldi	r18, 0x0A	; 10
   107da:	30 e0       	ldi	r19, 0x00	; 0
   107dc:	1c c0       	rjmp	.+56     	; 0x10816 <vfprintf+0x5ea>
   107de:	19 7f       	andi	r17, 0xF9	; 249
   107e0:	9f 36       	cpi	r25, 0x6F	; 111
   107e2:	61 f0       	breq	.+24     	; 0x107fc <vfprintf+0x5d0>
   107e4:	90 37       	cpi	r25, 0x70	; 112
   107e6:	20 f4       	brcc	.+8      	; 0x107f0 <vfprintf+0x5c4>
   107e8:	98 35       	cpi	r25, 0x58	; 88
   107ea:	09 f0       	breq	.+2      	; 0x107ee <vfprintf+0x5c2>
   107ec:	b2 c0       	rjmp	.+356    	; 0x10952 <vfprintf+0x726>
   107ee:	0f c0       	rjmp	.+30     	; 0x1080e <vfprintf+0x5e2>
   107f0:	90 37       	cpi	r25, 0x70	; 112
   107f2:	39 f0       	breq	.+14     	; 0x10802 <vfprintf+0x5d6>
   107f4:	98 37       	cpi	r25, 0x78	; 120
   107f6:	09 f0       	breq	.+2      	; 0x107fa <vfprintf+0x5ce>
   107f8:	ac c0       	rjmp	.+344    	; 0x10952 <vfprintf+0x726>
   107fa:	04 c0       	rjmp	.+8      	; 0x10804 <vfprintf+0x5d8>
   107fc:	28 e0       	ldi	r18, 0x08	; 8
   107fe:	30 e0       	ldi	r19, 0x00	; 0
   10800:	0a c0       	rjmp	.+20     	; 0x10816 <vfprintf+0x5ea>
   10802:	10 61       	ori	r17, 0x10	; 16
   10804:	14 fd       	sbrc	r17, 4
   10806:	14 60       	ori	r17, 0x04	; 4
   10808:	20 e1       	ldi	r18, 0x10	; 16
   1080a:	30 e0       	ldi	r19, 0x00	; 0
   1080c:	04 c0       	rjmp	.+8      	; 0x10816 <vfprintf+0x5ea>
   1080e:	14 fd       	sbrc	r17, 4
   10810:	16 60       	ori	r17, 0x06	; 6
   10812:	20 e1       	ldi	r18, 0x10	; 16
   10814:	32 e0       	ldi	r19, 0x02	; 2
   10816:	17 ff       	sbrs	r17, 7
   10818:	08 c0       	rjmp	.+16     	; 0x1082a <vfprintf+0x5fe>
   1081a:	f6 01       	movw	r30, r12
   1081c:	60 81       	ld	r22, Z
   1081e:	71 81       	ldd	r23, Z+1	; 0x01
   10820:	82 81       	ldd	r24, Z+2	; 0x02
   10822:	93 81       	ldd	r25, Z+3	; 0x03
   10824:	44 e0       	ldi	r20, 0x04	; 4
   10826:	50 e0       	ldi	r21, 0x00	; 0
   10828:	08 c0       	rjmp	.+16     	; 0x1083a <vfprintf+0x60e>
   1082a:	f6 01       	movw	r30, r12
   1082c:	80 81       	ld	r24, Z
   1082e:	91 81       	ldd	r25, Z+1	; 0x01
   10830:	bc 01       	movw	r22, r24
   10832:	80 e0       	ldi	r24, 0x00	; 0
   10834:	90 e0       	ldi	r25, 0x00	; 0
   10836:	42 e0       	ldi	r20, 0x02	; 2
   10838:	50 e0       	ldi	r21, 0x00	; 0
   1083a:	c4 0e       	add	r12, r20
   1083c:	d5 1e       	adc	r13, r21
   1083e:	ae 01       	movw	r20, r28
   10840:	4f 5f       	subi	r20, 0xFF	; 255
   10842:	5f 4f       	sbci	r21, 0xFF	; 255
   10844:	0e 94 b1 8c 	call	0x11962	; 0x11962 <__ultoa_invert>
   10848:	e8 2e       	mov	r14, r24
   1084a:	58 89       	ldd	r21, Y+16	; 0x10
   1084c:	e5 1a       	sub	r14, r21
   1084e:	8f e7       	ldi	r24, 0x7F	; 127
   10850:	f8 2e       	mov	r15, r24
   10852:	f1 22       	and	r15, r17
   10854:	f6 fe       	sbrs	r15, 6
   10856:	0b c0       	rjmp	.+22     	; 0x1086e <vfprintf+0x642>
   10858:	8e ef       	ldi	r24, 0xFE	; 254
   1085a:	f8 22       	and	r15, r24
   1085c:	e9 14       	cp	r14, r9
   1085e:	38 f4       	brcc	.+14     	; 0x1086e <vfprintf+0x642>
   10860:	f4 fe       	sbrs	r15, 4
   10862:	07 c0       	rjmp	.+14     	; 0x10872 <vfprintf+0x646>
   10864:	f2 fc       	sbrc	r15, 2
   10866:	05 c0       	rjmp	.+10     	; 0x10872 <vfprintf+0x646>
   10868:	9f ee       	ldi	r25, 0xEF	; 239
   1086a:	f9 22       	and	r15, r25
   1086c:	02 c0       	rjmp	.+4      	; 0x10872 <vfprintf+0x646>
   1086e:	1e 2d       	mov	r17, r14
   10870:	01 c0       	rjmp	.+2      	; 0x10874 <vfprintf+0x648>
   10872:	19 2d       	mov	r17, r9
   10874:	f4 fe       	sbrs	r15, 4
   10876:	0d c0       	rjmp	.+26     	; 0x10892 <vfprintf+0x666>
   10878:	fe 01       	movw	r30, r28
   1087a:	ee 0d       	add	r30, r14
   1087c:	f1 1d       	adc	r31, r1
   1087e:	80 81       	ld	r24, Z
   10880:	80 33       	cpi	r24, 0x30	; 48
   10882:	19 f4       	brne	.+6      	; 0x1088a <vfprintf+0x65e>
   10884:	e9 ee       	ldi	r30, 0xE9	; 233
   10886:	fe 22       	and	r15, r30
   10888:	08 c0       	rjmp	.+16     	; 0x1089a <vfprintf+0x66e>
   1088a:	1f 5f       	subi	r17, 0xFF	; 255
   1088c:	f2 fe       	sbrs	r15, 2
   1088e:	05 c0       	rjmp	.+10     	; 0x1089a <vfprintf+0x66e>
   10890:	03 c0       	rjmp	.+6      	; 0x10898 <vfprintf+0x66c>
   10892:	8f 2d       	mov	r24, r15
   10894:	86 78       	andi	r24, 0x86	; 134
   10896:	09 f0       	breq	.+2      	; 0x1089a <vfprintf+0x66e>
   10898:	1f 5f       	subi	r17, 0xFF	; 255
   1089a:	0f 2d       	mov	r16, r15
   1089c:	f3 fc       	sbrc	r15, 3
   1089e:	14 c0       	rjmp	.+40     	; 0x108c8 <vfprintf+0x69c>
   108a0:	f0 fe       	sbrs	r15, 0
   108a2:	0f c0       	rjmp	.+30     	; 0x108c2 <vfprintf+0x696>
   108a4:	18 15       	cp	r17, r8
   108a6:	10 f0       	brcs	.+4      	; 0x108ac <vfprintf+0x680>
   108a8:	9e 2c       	mov	r9, r14
   108aa:	0b c0       	rjmp	.+22     	; 0x108c2 <vfprintf+0x696>
   108ac:	9e 2c       	mov	r9, r14
   108ae:	98 0c       	add	r9, r8
   108b0:	91 1a       	sub	r9, r17
   108b2:	18 2d       	mov	r17, r8
   108b4:	06 c0       	rjmp	.+12     	; 0x108c2 <vfprintf+0x696>
   108b6:	80 e2       	ldi	r24, 0x20	; 32
   108b8:	90 e0       	ldi	r25, 0x00	; 0
   108ba:	b3 01       	movw	r22, r6
   108bc:	0e 94 c3 8b 	call	0x11786	; 0x11786 <fputc>
   108c0:	1f 5f       	subi	r17, 0xFF	; 255
   108c2:	18 15       	cp	r17, r8
   108c4:	c0 f3       	brcs	.-16     	; 0x108b6 <vfprintf+0x68a>
   108c6:	04 c0       	rjmp	.+8      	; 0x108d0 <vfprintf+0x6a4>
   108c8:	18 15       	cp	r17, r8
   108ca:	10 f4       	brcc	.+4      	; 0x108d0 <vfprintf+0x6a4>
   108cc:	81 1a       	sub	r8, r17
   108ce:	01 c0       	rjmp	.+2      	; 0x108d2 <vfprintf+0x6a6>
   108d0:	88 24       	eor	r8, r8
   108d2:	04 ff       	sbrs	r16, 4
   108d4:	0f c0       	rjmp	.+30     	; 0x108f4 <vfprintf+0x6c8>
   108d6:	80 e3       	ldi	r24, 0x30	; 48
   108d8:	90 e0       	ldi	r25, 0x00	; 0
   108da:	b3 01       	movw	r22, r6
   108dc:	0e 94 c3 8b 	call	0x11786	; 0x11786 <fputc>
   108e0:	02 ff       	sbrs	r16, 2
   108e2:	1d c0       	rjmp	.+58     	; 0x1091e <vfprintf+0x6f2>
   108e4:	01 fd       	sbrc	r16, 1
   108e6:	03 c0       	rjmp	.+6      	; 0x108ee <vfprintf+0x6c2>
   108e8:	88 e7       	ldi	r24, 0x78	; 120
   108ea:	90 e0       	ldi	r25, 0x00	; 0
   108ec:	0e c0       	rjmp	.+28     	; 0x1090a <vfprintf+0x6de>
   108ee:	88 e5       	ldi	r24, 0x58	; 88
   108f0:	90 e0       	ldi	r25, 0x00	; 0
   108f2:	0b c0       	rjmp	.+22     	; 0x1090a <vfprintf+0x6de>
   108f4:	80 2f       	mov	r24, r16
   108f6:	86 78       	andi	r24, 0x86	; 134
   108f8:	91 f0       	breq	.+36     	; 0x1091e <vfprintf+0x6f2>
   108fa:	01 ff       	sbrs	r16, 1
   108fc:	02 c0       	rjmp	.+4      	; 0x10902 <vfprintf+0x6d6>
   108fe:	8b e2       	ldi	r24, 0x2B	; 43
   10900:	01 c0       	rjmp	.+2      	; 0x10904 <vfprintf+0x6d8>
   10902:	80 e2       	ldi	r24, 0x20	; 32
   10904:	f7 fc       	sbrc	r15, 7
   10906:	8d e2       	ldi	r24, 0x2D	; 45
   10908:	90 e0       	ldi	r25, 0x00	; 0
   1090a:	b3 01       	movw	r22, r6
   1090c:	0e 94 c3 8b 	call	0x11786	; 0x11786 <fputc>
   10910:	06 c0       	rjmp	.+12     	; 0x1091e <vfprintf+0x6f2>
   10912:	80 e3       	ldi	r24, 0x30	; 48
   10914:	90 e0       	ldi	r25, 0x00	; 0
   10916:	b3 01       	movw	r22, r6
   10918:	0e 94 c3 8b 	call	0x11786	; 0x11786 <fputc>
   1091c:	9a 94       	dec	r9
   1091e:	e9 14       	cp	r14, r9
   10920:	c0 f3       	brcs	.-16     	; 0x10912 <vfprintf+0x6e6>
   10922:	ea 94       	dec	r14
   10924:	e1 e0       	ldi	r30, 0x01	; 1
   10926:	f0 e0       	ldi	r31, 0x00	; 0
   10928:	ec 0f       	add	r30, r28
   1092a:	fd 1f       	adc	r31, r29
   1092c:	ee 0d       	add	r30, r14
   1092e:	f1 1d       	adc	r31, r1
   10930:	80 81       	ld	r24, Z
   10932:	90 e0       	ldi	r25, 0x00	; 0
   10934:	b3 01       	movw	r22, r6
   10936:	0e 94 c3 8b 	call	0x11786	; 0x11786 <fputc>
   1093a:	ee 20       	and	r14, r14
   1093c:	91 f7       	brne	.-28     	; 0x10922 <vfprintf+0x6f6>
   1093e:	06 c0       	rjmp	.+12     	; 0x1094c <vfprintf+0x720>
   10940:	80 e2       	ldi	r24, 0x20	; 32
   10942:	90 e0       	ldi	r25, 0x00	; 0
   10944:	b3 01       	movw	r22, r6
   10946:	0e 94 c3 8b 	call	0x11786	; 0x11786 <fputc>
   1094a:	8a 94       	dec	r8
   1094c:	88 20       	and	r8, r8
   1094e:	c1 f7       	brne	.-16     	; 0x10940 <vfprintf+0x714>
   10950:	99 cc       	rjmp	.-1742   	; 0x10284 <vfprintf+0x58>
   10952:	f3 01       	movw	r30, r6
   10954:	66 81       	ldd	r22, Z+6	; 0x06
   10956:	77 81       	ldd	r23, Z+7	; 0x07
   10958:	cb 01       	movw	r24, r22
   1095a:	61 96       	adiw	r28, 0x11	; 17
   1095c:	0f b6       	in	r0, 0x3f	; 63
   1095e:	f8 94       	cli
   10960:	de bf       	out	0x3e, r29	; 62
   10962:	0f be       	out	0x3f, r0	; 63
   10964:	cd bf       	out	0x3d, r28	; 61
   10966:	cf 91       	pop	r28
   10968:	df 91       	pop	r29
   1096a:	1f 91       	pop	r17
   1096c:	0f 91       	pop	r16
   1096e:	ff 90       	pop	r15
   10970:	ef 90       	pop	r14
   10972:	df 90       	pop	r13
   10974:	cf 90       	pop	r12
   10976:	bf 90       	pop	r11
   10978:	af 90       	pop	r10
   1097a:	9f 90       	pop	r9
   1097c:	8f 90       	pop	r8
   1097e:	7f 90       	pop	r7
   10980:	6f 90       	pop	r6
   10982:	5f 90       	pop	r5
   10984:	4f 90       	pop	r4
   10986:	3f 90       	pop	r3
   10988:	2f 90       	pop	r2
   1098a:	08 95       	ret

0001098c <putval>:
   1098c:	fc 01       	movw	r30, r24
   1098e:	20 fd       	sbrc	r18, 0
   10990:	08 c0       	rjmp	.+16     	; 0x109a2 <putval+0x16>
   10992:	23 fd       	sbrc	r18, 3
   10994:	05 c0       	rjmp	.+10     	; 0x109a0 <putval+0x14>
   10996:	22 ff       	sbrs	r18, 2
   10998:	02 c0       	rjmp	.+4      	; 0x1099e <putval+0x12>
   1099a:	73 83       	std	Z+3, r23	; 0x03
   1099c:	62 83       	std	Z+2, r22	; 0x02
   1099e:	51 83       	std	Z+1, r21	; 0x01
   109a0:	40 83       	st	Z, r20
   109a2:	08 95       	ret

000109a4 <mulacc>:
   109a4:	ef 92       	push	r14
   109a6:	ff 92       	push	r15
   109a8:	0f 93       	push	r16
   109aa:	1f 93       	push	r17
   109ac:	44 ff       	sbrs	r20, 4
   109ae:	02 c0       	rjmp	.+4      	; 0x109b4 <mulacc+0x10>
   109b0:	33 e0       	ldi	r19, 0x03	; 3
   109b2:	11 c0       	rjmp	.+34     	; 0x109d6 <mulacc+0x32>
   109b4:	46 ff       	sbrs	r20, 6
   109b6:	02 c0       	rjmp	.+4      	; 0x109bc <mulacc+0x18>
   109b8:	34 e0       	ldi	r19, 0x04	; 4
   109ba:	0d c0       	rjmp	.+26     	; 0x109d6 <mulacc+0x32>
   109bc:	db 01       	movw	r26, r22
   109be:	fc 01       	movw	r30, r24
   109c0:	aa 0f       	add	r26, r26
   109c2:	bb 1f       	adc	r27, r27
   109c4:	ee 1f       	adc	r30, r30
   109c6:	ff 1f       	adc	r31, r31
   109c8:	10 94       	com	r1
   109ca:	d1 f7       	brne	.-12     	; 0x109c0 <mulacc+0x1c>
   109cc:	6a 0f       	add	r22, r26
   109ce:	7b 1f       	adc	r23, r27
   109d0:	8e 1f       	adc	r24, r30
   109d2:	9f 1f       	adc	r25, r31
   109d4:	31 e0       	ldi	r19, 0x01	; 1
   109d6:	66 0f       	add	r22, r22
   109d8:	77 1f       	adc	r23, r23
   109da:	88 1f       	adc	r24, r24
   109dc:	99 1f       	adc	r25, r25
   109de:	31 50       	subi	r19, 0x01	; 1
   109e0:	d1 f7       	brne	.-12     	; 0x109d6 <mulacc+0x32>
   109e2:	7b 01       	movw	r14, r22
   109e4:	8c 01       	movw	r16, r24
   109e6:	e2 0e       	add	r14, r18
   109e8:	f1 1c       	adc	r15, r1
   109ea:	01 1d       	adc	r16, r1
   109ec:	11 1d       	adc	r17, r1
   109ee:	a8 01       	movw	r20, r16
   109f0:	97 01       	movw	r18, r14
   109f2:	b7 01       	movw	r22, r14
   109f4:	ca 01       	movw	r24, r20
   109f6:	1f 91       	pop	r17
   109f8:	0f 91       	pop	r16
   109fa:	ff 90       	pop	r15
   109fc:	ef 90       	pop	r14
   109fe:	08 95       	ret

00010a00 <skip_spaces>:
   10a00:	0f 93       	push	r16
   10a02:	1f 93       	push	r17
   10a04:	cf 93       	push	r28
   10a06:	df 93       	push	r29
   10a08:	8c 01       	movw	r16, r24
   10a0a:	c8 01       	movw	r24, r16
   10a0c:	0e 94 81 8b 	call	0x11702	; 0x11702 <fgetc>
   10a10:	ec 01       	movw	r28, r24
   10a12:	97 fd       	sbrc	r25, 7
   10a14:	08 c0       	rjmp	.+16     	; 0x10a26 <skip_spaces+0x26>
   10a16:	0e 94 d8 8a 	call	0x115b0	; 0x115b0 <isspace>
   10a1a:	89 2b       	or	r24, r25
   10a1c:	b1 f7       	brne	.-20     	; 0x10a0a <skip_spaces+0xa>
   10a1e:	ce 01       	movw	r24, r28
   10a20:	b8 01       	movw	r22, r16
   10a22:	0e 94 97 8c 	call	0x1192e	; 0x1192e <ungetc>
   10a26:	ce 01       	movw	r24, r28
   10a28:	df 91       	pop	r29
   10a2a:	cf 91       	pop	r28
   10a2c:	1f 91       	pop	r17
   10a2e:	0f 91       	pop	r16
   10a30:	08 95       	ret

00010a32 <conv_int>:
   10a32:	8f 92       	push	r8
   10a34:	9f 92       	push	r9
   10a36:	af 92       	push	r10
   10a38:	bf 92       	push	r11
   10a3a:	df 92       	push	r13
   10a3c:	ef 92       	push	r14
   10a3e:	ff 92       	push	r15
   10a40:	0f 93       	push	r16
   10a42:	1f 93       	push	r17
   10a44:	cf 93       	push	r28
   10a46:	df 93       	push	r29
   10a48:	5c 01       	movw	r10, r24
   10a4a:	eb 01       	movw	r28, r22
   10a4c:	4a 01       	movw	r8, r20
   10a4e:	12 2f       	mov	r17, r18
   10a50:	0e 94 81 8b 	call	0x11702	; 0x11702 <fgetc>
   10a54:	ac 01       	movw	r20, r24
   10a56:	8b 32       	cpi	r24, 0x2B	; 43
   10a58:	19 f0       	breq	.+6      	; 0x10a60 <conv_int+0x2e>
   10a5a:	8d 32       	cpi	r24, 0x2D	; 45
   10a5c:	51 f4       	brne	.+20     	; 0x10a72 <conv_int+0x40>
   10a5e:	10 68       	ori	r17, 0x80	; 128
   10a60:	21 97       	sbiw	r28, 0x01	; 1
   10a62:	09 f4       	brne	.+2      	; 0x10a66 <conv_int+0x34>
   10a64:	6d c0       	rjmp	.+218    	; 0x10b40 <conv_int+0x10e>
   10a66:	c5 01       	movw	r24, r10
   10a68:	0e 94 81 8b 	call	0x11702	; 0x11702 <fgetc>
   10a6c:	ac 01       	movw	r20, r24
   10a6e:	97 fd       	sbrc	r25, 7
   10a70:	67 c0       	rjmp	.+206    	; 0x10b40 <conv_int+0x10e>
   10a72:	6d ef       	ldi	r22, 0xFD	; 253
   10a74:	d6 2e       	mov	r13, r22
   10a76:	d1 22       	and	r13, r17
   10a78:	8d 2d       	mov	r24, r13
   10a7a:	80 73       	andi	r24, 0x30	; 48
   10a7c:	01 f5       	brne	.+64     	; 0x10abe <conv_int+0x8c>
   10a7e:	40 33       	cpi	r20, 0x30	; 48
   10a80:	f1 f4       	brne	.+60     	; 0x10abe <conv_int+0x8c>
   10a82:	21 97       	sbiw	r28, 0x01	; 1
   10a84:	09 f4       	brne	.+2      	; 0x10a88 <conv_int+0x56>
   10a86:	47 c0       	rjmp	.+142    	; 0x10b16 <conv_int+0xe4>
   10a88:	c5 01       	movw	r24, r10
   10a8a:	0e 94 81 8b 	call	0x11702	; 0x11702 <fgetc>
   10a8e:	ac 01       	movw	r20, r24
   10a90:	97 fd       	sbrc	r25, 7
   10a92:	41 c0       	rjmp	.+130    	; 0x10b16 <conv_int+0xe4>
   10a94:	82 e0       	ldi	r24, 0x02	; 2
   10a96:	d8 2a       	or	r13, r24
   10a98:	48 37       	cpi	r20, 0x78	; 120
   10a9a:	11 f0       	breq	.+4      	; 0x10aa0 <conv_int+0x6e>
   10a9c:	48 35       	cpi	r20, 0x58	; 88
   10a9e:	59 f4       	brne	.+22     	; 0x10ab6 <conv_int+0x84>
   10aa0:	80 e4       	ldi	r24, 0x40	; 64
   10aa2:	d8 2a       	or	r13, r24
   10aa4:	21 97       	sbiw	r28, 0x01	; 1
   10aa6:	b9 f1       	breq	.+110    	; 0x10b16 <conv_int+0xe4>
   10aa8:	c5 01       	movw	r24, r10
   10aaa:	0e 94 81 8b 	call	0x11702	; 0x11702 <fgetc>
   10aae:	ac 01       	movw	r20, r24
   10ab0:	99 23       	and	r25, r25
   10ab2:	2c f4       	brge	.+10     	; 0x10abe <conv_int+0x8c>
   10ab4:	30 c0       	rjmp	.+96     	; 0x10b16 <conv_int+0xe4>
   10ab6:	d6 fc       	sbrc	r13, 6
   10ab8:	02 c0       	rjmp	.+4      	; 0x10abe <conv_int+0x8c>
   10aba:	80 e1       	ldi	r24, 0x10	; 16
   10abc:	d8 2a       	or	r13, r24
   10abe:	ee 24       	eor	r14, r14
   10ac0:	ff 24       	eor	r15, r15
   10ac2:	87 01       	movw	r16, r14
   10ac4:	24 2f       	mov	r18, r20
   10ac6:	20 53       	subi	r18, 0x30	; 48
   10ac8:	28 30       	cpi	r18, 0x08	; 8
   10aca:	88 f0       	brcs	.+34     	; 0x10aee <conv_int+0xbc>
   10acc:	d4 fc       	sbrc	r13, 4
   10ace:	09 c0       	rjmp	.+18     	; 0x10ae2 <conv_int+0xb0>
   10ad0:	2a 30       	cpi	r18, 0x0A	; 10
   10ad2:	68 f0       	brcs	.+26     	; 0x10aee <conv_int+0xbc>
   10ad4:	d6 fe       	sbrs	r13, 6
   10ad6:	05 c0       	rjmp	.+10     	; 0x10ae2 <conv_int+0xb0>
   10ad8:	2f 7d       	andi	r18, 0xDF	; 223
   10ada:	82 2f       	mov	r24, r18
   10adc:	81 51       	subi	r24, 0x11	; 17
   10ade:	86 30       	cpi	r24, 0x06	; 6
   10ae0:	28 f0       	brcs	.+10     	; 0x10aec <conv_int+0xba>
   10ae2:	ca 01       	movw	r24, r20
   10ae4:	b5 01       	movw	r22, r10
   10ae6:	0e 94 97 8c 	call	0x1192e	; 0x1192e <ungetc>
   10aea:	12 c0       	rjmp	.+36     	; 0x10b10 <conv_int+0xde>
   10aec:	27 50       	subi	r18, 0x07	; 7
   10aee:	c8 01       	movw	r24, r16
   10af0:	b7 01       	movw	r22, r14
   10af2:	4d 2d       	mov	r20, r13
   10af4:	0e 94 d2 84 	call	0x109a4	; 0x109a4 <mulacc>
   10af8:	7b 01       	movw	r14, r22
   10afa:	8c 01       	movw	r16, r24
   10afc:	82 e0       	ldi	r24, 0x02	; 2
   10afe:	d8 2a       	or	r13, r24
   10b00:	21 97       	sbiw	r28, 0x01	; 1
   10b02:	61 f0       	breq	.+24     	; 0x10b1c <conv_int+0xea>
   10b04:	c5 01       	movw	r24, r10
   10b06:	0e 94 81 8b 	call	0x11702	; 0x11702 <fgetc>
   10b0a:	ac 01       	movw	r20, r24
   10b0c:	97 ff       	sbrs	r25, 7
   10b0e:	da cf       	rjmp	.-76     	; 0x10ac4 <conv_int+0x92>
   10b10:	d1 fc       	sbrc	r13, 1
   10b12:	04 c0       	rjmp	.+8      	; 0x10b1c <conv_int+0xea>
   10b14:	15 c0       	rjmp	.+42     	; 0x10b40 <conv_int+0x10e>
   10b16:	ee 24       	eor	r14, r14
   10b18:	ff 24       	eor	r15, r15
   10b1a:	87 01       	movw	r16, r14
   10b1c:	d7 fe       	sbrs	r13, 7
   10b1e:	08 c0       	rjmp	.+16     	; 0x10b30 <conv_int+0xfe>
   10b20:	10 95       	com	r17
   10b22:	00 95       	com	r16
   10b24:	f0 94       	com	r15
   10b26:	e0 94       	com	r14
   10b28:	e1 1c       	adc	r14, r1
   10b2a:	f1 1c       	adc	r15, r1
   10b2c:	01 1d       	adc	r16, r1
   10b2e:	11 1d       	adc	r17, r1
   10b30:	c4 01       	movw	r24, r8
   10b32:	b8 01       	movw	r22, r16
   10b34:	a7 01       	movw	r20, r14
   10b36:	2d 2d       	mov	r18, r13
   10b38:	0e 94 c6 84 	call	0x1098c	; 0x1098c <putval>
   10b3c:	81 e0       	ldi	r24, 0x01	; 1
   10b3e:	01 c0       	rjmp	.+2      	; 0x10b42 <conv_int+0x110>
   10b40:	80 e0       	ldi	r24, 0x00	; 0
   10b42:	df 91       	pop	r29
   10b44:	cf 91       	pop	r28
   10b46:	1f 91       	pop	r17
   10b48:	0f 91       	pop	r16
   10b4a:	ff 90       	pop	r15
   10b4c:	ef 90       	pop	r14
   10b4e:	df 90       	pop	r13
   10b50:	bf 90       	pop	r11
   10b52:	af 90       	pop	r10
   10b54:	9f 90       	pop	r9
   10b56:	8f 90       	pop	r8
   10b58:	08 95       	ret

00010b5a <conv_brk>:
   10b5a:	6f 92       	push	r6
   10b5c:	7f 92       	push	r7
   10b5e:	8f 92       	push	r8
   10b60:	9f 92       	push	r9
   10b62:	af 92       	push	r10
   10b64:	bf 92       	push	r11
   10b66:	cf 92       	push	r12
   10b68:	df 92       	push	r13
   10b6a:	ef 92       	push	r14
   10b6c:	ff 92       	push	r15
   10b6e:	0f 93       	push	r16
   10b70:	1f 93       	push	r17
   10b72:	df 93       	push	r29
   10b74:	cf 93       	push	r28
   10b76:	cd b7       	in	r28, 0x3d	; 61
   10b78:	de b7       	in	r29, 0x3e	; 62
   10b7a:	a0 97       	sbiw	r28, 0x20	; 32
   10b7c:	0f b6       	in	r0, 0x3f	; 63
   10b7e:	f8 94       	cli
   10b80:	de bf       	out	0x3e, r29	; 62
   10b82:	0f be       	out	0x3f, r0	; 63
   10b84:	cd bf       	out	0x3d, r28	; 61
   10b86:	5c 01       	movw	r10, r24
   10b88:	6b 01       	movw	r12, r22
   10b8a:	8a 01       	movw	r16, r20
   10b8c:	79 01       	movw	r14, r18
   10b8e:	fe 01       	movw	r30, r28
   10b90:	31 96       	adiw	r30, 0x01	; 1
   10b92:	80 e2       	ldi	r24, 0x20	; 32
   10b94:	df 01       	movw	r26, r30
   10b96:	1d 92       	st	X+, r1
   10b98:	8a 95       	dec	r24
   10b9a:	e9 f7       	brne	.-6      	; 0x10b96 <conv_brk+0x3c>
   10b9c:	70 e0       	ldi	r23, 0x00	; 0
   10b9e:	30 e0       	ldi	r19, 0x00	; 0
   10ba0:	60 e0       	ldi	r22, 0x00	; 0
   10ba2:	40 e0       	ldi	r20, 0x00	; 0
   10ba4:	50 e0       	ldi	r21, 0x00	; 0
   10ba6:	3f 01       	movw	r6, r30
   10ba8:	a1 e0       	ldi	r26, 0x01	; 1
   10baa:	b0 e0       	ldi	r27, 0x00	; 0
   10bac:	f5 01       	movw	r30, r10
   10bae:	83 81       	ldd	r24, Z+3	; 0x03
   10bb0:	f7 01       	movw	r30, r14
   10bb2:	83 fd       	sbrc	r24, 3
   10bb4:	25 91       	lpm	r18, Z+
   10bb6:	83 ff       	sbrs	r24, 3
   10bb8:	21 91       	ld	r18, Z+
   10bba:	7f 01       	movw	r14, r30
   10bbc:	22 23       	and	r18, r18
   10bbe:	09 f4       	brne	.+2      	; 0x10bc2 <conv_brk+0x68>
   10bc0:	81 c0       	rjmp	.+258    	; 0x10cc4 <conv_brk+0x16a>
   10bc2:	2e 35       	cpi	r18, 0x5E	; 94
   10bc4:	19 f4       	brne	.+6      	; 0x10bcc <conv_brk+0x72>
   10bc6:	41 15       	cp	r20, r1
   10bc8:	51 05       	cpc	r21, r1
   10bca:	69 f1       	breq	.+90     	; 0x10c26 <conv_brk+0xcc>
   10bcc:	87 2f       	mov	r24, r23
   10bce:	90 e0       	ldi	r25, 0x00	; 0
   10bd0:	84 17       	cp	r24, r20
   10bd2:	95 07       	cpc	r25, r21
   10bd4:	44 f4       	brge	.+16     	; 0x10be6 <conv_brk+0x8c>
   10bd6:	2d 35       	cpi	r18, 0x5D	; 93
   10bd8:	51 f1       	breq	.+84     	; 0x10c2e <conv_brk+0xd4>
   10bda:	2d 32       	cpi	r18, 0x2D	; 45
   10bdc:	21 f4       	brne	.+8      	; 0x10be6 <conv_brk+0x8c>
   10bde:	33 23       	and	r19, r19
   10be0:	29 f4       	brne	.+10     	; 0x10bec <conv_brk+0x92>
   10be2:	31 e0       	ldi	r19, 0x01	; 1
   10be4:	21 c0       	rjmp	.+66     	; 0x10c28 <conv_brk+0xce>
   10be6:	33 23       	and	r19, r19
   10be8:	09 f4       	brne	.+2      	; 0x10bec <conv_brk+0x92>
   10bea:	62 2f       	mov	r22, r18
   10bec:	32 2f       	mov	r19, r18
   10bee:	83 2f       	mov	r24, r19
   10bf0:	86 95       	lsr	r24
   10bf2:	86 95       	lsr	r24
   10bf4:	86 95       	lsr	r24
   10bf6:	f3 01       	movw	r30, r6
   10bf8:	e8 0f       	add	r30, r24
   10bfa:	f1 1d       	adc	r31, r1
   10bfc:	83 2f       	mov	r24, r19
   10bfe:	87 70       	andi	r24, 0x07	; 7
   10c00:	4d 01       	movw	r8, r26
   10c02:	02 c0       	rjmp	.+4      	; 0x10c08 <conv_brk+0xae>
   10c04:	88 0c       	add	r8, r8
   10c06:	99 1c       	adc	r9, r9
   10c08:	8a 95       	dec	r24
   10c0a:	e2 f7       	brpl	.-8      	; 0x10c04 <conv_brk+0xaa>
   10c0c:	20 81       	ld	r18, Z
   10c0e:	28 29       	or	r18, r8
   10c10:	20 83       	st	Z, r18
   10c12:	36 17       	cp	r19, r22
   10c14:	11 f4       	brne	.+4      	; 0x10c1a <conv_brk+0xc0>
   10c16:	30 e0       	ldi	r19, 0x00	; 0
   10c18:	07 c0       	rjmp	.+14     	; 0x10c28 <conv_brk+0xce>
   10c1a:	36 17       	cp	r19, r22
   10c1c:	10 f4       	brcc	.+4      	; 0x10c22 <conv_brk+0xc8>
   10c1e:	3f 5f       	subi	r19, 0xFF	; 255
   10c20:	e6 cf       	rjmp	.-52     	; 0x10bee <conv_brk+0x94>
   10c22:	31 50       	subi	r19, 0x01	; 1
   10c24:	e4 cf       	rjmp	.-56     	; 0x10bee <conv_brk+0x94>
   10c26:	71 e0       	ldi	r23, 0x01	; 1
   10c28:	4f 5f       	subi	r20, 0xFF	; 255
   10c2a:	5f 4f       	sbci	r21, 0xFF	; 255
   10c2c:	bf cf       	rjmp	.-130    	; 0x10bac <conv_brk+0x52>
   10c2e:	33 23       	and	r19, r19
   10c30:	19 f0       	breq	.+6      	; 0x10c38 <conv_brk+0xde>
   10c32:	8e 81       	ldd	r24, Y+6	; 0x06
   10c34:	80 62       	ori	r24, 0x20	; 32
   10c36:	8e 83       	std	Y+6, r24	; 0x06
   10c38:	77 23       	and	r23, r23
   10c3a:	59 f0       	breq	.+22     	; 0x10c52 <conv_brk+0xf8>
   10c3c:	fe 01       	movw	r30, r28
   10c3e:	31 96       	adiw	r30, 0x01	; 1
   10c40:	9e 01       	movw	r18, r28
   10c42:	2f 5d       	subi	r18, 0xDF	; 223
   10c44:	3f 4f       	sbci	r19, 0xFF	; 255
   10c46:	80 81       	ld	r24, Z
   10c48:	80 95       	com	r24
   10c4a:	81 93       	st	Z+, r24
   10c4c:	e2 17       	cp	r30, r18
   10c4e:	f3 07       	cpc	r31, r19
   10c50:	d1 f7       	brne	.-12     	; 0x10c46 <conv_brk+0xec>
   10c52:	99 24       	eor	r9, r9
   10c54:	93 94       	inc	r9
   10c56:	3e 01       	movw	r6, r28
   10c58:	08 94       	sec
   10c5a:	61 1c       	adc	r6, r1
   10c5c:	71 1c       	adc	r7, r1
   10c5e:	c5 01       	movw	r24, r10
   10c60:	0e 94 81 8b 	call	0x11702	; 0x11702 <fgetc>
   10c64:	ac 01       	movw	r20, r24
   10c66:	97 fd       	sbrc	r25, 7
   10c68:	25 c0       	rjmp	.+74     	; 0x10cb4 <conv_brk+0x15a>
   10c6a:	86 95       	lsr	r24
   10c6c:	86 95       	lsr	r24
   10c6e:	86 95       	lsr	r24
   10c70:	f3 01       	movw	r30, r6
   10c72:	e8 0f       	add	r30, r24
   10c74:	f1 1d       	adc	r31, r1
   10c76:	80 81       	ld	r24, Z
   10c78:	90 e0       	ldi	r25, 0x00	; 0
   10c7a:	9a 01       	movw	r18, r20
   10c7c:	27 70       	andi	r18, 0x07	; 7
   10c7e:	30 70       	andi	r19, 0x00	; 0
   10c80:	02 c0       	rjmp	.+4      	; 0x10c86 <conv_brk+0x12c>
   10c82:	95 95       	asr	r25
   10c84:	87 95       	ror	r24
   10c86:	2a 95       	dec	r18
   10c88:	e2 f7       	brpl	.-8      	; 0x10c82 <conv_brk+0x128>
   10c8a:	80 fd       	sbrc	r24, 0
   10c8c:	05 c0       	rjmp	.+10     	; 0x10c98 <conv_brk+0x13e>
   10c8e:	ca 01       	movw	r24, r20
   10c90:	b5 01       	movw	r22, r10
   10c92:	0e 94 97 8c 	call	0x1192e	; 0x1192e <ungetc>
   10c96:	0e c0       	rjmp	.+28     	; 0x10cb4 <conv_brk+0x15a>
   10c98:	01 15       	cp	r16, r1
   10c9a:	11 05       	cpc	r17, r1
   10c9c:	19 f0       	breq	.+6      	; 0x10ca4 <conv_brk+0x14a>
   10c9e:	d8 01       	movw	r26, r16
   10ca0:	4d 93       	st	X+, r20
   10ca2:	8d 01       	movw	r16, r26
   10ca4:	08 94       	sec
   10ca6:	c1 08       	sbc	r12, r1
   10ca8:	d1 08       	sbc	r13, r1
   10caa:	99 24       	eor	r9, r9
   10cac:	c1 14       	cp	r12, r1
   10cae:	d1 04       	cpc	r13, r1
   10cb0:	b1 f6       	brne	.-84     	; 0x10c5e <conv_brk+0x104>
   10cb2:	02 c0       	rjmp	.+4      	; 0x10cb8 <conv_brk+0x15e>
   10cb4:	99 20       	and	r9, r9
   10cb6:	31 f4       	brne	.+12     	; 0x10cc4 <conv_brk+0x16a>
   10cb8:	01 15       	cp	r16, r1
   10cba:	11 05       	cpc	r17, r1
   10cbc:	29 f0       	breq	.+10     	; 0x10cc8 <conv_brk+0x16e>
   10cbe:	f8 01       	movw	r30, r16
   10cc0:	10 82       	st	Z, r1
   10cc2:	02 c0       	rjmp	.+4      	; 0x10cc8 <conv_brk+0x16e>
   10cc4:	ee 24       	eor	r14, r14
   10cc6:	ff 24       	eor	r15, r15
   10cc8:	c7 01       	movw	r24, r14
   10cca:	a0 96       	adiw	r28, 0x20	; 32
   10ccc:	0f b6       	in	r0, 0x3f	; 63
   10cce:	f8 94       	cli
   10cd0:	de bf       	out	0x3e, r29	; 62
   10cd2:	0f be       	out	0x3f, r0	; 63
   10cd4:	cd bf       	out	0x3d, r28	; 61
   10cd6:	cf 91       	pop	r28
   10cd8:	df 91       	pop	r29
   10cda:	1f 91       	pop	r17
   10cdc:	0f 91       	pop	r16
   10cde:	ff 90       	pop	r15
   10ce0:	ef 90       	pop	r14
   10ce2:	df 90       	pop	r13
   10ce4:	cf 90       	pop	r12
   10ce6:	bf 90       	pop	r11
   10ce8:	af 90       	pop	r10
   10cea:	9f 90       	pop	r9
   10cec:	8f 90       	pop	r8
   10cee:	7f 90       	pop	r7
   10cf0:	6f 90       	pop	r6
   10cf2:	08 95       	ret

00010cf4 <conv_flt>:
   10cf4:	2f 92       	push	r2
   10cf6:	3f 92       	push	r3
   10cf8:	5f 92       	push	r5
   10cfa:	6f 92       	push	r6
   10cfc:	7f 92       	push	r7
   10cfe:	8f 92       	push	r8
   10d00:	9f 92       	push	r9
   10d02:	af 92       	push	r10
   10d04:	bf 92       	push	r11
   10d06:	cf 92       	push	r12
   10d08:	df 92       	push	r13
   10d0a:	ef 92       	push	r14
   10d0c:	ff 92       	push	r15
   10d0e:	0f 93       	push	r16
   10d10:	1f 93       	push	r17
   10d12:	cf 93       	push	r28
   10d14:	df 93       	push	r29
   10d16:	3c 01       	movw	r6, r24
   10d18:	7b 01       	movw	r14, r22
   10d1a:	1a 01       	movw	r2, r20
   10d1c:	0e 94 81 8b 	call	0x11702	; 0x11702 <fgetc>
   10d20:	ec 01       	movw	r28, r24
   10d22:	8b 32       	cpi	r24, 0x2B	; 43
   10d24:	39 f0       	breq	.+14     	; 0x10d34 <conv_flt+0x40>
   10d26:	8d 32       	cpi	r24, 0x2D	; 45
   10d28:	11 f0       	breq	.+4      	; 0x10d2e <conv_flt+0x3a>
   10d2a:	55 24       	eor	r5, r5
   10d2c:	11 c0       	rjmp	.+34     	; 0x10d50 <conv_flt+0x5c>
   10d2e:	b0 e8       	ldi	r27, 0x80	; 128
   10d30:	5b 2e       	mov	r5, r27
   10d32:	01 c0       	rjmp	.+2      	; 0x10d36 <conv_flt+0x42>
   10d34:	55 24       	eor	r5, r5
   10d36:	08 94       	sec
   10d38:	e1 08       	sbc	r14, r1
   10d3a:	f1 08       	sbc	r15, r1
   10d3c:	e1 14       	cp	r14, r1
   10d3e:	f1 04       	cpc	r15, r1
   10d40:	09 f4       	brne	.+2      	; 0x10d44 <conv_flt+0x50>
   10d42:	18 c1       	rjmp	.+560    	; 0x10f74 <conv_flt+0x280>
   10d44:	c3 01       	movw	r24, r6
   10d46:	0e 94 81 8b 	call	0x11702	; 0x11702 <fgetc>
   10d4a:	ec 01       	movw	r28, r24
   10d4c:	97 fd       	sbrc	r25, 7
   10d4e:	12 c1       	rjmp	.+548    	; 0x10f74 <conv_flt+0x280>
   10d50:	ce 01       	movw	r24, r28
   10d52:	0e 94 e0 8a 	call	0x115c0	; 0x115c0 <tolower>
   10d56:	89 36       	cpi	r24, 0x69	; 105
   10d58:	91 05       	cpc	r25, r1
   10d5a:	21 f0       	breq	.+8      	; 0x10d64 <conv_flt+0x70>
   10d5c:	8e 36       	cpi	r24, 0x6E	; 110
   10d5e:	91 05       	cpc	r25, r1
   10d60:	99 f5       	brne	.+102    	; 0x10dc8 <conv_flt+0xd4>
   10d62:	1d c0       	rjmp	.+58     	; 0x10d9e <conv_flt+0xaa>
   10d64:	0b ee       	ldi	r16, 0xEB	; 235
   10d66:	12 e0       	ldi	r17, 0x02	; 2
   10d68:	1c c0       	rjmp	.+56     	; 0x10da2 <conv_flt+0xae>
   10d6a:	08 94       	sec
   10d6c:	e1 08       	sbc	r14, r1
   10d6e:	f1 08       	sbc	r15, r1
   10d70:	e1 14       	cp	r14, r1
   10d72:	f1 04       	cpc	r15, r1
   10d74:	71 f0       	breq	.+28     	; 0x10d92 <conv_flt+0x9e>
   10d76:	c3 01       	movw	r24, r6
   10d78:	0e 94 81 8b 	call	0x11702	; 0x11702 <fgetc>
   10d7c:	ec 01       	movw	r28, r24
   10d7e:	97 fd       	sbrc	r25, 7
   10d80:	08 c0       	rjmp	.+16     	; 0x10d92 <conv_flt+0x9e>
   10d82:	0e 94 e0 8a 	call	0x115c0	; 0x115c0 <tolower>
   10d86:	d8 16       	cp	r13, r24
   10d88:	61 f0       	breq	.+24     	; 0x10da2 <conv_flt+0xae>
   10d8a:	ce 01       	movw	r24, r28
   10d8c:	b3 01       	movw	r22, r6
   10d8e:	0e 94 97 8c 	call	0x1192e	; 0x1192e <ungetc>
   10d92:	22 e0       	ldi	r18, 0x02	; 2
   10d94:	0e 3e       	cpi	r16, 0xEE	; 238
   10d96:	12 07       	cpc	r17, r18
   10d98:	09 f0       	breq	.+2      	; 0x10d9c <conv_flt+0xa8>
   10d9a:	ec c0       	rjmp	.+472    	; 0x10f74 <conv_flt+0x280>
   10d9c:	08 c0       	rjmp	.+16     	; 0x10dae <conv_flt+0xba>
   10d9e:	08 ee       	ldi	r16, 0xE8	; 232
   10da0:	12 e0       	ldi	r17, 0x02	; 2
   10da2:	f8 01       	movw	r30, r16
   10da4:	0f 5f       	subi	r16, 0xFF	; 255
   10da6:	1f 4f       	sbci	r17, 0xFF	; 255
   10da8:	d4 90       	lpm	r13, Z+
   10daa:	dd 20       	and	r13, r13
   10dac:	f1 f6       	brne	.-68     	; 0x10d6a <conv_flt+0x76>
   10dae:	0b 5e       	subi	r16, 0xEB	; 235
   10db0:	12 40       	sbci	r17, 0x02	; 2
   10db2:	29 f0       	breq	.+10     	; 0x10dbe <conv_flt+0xca>
   10db4:	80 e0       	ldi	r24, 0x00	; 0
   10db6:	90 e0       	ldi	r25, 0x00	; 0
   10db8:	a0 e8       	ldi	r26, 0x80	; 128
   10dba:	bf e7       	ldi	r27, 0x7F	; 127
   10dbc:	cf c0       	rjmp	.+414    	; 0x10f5c <conv_flt+0x268>
   10dbe:	80 e0       	ldi	r24, 0x00	; 0
   10dc0:	90 e0       	ldi	r25, 0x00	; 0
   10dc2:	a0 ec       	ldi	r26, 0xC0	; 192
   10dc4:	bf e7       	ldi	r27, 0x7F	; 127
   10dc6:	ca c0       	rjmp	.+404    	; 0x10f5c <conv_flt+0x268>
   10dc8:	cc 24       	eor	r12, r12
   10dca:	dd 24       	eor	r13, r13
   10dcc:	88 24       	eor	r8, r8
   10dce:	99 24       	eor	r9, r9
   10dd0:	54 01       	movw	r10, r8
   10dd2:	ae 01       	movw	r20, r28
   10dd4:	40 53       	subi	r20, 0x30	; 48
   10dd6:	24 2f       	mov	r18, r20
   10dd8:	4a 30       	cpi	r20, 0x0A	; 10
   10dda:	38 f5       	brcc	.+78     	; 0x10e2a <conv_flt+0x136>
   10ddc:	52 e0       	ldi	r21, 0x02	; 2
   10dde:	55 2a       	or	r5, r21
   10de0:	85 2d       	mov	r24, r5
   10de2:	90 e0       	ldi	r25, 0x00	; 0
   10de4:	ac 01       	movw	r20, r24
   10de6:	48 70       	andi	r20, 0x08	; 8
   10de8:	50 70       	andi	r21, 0x00	; 0
   10dea:	52 fe       	sbrs	r5, 2
   10dec:	06 c0       	rjmp	.+12     	; 0x10dfa <conv_flt+0x106>
   10dee:	45 2b       	or	r20, r21
   10df0:	11 f5       	brne	.+68     	; 0x10e36 <conv_flt+0x142>
   10df2:	08 94       	sec
   10df4:	c1 1c       	adc	r12, r1
   10df6:	d1 1c       	adc	r13, r1
   10df8:	1e c0       	rjmp	.+60     	; 0x10e36 <conv_flt+0x142>
   10dfa:	45 2b       	or	r20, r21
   10dfc:	19 f0       	breq	.+6      	; 0x10e04 <conv_flt+0x110>
   10dfe:	08 94       	sec
   10e00:	c1 08       	sbc	r12, r1
   10e02:	d1 08       	sbc	r13, r1
   10e04:	c5 01       	movw	r24, r10
   10e06:	b4 01       	movw	r22, r8
   10e08:	40 e2       	ldi	r20, 0x20	; 32
   10e0a:	0e 94 d2 84 	call	0x109a4	; 0x109a4 <mulacc>
   10e0e:	4b 01       	movw	r8, r22
   10e10:	5c 01       	movw	r10, r24
   10e12:	88 e9       	ldi	r24, 0x98	; 152
   10e14:	88 16       	cp	r8, r24
   10e16:	89 e9       	ldi	r24, 0x99	; 153
   10e18:	98 06       	cpc	r9, r24
   10e1a:	89 e9       	ldi	r24, 0x99	; 153
   10e1c:	a8 06       	cpc	r10, r24
   10e1e:	89 e1       	ldi	r24, 0x19	; 25
   10e20:	b8 06       	cpc	r11, r24
   10e22:	48 f0       	brcs	.+18     	; 0x10e36 <conv_flt+0x142>
   10e24:	94 e0       	ldi	r25, 0x04	; 4
   10e26:	59 2a       	or	r5, r25
   10e28:	06 c0       	rjmp	.+12     	; 0x10e36 <conv_flt+0x142>
   10e2a:	4e 3f       	cpi	r20, 0xFE	; 254
   10e2c:	81 f4       	brne	.+32     	; 0x10e4e <conv_flt+0x15a>
   10e2e:	53 fc       	sbrc	r5, 3
   10e30:	0e c0       	rjmp	.+28     	; 0x10e4e <conv_flt+0x15a>
   10e32:	e8 e0       	ldi	r30, 0x08	; 8
   10e34:	5e 2a       	or	r5, r30
   10e36:	08 94       	sec
   10e38:	e1 08       	sbc	r14, r1
   10e3a:	f1 08       	sbc	r15, r1
   10e3c:	e1 14       	cp	r14, r1
   10e3e:	f1 04       	cpc	r15, r1
   10e40:	31 f0       	breq	.+12     	; 0x10e4e <conv_flt+0x15a>
   10e42:	c3 01       	movw	r24, r6
   10e44:	0e 94 81 8b 	call	0x11702	; 0x11702 <fgetc>
   10e48:	ec 01       	movw	r28, r24
   10e4a:	97 ff       	sbrs	r25, 7
   10e4c:	c2 cf       	rjmp	.-124    	; 0x10dd2 <conv_flt+0xde>
   10e4e:	51 fe       	sbrs	r5, 1
   10e50:	91 c0       	rjmp	.+290    	; 0x10f74 <conv_flt+0x280>
   10e52:	c5 36       	cpi	r28, 0x65	; 101
   10e54:	19 f0       	breq	.+6      	; 0x10e5c <conv_flt+0x168>
   10e56:	c5 34       	cpi	r28, 0x45	; 69
   10e58:	09 f0       	breq	.+2      	; 0x10e5c <conv_flt+0x168>
   10e5a:	46 c0       	rjmp	.+140    	; 0x10ee8 <conv_flt+0x1f4>
   10e5c:	08 94       	sec
   10e5e:	e1 08       	sbc	r14, r1
   10e60:	f1 08       	sbc	r15, r1
   10e62:	e1 14       	cp	r14, r1
   10e64:	f1 04       	cpc	r15, r1
   10e66:	09 f4       	brne	.+2      	; 0x10e6a <conv_flt+0x176>
   10e68:	85 c0       	rjmp	.+266    	; 0x10f74 <conv_flt+0x280>
   10e6a:	c3 01       	movw	r24, r6
   10e6c:	0e 94 81 8b 	call	0x11702	; 0x11702 <fgetc>
   10e70:	ec 01       	movw	r28, r24
   10e72:	97 fd       	sbrc	r25, 7
   10e74:	7f c0       	rjmp	.+254    	; 0x10f74 <conv_flt+0x280>
   10e76:	8b 32       	cpi	r24, 0x2B	; 43
   10e78:	21 f0       	breq	.+8      	; 0x10e82 <conv_flt+0x18e>
   10e7a:	8d 32       	cpi	r24, 0x2D	; 45
   10e7c:	69 f4       	brne	.+26     	; 0x10e98 <conv_flt+0x1a4>
   10e7e:	f0 e1       	ldi	r31, 0x10	; 16
   10e80:	5f 2a       	or	r5, r31
   10e82:	08 94       	sec
   10e84:	e1 08       	sbc	r14, r1
   10e86:	f1 08       	sbc	r15, r1
   10e88:	e1 14       	cp	r14, r1
   10e8a:	f1 04       	cpc	r15, r1
   10e8c:	09 f4       	brne	.+2      	; 0x10e90 <conv_flt+0x19c>
   10e8e:	72 c0       	rjmp	.+228    	; 0x10f74 <conv_flt+0x280>
   10e90:	c3 01       	movw	r24, r6
   10e92:	0e 94 81 8b 	call	0x11702	; 0x11702 <fgetc>
   10e96:	ec 01       	movw	r28, r24
   10e98:	ce 01       	movw	r24, r28
   10e9a:	c0 97       	sbiw	r24, 0x30	; 48
   10e9c:	0a 97       	sbiw	r24, 0x0a	; 10
   10e9e:	08 f0       	brcs	.+2      	; 0x10ea2 <conv_flt+0x1ae>
   10ea0:	69 c0       	rjmp	.+210    	; 0x10f74 <conv_flt+0x280>
   10ea2:	00 e0       	ldi	r16, 0x00	; 0
   10ea4:	10 e0       	ldi	r17, 0x00	; 0
   10ea6:	b8 01       	movw	r22, r16
   10ea8:	88 27       	eor	r24, r24
   10eaa:	77 fd       	sbrc	r23, 7
   10eac:	80 95       	com	r24
   10eae:	98 2f       	mov	r25, r24
   10eb0:	ae 01       	movw	r20, r28
   10eb2:	40 53       	subi	r20, 0x30	; 48
   10eb4:	24 2f       	mov	r18, r20
   10eb6:	40 e2       	ldi	r20, 0x20	; 32
   10eb8:	0e 94 d2 84 	call	0x109a4	; 0x109a4 <mulacc>
   10ebc:	8b 01       	movw	r16, r22
   10ebe:	08 94       	sec
   10ec0:	e1 08       	sbc	r14, r1
   10ec2:	f1 08       	sbc	r15, r1
   10ec4:	e1 14       	cp	r14, r1
   10ec6:	f1 04       	cpc	r15, r1
   10ec8:	39 f0       	breq	.+14     	; 0x10ed8 <conv_flt+0x1e4>
   10eca:	c3 01       	movw	r24, r6
   10ecc:	0e 94 81 8b 	call	0x11702	; 0x11702 <fgetc>
   10ed0:	ec 01       	movw	r28, r24
   10ed2:	c0 97       	sbiw	r24, 0x30	; 48
   10ed4:	0a 97       	sbiw	r24, 0x0a	; 10
   10ed6:	38 f3       	brcs	.-50     	; 0x10ea6 <conv_flt+0x1b2>
   10ed8:	b8 01       	movw	r22, r16
   10eda:	54 fe       	sbrs	r5, 4
   10edc:	03 c0       	rjmp	.+6      	; 0x10ee4 <conv_flt+0x1f0>
   10ede:	70 95       	com	r23
   10ee0:	61 95       	neg	r22
   10ee2:	7f 4f       	sbci	r23, 0xFF	; 255
   10ee4:	c6 0e       	add	r12, r22
   10ee6:	d7 1e       	adc	r13, r23
   10ee8:	ef 28       	or	r14, r15
   10eea:	31 f0       	breq	.+12     	; 0x10ef8 <conv_flt+0x204>
   10eec:	d7 fd       	sbrc	r29, 7
   10eee:	04 c0       	rjmp	.+8      	; 0x10ef8 <conv_flt+0x204>
   10ef0:	ce 01       	movw	r24, r28
   10ef2:	b3 01       	movw	r22, r6
   10ef4:	0e 94 97 8c 	call	0x1192e	; 0x1192e <ungetc>
   10ef8:	c5 01       	movw	r24, r10
   10efa:	b4 01       	movw	r22, r8
   10efc:	0e 94 0c 89 	call	0x11218	; 0x11218 <__floatunsisf>
   10f00:	d7 fe       	sbrs	r13, 7
   10f02:	0d c0       	rjmp	.+26     	; 0x10f1e <conv_flt+0x22a>
   10f04:	a7 e0       	ldi	r26, 0x07	; 7
   10f06:	ea 2e       	mov	r14, r26
   10f08:	a3 e0       	ldi	r26, 0x03	; 3
   10f0a:	fa 2e       	mov	r15, r26
   10f0c:	d0 94       	com	r13
   10f0e:	c1 94       	neg	r12
   10f10:	d1 08       	sbc	r13, r1
   10f12:	d3 94       	inc	r13
   10f14:	c0 e2       	ldi	r28, 0x20	; 32
   10f16:	d0 e0       	ldi	r29, 0x00	; 0
   10f18:	00 e0       	ldi	r16, 0x00	; 0
   10f1a:	10 e0       	ldi	r17, 0x00	; 0
   10f1c:	0e c0       	rjmp	.+28     	; 0x10f3a <conv_flt+0x246>
   10f1e:	ff e1       	ldi	r31, 0x1F	; 31
   10f20:	ef 2e       	mov	r14, r31
   10f22:	f3 e0       	ldi	r31, 0x03	; 3
   10f24:	ff 2e       	mov	r15, r31
   10f26:	f6 cf       	rjmp	.-20     	; 0x10f14 <conv_flt+0x220>
   10f28:	f7 01       	movw	r30, r14
   10f2a:	25 91       	lpm	r18, Z+
   10f2c:	35 91       	lpm	r19, Z+
   10f2e:	45 91       	lpm	r20, Z+
   10f30:	54 91       	lpm	r21, Z+
   10f32:	0e 94 49 89 	call	0x11292	; 0x11292 <__mulsf3>
   10f36:	cc 1a       	sub	r12, r28
   10f38:	dd 0a       	sbc	r13, r29
   10f3a:	cc 16       	cp	r12, r28
   10f3c:	dd 06       	cpc	r13, r29
   10f3e:	a0 f7       	brcc	.-24     	; 0x10f28 <conv_flt+0x234>
   10f40:	d6 95       	lsr	r29
   10f42:	c7 95       	ror	r28
   10f44:	0f 5f       	subi	r16, 0xFF	; 255
   10f46:	1f 4f       	sbci	r17, 0xFF	; 255
   10f48:	06 30       	cpi	r16, 0x06	; 6
   10f4a:	11 05       	cpc	r17, r1
   10f4c:	29 f0       	breq	.+10     	; 0x10f58 <conv_flt+0x264>
   10f4e:	ec ef       	ldi	r30, 0xFC	; 252
   10f50:	ff ef       	ldi	r31, 0xFF	; 255
   10f52:	ee 0e       	add	r14, r30
   10f54:	ff 1e       	adc	r15, r31
   10f56:	f1 cf       	rjmp	.-30     	; 0x10f3a <conv_flt+0x246>
   10f58:	dc 01       	movw	r26, r24
   10f5a:	cb 01       	movw	r24, r22
   10f5c:	57 fc       	sbrc	r5, 7
   10f5e:	b0 58       	subi	r27, 0x80	; 128
   10f60:	21 14       	cp	r2, r1
   10f62:	31 04       	cpc	r3, r1
   10f64:	29 f0       	breq	.+10     	; 0x10f70 <conv_flt+0x27c>
   10f66:	f1 01       	movw	r30, r2
   10f68:	80 83       	st	Z, r24
   10f6a:	91 83       	std	Z+1, r25	; 0x01
   10f6c:	a2 83       	std	Z+2, r26	; 0x02
   10f6e:	b3 83       	std	Z+3, r27	; 0x03
   10f70:	81 e0       	ldi	r24, 0x01	; 1
   10f72:	01 c0       	rjmp	.+2      	; 0x10f76 <conv_flt+0x282>
   10f74:	80 e0       	ldi	r24, 0x00	; 0
   10f76:	df 91       	pop	r29
   10f78:	cf 91       	pop	r28
   10f7a:	1f 91       	pop	r17
   10f7c:	0f 91       	pop	r16
   10f7e:	ff 90       	pop	r15
   10f80:	ef 90       	pop	r14
   10f82:	df 90       	pop	r13
   10f84:	cf 90       	pop	r12
   10f86:	bf 90       	pop	r11
   10f88:	af 90       	pop	r10
   10f8a:	9f 90       	pop	r9
   10f8c:	8f 90       	pop	r8
   10f8e:	7f 90       	pop	r7
   10f90:	6f 90       	pop	r6
   10f92:	5f 90       	pop	r5
   10f94:	3f 90       	pop	r3
   10f96:	2f 90       	pop	r2
   10f98:	08 95       	ret

00010f9a <vfscanf>:
   10f9a:	5f 92       	push	r5
   10f9c:	6f 92       	push	r6
   10f9e:	7f 92       	push	r7
   10fa0:	8f 92       	push	r8
   10fa2:	9f 92       	push	r9
   10fa4:	af 92       	push	r10
   10fa6:	bf 92       	push	r11
   10fa8:	cf 92       	push	r12
   10faa:	df 92       	push	r13
   10fac:	ef 92       	push	r14
   10fae:	ff 92       	push	r15
   10fb0:	0f 93       	push	r16
   10fb2:	1f 93       	push	r17
   10fb4:	cf 93       	push	r28
   10fb6:	df 93       	push	r29
   10fb8:	4c 01       	movw	r8, r24
   10fba:	5b 01       	movw	r10, r22
   10fbc:	3a 01       	movw	r6, r20
   10fbe:	fc 01       	movw	r30, r24
   10fc0:	17 82       	std	Z+7, r1	; 0x07
   10fc2:	16 82       	std	Z+6, r1	; 0x06
   10fc4:	55 24       	eor	r5, r5
   10fc6:	04 c1       	rjmp	.+520    	; 0x111d0 <vfscanf+0x236>
   10fc8:	81 2f       	mov	r24, r17
   10fca:	90 e0       	ldi	r25, 0x00	; 0
   10fcc:	0e 94 d8 8a 	call	0x115b0	; 0x115b0 <isspace>
   10fd0:	89 2b       	or	r24, r25
   10fd2:	21 f0       	breq	.+8      	; 0x10fdc <vfscanf+0x42>
   10fd4:	c4 01       	movw	r24, r8
   10fd6:	0e 94 00 85 	call	0x10a00	; 0x10a00 <skip_spaces>
   10fda:	fa c0       	rjmp	.+500    	; 0x111d0 <vfscanf+0x236>
   10fdc:	15 32       	cpi	r17, 0x25	; 37
   10fde:	49 f4       	brne	.+18     	; 0x10ff2 <vfscanf+0x58>
   10fe0:	f5 01       	movw	r30, r10
   10fe2:	f3 fc       	sbrc	r15, 3
   10fe4:	65 91       	lpm	r22, Z+
   10fe6:	f3 fe       	sbrs	r15, 3
   10fe8:	61 91       	ld	r22, Z+
   10fea:	5f 01       	movw	r10, r30
   10fec:	65 32       	cpi	r22, 0x25	; 37
   10fee:	69 f4       	brne	.+26     	; 0x1100a <vfscanf+0x70>
   10ff0:	15 e2       	ldi	r17, 0x25	; 37
   10ff2:	c4 01       	movw	r24, r8
   10ff4:	0e 94 81 8b 	call	0x11702	; 0x11702 <fgetc>
   10ff8:	97 fd       	sbrc	r25, 7
   10ffa:	f6 c0       	rjmp	.+492    	; 0x111e8 <vfscanf+0x24e>
   10ffc:	18 17       	cp	r17, r24
   10ffe:	09 f4       	brne	.+2      	; 0x11002 <vfscanf+0x68>
   11000:	e7 c0       	rjmp	.+462    	; 0x111d0 <vfscanf+0x236>
   11002:	b4 01       	movw	r22, r8
   11004:	0e 94 97 8c 	call	0x1192e	; 0x1192e <ungetc>
   11008:	f4 c0       	rjmp	.+488    	; 0x111f2 <vfscanf+0x258>
   1100a:	6a 32       	cpi	r22, 0x2A	; 42
   1100c:	19 f0       	breq	.+6      	; 0x11014 <vfscanf+0x7a>
   1100e:	16 2f       	mov	r17, r22
   11010:	00 e0       	ldi	r16, 0x00	; 0
   11012:	06 c0       	rjmp	.+12     	; 0x11020 <vfscanf+0x86>
   11014:	f3 fc       	sbrc	r15, 3
   11016:	15 91       	lpm	r17, Z+
   11018:	f3 fe       	sbrs	r15, 3
   1101a:	11 91       	ld	r17, Z+
   1101c:	5f 01       	movw	r10, r30
   1101e:	01 e0       	ldi	r16, 0x01	; 1
   11020:	cc 24       	eor	r12, r12
   11022:	dd 24       	eor	r13, r13
   11024:	0e c0       	rjmp	.+28     	; 0x11042 <vfscanf+0xa8>
   11026:	02 60       	ori	r16, 0x02	; 2
   11028:	b6 01       	movw	r22, r12
   1102a:	80 e0       	ldi	r24, 0x00	; 0
   1102c:	90 e0       	ldi	r25, 0x00	; 0
   1102e:	40 e2       	ldi	r20, 0x20	; 32
   11030:	0e 94 d2 84 	call	0x109a4	; 0x109a4 <mulacc>
   11034:	6b 01       	movw	r12, r22
   11036:	f5 01       	movw	r30, r10
   11038:	f3 fc       	sbrc	r15, 3
   1103a:	15 91       	lpm	r17, Z+
   1103c:	f3 fe       	sbrs	r15, 3
   1103e:	11 91       	ld	r17, Z+
   11040:	5f 01       	movw	r10, r30
   11042:	21 2f       	mov	r18, r17
   11044:	20 53       	subi	r18, 0x30	; 48
   11046:	2a 30       	cpi	r18, 0x0A	; 10
   11048:	70 f3       	brcs	.-36     	; 0x11026 <vfscanf+0x8c>
   1104a:	01 fd       	sbrc	r16, 1
   1104c:	04 c0       	rjmp	.+8      	; 0x11056 <vfscanf+0xbc>
   1104e:	cc 24       	eor	r12, r12
   11050:	ca 94       	dec	r12
   11052:	dc 2c       	mov	r13, r12
   11054:	04 c0       	rjmp	.+8      	; 0x1105e <vfscanf+0xc4>
   11056:	c1 14       	cp	r12, r1
   11058:	d1 04       	cpc	r13, r1
   1105a:	09 f4       	brne	.+2      	; 0x1105e <vfscanf+0xc4>
   1105c:	ca c0       	rjmp	.+404    	; 0x111f2 <vfscanf+0x258>
   1105e:	18 36       	cpi	r17, 0x68	; 104
   11060:	21 f0       	breq	.+8      	; 0x1106a <vfscanf+0xd0>
   11062:	1c 36       	cpi	r17, 0x6C	; 108
   11064:	99 f4       	brne	.+38     	; 0x1108c <vfscanf+0xf2>
   11066:	f5 01       	movw	r30, r10
   11068:	0b c0       	rjmp	.+22     	; 0x11080 <vfscanf+0xe6>
   1106a:	f5 01       	movw	r30, r10
   1106c:	f3 fc       	sbrc	r15, 3
   1106e:	65 91       	lpm	r22, Z+
   11070:	f3 fe       	sbrs	r15, 3
   11072:	61 91       	ld	r22, Z+
   11074:	68 36       	cpi	r22, 0x68	; 104
   11076:	19 f0       	breq	.+6      	; 0x1107e <vfscanf+0xe4>
   11078:	5f 01       	movw	r10, r30
   1107a:	16 2f       	mov	r17, r22
   1107c:	07 c0       	rjmp	.+14     	; 0x1108c <vfscanf+0xf2>
   1107e:	08 60       	ori	r16, 0x08	; 8
   11080:	04 60       	ori	r16, 0x04	; 4
   11082:	f3 fc       	sbrc	r15, 3
   11084:	15 91       	lpm	r17, Z+
   11086:	f3 fe       	sbrs	r15, 3
   11088:	11 91       	ld	r17, Z+
   1108a:	5f 01       	movw	r10, r30
   1108c:	11 23       	and	r17, r17
   1108e:	09 f4       	brne	.+2      	; 0x11092 <vfscanf+0xf8>
   11090:	b0 c0       	rjmp	.+352    	; 0x111f2 <vfscanf+0x258>
   11092:	86 ed       	ldi	r24, 0xD6	; 214
   11094:	92 e0       	ldi	r25, 0x02	; 2
   11096:	61 2f       	mov	r22, r17
   11098:	70 e0       	ldi	r23, 0x00	; 0
   1109a:	0e 94 e8 8a 	call	0x115d0	; 0x115d0 <strchr_P>
   1109e:	89 2b       	or	r24, r25
   110a0:	09 f4       	brne	.+2      	; 0x110a4 <vfscanf+0x10a>
   110a2:	a7 c0       	rjmp	.+334    	; 0x111f2 <vfscanf+0x258>
   110a4:	80 2f       	mov	r24, r16
   110a6:	00 ff       	sbrs	r16, 0
   110a8:	03 c0       	rjmp	.+6      	; 0x110b0 <vfscanf+0x116>
   110aa:	ee 24       	eor	r14, r14
   110ac:	ff 24       	eor	r15, r15
   110ae:	07 c0       	rjmp	.+14     	; 0x110be <vfscanf+0x124>
   110b0:	f3 01       	movw	r30, r6
   110b2:	e0 80       	ld	r14, Z
   110b4:	f1 80       	ldd	r15, Z+1	; 0x01
   110b6:	22 e0       	ldi	r18, 0x02	; 2
   110b8:	30 e0       	ldi	r19, 0x00	; 0
   110ba:	62 0e       	add	r6, r18
   110bc:	73 1e       	adc	r7, r19
   110be:	1e 36       	cpi	r17, 0x6E	; 110
   110c0:	51 f4       	brne	.+20     	; 0x110d6 <vfscanf+0x13c>
   110c2:	f4 01       	movw	r30, r8
   110c4:	46 81       	ldd	r20, Z+6	; 0x06
   110c6:	57 81       	ldd	r21, Z+7	; 0x07
   110c8:	60 e0       	ldi	r22, 0x00	; 0
   110ca:	70 e0       	ldi	r23, 0x00	; 0
   110cc:	c7 01       	movw	r24, r14
   110ce:	20 2f       	mov	r18, r16
   110d0:	0e 94 c6 84 	call	0x1098c	; 0x1098c <putval>
   110d4:	7d c0       	rjmp	.+250    	; 0x111d0 <vfscanf+0x236>
   110d6:	13 36       	cpi	r17, 0x63	; 99
   110d8:	b9 f4       	brne	.+46     	; 0x11108 <vfscanf+0x16e>
   110da:	81 fd       	sbrc	r24, 1
   110dc:	03 c0       	rjmp	.+6      	; 0x110e4 <vfscanf+0x14a>
   110de:	11 e0       	ldi	r17, 0x01	; 1
   110e0:	c1 2e       	mov	r12, r17
   110e2:	d1 2c       	mov	r13, r1
   110e4:	c4 01       	movw	r24, r8
   110e6:	0e 94 81 8b 	call	0x11702	; 0x11702 <fgetc>
   110ea:	97 fd       	sbrc	r25, 7
   110ec:	7d c0       	rjmp	.+250    	; 0x111e8 <vfscanf+0x24e>
   110ee:	e1 14       	cp	r14, r1
   110f0:	f1 04       	cpc	r15, r1
   110f2:	19 f0       	breq	.+6      	; 0x110fa <vfscanf+0x160>
   110f4:	f7 01       	movw	r30, r14
   110f6:	81 93       	st	Z+, r24
   110f8:	7f 01       	movw	r14, r30
   110fa:	08 94       	sec
   110fc:	c1 08       	sbc	r12, r1
   110fe:	d1 08       	sbc	r13, r1
   11100:	c1 14       	cp	r12, r1
   11102:	d1 04       	cpc	r13, r1
   11104:	79 f7       	brne	.-34     	; 0x110e4 <vfscanf+0x14a>
   11106:	62 c0       	rjmp	.+196    	; 0x111cc <vfscanf+0x232>
   11108:	1b 35       	cpi	r17, 0x5B	; 91
   1110a:	59 f4       	brne	.+22     	; 0x11122 <vfscanf+0x188>
   1110c:	c4 01       	movw	r24, r8
   1110e:	b6 01       	movw	r22, r12
   11110:	a7 01       	movw	r20, r14
   11112:	95 01       	movw	r18, r10
   11114:	0e 94 ad 85 	call	0x10b5a	; 0x10b5a <conv_brk>
   11118:	5c 01       	movw	r10, r24
   1111a:	00 97       	sbiw	r24, 0x00	; 0
   1111c:	09 f0       	breq	.+2      	; 0x11120 <vfscanf+0x186>
   1111e:	56 c0       	rjmp	.+172    	; 0x111cc <vfscanf+0x232>
   11120:	50 c0       	rjmp	.+160    	; 0x111c2 <vfscanf+0x228>
   11122:	c4 01       	movw	r24, r8
   11124:	0e 94 00 85 	call	0x10a00	; 0x10a00 <skip_spaces>
   11128:	97 fd       	sbrc	r25, 7
   1112a:	5e c0       	rjmp	.+188    	; 0x111e8 <vfscanf+0x24e>
   1112c:	1f 36       	cpi	r17, 0x6F	; 111
   1112e:	d1 f1       	breq	.+116    	; 0x111a4 <vfscanf+0x20a>
   11130:	10 37       	cpi	r17, 0x70	; 112
   11132:	38 f4       	brcc	.+14     	; 0x11142 <vfscanf+0x1a8>
   11134:	14 36       	cpi	r17, 0x64	; 100
   11136:	a1 f1       	breq	.+104    	; 0x111a0 <vfscanf+0x206>
   11138:	19 36       	cpi	r17, 0x69	; 105
   1113a:	a9 f1       	breq	.+106    	; 0x111a6 <vfscanf+0x20c>
   1113c:	18 35       	cpi	r17, 0x58	; 88
   1113e:	d1 f5       	brne	.+116    	; 0x111b4 <vfscanf+0x21a>
   11140:	2d c0       	rjmp	.+90     	; 0x1119c <vfscanf+0x202>
   11142:	13 37       	cpi	r17, 0x73	; 115
   11144:	51 f0       	breq	.+20     	; 0x1115a <vfscanf+0x1c0>
   11146:	14 37       	cpi	r17, 0x74	; 116
   11148:	18 f4       	brcc	.+6      	; 0x11150 <vfscanf+0x1b6>
   1114a:	10 37       	cpi	r17, 0x70	; 112
   1114c:	99 f5       	brne	.+102    	; 0x111b4 <vfscanf+0x21a>
   1114e:	26 c0       	rjmp	.+76     	; 0x1119c <vfscanf+0x202>
   11150:	15 37       	cpi	r17, 0x75	; 117
   11152:	31 f1       	breq	.+76     	; 0x111a0 <vfscanf+0x206>
   11154:	18 37       	cpi	r17, 0x78	; 120
   11156:	71 f5       	brne	.+92     	; 0x111b4 <vfscanf+0x21a>
   11158:	21 c0       	rjmp	.+66     	; 0x1119c <vfscanf+0x202>
   1115a:	c4 01       	movw	r24, r8
   1115c:	0e 94 81 8b 	call	0x11702	; 0x11702 <fgetc>
   11160:	ec 01       	movw	r28, r24
   11162:	97 fd       	sbrc	r25, 7
   11164:	15 c0       	rjmp	.+42     	; 0x11190 <vfscanf+0x1f6>
   11166:	0e 94 d8 8a 	call	0x115b0	; 0x115b0 <isspace>
   1116a:	89 2b       	or	r24, r25
   1116c:	29 f0       	breq	.+10     	; 0x11178 <vfscanf+0x1de>
   1116e:	ce 01       	movw	r24, r28
   11170:	b4 01       	movw	r22, r8
   11172:	0e 94 97 8c 	call	0x1192e	; 0x1192e <ungetc>
   11176:	0c c0       	rjmp	.+24     	; 0x11190 <vfscanf+0x1f6>
   11178:	e1 14       	cp	r14, r1
   1117a:	f1 04       	cpc	r15, r1
   1117c:	19 f0       	breq	.+6      	; 0x11184 <vfscanf+0x1ea>
   1117e:	f7 01       	movw	r30, r14
   11180:	c1 93       	st	Z+, r28
   11182:	7f 01       	movw	r14, r30
   11184:	08 94       	sec
   11186:	c1 08       	sbc	r12, r1
   11188:	d1 08       	sbc	r13, r1
   1118a:	c1 14       	cp	r12, r1
   1118c:	d1 04       	cpc	r13, r1
   1118e:	29 f7       	brne	.-54     	; 0x1115a <vfscanf+0x1c0>
   11190:	e1 14       	cp	r14, r1
   11192:	f1 04       	cpc	r15, r1
   11194:	d9 f0       	breq	.+54     	; 0x111cc <vfscanf+0x232>
   11196:	f7 01       	movw	r30, r14
   11198:	10 82       	st	Z, r1
   1119a:	18 c0       	rjmp	.+48     	; 0x111cc <vfscanf+0x232>
   1119c:	00 64       	ori	r16, 0x40	; 64
   1119e:	03 c0       	rjmp	.+6      	; 0x111a6 <vfscanf+0x20c>
   111a0:	00 62       	ori	r16, 0x20	; 32
   111a2:	01 c0       	rjmp	.+2      	; 0x111a6 <vfscanf+0x20c>
   111a4:	00 61       	ori	r16, 0x10	; 16
   111a6:	c4 01       	movw	r24, r8
   111a8:	b6 01       	movw	r22, r12
   111aa:	a7 01       	movw	r20, r14
   111ac:	20 2f       	mov	r18, r16
   111ae:	0e 94 19 85 	call	0x10a32	; 0x10a32 <conv_int>
   111b2:	05 c0       	rjmp	.+10     	; 0x111be <vfscanf+0x224>
   111b4:	c4 01       	movw	r24, r8
   111b6:	b6 01       	movw	r22, r12
   111b8:	a7 01       	movw	r20, r14
   111ba:	0e 94 7a 86 	call	0x10cf4	; 0x10cf4 <conv_flt>
   111be:	88 23       	and	r24, r24
   111c0:	29 f4       	brne	.+10     	; 0x111cc <vfscanf+0x232>
   111c2:	f4 01       	movw	r30, r8
   111c4:	83 81       	ldd	r24, Z+3	; 0x03
   111c6:	80 73       	andi	r24, 0x30	; 48
   111c8:	79 f4       	brne	.+30     	; 0x111e8 <vfscanf+0x24e>
   111ca:	13 c0       	rjmp	.+38     	; 0x111f2 <vfscanf+0x258>
   111cc:	00 ff       	sbrs	r16, 0
   111ce:	53 94       	inc	r5
   111d0:	f4 01       	movw	r30, r8
   111d2:	f3 80       	ldd	r15, Z+3	; 0x03
   111d4:	f5 01       	movw	r30, r10
   111d6:	f3 fc       	sbrc	r15, 3
   111d8:	15 91       	lpm	r17, Z+
   111da:	f3 fe       	sbrs	r15, 3
   111dc:	11 91       	ld	r17, Z+
   111de:	5f 01       	movw	r10, r30
   111e0:	11 23       	and	r17, r17
   111e2:	09 f0       	breq	.+2      	; 0x111e6 <vfscanf+0x24c>
   111e4:	f1 ce       	rjmp	.-542    	; 0x10fc8 <vfscanf+0x2e>
   111e6:	05 c0       	rjmp	.+10     	; 0x111f2 <vfscanf+0x258>
   111e8:	55 20       	and	r5, r5
   111ea:	19 f4       	brne	.+6      	; 0x111f2 <vfscanf+0x258>
   111ec:	2f ef       	ldi	r18, 0xFF	; 255
   111ee:	3f ef       	ldi	r19, 0xFF	; 255
   111f0:	02 c0       	rjmp	.+4      	; 0x111f6 <vfscanf+0x25c>
   111f2:	25 2d       	mov	r18, r5
   111f4:	30 e0       	ldi	r19, 0x00	; 0
   111f6:	c9 01       	movw	r24, r18
   111f8:	df 91       	pop	r29
   111fa:	cf 91       	pop	r28
   111fc:	1f 91       	pop	r17
   111fe:	0f 91       	pop	r16
   11200:	ff 90       	pop	r15
   11202:	ef 90       	pop	r14
   11204:	df 90       	pop	r13
   11206:	cf 90       	pop	r12
   11208:	bf 90       	pop	r11
   1120a:	af 90       	pop	r10
   1120c:	9f 90       	pop	r9
   1120e:	8f 90       	pop	r8
   11210:	7f 90       	pop	r7
   11212:	6f 90       	pop	r6
   11214:	5f 90       	pop	r5
   11216:	08 95       	ret

00011218 <__floatunsisf>:
   11218:	e8 94       	clt
   1121a:	09 c0       	rjmp	.+18     	; 0x1122e <__floatsisf+0x12>

0001121c <__floatsisf>:
   1121c:	97 fb       	bst	r25, 7
   1121e:	3e f4       	brtc	.+14     	; 0x1122e <__floatsisf+0x12>
   11220:	90 95       	com	r25
   11222:	80 95       	com	r24
   11224:	70 95       	com	r23
   11226:	61 95       	neg	r22
   11228:	7f 4f       	sbci	r23, 0xFF	; 255
   1122a:	8f 4f       	sbci	r24, 0xFF	; 255
   1122c:	9f 4f       	sbci	r25, 0xFF	; 255
   1122e:	99 23       	and	r25, r25
   11230:	a9 f0       	breq	.+42     	; 0x1125c <__floatsisf+0x40>
   11232:	f9 2f       	mov	r31, r25
   11234:	96 e9       	ldi	r25, 0x96	; 150
   11236:	bb 27       	eor	r27, r27
   11238:	93 95       	inc	r25
   1123a:	f6 95       	lsr	r31
   1123c:	87 95       	ror	r24
   1123e:	77 95       	ror	r23
   11240:	67 95       	ror	r22
   11242:	b7 95       	ror	r27
   11244:	f1 11       	cpse	r31, r1
   11246:	f8 cf       	rjmp	.-16     	; 0x11238 <__floatsisf+0x1c>
   11248:	fa f4       	brpl	.+62     	; 0x11288 <__floatsisf+0x6c>
   1124a:	bb 0f       	add	r27, r27
   1124c:	11 f4       	brne	.+4      	; 0x11252 <__floatsisf+0x36>
   1124e:	60 ff       	sbrs	r22, 0
   11250:	1b c0       	rjmp	.+54     	; 0x11288 <__floatsisf+0x6c>
   11252:	6f 5f       	subi	r22, 0xFF	; 255
   11254:	7f 4f       	sbci	r23, 0xFF	; 255
   11256:	8f 4f       	sbci	r24, 0xFF	; 255
   11258:	9f 4f       	sbci	r25, 0xFF	; 255
   1125a:	16 c0       	rjmp	.+44     	; 0x11288 <__floatsisf+0x6c>
   1125c:	88 23       	and	r24, r24
   1125e:	11 f0       	breq	.+4      	; 0x11264 <__floatsisf+0x48>
   11260:	96 e9       	ldi	r25, 0x96	; 150
   11262:	11 c0       	rjmp	.+34     	; 0x11286 <__floatsisf+0x6a>
   11264:	77 23       	and	r23, r23
   11266:	21 f0       	breq	.+8      	; 0x11270 <__floatsisf+0x54>
   11268:	9e e8       	ldi	r25, 0x8E	; 142
   1126a:	87 2f       	mov	r24, r23
   1126c:	76 2f       	mov	r23, r22
   1126e:	05 c0       	rjmp	.+10     	; 0x1127a <__floatsisf+0x5e>
   11270:	66 23       	and	r22, r22
   11272:	71 f0       	breq	.+28     	; 0x11290 <__floatsisf+0x74>
   11274:	96 e8       	ldi	r25, 0x86	; 134
   11276:	86 2f       	mov	r24, r22
   11278:	70 e0       	ldi	r23, 0x00	; 0
   1127a:	60 e0       	ldi	r22, 0x00	; 0
   1127c:	2a f0       	brmi	.+10     	; 0x11288 <__floatsisf+0x6c>
   1127e:	9a 95       	dec	r25
   11280:	66 0f       	add	r22, r22
   11282:	77 1f       	adc	r23, r23
   11284:	88 1f       	adc	r24, r24
   11286:	da f7       	brpl	.-10     	; 0x1127e <__floatsisf+0x62>
   11288:	88 0f       	add	r24, r24
   1128a:	96 95       	lsr	r25
   1128c:	87 95       	ror	r24
   1128e:	97 f9       	bld	r25, 7
   11290:	08 95       	ret

00011292 <__mulsf3>:
   11292:	0b d0       	rcall	.+22     	; 0x112aa <__mulsf3x>
   11294:	78 c0       	rjmp	.+240    	; 0x11386 <__fp_round>
   11296:	69 d0       	rcall	.+210    	; 0x1136a <__fp_pscA>
   11298:	28 f0       	brcs	.+10     	; 0x112a4 <__mulsf3+0x12>
   1129a:	6e d0       	rcall	.+220    	; 0x11378 <__fp_pscB>
   1129c:	18 f0       	brcs	.+6      	; 0x112a4 <__mulsf3+0x12>
   1129e:	95 23       	and	r25, r21
   112a0:	09 f0       	breq	.+2      	; 0x112a4 <__mulsf3+0x12>
   112a2:	5a c0       	rjmp	.+180    	; 0x11358 <__fp_inf>
   112a4:	5f c0       	rjmp	.+190    	; 0x11364 <__fp_nan>
   112a6:	11 24       	eor	r1, r1
   112a8:	a2 c0       	rjmp	.+324    	; 0x113ee <__fp_szero>

000112aa <__mulsf3x>:
   112aa:	7e d0       	rcall	.+252    	; 0x113a8 <__fp_split3>
   112ac:	a0 f3       	brcs	.-24     	; 0x11296 <__mulsf3+0x4>

000112ae <__mulsf3_pse>:
   112ae:	95 9f       	mul	r25, r21
   112b0:	d1 f3       	breq	.-12     	; 0x112a6 <__mulsf3+0x14>
   112b2:	95 0f       	add	r25, r21
   112b4:	50 e0       	ldi	r21, 0x00	; 0
   112b6:	55 1f       	adc	r21, r21
   112b8:	62 9f       	mul	r22, r18
   112ba:	f0 01       	movw	r30, r0
   112bc:	72 9f       	mul	r23, r18
   112be:	bb 27       	eor	r27, r27
   112c0:	f0 0d       	add	r31, r0
   112c2:	b1 1d       	adc	r27, r1
   112c4:	63 9f       	mul	r22, r19
   112c6:	aa 27       	eor	r26, r26
   112c8:	f0 0d       	add	r31, r0
   112ca:	b1 1d       	adc	r27, r1
   112cc:	aa 1f       	adc	r26, r26
   112ce:	64 9f       	mul	r22, r20
   112d0:	66 27       	eor	r22, r22
   112d2:	b0 0d       	add	r27, r0
   112d4:	a1 1d       	adc	r26, r1
   112d6:	66 1f       	adc	r22, r22
   112d8:	82 9f       	mul	r24, r18
   112da:	22 27       	eor	r18, r18
   112dc:	b0 0d       	add	r27, r0
   112de:	a1 1d       	adc	r26, r1
   112e0:	62 1f       	adc	r22, r18
   112e2:	73 9f       	mul	r23, r19
   112e4:	b0 0d       	add	r27, r0
   112e6:	a1 1d       	adc	r26, r1
   112e8:	62 1f       	adc	r22, r18
   112ea:	83 9f       	mul	r24, r19
   112ec:	a0 0d       	add	r26, r0
   112ee:	61 1d       	adc	r22, r1
   112f0:	22 1f       	adc	r18, r18
   112f2:	74 9f       	mul	r23, r20
   112f4:	33 27       	eor	r19, r19
   112f6:	a0 0d       	add	r26, r0
   112f8:	61 1d       	adc	r22, r1
   112fa:	23 1f       	adc	r18, r19
   112fc:	84 9f       	mul	r24, r20
   112fe:	60 0d       	add	r22, r0
   11300:	21 1d       	adc	r18, r1
   11302:	82 2f       	mov	r24, r18
   11304:	76 2f       	mov	r23, r22
   11306:	6a 2f       	mov	r22, r26
   11308:	11 24       	eor	r1, r1
   1130a:	9f 57       	subi	r25, 0x7F	; 127
   1130c:	50 40       	sbci	r21, 0x00	; 0
   1130e:	8a f0       	brmi	.+34     	; 0x11332 <__mulsf3_pse+0x84>
   11310:	e1 f0       	breq	.+56     	; 0x1134a <__mulsf3_pse+0x9c>
   11312:	88 23       	and	r24, r24
   11314:	4a f0       	brmi	.+18     	; 0x11328 <__mulsf3_pse+0x7a>
   11316:	ee 0f       	add	r30, r30
   11318:	ff 1f       	adc	r31, r31
   1131a:	bb 1f       	adc	r27, r27
   1131c:	66 1f       	adc	r22, r22
   1131e:	77 1f       	adc	r23, r23
   11320:	88 1f       	adc	r24, r24
   11322:	91 50       	subi	r25, 0x01	; 1
   11324:	50 40       	sbci	r21, 0x00	; 0
   11326:	a9 f7       	brne	.-22     	; 0x11312 <__mulsf3_pse+0x64>
   11328:	9e 3f       	cpi	r25, 0xFE	; 254
   1132a:	51 05       	cpc	r21, r1
   1132c:	70 f0       	brcs	.+28     	; 0x1134a <__mulsf3_pse+0x9c>
   1132e:	14 c0       	rjmp	.+40     	; 0x11358 <__fp_inf>
   11330:	5e c0       	rjmp	.+188    	; 0x113ee <__fp_szero>
   11332:	5f 3f       	cpi	r21, 0xFF	; 255
   11334:	ec f3       	brlt	.-6      	; 0x11330 <__mulsf3_pse+0x82>
   11336:	98 3e       	cpi	r25, 0xE8	; 232
   11338:	dc f3       	brlt	.-10     	; 0x11330 <__mulsf3_pse+0x82>
   1133a:	86 95       	lsr	r24
   1133c:	77 95       	ror	r23
   1133e:	67 95       	ror	r22
   11340:	b7 95       	ror	r27
   11342:	f7 95       	ror	r31
   11344:	e7 95       	ror	r30
   11346:	9f 5f       	subi	r25, 0xFF	; 255
   11348:	c1 f7       	brne	.-16     	; 0x1133a <__mulsf3_pse+0x8c>
   1134a:	fe 2b       	or	r31, r30
   1134c:	88 0f       	add	r24, r24
   1134e:	91 1d       	adc	r25, r1
   11350:	96 95       	lsr	r25
   11352:	87 95       	ror	r24
   11354:	97 f9       	bld	r25, 7
   11356:	08 95       	ret

00011358 <__fp_inf>:
   11358:	97 f9       	bld	r25, 7
   1135a:	9f 67       	ori	r25, 0x7F	; 127
   1135c:	80 e8       	ldi	r24, 0x80	; 128
   1135e:	70 e0       	ldi	r23, 0x00	; 0
   11360:	60 e0       	ldi	r22, 0x00	; 0
   11362:	08 95       	ret

00011364 <__fp_nan>:
   11364:	9f ef       	ldi	r25, 0xFF	; 255
   11366:	80 ec       	ldi	r24, 0xC0	; 192
   11368:	08 95       	ret

0001136a <__fp_pscA>:
   1136a:	00 24       	eor	r0, r0
   1136c:	0a 94       	dec	r0
   1136e:	16 16       	cp	r1, r22
   11370:	17 06       	cpc	r1, r23
   11372:	18 06       	cpc	r1, r24
   11374:	09 06       	cpc	r0, r25
   11376:	08 95       	ret

00011378 <__fp_pscB>:
   11378:	00 24       	eor	r0, r0
   1137a:	0a 94       	dec	r0
   1137c:	12 16       	cp	r1, r18
   1137e:	13 06       	cpc	r1, r19
   11380:	14 06       	cpc	r1, r20
   11382:	05 06       	cpc	r0, r21
   11384:	08 95       	ret

00011386 <__fp_round>:
   11386:	09 2e       	mov	r0, r25
   11388:	03 94       	inc	r0
   1138a:	00 0c       	add	r0, r0
   1138c:	11 f4       	brne	.+4      	; 0x11392 <__fp_round+0xc>
   1138e:	88 23       	and	r24, r24
   11390:	52 f0       	brmi	.+20     	; 0x113a6 <__fp_round+0x20>
   11392:	bb 0f       	add	r27, r27
   11394:	40 f4       	brcc	.+16     	; 0x113a6 <__fp_round+0x20>
   11396:	bf 2b       	or	r27, r31
   11398:	11 f4       	brne	.+4      	; 0x1139e <__fp_round+0x18>
   1139a:	60 ff       	sbrs	r22, 0
   1139c:	04 c0       	rjmp	.+8      	; 0x113a6 <__fp_round+0x20>
   1139e:	6f 5f       	subi	r22, 0xFF	; 255
   113a0:	7f 4f       	sbci	r23, 0xFF	; 255
   113a2:	8f 4f       	sbci	r24, 0xFF	; 255
   113a4:	9f 4f       	sbci	r25, 0xFF	; 255
   113a6:	08 95       	ret

000113a8 <__fp_split3>:
   113a8:	57 fd       	sbrc	r21, 7
   113aa:	90 58       	subi	r25, 0x80	; 128
   113ac:	44 0f       	add	r20, r20
   113ae:	55 1f       	adc	r21, r21
   113b0:	59 f0       	breq	.+22     	; 0x113c8 <__fp_splitA+0x10>
   113b2:	5f 3f       	cpi	r21, 0xFF	; 255
   113b4:	71 f0       	breq	.+28     	; 0x113d2 <__fp_splitA+0x1a>
   113b6:	47 95       	ror	r20

000113b8 <__fp_splitA>:
   113b8:	88 0f       	add	r24, r24
   113ba:	97 fb       	bst	r25, 7
   113bc:	99 1f       	adc	r25, r25
   113be:	61 f0       	breq	.+24     	; 0x113d8 <__fp_splitA+0x20>
   113c0:	9f 3f       	cpi	r25, 0xFF	; 255
   113c2:	79 f0       	breq	.+30     	; 0x113e2 <__fp_splitA+0x2a>
   113c4:	87 95       	ror	r24
   113c6:	08 95       	ret
   113c8:	12 16       	cp	r1, r18
   113ca:	13 06       	cpc	r1, r19
   113cc:	14 06       	cpc	r1, r20
   113ce:	55 1f       	adc	r21, r21
   113d0:	f2 cf       	rjmp	.-28     	; 0x113b6 <__fp_split3+0xe>
   113d2:	46 95       	lsr	r20
   113d4:	f1 df       	rcall	.-30     	; 0x113b8 <__fp_splitA>
   113d6:	08 c0       	rjmp	.+16     	; 0x113e8 <__fp_splitA+0x30>
   113d8:	16 16       	cp	r1, r22
   113da:	17 06       	cpc	r1, r23
   113dc:	18 06       	cpc	r1, r24
   113de:	99 1f       	adc	r25, r25
   113e0:	f1 cf       	rjmp	.-30     	; 0x113c4 <__fp_splitA+0xc>
   113e2:	86 95       	lsr	r24
   113e4:	71 05       	cpc	r23, r1
   113e6:	61 05       	cpc	r22, r1
   113e8:	08 94       	sec
   113ea:	08 95       	ret

000113ec <__fp_zero>:
   113ec:	e8 94       	clt

000113ee <__fp_szero>:
   113ee:	bb 27       	eor	r27, r27
   113f0:	66 27       	eor	r22, r22
   113f2:	77 27       	eor	r23, r23
   113f4:	cb 01       	movw	r24, r22
   113f6:	97 f9       	bld	r25, 7
   113f8:	08 95       	ret

000113fa <exit>:
   113fa:	f8 94       	cli
   113fc:	0c 94 e8 8e 	jmp	0x11dd0	; 0x11dd0 <_exit>

00011400 <__ftoa_engine>:
   11400:	28 30       	cpi	r18, 0x08	; 8
   11402:	08 f0       	brcs	.+2      	; 0x11406 <__ftoa_engine+0x6>
   11404:	27 e0       	ldi	r18, 0x07	; 7
   11406:	33 27       	eor	r19, r19
   11408:	da 01       	movw	r26, r20
   1140a:	99 0f       	add	r25, r25
   1140c:	31 1d       	adc	r19, r1
   1140e:	87 fd       	sbrc	r24, 7
   11410:	91 60       	ori	r25, 0x01	; 1
   11412:	00 96       	adiw	r24, 0x00	; 0
   11414:	61 05       	cpc	r22, r1
   11416:	71 05       	cpc	r23, r1
   11418:	39 f4       	brne	.+14     	; 0x11428 <__ftoa_engine+0x28>
   1141a:	32 60       	ori	r19, 0x02	; 2
   1141c:	2e 5f       	subi	r18, 0xFE	; 254
   1141e:	3d 93       	st	X+, r19
   11420:	30 e3       	ldi	r19, 0x30	; 48
   11422:	2a 95       	dec	r18
   11424:	e1 f7       	brne	.-8      	; 0x1141e <__ftoa_engine+0x1e>
   11426:	08 95       	ret
   11428:	9f 3f       	cpi	r25, 0xFF	; 255
   1142a:	30 f0       	brcs	.+12     	; 0x11438 <__ftoa_engine+0x38>
   1142c:	80 38       	cpi	r24, 0x80	; 128
   1142e:	71 05       	cpc	r23, r1
   11430:	61 05       	cpc	r22, r1
   11432:	09 f0       	breq	.+2      	; 0x11436 <__ftoa_engine+0x36>
   11434:	3c 5f       	subi	r19, 0xFC	; 252
   11436:	3c 5f       	subi	r19, 0xFC	; 252
   11438:	3d 93       	st	X+, r19
   1143a:	91 30       	cpi	r25, 0x01	; 1
   1143c:	08 f0       	brcs	.+2      	; 0x11440 <__ftoa_engine+0x40>
   1143e:	80 68       	ori	r24, 0x80	; 128
   11440:	91 1d       	adc	r25, r1
   11442:	df 93       	push	r29
   11444:	cf 93       	push	r28
   11446:	1f 93       	push	r17
   11448:	0f 93       	push	r16
   1144a:	ff 92       	push	r15
   1144c:	ef 92       	push	r14
   1144e:	19 2f       	mov	r17, r25
   11450:	98 7f       	andi	r25, 0xF8	; 248
   11452:	96 95       	lsr	r25
   11454:	e9 2f       	mov	r30, r25
   11456:	96 95       	lsr	r25
   11458:	96 95       	lsr	r25
   1145a:	e9 0f       	add	r30, r25
   1145c:	ff 27       	eor	r31, r31
   1145e:	e8 5a       	subi	r30, 0xA8	; 168
   11460:	fb 4b       	sbci	r31, 0xBB	; 187
   11462:	99 27       	eor	r25, r25
   11464:	33 27       	eor	r19, r19
   11466:	ee 24       	eor	r14, r14
   11468:	ff 24       	eor	r15, r15
   1146a:	a7 01       	movw	r20, r14
   1146c:	e7 01       	movw	r28, r14
   1146e:	05 90       	lpm	r0, Z+
   11470:	08 94       	sec
   11472:	07 94       	ror	r0
   11474:	28 f4       	brcc	.+10     	; 0x11480 <__ftoa_engine+0x80>
   11476:	36 0f       	add	r19, r22
   11478:	e7 1e       	adc	r14, r23
   1147a:	f8 1e       	adc	r15, r24
   1147c:	49 1f       	adc	r20, r25
   1147e:	51 1d       	adc	r21, r1
   11480:	66 0f       	add	r22, r22
   11482:	77 1f       	adc	r23, r23
   11484:	88 1f       	adc	r24, r24
   11486:	99 1f       	adc	r25, r25
   11488:	06 94       	lsr	r0
   1148a:	a1 f7       	brne	.-24     	; 0x11474 <__ftoa_engine+0x74>
   1148c:	05 90       	lpm	r0, Z+
   1148e:	07 94       	ror	r0
   11490:	28 f4       	brcc	.+10     	; 0x1149c <__ftoa_engine+0x9c>
   11492:	e7 0e       	add	r14, r23
   11494:	f8 1e       	adc	r15, r24
   11496:	49 1f       	adc	r20, r25
   11498:	56 1f       	adc	r21, r22
   1149a:	c1 1d       	adc	r28, r1
   1149c:	77 0f       	add	r23, r23
   1149e:	88 1f       	adc	r24, r24
   114a0:	99 1f       	adc	r25, r25
   114a2:	66 1f       	adc	r22, r22
   114a4:	06 94       	lsr	r0
   114a6:	a1 f7       	brne	.-24     	; 0x11490 <__ftoa_engine+0x90>
   114a8:	05 90       	lpm	r0, Z+
   114aa:	07 94       	ror	r0
   114ac:	28 f4       	brcc	.+10     	; 0x114b8 <__ftoa_engine+0xb8>
   114ae:	f8 0e       	add	r15, r24
   114b0:	49 1f       	adc	r20, r25
   114b2:	56 1f       	adc	r21, r22
   114b4:	c7 1f       	adc	r28, r23
   114b6:	d1 1d       	adc	r29, r1
   114b8:	88 0f       	add	r24, r24
   114ba:	99 1f       	adc	r25, r25
   114bc:	66 1f       	adc	r22, r22
   114be:	77 1f       	adc	r23, r23
   114c0:	06 94       	lsr	r0
   114c2:	a1 f7       	brne	.-24     	; 0x114ac <__ftoa_engine+0xac>
   114c4:	05 90       	lpm	r0, Z+
   114c6:	07 94       	ror	r0
   114c8:	20 f4       	brcc	.+8      	; 0x114d2 <__ftoa_engine+0xd2>
   114ca:	49 0f       	add	r20, r25
   114cc:	56 1f       	adc	r21, r22
   114ce:	c7 1f       	adc	r28, r23
   114d0:	d8 1f       	adc	r29, r24
   114d2:	99 0f       	add	r25, r25
   114d4:	66 1f       	adc	r22, r22
   114d6:	77 1f       	adc	r23, r23
   114d8:	88 1f       	adc	r24, r24
   114da:	06 94       	lsr	r0
   114dc:	a9 f7       	brne	.-22     	; 0x114c8 <__ftoa_engine+0xc8>
   114de:	84 91       	lpm	r24, Z+
   114e0:	10 95       	com	r17
   114e2:	17 70       	andi	r17, 0x07	; 7
   114e4:	41 f0       	breq	.+16     	; 0x114f6 <__ftoa_engine+0xf6>
   114e6:	d6 95       	lsr	r29
   114e8:	c7 95       	ror	r28
   114ea:	57 95       	ror	r21
   114ec:	47 95       	ror	r20
   114ee:	f7 94       	ror	r15
   114f0:	e7 94       	ror	r14
   114f2:	1a 95       	dec	r17
   114f4:	c1 f7       	brne	.-16     	; 0x114e6 <__ftoa_engine+0xe6>
   114f6:	ee ef       	ldi	r30, 0xFE	; 254
   114f8:	f3 e4       	ldi	r31, 0x43	; 67
   114fa:	68 94       	set
   114fc:	15 90       	lpm	r1, Z+
   114fe:	15 91       	lpm	r17, Z+
   11500:	35 91       	lpm	r19, Z+
   11502:	65 91       	lpm	r22, Z+
   11504:	95 91       	lpm	r25, Z+
   11506:	05 90       	lpm	r0, Z+
   11508:	7f e2       	ldi	r23, 0x2F	; 47
   1150a:	73 95       	inc	r23
   1150c:	e1 18       	sub	r14, r1
   1150e:	f1 0a       	sbc	r15, r17
   11510:	43 0b       	sbc	r20, r19
   11512:	56 0b       	sbc	r21, r22
   11514:	c9 0b       	sbc	r28, r25
   11516:	d0 09       	sbc	r29, r0
   11518:	c0 f7       	brcc	.-16     	; 0x1150a <__ftoa_engine+0x10a>
   1151a:	e1 0c       	add	r14, r1
   1151c:	f1 1e       	adc	r15, r17
   1151e:	43 1f       	adc	r20, r19
   11520:	56 1f       	adc	r21, r22
   11522:	c9 1f       	adc	r28, r25
   11524:	d0 1d       	adc	r29, r0
   11526:	7e f4       	brtc	.+30     	; 0x11546 <__ftoa_engine+0x146>
   11528:	70 33       	cpi	r23, 0x30	; 48
   1152a:	11 f4       	brne	.+4      	; 0x11530 <__ftoa_engine+0x130>
   1152c:	8a 95       	dec	r24
   1152e:	e6 cf       	rjmp	.-52     	; 0x114fc <__ftoa_engine+0xfc>
   11530:	e8 94       	clt
   11532:	01 50       	subi	r16, 0x01	; 1
   11534:	30 f0       	brcs	.+12     	; 0x11542 <__ftoa_engine+0x142>
   11536:	08 0f       	add	r16, r24
   11538:	0a f4       	brpl	.+2      	; 0x1153c <__ftoa_engine+0x13c>
   1153a:	00 27       	eor	r16, r16
   1153c:	02 17       	cp	r16, r18
   1153e:	08 f4       	brcc	.+2      	; 0x11542 <__ftoa_engine+0x142>
   11540:	20 2f       	mov	r18, r16
   11542:	23 95       	inc	r18
   11544:	02 2f       	mov	r16, r18
   11546:	7a 33       	cpi	r23, 0x3A	; 58
   11548:	28 f0       	brcs	.+10     	; 0x11554 <__ftoa_engine+0x154>
   1154a:	79 e3       	ldi	r23, 0x39	; 57
   1154c:	7d 93       	st	X+, r23
   1154e:	2a 95       	dec	r18
   11550:	e9 f7       	brne	.-6      	; 0x1154c <__ftoa_engine+0x14c>
   11552:	10 c0       	rjmp	.+32     	; 0x11574 <__ftoa_engine+0x174>
   11554:	7d 93       	st	X+, r23
   11556:	2a 95       	dec	r18
   11558:	89 f6       	brne	.-94     	; 0x114fc <__ftoa_engine+0xfc>
   1155a:	06 94       	lsr	r0
   1155c:	97 95       	ror	r25
   1155e:	67 95       	ror	r22
   11560:	37 95       	ror	r19
   11562:	17 95       	ror	r17
   11564:	17 94       	ror	r1
   11566:	e1 18       	sub	r14, r1
   11568:	f1 0a       	sbc	r15, r17
   1156a:	43 0b       	sbc	r20, r19
   1156c:	56 0b       	sbc	r21, r22
   1156e:	c9 0b       	sbc	r28, r25
   11570:	d0 09       	sbc	r29, r0
   11572:	98 f0       	brcs	.+38     	; 0x1159a <__ftoa_engine+0x19a>
   11574:	23 95       	inc	r18
   11576:	7e 91       	ld	r23, -X
   11578:	73 95       	inc	r23
   1157a:	7a 33       	cpi	r23, 0x3A	; 58
   1157c:	08 f0       	brcs	.+2      	; 0x11580 <__ftoa_engine+0x180>
   1157e:	70 e3       	ldi	r23, 0x30	; 48
   11580:	7c 93       	st	X, r23
   11582:	20 13       	cpse	r18, r16
   11584:	b8 f7       	brcc	.-18     	; 0x11574 <__ftoa_engine+0x174>
   11586:	7e 91       	ld	r23, -X
   11588:	70 61       	ori	r23, 0x10	; 16
   1158a:	7d 93       	st	X+, r23
   1158c:	30 f0       	brcs	.+12     	; 0x1159a <__ftoa_engine+0x19a>
   1158e:	83 95       	inc	r24
   11590:	71 e3       	ldi	r23, 0x31	; 49
   11592:	7d 93       	st	X+, r23
   11594:	70 e3       	ldi	r23, 0x30	; 48
   11596:	2a 95       	dec	r18
   11598:	e1 f7       	brne	.-8      	; 0x11592 <__ftoa_engine+0x192>
   1159a:	11 24       	eor	r1, r1
   1159c:	ef 90       	pop	r14
   1159e:	ff 90       	pop	r15
   115a0:	0f 91       	pop	r16
   115a2:	1f 91       	pop	r17
   115a4:	cf 91       	pop	r28
   115a6:	df 91       	pop	r29
   115a8:	99 27       	eor	r25, r25
   115aa:	87 fd       	sbrc	r24, 7
   115ac:	90 95       	com	r25
   115ae:	08 95       	ret

000115b0 <isspace>:
   115b0:	91 11       	cpse	r25, r1
   115b2:	7c c3       	rjmp	.+1784   	; 0x11cac <__ctype_isfalse>
   115b4:	80 32       	cpi	r24, 0x20	; 32
   115b6:	19 f0       	breq	.+6      	; 0x115be <isspace+0xe>
   115b8:	89 50       	subi	r24, 0x09	; 9
   115ba:	85 50       	subi	r24, 0x05	; 5
   115bc:	d0 f7       	brcc	.-12     	; 0x115b2 <isspace+0x2>
   115be:	08 95       	ret

000115c0 <tolower>:
   115c0:	91 11       	cpse	r25, r1
   115c2:	08 95       	ret
   115c4:	81 54       	subi	r24, 0x41	; 65
   115c6:	8a 51       	subi	r24, 0x1A	; 26
   115c8:	08 f4       	brcc	.+2      	; 0x115cc <tolower+0xc>
   115ca:	80 5e       	subi	r24, 0xE0	; 224
   115cc:	85 5a       	subi	r24, 0xA5	; 165
   115ce:	08 95       	ret

000115d0 <strchr_P>:
   115d0:	fc 01       	movw	r30, r24
   115d2:	05 90       	lpm	r0, Z+
   115d4:	06 16       	cp	r0, r22
   115d6:	21 f0       	breq	.+8      	; 0x115e0 <strchr_P+0x10>
   115d8:	00 20       	and	r0, r0
   115da:	d9 f7       	brne	.-10     	; 0x115d2 <strchr_P+0x2>
   115dc:	c0 01       	movw	r24, r0
   115de:	08 95       	ret
   115e0:	31 97       	sbiw	r30, 0x01	; 1
   115e2:	cf 01       	movw	r24, r30
   115e4:	08 95       	ret

000115e6 <strcmp_P>:
   115e6:	fb 01       	movw	r30, r22
   115e8:	dc 01       	movw	r26, r24
   115ea:	8d 91       	ld	r24, X+
   115ec:	05 90       	lpm	r0, Z+
   115ee:	80 19       	sub	r24, r0
   115f0:	01 10       	cpse	r0, r1
   115f2:	d9 f3       	breq	.-10     	; 0x115ea <strcmp_P+0x4>
   115f4:	99 0b       	sbc	r25, r25
   115f6:	08 95       	ret

000115f8 <strcpy_P>:
   115f8:	fb 01       	movw	r30, r22
   115fa:	dc 01       	movw	r26, r24
   115fc:	05 90       	lpm	r0, Z+
   115fe:	0d 92       	st	X+, r0
   11600:	00 20       	and	r0, r0
   11602:	e1 f7       	brne	.-8      	; 0x115fc <strcpy_P+0x4>
   11604:	08 95       	ret

00011606 <strlen_P>:
   11606:	fc 01       	movw	r30, r24
   11608:	05 90       	lpm	r0, Z+
   1160a:	00 20       	and	r0, r0
   1160c:	e9 f7       	brne	.-6      	; 0x11608 <strlen_P+0x2>
   1160e:	80 95       	com	r24
   11610:	90 95       	com	r25
   11612:	8e 0f       	add	r24, r30
   11614:	9f 1f       	adc	r25, r31
   11616:	08 95       	ret

00011618 <strncmp_P>:
   11618:	fb 01       	movw	r30, r22
   1161a:	dc 01       	movw	r26, r24
   1161c:	41 50       	subi	r20, 0x01	; 1
   1161e:	50 40       	sbci	r21, 0x00	; 0
   11620:	30 f0       	brcs	.+12     	; 0x1162e <strncmp_P+0x16>
   11622:	8d 91       	ld	r24, X+
   11624:	05 90       	lpm	r0, Z+
   11626:	80 19       	sub	r24, r0
   11628:	19 f4       	brne	.+6      	; 0x11630 <strncmp_P+0x18>
   1162a:	00 20       	and	r0, r0
   1162c:	b9 f7       	brne	.-18     	; 0x1161c <strncmp_P+0x4>
   1162e:	88 1b       	sub	r24, r24
   11630:	99 0b       	sbc	r25, r25
   11632:	08 95       	ret

00011634 <strnlen_P>:
   11634:	fc 01       	movw	r30, r24
   11636:	05 90       	lpm	r0, Z+
   11638:	61 50       	subi	r22, 0x01	; 1
   1163a:	70 40       	sbci	r23, 0x00	; 0
   1163c:	01 10       	cpse	r0, r1
   1163e:	d8 f7       	brcc	.-10     	; 0x11636 <strnlen_P+0x2>
   11640:	80 95       	com	r24
   11642:	90 95       	com	r25
   11644:	8e 0f       	add	r24, r30
   11646:	9f 1f       	adc	r25, r31
   11648:	08 95       	ret

0001164a <strstr_P>:
   1164a:	fb 01       	movw	r30, r22
   1164c:	55 91       	lpm	r21, Z+
   1164e:	55 23       	and	r21, r21
   11650:	a9 f0       	breq	.+42     	; 0x1167c <strstr_P+0x32>
   11652:	bf 01       	movw	r22, r30
   11654:	dc 01       	movw	r26, r24
   11656:	4d 91       	ld	r20, X+
   11658:	45 17       	cp	r20, r21
   1165a:	41 11       	cpse	r20, r1
   1165c:	e1 f7       	brne	.-8      	; 0x11656 <strstr_P+0xc>
   1165e:	59 f4       	brne	.+22     	; 0x11676 <strstr_P+0x2c>
   11660:	cd 01       	movw	r24, r26
   11662:	05 90       	lpm	r0, Z+
   11664:	00 20       	and	r0, r0
   11666:	49 f0       	breq	.+18     	; 0x1167a <strstr_P+0x30>
   11668:	4d 91       	ld	r20, X+
   1166a:	40 15       	cp	r20, r0
   1166c:	41 11       	cpse	r20, r1
   1166e:	c9 f3       	breq	.-14     	; 0x11662 <strstr_P+0x18>
   11670:	fb 01       	movw	r30, r22
   11672:	41 11       	cpse	r20, r1
   11674:	ef cf       	rjmp	.-34     	; 0x11654 <strstr_P+0xa>
   11676:	81 e0       	ldi	r24, 0x01	; 1
   11678:	90 e0       	ldi	r25, 0x00	; 0
   1167a:	01 97       	sbiw	r24, 0x01	; 1
   1167c:	08 95       	ret

0001167e <memcpy>:
   1167e:	fb 01       	movw	r30, r22
   11680:	dc 01       	movw	r26, r24
   11682:	02 c0       	rjmp	.+4      	; 0x11688 <memcpy+0xa>
   11684:	01 90       	ld	r0, Z+
   11686:	0d 92       	st	X+, r0
   11688:	41 50       	subi	r20, 0x01	; 1
   1168a:	50 40       	sbci	r21, 0x00	; 0
   1168c:	d8 f7       	brcc	.-10     	; 0x11684 <memcpy+0x6>
   1168e:	08 95       	ret

00011690 <strchr>:
   11690:	fc 01       	movw	r30, r24
   11692:	81 91       	ld	r24, Z+
   11694:	86 17       	cp	r24, r22
   11696:	21 f0       	breq	.+8      	; 0x116a0 <strchr+0x10>
   11698:	88 23       	and	r24, r24
   1169a:	d9 f7       	brne	.-10     	; 0x11692 <strchr+0x2>
   1169c:	99 27       	eor	r25, r25
   1169e:	08 95       	ret
   116a0:	31 97       	sbiw	r30, 0x01	; 1
   116a2:	cf 01       	movw	r24, r30
   116a4:	08 95       	ret

000116a6 <strcmp>:
   116a6:	fb 01       	movw	r30, r22
   116a8:	dc 01       	movw	r26, r24
   116aa:	8d 91       	ld	r24, X+
   116ac:	01 90       	ld	r0, Z+
   116ae:	80 19       	sub	r24, r0
   116b0:	01 10       	cpse	r0, r1
   116b2:	d9 f3       	breq	.-10     	; 0x116aa <strcmp+0x4>
   116b4:	99 0b       	sbc	r25, r25
   116b6:	08 95       	ret

000116b8 <strnlen>:
   116b8:	fc 01       	movw	r30, r24
   116ba:	61 50       	subi	r22, 0x01	; 1
   116bc:	70 40       	sbci	r23, 0x00	; 0
   116be:	01 90       	ld	r0, Z+
   116c0:	01 10       	cpse	r0, r1
   116c2:	d8 f7       	brcc	.-10     	; 0x116ba <strnlen+0x2>
   116c4:	80 95       	com	r24
   116c6:	90 95       	com	r25
   116c8:	8e 0f       	add	r24, r30
   116ca:	9f 1f       	adc	r25, r31
   116cc:	08 95       	ret

000116ce <strstr>:
   116ce:	fb 01       	movw	r30, r22
   116d0:	51 91       	ld	r21, Z+
   116d2:	55 23       	and	r21, r21
   116d4:	a9 f0       	breq	.+42     	; 0x11700 <strstr+0x32>
   116d6:	bf 01       	movw	r22, r30
   116d8:	dc 01       	movw	r26, r24
   116da:	4d 91       	ld	r20, X+
   116dc:	45 17       	cp	r20, r21
   116de:	41 11       	cpse	r20, r1
   116e0:	e1 f7       	brne	.-8      	; 0x116da <strstr+0xc>
   116e2:	59 f4       	brne	.+22     	; 0x116fa <strstr+0x2c>
   116e4:	cd 01       	movw	r24, r26
   116e6:	01 90       	ld	r0, Z+
   116e8:	00 20       	and	r0, r0
   116ea:	49 f0       	breq	.+18     	; 0x116fe <strstr+0x30>
   116ec:	4d 91       	ld	r20, X+
   116ee:	40 15       	cp	r20, r0
   116f0:	41 11       	cpse	r20, r1
   116f2:	c9 f3       	breq	.-14     	; 0x116e6 <strstr+0x18>
   116f4:	fb 01       	movw	r30, r22
   116f6:	41 11       	cpse	r20, r1
   116f8:	ef cf       	rjmp	.-34     	; 0x116d8 <strstr+0xa>
   116fa:	81 e0       	ldi	r24, 0x01	; 1
   116fc:	90 e0       	ldi	r25, 0x00	; 0
   116fe:	01 97       	sbiw	r24, 0x01	; 1
   11700:	08 95       	ret

00011702 <fgetc>:
   11702:	cf 93       	push	r28
   11704:	df 93       	push	r29
   11706:	ec 01       	movw	r28, r24
   11708:	4b 81       	ldd	r20, Y+3	; 0x03
   1170a:	40 ff       	sbrs	r20, 0
   1170c:	1a c0       	rjmp	.+52     	; 0x11742 <fgetc+0x40>
   1170e:	46 ff       	sbrs	r20, 6
   11710:	0a c0       	rjmp	.+20     	; 0x11726 <fgetc+0x24>
   11712:	4f 7b       	andi	r20, 0xBF	; 191
   11714:	4b 83       	std	Y+3, r20	; 0x03
   11716:	8e 81       	ldd	r24, Y+6	; 0x06
   11718:	9f 81       	ldd	r25, Y+7	; 0x07
   1171a:	01 96       	adiw	r24, 0x01	; 1
   1171c:	9f 83       	std	Y+7, r25	; 0x07
   1171e:	8e 83       	std	Y+6, r24	; 0x06
   11720:	8a 81       	ldd	r24, Y+2	; 0x02
   11722:	28 2f       	mov	r18, r24
   11724:	2b c0       	rjmp	.+86     	; 0x1177c <fgetc+0x7a>
   11726:	42 ff       	sbrs	r20, 2
   11728:	13 c0       	rjmp	.+38     	; 0x11750 <fgetc+0x4e>
   1172a:	e8 81       	ld	r30, Y
   1172c:	f9 81       	ldd	r31, Y+1	; 0x01
   1172e:	80 81       	ld	r24, Z
   11730:	28 2f       	mov	r18, r24
   11732:	33 27       	eor	r19, r19
   11734:	27 fd       	sbrc	r18, 7
   11736:	30 95       	com	r19
   11738:	21 15       	cp	r18, r1
   1173a:	31 05       	cpc	r19, r1
   1173c:	29 f4       	brne	.+10     	; 0x11748 <fgetc+0x46>
   1173e:	40 62       	ori	r20, 0x20	; 32
   11740:	4b 83       	std	Y+3, r20	; 0x03
   11742:	2f ef       	ldi	r18, 0xFF	; 255
   11744:	3f ef       	ldi	r19, 0xFF	; 255
   11746:	1b c0       	rjmp	.+54     	; 0x1177e <fgetc+0x7c>
   11748:	31 96       	adiw	r30, 0x01	; 1
   1174a:	f9 83       	std	Y+1, r31	; 0x01
   1174c:	e8 83       	st	Y, r30
   1174e:	11 c0       	rjmp	.+34     	; 0x11772 <fgetc+0x70>
   11750:	ea 85       	ldd	r30, Y+10	; 0x0a
   11752:	fb 85       	ldd	r31, Y+11	; 0x0b
   11754:	ce 01       	movw	r24, r28
   11756:	19 95       	eicall
   11758:	9c 01       	movw	r18, r24
   1175a:	97 ff       	sbrs	r25, 7
   1175c:	0a c0       	rjmp	.+20     	; 0x11772 <fgetc+0x70>
   1175e:	9b 81       	ldd	r25, Y+3	; 0x03
   11760:	2f 5f       	subi	r18, 0xFF	; 255
   11762:	3f 4f       	sbci	r19, 0xFF	; 255
   11764:	11 f0       	breq	.+4      	; 0x1176a <fgetc+0x68>
   11766:	80 e2       	ldi	r24, 0x20	; 32
   11768:	01 c0       	rjmp	.+2      	; 0x1176c <fgetc+0x6a>
   1176a:	80 e1       	ldi	r24, 0x10	; 16
   1176c:	89 2b       	or	r24, r25
   1176e:	8b 83       	std	Y+3, r24	; 0x03
   11770:	e8 cf       	rjmp	.-48     	; 0x11742 <fgetc+0x40>
   11772:	8e 81       	ldd	r24, Y+6	; 0x06
   11774:	9f 81       	ldd	r25, Y+7	; 0x07
   11776:	01 96       	adiw	r24, 0x01	; 1
   11778:	9f 83       	std	Y+7, r25	; 0x07
   1177a:	8e 83       	std	Y+6, r24	; 0x06
   1177c:	30 e0       	ldi	r19, 0x00	; 0
   1177e:	c9 01       	movw	r24, r18
   11780:	df 91       	pop	r29
   11782:	cf 91       	pop	r28
   11784:	08 95       	ret

00011786 <fputc>:
   11786:	0f 93       	push	r16
   11788:	1f 93       	push	r17
   1178a:	cf 93       	push	r28
   1178c:	df 93       	push	r29
   1178e:	8c 01       	movw	r16, r24
   11790:	eb 01       	movw	r28, r22
   11792:	8b 81       	ldd	r24, Y+3	; 0x03
   11794:	81 ff       	sbrs	r24, 1
   11796:	1b c0       	rjmp	.+54     	; 0x117ce <fputc+0x48>
   11798:	82 ff       	sbrs	r24, 2
   1179a:	0d c0       	rjmp	.+26     	; 0x117b6 <fputc+0x30>
   1179c:	2e 81       	ldd	r18, Y+6	; 0x06
   1179e:	3f 81       	ldd	r19, Y+7	; 0x07
   117a0:	8c 81       	ldd	r24, Y+4	; 0x04
   117a2:	9d 81       	ldd	r25, Y+5	; 0x05
   117a4:	28 17       	cp	r18, r24
   117a6:	39 07       	cpc	r19, r25
   117a8:	64 f4       	brge	.+24     	; 0x117c2 <fputc+0x3c>
   117aa:	e8 81       	ld	r30, Y
   117ac:	f9 81       	ldd	r31, Y+1	; 0x01
   117ae:	01 93       	st	Z+, r16
   117b0:	f9 83       	std	Y+1, r31	; 0x01
   117b2:	e8 83       	st	Y, r30
   117b4:	06 c0       	rjmp	.+12     	; 0x117c2 <fputc+0x3c>
   117b6:	e8 85       	ldd	r30, Y+8	; 0x08
   117b8:	f9 85       	ldd	r31, Y+9	; 0x09
   117ba:	80 2f       	mov	r24, r16
   117bc:	19 95       	eicall
   117be:	89 2b       	or	r24, r25
   117c0:	31 f4       	brne	.+12     	; 0x117ce <fputc+0x48>
   117c2:	8e 81       	ldd	r24, Y+6	; 0x06
   117c4:	9f 81       	ldd	r25, Y+7	; 0x07
   117c6:	01 96       	adiw	r24, 0x01	; 1
   117c8:	9f 83       	std	Y+7, r25	; 0x07
   117ca:	8e 83       	std	Y+6, r24	; 0x06
   117cc:	02 c0       	rjmp	.+4      	; 0x117d2 <fputc+0x4c>
   117ce:	0f ef       	ldi	r16, 0xFF	; 255
   117d0:	1f ef       	ldi	r17, 0xFF	; 255
   117d2:	c8 01       	movw	r24, r16
   117d4:	df 91       	pop	r29
   117d6:	cf 91       	pop	r28
   117d8:	1f 91       	pop	r17
   117da:	0f 91       	pop	r16
   117dc:	08 95       	ret

000117de <sprintf>:
   117de:	0f 93       	push	r16
   117e0:	1f 93       	push	r17
   117e2:	df 93       	push	r29
   117e4:	cf 93       	push	r28
   117e6:	cd b7       	in	r28, 0x3d	; 61
   117e8:	de b7       	in	r29, 0x3e	; 62
   117ea:	2e 97       	sbiw	r28, 0x0e	; 14
   117ec:	0f b6       	in	r0, 0x3f	; 63
   117ee:	f8 94       	cli
   117f0:	de bf       	out	0x3e, r29	; 62
   117f2:	0f be       	out	0x3f, r0	; 63
   117f4:	cd bf       	out	0x3d, r28	; 61
   117f6:	0e 89       	ldd	r16, Y+22	; 0x16
   117f8:	1f 89       	ldd	r17, Y+23	; 0x17
   117fa:	86 e0       	ldi	r24, 0x06	; 6
   117fc:	8c 83       	std	Y+4, r24	; 0x04
   117fe:	1a 83       	std	Y+2, r17	; 0x02
   11800:	09 83       	std	Y+1, r16	; 0x01
   11802:	8f ef       	ldi	r24, 0xFF	; 255
   11804:	9f e7       	ldi	r25, 0x7F	; 127
   11806:	9e 83       	std	Y+6, r25	; 0x06
   11808:	8d 83       	std	Y+5, r24	; 0x05
   1180a:	9e 01       	movw	r18, r28
   1180c:	26 5e       	subi	r18, 0xE6	; 230
   1180e:	3f 4f       	sbci	r19, 0xFF	; 255
   11810:	ce 01       	movw	r24, r28
   11812:	01 96       	adiw	r24, 0x01	; 1
   11814:	68 8d       	ldd	r22, Y+24	; 0x18
   11816:	79 8d       	ldd	r23, Y+25	; 0x19
   11818:	a9 01       	movw	r20, r18
   1181a:	0e 94 16 81 	call	0x1022c	; 0x1022c <vfprintf>
   1181e:	2f 81       	ldd	r18, Y+7	; 0x07
   11820:	38 85       	ldd	r19, Y+8	; 0x08
   11822:	02 0f       	add	r16, r18
   11824:	13 1f       	adc	r17, r19
   11826:	f8 01       	movw	r30, r16
   11828:	10 82       	st	Z, r1
   1182a:	2e 96       	adiw	r28, 0x0e	; 14
   1182c:	0f b6       	in	r0, 0x3f	; 63
   1182e:	f8 94       	cli
   11830:	de bf       	out	0x3e, r29	; 62
   11832:	0f be       	out	0x3f, r0	; 63
   11834:	cd bf       	out	0x3d, r28	; 61
   11836:	cf 91       	pop	r28
   11838:	df 91       	pop	r29
   1183a:	1f 91       	pop	r17
   1183c:	0f 91       	pop	r16
   1183e:	08 95       	ret

00011840 <sprintf_P>:
   11840:	0f 93       	push	r16
   11842:	1f 93       	push	r17
   11844:	df 93       	push	r29
   11846:	cf 93       	push	r28
   11848:	cd b7       	in	r28, 0x3d	; 61
   1184a:	de b7       	in	r29, 0x3e	; 62
   1184c:	2e 97       	sbiw	r28, 0x0e	; 14
   1184e:	0f b6       	in	r0, 0x3f	; 63
   11850:	f8 94       	cli
   11852:	de bf       	out	0x3e, r29	; 62
   11854:	0f be       	out	0x3f, r0	; 63
   11856:	cd bf       	out	0x3d, r28	; 61
   11858:	0e 89       	ldd	r16, Y+22	; 0x16
   1185a:	1f 89       	ldd	r17, Y+23	; 0x17
   1185c:	8e e0       	ldi	r24, 0x0E	; 14
   1185e:	8c 83       	std	Y+4, r24	; 0x04
   11860:	1a 83       	std	Y+2, r17	; 0x02
   11862:	09 83       	std	Y+1, r16	; 0x01
   11864:	8f ef       	ldi	r24, 0xFF	; 255
   11866:	9f e7       	ldi	r25, 0x7F	; 127
   11868:	9e 83       	std	Y+6, r25	; 0x06
   1186a:	8d 83       	std	Y+5, r24	; 0x05
   1186c:	9e 01       	movw	r18, r28
   1186e:	26 5e       	subi	r18, 0xE6	; 230
   11870:	3f 4f       	sbci	r19, 0xFF	; 255
   11872:	ce 01       	movw	r24, r28
   11874:	01 96       	adiw	r24, 0x01	; 1
   11876:	68 8d       	ldd	r22, Y+24	; 0x18
   11878:	79 8d       	ldd	r23, Y+25	; 0x19
   1187a:	a9 01       	movw	r20, r18
   1187c:	0e 94 16 81 	call	0x1022c	; 0x1022c <vfprintf>
   11880:	2f 81       	ldd	r18, Y+7	; 0x07
   11882:	38 85       	ldd	r19, Y+8	; 0x08
   11884:	02 0f       	add	r16, r18
   11886:	13 1f       	adc	r17, r19
   11888:	f8 01       	movw	r30, r16
   1188a:	10 82       	st	Z, r1
   1188c:	2e 96       	adiw	r28, 0x0e	; 14
   1188e:	0f b6       	in	r0, 0x3f	; 63
   11890:	f8 94       	cli
   11892:	de bf       	out	0x3e, r29	; 62
   11894:	0f be       	out	0x3f, r0	; 63
   11896:	cd bf       	out	0x3d, r28	; 61
   11898:	cf 91       	pop	r28
   1189a:	df 91       	pop	r29
   1189c:	1f 91       	pop	r17
   1189e:	0f 91       	pop	r16
   118a0:	08 95       	ret

000118a2 <sscanf>:
   118a2:	df 93       	push	r29
   118a4:	cf 93       	push	r28
   118a6:	cd b7       	in	r28, 0x3d	; 61
   118a8:	de b7       	in	r29, 0x3e	; 62
   118aa:	2e 97       	sbiw	r28, 0x0e	; 14
   118ac:	0f b6       	in	r0, 0x3f	; 63
   118ae:	f8 94       	cli
   118b0:	de bf       	out	0x3e, r29	; 62
   118b2:	0f be       	out	0x3f, r0	; 63
   118b4:	cd bf       	out	0x3d, r28	; 61
   118b6:	85 e0       	ldi	r24, 0x05	; 5
   118b8:	8c 83       	std	Y+4, r24	; 0x04
   118ba:	8c 89       	ldd	r24, Y+20	; 0x14
   118bc:	9d 89       	ldd	r25, Y+21	; 0x15
   118be:	9a 83       	std	Y+2, r25	; 0x02
   118c0:	89 83       	std	Y+1, r24	; 0x01
   118c2:	9e 01       	movw	r18, r28
   118c4:	28 5e       	subi	r18, 0xE8	; 232
   118c6:	3f 4f       	sbci	r19, 0xFF	; 255
   118c8:	ce 01       	movw	r24, r28
   118ca:	01 96       	adiw	r24, 0x01	; 1
   118cc:	6e 89       	ldd	r22, Y+22	; 0x16
   118ce:	7f 89       	ldd	r23, Y+23	; 0x17
   118d0:	a9 01       	movw	r20, r18
   118d2:	0e 94 cd 87 	call	0x10f9a	; 0x10f9a <vfscanf>
   118d6:	2e 96       	adiw	r28, 0x0e	; 14
   118d8:	0f b6       	in	r0, 0x3f	; 63
   118da:	f8 94       	cli
   118dc:	de bf       	out	0x3e, r29	; 62
   118de:	0f be       	out	0x3f, r0	; 63
   118e0:	cd bf       	out	0x3d, r28	; 61
   118e2:	cf 91       	pop	r28
   118e4:	df 91       	pop	r29
   118e6:	08 95       	ret

000118e8 <sscanf_P>:
   118e8:	df 93       	push	r29
   118ea:	cf 93       	push	r28
   118ec:	cd b7       	in	r28, 0x3d	; 61
   118ee:	de b7       	in	r29, 0x3e	; 62
   118f0:	2e 97       	sbiw	r28, 0x0e	; 14
   118f2:	0f b6       	in	r0, 0x3f	; 63
   118f4:	f8 94       	cli
   118f6:	de bf       	out	0x3e, r29	; 62
   118f8:	0f be       	out	0x3f, r0	; 63
   118fa:	cd bf       	out	0x3d, r28	; 61
   118fc:	8d e0       	ldi	r24, 0x0D	; 13
   118fe:	8c 83       	std	Y+4, r24	; 0x04
   11900:	8c 89       	ldd	r24, Y+20	; 0x14
   11902:	9d 89       	ldd	r25, Y+21	; 0x15
   11904:	9a 83       	std	Y+2, r25	; 0x02
   11906:	89 83       	std	Y+1, r24	; 0x01
   11908:	9e 01       	movw	r18, r28
   1190a:	28 5e       	subi	r18, 0xE8	; 232
   1190c:	3f 4f       	sbci	r19, 0xFF	; 255
   1190e:	ce 01       	movw	r24, r28
   11910:	01 96       	adiw	r24, 0x01	; 1
   11912:	6e 89       	ldd	r22, Y+22	; 0x16
   11914:	7f 89       	ldd	r23, Y+23	; 0x17
   11916:	a9 01       	movw	r20, r18
   11918:	0e 94 cd 87 	call	0x10f9a	; 0x10f9a <vfscanf>
   1191c:	2e 96       	adiw	r28, 0x0e	; 14
   1191e:	0f b6       	in	r0, 0x3f	; 63
   11920:	f8 94       	cli
   11922:	de bf       	out	0x3e, r29	; 62
   11924:	0f be       	out	0x3f, r0	; 63
   11926:	cd bf       	out	0x3d, r28	; 61
   11928:	cf 91       	pop	r28
   1192a:	df 91       	pop	r29
   1192c:	08 95       	ret

0001192e <ungetc>:
   1192e:	9c 01       	movw	r18, r24
   11930:	fb 01       	movw	r30, r22
   11932:	83 81       	ldd	r24, Z+3	; 0x03
   11934:	80 ff       	sbrs	r24, 0
   11936:	11 c0       	rjmp	.+34     	; 0x1195a <ungetc+0x2c>
   11938:	86 fd       	sbrc	r24, 6
   1193a:	0f c0       	rjmp	.+30     	; 0x1195a <ungetc+0x2c>
   1193c:	9f ef       	ldi	r25, 0xFF	; 255
   1193e:	2f 3f       	cpi	r18, 0xFF	; 255
   11940:	39 07       	cpc	r19, r25
   11942:	59 f0       	breq	.+22     	; 0x1195a <ungetc+0x2c>
   11944:	22 83       	std	Z+2, r18	; 0x02
   11946:	80 64       	ori	r24, 0x40	; 64
   11948:	8f 7d       	andi	r24, 0xDF	; 223
   1194a:	83 83       	std	Z+3, r24	; 0x03
   1194c:	86 81       	ldd	r24, Z+6	; 0x06
   1194e:	97 81       	ldd	r25, Z+7	; 0x07
   11950:	01 97       	sbiw	r24, 0x01	; 1
   11952:	97 83       	std	Z+7, r25	; 0x07
   11954:	86 83       	std	Z+6, r24	; 0x06
   11956:	30 e0       	ldi	r19, 0x00	; 0
   11958:	02 c0       	rjmp	.+4      	; 0x1195e <ungetc+0x30>
   1195a:	2f ef       	ldi	r18, 0xFF	; 255
   1195c:	3f ef       	ldi	r19, 0xFF	; 255
   1195e:	c9 01       	movw	r24, r18
   11960:	08 95       	ret

00011962 <__ultoa_invert>:
   11962:	fa 01       	movw	r30, r20
   11964:	aa 27       	eor	r26, r26
   11966:	28 30       	cpi	r18, 0x08	; 8
   11968:	51 f1       	breq	.+84     	; 0x119be <__ultoa_invert+0x5c>
   1196a:	20 31       	cpi	r18, 0x10	; 16
   1196c:	81 f1       	breq	.+96     	; 0x119ce <__ultoa_invert+0x6c>
   1196e:	e8 94       	clt
   11970:	6f 93       	push	r22
   11972:	6e 7f       	andi	r22, 0xFE	; 254
   11974:	6e 5f       	subi	r22, 0xFE	; 254
   11976:	7f 4f       	sbci	r23, 0xFF	; 255
   11978:	8f 4f       	sbci	r24, 0xFF	; 255
   1197a:	9f 4f       	sbci	r25, 0xFF	; 255
   1197c:	af 4f       	sbci	r26, 0xFF	; 255
   1197e:	b1 e0       	ldi	r27, 0x01	; 1
   11980:	3e d0       	rcall	.+124    	; 0x119fe <__ultoa_invert+0x9c>
   11982:	b4 e0       	ldi	r27, 0x04	; 4
   11984:	3c d0       	rcall	.+120    	; 0x119fe <__ultoa_invert+0x9c>
   11986:	67 0f       	add	r22, r23
   11988:	78 1f       	adc	r23, r24
   1198a:	89 1f       	adc	r24, r25
   1198c:	9a 1f       	adc	r25, r26
   1198e:	a1 1d       	adc	r26, r1
   11990:	68 0f       	add	r22, r24
   11992:	79 1f       	adc	r23, r25
   11994:	8a 1f       	adc	r24, r26
   11996:	91 1d       	adc	r25, r1
   11998:	a1 1d       	adc	r26, r1
   1199a:	6a 0f       	add	r22, r26
   1199c:	71 1d       	adc	r23, r1
   1199e:	81 1d       	adc	r24, r1
   119a0:	91 1d       	adc	r25, r1
   119a2:	a1 1d       	adc	r26, r1
   119a4:	20 d0       	rcall	.+64     	; 0x119e6 <__ultoa_invert+0x84>
   119a6:	09 f4       	brne	.+2      	; 0x119aa <__ultoa_invert+0x48>
   119a8:	68 94       	set
   119aa:	3f 91       	pop	r19
   119ac:	2a e0       	ldi	r18, 0x0A	; 10
   119ae:	26 9f       	mul	r18, r22
   119b0:	11 24       	eor	r1, r1
   119b2:	30 19       	sub	r19, r0
   119b4:	30 5d       	subi	r19, 0xD0	; 208
   119b6:	31 93       	st	Z+, r19
   119b8:	de f6       	brtc	.-74     	; 0x11970 <__ultoa_invert+0xe>
   119ba:	cf 01       	movw	r24, r30
   119bc:	08 95       	ret
   119be:	46 2f       	mov	r20, r22
   119c0:	47 70       	andi	r20, 0x07	; 7
   119c2:	40 5d       	subi	r20, 0xD0	; 208
   119c4:	41 93       	st	Z+, r20
   119c6:	b3 e0       	ldi	r27, 0x03	; 3
   119c8:	0f d0       	rcall	.+30     	; 0x119e8 <__ultoa_invert+0x86>
   119ca:	c9 f7       	brne	.-14     	; 0x119be <__ultoa_invert+0x5c>
   119cc:	f6 cf       	rjmp	.-20     	; 0x119ba <__ultoa_invert+0x58>
   119ce:	46 2f       	mov	r20, r22
   119d0:	4f 70       	andi	r20, 0x0F	; 15
   119d2:	40 5d       	subi	r20, 0xD0	; 208
   119d4:	4a 33       	cpi	r20, 0x3A	; 58
   119d6:	18 f0       	brcs	.+6      	; 0x119de <__ultoa_invert+0x7c>
   119d8:	49 5d       	subi	r20, 0xD9	; 217
   119da:	31 fd       	sbrc	r19, 1
   119dc:	40 52       	subi	r20, 0x20	; 32
   119de:	41 93       	st	Z+, r20
   119e0:	02 d0       	rcall	.+4      	; 0x119e6 <__ultoa_invert+0x84>
   119e2:	a9 f7       	brne	.-22     	; 0x119ce <__ultoa_invert+0x6c>
   119e4:	ea cf       	rjmp	.-44     	; 0x119ba <__ultoa_invert+0x58>
   119e6:	b4 e0       	ldi	r27, 0x04	; 4
   119e8:	a6 95       	lsr	r26
   119ea:	97 95       	ror	r25
   119ec:	87 95       	ror	r24
   119ee:	77 95       	ror	r23
   119f0:	67 95       	ror	r22
   119f2:	ba 95       	dec	r27
   119f4:	c9 f7       	brne	.-14     	; 0x119e8 <__ultoa_invert+0x86>
   119f6:	00 97       	sbiw	r24, 0x00	; 0
   119f8:	61 05       	cpc	r22, r1
   119fa:	71 05       	cpc	r23, r1
   119fc:	08 95       	ret
   119fe:	9b 01       	movw	r18, r22
   11a00:	ac 01       	movw	r20, r24
   11a02:	0a 2e       	mov	r0, r26
   11a04:	06 94       	lsr	r0
   11a06:	57 95       	ror	r21
   11a08:	47 95       	ror	r20
   11a0a:	37 95       	ror	r19
   11a0c:	27 95       	ror	r18
   11a0e:	ba 95       	dec	r27
   11a10:	c9 f7       	brne	.-14     	; 0x11a04 <__ultoa_invert+0xa2>
   11a12:	62 0f       	add	r22, r18
   11a14:	73 1f       	adc	r23, r19
   11a16:	84 1f       	adc	r24, r20
   11a18:	95 1f       	adc	r25, r21
   11a1a:	a0 1d       	adc	r26, r0
   11a1c:	08 95       	ret

00011a1e <__subsf3>:
   11a1e:	50 58       	subi	r21, 0x80	; 128

00011a20 <__addsf3>:
   11a20:	bb 27       	eor	r27, r27
   11a22:	aa 27       	eor	r26, r26
   11a24:	0e d0       	rcall	.+28     	; 0x11a42 <__addsf3x>
   11a26:	af cc       	rjmp	.-1698   	; 0x11386 <__fp_round>
   11a28:	a0 dc       	rcall	.-1728   	; 0x1136a <__fp_pscA>
   11a2a:	30 f0       	brcs	.+12     	; 0x11a38 <__addsf3+0x18>
   11a2c:	a5 dc       	rcall	.-1718   	; 0x11378 <__fp_pscB>
   11a2e:	20 f0       	brcs	.+8      	; 0x11a38 <__addsf3+0x18>
   11a30:	31 f4       	brne	.+12     	; 0x11a3e <__addsf3+0x1e>
   11a32:	9f 3f       	cpi	r25, 0xFF	; 255
   11a34:	11 f4       	brne	.+4      	; 0x11a3a <__addsf3+0x1a>
   11a36:	1e f4       	brtc	.+6      	; 0x11a3e <__addsf3+0x1e>
   11a38:	95 cc       	rjmp	.-1750   	; 0x11364 <__fp_nan>
   11a3a:	0e f4       	brtc	.+2      	; 0x11a3e <__addsf3+0x1e>
   11a3c:	e0 95       	com	r30
   11a3e:	e7 fb       	bst	r30, 7
   11a40:	8b cc       	rjmp	.-1770   	; 0x11358 <__fp_inf>

00011a42 <__addsf3x>:
   11a42:	e9 2f       	mov	r30, r25
   11a44:	b1 dc       	rcall	.-1694   	; 0x113a8 <__fp_split3>
   11a46:	80 f3       	brcs	.-32     	; 0x11a28 <__addsf3+0x8>
   11a48:	ba 17       	cp	r27, r26
   11a4a:	62 07       	cpc	r22, r18
   11a4c:	73 07       	cpc	r23, r19
   11a4e:	84 07       	cpc	r24, r20
   11a50:	95 07       	cpc	r25, r21
   11a52:	18 f0       	brcs	.+6      	; 0x11a5a <__addsf3x+0x18>
   11a54:	71 f4       	brne	.+28     	; 0x11a72 <__addsf3x+0x30>
   11a56:	9e f5       	brtc	.+102    	; 0x11abe <__addsf3x+0x7c>
   11a58:	c9 cc       	rjmp	.-1646   	; 0x113ec <__fp_zero>
   11a5a:	0e f4       	brtc	.+2      	; 0x11a5e <__addsf3x+0x1c>
   11a5c:	e0 95       	com	r30
   11a5e:	0b 2e       	mov	r0, r27
   11a60:	ba 2f       	mov	r27, r26
   11a62:	a0 2d       	mov	r26, r0
   11a64:	0b 01       	movw	r0, r22
   11a66:	b9 01       	movw	r22, r18
   11a68:	90 01       	movw	r18, r0
   11a6a:	0c 01       	movw	r0, r24
   11a6c:	ca 01       	movw	r24, r20
   11a6e:	a0 01       	movw	r20, r0
   11a70:	11 24       	eor	r1, r1
   11a72:	ff 27       	eor	r31, r31
   11a74:	59 1b       	sub	r21, r25
   11a76:	99 f0       	breq	.+38     	; 0x11a9e <__addsf3x+0x5c>
   11a78:	59 3f       	cpi	r21, 0xF9	; 249
   11a7a:	50 f4       	brcc	.+20     	; 0x11a90 <__addsf3x+0x4e>
   11a7c:	50 3e       	cpi	r21, 0xE0	; 224
   11a7e:	68 f1       	brcs	.+90     	; 0x11ada <__addsf3x+0x98>
   11a80:	1a 16       	cp	r1, r26
   11a82:	f0 40       	sbci	r31, 0x00	; 0
   11a84:	a2 2f       	mov	r26, r18
   11a86:	23 2f       	mov	r18, r19
   11a88:	34 2f       	mov	r19, r20
   11a8a:	44 27       	eor	r20, r20
   11a8c:	58 5f       	subi	r21, 0xF8	; 248
   11a8e:	f3 cf       	rjmp	.-26     	; 0x11a76 <__addsf3x+0x34>
   11a90:	46 95       	lsr	r20
   11a92:	37 95       	ror	r19
   11a94:	27 95       	ror	r18
   11a96:	a7 95       	ror	r26
   11a98:	f0 40       	sbci	r31, 0x00	; 0
   11a9a:	53 95       	inc	r21
   11a9c:	c9 f7       	brne	.-14     	; 0x11a90 <__addsf3x+0x4e>
   11a9e:	7e f4       	brtc	.+30     	; 0x11abe <__addsf3x+0x7c>
   11aa0:	1f 16       	cp	r1, r31
   11aa2:	ba 0b       	sbc	r27, r26
   11aa4:	62 0b       	sbc	r22, r18
   11aa6:	73 0b       	sbc	r23, r19
   11aa8:	84 0b       	sbc	r24, r20
   11aaa:	ba f0       	brmi	.+46     	; 0x11ada <__addsf3x+0x98>
   11aac:	91 50       	subi	r25, 0x01	; 1
   11aae:	a1 f0       	breq	.+40     	; 0x11ad8 <__addsf3x+0x96>
   11ab0:	ff 0f       	add	r31, r31
   11ab2:	bb 1f       	adc	r27, r27
   11ab4:	66 1f       	adc	r22, r22
   11ab6:	77 1f       	adc	r23, r23
   11ab8:	88 1f       	adc	r24, r24
   11aba:	c2 f7       	brpl	.-16     	; 0x11aac <__addsf3x+0x6a>
   11abc:	0e c0       	rjmp	.+28     	; 0x11ada <__addsf3x+0x98>
   11abe:	ba 0f       	add	r27, r26
   11ac0:	62 1f       	adc	r22, r18
   11ac2:	73 1f       	adc	r23, r19
   11ac4:	84 1f       	adc	r24, r20
   11ac6:	48 f4       	brcc	.+18     	; 0x11ada <__addsf3x+0x98>
   11ac8:	87 95       	ror	r24
   11aca:	77 95       	ror	r23
   11acc:	67 95       	ror	r22
   11ace:	b7 95       	ror	r27
   11ad0:	f7 95       	ror	r31
   11ad2:	9e 3f       	cpi	r25, 0xFE	; 254
   11ad4:	08 f0       	brcs	.+2      	; 0x11ad8 <__addsf3x+0x96>
   11ad6:	b3 cf       	rjmp	.-154    	; 0x11a3e <__addsf3+0x1e>
   11ad8:	93 95       	inc	r25
   11ada:	88 0f       	add	r24, r24
   11adc:	08 f0       	brcs	.+2      	; 0x11ae0 <__addsf3x+0x9e>
   11ade:	99 27       	eor	r25, r25
   11ae0:	ee 0f       	add	r30, r30
   11ae2:	97 95       	ror	r25
   11ae4:	87 95       	ror	r24
   11ae6:	08 95       	ret

00011ae8 <__divsf3>:
   11ae8:	0c d0       	rcall	.+24     	; 0x11b02 <__divsf3x>
   11aea:	4d cc       	rjmp	.-1894   	; 0x11386 <__fp_round>
   11aec:	45 dc       	rcall	.-1910   	; 0x11378 <__fp_pscB>
   11aee:	40 f0       	brcs	.+16     	; 0x11b00 <__divsf3+0x18>
   11af0:	3c dc       	rcall	.-1928   	; 0x1136a <__fp_pscA>
   11af2:	30 f0       	brcs	.+12     	; 0x11b00 <__divsf3+0x18>
   11af4:	21 f4       	brne	.+8      	; 0x11afe <__divsf3+0x16>
   11af6:	5f 3f       	cpi	r21, 0xFF	; 255
   11af8:	19 f0       	breq	.+6      	; 0x11b00 <__divsf3+0x18>
   11afa:	2e cc       	rjmp	.-1956   	; 0x11358 <__fp_inf>
   11afc:	51 11       	cpse	r21, r1
   11afe:	77 cc       	rjmp	.-1810   	; 0x113ee <__fp_szero>
   11b00:	31 cc       	rjmp	.-1950   	; 0x11364 <__fp_nan>

00011b02 <__divsf3x>:
   11b02:	52 dc       	rcall	.-1884   	; 0x113a8 <__fp_split3>
   11b04:	98 f3       	brcs	.-26     	; 0x11aec <__divsf3+0x4>

00011b06 <__divsf3_pse>:
   11b06:	99 23       	and	r25, r25
   11b08:	c9 f3       	breq	.-14     	; 0x11afc <__divsf3+0x14>
   11b0a:	55 23       	and	r21, r21
   11b0c:	b1 f3       	breq	.-20     	; 0x11afa <__divsf3+0x12>
   11b0e:	95 1b       	sub	r25, r21
   11b10:	55 0b       	sbc	r21, r21
   11b12:	bb 27       	eor	r27, r27
   11b14:	aa 27       	eor	r26, r26
   11b16:	62 17       	cp	r22, r18
   11b18:	73 07       	cpc	r23, r19
   11b1a:	84 07       	cpc	r24, r20
   11b1c:	38 f0       	brcs	.+14     	; 0x11b2c <__divsf3_pse+0x26>
   11b1e:	9f 5f       	subi	r25, 0xFF	; 255
   11b20:	5f 4f       	sbci	r21, 0xFF	; 255
   11b22:	22 0f       	add	r18, r18
   11b24:	33 1f       	adc	r19, r19
   11b26:	44 1f       	adc	r20, r20
   11b28:	aa 1f       	adc	r26, r26
   11b2a:	a9 f3       	breq	.-22     	; 0x11b16 <__divsf3_pse+0x10>
   11b2c:	33 d0       	rcall	.+102    	; 0x11b94 <__divsf3_pse+0x8e>
   11b2e:	0e 2e       	mov	r0, r30
   11b30:	3a f0       	brmi	.+14     	; 0x11b40 <__divsf3_pse+0x3a>
   11b32:	e0 e8       	ldi	r30, 0x80	; 128
   11b34:	30 d0       	rcall	.+96     	; 0x11b96 <__divsf3_pse+0x90>
   11b36:	91 50       	subi	r25, 0x01	; 1
   11b38:	50 40       	sbci	r21, 0x00	; 0
   11b3a:	e6 95       	lsr	r30
   11b3c:	00 1c       	adc	r0, r0
   11b3e:	ca f7       	brpl	.-14     	; 0x11b32 <__divsf3_pse+0x2c>
   11b40:	29 d0       	rcall	.+82     	; 0x11b94 <__divsf3_pse+0x8e>
   11b42:	fe 2f       	mov	r31, r30
   11b44:	27 d0       	rcall	.+78     	; 0x11b94 <__divsf3_pse+0x8e>
   11b46:	66 0f       	add	r22, r22
   11b48:	77 1f       	adc	r23, r23
   11b4a:	88 1f       	adc	r24, r24
   11b4c:	bb 1f       	adc	r27, r27
   11b4e:	26 17       	cp	r18, r22
   11b50:	37 07       	cpc	r19, r23
   11b52:	48 07       	cpc	r20, r24
   11b54:	ab 07       	cpc	r26, r27
   11b56:	b0 e8       	ldi	r27, 0x80	; 128
   11b58:	09 f0       	breq	.+2      	; 0x11b5c <__divsf3_pse+0x56>
   11b5a:	bb 0b       	sbc	r27, r27
   11b5c:	80 2d       	mov	r24, r0
   11b5e:	bf 01       	movw	r22, r30
   11b60:	ff 27       	eor	r31, r31
   11b62:	93 58       	subi	r25, 0x83	; 131
   11b64:	5f 4f       	sbci	r21, 0xFF	; 255
   11b66:	2a f0       	brmi	.+10     	; 0x11b72 <__divsf3_pse+0x6c>
   11b68:	9e 3f       	cpi	r25, 0xFE	; 254
   11b6a:	51 05       	cpc	r21, r1
   11b6c:	68 f0       	brcs	.+26     	; 0x11b88 <__divsf3_pse+0x82>
   11b6e:	f4 cb       	rjmp	.-2072   	; 0x11358 <__fp_inf>
   11b70:	3e cc       	rjmp	.-1924   	; 0x113ee <__fp_szero>
   11b72:	5f 3f       	cpi	r21, 0xFF	; 255
   11b74:	ec f3       	brlt	.-6      	; 0x11b70 <__divsf3_pse+0x6a>
   11b76:	98 3e       	cpi	r25, 0xE8	; 232
   11b78:	dc f3       	brlt	.-10     	; 0x11b70 <__divsf3_pse+0x6a>
   11b7a:	86 95       	lsr	r24
   11b7c:	77 95       	ror	r23
   11b7e:	67 95       	ror	r22
   11b80:	b7 95       	ror	r27
   11b82:	f7 95       	ror	r31
   11b84:	9f 5f       	subi	r25, 0xFF	; 255
   11b86:	c9 f7       	brne	.-14     	; 0x11b7a <__divsf3_pse+0x74>
   11b88:	88 0f       	add	r24, r24
   11b8a:	91 1d       	adc	r25, r1
   11b8c:	96 95       	lsr	r25
   11b8e:	87 95       	ror	r24
   11b90:	97 f9       	bld	r25, 7
   11b92:	08 95       	ret
   11b94:	e1 e0       	ldi	r30, 0x01	; 1
   11b96:	66 0f       	add	r22, r22
   11b98:	77 1f       	adc	r23, r23
   11b9a:	88 1f       	adc	r24, r24
   11b9c:	bb 1f       	adc	r27, r27
   11b9e:	62 17       	cp	r22, r18
   11ba0:	73 07       	cpc	r23, r19
   11ba2:	84 07       	cpc	r24, r20
   11ba4:	ba 07       	cpc	r27, r26
   11ba6:	20 f0       	brcs	.+8      	; 0x11bb0 <__divsf3_pse+0xaa>
   11ba8:	62 1b       	sub	r22, r18
   11baa:	73 0b       	sbc	r23, r19
   11bac:	84 0b       	sbc	r24, r20
   11bae:	ba 0b       	sbc	r27, r26
   11bb0:	ee 1f       	adc	r30, r30
   11bb2:	88 f7       	brcc	.-30     	; 0x11b96 <__divsf3_pse+0x90>
   11bb4:	e0 95       	com	r30
   11bb6:	08 95       	ret

00011bb8 <__fixsfsi>:
   11bb8:	04 d0       	rcall	.+8      	; 0x11bc2 <__fixunssfsi>
   11bba:	68 94       	set
   11bbc:	b1 11       	cpse	r27, r1
   11bbe:	17 cc       	rjmp	.-2002   	; 0x113ee <__fp_szero>
   11bc0:	08 95       	ret

00011bc2 <__fixunssfsi>:
   11bc2:	fa db       	rcall	.-2060   	; 0x113b8 <__fp_splitA>
   11bc4:	88 f0       	brcs	.+34     	; 0x11be8 <__fixunssfsi+0x26>
   11bc6:	9f 57       	subi	r25, 0x7F	; 127
   11bc8:	90 f0       	brcs	.+36     	; 0x11bee <__fixunssfsi+0x2c>
   11bca:	b9 2f       	mov	r27, r25
   11bcc:	99 27       	eor	r25, r25
   11bce:	b7 51       	subi	r27, 0x17	; 23
   11bd0:	a0 f0       	brcs	.+40     	; 0x11bfa <__fixunssfsi+0x38>
   11bd2:	d1 f0       	breq	.+52     	; 0x11c08 <__fixunssfsi+0x46>
   11bd4:	66 0f       	add	r22, r22
   11bd6:	77 1f       	adc	r23, r23
   11bd8:	88 1f       	adc	r24, r24
   11bda:	99 1f       	adc	r25, r25
   11bdc:	1a f0       	brmi	.+6      	; 0x11be4 <__fixunssfsi+0x22>
   11bde:	ba 95       	dec	r27
   11be0:	c9 f7       	brne	.-14     	; 0x11bd4 <__fixunssfsi+0x12>
   11be2:	12 c0       	rjmp	.+36     	; 0x11c08 <__fixunssfsi+0x46>
   11be4:	b1 30       	cpi	r27, 0x01	; 1
   11be6:	81 f0       	breq	.+32     	; 0x11c08 <__fixunssfsi+0x46>
   11be8:	01 dc       	rcall	.-2046   	; 0x113ec <__fp_zero>
   11bea:	b1 e0       	ldi	r27, 0x01	; 1
   11bec:	08 95       	ret
   11bee:	fe cb       	rjmp	.-2052   	; 0x113ec <__fp_zero>
   11bf0:	67 2f       	mov	r22, r23
   11bf2:	78 2f       	mov	r23, r24
   11bf4:	88 27       	eor	r24, r24
   11bf6:	b8 5f       	subi	r27, 0xF8	; 248
   11bf8:	39 f0       	breq	.+14     	; 0x11c08 <__fixunssfsi+0x46>
   11bfa:	b9 3f       	cpi	r27, 0xF9	; 249
   11bfc:	cc f3       	brlt	.-14     	; 0x11bf0 <__fixunssfsi+0x2e>
   11bfe:	86 95       	lsr	r24
   11c00:	77 95       	ror	r23
   11c02:	67 95       	ror	r22
   11c04:	b3 95       	inc	r27
   11c06:	d9 f7       	brne	.-10     	; 0x11bfe <__fixunssfsi+0x3c>
   11c08:	3e f4       	brtc	.+14     	; 0x11c18 <__fixunssfsi+0x56>
   11c0a:	90 95       	com	r25
   11c0c:	80 95       	com	r24
   11c0e:	70 95       	com	r23
   11c10:	61 95       	neg	r22
   11c12:	7f 4f       	sbci	r23, 0xFF	; 255
   11c14:	8f 4f       	sbci	r24, 0xFF	; 255
   11c16:	9f 4f       	sbci	r25, 0xFF	; 255
   11c18:	08 95       	ret

00011c1a <__eerd_block_m2560>:
   11c1a:	dc 01       	movw	r26, r24
   11c1c:	cb 01       	movw	r24, r22

00011c1e <__eerd_blraw_m2560>:
   11c1e:	fc 01       	movw	r30, r24
   11c20:	f9 99       	sbic	0x1f, 1	; 31
   11c22:	fe cf       	rjmp	.-4      	; 0x11c20 <__eerd_blraw_m2560+0x2>
   11c24:	06 c0       	rjmp	.+12     	; 0x11c32 <__eerd_blraw_m2560+0x14>
   11c26:	f2 bd       	out	0x22, r31	; 34
   11c28:	e1 bd       	out	0x21, r30	; 33
   11c2a:	f8 9a       	sbi	0x1f, 0	; 31
   11c2c:	31 96       	adiw	r30, 0x01	; 1
   11c2e:	00 b4       	in	r0, 0x20	; 32
   11c30:	0d 92       	st	X+, r0
   11c32:	41 50       	subi	r20, 0x01	; 1
   11c34:	50 40       	sbci	r21, 0x00	; 0
   11c36:	b8 f7       	brcc	.-18     	; 0x11c26 <__eerd_blraw_m2560+0x8>
   11c38:	08 95       	ret

00011c3a <__eerd_byte_m2560>:
   11c3a:	f9 99       	sbic	0x1f, 1	; 31
   11c3c:	fe cf       	rjmp	.-4      	; 0x11c3a <__eerd_byte_m2560>
   11c3e:	92 bd       	out	0x22, r25	; 34
   11c40:	81 bd       	out	0x21, r24	; 33
   11c42:	f8 9a       	sbi	0x1f, 0	; 31
   11c44:	99 27       	eor	r25, r25
   11c46:	80 b5       	in	r24, 0x20	; 32
   11c48:	08 95       	ret

00011c4a <__eerd_dword_m2560>:
   11c4a:	a6 e1       	ldi	r26, 0x16	; 22
   11c4c:	b0 e0       	ldi	r27, 0x00	; 0
   11c4e:	44 e0       	ldi	r20, 0x04	; 4
   11c50:	50 e0       	ldi	r21, 0x00	; 0
   11c52:	0c 94 0f 8e 	jmp	0x11c1e	; 0x11c1e <__eerd_blraw_m2560>

00011c56 <__eerd_word_m2560>:
   11c56:	a8 e1       	ldi	r26, 0x18	; 24
   11c58:	b0 e0       	ldi	r27, 0x00	; 0
   11c5a:	42 e0       	ldi	r20, 0x02	; 2
   11c5c:	50 e0       	ldi	r21, 0x00	; 0
   11c5e:	0c 94 0f 8e 	jmp	0x11c1e	; 0x11c1e <__eerd_blraw_m2560>

00011c62 <__eewr_block_m2560>:
   11c62:	dc 01       	movw	r26, r24
   11c64:	cb 01       	movw	r24, r22
   11c66:	03 c0       	rjmp	.+6      	; 0x11c6e <__eewr_block_m2560+0xc>
   11c68:	2d 91       	ld	r18, X+
   11c6a:	0e 94 3c 8e 	call	0x11c78	; 0x11c78 <__eewr_r18_m2560>
   11c6e:	41 50       	subi	r20, 0x01	; 1
   11c70:	50 40       	sbci	r21, 0x00	; 0
   11c72:	d0 f7       	brcc	.-12     	; 0x11c68 <__eewr_block_m2560+0x6>
   11c74:	08 95       	ret

00011c76 <__eewr_byte_m2560>:
   11c76:	26 2f       	mov	r18, r22

00011c78 <__eewr_r18_m2560>:
   11c78:	f9 99       	sbic	0x1f, 1	; 31
   11c7a:	fe cf       	rjmp	.-4      	; 0x11c78 <__eewr_r18_m2560>
   11c7c:	1f ba       	out	0x1f, r1	; 31
   11c7e:	92 bd       	out	0x22, r25	; 34
   11c80:	81 bd       	out	0x21, r24	; 33
   11c82:	20 bd       	out	0x20, r18	; 32
   11c84:	0f b6       	in	r0, 0x3f	; 63
   11c86:	f8 94       	cli
   11c88:	fa 9a       	sbi	0x1f, 2	; 31
   11c8a:	f9 9a       	sbi	0x1f, 1	; 31
   11c8c:	0f be       	out	0x3f, r0	; 63
   11c8e:	01 96       	adiw	r24, 0x01	; 1
   11c90:	08 95       	ret

00011c92 <__eewr_dword_m2560>:
   11c92:	24 2f       	mov	r18, r20
   11c94:	0e 94 3c 8e 	call	0x11c78	; 0x11c78 <__eewr_r18_m2560>
   11c98:	25 2f       	mov	r18, r21
   11c9a:	0e 94 3c 8e 	call	0x11c78	; 0x11c78 <__eewr_r18_m2560>
   11c9e:	0c 94 51 8e 	jmp	0x11ca2	; 0x11ca2 <__eewr_word_m2560>

00011ca2 <__eewr_word_m2560>:
   11ca2:	0e 94 3b 8e 	call	0x11c76	; 0x11c76 <__eewr_byte_m2560>
   11ca6:	27 2f       	mov	r18, r23
   11ca8:	0c 94 3c 8e 	jmp	0x11c78	; 0x11c78 <__eewr_r18_m2560>

00011cac <__ctype_isfalse>:
   11cac:	99 27       	eor	r25, r25
   11cae:	88 27       	eor	r24, r24

00011cb0 <__ctype_istrue>:
   11cb0:	08 95       	ret

00011cb2 <__mulsi3>:
   11cb2:	62 9f       	mul	r22, r18
   11cb4:	d0 01       	movw	r26, r0
   11cb6:	73 9f       	mul	r23, r19
   11cb8:	f0 01       	movw	r30, r0
   11cba:	82 9f       	mul	r24, r18
   11cbc:	e0 0d       	add	r30, r0
   11cbe:	f1 1d       	adc	r31, r1
   11cc0:	64 9f       	mul	r22, r20
   11cc2:	e0 0d       	add	r30, r0
   11cc4:	f1 1d       	adc	r31, r1
   11cc6:	92 9f       	mul	r25, r18
   11cc8:	f0 0d       	add	r31, r0
   11cca:	83 9f       	mul	r24, r19
   11ccc:	f0 0d       	add	r31, r0
   11cce:	74 9f       	mul	r23, r20
   11cd0:	f0 0d       	add	r31, r0
   11cd2:	65 9f       	mul	r22, r21
   11cd4:	f0 0d       	add	r31, r0
   11cd6:	99 27       	eor	r25, r25
   11cd8:	72 9f       	mul	r23, r18
   11cda:	b0 0d       	add	r27, r0
   11cdc:	e1 1d       	adc	r30, r1
   11cde:	f9 1f       	adc	r31, r25
   11ce0:	63 9f       	mul	r22, r19
   11ce2:	b0 0d       	add	r27, r0
   11ce4:	e1 1d       	adc	r30, r1
   11ce6:	f9 1f       	adc	r31, r25
   11ce8:	bd 01       	movw	r22, r26
   11cea:	cf 01       	movw	r24, r30
   11cec:	11 24       	eor	r1, r1
   11cee:	08 95       	ret

00011cf0 <__udivmodqi4>:
   11cf0:	99 1b       	sub	r25, r25
   11cf2:	79 e0       	ldi	r23, 0x09	; 9
   11cf4:	04 c0       	rjmp	.+8      	; 0x11cfe <__udivmodqi4_ep>

00011cf6 <__udivmodqi4_loop>:
   11cf6:	99 1f       	adc	r25, r25
   11cf8:	96 17       	cp	r25, r22
   11cfa:	08 f0       	brcs	.+2      	; 0x11cfe <__udivmodqi4_ep>
   11cfc:	96 1b       	sub	r25, r22

00011cfe <__udivmodqi4_ep>:
   11cfe:	88 1f       	adc	r24, r24
   11d00:	7a 95       	dec	r23
   11d02:	c9 f7       	brne	.-14     	; 0x11cf6 <__udivmodqi4_loop>
   11d04:	80 95       	com	r24
   11d06:	08 95       	ret

00011d08 <__udivmodhi4>:
   11d08:	aa 1b       	sub	r26, r26
   11d0a:	bb 1b       	sub	r27, r27
   11d0c:	51 e1       	ldi	r21, 0x11	; 17
   11d0e:	07 c0       	rjmp	.+14     	; 0x11d1e <__udivmodhi4_ep>

00011d10 <__udivmodhi4_loop>:
   11d10:	aa 1f       	adc	r26, r26
   11d12:	bb 1f       	adc	r27, r27
   11d14:	a6 17       	cp	r26, r22
   11d16:	b7 07       	cpc	r27, r23
   11d18:	10 f0       	brcs	.+4      	; 0x11d1e <__udivmodhi4_ep>
   11d1a:	a6 1b       	sub	r26, r22
   11d1c:	b7 0b       	sbc	r27, r23

00011d1e <__udivmodhi4_ep>:
   11d1e:	88 1f       	adc	r24, r24
   11d20:	99 1f       	adc	r25, r25
   11d22:	5a 95       	dec	r21
   11d24:	a9 f7       	brne	.-22     	; 0x11d10 <__udivmodhi4_loop>
   11d26:	80 95       	com	r24
   11d28:	90 95       	com	r25
   11d2a:	bc 01       	movw	r22, r24
   11d2c:	cd 01       	movw	r24, r26
   11d2e:	08 95       	ret

00011d30 <__divmodhi4>:
   11d30:	97 fb       	bst	r25, 7
   11d32:	09 2e       	mov	r0, r25
   11d34:	07 26       	eor	r0, r23
   11d36:	0a d0       	rcall	.+20     	; 0x11d4c <__divmodhi4_neg1>
   11d38:	77 fd       	sbrc	r23, 7
   11d3a:	04 d0       	rcall	.+8      	; 0x11d44 <__divmodhi4_neg2>
   11d3c:	e5 df       	rcall	.-54     	; 0x11d08 <__udivmodhi4>
   11d3e:	06 d0       	rcall	.+12     	; 0x11d4c <__divmodhi4_neg1>
   11d40:	00 20       	and	r0, r0
   11d42:	1a f4       	brpl	.+6      	; 0x11d4a <__divmodhi4_exit>

00011d44 <__divmodhi4_neg2>:
   11d44:	70 95       	com	r23
   11d46:	61 95       	neg	r22
   11d48:	7f 4f       	sbci	r23, 0xFF	; 255

00011d4a <__divmodhi4_exit>:
   11d4a:	08 95       	ret

00011d4c <__divmodhi4_neg1>:
   11d4c:	f6 f7       	brtc	.-4      	; 0x11d4a <__divmodhi4_exit>
   11d4e:	90 95       	com	r25
   11d50:	81 95       	neg	r24
   11d52:	9f 4f       	sbci	r25, 0xFF	; 255
   11d54:	08 95       	ret

00011d56 <__udivmodsi4>:
   11d56:	a1 e2       	ldi	r26, 0x21	; 33
   11d58:	1a 2e       	mov	r1, r26
   11d5a:	aa 1b       	sub	r26, r26
   11d5c:	bb 1b       	sub	r27, r27
   11d5e:	fd 01       	movw	r30, r26
   11d60:	0d c0       	rjmp	.+26     	; 0x11d7c <__udivmodsi4_ep>

00011d62 <__udivmodsi4_loop>:
   11d62:	aa 1f       	adc	r26, r26
   11d64:	bb 1f       	adc	r27, r27
   11d66:	ee 1f       	adc	r30, r30
   11d68:	ff 1f       	adc	r31, r31
   11d6a:	a2 17       	cp	r26, r18
   11d6c:	b3 07       	cpc	r27, r19
   11d6e:	e4 07       	cpc	r30, r20
   11d70:	f5 07       	cpc	r31, r21
   11d72:	20 f0       	brcs	.+8      	; 0x11d7c <__udivmodsi4_ep>
   11d74:	a2 1b       	sub	r26, r18
   11d76:	b3 0b       	sbc	r27, r19
   11d78:	e4 0b       	sbc	r30, r20
   11d7a:	f5 0b       	sbc	r31, r21

00011d7c <__udivmodsi4_ep>:
   11d7c:	66 1f       	adc	r22, r22
   11d7e:	77 1f       	adc	r23, r23
   11d80:	88 1f       	adc	r24, r24
   11d82:	99 1f       	adc	r25, r25
   11d84:	1a 94       	dec	r1
   11d86:	69 f7       	brne	.-38     	; 0x11d62 <__udivmodsi4_loop>
   11d88:	60 95       	com	r22
   11d8a:	70 95       	com	r23
   11d8c:	80 95       	com	r24
   11d8e:	90 95       	com	r25
   11d90:	9b 01       	movw	r18, r22
   11d92:	ac 01       	movw	r20, r24
   11d94:	bd 01       	movw	r22, r26
   11d96:	cf 01       	movw	r24, r30
   11d98:	08 95       	ret

00011d9a <__divmodsi4>:
   11d9a:	97 fb       	bst	r25, 7
   11d9c:	09 2e       	mov	r0, r25
   11d9e:	05 26       	eor	r0, r21
   11da0:	0e d0       	rcall	.+28     	; 0x11dbe <__divmodsi4_neg1>
   11da2:	57 fd       	sbrc	r21, 7
   11da4:	04 d0       	rcall	.+8      	; 0x11dae <__divmodsi4_neg2>
   11da6:	d7 df       	rcall	.-82     	; 0x11d56 <__udivmodsi4>
   11da8:	0a d0       	rcall	.+20     	; 0x11dbe <__divmodsi4_neg1>
   11daa:	00 1c       	adc	r0, r0
   11dac:	38 f4       	brcc	.+14     	; 0x11dbc <__divmodsi4_exit>

00011dae <__divmodsi4_neg2>:
   11dae:	50 95       	com	r21
   11db0:	40 95       	com	r20
   11db2:	30 95       	com	r19
   11db4:	21 95       	neg	r18
   11db6:	3f 4f       	sbci	r19, 0xFF	; 255
   11db8:	4f 4f       	sbci	r20, 0xFF	; 255
   11dba:	5f 4f       	sbci	r21, 0xFF	; 255

00011dbc <__divmodsi4_exit>:
   11dbc:	08 95       	ret

00011dbe <__divmodsi4_neg1>:
   11dbe:	f6 f7       	brtc	.-4      	; 0x11dbc <__divmodsi4_exit>
   11dc0:	90 95       	com	r25
   11dc2:	80 95       	com	r24
   11dc4:	70 95       	com	r23
   11dc6:	61 95       	neg	r22
   11dc8:	7f 4f       	sbci	r23, 0xFF	; 255
   11dca:	8f 4f       	sbci	r24, 0xFF	; 255
   11dcc:	9f 4f       	sbci	r25, 0xFF	; 255
   11dce:	08 95       	ret

00011dd0 <_exit>:
   11dd0:	f8 94       	cli

00011dd2 <__stop_program>:
   11dd2:	ff cf       	rjmp	.-2      	; 0x11dd2 <__stop_program>
