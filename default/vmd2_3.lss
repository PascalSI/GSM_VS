
vmd2_3.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000da  00800200  0001103a  000110ee  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0001103a  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000099a  008002da  008002da  000111c8  2**0
                  ALLOC
  3 .eeprom       000001a0  00810000  00810000  000111c8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .debug_aranges 00000020  00000000  00000000  00011368  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 00003590  00000000  00000000  00011388  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000ffdd  00000000  00000000  00014918  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000073b  00000000  00000000  000248f5  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00008ee5  00000000  00000000  00025030  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000012f0  00000000  00000000  0002df18  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00003da6  00000000  00000000  0002f208  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000084d0  00000000  00000000  00032fae  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00001128  00000000  00000000  0003b47e  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 6a 1c 	jmp	0x38d4	; 0x38d4 <__ctors_end>
       4:	0c 94 8b 1c 	jmp	0x3916	; 0x3916 <__bad_interrupt>
       8:	0c 94 8b 1c 	jmp	0x3916	; 0x3916 <__bad_interrupt>
       c:	0c 94 8b 1c 	jmp	0x3916	; 0x3916 <__bad_interrupt>
      10:	0c 94 8b 1c 	jmp	0x3916	; 0x3916 <__bad_interrupt>
      14:	0c 94 8b 1c 	jmp	0x3916	; 0x3916 <__bad_interrupt>
      18:	0c 94 8b 1c 	jmp	0x3916	; 0x3916 <__bad_interrupt>
      1c:	0c 94 8b 1c 	jmp	0x3916	; 0x3916 <__bad_interrupt>
      20:	0c 94 8b 1c 	jmp	0x3916	; 0x3916 <__bad_interrupt>
      24:	0c 94 8b 1c 	jmp	0x3916	; 0x3916 <__bad_interrupt>
      28:	0c 94 8b 1c 	jmp	0x3916	; 0x3916 <__bad_interrupt>
      2c:	0c 94 8b 1c 	jmp	0x3916	; 0x3916 <__bad_interrupt>
      30:	0c 94 8b 1c 	jmp	0x3916	; 0x3916 <__bad_interrupt>
      34:	0c 94 36 2c 	jmp	0x586c	; 0x586c <__vector_13>
      38:	0c 94 8b 1c 	jmp	0x3916	; 0x3916 <__bad_interrupt>
      3c:	0c 94 8b 1c 	jmp	0x3916	; 0x3916 <__bad_interrupt>
      40:	0c 94 8b 1c 	jmp	0x3916	; 0x3916 <__bad_interrupt>
      44:	0c 94 da 20 	jmp	0x41b4	; 0x41b4 <__vector_17>
      48:	0c 94 03 2a 	jmp	0x5406	; 0x5406 <__vector_18>
      4c:	0c 94 8b 1c 	jmp	0x3916	; 0x3916 <__bad_interrupt>
      50:	0c 94 8b 1c 	jmp	0x3916	; 0x3916 <__bad_interrupt>
      54:	0c 94 04 2c 	jmp	0x5808	; 0x5808 <__vector_21>
      58:	0c 94 8b 1c 	jmp	0x3916	; 0x3916 <__bad_interrupt>
      5c:	0c 94 8b 1c 	jmp	0x3916	; 0x3916 <__bad_interrupt>
      60:	0c 94 8b 1c 	jmp	0x3916	; 0x3916 <__bad_interrupt>
      64:	0c 94 73 3d 	jmp	0x7ae6	; 0x7ae6 <__vector_25>
      68:	0c 94 c7 3d 	jmp	0x7b8e	; 0x7b8e <__vector_26>
      6c:	0c 94 9d 3d 	jmp	0x7b3a	; 0x7b3a <__vector_27>
      70:	0c 94 8b 1c 	jmp	0x3916	; 0x3916 <__bad_interrupt>
      74:	0c 94 8b 1c 	jmp	0x3916	; 0x3916 <__bad_interrupt>
      78:	0c 94 8b 1c 	jmp	0x3916	; 0x3916 <__bad_interrupt>
      7c:	0c 94 8b 1c 	jmp	0x3916	; 0x3916 <__bad_interrupt>
      80:	0c 94 8b 1c 	jmp	0x3916	; 0x3916 <__bad_interrupt>
      84:	0c 94 8b 1c 	jmp	0x3916	; 0x3916 <__bad_interrupt>
      88:	0c 94 8b 1c 	jmp	0x3916	; 0x3916 <__bad_interrupt>
      8c:	0c 94 8b 1c 	jmp	0x3916	; 0x3916 <__bad_interrupt>
      90:	0c 94 f1 3d 	jmp	0x7be2	; 0x7be2 <__vector_36>
      94:	0c 94 45 3e 	jmp	0x7c8a	; 0x7c8a <__vector_37>
      98:	0c 94 1b 3e 	jmp	0x7c36	; 0x7c36 <__vector_38>
      9c:	0c 94 8b 1c 	jmp	0x3916	; 0x3916 <__bad_interrupt>
      a0:	0c 94 8b 1c 	jmp	0x3916	; 0x3916 <__bad_interrupt>
      a4:	0c 94 8b 1c 	jmp	0x3916	; 0x3916 <__bad_interrupt>
      a8:	0c 94 6a 2c 	jmp	0x58d4	; 0x58d4 <__vector_42>
      ac:	0c 94 8b 1c 	jmp	0x3916	; 0x3916 <__bad_interrupt>
      b0:	0c 94 8b 1c 	jmp	0x3916	; 0x3916 <__bad_interrupt>
      b4:	0c 94 8b 1c 	jmp	0x3916	; 0x3916 <__bad_interrupt>
      b8:	0c 94 8b 1c 	jmp	0x3916	; 0x3916 <__bad_interrupt>
      bc:	0c 94 8b 1c 	jmp	0x3916	; 0x3916 <__bad_interrupt>
      c0:	0c 94 8b 1c 	jmp	0x3916	; 0x3916 <__bad_interrupt>
      c4:	0c 94 8b 1c 	jmp	0x3916	; 0x3916 <__bad_interrupt>
      c8:	0c 94 8b 1c 	jmp	0x3916	; 0x3916 <__bad_interrupt>
      cc:	0c 94 bf 3e 	jmp	0x7d7e	; 0x7d7e <__vector_51>
      d0:	0c 94 6f 3e 	jmp	0x7cde	; 0x7cde <__vector_52>
      d4:	0c 94 97 3e 	jmp	0x7d2e	; 0x7d2e <__vector_53>
      d8:	0c 94 8b 1c 	jmp	0x3916	; 0x3916 <__bad_interrupt>
      dc:	0c 94 8b 1c 	jmp	0x3916	; 0x3916 <__bad_interrupt>
      e0:	0c 94 8b 1c 	jmp	0x3916	; 0x3916 <__bad_interrupt>
      e4:	64 55       	subi	r22, 0x54	; 84
      e6:	8a 55       	subi	r24, 0x5A	; 90
      e8:	9b 55       	subi	r25, 0x5B	; 91
      ea:	ae 55       	subi	r26, 0x5E	; 94
      ec:	64 55       	subi	r22, 0x54	; 84
      ee:	8a 55       	subi	r24, 0x5A	; 90
      f0:	ee 54       	subi	r30, 0x4E	; 78
      f2:	c2 55       	subi	r28, 0x52	; 82
      f4:	d2 55       	subi	r29, 0x52	; 82
      f6:	e2 55       	subi	r30, 0x52	; 82
      f8:	f5 55       	subi	r31, 0x55	; 85
      fa:	c2 55       	subi	r28, 0x52	; 82
      fc:	d2 55       	subi	r29, 0x52	; 82
      fe:	08 56       	subi	r16, 0x68	; 104
     100:	08 56       	subi	r16, 0x68	; 104
     102:	ee 54       	subi	r30, 0x4E	; 78
     104:	ee 54       	subi	r30, 0x4E	; 78
     106:	ee 54       	subi	r30, 0x4E	; 78
     108:	ee 54       	subi	r30, 0x4E	; 78
     10a:	ee 54       	subi	r30, 0x4E	; 78
     10c:	ee 54       	subi	r30, 0x4E	; 78
     10e:	ee 54       	subi	r30, 0x4E	; 78
     110:	ee 54       	subi	r30, 0x4E	; 78
     112:	ee 54       	subi	r30, 0x4E	; 78
     114:	ee 54       	subi	r30, 0x4E	; 78
     116:	ee 54       	subi	r30, 0x4E	; 78
     118:	ee 54       	subi	r30, 0x4E	; 78
     11a:	ee 54       	subi	r30, 0x4E	; 78
     11c:	ee 54       	subi	r30, 0x4E	; 78
     11e:	16 56       	subi	r17, 0x66	; 102
     120:	24 56       	subi	r18, 0x64	; 100
     122:	33 56       	subi	r19, 0x63	; 99
     124:	44 56       	subi	r20, 0x64	; 100
     126:	34 59       	subi	r19, 0x94	; 148
     128:	53 59       	subi	r21, 0x93	; 147
     12a:	74 59       	subi	r23, 0x94	; 148
     12c:	97 59       	subi	r25, 0x97	; 151
     12e:	34 59       	subi	r19, 0x94	; 148
     130:	53 59       	subi	r21, 0x93	; 147
     132:	f6 58       	subi	r31, 0x86	; 134
     134:	bc 59       	subi	r27, 0x9C	; 156
     136:	da 59       	subi	r29, 0x9A	; 154
     138:	f9 59       	subi	r31, 0x99	; 153
     13a:	1b 5a       	subi	r17, 0xAB	; 171
     13c:	bc 59       	subi	r27, 0x9C	; 156
     13e:	da 59       	subi	r29, 0x9A	; 154
     140:	3e 5a       	subi	r19, 0xAE	; 174
     142:	3e 5a       	subi	r19, 0xAE	; 174
     144:	f6 58       	subi	r31, 0x86	; 134
     146:	46 5a       	subi	r20, 0xA6	; 166
     148:	bf 58       	subi	r27, 0x8F	; 143
     14a:	7d 5a       	subi	r23, 0xAD	; 173
     14c:	b4 5a       	subi	r27, 0xA4	; 164
     14e:	46 5a       	subi	r20, 0xA6	; 166
     150:	bf 58       	subi	r27, 0x8F	; 143
     152:	f6 58       	subi	r31, 0x86	; 134
     154:	f6 58       	subi	r31, 0x86	; 134
     156:	f6 58       	subi	r31, 0x86	; 134
     158:	f1 5a       	subi	r31, 0xA1	; 161
     15a:	1b 5b       	subi	r17, 0xBB	; 187
     15c:	f1 5a       	subi	r31, 0xA1	; 161
     15e:	1b 5b       	subi	r17, 0xBB	; 187
     160:	34 59       	subi	r19, 0x94	; 148
     162:	53 59       	subi	r21, 0x93	; 147
     164:	45 5b       	subi	r20, 0xB5	; 181
     166:	56 5b       	subi	r21, 0xB6	; 182
     168:	6d 5b       	subi	r22, 0xBD	; 189
     16a:	12 59       	subi	r17, 0x92	; 146
     16c:	4d 5e       	subi	r20, 0xED	; 237
     16e:	4d 5e       	subi	r20, 0xED	; 237
     170:	04 5e       	subi	r16, 0xE4	; 228
     172:	04 5e       	subi	r16, 0xE4	; 228
     174:	4d 5e       	subi	r20, 0xED	; 237
     176:	4d 5e       	subi	r20, 0xED	; 237
     178:	10 5d       	subi	r17, 0xD0	; 208
     17a:	4d 5e       	subi	r20, 0xED	; 237
     17c:	4d 5e       	subi	r20, 0xED	; 237
     17e:	04 5e       	subi	r16, 0xE4	; 228
     180:	04 5e       	subi	r16, 0xE4	; 228
     182:	4d 5e       	subi	r20, 0xED	; 237
     184:	4d 5e       	subi	r20, 0xED	; 237
     186:	e0 5d       	subi	r30, 0xD0	; 208
     188:	e0 5d       	subi	r30, 0xD0	; 208
     18a:	10 5d       	subi	r17, 0xD0	; 208
     18c:	c8 5d       	subi	r28, 0xD8	; 216
     18e:	c8 5d       	subi	r28, 0xD8	; 216
     190:	c8 5d       	subi	r28, 0xD8	; 216
     192:	c8 5d       	subi	r28, 0xD8	; 216
     194:	c8 5d       	subi	r28, 0xD8	; 216
     196:	c8 5d       	subi	r28, 0xD8	; 216
     198:	10 5d       	subi	r17, 0xD0	; 208
     19a:	10 5d       	subi	r17, 0xD0	; 208
     19c:	10 5d       	subi	r17, 0xD0	; 208
     19e:	c8 5d       	subi	r28, 0xD8	; 216
     1a0:	c8 5d       	subi	r28, 0xD8	; 216
     1a2:	c8 5d       	subi	r28, 0xD8	; 216
     1a4:	c8 5d       	subi	r28, 0xD8	; 216
     1a6:	aa 5d       	subi	r26, 0xDA	; 218
     1a8:	aa 5d       	subi	r26, 0xDA	; 218
     1aa:	8d 5d       	subi	r24, 0xDD	; 221
     1ac:	8d 5d       	subi	r24, 0xDD	; 221
     1ae:	55 5d       	subi	r21, 0xD5	; 213
     1b0:	55 5d       	subi	r21, 0xD5	; 213
     1b2:	35 61       	ori	r19, 0x15	; 21
     1b4:	2c 61       	ori	r18, 0x1C	; 28
     1b6:	24 61       	ori	r18, 0x14	; 20
     1b8:	19 61       	ori	r17, 0x19	; 25
     1ba:	13 61       	ori	r17, 0x13	; 19
     1bc:	0a 61       	ori	r16, 0x1A	; 26
     1be:	01 61       	ori	r16, 0x11	; 17
     1c0:	fb 60       	ori	r31, 0x0B	; 11
     1c2:	f3 60       	ori	r31, 0x03	; 3
     1c4:	ed 60       	ori	r30, 0x0D	; 13
     1c6:	e5 60       	ori	r30, 0x05	; 5
     1c8:	df 60       	ori	r29, 0x0F	; 15
     1ca:	d7 60       	ori	r29, 0x07	; 7
     1cc:	fb 60       	ori	r31, 0x0B	; 11
     1ce:	df 60       	ori	r29, 0x0F	; 15
     1d0:	ce 60       	ori	r28, 0x0E	; 14
     1d2:	c7 60       	ori	r28, 0x07	; 7
     1d4:	c0 60       	ori	r28, 0x00	; 0
     1d6:	b9 60       	ori	r27, 0x09	; 9
     1d8:	b2 60       	ori	r27, 0x02	; 2
     1da:	ab 60       	ori	r26, 0x0B	; 11
     1dc:	a4 60       	ori	r26, 0x04	; 4
     1de:	c7 60       	ori	r28, 0x07	; 7
     1e0:	ab 60       	ori	r26, 0x0B	; 11
     1e2:	9b 60       	ori	r25, 0x0B	; 11
     1e4:	94 60       	ori	r25, 0x04	; 4
     1e6:	86 60       	ori	r24, 0x06	; 6
     1e8:	7f 60       	ori	r23, 0x0F	; 15
     1ea:	71 60       	ori	r23, 0x01	; 1
     1ec:	51 60       	ori	r21, 0x01	; 1
     1ee:	60 60       	ori	r22, 0x00	; 0
     1f0:	2a 60       	ori	r18, 0x0A	; 10
     1f2:	dd 5f       	subi	r29, 0xFD	; 253
     1f4:	25 60       	ori	r18, 0x05	; 5
     1f6:	17 60       	ori	r17, 0x07	; 7
     1f8:	3c 6c       	ori	r19, 0xCC	; 204
     1fa:	2e 6c       	ori	r18, 0xCE	; 206
     1fc:	22 6c       	ori	r18, 0xC2	; 194
     1fe:	9b 66       	ori	r25, 0x6B	; 107
     200:	ce 66       	ori	r28, 0x6E	; 110
     202:	83 6c       	ori	r24, 0xC3	; 195
     204:	72 6c       	ori	r23, 0xC2	; 194
     206:	14 6c       	ori	r17, 0xC4	; 196
     208:	08 6c       	ori	r16, 0xC8	; 200
     20a:	fa 6b       	ori	r31, 0xBA	; 186
     20c:	ee 6b       	ori	r30, 0xBE	; 190
     20e:	e0 6b       	ori	r30, 0xB0	; 176
     210:	d4 6b       	ori	r29, 0xB4	; 180
     212:	c6 6b       	ori	r28, 0xB6	; 182
     214:	be 6b       	ori	r27, 0xBE	; 190
     216:	57 6b       	ori	r21, 0xB7	; 183
     218:	46 6b       	ori	r20, 0xB6	; 182
     21a:	a7 6a       	ori	r26, 0xA7	; 167
     21c:	8e 6a       	ori	r24, 0xAE	; 174
     21e:	31 6b       	ori	r19, 0xB1	; 177
     220:	bf 6a       	ori	r27, 0xAF	; 175
     222:	7c 6a       	ori	r23, 0xAC	; 172
     224:	6a 6a       	ori	r22, 0xAA	; 170
     226:	49 6a       	ori	r20, 0xA9	; 169
     228:	37 6a       	ori	r19, 0xA7	; 167
     22a:	1f 6a       	ori	r17, 0xAF	; 175
     22c:	08 6a       	ori	r16, 0xA8	; 168
     22e:	e3 69       	ori	r30, 0x93	; 147
     230:	d1 69       	ori	r29, 0x91	; 145
     232:	ad 69       	ori	r26, 0x9D	; 157
     234:	9b 69       	ori	r25, 0x9B	; 155
     236:	88 6d       	ori	r24, 0xD8	; 216
     238:	63 6d       	ori	r22, 0xD3	; 211
     23a:	51 6d       	ori	r21, 0xD1	; 209
     23c:	3f 6d       	ori	r19, 0xDF	; 223
     23e:	1e 6d       	ori	r17, 0xDE	; 222
     240:	06 6d       	ori	r16, 0xD6	; 214
     242:	f4 6c       	ori	r31, 0xC4	; 196
     244:	e8 6c       	ori	r30, 0xC8	; 200
     246:	c3 6d       	ori	r28, 0xD3	; 211
     248:	b7 6d       	ori	r27, 0xD7	; 215
     24a:	ab 6d       	ori	r26, 0xDB	; 219
     24c:	9a 6d       	ori	r25, 0xDA	; 218
     24e:	c7 6c       	ori	r28, 0xC7	; 199
     250:	b6 6c       	ori	r27, 0xC6	; 198
     252:	a2 6c       	ori	r26, 0xC2	; 194
     254:	91 6c       	ori	r25, 0xC1	; 193
     256:	3e 6f       	ori	r19, 0xFE	; 254
     258:	fd 6e       	ori	r31, 0xED	; 237
     25a:	f2 6e       	ori	r31, 0xE2	; 226
     25c:	df 6e       	ori	r29, 0xEF	; 239
     25e:	24 6f       	ori	r18, 0xF4	; 244
     260:	14 6f       	ori	r17, 0xF4	; 244
     262:	31 6f       	ori	r19, 0xF1	; 241
     264:	da 6c       	ori	r29, 0xCA	; 202
     266:	2b 6e       	ori	r18, 0xEB	; 235
     268:	1c 6e       	ori	r17, 0xEC	; 236
     26a:	10 6e       	ori	r17, 0xE0	; 224
     26c:	d1 6d       	ori	r29, 0xD1	; 209
     26e:	48 6e       	ori	r20, 0xE8	; 232
     270:	38 6e       	ori	r19, 0xE8	; 232
     272:	cb 6e       	ori	r28, 0xEB	; 235
     274:	90 69       	ori	r25, 0x90	; 144
     276:	50 69       	ori	r21, 0x90	; 144
     278:	0d 69       	ori	r16, 0x9D	; 157
     27a:	00 69       	ori	r16, 0x90	; 144
     27c:	ed 68       	ori	r30, 0x8D	; 141
     27e:	79 69       	ori	r23, 0x99	; 153
     280:	5f 69       	ori	r21, 0x9F	; 159
     282:	6b 69       	ori	r22, 0x9B	; 155
     284:	ea 67       	ori	r30, 0x7A	; 122
     286:	95 68       	ori	r25, 0x85	; 133
     288:	2f 66       	ori	r18, 0x6F	; 111
     28a:	2f 66       	ori	r18, 0x6F	; 111
     28c:	57 68       	ori	r21, 0x87	; 135
     28e:	4d 68       	ori	r20, 0x8D	; 141
     290:	f6 67       	ori	r31, 0x76	; 118
     292:	c8 68       	ori	r28, 0x88	; 136
     294:	a7 68       	ori	r26, 0x87	; 135
     296:	d6 68       	ori	r29, 0x86	; 134
     298:	de 67       	ori	r29, 0x7E	; 126
     29a:	cc 67       	ori	r28, 0x7C	; 124
     29c:	9a 67       	ori	r25, 0x7A	; 122
     29e:	88 67       	ori	r24, 0x78	; 120
     2a0:	7c 67       	ori	r23, 0x7C	; 124
     2a2:	3f 67       	ori	r19, 0x7F	; 127
     2a4:	25 67       	ori	r18, 0x75	; 117
     2a6:	07 67       	ori	r16, 0x77	; 119
     2a8:	f9 66       	ori	r31, 0x69	; 105
     2aa:	dc 66       	ori	r29, 0x6C	; 108
     2ac:	42 78       	andi	r20, 0x82	; 130
     2ae:	49 78       	andi	r20, 0x89	; 137
     2b0:	35 78       	andi	r19, 0x85	; 133
     2b2:	3c 78       	andi	r19, 0x8C	; 140
     2b4:	2b 78       	andi	r18, 0x8B	; 139
     2b6:	31 78       	andi	r19, 0x81	; 129
     2b8:	1e 78       	andi	r17, 0x8E	; 142
     2ba:	24 78       	andi	r18, 0x84	; 132
     2bc:	50 78       	andi	r21, 0x80	; 128
     2be:	1a 78       	andi	r17, 0x8A	; 138
     2c0:	02 78       	andi	r16, 0x82	; 130
     2c2:	d4 78       	andi	r29, 0x84	; 132
     2c4:	bc 78       	andi	r27, 0x8C	; 140
     2c6:	b0 78       	andi	r27, 0x80	; 128
     2c8:	98 78       	andi	r25, 0x88	; 136
     2ca:	7c 78       	andi	r23, 0x8C	; 140
     2cc:	58 78       	andi	r21, 0x88	; 136

000002ce <__c.1790>:
     2ce:	6e 61 6e 00                                         nan.

000002d2 <__c.1788>:
     2d2:	69 6e 66 00                                         inf.

000002d6 <__c.2085>:
     2d6:	63 64 69 6e 6f 70 73 75 78 58 5b 65 66 67 45 46     cdinopsuxX[efgEF
     2e6:	47 00                                               G.

000002e8 <pstr_an>:
     2e8:	61 6e 00                                            an.

000002eb <pstr_nfinity>:
     2eb:	6e 66 69 6e 69 74 79 00                             nfinity.

000002f3 <pwr_m10>:
     2f3:	cd cc cc 3d 0a d7 23 3c 17 b7 d1 38 77 cc 2b 32     ...=..#<...8w.+2
     303:	95 95 e6 24 1f b1 4f 0a                             ...$..O.

0000030b <pwr_p10>:
     30b:	00 00 20 41 00 00 c8 42 00 40 1c 46 20 bc be 4c     .. A...B.@.F ..L
     31b:	ca 1b 0e 5a ae c5 9d 74                             ...Z...t

00000323 <DaysMonth>:
     323:	00 1f 1c 1f 1e 1f 1e 1f 1f 1e 1f 1e 1f              .............

00000330 <Modbus_Map>:
     330:	bc 07 20 00 46 0a 20 00 61 0b 04 00 45 08 50 00     .. .F. .a...E.P.

00000340 <BR_Tbl>:
     340:	42 03 ff a0 01 fb cf 00 7d 67 00 3f 44 00 2a 33     B.......}g.?D.*3
     350:	00 1f 22 00 1b 19 00 1b 10 00 1b                    .."........

0000035b <GSM_SIMCOM_SIM900R>:
     35b:	53 49 4d 43 4f 4d 5f 53 49 4d 39 30 30 52 00        SIMCOM_SIM900R.

0000036a <GSM_SIMCOM_SIM800>:
     36a:	53 49 4d 43 4f 4d 5f 53 49 4d 38 30 30 00           SIMCOM_SIM800.

00000378 <GSM_SIMCOM_SIM800C>:
     378:	53 49 4d 43 4f 4d 5f 53 49 4d 38 30 30 43 00        SIMCOM_SIM800C.

00000387 <URC_RDY>:
     387:	52 44 59 00                                         RDY.

0000038b <URC_CFUN>:
     38b:	2b 43 46 55 4e 3a 20 31 00                          +CFUN: 1.

00000394 <URC_CPIN_READY>:
     394:	2b 43 50 49 4e 3a 20 52 45 41 44 59 00              +CPIN: READY.

000003a1 <URC_CALL_READY>:
     3a1:	43 61 6c 6c 20 52 65 61 64 79 00                    Call Ready.

000003ac <URC_SMS_READY>:
     3ac:	53 4d 53 20 52 65 61 64 79 00                       SMS Ready.

000003b6 <URC_REMOTE_IP>:
     3b6:	52 45 4d 4f 54 45 20 49 50 00                       REMOTE IP.

000003c0 <URC_CONNECT>:
     3c0:	43 4f 4e 4e 45 43 54 00                             CONNECT.

000003c8 <URC_RECEIVE>:
     3c8:	2b 52 45 43 45 49 56 45 2c 00                       +RECEIVE,.

000003d2 <URC_CLOSED>:
     3d2:	2c 20 43 4c 4f 53 45 44 00                          , CLOSED.

000003db <URC_PDPDEACT>:
     3db:	2b 50 44 50 20 44 45 41 43 54 00                    +PDP DEACT.

000003e6 <URC_NO_CARRIER>:
     3e6:	4e 4f 20 43 41 52 52 49 45 52 00                    NO CARRIER.

000003f1 <RESP_OK>:
     3f1:	4f 4b 00                                            OK.

000003f4 <RESP_CONNECT>:
     3f4:	43 4f 4e 4e 45 43 54 00                             CONNECT.

000003fc <RESP_CONNECT_OK>:
     3fc:	78 2c 20 43 4f 4e 4e 45 43 54 20 4f 4b 00           x, CONNECT OK.

0000040a <RESP_SERVER_OK>:
     40a:	53 45 52 56 45 52 20 4f 4b 00                       SERVER OK.

00000414 <RESP_SERVER_CLOSE>:
     414:	53 45 52 56 45 52 20 43 4c 4f 53 45 00              SERVER CLOSE.

00000421 <RESP_Invitation>:
     421:	3e 00                                               >.

00000423 <RESP_SEND_OK>:
     423:	78 2c 20 53 45 4e 44 20 4f 4b 00                    x, SEND OK.

0000042e <RESP_CLOSE_OK>:
     42e:	43 4c 4f 53 45 20 4f 4b 00                          CLOSE OK.

00000437 <RESP_CLOSE_OK_FAST>:
     437:	78 2c 20 43 4c 4f 53 45 20 4f 4b 00                 x, CLOSE OK.

00000443 <RESP_CSQ>:
     443:	2b 43 53 51 3a 00                                   +CSQ:.

00000449 <RESP_SHUT_OK>:
     449:	53 48 55 54 20 4f 4b 00                             SHUT OK.

00000451 <RESP_CREC_0>:
     451:	2b 43 52 45 43 3a 20 30 00                          +CREC: 0.

0000045a <ESC_SEQ>:
     45a:	2b 2b 2b 00                                         +++.

0000045e <IDENTIFICATION>:
     45e:	49 44 45 4e 54 49 46 49 43 41 54 49 4f 4e 00        IDENTIFICATION.

0000046d <AT_AT>:
     46d:	41 54 00                                            AT.

00000470 <AT_IPR9600>:
     470:	41 54 2b 49 50 52 3d 39 36 30 30 00                 AT+IPR=9600.

0000047c <AT_W>:
     47c:	41 54 26 57 00                                      AT&W.

00000481 <AT_E0>:
     481:	41 54 45 30 00                                      ATE0.

00000486 <AT_CLCC1>:
     486:	41 54 2b 43 4c 43 43 3d 31 00                       AT+CLCC=1.

00000490 <AT_DDET101>:
     490:	41 54 2b 44 44 45 54 3d 31 2c 30 2c 31 00           AT+DDET=1,0,1.

0000049e <AT_CGMM>:
     49e:	41 54 2b 43 47 4d 4d 00                             AT+CGMM.

000004a6 <AT_CCID>:
     4a6:	41 54 2b 43 43 49 44 00                             AT+CCID.

000004ae <AT_IFC>:
     4ae:	41 54 2b 49 46 43 3d 32 2c 32 00                    AT+IFC=2,2.

000004b9 <ATD101>:
     4b9:	41 54 44 2a 31 30 31 23 00                          ATD*101#.

000004c2 <ATD_PLUS>:
     4c2:	41 54 44 2b 00                                      ATD+.

000004c7 <AT_CUSD101>:
     4c7:	41 54 2b 43 55 53 44 3d 31 2c 22 00                 AT+CUSD=1,".

000004d3 <AT_CMGF>:
     4d3:	41 54 2b 43 4d 47 46 3d 31 00                       AT+CMGF=1.

000004dd <AT_CSMP>:
     4dd:	41 54 2b 43 53 4d 50 3d 31 37 2c 31 36 37 2c 30     AT+CSMP=17,167,0
     4ed:	2c 30 00                                            ,0.

000004f0 <AT_CMGS>:
     4f0:	41 54 2b 43 4d 47 53 3d 22 2b 00                    AT+CMGS="+.

000004fb <AT_CIPMODE_0>:
     4fb:	41 54 2b 43 49 50 4d 4f 44 45 3d 30 00              AT+CIPMODE=0.

00000508 <AT_CIPMODE_1>:
     508:	41 54 2b 43 49 50 4d 4f 44 45 3d 31 00              AT+CIPMODE=1.

00000515 <AT_CIPMUX_0>:
     515:	41 54 2b 43 49 50 4d 55 58 3d 30 00                 AT+CIPMUX=0.

00000521 <AT_CIPMUX_1>:
     521:	41 54 2b 43 49 50 4d 55 58 3d 31 00                 AT+CIPMUX=1.

0000052d <AT_CGATT>:
     52d:	41 54 2b 43 47 41 54 54 3d 31 00                    AT+CGATT=1.

00000538 <AT_CIPCSGP>:
     538:	41 54 2b 43 49 50 43 53 47 50 3d 31 2c 22 00        AT+CIPCSGP=1,".

00000547 <AT_CSTT>:
     547:	41 54 2b 43 53 54 54 00                             AT+CSTT.

0000054f <AT_CIICR>:
     54f:	41 54 2b 43 49 49 43 52 00                          AT+CIICR.

00000558 <AT_CIFSR>:
     558:	41 54 2b 43 49 46 53 52 00                          AT+CIFSR.

00000561 <AT_CIPTKA>:
     561:	41 54 2b 43 49 50 54 4b 41 3d 31 2c 33 30 2c 33     AT+CIPTKA=1,30,3
     571:	30 2c 31 00                                         0,1.

00000575 <AT_CIPSTART>:
     575:	41 54 2b 43 49 50 53 54 41 52 54 3d 22 55 44 50     AT+CIPSTART="UDP
     585:	22 2c 00                                            ",.

00000588 <AT_CIPSTART_TCP_CLIENT>:
     588:	41 54 2b 43 49 50 53 54 41 52 54 3d 22 54 43 50     AT+CIPSTART="TCP
     598:	22 2c 00                                            ",.

0000059b <AT_CIPSERVER>:
     59b:	41 54 2b 43 49 50 53 45 52 56 45 52 3d 31 2c 00     AT+CIPSERVER=1,.

000005ab <AT_SERVERCLOSE>:
     5ab:	41 54 2b 43 49 50 53 45 52 56 45 52 3d 30 00        AT+CIPSERVER=0.

000005ba <AT_CIPSEND>:
     5ba:	41 54 2b 43 49 50 53 45 4e 44 3d 00                 AT+CIPSEND=.

000005c6 <AT_CIPCLOSE_1>:
     5c6:	41 54 2b 43 49 50 43 4c 4f 53 45 3d 78 2c 31 00     AT+CIPCLOSE=x,1.

000005d6 <AT_CIPCLOSE>:
     5d6:	41 54 2b 43 49 50 43 4c 4f 53 45 3d 31 00           AT+CIPCLOSE=1.

000005e4 <AT_CIPSHUT>:
     5e4:	41 54 2b 43 49 50 53 48 55 54 00                    AT+CIPSHUT.

000005ef <AT_CGATT_0>:
     5ef:	41 54 2b 43 47 41 54 54 3d 30 00                    AT+CGATT=0.

000005fa <AT_CSQ>:
     5fa:	41 54 2b 43 53 51 00                                AT+CSQ.

00000601 <ATO>:
     601:	41 54 4f 00                                         ATO.

00000605 <Symbols_P>:
     605:	30 31 32 33 34 35 36 37 38 39 61 62 63 64 65 66     0123456789abcdef
     615:	67 68 69 6a 6b 6c 6d 6e 6f 70 71 72 73 74 75 76     ghijklmnopqrstuv
     625:	77 78 79 7a 41 42 43 44 45 46 47 48 49 4a 4b 4c     wxyzABCDEFGHIJKL
     635:	4d 4e 4f 50 51 52 53 54 55 56 57 58 59 5a e0 e1     MNOPQRSTUVWXYZ..
     645:	e2 e3 e4 e5 b8 ba e6 e7 e8 b3 bf e9 ea eb ec ed     ................
     655:	ee ef f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 fa fb fc fd     ................
     665:	fe ff c0 c1 c2 c3 c4 c5 a8 aa c6 c7 c8 b2 af c9     ................
     675:	ca cb cc cd ce cf d0 d1 d2 d3 d4 d5 d6 d7 d8 d9     ................
     685:	da db dc dd de df 20 2b 2d 3d 3c 3e 24 25 26 2e     ...... +-=<>$%&.
     695:	2c 3f 21 27 40 3a 28 29 22 7c 2a 23 2f 00           ,?!'@:()"|*#/.

000006a3 <OnlyDigits_P>:
     6a3:	30 31 32 33 34 35 36 37 38 39 00                    0123456789.

000006ae <Digits_P>:
     6ae:	30 31 32 33 34 35 36 37 38 39 65 2b 2d 2e 00        0123456789e+-..

000006bd <ThermFami>:
     6bd:	00 00 00 00 00 00                                   ......

000006c3 <TermisLim>:
     6c3:	00 00 00 00 0c fe 08 07 0c fe 08 07 0c fe 70 17     ..............p.
     6d3:	0c fe 70 17 0c fe 70 17 0c fe 70 17 0c fe 08 07     ..p...p...p.....

000006e3 <TermocLim>:
     6e3:	00 00 00 00 30 f8 e0 2e 70 17 50 46 30 f8 4c 1d     ....0...p.PF0.L.
     6f3:	30 f8 70 17                                         0.p.

000006f7 <Fail_Str>:
     6f7:	d1 e1 ee e9 20 00                                   .... .

000006fd <Norm_Str>:
     6fd:	cd ee f0 ec e0 00                                   ......

00000703 <DI_NO_Str>:
     703:	ed e5 f2 20 00                                      ... .

00000708 <DI_OK_Str>:
     708:	ed ee f0 ec 00                                      .....

0000070d <DI_Sta_Tbl>:
     70d:	03 07 08 07                                         ....

00000711 <DI_Op_Str>:
     711:	f0 e0 e7 ec 00                                      .....

00000716 <DI_Cl_Str>:
     716:	e7 e0 ec ea 00                                      .....

0000071b <DI_Tbl>:
     71b:	11 07 16 07                                         ....

0000071f <DI_Inv_Cl_Str>:
     71f:	ed 2e e7 2e 00                                      .....

00000724 <DI_Inv_Op_Str>:
     724:	ed 2e f0 2e 00                                      .....

00000729 <DI_Inv_Tbl>:
     729:	1f 07 24 07                                         ..$.

0000072d <DO_Op_Str>:
     72d:	e2 fb ea eb 00                                      .....

00000732 <DO_Cl_Str>:
     732:	e2 ea eb 20 00                                      ... .

00000737 <DO_Tbl>:
     737:	2d 07 32 07                                         -.2.

0000073b <F_ADC_3>:
     73b:	07 b4 07 00 00 00                                   ......

00000741 <F_ADC_4>:
     741:	07 2b 09 00 00 00                                   .+....

00000747 <F_ADC_5>:
     747:	07 f8 06 00 00 00                                   ......

0000074d <List_ADC_Err>:
     74d:	20 2d 2d 2d 20 41 44 43 20 65 72 72 6f 72 73 20      --- ADC errors 
     75d:	2d 2d 2d 20 00 00 00 00 00 00 00 20 52 65 61 64     --- ....... Read
     76d:	20 66 61 69 6c 3a 20 20 20 20 7b 7b 7b 7b 7b 00      fail:    {{{{{.
     77d:	3b 07 00 00 00 00 20 43 61 6c 69 62 72 20 66 61     ;..... Calibr fa
     78d:	69 6c 3a 20 20 7b 7b 7b 7b 7b 00 41 07 00 00 00     il:  {{{{{.A....
     79d:	00 20 43 61 6c 69 62 72 20 62 72 65 61 6b 3a 20     . Calibr break: 
     7ad:	7b 7b 7b 7b 7b 00 47 07 00 00 00 00                 {{{{{.G.....

000007b9 <Menu_ADC_Err>:
     7b9:	4d 07 04 03 00 00 00 00 00 00 00 00 00 00 00 00     M...............
     7c9:	00 00 00 00                                         ....

000007cd <F_ADC_1>:
     7cd:	1d 6a 0b 47 24 00                                   .j.G$.

000007d3 <F_ADC_2>:
     7d3:	00 b3 06 00 00 00 00 12 09 00 00 00                 ............

000007df <List_ADC>:
     7df:	20 d0 e5 e6 e8 ec 3a 20 7b 7b 7b 7b 7b 7b 7b 7b      .....: {{{{{{{{
     7ef:	7b 7b 7b 7b 00 cd 07 00 00 00 00 20 c2 f0 e5 ec     {{{{....... ....
     7ff:	ff 3a 7b 7b 30 ec f1 20 ca e0 ed e0 eb 3a 7b 00     .:{{0.. .....:{.
     80f:	d3 07 00 00 00 00 20 2d 20 ca e0 ed e0 eb fb 20     ...... - ...... 
     81f:	2d 20 20 20 20 20 20 20 20 20 00 00 00 00 00 68     -         .....h
     82f:	23 20 2d 20 ca e0 eb e8 e1 f0 ee e2 ea e0 20 2d     # - .......... -
     83f:	20 20 20 20 20 00 00 00 00 00 0c 24 20 2d 20 ce          ......$ - .
     84f:	f8 e8 e1 ea e8 20 2d 20 20 20 20 20 20 20 20 20     ..... -         
     85f:	00 00 00 00 00 b9 07                                .......

00000866 <MenuADC>:
     866:	df 07 05 02 00 00 00 00 00 00 00 00 00 00 00 00     ................
     876:	00 00 00 00                                         ....

0000087a <MsgErr21>:
     87a:	20 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f      _______________
     88a:	5f 5f 5f 20 00 00 00 20 49 6e 74 65 72 6e 61 6c     ___ ... Internal
     89a:	20 65 72 72 6f 72 20 32 31 3a 20 00 00 00 20 20      error 21: ...  
     8aa:	20 20 20 20 41 44 43 20 6f 66 66 20 20 20 20 20         ADC off     
     8ba:	20 20 00 00 00 20 20 20 20 20 20 20 20 20 20 20       ...           
     8ca:	20 20 20 20 20 20 20 20 20 00 00 00 00 00 00 00              .......
	...

000008dc <Therm_Off_Str>:
     8dc:	20 20 20 78 20 20 20 00                                x   .

000008e4 <ADC_Off_Str>:
     8e4:	2d 2d 2d 2d 2d 2d 2d 00                             -------.

000008ec <ThermTbl>:
     8ec:	dc 08 e4 08                                         ....

000008f0 <ThermOff_Str>:
     8f0:	ce f2 ea eb 2e 00                                   ......

000008f6 <TSM100_Str>:
     8f6:	d2 d1 cc 31 30 30 00                                ...100.

000008fd <TSM50_Str>:
     8fd:	d2 d1 cc 35 30 00                                   ...50.

00000903 <TSP100_Str>:
     903:	d2 d1 cf 31 30 30 00                                ...100.

0000090a <TSP50_Str>:
     90a:	d2 d1 cf 35 30 00                                   ...50.

00000910 <Pt100_Str>:
     910:	50 74 31 30 30 00                                   Pt100.

00000916 <Gr21_Str>:
     916:	c3 f0 32 31 00                                      ..21.

0000091b <Gr23_Str>:
     91b:	c3 f0 32 33 00                                      ..23.

00000920 <RTD_Name_List>:
     920:	f0 08 f6 08 fd 08 03 09 0a 09 10 09 16 09 1b 09     ................

00000930 <TC_K_Str>:
     930:	54 58 41 00                                         TXA.

00000934 <TC_B_Str>:
     934:	54 cf d0 00                                         T...

00000938 <TC_J_Str>:
     938:	54 c6 ca 00                                         T...

0000093c <TC_L_Str>:
     93c:	54 58 ca 00                                         TX..

00000940 <TC_Name_List>:
     940:	f0 08 30 09 34 09 38 09 3c 09                       ..0.4.8.<.

0000094a <NoPariStr>:
     94a:	ed e5 f2 00                                         ....

0000094e <EvenPariStr>:
     94e:	f7 e5 f2 ed fb e9 00                                .......

00000955 <OddPariStr>:
     955:	ed e5 f7 e5 f2 ed fb e9 00                          .........

0000095e <MBPariTbl>:
     95e:	4a 09 4e 09 55 09                                   J.N.U.

00000964 <BR_Str1200>:
     964:	31 32 30 30 00                                      1200.

00000969 <BR_Str2400>:
     969:	32 34 30 30 00                                      2400.

0000096e <BR_Str4800>:
     96e:	34 38 30 30 00                                      4800.

00000973 <BR_Str9600>:
     973:	39 36 30 30 00                                      9600.

00000978 <BR_Str14400>:
     978:	31 34 34 30 30 00                                   14400.

0000097e <BR_Str19200>:
     97e:	31 39 32 30 30 00                                   19200.

00000984 <BR_Str28800>:
     984:	32 38 38 30 30 00                                   28800.

0000098a <BR_Str38400>:
     98a:	33 38 34 30 30 00                                   38400.

00000990 <BR_Str57600>:
     990:	35 37 36 30 30 00                                   57600.

00000996 <BaudTbl>:
     996:	64 09 69 09 6e 09 73 09 78 09 7e 09 84 09 8a 09     d.i.n.s.x.~.....
     9a6:	90 09                                               ..

000009a8 <F_MB0_Pari>:
     9a8:	1e 04 00 00 00 00 00 02 00 00 00 15 76 5e 09 00     ............v^..

000009b8 <F_MB0_Stopbits>:
     9b8:	01 05 00 01 00 00 00 02 00 00 00 15 76 00 00 00     ............v...

000009c8 <F_MB0_Baud>:
     9c8:	1e 06 00 00 00 00 00 08 00 00 00 9e 75 96 09 00     ............u...

000009d8 <MB0_CPT_04>:
     9d8:	0b 36 09 00 00 00 0b 3e 09 00 00 00                 .6.....>....

000009e4 <MB0_CPT_15>:
     9e4:	0b 38 09 00 00 00 0b 40 09 00 00 00                 .8.....@....

000009f0 <MB0_CPT_26>:
     9f0:	0b 3a 09 00 00 00 0b 42 09 00 00 00                 .:.....B....

000009fc <MB0_CPT_37>:
     9fc:	0b 3c 09 00 00 00 0b 44 09 00 00 00                 .<.....D....

00000a08 <List_MB0_CPT>:
     a08:	43 50 31 3a 7b 7b 7b 7b 7b 20 20 43 50 35 3a 7b     CP1:{{{{{  CP5:{
     a18:	7b 7b 7b 7b 00 d8 09 00 00 00 00 43 50 32 3a 7b     {{{{.......CP2:{
     a28:	7b 7b 7b 7b 20 20 43 50 36 3a 7b 7b 7b 7b 7b 00     {{{{  CP6:{{{{{.
     a38:	e4 09 00 00 00 00 43 50 33 3a 7b 7b 7b 7b 7b 20     ......CP3:{{{{{ 
     a48:	20 43 50 37 3a 7b 7b 7b 7b 7b 00 f0 09 00 00 00      CP7:{{{{{......
     a58:	00 43 50 34 3a 7b 7b 7b 7b 7b 20 20 43 50 38 3a     .CP4:{{{{{  CP8:
     a68:	7b 7b 7b 7b 7b 00 fc 09 00 00 00 00                 {{{{{.......

00000a74 <M_MB0_CPT>:
     a74:	08 0a 04 03 00 00 00 00 00 00 00 00 70 43 00 00     ............pC..
     a84:	00 00 00 00                                         ....

00000a88 <L_MB0>:
     a88:	20 2d 2d 2d 2d 20 4d 6f 64 62 75 73 20 30 20 2d      ---- Modbus 0 -
     a98:	2d 2d 2d 20 00 00 00 00 00 00 00 20 d1 f7 e5 f2     --- ....... ....
     aa8:	f7 e8 ea e8 20 28 f1 e1 f0 ee f1 3a 2d 3e 29 00     .... (.....:->).
     ab8:	00 00 00 00 74 0a 20 cf e0 f0 e8 f2 e5 f2 3a 20     ....t. .......: 
     ac8:	7d 7d 7d 7d 7d 7d 7d 7d 20 20 00 00 00 a8 09 00     }}}}}}}}  ......
     ad8:	00 20 d1 f2 ee ef 2d e1 e8 f2 fb 3a 20 7d 20 20     . ....-....: }  
     ae8:	20 20 20 20 20 00 00 00 b8 09 00 00 20 42 41 55          ....... BAU
     af8:	44 3a 20 7d 7d 7d 7d 7d 62 70 73 20 20 20 20 20     D: }}}}}bps     
     b08:	00 00 00 c8 09 00 00                                .......

00000b0f <MenuModbus0>:
     b0f:	88 0a 05 01 00 00 00 00 00 00 00 00 00 00 00 00     ................
     b1f:	00 00 00 00                                         ....

00000b23 <List_Modbus>:
     b23:	20 4d 6f 64 62 75 73 20 30 20 20 20 20 20 20 20      Modbus 0       
     b33:	20 20 20 20 00 00 00 00 00 0f 0b 20 20 20 20 58         .......    X
     b43:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 00                    .
     b53:	00 00 00 00 00 00 20 20 20 20 58 20 20 20 20 20     ......    X     
     b63:	20 20 20 20 20 20 20 20 20 20 00 00 00 00 00 00               ......
     b73:	00 20 20 20 20 58 20 20 20 20 20 20 20 20 20 20     .    X          
     b83:	20 20 20 20 20 00 00 00 00 00 00 00                      .......

00000b8f <MenuModbus>:
     b8f:	23 0b 04 00 00 00 00 00 00 00 00 00 00 00 00 00     #...............
     b9f:	00 00 00 00                                         ....

00000ba3 <N_Str>:
     ba3:	cd e5 f2 00                                         ....

00000ba7 <Y_Str>:
     ba7:	c4 e0 00                                            ...

00000baa <YN_Tbl>:
     baa:	a3 0b a7 0b                                         ....

00000bae <F_SummerTime>:
     bae:	1e 03 00 00 00 00 00 01 00 00 00 00 00 aa 0b 00     ................

00000bbe <F_WDay>:
     bbe:	00 57 06 00 00 00                                   .W....

00000bc4 <F_DateTime>:
     bc4:	04 5f 0b 01 00 00 00 1f 00 00 00 42 27 00 00 00     ._.........B'...
     bd4:	04 cc 07 01 00 00 00 0c 00 00 00 4c 27 00 00 00     ...........L'...
     be4:	04 de 05 00 00 00 00 63 00 00 00 56 27 00 00 00     .......c...V'...
     bf4:	04 c1 05 00 00 00 00 17 00 00 00 38 27 00 00 00     ...........8'...
     c04:	04 51 06 00 00 00 00 3b 00 00 00 2e 27 00 00 00     .Q.....;....'...
     c14:	04 f7 06 00 00 00 00 3b 00 00 00 24 27 00 00 00     .......;...$'...

00000c24 <GSM_CNTL_AUTO_Str>:
     c24:	61 75 74 6f 20 20 00                                auto  .

00000c2b <GSM_CNTL_MANUAL_Str>:
     c2b:	6d 61 6e 75 61 6c 00                                manual.

00000c32 <GSM_CNTL_CONFIG_Str>:
     c32:	63 6f 6e 66 69 67 00                                config.

00000c39 <GSM_ControlList>:
     c39:	24 0c 2b 0c 32 0c                                   $.+.2.

00000c3f <GSM_Not_Recognize_Str>:
     c3f:	6e 6f 74 20 72 65 63 6f 67 00                       not recog.

00000c49 <GSM_SIMCOM_SIM900R_Str>:
     c49:	53 49 4d 39 30 30 52 20 20 00                       SIM900R  .

00000c53 <GSM_SIMCOM_SIM800_Str>:
     c53:	53 49 4d 38 30 30 20 20 20 00                       SIM800   .

00000c5d <GSM_ModemList>:
     c5d:	3f 0c 49 0c 53 0c                                   ?.I.S.

00000c63 <MenuGSM_Modem_State>:
     c63:	1d 34 07 5d 0c 00 00 f6 06 00 00 00                 .4.]........

00000c6f <MenuGSM_State>:
     c6f:	00 f6 06 00 00 00                                   ......

00000c75 <MenuGSM_GSM_Cont>:
     c75:	1d d1 07 00 00 00 00 02 00 00 00 7f 43 39 0c 00     ............C9..

00000c85 <MenuGSM_GSM_MyIP>:
     c85:	00 31 09 00 00 00 00 32 09 00 00 00 00 33 09 00     .1.....2.....3..
     c95:	00 00 00 34 09 00 00 00                             ...4....

00000c9d <MenuGSM_ClientIP>:
     c9d:	00 4a 0b 00 00 00 00 4b 0b 00 00 00 00 4c 0b 00     .J.....K.....L..
     cad:	00 00 00 4d 0b 00 00 00                             ...M....

00000cb5 <MenuGSM_ActiveCon>:
     cb5:	00 d3 02 00 00 00                                   ......

00000cbb <MenuGSM_FIFOMax>:
     cbb:	00 19 09 00 00 00                                   ......

00000cc1 <MenuGSM_APN1>:
     cc1:	22 09 00 00 00 00 00 06 00 00 00 00 00 00 00 00     "...............

00000cd1 <MenuGSM_APN2>:
     cd1:	22 1d 00 00 00 00 00 06 00 00 00 00 00 00 00 00     "...............

00000ce1 <MenuGSM_APN_USER_NAME>:
     ce1:	22 59 00 00 00 00 00 06 00 00 00 00 00 00 00 00     "Y..............

00000cf1 <MenuGSM_APN_PASSWORD>:
     cf1:	22 6d 00 00 00 00 00 06 00 00 00 00 00 00 00 00     "m..............

00000d01 <MenuGSM_IPUDP1>:
     d01:	01 81 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     d11:	01 82 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     d21:	01 83 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     d31:	01 84 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00000d41 <MenuGSM_IPUDP2>:
     d41:	01 85 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     d51:	01 86 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     d61:	01 87 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     d71:	01 88 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00000d81 <MenuGSM_IPUDP3>:
     d81:	01 89 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     d91:	01 8a 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     da1:	01 8b 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     db1:	01 8c 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00000dc1 <MenuGSM_IPUDP4>:
     dc1:	01 8d 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     dd1:	01 8e 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     de1:	01 8f 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     df1:	01 90 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00000e01 <MenuGSM_PortUDP1>:
     e01:	08 a1 00 00 00 00 00 ff ff 00 00 00 00 00 00 00     ................

00000e11 <MenuGSM_PortUDP2>:
     e11:	08 a3 00 00 00 00 00 ff ff 00 00 00 00 00 00 00     ................

00000e21 <MenuGSM_PortUDP3>:
     e21:	08 a5 00 00 00 00 00 ff ff 00 00 00 00 00 00 00     ................

00000e31 <MenuGSM_PortUDP4>:
     e31:	08 a7 00 00 00 00 00 ff ff 00 00 00 00 00 00 00     ................

00000e41 <MenuGSM_IPTCP1>:
     e41:	01 b3 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     e51:	01 b4 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     e61:	01 b5 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     e71:	01 b6 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00000e81 <MenuGSM_IPTCP2>:
     e81:	01 b7 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     e91:	01 b8 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     ea1:	01 b9 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     eb1:	01 ba 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00000ec1 <MenuGSM_IPTCP3>:
     ec1:	01 bb 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     ed1:	01 bc 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     ee1:	01 bd 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     ef1:	01 be 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00000f01 <MenuGSM_IPTCP4>:
     f01:	01 bf 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     f11:	01 c0 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     f21:	01 c1 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     f31:	01 c2 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00000f41 <MenuGSM_TCPPort>:
     f41:	08 b1 00 00 00 00 00 ff ff 00 00 00 00 00 00 00     ................

00000f51 <MenuGSM_TCPTimeout>:
     f51:	08 c3 00 64 00 00 00 ff ff 00 00 00 00 00 00 02     ...d............

00000f61 <MenuGSM_SMS>:
     f61:	01 13 01 00 00 00 00 01 00 00 00 00 00 00 00 00     ................

00000f71 <MenuGSM_VegaSN>:
     f71:	08 07 00 00 00 00 00 ff ff 00 00 00 00 00 00 00     ................

00000f81 <ListGSM>:
     f81:	20 cc ee e4 e5 ec 20 7b 7b 7b 7b 7b 7b 7b 7b 7b      ..... {{{{{{{{{
     f91:	20 7b 7b 7b 00 63 0c 00 00 00 00 20 43 6f 6e 74      {{{.c..... Cont
     fa1:	72 6f 6c 20 6d 6f 64 65 3a 7d 7d 7d 7d 7d 7d 00     rol mode:}}}}}}.
     fb1:	00 00 75 0c 00 00 20 4d 79 49 50 7b 7b 7b 2e 7b     ..u... MyIP{{{.{
     fc1:	7b 7b 2e 7b 7b 7b 2e 7b 7b 7b 00 85 0c 00 00 00     {{.{{{.{{{......
     fd1:	00 20 43 6c 49 50 7b 7b 7b 2e 7b 7b 7b 2e 7b 7b     . ClIP{{{.{{{.{{
     fe1:	7b 2e 7b 7b 7b 00 9d 0c 00 00 00 00 20 41 63 74     {.{{{....... Act
     ff1:	69 76 65 20 63 6f 6e 65 63 74 69 6f 6e 7b 7b 7b     ive conection{{{
    1001:	00 b5 0c 00 00 00 00 20 46 49 46 4f 3a 6d 61 78     ....... FIFO:max
    1011:	20 7b 7b 2f 37 30 62 79 74 65 20 00 bb 0c 00 00      {{/70byte .....
    1021:	00 00 20 2d 2d 2d 2d 2d 2d 2d 41 50 4e 2d 2d 2d     .. -------APN---
    1031:	2d 2d 2d 2d 2d 2d 00 00 00 00 00 00 00 20 7d 7d     ------....... }}
    1041:	7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d     }}}}}}}}}}}}}}}}
    1051:	7d 00 00 00 c1 0c 00 00 20 7d 7d 7d 7d 7d 7d 7d     }....... }}}}}}}
    1061:	7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 00 00 00 d1     }}}}}}}}}}}}....
    1071:	0c 00 00 20 2d 2d 2d 41 50 4e 2d 55 53 45 52 20     ... ---APN-USER 
    1081:	4e 41 4d 45 2d 2d 2d 00 00 00 00 00 00 00 20 7d     NAME---....... }
    1091:	7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d     }}}}}}}}}}}}}}}}
    10a1:	7d 7d 00 00 00 e1 0c 00 00 20 2d 2d 2d 41 50 4e     }}....... ---APN
    10b1:	2d 50 41 53 53 57 4f 52 44 2d 2d 2d 2d 00 00 00     -PASSWORD----...
    10c1:	00 00 00 00 20 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d     .... }}}}}}}}}}}
    10d1:	7d 7d 7d 7d 7d 7d 7d 7d 00 00 00 f1 0c 00 00 20     }}}}}}}}....... 
    10e1:	2d 2d 53 65 6e 64 20 55 44 50 20 74 6f 20 49 50     --Send UDP to IP
    10f1:	2d 2d 2d 00 00 00 00 00 00 00 20 49 50 31 3a 7d     ---....... IP1:}
    1101:	7d 7d 2e 7d 7d 7d 2e 7d 7d 7d 2e 7d 7d 7d 00 00     }}.}}}.}}}.}}}..
    1111:	00 01 0d 00 00 20 49 50 32 3a 7d 7d 7d 2e 7d 7d     ..... IP2:}}}.}}
    1121:	7d 2e 7d 7d 7d 2e 7d 7d 7d 00 00 00 41 0d 00 00     }.}}}.}}}...A...
    1131:	20 49 50 33 3a 7d 7d 7d 2e 7d 7d 7d 2e 7d 7d 7d      IP3:}}}.}}}.}}}
    1141:	2e 7d 7d 7d 00 00 00 81 0d 00 00 20 49 50 34 3a     .}}}....... IP4:
    1151:	7d 7d 7d 2e 7d 7d 7d 2e 7d 7d 7d 2e 7d 7d 7d 00     }}}.}}}.}}}.}}}.
    1161:	00 00 c1 0d 00 00 20 2d 2d 2d 2d 20 55 44 50 20     ...... ---- UDP 
    1171:	50 6f 72 74 20 2d 2d 2d 2d 2d 00 00 00 00 00 00     Port -----......
    1181:	00 20 49 50 31 20 50 6f 72 74 3a 7d 7d 7d 7d 7d     . IP1 Port:}}}}}
    1191:	20 20 20 20 20 00 00 00 01 0e 00 00 20 49 50 32          ....... IP2
    11a1:	20 50 6f 72 74 3a 7d 7d 7d 7d 7d 20 20 20 20 20      Port:}}}}}     
    11b1:	00 00 00 11 0e 00 00 20 49 50 33 20 50 6f 72 74     ....... IP3 Port
    11c1:	3a 7d 7d 7d 7d 7d 20 20 20 20 20 00 00 00 21 0e     :}}}}}     ...!.
    11d1:	00 00 20 49 50 34 20 50 6f 72 74 3a 7d 7d 7d 7d     .. IP4 Port:}}}}
    11e1:	7d 20 20 20 20 20 00 00 00 31 0e 00 00 20 2d 20     }     ...1... - 
    11f1:	54 43 50 20 49 50 20 46 69 72 65 77 61 6c 6c 2d     TCP IP Firewall-
    1201:	2d 00 00 00 00 00 00 00 20 49 50 31 3a 7d 7d 7d     -....... IP1:}}}
    1211:	2e 7d 7d 7d 2e 7d 7d 7d 2e 7d 7d 7d 00 00 00 41     .}}}.}}}.}}}...A
    1221:	0e 00 00 20 49 50 32 3a 7d 7d 7d 2e 7d 7d 7d 2e     ... IP2:}}}.}}}.
    1231:	7d 7d 7d 2e 7d 7d 7d 00 00 00 81 0e 00 00 20 49     }}}.}}}....... I
    1241:	50 33 3a 7d 7d 7d 2e 7d 7d 7d 2e 7d 7d 7d 2e 7d     P3:}}}.}}}.}}}.}
    1251:	7d 7d 00 00 00 c1 0e 00 00 20 49 50 34 3a 7d 7d     }}....... IP4:}}
    1261:	7d 2e 7d 7d 7d 2e 7d 7d 7d 2e 7d 7d 7d 00 00 00     }.}}}.}}}.}}}...
    1271:	01 0f 00 00 20 54 43 50 53 65 72 76 65 72 50 6f     .... TCPServerPo
    1281:	72 74 3a 7d 7d 7d 7d 7d 00 00 00 41 0f 00 00 20     rt:}}}}}...A... 
    1291:	54 69 6d 65 6f 75 74 20 54 43 50 3a 7d 7d 7d 7d     Timeout TCP:}}}}
    12a1:	7d 7d 63 00 00 00 51 0f 00 00 20 2d 2d 2d 2d 2d     }}c...Q... -----
    12b1:	2d 2d 20 53 4d 53 20 2d 2d 2d 2d 2d 2d 2d 00 00     -- SMS -------..
    12c1:	00 00 00 00 00 20 d0 e0 f1 f1 fb eb ea e0 20 53     ..... ........ S
    12d1:	4d 53 3a 20 20 20 7d 7d 7d 00 00 00 61 0f 00 00     MS:   }}}...a...
    12e1:	20 2d 2d 49 64 65 6e 74 69 66 69 63 61 74 69 6f      --Identificatio
    12f1:	6e 2d 2d 2d 00 00 00 00 00 00 00 20 56 65 67 61     n---....... Vega
    1301:	20 53 2f 4e 3a 20 20 20 20 20 7d 7d 7d 7d 7d 00      S/N:     }}}}}.
    1311:	00 00 71 0f 00 00                                   ..q...

00001317 <MenuGSM>:
    1317:	81 0f 22 00 00 00 00 00 00 00 00 00 00 00 00 00     ..".............
    1327:	00 00 00 00                                         ....

0000132b <Mem_OK_Tbl>:
    132b:	fd 06 f7 06                                         ....

0000132f <F_Ok_Flash>:
    132f:	1f 17 09 2b 13 00                                   ...+..

00001335 <F_Ok_EEPROM>:
    1335:	1f 17 09 2b 13 01                                   ...+..

0000133b <Msg_EEWarning>:
    133b:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    134b:	20 20 20 20 00 00 00 20 cf e5 f0 e5 e4 20 ef f0         ... ..... ..
    135b:	ee e4 ee eb e6 e5 ed e8 e5 ec 20 00 00 00 f0 e0     .......... .....
    136b:	e1 ee f2 fb 20 ef f0 ee e2 e5 f0 fc f2 e5 20 e2     .... ......... .
    137b:	f1 e5 00 00 00 20 20 20 20 20 20 ed e0 f1 f2 f0     .....      .....
    138b:	ee e9 ea e8 20 20 20 20 20 00 00 00 00 00 00 00     ....     .......
	...

0000139d <Msg_NoBackUp>:
    139d:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    13ad:	20 20 20 20 00 00 00 d1 ee f5 f0 e0 ed b8 ed ed         ............
    13bd:	fb f5 20 ed e0 f1 f2 f0 ee e5 ea 00 00 00 20 20     .. ...........  
    13cd:	20 20 ed e5 20 ee e1 ed e0 f0 f3 e6 e5 ed ee 20       .. .......... 
    13dd:	20 20 00 00 00 20 20 20 20 20 20 20 20 20 20 20       ...           
    13ed:	20 20 20 20 20 20 20 20 20 00 00 00 00 00 00 00              .......
	...

000013ff <Menu_ConfirmationSave_List>:
    13ff:	d1 ee f5 f0 e0 ed e8 f2 fc 20 ed e0 f1 f2 f0 ee     ......... ......
    140f:	e9 ea e8 3f 00 00 00 00 00 00 00 20 20 20 c4 e0     ...?.......   ..
    141f:	20 2d 20 ea ed ee ef ea e0 20 c2 d5 ce c4 20 00      - ...... .... .
    142f:	00 00 00 00 00 00 20 20 cd e5 f2 20 2d 20 ea ed     ......  ... - ..
    143f:	ee ef ea e0 20 c2 db d5 ce c4 00 00 00 00 00 00     .... ...........
    144f:	00 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20     .               
    145f:	20 20 20 20 20 00 00 00 00 00 00 00                      .......

0000146b <Menu_ConfirmationSave>:
    146b:	ff 13 04 03 00 00 00 00 00 00 00 00 00 44 00 00     .............D..
    147b:	00 00 00 00                                         ....

0000147f <Menu_ConfirmationRest_List>:
    147f:	c2 ee f1 f2 e0 ed ee e2 2e 20 ed e0 f1 f2 f0 ee     ......... ......
    148f:	e9 ea e8 3f 00 00 00 00 00 00 00 20 20 20 c4 e0     ...?.......   ..
    149f:	20 2d 20 ea ed ee ef ea e0 20 c2 d5 ce c4 20 00      - ...... .... .
    14af:	00 00 00 00 00 00 20 20 cd e5 f2 20 2d 20 ea ed     ......  ... - ..
    14bf:	ee ef ea e0 20 c2 db d5 ce c4 00 00 00 00 00 00     .... ...........
    14cf:	00 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20     .               
    14df:	20 20 20 20 20 00 00 00 00 00 00 00                      .......

000014eb <Menu_ConfirmationRestore>:
    14eb:	7f 14 04 03 00 00 00 00 00 00 00 00 f5 43 00 00     .............C..
    14fb:	00 00 00 00                                         ....

000014ff <NoBackUp_Str>:
    14ff:	2d 2d 00                                            --.

00001502 <BackUp_Tbl>:
    1502:	ff 14                                               ..

00001504 <Menu_BackUp_IField>:
    1504:	05 00 00 02 15 00 05 01 00 02 15 00 05 02 00 02     ................
    1514:	15 00                                               ..

00001516 <Menu_BackUp_List>:
    1516:	d3 f1 f2 ed 2f d0 e5 e7 e5 f0 e2 ed e0 ff 20 ea     ..../......... .
    1526:	ee ef e8 ff 00 00 00 00 00 00 00 20 d1 ee f5 f0     ........... ....
    1536:	e0 ed e8 f2 fc 20 20 20 20 20 20 20 20 20 20 00     .....          .
    1546:	00 00 00 00 6b 14 20 c2 ee f1 f2 e0 ed ee e2 3a     ....k. ........:
    1556:	7b 7b 2e 7b 7b 2e 32 30 7b 7b 00 04 15 00 00 00     {{.{{.20{{......
    1566:	00 20 d1 ee f1 f2 2e 45 45 50 52 4f 4d 3a 20 7b     . .....EEPROM: {
    1576:	7b 7b 7b 7b 20 00 35 13 00 00 00 00                 {{{{ .5.....

00001582 <Menu_BackUp>:
    1582:	16 15 04 01 00 00 00 00 00 00 00 00 27 7a 00 00     ............'z..
    1592:	00 00 00 00                                         ....

00001596 <ListMem>:
    1596:	20 2d 2d 2d 2d 2d 20 4d 65 6d 6f 72 79 20 2d 2d      ----- Memory --
    15a6:	2d 2d 2d 20 00 00 00 00 00 00 00 20 46 6c 61 73     --- ....... Flas
    15b6:	68 3a 20 20 7b 7b 7b 7b 7b 20 20 20 20 20 20 00     h:  {{{{{      .
    15c6:	2f 13 00 00 00 00 20 45 45 50 52 4f 4d 3a 20 7b     /..... EEPROM: {
    15d6:	7b 7b 7b 7b 20 20 20 20 20 20 00 35 13 00 00 00     {{{{      .5....
    15e6:	00 20 52 65 73 65 74 20 45 45 50 52 4f 4d 20 66     . Reset EEPROM f
    15f6:	61 69 6c 20 20 00 00 00 00 00 00 00 20 42 61 63     ail  ....... Bac
    1606:	6b 55 70 20 45 45 50 52 4f 4d 20 20 20 20 20 20     kUp EEPROM      
    1616:	00 00 00 00 00 82 15                                .......

0000161d <MenuMem>:
    161d:	96 15 05 01 00 00 00 00 00 00 00 00 b3 4f 00 00     .............O..
    162d:	00 00 00 00                                         ....

00001631 <MsgErr11>:
    1631:	20 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f      _______________
    1641:	5f 5f 5f 20 00 00 00 20 49 6e 74 65 72 6e 61 6c     ___ ... Internal
    1651:	20 65 72 72 6f 72 20 31 31 3a 20 00 00 00 20 20      error 11: ...  
    1661:	20 20 20 46 6c 61 73 68 20 66 61 69 6c 20 20 20        Flash fail   
    1671:	20 20 00 00 00 20 20 20 20 20 20 20 20 20 20 20       ...           
    1681:	20 20 20 20 20 20 20 20 20 00 00 00 00 00 00 00              .......
	...

00001693 <MsgErr12>:
    1693:	20 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f      _______________
    16a3:	5f 5f 5f 20 00 00 00 20 49 6e 74 65 72 6e 61 6c     ___ ... Internal
    16b3:	20 65 72 72 6f 72 20 31 32 3a 20 00 00 00 20 20      error 12: ...  
    16c3:	20 20 45 45 50 52 4f 4d 20 66 61 69 6c 20 20 20       EEPROM fail   
    16d3:	20 20 00 00 00 20 20 20 20 20 20 20 20 20 20 20       ...           
    16e3:	20 20 20 20 20 20 20 20 20 00 00 00 00 00 00 00              .......
	...

000016f5 <MsgErr13>:
    16f5:	20 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f      _______________
    1705:	5f 5f 5f 20 00 00 00 20 49 6e 74 65 72 6e 61 6c     ___ ... Internal
    1715:	20 65 72 72 6f 72 20 31 33 3a 20 00 00 00 20 54      error 13: ... T
    1725:	6f 74 61 6c 20 6d 65 6d 6f 72 79 20 66 61 69 6c     otal memory fail
    1735:	20 20 00 00 00 20 20 20 20 20 20 20 20 20 20 20       ...           
    1745:	20 20 20 20 20 20 20 20 20 00 00 00 00 00 00 00              .......
	...

00001757 <MsgErrMemo>:
    1757:	00 00 31 16 93 16 f5 16                             ..1.....

0000175f <F_ScanCycle>:
    175f:	00 ae 07 00 00 00                                   ......

00001765 <F_ScanCyclePerSec>:
    1765:	07 ce 07 00 00 00                                   ......

0000176b <F_MaxScanCycle>:
    176b:	00 b1 06 00 00 00                                   ......

00001771 <ListScanCycle>:
    1771:	20 2d 2d 2d 20 53 63 61 6e 20 43 79 63 6c 65 20      --- Scan Cycle 
    1781:	2d 2d 2d 20 00 00 00 00 00 00 00 20 53 63 61 6e     --- ....... Scan
    1791:	43 79 63 6c 65 3a 20 20 20 7b 7b 7b 30 6d 73 00     Cycle:   {{{0ms.
    17a1:	5f 17 00 00 00 00 20 53 63 61 6e 43 79 63 6c 50     _..... ScanCyclP
    17b1:	65 72 53 65 63 3a 7b 7b 7b 7b 00 65 17 00 00 00     erSec:{{{{.e....
    17c1:	00 20 4d 61 78 53 63 61 6e 43 79 63 6c 65 3a 7b     . MaxScanCycle:{
    17d1:	7b 7b 30 6d 73 00 6b 17 00 00 00 00                 {{0ms.k.....

000017dd <MenuScanCycle>:
    17dd:	71 17 04 01 00 00 00 00 00 00 00 00 83 43 00 00     q............C..
    17ed:	00 00 00 00                                         ....

000017f1 <F_WT>:
    17f1:	0b 6b 0c 00 00 00 04 b0 06 00 00 00                 .k..........

000017fd <sec10_Str>:
    17fd:	31 30 20 f1 e5 ea 00                                10 ....

00001804 <sec30_Str>:
    1804:	33 30 20 f1 e5 ea 00                                30 ....

0000180b <min1_Str>:
    180b:	31 20 ec e8 ed 20 00                                1 ... .

00001812 <min3_Str>:
    1812:	33 20 ec e8 ed 20 00                                3 ... .

00001819 <min10_Str>:
    1819:	31 30 20 ec e8 ed 00                                10 ....

00001820 <BCKLT_Tbl>:
    1820:	fd 17 04 18 0b 18 12 18 19 18                       ..........

0000182a <F_Backlight>:
    182a:	1e 91 01 00 00 00 00 04 00 00 00 00 00 20 18 00     ............. ..

0000183a <F_IonT>:
    183a:	08 2f 01 00 00 00 00 ff 03 00 00 00 00 00 00 00     ./..............

0000184a <F_Menu_EMICounter>:
    184a:	10 3a 07 00 00 00                                   .:....

00001850 <ListSyst>:
    1850:	20 2d 20 d1 eb f3 e6 e5 e1 ed ee e5 20 ec e5 ed      - ......... ...
    1860:	fe 20 2d 20 00 00 00 00 00 00 00 20 c4 e8 f1 ea     . - ....... ....
    1870:	f0 e5 f2 ed fb e5 20 e2 f5 ee e4 fb 20 20 20 00     ...... .....   .
    1880:	00 00 00 00 6f 1e 20 c4 e8 f1 ea f0 e5 f2 ed fb     ....o. .........
    1890:	e5 20 e2 fb f5 ee e4 fb 20 20 00 00 00 00 00 33     . ......  .....3
    18a0:	21 20 c0 ed e0 eb ee e3 ee e2 fb e5 20 e2 f5 ee     ! .......... ...
    18b0:	e4 fb 20 20 20 00 00 00 00 00 e3 21 20 c0 ed e0     ..   ......! ...
    18c0:	eb ee e3 ee e2 fb e5 20 e2 fb f5 ee e4 fb 20 20     ....... ......  
    18d0:	00 00 00 00 00 a3 22 20 c0 d6 cf 20 20 20 20 20     ......" ...     
    18e0:	20 20 20 20 20 20 20 20 20 20 20 00 00 00 00 00                .....
    18f0:	66 08 20 d2 e5 f0 ec ee e4 e0 f2 f7 e8 ea e8 20     f. ............ 
    1900:	20 20 20 20 20 20 00 00 00 00 00 37 29 20 4d 6f           .....7) Mo
    1910:	64 62 75 73 20 20 20 20 20 20 20 20 20 20 20 20     dbus            
    1920:	20 00 00 00 00 00 8f 0b 20 cc ee e4 e5 ec 20 20      ....... .....  
    1930:	20 20 20 20 20 20 20 20 20 20 20 20 00 00 00 00                 ....
    1940:	00 17 13 20 7b 20 7d 7d 2e 7d 7d 2e 7d 7d 20 7d     ... { }}.}}.}} }
    1950:	7d 3a 7d 7d 3a 7d 7d 00 be 0b c4 0b 00 00 20 c0     }:}}:}}....... .
    1960:	e2 f2 ee cf e5 f0 e5 f5 cb e5 f2 ed c2 f0 3a 7d     ..............:}
    1970:	7d 7d 00 00 00 ae 0b 00 00 20 cd e0 f0 e0 e1 ee     }}....... ......
    1980:	f2 ea e0 3a 7b 7b 7b 7b 7b f7 7b 7b ec 00 f1 17     ...:{{{{{.{{....
    1990:	00 00 00 00 20 d1 ee f1 f2 ee ff ed e8 e5 20 ef     .... ......... .
    19a0:	e0 ec ff f2 e8 20 20 20 00 00 00 00 00 1d 16 20     .....   ....... 
    19b0:	53 63 61 6e 20 43 79 63 6c 65 3a 20 20 7b 7b 7b     Scan Cycle:  {{{
    19c0:	30 6d 73 00 5f 17 00 00 dd 17 20 cf ee f0 ee e3     0ms._..... .....
    19d0:	20 e8 ee ed ee e4 2e 3a 20 20 7d 7d 7d 7d 00 00      ......:  }}}}..
    19e0:	00 3a 18 00 00 20 cf ee e4 f1 e2 e5 f2 ea e0 c6     .:... ..........
    19f0:	ca c8 3a 7d 7d 7d 7d 7d 7d 00 00 00 2a 18 00 00     ..:}}}}}}...*...
    1a00:	20 d1 f7 b8 f2 2e dd cc cd 3a 7b 7b 7b 7b 7b 7b      ........:{{{{{{
    1a10:	7b 7b 7b 7b 00 4a 18 00 00 00 00                    {{{{.J.....

00001a1b <MenuSyst>:
    1a1b:	50 18 11 01 00 00 00 00 00 00 00 00 00 00 00 00     P...............
    1a2b:	00 00 00 00                                         ....

00001a2f <MsgErr41>:
    1a2f:	20 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f      _______________
    1a3f:	5f 5f 5f 20 00 00 00 20 49 6e 74 65 72 6e 61 6c     ___ ... Internal
    1a4f:	20 65 72 72 6f 72 20 34 31 3a 20 00 00 00 54 69      error 41: ...Ti
    1a5f:	6d 65 72 20 61 6c 6c 6f 63 61 74 69 6f 6e 20 65     mer allocation e
    1a6f:	72 72 00 00 00 20 20 20 20 20 20 20 20 20 20 20     rr...           
    1a7f:	20 20 20 20 20 20 20 20 20 00 00 00 00 00 00 00              .......
	...

00001a91 <F_DI1>:
    1a91:	1f 40 07 1b 07 00 1f 46 07 0d 07 00                 .@.....F....

00001a9d <F_DI2>:
    1a9d:	1f 40 07 1b 07 01 1f 46 07 0d 07 01                 .@.....F....

00001aa9 <F_DI3>:
    1aa9:	1f 40 07 1b 07 02 1f 46 07 0d 07 02                 .@.....F....

00001ab5 <F_DI4>:
    1ab5:	1f 40 07 1b 07 03 1f 46 07 0d 07 03                 .@.....F....

00001ac1 <F_DI5>:
    1ac1:	1f 40 07 1b 07 04 1f 46 07 0d 07 04                 .@.....F....

00001acd <F_DI6>:
    1acd:	1f 40 07 1b 07 05 1f 46 07 0d 07 05                 .@.....F....

00001ad9 <F_DI7>:
    1ad9:	1f 40 07 1b 07 06 1f 46 07 0d 07 06                 .@.....F....

00001ae5 <F_DI8>:
    1ae5:	1f 40 07 1b 07 07 1f 46 07 0d 07 07                 .@.....F....

00001af1 <F_DI9>:
    1af1:	1f 40 07 1b 07 08 1f 46 07 0d 07 08                 .@.....F....

00001afd <F_DI10>:
    1afd:	1f 40 07 1b 07 09 1f 46 07 0d 07 09                 .@.....F....

00001b09 <F_DI11>:
    1b09:	1f 40 07 1b 07 0a 1f 46 07 0d 07 0a                 .@.....F....

00001b15 <F_DI12>:
    1b15:	1f 40 07 1b 07 0b 1f 46 07 0d 07 0b                 .@.....F....

00001b21 <F_DI13>:
    1b21:	1f 40 07 1b 07 0c 1f 46 07 0d 07 0c                 .@.....F....

00001b2d <F_DI14>:
    1b2d:	1f 40 07 1b 07 0d 1f 46 07 0d 07 0d                 .@.....F....

00001b39 <F_DI15>:
    1b39:	1f 40 07 1b 07 0e 1f 46 07 0d 07 0e                 .@.....F....

00001b45 <F_DI16>:
    1b45:	1f 40 07 1b 07 0f 1f 46 07 0d 07 0f                 .@.....F....

00001b51 <F_DI17>:
    1b51:	1f 40 07 1b 07 10 1f 46 07 0d 07 10                 .@.....F....

00001b5d <F_DI18>:
    1b5d:	1f 40 07 1b 07 11 1f 46 07 0d 07 11                 .@.....F....

00001b69 <F_DII1>:
    1b69:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 00      ............)..

00001b79 <F_DII2>:
    1b79:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 01      ............)..

00001b89 <F_DII3>:
    1b89:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 02      ............)..

00001b99 <F_DII4>:
    1b99:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 03      ............)..

00001ba9 <F_DII5>:
    1ba9:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 04      ............)..

00001bb9 <F_DII6>:
    1bb9:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 05      ............)..

00001bc9 <F_DII7>:
    1bc9:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 06      ............)..

00001bd9 <F_DII8>:
    1bd9:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 07      ............)..

00001be9 <F_DII9>:
    1be9:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 08      ............)..

00001bf9 <F_DII10>:
    1bf9:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 09      ............)..

00001c09 <F_DII11>:
    1c09:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 0a      ............)..

00001c19 <F_DII12>:
    1c19:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 0b      ............)..

00001c29 <F_DII13>:
    1c29:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 0c      ............)..

00001c39 <F_DII14>:
    1c39:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 0d      ............)..

00001c49 <F_DII15>:
    1c49:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 0e      ............)..

00001c59 <F_DII16>:
    1c59:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 0f      ............)..

00001c69 <F_DII17>:
    1c69:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 10      ............)..

00001c79 <F_DII18>:
    1c79:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 11      ............)..

00001c89 <ListDI>:
    1c89:	20 4e 31 3a 20 20 7b 7b 7b 7b 20 7d 7d 7d 7d 20      N1:  {{{{ }}}} 
    1c99:	7b 7b 7b 7b 00 91 1a 69 1b 00 00 20 4e 32 3a 20     {{{{...i... N2: 
    1ca9:	20 7b 7b 7b 7b 20 7d 7d 7d 7d 20 7b 7b 7b 7b 00      {{{{ }}}} {{{{.
    1cb9:	9d 1a 79 1b 00 00 20 4e 33 3a 20 20 7b 7b 7b 7b     ..y... N3:  {{{{
    1cc9:	20 7d 7d 7d 7d 20 7b 7b 7b 7b 00 a9 1a 89 1b 00      }}}} {{{{......
    1cd9:	00 20 4e 34 3a 20 20 7b 7b 7b 7b 20 7d 7d 7d 7d     . N4:  {{{{ }}}}
    1ce9:	20 7b 7b 7b 7b 00 b5 1a 99 1b 00 00 20 4e 35 3a      {{{{....... N5:
    1cf9:	20 20 7b 7b 7b 7b 20 7d 7d 7d 7d 20 7b 7b 7b 7b       {{{{ }}}} {{{{
    1d09:	00 c1 1a a9 1b 00 00 20 4e 36 3a 20 20 7b 7b 7b     ....... N6:  {{{
    1d19:	7b 20 7d 7d 7d 7d 20 7b 7b 7b 7b 00 cd 1a b9 1b     { }}}} {{{{.....
    1d29:	00 00 20 4e 37 3a 20 20 7b 7b 7b 7b 20 7d 7d 7d     .. N7:  {{{{ }}}
    1d39:	7d 20 7b 7b 7b 7b 00 d9 1a c9 1b 00 00 20 4e 38     } {{{{....... N8
    1d49:	3a 20 20 7b 7b 7b 7b 20 7d 7d 7d 7d 20 7b 7b 7b     :  {{{{ }}}} {{{
    1d59:	7b 00 e5 1a d9 1b 00 00 20 4e 39 3a 20 20 7b 7b     {....... N9:  {{
    1d69:	7b 7b 20 7d 7d 7d 7d 20 7b 7b 7b 7b 00 f1 1a e9     {{ }}}} {{{{....
    1d79:	1b 00 00 20 4e 31 30 3a 20 7b 7b 7b 7b 20 7d 7d     ... N10: {{{{ }}
    1d89:	7d 7d 20 7b 7b 7b 7b 00 fd 1a f9 1b 00 00 20 4e     }} {{{{....... N
    1d99:	31 31 3a 20 7b 7b 7b 7b 20 7d 7d 7d 7d 20 7b 7b     11: {{{{ }}}} {{
    1da9:	7b 7b 00 09 1b 09 1c 00 00 20 4e 31 32 3a 20 7b     {{....... N12: {
    1db9:	7b 7b 7b 20 7d 7d 7d 7d 20 7b 7b 7b 7b 00 15 1b     {{{ }}}} {{{{...
    1dc9:	19 1c 00 00 20 4e 31 33 3a 20 7b 7b 7b 7b 20 7d     .... N13: {{{{ }
    1dd9:	7d 7d 7d 20 7b 7b 7b 7b 00 21 1b 29 1c 00 00 20     }}} {{{{.!.)... 
    1de9:	4e 31 34 3a 20 7b 7b 7b 7b 20 7d 7d 7d 7d 20 7b     N14: {{{{ }}}} {
    1df9:	7b 7b 7b 00 2d 1b 39 1c 00 00 20 4e 31 35 3a 20     {{{.-.9... N15: 
    1e09:	7b 7b 7b 7b 20 7d 7d 7d 7d 20 7b 7b 7b 7b 00 39     {{{{ }}}} {{{{.9
    1e19:	1b 49 1c 00 00 20 4e 31 36 3a 20 7b 7b 7b 7b 20     .I... N16: {{{{ 
    1e29:	7d 7d 7d 7d 20 7b 7b 7b 7b 00 45 1b 59 1c 00 00     }}}} {{{{.E.Y...
    1e39:	20 4e 31 37 3a 20 7b 7b 7b 7b 20 7d 7d 7d 7d 20      N17: {{{{ }}}} 
    1e49:	7b 7b 7b 7b 00 51 1b 69 1c 00 00 20 4e 31 38 3a     {{{{.Q.i... N18:
    1e59:	20 7b 7b 7b 7b 20 7d 7d 7d 7d 20 7b 7b 7b 7b 00      {{{{ }}}} {{{{.
    1e69:	5d 1b 79 1c 00 00                                   ].y...

00001e6f <MenuDI>:
    1e6f:	89 1c 12 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1e7f:	00 00 00 00                                         ....

00001e83 <F_DO1>:
    1e83:	1f df 07 00 00 00 00 00 00 00 00 00 00 37 07 00     .............7..

00001e93 <F_DO2>:
    1e93:	1f df 07 00 00 00 00 00 00 00 00 00 00 37 07 01     .............7..

00001ea3 <F_DO3>:
    1ea3:	1f df 07 00 00 00 00 00 00 00 00 00 00 37 07 02     .............7..

00001eb3 <F_DO4>:
    1eb3:	1f df 07 00 00 00 00 00 00 00 00 00 00 37 07 03     .............7..

00001ec3 <F_DO5>:
    1ec3:	1f df 07 00 00 00 00 00 00 00 00 00 00 37 07 04     .............7..

00001ed3 <F_DO6>:
    1ed3:	1f df 07 00 00 00 00 00 00 00 00 00 00 37 07 05     .............7..

00001ee3 <F_DO7>:
    1ee3:	1f df 07 00 00 00 00 00 00 00 00 00 00 37 07 06     .............7..

00001ef3 <F_DO8>:
    1ef3:	1f df 07 00 00 00 00 00 00 00 00 00 00 37 07 07     .............7..

00001f03 <F_DO9>:
    1f03:	1f df 07 00 00 00 00 00 00 00 00 00 00 37 07 08     .............7..

00001f13 <F_DO10>:
    1f13:	1f df 07 00 00 00 00 00 00 00 00 00 00 37 07 09     .............7..

00001f23 <F_DO11>:
    1f23:	1f df 07 00 00 00 00 00 00 00 00 00 00 37 07 0a     .............7..

00001f33 <F_DO12>:
    1f33:	1f df 07 00 00 00 00 00 00 00 00 00 00 37 07 0b     .............7..

00001f43 <F_DO13>:
    1f43:	1f df 07 00 00 00 00 00 00 00 00 00 00 37 07 0c     .............7..

00001f53 <F_DO14>:
    1f53:	1f df 07 00 00 00 00 00 00 00 00 00 00 37 07 0d     .............7..

00001f63 <F_DO15>:
    1f63:	1f df 07 00 00 00 00 00 00 00 00 00 00 37 07 0e     .............7..

00001f73 <F_DO16>:
    1f73:	1f df 07 00 00 00 00 00 00 00 00 00 00 37 07 0f     .............7..

00001f83 <ListDO>:
    1f83:	20 c2 fb f5 ee e4 20 4e 31 3a 20 20 20 20 20 7d      ..... N1:     }
    1f93:	7d 7d 7d 20 00 00 00 83 1e 00 00 20 c2 fb f5 ee     }}} ....... ....
    1fa3:	e4 20 4e 32 3a 20 20 20 20 20 7d 7d 7d 7d 20 00     . N2:     }}}} .
    1fb3:	00 00 93 1e 00 00 20 c2 fb f5 ee e4 20 4e 33 3a     ...... ..... N3:
    1fc3:	20 20 20 20 20 7d 7d 7d 7d 20 00 00 00 a3 1e 00          }}}} ......
    1fd3:	00 20 c2 fb f5 ee e4 20 4e 34 3a 20 20 20 20 20     . ..... N4:     
    1fe3:	7d 7d 7d 7d 20 00 00 00 b3 1e 00 00 20 c2 fb f5     }}}} ....... ...
    1ff3:	ee e4 20 4e 35 3a 20 20 20 20 20 7d 7d 7d 7d 20     .. N5:     }}}} 
    2003:	00 00 00 c3 1e 00 00 20 c2 fb f5 ee e4 20 4e 36     ....... ..... N6
    2013:	3a 20 20 20 20 20 7d 7d 7d 7d 20 00 00 00 d3 1e     :     }}}} .....
    2023:	00 00 20 c2 fb f5 ee e4 20 4e 37 3a 20 20 20 20     .. ..... N7:    
    2033:	20 7d 7d 7d 7d 20 00 00 00 e3 1e 00 00 20 c2 fb      }}}} ....... ..
    2043:	f5 ee e4 20 4e 38 3a 20 20 20 20 20 7d 7d 7d 7d     ... N8:     }}}}
    2053:	20 00 00 00 f3 1e 00 00 20 c2 fb f5 ee e4 20 4e      ....... ..... N
    2063:	39 3a 20 20 20 20 20 7d 7d 7d 7d 20 00 00 00 03     9:     }}}} ....
    2073:	1f 00 00 20 c2 fb f5 ee e4 20 4e 31 30 3a 20 20     ... ..... N10:  
    2083:	20 20 7d 7d 7d 7d 20 00 00 00 13 1f 00 00 20 c2       }}}} ....... .
    2093:	fb f5 ee e4 20 4e 31 31 3a 20 20 20 20 7d 7d 7d     .... N11:    }}}
    20a3:	7d 20 00 00 00 23 1f 00 00 20 c2 fb f5 ee e4 20     } ...#... ..... 
    20b3:	4e 31 32 3a 20 20 20 20 7d 7d 7d 7d 20 00 00 00     N12:    }}}} ...
    20c3:	33 1f 00 00 20 c2 fb f5 ee e4 20 4e 31 33 3a 20     3... ..... N13: 
    20d3:	20 20 20 7d 7d 7d 7d 20 00 00 00 43 1f 00 00 20        }}}} ...C... 
    20e3:	c2 fb f5 ee e4 20 4e 31 34 3a 20 20 20 20 7d 7d     ..... N14:    }}
    20f3:	7d 7d 20 00 00 00 53 1f 00 00 20 c2 fb f5 ee e4     }} ...S... .....
    2103:	20 4e 31 35 3a 20 20 20 20 7d 7d 7d 7d 20 00 00      N15:    }}}} ..
    2113:	00 63 1f 00 00 20 c2 fb f5 ee e4 20 4e 31 36 3a     .c... ..... N16:
    2123:	20 20 20 20 7d 7d 7d 7d 20 00 00 00 73 1f 00 00         }}}} ...s...

00002133 <MenuDO>:
    2133:	83 1f 10 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2143:	00 00 00 00                                         ....

00002147 <F_AI12>:
    2147:	0b 4e 0b 00 00 00 0b 50 0b 00 00 00                 .N.....P....

00002153 <F_AI34>:
    2153:	0b 52 0b 00 00 00 0b 54 0b 00 00 00                 .R.....T....

0000215f <F_AI56>:
    215f:	0b 56 0b 00 00 00 0b 58 0b 00 00 00                 .V.....X....

0000216b <F_AI78>:
    216b:	0b 5a 0b 00 00 00 0b 5c 0b 00 00 00                 .Z.....\....

00002177 <ListAI>:
    2177:	20 4e 31 3a 20 7b 7b 7b 7b 7b 20 4e 32 3a 20 7b      N1: {{{{{ N2: {
    2187:	7b 7b 7b 7b 00 47 21 00 00 00 00 20 4e 33 3a 20     {{{{.G!.... N3: 
    2197:	7b 7b 7b 7b 7b 20 4e 34 3a 20 7b 7b 7b 7b 7b 00     {{{{{ N4: {{{{{.
    21a7:	53 21 00 00 00 00 20 4e 35 3a 20 7b 7b 7b 7b 7b     S!.... N5: {{{{{
    21b7:	20 4e 36 3a 20 7b 7b 7b 7b 7b 00 5f 21 00 00 00      N6: {{{{{._!...
    21c7:	00 20 4e 37 3a 20 7b 7b 7b 7b 7b 20 4e 38 3a 20     . N7: {{{{{ N8: 
    21d7:	7b 7b 7b 7b 7b 00 6b 21 00 00 00 00                 {{{{{.k!....

000021e3 <MenuAI>:
    21e3:	77 21 04 03 00 00 00 00 00 00 00 00 00 00 00 00     w!..............
    21f3:	00 00 00 00                                         ....

000021f7 <F_AO1>:
    21f7:	0e d2 07 00 00 00 00 ff 03 00 00 00 00 00 00 00     ................

00002207 <F_AO2>:
    2207:	0e d4 07 00 00 00 00 ff 03 00 00 00 00 00 00 00     ................

00002217 <F_AO3>:
    2217:	0e d6 07 00 00 00 00 ff 03 00 00 00 00 00 00 00     ................

00002227 <F_AO4>:
    2227:	0e d8 07 00 00 00 00 ff 03 00 00 00 00 00 00 00     ................

00002237 <ListAO>:
    2237:	20 c2 fb f5 ee e4 20 4e 31 3a 20 20 20 20 20 7d      ..... N1:     }
    2247:	7d 7d 7d 7d 00 00 00 f7 21 00 00 20 c2 fb f5 ee     }}}}....!.. ....
    2257:	e4 20 4e 32 3a 20 20 20 20 20 7d 7d 7d 7d 7d 00     . N2:     }}}}}.
    2267:	00 00 07 22 00 00 20 c2 fb f5 ee e4 20 4e 33 3a     ...".. ..... N3:
    2277:	20 20 20 20 20 7d 7d 7d 7d 7d 00 00 00 17 22 00          }}}}}....".
    2287:	00 20 c2 fb f5 ee e4 20 4e 34 3a 20 20 20 20 20     . ..... N4:     
    2297:	7d 7d 7d 7d 7d 00 00 00 27 22 00 00                 }}}}}...'"..

000022a3 <MenuAO>:
    22a3:	37 22 04 00 00 00 00 00 00 00 00 00 00 00 00 00     7"..............
    22b3:	00 00 00 00                                         ....

000022b7 <F_ADC12>:
    22b7:	07 1b 09 00 00 00 07 1d 09 00 00 00                 ............

000022c3 <F_ADC34>:
    22c3:	07 1f 09 00 00 00 07 21 09 00 00 00                 .......!....

000022cf <F_ADC56>:
    22cf:	07 23 09 00 00 00 07 25 09 00 00 00                 .#.....%....

000022db <F_ADC_Ref>:
    22db:	07 27 09 00 00 00                                   .'....

000022e1 <List_ADC_Chan>:
    22e1:	20 2d 2d 2d 20 ca e0 ed e0 eb fb 20 c0 d6 cf 20      --- ...... ... 
    22f1:	2d 2d 2d 20 00 00 00 00 00 00 00 20 4e 31 3a 20     --- ....... N1: 
    2301:	7b 7b 7b 7b 7b 20 4e 32 3a 20 7b 7b 7b 7b 7b 00     {{{{{ N2: {{{{{.
    2311:	b7 22 00 00 00 00 20 4e 33 3a 20 7b 7b 7b 7b 7b     .".... N3: {{{{{
    2321:	20 4e 34 3a 20 7b 7b 7b 7b 7b 00 c3 22 00 00 00      N4: {{{{{.."...
    2331:	00 20 4e 35 3a 20 7b 7b 7b 7b 7b 20 4e 36 3a 20     . N5: {{{{{ N6: 
    2341:	7b 7b 7b 7b 7b 00 cf 22 00 00 00 00 20 ce ef ee     {{{{{..".... ...
    2351:	f0 ed 2e 20 ea e0 ed e0 eb 3a 20 7b 7b 7b 7b 7b     ... .....: {{{{{
    2361:	00 db 22 00 00 00 00                                .."....

00002368 <Menu_ADC_Ch>:
    2368:	e1 22 05 01 00 00 00 00 00 00 00 00 00 00 00 00     ."..............
    2378:	00 00 00 00                                         ....

0000237c <F_ADC_Zero>:
    237c:	00 6f 0c 00 00 00 04 6e 0c 00 00 00 04 6d 0c 00     .o.....n.....m..
	...

0000238e <F_ADC_Full>:
    238e:	00 72 0c 00 00 00 04 71 0c 00 00 00 04 70 0c 00     .r.....q.....p..
	...

000023a0 <List_ADC_Cali>:
    23a0:	20 2d 2d 2d 20 ca e0 eb e8 e1 f0 ee e2 ea e0 20      --- .......... 
    23b0:	2d 2d 2d 20 00 00 00 00 00 00 00 20 5a 65 72 6f     --- ....... Zero
    23c0:	3a 20 20 7b 7b 7b 20 7b 7b 7b 20 7b 7b 7b 20 00     :  {{{ {{{ {{{ .
    23d0:	7c 23 00 00 00 00 20 46 75 6c 6c 3a 20 20 7b 7b     |#.... Full:  {{
    23e0:	7b 20 7b 7b 7b 20 7b 7b 7b 20 00 8e 23 00 00 00     { {{{ {{{ ..#...
    23f0:	00 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20     .               
    2400:	20 20 20 20 20 00 00 00 00 00 00 00                      .......

0000240c <Menu_ADC_Cali>:
    240c:	a0 23 04 03 00 00 00 00 00 00 00 00 00 00 00 00     .#..............
    241c:	00 00 00 00                                         ....

00002420 <ADC_Rt_Str>:
    2420:	52 65 73 65 74 00                                   Reset.

00002426 <ADC_I1_Str>:
    2426:	49 6e 69 74 69 61 6c 69 73 61 74 00                 Initialisat.

00002432 <ADC_C1_Str>:
    2432:	43 61 6c 69 62 72 61 74 69 6f 6e 00                 Calibration.

0000243e <ADC_Re_Str>:
    243e:	52 65 61 64 00                                      Read.

00002443 <ADC_Of_Str>:
    2443:	4f 66 66 00                                         Off.

00002447 <ADC_Tbl>:
    2447:	20 24 26 24 32 24 3e 24 43 24                        $&$2$>$C$

00002451 <F_Therm1>:
    2451:	09 45 06 ec 08 01                                   .E....

00002457 <F_Therm2>:
    2457:	09 47 06 ec 08 01                                   .G....

0000245d <F_Therm3>:
    245d:	09 49 06 ec 08 01                                   .I....

00002463 <F_Therm4>:
    2463:	09 4b 06 ec 08 01                                   .K....

00002469 <F_Therm5>:
    2469:	09 4d 06 ec 08 01                                   .M....

0000246f <F_Therm6>:
    246f:	09 4f 06 ec 08 01                                   .O....

00002475 <F_Thermis1>:
    2475:	1e 17 01 00 00 00 00 07 00 00 00 00 00 20 09 00     ............. ..

00002485 <F_Thermis2>:
    2485:	1e 18 01 00 00 00 00 07 00 00 00 00 00 20 09 00     ............. ..

00002495 <F_Thermis3>:
    2495:	1e 19 01 00 00 00 00 07 00 00 00 00 00 20 09 00     ............. ..

000024a5 <F_Thermis4>:
    24a5:	1e 1a 01 00 00 00 00 07 00 00 00 00 00 20 09 00     ............. ..

000024b5 <F_Thermis5>:
    24b5:	1e 1b 01 00 00 00 00 07 00 00 00 00 00 20 09 00     ............. ..

000024c5 <F_Thermis6>:
    24c5:	1e 1c 01 00 00 00 00 07 00 00 00 00 00 20 09 00     ............. ..

000024d5 <F_ThermisD1>:
    24d5:	03 1d 01 80 ff ff ff 7f 00 00 00 00 00 00 00 01     ................

000024e5 <F_ThermisD2>:
    24e5:	03 20 01 80 ff ff ff 7f 00 00 00 00 00 00 00 01     . ..............

000024f5 <F_ThermisD3>:
    24f5:	03 23 01 80 ff ff ff 7f 00 00 00 00 00 00 00 01     .#..............

00002505 <F_ThermisD4>:
    2505:	03 26 01 80 ff ff ff 7f 00 00 00 00 00 00 00 01     .&..............

00002515 <F_ThermisD5>:
    2515:	03 29 01 80 ff ff ff 7f 00 00 00 00 00 00 00 01     .)..............

00002525 <F_ThermisD6>:
    2525:	03 2c 01 80 ff ff ff 7f 00 00 00 00 00 00 00 01     .,..............

00002535 <F_ThermisA1>:
    2535:	08 1e 01 84 03 00 00 4c 04 00 00 00 00 00 00 03     .......L........

00002545 <F_ThermisA2>:
    2545:	08 21 01 84 03 00 00 4c 04 00 00 00 00 00 00 03     .!.....L........

00002555 <F_ThermisA3>:
    2555:	08 24 01 84 03 00 00 4c 04 00 00 00 00 00 00 03     .$.....L........

00002565 <F_ThermisA4>:
    2565:	08 27 01 84 03 00 00 4c 04 00 00 00 00 00 00 03     .'.....L........

00002575 <F_ThermisA5>:
    2575:	08 2a 01 84 03 00 00 4c 04 00 00 00 00 00 00 03     .*.....L........

00002585 <F_ThermisA6>:
    2585:	08 2d 01 84 03 00 00 4c 04 00 00 00 00 00 00 03     .-.....L........

00002595 <ListTherm1>:
    2595:	20 ca e0 ed e0 eb 20 4e 31 3a 20 7b 7b 7b 7b 7b      ..... N1: {{{{{
    25a5:	7b 7b 7c 43 00 51 24 00 00 00 00 20 d2 e5 f0 ec     {{|C.Q$.... ....
    25b5:	ee e4 e0 f2 f7 e8 ea 3a 20 7d 7d 7d 7d 7d 7d 00     .......: }}}}}}.
    25c5:	00 00 75 24 00 00 20 d1 e4 e2 e8 e3 3a 20 20 20     ..u$.. .....:   
    25d5:	20 20 20 7d 7d 7d 7d 7d 7c 43 00 00 00 d5 24 00        }}}}}|C....$.
    25e5:	00 20 ca ee fd f4 f4 e8 f6 e8 e5 ed f2 3a 20 20     . ...........:  
    25f5:	7d 7d 7d 7d 7d 00 00 00 35 25 00 00                 }}}}}...5%..

00002601 <MenuTherm1>:
    2601:	95 25 04 01 00 00 00 00 00 00 00 00 00 00 00 00     .%..............
    2611:	00 00 00 00                                         ....

00002615 <ListTherm2>:
    2615:	20 ca e0 ed e0 eb 20 4e 32 3a 20 7b 7b 7b 7b 7b      ..... N2: {{{{{
    2625:	7b 7b 7c 43 00 57 24 00 00 00 00 20 d2 e5 f0 ec     {{|C.W$.... ....
    2635:	ee e4 e0 f2 f7 e8 ea 3a 20 7d 7d 7d 7d 7d 7d 00     .......: }}}}}}.
    2645:	00 00 85 24 00 00 20 d1 e4 e2 e8 e3 3a 20 20 20     ...$.. .....:   
    2655:	20 20 20 7d 7d 7d 7d 7d 7c 43 00 00 00 e5 24 00        }}}}}|C....$.
    2665:	00 20 ca ee fd f4 f4 e8 f6 e8 e5 ed f2 3a 20 20     . ...........:  
    2675:	7d 7d 7d 7d 7d 00 00 00 45 25 00 00                 }}}}}...E%..

00002681 <MenuTherm2>:
    2681:	15 26 04 01 00 00 00 00 00 00 00 00 00 00 00 00     .&..............
    2691:	00 00 00 00                                         ....

00002695 <ListTherm3>:
    2695:	20 ca e0 ed e0 eb 20 4e 33 3a 20 7b 7b 7b 7b 7b      ..... N3: {{{{{
    26a5:	7b 7b 7c 43 00 5d 24 00 00 00 00 20 d2 e5 f0 ec     {{|C.]$.... ....
    26b5:	ee e4 e0 f2 f7 e8 ea 3a 20 7d 7d 7d 7d 7d 7d 00     .......: }}}}}}.
    26c5:	00 00 95 24 00 00 20 d1 e4 e2 e8 e3 3a 20 20 20     ...$.. .....:   
    26d5:	20 20 20 7d 7d 7d 7d 7d 7c 43 00 00 00 f5 24 00        }}}}}|C....$.
    26e5:	00 20 ca ee fd f4 f4 e8 f6 e8 e5 ed f2 3a 20 20     . ...........:  
    26f5:	7d 7d 7d 7d 7d 00 00 00 55 25 00 00                 }}}}}...U%..

00002701 <MenuTherm3>:
    2701:	95 26 04 01 00 00 00 00 00 00 00 00 00 00 00 00     .&..............
    2711:	00 00 00 00                                         ....

00002715 <ListTherm4>:
    2715:	20 ca e0 ed e0 eb 20 4e 34 3a 20 7b 7b 7b 7b 7b      ..... N4: {{{{{
    2725:	7b 7b 7c 43 00 63 24 00 00 00 00 20 d2 e5 f0 ec     {{|C.c$.... ....
    2735:	ee e4 e0 f2 f7 e8 ea 3a 20 7d 7d 7d 7d 7d 7d 00     .......: }}}}}}.
    2745:	00 00 a5 24 00 00 20 d1 e4 e2 e8 e3 3a 20 20 20     ...$.. .....:   
    2755:	20 20 20 7d 7d 7d 7d 7d 7c 43 00 00 00 05 25 00        }}}}}|C....%.
    2765:	00 20 ca ee fd f4 f4 e8 f6 e8 e5 ed f2 3a 20 20     . ...........:  
    2775:	7d 7d 7d 7d 7d 00 00 00 65 25 00 00                 }}}}}...e%..

00002781 <MenuTherm4>:
    2781:	15 27 04 01 00 00 00 00 00 00 00 00 00 00 00 00     .'..............
    2791:	00 00 00 00                                         ....

00002795 <ListTherm5>:
    2795:	20 ca e0 ed e0 eb 20 4e 35 3a 20 7b 7b 7b 7b 7b      ..... N5: {{{{{
    27a5:	7b 7b 7c 43 00 69 24 00 00 00 00 20 d2 e5 f0 ec     {{|C.i$.... ....
    27b5:	ee e4 e0 f2 f7 e8 ea 3a 20 7d 7d 7d 7d 7d 7d 00     .......: }}}}}}.
    27c5:	00 00 b5 24 00 00 20 d1 e4 e2 e8 e3 3a 20 20 20     ...$.. .....:   
    27d5:	20 20 20 7d 7d 7d 7d 7d 7c 43 00 00 00 15 25 00        }}}}}|C....%.
    27e5:	00 20 ca ee fd f4 f4 e8 f6 e8 e5 ed f2 3a 20 20     . ...........:  
    27f5:	7d 7d 7d 7d 7d 00 00 00 75 25 00 00                 }}}}}...u%..

00002801 <MenuTherm5>:
    2801:	95 27 04 01 00 00 00 00 00 00 00 00 00 00 00 00     .'..............
    2811:	00 00 00 00                                         ....

00002815 <ListTherm6>:
    2815:	20 ca e0 ed e0 eb 20 4e 36 3a 20 7b 7b 7b 7b 7b      ..... N6: {{{{{
    2825:	7b 7b 7c 43 00 6f 24 00 00 00 00 20 d2 e5 f0 ec     {{|C.o$.... ....
    2835:	ee e4 e0 f2 f7 e8 ea 3a 20 7d 7d 7d 7d 7d 7d 00     .......: }}}}}}.
    2845:	00 00 c5 24 00 00 20 d1 e4 e2 e8 e3 3a 20 20 20     ...$.. .....:   
    2855:	20 20 20 7d 7d 7d 7d 7d 7c 43 00 00 00 25 25 00        }}}}}|C...%%.
    2865:	00 20 ca ee fd f4 f4 e8 f6 e8 e5 ed f2 3a 20 20     . ...........:  
    2875:	7d 7d 7d 7d 7d 00 00 00 85 25 00 00                 }}}}}....%..

00002881 <MenuTherm6>:
    2881:	15 28 04 01 00 00 00 00 00 00 00 00 00 00 00 00     .(..............
    2891:	00 00 00 00                                         ....

00002895 <List_Therm>:
    2895:	20 ca e0 ed e0 eb 20 4e 31 3a 20 7b 7b 7b 7b 7b      ..... N1: {{{{{
    28a5:	7b 7b 7c 43 00 51 24 00 00 01 26 20 ca e0 ed e0     {{|C.Q$...& ....
    28b5:	eb 20 4e 32 3a 20 7b 7b 7b 7b 7b 7b 7b 7c 43 00     . N2: {{{{{{{|C.
    28c5:	57 24 00 00 81 26 20 ca e0 ed e0 eb 20 4e 33 3a     W$...& ..... N3:
    28d5:	20 7b 7b 7b 7b 7b 7b 7b 7c 43 00 5d 24 00 00 01      {{{{{{{|C.]$...
    28e5:	27 20 ca e0 ed e0 eb 20 4e 34 3a 20 7b 7b 7b 7b     ' ..... N4: {{{{
    28f5:	7b 7b 7b 7c 43 00 63 24 00 00 81 27 20 ca e0 ed     {{{|C.c$...' ...
    2905:	e0 eb 20 4e 35 3a 20 7b 7b 7b 7b 7b 7b 7b 7c 43     .. N5: {{{{{{{|C
    2915:	00 69 24 00 00 01 28 20 ca e0 ed e0 eb 20 4e 36     .i$...( ..... N6
    2925:	3a 20 7b 7b 7b 7b 7b 7b 7b 7c 43 00 6f 24 00 00     : {{{{{{{|C.o$..
    2935:	81 28                                               .(

00002937 <MenuTherm>:
    2937:	95 28 06 00 00 00 00 00 00 00 00 00 00 00 00 00     .(..............
    2947:	00 00 00 00                                         ....

0000294b <MB_Master_List>:
    294b:	00 00 00                                            ...

0000294e <Channel0_Name_InField>:
    294e:	00 b6 06 00 00 00                                   ......

00002954 <Channel0_DI_State_InField>:
    2954:	00 b7 06 00 00 00                                   ......

0000295a <Channel0_Alarm_State_InField>:
    295a:	00 b8 06 00 00 00                                   ......

00002960 <Channel0_debounceTimeout_OutField>:
    2960:	08 31 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .1..............

00002970 <Channel0_calling_delay_OutField>:
    2970:	08 51 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .Q..............

00002980 <Channel0_calling_retry_delay_OutField>:
    2980:	08 71 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .q..............

00002990 <Channel0>:
    2990:	20 cd ee ec e5 f0 20 ea e0 ed e0 eb e0 20 20 20      ..... ......   
    29a0:	20 7b 7b 7b 00 4e 29 00 00 00 00 20 d1 ee f1 f2      {{{.N).... ....
    29b0:	ee ff ed e8 e5 20 e2 f5 ee e4 e0 20 7b 7b 7b 00     ..... ..... {{{.
    29c0:	54 29 00 00 00 00 20 d1 ee f1 f2 ee ff ed e8 e5     T).... .........
    29d0:	20 ea e0 ed e0 eb e0 7b 7b 7b 00 5a 29 00 00 00      ......{{{.Z)...
    29e0:	00 20 d2 e0 ed f2 e8 e4 f0 e5 e1 e5 e7 e3 20 20     . ............  
    29f0:	7d 7d 7d 7d 7d 00 00 00 60 29 00 00 20 d2 e4 ee     }}}}}...`).. ...
    2a00:	e7 e2 ee ed e0 20 20 20 20 20 20 7d 7d 7d 7d 7d     .....      }}}}}
    2a10:	00 00 00 70 29 00 00 20 d2 ef ee e2 f2 2e e4 ee     ...p).. ........
    2a20:	e7 e2 ee ed e0 20 7d 7d 7d 7d 7d 00 00 00 80 29     ..... }}}}}....)
	...

00002a32 <Channel0_Page>:
    2a32:	90 29 06 00 00 00 00 00 00 00 00 00 00 00 00 00     .)..............
    2a42:	00 00 00 00                                         ....

00002a46 <Channel1_Name_InField>:
    2a46:	00 ba 06 00 00 00                                   ......

00002a4c <Channel1_DI_State_InField>:
    2a4c:	00 bb 06 00 00 00                                   ......

00002a52 <Channel1_Alarm_State_InField>:
    2a52:	00 bc 06 00 00 00                                   ......

00002a58 <Channel1_debounceTimeout_OutField>:
    2a58:	08 33 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .3..............

00002a68 <Channel1_calling_delay_OutField>:
    2a68:	08 53 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .S..............

00002a78 <Channel1_calling_retry_delay_OutField>:
    2a78:	08 73 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .s..............

00002a88 <Channel1>:
    2a88:	20 cd ee ec e5 f0 20 ea e0 ed e0 eb e0 20 20 20      ..... ......   
    2a98:	20 7b 7b 7b 00 46 2a 00 00 00 00 20 d1 ee f1 f2      {{{.F*.... ....
    2aa8:	ee ff ed e8 e5 20 e2 f5 ee e4 e0 20 7b 7b 7b 00     ..... ..... {{{.
    2ab8:	4c 2a 00 00 00 00 20 d1 ee f1 f2 ee ff ed e8 e5     L*.... .........
    2ac8:	20 ea e0 ed e0 eb e0 7b 7b 7b 00 52 2a 00 00 00      ......{{{.R*...
    2ad8:	00 20 d2 e0 ed f2 e8 e4 f0 e5 e1 e5 e7 e3 20 20     . ............  
    2ae8:	7d 7d 7d 7d 7d 00 00 00 58 2a 00 00 20 d2 e4 ee     }}}}}...X*.. ...
    2af8:	e7 e2 ee ed e0 20 20 20 20 20 20 7d 7d 7d 7d 7d     .....      }}}}}
    2b08:	00 00 00 68 2a 00 00 20 d2 ef ee e2 f2 2e e4 ee     ...h*.. ........
    2b18:	e7 e2 ee ed e0 20 7d 7d 7d 7d 7d 00 00 00 78 2a     ..... }}}}}...x*
	...

00002b2a <Channel1_Page>:
    2b2a:	88 2a 06 00 00 00 00 00 00 00 00 00 00 00 00 00     .*..............
    2b3a:	00 00 00 00                                         ....

00002b3e <Channel2_Name_InField>:
    2b3e:	00 be 06 00 00 00                                   ......

00002b44 <Channel2_DI_State_InField>:
    2b44:	00 bf 06 00 00 00                                   ......

00002b4a <Channel2_Alarm_State_InField>:
    2b4a:	00 c0 06 00 00 00                                   ......

00002b50 <Channel2_debounceTimeout_OutField>:
    2b50:	08 35 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .5..............

00002b60 <Channel2_calling_delay_OutField>:
    2b60:	08 55 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .U..............

00002b70 <Channel2_calling_retry_delay_OutField>:
    2b70:	08 75 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .u..............

00002b80 <Channel2>:
    2b80:	20 cd ee ec e5 f0 20 ea e0 ed e0 eb e0 20 20 20      ..... ......   
    2b90:	20 7b 7b 7b 00 3e 2b 00 00 00 00 20 d1 ee f1 f2      {{{.>+.... ....
    2ba0:	ee ff ed e8 e5 20 e2 f5 ee e4 e0 20 7b 7b 7b 00     ..... ..... {{{.
    2bb0:	44 2b 00 00 00 00 20 d1 ee f1 f2 ee ff ed e8 e5     D+.... .........
    2bc0:	20 ea e0 ed e0 eb e0 7b 7b 7b 00 4a 2b 00 00 00      ......{{{.J+...
    2bd0:	00 20 d2 e0 ed f2 e8 e4 f0 e5 e1 e5 e7 e3 20 20     . ............  
    2be0:	7d 7d 7d 7d 7d 00 00 00 50 2b 00 00 20 d2 e4 ee     }}}}}...P+.. ...
    2bf0:	e7 e2 ee ed e0 20 20 20 20 20 20 7d 7d 7d 7d 7d     .....      }}}}}
    2c00:	00 00 00 60 2b 00 00 20 d2 ef ee e2 f2 2e e4 ee     ...`+.. ........
    2c10:	e7 e2 ee ed e0 20 7d 7d 7d 7d 7d 00 00 00 70 2b     ..... }}}}}...p+
	...

00002c22 <Channel2_Page>:
    2c22:	80 2b 06 00 00 00 00 00 00 00 00 00 00 00 00 00     .+..............
    2c32:	00 00 00 00                                         ....

00002c36 <Channel3_Name_InField>:
    2c36:	00 c2 06 00 00 00                                   ......

00002c3c <Channel3_DI_State_InField>:
    2c3c:	00 c3 06 00 00 00                                   ......

00002c42 <Channel3_Alarm_State_InField>:
    2c42:	00 c4 06 00 00 00                                   ......

00002c48 <Channel3_debounceTimeout_OutField>:
    2c48:	08 37 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .7..............

00002c58 <Channel3_calling_delay_OutField>:
    2c58:	08 57 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .W..............

00002c68 <Channel3_calling_retry_delay_OutField>:
    2c68:	08 77 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .w..............

00002c78 <Channel3>:
    2c78:	20 cd ee ec e5 f0 20 ea e0 ed e0 eb e0 20 20 20      ..... ......   
    2c88:	20 7b 7b 7b 00 36 2c 00 00 00 00 20 d1 ee f1 f2      {{{.6,.... ....
    2c98:	ee ff ed e8 e5 20 e2 f5 ee e4 e0 20 7b 7b 7b 00     ..... ..... {{{.
    2ca8:	3c 2c 00 00 00 00 20 d1 ee f1 f2 ee ff ed e8 e5     <,.... .........
    2cb8:	20 ea e0 ed e0 eb e0 7b 7b 7b 00 42 2c 00 00 00      ......{{{.B,...
    2cc8:	00 20 d2 e0 ed f2 e8 e4 f0 e5 e1 e5 e7 e3 20 20     . ............  
    2cd8:	7d 7d 7d 7d 7d 00 00 00 48 2c 00 00 20 d2 e4 ee     }}}}}...H,.. ...
    2ce8:	e7 e2 ee ed e0 20 20 20 20 20 20 7d 7d 7d 7d 7d     .....      }}}}}
    2cf8:	00 00 00 58 2c 00 00 20 d2 ef ee e2 f2 2e e4 ee     ...X,.. ........
    2d08:	e7 e2 ee ed e0 20 7d 7d 7d 7d 7d 00 00 00 68 2c     ..... }}}}}...h,
	...

00002d1a <Channel3_Page>:
    2d1a:	78 2c 06 00 00 00 00 00 00 00 00 00 00 00 00 00     x,..............
    2d2a:	00 00 00 00                                         ....

00002d2e <Channel4_Name_InField>:
    2d2e:	00 c6 06 00 00 00                                   ......

00002d34 <Channel4_DI_State_InField>:
    2d34:	00 c7 06 00 00 00                                   ......

00002d3a <Channel4_Alarm_State_InField>:
    2d3a:	00 c8 06 00 00 00                                   ......

00002d40 <Channel4_debounceTimeout_OutField>:
    2d40:	08 39 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .9..............

00002d50 <Channel4_calling_delay_OutField>:
    2d50:	08 59 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .Y..............

00002d60 <Channel4_calling_retry_delay_OutField>:
    2d60:	08 79 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .y..............

00002d70 <Channel4>:
    2d70:	20 cd ee ec e5 f0 20 ea e0 ed e0 eb e0 20 20 20      ..... ......   
    2d80:	20 7b 7b 7b 00 2e 2d 00 00 00 00 20 d1 ee f1 f2      {{{..-.... ....
    2d90:	ee ff ed e8 e5 20 e2 f5 ee e4 e0 20 7b 7b 7b 00     ..... ..... {{{.
    2da0:	34 2d 00 00 00 00 20 d1 ee f1 f2 ee ff ed e8 e5     4-.... .........
    2db0:	20 ea e0 ed e0 eb e0 7b 7b 7b 00 3a 2d 00 00 00      ......{{{.:-...
    2dc0:	00 20 d2 e0 ed f2 e8 e4 f0 e5 e1 e5 e7 e3 20 20     . ............  
    2dd0:	7d 7d 7d 7d 7d 00 00 00 40 2d 00 00 20 d2 e4 ee     }}}}}...@-.. ...
    2de0:	e7 e2 ee ed e0 20 20 20 20 20 20 7d 7d 7d 7d 7d     .....      }}}}}
    2df0:	00 00 00 50 2d 00 00 20 d2 ef ee e2 f2 2e e4 ee     ...P-.. ........
    2e00:	e7 e2 ee ed e0 20 7d 7d 7d 7d 7d 00 00 00 60 2d     ..... }}}}}...`-
	...

00002e12 <Channel4_Page>:
    2e12:	70 2d 06 00 00 00 00 00 00 00 00 00 00 00 00 00     p-..............
    2e22:	00 00 00 00                                         ....

00002e26 <Channel5_Name_InField>:
    2e26:	00 ca 06 00 00 00                                   ......

00002e2c <Channel5_DI_State_InField>:
    2e2c:	00 cb 06 00 00 00                                   ......

00002e32 <Channel5_Alarm_State_InField>:
    2e32:	00 cc 06 00 00 00                                   ......

00002e38 <Channel5_debounceTimeout_OutField>:
    2e38:	08 3b 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .;..............

00002e48 <Channel5_calling_delay_OutField>:
    2e48:	08 5b 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .[..............

00002e58 <Channel5_calling_retry_delay_OutField>:
    2e58:	08 7b 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .{..............

00002e68 <Channel5>:
    2e68:	20 cd ee ec e5 f0 20 ea e0 ed e0 eb e0 20 20 20      ..... ......   
    2e78:	20 7b 7b 7b 00 26 2e 00 00 00 00 20 d1 ee f1 f2      {{{.&..... ....
    2e88:	ee ff ed e8 e5 20 e2 f5 ee e4 e0 20 7b 7b 7b 00     ..... ..... {{{.
    2e98:	2c 2e 00 00 00 00 20 d1 ee f1 f2 ee ff ed e8 e5     ,..... .........
    2ea8:	20 ea e0 ed e0 eb e0 7b 7b 7b 00 32 2e 00 00 00      ......{{{.2....
    2eb8:	00 20 d2 e0 ed f2 e8 e4 f0 e5 e1 e5 e7 e3 20 20     . ............  
    2ec8:	7d 7d 7d 7d 7d 00 00 00 38 2e 00 00 20 d2 e4 ee     }}}}}...8... ...
    2ed8:	e7 e2 ee ed e0 20 20 20 20 20 20 7d 7d 7d 7d 7d     .....      }}}}}
    2ee8:	00 00 00 48 2e 00 00 20 d2 ef ee e2 f2 2e e4 ee     ...H... ........
    2ef8:	e7 e2 ee ed e0 20 7d 7d 7d 7d 7d 00 00 00 58 2e     ..... }}}}}...X.
	...

00002f0a <Channel5_Page>:
    2f0a:	68 2e 06 00 00 00 00 00 00 00 00 00 00 00 00 00     h...............
    2f1a:	00 00 00 00                                         ....

00002f1e <ChannelSettingsList>:
    2f1e:	20 ca e0 ed e0 eb 20 31 20 20 20 20 20 20 20 20      ..... 1        
    2f2e:	20 20 20 20 00 00 00 00 00 32 2a                        .....2*

00002f39 <MenuModem>:
    2f39:	81 0f 22 00 da 2f 00 00 00 00 00 00 00 00 00 00     .."../..........
    2f49:	00 00 00 00                                         ....

00002f4d <Field_TransmitterState>:
    2f4d:	00 b7 06 00 00 00                                   ......

00002f53 <Menu0List>:
    2f53:	20 2d 47 53 4d 2d f1 e8 e3 ed e0 eb e8 e7 e0 f2      -GSM-..........
    2f63:	ee f0 2d 20 00 00 00 00 00 da 2f 20 d1 eb f3 e6     ..- ....../ ....
    2f73:	e5 e1 ed ee e5 20 20 20 20 20 20 20 20 20 20 00     .....          .
    2f83:	00 00 00 00 1b 1a 20 cc ee e4 e5 ec 20 20 20 20     ...... .....    
    2f93:	20 20 20 20 20 20 20 20 20 20 00 00 00 00 00 39               .....9
    2fa3:	2f 20 cd e0 f1 f2 f0 ee e9 ea e0 20 ea e0 ed e0     / ......... ....
    2fb3:	eb ee e2 20 20 00 00 00 00 00 32 2a 20 d1 ee f1     ...  .....2* ...
    2fc3:	f2 2e 6f e1 e7 e2 ee ed e0 20 20 20 20 7b 7b 7b     ..o......    {{{
    2fd3:	00 4d 2f 00 00 00 00                                .M/....

00002fda <Menu0>:
    2fda:	53 2f 05 00 da 2f 00 00 00 00 00 00 00 00 00 00     S/.../..........
    2fea:	00 00 00 00                                         ....

00002fee <KeyAct.9481>:
    2fee:	00 00 f3 43 f4 43 bf 5b 17 57 69 5f 0e 5f           ...C.C.[.Wi_._

00002ffc <MaxThermType>:
    2ffc:	07 02                                               ..

00002ffe <TerLimType>:
    2ffe:	c3 06 e3 06                                         ....

00003002 <TSM100Tbl>:
    3002:	00 00 e1 f6 91 08 30 f8 0e 28 18 fc a2 37 0c fe     ......0..(...7..
    3012:	ea 46 00 00 49 65 e8 03 a6 83 d0 07 ff ff f4 17     .F..Ie..........

00003022 <TSM50Tbl>:
    3022:	00 00 df f6 46 04 30 f8 13 0c 24 fa fe 13 18 fc     ....F.0...$.....
    3032:	c6 1b 0c fe 6b 23 00 00 03 2b f4 01 9a 32 e8 03     ....k#...+...2..
    3042:	30 3a dc 05 c9 41 d0 07 ff ff bd 38                 0:...A.....8

0000304e <TSP100Tbl>:
    304e:	00 00 f6 f5 c2 38 0c fe e2 46 00 00 b6 62 e8 03     .....8...F...b..
    305e:	96 7d d0 07 ae 97 b8 0b ea b0 a0 0f 54 c9 88 13     .}..........T...
    306e:	e2 e0 70 17 ff ff 97 1e                             ..p.....

00003076 <TSP50Tbl>:
    3076:	00 00 1f f6 5f 1c 0c fe 56 31 e8 03 d0 3e d0 07     ...._...V1...>..
    3086:	d2 4b b8 0b 70 58 a0 0f aa 64 88 13 6c 70 70 17     .K..pX...d..lpp.
    3096:	ff ff 0e 47                                         ...G

0000309a <Pt100Tbl>:
    309a:	00 00 20 f6 fe 38 0c fe 48 62 e8 03 c4 7c d0 07     .. ..8..Hb...|..
    30aa:	6e 96 b8 0b 50 af a0 0f 56 c7 88 13 94 de 70 17     n...P...V.....p.
    30ba:	f6 f4 58 1b ff ff 8b 1f                             ..X.....

000030c2 <Gr21Tbl>:
    30c2:	00 00 1e f6 1c 1a 0c fe 64 2d e8 03 c6 39 d0 07     ........d-...9..
    30d2:	c4 45 b8 0b 68 51 a0 0f 9e 5c 88 13 7a 67 70 17     .E..hQ...\..zgp.
    30e2:	ff ff ce 4f                                         ...O

000030e6 <Gr23Tbl>:
    30e6:	00 00 d5 f6 7d 1d 0c fe 8b 25 00 00 8f 2d f4 01     ....}....%...-..
    30f6:	92 35 e8 03 95 3d dc 05 63 42 08 07 ff ff 3e 35     .5...=..cB....>5

00003106 <TC_B_Tbl>:
    3106:	00 00 90 01 99 01 dc 05 7c 07 b8 0b 8e 15 88 13     ........|.......
    3116:	1b 1f 70 17 30 2a 58 1b c4 36 40 1f b6 44 28 23     ..p.0*X..6@..D(#
    3126:	f2 53 10 27 5a 64 f8 2a d0 75 e0 2e 40 88 c8 32     .S.'Zd.*.u..@..2
    3136:	78 9b b0 36 50 af 98 3a 82 c3 80 3e d2 d7 68 42     x..6P..:...>..hB
    3146:	ff ff 38 4a                                         ..8J

0000314a <Mux.8930>:
    314a:	06 00 07 00 00 08 01 08 02 08 03 08 04 08 05 08     ................

0000315a <M.8855>:
    315a:	00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f     ................

0000316a <DI_M>:
    316a:	07 01 08 01 06 01 40 00 07 01 08 01 06 01 80 00     ......@.........
    317a:	04 01 05 01 03 01 80 00 21 00 22 00 20 00 01 00     ........!.". ...
    318a:	21 00 22 00 20 00 02 00 21 00 22 00 20 00 04 00     !.". ...!.". ...
    319a:	21 00 22 00 20 00 08 00 21 00 22 00 20 00 10 00     !.". ...!.". ...
    31aa:	21 00 22 00 20 00 20 00 21 00 22 00 20 00 40 00     !.". . .!.". .@.
    31ba:	21 00 22 00 20 00 80 00 33 00 34 00 32 00 04 00     !.". ...3.4.2...
    31ca:	04 01 05 01 03 01 40 00 04 01 05 01 03 01 20 00     ......@....... .
    31da:	04 01 05 01 03 01 10 00 04 01 05 01 03 01 08 00     ................
    31ea:	04 01 05 01 03 01 02 01 04 01 05 01 03 01 04 01     ................

000031fa <__c.6222>:
    31fa:	2b 50 44 50 00                                      +PDP.

000031ff <__c.6220>:
    31ff:	43 4c 4f 53 00                                      CLOS.

00003204 <__c.6218>:
    3204:	50 4f 53 54 00                                      POST.

00003209 <__c.6215>:
    3209:	47 45 54 20 00                                      GET .

0000320e <__c.6213>:
    320e:	0d 0a 00                                            ...

00003211 <__c.6209>:
    3211:	2b 43 53 51 3a 20 25 68 68 75 2c 25 68 68 75 00     +CSQ: %hhu,%hhu.

00003221 <__c.6162>:
    3221:	25 68 68 75 2c 20 43 4c 4f 53 45 44 00              %hhu, CLOSED.

0000322e <__c.6156>:
    322e:	4f 4b 00                                            OK.

00003231 <__c.6149>:
    3231:	25 68 68 75 20 25 68 68 75 20 25 68 68 75 20 25     %hhu %hhu %hhu %
    3241:	68 68 75 00                                         hhu.

00003245 <__c.6122>:
    3245:	4e 4f 20 43 41 52 52 49 45 52 00                    NO CARRIER.

00003250 <__c.6120>:
    3250:	42 55 53 59 00                                      BUSY.

00003255 <__c.6118>:
    3255:	4f 4b 00                                            OK.

00003258 <__c.6115>:
    3258:	2b 43 4c 43 43 3a 20 31 2c 30 2c 36 2c 00           +CLCC: 1,0,6,.

00003266 <__c.6112>:
    3266:	41 54 48 0d 00                                      ATH..

0000326b <__c.6107>:
    326b:	41 54 2b 43 52 45 43 3d 34 2c 22 43 3a 5c 55 73     AT+CREC=4,"C:\Us
    327b:	65 72 5c 4e 6f 74 43 6f 6e 66 69 72 6d 2e 61 6d     er\NotConfirm.am
    328b:	72 22 2c 30 2c 31 30 30 0d 00                       r",0,100..

00003295 <__c.6102>:
    3295:	41 54 2b 43 52 45 43 3d 34 2c 22 43 3a 5c 55 73     AT+CREC=4,"C:\Us
    32a5:	65 72 5c 43 6f 6e 66 69 72 6d 2e 61 6d 72 22 2c     er\Confirm.amr",
    32b5:	30 2c 31 30 30 0d 00                                0,100..

000032bc <__c.6099>:
    32bc:	2b 43 52 45 43 3a 20 30 00                          +CREC: 0.

000032c5 <__c.6096>:
    32c5:	41 54 2b 43 52 45 43 3d 35 0d 00                    AT+CREC=5..

000032d0 <__c.6093>:
    32d0:	2b 43 4c 43 43 3a 20 33 2c 30 2c 36 00              +CLCC: 3,0,6.

000032dd <__c.6091>:
    32dd:	2b 43 4c 43 43 3a 20 32 2c 30 2c 36 00              +CLCC: 2,0,6.

000032ea <__c.6089>:
    32ea:	2b 43 4c 43 43 3a 20 31 2c 30 2c 36 00              +CLCC: 1,0,6.

000032f7 <__c.6087>:
    32f7:	2b 44 54 4d 46 3a 20 31 00                          +DTMF: 1.

00003300 <__c.6084>:
    3300:	2b 43 52 45 43 3a 20 30 00                          +CREC: 0.

00003309 <__c.6080>:
    3309:	41 54 2b 43 52 45 43 3d 34 2c 22 43 3a 5c 55 73     AT+CREC=4,"C:\Us
    3319:	65 72 5c 43 6f 6e 66 69 72 6d 52 65 71 75 65 73     er\ConfirmReques
    3329:	74 2e 61 6d 72 22 2c 30 2c 31 30 30 0d 00           t.amr",0,100..

00003337 <__c.6077>:
    3337:	2b 43 52 45 43 3a 20 30 00                          +CREC: 0.

00003340 <__c.6073>:
    3340:	2e 61 6d 72 22 2c 30 2c 31 30 30 0d 00              .amr",0,100..

0000334d <__c.6071>:
    334d:	41 54 2b 43 52 45 43 3d 34 2c 22 43 3a 5c 55 73     AT+CREC=4,"C:\Us
    335d:	65 72 5c 41 6c 61 72 6d 00                          er\Alarm.

00003366 <__c.6068>:
    3366:	2b 43 4c 43 43 3a 20 31 2c 30 2c 36 2c 00           +CLCC: 1,0,6,.

00003374 <__c.6066>:
    3374:	2b 43 4c 43 43 3a 20 31 2c 30 2c 36 2c 00           +CLCC: 1,0,6,.

00003382 <__c.6064>:
    3382:	2b 43 4c 43 43 3a 20 31 2c 30 2c 36 2c 00           +CLCC: 1,0,6,.

00003390 <__c.6062>:
    3390:	2b 43 4c 43 43 3a 20 31 2c 30 2c 30 2c 00           +CLCC: 1,0,0,.

0000339e <__c.6060>:
    339e:	2b 43 4c 43 43 3a 20 31 2c 30 2c 30 2c 00           +CLCC: 1,0,0,.

000033ac <__c.6058>:
    33ac:	2b 43 4c 43 43 3a 20 31 2c 30 2c 30 2c 00           +CLCC: 1,0,0,.

000033ba <__c.6055>:
    33ba:	2b 43 4c 43 43 3a 20 33 2c 30 2c 33 2c 00           +CLCC: 3,0,3,.

000033c8 <__c.6053>:
    33c8:	2b 43 4c 43 43 3a 20 32 2c 30 2c 33 2c 00           +CLCC: 2,0,3,.

000033d6 <__c.6051>:
    33d6:	2b 43 4c 43 43 3a 20 31 2c 30 2c 33 2c 00           +CLCC: 1,0,3,.

000033e4 <__c.6049>:
    33e4:	2b 43 4c 43 43 3a 20 33 2c 30 2c 36 2c 00           +CLCC: 3,0,6,.

000033f2 <__c.6047>:
    33f2:	2b 43 4c 43 43 3a 20 32 2c 30 2c 36 2c 00           +CLCC: 2,0,6,.

00003400 <__c.6045>:
    3400:	2b 43 4c 43 43 3a 20 31 2c 30 2c 36 2c 00           +CLCC: 1,0,6,.

0000340e <__c.6042>:
    340e:	2b 43 4c 43 43 3a 20 33 2c 30 2c 32 2c 00           +CLCC: 3,0,2,.

0000341c <__c.6040>:
    341c:	2b 43 4c 43 43 3a 20 32 2c 30 2c 32 2c 00           +CLCC: 2,0,2,.

0000342a <__c.6038>:
    342a:	2b 43 4c 43 43 3a 20 31 2c 30 2c 32 2c 00           +CLCC: 1,0,2,.

00003438 <__c.5999>:
    3438:	2b 43 4c 43 43 3a 20 33 2c 30 2c 36 00              +CLCC: 3,0,6.

00003445 <__c.5997>:
    3445:	2b 43 4c 43 43 3a 20 32 2c 30 2c 36 00              +CLCC: 2,0,6.

00003452 <__c.5995>:
    3452:	2b 43 4c 43 43 3a 20 31 2c 30 2c 36 00              +CLCC: 1,0,6.

0000345f <__c.5993>:
    345f:	2b 44 54 4d 46 3a 20 31 00                          +DTMF: 1.

00003468 <MB_Port>:
    3468:	ce 00 c8 00 c9 00 ca 00 cd 00 cc 00 7c 21 82 21     ............|!.!
    3478:	86 21 87 21                                         .!.!

0000347c <MB_Role>:
	...

0000347d <MB_Timer>:
    347d:	46 00 47 00 81 2b b2 00 b3 00 8b 2b a4 00 a8 00     F.G..+.....+....
    348d:	97 2b                                               .+

0000348f <CGRAM_LCD>:
    348f:	00 04 06 1f 06 04 00 00 06 09 09 06 00 00 00 00     ................
    349f:	00 08 08 0e 0f 1f 0f 06 00 00 0e 11 1c 11 0e 00     ................
    34af:	0e 11 10 1c 10 11 0e 00 0a 00 0c 04 04 04 0e 00     ................
    34bf:	0a 0e 04 04 04 04 0e 00 00 00 00 00 00 00 00 00     ................

000034cf <Win2LCD>:
    34cf:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    34df:	00 02 ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    34ef:	20 21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f      !"#$%&'()*+,-./
    34ff:	30 31 32 33 34 35 36 37 38 39 3a 3b 3c 3d 3e 3f     0123456789:;<=>?
    350f:	40 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e 4f     @ABCDEFGHIJKLMNO
    351f:	50 51 52 53 54 55 56 57 58 59 5a 5b 5c 5d 5e 5f     PQRSTUVWXYZ[\]^_
    352f:	60 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e 6f     `abcdefghijklmno
    353f:	70 71 72 73 74 75 76 77 78 79 7a 7b 01 7d e9 7f     pqrstuvwxyz{.}..
    354f:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    355f:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    356f:	ff ff ff ff ff ff ff d9 a2 ff 04 ff ff ff ff 06     ................
    357f:	ff ff 49 69 ff ff ff da b5 ff 03 ff ff ff ff 05     ..Ii............
    358f:	41 a0 42 a1 e0 45 a3 a4 a5 a6 4b a7 4d 48 4f a8     A.B..E....K.MHO.
    359f:	50 43 54 a9 aa 58 e1 ab ac e2 ad ae 62 af b0 b1     PCT..X......b...
    35af:	61 b2 b3 b4 e3 65 b6 b7 b8 b9 ba bb bc bd 6f be     a....e........o.
    35bf:	70 63 bf 79 e4 78 e5 c0 c1 e6 c2 c3 c4 c5 c6 c7     pc.y.x..........

000035cf <LineAddr.3690>:
    35cf:	80 c0 94 d4                                         ....

000035d3 <Mux>:
    35d3:	00 01 02 03 04 05 06                                .......

000035da <aCRCLo.1496>:
    35da:	00 c0 c1 01 c3 03 02 c2 c6 06 07 c7 05 c5 c4 04     ................
    35ea:	cc 0c 0d cd 0f cf ce 0e 0a ca cb 0b c9 09 08 c8     ................
    35fa:	d8 18 19 d9 1b db da 1a 1e de df 1f dd 1d 1c dc     ................
    360a:	14 d4 d5 15 d7 17 16 d6 d2 12 13 d3 11 d1 d0 10     ................
    361a:	f0 30 31 f1 33 f3 f2 32 36 f6 f7 37 f5 35 34 f4     .01.3..26..7.54.
    362a:	3c fc fd 3d ff 3f 3e fe fa 3a 3b fb 39 f9 f8 38     <..=.?>..:;.9..8
    363a:	28 e8 e9 29 eb 2b 2a ea ee 2e 2f ef 2d ed ec 2c     (..).+*.../.-..,
    364a:	e4 24 25 e5 27 e7 e6 26 22 e2 e3 23 e1 21 20 e0     .$%.'..&"..#.! .
    365a:	a0 60 61 a1 63 a3 a2 62 66 a6 a7 67 a5 65 64 a4     .`a.c..bf..g.ed.
    366a:	6c ac ad 6d af 6f 6e ae aa 6a 6b ab 69 a9 a8 68     l..m.on..jk.i..h
    367a:	78 b8 b9 79 bb 7b 7a ba be 7e 7f bf 7d bd bc 7c     x..y.{z..~..}..|
    368a:	b4 74 75 b5 77 b7 b6 76 72 b2 b3 73 b1 71 70 b0     .tu.w..vr..s.qp.
    369a:	50 90 91 51 93 53 52 92 96 56 57 97 55 95 94 54     P..Q.SR..VW.U..T
    36aa:	9c 5c 5d 9d 5f 9f 9e 5e 5a 9a 9b 5b 99 59 58 98     .\]._..^Z..[.YX.
    36ba:	88 48 49 89 4b 8b 8a 4a 4e 8e 8f 4f 8d 4d 4c 8c     .HI.K..JN..O.ML.
    36ca:	44 84 85 45 87 47 46 86 82 42 43 83 41 81 80 40     D..E.GF..BC.A..@

000036da <aCRCHi.1495>:
    36da:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    36ea:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    36fa:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    370a:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    371a:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    372a:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    373a:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    374a:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    375a:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    376a:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    377a:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    378a:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    379a:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    37aa:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    37ba:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    37ca:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    37da:	00 40 7a 10 f3 5a 00 a0 72 4e 18 09 00 10 a5 d4     .@z..Z..rN......
    37ea:	e8 00 00 e8 76 48 17 00 00 e4 0b 54 02 00 00 ca     ....vH.....T....
    37fa:	9a 3b 00 00 00 e1 f5 05 00 00 80 96 98 00 00 00     .;..............
    380a:	40 42 0f 00 00 00 a0 86 01 00 00 00 10 27 00 00     @B...........'..
    381a:	00 00 e8 03 00 00 00 00 64 00 00 00 00 00 0a 00     ........d.......
    382a:	00 00 00 00 01 00 00 00 00 00 2c 76 d8 88 dc 67     ..........,v...g
    383a:	4f 08 23 df c1 df ae 59 e1 b1 b7 96 e5 e3 e4 53     O.#....Y.......S
    384a:	c6 3a e6 51 99 76 96 e8 e6 c2 84 26 eb 89 8c 9b     .:.Q.v.....&....
    385a:	62 ed 40 7c 6f fc ef bc 9c 9f 40 f2 ba a5 6f a5     b.@|o.....@...o.
    386a:	f4 90 05 5a 2a f7 5c 93 6b 6c f9 67 6d c1 1b fc     ...Z*.\.kl.gm...
    387a:	e0 e4 0d 47 fe f5 20 e6 b5 00 d0 ed 90 2e 03 00     ...G.. .........
    388a:	94 35 77 05 00 80 84 1e 08 00 00 20 4e 0a 00 00     .5w........ N...
    389a:	00 c8 0c 33 33 33 33 0f 98 6e 12 83 11 41 ef 8d     ...3333..n...A..
    38aa:	21 14 89 3b e6 55 16 cf fe e6 db 18 d1 84 4b 38     !..;.U........K8
    38ba:	1b f7 7c 1d 90 1d a4 bb e4 24 20 32 84 72 5e 22     ..|......$ 2.r^"
    38ca:	81 00 c9 f1 24 ec a1 e5 3d 27                       ....$...='

000038d4 <__ctors_end>:
    38d4:	11 24       	eor	r1, r1
    38d6:	1f be       	out	0x3f, r1	; 63
    38d8:	cf ef       	ldi	r28, 0xFF	; 255
    38da:	d1 e2       	ldi	r29, 0x21	; 33
    38dc:	de bf       	out	0x3e, r29	; 62
    38de:	cd bf       	out	0x3d, r28	; 61
    38e0:	00 e0       	ldi	r16, 0x00	; 0
    38e2:	0c bf       	out	0x3c, r16	; 60

000038e4 <__do_copy_data>:
    38e4:	12 e0       	ldi	r17, 0x02	; 2
    38e6:	a0 e0       	ldi	r26, 0x00	; 0
    38e8:	b2 e0       	ldi	r27, 0x02	; 2
    38ea:	ea e3       	ldi	r30, 0x3A	; 58
    38ec:	f0 e1       	ldi	r31, 0x10	; 16
    38ee:	01 e0       	ldi	r16, 0x01	; 1
    38f0:	0b bf       	out	0x3b, r16	; 59
    38f2:	02 c0       	rjmp	.+4      	; 0x38f8 <__do_copy_data+0x14>
    38f4:	07 90       	elpm	r0, Z+
    38f6:	0d 92       	st	X+, r0
    38f8:	aa 3d       	cpi	r26, 0xDA	; 218
    38fa:	b1 07       	cpc	r27, r17
    38fc:	d9 f7       	brne	.-10     	; 0x38f4 <__do_copy_data+0x10>

000038fe <__do_clear_bss>:
    38fe:	1c e0       	ldi	r17, 0x0C	; 12
    3900:	aa ed       	ldi	r26, 0xDA	; 218
    3902:	b2 e0       	ldi	r27, 0x02	; 2
    3904:	01 c0       	rjmp	.+2      	; 0x3908 <.do_clear_bss_start>

00003906 <.do_clear_bss_loop>:
    3906:	1d 92       	st	X+, r1

00003908 <.do_clear_bss_start>:
    3908:	a4 37       	cpi	r26, 0x74	; 116
    390a:	b1 07       	cpc	r27, r17
    390c:	e1 f7       	brne	.-8      	; 0x3906 <.do_clear_bss_loop>
    390e:	0e 94 54 79 	call	0xf2a8	; 0xf2a8 <main>
    3912:	0c 94 30 83 	jmp	0x10660	; 0x10660 <exit>

00003916 <__bad_interrupt>:
    3916:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000391a <rrb>:
#include <stdint.h>

// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
rrb(const uint8_t *addr)
{
    391a:	fc 01       	movw	r30, r24
	return *addr;
}
    391c:	80 81       	ld	r24, Z
    391e:	08 95       	ret

00003920 <prb>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    3920:	fc 01       	movw	r30, r24
    3922:	84 91       	lpm	r24, Z+
}
    3924:	08 95       	ret

00003926 <prw>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    3926:	fc 01       	movw	r30, r24
    3928:	25 91       	lpm	r18, Z+
    392a:	34 91       	lpm	r19, Z+
}
    392c:	c9 01       	movw	r24, r18
    392e:	08 95       	ret

00003930 <prd>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    3930:	fc 01       	movw	r30, r24
    3932:	25 91       	lpm	r18, Z+
    3934:	35 91       	lpm	r19, Z+
    3936:	45 91       	lpm	r20, Z+
    3938:	54 91       	lpm	r21, Z+
}
    393a:	b9 01       	movw	r22, r18
    393c:	ca 01       	movw	r24, r20
    393e:	08 95       	ret

00003940 <prb_f>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#if FLASHEND>0xFFFF
uint8_t
prb_f(const prog_uint8_t *addr)
{
	return pgm_read_byte_far((uint16_t)addr+0x10000);
    3940:	a0 e0       	ldi	r26, 0x00	; 0
    3942:	b0 e0       	ldi	r27, 0x00	; 0
    3944:	80 50       	subi	r24, 0x00	; 0
    3946:	90 40       	sbci	r25, 0x00	; 0
    3948:	af 4f       	sbci	r26, 0xFF	; 255
    394a:	bf 4f       	sbci	r27, 0xFF	; 255
}
    394c:	ab bf       	out	0x3b, r26	; 59
    394e:	fc 01       	movw	r30, r24
    3950:	87 91       	elpm	r24, Z+
    3952:	08 95       	ret

00003954 <prc>:

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    3954:	fc 01       	movw	r30, r24
    3956:	84 91       	lpm	r24, Z+
}
    3958:	08 95       	ret

0000395a <prp>:

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    395a:	fc 01       	movw	r30, r24
    395c:	25 91       	lpm	r18, Z+
    395e:	34 91       	lpm	r19, Z+
}
    3960:	c9 01       	movw	r24, r18
    3962:	08 95       	ret

00003964 <CRC_Seed>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
CRC_Seed(uint8_t (*GetByte)(const uint8_t*), const uint8_t *Block, uint32_t Sz, uint16_t Seed)
{
    3964:	6f 92       	push	r6
    3966:	7f 92       	push	r7
    3968:	8f 92       	push	r8
    396a:	9f 92       	push	r9
    396c:	af 92       	push	r10
    396e:	bf 92       	push	r11
    3970:	cf 92       	push	r12
    3972:	df 92       	push	r13
    3974:	ef 92       	push	r14
    3976:	ff 92       	push	r15
    3978:	0f 93       	push	r16
    397a:	1f 93       	push	r17
    397c:	cf 93       	push	r28
    397e:	df 93       	push	r29
    3980:	3c 01       	movw	r6, r24
    3982:	eb 01       	movw	r28, r22
    3984:	49 01       	movw	r8, r18
    3986:	5a 01       	movw	r10, r20
    3988:	c1 2e       	mov	r12, r17
		0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54,
		0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98,
		0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
		0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 0x40
	};
	uint8_t CRCHi=Seed>>8, CRCLo=Seed;
    398a:	d0 2e       	mov	r13, r16
	for (uint32_t i=0; i<Sz; i++) {
    398c:	21 15       	cp	r18, r1
    398e:	31 05       	cpc	r19, r1
    3990:	41 05       	cpc	r20, r1
    3992:	51 05       	cpc	r21, r1
    3994:	f9 f0       	breq	.+62     	; 0x39d4 <CRC_Seed+0x70>
    3996:	ee 24       	eor	r14, r14
    3998:	ff 24       	eor	r15, r15
    399a:	87 01       	movw	r16, r14
		uint8_t j = CRCLo^GetByte(Block+i);
    399c:	ce 01       	movw	r24, r28
    399e:	8e 0d       	add	r24, r14
    39a0:	9f 1d       	adc	r25, r15
    39a2:	f3 01       	movw	r30, r6
    39a4:	19 95       	eicall
		CRCLo = CRCHi^prb(aCRCHi+j);
    39a6:	d8 26       	eor	r13, r24
    39a8:	2d 2d       	mov	r18, r13
    39aa:	30 e0       	ldi	r19, 0x00	; 0

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    39ac:	c9 01       	movw	r24, r18
    39ae:	86 52       	subi	r24, 0x26	; 38
    39b0:	99 4c       	sbci	r25, 0xC9	; 201
    39b2:	fc 01       	movw	r30, r24
    39b4:	d4 90       	lpm	r13, Z+
		0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 0x40
	};
	uint8_t CRCHi=Seed>>8, CRCLo=Seed;
	for (uint32_t i=0; i<Sz; i++) {
		uint8_t j = CRCLo^GetByte(Block+i);
		CRCLo = CRCHi^prb(aCRCHi+j);
    39b6:	dc 24       	eor	r13, r12

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    39b8:	26 52       	subi	r18, 0x26	; 38
    39ba:	3a 4c       	sbci	r19, 0xCA	; 202
    39bc:	f9 01       	movw	r30, r18
    39be:	c4 90       	lpm	r12, Z+
		0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98,
		0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
		0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 0x40
	};
	uint8_t CRCHi=Seed>>8, CRCLo=Seed;
	for (uint32_t i=0; i<Sz; i++) {
    39c0:	08 94       	sec
    39c2:	e1 1c       	adc	r14, r1
    39c4:	f1 1c       	adc	r15, r1
    39c6:	01 1d       	adc	r16, r1
    39c8:	11 1d       	adc	r17, r1
    39ca:	e8 14       	cp	r14, r8
    39cc:	f9 04       	cpc	r15, r9
    39ce:	0a 05       	cpc	r16, r10
    39d0:	1b 05       	cpc	r17, r11
    39d2:	20 f3       	brcs	.-56     	; 0x399c <CRC_Seed+0x38>
    39d4:	9c 2d       	mov	r25, r12
    39d6:	80 e0       	ldi	r24, 0x00	; 0
    39d8:	2d 2d       	mov	r18, r13
    39da:	30 e0       	ldi	r19, 0x00	; 0
    39dc:	28 2b       	or	r18, r24
    39de:	39 2b       	or	r19, r25
		uint8_t j = CRCLo^GetByte(Block+i);
		CRCLo = CRCHi^prb(aCRCHi+j);
		CRCHi = prb(aCRCLo+j);
	}
	return CRCHi<<8|CRCLo;
}
    39e0:	c9 01       	movw	r24, r18
    39e2:	df 91       	pop	r29
    39e4:	cf 91       	pop	r28
    39e6:	1f 91       	pop	r17
    39e8:	0f 91       	pop	r16
    39ea:	ff 90       	pop	r15
    39ec:	ef 90       	pop	r14
    39ee:	df 90       	pop	r13
    39f0:	cf 90       	pop	r12
    39f2:	bf 90       	pop	r11
    39f4:	af 90       	pop	r10
    39f6:	9f 90       	pop	r9
    39f8:	8f 90       	pop	r8
    39fa:	7f 90       	pop	r7
    39fc:	6f 90       	pop	r6
    39fe:	08 95       	ret

00003a00 <CRC>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
CRC(uint8_t (*GetByte)(const uint8_t*), const uint8_t *Block, uint32_t Sz)
{
    3a00:	0f 93       	push	r16
    3a02:	1f 93       	push	r17
	return CRC_Seed(GetByte, Block, Sz, 0xFFFF);
    3a04:	0f ef       	ldi	r16, 0xFF	; 255
    3a06:	1f ef       	ldi	r17, 0xFF	; 255
    3a08:	0e 94 b2 1c 	call	0x3964	; 0x3964 <CRC_Seed>
}
    3a0c:	1f 91       	pop	r17
    3a0e:	0f 91       	pop	r16
    3a10:	08 95       	ret

00003a12 <CRC_Flash_calc>:

// ~~~~~~~~~~~~~~~~~
static uint16_t
CRC_Flash_calc(void)
{
    3a12:	0f 93       	push	r16
    3a14:	1f 93       	push	r17
	#if FLASHEND<0xFFFF
		return CRC(prb, NULL, (uint32_t)FLASHEND+1);
	#else
		return CRC_Seed(prb_f, NULL, FLASHEND-0xFFFF, CRC(prb, NULL, 0x10000));
    3a16:	80 e9       	ldi	r24, 0x90	; 144
    3a18:	9c e1       	ldi	r25, 0x1C	; 28
    3a1a:	60 e0       	ldi	r22, 0x00	; 0
    3a1c:	70 e0       	ldi	r23, 0x00	; 0
    3a1e:	20 e0       	ldi	r18, 0x00	; 0
    3a20:	30 e0       	ldi	r19, 0x00	; 0
    3a22:	41 e0       	ldi	r20, 0x01	; 1
    3a24:	50 e0       	ldi	r21, 0x00	; 0
    3a26:	0e 94 00 1d 	call	0x3a00	; 0x3a00 <CRC>
    3a2a:	8c 01       	movw	r16, r24
    3a2c:	80 ea       	ldi	r24, 0xA0	; 160
    3a2e:	9c e1       	ldi	r25, 0x1C	; 28
    3a30:	60 e0       	ldi	r22, 0x00	; 0
    3a32:	70 e0       	ldi	r23, 0x00	; 0
    3a34:	20 e0       	ldi	r18, 0x00	; 0
    3a36:	30 e0       	ldi	r19, 0x00	; 0
    3a38:	43 e0       	ldi	r20, 0x03	; 3
    3a3a:	50 e0       	ldi	r21, 0x00	; 0
    3a3c:	0e 94 b2 1c 	call	0x3964	; 0x3964 <CRC_Seed>
	#endif
}
    3a40:	1f 91       	pop	r17
    3a42:	0f 91       	pop	r16
    3a44:	08 95       	ret

00003a46 <CRC_EEPROM_calc>:

// ~~~~~~~~~~~~~~~~~~
static uint16_t
CRC_EEPROM_calc(void)
{
    3a46:	cf 92       	push	r12
    3a48:	df 92       	push	r13
    3a4a:	ef 92       	push	r14
    3a4c:	ff 92       	push	r15
    3a4e:	0f 93       	push	r16
    3a50:	1f 93       	push	r17
	return
    3a52:	93 e2       	ldi	r25, 0x23	; 35
    3a54:	c9 2e       	mov	r12, r25
    3a56:	93 e5       	ldi	r25, 0x53	; 83
    3a58:	d9 2e       	mov	r13, r25
    3a5a:	88 e9       	ldi	r24, 0x98	; 152
    3a5c:	e8 2e       	mov	r14, r24
    3a5e:	81 e0       	ldi	r24, 0x01	; 1
    3a60:	f8 2e       	mov	r15, r24
    3a62:	97 01       	movw	r18, r14
    3a64:	40 e0       	ldi	r20, 0x00	; 0
    3a66:	50 e0       	ldi	r21, 0x00	; 0
    3a68:	c6 01       	movw	r24, r12
    3a6a:	60 e0       	ldi	r22, 0x00	; 0
    3a6c:	70 e0       	ldi	r23, 0x00	; 0
    3a6e:	0e 94 00 1d 	call	0x3a00	; 0x3a00 <CRC>
    3a72:	8c 01       	movw	r16, r24
    3a74:	2b ef       	ldi	r18, 0xFB	; 251
    3a76:	3f e0       	ldi	r19, 0x0F	; 15
    3a78:	2e 19       	sub	r18, r14
    3a7a:	3f 09       	sbc	r19, r15
    3a7c:	40 e0       	ldi	r20, 0x00	; 0
    3a7e:	50 e0       	ldi	r21, 0x00	; 0
    3a80:	c6 01       	movw	r24, r12
    3a82:	65 e0       	ldi	r22, 0x05	; 5
    3a84:	70 e0       	ldi	r23, 0x00	; 0
    3a86:	e6 0e       	add	r14, r22
    3a88:	f7 1e       	adc	r15, r23
    3a8a:	b7 01       	movw	r22, r14
    3a8c:	0e 94 b2 1c 	call	0x3964	; 0x3964 <CRC_Seed>
		CRC_Seed(erb, (uint8_t*)&MemCheck_stor+sizeof(MemCheck_stor), E2END-((uint16_t)&MemCheck_stor-1)-sizeof(MemCheck_stor),
			CRC(erb, NULL, (uint16_t)&MemCheck_stor));
}
    3a90:	1f 91       	pop	r17
    3a92:	0f 91       	pop	r16
    3a94:	ff 90       	pop	r15
    3a96:	ef 90       	pop	r14
    3a98:	df 90       	pop	r13
    3a9a:	cf 90       	pop	r12
    3a9c:	08 95       	ret

00003a9e <InterruInit>:
InterruInit(void)
{
	#ifdef PMIC
		PMIC.CTRL = (uint8_t)(~PMIC_RREN_bm &~PMIC_IVSEL_bm) |PMIC_HILVLEN_bm |PMIC_MEDLVLEN_bm |PMIC_LOLVLEN_bm;
	#endif
	sei();
    3a9e:	78 94       	sei
}
    3aa0:	08 95       	ret

00003aa2 <IntOff>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3aa2:	8f b7       	in	r24, 0x3f	; 63
    3aa4:	80 78       	andi	r24, 0x80	; 128
    3aa6:	80 93 ee 02 	sts	0x02EE, r24
	cli();
    3aaa:	f8 94       	cli
	return interru_enub_flg;
}
    3aac:	08 95       	ret

00003aae <IntOn>:

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3aae:	80 91 ee 02 	lds	r24, 0x02EE
    3ab2:	88 23       	and	r24, r24
    3ab4:	09 f0       	breq	.+2      	; 0x3ab8 <IntOn+0xa>
		sei();
    3ab6:	78 94       	sei
	return interru_enub_flg;
}
    3ab8:	08 95       	ret

00003aba <WdtOn>:

// ~~~~~~~~
void
WdtOn(void)
{
	wdt_reset();
    3aba:	a8 95       	wdr
	wdt_enable(WDTO_2S);
    3abc:	2f e0       	ldi	r18, 0x0F	; 15
    3abe:	88 e1       	ldi	r24, 0x18	; 24
    3ac0:	90 e0       	ldi	r25, 0x00	; 0
    3ac2:	0f b6       	in	r0, 0x3f	; 63
    3ac4:	f8 94       	cli
    3ac6:	a8 95       	wdr
    3ac8:	80 93 60 00 	sts	0x0060, r24
    3acc:	0f be       	out	0x3f, r0	; 63
    3ace:	20 93 60 00 	sts	0x0060, r18
}
    3ad2:	08 95       	ret

00003ad4 <Timer8_ISR_Alloc>:

// ~~~~~~~~~~~~~~
uint8_t
Timer8_ISR_Alloc(void)
{
	uint8_t N = VacantTimer8_ISR;
    3ad4:	80 91 da 02 	lds	r24, 0x02DA
	VacantTimer8_ISR++;
    3ad8:	8f 5f       	subi	r24, 0xFF	; 255
    3ada:	80 93 da 02 	sts	0x02DA, r24
    3ade:	81 50       	subi	r24, 0x01	; 1
	return N;
}
    3ae0:	08 95       	ret

00003ae2 <Timer8Alloc>:

uint8_t
Timer8Alloc(void)
{
	uint8_t N = VacantTimer8;
    3ae2:	80 91 cc 02 	lds	r24, 0x02CC
	VacantTimer8++;
    3ae6:	8f 5f       	subi	r24, 0xFF	; 255
    3ae8:	80 93 cc 02 	sts	0x02CC, r24
    3aec:	81 50       	subi	r24, 0x01	; 1
	return N;
}
    3aee:	08 95       	ret

00003af0 <Timer16Alloc>:

// ~~~~~~~~~~~~~~~
uint8_t
Timer16Alloc(void)
{
	uint8_t N = VacantTimer16;
    3af0:	80 91 cd 02 	lds	r24, 0x02CD
	VacantTimer16++;
    3af4:	8f 5f       	subi	r24, 0xFF	; 255
    3af6:	80 93 cd 02 	sts	0x02CD, r24
    3afa:	81 50       	subi	r24, 0x01	; 1
	return N;
}
    3afc:	08 95       	ret

00003afe <Timer32Alloc>:

// ~~~~~~~~~~~~~~~
uint8_t
Timer32Alloc(void)
{
	uint8_t N = VacantTimer32;
    3afe:	80 91 ce 02 	lds	r24, 0x02CE
	VacantTimer32++;
    3b02:	8f 5f       	subi	r24, 0xFF	; 255
    3b04:	80 93 ce 02 	sts	0x02CE, r24
    3b08:	81 50       	subi	r24, 0x01	; 1
	return N;
}
    3b0a:	08 95       	ret

00003b0c <Timer8_ISR_AppAlloc>:
// ~~~~~~~~~~~~~~

uint8_t
Timer8_ISR_AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    3b0c:	88 23       	and	r24, r24
    3b0e:	39 f0       	breq	.+14     	; 0x3b1e <Timer8_ISR_AppAlloc+0x12>
	uint8_t N = VacantTimer8_ISR;
    3b10:	90 91 da 02 	lds	r25, 0x02DA
	VacantTimer8_ISR+=n;
    3b14:	89 0f       	add	r24, r25
    3b16:	80 93 da 02 	sts	0x02DA, r24
	return N;
}
    3b1a:	89 2f       	mov	r24, r25
    3b1c:	08 95       	ret
// ~~~~~~~~~~~~~~

uint8_t
Timer8_ISR_AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    3b1e:	90 e0       	ldi	r25, 0x00	; 0
	uint8_t N = VacantTimer8_ISR;
	VacantTimer8_ISR+=n;
	return N;
}
    3b20:	89 2f       	mov	r24, r25
    3b22:	08 95       	ret

00003b24 <Timer8AppAlloc>:

uint8_t
Timer8AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    3b24:	88 23       	and	r24, r24
    3b26:	39 f0       	breq	.+14     	; 0x3b36 <Timer8AppAlloc+0x12>
	uint8_t N = VacantTimer8;
    3b28:	90 91 cc 02 	lds	r25, 0x02CC
	VacantTimer8+=n;
    3b2c:	89 0f       	add	r24, r25
    3b2e:	80 93 cc 02 	sts	0x02CC, r24
	return N;
}
    3b32:	89 2f       	mov	r24, r25
    3b34:	08 95       	ret
}

uint8_t
Timer8AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    3b36:	90 e0       	ldi	r25, 0x00	; 0
	uint8_t N = VacantTimer8;
	VacantTimer8+=n;
	return N;
}
    3b38:	89 2f       	mov	r24, r25
    3b3a:	08 95       	ret

00003b3c <Timer16AppAlloc>:

// ~~~~~~~~~~~~~~~
uint8_t
Timer16AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    3b3c:	88 23       	and	r24, r24
    3b3e:	39 f0       	breq	.+14     	; 0x3b4e <Timer16AppAlloc+0x12>
	uint8_t N = VacantTimer16;
    3b40:	90 91 cd 02 	lds	r25, 0x02CD
	VacantTimer16+=n;
    3b44:	89 0f       	add	r24, r25
    3b46:	80 93 cd 02 	sts	0x02CD, r24
	return N;
}
    3b4a:	89 2f       	mov	r24, r25
    3b4c:	08 95       	ret

// ~~~~~~~~~~~~~~~
uint8_t
Timer16AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    3b4e:	90 e0       	ldi	r25, 0x00	; 0
	uint8_t N = VacantTimer16;
	VacantTimer16+=n;
	return N;
}
    3b50:	89 2f       	mov	r24, r25
    3b52:	08 95       	ret

00003b54 <Timer32AppAlloc>:

// ~~~~~~~~~~~~~~~
uint8_t
Timer32AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    3b54:	88 23       	and	r24, r24
    3b56:	39 f0       	breq	.+14     	; 0x3b66 <Timer32AppAlloc+0x12>
	uint8_t N = VacantTimer32;
    3b58:	90 91 ce 02 	lds	r25, 0x02CE
	VacantTimer32+=n;
    3b5c:	89 0f       	add	r24, r25
    3b5e:	80 93 ce 02 	sts	0x02CE, r24
	return N;
}
    3b62:	89 2f       	mov	r24, r25
    3b64:	08 95       	ret

// ~~~~~~~~~~~~~~~
uint8_t
Timer32AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    3b66:	90 e0       	ldi	r25, 0x00	; 0
	uint8_t N = VacantTimer32;
	VacantTimer32+=n;
	return N;
}
    3b68:	89 2f       	mov	r24, r25
    3b6a:	08 95       	ret

00003b6c <Timer8_ISR_SysAlloc>:

// ~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer8_ISR_SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys_ISR;
    3b6c:	90 91 db 02 	lds	r25, 0x02DB
	VacantTimer8Sys_ISR += n;
    3b70:	89 0f       	add	r24, r25
    3b72:	80 93 db 02 	sts	0x02DB, r24
	return N;
}
    3b76:	89 2f       	mov	r24, r25
    3b78:	08 95       	ret

00003b7a <Timer8SysAlloc>:

uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    3b7a:	90 91 cf 02 	lds	r25, 0x02CF
	VacantTimer8Sys += n;
    3b7e:	89 0f       	add	r24, r25
    3b80:	80 93 cf 02 	sts	0x02CF, r24
	return N;
}
    3b84:	89 2f       	mov	r24, r25
    3b86:	08 95       	ret

00003b88 <Timer16SysAlloc>:

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    3b88:	90 91 d0 02 	lds	r25, 0x02D0
	VacantTimer16Sys += n;
    3b8c:	89 0f       	add	r24, r25
    3b8e:	80 93 d0 02 	sts	0x02D0, r24
	return N;
}
    3b92:	89 2f       	mov	r24, r25
    3b94:	08 95       	ret

00003b96 <Timer32SysAlloc>:

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer32SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer32Sys;
    3b96:	90 91 d1 02 	lds	r25, 0x02D1
	VacantTimer32Sys += n;
    3b9a:	89 0f       	add	r24, r25
    3b9c:	80 93 d1 02 	sts	0x02D1, r24
	return N;
}
    3ba0:	89 2f       	mov	r24, r25
    3ba2:	08 95       	ret

00003ba4 <StartTimer8_ISR>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
StartTimer8_ISR(uint8_t TimerN, uint8_t Timeout)
{
    3ba4:	98 2f       	mov	r25, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3ba6:	3f b7       	in	r19, 0x3f	; 63
    3ba8:	30 78       	andi	r19, 0x80	; 128
    3baa:	30 93 ee 02 	sts	0x02EE, r19
	cli();
    3bae:	f8 94       	cli
	IntOff();
	if ((Timer8_ISR[TimerN]=Timeout)>0)
    3bb0:	48 2f       	mov	r20, r24
    3bb2:	50 e0       	ldi	r21, 0x00	; 0
    3bb4:	fa 01       	movw	r30, r20
    3bb6:	e1 51       	subi	r30, 0x11	; 17
    3bb8:	fd 4f       	sbci	r31, 0xFD	; 253
    3bba:	60 83       	st	Z, r22
    3bbc:	80 81       	ld	r24, Z
    3bbe:	88 23       	and	r24, r24
    3bc0:	c1 f0       	breq	.+48     	; 0x3bf2 <StartTimer8_ISR+0x4e>
		Timer8_ISR_Flg[TimerN/8] &=~(1<<TimerN%8);
    3bc2:	96 95       	lsr	r25
    3bc4:	96 95       	lsr	r25
    3bc6:	96 95       	lsr	r25
    3bc8:	e9 2f       	mov	r30, r25
    3bca:	f0 e0       	ldi	r31, 0x00	; 0
    3bcc:	e1 55       	subi	r30, 0x51	; 81
    3bce:	fb 4f       	sbci	r31, 0xFB	; 251
    3bd0:	20 81       	ld	r18, Z
    3bd2:	47 70       	andi	r20, 0x07	; 7
    3bd4:	50 70       	andi	r21, 0x00	; 0
    3bd6:	81 e0       	ldi	r24, 0x01	; 1
    3bd8:	90 e0       	ldi	r25, 0x00	; 0
    3bda:	02 c0       	rjmp	.+4      	; 0x3be0 <StartTimer8_ISR+0x3c>
    3bdc:	88 0f       	add	r24, r24
    3bde:	99 1f       	adc	r25, r25
    3be0:	4a 95       	dec	r20
    3be2:	e2 f7       	brpl	.-8      	; 0x3bdc <StartTimer8_ISR+0x38>
    3be4:	80 95       	com	r24
    3be6:	82 23       	and	r24, r18
    3be8:	80 83       	st	Z, r24

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3bea:	33 23       	and	r19, r19
    3bec:	09 f0       	breq	.+2      	; 0x3bf0 <StartTimer8_ISR+0x4c>
		sei();
    3bee:	78 94       	sei
    3bf0:	08 95       	ret
	else
		Timer8_ISR_Flg[TimerN/8] |=(1<<TimerN%8);
    3bf2:	96 95       	lsr	r25
    3bf4:	96 95       	lsr	r25
    3bf6:	96 95       	lsr	r25
    3bf8:	e9 2f       	mov	r30, r25
    3bfa:	f0 e0       	ldi	r31, 0x00	; 0
    3bfc:	e1 55       	subi	r30, 0x51	; 81
    3bfe:	fb 4f       	sbci	r31, 0xFB	; 251
    3c00:	20 81       	ld	r18, Z
    3c02:	47 70       	andi	r20, 0x07	; 7
    3c04:	50 70       	andi	r21, 0x00	; 0
    3c06:	81 e0       	ldi	r24, 0x01	; 1
    3c08:	90 e0       	ldi	r25, 0x00	; 0
    3c0a:	02 c0       	rjmp	.+4      	; 0x3c10 <StartTimer8_ISR+0x6c>
    3c0c:	88 0f       	add	r24, r24
    3c0e:	99 1f       	adc	r25, r25
    3c10:	4a 95       	dec	r20
    3c12:	e2 f7       	brpl	.-8      	; 0x3c0c <StartTimer8_ISR+0x68>
    3c14:	28 2b       	or	r18, r24
    3c16:	20 83       	st	Z, r18
    3c18:	e8 cf       	rjmp	.-48     	; 0x3bea <StartTimer8_ISR+0x46>

00003c1a <StartTimer8>:
}


void
StartTimer8(uint8_t TimerN, uint8_t Timeout)
{
    3c1a:	98 2f       	mov	r25, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3c1c:	3f b7       	in	r19, 0x3f	; 63
    3c1e:	30 78       	andi	r19, 0x80	; 128
    3c20:	30 93 ee 02 	sts	0x02EE, r19
	cli();
    3c24:	f8 94       	cli
	IntOff();
	if ((Timer8[TimerN]=Timeout)>0)
    3c26:	48 2f       	mov	r20, r24
    3c28:	50 e0       	ldi	r21, 0x00	; 0
    3c2a:	fa 01       	movw	r30, r20
    3c2c:	e9 50       	subi	r30, 0x09	; 9
    3c2e:	fd 4f       	sbci	r31, 0xFD	; 253
    3c30:	60 83       	st	Z, r22
    3c32:	80 81       	ld	r24, Z
    3c34:	88 23       	and	r24, r24
    3c36:	c1 f0       	breq	.+48     	; 0x3c68 <StartTimer8+0x4e>
		Timer8Flg[TimerN/8] &=~(1<<TimerN%8);
    3c38:	96 95       	lsr	r25
    3c3a:	96 95       	lsr	r25
    3c3c:	96 95       	lsr	r25
    3c3e:	e9 2f       	mov	r30, r25
    3c40:	f0 e0       	ldi	r31, 0x00	; 0
    3c42:	ef 54       	subi	r30, 0x4F	; 79
    3c44:	fb 4f       	sbci	r31, 0xFB	; 251
    3c46:	20 81       	ld	r18, Z
    3c48:	47 70       	andi	r20, 0x07	; 7
    3c4a:	50 70       	andi	r21, 0x00	; 0
    3c4c:	81 e0       	ldi	r24, 0x01	; 1
    3c4e:	90 e0       	ldi	r25, 0x00	; 0
    3c50:	02 c0       	rjmp	.+4      	; 0x3c56 <StartTimer8+0x3c>
    3c52:	88 0f       	add	r24, r24
    3c54:	99 1f       	adc	r25, r25
    3c56:	4a 95       	dec	r20
    3c58:	e2 f7       	brpl	.-8      	; 0x3c52 <StartTimer8+0x38>
    3c5a:	80 95       	com	r24
    3c5c:	82 23       	and	r24, r18
    3c5e:	80 83       	st	Z, r24

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3c60:	33 23       	and	r19, r19
    3c62:	09 f0       	breq	.+2      	; 0x3c66 <StartTimer8+0x4c>
		sei();
    3c64:	78 94       	sei
    3c66:	08 95       	ret
	else
		Timer8Flg[TimerN/8] |=(1<<TimerN%8);
    3c68:	96 95       	lsr	r25
    3c6a:	96 95       	lsr	r25
    3c6c:	96 95       	lsr	r25
    3c6e:	e9 2f       	mov	r30, r25
    3c70:	f0 e0       	ldi	r31, 0x00	; 0
    3c72:	ef 54       	subi	r30, 0x4F	; 79
    3c74:	fb 4f       	sbci	r31, 0xFB	; 251
    3c76:	20 81       	ld	r18, Z
    3c78:	47 70       	andi	r20, 0x07	; 7
    3c7a:	50 70       	andi	r21, 0x00	; 0
    3c7c:	81 e0       	ldi	r24, 0x01	; 1
    3c7e:	90 e0       	ldi	r25, 0x00	; 0
    3c80:	02 c0       	rjmp	.+4      	; 0x3c86 <StartTimer8+0x6c>
    3c82:	88 0f       	add	r24, r24
    3c84:	99 1f       	adc	r25, r25
    3c86:	4a 95       	dec	r20
    3c88:	e2 f7       	brpl	.-8      	; 0x3c82 <StartTimer8+0x68>
    3c8a:	28 2b       	or	r18, r24
    3c8c:	20 83       	st	Z, r18
    3c8e:	e8 cf       	rjmp	.-48     	; 0x3c60 <StartTimer8+0x46>

00003c90 <StartTimer16>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
StartTimer16(uint8_t TimerN, uint16_t Timeout)
{
    3c90:	28 2f       	mov	r18, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3c92:	3f b7       	in	r19, 0x3f	; 63
    3c94:	30 78       	andi	r19, 0x80	; 128
    3c96:	30 93 ee 02 	sts	0x02EE, r19
	cli();
    3c9a:	f8 94       	cli
	IntOff();
	if ((Timer16[TimerN]=Timeout)>0)
    3c9c:	48 2f       	mov	r20, r24
    3c9e:	50 e0       	ldi	r21, 0x00	; 0
    3ca0:	fa 01       	movw	r30, r20
    3ca2:	ee 0f       	add	r30, r30
    3ca4:	ff 1f       	adc	r31, r31
    3ca6:	e1 5b       	subi	r30, 0xB1	; 177
    3ca8:	fc 4f       	sbci	r31, 0xFC	; 252
    3caa:	71 83       	std	Z+1, r23	; 0x01
    3cac:	60 83       	st	Z, r22
    3cae:	80 81       	ld	r24, Z
    3cb0:	91 81       	ldd	r25, Z+1	; 0x01
    3cb2:	89 2b       	or	r24, r25
    3cb4:	c1 f0       	breq	.+48     	; 0x3ce6 <StartTimer16+0x56>
		Timer16Flg[TimerN/8] &=~(1<<TimerN%8);
    3cb6:	26 95       	lsr	r18
    3cb8:	26 95       	lsr	r18
    3cba:	26 95       	lsr	r18
    3cbc:	e2 2f       	mov	r30, r18
    3cbe:	f0 e0       	ldi	r31, 0x00	; 0
    3cc0:	e3 54       	subi	r30, 0x43	; 67
    3cc2:	fb 4f       	sbci	r31, 0xFB	; 251
    3cc4:	20 81       	ld	r18, Z
    3cc6:	47 70       	andi	r20, 0x07	; 7
    3cc8:	50 70       	andi	r21, 0x00	; 0
    3cca:	81 e0       	ldi	r24, 0x01	; 1
    3ccc:	90 e0       	ldi	r25, 0x00	; 0
    3cce:	02 c0       	rjmp	.+4      	; 0x3cd4 <StartTimer16+0x44>
    3cd0:	88 0f       	add	r24, r24
    3cd2:	99 1f       	adc	r25, r25
    3cd4:	4a 95       	dec	r20
    3cd6:	e2 f7       	brpl	.-8      	; 0x3cd0 <StartTimer16+0x40>
    3cd8:	80 95       	com	r24
    3cda:	82 23       	and	r24, r18
    3cdc:	80 83       	st	Z, r24

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3cde:	33 23       	and	r19, r19
    3ce0:	09 f0       	breq	.+2      	; 0x3ce4 <StartTimer16+0x54>
		sei();
    3ce2:	78 94       	sei
    3ce4:	08 95       	ret
	else
		Timer16Flg[TimerN/8] |=(1<<TimerN%8);
    3ce6:	26 95       	lsr	r18
    3ce8:	26 95       	lsr	r18
    3cea:	26 95       	lsr	r18
    3cec:	e2 2f       	mov	r30, r18
    3cee:	f0 e0       	ldi	r31, 0x00	; 0
    3cf0:	e3 54       	subi	r30, 0x43	; 67
    3cf2:	fb 4f       	sbci	r31, 0xFB	; 251
    3cf4:	20 81       	ld	r18, Z
    3cf6:	47 70       	andi	r20, 0x07	; 7
    3cf8:	50 70       	andi	r21, 0x00	; 0
    3cfa:	81 e0       	ldi	r24, 0x01	; 1
    3cfc:	90 e0       	ldi	r25, 0x00	; 0
    3cfe:	02 c0       	rjmp	.+4      	; 0x3d04 <StartTimer16+0x74>
    3d00:	88 0f       	add	r24, r24
    3d02:	99 1f       	adc	r25, r25
    3d04:	4a 95       	dec	r20
    3d06:	e2 f7       	brpl	.-8      	; 0x3d00 <StartTimer16+0x70>
    3d08:	28 2b       	or	r18, r24
    3d0a:	20 83       	st	Z, r18
    3d0c:	e8 cf       	rjmp	.-48     	; 0x3cde <StartTimer16+0x4e>

00003d0e <StartTimer32>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
StartTimer32(uint8_t TimerN, uint32_t Timeout)
{
    3d0e:	cf 93       	push	r28
    3d10:	df 93       	push	r29
    3d12:	28 2f       	mov	r18, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3d14:	3f b7       	in	r19, 0x3f	; 63
    3d16:	30 78       	andi	r19, 0x80	; 128
    3d18:	30 93 ee 02 	sts	0x02EE, r19
	cli();
    3d1c:	f8 94       	cli
	IntOff();
	if ((Timer32[TimerN]=Timeout)>0)
    3d1e:	c8 2f       	mov	r28, r24
    3d20:	d0 e0       	ldi	r29, 0x00	; 0
    3d22:	fe 01       	movw	r30, r28
    3d24:	ee 0f       	add	r30, r30
    3d26:	ff 1f       	adc	r31, r31
    3d28:	ee 0f       	add	r30, r30
    3d2a:	ff 1f       	adc	r31, r31
    3d2c:	e1 5f       	subi	r30, 0xF1	; 241
    3d2e:	fb 4f       	sbci	r31, 0xFB	; 251
    3d30:	40 83       	st	Z, r20
    3d32:	51 83       	std	Z+1, r21	; 0x01
    3d34:	62 83       	std	Z+2, r22	; 0x02
    3d36:	73 83       	std	Z+3, r23	; 0x03
    3d38:	80 81       	ld	r24, Z
    3d3a:	91 81       	ldd	r25, Z+1	; 0x01
    3d3c:	a2 81       	ldd	r26, Z+2	; 0x02
    3d3e:	b3 81       	ldd	r27, Z+3	; 0x03
    3d40:	00 97       	sbiw	r24, 0x00	; 0
    3d42:	a1 05       	cpc	r26, r1
    3d44:	b1 05       	cpc	r27, r1
    3d46:	d1 f0       	breq	.+52     	; 0x3d7c <StartTimer32+0x6e>
		Timer32Flg[TimerN/8] &=~(1<<TimerN%8);
    3d48:	26 95       	lsr	r18
    3d4a:	26 95       	lsr	r18
    3d4c:	26 95       	lsr	r18
    3d4e:	e2 2f       	mov	r30, r18
    3d50:	f0 e0       	ldi	r31, 0x00	; 0
    3d52:	e6 53       	subi	r30, 0x36	; 54
    3d54:	fb 4f       	sbci	r31, 0xFB	; 251
    3d56:	20 81       	ld	r18, Z
    3d58:	c7 70       	andi	r28, 0x07	; 7
    3d5a:	d0 70       	andi	r29, 0x00	; 0
    3d5c:	81 e0       	ldi	r24, 0x01	; 1
    3d5e:	90 e0       	ldi	r25, 0x00	; 0
    3d60:	02 c0       	rjmp	.+4      	; 0x3d66 <StartTimer32+0x58>
    3d62:	88 0f       	add	r24, r24
    3d64:	99 1f       	adc	r25, r25
    3d66:	ca 95       	dec	r28
    3d68:	e2 f7       	brpl	.-8      	; 0x3d62 <StartTimer32+0x54>
    3d6a:	80 95       	com	r24
    3d6c:	82 23       	and	r24, r18
    3d6e:	80 83       	st	Z, r24

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3d70:	33 23       	and	r19, r19
    3d72:	09 f0       	breq	.+2      	; 0x3d76 <StartTimer32+0x68>
		sei();
    3d74:	78 94       	sei
	else
		Timer32Flg[TimerN/8] |=(1<<TimerN%8);
	IntOn();
}
    3d76:	df 91       	pop	r29
    3d78:	cf 91       	pop	r28
    3d7a:	08 95       	ret
{
	IntOff();
	if ((Timer32[TimerN]=Timeout)>0)
		Timer32Flg[TimerN/8] &=~(1<<TimerN%8);
	else
		Timer32Flg[TimerN/8] |=(1<<TimerN%8);
    3d7c:	26 95       	lsr	r18
    3d7e:	26 95       	lsr	r18
    3d80:	26 95       	lsr	r18
    3d82:	e2 2f       	mov	r30, r18
    3d84:	f0 e0       	ldi	r31, 0x00	; 0
    3d86:	e6 53       	subi	r30, 0x36	; 54
    3d88:	fb 4f       	sbci	r31, 0xFB	; 251
    3d8a:	20 81       	ld	r18, Z
    3d8c:	c7 70       	andi	r28, 0x07	; 7
    3d8e:	d0 70       	andi	r29, 0x00	; 0
    3d90:	81 e0       	ldi	r24, 0x01	; 1
    3d92:	90 e0       	ldi	r25, 0x00	; 0
    3d94:	02 c0       	rjmp	.+4      	; 0x3d9a <StartTimer32+0x8c>
    3d96:	88 0f       	add	r24, r24
    3d98:	99 1f       	adc	r25, r25
    3d9a:	ca 95       	dec	r28
    3d9c:	e2 f7       	brpl	.-8      	; 0x3d96 <StartTimer32+0x88>
    3d9e:	28 2b       	or	r18, r24
    3da0:	20 83       	st	Z, r18
    3da2:	e6 cf       	rjmp	.-52     	; 0x3d70 <StartTimer32+0x62>

00003da4 <StopTimer8_ISR>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3da4:	4f b7       	in	r20, 0x3f	; 63
    3da6:	40 78       	andi	r20, 0x80	; 128
    3da8:	40 93 ee 02 	sts	0x02EE, r20
	cli();
    3dac:	f8 94       	cli
// ~~~~~~~~~~~~~~~~~~~~~~~
void
StopTimer8_ISR(uint8_t TimerN)
{
	IntOff();
	Timer8_ISR_Flg[TimerN/8] |=(1<<TimerN%8);
    3dae:	e8 2f       	mov	r30, r24
    3db0:	e6 95       	lsr	r30
    3db2:	e6 95       	lsr	r30
    3db4:	e6 95       	lsr	r30
    3db6:	f0 e0       	ldi	r31, 0x00	; 0
    3db8:	e1 55       	subi	r30, 0x51	; 81
    3dba:	fb 4f       	sbci	r31, 0xFB	; 251
    3dbc:	90 81       	ld	r25, Z
    3dbe:	87 70       	andi	r24, 0x07	; 7
    3dc0:	21 e0       	ldi	r18, 0x01	; 1
    3dc2:	30 e0       	ldi	r19, 0x00	; 0
    3dc4:	02 c0       	rjmp	.+4      	; 0x3dca <StopTimer8_ISR+0x26>
    3dc6:	22 0f       	add	r18, r18
    3dc8:	33 1f       	adc	r19, r19
    3dca:	8a 95       	dec	r24
    3dcc:	e2 f7       	brpl	.-8      	; 0x3dc6 <StopTimer8_ISR+0x22>
    3dce:	92 2b       	or	r25, r18
    3dd0:	90 83       	st	Z, r25

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3dd2:	44 23       	and	r20, r20
    3dd4:	09 f0       	breq	.+2      	; 0x3dd8 <StopTimer8_ISR+0x34>
		sei();
    3dd6:	78 94       	sei
    3dd8:	08 95       	ret

00003dda <StopTimer8>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3dda:	4f b7       	in	r20, 0x3f	; 63
    3ddc:	40 78       	andi	r20, 0x80	; 128
    3dde:	40 93 ee 02 	sts	0x02EE, r20
	cli();
    3de2:	f8 94       	cli

void
StopTimer8(uint8_t TimerN)
{
	IntOff();
	Timer8Flg[TimerN/8] |=(1<<TimerN%8);
    3de4:	e8 2f       	mov	r30, r24
    3de6:	e6 95       	lsr	r30
    3de8:	e6 95       	lsr	r30
    3dea:	e6 95       	lsr	r30
    3dec:	f0 e0       	ldi	r31, 0x00	; 0
    3dee:	ef 54       	subi	r30, 0x4F	; 79
    3df0:	fb 4f       	sbci	r31, 0xFB	; 251
    3df2:	90 81       	ld	r25, Z
    3df4:	87 70       	andi	r24, 0x07	; 7
    3df6:	21 e0       	ldi	r18, 0x01	; 1
    3df8:	30 e0       	ldi	r19, 0x00	; 0
    3dfa:	02 c0       	rjmp	.+4      	; 0x3e00 <StopTimer8+0x26>
    3dfc:	22 0f       	add	r18, r18
    3dfe:	33 1f       	adc	r19, r19
    3e00:	8a 95       	dec	r24
    3e02:	e2 f7       	brpl	.-8      	; 0x3dfc <StopTimer8+0x22>
    3e04:	92 2b       	or	r25, r18
    3e06:	90 83       	st	Z, r25

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3e08:	44 23       	and	r20, r20
    3e0a:	09 f0       	breq	.+2      	; 0x3e0e <StopTimer8+0x34>
		sei();
    3e0c:	78 94       	sei
    3e0e:	08 95       	ret

00003e10 <StopTimer16>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3e10:	4f b7       	in	r20, 0x3f	; 63
    3e12:	40 78       	andi	r20, 0x80	; 128
    3e14:	40 93 ee 02 	sts	0x02EE, r20
	cli();
    3e18:	f8 94       	cli
// ~~~~~~~~~~~~~~~~~~~~~~~~
void
StopTimer16(uint8_t TimerN)
{
	IntOff();
	Timer16Flg[TimerN/8] |=1<<TimerN%8;
    3e1a:	e8 2f       	mov	r30, r24
    3e1c:	e6 95       	lsr	r30
    3e1e:	e6 95       	lsr	r30
    3e20:	e6 95       	lsr	r30
    3e22:	f0 e0       	ldi	r31, 0x00	; 0
    3e24:	e3 54       	subi	r30, 0x43	; 67
    3e26:	fb 4f       	sbci	r31, 0xFB	; 251
    3e28:	90 81       	ld	r25, Z
    3e2a:	87 70       	andi	r24, 0x07	; 7
    3e2c:	21 e0       	ldi	r18, 0x01	; 1
    3e2e:	30 e0       	ldi	r19, 0x00	; 0
    3e30:	02 c0       	rjmp	.+4      	; 0x3e36 <StopTimer16+0x26>
    3e32:	22 0f       	add	r18, r18
    3e34:	33 1f       	adc	r19, r19
    3e36:	8a 95       	dec	r24
    3e38:	e2 f7       	brpl	.-8      	; 0x3e32 <StopTimer16+0x22>
    3e3a:	92 2b       	or	r25, r18
    3e3c:	90 83       	st	Z, r25

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3e3e:	44 23       	and	r20, r20
    3e40:	09 f0       	breq	.+2      	; 0x3e44 <StopTimer16+0x34>
		sei();
    3e42:	78 94       	sei
    3e44:	08 95       	ret

00003e46 <StopTimer32>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3e46:	4f b7       	in	r20, 0x3f	; 63
    3e48:	40 78       	andi	r20, 0x80	; 128
    3e4a:	40 93 ee 02 	sts	0x02EE, r20
	cli();
    3e4e:	f8 94       	cli
// ~~~~~~~~~~~~~~~~~~~~~~~~
void
StopTimer32(uint8_t TimerN)
{
	IntOff();
	Timer32Flg[TimerN/8] |=1<<TimerN%8;
    3e50:	e8 2f       	mov	r30, r24
    3e52:	e6 95       	lsr	r30
    3e54:	e6 95       	lsr	r30
    3e56:	e6 95       	lsr	r30
    3e58:	f0 e0       	ldi	r31, 0x00	; 0
    3e5a:	e6 53       	subi	r30, 0x36	; 54
    3e5c:	fb 4f       	sbci	r31, 0xFB	; 251
    3e5e:	90 81       	ld	r25, Z
    3e60:	87 70       	andi	r24, 0x07	; 7
    3e62:	21 e0       	ldi	r18, 0x01	; 1
    3e64:	30 e0       	ldi	r19, 0x00	; 0
    3e66:	02 c0       	rjmp	.+4      	; 0x3e6c <StopTimer32+0x26>
    3e68:	22 0f       	add	r18, r18
    3e6a:	33 1f       	adc	r19, r19
    3e6c:	8a 95       	dec	r24
    3e6e:	e2 f7       	brpl	.-8      	; 0x3e68 <StopTimer32+0x22>
    3e70:	92 2b       	or	r25, r18
    3e72:	90 83       	st	Z, r25

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3e74:	44 23       	and	r20, r20
    3e76:	09 f0       	breq	.+2      	; 0x3e7a <StopTimer32+0x34>
		sei();
    3e78:	78 94       	sei
    3e7a:	08 95       	ret

00003e7c <Timer8Stopp_ISR>:
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer8Stopp_ISR(uint8_t TimerN)
{
	return (Timer8_ISR_Flg[TimerN/8] &(1<<TimerN%8)) && Timer8_ISR[TimerN]==0;
    3e7c:	e8 2f       	mov	r30, r24
    3e7e:	e6 95       	lsr	r30
    3e80:	e6 95       	lsr	r30
    3e82:	e6 95       	lsr	r30
    3e84:	f0 e0       	ldi	r31, 0x00	; 0
    3e86:	e1 55       	subi	r30, 0x51	; 81
    3e88:	fb 4f       	sbci	r31, 0xFB	; 251
    3e8a:	20 81       	ld	r18, Z
    3e8c:	e8 2f       	mov	r30, r24
    3e8e:	f0 e0       	ldi	r31, 0x00	; 0
    3e90:	30 e0       	ldi	r19, 0x00	; 0
    3e92:	cf 01       	movw	r24, r30
    3e94:	87 70       	andi	r24, 0x07	; 7
    3e96:	90 70       	andi	r25, 0x00	; 0
    3e98:	02 c0       	rjmp	.+4      	; 0x3e9e <Timer8Stopp_ISR+0x22>
    3e9a:	35 95       	asr	r19
    3e9c:	27 95       	ror	r18
    3e9e:	8a 95       	dec	r24
    3ea0:	e2 f7       	brpl	.-8      	; 0x3e9a <Timer8Stopp_ISR+0x1e>
    3ea2:	20 fd       	sbrc	r18, 0
    3ea4:	02 c0       	rjmp	.+4      	; 0x3eaa <Timer8Stopp_ISR+0x2e>
    3ea6:	80 e0       	ldi	r24, 0x00	; 0
    3ea8:	08 95       	ret
    3eaa:	e1 51       	subi	r30, 0x11	; 17
    3eac:	fd 4f       	sbci	r31, 0xFD	; 253
    3eae:	90 81       	ld	r25, Z
    3eb0:	99 23       	and	r25, r25
    3eb2:	19 f4       	brne	.+6      	; 0x3eba <Timer8Stopp_ISR+0x3e>
    3eb4:	81 e0       	ldi	r24, 0x01	; 1
    3eb6:	89 27       	eor	r24, r25
}
    3eb8:	08 95       	ret
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer8Stopp_ISR(uint8_t TimerN)
{
	return (Timer8_ISR_Flg[TimerN/8] &(1<<TimerN%8)) && Timer8_ISR[TimerN]==0;
    3eba:	91 e0       	ldi	r25, 0x01	; 1
    3ebc:	81 e0       	ldi	r24, 0x01	; 1
    3ebe:	89 27       	eor	r24, r25
}
    3ec0:	08 95       	ret

00003ec2 <Timer8Stopp>:

// ~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer8Stopp(uint8_t TimerN)
{
	return (Timer8Flg[TimerN/8] &(1<<TimerN%8)) && Timer8[TimerN]==0;
    3ec2:	e8 2f       	mov	r30, r24
    3ec4:	e6 95       	lsr	r30
    3ec6:	e6 95       	lsr	r30
    3ec8:	e6 95       	lsr	r30
    3eca:	f0 e0       	ldi	r31, 0x00	; 0
    3ecc:	ef 54       	subi	r30, 0x4F	; 79
    3ece:	fb 4f       	sbci	r31, 0xFB	; 251
    3ed0:	20 81       	ld	r18, Z
    3ed2:	e8 2f       	mov	r30, r24
    3ed4:	f0 e0       	ldi	r31, 0x00	; 0
    3ed6:	30 e0       	ldi	r19, 0x00	; 0
    3ed8:	cf 01       	movw	r24, r30
    3eda:	87 70       	andi	r24, 0x07	; 7
    3edc:	90 70       	andi	r25, 0x00	; 0
    3ede:	02 c0       	rjmp	.+4      	; 0x3ee4 <Timer8Stopp+0x22>
    3ee0:	35 95       	asr	r19
    3ee2:	27 95       	ror	r18
    3ee4:	8a 95       	dec	r24
    3ee6:	e2 f7       	brpl	.-8      	; 0x3ee0 <Timer8Stopp+0x1e>
    3ee8:	20 fd       	sbrc	r18, 0
    3eea:	02 c0       	rjmp	.+4      	; 0x3ef0 <Timer8Stopp+0x2e>
    3eec:	80 e0       	ldi	r24, 0x00	; 0
    3eee:	08 95       	ret
    3ef0:	e9 50       	subi	r30, 0x09	; 9
    3ef2:	fd 4f       	sbci	r31, 0xFD	; 253
    3ef4:	90 81       	ld	r25, Z
    3ef6:	99 23       	and	r25, r25
    3ef8:	19 f4       	brne	.+6      	; 0x3f00 <Timer8Stopp+0x3e>
    3efa:	81 e0       	ldi	r24, 0x01	; 1
    3efc:	89 27       	eor	r24, r25
}
    3efe:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer8Stopp(uint8_t TimerN)
{
	return (Timer8Flg[TimerN/8] &(1<<TimerN%8)) && Timer8[TimerN]==0;
    3f00:	91 e0       	ldi	r25, 0x01	; 1
    3f02:	81 e0       	ldi	r24, 0x01	; 1
    3f04:	89 27       	eor	r24, r25
}
    3f06:	08 95       	ret

00003f08 <Timer16Stopp>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3f08:	4f b7       	in	r20, 0x3f	; 63
    3f0a:	40 78       	andi	r20, 0x80	; 128
    3f0c:	40 93 ee 02 	sts	0x02EE, r20
	cli();
    3f10:	f8 94       	cli
// ~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16Stopp(uint8_t TimerN)
{
	IntOff();
	uint8_t T_S = (Timer16Flg[TimerN/8] &(1<<TimerN%8)) && Timer16[TimerN]==0;
    3f12:	e8 2f       	mov	r30, r24
    3f14:	e6 95       	lsr	r30
    3f16:	e6 95       	lsr	r30
    3f18:	e6 95       	lsr	r30
    3f1a:	f0 e0       	ldi	r31, 0x00	; 0
    3f1c:	e3 54       	subi	r30, 0x43	; 67
    3f1e:	fb 4f       	sbci	r31, 0xFB	; 251
    3f20:	20 81       	ld	r18, Z
    3f22:	e8 2f       	mov	r30, r24
    3f24:	f0 e0       	ldi	r31, 0x00	; 0
    3f26:	30 e0       	ldi	r19, 0x00	; 0
    3f28:	cf 01       	movw	r24, r30
    3f2a:	87 70       	andi	r24, 0x07	; 7
    3f2c:	90 70       	andi	r25, 0x00	; 0
    3f2e:	02 c0       	rjmp	.+4      	; 0x3f34 <Timer16Stopp+0x2c>
    3f30:	35 95       	asr	r19
    3f32:	27 95       	ror	r18
    3f34:	8a 95       	dec	r24
    3f36:	e2 f7       	brpl	.-8      	; 0x3f30 <Timer16Stopp+0x28>
    3f38:	20 fd       	sbrc	r18, 0
    3f3a:	06 c0       	rjmp	.+12     	; 0x3f48 <Timer16Stopp+0x40>
    3f3c:	20 e0       	ldi	r18, 0x00	; 0

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3f3e:	44 23       	and	r20, r20
    3f40:	09 f0       	breq	.+2      	; 0x3f44 <Timer16Stopp+0x3c>
		sei();
    3f42:	78 94       	sei
	IntOn();
	return T_S;
}
    3f44:	82 2f       	mov	r24, r18
    3f46:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16Stopp(uint8_t TimerN)
{
	IntOff();
	uint8_t T_S = (Timer16Flg[TimerN/8] &(1<<TimerN%8)) && Timer16[TimerN]==0;
    3f48:	ee 0f       	add	r30, r30
    3f4a:	ff 1f       	adc	r31, r31
    3f4c:	e1 5b       	subi	r30, 0xB1	; 177
    3f4e:	fc 4f       	sbci	r31, 0xFC	; 252
    3f50:	80 81       	ld	r24, Z
    3f52:	91 81       	ldd	r25, Z+1	; 0x01
    3f54:	20 e0       	ldi	r18, 0x00	; 0
    3f56:	89 2b       	or	r24, r25
    3f58:	19 f4       	brne	.+6      	; 0x3f60 <Timer16Stopp+0x58>
    3f5a:	81 e0       	ldi	r24, 0x01	; 1
    3f5c:	28 27       	eor	r18, r24
    3f5e:	ef cf       	rjmp	.-34     	; 0x3f3e <Timer16Stopp+0x36>
    3f60:	21 e0       	ldi	r18, 0x01	; 1
    3f62:	81 e0       	ldi	r24, 0x01	; 1
    3f64:	28 27       	eor	r18, r24
    3f66:	eb cf       	rjmp	.-42     	; 0x3f3e <Timer16Stopp+0x36>

00003f68 <Timer32Stopp>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3f68:	4f b7       	in	r20, 0x3f	; 63
    3f6a:	40 78       	andi	r20, 0x80	; 128
    3f6c:	40 93 ee 02 	sts	0x02EE, r20
	cli();
    3f70:	f8 94       	cli
// ~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer32Stopp(uint8_t TimerN)
{
	IntOff();
	uint8_t T_S = (Timer32Flg[TimerN/8] &(1<<TimerN%8)) && Timer32[TimerN]==0;
    3f72:	e8 2f       	mov	r30, r24
    3f74:	e6 95       	lsr	r30
    3f76:	e6 95       	lsr	r30
    3f78:	e6 95       	lsr	r30
    3f7a:	f0 e0       	ldi	r31, 0x00	; 0
    3f7c:	e6 53       	subi	r30, 0x36	; 54
    3f7e:	fb 4f       	sbci	r31, 0xFB	; 251
    3f80:	20 81       	ld	r18, Z
    3f82:	e8 2f       	mov	r30, r24
    3f84:	f0 e0       	ldi	r31, 0x00	; 0
    3f86:	30 e0       	ldi	r19, 0x00	; 0
    3f88:	cf 01       	movw	r24, r30
    3f8a:	87 70       	andi	r24, 0x07	; 7
    3f8c:	90 70       	andi	r25, 0x00	; 0
    3f8e:	02 c0       	rjmp	.+4      	; 0x3f94 <Timer32Stopp+0x2c>
    3f90:	35 95       	asr	r19
    3f92:	27 95       	ror	r18
    3f94:	8a 95       	dec	r24
    3f96:	e2 f7       	brpl	.-8      	; 0x3f90 <Timer32Stopp+0x28>
    3f98:	20 fd       	sbrc	r18, 0
    3f9a:	06 c0       	rjmp	.+12     	; 0x3fa8 <Timer32Stopp+0x40>
    3f9c:	20 e0       	ldi	r18, 0x00	; 0

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3f9e:	44 23       	and	r20, r20
    3fa0:	09 f0       	breq	.+2      	; 0x3fa4 <Timer32Stopp+0x3c>
		sei();
    3fa2:	78 94       	sei
	IntOn();
	return T_S;
}
    3fa4:	82 2f       	mov	r24, r18
    3fa6:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer32Stopp(uint8_t TimerN)
{
	IntOff();
	uint8_t T_S = (Timer32Flg[TimerN/8] &(1<<TimerN%8)) && Timer32[TimerN]==0;
    3fa8:	ee 0f       	add	r30, r30
    3faa:	ff 1f       	adc	r31, r31
    3fac:	ee 0f       	add	r30, r30
    3fae:	ff 1f       	adc	r31, r31
    3fb0:	e1 5f       	subi	r30, 0xF1	; 241
    3fb2:	fb 4f       	sbci	r31, 0xFB	; 251
    3fb4:	80 81       	ld	r24, Z
    3fb6:	91 81       	ldd	r25, Z+1	; 0x01
    3fb8:	a2 81       	ldd	r26, Z+2	; 0x02
    3fba:	b3 81       	ldd	r27, Z+3	; 0x03
    3fbc:	20 e0       	ldi	r18, 0x00	; 0
    3fbe:	00 97       	sbiw	r24, 0x00	; 0
    3fc0:	a1 05       	cpc	r26, r1
    3fc2:	b1 05       	cpc	r27, r1
    3fc4:	19 f4       	brne	.+6      	; 0x3fcc <Timer32Stopp+0x64>
    3fc6:	81 e0       	ldi	r24, 0x01	; 1
    3fc8:	28 27       	eor	r18, r24
    3fca:	e9 cf       	rjmp	.-46     	; 0x3f9e <Timer32Stopp+0x36>
    3fcc:	21 e0       	ldi	r18, 0x01	; 1
    3fce:	81 e0       	ldi	r24, 0x01	; 1
    3fd0:	28 27       	eor	r18, r24
    3fd2:	e5 cf       	rjmp	.-54     	; 0x3f9e <Timer32Stopp+0x36>

00003fd4 <ResetTimer8_ISR>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3fd4:	5f b7       	in	r21, 0x3f	; 63
    3fd6:	50 78       	andi	r21, 0x80	; 128
    3fd8:	50 93 ee 02 	sts	0x02EE, r21
	cli();
    3fdc:	f8 94       	cli
//~~~~~~~~~~~~~~~~~~~~~~~~~
void
ResetTimer8_ISR(uint8_t TimerN)
{
	IntOff();
	Timer8_ISR_Flg[TimerN/8] |=(1<<TimerN%8);
    3fde:	e8 2f       	mov	r30, r24
    3fe0:	e6 95       	lsr	r30
    3fe2:	e6 95       	lsr	r30
    3fe4:	e6 95       	lsr	r30
    3fe6:	f0 e0       	ldi	r31, 0x00	; 0
    3fe8:	e1 55       	subi	r30, 0x51	; 81
    3fea:	fb 4f       	sbci	r31, 0xFB	; 251
    3fec:	40 81       	ld	r20, Z
    3fee:	a8 2f       	mov	r26, r24
    3ff0:	b0 e0       	ldi	r27, 0x00	; 0
    3ff2:	9d 01       	movw	r18, r26
    3ff4:	27 70       	andi	r18, 0x07	; 7
    3ff6:	30 70       	andi	r19, 0x00	; 0
    3ff8:	81 e0       	ldi	r24, 0x01	; 1
    3ffa:	90 e0       	ldi	r25, 0x00	; 0
    3ffc:	02 c0       	rjmp	.+4      	; 0x4002 <ResetTimer8_ISR+0x2e>
    3ffe:	88 0f       	add	r24, r24
    4000:	99 1f       	adc	r25, r25
    4002:	2a 95       	dec	r18
    4004:	e2 f7       	brpl	.-8      	; 0x3ffe <ResetTimer8_ISR+0x2a>
    4006:	48 2b       	or	r20, r24
    4008:	40 83       	st	Z, r20

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    400a:	55 23       	and	r21, r21
    400c:	09 f0       	breq	.+2      	; 0x4010 <ResetTimer8_ISR+0x3c>
		sei();
    400e:	78 94       	sei
	IntOn();
	Timer8_ISR[TimerN] = 0;
    4010:	a1 51       	subi	r26, 0x11	; 17
    4012:	bd 4f       	sbci	r27, 0xFD	; 253
    4014:	1c 92       	st	X, r1
}
    4016:	08 95       	ret

00004018 <ResetTimer8>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    4018:	5f b7       	in	r21, 0x3f	; 63
    401a:	50 78       	andi	r21, 0x80	; 128
    401c:	50 93 ee 02 	sts	0x02EE, r21
	cli();
    4020:	f8 94       	cli

void
ResetTimer8(uint8_t TimerN)
{
	IntOff();
	Timer8Flg[TimerN/8] |=(1<<TimerN%8);
    4022:	e8 2f       	mov	r30, r24
    4024:	e6 95       	lsr	r30
    4026:	e6 95       	lsr	r30
    4028:	e6 95       	lsr	r30
    402a:	f0 e0       	ldi	r31, 0x00	; 0
    402c:	ef 54       	subi	r30, 0x4F	; 79
    402e:	fb 4f       	sbci	r31, 0xFB	; 251
    4030:	40 81       	ld	r20, Z
    4032:	a8 2f       	mov	r26, r24
    4034:	b0 e0       	ldi	r27, 0x00	; 0
    4036:	9d 01       	movw	r18, r26
    4038:	27 70       	andi	r18, 0x07	; 7
    403a:	30 70       	andi	r19, 0x00	; 0
    403c:	81 e0       	ldi	r24, 0x01	; 1
    403e:	90 e0       	ldi	r25, 0x00	; 0
    4040:	02 c0       	rjmp	.+4      	; 0x4046 <ResetTimer8+0x2e>
    4042:	88 0f       	add	r24, r24
    4044:	99 1f       	adc	r25, r25
    4046:	2a 95       	dec	r18
    4048:	e2 f7       	brpl	.-8      	; 0x4042 <ResetTimer8+0x2a>
    404a:	48 2b       	or	r20, r24
    404c:	40 83       	st	Z, r20

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    404e:	55 23       	and	r21, r21
    4050:	09 f0       	breq	.+2      	; 0x4054 <ResetTimer8+0x3c>
		sei();
    4052:	78 94       	sei
	IntOn();
	Timer8[TimerN] = 0;
    4054:	a9 50       	subi	r26, 0x09	; 9
    4056:	bd 4f       	sbci	r27, 0xFD	; 253
    4058:	1c 92       	st	X, r1
}
    405a:	08 95       	ret

0000405c <ResetTimer16>:

//~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ResetTimer16(uint8_t TimerN)
{
    405c:	e8 2f       	mov	r30, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    405e:	5f b7       	in	r21, 0x3f	; 63
    4060:	50 78       	andi	r21, 0x80	; 128
    4062:	50 93 ee 02 	sts	0x02EE, r21
	cli();
    4066:	f8 94       	cli
	IntOff();
	Timer16Flg[TimerN/8] |=1<<TimerN%8;
    4068:	a8 2f       	mov	r26, r24
    406a:	a6 95       	lsr	r26
    406c:	a6 95       	lsr	r26
    406e:	a6 95       	lsr	r26
    4070:	b0 e0       	ldi	r27, 0x00	; 0
    4072:	a3 54       	subi	r26, 0x43	; 67
    4074:	bb 4f       	sbci	r27, 0xFB	; 251
    4076:	4c 91       	ld	r20, X
    4078:	f0 e0       	ldi	r31, 0x00	; 0
    407a:	9f 01       	movw	r18, r30
    407c:	27 70       	andi	r18, 0x07	; 7
    407e:	30 70       	andi	r19, 0x00	; 0
    4080:	81 e0       	ldi	r24, 0x01	; 1
    4082:	90 e0       	ldi	r25, 0x00	; 0
    4084:	02 c0       	rjmp	.+4      	; 0x408a <ResetTimer16+0x2e>
    4086:	88 0f       	add	r24, r24
    4088:	99 1f       	adc	r25, r25
    408a:	2a 95       	dec	r18
    408c:	e2 f7       	brpl	.-8      	; 0x4086 <ResetTimer16+0x2a>
    408e:	48 2b       	or	r20, r24
    4090:	4c 93       	st	X, r20
	Timer16[TimerN] = 0;
    4092:	ee 0f       	add	r30, r30
    4094:	ff 1f       	adc	r31, r31
    4096:	e1 5b       	subi	r30, 0xB1	; 177
    4098:	fc 4f       	sbci	r31, 0xFC	; 252
    409a:	11 82       	std	Z+1, r1	; 0x01
    409c:	10 82       	st	Z, r1

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    409e:	55 23       	and	r21, r21
    40a0:	09 f0       	breq	.+2      	; 0x40a4 <ResetTimer16+0x48>
		sei();
    40a2:	78 94       	sei
    40a4:	08 95       	ret

000040a6 <ResetTimer32>:
}

//~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ResetTimer32(uint8_t TimerN)
{
    40a6:	e8 2f       	mov	r30, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    40a8:	5f b7       	in	r21, 0x3f	; 63
    40aa:	50 78       	andi	r21, 0x80	; 128
    40ac:	50 93 ee 02 	sts	0x02EE, r21
	cli();
    40b0:	f8 94       	cli
	IntOff();
	Timer32Flg[TimerN/8] |=1<<TimerN%8;
    40b2:	a8 2f       	mov	r26, r24
    40b4:	a6 95       	lsr	r26
    40b6:	a6 95       	lsr	r26
    40b8:	a6 95       	lsr	r26
    40ba:	b0 e0       	ldi	r27, 0x00	; 0
    40bc:	a6 53       	subi	r26, 0x36	; 54
    40be:	bb 4f       	sbci	r27, 0xFB	; 251
    40c0:	4c 91       	ld	r20, X
    40c2:	f0 e0       	ldi	r31, 0x00	; 0
    40c4:	9f 01       	movw	r18, r30
    40c6:	27 70       	andi	r18, 0x07	; 7
    40c8:	30 70       	andi	r19, 0x00	; 0
    40ca:	81 e0       	ldi	r24, 0x01	; 1
    40cc:	90 e0       	ldi	r25, 0x00	; 0
    40ce:	02 c0       	rjmp	.+4      	; 0x40d4 <ResetTimer32+0x2e>
    40d0:	88 0f       	add	r24, r24
    40d2:	99 1f       	adc	r25, r25
    40d4:	2a 95       	dec	r18
    40d6:	e2 f7       	brpl	.-8      	; 0x40d0 <ResetTimer32+0x2a>
    40d8:	48 2b       	or	r20, r24
    40da:	4c 93       	st	X, r20
	Timer32[TimerN] = 0;
    40dc:	ee 0f       	add	r30, r30
    40de:	ff 1f       	adc	r31, r31
    40e0:	ee 0f       	add	r30, r30
    40e2:	ff 1f       	adc	r31, r31
    40e4:	e1 5f       	subi	r30, 0xF1	; 241
    40e6:	fb 4f       	sbci	r31, 0xFB	; 251
    40e8:	10 82       	st	Z, r1
    40ea:	11 82       	std	Z+1, r1	; 0x01
    40ec:	12 82       	std	Z+2, r1	; 0x02
    40ee:	13 82       	std	Z+3, r1	; 0x03

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    40f0:	55 23       	and	r21, r21
    40f2:	09 f0       	breq	.+2      	; 0x40f6 <ResetTimer32+0x50>
		sei();
    40f4:	78 94       	sei
    40f6:	08 95       	ret

000040f8 <GetTimer8_ISR>:

// ~~~~~~~~~~~~~~~~~~~~~~
uint8_t
GetTimer8_ISR(uint8_t TimerN)
{
	return Timer8_ISR[TimerN];
    40f8:	ef ee       	ldi	r30, 0xEF	; 239
    40fa:	f2 e0       	ldi	r31, 0x02	; 2
    40fc:	e8 0f       	add	r30, r24
    40fe:	f1 1d       	adc	r31, r1
    4100:	80 81       	ld	r24, Z
}
    4102:	08 95       	ret

00004104 <GetTimer8>:
uint8_t
GetTimer8(uint8_t TimerN)
{
	return Timer8[TimerN];
    4104:	e7 ef       	ldi	r30, 0xF7	; 247
    4106:	f2 e0       	ldi	r31, 0x02	; 2
    4108:	e8 0f       	add	r30, r24
    410a:	f1 1d       	adc	r31, r1
    410c:	80 81       	ld	r24, Z
}
    410e:	08 95       	ret

00004110 <GetTimer16>:

// ~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
GetTimer16(uint8_t TimerN)
{
    4110:	e8 2f       	mov	r30, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    4112:	8f b7       	in	r24, 0x3f	; 63
    4114:	80 78       	andi	r24, 0x80	; 128
    4116:	80 93 ee 02 	sts	0x02EE, r24
	cli();
    411a:	f8 94       	cli
	IntOff();
	uint16_t Time = Timer16[TimerN];
    411c:	f0 e0       	ldi	r31, 0x00	; 0
    411e:	ee 0f       	add	r30, r30
    4120:	ff 1f       	adc	r31, r31
    4122:	e1 5b       	subi	r30, 0xB1	; 177
    4124:	fc 4f       	sbci	r31, 0xFC	; 252
    4126:	01 90       	ld	r0, Z+
    4128:	f0 81       	ld	r31, Z
    412a:	e0 2d       	mov	r30, r0

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    412c:	88 23       	and	r24, r24
    412e:	09 f0       	breq	.+2      	; 0x4132 <GetTimer16+0x22>
		sei();
    4130:	78 94       	sei
	IntOn();
	return Time;
}
    4132:	cf 01       	movw	r24, r30
    4134:	08 95       	ret

00004136 <GetTimer32>:

// ~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
GetTimer32(uint8_t TimerN)
{
    4136:	e8 2f       	mov	r30, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    4138:	8f b7       	in	r24, 0x3f	; 63
    413a:	80 78       	andi	r24, 0x80	; 128
    413c:	80 93 ee 02 	sts	0x02EE, r24
	cli();
    4140:	f8 94       	cli
	IntOff();
	uint32_t Time = Timer32[TimerN];
    4142:	f0 e0       	ldi	r31, 0x00	; 0
    4144:	ee 0f       	add	r30, r30
    4146:	ff 1f       	adc	r31, r31
    4148:	ee 0f       	add	r30, r30
    414a:	ff 1f       	adc	r31, r31
    414c:	e1 5f       	subi	r30, 0xF1	; 241
    414e:	fb 4f       	sbci	r31, 0xFB	; 251
    4150:	20 81       	ld	r18, Z
    4152:	31 81       	ldd	r19, Z+1	; 0x01
    4154:	42 81       	ldd	r20, Z+2	; 0x02
    4156:	53 81       	ldd	r21, Z+3	; 0x03

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    4158:	88 23       	and	r24, r24
    415a:	09 f0       	breq	.+2      	; 0x415e <GetTimer32+0x28>
		sei();
    415c:	78 94       	sei
	IntOn();
	return Time;
}
    415e:	b9 01       	movw	r22, r18
    4160:	ca 01       	movw	r24, r20
    4162:	08 95       	ret

00004164 <TimerAllocError>:
// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t TimerAllocError(void){
	return ( (VacantTimer8Sys >=  Timer8TotNumber) || (VacantTimer16Sys >=  Timer16TotNumber) || (VacantTimer32Sys >=  Timer32TotNumber) ||
    4164:	80 91 cf 02 	lds	r24, 0x02CF
    4168:	88 35       	cpi	r24, 0x58	; 88
    416a:	a8 f4       	brcc	.+42     	; 0x4196 <TimerAllocError+0x32>
    416c:	80 91 d0 02 	lds	r24, 0x02D0
    4170:	80 36       	cpi	r24, 0x60	; 96
    4172:	88 f4       	brcc	.+34     	; 0x4196 <TimerAllocError+0x32>
    4174:	80 91 d1 02 	lds	r24, 0x02D1
    4178:	88 32       	cpi	r24, 0x28	; 40
    417a:	68 f4       	brcc	.+26     	; 0x4196 <TimerAllocError+0x32>
    417c:	80 91 cc 02 	lds	r24, 0x02CC
    4180:	80 34       	cpi	r24, 0x40	; 64
    4182:	48 f4       	brcc	.+18     	; 0x4196 <TimerAllocError+0x32>
    4184:	80 91 cd 02 	lds	r24, 0x02CD
    4188:	88 34       	cpi	r24, 0x48	; 72
    418a:	28 f4       	brcc	.+10     	; 0x4196 <TimerAllocError+0x32>
    418c:	90 e0       	ldi	r25, 0x00	; 0
    418e:	80 91 ce 02 	lds	r24, 0x02CE
    4192:	80 32       	cpi	r24, 0x20	; 32
    4194:	08 f0       	brcs	.+2      	; 0x4198 <TimerAllocError+0x34>
    4196:	91 e0       	ldi	r25, 0x01	; 1
		 Timer8AllocErr() || Timer16AllocErr() || Timer32AllocErr() );
}
    4198:	89 2f       	mov	r24, r25
    419a:	08 95       	ret

0000419c <ScanCycleInit>:
}

uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    419c:	80 91 cf 02 	lds	r24, 0x02CF
	VacantTimer8Sys += n;
    41a0:	8f 5f       	subi	r24, 0xFF	; 255
    41a2:	80 93 cf 02 	sts	0x02CF, r24
    41a6:	81 50       	subi	r24, 0x01	; 1

// ~~~~~~~~~~~~~~~~
void
ScanCycleInit(void)
{
	TD_Scan = Timer8SysAlloc(1);
    41a8:	80 93 d0 04 	sts	0x04D0, r24
	StartTimer8(TD_Scan, 0xFF);
    41ac:	6f ef       	ldi	r22, 0xFF	; 255
    41ae:	0e 94 0d 1e 	call	0x3c1a	; 0x3c1a <StartTimer8>
}
    41b2:	08 95       	ret

000041b4 <__vector_17>:
#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
	ISR(TIMER1_COMPA_vect)
#elif defined (__AVR_ATxmega128A1__)
	ISR(TCC0_OVF_vect)
#endif
{
    41b4:	1f 92       	push	r1
    41b6:	0f 92       	push	r0
    41b8:	0f b6       	in	r0, 0x3f	; 63
    41ba:	0f 92       	push	r0
    41bc:	0b b6       	in	r0, 0x3b	; 59
    41be:	0f 92       	push	r0
    41c0:	11 24       	eor	r1, r1
    41c2:	2f 93       	push	r18
    41c4:	4f 93       	push	r20
    41c6:	5f 93       	push	r21
    41c8:	6f 93       	push	r22
    41ca:	7f 93       	push	r23
    41cc:	8f 93       	push	r24
    41ce:	9f 93       	push	r25
    41d0:	af 93       	push	r26
    41d2:	bf 93       	push	r27
    41d4:	ef 93       	push	r30
    41d6:	ff 93       	push	r31
	TickCounter++;
    41d8:	80 91 d1 04 	lds	r24, 0x04D1
    41dc:	8f 5f       	subi	r24, 0xFF	; 255
    41de:	80 93 d1 04 	sts	0x04D1, r24
    41e2:	40 e0       	ldi	r20, 0x00	; 0
    41e4:	50 e0       	ldi	r21, 0x00	; 0
	uint8_t i;
	for (i=0; i<Timer8_ISR_TotNumber; i++)
			if (!(Timer8_ISR_Flg[i/8] &(1<<i%8)) && --Timer8_ISR[i]==0)
				Timer8_ISR_Flg[i/8] |=(1<<i%8);
    41e6:	a1 e0       	ldi	r26, 0x01	; 1
    41e8:	b0 e0       	ldi	r27, 0x00	; 0
#endif
{
	TickCounter++;
	uint8_t i;
	for (i=0; i<Timer8_ISR_TotNumber; i++)
			if (!(Timer8_ISR_Flg[i/8] &(1<<i%8)) && --Timer8_ISR[i]==0)
    41ea:	80 91 af 04 	lds	r24, 0x04AF
    41ee:	ba 01       	movw	r22, r20
    41f0:	67 70       	andi	r22, 0x07	; 7
    41f2:	70 70       	andi	r23, 0x00	; 0
    41f4:	90 e0       	ldi	r25, 0x00	; 0
    41f6:	06 2e       	mov	r0, r22
    41f8:	02 c0       	rjmp	.+4      	; 0x41fe <__vector_17+0x4a>
    41fa:	95 95       	asr	r25
    41fc:	87 95       	ror	r24
    41fe:	0a 94       	dec	r0
    4200:	e2 f7       	brpl	.-8      	; 0x41fa <__vector_17+0x46>
    4202:	80 fd       	sbrc	r24, 0
    4204:	14 c0       	rjmp	.+40     	; 0x422e <__vector_17+0x7a>
    4206:	fa 01       	movw	r30, r20
    4208:	e1 51       	subi	r30, 0x11	; 17
    420a:	fd 4f       	sbci	r31, 0xFD	; 253
    420c:	80 81       	ld	r24, Z
    420e:	81 50       	subi	r24, 0x01	; 1
    4210:	80 83       	st	Z, r24
    4212:	80 81       	ld	r24, Z
    4214:	88 23       	and	r24, r24
    4216:	59 f4       	brne	.+22     	; 0x422e <__vector_17+0x7a>
				Timer8_ISR_Flg[i/8] |=(1<<i%8);
    4218:	20 91 af 04 	lds	r18, 0x04AF
    421c:	cd 01       	movw	r24, r26
    421e:	02 c0       	rjmp	.+4      	; 0x4224 <__vector_17+0x70>
    4220:	88 0f       	add	r24, r24
    4222:	99 1f       	adc	r25, r25
    4224:	6a 95       	dec	r22
    4226:	e2 f7       	brpl	.-8      	; 0x4220 <__vector_17+0x6c>
    4228:	28 2b       	or	r18, r24
    422a:	20 93 af 04 	sts	0x04AF, r18
    422e:	4f 5f       	subi	r20, 0xFF	; 255
    4230:	5f 4f       	sbci	r21, 0xFF	; 255
	ISR(TCC0_OVF_vect)
#endif
{
	TickCounter++;
	uint8_t i;
	for (i=0; i<Timer8_ISR_TotNumber; i++)
    4232:	48 30       	cpi	r20, 0x08	; 8
    4234:	51 05       	cpc	r21, r1
    4236:	c9 f6       	brne	.-78     	; 0x41ea <__vector_17+0x36>
				Timer8_ISR_Flg[i/8] |=(1<<i%8);

	#ifdef HIGH_SPEED_COUNTER
		HSC_Process();
	#endif
}
    4238:	ff 91       	pop	r31
    423a:	ef 91       	pop	r30
    423c:	bf 91       	pop	r27
    423e:	af 91       	pop	r26
    4240:	9f 91       	pop	r25
    4242:	8f 91       	pop	r24
    4244:	7f 91       	pop	r23
    4246:	6f 91       	pop	r22
    4248:	5f 91       	pop	r21
    424a:	4f 91       	pop	r20
    424c:	2f 91       	pop	r18
    424e:	0f 90       	pop	r0
    4250:	0b be       	out	0x3b, r0	; 59
    4252:	0f 90       	pop	r0
    4254:	0f be       	out	0x3f, r0	; 63
    4256:	0f 90       	pop	r0
    4258:	1f 90       	pop	r1
    425a:	18 95       	reti

0000425c <TimeCycle>:
// ~~~~~~~~~~~~
void
TimeCycle(void)
{
	// WDT
	wdt_reset();
    425c:	a8 95       	wdr

	// Scan cycle
	ScanCount++;
    425e:	80 91 b2 07 	lds	r24, 0x07B2
    4262:	90 91 b3 07 	lds	r25, 0x07B3
    4266:	01 96       	adiw	r24, 0x01	; 1
    4268:	90 93 b3 07 	sts	0x07B3, r25
    426c:	80 93 b2 07 	sts	0x07B2, r24
	if ((ScanCycle=0xFF-Timer8[TD_Scan])>MaxScanCycle)
    4270:	90 91 d0 04 	lds	r25, 0x04D0
    4274:	e9 2f       	mov	r30, r25
    4276:	f0 e0       	ldi	r31, 0x00	; 0
    4278:	e9 50       	subi	r30, 0x09	; 9
    427a:	fd 4f       	sbci	r31, 0xFD	; 253
    427c:	e0 81       	ld	r30, Z
    427e:	e0 95       	com	r30
    4280:	e0 93 ae 07 	sts	0x07AE, r30
    4284:	80 91 b1 06 	lds	r24, 0x06B1
    4288:	8e 17       	cp	r24, r30
    428a:	10 f4       	brcc	.+4      	; 0x4290 <TimeCycle+0x34>
		MaxScanCycle = ScanCycle;
    428c:	e0 93 b1 06 	sts	0x06B1, r30
	StartTimer8(TD_Scan, 0xFF);
    4290:	89 2f       	mov	r24, r25
    4292:	6f ef       	ldi	r22, 0xFF	; 255
    4294:	0e 94 0d 1e 	call	0x3c1a	; 0x3c1a <StartTimer8>
}
    4298:	08 95       	ret

0000429a <MaxScanCycle_Clear>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
void
MaxScanCycle_Clear(void)
{
	MaxScanCycle = 0;
    429a:	10 92 b1 06 	sts	0x06B1, r1
}
    429e:	08 95       	ret

000042a0 <Delay_ms>:

// ~~~~~~~~~~~~~~~~~~~~
void
Delay_ms(uint8_t Delay)
{
	while (Delay--)
    42a0:	88 23       	and	r24, r24
    42a2:	39 f0       	breq	.+14     	; 0x42b2 <Delay_ms+0x12>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    42a4:	20 ea       	ldi	r18, 0xA0	; 160
    42a6:	3f e0       	ldi	r19, 0x0F	; 15
    42a8:	f9 01       	movw	r30, r18
    42aa:	31 97       	sbiw	r30, 0x01	; 1
    42ac:	f1 f7       	brne	.-4      	; 0x42aa <Delay_ms+0xa>
    42ae:	81 50       	subi	r24, 0x01	; 1
    42b0:	d9 f7       	brne	.-10     	; 0x42a8 <Delay_ms+0x8>
    42b2:	08 95       	ret

000042b4 <Delay_us>:
{
	/*uint8_t i;
	for(i=Delay/Delay_us_Max; i; i--)
		_delay_us(Delay_us_Max);*/
	//_delay_us(Delay%Delay_us_Max);
	Delay *= .8;	// By trial
    42b4:	a0 e0       	ldi	r26, 0x00	; 0
    42b6:	b0 e0       	ldi	r27, 0x00	; 0
    42b8:	bc 01       	movw	r22, r24
    42ba:	cd 01       	movw	r24, r26
    42bc:	0e 94 3f 82 	call	0x1047e	; 0x1047e <__floatunsisf>
    42c0:	2d ec       	ldi	r18, 0xCD	; 205
    42c2:	3c ec       	ldi	r19, 0xCC	; 204
    42c4:	4c e4       	ldi	r20, 0x4C	; 76
    42c6:	5f e3       	ldi	r21, 0x3F	; 63
    42c8:	0e 94 7c 82 	call	0x104f8	; 0x104f8 <__mulsf3>
    42cc:	0e 94 14 87 	call	0x10e28	; 0x10e28 <__fixunssfsi>
    42d0:	cb 01       	movw	r24, r22
	while (Delay--)
    42d2:	67 2b       	or	r22, r23
    42d4:	31 f0       	breq	.+12     	; 0x42e2 <Delay_us+0x2e>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    42d6:	35 e0       	ldi	r19, 0x05	; 5
    42d8:	23 2f       	mov	r18, r19
    42da:	2a 95       	dec	r18
    42dc:	f1 f7       	brne	.-4      	; 0x42da <Delay_us+0x26>
    42de:	01 97       	sbiw	r24, 0x01	; 1
    42e0:	d9 f7       	brne	.-10     	; 0x42d8 <Delay_us+0x24>
    42e2:	08 95       	ret

000042e4 <MB_PLC_Init>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#if defined vmd2_3
	void MB_PLC_Init(void)
	{
		// RS485
		DDRE |=(1<<PE2); PORTE &=~(1<<PE2);
    42e4:	6a 9a       	sbi	0x0d, 2	; 13
    42e6:	72 98       	cbi	0x0e, 2	; 14
		DDRD |=(1<<PD4); PORTD &=~(1<<PD4);
    42e8:	54 9a       	sbi	0x0a, 4	; 10
    42ea:	5c 98       	cbi	0x0b, 4	; 11
	#ifndef GSM
		DDRL |=(1<<PL5); PORTL &=~(1<<PL5);
	#endif
	}
    42ec:	08 95       	ret

000042ee <RS485_0>:
	void RS485_0(void) {PORTE ^=(1<<PE2);}
    42ee:	8e b1       	in	r24, 0x0e	; 14
    42f0:	94 e0       	ldi	r25, 0x04	; 4
    42f2:	89 27       	eor	r24, r25
    42f4:	8e b9       	out	0x0e, r24	; 14
    42f6:	08 95       	ret

000042f8 <RS485_1>:
	void RS485_1(void) {PORTD ^=(1<<PD4);}
    42f8:	8b b1       	in	r24, 0x0b	; 11
    42fa:	90 e1       	ldi	r25, 0x10	; 16
    42fc:	89 27       	eor	r24, r25
    42fe:	8b b9       	out	0x0b, r24	; 11
    4300:	08 95       	ret

00004302 <MB_LED0>:
	}
	void RS485_0(void) {PORTE ^=(1<<PE2);}
	void RS485_1(void) {PORTC ^=(1<<PC0);}
#endif

void MB_LED0(void) {}
    4302:	08 95       	ret

00004304 <MB_LED1>:
void MB_LED1(void) {}
    4304:	08 95       	ret

00004306 <MB_LED2>:
void MB_LED2(void) {}
    4306:	08 95       	ret

00004308 <MB_LED_Err_On_0>:

void MB_LED_Err_On_0(void)	{}
    4308:	08 95       	ret

0000430a <MB_LED_Err_Off_0>:
void MB_LED_Err_Off_0(void)	{}
    430a:	08 95       	ret

0000430c <MB_LED_Err_On_1>:
void MB_LED_Err_On_1(void)	{}
    430c:	08 95       	ret

0000430e <MB_LED_Err_Off_1>:
void MB_LED_Err_Off_1(void)	{}	
    430e:	08 95       	ret

00004310 <MB_LED_Err_On_2>:
void MB_LED_Err_On_2(void)	{}
    4310:	08 95       	ret

00004312 <MB_LED_Err_Off_2>:
void MB_LED_Err_Off_2(void)	{}
    4312:	08 95       	ret

00004314 <PWM_Init>:

// ~~~~~~~~~~~
void
PWM_Init(void)
{
	TCCR3A = (1<<COM3A1) | (0<<COM3A0) | (1<<COM3B1) | (0<<COM3B0) | (0<<COM3C1) | (0<<COM3C0) | (1<<WGM31) | (0<<WGM30);
    4314:	32 ea       	ldi	r19, 0xA2	; 162
    4316:	30 93 90 00 	sts	0x0090, r19
	TCCR3B = (0<<CS32) | (0<<CS31) | (1<<CS30) | (1<<WGM33) | (1<<WGM32);	// Fpwm = 244Hz
    431a:	29 e1       	ldi	r18, 0x19	; 25
    431c:	20 93 91 00 	sts	0x0091, r18
	ICR3 = PWM_PERIOD_TC3;
    4320:	8f ef       	ldi	r24, 0xFF	; 255
    4322:	9f ef       	ldi	r25, 0xFF	; 255
    4324:	90 93 97 00 	sts	0x0097, r25
    4328:	80 93 96 00 	sts	0x0096, r24
	DDRE |= (1<<PE3) | (1<<PE4);
    432c:	8d b1       	in	r24, 0x0d	; 13
    432e:	88 61       	ori	r24, 0x18	; 24
    4330:	8d b9       	out	0x0d, r24	; 13

	TCCR5A = (1<<COM5A1) | (0<<COM5A0) | (1<<COM5B1) | (0<<COM5B0) | (0<<COM5C1) | (0<<COM5C0) | (1<<WGM51) | (0<<WGM50);
    4332:	30 93 20 01 	sts	0x0120, r19
	TCCR5B = (0<<CS52) | (0<<CS51) | (1<<CS50) | (1<<WGM53) | (1<<WGM52);	// Fpwm = 244Hz
    4336:	20 93 21 01 	sts	0x0121, r18
	ICR5 = PWM_PERIOD_TC5;
    433a:	8e e7       	ldi	r24, 0x7E	; 126
    433c:	9c e0       	ldi	r25, 0x0C	; 12
    433e:	90 93 27 01 	sts	0x0127, r25
    4342:	80 93 26 01 	sts	0x0126, r24
	DDRL |= (1<<PL3) | (1<<PL4);
    4346:	ea e0       	ldi	r30, 0x0A	; 10
    4348:	f1 e0       	ldi	r31, 0x01	; 1
    434a:	80 81       	ld	r24, Z
    434c:	88 61       	ori	r24, 0x18	; 24
    434e:	80 83       	st	Z, r24
}
    4350:	08 95       	ret

00004352 <PWM_Out>:
void
PWM_Out(void)
{
	uint16_t Buf;

	Buf = Coef_AO_PWM_TC3*DAC_Output[0];
    4352:	60 91 d2 07 	lds	r22, 0x07D2
    4356:	70 91 d3 07 	lds	r23, 0x07D3
    435a:	80 e0       	ldi	r24, 0x00	; 0
    435c:	90 e0       	ldi	r25, 0x00	; 0
    435e:	0e 94 3f 82 	call	0x1047e	; 0x1047e <__floatunsisf>
    4362:	28 e8       	ldi	r18, 0x88	; 136
    4364:	3f e1       	ldi	r19, 0x1F	; 31
    4366:	40 e8       	ldi	r20, 0x80	; 128
    4368:	52 e4       	ldi	r21, 0x42	; 66
    436a:	0e 94 7c 82 	call	0x104f8	; 0x104f8 <__mulsf3>
    436e:	0e 94 14 87 	call	0x10e28	; 0x10e28 <__fixunssfsi>
    4372:	26 2f       	mov	r18, r22

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    4374:	9f b7       	in	r25, 0x3f	; 63
	cli();
    4376:	f8 94       	cli
	IntOff();
	OCR3AH = Buf>>8;
    4378:	70 93 99 00 	sts	0x0099, r23
	OCR3AL = Buf;
    437c:	20 93 98 00 	sts	0x0098, r18

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    4380:	97 ff       	sbrs	r25, 7
    4382:	01 c0       	rjmp	.+2      	; 0x4386 <PWM_Out+0x34>
		sei();
    4384:	78 94       	sei
	IntOn();

	Buf = Coef_AO_PWM_TC3*DAC_Output[1];
    4386:	60 91 d4 07 	lds	r22, 0x07D4
    438a:	70 91 d5 07 	lds	r23, 0x07D5
    438e:	80 e0       	ldi	r24, 0x00	; 0
    4390:	90 e0       	ldi	r25, 0x00	; 0
    4392:	0e 94 3f 82 	call	0x1047e	; 0x1047e <__floatunsisf>
    4396:	28 e8       	ldi	r18, 0x88	; 136
    4398:	3f e1       	ldi	r19, 0x1F	; 31
    439a:	40 e8       	ldi	r20, 0x80	; 128
    439c:	52 e4       	ldi	r21, 0x42	; 66
    439e:	0e 94 7c 82 	call	0x104f8	; 0x104f8 <__mulsf3>
    43a2:	0e 94 14 87 	call	0x10e28	; 0x10e28 <__fixunssfsi>
    43a6:	26 2f       	mov	r18, r22

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    43a8:	9f b7       	in	r25, 0x3f	; 63
	cli();
    43aa:	f8 94       	cli
	IntOff();
	OCR3BH = Buf>>8;
    43ac:	70 93 9b 00 	sts	0x009B, r23
	OCR3BL = Buf;
    43b0:	20 93 9a 00 	sts	0x009A, r18

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    43b4:	97 ff       	sbrs	r25, 7
    43b6:	01 c0       	rjmp	.+2      	; 0x43ba <PWM_Out+0x68>
		sei();
    43b8:	78 94       	sei
	IntOn();


	Buf = Coef_AO_PWM_TC5*DAC_Output[2];
    43ba:	60 91 d6 07 	lds	r22, 0x07D6
    43be:	70 91 d7 07 	lds	r23, 0x07D7
    43c2:	80 e0       	ldi	r24, 0x00	; 0
    43c4:	90 e0       	ldi	r25, 0x00	; 0
    43c6:	0e 94 3f 82 	call	0x1047e	; 0x1047e <__floatunsisf>
    43ca:	25 e0       	ldi	r18, 0x05	; 5
    43cc:	32 e1       	ldi	r19, 0x12	; 18
    43ce:	48 e4       	ldi	r20, 0x48	; 72
    43d0:	50 e4       	ldi	r21, 0x40	; 64
    43d2:	0e 94 7c 82 	call	0x104f8	; 0x104f8 <__mulsf3>
    43d6:	0e 94 14 87 	call	0x10e28	; 0x10e28 <__fixunssfsi>
    43da:	26 2f       	mov	r18, r22

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    43dc:	9f b7       	in	r25, 0x3f	; 63
	cli();
    43de:	f8 94       	cli
	IntOff();
	OCR5AH = Buf>>8;
    43e0:	70 93 29 01 	sts	0x0129, r23
	OCR5AL = Buf;
    43e4:	20 93 28 01 	sts	0x0128, r18

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    43e8:	97 ff       	sbrs	r25, 7
    43ea:	01 c0       	rjmp	.+2      	; 0x43ee <PWM_Out+0x9c>
		sei();
    43ec:	78 94       	sei
	IntOn();

	Buf = Coef_AO_PWM_TC5*DAC_Output[3];
    43ee:	60 91 d8 07 	lds	r22, 0x07D8
    43f2:	70 91 d9 07 	lds	r23, 0x07D9
    43f6:	80 e0       	ldi	r24, 0x00	; 0
    43f8:	90 e0       	ldi	r25, 0x00	; 0
    43fa:	0e 94 3f 82 	call	0x1047e	; 0x1047e <__floatunsisf>
    43fe:	25 e0       	ldi	r18, 0x05	; 5
    4400:	32 e1       	ldi	r19, 0x12	; 18
    4402:	48 e4       	ldi	r20, 0x48	; 72
    4404:	50 e4       	ldi	r21, 0x40	; 64
    4406:	0e 94 7c 82 	call	0x104f8	; 0x104f8 <__mulsf3>
    440a:	0e 94 14 87 	call	0x10e28	; 0x10e28 <__fixunssfsi>
    440e:	26 2f       	mov	r18, r22

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    4410:	8f b7       	in	r24, 0x3f	; 63
    4412:	80 78       	andi	r24, 0x80	; 128
    4414:	80 93 ee 02 	sts	0x02EE, r24
	cli();
    4418:	f8 94       	cli
	IntOff();
	OCR5BH = Buf>>8;
    441a:	70 93 2b 01 	sts	0x012B, r23
	OCR5BL = Buf;
    441e:	20 93 2a 01 	sts	0x012A, r18

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    4422:	88 23       	and	r24, r24
    4424:	09 f0       	breq	.+2      	; 0x4428 <PWM_Out+0xd6>
		sei();
    4426:	78 94       	sei
    4428:	08 95       	ret

0000442a <ADC_In>:
}

// ~~~~~~~~~
uint8_t
ADC_In(void)
{
    442a:	1f 93       	push	r17

// ~~~~~~~~~~~~~~~
inline static void
ADC_Select(void)
{
	SPCR |=(1<<CPOL);
    442c:	8c b5       	in	r24, 0x2c	; 44
    442e:	88 60       	ori	r24, 0x08	; 8
    4430:	8c bd       	out	0x2c, r24	; 44
	#ifdef CS_ADC
		cli();
    4432:	f8 94       	cli
		PortCS_ADC &=~CS_ADC;
    4434:	80 91 02 01 	lds	r24, 0x0102
    4438:	87 7f       	andi	r24, 0xF7	; 247
    443a:	80 93 02 01 	sts	0x0102, r24
		sei();
    443e:	78 94       	sei
ADC_In(void)
{
	uint8_t Chan = ADC_Reg;
	ADC_Select();

	switch(ADC_Phase) {
    4440:	80 91 6a 0b 	lds	r24, 0x0B6A
    4444:	81 30       	cpi	r24, 0x01	; 1
    4446:	09 f4       	brne	.+2      	; 0x444a <ADC_In+0x20>
    4448:	ec c0       	rjmp	.+472    	; 0x4622 <ADC_In+0x1f8>
    444a:	81 30       	cpi	r24, 0x01	; 1
    444c:	30 f5       	brcc	.+76     	; 0x449a <ADC_In+0x70>

// ~~~~~~~~~~~~~~~
inline static void
ADC_Rst(void)
{
	cli();
    444e:	f8 94       	cli
	PortRESET_PER &=~RESET_PER;
    4450:	80 91 02 01 	lds	r24, 0x0102
    4454:	8f 7e       	andi	r24, 0xEF	; 239
    4456:	80 93 02 01 	sts	0x0102, r24
	sei();
    445a:	78 94       	sei
    445c:	85 e0       	ldi	r24, 0x05	; 5
    445e:	8a 95       	dec	r24
    4460:	f1 f7       	brne	.-4      	; 0x445e <ADC_In+0x34>
	_delay_us(1);							// 100 ns needs
	cli();
    4462:	f8 94       	cli
	PortRESET_PER |=RESET_PER;
    4464:	80 91 02 01 	lds	r24, 0x0102
    4468:	80 61       	ori	r24, 0x10	; 16
    446a:	80 93 02 01 	sts	0x0102, r24
	sei();
    446e:	78 94       	sei
	StartTimer8_ISR(TD_ADC, 4);		// 16 ms needs
    4470:	80 91 39 07 	lds	r24, 0x0739
    4474:	64 e0       	ldi	r22, 0x04	; 4
	WaitSPI();
	SPDR = SR;
	WaitSPI();
	SPDR = SetpVal(CaliMode) &~ADC_FSYNC;
	WaitSPI();
	StartTimer8_ISR(TD_ADC, 36);
    4476:	0e 94 d2 1d 	call	0x3ba4	; 0x3ba4 <StartTimer8_ISR>
	ADC_Phase++;
    447a:	80 91 6a 0b 	lds	r24, 0x0B6A
    447e:	8f 5f       	subi	r24, 0xFF	; 255
    4480:	80 93 6a 0b 	sts	0x0B6A, r24
    4484:	17 e0       	ldi	r17, 0x07	; 7
// ~~~~~~~~~~~~~~~
inline static void
ADC_Desel(void)
{
	#ifdef CS_ADC
		cli();
    4486:	f8 94       	cli
		PortCS_ADC |=CS_ADC;
    4488:	80 91 02 01 	lds	r24, 0x0102
    448c:	88 60       	ori	r24, 0x08	; 8
    448e:	80 93 02 01 	sts	0x0102, r24
		sei();
    4492:	78 94       	sei
			IntOn();
		}
	#endif

	return Chan;
}
    4494:	81 2f       	mov	r24, r17
    4496:	1f 91       	pop	r17
    4498:	08 95       	ret
ADC_In(void)
{
	uint8_t Chan = ADC_Reg;
	ADC_Select();

	switch(ADC_Phase) {
    449a:	82 30       	cpi	r24, 0x02	; 2
    449c:	09 f4       	brne	.+2      	; 0x44a0 <ADC_In+0x76>
    449e:	d2 c0       	rjmp	.+420    	; 0x4644 <ADC_In+0x21a>
    44a0:	83 30       	cpi	r24, 0x03	; 3
    44a2:	11 f0       	breq	.+4      	; 0x44a8 <ADC_In+0x7e>
				StartTimer8_ISR(TD_ADC, ADC10ms);
			}
		}
		else if(Timer8Stopp_ISR(TD_ADC)) {
			ADC_ReadFail++;
			ADC_Phase = RST;
    44a4:	17 e0       	ldi	r17, 0x07	; 7
    44a6:	ef cf       	rjmp	.-34     	; 0x4486 <ADC_In+0x5c>
		default:
			SPDR = ADC_IN1(Reg);
			break;
		}
	#else
		SPDR = ADC_IN1(Reg);
    44a8:	88 e0       	ldi	r24, 0x08	; 8
    44aa:	8e bd       	out	0x2e, r24	; 46

// ~~~~~~~~~~~
static void
WaitADC2(void)
{
	WaitSPI();
    44ac:	0d b4       	in	r0, 0x2d	; 45
    44ae:	07 fe       	sbrs	r0, 7
    44b0:	fd cf       	rjmp	.-6      	; 0x44ac <ADC_In+0x82>
	SPDR = 0;
    44b2:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    44b4:	0d b4       	in	r0, 0x2d	; 45
    44b6:	07 fe       	sbrs	r0, 7
    44b8:	fd cf       	rjmp	.-6      	; 0x44b4 <ADC_In+0x8a>
			StartTimer8_ISR(TD_ADC, ADC10ms);
		break;
	case READ:
		ADC_IN(CommReg);
		WaitADC2();
		if(!(SPDR &ADC_DRDY)) {
    44ba:	0e b4       	in	r0, 0x2e	; 46
    44bc:	07 fc       	sbrc	r0, 7
    44be:	da c0       	rjmp	.+436    	; 0x4674 <ADC_In+0x24a>
		default:
			SPDR = ADC_IN1(Reg);
			break;
		}
	#else
		SPDR = ADC_IN1(Reg);
    44c0:	88 e3       	ldi	r24, 0x38	; 56
    44c2:	8e bd       	out	0x2e, r24	; 46

// ~~~~~~~~~~~
static void
WaitADC2(void)
{
	WaitSPI();
    44c4:	0d b4       	in	r0, 0x2d	; 45
    44c6:	07 fe       	sbrs	r0, 7
    44c8:	fd cf       	rjmp	.-6      	; 0x44c4 <ADC_In+0x9a>
	SPDR = 0;
    44ca:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    44cc:	0d b4       	in	r0, 0x2d	; 45
    44ce:	07 fe       	sbrs	r0, 7
    44d0:	fd cf       	rjmp	.-6      	; 0x44cc <ADC_In+0xa2>
		WaitADC2();
		if(!(SPDR &ADC_DRDY)) {
			uint16_t Buf;
			ADC_IN(DataReg);
			WaitADC2();
			Buf = SPDR<<8;
    44d2:	3e b5       	in	r19, 0x2e	; 46

// ~~~~~~~~~~~
static void
WaitADC1(void)
{
	SPDR = 0;
    44d4:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    44d6:	0d b4       	in	r0, 0x2d	; 45
    44d8:	07 fe       	sbrs	r0, 7
    44da:	fd cf       	rjmp	.-6      	; 0x44d6 <ADC_In+0xac>
			uint16_t Buf;
			ADC_IN(DataReg);
			WaitADC2();
			Buf = SPDR<<8;
			WaitADC1();
			Buf += SPDR;
    44dc:	2e b5       	in	r18, 0x2e	; 46
		WaitADC2();
		if(!(SPDR &ADC_DRDY)) {
			uint16_t Buf;
			ADC_IN(DataReg);
			WaitADC2();
			Buf = SPDR<<8;
    44de:	93 2f       	mov	r25, r19
    44e0:	80 e0       	ldi	r24, 0x00	; 0
			WaitADC1();
			Buf += SPDR;
    44e2:	ac 01       	movw	r20, r24
    44e4:	42 0f       	add	r20, r18
    44e6:	51 1d       	adc	r21, r1
    44e8:	9a 01       	movw	r18, r20
			#ifdef ADC_Ref_Chan
				if (ADC_Chan==sizeof(Mux)-1 && ADC_Input[sizeof(Mux)-1]!=0 && (Buf<ADC_Ref-ADC_Ref_d || Buf>ADC_Ref+ADC_Ref_d)) {
    44ea:	10 91 12 09 	lds	r17, 0x0912
    44ee:	16 30       	cpi	r17, 0x06	; 6
    44f0:	09 f4       	brne	.+2      	; 0x44f4 <ADC_In+0xca>
    44f2:	19 c1       	rjmp	.+562    	; 0x4726 <ADC_In+0x2fc>
		default:
			SPDR = ADC_IN1(Reg);
			break;
		}
	#else
		SPDR = ADC_IN1(Reg);
    44f4:	80 e1       	ldi	r24, 0x10	; 16
    44f6:	8e bd       	out	0x2e, r24	; 46
{
	Scale *Scl;
	int8_t i;

	ADC_IN(SetpReg);
	WaitSPI();
    44f8:	0d b4       	in	r0, 0x2d	; 45
    44fa:	07 fe       	sbrs	r0, 7
    44fc:	fd cf       	rjmp	.-6      	; 0x44f8 <ADC_In+0xce>
	SPDR = SetpVal(NormMode) |ADC_FSYNC;
    44fe:	87 e0       	ldi	r24, 0x07	; 7
    4500:	8e bd       	out	0x2e, r24	; 46
	WaitSPI();
    4502:	0d b4       	in	r0, 0x2d	; 45
    4504:	07 fe       	sbrs	r0, 7
    4506:	fd cf       	rjmp	.-6      	; 0x4502 <ADC_In+0xd8>
	ADC_Time = ADC10ms-Timer8_ISR[TD_ADC];
    4508:	40 91 39 07 	lds	r20, 0x0739
    450c:	e4 2f       	mov	r30, r20
    450e:	f0 e0       	ldi	r31, 0x00	; 0
    4510:	e1 51       	subi	r30, 0x11	; 17
    4512:	fd 4f       	sbci	r31, 0xFD	; 253
    4514:	90 81       	ld	r25, Z
    4516:	84 e1       	ldi	r24, 0x14	; 20
    4518:	89 1b       	sub	r24, r25
    451a:	80 93 b3 06 	sts	0x06B3, r24
		default:
			SPDR = ADC_IN1(Reg);
			break;
		}
	#else
		SPDR = ADC_IN1(Reg);
    451e:	88 e6       	ldi	r24, 0x68	; 104
    4520:	8e bd       	out	0x2e, r24	; 46

// ~~~~~~~~~~~
static void
WaitADC2(void)
{
	WaitSPI();
    4522:	0d b4       	in	r0, 0x2d	; 45
    4524:	07 fe       	sbrs	r0, 7
    4526:	fd cf       	rjmp	.-6      	; 0x4522 <ADC_In+0xf8>
	SPDR = 0;
    4528:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    452a:	0d b4       	in	r0, 0x2d	; 45
    452c:	07 fe       	sbrs	r0, 7
    452e:	fd cf       	rjmp	.-6      	; 0x452a <ADC_In+0x100>
    4530:	ef e6       	ldi	r30, 0x6F	; 111
    4532:	fc e0       	ldi	r31, 0x0C	; 12
		Scl=&ADC_Scale1;
	#endif
	ADC_IN(ZeroReg);
	WaitADC2();
	for(i=2; i>=0; i--) {
		Scl->Zero[i] = SPDR;
    4534:	8e b5       	in	r24, 0x2e	; 46
    4536:	80 83       	st	Z, r24

// ~~~~~~~~~~~
static void
WaitADC1(void)
{
	SPDR = 0;
    4538:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    453a:	0d b4       	in	r0, 0x2d	; 45
    453c:	07 fe       	sbrs	r0, 7
    453e:	fd cf       	rjmp	.-6      	; 0x453a <ADC_In+0x110>
    4540:	31 97       	sbiw	r30, 0x01	; 1
	#else
		Scl=&ADC_Scale1;
	#endif
	ADC_IN(ZeroReg);
	WaitADC2();
	for(i=2; i>=0; i--) {
    4542:	8c e0       	ldi	r24, 0x0C	; 12
    4544:	ec 36       	cpi	r30, 0x6C	; 108
    4546:	f8 07       	cpc	r31, r24
    4548:	a9 f7       	brne	.-22     	; 0x4534 <ADC_In+0x10a>

// ~~~~~~~~~~~
static void
WaitADC1(void)
{
	SPDR = 0;
    454a:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    454c:	0d b4       	in	r0, 0x2d	; 45
    454e:	07 fe       	sbrs	r0, 7
    4550:	fd cf       	rjmp	.-6      	; 0x454c <ADC_In+0x122>
		default:
			SPDR = ADC_IN1(Reg);
			break;
		}
	#else
		SPDR = ADC_IN1(Reg);
    4552:	88 e7       	ldi	r24, 0x78	; 120
    4554:	8e bd       	out	0x2e, r24	; 46

// ~~~~~~~~~~~
static void
WaitADC2(void)
{
	WaitSPI();
    4556:	0d b4       	in	r0, 0x2d	; 45
    4558:	07 fe       	sbrs	r0, 7
    455a:	fd cf       	rjmp	.-6      	; 0x4556 <ADC_In+0x12c>
	SPDR = 0;
    455c:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    455e:	0d b4       	in	r0, 0x2d	; 45
    4560:	07 fe       	sbrs	r0, 7
    4562:	fd cf       	rjmp	.-6      	; 0x455e <ADC_In+0x134>
    4564:	e2 e7       	ldi	r30, 0x72	; 114
    4566:	fc e0       	ldi	r31, 0x0C	; 12
	}
	WaitADC1();
	ADC_IN(FullReg);
	WaitADC2();
	for(i=2; i>=0; i--) {
		Scl->Full[i] = SPDR;
    4568:	8e b5       	in	r24, 0x2e	; 46
    456a:	80 83       	st	Z, r24

// ~~~~~~~~~~~
static void
WaitADC1(void)
{
	SPDR = 0;
    456c:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    456e:	0d b4       	in	r0, 0x2d	; 45
    4570:	07 fe       	sbrs	r0, 7
    4572:	fd cf       	rjmp	.-6      	; 0x456e <ADC_In+0x144>
    4574:	31 97       	sbiw	r30, 0x01	; 1
		WaitADC1();
	}
	WaitADC1();
	ADC_IN(FullReg);
	WaitADC2();
	for(i=2; i>=0; i--) {
    4576:	5c e0       	ldi	r21, 0x0C	; 12
    4578:	ef 36       	cpi	r30, 0x6F	; 111
    457a:	f5 07       	cpc	r31, r21
    457c:	a9 f7       	brne	.-22     	; 0x4568 <ADC_In+0x13e>

// ~~~~~~~~~~~
static void
WaitADC1(void)
{
	SPDR = 0;
    457e:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    4580:	0d b4       	in	r0, 0x2d	; 45
    4582:	07 fe       	sbrs	r0, 7
    4584:	fd cf       	rjmp	.-6      	; 0x4580 <ADC_In+0x156>
	for(i=2; i>=0; i--) {
		Scl->Full[i] = SPDR;
		WaitADC1();
	}
	WaitADC1();
	return Scl->Zero[2]<25 || Scl->Zero[2]>27 || Scl->Full[2]<200 || Scl->Full[2]>203;
    4586:	80 91 6f 0c 	lds	r24, 0x0C6F
    458a:	89 51       	subi	r24, 0x19	; 25
    458c:	83 30       	cpi	r24, 0x03	; 3
    458e:	08 f0       	brcs	.+2      	; 0x4592 <ADC_In+0x168>
    4590:	85 c0       	rjmp	.+266    	; 0x469c <ADC_In+0x272>
    4592:	80 91 72 0c 	lds	r24, 0x0C72
    4596:	88 3c       	cpi	r24, 0xC8	; 200
    4598:	08 f4       	brcc	.+2      	; 0x459c <ADC_In+0x172>
    459a:	80 c0       	rjmp	.+256    	; 0x469c <ADC_In+0x272>
    459c:	8c 3c       	cpi	r24, 0xCC	; 204
    459e:	08 f0       	brcs	.+2      	; 0x45a2 <ADC_In+0x178>
    45a0:	7d c0       	rjmp	.+250    	; 0x469c <ADC_In+0x272>
			if(ADC_Check()) {
				ADC_Break++;
				ADC_Phase = RST;
			}
			else {
				ADC_Input[ADC_Chan] = Buf;
    45a2:	e1 2f       	mov	r30, r17
    45a4:	f0 e0       	ldi	r31, 0x00	; 0
    45a6:	ee 0f       	add	r30, r30
    45a8:	ff 1f       	adc	r31, r31
    45aa:	e5 5e       	subi	r30, 0xE5	; 229
    45ac:	f6 4f       	sbci	r31, 0xF6	; 246
    45ae:	31 83       	std	Z+1, r19	; 0x01
    45b0:	20 83       	st	Z, r18

// ~~~~~~~~~~~~~~~
inline static void
SetMux(void)
{
	if(++ADC_Chan == ADC_Reg)
    45b2:	81 2f       	mov	r24, r17
    45b4:	8f 5f       	subi	r24, 0xFF	; 255
    45b6:	80 93 12 09 	sts	0x0912, r24
    45ba:	87 30       	cpi	r24, 0x07	; 7
    45bc:	11 f4       	brne	.+4      	; 0x45c2 <ADC_In+0x198>
		ADC_Chan = 0;
    45be:	10 92 12 09 	sts	0x0912, r1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    45c2:	e0 91 12 09 	lds	r30, 0x0912
    45c6:	f0 e0       	ldi	r31, 0x00	; 0
    45c8:	ed 52       	subi	r30, 0x2D	; 45
    45ca:	fa 4c       	sbci	r31, 0xCA	; 202
    45cc:	94 91       	lpm	r25, Z+
		#if ADC_Reg>8
			if(ADC_Chan>=sizeof(Mux))
				return;
		#endif
		uint8_t Addr = prb(Mux+ADC_Chan);
		cli();
    45ce:	f8 94       	cli
		if (Addr/4){
    45d0:	94 30       	cpi	r25, 0x04	; 4
    45d2:	08 f4       	brcc	.+2      	; 0x45d6 <ADC_In+0x1ac>
    45d4:	ca c0       	rjmp	.+404    	; 0x476a <ADC_In+0x340>
			Port_INH|=INH;
    45d6:	77 9a       	sbi	0x0e, 7	; 14
			#ifdef Port_INH2
				Port_INH2 &=~INH2;
    45d8:	80 91 02 01 	lds	r24, 0x0102
    45dc:	8b 7f       	andi	r24, 0xFB	; 251
    45de:	80 93 02 01 	sts	0x0102, r24
			Port_INH &=~INH;
			#ifdef Port_INH2
				Port_INH2|=INH2;
			#endif
		}
		if (Addr%4/2)	Port_TER_B	|=TER_B;	else Port_TER_B	&=~TER_B;
    45e2:	29 2f       	mov	r18, r25
    45e4:	30 e0       	ldi	r19, 0x00	; 0
    45e6:	c9 01       	movw	r24, r18
    45e8:	83 70       	andi	r24, 0x03	; 3
    45ea:	90 70       	andi	r25, 0x00	; 0
    45ec:	01 96       	adiw	r24, 0x01	; 1
    45ee:	03 97       	sbiw	r24, 0x03	; 3
    45f0:	08 f4       	brcc	.+2      	; 0x45f4 <ADC_In+0x1ca>
    45f2:	b9 c0       	rjmp	.+370    	; 0x4766 <ADC_In+0x33c>
    45f4:	76 9a       	sbi	0x0e, 6	; 14
		if (Addr%2)		Port_TER_A	|=TER_A;	else Port_TER_A	&=~TER_A;
    45f6:	20 ff       	sbrs	r18, 0
    45f8:	b4 c0       	rjmp	.+360    	; 0x4762 <ADC_In+0x338>
    45fa:	75 9a       	sbi	0x0e, 5	; 14
		sei();
    45fc:	78 94       	sei
    45fe:	85 e5       	ldi	r24, 0x55	; 85
    4600:	8a 95       	dec	r24
    4602:	f1 f7       	brne	.-4      	; 0x4600 <ADC_In+0x1d6>
		default:
			SPDR = ADC_IN1(Reg);
			break;
		}
	#else
		SPDR = ADC_IN1(Reg);
    4604:	80 e1       	ldi	r24, 0x10	; 16
    4606:	8e bd       	out	0x2e, r24	; 46
			else {
				ADC_Input[ADC_Chan] = Buf;
				Chan = ADC_Chan;
				SetMux();
				ADC_IN(SetpReg);
				WaitSPI();
    4608:	0d b4       	in	r0, 0x2d	; 45
    460a:	07 fe       	sbrs	r0, 7
    460c:	fd cf       	rjmp	.-6      	; 0x4608 <ADC_In+0x1de>
				SPDR = SetpVal(NormMode) &~ADC_FSYNC;
    460e:	86 e0       	ldi	r24, 0x06	; 6
    4610:	8e bd       	out	0x2e, r24	; 46
				WaitSPI();
    4612:	0d b4       	in	r0, 0x2d	; 45
    4614:	07 fe       	sbrs	r0, 7
    4616:	fd cf       	rjmp	.-6      	; 0x4612 <ADC_In+0x1e8>
				StartTimer8_ISR(TD_ADC, ADC10ms);
    4618:	84 2f       	mov	r24, r20
    461a:	64 e1       	ldi	r22, 0x14	; 20
    461c:	0e 94 d2 1d 	call	0x3ba4	; 0x3ba4 <StartTimer8_ISR>
    4620:	32 cf       	rjmp	.-412    	; 0x4486 <ADC_In+0x5c>

// ~~~~~~~~~~~~~~~
inline static void
ADC_Init1(void)
{
	if(!Timer8Stopp_ISR(TD_ADC))
    4622:	80 91 39 07 	lds	r24, 0x0739
    4626:	0e 94 3e 1f 	call	0x3e7c	; 0x3e7c <Timer8Stopp_ISR>
    462a:	88 23       	and	r24, r24
    462c:	09 f4       	brne	.+2      	; 0x4630 <ADC_In+0x206>
    462e:	3a cf       	rjmp	.-396    	; 0x44a4 <ADC_In+0x7a>
    4630:	81 e0       	ldi	r24, 0x01	; 1
		return;
	uint8_t i = 0;
	while(i++<8) {	// 4 x 0xFF needs
		SPDR = 0xFF;
    4632:	9f ef       	ldi	r25, 0xFF	; 255
    4634:	9e bd       	out	0x2e, r25	; 46
		WaitSPI();
    4636:	0d b4       	in	r0, 0x2d	; 45
    4638:	07 fe       	sbrs	r0, 7
    463a:	fd cf       	rjmp	.-6      	; 0x4636 <ADC_In+0x20c>
ADC_Init1(void)
{
	if(!Timer8Stopp_ISR(TD_ADC))
		return;
	uint8_t i = 0;
	while(i++<8) {	// 4 x 0xFF needs
    463c:	88 30       	cpi	r24, 0x08	; 8
    463e:	d9 f1       	breq	.+118    	; 0x46b6 <ADC_In+0x28c>
    4640:	8f 5f       	subi	r24, 0xFF	; 255
    4642:	f8 cf       	rjmp	.-16     	; 0x4634 <ADC_In+0x20a>
// ~~~~~~~~~~~~~~~
static void
Calibr(uint8_t CR)
{
	static uint8_t Try;
	SPDR = CR;
    4644:	88 e0       	ldi	r24, 0x08	; 8
    4646:	8e bd       	out	0x2e, r24	; 46

// ~~~~~~~~~~~
static void
WaitADC2(void)
{
	WaitSPI();
    4648:	0d b4       	in	r0, 0x2d	; 45
    464a:	07 fe       	sbrs	r0, 7
    464c:	fd cf       	rjmp	.-6      	; 0x4648 <ADC_In+0x21e>
	SPDR = 0;
    464e:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    4650:	0d b4       	in	r0, 0x2d	; 45
    4652:	07 fe       	sbrs	r0, 7
    4654:	fd cf       	rjmp	.-6      	; 0x4650 <ADC_In+0x226>
Calibr(uint8_t CR)
{
	static uint8_t Try;
	SPDR = CR;
	WaitADC2();
	if(!(SPDR &ADC_DRDY)) {
    4656:	0e b4       	in	r0, 0x2e	; 46
    4658:	07 fc       	sbrc	r0, 7
    465a:	45 c0       	rjmp	.+138    	; 0x46e6 <ADC_In+0x2bc>
		Try = 0;
    465c:	10 92 ec 02 	sts	0x02EC, r1
		ADC_Phase++;
    4660:	83 e0       	ldi	r24, 0x03	; 3
    4662:	80 93 6a 0b 	sts	0x0B6A, r24
		break;
	case CALI3:
		Calibr(ADC_IN3(CommReg));
#endif
		if (ADC_Phase==READ)
			StartTimer8_ISR(TD_ADC, ADC10ms);
    4666:	80 91 39 07 	lds	r24, 0x0739
    466a:	64 e1       	ldi	r22, 0x14	; 20
    466c:	0e 94 d2 1d 	call	0x3ba4	; 0x3ba4 <StartTimer8_ISR>
    4670:	17 e0       	ldi	r17, 0x07	; 7
    4672:	09 cf       	rjmp	.-494    	; 0x4486 <ADC_In+0x5c>
				SPDR = SetpVal(NormMode) &~ADC_FSYNC;
				WaitSPI();
				StartTimer8_ISR(TD_ADC, ADC10ms);
			}
		}
		else if(Timer8Stopp_ISR(TD_ADC)) {
    4674:	80 91 39 07 	lds	r24, 0x0739
    4678:	0e 94 3e 1f 	call	0x3e7c	; 0x3e7c <Timer8Stopp_ISR>
    467c:	88 23       	and	r24, r24
    467e:	09 f4       	brne	.+2      	; 0x4682 <ADC_In+0x258>
    4680:	11 cf       	rjmp	.-478    	; 0x44a4 <ADC_In+0x7a>
			ADC_ReadFail++;
    4682:	80 91 b4 07 	lds	r24, 0x07B4
    4686:	90 91 b5 07 	lds	r25, 0x07B5
    468a:	01 96       	adiw	r24, 0x01	; 1
    468c:	90 93 b5 07 	sts	0x07B5, r25
    4690:	80 93 b4 07 	sts	0x07B4, r24
			ADC_Phase = RST;
    4694:	10 92 6a 0b 	sts	0x0B6A, r1
    4698:	17 e0       	ldi	r17, 0x07	; 7
    469a:	f5 ce       	rjmp	.-534    	; 0x4486 <ADC_In+0x5c>
					ADC_Chan--;
				}
				else
			#endif
			if(ADC_Check()) {
				ADC_Break++;
    469c:	80 91 f8 06 	lds	r24, 0x06F8
    46a0:	90 91 f9 06 	lds	r25, 0x06F9
    46a4:	01 96       	adiw	r24, 0x01	; 1
    46a6:	90 93 f9 06 	sts	0x06F9, r25
    46aa:	80 93 f8 06 	sts	0x06F8, r24
				ADC_Phase = RST;
    46ae:	10 92 6a 0b 	sts	0x0B6A, r1
    46b2:	17 e0       	ldi	r17, 0x07	; 7
    46b4:	e8 ce       	rjmp	.-560    	; 0x4486 <ADC_In+0x5c>

// ~~~~~~~~~~~~~~~~~~~~~~~~~
static void
Init(uint8_t CR, uint8_t SR)
{
	SPDR = CR;
    46b6:	80 e2       	ldi	r24, 0x20	; 32
    46b8:	8e bd       	out	0x2e, r24	; 46
	WaitSPI();
    46ba:	0d b4       	in	r0, 0x2d	; 45
    46bc:	07 fe       	sbrs	r0, 7
    46be:	fd cf       	rjmp	.-6      	; 0x46ba <ADC_In+0x290>
	SPDR=ClckVal;
    46c0:	84 e0       	ldi	r24, 0x04	; 4
    46c2:	8e bd       	out	0x2e, r24	; 46
	WaitSPI();
    46c4:	0d b4       	in	r0, 0x2d	; 45
    46c6:	07 fe       	sbrs	r0, 7
    46c8:	fd cf       	rjmp	.-6      	; 0x46c4 <ADC_In+0x29a>
	SPDR = SR;
    46ca:	80 e1       	ldi	r24, 0x10	; 16
    46cc:	8e bd       	out	0x2e, r24	; 46
	WaitSPI();
    46ce:	0d b4       	in	r0, 0x2d	; 45
    46d0:	07 fe       	sbrs	r0, 7
    46d2:	fd cf       	rjmp	.-6      	; 0x46ce <ADC_In+0x2a4>
	SPDR = SetpVal(CaliMode) &~ADC_FSYNC;
    46d4:	86 e4       	ldi	r24, 0x46	; 70
    46d6:	8e bd       	out	0x2e, r24	; 46
	WaitSPI();
    46d8:	0d b4       	in	r0, 0x2d	; 45
    46da:	07 fe       	sbrs	r0, 7
    46dc:	fd cf       	rjmp	.-6      	; 0x46d8 <ADC_In+0x2ae>
	StartTimer8_ISR(TD_ADC, 36);
    46de:	80 91 39 07 	lds	r24, 0x0739
    46e2:	64 e2       	ldi	r22, 0x24	; 36
    46e4:	c8 ce       	rjmp	.-624    	; 0x4476 <ADC_In+0x4c>
	WaitADC2();
	if(!(SPDR &ADC_DRDY)) {
		Try = 0;
		ADC_Phase++;
	}
	else if(Timer8Stopp_ISR(TD_ADC)) {
    46e6:	80 91 39 07 	lds	r24, 0x0739
    46ea:	0e 94 3e 1f 	call	0x3e7c	; 0x3e7c <Timer8Stopp_ISR>
    46ee:	88 23       	and	r24, r24
    46f0:	99 f0       	breq	.+38     	; 0x4718 <ADC_In+0x2ee>
		ADC_Fail++;
    46f2:	80 91 2b 09 	lds	r24, 0x092B
    46f6:	90 91 2c 09 	lds	r25, 0x092C
    46fa:	01 96       	adiw	r24, 0x01	; 1
    46fc:	90 93 2c 09 	sts	0x092C, r25
    4700:	80 93 2b 09 	sts	0x092B, r24
		ADC_Phase = ++Try<27 ? RST : ADC_OFF;
    4704:	80 91 ec 02 	lds	r24, 0x02EC
    4708:	8f 5f       	subi	r24, 0xFF	; 255
    470a:	80 93 ec 02 	sts	0x02EC, r24
    470e:	8b 31       	cpi	r24, 0x1B	; 27
    4710:	98 f1       	brcs	.+102    	; 0x4778 <ADC_In+0x34e>
    4712:	84 e0       	ldi	r24, 0x04	; 4
    4714:	80 93 6a 0b 	sts	0x0B6A, r24
		Init(ADC_IN3(ClckReg), ADC_IN3(SetpReg));
		break;
	case CALI3:
		Calibr(ADC_IN3(CommReg));
#endif
		if (ADC_Phase==READ)
    4718:	80 91 6a 0b 	lds	r24, 0x0B6A
    471c:	83 30       	cpi	r24, 0x03	; 3
    471e:	09 f4       	brne	.+2      	; 0x4722 <ADC_In+0x2f8>
    4720:	a2 cf       	rjmp	.-188    	; 0x4666 <ADC_In+0x23c>
				StartTimer8_ISR(TD_ADC, ADC10ms);
			}
		}
		else if(Timer8Stopp_ISR(TD_ADC)) {
			ADC_ReadFail++;
			ADC_Phase = RST;
    4722:	17 e0       	ldi	r17, 0x07	; 7
    4724:	b0 ce       	rjmp	.-672    	; 0x4486 <ADC_In+0x5c>
			WaitADC2();
			Buf = SPDR<<8;
			WaitADC1();
			Buf += SPDR;
			#ifdef ADC_Ref_Chan
				if (ADC_Chan==sizeof(Mux)-1 && ADC_Input[sizeof(Mux)-1]!=0 && (Buf<ADC_Ref-ADC_Ref_d || Buf>ADC_Ref+ADC_Ref_d)) {
    4726:	80 91 27 09 	lds	r24, 0x0927
    472a:	90 91 28 09 	lds	r25, 0x0928
    472e:	89 2b       	or	r24, r25
    4730:	09 f4       	brne	.+2      	; 0x4734 <ADC_In+0x30a>
    4732:	e0 ce       	rjmp	.-576    	; 0x44f4 <ADC_In+0xca>
    4734:	ca 01       	movw	r24, r20
    4736:	80 58       	subi	r24, 0x80	; 128
    4738:	9e 43       	sbci	r25, 0x3E	; 62
    473a:	81 5a       	subi	r24, 0xA1	; 161
    473c:	9f 40       	sbci	r25, 0x0F	; 15
    473e:	08 f4       	brcc	.+2      	; 0x4742 <ADC_In+0x318>
    4740:	d9 ce       	rjmp	.-590    	; 0x44f4 <ADC_In+0xca>
					ADC_Break++;
    4742:	80 91 f8 06 	lds	r24, 0x06F8
    4746:	90 91 f9 06 	lds	r25, 0x06F9
    474a:	01 96       	adiw	r24, 0x01	; 1
    474c:	90 93 f9 06 	sts	0x06F9, r25
    4750:	80 93 f8 06 	sts	0x06F8, r24
					ADC_Phase = RST;
    4754:	10 92 6a 0b 	sts	0x0B6A, r1
					ADC_Chan--;
    4758:	85 e0       	ldi	r24, 0x05	; 5
    475a:	80 93 12 09 	sts	0x0912, r24
    475e:	17 e0       	ldi	r17, 0x07	; 7
    4760:	92 ce       	rjmp	.-732    	; 0x4486 <ADC_In+0x5c>
			#ifdef Port_INH2
				Port_INH2|=INH2;
			#endif
		}
		if (Addr%4/2)	Port_TER_B	|=TER_B;	else Port_TER_B	&=~TER_B;
		if (Addr%2)		Port_TER_A	|=TER_A;	else Port_TER_A	&=~TER_A;
    4762:	75 98       	cbi	0x0e, 5	; 14
    4764:	4b cf       	rjmp	.-362    	; 0x45fc <ADC_In+0x1d2>
			Port_INH &=~INH;
			#ifdef Port_INH2
				Port_INH2|=INH2;
			#endif
		}
		if (Addr%4/2)	Port_TER_B	|=TER_B;	else Port_TER_B	&=~TER_B;
    4766:	76 98       	cbi	0x0e, 6	; 14
    4768:	46 cf       	rjmp	.-372    	; 0x45f6 <ADC_In+0x1cc>
			#ifdef Port_INH2
				Port_INH2 &=~INH2;
			#endif
		}
		else{
			Port_INH &=~INH;
    476a:	77 98       	cbi	0x0e, 7	; 14
			#ifdef Port_INH2
				Port_INH2|=INH2;
    476c:	80 91 02 01 	lds	r24, 0x0102
    4770:	84 60       	ori	r24, 0x04	; 4
    4772:	80 93 02 01 	sts	0x0102, r24
    4776:	35 cf       	rjmp	.-406    	; 0x45e2 <ADC_In+0x1b8>
		Try = 0;
		ADC_Phase++;
	}
	else if(Timer8Stopp_ISR(TD_ADC)) {
		ADC_Fail++;
		ADC_Phase = ++Try<27 ? RST : ADC_OFF;
    4778:	80 e0       	ldi	r24, 0x00	; 0
    477a:	cc cf       	rjmp	.-104    	; 0x4714 <ADC_In+0x2ea>

0000477c <SPI_Init>:
// Total
// ~~~~~~~~~~~
void
SPI_Init(void)
{
	cli();
    477c:	f8 94       	cli
	#if defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		DDRB = (DDRB &~(1<<DDB3)) |(1<<DDB2) |(1<<DDB1) |(1<<DDB0);
    477e:	84 b1       	in	r24, 0x04	; 4
    4780:	80 7f       	andi	r24, 0xF0	; 240
    4782:	87 60       	ori	r24, 0x07	; 7
    4784:	84 b9       	out	0x04, r24	; 4
		PORTB |=1<<PB3;
    4786:	2b 9a       	sbi	0x05, 3	; 5
	#elif defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
		DDRB = (DDRB &~(1<<DDB6)) |(1<<DDB5) |(1<<DDB7) |(1<<DDB4);
		PORTB |=1<<PB6;
	#endif
	SPCR = (uint8_t)((~(1<<SPIE) |(1<<SPE)) &~(1<<DORD)) |(1<<MSTR) |(1<<CPHA) |(1<<SPR1) |(1<<SPR0);
    4788:	8f e5       	ldi	r24, 0x5F	; 95
    478a:	8c bd       	out	0x2c, r24	; 44
	sei();
    478c:	78 94       	sei
		PortCS_DAC_2 |=CS_DAC_2;
		sei();
	#endif

	#ifndef ADC_Miss
		cli();
    478e:	f8 94       	cli
		#ifdef CS_ADC
			DDR_CS_ADC |=CS_ADC;
    4790:	80 91 01 01 	lds	r24, 0x0101
    4794:	88 60       	ori	r24, 0x08	; 8
    4796:	80 93 01 01 	sts	0x0101, r24
			PortCS_ADC |=CS_ADC;
    479a:	80 91 02 01 	lds	r24, 0x0102
    479e:	88 60       	ori	r24, 0x08	; 8
    47a0:	80 93 02 01 	sts	0x0102, r24
		#endif
		DDR_RESET_PER |=RESET_PER;
    47a4:	80 91 01 01 	lds	r24, 0x0101
    47a8:	80 61       	ori	r24, 0x10	; 16
    47aa:	80 93 01 01 	sts	0x0101, r24
		#ifdef ADC_Mux
			DDR_INH |=INH;
    47ae:	6f 9a       	sbi	0x0d, 7	; 13
			#ifdef DDR_INH2			
				DDR_INH2 |=INH2;
    47b0:	80 91 01 01 	lds	r24, 0x0101
    47b4:	84 60       	ori	r24, 0x04	; 4
    47b6:	80 93 01 01 	sts	0x0101, r24
			#endif
			DDR_TER_A |=TER_A;
    47ba:	6d 9a       	sbi	0x0d, 5	; 13
			DDR_TER_B |=TER_B;
    47bc:	6e 9a       	sbi	0x0d, 6	; 13
		#endif
		sei();
    47be:	78 94       	sei

// ~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer8_ISR_SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys_ISR;
    47c0:	80 91 db 02 	lds	r24, 0x02DB
	VacantTimer8Sys_ISR += n;
    47c4:	8f 5f       	subi	r24, 0xFF	; 255
    47c6:	80 93 db 02 	sts	0x02DB, r24
    47ca:	81 50       	subi	r24, 0x01	; 1

		TD_ADC = Timer8_ISR_SysAlloc(1);
    47cc:	80 93 39 07 	sts	0x0739, r24


		ADC_Chan = ADC_Reg-1;		// Ignore 1-st measurement after calibration
    47d0:	86 e0       	ldi	r24, 0x06	; 6
    47d2:	80 93 12 09 	sts	0x0912, r24

		while(ADC_In()==ADC_Reg && ADC_OK);
    47d6:	0e 94 15 22 	call	0x442a	; 0x442a <ADC_In>
    47da:	87 30       	cpi	r24, 0x07	; 7
    47dc:	91 f4       	brne	.+36     	; 0x4802 <SPI_Init+0x86>
    47de:	80 91 2b 09 	lds	r24, 0x092B
    47e2:	90 91 2c 09 	lds	r25, 0x092C
    47e6:	89 2b       	or	r24, r25
    47e8:	61 f4       	brne	.+24     	; 0x4802 <SPI_Init+0x86>
    47ea:	80 91 b4 07 	lds	r24, 0x07B4
    47ee:	90 91 b5 07 	lds	r25, 0x07B5
    47f2:	89 2b       	or	r24, r25
    47f4:	31 f4       	brne	.+12     	; 0x4802 <SPI_Init+0x86>
    47f6:	80 91 f8 06 	lds	r24, 0x06F8
    47fa:	90 91 f9 06 	lds	r25, 0x06F9
    47fe:	89 2b       	or	r24, r25
    4800:	51 f3       	breq	.-44     	; 0x47d6 <SPI_Init+0x5a>
    4802:	08 95       	ret

00004804 <Pow10>:
#include <string.h>

// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
    4804:	48 2f       	mov	r20, r24
	uint16_t Pow = 1;
	while(Exp--)
    4806:	88 23       	and	r24, r24
    4808:	89 f0       	breq	.+34     	; 0x482c <Pow10+0x28>
    480a:	21 e0       	ldi	r18, 0x01	; 1
    480c:	30 e0       	ldi	r19, 0x00	; 0
		Pow *= 10;
    480e:	c9 01       	movw	r24, r18
    4810:	88 0f       	add	r24, r24
    4812:	99 1f       	adc	r25, r25
    4814:	22 0f       	add	r18, r18
    4816:	33 1f       	adc	r19, r19
    4818:	22 0f       	add	r18, r18
    481a:	33 1f       	adc	r19, r19
    481c:	22 0f       	add	r18, r18
    481e:	33 1f       	adc	r19, r19
    4820:	28 0f       	add	r18, r24
    4822:	39 1f       	adc	r19, r25
    4824:	41 50       	subi	r20, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    4826:	99 f7       	brne	.-26     	; 0x480e <Pow10+0xa>
		Pow *= 10;
	return Pow;
}
    4828:	c9 01       	movw	r24, r18
    482a:	08 95       	ret
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    482c:	21 e0       	ldi	r18, 0x01	; 1
    482e:	30 e0       	ldi	r19, 0x00	; 0
    4830:	fb cf       	rjmp	.-10     	; 0x4828 <Pow10+0x24>

00004832 <PowL10>:
	return Pow;
}
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
    4832:	1f 93       	push	r17
    4834:	18 2f       	mov	r17, r24
	uint32_t Pow = 1;
	while(Exp--)
    4836:	88 23       	and	r24, r24
    4838:	a1 f0       	breq	.+40     	; 0x4862 <PowL10+0x30>
    483a:	21 e0       	ldi	r18, 0x01	; 1
    483c:	30 e0       	ldi	r19, 0x00	; 0
    483e:	40 e0       	ldi	r20, 0x00	; 0
    4840:	50 e0       	ldi	r21, 0x00	; 0
		Pow *= 10;
    4842:	ca 01       	movw	r24, r20
    4844:	b9 01       	movw	r22, r18
    4846:	2a e0       	ldi	r18, 0x0A	; 10
    4848:	30 e0       	ldi	r19, 0x00	; 0
    484a:	40 e0       	ldi	r20, 0x00	; 0
    484c:	50 e0       	ldi	r21, 0x00	; 0
    484e:	0e 94 8c 87 	call	0x10f18	; 0x10f18 <__mulsi3>
    4852:	9b 01       	movw	r18, r22
    4854:	ac 01       	movw	r20, r24
    4856:	11 50       	subi	r17, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
	uint32_t Pow = 1;
	while(Exp--)
    4858:	a1 f7       	brne	.-24     	; 0x4842 <PowL10+0x10>
		Pow *= 10;
	return Pow;
}
    485a:	b9 01       	movw	r22, r18
    485c:	ca 01       	movw	r24, r20
    485e:	1f 91       	pop	r17
    4860:	08 95       	ret
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
	uint32_t Pow = 1;
	while(Exp--)
    4862:	21 e0       	ldi	r18, 0x01	; 1
    4864:	30 e0       	ldi	r19, 0x00	; 0
    4866:	40 e0       	ldi	r20, 0x00	; 0
    4868:	50 e0       	ldi	r21, 0x00	; 0
    486a:	f7 cf       	rjmp	.-18     	; 0x485a <PowL10+0x28>

0000486c <Log10>:
	return Pow;
}
// ~~~~~~~~~~~~~~~~~
uint8_t
Log10(uint32_t Numb)
{
    486c:	1f 93       	push	r17
	uint8_t Pos;
	for(Pos=0; Numb/=10; Pos++);
    486e:	2a e0       	ldi	r18, 0x0A	; 10
    4870:	30 e0       	ldi	r19, 0x00	; 0
    4872:	40 e0       	ldi	r20, 0x00	; 0
    4874:	50 e0       	ldi	r21, 0x00	; 0
    4876:	0e 94 de 87 	call	0x10fbc	; 0x10fbc <__udivmodsi4>
    487a:	c9 01       	movw	r24, r18
    487c:	da 01       	movw	r26, r20
    487e:	bc 01       	movw	r22, r24
    4880:	cd 01       	movw	r24, r26
    4882:	61 15       	cp	r22, r1
    4884:	71 05       	cpc	r23, r1
    4886:	81 05       	cpc	r24, r1
    4888:	91 05       	cpc	r25, r1
    488a:	a1 f0       	breq	.+40     	; 0x48b4 <Log10+0x48>
    488c:	10 e0       	ldi	r17, 0x00	; 0
    488e:	1f 5f       	subi	r17, 0xFF	; 255
    4890:	2a e0       	ldi	r18, 0x0A	; 10
    4892:	30 e0       	ldi	r19, 0x00	; 0
    4894:	40 e0       	ldi	r20, 0x00	; 0
    4896:	50 e0       	ldi	r21, 0x00	; 0
    4898:	0e 94 de 87 	call	0x10fbc	; 0x10fbc <__udivmodsi4>
    489c:	c9 01       	movw	r24, r18
    489e:	da 01       	movw	r26, r20
    48a0:	bc 01       	movw	r22, r24
    48a2:	cd 01       	movw	r24, r26
    48a4:	61 15       	cp	r22, r1
    48a6:	71 05       	cpc	r23, r1
    48a8:	81 05       	cpc	r24, r1
    48aa:	91 05       	cpc	r25, r1
    48ac:	81 f7       	brne	.-32     	; 0x488e <Log10+0x22>
	return Pos;
}
    48ae:	81 2f       	mov	r24, r17
    48b0:	1f 91       	pop	r17
    48b2:	08 95       	ret
// ~~~~~~~~~~~~~~~~~
uint8_t
Log10(uint32_t Numb)
{
	uint8_t Pos;
	for(Pos=0; Numb/=10; Pos++);
    48b4:	10 e0       	ldi	r17, 0x00	; 0
    48b6:	fb cf       	rjmp	.-10     	; 0x48ae <Log10+0x42>

000048b8 <CodBCD>:
// ~~~~~~~~~~~~~~~~~~~~

// ~~~~~~~~~~~~~~~~~~~
uint8_t
CodBCD(uint8_t Number)
{
    48b8:	28 2f       	mov	r18, r24
    48ba:	6a e0       	ldi	r22, 0x0A	; 10
    48bc:	0e 94 ab 87 	call	0x10f56	; 0x10f56 <__udivmodqi4>
    48c0:	38 2f       	mov	r19, r24
    48c2:	32 95       	swap	r19
    48c4:	30 7f       	andi	r19, 0xF0	; 240
    48c6:	82 2f       	mov	r24, r18
    48c8:	0e 94 ab 87 	call	0x10f56	; 0x10f56 <__udivmodqi4>
	return (Number/10<<4)+Number%10;
}
    48cc:	83 2f       	mov	r24, r19
    48ce:	89 0f       	add	r24, r25
    48d0:	08 95       	ret

000048d2 <DecodBCD>:

// ~~~~~~~~~~~~~~~~~~
uint8_t
DecodBCD(uint8_t BCD)
{
    48d2:	28 2f       	mov	r18, r24
    48d4:	22 95       	swap	r18
    48d6:	2f 70       	andi	r18, 0x0F	; 15
    48d8:	9a e0       	ldi	r25, 0x0A	; 10
    48da:	29 9f       	mul	r18, r25
    48dc:	90 01       	movw	r18, r0
    48de:	11 24       	eor	r1, r1
    48e0:	8f 70       	andi	r24, 0x0F	; 15
	return 10*(BCD>>4)+(BCD&0x0F);
}
    48e2:	82 0f       	add	r24, r18
    48e4:	08 95       	ret

000048e6 <LineFunc>:
} uLineGraph;

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
int16_t
LineFunc(const LineGraph *LG, int32_t x)
{
    48e6:	2f 92       	push	r2
    48e8:	3f 92       	push	r3
    48ea:	4f 92       	push	r4
    48ec:	5f 92       	push	r5
    48ee:	6f 92       	push	r6
    48f0:	7f 92       	push	r7
    48f2:	8f 92       	push	r8
    48f4:	9f 92       	push	r9
    48f6:	af 92       	push	r10
    48f8:	bf 92       	push	r11
    48fa:	cf 92       	push	r12
    48fc:	df 92       	push	r13
    48fe:	ef 92       	push	r14
    4900:	ff 92       	push	r15
    4902:	0f 93       	push	r16
    4904:	1f 93       	push	r17
    4906:	cf 93       	push	r28
    4908:	df 93       	push	r29
    490a:	ec 01       	movw	r28, r24
    490c:	7a 01       	movw	r14, r20
    490e:	8b 01       	movw	r16, r22
	int16_t y;
	if (LG->x1==LG->x2)
    4910:	28 80       	ld	r2, Y
    4912:	39 80       	ldd	r3, Y+1	; 0x01
    4914:	4a 80       	ldd	r4, Y+2	; 0x02
    4916:	5b 80       	ldd	r5, Y+3	; 0x03
    4918:	6c 81       	ldd	r22, Y+4	; 0x04
    491a:	7d 81       	ldd	r23, Y+5	; 0x05
    491c:	8e 81       	ldd	r24, Y+6	; 0x06
    491e:	9f 81       	ldd	r25, Y+7	; 0x07
    4920:	26 16       	cp	r2, r22
    4922:	37 06       	cpc	r3, r23
    4924:	48 06       	cpc	r4, r24
    4926:	59 06       	cpc	r5, r25
    4928:	09 f4       	brne	.+2      	; 0x492c <LineFunc+0x46>
    492a:	58 c0       	rjmp	.+176    	; 0x49dc <LineFunc+0xf6>
		y = LG->y1;
	else {
		float x1=LG->x1, x2=LG->x2, y1=LG->y1, y2=LG->y2;
    492c:	0e 94 41 82 	call	0x10482	; 0x10482 <__floatsisf>
    4930:	5b 01       	movw	r10, r22
    4932:	6c 01       	movw	r12, r24
    4934:	6a 85       	ldd	r22, Y+10	; 0x0a
    4936:	7b 85       	ldd	r23, Y+11	; 0x0b
    4938:	88 27       	eor	r24, r24
    493a:	77 fd       	sbrc	r23, 7
    493c:	80 95       	com	r24
    493e:	98 2f       	mov	r25, r24
    4940:	0e 94 41 82 	call	0x10482	; 0x10482 <__floatsisf>
    4944:	3b 01       	movw	r6, r22
    4946:	4c 01       	movw	r8, r24
		y = (x-x2)*(y2-y1)/(x2-x1)+y2;
    4948:	c8 01       	movw	r24, r16
    494a:	b7 01       	movw	r22, r14
    494c:	0e 94 41 82 	call	0x10482	; 0x10482 <__floatsisf>
    4950:	a6 01       	movw	r20, r12
    4952:	95 01       	movw	r18, r10
    4954:	0e 94 42 86 	call	0x10c84	; 0x10c84 <__subsf3>
    4958:	7b 01       	movw	r14, r22
    495a:	8c 01       	movw	r16, r24
    495c:	68 85       	ldd	r22, Y+8	; 0x08
    495e:	79 85       	ldd	r23, Y+9	; 0x09
    4960:	88 27       	eor	r24, r24
    4962:	77 fd       	sbrc	r23, 7
    4964:	80 95       	com	r24
    4966:	98 2f       	mov	r25, r24
    4968:	0e 94 41 82 	call	0x10482	; 0x10482 <__floatsisf>
    496c:	9b 01       	movw	r18, r22
    496e:	ac 01       	movw	r20, r24
    4970:	c4 01       	movw	r24, r8
    4972:	b3 01       	movw	r22, r6
    4974:	0e 94 42 86 	call	0x10c84	; 0x10c84 <__subsf3>
    4978:	9b 01       	movw	r18, r22
    497a:	ac 01       	movw	r20, r24
    497c:	c8 01       	movw	r24, r16
    497e:	b7 01       	movw	r22, r14
    4980:	0e 94 7c 82 	call	0x104f8	; 0x104f8 <__mulsf3>
    4984:	7b 01       	movw	r14, r22
    4986:	8c 01       	movw	r16, r24
    4988:	c2 01       	movw	r24, r4
    498a:	b1 01       	movw	r22, r2
    498c:	0e 94 41 82 	call	0x10482	; 0x10482 <__floatsisf>
    4990:	9b 01       	movw	r18, r22
    4992:	ac 01       	movw	r20, r24
    4994:	c6 01       	movw	r24, r12
    4996:	b5 01       	movw	r22, r10
    4998:	0e 94 42 86 	call	0x10c84	; 0x10c84 <__subsf3>
    499c:	9b 01       	movw	r18, r22
    499e:	ac 01       	movw	r20, r24
    49a0:	c8 01       	movw	r24, r16
    49a2:	b7 01       	movw	r22, r14
    49a4:	0e 94 a7 86 	call	0x10d4e	; 0x10d4e <__divsf3>
    49a8:	a4 01       	movw	r20, r8
    49aa:	93 01       	movw	r18, r6
    49ac:	0e 94 43 86 	call	0x10c86	; 0x10c86 <__addsf3>
    49b0:	0e 94 0f 87 	call	0x10e1e	; 0x10e1e <__fixsfsi>
    49b4:	cb 01       	movw	r24, r22
	}
	return y;
}
    49b6:	df 91       	pop	r29
    49b8:	cf 91       	pop	r28
    49ba:	1f 91       	pop	r17
    49bc:	0f 91       	pop	r16
    49be:	ff 90       	pop	r15
    49c0:	ef 90       	pop	r14
    49c2:	df 90       	pop	r13
    49c4:	cf 90       	pop	r12
    49c6:	bf 90       	pop	r11
    49c8:	af 90       	pop	r10
    49ca:	9f 90       	pop	r9
    49cc:	8f 90       	pop	r8
    49ce:	7f 90       	pop	r7
    49d0:	6f 90       	pop	r6
    49d2:	5f 90       	pop	r5
    49d4:	4f 90       	pop	r4
    49d6:	3f 90       	pop	r3
    49d8:	2f 90       	pop	r2
    49da:	08 95       	ret
int16_t
LineFunc(const LineGraph *LG, int32_t x)
{
	int16_t y;
	if (LG->x1==LG->x2)
		y = LG->y1;
    49dc:	88 85       	ldd	r24, Y+8	; 0x08
    49de:	99 85       	ldd	r25, Y+9	; 0x09
    49e0:	ea cf       	rjmp	.-44     	; 0x49b6 <LineFunc+0xd0>

000049e2 <uLineFunc>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
int16_t
uLineFunc(const uLineGraph *LG, uint32_t x)
{
    49e2:	2f 92       	push	r2
    49e4:	3f 92       	push	r3
    49e6:	4f 92       	push	r4
    49e8:	5f 92       	push	r5
    49ea:	6f 92       	push	r6
    49ec:	7f 92       	push	r7
    49ee:	8f 92       	push	r8
    49f0:	9f 92       	push	r9
    49f2:	af 92       	push	r10
    49f4:	bf 92       	push	r11
    49f6:	cf 92       	push	r12
    49f8:	df 92       	push	r13
    49fa:	ef 92       	push	r14
    49fc:	ff 92       	push	r15
    49fe:	0f 93       	push	r16
    4a00:	1f 93       	push	r17
    4a02:	cf 93       	push	r28
    4a04:	df 93       	push	r29
    4a06:	ec 01       	movw	r28, r24
    4a08:	7a 01       	movw	r14, r20
    4a0a:	8b 01       	movw	r16, r22
	int16_t y;
	if (LG->x1==LG->x2)
    4a0c:	28 80       	ld	r2, Y
    4a0e:	39 80       	ldd	r3, Y+1	; 0x01
    4a10:	4a 80       	ldd	r4, Y+2	; 0x02
    4a12:	5b 80       	ldd	r5, Y+3	; 0x03
    4a14:	6c 81       	ldd	r22, Y+4	; 0x04
    4a16:	7d 81       	ldd	r23, Y+5	; 0x05
    4a18:	8e 81       	ldd	r24, Y+6	; 0x06
    4a1a:	9f 81       	ldd	r25, Y+7	; 0x07
    4a1c:	26 16       	cp	r2, r22
    4a1e:	37 06       	cpc	r3, r23
    4a20:	48 06       	cpc	r4, r24
    4a22:	59 06       	cpc	r5, r25
    4a24:	09 f4       	brne	.+2      	; 0x4a28 <uLineFunc+0x46>
    4a26:	58 c0       	rjmp	.+176    	; 0x4ad8 <uLineFunc+0xf6>
		y = LG->y1;
	else {
		float x1=LG->x1, x2=LG->x2, y1=LG->y1, y2=LG->y2;
    4a28:	0e 94 3f 82 	call	0x1047e	; 0x1047e <__floatunsisf>
    4a2c:	5b 01       	movw	r10, r22
    4a2e:	6c 01       	movw	r12, r24
    4a30:	6a 85       	ldd	r22, Y+10	; 0x0a
    4a32:	7b 85       	ldd	r23, Y+11	; 0x0b
    4a34:	88 27       	eor	r24, r24
    4a36:	77 fd       	sbrc	r23, 7
    4a38:	80 95       	com	r24
    4a3a:	98 2f       	mov	r25, r24
    4a3c:	0e 94 41 82 	call	0x10482	; 0x10482 <__floatsisf>
    4a40:	3b 01       	movw	r6, r22
    4a42:	4c 01       	movw	r8, r24
		y = (x-x2)*(y2-y1)/(x2-x1)+y2;
    4a44:	c8 01       	movw	r24, r16
    4a46:	b7 01       	movw	r22, r14
    4a48:	0e 94 3f 82 	call	0x1047e	; 0x1047e <__floatunsisf>
    4a4c:	a6 01       	movw	r20, r12
    4a4e:	95 01       	movw	r18, r10
    4a50:	0e 94 42 86 	call	0x10c84	; 0x10c84 <__subsf3>
    4a54:	7b 01       	movw	r14, r22
    4a56:	8c 01       	movw	r16, r24
    4a58:	68 85       	ldd	r22, Y+8	; 0x08
    4a5a:	79 85       	ldd	r23, Y+9	; 0x09
    4a5c:	88 27       	eor	r24, r24
    4a5e:	77 fd       	sbrc	r23, 7
    4a60:	80 95       	com	r24
    4a62:	98 2f       	mov	r25, r24
    4a64:	0e 94 41 82 	call	0x10482	; 0x10482 <__floatsisf>
    4a68:	9b 01       	movw	r18, r22
    4a6a:	ac 01       	movw	r20, r24
    4a6c:	c4 01       	movw	r24, r8
    4a6e:	b3 01       	movw	r22, r6
    4a70:	0e 94 42 86 	call	0x10c84	; 0x10c84 <__subsf3>
    4a74:	9b 01       	movw	r18, r22
    4a76:	ac 01       	movw	r20, r24
    4a78:	c8 01       	movw	r24, r16
    4a7a:	b7 01       	movw	r22, r14
    4a7c:	0e 94 7c 82 	call	0x104f8	; 0x104f8 <__mulsf3>
    4a80:	7b 01       	movw	r14, r22
    4a82:	8c 01       	movw	r16, r24
    4a84:	c2 01       	movw	r24, r4
    4a86:	b1 01       	movw	r22, r2
    4a88:	0e 94 3f 82 	call	0x1047e	; 0x1047e <__floatunsisf>
    4a8c:	9b 01       	movw	r18, r22
    4a8e:	ac 01       	movw	r20, r24
    4a90:	c6 01       	movw	r24, r12
    4a92:	b5 01       	movw	r22, r10
    4a94:	0e 94 42 86 	call	0x10c84	; 0x10c84 <__subsf3>
    4a98:	9b 01       	movw	r18, r22
    4a9a:	ac 01       	movw	r20, r24
    4a9c:	c8 01       	movw	r24, r16
    4a9e:	b7 01       	movw	r22, r14
    4aa0:	0e 94 a7 86 	call	0x10d4e	; 0x10d4e <__divsf3>
    4aa4:	a4 01       	movw	r20, r8
    4aa6:	93 01       	movw	r18, r6
    4aa8:	0e 94 43 86 	call	0x10c86	; 0x10c86 <__addsf3>
    4aac:	0e 94 0f 87 	call	0x10e1e	; 0x10e1e <__fixsfsi>
    4ab0:	cb 01       	movw	r24, r22
	}
	return y;
}
    4ab2:	df 91       	pop	r29
    4ab4:	cf 91       	pop	r28
    4ab6:	1f 91       	pop	r17
    4ab8:	0f 91       	pop	r16
    4aba:	ff 90       	pop	r15
    4abc:	ef 90       	pop	r14
    4abe:	df 90       	pop	r13
    4ac0:	cf 90       	pop	r12
    4ac2:	bf 90       	pop	r11
    4ac4:	af 90       	pop	r10
    4ac6:	9f 90       	pop	r9
    4ac8:	8f 90       	pop	r8
    4aca:	7f 90       	pop	r7
    4acc:	6f 90       	pop	r6
    4ace:	5f 90       	pop	r5
    4ad0:	4f 90       	pop	r4
    4ad2:	3f 90       	pop	r3
    4ad4:	2f 90       	pop	r2
    4ad6:	08 95       	ret
int16_t
uLineFunc(const uLineGraph *LG, uint32_t x)
{
	int16_t y;
	if (LG->x1==LG->x2)
		y = LG->y1;
    4ad8:	88 85       	ldd	r24, Y+8	; 0x08
    4ada:	99 85       	ldd	r25, Y+9	; 0x09
    4adc:	ea cf       	rjmp	.-44     	; 0x4ab2 <uLineFunc+0xd0>

00004ade <PGM_uBrokLine>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
int16_t
PGM_uBrokLine(PGM_uDataPoint *Brok, uint16_t x)
{
    4ade:	af 92       	push	r10
    4ae0:	bf 92       	push	r11
    4ae2:	cf 92       	push	r12
    4ae4:	df 92       	push	r13
    4ae6:	ef 92       	push	r14
    4ae8:	ff 92       	push	r15
    4aea:	0f 93       	push	r16
    4aec:	1f 93       	push	r17
    4aee:	df 93       	push	r29
    4af0:	cf 93       	push	r28
    4af2:	cd b7       	in	r28, 0x3d	; 61
    4af4:	de b7       	in	r29, 0x3e	; 62
    4af6:	2c 97       	sbiw	r28, 0x0c	; 12
    4af8:	0f b6       	in	r0, 0x3f	; 63
    4afa:	f8 94       	cli
    4afc:	de bf       	out	0x3e, r29	; 62
    4afe:	0f be       	out	0x3f, r0	; 63
    4b00:	cd bf       	out	0x3d, r28	; 61
    4b02:	dc 01       	movw	r26, r24

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    4b04:	fc 01       	movw	r30, r24
    4b06:	85 91       	lpm	r24, Z+
    4b08:	94 91       	lpm	r25, Z+
	uLineGraph Segm;
	Segm.x2 = prw(&Brok->x);
    4b0a:	7c 01       	movw	r14, r24
    4b0c:	00 e0       	ldi	r16, 0x00	; 0
    4b0e:	10 e0       	ldi	r17, 0x00	; 0
    4b10:	5b 01       	movw	r10, r22
    4b12:	cc 24       	eor	r12, r12
    4b14:	dd 24       	eor	r13, r13
	do {
		Segm.x1 = Segm.x2;
		Segm.x2 = prw(&(++Brok)->x);
    4b16:	cd 01       	movw	r24, r26
    4b18:	04 96       	adiw	r24, 0x04	; 4
    4b1a:	fc 01       	movw	r30, r24
    4b1c:	25 91       	lpm	r18, Z+
    4b1e:	34 91       	lpm	r19, Z+
    4b20:	ad 01       	movw	r20, r26
    4b22:	b7 01       	movw	r22, r14
    4b24:	f8 01       	movw	r30, r16
    4b26:	dc 01       	movw	r26, r24
    4b28:	79 01       	movw	r14, r18
    4b2a:	00 e0       	ldi	r16, 0x00	; 0
    4b2c:	10 e0       	ldi	r17, 0x00	; 0
	} while(x>Segm.x2);
    4b2e:	ea 14       	cp	r14, r10
    4b30:	fb 04       	cpc	r15, r11
    4b32:	0c 05       	cpc	r16, r12
    4b34:	1d 05       	cpc	r17, r13
    4b36:	78 f3       	brcs	.-34     	; 0x4b16 <PGM_uBrokLine+0x38>
    4b38:	ca 01       	movw	r24, r20
    4b3a:	9b 01       	movw	r18, r22
    4b3c:	af 01       	movw	r20, r30
    4b3e:	69 83       	std	Y+1, r22	; 0x01
    4b40:	3a 83       	std	Y+2, r19	; 0x02
    4b42:	eb 83       	std	Y+3, r30	; 0x03
    4b44:	5c 83       	std	Y+4, r21	; 0x04
    4b46:	ed 82       	std	Y+5, r14	; 0x05
    4b48:	fe 82       	std	Y+6, r15	; 0x06
    4b4a:	0f 83       	std	Y+7, r16	; 0x07
    4b4c:	18 87       	std	Y+8, r17	; 0x08
    4b4e:	fc 01       	movw	r30, r24
    4b50:	32 96       	adiw	r30, 0x02	; 2
    4b52:	85 91       	lpm	r24, Z+
    4b54:	94 91       	lpm	r25, Z+
	Segm.y1 = (int16_t)prw(&(Brok-1)->y);
    4b56:	9a 87       	std	Y+10, r25	; 0x0a
    4b58:	89 87       	std	Y+9, r24	; 0x09
    4b5a:	fd 01       	movw	r30, r26
    4b5c:	32 96       	adiw	r30, 0x02	; 2
    4b5e:	85 91       	lpm	r24, Z+
    4b60:	94 91       	lpm	r25, Z+
	Segm.y2 = (int16_t)prw(&Brok->y);
    4b62:	9c 87       	std	Y+12, r25	; 0x0c
    4b64:	8b 87       	std	Y+11, r24	; 0x0b
	return uLineFunc(&Segm, x);
    4b66:	ce 01       	movw	r24, r28
    4b68:	01 96       	adiw	r24, 0x01	; 1
    4b6a:	b6 01       	movw	r22, r12
    4b6c:	a5 01       	movw	r20, r10
    4b6e:	0e 94 f1 24 	call	0x49e2	; 0x49e2 <uLineFunc>
}
    4b72:	2c 96       	adiw	r28, 0x0c	; 12
    4b74:	0f b6       	in	r0, 0x3f	; 63
    4b76:	f8 94       	cli
    4b78:	de bf       	out	0x3e, r29	; 62
    4b7a:	0f be       	out	0x3f, r0	; 63
    4b7c:	cd bf       	out	0x3d, r28	; 61
    4b7e:	cf 91       	pop	r28
    4b80:	df 91       	pop	r29
    4b82:	1f 91       	pop	r17
    4b84:	0f 91       	pop	r16
    4b86:	ff 90       	pop	r15
    4b88:	ef 90       	pop	r14
    4b8a:	df 90       	pop	r13
    4b8c:	cf 90       	pop	r12
    4b8e:	bf 90       	pop	r11
    4b90:	af 90       	pop	r10
    4b92:	08 95       	ret

00004b94 <InterBrokLine>:
	uint8_t WiAbsc, int16_t (*TblAbsc)[WiAbsc], uint8_t Absc,
	uint8_t WiOrdi, int16_t (*TblOrdi)[WiOrdi], uint8_t Ordi,
	uint8_t Len,
	int16_t x
)
{
    4b94:	2f 92       	push	r2
    4b96:	3f 92       	push	r3
    4b98:	4f 92       	push	r4
    4b9a:	5f 92       	push	r5
    4b9c:	6f 92       	push	r6
    4b9e:	7f 92       	push	r7
    4ba0:	8f 92       	push	r8
    4ba2:	9f 92       	push	r9
    4ba4:	af 92       	push	r10
    4ba6:	bf 92       	push	r11
    4ba8:	cf 92       	push	r12
    4baa:	df 92       	push	r13
    4bac:	ef 92       	push	r14
    4bae:	ff 92       	push	r15
    4bb0:	0f 93       	push	r16
    4bb2:	1f 93       	push	r17
    4bb4:	df 93       	push	r29
    4bb6:	cf 93       	push	r28
    4bb8:	cd b7       	in	r28, 0x3d	; 61
    4bba:	de b7       	in	r29, 0x3e	; 62
    4bbc:	2e 97       	sbiw	r28, 0x0e	; 14
    4bbe:	0f b6       	in	r0, 0x3f	; 63
    4bc0:	f8 94       	cli
    4bc2:	de bf       	out	0x3e, r29	; 62
    4bc4:	0f be       	out	0x3f, r0	; 63
    4bc6:	cd bf       	out	0x3d, r28	; 61
    4bc8:	2b 01       	movw	r4, r22
    4bca:	2d 87       	std	Y+13, r18	; 0x0d
    4bcc:	18 01       	movw	r2, r16
    4bce:	ee 86       	std	Y+14, r14	; 0x0e
    4bd0:	7c 2d       	mov	r23, r12
	LineGraph Segm;
	uint8_t i = 0;
	Segm.x2=TblAbsc[0][Absc];
    4bd2:	c4 2e       	mov	r12, r20
    4bd4:	dd 24       	eor	r13, r13
    4bd6:	cc 0c       	add	r12, r12
    4bd8:	dd 1c       	adc	r13, r13
    4bda:	f2 01       	movw	r30, r4
    4bdc:	ec 0d       	add	r30, r12
    4bde:	fd 1d       	adc	r31, r13
    4be0:	20 81       	ld	r18, Z
    4be2:	31 81       	ldd	r19, Z+1	; 0x01
    4be4:	79 01       	movw	r14, r18
    4be6:	00 27       	eor	r16, r16
    4be8:	f7 fc       	sbrc	r15, 7
    4bea:	00 95       	com	r16
    4bec:	10 2f       	mov	r17, r16
    4bee:	ed 82       	std	Y+5, r14	; 0x05
    4bf0:	fe 82       	std	Y+6, r15	; 0x06
    4bf2:	0f 83       	std	Y+7, r16	; 0x07
    4bf4:	18 87       	std	Y+8, r17	; 0x08
    4bf6:	a8 2f       	mov	r26, r24
    4bf8:	b0 e0       	ldi	r27, 0x00	; 0
    4bfa:	aa 0f       	add	r26, r26
    4bfc:	bb 1f       	adc	r27, r27
    4bfe:	35 01       	movw	r6, r10
    4c00:	88 24       	eor	r8, r8
    4c02:	77 fc       	sbrc	r7, 7
    4c04:	80 94       	com	r8
    4c06:	98 2c       	mov	r9, r8
    4c08:	60 e0       	ldi	r22, 0x00	; 0
    4c0a:	02 c0       	rjmp	.+4      	; 0x4c10 <InterBrokLine+0x7c>
	do {
		Segm.x1 = Segm.x2;
		Segm.x2 = TblAbsc[++i][Absc];
	} while(x>Segm.x2 && i<Len);
    4c0c:	79 01       	movw	r14, r18
    4c0e:	8a 01       	movw	r16, r20
	LineGraph Segm;
	uint8_t i = 0;
	Segm.x2=TblAbsc[0][Absc];
	do {
		Segm.x1 = Segm.x2;
		Segm.x2 = TblAbsc[++i][Absc];
    4c10:	6f 5f       	subi	r22, 0xFF	; 255
    4c12:	a6 2e       	mov	r10, r22
    4c14:	bb 24       	eor	r11, r11
    4c16:	aa 9e       	mul	r10, r26
    4c18:	f0 01       	movw	r30, r0
    4c1a:	ab 9e       	mul	r10, r27
    4c1c:	f0 0d       	add	r31, r0
    4c1e:	ba 9e       	mul	r11, r26
    4c20:	f0 0d       	add	r31, r0
    4c22:	11 24       	eor	r1, r1
    4c24:	e4 0d       	add	r30, r4
    4c26:	f5 1d       	adc	r31, r5
    4c28:	ec 0d       	add	r30, r12
    4c2a:	fd 1d       	adc	r31, r13
    4c2c:	80 81       	ld	r24, Z
    4c2e:	91 81       	ldd	r25, Z+1	; 0x01
    4c30:	9c 01       	movw	r18, r24
    4c32:	44 27       	eor	r20, r20
    4c34:	37 fd       	sbrc	r19, 7
    4c36:	40 95       	com	r20
    4c38:	54 2f       	mov	r21, r20
	} while(x>Segm.x2 && i<Len);
    4c3a:	26 15       	cp	r18, r6
    4c3c:	37 05       	cpc	r19, r7
    4c3e:	48 05       	cpc	r20, r8
    4c40:	59 05       	cpc	r21, r9
    4c42:	14 f4       	brge	.+4      	; 0x4c48 <InterBrokLine+0xb4>
    4c44:	67 17       	cp	r22, r23
    4c46:	10 f3       	brcs	.-60     	; 0x4c0c <InterBrokLine+0x78>
    4c48:	e9 82       	std	Y+1, r14	; 0x01
    4c4a:	fa 82       	std	Y+2, r15	; 0x02
    4c4c:	0b 83       	std	Y+3, r16	; 0x03
    4c4e:	1c 83       	std	Y+4, r17	; 0x04
    4c50:	2d 83       	std	Y+5, r18	; 0x05
    4c52:	3e 83       	std	Y+6, r19	; 0x06
    4c54:	4f 83       	std	Y+7, r20	; 0x07
    4c56:	58 87       	std	Y+8, r21	; 0x08
	Segm.y1 = TblOrdi[i-1][Ordi];
    4c58:	8d 85       	ldd	r24, Y+13	; 0x0d
    4c5a:	28 2f       	mov	r18, r24
    4c5c:	30 e0       	ldi	r19, 0x00	; 0
    4c5e:	22 0f       	add	r18, r18
    4c60:	33 1f       	adc	r19, r19
    4c62:	8e 85       	ldd	r24, Y+14	; 0x0e
    4c64:	a8 2f       	mov	r26, r24
    4c66:	b0 e0       	ldi	r27, 0x00	; 0
    4c68:	08 94       	sec
    4c6a:	a1 08       	sbc	r10, r1
    4c6c:	b1 08       	sbc	r11, r1
    4c6e:	a2 9e       	mul	r10, r18
    4c70:	f0 01       	movw	r30, r0
    4c72:	a3 9e       	mul	r10, r19
    4c74:	f0 0d       	add	r31, r0
    4c76:	b2 9e       	mul	r11, r18
    4c78:	f0 0d       	add	r31, r0
    4c7a:	11 24       	eor	r1, r1
    4c7c:	08 94       	sec
    4c7e:	a1 1c       	adc	r10, r1
    4c80:	b1 1c       	adc	r11, r1
    4c82:	e2 0d       	add	r30, r2
    4c84:	f3 1d       	adc	r31, r3
    4c86:	aa 0f       	add	r26, r26
    4c88:	bb 1f       	adc	r27, r27
    4c8a:	ea 0f       	add	r30, r26
    4c8c:	fb 1f       	adc	r31, r27
    4c8e:	80 81       	ld	r24, Z
    4c90:	91 81       	ldd	r25, Z+1	; 0x01
    4c92:	9a 87       	std	Y+10, r25	; 0x0a
    4c94:	89 87       	std	Y+9, r24	; 0x09
	Segm.y2 = TblOrdi[i][Ordi];
    4c96:	a2 9e       	mul	r10, r18
    4c98:	c0 01       	movw	r24, r0
    4c9a:	a3 9e       	mul	r10, r19
    4c9c:	90 0d       	add	r25, r0
    4c9e:	b2 9e       	mul	r11, r18
    4ca0:	90 0d       	add	r25, r0
    4ca2:	11 24       	eor	r1, r1
    4ca4:	82 0d       	add	r24, r2
    4ca6:	93 1d       	adc	r25, r3
    4ca8:	a8 0f       	add	r26, r24
    4caa:	b9 1f       	adc	r27, r25
    4cac:	8d 91       	ld	r24, X+
    4cae:	9c 91       	ld	r25, X
    4cb0:	9c 87       	std	Y+12, r25	; 0x0c
    4cb2:	8b 87       	std	Y+11, r24	; 0x0b
	return LineFunc(&Segm, x);
    4cb4:	ce 01       	movw	r24, r28
    4cb6:	01 96       	adiw	r24, 0x01	; 1
    4cb8:	b4 01       	movw	r22, r8
    4cba:	a3 01       	movw	r20, r6
    4cbc:	0e 94 73 24 	call	0x48e6	; 0x48e6 <LineFunc>
}
    4cc0:	2e 96       	adiw	r28, 0x0e	; 14
    4cc2:	0f b6       	in	r0, 0x3f	; 63
    4cc4:	f8 94       	cli
    4cc6:	de bf       	out	0x3e, r29	; 62
    4cc8:	0f be       	out	0x3f, r0	; 63
    4cca:	cd bf       	out	0x3d, r28	; 61
    4ccc:	cf 91       	pop	r28
    4cce:	df 91       	pop	r29
    4cd0:	1f 91       	pop	r17
    4cd2:	0f 91       	pop	r16
    4cd4:	ff 90       	pop	r15
    4cd6:	ef 90       	pop	r14
    4cd8:	df 90       	pop	r13
    4cda:	cf 90       	pop	r12
    4cdc:	bf 90       	pop	r11
    4cde:	af 90       	pop	r10
    4ce0:	9f 90       	pop	r9
    4ce2:	8f 90       	pop	r8
    4ce4:	7f 90       	pop	r7
    4ce6:	6f 90       	pop	r6
    4ce8:	5f 90       	pop	r5
    4cea:	4f 90       	pop	r4
    4cec:	3f 90       	pop	r3
    4cee:	2f 90       	pop	r2
    4cf0:	08 95       	ret

00004cf2 <TWI_Init>:
}

uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    4cf2:	90 91 cf 02 	lds	r25, 0x02CF
	VacantTimer8Sys += n;
    4cf6:	89 2f       	mov	r24, r25
    4cf8:	8f 5f       	subi	r24, 0xFF	; 255

// ~~~~~~~~~~~
void
TWI_Init(void)
{
	TD_TWI_Poll = Timer8SysAlloc(1);
    4cfa:	90 93 d2 04 	sts	0x04D2, r25
    4cfe:	8f 5f       	subi	r24, 0xFF	; 255
    4d00:	80 93 cf 02 	sts	0x02CF, r24
    4d04:	81 50       	subi	r24, 0x01	; 1
	TD_TWI_Timeout = Timer8SysAlloc(1);
    4d06:	80 93 d3 04 	sts	0x04D3, r24

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    4d0a:	80 91 d0 02 	lds	r24, 0x02D0
	VacantTimer16Sys += n;
    4d0e:	8f 5f       	subi	r24, 0xFF	; 255
    4d10:	80 93 d0 02 	sts	0x02D0, r24
    4d14:	81 50       	subi	r24, 0x01	; 1
	TD_RTC_Check = Timer16SysAlloc(1);
    4d16:	80 93 d4 04 	sts	0x04D4, r24
	StartTimer16(TD_RTC_Check, 300);
    4d1a:	6c e2       	ldi	r22, 0x2C	; 44
    4d1c:	71 e0       	ldi	r23, 0x01	; 1
    4d1e:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
	TWBR = 144;	//50
    4d22:	80 e9       	ldi	r24, 0x90	; 144
    4d24:	80 93 b8 00 	sts	0x00B8, r24
}
    4d28:	08 95       	ret

00004d2a <TWI_Error>:
// ~~~~~~~~~~~
void
TWI_Error(void)
{
	TWI_Error_Counter++;
    4d2a:	80 91 e5 08 	lds	r24, 0x08E5
    4d2e:	90 91 e6 08 	lds	r25, 0x08E6
    4d32:	01 96       	adiw	r24, 0x01	; 1
    4d34:	90 93 e6 08 	sts	0x08E6, r25
    4d38:	80 93 e5 08 	sts	0x08E5, r24
	//StopTWI();
	PowerOffTWI();
    4d3c:	10 92 bc 00 	sts	0x00BC, r1
	TWI_Phase = PCF_START;
    4d40:	10 92 c3 07 	sts	0x07C3, r1
	StartTimer8(TD_TWI_Poll, 49);
    4d44:	80 91 d2 04 	lds	r24, 0x04D2
    4d48:	61 e3       	ldi	r22, 0x31	; 49
    4d4a:	0e 94 0d 1e 	call	0x3c1a	; 0x3c1a <StartTimer8>
}
    4d4e:	08 95       	ret

00004d50 <WriteRTC>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
WriteRTC(uint8_t Addr, uint8_t Dat)
{
    4d50:	bf 92       	push	r11
    4d52:	cf 92       	push	r12
    4d54:	df 92       	push	r13
    4d56:	ef 92       	push	r14
    4d58:	ff 92       	push	r15
    4d5a:	0f 93       	push	r16
    4d5c:	1f 93       	push	r17
/*	if (!(TWCR &(1<<TWINT))){ //Wait for the end of current TWI operation and isuue STOP
		_delay_us(100);
		StopTWI();
		_delay_us(50);
	}*/
	PowerOffTWI();
    4d5e:	4c eb       	ldi	r20, 0xBC	; 188
    4d60:	c4 2e       	mov	r12, r20
    4d62:	d1 2c       	mov	r13, r1
    4d64:	f6 01       	movw	r30, r12
    4d66:	10 82       	st	Z, r1
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    4d68:	e0 e9       	ldi	r30, 0x90	; 144
    4d6a:	f1 e0       	ldi	r31, 0x01	; 1
    4d6c:	31 97       	sbiw	r30, 0x01	; 1
    4d6e:	f1 f7       	brne	.-4      	; 0x4d6c <WriteRTC+0x1c>
	_delay_us(100);
	//_delay_us(150);_delay_us(150);
	StartTWI();
    4d70:	94 ea       	ldi	r25, 0xA4	; 164
    4d72:	f6 01       	movw	r30, r12
    4d74:	90 83       	st	Z, r25
    4d76:	08 e5       	ldi	r16, 0x58	; 88
    4d78:	12 e0       	ldi	r17, 0x02	; 2
    4d7a:	f8 01       	movw	r30, r16
    4d7c:	31 97       	sbiw	r30, 0x01	; 1
    4d7e:	f1 f7       	brne	.-4      	; 0x4d7c <WriteRTC+0x2c>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = SLA_W(PCF_SLA);
    4d80:	f8 01       	movw	r30, r16
    4d82:	31 97       	sbiw	r30, 0x01	; 1
    4d84:	f1 f7       	brne	.-4      	; 0x4d82 <WriteRTC+0x32>
    4d86:	3b eb       	ldi	r19, 0xBB	; 187
    4d88:	e3 2e       	mov	r14, r19
    4d8a:	f1 2c       	mov	r15, r1
    4d8c:	90 ed       	ldi	r25, 0xD0	; 208
    4d8e:	f7 01       	movw	r30, r14
    4d90:	90 83       	st	Z, r25
    4d92:	90 81       	ld	r25, Z
    4d94:	90 83       	st	Z, r25
	RunTWI();
    4d96:	24 e8       	ldi	r18, 0x84	; 132
    4d98:	b2 2e       	mov	r11, r18
    4d9a:	f6 01       	movw	r30, r12
    4d9c:	b0 82       	st	Z, r11
    4d9e:	f8 01       	movw	r30, r16
    4da0:	31 97       	sbiw	r30, 0x01	; 1
    4da2:	f1 f7       	brne	.-4      	; 0x4da0 <WriteRTC+0x50>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = AddrSec+Addr;
    4da4:	f8 01       	movw	r30, r16
    4da6:	31 97       	sbiw	r30, 0x01	; 1
    4da8:	f1 f7       	brne	.-4      	; 0x4da6 <WriteRTC+0x56>
    4daa:	f7 01       	movw	r30, r14
    4dac:	80 83       	st	Z, r24
	RunTWI();
    4dae:	f6 01       	movw	r30, r12
    4db0:	b0 82       	st	Z, r11
    4db2:	c8 01       	movw	r24, r16
    4db4:	01 97       	sbiw	r24, 0x01	; 1
    4db6:	f1 f7       	brne	.-4      	; 0x4db4 <WriteRTC+0x64>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = CodBCD(Dat);
    4db8:	c8 01       	movw	r24, r16
    4dba:	01 97       	sbiw	r24, 0x01	; 1
    4dbc:	f1 f7       	brne	.-4      	; 0x4dba <WriteRTC+0x6a>
    4dbe:	86 2f       	mov	r24, r22
    4dc0:	0e 94 5c 24 	call	0x48b8	; 0x48b8 <CodBCD>
    4dc4:	f7 01       	movw	r30, r14
    4dc6:	80 83       	st	Z, r24
	RunTWI();
    4dc8:	f6 01       	movw	r30, r12
    4dca:	b0 82       	st	Z, r11
    4dcc:	c8 01       	movw	r24, r16
    4dce:	01 97       	sbiw	r24, 0x01	; 1
    4dd0:	f1 f7       	brne	.-4      	; 0x4dce <WriteRTC+0x7e>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	StopTWI();
    4dd2:	c8 01       	movw	r24, r16
    4dd4:	01 97       	sbiw	r24, 0x01	; 1
    4dd6:	f1 f7       	brne	.-4      	; 0x4dd4 <WriteRTC+0x84>
    4dd8:	84 e9       	ldi	r24, 0x94	; 148
    4dda:	80 83       	st	Z, r24
	TWI_Phase = PCF_START;
    4ddc:	10 92 c3 07 	sts	0x07C3, r1
}
    4de0:	1f 91       	pop	r17
    4de2:	0f 91       	pop	r16
    4de4:	ff 90       	pop	r15
    4de6:	ef 90       	pop	r14
    4de8:	df 90       	pop	r13
    4dea:	cf 90       	pop	r12
    4dec:	bf 90       	pop	r11
    4dee:	08 95       	ret

00004df0 <SetWeekday>:
*/

// ~~~~~~~~~~~~~~~
// 31.12.00 was Su
uint8_t SetWeekday(uint8_t Year, uint8_t Month, uint8_t MDay)
{
    4df0:	a6 2f       	mov	r26, r22
	uint8_t DayCount;
	uint8_t LastYear = Year-1;
    4df2:	b8 2f       	mov	r27, r24
    4df4:	b1 50       	subi	r27, 0x01	; 1

	DayCount = (LastYear+LastYear/4);
    4df6:	5b 2f       	mov	r21, r27
    4df8:	56 95       	lsr	r21
    4dfa:	56 95       	lsr	r21
    4dfc:	5b 0f       	add	r21, r27
	for (uint8_t i=1; i<Month; DayCount+=prb(DaysMonth+i++)%7);
    4dfe:	62 30       	cpi	r22, 0x02	; 2
    4e00:	88 f0       	brcs	.+34     	; 0x4e24 <SetWeekday+0x34>
    4e02:	e4 e2       	ldi	r30, 0x24	; 36
    4e04:	f3 e0       	ldi	r31, 0x03	; 3
    4e06:	a2 50       	subi	r26, 0x02	; 2
    4e08:	2a 2f       	mov	r18, r26
    4e0a:	30 e0       	ldi	r19, 0x00	; 0
    4e0c:	ae 5f       	subi	r26, 0xFE	; 254
    4e0e:	2b 5d       	subi	r18, 0xDB	; 219
    4e10:	3c 4f       	sbci	r19, 0xFC	; 252

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    4e12:	84 91       	lpm	r24, Z+
    4e14:	67 e0       	ldi	r22, 0x07	; 7
    4e16:	0e 94 ab 87 	call	0x10f56	; 0x10f56 <__udivmodqi4>
    4e1a:	59 0f       	add	r21, r25
    4e1c:	31 96       	adiw	r30, 0x01	; 1
    4e1e:	e2 17       	cp	r30, r18
    4e20:	f3 07       	cpc	r31, r19
    4e22:	b9 f7       	brne	.-18     	; 0x4e12 <SetWeekday+0x22>
    4e24:	25 2f       	mov	r18, r21
	if (LastYear%4==3 && Month>2)
    4e26:	b3 70       	andi	r27, 0x03	; 3
    4e28:	b3 30       	cpi	r27, 0x03	; 3
    4e2a:	51 f0       	breq	.+20     	; 0x4e40 <SetWeekday+0x50>
		DayCount++;
    4e2c:	84 2f       	mov	r24, r20
    4e2e:	67 e0       	ldi	r22, 0x07	; 7
    4e30:	0e 94 ab 87 	call	0x10f56	; 0x10f56 <__udivmodqi4>
    4e34:	82 2f       	mov	r24, r18
    4e36:	89 0f       	add	r24, r25
    4e38:	0e 94 ab 87 	call	0x10f56	; 0x10f56 <__udivmodqi4>
	DayCount += MDay%7;
	return DayCount%7;
}
    4e3c:	89 2f       	mov	r24, r25
    4e3e:	08 95       	ret
	uint8_t DayCount;
	uint8_t LastYear = Year-1;

	DayCount = (LastYear+LastYear/4);
	for (uint8_t i=1; i<Month; DayCount+=prb(DaysMonth+i++)%7);
	if (LastYear%4==3 && Month>2)
    4e40:	a3 30       	cpi	r26, 0x03	; 3
    4e42:	a0 f3       	brcs	.-24     	; 0x4e2c <SetWeekday+0x3c>
		DayCount++;
    4e44:	2f 5f       	subi	r18, 0xFF	; 255
    4e46:	f2 cf       	rjmp	.-28     	; 0x4e2c <SetWeekday+0x3c>

00004e48 <SetSec>:
}
// ~~~~~~~~~
void
SetSec(void)
{
	WriteRTC(0, Tm_Sec);
    4e48:	80 e0       	ldi	r24, 0x00	; 0
    4e4a:	60 91 f7 06 	lds	r22, 0x06F7
    4e4e:	0e 94 a8 26 	call	0x4d50	; 0x4d50 <WriteRTC>
	TrueTime_Sec = Tm_Sec;
    4e52:	80 91 f7 06 	lds	r24, 0x06F7
    4e56:	80 93 14 09 	sts	0x0914, r24
}
    4e5a:	08 95       	ret

00004e5c <SetMin>:

// ~~~~~~~~~
void
SetMin(void)
{
	WriteRTC(1, Tm_Min);
    4e5c:	81 e0       	ldi	r24, 0x01	; 1
    4e5e:	60 91 51 06 	lds	r22, 0x0651
    4e62:	0e 94 a8 26 	call	0x4d50	; 0x4d50 <WriteRTC>
	TrueTime_Min = Tm_Min;
    4e66:	80 91 51 06 	lds	r24, 0x0651
    4e6a:	80 93 16 09 	sts	0x0916, r24
}
    4e6e:	08 95       	ret

00004e70 <SetHour>:

// ~~~~~~~~~~
void
SetHour(void)
{
	WriteRTC(2,  Tm_Hour);
    4e70:	82 e0       	ldi	r24, 0x02	; 2
    4e72:	60 91 c1 05 	lds	r22, 0x05C1
    4e76:	0e 94 a8 26 	call	0x4d50	; 0x4d50 <WriteRTC>
	TrueTime_Hour = Tm_Hour;
    4e7a:	80 91 c1 05 	lds	r24, 0x05C1
    4e7e:	80 93 d8 05 	sts	0x05D8, r24
}
    4e82:	08 95       	ret

00004e84 <SetMDay>:
// ~~~~~~~~~~
void
SetMDay(void)
{
	WriteRTC(4,  Tm_MDay);
    4e84:	84 e0       	ldi	r24, 0x04	; 4
    4e86:	60 91 5f 0b 	lds	r22, 0x0B5F
    4e8a:	0e 94 a8 26 	call	0x4d50	; 0x4d50 <WriteRTC>
	TrueTime_MDay = Tm_MDay;
    4e8e:	80 91 5f 0b 	lds	r24, 0x0B5F
    4e92:	80 93 56 06 	sts	0x0656, r24
}
    4e96:	08 95       	ret

00004e98 <SetMon>:
// ~~~~~~~~~
void
SetMon(void)
{
	WriteRTC(5, Tm_Mon);
    4e98:	85 e0       	ldi	r24, 0x05	; 5
    4e9a:	60 91 cc 07 	lds	r22, 0x07CC
    4e9e:	0e 94 a8 26 	call	0x4d50	; 0x4d50 <WriteRTC>
	TrueTime_Mon = Tm_Mon;
    4ea2:	80 91 cc 07 	lds	r24, 0x07CC
    4ea6:	80 93 15 09 	sts	0x0915, r24
}
    4eaa:	08 95       	ret

00004eac <SetYear>:
// ~~~~~~~~~~~~~
void
SetYear(void)
{
	WriteRTC(6, Tm_Year);
    4eac:	86 e0       	ldi	r24, 0x06	; 6
    4eae:	60 91 de 05 	lds	r22, 0x05DE
    4eb2:	0e 94 a8 26 	call	0x4d50	; 0x4d50 <WriteRTC>
	TrueTime_Year = Tm_Year;
    4eb6:	80 91 de 05 	lds	r24, 0x05DE
    4eba:	80 93 c1 07 	sts	0x07C1, r24
}
    4ebe:	08 95       	ret

00004ec0 <SetDateTime>:
// ~~~~~~~~~~~~~
void
SetDateTime(uint8_t Year, uint8_t Month, uint8_t Day, uint8_t WDay, uint8_t Hour, uint8_t Min, uint8_t Sec){
    4ec0:	5f 92       	push	r5
    4ec2:	6f 92       	push	r6
    4ec4:	7f 92       	push	r7
    4ec6:	8f 92       	push	r8
    4ec8:	9f 92       	push	r9
    4eca:	af 92       	push	r10
    4ecc:	bf 92       	push	r11
    4ece:	cf 92       	push	r12
    4ed0:	df 92       	push	r13
    4ed2:	ef 92       	push	r14
    4ed4:	ff 92       	push	r15
    4ed6:	0f 93       	push	r16
    4ed8:	1f 93       	push	r17
    4eda:	58 2e       	mov	r5, r24
    4edc:	66 2e       	mov	r6, r22
    4ede:	74 2e       	mov	r7, r20
    4ee0:	f2 2e       	mov	r15, r18
    4ee2:	8c 2d       	mov	r24, r12
	PowerOffTWI();
    4ee4:	7c eb       	ldi	r23, 0xBC	; 188
    4ee6:	87 2e       	mov	r8, r23
    4ee8:	91 2c       	mov	r9, r1
    4eea:	f4 01       	movw	r30, r8
    4eec:	10 82       	st	Z, r1
    4eee:	e0 e9       	ldi	r30, 0x90	; 144
    4ef0:	f1 e0       	ldi	r31, 0x01	; 1
    4ef2:	31 97       	sbiw	r30, 0x01	; 1
    4ef4:	f1 f7       	brne	.-4      	; 0x4ef2 <SetDateTime+0x32>
	_delay_us(100);
	//_delay_us(150);_delay_us(150);
	StartTWI();
    4ef6:	94 ea       	ldi	r25, 0xA4	; 164
    4ef8:	f4 01       	movw	r30, r8
    4efa:	90 83       	st	Z, r25
    4efc:	68 e5       	ldi	r22, 0x58	; 88
    4efe:	c6 2e       	mov	r12, r22
    4f00:	62 e0       	ldi	r22, 0x02	; 2
    4f02:	d6 2e       	mov	r13, r22
    4f04:	f6 01       	movw	r30, r12
    4f06:	31 97       	sbiw	r30, 0x01	; 1
    4f08:	f1 f7       	brne	.-4      	; 0x4f06 <SetDateTime+0x46>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = SLA_W(PCF_SLA);
    4f0a:	f6 01       	movw	r30, r12
    4f0c:	31 97       	sbiw	r30, 0x01	; 1
    4f0e:	f1 f7       	brne	.-4      	; 0x4f0c <SetDateTime+0x4c>
    4f10:	5b eb       	ldi	r21, 0xBB	; 187
    4f12:	a5 2e       	mov	r10, r21
    4f14:	b1 2c       	mov	r11, r1
    4f16:	90 ed       	ldi	r25, 0xD0	; 208
    4f18:	f5 01       	movw	r30, r10
    4f1a:	90 83       	st	Z, r25
    4f1c:	90 81       	ld	r25, Z
    4f1e:	90 83       	st	Z, r25
	RunTWI();
    4f20:	14 e8       	ldi	r17, 0x84	; 132
    4f22:	f4 01       	movw	r30, r8
    4f24:	10 83       	st	Z, r17
    4f26:	f6 01       	movw	r30, r12
    4f28:	31 97       	sbiw	r30, 0x01	; 1
    4f2a:	f1 f7       	brne	.-4      	; 0x4f28 <SetDateTime+0x68>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = AddrSec;
    4f2c:	f6 01       	movw	r30, r12
    4f2e:	31 97       	sbiw	r30, 0x01	; 1
    4f30:	f1 f7       	brne	.-4      	; 0x4f2e <SetDateTime+0x6e>
    4f32:	f5 01       	movw	r30, r10
    4f34:	10 82       	st	Z, r1
	RunTWI();
    4f36:	f4 01       	movw	r30, r8
    4f38:	10 83       	st	Z, r17
    4f3a:	f6 01       	movw	r30, r12
    4f3c:	31 97       	sbiw	r30, 0x01	; 1
    4f3e:	f1 f7       	brne	.-4      	; 0x4f3c <SetDateTime+0x7c>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = CodBCD(Sec);
    4f40:	f6 01       	movw	r30, r12
    4f42:	31 97       	sbiw	r30, 0x01	; 1
    4f44:	f1 f7       	brne	.-4      	; 0x4f42 <SetDateTime+0x82>
    4f46:	0e 94 5c 24 	call	0x48b8	; 0x48b8 <CodBCD>
    4f4a:	f5 01       	movw	r30, r10
    4f4c:	80 83       	st	Z, r24
	RunTWI();
    4f4e:	f4 01       	movw	r30, r8
    4f50:	10 83       	st	Z, r17
    4f52:	c6 01       	movw	r24, r12
    4f54:	01 97       	sbiw	r24, 0x01	; 1
    4f56:	f1 f7       	brne	.-4      	; 0x4f54 <SetDateTime+0x94>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = CodBCD(Min);
    4f58:	c6 01       	movw	r24, r12
    4f5a:	01 97       	sbiw	r24, 0x01	; 1
    4f5c:	f1 f7       	brne	.-4      	; 0x4f5a <SetDateTime+0x9a>
    4f5e:	8e 2d       	mov	r24, r14
    4f60:	0e 94 5c 24 	call	0x48b8	; 0x48b8 <CodBCD>
    4f64:	f5 01       	movw	r30, r10
    4f66:	80 83       	st	Z, r24
	RunTWI();
    4f68:	f4 01       	movw	r30, r8
    4f6a:	10 83       	st	Z, r17
    4f6c:	c6 01       	movw	r24, r12
    4f6e:	01 97       	sbiw	r24, 0x01	; 1
    4f70:	f1 f7       	brne	.-4      	; 0x4f6e <SetDateTime+0xae>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = CodBCD(Hour);
    4f72:	c6 01       	movw	r24, r12
    4f74:	01 97       	sbiw	r24, 0x01	; 1
    4f76:	f1 f7       	brne	.-4      	; 0x4f74 <SetDateTime+0xb4>
    4f78:	80 2f       	mov	r24, r16
    4f7a:	0e 94 5c 24 	call	0x48b8	; 0x48b8 <CodBCD>
    4f7e:	f5 01       	movw	r30, r10
    4f80:	80 83       	st	Z, r24
	RunTWI();
    4f82:	f4 01       	movw	r30, r8
    4f84:	10 83       	st	Z, r17
    4f86:	c6 01       	movw	r24, r12
    4f88:	01 97       	sbiw	r24, 0x01	; 1
    4f8a:	f1 f7       	brne	.-4      	; 0x4f88 <SetDateTime+0xc8>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = WDay;
    4f8c:	c6 01       	movw	r24, r12
    4f8e:	01 97       	sbiw	r24, 0x01	; 1
    4f90:	f1 f7       	brne	.-4      	; 0x4f8e <SetDateTime+0xce>
    4f92:	f5 01       	movw	r30, r10
    4f94:	f0 82       	st	Z, r15
	RunTWI();
    4f96:	f4 01       	movw	r30, r8
    4f98:	10 83       	st	Z, r17
    4f9a:	c6 01       	movw	r24, r12
    4f9c:	01 97       	sbiw	r24, 0x01	; 1
    4f9e:	f1 f7       	brne	.-4      	; 0x4f9c <SetDateTime+0xdc>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = CodBCD(Day);
    4fa0:	c6 01       	movw	r24, r12
    4fa2:	01 97       	sbiw	r24, 0x01	; 1
    4fa4:	f1 f7       	brne	.-4      	; 0x4fa2 <SetDateTime+0xe2>
    4fa6:	87 2d       	mov	r24, r7
    4fa8:	0e 94 5c 24 	call	0x48b8	; 0x48b8 <CodBCD>
    4fac:	f5 01       	movw	r30, r10
    4fae:	80 83       	st	Z, r24
	RunTWI();
    4fb0:	f4 01       	movw	r30, r8
    4fb2:	10 83       	st	Z, r17
    4fb4:	c6 01       	movw	r24, r12
    4fb6:	01 97       	sbiw	r24, 0x01	; 1
    4fb8:	f1 f7       	brne	.-4      	; 0x4fb6 <SetDateTime+0xf6>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = CodBCD(Month);
    4fba:	c6 01       	movw	r24, r12
    4fbc:	01 97       	sbiw	r24, 0x01	; 1
    4fbe:	f1 f7       	brne	.-4      	; 0x4fbc <SetDateTime+0xfc>
    4fc0:	86 2d       	mov	r24, r6
    4fc2:	0e 94 5c 24 	call	0x48b8	; 0x48b8 <CodBCD>
    4fc6:	f5 01       	movw	r30, r10
    4fc8:	80 83       	st	Z, r24
	RunTWI();
    4fca:	f4 01       	movw	r30, r8
    4fcc:	10 83       	st	Z, r17
    4fce:	c6 01       	movw	r24, r12
    4fd0:	01 97       	sbiw	r24, 0x01	; 1
    4fd2:	f1 f7       	brne	.-4      	; 0x4fd0 <SetDateTime+0x110>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = CodBCD(Year);
    4fd4:	c6 01       	movw	r24, r12
    4fd6:	01 97       	sbiw	r24, 0x01	; 1
    4fd8:	f1 f7       	brne	.-4      	; 0x4fd6 <SetDateTime+0x116>
    4fda:	85 2d       	mov	r24, r5
    4fdc:	0e 94 5c 24 	call	0x48b8	; 0x48b8 <CodBCD>
    4fe0:	f5 01       	movw	r30, r10
    4fe2:	80 83       	st	Z, r24
	RunTWI();
    4fe4:	f4 01       	movw	r30, r8
    4fe6:	10 83       	st	Z, r17
    4fe8:	c6 01       	movw	r24, r12
    4fea:	01 97       	sbiw	r24, 0x01	; 1
    4fec:	f1 f7       	brne	.-4      	; 0x4fea <SetDateTime+0x12a>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	StopTWI();
    4fee:	c6 01       	movw	r24, r12
    4ff0:	01 97       	sbiw	r24, 0x01	; 1
    4ff2:	f1 f7       	brne	.-4      	; 0x4ff0 <SetDateTime+0x130>
    4ff4:	84 e9       	ldi	r24, 0x94	; 148
    4ff6:	80 83       	st	Z, r24
	TWI_Phase = PCF_START;
    4ff8:	10 92 c3 07 	sts	0x07C3, r1
}
    4ffc:	1f 91       	pop	r17
    4ffe:	0f 91       	pop	r16
    5000:	ff 90       	pop	r15
    5002:	ef 90       	pop	r14
    5004:	df 90       	pop	r13
    5006:	cf 90       	pop	r12
    5008:	bf 90       	pop	r11
    500a:	af 90       	pop	r10
    500c:	9f 90       	pop	r9
    500e:	8f 90       	pop	r8
    5010:	7f 90       	pop	r7
    5012:	6f 90       	pop	r6
    5014:	5f 90       	pop	r5
    5016:	08 95       	ret

00005018 <RTC_Ready>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t RTC_Ready(void){
    5018:	90 e0       	ldi	r25, 0x00	; 0
    501a:	80 91 c3 07 	lds	r24, 0x07C3
    501e:	88 23       	and	r24, r24
    5020:	09 f4       	brne	.+2      	; 0x5024 <RTC_Ready+0xc>
    5022:	91 e0       	ldi	r25, 0x01	; 1
	if(TWI_Phase == PCF_START) return 1;
	else return 0;
}
    5024:	89 2f       	mov	r24, r25
    5026:	08 95       	ret

00005028 <RTC_GetTrueTime>:
void RTC_GetTrueTime(void){
	TrueTime_Sec = Tm_Sec;
    5028:	80 91 f7 06 	lds	r24, 0x06F7
    502c:	80 93 14 09 	sts	0x0914, r24
	TrueTime_Min = Tm_Min;
    5030:	80 91 51 06 	lds	r24, 0x0651
    5034:	80 93 16 09 	sts	0x0916, r24
	TrueTime_Hour = Tm_Hour;
    5038:	80 91 c1 05 	lds	r24, 0x05C1
    503c:	80 93 d8 05 	sts	0x05D8, r24
	TrueTime_MDay = Tm_MDay;
    5040:	40 91 5f 0b 	lds	r20, 0x0B5F
    5044:	40 93 56 06 	sts	0x0656, r20
	TrueTime_Mon = Tm_Mon;
    5048:	60 91 cc 07 	lds	r22, 0x07CC
    504c:	60 93 15 09 	sts	0x0915, r22
	TrueTime_Year = Tm_Year;
    5050:	80 91 de 05 	lds	r24, 0x05DE
    5054:	80 93 c1 07 	sts	0x07C1, r24
	TrueTime_WDay = SetWeekday(TrueTime_Year, TrueTime_Mon, TrueTime_MDay);
    5058:	0e 94 f8 26 	call	0x4df0	; 0x4df0 <SetWeekday>
    505c:	80 93 5e 0b 	sts	0x0B5E, r24
}
    5060:	08 95       	ret

00005062 <RTC_SetTrueTime>:
void RTC_SetTrueTime(uint8_t Year, uint8_t Month, uint8_t Day, uint8_t WDay, uint8_t Hour, uint8_t Min, uint8_t Sec){
    5062:	8f 92       	push	r8
    5064:	9f 92       	push	r9
    5066:	af 92       	push	r10
    5068:	bf 92       	push	r11
    506a:	cf 92       	push	r12
    506c:	df 92       	push	r13
    506e:	ef 92       	push	r14
    5070:	ff 92       	push	r15
    5072:	0f 93       	push	r16
    5074:	1f 93       	push	r17
    5076:	88 2e       	mov	r8, r24
    5078:	a6 2e       	mov	r10, r22
    507a:	b4 2e       	mov	r11, r20
    507c:	92 2e       	mov	r9, r18
    507e:	d0 2e       	mov	r13, r16
    5080:	fe 2c       	mov	r15, r14
    5082:	1c 2d       	mov	r17, r12
	SetDateTime(Year, Month, Day, WDay, Hour, Min, Sec);
    5084:	0e 94 60 27 	call	0x4ec0	; 0x4ec0 <SetDateTime>
	TrueTime_Sec = Sec;
    5088:	10 93 14 09 	sts	0x0914, r17
	TrueTime_Min = Min;
    508c:	f0 92 16 09 	sts	0x0916, r15
	TrueTime_Hour = Hour;
    5090:	d0 92 d8 05 	sts	0x05D8, r13
	TrueTime_MDay = Day;
    5094:	b0 92 56 06 	sts	0x0656, r11
	TrueTime_Mon = Month;
    5098:	a0 92 15 09 	sts	0x0915, r10
	TrueTime_Year = Year;
    509c:	80 92 c1 07 	sts	0x07C1, r8
	TrueTime_WDay = WDay;
    50a0:	90 92 5e 0b 	sts	0x0B5E, r9
}
    50a4:	1f 91       	pop	r17
    50a6:	0f 91       	pop	r16
    50a8:	ff 90       	pop	r15
    50aa:	ef 90       	pop	r14
    50ac:	df 90       	pop	r13
    50ae:	cf 90       	pop	r12
    50b0:	bf 90       	pop	r11
    50b2:	af 90       	pop	r10
    50b4:	9f 90       	pop	r9
    50b6:	8f 90       	pop	r8
    50b8:	08 95       	ret

000050ba <RTC_Check>:

//  3 

uint8_t RTC_Check(void){

	if( (Tm_Year == TrueTime_Year)  && (Tm_Mon == TrueTime_Mon) && (Tm_MDay == TrueTime_MDay) &&
    50ba:	50 91 de 05 	lds	r21, 0x05DE
    50be:	40 91 c1 07 	lds	r20, 0x07C1
    50c2:	54 17       	cp	r21, r20
    50c4:	59 f1       	breq	.+86     	; 0x511c <RTC_Check+0x62>
    50c6:	90 91 14 09 	lds	r25, 0x0914
			(Tm_Hour == TrueTime_Hour) && (Tm_Min == TrueTime_Min) && (Tm_Sec == TrueTime_Sec) ) return 1;

	if(TrueTime_Sec>55){
    50ca:	98 33       	cpi	r25, 0x38	; 56
    50cc:	58 f0       	brcs	.+22     	; 0x50e4 <RTC_Check+0x2a>
		if(TrueTime_Min == 59){
    50ce:	80 91 16 09 	lds	r24, 0x0916
    50d2:	8b 33       	cpi	r24, 0x3B	; 59
    50d4:	09 f4       	brne	.+2      	; 0x50d8 <RTC_Check+0x1e>
    50d6:	5a c0       	rjmp	.+180    	; 0x518c <RTC_Check+0xd2>
			else{
				if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ) return 1;
			}
		}
		else{
			if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ||
    50d8:	54 17       	cp	r21, r20
    50da:	09 f4       	brne	.+2      	; 0x50de <RTC_Check+0x24>
    50dc:	40 c0       	rjmp	.+128    	; 0x515e <RTC_Check+0xa4>
				(Tm_Hour != TrueTime_Hour) ) return 1;		
		}
	}
	else{
		if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ||
    50de:	21 e0       	ldi	r18, 0x01	; 1
			(Tm_Hour != TrueTime_Hour) || (Tm_Min != TrueTime_Min) ) return 1;
	}
	
	return 0;
}
    50e0:	82 2f       	mov	r24, r18
    50e2:	08 95       	ret
			if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ||
				(Tm_Hour != TrueTime_Hour) ) return 1;		
		}
	}
	else{
		if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ||
    50e4:	54 17       	cp	r21, r20
    50e6:	d9 f7       	brne	.-10     	; 0x50de <RTC_Check+0x24>
    50e8:	90 91 cc 07 	lds	r25, 0x07CC
    50ec:	80 91 15 09 	lds	r24, 0x0915
    50f0:	98 17       	cp	r25, r24
    50f2:	a9 f7       	brne	.-22     	; 0x50de <RTC_Check+0x24>
    50f4:	90 91 5f 0b 	lds	r25, 0x0B5F
    50f8:	80 91 56 06 	lds	r24, 0x0656
    50fc:	98 17       	cp	r25, r24
    50fe:	79 f7       	brne	.-34     	; 0x50de <RTC_Check+0x24>
    5100:	90 91 c1 05 	lds	r25, 0x05C1
    5104:	80 91 d8 05 	lds	r24, 0x05D8
    5108:	98 17       	cp	r25, r24
    510a:	49 f7       	brne	.-46     	; 0x50de <RTC_Check+0x24>
    510c:	20 e0       	ldi	r18, 0x00	; 0
    510e:	90 91 51 06 	lds	r25, 0x0651
    5112:	80 91 16 09 	lds	r24, 0x0916
    5116:	98 17       	cp	r25, r24
    5118:	11 f7       	brne	.-60     	; 0x50de <RTC_Check+0x24>
    511a:	e2 cf       	rjmp	.-60     	; 0x50e0 <RTC_Check+0x26>

//  3 

uint8_t RTC_Check(void){

	if( (Tm_Year == TrueTime_Year)  && (Tm_Mon == TrueTime_Mon) && (Tm_MDay == TrueTime_MDay) &&
    511c:	90 91 cc 07 	lds	r25, 0x07CC
    5120:	80 91 15 09 	lds	r24, 0x0915
    5124:	98 17       	cp	r25, r24
    5126:	79 f6       	brne	.-98     	; 0x50c6 <RTC_Check+0xc>
    5128:	90 91 5f 0b 	lds	r25, 0x0B5F
    512c:	80 91 56 06 	lds	r24, 0x0656
    5130:	98 17       	cp	r25, r24
    5132:	49 f6       	brne	.-110    	; 0x50c6 <RTC_Check+0xc>
    5134:	90 91 c1 05 	lds	r25, 0x05C1
    5138:	80 91 d8 05 	lds	r24, 0x05D8
    513c:	98 17       	cp	r25, r24
    513e:	19 f6       	brne	.-122    	; 0x50c6 <RTC_Check+0xc>
    5140:	90 91 51 06 	lds	r25, 0x0651
    5144:	80 91 16 09 	lds	r24, 0x0916
    5148:	98 17       	cp	r25, r24
    514a:	09 f0       	breq	.+2      	; 0x514e <RTC_Check+0x94>
    514c:	bc cf       	rjmp	.-136    	; 0x50c6 <RTC_Check+0xc>
    514e:	80 91 f7 06 	lds	r24, 0x06F7
    5152:	90 91 14 09 	lds	r25, 0x0914
    5156:	89 17       	cp	r24, r25
    5158:	09 f0       	breq	.+2      	; 0x515c <RTC_Check+0xa2>
    515a:	b7 cf       	rjmp	.-146    	; 0x50ca <RTC_Check+0x10>
    515c:	c0 cf       	rjmp	.-128    	; 0x50de <RTC_Check+0x24>
			else{
				if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ) return 1;
			}
		}
		else{
			if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ||
    515e:	90 91 cc 07 	lds	r25, 0x07CC
    5162:	80 91 15 09 	lds	r24, 0x0915
    5166:	98 17       	cp	r25, r24
    5168:	09 f0       	breq	.+2      	; 0x516c <RTC_Check+0xb2>
    516a:	b9 cf       	rjmp	.-142    	; 0x50de <RTC_Check+0x24>
    516c:	90 91 5f 0b 	lds	r25, 0x0B5F
    5170:	80 91 56 06 	lds	r24, 0x0656
    5174:	98 17       	cp	r25, r24
    5176:	09 f0       	breq	.+2      	; 0x517a <RTC_Check+0xc0>
    5178:	b2 cf       	rjmp	.-156    	; 0x50de <RTC_Check+0x24>
    517a:	20 e0       	ldi	r18, 0x00	; 0
    517c:	90 91 c1 05 	lds	r25, 0x05C1
    5180:	80 91 d8 05 	lds	r24, 0x05D8
    5184:	98 17       	cp	r25, r24
    5186:	09 f0       	breq	.+2      	; 0x518a <RTC_Check+0xd0>
    5188:	aa cf       	rjmp	.-172    	; 0x50de <RTC_Check+0x24>
    518a:	aa cf       	rjmp	.-172    	; 0x50e0 <RTC_Check+0x26>
	if( (Tm_Year == TrueTime_Year)  && (Tm_Mon == TrueTime_Mon) && (Tm_MDay == TrueTime_MDay) &&
			(Tm_Hour == TrueTime_Hour) && (Tm_Min == TrueTime_Min) && (Tm_Sec == TrueTime_Sec) ) return 1;

	if(TrueTime_Sec>55){
		if(TrueTime_Min == 59){
			if(TrueTime_Hour == 23){
    518c:	80 91 d8 05 	lds	r24, 0x05D8
    5190:	87 31       	cpi	r24, 0x17	; 23
    5192:	99 f0       	breq	.+38     	; 0x51ba <RTC_Check+0x100>
				else{
					if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) ) return 1;
				}
			}
			else{
				if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ) return 1;
    5194:	54 17       	cp	r21, r20
    5196:	09 f0       	breq	.+2      	; 0x519a <RTC_Check+0xe0>
    5198:	a2 cf       	rjmp	.-188    	; 0x50de <RTC_Check+0x24>
    519a:	90 91 cc 07 	lds	r25, 0x07CC
    519e:	80 91 15 09 	lds	r24, 0x0915
    51a2:	98 17       	cp	r25, r24
    51a4:	09 f0       	breq	.+2      	; 0x51a8 <RTC_Check+0xee>
    51a6:	9b cf       	rjmp	.-202    	; 0x50de <RTC_Check+0x24>
    51a8:	20 e0       	ldi	r18, 0x00	; 0
    51aa:	90 91 5f 0b 	lds	r25, 0x0B5F
    51ae:	80 91 56 06 	lds	r24, 0x0656
    51b2:	98 17       	cp	r25, r24
    51b4:	09 f0       	breq	.+2      	; 0x51b8 <RTC_Check+0xfe>
    51b6:	93 cf       	rjmp	.-218    	; 0x50de <RTC_Check+0x24>
    51b8:	93 cf       	rjmp	.-218    	; 0x50e0 <RTC_Check+0x26>
			(Tm_Hour == TrueTime_Hour) && (Tm_Min == TrueTime_Min) && (Tm_Sec == TrueTime_Sec) ) return 1;

	if(TrueTime_Sec>55){
		if(TrueTime_Min == 59){
			if(TrueTime_Hour == 23){
				if(TrueTime_MDay >= 28){
    51ba:	80 91 56 06 	lds	r24, 0x0656
    51be:	8c 31       	cpi	r24, 0x1C	; 28
    51c0:	48 f0       	brcs	.+18     	; 0x51d4 <RTC_Check+0x11a>
					if(TrueTime_Mon == 12){
    51c2:	80 91 15 09 	lds	r24, 0x0915
    51c6:	8c 30       	cpi	r24, 0x0C	; 12
    51c8:	89 f0       	breq	.+34     	; 0x51ec <RTC_Check+0x132>
						if( ((TrueTime_Year+1) == Tm_Year) || (TrueTime_Year==Tm_Year) || ((TrueTime_Year==99) && (Tm_Year==0)) ) return 0;
    51ca:	20 e0       	ldi	r18, 0x00	; 0
    51cc:	54 17       	cp	r21, r20
    51ce:	09 f0       	breq	.+2      	; 0x51d2 <RTC_Check+0x118>
    51d0:	86 cf       	rjmp	.-244    	; 0x50de <RTC_Check+0x24>
    51d2:	86 cf       	rjmp	.-244    	; 0x50e0 <RTC_Check+0x26>
					else{
						if(Tm_Year!= TrueTime_Year) return 1;
					}
				}
				else{
					if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) ) return 1;
    51d4:	54 17       	cp	r21, r20
    51d6:	09 f0       	breq	.+2      	; 0x51da <RTC_Check+0x120>
    51d8:	82 cf       	rjmp	.-252    	; 0x50de <RTC_Check+0x24>
    51da:	20 e0       	ldi	r18, 0x00	; 0
    51dc:	90 91 cc 07 	lds	r25, 0x07CC
    51e0:	80 91 15 09 	lds	r24, 0x0915
    51e4:	98 17       	cp	r25, r24
    51e6:	09 f0       	breq	.+2      	; 0x51ea <RTC_Check+0x130>
    51e8:	7a cf       	rjmp	.-268    	; 0x50de <RTC_Check+0x24>
    51ea:	7a cf       	rjmp	.-268    	; 0x50e0 <RTC_Check+0x26>
	if(TrueTime_Sec>55){
		if(TrueTime_Min == 59){
			if(TrueTime_Hour == 23){
				if(TrueTime_MDay >= 28){
					if(TrueTime_Mon == 12){
						if( ((TrueTime_Year+1) == Tm_Year) || (TrueTime_Year==Tm_Year) || ((TrueTime_Year==99) && (Tm_Year==0)) ) return 0;
    51ec:	84 2f       	mov	r24, r20
    51ee:	90 e0       	ldi	r25, 0x00	; 0
    51f0:	01 96       	adiw	r24, 0x01	; 1
    51f2:	25 2f       	mov	r18, r21
    51f4:	30 e0       	ldi	r19, 0x00	; 0
    51f6:	82 17       	cp	r24, r18
    51f8:	93 07       	cpc	r25, r19
    51fa:	61 f0       	breq	.+24     	; 0x5214 <RTC_Check+0x15a>
    51fc:	54 17       	cp	r21, r20
    51fe:	51 f0       	breq	.+20     	; 0x5214 <RTC_Check+0x15a>
    5200:	43 36       	cpi	r20, 0x63	; 99
    5202:	09 f0       	breq	.+2      	; 0x5206 <RTC_Check+0x14c>
    5204:	6c cf       	rjmp	.-296    	; 0x50de <RTC_Check+0x24>
    5206:	20 e0       	ldi	r18, 0x00	; 0
    5208:	55 23       	and	r21, r21
    520a:	09 f4       	brne	.+2      	; 0x520e <RTC_Check+0x154>
    520c:	21 e0       	ldi	r18, 0x01	; 1
    520e:	81 e0       	ldi	r24, 0x01	; 1
    5210:	28 27       	eor	r18, r24
    5212:	66 cf       	rjmp	.-308    	; 0x50e0 <RTC_Check+0x26>
			if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ||
				(Tm_Hour != TrueTime_Hour) ) return 1;		
		}
	}
	else{
		if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ||
    5214:	20 e0       	ldi	r18, 0x00	; 0
    5216:	64 cf       	rjmp	.-312    	; 0x50e0 <RTC_Check+0x26>

00005218 <GSM_PWRCNTRL_Config>:
#endif

//  gsm_sim900r.h   PWRCNTRL
#ifdef vmd2_3
	void GSM_PWRCNTRL_Config(void){
		cli();
    5218:	f8 94       	cli
		DDRL|=(1<<PL5);
    521a:	ea e0       	ldi	r30, 0x0A	; 10
    521c:	f1 e0       	ldi	r31, 0x01	; 1
    521e:	80 81       	ld	r24, Z
    5220:	80 62       	ori	r24, 0x20	; 32
    5222:	80 83       	st	Z, r24
		sei();
    5224:	78 94       	sei
	}
    5226:	08 95       	ret

00005228 <GSM_PWRCNTRL_OFF>:
	void GSM_PWRCNTRL_OFF(void){
		cli();
    5228:	f8 94       	cli
		PORTL|=(1<<PL5);
    522a:	eb e0       	ldi	r30, 0x0B	; 11
    522c:	f1 e0       	ldi	r31, 0x01	; 1
    522e:	80 81       	ld	r24, Z
    5230:	80 62       	ori	r24, 0x20	; 32
    5232:	80 83       	st	Z, r24
		sei();
    5234:	78 94       	sei
	}
    5236:	08 95       	ret

00005238 <GSM_PWRCNTRL_ON>:
	void GSM_PWRCNTRL_ON(void){
		cli();
    5238:	f8 94       	cli
		PORTL &= ~(1<<PL5);
    523a:	eb e0       	ldi	r30, 0x0B	; 11
    523c:	f1 e0       	ldi	r31, 0x01	; 1
    523e:	80 81       	ld	r24, Z
    5240:	8f 7d       	andi	r24, 0xDF	; 223
    5242:	80 83       	st	Z, r24
		sei();
    5244:	78 94       	sei
	}
    5246:	08 95       	ret

00005248 <GSM_CTS_RTS_Config>:

	void GSM_CTS_RTS_Config(void){
		cli();
    5248:	f8 94       	cli
		//TS
		DDRB &=~(1<<PB6);
    524a:	26 98       	cbi	0x04, 6	; 4
		PORTB |=(1<<PB6);	//pull'up
    524c:	2e 9a       	sbi	0x05, 6	; 5
		//RTS
		DDRG |= (1<<PG5);
    524e:	9d 9a       	sbi	0x13, 5	; 19
		PORTG &= ~(1<<PG5);
    5250:	a5 98       	cbi	0x14, 5	; 20
		sei();
    5252:	78 94       	sei
	}
    5254:	08 95       	ret

00005256 <GSM_CTS_State>:
	uint8_t GSM_CTS_State(void){
		return PINB & (1<<PB6);
    5256:	83 b1       	in	r24, 0x03	; 3
	}
    5258:	80 74       	andi	r24, 0x40	; 64
    525a:	08 95       	ret

0000525c <GSM_RTS_OFF>:
	void GSM_RTS_OFF(void){
		cli();
    525c:	f8 94       	cli
		PORTG &= ~(1<<PG5);
    525e:	a5 98       	cbi	0x14, 5	; 20
		sei();
    5260:	78 94       	sei
	}
    5262:	08 95       	ret

00005264 <GSM_RTS_ON>:
	void GSM_RTS_ON(void){
		cli();
    5264:	f8 94       	cli
		PORTG |= (1<<PG5);
    5266:	a5 9a       	sbi	0x14, 5	; 20
		sei();
    5268:	78 94       	sei
	}
    526a:	08 95       	ret

0000526c <LED_Init>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    526c:	8f b7       	in	r24, 0x3f	; 63
    526e:	80 78       	andi	r24, 0x80	; 128
    5270:	80 93 ee 02 	sts	0x02EE, r24
	cli();
    5274:	f8 94       	cli
//~~~~~~~~~~~~
void
LED_Init(void)
{
	IntOff();
	DDR_LED |=PinLED;
    5276:	83 9a       	sbi	0x10, 3	; 16
	LED_Rst();
    5278:	8b 98       	cbi	0x11, 3	; 17

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    527a:	88 23       	and	r24, r24
    527c:	09 f0       	breq	.+2      	; 0x5280 <LED_Init+0x14>
		sei();
    527e:	78 94       	sei
    5280:	08 95       	ret

00005282 <LED_On>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    5282:	8f b7       	in	r24, 0x3f	; 63
    5284:	80 78       	andi	r24, 0x80	; 128
    5286:	80 93 ee 02 	sts	0x02EE, r24
	cli();
    528a:	f8 94       	cli
// ~~~~~~~~~
void
LED_On(void)
{
	IntOff();
	LED_Set();
    528c:	8b 9a       	sbi	0x11, 3	; 17

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    528e:	88 23       	and	r24, r24
    5290:	09 f0       	breq	.+2      	; 0x5294 <LED_On+0x12>
		sei();
    5292:	78 94       	sei
    5294:	08 95       	ret

00005296 <LED_Off>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    5296:	8f b7       	in	r24, 0x3f	; 63
    5298:	80 78       	andi	r24, 0x80	; 128
    529a:	80 93 ee 02 	sts	0x02EE, r24
	cli();
    529e:	f8 94       	cli
// ~~~~~~~~~~
void
LED_Off(void)
{
	IntOff();
	LED_Rst();
    52a0:	8b 98       	cbi	0x11, 3	; 17

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    52a2:	88 23       	and	r24, r24
    52a4:	09 f0       	breq	.+2      	; 0x52a8 <LED_Off+0x12>
		sei();
    52a6:	78 94       	sei
    52a8:	08 95       	ret

000052aa <LED_Toggle>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    52aa:	8f b7       	in	r24, 0x3f	; 63
    52ac:	80 78       	andi	r24, 0x80	; 128
    52ae:	80 93 ee 02 	sts	0x02EE, r24
	cli();
    52b2:	f8 94       	cli
// ~~~~~~~~~~~~~
uint8_t
LED_Toggle(void)
{
	IntOff();
	LED_Inv();
    52b4:	91 b3       	in	r25, 0x11	; 17
    52b6:	28 e0       	ldi	r18, 0x08	; 8
    52b8:	92 27       	eor	r25, r18
    52ba:	91 bb       	out	0x11, r25	; 17

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    52bc:	88 23       	and	r24, r24
    52be:	09 f0       	breq	.+2      	; 0x52c2 <LED_Toggle+0x18>
		sei();
    52c0:	78 94       	sei
	IntOn();
	return PortLED &PinLED;
    52c2:	81 b3       	in	r24, 0x11	; 17
}
    52c4:	88 70       	andi	r24, 0x08	; 8
    52c6:	08 95       	ret

000052c8 <Send>:
#ifdef Port_LCD_DB0	//8-bit width data bus
	// ~~~~~~~~~~~~~~
	static void
	Send(uint8_t Val)
	{
		if (Val &(1<<0)) Port_LCD_DB0 |=DB0; else Port_LCD_DB0 &=~DB0;
    52c8:	98 2f       	mov	r25, r24
    52ca:	80 ff       	sbrs	r24, 0
    52cc:	23 c0       	rjmp	.+70     	; 0x5314 <Send+0x4c>
    52ce:	41 9a       	sbi	0x08, 1	; 8
		if (Val &(1<<1)) Port_LCD_DB1 |=DB1; else Port_LCD_DB1 &=~DB1;
    52d0:	91 ff       	sbrs	r25, 1
    52d2:	23 c0       	rjmp	.+70     	; 0x531a <Send+0x52>
    52d4:	40 9a       	sbi	0x08, 0	; 8
		if (Val &(1<<2)) Port_LCD_DB2 |=DB2; else Port_LCD_DB2 &=~DB2;
    52d6:	92 ff       	sbrs	r25, 2
    52d8:	23 c0       	rjmp	.+70     	; 0x5320 <Send+0x58>
    52da:	a1 9a       	sbi	0x14, 1	; 20
		if (Val &(1<<3)) Port_LCD_DB3 |=DB3; else Port_LCD_DB3 &=~DB3;
    52dc:	93 ff       	sbrs	r25, 3
    52de:	23 c0       	rjmp	.+70     	; 0x5326 <Send+0x5e>
    52e0:	a0 9a       	sbi	0x14, 0	; 20
		if (Val &(1<<4)) Port_LCD_DB4 |=DB4; else Port_LCD_DB4 &=~DB4;
    52e2:	94 ff       	sbrs	r25, 4
    52e4:	23 c0       	rjmp	.+70     	; 0x532c <Send+0x64>
    52e6:	5f 9a       	sbi	0x0b, 7	; 11
		if (Val &(1<<5)) Port_LCD_DB5 |=DB5; else Port_LCD_DB5 &=~DB5;
    52e8:	95 ff       	sbrs	r25, 5
    52ea:	23 c0       	rjmp	.+70     	; 0x5332 <Send+0x6a>
    52ec:	5e 9a       	sbi	0x0b, 6	; 11
		if (Val &(1<<6)) Port_LCD_DB6 |=DB6; else Port_LCD_DB6 &=~DB6;
    52ee:	96 ff       	sbrs	r25, 6
    52f0:	23 c0       	rjmp	.+70     	; 0x5338 <Send+0x70>
    52f2:	5d 9a       	sbi	0x0b, 5	; 11
		if (Val &(1<<7)) Port_LCD_DB7 |=DB7; else Port_LCD_DB7 &=~DB7;
    52f4:	87 fd       	sbrc	r24, 7
    52f6:	23 c0       	rjmp	.+70     	; 0x533e <Send+0x76>
    52f8:	80 91 0b 01 	lds	r24, 0x010B
    52fc:	8f 77       	andi	r24, 0x7F	; 127
    52fe:	80 93 0b 01 	sts	0x010B, r24

		Port_LCD_E |=LCD_E;
    5302:	42 9a       	sbi	0x08, 2	; 8
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    5304:	85 e0       	ldi	r24, 0x05	; 5
    5306:	98 2f       	mov	r25, r24
    5308:	9a 95       	dec	r25
    530a:	f1 f7       	brne	.-4      	; 0x5308 <Send+0x40>
		_delay_us(1);		// 450 ns needs
		Port_LCD_E &=~LCD_E;
    530c:	42 98       	cbi	0x08, 2	; 8
    530e:	8a 95       	dec	r24
    5310:	f1 f7       	brne	.-4      	; 0x530e <Send+0x46>
		_delay_us(1);		// 10 ns needs
	}
    5312:	08 95       	ret
#ifdef Port_LCD_DB0	//8-bit width data bus
	// ~~~~~~~~~~~~~~
	static void
	Send(uint8_t Val)
	{
		if (Val &(1<<0)) Port_LCD_DB0 |=DB0; else Port_LCD_DB0 &=~DB0;
    5314:	41 98       	cbi	0x08, 1	; 8
		if (Val &(1<<1)) Port_LCD_DB1 |=DB1; else Port_LCD_DB1 &=~DB1;
    5316:	91 fd       	sbrc	r25, 1
    5318:	dd cf       	rjmp	.-70     	; 0x52d4 <Send+0xc>
    531a:	40 98       	cbi	0x08, 0	; 8
		if (Val &(1<<2)) Port_LCD_DB2 |=DB2; else Port_LCD_DB2 &=~DB2;
    531c:	92 fd       	sbrc	r25, 2
    531e:	dd cf       	rjmp	.-70     	; 0x52da <Send+0x12>
    5320:	a1 98       	cbi	0x14, 1	; 20
		if (Val &(1<<3)) Port_LCD_DB3 |=DB3; else Port_LCD_DB3 &=~DB3;
    5322:	93 fd       	sbrc	r25, 3
    5324:	dd cf       	rjmp	.-70     	; 0x52e0 <Send+0x18>
    5326:	a0 98       	cbi	0x14, 0	; 20
		if (Val &(1<<4)) Port_LCD_DB4 |=DB4; else Port_LCD_DB4 &=~DB4;
    5328:	94 fd       	sbrc	r25, 4
    532a:	dd cf       	rjmp	.-70     	; 0x52e6 <Send+0x1e>
    532c:	5f 98       	cbi	0x0b, 7	; 11
		if (Val &(1<<5)) Port_LCD_DB5 |=DB5; else Port_LCD_DB5 &=~DB5;
    532e:	95 fd       	sbrc	r25, 5
    5330:	dd cf       	rjmp	.-70     	; 0x52ec <Send+0x24>
    5332:	5e 98       	cbi	0x0b, 6	; 11
		if (Val &(1<<6)) Port_LCD_DB6 |=DB6; else Port_LCD_DB6 &=~DB6;
    5334:	96 fd       	sbrc	r25, 6
    5336:	dd cf       	rjmp	.-70     	; 0x52f2 <Send+0x2a>
    5338:	5d 98       	cbi	0x0b, 5	; 11
		if (Val &(1<<7)) Port_LCD_DB7 |=DB7; else Port_LCD_DB7 &=~DB7;
    533a:	87 ff       	sbrs	r24, 7
    533c:	dd cf       	rjmp	.-70     	; 0x52f8 <Send+0x30>
    533e:	80 91 0b 01 	lds	r24, 0x010B
    5342:	80 68       	ori	r24, 0x80	; 128
    5344:	80 93 0b 01 	sts	0x010B, r24
    5348:	dc cf       	rjmp	.-72     	; 0x5302 <Send+0x3a>

0000534a <Send_I>:
#endif
// ~~~~~~~~~~~~~~~~
static void
Send_I(uint8_t Val)
{
	Send(Val);
    534a:	0e 94 64 29 	call	0x52c8	; 0x52c8 <Send>
	Delay_us(LCD_Delay);
    534e:	82 e3       	ldi	r24, 0x32	; 50
    5350:	90 e0       	ldi	r25, 0x00	; 0
    5352:	0e 94 5a 21 	call	0x42b4	; 0x42b4 <Delay_us>
}
    5356:	08 95       	ret

00005358 <LCD_FuncSet0>:

// ~~~~~~~~~~~
static void
LCD_FuncSet0(void)
{
	Port_LCD_DB4  |=DB4;
    5358:	5f 9a       	sbi	0x0b, 7	; 11
	Port_LCD_DB5  |=DB5;
    535a:	5e 9a       	sbi	0x0b, 6	; 11
	Port_LCD_DB6 &=~DB6;
    535c:	5d 98       	cbi	0x0b, 5	; 11
	Port_LCD_DB7 &=~DB7;
    535e:	eb e0       	ldi	r30, 0x0B	; 11
    5360:	f1 e0       	ldi	r31, 0x01	; 1
    5362:	80 81       	ld	r24, Z
    5364:	8f 77       	andi	r24, 0x7F	; 127
    5366:	80 83       	st	Z, r24
}
    5368:	08 95       	ret

0000536a <LCD_Rdy>:
}

// ~~~~~~~~~~
uint8_t
LCD_Rdy(void)
{
    536a:	1f 93       	push	r17
	uint8_t Rdy = Timer8Stopp(TD_LCD);
    536c:	10 91 d7 04 	lds	r17, 0x04D7
    5370:	81 2f       	mov	r24, r17
    5372:	0e 94 61 1f 	call	0x3ec2	; 0x3ec2 <Timer8Stopp>
	Rdy = Rdy && !(TIMSK_LCD &(1<<OCIE1B));
    5376:	88 23       	and	r24, r24
    5378:	29 f0       	breq	.+10     	; 0x5384 <LCD_Rdy+0x1a>
    537a:	80 91 6f 00 	lds	r24, 0x006F
    537e:	82 ff       	sbrs	r24, 2
    5380:	03 c0       	rjmp	.+6      	; 0x5388 <LCD_Rdy+0x1e>
    5382:	80 e0       	ldi	r24, 0x00	; 0
	if (Rdy)
		StartTimer8(TD_LCD, 6);
	return Rdy;
}
    5384:	1f 91       	pop	r17
    5386:	08 95       	ret
LCD_Rdy(void)
{
	uint8_t Rdy = Timer8Stopp(TD_LCD);
	Rdy = Rdy && !(TIMSK_LCD &(1<<OCIE1B));
	if (Rdy)
		StartTimer8(TD_LCD, 6);
    5388:	81 2f       	mov	r24, r17
    538a:	66 e0       	ldi	r22, 0x06	; 6
    538c:	0e 94 0d 1e 	call	0x3c1a	; 0x3c1a <StartTimer8>
    5390:	81 e0       	ldi	r24, 0x01	; 1
	return Rdy;
}
    5392:	1f 91       	pop	r17
    5394:	08 95       	ret

00005396 <LCD_Out>:
LCD_Out(void)
{
	static uint8_t N;
	uint16_t LCD_delay = 100;	//50us

	if( (N>=20) && !LCD_Rst_Flg ){
    5396:	90 91 eb 02 	lds	r25, 0x02EB
    539a:	94 31       	cpi	r25, 0x14	; 20
    539c:	20 f0       	brcs	.+8      	; 0x53a6 <LCD_Out+0x10>
    539e:	80 91 d6 04 	lds	r24, 0x04D6
    53a2:	88 23       	and	r24, r24
    53a4:	19 f1       	breq	.+70     	; 0x53ec <LCD_Out+0x56>
		LCD_Rst0();
		LCD_Rst_Flg = 1;
		LCD_delay = 10000;	//5ms
	}
	else {
		N++;
    53a6:	9f 5f       	subi	r25, 0xFF	; 255
    53a8:	90 93 eb 02 	sts	0x02EB, r25
    53ac:	24 e6       	ldi	r18, 0x64	; 100
    53ae:	30 e0       	ldi	r19, 0x00	; 0
	}

	cli();
    53b0:	f8 94       	cli
	LCD_delay = TCNT1 + LCD_delay;
    53b2:	80 91 84 00 	lds	r24, 0x0084
    53b6:	90 91 85 00 	lds	r25, 0x0085
    53ba:	82 0f       	add	r24, r18
    53bc:	93 1f       	adc	r25, r19
	if(LCD_delay >= 20000) OCR1B = LCD_delay - 20000;
    53be:	2e e4       	ldi	r18, 0x4E	; 78
    53c0:	80 32       	cpi	r24, 0x20	; 32
    53c2:	92 07       	cpc	r25, r18
    53c4:	60 f4       	brcc	.+24     	; 0x53de <LCD_Out+0x48>
	else OCR1B = LCD_delay;
    53c6:	90 93 8b 00 	sts	0x008B, r25
    53ca:	80 93 8a 00 	sts	0x008A, r24
	TIFR_LCD |= (1<<OCF1B);
    53ce:	b2 9a       	sbi	0x16, 2	; 22
	TIMSK_LCD |= (1<<OCIE1B);
    53d0:	80 91 6f 00 	lds	r24, 0x006F
    53d4:	84 60       	ori	r24, 0x04	; 4
    53d6:	80 93 6f 00 	sts	0x006F, r24
	sei();
    53da:	78 94       	sei
}
    53dc:	08 95       	ret
		N++;
	}

	cli();
	LCD_delay = TCNT1 + LCD_delay;
	if(LCD_delay >= 20000) OCR1B = LCD_delay - 20000;
    53de:	80 52       	subi	r24, 0x20	; 32
    53e0:	9e 44       	sbci	r25, 0x4E	; 78
    53e2:	90 93 8b 00 	sts	0x008B, r25
    53e6:	80 93 8a 00 	sts	0x008A, r24
    53ea:	f1 cf       	rjmp	.-30     	; 0x53ce <LCD_Out+0x38>
{
	static uint8_t N;
	uint16_t LCD_delay = 100;	//50us

	if( (N>=20) && !LCD_Rst_Flg ){
		N = 0;
    53ec:	10 92 eb 02 	sts	0x02EB, r1
#endif
// ~~~~~~~~~~~
static void
LCD_Rst0(void)
{
	cli();
    53f0:	f8 94       	cli
	Port_LCD_RS &=~LCD_RS;
    53f2:	44 98       	cbi	0x08, 4	; 8
	LCD_FuncSet0();
    53f4:	0e 94 ac 29 	call	0x5358	; 0x5358 <LCD_FuncSet0>
	sei();
    53f8:	78 94       	sei
	uint16_t LCD_delay = 100;	//50us

	if( (N>=20) && !LCD_Rst_Flg ){
		N = 0;
		LCD_Rst0();
		LCD_Rst_Flg = 1;
    53fa:	81 e0       	ldi	r24, 0x01	; 1
    53fc:	80 93 d6 04 	sts	0x04D6, r24
    5400:	20 e1       	ldi	r18, 0x10	; 16
    5402:	37 e2       	ldi	r19, 0x27	; 39
    5404:	d5 cf       	rjmp	.-86     	; 0x53b0 <LCD_Out+0x1a>

00005406 <__vector_18>:
	sei();
}

// ~~~~~~~~~~~~~~~~~~~~~~
// 40 us needs
ISR(TIMER1_COMPB_vect){
    5406:	1f 92       	push	r1
    5408:	0f 92       	push	r0
    540a:	0f b6       	in	r0, 0x3f	; 63
    540c:	0f 92       	push	r0
    540e:	0b b6       	in	r0, 0x3b	; 59
    5410:	0f 92       	push	r0
    5412:	11 24       	eor	r1, r1
    5414:	ff 92       	push	r15
    5416:	0f 93       	push	r16
    5418:	1f 93       	push	r17
    541a:	2f 93       	push	r18
    541c:	3f 93       	push	r19
    541e:	4f 93       	push	r20
    5420:	5f 93       	push	r21
    5422:	6f 93       	push	r22
    5424:	7f 93       	push	r23
    5426:	8f 93       	push	r24
    5428:	9f 93       	push	r25
    542a:	af 93       	push	r26
    542c:	bf 93       	push	r27
    542e:	ef 93       	push	r30
    5430:	ff 93       	push	r31

	uint16_t LCD_delay = 100;	//50us

	if (LCD_Rst_Flg) {
    5432:	80 91 d6 04 	lds	r24, 0x04D6
    5436:	88 23       	and	r24, r24
    5438:	f1 f0       	breq	.+60     	; 0x5476 <__vector_18+0x70>
		switch(LCD_Rst_Flg){
    543a:	10 91 d6 04 	lds	r17, 0x04D6
    543e:	15 30       	cpi	r17, 0x05	; 5
    5440:	09 f4       	brne	.+2      	; 0x5444 <__vector_18+0x3e>
    5442:	b5 c0       	rjmp	.+362    	; 0x55ae <__vector_18+0x1a8>
    5444:	16 30       	cpi	r17, 0x06	; 6
    5446:	08 f4       	brcc	.+2      	; 0x544a <__vector_18+0x44>
    5448:	a1 c0       	rjmp	.+322    	; 0x558c <__vector_18+0x186>
    544a:	17 30       	cpi	r17, 0x07	; 7
    544c:	09 f4       	brne	.+2      	; 0x5450 <__vector_18+0x4a>
    544e:	15 c1       	rjmp	.+554    	; 0x567a <__vector_18+0x274>
    5450:	17 30       	cpi	r17, 0x07	; 7
    5452:	08 f0       	brcs	.+2      	; 0x5456 <__vector_18+0x50>
    5454:	dc c0       	rjmp	.+440    	; 0x560e <__vector_18+0x208>
				break;
			case 5:
				Send(0b00001100);	//; Display on, cursor off, blink off	
				break;
			case 6:
				Send(0b00000110);	//; cursor shift right, no display shift
    5456:	86 e0       	ldi	r24, 0x06	; 6
    5458:	0e 94 64 29 	call	0x52c8	; 0x52c8 <Send>
				#endif
				Port_LCD_RS |=LCD_RS;
			default:
				LCD_Rst_Flg = 255;
		}
		if(LCD_Rst_Flg==1) LCD_delay = 400;	//200us
    545c:	80 91 d6 04 	lds	r24, 0x04D6
    5460:	81 30       	cpi	r24, 0x01	; 1
    5462:	09 f4       	brne	.+2      	; 0x5466 <__vector_18+0x60>
    5464:	a1 c0       	rjmp	.+322    	; 0x55a8 <__vector_18+0x1a2>
    5466:	24 e6       	ldi	r18, 0x64	; 100
    5468:	30 e0       	ldi	r19, 0x00	; 0

		LCD_Rst_Flg++;
    546a:	80 91 d6 04 	lds	r24, 0x04D6
    546e:	8f 5f       	subi	r24, 0xFF	; 255
    5470:	80 93 d6 04 	sts	0x04D6, r24
    5474:	5f c0       	rjmp	.+190    	; 0x5534 <__vector_18+0x12e>
	else {
		static uint8_t X, Y;
		static prog_uint8_t LineAddr[] = {128, 192, 148, 212};
		unsigned char cursor_symb;
		
		if (X<LCDXSz) {
    5476:	10 91 e8 02 	lds	r17, 0x02E8
    547a:	14 31       	cpi	r17, 0x14	; 20
    547c:	08 f0       	brcs	.+2      	; 0x5480 <__vector_18+0x7a>
    547e:	45 c0       	rjmp	.+138    	; 0x550a <__vector_18+0x104>
			if((X>=CurrX)&&(X<(CurrX+StrSize))&&(Y==CurrLCD)){
    5480:	80 91 fa 06 	lds	r24, 0x06FA
    5484:	18 17       	cp	r17, r24
    5486:	08 f4       	brcc	.+2      	; 0x548a <__vector_18+0x84>
    5488:	96 c0       	rjmp	.+300    	; 0x55b6 <__vector_18+0x1b0>
    548a:	61 2f       	mov	r22, r17
    548c:	70 e0       	ldi	r23, 0x00	; 0
    548e:	20 91 ac 06 	lds	r18, 0x06AC
    5492:	90 e0       	ldi	r25, 0x00	; 0
    5494:	82 0f       	add	r24, r18
    5496:	91 1d       	adc	r25, r1
    5498:	68 17       	cp	r22, r24
    549a:	79 07       	cpc	r23, r25
    549c:	0c f4       	brge	.+2      	; 0x54a0 <__vector_18+0x9a>
    549e:	e4 c0       	rjmp	.+456    	; 0x5668 <__vector_18+0x262>
    54a0:	e0 91 e7 02 	lds	r30, 0x02E7
    54a4:	20 e0       	ldi	r18, 0x00	; 0
			else
			{
				cursor_symb=0;
			}

			Send(
    54a6:	4e 2f       	mov	r20, r30
    54a8:	50 e0       	ldi	r21, 0x00	; 0
    54aa:	90 91 18 09 	lds	r25, 0x0918
    54ae:	89 2f       	mov	r24, r25
    54b0:	88 50       	subi	r24, 0x08	; 8
    54b2:	83 30       	cpi	r24, 0x03	; 3
    54b4:	18 f0       	brcs	.+6      	; 0x54bc <__vector_18+0xb6>
    54b6:	9e 30       	cpi	r25, 0x0E	; 14
    54b8:	08 f4       	brcc	.+2      	; 0x54bc <__vector_18+0xb6>
    54ba:	91 c0       	rjmp	.+290    	; 0x55de <__vector_18+0x1d8>
    54bc:	22 23       	and	r18, r18
    54be:	09 f4       	brne	.+2      	; 0x54c2 <__vector_18+0xbc>
    54c0:	8e c0       	rjmp	.+284    	; 0x55de <__vector_18+0x1d8>
    54c2:	80 91 d6 02 	lds	r24, 0x02D6
    54c6:	8f 3f       	cpi	r24, 0xFF	; 255
    54c8:	09 f4       	brne	.+2      	; 0x54cc <__vector_18+0xc6>
    54ca:	89 c0       	rjmp	.+274    	; 0x55de <__vector_18+0x1d8>
    54cc:	e2 2f       	mov	r30, r18
    54ce:	f0 e0       	ldi	r31, 0x00	; 0
    54d0:	e1 53       	subi	r30, 0x31	; 49
    54d2:	fb 4c       	sbci	r31, 0xCB	; 203
    54d4:	24 91       	lpm	r18, Z+
    54d6:	fa 01       	movw	r30, r20
    54d8:	ee 0f       	add	r30, r30
    54da:	ff 1f       	adc	r31, r31
    54dc:	ee 0f       	add	r30, r30
    54de:	ff 1f       	adc	r31, r31
    54e0:	cf 01       	movw	r24, r30
    54e2:	88 0f       	add	r24, r24
    54e4:	99 1f       	adc	r25, r25
    54e6:	88 0f       	add	r24, r24
    54e8:	99 1f       	adc	r25, r25
    54ea:	e8 0f       	add	r30, r24
    54ec:	f9 1f       	adc	r31, r25
    54ee:	e6 0f       	add	r30, r22
    54f0:	f7 1f       	adc	r31, r23
    54f2:	ed 56       	subi	r30, 0x6D	; 109
    54f4:	f7 4f       	sbci	r31, 0xF7	; 247
    54f6:	20 83       	st	Z, r18
    54f8:	82 2f       	mov	r24, r18
    54fa:	0e 94 64 29 	call	0x52c8	; 0x52c8 <Send>
				#ifndef QslRD
					*((uint8_t*)RMON+Y*LCDXSz+X) =
				#endif
			#endif
				(((Blink>=8 && Blink<=10 )|| Blink>=14)&&cursor_symb&&(CurrField!=255))?prb(Win2LCD+(unsigned char)cursor_symb):(prb(Win2LCD+(unsigned char)LCD_Buf[Y][X])));
				X++;
    54fe:	1f 5f       	subi	r17, 0xFF	; 255
    5500:	10 93 e8 02 	sts	0x02E8, r17
    5504:	24 e6       	ldi	r18, 0x64	; 100
    5506:	30 e0       	ldi	r19, 0x00	; 0
    5508:	15 c0       	rjmp	.+42     	; 0x5534 <__vector_18+0x12e>
		}
		else {
			X = 0;
    550a:	10 92 e8 02 	sts	0x02E8, r1
			if (++Y==LCDYSz) {
    550e:	e0 91 e7 02 	lds	r30, 0x02E7
    5512:	ef 5f       	subi	r30, 0xFF	; 255
    5514:	e0 93 e7 02 	sts	0x02E7, r30
    5518:	e4 30       	cpi	r30, 0x04	; 4
    551a:	09 f4       	brne	.+2      	; 0x551e <__vector_18+0x118>
    551c:	51 c0       	rjmp	.+162    	; 0x55c0 <__vector_18+0x1ba>
				Y = 0;
				TIMSK_LCD &= ~(1<<OCIE1B);	//stop Output CompareB interrups
			}
			Port_LCD_RS &=~LCD_RS;
    551e:	44 98       	cbi	0x08, 4	; 8
    5520:	f0 e0       	ldi	r31, 0x00	; 0
    5522:	e1 53       	subi	r30, 0x31	; 49
    5524:	fa 4c       	sbci	r31, 0xCA	; 202
    5526:	e4 91       	lpm	r30, Z+
			Send(prb(LineAddr+Y));
    5528:	8e 2f       	mov	r24, r30
    552a:	0e 94 64 29 	call	0x52c8	; 0x52c8 <Send>
			Port_LCD_RS |=LCD_RS;
    552e:	44 9a       	sbi	0x08, 4	; 8
    5530:	24 e6       	ldi	r18, 0x64	; 100
    5532:	30 e0       	ldi	r19, 0x00	; 0
		}
	}
	LCD_delay = TCNT1 + LCD_delay;
    5534:	80 91 84 00 	lds	r24, 0x0084
    5538:	90 91 85 00 	lds	r25, 0x0085
    553c:	82 0f       	add	r24, r18
    553e:	93 1f       	adc	r25, r19
	if(LCD_delay >= 20000) OCR1B = LCD_delay - 20000;
    5540:	2e e4       	ldi	r18, 0x4E	; 78
    5542:	80 32       	cpi	r24, 0x20	; 32
    5544:	92 07       	cpc	r25, r18
    5546:	d8 f4       	brcc	.+54     	; 0x557e <__vector_18+0x178>
	else OCR1B = LCD_delay;
    5548:	90 93 8b 00 	sts	0x008B, r25
    554c:	80 93 8a 00 	sts	0x008A, r24
	TIFR_LCD |= (1<<OCF1B);
    5550:	b2 9a       	sbi	0x16, 2	; 22
}
    5552:	ff 91       	pop	r31
    5554:	ef 91       	pop	r30
    5556:	bf 91       	pop	r27
    5558:	af 91       	pop	r26
    555a:	9f 91       	pop	r25
    555c:	8f 91       	pop	r24
    555e:	7f 91       	pop	r23
    5560:	6f 91       	pop	r22
    5562:	5f 91       	pop	r21
    5564:	4f 91       	pop	r20
    5566:	3f 91       	pop	r19
    5568:	2f 91       	pop	r18
    556a:	1f 91       	pop	r17
    556c:	0f 91       	pop	r16
    556e:	ff 90       	pop	r15
    5570:	0f 90       	pop	r0
    5572:	0b be       	out	0x3b, r0	; 59
    5574:	0f 90       	pop	r0
    5576:	0f be       	out	0x3f, r0	; 63
    5578:	0f 90       	pop	r0
    557a:	1f 90       	pop	r1
    557c:	18 95       	reti
			Send(prb(LineAddr+Y));
			Port_LCD_RS |=LCD_RS;
		}
	}
	LCD_delay = TCNT1 + LCD_delay;
	if(LCD_delay >= 20000) OCR1B = LCD_delay - 20000;
    557e:	80 52       	subi	r24, 0x20	; 32
    5580:	9e 44       	sbci	r25, 0x4E	; 78
    5582:	90 93 8b 00 	sts	0x008B, r25
    5586:	80 93 8a 00 	sts	0x008A, r24
    558a:	e2 cf       	rjmp	.-60     	; 0x5550 <__vector_18+0x14a>
ISR(TIMER1_COMPB_vect){

	uint16_t LCD_delay = 100;	//50us

	if (LCD_Rst_Flg) {
		switch(LCD_Rst_Flg){
    558c:	12 30       	cpi	r17, 0x02	; 2
    558e:	21 f1       	breq	.+72     	; 0x55d8 <__vector_18+0x1d2>
    5590:	13 30       	cpi	r17, 0x03	; 3
    5592:	f8 f4       	brcc	.+62     	; 0x55d2 <__vector_18+0x1cc>
    5594:	11 30       	cpi	r17, 0x01	; 1
    5596:	01 f1       	breq	.+64     	; 0x55d8 <__vector_18+0x1d2>
				#else
					Send(0b00000010);	//RETURN HOME					
				#endif
				Port_LCD_RS |=LCD_RS;
			default:
				LCD_Rst_Flg = 255;
    5598:	8f ef       	ldi	r24, 0xFF	; 255
    559a:	80 93 d6 04 	sts	0x04D6, r24
		}
		if(LCD_Rst_Flg==1) LCD_delay = 400;	//200us
    559e:	80 91 d6 04 	lds	r24, 0x04D6
    55a2:	81 30       	cpi	r24, 0x01	; 1
    55a4:	09 f0       	breq	.+2      	; 0x55a8 <__vector_18+0x1a2>
    55a6:	5f cf       	rjmp	.-322    	; 0x5466 <__vector_18+0x60>
    55a8:	20 e9       	ldi	r18, 0x90	; 144
    55aa:	31 e0       	ldi	r19, 0x01	; 1
    55ac:	5e cf       	rjmp	.-324    	; 0x546a <__vector_18+0x64>
				#else
					Send(0b00101000);	//; 4-bits DL, 2 lines, 5x7 dots
				#endif
				break;
			case 5:
				Send(0b00001100);	//; Display on, cursor off, blink off	
    55ae:	8c e0       	ldi	r24, 0x0C	; 12
    55b0:	0e 94 64 29 	call	0x52c8	; 0x52c8 <Send>
    55b4:	53 cf       	rjmp	.-346    	; 0x545c <__vector_18+0x56>
    55b6:	61 2f       	mov	r22, r17
    55b8:	70 e0       	ldi	r23, 0x00	; 0
    55ba:	e0 91 e7 02 	lds	r30, 0x02E7
    55be:	72 cf       	rjmp	.-284    	; 0x54a4 <__vector_18+0x9e>
				X++;
		}
		else {
			X = 0;
			if (++Y==LCDYSz) {
				Y = 0;
    55c0:	10 92 e7 02 	sts	0x02E7, r1
				TIMSK_LCD &= ~(1<<OCIE1B);	//stop Output CompareB interrups
    55c4:	80 91 6f 00 	lds	r24, 0x006F
    55c8:	8b 7f       	andi	r24, 0xFB	; 251
    55ca:	80 93 6f 00 	sts	0x006F, r24
    55ce:	e0 e0       	ldi	r30, 0x00	; 0
    55d0:	a6 cf       	rjmp	.-180    	; 0x551e <__vector_18+0x118>
ISR(TIMER1_COMPB_vect){

	uint16_t LCD_delay = 100;	//50us

	if (LCD_Rst_Flg) {
		switch(LCD_Rst_Flg){
    55d2:	13 30       	cpi	r17, 0x03	; 3
    55d4:	09 f0       	breq	.+2      	; 0x55d8 <__vector_18+0x1d2>
    55d6:	56 c0       	rjmp	.+172    	; 0x5684 <__vector_18+0x27e>
			case 2:
				LCD_FuncSet0();
				break;
			case 3:
				#ifdef Port_LCD_DB0	
					LCD_FuncSet0();
    55d8:	0e 94 ac 29 	call	0x5358	; 0x5358 <LCD_FuncSet0>
    55dc:	3f cf       	rjmp	.-386    	; 0x545c <__vector_18+0x56>
			else
			{
				cursor_symb=0;
			}

			Send(
    55de:	ca 01       	movw	r24, r20
    55e0:	88 0f       	add	r24, r24
    55e2:	99 1f       	adc	r25, r25
    55e4:	84 0f       	add	r24, r20
    55e6:	95 1f       	adc	r25, r21
    55e8:	fc 01       	movw	r30, r24
    55ea:	ee 0f       	add	r30, r30
    55ec:	ff 1f       	adc	r31, r31
    55ee:	ee 0f       	add	r30, r30
    55f0:	ff 1f       	adc	r31, r31
    55f2:	ee 0f       	add	r30, r30
    55f4:	ff 1f       	adc	r31, r31
    55f6:	e8 1b       	sub	r30, r24
    55f8:	f9 0b       	sbc	r31, r25
    55fa:	e6 0f       	add	r30, r22
    55fc:	f7 1f       	adc	r31, r23
    55fe:	e8 5a       	subi	r30, 0xA8	; 168
    5600:	f9 4f       	sbci	r31, 0xF9	; 249
    5602:	e0 81       	ld	r30, Z
    5604:	f0 e0       	ldi	r31, 0x00	; 0
    5606:	e1 53       	subi	r30, 0x31	; 49
    5608:	fb 4c       	sbci	r31, 0xCB	; 203
    560a:	24 91       	lpm	r18, Z+
    560c:	64 cf       	rjmp	.-312    	; 0x54d6 <__vector_18+0xd0>
ISR(TIMER1_COMPB_vect){

	uint16_t LCD_delay = 100;	//50us

	if (LCD_Rst_Flg) {
		switch(LCD_Rst_Flg){
    560e:	18 30       	cpi	r17, 0x08	; 8
    5610:	49 f0       	breq	.+18     	; 0x5624 <__vector_18+0x21e>
    5612:	19 30       	cpi	r17, 0x09	; 9
    5614:	09 f0       	breq	.+2      	; 0x5618 <__vector_18+0x212>
    5616:	c0 cf       	rjmp	.-128    	; 0x5598 <__vector_18+0x192>
						else{i=0;LCD_Rst_Flg = 8;}
					}
				}
				break;
			case 9:
				Port_LCD_RS &=~LCD_RS;
    5618:	44 98       	cbi	0x08, 4	; 8
				#ifdef NOT_USE_LCD_RETURN_HOME_CMD
					Send(128);			//     
				#else
					Send(0b00000010);	//RETURN HOME					
    561a:	82 e0       	ldi	r24, 0x02	; 2
    561c:	0e 94 64 29 	call	0x52c8	; 0x52c8 <Send>
				#endif
				Port_LCD_RS |=LCD_RS;
    5620:	44 9a       	sbi	0x08, 4	; 8
    5622:	ba cf       	rjmp	.-140    	; 0x5598 <__vector_18+0x192>
				Send(0b01000000);	//;    CG RAM   0.
				Port_LCD_RS |=LCD_RS;
				break;
			case 8:{
					static uint8_t i,j;
					LCD_Rst_Flg = 7;
    5624:	87 e0       	ldi	r24, 0x07	; 7
    5626:	80 93 d6 04 	sts	0x04D6, r24
					Send(prb(CGRAM_LCD[i]+j));
    562a:	f0 90 ea 02 	lds	r15, 0x02EA
    562e:	00 91 e9 02 	lds	r16, 0x02E9
    5632:	ef 2d       	mov	r30, r15
    5634:	f0 e0       	ldi	r31, 0x00	; 0
    5636:	ee 0f       	add	r30, r30
    5638:	ff 1f       	adc	r31, r31
    563a:	ee 0f       	add	r30, r30
    563c:	ff 1f       	adc	r31, r31
    563e:	ee 0f       	add	r30, r30
    5640:	ff 1f       	adc	r31, r31
    5642:	e0 0f       	add	r30, r16
    5644:	f1 1d       	adc	r31, r1
    5646:	e1 57       	subi	r30, 0x71	; 113
    5648:	fb 4c       	sbci	r31, 0xCB	; 203
    564a:	e4 91       	lpm	r30, Z+
    564c:	8e 2f       	mov	r24, r30
    564e:	0e 94 64 29 	call	0x52c8	; 0x52c8 <Send>
					if(j<7) j++;
    5652:	07 30       	cpi	r16, 0x07	; 7
    5654:	f0 f0       	brcs	.+60     	; 0x5692 <__vector_18+0x28c>
					else{
						j=0;
    5656:	10 92 e9 02 	sts	0x02E9, r1
						if(i<7)i++;
    565a:	26 e0       	ldi	r18, 0x06	; 6
    565c:	2f 15       	cp	r18, r15
    565e:	e8 f0       	brcs	.+58     	; 0x569a <__vector_18+0x294>
    5660:	f3 94       	inc	r15
    5662:	f0 92 ea 02 	sts	0x02EA, r15
    5666:	fa ce       	rjmp	.-524    	; 0x545c <__vector_18+0x56>
		static uint8_t X, Y;
		static prog_uint8_t LineAddr[] = {128, 192, 148, 212};
		unsigned char cursor_symb;
		
		if (X<LCDXSz) {
			if((X>=CurrX)&&(X<(CurrX+StrSize))&&(Y==CurrLCD)){
    5668:	e0 91 e7 02 	lds	r30, 0x02E7
    566c:	80 91 e8 08 	lds	r24, 0x08E8
    5670:	e8 17       	cp	r30, r24
    5672:	09 f0       	breq	.+2      	; 0x5676 <__vector_18+0x270>
    5674:	17 cf       	rjmp	.-466    	; 0x54a4 <__vector_18+0x9e>
    5676:	2f e5       	ldi	r18, 0x5F	; 95
    5678:	16 cf       	rjmp	.-468    	; 0x54a6 <__vector_18+0xa0>
				break;
			case 6:
				Send(0b00000110);	//; cursor shift right, no display shift
				break;
			case 7:
				Send(0b01000000);	//;    CG RAM   0.
    567a:	80 e4       	ldi	r24, 0x40	; 64
    567c:	0e 94 64 29 	call	0x52c8	; 0x52c8 <Send>
				Port_LCD_RS |=LCD_RS;
    5680:	44 9a       	sbi	0x08, 4	; 8
    5682:	ec ce       	rjmp	.-552    	; 0x545c <__vector_18+0x56>
ISR(TIMER1_COMPB_vect){

	uint16_t LCD_delay = 100;	//50us

	if (LCD_Rst_Flg) {
		switch(LCD_Rst_Flg){
    5684:	14 30       	cpi	r17, 0x04	; 4
    5686:	09 f0       	breq	.+2      	; 0x568a <__vector_18+0x284>
    5688:	87 cf       	rjmp	.-242    	; 0x5598 <__vector_18+0x192>
					LCD_FuncSet1();
				#endif
				break;
			case 4:
				#ifdef Port_LCD_DB0	
					Send(0b00111000);	//; 8-bits DL, 2 lines, 5x7 dots
    568a:	88 e3       	ldi	r24, 0x38	; 56
    568c:	0e 94 64 29 	call	0x52c8	; 0x52c8 <Send>
    5690:	e5 ce       	rjmp	.-566    	; 0x545c <__vector_18+0x56>
				break;
			case 8:{
					static uint8_t i,j;
					LCD_Rst_Flg = 7;
					Send(prb(CGRAM_LCD[i]+j));
					if(j<7) j++;
    5692:	0f 5f       	subi	r16, 0xFF	; 255
    5694:	00 93 e9 02 	sts	0x02E9, r16
    5698:	e1 ce       	rjmp	.-574    	; 0x545c <__vector_18+0x56>
					else{
						j=0;
						if(i<7)i++;
						else{i=0;LCD_Rst_Flg = 8;}
    569a:	10 92 ea 02 	sts	0x02EA, r1
    569e:	10 93 d6 04 	sts	0x04D6, r17
    56a2:	dc ce       	rjmp	.-584    	; 0x545c <__vector_18+0x56>

000056a4 <LCDBackLightOn>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    56a4:	9f b7       	in	r25, 0x3f	; 63
    56a6:	90 78       	andi	r25, 0x80	; 128
    56a8:	90 93 ee 02 	sts	0x02EE, r25
	cli();
    56ac:	f8 94       	cli
	void LCDBackLightOn(void){
		IntOff();	
		#ifdef BACKLIGHT_INVERSION
			PORT_BACKLIGHT &= ~BACKLIGHT;
		#else
			PORT_BACKLIGHT |= BACKLIGHT;
    56ae:	80 91 0b 01 	lds	r24, 0x010B
    56b2:	80 64       	ori	r24, 0x40	; 64
    56b4:	80 93 0b 01 	sts	0x010B, r24

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    56b8:	99 23       	and	r25, r25
    56ba:	09 f0       	breq	.+2      	; 0x56be <LCDBackLightOn+0x1a>
		sei();
    56bc:	78 94       	sei
    56be:	08 95       	ret

000056c0 <LCDBackLightOff>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    56c0:	9f b7       	in	r25, 0x3f	; 63
    56c2:	90 78       	andi	r25, 0x80	; 128
    56c4:	90 93 ee 02 	sts	0x02EE, r25
	cli();
    56c8:	f8 94       	cli
	void LCDBackLightOff(void){
		IntOff();	
		#ifdef BACKLIGHT_INVERSION
			PORT_BACKLIGHT |= BACKLIGHT;
		#else
			PORT_BACKLIGHT &= ~BACKLIGHT;
    56ca:	80 91 0b 01 	lds	r24, 0x010B
    56ce:	8f 7b       	andi	r24, 0xBF	; 191
    56d0:	80 93 0b 01 	sts	0x010B, r24

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    56d4:	99 23       	and	r25, r25
    56d6:	09 f0       	breq	.+2      	; 0x56da <LCDBackLightOff+0x1a>
		sei();
    56d8:	78 94       	sei
    56da:	08 95       	ret

000056dc <LCDBackLightControl>:
				StartTimer16(TD_BackLight, 3000);
				break;			
		}
	}
	void LCDBackLightControl(void){
		switch(BackLightMode){
    56dc:	80 91 52 06 	lds	r24, 0x0652
    56e0:	81 30       	cpi	r24, 0x01	; 1
    56e2:	29 f0       	breq	.+10     	; 0x56ee <LCDBackLightControl+0x12>
    56e4:	82 30       	cpi	r24, 0x02	; 2
    56e6:	61 f0       	breq	.+24     	; 0x5700 <LCDBackLightControl+0x24>
		case 1: if(Timer16Stopp(TD_BackLight)) LCDBackLightOff();
			break;
		case 2:
			break;
		default: LCDBackLightOn();
    56e8:	0e 94 52 2b 	call	0x56a4	; 0x56a4 <LCDBackLightOn>
    56ec:	08 95       	ret
				break;			
		}
	}
	void LCDBackLightControl(void){
		switch(BackLightMode){
		case 1: if(Timer16Stopp(TD_BackLight)) LCDBackLightOff();
    56ee:	80 91 d8 04 	lds	r24, 0x04D8
    56f2:	0e 94 84 1f 	call	0x3f08	; 0x3f08 <Timer16Stopp>
    56f6:	88 23       	and	r24, r24
    56f8:	c9 f3       	breq	.-14     	; 0x56ec <LCDBackLightControl+0x10>
    56fa:	0e 94 60 2b 	call	0x56c0	; 0x56c0 <LCDBackLightOff>
    56fe:	08 95       	ret
    5700:	08 95       	ret

00005702 <StartTimer0>:
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
		TCCR0  = ((((1<<WGM01) &~(1<<WGM00)  &~(1<<COM01)  &~(1<<COM00)) |(1<<CS02)) &~(1<<CS01)) |(1<<CS00);
	#elif defined (__AVR_ATmega128__)
		TCCR0  =   ((1<<WGM01) &~(1<<WGM00)  &~(1<<COM01)  &~(1<<COM00)) |(1<<CS02)   |(1<<CS01)  |(1<<CS00);
	#elif defined (__AVR_ATmega1280__)  || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TCCR0A =    (1<<WGM01) &~(1<<WGM00)  &~(1<<COM0A1) &~(1<<COM0A0) &~(1<<COM0B1) &~(1<<COM0B0);
    5702:	82 e0       	ldi	r24, 0x02	; 2
    5704:	84 bd       	out	0x24, r24	; 36
		TCCR0B = ((~(1<<WGM02)                                           |(1<<CS02)) &~(1<<CS01)) |(1<<CS00);
    5706:	85 ef       	ldi	r24, 0xF5	; 245
    5708:	85 bd       	out	0x25, r24	; 37
	#endif
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__)
		TIMSK |=(1<<OCIE0);
	#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TIMSK0 |=(1<<OCIE0A);
    570a:	ee e6       	ldi	r30, 0x6E	; 110
    570c:	f0 e0       	ldi	r31, 0x00	; 0
    570e:	80 81       	ld	r24, Z
    5710:	82 60       	ori	r24, 0x02	; 2
    5712:	80 83       	st	Z, r24
	#endif
}
    5714:	08 95       	ret

00005716 <StartTimer2>:
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
		TCCR2  =   ((1<<WGM21) &~(1<<WGM20)  &~(1<<COM21)  &~(1<<COM20)) |(1<<CS22)   |(1<<CS21)  |(1<<CS20);
	#elif defined (__AVR_ATmega128__)
		TCCR2  = ((((1<<WGM21) &~(1<<WGM20)  &~(1<<COM21)  &~(1<<COM20)) |(1<<CS22)) &~(1<<CS21)) |(1<<CS20);
	#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TCCR2A =    (1<<WGM21) &~(1<<WGM20)  &~(1<<COM2A1) &~(1<<COM2A0) &~(1<<COM2B1) &~(1<<COM2B0);
    5716:	82 e0       	ldi	r24, 0x02	; 2
    5718:	80 93 b0 00 	sts	0x00B0, r24
		TCCR2B =   ~(1<<WGM22)                                           |(1<<CS22)   |(1<<CS21)  |(1<<CS20);
    571c:	87 ef       	ldi	r24, 0xF7	; 247
    571e:	80 93 b1 00 	sts	0x00B1, r24
	#endif
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__)
		TIMSK |=(1<<OCIE2);
	#elif  defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TIMSK2 |=(1<<OCIE2A);
    5722:	e0 e7       	ldi	r30, 0x70	; 112
    5724:	f0 e0       	ldi	r31, 0x00	; 0
    5726:	80 81       	ld	r24, Z
    5728:	82 60       	ori	r24, 0x02	; 2
    572a:	80 83       	st	Z, r24
	#endif
}
    572c:	08 95       	ret

0000572e <StartTimer4>:
#if defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
	//static void
	void
	StartTimer4(void)
	{
		TCCR4A = 0;
    572e:	10 92 a0 00 	sts	0x00A0, r1
		TCCR4B = (1<<WGM42) | (1<<CS42) | (0<<CS41) | (1<<CS40);	// clk/1024
    5732:	8d e0       	ldi	r24, 0x0D	; 13
    5734:	80 93 a1 00 	sts	0x00A1, r24
		TIMSK4 |=(1<<OCIE4A);
    5738:	e2 e7       	ldi	r30, 0x72	; 114
    573a:	f0 e0       	ldi	r31, 0x00	; 0
    573c:	80 81       	ld	r24, Z
    573e:	82 60       	ori	r24, 0x02	; 2
    5740:	80 83       	st	Z, r24
	}
    5742:	08 95       	ret

00005744 <MB_Timer_ISR>:
// ~~~

// ~~~~~~~~~~~~~~~~~~~
static void
MB_Timer_ISR(tc_t *tc)
{
    5744:	bc 01       	movw	r22, r24

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5746:	ed e7       	ldi	r30, 0x7D	; 125
    5748:	f4 e3       	ldi	r31, 0x34	; 52
    574a:	85 91       	lpm	r24, Z+
    574c:	94 91       	lpm	r25, Z+
	#if defined (__AVR_ATxmega128A1__)
		tc->INTCTRLA = (tc->INTCTRLA &~TC1_OVFINTLVL_gm) |TC_OVFINTLVL_OFF_gc;
		tc->CTRLA = TC_CLKSEL_OFF_gc;
	#endif
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Timer[MB_N]tc_f)!=tc; MB_N++);
    574e:	68 17       	cp	r22, r24
    5750:	79 07       	cpc	r23, r25
    5752:	09 f4       	brne	.+2      	; 0x5756 <MB_Timer_ISR+0x12>
    5754:	54 c0       	rjmp	.+168    	; 0x57fe <MB_Timer_ISR+0xba>
    5756:	20 e0       	ldi	r18, 0x00	; 0
    5758:	2f 5f       	subi	r18, 0xFF	; 255
    575a:	42 2f       	mov	r20, r18
    575c:	50 e0       	ldi	r21, 0x00	; 0
    575e:	fa 01       	movw	r30, r20
    5760:	ee 0f       	add	r30, r30
    5762:	ff 1f       	adc	r31, r31
    5764:	e4 0f       	add	r30, r20
    5766:	f5 1f       	adc	r31, r21
    5768:	ee 0f       	add	r30, r30
    576a:	ff 1f       	adc	r31, r31
    576c:	e3 58       	subi	r30, 0x83	; 131
    576e:	fb 4c       	sbci	r31, 0xCB	; 203
    5770:	85 91       	lpm	r24, Z+
    5772:	94 91       	lpm	r25, Z+
    5774:	68 17       	cp	r22, r24
    5776:	79 07       	cpc	r23, r25
    5778:	79 f7       	brne	.-34     	; 0x5758 <MB_Timer_ISR+0x14>
    577a:	fa 01       	movw	r30, r20

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    577c:	e4 58       	subi	r30, 0x84	; 132
    577e:	fb 4c       	sbci	r31, 0xCB	; 203
    5780:	84 91       	lpm	r24, Z+

	
	switch (prb(MB_Role+MB_N)){
    5782:	88 23       	and	r24, r24
    5784:	f9 f4       	brne	.+62     	; 0x57c4 <MB_Timer_ISR+0x80>
	case Role_Slave:
		if(MB_Frame[MB_N][0]==MB_NativeAddr[MB_N]){	// Slave     -   MB_TimerFlag
    5786:	f4 2f       	mov	r31, r20
    5788:	ee 27       	eor	r30, r30
    578a:	e5 59       	subi	r30, 0x95	; 149
    578c:	f4 4f       	sbci	r31, 0xF4	; 244
    578e:	da 01       	movw	r26, r20
    5790:	a0 52       	subi	r26, 0x20	; 32
    5792:	ba 4f       	sbci	r27, 0xFA	; 250
    5794:	90 81       	ld	r25, Z
    5796:	8c 91       	ld	r24, X
    5798:	98 17       	cp	r25, r24
    579a:	21 f1       	breq	.+72     	; 0x57e4 <MB_Timer_ISR+0xa0>
			MB_TimerFlag |= (1<<MB_N);
		}
		else{
			MB_State[MB_N] = MB_Idle;
    579c:	fa 01       	movw	r30, r20
    579e:	ee 53       	subi	r30, 0x3E	; 62
    57a0:	fa 4f       	sbci	r31, 0xFA	; 250
    57a2:	81 e0       	ldi	r24, 0x01	; 1
    57a4:	80 83       	st	Z, r24
			MB_CPT[MB_N][0]++;
    57a6:	fa 01       	movw	r30, r20
    57a8:	e2 95       	swap	r30
    57aa:	f2 95       	swap	r31
    57ac:	f0 7f       	andi	r31, 0xF0	; 240
    57ae:	fe 27       	eor	r31, r30
    57b0:	e0 7f       	andi	r30, 0xF0	; 240
    57b2:	fe 27       	eor	r31, r30
    57b4:	ea 5c       	subi	r30, 0xCA	; 202
    57b6:	f6 4f       	sbci	r31, 0xF6	; 246
    57b8:	80 81       	ld	r24, Z
    57ba:	91 81       	ldd	r25, Z+1	; 0x01
    57bc:	01 96       	adiw	r24, 0x01	; 1
    57be:	91 83       	std	Z+1, r25	; 0x01
    57c0:	80 83       	st	Z, r24
    57c2:	08 95       	ret
	#endif
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Timer[MB_N]tc_f)!=tc; MB_N++);

	
	switch (prb(MB_Role+MB_N)){
    57c4:	81 30       	cpi	r24, 0x01	; 1
    57c6:	09 f0       	breq	.+2      	; 0x57ca <MB_Timer_ISR+0x86>
    57c8:	08 95       	ret
			MB_State[MB_N] = MB_Idle;
			MB_CPT[MB_N][0]++;
		}
		break;
	case Role_Master:
		MB_TimerFlag |= (1<<MB_N);
    57ca:	20 91 2a 09 	lds	r18, 0x092A
    57ce:	81 e0       	ldi	r24, 0x01	; 1
    57d0:	90 e0       	ldi	r25, 0x00	; 0
    57d2:	02 c0       	rjmp	.+4      	; 0x57d8 <MB_Timer_ISR+0x94>
    57d4:	88 0f       	add	r24, r24
    57d6:	99 1f       	adc	r25, r25
    57d8:	4a 95       	dec	r20
    57da:	e2 f7       	brpl	.-8      	; 0x57d4 <MB_Timer_ISR+0x90>
    57dc:	28 2b       	or	r18, r24
    57de:	20 93 2a 09 	sts	0x092A, r18
    57e2:	08 95       	ret

	
	switch (prb(MB_Role+MB_N)){
	case Role_Slave:
		if(MB_Frame[MB_N][0]==MB_NativeAddr[MB_N]){	// Slave     -   MB_TimerFlag
			MB_TimerFlag |= (1<<MB_N);
    57e4:	20 91 2a 09 	lds	r18, 0x092A
    57e8:	81 e0       	ldi	r24, 0x01	; 1
    57ea:	90 e0       	ldi	r25, 0x00	; 0
    57ec:	02 c0       	rjmp	.+4      	; 0x57f2 <MB_Timer_ISR+0xae>
    57ee:	88 0f       	add	r24, r24
    57f0:	99 1f       	adc	r25, r25
    57f2:	4a 95       	dec	r20
    57f4:	e2 f7       	brpl	.-8      	; 0x57ee <MB_Timer_ISR+0xaa>
    57f6:	28 2b       	or	r18, r24
    57f8:	20 93 2a 09 	sts	0x092A, r18
    57fc:	08 95       	ret
	#if defined (__AVR_ATxmega128A1__)
		tc->INTCTRLA = (tc->INTCTRLA &~TC1_OVFINTLVL_gm) |TC_OVFINTLVL_OFF_gc;
		tc->CTRLA = TC_CLKSEL_OFF_gc;
	#endif
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Timer[MB_N]tc_f)!=tc; MB_N++);
    57fe:	40 e0       	ldi	r20, 0x00	; 0
    5800:	50 e0       	ldi	r21, 0x00	; 0
    5802:	e0 e0       	ldi	r30, 0x00	; 0
    5804:	f0 e0       	ldi	r31, 0x00	; 0
    5806:	ba cf       	rjmp	.-140    	; 0x577c <MB_Timer_ISR+0x38>

00005808 <__vector_21>:
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#elif  defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) ||defined (__AVR_ATmega2561__)
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ISR(TIMER0_COMPA_vect)
{
    5808:	1f 92       	push	r1
    580a:	0f 92       	push	r0
    580c:	0f b6       	in	r0, 0x3f	; 63
    580e:	0f 92       	push	r0
    5810:	0b b6       	in	r0, 0x3b	; 59
    5812:	0f 92       	push	r0
    5814:	11 24       	eor	r1, r1
    5816:	2f 93       	push	r18
    5818:	3f 93       	push	r19
    581a:	4f 93       	push	r20
    581c:	5f 93       	push	r21
    581e:	6f 93       	push	r22
    5820:	7f 93       	push	r23
    5822:	8f 93       	push	r24
    5824:	9f 93       	push	r25
    5826:	af 93       	push	r26
    5828:	bf 93       	push	r27
    582a:	ef 93       	push	r30
    582c:	ff 93       	push	r31
	TCCR0B &=~(1<<CS02) &~(1<<CS01) &~(1<<CS00);
    582e:	85 b5       	in	r24, 0x25	; 37
    5830:	88 7f       	andi	r24, 0xF8	; 248
    5832:	85 bd       	out	0x25, r24	; 37
	TIMSK0 &=~(1<<OCIE0A);
    5834:	ee e6       	ldi	r30, 0x6E	; 110
    5836:	f0 e0       	ldi	r31, 0x00	; 0
    5838:	80 81       	ld	r24, Z
    583a:	8d 7f       	andi	r24, 0xFD	; 253
    583c:	80 83       	st	Z, r24
	MB_Timer_ISR(&TCNT0);
    583e:	86 e4       	ldi	r24, 0x46	; 70
    5840:	90 e0       	ldi	r25, 0x00	; 0
    5842:	0e 94 a2 2b 	call	0x5744	; 0x5744 <MB_Timer_ISR>
}
    5846:	ff 91       	pop	r31
    5848:	ef 91       	pop	r30
    584a:	bf 91       	pop	r27
    584c:	af 91       	pop	r26
    584e:	9f 91       	pop	r25
    5850:	8f 91       	pop	r24
    5852:	7f 91       	pop	r23
    5854:	6f 91       	pop	r22
    5856:	5f 91       	pop	r21
    5858:	4f 91       	pop	r20
    585a:	3f 91       	pop	r19
    585c:	2f 91       	pop	r18
    585e:	0f 90       	pop	r0
    5860:	0b be       	out	0x3b, r0	; 59
    5862:	0f 90       	pop	r0
    5864:	0f be       	out	0x3f, r0	; 63
    5866:	0f 90       	pop	r0
    5868:	1f 90       	pop	r1
    586a:	18 95       	reti

0000586c <__vector_13>:

// ~~~~~~~~~~~~~~~~~~~
ISR(TIMER2_COMPA_vect)
{
    586c:	1f 92       	push	r1
    586e:	0f 92       	push	r0
    5870:	0f b6       	in	r0, 0x3f	; 63
    5872:	0f 92       	push	r0
    5874:	0b b6       	in	r0, 0x3b	; 59
    5876:	0f 92       	push	r0
    5878:	11 24       	eor	r1, r1
    587a:	2f 93       	push	r18
    587c:	3f 93       	push	r19
    587e:	4f 93       	push	r20
    5880:	5f 93       	push	r21
    5882:	6f 93       	push	r22
    5884:	7f 93       	push	r23
    5886:	8f 93       	push	r24
    5888:	9f 93       	push	r25
    588a:	af 93       	push	r26
    588c:	bf 93       	push	r27
    588e:	ef 93       	push	r30
    5890:	ff 93       	push	r31
	TCCR2B &=~(1<<CS22) &~(1<<CS21) &~(1<<CS20);
    5892:	e1 eb       	ldi	r30, 0xB1	; 177
    5894:	f0 e0       	ldi	r31, 0x00	; 0
    5896:	80 81       	ld	r24, Z
    5898:	88 7f       	andi	r24, 0xF8	; 248
    589a:	80 83       	st	Z, r24
	TIMSK2 &=~(1<<OCIE2A);
    589c:	e0 e7       	ldi	r30, 0x70	; 112
    589e:	f0 e0       	ldi	r31, 0x00	; 0
    58a0:	80 81       	ld	r24, Z
    58a2:	8d 7f       	andi	r24, 0xFD	; 253
    58a4:	80 83       	st	Z, r24
	MB_Timer_ISR(&TCNT2);
    58a6:	82 eb       	ldi	r24, 0xB2	; 178
    58a8:	90 e0       	ldi	r25, 0x00	; 0
    58aa:	0e 94 a2 2b 	call	0x5744	; 0x5744 <MB_Timer_ISR>
}
    58ae:	ff 91       	pop	r31
    58b0:	ef 91       	pop	r30
    58b2:	bf 91       	pop	r27
    58b4:	af 91       	pop	r26
    58b6:	9f 91       	pop	r25
    58b8:	8f 91       	pop	r24
    58ba:	7f 91       	pop	r23
    58bc:	6f 91       	pop	r22
    58be:	5f 91       	pop	r21
    58c0:	4f 91       	pop	r20
    58c2:	3f 91       	pop	r19
    58c4:	2f 91       	pop	r18
    58c6:	0f 90       	pop	r0
    58c8:	0b be       	out	0x3b, r0	; 59
    58ca:	0f 90       	pop	r0
    58cc:	0f be       	out	0x3f, r0	; 63
    58ce:	0f 90       	pop	r0
    58d0:	1f 90       	pop	r1
    58d2:	18 95       	reti

000058d4 <__vector_42>:
// ~~~~~~~~~~~~~~~~~~~
ISR(TIMER4_COMPA_vect)
{
    58d4:	1f 92       	push	r1
    58d6:	0f 92       	push	r0
    58d8:	0f b6       	in	r0, 0x3f	; 63
    58da:	0f 92       	push	r0
    58dc:	0b b6       	in	r0, 0x3b	; 59
    58de:	0f 92       	push	r0
    58e0:	11 24       	eor	r1, r1
    58e2:	2f 93       	push	r18
    58e4:	3f 93       	push	r19
    58e6:	4f 93       	push	r20
    58e8:	5f 93       	push	r21
    58ea:	6f 93       	push	r22
    58ec:	7f 93       	push	r23
    58ee:	8f 93       	push	r24
    58f0:	9f 93       	push	r25
    58f2:	af 93       	push	r26
    58f4:	bf 93       	push	r27
    58f6:	ef 93       	push	r30
    58f8:	ff 93       	push	r31
	TCCR4B &=~(1<<CS42) &~(1<<CS41) &~(1<<CS40);
    58fa:	e1 ea       	ldi	r30, 0xA1	; 161
    58fc:	f0 e0       	ldi	r31, 0x00	; 0
    58fe:	80 81       	ld	r24, Z
    5900:	88 7f       	andi	r24, 0xF8	; 248
    5902:	80 83       	st	Z, r24
	TIMSK4 &=~(1<<OCIE4A);
    5904:	e2 e7       	ldi	r30, 0x72	; 114
    5906:	f0 e0       	ldi	r31, 0x00	; 0
    5908:	80 81       	ld	r24, Z
    590a:	8d 7f       	andi	r24, 0xFD	; 253
    590c:	80 83       	st	Z, r24
	MB_Timer_ISR((uint8_t*)&TCNT4);
    590e:	84 ea       	ldi	r24, 0xA4	; 164
    5910:	90 e0       	ldi	r25, 0x00	; 0
    5912:	0e 94 a2 2b 	call	0x5744	; 0x5744 <MB_Timer_ISR>
}
    5916:	ff 91       	pop	r31
    5918:	ef 91       	pop	r30
    591a:	bf 91       	pop	r27
    591c:	af 91       	pop	r26
    591e:	9f 91       	pop	r25
    5920:	8f 91       	pop	r24
    5922:	7f 91       	pop	r23
    5924:	6f 91       	pop	r22
    5926:	5f 91       	pop	r21
    5928:	4f 91       	pop	r20
    592a:	3f 91       	pop	r19
    592c:	2f 91       	pop	r18
    592e:	0f 90       	pop	r0
    5930:	0b be       	out	0x3b, r0	; 59
    5932:	0f 90       	pop	r0
    5934:	0f be       	out	0x3f, r0	; 63
    5936:	0f 90       	pop	r0
    5938:	1f 90       	pop	r1
    593a:	18 95       	reti

0000593c <MBRecept>:
		#endif
		MB_Err &=(1<<MB_N);
		return;
	}
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		Buf = USART_Reg(MB_N, ucsra);
    593c:	68 2f       	mov	r22, r24
    593e:	70 e0       	ldi	r23, 0x00	; 0

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5940:	9b 01       	movw	r18, r22
    5942:	22 0f       	add	r18, r18
    5944:	33 1f       	adc	r19, r19
    5946:	cb 01       	movw	r24, r22
    5948:	88 0f       	add	r24, r24
    594a:	99 1f       	adc	r25, r25
    594c:	88 0f       	add	r24, r24
    594e:	99 1f       	adc	r25, r25
    5950:	88 0f       	add	r24, r24
    5952:	99 1f       	adc	r25, r25
    5954:	28 0f       	add	r18, r24
    5956:	39 1f       	adc	r19, r25
    5958:	22 0f       	add	r18, r18
    595a:	33 1f       	adc	r19, r19
    595c:	26 59       	subi	r18, 0x96	; 150
    595e:	3b 4c       	sbci	r19, 0xCB	; 203
    5960:	f9 01       	movw	r30, r18
    5962:	a5 91       	lpm	r26, Z+
    5964:	b4 91       	lpm	r27, Z+
    5966:	3c 91       	ld	r19, X
		MB_Frame[MB_N][MB_Frame_Sz[MB_N]++] = USART_Reg(MB_N, udr);
    5968:	ab 01       	movw	r20, r22
    596a:	47 5b       	subi	r20, 0xB7	; 183
    596c:	58 4f       	sbci	r21, 0xF8	; 248
    596e:	fa 01       	movw	r30, r20
    5970:	20 81       	ld	r18, Z
    5972:	cb 01       	movw	r24, r22
    5974:	88 0f       	add	r24, r24
    5976:	99 1f       	adc	r25, r25
    5978:	88 0f       	add	r24, r24
    597a:	99 1f       	adc	r25, r25
    597c:	fc 01       	movw	r30, r24
    597e:	ee 0f       	add	r30, r30
    5980:	ff 1f       	adc	r31, r31
    5982:	ee 0f       	add	r30, r30
    5984:	ff 1f       	adc	r31, r31
    5986:	e8 0f       	add	r30, r24
    5988:	f9 1f       	adc	r31, r25
    598a:	e8 59       	subi	r30, 0x98	; 152
    598c:	fb 4c       	sbci	r31, 0xCB	; 203
    598e:	a5 91       	lpm	r26, Z+
    5990:	b4 91       	lpm	r27, Z+
    5992:	f6 2f       	mov	r31, r22
    5994:	ee 27       	eor	r30, r30
    5996:	e2 0f       	add	r30, r18
    5998:	f1 1d       	adc	r31, r1
    599a:	e5 59       	subi	r30, 0x95	; 149
    599c:	f4 4f       	sbci	r31, 0xF4	; 244
    599e:	8c 91       	ld	r24, X
    59a0:	80 83       	st	Z, r24
    59a2:	2f 5f       	subi	r18, 0xFF	; 255
    59a4:	fa 01       	movw	r30, r20
    59a6:	20 83       	st	Z, r18
	#elif defined (__AVR_ATxmega128A1__)
		USART_t *usart = prp(&MB_Port[MB_N].usart);
		Buf = usart->STATUS;
		MB_Frame[MB_N][MB_Frame_Sz[MB_N]++] = usart->DATA;
	#endif
	if (Buf &(1<<3))
    59a8:	23 2f       	mov	r18, r19
    59aa:	30 e0       	ldi	r19, 0x00	; 0
    59ac:	23 ff       	sbrs	r18, 3
    59ae:	0e c0       	rjmp	.+28     	; 0x59cc <MBRecept+0x90>
		MB_CPT[MB_N][7]++;
    59b0:	fb 01       	movw	r30, r22
    59b2:	e2 95       	swap	r30
    59b4:	f2 95       	swap	r31
    59b6:	f0 7f       	andi	r31, 0xF0	; 240
    59b8:	fe 27       	eor	r31, r30
    59ba:	e0 7f       	andi	r30, 0xF0	; 240
    59bc:	fe 27       	eor	r31, r30
    59be:	ea 5c       	subi	r30, 0xCA	; 202
    59c0:	f6 4f       	sbci	r31, 0xF6	; 246
    59c2:	86 85       	ldd	r24, Z+14	; 0x0e
    59c4:	97 85       	ldd	r25, Z+15	; 0x0f
    59c6:	01 96       	adiw	r24, 0x01	; 1
    59c8:	97 87       	std	Z+15, r25	; 0x0f
    59ca:	86 87       	std	Z+14, r24	; 0x0e
	if (Buf &((1<<4) |(1<<3) |(1<<2)))
    59cc:	2c 71       	andi	r18, 0x1C	; 28
    59ce:	30 70       	andi	r19, 0x00	; 0
    59d0:	23 2b       	or	r18, r19
    59d2:	61 f0       	breq	.+24     	; 0x59ec <MBRecept+0xb0>
		MB_Err |=(1<<MB_N);
    59d4:	81 e0       	ldi	r24, 0x01	; 1
    59d6:	90 e0       	ldi	r25, 0x00	; 0
    59d8:	02 c0       	rjmp	.+4      	; 0x59de <MBRecept+0xa2>
    59da:	88 0f       	add	r24, r24
    59dc:	99 1f       	adc	r25, r25
    59de:	6a 95       	dec	r22
    59e0:	e2 f7       	brpl	.-8      	; 0x59da <MBRecept+0x9e>
    59e2:	20 91 d9 04 	lds	r18, 0x04D9
    59e6:	28 2b       	or	r18, r24
    59e8:	20 93 d9 04 	sts	0x04D9, r18
    59ec:	08 95       	ret

000059ee <MB_Transm>:
}

// ~~~~~~~~~~~~~~~~~~~~
void
MB_Transm(uint8_t MB_N)
{
    59ee:	af 92       	push	r10
    59f0:	bf 92       	push	r11
    59f2:	cf 92       	push	r12
    59f4:	df 92       	push	r13
    59f6:	ef 92       	push	r14
    59f8:	ff 92       	push	r15
    59fa:	0f 93       	push	r16
    59fc:	1f 93       	push	r17
	MB_State[MB_N] = MB_Trans;
    59fe:	e8 2e       	mov	r14, r24
    5a00:	ff 24       	eor	r15, r15
    5a02:	f7 01       	movw	r30, r14
    5a04:	ee 53       	subi	r30, 0x3E	; 62
    5a06:	fa 4f       	sbci	r31, 0xFA	; 250
    5a08:	83 e0       	ldi	r24, 0x03	; 3
    5a0a:	80 83       	st	Z, r24
    5a0c:	57 01       	movw	r10, r14
    5a0e:	aa 0c       	add	r10, r10
    5a10:	bb 1c       	adc	r11, r11
    5a12:	aa 0c       	add	r10, r10
    5a14:	bb 1c       	adc	r11, r11
    5a16:	85 01       	movw	r16, r10
    5a18:	00 0f       	add	r16, r16
    5a1a:	11 1f       	adc	r17, r17
    5a1c:	00 0f       	add	r16, r16
    5a1e:	11 1f       	adc	r17, r17
    5a20:	0a 0d       	add	r16, r10
    5a22:	1b 1d       	adc	r17, r11
    5a24:	04 5f       	subi	r16, 0xF4	; 244
    5a26:	1f 4f       	sbci	r17, 0xFF	; 255
    5a28:	88 e6       	ldi	r24, 0x68	; 104
    5a2a:	c8 2e       	mov	r12, r24
    5a2c:	84 e3       	ldi	r24, 0x34	; 52
    5a2e:	d8 2e       	mov	r13, r24
    5a30:	c6 01       	movw	r24, r12
    5a32:	80 0f       	add	r24, r16
    5a34:	91 1f       	adc	r25, r17
    5a36:	0c 50       	subi	r16, 0x0C	; 12
    5a38:	10 40       	sbci	r17, 0x00	; 0
    5a3a:	fc 01       	movw	r30, r24
    5a3c:	25 91       	lpm	r18, Z+
    5a3e:	34 91       	lpm	r19, Z+
	USART_Func(MB_N, RS485);
    5a40:	f9 01       	movw	r30, r18
    5a42:	19 95       	eicall
    5a44:	f6 01       	movw	r30, r12
    5a46:	e0 0f       	add	r30, r16
    5a48:	f1 1f       	adc	r31, r17
    5a4a:	a5 91       	lpm	r26, Z+
    5a4c:	b4 91       	lpm	r27, Z+
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		//USART_Reg(MB_N, ucsrb) |=(1<<6);
		USART_Reg(MB_N, udr) = MB_Frame[MB_N][0];
    5a4e:	fe 2d       	mov	r31, r14
    5a50:	ee 27       	eor	r30, r30
    5a52:	e5 59       	subi	r30, 0x95	; 149
    5a54:	f4 4f       	sbci	r31, 0xF4	; 244
    5a56:	80 81       	ld	r24, Z
    5a58:	8c 93       	st	X, r24
    5a5a:	97 01       	movw	r18, r14
    5a5c:	22 0f       	add	r18, r18
    5a5e:	33 1f       	adc	r19, r19
    5a60:	c7 01       	movw	r24, r14
    5a62:	88 0f       	add	r24, r24
    5a64:	99 1f       	adc	r25, r25
    5a66:	88 0f       	add	r24, r24
    5a68:	99 1f       	adc	r25, r25
    5a6a:	88 0f       	add	r24, r24
    5a6c:	99 1f       	adc	r25, r25
    5a6e:	28 0f       	add	r18, r24
    5a70:	39 1f       	adc	r19, r25
    5a72:	2f 5f       	subi	r18, 0xFF	; 255
    5a74:	3f 4f       	sbci	r19, 0xFF	; 255
    5a76:	22 0f       	add	r18, r18
    5a78:	33 1f       	adc	r19, r19
    5a7a:	2c 0d       	add	r18, r12
    5a7c:	3d 1d       	adc	r19, r13
    5a7e:	f9 01       	movw	r30, r18
    5a80:	a5 91       	lpm	r26, Z+
    5a82:	b4 91       	lpm	r27, Z+

		USART_Reg(MB_N, ucsra) |=(1<<6);	//Clear TxC pending interrupt		
    5a84:	8c 91       	ld	r24, X
    5a86:	80 64       	ori	r24, 0x40	; 64
    5a88:	8c 93       	st	X, r24
    5a8a:	c5 01       	movw	r24, r10
    5a8c:	8e 0d       	add	r24, r14
    5a8e:	9f 1d       	adc	r25, r15
    5a90:	01 96       	adiw	r24, 0x01	; 1
    5a92:	88 0f       	add	r24, r24
    5a94:	99 1f       	adc	r25, r25
    5a96:	88 0f       	add	r24, r24
    5a98:	99 1f       	adc	r25, r25
    5a9a:	8c 0d       	add	r24, r12
    5a9c:	9d 1d       	adc	r25, r13
    5a9e:	fc 01       	movw	r30, r24
    5aa0:	a5 91       	lpm	r26, Z+
    5aa2:	b4 91       	lpm	r27, Z+
		USART_Reg(MB_N, ucsrb) |=(1<<5);
    5aa4:	8c 91       	ld	r24, X
    5aa6:	80 62       	ori	r24, 0x20	; 32
    5aa8:	8c 93       	st	X, r24
	#elif defined (__AVR_ATxmega128A1__)
		USART_t *usart = prp(&MB_Port[MB_N].usart);
		usart->CTRLA = (usart->CTRLA &~USART_TXCINTLVL_gm) |USART_TXCINTLVL_HI_gc;
		usart->DATA = MB_Frame[MB_N][0];
	#endif
}
    5aaa:	1f 91       	pop	r17
    5aac:	0f 91       	pop	r16
    5aae:	ff 90       	pop	r15
    5ab0:	ef 90       	pop	r14
    5ab2:	df 90       	pop	r13
    5ab4:	cf 90       	pop	r12
    5ab6:	bf 90       	pop	r11
    5ab8:	af 90       	pop	r10
    5aba:	08 95       	ret

00005abc <Modbus_RX>:

// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_RX(usart_t *usart)
{
    5abc:	cf 93       	push	r28
    5abe:	df 93       	push	r29
    5ac0:	dc 01       	movw	r26, r24
    5ac2:	e8 e6       	ldi	r30, 0x68	; 104
    5ac4:	f4 e3       	ldi	r31, 0x34	; 52
    5ac6:	85 91       	lpm	r24, Z+
    5ac8:	94 91       	lpm	r25, Z+
// ~~~~~~~~~~~~~~~~~~~~~~
static uint8_t
MB_Port_N(usart_t *usart)
{
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Port[MB_N].usart_field)!=usart; MB_N++);
    5aca:	a8 17       	cp	r26, r24
    5acc:	b9 07       	cpc	r27, r25
    5ace:	09 f4       	brne	.+2      	; 0x5ad2 <Modbus_RX+0x16>
    5ad0:	6e c0       	rjmp	.+220    	; 0x5bae <Modbus_RX+0xf2>
    5ad2:	30 e0       	ldi	r19, 0x00	; 0
    5ad4:	3f 5f       	subi	r19, 0xFF	; 255
    5ad6:	c3 2f       	mov	r28, r19
    5ad8:	d0 e0       	ldi	r29, 0x00	; 0
    5ada:	ce 01       	movw	r24, r28
    5adc:	88 0f       	add	r24, r24
    5ade:	99 1f       	adc	r25, r25
    5ae0:	88 0f       	add	r24, r24
    5ae2:	99 1f       	adc	r25, r25
    5ae4:	fc 01       	movw	r30, r24
    5ae6:	ee 0f       	add	r30, r30
    5ae8:	ff 1f       	adc	r31, r31
    5aea:	ee 0f       	add	r30, r30
    5aec:	ff 1f       	adc	r31, r31
    5aee:	e8 0f       	add	r30, r24
    5af0:	f9 1f       	adc	r31, r25
    5af2:	e8 59       	subi	r30, 0x98	; 152
    5af4:	fb 4c       	sbci	r31, 0xCB	; 203
    5af6:	85 91       	lpm	r24, Z+
    5af8:	94 91       	lpm	r25, Z+
    5afa:	a8 17       	cp	r26, r24
    5afc:	b9 07       	cpc	r27, r25
    5afe:	51 f7       	brne	.-44     	; 0x5ad4 <Modbus_RX+0x18>
// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_RX(usart_t *usart)
{
	uint8_t MB_N = MB_Port_N(usart);
	switch (MB_State[MB_N]) {
    5b00:	fe 01       	movw	r30, r28
    5b02:	ee 53       	subi	r30, 0x3E	; 62
    5b04:	fa 4f       	sbci	r31, 0xFA	; 250
    5b06:	80 81       	ld	r24, Z
    5b08:	82 30       	cpi	r24, 0x02	; 2
    5b0a:	19 f1       	breq	.+70     	; 0x5b52 <Modbus_RX+0x96>
    5b0c:	83 30       	cpi	r24, 0x03	; 3
    5b0e:	28 f0       	brcs	.+10     	; 0x5b1a <Modbus_RX+0x5e>
    5b10:	86 30       	cpi	r24, 0x06	; 6
    5b12:	d8 f0       	brcs	.+54     	; 0x5b4a <Modbus_RX+0x8e>
	case MB_Trans: case MB_Proc: 
	case MB_NoReply: // MB_NoReply    MB_Recept ..  MB_M_Cycle   MB_Trans
		usart_data(usart);
		break;
	}
}
    5b14:	df 91       	pop	r29
    5b16:	cf 91       	pop	r28
    5b18:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_RX(usart_t *usart)
{
	uint8_t MB_N = MB_Port_N(usart);
	switch (MB_State[MB_N]) {
    5b1a:	88 23       	and	r24, r24
    5b1c:	f1 f4       	brne	.+60     	; 0x5b5a <Modbus_RX+0x9e>
	case MB_Initi:
		MB_Frame[MB_N][0] = usart_data(usart);
    5b1e:	8c 91       	ld	r24, X
    5b20:	fc 2f       	mov	r31, r28
    5b22:	ee 27       	eor	r30, r30
    5b24:	e5 59       	subi	r30, 0x95	; 149
    5b26:	f4 4f       	sbci	r31, 0xF4	; 244
    5b28:	80 83       	st	Z, r24
    5b2a:	ce 01       	movw	r24, r28
    5b2c:	88 0f       	add	r24, r24
    5b2e:	99 1f       	adc	r25, r25
    5b30:	8c 0f       	add	r24, r28
    5b32:	9d 1f       	adc	r25, r29
    5b34:	88 0f       	add	r24, r24
    5b36:	99 1f       	adc	r25, r25
    5b38:	83 58       	subi	r24, 0x83	; 131
    5b3a:	9b 4c       	sbci	r25, 0xCB	; 203
    5b3c:	fc 01       	movw	r30, r24
    5b3e:	a5 91       	lpm	r26, Z+
    5b40:	b4 91       	lpm	r27, Z+
		break;
	case MB_Recept:
		/*if(TCNT2>=prb(&(BR_Tbl+MB_BitRate_RAM[MB_N])->Time15))
			MB_Err &=(1<<MB_N);*/
		MBRecept(MB_N);
		MB_ClearTimer(MB_N);
    5b42:	1c 92       	st	X, r1
	case MB_Trans: case MB_Proc: 
	case MB_NoReply: // MB_NoReply    MB_Recept ..  MB_M_Cycle   MB_Trans
		usart_data(usart);
		break;
	}
}
    5b44:	df 91       	pop	r29
    5b46:	cf 91       	pop	r28
    5b48:	08 95       	ret
		MBRecept(MB_N);
		MB_ClearTimer(MB_N);
		break;
	case MB_Trans: case MB_Proc: 
	case MB_NoReply: // MB_NoReply    MB_Recept ..  MB_M_Cycle   MB_Trans
		usart_data(usart);
    5b4a:	8c 91       	ld	r24, X
		break;
	}
}
    5b4c:	df 91       	pop	r29
    5b4e:	cf 91       	pop	r28
    5b50:	08 95       	ret
		MB_StartTimer(MB_N);
		break;
	case MB_Recept:
		/*if(TCNT2>=prb(&(BR_Tbl+MB_BitRate_RAM[MB_N])->Time15))
			MB_Err &=(1<<MB_N);*/
		MBRecept(MB_N);
    5b52:	83 2f       	mov	r24, r19
    5b54:	0e 94 9e 2c 	call	0x593c	; 0x593c <MBRecept>
    5b58:	e8 cf       	rjmp	.-48     	; 0x5b2a <Modbus_RX+0x6e>
// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_RX(usart_t *usart)
{
	uint8_t MB_N = MB_Port_N(usart);
	switch (MB_State[MB_N]) {
    5b5a:	81 30       	cpi	r24, 0x01	; 1
    5b5c:	d9 f6       	brne	.-74     	; 0x5b14 <Modbus_RX+0x58>
	case MB_Initi:
		MB_Frame[MB_N][0] = usart_data(usart);
		MB_ClearTimer(MB_N);
		break;
	case MB_Idle: 
		MB_State[MB_N] = MB_Recept;
    5b5e:	82 e0       	ldi	r24, 0x02	; 2
    5b60:	80 83       	st	Z, r24
		MB_Err &=~(1<<MB_N);
    5b62:	81 e0       	ldi	r24, 0x01	; 1
    5b64:	90 e0       	ldi	r25, 0x00	; 0
    5b66:	0c 2e       	mov	r0, r28
    5b68:	02 c0       	rjmp	.+4      	; 0x5b6e <Modbus_RX+0xb2>
    5b6a:	88 0f       	add	r24, r24
    5b6c:	99 1f       	adc	r25, r25
    5b6e:	0a 94       	dec	r0
    5b70:	e2 f7       	brpl	.-8      	; 0x5b6a <Modbus_RX+0xae>
    5b72:	80 95       	com	r24
    5b74:	20 91 d9 04 	lds	r18, 0x04D9
    5b78:	28 23       	and	r18, r24
    5b7a:	20 93 d9 04 	sts	0x04D9, r18
		MB_Frame_Sz[MB_N] = 0;
    5b7e:	fe 01       	movw	r30, r28
    5b80:	e7 5b       	subi	r30, 0xB7	; 183
    5b82:	f8 4f       	sbci	r31, 0xF8	; 248
    5b84:	10 82       	st	Z, r1
		MBRecept(MB_N);
    5b86:	83 2f       	mov	r24, r19
    5b88:	0e 94 9e 2c 	call	0x593c	; 0x593c <MBRecept>
    5b8c:	ce 01       	movw	r24, r28
    5b8e:	88 0f       	add	r24, r24
    5b90:	99 1f       	adc	r25, r25
    5b92:	8c 0f       	add	r24, r28
    5b94:	9d 1f       	adc	r25, r29
    5b96:	88 0f       	add	r24, r24
    5b98:	99 1f       	adc	r25, r25
    5b9a:	8f 57       	subi	r24, 0x7F	; 127
    5b9c:	9b 4c       	sbci	r25, 0xCB	; 203
    5b9e:	fc 01       	movw	r30, r24
    5ba0:	25 91       	lpm	r18, Z+
    5ba2:	34 91       	lpm	r19, Z+
		MB_StartTimer(MB_N);
    5ba4:	f9 01       	movw	r30, r18
    5ba6:	19 95       	eicall
	case MB_Trans: case MB_Proc: 
	case MB_NoReply: // MB_NoReply    MB_Recept ..  MB_M_Cycle   MB_Trans
		usart_data(usart);
		break;
	}
}
    5ba8:	df 91       	pop	r29
    5baa:	cf 91       	pop	r28
    5bac:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~
static uint8_t
MB_Port_N(usart_t *usart)
{
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Port[MB_N].usart_field)!=usart; MB_N++);
    5bae:	30 e0       	ldi	r19, 0x00	; 0
    5bb0:	c0 e0       	ldi	r28, 0x00	; 0
    5bb2:	d0 e0       	ldi	r29, 0x00	; 0
    5bb4:	a5 cf       	rjmp	.-182    	; 0x5b00 <Modbus_RX+0x44>

00005bb6 <CommErr>:
}

// ~~~~~~~~~~~~~~~~~~
uint8_t
CommErr(uint8_t MB_N)
{
    5bb6:	0f 93       	push	r16
    5bb8:	1f 93       	push	r17
    5bba:	cf 93       	push	r28
    5bbc:	df 93       	push	r29
    5bbe:	38 2f       	mov	r19, r24
	uint8_t Sz = MB_Frame_Sz[MB_N]-2;
    5bc0:	c8 2f       	mov	r28, r24
    5bc2:	d0 e0       	ldi	r29, 0x00	; 0
    5bc4:	fe 01       	movw	r30, r28
    5bc6:	e7 5b       	subi	r30, 0xB7	; 183
    5bc8:	f8 4f       	sbci	r31, 0xF8	; 248
    5bca:	20 81       	ld	r18, Z
	uint8_t Err = MB_Err &(1<<MB_N) || MB_Frame_Sz[MB_N]<3 || *(uint16_t*)(MB_Frame[MB_N]+Sz)!=CRC(rrb, MB_Frame[MB_N], Sz);
    5bcc:	80 91 d9 04 	lds	r24, 0x04D9
    5bd0:	90 e0       	ldi	r25, 0x00	; 0
    5bd2:	03 2e       	mov	r0, r19
    5bd4:	02 c0       	rjmp	.+4      	; 0x5bda <CommErr+0x24>
    5bd6:	95 95       	asr	r25
    5bd8:	87 95       	ror	r24
    5bda:	0a 94       	dec	r0
    5bdc:	e2 f7       	brpl	.-8      	; 0x5bd6 <CommErr+0x20>
    5bde:	80 ff       	sbrs	r24, 0
    5be0:	29 c0       	rjmp	.+82     	; 0x5c34 <CommErr+0x7e>
	if (Err) {
		MB_CPT[MB_N][1]++;
    5be2:	fe 01       	movw	r30, r28
    5be4:	ee 0f       	add	r30, r30
    5be6:	ff 1f       	adc	r31, r31
    5be8:	ee 0f       	add	r30, r30
    5bea:	ff 1f       	adc	r31, r31
    5bec:	ee 0f       	add	r30, r30
    5bee:	ff 1f       	adc	r31, r31
    5bf0:	ee 0f       	add	r30, r30
    5bf2:	ff 1f       	adc	r31, r31
    5bf4:	e8 5c       	subi	r30, 0xC8	; 200
    5bf6:	f6 4f       	sbci	r31, 0xF6	; 246
    5bf8:	80 81       	ld	r24, Z
    5bfa:	91 81       	ldd	r25, Z+1	; 0x01
    5bfc:	01 96       	adiw	r24, 0x01	; 1
    5bfe:	91 83       	std	Z+1, r25	; 0x01
    5c00:	80 83       	st	Z, r24
    5c02:	ce 01       	movw	r24, r28
    5c04:	88 0f       	add	r24, r24
    5c06:	99 1f       	adc	r25, r25
    5c08:	88 0f       	add	r24, r24
    5c0a:	99 1f       	adc	r25, r25
    5c0c:	9c 01       	movw	r18, r24
    5c0e:	22 0f       	add	r18, r18
    5c10:	33 1f       	adc	r19, r19
    5c12:	22 0f       	add	r18, r18
    5c14:	33 1f       	adc	r19, r19
    5c16:	28 0f       	add	r18, r24
    5c18:	39 1f       	adc	r19, r25
    5c1a:	28 58       	subi	r18, 0x88	; 136
    5c1c:	3b 4c       	sbci	r19, 0xCB	; 203
    5c1e:	f9 01       	movw	r30, r18
    5c20:	85 91       	lpm	r24, Z+
    5c22:	94 91       	lpm	r25, Z+
		USART_Func(MB_N, LED_Err_On);
    5c24:	fc 01       	movw	r30, r24
    5c26:	19 95       	eicall
    5c28:	81 e0       	ldi	r24, 0x01	; 1
	else {
		MB_CPT[MB_N][0]++;
		USART_Func(MB_N, LED_Err_Off);
	}
	return Err;
}
    5c2a:	df 91       	pop	r29
    5c2c:	cf 91       	pop	r28
    5c2e:	1f 91       	pop	r17
    5c30:	0f 91       	pop	r16
    5c32:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~
uint8_t
CommErr(uint8_t MB_N)
{
	uint8_t Sz = MB_Frame_Sz[MB_N]-2;
	uint8_t Err = MB_Err &(1<<MB_N) || MB_Frame_Sz[MB_N]<3 || *(uint16_t*)(MB_Frame[MB_N]+Sz)!=CRC(rrb, MB_Frame[MB_N], Sz);
    5c34:	23 30       	cpi	r18, 0x03	; 3
    5c36:	a8 f2       	brcs	.-86     	; 0x5be2 <CommErr+0x2c>

// ~~~~~~~~~~~~~~~~~~
uint8_t
CommErr(uint8_t MB_N)
{
	uint8_t Sz = MB_Frame_Sz[MB_N]-2;
    5c38:	22 50       	subi	r18, 0x02	; 2
	uint8_t Err = MB_Err &(1<<MB_N) || MB_Frame_Sz[MB_N]<3 || *(uint16_t*)(MB_Frame[MB_N]+Sz)!=CRC(rrb, MB_Frame[MB_N], Sz);
    5c3a:	73 2f       	mov	r23, r19
    5c3c:	60 e0       	ldi	r22, 0x00	; 0
    5c3e:	fb 01       	movw	r30, r22
    5c40:	e2 0f       	add	r30, r18
    5c42:	f1 1d       	adc	r31, r1
    5c44:	e5 59       	subi	r30, 0x95	; 149
    5c46:	f4 4f       	sbci	r31, 0xF4	; 244
    5c48:	00 81       	ld	r16, Z
    5c4a:	11 81       	ldd	r17, Z+1	; 0x01
    5c4c:	65 59       	subi	r22, 0x95	; 149
    5c4e:	74 4f       	sbci	r23, 0xF4	; 244
    5c50:	30 e0       	ldi	r19, 0x00	; 0
    5c52:	40 e0       	ldi	r20, 0x00	; 0
    5c54:	50 e0       	ldi	r21, 0x00	; 0
    5c56:	8d e8       	ldi	r24, 0x8D	; 141
    5c58:	9c e1       	ldi	r25, 0x1C	; 28
    5c5a:	0e 94 00 1d 	call	0x3a00	; 0x3a00 <CRC>
    5c5e:	08 17       	cp	r16, r24
    5c60:	19 07       	cpc	r17, r25
    5c62:	09 f0       	breq	.+2      	; 0x5c66 <CommErr+0xb0>
    5c64:	be cf       	rjmp	.-132    	; 0x5be2 <CommErr+0x2c>
	if (Err) {
		MB_CPT[MB_N][1]++;
		USART_Func(MB_N, LED_Err_On);
	}
	else {
		MB_CPT[MB_N][0]++;
    5c66:	fe 01       	movw	r30, r28
    5c68:	e2 95       	swap	r30
    5c6a:	f2 95       	swap	r31
    5c6c:	f0 7f       	andi	r31, 0xF0	; 240
    5c6e:	fe 27       	eor	r31, r30
    5c70:	e0 7f       	andi	r30, 0xF0	; 240
    5c72:	fe 27       	eor	r31, r30
    5c74:	ea 5c       	subi	r30, 0xCA	; 202
    5c76:	f6 4f       	sbci	r31, 0xF6	; 246
    5c78:	80 81       	ld	r24, Z
    5c7a:	91 81       	ldd	r25, Z+1	; 0x01
    5c7c:	01 96       	adiw	r24, 0x01	; 1
    5c7e:	91 83       	std	Z+1, r25	; 0x01
    5c80:	80 83       	st	Z, r24
    5c82:	ce 01       	movw	r24, r28
    5c84:	88 0f       	add	r24, r24
    5c86:	99 1f       	adc	r25, r25
    5c88:	88 0f       	add	r24, r24
    5c8a:	99 1f       	adc	r25, r25
    5c8c:	9c 01       	movw	r18, r24
    5c8e:	22 0f       	add	r18, r18
    5c90:	33 1f       	adc	r19, r19
    5c92:	22 0f       	add	r18, r18
    5c94:	33 1f       	adc	r19, r19
    5c96:	28 0f       	add	r18, r24
    5c98:	39 1f       	adc	r19, r25
    5c9a:	26 58       	subi	r18, 0x86	; 134
    5c9c:	3b 4c       	sbci	r19, 0xCB	; 203
    5c9e:	f9 01       	movw	r30, r18
    5ca0:	85 91       	lpm	r24, Z+
    5ca2:	94 91       	lpm	r25, Z+
		USART_Func(MB_N, LED_Err_Off);
    5ca4:	fc 01       	movw	r30, r24
    5ca6:	19 95       	eicall
    5ca8:	80 e0       	ldi	r24, 0x00	; 0
    5caa:	bf cf       	rjmp	.-130    	; 0x5c2a <CommErr+0x74>

00005cac <SetCRC_MB>:
}

// ~~~~~~~~~~~~~~~~~~~~
void
SetCRC_MB(uint8_t MB_N)
{
    5cac:	df 92       	push	r13
    5cae:	ef 92       	push	r14
    5cb0:	ff 92       	push	r15
    5cb2:	0f 93       	push	r16
    5cb4:	1f 93       	push	r17
	uint8_t Sz = MB_Frame_Sz[MB_N]-2;
    5cb6:	e9 e4       	ldi	r30, 0x49	; 73
    5cb8:	f7 e0       	ldi	r31, 0x07	; 7
    5cba:	e8 0f       	add	r30, r24
    5cbc:	f1 1d       	adc	r31, r1
    5cbe:	d0 80       	ld	r13, Z
    5cc0:	9e ef       	ldi	r25, 0xFE	; 254
    5cc2:	d9 0e       	add	r13, r25
	*(uint16_t*)(MB_Frame[MB_N]+Sz) = CRC(rrb, MB_Frame[MB_N], Sz);
    5cc4:	18 2f       	mov	r17, r24
    5cc6:	00 e0       	ldi	r16, 0x00	; 0
    5cc8:	8b e6       	ldi	r24, 0x6B	; 107
    5cca:	e8 2e       	mov	r14, r24
    5ccc:	8b e0       	ldi	r24, 0x0B	; 11
    5cce:	f8 2e       	mov	r15, r24
    5cd0:	b7 01       	movw	r22, r14
    5cd2:	60 0f       	add	r22, r16
    5cd4:	71 1f       	adc	r23, r17
    5cd6:	2d 2d       	mov	r18, r13
    5cd8:	30 e0       	ldi	r19, 0x00	; 0
    5cda:	40 e0       	ldi	r20, 0x00	; 0
    5cdc:	50 e0       	ldi	r21, 0x00	; 0
    5cde:	8d e8       	ldi	r24, 0x8D	; 141
    5ce0:	9c e1       	ldi	r25, 0x1C	; 28
    5ce2:	0e 94 00 1d 	call	0x3a00	; 0x3a00 <CRC>
    5ce6:	0d 0d       	add	r16, r13
    5ce8:	11 1d       	adc	r17, r1
    5cea:	e0 0e       	add	r14, r16
    5cec:	f1 1e       	adc	r15, r17
    5cee:	f7 01       	movw	r30, r14
    5cf0:	91 83       	std	Z+1, r25	; 0x01
    5cf2:	80 83       	st	Z, r24
}
    5cf4:	1f 91       	pop	r17
    5cf6:	0f 91       	pop	r16
    5cf8:	ff 90       	pop	r15
    5cfa:	ef 90       	pop	r14
    5cfc:	df 90       	pop	r13
    5cfe:	08 95       	ret

00005d00 <MB_FrameReg>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
MB_FrameReg(uint8_t MB_N, uint8_t i)
{
	return MB_Frame[MB_N][i]<<8 | MB_Frame[MB_N][i+1];
    5d00:	70 e0       	ldi	r23, 0x00	; 0
    5d02:	ab e6       	ldi	r26, 0x6B	; 107
    5d04:	bb e0       	ldi	r27, 0x0B	; 11
    5d06:	f8 2f       	mov	r31, r24
    5d08:	e0 e0       	ldi	r30, 0x00	; 0
    5d0a:	ea 0f       	add	r30, r26
    5d0c:	fb 1f       	adc	r31, r27
    5d0e:	e6 0f       	add	r30, r22
    5d10:	f7 1f       	adc	r31, r23
    5d12:	41 81       	ldd	r20, Z+1	; 0x01
    5d14:	50 e0       	ldi	r21, 0x00	; 0
    5d16:	38 2f       	mov	r19, r24
    5d18:	20 e0       	ldi	r18, 0x00	; 0
    5d1a:	26 0f       	add	r18, r22
    5d1c:	37 1f       	adc	r19, r23
    5d1e:	a2 0f       	add	r26, r18
    5d20:	b3 1f       	adc	r27, r19
    5d22:	9c 91       	ld	r25, X
    5d24:	80 e0       	ldi	r24, 0x00	; 0
    5d26:	48 2b       	or	r20, r24
    5d28:	59 2b       	or	r21, r25
}
    5d2a:	ca 01       	movw	r24, r20
    5d2c:	08 95       	ret

00005d2e <MB_CPT_Clear>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~
void
MB_CPT_Clear(uint8_t MB_N)
{
    5d2e:	90 e0       	ldi	r25, 0x00	; 0
    5d30:	20 e0       	ldi	r18, 0x00	; 0
    5d32:	30 e0       	ldi	r19, 0x00	; 0
    5d34:	88 0f       	add	r24, r24
    5d36:	99 1f       	adc	r25, r25
    5d38:	88 0f       	add	r24, r24
    5d3a:	99 1f       	adc	r25, r25
    5d3c:	88 0f       	add	r24, r24
    5d3e:	99 1f       	adc	r25, r25
	for (uint8_t i=0; i<8; MB_CPT[MB_N][i++]=0);
    5d40:	fc 01       	movw	r30, r24
    5d42:	e2 0f       	add	r30, r18
    5d44:	f3 1f       	adc	r31, r19
    5d46:	ee 0f       	add	r30, r30
    5d48:	ff 1f       	adc	r31, r31
    5d4a:	ea 5c       	subi	r30, 0xCA	; 202
    5d4c:	f6 4f       	sbci	r31, 0xF6	; 246
    5d4e:	11 82       	std	Z+1, r1	; 0x01
    5d50:	10 82       	st	Z, r1
    5d52:	2f 5f       	subi	r18, 0xFF	; 255
    5d54:	3f 4f       	sbci	r19, 0xFF	; 255
    5d56:	28 30       	cpi	r18, 0x08	; 8
    5d58:	31 05       	cpc	r19, r1
    5d5a:	91 f7       	brne	.-28     	; 0x5d40 <MB_CPT_Clear+0x12>
}
    5d5c:	08 95       	ret

00005d5e <MB_S_Timer_ISR>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_S_Timer_ISR(uint8_t MB_N)
{
    5d5e:	2f 92       	push	r2
    5d60:	3f 92       	push	r3
    5d62:	4f 92       	push	r4
    5d64:	5f 92       	push	r5
    5d66:	6f 92       	push	r6
    5d68:	7f 92       	push	r7
    5d6a:	8f 92       	push	r8
    5d6c:	9f 92       	push	r9
    5d6e:	af 92       	push	r10
    5d70:	bf 92       	push	r11
    5d72:	cf 92       	push	r12
    5d74:	df 92       	push	r13
    5d76:	ef 92       	push	r14
    5d78:	ff 92       	push	r15
    5d7a:	0f 93       	push	r16
    5d7c:	1f 93       	push	r17
    5d7e:	df 93       	push	r29
    5d80:	cf 93       	push	r28
    5d82:	cd b7       	in	r28, 0x3d	; 61
    5d84:	de b7       	in	r29, 0x3e	; 62
    5d86:	29 97       	sbiw	r28, 0x09	; 9
    5d88:	0f b6       	in	r0, 0x3f	; 63
    5d8a:	f8 94       	cli
    5d8c:	de bf       	out	0x3e, r29	; 62
    5d8e:	0f be       	out	0x3f, r0	; 63
    5d90:	cd bf       	out	0x3d, r28	; 61
    5d92:	d8 2e       	mov	r13, r24
	switch (MB_State[MB_N]) {
    5d94:	28 2f       	mov	r18, r24
    5d96:	30 e0       	ldi	r19, 0x00	; 0
    5d98:	39 87       	std	Y+9, r19	; 0x09
    5d9a:	28 87       	std	Y+8, r18	; 0x08
    5d9c:	89 01       	movw	r16, r18
    5d9e:	0e 53       	subi	r16, 0x3E	; 62
    5da0:	1a 4f       	sbci	r17, 0xFA	; 250
    5da2:	d8 01       	movw	r26, r16
    5da4:	8c 91       	ld	r24, X
    5da6:	88 23       	and	r24, r24
    5da8:	b9 f1       	breq	.+110    	; 0x5e18 <MB_S_Timer_ISR+0xba>
    5daa:	82 30       	cpi	r24, 0x02	; 2
    5dac:	c9 f0       	breq	.+50     	; 0x5de0 <MB_S_Timer_ISR+0x82>
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
		MB_S_CtrlProc(MB_N);
		break;
	}
}
    5dae:	29 96       	adiw	r28, 0x09	; 9
    5db0:	0f b6       	in	r0, 0x3f	; 63
    5db2:	f8 94       	cli
    5db4:	de bf       	out	0x3e, r29	; 62
    5db6:	0f be       	out	0x3f, r0	; 63
    5db8:	cd bf       	out	0x3d, r28	; 61
    5dba:	cf 91       	pop	r28
    5dbc:	df 91       	pop	r29
    5dbe:	1f 91       	pop	r17
    5dc0:	0f 91       	pop	r16
    5dc2:	ff 90       	pop	r15
    5dc4:	ef 90       	pop	r14
    5dc6:	df 90       	pop	r13
    5dc8:	cf 90       	pop	r12
    5dca:	bf 90       	pop	r11
    5dcc:	af 90       	pop	r10
    5dce:	9f 90       	pop	r9
    5dd0:	8f 90       	pop	r8
    5dd2:	7f 90       	pop	r7
    5dd4:	6f 90       	pop	r6
    5dd6:	5f 90       	pop	r5
    5dd8:	4f 90       	pop	r4
    5dda:	3f 90       	pop	r3
    5ddc:	2f 90       	pop	r2
    5dde:	08 95       	ret
	switch (MB_State[MB_N]) {
	case MB_Initi:
		MB_State[MB_N] = MB_Idle;
		break;
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
    5de0:	84 e0       	ldi	r24, 0x04	; 4
    5de2:	d8 01       	movw	r26, r16
    5de4:	8c 93       	st	X, r24

// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
MB_S_CtrlProc(uint8_t MB_N)
{
	if (CommErr(MB_N)) {
    5de6:	8d 2d       	mov	r24, r13
    5de8:	0e 94 db 2d 	call	0x5bb6	; 0x5bb6 <CommErr>
    5dec:	88 23       	and	r24, r24
    5dee:	a1 f4       	brne	.+40     	; 0x5e18 <MB_S_Timer_ISR+0xba>
		MB_State[MB_N] = MB_Idle;
		return;
	}
	if (MB_Frame[MB_N][0]!=0 && MB_Frame[MB_N][0]!=MB_NativeAddr[MB_N]) {
    5df0:	28 85       	ldd	r18, Y+8	; 0x08
    5df2:	39 85       	ldd	r19, Y+9	; 0x09
    5df4:	f2 2e       	mov	r15, r18
    5df6:	ee 24       	eor	r14, r14
    5df8:	f7 01       	movw	r30, r14
    5dfa:	e5 59       	subi	r30, 0x95	; 149
    5dfc:	f4 4f       	sbci	r31, 0xF4	; 244
    5dfe:	90 81       	ld	r25, Z
    5e00:	99 23       	and	r25, r25
    5e02:	71 f0       	breq	.+28     	; 0x5e20 <MB_S_Timer_ISR+0xc2>
    5e04:	f9 01       	movw	r30, r18
    5e06:	e0 52       	subi	r30, 0x20	; 32
    5e08:	fa 4f       	sbci	r31, 0xFA	; 250
    5e0a:	80 81       	ld	r24, Z
    5e0c:	98 17       	cp	r25, r24
    5e0e:	41 f0       	breq	.+16     	; 0x5e20 <MB_S_Timer_ISR+0xc2>
		MB_State[MB_N] = MB_Idle;
    5e10:	81 e0       	ldi	r24, 0x01	; 1
    5e12:	d8 01       	movw	r26, r16
    5e14:	8c 93       	st	X, r24
    5e16:	cb cf       	rjmp	.-106    	; 0x5dae <MB_S_Timer_ISR+0x50>
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
MB_S_CtrlProc(uint8_t MB_N)
{
	if (CommErr(MB_N)) {
		MB_State[MB_N] = MB_Idle;
    5e18:	81 e0       	ldi	r24, 0x01	; 1
    5e1a:	f8 01       	movw	r30, r16
    5e1c:	80 83       	st	Z, r24
    5e1e:	c7 cf       	rjmp	.-114    	; 0x5dae <MB_S_Timer_ISR+0x50>
    5e20:	28 84       	ldd	r2, Y+8	; 0x08
    5e22:	39 84       	ldd	r3, Y+9	; 0x09
    5e24:	22 0c       	add	r2, r2
    5e26:	33 1c       	adc	r3, r3
    5e28:	22 0c       	add	r2, r2
    5e2a:	33 1c       	adc	r3, r3
    5e2c:	51 01       	movw	r10, r2
    5e2e:	aa 0c       	add	r10, r10
    5e30:	bb 1c       	adc	r11, r11
    5e32:	aa 0c       	add	r10, r10
    5e34:	bb 1c       	adc	r11, r11
    5e36:	a2 0c       	add	r10, r2
    5e38:	b3 1c       	adc	r11, r3
    5e3a:	e6 e7       	ldi	r30, 0x76	; 118
    5e3c:	f4 e3       	ldi	r31, 0x34	; 52
    5e3e:	ae 0e       	add	r10, r30
    5e40:	bf 1e       	adc	r11, r31
    5e42:	f5 01       	movw	r30, r10
    5e44:	25 91       	lpm	r18, Z+
    5e46:	34 91       	lpm	r19, Z+
	}
	if (MB_Frame[MB_N][0]!=0 && MB_Frame[MB_N][0]!=MB_NativeAddr[MB_N]) {
		MB_State[MB_N] = MB_Idle;
		return;
	}
	USART_Func(MB_N, LED);
    5e48:	f9 01       	movw	r30, r18
    5e4a:	19 95       	eicall
	MB_CPT[MB_N][3]++;
    5e4c:	68 84       	ldd	r6, Y+8	; 0x08
    5e4e:	79 84       	ldd	r7, Y+9	; 0x09
    5e50:	62 94       	swap	r6
    5e52:	72 94       	swap	r7
    5e54:	b0 ef       	ldi	r27, 0xF0	; 240
    5e56:	7b 22       	and	r7, r27
    5e58:	76 24       	eor	r7, r6
    5e5a:	6b 22       	and	r6, r27
    5e5c:	76 24       	eor	r7, r6
    5e5e:	f3 01       	movw	r30, r6
    5e60:	ea 5c       	subi	r30, 0xCA	; 202
    5e62:	f6 4f       	sbci	r31, 0xF6	; 246
    5e64:	86 81       	ldd	r24, Z+6	; 0x06
    5e66:	97 81       	ldd	r25, Z+7	; 0x07
    5e68:	01 96       	adiw	r24, 0x01	; 1
    5e6a:	97 83       	std	Z+7, r25	; 0x07
    5e6c:	86 83       	std	Z+6, r24	; 0x06

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
MB_FrameReg(uint8_t MB_N, uint8_t i)
{
	return MB_Frame[MB_N][i]<<8 | MB_Frame[MB_N][i+1];
    5e6e:	68 85       	ldd	r22, Y+8	; 0x08
    5e70:	79 85       	ldd	r23, Y+9	; 0x09
    5e72:	76 95       	lsr	r23
    5e74:	76 2f       	mov	r23, r22
    5e76:	66 27       	eor	r22, r22
    5e78:	77 95       	ror	r23
    5e7a:	67 95       	ror	r22
    5e7c:	db 01       	movw	r26, r22
    5e7e:	aa 0f       	add	r26, r26
    5e80:	bb 1f       	adc	r27, r27
    5e82:	a3 59       	subi	r26, 0x93	; 147
    5e84:	b4 4f       	sbci	r27, 0xF4	; 244
    5e86:	9c 91       	ld	r25, X
    5e88:	80 e0       	ldi	r24, 0x00	; 0
    5e8a:	a7 01       	movw	r20, r14
    5e8c:	45 59       	subi	r20, 0x95	; 149
    5e8e:	54 4f       	sbci	r21, 0xF4	; 244
    5e90:	fa 01       	movw	r30, r20
    5e92:	23 81       	ldd	r18, Z+3	; 0x03
    5e94:	82 2e       	mov	r8, r18
    5e96:	99 24       	eor	r9, r9
    5e98:	88 2a       	or	r8, r24
    5e9a:	99 2a       	or	r9, r25
inline static uint8_t
Process(uint8_t MB_N)
{
	uint8_t Err;
	uint16_t StartAddr = MB_FrameReg(MB_N, 2);
	switch (MB_Frame[MB_N][1]) {
    5e9c:	31 81       	ldd	r19, Z+1	; 0x01
    5e9e:	35 30       	cpi	r19, 0x05	; 5
    5ea0:	08 f0       	brcs	.+2      	; 0x5ea4 <MB_S_Timer_ISR+0x146>
    5ea2:	52 c0       	rjmp	.+164    	; 0x5f48 <MB_S_Timer_ISR+0x1ea>
    5ea4:	33 30       	cpi	r19, 0x03	; 3
    5ea6:	08 f4       	brcc	.+2      	; 0x5eaa <MB_S_Timer_ISR+0x14c>
    5ea8:	72 c0       	rjmp	.+228    	; 0x5f8e <MB_S_Timer_ISR+0x230>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_ReadReg(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame[MB_N][0]==0)
    5eaa:	fa 01       	movw	r30, r20
    5eac:	80 81       	ld	r24, Z
    5eae:	88 23       	and	r24, r24
    5eb0:	09 f4       	brne	.+2      	; 0x5eb4 <MB_S_Timer_ISR+0x156>
    5eb2:	5c c0       	rjmp	.+184    	; 0x5f6c <MB_S_Timer_ISR+0x20e>
		return 0xFF;
	if (MB_Frame_Sz[MB_N]!=8)
    5eb4:	29 e4       	ldi	r18, 0x49	; 73
    5eb6:	42 2e       	mov	r4, r18
    5eb8:	27 e0       	ldi	r18, 0x07	; 7
    5eba:	52 2e       	mov	r5, r18
    5ebc:	88 85       	ldd	r24, Y+8	; 0x08
    5ebe:	99 85       	ldd	r25, Y+9	; 0x09
    5ec0:	48 0e       	add	r4, r24
    5ec2:	59 1e       	adc	r5, r25
    5ec4:	f2 01       	movw	r30, r4
    5ec6:	80 81       	ld	r24, Z
    5ec8:	88 30       	cpi	r24, 0x08	; 8
    5eca:	09 f4       	brne	.+2      	; 0x5ece <MB_S_Timer_ISR+0x170>
    5ecc:	27 c2       	rjmp	.+1102   	; 0x631c <MB_S_Timer_ISR+0x5be>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_PresetSingle(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame_Sz[MB_N]!=8)
		return MB_Frame[MB_N][2]=IllegData;
    5ece:	83 e0       	ldi	r24, 0x03	; 3
    5ed0:	8c 93       	st	X, r24
    5ed2:	93 e0       	ldi	r25, 0x03	; 3
		break;
	default:
		Err = MB_Frame[MB_N][2] = IllegFunc;
		break;
	}
	if (MB_Frame[MB_N][0]) {
    5ed4:	f7 01       	movw	r30, r14
    5ed6:	e5 59       	subi	r30, 0x95	; 149
    5ed8:	f4 4f       	sbci	r31, 0xF4	; 244
    5eda:	80 81       	ld	r24, Z
    5edc:	88 23       	and	r24, r24
    5ede:	81 f0       	breq	.+32     	; 0x5f00 <MB_S_Timer_ISR+0x1a2>
		if (Err) {
    5ee0:	99 23       	and	r25, r25
    5ee2:	49 f0       	breq	.+18     	; 0x5ef6 <MB_S_Timer_ISR+0x198>
			MB_Frame[MB_N][1] |=(1<<7);
    5ee4:	81 81       	ldd	r24, Z+1	; 0x01
    5ee6:	80 68       	ori	r24, 0x80	; 128
    5ee8:	81 83       	std	Z+1, r24	; 0x01
			MB_Frame_Sz[MB_N] = 5;
    5eea:	e8 85       	ldd	r30, Y+8	; 0x08
    5eec:	f9 85       	ldd	r31, Y+9	; 0x09
    5eee:	e7 5b       	subi	r30, 0xB7	; 183
    5ef0:	f8 4f       	sbci	r31, 0xF8	; 248
    5ef2:	85 e0       	ldi	r24, 0x05	; 5
    5ef4:	80 83       	st	Z, r24
		}
		SetCRC_MB(MB_N);
    5ef6:	8d 2d       	mov	r24, r13
    5ef8:	9d 83       	std	Y+5, r25	; 0x05
    5efa:	0e 94 56 2e 	call	0x5cac	; 0x5cac <SetCRC_MB>
    5efe:	9d 81       	ldd	r25, Y+5	; 0x05
		MB_State[MB_N] = MB_Idle;
		return;
	}
	USART_Func(MB_N, LED);
	MB_CPT[MB_N][3]++;
	if (Process(MB_N))
    5f00:	99 23       	and	r25, r25
    5f02:	a1 f5       	brne	.+104    	; 0x5f6c <MB_S_Timer_ISR+0x20e>
		MB_CPT[MB_N][2]++;
	if (MB_Frame[MB_N][0])
    5f04:	2b e6       	ldi	r18, 0x6B	; 107
    5f06:	3b e0       	ldi	r19, 0x0B	; 11
    5f08:	e2 0e       	add	r14, r18
    5f0a:	f3 1e       	adc	r15, r19
    5f0c:	d7 01       	movw	r26, r14
    5f0e:	8c 91       	ld	r24, X
    5f10:	88 23       	and	r24, r24
    5f12:	c9 f5       	brne	.+114    	; 0x5f86 <MB_S_Timer_ISR+0x228>
		MB_Transm(MB_N);
	else {
		MB_CPT[MB_N][4]++;
    5f14:	e8 85       	ldd	r30, Y+8	; 0x08
    5f16:	f9 85       	ldd	r31, Y+9	; 0x09
    5f18:	ee 0f       	add	r30, r30
    5f1a:	ff 1f       	adc	r31, r31
    5f1c:	ee 0f       	add	r30, r30
    5f1e:	ff 1f       	adc	r31, r31
    5f20:	ee 0f       	add	r30, r30
    5f22:	ff 1f       	adc	r31, r31
    5f24:	ee 0f       	add	r30, r30
    5f26:	ff 1f       	adc	r31, r31
    5f28:	e2 5c       	subi	r30, 0xC2	; 194
    5f2a:	f6 4f       	sbci	r31, 0xF6	; 246
    5f2c:	80 81       	ld	r24, Z
    5f2e:	91 81       	ldd	r25, Z+1	; 0x01
    5f30:	01 96       	adiw	r24, 0x01	; 1
    5f32:	91 83       	std	Z+1, r25	; 0x01
    5f34:	80 83       	st	Z, r24
		MB_State[MB_N] = MB_Idle;
    5f36:	81 e0       	ldi	r24, 0x01	; 1
    5f38:	f8 01       	movw	r30, r16
    5f3a:	80 83       	st	Z, r24
    5f3c:	f5 01       	movw	r30, r10
    5f3e:	85 91       	lpm	r24, Z+
    5f40:	94 91       	lpm	r25, Z+
		USART_Func(MB_N, LED);
    5f42:	fc 01       	movw	r30, r24
    5f44:	19 95       	eicall
    5f46:	33 cf       	rjmp	.-410    	; 0x5dae <MB_S_Timer_ISR+0x50>
inline static uint8_t
Process(uint8_t MB_N)
{
	uint8_t Err;
	uint16_t StartAddr = MB_FrameReg(MB_N, 2);
	switch (MB_Frame[MB_N][1]) {
    5f48:	3f 30       	cpi	r19, 0x0F	; 15
    5f4a:	09 f4       	brne	.+2      	; 0x5f4e <MB_S_Timer_ISR+0x1f0>
    5f4c:	1e c1       	rjmp	.+572    	; 0x618a <MB_S_Timer_ISR+0x42c>
    5f4e:	30 31       	cpi	r19, 0x10	; 16
    5f50:	09 f4       	brne	.+2      	; 0x5f54 <MB_S_Timer_ISR+0x1f6>
    5f52:	fc c0       	rjmp	.+504    	; 0x614c <MB_S_Timer_ISR+0x3ee>
    5f54:	36 30       	cpi	r19, 0x06	; 6
    5f56:	09 f4       	brne	.+2      	; 0x5f5a <MB_S_Timer_ISR+0x1fc>
    5f58:	bd c0       	rjmp	.+378    	; 0x60d4 <MB_S_Timer_ISR+0x376>
		break;
	case 0x10:
		Err = MB_S_Preset(MB_N, StartAddr);
		break;
	default:
		Err = MB_Frame[MB_N][2] = IllegFunc;
    5f5a:	66 0f       	add	r22, r22
    5f5c:	77 1f       	adc	r23, r23
    5f5e:	63 59       	subi	r22, 0x93	; 147
    5f60:	74 4f       	sbci	r23, 0xF4	; 244
    5f62:	81 e0       	ldi	r24, 0x01	; 1
    5f64:	fb 01       	movw	r30, r22
    5f66:	80 83       	st	Z, r24
    5f68:	91 e0       	ldi	r25, 0x01	; 1
    5f6a:	b4 cf       	rjmp	.-152    	; 0x5ed4 <MB_S_Timer_ISR+0x176>
		return;
	}
	USART_Func(MB_N, LED);
	MB_CPT[MB_N][3]++;
	if (Process(MB_N))
		MB_CPT[MB_N][2]++;
    5f6c:	f1 01       	movw	r30, r2
    5f6e:	ee 0f       	add	r30, r30
    5f70:	ff 1f       	adc	r31, r31
    5f72:	ee 0f       	add	r30, r30
    5f74:	ff 1f       	adc	r31, r31
    5f76:	e6 5c       	subi	r30, 0xC6	; 198
    5f78:	f6 4f       	sbci	r31, 0xF6	; 246
    5f7a:	80 81       	ld	r24, Z
    5f7c:	91 81       	ldd	r25, Z+1	; 0x01
    5f7e:	01 96       	adiw	r24, 0x01	; 1
    5f80:	91 83       	std	Z+1, r25	; 0x01
    5f82:	80 83       	st	Z, r24
    5f84:	bf cf       	rjmp	.-130    	; 0x5f04 <MB_S_Timer_ISR+0x1a6>
	if (MB_Frame[MB_N][0])
		MB_Transm(MB_N);
    5f86:	8d 2d       	mov	r24, r13
    5f88:	0e 94 f7 2c 	call	0x59ee	; 0x59ee <MB_Transm>
    5f8c:	10 cf       	rjmp	.-480    	; 0x5dae <MB_S_Timer_ISR+0x50>
inline static uint8_t
Process(uint8_t MB_N)
{
	uint8_t Err;
	uint16_t StartAddr = MB_FrameReg(MB_N, 2);
	switch (MB_Frame[MB_N][1]) {
    5f8e:	31 30       	cpi	r19, 0x01	; 1
    5f90:	20 f3       	brcs	.-56     	; 0x5f5a <MB_S_Timer_ISR+0x1fc>
*/
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_ReadDiscr(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame[MB_N][0]==0)
    5f92:	fa 01       	movw	r30, r20
    5f94:	80 81       	ld	r24, Z
    5f96:	88 23       	and	r24, r24
    5f98:	49 f3       	breq	.-46     	; 0x5f6c <MB_S_Timer_ISR+0x20e>
		return 0xFF;
	if (MB_Frame_Sz[MB_N]!=8)
    5f9a:	e9 e4       	ldi	r30, 0x49	; 73
    5f9c:	4e 2e       	mov	r4, r30
    5f9e:	e7 e0       	ldi	r30, 0x07	; 7
    5fa0:	5e 2e       	mov	r5, r30
    5fa2:	88 85       	ldd	r24, Y+8	; 0x08
    5fa4:	99 85       	ldd	r25, Y+9	; 0x09
    5fa6:	48 0e       	add	r4, r24
    5fa8:	59 1e       	adc	r5, r25
    5faa:	f2 01       	movw	r30, r4
    5fac:	80 81       	ld	r24, Z
    5fae:	88 30       	cpi	r24, 0x08	; 8
    5fb0:	09 f0       	breq	.+2      	; 0x5fb4 <MB_S_Timer_ISR+0x256>
    5fb2:	8d cf       	rjmp	.-230    	; 0x5ece <MB_S_Timer_ISR+0x170>
    5fb4:	88 85       	ldd	r24, Y+8	; 0x08
    5fb6:	99 85       	ldd	r25, Y+9	; 0x09
    5fb8:	f8 2f       	mov	r31, r24
    5fba:	ee 27       	eor	r30, r30
    5fbc:	e1 59       	subi	r30, 0x91	; 145
    5fbe:	f4 4f       	sbci	r31, 0xF4	; 244
    5fc0:	90 81       	ld	r25, Z
    5fc2:	80 e0       	ldi	r24, 0x00	; 0
    5fc4:	da 01       	movw	r26, r20
    5fc6:	15 96       	adiw	r26, 0x05	; 5
    5fc8:	2c 91       	ld	r18, X
    5fca:	a2 2f       	mov	r26, r18
    5fcc:	b0 e0       	ldi	r27, 0x00	; 0
    5fce:	a8 2b       	or	r26, r24
    5fd0:	b9 2b       	or	r27, r25
		return MB_Frame[MB_N][2]=IllegData;
	uint16_t Qt = MB_FrameReg(MB_N, 4);
	if (StartAddr+Qt>(MB_Frame[MB_N][1]==1?prw(&Modbus_Map[MB_N].Coil_Qt):prw(&Modbus_Map[MB_N].Input_Qt)))
    5fd2:	31 30       	cpi	r19, 0x01	; 1
    5fd4:	09 f4       	brne	.+2      	; 0x5fd8 <MB_S_Timer_ISR+0x27a>
    5fd6:	44 c2       	rjmp	.+1160   	; 0x6460 <MB_S_Timer_ISR+0x702>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    5fd8:	f3 01       	movw	r30, r6
    5fda:	ea 5c       	subi	r30, 0xCA	; 202
    5fdc:	fc 4f       	sbci	r31, 0xFC	; 252
    5fde:	45 91       	lpm	r20, Z+
    5fe0:	54 91       	lpm	r21, Z+
    5fe2:	cd 01       	movw	r24, r26
    5fe4:	88 0d       	add	r24, r8
    5fe6:	99 1d       	adc	r25, r9
    5fe8:	48 17       	cp	r20, r24
    5fea:	59 07       	cpc	r21, r25
    5fec:	08 f4       	brcc	.+2      	; 0x5ff0 <MB_S_Timer_ISR+0x292>
    5fee:	8d c1       	rjmp	.+794    	; 0x630a <MB_S_Timer_ISR+0x5ac>
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
    5ff0:	31 30       	cpi	r19, 0x01	; 1
    5ff2:	09 f4       	brne	.+2      	; 0x5ff6 <MB_S_Timer_ISR+0x298>
    5ff4:	4a c2       	rjmp	.+1172   	; 0x648a <MB_S_Timer_ISR+0x72c>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5ff6:	f1 01       	movw	r30, r2
    5ff8:	ee 0f       	add	r30, r30
    5ffa:	ff 1f       	adc	r31, r31
    5ffc:	ee 0f       	add	r30, r30
    5ffe:	ff 1f       	adc	r31, r31
    6000:	ec 5c       	subi	r30, 0xCC	; 204
    6002:	fc 4f       	sbci	r31, 0xFC	; 252
    6004:	85 91       	lpm	r24, Z+
    6006:	94 91       	lpm	r25, Z+
    6008:	28 2f       	mov	r18, r24
    600a:	89 2f       	mov	r24, r25
    600c:	62 2e       	mov	r6, r18
    600e:	78 2e       	mov	r7, r24
	MB_Frame[MB_N][2] = Qt/8+(Qt%8>0);
    6010:	20 e0       	ldi	r18, 0x00	; 0
    6012:	cd 01       	movw	r24, r26
    6014:	87 70       	andi	r24, 0x07	; 7
    6016:	90 70       	andi	r25, 0x00	; 0
    6018:	89 2b       	or	r24, r25
    601a:	09 f0       	breq	.+2      	; 0x601e <MB_S_Timer_ISR+0x2c0>
    601c:	21 e0       	ldi	r18, 0x01	; 1
    601e:	cd 01       	movw	r24, r26
    6020:	96 95       	lsr	r25
    6022:	87 95       	ror	r24
    6024:	96 95       	lsr	r25
    6026:	87 95       	ror	r24
    6028:	96 95       	lsr	r25
    602a:	87 95       	ror	r24
    602c:	82 0f       	add	r24, r18
    602e:	66 0f       	add	r22, r22
    6030:	77 1f       	adc	r23, r23
    6032:	63 59       	subi	r22, 0x93	; 147
    6034:	74 4f       	sbci	r23, 0xF4	; 244
    6036:	fb 01       	movw	r30, r22
    6038:	80 83       	st	Z, r24
	MB_Frame_Sz[MB_N] = MB_Frame[MB_N][2]+5;
    603a:	8b 5f       	subi	r24, 0xFB	; 251
    603c:	f2 01       	movw	r30, r4
    603e:	80 83       	st	Z, r24
	for (uint8_t i=0; i<Qt; i++) {
    6040:	10 97       	sbiw	r26, 0x00	; 0
    6042:	09 f4       	brne	.+2      	; 0x6046 <MB_S_Timer_ISR+0x2e8>
    6044:	22 c1       	rjmp	.+580    	; 0x628a <MB_S_Timer_ISR+0x52c>
    6046:	60 e0       	ldi	r22, 0x00	; 0
    6048:	20 e0       	ldi	r18, 0x00	; 0
    604a:	30 e0       	ldi	r19, 0x00	; 0
    604c:	80 e0       	ldi	r24, 0x00	; 0
    604e:	90 e0       	ldi	r25, 0x00	; 0
		uint16_t j = StartAddr+i;
		uint8_t Byte=3+i/8, Bit=1<<i%8;
    6050:	e1 e0       	ldi	r30, 0x01	; 1
    6052:	4e 2e       	mov	r4, r30
    6054:	51 2c       	mov	r5, r1
    6056:	10 c0       	rjmp	.+32     	; 0x6078 <MB_S_Timer_ISR+0x31a>
		if (Discr[j/8] &(1<<j%8))
			MB_Frame[MB_N][Byte] |=Bit;
    6058:	f7 01       	movw	r30, r14
    605a:	e4 0f       	add	r30, r20
    605c:	f1 1d       	adc	r31, r1
    605e:	e5 59       	subi	r30, 0x95	; 149
    6060:	f4 4f       	sbci	r31, 0xF4	; 244
    6062:	80 81       	ld	r24, Z
    6064:	85 2b       	or	r24, r21
    6066:	80 83       	st	Z, r24
	if (StartAddr+Qt>(MB_Frame[MB_N][1]==1?prw(&Modbus_Map[MB_N].Coil_Qt):prw(&Modbus_Map[MB_N].Input_Qt)))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
	MB_Frame[MB_N][2] = Qt/8+(Qt%8>0);
	MB_Frame_Sz[MB_N] = MB_Frame[MB_N][2]+5;
	for (uint8_t i=0; i<Qt; i++) {
    6068:	6f 5f       	subi	r22, 0xFF	; 255
    606a:	86 2f       	mov	r24, r22
    606c:	90 e0       	ldi	r25, 0x00	; 0
    606e:	9c 01       	movw	r18, r24
    6070:	8a 17       	cp	r24, r26
    6072:	9b 07       	cpc	r25, r27
    6074:	08 f0       	brcs	.+2      	; 0x6078 <MB_S_Timer_ISR+0x31a>
    6076:	09 c1       	rjmp	.+530    	; 0x628a <MB_S_Timer_ISR+0x52c>
		uint16_t j = StartAddr+i;
    6078:	28 0d       	add	r18, r8
    607a:	39 1d       	adc	r19, r9
		uint8_t Byte=3+i/8, Bit=1<<i%8;
    607c:	46 2f       	mov	r20, r22
    607e:	46 95       	lsr	r20
    6080:	46 95       	lsr	r20
    6082:	46 95       	lsr	r20
    6084:	4d 5f       	subi	r20, 0xFD	; 253
    6086:	87 70       	andi	r24, 0x07	; 7
    6088:	90 70       	andi	r25, 0x00	; 0
    608a:	f2 01       	movw	r30, r4
    608c:	02 c0       	rjmp	.+4      	; 0x6092 <MB_S_Timer_ISR+0x334>
    608e:	ee 0f       	add	r30, r30
    6090:	ff 1f       	adc	r31, r31
    6092:	8a 95       	dec	r24
    6094:	e2 f7       	brpl	.-8      	; 0x608e <MB_S_Timer_ISR+0x330>
    6096:	5e 2f       	mov	r21, r30
		if (Discr[j/8] &(1<<j%8))
    6098:	f9 01       	movw	r30, r18
    609a:	f6 95       	lsr	r31
    609c:	e7 95       	ror	r30
    609e:	f6 95       	lsr	r31
    60a0:	e7 95       	ror	r30
    60a2:	f6 95       	lsr	r31
    60a4:	e7 95       	ror	r30
    60a6:	e6 0d       	add	r30, r6
    60a8:	f7 1d       	adc	r31, r7
    60aa:	80 81       	ld	r24, Z
    60ac:	90 e0       	ldi	r25, 0x00	; 0
    60ae:	27 70       	andi	r18, 0x07	; 7
    60b0:	30 70       	andi	r19, 0x00	; 0
    60b2:	02 c0       	rjmp	.+4      	; 0x60b8 <MB_S_Timer_ISR+0x35a>
    60b4:	95 95       	asr	r25
    60b6:	87 95       	ror	r24
    60b8:	2a 95       	dec	r18
    60ba:	e2 f7       	brpl	.-8      	; 0x60b4 <MB_S_Timer_ISR+0x356>
    60bc:	80 fd       	sbrc	r24, 0
    60be:	cc cf       	rjmp	.-104    	; 0x6058 <MB_S_Timer_ISR+0x2fa>
			MB_Frame[MB_N][Byte] |=Bit;
		else
			MB_Frame[MB_N][Byte] &=~Bit;
    60c0:	f7 01       	movw	r30, r14
    60c2:	e4 0f       	add	r30, r20
    60c4:	f1 1d       	adc	r31, r1
    60c6:	e5 59       	subi	r30, 0x95	; 149
    60c8:	f4 4f       	sbci	r31, 0xF4	; 244
    60ca:	50 95       	com	r21
    60cc:	80 81       	ld	r24, Z
    60ce:	58 23       	and	r21, r24
    60d0:	50 83       	st	Z, r21
    60d2:	ca cf       	rjmp	.-108    	; 0x6068 <MB_S_Timer_ISR+0x30a>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_PresetSingle(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame_Sz[MB_N]!=8)
    60d4:	68 85       	ldd	r22, Y+8	; 0x08
    60d6:	79 85       	ldd	r23, Y+9	; 0x09
    60d8:	67 5b       	subi	r22, 0xB7	; 183
    60da:	78 4f       	sbci	r23, 0xF8	; 248
    60dc:	fb 01       	movw	r30, r22
    60de:	c0 80       	ld	r12, Z
    60e0:	f8 e0       	ldi	r31, 0x08	; 8
    60e2:	cf 16       	cp	r12, r31
    60e4:	09 f0       	breq	.+2      	; 0x60e8 <MB_S_Timer_ISR+0x38a>
    60e6:	f3 ce       	rjmp	.-538    	; 0x5ece <MB_S_Timer_ISR+0x170>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    60e8:	f3 01       	movw	r30, r6
    60ea:	e6 5c       	subi	r30, 0xC6	; 198
    60ec:	fc 4f       	sbci	r31, 0xFC	; 252
    60ee:	25 91       	lpm	r18, Z+
    60f0:	34 91       	lpm	r19, Z+
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+1>prw(&Modbus_Map[MB_N].HoldReg_Qt))
    60f2:	c4 01       	movw	r24, r8
    60f4:	01 96       	adiw	r24, 0x01	; 1
    60f6:	28 17       	cp	r18, r24
    60f8:	39 07       	cpc	r19, r25
    60fa:	08 f4       	brcc	.+2      	; 0x60fe <MB_S_Timer_ISR+0x3a0>
    60fc:	02 c1       	rjmp	.+516    	; 0x6302 <MB_S_Timer_ISR+0x5a4>
		return MB_Frame[MB_N][2]=IllegAddr;
	MB_Frame_Sz[MB_N] = 8;
    60fe:	db 01       	movw	r26, r22
    6100:	cc 92       	st	X, r12

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6102:	e8 85       	ldd	r30, Y+8	; 0x08
    6104:	f9 85       	ldd	r31, Y+9	; 0x09
    6106:	ee 0f       	add	r30, r30
    6108:	ff 1f       	adc	r31, r31
    610a:	ee 0f       	add	r30, r30
    610c:	ff 1f       	adc	r31, r31
    610e:	ee 0f       	add	r30, r30
    6110:	ff 1f       	adc	r31, r31
    6112:	ee 0f       	add	r30, r30
    6114:	ff 1f       	adc	r31, r31
    6116:	e8 5c       	subi	r30, 0xC8	; 200
    6118:	fc 4f       	sbci	r31, 0xFC	; 252
    611a:	85 91       	lpm	r24, Z+
    611c:	94 91       	lpm	r25, Z+
	*((uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+StartAddr) = MB_FrameReg(MB_N, 4);
    611e:	88 0c       	add	r8, r8
    6120:	99 1c       	adc	r9, r9
    6122:	88 0e       	add	r8, r24
    6124:	99 1e       	adc	r9, r25
    6126:	28 85       	ldd	r18, Y+8	; 0x08
    6128:	39 85       	ldd	r19, Y+9	; 0x09
    612a:	f2 2f       	mov	r31, r18
    612c:	ee 27       	eor	r30, r30
    612e:	e1 59       	subi	r30, 0x91	; 145
    6130:	f4 4f       	sbci	r31, 0xF4	; 244
    6132:	90 81       	ld	r25, Z
    6134:	80 e0       	ldi	r24, 0x00	; 0
    6136:	da 01       	movw	r26, r20
    6138:	15 96       	adiw	r26, 0x05	; 5
    613a:	2c 91       	ld	r18, X
    613c:	30 e0       	ldi	r19, 0x00	; 0
    613e:	82 2b       	or	r24, r18
    6140:	93 2b       	or	r25, r19
    6142:	f4 01       	movw	r30, r8
    6144:	91 83       	std	Z+1, r25	; 0x01
    6146:	80 83       	st	Z, r24
    6148:	90 e0       	ldi	r25, 0x00	; 0
    614a:	c4 ce       	rjmp	.-632    	; 0x5ed4 <MB_S_Timer_ISR+0x176>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_Preset(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][6]+9 || MB_Frame[MB_N][5]*2!=MB_Frame[MB_N][6])
    614c:	fa 01       	movw	r30, r20
    614e:	86 81       	ldd	r24, Z+6	; 0x06
    6150:	28 2f       	mov	r18, r24
    6152:	30 e0       	ldi	r19, 0x00	; 0
    6154:	3f 83       	std	Y+7, r19	; 0x07
    6156:	2e 83       	std	Y+6, r18	; 0x06
    6158:	89 e4       	ldi	r24, 0x49	; 73
    615a:	48 2e       	mov	r4, r24
    615c:	87 e0       	ldi	r24, 0x07	; 7
    615e:	58 2e       	mov	r5, r24
    6160:	88 85       	ldd	r24, Y+8	; 0x08
    6162:	99 85       	ldd	r25, Y+9	; 0x09
    6164:	48 0e       	add	r4, r24
    6166:	59 1e       	adc	r5, r25
    6168:	f2 01       	movw	r30, r4
    616a:	80 81       	ld	r24, Z
    616c:	90 e0       	ldi	r25, 0x00	; 0
    616e:	27 5f       	subi	r18, 0xF7	; 247
    6170:	3f 4f       	sbci	r19, 0xFF	; 255
    6172:	82 17       	cp	r24, r18
    6174:	93 07       	cpc	r25, r19
    6176:	99 f1       	breq	.+102    	; 0x61de <MB_S_Timer_ISR+0x480>
		return MB_Frame[MB_N][2]=IllegData;
    6178:	66 0f       	add	r22, r22
    617a:	77 1f       	adc	r23, r23
    617c:	63 59       	subi	r22, 0x93	; 147
    617e:	74 4f       	sbci	r23, 0xF4	; 244
    6180:	83 e0       	ldi	r24, 0x03	; 3
    6182:	db 01       	movw	r26, r22
    6184:	8c 93       	st	X, r24
    6186:	93 e0       	ldi	r25, 0x03	; 3
    6188:	a5 ce       	rjmp	.-694    	; 0x5ed4 <MB_S_Timer_ISR+0x176>
    618a:	28 85       	ldd	r18, Y+8	; 0x08
    618c:	39 85       	ldd	r19, Y+9	; 0x09
    618e:	f2 2f       	mov	r31, r18
    6190:	ee 27       	eor	r30, r30
    6192:	e1 59       	subi	r30, 0x91	; 145
    6194:	f4 4f       	sbci	r31, 0xF4	; 244
    6196:	e0 81       	ld	r30, Z
    6198:	da 01       	movw	r26, r20
    619a:	15 96       	adiw	r26, 0x05	; 5
    619c:	fc 91       	ld	r31, X
    619e:	15 97       	sbiw	r26, 0x05	; 5
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_Force(uint8_t MB_N, uint16_t StartAddr)
{
	uint16_t Qt = MB_FrameReg(MB_N, 4);
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][6]+9 || Qt/8+(Qt%8>0)!=MB_Frame[MB_N][6])
    61a0:	16 96       	adiw	r26, 0x06	; 6
    61a2:	2c 91       	ld	r18, X
    61a4:	a9 e4       	ldi	r26, 0x49	; 73
    61a6:	4a 2e       	mov	r4, r26
    61a8:	a7 e0       	ldi	r26, 0x07	; 7
    61aa:	5a 2e       	mov	r5, r26
    61ac:	88 85       	ldd	r24, Y+8	; 0x08
    61ae:	99 85       	ldd	r25, Y+9	; 0x09
    61b0:	48 0e       	add	r4, r24
    61b2:	59 1e       	adc	r5, r25
    61b4:	d2 01       	movw	r26, r4
    61b6:	8c 91       	ld	r24, X
    61b8:	90 e0       	ldi	r25, 0x00	; 0
    61ba:	42 2f       	mov	r20, r18
    61bc:	50 e0       	ldi	r21, 0x00	; 0
    61be:	9a 01       	movw	r18, r20
    61c0:	27 5f       	subi	r18, 0xF7	; 247
    61c2:	3f 4f       	sbci	r19, 0xFF	; 255
    61c4:	82 17       	cp	r24, r18
    61c6:	93 07       	cpc	r25, r19
    61c8:	09 f4       	brne	.+2      	; 0x61cc <MB_S_Timer_ISR+0x46e>
    61ca:	61 c0       	rjmp	.+194    	; 0x628e <MB_S_Timer_ISR+0x530>
		return MB_Frame[MB_N][2]=IllegData;
    61cc:	66 0f       	add	r22, r22
    61ce:	77 1f       	adc	r23, r23
    61d0:	63 59       	subi	r22, 0x93	; 147
    61d2:	74 4f       	sbci	r23, 0xF4	; 244
    61d4:	83 e0       	ldi	r24, 0x03	; 3
    61d6:	fb 01       	movw	r30, r22
    61d8:	80 83       	st	Z, r24
    61da:	93 e0       	ldi	r25, 0x03	; 3
    61dc:	7b ce       	rjmp	.-778    	; 0x5ed4 <MB_S_Timer_ISR+0x176>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_Preset(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][6]+9 || MB_Frame[MB_N][5]*2!=MB_Frame[MB_N][6])
    61de:	9a 01       	movw	r18, r20
    61e0:	2b 5f       	subi	r18, 0xFB	; 251
    61e2:	3f 4f       	sbci	r19, 0xFF	; 255
    61e4:	3c 83       	std	Y+4, r19	; 0x04
    61e6:	2b 83       	std	Y+3, r18	; 0x03
    61e8:	fa 01       	movw	r30, r20
    61ea:	c5 80       	ldd	r12, Z+5	; 0x05
    61ec:	2c 2d       	mov	r18, r12
    61ee:	30 e0       	ldi	r19, 0x00	; 0
    61f0:	c9 01       	movw	r24, r18
    61f2:	88 0f       	add	r24, r24
    61f4:	99 1f       	adc	r25, r25
    61f6:	ee 81       	ldd	r30, Y+6	; 0x06
    61f8:	ff 81       	ldd	r31, Y+7	; 0x07
    61fa:	e8 17       	cp	r30, r24
    61fc:	f9 07       	cpc	r31, r25
    61fe:	09 f0       	breq	.+2      	; 0x6202 <MB_S_Timer_ISR+0x4a4>
    6200:	bb cf       	rjmp	.-138    	; 0x6178 <MB_S_Timer_ISR+0x41a>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    6202:	f3 01       	movw	r30, r6
    6204:	e6 5c       	subi	r30, 0xC6	; 198
    6206:	fc 4f       	sbci	r31, 0xFC	; 252
    6208:	85 91       	lpm	r24, Z+
    620a:	94 91       	lpm	r25, Z+
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+MB_Frame[MB_N][5]>prw(&Modbus_Map[MB_N].HoldReg_Qt))
    620c:	28 0d       	add	r18, r8
    620e:	39 1d       	adc	r19, r9
    6210:	82 17       	cp	r24, r18
    6212:	93 07       	cpc	r25, r19
    6214:	08 f4       	brcc	.+2      	; 0x6218 <MB_S_Timer_ISR+0x4ba>
    6216:	75 c0       	rjmp	.+234    	; 0x6302 <MB_S_Timer_ISR+0x5a4>
		return MB_Frame[MB_N][2]=IllegAddr;
	MB_Frame_Sz[MB_N] = 8;
    6218:	88 e0       	ldi	r24, 0x08	; 8
    621a:	f2 01       	movw	r30, r4
    621c:	80 83       	st	Z, r24

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    621e:	e8 85       	ldd	r30, Y+8	; 0x08
    6220:	f9 85       	ldd	r31, Y+9	; 0x09
    6222:	ee 0f       	add	r30, r30
    6224:	ff 1f       	adc	r31, r31
    6226:	ee 0f       	add	r30, r30
    6228:	ff 1f       	adc	r31, r31
    622a:	ee 0f       	add	r30, r30
    622c:	ff 1f       	adc	r31, r31
    622e:	ee 0f       	add	r30, r30
    6230:	ff 1f       	adc	r31, r31
    6232:	e8 5c       	subi	r30, 0xC8	; 200
    6234:	fc 4f       	sbci	r31, 0xFC	; 252
    6236:	45 90       	lpm	r4, Z+
    6238:	54 90       	lpm	r5, Z+
	uint16_t *HoldReg = prp(&Modbus_Map[MB_N].HoldReg);
	for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    623a:	cc 20       	and	r12, r12
    623c:	31 f1       	breq	.+76     	; 0x628a <MB_S_Timer_ISR+0x52c>
    623e:	60 e0       	ldi	r22, 0x00	; 0
    6240:	6b 80       	ldd	r6, Y+3	; 0x03
    6242:	7c 80       	ldd	r7, Y+4	; 0x04
    6244:	a6 2f       	mov	r26, r22
    6246:	b0 e0       	ldi	r27, 0x00	; 0
    6248:	cd 01       	movw	r24, r26
    624a:	88 0f       	add	r24, r24
    624c:	99 1f       	adc	r25, r25
    624e:	89 5f       	subi	r24, 0xF9	; 249
    6250:	28 2f       	mov	r18, r24
    6252:	30 e0       	ldi	r19, 0x00	; 0
		uint8_t j = i*2;
		HoldReg[StartAddr+i] = MB_FrameReg(MB_N, 7+j);
    6254:	a8 0d       	add	r26, r8
    6256:	b9 1d       	adc	r27, r9
    6258:	aa 0f       	add	r26, r26
    625a:	bb 1f       	adc	r27, r27
    625c:	a4 0d       	add	r26, r4
    625e:	b5 1d       	adc	r27, r5
    6260:	fa 01       	movw	r30, r20
    6262:	e2 0f       	add	r30, r18
    6264:	f3 1f       	adc	r31, r19
    6266:	81 81       	ldd	r24, Z+1	; 0x01
    6268:	90 e0       	ldi	r25, 0x00	; 0
    626a:	2e 0d       	add	r18, r14
    626c:	3f 1d       	adc	r19, r15
    626e:	25 59       	subi	r18, 0x95	; 149
    6270:	34 4f       	sbci	r19, 0xF4	; 244
    6272:	f9 01       	movw	r30, r18
    6274:	30 81       	ld	r19, Z
    6276:	20 e0       	ldi	r18, 0x00	; 0
    6278:	82 2b       	or	r24, r18
    627a:	93 2b       	or	r25, r19
    627c:	8d 93       	st	X+, r24
    627e:	9c 93       	st	X, r25
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+MB_Frame[MB_N][5]>prw(&Modbus_Map[MB_N].HoldReg_Qt))
		return MB_Frame[MB_N][2]=IllegAddr;
	MB_Frame_Sz[MB_N] = 8;
	uint16_t *HoldReg = prp(&Modbus_Map[MB_N].HoldReg);
	for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    6280:	6f 5f       	subi	r22, 0xFF	; 255
    6282:	d3 01       	movw	r26, r6
    6284:	8c 91       	ld	r24, X
    6286:	68 17       	cp	r22, r24
    6288:	e8 f2       	brcs	.-70     	; 0x6244 <MB_S_Timer_ISR+0x4e6>
		break;
	case 0x10:
		Err = MB_S_Preset(MB_N, StartAddr);
		break;
	default:
		Err = MB_Frame[MB_N][2] = IllegFunc;
    628a:	90 e0       	ldi	r25, 0x00	; 0
    628c:	23 ce       	rjmp	.-954    	; 0x5ed4 <MB_S_Timer_ISR+0x176>
    628e:	9e 2f       	mov	r25, r30
    6290:	80 e0       	ldi	r24, 0x00	; 0
    6292:	af 2f       	mov	r26, r31
    6294:	b0 e0       	ldi	r27, 0x00	; 0
    6296:	a8 2b       	or	r26, r24
    6298:	b9 2b       	or	r27, r25
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_Force(uint8_t MB_N, uint16_t StartAddr)
{
	uint16_t Qt = MB_FrameReg(MB_N, 4);
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][6]+9 || Qt/8+(Qt%8>0)!=MB_Frame[MB_N][6])
    629a:	20 e0       	ldi	r18, 0x00	; 0
    629c:	30 e0       	ldi	r19, 0x00	; 0
    629e:	cd 01       	movw	r24, r26
    62a0:	87 70       	andi	r24, 0x07	; 7
    62a2:	90 70       	andi	r25, 0x00	; 0
    62a4:	89 2b       	or	r24, r25
    62a6:	11 f0       	breq	.+4      	; 0x62ac <MB_S_Timer_ISR+0x54e>
    62a8:	21 e0       	ldi	r18, 0x01	; 1
    62aa:	30 e0       	ldi	r19, 0x00	; 0
    62ac:	cd 01       	movw	r24, r26
    62ae:	96 95       	lsr	r25
    62b0:	87 95       	ror	r24
    62b2:	96 95       	lsr	r25
    62b4:	87 95       	ror	r24
    62b6:	96 95       	lsr	r25
    62b8:	87 95       	ror	r24
    62ba:	28 0f       	add	r18, r24
    62bc:	39 1f       	adc	r19, r25
    62be:	24 17       	cp	r18, r20
    62c0:	35 07       	cpc	r19, r21
    62c2:	09 f0       	breq	.+2      	; 0x62c6 <MB_S_Timer_ISR+0x568>
    62c4:	83 cf       	rjmp	.-250    	; 0x61cc <MB_S_Timer_ISR+0x46e>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    62c6:	e8 85       	ldd	r30, Y+8	; 0x08
    62c8:	f9 85       	ldd	r31, Y+9	; 0x09
    62ca:	ee 0f       	add	r30, r30
    62cc:	ff 1f       	adc	r31, r31
    62ce:	ee 0f       	add	r30, r30
    62d0:	ff 1f       	adc	r31, r31
    62d2:	ee 0f       	add	r30, r30
    62d4:	ff 1f       	adc	r31, r31
    62d6:	ee 0f       	add	r30, r30
    62d8:	ff 1f       	adc	r31, r31
    62da:	ee 5c       	subi	r30, 0xCE	; 206
    62dc:	fc 4f       	sbci	r31, 0xFC	; 252
    62de:	25 91       	lpm	r18, Z+
    62e0:	34 91       	lpm	r19, Z+
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+Qt > prw(&Modbus_Map[MB_N].Coil_Qt))
    62e2:	cd 01       	movw	r24, r26
    62e4:	88 0d       	add	r24, r8
    62e6:	99 1d       	adc	r25, r9
    62e8:	28 17       	cp	r18, r24
    62ea:	39 07       	cpc	r19, r25
    62ec:	08 f0       	brcs	.+2      	; 0x62f0 <MB_S_Timer_ISR+0x592>
    62ee:	5d c0       	rjmp	.+186    	; 0x63aa <MB_S_Timer_ISR+0x64c>
		return MB_Frame[MB_N][2]=IllegAddr;
    62f0:	66 0f       	add	r22, r22
    62f2:	77 1f       	adc	r23, r23
    62f4:	63 59       	subi	r22, 0x93	; 147
    62f6:	74 4f       	sbci	r23, 0xF4	; 244
    62f8:	82 e0       	ldi	r24, 0x02	; 2
    62fa:	db 01       	movw	r26, r22
    62fc:	8c 93       	st	X, r24
    62fe:	92 e0       	ldi	r25, 0x02	; 2
    6300:	e9 cd       	rjmp	.-1070   	; 0x5ed4 <MB_S_Timer_ISR+0x176>
MB_S_Preset(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][6]+9 || MB_Frame[MB_N][5]*2!=MB_Frame[MB_N][6])
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+MB_Frame[MB_N][5]>prw(&Modbus_Map[MB_N].HoldReg_Qt))
		return MB_Frame[MB_N][2]=IllegAddr;
    6302:	82 e0       	ldi	r24, 0x02	; 2
    6304:	8c 93       	st	X, r24
    6306:	92 e0       	ldi	r25, 0x02	; 2
    6308:	e5 cd       	rjmp	.-1078   	; 0x5ed4 <MB_S_Timer_ISR+0x176>
	if (MB_Frame[MB_N][0]==0)
		return 0xFF;
	if (MB_Frame_Sz[MB_N]!=8)
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+MB_Frame[MB_N][5]>(MB_Frame[MB_N][1]==3?prw(&Modbus_Map[MB_N].HoldReg_Qt):prw(&Modbus_Map[MB_N].InReg_Qt)))
		return MB_Frame[MB_N][2]=IllegAddr;
    630a:	66 0f       	add	r22, r22
    630c:	77 1f       	adc	r23, r23
    630e:	63 59       	subi	r22, 0x93	; 147
    6310:	74 4f       	sbci	r23, 0xF4	; 244
    6312:	82 e0       	ldi	r24, 0x02	; 2
    6314:	fb 01       	movw	r30, r22
    6316:	80 83       	st	Z, r24
    6318:	92 e0       	ldi	r25, 0x02	; 2
    631a:	dc cd       	rjmp	.-1096   	; 0x5ed4 <MB_S_Timer_ISR+0x176>
{
	if (MB_Frame[MB_N][0]==0)
		return 0xFF;
	if (MB_Frame_Sz[MB_N]!=8)
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+MB_Frame[MB_N][5]>(MB_Frame[MB_N][1]==3?prw(&Modbus_Map[MB_N].HoldReg_Qt):prw(&Modbus_Map[MB_N].InReg_Qt)))
    631c:	da 01       	movw	r26, r20
    631e:	15 96       	adiw	r26, 0x05	; 5
    6320:	8c 91       	ld	r24, X
    6322:	33 30       	cpi	r19, 0x03	; 3
    6324:	09 f4       	brne	.+2      	; 0x6328 <MB_S_Timer_ISR+0x5ca>
    6326:	ab c0       	rjmp	.+342    	; 0x647e <MB_S_Timer_ISR+0x720>
    6328:	f3 01       	movw	r30, r6
    632a:	e2 5c       	subi	r30, 0xC2	; 194
    632c:	fc 4f       	sbci	r31, 0xFC	; 252
    632e:	45 91       	lpm	r20, Z+
    6330:	54 91       	lpm	r21, Z+
    6332:	a8 2f       	mov	r26, r24
    6334:	b0 e0       	ldi	r27, 0x00	; 0
    6336:	c4 01       	movw	r24, r8
    6338:	8a 0f       	add	r24, r26
    633a:	9b 1f       	adc	r25, r27
    633c:	48 17       	cp	r20, r24
    633e:	59 07       	cpc	r21, r25
    6340:	20 f3       	brcs	.-56     	; 0x630a <MB_S_Timer_ISR+0x5ac>
		return MB_Frame[MB_N][2]=IllegAddr;
	uint16_t *Reg = (uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg)) + StartAddr;
    6342:	33 30       	cpi	r19, 0x03	; 3
    6344:	09 f4       	brne	.+2      	; 0x6348 <MB_S_Timer_ISR+0x5ea>
    6346:	a9 c0       	rjmp	.+338    	; 0x649a <MB_S_Timer_ISR+0x73c>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6348:	f3 01       	movw	r30, r6
    634a:	e4 5c       	subi	r30, 0xC4	; 196
    634c:	fc 4f       	sbci	r31, 0xFC	; 252
    634e:	85 91       	lpm	r24, Z+
    6350:	94 91       	lpm	r25, Z+
    6352:	94 01       	movw	r18, r8
    6354:	22 0f       	add	r18, r18
    6356:	33 1f       	adc	r19, r19
    6358:	28 0f       	add	r18, r24
    635a:	39 1f       	adc	r19, r25
	MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][2] = MB_Frame[MB_N][5]*2) + 5;
    635c:	cd 01       	movw	r24, r26
    635e:	88 0f       	add	r24, r24
    6360:	99 1f       	adc	r25, r25
    6362:	66 0f       	add	r22, r22
    6364:	77 1f       	adc	r23, r23
    6366:	63 59       	subi	r22, 0x93	; 147
    6368:	74 4f       	sbci	r23, 0xF4	; 244
    636a:	db 01       	movw	r26, r22
    636c:	8c 93       	st	X, r24
    636e:	8b 5f       	subi	r24, 0xFB	; 251
    6370:	f2 01       	movw	r30, r4
    6372:	80 83       	st	Z, r24
	uint8_t Qt = MB_Frame[MB_N][5];
    6374:	f7 01       	movw	r30, r14
    6376:	e5 59       	subi	r30, 0x95	; 149
    6378:	f4 4f       	sbci	r31, 0xF4	; 244
    637a:	45 81       	ldd	r20, Z+5	; 0x05
	for (uint8_t i=0; i<Qt; i++) {
    637c:	44 23       	and	r20, r20
    637e:	09 f4       	brne	.+2      	; 0x6382 <MB_S_Timer_ISR+0x624>
    6380:	84 cf       	rjmp	.-248    	; 0x628a <MB_S_Timer_ISR+0x52c>
    6382:	d9 01       	movw	r26, r18
    6384:	90 e0       	ldi	r25, 0x00	; 0
		uint8_t j = i*2;
		MB_Frame[MB_N][3+j] = Reg[i]>>8;
    6386:	9f 01       	movw	r18, r30
    6388:	89 2f       	mov	r24, r25
    638a:	88 0f       	add	r24, r24
    638c:	f9 01       	movw	r30, r18
    638e:	e8 0f       	add	r30, r24
    6390:	f1 1d       	adc	r31, r1
    6392:	11 96       	adiw	r26, 0x01	; 1
    6394:	8c 91       	ld	r24, X
    6396:	11 97       	sbiw	r26, 0x01	; 1
    6398:	83 83       	std	Z+3, r24	; 0x03
		MB_Frame[MB_N][4+j] = Reg[i];
    639a:	8c 91       	ld	r24, X
    639c:	84 83       	std	Z+4, r24	; 0x04
	if (StartAddr+MB_Frame[MB_N][5]>(MB_Frame[MB_N][1]==3?prw(&Modbus_Map[MB_N].HoldReg_Qt):prw(&Modbus_Map[MB_N].InReg_Qt)))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint16_t *Reg = (uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg)) + StartAddr;
	MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][2] = MB_Frame[MB_N][5]*2) + 5;
	uint8_t Qt = MB_Frame[MB_N][5];
	for (uint8_t i=0; i<Qt; i++) {
    639e:	9f 5f       	subi	r25, 0xFF	; 255
    63a0:	12 96       	adiw	r26, 0x02	; 2
    63a2:	94 17       	cp	r25, r20
    63a4:	88 f3       	brcs	.-30     	; 0x6388 <MB_S_Timer_ISR+0x62a>
		break;
	case 0x10:
		Err = MB_S_Preset(MB_N, StartAddr);
		break;
	default:
		Err = MB_Frame[MB_N][2] = IllegFunc;
    63a6:	90 e0       	ldi	r25, 0x00	; 0
    63a8:	95 cd       	rjmp	.-1238   	; 0x5ed4 <MB_S_Timer_ISR+0x176>
    63aa:	93 01       	movw	r18, r6
    63ac:	20 5d       	subi	r18, 0xD0	; 208
    63ae:	3c 4f       	sbci	r19, 0xFC	; 252
    63b0:	f9 01       	movw	r30, r18
    63b2:	85 91       	lpm	r24, Z+
    63b4:	94 91       	lpm	r25, Z+
    63b6:	9a 83       	std	Y+2, r25	; 0x02
    63b8:	89 83       	std	Y+1, r24	; 0x01
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][6]+9 || Qt/8+(Qt%8>0)!=MB_Frame[MB_N][6])
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+Qt > prw(&Modbus_Map[MB_N].Coil_Qt))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Coil = prp(&Modbus_Map[MB_N].Coil);
	MB_Frame_Sz[MB_N] = 8;
    63ba:	88 e0       	ldi	r24, 0x08	; 8
    63bc:	f2 01       	movw	r30, r4
    63be:	80 83       	st	Z, r24
	for (uint8_t i=0; i<Qt; i++) {
    63c0:	10 97       	sbiw	r26, 0x00	; 0
    63c2:	09 f4       	brne	.+2      	; 0x63c6 <MB_S_Timer_ISR+0x668>
    63c4:	62 cf       	rjmp	.-316    	; 0x628a <MB_S_Timer_ISR+0x52c>
    63c6:	cc 24       	eor	r12, r12
    63c8:	80 e0       	ldi	r24, 0x00	; 0
    63ca:	90 e0       	ldi	r25, 0x00	; 0
    63cc:	20 e0       	ldi	r18, 0x00	; 0
    63ce:	30 e0       	ldi	r19, 0x00	; 0
		uint16_t j = StartAddr+i;
		uint16_t Byte=j/8, Bit=1<<j%8;
    63d0:	e1 e0       	ldi	r30, 0x01	; 1
    63d2:	4e 2e       	mov	r4, r30
    63d4:	51 2c       	mov	r5, r1
		if (MB_Frame[MB_N][7+i/8] &(1<<i%8))
    63d6:	7b e6       	ldi	r23, 0x6B	; 107
    63d8:	67 2e       	mov	r6, r23
    63da:	7b e0       	ldi	r23, 0x0B	; 11
    63dc:	77 2e       	mov	r7, r23
    63de:	6e 0c       	add	r6, r14
    63e0:	7f 1c       	adc	r7, r15
    63e2:	10 c0       	rjmp	.+32     	; 0x6404 <MB_S_Timer_ISR+0x6a6>
			Coil[Byte] |=Bit;
    63e4:	29 81       	ldd	r18, Y+1	; 0x01
    63e6:	3a 81       	ldd	r19, Y+2	; 0x02
    63e8:	24 0f       	add	r18, r20
    63ea:	35 1f       	adc	r19, r21
    63ec:	f9 01       	movw	r30, r18
    63ee:	80 81       	ld	r24, Z
    63f0:	86 2b       	or	r24, r22
    63f2:	80 83       	st	Z, r24
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+Qt > prw(&Modbus_Map[MB_N].Coil_Qt))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Coil = prp(&Modbus_Map[MB_N].Coil);
	MB_Frame_Sz[MB_N] = 8;
	for (uint8_t i=0; i<Qt; i++) {
    63f4:	c3 94       	inc	r12
    63f6:	2c 2d       	mov	r18, r12
    63f8:	30 e0       	ldi	r19, 0x00	; 0
    63fa:	c9 01       	movw	r24, r18
    63fc:	2a 17       	cp	r18, r26
    63fe:	3b 07       	cpc	r19, r27
    6400:	08 f0       	brcs	.+2      	; 0x6404 <MB_S_Timer_ISR+0x6a6>
    6402:	43 cf       	rjmp	.-378    	; 0x628a <MB_S_Timer_ISR+0x52c>
		uint16_t j = StartAddr+i;
    6404:	88 0d       	add	r24, r8
    6406:	99 1d       	adc	r25, r9
		uint16_t Byte=j/8, Bit=1<<j%8;
    6408:	ac 01       	movw	r20, r24
    640a:	56 95       	lsr	r21
    640c:	47 95       	ror	r20
    640e:	56 95       	lsr	r21
    6410:	47 95       	ror	r20
    6412:	56 95       	lsr	r21
    6414:	47 95       	ror	r20
    6416:	87 70       	andi	r24, 0x07	; 7
    6418:	90 70       	andi	r25, 0x00	; 0
    641a:	b2 01       	movw	r22, r4
    641c:	02 c0       	rjmp	.+4      	; 0x6422 <MB_S_Timer_ISR+0x6c4>
    641e:	66 0f       	add	r22, r22
    6420:	77 1f       	adc	r23, r23
    6422:	8a 95       	dec	r24
    6424:	e2 f7       	brpl	.-8      	; 0x641e <MB_S_Timer_ISR+0x6c0>
		if (MB_Frame[MB_N][7+i/8] &(1<<i%8))
    6426:	8c 2d       	mov	r24, r12
    6428:	86 95       	lsr	r24
    642a:	86 95       	lsr	r24
    642c:	86 95       	lsr	r24
    642e:	f3 01       	movw	r30, r6
    6430:	e8 0f       	add	r30, r24
    6432:	f1 1d       	adc	r31, r1
    6434:	87 81       	ldd	r24, Z+7	; 0x07
    6436:	90 e0       	ldi	r25, 0x00	; 0
    6438:	27 70       	andi	r18, 0x07	; 7
    643a:	30 70       	andi	r19, 0x00	; 0
    643c:	02 c0       	rjmp	.+4      	; 0x6442 <MB_S_Timer_ISR+0x6e4>
    643e:	95 95       	asr	r25
    6440:	87 95       	ror	r24
    6442:	2a 95       	dec	r18
    6444:	e2 f7       	brpl	.-8      	; 0x643e <MB_S_Timer_ISR+0x6e0>
    6446:	80 fd       	sbrc	r24, 0
    6448:	cd cf       	rjmp	.-102    	; 0x63e4 <MB_S_Timer_ISR+0x686>
			Coil[Byte] |=Bit;
		else
			Coil[Byte] &=~Bit;
    644a:	29 81       	ldd	r18, Y+1	; 0x01
    644c:	3a 81       	ldd	r19, Y+2	; 0x02
    644e:	24 0f       	add	r18, r20
    6450:	35 1f       	adc	r19, r21
    6452:	96 2f       	mov	r25, r22
    6454:	90 95       	com	r25
    6456:	f9 01       	movw	r30, r18
    6458:	80 81       	ld	r24, Z
    645a:	89 23       	and	r24, r25
    645c:	80 83       	st	Z, r24
    645e:	ca cf       	rjmp	.-108    	; 0x63f4 <MB_S_Timer_ISR+0x696>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    6460:	e8 85       	ldd	r30, Y+8	; 0x08
    6462:	f9 85       	ldd	r31, Y+9	; 0x09
    6464:	ee 0f       	add	r30, r30
    6466:	ff 1f       	adc	r31, r31
    6468:	ee 0f       	add	r30, r30
    646a:	ff 1f       	adc	r31, r31
    646c:	ee 0f       	add	r30, r30
    646e:	ff 1f       	adc	r31, r31
    6470:	ee 0f       	add	r30, r30
    6472:	ff 1f       	adc	r31, r31
    6474:	ee 5c       	subi	r30, 0xCE	; 206
    6476:	fc 4f       	sbci	r31, 0xFC	; 252
    6478:	45 91       	lpm	r20, Z+
    647a:	54 91       	lpm	r21, Z+
    647c:	b2 cd       	rjmp	.-1180   	; 0x5fe2 <MB_S_Timer_ISR+0x284>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    647e:	f3 01       	movw	r30, r6
    6480:	e6 5c       	subi	r30, 0xC6	; 198
    6482:	fc 4f       	sbci	r31, 0xFC	; 252
    6484:	45 91       	lpm	r20, Z+
    6486:	54 91       	lpm	r21, Z+
    6488:	54 cf       	rjmp	.-344    	; 0x6332 <MB_S_Timer_ISR+0x5d4>
    648a:	f3 01       	movw	r30, r6
    648c:	e0 5d       	subi	r30, 0xD0	; 208
    648e:	fc 4f       	sbci	r31, 0xFC	; 252
    6490:	85 91       	lpm	r24, Z+
    6492:	94 91       	lpm	r25, Z+
    6494:	28 2f       	mov	r18, r24
    6496:	89 2f       	mov	r24, r25
    6498:	b9 cd       	rjmp	.-1166   	; 0x600c <MB_S_Timer_ISR+0x2ae>
    649a:	e8 85       	ldd	r30, Y+8	; 0x08
    649c:	f9 85       	ldd	r31, Y+9	; 0x09
    649e:	ee 0f       	add	r30, r30
    64a0:	ff 1f       	adc	r31, r31
    64a2:	ee 0f       	add	r30, r30
    64a4:	ff 1f       	adc	r31, r31
    64a6:	ee 0f       	add	r30, r30
    64a8:	ff 1f       	adc	r31, r31
    64aa:	ee 0f       	add	r30, r30
    64ac:	ff 1f       	adc	r31, r31
    64ae:	e8 5c       	subi	r30, 0xC8	; 200
    64b0:	fc 4f       	sbci	r31, 0xFC	; 252
    64b2:	85 91       	lpm	r24, Z+
    64b4:	94 91       	lpm	r25, Z+
    64b6:	4d cf       	rjmp	.-358    	; 0x6352 <MB_S_Timer_ISR+0x5f4>

000064b8 <MB_S_Tx>:
    64b8:	94 e1       	ldi	r25, 0x14	; 20
    64ba:	89 9f       	mul	r24, r25
    64bc:	c0 01       	movw	r24, r0
    64be:	11 24       	eor	r1, r1
    64c0:	8a 58       	subi	r24, 0x8A	; 138
    64c2:	9b 4c       	sbci	r25, 0xCB	; 203
    64c4:	fc 01       	movw	r30, r24
    64c6:	25 91       	lpm	r18, Z+
    64c8:	34 91       	lpm	r19, Z+

// ~~~~~~~~~~~~~~~~~~
void
MB_S_Tx(uint8_t MB_N)
{
	USART_Func(MB_N, LED);
    64ca:	f9 01       	movw	r30, r18
    64cc:	19 95       	eicall
}
    64ce:	08 95       	ret

000064d0 <MB_Slave_Off>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
MB_Slave_Off(uint8_t MB_N, uint8_t S_N)
{
    64d0:	21 e0       	ldi	r18, 0x01	; 1
    64d2:	30 e0       	ldi	r19, 0x00	; 0
    64d4:	40 e0       	ldi	r20, 0x00	; 0
    64d6:	50 e0       	ldi	r21, 0x00	; 0
    64d8:	04 c0       	rjmp	.+8      	; 0x64e2 <MB_Slave_Off+0x12>
    64da:	22 0f       	add	r18, r18
    64dc:	33 1f       	adc	r19, r19
    64de:	44 1f       	adc	r20, r20
    64e0:	55 1f       	adc	r21, r21
    64e2:	6a 95       	dec	r22
    64e4:	d2 f7       	brpl	.-12     	; 0x64da <MB_Slave_Off+0xa>
    64e6:	e8 2f       	mov	r30, r24
    64e8:	f0 e0       	ldi	r31, 0x00	; 0
    64ea:	ee 0f       	add	r30, r30
    64ec:	ff 1f       	adc	r31, r31
    64ee:	ee 0f       	add	r30, r30
    64f0:	ff 1f       	adc	r31, r31
    64f2:	e3 5d       	subi	r30, 0xD3	; 211
    64f4:	f6 4f       	sbci	r31, 0xF6	; 246
    64f6:	80 81       	ld	r24, Z
    64f8:	91 81       	ldd	r25, Z+1	; 0x01
    64fa:	a2 81       	ldd	r26, Z+2	; 0x02
    64fc:	b3 81       	ldd	r27, Z+3	; 0x03
    64fe:	28 23       	and	r18, r24
    6500:	39 23       	and	r19, r25
    6502:	4a 23       	and	r20, r26
    6504:	5b 23       	and	r21, r27
	return SlaveOff[MB_N] &((uint32_t)1<<S_N);
}
    6506:	b9 01       	movw	r22, r18
    6508:	ca 01       	movw	r24, r20
    650a:	08 95       	ret

0000650c <GetReg>:
}

// ~~~~~~~~~~~~~~~~~
static uint16_t*
GetReg(uint8_t MB_N)
{
    650c:	98 2f       	mov	r25, r24
	return MB_SingleState[MB_N]!=MB_SingleExec?(uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+prw(&GetQuery(MB_N)->AllocAddr):MB_SingleQuery[MB_N].Buf;
    650e:	a8 2f       	mov	r26, r24
    6510:	b0 e0       	ldi	r27, 0x00	; 0
    6512:	fd 01       	movw	r30, r26
    6514:	e1 55       	subi	r30, 0x51	; 81
    6516:	f9 4f       	sbci	r31, 0xF9	; 249
    6518:	80 81       	ld	r24, Z
    651a:	82 30       	cpi	r24, 0x02	; 2
    651c:	09 f4       	brne	.+2      	; 0x6520 <GetReg+0x14>
    651e:	39 c0       	rjmp	.+114    	; 0x6592 <GetReg+0x86>
    6520:	fd 01       	movw	r30, r26
    6522:	ee 0f       	add	r30, r30
    6524:	ff 1f       	adc	r31, r31
    6526:	ee 0f       	add	r30, r30
    6528:	ff 1f       	adc	r31, r31
    652a:	ee 0f       	add	r30, r30
    652c:	ff 1f       	adc	r31, r31
    652e:	ee 0f       	add	r30, r30
    6530:	ff 1f       	adc	r31, r31
    6532:	e8 5c       	subi	r30, 0xC8	; 200
    6534:	fc 4f       	sbci	r31, 0xFC	; 252
    6536:	45 91       	lpm	r20, Z+
    6538:	54 91       	lpm	r21, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    653a:	83 e0       	ldi	r24, 0x03	; 3
    653c:	98 9f       	mul	r25, r24
    653e:	f0 01       	movw	r30, r0
    6540:	11 24       	eor	r1, r1
    6542:	e5 5b       	subi	r30, 0xB5	; 181
    6544:	f6 4d       	sbci	r31, 0xD6	; 214
    6546:	25 91       	lpm	r18, Z+
    6548:	34 91       	lpm	r19, Z+
    654a:	fd 01       	movw	r30, r26
    654c:	ec 5a       	subi	r30, 0xAC	; 172
    654e:	f9 4f       	sbci	r31, 0xF9	; 249
    6550:	80 81       	ld	r24, Z
    6552:	90 e0       	ldi	r25, 0x00	; 0
    6554:	88 0f       	add	r24, r24
    6556:	99 1f       	adc	r25, r25
    6558:	88 0f       	add	r24, r24
    655a:	99 1f       	adc	r25, r25
    655c:	28 0f       	add	r18, r24
    655e:	39 1f       	adc	r19, r25
    6560:	2f 5f       	subi	r18, 0xFF	; 255
    6562:	3f 4f       	sbci	r19, 0xFF	; 255
    6564:	f9 01       	movw	r30, r18
    6566:	65 91       	lpm	r22, Z+
    6568:	74 91       	lpm	r23, Z+
    656a:	ab 5a       	subi	r26, 0xAB	; 171
    656c:	b9 4f       	sbci	r27, 0xF9	; 249
    656e:	8c 91       	ld	r24, X
    6570:	27 e0       	ldi	r18, 0x07	; 7
    6572:	82 9f       	mul	r24, r18
    6574:	c0 01       	movw	r24, r0
    6576:	11 24       	eor	r1, r1
    6578:	68 0f       	add	r22, r24
    657a:	79 1f       	adc	r23, r25
    657c:	6b 5f       	subi	r22, 0xFB	; 251
    657e:	7f 4f       	sbci	r23, 0xFF	; 255
    6580:	fb 01       	movw	r30, r22
    6582:	85 91       	lpm	r24, Z+
    6584:	94 91       	lpm	r25, Z+
    6586:	88 0f       	add	r24, r24
    6588:	99 1f       	adc	r25, r25
    658a:	48 0f       	add	r20, r24
    658c:	59 1f       	adc	r21, r25
}
    658e:	ca 01       	movw	r24, r20
    6590:	08 95       	ret

// ~~~~~~~~~~~~~~~~~
static uint16_t*
GetReg(uint8_t MB_N)
{
	return MB_SingleState[MB_N]!=MB_SingleExec?(uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+prw(&GetQuery(MB_N)->AllocAddr):MB_SingleQuery[MB_N].Buf;
    6592:	aa 0f       	add	r26, r26
    6594:	bb 1f       	adc	r27, r27
    6596:	aa 0f       	add	r26, r26
    6598:	bb 1f       	adc	r27, r27
    659a:	aa 0f       	add	r26, r26
    659c:	bb 1f       	adc	r27, r27
    659e:	a6 52       	subi	r26, 0x26	; 38
    65a0:	bb 4f       	sbci	r27, 0xFB	; 251
    65a2:	16 96       	adiw	r26, 0x06	; 6
    65a4:	4d 91       	ld	r20, X+
    65a6:	5c 91       	ld	r21, X
    65a8:	17 97       	sbiw	r26, 0x07	; 7
}
    65aa:	ca 01       	movw	r24, r20
    65ac:	08 95       	ret

000065ae <FormData>:

// ~~~~~~~~~~~~~~~~~~~
static void
FormData(uint8_t MB_N)
{
    65ae:	cf 92       	push	r12
    65b0:	df 92       	push	r13
    65b2:	ef 92       	push	r14
    65b4:	ff 92       	push	r15
    65b6:	0f 93       	push	r16
    65b8:	1f 93       	push	r17
    65ba:	cf 93       	push	r28
    65bc:	df 93       	push	r29
    65be:	e8 2e       	mov	r14, r24
	uint16_t Qt;
	uint16_t *Reg;
	switch (MB_Frame[MB_N][1]) {
    65c0:	c8 2f       	mov	r28, r24
    65c2:	d0 e0       	ldi	r29, 0x00	; 0
    65c4:	7c 2f       	mov	r23, r28
    65c6:	66 27       	eor	r22, r22
    65c8:	8b 01       	movw	r16, r22
    65ca:	05 59       	subi	r16, 0x95	; 149
    65cc:	14 4f       	sbci	r17, 0xF4	; 244
    65ce:	f8 01       	movw	r30, r16
    65d0:	81 81       	ldd	r24, Z+1	; 0x01
    65d2:	86 30       	cpi	r24, 0x06	; 6
    65d4:	09 f4       	brne	.+2      	; 0x65d8 <FormData+0x2a>
    65d6:	4b c0       	rjmp	.+150    	; 0x666e <FormData+0xc0>
    65d8:	87 30       	cpi	r24, 0x07	; 7
    65da:	88 f0       	brcs	.+34     	; 0x65fe <FormData+0x50>
    65dc:	8f 30       	cpi	r24, 0x0F	; 15
    65de:	09 f4       	brne	.+2      	; 0x65e2 <FormData+0x34>
    65e0:	5b c0       	rjmp	.+182    	; 0x6698 <FormData+0xea>
    65e2:	80 31       	cpi	r24, 0x10	; 16
    65e4:	a1 f0       	breq	.+40     	; 0x660e <FormData+0x60>
			MB_Frame[MB_N][7+j] = Reg[i]>>8;
			MB_Frame[MB_N][8+j] = Reg[i];
		}
		break;
	}
	SetCRC_MB(MB_N);
    65e6:	8e 2d       	mov	r24, r14
    65e8:	0e 94 56 2e 	call	0x5cac	; 0x5cac <SetCRC_MB>
}
    65ec:	df 91       	pop	r29
    65ee:	cf 91       	pop	r28
    65f0:	1f 91       	pop	r17
    65f2:	0f 91       	pop	r16
    65f4:	ff 90       	pop	r15
    65f6:	ef 90       	pop	r14
    65f8:	df 90       	pop	r13
    65fa:	cf 90       	pop	r12
    65fc:	08 95       	ret
static void
FormData(uint8_t MB_N)
{
	uint16_t Qt;
	uint16_t *Reg;
	switch (MB_Frame[MB_N][1]) {
    65fe:	81 50       	subi	r24, 0x01	; 1
    6600:	84 30       	cpi	r24, 0x04	; 4
    6602:	88 f7       	brcc	.-30     	; 0x65e6 <FormData+0x38>
	case 1: case 2: case 3: case 4:
		MB_Frame_Sz[MB_N] = 8;
    6604:	c7 5b       	subi	r28, 0xB7	; 183
    6606:	d8 4f       	sbci	r29, 0xF8	; 248
    6608:	88 e0       	ldi	r24, 0x08	; 8
    660a:	88 83       	st	Y, r24
    660c:	ec cf       	rjmp	.-40     	; 0x65e6 <FormData+0x38>
			else
				MB_Frame[MB_N][Byte] &=~Bit;
		}
		break;
	case 0x10:
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = MB_Frame[MB_N][5]*2) + 9;
    660e:	55 e0       	ldi	r21, 0x05	; 5
    6610:	c5 2e       	mov	r12, r21
    6612:	d1 2c       	mov	r13, r1
    6614:	c0 0e       	add	r12, r16
    6616:	d1 1e       	adc	r13, r17
    6618:	f8 01       	movw	r30, r16
    661a:	85 81       	ldd	r24, Z+5	; 0x05
    661c:	90 e0       	ldi	r25, 0x00	; 0
    661e:	88 0f       	add	r24, r24
    6620:	99 1f       	adc	r25, r25
    6622:	86 83       	std	Z+6, r24	; 0x06
    6624:	c7 5b       	subi	r28, 0xB7	; 183
    6626:	d8 4f       	sbci	r29, 0xF8	; 248
    6628:	87 5f       	subi	r24, 0xF7	; 247
    662a:	88 83       	st	Y, r24
		Reg = GetReg(MB_N);
    662c:	8e 2d       	mov	r24, r14
    662e:	0e 94 86 32 	call	0x650c	; 0x650c <GetReg>
    6632:	bc 01       	movw	r22, r24
		for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    6634:	f8 01       	movw	r30, r16
    6636:	85 81       	ldd	r24, Z+5	; 0x05
    6638:	88 23       	and	r24, r24
    663a:	a9 f2       	breq	.-86     	; 0x65e6 <FormData+0x38>
    663c:	20 e0       	ldi	r18, 0x00	; 0
			uint8_t j = i*2;
			MB_Frame[MB_N][7+j] = Reg[i]>>8;
    663e:	a8 01       	movw	r20, r16
		}
		break;
	case 0x10:
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = MB_Frame[MB_N][5]*2) + 9;
		Reg = GetReg(MB_N);
		for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    6640:	e6 01       	movw	r28, r12
			uint8_t j = i*2;
			MB_Frame[MB_N][7+j] = Reg[i]>>8;
    6642:	82 2f       	mov	r24, r18
    6644:	90 e0       	ldi	r25, 0x00	; 0
    6646:	88 0f       	add	r24, r24
    6648:	99 1f       	adc	r25, r25
    664a:	fb 01       	movw	r30, r22
    664c:	e8 0f       	add	r30, r24
    664e:	f9 1f       	adc	r31, r25
    6650:	da 01       	movw	r26, r20
    6652:	a8 0f       	add	r26, r24
    6654:	b1 1d       	adc	r27, r1
    6656:	81 81       	ldd	r24, Z+1	; 0x01
    6658:	17 96       	adiw	r26, 0x07	; 7
    665a:	8c 93       	st	X, r24
    665c:	17 97       	sbiw	r26, 0x07	; 7
			MB_Frame[MB_N][8+j] = Reg[i];
    665e:	80 81       	ld	r24, Z
    6660:	18 96       	adiw	r26, 0x08	; 8
    6662:	8c 93       	st	X, r24
		}
		break;
	case 0x10:
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = MB_Frame[MB_N][5]*2) + 9;
		Reg = GetReg(MB_N);
		for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    6664:	2f 5f       	subi	r18, 0xFF	; 255
    6666:	88 81       	ld	r24, Y
    6668:	28 17       	cp	r18, r24
    666a:	58 f3       	brcs	.-42     	; 0x6642 <FormData+0x94>
    666c:	bc cf       	rjmp	.-136    	; 0x65e6 <FormData+0x38>
		MB_Frame_Sz[MB_N] = 8;
		MB_Frame[MB_N][5] = 0;
		break;
	*/
	case 6:
		MB_Frame_Sz[MB_N] = 8;
    666e:	fe 01       	movw	r30, r28
    6670:	e7 5b       	subi	r30, 0xB7	; 183
    6672:	f8 4f       	sbci	r31, 0xF8	; 248
    6674:	88 e0       	ldi	r24, 0x08	; 8
    6676:	80 83       	st	Z, r24
		Reg = GetReg(MB_N);
    6678:	8e 2d       	mov	r24, r14
    667a:	0e 94 86 32 	call	0x650c	; 0x650c <GetReg>
    667e:	dc 01       	movw	r26, r24
		MB_Frame[MB_N][4] = *Reg>>8;
    6680:	fc 2f       	mov	r31, r28
    6682:	ee 27       	eor	r30, r30
    6684:	e1 59       	subi	r30, 0x91	; 145
    6686:	f4 4f       	sbci	r31, 0xF4	; 244
    6688:	11 96       	adiw	r26, 0x01	; 1
    668a:	8c 91       	ld	r24, X
    668c:	11 97       	sbiw	r26, 0x01	; 1
    668e:	80 83       	st	Z, r24
		MB_Frame[MB_N][5] = *Reg;
    6690:	8c 91       	ld	r24, X
    6692:	f8 01       	movw	r30, r16
    6694:	85 83       	std	Z+5, r24	; 0x05
    6696:	a7 cf       	rjmp	.-178    	; 0x65e6 <FormData+0x38>
    6698:	fc 2f       	mov	r31, r28
    669a:	ee 27       	eor	r30, r30
    669c:	e1 59       	subi	r30, 0x91	; 145
    669e:	f4 4f       	sbci	r31, 0xF4	; 244
    66a0:	90 81       	ld	r25, Z
    66a2:	80 e0       	ldi	r24, 0x00	; 0
    66a4:	f8 01       	movw	r30, r16
    66a6:	25 81       	ldd	r18, Z+5	; 0x05
    66a8:	02 2f       	mov	r16, r18
    66aa:	10 e0       	ldi	r17, 0x00	; 0
    66ac:	08 2b       	or	r16, r24
    66ae:	19 2b       	or	r17, r25
		break;
	case 0x0F:
		Qt = MB_FrameReg(MB_N, 4);
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = Qt/8 + (Qt%8>0)) + 9;
    66b0:	98 01       	movw	r18, r16
    66b2:	36 95       	lsr	r19
    66b4:	27 95       	ror	r18
    66b6:	36 95       	lsr	r19
    66b8:	27 95       	ror	r18
    66ba:	36 95       	lsr	r19
    66bc:	27 95       	ror	r18
    66be:	40 e0       	ldi	r20, 0x00	; 0
    66c0:	c8 01       	movw	r24, r16
    66c2:	87 70       	andi	r24, 0x07	; 7
    66c4:	90 70       	andi	r25, 0x00	; 0
    66c6:	89 2b       	or	r24, r25
    66c8:	09 f0       	breq	.+2      	; 0x66cc <FormData+0x11e>
    66ca:	8b c0       	rjmp	.+278    	; 0x67e2 <FormData+0x234>
    66cc:	84 2f       	mov	r24, r20
    66ce:	82 0f       	add	r24, r18
    66d0:	fb 01       	movw	r30, r22
    66d2:	e5 59       	subi	r30, 0x95	; 149
    66d4:	f4 4f       	sbci	r31, 0xF4	; 244
    66d6:	86 83       	std	Z+6, r24	; 0x06
    66d8:	de 01       	movw	r26, r28
    66da:	a7 5b       	subi	r26, 0xB7	; 183
    66dc:	b8 4f       	sbci	r27, 0xF8	; 248
    66de:	87 5f       	subi	r24, 0xF7	; 247
    66e0:	8c 93       	st	X, r24
		MB_Frame[MB_N][7+Qt/8] = 0;
    66e2:	e2 0f       	add	r30, r18
    66e4:	f3 1f       	adc	r31, r19
    66e6:	17 82       	std	Z+7, r1	; 0x07
		uint8_t *Discr;
		uint8_t Pin;
		if (MB_SingleState[MB_N]!=MB_SingleExec) {
    66e8:	fe 01       	movw	r30, r28
    66ea:	e1 55       	subi	r30, 0x51	; 81
    66ec:	f9 4f       	sbci	r31, 0xF9	; 249
    66ee:	80 81       	ld	r24, Z
    66f0:	82 30       	cpi	r24, 0x02	; 2
    66f2:	09 f4       	brne	.+2      	; 0x66f6 <FormData+0x148>
    66f4:	78 c0       	rjmp	.+240    	; 0x67e6 <FormData+0x238>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    66f6:	fe 01       	movw	r30, r28
    66f8:	e2 95       	swap	r30
    66fa:	f2 95       	swap	r31
    66fc:	f0 7f       	andi	r31, 0xF0	; 240
    66fe:	fe 27       	eor	r31, r30
    6700:	e0 7f       	andi	r30, 0xF0	; 240
    6702:	fe 27       	eor	r31, r30
    6704:	e0 5d       	subi	r30, 0xD0	; 208
    6706:	fc 4f       	sbci	r31, 0xFC	; 252
			Discr = prp(&Modbus_Map[MB_N].Coil);
    6708:	a5 91       	lpm	r26, Z+
    670a:	b4 91       	lpm	r27, Z+
    670c:	83 e0       	ldi	r24, 0x03	; 3
    670e:	e8 9e       	mul	r14, r24
    6710:	f0 01       	movw	r30, r0
    6712:	11 24       	eor	r1, r1
    6714:	e5 5b       	subi	r30, 0xB5	; 181
    6716:	f6 4d       	sbci	r31, 0xD6	; 214
    6718:	25 91       	lpm	r18, Z+
    671a:	34 91       	lpm	r19, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    671c:	fe 01       	movw	r30, r28
    671e:	ec 5a       	subi	r30, 0xAC	; 172
    6720:	f9 4f       	sbci	r31, 0xF9	; 249
    6722:	80 81       	ld	r24, Z
    6724:	90 e0       	ldi	r25, 0x00	; 0
    6726:	88 0f       	add	r24, r24
    6728:	99 1f       	adc	r25, r25
    672a:	88 0f       	add	r24, r24
    672c:	99 1f       	adc	r25, r25
    672e:	28 0f       	add	r18, r24
    6730:	39 1f       	adc	r19, r25
    6732:	2f 5f       	subi	r18, 0xFF	; 255
    6734:	3f 4f       	sbci	r19, 0xFF	; 255
    6736:	f9 01       	movw	r30, r18
    6738:	45 91       	lpm	r20, Z+
    673a:	54 91       	lpm	r21, Z+
    673c:	cb 5a       	subi	r28, 0xAB	; 171
    673e:	d9 4f       	sbci	r29, 0xF9	; 249
    6740:	88 81       	ld	r24, Y
    6742:	27 e0       	ldi	r18, 0x07	; 7
    6744:	82 9f       	mul	r24, r18
    6746:	c0 01       	movw	r24, r0
    6748:	11 24       	eor	r1, r1
    674a:	48 0f       	add	r20, r24
    674c:	59 1f       	adc	r21, r25
    674e:	4b 5f       	subi	r20, 0xFB	; 251
    6750:	5f 4f       	sbci	r21, 0xFF	; 255
    6752:	fa 01       	movw	r30, r20
    6754:	85 91       	lpm	r24, Z+
    6756:	94 91       	lpm	r25, Z+
			Pin = prw(&GetQuery(MB_N)->AllocAddr);
    6758:	f8 2e       	mov	r15, r24
		}
		else {
			Discr = MB_SingleQuery[MB_N].Buf;
			Pin = 0;
		}
		for (uint8_t i=0; i<Qt; i++) {
    675a:	01 15       	cp	r16, r1
    675c:	11 05       	cpc	r17, r1
    675e:	09 f4       	brne	.+2      	; 0x6762 <FormData+0x1b4>
    6760:	42 cf       	rjmp	.-380    	; 0x65e6 <FormData+0x38>
    6762:	50 e0       	ldi	r21, 0x00	; 0
    6764:	80 e0       	ldi	r24, 0x00	; 0
    6766:	90 e0       	ldi	r25, 0x00	; 0
			uint8_t j = Pin+i;
			uint8_t Byte=7+i/8, Bit=1<<i%8;
    6768:	c1 e0       	ldi	r28, 0x01	; 1
    676a:	d0 e0       	ldi	r29, 0x00	; 0
    676c:	0f c0       	rjmp	.+30     	; 0x678c <FormData+0x1de>
			if (Discr[j/8] &(1<<j%8))
				MB_Frame[MB_N][Byte] |=Bit;
    676e:	fb 01       	movw	r30, r22
    6770:	e3 0f       	add	r30, r19
    6772:	f1 1d       	adc	r31, r1
    6774:	e5 59       	subi	r30, 0x95	; 149
    6776:	f4 4f       	sbci	r31, 0xF4	; 244
    6778:	80 81       	ld	r24, Z
    677a:	84 2b       	or	r24, r20
    677c:	80 83       	st	Z, r24
		}
		else {
			Discr = MB_SingleQuery[MB_N].Buf;
			Pin = 0;
		}
		for (uint8_t i=0; i<Qt; i++) {
    677e:	5f 5f       	subi	r21, 0xFF	; 255
    6780:	85 2f       	mov	r24, r21
    6782:	90 e0       	ldi	r25, 0x00	; 0
    6784:	80 17       	cp	r24, r16
    6786:	91 07       	cpc	r25, r17
    6788:	08 f0       	brcs	.+2      	; 0x678c <FormData+0x1de>
    678a:	2d cf       	rjmp	.-422    	; 0x65e6 <FormData+0x38>
    678c:	25 2f       	mov	r18, r21
    678e:	2f 0d       	add	r18, r15
			uint8_t j = Pin+i;
			uint8_t Byte=7+i/8, Bit=1<<i%8;
    6790:	35 2f       	mov	r19, r21
    6792:	36 95       	lsr	r19
    6794:	36 95       	lsr	r19
    6796:	36 95       	lsr	r19
    6798:	39 5f       	subi	r19, 0xF9	; 249
    679a:	87 70       	andi	r24, 0x07	; 7
    679c:	90 70       	andi	r25, 0x00	; 0
    679e:	fe 01       	movw	r30, r28
    67a0:	02 c0       	rjmp	.+4      	; 0x67a6 <FormData+0x1f8>
    67a2:	ee 0f       	add	r30, r30
    67a4:	ff 1f       	adc	r31, r31
    67a6:	8a 95       	dec	r24
    67a8:	e2 f7       	brpl	.-8      	; 0x67a2 <FormData+0x1f4>
    67aa:	4e 2f       	mov	r20, r30
			if (Discr[j/8] &(1<<j%8))
    67ac:	82 2f       	mov	r24, r18
    67ae:	86 95       	lsr	r24
    67b0:	86 95       	lsr	r24
    67b2:	86 95       	lsr	r24
    67b4:	fd 01       	movw	r30, r26
    67b6:	e8 0f       	add	r30, r24
    67b8:	f1 1d       	adc	r31, r1
    67ba:	80 81       	ld	r24, Z
    67bc:	90 e0       	ldi	r25, 0x00	; 0
    67be:	27 70       	andi	r18, 0x07	; 7
    67c0:	02 c0       	rjmp	.+4      	; 0x67c6 <FormData+0x218>
    67c2:	95 95       	asr	r25
    67c4:	87 95       	ror	r24
    67c6:	2a 95       	dec	r18
    67c8:	e2 f7       	brpl	.-8      	; 0x67c2 <FormData+0x214>
    67ca:	80 fd       	sbrc	r24, 0
    67cc:	d0 cf       	rjmp	.-96     	; 0x676e <FormData+0x1c0>
				MB_Frame[MB_N][Byte] |=Bit;
			else
				MB_Frame[MB_N][Byte] &=~Bit;
    67ce:	fb 01       	movw	r30, r22
    67d0:	e3 0f       	add	r30, r19
    67d2:	f1 1d       	adc	r31, r1
    67d4:	e5 59       	subi	r30, 0x95	; 149
    67d6:	f4 4f       	sbci	r31, 0xF4	; 244
    67d8:	40 95       	com	r20
    67da:	80 81       	ld	r24, Z
    67dc:	48 23       	and	r20, r24
    67de:	40 83       	st	Z, r20
    67e0:	ce cf       	rjmp	.-100    	; 0x677e <FormData+0x1d0>
		MB_Frame[MB_N][4] = *Reg>>8;
		MB_Frame[MB_N][5] = *Reg;
		break;
	case 0x0F:
		Qt = MB_FrameReg(MB_N, 4);
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = Qt/8 + (Qt%8>0)) + 9;
    67e2:	41 e0       	ldi	r20, 0x01	; 1
    67e4:	73 cf       	rjmp	.-282    	; 0x66cc <FormData+0x11e>
		if (MB_SingleState[MB_N]!=MB_SingleExec) {
			Discr = prp(&Modbus_Map[MB_N].Coil);
			Pin = prw(&GetQuery(MB_N)->AllocAddr);
		}
		else {
			Discr = MB_SingleQuery[MB_N].Buf;
    67e6:	cc 0f       	add	r28, r28
    67e8:	dd 1f       	adc	r29, r29
    67ea:	cc 0f       	add	r28, r28
    67ec:	dd 1f       	adc	r29, r29
    67ee:	cc 0f       	add	r28, r28
    67f0:	dd 1f       	adc	r29, r29
    67f2:	c6 52       	subi	r28, 0x26	; 38
    67f4:	db 4f       	sbci	r29, 0xFB	; 251
    67f6:	ae 81       	ldd	r26, Y+6	; 0x06
    67f8:	bf 81       	ldd	r27, Y+7	; 0x07
    67fa:	ff 24       	eor	r15, r15
    67fc:	ae cf       	rjmp	.-164    	; 0x675a <FormData+0x1ac>

000067fe <FormQuery>:
}

// ~~~~~~~~~~~~~~~~~~~~
static void
FormQuery(uint8_t MB_N)
{
    67fe:	cf 93       	push	r28
    6800:	df 93       	push	r29

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6802:	93 e0       	ldi	r25, 0x03	; 3
    6804:	89 9f       	mul	r24, r25
    6806:	f0 01       	movw	r30, r0
    6808:	11 24       	eor	r1, r1
    680a:	e5 5b       	subi	r30, 0xB5	; 181
    680c:	f6 4d       	sbci	r31, 0xD6	; 214
    680e:	65 91       	lpm	r22, Z+
    6810:	74 91       	lpm	r23, Z+

// ~~~~~~~~~~~~~~~~~~~
static MB_Slave*
GetSlave(uint8_t MB_N)
{
	return (MB_Slave*)prp(&(MB_Master_List+MB_N)->SlaveList)+CurrSlave[MB_N];
    6812:	48 2f       	mov	r20, r24
    6814:	50 e0       	ldi	r21, 0x00	; 0
    6816:	fa 01       	movw	r30, r20
    6818:	ec 5a       	subi	r30, 0xAC	; 172
    681a:	f9 4f       	sbci	r31, 0xF9	; 249
    681c:	20 81       	ld	r18, Z
    681e:	30 e0       	ldi	r19, 0x00	; 0
    6820:	22 0f       	add	r18, r18
    6822:	33 1f       	adc	r19, r19
    6824:	22 0f       	add	r18, r18
    6826:	33 1f       	adc	r19, r19
    6828:	62 0f       	add	r22, r18
    682a:	73 1f       	adc	r23, r19
    682c:	fb 01       	movw	r30, r22
    682e:	31 96       	adiw	r30, 0x01	; 1
    6830:	c5 91       	lpm	r28, Z+
    6832:	d4 91       	lpm	r29, Z+
// ~~~~~~~~~~~~~~~~~~~~
static void
FormQuery(uint8_t MB_N)
{
	MB_Slave *Slave = GetSlave(MB_N);
	MB_Query *Query = (MB_Query*)prp(&Slave->QueryList)+CurrQuery[MB_N];
    6834:	fa 01       	movw	r30, r20
    6836:	eb 5a       	subi	r30, 0xAB	; 171
    6838:	f9 4f       	sbci	r31, 0xF9	; 249
    683a:	20 81       	ld	r18, Z
    683c:	97 e0       	ldi	r25, 0x07	; 7
    683e:	29 9f       	mul	r18, r25
    6840:	90 01       	movw	r18, r0
    6842:	11 24       	eor	r1, r1
    6844:	c2 0f       	add	r28, r18
    6846:	d3 1f       	adc	r29, r19

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    6848:	fb 01       	movw	r30, r22
    684a:	94 91       	lpm	r25, Z+

	MB_Frame[MB_N][0] = prb(&Slave->Addr);
    684c:	2b e6       	ldi	r18, 0x6B	; 107
    684e:	3b e0       	ldi	r19, 0x0B	; 11
    6850:	b4 2f       	mov	r27, r20
    6852:	aa 27       	eor	r26, r26
    6854:	a2 0f       	add	r26, r18
    6856:	b3 1f       	adc	r27, r19
    6858:	9c 93       	st	X, r25
    685a:	fe 01       	movw	r30, r28
    685c:	94 91       	lpm	r25, Z+
	MB_Frame[MB_N][1] = prb(&Query->Func);
    685e:	11 96       	adiw	r26, 0x01	; 1
    6860:	9c 93       	st	X, r25
    6862:	11 97       	sbiw	r26, 0x01	; 1
	MB_Frame[MB_N][2] = prb((uint8_t*)&Query->StartAddr+1);
    6864:	be 01       	movw	r22, r28
    6866:	6f 5f       	subi	r22, 0xFF	; 255
    6868:	7f 4f       	sbci	r23, 0xFF	; 255
    686a:	6f 5f       	subi	r22, 0xFF	; 255
    686c:	7f 4f       	sbci	r23, 0xFF	; 255
    686e:	fb 01       	movw	r30, r22
    6870:	94 91       	lpm	r25, Z+
    6872:	61 50       	subi	r22, 0x01	; 1
    6874:	70 40       	sbci	r23, 0x00	; 0
    6876:	fd 01       	movw	r30, r26
    6878:	92 83       	std	Z+2, r25	; 0x02
    687a:	fb 01       	movw	r30, r22
    687c:	94 91       	lpm	r25, Z+
	MB_Frame[MB_N][3] = prb((uint8_t*)&Query->StartAddr);
    687e:	13 96       	adiw	r26, 0x03	; 3
    6880:	9c 93       	st	X, r25
    6882:	13 97       	sbiw	r26, 0x03	; 3
    6884:	24 96       	adiw	r28, 0x04	; 4
    6886:	fe 01       	movw	r30, r28
    6888:	94 91       	lpm	r25, Z+
	MB_Frame[MB_N][4] = prb((uint8_t*)&Query->Qt+1);
    688a:	fd 01       	movw	r30, r26
    688c:	94 83       	std	Z+4, r25	; 0x04
    688e:	21 97       	sbiw	r28, 0x01	; 1
    6890:	fe 01       	movw	r30, r28
    6892:	94 91       	lpm	r25, Z+
	MB_Frame[MB_N][5] = prb((uint8_t*)&Query->Qt);
    6894:	15 96       	adiw	r26, 0x05	; 5
    6896:	9c 93       	st	X, r25

	FormData(MB_N);
    6898:	0e 94 d7 32 	call	0x65ae	; 0x65ae <FormData>
}
    689c:	df 91       	pop	r29
    689e:	cf 91       	pop	r28
    68a0:	08 95       	ret

000068a2 <FormSingle>:

// ~~~~~~~~~~~~~~~~~~~~~
static void
FormSingle(uint8_t MB_N)
{
    68a2:	1f 93       	push	r17
    68a4:	cf 93       	push	r28
    68a6:	df 93       	push	r29
	MB_Frame[MB_N][0] = MB_SingleQuery[MB_N].Addr;
    68a8:	a8 2f       	mov	r26, r24
    68aa:	b0 e0       	ldi	r27, 0x00	; 0
    68ac:	6b e6       	ldi	r22, 0x6B	; 107
    68ae:	7b e0       	ldi	r23, 0x0B	; 11
    68b0:	5a 2f       	mov	r21, r26
    68b2:	44 27       	eor	r20, r20
    68b4:	46 0f       	add	r20, r22
    68b6:	57 1f       	adc	r21, r23
    68b8:	2a ed       	ldi	r18, 0xDA	; 218
    68ba:	34 e0       	ldi	r19, 0x04	; 4
    68bc:	fd 01       	movw	r30, r26
    68be:	ee 0f       	add	r30, r30
    68c0:	ff 1f       	adc	r31, r31
    68c2:	ee 0f       	add	r30, r30
    68c4:	ff 1f       	adc	r31, r31
    68c6:	ee 0f       	add	r30, r30
    68c8:	ff 1f       	adc	r31, r31
    68ca:	e2 0f       	add	r30, r18
    68cc:	f3 1f       	adc	r31, r19
    68ce:	90 81       	ld	r25, Z
    68d0:	ea 01       	movw	r28, r20
    68d2:	98 83       	st	Y, r25
	MB_Frame[MB_N][1] = MB_SingleQuery[MB_N].Func;
    68d4:	91 81       	ldd	r25, Z+1	; 0x01
    68d6:	99 83       	std	Y+1, r25	; 0x01
	MB_Frame[MB_N][2] = MB_SingleQuery[MB_N].StartAddr>>8;
    68d8:	fd 01       	movw	r30, r26
    68da:	ee 0f       	add	r30, r30
    68dc:	ff 1f       	adc	r31, r31
    68de:	ee 0f       	add	r30, r30
    68e0:	ff 1f       	adc	r31, r31
    68e2:	ee 0f       	add	r30, r30
    68e4:	ff 1f       	adc	r31, r31
    68e6:	32 96       	adiw	r30, 0x02	; 2
    68e8:	e2 0f       	add	r30, r18
    68ea:	f3 1f       	adc	r31, r19
    68ec:	10 81       	ld	r17, Z
    68ee:	91 81       	ldd	r25, Z+1	; 0x01
    68f0:	fa 01       	movw	r30, r20
    68f2:	92 83       	std	Z+2, r25	; 0x02
	MB_Frame[MB_N][3] = MB_SingleQuery[MB_N].StartAddr;
    68f4:	1b 83       	std	Y+3, r17	; 0x03
	MB_Frame[MB_N][4] = MB_SingleQuery[MB_N].Qt>>8;
    68f6:	fd 01       	movw	r30, r26
    68f8:	ee 0f       	add	r30, r30
    68fa:	ff 1f       	adc	r31, r31
    68fc:	ee 0f       	add	r30, r30
    68fe:	ff 1f       	adc	r31, r31
    6900:	ee 0f       	add	r30, r30
    6902:	ff 1f       	adc	r31, r31
    6904:	34 96       	adiw	r30, 0x04	; 4
    6906:	e2 0f       	add	r30, r18
    6908:	f3 1f       	adc	r31, r19
    690a:	10 81       	ld	r17, Z
    690c:	91 81       	ldd	r25, Z+1	; 0x01
    690e:	9c 83       	std	Y+4, r25	; 0x04
	MB_Frame[MB_N][5] = MB_SingleQuery[MB_N].Qt;
    6910:	1d 83       	std	Y+5, r17	; 0x05
	
	MB_SingleState[MB_N] = MB_SingleExec;
    6912:	a1 55       	subi	r26, 0x51	; 81
    6914:	b9 4f       	sbci	r27, 0xF9	; 249
    6916:	92 e0       	ldi	r25, 0x02	; 2
    6918:	9c 93       	st	X, r25
	FormData(MB_N);
    691a:	0e 94 d7 32 	call	0x65ae	; 0x65ae <FormData>
}
    691e:	df 91       	pop	r29
    6920:	cf 91       	pop	r28
    6922:	1f 91       	pop	r17
    6924:	08 95       	ret

00006926 <NextSlave>:

// ~~~~~~~~~~~~~~~~~~~~
static uint8_t
NextSlave(uint8_t MB_N)
{
    6926:	2f 92       	push	r2
    6928:	3f 92       	push	r3
    692a:	4f 92       	push	r4
    692c:	5f 92       	push	r5
    692e:	6f 92       	push	r6
    6930:	7f 92       	push	r7
    6932:	8f 92       	push	r8
    6934:	9f 92       	push	r9
    6936:	af 92       	push	r10
    6938:	bf 92       	push	r11
    693a:	cf 92       	push	r12
    693c:	df 92       	push	r13
    693e:	ef 92       	push	r14
    6940:	ff 92       	push	r15
    6942:	0f 93       	push	r16
    6944:	1f 93       	push	r17
    6946:	df 93       	push	r29
    6948:	cf 93       	push	r28
    694a:	00 d0       	rcall	.+0      	; 0x694c <NextSlave+0x26>
    694c:	00 d0       	rcall	.+0      	; 0x694e <NextSlave+0x28>
    694e:	cd b7       	in	r28, 0x3d	; 61
    6950:	de b7       	in	r29, 0x3e	; 62
    6952:	68 2e       	mov	r6, r24
    6954:	e3 e0       	ldi	r30, 0x03	; 3
    6956:	8e 9f       	mul	r24, r30
    6958:	f0 01       	movw	r30, r0
    695a:	11 24       	eor	r1, r1
    695c:	e3 5b       	subi	r30, 0xB3	; 179
    695e:	f6 4d       	sbci	r31, 0xD6	; 214
    6960:	04 91       	lpm	r16, Z+
    6962:	c8 2e       	mov	r12, r24
    6964:	dd 24       	eor	r13, r13
    6966:	a6 01       	movw	r20, r12
    6968:	4c 5a       	subi	r20, 0xAC	; 172
    696a:	59 4f       	sbci	r21, 0xF9	; 249
    696c:	5e 83       	std	Y+6, r21	; 0x06
    696e:	4d 83       	std	Y+5, r20	; 0x05
    6970:	fa 01       	movw	r30, r20
    6972:	20 81       	ld	r18, Z
    6974:	16 01       	movw	r2, r12
    6976:	22 0c       	add	r2, r2
    6978:	33 1c       	adc	r3, r3
    697a:	22 0c       	add	r2, r2
    697c:	33 1c       	adc	r3, r3
    697e:	f1 01       	movw	r30, r2
    6980:	ec 51       	subi	r30, 0x1C	; 28
    6982:	fb 4f       	sbci	r31, 0xFB	; 251
    6984:	80 80       	ld	r8, Z
    6986:	91 80       	ldd	r9, Z+1	; 0x01
    6988:	a2 80       	ldd	r10, Z+2	; 0x02
    698a:	b3 80       	ldd	r11, Z+3	; 0x03
	do
		if (++CurrSlave[MB_N]==SlaveQt) {
			CurrSlave[MB_N] = 0;
			Over = 1;

			if ((MB_Master_Cycle[MB_N]=0xFFFF-GetTimer16(TD_MB_Cycle+MB_N))>MB_Master_MaxCycle[MB_N])
    698c:	70 90 e8 04 	lds	r7, 0x04E8
    6990:	f2 e0       	ldi	r31, 0x02	; 2
    6992:	7f 0e       	add	r7, r31
    6994:	47 2d       	mov	r20, r7
    6996:	48 0f       	add	r20, r24
    6998:	4a 83       	std	Y+2, r20	; 0x02
    699a:	5e ef       	ldi	r21, 0xFE	; 254
    699c:	75 0e       	add	r7, r21
// ~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
GetTimer16(uint8_t TimerN)
{
	IntOff();
	uint16_t Time = Timer16[TimerN];
    699e:	e4 2e       	mov	r14, r20
    69a0:	ff 24       	eor	r15, r15
    69a2:	19 82       	std	Y+1, r1	; 0x01
    69a4:	10 e0       	ldi	r17, 0x00	; 0
    69a6:	ee 0c       	add	r14, r14
    69a8:	ff 1c       	adc	r15, r15
    69aa:	8f e4       	ldi	r24, 0x4F	; 79
    69ac:	93 e0       	ldi	r25, 0x03	; 3
    69ae:	e8 0e       	add	r14, r24
    69b0:	f9 1e       	adc	r15, r25
    69b2:	c6 01       	movw	r24, r12
    69b4:	88 0f       	add	r24, r24
    69b6:	99 1f       	adc	r25, r25
    69b8:	fc 01       	movw	r30, r24
    69ba:	e8 54       	subi	r30, 0x48	; 72
    69bc:	f8 4f       	sbci	r31, 0xF8	; 248
    69be:	fc 83       	std	Y+4, r31	; 0x04
    69c0:	eb 83       	std	Y+3, r30	; 0x03
    69c2:	ff ef       	ldi	r31, 0xFF	; 255
    69c4:	4f 2e       	mov	r4, r31
    69c6:	f6 e0       	ldi	r31, 0x06	; 6
    69c8:	5f 2e       	mov	r5, r31
    69ca:	48 0e       	add	r4, r24
    69cc:	59 1e       	adc	r5, r25
    69ce:	14 c0       	rjmp	.+40     	; 0x69f8 <NextSlave+0xd2>
				MB_Master_MaxCycle[MB_N] = MB_Master_Cycle[MB_N];
			StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
		}
	while (SlaveSkip[MB_N] &((uint32_t)1<<CurrSlave[MB_N]) && ++i<SlaveQt);
    69d0:	ed 81       	ldd	r30, Y+5	; 0x05
    69d2:	fe 81       	ldd	r31, Y+6	; 0x06
    69d4:	20 81       	ld	r18, Z
    69d6:	d5 01       	movw	r26, r10
    69d8:	c4 01       	movw	r24, r8
    69da:	02 2e       	mov	r0, r18
    69dc:	04 c0       	rjmp	.+8      	; 0x69e6 <NextSlave+0xc0>
    69de:	b6 95       	lsr	r27
    69e0:	a7 95       	ror	r26
    69e2:	97 95       	ror	r25
    69e4:	87 95       	ror	r24
    69e6:	0a 94       	dec	r0
    69e8:	d2 f7       	brpl	.-12     	; 0x69de <NextSlave+0xb8>
    69ea:	81 70       	andi	r24, 0x01	; 1
    69ec:	90 70       	andi	r25, 0x00	; 0
    69ee:	88 23       	and	r24, r24
    69f0:	61 f1       	breq	.+88     	; 0x6a4a <NextSlave+0x124>
    69f2:	1f 5f       	subi	r17, 0xFF	; 255
    69f4:	10 17       	cp	r17, r16
    69f6:	48 f5       	brcc	.+82     	; 0x6a4a <NextSlave+0x124>
{
	uint8_t Over = 0;
	uint8_t i = 0;
	uint8_t SlaveQt = prb(&(MB_Master_List+MB_N)->SlaveQt);
	do
		if (++CurrSlave[MB_N]==SlaveQt) {
    69f8:	82 2f       	mov	r24, r18
    69fa:	8f 5f       	subi	r24, 0xFF	; 255
    69fc:	ed 81       	ldd	r30, Y+5	; 0x05
    69fe:	fe 81       	ldd	r31, Y+6	; 0x06
    6a00:	80 83       	st	Z, r24
    6a02:	80 17       	cp	r24, r16
    6a04:	29 f7       	brne	.-54     	; 0x69d0 <NextSlave+0xaa>
			CurrSlave[MB_N] = 0;
    6a06:	10 82       	st	Z, r1

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    6a08:	8f b7       	in	r24, 0x3f	; 63
    6a0a:	80 78       	andi	r24, 0x80	; 128
    6a0c:	80 93 ee 02 	sts	0x02EE, r24
	cli();
    6a10:	f8 94       	cli
    6a12:	f7 01       	movw	r30, r14
    6a14:	20 81       	ld	r18, Z
    6a16:	31 81       	ldd	r19, Z+1	; 0x01

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    6a18:	88 23       	and	r24, r24
    6a1a:	09 f0       	breq	.+2      	; 0x6a1e <NextSlave+0xf8>
		sei();
    6a1c:	78 94       	sei
			Over = 1;

			if ((MB_Master_Cycle[MB_N]=0xFFFF-GetTimer16(TD_MB_Cycle+MB_N))>MB_Master_MaxCycle[MB_N])
    6a1e:	20 95       	com	r18
    6a20:	30 95       	com	r19
    6a22:	eb 81       	ldd	r30, Y+3	; 0x03
    6a24:	fc 81       	ldd	r31, Y+4	; 0x04
    6a26:	31 83       	std	Z+1, r19	; 0x01
    6a28:	20 83       	st	Z, r18
    6a2a:	f2 01       	movw	r30, r4
    6a2c:	80 81       	ld	r24, Z
    6a2e:	91 81       	ldd	r25, Z+1	; 0x01
    6a30:	82 17       	cp	r24, r18
    6a32:	93 07       	cpc	r25, r19
    6a34:	10 f4       	brcc	.+4      	; 0x6a3a <NextSlave+0x114>
				MB_Master_MaxCycle[MB_N] = MB_Master_Cycle[MB_N];
    6a36:	31 83       	std	Z+1, r19	; 0x01
    6a38:	20 83       	st	Z, r18
			StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
    6a3a:	8a 81       	ldd	r24, Y+2	; 0x02
    6a3c:	6f ef       	ldi	r22, 0xFF	; 255
    6a3e:	7f ef       	ldi	r23, 0xFF	; 255
    6a40:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
    6a44:	f1 e0       	ldi	r31, 0x01	; 1
    6a46:	f9 83       	std	Y+1, r31	; 0x01
    6a48:	c3 cf       	rjmp	.-122    	; 0x69d0 <NextSlave+0xaa>
		}
	while (SlaveSkip[MB_N] &((uint32_t)1<<CurrSlave[MB_N]) && ++i<SlaveQt);
	if (i==SlaveQt) {
    6a4a:	10 17       	cp	r17, r16
    6a4c:	01 f1       	breq	.+64     	; 0x6a8e <NextSlave+0x168>
		SlavesOn(MB_N);
		if (++CurrSlave[MB_N]==SlaveQt)
			CurrSlave[MB_N] = 0;
	}
	CurrQuery[MB_N] = 0;
    6a4e:	45 e5       	ldi	r20, 0x55	; 85
    6a50:	56 e0       	ldi	r21, 0x06	; 6
    6a52:	c4 0e       	add	r12, r20
    6a54:	d5 1e       	adc	r13, r21
    6a56:	f6 01       	movw	r30, r12
    6a58:	10 82       	st	Z, r1
	return Over;
}
    6a5a:	89 81       	ldd	r24, Y+1	; 0x01
    6a5c:	26 96       	adiw	r28, 0x06	; 6
    6a5e:	0f b6       	in	r0, 0x3f	; 63
    6a60:	f8 94       	cli
    6a62:	de bf       	out	0x3e, r29	; 62
    6a64:	0f be       	out	0x3f, r0	; 63
    6a66:	cd bf       	out	0x3d, r28	; 61
    6a68:	cf 91       	pop	r28
    6a6a:	df 91       	pop	r29
    6a6c:	1f 91       	pop	r17
    6a6e:	0f 91       	pop	r16
    6a70:	ff 90       	pop	r15
    6a72:	ef 90       	pop	r14
    6a74:	df 90       	pop	r13
    6a76:	cf 90       	pop	r12
    6a78:	bf 90       	pop	r11
    6a7a:	af 90       	pop	r10
    6a7c:	9f 90       	pop	r9
    6a7e:	8f 90       	pop	r8
    6a80:	7f 90       	pop	r7
    6a82:	6f 90       	pop	r6
    6a84:	5f 90       	pop	r5
    6a86:	4f 90       	pop	r4
    6a88:	3f 90       	pop	r3
    6a8a:	2f 90       	pop	r2
    6a8c:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~
static void
SlavesOn(uint8_t MB_N)
{
	SlaveSkip[MB_N] = 0;
    6a8e:	44 ee       	ldi	r20, 0xE4	; 228
    6a90:	54 e0       	ldi	r21, 0x04	; 4
    6a92:	24 0e       	add	r2, r20
    6a94:	35 1e       	adc	r3, r21
    6a96:	f1 01       	movw	r30, r2
    6a98:	10 82       	st	Z, r1
    6a9a:	11 82       	std	Z+1, r1	; 0x01
    6a9c:	12 82       	std	Z+2, r1	; 0x02
    6a9e:	13 82       	std	Z+3, r1	; 0x03
	StartTimer16(TD_MB_SlaveOff+MB_N, 100*MB_M_TimeOff[MB_N]);
    6aa0:	73 94       	inc	r7
    6aa2:	f6 01       	movw	r30, r12
    6aa4:	e1 52       	subi	r30, 0x21	; 33
    6aa6:	fa 4f       	sbci	r31, 0xFA	; 250
    6aa8:	60 81       	ld	r22, Z
    6aaa:	84 e6       	ldi	r24, 0x64	; 100
    6aac:	68 9f       	mul	r22, r24
    6aae:	b0 01       	movw	r22, r0
    6ab0:	11 24       	eor	r1, r1
    6ab2:	87 2d       	mov	r24, r7
    6ab4:	86 0d       	add	r24, r6
    6ab6:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
			StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
		}
	while (SlaveSkip[MB_N] &((uint32_t)1<<CurrSlave[MB_N]) && ++i<SlaveQt);
	if (i==SlaveQt) {
		SlavesOn(MB_N);
		if (++CurrSlave[MB_N]==SlaveQt)
    6aba:	ed 81       	ldd	r30, Y+5	; 0x05
    6abc:	fe 81       	ldd	r31, Y+6	; 0x06
    6abe:	80 81       	ld	r24, Z
    6ac0:	8f 5f       	subi	r24, 0xFF	; 255
    6ac2:	80 83       	st	Z, r24
    6ac4:	18 17       	cp	r17, r24
    6ac6:	19 f6       	brne	.-122    	; 0x6a4e <NextSlave+0x128>
			CurrSlave[MB_N] = 0;
    6ac8:	10 82       	st	Z, r1
    6aca:	c1 cf       	rjmp	.-126    	; 0x6a4e <NextSlave+0x128>

00006acc <FailSlave>:
}

// ~~~~~~~~~~~~~~~~~~~~
static uint8_t
FailSlave(uint8_t MB_N)
{
    6acc:	ef 92       	push	r14
    6ace:	ff 92       	push	r15
    6ad0:	1f 93       	push	r17
    6ad2:	cf 93       	push	r28
    6ad4:	df 93       	push	r29
    6ad6:	18 2f       	mov	r17, r24
	uint8_t Over = 0;
	if (MB_SingleState[MB_N]==MB_SingleExec)
    6ad8:	68 2f       	mov	r22, r24
    6ada:	70 e0       	ldi	r23, 0x00	; 0
    6adc:	fb 01       	movw	r30, r22
    6ade:	e1 55       	subi	r30, 0x51	; 81
    6ae0:	f9 4f       	sbci	r31, 0xF9	; 249
    6ae2:	80 81       	ld	r24, Z
    6ae4:	82 30       	cpi	r24, 0x02	; 2
    6ae6:	19 f1       	breq	.+70     	; 0x6b2e <FailSlave+0x62>
		MB_SingleState[MB_N] = MB_SingleIdle;
	else{
		MB_CPT[MB_N][4]++;	// -    
    6ae8:	fb 01       	movw	r30, r22
    6aea:	ee 0f       	add	r30, r30
    6aec:	ff 1f       	adc	r31, r31
    6aee:	ee 0f       	add	r30, r30
    6af0:	ff 1f       	adc	r31, r31
    6af2:	ee 0f       	add	r30, r30
    6af4:	ff 1f       	adc	r31, r31
    6af6:	ee 0f       	add	r30, r30
    6af8:	ff 1f       	adc	r31, r31
    6afa:	e2 5c       	subi	r30, 0xC2	; 194
    6afc:	f6 4f       	sbci	r31, 0xF6	; 246
    6afe:	80 81       	ld	r24, Z
    6b00:	91 81       	ldd	r25, Z+1	; 0x01
    6b02:	01 96       	adiw	r24, 0x01	; 1
    6b04:	91 83       	std	Z+1, r25	; 0x01
    6b06:	80 83       	st	Z, r24
		if (++Try[MB_N]==MB_M_Try[MB_N]) {
    6b08:	eb 01       	movw	r28, r22
    6b0a:	cd 51       	subi	r28, 0x1D	; 29
    6b0c:	db 4f       	sbci	r29, 0xFB	; 251
    6b0e:	88 81       	ld	r24, Y
    6b10:	8f 5f       	subi	r24, 0xFF	; 255
    6b12:	88 83       	st	Y, r24
    6b14:	fb 01       	movw	r30, r22
    6b16:	e1 5c       	subi	r30, 0xC1	; 193
    6b18:	f8 4f       	sbci	r31, 0xF8	; 248
    6b1a:	90 81       	ld	r25, Z
    6b1c:	89 17       	cp	r24, r25
    6b1e:	79 f0       	breq	.+30     	; 0x6b3e <FailSlave+0x72>
    6b20:	80 e0       	ldi	r24, 0x00	; 0
			Try[MB_N] = 0;
			Over = NextSlave(MB_N);
		}
	}
	return Over;
}
    6b22:	df 91       	pop	r29
    6b24:	cf 91       	pop	r28
    6b26:	1f 91       	pop	r17
    6b28:	ff 90       	pop	r15
    6b2a:	ef 90       	pop	r14
    6b2c:	08 95       	ret
static uint8_t
FailSlave(uint8_t MB_N)
{
	uint8_t Over = 0;
	if (MB_SingleState[MB_N]==MB_SingleExec)
		MB_SingleState[MB_N] = MB_SingleIdle;
    6b2e:	10 82       	st	Z, r1
    6b30:	80 e0       	ldi	r24, 0x00	; 0
			Try[MB_N] = 0;
			Over = NextSlave(MB_N);
		}
	}
	return Over;
}
    6b32:	df 91       	pop	r29
    6b34:	cf 91       	pop	r28
    6b36:	1f 91       	pop	r17
    6b38:	ff 90       	pop	r15
    6b3a:	ef 90       	pop	r14
    6b3c:	08 95       	ret
	if (MB_SingleState[MB_N]==MB_SingleExec)
		MB_SingleState[MB_N] = MB_SingleIdle;
	else{
		MB_CPT[MB_N][4]++;	// -    
		if (++Try[MB_N]==MB_M_Try[MB_N]) {
			uint32_t S_N = (uint32_t)1<<CurrSlave[MB_N];
    6b3e:	fb 01       	movw	r30, r22
    6b40:	ec 5a       	subi	r30, 0xAC	; 172
    6b42:	f9 4f       	sbci	r31, 0xF9	; 249
    6b44:	21 e0       	ldi	r18, 0x01	; 1
    6b46:	30 e0       	ldi	r19, 0x00	; 0
    6b48:	40 e0       	ldi	r20, 0x00	; 0
    6b4a:	50 e0       	ldi	r21, 0x00	; 0
    6b4c:	00 80       	ld	r0, Z
    6b4e:	04 c0       	rjmp	.+8      	; 0x6b58 <FailSlave+0x8c>
    6b50:	22 0f       	add	r18, r18
    6b52:	33 1f       	adc	r19, r19
    6b54:	44 1f       	adc	r20, r20
    6b56:	55 1f       	adc	r21, r21
    6b58:	0a 94       	dec	r0
    6b5a:	d2 f7       	brpl	.-12     	; 0x6b50 <FailSlave+0x84>
			SlaveOff[MB_N] |=S_N;
    6b5c:	7b 01       	movw	r14, r22
    6b5e:	ee 0c       	add	r14, r14
    6b60:	ff 1c       	adc	r15, r15
    6b62:	ee 0c       	add	r14, r14
    6b64:	ff 1c       	adc	r15, r15
    6b66:	b7 01       	movw	r22, r14
    6b68:	63 5d       	subi	r22, 0xD3	; 211
    6b6a:	76 4f       	sbci	r23, 0xF6	; 246
    6b6c:	fb 01       	movw	r30, r22
    6b6e:	80 81       	ld	r24, Z
    6b70:	91 81       	ldd	r25, Z+1	; 0x01
    6b72:	a2 81       	ldd	r26, Z+2	; 0x02
    6b74:	b3 81       	ldd	r27, Z+3	; 0x03
    6b76:	82 2b       	or	r24, r18
    6b78:	93 2b       	or	r25, r19
    6b7a:	a4 2b       	or	r26, r20
    6b7c:	b5 2b       	or	r27, r21
    6b7e:	80 83       	st	Z, r24
    6b80:	91 83       	std	Z+1, r25	; 0x01
    6b82:	a2 83       	std	Z+2, r26	; 0x02
    6b84:	b3 83       	std	Z+3, r27	; 0x03
			SlaveSkip[MB_N] |=S_N;
    6b86:	f7 01       	movw	r30, r14
    6b88:	ec 51       	subi	r30, 0x1C	; 28
    6b8a:	fb 4f       	sbci	r31, 0xFB	; 251
    6b8c:	80 81       	ld	r24, Z
    6b8e:	91 81       	ldd	r25, Z+1	; 0x01
    6b90:	a2 81       	ldd	r26, Z+2	; 0x02
    6b92:	b3 81       	ldd	r27, Z+3	; 0x03
    6b94:	28 2b       	or	r18, r24
    6b96:	39 2b       	or	r19, r25
    6b98:	4a 2b       	or	r20, r26
    6b9a:	5b 2b       	or	r21, r27
    6b9c:	20 83       	st	Z, r18
    6b9e:	31 83       	std	Z+1, r19	; 0x01
    6ba0:	42 83       	std	Z+2, r20	; 0x02
    6ba2:	53 83       	std	Z+3, r21	; 0x03
			Try[MB_N] = 0;
    6ba4:	18 82       	st	Y, r1
			Over = NextSlave(MB_N);
    6ba6:	81 2f       	mov	r24, r17
    6ba8:	0e 94 93 34 	call	0x6926	; 0x6926 <NextSlave>
		}
	}
	return Over;
}
    6bac:	df 91       	pop	r29
    6bae:	cf 91       	pop	r28
    6bb0:	1f 91       	pop	r17
    6bb2:	ff 90       	pop	r15
    6bb4:	ef 90       	pop	r14
    6bb6:	08 95       	ret

00006bb8 <MB_M_Timer_ISR>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_M_Timer_ISR(uint8_t MB_N)
{
    6bb8:	4f 92       	push	r4
    6bba:	5f 92       	push	r5
    6bbc:	6f 92       	push	r6
    6bbe:	7f 92       	push	r7
    6bc0:	8f 92       	push	r8
    6bc2:	9f 92       	push	r9
    6bc4:	af 92       	push	r10
    6bc6:	bf 92       	push	r11
    6bc8:	cf 92       	push	r12
    6bca:	df 92       	push	r13
    6bcc:	ef 92       	push	r14
    6bce:	ff 92       	push	r15
    6bd0:	0f 93       	push	r16
    6bd2:	1f 93       	push	r17
    6bd4:	cf 93       	push	r28
    6bd6:	df 93       	push	r29
    6bd8:	18 2f       	mov	r17, r24
	switch (MB_State[MB_N]) {
    6bda:	c8 2f       	mov	r28, r24
    6bdc:	d0 e0       	ldi	r29, 0x00	; 0
    6bde:	fe 01       	movw	r30, r28
    6be0:	ee 53       	subi	r30, 0x3E	; 62
    6be2:	fa 4f       	sbci	r31, 0xFA	; 250
    6be4:	80 81       	ld	r24, Z
    6be6:	88 23       	and	r24, r24
    6be8:	f9 f4       	brne	.+62     	; 0x6c28 <MB_M_Timer_ISR+0x70>
	case MB_Initi:
		StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
    6bea:	80 91 e8 04 	lds	r24, 0x04E8
    6bee:	8e 5f       	subi	r24, 0xFE	; 254
    6bf0:	81 0f       	add	r24, r17
    6bf2:	6f ef       	ldi	r22, 0xFF	; 255
    6bf4:	7f ef       	ldi	r23, 0xFF	; 255
    6bf6:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
		FormQuery(MB_N);
    6bfa:	81 2f       	mov	r24, r17
    6bfc:	0e 94 ff 33 	call	0x67fe	; 0x67fe <FormQuery>
		MB_Transm(MB_N);
    6c00:	81 2f       	mov	r24, r17
    6c02:	0e 94 f7 2c 	call	0x59ee	; 0x59ee <MB_Transm>
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
		MB_M_CtrlProc(MB_N);
		break;
	}
}
    6c06:	df 91       	pop	r29
    6c08:	cf 91       	pop	r28
    6c0a:	1f 91       	pop	r17
    6c0c:	0f 91       	pop	r16
    6c0e:	ff 90       	pop	r15
    6c10:	ef 90       	pop	r14
    6c12:	df 90       	pop	r13
    6c14:	cf 90       	pop	r12
    6c16:	bf 90       	pop	r11
    6c18:	af 90       	pop	r10
    6c1a:	9f 90       	pop	r9
    6c1c:	8f 90       	pop	r8
    6c1e:	7f 90       	pop	r7
    6c20:	6f 90       	pop	r6
    6c22:	5f 90       	pop	r5
    6c24:	4f 90       	pop	r4
    6c26:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_M_Timer_ISR(uint8_t MB_N)
{
	switch (MB_State[MB_N]) {
    6c28:	82 30       	cpi	r24, 0x02	; 2
    6c2a:	69 f7       	brne	.-38     	; 0x6c06 <MB_M_Timer_ISR+0x4e>
		StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
		FormQuery(MB_N);
		MB_Transm(MB_N);
		break;
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
    6c2c:	84 e0       	ldi	r24, 0x04	; 4
    6c2e:	80 83       	st	Z, r24
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
MB_M_CtrlProc(uint8_t MB_N)
{
	uint8_t Over = 0;
	LastProcSingle = MB_SingleState[MB_N]==MB_SingleExec;
    6c30:	ef ea       	ldi	r30, 0xAF	; 175
    6c32:	ae 2e       	mov	r10, r30
    6c34:	e6 e0       	ldi	r30, 0x06	; 6
    6c36:	be 2e       	mov	r11, r30
    6c38:	ac 0e       	add	r10, r28
    6c3a:	bd 1e       	adc	r11, r29
    6c3c:	d5 01       	movw	r26, r10
    6c3e:	8c 91       	ld	r24, X
    6c40:	90 e0       	ldi	r25, 0x00	; 0
    6c42:	82 30       	cpi	r24, 0x02	; 2
    6c44:	09 f4       	brne	.+2      	; 0x6c48 <MB_M_Timer_ISR+0x90>
    6c46:	4e c0       	rjmp	.+156    	; 0x6ce4 <MB_M_Timer_ISR+0x12c>
    6c48:	90 93 e2 04 	sts	0x04E2, r25
	if (CommErr(MB_N))
    6c4c:	81 2f       	mov	r24, r17
    6c4e:	0e 94 db 2d 	call	0x5bb6	; 0x5bb6 <CommErr>
    6c52:	88 23       	and	r24, r24
    6c54:	91 f5       	brne	.+100    	; 0x6cba <MB_M_Timer_ISR+0x102>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6c56:	7e 01       	movw	r14, r28
    6c58:	ee 0c       	add	r14, r14
    6c5a:	ff 1c       	adc	r15, r15
    6c5c:	ee 0c       	add	r14, r14
    6c5e:	ff 1c       	adc	r15, r15
    6c60:	c7 01       	movw	r24, r14
    6c62:	88 0f       	add	r24, r24
    6c64:	99 1f       	adc	r25, r25
    6c66:	88 0f       	add	r24, r24
    6c68:	99 1f       	adc	r25, r25
    6c6a:	8e 0d       	add	r24, r14
    6c6c:	9f 1d       	adc	r25, r15
    6c6e:	8a 58       	subi	r24, 0x8A	; 138
    6c70:	9b 4c       	sbci	r25, 0xCB	; 203
    6c72:	fc 01       	movw	r30, r24
    6c74:	25 91       	lpm	r18, Z+
    6c76:	34 91       	lpm	r19, Z+
		Over = FailSlave(MB_N);
	else {
		USART_Func(MB_N, LED);
    6c78:	f9 01       	movw	r30, r18
    6c7a:	19 95       	eicall
		MB_Slave *Slave;
		MB_Query *Query;
		uint8_t Addr, Func;
		if (LastProcSingle) {
    6c7c:	80 91 e2 04 	lds	r24, 0x04E2
    6c80:	88 23       	and	r24, r24
    6c82:	91 f1       	breq	.+100    	; 0x6ce8 <MB_M_Timer_ISR+0x130>
			Addr = MB_SingleQuery[MB_N].Addr;
    6c84:	fe 01       	movw	r30, r28
    6c86:	ee 0f       	add	r30, r30
    6c88:	ff 1f       	adc	r31, r31
    6c8a:	ee 0f       	add	r30, r30
    6c8c:	ff 1f       	adc	r31, r31
    6c8e:	ee 0f       	add	r30, r30
    6c90:	ff 1f       	adc	r31, r31
    6c92:	e6 52       	subi	r30, 0x26	; 38
    6c94:	fb 4f       	sbci	r31, 0xFB	; 251
    6c96:	20 81       	ld	r18, Z
			Func = MB_SingleQuery[MB_N].Func;
    6c98:	91 81       	ldd	r25, Z+1	; 0x01
    6c9a:	40 e0       	ldi	r20, 0x00	; 0
    6c9c:	50 e0       	ldi	r21, 0x00	; 0
    6c9e:	60 e0       	ldi	r22, 0x00	; 0
    6ca0:	70 e0       	ldi	r23, 0x00	; 0
			Slave = GetSlave(MB_N);
			Query = (MB_Query*)prp(&Slave->QueryList)+CurrQuery[MB_N];
			Addr = prb(&Slave->Addr);
			Func = prb(&Query->Func);
		}
		if (MB_Frame[MB_N][0]!=Addr || MB_Frame[MB_N][1]!=Func)
    6ca2:	dc 2e       	mov	r13, r28
    6ca4:	cc 24       	eor	r12, r12
    6ca6:	f6 01       	movw	r30, r12
    6ca8:	e5 59       	subi	r30, 0x95	; 149
    6caa:	f4 4f       	sbci	r31, 0xF4	; 244
    6cac:	80 81       	ld	r24, Z
    6cae:	82 17       	cp	r24, r18
    6cb0:	21 f4       	brne	.+8      	; 0x6cba <MB_M_Timer_ISR+0x102>
    6cb2:	a1 81       	ldd	r26, Z+1	; 0x01
    6cb4:	a9 17       	cp	r26, r25
    6cb6:	09 f4       	brne	.+2      	; 0x6cba <MB_M_Timer_ISR+0x102>
    6cb8:	3d c0       	rjmp	.+122    	; 0x6d34 <MB_M_Timer_ISR+0x17c>
				Err = MB_M_Force(MB_N, Query);
				break;
			}
			if (Err) {
				MB_CPT[MB_N][2]++;
				Over = FailSlave(MB_N);
    6cba:	81 2f       	mov	r24, r17
    6cbc:	0e 94 66 35 	call	0x6acc	; 0x6acc <FailSlave>
    6cc0:	98 2f       	mov	r25, r24
			}
		}
		/*if (Over)
			USART_Func(MB_N, LED);*/
	}
	StartTimer16(TD_MB_Idle+MB_N, Over?MB_M_Period[MB_N]:MB_M_Pause_Min);
    6cc2:	80 91 e8 04 	lds	r24, 0x04E8
    6cc6:	81 0f       	add	r24, r17
    6cc8:	99 23       	and	r25, r25
    6cca:	49 f0       	breq	.+18     	; 0x6cde <MB_M_Timer_ISR+0x126>
    6ccc:	cc 0f       	add	r28, r28
    6cce:	dd 1f       	adc	r29, r29
    6cd0:	c3 55       	subi	r28, 0x53	; 83
    6cd2:	d9 4f       	sbci	r29, 0xF9	; 249
    6cd4:	68 81       	ld	r22, Y
    6cd6:	79 81       	ldd	r23, Y+1	; 0x01
    6cd8:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
    6cdc:	94 cf       	rjmp	.-216    	; 0x6c06 <MB_M_Timer_ISR+0x4e>
    6cde:	65 e0       	ldi	r22, 0x05	; 5
    6ce0:	70 e0       	ldi	r23, 0x00	; 0
    6ce2:	fa cf       	rjmp	.-12     	; 0x6cd8 <MB_M_Timer_ISR+0x120>
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
MB_M_CtrlProc(uint8_t MB_N)
{
	uint8_t Over = 0;
	LastProcSingle = MB_SingleState[MB_N]==MB_SingleExec;
    6ce4:	91 e0       	ldi	r25, 0x01	; 1
    6ce6:	b0 cf       	rjmp	.-160    	; 0x6c48 <MB_M_Timer_ISR+0x90>
    6ce8:	83 e0       	ldi	r24, 0x03	; 3
    6cea:	18 9f       	mul	r17, r24
    6cec:	f0 01       	movw	r30, r0
    6cee:	11 24       	eor	r1, r1
    6cf0:	e5 5b       	subi	r30, 0xB5	; 181
    6cf2:	f6 4d       	sbci	r31, 0xD6	; 214
    6cf4:	65 91       	lpm	r22, Z+
    6cf6:	74 91       	lpm	r23, Z+

// ~~~~~~~~~~~~~~~~~~~
static MB_Slave*
GetSlave(uint8_t MB_N)
{
	return (MB_Slave*)prp(&(MB_Master_List+MB_N)->SlaveList)+CurrSlave[MB_N];
    6cf8:	fe 01       	movw	r30, r28
    6cfa:	ec 5a       	subi	r30, 0xAC	; 172
    6cfc:	f9 4f       	sbci	r31, 0xF9	; 249
    6cfe:	80 81       	ld	r24, Z
    6d00:	90 e0       	ldi	r25, 0x00	; 0
    6d02:	88 0f       	add	r24, r24
    6d04:	99 1f       	adc	r25, r25
    6d06:	88 0f       	add	r24, r24
    6d08:	99 1f       	adc	r25, r25
    6d0a:	68 0f       	add	r22, r24
    6d0c:	79 1f       	adc	r23, r25
    6d0e:	fb 01       	movw	r30, r22
    6d10:	31 96       	adiw	r30, 0x01	; 1
    6d12:	45 91       	lpm	r20, Z+
    6d14:	54 91       	lpm	r21, Z+
			Addr = MB_SingleQuery[MB_N].Addr;
			Func = MB_SingleQuery[MB_N].Func;
		}
		else {
			Slave = GetSlave(MB_N);
			Query = (MB_Query*)prp(&Slave->QueryList)+CurrQuery[MB_N];
    6d16:	fe 01       	movw	r30, r28
    6d18:	eb 5a       	subi	r30, 0xAB	; 171
    6d1a:	f9 4f       	sbci	r31, 0xF9	; 249
    6d1c:	80 81       	ld	r24, Z
    6d1e:	27 e0       	ldi	r18, 0x07	; 7
    6d20:	82 9f       	mul	r24, r18
    6d22:	c0 01       	movw	r24, r0
    6d24:	11 24       	eor	r1, r1
    6d26:	48 0f       	add	r20, r24
    6d28:	59 1f       	adc	r21, r25

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    6d2a:	fb 01       	movw	r30, r22
    6d2c:	24 91       	lpm	r18, Z+
		}
		if (MB_Frame[MB_N][0]!=Addr || MB_Frame[MB_N][1]!=Func)
			Over = FailSlave(MB_N);
		else {
			uint8_t Err;
			switch (Func) {
    6d2e:	fa 01       	movw	r30, r20
    6d30:	94 91       	lpm	r25, Z+
    6d32:	b7 cf       	rjmp	.-146    	; 0x6ca2 <MB_M_Timer_ISR+0xea>
    6d34:	95 30       	cpi	r25, 0x05	; 5
    6d36:	18 f5       	brcc	.+70     	; 0x6d7e <MB_M_Timer_ISR+0x1c6>
    6d38:	93 30       	cpi	r25, 0x03	; 3
    6d3a:	08 f4       	brcc	.+2      	; 0x6d3e <MB_M_Timer_ISR+0x186>
    6d3c:	ad c0       	rjmp	.+346    	; 0x6e98 <MB_M_Timer_ISR+0x2e0>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_M_ReadReg(uint8_t MB_N, MB_Query *Query)
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || (LastProcSingle?MB_SingleQuery[MB_N].Qt:prw(&Query->Qt))*2!=MB_Frame[MB_N][2])
    6d3e:	fc 2f       	mov	r31, r28
    6d40:	ee 27       	eor	r30, r30
    6d42:	e3 59       	subi	r30, 0x93	; 147
    6d44:	f4 4f       	sbci	r31, 0xF4	; 244
    6d46:	b0 81       	ld	r27, Z
    6d48:	fe 01       	movw	r30, r28
    6d4a:	e7 5b       	subi	r30, 0xB7	; 183
    6d4c:	f8 4f       	sbci	r31, 0xF8	; 248
    6d4e:	80 81       	ld	r24, Z
    6d50:	90 e0       	ldi	r25, 0x00	; 0
    6d52:	8b 2e       	mov	r8, r27
    6d54:	99 24       	eor	r9, r9
    6d56:	94 01       	movw	r18, r8
    6d58:	2b 5f       	subi	r18, 0xFB	; 251
    6d5a:	3f 4f       	sbci	r19, 0xFF	; 255
    6d5c:	82 17       	cp	r24, r18
    6d5e:	93 07       	cpc	r25, r19
    6d60:	09 f4       	brne	.+2      	; 0x6d64 <MB_M_Timer_ISR+0x1ac>
    6d62:	94 c1       	rjmp	.+808    	; 0x708c <MB_M_Timer_ISR+0x4d4>
			case 0x0F: case 0x10:
				Err = MB_M_Force(MB_N, Query);
				break;
			}
			if (Err) {
				MB_CPT[MB_N][2]++;
    6d64:	f7 01       	movw	r30, r14
    6d66:	ee 0f       	add	r30, r30
    6d68:	ff 1f       	adc	r31, r31
    6d6a:	ee 0f       	add	r30, r30
    6d6c:	ff 1f       	adc	r31, r31
    6d6e:	e6 5c       	subi	r30, 0xC6	; 198
    6d70:	f6 4f       	sbci	r31, 0xF6	; 246
    6d72:	80 81       	ld	r24, Z
    6d74:	91 81       	ldd	r25, Z+1	; 0x01
    6d76:	01 96       	adiw	r24, 0x01	; 1
    6d78:	91 83       	std	Z+1, r25	; 0x01
    6d7a:	80 83       	st	Z, r24
    6d7c:	9e cf       	rjmp	.-196    	; 0x6cba <MB_M_Timer_ISR+0x102>
		}
		if (MB_Frame[MB_N][0]!=Addr || MB_Frame[MB_N][1]!=Func)
			Over = FailSlave(MB_N);
		else {
			uint8_t Err;
			switch (Func) {
    6d7e:	96 30       	cpi	r25, 0x06	; 6
    6d80:	09 f4       	brne	.+2      	; 0x6d84 <MB_M_Timer_ISR+0x1cc>
    6d82:	18 c1       	rjmp	.+560    	; 0x6fb4 <MB_M_Timer_ISR+0x3fc>
    6d84:	96 30       	cpi	r25, 0x06	; 6
    6d86:	08 f4       	brcc	.+2      	; 0x6d8a <MB_M_Timer_ISR+0x1d2>
    6d88:	43 c0       	rjmp	.+134    	; 0x6e10 <MB_M_Timer_ISR+0x258>
    6d8a:	9f 50       	subi	r25, 0x0F	; 15
    6d8c:	92 30       	cpi	r25, 0x02	; 2
    6d8e:	08 f0       	brcs	.+2      	; 0x6d92 <MB_M_Timer_ISR+0x1da>
    6d90:	3f c0       	rjmp	.+126    	; 0x6e10 <MB_M_Timer_ISR+0x258>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_M_Force(uint8_t MB_N, MB_Query *Query)
{
	uint16_t StartAddr, Qt;
	if (LastProcSingle) {
    6d92:	80 91 e2 04 	lds	r24, 0x04E2
    6d96:	88 23       	and	r24, r24
    6d98:	09 f4       	brne	.+2      	; 0x6d9c <MB_M_Timer_ISR+0x1e4>
    6d9a:	4e c1       	rjmp	.+668    	; 0x7038 <MB_M_Timer_ISR+0x480>
		StartAddr	= MB_SingleQuery[MB_N].StartAddr;
    6d9c:	f7 01       	movw	r30, r14
    6d9e:	ee 0f       	add	r30, r30
    6da0:	ff 1f       	adc	r31, r31
    6da2:	e4 52       	subi	r30, 0x24	; 36
    6da4:	fb 4f       	sbci	r31, 0xFB	; 251
    6da6:	80 80       	ld	r8, Z
    6da8:	91 80       	ldd	r9, Z+1	; 0x01
		Qt				= MB_SingleQuery[MB_N].Qt;
    6daa:	fe 01       	movw	r30, r28
    6dac:	ee 0f       	add	r30, r30
    6dae:	ff 1f       	adc	r31, r31
    6db0:	ee 0f       	add	r30, r30
    6db2:	ff 1f       	adc	r31, r31
    6db4:	ee 0f       	add	r30, r30
    6db6:	ff 1f       	adc	r31, r31
    6db8:	e2 52       	subi	r30, 0x22	; 34
    6dba:	fb 4f       	sbci	r31, 0xFB	; 251
    6dbc:	40 81       	ld	r20, Z
    6dbe:	51 81       	ldd	r21, Z+1	; 0x01
	}
	else {
		StartAddr	= prw(&Query->StartAddr);
		Qt				= prw(&Query->Qt);
	}
	return MB_Frame_Sz[MB_N]!=8 || MB_FrameReg(MB_N, 2)!=StartAddr || MB_FrameReg(MB_N, 4)!=Qt;
    6dc0:	fe 01       	movw	r30, r28
    6dc2:	e7 5b       	subi	r30, 0xB7	; 183
    6dc4:	f8 4f       	sbci	r31, 0xF8	; 248
    6dc6:	80 81       	ld	r24, Z
    6dc8:	88 30       	cpi	r24, 0x08	; 8
    6dca:	61 f6       	brne	.-104    	; 0x6d64 <MB_M_Timer_ISR+0x1ac>
    6dcc:	fc 2f       	mov	r31, r28
    6dce:	ee 27       	eor	r30, r30
    6dd0:	e3 59       	subi	r30, 0x93	; 147
    6dd2:	f4 4f       	sbci	r31, 0xF4	; 244
    6dd4:	30 81       	ld	r19, Z
    6dd6:	20 e0       	ldi	r18, 0x00	; 0
    6dd8:	d6 01       	movw	r26, r12
    6dda:	a5 59       	subi	r26, 0x95	; 149
    6ddc:	b4 4f       	sbci	r27, 0xF4	; 244
    6dde:	13 96       	adiw	r26, 0x03	; 3
    6de0:	8c 91       	ld	r24, X
    6de2:	13 97       	sbiw	r26, 0x03	; 3
    6de4:	90 e0       	ldi	r25, 0x00	; 0
    6de6:	28 2b       	or	r18, r24
    6de8:	39 2b       	or	r19, r25
    6dea:	28 15       	cp	r18, r8
    6dec:	39 05       	cpc	r19, r9
    6dee:	09 f0       	breq	.+2      	; 0x6df2 <MB_M_Timer_ISR+0x23a>
    6df0:	b9 cf       	rjmp	.-142    	; 0x6d64 <MB_M_Timer_ISR+0x1ac>
    6df2:	fc 2f       	mov	r31, r28
    6df4:	ee 27       	eor	r30, r30
    6df6:	e1 59       	subi	r30, 0x91	; 145
    6df8:	f4 4f       	sbci	r31, 0xF4	; 244
    6dfa:	90 81       	ld	r25, Z
    6dfc:	80 e0       	ldi	r24, 0x00	; 0
    6dfe:	15 96       	adiw	r26, 0x05	; 5
    6e00:	2c 91       	ld	r18, X
    6e02:	30 e0       	ldi	r19, 0x00	; 0
    6e04:	82 2b       	or	r24, r18
    6e06:	93 2b       	or	r25, r19
    6e08:	84 17       	cp	r24, r20
    6e0a:	95 07       	cpc	r25, r21
    6e0c:	09 f0       	breq	.+2      	; 0x6e10 <MB_M_Timer_ISR+0x258>
    6e0e:	aa cf       	rjmp	.-172    	; 0x6d64 <MB_M_Timer_ISR+0x1ac>
			}
			if (Err) {
				MB_CPT[MB_N][2]++;
				Over = FailSlave(MB_N);
			}
			else if (LastProcSingle)
    6e10:	80 91 e2 04 	lds	r24, 0x04E2
    6e14:	88 23       	and	r24, r24
    6e16:	41 f0       	breq	.+16     	; 0x6e28 <MB_M_Timer_ISR+0x270>
				MB_SingleState[MB_N] = MB_SingleIdle;
    6e18:	d5 01       	movw	r26, r10
    6e1a:	1c 92       	st	X, r1
			}
		}
		/*if (Over)
			USART_Func(MB_N, LED);*/
	}
	StartTimer16(TD_MB_Idle+MB_N, Over?MB_M_Period[MB_N]:MB_M_Pause_Min);
    6e1c:	80 91 e8 04 	lds	r24, 0x04E8
    6e20:	81 0f       	add	r24, r17
    6e22:	65 e0       	ldi	r22, 0x05	; 5
    6e24:	70 e0       	ldi	r23, 0x00	; 0
    6e26:	58 cf       	rjmp	.-336    	; 0x6cd8 <MB_M_Timer_ISR+0x120>
				Over = FailSlave(MB_N);
			}
			else if (LastProcSingle)
				MB_SingleState[MB_N] = MB_SingleIdle;
			else {
				SlaveOff[MB_N] &=~((uint32_t)1<<CurrSlave[MB_N]);
    6e28:	ed e2       	ldi	r30, 0x2D	; 45
    6e2a:	f9 e0       	ldi	r31, 0x09	; 9
    6e2c:	ee 0e       	add	r14, r30
    6e2e:	ff 1e       	adc	r15, r31
    6e30:	9e 01       	movw	r18, r28
    6e32:	2c 5a       	subi	r18, 0xAC	; 172
    6e34:	39 4f       	sbci	r19, 0xF9	; 249
    6e36:	81 e0       	ldi	r24, 0x01	; 1
    6e38:	90 e0       	ldi	r25, 0x00	; 0
    6e3a:	a0 e0       	ldi	r26, 0x00	; 0
    6e3c:	b0 e0       	ldi	r27, 0x00	; 0
    6e3e:	f9 01       	movw	r30, r18
    6e40:	00 80       	ld	r0, Z
    6e42:	04 c0       	rjmp	.+8      	; 0x6e4c <MB_M_Timer_ISR+0x294>
    6e44:	88 0f       	add	r24, r24
    6e46:	99 1f       	adc	r25, r25
    6e48:	aa 1f       	adc	r26, r26
    6e4a:	bb 1f       	adc	r27, r27
    6e4c:	0a 94       	dec	r0
    6e4e:	d2 f7       	brpl	.-12     	; 0x6e44 <MB_M_Timer_ISR+0x28c>
    6e50:	80 95       	com	r24
    6e52:	90 95       	com	r25
    6e54:	a0 95       	com	r26
    6e56:	b0 95       	com	r27
    6e58:	f7 01       	movw	r30, r14
    6e5a:	20 81       	ld	r18, Z
    6e5c:	31 81       	ldd	r19, Z+1	; 0x01
    6e5e:	42 81       	ldd	r20, Z+2	; 0x02
    6e60:	53 81       	ldd	r21, Z+3	; 0x03
    6e62:	82 23       	and	r24, r18
    6e64:	93 23       	and	r25, r19
    6e66:	a4 23       	and	r26, r20
    6e68:	b5 23       	and	r27, r21
    6e6a:	80 83       	st	Z, r24
    6e6c:	91 83       	std	Z+1, r25	; 0x01
    6e6e:	a2 83       	std	Z+2, r26	; 0x02
    6e70:	b3 83       	std	Z+3, r27	; 0x03
				if (++CurrQuery[MB_N]==prb(&Slave->QueryQt))
    6e72:	fe 01       	movw	r30, r28
    6e74:	eb 5a       	subi	r30, 0xAB	; 171
    6e76:	f9 4f       	sbci	r31, 0xF9	; 249
    6e78:	80 81       	ld	r24, Z
    6e7a:	8f 5f       	subi	r24, 0xFF	; 255
    6e7c:	80 83       	st	Z, r24
    6e7e:	6d 5f       	subi	r22, 0xFD	; 253
    6e80:	7f 4f       	sbci	r23, 0xFF	; 255
    6e82:	fb 01       	movw	r30, r22
    6e84:	94 91       	lpm	r25, Z+
    6e86:	89 17       	cp	r24, r25
    6e88:	09 f4       	brne	.+2      	; 0x6e8c <MB_M_Timer_ISR+0x2d4>
    6e8a:	55 c1       	rjmp	.+682    	; 0x7136 <MB_M_Timer_ISR+0x57e>
    6e8c:	90 e0       	ldi	r25, 0x00	; 0
					Over = NextSlave(MB_N);
				Try[MB_N] = 0;
    6e8e:	fe 01       	movw	r30, r28
    6e90:	ed 51       	subi	r30, 0x1D	; 29
    6e92:	fb 4f       	sbci	r31, 0xFB	; 251
    6e94:	10 82       	st	Z, r1
    6e96:	15 cf       	rjmp	.-470    	; 0x6cc2 <MB_M_Timer_ISR+0x10a>
		}
		if (MB_Frame[MB_N][0]!=Addr || MB_Frame[MB_N][1]!=Func)
			Over = FailSlave(MB_N);
		else {
			uint8_t Err;
			switch (Func) {
    6e98:	91 30       	cpi	r25, 0x01	; 1
    6e9a:	08 f4       	brcc	.+2      	; 0x6e9e <MB_M_Timer_ISR+0x2e6>
    6e9c:	b9 cf       	rjmp	.-142    	; 0x6e10 <MB_M_Timer_ISR+0x258>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_M_ReadDiscr(uint8_t MB_N, MB_Query *Query)
{
	uint8_t Qt = LastProcSingle ? MB_SingleQuery[MB_N].Qt : prb((uint8_t*)&Query->Qt);
    6e9e:	80 91 e2 04 	lds	r24, 0x04E2
    6ea2:	88 23       	and	r24, r24
    6ea4:	09 f4       	brne	.+2      	; 0x6ea8 <MB_M_Timer_ISR+0x2f0>
    6ea6:	eb c0       	rjmp	.+470    	; 0x707e <MB_M_Timer_ISR+0x4c6>
    6ea8:	fe 01       	movw	r30, r28
    6eaa:	ee 0f       	add	r30, r30
    6eac:	ff 1f       	adc	r31, r31
    6eae:	ee 0f       	add	r30, r30
    6eb0:	ff 1f       	adc	r31, r31
    6eb2:	ee 0f       	add	r30, r30
    6eb4:	ff 1f       	adc	r31, r31
    6eb6:	e2 52       	subi	r30, 0x22	; 34
    6eb8:	fb 4f       	sbci	r31, 0xFB	; 251
    6eba:	b0 81       	ld	r27, Z
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || Qt/8+((Qt%8)>0)!=MB_Frame[MB_N][2])
    6ebc:	fc 2f       	mov	r31, r28
    6ebe:	ee 27       	eor	r30, r30
    6ec0:	e3 59       	subi	r30, 0x93	; 147
    6ec2:	f4 4f       	sbci	r31, 0xF4	; 244
    6ec4:	80 81       	ld	r24, Z
    6ec6:	88 2e       	mov	r8, r24
    6ec8:	99 24       	eor	r9, r9
    6eca:	fe 01       	movw	r30, r28
    6ecc:	e7 5b       	subi	r30, 0xB7	; 183
    6ece:	f8 4f       	sbci	r31, 0xF8	; 248
    6ed0:	80 81       	ld	r24, Z
    6ed2:	90 e0       	ldi	r25, 0x00	; 0
    6ed4:	94 01       	movw	r18, r8
    6ed6:	2b 5f       	subi	r18, 0xFB	; 251
    6ed8:	3f 4f       	sbci	r19, 0xFF	; 255
    6eda:	82 17       	cp	r24, r18
    6edc:	93 07       	cpc	r25, r19
    6ede:	09 f0       	breq	.+2      	; 0x6ee2 <MB_M_Timer_ISR+0x32a>
    6ee0:	41 cf       	rjmp	.-382    	; 0x6d64 <MB_M_Timer_ISR+0x1ac>
    6ee2:	20 e0       	ldi	r18, 0x00	; 0
    6ee4:	30 e0       	ldi	r19, 0x00	; 0
    6ee6:	6b 2e       	mov	r6, r27
    6ee8:	77 24       	eor	r7, r7
    6eea:	c3 01       	movw	r24, r6
    6eec:	87 70       	andi	r24, 0x07	; 7
    6eee:	90 70       	andi	r25, 0x00	; 0
    6ef0:	18 16       	cp	r1, r24
    6ef2:	19 06       	cpc	r1, r25
    6ef4:	14 f4       	brge	.+4      	; 0x6efa <MB_M_Timer_ISR+0x342>
    6ef6:	21 e0       	ldi	r18, 0x01	; 1
    6ef8:	30 e0       	ldi	r19, 0x00	; 0
    6efa:	b6 95       	lsr	r27
    6efc:	b6 95       	lsr	r27
    6efe:	b6 95       	lsr	r27
    6f00:	2b 0f       	add	r18, r27
    6f02:	31 1d       	adc	r19, r1
    6f04:	82 16       	cp	r8, r18
    6f06:	93 06       	cpc	r9, r19
    6f08:	09 f0       	breq	.+2      	; 0x6f0c <MB_M_Timer_ISR+0x354>
    6f0a:	2c cf       	rjmp	.-424    	; 0x6d64 <MB_M_Timer_ISR+0x1ac>
		return 1;
	uint8_t *Discr;
	uint8_t Pin;
	if (LastProcSingle) {
    6f0c:	80 91 e2 04 	lds	r24, 0x04E2
    6f10:	88 23       	and	r24, r24
    6f12:	09 f4       	brne	.+2      	; 0x6f16 <MB_M_Timer_ISR+0x35e>
    6f14:	1d c1       	rjmp	.+570    	; 0x7150 <MB_M_Timer_ISR+0x598>
		Discr = MB_SingleQuery[MB_N].Buf;
    6f16:	fe 01       	movw	r30, r28
    6f18:	ee 0f       	add	r30, r30
    6f1a:	ff 1f       	adc	r31, r31
    6f1c:	ee 0f       	add	r30, r30
    6f1e:	ff 1f       	adc	r31, r31
    6f20:	ee 0f       	add	r30, r30
    6f22:	ff 1f       	adc	r31, r31
    6f24:	e6 52       	subi	r30, 0x26	; 38
    6f26:	fb 4f       	sbci	r31, 0xFB	; 251
    6f28:	86 80       	ldd	r8, Z+6	; 0x06
    6f2a:	97 80       	ldd	r9, Z+7	; 0x07
    6f2c:	00 e0       	ldi	r16, 0x00	; 0
	}
	else {
		Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
		Pin = prw(&Query->AllocAddr);
	}
	for (uint16_t i=0; i<Qt; i++) {
    6f2e:	61 14       	cp	r6, r1
    6f30:	71 04       	cpc	r7, r1
    6f32:	09 f4       	brne	.+2      	; 0x6f36 <MB_M_Timer_ISR+0x37e>
    6f34:	6d cf       	rjmp	.-294    	; 0x6e10 <MB_M_Timer_ISR+0x258>
    6f36:	40 e0       	ldi	r20, 0x00	; 0
    6f38:	50 e0       	ldi	r21, 0x00	; 0
		uint8_t j = Pin+i;
		uint8_t Byte=j/8, Bit=1<<j%8;
    6f3a:	21 e0       	ldi	r18, 0x01	; 1
    6f3c:	42 2e       	mov	r4, r18
    6f3e:	51 2c       	mov	r5, r1
		if (MB_Frame[MB_N][3+i/8] &(1<<i%8))
    6f40:	8b e6       	ldi	r24, 0x6B	; 107
    6f42:	9b e0       	ldi	r25, 0x0B	; 11
    6f44:	c8 0e       	add	r12, r24
    6f46:	d9 1e       	adc	r13, r25
    6f48:	0c c0       	rjmp	.+24     	; 0x6f62 <MB_M_Timer_ISR+0x3aa>
			Discr[Byte] |=Bit;
    6f4a:	f4 01       	movw	r30, r8
    6f4c:	eb 0f       	add	r30, r27
    6f4e:	f1 1d       	adc	r31, r1
    6f50:	80 81       	ld	r24, Z
    6f52:	8a 2b       	or	r24, r26
    6f54:	80 83       	st	Z, r24
	}
	else {
		Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
		Pin = prw(&Query->AllocAddr);
	}
	for (uint16_t i=0; i<Qt; i++) {
    6f56:	4f 5f       	subi	r20, 0xFF	; 255
    6f58:	5f 4f       	sbci	r21, 0xFF	; 255
    6f5a:	46 15       	cp	r20, r6
    6f5c:	57 05       	cpc	r21, r7
    6f5e:	08 f0       	brcs	.+2      	; 0x6f62 <MB_M_Timer_ISR+0x3aa>
    6f60:	57 cf       	rjmp	.-338    	; 0x6e10 <MB_M_Timer_ISR+0x258>
    6f62:	80 2f       	mov	r24, r16
    6f64:	84 0f       	add	r24, r20
		uint8_t j = Pin+i;
		uint8_t Byte=j/8, Bit=1<<j%8;
    6f66:	b8 2f       	mov	r27, r24
    6f68:	b6 95       	lsr	r27
    6f6a:	b6 95       	lsr	r27
    6f6c:	b6 95       	lsr	r27
    6f6e:	87 70       	andi	r24, 0x07	; 7
    6f70:	a4 2d       	mov	r26, r4
    6f72:	01 c0       	rjmp	.+2      	; 0x6f76 <MB_M_Timer_ISR+0x3be>
    6f74:	aa 0f       	add	r26, r26
    6f76:	8a 95       	dec	r24
    6f78:	ea f7       	brpl	.-6      	; 0x6f74 <MB_M_Timer_ISR+0x3bc>
		if (MB_Frame[MB_N][3+i/8] &(1<<i%8))
    6f7a:	fa 01       	movw	r30, r20
    6f7c:	f6 95       	lsr	r31
    6f7e:	e7 95       	ror	r30
    6f80:	f6 95       	lsr	r31
    6f82:	e7 95       	ror	r30
    6f84:	f6 95       	lsr	r31
    6f86:	e7 95       	ror	r30
    6f88:	ec 0d       	add	r30, r12
    6f8a:	fd 1d       	adc	r31, r13
    6f8c:	83 81       	ldd	r24, Z+3	; 0x03
    6f8e:	90 e0       	ldi	r25, 0x00	; 0
    6f90:	9a 01       	movw	r18, r20
    6f92:	27 70       	andi	r18, 0x07	; 7
    6f94:	30 70       	andi	r19, 0x00	; 0
    6f96:	02 c0       	rjmp	.+4      	; 0x6f9c <MB_M_Timer_ISR+0x3e4>
    6f98:	95 95       	asr	r25
    6f9a:	87 95       	ror	r24
    6f9c:	2a 95       	dec	r18
    6f9e:	e2 f7       	brpl	.-8      	; 0x6f98 <MB_M_Timer_ISR+0x3e0>
    6fa0:	80 fd       	sbrc	r24, 0
    6fa2:	d3 cf       	rjmp	.-90     	; 0x6f4a <MB_M_Timer_ISR+0x392>
			Discr[Byte] |=Bit;
		else
			Discr[Byte] &=~Bit;
    6fa4:	f4 01       	movw	r30, r8
    6fa6:	eb 0f       	add	r30, r27
    6fa8:	f1 1d       	adc	r31, r1
    6faa:	a0 95       	com	r26
    6fac:	80 81       	ld	r24, Z
    6fae:	8a 23       	and	r24, r26
    6fb0:	80 83       	st	Z, r24
    6fb2:	d1 cf       	rjmp	.-94     	; 0x6f56 <MB_M_Timer_ISR+0x39e>
inline static uint8_t
MB_M_PresetSingle(uint8_t MB_N, MB_Query *Query)
{
	uint16_t StartAddr;
	uint16_t *Reg;
	if (LastProcSingle) {
    6fb4:	80 91 e2 04 	lds	r24, 0x04E2
    6fb8:	88 23       	and	r24, r24
    6fba:	09 f4       	brne	.+2      	; 0x6fbe <MB_M_Timer_ISR+0x406>
    6fbc:	46 c0       	rjmp	.+140    	; 0x704a <MB_M_Timer_ISR+0x492>
		StartAddr = MB_SingleQuery[MB_N].StartAddr;
    6fbe:	f7 01       	movw	r30, r14
    6fc0:	ee 0f       	add	r30, r30
    6fc2:	ff 1f       	adc	r31, r31
    6fc4:	e4 52       	subi	r30, 0x24	; 36
    6fc6:	fb 4f       	sbci	r31, 0xFB	; 251
    6fc8:	80 80       	ld	r8, Z
    6fca:	91 80       	ldd	r9, Z+1	; 0x01
		Reg = MB_SingleQuery[MB_N].Buf;
    6fcc:	fe 01       	movw	r30, r28
    6fce:	ee 0f       	add	r30, r30
    6fd0:	ff 1f       	adc	r31, r31
    6fd2:	ee 0f       	add	r30, r30
    6fd4:	ff 1f       	adc	r31, r31
    6fd6:	ee 0f       	add	r30, r30
    6fd8:	ff 1f       	adc	r31, r31
    6fda:	e6 52       	subi	r30, 0x26	; 38
    6fdc:	fb 4f       	sbci	r31, 0xFB	; 251
    6fde:	a6 81       	ldd	r26, Z+6	; 0x06
    6fe0:	b7 81       	ldd	r27, Z+7	; 0x07
	}
	else {
		StartAddr = prw(&Query->StartAddr);
		Reg = (uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+prw(&Query->AllocAddr);
	}
	return MB_Frame_Sz[MB_N]!=8 || MB_FrameReg(MB_N, 2)!=StartAddr || MB_FrameReg(MB_N, 4)!=*Reg;
    6fe2:	fe 01       	movw	r30, r28
    6fe4:	e7 5b       	subi	r30, 0xB7	; 183
    6fe6:	f8 4f       	sbci	r31, 0xF8	; 248
    6fe8:	80 81       	ld	r24, Z
    6fea:	88 30       	cpi	r24, 0x08	; 8
    6fec:	09 f0       	breq	.+2      	; 0x6ff0 <MB_M_Timer_ISR+0x438>
    6fee:	ba ce       	rjmp	.-652    	; 0x6d64 <MB_M_Timer_ISR+0x1ac>
    6ff0:	fc 2f       	mov	r31, r28
    6ff2:	ee 27       	eor	r30, r30
    6ff4:	e3 59       	subi	r30, 0x93	; 147
    6ff6:	f4 4f       	sbci	r31, 0xF4	; 244
    6ff8:	30 81       	ld	r19, Z
    6ffa:	20 e0       	ldi	r18, 0x00	; 0
    6ffc:	a6 01       	movw	r20, r12
    6ffe:	45 59       	subi	r20, 0x95	; 149
    7000:	54 4f       	sbci	r21, 0xF4	; 244
    7002:	fa 01       	movw	r30, r20
    7004:	83 81       	ldd	r24, Z+3	; 0x03
    7006:	90 e0       	ldi	r25, 0x00	; 0
    7008:	28 2b       	or	r18, r24
    700a:	39 2b       	or	r19, r25
    700c:	28 15       	cp	r18, r8
    700e:	39 05       	cpc	r19, r9
    7010:	09 f0       	breq	.+2      	; 0x7014 <MB_M_Timer_ISR+0x45c>
    7012:	a8 ce       	rjmp	.-688    	; 0x6d64 <MB_M_Timer_ISR+0x1ac>
    7014:	fc 2f       	mov	r31, r28
    7016:	ee 27       	eor	r30, r30
    7018:	e1 59       	subi	r30, 0x91	; 145
    701a:	f4 4f       	sbci	r31, 0xF4	; 244
    701c:	30 81       	ld	r19, Z
    701e:	20 e0       	ldi	r18, 0x00	; 0
    7020:	fa 01       	movw	r30, r20
    7022:	85 81       	ldd	r24, Z+5	; 0x05
    7024:	90 e0       	ldi	r25, 0x00	; 0
    7026:	28 2b       	or	r18, r24
    7028:	39 2b       	or	r19, r25
    702a:	8d 91       	ld	r24, X+
    702c:	9c 91       	ld	r25, X
    702e:	28 17       	cp	r18, r24
    7030:	39 07       	cpc	r19, r25
    7032:	09 f0       	breq	.+2      	; 0x7036 <MB_M_Timer_ISR+0x47e>
    7034:	97 ce       	rjmp	.-722    	; 0x6d64 <MB_M_Timer_ISR+0x1ac>
    7036:	ec ce       	rjmp	.-552    	; 0x6e10 <MB_M_Timer_ISR+0x258>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    7038:	fa 01       	movw	r30, r20
    703a:	31 96       	adiw	r30, 0x01	; 1
    703c:	85 90       	lpm	r8, Z+
    703e:	94 90       	lpm	r9, Z+

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    7040:	fa 01       	movw	r30, r20
    7042:	33 96       	adiw	r30, 0x03	; 3
    7044:	45 91       	lpm	r20, Z+
    7046:	54 91       	lpm	r21, Z+
    7048:	bb ce       	rjmp	.-650    	; 0x6dc0 <MB_M_Timer_ISR+0x208>
    704a:	fa 01       	movw	r30, r20
    704c:	31 96       	adiw	r30, 0x01	; 1
    704e:	85 90       	lpm	r8, Z+
    7050:	94 90       	lpm	r9, Z+
    7052:	fe 01       	movw	r30, r28
    7054:	ee 0f       	add	r30, r30
    7056:	ff 1f       	adc	r31, r31
    7058:	ee 0f       	add	r30, r30
    705a:	ff 1f       	adc	r31, r31
    705c:	ee 0f       	add	r30, r30
    705e:	ff 1f       	adc	r31, r31
    7060:	ee 0f       	add	r30, r30
    7062:	ff 1f       	adc	r31, r31
    7064:	e8 5c       	subi	r30, 0xC8	; 200
    7066:	fc 4f       	sbci	r31, 0xFC	; 252
    7068:	a5 91       	lpm	r26, Z+
    706a:	b4 91       	lpm	r27, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    706c:	fa 01       	movw	r30, r20
    706e:	35 96       	adiw	r30, 0x05	; 5
    7070:	85 91       	lpm	r24, Z+
    7072:	94 91       	lpm	r25, Z+
		StartAddr = MB_SingleQuery[MB_N].StartAddr;
		Reg = MB_SingleQuery[MB_N].Buf;
	}
	else {
		StartAddr = prw(&Query->StartAddr);
		Reg = (uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+prw(&Query->AllocAddr);
    7074:	88 0f       	add	r24, r24
    7076:	99 1f       	adc	r25, r25
    7078:	a8 0f       	add	r26, r24
    707a:	b9 1f       	adc	r27, r25
    707c:	b2 cf       	rjmp	.-156    	; 0x6fe2 <MB_M_Timer_ISR+0x42a>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    707e:	4d 5f       	subi	r20, 0xFD	; 253
    7080:	5f 4f       	sbci	r21, 0xFF	; 255
    7082:	fa 01       	movw	r30, r20
    7084:	b4 91       	lpm	r27, Z+
    7086:	43 50       	subi	r20, 0x03	; 3
    7088:	50 40       	sbci	r21, 0x00	; 0
    708a:	18 cf       	rjmp	.-464    	; 0x6ebc <MB_M_Timer_ISR+0x304>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_M_ReadReg(uint8_t MB_N, MB_Query *Query)
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || (LastProcSingle?MB_SingleQuery[MB_N].Qt:prw(&Query->Qt))*2!=MB_Frame[MB_N][2])
    708c:	80 91 e2 04 	lds	r24, 0x04E2
    7090:	88 23       	and	r24, r24
    7092:	09 f4       	brne	.+2      	; 0x7096 <MB_M_Timer_ISR+0x4de>
    7094:	55 c0       	rjmp	.+170    	; 0x7140 <MB_M_Timer_ISR+0x588>
    7096:	fe 01       	movw	r30, r28
    7098:	ee 0f       	add	r30, r30
    709a:	ff 1f       	adc	r31, r31
    709c:	ee 0f       	add	r30, r30
    709e:	ff 1f       	adc	r31, r31
    70a0:	ee 0f       	add	r30, r30
    70a2:	ff 1f       	adc	r31, r31
    70a4:	e2 52       	subi	r30, 0x22	; 34
    70a6:	fb 4f       	sbci	r31, 0xFB	; 251
    70a8:	20 81       	ld	r18, Z
    70aa:	31 81       	ldd	r19, Z+1	; 0x01
    70ac:	22 0f       	add	r18, r18
    70ae:	33 1f       	adc	r19, r19
    70b0:	82 16       	cp	r8, r18
    70b2:	93 06       	cpc	r9, r19
    70b4:	09 f0       	breq	.+2      	; 0x70b8 <MB_M_Timer_ISR+0x500>
    70b6:	56 ce       	rjmp	.-852    	; 0x6d64 <MB_M_Timer_ISR+0x1ac>
		return 1;
	uint16_t *Reg = LastProcSingle ?
		MB_SingleQuery[MB_N].Buf
	:
		(uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg))+prw(&Query->AllocAddr);
    70b8:	80 91 e2 04 	lds	r24, 0x04E2
    70bc:	88 23       	and	r24, r24
    70be:	09 f4       	brne	.+2      	; 0x70c2 <MB_M_Timer_ISR+0x50a>
    70c0:	5e c0       	rjmp	.+188    	; 0x717e <MB_M_Timer_ISR+0x5c6>
    70c2:	fe 01       	movw	r30, r28
    70c4:	ee 0f       	add	r30, r30
    70c6:	ff 1f       	adc	r31, r31
    70c8:	ee 0f       	add	r30, r30
    70ca:	ff 1f       	adc	r31, r31
    70cc:	ee 0f       	add	r30, r30
    70ce:	ff 1f       	adc	r31, r31
    70d0:	e6 52       	subi	r30, 0x26	; 38
    70d2:	fb 4f       	sbci	r31, 0xFB	; 251
    70d4:	26 81       	ldd	r18, Z+6	; 0x06
    70d6:	37 81       	ldd	r19, Z+7	; 0x07
	for (int8_t j=MB_Frame[MB_N][2]/2-1; j>=0; j--) {
    70d8:	4b 2f       	mov	r20, r27
    70da:	46 95       	lsr	r20
    70dc:	41 50       	subi	r20, 0x01	; 1
    70de:	47 fd       	sbrc	r20, 7
    70e0:	97 ce       	rjmp	.-722    	; 0x6e10 <MB_M_Timer_ISR+0x258>
    70e2:	84 2f       	mov	r24, r20
    70e4:	99 27       	eor	r25, r25
    70e6:	87 fd       	sbrc	r24, 7
    70e8:	90 95       	com	r25
    70ea:	88 0f       	add	r24, r24
    70ec:	99 1f       	adc	r25, r25
    70ee:	58 2f       	mov	r21, r24
    70f0:	5d 5f       	subi	r21, 0xFD	; 253
    70f2:	28 0f       	add	r18, r24
    70f4:	39 1f       	adc	r19, r25
		int8_t i = j*2;
		Reg[j] = MB_FrameReg(MB_N, 3+i);
    70f6:	8b e6       	ldi	r24, 0x6B	; 107
    70f8:	88 2e       	mov	r8, r24
    70fa:	8b e0       	ldi	r24, 0x0B	; 11
    70fc:	98 2e       	mov	r9, r24
    70fe:	8c 0c       	add	r8, r12
    7100:	9d 1c       	adc	r9, r13
    7102:	e5 2f       	mov	r30, r21
    7104:	f0 e0       	ldi	r31, 0x00	; 0
    7106:	d4 01       	movw	r26, r8
    7108:	ae 0f       	add	r26, r30
    710a:	bf 1f       	adc	r27, r31
    710c:	11 96       	adiw	r26, 0x01	; 1
    710e:	8c 91       	ld	r24, X
    7110:	90 e0       	ldi	r25, 0x00	; 0
    7112:	ec 0d       	add	r30, r12
    7114:	fd 1d       	adc	r31, r13
    7116:	e5 59       	subi	r30, 0x95	; 149
    7118:	f4 4f       	sbci	r31, 0xF4	; 244
    711a:	f0 81       	ld	r31, Z
    711c:	e0 e0       	ldi	r30, 0x00	; 0
    711e:	8e 2b       	or	r24, r30
    7120:	9f 2b       	or	r25, r31
    7122:	d9 01       	movw	r26, r18
    7124:	8d 93       	st	X+, r24
    7126:	9c 93       	st	X, r25
		return 1;
	uint16_t *Reg = LastProcSingle ?
		MB_SingleQuery[MB_N].Buf
	:
		(uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg))+prw(&Query->AllocAddr);
	for (int8_t j=MB_Frame[MB_N][2]/2-1; j>=0; j--) {
    7128:	41 50       	subi	r20, 0x01	; 1
    712a:	52 50       	subi	r21, 0x02	; 2
    712c:	22 50       	subi	r18, 0x02	; 2
    712e:	30 40       	sbci	r19, 0x00	; 0
    7130:	47 ff       	sbrs	r20, 7
    7132:	e7 cf       	rjmp	.-50     	; 0x7102 <MB_M_Timer_ISR+0x54a>
    7134:	6d ce       	rjmp	.-806    	; 0x6e10 <MB_M_Timer_ISR+0x258>
			else if (LastProcSingle)
				MB_SingleState[MB_N] = MB_SingleIdle;
			else {
				SlaveOff[MB_N] &=~((uint32_t)1<<CurrSlave[MB_N]);
				if (++CurrQuery[MB_N]==prb(&Slave->QueryQt))
					Over = NextSlave(MB_N);
    7136:	81 2f       	mov	r24, r17
    7138:	0e 94 93 34 	call	0x6926	; 0x6926 <NextSlave>
    713c:	98 2f       	mov	r25, r24
    713e:	a7 ce       	rjmp	.-690    	; 0x6e8e <MB_M_Timer_ISR+0x2d6>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    7140:	ca 01       	movw	r24, r20
    7142:	03 96       	adiw	r24, 0x03	; 3
    7144:	fc 01       	movw	r30, r24
    7146:	25 91       	lpm	r18, Z+
    7148:	34 91       	lpm	r19, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_M_ReadReg(uint8_t MB_N, MB_Query *Query)
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || (LastProcSingle?MB_SingleQuery[MB_N].Qt:prw(&Query->Qt))*2!=MB_Frame[MB_N][2])
    714a:	22 0f       	add	r18, r18
    714c:	33 1f       	adc	r19, r19
    714e:	b0 cf       	rjmp	.-160    	; 0x70b0 <MB_M_Timer_ISR+0x4f8>
	if (LastProcSingle) {
		Discr = MB_SingleQuery[MB_N].Buf;
		Pin = 0;
	}
	else {
		Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
    7150:	a1 30       	cpi	r26, 0x01	; 1
    7152:	59 f1       	breq	.+86     	; 0x71aa <MB_M_Timer_ISR+0x5f2>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    7154:	f7 01       	movw	r30, r14
    7156:	ee 0f       	add	r30, r30
    7158:	ff 1f       	adc	r31, r31
    715a:	ee 0f       	add	r30, r30
    715c:	ff 1f       	adc	r31, r31
    715e:	ec 5c       	subi	r30, 0xCC	; 204
    7160:	fc 4f       	sbci	r31, 0xFC	; 252
    7162:	85 91       	lpm	r24, Z+
    7164:	94 91       	lpm	r25, Z+
    7166:	e8 2f       	mov	r30, r24
    7168:	89 2f       	mov	r24, r25
    716a:	2e 2f       	mov	r18, r30
    716c:	38 2f       	mov	r19, r24
    716e:	c9 01       	movw	r24, r18
    7170:	4c 01       	movw	r8, r24

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    7172:	fa 01       	movw	r30, r20
    7174:	35 96       	adiw	r30, 0x05	; 5
    7176:	85 91       	lpm	r24, Z+
    7178:	94 91       	lpm	r25, Z+
		Pin = prw(&Query->AllocAddr);
    717a:	08 2f       	mov	r16, r24
    717c:	d8 ce       	rjmp	.-592    	; 0x6f2e <MB_M_Timer_ISR+0x376>
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || (LastProcSingle?MB_SingleQuery[MB_N].Qt:prw(&Query->Qt))*2!=MB_Frame[MB_N][2])
		return 1;
	uint16_t *Reg = LastProcSingle ?
		MB_SingleQuery[MB_N].Buf
	:
		(uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg))+prw(&Query->AllocAddr);
    717e:	a3 30       	cpi	r26, 0x03	; 3
    7180:	11 f1       	breq	.+68     	; 0x71c6 <MB_M_Timer_ISR+0x60e>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    7182:	fe 01       	movw	r30, r28
    7184:	e2 95       	swap	r30
    7186:	f2 95       	swap	r31
    7188:	f0 7f       	andi	r31, 0xF0	; 240
    718a:	fe 27       	eor	r31, r30
    718c:	e0 7f       	andi	r30, 0xF0	; 240
    718e:	fe 27       	eor	r31, r30
    7190:	e4 5c       	subi	r30, 0xC4	; 196
    7192:	fc 4f       	sbci	r31, 0xFC	; 252
    7194:	85 91       	lpm	r24, Z+
    7196:	94 91       	lpm	r25, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    7198:	fa 01       	movw	r30, r20
    719a:	35 96       	adiw	r30, 0x05	; 5
    719c:	25 91       	lpm	r18, Z+
    719e:	34 91       	lpm	r19, Z+
    71a0:	22 0f       	add	r18, r18
    71a2:	33 1f       	adc	r19, r19
    71a4:	28 0f       	add	r18, r24
    71a6:	39 1f       	adc	r19, r25
    71a8:	97 cf       	rjmp	.-210    	; 0x70d8 <MB_M_Timer_ISR+0x520>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    71aa:	fe 01       	movw	r30, r28
    71ac:	e2 95       	swap	r30
    71ae:	f2 95       	swap	r31
    71b0:	f0 7f       	andi	r31, 0xF0	; 240
    71b2:	fe 27       	eor	r31, r30
    71b4:	e0 7f       	andi	r30, 0xF0	; 240
    71b6:	fe 27       	eor	r31, r30
    71b8:	e0 5d       	subi	r30, 0xD0	; 208
    71ba:	fc 4f       	sbci	r31, 0xFC	; 252
    71bc:	85 91       	lpm	r24, Z+
    71be:	94 91       	lpm	r25, Z+
    71c0:	e8 2f       	mov	r30, r24
    71c2:	89 2f       	mov	r24, r25
    71c4:	d2 cf       	rjmp	.-92     	; 0x716a <MB_M_Timer_ISR+0x5b2>

// ~~~~~~~~~~~~~~~~~~
void
MB_M_Tx(uint8_t MB_N)
{
	StartTimer16(TD_MB_Idle+MB_N, MB_M_Timeout[MB_N]);
    71c6:	fe 01       	movw	r30, r28
    71c8:	ee 0f       	add	r30, r30
    71ca:	ff 1f       	adc	r31, r31
    71cc:	ee 0f       	add	r30, r30
    71ce:	ff 1f       	adc	r31, r31
    71d0:	ee 0f       	add	r30, r30
    71d2:	ff 1f       	adc	r31, r31
    71d4:	ee 0f       	add	r30, r30
    71d6:	ff 1f       	adc	r31, r31
    71d8:	e8 5c       	subi	r30, 0xC8	; 200
    71da:	fc 4f       	sbci	r31, 0xFC	; 252
    71dc:	85 91       	lpm	r24, Z+
    71de:	94 91       	lpm	r25, Z+
    71e0:	db cf       	rjmp	.-74     	; 0x7198 <MB_M_Timer_ISR+0x5e0>

000071e2 <MB_M_Tx>:
    71e2:	90 91 e8 04 	lds	r25, 0x04E8
    71e6:	e9 e2       	ldi	r30, 0x29	; 41
    71e8:	f9 e0       	ldi	r31, 0x09	; 9
    71ea:	e8 0f       	add	r30, r24
    71ec:	f1 1d       	adc	r31, r1
    71ee:	60 81       	ld	r22, Z
    71f0:	89 0f       	add	r24, r25
    71f2:	70 e0       	ldi	r23, 0x00	; 0
    71f4:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
}
    71f8:	08 95       	ret

000071fa <Modbus_TX>:
}

// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_TX(usart_t *usart)
{
    71fa:	cf 92       	push	r12
    71fc:	df 92       	push	r13
    71fe:	ef 92       	push	r14
    7200:	ff 92       	push	r15
    7202:	1f 93       	push	r17
    7204:	cf 93       	push	r28
    7206:	df 93       	push	r29
    7208:	dc 01       	movw	r26, r24
    720a:	e8 e6       	ldi	r30, 0x68	; 104
    720c:	f4 e3       	ldi	r31, 0x34	; 52
    720e:	85 91       	lpm	r24, Z+
    7210:	94 91       	lpm	r25, Z+
// ~~~~~~~~~~~~~~~~~~~~~~
static uint8_t
MB_Port_N(usart_t *usart)
{
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Port[MB_N].usart_field)!=usart; MB_N++);
    7212:	a8 17       	cp	r26, r24
    7214:	b9 07       	cpc	r27, r25
    7216:	09 f4       	brne	.+2      	; 0x721a <Modbus_TX+0x20>
    7218:	c0 c0       	rjmp	.+384    	; 0x739a <Modbus_TX+0x1a0>
    721a:	10 e0       	ldi	r17, 0x00	; 0
    721c:	1f 5f       	subi	r17, 0xFF	; 255
    721e:	c1 2f       	mov	r28, r17
    7220:	d0 e0       	ldi	r29, 0x00	; 0
    7222:	ce 01       	movw	r24, r28
    7224:	88 0f       	add	r24, r24
    7226:	99 1f       	adc	r25, r25
    7228:	88 0f       	add	r24, r24
    722a:	99 1f       	adc	r25, r25
    722c:	fc 01       	movw	r30, r24
    722e:	ee 0f       	add	r30, r30
    7230:	ff 1f       	adc	r31, r31
    7232:	ee 0f       	add	r30, r30
    7234:	ff 1f       	adc	r31, r31
    7236:	e8 0f       	add	r30, r24
    7238:	f9 1f       	adc	r31, r25
    723a:	e8 59       	subi	r30, 0x98	; 152
    723c:	fb 4c       	sbci	r31, 0xCB	; 203
    723e:	85 91       	lpm	r24, Z+
    7240:	94 91       	lpm	r25, Z+
    7242:	a8 17       	cp	r26, r24
    7244:	b9 07       	cpc	r27, r25
    7246:	51 f7       	brne	.-44     	; 0x721c <Modbus_TX+0x22>
void
Modbus_TX(usart_t *usart)
{
	uint8_t MB_N = MB_Port_N(usart);
	static uint8_t Count[Modbus_Qt];
	if (Count[MB_N] == MB_Frame_Sz[MB_N]-2){
    7248:	26 ee       	ldi	r18, 0xE6	; 230
    724a:	c2 2e       	mov	r12, r18
    724c:	22 e0       	ldi	r18, 0x02	; 2
    724e:	d2 2e       	mov	r13, r18
    7250:	cc 0e       	add	r12, r28
    7252:	dd 1e       	adc	r13, r29
    7254:	f6 01       	movw	r30, r12
    7256:	50 81       	ld	r21, Z
    7258:	be 01       	movw	r22, r28
    725a:	67 5b       	subi	r22, 0xB7	; 183
    725c:	78 4f       	sbci	r23, 0xF8	; 248
    725e:	fb 01       	movw	r30, r22
    7260:	40 81       	ld	r20, Z
    7262:	25 2f       	mov	r18, r21
    7264:	30 e0       	ldi	r19, 0x00	; 0
    7266:	84 2f       	mov	r24, r20
    7268:	90 e0       	ldi	r25, 0x00	; 0
    726a:	02 97       	sbiw	r24, 0x02	; 2
    726c:	28 17       	cp	r18, r24
    726e:	39 07       	cpc	r19, r25
    7270:	09 f4       	brne	.+2      	; 0x7274 <Modbus_TX+0x7a>
    7272:	55 c0       	rjmp	.+170    	; 0x731e <Modbus_TX+0x124>
		USART_Reg(MB_N, ucsrb) &=~(1<<5);
		USART_Reg(MB_N, ucsrb) |=(1<<6);
		USART_Reg(MB_N, ucsra) |=(1<<6);	//Clear TxC pending interrupt		
	}
	if (++Count[MB_N]<MB_Frame_Sz[MB_N]) {
    7274:	25 2f       	mov	r18, r21
    7276:	2f 5f       	subi	r18, 0xFF	; 255
    7278:	f6 01       	movw	r30, r12
    727a:	20 83       	st	Z, r18
    727c:	24 17       	cp	r18, r20
    727e:	80 f4       	brcc	.+32     	; 0x72a0 <Modbus_TX+0xa6>
		usart_data(usart) = MB_Frame[MB_N][Count[MB_N]];
    7280:	fc 2f       	mov	r31, r28
    7282:	ee 27       	eor	r30, r30
    7284:	e2 0f       	add	r30, r18
    7286:	f1 1d       	adc	r31, r1
    7288:	e5 59       	subi	r30, 0x95	; 149
    728a:	f4 4f       	sbci	r31, 0xF4	; 244
    728c:	80 81       	ld	r24, Z
    728e:	8c 93       	st	X, r24
		break;
	case Role_Master:
		MB_M_Tx(MB_N);
		break;
	}
}
    7290:	df 91       	pop	r29
    7292:	cf 91       	pop	r28
    7294:	1f 91       	pop	r17
    7296:	ff 90       	pop	r15
    7298:	ef 90       	pop	r14
    729a:	df 90       	pop	r13
    729c:	cf 90       	pop	r12
    729e:	08 95       	ret
    72a0:	9e 01       	movw	r18, r28
    72a2:	22 0f       	add	r18, r18
    72a4:	33 1f       	adc	r19, r19
    72a6:	22 0f       	add	r18, r18
    72a8:	33 1f       	adc	r19, r19
    72aa:	c9 01       	movw	r24, r18
    72ac:	8c 0f       	add	r24, r28
    72ae:	9d 1f       	adc	r25, r29
    72b0:	88 0f       	add	r24, r24
    72b2:	99 1f       	adc	r25, r25
    72b4:	88 0f       	add	r24, r24
    72b6:	99 1f       	adc	r25, r25
    72b8:	84 59       	subi	r24, 0x94	; 148
    72ba:	9b 4c       	sbci	r25, 0xCB	; 203
    72bc:	fc 01       	movw	r30, r24
    72be:	a5 91       	lpm	r26, Z+
    72c0:	b4 91       	lpm	r27, Z+
	}

	void MB_S_Tx(uint8_t);
	void MB_M_Tx(uint8_t);
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		USART_Reg(MB_N, ucsrb) &=~((1<<6)|(1<<5)); 	// .  USART Data Register Empty Interrupt
    72c2:	8c 91       	ld	r24, X
    72c4:	8f 79       	andi	r24, 0x9F	; 159
    72c6:	8c 93       	st	X, r24
    72c8:	79 01       	movw	r14, r18
    72ca:	ee 0c       	add	r14, r14
    72cc:	ff 1c       	adc	r15, r15
    72ce:	ee 0c       	add	r14, r14
    72d0:	ff 1c       	adc	r15, r15
    72d2:	e2 0e       	add	r14, r18
    72d4:	f3 1e       	adc	r15, r19
    72d6:	c7 01       	movw	r24, r14
    72d8:	8c 58       	subi	r24, 0x8C	; 140
    72da:	9b 4c       	sbci	r25, 0xCB	; 203
    72dc:	fc 01       	movw	r30, r24
    72de:	25 91       	lpm	r18, Z+
    72e0:	34 91       	lpm	r19, Z+
	#elif defined (__AVR_ATxmega128A1__)
		usart->CTRLA = (usart->CTRLA &~USART_TXCINTLVL_gm) |USART_TXCINTLVL_OFF_gc;
	#endif
	USART_Func(MB_N, RS485);
    72e2:	f9 01       	movw	r30, r18
    72e4:	19 95       	eicall
	Count[MB_N] = 0;
    72e6:	f6 01       	movw	r30, r12
    72e8:	10 82       	st	Z, r1
	//StartTime3_5();
	MB_State[MB_N] = MB_Idle;
    72ea:	ce 53       	subi	r28, 0x3E	; 62
    72ec:	da 4f       	sbci	r29, 0xFA	; 250
    72ee:	81 e0       	ldi	r24, 0x01	; 1
    72f0:	88 83       	st	Y, r24

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    72f2:	e1 2f       	mov	r30, r17
    72f4:	f0 e0       	ldi	r31, 0x00	; 0
    72f6:	e4 58       	subi	r30, 0x84	; 132
    72f8:	fb 4c       	sbci	r31, 0xCB	; 203
    72fa:	84 91       	lpm	r24, Z+
	switch (prb(MB_Role+MB_N)) {
    72fc:	88 23       	and	r24, r24
    72fe:	09 f4       	brne	.+2      	; 0x7302 <Modbus_TX+0x108>
    7300:	3c c0       	rjmp	.+120    	; 0x737a <Modbus_TX+0x180>
    7302:	81 30       	cpi	r24, 0x01	; 1
    7304:	09 f0       	breq	.+2      	; 0x7308 <Modbus_TX+0x10e>
    7306:	c4 cf       	rjmp	.-120    	; 0x7290 <Modbus_TX+0x96>
	case Role_Slave:
		MB_S_Tx(MB_N);
		break;
	case Role_Master:
		MB_M_Tx(MB_N);
    7308:	81 2f       	mov	r24, r17
    730a:	0e 94 f1 38 	call	0x71e2	; 0x71e2 <MB_M_Tx>
		break;
	}
}
    730e:	df 91       	pop	r29
    7310:	cf 91       	pop	r28
    7312:	1f 91       	pop	r17
    7314:	ff 90       	pop	r15
    7316:	ef 90       	pop	r14
    7318:	df 90       	pop	r13
    731a:	cf 90       	pop	r12
    731c:	08 95       	ret

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    731e:	fe 01       	movw	r30, r28
    7320:	ee 0f       	add	r30, r30
    7322:	ff 1f       	adc	r31, r31
    7324:	ee 0f       	add	r30, r30
    7326:	ff 1f       	adc	r31, r31
    7328:	ec 0f       	add	r30, r28
    732a:	fd 1f       	adc	r31, r29
    732c:	ee 0f       	add	r30, r30
    732e:	ff 1f       	adc	r31, r31
    7330:	ee 0f       	add	r30, r30
    7332:	ff 1f       	adc	r31, r31
    7334:	e4 59       	subi	r30, 0x94	; 148
    7336:	fb 4c       	sbci	r31, 0xCB	; 203
    7338:	25 91       	lpm	r18, Z+
    733a:	34 91       	lpm	r19, Z+
Modbus_TX(usart_t *usart)
{
	uint8_t MB_N = MB_Port_N(usart);
	static uint8_t Count[Modbus_Qt];
	if (Count[MB_N] == MB_Frame_Sz[MB_N]-2){
		USART_Reg(MB_N, ucsrb) &=~(1<<5);
    733c:	f9 01       	movw	r30, r18
    733e:	80 81       	ld	r24, Z
    7340:	8f 7d       	andi	r24, 0xDF	; 223
		USART_Reg(MB_N, ucsrb) |=(1<<6);
    7342:	80 64       	ori	r24, 0x40	; 64
    7344:	80 83       	st	Z, r24
    7346:	9e 01       	movw	r18, r28
    7348:	22 0f       	add	r18, r18
    734a:	33 1f       	adc	r19, r19
    734c:	ce 01       	movw	r24, r28
    734e:	88 0f       	add	r24, r24
    7350:	99 1f       	adc	r25, r25
    7352:	88 0f       	add	r24, r24
    7354:	99 1f       	adc	r25, r25
    7356:	88 0f       	add	r24, r24
    7358:	99 1f       	adc	r25, r25
    735a:	28 0f       	add	r18, r24
    735c:	39 1f       	adc	r19, r25
    735e:	22 0f       	add	r18, r18
    7360:	33 1f       	adc	r19, r19
    7362:	26 59       	subi	r18, 0x96	; 150
    7364:	3b 4c       	sbci	r19, 0xCB	; 203
    7366:	f9 01       	movw	r30, r18
    7368:	e5 90       	lpm	r14, Z+
    736a:	f4 90       	lpm	r15, Z+
		USART_Reg(MB_N, ucsra) |=(1<<6);	//Clear TxC pending interrupt		
    736c:	f7 01       	movw	r30, r14
    736e:	80 81       	ld	r24, Z
    7370:	80 64       	ori	r24, 0x40	; 64
    7372:	80 83       	st	Z, r24
    7374:	fb 01       	movw	r30, r22
    7376:	40 81       	ld	r20, Z
    7378:	7d cf       	rjmp	.-262    	; 0x7274 <Modbus_TX+0x7a>
    737a:	c7 01       	movw	r24, r14
    737c:	8a 58       	subi	r24, 0x8A	; 138
    737e:	9b 4c       	sbci	r25, 0xCB	; 203
    7380:	fc 01       	movw	r30, r24
    7382:	25 91       	lpm	r18, Z+
    7384:	34 91       	lpm	r19, Z+

// ~~~~~~~~~~~~~~~~~~
void
MB_S_Tx(uint8_t MB_N)
{
	USART_Func(MB_N, LED);
    7386:	f9 01       	movw	r30, r18
    7388:	19 95       	eicall
		break;
	case Role_Master:
		MB_M_Tx(MB_N);
		break;
	}
}
    738a:	df 91       	pop	r29
    738c:	cf 91       	pop	r28
    738e:	1f 91       	pop	r17
    7390:	ff 90       	pop	r15
    7392:	ef 90       	pop	r14
    7394:	df 90       	pop	r13
    7396:	cf 90       	pop	r12
    7398:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~
static uint8_t
MB_Port_N(usart_t *usart)
{
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Port[MB_N].usart_field)!=usart; MB_N++);
    739a:	10 e0       	ldi	r17, 0x00	; 0
    739c:	c0 e0       	ldi	r28, 0x00	; 0
    739e:	d0 e0       	ldi	r29, 0x00	; 0
    73a0:	53 cf       	rjmp	.-346    	; 0x7248 <Modbus_TX+0x4e>

000073a2 <MB_SingleRun>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_SingleRun(uint8_t MB_N, uint8_t Addr, uint8_t Func, uint16_t StartAddr, uint16_t Qt, void *Buf)
{
    73a2:	df 92       	push	r13
    73a4:	ef 92       	push	r14
    73a6:	ff 92       	push	r15
    73a8:	0f 93       	push	r16
    73aa:	1f 93       	push	r17
    73ac:	cf 93       	push	r28
    73ae:	df 93       	push	r29
    73b0:	d8 2e       	mov	r13, r24
    73b2:	94 2f       	mov	r25, r20
    73b4:	a9 01       	movw	r20, r18
	if (MB_SingleState[MB_N]!=MB_SingleIdle)
    73b6:	c8 2f       	mov	r28, r24
    73b8:	d0 e0       	ldi	r29, 0x00	; 0
    73ba:	9e 01       	movw	r18, r28
    73bc:	21 55       	subi	r18, 0x51	; 81
    73be:	39 4f       	sbci	r19, 0xF9	; 249
    73c0:	f9 01       	movw	r30, r18
    73c2:	80 81       	ld	r24, Z
    73c4:	88 23       	and	r24, r24
    73c6:	91 f5       	brne	.+100    	; 0x742c <MB_SingleRun+0x8a>
		return;

	MB_SingleQuery[MB_N].Addr				= Addr;
    73c8:	de 01       	movw	r26, r28
    73ca:	aa 0f       	add	r26, r26
    73cc:	bb 1f       	adc	r27, r27
    73ce:	aa 0f       	add	r26, r26
    73d0:	bb 1f       	adc	r27, r27
    73d2:	aa 0f       	add	r26, r26
    73d4:	bb 1f       	adc	r27, r27
    73d6:	a6 52       	subi	r26, 0x26	; 38
    73d8:	bb 4f       	sbci	r27, 0xFB	; 251
    73da:	6c 93       	st	X, r22
	MB_SingleQuery[MB_N].Func				= Func;
    73dc:	11 96       	adiw	r26, 0x01	; 1
    73de:	9c 93       	st	X, r25
    73e0:	11 97       	sbiw	r26, 0x01	; 1
	MB_SingleQuery[MB_N].StartAddr	= StartAddr;
    73e2:	be 01       	movw	r22, r28
    73e4:	66 0f       	add	r22, r22
    73e6:	77 1f       	adc	r23, r23
    73e8:	66 0f       	add	r22, r22
    73ea:	77 1f       	adc	r23, r23
    73ec:	fb 01       	movw	r30, r22
    73ee:	ee 0f       	add	r30, r30
    73f0:	ff 1f       	adc	r31, r31
    73f2:	e4 52       	subi	r30, 0x24	; 36
    73f4:	fb 4f       	sbci	r31, 0xFB	; 251
    73f6:	51 83       	std	Z+1, r21	; 0x01
    73f8:	40 83       	st	Z, r20
	MB_SingleQuery[MB_N].Qt					= Qt;
    73fa:	ae 01       	movw	r20, r28
    73fc:	44 0f       	add	r20, r20
    73fe:	55 1f       	adc	r21, r21
    7400:	fa 01       	movw	r30, r20
    7402:	ee 0f       	add	r30, r30
    7404:	ff 1f       	adc	r31, r31
    7406:	ee 0f       	add	r30, r30
    7408:	ff 1f       	adc	r31, r31
    740a:	e2 52       	subi	r30, 0x22	; 34
    740c:	fb 4f       	sbci	r31, 0xFB	; 251
    740e:	11 83       	std	Z+1, r17	; 0x01
    7410:	00 83       	st	Z, r16
	MB_SingleQuery[MB_N].Buf				= Buf;
    7412:	17 96       	adiw	r26, 0x07	; 7
    7414:	fc 92       	st	X, r15
    7416:	ee 92       	st	-X, r14
    7418:	16 97       	sbiw	r26, 0x06	; 6

	MB_SingleState[MB_N] = MB_SingleStart;
    741a:	81 e0       	ldi	r24, 0x01	; 1
    741c:	f9 01       	movw	r30, r18
    741e:	80 83       	st	Z, r24
	if (MB_State[MB_N]==MB_Proc && !LastProcSingle) {
    7420:	fe 01       	movw	r30, r28
    7422:	ee 53       	subi	r30, 0x3E	; 62
    7424:	fa 4f       	sbci	r31, 0xFA	; 250
    7426:	80 81       	ld	r24, Z
    7428:	84 30       	cpi	r24, 0x04	; 4
    742a:	41 f0       	breq	.+16     	; 0x743c <MB_SingleRun+0x9a>
			IntOff();
			MB_Transm(MB_N);
			IntOn();
		}
	}
}
    742c:	df 91       	pop	r29
    742e:	cf 91       	pop	r28
    7430:	1f 91       	pop	r17
    7432:	0f 91       	pop	r16
    7434:	ff 90       	pop	r15
    7436:	ef 90       	pop	r14
    7438:	df 90       	pop	r13
    743a:	08 95       	ret
	MB_SingleQuery[MB_N].StartAddr	= StartAddr;
	MB_SingleQuery[MB_N].Qt					= Qt;
	MB_SingleQuery[MB_N].Buf				= Buf;

	MB_SingleState[MB_N] = MB_SingleStart;
	if (MB_State[MB_N]==MB_Proc && !LastProcSingle) {
    743c:	80 91 e2 04 	lds	r24, 0x04E2
    7440:	88 23       	and	r24, r24
    7442:	a1 f7       	brne	.-24     	; 0x742c <MB_SingleRun+0x8a>
		uint16_t T = (CurrSlave[MB_N]==0 ? MB_M_Period[MB_N] : MB_M_Timeout[MB_N]) - GetTimer16(TD_MB_Idle+MB_N);
    7444:	fe 01       	movw	r30, r28
    7446:	ec 5a       	subi	r30, 0xAC	; 172
    7448:	f9 4f       	sbci	r31, 0xF9	; 249
    744a:	80 81       	ld	r24, Z
    744c:	88 23       	and	r24, r24
    744e:	09 f0       	breq	.+2      	; 0x7452 <MB_SingleRun+0xb0>
    7450:	4d c0       	rjmp	.+154    	; 0x74ec <MB_SingleRun+0x14a>
    7452:	43 55       	subi	r20, 0x53	; 83
    7454:	59 4f       	sbci	r21, 0xF9	; 249
    7456:	fa 01       	movw	r30, r20
    7458:	40 81       	ld	r20, Z
    745a:	51 81       	ldd	r21, Z+1	; 0x01
    745c:	20 91 e8 04 	lds	r18, 0x04E8
    7460:	2d 0d       	add	r18, r13

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    7462:	8f b7       	in	r24, 0x3f	; 63
    7464:	80 78       	andi	r24, 0x80	; 128
    7466:	80 93 ee 02 	sts	0x02EE, r24
	cli();
    746a:	f8 94       	cli
    746c:	e2 2f       	mov	r30, r18
    746e:	f0 e0       	ldi	r31, 0x00	; 0
    7470:	ee 0f       	add	r30, r30
    7472:	ff 1f       	adc	r31, r31
    7474:	e1 5b       	subi	r30, 0xB1	; 177
    7476:	fc 4f       	sbci	r31, 0xFC	; 252
    7478:	a0 81       	ld	r26, Z
    747a:	b1 81       	ldd	r27, Z+1	; 0x01

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    747c:	88 23       	and	r24, r24
    747e:	09 f0       	breq	.+2      	; 0x7482 <MB_SingleRun+0xe0>
		sei();
    7480:	78 94       	sei
    7482:	ca 01       	movw	r24, r20
    7484:	8a 1b       	sub	r24, r26
    7486:	9b 0b       	sbc	r25, r27
		if (T<MB_M_Pause_Min)
    7488:	85 30       	cpi	r24, 0x05	; 5
    748a:	91 05       	cpc	r25, r1
    748c:	a8 f1       	brcs	.+106    	; 0x74f8 <MB_SingleRun+0x156>

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    748e:	8f b7       	in	r24, 0x3f	; 63
    7490:	80 78       	andi	r24, 0x80	; 128
    7492:	80 93 ee 02 	sts	0x02EE, r24
	cli();
    7496:	f8 94       	cli
    7498:	cb 01       	movw	r24, r22
    749a:	88 0f       	add	r24, r24
    749c:	99 1f       	adc	r25, r25
    749e:	88 0f       	add	r24, r24
    74a0:	99 1f       	adc	r25, r25
    74a2:	86 0f       	add	r24, r22
    74a4:	97 1f       	adc	r25, r23
    74a6:	8a 58       	subi	r24, 0x8A	; 138
    74a8:	9b 4c       	sbci	r25, 0xCB	; 203
    74aa:	fc 01       	movw	r30, r24
    74ac:	25 91       	lpm	r18, Z+
    74ae:	34 91       	lpm	r19, Z+
			StartTimer16(TD_MB_Idle+MB_N, MB_M_Pause_Min-T);
		else {
			IntOff();
			USART_Func(MB_N, LED);
    74b0:	f9 01       	movw	r30, r18
    74b2:	19 95       	eicall

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    74b4:	80 91 ee 02 	lds	r24, 0x02EE
    74b8:	88 23       	and	r24, r24
    74ba:	09 f0       	breq	.+2      	; 0x74be <MB_SingleRun+0x11c>
		sei();
    74bc:	78 94       	sei
			IntOn();
			ResetTimer16(TD_MB_Idle+MB_N);
    74be:	80 91 e8 04 	lds	r24, 0x04E8
    74c2:	8d 0d       	add	r24, r13
    74c4:	0e 94 2e 20 	call	0x405c	; 0x405c <ResetTimer16>
			FormSingle(MB_N);
    74c8:	8d 2d       	mov	r24, r13
    74ca:	0e 94 51 34 	call	0x68a2	; 0x68a2 <FormSingle>

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    74ce:	8f b7       	in	r24, 0x3f	; 63
    74d0:	80 78       	andi	r24, 0x80	; 128
    74d2:	80 93 ee 02 	sts	0x02EE, r24
	cli();
    74d6:	f8 94       	cli
			IntOff();
			MB_Transm(MB_N);
    74d8:	8d 2d       	mov	r24, r13
    74da:	0e 94 f7 2c 	call	0x59ee	; 0x59ee <MB_Transm>

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    74de:	80 91 ee 02 	lds	r24, 0x02EE
    74e2:	88 23       	and	r24, r24
    74e4:	09 f4       	brne	.+2      	; 0x74e8 <MB_SingleRun+0x146>
    74e6:	a2 cf       	rjmp	.-188    	; 0x742c <MB_SingleRun+0x8a>
		sei();
    74e8:	78 94       	sei
    74ea:	a0 cf       	rjmp	.-192    	; 0x742c <MB_SingleRun+0x8a>
	MB_SingleQuery[MB_N].Qt					= Qt;
	MB_SingleQuery[MB_N].Buf				= Buf;

	MB_SingleState[MB_N] = MB_SingleStart;
	if (MB_State[MB_N]==MB_Proc && !LastProcSingle) {
		uint16_t T = (CurrSlave[MB_N]==0 ? MB_M_Period[MB_N] : MB_M_Timeout[MB_N]) - GetTimer16(TD_MB_Idle+MB_N);
    74ec:	c7 5d       	subi	r28, 0xD7	; 215
    74ee:	d6 4f       	sbci	r29, 0xF6	; 246
    74f0:	88 81       	ld	r24, Y
    74f2:	48 2f       	mov	r20, r24
    74f4:	50 e0       	ldi	r21, 0x00	; 0
    74f6:	b2 cf       	rjmp	.-156    	; 0x745c <MB_SingleRun+0xba>
		if (T<MB_M_Pause_Min)
			StartTimer16(TD_MB_Idle+MB_N, MB_M_Pause_Min-T);
    74f8:	65 e0       	ldi	r22, 0x05	; 5
    74fa:	70 e0       	ldi	r23, 0x00	; 0
    74fc:	68 1b       	sub	r22, r24
    74fe:	79 0b       	sbc	r23, r25
    7500:	82 2f       	mov	r24, r18
    7502:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
    7506:	92 cf       	rjmp	.-220    	; 0x742c <MB_SingleRun+0x8a>

00007508 <MB_Master_MaxCycle_Clear>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_Master_MaxCycle_Clear(uint8_t MB_N)
{
	MB_Master_MaxCycle[MB_N] = 0;
    7508:	e8 2f       	mov	r30, r24
    750a:	f0 e0       	ldi	r31, 0x00	; 0
    750c:	ee 0f       	add	r30, r30
    750e:	ff 1f       	adc	r31, r31
    7510:	e1 50       	subi	r30, 0x01	; 1
    7512:	f9 4f       	sbci	r31, 0xF9	; 249
    7514:	11 82       	std	Z+1, r1	; 0x01
    7516:	10 82       	st	Z, r1
}
    7518:	08 95       	ret

0000751a <MB_M_Cycle>:

// ~~~~~~~~~~~~~~~~~~~~~
void
MB_M_Cycle(uint8_t MB_N)
{
    751a:	ff 92       	push	r15
    751c:	0f 93       	push	r16
    751e:	1f 93       	push	r17
    7520:	cf 93       	push	r28
    7522:	df 93       	push	r29
    7524:	f8 2e       	mov	r15, r24
	if (Timer16Stopp(TD_MB_SlaveOff+MB_N))
    7526:	10 91 e8 04 	lds	r17, 0x04E8
    752a:	18 0f       	add	r17, r24
    752c:	01 2f       	mov	r16, r17
    752e:	0f 5f       	subi	r16, 0xFF	; 255
    7530:	80 2f       	mov	r24, r16
    7532:	0e 94 84 1f 	call	0x3f08	; 0x3f08 <Timer16Stopp>
    7536:	88 23       	and	r24, r24
    7538:	d9 f4       	brne	.+54     	; 0x7570 <MB_M_Cycle+0x56>
		SlavesOn(MB_N);

	if (Timer16Stopp(TD_MB_Idle+MB_N)){
    753a:	81 2f       	mov	r24, r17
    753c:	0e 94 84 1f 	call	0x3f08	; 0x3f08 <Timer16Stopp>
    7540:	88 23       	and	r24, r24
    7542:	81 f0       	breq	.+32     	; 0x7564 <MB_M_Cycle+0x4a>
		cli();
    7544:	f8 94       	cli
		if(MB_State[MB_N] == MB_Idle) MB_State[MB_N] = MB_NoReply;
    7546:	cf 2d       	mov	r28, r15
    7548:	d0 e0       	ldi	r29, 0x00	; 0
    754a:	fe 01       	movw	r30, r28
    754c:	ee 53       	subi	r30, 0x3E	; 62
    754e:	fa 4f       	sbci	r31, 0xFA	; 250
    7550:	80 81       	ld	r24, Z
    7552:	81 30       	cpi	r24, 0x01	; 1
    7554:	29 f1       	breq	.+74     	; 0x75a0 <MB_M_Cycle+0x86>
		sei();
    7556:	78 94       	sei
	}
	else return;
	
	switch (MB_State[MB_N]) {
    7558:	80 81       	ld	r24, Z
    755a:	84 30       	cpi	r24, 0x04	; 4
    755c:	39 f1       	breq	.+78     	; 0x75ac <MB_M_Cycle+0x92>
    755e:	85 30       	cpi	r24, 0x05	; 5
    7560:	09 f4       	brne	.+2      	; 0x7564 <MB_M_Cycle+0x4a>
    7562:	52 c0       	rjmp	.+164    	; 0x7608 <MB_M_Cycle+0xee>
		cli();
		MB_Transm(MB_N);
		sei();
		break;
	}
}
    7564:	df 91       	pop	r29
    7566:	cf 91       	pop	r28
    7568:	1f 91       	pop	r17
    756a:	0f 91       	pop	r16
    756c:	ff 90       	pop	r15
    756e:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~
static void
SlavesOn(uint8_t MB_N)
{
	SlaveSkip[MB_N] = 0;
    7570:	af 2d       	mov	r26, r15
    7572:	b0 e0       	ldi	r27, 0x00	; 0
    7574:	fd 01       	movw	r30, r26
    7576:	ee 0f       	add	r30, r30
    7578:	ff 1f       	adc	r31, r31
    757a:	ee 0f       	add	r30, r30
    757c:	ff 1f       	adc	r31, r31
    757e:	ec 51       	subi	r30, 0x1C	; 28
    7580:	fb 4f       	sbci	r31, 0xFB	; 251
    7582:	10 82       	st	Z, r1
    7584:	11 82       	std	Z+1, r1	; 0x01
    7586:	12 82       	std	Z+2, r1	; 0x02
    7588:	13 82       	std	Z+3, r1	; 0x03
	StartTimer16(TD_MB_SlaveOff+MB_N, 100*MB_M_TimeOff[MB_N]);
    758a:	a1 52       	subi	r26, 0x21	; 33
    758c:	ba 4f       	sbci	r27, 0xFA	; 250
    758e:	6c 91       	ld	r22, X
    7590:	84 e6       	ldi	r24, 0x64	; 100
    7592:	68 9f       	mul	r22, r24
    7594:	b0 01       	movw	r22, r0
    7596:	11 24       	eor	r1, r1
    7598:	80 2f       	mov	r24, r16
    759a:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
    759e:	cd cf       	rjmp	.-102    	; 0x753a <MB_M_Cycle+0x20>
	if (Timer16Stopp(TD_MB_SlaveOff+MB_N))
		SlavesOn(MB_N);

	if (Timer16Stopp(TD_MB_Idle+MB_N)){
		cli();
		if(MB_State[MB_N] == MB_Idle) MB_State[MB_N] = MB_NoReply;
    75a0:	85 e0       	ldi	r24, 0x05	; 5
    75a2:	80 83       	st	Z, r24
		sei();
    75a4:	78 94       	sei
	}
	else return;
	
	switch (MB_State[MB_N]) {
    75a6:	80 81       	ld	r24, Z
    75a8:	84 30       	cpi	r24, 0x04	; 4
    75aa:	c9 f6       	brne	.-78     	; 0x755e <MB_M_Cycle+0x44>
		cli();
		MB_Transm(MB_N);
		sei();
		break;
	case MB_Proc:
		cli();
    75ac:	f8 94       	cli
    75ae:	ce 01       	movw	r24, r28
    75b0:	88 0f       	add	r24, r24
    75b2:	99 1f       	adc	r25, r25
    75b4:	88 0f       	add	r24, r24
    75b6:	99 1f       	adc	r25, r25
    75b8:	9c 01       	movw	r18, r24
    75ba:	22 0f       	add	r18, r18
    75bc:	33 1f       	adc	r19, r19
    75be:	22 0f       	add	r18, r18
    75c0:	33 1f       	adc	r19, r19
    75c2:	28 0f       	add	r18, r24
    75c4:	39 1f       	adc	r19, r25
    75c6:	2a 58       	subi	r18, 0x8A	; 138
    75c8:	3b 4c       	sbci	r19, 0xCB	; 203
    75ca:	f9 01       	movw	r30, r18
    75cc:	85 91       	lpm	r24, Z+
    75ce:	94 91       	lpm	r25, Z+
		USART_Func(MB_N, LED);
    75d0:	fc 01       	movw	r30, r24
    75d2:	19 95       	eicall
		sei();
    75d4:	78 94       	sei
		switch (MB_SingleState[MB_N]) {
    75d6:	c1 55       	subi	r28, 0x51	; 81
    75d8:	d9 4f       	sbci	r29, 0xF9	; 249
    75da:	88 81       	ld	r24, Y
    75dc:	88 23       	and	r24, r24
    75de:	b1 f1       	breq	.+108    	; 0x764c <MB_M_Cycle+0x132>
    75e0:	81 30       	cpi	r24, 0x01	; 1
    75e2:	81 f1       	breq	.+96     	; 0x7644 <MB_M_Cycle+0x12a>
				FormQuery(MB_N);
			else
				FormSingle(MB_N);
			break;
		}
		StartTimer16(TD_MB_Idle+MB_N, 0xFFFF);	//     
    75e4:	80 91 e8 04 	lds	r24, 0x04E8
    75e8:	8f 0d       	add	r24, r15
    75ea:	6f ef       	ldi	r22, 0xFF	; 255
    75ec:	7f ef       	ldi	r23, 0xFF	; 255
    75ee:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
		cli();
    75f2:	f8 94       	cli
		MB_Transm(MB_N);
    75f4:	8f 2d       	mov	r24, r15
    75f6:	0e 94 f7 2c 	call	0x59ee	; 0x59ee <MB_Transm>
		sei();
    75fa:	78 94       	sei
		break;
	}
}
    75fc:	df 91       	pop	r29
    75fe:	cf 91       	pop	r28
    7600:	1f 91       	pop	r17
    7602:	0f 91       	pop	r16
    7604:	ff 90       	pop	r15
    7606:	08 95       	ret
	}
	else return;
	
	switch (MB_State[MB_N]) {
	case MB_NoReply:
		FailSlave(MB_N);
    7608:	8f 2d       	mov	r24, r15
    760a:	0e 94 66 35 	call	0x6acc	; 0x6acc <FailSlave>
		switch (MB_SingleState[MB_N]) {
    760e:	fe 01       	movw	r30, r28
    7610:	e1 55       	subi	r30, 0x51	; 81
    7612:	f9 4f       	sbci	r31, 0xF9	; 249
    7614:	e0 81       	ld	r30, Z
    7616:	ee 23       	and	r30, r30
    7618:	e9 f4       	brne	.+58     	; 0x7654 <MB_M_Cycle+0x13a>
		case MB_SingleIdle:
			FormQuery(MB_N);
    761a:	8f 2d       	mov	r24, r15
    761c:	0e 94 ff 33 	call	0x67fe	; 0x67fe <FormQuery>
		case MB_SingleStart:
			if (Try[MB_N]==0)
				FormSingle(MB_N);
			break;
		}
		StartTimer16(TD_MB_Idle+MB_N, 0xFFFF);	//     
    7620:	80 91 e8 04 	lds	r24, 0x04E8
    7624:	8f 0d       	add	r24, r15
    7626:	6f ef       	ldi	r22, 0xFF	; 255
    7628:	7f ef       	ldi	r23, 0xFF	; 255
    762a:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
		cli();
    762e:	f8 94       	cli
		MB_Transm(MB_N);
    7630:	8f 2d       	mov	r24, r15
    7632:	0e 94 f7 2c 	call	0x59ee	; 0x59ee <MB_Transm>
		sei();
    7636:	78 94       	sei
		cli();
		MB_Transm(MB_N);
		sei();
		break;
	}
}
    7638:	df 91       	pop	r29
    763a:	cf 91       	pop	r28
    763c:	1f 91       	pop	r17
    763e:	0f 91       	pop	r16
    7640:	ff 90       	pop	r15
    7642:	08 95       	ret
		switch (MB_SingleState[MB_N]) {
		case MB_SingleIdle:
			FormQuery(MB_N);
			break;
		case MB_SingleStart:
			if (LastProcSingle)
    7644:	80 91 e2 04 	lds	r24, 0x04E2
    7648:	88 23       	and	r24, r24
    764a:	79 f0       	breq	.+30     	; 0x766a <MB_M_Cycle+0x150>
				FormQuery(MB_N);
    764c:	8f 2d       	mov	r24, r15
    764e:	0e 94 ff 33 	call	0x67fe	; 0x67fe <FormQuery>
    7652:	c8 cf       	rjmp	.-112    	; 0x75e4 <MB_M_Cycle+0xca>
	else return;
	
	switch (MB_State[MB_N]) {
	case MB_NoReply:
		FailSlave(MB_N);
		switch (MB_SingleState[MB_N]) {
    7654:	e1 30       	cpi	r30, 0x01	; 1
    7656:	21 f7       	brne	.-56     	; 0x7620 <MB_M_Cycle+0x106>
		case MB_SingleIdle:
			FormQuery(MB_N);
			break;
		case MB_SingleStart:
			if (Try[MB_N]==0)
    7658:	cd 51       	subi	r28, 0x1D	; 29
    765a:	db 4f       	sbci	r29, 0xFB	; 251
    765c:	88 81       	ld	r24, Y
    765e:	88 23       	and	r24, r24
    7660:	f9 f6       	brne	.-66     	; 0x7620 <MB_M_Cycle+0x106>
				FormSingle(MB_N);
    7662:	8f 2d       	mov	r24, r15
    7664:	0e 94 51 34 	call	0x68a2	; 0x68a2 <FormSingle>
    7668:	db cf       	rjmp	.-74     	; 0x7620 <MB_M_Cycle+0x106>
			break;
		case MB_SingleStart:
			if (LastProcSingle)
				FormQuery(MB_N);
			else
				FormSingle(MB_N);
    766a:	8f 2d       	mov	r24, r15
    766c:	0e 94 51 34 	call	0x68a2	; 0x68a2 <FormSingle>
    7670:	b9 cf       	rjmp	.-142    	; 0x75e4 <MB_M_Cycle+0xca>

00007672 <MB_Cycle>:
}

// ~~~~~~~~~~~
void
MB_Cycle(void)
{
    7672:	cf 93       	push	r28
    7674:	df 93       	push	r29
	void MB_S_Timer_ISR(uint8_t);
	void MB_M_Timer_ISR(uint8_t);

	for (uint8_t MB_N=0; MB_N<Modbus_Qt; MB_N++){
		if(MB_TimerFlag & (1<<MB_N)){
    7676:	80 91 2a 09 	lds	r24, 0x092A
    767a:	80 fd       	sbrc	r24, 0
    767c:	0c c0       	rjmp	.+24     	; 0x7696 <MB_Cycle+0x24>
    767e:	cc e7       	ldi	r28, 0x7C	; 124
    7680:	d4 e3       	ldi	r29, 0x34	; 52

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    7682:	fe 01       	movw	r30, r28
    7684:	84 91       	lpm	r24, Z+
	}

	void MB_M_Cycle(uint8_t);

	for (uint8_t MB_N=0; MB_N<Modbus_Qt; MB_N++)
		if (prb(MB_Role+MB_N)==Role_Master)
    7686:	81 30       	cpi	r24, 0x01	; 1
    7688:	19 f4       	brne	.+6      	; 0x7690 <MB_Cycle+0x1e>
			MB_M_Cycle(MB_N);
    768a:	80 e0       	ldi	r24, 0x00	; 0
    768c:	0e 94 8d 3a 	call	0x751a	; 0x751a <MB_M_Cycle>
}
    7690:	df 91       	pop	r29
    7692:	cf 91       	pop	r28
    7694:	08 95       	ret
	void MB_S_Timer_ISR(uint8_t);
	void MB_M_Timer_ISR(uint8_t);

	for (uint8_t MB_N=0; MB_N<Modbus_Qt; MB_N++){
		if(MB_TimerFlag & (1<<MB_N)){
			cli();
    7696:	f8 94       	cli
			MB_TimerFlag &= ~(1<<MB_N);
    7698:	80 91 2a 09 	lds	r24, 0x092A
    769c:	8e 7f       	andi	r24, 0xFE	; 254
    769e:	80 93 2a 09 	sts	0x092A, r24
			sei();
    76a2:	78 94       	sei
    76a4:	cc e7       	ldi	r28, 0x7C	; 124
    76a6:	d4 e3       	ldi	r29, 0x34	; 52
    76a8:	fe 01       	movw	r30, r28
    76aa:	84 91       	lpm	r24, Z+
			switch (prb(MB_Role+MB_N)) {
    76ac:	88 23       	and	r24, r24
    76ae:	21 f4       	brne	.+8      	; 0x76b8 <MB_Cycle+0x46>
			case Role_Slave:
				MB_S_Timer_ISR(MB_N);
    76b0:	80 e0       	ldi	r24, 0x00	; 0
    76b2:	0e 94 af 2e 	call	0x5d5e	; 0x5d5e <MB_S_Timer_ISR>
    76b6:	e5 cf       	rjmp	.-54     	; 0x7682 <MB_Cycle+0x10>
	for (uint8_t MB_N=0; MB_N<Modbus_Qt; MB_N++){
		if(MB_TimerFlag & (1<<MB_N)){
			cli();
			MB_TimerFlag &= ~(1<<MB_N);
			sei();
			switch (prb(MB_Role+MB_N)) {
    76b8:	81 30       	cpi	r24, 0x01	; 1
    76ba:	19 f7       	brne	.-58     	; 0x7682 <MB_Cycle+0x10>
			case Role_Slave:
				MB_S_Timer_ISR(MB_N);
				break;
			case Role_Master:
				MB_M_Timer_ISR(MB_N);
    76bc:	80 e0       	ldi	r24, 0x00	; 0
    76be:	0e 94 dc 35 	call	0x6bb8	; 0x6bb8 <MB_M_Timer_ISR>
    76c2:	df cf       	rjmp	.-66     	; 0x7682 <MB_Cycle+0x10>

000076c4 <SetIP>:
	uint8_t IP3;
	uint8_t IP4;
} IP_Addr;

//~~~~~~~~~~~~~~
void SetIP(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
    76c4:	0f 93       	push	r16
    76c6:	fc 01       	movw	r30, r24
	IP->IP1 = IP1;
    76c8:	60 83       	st	Z, r22
	IP->IP2 = IP2;
    76ca:	41 83       	std	Z+1, r20	; 0x01
	IP->IP3 = IP3;
    76cc:	22 83       	std	Z+2, r18	; 0x02
	IP->IP4 = IP4;
    76ce:	03 83       	std	Z+3, r16	; 0x03
}
    76d0:	0f 91       	pop	r16
    76d2:	08 95       	ret

000076d4 <IP_compare_Const>:
uint8_t IP_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
    76d4:	0f 93       	push	r16
    76d6:	fc 01       	movw	r30, r24
	if((IP->IP1 == IP1) && (IP->IP2 == IP2) && (IP->IP3 == IP3) && (IP->IP4 == IP4)) return 1;
    76d8:	80 81       	ld	r24, Z
    76da:	86 17       	cp	r24, r22
    76dc:	21 f0       	breq	.+8      	; 0x76e6 <IP_compare_Const+0x12>
    76de:	20 e0       	ldi	r18, 0x00	; 0
	else return 0;
}
    76e0:	82 2f       	mov	r24, r18
    76e2:	0f 91       	pop	r16
    76e4:	08 95       	ret
	IP->IP2 = IP2;
	IP->IP3 = IP3;
	IP->IP4 = IP4;
}
uint8_t IP_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	if((IP->IP1 == IP1) && (IP->IP2 == IP2) && (IP->IP3 == IP3) && (IP->IP4 == IP4)) return 1;
    76e6:	81 81       	ldd	r24, Z+1	; 0x01
    76e8:	84 17       	cp	r24, r20
    76ea:	c9 f7       	brne	.-14     	; 0x76de <IP_compare_Const+0xa>
    76ec:	82 81       	ldd	r24, Z+2	; 0x02
    76ee:	82 17       	cp	r24, r18
    76f0:	b1 f7       	brne	.-20     	; 0x76de <IP_compare_Const+0xa>
    76f2:	20 e0       	ldi	r18, 0x00	; 0
    76f4:	83 81       	ldd	r24, Z+3	; 0x03
    76f6:	80 13       	cpse	r24, r16
    76f8:	21 e0       	ldi	r18, 0x01	; 1
    76fa:	81 e0       	ldi	r24, 0x01	; 1
    76fc:	28 27       	eor	r18, r24
    76fe:	f0 cf       	rjmp	.-32     	; 0x76e0 <IP_compare_Const+0xc>

00007700 <GSM_StartCalling>:
uint8_t numOfCheckBallanceRetry=0;

uint8_t Message[3];  // 
uint8_t GSMBusyState=0; // " " 0 -  , 1 -  
void GSM_StartCalling(uint8_t inputN,uint8_t abonentN){
	Message[0]=1;
    7700:	91 e0       	ldi	r25, 0x01	; 1
    7702:	90 93 35 07 	sts	0x0735, r25
	Message[1]=inputN;
    7706:	80 93 36 07 	sts	0x0736, r24
	Message[2]=abonentN;
    770a:	60 93 37 07 	sts	0x0737, r22
}
    770e:	08 95       	ret

00007710 <InitFIFO>:
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    7710:	8f ef       	ldi	r24, 0xFF	; 255
    7712:	80 93 3e 07 	sts	0x073E, r24
	GSM_RX_FIFO_End = 255;
    7716:	80 93 53 06 	sts	0x0653, r24
	GSM_RxCharN = 0;
    771a:	10 92 60 0b 	sts	0x0B60, r1
	GSM_RX_FIFOOverFlow = 0;
    771e:	10 92 13 09 	sts	0x0913, r1
	GSM_RX_FIFOMax = 0;
    7722:	10 92 19 09 	sts	0x0919, r1
}
    7726:	08 95       	ret

00007728 <GetByteFromFIFO>:
// ~~~~~~~~~~~
void GetByteFromFIFO(uint8_t *ReadBuf, uint8_t *Index, uint8_t ReadBuf_Sz){
    7728:	0f 93       	push	r16
    772a:	1f 93       	push	r17
    772c:	cf 93       	push	r28
    772e:	df 93       	push	r29
    7730:	8c 01       	movw	r16, r24
    7732:	eb 01       	movw	r28, r22

	//Reset *Index if read buffer overflow
	if(*Index >= ReadBuf_Sz){
    7734:	88 81       	ld	r24, Y
    7736:	84 17       	cp	r24, r20
    7738:	08 f0       	brcs	.+2      	; 0x773c <GetByteFromFIFO+0x14>
		*Index = 0;
    773a:	18 82       	st	Y, r1
		//TODO  
	}	

	if(GSM_RX_FIFO_Begin > GSM_RX_FIFO_End){
    773c:	80 91 3e 07 	lds	r24, 0x073E
    7740:	e0 91 53 06 	lds	r30, 0x0653
    7744:	e8 17       	cp	r30, r24
    7746:	f8 f4       	brcc	.+62     	; 0x7786 <GetByteFromFIFO+0x5e>
		if((GSM_RX_FIFO_End != 255)&&(GSM_RX_FIFO_End != 255))			
    7748:	ef 3f       	cpi	r30, 0xFF	; 255
    774a:	61 f0       	breq	.+24     	; 0x7764 <GetByteFromFIFO+0x3c>
			if(GSM_RX_FIFOMax < (GSM_RX_FIFO_Begin - GSM_RX_FIFO_End))
    774c:	20 91 19 09 	lds	r18, 0x0919
    7750:	80 91 3e 07 	lds	r24, 0x073E
    7754:	30 e0       	ldi	r19, 0x00	; 0
    7756:	90 e0       	ldi	r25, 0x00	; 0
    7758:	8e 1b       	sub	r24, r30
    775a:	91 09       	sbc	r25, r1
    775c:	28 17       	cp	r18, r24
    775e:	39 07       	cpc	r19, r25
    7760:	0c f4       	brge	.+2      	; 0x7764 <GetByteFromFIFO+0x3c>
    7762:	46 c0       	rjmp	.+140    	; 0x77f0 <GetByteFromFIFO+0xc8>
				GSM_RX_FIFOMax =  GSM_RX_FIFO_Begin - GSM_RX_FIFO_End;
		GSM_RX_FIFO_End++;
    7764:	ef 5f       	subi	r30, 0xFF	; 255
    7766:	e0 93 53 06 	sts	0x0653, r30
		ReadBuf[*Index] = GSM_RX_FIFO[GSM_RX_FIFO_End];
    776a:	88 81       	ld	r24, Y
    776c:	d8 01       	movw	r26, r16
    776e:	a8 0f       	add	r26, r24
    7770:	b1 1d       	adc	r27, r1
    7772:	f0 e0       	ldi	r31, 0x00	; 0
    7774:	ef 51       	subi	r30, 0x1F	; 31
    7776:	fa 4f       	sbci	r31, 0xFA	; 250
    7778:	80 81       	ld	r24, Z
    777a:	8c 93       	st	X, r24
		*Index=*Index+1;
    777c:	88 81       	ld	r24, Y
    777e:	8f 5f       	subi	r24, 0xFF	; 255
    7780:	88 83       	st	Y, r24
    7782:	e0 91 53 06 	lds	r30, 0x0653
	}
	if(GSM_RX_FIFO_End > GSM_RX_FIFO_Begin){
    7786:	80 91 3e 07 	lds	r24, 0x073E
    778a:	8e 17       	cp	r24, r30
    778c:	28 f5       	brcc	.+74     	; 0x77d8 <GetByteFromFIFO+0xb0>
		if((GSM_RX_FIFO_End != 255)&&(GSM_RX_FIFO_End != 255))
    778e:	ef 3f       	cpi	r30, 0xFF	; 255
    7790:	99 f0       	breq	.+38     	; 0x77b8 <GetByteFromFIFO+0x90>
			if(GSM_RX_FIFOMax < (GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End  + GSM_RX_FIFO_Begin))
    7792:	20 91 19 09 	lds	r18, 0x0919
    7796:	80 91 3e 07 	lds	r24, 0x073E
    779a:	30 e0       	ldi	r19, 0x00	; 0
    779c:	90 e0       	ldi	r25, 0x00	; 0
    779e:	8c 59       	subi	r24, 0x9C	; 156
    77a0:	9f 4f       	sbci	r25, 0xFF	; 255
    77a2:	8e 1b       	sub	r24, r30
    77a4:	91 09       	sbc	r25, r1
    77a6:	28 17       	cp	r18, r24
    77a8:	39 07       	cpc	r19, r25
    77aa:	dc f0       	brlt	.+54     	; 0x77e2 <GetByteFromFIFO+0xba>
				GSM_RX_FIFOMax = GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End  + GSM_RX_FIFO_Begin;
		GSM_RX_FIFO_End++;
    77ac:	8e 2f       	mov	r24, r30
    77ae:	8f 5f       	subi	r24, 0xFF	; 255
    77b0:	80 93 53 06 	sts	0x0653, r24
		if(GSM_RX_FIFO_End >= GSM_RX_FIFO_SIZE) GSM_RX_FIFO_End = 0;
    77b4:	84 36       	cpi	r24, 0x64	; 100
    77b6:	10 f0       	brcs	.+4      	; 0x77bc <GetByteFromFIFO+0x94>
    77b8:	10 92 53 06 	sts	0x0653, r1
		ReadBuf[*Index] = GSM_RX_FIFO[GSM_RX_FIFO_End];
    77bc:	88 81       	ld	r24, Y
    77be:	08 0f       	add	r16, r24
    77c0:	11 1d       	adc	r17, r1
    77c2:	e0 91 53 06 	lds	r30, 0x0653
    77c6:	f0 e0       	ldi	r31, 0x00	; 0
    77c8:	ef 51       	subi	r30, 0x1F	; 31
    77ca:	fa 4f       	sbci	r31, 0xFA	; 250
    77cc:	80 81       	ld	r24, Z
    77ce:	f8 01       	movw	r30, r16
    77d0:	80 83       	st	Z, r24
		*Index=*Index+1;
    77d2:	88 81       	ld	r24, Y
    77d4:	8f 5f       	subi	r24, 0xFF	; 255
    77d6:	88 83       	st	Y, r24
	}
}
    77d8:	df 91       	pop	r29
    77da:	cf 91       	pop	r28
    77dc:	1f 91       	pop	r17
    77de:	0f 91       	pop	r16
    77e0:	08 95       	ret
		*Index=*Index+1;
	}
	if(GSM_RX_FIFO_End > GSM_RX_FIFO_Begin){
		if((GSM_RX_FIFO_End != 255)&&(GSM_RX_FIFO_End != 255))
			if(GSM_RX_FIFOMax < (GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End  + GSM_RX_FIFO_Begin))
				GSM_RX_FIFOMax = GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End  + GSM_RX_FIFO_Begin;
    77e2:	80 91 3e 07 	lds	r24, 0x073E
    77e6:	8c 59       	subi	r24, 0x9C	; 156
    77e8:	8e 1b       	sub	r24, r30
    77ea:	80 93 19 09 	sts	0x0919, r24
    77ee:	de cf       	rjmp	.-68     	; 0x77ac <GetByteFromFIFO+0x84>
	}	

	if(GSM_RX_FIFO_Begin > GSM_RX_FIFO_End){
		if((GSM_RX_FIFO_End != 255)&&(GSM_RX_FIFO_End != 255))			
			if(GSM_RX_FIFOMax < (GSM_RX_FIFO_Begin - GSM_RX_FIFO_End))
				GSM_RX_FIFOMax =  GSM_RX_FIFO_Begin - GSM_RX_FIFO_End;
    77f0:	80 91 3e 07 	lds	r24, 0x073E
    77f4:	8e 1b       	sub	r24, r30
    77f6:	80 93 19 09 	sts	0x0919, r24
    77fa:	b4 cf       	rjmp	.-152    	; 0x7764 <GetByteFromFIFO+0x3c>

000077fc <GetStringFromFIFO>:
//        
uint8_t GetStringFromFIFO(void){

	uint8_t StrLength = 0;

	while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    77fc:	90 91 3e 07 	lds	r25, 0x073E
    7800:	80 91 53 06 	lds	r24, 0x0653
    7804:	98 17       	cp	r25, r24
    7806:	39 f1       	breq	.+78     	; 0x7856 <GetStringFromFIFO+0x5a>
		
		GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);
    7808:	81 ee       	ldi	r24, 0xE1	; 225
    780a:	97 e0       	ldi	r25, 0x07	; 7
    780c:	60 e6       	ldi	r22, 0x60	; 96
    780e:	7b e0       	ldi	r23, 0x0B	; 11
    7810:	44 e6       	ldi	r20, 0x64	; 100
    7812:	0e 94 94 3b 	call	0x7728	; 0x7728 <GetByteFromFIFO>

		//   : xxxxxxxxxxxxxxxx<CR><LF>
		//	'\r' CR - carridge return 0x0D
		//	'\n' LF - line feed 0x0A
		//   xxxxxxxxxxxxxxxx<\0>
		if( (GSM_RxCharN >= 2) && (GSM_RxStr[GSM_RxCharN-2]== '\r') && (GSM_RxStr[GSM_RxCharN-1]== '\n') ){
    7816:	80 91 60 0b 	lds	r24, 0x0B60
    781a:	82 30       	cpi	r24, 0x02	; 2
    781c:	78 f3       	brcs	.-34     	; 0x77fc <GetStringFromFIFO>
    781e:	e0 91 60 0b 	lds	r30, 0x0B60
    7822:	f0 e0       	ldi	r31, 0x00	; 0
    7824:	e1 52       	subi	r30, 0x21	; 33
    7826:	f8 4f       	sbci	r31, 0xF8	; 248
    7828:	80 81       	ld	r24, Z
    782a:	8d 30       	cpi	r24, 0x0D	; 13
    782c:	39 f7       	brne	.-50     	; 0x77fc <GetStringFromFIFO>
    782e:	e0 91 60 0b 	lds	r30, 0x0B60
    7832:	f0 e0       	ldi	r31, 0x00	; 0
    7834:	e0 52       	subi	r30, 0x20	; 32
    7836:	f8 4f       	sbci	r31, 0xF8	; 248
    7838:	80 81       	ld	r24, Z
    783a:	8a 30       	cpi	r24, 0x0A	; 10
    783c:	f9 f6       	brne	.-66     	; 0x77fc <GetStringFromFIFO>
			GSM_RxStr[GSM_RxCharN-2] = '\0';
    783e:	e0 91 60 0b 	lds	r30, 0x0B60
    7842:	f0 e0       	ldi	r31, 0x00	; 0
    7844:	e1 52       	subi	r30, 0x21	; 33
    7846:	f8 4f       	sbci	r31, 0xF8	; 248
    7848:	10 82       	st	Z, r1
			StrLength = GSM_RxCharN-1;
    784a:	80 91 60 0b 	lds	r24, 0x0B60
    784e:	81 50       	subi	r24, 0x01	; 1
			GSM_RxCharN = 0;
    7850:	10 92 60 0b 	sts	0x0B60, r1
    7854:	08 95       	ret
//        
uint8_t GetStringFromFIFO(void){

	uint8_t StrLength = 0;

	while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    7856:	80 e0       	ldi	r24, 0x00	; 0
		}

	}//while
	
	return StrLength;
}
    7858:	08 95       	ret

0000785a <GetStringFromFIFOwithOverflowDetect>:

uint8_t GetStringFromFIFOwithOverflowDetect(void){
    785a:	04 c0       	rjmp	.+8      	; 0x7864 <GetStringFromFIFOwithOverflowDetect+0xa>

		//   : xxxxxxxxxxxxxxxx<CR><LF>
		//	'\r' CR - carridge return 0x0D
		//	'\n' LF - line feed 0x0A
		//   xxxxxxxxxxxxxxxx<\0>
		if( ((GSM_RxCharN >= 2) && (GSM_RxStr[GSM_RxCharN-2]== '\r') && (GSM_RxStr[GSM_RxCharN-1]== '\n'))||(GSM_RxCharN==GSM_RXSTR_SIZE-1) ){
    785c:	80 91 60 0b 	lds	r24, 0x0B60
    7860:	83 36       	cpi	r24, 0x63	; 99
    7862:	09 f1       	breq	.+66     	; 0x78a6 <GetStringFromFIFOwithOverflowDetect+0x4c>

uint8_t GetStringFromFIFOwithOverflowDetect(void){

	uint8_t StrLength = 0;

	while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    7864:	90 91 3e 07 	lds	r25, 0x073E
    7868:	80 91 53 06 	lds	r24, 0x0653
    786c:	98 17       	cp	r25, r24
    786e:	39 f1       	breq	.+78     	; 0x78be <GetStringFromFIFOwithOverflowDetect+0x64>
		
		GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);
    7870:	81 ee       	ldi	r24, 0xE1	; 225
    7872:	97 e0       	ldi	r25, 0x07	; 7
    7874:	60 e6       	ldi	r22, 0x60	; 96
    7876:	7b e0       	ldi	r23, 0x0B	; 11
    7878:	44 e6       	ldi	r20, 0x64	; 100
    787a:	0e 94 94 3b 	call	0x7728	; 0x7728 <GetByteFromFIFO>

		//   : xxxxxxxxxxxxxxxx<CR><LF>
		//	'\r' CR - carridge return 0x0D
		//	'\n' LF - line feed 0x0A
		//   xxxxxxxxxxxxxxxx<\0>
		if( ((GSM_RxCharN >= 2) && (GSM_RxStr[GSM_RxCharN-2]== '\r') && (GSM_RxStr[GSM_RxCharN-1]== '\n'))||(GSM_RxCharN==GSM_RXSTR_SIZE-1) ){
    787e:	80 91 60 0b 	lds	r24, 0x0B60
    7882:	82 30       	cpi	r24, 0x02	; 2
    7884:	58 f3       	brcs	.-42     	; 0x785c <GetStringFromFIFOwithOverflowDetect+0x2>
    7886:	e0 91 60 0b 	lds	r30, 0x0B60
    788a:	f0 e0       	ldi	r31, 0x00	; 0
    788c:	e1 52       	subi	r30, 0x21	; 33
    788e:	f8 4f       	sbci	r31, 0xF8	; 248
    7890:	80 81       	ld	r24, Z
    7892:	8d 30       	cpi	r24, 0x0D	; 13
    7894:	19 f7       	brne	.-58     	; 0x785c <GetStringFromFIFOwithOverflowDetect+0x2>
    7896:	e0 91 60 0b 	lds	r30, 0x0B60
    789a:	f0 e0       	ldi	r31, 0x00	; 0
    789c:	e0 52       	subi	r30, 0x20	; 32
    789e:	f8 4f       	sbci	r31, 0xF8	; 248
    78a0:	80 81       	ld	r24, Z
    78a2:	8a 30       	cpi	r24, 0x0A	; 10
    78a4:	d9 f6       	brne	.-74     	; 0x785c <GetStringFromFIFOwithOverflowDetect+0x2>
			GSM_RxStr[GSM_RxCharN-2] = '\0';
    78a6:	e0 91 60 0b 	lds	r30, 0x0B60
    78aa:	f0 e0       	ldi	r31, 0x00	; 0
    78ac:	e1 52       	subi	r30, 0x21	; 33
    78ae:	f8 4f       	sbci	r31, 0xF8	; 248
    78b0:	10 82       	st	Z, r1
			StrLength = GSM_RxCharN-1;
    78b2:	80 91 60 0b 	lds	r24, 0x0B60
    78b6:	81 50       	subi	r24, 0x01	; 1
			GSM_RxCharN = 0;
    78b8:	10 92 60 0b 	sts	0x0B60, r1
    78bc:	08 95       	ret

uint8_t GetStringFromFIFOwithOverflowDetect(void){

	uint8_t StrLength = 0;

	while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    78be:	80 e0       	ldi	r24, 0x00	; 0
		}

	}//while
	
	return StrLength;
}
    78c0:	08 95       	ret

000078c2 <ForceEndStringFromFIFO>:
// ~~~~~~~~~~~
//    GSM_RxStr  <CR><LF>
uint8_t ForceEndStringFromFIFO(void){
	uint8_t StrLength;
	if(GSM_RxCharN > GSM_RXSTR_SIZE-1) GSM_RxCharN = GSM_RXSTR_SIZE-1;
    78c2:	80 91 60 0b 	lds	r24, 0x0B60
    78c6:	84 36       	cpi	r24, 0x64	; 100
    78c8:	18 f0       	brcs	.+6      	; 0x78d0 <ForceEndStringFromFIFO+0xe>
    78ca:	83 e6       	ldi	r24, 0x63	; 99
    78cc:	80 93 60 0b 	sts	0x0B60, r24
	StrLength = GSM_RxCharN;
    78d0:	80 91 60 0b 	lds	r24, 0x0B60
	GSM_RxStr[GSM_RxCharN]='\0';
    78d4:	e0 91 60 0b 	lds	r30, 0x0B60
    78d8:	f0 e0       	ldi	r31, 0x00	; 0
    78da:	ef 51       	subi	r30, 0x1F	; 31
    78dc:	f8 4f       	sbci	r31, 0xF8	; 248
    78de:	10 82       	st	Z, r1
	GSM_RxCharN = 0;
    78e0:	10 92 60 0b 	sts	0x0B60, r1
	return StrLength;
}
    78e4:	08 95       	ret

000078e6 <GetDataFromFIFO>:

// ~~~~~~~~~~~
uint8_t GetDataFromFIFO(const uint8_t Amount){
    78e6:	1f 93       	push	r17
    78e8:	18 2f       	mov	r17, r24

	while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    78ea:	90 91 3e 07 	lds	r25, 0x073E
    78ee:	80 91 53 06 	lds	r24, 0x0653
    78f2:	98 17       	cp	r25, r24
    78f4:	81 f0       	breq	.+32     	; 0x7916 <GetDataFromFIFO+0x30>
		GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);
    78f6:	81 ee       	ldi	r24, 0xE1	; 225
    78f8:	97 e0       	ldi	r25, 0x07	; 7
    78fa:	60 e6       	ldi	r22, 0x60	; 96
    78fc:	7b e0       	ldi	r23, 0x0B	; 11
    78fe:	44 e6       	ldi	r20, 0x64	; 100
    7900:	0e 94 94 3b 	call	0x7728	; 0x7728 <GetByteFromFIFO>
		if(GSM_RxCharN >= Amount){
    7904:	80 91 60 0b 	lds	r24, 0x0B60
    7908:	81 17       	cp	r24, r17
    790a:	78 f3       	brcs	.-34     	; 0x78ea <GetDataFromFIFO+0x4>
			GSM_RxCharN = 0;
    790c:	10 92 60 0b 	sts	0x0B60, r1
			return Amount;
		}
	}//while
	return GSM_RxCharN;
}
    7910:	81 2f       	mov	r24, r17
    7912:	1f 91       	pop	r17
    7914:	08 95       	ret
		if(GSM_RxCharN >= Amount){
			GSM_RxCharN = 0;
			return Amount;
		}
	}//while
	return GSM_RxCharN;
    7916:	10 91 60 0b 	lds	r17, 0x0B60
}
    791a:	81 2f       	mov	r24, r17
    791c:	1f 91       	pop	r17
    791e:	08 95       	ret

00007920 <GSM_Init>:
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    7920:	8f ef       	ldi	r24, 0xFF	; 255
    7922:	80 93 3e 07 	sts	0x073E, r24
	GSM_RX_FIFO_End = 255;
    7926:	80 93 53 06 	sts	0x0653, r24
	GSM_RxCharN = 0;
    792a:	10 92 60 0b 	sts	0x0B60, r1
	GSM_RX_FIFOOverFlow = 0;
    792e:	10 92 13 09 	sts	0x0913, r1
	GSM_RX_FIFOMax = 0;
    7932:	10 92 19 09 	sts	0x0919, r1
		USART_GSM.BAUDCTRLB = 0x00 + USART_BSCALE0_bm;
		USART_GSM.CTRLA = USART_RXCINTLVL_HI_gc;
		USART_GSM.CTRLB = (1<<USART_RXEN_bp) | (1<<USART_TXEN_bp) | (0<<USART_CLK2X_bp) | (0 << USART_MPCM_bp) | (0 << USART_TXB8_bp);
		USART_GSM.CTRLC = USART_CMODE_ASYNCHRONOUS_gc | USART_PMODE_DISABLED_gc | (0<< USART_SBMODE_bp) | USART_CHSIZE_8BIT_gc;
	#else
		UCSR_GSM_A = ~(1<<U2X_GSM) &~(1<<MPCM_GSM);
    7936:	8c ef       	ldi	r24, 0xFC	; 252
    7938:	80 93 d0 00 	sts	0x00D0, r24
		UCSR_GSM_B =  (1<<RXCIE_GSM) | (0<<TXCIE_GSM) | (0<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    793c:	88 e9       	ldi	r24, 0x98	; 152
    793e:	80 93 d1 00 	sts	0x00D1, r24
		#if defined (__AVR_ATmega2561__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__)			
			UCSR_GSM_C = (0<<UMSEL_GSM_1) | (0<<UMSEL_GSM_0) | (0<<UPM_GSM_1) | (0<<UPM_GSM_0) | (0<<USBS_GSM) | (1<<UCSZ_GSM_1) | (1<<UCSZ_GSM_0) | (0<<UCPOL_GSM);
    7942:	86 e0       	ldi	r24, 0x06	; 6
    7944:	80 93 d2 00 	sts	0x00D2, r24
		#else
			UCSR_GSM_C = ((~(1<<UMSEL_GSM) &~(1<<UPM_GSM_1) &~(1<<UPM_GSM_0) &~(1<<USBS_GSM)) |(1<<UCSZ_GSM_1) |(1<<UCSZ_GSM_0)) &~(1<<UCPOL_GSM);
		#endif
		UBRR_GSM_H = 0x00;
    7948:	10 92 d5 00 	sts	0x00D5, r1
		UBRR_GSM_L = 0x67;	// 9600
    794c:	87 e6       	ldi	r24, 0x67	; 103
    794e:	80 93 d4 00 	sts	0x00D4, r24
#endif

//  gsm_sim900r.h   PWRCNTRL
#ifdef vmd2_3
	void GSM_PWRCNTRL_Config(void){
		cli();
    7952:	f8 94       	cli
		DDRL|=(1<<PL5);
    7954:	ea e0       	ldi	r30, 0x0A	; 10
    7956:	f1 e0       	ldi	r31, 0x01	; 1
    7958:	80 81       	ld	r24, Z
    795a:	80 62       	ori	r24, 0x20	; 32
    795c:	80 83       	st	Z, r24
		sei();
    795e:	78 94       	sei
		cli();
		PORTL|=(1<<PL5);
		sei();
	}
	void GSM_PWRCNTRL_ON(void){
		cli();
    7960:	f8 94       	cli
		PORTL &= ~(1<<PL5);
    7962:	eb e0       	ldi	r30, 0x0B	; 11
    7964:	f1 e0       	ldi	r31, 0x01	; 1
    7966:	80 81       	ld	r24, Z
    7968:	8f 7d       	andi	r24, 0xDF	; 223
    796a:	80 83       	st	Z, r24
		sei();
    796c:	78 94       	sei

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    796e:	80 91 d0 02 	lds	r24, 0x02D0
	VacantTimer16Sys += n;
    7972:	98 2f       	mov	r25, r24
    7974:	9f 5f       	subi	r25, 0xFF	; 255
	GSM_PWRCNTRL_ON();
	#ifdef GSM_HW_FLOW_CONTROL
		GSM_CTS_RTS_Config();
	#endif

	TD_GSM = Timer16SysAlloc(1);
    7976:	80 93 e9 04 	sts	0x04E9, r24
    797a:	29 2f       	mov	r18, r25
    797c:	2f 5f       	subi	r18, 0xFF	; 255
	TD_TCP_Connect = Timer16SysAlloc(1);
    797e:	90 93 ea 04 	sts	0x04EA, r25

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer32SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer32Sys;
    7982:	90 91 d1 02 	lds	r25, 0x02D1
	VacantTimer32Sys += n;
    7986:	89 2f       	mov	r24, r25
    7988:	8f 5f       	subi	r24, 0xFF	; 255
	TD_GSM_Reset = Timer32SysAlloc(1);
    798a:	90 93 eb 04 	sts	0x04EB, r25
// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
	VacantTimer16Sys += n;
    798e:	92 2f       	mov	r25, r18
    7990:	9f 5f       	subi	r25, 0xFF	; 255
	TD_5min_timer = Timer16SysAlloc(1);
    7992:	20 93 ec 04 	sts	0x04EC, r18
// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer32SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer32Sys;
	VacantTimer32Sys += n;
    7996:	8f 5f       	subi	r24, 0xFF	; 255
    7998:	80 93 d1 02 	sts	0x02D1, r24
    799c:	81 50       	subi	r24, 0x01	; 1
	TD_1hour_resetGPRS_timer = Timer32SysAlloc(1);
    799e:	80 93 ed 04 	sts	0x04ED, r24
// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
	VacantTimer16Sys += n;
    79a2:	89 2f       	mov	r24, r25
    79a4:	8f 5f       	subi	r24, 0xFF	; 255
	TD_CheckModem = Timer16SysAlloc(1);
    79a6:	90 93 ee 04 	sts	0x04EE, r25
    79aa:	9e 5f       	subi	r25, 0xFE	; 254
	TD_CleanFIFO = Timer16SysAlloc(1);
    79ac:	80 93 ef 04 	sts	0x04EF, r24
    79b0:	8e 5f       	subi	r24, 0xFE	; 254
	TD_data_start_delay = Timer16SysAlloc(1);
    79b2:	90 93 f0 04 	sts	0x04F0, r25
    79b6:	8f 5f       	subi	r24, 0xFF	; 255
    79b8:	80 93 d0 02 	sts	0x02D0, r24
    79bc:	81 50       	subi	r24, 0x01	; 1
	TD_timer_after_page_transfer = Timer16SysAlloc(1);
    79be:	80 93 f1 04 	sts	0x04F1, r24

/*	for (uint8_t i=0; i<4; i++)
		GPRS_ServerAddr[i] = erb(GPRS_ServerAddr_EE+i);
*/
	GSM_Control = GSM_CNTL_AUTO;
    79c2:	10 92 d1 07 	sts	0x07D1, r1
	GSM_State = GSM_PowerOn;
    79c6:	10 92 f6 06 	sts	0x06F6, r1



}
    79ca:	08 95       	ret

000079cc <GSM_RX>:
// ~~~~~~~~~
void
GSM_RX(void)
{
	char Char = UDR_GSM;
    79cc:	90 91 d6 00 	lds	r25, 0x00D6

	//---FIFO
	GSM_RX_FIFO_Begin++;
    79d0:	80 91 3e 07 	lds	r24, 0x073E
    79d4:	8f 5f       	subi	r24, 0xFF	; 255
    79d6:	80 93 3e 07 	sts	0x073E, r24
	if(GSM_RX_FIFO_Begin >= GSM_RX_FIFO_SIZE) GSM_RX_FIFO_Begin = 0;
    79da:	80 91 3e 07 	lds	r24, 0x073E
    79de:	84 36       	cpi	r24, 0x64	; 100
    79e0:	10 f0       	brcs	.+4      	; 0x79e6 <GSM_RX+0x1a>
    79e2:	10 92 3e 07 	sts	0x073E, r1
	GSM_RX_FIFO[GSM_RX_FIFO_Begin] = Char;
    79e6:	e0 91 3e 07 	lds	r30, 0x073E
    79ea:	f0 e0       	ldi	r31, 0x00	; 0
    79ec:	ef 51       	subi	r30, 0x1F	; 31
    79ee:	fa 4f       	sbci	r31, 0xFA	; 250
    79f0:	90 83       	st	Z, r25
	if(GSM_RX_FIFO_Begin == GSM_RX_FIFO_End){
    79f2:	90 91 3e 07 	lds	r25, 0x073E
    79f6:	80 91 53 06 	lds	r24, 0x0653
    79fa:	98 13       	cpse	r25, r24
    79fc:	08 95       	ret
		GSM_RX_FIFOOverFlow = 1;
    79fe:	81 e0       	ldi	r24, 0x01	; 1
    7a00:	80 93 13 09 	sts	0x0913, r24
		GSM_RX_FIFOMax = GSM_RX_FIFO_SIZE;
    7a04:	84 e6       	ldi	r24, 0x64	; 100
    7a06:	80 93 19 09 	sts	0x0919, r24
    7a0a:	08 95       	ret

00007a0c <GSM_Wait_Char>:
		else return 1;
	}
	else return 0;
}
// ~~~~~~~~~
uint8_t GSM_Wait_Char(char Char, uint8_t RestoreCMD){
    7a0c:	0f 93       	push	r16
    7a0e:	1f 93       	push	r17
    7a10:	08 2f       	mov	r16, r24
    7a12:	16 2f       	mov	r17, r22
	if(Timer16Stopp(TD_GSM)){
    7a14:	80 91 e9 04 	lds	r24, 0x04E9
    7a18:	0e 94 84 1f 	call	0x3f08	; 0x3f08 <Timer16Stopp>
    7a1c:	88 23       	and	r24, r24
    7a1e:	39 f0       	breq	.+14     	; 0x7a2e <GSM_Wait_Char+0x22>
		GSM_State = RestoreCMD;
    7a20:	10 93 f6 06 	sts	0x06F6, r17
    7a24:	90 e0       	ldi	r25, 0x00	; 0
	if(GetDataFromFIFO(1)){
		if(GSM_RxStr[0] == Char)	return 1;
		else return 0;
	}
	else return 0;
}
    7a26:	89 2f       	mov	r24, r25
    7a28:	1f 91       	pop	r17
    7a2a:	0f 91       	pop	r16
    7a2c:	08 95       	ret
	if(Timer16Stopp(TD_GSM)){
		GSM_State = RestoreCMD;
		return 0;
	}
	//   
	if(GetDataFromFIFO(1)){
    7a2e:	81 e0       	ldi	r24, 0x01	; 1
    7a30:	0e 94 73 3c 	call	0x78e6	; 0x78e6 <GetDataFromFIFO>
    7a34:	88 23       	and	r24, r24
    7a36:	39 f0       	breq	.+14     	; 0x7a46 <GSM_Wait_Char+0x3a>
    7a38:	90 e0       	ldi	r25, 0x00	; 0
    7a3a:	80 91 e1 07 	lds	r24, 0x07E1
    7a3e:	80 17       	cp	r24, r16
    7a40:	91 f7       	brne	.-28     	; 0x7a26 <GSM_Wait_Char+0x1a>
    7a42:	91 e0       	ldi	r25, 0x01	; 1
    7a44:	f0 cf       	rjmp	.-32     	; 0x7a26 <GSM_Wait_Char+0x1a>
    7a46:	90 e0       	ldi	r25, 0x00	; 0
		if(GSM_RxStr[0] == Char)	return 1;
		else return 0;
	}
	else return 0;
}
    7a48:	89 2f       	mov	r24, r25
    7a4a:	1f 91       	pop	r17
    7a4c:	0f 91       	pop	r16
    7a4e:	08 95       	ret

00007a50 <GSM_SendFirstChar>:
// ~~~~~~~~~
void GSM_SendFirstChar(void){

	UDR_GSM = GSM_TxStr[0];
    7a50:	80 91 4a 0a 	lds	r24, 0x0A4A
    7a54:	80 93 d6 00 	sts	0x00D6, r24
	#ifdef GSM_DEBUG
		GPRS_TerminalProcess(GSM_TxStr[0]);
	#endif

	GSM_TxCharN = 1;
    7a58:	81 e0       	ldi	r24, 0x01	; 1
    7a5a:	80 93 69 0b 	sts	0x0B69, r24
	cli();
    7a5e:	f8 94       	cli
	GSM_Flag &=~(1<<flg_TxCStr);	
    7a60:	80 91 d2 02 	lds	r24, 0x02D2
    7a64:	8e 7f       	andi	r24, 0xFE	; 254
    7a66:	80 93 d2 02 	sts	0x02D2, r24
	sei();
    7a6a:	78 94       	sei
	cli();
    7a6c:	f8 94       	cli
	#if defined (__AVR_ATxmega128A1__)
		USART_GSM.CTRLA = USART_RXCINTLVL_HI_gc | USART_DREINTLVL_HI_gc;
	#else
		UCSR_GSM_B =  (1<<RXCIE_GSM) | (0<<TXCIE_GSM) | (1<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    7a6e:	88 eb       	ldi	r24, 0xB8	; 184
    7a70:	80 93 d1 00 	sts	0x00D1, r24
	#endif
	
	sei();	
    7a74:	78 94       	sei
}
    7a76:	08 95       	ret

00007a78 <GSM_DRE>:
		StartTimer16(TD_GSM, Timeout);
	}
}
// ~~~~~~~~~
void GSM_DRE(void){
	if(GSM_TxCharN < GSMTxSz){
    7a78:	90 91 69 0b 	lds	r25, 0x0B69
    7a7c:	80 91 bb 07 	lds	r24, 0x07BB
    7a80:	98 17       	cp	r25, r24
    7a82:	20 f0       	brcs	.+8      	; 0x7a8c <GSM_DRE+0x14>
	}
	else{
		#if defined (__AVR_ATxmega128A1__)
			USART_GSM.CTRLA = USART_RXCINTLVL_HI_gc | USART_TXCINTLVL_HI_gc;
		#else
			UCSR_GSM_B =  (1<<RXCIE_GSM) | (1<<TXCIE_GSM) | (0<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    7a84:	88 ed       	ldi	r24, 0xD8	; 216
    7a86:	80 93 d1 00 	sts	0x00D1, r24
    7a8a:	08 95       	ret
	}
}
// ~~~~~~~~~
void GSM_DRE(void){
	if(GSM_TxCharN < GSMTxSz){
		UDR_GSM = GSM_TxStr[GSM_TxCharN];
    7a8c:	e0 91 69 0b 	lds	r30, 0x0B69
    7a90:	f0 e0       	ldi	r31, 0x00	; 0
    7a92:	e6 5b       	subi	r30, 0xB6	; 182
    7a94:	f5 4f       	sbci	r31, 0xF5	; 245
    7a96:	80 81       	ld	r24, Z
    7a98:	80 93 d6 00 	sts	0x00D6, r24
		#ifdef GSM_DEBUG
			GPRS_TerminalProcess(GSM_TxStr[GSM_TxCharN]);
		#endif
		GSM_TxCharN++;
    7a9c:	80 91 69 0b 	lds	r24, 0x0B69
    7aa0:	8f 5f       	subi	r24, 0xFF	; 255
    7aa2:	80 93 69 0b 	sts	0x0B69, r24
    7aa6:	08 95       	ret

00007aa8 <GSM_TX>:
}
// ~~~~~~~~~
void
GSM_TX(void)
{
	GSM_Flag |=(1<<flg_TxCStr);
    7aa8:	80 91 d2 02 	lds	r24, 0x02D2
    7aac:	81 60       	ori	r24, 0x01	; 1
    7aae:	80 93 d2 02 	sts	0x02D2, r24
	if(dataSendFlg){
    7ab2:	80 91 df 02 	lds	r24, 0x02DF
    7ab6:	88 23       	and	r24, r24
    7ab8:	21 f0       	breq	.+8      	; 0x7ac2 <GSM_TX+0x1a>
	dataSendFlg=0;
    7aba:	10 92 df 02 	sts	0x02DF, r1
	GPRS_FlgSz_Out=0;
    7abe:	10 92 b1 07 	sts	0x07B1, r1
	}
	#if defined (__AVR_ATxmega128A1__)
		USART_GSM.CTRLA = USART_RXCINTLVL_HI_gc;
	#else
		UCSR_GSM_B =  (1<<RXCIE_GSM) | (0<<TXCIE_GSM) | (0<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    7ac2:	88 e9       	ldi	r24, 0x98	; 152
    7ac4:	80 93 d1 00 	sts	0x00D1, r24
	#endif
}
    7ac8:	08 95       	ret

00007aca <GSM_Reset>:
GSM_Reset(void)
{
/*	IntOff();
	GSM_State = GSM_Restart;
	IntOn();*/
}
    7aca:	08 95       	ret

00007acc <GSM_GotoNextVega>:

uint8_t GSM_GotoNextVega(void){
 return 0;
}
    7acc:	80 e0       	ldi	r24, 0x00	; 0
    7ace:	08 95       	ret

00007ad0 <GSM_GetConfirmState>:
}
uint8_t ConfirmState = 0;
uint8_t RequestRepeatCounter = 0;
uint8_t TransmitterState = 0;
uint8_t GSM_GetConfirmState(){
	if(1 == ConfirmState){
    7ad0:	80 91 e1 02 	lds	r24, 0x02E1
    7ad4:	81 30       	cpi	r24, 0x01	; 1
    7ad6:	11 f0       	breq	.+4      	; 0x7adc <GSM_GetConfirmState+0xc>
    7ad8:	80 e0       	ldi	r24, 0x00	; 0
    7ada:	08 95       	ret
		ConfirmState = 0;
    7adc:	10 92 e1 02 	sts	0x02E1, r1
    7ae0:	81 e0       	ldi	r24, 0x01	; 1
		return 1;
	}
	else return 0;
}
    7ae2:	08 95       	ret

00007ae4 <GPRS_ServerAddr_Save>:
// ~~~~~~~~~~~~~~~~~~~~~~~~
void
GPRS_ServerAddr_Save(void)
{

}
    7ae4:	08 95       	ret

00007ae6 <__vector_25>:
#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__)
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	#ifdef vmd2_3
		// ~~~~~~~~~~
		// USART0 - PORT0
		Modbus_ISR(0)
    7ae6:	1f 92       	push	r1
    7ae8:	0f 92       	push	r0
    7aea:	0f b6       	in	r0, 0x3f	; 63
    7aec:	0f 92       	push	r0
    7aee:	0b b6       	in	r0, 0x3b	; 59
    7af0:	0f 92       	push	r0
    7af2:	11 24       	eor	r1, r1
    7af4:	2f 93       	push	r18
    7af6:	3f 93       	push	r19
    7af8:	4f 93       	push	r20
    7afa:	5f 93       	push	r21
    7afc:	6f 93       	push	r22
    7afe:	7f 93       	push	r23
    7b00:	8f 93       	push	r24
    7b02:	9f 93       	push	r25
    7b04:	af 93       	push	r26
    7b06:	bf 93       	push	r27
    7b08:	ef 93       	push	r30
    7b0a:	ff 93       	push	r31
    7b0c:	86 ec       	ldi	r24, 0xC6	; 198
    7b0e:	90 e0       	ldi	r25, 0x00	; 0
    7b10:	0e 94 5e 2d 	call	0x5abc	; 0x5abc <Modbus_RX>
    7b14:	ff 91       	pop	r31
    7b16:	ef 91       	pop	r30
    7b18:	bf 91       	pop	r27
    7b1a:	af 91       	pop	r26
    7b1c:	9f 91       	pop	r25
    7b1e:	8f 91       	pop	r24
    7b20:	7f 91       	pop	r23
    7b22:	6f 91       	pop	r22
    7b24:	5f 91       	pop	r21
    7b26:	4f 91       	pop	r20
    7b28:	3f 91       	pop	r19
    7b2a:	2f 91       	pop	r18
    7b2c:	0f 90       	pop	r0
    7b2e:	0b be       	out	0x3b, r0	; 59
    7b30:	0f 90       	pop	r0
    7b32:	0f be       	out	0x3f, r0	; 63
    7b34:	0f 90       	pop	r0
    7b36:	1f 90       	pop	r1
    7b38:	18 95       	reti

00007b3a <__vector_27>:
    7b3a:	1f 92       	push	r1
    7b3c:	0f 92       	push	r0
    7b3e:	0f b6       	in	r0, 0x3f	; 63
    7b40:	0f 92       	push	r0
    7b42:	0b b6       	in	r0, 0x3b	; 59
    7b44:	0f 92       	push	r0
    7b46:	11 24       	eor	r1, r1
    7b48:	2f 93       	push	r18
    7b4a:	3f 93       	push	r19
    7b4c:	4f 93       	push	r20
    7b4e:	5f 93       	push	r21
    7b50:	6f 93       	push	r22
    7b52:	7f 93       	push	r23
    7b54:	8f 93       	push	r24
    7b56:	9f 93       	push	r25
    7b58:	af 93       	push	r26
    7b5a:	bf 93       	push	r27
    7b5c:	ef 93       	push	r30
    7b5e:	ff 93       	push	r31
    7b60:	86 ec       	ldi	r24, 0xC6	; 198
    7b62:	90 e0       	ldi	r25, 0x00	; 0
    7b64:	0e 94 fd 38 	call	0x71fa	; 0x71fa <Modbus_TX>
    7b68:	ff 91       	pop	r31
    7b6a:	ef 91       	pop	r30
    7b6c:	bf 91       	pop	r27
    7b6e:	af 91       	pop	r26
    7b70:	9f 91       	pop	r25
    7b72:	8f 91       	pop	r24
    7b74:	7f 91       	pop	r23
    7b76:	6f 91       	pop	r22
    7b78:	5f 91       	pop	r21
    7b7a:	4f 91       	pop	r20
    7b7c:	3f 91       	pop	r19
    7b7e:	2f 91       	pop	r18
    7b80:	0f 90       	pop	r0
    7b82:	0b be       	out	0x3b, r0	; 59
    7b84:	0f 90       	pop	r0
    7b86:	0f be       	out	0x3f, r0	; 63
    7b88:	0f 90       	pop	r0
    7b8a:	1f 90       	pop	r1
    7b8c:	18 95       	reti

00007b8e <__vector_26>:
    7b8e:	1f 92       	push	r1
    7b90:	0f 92       	push	r0
    7b92:	0f b6       	in	r0, 0x3f	; 63
    7b94:	0f 92       	push	r0
    7b96:	0b b6       	in	r0, 0x3b	; 59
    7b98:	0f 92       	push	r0
    7b9a:	11 24       	eor	r1, r1
    7b9c:	2f 93       	push	r18
    7b9e:	3f 93       	push	r19
    7ba0:	4f 93       	push	r20
    7ba2:	5f 93       	push	r21
    7ba4:	6f 93       	push	r22
    7ba6:	7f 93       	push	r23
    7ba8:	8f 93       	push	r24
    7baa:	9f 93       	push	r25
    7bac:	af 93       	push	r26
    7bae:	bf 93       	push	r27
    7bb0:	ef 93       	push	r30
    7bb2:	ff 93       	push	r31
    7bb4:	86 ec       	ldi	r24, 0xC6	; 198
    7bb6:	90 e0       	ldi	r25, 0x00	; 0
    7bb8:	0e 94 fd 38 	call	0x71fa	; 0x71fa <Modbus_TX>
    7bbc:	ff 91       	pop	r31
    7bbe:	ef 91       	pop	r30
    7bc0:	bf 91       	pop	r27
    7bc2:	af 91       	pop	r26
    7bc4:	9f 91       	pop	r25
    7bc6:	8f 91       	pop	r24
    7bc8:	7f 91       	pop	r23
    7bca:	6f 91       	pop	r22
    7bcc:	5f 91       	pop	r21
    7bce:	4f 91       	pop	r20
    7bd0:	3f 91       	pop	r19
    7bd2:	2f 91       	pop	r18
    7bd4:	0f 90       	pop	r0
    7bd6:	0b be       	out	0x3b, r0	; 59
    7bd8:	0f 90       	pop	r0
    7bda:	0f be       	out	0x3f, r0	; 63
    7bdc:	0f 90       	pop	r0
    7bde:	1f 90       	pop	r1
    7be0:	18 95       	reti

00007be2 <__vector_36>:

		// ~~~~~~~~~~
		// USART1 - PORT1
		Modbus_ISR(1)
    7be2:	1f 92       	push	r1
    7be4:	0f 92       	push	r0
    7be6:	0f b6       	in	r0, 0x3f	; 63
    7be8:	0f 92       	push	r0
    7bea:	0b b6       	in	r0, 0x3b	; 59
    7bec:	0f 92       	push	r0
    7bee:	11 24       	eor	r1, r1
    7bf0:	2f 93       	push	r18
    7bf2:	3f 93       	push	r19
    7bf4:	4f 93       	push	r20
    7bf6:	5f 93       	push	r21
    7bf8:	6f 93       	push	r22
    7bfa:	7f 93       	push	r23
    7bfc:	8f 93       	push	r24
    7bfe:	9f 93       	push	r25
    7c00:	af 93       	push	r26
    7c02:	bf 93       	push	r27
    7c04:	ef 93       	push	r30
    7c06:	ff 93       	push	r31
    7c08:	8e ec       	ldi	r24, 0xCE	; 206
    7c0a:	90 e0       	ldi	r25, 0x00	; 0
    7c0c:	0e 94 5e 2d 	call	0x5abc	; 0x5abc <Modbus_RX>
    7c10:	ff 91       	pop	r31
    7c12:	ef 91       	pop	r30
    7c14:	bf 91       	pop	r27
    7c16:	af 91       	pop	r26
    7c18:	9f 91       	pop	r25
    7c1a:	8f 91       	pop	r24
    7c1c:	7f 91       	pop	r23
    7c1e:	6f 91       	pop	r22
    7c20:	5f 91       	pop	r21
    7c22:	4f 91       	pop	r20
    7c24:	3f 91       	pop	r19
    7c26:	2f 91       	pop	r18
    7c28:	0f 90       	pop	r0
    7c2a:	0b be       	out	0x3b, r0	; 59
    7c2c:	0f 90       	pop	r0
    7c2e:	0f be       	out	0x3f, r0	; 63
    7c30:	0f 90       	pop	r0
    7c32:	1f 90       	pop	r1
    7c34:	18 95       	reti

00007c36 <__vector_38>:
    7c36:	1f 92       	push	r1
    7c38:	0f 92       	push	r0
    7c3a:	0f b6       	in	r0, 0x3f	; 63
    7c3c:	0f 92       	push	r0
    7c3e:	0b b6       	in	r0, 0x3b	; 59
    7c40:	0f 92       	push	r0
    7c42:	11 24       	eor	r1, r1
    7c44:	2f 93       	push	r18
    7c46:	3f 93       	push	r19
    7c48:	4f 93       	push	r20
    7c4a:	5f 93       	push	r21
    7c4c:	6f 93       	push	r22
    7c4e:	7f 93       	push	r23
    7c50:	8f 93       	push	r24
    7c52:	9f 93       	push	r25
    7c54:	af 93       	push	r26
    7c56:	bf 93       	push	r27
    7c58:	ef 93       	push	r30
    7c5a:	ff 93       	push	r31
    7c5c:	8e ec       	ldi	r24, 0xCE	; 206
    7c5e:	90 e0       	ldi	r25, 0x00	; 0
    7c60:	0e 94 fd 38 	call	0x71fa	; 0x71fa <Modbus_TX>
    7c64:	ff 91       	pop	r31
    7c66:	ef 91       	pop	r30
    7c68:	bf 91       	pop	r27
    7c6a:	af 91       	pop	r26
    7c6c:	9f 91       	pop	r25
    7c6e:	8f 91       	pop	r24
    7c70:	7f 91       	pop	r23
    7c72:	6f 91       	pop	r22
    7c74:	5f 91       	pop	r21
    7c76:	4f 91       	pop	r20
    7c78:	3f 91       	pop	r19
    7c7a:	2f 91       	pop	r18
    7c7c:	0f 90       	pop	r0
    7c7e:	0b be       	out	0x3b, r0	; 59
    7c80:	0f 90       	pop	r0
    7c82:	0f be       	out	0x3f, r0	; 63
    7c84:	0f 90       	pop	r0
    7c86:	1f 90       	pop	r1
    7c88:	18 95       	reti

00007c8a <__vector_37>:
    7c8a:	1f 92       	push	r1
    7c8c:	0f 92       	push	r0
    7c8e:	0f b6       	in	r0, 0x3f	; 63
    7c90:	0f 92       	push	r0
    7c92:	0b b6       	in	r0, 0x3b	; 59
    7c94:	0f 92       	push	r0
    7c96:	11 24       	eor	r1, r1
    7c98:	2f 93       	push	r18
    7c9a:	3f 93       	push	r19
    7c9c:	4f 93       	push	r20
    7c9e:	5f 93       	push	r21
    7ca0:	6f 93       	push	r22
    7ca2:	7f 93       	push	r23
    7ca4:	8f 93       	push	r24
    7ca6:	9f 93       	push	r25
    7ca8:	af 93       	push	r26
    7caa:	bf 93       	push	r27
    7cac:	ef 93       	push	r30
    7cae:	ff 93       	push	r31
    7cb0:	8e ec       	ldi	r24, 0xCE	; 206
    7cb2:	90 e0       	ldi	r25, 0x00	; 0
    7cb4:	0e 94 fd 38 	call	0x71fa	; 0x71fa <Modbus_TX>
    7cb8:	ff 91       	pop	r31
    7cba:	ef 91       	pop	r30
    7cbc:	bf 91       	pop	r27
    7cbe:	af 91       	pop	r26
    7cc0:	9f 91       	pop	r25
    7cc2:	8f 91       	pop	r24
    7cc4:	7f 91       	pop	r23
    7cc6:	6f 91       	pop	r22
    7cc8:	5f 91       	pop	r21
    7cca:	4f 91       	pop	r20
    7ccc:	3f 91       	pop	r19
    7cce:	2f 91       	pop	r18
    7cd0:	0f 90       	pop	r0
    7cd2:	0b be       	out	0x3b, r0	; 59
    7cd4:	0f 90       	pop	r0
    7cd6:	0f be       	out	0x3f, r0	; 63
    7cd8:	0f 90       	pop	r0
    7cda:	1f 90       	pop	r1
    7cdc:	18 95       	reti

00007cde <__vector_52>:

		// USART2 - PORT2 (only GSM)
		#ifdef GSM
			#ifndef SIM300DZ
				ISR(USART2_UDRE_vect) {GSM_DRE();}
    7cde:	1f 92       	push	r1
    7ce0:	0f 92       	push	r0
    7ce2:	0f b6       	in	r0, 0x3f	; 63
    7ce4:	0f 92       	push	r0
    7ce6:	0b b6       	in	r0, 0x3b	; 59
    7ce8:	0f 92       	push	r0
    7cea:	11 24       	eor	r1, r1
    7cec:	2f 93       	push	r18
    7cee:	3f 93       	push	r19
    7cf0:	4f 93       	push	r20
    7cf2:	5f 93       	push	r21
    7cf4:	6f 93       	push	r22
    7cf6:	7f 93       	push	r23
    7cf8:	8f 93       	push	r24
    7cfa:	9f 93       	push	r25
    7cfc:	af 93       	push	r26
    7cfe:	bf 93       	push	r27
    7d00:	ef 93       	push	r30
    7d02:	ff 93       	push	r31
    7d04:	0e 94 3c 3d 	call	0x7a78	; 0x7a78 <GSM_DRE>
    7d08:	ff 91       	pop	r31
    7d0a:	ef 91       	pop	r30
    7d0c:	bf 91       	pop	r27
    7d0e:	af 91       	pop	r26
    7d10:	9f 91       	pop	r25
    7d12:	8f 91       	pop	r24
    7d14:	7f 91       	pop	r23
    7d16:	6f 91       	pop	r22
    7d18:	5f 91       	pop	r21
    7d1a:	4f 91       	pop	r20
    7d1c:	3f 91       	pop	r19
    7d1e:	2f 91       	pop	r18
    7d20:	0f 90       	pop	r0
    7d22:	0b be       	out	0x3b, r0	; 59
    7d24:	0f 90       	pop	r0
    7d26:	0f be       	out	0x3f, r0	; 63
    7d28:	0f 90       	pop	r0
    7d2a:	1f 90       	pop	r1
    7d2c:	18 95       	reti

00007d2e <__vector_53>:
			#endif
			ISR(USART2_TX_vect) {GSM_TX();}
    7d2e:	1f 92       	push	r1
    7d30:	0f 92       	push	r0
    7d32:	0f b6       	in	r0, 0x3f	; 63
    7d34:	0f 92       	push	r0
    7d36:	0b b6       	in	r0, 0x3b	; 59
    7d38:	0f 92       	push	r0
    7d3a:	11 24       	eor	r1, r1
    7d3c:	2f 93       	push	r18
    7d3e:	3f 93       	push	r19
    7d40:	4f 93       	push	r20
    7d42:	5f 93       	push	r21
    7d44:	6f 93       	push	r22
    7d46:	7f 93       	push	r23
    7d48:	8f 93       	push	r24
    7d4a:	9f 93       	push	r25
    7d4c:	af 93       	push	r26
    7d4e:	bf 93       	push	r27
    7d50:	ef 93       	push	r30
    7d52:	ff 93       	push	r31
    7d54:	0e 94 54 3d 	call	0x7aa8	; 0x7aa8 <GSM_TX>
    7d58:	ff 91       	pop	r31
    7d5a:	ef 91       	pop	r30
    7d5c:	bf 91       	pop	r27
    7d5e:	af 91       	pop	r26
    7d60:	9f 91       	pop	r25
    7d62:	8f 91       	pop	r24
    7d64:	7f 91       	pop	r23
    7d66:	6f 91       	pop	r22
    7d68:	5f 91       	pop	r21
    7d6a:	4f 91       	pop	r20
    7d6c:	3f 91       	pop	r19
    7d6e:	2f 91       	pop	r18
    7d70:	0f 90       	pop	r0
    7d72:	0b be       	out	0x3b, r0	; 59
    7d74:	0f 90       	pop	r0
    7d76:	0f be       	out	0x3f, r0	; 63
    7d78:	0f 90       	pop	r0
    7d7a:	1f 90       	pop	r1
    7d7c:	18 95       	reti

00007d7e <__vector_51>:
			ISR(USART2_RX_vect) {GSM_RX();}
    7d7e:	1f 92       	push	r1
    7d80:	0f 92       	push	r0
    7d82:	0f b6       	in	r0, 0x3f	; 63
    7d84:	0f 92       	push	r0
    7d86:	0b b6       	in	r0, 0x3b	; 59
    7d88:	0f 92       	push	r0
    7d8a:	11 24       	eor	r1, r1
    7d8c:	2f 93       	push	r18
    7d8e:	3f 93       	push	r19
    7d90:	4f 93       	push	r20
    7d92:	5f 93       	push	r21
    7d94:	6f 93       	push	r22
    7d96:	7f 93       	push	r23
    7d98:	8f 93       	push	r24
    7d9a:	9f 93       	push	r25
    7d9c:	af 93       	push	r26
    7d9e:	bf 93       	push	r27
    7da0:	ef 93       	push	r30
    7da2:	ff 93       	push	r31
    7da4:	0e 94 e6 3c 	call	0x79cc	; 0x79cc <GSM_RX>
    7da8:	ff 91       	pop	r31
    7daa:	ef 91       	pop	r30
    7dac:	bf 91       	pop	r27
    7dae:	af 91       	pop	r26
    7db0:	9f 91       	pop	r25
    7db2:	8f 91       	pop	r24
    7db4:	7f 91       	pop	r23
    7db6:	6f 91       	pop	r22
    7db8:	5f 91       	pop	r21
    7dba:	4f 91       	pop	r20
    7dbc:	3f 91       	pop	r19
    7dbe:	2f 91       	pop	r18
    7dc0:	0f 90       	pop	r0
    7dc2:	0b be       	out	0x3b, r0	; 59
    7dc4:	0f 90       	pop	r0
    7dc6:	0f be       	out	0x3f, r0	; 63
    7dc8:	0f 90       	pop	r0
    7dca:	1f 90       	pop	r1
    7dcc:	18 95       	reti

00007dce <KeypadInit>:
		for (uint8_t str=0; str<sizeof(KeyStr); str++) {
			uint8_t KS = prb(KeyStr+str);
			DDR_Key &=~KS;
			PortKey |=KS;
		}*/
		DDR_KeyROW1 |= KeyROW1;
    7dce:	81 9a       	sbi	0x10, 1	; 16
		DDR_KeyROW2 |= KeyROW2;
    7dd0:	80 9a       	sbi	0x10, 0	; 16
		PortKeyROW1 |= KeyROW1;
    7dd2:	89 9a       	sbi	0x11, 1	; 17
		PortKeyROW2 |= KeyROW2;
    7dd4:	88 9a       	sbi	0x11, 0	; 17
		
		DDR_KeySTR1 &= ~KeySTR1;
    7dd6:	85 98       	cbi	0x10, 5	; 16
		DDR_KeySTR2 &= ~KeySTR2;
    7dd8:	84 98       	cbi	0x10, 4	; 16
		DDR_KeySTR3 &= ~KeySTR3;
    7dda:	82 98       	cbi	0x10, 2	; 16
		PortKeySTR1 |= KeySTR1;
    7ddc:	8d 9a       	sbi	0x11, 5	; 17
		PortKeySTR2 |= KeySTR2;
    7dde:	8c 9a       	sbi	0x11, 4	; 17
		PortKeySTR3 |= KeySTR3;
    7de0:	8a 9a       	sbi	0x11, 2	; 17
}

uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    7de2:	80 91 cf 02 	lds	r24, 0x02CF
	VacantTimer8Sys += n;
    7de6:	8f 5f       	subi	r24, 0xFF	; 255
    7de8:	80 93 cf 02 	sts	0x02CF, r24
    7dec:	81 50       	subi	r24, 0x01	; 1
		PORTJ.DIRCLR = (1<<7);
		for (uint8_t str=1; str<sizeof(KeyStr); str++)
			PORTK.DIRCLR = prb(KeyStr+str);
		PORTJ.PIN7CTRL = PORTK.PIN0CTRL = PORTK.PIN1CTRL = PORTK.PIN2CTRL = PORTK.PIN3CTRL = PORT_OPC_PULLUP_gc;
	#endif
	TD_Keypad = Timer8SysAlloc(1);
    7dee:	80 93 f3 04 	sts	0x04F3, r24
}
    7df2:	08 95       	ret

00007df4 <KeypadIn>:
	return KeyPressedNonFilter = Key;
}
// ~~~~~~~~~~~
uint8_t
KeypadIn(void)
{
    7df4:	0f 93       	push	r16
    7df6:	1f 93       	push	r17
			}
		}
		RowOff(KR);
	}*/

	cli(); PortKeyROW1 &= ~KeyROW1; sei();
    7df8:	f8 94       	cli
    7dfa:	89 98       	cbi	0x11, 1	; 17
    7dfc:	78 94       	sei
    7dfe:	85 e3       	ldi	r24, 0x35	; 53
    7e00:	8a 95       	dec	r24
    7e02:	f1 f7       	brne	.-4      	; 0x7e00 <KeypadIn+0xc>
	_delay_us(10);		// By trial
	if(!(PIN_KeySTR1 & (KeySTR1))){ Key=2; PresKeysQuant++;} 
    7e04:	7d 99       	sbic	0x0f, 5	; 15
    7e06:	38 c0       	rjmp	.+112    	; 0x7e78 <KeypadIn+0x84>
    7e08:	91 e0       	ldi	r25, 0x01	; 1
    7e0a:	02 e0       	ldi	r16, 0x02	; 2
	if(!(PIN_KeySTR2 & (KeySTR2))){ Key=6; PresKeysQuant++;} 
    7e0c:	7c 99       	sbic	0x0f, 4	; 15
    7e0e:	02 c0       	rjmp	.+4      	; 0x7e14 <KeypadIn+0x20>
    7e10:	9f 5f       	subi	r25, 0xFF	; 255
    7e12:	06 e0       	ldi	r16, 0x06	; 6
	if(!(PIN_KeySTR3 & (KeySTR3))){ Key=4; PresKeysQuant++;} 
    7e14:	7a 99       	sbic	0x0f, 2	; 15
    7e16:	02 c0       	rjmp	.+4      	; 0x7e1c <KeypadIn+0x28>
    7e18:	9f 5f       	subi	r25, 0xFF	; 255
    7e1a:	04 e0       	ldi	r16, 0x04	; 4
	cli(); PortKeyROW1 |= KeyROW1; sei();	
    7e1c:	f8 94       	cli
    7e1e:	89 9a       	sbi	0x11, 1	; 17
    7e20:	78 94       	sei

	cli(); PortKeyROW2 &= ~KeyROW2; sei();
    7e22:	f8 94       	cli
    7e24:	88 98       	cbi	0x11, 0	; 17
    7e26:	78 94       	sei
    7e28:	85 e3       	ldi	r24, 0x35	; 53
    7e2a:	8a 95       	dec	r24
    7e2c:	f1 f7       	brne	.-4      	; 0x7e2a <KeypadIn+0x36>
	_delay_us(10);		// By trial
	if(!(PIN_KeySTR1 & (KeySTR1))){ Key=1; PresKeysQuant++;}
    7e2e:	7d 99       	sbic	0x0f, 5	; 15
    7e30:	02 c0       	rjmp	.+4      	; 0x7e36 <KeypadIn+0x42>
    7e32:	9f 5f       	subi	r25, 0xFF	; 255
    7e34:	01 e0       	ldi	r16, 0x01	; 1
	if(!(PIN_KeySTR2 & (KeySTR2))){ Key=5; PresKeysQuant++;}
    7e36:	7c 99       	sbic	0x0f, 4	; 15
    7e38:	02 c0       	rjmp	.+4      	; 0x7e3e <KeypadIn+0x4a>
    7e3a:	9f 5f       	subi	r25, 0xFF	; 255
    7e3c:	05 e0       	ldi	r16, 0x05	; 5
	if(!(PIN_KeySTR3 & (KeySTR3))){ Key=3; PresKeysQuant++;}
    7e3e:	7a 99       	sbic	0x0f, 2	; 15
    7e40:	02 c0       	rjmp	.+4      	; 0x7e46 <KeypadIn+0x52>
    7e42:	9f 5f       	subi	r25, 0xFF	; 255
    7e44:	03 e0       	ldi	r16, 0x03	; 3
	cli(); PortKeyROW2 |= KeyROW2; sei();
    7e46:	f8 94       	cli
    7e48:	88 9a       	sbi	0x11, 0	; 17
    7e4a:	78 94       	sei
	if(PresKeysQuant!=1) Key = 0;
    7e4c:	91 30       	cpi	r25, 0x01	; 1
    7e4e:	09 f4       	brne	.+2      	; 0x7e52 <KeypadIn+0x5e>
    7e50:	4a c0       	rjmp	.+148    	; 0x7ee6 <KeypadIn+0xf2>

	return KeyPressedNonFilter = Key;
    7e52:	10 92 11 09 	sts	0x0911, r1
    7e56:	00 e0       	ldi	r16, 0x00	; 0
{
	static uint8_t PrevKey;
	uint8_t KeyResult = 0;
	uint8_t Key = KeypadScan();	//   
	if(Key) KeyPressedCounter++;
	if(Key != PrevKey){			//     -   
    7e58:	80 91 e5 02 	lds	r24, 0x02E5
    7e5c:	80 17       	cp	r24, r16
    7e5e:	11 f0       	breq	.+4      	; 0x7e64 <KeypadIn+0x70>
		PrevKey = 0;
    7e60:	10 92 e5 02 	sts	0x02E5, r1
	}
	
	if (Timer8Stopp(TD_Keypad)) {
    7e64:	10 91 f3 04 	lds	r17, 0x04F3
    7e68:	81 2f       	mov	r24, r17
    7e6a:	0e 94 61 1f 	call	0x3ec2	; 0x3ec2 <Timer8Stopp>
    7e6e:	88 23       	and	r24, r24
    7e70:	31 f4       	brne	.+12     	; 0x7e7e <KeypadIn+0x8a>
					for(I=0;I<=(KeyQuantity/8);I++) *((uint8_t*)RKEY+I) = 0;
				}
		#endif
	}
	return KeyResult;
}
    7e72:	1f 91       	pop	r17
    7e74:	0f 91       	pop	r16
    7e76:	08 95       	ret
		RowOff(KR);
	}*/

	cli(); PortKeyROW1 &= ~KeyROW1; sei();
	_delay_us(10);		// By trial
	if(!(PIN_KeySTR1 & (KeySTR1))){ Key=2; PresKeysQuant++;} 
    7e78:	90 e0       	ldi	r25, 0x00	; 0
    7e7a:	00 e0       	ldi	r16, 0x00	; 0
    7e7c:	c7 cf       	rjmp	.-114    	; 0x7e0c <KeypadIn+0x18>
	if(Key != PrevKey){			//     -   
		PrevKey = 0;
	}
	
	if (Timer8Stopp(TD_Keypad)) {
		StartTimer8(TD_Keypad, 6);	// By trial keystroke time == 70-180 ms
    7e7e:	81 2f       	mov	r24, r17
    7e80:	66 e0       	ldi	r22, 0x06	; 6
    7e82:	0e 94 0d 1e 	call	0x3c1a	; 0x3c1a <StartTimer8>
		if (Key != PrevKey) {
    7e86:	80 91 e5 02 	lds	r24, 0x02E5
    7e8a:	80 17       	cp	r24, r16
    7e8c:	09 f4       	brne	.+2      	; 0x7e90 <KeypadIn+0x9c>
    7e8e:	44 c0       	rjmp	.+136    	; 0x7f18 <KeypadIn+0x124>
				PrevKey = Key;
    7e90:	00 93 e5 02 	sts	0x02E5, r16
				Key = 0;
				KeyStroke = 0;
    7e94:	10 92 f2 04 	sts	0x04F2, r1

		#ifdef RKEY
			#ifdef QslRD
				if(!*(uint8_t*)RNUM)
			#endif
				if (KeyResult==0) {
    7e98:	40 e0       	ldi	r20, 0x00	; 0
    7e9a:	50 e0       	ldi	r21, 0x00	; 0
					uint8_t I = 0;
					while (1<<(I++ & 0b00000111) != *((uint8_t*)RKEY+(I>>3)) && I<=KeyQuantity);
    7e9c:	a1 e0       	ldi	r26, 0x01	; 1
    7e9e:	b0 e0       	ldi	r27, 0x00	; 0

		#ifdef RKEY
			#ifdef QslRD
				if(!*(uint8_t*)RNUM)
			#endif
				if (KeyResult==0) {
    7ea0:	e4 2f       	mov	r30, r20
    7ea2:	64 2f       	mov	r22, r20
    7ea4:	6f 5f       	subi	r22, 0xFF	; 255
					uint8_t I = 0;
					while (1<<(I++ & 0b00000111) != *((uint8_t*)RKEY+(I>>3)) && I<=KeyQuantity);
    7ea6:	9a 01       	movw	r18, r20
    7ea8:	27 70       	andi	r18, 0x07	; 7
    7eaa:	30 70       	andi	r19, 0x00	; 0
    7eac:	cd 01       	movw	r24, r26
    7eae:	02 c0       	rjmp	.+4      	; 0x7eb4 <KeypadIn+0xc0>
    7eb0:	88 0f       	add	r24, r24
    7eb2:	99 1f       	adc	r25, r25
    7eb4:	2a 95       	dec	r18
    7eb6:	e2 f7       	brpl	.-8      	; 0x7eb0 <KeypadIn+0xbc>
    7eb8:	9c 01       	movw	r18, r24
    7eba:	e6 95       	lsr	r30
    7ebc:	e6 95       	lsr	r30
    7ebe:	e6 95       	lsr	r30
    7ec0:	f0 e0       	ldi	r31, 0x00	; 0
    7ec2:	e1 54       	subi	r30, 0x41	; 65
    7ec4:	f8 4f       	sbci	r31, 0xF8	; 248
    7ec6:	80 81       	ld	r24, Z
    7ec8:	90 e0       	ldi	r25, 0x00	; 0
    7eca:	28 17       	cp	r18, r24
    7ecc:	39 07       	cpc	r19, r25
    7ece:	b1 f1       	breq	.+108    	; 0x7f3c <KeypadIn+0x148>
    7ed0:	4f 5f       	subi	r20, 0xFF	; 255
    7ed2:	5f 4f       	sbci	r21, 0xFF	; 255
    7ed4:	47 30       	cpi	r20, 0x07	; 7
    7ed6:	51 05       	cpc	r21, r1
    7ed8:	19 f7       	brne	.-58     	; 0x7ea0 <KeypadIn+0xac>
					if (I<=KeyQuantity)
    7eda:	80 e0       	ldi	r24, 0x00	; 0
						KeyResult = I;
					for(I=0;I<=(KeyQuantity/8);I++) *((uint8_t*)RKEY+I) = 0;
    7edc:	10 92 bf 07 	sts	0x07BF, r1
				}
		#endif
	}
	return KeyResult;
}
    7ee0:	1f 91       	pop	r17
    7ee2:	0f 91       	pop	r16
    7ee4:	08 95       	ret
	if(!(PIN_KeySTR2 & (KeySTR2))){ Key=5; PresKeysQuant++;}
	if(!(PIN_KeySTR3 & (KeySTR3))){ Key=3; PresKeysQuant++;}
	cli(); PortKeyROW2 |= KeyROW2; sei();
	if(PresKeysQuant!=1) Key = 0;

	return KeyPressedNonFilter = Key;
    7ee6:	00 93 11 09 	sts	0x0911, r16
KeypadIn(void)
{
	static uint8_t PrevKey;
	uint8_t KeyResult = 0;
	uint8_t Key = KeypadScan();	//   
	if(Key) KeyPressedCounter++;
    7eea:	00 23       	and	r16, r16
    7eec:	09 f4       	brne	.+2      	; 0x7ef0 <KeypadIn+0xfc>
    7eee:	b4 cf       	rjmp	.-152    	; 0x7e58 <KeypadIn+0x64>
    7ef0:	80 91 3a 07 	lds	r24, 0x073A
    7ef4:	90 91 3b 07 	lds	r25, 0x073B
    7ef8:	a0 91 3c 07 	lds	r26, 0x073C
    7efc:	b0 91 3d 07 	lds	r27, 0x073D
    7f00:	01 96       	adiw	r24, 0x01	; 1
    7f02:	a1 1d       	adc	r26, r1
    7f04:	b1 1d       	adc	r27, r1
    7f06:	80 93 3a 07 	sts	0x073A, r24
    7f0a:	90 93 3b 07 	sts	0x073B, r25
    7f0e:	a0 93 3c 07 	sts	0x073C, r26
    7f12:	b0 93 3d 07 	sts	0x073D, r27
    7f16:	a0 cf       	rjmp	.-192    	; 0x7e58 <KeypadIn+0x64>
				PrevKey = Key;
				Key = 0;
				KeyStroke = 0;
		}
		else{
			KeyPressed = KeyResult = Key;
    7f18:	00 93 b0 07 	sts	0x07B0, r16
			if(KeyStroke<0xFF && ++KeyStroke>1 && KeyStroke<=0xF) KeyResult = 0;
    7f1c:	90 91 f2 04 	lds	r25, 0x04F2
    7f20:	9f 3f       	cpi	r25, 0xFF	; 255
    7f22:	41 f0       	breq	.+16     	; 0x7f34 <KeypadIn+0x140>
    7f24:	9f 5f       	subi	r25, 0xFF	; 255
    7f26:	90 93 f2 04 	sts	0x04F2, r25
    7f2a:	92 30       	cpi	r25, 0x02	; 2
    7f2c:	18 f0       	brcs	.+6      	; 0x7f34 <KeypadIn+0x140>
    7f2e:	90 31       	cpi	r25, 0x10	; 16
    7f30:	08 f4       	brcc	.+2      	; 0x7f34 <KeypadIn+0x140>
    7f32:	b2 cf       	rjmp	.-156    	; 0x7e98 <KeypadIn+0xa4>

		#ifdef RKEY
			#ifdef QslRD
				if(!*(uint8_t*)RNUM)
			#endif
				if (KeyResult==0) {
    7f34:	88 23       	and	r24, r24
    7f36:	09 f0       	breq	.+2      	; 0x7f3a <KeypadIn+0x146>
    7f38:	9c cf       	rjmp	.-200    	; 0x7e72 <KeypadIn+0x7e>
    7f3a:	ae cf       	rjmp	.-164    	; 0x7e98 <KeypadIn+0xa4>
					uint8_t I = 0;
					while (1<<(I++ & 0b00000111) != *((uint8_t*)RKEY+(I>>3)) && I<=KeyQuantity);
					if (I<=KeyQuantity)
    7f3c:	67 30       	cpi	r22, 0x07	; 7
    7f3e:	68 f6       	brcc	.-102    	; 0x7eda <KeypadIn+0xe6>
    7f40:	86 2f       	mov	r24, r22
    7f42:	cc cf       	rjmp	.-104    	; 0x7edc <KeypadIn+0xe8>

00007f44 <InitBufStr>:
static uint8_t Minus;
// ~~~~~~~~~~~
char BufStr[LCDXSz+1];
uint8_t CurrFieldSize;

void InitBufStr(OutField *Field){
    7f44:	e3 ec       	ldi	r30, 0xC3	; 195
    7f46:	f5 e0       	ldi	r31, 0x05	; 5
	for(uint8_t i =0; i<LCDXSz; i++) BufStr[i]=' ';
    7f48:	80 e2       	ldi	r24, 0x20	; 32
    7f4a:	81 93       	st	Z+, r24
    7f4c:	95 e0       	ldi	r25, 0x05	; 5
    7f4e:	e7 3d       	cpi	r30, 0xD7	; 215
    7f50:	f9 07       	cpc	r31, r25
    7f52:	d9 f7       	brne	.-10     	; 0x7f4a <InitBufStr+0x6>
	BufStr[LCDXSz] ='\0';
    7f54:	10 82       	st	Z, r1
	CurrFieldSize = 0;
    7f56:	10 92 c0 07 	sts	0x07C0, r1
	MultiSymbol = 0;
    7f5a:	10 92 f4 04 	sts	0x04F4, r1
}
    7f5e:	08 95       	ret

00007f60 <EventFunc>:

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    7f60:	fc 01       	movw	r30, r24
    7f62:	85 91       	lpm	r24, Z+
    7f64:	94 91       	lpm	r25, Z+
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
EventFunc(const MenuEvent *Event)
{
	MenuEvent Func = prp(Event);
	if (Func)
    7f66:	00 97       	sbiw	r24, 0x00	; 0
    7f68:	11 f0       	breq	.+4      	; 0x7f6e <EventFunc+0xe>
		Func();
    7f6a:	fc 01       	movw	r30, r24
    7f6c:	19 95       	eicall
    7f6e:	08 95       	ret

00007f70 <KeyFunc>:
    7f70:	fc 01       	movw	r30, r24
    7f72:	85 91       	lpm	r24, Z+
    7f74:	94 91       	lpm	r25, Z+
// ~~~~~~~~~~~~~~~~~~~~~~~~
static uint8_t
KeyFunc(const MenuKey *Key)
{
	MenuKey Func=prp(Key);
	return Func && Func()==CustomKey;
    7f76:	00 97       	sbiw	r24, 0x00	; 0
    7f78:	51 f0       	breq	.+20     	; 0x7f8e <KeyFunc+0x1e>
    7f7a:	fc 01       	movw	r30, r24
    7f7c:	19 95       	eicall
    7f7e:	90 e0       	ldi	r25, 0x00	; 0
    7f80:	81 30       	cpi	r24, 0x01	; 1
    7f82:	09 f0       	breq	.+2      	; 0x7f86 <KeyFunc+0x16>
    7f84:	91 e0       	ldi	r25, 0x01	; 1
    7f86:	81 e0       	ldi	r24, 0x01	; 1
    7f88:	98 27       	eor	r25, r24
}
    7f8a:	89 2f       	mov	r24, r25
    7f8c:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~~~
static uint8_t
KeyFunc(const MenuKey *Key)
{
	MenuKey Func=prp(Key);
	return Func && Func()==CustomKey;
    7f8e:	90 e0       	ldi	r25, 0x00	; 0
}
    7f90:	89 2f       	mov	r24, r25
    7f92:	08 95       	ret

00007f94 <GotoMenu>:

// ~~~~~~~~~~~~~~~~~~~~~
void
GotoMenu(MenuPage *Menu)
{
    7f94:	cf 93       	push	r28
    7f96:	df 93       	push	r29
    7f98:	ec 01       	movw	r28, r24
	EventFunc(&CurrPage->Exit);
    7f9a:	80 91 d4 02 	lds	r24, 0x02D4
    7f9e:	90 91 d5 02 	lds	r25, 0x02D5
    7fa2:	0a 96       	adiw	r24, 0x0a	; 10
    7fa4:	0e 94 b0 3f 	call	0x7f60	; 0x7f60 <EventFunc>
    7fa8:	fe 01       	movw	r30, r28
    7faa:	34 96       	adiw	r30, 0x04	; 4
    7fac:	85 91       	lpm	r24, Z+
    7fae:	94 91       	lpm	r25, Z+
	if(prp(&Menu->OutPage))
    7fb0:	89 2b       	or	r24, r25
    7fb2:	c9 f0       	breq	.+50     	; 0x7fe6 <GotoMenu+0x52>
		MenuDepth=0;
    7fb4:	10 92 ba 07 	sts	0x07BA, r1
	else {
		MenuStack[MenuDepth].Page = CurrPage;
		MenuStack[MenuDepth].Line = CurrLine;
		MenuStack[MenuDepth++].LCD = CurrLCD;
	}
	CurrPage = Menu;
    7fb8:	d0 93 d5 02 	sts	0x02D5, r29
    7fbc:	c0 93 d4 02 	sts	0x02D4, r28

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    7fc0:	23 96       	adiw	r28, 0x03	; 3
    7fc2:	fe 01       	movw	r30, r28
    7fc4:	84 91       	lpm	r24, Z+
	CurrLine = CurrLCD = GetFix();
    7fc6:	80 93 e8 08 	sts	0x08E8, r24
    7fca:	80 93 ca 07 	sts	0x07CA, r24
	CurrField = CurrPos = NullPos;
    7fce:	8f ef       	ldi	r24, 0xFF	; 255
    7fd0:	80 93 d7 02 	sts	0x02D7, r24
    7fd4:	80 93 d6 02 	sts	0x02D6, r24
	EventFunc(&CurrPage->Load);
    7fd8:	ce 01       	movw	r24, r28
    7fda:	03 96       	adiw	r24, 0x03	; 3
    7fdc:	0e 94 b0 3f 	call	0x7f60	; 0x7f60 <EventFunc>
}
    7fe0:	df 91       	pop	r29
    7fe2:	cf 91       	pop	r28
    7fe4:	08 95       	ret
{
	EventFunc(&CurrPage->Exit);
	if(prp(&Menu->OutPage))
		MenuDepth=0;
	else {
		MenuStack[MenuDepth].Page = CurrPage;
    7fe6:	20 91 ba 07 	lds	r18, 0x07BA
    7fea:	e2 2f       	mov	r30, r18
    7fec:	f0 e0       	ldi	r31, 0x00	; 0
    7fee:	ee 0f       	add	r30, r30
    7ff0:	ff 1f       	adc	r31, r31
    7ff2:	ee 0f       	add	r30, r30
    7ff4:	ff 1f       	adc	r31, r31
    7ff6:	df 01       	movw	r26, r30
    7ff8:	a7 51       	subi	r26, 0x17	; 23
    7ffa:	b7 4f       	sbci	r27, 0xF7	; 247
    7ffc:	80 91 d4 02 	lds	r24, 0x02D4
    8000:	90 91 d5 02 	lds	r25, 0x02D5
    8004:	11 96       	adiw	r26, 0x01	; 1
    8006:	9c 93       	st	X, r25
    8008:	8e 93       	st	-X, r24
		MenuStack[MenuDepth].Line = CurrLine;
    800a:	80 91 ca 07 	lds	r24, 0x07CA
    800e:	13 96       	adiw	r26, 0x03	; 3
    8010:	8c 93       	st	X, r24
		MenuStack[MenuDepth++].LCD = CurrLCD;
    8012:	e5 51       	subi	r30, 0x15	; 21
    8014:	f7 4f       	sbci	r31, 0xF7	; 247
    8016:	80 91 e8 08 	lds	r24, 0x08E8
    801a:	80 83       	st	Z, r24
    801c:	2f 5f       	subi	r18, 0xFF	; 255
    801e:	20 93 ba 07 	sts	0x07BA, r18
    8022:	ca cf       	rjmp	.-108    	; 0x7fb8 <GotoMenu+0x24>

00008024 <HideMsg>:

// ~~~~~~~~~~
uint8_t
HideMsg(void)
{
	if (CurrMsg) {
    8024:	80 91 f5 04 	lds	r24, 0x04F5
    8028:	90 91 f6 04 	lds	r25, 0x04F6
    802c:	00 97       	sbiw	r24, 0x00	; 0
    802e:	51 f0       	breq	.+20     	; 0x8044 <HideMsg+0x20>
		EventFunc(&CurrMsg->Exit);
    8030:	80 5a       	subi	r24, 0xA0	; 160
    8032:	9f 4f       	sbci	r25, 0xFF	; 255
    8034:	0e 94 b0 3f 	call	0x7f60	; 0x7f60 <EventFunc>
		CurrMsg = NULL;
    8038:	10 92 f6 04 	sts	0x04F6, r1
    803c:	10 92 f5 04 	sts	0x04F5, r1
    8040:	81 e0       	ldi	r24, 0x01	; 1
		return 1;
	}
	else
		return 0;
}
    8042:	08 95       	ret

// ~~~~~~~~~~
uint8_t
HideMsg(void)
{
	if (CurrMsg) {
    8044:	80 e0       	ldi	r24, 0x00	; 0
    8046:	08 95       	ret

00008048 <ShowMsg>:
}

// ~~~~~~~~~~~~~~~~~~
void
ShowMsg(MsgPage *Msg)
{
    8048:	0f 93       	push	r16
    804a:	1f 93       	push	r17
    804c:	8c 01       	movw	r16, r24
	HideMsg();
    804e:	0e 94 12 40 	call	0x8024	; 0x8024 <HideMsg>
	CurrMsg = Msg;
    8052:	10 93 f6 04 	sts	0x04F6, r17
    8056:	00 93 f5 04 	sts	0x04F5, r16
	EventFunc(&CurrMsg->Load);
    805a:	c8 01       	movw	r24, r16
    805c:	84 5a       	subi	r24, 0xA4	; 164
    805e:	9f 4f       	sbci	r25, 0xFF	; 255
    8060:	0e 94 b0 3f 	call	0x7f60	; 0x7f60 <EventFunc>
}
    8064:	1f 91       	pop	r17
    8066:	0f 91       	pop	r16
    8068:	08 95       	ret

0000806a <MenuInit>:

// ~~~~~~~~~~~
void
MenuInit(void)
{
	CurrLCD = CurrLine = GetFix();
    806a:	e0 91 d4 02 	lds	r30, 0x02D4
    806e:	f0 91 d5 02 	lds	r31, 0x02D5
    8072:	33 96       	adiw	r30, 0x03	; 3
    8074:	84 91       	lpm	r24, Z+
    8076:	80 93 ca 07 	sts	0x07CA, r24
    807a:	80 93 e8 08 	sts	0x08E8, r24
	#ifdef InitMsg
		ShowMsg(&InitMsg);
	#endif
	EventFunc(&CurrPage->Load);
    807e:	cf 01       	movw	r24, r30
    8080:	03 96       	adiw	r24, 0x03	; 3
    8082:	0e 94 b0 3f 	call	0x7f60	; 0x7f60 <EventFunc>
}
    8086:	08 95       	ret

00008088 <PosBlink>:
}

// ~~~~~~~~~~~~~~~~~~~~~
static void
PosBlink(T_Param *Param, char Cursor)
{
    8088:	fc 01       	movw	r30, r24
	CurrX=Param->Pos+Param->Size-CurrPos-(Param->Prec&&CurrPos>=Param->Prec?2:1)-LCD_Buf[Y1];
    808a:	20 81       	ld	r18, Z
    808c:	33 81       	ldd	r19, Z+3	; 0x03
    808e:	90 91 d7 02 	lds	r25, 0x02D7
    8092:	82 81       	ldd	r24, Z+2	; 0x02
    8094:	88 23       	and	r24, r24
    8096:	11 f0       	breq	.+4      	; 0x809c <PosBlink+0x14>
    8098:	98 17       	cp	r25, r24
    809a:	a0 f4       	brcc	.+40     	; 0x80c4 <PosBlink+0x3c>
    809c:	4f ef       	ldi	r20, 0xFF	; 255
    809e:	39 1b       	sub	r19, r25
    80a0:	32 0f       	add	r19, r18
    80a2:	88 e5       	ldi	r24, 0x58	; 88
    80a4:	96 e0       	ldi	r25, 0x06	; 6
    80a6:	38 1b       	sub	r19, r24
    80a8:	80 91 45 0a 	lds	r24, 0x0A45
    80ac:	25 e1       	ldi	r18, 0x15	; 21
    80ae:	82 9f       	mul	r24, r18
    80b0:	c0 01       	movw	r24, r0
    80b2:	11 24       	eor	r1, r1
    80b4:	38 1b       	sub	r19, r24
    80b6:	34 0f       	add	r19, r20
    80b8:	30 93 fa 06 	sts	0x06FA, r19
	StrSize=1;
    80bc:	81 e0       	ldi	r24, 0x01	; 1
    80be:	80 93 ac 06 	sts	0x06AC, r24
}
    80c2:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~~~
static void
PosBlink(T_Param *Param, char Cursor)
{
	CurrX=Param->Pos+Param->Size-CurrPos-(Param->Prec&&CurrPos>=Param->Prec?2:1)-LCD_Buf[Y1];
    80c4:	4e ef       	ldi	r20, 0xFE	; 254
    80c6:	eb cf       	rjmp	.-42     	; 0x809e <PosBlink+0x16>

000080c8 <GetCurrFieldSize>:

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    80c8:	e0 91 d4 02 	lds	r30, 0x02D4
    80cc:	f0 91 d5 02 	lds	r31, 0x02D5
    80d0:	45 91       	lpm	r20, Z+
    80d2:	54 91       	lpm	r21, Z+
}
// ~~~~~~~~~~~~~~~~~~~~~~~
// Return size of CurrField. Use to determine size of Text, EE_Text OutField vars
uint8_t GetCurrFieldSize(void){
	uint8_t Size;
	MenuLine *Line=GetLine+CurrLine;
    80d4:	80 91 ca 07 	lds	r24, 0x07CA
    80d8:	2b e1       	ldi	r18, 0x1B	; 27
    80da:	82 9f       	mul	r24, r18
    80dc:	c0 01       	movw	r24, r0
    80de:	11 24       	eor	r1, r1
    80e0:	48 0f       	add	r20, r24
    80e2:	59 1f       	adc	r21, r25
		while(prc(CurrStr+X)=='}'){
			X++;
			Size++;
		}
		if(Size){
			if(OF_N == CurrField) return Size;
    80e4:	30 91 d6 02 	lds	r19, 0x02D6
    80e8:	90 e0       	ldi	r25, 0x00	; 0
    80ea:	20 e0       	ldi	r18, 0x00	; 0

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    80ec:	fa 01       	movw	r30, r20
    80ee:	e9 0f       	add	r30, r25
    80f0:	f1 1d       	adc	r31, r1
    80f2:	e4 91       	lpm	r30, Z+
	MenuLine *Line=GetLine+CurrLine;
	PGM_P CurrStr=(PGM_P)(Line->Str);
	uint8_t OF_N = 0;
	for(uint8_t X=0; X<LCDXSz; X++){
		Size = 0;
		while(prc(CurrStr+X)=='}'){
    80f4:	ed 37       	cpi	r30, 0x7D	; 125
    80f6:	71 f4       	brne	.+28     	; 0x8114 <GetCurrFieldSize+0x4c>
			X++;
			Size++;
		}
		if(Size){
			if(OF_N == CurrField) return Size;
    80f8:	80 e0       	ldi	r24, 0x00	; 0
	PGM_P CurrStr=(PGM_P)(Line->Str);
	uint8_t OF_N = 0;
	for(uint8_t X=0; X<LCDXSz; X++){
		Size = 0;
		while(prc(CurrStr+X)=='}'){
			X++;
    80fa:	9f 5f       	subi	r25, 0xFF	; 255
			Size++;
    80fc:	8f 5f       	subi	r24, 0xFF	; 255
    80fe:	fa 01       	movw	r30, r20
    8100:	e9 0f       	add	r30, r25
    8102:	f1 1d       	adc	r31, r1
    8104:	e4 91       	lpm	r30, Z+
	MenuLine *Line=GetLine+CurrLine;
	PGM_P CurrStr=(PGM_P)(Line->Str);
	uint8_t OF_N = 0;
	for(uint8_t X=0; X<LCDXSz; X++){
		Size = 0;
		while(prc(CurrStr+X)=='}'){
    8106:	ed 37       	cpi	r30, 0x7D	; 125
    8108:	c1 f3       	breq	.-16     	; 0x80fa <GetCurrFieldSize+0x32>
			X++;
			Size++;
		}
		if(Size){
    810a:	88 23       	and	r24, r24
    810c:	19 f0       	breq	.+6      	; 0x8114 <GetCurrFieldSize+0x4c>
			if(OF_N == CurrField) return Size;
    810e:	23 17       	cp	r18, r19
    8110:	29 f0       	breq	.+10     	; 0x811c <GetCurrFieldSize+0x54>
			OF_N++;
    8112:	2f 5f       	subi	r18, 0xFF	; 255
uint8_t GetCurrFieldSize(void){
	uint8_t Size;
	MenuLine *Line=GetLine+CurrLine;
	PGM_P CurrStr=(PGM_P)(Line->Str);
	uint8_t OF_N = 0;
	for(uint8_t X=0; X<LCDXSz; X++){
    8114:	9f 5f       	subi	r25, 0xFF	; 255
    8116:	94 31       	cpi	r25, 0x14	; 20
    8118:	48 f3       	brcs	.-46     	; 0x80ec <GetCurrFieldSize+0x24>
		Size = 0;
		while(prc(CurrStr+X)=='}'){
    811a:	80 e0       	ldi	r24, 0x00	; 0
			if(OF_N == CurrField) return Size;
			OF_N++;
		}
	}
	return 0;
}
    811c:	08 95       	ret

0000811e <Inc>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
static int32_t
Inc(int8_t Dir, uint32_t Buf)
{
    811e:	5f 92       	push	r5
    8120:	6f 92       	push	r6
    8122:	7f 92       	push	r7
    8124:	8f 92       	push	r8
    8126:	9f 92       	push	r9
    8128:	af 92       	push	r10
    812a:	bf 92       	push	r11
    812c:	cf 92       	push	r12
    812e:	df 92       	push	r13
    8130:	ef 92       	push	r14
    8132:	ff 92       	push	r15
    8134:	0f 93       	push	r16
    8136:	1f 93       	push	r17
    8138:	cf 93       	push	r28
    813a:	df 93       	push	r29
    813c:	58 2e       	mov	r5, r24
    813e:	3a 01       	movw	r6, r20
    8140:	4b 01       	movw	r8, r22
	uint32_t Pos = PowL10(CurrPos);
    8142:	d0 90 d7 02 	lds	r13, 0x02D7
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
	uint32_t Pow = 1;
	while(Exp--)
    8146:	dd 20       	and	r13, r13
    8148:	09 f4       	brne	.+2      	; 0x814c <Inc+0x2e>
    814a:	5f c0       	rjmp	.+190    	; 0x820a <Inc+0xec>
    814c:	61 e0       	ldi	r22, 0x01	; 1
    814e:	e6 2e       	mov	r14, r22
    8150:	f1 2c       	mov	r15, r1
    8152:	01 2d       	mov	r16, r1
    8154:	11 2d       	mov	r17, r1
		Pow *= 10;
    8156:	c8 01       	movw	r24, r16
    8158:	b7 01       	movw	r22, r14
    815a:	2a e0       	ldi	r18, 0x0A	; 10
    815c:	30 e0       	ldi	r19, 0x00	; 0
    815e:	40 e0       	ldi	r20, 0x00	; 0
    8160:	50 e0       	ldi	r21, 0x00	; 0
    8162:	0e 94 8c 87 	call	0x10f18	; 0x10f18 <__mulsi3>
    8166:	7b 01       	movw	r14, r22
    8168:	8c 01       	movw	r16, r24
    816a:	da 94       	dec	r13
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
	uint32_t Pow = 1;
	while(Exp--)
    816c:	a1 f7       	brne	.-24     	; 0x8156 <Inc+0x38>
    816e:	5b 01       	movw	r10, r22
    8170:	6c 01       	movw	r12, r24
	uint8_t Dig=Buf%(Pos*10)/Pos;
	if(Dig==(Dir==1?9:0)) {
    8172:	81 e0       	ldi	r24, 0x01	; 1
    8174:	58 16       	cp	r5, r24
    8176:	09 f4       	brne	.+2      	; 0x817a <Inc+0x5c>
    8178:	45 c0       	rjmp	.+138    	; 0x8204 <Inc+0xe6>
    817a:	c0 e0       	ldi	r28, 0x00	; 0
    817c:	d0 e0       	ldi	r29, 0x00	; 0
    817e:	c8 01       	movw	r24, r16
    8180:	b7 01       	movw	r22, r14
    8182:	2a e0       	ldi	r18, 0x0A	; 10
    8184:	30 e0       	ldi	r19, 0x00	; 0
    8186:	40 e0       	ldi	r20, 0x00	; 0
    8188:	50 e0       	ldi	r21, 0x00	; 0
    818a:	0e 94 8c 87 	call	0x10f18	; 0x10f18 <__mulsi3>
    818e:	9b 01       	movw	r18, r22
    8190:	ac 01       	movw	r20, r24
    8192:	c4 01       	movw	r24, r8
    8194:	b3 01       	movw	r22, r6
    8196:	0e 94 de 87 	call	0x10fbc	; 0x10fbc <__udivmodsi4>
    819a:	a8 01       	movw	r20, r16
    819c:	97 01       	movw	r18, r14
    819e:	0e 94 de 87 	call	0x10fbc	; 0x10fbc <__udivmodsi4>
    81a2:	30 e0       	ldi	r19, 0x00	; 0
    81a4:	2c 17       	cp	r18, r28
    81a6:	3d 07       	cpc	r19, r29
    81a8:	99 f4       	brne	.+38     	; 0x81d0 <Inc+0xb2>
			Dir = -Dir;
    81aa:	51 94       	neg	r5
			Pos *= 9;
    81ac:	57 01       	movw	r10, r14
    81ae:	68 01       	movw	r12, r16
    81b0:	aa 0c       	add	r10, r10
    81b2:	bb 1c       	adc	r11, r11
    81b4:	cc 1c       	adc	r12, r12
    81b6:	dd 1c       	adc	r13, r13
    81b8:	aa 0c       	add	r10, r10
    81ba:	bb 1c       	adc	r11, r11
    81bc:	cc 1c       	adc	r12, r12
    81be:	dd 1c       	adc	r13, r13
    81c0:	aa 0c       	add	r10, r10
    81c2:	bb 1c       	adc	r11, r11
    81c4:	cc 1c       	adc	r12, r12
    81c6:	dd 1c       	adc	r13, r13
    81c8:	ae 0c       	add	r10, r14
    81ca:	bf 1c       	adc	r11, r15
    81cc:	c0 1e       	adc	r12, r16
    81ce:	d1 1e       	adc	r13, r17
    81d0:	65 2d       	mov	r22, r5
    81d2:	77 27       	eor	r23, r23
    81d4:	67 fd       	sbrc	r22, 7
    81d6:	70 95       	com	r23
    81d8:	87 2f       	mov	r24, r23
    81da:	97 2f       	mov	r25, r23
    81dc:	a6 01       	movw	r20, r12
    81de:	95 01       	movw	r18, r10
    81e0:	0e 94 8c 87 	call	0x10f18	; 0x10f18 <__mulsi3>
	}
	return Pos*Dir;
}
    81e4:	df 91       	pop	r29
    81e6:	cf 91       	pop	r28
    81e8:	1f 91       	pop	r17
    81ea:	0f 91       	pop	r16
    81ec:	ff 90       	pop	r15
    81ee:	ef 90       	pop	r14
    81f0:	df 90       	pop	r13
    81f2:	cf 90       	pop	r12
    81f4:	bf 90       	pop	r11
    81f6:	af 90       	pop	r10
    81f8:	9f 90       	pop	r9
    81fa:	8f 90       	pop	r8
    81fc:	7f 90       	pop	r7
    81fe:	6f 90       	pop	r6
    8200:	5f 90       	pop	r5
    8202:	08 95       	ret
static int32_t
Inc(int8_t Dir, uint32_t Buf)
{
	uint32_t Pos = PowL10(CurrPos);
	uint8_t Dig=Buf%(Pos*10)/Pos;
	if(Dig==(Dir==1?9:0)) {
    8204:	c9 e0       	ldi	r28, 0x09	; 9
    8206:	d0 e0       	ldi	r29, 0x00	; 0
    8208:	ba cf       	rjmp	.-140    	; 0x817e <Inc+0x60>
    820a:	e1 e0       	ldi	r30, 0x01	; 1
    820c:	ee 2e       	mov	r14, r30
    820e:	f1 2c       	mov	r15, r1
    8210:	01 2d       	mov	r16, r1
    8212:	11 2d       	mov	r17, r1
    8214:	71 e0       	ldi	r23, 0x01	; 1
    8216:	a7 2e       	mov	r10, r23
    8218:	b1 2c       	mov	r11, r1
    821a:	c1 2c       	mov	r12, r1
    821c:	d1 2c       	mov	r13, r1
    821e:	a9 cf       	rjmp	.-174    	; 0x8172 <Inc+0x54>

00008220 <MenuRight>:

// ~~~~~~~~~~~~
void
MenuRight(void)
{
}
    8220:	08 95       	ret

00008222 <MenuLeft>:

// ~~~~~~~~~~~~~
void
MenuLeft(void)
{
}
    8222:	08 95       	ret

00008224 <MenuEnter>:

// ~~~~~~~~~~~~
void
MenuEnter(void)
{
}
    8224:	08 95       	ret

00008226 <MenuEsc>:

// ~~~~~~~~~~
void
MenuEsc(void)
{
}
    8226:	08 95       	ret

00008228 <DI_State>:
} DigInput;

// ~~~~~~~~~~~~~~~~~~
uint8_t
DI_State(uint8_t D_N)
{
    8228:	28 2f       	mov	r18, r24
    822a:	86 95       	lsr	r24
    822c:	86 95       	lsr	r24
    822e:	86 95       	lsr	r24
    8230:	e0 e4       	ldi	r30, 0x40	; 64
    8232:	f7 e0       	ldi	r31, 0x07	; 7
    8234:	e8 0f       	add	r30, r24
    8236:	f1 1d       	adc	r31, r1
    8238:	80 81       	ld	r24, Z
    823a:	90 e0       	ldi	r25, 0x00	; 0
    823c:	27 70       	andi	r18, 0x07	; 7
    823e:	02 c0       	rjmp	.+4      	; 0x8244 <DI_State+0x1c>
    8240:	95 95       	asr	r25
    8242:	87 95       	ror	r24
    8244:	2a 95       	dec	r18
    8246:	e2 f7       	brpl	.-8      	; 0x8240 <DI_State+0x18>
	return (DigInput.State[D_N/8] &(1<<D_N%8)) != 0;
}
    8248:	81 70       	andi	r24, 0x01	; 1
    824a:	08 95       	ret

0000824c <DI_Front>:

// ~~~~~~~~~~~~~~~~~~
uint8_t
DI_Front(uint8_t D_N)
{
    824c:	e8 2f       	mov	r30, r24
	uint8_t Byte=D_N/8, Bit=1<<D_N%8;
    824e:	28 2f       	mov	r18, r24
    8250:	27 70       	andi	r18, 0x07	; 7
    8252:	81 e0       	ldi	r24, 0x01	; 1
    8254:	90 e0       	ldi	r25, 0x00	; 0
    8256:	01 c0       	rjmp	.+2      	; 0x825a <DI_Front+0xe>
    8258:	88 0f       	add	r24, r24
    825a:	2a 95       	dec	r18
    825c:	ea f7       	brpl	.-6      	; 0x8258 <DI_Front+0xc>
	uint8_t State = DigInput.State[Byte] &Bit;
    825e:	e6 95       	lsr	r30
    8260:	e6 95       	lsr	r30
    8262:	e6 95       	lsr	r30
    8264:	f0 e0       	ldi	r31, 0x00	; 0
    8266:	e0 5c       	subi	r30, 0xC0	; 192
    8268:	f8 4f       	sbci	r31, 0xF8	; 248
    826a:	90 81       	ld	r25, Z
    826c:	98 23       	and	r25, r24
	return DigInput.StateOld[Byte] &Bit ? State?NoFront:FallFront : State?RiseFront:NoFront;
    826e:	23 81       	ldd	r18, Z+3	; 0x03
    8270:	82 23       	and	r24, r18
    8272:	21 f0       	breq	.+8      	; 0x827c <DI_Front+0x30>
    8274:	99 23       	and	r25, r25
    8276:	41 f4       	brne	.+16     	; 0x8288 <DI_Front+0x3c>
    8278:	82 e0       	ldi	r24, 0x02	; 2
    827a:	08 95       	ret
    827c:	89 2f       	mov	r24, r25
    827e:	99 23       	and	r25, r25
    8280:	09 f4       	brne	.+2      	; 0x8284 <DI_Front+0x38>
}
    8282:	08 95       	ret
uint8_t
DI_Front(uint8_t D_N)
{
	uint8_t Byte=D_N/8, Bit=1<<D_N%8;
	uint8_t State = DigInput.State[Byte] &Bit;
	return DigInput.StateOld[Byte] &Bit ? State?NoFront:FallFront : State?RiseFront:NoFront;
    8284:	81 e0       	ldi	r24, 0x01	; 1
}
    8286:	08 95       	ret
uint8_t
DI_Front(uint8_t D_N)
{
	uint8_t Byte=D_N/8, Bit=1<<D_N%8;
	uint8_t State = DigInput.State[Byte] &Bit;
	return DigInput.StateOld[Byte] &Bit ? State?NoFront:FallFront : State?RiseFront:NoFront;
    8288:	80 e0       	ldi	r24, 0x00	; 0
    828a:	08 95       	ret

0000828c <DI_Status>:
}

// ~~~~~~~~~~~~~~~~~~~
uint8_t
DI_Status(uint8_t D_N)
{
    828c:	28 2f       	mov	r18, r24
    828e:	86 95       	lsr	r24
    8290:	86 95       	lsr	r24
    8292:	86 95       	lsr	r24
    8294:	e0 e4       	ldi	r30, 0x40	; 64
    8296:	f7 e0       	ldi	r31, 0x07	; 7
    8298:	e8 0f       	add	r30, r24
    829a:	f1 1d       	adc	r31, r1
    829c:	86 81       	ldd	r24, Z+6	; 0x06
    829e:	90 e0       	ldi	r25, 0x00	; 0
    82a0:	27 70       	andi	r18, 0x07	; 7
    82a2:	02 c0       	rjmp	.+4      	; 0x82a8 <DI_Status+0x1c>
    82a4:	95 95       	asr	r25
    82a6:	87 95       	ror	r24
    82a8:	2a 95       	dec	r18
    82aa:	e2 f7       	brpl	.-8      	; 0x82a4 <DI_Status+0x18>
	return (DigInput.Status[D_N/8] &(1<<D_N%8)) != 0;
}
    82ac:	81 70       	andi	r24, 0x01	; 1
    82ae:	08 95       	ret

000082b0 <DI_Init>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

// ~~~~~~~~~~
void
DI_Init(void)
{
    82b0:	20 e0       	ldi	r18, 0x00	; 0
    82b2:	30 e0       	ldi	r19, 0x00	; 0
// ~~~~~~~~~~~~~~~
static void
DI_Init_Hard(void)
{
	for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
		cli();
    82b4:	f8 94       	cli

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    82b6:	a9 01       	movw	r20, r18
    82b8:	44 0f       	add	r20, r20
    82ba:	55 1f       	adc	r21, r21
    82bc:	44 0f       	add	r20, r20
    82be:	55 1f       	adc	r21, r21
    82c0:	44 0f       	add	r20, r20
    82c2:	55 1f       	adc	r21, r21
    82c4:	ca 01       	movw	r24, r20
    82c6:	86 59       	subi	r24, 0x96	; 150
    82c8:	9e 4c       	sbci	r25, 0xCE	; 206
    82ca:	fc 01       	movw	r30, r24
    82cc:	a5 91       	lpm	r26, Z+
    82ce:	b4 91       	lpm	r27, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    82d0:	40 59       	subi	r20, 0x90	; 144
    82d2:	5e 4c       	sbci	r21, 0xCE	; 206
    82d4:	fa 01       	movw	r30, r20
    82d6:	44 91       	lpm	r20, Z+
		*(uint8_t*)prp(&DI_M[D_N].DDR) &=~prb(&DI_M[D_N].P);
    82d8:	94 2f       	mov	r25, r20
    82da:	90 95       	com	r25
    82dc:	8c 91       	ld	r24, X
    82de:	89 23       	and	r24, r25
    82e0:	8c 93       	st	X, r24

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    82e2:	c9 01       	movw	r24, r18
    82e4:	88 0f       	add	r24, r24
    82e6:	99 1f       	adc	r25, r25
    82e8:	88 0f       	add	r24, r24
    82ea:	99 1f       	adc	r25, r25
    82ec:	88 0f       	add	r24, r24
    82ee:	99 1f       	adc	r25, r25
    82f0:	84 59       	subi	r24, 0x94	; 148
    82f2:	9e 4c       	sbci	r25, 0xCE	; 206
    82f4:	fc 01       	movw	r30, r24
    82f6:	a5 91       	lpm	r26, Z+
    82f8:	b4 91       	lpm	r27, Z+
		*(uint8_t*)prp(&DI_M[D_N].PORT) |=prb(&DI_M[D_N].P);
    82fa:	8c 91       	ld	r24, X
    82fc:	84 2b       	or	r24, r20
    82fe:	8c 93       	st	X, r24
		sei();
    8300:	78 94       	sei
    8302:	2f 5f       	subi	r18, 0xFF	; 255
    8304:	3f 4f       	sbci	r19, 0xFF	; 255

// ~~~~~~~~~~~~~~~
static void
DI_Init_Hard(void)
{
	for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
    8306:	22 31       	cpi	r18, 0x12	; 18
    8308:	31 05       	cpc	r19, r1
    830a:	a1 f6       	brne	.-88     	; 0x82b4 <DI_Init+0x4>
{
	DI_Init_Hard();
	#ifdef HSC_Reg
		HSC_Init();
	#endif
}
    830c:	08 95       	ret

0000830e <DO_State>:
} DigOutput;

// ~~~~~~~~~~~~~~~~~~
uint8_t
DO_State(uint8_t D_N)
{
    830e:	90 e0       	ldi	r25, 0x00	; 0
    8310:	e8 2f       	mov	r30, r24
    8312:	e6 95       	lsr	r30
    8314:	e6 95       	lsr	r30
    8316:	e6 95       	lsr	r30
    8318:	f0 e0       	ldi	r31, 0x00	; 0
    831a:	e5 52       	subi	r30, 0x25	; 37
    831c:	f8 4f       	sbci	r31, 0xF8	; 248
    831e:	40 81       	ld	r20, Z
    8320:	50 e0       	ldi	r21, 0x00	; 0
    8322:	87 70       	andi	r24, 0x07	; 7
    8324:	21 e0       	ldi	r18, 0x01	; 1
    8326:	30 e0       	ldi	r19, 0x00	; 0
    8328:	02 c0       	rjmp	.+4      	; 0x832e <DO_State+0x20>
    832a:	22 0f       	add	r18, r18
    832c:	33 1f       	adc	r19, r19
    832e:	8a 95       	dec	r24
    8330:	e2 f7       	brpl	.-8      	; 0x832a <DO_State+0x1c>
    8332:	42 23       	and	r20, r18
    8334:	53 23       	and	r21, r19
    8336:	14 16       	cp	r1, r20
    8338:	15 06       	cpc	r1, r21
    833a:	0c f4       	brge	.+2      	; 0x833e <DO_State+0x30>
    833c:	91 e0       	ldi	r25, 0x01	; 1
	return (DigOutput.State[D_N/8] &(1<<D_N%8)) > 0;
}
    833e:	89 2f       	mov	r24, r25
    8340:	08 95       	ret

00008342 <DO_Front>:

// ~~~~~~~~~~~~~~~~~~
uint8_t
DO_Front(uint8_t D_N)
{
    8342:	e8 2f       	mov	r30, r24
	uint8_t Byte=D_N/8, Bit=1<<D_N%8;
    8344:	28 2f       	mov	r18, r24
    8346:	27 70       	andi	r18, 0x07	; 7
    8348:	81 e0       	ldi	r24, 0x01	; 1
    834a:	90 e0       	ldi	r25, 0x00	; 0
    834c:	01 c0       	rjmp	.+2      	; 0x8350 <DO_Front+0xe>
    834e:	88 0f       	add	r24, r24
    8350:	2a 95       	dec	r18
    8352:	ea f7       	brpl	.-6      	; 0x834e <DO_Front+0xc>
	uint8_t State = DigOutput.State[Byte] &Bit;
    8354:	e6 95       	lsr	r30
    8356:	e6 95       	lsr	r30
    8358:	e6 95       	lsr	r30
    835a:	f0 e0       	ldi	r31, 0x00	; 0
    835c:	e5 52       	subi	r30, 0x25	; 37
    835e:	f8 4f       	sbci	r31, 0xF8	; 248
    8360:	90 81       	ld	r25, Z
    8362:	98 23       	and	r25, r24
	return DigOutput.StateOld[Byte] &Bit ? State?NoFront:FallFront : State?RiseFront:NoFront;
    8364:	22 81       	ldd	r18, Z+2	; 0x02
    8366:	82 23       	and	r24, r18
    8368:	21 f0       	breq	.+8      	; 0x8372 <DO_Front+0x30>
    836a:	99 23       	and	r25, r25
    836c:	41 f4       	brne	.+16     	; 0x837e <DO_Front+0x3c>
    836e:	82 e0       	ldi	r24, 0x02	; 2
    8370:	08 95       	ret
    8372:	89 2f       	mov	r24, r25
    8374:	99 23       	and	r25, r25
    8376:	09 f4       	brne	.+2      	; 0x837a <DO_Front+0x38>
}
    8378:	08 95       	ret
uint8_t
DO_Front(uint8_t D_N)
{
	uint8_t Byte=D_N/8, Bit=1<<D_N%8;
	uint8_t State = DigOutput.State[Byte] &Bit;
	return DigOutput.StateOld[Byte] &Bit ? State?NoFront:FallFront : State?RiseFront:NoFront;
    837a:	81 e0       	ldi	r24, 0x01	; 1
}
    837c:	08 95       	ret
uint8_t
DO_Front(uint8_t D_N)
{
	uint8_t Byte=D_N/8, Bit=1<<D_N%8;
	uint8_t State = DigOutput.State[Byte] &Bit;
	return DigOutput.StateOld[Byte] &Bit ? State?NoFront:FallFront : State?RiseFront:NoFront;
    837e:	80 e0       	ldi	r24, 0x00	; 0
    8380:	08 95       	ret

00008382 <SetDigOut>:

// ~~~~~~~~~~~~~~~~~~~
void
SetDigOut(uint8_t D_N)
{
	DigOutput.Buf[D_N/8] |=(1<<D_N%8);
    8382:	98 2f       	mov	r25, r24
    8384:	96 95       	lsr	r25
    8386:	96 95       	lsr	r25
    8388:	96 95       	lsr	r25
    838a:	eb ed       	ldi	r30, 0xDB	; 219
    838c:	f7 e0       	ldi	r31, 0x07	; 7
    838e:	e9 0f       	add	r30, r25
    8390:	f1 1d       	adc	r31, r1
    8392:	87 70       	andi	r24, 0x07	; 7
    8394:	21 e0       	ldi	r18, 0x01	; 1
    8396:	30 e0       	ldi	r19, 0x00	; 0
    8398:	02 c0       	rjmp	.+4      	; 0x839e <SetDigOut+0x1c>
    839a:	22 0f       	add	r18, r18
    839c:	33 1f       	adc	r19, r19
    839e:	8a 95       	dec	r24
    83a0:	e2 f7       	brpl	.-8      	; 0x839a <SetDigOut+0x18>
    83a2:	84 81       	ldd	r24, Z+4	; 0x04
    83a4:	82 2b       	or	r24, r18
    83a6:	84 83       	std	Z+4, r24	; 0x04
}
    83a8:	08 95       	ret

000083aa <ResDigOut>:

// ~~~~~~~~~~~~~~~~~~~
void
ResDigOut(uint8_t D_N)
{
	DigOutput.Buf[D_N/8] &=~(1<<D_N%8);
    83aa:	98 2f       	mov	r25, r24
    83ac:	96 95       	lsr	r25
    83ae:	96 95       	lsr	r25
    83b0:	96 95       	lsr	r25
    83b2:	eb ed       	ldi	r30, 0xDB	; 219
    83b4:	f7 e0       	ldi	r31, 0x07	; 7
    83b6:	e9 0f       	add	r30, r25
    83b8:	f1 1d       	adc	r31, r1
    83ba:	87 70       	andi	r24, 0x07	; 7
    83bc:	21 e0       	ldi	r18, 0x01	; 1
    83be:	30 e0       	ldi	r19, 0x00	; 0
    83c0:	02 c0       	rjmp	.+4      	; 0x83c6 <ResDigOut+0x1c>
    83c2:	22 0f       	add	r18, r18
    83c4:	33 1f       	adc	r19, r19
    83c6:	8a 95       	dec	r24
    83c8:	e2 f7       	brpl	.-8      	; 0x83c2 <ResDigOut+0x18>
    83ca:	20 95       	com	r18
    83cc:	84 81       	ldd	r24, Z+4	; 0x04
    83ce:	28 23       	and	r18, r24
    83d0:	24 83       	std	Z+4, r18	; 0x04
}
    83d2:	08 95       	ret

000083d4 <TogDigOut>:

// ~~~~~~~~~~~~~~~~~~~
void
TogDigOut(uint8_t D_N)
{
	DigOutput.Buf[D_N/8] ^=(1<<D_N%8);
    83d4:	98 2f       	mov	r25, r24
    83d6:	96 95       	lsr	r25
    83d8:	96 95       	lsr	r25
    83da:	96 95       	lsr	r25
    83dc:	eb ed       	ldi	r30, 0xDB	; 219
    83de:	f7 e0       	ldi	r31, 0x07	; 7
    83e0:	e9 0f       	add	r30, r25
    83e2:	f1 1d       	adc	r31, r1
    83e4:	87 70       	andi	r24, 0x07	; 7
    83e6:	21 e0       	ldi	r18, 0x01	; 1
    83e8:	30 e0       	ldi	r19, 0x00	; 0
    83ea:	02 c0       	rjmp	.+4      	; 0x83f0 <TogDigOut+0x1c>
    83ec:	22 0f       	add	r18, r18
    83ee:	33 1f       	adc	r19, r19
    83f0:	8a 95       	dec	r24
    83f2:	e2 f7       	brpl	.-8      	; 0x83ec <TogDigOut+0x18>
    83f4:	84 81       	ldd	r24, Z+4	; 0x04
    83f6:	82 27       	eor	r24, r18
    83f8:	84 83       	std	Z+4, r24	; 0x04
}
    83fa:	08 95       	ret

000083fc <SetAllDigOut>:

// ~~~~~~~~~~~~~~~
void
SetAllDigOut(void)
{
	for (uint8_t i=0; i<DO_Reg; DigOutput.Buf[i++]=0xFF);
    83fc:	8f ef       	ldi	r24, 0xFF	; 255
    83fe:	80 93 df 07 	sts	0x07DF, r24
    8402:	80 93 e0 07 	sts	0x07E0, r24
}
    8406:	08 95       	ret

00008408 <DO_Enable>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    8408:	8f b7       	in	r24, 0x3f	; 63
    840a:	80 78       	andi	r24, 0x80	; 128
    840c:	80 93 ee 02 	sts	0x02EE, r24
	cli();
    8410:	f8 94       	cli
void
DO_Enable(void)
{
	#ifdef Enable
		IntOff();
		PortEnable |=Enable;
    8412:	46 9a       	sbi	0x08, 6	; 8

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    8414:	88 23       	and	r24, r24
    8416:	09 f0       	breq	.+2      	; 0x841a <DO_Enable+0x12>
		sei();
    8418:	78 94       	sei
    841a:	08 95       	ret

0000841c <DO_Disable>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    841c:	8f b7       	in	r24, 0x3f	; 63
    841e:	80 78       	andi	r24, 0x80	; 128
    8420:	80 93 ee 02 	sts	0x02EE, r24
	cli();
    8424:	f8 94       	cli
void
DO_Disable()
{
	#ifdef Enable
		IntOff();
		PortEnable &=~Enable;
    8426:	46 98       	cbi	0x08, 6	; 8

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    8428:	88 23       	and	r24, r24
    842a:	09 f0       	breq	.+2      	; 0x842e <DO_Disable+0x12>
		sei();
    842c:	78 94       	sei
    842e:	08 95       	ret

00008430 <DigitOut>:

// ~~~~~~~~~~~
void
DigitOut(void)
{
	memcpy(DigOutput.StateOld, DigOutput.State, DO_Reg+DO_Reg_Ext);
    8430:	90 91 db 07 	lds	r25, 0x07DB
    8434:	80 91 dc 07 	lds	r24, 0x07DC
    8438:	80 93 de 07 	sts	0x07DE, r24
    843c:	90 93 dd 07 	sts	0x07DD, r25
	memcpy(DigOutput.State, DigOutput.Buf, DO_Reg);
    8440:	90 91 df 07 	lds	r25, 0x07DF
    8444:	80 91 e0 07 	lds	r24, 0x07E0
    8448:	80 93 dc 07 	sts	0x07DC, r24
    844c:	90 93 db 07 	sts	0x07DB, r25
    8450:	20 e1       	ldi	r18, 0x10	; 16
    8452:	35 e0       	ldi	r19, 0x05	; 5
    8454:	10 c0       	rjmp	.+32     	; 0x8476 <DigitOut+0x46>
	uint8_t N = DO_Reg*8;
	while (N) {
		uint8_t D_N = prb(M+--N);
		cli();
		if (DigOutput.State[D_N/8] &(1<<D_N%8))
			PortData  |=Data;
    8456:	47 9a       	sbi	0x08, 7	; 8
		else
			PortData &=~Data;
		sei();
    8458:	78 94       	sei
    845a:	83 2f       	mov	r24, r19
    845c:	8a 95       	dec	r24
    845e:	f1 f7       	brne	.-4      	; 0x845c <DigitOut+0x2c>
		_delay_us(1);				// 125 ns needs at 5V
		cli();
    8460:	f8 94       	cli
		PortClock |=Clock;
    8462:	45 9a       	sbi	0x08, 5	; 8
		sei();
    8464:	78 94       	sei
    8466:	83 2f       	mov	r24, r19
    8468:	8a 95       	dec	r24
    846a:	f1 f7       	brne	.-4      	; 0x8468 <DigitOut+0x38>
		_delay_us(1);				// 200 ns needs at 5V
		cli();
    846c:	f8 94       	cli
		PortClock &=~Clock;
    846e:	45 98       	cbi	0x08, 5	; 8
		sei();
    8470:	78 94       	sei
DigitOut_Hard(void)
{
	static prog_uint8_t M[DO_Reg*8] = DO_Map;

	uint8_t N = DO_Reg*8;
	while (N) {
    8472:	22 23       	and	r18, r18
    8474:	d1 f0       	breq	.+52     	; 0x84aa <DigitOut+0x7a>
		uint8_t D_N = prb(M+--N);
    8476:	21 50       	subi	r18, 0x01	; 1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    8478:	e2 2f       	mov	r30, r18
    847a:	f0 e0       	ldi	r31, 0x00	; 0
    847c:	e6 5a       	subi	r30, 0xA6	; 166
    847e:	fe 4c       	sbci	r31, 0xCE	; 206
    8480:	e4 91       	lpm	r30, Z+
		cli();
    8482:	f8 94       	cli
		if (DigOutput.State[D_N/8] &(1<<D_N%8))
    8484:	ae 2f       	mov	r26, r30
    8486:	a6 95       	lsr	r26
    8488:	a6 95       	lsr	r26
    848a:	a6 95       	lsr	r26
    848c:	b0 e0       	ldi	r27, 0x00	; 0
    848e:	a5 52       	subi	r26, 0x25	; 37
    8490:	b8 4f       	sbci	r27, 0xF8	; 248
    8492:	8c 91       	ld	r24, X
    8494:	90 e0       	ldi	r25, 0x00	; 0
    8496:	e7 70       	andi	r30, 0x07	; 7
    8498:	02 c0       	rjmp	.+4      	; 0x849e <DigitOut+0x6e>
    849a:	95 95       	asr	r25
    849c:	87 95       	ror	r24
    849e:	ea 95       	dec	r30
    84a0:	e2 f7       	brpl	.-8      	; 0x849a <DigitOut+0x6a>
    84a2:	80 fd       	sbrc	r24, 0
    84a4:	d8 cf       	rjmp	.-80     	; 0x8456 <DigitOut+0x26>
			PortData  |=Data;
		else
			PortData &=~Data;
    84a6:	47 98       	cbi	0x08, 7	; 8
    84a8:	d7 cf       	rjmp	.-82     	; 0x8458 <DigitOut+0x28>
		_delay_us(1);				// 200 ns needs at 5V
		cli();
		PortClock &=~Clock;
		sei();
	}
	cli();
    84aa:	f8 94       	cli
	PortStrobe |=Strobe;
    84ac:	80 91 05 01 	lds	r24, 0x0105
    84b0:	81 60       	ori	r24, 0x01	; 1
    84b2:	80 93 05 01 	sts	0x0105, r24
	sei();
    84b6:	78 94       	sei
    84b8:	85 e0       	ldi	r24, 0x05	; 5
    84ba:	8a 95       	dec	r24
    84bc:	f1 f7       	brne	.-4      	; 0x84ba <DigitOut+0x8a>
	_delay_us(1);					// 200 ns needs at 5V
	cli();
    84be:	f8 94       	cli
	PortStrobe &=~Strobe;
    84c0:	80 91 05 01 	lds	r24, 0x0105
    84c4:	8e 7f       	andi	r24, 0xFE	; 254
    84c6:	80 93 05 01 	sts	0x0105, r24
	sei();
    84ca:	78 94       	sei
				DigOutput.State[j] = (DigOutput_Ext)[i];
			(DigOutput_Ext)[i+DO_Reg_Ext] = DigOutput.Buf[j];
			IntOn();
		}
	#endif
}
    84cc:	08 95       	ret

000084ce <DO_Init>:

// ~~~~~~~~~~~~~~~
static void
DO_Init_Hard(void)
{
	cli();
    84ce:	f8 94       	cli
	DDR_Strobe |= Strobe;
    84d0:	e4 e0       	ldi	r30, 0x04	; 4
    84d2:	f1 e0       	ldi	r31, 0x01	; 1
    84d4:	80 81       	ld	r24, Z
    84d6:	81 60       	ori	r24, 0x01	; 1
    84d8:	80 83       	st	Z, r24
	DDR_Data |= Data;
    84da:	3f 9a       	sbi	0x07, 7	; 7
	DDR_Enable |= Enable;
    84dc:	3e 9a       	sbi	0x07, 6	; 7
	DDR_Clock |=Clock;
    84de:	3d 9a       	sbi	0x07, 5	; 7
	PortStrobe &=~Strobe;
    84e0:	e5 e0       	ldi	r30, 0x05	; 5
    84e2:	f1 e0       	ldi	r31, 0x01	; 1
    84e4:	80 81       	ld	r24, Z
    84e6:	8e 7f       	andi	r24, 0xFE	; 254
    84e8:	80 83       	st	Z, r24
	PortClock &=~Clock;
    84ea:	45 98       	cbi	0x08, 5	; 8
	sei();
    84ec:	78 94       	sei
// ~~~~~~~~~~
void
DO_Init(void)
{
	DO_Init_Hard();
	DigitOut();		// Clear all
    84ee:	0e 94 18 42 	call	0x8430	; 0x8430 <DigitOut>
	DO_Enable();
    84f2:	0e 94 04 42 	call	0x8408	; 0x8408 <DO_Enable>
}
    84f6:	08 95       	ret

000084f8 <AI_Init>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    84f8:	e0 91 00 05 	lds	r30, 0x0500
    84fc:	f0 e0       	ldi	r31, 0x00	; 0
    84fe:	ee 0f       	add	r30, r30
    8500:	ff 1f       	adc	r31, r31
    8502:	e6 5b       	subi	r30, 0xB6	; 182
    8504:	fe 4c       	sbci	r31, 0xCE	; 206
    8506:	85 91       	lpm	r24, Z+
    8508:	94 91       	lpm	r25, Z+
// ~~~~~~~~~~~
static void
SetMuxAI(void)
{
	static prog_uint16_t Mux[] = AI_Mux;
	ADMUX = (uint8_t) prw(Mux+AI_N);
    850a:	80 93 7c 00 	sts	0x007C, r24
	#ifdef MUX5
		ADCSRB = (uint8_t) (prw(Mux+AI_N)>>8);
    850e:	90 93 7b 00 	sts	0x007B, r25
		#ifdef AN_C
			DDR_AN_C |=AN_C;
		#endif
	#endif
	SetMuxAI();
	ADCSRA = (((((1<<ADEN) |(1<<ADSC)) &~(1<<AD_Mode)) |(1<<ADIF)) &~(1<<ADIE)) |(1<<ADPS2) |(1<<ADPS1) |(1<<ADPS0);
    8512:	87 ed       	ldi	r24, 0xD7	; 215
    8514:	80 93 7a 00 	sts	0x007A, r24
		}
	#endif
	#ifdef InitAI_10ms
		TD_InnADC = Timer8SysAlloc(AI_Reg);
	#endif
}
    8518:	08 95       	ret

0000851a <AnalogIn>:

// ~~~~~~~~~~~
uint8_t
AnalogIn(void)
{
	if (ADCSRA &(1<<ADSC))
    851a:	80 91 7a 00 	lds	r24, 0x007A
    851e:	86 fd       	sbrc	r24, 6
    8520:	2c c0       	rjmp	.+88     	; 0x857a <AnalogIn+0x60>
		return AI_Reg;
	AnalogInput[AI_N] = ADCL;
    8522:	50 91 00 05 	lds	r21, 0x0500
    8526:	65 2f       	mov	r22, r21
    8528:	20 91 78 00 	lds	r18, 0x0078
	AnalogInput[AI_N] |= ADCH<<8;
    852c:	40 91 79 00 	lds	r20, 0x0079
    8530:	e5 2f       	mov	r30, r21
    8532:	f0 e0       	ldi	r31, 0x00	; 0
    8534:	ee 0f       	add	r30, r30
    8536:	ff 1f       	adc	r31, r31
    8538:	e2 5b       	subi	r30, 0xB2	; 178
    853a:	f4 4f       	sbci	r31, 0xF4	; 244
    853c:	94 2f       	mov	r25, r20
    853e:	80 e0       	ldi	r24, 0x00	; 0
    8540:	30 e0       	ldi	r19, 0x00	; 0
    8542:	82 2b       	or	r24, r18
    8544:	93 2b       	or	r25, r19
    8546:	91 83       	std	Z+1, r25	; 0x01
    8548:	80 83       	st	Z, r24
		}
		else
			Chan = AI_Reg;
	#endif

	if (++AI_N == AI_Reg)
    854a:	5f 5f       	subi	r21, 0xFF	; 255
    854c:	50 93 00 05 	sts	0x0500, r21
    8550:	58 30       	cpi	r21, 0x08	; 8
    8552:	b1 f0       	breq	.+44     	; 0x8580 <AnalogIn+0x66>
    8554:	e5 2f       	mov	r30, r21
    8556:	f0 e0       	ldi	r31, 0x00	; 0
    8558:	ee 0f       	add	r30, r30
    855a:	ff 1f       	adc	r31, r31
    855c:	e6 5b       	subi	r30, 0xB6	; 182
    855e:	fe 4c       	sbci	r31, 0xCE	; 206
    8560:	85 91       	lpm	r24, Z+
    8562:	94 91       	lpm	r25, Z+
// ~~~~~~~~~~~
static void
SetMuxAI(void)
{
	static prog_uint16_t Mux[] = AI_Mux;
	ADMUX = (uint8_t) prw(Mux+AI_N);
    8564:	80 93 7c 00 	sts	0x007C, r24
	#ifdef MUX5
		ADCSRB = (uint8_t) (prw(Mux+AI_N)>>8);
    8568:	90 93 7b 00 	sts	0x007B, r25
	#endif

	if (++AI_N == AI_Reg)
		AI_N = 0;
	SetMuxAI();
	ADCSRA |=(1<<ADSC);
    856c:	80 91 7a 00 	lds	r24, 0x007A
    8570:	80 64       	ori	r24, 0x40	; 64
    8572:	80 93 7a 00 	sts	0x007A, r24
			IntOn();
		}
	#endif

	return Chan;
}
    8576:	86 2f       	mov	r24, r22
    8578:	08 95       	ret

// ~~~~~~~~~~~
uint8_t
AnalogIn(void)
{
	if (ADCSRA &(1<<ADSC))
    857a:	68 e0       	ldi	r22, 0x08	; 8
			IntOn();
		}
	#endif

	return Chan;
}
    857c:	86 2f       	mov	r24, r22
    857e:	08 95       	ret
		else
			Chan = AI_Reg;
	#endif

	if (++AI_N == AI_Reg)
		AI_N = 0;
    8580:	10 92 00 05 	sts	0x0500, r1
    8584:	50 e0       	ldi	r21, 0x00	; 0
    8586:	e6 cf       	rjmp	.-52     	; 0x8554 <AnalogIn+0x3a>

00008588 <Thermode>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
int16_t
Thermode(uint8_t T_Fami, uint8_t T_Type, uint16_t Code)
{
	if (T_Type==ThermOff)
    8588:	66 23       	and	r22, r22
    858a:	f9 f0       	breq	.+62     	; 0x85ca <Thermode+0x42>
		return Therm_Off_Mark;
	if (T_Fami==Thermis)
    858c:	88 23       	and	r24, r24
    858e:	91 f4       	brne	.+36     	; 0x85b4 <Thermode+0x2c>
		switch(T_Type) {
    8590:	64 30       	cpi	r22, 0x04	; 4
    8592:	d9 f1       	breq	.+118    	; 0x860a <Thermode+0x82>
    8594:	65 30       	cpi	r22, 0x05	; 5
    8596:	60 f5       	brcc	.+88     	; 0x85f0 <Thermode+0x68>
    8598:	62 30       	cpi	r22, 0x02	; 2
    859a:	09 f4       	brne	.+2      	; 0x859e <Thermode+0x16>
    859c:	4b c0       	rjmp	.+150    	; 0x8634 <Thermode+0xac>
    859e:	63 30       	cpi	r22, 0x03	; 3
    85a0:	d8 f5       	brcc	.+118    	; 0x8618 <Thermode+0x90>
    85a2:	61 30       	cpi	r22, 0x01	; 1
    85a4:	a1 f4       	brne	.+40     	; 0x85ce <Thermode+0x46>
		case TSM100:
			return ThermCalc(TSM100);
    85a6:	82 e0       	ldi	r24, 0x02	; 2
    85a8:	90 e3       	ldi	r25, 0x30	; 48
    85aa:	ba 01       	movw	r22, r20
    85ac:	0e 94 6f 25 	call	0x4ade	; 0x4ade <PGM_uBrokLine>
    85b0:	ac 01       	movw	r20, r24
    85b2:	0d c0       	rjmp	.+26     	; 0x85ce <Thermode+0x46>
#endif
		default:
			return Code;
		}
	else	// T_Fami==Thermoc
		switch(T_Type) {
    85b4:	61 30       	cpi	r22, 0x01	; 1
    85b6:	69 f0       	breq	.+26     	; 0x85d2 <Thermode+0x4a>
    85b8:	62 30       	cpi	r22, 0x02	; 2
    85ba:	49 f4       	brne	.+18     	; 0x85ce <Thermode+0x46>
		case TC_K:
			return .1851*Code;
#endif
#if	TerInput==ADC_Input
		case TC_B:
			return ThermCalc(TC_B_);
    85bc:	86 e0       	ldi	r24, 0x06	; 6
    85be:	91 e3       	ldi	r25, 0x31	; 49
    85c0:	ba 01       	movw	r22, r20
    85c2:	0e 94 6f 25 	call	0x4ade	; 0x4ade <PGM_uBrokLine>
    85c6:	ac 01       	movw	r20, r24
    85c8:	02 c0       	rjmp	.+4      	; 0x85ce <Thermode+0x46>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
int16_t
Thermode(uint8_t T_Fami, uint8_t T_Type, uint16_t Code)
{
	if (T_Type==ThermOff)
    85ca:	40 e0       	ldi	r20, 0x00	; 0
    85cc:	50 e8       	ldi	r21, 0x80	; 128
			return ThermCalc(TC_B_);
#endif
		default:
			return Code;
		}
}
    85ce:	ca 01       	movw	r24, r20
    85d0:	08 95       	ret
			return ThermCalc(TC_J_) + InnerTer;
		case TC_L:
			return ThermCalc(TC_L_) + InnerTer;
#else
		case TC_K:
			return .1851*Code;
    85d2:	ba 01       	movw	r22, r20
    85d4:	80 e0       	ldi	r24, 0x00	; 0
    85d6:	90 e0       	ldi	r25, 0x00	; 0
    85d8:	0e 94 3f 82 	call	0x1047e	; 0x1047e <__floatunsisf>
    85dc:	2b ed       	ldi	r18, 0xDB	; 219
    85de:	3a e8       	ldi	r19, 0x8A	; 138
    85e0:	4d e3       	ldi	r20, 0x3D	; 61
    85e2:	5e e3       	ldi	r21, 0x3E	; 62
    85e4:	0e 94 7c 82 	call	0x104f8	; 0x104f8 <__mulsf3>
    85e8:	0e 94 0f 87 	call	0x10e1e	; 0x10e1e <__fixsfsi>
    85ec:	ab 01       	movw	r20, r22
    85ee:	ef cf       	rjmp	.-34     	; 0x85ce <Thermode+0x46>
Thermode(uint8_t T_Fami, uint8_t T_Type, uint16_t Code)
{
	if (T_Type==ThermOff)
		return Therm_Off_Mark;
	if (T_Fami==Thermis)
		switch(T_Type) {
    85f0:	66 30       	cpi	r22, 0x06	; 6
    85f2:	39 f1       	breq	.+78     	; 0x8642 <Thermode+0xba>
    85f4:	66 30       	cpi	r22, 0x06	; 6
    85f6:	b8 f0       	brcs	.+46     	; 0x8626 <Thermode+0x9e>
    85f8:	67 30       	cpi	r22, 0x07	; 7
    85fa:	49 f7       	brne	.-46     	; 0x85ce <Thermode+0x46>
			return ThermCalc(Pt100);
#if	TerInput==ADC_Input
		case Gr21:
			return ThermCalc(Gr21);
		case Gr23:
			return ThermCalc(Gr23);
    85fc:	86 ee       	ldi	r24, 0xE6	; 230
    85fe:	90 e3       	ldi	r25, 0x30	; 48
    8600:	ba 01       	movw	r22, r20
    8602:	0e 94 6f 25 	call	0x4ade	; 0x4ade <PGM_uBrokLine>
    8606:	ac 01       	movw	r20, r24
    8608:	e2 cf       	rjmp	.-60     	; 0x85ce <Thermode+0x46>
		case TSM50:
			return ThermCalc(TSM50);
		case TSP100:
			return ThermCalc(TSP100);
		case TSP50:
			return ThermCalc(TSP50);
    860a:	86 e7       	ldi	r24, 0x76	; 118
    860c:	90 e3       	ldi	r25, 0x30	; 48
    860e:	ba 01       	movw	r22, r20
    8610:	0e 94 6f 25 	call	0x4ade	; 0x4ade <PGM_uBrokLine>
    8614:	ac 01       	movw	r20, r24
    8616:	db cf       	rjmp	.-74     	; 0x85ce <Thermode+0x46>
		case TSM100:
			return ThermCalc(TSM100);
		case TSM50:
			return ThermCalc(TSM50);
		case TSP100:
			return ThermCalc(TSP100);
    8618:	8e e4       	ldi	r24, 0x4E	; 78
    861a:	90 e3       	ldi	r25, 0x30	; 48
    861c:	ba 01       	movw	r22, r20
    861e:	0e 94 6f 25 	call	0x4ade	; 0x4ade <PGM_uBrokLine>
    8622:	ac 01       	movw	r20, r24
    8624:	d4 cf       	rjmp	.-88     	; 0x85ce <Thermode+0x46>
		case TSP50:
			return ThermCalc(TSP50);
		case Pt100:
			return ThermCalc(Pt100);
    8626:	8a e9       	ldi	r24, 0x9A	; 154
    8628:	90 e3       	ldi	r25, 0x30	; 48
    862a:	ba 01       	movw	r22, r20
    862c:	0e 94 6f 25 	call	0x4ade	; 0x4ade <PGM_uBrokLine>
    8630:	ac 01       	movw	r20, r24
    8632:	cd cf       	rjmp	.-102    	; 0x85ce <Thermode+0x46>
	if (T_Fami==Thermis)
		switch(T_Type) {
		case TSM100:
			return ThermCalc(TSM100);
		case TSM50:
			return ThermCalc(TSM50);
    8634:	82 e2       	ldi	r24, 0x22	; 34
    8636:	90 e3       	ldi	r25, 0x30	; 48
    8638:	ba 01       	movw	r22, r20
    863a:	0e 94 6f 25 	call	0x4ade	; 0x4ade <PGM_uBrokLine>
    863e:	ac 01       	movw	r20, r24
    8640:	c6 cf       	rjmp	.-116    	; 0x85ce <Thermode+0x46>
			return ThermCalc(TSP50);
		case Pt100:
			return ThermCalc(Pt100);
#if	TerInput==ADC_Input
		case Gr21:
			return ThermCalc(Gr21);
    8642:	82 ec       	ldi	r24, 0xC2	; 194
    8644:	90 e3       	ldi	r25, 0x30	; 48
    8646:	ba 01       	movw	r22, r20
    8648:	0e 94 6f 25 	call	0x4ade	; 0x4ade <PGM_uBrokLine>
    864c:	ac 01       	movw	r20, r24
    864e:	bf cf       	rjmp	.-130    	; 0x85ce <Thermode+0x46>

00008650 <ThermExt>:
			IntOff();
			Temperature[TerReg+i] = (Temperature_Ext)[i];
			IntOn();
		}
	#endif
}
    8650:	08 95       	ret

00008652 <Therm_ADC_Off>:

// ~~~~~~~~~~~~~~~~
void
Therm_ADC_Off(void)
{
	for (uint8_t i=0; i<TerReg; Temperature[i++]=ADC_Off_Mark);
    8652:	81 e0       	ldi	r24, 0x01	; 1
    8654:	90 e8       	ldi	r25, 0x80	; 128
    8656:	90 93 46 06 	sts	0x0646, r25
    865a:	80 93 45 06 	sts	0x0645, r24
    865e:	90 93 48 06 	sts	0x0648, r25
    8662:	80 93 47 06 	sts	0x0647, r24
    8666:	90 93 4a 06 	sts	0x064A, r25
    866a:	80 93 49 06 	sts	0x0649, r24
    866e:	90 93 4c 06 	sts	0x064C, r25
    8672:	80 93 4b 06 	sts	0x064B, r24
    8676:	90 93 4e 06 	sts	0x064E, r25
    867a:	80 93 4d 06 	sts	0x064D, r24
    867e:	90 93 50 06 	sts	0x0650, r25
    8682:	80 93 4f 06 	sts	0x064F, r24
}
    8686:	08 95       	ret

00008688 <ThermWrong>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
ThermWrong(uint8_t T_Fami, uint8_t T_Type, int16_t Ter)
{
	uint8_t TW = ThermNorm;
	if (T_Type!=ThermOff && T_Type<=prb(MaxThermType+T_Fami)) {
    8688:	66 23       	and	r22, r22
    868a:	31 f1       	breq	.+76     	; 0x86d8 <ThermWrong+0x50>
    868c:	28 2f       	mov	r18, r24
    868e:	30 e0       	ldi	r19, 0x00	; 0

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    8690:	f9 01       	movw	r30, r18
    8692:	e4 50       	subi	r30, 0x04	; 4
    8694:	f0 4d       	sbci	r31, 0xD0	; 208
    8696:	e4 91       	lpm	r30, Z+
    8698:	e6 17       	cp	r30, r22
    869a:	f0 f0       	brcs	.+60     	; 0x86d8 <ThermWrong+0x50>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    869c:	f9 01       	movw	r30, r18
    869e:	ee 0f       	add	r30, r30
    86a0:	ff 1f       	adc	r31, r31
    86a2:	e2 50       	subi	r30, 0x02	; 2
    86a4:	f0 4d       	sbci	r31, 0xD0	; 208
    86a6:	25 91       	lpm	r18, Z+
    86a8:	34 91       	lpm	r19, Z+
		TerLim *T_L = prp(TerLimType+T_Fami);
		if (Ter<(int16_t)prw(&T_L[T_Type].Low))
    86aa:	86 2f       	mov	r24, r22
    86ac:	90 e0       	ldi	r25, 0x00	; 0
    86ae:	88 0f       	add	r24, r24
    86b0:	99 1f       	adc	r25, r25
    86b2:	88 0f       	add	r24, r24
    86b4:	99 1f       	adc	r25, r25
    86b6:	28 0f       	add	r18, r24
    86b8:	39 1f       	adc	r19, r25

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    86ba:	f9 01       	movw	r30, r18
    86bc:	85 91       	lpm	r24, Z+
    86be:	94 91       	lpm	r25, Z+
    86c0:	48 17       	cp	r20, r24
    86c2:	59 07       	cpc	r21, r25
    86c4:	5c f0       	brlt	.+22     	; 0x86dc <ThermWrong+0x54>
    86c6:	f9 01       	movw	r30, r18
    86c8:	32 96       	adiw	r30, 0x02	; 2
    86ca:	85 91       	lpm	r24, Z+
    86cc:	94 91       	lpm	r25, Z+
			TW = ThermUnder;
		else if(Ter>(int16_t)prw(&T_L[T_Type].Upp))
    86ce:	84 17       	cp	r24, r20
    86d0:	95 07       	cpc	r25, r21
    86d2:	14 f4       	brge	.+4      	; 0x86d8 <ThermWrong+0x50>
    86d4:	82 e0       	ldi	r24, 0x02	; 2
    86d6:	08 95       	ret
    86d8:	80 e0       	ldi	r24, 0x00	; 0
			TW = ThermOver;
	}
	return TW;
}
    86da:	08 95       	ret
ThermWrong(uint8_t T_Fami, uint8_t T_Type, int16_t Ter)
{
	uint8_t TW = ThermNorm;
	if (T_Type!=ThermOff && T_Type<=prb(MaxThermType+T_Fami)) {
		TerLim *T_L = prp(TerLimType+T_Fami);
		if (Ter<(int16_t)prw(&T_L[T_Type].Low))
    86dc:	81 e0       	ldi	r24, 0x01	; 1
    86de:	08 95       	ret

000086e0 <Key_MB0_CPT_Clear>:
	{" BAUD: }}}}}bps     ", NULL, F_MB##N##_Baud}																														\
};																																																					\
MenuPage MenuModbus##N = {SetMenu(L_MB##N), 1};

#if Modbus_Qt == 1
	M_Modbus(0)
    86e0:	80 e0       	ldi	r24, 0x00	; 0
    86e2:	90 e0       	ldi	r25, 0x00	; 0

// ~~~~~~~~~~~~~~~~~~~~~~~
void
MB_CPT_Clear(uint8_t MB_N)
{
	for (uint8_t i=0; i<8; MB_CPT[MB_N][i++]=0);
    86e4:	fc 01       	movw	r30, r24
    86e6:	ee 0f       	add	r30, r30
    86e8:	ff 1f       	adc	r31, r31
    86ea:	ea 5c       	subi	r30, 0xCA	; 202
    86ec:	f6 4f       	sbci	r31, 0xF6	; 246
    86ee:	11 82       	std	Z+1, r1	; 0x01
    86f0:	10 82       	st	Z, r1
    86f2:	01 96       	adiw	r24, 0x01	; 1
    86f4:	88 30       	cpi	r24, 0x08	; 8
    86f6:	91 05       	cpc	r25, r1
    86f8:	a9 f7       	brne	.-22     	; 0x86e4 <Key_MB0_CPT_Clear+0x4>
    86fa:	81 e0       	ldi	r24, 0x01	; 1
    86fc:	08 95       	ret

000086fe <ResetGSMState>:
	#ifdef GSM_DEBUG
		MenuPage MenuGSMConsole;
	#endif

	void ResetGSMState(void){
		GSM_State = GSM_ReStart1;
    86fe:	8a e4       	ldi	r24, 0x4A	; 74
    8700:	80 93 f6 06 	sts	0x06F6, r24
	}
    8704:	08 95       	ret

00008706 <Key_MaxScanCycle_Clear>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
InField F_ScanCycle[] = { {Byte, &ScanCycle} };
InField F_ScanCyclePerSec[] = { {Word, &ScanPerSec} }; 
InField F_MaxScanCycle[] = {{Byte, &MaxScanCycle}};

uint8_t Key_MaxScanCycle_Clear(void) {if(CurrLine==3) MaxScanCycle_Clear(); return StandartKey;}
    8706:	80 91 ca 07 	lds	r24, 0x07CA
    870a:	83 30       	cpi	r24, 0x03	; 3
    870c:	11 f4       	brne	.+4      	; 0x8712 <Key_MaxScanCycle_Clear+0xc>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
void
MaxScanCycle_Clear(void)
{
	MaxScanCycle = 0;
    870e:	10 92 b1 06 	sts	0x06B1, r1
    8712:	80 e0       	ldi	r24, 0x00	; 0
    8714:	08 95       	ret

00008716 <Caller_StartCalling>:
uint8_t CallerBusyState;
uint8_t CallerMessage[2];
uint8_t CurrentAbonent;
uint8_t CurrentCall;
void Caller_StartCalling(uint8_t inputN){
	CallerMessage[0]=1;
    8716:	91 e0       	ldi	r25, 0x01	; 1
    8718:	90 93 b6 07 	sts	0x07B6, r25
	CallerMessage[1]=inputN;
    871c:	80 93 b7 07 	sts	0x07B7, r24
	CallerBusyState = 1;
    8720:	90 93 c4 07 	sts	0x07C4, r25
}
    8724:	08 95       	ret

00008726 <CallerCycle>:

void CallerCycle(){
	
	switch(Caller_state){
    8726:	80 91 e4 02 	lds	r24, 0x02E4
    872a:	81 30       	cpi	r24, 0x01	; 1
    872c:	49 f1       	breq	.+82     	; 0x8780 <CallerCycle+0x5a>
    872e:	81 30       	cpi	r24, 0x01	; 1
    8730:	80 f4       	brcc	.+32     	; 0x8752 <CallerCycle+0x2c>
		case CALLER_IDLE:
			if(0 != CallerMessage[0]){
    8732:	80 91 b6 07 	lds	r24, 0x07B6
    8736:	88 23       	and	r24, r24
    8738:	81 f1       	breq	.+96     	; 0x879a <CallerCycle+0x74>
				CallerMessage[0] = 0;
    873a:	10 92 b6 07 	sts	0x07B6, r1
				CurrentAbonent = 0;
    873e:	10 92 38 07 	sts	0x0738, r1
				CurrentCall = 0;
    8742:	10 92 da 07 	sts	0x07DA, r1
				CallerBusyState = 1;
    8746:	81 e0       	ldi	r24, 0x01	; 1
    8748:	80 93 c4 07 	sts	0x07C4, r24
				Caller_state = CHECK_PHONE_BUSY;
    874c:	80 93 e4 02 	sts	0x02E4, r24
    8750:	08 95       	ret
	CallerBusyState = 1;
}

void CallerCycle(){
	
	switch(Caller_state){
    8752:	82 30       	cpi	r24, 0x02	; 2
    8754:	09 f0       	breq	.+2      	; 0x8758 <CallerCycle+0x32>
    8756:	08 95       	ret
					break;
				}
			}
			break;
		case CALLER_ARBITR:
			GSM_StartCalling(CurrentAbonent,CallerMessage[1]);
    8758:	90 91 38 07 	lds	r25, 0x0738
    875c:	80 91 b7 07 	lds	r24, 0x07B7
uint8_t numOfCheckBallanceRetry=0;

uint8_t Message[3];  // 
uint8_t GSMBusyState=0; // " " 0 -  , 1 -  
void GSM_StartCalling(uint8_t inputN,uint8_t abonentN){
	Message[0]=1;
    8760:	21 e0       	ldi	r18, 0x01	; 1
    8762:	20 93 35 07 	sts	0x0735, r18
	Message[1]=inputN;
    8766:	90 93 36 07 	sts	0x0736, r25
	Message[2]=abonentN;
    876a:	80 93 37 07 	sts	0x0737, r24
			if(CurrentCall<2){
    876e:	80 91 da 07 	lds	r24, 0x07DA
    8772:	82 30       	cpi	r24, 0x02	; 2
    8774:	c8 f0       	brcs	.+50     	; 0x87a8 <CallerCycle+0x82>
				CurrentCall++;
				Caller_state = CHECK_PHONE_BUSY;
				break;
			}
			else{
			 if(CurrentAbonent<MaxTelephDirSz-1){
    8776:	92 30       	cpi	r25, 0x02	; 2
    8778:	e8 f0       	brcs	.+58     	; 0x87b4 <CallerCycle+0x8e>
				CurrentCall = 0;
				Caller_state = CHECK_PHONE_BUSY;
				break;
			 }
			 else{
			 	Caller_state = CALLER_IDLE;
    877a:	10 92 e4 02 	sts	0x02E4, r1
    877e:	08 95       	ret
				break;
			}
			CallerBusyState = 0;
			break;
		case CHECK_PHONE_BUSY:
			if(0 == TransmitterState){
    8780:	80 91 e3 02 	lds	r24, 0x02E3
    8784:	88 23       	and	r24, r24
    8786:	61 f0       	breq	.+24     	; 0x87a0 <CallerCycle+0x7a>
}
uint8_t ConfirmState = 0;
uint8_t RequestRepeatCounter = 0;
uint8_t TransmitterState = 0;
uint8_t GSM_GetConfirmState(){
	if(1 == ConfirmState){
    8788:	80 91 e1 02 	lds	r24, 0x02E1
    878c:	81 30       	cpi	r24, 0x01	; 1
    878e:	19 f7       	brne	.-58     	; 0x8756 <CallerCycle+0x30>
		ConfirmState = 0;
    8790:	10 92 e1 02 	sts	0x02E1, r1
				Caller_state = CALLER_ARBITR;
				break;
			}else 
			{
				if(1 == GSM_GetConfirmState()){
					Caller_state = CALLER_IDLE;
    8794:	10 92 e4 02 	sts	0x02E4, r1
    8798:	08 95       	ret
				CurrentCall = 0;
				CallerBusyState = 1;
				Caller_state = CHECK_PHONE_BUSY;
				break;
			}
			CallerBusyState = 0;
    879a:	10 92 c4 07 	sts	0x07C4, r1
    879e:	08 95       	ret
			break;
		case CHECK_PHONE_BUSY:
			if(0 == TransmitterState){
				Caller_state = CALLER_ARBITR;
    87a0:	82 e0       	ldi	r24, 0x02	; 2
    87a2:	80 93 e4 02 	sts	0x02E4, r24
    87a6:	08 95       	ret
			}
			break;
		case CALLER_ARBITR:
			GSM_StartCalling(CurrentAbonent,CallerMessage[1]);
			if(CurrentCall<2){
				CurrentCall++;
    87a8:	8f 5f       	subi	r24, 0xFF	; 255
    87aa:	80 93 da 07 	sts	0x07DA, r24
				Caller_state = CHECK_PHONE_BUSY;
    87ae:	20 93 e4 02 	sts	0x02E4, r18
    87b2:	08 95       	ret
				break;
			}
			else{
			 if(CurrentAbonent<MaxTelephDirSz-1){
			 	CurrentAbonent++;
    87b4:	9f 5f       	subi	r25, 0xFF	; 255
    87b6:	90 93 38 07 	sts	0x0738, r25
				CurrentCall = 0;
    87ba:	10 92 da 07 	sts	0x07DA, r1
				Caller_state = CHECK_PHONE_BUSY;
    87be:	20 93 e4 02 	sts	0x02E4, r18
    87c2:	08 95       	ret

000087c4 <ApplInit>:

}

void
ApplInit(void)
{
    87c4:	20 91 cd 02 	lds	r18, 0x02CD
    87c8:	e6 eb       	ldi	r30, 0xB6	; 182
    87ca:	f6 e0       	ldi	r31, 0x06	; 6
    87cc:	92 2f       	mov	r25, r18
    87ce:	81 e0       	ldi	r24, 0x01	; 1
	for(int i=0; i<16; i++){
		Channels[i].number = i+1;
    87d0:	80 83       	st	Z, r24
		Channels[i].timer = Timer16Alloc();
    87d2:	93 83       	std	Z+3, r25	; 0x03
    87d4:	9f 5f       	subi	r25, 0xFF	; 255
    87d6:	34 96       	adiw	r30, 0x04	; 4
    87d8:	8f 5f       	subi	r24, 0xFF	; 255
}

void
ApplInit(void)
{
	for(int i=0; i<16; i++){
    87da:	81 31       	cpi	r24, 0x11	; 17
    87dc:	c9 f7       	brne	.-14     	; 0x87d0 <ApplInit+0xc>
    87de:	20 5f       	subi	r18, 0xF0	; 240
    87e0:	20 93 cd 02 	sts	0x02CD, r18
		Channels[i].number = i+1;
		Channels[i].timer = Timer16Alloc();
	}

}
    87e4:	08 95       	ret

000087e6 <StartKey>:
// ~~~~~~~~~~~
void
StartKey(void)
{	
	
}
    87e6:	08 95       	ret

000087e8 <StopKey>:
// ~~~~~~~~~~
void
StopKey(void)
{
	
}
    87e8:	08 95       	ret

000087ea <Menu_ConfirmationRest_Enter>:
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	//		   
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	uint8_t Menu_ConfirmationRest_Enter(){

		eeprom_write_byte((uint8_t*)E2END, 0xBB);
    87ea:	8f ef       	ldi	r24, 0xFF	; 255
    87ec:	9f e0       	ldi	r25, 0x0F	; 15
    87ee:	6b eb       	ldi	r22, 0xBB	; 187
    87f0:	0e 94 6e 87 	call	0x10edc	; 0x10edc <__eewr_byte_m2560>
		eeprom_write_byte(&MemCheck_stor.ReprogFlg, 0);
    87f4:	8c e9       	ldi	r24, 0x9C	; 156
    87f6:	91 e0       	ldi	r25, 0x01	; 1
    87f8:	60 e0       	ldi	r22, 0x00	; 0
    87fa:	0e 94 6e 87 	call	0x10edc	; 0x10edc <__eewr_byte_m2560>
    87fe:	ff cf       	rjmp	.-2      	; 0x87fe <Menu_ConfirmationRest_Enter+0x14>

00008800 <Menu_ConfirmationSave_Enter>:
	//		   
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	uint8_t Menu_ConfirmationSave_Enter(){

		//  backup-
		eeprom_write_byte((uint8_t*)E2END, 0xAA);
    8800:	8f ef       	ldi	r24, 0xFF	; 255
    8802:	9f e0       	ldi	r25, 0x0F	; 15
    8804:	6a ea       	ldi	r22, 0xAA	; 170
    8806:	0e 94 6e 87 	call	0x10edc	; 0x10edc <__eewr_byte_m2560>
		eeprom_write_byte(&DateBackUp.Day, Tm_MDay);
    880a:	80 e0       	ldi	r24, 0x00	; 0
    880c:	90 e0       	ldi	r25, 0x00	; 0
    880e:	60 91 5f 0b 	lds	r22, 0x0B5F
    8812:	0e 94 6e 87 	call	0x10edc	; 0x10edc <__eewr_byte_m2560>
		eeprom_write_byte(&DateBackUp.Month, Tm_Mon);
    8816:	81 e0       	ldi	r24, 0x01	; 1
    8818:	90 e0       	ldi	r25, 0x00	; 0
    881a:	60 91 cc 07 	lds	r22, 0x07CC
    881e:	0e 94 6e 87 	call	0x10edc	; 0x10edc <__eewr_byte_m2560>
		#ifdef M41T56
			eeprom_write_byte(&DateBackUp.Year, Tm_Year);
    8822:	82 e0       	ldi	r24, 0x02	; 2
    8824:	90 e0       	ldi	r25, 0x00	; 0
    8826:	60 91 de 05 	lds	r22, 0x05DE
    882a:	0e 94 6e 87 	call	0x10edc	; 0x10edc <__eewr_byte_m2560>
		#else
			eeprom_write_byte(&DateBackUp.Year, erb(&Tm_Year));
		#endif
		eeprom_write_byte(&MemCheck_stor.ReprogFlg, 0);
    882e:	8c e9       	ldi	r24, 0x9C	; 156
    8830:	91 e0       	ldi	r25, 0x01	; 1
    8832:	60 e0       	ldi	r22, 0x00	; 0
    8834:	0e 94 6e 87 	call	0x10edc	; 0x10edc <__eewr_byte_m2560>
    8838:	ff cf       	rjmp	.-2      	; 0x8838 <Menu_ConfirmationSave_Enter+0x38>

0000883a <GSM_SendData>:
	GSMTxSz = Size;
	memcpy(GSM_TxStr, Data_Out, GSMTxSz);
	GSM_SendFirstChar();
}
// ~~~~~~~~~
void GSM_SendData(uint8_t *Data_Out, uint8_t Size){
    883a:	58 2f       	mov	r21, r24
    883c:	79 2f       	mov	r23, r25
	GSMTxSz = Size;
    883e:	60 93 bb 07 	sts	0x07BB, r22
	memcpy(GSM_TxStr, Data_Out, GSMTxSz);
    8842:	40 91 bb 07 	lds	r20, 0x07BB
    8846:	2a e4       	ldi	r18, 0x4A	; 74
    8848:	3a e0       	ldi	r19, 0x0A	; 10
    884a:	c9 01       	movw	r24, r18
    884c:	65 2f       	mov	r22, r21
    884e:	50 e0       	ldi	r21, 0x00	; 0
    8850:	0e 94 72 84 	call	0x108e4	; 0x108e4 <memcpy>
	GSM_SendFirstChar();
    8854:	0e 94 28 3d 	call	0x7a50	; 0x7a50 <GSM_SendFirstChar>
}
    8858:	08 95       	ret

0000885a <GSM_AddHeaderSendData>:
	GSMTxSz++;
	GSM_SendFirstChar();
}
// ~~~~~~~~~
//   + CntrZ
void GSM_AddHeaderSendData(uint8_t *Data_Out, uint8_t Size){
    885a:	58 2f       	mov	r21, r24
    885c:	79 2f       	mov	r23, r25
	GSMTxSz = Size;
    885e:	60 93 bb 07 	sts	0x07BB, r22
	memcpy(GSM_TxStr, Data_Out, GSMTxSz);
    8862:	40 91 bb 07 	lds	r20, 0x07BB
    8866:	2a e4       	ldi	r18, 0x4A	; 74
    8868:	3a e0       	ldi	r19, 0x0A	; 10
    886a:	c9 01       	movw	r24, r18
    886c:	65 2f       	mov	r22, r21
    886e:	50 e0       	ldi	r21, 0x00	; 0
    8870:	0e 94 72 84 	call	0x108e4	; 0x108e4 <memcpy>
	GSM_SendFirstChar();
    8874:	0e 94 28 3d 	call	0x7a50	; 0x7a50 <GSM_SendFirstChar>
}
    8878:	08 95       	ret

0000887a <PresicionHanler>:
		ew##ty3((ty2*)Var, Min);						\
	else																	\
		ew##ty3((ty2*)Var, (ty2)Buf)
// ~~~~~~~~~~~~~~~~~~~~~~~
//Change BufStr due to precision for correct sscanf reading BufStr
void PresicionHanler(OutField *Field){
    887a:	cf 93       	push	r28
    887c:	df 93       	push	r29

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    887e:	ec 01       	movw	r28, r24
    8880:	2f 96       	adiw	r28, 0x0f	; 15
    8882:	fe 01       	movw	r30, r28
    8884:	84 91       	lpm	r24, Z+
	if(prb(&Field->Prec)){
    8886:	88 23       	and	r24, r24
    8888:	19 f4       	brne	.+6      	; 0x8890 <PresicionHanler+0x16>
			}
			p++;
		}
	}
	
}
    888a:	df 91       	pop	r29
    888c:	cf 91       	pop	r28
    888e:	08 95       	ret
		ew##ty3((ty2*)Var, (ty2)Buf)
// ~~~~~~~~~~~~~~~~~~~~~~~
//Change BufStr due to precision for correct sscanf reading BufStr
void PresicionHanler(OutField *Field){
	if(prb(&Field->Prec)){
		char *p = strchr(BufStr,'.');	//seek for first decimal point
    8890:	83 ec       	ldi	r24, 0xC3	; 195
    8892:	95 e0       	ldi	r25, 0x05	; 5
    8894:	6e e2       	ldi	r22, 0x2E	; 46
    8896:	70 e0       	ldi	r23, 0x00	; 0
    8898:	0e 94 7b 84 	call	0x108f6	; 0x108f6 <strchr>
		if(p==NULL){
    889c:	00 97       	sbiw	r24, 0x00	; 0
    889e:	01 f1       	breq	.+64     	; 0x88e0 <PresicionHanler+0x66>
    88a0:	fe 01       	movw	r30, r28
    88a2:	24 91       	lpm	r18, Z+
			p = strchr(BufStr,' ');	//else seek for first space
		}
	  	for(uint8_t i=0; i<prb(&Field->Prec); i++){
    88a4:	22 23       	and	r18, r18
    88a6:	89 f3       	breq	.-30     	; 0x888a <PresicionHanler+0x10>
    88a8:	fc 01       	movw	r30, r24
    88aa:	dc 01       	movw	r26, r24
    88ac:	11 96       	adiw	r26, 0x01	; 1
    88ae:	30 e0       	ldi	r19, 0x00	; 0
			if(*p == '.'){
				if(isdigit(*(p+1))){
					*p= *(p+1);
					*(p+1) = '.';
				}
				else *p='0'; 
    88b0:	60 e3       	ldi	r22, 0x30	; 48
    88b2:	52 2f       	mov	r21, r18
    88b4:	07 c0       	rjmp	.+14     	; 0x88c4 <PresicionHanler+0x4a>
		if(p==NULL){
			p = strchr(BufStr,' ');	//else seek for first space
		}
	  	for(uint8_t i=0; i<prb(&Field->Prec); i++){
			if(*p == ' ') *p='0'; 
			if(*p == '.'){
    88b6:	2e 32       	cpi	r18, 0x2E	; 46
    88b8:	51 f0       	breq	.+20     	; 0x88ce <PresicionHanler+0x54>
	if(prb(&Field->Prec)){
		char *p = strchr(BufStr,'.');	//seek for first decimal point
		if(p==NULL){
			p = strchr(BufStr,' ');	//else seek for first space
		}
	  	for(uint8_t i=0; i<prb(&Field->Prec); i++){
    88ba:	3f 5f       	subi	r19, 0xFF	; 255
    88bc:	31 96       	adiw	r30, 0x01	; 1
    88be:	11 96       	adiw	r26, 0x01	; 1
    88c0:	35 17       	cp	r19, r21
    88c2:	18 f7       	brcc	.-58     	; 0x888a <PresicionHanler+0x10>
			if(*p == ' ') *p='0'; 
    88c4:	20 81       	ld	r18, Z
    88c6:	20 32       	cpi	r18, 0x20	; 32
    88c8:	b1 f7       	brne	.-20     	; 0x88b6 <PresicionHanler+0x3c>
			if(*p == '.'){
				if(isdigit(*(p+1))){
					*p= *(p+1);
					*(p+1) = '.';
				}
				else *p='0'; 
    88ca:	60 83       	st	Z, r22
    88cc:	f6 cf       	rjmp	.-20     	; 0x88ba <PresicionHanler+0x40>
			p = strchr(BufStr,' ');	//else seek for first space
		}
	  	for(uint8_t i=0; i<prb(&Field->Prec); i++){
			if(*p == ' ') *p='0'; 
			if(*p == '.'){
				if(isdigit(*(p+1))){
    88ce:	4c 91       	ld	r20, X
    88d0:	84 2f       	mov	r24, r20
    88d2:	90 e0       	ldi	r25, 0x00	; 0
    88d4:	c0 97       	sbiw	r24, 0x30	; 48
    88d6:	0a 97       	sbiw	r24, 0x0a	; 10
    88d8:	c0 f7       	brcc	.-16     	; 0x88ca <PresicionHanler+0x50>
					*p= *(p+1);
    88da:	40 83       	st	Z, r20
					*(p+1) = '.';
    88dc:	2c 93       	st	X, r18
    88de:	ed cf       	rjmp	.-38     	; 0x88ba <PresicionHanler+0x40>
//Change BufStr due to precision for correct sscanf reading BufStr
void PresicionHanler(OutField *Field){
	if(prb(&Field->Prec)){
		char *p = strchr(BufStr,'.');	//seek for first decimal point
		if(p==NULL){
			p = strchr(BufStr,' ');	//else seek for first space
    88e0:	83 ec       	ldi	r24, 0xC3	; 195
    88e2:	95 e0       	ldi	r25, 0x05	; 5
    88e4:	60 e2       	ldi	r22, 0x20	; 32
    88e6:	70 e0       	ldi	r23, 0x00	; 0
    88e8:	0e 94 7b 84 	call	0x108f6	; 0x108f6 <strchr>
    88ec:	d9 cf       	rjmp	.-78     	; 0x88a0 <PresicionHanler+0x26>

000088ee <GetMultiSymbol>:
	}
	return 0;
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~
//    MultiSymbol   
uint8_t GetMultiSymbol(PGM_P Str_P, char Char){
    88ee:	1f 93       	push	r17
    88f0:	18 2f       	mov	r17, r24
	PGM_P ptr_P= strchr_P(Str_P, Char);
    88f2:	70 e0       	ldi	r23, 0x00	; 0
    88f4:	0e 94 1b 84 	call	0x10836	; 0x10836 <strchr_P>
	if(ptr_P) return (uint8_t)(ptr_P - Str_P);
    88f8:	00 97       	sbiw	r24, 0x00	; 0
    88fa:	19 f0       	breq	.+6      	; 0x8902 <GetMultiSymbol+0x14>
    88fc:	81 1b       	sub	r24, r17
	else return 0;
}
    88fe:	1f 91       	pop	r17
    8900:	08 95       	ret
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~
//    MultiSymbol   
uint8_t GetMultiSymbol(PGM_P Str_P, char Char){
	PGM_P ptr_P= strchr_P(Str_P, Char);
	if(ptr_P) return (uint8_t)(ptr_P - Str_P);
    8902:	80 e0       	ldi	r24, 0x00	; 0
	else return 0;
}
    8904:	1f 91       	pop	r17
    8906:	08 95       	ret

00008908 <PutEnum>:
} T_Param;

// ~~~~~~~~~~~~~~~~~~~~
void
PutEnum(T_Param *Param)
{
    8908:	0f 93       	push	r16
    890a:	1f 93       	push	r17
    890c:	cf 93       	push	r28
    890e:	df 93       	push	r29
    8910:	8c 01       	movw	r16, r24

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    8912:	dc 01       	movw	r26, r24
    8914:	14 96       	adiw	r26, 0x04	; 4
    8916:	ed 91       	ld	r30, X+
    8918:	fc 91       	ld	r31, X
    891a:	15 97       	sbiw	r26, 0x05	; 5
    891c:	65 91       	lpm	r22, Z+
    891e:	74 91       	lpm	r23, Z+
	strcpy_P(Param->Pos, prp(Param->Txt));
    8920:	8d 91       	ld	r24, X+
    8922:	9c 91       	ld	r25, X
    8924:	0e 94 2f 84 	call	0x1085e	; 0x1085e <strcpy_P>
	for(uint8_t i=strlen(Param->Pos); i<Param->Size; *(Param->Pos+i++)=' ');
    8928:	f8 01       	movw	r30, r16
    892a:	c0 81       	ld	r28, Z
    892c:	d1 81       	ldd	r29, Z+1	; 0x01
    892e:	fe 01       	movw	r30, r28
    8930:	01 90       	ld	r0, Z+
    8932:	00 20       	and	r0, r0
    8934:	e9 f7       	brne	.-6      	; 0x8930 <PutEnum+0x28>
    8936:	31 97       	sbiw	r30, 0x01	; 1
    8938:	ec 1b       	sub	r30, r28
    893a:	d8 01       	movw	r26, r16
    893c:	13 96       	adiw	r26, 0x03	; 3
    893e:	8c 91       	ld	r24, X
    8940:	e8 17       	cp	r30, r24
    8942:	70 f4       	brcc	.+28     	; 0x8960 <PutEnum+0x58>
    8944:	90 e2       	ldi	r25, 0x20	; 32
    8946:	02 c0       	rjmp	.+4      	; 0x894c <PutEnum+0x44>
    8948:	cd 91       	ld	r28, X+
    894a:	dc 91       	ld	r29, X
    894c:	ce 0f       	add	r28, r30
    894e:	d1 1d       	adc	r29, r1
    8950:	98 83       	st	Y, r25
    8952:	ef 5f       	subi	r30, 0xFF	; 255
    8954:	d8 01       	movw	r26, r16
    8956:	13 96       	adiw	r26, 0x03	; 3
    8958:	8c 91       	ld	r24, X
    895a:	13 97       	sbiw	r26, 0x03	; 3
    895c:	e8 17       	cp	r30, r24
    895e:	a0 f3       	brcs	.-24     	; 0x8948 <PutEnum+0x40>
}
    8960:	df 91       	pop	r29
    8962:	cf 91       	pop	r28
    8964:	1f 91       	pop	r17
    8966:	0f 91       	pop	r16
    8968:	08 95       	ret

0000896a <Put_sbVal>:
}

// ~~~~~~~~~~~~~~~~~~~~~~
void
Put_sbVal(T_Param *Param)
{
    896a:	6f 92       	push	r6
    896c:	7f 92       	push	r7
    896e:	8f 92       	push	r8
    8970:	9f 92       	push	r9
    8972:	af 92       	push	r10
    8974:	bf 92       	push	r11
    8976:	cf 92       	push	r12
    8978:	df 92       	push	r13
    897a:	ef 92       	push	r14
    897c:	ff 92       	push	r15
    897e:	0f 93       	push	r16
    8980:	1f 93       	push	r17
    8982:	df 93       	push	r29
    8984:	cf 93       	push	r28
    8986:	cd b7       	in	r28, 0x3d	; 61
    8988:	de b7       	in	r29, 0x3e	; 62
    898a:	2c 97       	sbiw	r28, 0x0c	; 12
    898c:	0f b6       	in	r0, 0x3f	; 63
    898e:	f8 94       	cli
    8990:	de bf       	out	0x3e, r29	; 62
    8992:	0f be       	out	0x3f, r0	; 63
    8994:	cd bf       	out	0x3d, r28	; 61
    8996:	5c 01       	movw	r10, r24
	char Format[] = "%0+ li.%. u";
    8998:	be 01       	movw	r22, r28
    899a:	6f 5f       	subi	r22, 0xFF	; 255
    899c:	7f 4f       	sbci	r23, 0xFF	; 255
    899e:	db 01       	movw	r26, r22
    89a0:	e0 e0       	ldi	r30, 0x00	; 0
    89a2:	f2 e0       	ldi	r31, 0x02	; 2
    89a4:	8c e0       	ldi	r24, 0x0C	; 12
    89a6:	01 90       	ld	r0, Z+
    89a8:	0d 92       	st	X+, r0
    89aa:	81 50       	subi	r24, 0x01	; 1
    89ac:	e1 f7       	brne	.-8      	; 0x89a6 <Put_sbVal+0x3c>
	Format[3] = '0'+Param->Size;
    89ae:	d5 01       	movw	r26, r10
    89b0:	13 96       	adiw	r26, 0x03	; 3
    89b2:	2c 91       	ld	r18, X
    89b4:	13 97       	sbiw	r26, 0x03	; 3
    89b6:	20 5d       	subi	r18, 0xD0	; 208
    89b8:	2c 83       	std	Y+4, r18	; 0x04
	if(Param->Prec) {
    89ba:	12 96       	adiw	r26, 0x02	; 2
    89bc:	9c 91       	ld	r25, X
    89be:	99 23       	and	r25, r25
    89c0:	09 f4       	brne	.+2      	; 0x89c4 <Put_sbVal+0x5a>
    89c2:	8d c0       	rjmp	.+282    	; 0x8ade <Put_sbVal+0x174>
		Format[3] -= Param->Prec+1;
    89c4:	89 2f       	mov	r24, r25
    89c6:	80 95       	com	r24
    89c8:	82 0f       	add	r24, r18
    89ca:	8c 83       	std	Y+4, r24	; 0x04
		Format[9] = '0'+Param->Prec;
    89cc:	90 5d       	subi	r25, 0xD0	; 208
    89ce:	9a 87       	std	Y+10, r25	; 0x0a
    89d0:	90 53       	subi	r25, 0x30	; 48
		int16_t Div=Pow10(Param->Prec);
    89d2:	49 2f       	mov	r20, r25
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    89d4:	21 e0       	ldi	r18, 0x01	; 1
    89d6:	30 e0       	ldi	r19, 0x00	; 0
		Pow *= 10;
    89d8:	c9 01       	movw	r24, r18
    89da:	88 0f       	add	r24, r24
    89dc:	99 1f       	adc	r25, r25
    89de:	22 0f       	add	r18, r18
    89e0:	33 1f       	adc	r19, r19
    89e2:	22 0f       	add	r18, r18
    89e4:	33 1f       	adc	r19, r19
    89e6:	22 0f       	add	r18, r18
    89e8:	33 1f       	adc	r19, r19
    89ea:	28 0f       	add	r18, r24
    89ec:	39 1f       	adc	r19, r25
    89ee:	41 50       	subi	r20, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    89f0:	99 f7       	brne	.-26     	; 0x89d8 <Put_sbVal+0x6e>
    89f2:	39 01       	movw	r6, r18
    89f4:	88 24       	eor	r8, r8
    89f6:	77 fc       	sbrc	r7, 7
    89f8:	80 94       	com	r8
    89fa:	98 2c       	mov	r9, r8
		sprintf(Param->Pos, Format, sF_Buf/Div, (uint32_t)labs(sF_Buf)%Div);
    89fc:	10 91 fb 04 	lds	r17, 0x04FB
    8a00:	00 91 fc 04 	lds	r16, 0x04FC
    8a04:	f0 90 fd 04 	lds	r15, 0x04FD
    8a08:	e0 90 fe 04 	lds	r14, 0x04FE
    8a0c:	ed b7       	in	r30, 0x3d	; 61
    8a0e:	fe b7       	in	r31, 0x3e	; 62
    8a10:	3c 97       	sbiw	r30, 0x0c	; 12
    8a12:	0f b6       	in	r0, 0x3f	; 63
    8a14:	f8 94       	cli
    8a16:	fe bf       	out	0x3e, r31	; 62
    8a18:	0f be       	out	0x3f, r0	; 63
    8a1a:	ed bf       	out	0x3d, r30	; 61
    8a1c:	cd b6       	in	r12, 0x3d	; 61
    8a1e:	de b6       	in	r13, 0x3e	; 62
    8a20:	08 94       	sec
    8a22:	c1 1c       	adc	r12, r1
    8a24:	d1 1c       	adc	r13, r1
    8a26:	d5 01       	movw	r26, r10
    8a28:	8d 91       	ld	r24, X+
    8a2a:	9c 91       	ld	r25, X
    8a2c:	92 83       	std	Z+2, r25	; 0x02
    8a2e:	81 83       	std	Z+1, r24	; 0x01
    8a30:	f6 01       	movw	r30, r12
    8a32:	73 83       	std	Z+3, r23	; 0x03
    8a34:	62 83       	std	Z+2, r22	; 0x02
    8a36:	61 2f       	mov	r22, r17
    8a38:	70 2f       	mov	r23, r16
    8a3a:	8f 2d       	mov	r24, r15
    8a3c:	9e 2d       	mov	r25, r14
    8a3e:	a4 01       	movw	r20, r8
    8a40:	93 01       	movw	r18, r6
    8a42:	0e 94 00 88 	call	0x11000	; 0x11000 <__divmodsi4>
    8a46:	d6 01       	movw	r26, r12
    8a48:	14 96       	adiw	r26, 0x04	; 4
    8a4a:	2d 93       	st	X+, r18
    8a4c:	3d 93       	st	X+, r19
    8a4e:	4d 93       	st	X+, r20
    8a50:	5c 93       	st	X, r21
    8a52:	17 97       	sbiw	r26, 0x07	; 7
    8a54:	21 2f       	mov	r18, r17
    8a56:	30 2f       	mov	r19, r16
    8a58:	4f 2d       	mov	r20, r15
    8a5a:	5e 2d       	mov	r21, r14
    8a5c:	c9 01       	movw	r24, r18
    8a5e:	da 01       	movw	r26, r20
    8a60:	bc 01       	movw	r22, r24
    8a62:	cd 01       	movw	r24, r26
    8a64:	97 fd       	sbrc	r25, 7
    8a66:	77 c0       	rjmp	.+238    	; 0x8b56 <Put_sbVal+0x1ec>
    8a68:	a4 01       	movw	r20, r8
    8a6a:	93 01       	movw	r18, r6
    8a6c:	0e 94 de 87 	call	0x10fbc	; 0x10fbc <__udivmodsi4>
    8a70:	f6 01       	movw	r30, r12
    8a72:	60 87       	std	Z+8, r22	; 0x08
    8a74:	71 87       	std	Z+9, r23	; 0x09
    8a76:	82 87       	std	Z+10, r24	; 0x0a
    8a78:	93 87       	std	Z+11, r25	; 0x0b
    8a7a:	0e 94 22 85 	call	0x10a44	; 0x10a44 <sprintf>
		if(sF_Buf<0) {
    8a7e:	8d b7       	in	r24, 0x3d	; 61
    8a80:	9e b7       	in	r25, 0x3e	; 62
    8a82:	0c 96       	adiw	r24, 0x0c	; 12
    8a84:	0f b6       	in	r0, 0x3f	; 63
    8a86:	f8 94       	cli
    8a88:	9e bf       	out	0x3e, r25	; 62
    8a8a:	0f be       	out	0x3f, r0	; 63
    8a8c:	8d bf       	out	0x3d, r24	; 61
    8a8e:	80 91 fb 04 	lds	r24, 0x04FB
    8a92:	90 91 fc 04 	lds	r25, 0x04FC
    8a96:	a0 91 fd 04 	lds	r26, 0x04FD
    8a9a:	b0 91 fe 04 	lds	r27, 0x04FE
    8a9e:	b7 fd       	sbrc	r27, 7
    8aa0:	4a c0       	rjmp	.+148    	; 0x8b36 <Put_sbVal+0x1cc>
	}
	else {
		Format[6] = '\0';
		sprintf(Param->Pos, Format, sF_Buf);
	}
	if(Minus)
    8aa2:	80 91 ff 04 	lds	r24, 0x04FF
    8aa6:	88 23       	and	r24, r24
    8aa8:	29 f0       	breq	.+10     	; 0x8ab4 <Put_sbVal+0x14a>
		*Param->Pos = '-';
    8aaa:	d5 01       	movw	r26, r10
    8aac:	ed 91       	ld	r30, X+
    8aae:	fc 91       	ld	r31, X
    8ab0:	8d e2       	ldi	r24, 0x2D	; 45
    8ab2:	80 83       	st	Z, r24
}
    8ab4:	2c 96       	adiw	r28, 0x0c	; 12
    8ab6:	0f b6       	in	r0, 0x3f	; 63
    8ab8:	f8 94       	cli
    8aba:	de bf       	out	0x3e, r29	; 62
    8abc:	0f be       	out	0x3f, r0	; 63
    8abe:	cd bf       	out	0x3d, r28	; 61
    8ac0:	cf 91       	pop	r28
    8ac2:	df 91       	pop	r29
    8ac4:	1f 91       	pop	r17
    8ac6:	0f 91       	pop	r16
    8ac8:	ff 90       	pop	r15
    8aca:	ef 90       	pop	r14
    8acc:	df 90       	pop	r13
    8ace:	cf 90       	pop	r12
    8ad0:	bf 90       	pop	r11
    8ad2:	af 90       	pop	r10
    8ad4:	9f 90       	pop	r9
    8ad6:	8f 90       	pop	r8
    8ad8:	7f 90       	pop	r7
    8ada:	6f 90       	pop	r6
    8adc:	08 95       	ret
				Param->Pos++;
			*Param->Pos = '-';
		}
	}
	else {
		Format[6] = '\0';
    8ade:	1f 82       	std	Y+7, r1	; 0x07
		sprintf(Param->Pos, Format, sF_Buf);
    8ae0:	ed b7       	in	r30, 0x3d	; 61
    8ae2:	fe b7       	in	r31, 0x3e	; 62
    8ae4:	38 97       	sbiw	r30, 0x08	; 8
    8ae6:	0f b6       	in	r0, 0x3f	; 63
    8ae8:	f8 94       	cli
    8aea:	fe bf       	out	0x3e, r31	; 62
    8aec:	0f be       	out	0x3f, r0	; 63
    8aee:	ed bf       	out	0x3d, r30	; 61
    8af0:	31 96       	adiw	r30, 0x01	; 1
    8af2:	d5 01       	movw	r26, r10
    8af4:	8d 91       	ld	r24, X+
    8af6:	9c 91       	ld	r25, X
    8af8:	ad b7       	in	r26, 0x3d	; 61
    8afa:	be b7       	in	r27, 0x3e	; 62
    8afc:	12 96       	adiw	r26, 0x02	; 2
    8afe:	9c 93       	st	X, r25
    8b00:	8e 93       	st	-X, r24
    8b02:	11 97       	sbiw	r26, 0x01	; 1
    8b04:	73 83       	std	Z+3, r23	; 0x03
    8b06:	62 83       	std	Z+2, r22	; 0x02
    8b08:	80 91 fb 04 	lds	r24, 0x04FB
    8b0c:	90 91 fc 04 	lds	r25, 0x04FC
    8b10:	a0 91 fd 04 	lds	r26, 0x04FD
    8b14:	b0 91 fe 04 	lds	r27, 0x04FE
    8b18:	84 83       	std	Z+4, r24	; 0x04
    8b1a:	95 83       	std	Z+5, r25	; 0x05
    8b1c:	a6 83       	std	Z+6, r26	; 0x06
    8b1e:	b7 83       	std	Z+7, r27	; 0x07
    8b20:	0e 94 22 85 	call	0x10a44	; 0x10a44 <sprintf>
    8b24:	ed b7       	in	r30, 0x3d	; 61
    8b26:	fe b7       	in	r31, 0x3e	; 62
    8b28:	38 96       	adiw	r30, 0x08	; 8
    8b2a:	0f b6       	in	r0, 0x3f	; 63
    8b2c:	f8 94       	cli
    8b2e:	fe bf       	out	0x3e, r31	; 62
    8b30:	0f be       	out	0x3f, r0	; 63
    8b32:	ed bf       	out	0x3d, r30	; 61
    8b34:	b6 cf       	rjmp	.-148    	; 0x8aa2 <Put_sbVal+0x138>
		Format[3] -= Param->Prec+1;
		Format[9] = '0'+Param->Prec;
		int16_t Div=Pow10(Param->Prec);
		sprintf(Param->Pos, Format, sF_Buf/Div, (uint32_t)labs(sF_Buf)%Div);
		if(sF_Buf<0) {
			while(*Param->Pos==' ')
    8b36:	d5 01       	movw	r26, r10
    8b38:	ed 91       	ld	r30, X+
    8b3a:	fc 91       	ld	r31, X
    8b3c:	80 81       	ld	r24, Z
    8b3e:	80 32       	cpi	r24, 0x20	; 32
    8b40:	39 f4       	brne	.+14     	; 0x8b50 <Put_sbVal+0x1e6>
				Param->Pos++;
    8b42:	31 96       	adiw	r30, 0x01	; 1
    8b44:	d5 01       	movw	r26, r10
    8b46:	ed 93       	st	X+, r30
    8b48:	fc 93       	st	X, r31
		Format[3] -= Param->Prec+1;
		Format[9] = '0'+Param->Prec;
		int16_t Div=Pow10(Param->Prec);
		sprintf(Param->Pos, Format, sF_Buf/Div, (uint32_t)labs(sF_Buf)%Div);
		if(sF_Buf<0) {
			while(*Param->Pos==' ')
    8b4a:	80 81       	ld	r24, Z
    8b4c:	80 32       	cpi	r24, 0x20	; 32
    8b4e:	c9 f3       	breq	.-14     	; 0x8b42 <Put_sbVal+0x1d8>
				Param->Pos++;
			*Param->Pos = '-';
    8b50:	8d e2       	ldi	r24, 0x2D	; 45
    8b52:	80 83       	st	Z, r24
    8b54:	a6 cf       	rjmp	.-180    	; 0x8aa2 <Put_sbVal+0x138>
	Format[3] = '0'+Param->Size;
	if(Param->Prec) {
		Format[3] -= Param->Prec+1;
		Format[9] = '0'+Param->Prec;
		int16_t Div=Pow10(Param->Prec);
		sprintf(Param->Pos, Format, sF_Buf/Div, (uint32_t)labs(sF_Buf)%Div);
    8b56:	90 95       	com	r25
    8b58:	80 95       	com	r24
    8b5a:	70 95       	com	r23
    8b5c:	61 95       	neg	r22
    8b5e:	7f 4f       	sbci	r23, 0xFF	; 255
    8b60:	8f 4f       	sbci	r24, 0xFF	; 255
    8b62:	9f 4f       	sbci	r25, 0xFF	; 255
    8b64:	81 cf       	rjmp	.-254    	; 0x8a68 <Put_sbVal+0xfe>

00008b66 <Put_bVal>:
}

// ~~~~~~~~~~~~~~~~~~~~~
void
Put_bVal(T_Param *Param)
{
    8b66:	6f 92       	push	r6
    8b68:	7f 92       	push	r7
    8b6a:	8f 92       	push	r8
    8b6c:	9f 92       	push	r9
    8b6e:	af 92       	push	r10
    8b70:	bf 92       	push	r11
    8b72:	cf 92       	push	r12
    8b74:	df 92       	push	r13
    8b76:	ef 92       	push	r14
    8b78:	ff 92       	push	r15
    8b7a:	0f 93       	push	r16
    8b7c:	1f 93       	push	r17
    8b7e:	df 93       	push	r29
    8b80:	cf 93       	push	r28
    8b82:	cd b7       	in	r28, 0x3d	; 61
    8b84:	de b7       	in	r29, 0x3e	; 62
    8b86:	2b 97       	sbiw	r28, 0x0b	; 11
    8b88:	0f b6       	in	r0, 0x3f	; 63
    8b8a:	f8 94       	cli
    8b8c:	de bf       	out	0x3e, r29	; 62
    8b8e:	0f be       	out	0x3f, r0	; 63
    8b90:	cd bf       	out	0x3d, r28	; 61
    8b92:	bc 01       	movw	r22, r24
	char Format[] = "%0 li.%. u";
    8b94:	3e 01       	movw	r6, r28
    8b96:	08 94       	sec
    8b98:	61 1c       	adc	r6, r1
    8b9a:	71 1c       	adc	r7, r1
    8b9c:	d3 01       	movw	r26, r6
    8b9e:	ec e0       	ldi	r30, 0x0C	; 12
    8ba0:	f2 e0       	ldi	r31, 0x02	; 2
    8ba2:	8b e0       	ldi	r24, 0x0B	; 11
    8ba4:	01 90       	ld	r0, Z+
    8ba6:	0d 92       	st	X+, r0
    8ba8:	81 50       	subi	r24, 0x01	; 1
    8baa:	e1 f7       	brne	.-8      	; 0x8ba4 <Put_bVal+0x3e>
	Format[2] = '0'+Param->Size;
    8bac:	db 01       	movw	r26, r22
    8bae:	13 96       	adiw	r26, 0x03	; 3
    8bb0:	2c 91       	ld	r18, X
    8bb2:	13 97       	sbiw	r26, 0x03	; 3
    8bb4:	20 5d       	subi	r18, 0xD0	; 208
    8bb6:	2b 83       	std	Y+3, r18	; 0x03
	if(Param->Prec) {
    8bb8:	12 96       	adiw	r26, 0x02	; 2
    8bba:	9c 91       	ld	r25, X
    8bbc:	99 23       	and	r25, r25
    8bbe:	09 f4       	brne	.+2      	; 0x8bc2 <Put_bVal+0x5c>
    8bc0:	6d c0       	rjmp	.+218    	; 0x8c9c <Put_bVal+0x136>
		Format[2] -= Param->Prec+1;
    8bc2:	89 2f       	mov	r24, r25
    8bc4:	80 95       	com	r24
    8bc6:	82 0f       	add	r24, r18
    8bc8:	8b 83       	std	Y+3, r24	; 0x03
		Format[8] = '0'+Param->Prec;
    8bca:	90 5d       	subi	r25, 0xD0	; 208
    8bcc:	99 87       	std	Y+9, r25	; 0x09
    8bce:	90 53       	subi	r25, 0x30	; 48
		uint16_t Div=Pow10(Param->Prec);
    8bd0:	49 2f       	mov	r20, r25
    8bd2:	21 e0       	ldi	r18, 0x01	; 1
    8bd4:	30 e0       	ldi	r19, 0x00	; 0
		Pow *= 10;
    8bd6:	c9 01       	movw	r24, r18
    8bd8:	88 0f       	add	r24, r24
    8bda:	99 1f       	adc	r25, r25
    8bdc:	22 0f       	add	r18, r18
    8bde:	33 1f       	adc	r19, r19
    8be0:	22 0f       	add	r18, r18
    8be2:	33 1f       	adc	r19, r19
    8be4:	22 0f       	add	r18, r18
    8be6:	33 1f       	adc	r19, r19
    8be8:	28 0f       	add	r18, r24
    8bea:	39 1f       	adc	r19, r25
    8bec:	41 50       	subi	r20, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    8bee:	99 f7       	brne	.-26     	; 0x8bd6 <Put_bVal+0x70>
    8bf0:	49 01       	movw	r8, r18
    8bf2:	aa 24       	eor	r10, r10
    8bf4:	bb 24       	eor	r11, r11
		sprintf(Param->Pos, Format, F_Buf/Div, F_Buf%Div);
    8bf6:	c0 90 f7 04 	lds	r12, 0x04F7
    8bfa:	d0 90 f8 04 	lds	r13, 0x04F8
    8bfe:	e0 90 f9 04 	lds	r14, 0x04F9
    8c02:	f0 90 fa 04 	lds	r15, 0x04FA
    8c06:	ed b7       	in	r30, 0x3d	; 61
    8c08:	fe b7       	in	r31, 0x3e	; 62
    8c0a:	3c 97       	sbiw	r30, 0x0c	; 12
    8c0c:	0f b6       	in	r0, 0x3f	; 63
    8c0e:	f8 94       	cli
    8c10:	fe bf       	out	0x3e, r31	; 62
    8c12:	0f be       	out	0x3f, r0	; 63
    8c14:	ed bf       	out	0x3d, r30	; 61
    8c16:	0d b7       	in	r16, 0x3d	; 61
    8c18:	1e b7       	in	r17, 0x3e	; 62
    8c1a:	0f 5f       	subi	r16, 0xFF	; 255
    8c1c:	1f 4f       	sbci	r17, 0xFF	; 255
    8c1e:	db 01       	movw	r26, r22
    8c20:	8d 91       	ld	r24, X+
    8c22:	9c 91       	ld	r25, X
    8c24:	92 83       	std	Z+2, r25	; 0x02
    8c26:	81 83       	std	Z+1, r24	; 0x01
    8c28:	f8 01       	movw	r30, r16
    8c2a:	73 82       	std	Z+3, r7	; 0x03
    8c2c:	62 82       	std	Z+2, r6	; 0x02
    8c2e:	c7 01       	movw	r24, r14
    8c30:	b6 01       	movw	r22, r12
    8c32:	a5 01       	movw	r20, r10
    8c34:	94 01       	movw	r18, r8
    8c36:	0e 94 de 87 	call	0x10fbc	; 0x10fbc <__udivmodsi4>
    8c3a:	d8 01       	movw	r26, r16
    8c3c:	14 96       	adiw	r26, 0x04	; 4
    8c3e:	2d 93       	st	X+, r18
    8c40:	3d 93       	st	X+, r19
    8c42:	4d 93       	st	X+, r20
    8c44:	5c 93       	st	X, r21
    8c46:	17 97       	sbiw	r26, 0x07	; 7
    8c48:	c7 01       	movw	r24, r14
    8c4a:	b6 01       	movw	r22, r12
    8c4c:	a5 01       	movw	r20, r10
    8c4e:	94 01       	movw	r18, r8
    8c50:	0e 94 de 87 	call	0x10fbc	; 0x10fbc <__udivmodsi4>
    8c54:	f8 01       	movw	r30, r16
    8c56:	60 87       	std	Z+8, r22	; 0x08
    8c58:	71 87       	std	Z+9, r23	; 0x09
    8c5a:	82 87       	std	Z+10, r24	; 0x0a
    8c5c:	93 87       	std	Z+11, r25	; 0x0b
    8c5e:	0e 94 22 85 	call	0x10a44	; 0x10a44 <sprintf>
    8c62:	8d b7       	in	r24, 0x3d	; 61
    8c64:	9e b7       	in	r25, 0x3e	; 62
    8c66:	0c 96       	adiw	r24, 0x0c	; 12
    8c68:	0f b6       	in	r0, 0x3f	; 63
    8c6a:	f8 94       	cli
    8c6c:	9e bf       	out	0x3e, r25	; 62
    8c6e:	0f be       	out	0x3f, r0	; 63
    8c70:	8d bf       	out	0x3d, r24	; 61
	}
	else{
		Format[5] = '\0';
		sprintf(Param->Pos, Format, F_Buf);
	}
}
    8c72:	2b 96       	adiw	r28, 0x0b	; 11
    8c74:	0f b6       	in	r0, 0x3f	; 63
    8c76:	f8 94       	cli
    8c78:	de bf       	out	0x3e, r29	; 62
    8c7a:	0f be       	out	0x3f, r0	; 63
    8c7c:	cd bf       	out	0x3d, r28	; 61
    8c7e:	cf 91       	pop	r28
    8c80:	df 91       	pop	r29
    8c82:	1f 91       	pop	r17
    8c84:	0f 91       	pop	r16
    8c86:	ff 90       	pop	r15
    8c88:	ef 90       	pop	r14
    8c8a:	df 90       	pop	r13
    8c8c:	cf 90       	pop	r12
    8c8e:	bf 90       	pop	r11
    8c90:	af 90       	pop	r10
    8c92:	9f 90       	pop	r9
    8c94:	8f 90       	pop	r8
    8c96:	7f 90       	pop	r7
    8c98:	6f 90       	pop	r6
    8c9a:	08 95       	ret
		Format[8] = '0'+Param->Prec;
		uint16_t Div=Pow10(Param->Prec);
		sprintf(Param->Pos, Format, F_Buf/Div, F_Buf%Div);
	}
	else{
		Format[5] = '\0';
    8c9c:	1e 82       	std	Y+6, r1	; 0x06
		sprintf(Param->Pos, Format, F_Buf);
    8c9e:	ad b7       	in	r26, 0x3d	; 61
    8ca0:	be b7       	in	r27, 0x3e	; 62
    8ca2:	18 97       	sbiw	r26, 0x08	; 8
    8ca4:	0f b6       	in	r0, 0x3f	; 63
    8ca6:	f8 94       	cli
    8ca8:	be bf       	out	0x3e, r27	; 62
    8caa:	0f be       	out	0x3f, r0	; 63
    8cac:	ad bf       	out	0x3d, r26	; 61
    8cae:	ed b7       	in	r30, 0x3d	; 61
    8cb0:	fe b7       	in	r31, 0x3e	; 62
    8cb2:	31 96       	adiw	r30, 0x01	; 1
    8cb4:	db 01       	movw	r26, r22
    8cb6:	8d 91       	ld	r24, X+
    8cb8:	9c 91       	ld	r25, X
    8cba:	ad b7       	in	r26, 0x3d	; 61
    8cbc:	be b7       	in	r27, 0x3e	; 62
    8cbe:	12 96       	adiw	r26, 0x02	; 2
    8cc0:	9c 93       	st	X, r25
    8cc2:	8e 93       	st	-X, r24
    8cc4:	11 97       	sbiw	r26, 0x01	; 1
    8cc6:	73 82       	std	Z+3, r7	; 0x03
    8cc8:	62 82       	std	Z+2, r6	; 0x02
    8cca:	80 91 f7 04 	lds	r24, 0x04F7
    8cce:	90 91 f8 04 	lds	r25, 0x04F8
    8cd2:	a0 91 f9 04 	lds	r26, 0x04F9
    8cd6:	b0 91 fa 04 	lds	r27, 0x04FA
    8cda:	84 83       	std	Z+4, r24	; 0x04
    8cdc:	95 83       	std	Z+5, r25	; 0x05
    8cde:	a6 83       	std	Z+6, r26	; 0x06
    8ce0:	b7 83       	std	Z+7, r27	; 0x07
    8ce2:	0e 94 22 85 	call	0x10a44	; 0x10a44 <sprintf>
    8ce6:	ed b7       	in	r30, 0x3d	; 61
    8ce8:	fe b7       	in	r31, 0x3e	; 62
    8cea:	38 96       	adiw	r30, 0x08	; 8
    8cec:	0f b6       	in	r0, 0x3f	; 63
    8cee:	f8 94       	cli
    8cf0:	fe bf       	out	0x3e, r31	; 62
    8cf2:	0f be       	out	0x3f, r0	; 63
    8cf4:	ed bf       	out	0x3d, r30	; 61
    8cf6:	bd cf       	rjmp	.-134    	; 0x8c72 <Put_bVal+0x10c>

00008cf8 <Put_TextValAlignLeft>:
	char Format[8];
	//char Format[8] = "%10.10s";
	sprintf(Format,"%%%u.%us", Param->Size, Param->Size);
	sprintf(Param->Pos, Format, Val);
}
void Put_TextValAlignLeft(char* Val, T_Param *Param){
    8cf8:	cf 92       	push	r12
    8cfa:	df 92       	push	r13
    8cfc:	ef 92       	push	r14
    8cfe:	ff 92       	push	r15
    8d00:	0f 93       	push	r16
    8d02:	1f 93       	push	r17
    8d04:	df 93       	push	r29
    8d06:	cf 93       	push	r28
    8d08:	cd b7       	in	r28, 0x3d	; 61
    8d0a:	de b7       	in	r29, 0x3e	; 62
    8d0c:	29 97       	sbiw	r28, 0x09	; 9
    8d0e:	0f b6       	in	r0, 0x3f	; 63
    8d10:	f8 94       	cli
    8d12:	de bf       	out	0x3e, r29	; 62
    8d14:	0f be       	out	0x3f, r0	; 63
    8d16:	cd bf       	out	0x3d, r28	; 61
    8d18:	6c 01       	movw	r12, r24
    8d1a:	7b 01       	movw	r14, r22
	char Format[9];
	//char Format[8] = "%10.10s";
	sprintf(Format,"%%-%u.%us", Param->Size, Param->Size);
    8d1c:	db 01       	movw	r26, r22
    8d1e:	13 96       	adiw	r26, 0x03	; 3
    8d20:	2c 91       	ld	r18, X
    8d22:	ed b7       	in	r30, 0x3d	; 61
    8d24:	fe b7       	in	r31, 0x3e	; 62
    8d26:	38 97       	sbiw	r30, 0x08	; 8
    8d28:	0f b6       	in	r0, 0x3f	; 63
    8d2a:	f8 94       	cli
    8d2c:	fe bf       	out	0x3e, r31	; 62
    8d2e:	0f be       	out	0x3f, r0	; 63
    8d30:	ed bf       	out	0x3d, r30	; 61
    8d32:	31 96       	adiw	r30, 0x01	; 1
    8d34:	8e 01       	movw	r16, r28
    8d36:	0f 5f       	subi	r16, 0xFF	; 255
    8d38:	1f 4f       	sbci	r17, 0xFF	; 255
    8d3a:	ad b7       	in	r26, 0x3d	; 61
    8d3c:	be b7       	in	r27, 0x3e	; 62
    8d3e:	12 96       	adiw	r26, 0x02	; 2
    8d40:	1c 93       	st	X, r17
    8d42:	0e 93       	st	-X, r16
    8d44:	11 97       	sbiw	r26, 0x01	; 1
    8d46:	87 e1       	ldi	r24, 0x17	; 23
    8d48:	92 e0       	ldi	r25, 0x02	; 2
    8d4a:	93 83       	std	Z+3, r25	; 0x03
    8d4c:	82 83       	std	Z+2, r24	; 0x02
    8d4e:	24 83       	std	Z+4, r18	; 0x04
    8d50:	15 82       	std	Z+5, r1	; 0x05
    8d52:	26 83       	std	Z+6, r18	; 0x06
    8d54:	17 82       	std	Z+7, r1	; 0x07
    8d56:	0e 94 22 85 	call	0x10a44	; 0x10a44 <sprintf>
	sprintf(Param->Pos, Format, Val);
    8d5a:	0f 90       	pop	r0
    8d5c:	0f 90       	pop	r0
    8d5e:	ed b7       	in	r30, 0x3d	; 61
    8d60:	fe b7       	in	r31, 0x3e	; 62
    8d62:	31 96       	adiw	r30, 0x01	; 1
    8d64:	d7 01       	movw	r26, r14
    8d66:	8d 91       	ld	r24, X+
    8d68:	9c 91       	ld	r25, X
    8d6a:	ad b7       	in	r26, 0x3d	; 61
    8d6c:	be b7       	in	r27, 0x3e	; 62
    8d6e:	12 96       	adiw	r26, 0x02	; 2
    8d70:	9c 93       	st	X, r25
    8d72:	8e 93       	st	-X, r24
    8d74:	11 97       	sbiw	r26, 0x01	; 1
    8d76:	13 83       	std	Z+3, r17	; 0x03
    8d78:	02 83       	std	Z+2, r16	; 0x02
    8d7a:	d5 82       	std	Z+5, r13	; 0x05
    8d7c:	c4 82       	std	Z+4, r12	; 0x04
    8d7e:	0e 94 22 85 	call	0x10a44	; 0x10a44 <sprintf>
    8d82:	ed b7       	in	r30, 0x3d	; 61
    8d84:	fe b7       	in	r31, 0x3e	; 62
    8d86:	36 96       	adiw	r30, 0x06	; 6
    8d88:	0f b6       	in	r0, 0x3f	; 63
    8d8a:	f8 94       	cli
    8d8c:	fe bf       	out	0x3e, r31	; 62
    8d8e:	0f be       	out	0x3f, r0	; 63
    8d90:	ed bf       	out	0x3d, r30	; 61
}
    8d92:	29 96       	adiw	r28, 0x09	; 9
    8d94:	0f b6       	in	r0, 0x3f	; 63
    8d96:	f8 94       	cli
    8d98:	de bf       	out	0x3e, r29	; 62
    8d9a:	0f be       	out	0x3f, r0	; 63
    8d9c:	cd bf       	out	0x3d, r28	; 61
    8d9e:	cf 91       	pop	r28
    8da0:	df 91       	pop	r29
    8da2:	1f 91       	pop	r17
    8da4:	0f 91       	pop	r16
    8da6:	ff 90       	pop	r15
    8da8:	ef 90       	pop	r14
    8daa:	df 90       	pop	r13
    8dac:	cf 90       	pop	r12
    8dae:	08 95       	ret

00008db0 <Put_TextValAlignRight>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Put_TextVal -  
// if, for example, Filed width =12 -> sprintf(Param->Pos,"%12.12s",Val)
// min and max width = Param->Size and align right
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void Put_TextValAlignRight(char* Val, T_Param *Param){
    8db0:	cf 92       	push	r12
    8db2:	df 92       	push	r13
    8db4:	ef 92       	push	r14
    8db6:	ff 92       	push	r15
    8db8:	0f 93       	push	r16
    8dba:	1f 93       	push	r17
    8dbc:	df 93       	push	r29
    8dbe:	cf 93       	push	r28
    8dc0:	cd b7       	in	r28, 0x3d	; 61
    8dc2:	de b7       	in	r29, 0x3e	; 62
    8dc4:	28 97       	sbiw	r28, 0x08	; 8
    8dc6:	0f b6       	in	r0, 0x3f	; 63
    8dc8:	f8 94       	cli
    8dca:	de bf       	out	0x3e, r29	; 62
    8dcc:	0f be       	out	0x3f, r0	; 63
    8dce:	cd bf       	out	0x3d, r28	; 61
    8dd0:	6c 01       	movw	r12, r24
    8dd2:	7b 01       	movw	r14, r22
	char Format[8];
	//char Format[8] = "%10.10s";
	sprintf(Format,"%%%u.%us", Param->Size, Param->Size);
    8dd4:	db 01       	movw	r26, r22
    8dd6:	13 96       	adiw	r26, 0x03	; 3
    8dd8:	2c 91       	ld	r18, X
    8dda:	ed b7       	in	r30, 0x3d	; 61
    8ddc:	fe b7       	in	r31, 0x3e	; 62
    8dde:	38 97       	sbiw	r30, 0x08	; 8
    8de0:	0f b6       	in	r0, 0x3f	; 63
    8de2:	f8 94       	cli
    8de4:	fe bf       	out	0x3e, r31	; 62
    8de6:	0f be       	out	0x3f, r0	; 63
    8de8:	ed bf       	out	0x3d, r30	; 61
    8dea:	31 96       	adiw	r30, 0x01	; 1
    8dec:	8e 01       	movw	r16, r28
    8dee:	0f 5f       	subi	r16, 0xFF	; 255
    8df0:	1f 4f       	sbci	r17, 0xFF	; 255
    8df2:	ad b7       	in	r26, 0x3d	; 61
    8df4:	be b7       	in	r27, 0x3e	; 62
    8df6:	12 96       	adiw	r26, 0x02	; 2
    8df8:	1c 93       	st	X, r17
    8dfa:	0e 93       	st	-X, r16
    8dfc:	11 97       	sbiw	r26, 0x01	; 1
    8dfe:	81 e2       	ldi	r24, 0x21	; 33
    8e00:	92 e0       	ldi	r25, 0x02	; 2
    8e02:	93 83       	std	Z+3, r25	; 0x03
    8e04:	82 83       	std	Z+2, r24	; 0x02
    8e06:	24 83       	std	Z+4, r18	; 0x04
    8e08:	15 82       	std	Z+5, r1	; 0x05
    8e0a:	26 83       	std	Z+6, r18	; 0x06
    8e0c:	17 82       	std	Z+7, r1	; 0x07
    8e0e:	0e 94 22 85 	call	0x10a44	; 0x10a44 <sprintf>
	sprintf(Param->Pos, Format, Val);
    8e12:	0f 90       	pop	r0
    8e14:	0f 90       	pop	r0
    8e16:	ed b7       	in	r30, 0x3d	; 61
    8e18:	fe b7       	in	r31, 0x3e	; 62
    8e1a:	31 96       	adiw	r30, 0x01	; 1
    8e1c:	d7 01       	movw	r26, r14
    8e1e:	8d 91       	ld	r24, X+
    8e20:	9c 91       	ld	r25, X
    8e22:	ad b7       	in	r26, 0x3d	; 61
    8e24:	be b7       	in	r27, 0x3e	; 62
    8e26:	12 96       	adiw	r26, 0x02	; 2
    8e28:	9c 93       	st	X, r25
    8e2a:	8e 93       	st	-X, r24
    8e2c:	11 97       	sbiw	r26, 0x01	; 1
    8e2e:	13 83       	std	Z+3, r17	; 0x03
    8e30:	02 83       	std	Z+2, r16	; 0x02
    8e32:	d5 82       	std	Z+5, r13	; 0x05
    8e34:	c4 82       	std	Z+4, r12	; 0x04
    8e36:	0e 94 22 85 	call	0x10a44	; 0x10a44 <sprintf>
    8e3a:	ed b7       	in	r30, 0x3d	; 61
    8e3c:	fe b7       	in	r31, 0x3e	; 62
    8e3e:	36 96       	adiw	r30, 0x06	; 6
    8e40:	0f b6       	in	r0, 0x3f	; 63
    8e42:	f8 94       	cli
    8e44:	fe bf       	out	0x3e, r31	; 62
    8e46:	0f be       	out	0x3f, r0	; 63
    8e48:	ed bf       	out	0x3d, r30	; 61
}
    8e4a:	28 96       	adiw	r28, 0x08	; 8
    8e4c:	0f b6       	in	r0, 0x3f	; 63
    8e4e:	f8 94       	cli
    8e50:	de bf       	out	0x3e, r29	; 62
    8e52:	0f be       	out	0x3f, r0	; 63
    8e54:	cd bf       	out	0x3d, r28	; 61
    8e56:	cf 91       	pop	r28
    8e58:	df 91       	pop	r29
    8e5a:	1f 91       	pop	r17
    8e5c:	0f 91       	pop	r16
    8e5e:	ff 90       	pop	r15
    8e60:	ef 90       	pop	r14
    8e62:	df 90       	pop	r13
    8e64:	cf 90       	pop	r12
    8e66:	08 95       	ret

00008e68 <Put_GFVal>:
// Trailing zeros are removed from the fractional part of the result; 
// a decimal point appears only if it is followed by at least one digit.
// Max presicion - 8digits Why???
// Therefore Max Field size - 9
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void Put_GFVal(float Val, T_Param *Param){
    8e68:	ef 92       	push	r14
    8e6a:	ff 92       	push	r15
    8e6c:	0f 93       	push	r16
    8e6e:	1f 93       	push	r17
    8e70:	df 93       	push	r29
    8e72:	cf 93       	push	r28
    8e74:	cd b7       	in	r28, 0x3d	; 61
    8e76:	de b7       	in	r29, 0x3e	; 62
    8e78:	2f 97       	sbiw	r28, 0x0f	; 15
    8e7a:	0f b6       	in	r0, 0x3f	; 63
    8e7c:	f8 94       	cli
    8e7e:	de bf       	out	0x3e, r29	; 62
    8e80:	0f be       	out	0x3f, r0	; 63
    8e82:	cd bf       	out	0x3d, r28	; 61
    8e84:	7b 01       	movw	r14, r22
    8e86:	8c 01       	movw	r16, r24
    8e88:	9a 01       	movw	r18, r20
	if(Param->Size < 10){
    8e8a:	da 01       	movw	r26, r20
    8e8c:	13 96       	adiw	r26, 0x03	; 3
    8e8e:	8c 91       	ld	r24, X
    8e90:	8a 30       	cpi	r24, 0x0A	; 10
    8e92:	08 f4       	brcc	.+2      	; 0x8e96 <Put_GFVal+0x2e>
    8e94:	44 c0       	rjmp	.+136    	; 0x8f1e <Put_GFVal+0xb6>
		Format[2] = '0'+Param->Size;
		Format[4] = '0'+Param->Prec;
		sprintf(Param->Pos, Format, Val);
	}
	else{
		char Format[] = "%+1 . g";
    8e96:	ae 01       	movw	r20, r28
    8e98:	48 5f       	subi	r20, 0xF8	; 248
    8e9a:	5f 4f       	sbci	r21, 0xFF	; 255
    8e9c:	da 01       	movw	r26, r20
    8e9e:	ea e2       	ldi	r30, 0x2A	; 42
    8ea0:	f2 e0       	ldi	r31, 0x02	; 2
    8ea2:	88 e0       	ldi	r24, 0x08	; 8
    8ea4:	01 90       	ld	r0, Z+
    8ea6:	0d 92       	st	X+, r0
    8ea8:	81 50       	subi	r24, 0x01	; 1
    8eaa:	e1 f7       	brne	.-8      	; 0x8ea4 <Put_GFVal+0x3c>
		Format[3] = '0'+Param->Size-10;	
    8eac:	d9 01       	movw	r26, r18
    8eae:	13 96       	adiw	r26, 0x03	; 3
    8eb0:	8c 91       	ld	r24, X
    8eb2:	13 97       	sbiw	r26, 0x03	; 3
    8eb4:	8a 5d       	subi	r24, 0xDA	; 218
    8eb6:	8b 87       	std	Y+11, r24	; 0x0b
		Format[5] = '0'+Param->Prec;
    8eb8:	12 96       	adiw	r26, 0x02	; 2
    8eba:	8c 91       	ld	r24, X
    8ebc:	12 97       	sbiw	r26, 0x02	; 2
    8ebe:	80 5d       	subi	r24, 0xD0	; 208
    8ec0:	8d 87       	std	Y+13, r24	; 0x0d
		sprintf(Param->Pos, Format, Val);
    8ec2:	ed b7       	in	r30, 0x3d	; 61
    8ec4:	fe b7       	in	r31, 0x3e	; 62
    8ec6:	38 97       	sbiw	r30, 0x08	; 8
    8ec8:	0f b6       	in	r0, 0x3f	; 63
    8eca:	f8 94       	cli
    8ecc:	fe bf       	out	0x3e, r31	; 62
    8ece:	0f be       	out	0x3f, r0	; 63
    8ed0:	ed bf       	out	0x3d, r30	; 61
    8ed2:	31 96       	adiw	r30, 0x01	; 1
    8ed4:	8d 91       	ld	r24, X+
    8ed6:	9c 91       	ld	r25, X
    8ed8:	ad b7       	in	r26, 0x3d	; 61
    8eda:	be b7       	in	r27, 0x3e	; 62
    8edc:	12 96       	adiw	r26, 0x02	; 2
    8ede:	9c 93       	st	X, r25
    8ee0:	8e 93       	st	-X, r24
    8ee2:	11 97       	sbiw	r26, 0x01	; 1
    8ee4:	53 83       	std	Z+3, r21	; 0x03
    8ee6:	42 83       	std	Z+2, r20	; 0x02
    8ee8:	e4 82       	std	Z+4, r14	; 0x04
    8eea:	f5 82       	std	Z+5, r15	; 0x05
    8eec:	06 83       	std	Z+6, r16	; 0x06
    8eee:	17 83       	std	Z+7, r17	; 0x07
    8ef0:	0e 94 22 85 	call	0x10a44	; 0x10a44 <sprintf>
    8ef4:	ed b7       	in	r30, 0x3d	; 61
    8ef6:	fe b7       	in	r31, 0x3e	; 62
    8ef8:	38 96       	adiw	r30, 0x08	; 8
    8efa:	0f b6       	in	r0, 0x3f	; 63
    8efc:	f8 94       	cli
    8efe:	fe bf       	out	0x3e, r31	; 62
    8f00:	0f be       	out	0x3f, r0	; 63
    8f02:	ed bf       	out	0x3d, r30	; 61
	}
}
    8f04:	2f 96       	adiw	r28, 0x0f	; 15
    8f06:	0f b6       	in	r0, 0x3f	; 63
    8f08:	f8 94       	cli
    8f0a:	de bf       	out	0x3e, r29	; 62
    8f0c:	0f be       	out	0x3f, r0	; 63
    8f0e:	cd bf       	out	0x3d, r28	; 61
    8f10:	cf 91       	pop	r28
    8f12:	df 91       	pop	r29
    8f14:	1f 91       	pop	r17
    8f16:	0f 91       	pop	r16
    8f18:	ff 90       	pop	r15
    8f1a:	ef 90       	pop	r14
    8f1c:	08 95       	ret
// Max presicion - 8digits Why???
// Therefore Max Field size - 9
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void Put_GFVal(float Val, T_Param *Param){
	if(Param->Size < 10){
		char Format[] = "%+ . g";
    8f1e:	ae 01       	movw	r20, r28
    8f20:	4f 5f       	subi	r20, 0xFF	; 255
    8f22:	5f 4f       	sbci	r21, 0xFF	; 255
    8f24:	da 01       	movw	r26, r20
    8f26:	e2 e3       	ldi	r30, 0x32	; 50
    8f28:	f2 e0       	ldi	r31, 0x02	; 2
    8f2a:	87 e0       	ldi	r24, 0x07	; 7
    8f2c:	01 90       	ld	r0, Z+
    8f2e:	0d 92       	st	X+, r0
    8f30:	81 50       	subi	r24, 0x01	; 1
    8f32:	e1 f7       	brne	.-8      	; 0x8f2c <Put_GFVal+0xc4>
		Format[2] = '0'+Param->Size;
    8f34:	f9 01       	movw	r30, r18
    8f36:	83 81       	ldd	r24, Z+3	; 0x03
    8f38:	80 5d       	subi	r24, 0xD0	; 208
    8f3a:	8b 83       	std	Y+3, r24	; 0x03
		Format[4] = '0'+Param->Prec;
    8f3c:	82 81       	ldd	r24, Z+2	; 0x02
    8f3e:	80 5d       	subi	r24, 0xD0	; 208
    8f40:	8d 83       	std	Y+5, r24	; 0x05
		sprintf(Param->Pos, Format, Val);
    8f42:	8d b7       	in	r24, 0x3d	; 61
    8f44:	9e b7       	in	r25, 0x3e	; 62
    8f46:	08 97       	sbiw	r24, 0x08	; 8
    8f48:	0f b6       	in	r0, 0x3f	; 63
    8f4a:	f8 94       	cli
    8f4c:	9e bf       	out	0x3e, r25	; 62
    8f4e:	0f be       	out	0x3f, r0	; 63
    8f50:	8d bf       	out	0x3d, r24	; 61
    8f52:	ed b7       	in	r30, 0x3d	; 61
    8f54:	fe b7       	in	r31, 0x3e	; 62
    8f56:	31 96       	adiw	r30, 0x01	; 1
    8f58:	d9 01       	movw	r26, r18
    8f5a:	bc cf       	rjmp	.-136    	; 0x8ed4 <Put_GFVal+0x6c>

00008f5c <Put_FFVal>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Put_FVal -  The double argument is rounded and converted to decimal notation in the format "[-]ddd.ddd"
// Max presicion - 8digits Why???
// Therefore Max Field size - 9
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void Put_FFVal(float Val, T_Param *Param){
    8f5c:	ef 92       	push	r14
    8f5e:	ff 92       	push	r15
    8f60:	0f 93       	push	r16
    8f62:	1f 93       	push	r17
    8f64:	df 93       	push	r29
    8f66:	cf 93       	push	r28
    8f68:	cd b7       	in	r28, 0x3d	; 61
    8f6a:	de b7       	in	r29, 0x3e	; 62
    8f6c:	27 97       	sbiw	r28, 0x07	; 7
    8f6e:	0f b6       	in	r0, 0x3f	; 63
    8f70:	f8 94       	cli
    8f72:	de bf       	out	0x3e, r29	; 62
    8f74:	0f be       	out	0x3f, r0	; 63
    8f76:	cd bf       	out	0x3d, r28	; 61
    8f78:	7b 01       	movw	r14, r22
    8f7a:	8c 01       	movw	r16, r24
    8f7c:	9a 01       	movw	r18, r20
	char Format[] = "%+ . f";
    8f7e:	ae 01       	movw	r20, r28
    8f80:	4f 5f       	subi	r20, 0xFF	; 255
    8f82:	5f 4f       	sbci	r21, 0xFF	; 255
    8f84:	da 01       	movw	r26, r20
    8f86:	e9 e3       	ldi	r30, 0x39	; 57
    8f88:	f2 e0       	ldi	r31, 0x02	; 2
    8f8a:	87 e0       	ldi	r24, 0x07	; 7
    8f8c:	01 90       	ld	r0, Z+
    8f8e:	0d 92       	st	X+, r0
    8f90:	81 50       	subi	r24, 0x01	; 1
    8f92:	e1 f7       	brne	.-8      	; 0x8f8c <Put_FFVal+0x30>
	Format[2] = '0'+Param->Size;
    8f94:	d9 01       	movw	r26, r18
    8f96:	13 96       	adiw	r26, 0x03	; 3
    8f98:	8c 91       	ld	r24, X
    8f9a:	13 97       	sbiw	r26, 0x03	; 3
    8f9c:	80 5d       	subi	r24, 0xD0	; 208
    8f9e:	8b 83       	std	Y+3, r24	; 0x03
	Format[4] = '0'+Param->Prec;	
    8fa0:	12 96       	adiw	r26, 0x02	; 2
    8fa2:	8c 91       	ld	r24, X
    8fa4:	12 97       	sbiw	r26, 0x02	; 2
    8fa6:	80 5d       	subi	r24, 0xD0	; 208
    8fa8:	8d 83       	std	Y+5, r24	; 0x05
	sprintf(Param->Pos, Format, Val);
    8faa:	ed b7       	in	r30, 0x3d	; 61
    8fac:	fe b7       	in	r31, 0x3e	; 62
    8fae:	38 97       	sbiw	r30, 0x08	; 8
    8fb0:	0f b6       	in	r0, 0x3f	; 63
    8fb2:	f8 94       	cli
    8fb4:	fe bf       	out	0x3e, r31	; 62
    8fb6:	0f be       	out	0x3f, r0	; 63
    8fb8:	ed bf       	out	0x3d, r30	; 61
    8fba:	31 96       	adiw	r30, 0x01	; 1
    8fbc:	8d 91       	ld	r24, X+
    8fbe:	9c 91       	ld	r25, X
    8fc0:	ad b7       	in	r26, 0x3d	; 61
    8fc2:	be b7       	in	r27, 0x3e	; 62
    8fc4:	12 96       	adiw	r26, 0x02	; 2
    8fc6:	9c 93       	st	X, r25
    8fc8:	8e 93       	st	-X, r24
    8fca:	11 97       	sbiw	r26, 0x01	; 1
    8fcc:	53 83       	std	Z+3, r21	; 0x03
    8fce:	42 83       	std	Z+2, r20	; 0x02
    8fd0:	e4 82       	std	Z+4, r14	; 0x04
    8fd2:	f5 82       	std	Z+5, r15	; 0x05
    8fd4:	06 83       	std	Z+6, r16	; 0x06
    8fd6:	17 83       	std	Z+7, r17	; 0x07
    8fd8:	0e 94 22 85 	call	0x10a44	; 0x10a44 <sprintf>
    8fdc:	ed b7       	in	r30, 0x3d	; 61
    8fde:	fe b7       	in	r31, 0x3e	; 62
    8fe0:	38 96       	adiw	r30, 0x08	; 8
    8fe2:	0f b6       	in	r0, 0x3f	; 63
    8fe4:	f8 94       	cli
    8fe6:	fe bf       	out	0x3e, r31	; 62
    8fe8:	0f be       	out	0x3f, r0	; 63
    8fea:	ed bf       	out	0x3d, r30	; 61
}
    8fec:	27 96       	adiw	r28, 0x07	; 7
    8fee:	0f b6       	in	r0, 0x3f	; 63
    8ff0:	f8 94       	cli
    8ff2:	de bf       	out	0x3e, r29	; 62
    8ff4:	0f be       	out	0x3f, r0	; 63
    8ff6:	cd bf       	out	0x3d, r28	; 61
    8ff8:	cf 91       	pop	r28
    8ffa:	df 91       	pop	r29
    8ffc:	1f 91       	pop	r17
    8ffe:	0f 91       	pop	r16
    9000:	ff 90       	pop	r15
    9002:	ef 90       	pop	r14
    9004:	08 95       	ret

00009006 <Put_zDVal>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Put_zDVal - print unsigned Longint with leading zeroes in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void 
Put_zDVal(uint32_t Val, T_Param *Param)
{
    9006:	2f 92       	push	r2
    9008:	3f 92       	push	r3
    900a:	4f 92       	push	r4
    900c:	5f 92       	push	r5
    900e:	6f 92       	push	r6
    9010:	7f 92       	push	r7
    9012:	8f 92       	push	r8
    9014:	9f 92       	push	r9
    9016:	af 92       	push	r10
    9018:	bf 92       	push	r11
    901a:	cf 92       	push	r12
    901c:	df 92       	push	r13
    901e:	ef 92       	push	r14
    9020:	ff 92       	push	r15
    9022:	0f 93       	push	r16
    9024:	1f 93       	push	r17
    9026:	df 93       	push	r29
    9028:	cf 93       	push	r28
    902a:	cd b7       	in	r28, 0x3d	; 61
    902c:	de b7       	in	r29, 0x3e	; 62
    902e:	2c 97       	sbiw	r28, 0x0c	; 12
    9030:	0f b6       	in	r0, 0x3f	; 63
    9032:	f8 94       	cli
    9034:	de bf       	out	0x3e, r29	; 62
    9036:	0f be       	out	0x3f, r0	; 63
    9038:	cd bf       	out	0x3d, r28	; 61
    903a:	1b 01       	movw	r2, r22
    903c:	2c 01       	movw	r4, r24
    903e:	3a 01       	movw	r6, r20
	uint32_t Idx = 0xFFFFFFFF-Val;
	if(Param->Txt && Idx<2) {
    9040:	da 01       	movw	r26, r20
    9042:	14 96       	adiw	r26, 0x04	; 4
    9044:	2d 91       	ld	r18, X+
    9046:	3c 91       	ld	r19, X
    9048:	15 97       	sbiw	r26, 0x05	; 5
    904a:	21 15       	cp	r18, r1
    904c:	31 05       	cpc	r19, r1
    904e:	61 f0       	breq	.+24     	; 0x9068 <Put_zDVal+0x62>
// Put_zDVal - print unsigned Longint with leading zeroes in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void 
Put_zDVal(uint32_t Val, T_Param *Param)
{
	uint32_t Idx = 0xFFFFFFFF-Val;
    9050:	dc 01       	movw	r26, r24
    9052:	cb 01       	movw	r24, r22
    9054:	80 95       	com	r24
    9056:	90 95       	com	r25
    9058:	a0 95       	com	r26
    905a:	b0 95       	com	r27
	if(Param->Txt && Idx<2) {
    905c:	82 30       	cpi	r24, 0x02	; 2
    905e:	91 05       	cpc	r25, r1
    9060:	a1 05       	cpc	r26, r1
    9062:	b1 05       	cpc	r27, r1
    9064:	08 f4       	brcc	.+2      	; 0x9068 <Put_zDVal+0x62>
    9066:	e5 c0       	rjmp	.+458    	; 0x9232 <Put_zDVal+0x22c>
		Param->Txt += Idx;
		PutEnum(Param);
		return;
	}

	if(Param->Size==10 && Param->Prec==0){
    9068:	d3 01       	movw	r26, r6
    906a:	13 96       	adiw	r26, 0x03	; 3
    906c:	8c 91       	ld	r24, X
    906e:	13 97       	sbiw	r26, 0x03	; 3
    9070:	8a 30       	cpi	r24, 0x0A	; 10
    9072:	09 f4       	brne	.+2      	; 0x9076 <Put_zDVal+0x70>
    9074:	72 c0       	rjmp	.+228    	; 0x915a <Put_zDVal+0x154>
		sprintf(Param->Pos, "%010lu", Val);
		return;
	}
	char Format[] = "%0 lu.%. lu";
    9076:	de 01       	movw	r26, r28
    9078:	11 96       	adiw	r26, 0x01	; 1
    907a:	e7 e4       	ldi	r30, 0x47	; 71
    907c:	f2 e0       	ldi	r31, 0x02	; 2
    907e:	8c e0       	ldi	r24, 0x0C	; 12
    9080:	01 90       	ld	r0, Z+
    9082:	0d 92       	st	X+, r0
    9084:	81 50       	subi	r24, 0x01	; 1
    9086:	e1 f7       	brne	.-8      	; 0x9080 <Put_zDVal+0x7a>
	Format[2] = '0'+Param->Size;
    9088:	d3 01       	movw	r26, r6
    908a:	13 96       	adiw	r26, 0x03	; 3
    908c:	2c 91       	ld	r18, X
    908e:	13 97       	sbiw	r26, 0x03	; 3
    9090:	20 5d       	subi	r18, 0xD0	; 208
    9092:	2b 83       	std	Y+3, r18	; 0x03
	if(Param->Prec) {
    9094:	12 96       	adiw	r26, 0x02	; 2
    9096:	9c 91       	ld	r25, X
    9098:	99 23       	and	r25, r25
    909a:	09 f4       	brne	.+2      	; 0x909e <Put_zDVal+0x98>
    909c:	a0 c0       	rjmp	.+320    	; 0x91de <Put_zDVal+0x1d8>
		Format[2] -= Param->Prec+1;
    909e:	89 2f       	mov	r24, r25
    90a0:	80 95       	com	r24
    90a2:	82 0f       	add	r24, r18
    90a4:	8b 83       	std	Y+3, r24	; 0x03
		Format[8] = '0'+Param->Prec;
    90a6:	90 5d       	subi	r25, 0xD0	; 208
    90a8:	99 87       	std	Y+9, r25	; 0x09
    90aa:	90 53       	subi	r25, 0x30	; 48
		uint32_t Div=PowL10(Param->Prec);
    90ac:	09 2f       	mov	r16, r25
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
	uint32_t Pow = 1;
	while(Exp--)
    90ae:	61 e0       	ldi	r22, 0x01	; 1
    90b0:	86 2e       	mov	r8, r22
    90b2:	91 2c       	mov	r9, r1
    90b4:	a1 2c       	mov	r10, r1
    90b6:	b1 2c       	mov	r11, r1
		Pow *= 10;
    90b8:	c5 01       	movw	r24, r10
    90ba:	b4 01       	movw	r22, r8
    90bc:	2a e0       	ldi	r18, 0x0A	; 10
    90be:	30 e0       	ldi	r19, 0x00	; 0
    90c0:	40 e0       	ldi	r20, 0x00	; 0
    90c2:	50 e0       	ldi	r21, 0x00	; 0
    90c4:	0e 94 8c 87 	call	0x10f18	; 0x10f18 <__mulsi3>
    90c8:	4b 01       	movw	r8, r22
    90ca:	5c 01       	movw	r10, r24
    90cc:	01 50       	subi	r16, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
	uint32_t Pow = 1;
	while(Exp--)
    90ce:	a1 f7       	brne	.-24     	; 0x90b8 <Put_zDVal+0xb2>
    90d0:	c2 01       	movw	r24, r4
    90d2:	b1 01       	movw	r22, r2
    90d4:	94 01       	movw	r18, r8
    90d6:	a5 01       	movw	r20, r10
    90d8:	0e 94 de 87 	call	0x10fbc	; 0x10fbc <__udivmodsi4>
    90dc:	f6 2e       	mov	r15, r22
    90de:	e7 2e       	mov	r14, r23
    90e0:	d8 2e       	mov	r13, r24
    90e2:	c9 2e       	mov	r12, r25
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
    90e4:	ed b7       	in	r30, 0x3d	; 61
    90e6:	fe b7       	in	r31, 0x3e	; 62
    90e8:	3c 97       	sbiw	r30, 0x0c	; 12
    90ea:	0f b6       	in	r0, 0x3f	; 63
    90ec:	f8 94       	cli
    90ee:	fe bf       	out	0x3e, r31	; 62
    90f0:	0f be       	out	0x3f, r0	; 63
    90f2:	ed bf       	out	0x3d, r30	; 61
    90f4:	0d b7       	in	r16, 0x3d	; 61
    90f6:	1e b7       	in	r17, 0x3e	; 62
    90f8:	0f 5f       	subi	r16, 0xFF	; 255
    90fa:	1f 4f       	sbci	r17, 0xFF	; 255
    90fc:	d3 01       	movw	r26, r6
    90fe:	8d 91       	ld	r24, X+
    9100:	9c 91       	ld	r25, X
    9102:	92 83       	std	Z+2, r25	; 0x02
    9104:	81 83       	std	Z+1, r24	; 0x01
    9106:	81 e0       	ldi	r24, 0x01	; 1
    9108:	90 e0       	ldi	r25, 0x00	; 0
    910a:	8c 0f       	add	r24, r28
    910c:	9d 1f       	adc	r25, r29
    910e:	f8 01       	movw	r30, r16
    9110:	93 83       	std	Z+3, r25	; 0x03
    9112:	82 83       	std	Z+2, r24	; 0x02
    9114:	c2 01       	movw	r24, r4
    9116:	b1 01       	movw	r22, r2
    9118:	a5 01       	movw	r20, r10
    911a:	94 01       	movw	r18, r8
    911c:	0e 94 de 87 	call	0x10fbc	; 0x10fbc <__udivmodsi4>
    9120:	d8 01       	movw	r26, r16
    9122:	14 96       	adiw	r26, 0x04	; 4
    9124:	2d 93       	st	X+, r18
    9126:	3d 93       	st	X+, r19
    9128:	4d 93       	st	X+, r20
    912a:	5c 93       	st	X, r21
    912c:	17 97       	sbiw	r26, 0x07	; 7
    912e:	18 96       	adiw	r26, 0x08	; 8
    9130:	fc 92       	st	X, r15
    9132:	18 97       	sbiw	r26, 0x08	; 8
    9134:	19 96       	adiw	r26, 0x09	; 9
    9136:	ec 92       	st	X, r14
    9138:	19 97       	sbiw	r26, 0x09	; 9
    913a:	1a 96       	adiw	r26, 0x0a	; 10
    913c:	dc 92       	st	X, r13
    913e:	1a 97       	sbiw	r26, 0x0a	; 10
    9140:	1b 96       	adiw	r26, 0x0b	; 11
    9142:	cc 92       	st	X, r12
    9144:	0e 94 22 85 	call	0x10a44	; 0x10a44 <sprintf>
    9148:	ed b7       	in	r30, 0x3d	; 61
    914a:	fe b7       	in	r31, 0x3e	; 62
    914c:	3c 96       	adiw	r30, 0x0c	; 12
    914e:	0f b6       	in	r0, 0x3f	; 63
    9150:	f8 94       	cli
    9152:	fe bf       	out	0x3e, r31	; 62
    9154:	0f be       	out	0x3f, r0	; 63
    9156:	ed bf       	out	0x3d, r30	; 61
    9158:	29 c0       	rjmp	.+82     	; 0x91ac <Put_zDVal+0x1a6>
		Param->Txt += Idx;
		PutEnum(Param);
		return;
	}

	if(Param->Size==10 && Param->Prec==0){
    915a:	12 96       	adiw	r26, 0x02	; 2
    915c:	8c 91       	ld	r24, X
    915e:	12 97       	sbiw	r26, 0x02	; 2
    9160:	88 23       	and	r24, r24
    9162:	09 f0       	breq	.+2      	; 0x9166 <Put_zDVal+0x160>
    9164:	88 cf       	rjmp	.-240    	; 0x9076 <Put_zDVal+0x70>
		sprintf(Param->Pos, "%010lu", Val);
    9166:	ed b7       	in	r30, 0x3d	; 61
    9168:	fe b7       	in	r31, 0x3e	; 62
    916a:	38 97       	sbiw	r30, 0x08	; 8
    916c:	0f b6       	in	r0, 0x3f	; 63
    916e:	f8 94       	cli
    9170:	fe bf       	out	0x3e, r31	; 62
    9172:	0f be       	out	0x3f, r0	; 63
    9174:	ed bf       	out	0x3d, r30	; 61
    9176:	31 96       	adiw	r30, 0x01	; 1
    9178:	8d 91       	ld	r24, X+
    917a:	9c 91       	ld	r25, X
    917c:	ad b7       	in	r26, 0x3d	; 61
    917e:	be b7       	in	r27, 0x3e	; 62
    9180:	12 96       	adiw	r26, 0x02	; 2
    9182:	9c 93       	st	X, r25
    9184:	8e 93       	st	-X, r24
    9186:	11 97       	sbiw	r26, 0x01	; 1
    9188:	80 e4       	ldi	r24, 0x40	; 64
    918a:	92 e0       	ldi	r25, 0x02	; 2
    918c:	93 83       	std	Z+3, r25	; 0x03
    918e:	82 83       	std	Z+2, r24	; 0x02
    9190:	24 82       	std	Z+4, r2	; 0x04
    9192:	35 82       	std	Z+5, r3	; 0x05
    9194:	46 82       	std	Z+6, r4	; 0x06
    9196:	57 82       	std	Z+7, r5	; 0x07
    9198:	0e 94 22 85 	call	0x10a44	; 0x10a44 <sprintf>
    919c:	ed b7       	in	r30, 0x3d	; 61
    919e:	fe b7       	in	r31, 0x3e	; 62
    91a0:	38 96       	adiw	r30, 0x08	; 8
    91a2:	0f b6       	in	r0, 0x3f	; 63
    91a4:	f8 94       	cli
    91a6:	fe bf       	out	0x3e, r31	; 62
    91a8:	0f be       	out	0x3f, r0	; 63
    91aa:	ed bf       	out	0x3d, r30	; 61
	}
	else {
		Format[5] = '\0';
		sprintf(Param->Pos, Format, Val);
	}
}
    91ac:	2c 96       	adiw	r28, 0x0c	; 12
    91ae:	0f b6       	in	r0, 0x3f	; 63
    91b0:	f8 94       	cli
    91b2:	de bf       	out	0x3e, r29	; 62
    91b4:	0f be       	out	0x3f, r0	; 63
    91b6:	cd bf       	out	0x3d, r28	; 61
    91b8:	cf 91       	pop	r28
    91ba:	df 91       	pop	r29
    91bc:	1f 91       	pop	r17
    91be:	0f 91       	pop	r16
    91c0:	ff 90       	pop	r15
    91c2:	ef 90       	pop	r14
    91c4:	df 90       	pop	r13
    91c6:	cf 90       	pop	r12
    91c8:	bf 90       	pop	r11
    91ca:	af 90       	pop	r10
    91cc:	9f 90       	pop	r9
    91ce:	8f 90       	pop	r8
    91d0:	7f 90       	pop	r7
    91d2:	6f 90       	pop	r6
    91d4:	5f 90       	pop	r5
    91d6:	4f 90       	pop	r4
    91d8:	3f 90       	pop	r3
    91da:	2f 90       	pop	r2
    91dc:	08 95       	ret
		Format[8] = '0'+Param->Prec;
		uint32_t Div=PowL10(Param->Prec);
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
	}
	else {
		Format[5] = '\0';
    91de:	1e 82       	std	Y+6, r1	; 0x06
		sprintf(Param->Pos, Format, Val);
    91e0:	8d b7       	in	r24, 0x3d	; 61
    91e2:	9e b7       	in	r25, 0x3e	; 62
    91e4:	08 97       	sbiw	r24, 0x08	; 8
    91e6:	0f b6       	in	r0, 0x3f	; 63
    91e8:	f8 94       	cli
    91ea:	9e bf       	out	0x3e, r25	; 62
    91ec:	0f be       	out	0x3f, r0	; 63
    91ee:	8d bf       	out	0x3d, r24	; 61
    91f0:	ed b7       	in	r30, 0x3d	; 61
    91f2:	fe b7       	in	r31, 0x3e	; 62
    91f4:	31 96       	adiw	r30, 0x01	; 1
    91f6:	d3 01       	movw	r26, r6
    91f8:	8d 91       	ld	r24, X+
    91fa:	9c 91       	ld	r25, X
    91fc:	ad b7       	in	r26, 0x3d	; 61
    91fe:	be b7       	in	r27, 0x3e	; 62
    9200:	12 96       	adiw	r26, 0x02	; 2
    9202:	9c 93       	st	X, r25
    9204:	8e 93       	st	-X, r24
    9206:	11 97       	sbiw	r26, 0x01	; 1
    9208:	81 e0       	ldi	r24, 0x01	; 1
    920a:	90 e0       	ldi	r25, 0x00	; 0
    920c:	8c 0f       	add	r24, r28
    920e:	9d 1f       	adc	r25, r29
    9210:	93 83       	std	Z+3, r25	; 0x03
    9212:	82 83       	std	Z+2, r24	; 0x02
    9214:	24 82       	std	Z+4, r2	; 0x04
    9216:	35 82       	std	Z+5, r3	; 0x05
    9218:	46 82       	std	Z+6, r4	; 0x06
    921a:	57 82       	std	Z+7, r5	; 0x07
    921c:	0e 94 22 85 	call	0x10a44	; 0x10a44 <sprintf>
    9220:	ad b7       	in	r26, 0x3d	; 61
    9222:	be b7       	in	r27, 0x3e	; 62
    9224:	18 96       	adiw	r26, 0x08	; 8
    9226:	0f b6       	in	r0, 0x3f	; 63
    9228:	f8 94       	cli
    922a:	be bf       	out	0x3e, r27	; 62
    922c:	0f be       	out	0x3f, r0	; 63
    922e:	ad bf       	out	0x3d, r26	; 61
    9230:	bd cf       	rjmp	.-134    	; 0x91ac <Put_zDVal+0x1a6>
void 
Put_zDVal(uint32_t Val, T_Param *Param)
{
	uint32_t Idx = 0xFFFFFFFF-Val;
	if(Param->Txt && Idx<2) {
		Param->Txt += Idx;
    9232:	88 0f       	add	r24, r24
    9234:	99 1f       	adc	r25, r25
    9236:	28 0f       	add	r18, r24
    9238:	39 1f       	adc	r19, r25
    923a:	fa 01       	movw	r30, r20
    923c:	35 83       	std	Z+5, r19	; 0x05
    923e:	24 83       	std	Z+4, r18	; 0x04
		PutEnum(Param);
    9240:	ca 01       	movw	r24, r20
    9242:	0e 94 84 44 	call	0x8908	; 0x8908 <PutEnum>
    9246:	b2 cf       	rjmp	.-156    	; 0x91ac <Put_zDVal+0x1a6>

00009248 <Put_sDVal>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Put_sDVal - print signed Longint in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_sDVal(int32_t Val, T_Param *Param)
{
    9248:	cf 92       	push	r12
    924a:	df 92       	push	r13
    924c:	ef 92       	push	r14
    924e:	ff 92       	push	r15
    9250:	0f 93       	push	r16
    9252:	1f 93       	push	r17
    9254:	df 93       	push	r29
    9256:	cf 93       	push	r28
    9258:	cd b7       	in	r28, 0x3d	; 61
    925a:	de b7       	in	r29, 0x3e	; 62
    925c:	2d 97       	sbiw	r28, 0x0d	; 13
    925e:	0f b6       	in	r0, 0x3f	; 63
    9260:	f8 94       	cli
    9262:	de bf       	out	0x3e, r29	; 62
    9264:	0f be       	out	0x3f, r0	; 63
    9266:	cd bf       	out	0x3d, r28	; 61
    9268:	6b 01       	movw	r12, r22
    926a:	7c 01       	movw	r14, r24
    926c:	8a 01       	movw	r16, r20
	uint32_t Idx = 0x80000000+Val;
	if(Param->Txt && Idx<2) {
    926e:	da 01       	movw	r26, r20
    9270:	14 96       	adiw	r26, 0x04	; 4
    9272:	2d 91       	ld	r18, X+
    9274:	3c 91       	ld	r19, X
    9276:	15 97       	sbiw	r26, 0x05	; 5
    9278:	21 15       	cp	r18, r1
    927a:	31 05       	cpc	r19, r1
    927c:	61 f0       	breq	.+24     	; 0x9296 <Put_sDVal+0x4e>
// Put_sDVal - print signed Longint in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_sDVal(int32_t Val, T_Param *Param)
{
	uint32_t Idx = 0x80000000+Val;
    927e:	dc 01       	movw	r26, r24
    9280:	cb 01       	movw	r24, r22
    9282:	80 50       	subi	r24, 0x00	; 0
    9284:	90 40       	sbci	r25, 0x00	; 0
    9286:	a0 40       	sbci	r26, 0x00	; 0
    9288:	b0 48       	sbci	r27, 0x80	; 128
	if(Param->Txt && Idx<2) {
    928a:	82 30       	cpi	r24, 0x02	; 2
    928c:	91 05       	cpc	r25, r1
    928e:	a1 05       	cpc	r26, r1
    9290:	b1 05       	cpc	r27, r1
    9292:	08 f4       	brcc	.+2      	; 0x9296 <Put_sDVal+0x4e>
    9294:	f7 c0       	rjmp	.+494    	; 0x9484 <Put_sDVal+0x23c>
		Param->Txt += Idx;
		PutEnum(Param);
		return;
	}
	// standart specificator to print Longint in string
	if(Param->Size>9){
    9296:	d8 01       	movw	r26, r16
    9298:	13 96       	adiw	r26, 0x03	; 3
    929a:	8c 91       	ld	r24, X
    929c:	8a 30       	cpi	r24, 0x0A	; 10
    929e:	f8 f0       	brcs	.+62     	; 0x92de <Put_sDVal+0x96>
		char Format[] = "%+1 ld";
    92a0:	9e 01       	movw	r18, r28
    92a2:	29 5f       	subi	r18, 0xF9	; 249
    92a4:	3f 4f       	sbci	r19, 0xFF	; 255
    92a6:	d9 01       	movw	r26, r18
    92a8:	e3 e5       	ldi	r30, 0x53	; 83
    92aa:	f2 e0       	ldi	r31, 0x02	; 2
    92ac:	87 e0       	ldi	r24, 0x07	; 7
    92ae:	01 90       	ld	r0, Z+
    92b0:	0d 92       	st	X+, r0
    92b2:	81 50       	subi	r24, 0x01	; 1
    92b4:	e1 f7       	brne	.-8      	; 0x92ae <Put_sDVal+0x66>
		Format[3] = '0'+Param->Size%10;
    92b6:	f8 01       	movw	r30, r16
    92b8:	83 81       	ldd	r24, Z+3	; 0x03
    92ba:	6a e0       	ldi	r22, 0x0A	; 10
    92bc:	0e 94 ab 87 	call	0x10f56	; 0x10f56 <__udivmodqi4>
    92c0:	90 5d       	subi	r25, 0xD0	; 208
    92c2:	9a 87       	std	Y+10, r25	; 0x0a
		sprintf(Param->Pos, Format, Val);
    92c4:	8d b7       	in	r24, 0x3d	; 61
    92c6:	9e b7       	in	r25, 0x3e	; 62
    92c8:	08 97       	sbiw	r24, 0x08	; 8
    92ca:	0f b6       	in	r0, 0x3f	; 63
    92cc:	f8 94       	cli
    92ce:	9e bf       	out	0x3e, r25	; 62
    92d0:	0f be       	out	0x3f, r0	; 63
    92d2:	8d bf       	out	0x3d, r24	; 61
    92d4:	ed b7       	in	r30, 0x3d	; 61
    92d6:	fe b7       	in	r31, 0x3e	; 62
    92d8:	31 96       	adiw	r30, 0x01	; 1
    92da:	d8 01       	movw	r26, r16
    92dc:	1a c0       	rjmp	.+52     	; 0x9312 <Put_sDVal+0xca>
	}
	else{
		char Format[] = "%+ ld";
    92de:	9e 01       	movw	r18, r28
    92e0:	2f 5f       	subi	r18, 0xFF	; 255
    92e2:	3f 4f       	sbci	r19, 0xFF	; 255
    92e4:	d9 01       	movw	r26, r18
    92e6:	ea e5       	ldi	r30, 0x5A	; 90
    92e8:	f2 e0       	ldi	r31, 0x02	; 2
    92ea:	86 e0       	ldi	r24, 0x06	; 6
    92ec:	01 90       	ld	r0, Z+
    92ee:	0d 92       	st	X+, r0
    92f0:	81 50       	subi	r24, 0x01	; 1
    92f2:	e1 f7       	brne	.-8      	; 0x92ec <Put_sDVal+0xa4>
		Format[2] = '0'+Param->Size;
    92f4:	d8 01       	movw	r26, r16
    92f6:	13 96       	adiw	r26, 0x03	; 3
    92f8:	8c 91       	ld	r24, X
    92fa:	13 97       	sbiw	r26, 0x03	; 3
    92fc:	80 5d       	subi	r24, 0xD0	; 208
    92fe:	8b 83       	std	Y+3, r24	; 0x03
		sprintf(Param->Pos, Format, Val);
    9300:	ed b7       	in	r30, 0x3d	; 61
    9302:	fe b7       	in	r31, 0x3e	; 62
    9304:	38 97       	sbiw	r30, 0x08	; 8
    9306:	0f b6       	in	r0, 0x3f	; 63
    9308:	f8 94       	cli
    930a:	fe bf       	out	0x3e, r31	; 62
    930c:	0f be       	out	0x3f, r0	; 63
    930e:	ed bf       	out	0x3d, r30	; 61
    9310:	31 96       	adiw	r30, 0x01	; 1
    9312:	8d 91       	ld	r24, X+
    9314:	9c 91       	ld	r25, X
    9316:	ad b7       	in	r26, 0x3d	; 61
    9318:	be b7       	in	r27, 0x3e	; 62
    931a:	12 96       	adiw	r26, 0x02	; 2
    931c:	9c 93       	st	X, r25
    931e:	8e 93       	st	-X, r24
    9320:	11 97       	sbiw	r26, 0x01	; 1
    9322:	33 83       	std	Z+3, r19	; 0x03
    9324:	22 83       	std	Z+2, r18	; 0x02
    9326:	c4 82       	std	Z+4, r12	; 0x04
    9328:	d5 82       	std	Z+5, r13	; 0x05
    932a:	e6 82       	std	Z+6, r14	; 0x06
    932c:	f7 82       	std	Z+7, r15	; 0x07
    932e:	0e 94 22 85 	call	0x10a44	; 0x10a44 <sprintf>
    9332:	ed b7       	in	r30, 0x3d	; 61
    9334:	fe b7       	in	r31, 0x3e	; 62
    9336:	38 96       	adiw	r30, 0x08	; 8
    9338:	0f b6       	in	r0, 0x3f	; 63
    933a:	f8 94       	cli
    933c:	fe bf       	out	0x3e, r31	; 62
    933e:	0f be       	out	0x3f, r0	; 63
    9340:	ed bf       	out	0x3d, r30	; 61
	}
	//Delete sign if zero
	if(!Val)Param->Pos[Param->Size-2] = ' ';
    9342:	c1 14       	cp	r12, r1
    9344:	d1 04       	cpc	r13, r1
    9346:	e1 04       	cpc	r14, r1
    9348:	f1 04       	cpc	r15, r1
    934a:	59 f4       	brne	.+22     	; 0x9362 <Put_sDVal+0x11a>
    934c:	d8 01       	movw	r26, r16
    934e:	13 96       	adiw	r26, 0x03	; 3
    9350:	8c 91       	ld	r24, X
    9352:	13 97       	sbiw	r26, 0x03	; 3
    9354:	ed 91       	ld	r30, X+
    9356:	fc 91       	ld	r31, X
    9358:	e8 0f       	add	r30, r24
    935a:	f1 1d       	adc	r31, r1
    935c:	32 97       	sbiw	r30, 0x02	; 2
    935e:	80 e2       	ldi	r24, 0x20	; 32
    9360:	80 83       	st	Z, r24

	if(Param->Prec){
    9362:	f8 01       	movw	r30, r16
    9364:	92 81       	ldd	r25, Z+2	; 0x02
    9366:	99 23       	and	r25, r25
    9368:	09 f4       	brne	.+2      	; 0x936c <Put_sDVal+0x124>
    936a:	41 c0       	rjmp	.+130    	; 0x93ee <Put_sDVal+0x1a6>
		//Insert decimal point
		for(uint8_t i=0; i< Param->Size - Param->Prec; i++){
    936c:	83 81       	ldd	r24, Z+3	; 0x03
    936e:	28 2f       	mov	r18, r24
    9370:	30 e0       	ldi	r19, 0x00	; 0
    9372:	29 1b       	sub	r18, r25
    9374:	31 09       	sbc	r19, r1
    9376:	12 16       	cp	r1, r18
    9378:	13 06       	cpc	r1, r19
    937a:	d4 f4       	brge	.+52     	; 0x93b0 <Put_sDVal+0x168>
    937c:	40 e0       	ldi	r20, 0x00	; 0
    937e:	80 e0       	ldi	r24, 0x00	; 0
    9380:	90 e0       	ldi	r25, 0x00	; 0
			Param->Pos[i] = Param->Pos[i+1];
    9382:	d8 01       	movw	r26, r16
    9384:	ed 91       	ld	r30, X+
    9386:	fc 91       	ld	r31, X
    9388:	11 97       	sbiw	r26, 0x01	; 1
    938a:	e8 0f       	add	r30, r24
    938c:	f9 1f       	adc	r31, r25
    938e:	81 81       	ldd	r24, Z+1	; 0x01
    9390:	80 83       	st	Z, r24
	//Delete sign if zero
	if(!Val)Param->Pos[Param->Size-2] = ' ';

	if(Param->Prec){
		//Insert decimal point
		for(uint8_t i=0; i< Param->Size - Param->Prec; i++){
    9392:	4f 5f       	subi	r20, 0xFF	; 255
    9394:	13 96       	adiw	r26, 0x03	; 3
    9396:	8c 91       	ld	r24, X
    9398:	13 97       	sbiw	r26, 0x03	; 3
    939a:	28 2f       	mov	r18, r24
    939c:	30 e0       	ldi	r19, 0x00	; 0
    939e:	12 96       	adiw	r26, 0x02	; 2
    93a0:	8c 91       	ld	r24, X
    93a2:	28 1b       	sub	r18, r24
    93a4:	31 09       	sbc	r19, r1
    93a6:	84 2f       	mov	r24, r20
    93a8:	90 e0       	ldi	r25, 0x00	; 0
    93aa:	82 17       	cp	r24, r18
    93ac:	93 07       	cpc	r25, r19
    93ae:	4c f3       	brlt	.-46     	; 0x9382 <Put_sDVal+0x13a>
			Param->Pos[i] = Param->Pos[i+1];
		}
		Param->Pos[Param->Size - Param->Prec-1] = '.';
    93b0:	d8 01       	movw	r26, r16
    93b2:	ed 91       	ld	r30, X+
    93b4:	fc 91       	ld	r31, X
    93b6:	11 97       	sbiw	r26, 0x01	; 1
    93b8:	e2 0f       	add	r30, r18
    93ba:	f3 1f       	adc	r31, r19
    93bc:	31 97       	sbiw	r30, 0x01	; 1
    93be:	8e e2       	ldi	r24, 0x2E	; 46
    93c0:	80 83       	st	Z, r24
		//Fill zeros and shift sign for correct view
		char c = Param->Pos[Param->Size - Param->Prec-2];
    93c2:	4d 91       	ld	r20, X+
    93c4:	5c 91       	ld	r21, X
    93c6:	11 97       	sbiw	r26, 0x01	; 1
    93c8:	13 96       	adiw	r26, 0x03	; 3
    93ca:	9c 91       	ld	r25, X
    93cc:	13 97       	sbiw	r26, 0x03	; 3
    93ce:	e9 2f       	mov	r30, r25
    93d0:	f0 e0       	ldi	r31, 0x00	; 0
    93d2:	12 96       	adiw	r26, 0x02	; 2
    93d4:	8c 91       	ld	r24, X
    93d6:	e8 1b       	sub	r30, r24
    93d8:	f1 09       	sbc	r31, r1
    93da:	e4 0f       	add	r30, r20
    93dc:	f5 1f       	adc	r31, r21
    93de:	32 97       	sbiw	r30, 0x02	; 2
    93e0:	e0 81       	ld	r30, Z
		if(c ==' ' || c =='+' || c =='-'){
    93e2:	e0 32       	cpi	r30, 0x20	; 32
    93e4:	99 f0       	breq	.+38     	; 0x940c <Put_sDVal+0x1c4>
    93e6:	eb 32       	cpi	r30, 0x2B	; 43
    93e8:	89 f0       	breq	.+34     	; 0x940c <Put_sDVal+0x1c4>
    93ea:	ed 32       	cpi	r30, 0x2D	; 45
    93ec:	79 f0       	breq	.+30     	; 0x940c <Put_sDVal+0x1c4>
				}
			}
		}
	}

}
    93ee:	2d 96       	adiw	r28, 0x0d	; 13
    93f0:	0f b6       	in	r0, 0x3f	; 63
    93f2:	f8 94       	cli
    93f4:	de bf       	out	0x3e, r29	; 62
    93f6:	0f be       	out	0x3f, r0	; 63
    93f8:	cd bf       	out	0x3d, r28	; 61
    93fa:	cf 91       	pop	r28
    93fc:	df 91       	pop	r29
    93fe:	1f 91       	pop	r17
    9400:	0f 91       	pop	r16
    9402:	ff 90       	pop	r15
    9404:	ef 90       	pop	r14
    9406:	df 90       	pop	r13
    9408:	cf 90       	pop	r12
    940a:	08 95       	ret
		}
		Param->Pos[Param->Size - Param->Prec-1] = '.';
		//Fill zeros and shift sign for correct view
		char c = Param->Pos[Param->Size - Param->Prec-2];
		if(c ==' ' || c =='+' || c =='-'){
			for(uint8_t i=Param->Size-1; i>1; i--){
    940c:	e9 2f       	mov	r30, r25
    940e:	e1 50       	subi	r30, 0x01	; 1
    9410:	e2 30       	cpi	r30, 0x02	; 2
    9412:	68 f3       	brcs	.-38     	; 0x93ee <Put_sDVal+0x1a6>
				if(Param->Pos[i] == ' '|| Param->Pos[i] == '+' || Param->Pos[i] == '-' ) Param->Pos[i]='0';
    9414:	90 e3       	ldi	r25, 0x30	; 48
    9416:	09 c0       	rjmp	.+18     	; 0x942a <Put_sDVal+0x1e2>
    9418:	8b 32       	cpi	r24, 0x2B	; 43
    941a:	79 f0       	breq	.+30     	; 0x943a <Put_sDVal+0x1f2>
    941c:	8d 32       	cpi	r24, 0x2D	; 45
    941e:	69 f0       	breq	.+26     	; 0x943a <Put_sDVal+0x1f2>
				if(Param->Pos[i] == '.'){
    9420:	8e 32       	cpi	r24, 0x2E	; 46
    9422:	a9 f0       	breq	.+42     	; 0x944e <Put_sDVal+0x206>
		}
		Param->Pos[Param->Size - Param->Prec-1] = '.';
		//Fill zeros and shift sign for correct view
		char c = Param->Pos[Param->Size - Param->Prec-2];
		if(c ==' ' || c =='+' || c =='-'){
			for(uint8_t i=Param->Size-1; i>1; i--){
    9424:	e1 50       	subi	r30, 0x01	; 1
    9426:	e2 30       	cpi	r30, 0x02	; 2
    9428:	10 f3       	brcs	.-60     	; 0x93ee <Put_sDVal+0x1a6>
				if(Param->Pos[i] == ' '|| Param->Pos[i] == '+' || Param->Pos[i] == '-' ) Param->Pos[i]='0';
    942a:	2e 2f       	mov	r18, r30
    942c:	30 e0       	ldi	r19, 0x00	; 0
    942e:	da 01       	movw	r26, r20
    9430:	a2 0f       	add	r26, r18
    9432:	b3 1f       	adc	r27, r19
    9434:	8c 91       	ld	r24, X
    9436:	80 32       	cpi	r24, 0x20	; 32
    9438:	79 f7       	brne	.-34     	; 0x9418 <Put_sDVal+0x1d0>
    943a:	9c 93       	st	X, r25
    943c:	d8 01       	movw	r26, r16
    943e:	4d 91       	ld	r20, X+
    9440:	5c 91       	ld	r21, X
    9442:	da 01       	movw	r26, r20
    9444:	a2 0f       	add	r26, r18
    9446:	b3 1f       	adc	r27, r19
    9448:	8c 91       	ld	r24, X
				if(Param->Pos[i] == '.'){
    944a:	8e 32       	cpi	r24, 0x2E	; 46
    944c:	59 f7       	brne	.-42     	; 0x9424 <Put_sDVal+0x1dc>
					Param->Pos[i-1]='0';
    944e:	11 97       	sbiw	r26, 0x01	; 1
    9450:	80 e3       	ldi	r24, 0x30	; 48
    9452:	8c 93       	st	X, r24
					if(Val>0)Param->Pos[i-2]='+';
    9454:	1c 14       	cp	r1, r12
    9456:	1d 04       	cpc	r1, r13
    9458:	1e 04       	cpc	r1, r14
    945a:	1f 04       	cpc	r1, r15
    945c:	44 f4       	brge	.+16     	; 0x946e <Put_sDVal+0x226>
    945e:	d8 01       	movw	r26, r16
    9460:	ed 91       	ld	r30, X+
    9462:	fc 91       	ld	r31, X
    9464:	e2 0f       	add	r30, r18
    9466:	f3 1f       	adc	r31, r19
    9468:	32 97       	sbiw	r30, 0x02	; 2
    946a:	8b e2       	ldi	r24, 0x2B	; 43
    946c:	80 83       	st	Z, r24
					if(Val<0)Param->Pos[i-2]='-';
    946e:	f7 fe       	sbrs	r15, 7
    9470:	be cf       	rjmp	.-132    	; 0x93ee <Put_sDVal+0x1a6>
    9472:	d8 01       	movw	r26, r16
    9474:	ed 91       	ld	r30, X+
    9476:	fc 91       	ld	r31, X
    9478:	e2 0f       	add	r30, r18
    947a:	f3 1f       	adc	r31, r19
    947c:	32 97       	sbiw	r30, 0x02	; 2
    947e:	8d e2       	ldi	r24, 0x2D	; 45
    9480:	80 83       	st	Z, r24
    9482:	b5 cf       	rjmp	.-150    	; 0x93ee <Put_sDVal+0x1a6>
void
Put_sDVal(int32_t Val, T_Param *Param)
{
	uint32_t Idx = 0x80000000+Val;
	if(Param->Txt && Idx<2) {
		Param->Txt += Idx;
    9484:	88 0f       	add	r24, r24
    9486:	99 1f       	adc	r25, r25
    9488:	28 0f       	add	r18, r24
    948a:	39 1f       	adc	r19, r25
    948c:	fa 01       	movw	r30, r20
    948e:	35 83       	std	Z+5, r19	; 0x05
    9490:	24 83       	std	Z+4, r18	; 0x04
		PutEnum(Param);
    9492:	ca 01       	movw	r24, r20
    9494:	0e 94 84 44 	call	0x8908	; 0x8908 <PutEnum>
    9498:	aa cf       	rjmp	.-172    	; 0x93ee <Put_sDVal+0x1a6>

0000949a <PutDVal>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// PutDVal - print unsigned Longint in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
PutDVal(uint32_t Val, T_Param *Param)
{
    949a:	2f 92       	push	r2
    949c:	3f 92       	push	r3
    949e:	4f 92       	push	r4
    94a0:	5f 92       	push	r5
    94a2:	6f 92       	push	r6
    94a4:	7f 92       	push	r7
    94a6:	8f 92       	push	r8
    94a8:	9f 92       	push	r9
    94aa:	af 92       	push	r10
    94ac:	bf 92       	push	r11
    94ae:	cf 92       	push	r12
    94b0:	df 92       	push	r13
    94b2:	ef 92       	push	r14
    94b4:	ff 92       	push	r15
    94b6:	0f 93       	push	r16
    94b8:	1f 93       	push	r17
    94ba:	df 93       	push	r29
    94bc:	cf 93       	push	r28
    94be:	cd b7       	in	r28, 0x3d	; 61
    94c0:	de b7       	in	r29, 0x3e	; 62
    94c2:	2b 97       	sbiw	r28, 0x0b	; 11
    94c4:	0f b6       	in	r0, 0x3f	; 63
    94c6:	f8 94       	cli
    94c8:	de bf       	out	0x3e, r29	; 62
    94ca:	0f be       	out	0x3f, r0	; 63
    94cc:	cd bf       	out	0x3d, r28	; 61
    94ce:	1b 01       	movw	r2, r22
    94d0:	2c 01       	movw	r4, r24
    94d2:	3a 01       	movw	r6, r20
	uint32_t Idx = 0xFFFFFFFF-Val;
	if(Param->Txt && Idx<2) {
    94d4:	da 01       	movw	r26, r20
    94d6:	14 96       	adiw	r26, 0x04	; 4
    94d8:	2d 91       	ld	r18, X+
    94da:	3c 91       	ld	r19, X
    94dc:	15 97       	sbiw	r26, 0x05	; 5
    94de:	21 15       	cp	r18, r1
    94e0:	31 05       	cpc	r19, r1
    94e2:	61 f0       	breq	.+24     	; 0x94fc <PutDVal+0x62>
// PutDVal - print unsigned Longint in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
PutDVal(uint32_t Val, T_Param *Param)
{
	uint32_t Idx = 0xFFFFFFFF-Val;
    94e4:	dc 01       	movw	r26, r24
    94e6:	cb 01       	movw	r24, r22
    94e8:	80 95       	com	r24
    94ea:	90 95       	com	r25
    94ec:	a0 95       	com	r26
    94ee:	b0 95       	com	r27
	if(Param->Txt && Idx<2) {
    94f0:	82 30       	cpi	r24, 0x02	; 2
    94f2:	91 05       	cpc	r25, r1
    94f4:	a1 05       	cpc	r26, r1
    94f6:	b1 05       	cpc	r27, r1
    94f8:	08 f4       	brcc	.+2      	; 0x94fc <PutDVal+0x62>
    94fa:	e5 c0       	rjmp	.+458    	; 0x96c6 <PutDVal+0x22c>
		Param->Txt += Idx;
		PutEnum(Param);
		return;
	}

	if(Param->Size==10 && Param->Prec==0){
    94fc:	d3 01       	movw	r26, r6
    94fe:	13 96       	adiw	r26, 0x03	; 3
    9500:	8c 91       	ld	r24, X
    9502:	13 97       	sbiw	r26, 0x03	; 3
    9504:	8a 30       	cpi	r24, 0x0A	; 10
    9506:	09 f4       	brne	.+2      	; 0x950a <PutDVal+0x70>
    9508:	72 c0       	rjmp	.+228    	; 0x95ee <PutDVal+0x154>
		sprintf(Param->Pos, "%10lu", Val);
		return;
	}
	char Format[] = "% lu.%. lu";
    950a:	de 01       	movw	r26, r28
    950c:	11 96       	adiw	r26, 0x01	; 1
    950e:	e6 e6       	ldi	r30, 0x66	; 102
    9510:	f2 e0       	ldi	r31, 0x02	; 2
    9512:	8b e0       	ldi	r24, 0x0B	; 11
    9514:	01 90       	ld	r0, Z+
    9516:	0d 92       	st	X+, r0
    9518:	81 50       	subi	r24, 0x01	; 1
    951a:	e1 f7       	brne	.-8      	; 0x9514 <PutDVal+0x7a>
	Format[1] = '0'+Param->Size;
    951c:	d3 01       	movw	r26, r6
    951e:	13 96       	adiw	r26, 0x03	; 3
    9520:	2c 91       	ld	r18, X
    9522:	13 97       	sbiw	r26, 0x03	; 3
    9524:	20 5d       	subi	r18, 0xD0	; 208
    9526:	2a 83       	std	Y+2, r18	; 0x02
	if(Param->Prec) {
    9528:	12 96       	adiw	r26, 0x02	; 2
    952a:	9c 91       	ld	r25, X
    952c:	99 23       	and	r25, r25
    952e:	09 f4       	brne	.+2      	; 0x9532 <PutDVal+0x98>
    9530:	a0 c0       	rjmp	.+320    	; 0x9672 <PutDVal+0x1d8>
		Format[1] -= Param->Prec+1;
    9532:	89 2f       	mov	r24, r25
    9534:	80 95       	com	r24
    9536:	82 0f       	add	r24, r18
    9538:	8a 83       	std	Y+2, r24	; 0x02
		Format[7] = '0'+Param->Prec;
    953a:	90 5d       	subi	r25, 0xD0	; 208
    953c:	98 87       	std	Y+8, r25	; 0x08
    953e:	90 53       	subi	r25, 0x30	; 48
		uint32_t Div=PowL10(Param->Prec);
    9540:	09 2f       	mov	r16, r25
    9542:	f1 e0       	ldi	r31, 0x01	; 1
    9544:	8f 2e       	mov	r8, r31
    9546:	91 2c       	mov	r9, r1
    9548:	a1 2c       	mov	r10, r1
    954a:	b1 2c       	mov	r11, r1
		Pow *= 10;
    954c:	c5 01       	movw	r24, r10
    954e:	b4 01       	movw	r22, r8
    9550:	2a e0       	ldi	r18, 0x0A	; 10
    9552:	30 e0       	ldi	r19, 0x00	; 0
    9554:	40 e0       	ldi	r20, 0x00	; 0
    9556:	50 e0       	ldi	r21, 0x00	; 0
    9558:	0e 94 8c 87 	call	0x10f18	; 0x10f18 <__mulsi3>
    955c:	4b 01       	movw	r8, r22
    955e:	5c 01       	movw	r10, r24
    9560:	01 50       	subi	r16, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
	uint32_t Pow = 1;
	while(Exp--)
    9562:	a1 f7       	brne	.-24     	; 0x954c <PutDVal+0xb2>
    9564:	c2 01       	movw	r24, r4
    9566:	b1 01       	movw	r22, r2
    9568:	94 01       	movw	r18, r8
    956a:	a5 01       	movw	r20, r10
    956c:	0e 94 de 87 	call	0x10fbc	; 0x10fbc <__udivmodsi4>
    9570:	f6 2e       	mov	r15, r22
    9572:	e7 2e       	mov	r14, r23
    9574:	d8 2e       	mov	r13, r24
    9576:	c9 2e       	mov	r12, r25
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
    9578:	ed b7       	in	r30, 0x3d	; 61
    957a:	fe b7       	in	r31, 0x3e	; 62
    957c:	3c 97       	sbiw	r30, 0x0c	; 12
    957e:	0f b6       	in	r0, 0x3f	; 63
    9580:	f8 94       	cli
    9582:	fe bf       	out	0x3e, r31	; 62
    9584:	0f be       	out	0x3f, r0	; 63
    9586:	ed bf       	out	0x3d, r30	; 61
    9588:	0d b7       	in	r16, 0x3d	; 61
    958a:	1e b7       	in	r17, 0x3e	; 62
    958c:	0f 5f       	subi	r16, 0xFF	; 255
    958e:	1f 4f       	sbci	r17, 0xFF	; 255
    9590:	d3 01       	movw	r26, r6
    9592:	8d 91       	ld	r24, X+
    9594:	9c 91       	ld	r25, X
    9596:	92 83       	std	Z+2, r25	; 0x02
    9598:	81 83       	std	Z+1, r24	; 0x01
    959a:	81 e0       	ldi	r24, 0x01	; 1
    959c:	90 e0       	ldi	r25, 0x00	; 0
    959e:	8c 0f       	add	r24, r28
    95a0:	9d 1f       	adc	r25, r29
    95a2:	f8 01       	movw	r30, r16
    95a4:	93 83       	std	Z+3, r25	; 0x03
    95a6:	82 83       	std	Z+2, r24	; 0x02
    95a8:	c2 01       	movw	r24, r4
    95aa:	b1 01       	movw	r22, r2
    95ac:	a5 01       	movw	r20, r10
    95ae:	94 01       	movw	r18, r8
    95b0:	0e 94 de 87 	call	0x10fbc	; 0x10fbc <__udivmodsi4>
    95b4:	d8 01       	movw	r26, r16
    95b6:	14 96       	adiw	r26, 0x04	; 4
    95b8:	2d 93       	st	X+, r18
    95ba:	3d 93       	st	X+, r19
    95bc:	4d 93       	st	X+, r20
    95be:	5c 93       	st	X, r21
    95c0:	17 97       	sbiw	r26, 0x07	; 7
    95c2:	18 96       	adiw	r26, 0x08	; 8
    95c4:	fc 92       	st	X, r15
    95c6:	18 97       	sbiw	r26, 0x08	; 8
    95c8:	19 96       	adiw	r26, 0x09	; 9
    95ca:	ec 92       	st	X, r14
    95cc:	19 97       	sbiw	r26, 0x09	; 9
    95ce:	1a 96       	adiw	r26, 0x0a	; 10
    95d0:	dc 92       	st	X, r13
    95d2:	1a 97       	sbiw	r26, 0x0a	; 10
    95d4:	1b 96       	adiw	r26, 0x0b	; 11
    95d6:	cc 92       	st	X, r12
    95d8:	0e 94 22 85 	call	0x10a44	; 0x10a44 <sprintf>
    95dc:	ed b7       	in	r30, 0x3d	; 61
    95de:	fe b7       	in	r31, 0x3e	; 62
    95e0:	3c 96       	adiw	r30, 0x0c	; 12
    95e2:	0f b6       	in	r0, 0x3f	; 63
    95e4:	f8 94       	cli
    95e6:	fe bf       	out	0x3e, r31	; 62
    95e8:	0f be       	out	0x3f, r0	; 63
    95ea:	ed bf       	out	0x3d, r30	; 61
    95ec:	29 c0       	rjmp	.+82     	; 0x9640 <PutDVal+0x1a6>
		Param->Txt += Idx;
		PutEnum(Param);
		return;
	}

	if(Param->Size==10 && Param->Prec==0){
    95ee:	12 96       	adiw	r26, 0x02	; 2
    95f0:	8c 91       	ld	r24, X
    95f2:	12 97       	sbiw	r26, 0x02	; 2
    95f4:	88 23       	and	r24, r24
    95f6:	09 f0       	breq	.+2      	; 0x95fa <PutDVal+0x160>
    95f8:	88 cf       	rjmp	.-240    	; 0x950a <PutDVal+0x70>
		sprintf(Param->Pos, "%10lu", Val);
    95fa:	ed b7       	in	r30, 0x3d	; 61
    95fc:	fe b7       	in	r31, 0x3e	; 62
    95fe:	38 97       	sbiw	r30, 0x08	; 8
    9600:	0f b6       	in	r0, 0x3f	; 63
    9602:	f8 94       	cli
    9604:	fe bf       	out	0x3e, r31	; 62
    9606:	0f be       	out	0x3f, r0	; 63
    9608:	ed bf       	out	0x3d, r30	; 61
    960a:	31 96       	adiw	r30, 0x01	; 1
    960c:	8d 91       	ld	r24, X+
    960e:	9c 91       	ld	r25, X
    9610:	ad b7       	in	r26, 0x3d	; 61
    9612:	be b7       	in	r27, 0x3e	; 62
    9614:	12 96       	adiw	r26, 0x02	; 2
    9616:	9c 93       	st	X, r25
    9618:	8e 93       	st	-X, r24
    961a:	11 97       	sbiw	r26, 0x01	; 1
    961c:	80 e6       	ldi	r24, 0x60	; 96
    961e:	92 e0       	ldi	r25, 0x02	; 2
    9620:	93 83       	std	Z+3, r25	; 0x03
    9622:	82 83       	std	Z+2, r24	; 0x02
    9624:	24 82       	std	Z+4, r2	; 0x04
    9626:	35 82       	std	Z+5, r3	; 0x05
    9628:	46 82       	std	Z+6, r4	; 0x06
    962a:	57 82       	std	Z+7, r5	; 0x07
    962c:	0e 94 22 85 	call	0x10a44	; 0x10a44 <sprintf>
    9630:	ed b7       	in	r30, 0x3d	; 61
    9632:	fe b7       	in	r31, 0x3e	; 62
    9634:	38 96       	adiw	r30, 0x08	; 8
    9636:	0f b6       	in	r0, 0x3f	; 63
    9638:	f8 94       	cli
    963a:	fe bf       	out	0x3e, r31	; 62
    963c:	0f be       	out	0x3f, r0	; 63
    963e:	ed bf       	out	0x3d, r30	; 61
	}
	else {
		Format[4] = '\0';
		sprintf(Param->Pos, Format, Val);
	}
}
    9640:	2b 96       	adiw	r28, 0x0b	; 11
    9642:	0f b6       	in	r0, 0x3f	; 63
    9644:	f8 94       	cli
    9646:	de bf       	out	0x3e, r29	; 62
    9648:	0f be       	out	0x3f, r0	; 63
    964a:	cd bf       	out	0x3d, r28	; 61
    964c:	cf 91       	pop	r28
    964e:	df 91       	pop	r29
    9650:	1f 91       	pop	r17
    9652:	0f 91       	pop	r16
    9654:	ff 90       	pop	r15
    9656:	ef 90       	pop	r14
    9658:	df 90       	pop	r13
    965a:	cf 90       	pop	r12
    965c:	bf 90       	pop	r11
    965e:	af 90       	pop	r10
    9660:	9f 90       	pop	r9
    9662:	8f 90       	pop	r8
    9664:	7f 90       	pop	r7
    9666:	6f 90       	pop	r6
    9668:	5f 90       	pop	r5
    966a:	4f 90       	pop	r4
    966c:	3f 90       	pop	r3
    966e:	2f 90       	pop	r2
    9670:	08 95       	ret
		Format[7] = '0'+Param->Prec;
		uint32_t Div=PowL10(Param->Prec);
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
	}
	else {
		Format[4] = '\0';
    9672:	1d 82       	std	Y+5, r1	; 0x05
		sprintf(Param->Pos, Format, Val);
    9674:	8d b7       	in	r24, 0x3d	; 61
    9676:	9e b7       	in	r25, 0x3e	; 62
    9678:	08 97       	sbiw	r24, 0x08	; 8
    967a:	0f b6       	in	r0, 0x3f	; 63
    967c:	f8 94       	cli
    967e:	9e bf       	out	0x3e, r25	; 62
    9680:	0f be       	out	0x3f, r0	; 63
    9682:	8d bf       	out	0x3d, r24	; 61
    9684:	ed b7       	in	r30, 0x3d	; 61
    9686:	fe b7       	in	r31, 0x3e	; 62
    9688:	31 96       	adiw	r30, 0x01	; 1
    968a:	d3 01       	movw	r26, r6
    968c:	8d 91       	ld	r24, X+
    968e:	9c 91       	ld	r25, X
    9690:	ad b7       	in	r26, 0x3d	; 61
    9692:	be b7       	in	r27, 0x3e	; 62
    9694:	12 96       	adiw	r26, 0x02	; 2
    9696:	9c 93       	st	X, r25
    9698:	8e 93       	st	-X, r24
    969a:	11 97       	sbiw	r26, 0x01	; 1
    969c:	81 e0       	ldi	r24, 0x01	; 1
    969e:	90 e0       	ldi	r25, 0x00	; 0
    96a0:	8c 0f       	add	r24, r28
    96a2:	9d 1f       	adc	r25, r29
    96a4:	93 83       	std	Z+3, r25	; 0x03
    96a6:	82 83       	std	Z+2, r24	; 0x02
    96a8:	24 82       	std	Z+4, r2	; 0x04
    96aa:	35 82       	std	Z+5, r3	; 0x05
    96ac:	46 82       	std	Z+6, r4	; 0x06
    96ae:	57 82       	std	Z+7, r5	; 0x07
    96b0:	0e 94 22 85 	call	0x10a44	; 0x10a44 <sprintf>
    96b4:	ad b7       	in	r26, 0x3d	; 61
    96b6:	be b7       	in	r27, 0x3e	; 62
    96b8:	18 96       	adiw	r26, 0x08	; 8
    96ba:	0f b6       	in	r0, 0x3f	; 63
    96bc:	f8 94       	cli
    96be:	be bf       	out	0x3e, r27	; 62
    96c0:	0f be       	out	0x3f, r0	; 63
    96c2:	ad bf       	out	0x3d, r26	; 61
    96c4:	bd cf       	rjmp	.-134    	; 0x9640 <PutDVal+0x1a6>
void
PutDVal(uint32_t Val, T_Param *Param)
{
	uint32_t Idx = 0xFFFFFFFF-Val;
	if(Param->Txt && Idx<2) {
		Param->Txt += Idx;
    96c6:	88 0f       	add	r24, r24
    96c8:	99 1f       	adc	r25, r25
    96ca:	28 0f       	add	r18, r24
    96cc:	39 1f       	adc	r19, r25
    96ce:	fa 01       	movw	r30, r20
    96d0:	35 83       	std	Z+5, r19	; 0x05
    96d2:	24 83       	std	Z+4, r18	; 0x04
		PutEnum(Param);
    96d4:	ca 01       	movw	r24, r20
    96d6:	0e 94 84 44 	call	0x8908	; 0x8908 <PutEnum>
    96da:	b2 cf       	rjmp	.-156    	; 0x9640 <PutDVal+0x1a6>

000096dc <Put_zVal_h>:
	}
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_zVal_h(uint32_t Val, char Type, T_Param *Param)
{
    96dc:	1f 93       	push	r17
    96de:	17 2f       	mov	r17, r23
    96e0:	58 2f       	mov	r21, r24
    96e2:	79 2f       	mov	r23, r25
    96e4:	d9 01       	movw	r26, r18
	if(Type=='b') sprintf(Param->Pos, "%02hx", (uint8_t)Val);
    96e6:	42 36       	cpi	r20, 0x62	; 98
    96e8:	71 f1       	breq	.+92     	; 0x9746 <Put_zVal_h+0x6a>
	if(Type=='w') sprintf(Param->Pos, "%04x", (uint16_t)Val);
    96ea:	47 37       	cpi	r20, 0x77	; 119
    96ec:	09 f4       	brne	.+2      	; 0x96f0 <Put_zVal_h+0x14>
    96ee:	4a c0       	rjmp	.+148    	; 0x9784 <Put_zVal_h+0xa8>
	if(Type=='l') sprintf(Param->Pos, "%08lx", Val);
    96f0:	4c 36       	cpi	r20, 0x6C	; 108
    96f2:	11 f0       	breq	.+4      	; 0x96f8 <Put_zVal_h+0x1c>
}
    96f4:	1f 91       	pop	r17
    96f6:	08 95       	ret
void
Put_zVal_h(uint32_t Val, char Type, T_Param *Param)
{
	if(Type=='b') sprintf(Param->Pos, "%02hx", (uint8_t)Val);
	if(Type=='w') sprintf(Param->Pos, "%04x", (uint16_t)Val);
	if(Type=='l') sprintf(Param->Pos, "%08lx", Val);
    96f8:	8d b7       	in	r24, 0x3d	; 61
    96fa:	9e b7       	in	r25, 0x3e	; 62
    96fc:	08 97       	sbiw	r24, 0x08	; 8
    96fe:	0f b6       	in	r0, 0x3f	; 63
    9700:	f8 94       	cli
    9702:	9e bf       	out	0x3e, r25	; 62
    9704:	0f be       	out	0x3f, r0	; 63
    9706:	8d bf       	out	0x3d, r24	; 61
    9708:	ed b7       	in	r30, 0x3d	; 61
    970a:	fe b7       	in	r31, 0x3e	; 62
    970c:	31 96       	adiw	r30, 0x01	; 1
    970e:	8d 91       	ld	r24, X+
    9710:	9c 91       	ld	r25, X
    9712:	ad b7       	in	r26, 0x3d	; 61
    9714:	be b7       	in	r27, 0x3e	; 62
    9716:	12 96       	adiw	r26, 0x02	; 2
    9718:	9c 93       	st	X, r25
    971a:	8e 93       	st	-X, r24
    971c:	11 97       	sbiw	r26, 0x01	; 1
    971e:	8c e7       	ldi	r24, 0x7C	; 124
    9720:	92 e0       	ldi	r25, 0x02	; 2
    9722:	93 83       	std	Z+3, r25	; 0x03
    9724:	82 83       	std	Z+2, r24	; 0x02
    9726:	64 83       	std	Z+4, r22	; 0x04
    9728:	15 83       	std	Z+5, r17	; 0x05
    972a:	56 83       	std	Z+6, r21	; 0x06
    972c:	77 83       	std	Z+7, r23	; 0x07
    972e:	0e 94 22 85 	call	0x10a44	; 0x10a44 <sprintf>
    9732:	8d b7       	in	r24, 0x3d	; 61
    9734:	9e b7       	in	r25, 0x3e	; 62
    9736:	08 96       	adiw	r24, 0x08	; 8
    9738:	0f b6       	in	r0, 0x3f	; 63
    973a:	f8 94       	cli
    973c:	9e bf       	out	0x3e, r25	; 62
    973e:	0f be       	out	0x3f, r0	; 63
    9740:	8d bf       	out	0x3d, r24	; 61
}
    9742:	1f 91       	pop	r17
    9744:	08 95       	ret
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_zVal_h(uint32_t Val, char Type, T_Param *Param)
{
	if(Type=='b') sprintf(Param->Pos, "%02hx", (uint8_t)Val);
    9746:	00 d0       	rcall	.+0      	; 0x9748 <Put_zVal_h+0x6c>
    9748:	00 d0       	rcall	.+0      	; 0x974a <Put_zVal_h+0x6e>
    974a:	ed b7       	in	r30, 0x3d	; 61
    974c:	fe b7       	in	r31, 0x3e	; 62
    974e:	31 96       	adiw	r30, 0x01	; 1
    9750:	8d 91       	ld	r24, X+
    9752:	9c 91       	ld	r25, X
    9754:	ad b7       	in	r26, 0x3d	; 61
    9756:	be b7       	in	r27, 0x3e	; 62
    9758:	12 96       	adiw	r26, 0x02	; 2
    975a:	9c 93       	st	X, r25
    975c:	8e 93       	st	-X, r24
    975e:	11 97       	sbiw	r26, 0x01	; 1
    9760:	81 e7       	ldi	r24, 0x71	; 113
    9762:	92 e0       	ldi	r25, 0x02	; 2
    9764:	93 83       	std	Z+3, r25	; 0x03
    9766:	82 83       	std	Z+2, r24	; 0x02
    9768:	64 83       	std	Z+4, r22	; 0x04
    976a:	15 82       	std	Z+5, r1	; 0x05
    976c:	0e 94 22 85 	call	0x10a44	; 0x10a44 <sprintf>
    9770:	8d b7       	in	r24, 0x3d	; 61
    9772:	9e b7       	in	r25, 0x3e	; 62
    9774:	06 96       	adiw	r24, 0x06	; 6
    9776:	0f b6       	in	r0, 0x3f	; 63
    9778:	f8 94       	cli
    977a:	9e bf       	out	0x3e, r25	; 62
    977c:	0f be       	out	0x3f, r0	; 63
    977e:	8d bf       	out	0x3d, r24	; 61
	if(Type=='w') sprintf(Param->Pos, "%04x", (uint16_t)Val);
	if(Type=='l') sprintf(Param->Pos, "%08lx", Val);
}
    9780:	1f 91       	pop	r17
    9782:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_zVal_h(uint32_t Val, char Type, T_Param *Param)
{
	if(Type=='b') sprintf(Param->Pos, "%02hx", (uint8_t)Val);
	if(Type=='w') sprintf(Param->Pos, "%04x", (uint16_t)Val);
    9784:	00 d0       	rcall	.+0      	; 0x9786 <Put_zVal_h+0xaa>
    9786:	00 d0       	rcall	.+0      	; 0x9788 <Put_zVal_h+0xac>
    9788:	ed b7       	in	r30, 0x3d	; 61
    978a:	fe b7       	in	r31, 0x3e	; 62
    978c:	31 96       	adiw	r30, 0x01	; 1
    978e:	8d 91       	ld	r24, X+
    9790:	9c 91       	ld	r25, X
    9792:	ad b7       	in	r26, 0x3d	; 61
    9794:	be b7       	in	r27, 0x3e	; 62
    9796:	12 96       	adiw	r26, 0x02	; 2
    9798:	9c 93       	st	X, r25
    979a:	8e 93       	st	-X, r24
    979c:	11 97       	sbiw	r26, 0x01	; 1
    979e:	87 e7       	ldi	r24, 0x77	; 119
    97a0:	92 e0       	ldi	r25, 0x02	; 2
    97a2:	93 83       	std	Z+3, r25	; 0x03
    97a4:	82 83       	std	Z+2, r24	; 0x02
    97a6:	64 83       	std	Z+4, r22	; 0x04
    97a8:	15 83       	std	Z+5, r17	; 0x05
    97aa:	0e 94 22 85 	call	0x10a44	; 0x10a44 <sprintf>
    97ae:	8d b7       	in	r24, 0x3d	; 61
    97b0:	9e b7       	in	r25, 0x3e	; 62
    97b2:	06 96       	adiw	r24, 0x06	; 6
    97b4:	0f b6       	in	r0, 0x3f	; 63
    97b6:	f8 94       	cli
    97b8:	9e bf       	out	0x3e, r25	; 62
    97ba:	0f be       	out	0x3f, r0	; 63
    97bc:	8d bf       	out	0x3d, r24	; 61
	if(Type=='l') sprintf(Param->Pos, "%08lx", Val);
}
    97be:	1f 91       	pop	r17
    97c0:	08 95       	ret

000097c2 <Put_zVal>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_zVal(uint16_t Val, char Type, T_Param *Param)
{
    97c2:	af 92       	push	r10
    97c4:	bf 92       	push	r11
    97c6:	cf 92       	push	r12
    97c8:	df 92       	push	r13
    97ca:	ef 92       	push	r14
    97cc:	ff 92       	push	r15
    97ce:	0f 93       	push	r16
    97d0:	1f 93       	push	r17
    97d2:	df 93       	push	r29
    97d4:	cf 93       	push	r28
    97d6:	cd b7       	in	r28, 0x3d	; 61
    97d8:	de b7       	in	r29, 0x3e	; 62
    97da:	2a 97       	sbiw	r28, 0x0a	; 10
    97dc:	0f b6       	in	r0, 0x3f	; 63
    97de:	f8 94       	cli
    97e0:	de bf       	out	0x3e, r29	; 62
    97e2:	0f be       	out	0x3f, r0	; 63
    97e4:	cd bf       	out	0x3d, r28	; 61
    97e6:	6c 01       	movw	r12, r24
    97e8:	7a 01       	movw	r14, r20
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
    97ea:	67 37       	cpi	r22, 0x77	; 119
    97ec:	09 f4       	brne	.+2      	; 0x97f0 <Put_zVal+0x2e>
    97ee:	79 c0       	rjmp	.+242    	; 0x98e2 <Put_zVal+0x120>
    97f0:	8f ef       	ldi	r24, 0xFF	; 255
    97f2:	90 e0       	ldi	r25, 0x00	; 0
	if(Param->Txt && Idx<2) {
    97f4:	d7 01       	movw	r26, r14
    97f6:	14 96       	adiw	r26, 0x04	; 4
    97f8:	2d 91       	ld	r18, X+
    97fa:	3c 91       	ld	r19, X
    97fc:	15 97       	sbiw	r26, 0x05	; 5
    97fe:	21 15       	cp	r18, r1
    9800:	31 05       	cpc	r19, r1
    9802:	31 f0       	breq	.+12     	; 0x9810 <Put_zVal+0x4e>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_zVal(uint16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
    9804:	8c 19       	sub	r24, r12
    9806:	9d 09       	sbc	r25, r13
	if(Param->Txt && Idx<2) {
    9808:	82 30       	cpi	r24, 0x02	; 2
    980a:	91 05       	cpc	r25, r1
    980c:	08 f4       	brcc	.+2      	; 0x9810 <Put_zVal+0x4e>
    980e:	8a c0       	rjmp	.+276    	; 0x9924 <Put_zVal+0x162>
		Param->Txt += Idx;
		PutEnum(Param);
		return;
	}
	char Format[] = "%0 u.%. u";
    9810:	5e 01       	movw	r10, r28
    9812:	08 94       	sec
    9814:	a1 1c       	adc	r10, r1
    9816:	b1 1c       	adc	r11, r1
    9818:	d5 01       	movw	r26, r10
    981a:	e2 e8       	ldi	r30, 0x82	; 130
    981c:	f2 e0       	ldi	r31, 0x02	; 2
    981e:	8a e0       	ldi	r24, 0x0A	; 10
    9820:	01 90       	ld	r0, Z+
    9822:	0d 92       	st	X+, r0
    9824:	81 50       	subi	r24, 0x01	; 1
    9826:	e1 f7       	brne	.-8      	; 0x9820 <Put_zVal+0x5e>
	Format[2] = '0'+Param->Size;
    9828:	f7 01       	movw	r30, r14
    982a:	23 81       	ldd	r18, Z+3	; 0x03
    982c:	20 5d       	subi	r18, 0xD0	; 208
    982e:	2b 83       	std	Y+3, r18	; 0x03
	if(Param->Prec) {
    9830:	92 81       	ldd	r25, Z+2	; 0x02
    9832:	99 23       	and	r25, r25
    9834:	09 f4       	brne	.+2      	; 0x9838 <Put_zVal+0x76>
    9836:	58 c0       	rjmp	.+176    	; 0x98e8 <Put_zVal+0x126>
		Format[2] -= Param->Prec+1;
    9838:	89 2f       	mov	r24, r25
    983a:	80 95       	com	r24
    983c:	82 0f       	add	r24, r18
    983e:	8b 83       	std	Y+3, r24	; 0x03
		Format[7] = '0'+Param->Prec;
    9840:	90 5d       	subi	r25, 0xD0	; 208
    9842:	98 87       	std	Y+8, r25	; 0x08
    9844:	90 53       	subi	r25, 0x30	; 48
		uint16_t Div=Pow10(Param->Prec);
    9846:	29 2f       	mov	r18, r25
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    9848:	01 e0       	ldi	r16, 0x01	; 1
    984a:	10 e0       	ldi	r17, 0x00	; 0
		Pow *= 10;
    984c:	c8 01       	movw	r24, r16
    984e:	88 0f       	add	r24, r24
    9850:	99 1f       	adc	r25, r25
    9852:	00 0f       	add	r16, r16
    9854:	11 1f       	adc	r17, r17
    9856:	00 0f       	add	r16, r16
    9858:	11 1f       	adc	r17, r17
    985a:	00 0f       	add	r16, r16
    985c:	11 1f       	adc	r17, r17
    985e:	08 0f       	add	r16, r24
    9860:	19 1f       	adc	r17, r25
    9862:	21 50       	subi	r18, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    9864:	99 f7       	brne	.-26     	; 0x984c <Put_zVal+0x8a>
    9866:	c6 01       	movw	r24, r12
    9868:	b8 01       	movw	r22, r16
    986a:	0e 94 b7 87 	call	0x10f6e	; 0x10f6e <__udivmodhi4>
    986e:	9c 01       	movw	r18, r24
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
    9870:	8d b7       	in	r24, 0x3d	; 61
    9872:	9e b7       	in	r25, 0x3e	; 62
    9874:	08 97       	sbiw	r24, 0x08	; 8
    9876:	0f b6       	in	r0, 0x3f	; 63
    9878:	f8 94       	cli
    987a:	9e bf       	out	0x3e, r25	; 62
    987c:	0f be       	out	0x3f, r0	; 63
    987e:	8d bf       	out	0x3d, r24	; 61
    9880:	ed b7       	in	r30, 0x3d	; 61
    9882:	fe b7       	in	r31, 0x3e	; 62
    9884:	31 96       	adiw	r30, 0x01	; 1
    9886:	d7 01       	movw	r26, r14
    9888:	8d 91       	ld	r24, X+
    988a:	9c 91       	ld	r25, X
    988c:	ad b7       	in	r26, 0x3d	; 61
    988e:	be b7       	in	r27, 0x3e	; 62
    9890:	12 96       	adiw	r26, 0x02	; 2
    9892:	9c 93       	st	X, r25
    9894:	8e 93       	st	-X, r24
    9896:	11 97       	sbiw	r26, 0x01	; 1
    9898:	b3 82       	std	Z+3, r11	; 0x03
    989a:	a2 82       	std	Z+2, r10	; 0x02
    989c:	c6 01       	movw	r24, r12
    989e:	b8 01       	movw	r22, r16
    98a0:	0e 94 b7 87 	call	0x10f6e	; 0x10f6e <__udivmodhi4>
    98a4:	75 83       	std	Z+5, r23	; 0x05
    98a6:	64 83       	std	Z+4, r22	; 0x04
    98a8:	26 83       	std	Z+6, r18	; 0x06
    98aa:	37 83       	std	Z+7, r19	; 0x07
    98ac:	0e 94 22 85 	call	0x10a44	; 0x10a44 <sprintf>
    98b0:	ed b7       	in	r30, 0x3d	; 61
    98b2:	fe b7       	in	r31, 0x3e	; 62
    98b4:	38 96       	adiw	r30, 0x08	; 8
    98b6:	0f b6       	in	r0, 0x3f	; 63
    98b8:	f8 94       	cli
    98ba:	fe bf       	out	0x3e, r31	; 62
    98bc:	0f be       	out	0x3f, r0	; 63
    98be:	ed bf       	out	0x3d, r30	; 61
	}
	else {
		Format[4] = '\0';
		sprintf(Param->Pos, Format, Val);
	}
}
    98c0:	2a 96       	adiw	r28, 0x0a	; 10
    98c2:	0f b6       	in	r0, 0x3f	; 63
    98c4:	f8 94       	cli
    98c6:	de bf       	out	0x3e, r29	; 62
    98c8:	0f be       	out	0x3f, r0	; 63
    98ca:	cd bf       	out	0x3d, r28	; 61
    98cc:	cf 91       	pop	r28
    98ce:	df 91       	pop	r29
    98d0:	1f 91       	pop	r17
    98d2:	0f 91       	pop	r16
    98d4:	ff 90       	pop	r15
    98d6:	ef 90       	pop	r14
    98d8:	df 90       	pop	r13
    98da:	cf 90       	pop	r12
    98dc:	bf 90       	pop	r11
    98de:	af 90       	pop	r10
    98e0:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_zVal(uint16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
    98e2:	8f ef       	ldi	r24, 0xFF	; 255
    98e4:	9f ef       	ldi	r25, 0xFF	; 255
    98e6:	86 cf       	rjmp	.-244    	; 0x97f4 <Put_zVal+0x32>
		Format[7] = '0'+Param->Prec;
		uint16_t Div=Pow10(Param->Prec);
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
	}
	else {
		Format[4] = '\0';
    98e8:	1d 82       	std	Y+5, r1	; 0x05
		sprintf(Param->Pos, Format, Val);
    98ea:	00 d0       	rcall	.+0      	; 0x98ec <Put_zVal+0x12a>
    98ec:	00 d0       	rcall	.+0      	; 0x98ee <Put_zVal+0x12c>
    98ee:	ed b7       	in	r30, 0x3d	; 61
    98f0:	fe b7       	in	r31, 0x3e	; 62
    98f2:	31 96       	adiw	r30, 0x01	; 1
    98f4:	d7 01       	movw	r26, r14
    98f6:	8d 91       	ld	r24, X+
    98f8:	9c 91       	ld	r25, X
    98fa:	ad b7       	in	r26, 0x3d	; 61
    98fc:	be b7       	in	r27, 0x3e	; 62
    98fe:	12 96       	adiw	r26, 0x02	; 2
    9900:	9c 93       	st	X, r25
    9902:	8e 93       	st	-X, r24
    9904:	11 97       	sbiw	r26, 0x01	; 1
    9906:	b3 82       	std	Z+3, r11	; 0x03
    9908:	a2 82       	std	Z+2, r10	; 0x02
    990a:	d5 82       	std	Z+5, r13	; 0x05
    990c:	c4 82       	std	Z+4, r12	; 0x04
    990e:	0e 94 22 85 	call	0x10a44	; 0x10a44 <sprintf>
    9912:	ed b7       	in	r30, 0x3d	; 61
    9914:	fe b7       	in	r31, 0x3e	; 62
    9916:	36 96       	adiw	r30, 0x06	; 6
    9918:	0f b6       	in	r0, 0x3f	; 63
    991a:	f8 94       	cli
    991c:	fe bf       	out	0x3e, r31	; 62
    991e:	0f be       	out	0x3f, r0	; 63
    9920:	ed bf       	out	0x3d, r30	; 61
    9922:	ce cf       	rjmp	.-100    	; 0x98c0 <Put_zVal+0xfe>
void
Put_zVal(uint16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
	if(Param->Txt && Idx<2) {
		Param->Txt += Idx;
    9924:	88 0f       	add	r24, r24
    9926:	99 1f       	adc	r25, r25
    9928:	28 0f       	add	r18, r24
    992a:	39 1f       	adc	r19, r25
    992c:	15 96       	adiw	r26, 0x05	; 5
    992e:	3c 93       	st	X, r19
    9930:	2e 93       	st	-X, r18
    9932:	14 97       	sbiw	r26, 0x04	; 4
		PutEnum(Param);
    9934:	c7 01       	movw	r24, r14
    9936:	0e 94 84 44 	call	0x8908	; 0x8908 <PutEnum>
    993a:	c2 cf       	rjmp	.-124    	; 0x98c0 <Put_zVal+0xfe>

0000993c <Put_sVal>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_sVal(int16_t Val, char Type, T_Param *Param)
{
    993c:	af 92       	push	r10
    993e:	bf 92       	push	r11
    9940:	cf 92       	push	r12
    9942:	df 92       	push	r13
    9944:	ef 92       	push	r14
    9946:	ff 92       	push	r15
    9948:	0f 93       	push	r16
    994a:	1f 93       	push	r17
    994c:	df 93       	push	r29
    994e:	cf 93       	push	r28
    9950:	cd b7       	in	r28, 0x3d	; 61
    9952:	de b7       	in	r29, 0x3e	; 62
    9954:	2a 97       	sbiw	r28, 0x0a	; 10
    9956:	0f b6       	in	r0, 0x3f	; 63
    9958:	f8 94       	cli
    995a:	de bf       	out	0x3e, r29	; 62
    995c:	0f be       	out	0x3f, r0	; 63
    995e:	cd bf       	out	0x3d, r28	; 61
    9960:	6c 01       	movw	r12, r24
    9962:	7a 01       	movw	r14, r20
	uint16_t Idx = (Type=='w'?0x8000:0x80)+Val;
    9964:	67 37       	cpi	r22, 0x77	; 119
    9966:	09 f4       	brne	.+2      	; 0x996a <Put_sVal+0x2e>
    9968:	81 c0       	rjmp	.+258    	; 0x9a6c <Put_sVal+0x130>
    996a:	80 e8       	ldi	r24, 0x80	; 128
    996c:	90 e0       	ldi	r25, 0x00	; 0
	if(Param->Txt && Idx<2) {
    996e:	d7 01       	movw	r26, r14
    9970:	14 96       	adiw	r26, 0x04	; 4
    9972:	2d 91       	ld	r18, X+
    9974:	3c 91       	ld	r19, X
    9976:	15 97       	sbiw	r26, 0x05	; 5
    9978:	21 15       	cp	r18, r1
    997a:	31 05       	cpc	r19, r1
    997c:	31 f0       	breq	.+12     	; 0x998a <Put_sVal+0x4e>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_sVal(int16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0x8000:0x80)+Val;
    997e:	8c 0d       	add	r24, r12
    9980:	9d 1d       	adc	r25, r13
	if(Param->Txt && Idx<2) {
    9982:	82 30       	cpi	r24, 0x02	; 2
    9984:	91 05       	cpc	r25, r1
    9986:	08 f4       	brcc	.+2      	; 0x998a <Put_sVal+0x4e>
    9988:	ac c0       	rjmp	.+344    	; 0x9ae2 <Put_sVal+0x1a6>
		Param->Txt += Idx;
		PutEnum(Param);
		return;
	}
	char Format[] = "%+ d.%. u";
    998a:	5e 01       	movw	r10, r28
    998c:	08 94       	sec
    998e:	a1 1c       	adc	r10, r1
    9990:	b1 1c       	adc	r11, r1
    9992:	d5 01       	movw	r26, r10
    9994:	ec e8       	ldi	r30, 0x8C	; 140
    9996:	f2 e0       	ldi	r31, 0x02	; 2
    9998:	8a e0       	ldi	r24, 0x0A	; 10
    999a:	01 90       	ld	r0, Z+
    999c:	0d 92       	st	X+, r0
    999e:	81 50       	subi	r24, 0x01	; 1
    99a0:	e1 f7       	brne	.-8      	; 0x999a <Put_sVal+0x5e>
	if(Val==0)
    99a2:	c1 14       	cp	r12, r1
    99a4:	d1 04       	cpc	r13, r1
    99a6:	09 f4       	brne	.+2      	; 0x99aa <Put_sVal+0x6e>
    99a8:	64 c0       	rjmp	.+200    	; 0x9a72 <Put_sVal+0x136>
		Format[1] = ' ';
	Format[2] = '0'+Param->Size;
    99aa:	f7 01       	movw	r30, r14
    99ac:	23 81       	ldd	r18, Z+3	; 0x03
    99ae:	20 5d       	subi	r18, 0xD0	; 208
    99b0:	2b 83       	std	Y+3, r18	; 0x03
	if(Param->Prec) {
    99b2:	92 81       	ldd	r25, Z+2	; 0x02
    99b4:	99 23       	and	r25, r25
    99b6:	09 f4       	brne	.+2      	; 0x99ba <Put_sVal+0x7e>
    99b8:	66 c0       	rjmp	.+204    	; 0x9a86 <Put_sVal+0x14a>
		Format[2] -= Param->Prec+1;
    99ba:	89 2f       	mov	r24, r25
    99bc:	80 95       	com	r24
    99be:	82 0f       	add	r24, r18
    99c0:	8b 83       	std	Y+3, r24	; 0x03
		Format[7] = '0'+Param->Prec;
    99c2:	90 5d       	subi	r25, 0xD0	; 208
    99c4:	98 87       	std	Y+8, r25	; 0x08
    99c6:	90 53       	subi	r25, 0x30	; 48
		int16_t Div=Pow10(Param->Prec);
    99c8:	29 2f       	mov	r18, r25
    99ca:	01 e0       	ldi	r16, 0x01	; 1
    99cc:	10 e0       	ldi	r17, 0x00	; 0
		Pow *= 10;
    99ce:	c8 01       	movw	r24, r16
    99d0:	88 0f       	add	r24, r24
    99d2:	99 1f       	adc	r25, r25
    99d4:	00 0f       	add	r16, r16
    99d6:	11 1f       	adc	r17, r17
    99d8:	00 0f       	add	r16, r16
    99da:	11 1f       	adc	r17, r17
    99dc:	00 0f       	add	r16, r16
    99de:	11 1f       	adc	r17, r17
    99e0:	08 0f       	add	r16, r24
    99e2:	19 1f       	adc	r17, r25
    99e4:	21 50       	subi	r18, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    99e6:	99 f7       	brne	.-26     	; 0x99ce <Put_sVal+0x92>
    99e8:	c6 01       	movw	r24, r12
    99ea:	d7 fc       	sbrc	r13, 7
    99ec:	86 c0       	rjmp	.+268    	; 0x9afa <Put_sVal+0x1be>
    99ee:	b8 01       	movw	r22, r16
    99f0:	0e 94 b7 87 	call	0x10f6e	; 0x10f6e <__udivmodhi4>
    99f4:	9c 01       	movw	r18, r24
		sprintf(Param->Pos, Format, Val/Div, (uint16_t)abs(Val)%Div);
    99f6:	8d b7       	in	r24, 0x3d	; 61
    99f8:	9e b7       	in	r25, 0x3e	; 62
    99fa:	08 97       	sbiw	r24, 0x08	; 8
    99fc:	0f b6       	in	r0, 0x3f	; 63
    99fe:	f8 94       	cli
    9a00:	9e bf       	out	0x3e, r25	; 62
    9a02:	0f be       	out	0x3f, r0	; 63
    9a04:	8d bf       	out	0x3d, r24	; 61
    9a06:	ed b7       	in	r30, 0x3d	; 61
    9a08:	fe b7       	in	r31, 0x3e	; 62
    9a0a:	31 96       	adiw	r30, 0x01	; 1
    9a0c:	d7 01       	movw	r26, r14
    9a0e:	8d 91       	ld	r24, X+
    9a10:	9c 91       	ld	r25, X
    9a12:	ad b7       	in	r26, 0x3d	; 61
    9a14:	be b7       	in	r27, 0x3e	; 62
    9a16:	12 96       	adiw	r26, 0x02	; 2
    9a18:	9c 93       	st	X, r25
    9a1a:	8e 93       	st	-X, r24
    9a1c:	11 97       	sbiw	r26, 0x01	; 1
    9a1e:	b3 82       	std	Z+3, r11	; 0x03
    9a20:	a2 82       	std	Z+2, r10	; 0x02
    9a22:	c6 01       	movw	r24, r12
    9a24:	b8 01       	movw	r22, r16
    9a26:	0e 94 cb 87 	call	0x10f96	; 0x10f96 <__divmodhi4>
    9a2a:	75 83       	std	Z+5, r23	; 0x05
    9a2c:	64 83       	std	Z+4, r22	; 0x04
    9a2e:	26 83       	std	Z+6, r18	; 0x06
    9a30:	37 83       	std	Z+7, r19	; 0x07
    9a32:	0e 94 22 85 	call	0x10a44	; 0x10a44 <sprintf>
		if(Val<0) {
    9a36:	ed b7       	in	r30, 0x3d	; 61
    9a38:	fe b7       	in	r31, 0x3e	; 62
    9a3a:	38 96       	adiw	r30, 0x08	; 8
    9a3c:	0f b6       	in	r0, 0x3f	; 63
    9a3e:	f8 94       	cli
    9a40:	fe bf       	out	0x3e, r31	; 62
    9a42:	0f be       	out	0x3f, r0	; 63
    9a44:	ed bf       	out	0x3d, r30	; 61
    9a46:	d7 fc       	sbrc	r13, 7
    9a48:	3c c0       	rjmp	.+120    	; 0x9ac2 <Put_sVal+0x186>
	}
	else {
		Format[4] = '\0';
		sprintf(Param->Pos, Format, Val);
	}
}
    9a4a:	2a 96       	adiw	r28, 0x0a	; 10
    9a4c:	0f b6       	in	r0, 0x3f	; 63
    9a4e:	f8 94       	cli
    9a50:	de bf       	out	0x3e, r29	; 62
    9a52:	0f be       	out	0x3f, r0	; 63
    9a54:	cd bf       	out	0x3d, r28	; 61
    9a56:	cf 91       	pop	r28
    9a58:	df 91       	pop	r29
    9a5a:	1f 91       	pop	r17
    9a5c:	0f 91       	pop	r16
    9a5e:	ff 90       	pop	r15
    9a60:	ef 90       	pop	r14
    9a62:	df 90       	pop	r13
    9a64:	cf 90       	pop	r12
    9a66:	bf 90       	pop	r11
    9a68:	af 90       	pop	r10
    9a6a:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_sVal(int16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0x8000:0x80)+Val;
    9a6c:	80 e0       	ldi	r24, 0x00	; 0
    9a6e:	90 e8       	ldi	r25, 0x80	; 128
    9a70:	7e cf       	rjmp	.-260    	; 0x996e <Put_sVal+0x32>
		PutEnum(Param);
		return;
	}
	char Format[] = "%+ d.%. u";
	if(Val==0)
		Format[1] = ' ';
    9a72:	80 e2       	ldi	r24, 0x20	; 32
    9a74:	8a 83       	std	Y+2, r24	; 0x02
	Format[2] = '0'+Param->Size;
    9a76:	f7 01       	movw	r30, r14
    9a78:	23 81       	ldd	r18, Z+3	; 0x03
    9a7a:	20 5d       	subi	r18, 0xD0	; 208
    9a7c:	2b 83       	std	Y+3, r18	; 0x03
	if(Param->Prec) {
    9a7e:	92 81       	ldd	r25, Z+2	; 0x02
    9a80:	99 23       	and	r25, r25
    9a82:	09 f0       	breq	.+2      	; 0x9a86 <Put_sVal+0x14a>
    9a84:	9a cf       	rjmp	.-204    	; 0x99ba <Put_sVal+0x7e>
				Param->Pos++;
			*Param->Pos = '-';
		}
	}
	else {
		Format[4] = '\0';
    9a86:	1d 82       	std	Y+5, r1	; 0x05
		sprintf(Param->Pos, Format, Val);
    9a88:	00 d0       	rcall	.+0      	; 0x9a8a <Put_sVal+0x14e>
    9a8a:	00 d0       	rcall	.+0      	; 0x9a8c <Put_sVal+0x150>
    9a8c:	ed b7       	in	r30, 0x3d	; 61
    9a8e:	fe b7       	in	r31, 0x3e	; 62
    9a90:	31 96       	adiw	r30, 0x01	; 1
    9a92:	d7 01       	movw	r26, r14
    9a94:	8d 91       	ld	r24, X+
    9a96:	9c 91       	ld	r25, X
    9a98:	ad b7       	in	r26, 0x3d	; 61
    9a9a:	be b7       	in	r27, 0x3e	; 62
    9a9c:	12 96       	adiw	r26, 0x02	; 2
    9a9e:	9c 93       	st	X, r25
    9aa0:	8e 93       	st	-X, r24
    9aa2:	11 97       	sbiw	r26, 0x01	; 1
    9aa4:	b3 82       	std	Z+3, r11	; 0x03
    9aa6:	a2 82       	std	Z+2, r10	; 0x02
    9aa8:	d5 82       	std	Z+5, r13	; 0x05
    9aaa:	c4 82       	std	Z+4, r12	; 0x04
    9aac:	0e 94 22 85 	call	0x10a44	; 0x10a44 <sprintf>
    9ab0:	ed b7       	in	r30, 0x3d	; 61
    9ab2:	fe b7       	in	r31, 0x3e	; 62
    9ab4:	36 96       	adiw	r30, 0x06	; 6
    9ab6:	0f b6       	in	r0, 0x3f	; 63
    9ab8:	f8 94       	cli
    9aba:	fe bf       	out	0x3e, r31	; 62
    9abc:	0f be       	out	0x3f, r0	; 63
    9abe:	ed bf       	out	0x3d, r30	; 61
    9ac0:	c4 cf       	rjmp	.-120    	; 0x9a4a <Put_sVal+0x10e>
		Format[2] -= Param->Prec+1;
		Format[7] = '0'+Param->Prec;
		int16_t Div=Pow10(Param->Prec);
		sprintf(Param->Pos, Format, Val/Div, (uint16_t)abs(Val)%Div);
		if(Val<0) {
			while(*Param->Pos==' ')
    9ac2:	d7 01       	movw	r26, r14
    9ac4:	ed 91       	ld	r30, X+
    9ac6:	fc 91       	ld	r31, X
    9ac8:	80 81       	ld	r24, Z
    9aca:	80 32       	cpi	r24, 0x20	; 32
    9acc:	39 f4       	brne	.+14     	; 0x9adc <Put_sVal+0x1a0>
				Param->Pos++;
    9ace:	31 96       	adiw	r30, 0x01	; 1
    9ad0:	d7 01       	movw	r26, r14
    9ad2:	ed 93       	st	X+, r30
    9ad4:	fc 93       	st	X, r31
		Format[2] -= Param->Prec+1;
		Format[7] = '0'+Param->Prec;
		int16_t Div=Pow10(Param->Prec);
		sprintf(Param->Pos, Format, Val/Div, (uint16_t)abs(Val)%Div);
		if(Val<0) {
			while(*Param->Pos==' ')
    9ad6:	80 81       	ld	r24, Z
    9ad8:	80 32       	cpi	r24, 0x20	; 32
    9ada:	c9 f3       	breq	.-14     	; 0x9ace <Put_sVal+0x192>
				Param->Pos++;
			*Param->Pos = '-';
    9adc:	8d e2       	ldi	r24, 0x2D	; 45
    9ade:	80 83       	st	Z, r24
    9ae0:	b4 cf       	rjmp	.-152    	; 0x9a4a <Put_sVal+0x10e>
void
Put_sVal(int16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0x8000:0x80)+Val;
	if(Param->Txt && Idx<2) {
		Param->Txt += Idx;
    9ae2:	88 0f       	add	r24, r24
    9ae4:	99 1f       	adc	r25, r25
    9ae6:	28 0f       	add	r18, r24
    9ae8:	39 1f       	adc	r19, r25
    9aea:	15 96       	adiw	r26, 0x05	; 5
    9aec:	3c 93       	st	X, r19
    9aee:	2e 93       	st	-X, r18
    9af0:	14 97       	sbiw	r26, 0x04	; 4
		PutEnum(Param);
    9af2:	c7 01       	movw	r24, r14
    9af4:	0e 94 84 44 	call	0x8908	; 0x8908 <PutEnum>
    9af8:	a8 cf       	rjmp	.-176    	; 0x9a4a <Put_sVal+0x10e>
    9afa:	88 27       	eor	r24, r24
    9afc:	99 27       	eor	r25, r25
    9afe:	8c 19       	sub	r24, r12
    9b00:	9d 09       	sbc	r25, r13
    9b02:	75 cf       	rjmp	.-278    	; 0x99ee <Put_sVal+0xb2>

00009b04 <PutVal>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
PutVal(uint16_t Val, char Type, T_Param *Param)
{
    9b04:	af 92       	push	r10
    9b06:	bf 92       	push	r11
    9b08:	cf 92       	push	r12
    9b0a:	df 92       	push	r13
    9b0c:	ef 92       	push	r14
    9b0e:	ff 92       	push	r15
    9b10:	0f 93       	push	r16
    9b12:	1f 93       	push	r17
    9b14:	df 93       	push	r29
    9b16:	cf 93       	push	r28
    9b18:	cd b7       	in	r28, 0x3d	; 61
    9b1a:	de b7       	in	r29, 0x3e	; 62
    9b1c:	29 97       	sbiw	r28, 0x09	; 9
    9b1e:	0f b6       	in	r0, 0x3f	; 63
    9b20:	f8 94       	cli
    9b22:	de bf       	out	0x3e, r29	; 62
    9b24:	0f be       	out	0x3f, r0	; 63
    9b26:	cd bf       	out	0x3d, r28	; 61
    9b28:	6c 01       	movw	r12, r24
    9b2a:	7a 01       	movw	r14, r20
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
    9b2c:	67 37       	cpi	r22, 0x77	; 119
    9b2e:	09 f4       	brne	.+2      	; 0x9b32 <PutVal+0x2e>
    9b30:	79 c0       	rjmp	.+242    	; 0x9c24 <PutVal+0x120>
    9b32:	8f ef       	ldi	r24, 0xFF	; 255
    9b34:	90 e0       	ldi	r25, 0x00	; 0
	if(Param->Txt && Idx<2) {
    9b36:	d7 01       	movw	r26, r14
    9b38:	14 96       	adiw	r26, 0x04	; 4
    9b3a:	2d 91       	ld	r18, X+
    9b3c:	3c 91       	ld	r19, X
    9b3e:	15 97       	sbiw	r26, 0x05	; 5
    9b40:	21 15       	cp	r18, r1
    9b42:	31 05       	cpc	r19, r1
    9b44:	31 f0       	breq	.+12     	; 0x9b52 <PutVal+0x4e>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
PutVal(uint16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
    9b46:	8c 19       	sub	r24, r12
    9b48:	9d 09       	sbc	r25, r13
	if(Param->Txt && Idx<2) {
    9b4a:	82 30       	cpi	r24, 0x02	; 2
    9b4c:	91 05       	cpc	r25, r1
    9b4e:	08 f4       	brcc	.+2      	; 0x9b52 <PutVal+0x4e>
    9b50:	8a c0       	rjmp	.+276    	; 0x9c66 <PutVal+0x162>
		Param->Txt += Idx;
		PutEnum(Param);
		return;
	}
	char Format[] = "% u.%. u";
    9b52:	5e 01       	movw	r10, r28
    9b54:	08 94       	sec
    9b56:	a1 1c       	adc	r10, r1
    9b58:	b1 1c       	adc	r11, r1
    9b5a:	d5 01       	movw	r26, r10
    9b5c:	e6 e9       	ldi	r30, 0x96	; 150
    9b5e:	f2 e0       	ldi	r31, 0x02	; 2
    9b60:	89 e0       	ldi	r24, 0x09	; 9
    9b62:	01 90       	ld	r0, Z+
    9b64:	0d 92       	st	X+, r0
    9b66:	81 50       	subi	r24, 0x01	; 1
    9b68:	e1 f7       	brne	.-8      	; 0x9b62 <PutVal+0x5e>
	Format[1] = '0'+Param->Size;
    9b6a:	f7 01       	movw	r30, r14
    9b6c:	23 81       	ldd	r18, Z+3	; 0x03
    9b6e:	20 5d       	subi	r18, 0xD0	; 208
    9b70:	2a 83       	std	Y+2, r18	; 0x02
	if(Param->Prec) {
    9b72:	92 81       	ldd	r25, Z+2	; 0x02
    9b74:	99 23       	and	r25, r25
    9b76:	09 f4       	brne	.+2      	; 0x9b7a <PutVal+0x76>
    9b78:	58 c0       	rjmp	.+176    	; 0x9c2a <PutVal+0x126>
		Format[1] -= Param->Prec+1;
    9b7a:	89 2f       	mov	r24, r25
    9b7c:	80 95       	com	r24
    9b7e:	82 0f       	add	r24, r18
    9b80:	8a 83       	std	Y+2, r24	; 0x02
		Format[6] = '0'+Param->Prec;
    9b82:	90 5d       	subi	r25, 0xD0	; 208
    9b84:	9f 83       	std	Y+7, r25	; 0x07
    9b86:	90 53       	subi	r25, 0x30	; 48
		uint16_t Div=Pow10(Param->Prec);
    9b88:	29 2f       	mov	r18, r25
    9b8a:	01 e0       	ldi	r16, 0x01	; 1
    9b8c:	10 e0       	ldi	r17, 0x00	; 0
		Pow *= 10;
    9b8e:	c8 01       	movw	r24, r16
    9b90:	88 0f       	add	r24, r24
    9b92:	99 1f       	adc	r25, r25
    9b94:	00 0f       	add	r16, r16
    9b96:	11 1f       	adc	r17, r17
    9b98:	00 0f       	add	r16, r16
    9b9a:	11 1f       	adc	r17, r17
    9b9c:	00 0f       	add	r16, r16
    9b9e:	11 1f       	adc	r17, r17
    9ba0:	08 0f       	add	r16, r24
    9ba2:	19 1f       	adc	r17, r25
    9ba4:	21 50       	subi	r18, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    9ba6:	99 f7       	brne	.-26     	; 0x9b8e <PutVal+0x8a>
    9ba8:	c6 01       	movw	r24, r12
    9baa:	b8 01       	movw	r22, r16
    9bac:	0e 94 b7 87 	call	0x10f6e	; 0x10f6e <__udivmodhi4>
    9bb0:	9c 01       	movw	r18, r24
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
    9bb2:	8d b7       	in	r24, 0x3d	; 61
    9bb4:	9e b7       	in	r25, 0x3e	; 62
    9bb6:	08 97       	sbiw	r24, 0x08	; 8
    9bb8:	0f b6       	in	r0, 0x3f	; 63
    9bba:	f8 94       	cli
    9bbc:	9e bf       	out	0x3e, r25	; 62
    9bbe:	0f be       	out	0x3f, r0	; 63
    9bc0:	8d bf       	out	0x3d, r24	; 61
    9bc2:	ed b7       	in	r30, 0x3d	; 61
    9bc4:	fe b7       	in	r31, 0x3e	; 62
    9bc6:	31 96       	adiw	r30, 0x01	; 1
    9bc8:	d7 01       	movw	r26, r14
    9bca:	8d 91       	ld	r24, X+
    9bcc:	9c 91       	ld	r25, X
    9bce:	ad b7       	in	r26, 0x3d	; 61
    9bd0:	be b7       	in	r27, 0x3e	; 62
    9bd2:	12 96       	adiw	r26, 0x02	; 2
    9bd4:	9c 93       	st	X, r25
    9bd6:	8e 93       	st	-X, r24
    9bd8:	11 97       	sbiw	r26, 0x01	; 1
    9bda:	b3 82       	std	Z+3, r11	; 0x03
    9bdc:	a2 82       	std	Z+2, r10	; 0x02
    9bde:	c6 01       	movw	r24, r12
    9be0:	b8 01       	movw	r22, r16
    9be2:	0e 94 b7 87 	call	0x10f6e	; 0x10f6e <__udivmodhi4>
    9be6:	75 83       	std	Z+5, r23	; 0x05
    9be8:	64 83       	std	Z+4, r22	; 0x04
    9bea:	26 83       	std	Z+6, r18	; 0x06
    9bec:	37 83       	std	Z+7, r19	; 0x07
    9bee:	0e 94 22 85 	call	0x10a44	; 0x10a44 <sprintf>
    9bf2:	ed b7       	in	r30, 0x3d	; 61
    9bf4:	fe b7       	in	r31, 0x3e	; 62
    9bf6:	38 96       	adiw	r30, 0x08	; 8
    9bf8:	0f b6       	in	r0, 0x3f	; 63
    9bfa:	f8 94       	cli
    9bfc:	fe bf       	out	0x3e, r31	; 62
    9bfe:	0f be       	out	0x3f, r0	; 63
    9c00:	ed bf       	out	0x3d, r30	; 61
	}
	else {
		Format[3] = '\0';
		sprintf(Param->Pos, Format, Val);
	}
}
    9c02:	29 96       	adiw	r28, 0x09	; 9
    9c04:	0f b6       	in	r0, 0x3f	; 63
    9c06:	f8 94       	cli
    9c08:	de bf       	out	0x3e, r29	; 62
    9c0a:	0f be       	out	0x3f, r0	; 63
    9c0c:	cd bf       	out	0x3d, r28	; 61
    9c0e:	cf 91       	pop	r28
    9c10:	df 91       	pop	r29
    9c12:	1f 91       	pop	r17
    9c14:	0f 91       	pop	r16
    9c16:	ff 90       	pop	r15
    9c18:	ef 90       	pop	r14
    9c1a:	df 90       	pop	r13
    9c1c:	cf 90       	pop	r12
    9c1e:	bf 90       	pop	r11
    9c20:	af 90       	pop	r10
    9c22:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
PutVal(uint16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
    9c24:	8f ef       	ldi	r24, 0xFF	; 255
    9c26:	9f ef       	ldi	r25, 0xFF	; 255
    9c28:	86 cf       	rjmp	.-244    	; 0x9b36 <PutVal+0x32>
		Format[6] = '0'+Param->Prec;
		uint16_t Div=Pow10(Param->Prec);
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
	}
	else {
		Format[3] = '\0';
    9c2a:	1c 82       	std	Y+4, r1	; 0x04
		sprintf(Param->Pos, Format, Val);
    9c2c:	00 d0       	rcall	.+0      	; 0x9c2e <PutVal+0x12a>
    9c2e:	00 d0       	rcall	.+0      	; 0x9c30 <PutVal+0x12c>
    9c30:	ed b7       	in	r30, 0x3d	; 61
    9c32:	fe b7       	in	r31, 0x3e	; 62
    9c34:	31 96       	adiw	r30, 0x01	; 1
    9c36:	d7 01       	movw	r26, r14
    9c38:	8d 91       	ld	r24, X+
    9c3a:	9c 91       	ld	r25, X
    9c3c:	ad b7       	in	r26, 0x3d	; 61
    9c3e:	be b7       	in	r27, 0x3e	; 62
    9c40:	12 96       	adiw	r26, 0x02	; 2
    9c42:	9c 93       	st	X, r25
    9c44:	8e 93       	st	-X, r24
    9c46:	11 97       	sbiw	r26, 0x01	; 1
    9c48:	b3 82       	std	Z+3, r11	; 0x03
    9c4a:	a2 82       	std	Z+2, r10	; 0x02
    9c4c:	d5 82       	std	Z+5, r13	; 0x05
    9c4e:	c4 82       	std	Z+4, r12	; 0x04
    9c50:	0e 94 22 85 	call	0x10a44	; 0x10a44 <sprintf>
    9c54:	ed b7       	in	r30, 0x3d	; 61
    9c56:	fe b7       	in	r31, 0x3e	; 62
    9c58:	36 96       	adiw	r30, 0x06	; 6
    9c5a:	0f b6       	in	r0, 0x3f	; 63
    9c5c:	f8 94       	cli
    9c5e:	fe bf       	out	0x3e, r31	; 62
    9c60:	0f be       	out	0x3f, r0	; 63
    9c62:	ed bf       	out	0x3d, r30	; 61
    9c64:	ce cf       	rjmp	.-100    	; 0x9c02 <PutVal+0xfe>
void
PutVal(uint16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
	if(Param->Txt && Idx<2) {
		Param->Txt += Idx;
    9c66:	88 0f       	add	r24, r24
    9c68:	99 1f       	adc	r25, r25
    9c6a:	28 0f       	add	r18, r24
    9c6c:	39 1f       	adc	r19, r25
    9c6e:	15 96       	adiw	r26, 0x05	; 5
    9c70:	3c 93       	st	X, r19
    9c72:	2e 93       	st	-X, r18
    9c74:	14 97       	sbiw	r26, 0x04	; 4
		PutEnum(Param);
    9c76:	c7 01       	movw	r24, r14
    9c78:	0e 94 84 44 	call	0x8908	; 0x8908 <PutEnum>
    9c7c:	c2 cf       	rjmp	.-124    	; 0x9c02 <PutVal+0xfe>

00009c7e <GSM_Wait_Response_P>:
//	}
	if(strcmp(GSM_RxStr, Str))return 0;
	else return 1;
}
// ~~~~~~~~~
uint8_t GSM_Wait_Response_P(prog_char *Str_P, uint8_t RestoreCMD){
    9c7e:	1f 93       	push	r17
    9c80:	cf 93       	push	r28
    9c82:	df 93       	push	r29
    9c84:	ec 01       	movw	r28, r24
    9c86:	16 2f       	mov	r17, r22
	
	if(Timer16Stopp(TD_GSM) && RestoreCMD){
    9c88:	80 91 e9 04 	lds	r24, 0x04E9
    9c8c:	0e 94 84 1f 	call	0x3f08	; 0x3f08 <Timer16Stopp>
    9c90:	88 23       	and	r24, r24
    9c92:	11 f0       	breq	.+4      	; 0x9c98 <GSM_Wait_Response_P+0x1a>
    9c94:	11 23       	and	r17, r17
    9c96:	51 f4       	brne	.+20     	; 0x9cac <GSM_Wait_Response_P+0x2e>
		GSM_State = RestoreCMD;
		return 0;
	}
	//  
	if(GetStringFromFIFO()){
    9c98:	0e 94 fe 3b 	call	0x77fc	; 0x77fc <GetStringFromFIFO>
    9c9c:	88 23       	and	r24, r24
    9c9e:	71 f4       	brne	.+28     	; 0x9cbc <GSM_Wait_Response_P+0x3e>
    9ca0:	20 e0       	ldi	r18, 0x00	; 0
		if(strcmp_P(GSM_RxStr, Str_P)) return 0;
		else return 1;
	}
	else return 0;
}
    9ca2:	82 2f       	mov	r24, r18
    9ca4:	df 91       	pop	r29
    9ca6:	cf 91       	pop	r28
    9ca8:	1f 91       	pop	r17
    9caa:	08 95       	ret
}
// ~~~~~~~~~
uint8_t GSM_Wait_Response_P(prog_char *Str_P, uint8_t RestoreCMD){
	
	if(Timer16Stopp(TD_GSM) && RestoreCMD){
		GSM_State = RestoreCMD;
    9cac:	10 93 f6 06 	sts	0x06F6, r17
    9cb0:	20 e0       	ldi	r18, 0x00	; 0
	if(GetStringFromFIFO()){
		if(strcmp_P(GSM_RxStr, Str_P)) return 0;
		else return 1;
	}
	else return 0;
}
    9cb2:	82 2f       	mov	r24, r18
    9cb4:	df 91       	pop	r29
    9cb6:	cf 91       	pop	r28
    9cb8:	1f 91       	pop	r17
    9cba:	08 95       	ret
		GSM_State = RestoreCMD;
		return 0;
	}
	//  
	if(GetStringFromFIFO()){
		if(strcmp_P(GSM_RxStr, Str_P)) return 0;
    9cbc:	81 ee       	ldi	r24, 0xE1	; 225
    9cbe:	97 e0       	ldi	r25, 0x07	; 7
    9cc0:	be 01       	movw	r22, r28
    9cc2:	0e 94 26 84 	call	0x1084c	; 0x1084c <strcmp_P>
    9cc6:	20 e0       	ldi	r18, 0x00	; 0
    9cc8:	89 2b       	or	r24, r25
    9cca:	59 f7       	brne	.-42     	; 0x9ca2 <GSM_Wait_Response_P+0x24>
    9ccc:	21 e0       	ldi	r18, 0x01	; 1
		else return 1;
	}
	else return 0;
}
    9cce:	82 2f       	mov	r24, r18
    9cd0:	df 91       	pop	r29
    9cd2:	cf 91       	pop	r28
    9cd4:	1f 91       	pop	r17
    9cd6:	08 95       	ret

00009cd8 <GSM_SendCR>:
	
	sei();	
}
// ~~~~~~~~~
//   + CR
void GSM_SendCR(prog_char *Str_P){
    9cd8:	ef 92       	push	r14
    9cda:	ff 92       	push	r15
    9cdc:	0f 93       	push	r16
    9cde:	1f 93       	push	r17
    9ce0:	7c 01       	movw	r14, r24
	GSMTxSz = strlen_P(Str_P);
    9ce2:	0e 94 36 84 	call	0x1086c	; 0x1086c <strlen_P>
    9ce6:	80 93 bb 07 	sts	0x07BB, r24
	sprintf_P(GSM_TxStr, Str_P);
    9cea:	00 d0       	rcall	.+0      	; 0x9cec <GSM_SendCR+0x14>
    9cec:	0f 92       	push	r0
    9cee:	0a e4       	ldi	r16, 0x4A	; 74
    9cf0:	1a e0       	ldi	r17, 0x0A	; 10
    9cf2:	ed b7       	in	r30, 0x3d	; 61
    9cf4:	fe b7       	in	r31, 0x3e	; 62
    9cf6:	12 83       	std	Z+2, r17	; 0x02
    9cf8:	01 83       	std	Z+1, r16	; 0x01
    9cfa:	f4 82       	std	Z+4, r15	; 0x04
    9cfc:	e3 82       	std	Z+3, r14	; 0x03
    9cfe:	0e 94 53 85 	call	0x10aa6	; 0x10aa6 <sprintf_P>
	sprintf(GSM_TxStr + GSMTxSz, "\r");
    9d02:	80 91 bb 07 	lds	r24, 0x07BB
    9d06:	08 0f       	add	r16, r24
    9d08:	11 1d       	adc	r17, r1
    9d0a:	8d e0       	ldi	r24, 0x0D	; 13
    9d0c:	90 e0       	ldi	r25, 0x00	; 0
    9d0e:	f8 01       	movw	r30, r16
    9d10:	91 83       	std	Z+1, r25	; 0x01
    9d12:	80 83       	st	Z, r24
	GSMTxSz++;
    9d14:	80 91 bb 07 	lds	r24, 0x07BB
    9d18:	8f 5f       	subi	r24, 0xFF	; 255
    9d1a:	80 93 bb 07 	sts	0x07BB, r24
	GSM_SendFirstChar();
    9d1e:	0f 90       	pop	r0
    9d20:	0f 90       	pop	r0
    9d22:	0f 90       	pop	r0
    9d24:	0f 90       	pop	r0
    9d26:	0e 94 28 3d 	call	0x7a50	; 0x7a50 <GSM_SendFirstChar>
}
    9d2a:	1f 91       	pop	r17
    9d2c:	0f 91       	pop	r16
    9d2e:	ff 90       	pop	r15
    9d30:	ef 90       	pop	r14
    9d32:	08 95       	ret

00009d34 <GSM_Execute_Command>:
	GSMTxSz = Size;
	memcpy(GSM_TxStr, Data_Out, GSMTxSz);
	GSM_SendFirstChar();
}
// ~~~~~~~~~
void GSM_Execute_Command(prog_char *Str_P, uint16_t Timeout){
    9d34:	cf 93       	push	r28
    9d36:	df 93       	push	r29
    9d38:	9c 01       	movw	r18, r24
    9d3a:	eb 01       	movw	r28, r22
	if(GSM_Flag & (1<<flg_TxCStr)){
    9d3c:	80 91 d2 02 	lds	r24, 0x02D2
    9d40:	80 ff       	sbrs	r24, 0
    9d42:	08 c0       	rjmp	.+16     	; 0x9d54 <GSM_Execute_Command+0x20>
		GSM_SendCR(Str_P);
    9d44:	c9 01       	movw	r24, r18
    9d46:	0e 94 6c 4e 	call	0x9cd8	; 0x9cd8 <GSM_SendCR>
		StartTimer16(TD_GSM, Timeout);
    9d4a:	80 91 e9 04 	lds	r24, 0x04E9
    9d4e:	be 01       	movw	r22, r28
    9d50:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
	}
}
    9d54:	df 91       	pop	r29
    9d56:	cf 91       	pop	r28
    9d58:	08 95       	ret

00009d5a <analize_DTMF>:
uint8_t GSM_GotoNextVega(void){
 return 0;
}
uint8_t counter=0;
uint8_t analize_DTMF(){
	if((strstr_P(GSM_RxStr, PSTR("+DTMF: 1")) != NULL) ){
    9d5a:	81 ee       	ldi	r24, 0xE1	; 225
    9d5c:	97 e0       	ldi	r25, 0x07	; 7
    9d5e:	6f e5       	ldi	r22, 0x5F	; 95
    9d60:	74 e3       	ldi	r23, 0x34	; 52
    9d62:	0e 94 58 84 	call	0x108b0	; 0x108b0 <strstr_P>
    9d66:	89 2b       	or	r24, r25
    9d68:	59 f0       	breq	.+22     	; 0x9d80 <analize_DTMF+0x26>
		StartTimer16(TD_GSM,1000);
    9d6a:	80 91 e9 04 	lds	r24, 0x04E9
    9d6e:	68 ee       	ldi	r22, 0xE8	; 232
    9d70:	73 e0       	ldi	r23, 0x03	; 3
    9d72:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
		GSM_State = GSM_SEND_CREC_5;
    9d76:	8b e1       	ldi	r24, 0x1B	; 27
    9d78:	80 93 f6 06 	sts	0x06F6, r24
    9d7c:	81 e0       	ldi	r24, 0x01	; 1
    9d7e:	08 95       	ret
		return 1;
	}
	if((strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 2,0,6")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 3,0,6")) != NULL) ){
    9d80:	81 ee       	ldi	r24, 0xE1	; 225
    9d82:	97 e0       	ldi	r25, 0x07	; 7
    9d84:	62 e5       	ldi	r22, 0x52	; 82
    9d86:	74 e3       	ldi	r23, 0x34	; 52
    9d88:	0e 94 58 84 	call	0x108b0	; 0x108b0 <strstr_P>
    9d8c:	89 2b       	or	r24, r25
    9d8e:	59 f0       	breq	.+22     	; 0x9da6 <analize_DTMF+0x4c>
		StartTimer16(TD_GSM,2000);
    9d90:	80 91 e9 04 	lds	r24, 0x04E9
    9d94:	60 ed       	ldi	r22, 0xD0	; 208
    9d96:	77 e0       	ldi	r23, 0x07	; 7
    9d98:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
		GSM_State = GSM_WAIT_DISCONNECT_CAUSE;
    9d9c:	85 e2       	ldi	r24, 0x25	; 37
    9d9e:	80 93 f6 06 	sts	0x06F6, r24
    9da2:	81 e0       	ldi	r24, 0x01	; 1
		return 1;
	}
	return 0;
}
    9da4:	08 95       	ret
	if((strstr_P(GSM_RxStr, PSTR("+DTMF: 1")) != NULL) ){
		StartTimer16(TD_GSM,1000);
		GSM_State = GSM_SEND_CREC_5;
		return 1;
	}
	if((strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 2,0,6")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 3,0,6")) != NULL) ){
    9da6:	81 ee       	ldi	r24, 0xE1	; 225
    9da8:	97 e0       	ldi	r25, 0x07	; 7
    9daa:	65 e4       	ldi	r22, 0x45	; 69
    9dac:	74 e3       	ldi	r23, 0x34	; 52
    9dae:	0e 94 58 84 	call	0x108b0	; 0x108b0 <strstr_P>
    9db2:	89 2b       	or	r24, r25
    9db4:	69 f7       	brne	.-38     	; 0x9d90 <analize_DTMF+0x36>
    9db6:	81 ee       	ldi	r24, 0xE1	; 225
    9db8:	97 e0       	ldi	r25, 0x07	; 7
    9dba:	68 e3       	ldi	r22, 0x38	; 56
    9dbc:	74 e3       	ldi	r23, 0x34	; 52
    9dbe:	0e 94 58 84 	call	0x108b0	; 0x108b0 <strstr_P>
    9dc2:	89 2b       	or	r24, r25
    9dc4:	29 f7       	brne	.-54     	; 0x9d90 <analize_DTMF+0x36>
    9dc6:	80 e0       	ldi	r24, 0x00	; 0
    9dc8:	08 95       	ret

00009dca <GSM_Wait_Response>:
	#endif

}
// ~~~~~~~~~
//   GetStringFromFIFO()!
uint8_t GSM_Wait_Response(char *Str, uint8_t RestoreCMD){
    9dca:	bc 01       	movw	r22, r24
//	if(Timer16Stopp(TD_GSM) && RestoreCMD){
//		GSM_State = RestoreCMD;
//		return 0;
//	}
	if(strcmp(GSM_RxStr, Str))return 0;
    9dcc:	81 ee       	ldi	r24, 0xE1	; 225
    9dce:	97 e0       	ldi	r25, 0x07	; 7
    9dd0:	0e 94 86 84 	call	0x1090c	; 0x1090c <strcmp>
    9dd4:	9c 01       	movw	r18, r24
    9dd6:	80 e0       	ldi	r24, 0x00	; 0
    9dd8:	23 2b       	or	r18, r19
    9dda:	09 f4       	brne	.+2      	; 0x9dde <GSM_Wait_Response+0x14>
    9ddc:	81 e0       	ldi	r24, 0x01	; 1
	else return 1;
}
    9dde:	08 95       	ret

00009de0 <DigiFilt>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
DigiFilt(const uint16_t *Array, uint8_t Edge)
{
    9de0:	6f 92       	push	r6
    9de2:	7f 92       	push	r7
    9de4:	8f 92       	push	r8
    9de6:	9f 92       	push	r9
    9de8:	bf 92       	push	r11
    9dea:	cf 92       	push	r12
    9dec:	df 92       	push	r13
    9dee:	ef 92       	push	r14
    9df0:	ff 92       	push	r15
    9df2:	0f 93       	push	r16
    9df4:	1f 93       	push	r17
    9df6:	df 93       	push	r29
    9df8:	cf 93       	push	r28
    9dfa:	cd b7       	in	r28, 0x3d	; 61
    9dfc:	de b7       	in	r29, 0x3e	; 62
    9dfe:	28 2f       	mov	r18, r24
    9e00:	79 2f       	mov	r23, r25
    9e02:	e6 2e       	mov	r14, r22
				Buf[i] = Buf[j];
				Buf[j] = Swap;
			}
	for(i=Edge; i<_Edge; Sum+=Buf[i++]);
	return Sum/(Edge*2);
}
    9e04:	6d b6       	in	r6, 0x3d	; 61
    9e06:	7e b6       	in	r7, 0x3e	; 62

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
DigiFilt(const uint16_t *Array, uint8_t Edge)
{
	uint8_t Sz = Edge*4;
    9e08:	86 2e       	mov	r8, r22
    9e0a:	99 24       	eor	r9, r9
    9e0c:	f6 2e       	mov	r15, r22
    9e0e:	ff 0c       	add	r15, r15
    9e10:	ff 0c       	add	r15, r15
	uint8_t _Edge = Sz-Edge;
    9e12:	bf 2c       	mov	r11, r15
    9e14:	b6 1a       	sub	r11, r22
	uint16_t Buf[Sz];
    9e16:	ef 2d       	mov	r30, r15
    9e18:	f0 e0       	ldi	r31, 0x00	; 0
    9e1a:	ee 0f       	add	r30, r30
    9e1c:	ff 1f       	adc	r31, r31
    9e1e:	8d b7       	in	r24, 0x3d	; 61
    9e20:	9e b7       	in	r25, 0x3e	; 62
    9e22:	8e 1b       	sub	r24, r30
    9e24:	9f 0b       	sbc	r25, r31
    9e26:	0f b6       	in	r0, 0x3f	; 63
    9e28:	f8 94       	cli
    9e2a:	9e bf       	out	0x3e, r25	; 62
    9e2c:	0f be       	out	0x3f, r0	; 63
    9e2e:	8d bf       	out	0x3d, r24	; 61
    9e30:	0d b7       	in	r16, 0x3d	; 61
    9e32:	1e b7       	in	r17, 0x3e	; 62
    9e34:	0f 5f       	subi	r16, 0xFF	; 255
    9e36:	1f 4f       	sbci	r17, 0xFF	; 255
	uint32_t Sum = 0;
	uint16_t Swap;
	uint8_t i, j;
	memcpy(Buf, Array, Sz*2);
    9e38:	c8 01       	movw	r24, r16
    9e3a:	62 2f       	mov	r22, r18
    9e3c:	af 01       	movw	r20, r30
    9e3e:	0e 94 72 84 	call	0x108e4	; 0x108e4 <memcpy>
	for(i=0; i<Edge; i++)
    9e42:	ee 20       	and	r14, r14
    9e44:	09 f1       	breq	.+66     	; 0x9e88 <DigiFilt+0xa8>
    9e46:	d8 01       	movw	r26, r16
    9e48:	80 e0       	ldi	r24, 0x00	; 0
		for(j=i+1; j<Sz; j++)
    9e4a:	58 2f       	mov	r21, r24
    9e4c:	5f 5f       	subi	r21, 0xFF	; 255
    9e4e:	5f 15       	cp	r21, r15
    9e50:	b8 f4       	brcc	.+46     	; 0x9e80 <DigiFilt+0xa0>
    9e52:	45 2f       	mov	r20, r21
			if(Buf[j] < Buf[i]) {
    9e54:	e4 2f       	mov	r30, r20
    9e56:	f0 e0       	ldi	r31, 0x00	; 0
    9e58:	ee 0f       	add	r30, r30
    9e5a:	ff 1f       	adc	r31, r31
    9e5c:	e0 0f       	add	r30, r16
    9e5e:	f1 1f       	adc	r31, r17
    9e60:	20 81       	ld	r18, Z
    9e62:	31 81       	ldd	r19, Z+1	; 0x01
    9e64:	8d 91       	ld	r24, X+
    9e66:	9c 91       	ld	r25, X
    9e68:	11 97       	sbiw	r26, 0x01	; 1
    9e6a:	28 17       	cp	r18, r24
    9e6c:	39 07       	cpc	r19, r25
    9e6e:	28 f4       	brcc	.+10     	; 0x9e7a <DigiFilt+0x9a>
				Swap = Buf[i];
				Buf[i] = Buf[j];
    9e70:	11 96       	adiw	r26, 0x01	; 1
    9e72:	3c 93       	st	X, r19
    9e74:	2e 93       	st	-X, r18
				Buf[j] = Swap;
    9e76:	91 83       	std	Z+1, r25	; 0x01
    9e78:	80 83       	st	Z, r24
	uint32_t Sum = 0;
	uint16_t Swap;
	uint8_t i, j;
	memcpy(Buf, Array, Sz*2);
	for(i=0; i<Edge; i++)
		for(j=i+1; j<Sz; j++)
    9e7a:	4f 5f       	subi	r20, 0xFF	; 255
    9e7c:	4f 15       	cp	r20, r15
    9e7e:	50 f3       	brcs	.-44     	; 0x9e54 <DigiFilt+0x74>
    9e80:	12 96       	adiw	r26, 0x02	; 2
    9e82:	85 2f       	mov	r24, r21
	uint16_t Buf[Sz];
	uint32_t Sum = 0;
	uint16_t Swap;
	uint8_t i, j;
	memcpy(Buf, Array, Sz*2);
	for(i=0; i<Edge; i++)
    9e84:	5e 15       	cp	r21, r14
    9e86:	08 f3       	brcs	.-62     	; 0x9e4a <DigiFilt+0x6a>
			if(Buf[j] < Buf[i]) {
				Swap = Buf[i];
				Buf[i] = Buf[j];
				Buf[j] = Swap;
			}
	for(i=Sz-1; i>=_Edge; i--)
    9e88:	ef 2d       	mov	r30, r15
    9e8a:	e1 50       	subi	r30, 0x01	; 1
    9e8c:	eb 15       	cp	r30, r11
    9e8e:	10 f1       	brcs	.+68     	; 0x9ed4 <DigiFilt+0xf4>
		for(j=i-1; j>=Edge; j--)
    9e90:	5e 2f       	mov	r21, r30
    9e92:	51 50       	subi	r21, 0x01	; 1
    9e94:	5e 15       	cp	r21, r14
    9e96:	d8 f0       	brcs	.+54     	; 0x9ece <DigiFilt+0xee>
    9e98:	f0 e0       	ldi	r31, 0x00	; 0
    9e9a:	45 2f       	mov	r20, r21
    9e9c:	ee 0f       	add	r30, r30
    9e9e:	ff 1f       	adc	r31, r31
			if(Buf[j] > Buf[i]) {
    9ea0:	e0 0f       	add	r30, r16
    9ea2:	f1 1f       	adc	r31, r17
    9ea4:	a4 2f       	mov	r26, r20
    9ea6:	b0 e0       	ldi	r27, 0x00	; 0
    9ea8:	aa 0f       	add	r26, r26
    9eaa:	bb 1f       	adc	r27, r27
    9eac:	a0 0f       	add	r26, r16
    9eae:	b1 1f       	adc	r27, r17
    9eb0:	2d 91       	ld	r18, X+
    9eb2:	3c 91       	ld	r19, X
    9eb4:	11 97       	sbiw	r26, 0x01	; 1
    9eb6:	80 81       	ld	r24, Z
    9eb8:	91 81       	ldd	r25, Z+1	; 0x01
    9eba:	82 17       	cp	r24, r18
    9ebc:	93 07       	cpc	r25, r19
    9ebe:	20 f4       	brcc	.+8      	; 0x9ec8 <DigiFilt+0xe8>
				Swap = Buf[i];
				Buf[i] = Buf[j];
    9ec0:	31 83       	std	Z+1, r19	; 0x01
    9ec2:	20 83       	st	Z, r18
				Buf[j] = Swap;
    9ec4:	8d 93       	st	X+, r24
    9ec6:	9c 93       	st	X, r25
				Swap = Buf[i];
				Buf[i] = Buf[j];
				Buf[j] = Swap;
			}
	for(i=Sz-1; i>=_Edge; i--)
		for(j=i-1; j>=Edge; j--)
    9ec8:	41 50       	subi	r20, 0x01	; 1
    9eca:	4e 15       	cp	r20, r14
    9ecc:	58 f7       	brcc	.-42     	; 0x9ea4 <DigiFilt+0xc4>
    9ece:	e5 2f       	mov	r30, r21
			if(Buf[j] < Buf[i]) {
				Swap = Buf[i];
				Buf[i] = Buf[j];
				Buf[j] = Swap;
			}
	for(i=Sz-1; i>=_Edge; i--)
    9ed0:	5b 15       	cp	r21, r11
    9ed2:	f0 f6       	brcc	.-68     	; 0x9e90 <DigiFilt+0xb0>
			if(Buf[j] > Buf[i]) {
				Swap = Buf[i];
				Buf[i] = Buf[j];
				Buf[j] = Swap;
			}
	for(i=Edge; i<_Edge; Sum+=Buf[i++]);
    9ed4:	eb 14       	cp	r14, r11
    9ed6:	a0 f5       	brcc	.+104    	; 0x9f40 <DigiFilt+0x160>
    9ed8:	6e 2d       	mov	r22, r14
    9eda:	cc 24       	eor	r12, r12
    9edc:	dd 24       	eor	r13, r13
    9ede:	76 01       	movw	r14, r12
    9ee0:	e6 2f       	mov	r30, r22
    9ee2:	f0 e0       	ldi	r31, 0x00	; 0
    9ee4:	ee 0f       	add	r30, r30
    9ee6:	ff 1f       	adc	r31, r31
    9ee8:	e0 0f       	add	r30, r16
    9eea:	f1 1f       	adc	r31, r17
    9eec:	80 81       	ld	r24, Z
    9eee:	91 81       	ldd	r25, Z+1	; 0x01
    9ef0:	a0 e0       	ldi	r26, 0x00	; 0
    9ef2:	b0 e0       	ldi	r27, 0x00	; 0
    9ef4:	c8 0e       	add	r12, r24
    9ef6:	d9 1e       	adc	r13, r25
    9ef8:	ea 1e       	adc	r14, r26
    9efa:	fb 1e       	adc	r15, r27
    9efc:	6f 5f       	subi	r22, 0xFF	; 255
    9efe:	6b 15       	cp	r22, r11
    9f00:	78 f3       	brcs	.-34     	; 0x9ee0 <DigiFilt+0x100>
    9f02:	88 0c       	add	r8, r8
    9f04:	99 1c       	adc	r9, r9
    9f06:	94 01       	movw	r18, r8
    9f08:	44 27       	eor	r20, r20
    9f0a:	37 fd       	sbrc	r19, 7
    9f0c:	40 95       	com	r20
    9f0e:	54 2f       	mov	r21, r20
    9f10:	c7 01       	movw	r24, r14
    9f12:	b6 01       	movw	r22, r12
    9f14:	0e 94 de 87 	call	0x10fbc	; 0x10fbc <__udivmodsi4>
    9f18:	c9 01       	movw	r24, r18
	return Sum/(Edge*2);
}
    9f1a:	0f b6       	in	r0, 0x3f	; 63
    9f1c:	f8 94       	cli
    9f1e:	7e be       	out	0x3e, r7	; 62
    9f20:	0f be       	out	0x3f, r0	; 63
    9f22:	6d be       	out	0x3d, r6	; 61
    9f24:	cf 91       	pop	r28
    9f26:	df 91       	pop	r29
    9f28:	1f 91       	pop	r17
    9f2a:	0f 91       	pop	r16
    9f2c:	ff 90       	pop	r15
    9f2e:	ef 90       	pop	r14
    9f30:	df 90       	pop	r13
    9f32:	cf 90       	pop	r12
    9f34:	bf 90       	pop	r11
    9f36:	9f 90       	pop	r9
    9f38:	8f 90       	pop	r8
    9f3a:	7f 90       	pop	r7
    9f3c:	6f 90       	pop	r6
    9f3e:	08 95       	ret
			if(Buf[j] > Buf[i]) {
				Swap = Buf[i];
				Buf[i] = Buf[j];
				Buf[j] = Swap;
			}
	for(i=Edge; i<_Edge; Sum+=Buf[i++]);
    9f40:	cc 24       	eor	r12, r12
    9f42:	dd 24       	eor	r13, r13
    9f44:	76 01       	movw	r14, r12
    9f46:	dd cf       	rjmp	.-70     	; 0x9f02 <DigiFilt+0x122>

00009f48 <MemFailReset>:

// ~~~~~~~~~~~~~~~
void
MemFailReset(void)
{
	if (MemFail &(1<<MemFail_EEPROM)) {
    9f48:	80 91 17 09 	lds	r24, 0x0917
    9f4c:	81 ff       	sbrs	r24, 1
    9f4e:	08 95       	ret
		MemFail &=~(1<<MemFail_EEPROM);
    9f50:	8d 7f       	andi	r24, 0xFD	; 253
    9f52:	80 93 17 09 	sts	0x0917, r24
		eeprom_write_word(&MemCheck_stor.CRC_EEPROM_stor, CRC_EEPROM_calc());
    9f56:	0e 94 23 1d 	call	0x3a46	; 0x3a46 <CRC_EEPROM_calc>
    9f5a:	bc 01       	movw	r22, r24
    9f5c:	8a e9       	ldi	r24, 0x9A	; 154
    9f5e:	91 e0       	ldi	r25, 0x01	; 1
    9f60:	0e 94 84 87 	call	0x10f08	; 0x10f08 <__eewr_word_m2560>
    9f64:	08 95       	ret

00009f66 <Key_Mem>:
		MenuPage Menu_BackUp = { SetMenu(Menu_BackUp_List), 1, NULL,
				NULL, NULL, NULL, Menu_BackUp_Enter, NULL, NULL, NULL};
#endif

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t Key_Mem(void) {if(CurrLine==3) MemFailReset(); return StandartKey;}
    9f66:	80 91 ca 07 	lds	r24, 0x07CA
    9f6a:	83 30       	cpi	r24, 0x03	; 3
    9f6c:	11 f0       	breq	.+4      	; 0x9f72 <Key_Mem+0xc>
    9f6e:	80 e0       	ldi	r24, 0x00	; 0
    9f70:	08 95       	ret
    9f72:	0e 94 a4 4f 	call	0x9f48	; 0x9f48 <MemFailReset>
    9f76:	80 e0       	ldi	r24, 0x00	; 0
    9f78:	08 95       	ret

00009f7a <CRC_EEPROM_upd>:
// ~~~~~~~~~~~~~~~~~
// Duration: 48 ms
static void
CRC_EEPROM_upd(void)
{
	if (!(MemFail &(1<<MemFail_EEPROM)))
    9f7a:	80 91 17 09 	lds	r24, 0x0917
    9f7e:	81 fd       	sbrc	r24, 1
    9f80:	08 95       	ret
		eeprom_write_word(&MemCheck_stor.CRC_EEPROM_stor, CRC_EEPROM_calc());
    9f82:	0e 94 23 1d 	call	0x3a46	; 0x3a46 <CRC_EEPROM_calc>
    9f86:	bc 01       	movw	r22, r24
    9f88:	8a e9       	ldi	r24, 0x9A	; 154
    9f8a:	91 e0       	ldi	r25, 0x01	; 1
    9f8c:	0e 94 84 87 	call	0x10f08	; 0x10f08 <__eewr_word_m2560>
    9f90:	08 95       	ret

00009f92 <ewb>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ewb(uint8_t *addr, uint8_t val)
{
	//IntOff();
	eeprom_write_byte(addr, val);
    9f92:	0e 94 6e 87 	call	0x10edc	; 0x10edc <__eewr_byte_m2560>
	CRC_EEPROM_upd();
    9f96:	0e 94 bd 4f 	call	0x9f7a	; 0x9f7a <CRC_EEPROM_upd>
	//IntOn();
}
    9f9a:	08 95       	ret

00009f9c <MB_M_TimeOff_Set>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_M_TimeOff_Set(uint8_t MB_N)
{
	ewb(&MB_M_Param_EE[MB_N].TimeOff, MB_M_TimeOff[MB_N]);
    9f9c:	e8 2f       	mov	r30, r24
    9f9e:	f0 e0       	ldi	r31, 0x00	; 0
    9fa0:	cf 01       	movw	r24, r30
    9fa2:	88 0f       	add	r24, r24
    9fa4:	99 1f       	adc	r25, r25
    9fa6:	88 0f       	add	r24, r24
    9fa8:	99 1f       	adc	r25, r25
    9faa:	8e 0f       	add	r24, r30
    9fac:	9f 1f       	adc	r25, r31
    9fae:	e1 52       	subi	r30, 0x21	; 33
    9fb0:	fa 4f       	sbci	r31, 0xFA	; 250
    9fb2:	8a 56       	subi	r24, 0x6A	; 106
    9fb4:	9e 4f       	sbci	r25, 0xFE	; 254
    9fb6:	60 81       	ld	r22, Z
    9fb8:	0e 94 c9 4f 	call	0x9f92	; 0x9f92 <ewb>
}
    9fbc:	08 95       	ret

00009fbe <MB_M_Try_Set>:

// ~~~~~~~~~~~~~~~~~~~~~~~
void
MB_M_Try_Set(uint8_t MB_N)
{
	ewb(&MB_M_Param_EE[MB_N].Try, MB_M_Try[MB_N]);
    9fbe:	e8 2f       	mov	r30, r24
    9fc0:	f0 e0       	ldi	r31, 0x00	; 0
    9fc2:	cf 01       	movw	r24, r30
    9fc4:	88 0f       	add	r24, r24
    9fc6:	99 1f       	adc	r25, r25
    9fc8:	88 0f       	add	r24, r24
    9fca:	99 1f       	adc	r25, r25
    9fcc:	8e 0f       	add	r24, r30
    9fce:	9f 1f       	adc	r25, r31
    9fd0:	e1 5c       	subi	r30, 0xC1	; 193
    9fd2:	f8 4f       	sbci	r31, 0xF8	; 248
    9fd4:	8b 56       	subi	r24, 0x6B	; 107
    9fd6:	9e 4f       	sbci	r25, 0xFE	; 254
    9fd8:	60 81       	ld	r22, Z
    9fda:	0e 94 c9 4f 	call	0x9f92	; 0x9f92 <ewb>
}
    9fde:	08 95       	ret

00009fe0 <MB_M_Timeout_Set>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_M_Timeout_Set(uint8_t MB_N)
{
	ewb(&MB_M_Param_EE[MB_N].Timeout, MB_M_Timeout[MB_N]);
    9fe0:	e8 2f       	mov	r30, r24
    9fe2:	f0 e0       	ldi	r31, 0x00	; 0
    9fe4:	cf 01       	movw	r24, r30
    9fe6:	88 0f       	add	r24, r24
    9fe8:	99 1f       	adc	r25, r25
    9fea:	88 0f       	add	r24, r24
    9fec:	99 1f       	adc	r25, r25
    9fee:	8e 0f       	add	r24, r30
    9ff0:	9f 1f       	adc	r25, r31
    9ff2:	e7 5d       	subi	r30, 0xD7	; 215
    9ff4:	f6 4f       	sbci	r31, 0xF6	; 246
    9ff6:	8c 56       	subi	r24, 0x6C	; 108
    9ff8:	9e 4f       	sbci	r25, 0xFE	; 254
    9ffa:	60 81       	ld	r22, Z
    9ffc:	0e 94 c9 4f 	call	0x9f92	; 0x9f92 <ewb>
}
    a000:	08 95       	ret

0000a002 <Set_MB_Addr>:
	static uint8_t EEMEM MB_NativeAddr_EE[Modbus_Qt] = Init_MB_NativeAddr;
	// ~~~~~~~~~~~~~~~~~~~~~~
	void
	Set_MB_Addr(uint8_t MB_N)
	{
		ewb(MB_NativeAddr_EE+MB_N, MB_NativeAddr[MB_N]);
    a002:	e8 2f       	mov	r30, r24
    a004:	f0 e0       	ldi	r31, 0x00	; 0
    a006:	cf 01       	movw	r24, r30
    a008:	89 56       	subi	r24, 0x69	; 105
    a00a:	9e 4f       	sbci	r25, 0xFE	; 254
    a00c:	e0 52       	subi	r30, 0x20	; 32
    a00e:	fa 4f       	sbci	r31, 0xFA	; 250
    a010:	60 81       	ld	r22, Z
    a012:	0e 94 c9 4f 	call	0x9f92	; 0x9f92 <ewb>
	}
    a016:	08 95       	ret

0000a018 <eww>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
eww(uint16_t *addr, uint16_t val)
{
	//IntOff();
	eeprom_write_word(addr, val);
    a018:	0e 94 84 87 	call	0x10f08	; 0x10f08 <__eewr_word_m2560>
	CRC_EEPROM_upd();
    a01c:	0e 94 bd 4f 	call	0x9f7a	; 0x9f7a <CRC_EEPROM_upd>
	//IntOn();
}
    a020:	08 95       	ret

0000a022 <MB_M_Period_Set>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_M_Period_Set(uint8_t MB_N)
{
	eww(&MB_M_Param_EE[MB_N].Period, MB_M_Period[MB_N]);
    a022:	e8 2f       	mov	r30, r24
    a024:	f0 e0       	ldi	r31, 0x00	; 0
    a026:	cf 01       	movw	r24, r30
    a028:	88 0f       	add	r24, r24
    a02a:	99 1f       	adc	r25, r25
    a02c:	88 0f       	add	r24, r24
    a02e:	99 1f       	adc	r25, r25
    a030:	8e 0f       	add	r24, r30
    a032:	9f 1f       	adc	r25, r31
    a034:	ee 0f       	add	r30, r30
    a036:	ff 1f       	adc	r31, r31
    a038:	e3 55       	subi	r30, 0x53	; 83
    a03a:	f9 4f       	sbci	r31, 0xF9	; 249
    a03c:	60 81       	ld	r22, Z
    a03e:	71 81       	ldd	r23, Z+1	; 0x01
    a040:	8e 56       	subi	r24, 0x6E	; 110
    a042:	9e 4f       	sbci	r25, 0xFE	; 254
    a044:	0e 94 0c 50 	call	0xa018	; 0xa018 <eww>
}
    a048:	08 95       	ret

0000a04a <OnTimeSave>:

// ~~~~~~~~~~~~~
void
OnTimeSave(void)
{
	ewb(&Timer1min_EE, Timer1min);
    a04a:	8d e9       	ldi	r24, 0x9D	; 157
    a04c:	91 e0       	ldi	r25, 0x01	; 1
    a04e:	60 91 b0 06 	lds	r22, 0x06B0
    a052:	0e 94 c9 4f 	call	0x9f92	; 0x9f92 <ewb>
	eww(&Timer1hour_EE, Timer1hour);
    a056:	60 91 6b 0c 	lds	r22, 0x0C6B
    a05a:	70 91 6c 0c 	lds	r23, 0x0C6C
    a05e:	8e e9       	ldi	r24, 0x9E	; 158
    a060:	91 e0       	ldi	r25, 0x01	; 1
    a062:	0e 94 0c 50 	call	0xa018	; 0xa018 <eww>
}
    a066:	08 95       	ret

0000a068 <TimersInc>:
		HSC_Process();
	#endif
}
void 
TimersInc(void)
{
    a068:	ef 92       	push	r14
    a06a:	ff 92       	push	r15
    a06c:	0f 93       	push	r16
    a06e:	1f 93       	push	r17
    a070:	cf 93       	push	r28
    a072:	df 93       	push	r29
	uint8_t i, TickCounterVar;	
	cli();
    a074:	f8 94       	cli
	TickCounterVar = TickCounter;
    a076:	e0 90 d1 04 	lds	r14, 0x04D1
	TickCounter = 0;
    a07a:	10 92 d1 04 	sts	0x04D1, r1
	sei();
    a07e:	78 94       	sei
	for(uint8_t j=0;j<TickCounterVar;j++){
    a080:	ee 20       	and	r14, r14
    a082:	09 f4       	brne	.+2      	; 0xa086 <TimersInc+0x1e>
    a084:	c8 c0       	rjmp	.+400    	; 0xa216 <TimersInc+0x1ae>
    a086:	ff 24       	eor	r15, r15
		LiveTime++;
	 	for (i=0; i<Timer8TotNumber; i++){
			cli();
			if (!(Timer8Flg[i/8] &(1<<i%8)) && --Timer8[i]==0)
				Timer8Flg[i/8] |=(1<<i%8);
    a088:	01 e0       	ldi	r16, 0x01	; 1
    a08a:	10 e0       	ldi	r17, 0x00	; 0
	cli();
	TickCounterVar = TickCounter;
	TickCounter = 0;
	sei();
	for(uint8_t j=0;j<TickCounterVar;j++){
		LiveTime++;
    a08c:	80 91 c5 07 	lds	r24, 0x07C5
    a090:	90 91 c6 07 	lds	r25, 0x07C6
    a094:	a0 91 c7 07 	lds	r26, 0x07C7
    a098:	b0 91 c8 07 	lds	r27, 0x07C8
    a09c:	01 96       	adiw	r24, 0x01	; 1
    a09e:	a1 1d       	adc	r26, r1
    a0a0:	b1 1d       	adc	r27, r1
    a0a2:	80 93 c5 07 	sts	0x07C5, r24
    a0a6:	90 93 c6 07 	sts	0x07C6, r25
    a0aa:	a0 93 c7 07 	sts	0x07C7, r26
    a0ae:	b0 93 c8 07 	sts	0x07C8, r27
    a0b2:	40 e0       	ldi	r20, 0x00	; 0
    a0b4:	50 e0       	ldi	r21, 0x00	; 0
	 	for (i=0; i<Timer8TotNumber; i++){
			cli();
    a0b6:	f8 94       	cli
			if (!(Timer8Flg[i/8] &(1<<i%8)) && --Timer8[i]==0)
    a0b8:	84 2f       	mov	r24, r20
    a0ba:	86 95       	lsr	r24
    a0bc:	86 95       	lsr	r24
    a0be:	86 95       	lsr	r24
    a0c0:	a8 2f       	mov	r26, r24
    a0c2:	b0 e0       	ldi	r27, 0x00	; 0
    a0c4:	af 54       	subi	r26, 0x4F	; 79
    a0c6:	bb 4f       	sbci	r27, 0xFB	; 251
    a0c8:	8c 91       	ld	r24, X
    a0ca:	ba 01       	movw	r22, r20
    a0cc:	67 70       	andi	r22, 0x07	; 7
    a0ce:	70 70       	andi	r23, 0x00	; 0
    a0d0:	90 e0       	ldi	r25, 0x00	; 0
    a0d2:	06 2e       	mov	r0, r22
    a0d4:	02 c0       	rjmp	.+4      	; 0xa0da <TimersInc+0x72>
    a0d6:	95 95       	asr	r25
    a0d8:	87 95       	ror	r24
    a0da:	0a 94       	dec	r0
    a0dc:	e2 f7       	brpl	.-8      	; 0xa0d6 <TimersInc+0x6e>
    a0de:	80 fd       	sbrc	r24, 0
    a0e0:	12 c0       	rjmp	.+36     	; 0xa106 <TimersInc+0x9e>
    a0e2:	fa 01       	movw	r30, r20
    a0e4:	e9 50       	subi	r30, 0x09	; 9
    a0e6:	fd 4f       	sbci	r31, 0xFD	; 253
    a0e8:	80 81       	ld	r24, Z
    a0ea:	81 50       	subi	r24, 0x01	; 1
    a0ec:	80 83       	st	Z, r24
    a0ee:	80 81       	ld	r24, Z
    a0f0:	88 23       	and	r24, r24
    a0f2:	49 f4       	brne	.+18     	; 0xa106 <TimersInc+0x9e>
				Timer8Flg[i/8] |=(1<<i%8);
    a0f4:	2c 91       	ld	r18, X
    a0f6:	c8 01       	movw	r24, r16
    a0f8:	02 c0       	rjmp	.+4      	; 0xa0fe <TimersInc+0x96>
    a0fa:	88 0f       	add	r24, r24
    a0fc:	99 1f       	adc	r25, r25
    a0fe:	6a 95       	dec	r22
    a100:	e2 f7       	brpl	.-8      	; 0xa0fa <TimersInc+0x92>
    a102:	28 2b       	or	r18, r24
    a104:	2c 93       	st	X, r18
			sei();
    a106:	78 94       	sei
    a108:	4f 5f       	subi	r20, 0xFF	; 255
    a10a:	5f 4f       	sbci	r21, 0xFF	; 255
	TickCounterVar = TickCounter;
	TickCounter = 0;
	sei();
	for(uint8_t j=0;j<TickCounterVar;j++){
		LiveTime++;
	 	for (i=0; i<Timer8TotNumber; i++){
    a10c:	48 35       	cpi	r20, 0x58	; 88
    a10e:	51 05       	cpc	r21, r1
    a110:	91 f6       	brne	.-92     	; 0xa0b6 <TimersInc+0x4e>
    a112:	40 e0       	ldi	r20, 0x00	; 0
    a114:	50 e0       	ldi	r21, 0x00	; 0
			if (!(Timer8Flg[i/8] &(1<<i%8)) && --Timer8[i]==0)
				Timer8Flg[i/8] |=(1<<i%8);
			sei();
		}
		for (i=0; i<Timer16TotNumber; i++){
			cli();
    a116:	f8 94       	cli
			if (!(Timer16Flg[i/8] &(1<<i%8)) && --Timer16[i]==0)
    a118:	84 2f       	mov	r24, r20
    a11a:	86 95       	lsr	r24
    a11c:	86 95       	lsr	r24
    a11e:	86 95       	lsr	r24
    a120:	a8 2f       	mov	r26, r24
    a122:	b0 e0       	ldi	r27, 0x00	; 0
    a124:	a3 54       	subi	r26, 0x43	; 67
    a126:	bb 4f       	sbci	r27, 0xFB	; 251
    a128:	8c 91       	ld	r24, X
    a12a:	ba 01       	movw	r22, r20
    a12c:	67 70       	andi	r22, 0x07	; 7
    a12e:	70 70       	andi	r23, 0x00	; 0
    a130:	90 e0       	ldi	r25, 0x00	; 0
    a132:	06 2e       	mov	r0, r22
    a134:	02 c0       	rjmp	.+4      	; 0xa13a <TimersInc+0xd2>
    a136:	95 95       	asr	r25
    a138:	87 95       	ror	r24
    a13a:	0a 94       	dec	r0
    a13c:	e2 f7       	brpl	.-8      	; 0xa136 <TimersInc+0xce>
    a13e:	80 fd       	sbrc	r24, 0
    a140:	17 c0       	rjmp	.+46     	; 0xa170 <TimersInc+0x108>
    a142:	fa 01       	movw	r30, r20
    a144:	ee 0f       	add	r30, r30
    a146:	ff 1f       	adc	r31, r31
    a148:	e1 5b       	subi	r30, 0xB1	; 177
    a14a:	fc 4f       	sbci	r31, 0xFC	; 252
    a14c:	80 81       	ld	r24, Z
    a14e:	91 81       	ldd	r25, Z+1	; 0x01
    a150:	01 97       	sbiw	r24, 0x01	; 1
    a152:	91 83       	std	Z+1, r25	; 0x01
    a154:	80 83       	st	Z, r24
    a156:	80 81       	ld	r24, Z
    a158:	91 81       	ldd	r25, Z+1	; 0x01
    a15a:	89 2b       	or	r24, r25
    a15c:	49 f4       	brne	.+18     	; 0xa170 <TimersInc+0x108>
				Timer16Flg[i/8] |=(1<<i%8);
    a15e:	2c 91       	ld	r18, X
    a160:	c8 01       	movw	r24, r16
    a162:	02 c0       	rjmp	.+4      	; 0xa168 <TimersInc+0x100>
    a164:	88 0f       	add	r24, r24
    a166:	99 1f       	adc	r25, r25
    a168:	6a 95       	dec	r22
    a16a:	e2 f7       	brpl	.-8      	; 0xa164 <TimersInc+0xfc>
    a16c:	28 2b       	or	r18, r24
    a16e:	2c 93       	st	X, r18
			sei();
    a170:	78 94       	sei
    a172:	4f 5f       	subi	r20, 0xFF	; 255
    a174:	5f 4f       	sbci	r21, 0xFF	; 255
			cli();
			if (!(Timer8Flg[i/8] &(1<<i%8)) && --Timer8[i]==0)
				Timer8Flg[i/8] |=(1<<i%8);
			sei();
		}
		for (i=0; i<Timer16TotNumber; i++){
    a176:	40 36       	cpi	r20, 0x60	; 96
    a178:	51 05       	cpc	r21, r1
    a17a:	69 f6       	brne	.-102    	; 0xa116 <TimersInc+0xae>
    a17c:	40 e0       	ldi	r20, 0x00	; 0
    a17e:	50 e0       	ldi	r21, 0x00	; 0
			if (!(Timer16Flg[i/8] &(1<<i%8)) && --Timer16[i]==0)
				Timer16Flg[i/8] |=(1<<i%8);
			sei();
		}
		for (i=0; i<Timer32TotNumber; i++){
			cli();
    a180:	f8 94       	cli
			if (!(Timer32Flg[i/8] &(1<<i%8)) && --Timer32[i]==0)
    a182:	84 2f       	mov	r24, r20
    a184:	86 95       	lsr	r24
    a186:	86 95       	lsr	r24
    a188:	86 95       	lsr	r24
    a18a:	c8 2f       	mov	r28, r24
    a18c:	d0 e0       	ldi	r29, 0x00	; 0
    a18e:	c6 53       	subi	r28, 0x36	; 54
    a190:	db 4f       	sbci	r29, 0xFB	; 251
    a192:	88 81       	ld	r24, Y
    a194:	ba 01       	movw	r22, r20
    a196:	67 70       	andi	r22, 0x07	; 7
    a198:	70 70       	andi	r23, 0x00	; 0
    a19a:	90 e0       	ldi	r25, 0x00	; 0
    a19c:	06 2e       	mov	r0, r22
    a19e:	02 c0       	rjmp	.+4      	; 0xa1a4 <TimersInc+0x13c>
    a1a0:	95 95       	asr	r25
    a1a2:	87 95       	ror	r24
    a1a4:	0a 94       	dec	r0
    a1a6:	e2 f7       	brpl	.-8      	; 0xa1a0 <TimersInc+0x138>
    a1a8:	80 fd       	sbrc	r24, 0
    a1aa:	23 c0       	rjmp	.+70     	; 0xa1f2 <TimersInc+0x18a>
    a1ac:	fa 01       	movw	r30, r20
    a1ae:	ee 0f       	add	r30, r30
    a1b0:	ff 1f       	adc	r31, r31
    a1b2:	ee 0f       	add	r30, r30
    a1b4:	ff 1f       	adc	r31, r31
    a1b6:	e1 5f       	subi	r30, 0xF1	; 241
    a1b8:	fb 4f       	sbci	r31, 0xFB	; 251
    a1ba:	80 81       	ld	r24, Z
    a1bc:	91 81       	ldd	r25, Z+1	; 0x01
    a1be:	a2 81       	ldd	r26, Z+2	; 0x02
    a1c0:	b3 81       	ldd	r27, Z+3	; 0x03
    a1c2:	01 97       	sbiw	r24, 0x01	; 1
    a1c4:	a1 09       	sbc	r26, r1
    a1c6:	b1 09       	sbc	r27, r1
    a1c8:	80 83       	st	Z, r24
    a1ca:	91 83       	std	Z+1, r25	; 0x01
    a1cc:	a2 83       	std	Z+2, r26	; 0x02
    a1ce:	b3 83       	std	Z+3, r27	; 0x03
    a1d0:	80 81       	ld	r24, Z
    a1d2:	91 81       	ldd	r25, Z+1	; 0x01
    a1d4:	a2 81       	ldd	r26, Z+2	; 0x02
    a1d6:	b3 81       	ldd	r27, Z+3	; 0x03
    a1d8:	00 97       	sbiw	r24, 0x00	; 0
    a1da:	a1 05       	cpc	r26, r1
    a1dc:	b1 05       	cpc	r27, r1
    a1de:	49 f4       	brne	.+18     	; 0xa1f2 <TimersInc+0x18a>
				Timer32Flg[i/8] |=(1<<i%8);	
    a1e0:	28 81       	ld	r18, Y
    a1e2:	c8 01       	movw	r24, r16
    a1e4:	02 c0       	rjmp	.+4      	; 0xa1ea <TimersInc+0x182>
    a1e6:	88 0f       	add	r24, r24
    a1e8:	99 1f       	adc	r25, r25
    a1ea:	6a 95       	dec	r22
    a1ec:	e2 f7       	brpl	.-8      	; 0xa1e6 <TimersInc+0x17e>
    a1ee:	28 2b       	or	r18, r24
    a1f0:	28 83       	st	Y, r18
			sei();
    a1f2:	78 94       	sei
    a1f4:	4f 5f       	subi	r20, 0xFF	; 255
    a1f6:	5f 4f       	sbci	r21, 0xFF	; 255
			cli();
			if (!(Timer16Flg[i/8] &(1<<i%8)) && --Timer16[i]==0)
				Timer16Flg[i/8] |=(1<<i%8);
			sei();
		}
		for (i=0; i<Timer32TotNumber; i++){
    a1f8:	48 32       	cpi	r20, 0x28	; 40
    a1fa:	51 05       	cpc	r21, r1
    a1fc:	09 f0       	breq	.+2      	; 0xa200 <TimersInc+0x198>
    a1fe:	c0 cf       	rjmp	.-128    	; 0xa180 <TimersInc+0x118>
			sei();
		}

		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		static uint8_t Timer10ms;
		if (++Timer10ms==100) {
    a200:	80 91 ed 02 	lds	r24, 0x02ED
    a204:	8f 5f       	subi	r24, 0xFF	; 255
    a206:	80 93 ed 02 	sts	0x02ED, r24
    a20a:	84 36       	cpi	r24, 0x64	; 100
    a20c:	59 f0       	breq	.+22     	; 0xa224 <TimersInc+0x1bc>
	uint8_t i, TickCounterVar;	
	cli();
	TickCounterVar = TickCounter;
	TickCounter = 0;
	sei();
	for(uint8_t j=0;j<TickCounterVar;j++){
    a20e:	f3 94       	inc	r15
    a210:	fe 14       	cp	r15, r14
    a212:	08 f4       	brcc	.+2      	; 0xa216 <TimersInc+0x1ae>
    a214:	3b cf       	rjmp	.-394    	; 0xa08c <TimersInc+0x24>
 			ScanCount = 0;
			RT();
		}
		#endif
	}
}
    a216:	df 91       	pop	r29
    a218:	cf 91       	pop	r28
    a21a:	1f 91       	pop	r17
    a21c:	0f 91       	pop	r16
    a21e:	ff 90       	pop	r15
    a220:	ef 90       	pop	r14
    a222:	08 95       	ret
		}

		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		static uint8_t Timer10ms;
		if (++Timer10ms==100) {
			Timer10ms = 0;
    a224:	10 92 ed 02 	sts	0x02ED, r1
			ScanPerSec = ScanCount;
    a228:	80 91 b2 07 	lds	r24, 0x07B2
    a22c:	90 91 b3 07 	lds	r25, 0x07B3
    a230:	90 93 cf 07 	sts	0x07CF, r25
    a234:	80 93 ce 07 	sts	0x07CE, r24
 			ScanCount = 0;
    a238:	10 92 b3 07 	sts	0x07B3, r1
    a23c:	10 92 b2 07 	sts	0x07B2, r1

// ~~~~~~~~~~~~~~~
inline static void
RT(void)
{
	if (++Timer1s==60) {
    a240:	80 91 1a 09 	lds	r24, 0x091A
    a244:	8f 5f       	subi	r24, 0xFF	; 255
    a246:	80 93 1a 09 	sts	0x091A, r24
    a24a:	8c 33       	cpi	r24, 0x3C	; 60
    a24c:	01 f7       	brne	.-64     	; 0xa20e <TimersInc+0x1a6>
		Timer1s = 0;
    a24e:	10 92 1a 09 	sts	0x091A, r1
		if (++Timer1min==60) {
    a252:	80 91 b0 06 	lds	r24, 0x06B0
    a256:	8f 5f       	subi	r24, 0xFF	; 255
    a258:	80 93 b0 06 	sts	0x06B0, r24
    a25c:	8c 33       	cpi	r24, 0x3C	; 60
    a25e:	b9 f6       	brne	.-82     	; 0xa20e <TimersInc+0x1a6>
			Timer1min = 0;
    a260:	10 92 b0 06 	sts	0x06B0, r1
			++Timer1hour;
    a264:	80 91 6b 0c 	lds	r24, 0x0C6B
    a268:	90 91 6c 0c 	lds	r25, 0x0C6C
    a26c:	01 96       	adiw	r24, 0x01	; 1
    a26e:	90 93 6c 0c 	sts	0x0C6C, r25
    a272:	80 93 6b 0c 	sts	0x0C6B, r24
			OnTimeSave();
    a276:	0e 94 25 50 	call	0xa04a	; 0xa04a <OnTimeSave>
    a27a:	c9 cf       	rjmp	.-110    	; 0xa20e <TimersInc+0x1a6>

0000a27c <ewbl>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ewbl(const void *src, void *dst, size_t n)
{
	//IntOff();
	eeprom_write_block(src, dst, n);
    a27c:	0e 94 64 87 	call	0x10ec8	; 0x10ec8 <__eewr_block_m2560>
	CRC_EEPROM_upd();
    a280:	0e 94 bd 4f 	call	0x9f7a	; 0x9f7a <CRC_EEPROM_upd>
	//IntOn();
}
    a284:	08 95       	ret

0000a286 <ewd>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ewd(uint32_t *addr, uint32_t val)
{
	//IntOff();
	eeprom_write_dword(addr, val);
    a286:	0e 94 7c 87 	call	0x10ef8	; 0x10ef8 <__eewr_dword_m2560>
	CRC_EEPROM_upd();
    a28a:	0e 94 bd 4f 	call	0x9f7a	; 0x9f7a <CRC_EEPROM_upd>
	//IntOn();
}
    a28e:	08 95       	ret

0000a290 <erbl>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    a290:	0e 94 40 87 	call	0x10e80	; 0x10e80 <__eerd_block_m2560>
	//IntOn();
}
    a294:	08 95       	ret

0000a296 <erd>:
// ~~~~~~~~~~~~~~~~~~~~~~
uint32_t
erd(const uint32_t *addr)
{
	//IntOff();
	uint32_t word = eeprom_read_dword(addr);
    a296:	0e 94 58 87 	call	0x10eb0	; 0x10eb0 <__eerd_dword_m2560>
	//IntOn();
	return word;
}
    a29a:	08 95       	ret

0000a29c <erw>:
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    a29c:	0e 94 5e 87 	call	0x10ebc	; 0x10ebc <__eerd_word_m2560>
	//IntOn();
	return word;
}
    a2a0:	08 95       	ret

0000a2a2 <ChannelProcessing>:
	CHANNEL_WRITE_LOG,		//2
	CHANNEL_WAIT_CALL,		//3
	CHANNEL_CALLING,		//4
	CHANNEL_WAIT_RECALL		//5
};
void ChannelProcessing(uint8_t chNumber){
    a2a2:	ef 92       	push	r14
    a2a4:	ff 92       	push	r15
    a2a6:	0f 93       	push	r16
    a2a8:	1f 93       	push	r17
    a2aa:	cf 93       	push	r28
    a2ac:	df 93       	push	r29
	switch(Channels[chNumber].Alarm_State){
    a2ae:	c8 2f       	mov	r28, r24
    a2b0:	d0 e0       	ldi	r29, 0x00	; 0
    a2b2:	9e 01       	movw	r18, r28
    a2b4:	22 0f       	add	r18, r18
    a2b6:	33 1f       	adc	r19, r19
    a2b8:	79 01       	movw	r14, r18
    a2ba:	ee 0c       	add	r14, r14
    a2bc:	ff 1c       	adc	r15, r15
    a2be:	88 eb       	ldi	r24, 0xB8	; 184
    a2c0:	96 e0       	ldi	r25, 0x06	; 6
    a2c2:	e8 0e       	add	r14, r24
    a2c4:	f9 1e       	adc	r15, r25
    a2c6:	f7 01       	movw	r30, r14
    a2c8:	80 81       	ld	r24, Z
    a2ca:	82 30       	cpi	r24, 0x02	; 2
    a2cc:	09 f4       	brne	.+2      	; 0xa2d0 <ChannelProcessing+0x2e>
    a2ce:	7b c0       	rjmp	.+246    	; 0xa3c6 <ChannelProcessing+0x124>
    a2d0:	83 30       	cpi	r24, 0x03	; 3
    a2d2:	c8 f0       	brcs	.+50     	; 0xa306 <ChannelProcessing+0x64>
    a2d4:	84 30       	cpi	r24, 0x04	; 4
    a2d6:	09 f4       	brne	.+2      	; 0xa2da <ChannelProcessing+0x38>
    a2d8:	4c c0       	rjmp	.+152    	; 0xa372 <ChannelProcessing+0xd0>
    a2da:	84 30       	cpi	r24, 0x04	; 4
    a2dc:	08 f0       	brcs	.+2      	; 0xa2e0 <ChannelProcessing+0x3e>
    a2de:	46 c0       	rjmp	.+140    	; 0xa36c <ChannelProcessing+0xca>
				Channels[chNumber].Alarm_State = CHANNEL_WAIT_RECALL;
				StartTimer16(Channels[chNumber].timer, erw(&calling_retry_delay[chNumber])*100);
			}
			break;
		case CHANNEL_WAIT_RECALL:
			if(1 == Channels[chNumber].DI_State)
    a2e0:	fe 01       	movw	r30, r28
    a2e2:	ee 0f       	add	r30, r30
    a2e4:	ff 1f       	adc	r31, r31
    a2e6:	ee 0f       	add	r30, r30
    a2e8:	ff 1f       	adc	r31, r31
    a2ea:	ea 54       	subi	r30, 0x4A	; 74
    a2ec:	f9 4f       	sbci	r31, 0xF9	; 249
    a2ee:	81 81       	ldd	r24, Z+1	; 0x01
    a2f0:	81 30       	cpi	r24, 0x01	; 1
    a2f2:	99 f1       	breq	.+102    	; 0xa35a <ChannelProcessing+0xb8>
			{
				Channels[chNumber].Alarm_State = CHANNEL_PINSCAN;
				break;				
			} 
			if(Timer16Stopp(Channels[chNumber].timer)){
    a2f4:	83 81       	ldd	r24, Z+3	; 0x03
    a2f6:	0e 94 84 1f 	call	0x3f08	; 0x3f08 <Timer16Stopp>
    a2fa:	88 23       	and	r24, r24
    a2fc:	49 f0       	breq	.+18     	; 0xa310 <ChannelProcessing+0x6e>
				Channels[chNumber].Alarm_State = CHANNEL_CALLING;
    a2fe:	84 e0       	ldi	r24, 0x04	; 4
    a300:	f7 01       	movw	r30, r14
    a302:	80 83       	st	Z, r24
    a304:	05 c0       	rjmp	.+10     	; 0xa310 <ChannelProcessing+0x6e>
	CHANNEL_WAIT_CALL,		//3
	CHANNEL_CALLING,		//4
	CHANNEL_WAIT_RECALL		//5
};
void ChannelProcessing(uint8_t chNumber){
	switch(Channels[chNumber].Alarm_State){
    a306:	88 23       	and	r24, r24
    a308:	51 f0       	breq	.+20     	; 0xa31e <ChannelProcessing+0x7c>
    a30a:	81 30       	cpi	r24, 0x01	; 1
    a30c:	09 f4       	brne	.+2      	; 0xa310 <ChannelProcessing+0x6e>
    a30e:	7c c0       	rjmp	.+248    	; 0xa408 <ChannelProcessing+0x166>
			}			
			break;

	}

}
    a310:	df 91       	pop	r29
    a312:	cf 91       	pop	r28
    a314:	1f 91       	pop	r17
    a316:	0f 91       	pop	r16
    a318:	ff 90       	pop	r15
    a31a:	ef 90       	pop	r14
    a31c:	08 95       	ret
	CHANNEL_WAIT_RECALL		//5
};
void ChannelProcessing(uint8_t chNumber){
	switch(Channels[chNumber].Alarm_State){
		case CHANNEL_PINSCAN:
			if(0 == Channels[chNumber].DI_State)
    a31e:	cc 0f       	add	r28, r28
    a320:	dd 1f       	adc	r29, r29
    a322:	cc 0f       	add	r28, r28
    a324:	dd 1f       	adc	r29, r29
    a326:	ca 54       	subi	r28, 0x4A	; 74
    a328:	d9 4f       	sbci	r29, 0xF9	; 249
    a32a:	89 81       	ldd	r24, Y+1	; 0x01
    a32c:	88 23       	and	r24, r24
    a32e:	81 f7       	brne	.-32     	; 0xa310 <ChannelProcessing+0x6e>
			{
				Channels[chNumber].Alarm_State = CHANNEL_WAIT_DEBOUNCE;
    a330:	81 e0       	ldi	r24, 0x01	; 1
    a332:	f7 01       	movw	r30, r14
    a334:	80 83       	st	Z, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    a336:	c9 01       	movw	r24, r18
    a338:	8f 5c       	subi	r24, 0xCF	; 207
    a33a:	9e 4f       	sbci	r25, 0xFE	; 254
    a33c:	0e 94 5e 87 	call	0x10ebc	; 0x10ebc <__eerd_word_m2560>
				StartTimer16(Channels[chNumber].timer, erw(&debounceTimeout[chNumber])*100);
    a340:	24 e6       	ldi	r18, 0x64	; 100
    a342:	30 e0       	ldi	r19, 0x00	; 0
    a344:	82 9f       	mul	r24, r18
    a346:	b0 01       	movw	r22, r0
    a348:	83 9f       	mul	r24, r19
    a34a:	70 0d       	add	r23, r0
    a34c:	92 9f       	mul	r25, r18
    a34e:	70 0d       	add	r23, r0
    a350:	11 24       	eor	r1, r1
    a352:	8b 81       	ldd	r24, Y+3	; 0x03
    a354:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
    a358:	db cf       	rjmp	.-74     	; 0xa310 <ChannelProcessing+0x6e>
			}
			break;
		case CHANNEL_WAIT_RECALL:
			if(1 == Channels[chNumber].DI_State)
			{
				Channels[chNumber].Alarm_State = CHANNEL_PINSCAN;
    a35a:	f7 01       	movw	r30, r14
    a35c:	10 82       	st	Z, r1
			}			
			break;

	}

}
    a35e:	df 91       	pop	r29
    a360:	cf 91       	pop	r28
    a362:	1f 91       	pop	r17
    a364:	0f 91       	pop	r16
    a366:	ff 90       	pop	r15
    a368:	ef 90       	pop	r14
    a36a:	08 95       	ret
	CHANNEL_WAIT_CALL,		//3
	CHANNEL_CALLING,		//4
	CHANNEL_WAIT_RECALL		//5
};
void ChannelProcessing(uint8_t chNumber){
	switch(Channels[chNumber].Alarm_State){
    a36c:	85 30       	cpi	r24, 0x05	; 5
    a36e:	81 f6       	brne	.-96     	; 0xa310 <ChannelProcessing+0x6e>
    a370:	b7 cf       	rjmp	.-146    	; 0xa2e0 <ChannelProcessing+0x3e>
			if(Timer16Stopp(Channels[chNumber].timer)){
				Channels[chNumber].Alarm_State = CHANNEL_CALLING;
			}
			break;
		case CHANNEL_CALLING:
			if(0 == CallerBusyState){
    a372:	80 91 c4 07 	lds	r24, 0x07C4
    a376:	88 23       	and	r24, r24
    a378:	59 f6       	brne	.-106    	; 0xa310 <ChannelProcessing+0x6e>
				Caller_StartCalling(Channels[chNumber].number);
    a37a:	8e 01       	movw	r16, r28
    a37c:	00 0f       	add	r16, r16
    a37e:	11 1f       	adc	r17, r17
    a380:	00 0f       	add	r16, r16
    a382:	11 1f       	adc	r17, r17
    a384:	0a 54       	subi	r16, 0x4A	; 74
    a386:	19 4f       	sbci	r17, 0xF9	; 249
    a388:	f8 01       	movw	r30, r16
    a38a:	90 81       	ld	r25, Z
uint8_t CallerBusyState;
uint8_t CallerMessage[2];
uint8_t CurrentAbonent;
uint8_t CurrentCall;
void Caller_StartCalling(uint8_t inputN){
	CallerMessage[0]=1;
    a38c:	81 e0       	ldi	r24, 0x01	; 1
    a38e:	80 93 b6 07 	sts	0x07B6, r24
	CallerMessage[1]=inputN;
    a392:	90 93 b7 07 	sts	0x07B7, r25
	CallerBusyState = 1;
    a396:	80 93 c4 07 	sts	0x07C4, r24
			}
			break;
		case CHANNEL_CALLING:
			if(0 == CallerBusyState){
				Caller_StartCalling(Channels[chNumber].number);
				Channels[chNumber].Alarm_State = CHANNEL_WAIT_RECALL;
    a39a:	85 e0       	ldi	r24, 0x05	; 5
    a39c:	f7 01       	movw	r30, r14
    a39e:	80 83       	st	Z, r24
    a3a0:	c9 01       	movw	r24, r18
    a3a2:	8f 58       	subi	r24, 0x8F	; 143
    a3a4:	9e 4f       	sbci	r25, 0xFE	; 254
    a3a6:	0e 94 5e 87 	call	0x10ebc	; 0x10ebc <__eerd_word_m2560>
				StartTimer16(Channels[chNumber].timer, erw(&calling_retry_delay[chNumber])*100);
    a3aa:	24 e6       	ldi	r18, 0x64	; 100
    a3ac:	30 e0       	ldi	r19, 0x00	; 0
    a3ae:	82 9f       	mul	r24, r18
    a3b0:	b0 01       	movw	r22, r0
    a3b2:	83 9f       	mul	r24, r19
    a3b4:	70 0d       	add	r23, r0
    a3b6:	92 9f       	mul	r25, r18
    a3b8:	70 0d       	add	r23, r0
    a3ba:	11 24       	eor	r1, r1
    a3bc:	f8 01       	movw	r30, r16
    a3be:	83 81       	ldd	r24, Z+3	; 0x03
    a3c0:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
    a3c4:	a5 cf       	rjmp	.-182    	; 0xa310 <ChannelProcessing+0x6e>
			if(Timer16Stopp(Channels[chNumber].timer)){
				Channels[chNumber].Alarm_State = CHANNEL_WRITE_LOG;
			}
			break;
		case CHANNEL_WRITE_LOG:
				Channels[chNumber].Alarm_State = CHANNEL_WAIT_CALL;
    a3c6:	83 e0       	ldi	r24, 0x03	; 3
    a3c8:	f7 01       	movw	r30, r14
    a3ca:	80 83       	st	Z, r24
    a3cc:	c9 01       	movw	r24, r18
    a3ce:	8f 5a       	subi	r24, 0xAF	; 175
    a3d0:	9e 4f       	sbci	r25, 0xFE	; 254
    a3d2:	0e 94 5e 87 	call	0x10ebc	; 0x10ebc <__eerd_word_m2560>
				StartTimer16(Channels[chNumber].timer, erw(&calling_delay[chNumber])*100);
    a3d6:	cc 0f       	add	r28, r28
    a3d8:	dd 1f       	adc	r29, r29
    a3da:	cc 0f       	add	r28, r28
    a3dc:	dd 1f       	adc	r29, r29
    a3de:	ca 54       	subi	r28, 0x4A	; 74
    a3e0:	d9 4f       	sbci	r29, 0xF9	; 249
    a3e2:	24 e6       	ldi	r18, 0x64	; 100
    a3e4:	30 e0       	ldi	r19, 0x00	; 0
    a3e6:	82 9f       	mul	r24, r18
    a3e8:	b0 01       	movw	r22, r0
    a3ea:	83 9f       	mul	r24, r19
    a3ec:	70 0d       	add	r23, r0
    a3ee:	92 9f       	mul	r25, r18
    a3f0:	70 0d       	add	r23, r0
    a3f2:	11 24       	eor	r1, r1
    a3f4:	8b 81       	ldd	r24, Y+3	; 0x03
    a3f6:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
			}			
			break;

	}

}
    a3fa:	df 91       	pop	r29
    a3fc:	cf 91       	pop	r28
    a3fe:	1f 91       	pop	r17
    a400:	0f 91       	pop	r16
    a402:	ff 90       	pop	r15
    a404:	ef 90       	pop	r14
    a406:	08 95       	ret
				StartTimer16(Channels[chNumber].timer, erw(&debounceTimeout[chNumber])*100);
				break;
			}
			break;
		case CHANNEL_WAIT_DEBOUNCE:
			if(1 == Channels[chNumber].DI_State)
    a408:	fe 01       	movw	r30, r28
    a40a:	ee 0f       	add	r30, r30
    a40c:	ff 1f       	adc	r31, r31
    a40e:	ee 0f       	add	r30, r30
    a410:	ff 1f       	adc	r31, r31
    a412:	ea 54       	subi	r30, 0x4A	; 74
    a414:	f9 4f       	sbci	r31, 0xF9	; 249
    a416:	81 81       	ldd	r24, Z+1	; 0x01
    a418:	81 30       	cpi	r24, 0x01	; 1
    a41a:	09 f4       	brne	.+2      	; 0xa41e <ChannelProcessing+0x17c>
    a41c:	9e cf       	rjmp	.-196    	; 0xa35a <ChannelProcessing+0xb8>
			{
				Channels[chNumber].Alarm_State = CHANNEL_PINSCAN;
				break;				
			} 
			if(Timer16Stopp(Channels[chNumber].timer)){
    a41e:	83 81       	ldd	r24, Z+3	; 0x03
    a420:	0e 94 84 1f 	call	0x3f08	; 0x3f08 <Timer16Stopp>
    a424:	88 23       	and	r24, r24
    a426:	09 f4       	brne	.+2      	; 0xa42a <ChannelProcessing+0x188>
    a428:	73 cf       	rjmp	.-282    	; 0xa310 <ChannelProcessing+0x6e>
				Channels[chNumber].Alarm_State = CHANNEL_WRITE_LOG;
    a42a:	82 e0       	ldi	r24, 0x02	; 2
    a42c:	f7 01       	movw	r30, r14
    a42e:	80 83       	st	Z, r24
    a430:	6f cf       	rjmp	.-290    	; 0xa310 <ChannelProcessing+0x6e>

0000a432 <ApplCycle>:
}

// ~~~~~~~~~~~~
void
ApplCycle(void)
{
    a432:	1f 93       	push	r17
    a434:	cf 93       	push	r28
    a436:	df 93       	push	r29
    a438:	c7 eb       	ldi	r28, 0xB7	; 183
    a43a:	d6 e0       	ldi	r29, 0x06	; 6
    a43c:	10 e0       	ldi	r17, 0x00	; 0
	for(uint8_t i=0; i<16; i++){
			Channels[i].DI_State = DI_State(i);
    a43e:	81 2f       	mov	r24, r17
    a440:	0e 94 14 41 	call	0x8228	; 0x8228 <DI_State>
    a444:	88 83       	st	Y, r24
			ChannelProcessing(i);
    a446:	81 2f       	mov	r24, r17
    a448:	0e 94 51 51 	call	0xa2a2	; 0xa2a2 <ChannelProcessing>

// ~~~~~~~~~~~~
void
ApplCycle(void)
{
	for(uint8_t i=0; i<16; i++){
    a44c:	1f 5f       	subi	r17, 0xFF	; 255
    a44e:	24 96       	adiw	r28, 0x04	; 4
    a450:	10 31       	cpi	r17, 0x10	; 16
    a452:	a9 f7       	brne	.-22     	; 0xa43e <ApplCycle+0xc>
			Channels[i].DI_State = DI_State(i);
			ChannelProcessing(i);
	}
	CallerCycle();
    a454:	0e 94 93 43 	call	0x8726	; 0x8726 <CallerCycle>
}
    a458:	df 91       	pop	r29
    a45a:	cf 91       	pop	r28
    a45c:	1f 91       	pop	r17
    a45e:	08 95       	ret

0000a460 <EE_InterBrokLine>:
	uint8_t WiAbsc, uint16_t (*TblAbsc)[WiAbsc], uint8_t Absc,
	uint8_t WiOrdi, uint16_t (*TblOrdi)[WiOrdi], uint8_t Ordi,
	uint8_t Len,
	int16_t x
)
{
    a460:	2f 92       	push	r2
    a462:	3f 92       	push	r3
    a464:	4f 92       	push	r4
    a466:	5f 92       	push	r5
    a468:	6f 92       	push	r6
    a46a:	7f 92       	push	r7
    a46c:	8f 92       	push	r8
    a46e:	9f 92       	push	r9
    a470:	af 92       	push	r10
    a472:	bf 92       	push	r11
    a474:	cf 92       	push	r12
    a476:	df 92       	push	r13
    a478:	ef 92       	push	r14
    a47a:	ff 92       	push	r15
    a47c:	0f 93       	push	r16
    a47e:	1f 93       	push	r17
    a480:	df 93       	push	r29
    a482:	cf 93       	push	r28
    a484:	cd b7       	in	r28, 0x3d	; 61
    a486:	de b7       	in	r29, 0x3e	; 62
    a488:	2e 97       	sbiw	r28, 0x0e	; 14
    a48a:	0f b6       	in	r0, 0x3f	; 63
    a48c:	f8 94       	cli
    a48e:	de bf       	out	0x3e, r29	; 62
    a490:	0f be       	out	0x3f, r0	; 63
    a492:	cd bf       	out	0x3d, r28	; 61
    a494:	f8 2e       	mov	r15, r24
    a496:	2b 01       	movw	r4, r22
    a498:	2d 87       	std	Y+13, r18	; 0x0d
    a49a:	18 01       	movw	r2, r16
    a49c:	ee 86       	std	Y+14, r14	; 0x0e
    a49e:	0c 2d       	mov	r16, r12
	LineGraph Segm;
	uint8_t i = 0;
	Segm.x2 = (int16_t)erw(TblAbsc[0]+Absc);
    a4a0:	c4 2e       	mov	r12, r20
    a4a2:	dd 24       	eor	r13, r13
    a4a4:	c6 01       	movw	r24, r12
    a4a6:	88 0f       	add	r24, r24
    a4a8:	99 1f       	adc	r25, r25
    a4aa:	86 0f       	add	r24, r22
    a4ac:	97 1f       	adc	r25, r23
    a4ae:	0e 94 5e 87 	call	0x10ebc	; 0x10ebc <__eerd_word_m2560>
    a4b2:	aa 27       	eor	r26, r26
    a4b4:	97 fd       	sbrc	r25, 7
    a4b6:	a0 95       	com	r26
    a4b8:	ba 2f       	mov	r27, r26
    a4ba:	8d 83       	std	Y+5, r24	; 0x05
    a4bc:	9e 83       	std	Y+6, r25	; 0x06
    a4be:	af 83       	std	Y+7, r26	; 0x07
    a4c0:	b8 87       	std	Y+8, r27	; 0x08
    a4c2:	ef 2c       	mov	r14, r15
    a4c4:	ff 24       	eor	r15, r15
    a4c6:	35 01       	movw	r6, r10
    a4c8:	88 24       	eor	r8, r8
    a4ca:	77 fc       	sbrc	r7, 7
    a4cc:	80 94       	com	r8
    a4ce:	98 2c       	mov	r9, r8
    a4d0:	10 e0       	ldi	r17, 0x00	; 0
    a4d2:	9c 01       	movw	r18, r24
    a4d4:	ad 01       	movw	r20, r26
	do {
		Segm.x1 = Segm.x2;
    a4d6:	29 83       	std	Y+1, r18	; 0x01
    a4d8:	3a 83       	std	Y+2, r19	; 0x02
    a4da:	4b 83       	std	Y+3, r20	; 0x03
    a4dc:	5c 83       	std	Y+4, r21	; 0x04
		Segm.x2 = (int16_t)erw(TblAbsc[++i]+Absc);
    a4de:	1f 5f       	subi	r17, 0xFF	; 255
    a4e0:	a1 2e       	mov	r10, r17
    a4e2:	bb 24       	eor	r11, r11
    a4e4:	ae 9c       	mul	r10, r14
    a4e6:	c0 01       	movw	r24, r0
    a4e8:	af 9c       	mul	r10, r15
    a4ea:	90 0d       	add	r25, r0
    a4ec:	be 9c       	mul	r11, r14
    a4ee:	90 0d       	add	r25, r0
    a4f0:	11 24       	eor	r1, r1
    a4f2:	8c 0d       	add	r24, r12
    a4f4:	9d 1d       	adc	r25, r13
    a4f6:	88 0f       	add	r24, r24
    a4f8:	99 1f       	adc	r25, r25
    a4fa:	84 0d       	add	r24, r4
    a4fc:	95 1d       	adc	r25, r5
    a4fe:	0e 94 5e 87 	call	0x10ebc	; 0x10ebc <__eerd_word_m2560>
    a502:	9c 01       	movw	r18, r24
    a504:	44 27       	eor	r20, r20
    a506:	37 fd       	sbrc	r19, 7
    a508:	40 95       	com	r20
    a50a:	54 2f       	mov	r21, r20
    a50c:	2d 83       	std	Y+5, r18	; 0x05
    a50e:	3e 83       	std	Y+6, r19	; 0x06
    a510:	4f 83       	std	Y+7, r20	; 0x07
    a512:	58 87       	std	Y+8, r21	; 0x08
	} while(x>Segm.x2 && i<Len);
    a514:	26 15       	cp	r18, r6
    a516:	37 05       	cpc	r19, r7
    a518:	48 05       	cpc	r20, r8
    a51a:	59 05       	cpc	r21, r9
    a51c:	14 f4       	brge	.+4      	; 0xa522 <EE_InterBrokLine+0xc2>
    a51e:	10 17       	cp	r17, r16
    a520:	d0 f2       	brcs	.-76     	; 0xa4d6 <EE_InterBrokLine+0x76>
	Segm.y1 = (int16_t)erw(TblOrdi[i-1]+Ordi);
    a522:	8d 85       	ldd	r24, Y+13	; 0x0d
    a524:	08 2f       	mov	r16, r24
    a526:	10 e0       	ldi	r17, 0x00	; 0
    a528:	8e 85       	ldd	r24, Y+14	; 0x0e
    a52a:	e8 2e       	mov	r14, r24
    a52c:	ff 24       	eor	r15, r15
    a52e:	08 94       	sec
    a530:	a1 08       	sbc	r10, r1
    a532:	b1 08       	sbc	r11, r1
    a534:	a0 9e       	mul	r10, r16
    a536:	c0 01       	movw	r24, r0
    a538:	a1 9e       	mul	r10, r17
    a53a:	90 0d       	add	r25, r0
    a53c:	b0 9e       	mul	r11, r16
    a53e:	90 0d       	add	r25, r0
    a540:	11 24       	eor	r1, r1
    a542:	08 94       	sec
    a544:	a1 1c       	adc	r10, r1
    a546:	b1 1c       	adc	r11, r1
    a548:	8e 0d       	add	r24, r14
    a54a:	9f 1d       	adc	r25, r15
    a54c:	88 0f       	add	r24, r24
    a54e:	99 1f       	adc	r25, r25
    a550:	82 0d       	add	r24, r2
    a552:	93 1d       	adc	r25, r3
    a554:	0e 94 5e 87 	call	0x10ebc	; 0x10ebc <__eerd_word_m2560>
    a558:	9a 87       	std	Y+10, r25	; 0x0a
    a55a:	89 87       	std	Y+9, r24	; 0x09
    a55c:	a0 9e       	mul	r10, r16
    a55e:	c0 01       	movw	r24, r0
    a560:	a1 9e       	mul	r10, r17
    a562:	90 0d       	add	r25, r0
    a564:	b0 9e       	mul	r11, r16
    a566:	90 0d       	add	r25, r0
    a568:	11 24       	eor	r1, r1
    a56a:	8e 0d       	add	r24, r14
    a56c:	9f 1d       	adc	r25, r15
    a56e:	88 0f       	add	r24, r24
    a570:	99 1f       	adc	r25, r25
    a572:	82 0d       	add	r24, r2
    a574:	93 1d       	adc	r25, r3
    a576:	0e 94 5e 87 	call	0x10ebc	; 0x10ebc <__eerd_word_m2560>
	Segm.y2 = (int16_t)erw(TblOrdi[i]+Ordi);
    a57a:	9c 87       	std	Y+12, r25	; 0x0c
    a57c:	8b 87       	std	Y+11, r24	; 0x0b
	return LineFunc(&Segm, x);
    a57e:	ce 01       	movw	r24, r28
    a580:	01 96       	adiw	r24, 0x01	; 1
    a582:	b4 01       	movw	r22, r8
    a584:	a3 01       	movw	r20, r6
    a586:	0e 94 73 24 	call	0x48e6	; 0x48e6 <LineFunc>
}
    a58a:	2e 96       	adiw	r28, 0x0e	; 14
    a58c:	0f b6       	in	r0, 0x3f	; 63
    a58e:	f8 94       	cli
    a590:	de bf       	out	0x3e, r29	; 62
    a592:	0f be       	out	0x3f, r0	; 63
    a594:	cd bf       	out	0x3d, r28	; 61
    a596:	cf 91       	pop	r28
    a598:	df 91       	pop	r29
    a59a:	1f 91       	pop	r17
    a59c:	0f 91       	pop	r16
    a59e:	ff 90       	pop	r15
    a5a0:	ef 90       	pop	r14
    a5a2:	df 90       	pop	r13
    a5a4:	cf 90       	pop	r12
    a5a6:	bf 90       	pop	r11
    a5a8:	af 90       	pop	r10
    a5aa:	9f 90       	pop	r9
    a5ac:	8f 90       	pop	r8
    a5ae:	7f 90       	pop	r7
    a5b0:	6f 90       	pop	r6
    a5b2:	5f 90       	pop	r5
    a5b4:	4f 90       	pop	r4
    a5b6:	3f 90       	pop	r3
    a5b8:	2f 90       	pop	r2
    a5ba:	08 95       	ret

0000a5bc <MemCheck>:
}

// ~~~~~~~~~~~
uint8_t
MemCheck(void)
{
    a5bc:	0f 93       	push	r16
    a5be:	1f 93       	push	r17
//	uint8_t T = Timer32Stopp(TD_Mem);
//	if (T) {
//		StartTimer32(TD_Mem, 360000);
		if (!(MemFail &(1<<MemFail_Flash)) && CRC_Flash_calc()!=erw(&MemCheck_stor.CRC_Flash_stor))
    a5c0:	80 91 17 09 	lds	r24, 0x0917
    a5c4:	80 ff       	sbrs	r24, 0
    a5c6:	17 c0       	rjmp	.+46     	; 0xa5f6 <MemCheck+0x3a>
			MemFail |=(1<<MemFail_Flash);
		if (!(MemFail &(1<<MemFail_EEPROM)) && CRC_EEPROM_calc()!=erw(&MemCheck_stor.CRC_EEPROM_stor))
    a5c8:	81 ff       	sbrs	r24, 1
    a5ca:	03 c0       	rjmp	.+6      	; 0xa5d2 <MemCheck+0x16>
			MemFail |=(1<<MemFail_EEPROM);
//	}
//	return T && MemFail;
	return MemFail;
}
    a5cc:	1f 91       	pop	r17
    a5ce:	0f 91       	pop	r16
    a5d0:	08 95       	ret
//	uint8_t T = Timer32Stopp(TD_Mem);
//	if (T) {
//		StartTimer32(TD_Mem, 360000);
		if (!(MemFail &(1<<MemFail_Flash)) && CRC_Flash_calc()!=erw(&MemCheck_stor.CRC_Flash_stor))
			MemFail |=(1<<MemFail_Flash);
		if (!(MemFail &(1<<MemFail_EEPROM)) && CRC_EEPROM_calc()!=erw(&MemCheck_stor.CRC_EEPROM_stor))
    a5d2:	0e 94 23 1d 	call	0x3a46	; 0x3a46 <CRC_EEPROM_calc>
    a5d6:	8c 01       	movw	r16, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    a5d8:	8a e9       	ldi	r24, 0x9A	; 154
    a5da:	91 e0       	ldi	r25, 0x01	; 1
    a5dc:	0e 94 5e 87 	call	0x10ebc	; 0x10ebc <__eerd_word_m2560>
//	uint8_t T = Timer32Stopp(TD_Mem);
//	if (T) {
//		StartTimer32(TD_Mem, 360000);
		if (!(MemFail &(1<<MemFail_Flash)) && CRC_Flash_calc()!=erw(&MemCheck_stor.CRC_Flash_stor))
			MemFail |=(1<<MemFail_Flash);
		if (!(MemFail &(1<<MemFail_EEPROM)) && CRC_EEPROM_calc()!=erw(&MemCheck_stor.CRC_EEPROM_stor))
    a5e0:	08 17       	cp	r16, r24
    a5e2:	19 07       	cpc	r17, r25
    a5e4:	d9 f0       	breq	.+54     	; 0xa61c <MemCheck+0x60>
			MemFail |=(1<<MemFail_EEPROM);
    a5e6:	80 91 17 09 	lds	r24, 0x0917
    a5ea:	82 60       	ori	r24, 0x02	; 2
    a5ec:	80 93 17 09 	sts	0x0917, r24
//	}
//	return T && MemFail;
	return MemFail;
}
    a5f0:	1f 91       	pop	r17
    a5f2:	0f 91       	pop	r16
    a5f4:	08 95       	ret
MemCheck(void)
{
//	uint8_t T = Timer32Stopp(TD_Mem);
//	if (T) {
//		StartTimer32(TD_Mem, 360000);
		if (!(MemFail &(1<<MemFail_Flash)) && CRC_Flash_calc()!=erw(&MemCheck_stor.CRC_Flash_stor))
    a5f6:	0e 94 09 1d 	call	0x3a12	; 0x3a12 <CRC_Flash_calc>
    a5fa:	8c 01       	movw	r16, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    a5fc:	88 e9       	ldi	r24, 0x98	; 152
    a5fe:	91 e0       	ldi	r25, 0x01	; 1
    a600:	0e 94 5e 87 	call	0x10ebc	; 0x10ebc <__eerd_word_m2560>
MemCheck(void)
{
//	uint8_t T = Timer32Stopp(TD_Mem);
//	if (T) {
//		StartTimer32(TD_Mem, 360000);
		if (!(MemFail &(1<<MemFail_Flash)) && CRC_Flash_calc()!=erw(&MemCheck_stor.CRC_Flash_stor))
    a604:	08 17       	cp	r16, r24
    a606:	19 07       	cpc	r17, r25
    a608:	31 f0       	breq	.+12     	; 0xa616 <MemCheck+0x5a>
			MemFail |=(1<<MemFail_Flash);
    a60a:	80 91 17 09 	lds	r24, 0x0917
    a60e:	81 60       	ori	r24, 0x01	; 1
    a610:	80 93 17 09 	sts	0x0917, r24
    a614:	d9 cf       	rjmp	.-78     	; 0xa5c8 <MemCheck+0xc>
    a616:	80 91 17 09 	lds	r24, 0x0917
    a61a:	d6 cf       	rjmp	.-84     	; 0xa5c8 <MemCheck+0xc>
    a61c:	80 91 17 09 	lds	r24, 0x0917
    a620:	d5 cf       	rjmp	.-86     	; 0xa5cc <MemCheck+0x10>

0000a622 <MemCheckMsg>:

// ~~~~~~~~~~~~~~
void
MemCheckMsg(void)
{
	if(MemCheck())
    a622:	0e 94 de 52 	call	0xa5bc	; 0xa5bc <MemCheck>
    a626:	88 23       	and	r24, r24
    a628:	09 f4       	brne	.+2      	; 0xa62c <MemCheckMsg+0xa>
    a62a:	08 95       	ret

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    a62c:	80 91 17 09 	lds	r24, 0x0917
    a630:	e8 2f       	mov	r30, r24
    a632:	f0 e0       	ldi	r31, 0x00	; 0
    a634:	ee 0f       	add	r30, r30
    a636:	ff 1f       	adc	r31, r31
    a638:	e9 5a       	subi	r30, 0xA9	; 169
    a63a:	f8 4e       	sbci	r31, 0xE8	; 232
		ShowMsg(prp(MsgErrMemo+MemFail));
    a63c:	85 91       	lpm	r24, Z+
    a63e:	94 91       	lpm	r25, Z+
    a640:	0e 94 24 40 	call	0x8048	; 0x8048 <ShowMsg>
    a644:	08 95       	ret

0000a646 <erb>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    a646:	0e 94 50 87 	call	0x10ea0	; 0x10ea0 <__eerd_byte_m2560>
	//IntOn();
	return byte;
}
    a64a:	08 95       	ret

0000a64c <ThermChanWrong>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
ThermChanWrong(uint8_t ChanN)
{
    a64c:	ff 92       	push	r15
    a64e:	0f 93       	push	r16
    a650:	1f 93       	push	r17
	return ThermWrong(prb(ThermFami+ChanN), erb(ThermType+ChanN), Temperature[ChanN]);
    a652:	08 2f       	mov	r16, r24
    a654:	10 e0       	ldi	r17, 0x00	; 0

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    a656:	f8 01       	movw	r30, r16
    a658:	e3 54       	subi	r30, 0x43	; 67
    a65a:	f9 4f       	sbci	r31, 0xF9	; 249
    a65c:	f4 90       	lpm	r15, Z+
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    a65e:	c8 01       	movw	r24, r16
    a660:	89 5e       	subi	r24, 0xE9	; 233
    a662:	9e 4f       	sbci	r25, 0xFE	; 254
    a664:	0e 94 50 87 	call	0x10ea0	; 0x10ea0 <__eerd_byte_m2560>
    a668:	68 2f       	mov	r22, r24
    a66a:	00 0f       	add	r16, r16
    a66c:	11 1f       	adc	r17, r17
    a66e:	0b 5b       	subi	r16, 0xBB	; 187
    a670:	19 4f       	sbci	r17, 0xF9	; 249
    a672:	f8 01       	movw	r30, r16
    a674:	40 81       	ld	r20, Z
    a676:	51 81       	ldd	r21, Z+1	; 0x01
    a678:	8f 2d       	mov	r24, r15
    a67a:	0e 94 44 43 	call	0x8688	; 0x8688 <ThermWrong>
}
    a67e:	1f 91       	pop	r17
    a680:	0f 91       	pop	r16
    a682:	ff 90       	pop	r15
    a684:	08 95       	ret

0000a686 <ThermChan>:
}

// ~~~~~~~~~~~~~~~~~~~~~
void
ThermChan(uint8_t ChanN)
{
    a686:	8f 92       	push	r8
    a688:	9f 92       	push	r9
    a68a:	af 92       	push	r10
    a68c:	bf 92       	push	r11
    a68e:	cf 92       	push	r12
    a690:	df 92       	push	r13
    a692:	ef 92       	push	r14
    a694:	ff 92       	push	r15
    a696:	0f 93       	push	r16
    a698:	1f 93       	push	r17
    a69a:	cf 93       	push	r28
    a69c:	df 93       	push	r29
	if (ChanN>=TerReg)
    a69e:	86 30       	cpi	r24, 0x06	; 6
    a6a0:	08 f0       	brcs	.+2      	; 0xa6a4 <ThermChan+0x1e>
    a6a2:	4c c0       	rjmp	.+152    	; 0xa73c <ThermChan+0xb6>
		return;
    a6a4:	e8 2e       	mov	r14, r24
    a6a6:	ff 24       	eor	r15, r15
    a6a8:	d7 01       	movw	r26, r14
    a6aa:	aa 0f       	add	r26, r26
    a6ac:	bb 1f       	adc	r27, r27
    a6ae:	a2 95       	swap	r26
    a6b0:	b2 95       	swap	r27
    a6b2:	b0 7f       	andi	r27, 0xF0	; 240
    a6b4:	ba 27       	eor	r27, r26
    a6b6:	a0 7f       	andi	r26, 0xF0	; 240
    a6b8:	ba 27       	eor	r27, r26
    a6ba:	fd 01       	movw	r30, r26
    a6bc:	e3 5e       	subi	r30, 0xE3	; 227
    a6be:	fa 4f       	sbci	r31, 0xFA	; 250
    a6c0:	2f e0       	ldi	r18, 0x0F	; 15
	for (uint8_t i=TerFiltLev*4-1; i; i--)
		TerBuf[ChanN][i] = TerBuf[ChanN][i-1];
    a6c2:	80 81       	ld	r24, Z
    a6c4:	91 81       	ldd	r25, Z+1	; 0x01
    a6c6:	93 83       	std	Z+3, r25	; 0x03
    a6c8:	82 83       	std	Z+2, r24	; 0x02
void
ThermChan(uint8_t ChanN)
{
	if (ChanN>=TerReg)
		return;
	for (uint8_t i=TerFiltLev*4-1; i; i--)
    a6ca:	21 50       	subi	r18, 0x01	; 1
    a6cc:	32 97       	sbiw	r30, 0x02	; 2
    a6ce:	22 23       	and	r18, r18
    a6d0:	c1 f7       	brne	.-16     	; 0xa6c2 <ThermChan+0x3c>
		TerBuf[ChanN][i] = TerBuf[ChanN][i-1];
	TerBuf[ChanN][0] = TerInput[ChanN];
    a6d2:	af 5f       	subi	r26, 0xFF	; 255
    a6d4:	ba 4f       	sbci	r27, 0xFA	; 250
    a6d6:	47 01       	movw	r8, r14
    a6d8:	88 0c       	add	r8, r8
    a6da:	99 1c       	adc	r9, r9
    a6dc:	f4 01       	movw	r30, r8
    a6de:	e5 5e       	subi	r30, 0xE5	; 229
    a6e0:	f6 4f       	sbci	r31, 0xF6	; 246
    a6e2:	80 81       	ld	r24, Z
    a6e4:	91 81       	ldd	r25, Z+1	; 0x01
    a6e6:	8d 93       	st	X+, r24
    a6e8:	9c 93       	st	X, r25

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    a6ea:	f7 01       	movw	r30, r14
    a6ec:	e3 54       	subi	r30, 0x43	; 67
    a6ee:	f9 4f       	sbci	r31, 0xF9	; 249
    a6f0:	c4 90       	lpm	r12, Z+
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    a6f2:	c7 01       	movw	r24, r14
    a6f4:	89 5e       	subi	r24, 0xE9	; 233
    a6f6:	9e 4f       	sbci	r25, 0xFE	; 254
    a6f8:	0e 94 50 87 	call	0x10ea0	; 0x10ea0 <__eerd_byte_m2560>
    a6fc:	18 2f       	mov	r17, r24
	int16_t Ter = Thermode(prb(ThermFami+ChanN), erb(ThermType+ChanN), DigiFilt(TerBuf[ChanN],TerFiltLev));
    a6fe:	c7 01       	movw	r24, r14
    a700:	88 0f       	add	r24, r24
    a702:	99 1f       	adc	r25, r25
    a704:	82 95       	swap	r24
    a706:	92 95       	swap	r25
    a708:	90 7f       	andi	r25, 0xF0	; 240
    a70a:	98 27       	eor	r25, r24
    a70c:	80 7f       	andi	r24, 0xF0	; 240
    a70e:	98 27       	eor	r25, r24
    a710:	8f 5f       	subi	r24, 0xFF	; 255
    a712:	9a 4f       	sbci	r25, 0xFA	; 250
    a714:	64 e0       	ldi	r22, 0x04	; 4
    a716:	0e 94 f0 4e 	call	0x9de0	; 0x9de0 <DigiFilt>
    a71a:	ac 01       	movw	r20, r24
    a71c:	8c 2d       	mov	r24, r12
    a71e:	61 2f       	mov	r22, r17
    a720:	0e 94 c4 42 	call	0x8588	; 0x8588 <Thermode>
    a724:	ec 01       	movw	r28, r24
	if (Ter!=Therm_Off_Mark)
    a726:	80 e8       	ldi	r24, 0x80	; 128
    a728:	c0 30       	cpi	r28, 0x00	; 0
    a72a:	d8 07       	cpc	r29, r24
    a72c:	a1 f4       	brne	.+40     	; 0xa756 <ThermChan+0xd0>
		Ter = (Ter+(int8_t)erb(&ThermCorr[ChanN].D))*(erw(&ThermCorr[ChanN].A)/1000.0);
	Temperature[ChanN] = Ter;
    a72e:	e5 e4       	ldi	r30, 0x45	; 69
    a730:	f6 e0       	ldi	r31, 0x06	; 6
    a732:	8e 0e       	add	r8, r30
    a734:	9f 1e       	adc	r9, r31
    a736:	f4 01       	movw	r30, r8
    a738:	d1 83       	std	Z+1, r29	; 0x01
    a73a:	c0 83       	st	Z, r28
}
    a73c:	df 91       	pop	r29
    a73e:	cf 91       	pop	r28
    a740:	1f 91       	pop	r17
    a742:	0f 91       	pop	r16
    a744:	ff 90       	pop	r15
    a746:	ef 90       	pop	r14
    a748:	df 90       	pop	r13
    a74a:	cf 90       	pop	r12
    a74c:	bf 90       	pop	r11
    a74e:	af 90       	pop	r10
    a750:	9f 90       	pop	r9
    a752:	8f 90       	pop	r8
    a754:	08 95       	ret
    a756:	64 01       	movw	r12, r8
    a758:	ce 0c       	add	r12, r14
    a75a:	df 1c       	adc	r13, r15
    a75c:	c6 01       	movw	r24, r12
    a75e:	83 5e       	subi	r24, 0xE3	; 227
    a760:	9e 4f       	sbci	r25, 0xFE	; 254
    a762:	0e 94 50 87 	call	0x10ea0	; 0x10ea0 <__eerd_byte_m2560>
    a766:	e8 2e       	mov	r14, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    a768:	c6 01       	movw	r24, r12
    a76a:	82 5e       	subi	r24, 0xE2	; 226
    a76c:	9e 4f       	sbci	r25, 0xFE	; 254
    a76e:	0e 94 5e 87 	call	0x10ebc	; 0x10ebc <__eerd_word_m2560>
    a772:	5c 01       	movw	r10, r24
	for (uint8_t i=TerFiltLev*4-1; i; i--)
		TerBuf[ChanN][i] = TerBuf[ChanN][i-1];
	TerBuf[ChanN][0] = TerInput[ChanN];
	int16_t Ter = Thermode(prb(ThermFami+ChanN), erb(ThermType+ChanN), DigiFilt(TerBuf[ChanN],TerFiltLev));
	if (Ter!=Therm_Off_Mark)
		Ter = (Ter+(int8_t)erb(&ThermCorr[ChanN].D))*(erw(&ThermCorr[ChanN].A)/1000.0);
    a774:	ff 24       	eor	r15, r15
    a776:	e7 fc       	sbrc	r14, 7
    a778:	f0 94       	com	r15
    a77a:	ec 0e       	add	r14, r28
    a77c:	fd 1e       	adc	r15, r29
    a77e:	00 27       	eor	r16, r16
    a780:	f7 fc       	sbrc	r15, 7
    a782:	00 95       	com	r16
    a784:	10 2f       	mov	r17, r16
    a786:	c8 01       	movw	r24, r16
    a788:	b7 01       	movw	r22, r14
    a78a:	0e 94 41 82 	call	0x10482	; 0x10482 <__floatsisf>
    a78e:	7b 01       	movw	r14, r22
    a790:	8c 01       	movw	r16, r24
    a792:	cc 24       	eor	r12, r12
    a794:	dd 24       	eor	r13, r13
    a796:	c6 01       	movw	r24, r12
    a798:	b5 01       	movw	r22, r10
    a79a:	0e 94 3f 82 	call	0x1047e	; 0x1047e <__floatunsisf>
    a79e:	20 e0       	ldi	r18, 0x00	; 0
    a7a0:	30 e0       	ldi	r19, 0x00	; 0
    a7a2:	4a e7       	ldi	r20, 0x7A	; 122
    a7a4:	54 e4       	ldi	r21, 0x44	; 68
    a7a6:	0e 94 a7 86 	call	0x10d4e	; 0x10d4e <__divsf3>
    a7aa:	9b 01       	movw	r18, r22
    a7ac:	ac 01       	movw	r20, r24
    a7ae:	c8 01       	movw	r24, r16
    a7b0:	b7 01       	movw	r22, r14
    a7b2:	0e 94 7c 82 	call	0x104f8	; 0x104f8 <__mulsf3>
    a7b6:	0e 94 0f 87 	call	0x10e1e	; 0x10e1e <__fixsfsi>
    a7ba:	eb 01       	movw	r28, r22
    a7bc:	b8 cf       	rjmp	.-144    	; 0xa72e <ThermChan+0xa8>

0000a7be <ThermInit>:
}

// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
ThermInit(uint8_t ChanN)
{
    a7be:	ef 92       	push	r14
    a7c0:	ff 92       	push	r15
    a7c2:	0f 93       	push	r16
    a7c4:	1f 93       	push	r17
    a7c6:	cf 93       	push	r28
    a7c8:	df 93       	push	r29
    a7ca:	f8 2e       	mov	r15, r24
	if (ChanN<TerReg) {
    a7cc:	85 e0       	ldi	r24, 0x05	; 5
    a7ce:	8f 15       	cp	r24, r15
    a7d0:	68 f1       	brcs	.+90     	; 0xa82c <ThermInit+0x6e>
    a7d2:	8f 2d       	mov	r24, r15
    a7d4:	90 e0       	ldi	r25, 0x00	; 0
    a7d6:	8c 01       	movw	r16, r24
    a7d8:	00 0f       	add	r16, r16
    a7da:	11 1f       	adc	r17, r17
    a7dc:	f8 01       	movw	r30, r16
    a7de:	e5 5e       	subi	r30, 0xE5	; 229
    a7e0:	f6 4f       	sbci	r31, 0xF6	; 246
    a7e2:	c0 81       	ld	r28, Z
    a7e4:	d1 81       	ldd	r29, Z+1	; 0x01
    a7e6:	fc 01       	movw	r30, r24
    a7e8:	ee 0f       	add	r30, r30
    a7ea:	ff 1f       	adc	r31, r31
    a7ec:	e2 95       	swap	r30
    a7ee:	f2 95       	swap	r31
    a7f0:	f0 7f       	andi	r31, 0xF0	; 240
    a7f2:	fe 27       	eor	r31, r30
    a7f4:	e0 7f       	andi	r30, 0xF0	; 240
    a7f6:	fe 27       	eor	r31, r30
    a7f8:	ef 5f       	subi	r30, 0xFF	; 255
    a7fa:	fa 4f       	sbci	r31, 0xFA	; 250
    a7fc:	20 e0       	ldi	r18, 0x00	; 0
		for (uint8_t i=0; i<TerFiltLev*4; TerBuf[ChanN][i++]=TerInput[ChanN]);
    a7fe:	c1 93       	st	Z+, r28
    a800:	d1 93       	st	Z+, r29
    a802:	2f 5f       	subi	r18, 0xFF	; 255
    a804:	20 31       	cpi	r18, 0x10	; 16
    a806:	d9 f7       	brne	.-10     	; 0xa7fe <ThermInit+0x40>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    a808:	fc 01       	movw	r30, r24
    a80a:	e3 54       	subi	r30, 0x43	; 67
    a80c:	f9 4f       	sbci	r31, 0xF9	; 249
    a80e:	e4 90       	lpm	r14, Z+
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    a810:	89 5e       	subi	r24, 0xE9	; 233
    a812:	9e 4f       	sbci	r25, 0xFE	; 254
    a814:	0e 94 50 87 	call	0x10ea0	; 0x10ea0 <__eerd_byte_m2560>
    a818:	68 2f       	mov	r22, r24
		Temperature[ChanN] = Thermode(prb(ThermFami+ChanN), erb(ThermType+ChanN), TerInput[ChanN]);
    a81a:	8e 2d       	mov	r24, r14
    a81c:	ae 01       	movw	r20, r28
    a81e:	0e 94 c4 42 	call	0x8588	; 0x8588 <Thermode>
    a822:	0b 5b       	subi	r16, 0xBB	; 187
    a824:	19 4f       	sbci	r17, 0xF9	; 249
    a826:	f8 01       	movw	r30, r16
    a828:	91 83       	std	Z+1, r25	; 0x01
    a82a:	80 83       	st	Z, r24
    a82c:	80 e0       	ldi	r24, 0x00	; 0
    a82e:	f5 e0       	ldi	r31, 0x05	; 5
    a830:	ff 12       	cpse	r15, r31
    a832:	81 e0       	ldi	r24, 0x01	; 1
	}
	return ChanN!=TerReg-1;
}
    a834:	df 91       	pop	r29
    a836:	cf 91       	pop	r28
    a838:	1f 91       	pop	r17
    a83a:	0f 91       	pop	r16
    a83c:	ff 90       	pop	r15
    a83e:	ef 90       	pop	r14
    a840:	08 95       	ret

0000a842 <DigitIn>:
}

// ~~~~~~~~~~
void
DigitIn(void)
{
    a842:	cf 93       	push	r28
    a844:	df 93       	push	r29
	memcpy(DigInput.StateOld, DigInput.State, DI_Reg+DI_Reg_Ext);
    a846:	e3 e4       	ldi	r30, 0x43	; 67
    a848:	f7 e0       	ldi	r31, 0x07	; 7
    a84a:	df 01       	movw	r26, r30
    a84c:	13 97       	sbiw	r26, 0x03	; 3
    a84e:	83 e0       	ldi	r24, 0x03	; 3
    a850:	0d 90       	ld	r0, X+
    a852:	01 92       	st	Z+, r0
    a854:	81 50       	subi	r24, 0x01	; 1
    a856:	e1 f7       	brne	.-8      	; 0xa850 <DigitIn+0xe>
    a858:	84 e1       	ldi	r24, 0x14	; 20
    a85a:	91 e0       	ldi	r25, 0x01	; 1
    a85c:	0e 94 50 87 	call	0x10ea0	; 0x10ea0 <__eerd_byte_m2560>
	for (uint8_t i=0; i<DI_Reg; i++)
		DigInput.Status[i] = DigInput.State[i]^erb(DI_Invers+i);
    a860:	90 91 40 07 	lds	r25, 0x0740
    a864:	98 27       	eor	r25, r24
    a866:	90 93 46 07 	sts	0x0746, r25
    a86a:	85 e1       	ldi	r24, 0x15	; 21
    a86c:	91 e0       	ldi	r25, 0x01	; 1
    a86e:	0e 94 50 87 	call	0x10ea0	; 0x10ea0 <__eerd_byte_m2560>
    a872:	90 91 41 07 	lds	r25, 0x0741
    a876:	98 27       	eor	r25, r24
    a878:	90 93 47 07 	sts	0x0747, r25
    a87c:	86 e1       	ldi	r24, 0x16	; 22
    a87e:	91 e0       	ldi	r25, 0x01	; 1
    a880:	0e 94 50 87 	call	0x10ea0	; 0x10ea0 <__eerd_byte_m2560>
    a884:	90 91 42 07 	lds	r25, 0x0742
    a888:	98 27       	eor	r25, r24
    a88a:	90 93 48 07 	sts	0x0748, r25
    a88e:	40 e0       	ldi	r20, 0x00	; 0
    a890:	50 e0       	ldi	r21, 0x00	; 0
#else
	static void
	DigitIn_Hard(void)
	{
		for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
			uint8_t Byte=D_N/8, Bit=1<<D_N%8;
    a892:	a1 e0       	ldi	r26, 0x01	; 1
    a894:	b0 e0       	ldi	r27, 0x00	; 0
    a896:	1b c0       	rjmp	.+54     	; 0xa8ce <DigitIn+0x8c>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    a898:	c9 01       	movw	r24, r18
    a89a:	82 59       	subi	r24, 0x92	; 146
    a89c:	9e 4c       	sbci	r25, 0xCE	; 206
    a89e:	fc 01       	movw	r30, r24
    a8a0:	c5 91       	lpm	r28, Z+
    a8a2:	d4 91       	lpm	r29, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    a8a4:	20 59       	subi	r18, 0x90	; 144
    a8a6:	3e 4c       	sbci	r19, 0xCE	; 206
    a8a8:	f9 01       	movw	r30, r18
    a8aa:	84 91       	lpm	r24, Z+
			if(prb(&DI_M[D_N].Inversion)){
				if (*(uint8_t*)prp(&DI_M[D_N].PIN) & prb(&DI_M[D_N].P))
    a8ac:	98 81       	ld	r25, Y
    a8ae:	89 23       	and	r24, r25
    a8b0:	09 f4       	brne	.+2      	; 0xa8b4 <DigitIn+0x72>
    a8b2:	3d c0       	rjmp	.+122    	; 0xa92e <DigitIn+0xec>
			}
			else{
				if (*(uint8_t*)prp(&DI_M[D_N].PIN) & prb(&DI_M[D_N].P))
					DigInput.State[Byte] &=~Bit;
				else
					DigInput.State[Byte]  |=Bit;
    a8b4:	e7 2f       	mov	r30, r23
    a8b6:	f0 e0       	ldi	r31, 0x00	; 0
    a8b8:	e0 5c       	subi	r30, 0xC0	; 192
    a8ba:	f8 4f       	sbci	r31, 0xF8	; 248
    a8bc:	80 81       	ld	r24, Z
    a8be:	86 2b       	or	r24, r22
    a8c0:	80 83       	st	Z, r24
    a8c2:	4f 5f       	subi	r20, 0xFF	; 255
    a8c4:	5f 4f       	sbci	r21, 0xFF	; 255
	void DigitIn_Hard(void);
#else
	static void
	DigitIn_Hard(void)
	{
		for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
    a8c6:	42 31       	cpi	r20, 0x12	; 18
    a8c8:	51 05       	cpc	r21, r1
    a8ca:	09 f4       	brne	.+2      	; 0xa8ce <DigitIn+0x8c>
    a8cc:	3e c0       	rjmp	.+124    	; 0xa94a <DigitIn+0x108>
			uint8_t Byte=D_N/8, Bit=1<<D_N%8;
    a8ce:	74 2f       	mov	r23, r20
    a8d0:	76 95       	lsr	r23
    a8d2:	76 95       	lsr	r23
    a8d4:	76 95       	lsr	r23
    a8d6:	ca 01       	movw	r24, r20
    a8d8:	87 70       	andi	r24, 0x07	; 7
    a8da:	90 70       	andi	r25, 0x00	; 0
    a8dc:	9d 01       	movw	r18, r26
    a8de:	02 c0       	rjmp	.+4      	; 0xa8e4 <DigitIn+0xa2>
    a8e0:	22 0f       	add	r18, r18
    a8e2:	33 1f       	adc	r19, r19
    a8e4:	8a 95       	dec	r24
    a8e6:	e2 f7       	brpl	.-8      	; 0xa8e0 <DigitIn+0x9e>
    a8e8:	62 2f       	mov	r22, r18
    a8ea:	9a 01       	movw	r18, r20
    a8ec:	22 0f       	add	r18, r18
    a8ee:	33 1f       	adc	r19, r19
    a8f0:	22 0f       	add	r18, r18
    a8f2:	33 1f       	adc	r19, r19
    a8f4:	22 0f       	add	r18, r18
    a8f6:	33 1f       	adc	r19, r19
    a8f8:	f9 01       	movw	r30, r18
    a8fa:	ef 58       	subi	r30, 0x8F	; 143
    a8fc:	fe 4c       	sbci	r31, 0xCE	; 206
    a8fe:	e4 91       	lpm	r30, Z+
			if(prb(&DI_M[D_N].Inversion)){
    a900:	ee 23       	and	r30, r30
    a902:	09 f0       	breq	.+2      	; 0xa906 <DigitIn+0xc4>
    a904:	c9 cf       	rjmp	.-110    	; 0xa898 <DigitIn+0x56>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    a906:	ca 01       	movw	r24, r20
    a908:	88 0f       	add	r24, r24
    a90a:	99 1f       	adc	r25, r25
    a90c:	88 0f       	add	r24, r24
    a90e:	99 1f       	adc	r25, r25
    a910:	88 0f       	add	r24, r24
    a912:	99 1f       	adc	r25, r25
    a914:	82 59       	subi	r24, 0x92	; 146
    a916:	9e 4c       	sbci	r25, 0xCE	; 206
    a918:	fc 01       	movw	r30, r24
    a91a:	c5 91       	lpm	r28, Z+
    a91c:	d4 91       	lpm	r29, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    a91e:	20 59       	subi	r18, 0x90	; 144
    a920:	3e 4c       	sbci	r19, 0xCE	; 206
    a922:	f9 01       	movw	r30, r18
    a924:	84 91       	lpm	r24, Z+
					DigInput.State[Byte] |=Bit;
				else
					DigInput.State[Byte] &=~Bit;
			}
			else{
				if (*(uint8_t*)prp(&DI_M[D_N].PIN) & prb(&DI_M[D_N].P))
    a926:	98 81       	ld	r25, Y
    a928:	89 23       	and	r24, r25
    a92a:	09 f4       	brne	.+2      	; 0xa92e <DigitIn+0xec>
    a92c:	c3 cf       	rjmp	.-122    	; 0xa8b4 <DigitIn+0x72>
					DigInput.State[Byte] &=~Bit;
    a92e:	e7 2f       	mov	r30, r23
    a930:	f0 e0       	ldi	r31, 0x00	; 0
    a932:	e0 5c       	subi	r30, 0xC0	; 192
    a934:	f8 4f       	sbci	r31, 0xF8	; 248
    a936:	60 95       	com	r22
    a938:	80 81       	ld	r24, Z
    a93a:	68 23       	and	r22, r24
    a93c:	60 83       	st	Z, r22
				else
					DigInput.State[Byte]  |=Bit;
    a93e:	4f 5f       	subi	r20, 0xFF	; 255
    a940:	5f 4f       	sbci	r21, 0xFF	; 255
	void DigitIn_Hard(void);
#else
	static void
	DigitIn_Hard(void)
	{
		for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
    a942:	42 31       	cpi	r20, 0x12	; 18
    a944:	51 05       	cpc	r21, r1
    a946:	09 f0       	breq	.+2      	; 0xa94a <DigitIn+0x108>
    a948:	c2 cf       	rjmp	.-124    	; 0xa8ce <DigitIn+0x8c>
			DigInput.State[j]		= (DigInput_Ext)[i];
			DigInput.Status[j]	= (DigInput_Ext)[i+DI_Reg_Ext];
			IntOn();
		}
	#endif
}
    a94a:	df 91       	pop	r29
    a94c:	cf 91       	pop	r28
    a94e:	08 95       	ret

0000a950 <Field2Buf>:
	else return 0;
}
// ~~~~~~~~~~~~~~~~~~~~~~~
static void
Field2Buf(OutField *Field)
{
    a950:	6f 92       	push	r6
    a952:	7f 92       	push	r7
    a954:	8f 92       	push	r8
    a956:	9f 92       	push	r9
    a958:	af 92       	push	r10
    a95a:	bf 92       	push	r11
    a95c:	cf 92       	push	r12
    a95e:	df 92       	push	r13
    a960:	ef 92       	push	r14
    a962:	ff 92       	push	r15
    a964:	0f 93       	push	r16
    a966:	1f 93       	push	r17
    a968:	df 93       	push	r29
    a96a:	cf 93       	push	r28
    a96c:	cd b7       	in	r28, 0x3d	; 61
    a96e:	de b7       	in	r29, 0x3e	; 62
    a970:	6f 97       	sbiw	r28, 0x1f	; 31
    a972:	0f b6       	in	r0, 0x3f	; 63
    a974:	f8 94       	cli
    a976:	de bf       	out	0x3e, r29	; 62
    a978:	0f be       	out	0x3f, r0	; 63
    a97a:	cd bf       	out	0x3d, r28	; 61
    a97c:	7c 01       	movw	r14, r24

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    a97e:	fc 01       	movw	r30, r24
    a980:	31 96       	adiw	r30, 0x01	; 1
    a982:	c5 90       	lpm	r12, Z+
    a984:	d4 90       	lpm	r13, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    a986:	bf e0       	ldi	r27, 0x0F	; 15
    a988:	8b 2e       	mov	r8, r27
    a98a:	91 2c       	mov	r9, r1
    a98c:	88 0e       	add	r8, r24
    a98e:	99 1e       	adc	r9, r25
    a990:	f4 01       	movw	r30, r8
    a992:	24 91       	lpm	r18, Z+
	void *Var = prp(&Field->Var);
	uint8_t BitN=prb(&Field->Prec), Mask=1<<BitN%8, *BitVar=(uint8_t*)Var+BitN/8;
    a994:	32 2f       	mov	r19, r18
    a996:	37 70       	andi	r19, 0x07	; 7
    a998:	81 e0       	ldi	r24, 0x01	; 1
    a99a:	90 e0       	ldi	r25, 0x00	; 0
    a99c:	18 2f       	mov	r17, r24
    a99e:	01 c0       	rjmp	.+2      	; 0xa9a2 <Field2Buf+0x52>
    a9a0:	11 0f       	add	r17, r17
    a9a2:	3a 95       	dec	r19
    a9a4:	ea f7       	brpl	.-6      	; 0xa9a0 <Field2Buf+0x50>
    a9a6:	26 95       	lsr	r18
    a9a8:	26 95       	lsr	r18
    a9aa:	26 95       	lsr	r18
    a9ac:	56 01       	movw	r10, r12
    a9ae:	a2 0e       	add	r10, r18
    a9b0:	b1 1c       	adc	r11, r1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    a9b2:	a7 e0       	ldi	r26, 0x07	; 7
    a9b4:	6a 2e       	mov	r6, r26
    a9b6:	71 2c       	mov	r7, r1
    a9b8:	6e 0c       	add	r6, r14
    a9ba:	7f 1c       	adc	r7, r15
    a9bc:	f3 01       	movw	r30, r6
    a9be:	65 91       	lpm	r22, Z+
    a9c0:	75 91       	lpm	r23, Z+
    a9c2:	85 91       	lpm	r24, Z+
    a9c4:	94 91       	lpm	r25, Z+
	uint8_t Pos=Log10(prd(&Field->Max));
    a9c6:	0e 94 36 24 	call	0x486c	; 0x486c <Log10>
    a9ca:	08 2f       	mov	r16, r24

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    a9cc:	f7 01       	movw	r30, r14
    a9ce:	84 91       	lpm	r24, Z+
	uint8_t Oldstyle = 0;

	switch(prb(&Field->Type)) {
    a9d0:	e8 2f       	mov	r30, r24
    a9d2:	f0 e0       	ldi	r31, 0x00	; 0
    a9d4:	e1 32       	cpi	r30, 0x21	; 33
    a9d6:	f1 05       	cpc	r31, r1
    a9d8:	08 f4       	brcc	.+2      	; 0xa9dc <Field2Buf+0x8c>
    a9da:	6e c0       	rjmp	.+220    	; 0xaab8 <Field2Buf+0x168>
		F_Buf = (erb(BitVar) &Mask) > 0;
		Oldstyle = 1;
		break;
	}

	Minus=0;
    a9dc:	10 92 ff 04 	sts	0x04FF, r1
	if(Oldstyle) return;

	InitBufStr(Field);
    a9e0:	c7 01       	movw	r24, r14
    a9e2:	0e 94 a2 3f 	call	0x7f44	; 0x7f44 <InitBufStr>
	CurrFieldSize = GetCurrFieldSize();
    a9e6:	0e 94 64 40 	call	0x80c8	; 0x80c8 <GetCurrFieldSize>
    a9ea:	48 2f       	mov	r20, r24
    a9ec:	80 93 c0 07 	sts	0x07C0, r24
	CurrPos = CurrFieldSize - 1;
    a9f0:	41 50       	subi	r20, 0x01	; 1
    a9f2:	40 93 d7 02 	sts	0x02D7, r20
    a9f6:	4f 5f       	subi	r20, 0xFF	; 255
	float fTemp;
	T_Param Param;
	Param.Size = CurrFieldSize;
    a9f8:	48 87       	std	Y+8, r20	; 0x08
	Param.Pos = BufStr;
    a9fa:	83 ec       	ldi	r24, 0xC3	; 195
    a9fc:	95 e0       	ldi	r25, 0x05	; 5
    a9fe:	9e 83       	std	Y+6, r25	; 0x06
    aa00:	8d 83       	std	Y+5, r24	; 0x05
    aa02:	f4 01       	movw	r30, r8
    aa04:	84 91       	lpm	r24, Z+
	Param.Prec = prb(&Field->Prec);
    aa06:	8f 83       	std	Y+7, r24	; 0x07
	Param.Txt = NULL;
    aa08:	1a 86       	std	Y+10, r1	; 0x0a
    aa0a:	19 86       	std	Y+9, r1	; 0x09
    aa0c:	f7 01       	movw	r30, r14
    aa0e:	84 91       	lpm	r24, Z+

	switch(prb(&Field->Type)) {
    aa10:	85 31       	cpi	r24, 0x15	; 21
    aa12:	09 f4       	brne	.+2      	; 0xaa16 <Field2Buf+0xc6>
    aa14:	74 c1       	rjmp	.+744    	; 0xacfe <Field2Buf+0x3ae>
    aa16:	86 31       	cpi	r24, 0x16	; 22
    aa18:	08 f4       	brcc	.+2      	; 0xaa1c <Field2Buf+0xcc>
    aa1a:	56 c1       	rjmp	.+684    	; 0xacc8 <Field2Buf+0x378>
    aa1c:	8b 31       	cpi	r24, 0x1B	; 27
    aa1e:	09 f4       	brne	.+2      	; 0xaa22 <Field2Buf+0xd2>
    aa20:	fe c1       	rjmp	.+1020   	; 0xae1e <Field2Buf+0x4ce>
    aa22:	8c 31       	cpi	r24, 0x1C	; 28
    aa24:	08 f0       	brcs	.+2      	; 0xaa28 <Field2Buf+0xd8>
    aa26:	b7 c1       	rjmp	.+878    	; 0xad96 <Field2Buf+0x446>
    aa28:	89 31       	cpi	r24, 0x19	; 25
    aa2a:	09 f4       	brne	.+2      	; 0xaa2e <Field2Buf+0xde>
    aa2c:	92 c1       	rjmp	.+804    	; 0xad52 <Field2Buf+0x402>
    aa2e:	8a 31       	cpi	r24, 0x1A	; 26
    aa30:	09 f0       	breq	.+2      	; 0xaa34 <Field2Buf+0xe4>
    aa32:	5b c0       	rjmp	.+182    	; 0xaaea <Field2Buf+0x19a>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    aa34:	7e 01       	movw	r14, r28
    aa36:	08 94       	sec
    aa38:	e1 1c       	adc	r14, r1
    aa3a:	f1 1c       	adc	r15, r1
    aa3c:	c7 01       	movw	r24, r14
    aa3e:	b6 01       	movw	r22, r12
    aa40:	44 e0       	ldi	r20, 0x04	; 4
    aa42:	50 e0       	ldi	r21, 0x00	; 0
    aa44:	0e 94 40 87 	call	0x10e80	; 0x10e80 <__eerd_block_m2560>
		Put_FFVal(*(float*)Var, &Param);
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
		break;
	case EE_FFloat:
		erbl(&fTemp, Var, 4);
		Put_FFVal(fTemp, &Param);
    aa48:	69 81       	ldd	r22, Y+1	; 0x01
    aa4a:	7a 81       	ldd	r23, Y+2	; 0x02
    aa4c:	8b 81       	ldd	r24, Y+3	; 0x03
    aa4e:	9c 81       	ldd	r25, Y+4	; 0x04
    aa50:	8e 01       	movw	r16, r28
    aa52:	0b 5f       	subi	r16, 0xFB	; 251
    aa54:	1f 4f       	sbci	r17, 0xFF	; 255
    aa56:	a8 01       	movw	r20, r16
    aa58:	0e 94 ae 47 	call	0x8f5c	; 0x8f5c <Put_FFVal>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
    aa5c:	8e ea       	ldi	r24, 0xAE	; 174
    aa5e:	96 e0       	ldi	r25, 0x06	; 6
    aa60:	60 91 c3 05 	lds	r22, 0x05C3
    aa64:	0e 94 77 44 	call	0x88ee	; 0x88ee <GetMultiSymbol>
    aa68:	80 93 f4 04 	sts	0x04F4, r24
	case GFloat:
		Put_GFVal(*(float*)Var, &Param);
    aa6c:	f6 01       	movw	r30, r12
    aa6e:	60 81       	ld	r22, Z
    aa70:	71 81       	ldd	r23, Z+1	; 0x01
    aa72:	82 81       	ldd	r24, Z+2	; 0x02
    aa74:	93 81       	ldd	r25, Z+3	; 0x03
    aa76:	a8 01       	movw	r20, r16
    aa78:	0e 94 34 47 	call	0x8e68	; 0x8e68 <Put_GFVal>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
    aa7c:	8e ea       	ldi	r24, 0xAE	; 174
    aa7e:	96 e0       	ldi	r25, 0x06	; 6
    aa80:	60 91 c3 05 	lds	r22, 0x05C3
    aa84:	0e 94 77 44 	call	0x88ee	; 0x88ee <GetMultiSymbol>
    aa88:	80 93 f4 04 	sts	0x04F4, r24
    aa8c:	c7 01       	movw	r24, r14
    aa8e:	b6 01       	movw	r22, r12
    aa90:	44 e0       	ldi	r20, 0x04	; 4
    aa92:	50 e0       	ldi	r21, 0x00	; 0
    aa94:	0e 94 40 87 	call	0x10e80	; 0x10e80 <__eerd_block_m2560>
	case EE_GFloat:
		erbl(&fTemp, Var, 4);
		Put_GFVal(fTemp, &Param);
    aa98:	69 81       	ldd	r22, Y+1	; 0x01
    aa9a:	7a 81       	ldd	r23, Y+2	; 0x02
    aa9c:	8b 81       	ldd	r24, Y+3	; 0x03
    aa9e:	9c 81       	ldd	r25, Y+4	; 0x04
    aaa0:	a8 01       	movw	r20, r16
    aaa2:	0e 94 34 47 	call	0x8e68	; 0x8e68 <Put_GFVal>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
    aaa6:	8e ea       	ldi	r24, 0xAE	; 174
    aaa8:	96 e0       	ldi	r25, 0x06	; 6
    aaaa:	60 91 c3 05 	lds	r22, 0x05C3
    aaae:	0e 94 77 44 	call	0x88ee	; 0x88ee <GetMultiSymbol>
    aab2:	80 93 f4 04 	sts	0x04F4, r24
    aab6:	19 c0       	rjmp	.+50     	; 0xaaea <Field2Buf+0x19a>
	void *Var = prp(&Field->Var);
	uint8_t BitN=prb(&Field->Prec), Mask=1<<BitN%8, *BitVar=(uint8_t*)Var+BitN/8;
	uint8_t Pos=Log10(prd(&Field->Max));
	uint8_t Oldstyle = 0;

	switch(prb(&Field->Type)) {
    aab8:	ee 58       	subi	r30, 0x8E	; 142
    aaba:	ff 4f       	sbci	r31, 0xFF	; 255
    aabc:	ee 0f       	add	r30, r30
    aabe:	ff 1f       	adc	r31, r31
    aac0:	05 90       	lpm	r0, Z+
    aac2:	f4 91       	lpm	r31, Z+
    aac4:	e0 2d       	mov	r30, r0
    aac6:	19 94       	eijmp
	case Byte: case z_Byte:
		F_Buf = *(uint8_t*)Var;
    aac8:	f6 01       	movw	r30, r12
    aaca:	80 81       	ld	r24, Z
    aacc:	90 e0       	ldi	r25, 0x00	; 0
    aace:	a0 e0       	ldi	r26, 0x00	; 0
    aad0:	b0 e0       	ldi	r27, 0x00	; 0
    aad2:	80 93 f7 04 	sts	0x04F7, r24
    aad6:	90 93 f8 04 	sts	0x04F8, r25
    aada:	a0 93 f9 04 	sts	0x04F9, r26
    aade:	b0 93 fa 04 	sts	0x04FA, r27
		CurrPos = Pos;
    aae2:	00 93 d7 02 	sts	0x02D7, r16
		F_Buf = (erb(BitVar) &Mask) > 0;
		Oldstyle = 1;
		break;
	}

	Minus=0;
    aae6:	10 92 ff 04 	sts	0x04FF, r1
				MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[0]);
			else MultiSymbol = GetMultiSymbol(Symbols_P, BufStr[0]);
		}
		break;
	}
}
    aaea:	6f 96       	adiw	r28, 0x1f	; 31
    aaec:	0f b6       	in	r0, 0x3f	; 63
    aaee:	f8 94       	cli
    aaf0:	de bf       	out	0x3e, r29	; 62
    aaf2:	0f be       	out	0x3f, r0	; 63
    aaf4:	cd bf       	out	0x3d, r28	; 61
    aaf6:	cf 91       	pop	r28
    aaf8:	df 91       	pop	r29
    aafa:	1f 91       	pop	r17
    aafc:	0f 91       	pop	r16
    aafe:	ff 90       	pop	r15
    ab00:	ef 90       	pop	r14
    ab02:	df 90       	pop	r13
    ab04:	cf 90       	pop	r12
    ab06:	bf 90       	pop	r11
    ab08:	af 90       	pop	r10
    ab0a:	9f 90       	pop	r9
    ab0c:	8f 90       	pop	r8
    ab0e:	7f 90       	pop	r7
    ab10:	6f 90       	pop	r6
    ab12:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    ab14:	c6 01       	movw	r24, r12
    ab16:	0e 94 50 87 	call	0x10ea0	; 0x10ea0 <__eerd_byte_m2560>
		sF_Buf = *(int8_t*)Var;
		CurrPos = Pos+1;
		Oldstyle = 1;
		break;
	case EE_Byte: case z_EE_Byte:
		F_Buf = erb((uint8_t*)Var);
    ab1a:	90 e0       	ldi	r25, 0x00	; 0
    ab1c:	a0 e0       	ldi	r26, 0x00	; 0
    ab1e:	b0 e0       	ldi	r27, 0x00	; 0
    ab20:	80 93 f7 04 	sts	0x04F7, r24
    ab24:	90 93 f8 04 	sts	0x04F8, r25
    ab28:	a0 93 f9 04 	sts	0x04F9, r26
    ab2c:	b0 93 fa 04 	sts	0x04FA, r27
		CurrPos = Pos;
    ab30:	00 93 d7 02 	sts	0x02D7, r16
    ab34:	d8 cf       	rjmp	.-80     	; 0xaae6 <Field2Buf+0x196>
		F_Buf = *(uint8_t*)Var;
		CurrPos = Pos;
		Oldstyle = 1;
		break;
	case s_Byte:
		sF_Buf = *(int8_t*)Var;
    ab36:	f6 01       	movw	r30, r12
    ab38:	80 81       	ld	r24, Z
    ab3a:	99 27       	eor	r25, r25
    ab3c:	87 fd       	sbrc	r24, 7
    ab3e:	90 95       	com	r25
    ab40:	a9 2f       	mov	r26, r25
    ab42:	b9 2f       	mov	r27, r25
    ab44:	80 93 fb 04 	sts	0x04FB, r24
    ab48:	90 93 fc 04 	sts	0x04FC, r25
    ab4c:	a0 93 fd 04 	sts	0x04FD, r26
    ab50:	b0 93 fe 04 	sts	0x04FE, r27
		CurrPos = Pos+1;
    ab54:	0f 5f       	subi	r16, 0xFF	; 255
    ab56:	00 93 d7 02 	sts	0x02D7, r16
    ab5a:	c5 cf       	rjmp	.-118    	; 0xaae6 <Field2Buf+0x196>
    ab5c:	c6 01       	movw	r24, r12
    ab5e:	0e 94 50 87 	call	0x10ea0	; 0x10ea0 <__eerd_byte_m2560>
		F_Buf = erb((uint8_t*)Var);
		CurrPos = Pos;
		Oldstyle = 1;
		break;
	case s_EE_Byte:
		sF_Buf = (int8_t)erb((uint8_t*)Var);
    ab62:	99 27       	eor	r25, r25
    ab64:	87 fd       	sbrc	r24, 7
    ab66:	90 95       	com	r25
    ab68:	a9 2f       	mov	r26, r25
    ab6a:	b9 2f       	mov	r27, r25
    ab6c:	80 93 fb 04 	sts	0x04FB, r24
    ab70:	90 93 fc 04 	sts	0x04FC, r25
    ab74:	a0 93 fd 04 	sts	0x04FD, r26
    ab78:	b0 93 fe 04 	sts	0x04FE, r27
		CurrPos = Pos+1;
    ab7c:	0f 5f       	subi	r16, 0xFF	; 255
    ab7e:	00 93 d7 02 	sts	0x02D7, r16
    ab82:	b1 cf       	rjmp	.-158    	; 0xaae6 <Field2Buf+0x196>
		Oldstyle = 1;
		break;

	case Word: case z_Word:
		F_Buf = *(uint16_t*)Var;
    ab84:	f6 01       	movw	r30, r12
    ab86:	80 81       	ld	r24, Z
    ab88:	91 81       	ldd	r25, Z+1	; 0x01
    ab8a:	a0 e0       	ldi	r26, 0x00	; 0
    ab8c:	b0 e0       	ldi	r27, 0x00	; 0
    ab8e:	80 93 f7 04 	sts	0x04F7, r24
    ab92:	90 93 f8 04 	sts	0x04F8, r25
    ab96:	a0 93 f9 04 	sts	0x04F9, r26
    ab9a:	b0 93 fa 04 	sts	0x04FA, r27
		CurrPos = Pos;
    ab9e:	00 93 d7 02 	sts	0x02D7, r16
    aba2:	a1 cf       	rjmp	.-190    	; 0xaae6 <Field2Buf+0x196>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    aba4:	c6 01       	movw	r24, r12
    aba6:	0e 94 5e 87 	call	0x10ebc	; 0x10ebc <__eerd_word_m2560>
		Oldstyle = 1;
		break;
	case EE_Word: case z_EE_Word:
		F_Buf = erw((uint16_t*)Var);
    abaa:	a0 e0       	ldi	r26, 0x00	; 0
    abac:	b0 e0       	ldi	r27, 0x00	; 0
    abae:	80 93 f7 04 	sts	0x04F7, r24
    abb2:	90 93 f8 04 	sts	0x04F8, r25
    abb6:	a0 93 f9 04 	sts	0x04F9, r26
    abba:	b0 93 fa 04 	sts	0x04FA, r27
		CurrPos = Pos;
    abbe:	00 93 d7 02 	sts	0x02D7, r16
    abc2:	91 cf       	rjmp	.-222    	; 0xaae6 <Field2Buf+0x196>
		Oldstyle = 1;
		break;
	case s_Word:
		sF_Buf = *(int16_t*)Var;
    abc4:	f6 01       	movw	r30, r12
    abc6:	80 81       	ld	r24, Z
    abc8:	91 81       	ldd	r25, Z+1	; 0x01
    abca:	aa 27       	eor	r26, r26
    abcc:	97 fd       	sbrc	r25, 7
    abce:	a0 95       	com	r26
    abd0:	ba 2f       	mov	r27, r26
    abd2:	80 93 fb 04 	sts	0x04FB, r24
    abd6:	90 93 fc 04 	sts	0x04FC, r25
    abda:	a0 93 fd 04 	sts	0x04FD, r26
    abde:	b0 93 fe 04 	sts	0x04FE, r27
		CurrPos = Pos+1;
    abe2:	0f 5f       	subi	r16, 0xFF	; 255
    abe4:	00 93 d7 02 	sts	0x02D7, r16
    abe8:	7e cf       	rjmp	.-260    	; 0xaae6 <Field2Buf+0x196>
    abea:	c6 01       	movw	r24, r12
    abec:	0e 94 5e 87 	call	0x10ebc	; 0x10ebc <__eerd_word_m2560>
		Oldstyle = 1;
		break;
	case s_EE_Word:
		sF_Buf = (int16_t)erw((uint16_t*)Var);
    abf0:	aa 27       	eor	r26, r26
    abf2:	97 fd       	sbrc	r25, 7
    abf4:	a0 95       	com	r26
    abf6:	ba 2f       	mov	r27, r26
    abf8:	80 93 fb 04 	sts	0x04FB, r24
    abfc:	90 93 fc 04 	sts	0x04FC, r25
    ac00:	a0 93 fd 04 	sts	0x04FD, r26
    ac04:	b0 93 fe 04 	sts	0x04FE, r27
		CurrPos = Pos+1;
    ac08:	0f 5f       	subi	r16, 0xFF	; 255
    ac0a:	00 93 d7 02 	sts	0x02D7, r16
    ac0e:	6b cf       	rjmp	.-298    	; 0xaae6 <Field2Buf+0x196>
		Oldstyle = 1;
		break;
	case c_Word: case zc_Word:
		F_Buf = *(uint16_t*)Var;
    ac10:	f6 01       	movw	r30, r12
    ac12:	80 81       	ld	r24, Z
    ac14:	91 81       	ldd	r25, Z+1	; 0x01
    ac16:	a0 e0       	ldi	r26, 0x00	; 0
    ac18:	b0 e0       	ldi	r27, 0x00	; 0
    ac1a:	80 93 f7 04 	sts	0x04F7, r24
    ac1e:	90 93 f8 04 	sts	0x04F8, r25
    ac22:	a0 93 f9 04 	sts	0x04F9, r26
    ac26:	b0 93 fa 04 	sts	0x04FA, r27
    ac2a:	5d cf       	rjmp	.-326    	; 0xaae6 <Field2Buf+0x196>
		Oldstyle = 1;
		break;

	case Enum:
		F_Buf = *(uint8_t*)Var;
    ac2c:	f6 01       	movw	r30, r12
    ac2e:	80 81       	ld	r24, Z
    ac30:	90 e0       	ldi	r25, 0x00	; 0
    ac32:	a0 e0       	ldi	r26, 0x00	; 0
    ac34:	b0 e0       	ldi	r27, 0x00	; 0
    ac36:	80 93 f7 04 	sts	0x04F7, r24
    ac3a:	90 93 f8 04 	sts	0x04F8, r25
    ac3e:	a0 93 f9 04 	sts	0x04F9, r26
    ac42:	b0 93 fa 04 	sts	0x04FA, r27
    ac46:	4f cf       	rjmp	.-354    	; 0xaae6 <Field2Buf+0x196>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    ac48:	c6 01       	movw	r24, r12
    ac4a:	0e 94 50 87 	call	0x10ea0	; 0x10ea0 <__eerd_byte_m2560>
		Oldstyle = 1;
		break;
	case EE_Enum:
		F_Buf = erb((uint8_t*)Var);
    ac4e:	90 e0       	ldi	r25, 0x00	; 0
    ac50:	a0 e0       	ldi	r26, 0x00	; 0
    ac52:	b0 e0       	ldi	r27, 0x00	; 0
    ac54:	80 93 f7 04 	sts	0x04F7, r24
    ac58:	90 93 f8 04 	sts	0x04F8, r25
    ac5c:	a0 93 f9 04 	sts	0x04F9, r26
    ac60:	b0 93 fa 04 	sts	0x04FA, r27
    ac64:	40 cf       	rjmp	.-384    	; 0xaae6 <Field2Buf+0x196>
		Oldstyle = 1;
		break;
	case Bit:
		F_Buf = (*BitVar &Mask) > 0;
    ac66:	20 e0       	ldi	r18, 0x00	; 0
    ac68:	30 e0       	ldi	r19, 0x00	; 0
    ac6a:	40 e0       	ldi	r20, 0x00	; 0
    ac6c:	50 e0       	ldi	r21, 0x00	; 0
    ac6e:	f5 01       	movw	r30, r10
    ac70:	80 81       	ld	r24, Z
    ac72:	81 23       	and	r24, r17
    ac74:	21 f5       	brne	.+72     	; 0xacbe <Field2Buf+0x36e>
    ac76:	20 93 f7 04 	sts	0x04F7, r18
    ac7a:	30 93 f8 04 	sts	0x04F8, r19
    ac7e:	40 93 f9 04 	sts	0x04F9, r20
    ac82:	50 93 fa 04 	sts	0x04FA, r21
    ac86:	2f cf       	rjmp	.-418    	; 0xaae6 <Field2Buf+0x196>
    ac88:	c5 01       	movw	r24, r10
    ac8a:	0e 94 50 87 	call	0x10ea0	; 0x10ea0 <__eerd_byte_m2560>
		Oldstyle = 1;
		break;
	case EE_Bit:
		F_Buf = (erb(BitVar) &Mask) > 0;
    ac8e:	10 92 f7 04 	sts	0x04F7, r1
    ac92:	10 92 f8 04 	sts	0x04F8, r1
    ac96:	10 92 f9 04 	sts	0x04F9, r1
    ac9a:	10 92 fa 04 	sts	0x04FA, r1
    ac9e:	18 23       	and	r17, r24
    aca0:	09 f4       	brne	.+2      	; 0xaca4 <Field2Buf+0x354>
    aca2:	21 cf       	rjmp	.-446    	; 0xaae6 <Field2Buf+0x196>
    aca4:	81 e0       	ldi	r24, 0x01	; 1
    aca6:	90 e0       	ldi	r25, 0x00	; 0
    aca8:	a0 e0       	ldi	r26, 0x00	; 0
    acaa:	b0 e0       	ldi	r27, 0x00	; 0
    acac:	80 93 f7 04 	sts	0x04F7, r24
    acb0:	90 93 f8 04 	sts	0x04F8, r25
    acb4:	a0 93 f9 04 	sts	0x04F9, r26
    acb8:	b0 93 fa 04 	sts	0x04FA, r27
    acbc:	14 cf       	rjmp	.-472    	; 0xaae6 <Field2Buf+0x196>
	case EE_Enum:
		F_Buf = erb((uint8_t*)Var);
		Oldstyle = 1;
		break;
	case Bit:
		F_Buf = (*BitVar &Mask) > 0;
    acbe:	21 e0       	ldi	r18, 0x01	; 1
    acc0:	30 e0       	ldi	r19, 0x00	; 0
    acc2:	40 e0       	ldi	r20, 0x00	; 0
    acc4:	50 e0       	ldi	r21, 0x00	; 0
    acc6:	d7 cf       	rjmp	.-82     	; 0xac76 <Field2Buf+0x326>
	Param.Size = CurrFieldSize;
	Param.Pos = BufStr;
	Param.Prec = prb(&Field->Prec);
	Param.Txt = NULL;

	switch(prb(&Field->Type)) {
    acc8:	82 31       	cpi	r24, 0x12	; 18
    acca:	51 f1       	breq	.+84     	; 0xad20 <Field2Buf+0x3d0>
    accc:	83 31       	cpi	r24, 0x13	; 19
    acce:	08 f0       	brcs	.+2      	; 0xacd2 <Field2Buf+0x382>
    acd0:	53 c0       	rjmp	.+166    	; 0xad78 <Field2Buf+0x428>
    acd2:	80 31       	cpi	r24, 0x10	; 16
    acd4:	c1 f1       	breq	.+112    	; 0xad46 <Field2Buf+0x3f6>
    acd6:	81 31       	cpi	r24, 0x11	; 17
    acd8:	09 f0       	breq	.+2      	; 0xacdc <Field2Buf+0x38c>
    acda:	07 cf       	rjmp	.-498    	; 0xaaea <Field2Buf+0x19a>
// ~~~~~~~~~~~~~~~~~~~~~~
uint32_t
erd(const uint32_t *addr)
{
	//IntOff();
	uint32_t word = eeprom_read_dword(addr);
    acdc:	c6 01       	movw	r24, r12
    acde:	0e 94 58 87 	call	0x10eb0	; 0x10eb0 <__eerd_dword_m2560>
	case z_Longint:
		Put_zDVal(*(uint32_t*)Var, &Param);
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
		break;
	case EE_Longint: 
		PutDVal(erd((uint32_t*)Var), &Param);
    ace2:	ae 01       	movw	r20, r28
    ace4:	4b 5f       	subi	r20, 0xFB	; 251
    ace6:	5f 4f       	sbci	r21, 0xFF	; 255
    ace8:	0e 94 4d 4a 	call	0x949a	; 0x949a <PutDVal>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
    acec:	8e ea       	ldi	r24, 0xAE	; 174
    acee:	96 e0       	ldi	r25, 0x06	; 6
    acf0:	60 91 c3 05 	lds	r22, 0x05C3
    acf4:	0e 94 77 44 	call	0x88ee	; 0x88ee <GetMultiSymbol>
    acf8:	80 93 f4 04 	sts	0x04F4, r24
    acfc:	f6 ce       	rjmp	.-532    	; 0xaaea <Field2Buf+0x19a>
    acfe:	c6 01       	movw	r24, r12
    ad00:	0e 94 58 87 	call	0x10eb0	; 0x10eb0 <__eerd_dword_m2560>
		break;
	case z_EE_Longint:
		Put_zDVal(erd((uint32_t*)Var), &Param);
    ad04:	ae 01       	movw	r20, r28
    ad06:	4b 5f       	subi	r20, 0xFB	; 251
    ad08:	5f 4f       	sbci	r21, 0xFF	; 255
    ad0a:	0e 94 03 48 	call	0x9006	; 0x9006 <Put_zDVal>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
    ad0e:	8e ea       	ldi	r24, 0xAE	; 174
    ad10:	96 e0       	ldi	r25, 0x06	; 6
    ad12:	60 91 c3 05 	lds	r22, 0x05C3
    ad16:	0e 94 77 44 	call	0x88ee	; 0x88ee <GetMultiSymbol>
    ad1a:	80 93 f4 04 	sts	0x04F4, r24
    ad1e:	e5 ce       	rjmp	.-566    	; 0xaaea <Field2Buf+0x19a>
		break;
	case s_Longint:
		Put_sDVal(*(int32_t*)Var, &Param);
    ad20:	f6 01       	movw	r30, r12
    ad22:	60 81       	ld	r22, Z
    ad24:	71 81       	ldd	r23, Z+1	; 0x01
    ad26:	82 81       	ldd	r24, Z+2	; 0x02
    ad28:	93 81       	ldd	r25, Z+3	; 0x03
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
		break;
	case s_EE_Longint:
		Put_sDVal((int32_t)erd((uint32_t*)Var), &Param);
    ad2a:	ae 01       	movw	r20, r28
    ad2c:	4b 5f       	subi	r20, 0xFB	; 251
    ad2e:	5f 4f       	sbci	r21, 0xFF	; 255
    ad30:	0e 94 24 49 	call	0x9248	; 0x9248 <Put_sDVal>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
    ad34:	8e ea       	ldi	r24, 0xAE	; 174
    ad36:	96 e0       	ldi	r25, 0x06	; 6
    ad38:	60 91 c3 05 	lds	r22, 0x05C3
    ad3c:	0e 94 77 44 	call	0x88ee	; 0x88ee <GetMultiSymbol>
    ad40:	80 93 f4 04 	sts	0x04F4, r24
    ad44:	d2 ce       	rjmp	.-604    	; 0xaaea <Field2Buf+0x19a>
	Param.Prec = prb(&Field->Prec);
	Param.Txt = NULL;

	switch(prb(&Field->Type)) {
	case Longint:
		PutDVal(*(uint32_t*)Var, &Param);
    ad46:	f6 01       	movw	r30, r12
    ad48:	60 81       	ld	r22, Z
    ad4a:	71 81       	ldd	r23, Z+1	; 0x01
    ad4c:	82 81       	ldd	r24, Z+2	; 0x02
    ad4e:	93 81       	ldd	r25, Z+3	; 0x03
    ad50:	c8 cf       	rjmp	.-112    	; 0xace2 <Field2Buf+0x392>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
		break;


	case FFloat:
		Put_FFVal(*(float*)Var, &Param);
    ad52:	f6 01       	movw	r30, r12
    ad54:	60 81       	ld	r22, Z
    ad56:	71 81       	ldd	r23, Z+1	; 0x01
    ad58:	82 81       	ldd	r24, Z+2	; 0x02
    ad5a:	93 81       	ldd	r25, Z+3	; 0x03
    ad5c:	ae 01       	movw	r20, r28
    ad5e:	4b 5f       	subi	r20, 0xFB	; 251
    ad60:	5f 4f       	sbci	r21, 0xFF	; 255
    ad62:	0e 94 ae 47 	call	0x8f5c	; 0x8f5c <Put_FFVal>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
    ad66:	8e ea       	ldi	r24, 0xAE	; 174
    ad68:	96 e0       	ldi	r25, 0x06	; 6
    ad6a:	60 91 c3 05 	lds	r22, 0x05C3
    ad6e:	0e 94 77 44 	call	0x88ee	; 0x88ee <GetMultiSymbol>
    ad72:	80 93 f4 04 	sts	0x04F4, r24
    ad76:	b9 ce       	rjmp	.-654    	; 0xaaea <Field2Buf+0x19a>
	Param.Size = CurrFieldSize;
	Param.Pos = BufStr;
	Param.Prec = prb(&Field->Prec);
	Param.Txt = NULL;

	switch(prb(&Field->Type)) {
    ad78:	83 31       	cpi	r24, 0x13	; 19
    ad7a:	49 f0       	breq	.+18     	; 0xad8e <Field2Buf+0x43e>
    ad7c:	84 31       	cpi	r24, 0x14	; 20
    ad7e:	09 f0       	breq	.+2      	; 0xad82 <Field2Buf+0x432>
    ad80:	b4 ce       	rjmp	.-664    	; 0xaaea <Field2Buf+0x19a>
	case Longint:
		PutDVal(*(uint32_t*)Var, &Param);
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
		break;
	case z_Longint:
		Put_zDVal(*(uint32_t*)Var, &Param);
    ad82:	f6 01       	movw	r30, r12
    ad84:	60 81       	ld	r22, Z
    ad86:	71 81       	ldd	r23, Z+1	; 0x01
    ad88:	82 81       	ldd	r24, Z+2	; 0x02
    ad8a:	93 81       	ldd	r25, Z+3	; 0x03
    ad8c:	bb cf       	rjmp	.-138    	; 0xad04 <Field2Buf+0x3b4>
    ad8e:	c6 01       	movw	r24, r12
    ad90:	0e 94 58 87 	call	0x10eb0	; 0x10eb0 <__eerd_dword_m2560>
    ad94:	ca cf       	rjmp	.-108    	; 0xad2a <Field2Buf+0x3da>
	Param.Size = CurrFieldSize;
	Param.Pos = BufStr;
	Param.Prec = prb(&Field->Prec);
	Param.Txt = NULL;

	switch(prb(&Field->Type)) {
    ad96:	81 32       	cpi	r24, 0x21	; 33
    ad98:	69 f0       	breq	.+26     	; 0xadb4 <Field2Buf+0x464>
    ad9a:	82 32       	cpi	r24, 0x22	; 34
    ad9c:	69 f1       	breq	.+90     	; 0xadf8 <Field2Buf+0x4a8>
    ad9e:	8c 31       	cpi	r24, 0x1C	; 28
    ada0:	09 f0       	breq	.+2      	; 0xada4 <Field2Buf+0x454>
    ada2:	a3 ce       	rjmp	.-698    	; 0xaaea <Field2Buf+0x19a>
    ada4:	8e 01       	movw	r16, r28
    ada6:	0b 5f       	subi	r16, 0xFB	; 251
    ada8:	1f 4f       	sbci	r17, 0xFF	; 255
    adaa:	7e 01       	movw	r14, r28
    adac:	08 94       	sec
    adae:	e1 1c       	adc	r14, r1
    adb0:	f1 1c       	adc	r15, r1
    adb2:	6c ce       	rjmp	.-808    	; 0xaa8c <Field2Buf+0x13c>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
		break;


	case Text:
		Put_TextValAlignLeft((char*)Var, &Param);
    adb4:	c6 01       	movw	r24, r12
		
		break;
	case EE_Text:{
			char TempStr[LCDXSz+1];
			erbl(TempStr, Var, CurrFieldSize);
			Put_TextValAlignLeft(TempStr, &Param);
    adb6:	be 01       	movw	r22, r28
    adb8:	6b 5f       	subi	r22, 0xFB	; 251
    adba:	7f 4f       	sbci	r23, 0xFF	; 255
    adbc:	0e 94 7c 46 	call	0x8cf8	; 0x8cf8 <Put_TextValAlignLeft>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    adc0:	f7 01       	movw	r30, r14
    adc2:	33 96       	adiw	r30, 0x03	; 3
    adc4:	85 91       	lpm	r24, Z+
    adc6:	95 91       	lpm	r25, Z+
    adc8:	a5 91       	lpm	r26, Z+
    adca:	b4 91       	lpm	r27, Z+
			if( (prd(&Field->Min) == DIGIT) && (prd(&Field->Max) == DIGIT) )
    adcc:	00 97       	sbiw	r24, 0x00	; 0
    adce:	a1 05       	cpc	r26, r1
    add0:	b1 05       	cpc	r27, r1
    add2:	49 f4       	brne	.+18     	; 0xade6 <Field2Buf+0x496>
    add4:	f3 01       	movw	r30, r6
    add6:	85 91       	lpm	r24, Z+
    add8:	95 91       	lpm	r25, Z+
    adda:	a5 91       	lpm	r26, Z+
    addc:	b4 91       	lpm	r27, Z+
    adde:	00 97       	sbiw	r24, 0x00	; 0
    ade0:	a1 05       	cpc	r26, r1
    ade2:	b1 05       	cpc	r27, r1
    ade4:	99 f0       	breq	.+38     	; 0xae0c <Field2Buf+0x4bc>
				MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[0]);
			else MultiSymbol = GetMultiSymbol(Symbols_P, BufStr[0]);
    ade6:	85 e0       	ldi	r24, 0x05	; 5
    ade8:	96 e0       	ldi	r25, 0x06	; 6
    adea:	60 91 c3 05 	lds	r22, 0x05C3
    adee:	0e 94 77 44 	call	0x88ee	; 0x88ee <GetMultiSymbol>
    adf2:	80 93 f4 04 	sts	0x04F4, r24
    adf6:	79 ce       	rjmp	.-782    	; 0xaaea <Field2Buf+0x19a>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    adf8:	8e 01       	movw	r16, r28
    adfa:	05 5f       	subi	r16, 0xF5	; 245
    adfc:	1f 4f       	sbci	r17, 0xFF	; 255
    adfe:	c8 01       	movw	r24, r16
    ae00:	b6 01       	movw	r22, r12
    ae02:	50 e0       	ldi	r21, 0x00	; 0
    ae04:	0e 94 40 87 	call	0x10e80	; 0x10e80 <__eerd_block_m2560>
		
		break;
	case EE_Text:{
			char TempStr[LCDXSz+1];
			erbl(TempStr, Var, CurrFieldSize);
			Put_TextValAlignLeft(TempStr, &Param);
    ae08:	c8 01       	movw	r24, r16
    ae0a:	d5 cf       	rjmp	.-86     	; 0xadb6 <Field2Buf+0x466>
			if( (prd(&Field->Min) == DIGIT) && (prd(&Field->Max) == DIGIT) )
				MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[0]);
    ae0c:	83 ea       	ldi	r24, 0xA3	; 163
    ae0e:	96 e0       	ldi	r25, 0x06	; 6
    ae10:	60 91 c3 05 	lds	r22, 0x05C3
    ae14:	0e 94 77 44 	call	0x88ee	; 0x88ee <GetMultiSymbol>
    ae18:	80 93 f4 04 	sts	0x04F4, r24
    ae1c:	66 ce       	rjmp	.-820    	; 0xaaea <Field2Buf+0x19a>
    ae1e:	8e 01       	movw	r16, r28
    ae20:	0b 5f       	subi	r16, 0xFB	; 251
    ae22:	1f 4f       	sbci	r17, 0xFF	; 255
    ae24:	7e 01       	movw	r14, r28
    ae26:	08 94       	sec
    ae28:	e1 1c       	adc	r14, r1
    ae2a:	f1 1c       	adc	r15, r1
    ae2c:	1f ce       	rjmp	.-962    	; 0xaa6c <Field2Buf+0x11c>

0000ae2e <MenuEscLeft>:
}

// ~~~~~~~~~~~~~~
void
MenuEscLeft(void)
{
    ae2e:	0f 93       	push	r16
    ae30:	1f 93       	push	r17
    ae32:	cf 93       	push	r28
    ae34:	df 93       	push	r29
//	1) Hide current Message
	if(HideMsg()||KeyFunc(&CurrPage->Esc))
    ae36:	0e 94 12 40 	call	0x8024	; 0x8024 <HideMsg>
    ae3a:	88 23       	and	r24, r24
    ae3c:	29 f0       	breq	.+10     	; 0xae48 <MenuEscLeft+0x1a>
		else
			CurrPage=prp(&CurrPage->OutPage);
		CurrLine=CurrLCD=GetFix();
	}
	EventFunc(&CurrPage->Load);
}
    ae3e:	df 91       	pop	r29
    ae40:	cf 91       	pop	r28
    ae42:	1f 91       	pop	r17
    ae44:	0f 91       	pop	r16
    ae46:	08 95       	ret
// ~~~~~~~~~~~~~~
void
MenuEscLeft(void)
{
//	1) Hide current Message
	if(HideMsg()||KeyFunc(&CurrPage->Esc))
    ae48:	80 91 d4 02 	lds	r24, 0x02D4
    ae4c:	90 91 d5 02 	lds	r25, 0x02D5
    ae50:	0e 96       	adiw	r24, 0x0e	; 14
    ae52:	0e 94 b8 3f 	call	0x7f70	; 0x7f70 <KeyFunc>
    ae56:	88 23       	and	r24, r24
    ae58:	91 f7       	brne	.-28     	; 0xae3e <MenuEscLeft+0x10>
		return;

// 2) Variable
	if(CurrField!=NullPos) {
    ae5a:	30 91 d6 02 	lds	r19, 0x02D6
    ae5e:	3f 3f       	cpi	r19, 0xFF	; 255
    ae60:	09 f4       	brne	.+2      	; 0xae64 <MenuEscLeft+0x36>
    ae62:	c8 c0       	rjmp	.+400    	; 0xaff4 <MenuEscLeft+0x1c6>
		if(CurrPos!=NullPos) {
    ae64:	40 91 d7 02 	lds	r20, 0x02D7
    ae68:	4f 3f       	cpi	r20, 0xFF	; 255
    ae6a:	09 f4       	brne	.+2      	; 0xae6e <MenuEscLeft+0x40>
    ae6c:	5a c0       	rjmp	.+180    	; 0xaf22 <MenuEscLeft+0xf4>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    ae6e:	80 91 d4 02 	lds	r24, 0x02D4
    ae72:	90 91 d5 02 	lds	r25, 0x02D5
    ae76:	fc 01       	movw	r30, r24
    ae78:	65 91       	lpm	r22, Z+
    ae7a:	74 91       	lpm	r23, Z+
			OutField *Field=GetField;
    ae7c:	80 91 ca 07 	lds	r24, 0x07CA
    ae80:	2b e1       	ldi	r18, 0x1B	; 27
    ae82:	82 9f       	mul	r24, r18
    ae84:	c0 01       	movw	r24, r0
    ae86:	11 24       	eor	r1, r1
    ae88:	68 0f       	add	r22, r24
    ae8a:	79 1f       	adc	r23, r25
    ae8c:	69 5e       	subi	r22, 0xE9	; 233
    ae8e:	7f 4f       	sbci	r23, 0xFF	; 255
    ae90:	fb 01       	movw	r30, r22
    ae92:	c5 91       	lpm	r28, Z+
    ae94:	d4 91       	lpm	r29, Z+
    ae96:	83 2f       	mov	r24, r19
    ae98:	90 e0       	ldi	r25, 0x00	; 0
    ae9a:	82 95       	swap	r24
    ae9c:	92 95       	swap	r25
    ae9e:	90 7f       	andi	r25, 0xF0	; 240
    aea0:	98 27       	eor	r25, r24
    aea2:	80 7f       	andi	r24, 0xF0	; 240
    aea4:	98 27       	eor	r25, r24
    aea6:	c8 0f       	add	r28, r24
    aea8:	d9 1f       	adc	r29, r25

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    aeaa:	fe 01       	movw	r30, r28
    aeac:	14 91       	lpm	r17, Z+
			uint8_t Type=prb(&Field->Type);
			uint8_t Pos;

			if( (Type == Text) || (Type == EE_Text) ||
    aeae:	01 2f       	mov	r16, r17
    aeb0:	01 52       	subi	r16, 0x21	; 33
    aeb2:	02 30       	cpi	r16, 0x02	; 2
    aeb4:	00 f1       	brcs	.+64     	; 0xaef6 <MenuEscLeft+0xc8>
    aeb6:	10 31       	cpi	r17, 0x10	; 16
    aeb8:	f1 f0       	breq	.+60     	; 0xaef6 <MenuEscLeft+0xc8>
    aeba:	11 31       	cpi	r17, 0x11	; 17
    aebc:	e1 f0       	breq	.+56     	; 0xaef6 <MenuEscLeft+0xc8>
    aebe:	12 31       	cpi	r17, 0x12	; 18
    aec0:	d1 f0       	breq	.+52     	; 0xaef6 <MenuEscLeft+0xc8>
    aec2:	13 31       	cpi	r17, 0x13	; 19
    aec4:	c1 f0       	breq	.+48     	; 0xaef6 <MenuEscLeft+0xc8>
    aec6:	14 31       	cpi	r17, 0x14	; 20
    aec8:	b1 f0       	breq	.+44     	; 0xaef6 <MenuEscLeft+0xc8>
    aeca:	15 31       	cpi	r17, 0x15	; 21
    aecc:	a1 f0       	breq	.+40     	; 0xaef6 <MenuEscLeft+0xc8>
    aece:	19 31       	cpi	r17, 0x19	; 25
    aed0:	91 f0       	breq	.+36     	; 0xaef6 <MenuEscLeft+0xc8>
    aed2:	1a 31       	cpi	r17, 0x1A	; 26
    aed4:	81 f0       	breq	.+32     	; 0xaef6 <MenuEscLeft+0xc8>
    aed6:	1b 31       	cpi	r17, 0x1B	; 27
    aed8:	71 f0       	breq	.+28     	; 0xaef6 <MenuEscLeft+0xc8>
    aeda:	1c 31       	cpi	r17, 0x1C	; 28
    aedc:	61 f0       	breq	.+24     	; 0xaef6 <MenuEscLeft+0xc8>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    aede:	fe 01       	movw	r30, r28
    aee0:	37 96       	adiw	r30, 0x07	; 7
    aee2:	65 91       	lpm	r22, Z+
    aee4:	75 91       	lpm	r23, Z+
    aee6:	85 91       	lpm	r24, Z+
    aee8:	94 91       	lpm	r25, Z+
			 (Type == Longint) || (Type == EE_Longint)|| (Type == s_Longint) || (Type == s_EE_Longint) || (Type == z_Longint) || (Type == z_EE_Longint) ||
			 (Type == FFloat) || (Type == EE_FFloat) || (Type == GFloat) || (Type == EE_GFloat) ) 
			 	Pos = CurrFieldSize-1;
			else Pos=Log10(prd(&Field->Max));
    aeea:	0e 94 36 24 	call	0x486c	; 0x486c <Log10>
    aeee:	98 2f       	mov	r25, r24
    aef0:	40 91 d7 02 	lds	r20, 0x02D7
    aef4:	03 c0       	rjmp	.+6      	; 0xaefc <MenuEscLeft+0xce>
			uint8_t Pos;

			if( (Type == Text) || (Type == EE_Text) ||
			 (Type == Longint) || (Type == EE_Longint)|| (Type == s_Longint) || (Type == s_EE_Longint) || (Type == z_Longint) || (Type == z_EE_Longint) ||
			 (Type == FFloat) || (Type == EE_FFloat) || (Type == GFloat) || (Type == EE_GFloat) ) 
			 	Pos = CurrFieldSize-1;
    aef6:	90 91 c0 07 	lds	r25, 0x07C0
    aefa:	91 50       	subi	r25, 0x01	; 1
			else Pos=Log10(prd(&Field->Max));

			if(Type==s_Byte || Type==s_EE_Byte || Type==s_Word || Type==s_EE_Word)
    aefc:	81 2f       	mov	r24, r17
    aefe:	82 50       	subi	r24, 0x02	; 2
    af00:	82 30       	cpi	r24, 0x02	; 2
    af02:	b0 f1       	brcs	.+108    	; 0xaf70 <MenuEscLeft+0x142>
    af04:	19 30       	cpi	r17, 0x09	; 9
    af06:	a1 f1       	breq	.+104    	; 0xaf70 <MenuEscLeft+0x142>
    af08:	1a 30       	cpi	r17, 0x0A	; 10
    af0a:	91 f1       	breq	.+100    	; 0xaf70 <MenuEscLeft+0x142>
				Pos++;
			if(++CurrPos>Pos)
    af0c:	24 2f       	mov	r18, r20
    af0e:	2f 5f       	subi	r18, 0xFF	; 255
    af10:	20 93 d7 02 	sts	0x02D7, r18
    af14:	92 17       	cp	r25, r18
    af16:	70 f5       	brcc	.+92     	; 0xaf74 <MenuEscLeft+0x146>
				CurrPos = NullPos;
    af18:	8f ef       	ldi	r24, 0xFF	; 255
    af1a:	80 93 d7 02 	sts	0x02D7, r24
    af1e:	30 91 d6 02 	lds	r19, 0x02D6
				}
				return;
			}
		}
		//     
		if(--CurrField!=NullPos)
    af22:	31 50       	subi	r19, 0x01	; 1
    af24:	30 93 d6 02 	sts	0x02D6, r19
    af28:	3f 3f       	cpi	r19, 0xFF	; 255
    af2a:	09 f4       	brne	.+2      	; 0xaf2e <MenuEscLeft+0x100>
    af2c:	88 cf       	rjmp	.-240    	; 0xae3e <MenuEscLeft+0x10>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    af2e:	80 91 d4 02 	lds	r24, 0x02D4
    af32:	90 91 d5 02 	lds	r25, 0x02D5
    af36:	fc 01       	movw	r30, r24
    af38:	45 91       	lpm	r20, Z+
    af3a:	54 91       	lpm	r21, Z+
			Field2Buf(GetField);
    af3c:	80 91 ca 07 	lds	r24, 0x07CA
    af40:	2b e1       	ldi	r18, 0x1B	; 27
    af42:	82 9f       	mul	r24, r18
    af44:	c0 01       	movw	r24, r0
    af46:	11 24       	eor	r1, r1
    af48:	48 0f       	add	r20, r24
    af4a:	59 1f       	adc	r21, r25
    af4c:	49 5e       	subi	r20, 0xE9	; 233
    af4e:	5f 4f       	sbci	r21, 0xFF	; 255
    af50:	fa 01       	movw	r30, r20
    af52:	85 91       	lpm	r24, Z+
    af54:	94 91       	lpm	r25, Z+
    af56:	23 2f       	mov	r18, r19
    af58:	30 e0       	ldi	r19, 0x00	; 0
    af5a:	22 95       	swap	r18
    af5c:	32 95       	swap	r19
    af5e:	30 7f       	andi	r19, 0xF0	; 240
    af60:	32 27       	eor	r19, r18
    af62:	20 7f       	andi	r18, 0xF0	; 240
    af64:	32 27       	eor	r19, r18
    af66:	82 0f       	add	r24, r18
    af68:	93 1f       	adc	r25, r19
    af6a:	0e 94 a8 54 	call	0xa950	; 0xa950 <Field2Buf>
    af6e:	67 cf       	rjmp	.-306    	; 0xae3e <MenuEscLeft+0x10>
			 (Type == FFloat) || (Type == EE_FFloat) || (Type == GFloat) || (Type == EE_GFloat) ) 
			 	Pos = CurrFieldSize-1;
			else Pos=Log10(prd(&Field->Max));

			if(Type==s_Byte || Type==s_EE_Byte || Type==s_Word || Type==s_EE_Word)
				Pos++;
    af70:	9f 5f       	subi	r25, 0xFF	; 255
    af72:	cc cf       	rjmp	.-104    	; 0xaf0c <MenuEscLeft+0xde>
			if(++CurrPos>Pos)
				CurrPos = NullPos;
			else{
				switch(Type){
    af74:	1d 31       	cpi	r17, 0x1D	; 29
    af76:	40 f1       	brcs	.+80     	; 0xafc8 <MenuEscLeft+0x19a>
    af78:	02 30       	cpi	r16, 0x02	; 2
    af7a:	08 f0       	brcs	.+2      	; 0xaf7e <MenuEscLeft+0x150>
    af7c:	60 cf       	rjmp	.-320    	; 0xae3e <MenuEscLeft+0x10>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    af7e:	fe 01       	movw	r30, r28
    af80:	33 96       	adiw	r30, 0x03	; 3
    af82:	85 91       	lpm	r24, Z+
    af84:	95 91       	lpm	r25, Z+
    af86:	a5 91       	lpm	r26, Z+
    af88:	b4 91       	lpm	r27, Z+
				case Text: case EE_Text:
					if( (prd(&Field->Min) == DIGIT) && (prd(&Field->Max) == DIGIT) )
    af8a:	00 97       	sbiw	r24, 0x00	; 0
    af8c:	a1 05       	cpc	r26, r1
    af8e:	b1 05       	cpc	r27, r1
    af90:	59 f4       	brne	.+22     	; 0xafa8 <MenuEscLeft+0x17a>
    af92:	fe 01       	movw	r30, r28
    af94:	37 96       	adiw	r30, 0x07	; 7
    af96:	85 91       	lpm	r24, Z+
    af98:	95 91       	lpm	r25, Z+
    af9a:	a5 91       	lpm	r26, Z+
    af9c:	b4 91       	lpm	r27, Z+
    af9e:	00 97       	sbiw	r24, 0x00	; 0
    afa0:	a1 05       	cpc	r26, r1
    afa2:	b1 05       	cpc	r27, r1
    afa4:	09 f4       	brne	.+2      	; 0xafa8 <MenuEscLeft+0x17a>
    afa6:	6f c0       	rjmp	.+222    	; 0xb086 <MenuEscLeft+0x258>
						MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[CurrFieldSize - 1 - CurrPos]);
					else MultiSymbol = GetMultiSymbol(Symbols_P, BufStr[CurrFieldSize - 1 - CurrPos]);
    afa8:	e0 91 c0 07 	lds	r30, 0x07C0
    afac:	f0 e0       	ldi	r31, 0x00	; 0
    afae:	31 97       	sbiw	r30, 0x01	; 1
    afb0:	e2 1b       	sub	r30, r18
    afb2:	f1 09       	sbc	r31, r1
    afb4:	ed 53       	subi	r30, 0x3D	; 61
    afb6:	fa 4f       	sbci	r31, 0xFA	; 250
    afb8:	85 e0       	ldi	r24, 0x05	; 5
    afba:	96 e0       	ldi	r25, 0x06	; 6
    afbc:	60 81       	ld	r22, Z
    afbe:	0e 94 77 44 	call	0x88ee	; 0x88ee <GetMultiSymbol>
    afc2:	80 93 f4 04 	sts	0x04F4, r24
    afc6:	3b cf       	rjmp	.-394    	; 0xae3e <MenuEscLeft+0x10>
			if(Type==s_Byte || Type==s_EE_Byte || Type==s_Word || Type==s_EE_Word)
				Pos++;
			if(++CurrPos>Pos)
				CurrPos = NullPos;
			else{
				switch(Type){
    afc8:	19 31       	cpi	r17, 0x19	; 25
    afca:	20 f4       	brcc	.+8      	; 0xafd4 <MenuEscLeft+0x1a6>
    afcc:	10 51       	subi	r17, 0x10	; 16
    afce:	16 30       	cpi	r17, 0x06	; 6
    afd0:	08 f0       	brcs	.+2      	; 0xafd4 <MenuEscLeft+0x1a6>
    afd2:	35 cf       	rjmp	.-406    	; 0xae3e <MenuEscLeft+0x10>
						MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[CurrFieldSize - 1 - CurrPos]);
					else MultiSymbol = GetMultiSymbol(Symbols_P, BufStr[CurrFieldSize - 1 - CurrPos]);
					break;
				case Longint: case z_Longint: case EE_Longint: case z_EE_Longint: case s_Longint: case s_EE_Longint:
				case FFloat: case EE_FFloat: case GFloat: case EE_GFloat:
					MultiSymbol = GetMultiSymbol(Digits_P, BufStr[CurrFieldSize - 1 - CurrPos]);
    afd4:	e0 91 c0 07 	lds	r30, 0x07C0
    afd8:	f0 e0       	ldi	r31, 0x00	; 0
    afda:	31 97       	sbiw	r30, 0x01	; 1
    afdc:	e2 1b       	sub	r30, r18
    afde:	f1 09       	sbc	r31, r1
    afe0:	ed 53       	subi	r30, 0x3D	; 61
    afe2:	fa 4f       	sbci	r31, 0xFA	; 250
    afe4:	8e ea       	ldi	r24, 0xAE	; 174
    afe6:	96 e0       	ldi	r25, 0x06	; 6
    afe8:	60 81       	ld	r22, Z
    afea:	0e 94 77 44 	call	0x88ee	; 0x88ee <GetMultiSymbol>
    afee:	80 93 f4 04 	sts	0x04F4, r24
    aff2:	25 cf       	rjmp	.-438    	; 0xae3e <MenuEscLeft+0x10>
			Field2Buf(GetField);
		return;
	}

// 3) Go to menu
	EventFunc(&CurrPage->Exit);
    aff4:	80 91 d4 02 	lds	r24, 0x02D4
    aff8:	90 91 d5 02 	lds	r25, 0x02D5
    affc:	0a 96       	adiw	r24, 0x0a	; 10
    affe:	0e 94 b0 3f 	call	0x7f60	; 0x7f60 <EventFunc>
	if(MenuDepth) {
    b002:	e0 91 ba 07 	lds	r30, 0x07BA
    b006:	ee 23       	and	r30, r30
    b008:	21 f1       	breq	.+72     	; 0xb052 <MenuEscLeft+0x224>
		CurrPage=MenuStack[--MenuDepth].Page;
    b00a:	e1 50       	subi	r30, 0x01	; 1
    b00c:	e0 93 ba 07 	sts	0x07BA, r30
    b010:	f0 e0       	ldi	r31, 0x00	; 0
    b012:	ee 0f       	add	r30, r30
    b014:	ff 1f       	adc	r31, r31
    b016:	ee 0f       	add	r30, r30
    b018:	ff 1f       	adc	r31, r31
    b01a:	df 01       	movw	r26, r30
    b01c:	a7 51       	subi	r26, 0x17	; 23
    b01e:	b7 4f       	sbci	r27, 0xF7	; 247
    b020:	9c 91       	ld	r25, X
    b022:	11 96       	adiw	r26, 0x01	; 1
    b024:	2c 91       	ld	r18, X
    b026:	11 97       	sbiw	r26, 0x01	; 1
    b028:	90 93 d4 02 	sts	0x02D4, r25
    b02c:	20 93 d5 02 	sts	0x02D5, r18
		CurrLine=MenuStack[MenuDepth].Line;
    b030:	13 96       	adiw	r26, 0x03	; 3
    b032:	8c 91       	ld	r24, X
    b034:	80 93 ca 07 	sts	0x07CA, r24
		CurrLCD=MenuStack[MenuDepth].LCD;
    b038:	e5 51       	subi	r30, 0x15	; 21
    b03a:	f7 4f       	sbci	r31, 0xF7	; 247
    b03c:	80 81       	ld	r24, Z
    b03e:	80 93 e8 08 	sts	0x08E8, r24
    b042:	e9 2f       	mov	r30, r25
    b044:	f2 2f       	mov	r31, r18
    b046:	9f 01       	movw	r18, r30
		}
		else
			CurrPage=prp(&CurrPage->OutPage);
		CurrLine=CurrLCD=GetFix();
	}
	EventFunc(&CurrPage->Load);
    b048:	c9 01       	movw	r24, r18
    b04a:	06 96       	adiw	r24, 0x06	; 6
    b04c:	0e 94 b0 3f 	call	0x7f60	; 0x7f60 <EventFunc>
    b050:	f6 ce       	rjmp	.-532    	; 0xae3e <MenuEscLeft+0x10>
		CurrPage=MenuStack[--MenuDepth].Page;
		CurrLine=MenuStack[MenuDepth].Line;
		CurrLCD=MenuStack[MenuDepth].LCD;
	}
	else {
		if(NextPage) {
    b052:	e0 91 d9 05 	lds	r30, 0x05D9
    b056:	f0 91 da 05 	lds	r31, 0x05DA
    b05a:	30 97       	sbiw	r30, 0x00	; 0
    b05c:	21 f1       	breq	.+72     	; 0xb0a6 <MenuEscLeft+0x278>
			CurrPage=NextPage;
    b05e:	f0 93 d5 02 	sts	0x02D5, r31
    b062:	e0 93 d4 02 	sts	0x02D4, r30
			NextPage=NULL;
    b066:	10 92 da 05 	sts	0x05DA, r1
    b06a:	10 92 d9 05 	sts	0x05D9, r1
    b06e:	9f 01       	movw	r18, r30

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    b070:	2d 5f       	subi	r18, 0xFD	; 253
    b072:	3f 4f       	sbci	r19, 0xFF	; 255
    b074:	f9 01       	movw	r30, r18
    b076:	84 91       	lpm	r24, Z+
    b078:	23 50       	subi	r18, 0x03	; 3
    b07a:	30 40       	sbci	r19, 0x00	; 0
		}
		else
			CurrPage=prp(&CurrPage->OutPage);
		CurrLine=CurrLCD=GetFix();
    b07c:	80 93 e8 08 	sts	0x08E8, r24
    b080:	80 93 ca 07 	sts	0x07CA, r24
    b084:	e1 cf       	rjmp	.-62     	; 0xb048 <MenuEscLeft+0x21a>
				CurrPos = NullPos;
			else{
				switch(Type){
				case Text: case EE_Text:
					if( (prd(&Field->Min) == DIGIT) && (prd(&Field->Max) == DIGIT) )
						MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[CurrFieldSize - 1 - CurrPos]);
    b086:	e0 91 c0 07 	lds	r30, 0x07C0
    b08a:	f0 e0       	ldi	r31, 0x00	; 0
    b08c:	31 97       	sbiw	r30, 0x01	; 1
    b08e:	e2 1b       	sub	r30, r18
    b090:	f1 09       	sbc	r31, r1
    b092:	ed 53       	subi	r30, 0x3D	; 61
    b094:	fa 4f       	sbci	r31, 0xFA	; 250
    b096:	83 ea       	ldi	r24, 0xA3	; 163
    b098:	96 e0       	ldi	r25, 0x06	; 6
    b09a:	60 81       	ld	r22, Z
    b09c:	0e 94 77 44 	call	0x88ee	; 0x88ee <GetMultiSymbol>
    b0a0:	80 93 f4 04 	sts	0x04F4, r24
    b0a4:	cc ce       	rjmp	.-616    	; 0xae3e <MenuEscLeft+0x10>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    b0a6:	80 91 d4 02 	lds	r24, 0x02D4
    b0aa:	90 91 d5 02 	lds	r25, 0x02D5
    b0ae:	04 96       	adiw	r24, 0x04	; 4
		if(NextPage) {
			CurrPage=NextPage;
			NextPage=NULL;
		}
		else
			CurrPage=prp(&CurrPage->OutPage);
    b0b0:	fc 01       	movw	r30, r24
    b0b2:	25 91       	lpm	r18, Z+
    b0b4:	34 91       	lpm	r19, Z+
    b0b6:	30 93 d5 02 	sts	0x02D5, r19
    b0ba:	20 93 d4 02 	sts	0x02D4, r18
    b0be:	d8 cf       	rjmp	.-80     	; 0xb070 <MenuEscLeft+0x242>

0000b0c0 <Buf2Field>:
// ~~~~~~~~~~~~~~~~~~~~~~~
//       
//     -
static void
Buf2Field(OutField *Field)
{
    b0c0:	3f 92       	push	r3
    b0c2:	4f 92       	push	r4
    b0c4:	5f 92       	push	r5
    b0c6:	6f 92       	push	r6
    b0c8:	7f 92       	push	r7
    b0ca:	8f 92       	push	r8
    b0cc:	9f 92       	push	r9
    b0ce:	af 92       	push	r10
    b0d0:	bf 92       	push	r11
    b0d2:	cf 92       	push	r12
    b0d4:	df 92       	push	r13
    b0d6:	ef 92       	push	r14
    b0d8:	ff 92       	push	r15
    b0da:	0f 93       	push	r16
    b0dc:	1f 93       	push	r17
    b0de:	df 93       	push	r29
    b0e0:	cf 93       	push	r28
    b0e2:	cd b7       	in	r28, 0x3d	; 61
    b0e4:	de b7       	in	r29, 0x3e	; 62
    b0e6:	6d 97       	sbiw	r28, 0x1d	; 29
    b0e8:	0f b6       	in	r0, 0x3f	; 63
    b0ea:	f8 94       	cli
    b0ec:	de bf       	out	0x3e, r29	; 62
    b0ee:	0f be       	out	0x3f, r0	; 63
    b0f0:	cd bf       	out	0x3d, r28	; 61
    b0f2:	6c 01       	movw	r12, r24
    b0f4:	fc 01       	movw	r30, r24
    b0f6:	31 96       	adiw	r30, 0x01	; 1
    b0f8:	45 90       	lpm	r4, Z+
    b0fa:	54 90       	lpm	r5, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    b0fc:	2f e0       	ldi	r18, 0x0F	; 15
    b0fe:	30 e0       	ldi	r19, 0x00	; 0
    b100:	c2 0e       	add	r12, r18
    b102:	d3 1e       	adc	r13, r19
    b104:	f6 01       	movw	r30, r12
    b106:	24 91       	lpm	r18, Z+
    b108:	81 ef       	ldi	r24, 0xF1	; 241
    b10a:	9f ef       	ldi	r25, 0xFF	; 255
    b10c:	c8 0e       	add	r12, r24
    b10e:	d9 1e       	adc	r13, r25
	void *Var = prp(&Field->Var);
	uint8_t BitN=prb(&Field->Prec), Mask=1<<BitN%8, *BitVar=(uint8_t*)Var+BitN/8;
    b110:	32 2f       	mov	r19, r18
    b112:	37 70       	andi	r19, 0x07	; 7
    b114:	81 e0       	ldi	r24, 0x01	; 1
    b116:	90 e0       	ldi	r25, 0x00	; 0
    b118:	38 2e       	mov	r3, r24
    b11a:	01 c0       	rjmp	.+2      	; 0xb11e <Buf2Field+0x5e>
    b11c:	33 0c       	add	r3, r3
    b11e:	3a 95       	dec	r19
    b120:	ea f7       	brpl	.-6      	; 0xb11c <Buf2Field+0x5c>
    b122:	26 95       	lsr	r18
    b124:	26 95       	lsr	r18
    b126:	26 95       	lsr	r18
    b128:	32 01       	movw	r6, r4
    b12a:	62 0e       	add	r6, r18
    b12c:	71 1c       	adc	r7, r1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    b12e:	f6 01       	movw	r30, r12
    b130:	33 96       	adiw	r30, 0x03	; 3
    b132:	85 90       	lpm	r8, Z+
    b134:	95 90       	lpm	r9, Z+
    b136:	a5 90       	lpm	r10, Z+
    b138:	b4 90       	lpm	r11, Z+
	uint8_t EE_BitVar;
	uint32_t Min=prd(&Field->Min), Max=prd(&Field->Max);

	uint32_t Temp=0;
    b13a:	f6 01       	movw	r30, r12
    b13c:	37 96       	adiw	r30, 0x07	; 7
    b13e:	e5 90       	lpm	r14, Z+
    b140:	f5 90       	lpm	r15, Z+
    b142:	05 91       	lpm	r16, Z+
    b144:	14 91       	lpm	r17, Z+
    b146:	19 82       	std	Y+1, r1	; 0x01
    b148:	1a 82       	std	Y+2, r1	; 0x02
    b14a:	1b 82       	std	Y+3, r1	; 0x03
    b14c:	1c 82       	std	Y+4, r1	; 0x04
	float fTemp=0;
    b14e:	80 e0       	ldi	r24, 0x00	; 0
    b150:	90 e0       	ldi	r25, 0x00	; 0
    b152:	a0 e0       	ldi	r26, 0x00	; 0
    b154:	b0 e0       	ldi	r27, 0x00	; 0
    b156:	8d 83       	std	Y+5, r24	; 0x05
    b158:	9e 83       	std	Y+6, r25	; 0x06
    b15a:	af 83       	std	Y+7, r26	; 0x07
    b15c:	b8 87       	std	Y+8, r27	; 0x08

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    b15e:	f6 01       	movw	r30, r12
    b160:	84 91       	lpm	r24, Z+

	switch(prb(&Field->Type)) {
    b162:	e8 2f       	mov	r30, r24
    b164:	f0 e0       	ldi	r31, 0x00	; 0
    b166:	e3 32       	cpi	r30, 0x23	; 35
    b168:	f1 05       	cpc	r31, r1
    b16a:	08 f0       	brcs	.+2      	; 0xb16e <Buf2Field+0xae>
    b16c:	3f c0       	rjmp	.+126    	; 0xb1ec <Buf2Field+0x12c>
    b16e:	ed 56       	subi	r30, 0x6D	; 109
    b170:	ff 4f       	sbci	r31, 0xFF	; 255
    b172:	ee 0f       	add	r30, r30
    b174:	ff 1f       	adc	r31, r31
    b176:	05 90       	lpm	r0, Z+
    b178:	f4 91       	lpm	r31, Z+
    b17a:	e0 2d       	mov	r30, r0
    b17c:	19 94       	eijmp
		PresicionHanler(Field);
		sscanf(BufStr,"%lud", (uint32_t*)&Temp);
		SetField32(Temp, uint32_t);
		break;
	case EE_Longint: case z_EE_Longint:
		PresicionHanler(Field);
    b17e:	c6 01       	movw	r24, r12
    b180:	0e 94 3d 44 	call	0x887a	; 0x887a <PresicionHanler>
		if(sscanf(BufStr,"%lud", (uint32_t*)&Temp) == 1){
    b184:	00 d0       	rcall	.+0      	; 0xb186 <Buf2Field+0xc6>
    b186:	00 d0       	rcall	.+0      	; 0xb188 <Buf2Field+0xc8>
    b188:	ed b7       	in	r30, 0x3d	; 61
    b18a:	fe b7       	in	r31, 0x3e	; 62
    b18c:	31 96       	adiw	r30, 0x01	; 1
    b18e:	83 ec       	ldi	r24, 0xC3	; 195
    b190:	95 e0       	ldi	r25, 0x05	; 5
    b192:	ad b7       	in	r26, 0x3d	; 61
    b194:	be b7       	in	r27, 0x3e	; 62
    b196:	12 96       	adiw	r26, 0x02	; 2
    b198:	9c 93       	st	X, r25
    b19a:	8e 93       	st	-X, r24
    b19c:	11 97       	sbiw	r26, 0x01	; 1
    b19e:	8f e9       	ldi	r24, 0x9F	; 159
    b1a0:	92 e0       	ldi	r25, 0x02	; 2
    b1a2:	93 83       	std	Z+3, r25	; 0x03
    b1a4:	82 83       	std	Z+2, r24	; 0x02
    b1a6:	ce 01       	movw	r24, r28
    b1a8:	01 96       	adiw	r24, 0x01	; 1
    b1aa:	95 83       	std	Z+5, r25	; 0x05
    b1ac:	84 83       	std	Z+4, r24	; 0x04
    b1ae:	0e 94 84 85 	call	0x10b08	; 0x10b08 <sscanf>
    b1b2:	ed b7       	in	r30, 0x3d	; 61
    b1b4:	fe b7       	in	r31, 0x3e	; 62
    b1b6:	36 96       	adiw	r30, 0x06	; 6
    b1b8:	0f b6       	in	r0, 0x3f	; 63
    b1ba:	f8 94       	cli
    b1bc:	fe bf       	out	0x3e, r31	; 62
    b1be:	0f be       	out	0x3f, r0	; 63
    b1c0:	ed bf       	out	0x3d, r30	; 61
    b1c2:	01 97       	sbiw	r24, 0x01	; 1
    b1c4:	99 f4       	brne	.+38     	; 0xb1ec <Buf2Field+0x12c>
			SetEEField32(Temp, uint32_t, uint32_t, d);
    b1c6:	49 81       	ldd	r20, Y+1	; 0x01
    b1c8:	5a 81       	ldd	r21, Y+2	; 0x02
    b1ca:	6b 81       	ldd	r22, Y+3	; 0x03
    b1cc:	7c 81       	ldd	r23, Y+4	; 0x04
    b1ce:	e4 16       	cp	r14, r20
    b1d0:	f5 06       	cpc	r15, r21
    b1d2:	06 07       	cpc	r16, r22
    b1d4:	17 07       	cpc	r17, r23
    b1d6:	08 f4       	brcc	.+2      	; 0xb1da <Buf2Field+0x11a>
    b1d8:	cc c2       	rjmp	.+1432   	; 0xb772 <Buf2Field+0x6b2>
    b1da:	48 15       	cp	r20, r8
    b1dc:	59 05       	cpc	r21, r9
    b1de:	6a 05       	cpc	r22, r10
    b1e0:	7b 05       	cpc	r23, r11
    b1e2:	08 f4       	brcc	.+2      	; 0xb1e6 <Buf2Field+0x126>
    b1e4:	f8 c1       	rjmp	.+1008   	; 0xb5d6 <Buf2Field+0x516>
		SetField32(Temp, int32_t);
		break;
	case s_EE_Longint:
		PresicionHanler(Field);
		if(sscanf(BufStr,"%ld", (int32_t*)&Temp) == 1){
			SetEEField32(Temp, int32_t, uint32_t, d);
    b1e6:	c2 01       	movw	r24, r4
    b1e8:	0e 94 43 51 	call	0xa286	; 0xa286 <ewd>
			ewbl(TempStr, Var, Width);
		}
		break;

	}
	EventFunc(&Field->Act);
    b1ec:	c6 01       	movw	r24, r12
    b1ee:	0b 96       	adiw	r24, 0x0b	; 11
    b1f0:	0e 94 b0 3f 	call	0x7f60	; 0x7f60 <EventFunc>
}
    b1f4:	6d 96       	adiw	r28, 0x1d	; 29
    b1f6:	0f b6       	in	r0, 0x3f	; 63
    b1f8:	f8 94       	cli
    b1fa:	de bf       	out	0x3e, r29	; 62
    b1fc:	0f be       	out	0x3f, r0	; 63
    b1fe:	cd bf       	out	0x3d, r28	; 61
    b200:	cf 91       	pop	r28
    b202:	df 91       	pop	r29
    b204:	1f 91       	pop	r17
    b206:	0f 91       	pop	r16
    b208:	ff 90       	pop	r15
    b20a:	ef 90       	pop	r14
    b20c:	df 90       	pop	r13
    b20e:	cf 90       	pop	r12
    b210:	bf 90       	pop	r11
    b212:	af 90       	pop	r10
    b214:	9f 90       	pop	r9
    b216:	8f 90       	pop	r8
    b218:	7f 90       	pop	r7
    b21a:	6f 90       	pop	r6
    b21c:	5f 90       	pop	r5
    b21e:	4f 90       	pop	r4
    b220:	3f 90       	pop	r3
    b222:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    b224:	8e 01       	movw	r16, r28
    b226:	07 5f       	subi	r16, 0xF7	; 247
    b228:	1f 4f       	sbci	r17, 0xFF	; 255
    b22a:	c8 01       	movw	r24, r16
    b22c:	b2 01       	movw	r22, r4
    b22e:	45 e1       	ldi	r20, 0x15	; 21
    b230:	50 e0       	ldi	r21, 0x00	; 0
    b232:	0e 94 40 87 	call	0x10e80	; 0x10e80 <__eerd_block_m2560>
		}
		break;
	case EE_Text:{
			char TempStr[LCDXSz+1];
			erbl(TempStr, Var, LCDXSz+1);
			uint8_t Width = strlen(TempStr);
    b236:	d8 01       	movw	r26, r16
    b238:	0d 90       	ld	r0, X+
    b23a:	00 20       	and	r0, r0
    b23c:	e9 f7       	brne	.-6      	; 0xb238 <Buf2Field+0x178>
    b23e:	7d 01       	movw	r14, r26
    b240:	08 94       	sec
    b242:	e1 08       	sbc	r14, r1
    b244:	f1 08       	sbc	r15, r1
    b246:	e0 1a       	sub	r14, r16
    b248:	f1 0a       	sbc	r15, r17
			memcpy(TempStr, BufStr, Width);
    b24a:	23 ec       	ldi	r18, 0xC3	; 195
    b24c:	35 e0       	ldi	r19, 0x05	; 5
    b24e:	c8 01       	movw	r24, r16
    b250:	b9 01       	movw	r22, r18
    b252:	4e 2d       	mov	r20, r14
    b254:	50 e0       	ldi	r21, 0x00	; 0
    b256:	0e 94 72 84 	call	0x108e4	; 0x108e4 <memcpy>
			ewbl(TempStr, Var, Width);
    b25a:	c8 01       	movw	r24, r16
    b25c:	b2 01       	movw	r22, r4
    b25e:	4e 2d       	mov	r20, r14
    b260:	50 e0       	ldi	r21, 0x00	; 0
    b262:	0e 94 3e 51 	call	0xa27c	; 0xa27c <ewbl>
    b266:	c2 cf       	rjmp	.-124    	; 0xb1ec <Buf2Field+0x12c>
	uint32_t Temp=0;
	float fTemp=0;

	switch(prb(&Field->Type)) {
	case Byte: case z_Byte: case Enum:
		SetField(F_Buf, uint8_t);
    b268:	20 91 f7 04 	lds	r18, 0x04F7
    b26c:	30 91 f8 04 	lds	r19, 0x04F8
    b270:	40 91 f9 04 	lds	r20, 0x04F9
    b274:	50 91 fa 04 	lds	r21, 0x04FA
    b278:	8e 2d       	mov	r24, r14
    b27a:	90 e0       	ldi	r25, 0x00	; 0
    b27c:	a0 e0       	ldi	r26, 0x00	; 0
    b27e:	b0 e0       	ldi	r27, 0x00	; 0
    b280:	82 17       	cp	r24, r18
    b282:	93 07       	cpc	r25, r19
    b284:	a4 07       	cpc	r26, r20
    b286:	b5 07       	cpc	r27, r21
    b288:	08 f4       	brcc	.+2      	; 0xb28c <Buf2Field+0x1cc>
    b28a:	50 c2       	rjmp	.+1184   	; 0xb72c <Buf2Field+0x66c>
    b28c:	88 2d       	mov	r24, r8
    b28e:	90 e0       	ldi	r25, 0x00	; 0
    b290:	a0 e0       	ldi	r26, 0x00	; 0
    b292:	b0 e0       	ldi	r27, 0x00	; 0
    b294:	28 17       	cp	r18, r24
    b296:	39 07       	cpc	r19, r25
    b298:	4a 07       	cpc	r20, r26
    b29a:	5b 07       	cpc	r21, r27
    b29c:	08 f0       	brcs	.+2      	; 0xb2a0 <Buf2Field+0x1e0>
    b29e:	66 c2       	rjmp	.+1228   	; 0xb76c <Buf2Field+0x6ac>
    b2a0:	f2 01       	movw	r30, r4
    b2a2:	80 82       	st	Z, r8
    b2a4:	a3 cf       	rjmp	.-186    	; 0xb1ec <Buf2Field+0x12c>
		break;
	case s_Byte:
		SetField(sF_Buf, int8_t);
		break;
	case EE_Byte: case z_EE_Byte: case EE_Enum:
		SetEEField(F_Buf, uint8_t, uint8_t, b);
    b2a6:	20 91 f7 04 	lds	r18, 0x04F7
    b2aa:	30 91 f8 04 	lds	r19, 0x04F8
    b2ae:	40 91 f9 04 	lds	r20, 0x04F9
    b2b2:	50 91 fa 04 	lds	r21, 0x04FA
    b2b6:	8e 2d       	mov	r24, r14
    b2b8:	90 e0       	ldi	r25, 0x00	; 0
    b2ba:	a0 e0       	ldi	r26, 0x00	; 0
    b2bc:	b0 e0       	ldi	r27, 0x00	; 0
    b2be:	82 17       	cp	r24, r18
    b2c0:	93 07       	cpc	r25, r19
    b2c2:	a4 07       	cpc	r26, r20
    b2c4:	b5 07       	cpc	r27, r21
    b2c6:	08 f4       	brcc	.+2      	; 0xb2ca <Buf2Field+0x20a>
    b2c8:	41 c2       	rjmp	.+1154   	; 0xb74c <Buf2Field+0x68c>
    b2ca:	88 2d       	mov	r24, r8
    b2cc:	90 e0       	ldi	r25, 0x00	; 0
    b2ce:	a0 e0       	ldi	r26, 0x00	; 0
    b2d0:	b0 e0       	ldi	r27, 0x00	; 0
    b2d2:	28 17       	cp	r18, r24
    b2d4:	39 07       	cpc	r19, r25
    b2d6:	4a 07       	cpc	r20, r26
    b2d8:	5b 07       	cpc	r21, r27
    b2da:	08 f4       	brcc	.+2      	; 0xb2de <Buf2Field+0x21e>
    b2dc:	48 c0       	rjmp	.+144    	; 0xb36e <Buf2Field+0x2ae>
		break;
	case s_EE_Byte:
		SetEEField(sF_Buf, int8_t, uint8_t, b);
    b2de:	c2 01       	movw	r24, r4
    b2e0:	62 2f       	mov	r22, r18
    b2e2:	0e 94 c9 4f 	call	0x9f92	; 0x9f92 <ewb>
    b2e6:	82 cf       	rjmp	.-252    	; 0xb1ec <Buf2Field+0x12c>
	switch(prb(&Field->Type)) {
	case Byte: case z_Byte: case Enum:
		SetField(F_Buf, uint8_t);
		break;
	case s_Byte:
		SetField(sF_Buf, int8_t);
    b2e8:	20 91 fb 04 	lds	r18, 0x04FB
    b2ec:	30 91 fc 04 	lds	r19, 0x04FC
    b2f0:	40 91 fd 04 	lds	r20, 0x04FD
    b2f4:	50 91 fe 04 	lds	r21, 0x04FE
    b2f8:	8e 2d       	mov	r24, r14
    b2fa:	99 27       	eor	r25, r25
    b2fc:	87 fd       	sbrc	r24, 7
    b2fe:	90 95       	com	r25
    b300:	a9 2f       	mov	r26, r25
    b302:	b9 2f       	mov	r27, r25
    b304:	82 17       	cp	r24, r18
    b306:	93 07       	cpc	r25, r19
    b308:	a4 07       	cpc	r26, r20
    b30a:	b5 07       	cpc	r27, r21
    b30c:	0c f4       	brge	.+2      	; 0xb310 <Buf2Field+0x250>
    b30e:	08 c2       	rjmp	.+1040   	; 0xb720 <Buf2Field+0x660>
    b310:	88 2d       	mov	r24, r8
    b312:	99 27       	eor	r25, r25
    b314:	87 fd       	sbrc	r24, 7
    b316:	90 95       	com	r25
    b318:	a9 2f       	mov	r26, r25
    b31a:	b9 2f       	mov	r27, r25
    b31c:	28 17       	cp	r18, r24
    b31e:	39 07       	cpc	r19, r25
    b320:	4a 07       	cpc	r20, r26
    b322:	5b 07       	cpc	r21, r27
    b324:	0c f0       	brlt	.+2      	; 0xb328 <Buf2Field+0x268>
    b326:	17 c2       	rjmp	.+1070   	; 0xb756 <Buf2Field+0x696>
    b328:	d2 01       	movw	r26, r4
    b32a:	8c 92       	st	X, r8
    b32c:	5f cf       	rjmp	.-322    	; 0xb1ec <Buf2Field+0x12c>
		break;
	case EE_Byte: case z_EE_Byte: case EE_Enum:
		SetEEField(F_Buf, uint8_t, uint8_t, b);
		break;
	case s_EE_Byte:
		SetEEField(sF_Buf, int8_t, uint8_t, b);
    b32e:	20 91 fb 04 	lds	r18, 0x04FB
    b332:	30 91 fc 04 	lds	r19, 0x04FC
    b336:	40 91 fd 04 	lds	r20, 0x04FD
    b33a:	50 91 fe 04 	lds	r21, 0x04FE
    b33e:	8e 2d       	mov	r24, r14
    b340:	99 27       	eor	r25, r25
    b342:	87 fd       	sbrc	r24, 7
    b344:	90 95       	com	r25
    b346:	a9 2f       	mov	r26, r25
    b348:	b9 2f       	mov	r27, r25
    b34a:	82 17       	cp	r24, r18
    b34c:	93 07       	cpc	r25, r19
    b34e:	a4 07       	cpc	r26, r20
    b350:	b5 07       	cpc	r27, r21
    b352:	0c f4       	brge	.+2      	; 0xb356 <Buf2Field+0x296>
    b354:	fb c1       	rjmp	.+1014   	; 0xb74c <Buf2Field+0x68c>
    b356:	88 2d       	mov	r24, r8
    b358:	99 27       	eor	r25, r25
    b35a:	87 fd       	sbrc	r24, 7
    b35c:	90 95       	com	r25
    b35e:	a9 2f       	mov	r26, r25
    b360:	b9 2f       	mov	r27, r25
    b362:	28 17       	cp	r18, r24
    b364:	39 07       	cpc	r19, r25
    b366:	4a 07       	cpc	r20, r26
    b368:	5b 07       	cpc	r21, r27
    b36a:	0c f0       	brlt	.+2      	; 0xb36e <Buf2Field+0x2ae>
    b36c:	b8 cf       	rjmp	.-144    	; 0xb2de <Buf2Field+0x21e>
    b36e:	c2 01       	movw	r24, r4
    b370:	68 2d       	mov	r22, r8
    b372:	0e 94 c9 4f 	call	0x9f92	; 0x9f92 <ewb>
    b376:	3a cf       	rjmp	.-396    	; 0xb1ec <Buf2Field+0x12c>
		break;
	case Word: case z_Word:
		SetField(F_Buf, uint16_t);
    b378:	20 91 f7 04 	lds	r18, 0x04F7
    b37c:	30 91 f8 04 	lds	r19, 0x04F8
    b380:	40 91 f9 04 	lds	r20, 0x04F9
    b384:	50 91 fa 04 	lds	r21, 0x04FA
    b388:	c7 01       	movw	r24, r14
    b38a:	a0 e0       	ldi	r26, 0x00	; 0
    b38c:	b0 e0       	ldi	r27, 0x00	; 0
    b38e:	82 17       	cp	r24, r18
    b390:	93 07       	cpc	r25, r19
    b392:	a4 07       	cpc	r26, r20
    b394:	b5 07       	cpc	r27, r21
    b396:	08 f4       	brcc	.+2      	; 0xb39a <Buf2Field+0x2da>
    b398:	cc c1       	rjmp	.+920    	; 0xb732 <Buf2Field+0x672>
    b39a:	c4 01       	movw	r24, r8
    b39c:	a0 e0       	ldi	r26, 0x00	; 0
    b39e:	b0 e0       	ldi	r27, 0x00	; 0
    b3a0:	28 17       	cp	r18, r24
    b3a2:	39 07       	cpc	r19, r25
    b3a4:	4a 07       	cpc	r20, r26
    b3a6:	5b 07       	cpc	r21, r27
    b3a8:	08 f0       	brcs	.+2      	; 0xb3ac <Buf2Field+0x2ec>
    b3aa:	d8 c1       	rjmp	.+944    	; 0xb75c <Buf2Field+0x69c>
    b3ac:	f2 01       	movw	r30, r4
    b3ae:	91 82       	std	Z+1, r9	; 0x01
    b3b0:	80 82       	st	Z, r8
    b3b2:	1c cf       	rjmp	.-456    	; 0xb1ec <Buf2Field+0x12c>
		break;
	case EE_Word: case z_EE_Word:
		SetEEField(F_Buf, uint16_t, uint16_t, w);
    b3b4:	20 91 f7 04 	lds	r18, 0x04F7
    b3b8:	30 91 f8 04 	lds	r19, 0x04F8
    b3bc:	40 91 f9 04 	lds	r20, 0x04F9
    b3c0:	50 91 fa 04 	lds	r21, 0x04FA
    b3c4:	c7 01       	movw	r24, r14
    b3c6:	a0 e0       	ldi	r26, 0x00	; 0
    b3c8:	b0 e0       	ldi	r27, 0x00	; 0
    b3ca:	82 17       	cp	r24, r18
    b3cc:	93 07       	cpc	r25, r19
    b3ce:	a4 07       	cpc	r26, r20
    b3d0:	b5 07       	cpc	r27, r21
    b3d2:	08 f4       	brcc	.+2      	; 0xb3d6 <Buf2Field+0x316>
    b3d4:	b6 c1       	rjmp	.+876    	; 0xb742 <Buf2Field+0x682>
    b3d6:	c4 01       	movw	r24, r8
    b3d8:	a0 e0       	ldi	r26, 0x00	; 0
    b3da:	b0 e0       	ldi	r27, 0x00	; 0
    b3dc:	28 17       	cp	r18, r24
    b3de:	39 07       	cpc	r19, r25
    b3e0:	4a 07       	cpc	r20, r26
    b3e2:	5b 07       	cpc	r21, r27
    b3e4:	08 f4       	brcc	.+2      	; 0xb3e8 <Buf2Field+0x328>
    b3e6:	45 c0       	rjmp	.+138    	; 0xb472 <Buf2Field+0x3b2>
		break;
	case s_Word:
		SetField(sF_Buf, int16_t);
		break;
	case s_EE_Word:
		SetEEField(sF_Buf, int16_t, uint16_t, w);
    b3e8:	c2 01       	movw	r24, r4
    b3ea:	b9 01       	movw	r22, r18
    b3ec:	0e 94 0c 50 	call	0xa018	; 0xa018 <eww>
    b3f0:	fd ce       	rjmp	.-518    	; 0xb1ec <Buf2Field+0x12c>
		break;
	case EE_Word: case z_EE_Word:
		SetEEField(F_Buf, uint16_t, uint16_t, w);
		break;
	case s_Word:
		SetField(sF_Buf, int16_t);
    b3f2:	20 91 fb 04 	lds	r18, 0x04FB
    b3f6:	30 91 fc 04 	lds	r19, 0x04FC
    b3fa:	40 91 fd 04 	lds	r20, 0x04FD
    b3fe:	50 91 fe 04 	lds	r21, 0x04FE
    b402:	c7 01       	movw	r24, r14
    b404:	aa 27       	eor	r26, r26
    b406:	97 fd       	sbrc	r25, 7
    b408:	a0 95       	com	r26
    b40a:	ba 2f       	mov	r27, r26
    b40c:	82 17       	cp	r24, r18
    b40e:	93 07       	cpc	r25, r19
    b410:	a4 07       	cpc	r26, r20
    b412:	b5 07       	cpc	r27, r21
    b414:	0c f4       	brge	.+2      	; 0xb418 <Buf2Field+0x358>
    b416:	91 c1       	rjmp	.+802    	; 0xb73a <Buf2Field+0x67a>
    b418:	c4 01       	movw	r24, r8
    b41a:	aa 27       	eor	r26, r26
    b41c:	97 fd       	sbrc	r25, 7
    b41e:	a0 95       	com	r26
    b420:	ba 2f       	mov	r27, r26
    b422:	28 17       	cp	r18, r24
    b424:	39 07       	cpc	r19, r25
    b426:	4a 07       	cpc	r20, r26
    b428:	5b 07       	cpc	r21, r27
    b42a:	0c f0       	brlt	.+2      	; 0xb42e <Buf2Field+0x36e>
    b42c:	9b c1       	rjmp	.+822    	; 0xb764 <Buf2Field+0x6a4>
    b42e:	d2 01       	movw	r26, r4
    b430:	8d 92       	st	X+, r8
    b432:	9c 92       	st	X, r9
    b434:	db ce       	rjmp	.-586    	; 0xb1ec <Buf2Field+0x12c>
		break;
	case s_EE_Word:
		SetEEField(sF_Buf, int16_t, uint16_t, w);
    b436:	20 91 fb 04 	lds	r18, 0x04FB
    b43a:	30 91 fc 04 	lds	r19, 0x04FC
    b43e:	40 91 fd 04 	lds	r20, 0x04FD
    b442:	50 91 fe 04 	lds	r21, 0x04FE
    b446:	c7 01       	movw	r24, r14
    b448:	aa 27       	eor	r26, r26
    b44a:	97 fd       	sbrc	r25, 7
    b44c:	a0 95       	com	r26
    b44e:	ba 2f       	mov	r27, r26
    b450:	82 17       	cp	r24, r18
    b452:	93 07       	cpc	r25, r19
    b454:	a4 07       	cpc	r26, r20
    b456:	b5 07       	cpc	r27, r21
    b458:	0c f4       	brge	.+2      	; 0xb45c <Buf2Field+0x39c>
    b45a:	73 c1       	rjmp	.+742    	; 0xb742 <Buf2Field+0x682>
    b45c:	c4 01       	movw	r24, r8
    b45e:	aa 27       	eor	r26, r26
    b460:	97 fd       	sbrc	r25, 7
    b462:	a0 95       	com	r26
    b464:	ba 2f       	mov	r27, r26
    b466:	28 17       	cp	r18, r24
    b468:	39 07       	cpc	r19, r25
    b46a:	4a 07       	cpc	r20, r26
    b46c:	5b 07       	cpc	r21, r27
    b46e:	0c f0       	brlt	.+2      	; 0xb472 <Buf2Field+0x3b2>
    b470:	bb cf       	rjmp	.-138    	; 0xb3e8 <Buf2Field+0x328>
    b472:	c2 01       	movw	r24, r4
    b474:	b4 01       	movw	r22, r8
    b476:	0e 94 0c 50 	call	0xa018	; 0xa018 <eww>
    b47a:	b8 ce       	rjmp	.-656    	; 0xb1ec <Buf2Field+0x12c>
		break;
	case c_Word: case zc_Word:
		*(uint16_t*)Var = F_Buf;
    b47c:	80 91 f7 04 	lds	r24, 0x04F7
    b480:	90 91 f8 04 	lds	r25, 0x04F8
    b484:	d2 01       	movw	r26, r4
    b486:	8d 93       	st	X+, r24
    b488:	9c 93       	st	X, r25
    b48a:	b0 ce       	rjmp	.-672    	; 0xb1ec <Buf2Field+0x12c>
		break;


	case Longint: case z_Longint:
		//if(Limit_uByteVar(Temp)) sscanf(BufStr,"%ud", (unsigned short int*)&Temp);
		PresicionHanler(Field);
    b48c:	c6 01       	movw	r24, r12
    b48e:	0e 94 3d 44 	call	0x887a	; 0x887a <PresicionHanler>
		sscanf(BufStr,"%lud", (uint32_t*)&Temp);
    b492:	00 d0       	rcall	.+0      	; 0xb494 <Buf2Field+0x3d4>
    b494:	00 d0       	rcall	.+0      	; 0xb496 <Buf2Field+0x3d6>
    b496:	ed b7       	in	r30, 0x3d	; 61
    b498:	fe b7       	in	r31, 0x3e	; 62
    b49a:	31 96       	adiw	r30, 0x01	; 1
    b49c:	83 ec       	ldi	r24, 0xC3	; 195
    b49e:	95 e0       	ldi	r25, 0x05	; 5
    b4a0:	ad b7       	in	r26, 0x3d	; 61
    b4a2:	be b7       	in	r27, 0x3e	; 62
    b4a4:	12 96       	adiw	r26, 0x02	; 2
    b4a6:	9c 93       	st	X, r25
    b4a8:	8e 93       	st	-X, r24
    b4aa:	11 97       	sbiw	r26, 0x01	; 1
    b4ac:	8f e9       	ldi	r24, 0x9F	; 159
    b4ae:	92 e0       	ldi	r25, 0x02	; 2
    b4b0:	93 83       	std	Z+3, r25	; 0x03
    b4b2:	82 83       	std	Z+2, r24	; 0x02
    b4b4:	ce 01       	movw	r24, r28
    b4b6:	01 96       	adiw	r24, 0x01	; 1
    b4b8:	95 83       	std	Z+5, r25	; 0x05
    b4ba:	84 83       	std	Z+4, r24	; 0x04
    b4bc:	0e 94 84 85 	call	0x10b08	; 0x10b08 <sscanf>
		SetField32(Temp, uint32_t);
    b4c0:	89 81       	ldd	r24, Y+1	; 0x01
    b4c2:	9a 81       	ldd	r25, Y+2	; 0x02
    b4c4:	ab 81       	ldd	r26, Y+3	; 0x03
    b4c6:	bc 81       	ldd	r27, Y+4	; 0x04
    b4c8:	ed b7       	in	r30, 0x3d	; 61
    b4ca:	fe b7       	in	r31, 0x3e	; 62
    b4cc:	36 96       	adiw	r30, 0x06	; 6
    b4ce:	0f b6       	in	r0, 0x3f	; 63
    b4d0:	f8 94       	cli
    b4d2:	fe bf       	out	0x3e, r31	; 62
    b4d4:	0f be       	out	0x3f, r0	; 63
    b4d6:	ed bf       	out	0x3d, r30	; 61
    b4d8:	e8 16       	cp	r14, r24
    b4da:	f9 06       	cpc	r15, r25
    b4dc:	0a 07       	cpc	r16, r26
    b4de:	1b 07       	cpc	r17, r27
    b4e0:	08 f4       	brcc	.+2      	; 0xb4e4 <Buf2Field+0x424>
    b4e2:	17 c1       	rjmp	.+558    	; 0xb712 <Buf2Field+0x652>
    b4e4:	88 15       	cp	r24, r8
    b4e6:	99 05       	cpc	r25, r9
    b4e8:	aa 05       	cpc	r26, r10
    b4ea:	bb 05       	cpc	r27, r11
    b4ec:	b8 f1       	brcs	.+110    	; 0xb55c <Buf2Field+0x49c>
		break;
	case s_Longint:
		PresicionHanler(Field);
		//if(Limit_sByteVar(Temp)) sscanf(BufStr,"%hd", (short int*)&Temp);
		sscanf(BufStr,"%ld", (int32_t*)&Temp);
		SetField32(Temp, int32_t);
    b4ee:	f2 01       	movw	r30, r4
    b4f0:	80 83       	st	Z, r24
    b4f2:	91 83       	std	Z+1, r25	; 0x01
    b4f4:	a2 83       	std	Z+2, r26	; 0x02
    b4f6:	b3 83       	std	Z+3, r27	; 0x03
    b4f8:	79 ce       	rjmp	.-782    	; 0xb1ec <Buf2Field+0x12c>
		if(sscanf(BufStr,"%lud", (uint32_t*)&Temp) == 1){
			SetEEField32(Temp, uint32_t, uint32_t, d);
		}		
		break;
	case s_Longint:
		PresicionHanler(Field);
    b4fa:	c6 01       	movw	r24, r12
    b4fc:	0e 94 3d 44 	call	0x887a	; 0x887a <PresicionHanler>
		//if(Limit_sByteVar(Temp)) sscanf(BufStr,"%hd", (short int*)&Temp);
		sscanf(BufStr,"%ld", (int32_t*)&Temp);
    b500:	00 d0       	rcall	.+0      	; 0xb502 <Buf2Field+0x442>
    b502:	00 d0       	rcall	.+0      	; 0xb504 <Buf2Field+0x444>
    b504:	ed b7       	in	r30, 0x3d	; 61
    b506:	fe b7       	in	r31, 0x3e	; 62
    b508:	31 96       	adiw	r30, 0x01	; 1
    b50a:	83 ec       	ldi	r24, 0xC3	; 195
    b50c:	95 e0       	ldi	r25, 0x05	; 5
    b50e:	ad b7       	in	r26, 0x3d	; 61
    b510:	be b7       	in	r27, 0x3e	; 62
    b512:	12 96       	adiw	r26, 0x02	; 2
    b514:	9c 93       	st	X, r25
    b516:	8e 93       	st	-X, r24
    b518:	11 97       	sbiw	r26, 0x01	; 1
    b51a:	84 ea       	ldi	r24, 0xA4	; 164
    b51c:	92 e0       	ldi	r25, 0x02	; 2
    b51e:	93 83       	std	Z+3, r25	; 0x03
    b520:	82 83       	std	Z+2, r24	; 0x02
    b522:	ce 01       	movw	r24, r28
    b524:	01 96       	adiw	r24, 0x01	; 1
    b526:	95 83       	std	Z+5, r25	; 0x05
    b528:	84 83       	std	Z+4, r24	; 0x04
    b52a:	0e 94 84 85 	call	0x10b08	; 0x10b08 <sscanf>
		SetField32(Temp, int32_t);
    b52e:	89 81       	ldd	r24, Y+1	; 0x01
    b530:	9a 81       	ldd	r25, Y+2	; 0x02
    b532:	ab 81       	ldd	r26, Y+3	; 0x03
    b534:	bc 81       	ldd	r27, Y+4	; 0x04
    b536:	ed b7       	in	r30, 0x3d	; 61
    b538:	fe b7       	in	r31, 0x3e	; 62
    b53a:	36 96       	adiw	r30, 0x06	; 6
    b53c:	0f b6       	in	r0, 0x3f	; 63
    b53e:	f8 94       	cli
    b540:	fe bf       	out	0x3e, r31	; 62
    b542:	0f be       	out	0x3f, r0	; 63
    b544:	ed bf       	out	0x3d, r30	; 61
    b546:	e8 16       	cp	r14, r24
    b548:	f9 06       	cpc	r15, r25
    b54a:	0a 07       	cpc	r16, r26
    b54c:	1b 07       	cpc	r17, r27
    b54e:	0c f4       	brge	.+2      	; 0xb552 <Buf2Field+0x492>
    b550:	e0 c0       	rjmp	.+448    	; 0xb712 <Buf2Field+0x652>
    b552:	88 15       	cp	r24, r8
    b554:	99 05       	cpc	r25, r9
    b556:	aa 05       	cpc	r26, r10
    b558:	bb 05       	cpc	r27, r11
    b55a:	4c f6       	brge	.-110    	; 0xb4ee <Buf2Field+0x42e>
    b55c:	f2 01       	movw	r30, r4
    b55e:	80 82       	st	Z, r8
    b560:	91 82       	std	Z+1, r9	; 0x01
    b562:	a2 82       	std	Z+2, r10	; 0x02
    b564:	b3 82       	std	Z+3, r11	; 0x03
    b566:	42 ce       	rjmp	.-892    	; 0xb1ec <Buf2Field+0x12c>
		break;
	case s_EE_Longint:
		PresicionHanler(Field);
    b568:	c6 01       	movw	r24, r12
    b56a:	0e 94 3d 44 	call	0x887a	; 0x887a <PresicionHanler>
		if(sscanf(BufStr,"%ld", (int32_t*)&Temp) == 1){
    b56e:	00 d0       	rcall	.+0      	; 0xb570 <Buf2Field+0x4b0>
    b570:	00 d0       	rcall	.+0      	; 0xb572 <Buf2Field+0x4b2>
    b572:	ed b7       	in	r30, 0x3d	; 61
    b574:	fe b7       	in	r31, 0x3e	; 62
    b576:	31 96       	adiw	r30, 0x01	; 1
    b578:	83 ec       	ldi	r24, 0xC3	; 195
    b57a:	95 e0       	ldi	r25, 0x05	; 5
    b57c:	ad b7       	in	r26, 0x3d	; 61
    b57e:	be b7       	in	r27, 0x3e	; 62
    b580:	12 96       	adiw	r26, 0x02	; 2
    b582:	9c 93       	st	X, r25
    b584:	8e 93       	st	-X, r24
    b586:	11 97       	sbiw	r26, 0x01	; 1
    b588:	84 ea       	ldi	r24, 0xA4	; 164
    b58a:	92 e0       	ldi	r25, 0x02	; 2
    b58c:	93 83       	std	Z+3, r25	; 0x03
    b58e:	82 83       	std	Z+2, r24	; 0x02
    b590:	ce 01       	movw	r24, r28
    b592:	01 96       	adiw	r24, 0x01	; 1
    b594:	95 83       	std	Z+5, r25	; 0x05
    b596:	84 83       	std	Z+4, r24	; 0x04
    b598:	0e 94 84 85 	call	0x10b08	; 0x10b08 <sscanf>
    b59c:	ed b7       	in	r30, 0x3d	; 61
    b59e:	fe b7       	in	r31, 0x3e	; 62
    b5a0:	36 96       	adiw	r30, 0x06	; 6
    b5a2:	0f b6       	in	r0, 0x3f	; 63
    b5a4:	f8 94       	cli
    b5a6:	fe bf       	out	0x3e, r31	; 62
    b5a8:	0f be       	out	0x3f, r0	; 63
    b5aa:	ed bf       	out	0x3d, r30	; 61
    b5ac:	01 97       	sbiw	r24, 0x01	; 1
    b5ae:	09 f0       	breq	.+2      	; 0xb5b2 <Buf2Field+0x4f2>
    b5b0:	1d ce       	rjmp	.-966    	; 0xb1ec <Buf2Field+0x12c>
			SetEEField32(Temp, int32_t, uint32_t, d);
    b5b2:	49 81       	ldd	r20, Y+1	; 0x01
    b5b4:	5a 81       	ldd	r21, Y+2	; 0x02
    b5b6:	6b 81       	ldd	r22, Y+3	; 0x03
    b5b8:	7c 81       	ldd	r23, Y+4	; 0x04
    b5ba:	ca 01       	movw	r24, r20
    b5bc:	db 01       	movw	r26, r22
    b5be:	e8 16       	cp	r14, r24
    b5c0:	f9 06       	cpc	r15, r25
    b5c2:	0a 07       	cpc	r16, r26
    b5c4:	1b 07       	cpc	r17, r27
    b5c6:	0c f4       	brge	.+2      	; 0xb5ca <Buf2Field+0x50a>
    b5c8:	d4 c0       	rjmp	.+424    	; 0xb772 <Buf2Field+0x6b2>
    b5ca:	88 15       	cp	r24, r8
    b5cc:	99 05       	cpc	r25, r9
    b5ce:	aa 05       	cpc	r26, r10
    b5d0:	bb 05       	cpc	r27, r11
    b5d2:	0c f0       	brlt	.+2      	; 0xb5d6 <Buf2Field+0x516>
    b5d4:	08 ce       	rjmp	.-1008   	; 0xb1e6 <Buf2Field+0x126>
    b5d6:	c2 01       	movw	r24, r4
    b5d8:	b5 01       	movw	r22, r10
    b5da:	a4 01       	movw	r20, r8
    b5dc:	0e 94 43 51 	call	0xa286	; 0xa286 <ewd>
    b5e0:	05 ce       	rjmp	.-1014   	; 0xb1ec <Buf2Field+0x12c>
		}
		break;


	case FFloat: case GFloat:
		sscanf(BufStr,"%f", &fTemp);
    b5e2:	00 d0       	rcall	.+0      	; 0xb5e4 <Buf2Field+0x524>
    b5e4:	00 d0       	rcall	.+0      	; 0xb5e6 <Buf2Field+0x526>
    b5e6:	ed b7       	in	r30, 0x3d	; 61
    b5e8:	fe b7       	in	r31, 0x3e	; 62
    b5ea:	31 96       	adiw	r30, 0x01	; 1
    b5ec:	83 ec       	ldi	r24, 0xC3	; 195
    b5ee:	95 e0       	ldi	r25, 0x05	; 5
    b5f0:	ad b7       	in	r26, 0x3d	; 61
    b5f2:	be b7       	in	r27, 0x3e	; 62
    b5f4:	12 96       	adiw	r26, 0x02	; 2
    b5f6:	9c 93       	st	X, r25
    b5f8:	8e 93       	st	-X, r24
    b5fa:	11 97       	sbiw	r26, 0x01	; 1
    b5fc:	88 ea       	ldi	r24, 0xA8	; 168
    b5fe:	92 e0       	ldi	r25, 0x02	; 2
    b600:	93 83       	std	Z+3, r25	; 0x03
    b602:	82 83       	std	Z+2, r24	; 0x02
    b604:	ce 01       	movw	r24, r28
    b606:	05 96       	adiw	r24, 0x05	; 5
    b608:	95 83       	std	Z+5, r25	; 0x05
    b60a:	84 83       	std	Z+4, r24	; 0x04
    b60c:	0e 94 84 85 	call	0x10b08	; 0x10b08 <sscanf>
		*(float*)Var = fTemp;
    b610:	8d 81       	ldd	r24, Y+5	; 0x05
    b612:	9e 81       	ldd	r25, Y+6	; 0x06
    b614:	af 81       	ldd	r26, Y+7	; 0x07
    b616:	b8 85       	ldd	r27, Y+8	; 0x08
    b618:	f2 01       	movw	r30, r4
    b61a:	80 83       	st	Z, r24
    b61c:	91 83       	std	Z+1, r25	; 0x01
    b61e:	a2 83       	std	Z+2, r26	; 0x02
    b620:	b3 83       	std	Z+3, r27	; 0x03
    b622:	2d b7       	in	r18, 0x3d	; 61
    b624:	3e b7       	in	r19, 0x3e	; 62
    b626:	2a 5f       	subi	r18, 0xFA	; 250
    b628:	3f 4f       	sbci	r19, 0xFF	; 255
    b62a:	0f b6       	in	r0, 0x3f	; 63
    b62c:	f8 94       	cli
    b62e:	3e bf       	out	0x3e, r19	; 62
    b630:	0f be       	out	0x3f, r0	; 63
    b632:	2d bf       	out	0x3d, r18	; 61
    b634:	db cd       	rjmp	.-1098   	; 0xb1ec <Buf2Field+0x12c>
		break;
	case EE_FFloat: case EE_GFloat:
		if(sscanf(BufStr,"%f", &fTemp) == 1){
    b636:	00 d0       	rcall	.+0      	; 0xb638 <Buf2Field+0x578>
    b638:	00 d0       	rcall	.+0      	; 0xb63a <Buf2Field+0x57a>
    b63a:	ed b7       	in	r30, 0x3d	; 61
    b63c:	fe b7       	in	r31, 0x3e	; 62
    b63e:	31 96       	adiw	r30, 0x01	; 1
    b640:	83 ec       	ldi	r24, 0xC3	; 195
    b642:	95 e0       	ldi	r25, 0x05	; 5
    b644:	ad b7       	in	r26, 0x3d	; 61
    b646:	be b7       	in	r27, 0x3e	; 62
    b648:	12 96       	adiw	r26, 0x02	; 2
    b64a:	9c 93       	st	X, r25
    b64c:	8e 93       	st	-X, r24
    b64e:	11 97       	sbiw	r26, 0x01	; 1
    b650:	88 ea       	ldi	r24, 0xA8	; 168
    b652:	92 e0       	ldi	r25, 0x02	; 2
    b654:	93 83       	std	Z+3, r25	; 0x03
    b656:	82 83       	std	Z+2, r24	; 0x02
    b658:	8e 01       	movw	r16, r28
    b65a:	0b 5f       	subi	r16, 0xFB	; 251
    b65c:	1f 4f       	sbci	r17, 0xFF	; 255
    b65e:	15 83       	std	Z+5, r17	; 0x05
    b660:	04 83       	std	Z+4, r16	; 0x04
    b662:	0e 94 84 85 	call	0x10b08	; 0x10b08 <sscanf>
    b666:	ed b7       	in	r30, 0x3d	; 61
    b668:	fe b7       	in	r31, 0x3e	; 62
    b66a:	36 96       	adiw	r30, 0x06	; 6
    b66c:	0f b6       	in	r0, 0x3f	; 63
    b66e:	f8 94       	cli
    b670:	fe bf       	out	0x3e, r31	; 62
    b672:	0f be       	out	0x3f, r0	; 63
    b674:	ed bf       	out	0x3d, r30	; 61
    b676:	01 97       	sbiw	r24, 0x01	; 1
    b678:	09 f0       	breq	.+2      	; 0xb67c <Buf2Field+0x5bc>
    b67a:	b8 cd       	rjmp	.-1168   	; 0xb1ec <Buf2Field+0x12c>
			ewbl(&fTemp, (float*)Var, 4);
    b67c:	c8 01       	movw	r24, r16
    b67e:	b2 01       	movw	r22, r4
    b680:	44 e0       	ldi	r20, 0x04	; 4
    b682:	50 e0       	ldi	r21, 0x00	; 0
    b684:	0e 94 3e 51 	call	0xa27c	; 0xa27c <ewbl>
    b688:	b1 cd       	rjmp	.-1182   	; 0xb1ec <Buf2Field+0x12c>
		}
		break;


	case Bit:
		if(F_Buf)
    b68a:	80 91 f7 04 	lds	r24, 0x04F7
    b68e:	90 91 f8 04 	lds	r25, 0x04F8
    b692:	a0 91 f9 04 	lds	r26, 0x04F9
    b696:	b0 91 fa 04 	lds	r27, 0x04FA
    b69a:	00 97       	sbiw	r24, 0x00	; 0
    b69c:	a1 05       	cpc	r26, r1
    b69e:	b1 05       	cpc	r27, r1
    b6a0:	91 f1       	breq	.+100    	; 0xb706 <Buf2Field+0x646>
			*BitVar |=Mask;
    b6a2:	d3 01       	movw	r26, r6
    b6a4:	8c 91       	ld	r24, X
    b6a6:	83 29       	or	r24, r3
    b6a8:	8c 93       	st	X, r24
    b6aa:	a0 cd       	rjmp	.-1216   	; 0xb1ec <Buf2Field+0x12c>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    b6ac:	c3 01       	movw	r24, r6
    b6ae:	0e 94 50 87 	call	0x10ea0	; 0x10ea0 <__eerd_byte_m2560>
    b6b2:	28 2f       	mov	r18, r24
		else
			*BitVar &=~Mask;
		break;
	case EE_Bit:
		EE_BitVar=erb(BitVar);
		ewb(BitVar, F_Buf ? EE_BitVar |Mask : EE_BitVar &~Mask);
    b6b4:	80 91 f7 04 	lds	r24, 0x04F7
    b6b8:	90 91 f8 04 	lds	r25, 0x04F8
    b6bc:	a0 91 f9 04 	lds	r26, 0x04F9
    b6c0:	b0 91 fa 04 	lds	r27, 0x04FA
    b6c4:	00 97       	sbiw	r24, 0x00	; 0
    b6c6:	a1 05       	cpc	r26, r1
    b6c8:	b1 05       	cpc	r27, r1
    b6ca:	d1 f4       	brne	.+52     	; 0xb700 <Buf2Field+0x640>
    b6cc:	63 2d       	mov	r22, r3
    b6ce:	60 95       	com	r22
    b6d0:	62 23       	and	r22, r18
    b6d2:	c3 01       	movw	r24, r6
    b6d4:	0e 94 c9 4f 	call	0x9f92	; 0x9f92 <ewb>
    b6d8:	89 cd       	rjmp	.-1262   	; 0xb1ec <Buf2Field+0x12c>
		break;


	case Text:{
		//    
		uint8_t Field_width = strlen((char*)Var);
    b6da:	f2 01       	movw	r30, r4
    b6dc:	01 90       	ld	r0, Z+
    b6de:	00 20       	and	r0, r0
    b6e0:	e9 f7       	brne	.-6      	; 0xb6dc <Buf2Field+0x61c>
    b6e2:	31 97       	sbiw	r30, 0x01	; 1
    b6e4:	4e 2f       	mov	r20, r30
    b6e6:	44 19       	sub	r20, r4
		if(Field_width > LCDXSz) Field_width = LCDXSz+1;
    b6e8:	45 31       	cpi	r20, 0x15	; 21
    b6ea:	e8 f0       	brcs	.+58     	; 0xb726 <Buf2Field+0x666>
    b6ec:	e5 e1       	ldi	r30, 0x15	; 21
    b6ee:	f0 e0       	ldi	r31, 0x00	; 0
		memcpy(Var,BufStr,Field_width);
    b6f0:	23 ec       	ldi	r18, 0xC3	; 195
    b6f2:	35 e0       	ldi	r19, 0x05	; 5
    b6f4:	c2 01       	movw	r24, r4
    b6f6:	b9 01       	movw	r22, r18
    b6f8:	af 01       	movw	r20, r30
    b6fa:	0e 94 72 84 	call	0x108e4	; 0x108e4 <memcpy>
    b6fe:	76 cd       	rjmp	.-1300   	; 0xb1ec <Buf2Field+0x12c>
		else
			*BitVar &=~Mask;
		break;
	case EE_Bit:
		EE_BitVar=erb(BitVar);
		ewb(BitVar, F_Buf ? EE_BitVar |Mask : EE_BitVar &~Mask);
    b700:	63 2d       	mov	r22, r3
    b702:	62 2b       	or	r22, r18
    b704:	e6 cf       	rjmp	.-52     	; 0xb6d2 <Buf2Field+0x612>

	case Bit:
		if(F_Buf)
			*BitVar |=Mask;
		else
			*BitVar &=~Mask;
    b706:	30 94       	com	r3
    b708:	f3 01       	movw	r30, r6
    b70a:	80 81       	ld	r24, Z
    b70c:	83 21       	and	r24, r3
    b70e:	80 83       	st	Z, r24
    b710:	6d cd       	rjmp	.-1318   	; 0xb1ec <Buf2Field+0x12c>
		break;
	case s_Longint:
		PresicionHanler(Field);
		//if(Limit_sByteVar(Temp)) sscanf(BufStr,"%hd", (short int*)&Temp);
		sscanf(BufStr,"%ld", (int32_t*)&Temp);
		SetField32(Temp, int32_t);
    b712:	d2 01       	movw	r26, r4
    b714:	ed 92       	st	X+, r14
    b716:	fd 92       	st	X+, r15
    b718:	0d 93       	st	X+, r16
    b71a:	1c 93       	st	X, r17
    b71c:	13 97       	sbiw	r26, 0x03	; 3
    b71e:	66 cd       	rjmp	.-1332   	; 0xb1ec <Buf2Field+0x12c>
	switch(prb(&Field->Type)) {
	case Byte: case z_Byte: case Enum:
		SetField(F_Buf, uint8_t);
		break;
	case s_Byte:
		SetField(sF_Buf, int8_t);
    b720:	f2 01       	movw	r30, r4
    b722:	e0 82       	st	Z, r14
    b724:	63 cd       	rjmp	.-1338   	; 0xb1ec <Buf2Field+0x12c>


	case Text:{
		//    
		uint8_t Field_width = strlen((char*)Var);
		if(Field_width > LCDXSz) Field_width = LCDXSz+1;
    b726:	e4 2f       	mov	r30, r20
    b728:	f0 e0       	ldi	r31, 0x00	; 0
    b72a:	e2 cf       	rjmp	.-60     	; 0xb6f0 <Buf2Field+0x630>
	uint32_t Temp=0;
	float fTemp=0;

	switch(prb(&Field->Type)) {
	case Byte: case z_Byte: case Enum:
		SetField(F_Buf, uint8_t);
    b72c:	d2 01       	movw	r26, r4
    b72e:	ec 92       	st	X, r14
    b730:	5d cd       	rjmp	.-1350   	; 0xb1ec <Buf2Field+0x12c>
		break;
	case s_EE_Byte:
		SetEEField(sF_Buf, int8_t, uint8_t, b);
		break;
	case Word: case z_Word:
		SetField(F_Buf, uint16_t);
    b732:	d2 01       	movw	r26, r4
    b734:	ed 92       	st	X+, r14
    b736:	fc 92       	st	X, r15
    b738:	59 cd       	rjmp	.-1358   	; 0xb1ec <Buf2Field+0x12c>
		break;
	case EE_Word: case z_EE_Word:
		SetEEField(F_Buf, uint16_t, uint16_t, w);
		break;
	case s_Word:
		SetField(sF_Buf, int16_t);
    b73a:	f2 01       	movw	r30, r4
    b73c:	f1 82       	std	Z+1, r15	; 0x01
    b73e:	e0 82       	st	Z, r14
    b740:	55 cd       	rjmp	.-1366   	; 0xb1ec <Buf2Field+0x12c>
		break;
	case s_EE_Word:
		SetEEField(sF_Buf, int16_t, uint16_t, w);
    b742:	c2 01       	movw	r24, r4
    b744:	b7 01       	movw	r22, r14
    b746:	0e 94 0c 50 	call	0xa018	; 0xa018 <eww>
    b74a:	50 cd       	rjmp	.-1376   	; 0xb1ec <Buf2Field+0x12c>
		break;
	case EE_Byte: case z_EE_Byte: case EE_Enum:
		SetEEField(F_Buf, uint8_t, uint8_t, b);
		break;
	case s_EE_Byte:
		SetEEField(sF_Buf, int8_t, uint8_t, b);
    b74c:	c2 01       	movw	r24, r4
    b74e:	6e 2d       	mov	r22, r14
    b750:	0e 94 c9 4f 	call	0x9f92	; 0x9f92 <ewb>
    b754:	4b cd       	rjmp	.-1386   	; 0xb1ec <Buf2Field+0x12c>
	switch(prb(&Field->Type)) {
	case Byte: case z_Byte: case Enum:
		SetField(F_Buf, uint8_t);
		break;
	case s_Byte:
		SetField(sF_Buf, int8_t);
    b756:	f2 01       	movw	r30, r4
    b758:	20 83       	st	Z, r18
    b75a:	48 cd       	rjmp	.-1392   	; 0xb1ec <Buf2Field+0x12c>
		break;
	case s_EE_Byte:
		SetEEField(sF_Buf, int8_t, uint8_t, b);
		break;
	case Word: case z_Word:
		SetField(F_Buf, uint16_t);
    b75c:	d2 01       	movw	r26, r4
    b75e:	2d 93       	st	X+, r18
    b760:	3c 93       	st	X, r19
    b762:	44 cd       	rjmp	.-1400   	; 0xb1ec <Buf2Field+0x12c>
		break;
	case EE_Word: case z_EE_Word:
		SetEEField(F_Buf, uint16_t, uint16_t, w);
		break;
	case s_Word:
		SetField(sF_Buf, int16_t);
    b764:	f2 01       	movw	r30, r4
    b766:	31 83       	std	Z+1, r19	; 0x01
    b768:	20 83       	st	Z, r18
    b76a:	40 cd       	rjmp	.-1408   	; 0xb1ec <Buf2Field+0x12c>
	uint32_t Temp=0;
	float fTemp=0;

	switch(prb(&Field->Type)) {
	case Byte: case z_Byte: case Enum:
		SetField(F_Buf, uint8_t);
    b76c:	d2 01       	movw	r26, r4
    b76e:	2c 93       	st	X, r18
    b770:	3d cd       	rjmp	.-1414   	; 0xb1ec <Buf2Field+0x12c>
		SetField32(Temp, int32_t);
		break;
	case s_EE_Longint:
		PresicionHanler(Field);
		if(sscanf(BufStr,"%ld", (int32_t*)&Temp) == 1){
			SetEEField32(Temp, int32_t, uint32_t, d);
    b772:	c2 01       	movw	r24, r4
    b774:	b8 01       	movw	r22, r16
    b776:	a7 01       	movw	r20, r14
    b778:	0e 94 43 51 	call	0xa286	; 0xa286 <ewd>
    b77c:	37 cd       	rjmp	.-1426   	; 0xb1ec <Buf2Field+0x12c>

0000b77e <MenuEnterRight>:
}

// ~~~~~~~~~~~~~~~~~
void
MenuEnterRight(void)
{
    b77e:	ef 92       	push	r14
    b780:	ff 92       	push	r15
    b782:	0f 93       	push	r16
    b784:	1f 93       	push	r17
    b786:	cf 93       	push	r28
    b788:	df 93       	push	r29
//	1) Hide current Message
	if(HideMsg()||KeyFunc(&CurrPage->Enter))
    b78a:	0e 94 12 40 	call	0x8024	; 0x8024 <HideMsg>
    b78e:	88 23       	and	r24, r24
    b790:	39 f0       	breq	.+14     	; 0xb7a0 <MenuEnterRight+0x22>
	if(NextPage || (NextPage=prp(&Line->InnPage))) {
		GotoMenu(NextPage);
		NextPage=NULL;
		return;
	}
}
    b792:	df 91       	pop	r29
    b794:	cf 91       	pop	r28
    b796:	1f 91       	pop	r17
    b798:	0f 91       	pop	r16
    b79a:	ff 90       	pop	r15
    b79c:	ef 90       	pop	r14
    b79e:	08 95       	ret
// ~~~~~~~~~~~~~~~~~
void
MenuEnterRight(void)
{
//	1) Hide current Message
	if(HideMsg()||KeyFunc(&CurrPage->Enter))
    b7a0:	80 91 d4 02 	lds	r24, 0x02D4
    b7a4:	90 91 d5 02 	lds	r25, 0x02D5
    b7a8:	0c 96       	adiw	r24, 0x0c	; 12
    b7aa:	0e 94 b8 3f 	call	0x7f70	; 0x7f70 <KeyFunc>
    b7ae:	88 23       	and	r24, r24
    b7b0:	81 f7       	brne	.-32     	; 0xb792 <MenuEnterRight+0x14>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    b7b2:	40 91 d4 02 	lds	r20, 0x02D4
    b7b6:	50 91 d5 02 	lds	r21, 0x02D5
    b7ba:	fa 01       	movw	r30, r20
    b7bc:	c5 91       	lpm	r28, Z+
    b7be:	d4 91       	lpm	r29, Z+
		return;

	MenuLine *Line=GetLine+CurrLine;
    b7c0:	90 91 ca 07 	lds	r25, 0x07CA
    b7c4:	8b e1       	ldi	r24, 0x1B	; 27
    b7c6:	98 9f       	mul	r25, r24
    b7c8:	b0 01       	movw	r22, r0
    b7ca:	11 24       	eor	r1, r1
    b7cc:	c6 0f       	add	r28, r22
    b7ce:	d7 1f       	adc	r29, r23
    b7d0:	fe 01       	movw	r30, r28
    b7d2:	77 96       	adiw	r30, 0x17	; 23
    b7d4:	e5 90       	lpm	r14, Z+
    b7d6:	f4 90       	lpm	r15, Z+
	OutField *Field=prp(&Line->OF_List);

// 2) Variable
	if(Field){
    b7d8:	e1 14       	cp	r14, r1
    b7da:	f1 04       	cpc	r15, r1
    b7dc:	09 f4       	brne	.+2      	; 0xb7e0 <MenuEnterRight+0x62>
    b7de:	93 c0       	rjmp	.+294    	; 0xb906 <MenuEnterRight+0x188>
    b7e0:	30 e0       	ldi	r19, 0x00	; 0
    b7e2:	10 e0       	ldi	r17, 0x00	; 0
    b7e4:	80 e0       	ldi	r24, 0x00	; 0
    b7e6:	90 e0       	ldi	r25, 0x00	; 0
    b7e8:	05 c0       	rjmp	.+10     	; 0xb7f4 <MenuEnterRight+0x76>
		uint8_t i=0;
		while(i<LCDXSz) {
			Char1 = Char2;
			Char2 = prc(CurrStr+i++);
			if (Char2=='}' && Char1!='}')
				FieldNumber++;
    b7ea:	01 96       	adiw	r24, 0x01	; 1
	// Define variable quantity 
		uint8_t FieldNumber = 0;
		PGM_P CurrStr=(PGM_P)(Line->Str);
		char Char1, Char2=0;
		uint8_t i=0;
		while(i<LCDXSz) {
    b7ec:	84 31       	cpi	r24, 0x14	; 20
    b7ee:	91 05       	cpc	r25, r1
    b7f0:	71 f0       	breq	.+28     	; 0xb80e <MenuEnterRight+0x90>
    b7f2:	32 2f       	mov	r19, r18

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    b7f4:	fe 01       	movw	r30, r28
    b7f6:	e8 0f       	add	r30, r24
    b7f8:	f9 1f       	adc	r31, r25
    b7fa:	24 91       	lpm	r18, Z+
			Char1 = Char2;
			Char2 = prc(CurrStr+i++);
			if (Char2=='}' && Char1!='}')
    b7fc:	2d 37       	cpi	r18, 0x7D	; 125
    b7fe:	a9 f7       	brne	.-22     	; 0xb7ea <MenuEnterRight+0x6c>
    b800:	3d 37       	cpi	r19, 0x7D	; 125
    b802:	99 f3       	breq	.-26     	; 0xb7ea <MenuEnterRight+0x6c>
				FieldNumber++;
    b804:	1f 5f       	subi	r17, 0xFF	; 255
    b806:	01 96       	adiw	r24, 0x01	; 1
	// Define variable quantity 
		uint8_t FieldNumber = 0;
		PGM_P CurrStr=(PGM_P)(Line->Str);
		char Char1, Char2=0;
		uint8_t i=0;
		while(i<LCDXSz) {
    b808:	84 31       	cpi	r24, 0x14	; 20
    b80a:	91 05       	cpc	r25, r1
    b80c:	91 f7       	brne	.-28     	; 0xb7f2 <MenuEnterRight+0x74>
			Char2 = prc(CurrStr+i++);
			if (Char2=='}' && Char1!='}')
				FieldNumber++;
		}
		//    Bit (:)   
		if(FieldNumber==1 && prb(&Field->Type)==Bit) {
    b80e:	11 30       	cpi	r17, 0x01	; 1
    b810:	09 f4       	brne	.+2      	; 0xb814 <MenuEnterRight+0x96>
    b812:	b8 c0       	rjmp	.+368    	; 0xb984 <MenuEnterRight+0x206>
			EventFunc(&Field->Act);
			return;
		}

	//    
		if(CurrPos!=NullPos && --CurrPos!=NullPos){
    b814:	80 91 d7 02 	lds	r24, 0x02D7
    b818:	8f 3f       	cpi	r24, 0xFF	; 255
    b81a:	09 f4       	brne	.+2      	; 0xb81e <MenuEnterRight+0xa0>
    b81c:	4a c0       	rjmp	.+148    	; 0xb8b2 <MenuEnterRight+0x134>
    b81e:	08 2f       	mov	r16, r24
    b820:	01 50       	subi	r16, 0x01	; 1
    b822:	00 93 d7 02 	sts	0x02D7, r16
    b826:	0f 3f       	cpi	r16, 0xFF	; 255
    b828:	09 f4       	brne	.+2      	; 0xb82c <MenuEnterRight+0xae>
    b82a:	43 c0       	rjmp	.+134    	; 0xb8b2 <MenuEnterRight+0x134>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    b82c:	fa 01       	movw	r30, r20
    b82e:	45 91       	lpm	r20, Z+
    b830:	54 91       	lpm	r21, Z+
			OutField *Field1=GetField;
    b832:	46 0f       	add	r20, r22
    b834:	57 1f       	adc	r21, r23
    b836:	49 5e       	subi	r20, 0xE9	; 233
    b838:	5f 4f       	sbci	r21, 0xFF	; 255
    b83a:	fa 01       	movw	r30, r20
    b83c:	25 91       	lpm	r18, Z+
    b83e:	34 91       	lpm	r19, Z+
    b840:	80 91 d6 02 	lds	r24, 0x02D6
    b844:	90 e0       	ldi	r25, 0x00	; 0
    b846:	82 95       	swap	r24
    b848:	92 95       	swap	r25
    b84a:	90 7f       	andi	r25, 0xF0	; 240
    b84c:	98 27       	eor	r25, r24
    b84e:	80 7f       	andi	r24, 0xF0	; 240
    b850:	98 27       	eor	r25, r24
    b852:	28 0f       	add	r18, r24
    b854:	39 1f       	adc	r19, r25

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    b856:	f9 01       	movw	r30, r18
    b858:	84 91       	lpm	r24, Z+
			switch(prb(&Field1->Type)){
    b85a:	8d 31       	cpi	r24, 0x1D	; 29
    b85c:	08 f4       	brcc	.+2      	; 0xb860 <MenuEnterRight+0xe2>
    b85e:	67 c0       	rjmp	.+206    	; 0xb92e <MenuEnterRight+0x1b0>
    b860:	81 52       	subi	r24, 0x21	; 33
    b862:	82 30       	cpi	r24, 0x02	; 2
    b864:	08 f0       	brcs	.+2      	; 0xb868 <MenuEnterRight+0xea>
    b866:	95 cf       	rjmp	.-214    	; 0xb792 <MenuEnterRight+0x14>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    b868:	f9 01       	movw	r30, r18
    b86a:	33 96       	adiw	r30, 0x03	; 3
    b86c:	85 91       	lpm	r24, Z+
    b86e:	95 91       	lpm	r25, Z+
    b870:	a5 91       	lpm	r26, Z+
    b872:	b4 91       	lpm	r27, Z+
			case Text: case EE_Text:
				if( (prd(&Field1->Min) == DIGIT) && (prd(&Field1->Max) == DIGIT) )
    b874:	00 97       	sbiw	r24, 0x00	; 0
    b876:	a1 05       	cpc	r26, r1
    b878:	b1 05       	cpc	r27, r1
    b87a:	59 f4       	brne	.+22     	; 0xb892 <MenuEnterRight+0x114>
    b87c:	f9 01       	movw	r30, r18
    b87e:	37 96       	adiw	r30, 0x07	; 7
    b880:	85 91       	lpm	r24, Z+
    b882:	95 91       	lpm	r25, Z+
    b884:	a5 91       	lpm	r26, Z+
    b886:	b4 91       	lpm	r27, Z+
    b888:	00 97       	sbiw	r24, 0x00	; 0
    b88a:	a1 05       	cpc	r26, r1
    b88c:	b1 05       	cpc	r27, r1
    b88e:	09 f4       	brne	.+2      	; 0xb892 <MenuEnterRight+0x114>
    b890:	a3 c0       	rjmp	.+326    	; 0xb9d8 <MenuEnterRight+0x25a>
					MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[CurrFieldSize - 1 - CurrPos]);
				else MultiSymbol = GetMultiSymbol(Symbols_P, BufStr[CurrFieldSize - 1 - CurrPos]);
    b892:	e0 91 c0 07 	lds	r30, 0x07C0
    b896:	f0 e0       	ldi	r31, 0x00	; 0
    b898:	31 97       	sbiw	r30, 0x01	; 1
    b89a:	e0 1b       	sub	r30, r16
    b89c:	f1 09       	sbc	r31, r1
    b89e:	ed 53       	subi	r30, 0x3D	; 61
    b8a0:	fa 4f       	sbci	r31, 0xFA	; 250
    b8a2:	85 e0       	ldi	r24, 0x05	; 5
    b8a4:	96 e0       	ldi	r25, 0x06	; 6
    b8a6:	60 81       	ld	r22, Z
    b8a8:	0e 94 77 44 	call	0x88ee	; 0x88ee <GetMultiSymbol>
    b8ac:	80 93 f4 04 	sts	0x04F4, r24
    b8b0:	70 cf       	rjmp	.-288    	; 0xb792 <MenuEnterRight+0x14>
				break;		
			}
			return;
		}

		if(CurrField!=NullPos) {
    b8b2:	80 91 d6 02 	lds	r24, 0x02D6
    b8b6:	8f 3f       	cpi	r24, 0xFF	; 255
    b8b8:	81 f0       	breq	.+32     	; 0xb8da <MenuEnterRight+0x15c>
			Buf2Field(Field+CurrField);
    b8ba:	90 e0       	ldi	r25, 0x00	; 0
    b8bc:	82 95       	swap	r24
    b8be:	92 95       	swap	r25
    b8c0:	90 7f       	andi	r25, 0xF0	; 240
    b8c2:	98 27       	eor	r25, r24
    b8c4:	80 7f       	andi	r24, 0xF0	; 240
    b8c6:	98 27       	eor	r25, r24
    b8c8:	8e 0d       	add	r24, r14
    b8ca:	9f 1d       	adc	r25, r15
    b8cc:	0e 94 60 58 	call	0xb0c0	; 0xb0c0 <Buf2Field>
			if(CurrField==NullPos)
    b8d0:	80 91 d6 02 	lds	r24, 0x02D6
    b8d4:	8f 3f       	cpi	r24, 0xFF	; 255
    b8d6:	09 f4       	brne	.+2      	; 0xb8da <MenuEnterRight+0x15c>
    b8d8:	5c cf       	rjmp	.-328    	; 0xb792 <MenuEnterRight+0x14>
				return;
		}
		//     
		if(++CurrField==FieldNumber)
    b8da:	8f 5f       	subi	r24, 0xFF	; 255
    b8dc:	80 93 d6 02 	sts	0x02D6, r24
    b8e0:	18 17       	cp	r17, r24
    b8e2:	d9 f1       	breq	.+118    	; 0xb95a <MenuEnterRight+0x1dc>
			CurrField=NullPos;
		else
			Field2Buf(Field+CurrField);
    b8e4:	90 e0       	ldi	r25, 0x00	; 0
    b8e6:	82 95       	swap	r24
    b8e8:	92 95       	swap	r25
    b8ea:	90 7f       	andi	r25, 0xF0	; 240
    b8ec:	98 27       	eor	r25, r24
    b8ee:	80 7f       	andi	r24, 0xF0	; 240
    b8f0:	98 27       	eor	r25, r24
    b8f2:	8e 0d       	add	r24, r14
    b8f4:	9f 1d       	adc	r25, r15
    b8f6:	0e 94 a8 54 	call	0xa950	; 0xa950 <Field2Buf>
    b8fa:	40 91 d4 02 	lds	r20, 0x02D4
    b8fe:	50 91 d5 02 	lds	r21, 0x02D5
    b902:	90 91 ca 07 	lds	r25, 0x07CA

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    b906:	4e 5f       	subi	r20, 0xFE	; 254
    b908:	5f 4f       	sbci	r21, 0xFF	; 255
    b90a:	fa 01       	movw	r30, r20
    b90c:	84 91       	lpm	r24, Z+
	}

// 3) Go to menu
	if( CurrLine >= prb(&CurrPage->LineNumber) )
    b90e:	98 17       	cp	r25, r24
    b910:	08 f0       	brcs	.+2      	; 0xb914 <MenuEnterRight+0x196>
    b912:	3f cf       	rjmp	.-386    	; 0xb792 <MenuEnterRight+0x14>
		return;

	if(NextPage || (NextPage=prp(&Line->InnPage))) {
    b914:	80 91 d9 05 	lds	r24, 0x05D9
    b918:	90 91 da 05 	lds	r25, 0x05DA
    b91c:	00 97       	sbiw	r24, 0x00	; 0
    b91e:	39 f1       	breq	.+78     	; 0xb96e <MenuEnterRight+0x1f0>
		GotoMenu(NextPage);
    b920:	0e 94 ca 3f 	call	0x7f94	; 0x7f94 <GotoMenu>
		NextPage=NULL;
    b924:	10 92 da 05 	sts	0x05DA, r1
    b928:	10 92 d9 05 	sts	0x05D9, r1
    b92c:	32 cf       	rjmp	.-412    	; 0xb792 <MenuEnterRight+0x14>
		}

	//    
		if(CurrPos!=NullPos && --CurrPos!=NullPos){
			OutField *Field1=GetField;
			switch(prb(&Field1->Type)){
    b92e:	89 31       	cpi	r24, 0x19	; 25
    b930:	20 f4       	brcc	.+8      	; 0xb93a <MenuEnterRight+0x1bc>
    b932:	80 51       	subi	r24, 0x10	; 16
    b934:	86 30       	cpi	r24, 0x06	; 6
    b936:	08 f0       	brcs	.+2      	; 0xb93a <MenuEnterRight+0x1bc>
    b938:	2c cf       	rjmp	.-424    	; 0xb792 <MenuEnterRight+0x14>
					MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[CurrFieldSize - 1 - CurrPos]);
				else MultiSymbol = GetMultiSymbol(Symbols_P, BufStr[CurrFieldSize - 1 - CurrPos]);
				break;
			case Longint: case z_Longint: case EE_Longint: case z_EE_Longint: case s_Longint: case s_EE_Longint:
			case FFloat: case EE_FFloat: case GFloat: case EE_GFloat:
				MultiSymbol = GetMultiSymbol(Digits_P, BufStr[CurrFieldSize - 1 - CurrPos]);
    b93a:	e0 91 c0 07 	lds	r30, 0x07C0
    b93e:	f0 e0       	ldi	r31, 0x00	; 0
    b940:	31 97       	sbiw	r30, 0x01	; 1
    b942:	e0 1b       	sub	r30, r16
    b944:	f1 09       	sbc	r31, r1
    b946:	ed 53       	subi	r30, 0x3D	; 61
    b948:	fa 4f       	sbci	r31, 0xFA	; 250
    b94a:	8e ea       	ldi	r24, 0xAE	; 174
    b94c:	96 e0       	ldi	r25, 0x06	; 6
    b94e:	60 81       	ld	r22, Z
    b950:	0e 94 77 44 	call	0x88ee	; 0x88ee <GetMultiSymbol>
    b954:	80 93 f4 04 	sts	0x04F4, r24
    b958:	1c cf       	rjmp	.-456    	; 0xb792 <MenuEnterRight+0x14>
			if(CurrField==NullPos)
				return;
		}
		//     
		if(++CurrField==FieldNumber)
			CurrField=NullPos;
    b95a:	8f ef       	ldi	r24, 0xFF	; 255
    b95c:	80 93 d6 02 	sts	0x02D6, r24
    b960:	40 91 d4 02 	lds	r20, 0x02D4
    b964:	50 91 d5 02 	lds	r21, 0x02D5
    b968:	90 91 ca 07 	lds	r25, 0x07CA
    b96c:	cc cf       	rjmp	.-104    	; 0xb906 <MenuEnterRight+0x188>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    b96e:	fe 01       	movw	r30, r28
    b970:	79 96       	adiw	r30, 0x19	; 25
    b972:	85 91       	lpm	r24, Z+
    b974:	94 91       	lpm	r25, Z+

// 3) Go to menu
	if( CurrLine >= prb(&CurrPage->LineNumber) )
		return;

	if(NextPage || (NextPage=prp(&Line->InnPage))) {
    b976:	90 93 da 05 	sts	0x05DA, r25
    b97a:	80 93 d9 05 	sts	0x05D9, r24
    b97e:	00 97       	sbiw	r24, 0x00	; 0
    b980:	79 f6       	brne	.-98     	; 0xb920 <MenuEnterRight+0x1a2>
    b982:	07 cf       	rjmp	.-498    	; 0xb792 <MenuEnterRight+0x14>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    b984:	f7 01       	movw	r30, r14
    b986:	84 91       	lpm	r24, Z+
			Char2 = prc(CurrStr+i++);
			if (Char2=='}' && Char1!='}')
				FieldNumber++;
		}
		//    Bit (:)   
		if(FieldNumber==1 && prb(&Field->Type)==Bit) {
    b988:	8f 31       	cpi	r24, 0x1F	; 31
    b98a:	09 f0       	breq	.+2      	; 0xb98e <MenuEnterRight+0x210>
    b98c:	43 cf       	rjmp	.-378    	; 0xb814 <MenuEnterRight+0x96>
    b98e:	8f e0       	ldi	r24, 0x0F	; 15
    b990:	90 e0       	ldi	r25, 0x00	; 0
    b992:	e8 0e       	add	r14, r24
    b994:	f9 1e       	adc	r15, r25
    b996:	f7 01       	movw	r30, r14
    b998:	24 91       	lpm	r18, Z+
    b99a:	81 ef       	ldi	r24, 0xF1	; 241
    b99c:	9f ef       	ldi	r25, 0xFF	; 255
    b99e:	e8 0e       	add	r14, r24
    b9a0:	f9 1e       	adc	r15, r25

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    b9a2:	c7 01       	movw	r24, r14
    b9a4:	01 96       	adiw	r24, 0x01	; 1
    b9a6:	fc 01       	movw	r30, r24
    b9a8:	a5 91       	lpm	r26, Z+
    b9aa:	b4 91       	lpm	r27, Z+
			uint8_t BitN=prb(&Field->Prec);
			*((uint8_t*)prp(&Field->Var)+BitN/8) ^=(1<<BitN%8);
    b9ac:	82 2f       	mov	r24, r18
    b9ae:	86 95       	lsr	r24
    b9b0:	86 95       	lsr	r24
    b9b2:	86 95       	lsr	r24
    b9b4:	a8 0f       	add	r26, r24
    b9b6:	b1 1d       	adc	r27, r1
    b9b8:	27 70       	andi	r18, 0x07	; 7
    b9ba:	81 e0       	ldi	r24, 0x01	; 1
    b9bc:	90 e0       	ldi	r25, 0x00	; 0
    b9be:	02 c0       	rjmp	.+4      	; 0xb9c4 <MenuEnterRight+0x246>
    b9c0:	88 0f       	add	r24, r24
    b9c2:	99 1f       	adc	r25, r25
    b9c4:	2a 95       	dec	r18
    b9c6:	e2 f7       	brpl	.-8      	; 0xb9c0 <MenuEnterRight+0x242>
    b9c8:	2c 91       	ld	r18, X
    b9ca:	28 27       	eor	r18, r24
    b9cc:	2c 93       	st	X, r18
			EventFunc(&Field->Act);
    b9ce:	c7 01       	movw	r24, r14
    b9d0:	0b 96       	adiw	r24, 0x0b	; 11
    b9d2:	0e 94 b0 3f 	call	0x7f60	; 0x7f60 <EventFunc>
    b9d6:	dd ce       	rjmp	.-582    	; 0xb792 <MenuEnterRight+0x14>
		if(CurrPos!=NullPos && --CurrPos!=NullPos){
			OutField *Field1=GetField;
			switch(prb(&Field1->Type)){
			case Text: case EE_Text:
				if( (prd(&Field1->Min) == DIGIT) && (prd(&Field1->Max) == DIGIT) )
					MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[CurrFieldSize - 1 - CurrPos]);
    b9d8:	e0 91 c0 07 	lds	r30, 0x07C0
    b9dc:	f0 e0       	ldi	r31, 0x00	; 0
    b9de:	31 97       	sbiw	r30, 0x01	; 1
    b9e0:	e0 1b       	sub	r30, r16
    b9e2:	f1 09       	sbc	r31, r1
    b9e4:	ed 53       	subi	r30, 0x3D	; 61
    b9e6:	fa 4f       	sbci	r31, 0xFA	; 250
    b9e8:	83 ea       	ldi	r24, 0xA3	; 163
    b9ea:	96 e0       	ldi	r25, 0x06	; 6
    b9ec:	60 81       	ld	r22, Z
    b9ee:	0e 94 77 44 	call	0x88ee	; 0x88ee <GetMultiSymbol>
    b9f2:	80 93 f4 04 	sts	0x04F4, r24
    b9f6:	cd ce       	rjmp	.-614    	; 0xb792 <MenuEnterRight+0x14>

0000b9f8 <MenuUD>:
	return Pos*Dir;
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
MenuUD(const MenuKey *Key, int8_t Dir, uint8_t LimLine, uint8_t LimLCD, uint8_t LimVar)
{
    b9f8:	af 92       	push	r10
    b9fa:	bf 92       	push	r11
    b9fc:	cf 92       	push	r12
    b9fe:	df 92       	push	r13
    ba00:	ef 92       	push	r14
    ba02:	ff 92       	push	r15
    ba04:	0f 93       	push	r16
    ba06:	1f 93       	push	r17
    ba08:	cf 93       	push	r28
    ba0a:	df 93       	push	r29
    ba0c:	fc 01       	movw	r30, r24
    ba0e:	e6 2e       	mov	r14, r22
    ba10:	14 2f       	mov	r17, r20
    ba12:	f2 2e       	mov	r15, r18
	if(CurrMsg || KeyFunc(Key))
    ba14:	80 91 f5 04 	lds	r24, 0x04F5
    ba18:	90 91 f6 04 	lds	r25, 0x04F6
    ba1c:	89 2b       	or	r24, r25
    ba1e:	59 f0       	breq	.+22     	; 0xba36 <MenuUD+0x3e>
		else 		{if(--MultiSymbol == 255) MultiSymbol = strlen_P(Digits_P)-1;}
		if(CurrPos!=NullPos)
			BufStr[CurrFieldSize - 1 - CurrPos] = prc(Digits_P + MultiSymbol);
		break;
	}
}
    ba20:	df 91       	pop	r29
    ba22:	cf 91       	pop	r28
    ba24:	1f 91       	pop	r17
    ba26:	0f 91       	pop	r16
    ba28:	ff 90       	pop	r15
    ba2a:	ef 90       	pop	r14
    ba2c:	df 90       	pop	r13
    ba2e:	cf 90       	pop	r12
    ba30:	bf 90       	pop	r11
    ba32:	af 90       	pop	r10
    ba34:	08 95       	ret
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
MenuUD(const MenuKey *Key, int8_t Dir, uint8_t LimLine, uint8_t LimLCD, uint8_t LimVar)
{
	if(CurrMsg || KeyFunc(Key))
    ba36:	cf 01       	movw	r24, r30
    ba38:	0e 94 b8 3f 	call	0x7f70	; 0x7f70 <KeyFunc>
    ba3c:	88 23       	and	r24, r24
    ba3e:	81 f7       	brne	.-32     	; 0xba20 <MenuUD+0x28>
		return;
	if(CurrField==NullPos) {
    ba40:	30 91 d6 02 	lds	r19, 0x02D6
    ba44:	3f 3f       	cpi	r19, 0xFF	; 255
    ba46:	09 f4       	brne	.+2      	; 0xba4a <MenuUD+0x52>
    ba48:	48 c1       	rjmp	.+656    	; 0xbcda <MenuUD+0x2e2>
			if(LimLCD)
				CurrLCD -= Dir;
		}
		return;
	}
	Blink=0;
    ba4a:	10 92 18 09 	sts	0x0918, r1
    ba4e:	80 91 d4 02 	lds	r24, 0x02D4
    ba52:	90 91 d5 02 	lds	r25, 0x02D5
    ba56:	fc 01       	movw	r30, r24
    ba58:	45 91       	lpm	r20, Z+
    ba5a:	54 91       	lpm	r21, Z+
	OutField *Field=GetField;
    ba5c:	80 91 ca 07 	lds	r24, 0x07CA
    ba60:	2b e1       	ldi	r18, 0x1B	; 27
    ba62:	82 9f       	mul	r24, r18
    ba64:	c0 01       	movw	r24, r0
    ba66:	11 24       	eor	r1, r1
    ba68:	48 0f       	add	r20, r24
    ba6a:	59 1f       	adc	r21, r25
    ba6c:	49 5e       	subi	r20, 0xE9	; 233
    ba6e:	5f 4f       	sbci	r21, 0xFF	; 255
    ba70:	fa 01       	movw	r30, r20
    ba72:	c5 91       	lpm	r28, Z+
    ba74:	d4 91       	lpm	r29, Z+
    ba76:	83 2f       	mov	r24, r19
    ba78:	90 e0       	ldi	r25, 0x00	; 0
    ba7a:	82 95       	swap	r24
    ba7c:	92 95       	swap	r25
    ba7e:	90 7f       	andi	r25, 0xF0	; 240
    ba80:	98 27       	eor	r25, r24
    ba82:	80 7f       	andi	r24, 0xF0	; 240
    ba84:	98 27       	eor	r25, r24
    ba86:	c8 0f       	add	r28, r24
    ba88:	d9 1f       	adc	r29, r25

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    ba8a:	fe 01       	movw	r30, r28
    ba8c:	84 91       	lpm	r24, Z+
	switch(prb(&Field->Type)) {
    ba8e:	e8 2f       	mov	r30, r24
    ba90:	f0 e0       	ldi	r31, 0x00	; 0
    ba92:	e3 32       	cpi	r30, 0x23	; 35
    ba94:	f1 05       	cpc	r31, r1
    ba96:	08 f0       	brcs	.+2      	; 0xba9a <MenuUD+0xa2>
    ba98:	c3 cf       	rjmp	.-122    	; 0xba20 <MenuUD+0x28>
    ba9a:	ea 54       	subi	r30, 0x4A	; 74
    ba9c:	ff 4f       	sbci	r31, 0xFF	; 255
    ba9e:	ee 0f       	add	r30, r30
    baa0:	ff 1f       	adc	r31, r31
    baa2:	05 90       	lpm	r0, Z+
    baa4:	f4 91       	lpm	r31, Z+
    baa6:	e0 2d       	mov	r30, r0
    baa8:	19 94       	eijmp

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    baaa:	fe 01       	movw	r30, r28
    baac:	33 96       	adiw	r30, 0x03	; 3
    baae:	85 91       	lpm	r24, Z+
    bab0:	95 91       	lpm	r25, Z+
    bab2:	a5 91       	lpm	r26, Z+
    bab4:	b4 91       	lpm	r27, Z+
		break;
	case Bit: case EE_Bit:
		F_Buf = !F_Buf;
		break;
	case Text: case EE_Text:
		if( (prd(&Field->Min) == DIGIT) && (prd(&Field->Max) == DIGIT) ){
    bab6:	00 97       	sbiw	r24, 0x00	; 0
    bab8:	a1 05       	cpc	r26, r1
    baba:	b1 05       	cpc	r27, r1
    babc:	09 f0       	breq	.+2      	; 0xbac0 <MenuUD+0xc8>
    babe:	1e c1       	rjmp	.+572    	; 0xbcfc <MenuUD+0x304>
    bac0:	fe 01       	movw	r30, r28
    bac2:	37 96       	adiw	r30, 0x07	; 7
    bac4:	85 91       	lpm	r24, Z+
    bac6:	95 91       	lpm	r25, Z+
    bac8:	a5 91       	lpm	r26, Z+
    baca:	b4 91       	lpm	r27, Z+
    bacc:	00 97       	sbiw	r24, 0x00	; 0
    bace:	a1 05       	cpc	r26, r1
    bad0:	b1 05       	cpc	r27, r1
    bad2:	09 f0       	breq	.+2      	; 0xbad6 <MenuUD+0xde>
    bad4:	13 c1       	rjmp	.+550    	; 0xbcfc <MenuUD+0x304>
			if(Dir==1){	if(++MultiSymbol > 9) MultiSymbol = 0;}
    bad6:	31 e0       	ldi	r19, 0x01	; 1
    bad8:	e3 16       	cp	r14, r19
    bada:	09 f4       	brne	.+2      	; 0xbade <MenuUD+0xe6>
    badc:	92 c1       	rjmp	.+804    	; 0xbe02 <MenuUD+0x40a>
			else{		if(--MultiSymbol == 255) MultiSymbol = 9;}
    bade:	80 91 f4 04 	lds	r24, 0x04F4
    bae2:	81 50       	subi	r24, 0x01	; 1
    bae4:	80 93 f4 04 	sts	0x04F4, r24
    bae8:	8f 3f       	cpi	r24, 0xFF	; 255
    baea:	09 f4       	brne	.+2      	; 0xbaee <MenuUD+0xf6>
    baec:	93 c1       	rjmp	.+806    	; 0xbe14 <MenuUD+0x41c>
		}
		else{
			if(Dir==1){	if(++MultiSymbol >= strlen_P(Symbols_P)) MultiSymbol = 0;}
			else{		if(--MultiSymbol == 255) MultiSymbol = strlen_P(Symbols_P)-1;}
		}
		if(CurrPos!=NullPos)
    baee:	90 91 d7 02 	lds	r25, 0x02D7
    baf2:	9f 3f       	cpi	r25, 0xFF	; 255
    baf4:	09 f4       	brne	.+2      	; 0xbaf8 <MenuUD+0x100>
    baf6:	94 cf       	rjmp	.-216    	; 0xba20 <MenuUD+0x28>

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    baf8:	80 91 f4 04 	lds	r24, 0x04F4
    bafc:	e8 2f       	mov	r30, r24
    bafe:	f0 e0       	ldi	r31, 0x00	; 0
    bb00:	eb 5f       	subi	r30, 0xFB	; 251
    bb02:	f9 4f       	sbci	r31, 0xF9	; 249
	case Longint: case z_Longint: case EE_Longint: case z_EE_Longint: case s_Longint: case s_EE_Longint:
	case FFloat: case EE_FFloat: case GFloat: case EE_GFloat:
		if(Dir==1)	{if(++MultiSymbol >= strlen_P(Digits_P)) MultiSymbol = 0;}
		else 		{if(--MultiSymbol == 255) MultiSymbol = strlen_P(Digits_P)-1;}
		if(CurrPos!=NullPos)
			BufStr[CurrFieldSize - 1 - CurrPos] = prc(Digits_P + MultiSymbol);
    bb04:	84 91       	lpm	r24, Z+
    bb06:	e0 91 c0 07 	lds	r30, 0x07C0
    bb0a:	f0 e0       	ldi	r31, 0x00	; 0
    bb0c:	31 97       	sbiw	r30, 0x01	; 1
    bb0e:	e9 1b       	sub	r30, r25
    bb10:	f1 09       	sbc	r31, r1
    bb12:	ed 53       	subi	r30, 0x3D	; 61
    bb14:	fa 4f       	sbci	r31, 0xFA	; 250
    bb16:	80 83       	st	Z, r24
    bb18:	83 cf       	rjmp	.-250    	; 0xba20 <MenuUD+0x28>
	case Enum: case EE_Enum:
		if(LimVar)
			F_Buf += Dir;
		break;
	case Bit: case EE_Bit:
		F_Buf = !F_Buf;
    bb1a:	20 e0       	ldi	r18, 0x00	; 0
    bb1c:	30 e0       	ldi	r19, 0x00	; 0
    bb1e:	40 e0       	ldi	r20, 0x00	; 0
    bb20:	50 e0       	ldi	r21, 0x00	; 0
    bb22:	80 91 f7 04 	lds	r24, 0x04F7
    bb26:	90 91 f8 04 	lds	r25, 0x04F8
    bb2a:	a0 91 f9 04 	lds	r26, 0x04F9
    bb2e:	b0 91 fa 04 	lds	r27, 0x04FA
    bb32:	00 97       	sbiw	r24, 0x00	; 0
    bb34:	a1 05       	cpc	r26, r1
    bb36:	b1 05       	cpc	r27, r1
    bb38:	21 f4       	brne	.+8      	; 0xbb42 <MenuUD+0x14a>
    bb3a:	21 e0       	ldi	r18, 0x01	; 1
    bb3c:	30 e0       	ldi	r19, 0x00	; 0
    bb3e:	40 e0       	ldi	r20, 0x00	; 0
    bb40:	50 e0       	ldi	r21, 0x00	; 0
    bb42:	20 93 f7 04 	sts	0x04F7, r18
    bb46:	30 93 f8 04 	sts	0x04F8, r19
    bb4a:	40 93 f9 04 	sts	0x04F9, r20
    bb4e:	50 93 fa 04 	sts	0x04FA, r21
    bb52:	66 cf       	rjmp	.-308    	; 0xba20 <MenuUD+0x28>
			Buf2Field(Field);
			Field2Buf(Field);
		}
		break;
	case Enum: case EE_Enum:
		if(LimVar)
    bb54:	00 23       	and	r16, r16
    bb56:	09 f4       	brne	.+2      	; 0xbb5a <MenuUD+0x162>
    bb58:	63 cf       	rjmp	.-314    	; 0xba20 <MenuUD+0x28>
			F_Buf += Dir;
    bb5a:	2e 2d       	mov	r18, r14
    bb5c:	33 27       	eor	r19, r19
    bb5e:	27 fd       	sbrc	r18, 7
    bb60:	30 95       	com	r19
    bb62:	43 2f       	mov	r20, r19
    bb64:	53 2f       	mov	r21, r19
    bb66:	80 91 f7 04 	lds	r24, 0x04F7
    bb6a:	90 91 f8 04 	lds	r25, 0x04F8
    bb6e:	a0 91 f9 04 	lds	r26, 0x04F9
    bb72:	b0 91 fa 04 	lds	r27, 0x04FA
    bb76:	82 0f       	add	r24, r18
    bb78:	93 1f       	adc	r25, r19
    bb7a:	a4 1f       	adc	r26, r20
    bb7c:	b5 1f       	adc	r27, r21
    bb7e:	80 93 f7 04 	sts	0x04F7, r24
    bb82:	90 93 f8 04 	sts	0x04F8, r25
    bb86:	a0 93 f9 04 	sts	0x04F9, r26
    bb8a:	b0 93 fa 04 	sts	0x04FA, r27
    bb8e:	48 cf       	rjmp	.-368    	; 0xba20 <MenuUD+0x28>
		if(CurrPos!=NullPos)
			BufStr[CurrFieldSize - 1 - CurrPos] = prc(Symbols_P + MultiSymbol);
		break;
	case Longint: case z_Longint: case EE_Longint: case z_EE_Longint: case s_Longint: case s_EE_Longint:
	case FFloat: case EE_FFloat: case GFloat: case EE_GFloat:
		if(Dir==1)	{if(++MultiSymbol >= strlen_P(Digits_P)) MultiSymbol = 0;}
    bb90:	51 e0       	ldi	r21, 0x01	; 1
    bb92:	e5 16       	cp	r14, r21
    bb94:	09 f4       	brne	.+2      	; 0xbb98 <MenuUD+0x1a0>
    bb96:	fb c0       	rjmp	.+502    	; 0xbd8e <MenuUD+0x396>
		else 		{if(--MultiSymbol == 255) MultiSymbol = strlen_P(Digits_P)-1;}
    bb98:	80 91 f4 04 	lds	r24, 0x04F4
    bb9c:	81 50       	subi	r24, 0x01	; 1
    bb9e:	80 93 f4 04 	sts	0x04F4, r24
    bba2:	8f 3f       	cpi	r24, 0xFF	; 255
    bba4:	09 f4       	brne	.+2      	; 0xbba8 <MenuUD+0x1b0>
    bba6:	14 c1       	rjmp	.+552    	; 0xbdd0 <MenuUD+0x3d8>
		if(CurrPos!=NullPos)
    bba8:	90 91 d7 02 	lds	r25, 0x02D7
    bbac:	9f 3f       	cpi	r25, 0xFF	; 255
    bbae:	09 f4       	brne	.+2      	; 0xbbb2 <MenuUD+0x1ba>
    bbb0:	37 cf       	rjmp	.-402    	; 0xba20 <MenuUD+0x28>
    bbb2:	80 91 f4 04 	lds	r24, 0x04F4
    bbb6:	e8 2f       	mov	r30, r24
    bbb8:	f0 e0       	ldi	r31, 0x00	; 0
    bbba:	e2 55       	subi	r30, 0x52	; 82
    bbbc:	f9 4f       	sbci	r31, 0xF9	; 249
    bbbe:	a2 cf       	rjmp	.-188    	; 0xbb04 <MenuUD+0x10c>
			sF_Buf += Inc(Dir, sF_Buf);
		else if(sF_Buf<0 || sF_Buf==0 && Minus)
			Minus = (sF_Buf-=Inc(Dir, -sF_Buf))==0;
		break;
	case c_Word: case zc_Word:
		if(LimVar) {
    bbc0:	00 23       	and	r16, r16
    bbc2:	09 f4       	brne	.+2      	; 0xbbc6 <MenuUD+0x1ce>
    bbc4:	2d cf       	rjmp	.-422    	; 0xba20 <MenuUD+0x28>
			F_Buf += Dir;
    bbc6:	2e 2d       	mov	r18, r14
    bbc8:	33 27       	eor	r19, r19
    bbca:	27 fd       	sbrc	r18, 7
    bbcc:	30 95       	com	r19
    bbce:	43 2f       	mov	r20, r19
    bbd0:	53 2f       	mov	r21, r19
    bbd2:	80 91 f7 04 	lds	r24, 0x04F7
    bbd6:	90 91 f8 04 	lds	r25, 0x04F8
    bbda:	a0 91 f9 04 	lds	r26, 0x04F9
    bbde:	b0 91 fa 04 	lds	r27, 0x04FA
    bbe2:	82 0f       	add	r24, r18
    bbe4:	93 1f       	adc	r25, r19
    bbe6:	a4 1f       	adc	r26, r20
    bbe8:	b5 1f       	adc	r27, r21
    bbea:	80 93 f7 04 	sts	0x04F7, r24
    bbee:	90 93 f8 04 	sts	0x04F8, r25
    bbf2:	a0 93 f9 04 	sts	0x04F9, r26
    bbf6:	b0 93 fa 04 	sts	0x04FA, r27
			Buf2Field(Field);
    bbfa:	ce 01       	movw	r24, r28
    bbfc:	0e 94 60 58 	call	0xb0c0	; 0xb0c0 <Buf2Field>
			Field2Buf(Field);
    bc00:	ce 01       	movw	r24, r28
    bc02:	0e 94 a8 54 	call	0xa950	; 0xa950 <Field2Buf>
    bc06:	0c cf       	rjmp	.-488    	; 0xba20 <MenuUD+0x28>
	case Word: case EE_Word: case z_Word: case z_EE_Word:
		F_Buf += Inc(Dir, F_Buf);
		break;
	case s_Byte: case s_EE_Byte:
	case s_Word: case s_EE_Word:
		if(CurrPos==Log10(prd(&Field->Max))+1) {
    bc08:	00 91 d7 02 	lds	r16, 0x02D7
    bc0c:	10 e0       	ldi	r17, 0x00	; 0

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    bc0e:	fe 01       	movw	r30, r28
    bc10:	37 96       	adiw	r30, 0x07	; 7
    bc12:	65 91       	lpm	r22, Z+
    bc14:	75 91       	lpm	r23, Z+
    bc16:	85 91       	lpm	r24, Z+
    bc18:	94 91       	lpm	r25, Z+
    bc1a:	0e 94 36 24 	call	0x486c	; 0x486c <Log10>
    bc1e:	90 e0       	ldi	r25, 0x00	; 0
    bc20:	01 96       	adiw	r24, 0x01	; 1
    bc22:	08 17       	cp	r16, r24
    bc24:	19 07       	cpc	r17, r25
    bc26:	09 f4       	brne	.+2      	; 0xbc2a <MenuUD+0x232>
    bc28:	9c c0       	rjmp	.+312    	; 0xbd62 <MenuUD+0x36a>
			if(sF_Buf==0)
				Minus = !Minus;
			else
				sF_Buf = -sF_Buf;
		}
		else if(sF_Buf>0 || sF_Buf==0 && !Minus)
    bc2a:	a0 90 fb 04 	lds	r10, 0x04FB
    bc2e:	b0 90 fc 04 	lds	r11, 0x04FC
    bc32:	c0 90 fd 04 	lds	r12, 0x04FD
    bc36:	d0 90 fe 04 	lds	r13, 0x04FE
    bc3a:	1a 14       	cp	r1, r10
    bc3c:	1b 04       	cpc	r1, r11
    bc3e:	1c 04       	cpc	r1, r12
    bc40:	1d 04       	cpc	r1, r13
    bc42:	0c f4       	brge	.+2      	; 0xbc46 <MenuUD+0x24e>
    bc44:	74 c0       	rjmp	.+232    	; 0xbd2e <MenuUD+0x336>
    bc46:	a1 14       	cp	r10, r1
    bc48:	b1 04       	cpc	r11, r1
    bc4a:	c1 04       	cpc	r12, r1
    bc4c:	d1 04       	cpc	r13, r1
    bc4e:	09 f4       	brne	.+2      	; 0xbc52 <MenuUD+0x25a>
    bc50:	69 c0       	rjmp	.+210    	; 0xbd24 <MenuUD+0x32c>
			sF_Buf += Inc(Dir, sF_Buf);
		else if(sF_Buf<0 || sF_Buf==0 && Minus)
			Minus = (sF_Buf-=Inc(Dir, -sF_Buf))==0;
    bc52:	44 27       	eor	r20, r20
    bc54:	55 27       	eor	r21, r21
    bc56:	ba 01       	movw	r22, r20
    bc58:	4a 19       	sub	r20, r10
    bc5a:	5b 09       	sbc	r21, r11
    bc5c:	6c 09       	sbc	r22, r12
    bc5e:	7d 09       	sbc	r23, r13
    bc60:	8e 2d       	mov	r24, r14
    bc62:	0e 94 8f 40 	call	0x811e	; 0x811e <Inc>
    bc66:	a6 01       	movw	r20, r12
    bc68:	95 01       	movw	r18, r10
    bc6a:	26 1b       	sub	r18, r22
    bc6c:	37 0b       	sbc	r19, r23
    bc6e:	48 0b       	sbc	r20, r24
    bc70:	59 0b       	sbc	r21, r25
    bc72:	20 93 fb 04 	sts	0x04FB, r18
    bc76:	30 93 fc 04 	sts	0x04FC, r19
    bc7a:	40 93 fd 04 	sts	0x04FD, r20
    bc7e:	50 93 fe 04 	sts	0x04FE, r21
    bc82:	10 92 ff 04 	sts	0x04FF, r1
    bc86:	21 15       	cp	r18, r1
    bc88:	31 05       	cpc	r19, r1
    bc8a:	41 05       	cpc	r20, r1
    bc8c:	51 05       	cpc	r21, r1
    bc8e:	09 f0       	breq	.+2      	; 0xbc92 <MenuUD+0x29a>
    bc90:	c7 ce       	rjmp	.-626    	; 0xba20 <MenuUD+0x28>
    bc92:	81 e0       	ldi	r24, 0x01	; 1
    bc94:	80 93 ff 04 	sts	0x04FF, r24
    bc98:	c3 ce       	rjmp	.-634    	; 0xba20 <MenuUD+0x28>
	Blink=0;
	OutField *Field=GetField;
	switch(prb(&Field->Type)) {
	case Byte: case EE_Byte: case z_Byte: case z_EE_Byte:
	case Word: case EE_Word: case z_Word: case z_EE_Word:
		F_Buf += Inc(Dir, F_Buf);
    bc9a:	40 91 f7 04 	lds	r20, 0x04F7
    bc9e:	50 91 f8 04 	lds	r21, 0x04F8
    bca2:	60 91 f9 04 	lds	r22, 0x04F9
    bca6:	70 91 fa 04 	lds	r23, 0x04FA
    bcaa:	8e 2d       	mov	r24, r14
    bcac:	0e 94 8f 40 	call	0x811e	; 0x811e <Inc>
    bcb0:	20 91 f7 04 	lds	r18, 0x04F7
    bcb4:	30 91 f8 04 	lds	r19, 0x04F8
    bcb8:	40 91 f9 04 	lds	r20, 0x04F9
    bcbc:	50 91 fa 04 	lds	r21, 0x04FA
    bcc0:	26 0f       	add	r18, r22
    bcc2:	37 1f       	adc	r19, r23
    bcc4:	48 1f       	adc	r20, r24
    bcc6:	59 1f       	adc	r21, r25
    bcc8:	20 93 f7 04 	sts	0x04F7, r18
    bccc:	30 93 f8 04 	sts	0x04F8, r19
    bcd0:	40 93 f9 04 	sts	0x04F9, r20
    bcd4:	50 93 fa 04 	sts	0x04FA, r21
    bcd8:	a3 ce       	rjmp	.-698    	; 0xba20 <MenuUD+0x28>
MenuUD(const MenuKey *Key, int8_t Dir, uint8_t LimLine, uint8_t LimLCD, uint8_t LimVar)
{
	if(CurrMsg || KeyFunc(Key))
		return;
	if(CurrField==NullPos) {
		if(LimLine) {
    bcda:	11 23       	and	r17, r17
    bcdc:	09 f4       	brne	.+2      	; 0xbce0 <MenuUD+0x2e8>
    bcde:	a0 ce       	rjmp	.-704    	; 0xba20 <MenuUD+0x28>
			CurrLine -= Dir;
    bce0:	80 91 ca 07 	lds	r24, 0x07CA
    bce4:	8e 19       	sub	r24, r14
    bce6:	80 93 ca 07 	sts	0x07CA, r24
			if(LimLCD)
    bcea:	ff 20       	and	r15, r15
    bcec:	09 f4       	brne	.+2      	; 0xbcf0 <MenuUD+0x2f8>
    bcee:	98 ce       	rjmp	.-720    	; 0xba20 <MenuUD+0x28>
				CurrLCD -= Dir;
    bcf0:	80 91 e8 08 	lds	r24, 0x08E8
    bcf4:	8e 19       	sub	r24, r14
    bcf6:	80 93 e8 08 	sts	0x08E8, r24
    bcfa:	92 ce       	rjmp	.-732    	; 0xba20 <MenuUD+0x28>
		if( (prd(&Field->Min) == DIGIT) && (prd(&Field->Max) == DIGIT) ){
			if(Dir==1){	if(++MultiSymbol > 9) MultiSymbol = 0;}
			else{		if(--MultiSymbol == 255) MultiSymbol = 9;}
		}
		else{
			if(Dir==1){	if(++MultiSymbol >= strlen_P(Symbols_P)) MultiSymbol = 0;}
    bcfc:	41 e0       	ldi	r20, 0x01	; 1
    bcfe:	e4 16       	cp	r14, r20
    bd00:	09 f4       	brne	.+2      	; 0xbd04 <MenuUD+0x30c>
    bd02:	6e c0       	rjmp	.+220    	; 0xbde0 <MenuUD+0x3e8>
			else{		if(--MultiSymbol == 255) MultiSymbol = strlen_P(Symbols_P)-1;}
    bd04:	80 91 f4 04 	lds	r24, 0x04F4
    bd08:	81 50       	subi	r24, 0x01	; 1
    bd0a:	80 93 f4 04 	sts	0x04F4, r24
    bd0e:	8f 3f       	cpi	r24, 0xFF	; 255
    bd10:	09 f0       	breq	.+2      	; 0xbd14 <MenuUD+0x31c>
    bd12:	ed ce       	rjmp	.-550    	; 0xbaee <MenuUD+0xf6>
    bd14:	85 e0       	ldi	r24, 0x05	; 5
    bd16:	96 e0       	ldi	r25, 0x06	; 6
    bd18:	0e 94 36 84 	call	0x1086c	; 0x1086c <strlen_P>
    bd1c:	81 50       	subi	r24, 0x01	; 1
    bd1e:	80 93 f4 04 	sts	0x04F4, r24
    bd22:	e5 ce       	rjmp	.-566    	; 0xbaee <MenuUD+0xf6>
			if(sF_Buf==0)
				Minus = !Minus;
			else
				sF_Buf = -sF_Buf;
		}
		else if(sF_Buf>0 || sF_Buf==0 && !Minus)
    bd24:	80 91 ff 04 	lds	r24, 0x04FF
    bd28:	88 23       	and	r24, r24
    bd2a:	09 f0       	breq	.+2      	; 0xbd2e <MenuUD+0x336>
    bd2c:	92 cf       	rjmp	.-220    	; 0xbc52 <MenuUD+0x25a>
			sF_Buf += Inc(Dir, sF_Buf);
    bd2e:	8e 2d       	mov	r24, r14
    bd30:	b6 01       	movw	r22, r12
    bd32:	a5 01       	movw	r20, r10
    bd34:	0e 94 8f 40 	call	0x811e	; 0x811e <Inc>
    bd38:	20 91 fb 04 	lds	r18, 0x04FB
    bd3c:	30 91 fc 04 	lds	r19, 0x04FC
    bd40:	40 91 fd 04 	lds	r20, 0x04FD
    bd44:	50 91 fe 04 	lds	r21, 0x04FE
    bd48:	26 0f       	add	r18, r22
    bd4a:	37 1f       	adc	r19, r23
    bd4c:	48 1f       	adc	r20, r24
    bd4e:	59 1f       	adc	r21, r25
    bd50:	20 93 fb 04 	sts	0x04FB, r18
    bd54:	30 93 fc 04 	sts	0x04FC, r19
    bd58:	40 93 fd 04 	sts	0x04FD, r20
    bd5c:	50 93 fe 04 	sts	0x04FE, r21
    bd60:	5f ce       	rjmp	.-834    	; 0xba20 <MenuUD+0x28>
		F_Buf += Inc(Dir, F_Buf);
		break;
	case s_Byte: case s_EE_Byte:
	case s_Word: case s_EE_Word:
		if(CurrPos==Log10(prd(&Field->Max))+1) {
			if(sF_Buf==0)
    bd62:	20 91 fb 04 	lds	r18, 0x04FB
    bd66:	30 91 fc 04 	lds	r19, 0x04FC
    bd6a:	40 91 fd 04 	lds	r20, 0x04FD
    bd6e:	50 91 fe 04 	lds	r21, 0x04FE
    bd72:	21 15       	cp	r18, r1
    bd74:	31 05       	cpc	r19, r1
    bd76:	41 05       	cpc	r20, r1
    bd78:	51 05       	cpc	r21, r1
    bd7a:	d1 f4       	brne	.+52     	; 0xbdb0 <MenuUD+0x3b8>
				Minus = !Minus;
    bd7c:	90 e0       	ldi	r25, 0x00	; 0
    bd7e:	80 91 ff 04 	lds	r24, 0x04FF
    bd82:	88 23       	and	r24, r24
    bd84:	09 f4       	brne	.+2      	; 0xbd88 <MenuUD+0x390>
    bd86:	91 e0       	ldi	r25, 0x01	; 1
    bd88:	90 93 ff 04 	sts	0x04FF, r25
    bd8c:	49 ce       	rjmp	.-878    	; 0xba20 <MenuUD+0x28>
		if(CurrPos!=NullPos)
			BufStr[CurrFieldSize - 1 - CurrPos] = prc(Symbols_P + MultiSymbol);
		break;
	case Longint: case z_Longint: case EE_Longint: case z_EE_Longint: case s_Longint: case s_EE_Longint:
	case FFloat: case EE_FFloat: case GFloat: case EE_GFloat:
		if(Dir==1)	{if(++MultiSymbol >= strlen_P(Digits_P)) MultiSymbol = 0;}
    bd8e:	00 91 f4 04 	lds	r16, 0x04F4
    bd92:	0f 5f       	subi	r16, 0xFF	; 255
    bd94:	00 93 f4 04 	sts	0x04F4, r16
    bd98:	8e ea       	ldi	r24, 0xAE	; 174
    bd9a:	96 e0       	ldi	r25, 0x06	; 6
    bd9c:	0e 94 36 84 	call	0x1086c	; 0x1086c <strlen_P>
    bda0:	10 e0       	ldi	r17, 0x00	; 0
    bda2:	08 17       	cp	r16, r24
    bda4:	19 07       	cpc	r17, r25
    bda6:	08 f4       	brcc	.+2      	; 0xbdaa <MenuUD+0x3b2>
    bda8:	ff ce       	rjmp	.-514    	; 0xbba8 <MenuUD+0x1b0>
    bdaa:	10 92 f4 04 	sts	0x04F4, r1
    bdae:	fc ce       	rjmp	.-520    	; 0xbba8 <MenuUD+0x1b0>
	case s_Word: case s_EE_Word:
		if(CurrPos==Log10(prd(&Field->Max))+1) {
			if(sF_Buf==0)
				Minus = !Minus;
			else
				sF_Buf = -sF_Buf;
    bdb0:	88 27       	eor	r24, r24
    bdb2:	99 27       	eor	r25, r25
    bdb4:	dc 01       	movw	r26, r24
    bdb6:	82 1b       	sub	r24, r18
    bdb8:	93 0b       	sbc	r25, r19
    bdba:	a4 0b       	sbc	r26, r20
    bdbc:	b5 0b       	sbc	r27, r21
    bdbe:	80 93 fb 04 	sts	0x04FB, r24
    bdc2:	90 93 fc 04 	sts	0x04FC, r25
    bdc6:	a0 93 fd 04 	sts	0x04FD, r26
    bdca:	b0 93 fe 04 	sts	0x04FE, r27
    bdce:	28 ce       	rjmp	.-944    	; 0xba20 <MenuUD+0x28>
			BufStr[CurrFieldSize - 1 - CurrPos] = prc(Symbols_P + MultiSymbol);
		break;
	case Longint: case z_Longint: case EE_Longint: case z_EE_Longint: case s_Longint: case s_EE_Longint:
	case FFloat: case EE_FFloat: case GFloat: case EE_GFloat:
		if(Dir==1)	{if(++MultiSymbol >= strlen_P(Digits_P)) MultiSymbol = 0;}
		else 		{if(--MultiSymbol == 255) MultiSymbol = strlen_P(Digits_P)-1;}
    bdd0:	8e ea       	ldi	r24, 0xAE	; 174
    bdd2:	96 e0       	ldi	r25, 0x06	; 6
    bdd4:	0e 94 36 84 	call	0x1086c	; 0x1086c <strlen_P>
    bdd8:	81 50       	subi	r24, 0x01	; 1
    bdda:	80 93 f4 04 	sts	0x04F4, r24
    bdde:	e4 ce       	rjmp	.-568    	; 0xbba8 <MenuUD+0x1b0>
		if( (prd(&Field->Min) == DIGIT) && (prd(&Field->Max) == DIGIT) ){
			if(Dir==1){	if(++MultiSymbol > 9) MultiSymbol = 0;}
			else{		if(--MultiSymbol == 255) MultiSymbol = 9;}
		}
		else{
			if(Dir==1){	if(++MultiSymbol >= strlen_P(Symbols_P)) MultiSymbol = 0;}
    bde0:	00 91 f4 04 	lds	r16, 0x04F4
    bde4:	0f 5f       	subi	r16, 0xFF	; 255
    bde6:	00 93 f4 04 	sts	0x04F4, r16
    bdea:	85 e0       	ldi	r24, 0x05	; 5
    bdec:	96 e0       	ldi	r25, 0x06	; 6
    bdee:	0e 94 36 84 	call	0x1086c	; 0x1086c <strlen_P>
    bdf2:	10 e0       	ldi	r17, 0x00	; 0
    bdf4:	08 17       	cp	r16, r24
    bdf6:	19 07       	cpc	r17, r25
    bdf8:	08 f4       	brcc	.+2      	; 0xbdfc <MenuUD+0x404>
    bdfa:	79 ce       	rjmp	.-782    	; 0xbaee <MenuUD+0xf6>
    bdfc:	10 92 f4 04 	sts	0x04F4, r1
    be00:	76 ce       	rjmp	.-788    	; 0xbaee <MenuUD+0xf6>
	case Bit: case EE_Bit:
		F_Buf = !F_Buf;
		break;
	case Text: case EE_Text:
		if( (prd(&Field->Min) == DIGIT) && (prd(&Field->Max) == DIGIT) ){
			if(Dir==1){	if(++MultiSymbol > 9) MultiSymbol = 0;}
    be02:	80 91 f4 04 	lds	r24, 0x04F4
    be06:	8f 5f       	subi	r24, 0xFF	; 255
    be08:	80 93 f4 04 	sts	0x04F4, r24
    be0c:	8a 30       	cpi	r24, 0x0A	; 10
    be0e:	08 f4       	brcc	.+2      	; 0xbe12 <MenuUD+0x41a>
    be10:	6e ce       	rjmp	.-804    	; 0xbaee <MenuUD+0xf6>
    be12:	f4 cf       	rjmp	.-24     	; 0xbdfc <MenuUD+0x404>
			else{		if(--MultiSymbol == 255) MultiSymbol = 9;}
    be14:	89 e0       	ldi	r24, 0x09	; 9
    be16:	80 93 f4 04 	sts	0x04F4, r24
    be1a:	69 ce       	rjmp	.-814    	; 0xbaee <MenuUD+0xf6>

0000be1c <MenuDown>:
}

// ~~~~~~~~~~~
void
MenuDown(void)
{
    be1c:	ef 92       	push	r14
    be1e:	ff 92       	push	r15
    be20:	0f 93       	push	r16
    be22:	1f 93       	push	r17
    be24:	cf 93       	push	r28
    be26:	df 93       	push	r29
	MenuUD(&CurrPage->Down, -1, prb(&CurrPage->LineNumber)-CurrLine>1, CurrLCD<LCDYSz-1, F_Buf>prd(&GetField->Min));
    be28:	c0 91 d4 02 	lds	r28, 0x02D4
    be2c:	d0 91 d5 02 	lds	r29, 0x02D5

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    be30:	22 96       	adiw	r28, 0x02	; 2
    be32:	fe 01       	movw	r30, r28
    be34:	24 91       	lpm	r18, Z+
    be36:	22 97       	sbiw	r28, 0x02	; 2
    be38:	40 91 ca 07 	lds	r20, 0x07CA

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    be3c:	fe 01       	movw	r30, r28
    be3e:	65 91       	lpm	r22, Z+
    be40:	74 91       	lpm	r23, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    be42:	8b e1       	ldi	r24, 0x1B	; 27
    be44:	48 9f       	mul	r20, r24
    be46:	c0 01       	movw	r24, r0
    be48:	11 24       	eor	r1, r1
    be4a:	68 0f       	add	r22, r24
    be4c:	79 1f       	adc	r23, r25
    be4e:	69 5e       	subi	r22, 0xE9	; 233
    be50:	7f 4f       	sbci	r23, 0xFF	; 255
    be52:	fb 01       	movw	r30, r22
    be54:	a5 91       	lpm	r26, Z+
    be56:	b4 91       	lpm	r27, Z+
    be58:	80 91 d6 02 	lds	r24, 0x02D6
    be5c:	90 e0       	ldi	r25, 0x00	; 0
    be5e:	82 95       	swap	r24
    be60:	92 95       	swap	r25
    be62:	90 7f       	andi	r25, 0xF0	; 240
    be64:	98 27       	eor	r25, r24
    be66:	80 7f       	andi	r24, 0xF0	; 240
    be68:	98 27       	eor	r25, r24
    be6a:	a8 0f       	add	r26, r24
    be6c:	b9 1f       	adc	r27, r25
    be6e:	13 96       	adiw	r26, 0x03	; 3
    be70:	fd 01       	movw	r30, r26
    be72:	e5 90       	lpm	r14, Z+
    be74:	f5 90       	lpm	r15, Z+
    be76:	05 91       	lpm	r16, Z+
    be78:	14 91       	lpm	r17, Z+
    be7a:	fe 01       	movw	r30, r28
    be7c:	72 96       	adiw	r30, 0x12	; 18
    be7e:	50 e0       	ldi	r21, 0x00	; 0
    be80:	30 e0       	ldi	r19, 0x00	; 0
    be82:	24 1b       	sub	r18, r20
    be84:	31 09       	sbc	r19, r1
    be86:	22 30       	cpi	r18, 0x02	; 2
    be88:	31 05       	cpc	r19, r1
    be8a:	0c f0       	brlt	.+2      	; 0xbe8e <MenuDown+0x72>
    be8c:	51 e0       	ldi	r21, 0x01	; 1
    be8e:	20 e0       	ldi	r18, 0x00	; 0
    be90:	80 91 e8 08 	lds	r24, 0x08E8
    be94:	83 30       	cpi	r24, 0x03	; 3
    be96:	08 f4       	brcc	.+2      	; 0xbe9a <MenuDown+0x7e>
    be98:	21 e0       	ldi	r18, 0x01	; 1
    be9a:	30 e0       	ldi	r19, 0x00	; 0
    be9c:	80 91 f7 04 	lds	r24, 0x04F7
    bea0:	90 91 f8 04 	lds	r25, 0x04F8
    bea4:	a0 91 f9 04 	lds	r26, 0x04F9
    bea8:	b0 91 fa 04 	lds	r27, 0x04FA
    beac:	e8 16       	cp	r14, r24
    beae:	f9 06       	cpc	r15, r25
    beb0:	0a 07       	cpc	r16, r26
    beb2:	1b 07       	cpc	r17, r27
    beb4:	08 f4       	brcc	.+2      	; 0xbeb8 <MenuDown+0x9c>
    beb6:	31 e0       	ldi	r19, 0x01	; 1
    beb8:	cf 01       	movw	r24, r30
    beba:	6f ef       	ldi	r22, 0xFF	; 255
    bebc:	45 2f       	mov	r20, r21
    bebe:	03 2f       	mov	r16, r19
    bec0:	0e 94 fc 5c 	call	0xb9f8	; 0xb9f8 <MenuUD>
}
    bec4:	df 91       	pop	r29
    bec6:	cf 91       	pop	r28
    bec8:	1f 91       	pop	r17
    beca:	0f 91       	pop	r16
    becc:	ff 90       	pop	r15
    bece:	ef 90       	pop	r14
    bed0:	08 95       	ret

0000bed2 <MenuUp>:
}

// ~~~~~~~~~
void
MenuUp(void)
{
    bed2:	ef 92       	push	r14
    bed4:	ff 92       	push	r15
    bed6:	0f 93       	push	r16
    bed8:	1f 93       	push	r17
	uint8_t Fix=GetFix();
    beda:	a0 91 d4 02 	lds	r26, 0x02D4
    bede:	b0 91 d5 02 	lds	r27, 0x02D5

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    bee2:	13 96       	adiw	r26, 0x03	; 3
    bee4:	fd 01       	movw	r30, r26
    bee6:	34 91       	lpm	r19, Z+
    bee8:	13 97       	sbiw	r26, 0x03	; 3
	MenuUD(&CurrPage->Up, 1, CurrLine>Fix, CurrLCD>Fix, F_Buf<prd(&GetField->Max));
    beea:	20 91 ca 07 	lds	r18, 0x07CA

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    beee:	fd 01       	movw	r30, r26
    bef0:	45 91       	lpm	r20, Z+
    bef2:	54 91       	lpm	r21, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    bef4:	8b e1       	ldi	r24, 0x1B	; 27
    bef6:	28 9f       	mul	r18, r24
    bef8:	c0 01       	movw	r24, r0
    befa:	11 24       	eor	r1, r1
    befc:	48 0f       	add	r20, r24
    befe:	59 1f       	adc	r21, r25
    bf00:	49 5e       	subi	r20, 0xE9	; 233
    bf02:	5f 4f       	sbci	r21, 0xFF	; 255
    bf04:	fa 01       	movw	r30, r20
    bf06:	65 91       	lpm	r22, Z+
    bf08:	74 91       	lpm	r23, Z+
    bf0a:	80 91 d6 02 	lds	r24, 0x02D6
    bf0e:	90 e0       	ldi	r25, 0x00	; 0
    bf10:	82 95       	swap	r24
    bf12:	92 95       	swap	r25
    bf14:	90 7f       	andi	r25, 0xF0	; 240
    bf16:	98 27       	eor	r25, r24
    bf18:	80 7f       	andi	r24, 0xF0	; 240
    bf1a:	98 27       	eor	r25, r24
    bf1c:	68 0f       	add	r22, r24
    bf1e:	79 1f       	adc	r23, r25
    bf20:	69 5f       	subi	r22, 0xF9	; 249
    bf22:	7f 4f       	sbci	r23, 0xFF	; 255
    bf24:	fb 01       	movw	r30, r22
    bf26:	e5 90       	lpm	r14, Z+
    bf28:	f5 90       	lpm	r15, Z+
    bf2a:	05 91       	lpm	r16, Z+
    bf2c:	14 91       	lpm	r17, Z+
    bf2e:	fd 01       	movw	r30, r26
    bf30:	70 96       	adiw	r30, 0x10	; 16
    bf32:	40 e0       	ldi	r20, 0x00	; 0
    bf34:	32 17       	cp	r19, r18
    bf36:	08 f4       	brcc	.+2      	; 0xbf3a <MenuUp+0x68>
    bf38:	41 e0       	ldi	r20, 0x01	; 1
    bf3a:	20 e0       	ldi	r18, 0x00	; 0
    bf3c:	80 91 e8 08 	lds	r24, 0x08E8
    bf40:	38 17       	cp	r19, r24
    bf42:	08 f4       	brcc	.+2      	; 0xbf46 <MenuUp+0x74>
    bf44:	21 e0       	ldi	r18, 0x01	; 1
    bf46:	30 e0       	ldi	r19, 0x00	; 0
    bf48:	80 91 f7 04 	lds	r24, 0x04F7
    bf4c:	90 91 f8 04 	lds	r25, 0x04F8
    bf50:	a0 91 f9 04 	lds	r26, 0x04F9
    bf54:	b0 91 fa 04 	lds	r27, 0x04FA
    bf58:	8e 15       	cp	r24, r14
    bf5a:	9f 05       	cpc	r25, r15
    bf5c:	a0 07       	cpc	r26, r16
    bf5e:	b1 07       	cpc	r27, r17
    bf60:	08 f4       	brcc	.+2      	; 0xbf64 <MenuUp+0x92>
    bf62:	31 e0       	ldi	r19, 0x01	; 1
    bf64:	cf 01       	movw	r24, r30
    bf66:	61 e0       	ldi	r22, 0x01	; 1
    bf68:	03 2f       	mov	r16, r19
    bf6a:	0e 94 fc 5c 	call	0xb9f8	; 0xb9f8 <MenuUD>
}
    bf6e:	1f 91       	pop	r17
    bf70:	0f 91       	pop	r16
    bf72:	ff 90       	pop	r15
    bf74:	ef 90       	pop	r14
    bf76:	08 95       	ret

0000bf78 <PutField>:
	sprintf(Param->Pos, Format, Val);
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
PutField(uint8_t Type, void *Var, T_Param *Param)
{
    bf78:	af 92       	push	r10
    bf7a:	bf 92       	push	r11
    bf7c:	cf 92       	push	r12
    bf7e:	df 92       	push	r13
    bf80:	ef 92       	push	r14
    bf82:	ff 92       	push	r15
    bf84:	0f 93       	push	r16
    bf86:	1f 93       	push	r17
    bf88:	df 93       	push	r29
    bf8a:	cf 93       	push	r28
    bf8c:	cd b7       	in	r28, 0x3d	; 61
    bf8e:	de b7       	in	r29, 0x3e	; 62
    bf90:	69 97       	sbiw	r28, 0x19	; 25
    bf92:	0f b6       	in	r0, 0x3f	; 63
    bf94:	f8 94       	cli
    bf96:	de bf       	out	0x3e, r29	; 62
    bf98:	0f be       	out	0x3f, r0	; 63
    bf9a:	cd bf       	out	0x3d, r28	; 61
    bf9c:	db 01       	movw	r26, r22
    bf9e:	7a 01       	movw	r14, r20
	float fTemp;

	switch(Type) {
    bfa0:	e8 2f       	mov	r30, r24
    bfa2:	f0 e0       	ldi	r31, 0x00	; 0
    bfa4:	e3 32       	cpi	r30, 0x23	; 35
    bfa6:	f1 05       	cpc	r31, r1
    bfa8:	88 f5       	brcc	.+98     	; 0xc00c <PutField+0x94>
    bfaa:	e7 52       	subi	r30, 0x27	; 39
    bfac:	ff 4f       	sbci	r31, 0xFF	; 255
    bfae:	ee 0f       	add	r30, r30
    bfb0:	ff 1f       	adc	r31, r31
    bfb2:	05 90       	lpm	r0, Z+
    bfb4:	f4 91       	lpm	r31, Z+
    bfb6:	e0 2d       	mov	r30, r0
    bfb8:	19 94       	eijmp
		break;
	case Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((*((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
		break;
	case EE_Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((erb((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
    bfba:	fa 01       	movw	r30, r20
    bfbc:	a0 80       	ld	r10, Z
    bfbe:	b1 80       	ldd	r11, Z+1	; 0x01
    bfc0:	c4 80       	ldd	r12, Z+4	; 0x04
    bfc2:	d5 80       	ldd	r13, Z+5	; 0x05
    bfc4:	12 81       	ldd	r17, Z+2	; 0x02
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    bfc6:	81 2f       	mov	r24, r17
    bfc8:	86 95       	lsr	r24
    bfca:	86 95       	lsr	r24
    bfcc:	86 95       	lsr	r24
    bfce:	9b 01       	movw	r18, r22
    bfd0:	28 0f       	add	r18, r24
    bfd2:	31 1d       	adc	r19, r1
    bfd4:	c9 01       	movw	r24, r18
    bfd6:	0e 94 50 87 	call	0x10ea0	; 0x10ea0 <__eerd_byte_m2560>
    bfda:	17 70       	andi	r17, 0x07	; 7
    bfdc:	21 e0       	ldi	r18, 0x01	; 1
    bfde:	30 e0       	ldi	r19, 0x00	; 0
    bfe0:	02 c0       	rjmp	.+4      	; 0xbfe6 <PutField+0x6e>
    bfe2:	22 0f       	add	r18, r18
    bfe4:	33 1f       	adc	r19, r19
    bfe6:	1a 95       	dec	r17
    bfe8:	e2 f7       	brpl	.-8      	; 0xbfe2 <PutField+0x6a>
    bfea:	90 e0       	ldi	r25, 0x00	; 0
    bfec:	28 23       	and	r18, r24
    bfee:	39 23       	and	r19, r25
    bff0:	12 16       	cp	r1, r18
    bff2:	13 06       	cpc	r1, r19
    bff4:	0c f0       	brlt	.+2      	; 0xbff8 <PutField+0x80>
    bff6:	3f c1       	rjmp	.+638    	; 0xc276 <PutField+0x2fe>
    bff8:	82 e0       	ldi	r24, 0x02	; 2
    bffa:	90 e0       	ldi	r25, 0x00	; 0

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    bffc:	f6 01       	movw	r30, r12
    bffe:	e8 0f       	add	r30, r24
    c000:	f9 1f       	adc	r31, r25
    c002:	65 91       	lpm	r22, Z+
    c004:	74 91       	lpm	r23, Z+
    c006:	c5 01       	movw	r24, r10
    c008:	0e 94 2f 84 	call	0x1085e	; 0x1085e <strcpy_P>
			erbl(TempStr, Var, Param->Size);
			Put_TextValAlignRight(TempStr, Param);
		}
		break;
	}
}
    c00c:	69 96       	adiw	r28, 0x19	; 25
    c00e:	0f b6       	in	r0, 0x3f	; 63
    c010:	f8 94       	cli
    c012:	de bf       	out	0x3e, r29	; 62
    c014:	0f be       	out	0x3f, r0	; 63
    c016:	cd bf       	out	0x3d, r28	; 61
    c018:	cf 91       	pop	r28
    c01a:	df 91       	pop	r29
    c01c:	1f 91       	pop	r17
    c01e:	0f 91       	pop	r16
    c020:	ff 90       	pop	r15
    c022:	ef 90       	pop	r14
    c024:	df 90       	pop	r13
    c026:	cf 90       	pop	r12
    c028:	bf 90       	pop	r11
    c02a:	af 90       	pop	r10
    c02c:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    c02e:	8e 01       	movw	r16, r28
    c030:	0b 5f       	subi	r16, 0xFB	; 251
    c032:	1f 4f       	sbci	r17, 0xFF	; 255
    c034:	fa 01       	movw	r30, r20
    c036:	43 81       	ldd	r20, Z+3	; 0x03
    c038:	c8 01       	movw	r24, r16
    c03a:	50 e0       	ldi	r21, 0x00	; 0
    c03c:	0e 94 40 87 	call	0x10e80	; 0x10e80 <__eerd_block_m2560>
		Put_TextValAlignRight(Var, Param);
		break;
	case EE_Text:{
			char TempStr[LCDXSz+1];
			erbl(TempStr, Var, Param->Size);
			Put_TextValAlignRight(TempStr, Param);
    c040:	c8 01       	movw	r24, r16
    c042:	b7 01       	movw	r22, r14
    c044:	0e 94 d8 46 	call	0x8db0	; 0x8db0 <Put_TextValAlignRight>
    c048:	e1 cf       	rjmp	.-62     	; 0xc00c <PutField+0x94>
	case EE_Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((erb((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
		break;

	case Text:
		Put_TextValAlignRight(Var, Param);
    c04a:	cb 01       	movw	r24, r22
    c04c:	ba 01       	movw	r22, r20
    c04e:	0e 94 d8 46 	call	0x8db0	; 0x8db0 <Put_TextValAlignRight>
    c052:	dc cf       	rjmp	.-72     	; 0xc00c <PutField+0x94>
	case EE_Enum:
		Param->Txt += erb((uint8_t*)Var);
		PutEnum(Param);
		break;
	case Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((*((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
    c054:	fa 01       	movw	r30, r20
    c056:	00 81       	ld	r16, Z
    c058:	11 81       	ldd	r17, Z+1	; 0x01
    c05a:	64 81       	ldd	r22, Z+4	; 0x04
    c05c:	75 81       	ldd	r23, Z+5	; 0x05
    c05e:	42 81       	ldd	r20, Z+2	; 0x02
    c060:	84 2f       	mov	r24, r20
    c062:	86 95       	lsr	r24
    c064:	86 95       	lsr	r24
    c066:	86 95       	lsr	r24
    c068:	a8 0f       	add	r26, r24
    c06a:	b1 1d       	adc	r27, r1
    c06c:	2c 91       	ld	r18, X
    c06e:	30 e0       	ldi	r19, 0x00	; 0
    c070:	47 70       	andi	r20, 0x07	; 7
    c072:	81 e0       	ldi	r24, 0x01	; 1
    c074:	90 e0       	ldi	r25, 0x00	; 0
    c076:	02 c0       	rjmp	.+4      	; 0xc07c <PutField+0x104>
    c078:	88 0f       	add	r24, r24
    c07a:	99 1f       	adc	r25, r25
    c07c:	4a 95       	dec	r20
    c07e:	e2 f7       	brpl	.-8      	; 0xc078 <PutField+0x100>
    c080:	28 23       	and	r18, r24
    c082:	39 23       	and	r19, r25
    c084:	12 16       	cp	r1, r18
    c086:	13 06       	cpc	r1, r19
    c088:	0c f0       	brlt	.+2      	; 0xc08c <PutField+0x114>
    c08a:	f8 c0       	rjmp	.+496    	; 0xc27c <PutField+0x304>
    c08c:	82 e0       	ldi	r24, 0x02	; 2
    c08e:	90 e0       	ldi	r25, 0x00	; 0

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    c090:	fb 01       	movw	r30, r22
    c092:	e8 0f       	add	r30, r24
    c094:	f9 1f       	adc	r31, r25
    c096:	65 91       	lpm	r22, Z+
    c098:	74 91       	lpm	r23, Z+
    c09a:	c8 01       	movw	r24, r16
    c09c:	0e 94 2f 84 	call	0x1085e	; 0x1085e <strcpy_P>
    c0a0:	b5 cf       	rjmp	.-150    	; 0xc00c <PutField+0x94>
		Put_GFVal(fTemp, Param);
		break;


	case Enum:
		Param->Txt += *(uint8_t*)Var;
    c0a2:	2c 91       	ld	r18, X
    c0a4:	30 e0       	ldi	r19, 0x00	; 0
    c0a6:	22 0f       	add	r18, r18
    c0a8:	33 1f       	adc	r19, r19
    c0aa:	f7 01       	movw	r30, r14
    c0ac:	84 81       	ldd	r24, Z+4	; 0x04
    c0ae:	95 81       	ldd	r25, Z+5	; 0x05
    c0b0:	82 0f       	add	r24, r18
    c0b2:	93 1f       	adc	r25, r19
    c0b4:	95 83       	std	Z+5, r25	; 0x05
    c0b6:	84 83       	std	Z+4, r24	; 0x04
		PutEnum(Param);
    c0b8:	c7 01       	movw	r24, r14
    c0ba:	0e 94 84 44 	call	0x8908	; 0x8908 <PutEnum>
    c0be:	a6 cf       	rjmp	.-180    	; 0xc00c <PutField+0x94>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    c0c0:	cb 01       	movw	r24, r22
    c0c2:	0e 94 50 87 	call	0x10ea0	; 0x10ea0 <__eerd_byte_m2560>
		break;
	case EE_Enum:
		Param->Txt += erb((uint8_t*)Var);
    c0c6:	90 e0       	ldi	r25, 0x00	; 0
    c0c8:	88 0f       	add	r24, r24
    c0ca:	99 1f       	adc	r25, r25
    c0cc:	f7 01       	movw	r30, r14
    c0ce:	24 81       	ldd	r18, Z+4	; 0x04
    c0d0:	35 81       	ldd	r19, Z+5	; 0x05
    c0d2:	28 0f       	add	r18, r24
    c0d4:	39 1f       	adc	r19, r25
    c0d6:	35 83       	std	Z+5, r19	; 0x05
    c0d8:	24 83       	std	Z+4, r18	; 0x04
		PutEnum(Param);
    c0da:	c7 01       	movw	r24, r14
    c0dc:	0e 94 84 44 	call	0x8908	; 0x8908 <PutEnum>
    c0e0:	95 cf       	rjmp	.-214    	; 0xc00c <PutField+0x94>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    c0e2:	ce 01       	movw	r24, r28
    c0e4:	01 96       	adiw	r24, 0x01	; 1
    c0e6:	44 e0       	ldi	r20, 0x04	; 4
    c0e8:	50 e0       	ldi	r21, 0x00	; 0
    c0ea:	0e 94 40 87 	call	0x10e80	; 0x10e80 <__eerd_block_m2560>
	case GFloat:
		Put_GFVal(*(float*)Var, Param);
		break;			
	case EE_GFloat:
		erbl(&fTemp, Var, 4);
		Put_GFVal(fTemp, Param);
    c0ee:	69 81       	ldd	r22, Y+1	; 0x01
    c0f0:	7a 81       	ldd	r23, Y+2	; 0x02
    c0f2:	8b 81       	ldd	r24, Y+3	; 0x03
    c0f4:	9c 81       	ldd	r25, Y+4	; 0x04
    c0f6:	a7 01       	movw	r20, r14
    c0f8:	0e 94 34 47 	call	0x8e68	; 0x8e68 <Put_GFVal>
    c0fc:	87 cf       	rjmp	.-242    	; 0xc00c <PutField+0x94>
	case EE_FFloat:
		erbl(&fTemp, Var, 4);
		Put_FFVal(fTemp, Param);
		break;
	case GFloat:
		Put_GFVal(*(float*)Var, Param);
    c0fe:	6d 91       	ld	r22, X+
    c100:	7d 91       	ld	r23, X+
    c102:	8d 91       	ld	r24, X+
    c104:	9c 91       	ld	r25, X
    c106:	0e 94 34 47 	call	0x8e68	; 0x8e68 <Put_GFVal>
    c10a:	80 cf       	rjmp	.-256    	; 0xc00c <PutField+0x94>
    c10c:	ce 01       	movw	r24, r28
    c10e:	01 96       	adiw	r24, 0x01	; 1
    c110:	44 e0       	ldi	r20, 0x04	; 4
    c112:	50 e0       	ldi	r21, 0x00	; 0
    c114:	0e 94 40 87 	call	0x10e80	; 0x10e80 <__eerd_block_m2560>
	case FFloat:
		Put_FFVal(*(float*)Var, Param);
		break;			
	case EE_FFloat:
		erbl(&fTemp, Var, 4);
		Put_FFVal(fTemp, Param);
    c118:	69 81       	ldd	r22, Y+1	; 0x01
    c11a:	7a 81       	ldd	r23, Y+2	; 0x02
    c11c:	8b 81       	ldd	r24, Y+3	; 0x03
    c11e:	9c 81       	ldd	r25, Y+4	; 0x04
    c120:	a7 01       	movw	r20, r14
    c122:	0e 94 ae 47 	call	0x8f5c	; 0x8f5c <Put_FFVal>
    c126:	72 cf       	rjmp	.-284    	; 0xc00c <PutField+0x94>
		Put_zDVal(erd((uint32_t*)Var), Param);
		break;

		
	case FFloat:
		Put_FFVal(*(float*)Var, Param);
    c128:	6d 91       	ld	r22, X+
    c12a:	7d 91       	ld	r23, X+
    c12c:	8d 91       	ld	r24, X+
    c12e:	9c 91       	ld	r25, X
    c130:	0e 94 ae 47 	call	0x8f5c	; 0x8f5c <Put_FFVal>
    c134:	6b cf       	rjmp	.-298    	; 0xc00c <PutField+0x94>
		break;
	case zh_Word:
		Put_zVal_h(*(uint16_t*)Var, 'w', Param);
		break;
	case zh_Longint:
		Put_zVal_h(*(uint32_t*)Var, 'l', Param);
    c136:	6d 91       	ld	r22, X+
    c138:	7d 91       	ld	r23, X+
    c13a:	8d 91       	ld	r24, X+
    c13c:	9c 91       	ld	r25, X
    c13e:	4c e6       	ldi	r20, 0x6C	; 108
    c140:	97 01       	movw	r18, r14
    c142:	0e 94 6e 4b 	call	0x96dc	; 0x96dc <Put_zVal_h>
    c146:	62 cf       	rjmp	.-316    	; 0xc00c <PutField+0x94>
// ~~~~~~~~~~~~~~~~~~~~~~
uint32_t
erd(const uint32_t *addr)
{
	//IntOff();
	uint32_t word = eeprom_read_dword(addr);
    c148:	cb 01       	movw	r24, r22
    c14a:	0e 94 58 87 	call	0x10eb0	; 0x10eb0 <__eerd_dword_m2560>
		break;
	case z_Longint: case zc_Longint:
		Put_zDVal(*(uint32_t*)Var, Param);
		break;
	case z_EE_Longint:
		Put_zDVal(erd((uint32_t*)Var), Param);
    c14e:	a7 01       	movw	r20, r14
    c150:	0e 94 03 48 	call	0x9006	; 0x9006 <Put_zDVal>
    c154:	5b cf       	rjmp	.-330    	; 0xc00c <PutField+0x94>
		break;
	case s_EE_Longint:
		Put_sDVal((int32_t)erd((uint32_t*)Var), Param);
		break;
	case z_Longint: case zc_Longint:
		Put_zDVal(*(uint32_t*)Var, Param);
    c156:	6d 91       	ld	r22, X+
    c158:	7d 91       	ld	r23, X+
    c15a:	8d 91       	ld	r24, X+
    c15c:	9c 91       	ld	r25, X
    c15e:	0e 94 03 48 	call	0x9006	; 0x9006 <Put_zDVal>
    c162:	54 cf       	rjmp	.-344    	; 0xc00c <PutField+0x94>
    c164:	cb 01       	movw	r24, r22
    c166:	0e 94 58 87 	call	0x10eb0	; 0x10eb0 <__eerd_dword_m2560>
		break;
	case s_Longint:
		Put_sDVal(*(int32_t*)Var, Param);
		break;
	case s_EE_Longint:
		Put_sDVal((int32_t)erd((uint32_t*)Var), Param);
    c16a:	a7 01       	movw	r20, r14
    c16c:	0e 94 24 49 	call	0x9248	; 0x9248 <Put_sDVal>
    c170:	4d cf       	rjmp	.-358    	; 0xc00c <PutField+0x94>
		break;
	case EE_Longint:
		PutDVal(erd((uint32_t*)Var), Param);
		break;
	case s_Longint:
		Put_sDVal(*(int32_t*)Var, Param);
    c172:	6d 91       	ld	r22, X+
    c174:	7d 91       	ld	r23, X+
    c176:	8d 91       	ld	r24, X+
    c178:	9c 91       	ld	r25, X
    c17a:	0e 94 24 49 	call	0x9248	; 0x9248 <Put_sDVal>
    c17e:	46 cf       	rjmp	.-372    	; 0xc00c <PutField+0x94>
    c180:	cb 01       	movw	r24, r22
    c182:	0e 94 58 87 	call	0x10eb0	; 0x10eb0 <__eerd_dword_m2560>

	case Longint: case c_Longint:
		PutDVal(*(uint32_t*)Var, Param);
		break;
	case EE_Longint:
		PutDVal(erd((uint32_t*)Var), Param);
    c186:	a7 01       	movw	r20, r14
    c188:	0e 94 4d 4a 	call	0x949a	; 0x949a <PutDVal>
    c18c:	3f cf       	rjmp	.-386    	; 0xc00c <PutField+0x94>
		Put_zVal(erw((uint16_t*)Var), 'w', Param);
		break;


	case Longint: case c_Longint:
		PutDVal(*(uint32_t*)Var, Param);
    c18e:	6d 91       	ld	r22, X+
    c190:	7d 91       	ld	r23, X+
    c192:	8d 91       	ld	r24, X+
    c194:	9c 91       	ld	r25, X
    c196:	0e 94 4d 4a 	call	0x949a	; 0x949a <PutDVal>
    c19a:	38 cf       	rjmp	.-400    	; 0xc00c <PutField+0x94>

	case zh_Byte:
		Put_zVal_h(*(uint8_t*)Var, 'b', Param);
		break;
	case zh_Word:
		Put_zVal_h(*(uint16_t*)Var, 'w', Param);
    c19c:	6d 91       	ld	r22, X+
    c19e:	7c 91       	ld	r23, X
    c1a0:	80 e0       	ldi	r24, 0x00	; 0
    c1a2:	90 e0       	ldi	r25, 0x00	; 0
    c1a4:	47 e7       	ldi	r20, 0x77	; 119
    c1a6:	97 01       	movw	r18, r14
    c1a8:	0e 94 6e 4b 	call	0x96dc	; 0x96dc <Put_zVal_h>
    c1ac:	2f cf       	rjmp	.-418    	; 0xc00c <PutField+0x94>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    c1ae:	cb 01       	movw	r24, r22
    c1b0:	0e 94 5e 87 	call	0x10ebc	; 0x10ebc <__eerd_word_m2560>
		break;
	case z_Word: case zc_Word:
		Put_zVal(*(uint16_t*)Var, 'w', Param);
		break;
	case z_EE_Word:
		Put_zVal(erw((uint16_t*)Var), 'w', Param);
    c1b4:	67 e7       	ldi	r22, 0x77	; 119
    c1b6:	a7 01       	movw	r20, r14
    c1b8:	0e 94 e1 4b 	call	0x97c2	; 0x97c2 <Put_zVal>
    c1bc:	27 cf       	rjmp	.-434    	; 0xc00c <PutField+0x94>
		break;
	case s_EE_Word:
		Put_sVal((int16_t)erw((uint16_t*)Var), 'w', Param);
		break;
	case z_Word: case zc_Word:
		Put_zVal(*(uint16_t*)Var, 'w', Param);
    c1be:	8d 91       	ld	r24, X+
    c1c0:	9c 91       	ld	r25, X
    c1c2:	67 e7       	ldi	r22, 0x77	; 119
    c1c4:	0e 94 e1 4b 	call	0x97c2	; 0x97c2 <Put_zVal>
    c1c8:	21 cf       	rjmp	.-446    	; 0xc00c <PutField+0x94>
    c1ca:	cb 01       	movw	r24, r22
    c1cc:	0e 94 5e 87 	call	0x10ebc	; 0x10ebc <__eerd_word_m2560>
		break;
	case s_Word:
		Put_sVal(*(int16_t*)Var, 'w', Param);
		break;
	case s_EE_Word:
		Put_sVal((int16_t)erw((uint16_t*)Var), 'w', Param);
    c1d0:	67 e7       	ldi	r22, 0x77	; 119
    c1d2:	a7 01       	movw	r20, r14
    c1d4:	0e 94 9e 4c 	call	0x993c	; 0x993c <Put_sVal>
    c1d8:	19 cf       	rjmp	.-462    	; 0xc00c <PutField+0x94>
		break;
	case EE_Word:
		PutVal(erw((uint16_t*)Var), 'w', Param);
		break;
	case s_Word:
		Put_sVal(*(int16_t*)Var, 'w', Param);
    c1da:	8d 91       	ld	r24, X+
    c1dc:	9c 91       	ld	r25, X
    c1de:	67 e7       	ldi	r22, 0x77	; 119
    c1e0:	0e 94 9e 4c 	call	0x993c	; 0x993c <Put_sVal>
    c1e4:	13 cf       	rjmp	.-474    	; 0xc00c <PutField+0x94>
    c1e6:	cb 01       	movw	r24, r22
    c1e8:	0e 94 5e 87 	call	0x10ebc	; 0x10ebc <__eerd_word_m2560>

	case Word: case c_Word:
		PutVal(*(uint16_t*)Var, 'w', Param);
		break;
	case EE_Word:
		PutVal(erw((uint16_t*)Var), 'w', Param);
    c1ec:	67 e7       	ldi	r22, 0x77	; 119
    c1ee:	a7 01       	movw	r20, r14
    c1f0:	0e 94 82 4d 	call	0x9b04	; 0x9b04 <PutVal>
    c1f4:	0b cf       	rjmp	.-490    	; 0xc00c <PutField+0x94>
	case zh_Longint:
		Put_zVal_h(*(uint32_t*)Var, 'l', Param);
		break;

	case Word: case c_Word:
		PutVal(*(uint16_t*)Var, 'w', Param);
    c1f6:	8d 91       	ld	r24, X+
    c1f8:	9c 91       	ld	r25, X
    c1fa:	67 e7       	ldi	r22, 0x77	; 119
    c1fc:	0e 94 82 4d 	call	0x9b04	; 0x9b04 <PutVal>
    c200:	05 cf       	rjmp	.-502    	; 0xc00c <PutField+0x94>
	case z_EE_Byte:
		Put_zVal(erb((uint8_t*)Var), 'b', Param);
		break;

	case zh_Byte:
		Put_zVal_h(*(uint8_t*)Var, 'b', Param);
    c202:	6c 91       	ld	r22, X
    c204:	70 e0       	ldi	r23, 0x00	; 0
    c206:	80 e0       	ldi	r24, 0x00	; 0
    c208:	90 e0       	ldi	r25, 0x00	; 0
    c20a:	42 e6       	ldi	r20, 0x62	; 98
    c20c:	97 01       	movw	r18, r14
    c20e:	0e 94 6e 4b 	call	0x96dc	; 0x96dc <Put_zVal_h>
    c212:	fc ce       	rjmp	.-520    	; 0xc00c <PutField+0x94>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    c214:	cb 01       	movw	r24, r22
    c216:	0e 94 50 87 	call	0x10ea0	; 0x10ea0 <__eerd_byte_m2560>
		break;
	case z_Byte:
		Put_zVal(*(uint8_t*)Var, 'b', Param);
		break;
	case z_EE_Byte:
		Put_zVal(erb((uint8_t*)Var), 'b', Param);
    c21a:	90 e0       	ldi	r25, 0x00	; 0
    c21c:	62 e6       	ldi	r22, 0x62	; 98
    c21e:	a7 01       	movw	r20, r14
    c220:	0e 94 e1 4b 	call	0x97c2	; 0x97c2 <Put_zVal>
    c224:	f3 ce       	rjmp	.-538    	; 0xc00c <PutField+0x94>
		break;
	case s_EE_Byte:
		Put_sVal((int8_t)erb((uint8_t*)Var), 'b', Param);
		break;
	case z_Byte:
		Put_zVal(*(uint8_t*)Var, 'b', Param);
    c226:	8c 91       	ld	r24, X
    c228:	90 e0       	ldi	r25, 0x00	; 0
    c22a:	62 e6       	ldi	r22, 0x62	; 98
    c22c:	0e 94 e1 4b 	call	0x97c2	; 0x97c2 <Put_zVal>
    c230:	ed ce       	rjmp	.-550    	; 0xc00c <PutField+0x94>
    c232:	cb 01       	movw	r24, r22
    c234:	0e 94 50 87 	call	0x10ea0	; 0x10ea0 <__eerd_byte_m2560>
		break;
	case s_Byte:
		Put_sVal(*(int8_t*)Var, 'b', Param);
		break;
	case s_EE_Byte:
		Put_sVal((int8_t)erb((uint8_t*)Var), 'b', Param);
    c238:	99 27       	eor	r25, r25
    c23a:	87 fd       	sbrc	r24, 7
    c23c:	90 95       	com	r25
    c23e:	62 e6       	ldi	r22, 0x62	; 98
    c240:	a7 01       	movw	r20, r14
    c242:	0e 94 9e 4c 	call	0x993c	; 0x993c <Put_sVal>
    c246:	e2 ce       	rjmp	.-572    	; 0xc00c <PutField+0x94>
		break;
	case EE_Byte:
		PutVal(erb((uint8_t*)Var), 'b', Param);
		break;
	case s_Byte:
		Put_sVal(*(int8_t*)Var, 'b', Param);
    c248:	8c 91       	ld	r24, X
    c24a:	99 27       	eor	r25, r25
    c24c:	87 fd       	sbrc	r24, 7
    c24e:	90 95       	com	r25
    c250:	62 e6       	ldi	r22, 0x62	; 98
    c252:	0e 94 9e 4c 	call	0x993c	; 0x993c <Put_sVal>
    c256:	da ce       	rjmp	.-588    	; 0xc00c <PutField+0x94>
    c258:	cb 01       	movw	r24, r22
    c25a:	0e 94 50 87 	call	0x10ea0	; 0x10ea0 <__eerd_byte_m2560>
	switch(Type) {
	case Byte:
		PutVal(*(uint8_t*)Var, 'b', Param);
		break;
	case EE_Byte:
		PutVal(erb((uint8_t*)Var), 'b', Param);
    c25e:	90 e0       	ldi	r25, 0x00	; 0
    c260:	62 e6       	ldi	r22, 0x62	; 98
    c262:	a7 01       	movw	r20, r14
    c264:	0e 94 82 4d 	call	0x9b04	; 0x9b04 <PutVal>
    c268:	d1 ce       	rjmp	.-606    	; 0xc00c <PutField+0x94>
{
	float fTemp;

	switch(Type) {
	case Byte:
		PutVal(*(uint8_t*)Var, 'b', Param);
    c26a:	8c 91       	ld	r24, X
    c26c:	90 e0       	ldi	r25, 0x00	; 0
    c26e:	62 e6       	ldi	r22, 0x62	; 98
    c270:	0e 94 82 4d 	call	0x9b04	; 0x9b04 <PutVal>
    c274:	cb ce       	rjmp	.-618    	; 0xc00c <PutField+0x94>
		break;
	case Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((*((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
		break;
	case EE_Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((erb((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
    c276:	80 e0       	ldi	r24, 0x00	; 0
    c278:	90 e0       	ldi	r25, 0x00	; 0
    c27a:	c0 ce       	rjmp	.-640    	; 0xbffc <PutField+0x84>
	case EE_Enum:
		Param->Txt += erb((uint8_t*)Var);
		PutEnum(Param);
		break;
	case Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((*((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
    c27c:	80 e0       	ldi	r24, 0x00	; 0
    c27e:	90 e0       	ldi	r25, 0x00	; 0
    c280:	07 cf       	rjmp	.-498    	; 0xc090 <PutField+0x118>

0000c282 <PutLine>:
	PosBlink(Param,'_');
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
PutLine(uint8_t LineN, uint8_t Y)
{
    c282:	2f 92       	push	r2
    c284:	3f 92       	push	r3
    c286:	4f 92       	push	r4
    c288:	5f 92       	push	r5
    c28a:	6f 92       	push	r6
    c28c:	7f 92       	push	r7
    c28e:	8f 92       	push	r8
    c290:	9f 92       	push	r9
    c292:	af 92       	push	r10
    c294:	bf 92       	push	r11
    c296:	cf 92       	push	r12
    c298:	df 92       	push	r13
    c29a:	ef 92       	push	r14
    c29c:	ff 92       	push	r15
    c29e:	0f 93       	push	r16
    c2a0:	1f 93       	push	r17
    c2a2:	df 93       	push	r29
    c2a4:	cf 93       	push	r28
    c2a6:	cd b7       	in	r28, 0x3d	; 61
    c2a8:	de b7       	in	r29, 0x3e	; 62
    c2aa:	60 97       	sbiw	r28, 0x10	; 16
    c2ac:	0f b6       	in	r0, 0x3f	; 63
    c2ae:	f8 94       	cli
    c2b0:	de bf       	out	0x3e, r29	; 62
    c2b2:	0f be       	out	0x3f, r0	; 63
    c2b4:	cd bf       	out	0x3d, r28	; 61
    c2b6:	8f 87       	std	Y+15, r24	; 0x0f
    c2b8:	68 8b       	std	Y+16, r22	; 0x10

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    c2ba:	e0 91 d4 02 	lds	r30, 0x02D4
    c2be:	f0 91 d5 02 	lds	r31, 0x02D5
    c2c2:	e5 90       	lpm	r14, Z+
    c2c4:	f4 90       	lpm	r15, Z+
	MenuLine *Line=GetLine+LineN;
    c2c6:	8b e1       	ldi	r24, 0x1B	; 27
    c2c8:	2f 85       	ldd	r18, Y+15	; 0x0f
    c2ca:	28 9f       	mul	r18, r24
    c2cc:	c0 01       	movw	r24, r0
    c2ce:	11 24       	eor	r1, r1
    c2d0:	e8 0e       	add	r14, r24
    c2d2:	f9 1e       	adc	r15, r25
	PGM_P CurrStr=(PGM_P)(Line->Str);
    c2d4:	be 2c       	mov	r11, r14
    c2d6:	af 2c       	mov	r10, r15
    c2d8:	f7 01       	movw	r30, r14
    c2da:	75 96       	adiw	r30, 0x15	; 21
    c2dc:	c5 90       	lpm	r12, Z+
    c2de:	d4 90       	lpm	r13, Z+

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    c2e0:	f7 01       	movw	r30, r14
    c2e2:	77 96       	adiw	r30, 0x17	; 23
    c2e4:	85 91       	lpm	r24, Z+
    c2e6:	94 91       	lpm	r25, Z+
    c2e8:	9e 87       	std	Y+14, r25	; 0x0e
    c2ea:	8d 87       	std	Y+13, r24	; 0x0d
    c2ec:	87 01       	movw	r16, r14
    c2ee:	f7 01       	movw	r30, r14
    c2f0:	84 91       	lpm	r24, Z+
	uint8_t X;
	uint8_t X0=0;
	uint8_t X1=LCDXSz;
	int8_t Xs = 0;
	//--- ">>" Align right
	if(prc(CurrStr+0) == '>' && prc(CurrStr+1) == '>'){
    c2f2:	8e 33       	cpi	r24, 0x3E	; 62
    c2f4:	09 f4       	brne	.+2      	; 0xc2f8 <PutLine+0x76>
    c2f6:	a6 c1       	rjmp	.+844    	; 0xc644 <PutLine+0x3c2>
		X0 = LCDXSz - strlen_P(CurrStr) + 2;
		Xs = X0-2;
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';
    c2f8:	40 e0       	ldi	r20, 0x00	; 0
    c2fa:	50 e0       	ldi	r21, 0x00	; 0
    c2fc:	f8 01       	movw	r30, r16
    c2fe:	84 91       	lpm	r24, Z+
	}
	//--- "<<" Align left
	if(prc(CurrStr+0) == '<' && prc(CurrStr+1) == '<'){
    c300:	8c 33       	cpi	r24, 0x3C	; 60
    c302:	09 f4       	brne	.+2      	; 0xc306 <PutLine+0x84>
    c304:	8a c1       	rjmp	.+788    	; 0xc61a <PutLine+0x398>
		X1 = strlen_P(CurrStr) - 2;
    c306:	84 e1       	ldi	r24, 0x14	; 20
    c308:	98 2e       	mov	r9, r24
    c30a:	f8 01       	movw	r30, r16
    c30c:	84 91       	lpm	r24, Z+
		X0 = 0;
		Xs = X0-2;
	}
	//--- "<>" Align center
	if(prc(CurrStr+0) == '<' && prc(CurrStr+1) == '>'){
    c30e:	8c 33       	cpi	r24, 0x3C	; 60
    c310:	09 f4       	brne	.+2      	; 0xc314 <PutLine+0x92>
    c312:	56 c1       	rjmp	.+684    	; 0xc5c0 <PutLine+0x33e>
		Xs = X0-2;
		X1 = X0 + (strlen_P(CurrStr) - 2);
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';		
	}
	//---
	for(X=X0; X<X1; X++){
    c314:	49 15       	cp	r20, r9
    c316:	08 f0       	brcs	.+2      	; 0xc31a <PutLine+0x98>
    c318:	ac c0       	rjmp	.+344    	; 0xc472 <PutLine+0x1f0>
static void
PutLine(uint8_t LineN, uint8_t Y)
{
	MenuLine *Line=GetLine+LineN;
	PGM_P CurrStr=(PGM_P)(Line->Str);
	InField *IF = prp(&Line->IF_List);
    c31a:	88 89       	ldd	r24, Y+16	; 0x10
    c31c:	28 2f       	mov	r18, r24
    c31e:	30 e0       	ldi	r19, 0x00	; 0
    c320:	c9 01       	movw	r24, r18
    c322:	88 0f       	add	r24, r24
    c324:	99 1f       	adc	r25, r25
    c326:	82 0f       	add	r24, r18
    c328:	93 1f       	adc	r25, r19
    c32a:	5c 01       	movw	r10, r24
    c32c:	aa 0c       	add	r10, r10
    c32e:	bb 1c       	adc	r11, r11
    c330:	aa 0c       	add	r10, r10
    c332:	bb 1c       	adc	r11, r11
    c334:	aa 0c       	add	r10, r10
    c336:	bb 1c       	adc	r11, r11
    c338:	a8 1a       	sub	r10, r24
    c33a:	b9 0a       	sbc	r11, r25
    c33c:	25 2e       	mov	r2, r21
    c33e:	33 24       	eor	r3, r3
    c340:	27 fc       	sbrc	r2, 7
    c342:	30 94       	com	r3
    c344:	04 2f       	mov	r16, r20
    c346:	88 24       	eor	r8, r8
		switch(Char=prc(CurrStr+X-Xs)) {
		case '{':
			while((Char=prc(CurrStr + X - Xs + ++Param.Size))=='{');
			Param.Prec = prb(&IF->Prec);
			Param.Txt = prp(&IF->EnumList);
			PutField(prb(&IF->Type), prp(&IF->Var), &Param);
    c348:	3e 01       	movw	r6, r28
    c34a:	08 94       	sec
    c34c:	61 1c       	adc	r6, r1
    c34e:	71 1c       	adc	r7, r1
			else
				PutField(prb(&(OF+OF_N)->Type), prp(&(OF+OF_N)->Var), &Param);
			OF_N++;
			break;
		}
		LCD_Buf[Y][X+=Param.Size] = Char;
    c350:	25 01       	movw	r4, r10
    c352:	11 c0       	rjmp	.+34     	; 0xc376 <PutLine+0xf4>
	for(X=X0; X<X1; X++){
		char Char;
		T_Param Param;
		Param.Pos = LCD_Buf[Y]+X;
		Param.Size = 0;
		switch(Char=prc(CurrStr+X-Xs)) {
    c354:	1d 37       	cpi	r17, 0x7D	; 125
    c356:	09 f4       	brne	.+2      	; 0xc35a <PutLine+0xd8>
    c358:	4c c0       	rjmp	.+152    	; 0xc3f2 <PutLine+0x170>
    c35a:	30 e0       	ldi	r19, 0x00	; 0
			else
				PutField(prb(&(OF+OF_N)->Type), prp(&(OF+OF_N)->Var), &Param);
			OF_N++;
			break;
		}
		LCD_Buf[Y][X+=Param.Size] = Char;
    c35c:	80 2f       	mov	r24, r16
    c35e:	83 0f       	add	r24, r19
    c360:	f2 01       	movw	r30, r4
    c362:	e8 0f       	add	r30, r24
    c364:	f1 1d       	adc	r31, r1
    c366:	e8 5a       	subi	r30, 0xA8	; 168
    c368:	f9 4f       	sbci	r31, 0xF9	; 249
    c36a:	10 83       	st	Z, r17
		Xs = X0-2;
		X1 = X0 + (strlen_P(CurrStr) - 2);
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';		
	}
	//---
	for(X=X0; X<X1; X++){
    c36c:	08 2f       	mov	r16, r24
    c36e:	0f 5f       	subi	r16, 0xFF	; 255
    c370:	09 15       	cp	r16, r9
    c372:	08 f0       	brcs	.+2      	; 0xc376 <PutLine+0xf4>
    c374:	7e c0       	rjmp	.+252    	; 0xc472 <PutLine+0x1f0>
		char Char;
		T_Param Param;
		Param.Pos = LCD_Buf[Y]+X;
    c376:	80 2f       	mov	r24, r16
    c378:	90 e0       	ldi	r25, 0x00	; 0
    c37a:	9c 01       	movw	r18, r24
    c37c:	2a 0d       	add	r18, r10
    c37e:	3b 1d       	adc	r19, r11
    c380:	28 5a       	subi	r18, 0xA8	; 168
    c382:	39 4f       	sbci	r19, 0xF9	; 249
    c384:	3a 83       	std	Y+2, r19	; 0x02
    c386:	29 83       	std	Y+1, r18	; 0x01
		Param.Size = 0;
		switch(Char=prc(CurrStr+X-Xs)) {
    c388:	82 19       	sub	r24, r2
    c38a:	93 09       	sbc	r25, r3
    c38c:	f7 01       	movw	r30, r14
    c38e:	e8 0f       	add	r30, r24
    c390:	f9 1f       	adc	r31, r25
    c392:	14 91       	lpm	r17, Z+
    c394:	1b 37       	cpi	r17, 0x7B	; 123
    c396:	f1 f6       	brne	.-68     	; 0xc354 <PutLine+0xd2>
    c398:	21 e0       	ldi	r18, 0x01	; 1
    c39a:	01 c0       	rjmp	.+2      	; 0xc39e <PutLine+0x11c>
		case '{':
			while((Char=prc(CurrStr + X - Xs + ++Param.Size))=='{');
    c39c:	23 2f       	mov	r18, r19
    c39e:	fc 01       	movw	r30, r24
    c3a0:	e2 0f       	add	r30, r18
    c3a2:	f1 1d       	adc	r31, r1
    c3a4:	ee 0d       	add	r30, r14
    c3a6:	ff 1d       	adc	r31, r15
    c3a8:	14 91       	lpm	r17, Z+
    c3aa:	32 2f       	mov	r19, r18
    c3ac:	3f 5f       	subi	r19, 0xFF	; 255
    c3ae:	1b 37       	cpi	r17, 0x7B	; 123
    c3b0:	a9 f3       	breq	.-22     	; 0xc39c <PutLine+0x11a>
    c3b2:	2c 83       	std	Y+4, r18	; 0x04

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    c3b4:	a5 e0       	ldi	r26, 0x05	; 5
    c3b6:	b0 e0       	ldi	r27, 0x00	; 0
    c3b8:	ca 0e       	add	r12, r26
    c3ba:	db 1e       	adc	r13, r27
    c3bc:	f6 01       	movw	r30, r12
    c3be:	84 91       	lpm	r24, Z+
    c3c0:	2b ef       	ldi	r18, 0xFB	; 251
    c3c2:	3f ef       	ldi	r19, 0xFF	; 255
    c3c4:	c2 0e       	add	r12, r18
    c3c6:	d3 1e       	adc	r13, r19
			Param.Prec = prb(&IF->Prec);
    c3c8:	8b 83       	std	Y+3, r24	; 0x03

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    c3ca:	f6 01       	movw	r30, r12
    c3cc:	33 96       	adiw	r30, 0x03	; 3
    c3ce:	85 91       	lpm	r24, Z+
    c3d0:	94 91       	lpm	r25, Z+
			Param.Txt = prp(&IF->EnumList);
    c3d2:	9e 83       	std	Y+6, r25	; 0x06
    c3d4:	8d 83       	std	Y+5, r24	; 0x05

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    c3d6:	f6 01       	movw	r30, r12
    c3d8:	84 91       	lpm	r24, Z+

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    c3da:	31 96       	adiw	r30, 0x01	; 1
    c3dc:	65 91       	lpm	r22, Z+
    c3de:	74 91       	lpm	r23, Z+
			PutField(prb(&IF->Type), prp(&IF->Var), &Param);
    c3e0:	a3 01       	movw	r20, r6
    c3e2:	0e 94 bc 5f 	call	0xbf78	; 0xbf78 <PutField>
			IF++;
    c3e6:	26 e0       	ldi	r18, 0x06	; 6
    c3e8:	30 e0       	ldi	r19, 0x00	; 0
    c3ea:	c2 0e       	add	r12, r18
    c3ec:	d3 1e       	adc	r13, r19
    c3ee:	3c 81       	ldd	r19, Y+4	; 0x04
    c3f0:	b5 cf       	rjmp	.-150    	; 0xc35c <PutLine+0xda>
			break;
    c3f2:	21 e0       	ldi	r18, 0x01	; 1
    c3f4:	01 c0       	rjmp	.+2      	; 0xc3f8 <PutLine+0x176>
		case '}':
			while((Char=prc(CurrStr+X - Xs + ++Param.Size))=='}');
    c3f6:	23 2f       	mov	r18, r19

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    c3f8:	fc 01       	movw	r30, r24
    c3fa:	e2 0f       	add	r30, r18
    c3fc:	f1 1d       	adc	r31, r1
    c3fe:	ee 0d       	add	r30, r14
    c400:	ff 1d       	adc	r31, r15
    c402:	14 91       	lpm	r17, Z+
    c404:	32 2f       	mov	r19, r18
    c406:	3f 5f       	subi	r19, 0xFF	; 255
    c408:	1d 37       	cpi	r17, 0x7D	; 125
    c40a:	a9 f3       	breq	.-22     	; 0xc3f6 <PutLine+0x174>
    c40c:	2c 83       	std	Y+4, r18	; 0x04
			Y1=Y;
    c40e:	38 89       	ldd	r19, Y+16	; 0x10
    c410:	30 93 45 0a 	sts	0x0A45, r19
			Param.Prec = prb(&(OF+OF_N)->Prec);
    c414:	48 2d       	mov	r20, r8
    c416:	50 e0       	ldi	r21, 0x00	; 0
    c418:	42 95       	swap	r20
    c41a:	52 95       	swap	r21
    c41c:	50 7f       	andi	r21, 0xF0	; 240
    c41e:	54 27       	eor	r21, r20
    c420:	40 7f       	andi	r20, 0xF0	; 240
    c422:	54 27       	eor	r21, r20
    c424:	8d 85       	ldd	r24, Y+13	; 0x0d
    c426:	9e 85       	ldd	r25, Y+14	; 0x0e
    c428:	48 0f       	add	r20, r24
    c42a:	59 1f       	adc	r21, r25

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    c42c:	41 5f       	subi	r20, 0xF1	; 241
    c42e:	5f 4f       	sbci	r21, 0xFF	; 255
    c430:	fa 01       	movw	r30, r20
    c432:	84 91       	lpm	r24, Z+
    c434:	4f 50       	subi	r20, 0x0F	; 15
    c436:	50 40       	sbci	r21, 0x00	; 0
    c438:	8b 83       	std	Y+3, r24	; 0x03

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    c43a:	ca 01       	movw	r24, r20
    c43c:	0d 96       	adiw	r24, 0x0d	; 13
    c43e:	fc 01       	movw	r30, r24
    c440:	25 91       	lpm	r18, Z+
    c442:	34 91       	lpm	r19, Z+
			Param.Txt = prp(&(OF+OF_N)->EnumList);
    c444:	3e 83       	std	Y+6, r19	; 0x06
    c446:	2d 83       	std	Y+5, r18	; 0x05
			if(LineN==CurrLine && OF_N==CurrField)
    c448:	80 91 ca 07 	lds	r24, 0x07CA
    c44c:	ff 85       	ldd	r31, Y+15	; 0x0f
    c44e:	f8 17       	cp	r31, r24
    c450:	29 f4       	brne	.+10     	; 0xc45c <PutLine+0x1da>
    c452:	80 91 d6 02 	lds	r24, 0x02D6
    c456:	88 16       	cp	r8, r24
    c458:	09 f4       	brne	.+2      	; 0xc45c <PutLine+0x1da>
    c45a:	43 c0       	rjmp	.+134    	; 0xc4e2 <PutLine+0x260>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    c45c:	fa 01       	movw	r30, r20
    c45e:	84 91       	lpm	r24, Z+

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    c460:	31 96       	adiw	r30, 0x01	; 1
    c462:	65 91       	lpm	r22, Z+
    c464:	74 91       	lpm	r23, Z+
				}
				else{ 
					PutBuf(prb(&(OF+OF_N)->Type), &Param);
				}			
			else
				PutField(prb(&(OF+OF_N)->Type), prp(&(OF+OF_N)->Var), &Param);
    c466:	a3 01       	movw	r20, r6
    c468:	0e 94 bc 5f 	call	0xbf78	; 0xbf78 <PutField>
    c46c:	3c 81       	ldd	r19, Y+4	; 0x04
			OF_N++;
    c46e:	83 94       	inc	r8
    c470:	75 cf       	rjmp	.-278    	; 0xc35c <PutLine+0xda>
		}
		LCD_Buf[Y][X+=Param.Size] = Char;

	}
	X=X1;
	for(;X<LCDXSz; X++) LCD_Buf[Y][X] = ' ';
    c472:	f3 e1       	ldi	r31, 0x13	; 19
    c474:	f9 15       	cp	r31, r9
    c476:	e0 f0       	brcs	.+56     	; 0xc4b0 <PutLine+0x22e>
    c478:	88 89       	ldd	r24, Y+16	; 0x10
    c47a:	28 2f       	mov	r18, r24
    c47c:	30 e0       	ldi	r19, 0x00	; 0
    c47e:	49 2d       	mov	r20, r9
    c480:	c9 01       	movw	r24, r18
    c482:	88 0f       	add	r24, r24
    c484:	99 1f       	adc	r25, r25
    c486:	82 0f       	add	r24, r18
    c488:	93 1f       	adc	r25, r19
    c48a:	9c 01       	movw	r18, r24
    c48c:	22 0f       	add	r18, r18
    c48e:	33 1f       	adc	r19, r19
    c490:	22 0f       	add	r18, r18
    c492:	33 1f       	adc	r19, r19
    c494:	22 0f       	add	r18, r18
    c496:	33 1f       	adc	r19, r19
    c498:	28 1b       	sub	r18, r24
    c49a:	39 0b       	sbc	r19, r25
    c49c:	80 e2       	ldi	r24, 0x20	; 32
    c49e:	f9 01       	movw	r30, r18
    c4a0:	e4 0f       	add	r30, r20
    c4a2:	f1 1d       	adc	r31, r1
    c4a4:	e8 5a       	subi	r30, 0xA8	; 168
    c4a6:	f9 4f       	sbci	r31, 0xF9	; 249
    c4a8:	80 83       	st	Z, r24
    c4aa:	4f 5f       	subi	r20, 0xFF	; 255
    c4ac:	44 31       	cpi	r20, 0x14	; 20
    c4ae:	b8 f3       	brcs	.-18     	; 0xc49e <PutLine+0x21c>

}
    c4b0:	60 96       	adiw	r28, 0x10	; 16
    c4b2:	0f b6       	in	r0, 0x3f	; 63
    c4b4:	f8 94       	cli
    c4b6:	de bf       	out	0x3e, r29	; 62
    c4b8:	0f be       	out	0x3f, r0	; 63
    c4ba:	cd bf       	out	0x3d, r28	; 61
    c4bc:	cf 91       	pop	r28
    c4be:	df 91       	pop	r29
    c4c0:	1f 91       	pop	r17
    c4c2:	0f 91       	pop	r16
    c4c4:	ff 90       	pop	r15
    c4c6:	ef 90       	pop	r14
    c4c8:	df 90       	pop	r13
    c4ca:	cf 90       	pop	r12
    c4cc:	bf 90       	pop	r11
    c4ce:	af 90       	pop	r10
    c4d0:	9f 90       	pop	r9
    c4d2:	8f 90       	pop	r8
    c4d4:	7f 90       	pop	r7
    c4d6:	6f 90       	pop	r6
    c4d8:	5f 90       	pop	r5
    c4da:	4f 90       	pop	r4
    c4dc:	3f 90       	pop	r3
    c4de:	2f 90       	pop	r2
    c4e0:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    c4e2:	fa 01       	movw	r30, r20
    c4e4:	84 91       	lpm	r24, Z+
			Y1=Y;
			Param.Prec = prb(&(OF+OF_N)->Prec);
			Param.Txt = prp(&(OF+OF_N)->EnumList);
			if(LineN==CurrLine && OF_N==CurrField)
				//add new
				if( (prb(&(OF+OF_N)->Type) == Text) || (prb(&(OF+OF_N)->Type) == EE_Text ) ||
    c4e6:	81 32       	cpi	r24, 0x21	; 33
    c4e8:	61 f1       	breq	.+88     	; 0xc542 <PutLine+0x2c0>
    c4ea:	82 32       	cpi	r24, 0x22	; 34
    c4ec:	51 f1       	breq	.+84     	; 0xc542 <PutLine+0x2c0>
    c4ee:	80 31       	cpi	r24, 0x10	; 16
    c4f0:	41 f1       	breq	.+80     	; 0xc542 <PutLine+0x2c0>
    c4f2:	84 31       	cpi	r24, 0x14	; 20
    c4f4:	31 f1       	breq	.+76     	; 0xc542 <PutLine+0x2c0>
    c4f6:	81 31       	cpi	r24, 0x11	; 17
    c4f8:	21 f1       	breq	.+72     	; 0xc542 <PutLine+0x2c0>
    c4fa:	85 31       	cpi	r24, 0x15	; 21
    c4fc:	11 f1       	breq	.+68     	; 0xc542 <PutLine+0x2c0>
    c4fe:	82 31       	cpi	r24, 0x12	; 18
    c500:	01 f1       	breq	.+64     	; 0xc542 <PutLine+0x2c0>
    c502:	83 31       	cpi	r24, 0x13	; 19
    c504:	f1 f0       	breq	.+60     	; 0xc542 <PutLine+0x2c0>
    c506:	89 31       	cpi	r24, 0x19	; 25
    c508:	e1 f0       	breq	.+56     	; 0xc542 <PutLine+0x2c0>
    c50a:	8b 31       	cpi	r24, 0x1B	; 27
    c50c:	d1 f0       	breq	.+52     	; 0xc542 <PutLine+0x2c0>
    c50e:	8a 31       	cpi	r24, 0x1A	; 26
    c510:	c1 f0       	breq	.+48     	; 0xc542 <PutLine+0x2c0>
    c512:	8c 31       	cpi	r24, 0x1C	; 28
    c514:	b1 f0       	breq	.+44     	; 0xc542 <PutLine+0x2c0>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
PutBuf(uint8_t Type, T_Param *Param)
{
	switch(Type) {
    c516:	89 30       	cpi	r24, 0x09	; 9
    c518:	08 f0       	brcs	.+2      	; 0xc51c <PutLine+0x29a>
    c51a:	b7 c0       	rjmp	.+366    	; 0xc68a <PutLine+0x408>
    c51c:	87 30       	cpi	r24, 0x07	; 7
    c51e:	08 f0       	brcs	.+2      	; 0xc522 <PutLine+0x2a0>
    c520:	b9 c0       	rjmp	.+370    	; 0xc694 <PutLine+0x412>
    c522:	84 30       	cpi	r24, 0x04	; 4
    c524:	08 f0       	brcs	.+2      	; 0xc528 <PutLine+0x2a6>
    c526:	e5 c0       	rjmp	.+458    	; 0xc6f2 <PutLine+0x470>
    c528:	82 30       	cpi	r24, 0x02	; 2
    c52a:	08 f4       	brcc	.+2      	; 0xc52e <PutLine+0x2ac>
    c52c:	b3 c0       	rjmp	.+358    	; 0xc694 <PutLine+0x412>
		Put_bVal(Param);
		PosBlink(Param,' ');
		break;
	case s_Byte: case s_EE_Byte:
	case s_Word: case s_EE_Word:
		Put_sbVal(Param);
    c52e:	c3 01       	movw	r24, r6
    c530:	0e 94 b5 44 	call	0x896a	; 0x896a <Put_sbVal>
		PosBlink(Param,' ');
    c534:	c3 01       	movw	r24, r6
    c536:	60 e2       	ldi	r22, 0x20	; 32
    c538:	0e 94 44 40 	call	0x8088	; 0x8088 <PosBlink>
    c53c:	3c 81       	ldd	r19, Y+4	; 0x04
				else{ 
					PutBuf(prb(&(OF+OF_N)->Type), &Param);
				}			
			else
				PutField(prb(&(OF+OF_N)->Type), prp(&(OF+OF_N)->Var), &Param);
			OF_N++;
    c53e:	83 94       	inc	r8
    c540:	0d cf       	rjmp	.-486    	; 0xc35c <PutLine+0xda>
// When use BufStr for variable edit
inline static void
PutBufStr(uint8_t Type, T_Param *Param)
{	
	char Format[6];
	sprintf(Format,"%%.%us", Param->Size);
    c542:	00 d0       	rcall	.+0      	; 0xc544 <PutLine+0x2c2>
    c544:	00 d0       	rcall	.+0      	; 0xc546 <PutLine+0x2c4>
    c546:	ed b7       	in	r30, 0x3d	; 61
    c548:	fe b7       	in	r31, 0x3e	; 62
    c54a:	31 96       	adiw	r30, 0x01	; 1
    c54c:	27 e0       	ldi	r18, 0x07	; 7
    c54e:	30 e0       	ldi	r19, 0x00	; 0
    c550:	2c 0f       	add	r18, r28
    c552:	3d 1f       	adc	r19, r29
    c554:	ad b7       	in	r26, 0x3d	; 61
    c556:	be b7       	in	r27, 0x3e	; 62
    c558:	12 96       	adiw	r26, 0x02	; 2
    c55a:	3c 93       	st	X, r19
    c55c:	2e 93       	st	-X, r18
    c55e:	11 97       	sbiw	r26, 0x01	; 1
    c560:	8b ea       	ldi	r24, 0xAB	; 171
    c562:	92 e0       	ldi	r25, 0x02	; 2
    c564:	93 83       	std	Z+3, r25	; 0x03
    c566:	82 83       	std	Z+2, r24	; 0x02
    c568:	8c 81       	ldd	r24, Y+4	; 0x04
    c56a:	84 83       	std	Z+4, r24	; 0x04
    c56c:	15 82       	std	Z+5, r1	; 0x05
    c56e:	0e 94 22 85 	call	0x10a44	; 0x10a44 <sprintf>
	sprintf(Param->Pos, Format, BufStr);
    c572:	ed b7       	in	r30, 0x3d	; 61
    c574:	fe b7       	in	r31, 0x3e	; 62
    c576:	31 96       	adiw	r30, 0x01	; 1
    c578:	89 81       	ldd	r24, Y+1	; 0x01
    c57a:	9a 81       	ldd	r25, Y+2	; 0x02
    c57c:	ad b7       	in	r26, 0x3d	; 61
    c57e:	be b7       	in	r27, 0x3e	; 62
    c580:	12 96       	adiw	r26, 0x02	; 2
    c582:	9c 93       	st	X, r25
    c584:	8e 93       	st	-X, r24
    c586:	11 97       	sbiw	r26, 0x01	; 1
    c588:	27 e0       	ldi	r18, 0x07	; 7
    c58a:	30 e0       	ldi	r19, 0x00	; 0
    c58c:	2c 0f       	add	r18, r28
    c58e:	3d 1f       	adc	r19, r29
    c590:	33 83       	std	Z+3, r19	; 0x03
    c592:	22 83       	std	Z+2, r18	; 0x02
    c594:	83 ec       	ldi	r24, 0xC3	; 195
    c596:	95 e0       	ldi	r25, 0x05	; 5
    c598:	95 83       	std	Z+5, r25	; 0x05
    c59a:	84 83       	std	Z+4, r24	; 0x04
    c59c:	0e 94 22 85 	call	0x10a44	; 0x10a44 <sprintf>
	Param->Prec = 0;
    c5a0:	1b 82       	std	Y+3, r1	; 0x03
	PosBlink(Param,'_');
    c5a2:	ad b7       	in	r26, 0x3d	; 61
    c5a4:	be b7       	in	r27, 0x3e	; 62
    c5a6:	16 96       	adiw	r26, 0x06	; 6
    c5a8:	0f b6       	in	r0, 0x3f	; 63
    c5aa:	f8 94       	cli
    c5ac:	be bf       	out	0x3e, r27	; 62
    c5ae:	0f be       	out	0x3f, r0	; 63
    c5b0:	ad bf       	out	0x3d, r26	; 61
    c5b2:	c3 01       	movw	r24, r6
    c5b4:	6f e5       	ldi	r22, 0x5F	; 95
    c5b6:	0e 94 44 40 	call	0x8088	; 0x8088 <PosBlink>
    c5ba:	3c 81       	ldd	r19, Y+4	; 0x04
				else{ 
					PutBuf(prb(&(OF+OF_N)->Type), &Param);
				}			
			else
				PutField(prb(&(OF+OF_N)->Type), prp(&(OF+OF_N)->Var), &Param);
			OF_N++;
    c5bc:	83 94       	inc	r8
    c5be:	ce ce       	rjmp	.-612    	; 0xc35c <PutLine+0xda>

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    c5c0:	08 94       	sec
    c5c2:	e1 1c       	adc	r14, r1
    c5c4:	f1 1c       	adc	r15, r1
    c5c6:	f7 01       	movw	r30, r14
    c5c8:	84 91       	lpm	r24, Z+
    c5ca:	08 94       	sec
    c5cc:	e1 08       	sbc	r14, r1
    c5ce:	f1 08       	sbc	r15, r1
		X1 = strlen_P(CurrStr) - 2;
		X0 = 0;
		Xs = X0-2;
	}
	//--- "<>" Align center
	if(prc(CurrStr+0) == '<' && prc(CurrStr+1) == '>'){
    c5d0:	8e 33       	cpi	r24, 0x3E	; 62
    c5d2:	09 f0       	breq	.+2      	; 0xc5d6 <PutLine+0x354>
    c5d4:	9f ce       	rjmp	.-706    	; 0xc314 <PutLine+0x92>
		X0 = (LCDXSz - strlen_P(CurrStr) + 2) / 2;
    c5d6:	8b 2d       	mov	r24, r11
    c5d8:	9a 2d       	mov	r25, r10
    c5da:	0e 94 36 84 	call	0x1086c	; 0x1086c <strlen_P>
    c5de:	26 e1       	ldi	r18, 0x16	; 22
    c5e0:	30 e0       	ldi	r19, 0x00	; 0
    c5e2:	28 1b       	sub	r18, r24
    c5e4:	39 0b       	sbc	r19, r25
    c5e6:	36 95       	lsr	r19
    c5e8:	27 95       	ror	r18
    c5ea:	42 2f       	mov	r20, r18
		Xs = X0-2;
    c5ec:	52 2f       	mov	r21, r18
    c5ee:	52 50       	subi	r21, 0x02	; 2
		X1 = X0 + (strlen_P(CurrStr) - 2);
    c5f0:	be ef       	ldi	r27, 0xFE	; 254
    c5f2:	9b 2e       	mov	r9, r27
    c5f4:	98 0e       	add	r9, r24
    c5f6:	92 0e       	add	r9, r18
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';		
    c5f8:	22 23       	and	r18, r18
    c5fa:	09 f4       	brne	.+2      	; 0xc5fe <PutLine+0x37c>
    c5fc:	8b ce       	rjmp	.-746    	; 0xc314 <PutLine+0x92>
    c5fe:	85 e1       	ldi	r24, 0x15	; 21
    c600:	28 89       	ldd	r18, Y+16	; 0x10
    c602:	28 9f       	mul	r18, r24
    c604:	f0 01       	movw	r30, r0
    c606:	11 24       	eor	r1, r1
    c608:	e8 5a       	subi	r30, 0xA8	; 168
    c60a:	f9 4f       	sbci	r31, 0xF9	; 249
    c60c:	80 e0       	ldi	r24, 0x00	; 0
    c60e:	90 e2       	ldi	r25, 0x20	; 32
    c610:	91 93       	st	Z+, r25
    c612:	8f 5f       	subi	r24, 0xFF	; 255
    c614:	84 17       	cp	r24, r20
    c616:	e0 f3       	brcs	.-8      	; 0xc610 <PutLine+0x38e>
    c618:	7d ce       	rjmp	.-774    	; 0xc314 <PutLine+0x92>
    c61a:	08 94       	sec
    c61c:	e1 1c       	adc	r14, r1
    c61e:	f1 1c       	adc	r15, r1
    c620:	f7 01       	movw	r30, r14
    c622:	84 91       	lpm	r24, Z+
    c624:	08 94       	sec
    c626:	e1 08       	sbc	r14, r1
    c628:	f1 08       	sbc	r15, r1
		X0 = LCDXSz - strlen_P(CurrStr) + 2;
		Xs = X0-2;
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';
	}
	//--- "<<" Align left
	if(prc(CurrStr+0) == '<' && prc(CurrStr+1) == '<'){
    c62a:	8c 33       	cpi	r24, 0x3C	; 60
    c62c:	09 f0       	breq	.+2      	; 0xc630 <PutLine+0x3ae>
    c62e:	6b ce       	rjmp	.-810    	; 0xc306 <PutLine+0x84>
		X1 = strlen_P(CurrStr) - 2;
    c630:	8b 2d       	mov	r24, r11
    c632:	9a 2d       	mov	r25, r10
    c634:	0e 94 36 84 	call	0x1086c	; 0x1086c <strlen_P>
    c638:	9e ef       	ldi	r25, 0xFE	; 254
    c63a:	99 2e       	mov	r9, r25
    c63c:	98 0e       	add	r9, r24
    c63e:	40 e0       	ldi	r20, 0x00	; 0
    c640:	5e ef       	ldi	r21, 0xFE	; 254
    c642:	63 ce       	rjmp	.-826    	; 0xc30a <PutLine+0x88>
    c644:	08 94       	sec
    c646:	e1 1c       	adc	r14, r1
    c648:	f1 1c       	adc	r15, r1
    c64a:	f7 01       	movw	r30, r14
    c64c:	84 91       	lpm	r24, Z+
    c64e:	08 94       	sec
    c650:	e1 08       	sbc	r14, r1
    c652:	f1 08       	sbc	r15, r1
	uint8_t X;
	uint8_t X0=0;
	uint8_t X1=LCDXSz;
	int8_t Xs = 0;
	//--- ">>" Align right
	if(prc(CurrStr+0) == '>' && prc(CurrStr+1) == '>'){
    c654:	8e 33       	cpi	r24, 0x3E	; 62
    c656:	09 f0       	breq	.+2      	; 0xc65a <PutLine+0x3d8>
    c658:	4f ce       	rjmp	.-866    	; 0xc2f8 <PutLine+0x76>
		X0 = LCDXSz - strlen_P(CurrStr) + 2;
    c65a:	c7 01       	movw	r24, r14
    c65c:	0e 94 36 84 	call	0x1086c	; 0x1086c <strlen_P>
    c660:	46 e1       	ldi	r20, 0x16	; 22
    c662:	48 1b       	sub	r20, r24
		Xs = X0-2;
    c664:	54 2f       	mov	r21, r20
    c666:	52 50       	subi	r21, 0x02	; 2
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';
    c668:	44 23       	and	r20, r20
    c66a:	09 f4       	brne	.+2      	; 0xc66e <PutLine+0x3ec>
    c66c:	47 ce       	rjmp	.-882    	; 0xc2fc <PutLine+0x7a>
    c66e:	85 e1       	ldi	r24, 0x15	; 21
    c670:	28 89       	ldd	r18, Y+16	; 0x10
    c672:	28 9f       	mul	r18, r24
    c674:	f0 01       	movw	r30, r0
    c676:	11 24       	eor	r1, r1
    c678:	e8 5a       	subi	r30, 0xA8	; 168
    c67a:	f9 4f       	sbci	r31, 0xF9	; 249
    c67c:	80 e0       	ldi	r24, 0x00	; 0
    c67e:	90 e2       	ldi	r25, 0x20	; 32
    c680:	91 93       	st	Z+, r25
    c682:	8f 5f       	subi	r24, 0xFF	; 255
    c684:	84 17       	cp	r24, r20
    c686:	e0 f3       	brcs	.-8      	; 0xc680 <PutLine+0x3fe>
    c688:	39 ce       	rjmp	.-910    	; 0xc2fc <PutLine+0x7a>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
PutBuf(uint8_t Type, T_Param *Param)
{
	switch(Type) {
    c68a:	8d 30       	cpi	r24, 0x0D	; 13
    c68c:	68 f4       	brcc	.+26     	; 0xc6a8 <PutLine+0x426>
    c68e:	8b 30       	cpi	r24, 0x0B	; 11
    c690:	08 f4       	brcc	.+2      	; 0xc694 <PutLine+0x412>
    c692:	4d cf       	rjmp	.-358    	; 0xc52e <PutLine+0x2ac>
	case Byte: case EE_Byte: case z_Byte: case z_EE_Byte:
	case Word: case EE_Word: case z_Word: case z_EE_Word:
		Put_bVal(Param);
    c694:	c3 01       	movw	r24, r6
    c696:	0e 94 b3 45 	call	0x8b66	; 0x8b66 <Put_bVal>
		PosBlink(Param,' ');
    c69a:	c3 01       	movw	r24, r6
    c69c:	60 e2       	ldi	r22, 0x20	; 32
    c69e:	0e 94 44 40 	call	0x8088	; 0x8088 <PosBlink>
    c6a2:	3c 81       	ldd	r19, Y+4	; 0x04
				else{ 
					PutBuf(prb(&(OF+OF_N)->Type), &Param);
				}			
			else
				PutField(prb(&(OF+OF_N)->Type), prp(&(OF+OF_N)->Var), &Param);
			OF_N++;
    c6a4:	83 94       	inc	r8
    c6a6:	5a ce       	rjmp	.-844    	; 0xc35c <PutLine+0xda>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
PutBuf(uint8_t Type, T_Param *Param)
{
	switch(Type) {
    c6a8:	8e 30       	cpi	r24, 0x0E	; 14
    c6aa:	b9 f1       	breq	.+110    	; 0xc71a <PutLine+0x498>
    c6ac:	8e 30       	cpi	r24, 0x0E	; 14
    c6ae:	28 f1       	brcs	.+74     	; 0xc6fa <PutLine+0x478>
    c6b0:	8d 51       	subi	r24, 0x1D	; 29
    c6b2:	84 30       	cpi	r24, 0x04	; 4
    c6b4:	08 f0       	brcs	.+2      	; 0xc6b8 <PutLine+0x436>
    c6b6:	da ce       	rjmp	.-588    	; 0xc46c <PutLine+0x1ea>
	case zc_Word:
		Put_zVal(F_Buf, 'w', Param);
		ValBlink(Param->Pos, Param->Size);
		break;
	case Enum: case EE_Enum: case Bit: case EE_Bit:
		Param->Txt += (uint8_t)F_Buf;
    c6b8:	80 91 f7 04 	lds	r24, 0x04F7
    c6bc:	90 e0       	ldi	r25, 0x00	; 0
    c6be:	88 0f       	add	r24, r24
    c6c0:	99 1f       	adc	r25, r25
    c6c2:	28 0f       	add	r18, r24
    c6c4:	39 1f       	adc	r19, r25
    c6c6:	3e 83       	std	Y+6, r19	; 0x06
    c6c8:	2d 83       	std	Y+5, r18	; 0x05
		PutEnum(Param);
    c6ca:	c3 01       	movw	r24, r6
    c6cc:	0e 94 84 44 	call	0x8908	; 0x8908 <PutEnum>
		ValBlink(Param->Pos, Param->Size);
    c6d0:	3c 81       	ldd	r19, Y+4	; 0x04

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
ValBlink(char *Pos, uint8_t Sz)
{
	CurrX=Pos-LCD_Buf[Y1];
    c6d2:	80 91 45 0a 	lds	r24, 0x0A45
    c6d6:	f5 e1       	ldi	r31, 0x15	; 21
    c6d8:	8f 9f       	mul	r24, r31
    c6da:	c0 01       	movw	r24, r0
    c6dc:	11 24       	eor	r1, r1
    c6de:	88 5a       	subi	r24, 0xA8	; 168
    c6e0:	99 4f       	sbci	r25, 0xF9	; 249
    c6e2:	29 81       	ldd	r18, Y+1	; 0x01
    c6e4:	28 1b       	sub	r18, r24
    c6e6:	20 93 fa 06 	sts	0x06FA, r18
	StrSize=Sz; 
    c6ea:	30 93 ac 06 	sts	0x06AC, r19
				else{ 
					PutBuf(prb(&(OF+OF_N)->Type), &Param);
				}			
			else
				PutField(prb(&(OF+OF_N)->Type), prp(&(OF+OF_N)->Var), &Param);
			OF_N++;
    c6ee:	83 94       	inc	r8
    c6f0:	35 ce       	rjmp	.-918    	; 0xc35c <PutLine+0xda>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
PutBuf(uint8_t Type, T_Param *Param)
{
	switch(Type) {
    c6f2:	86 30       	cpi	r24, 0x06	; 6
    c6f4:	78 f2       	brcs	.-98     	; 0xc694 <PutLine+0x412>
    c6f6:	3c 81       	ldd	r19, Y+4	; 0x04
    c6f8:	ba ce       	rjmp	.-652    	; 0xc46e <PutLine+0x1ec>
	case s_Word: case s_EE_Word:
		Put_sbVal(Param);
		PosBlink(Param,' ');
		break;
	case c_Word:
		PutVal(F_Buf, 'w', Param);
    c6fa:	80 91 f7 04 	lds	r24, 0x04F7
    c6fe:	90 91 f8 04 	lds	r25, 0x04F8
    c702:	67 e7       	ldi	r22, 0x77	; 119
    c704:	a3 01       	movw	r20, r6
    c706:	0e 94 82 4d 	call	0x9b04	; 0x9b04 <PutVal>
		ValBlink(Param->Pos, Param->Size);
    c70a:	3c 81       	ldd	r19, Y+4	; 0x04

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
ValBlink(char *Pos, uint8_t Sz)
{
	CurrX=Pos-LCD_Buf[Y1];
    c70c:	80 91 45 0a 	lds	r24, 0x0A45
    c710:	b5 e1       	ldi	r27, 0x15	; 21
    c712:	8b 9f       	mul	r24, r27
    c714:	c0 01       	movw	r24, r0
    c716:	11 24       	eor	r1, r1
    c718:	e2 cf       	rjmp	.-60     	; 0xc6de <PutLine+0x45c>
	case c_Word:
		PutVal(F_Buf, 'w', Param);
		ValBlink(Param->Pos, Param->Size);
		break;
	case zc_Word:
		Put_zVal(F_Buf, 'w', Param);
    c71a:	80 91 f7 04 	lds	r24, 0x04F7
    c71e:	90 91 f8 04 	lds	r25, 0x04F8
    c722:	67 e7       	ldi	r22, 0x77	; 119
    c724:	a3 01       	movw	r20, r6
    c726:	0e 94 e1 4b 	call	0x97c2	; 0x97c2 <Put_zVal>
		ValBlink(Param->Pos, Param->Size);
    c72a:	3c 81       	ldd	r19, Y+4	; 0x04

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
ValBlink(char *Pos, uint8_t Sz)
{
	CurrX=Pos-LCD_Buf[Y1];
    c72c:	80 91 45 0a 	lds	r24, 0x0A45
    c730:	e5 e1       	ldi	r30, 0x15	; 21
    c732:	8e 9f       	mul	r24, r30
    c734:	c0 01       	movw	r24, r0
    c736:	11 24       	eor	r1, r1
    c738:	d2 cf       	rjmp	.-92     	; 0xc6de <PutLine+0x45c>

0000c73a <MenuOut>:
	while(X<LCDXSz)	LCD_Buf[Y][X++] = ' ';
}
// ~~~~~~~~~~
void
MenuOut(void)
{
    c73a:	2f 92       	push	r2
    c73c:	3f 92       	push	r3
    c73e:	4f 92       	push	r4
    c740:	5f 92       	push	r5
    c742:	6f 92       	push	r6
    c744:	7f 92       	push	r7
    c746:	8f 92       	push	r8
    c748:	9f 92       	push	r9
    c74a:	af 92       	push	r10
    c74c:	bf 92       	push	r11
    c74e:	cf 92       	push	r12
    c750:	df 92       	push	r13
    c752:	ef 92       	push	r14
    c754:	ff 92       	push	r15
    c756:	0f 93       	push	r16
    c758:	1f 93       	push	r17
    c75a:	df 93       	push	r29
    c75c:	cf 93       	push	r28
    c75e:	cd b7       	in	r28, 0x3d	; 61
    c760:	de b7       	in	r29, 0x3e	; 62
    c762:	2a 97       	sbiw	r28, 0x0a	; 10
    c764:	0f b6       	in	r0, 0x3f	; 63
    c766:	f8 94       	cli
    c768:	de bf       	out	0x3e, r29	; 62
    c76a:	0f be       	out	0x3f, r0	; 63
    c76c:	cd bf       	out	0x3d, r28	; 61
	uint8_t Y;
	if(CurrMsg) {
    c76e:	a0 90 f5 04 	lds	r10, 0x04F5
    c772:	b0 90 f6 04 	lds	r11, 0x04F6
    c776:	a1 14       	cp	r10, r1
    c778:	b1 04       	cpc	r11, r1
    c77a:	09 f4       	brne	.+2      	; 0xc77e <MenuOut+0x44>
    c77c:	6a c1       	rjmp	.+724    	; 0xca52 <MenuOut+0x318>
    c77e:	22 24       	eor	r2, r2
    c780:	33 24       	eor	r3, r3
    c782:	18 86       	std	Y+8, r1	; 0x08
    c784:	1f 82       	std	Y+7, r1	; 0x07
	int8_t Xs = 0;
	//--- ">>" Align right
	if(prc(CurrStr+0) == '>' && prc(CurrStr+1) == '>'){
		X0 = LCDXSz - strlen_P(CurrStr) + 2;
		Xs = X0-2;
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';
    c786:	80 e2       	ldi	r24, 0x20	; 32
    c788:	48 2e       	mov	r4, r24
	#if TypeLCD==840
		const MsgLine *Line=(MsgLine*)prp(&CurrMsg->LineList)+Y;
	#else
		const MsgLine *Line=CurrMsg->LineList+Y;		
	#endif
	PGM_P CurrStr=(PGM_P)(Line->Str);
    c78a:	91 01       	movw	r18, r2
    c78c:	22 0f       	add	r18, r18
    c78e:	33 1f       	adc	r19, r19
    c790:	3a 87       	std	Y+10, r19	; 0x0a
    c792:	29 87       	std	Y+9, r18	; 0x09
    c794:	49 01       	movw	r8, r18
    c796:	82 0c       	add	r8, r2
    c798:	93 1c       	adc	r9, r3
    c79a:	64 01       	movw	r12, r8
    c79c:	cc 0c       	add	r12, r12
    c79e:	dd 1c       	adc	r13, r13
    c7a0:	cc 0c       	add	r12, r12
    c7a2:	dd 1c       	adc	r13, r13
    c7a4:	cc 0c       	add	r12, r12
    c7a6:	dd 1c       	adc	r13, r13
    c7a8:	96 01       	movw	r18, r12
    c7aa:	22 19       	sub	r18, r2
    c7ac:	33 09       	sbc	r19, r3
    c7ae:	75 01       	movw	r14, r10
    c7b0:	e2 0e       	add	r14, r18
    c7b2:	f3 1e       	adc	r15, r19

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    c7b4:	2b 5e       	subi	r18, 0xEB	; 235
    c7b6:	3f 4f       	sbci	r19, 0xFF	; 255
    c7b8:	c5 01       	movw	r24, r10
    c7ba:	82 0f       	add	r24, r18
    c7bc:	93 1f       	adc	r25, r19
    c7be:	25 51       	subi	r18, 0x15	; 21
    c7c0:	30 40       	sbci	r19, 0x00	; 0
    c7c2:	fc 01       	movw	r30, r24
    c7c4:	65 90       	lpm	r6, Z+
    c7c6:	74 90       	lpm	r7, Z+

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    c7c8:	f7 01       	movw	r30, r14
    c7ca:	84 91       	lpm	r24, Z+
	uint8_t X;
	uint8_t X0=0;
	uint8_t X1=LCDXSz;
	int8_t Xs = 0;
	//--- ">>" Align right
	if(prc(CurrStr+0) == '>' && prc(CurrStr+1) == '>'){
    c7cc:	8e 33       	cpi	r24, 0x3E	; 62
    c7ce:	09 f4       	brne	.+2      	; 0xc7d2 <MenuOut+0x98>
    c7d0:	b3 c0       	rjmp	.+358    	; 0xc938 <MenuOut+0x1fe>
		X0 = LCDXSz - strlen_P(CurrStr) + 2;
		Xs = X0-2;
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';
    c7d2:	90 e0       	ldi	r25, 0x00	; 0
    c7d4:	00 e0       	ldi	r16, 0x00	; 0
    c7d6:	f7 01       	movw	r30, r14
    c7d8:	84 91       	lpm	r24, Z+
	}
	//--- "<<" Align left
	if(prc(CurrStr+0) == '<' && prc(CurrStr+1) == '<'){
    c7da:	8c 33       	cpi	r24, 0x3C	; 60
    c7dc:	09 f4       	brne	.+2      	; 0xc7e0 <MenuOut+0xa6>
    c7de:	cd c0       	rjmp	.+410    	; 0xc97a <MenuOut+0x240>
		X1 = strlen_P(CurrStr) - 2;
    c7e0:	f4 e1       	ldi	r31, 0x14	; 20
    c7e2:	5f 2e       	mov	r5, r31
    c7e4:	f7 01       	movw	r30, r14
    c7e6:	84 91       	lpm	r24, Z+
		X0 = 0;
		Xs = X0-2;
	}
	//--- "<>" Align center
	if(prc(CurrStr+0) == '<' && prc(CurrStr+1) == '>'){
    c7e8:	8c 33       	cpi	r24, 0x3C	; 60
    c7ea:	09 f4       	brne	.+2      	; 0xc7ee <MenuOut+0xb4>
    c7ec:	e6 c0       	rjmp	.+460    	; 0xc9ba <MenuOut+0x280>
		X1 = X0 + (strlen_P(CurrStr) - 2);
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';		
	}
	//---

	for(X=X0; X<X1; X++){
    c7ee:	05 15       	cp	r16, r5
    c7f0:	08 f0       	brcs	.+2      	; 0xc7f4 <MenuOut+0xba>
    c7f2:	73 c0       	rjmp	.+230    	; 0xc8da <MenuOut+0x1a0>
		const MsgLine *Line=(MsgLine*)prp(&CurrMsg->LineList)+Y;
	#else
		const MsgLine *Line=CurrMsg->LineList+Y;		
	#endif
	PGM_P CurrStr=(PGM_P)(Line->Str);
	InField *IF = prp(&Line->IF_List);
    c7f4:	73 01       	movw	r14, r6
    c7f6:	69 2e       	mov	r6, r25
    c7f8:	77 24       	eor	r7, r7
    c7fa:	67 fc       	sbrc	r6, 7
    c7fc:	70 94       	com	r7
    c7fe:	29 85       	ldd	r18, Y+9	; 0x09
    c800:	3a 85       	ldd	r19, Y+10	; 0x0a
    c802:	22 0d       	add	r18, r2
    c804:	33 1d       	adc	r19, r3
    c806:	c9 01       	movw	r24, r18
    c808:	88 0f       	add	r24, r24
    c80a:	99 1f       	adc	r25, r25
    c80c:	88 0f       	add	r24, r24
    c80e:	99 1f       	adc	r25, r25
    c810:	88 0f       	add	r24, r24
    c812:	99 1f       	adc	r25, r25
    c814:	6c 01       	movw	r12, r24
    c816:	c2 18       	sub	r12, r2
    c818:	d3 08       	sbc	r13, r3
			Param.Txt = prp(&IF->EnumList);
			PutField(prb(&IF->Type), prp(&IF->Var), &Param);
			IF++;
			X += Param.Size;
		}
		LCD_Buf[Y][X] = Char;
    c81a:	4c 01       	movw	r8, r24
    c81c:	82 1a       	sub	r8, r18
    c81e:	93 0a       	sbc	r9, r19
    c820:	09 c0       	rjmp	.+18     	; 0xc834 <MenuOut+0xfa>
    c822:	a8 0d       	add	r26, r8
    c824:	b9 1d       	adc	r27, r9
    c826:	a8 5a       	subi	r26, 0xA8	; 168
    c828:	b9 4f       	sbci	r27, 0xF9	; 249
    c82a:	1c 93       	st	X, r17
		X1 = X0 + (strlen_P(CurrStr) - 2);
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';		
	}
	//---

	for(X=X0; X<X1; X++){
    c82c:	0f 5f       	subi	r16, 0xFF	; 255
    c82e:	05 15       	cp	r16, r5
    c830:	08 f0       	brcs	.+2      	; 0xc834 <MenuOut+0xfa>
    c832:	4f c0       	rjmp	.+158    	; 0xc8d2 <MenuOut+0x198>
		char Char;
		if((Char=prc(CurrStr+X-Xs))=='{') {
    c834:	a0 2f       	mov	r26, r16
    c836:	b0 e0       	ldi	r27, 0x00	; 0
    c838:	9d 01       	movw	r18, r26
    c83a:	26 19       	sub	r18, r6
    c83c:	37 09       	sbc	r19, r7
    c83e:	f6 01       	movw	r30, r12
    c840:	e2 0f       	add	r30, r18
    c842:	f3 1f       	adc	r31, r19
    c844:	ea 0d       	add	r30, r10
    c846:	fb 1d       	adc	r31, r11
    c848:	14 91       	lpm	r17, Z+
    c84a:	1b 37       	cpi	r17, 0x7B	; 123
    c84c:	51 f7       	brne	.-44     	; 0xc822 <MenuOut+0xe8>
			T_Param Param;
			Param.Pos = LCD_Buf[Y]+X;
    c84e:	8f 81       	ldd	r24, Y+7	; 0x07
    c850:	98 85       	ldd	r25, Y+8	; 0x08
    c852:	a8 0f       	add	r26, r24
    c854:	b9 1f       	adc	r27, r25
    c856:	a8 5a       	subi	r26, 0xA8	; 168
    c858:	b9 4f       	sbci	r27, 0xF9	; 249
    c85a:	ba 83       	std	Y+2, r27	; 0x02
    c85c:	a9 83       	std	Y+1, r26	; 0x01
    c85e:	81 e0       	ldi	r24, 0x01	; 1
    c860:	f9 01       	movw	r30, r18
    c862:	e8 0f       	add	r30, r24
    c864:	f1 1d       	adc	r31, r1
    c866:	ec 0d       	add	r30, r12
    c868:	fd 1d       	adc	r31, r13
    c86a:	ea 0d       	add	r30, r10
    c86c:	fb 1d       	adc	r31, r11
    c86e:	14 91       	lpm	r17, Z+
    c870:	98 2f       	mov	r25, r24
    c872:	8f 5f       	subi	r24, 0xFF	; 255
			Param.Size = 0;
			while((Char=prc(CurrStr+X-Xs+ ++Param.Size))=='{');
    c874:	1b 37       	cpi	r17, 0x7B	; 123
    c876:	a1 f3       	breq	.-24     	; 0xc860 <MenuOut+0x126>
    c878:	9c 83       	std	Y+4, r25	; 0x04

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    c87a:	e5 e0       	ldi	r30, 0x05	; 5
    c87c:	f0 e0       	ldi	r31, 0x00	; 0
    c87e:	ee 0e       	add	r14, r30
    c880:	ff 1e       	adc	r15, r31
    c882:	f7 01       	movw	r30, r14
    c884:	84 91       	lpm	r24, Z+
    c886:	2b ef       	ldi	r18, 0xFB	; 251
    c888:	3f ef       	ldi	r19, 0xFF	; 255
    c88a:	e2 0e       	add	r14, r18
    c88c:	f3 1e       	adc	r15, r19
			Param.Prec = prb(&IF->Prec);
    c88e:	8b 83       	std	Y+3, r24	; 0x03

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    c890:	f7 01       	movw	r30, r14
    c892:	33 96       	adiw	r30, 0x03	; 3
    c894:	85 91       	lpm	r24, Z+
    c896:	94 91       	lpm	r25, Z+
			Param.Txt = prp(&IF->EnumList);
    c898:	9e 83       	std	Y+6, r25	; 0x06
    c89a:	8d 83       	std	Y+5, r24	; 0x05

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    c89c:	f7 01       	movw	r30, r14
    c89e:	84 91       	lpm	r24, Z+

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    c8a0:	31 96       	adiw	r30, 0x01	; 1
    c8a2:	65 91       	lpm	r22, Z+
    c8a4:	74 91       	lpm	r23, Z+
			PutField(prb(&IF->Type), prp(&IF->Var), &Param);
    c8a6:	ae 01       	movw	r20, r28
    c8a8:	4f 5f       	subi	r20, 0xFF	; 255
    c8aa:	5f 4f       	sbci	r21, 0xFF	; 255
    c8ac:	0e 94 bc 5f 	call	0xbf78	; 0xbf78 <PutField>
			IF++;
    c8b0:	26 e0       	ldi	r18, 0x06	; 6
    c8b2:	30 e0       	ldi	r19, 0x00	; 0
    c8b4:	e2 0e       	add	r14, r18
    c8b6:	f3 1e       	adc	r15, r19
			X += Param.Size;
    c8b8:	8c 81       	ldd	r24, Y+4	; 0x04
    c8ba:	08 0f       	add	r16, r24
    c8bc:	a0 2f       	mov	r26, r16
    c8be:	b0 e0       	ldi	r27, 0x00	; 0
		}
		LCD_Buf[Y][X] = Char;
    c8c0:	a8 0d       	add	r26, r8
    c8c2:	b9 1d       	adc	r27, r9
    c8c4:	a8 5a       	subi	r26, 0xA8	; 168
    c8c6:	b9 4f       	sbci	r27, 0xF9	; 249
    c8c8:	1c 93       	st	X, r17
		X1 = X0 + (strlen_P(CurrStr) - 2);
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';		
	}
	//---

	for(X=X0; X<X1; X++){
    c8ca:	0f 5f       	subi	r16, 0xFF	; 255
    c8cc:	05 15       	cp	r16, r5
    c8ce:	08 f4       	brcc	.+2      	; 0xc8d2 <MenuOut+0x198>
    c8d0:	b1 cf       	rjmp	.-158    	; 0xc834 <MenuOut+0xfa>
    c8d2:	a0 90 f5 04 	lds	r10, 0x04F5
    c8d6:	b0 90 f6 04 	lds	r11, 0x04F6
			X += Param.Size;
		}
		LCD_Buf[Y][X] = Char;
	}
	X=X1;
	for(;X<LCDXSz; X++) LCD_Buf[Y][X] = ' ';
    c8da:	33 e1       	ldi	r19, 0x13	; 19
    c8dc:	35 15       	cp	r19, r5
    c8de:	08 f0       	brcs	.+2      	; 0xc8e2 <MenuOut+0x1a8>
    c8e0:	9f c0       	rjmp	.+318    	; 0xca20 <MenuOut+0x2e6>
    c8e2:	08 94       	sec
    c8e4:	21 1c       	adc	r2, r1
    c8e6:	31 1c       	adc	r3, r1
    c8e8:	ef 81       	ldd	r30, Y+7	; 0x07
    c8ea:	f8 85       	ldd	r31, Y+8	; 0x08
    c8ec:	75 96       	adiw	r30, 0x15	; 21
    c8ee:	f8 87       	std	Y+8, r31	; 0x08
    c8f0:	ef 83       	std	Y+7, r30	; 0x07
void
MenuOut(void)
{
	uint8_t Y;
	if(CurrMsg) {
		for(Y=0; Y<LCDYSz; PutMsgLine(Y++));
    c8f2:	f4 e0       	ldi	r31, 0x04	; 4
    c8f4:	2f 16       	cp	r2, r31
    c8f6:	31 04       	cpc	r3, r1
    c8f8:	09 f0       	breq	.+2      	; 0xc8fc <MenuOut+0x1c2>
    c8fa:	47 cf       	rjmp	.-370    	; 0xc78a <MenuOut+0x50>
		EventFunc(&CurrMsg->Run);
    c8fc:	c5 01       	movw	r24, r10
    c8fe:	82 5a       	subi	r24, 0xA2	; 162
    c900:	9f 4f       	sbci	r25, 0xFF	; 255
    c902:	0e 94 b0 3f 	call	0x7f60	; 0x7f60 <EventFunc>
	if(prb(&CurrPage->LineNumber)>LCDYSz || Fix<LCDYSz-1 || prp(&(GetLine+CurrLine)->OF_List))
		LCD_Buf[CurrLCD][0] = CharCursor;
	if(++Blink>16)
		Blink=0;
	EventFunc(&CurrPage->Run);
}
    c906:	2a 96       	adiw	r28, 0x0a	; 10
    c908:	0f b6       	in	r0, 0x3f	; 63
    c90a:	f8 94       	cli
    c90c:	de bf       	out	0x3e, r29	; 62
    c90e:	0f be       	out	0x3f, r0	; 63
    c910:	cd bf       	out	0x3d, r28	; 61
    c912:	cf 91       	pop	r28
    c914:	df 91       	pop	r29
    c916:	1f 91       	pop	r17
    c918:	0f 91       	pop	r16
    c91a:	ff 90       	pop	r15
    c91c:	ef 90       	pop	r14
    c91e:	df 90       	pop	r13
    c920:	cf 90       	pop	r12
    c922:	bf 90       	pop	r11
    c924:	af 90       	pop	r10
    c926:	9f 90       	pop	r9
    c928:	8f 90       	pop	r8
    c92a:	7f 90       	pop	r7
    c92c:	6f 90       	pop	r6
    c92e:	5f 90       	pop	r5
    c930:	4f 90       	pop	r4
    c932:	3f 90       	pop	r3
    c934:	2f 90       	pop	r2
    c936:	08 95       	ret

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    c938:	f9 01       	movw	r30, r18
    c93a:	31 96       	adiw	r30, 0x01	; 1
    c93c:	ea 0d       	add	r30, r10
    c93e:	fb 1d       	adc	r31, r11
    c940:	e4 91       	lpm	r30, Z+
	uint8_t X;
	uint8_t X0=0;
	uint8_t X1=LCDXSz;
	int8_t Xs = 0;
	//--- ">>" Align right
	if(prc(CurrStr+0) == '>' && prc(CurrStr+1) == '>'){
    c942:	ee 33       	cpi	r30, 0x3E	; 62
    c944:	09 f0       	breq	.+2      	; 0xc948 <MenuOut+0x20e>
    c946:	45 cf       	rjmp	.-374    	; 0xc7d2 <MenuOut+0x98>
		X0 = LCDXSz - strlen_P(CurrStr) + 2;
    c948:	c7 01       	movw	r24, r14
    c94a:	0e 94 36 84 	call	0x1086c	; 0x1086c <strlen_P>
    c94e:	06 e1       	ldi	r16, 0x16	; 22
    c950:	08 1b       	sub	r16, r24
		Xs = X0-2;
    c952:	90 2f       	mov	r25, r16
    c954:	92 50       	subi	r25, 0x02	; 2
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';
    c956:	00 23       	and	r16, r16
    c958:	09 f4       	brne	.+2      	; 0xc95c <MenuOut+0x222>
    c95a:	3d cf       	rjmp	.-390    	; 0xc7d6 <MenuOut+0x9c>
    c95c:	f6 01       	movw	r30, r12
    c95e:	e8 19       	sub	r30, r8
    c960:	f9 09       	sbc	r31, r9
    c962:	e8 5a       	subi	r30, 0xA8	; 168
    c964:	f9 4f       	sbci	r31, 0xF9	; 249
    c966:	80 e0       	ldi	r24, 0x00	; 0
    c968:	41 92       	st	Z+, r4
    c96a:	8f 5f       	subi	r24, 0xFF	; 255
    c96c:	80 17       	cp	r24, r16
    c96e:	e0 f3       	brcs	.-8      	; 0xc968 <MenuOut+0x22e>
    c970:	f7 01       	movw	r30, r14
    c972:	84 91       	lpm	r24, Z+
	}
	//--- "<<" Align left
	if(prc(CurrStr+0) == '<' && prc(CurrStr+1) == '<'){
    c974:	8c 33       	cpi	r24, 0x3C	; 60
    c976:	09 f0       	breq	.+2      	; 0xc97a <MenuOut+0x240>
    c978:	33 cf       	rjmp	.-410    	; 0xc7e0 <MenuOut+0xa6>
    c97a:	e9 85       	ldd	r30, Y+9	; 0x09
    c97c:	fa 85       	ldd	r31, Y+10	; 0x0a
    c97e:	e2 0d       	add	r30, r2
    c980:	f3 1d       	adc	r31, r3
    c982:	ee 0f       	add	r30, r30
    c984:	ff 1f       	adc	r31, r31
    c986:	ee 0f       	add	r30, r30
    c988:	ff 1f       	adc	r31, r31
    c98a:	ee 0f       	add	r30, r30
    c98c:	ff 1f       	adc	r31, r31
    c98e:	e2 19       	sub	r30, r2
    c990:	f3 09       	sbc	r31, r3
    c992:	31 96       	adiw	r30, 0x01	; 1
    c994:	ea 0d       	add	r30, r10
    c996:	fb 1d       	adc	r31, r11
    c998:	e4 91       	lpm	r30, Z+
    c99a:	ec 33       	cpi	r30, 0x3C	; 60
    c99c:	09 f0       	breq	.+2      	; 0xc9a0 <MenuOut+0x266>
    c99e:	20 cf       	rjmp	.-448    	; 0xc7e0 <MenuOut+0xa6>
		X1 = strlen_P(CurrStr) - 2;
    c9a0:	c7 01       	movw	r24, r14
    c9a2:	0e 94 36 84 	call	0x1086c	; 0x1086c <strlen_P>
    c9a6:	ae ef       	ldi	r26, 0xFE	; 254
    c9a8:	5a 2e       	mov	r5, r26
    c9aa:	58 0e       	add	r5, r24
    c9ac:	9e ef       	ldi	r25, 0xFE	; 254
    c9ae:	00 e0       	ldi	r16, 0x00	; 0
    c9b0:	f7 01       	movw	r30, r14
    c9b2:	84 91       	lpm	r24, Z+
		X0 = 0;
		Xs = X0-2;
	}
	//--- "<>" Align center
	if(prc(CurrStr+0) == '<' && prc(CurrStr+1) == '>'){
    c9b4:	8c 33       	cpi	r24, 0x3C	; 60
    c9b6:	09 f0       	breq	.+2      	; 0xc9ba <MenuOut+0x280>
    c9b8:	1a cf       	rjmp	.-460    	; 0xc7ee <MenuOut+0xb4>
    c9ba:	89 84       	ldd	r8, Y+9	; 0x09
    c9bc:	9a 84       	ldd	r9, Y+10	; 0x0a
    c9be:	82 0c       	add	r8, r2
    c9c0:	93 1c       	adc	r9, r3
    c9c2:	64 01       	movw	r12, r8
    c9c4:	cc 0c       	add	r12, r12
    c9c6:	dd 1c       	adc	r13, r13
    c9c8:	cc 0c       	add	r12, r12
    c9ca:	dd 1c       	adc	r13, r13
    c9cc:	cc 0c       	add	r12, r12
    c9ce:	dd 1c       	adc	r13, r13
    c9d0:	f6 01       	movw	r30, r12
    c9d2:	e2 19       	sub	r30, r2
    c9d4:	f3 09       	sbc	r31, r3
    c9d6:	31 96       	adiw	r30, 0x01	; 1
    c9d8:	ea 0d       	add	r30, r10
    c9da:	fb 1d       	adc	r31, r11
    c9dc:	e4 91       	lpm	r30, Z+
    c9de:	ee 33       	cpi	r30, 0x3E	; 62
    c9e0:	09 f0       	breq	.+2      	; 0xc9e4 <MenuOut+0x2aa>
    c9e2:	05 cf       	rjmp	.-502    	; 0xc7ee <MenuOut+0xb4>
		X0 = (LCDXSz - strlen_P(CurrStr) + 2) / 2;
    c9e4:	c7 01       	movw	r24, r14
    c9e6:	0e 94 36 84 	call	0x1086c	; 0x1086c <strlen_P>
    c9ea:	26 e1       	ldi	r18, 0x16	; 22
    c9ec:	30 e0       	ldi	r19, 0x00	; 0
    c9ee:	28 1b       	sub	r18, r24
    c9f0:	39 0b       	sbc	r19, r25
    c9f2:	36 95       	lsr	r19
    c9f4:	27 95       	ror	r18
    c9f6:	02 2f       	mov	r16, r18
		Xs = X0-2;
    c9f8:	92 2f       	mov	r25, r18
    c9fa:	92 50       	subi	r25, 0x02	; 2
		X1 = X0 + (strlen_P(CurrStr) - 2);
    c9fc:	6e ef       	ldi	r22, 0xFE	; 254
    c9fe:	56 2e       	mov	r5, r22
    ca00:	58 0e       	add	r5, r24
    ca02:	52 0e       	add	r5, r18
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';		
    ca04:	22 23       	and	r18, r18
    ca06:	09 f4       	brne	.+2      	; 0xca0a <MenuOut+0x2d0>
    ca08:	f2 ce       	rjmp	.-540    	; 0xc7ee <MenuOut+0xb4>
    ca0a:	f6 01       	movw	r30, r12
    ca0c:	e8 19       	sub	r30, r8
    ca0e:	f9 09       	sbc	r31, r9
    ca10:	e8 5a       	subi	r30, 0xA8	; 168
    ca12:	f9 4f       	sbci	r31, 0xF9	; 249
    ca14:	80 e0       	ldi	r24, 0x00	; 0
    ca16:	41 92       	st	Z+, r4
    ca18:	8f 5f       	subi	r24, 0xFF	; 255
    ca1a:	80 17       	cp	r24, r16
    ca1c:	e0 f3       	brcs	.-8      	; 0xca16 <MenuOut+0x2dc>
    ca1e:	e7 ce       	rjmp	.-562    	; 0xc7ee <MenuOut+0xb4>
			X += Param.Size;
		}
		LCD_Buf[Y][X] = Char;
	}
	X=X1;
	for(;X<LCDXSz; X++) LCD_Buf[Y][X] = ' ';
    ca20:	89 85       	ldd	r24, Y+9	; 0x09
    ca22:	9a 85       	ldd	r25, Y+10	; 0x0a
    ca24:	82 0d       	add	r24, r2
    ca26:	93 1d       	adc	r25, r3
    ca28:	9c 01       	movw	r18, r24
    ca2a:	22 0f       	add	r18, r18
    ca2c:	33 1f       	adc	r19, r19
    ca2e:	22 0f       	add	r18, r18
    ca30:	33 1f       	adc	r19, r19
    ca32:	22 0f       	add	r18, r18
    ca34:	33 1f       	adc	r19, r19
    ca36:	28 1b       	sub	r18, r24
    ca38:	39 0b       	sbc	r19, r25
    ca3a:	f9 01       	movw	r30, r18
    ca3c:	e5 0d       	add	r30, r5
    ca3e:	f1 1d       	adc	r31, r1
    ca40:	e8 5a       	subi	r30, 0xA8	; 168
    ca42:	f9 4f       	sbci	r31, 0xF9	; 249
    ca44:	40 82       	st	Z, r4
    ca46:	53 94       	inc	r5
    ca48:	83 e1       	ldi	r24, 0x13	; 19
    ca4a:	85 15       	cp	r24, r5
    ca4c:	08 f4       	brcc	.+2      	; 0xca50 <MenuOut+0x316>
    ca4e:	49 cf       	rjmp	.-366    	; 0xc8e2 <MenuOut+0x1a8>
    ca50:	f4 cf       	rjmp	.-24     	; 0xca3a <MenuOut+0x300>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    ca52:	40 91 d4 02 	lds	r20, 0x02D4
    ca56:	50 91 d5 02 	lds	r21, 0x02D5
    ca5a:	4d 5f       	subi	r20, 0xFD	; 253
    ca5c:	5f 4f       	sbci	r21, 0xFF	; 255
    ca5e:	fa 01       	movw	r30, r20
    ca60:	e4 90       	lpm	r14, Z+
    ca62:	43 50       	subi	r20, 0x03	; 3
    ca64:	50 40       	sbci	r21, 0x00	; 0
		for(Y=0; Y<LCDYSz; PutMsgLine(Y++));
		EventFunc(&CurrMsg->Run);
		return;
	}
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
    ca66:	c0 90 ca 07 	lds	r12, 0x07CA
    ca6a:	d0 90 e8 08 	lds	r13, 0x08E8
	for(Y=0; Y<Fix; Y++)
    ca6e:	ee 20       	and	r14, r14
    ca70:	09 f4       	brne	.+2      	; 0xca74 <MenuOut+0x33a>
    ca72:	a6 c0       	rjmp	.+332    	; 0xcbc0 <MenuOut+0x486>
    ca74:	00 e0       	ldi	r16, 0x00	; 0
    ca76:	10 e0       	ldi	r17, 0x00	; 0
// ~~~~~~~~~~~~~~~~~~
inline static void
PutBlankLine(uint8_t Y)
{
	uint8_t X=0;
	while(X<LCDXSz)	LCD_Buf[Y][X++] = ' ';
    ca78:	80 e2       	ldi	r24, 0x20	; 32
    ca7a:	f8 2e       	mov	r15, r24
    ca7c:	4e 5f       	subi	r20, 0xFE	; 254
    ca7e:	5f 4f       	sbci	r21, 0xFF	; 255
    ca80:	fa 01       	movw	r30, r20
    ca82:	84 91       	lpm	r24, Z+
    ca84:	42 50       	subi	r20, 0x02	; 2
    ca86:	50 40       	sbci	r21, 0x00	; 0
		return;
	}
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
    ca88:	08 17       	cp	r16, r24
    ca8a:	08 f4       	brcc	.+2      	; 0xca8e <MenuOut+0x354>
    ca8c:	69 c0       	rjmp	.+210    	; 0xcb60 <MenuOut+0x426>
    ca8e:	c8 01       	movw	r24, r16
    ca90:	88 0f       	add	r24, r24
    ca92:	99 1f       	adc	r25, r25
    ca94:	80 0f       	add	r24, r16
    ca96:	91 1f       	adc	r25, r17
    ca98:	fc 01       	movw	r30, r24
    ca9a:	ee 0f       	add	r30, r30
    ca9c:	ff 1f       	adc	r31, r31
    ca9e:	ee 0f       	add	r30, r30
    caa0:	ff 1f       	adc	r31, r31
    caa2:	ee 0f       	add	r30, r30
    caa4:	ff 1f       	adc	r31, r31
    caa6:	e8 1b       	sub	r30, r24
    caa8:	f9 0b       	sbc	r31, r25
    caaa:	e8 5a       	subi	r30, 0xA8	; 168
    caac:	f9 4f       	sbci	r31, 0xF9	; 249
    caae:	80 e0       	ldi	r24, 0x00	; 0
// ~~~~~~~~~~~~~~~~~~
inline static void
PutBlankLine(uint8_t Y)
{
	uint8_t X=0;
	while(X<LCDXSz)	LCD_Buf[Y][X++] = ' ';
    cab0:	f1 92       	st	Z+, r15
    cab2:	8f 5f       	subi	r24, 0xFF	; 255
    cab4:	84 31       	cpi	r24, 0x14	; 20
    cab6:	e1 f7       	brne	.-8      	; 0xcab0 <MenuOut+0x376>
	}
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Y, Y);
    cab8:	0f 5f       	subi	r16, 0xFF	; 255
    caba:	1f 4f       	sbci	r17, 0xFF	; 255
		EventFunc(&CurrMsg->Run);
		return;
	}
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
    cabc:	0e 15       	cp	r16, r14
    cabe:	f0 f2       	brcs	.-68     	; 0xca7c <MenuOut+0x342>
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Y, Y);
	for(; Y<LCDYSz; Y++)
    cac0:	f3 e0       	ldi	r31, 0x03	; 3
    cac2:	fe 15       	cp	r31, r14
    cac4:	f0 f0       	brcs	.+60     	; 0xcb02 <MenuOut+0x3c8>
    cac6:	1e 2d       	mov	r17, r14
		EventFunc(&CurrMsg->Run);
		return;
	}
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
    cac8:	fc 2c       	mov	r15, r12
    caca:	fd 18       	sub	r15, r13
    cacc:	f1 0e       	add	r15, r17
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Y, Y);
	for(; Y<LCDYSz; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
    cace:	95 e1       	ldi	r25, 0x15	; 21
    cad0:	d9 2e       	mov	r13, r25
// ~~~~~~~~~~~~~~~~~~
inline static void
PutBlankLine(uint8_t Y)
{
	uint8_t X=0;
	while(X<LCDXSz)	LCD_Buf[Y][X++] = ' ';
    cad2:	00 e2       	ldi	r16, 0x20	; 32
    cad4:	4e 5f       	subi	r20, 0xFE	; 254
    cad6:	5f 4f       	sbci	r21, 0xFF	; 255
    cad8:	fa 01       	movw	r30, r20
    cada:	84 91       	lpm	r24, Z+
    cadc:	42 50       	subi	r20, 0x02	; 2
    cade:	50 40       	sbci	r21, 0x00	; 0
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Y, Y);
	for(; Y<LCDYSz; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
    cae0:	18 17       	cp	r17, r24
    cae2:	08 f4       	brcc	.+2      	; 0xcae6 <MenuOut+0x3ac>
    cae4:	4b c0       	rjmp	.+150    	; 0xcb7c <MenuOut+0x442>
    cae6:	1d 9d       	mul	r17, r13
    cae8:	f0 01       	movw	r30, r0
    caea:	11 24       	eor	r1, r1
    caec:	e8 5a       	subi	r30, 0xA8	; 168
    caee:	f9 4f       	sbci	r31, 0xF9	; 249
    caf0:	80 e0       	ldi	r24, 0x00	; 0
// ~~~~~~~~~~~~~~~~~~
inline static void
PutBlankLine(uint8_t Y)
{
	uint8_t X=0;
	while(X<LCDXSz)	LCD_Buf[Y][X++] = ' ';
    caf2:	01 93       	st	Z+, r16
    caf4:	8f 5f       	subi	r24, 0xFF	; 255
    caf6:	84 31       	cpi	r24, 0x14	; 20
    caf8:	e1 f7       	brne	.-8      	; 0xcaf2 <MenuOut+0x3b8>
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Y, Y);
	for(; Y<LCDYSz; Y++)
    cafa:	1f 5f       	subi	r17, 0xFF	; 255
    cafc:	f3 94       	inc	r15
    cafe:	14 30       	cpi	r17, 0x04	; 4
    cb00:	48 f3       	brcs	.-46     	; 0xcad4 <MenuOut+0x39a>
    cb02:	4e 5f       	subi	r20, 0xFE	; 254
    cb04:	5f 4f       	sbci	r21, 0xFF	; 255
    cb06:	fa 01       	movw	r30, r20
    cb08:	84 91       	lpm	r24, Z+
    cb0a:	42 50       	subi	r20, 0x02	; 2
    cb0c:	50 40       	sbci	r21, 0x00	; 0
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Dist+Y, Y);
	if(prb(&CurrPage->LineNumber)>LCDYSz || Fix<LCDYSz-1 || prp(&(GetLine+CurrLine)->OF_List))
    cb0e:	85 30       	cpi	r24, 0x05	; 5
    cb10:	20 f4       	brcc	.+8      	; 0xcb1a <MenuOut+0x3e0>
    cb12:	f2 e0       	ldi	r31, 0x02	; 2
    cb14:	fe 15       	cp	r31, r14
    cb16:	08 f4       	brcc	.+2      	; 0xcb1a <MenuOut+0x3e0>
    cb18:	3f c0       	rjmp	.+126    	; 0xcb98 <MenuOut+0x45e>
		LCD_Buf[CurrLCD][0] = CharCursor;
    cb1a:	80 91 e8 08 	lds	r24, 0x08E8
    cb1e:	90 e0       	ldi	r25, 0x00	; 0
    cb20:	9c 01       	movw	r18, r24
    cb22:	22 0f       	add	r18, r18
    cb24:	33 1f       	adc	r19, r19
    cb26:	28 0f       	add	r18, r24
    cb28:	39 1f       	adc	r19, r25
    cb2a:	f9 01       	movw	r30, r18
    cb2c:	ee 0f       	add	r30, r30
    cb2e:	ff 1f       	adc	r31, r31
    cb30:	ee 0f       	add	r30, r30
    cb32:	ff 1f       	adc	r31, r31
    cb34:	ee 0f       	add	r30, r30
    cb36:	ff 1f       	adc	r31, r31
    cb38:	e2 1b       	sub	r30, r18
    cb3a:	f3 0b       	sbc	r31, r19
    cb3c:	e8 5a       	subi	r30, 0xA8	; 168
    cb3e:	f9 4f       	sbci	r31, 0xF9	; 249
    cb40:	80 e1       	ldi	r24, 0x10	; 16
    cb42:	80 83       	st	Z, r24
	if(++Blink>16)
    cb44:	80 91 18 09 	lds	r24, 0x0918
    cb48:	8f 5f       	subi	r24, 0xFF	; 255
    cb4a:	80 93 18 09 	sts	0x0918, r24
    cb4e:	81 31       	cpi	r24, 0x11	; 17
    cb50:	10 f0       	brcs	.+4      	; 0xcb56 <MenuOut+0x41c>
		Blink=0;
    cb52:	10 92 18 09 	sts	0x0918, r1
	EventFunc(&CurrPage->Run);
    cb56:	ca 01       	movw	r24, r20
    cb58:	08 96       	adiw	r24, 0x08	; 8
    cb5a:	0e 94 b0 3f 	call	0x7f60	; 0x7f60 <EventFunc>
    cb5e:	d3 ce       	rjmp	.-602    	; 0xc906 <MenuOut+0x1cc>
	}
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Y, Y);
    cb60:	80 2f       	mov	r24, r16
    cb62:	60 2f       	mov	r22, r16
    cb64:	0e 94 41 61 	call	0xc282	; 0xc282 <PutLine>
    cb68:	40 91 d4 02 	lds	r20, 0x02D4
    cb6c:	50 91 d5 02 	lds	r21, 0x02D5
    cb70:	0f 5f       	subi	r16, 0xFF	; 255
    cb72:	1f 4f       	sbci	r17, 0xFF	; 255
		EventFunc(&CurrMsg->Run);
		return;
	}
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
    cb74:	0e 15       	cp	r16, r14
    cb76:	08 f4       	brcc	.+2      	; 0xcb7a <MenuOut+0x440>
    cb78:	81 cf       	rjmp	.-254    	; 0xca7c <MenuOut+0x342>
    cb7a:	a2 cf       	rjmp	.-188    	; 0xcac0 <MenuOut+0x386>
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Y, Y);
	for(; Y<LCDYSz; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Dist+Y, Y);
    cb7c:	8f 2d       	mov	r24, r15
    cb7e:	61 2f       	mov	r22, r17
    cb80:	0e 94 41 61 	call	0xc282	; 0xc282 <PutLine>
    cb84:	40 91 d4 02 	lds	r20, 0x02D4
    cb88:	50 91 d5 02 	lds	r21, 0x02D5
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Y, Y);
	for(; Y<LCDYSz; Y++)
    cb8c:	1f 5f       	subi	r17, 0xFF	; 255
    cb8e:	f3 94       	inc	r15
    cb90:	14 30       	cpi	r17, 0x04	; 4
    cb92:	08 f4       	brcc	.+2      	; 0xcb96 <MenuOut+0x45c>
    cb94:	9f cf       	rjmp	.-194    	; 0xcad4 <MenuOut+0x39a>
    cb96:	b5 cf       	rjmp	.-150    	; 0xcb02 <MenuOut+0x3c8>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    cb98:	fa 01       	movw	r30, r20
    cb9a:	65 91       	lpm	r22, Z+
    cb9c:	74 91       	lpm	r23, Z+
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Dist+Y, Y);
	if(prb(&CurrPage->LineNumber)>LCDYSz || Fix<LCDYSz-1 || prp(&(GetLine+CurrLine)->OF_List))
    cb9e:	80 91 ca 07 	lds	r24, 0x07CA
    cba2:	2b e1       	ldi	r18, 0x1B	; 27
    cba4:	82 9f       	mul	r24, r18
    cba6:	c0 01       	movw	r24, r0
    cba8:	11 24       	eor	r1, r1
    cbaa:	68 0f       	add	r22, r24
    cbac:	79 1f       	adc	r23, r25
    cbae:	69 5e       	subi	r22, 0xE9	; 233
    cbb0:	7f 4f       	sbci	r23, 0xFF	; 255
    cbb2:	fb 01       	movw	r30, r22
    cbb4:	85 91       	lpm	r24, Z+
    cbb6:	94 91       	lpm	r25, Z+
    cbb8:	89 2b       	or	r24, r25
    cbba:	09 f0       	breq	.+2      	; 0xcbbe <MenuOut+0x484>
    cbbc:	ae cf       	rjmp	.-164    	; 0xcb1a <MenuOut+0x3e0>
    cbbe:	c2 cf       	rjmp	.-124    	; 0xcb44 <MenuOut+0x40a>
		EventFunc(&CurrMsg->Run);
		return;
	}
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
    cbc0:	10 e0       	ldi	r17, 0x00	; 0
    cbc2:	82 cf       	rjmp	.-252    	; 0xcac8 <MenuOut+0x38e>

0000cbc4 <LCD_Sweep>:

// ~~~~~~~~~~~~
static void
LCD_Sweep(void)
{
	if(LCD_Rdy()) {
    cbc4:	0e 94 b5 29 	call	0x536a	; 0x536a <LCD_Rdy>
    cbc8:	88 23       	and	r24, r24
    cbca:	09 f4       	brne	.+2      	; 0xcbce <LCD_Sweep+0xa>
    cbcc:	08 95       	ret
		MenuOut();
    cbce:	0e 94 9d 63 	call	0xc73a	; 0xc73a <MenuOut>
		LCD_Out();
    cbd2:	0e 94 cb 29 	call	0x5396	; 0x5396 <LCD_Out>
    cbd6:	08 95       	ret

0000cbd8 <strcpy_EE>:
	}//while
	return GSM_RxCharN;
}
// ~~~~~~~~~~~
//    EEPROM   RAM     '\0'    EEPROM
uint8_t strcpy_EE(char* str_RAM, uint8_t* str_EE){
    cbd8:	cf 92       	push	r12
    cbda:	df 92       	push	r13
    cbdc:	ef 92       	push	r14
    cbde:	ff 92       	push	r15
    cbe0:	1f 93       	push	r17
    cbe2:	cf 93       	push	r28
    cbe4:	df 93       	push	r29
    cbe6:	6c 01       	movw	r12, r24
    cbe8:	7b 01       	movw	r14, r22
    cbea:	10 e0       	ldi	r17, 0x00	; 0
    cbec:	06 c0       	rjmp	.+12     	; 0xcbfa <strcpy_EE+0x22>
	uint8_t i=0;
	while( (erb(&str_EE[i])!='\0') && (erb(&str_EE[i])!=' ') ){
    cbee:	80 32       	cpi	r24, 0x20	; 32
    cbf0:	69 f0       	breq	.+26     	; 0xcc0c <strcpy_EE+0x34>
		str_RAM[i] = (char)erb(&str_EE[i]);
    cbf2:	cc 0d       	add	r28, r12
    cbf4:	dd 1d       	adc	r29, r13
    cbf6:	88 83       	st	Y, r24
		i++;
    cbf8:	1f 5f       	subi	r17, 0xFF	; 255
}
// ~~~~~~~~~~~
//    EEPROM   RAM     '\0'    EEPROM
uint8_t strcpy_EE(char* str_RAM, uint8_t* str_EE){
	uint8_t i=0;
	while( (erb(&str_EE[i])!='\0') && (erb(&str_EE[i])!=' ') ){
    cbfa:	c1 2f       	mov	r28, r17
    cbfc:	d0 e0       	ldi	r29, 0x00	; 0
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    cbfe:	c7 01       	movw	r24, r14
    cc00:	8c 0f       	add	r24, r28
    cc02:	9d 1f       	adc	r25, r29
    cc04:	0e 94 50 87 	call	0x10ea0	; 0x10ea0 <__eerd_byte_m2560>
    cc08:	88 23       	and	r24, r24
    cc0a:	89 f7       	brne	.-30     	; 0xcbee <strcpy_EE+0x16>
		str_RAM[i] = (char)erb(&str_EE[i]);
		i++;
	}
	return i;	
}
    cc0c:	81 2f       	mov	r24, r17
    cc0e:	df 91       	pop	r29
    cc10:	cf 91       	pop	r28
    cc12:	1f 91       	pop	r17
    cc14:	ff 90       	pop	r15
    cc16:	ef 90       	pop	r14
    cc18:	df 90       	pop	r13
    cc1a:	cf 90       	pop	r12
    cc1c:	08 95       	ret

0000cc1e <GSM_Cycle>:
	}//switch
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
void
GSM_Cycle(void)
{
    cc1e:	7f 92       	push	r7
    cc20:	8f 92       	push	r8
    cc22:	9f 92       	push	r9
    cc24:	af 92       	push	r10
    cc26:	bf 92       	push	r11
    cc28:	cf 92       	push	r12
    cc2a:	df 92       	push	r13
    cc2c:	ef 92       	push	r14
    cc2e:	ff 92       	push	r15
    cc30:	0f 93       	push	r16
    cc32:	1f 93       	push	r17
    cc34:	df 93       	push	r29
    cc36:	cf 93       	push	r28
    cc38:	cd b7       	in	r28, 0x3d	; 61
    cc3a:	de b7       	in	r29, 0x3e	; 62
    cc3c:	65 97       	sbiw	r28, 0x15	; 21
    cc3e:	0f b6       	in	r0, 0x3f	; 63
    cc40:	f8 94       	cli
    cc42:	de bf       	out	0x3e, r29	; 62
    cc44:	0f be       	out	0x3f, r0	; 63
    cc46:	cd bf       	out	0x3d, r28	; 61
	switch(GSM_Control){
    cc48:	80 91 d1 07 	lds	r24, 0x07D1
    cc4c:	88 23       	and	r24, r24
    cc4e:	d9 f4       	brne	.+54     	; 0xcc86 <GSM_Cycle+0x68>
	else return 0;
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Auto(){

	switch(GSM_State){
    cc50:	80 91 f6 06 	lds	r24, 0x06F6
    cc54:	e8 2f       	mov	r30, r24
    cc56:	f0 e0       	ldi	r31, 0x00	; 0
    cc58:	ea 35       	cpi	r30, 0x5A	; 90
    cc5a:	f1 05       	cpc	r31, r1
    cc5c:	68 f1       	brcs	.+90     	; 0xccb8 <GSM_Cycle+0x9a>
			break;	
		case GSM_CNTL_CONFIG:
			GSM_Config();
			break;								
	}
}
    cc5e:	65 96       	adiw	r28, 0x15	; 21
    cc60:	0f b6       	in	r0, 0x3f	; 63
    cc62:	f8 94       	cli
    cc64:	de bf       	out	0x3e, r29	; 62
    cc66:	0f be       	out	0x3f, r0	; 63
    cc68:	cd bf       	out	0x3d, r28	; 61
    cc6a:	cf 91       	pop	r28
    cc6c:	df 91       	pop	r29
    cc6e:	1f 91       	pop	r17
    cc70:	0f 91       	pop	r16
    cc72:	ff 90       	pop	r15
    cc74:	ef 90       	pop	r14
    cc76:	df 90       	pop	r13
    cc78:	cf 90       	pop	r12
    cc7a:	bf 90       	pop	r11
    cc7c:	af 90       	pop	r10
    cc7e:	9f 90       	pop	r9
    cc80:	8f 90       	pop	r8
    cc82:	7f 90       	pop	r7
    cc84:	08 95       	ret
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
void
GSM_Cycle(void)
{
	switch(GSM_Control){
    cc86:	82 30       	cpi	r24, 0x02	; 2
    cc88:	51 f7       	brne	.-44     	; 0xcc5e <GSM_Cycle+0x40>
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Manual(){}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Config(){
	switch(GSM_State){
    cc8a:	80 91 f6 06 	lds	r24, 0x06F6
    cc8e:	84 30       	cpi	r24, 0x04	; 4
    cc90:	11 f4       	brne	.+4      	; 0xcc96 <GSM_Cycle+0x78>
    cc92:	0c 94 98 6f 	jmp	0xdf30	; 0xdf30 <GSM_Cycle+0x1312>
    cc96:	85 30       	cpi	r24, 0x05	; 5
    cc98:	b8 f0       	brcs	.+46     	; 0xccc8 <GSM_Cycle+0xaa>
    cc9a:	86 30       	cpi	r24, 0x06	; 6
    cc9c:	11 f4       	brne	.+4      	; 0xcca2 <GSM_Cycle+0x84>
    cc9e:	0c 94 5f 6f 	jmp	0xdebe	; 0xdebe <GSM_Cycle+0x12a0>
    cca2:	86 30       	cpi	r24, 0x06	; 6
    cca4:	48 f1       	brcs	.+82     	; 0xccf8 <GSM_Cycle+0xda>
    cca6:	87 30       	cpi	r24, 0x07	; 7
    cca8:	11 f4       	brne	.+4      	; 0xccae <GSM_Cycle+0x90>
    ccaa:	0c 94 50 6f 	jmp	0xdea0	; 0xdea0 <GSM_Cycle+0x1282>
    ccae:	88 30       	cpi	r24, 0x08	; 8
    ccb0:	b1 f2       	breq	.-84     	; 0xcc5e <GSM_Cycle+0x40>
			if(Timer16Stopp(TD_GSM)) GSM_State++;
			break;
		case GSM_FINISH:			
			break;
		default:
			GSM_State = GSM_CFG_START;
    ccb2:	10 92 f6 06 	sts	0x06F6, r1
    ccb6:	d3 cf       	rjmp	.-90     	; 0xcc5e <GSM_Cycle+0x40>
	else return 0;
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Auto(){

	switch(GSM_State){
    ccb8:	e4 50       	subi	r30, 0x04	; 4
    ccba:	ff 4f       	sbci	r31, 0xFF	; 255
    ccbc:	ee 0f       	add	r30, r30
    ccbe:	ff 1f       	adc	r31, r31
    ccc0:	05 90       	lpm	r0, Z+
    ccc2:	f4 91       	lpm	r31, Z+
    ccc4:	e0 2d       	mov	r30, r0
    ccc6:	19 94       	eijmp
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Manual(){}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Config(){
	switch(GSM_State){
    ccc8:	81 30       	cpi	r24, 0x01	; 1
    ccca:	11 f4       	brne	.+4      	; 0xccd0 <GSM_Cycle+0xb2>
    cccc:	0c 94 85 6f 	jmp	0xdf0a	; 0xdf0a <GSM_Cycle+0x12ec>
    ccd0:	81 30       	cpi	r24, 0x01	; 1
    ccd2:	f0 f0       	brcs	.+60     	; 0xcd10 <GSM_Cycle+0xf2>
    ccd4:	82 30       	cpi	r24, 0x02	; 2
    ccd6:	11 f4       	brne	.+4      	; 0xccdc <GSM_Cycle+0xbe>
    ccd8:	0c 94 75 6f 	jmp	0xdeea	; 0xdeea <GSM_Cycle+0x12cc>
    ccdc:	83 30       	cpi	r24, 0x03	; 3
    ccde:	49 f7       	brne	.-46     	; 0xccb2 <GSM_Cycle+0x94>
			break;
		case GSM_CFG_WAIT_AT_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_CFG_SEND_AT)) GSM_State++;
			break;
		case GSM_CFG_SEND_IPR:
			GSM_Execute_Command(AT_IPR9600, 100); GSM_State++;
    cce0:	80 e7       	ldi	r24, 0x70	; 112
    cce2:	94 e0       	ldi	r25, 0x04	; 4
    cce4:	64 e6       	ldi	r22, 0x64	; 100
    cce6:	70 e0       	ldi	r23, 0x00	; 0
    cce8:	0e 94 9a 4e 	call	0x9d34	; 0x9d34 <GSM_Execute_Command>
    ccec:	80 91 f6 06 	lds	r24, 0x06F6
    ccf0:	8f 5f       	subi	r24, 0xFF	; 255
    ccf2:	80 93 f6 06 	sts	0x06F6, r24
    ccf6:	b3 cf       	rjmp	.-154    	; 0xcc5e <GSM_Cycle+0x40>
				StartTimer16(TD_GSM,200);
				GSM_State++;
			}
			break;
		case GSM_CFG_SEND_ATW:
			GSM_Execute_Command(AT_W, 100); GSM_State++;
    ccf8:	8c e7       	ldi	r24, 0x7C	; 124
    ccfa:	94 e0       	ldi	r25, 0x04	; 4
    ccfc:	64 e6       	ldi	r22, 0x64	; 100
    ccfe:	70 e0       	ldi	r23, 0x00	; 0
    cd00:	0e 94 9a 4e 	call	0x9d34	; 0x9d34 <GSM_Execute_Command>
    cd04:	80 91 f6 06 	lds	r24, 0x06F6
    cd08:	8f 5f       	subi	r24, 0xFF	; 255
    cd0a:	80 93 f6 06 	sts	0x06F6, r24
    cd0e:	a7 cf       	rjmp	.-178    	; 0xcc5e <GSM_Cycle+0x40>
inline static void GSM_Manual(){}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Config(){
	switch(GSM_State){
		case GSM_CFG_START:
			StartTimer16(TD_GSM,200);
    cd10:	80 91 e9 04 	lds	r24, 0x04E9
    cd14:	68 ec       	ldi	r22, 0xC8	; 200
    cd16:	70 e0       	ldi	r23, 0x00	; 0
    cd18:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
		cli();
		PORTL|=(1<<PL5);
		sei();
	}
	void GSM_PWRCNTRL_ON(void){
		cli();
    cd1c:	f8 94       	cli
		PORTL &= ~(1<<PL5);
    cd1e:	80 91 0b 01 	lds	r24, 0x010B
    cd22:	8f 7d       	andi	r24, 0xDF	; 223
    cd24:	80 93 0b 01 	sts	0x010B, r24
		sei();
    cd28:	78 94       	sei
			GSM_PWRCNTRL_ON();
			GSM_State++;
    cd2a:	80 91 f6 06 	lds	r24, 0x06F6
    cd2e:	8f 5f       	subi	r24, 0xFF	; 255
    cd30:	80 93 f6 06 	sts	0x06F6, r24
    cd34:	94 cf       	rjmp	.-216    	; 0xcc5e <GSM_Cycle+0x40>
			break;
		case GSM_SEND_CGMM:
			GSM_Execute_Command(AT_CGMM,5000*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CGMM_READ:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
    cd36:	80 91 e9 04 	lds	r24, 0x04E9
    cd3a:	0e 94 84 1f 	call	0x3f08	; 0x3f08 <Timer16Stopp>
    cd3e:	88 23       	and	r24, r24
    cd40:	19 f0       	breq	.+6      	; 0xcd48 <GSM_Cycle+0x12a>
    cd42:	8a e4       	ldi	r24, 0x4A	; 74
    cd44:	80 93 f6 06 	sts	0x06F6, r24
			if(GetStringFromFIFO()){
    cd48:	0e 94 fe 3b 	call	0x77fc	; 0x77fc <GetStringFromFIFO>
    cd4c:	88 23       	and	r24, r24
    cd4e:	31 f1       	breq	.+76     	; 0xcd9c <GSM_Cycle+0x17e>
				if(!strcmp_P(GSM_RxStr, GSM_SIMCOM_SIM900R)) GSM_Modem = SIMCOM_SIM900R;
    cd50:	81 ee       	ldi	r24, 0xE1	; 225
    cd52:	97 e0       	ldi	r25, 0x07	; 7
    cd54:	6b e5       	ldi	r22, 0x5B	; 91
    cd56:	73 e0       	ldi	r23, 0x03	; 3
    cd58:	0e 94 26 84 	call	0x1084c	; 0x1084c <strcmp_P>
    cd5c:	89 2b       	or	r24, r25
    cd5e:	19 f4       	brne	.+6      	; 0xcd66 <GSM_Cycle+0x148>
    cd60:	81 e0       	ldi	r24, 0x01	; 1
    cd62:	80 93 34 07 	sts	0x0734, r24
				if(!strcmp_P(GSM_RxStr, GSM_SIMCOM_SIM800)) GSM_Modem = SIMCOM_SIM800;
    cd66:	81 ee       	ldi	r24, 0xE1	; 225
    cd68:	97 e0       	ldi	r25, 0x07	; 7
    cd6a:	6a e6       	ldi	r22, 0x6A	; 106
    cd6c:	73 e0       	ldi	r23, 0x03	; 3
    cd6e:	0e 94 26 84 	call	0x1084c	; 0x1084c <strcmp_P>
    cd72:	89 2b       	or	r24, r25
    cd74:	19 f4       	brne	.+6      	; 0xcd7c <GSM_Cycle+0x15e>
    cd76:	82 e0       	ldi	r24, 0x02	; 2
    cd78:	80 93 34 07 	sts	0x0734, r24
				if(!strcmp_P(GSM_RxStr, GSM_SIMCOM_SIM800C)) GSM_Modem = SIMCOM_SIM800;
    cd7c:	81 ee       	ldi	r24, 0xE1	; 225
    cd7e:	97 e0       	ldi	r25, 0x07	; 7
    cd80:	68 e7       	ldi	r22, 0x78	; 120
    cd82:	73 e0       	ldi	r23, 0x03	; 3
    cd84:	0e 94 26 84 	call	0x1084c	; 0x1084c <strcmp_P>
    cd88:	89 2b       	or	r24, r25
    cd8a:	11 f0       	breq	.+4      	; 0xcd90 <GSM_Cycle+0x172>
    cd8c:	0c 94 13 73 	jmp	0xe626	; 0xe626 <GSM_Cycle+0x1a08>
    cd90:	82 e0       	ldi	r24, 0x02	; 2
    cd92:	80 93 34 07 	sts	0x0734, r24
				//Add here new model GSM-modem
				if(GSM_Modem != NOT_RECOGNIZED) GSM_State = GSM_WAIT_CALL_READY;
    cd96:	86 e0       	ldi	r24, 0x06	; 6
    cd98:	80 93 f6 06 	sts	0x06F6, r24
			}
		case GSM_WAIT_CFUN:
			if(GSM_Wait_Response_P(URC_CFUN, GSM_ReStart1)) GSM_State++;
    cd9c:	8b e8       	ldi	r24, 0x8B	; 139
    cd9e:	93 e0       	ldi	r25, 0x03	; 3
    cda0:	6a e4       	ldi	r22, 0x4A	; 74
    cda2:	0e 94 3f 4e 	call	0x9c7e	; 0x9c7e <GSM_Wait_Response_P>
    cda6:	88 23       	and	r24, r24
    cda8:	09 f4       	brne	.+2      	; 0xcdac <GSM_Cycle+0x18e>
    cdaa:	59 cf       	rjmp	.-334    	; 0xcc5e <GSM_Cycle+0x40>
    cdac:	80 91 f6 06 	lds	r24, 0x06F6
    cdb0:	8f 5f       	subi	r24, 0xFF	; 255
    cdb2:	80 93 f6 06 	sts	0x06F6, r24
    cdb6:	53 cf       	rjmp	.-346    	; 0xcc5e <GSM_Cycle+0x40>
		case GSM_WAIT_R2D_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;

		case GSM_WAIT_R2D_CONNECT:
			if(GSM_Wait_Response_P(RESP_CONNECT, GSM_ReStart1)){ 				
    cdb8:	84 ef       	ldi	r24, 0xF4	; 244
    cdba:	93 e0       	ldi	r25, 0x03	; 3
    cdbc:	6a e4       	ldi	r22, 0x4A	; 74
    cdbe:	0e 94 3f 4e 	call	0x9c7e	; 0x9c7e <GSM_Wait_Response_P>
    cdc2:	88 23       	and	r24, r24
    cdc4:	09 f4       	brne	.+2      	; 0xcdc8 <GSM_Cycle+0x1aa>
    cdc6:	4b cf       	rjmp	.-362    	; 0xcc5e <GSM_Cycle+0x40>
				GSM_State=GSM_ProtocolMode;
    cdc8:	82 e5       	ldi	r24, 0x52	; 82
    cdca:	80 93 f6 06 	sts	0x06F6, r24
				StartTimer16(TD_timer_after_page_transfer,100);
    cdce:	80 91 f1 04 	lds	r24, 0x04F1
    cdd2:	64 e6       	ldi	r22, 0x64	; 100
    cdd4:	70 e0       	ldi	r23, 0x00	; 0
    cdd6:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    cdda:	8f ef       	ldi	r24, 0xFF	; 255
    cddc:	80 93 3e 07 	sts	0x073E, r24
	GSM_RX_FIFO_End = 255;
    cde0:	80 93 53 06 	sts	0x0653, r24
	GSM_RxCharN = 0;
    cde4:	10 92 60 0b 	sts	0x0B60, r1
	GSM_RX_FIFOOverFlow = 0;
    cde8:	10 92 13 09 	sts	0x0913, r1
	GSM_RX_FIFOMax = 0;
    cdec:	10 92 19 09 	sts	0x0919, r1
    cdf0:	36 cf       	rjmp	.-404    	; 0xcc5e <GSM_Cycle+0x40>
			GSM_State=GSM_WAIT_R2D_CONNECT;
		
			break;

		case GSM_WAIT_R2D_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    cdf2:	81 ef       	ldi	r24, 0xF1	; 241
    cdf4:	93 e0       	ldi	r25, 0x03	; 3
    cdf6:	6a e4       	ldi	r22, 0x4A	; 74
    cdf8:	0e 94 3f 4e 	call	0x9c7e	; 0x9c7e <GSM_Wait_Response_P>
    cdfc:	88 23       	and	r24, r24
    cdfe:	09 f4       	brne	.+2      	; 0xce02 <GSM_Cycle+0x1e4>
    ce00:	2e cf       	rjmp	.-420    	; 0xcc5e <GSM_Cycle+0x40>
    ce02:	80 91 f6 06 	lds	r24, 0x06F6
    ce06:	8f 5f       	subi	r24, 0xFF	; 255
    ce08:	80 93 f6 06 	sts	0x06F6, r24
    ce0c:	28 cf       	rjmp	.-432    	; 0xcc5e <GSM_Cycle+0x40>
			break;

		//----  data mode
		case GSM_Return2dataMode:

			CommandModeDestination=0;
    ce0e:	10 92 af 07 	sts	0x07AF, r1
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    ce12:	8f ef       	ldi	r24, 0xFF	; 255
    ce14:	80 93 3e 07 	sts	0x073E, r24
	GSM_RX_FIFO_End = 255;
    ce18:	80 93 53 06 	sts	0x0653, r24
	GSM_RxCharN = 0;
    ce1c:	10 92 60 0b 	sts	0x0B60, r1
	GSM_RX_FIFOOverFlow = 0;
    ce20:	10 92 13 09 	sts	0x0913, r1
	GSM_RX_FIFOMax = 0;
    ce24:	10 92 19 09 	sts	0x0919, r1
    ce28:	e1 ee       	ldi	r30, 0xE1	; 225
    ce2a:	f7 e0       	ldi	r31, 0x07	; 7

			CommandModeDestination=0;
			InitFIFO();
			for(int i=0;i<GSM_RXSTR_SIZE;i++)
			{
				GSM_RxStr[i]=0;	
    ce2c:	11 92       	st	Z+, r1
		//----  data mode
		case GSM_Return2dataMode:

			CommandModeDestination=0;
			InitFIFO();
			for(int i=0;i<GSM_RXSTR_SIZE;i++)
    ce2e:	b8 e0       	ldi	r27, 0x08	; 8
    ce30:	e5 34       	cpi	r30, 0x45	; 69
    ce32:	fb 07       	cpc	r31, r27
    ce34:	d9 f7       	brne	.-10     	; 0xce2c <GSM_Cycle+0x20e>
			{
				GSM_RxStr[i]=0;	
			}
			GSM_Execute_Command(ATO, 600*GSM_DEBUG_DELAY); //GSM_State++;
    ce36:	81 e0       	ldi	r24, 0x01	; 1
    ce38:	96 e0       	ldi	r25, 0x06	; 6
    ce3a:	68 e5       	ldi	r22, 0x58	; 88
    ce3c:	72 e0       	ldi	r23, 0x02	; 2
    ce3e:	0e 94 9a 4e 	call	0x9d34	; 0x9d34 <GSM_Execute_Command>
			GSM_State=GSM_WAIT_R2D_CONNECT;
    ce42:	89 e5       	ldi	r24, 0x59	; 89
    ce44:	80 93 f6 06 	sts	0x06F6, r24
    ce48:	0a cf       	rjmp	.-492    	; 0xcc5e <GSM_Cycle+0x40>
				StartTimer16(TD_GSM,1000);	// min 500ms after +++
				GSM_State++;
			}
			break;
		case GSM_WAIT_D2C_SWITCH_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) {
    ce4a:	81 ef       	ldi	r24, 0xF1	; 241
    ce4c:	93 e0       	ldi	r25, 0x03	; 3
    ce4e:	6a e4       	ldi	r22, 0x4A	; 74
    ce50:	0e 94 3f 4e 	call	0x9c7e	; 0x9c7e <GSM_Wait_Response_P>
    ce54:	88 23       	and	r24, r24
    ce56:	09 f4       	brne	.+2      	; 0xce5a <GSM_Cycle+0x23c>
    ce58:	02 cf       	rjmp	.-508    	; 0xcc5e <GSM_Cycle+0x40>

				switch(CommandModeDestination){
    ce5a:	80 91 af 07 	lds	r24, 0x07AF
    ce5e:	82 30       	cpi	r24, 0x02	; 2
    ce60:	11 f4       	brne	.+4      	; 0xce66 <GSM_Cycle+0x248>
    ce62:	0c 94 8c 73 	jmp	0xe718	; 0xe718 <GSM_Cycle+0x1afa>
    ce66:	83 30       	cpi	r24, 0x03	; 3
    ce68:	10 f0       	brcs	.+4      	; 0xce6e <GSM_Cycle+0x250>
    ce6a:	0c 94 fc 72 	jmp	0xe5f8	; 0xe5f8 <GSM_Cycle+0x19da>
    ce6e:	81 30       	cpi	r24, 0x01	; 1
    ce70:	11 f4       	brne	.+4      	; 0xce76 <GSM_Cycle+0x258>
    ce72:	0c 94 93 73 	jmp	0xe726	; 0xe726 <GSM_Cycle+0x1b08>
						break;
					case 5:	
						GSM_State = GSM_SEND_CSQ;
						counter=0;	
						break;
					default:GSM_State = GSM_Return2dataMode;
    ce76:	87 e5       	ldi	r24, 0x57	; 87
    ce78:	80 93 f6 06 	sts	0x06F6, r24
    ce7c:	f0 ce       	rjmp	.-544    	; 0xcc5e <GSM_Cycle+0x40>
//IF WEB			WebClose();
			GSM_State++;

			break;
		case GSM_Swtch2CommandModePlus:
			if(Timer16Stopp(TD_GSM)){
    ce7e:	80 91 e9 04 	lds	r24, 0x04E9
    ce82:	0e 94 84 1f 	call	0x3f08	; 0x3f08 <Timer16Stopp>
    ce86:	88 23       	and	r24, r24
    ce88:	09 f4       	brne	.+2      	; 0xce8c <GSM_Cycle+0x26e>
    ce8a:	e9 ce       	rjmp	.-558    	; 0xcc5e <GSM_Cycle+0x40>
    ce8c:	e1 ee       	ldi	r30, 0xE1	; 225
    ce8e:	f7 e0       	ldi	r31, 0x07	; 7
				for(int i=0;i<GSM_RXSTR_SIZE;i++)
				{
					GSM_RxStr[i]=0;	
    ce90:	11 92       	st	Z+, r1
			GSM_State++;

			break;
		case GSM_Swtch2CommandModePlus:
			if(Timer16Stopp(TD_GSM)){
				for(int i=0;i<GSM_RXSTR_SIZE;i++)
    ce92:	28 e0       	ldi	r18, 0x08	; 8
    ce94:	e5 34       	cpi	r30, 0x45	; 69
    ce96:	f2 07       	cpc	r31, r18
    ce98:	d9 f7       	brne	.-10     	; 0xce90 <GSM_Cycle+0x272>
				{
					GSM_RxStr[i]=0;	
				}
				sprintf_P(GSM_TxStr, ESC_SEQ);
    ce9a:	00 d0       	rcall	.+0      	; 0xce9c <GSM_Cycle+0x27e>
    ce9c:	0f 92       	push	r0
    ce9e:	0a e4       	ldi	r16, 0x4A	; 74
    cea0:	1a e0       	ldi	r17, 0x0A	; 10
    cea2:	ad b7       	in	r26, 0x3d	; 61
    cea4:	be b7       	in	r27, 0x3e	; 62
    cea6:	12 96       	adiw	r26, 0x02	; 2
    cea8:	1c 93       	st	X, r17
    ceaa:	0e 93       	st	-X, r16
    ceac:	11 97       	sbiw	r26, 0x01	; 1
    ceae:	8a e5       	ldi	r24, 0x5A	; 90
    ceb0:	94 e0       	ldi	r25, 0x04	; 4
    ceb2:	14 96       	adiw	r26, 0x04	; 4
    ceb4:	9c 93       	st	X, r25
    ceb6:	8e 93       	st	-X, r24
    ceb8:	13 97       	sbiw	r26, 0x03	; 3
    ceba:	0e 94 53 85 	call	0x10aa6	; 0x10aa6 <sprintf_P>
				GSMTxSz = strlen(GSM_TxStr);
    cebe:	f8 01       	movw	r30, r16
    cec0:	01 90       	ld	r0, Z+
    cec2:	00 20       	and	r0, r0
    cec4:	e9 f7       	brne	.-6      	; 0xcec0 <GSM_Cycle+0x2a2>
    cec6:	8f 01       	movw	r16, r30
    cec8:	01 50       	subi	r16, 0x01	; 1
    ceca:	10 40       	sbci	r17, 0x00	; 0
    cecc:	0a 54       	subi	r16, 0x4A	; 74
    cece:	1a 40       	sbci	r17, 0x0A	; 10
    ced0:	00 93 bb 07 	sts	0x07BB, r16
				GSM_SendFirstChar();
    ced4:	0f 90       	pop	r0
    ced6:	0f 90       	pop	r0
    ced8:	0f 90       	pop	r0
    ceda:	0f 90       	pop	r0
    cedc:	0e 94 28 3d 	call	0x7a50	; 0x7a50 <GSM_SendFirstChar>
				StartTimer16(TD_GSM,1000);	// min 500ms after +++
    cee0:	80 91 e9 04 	lds	r24, 0x04E9
    cee4:	68 ee       	ldi	r22, 0xE8	; 232
    cee6:	73 e0       	ldi	r23, 0x03	; 3
    cee8:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
				GSM_State++;
    ceec:	80 91 f6 06 	lds	r24, 0x06F6
    cef0:	8f 5f       	subi	r24, 0xFF	; 255
    cef2:	80 93 f6 06 	sts	0x06F6, r24
    cef6:	b3 ce       	rjmp	.-666    	; 0xcc5e <GSM_Cycle+0x40>
				GSM_State =GSM_ReStart1;
				break;
			}			
			break;
		case GSM_Swtch2CommandMode:
			StartTimer16(TD_GSM,100);	// min 1000ms before +++
    cef8:	80 91 e9 04 	lds	r24, 0x04E9
    cefc:	64 e6       	ldi	r22, 0x64	; 100
    cefe:	70 e0       	ldi	r23, 0x00	; 0
    cf00:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
//IF WEB			WebClose();
			GSM_State++;
    cf04:	80 91 f6 06 	lds	r24, 0x06F6
    cf08:	8f 5f       	subi	r24, 0xFF	; 255
    cf0a:	80 93 f6 06 	sts	0x06F6, r24
    cf0e:	a7 ce       	rjmp	.-690    	; 0xcc5e <GSM_Cycle+0x40>
			}
			break;

		case GSM_DataMode:
			// -----    
			if(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){	// if FIFO not empty
    cf10:	90 91 3e 07 	lds	r25, 0x073E
    cf14:	80 91 53 06 	lds	r24, 0x0653
    cf18:	98 17       	cp	r25, r24
    cf1a:	11 f4       	brne	.+4      	; 0xcf20 <GSM_Cycle+0x302>
    cf1c:	0c 94 e2 71 	jmp	0xe3c4	; 0xe3c4 <GSM_Cycle+0x17a6>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    cf20:	83 ec       	ldi	r24, 0xC3	; 195
    cf22:	90 e0       	ldi	r25, 0x00	; 0
    cf24:	0e 94 5e 87 	call	0x10ebc	; 0x10ebc <__eerd_word_m2560>
    cf28:	bc 01       	movw	r22, r24
				StartTimer16(TD_TCP_Connect, erw(&TCP_CONNECT_timeout));	//   
    cf2a:	80 91 ea 04 	lds	r24, 0x04EA
    cf2e:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
    cf32:	95 ce       	rjmp	.-726    	; 0xcc5e <GSM_Cycle+0x40>
		//------------------------

		//-----------

		case GSM_ProtocolMode:
			if( (strstr_P(GSM_RxStr, URC_CLOSED+2) != NULL) ){
    cf34:	81 ee       	ldi	r24, 0xE1	; 225
    cf36:	97 e0       	ldi	r25, 0x07	; 7
    cf38:	64 ed       	ldi	r22, 0xD4	; 212
    cf3a:	73 e0       	ldi	r23, 0x03	; 3
    cf3c:	0e 94 58 84 	call	0x108b0	; 0x108b0 <strstr_P>
    cf40:	89 2b       	or	r24, r25
    cf42:	b1 f0       	breq	.+44     	; 0xcf70 <GSM_Cycle+0x352>
					GSM_State =GSM_ReStart1;
    cf44:	8a e4       	ldi	r24, 0x4A	; 74
    cf46:	80 93 f6 06 	sts	0x06F6, r24
    cf4a:	89 ce       	rjmp	.-750    	; 0xcc5e <GSM_Cycle+0x40>

			while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){	
					GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);
					if(GSM_RxCharN==2)
						{
							if(!strncmp_P(GSM_RxStr, PSTR("\r\n"), 2)) {GSM_RxCharN=0;}
    cf4c:	81 ee       	ldi	r24, 0xE1	; 225
    cf4e:	97 e0       	ldi	r25, 0x07	; 7
    cf50:	6e e0       	ldi	r22, 0x0E	; 14
    cf52:	72 e3       	ldi	r23, 0x32	; 50
    cf54:	42 e0       	ldi	r20, 0x02	; 2
    cf56:	50 e0       	ldi	r21, 0x00	; 0
    cf58:	0e 94 3f 84 	call	0x1087e	; 0x1087e <strncmp_P>
    cf5c:	89 2b       	or	r24, r25
    cf5e:	11 f4       	brne	.+4      	; 0xcf64 <GSM_Cycle+0x346>
    cf60:	10 92 60 0b 	sts	0x0B60, r1
						}
					if(GSM_RxCharN >= 4){
    cf64:	80 91 60 0b 	lds	r24, 0x0B60
    cf68:	84 30       	cpi	r24, 0x04	; 4
    cf6a:	10 f0       	brcs	.+4      	; 0xcf70 <GSM_Cycle+0x352>
    cf6c:	0c 94 56 71 	jmp	0xe2ac	; 0xe2ac <GSM_Cycle+0x168e>
					break;
			}



			while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){	
    cf70:	90 91 3e 07 	lds	r25, 0x073E
    cf74:	80 91 53 06 	lds	r24, 0x0653
    cf78:	98 17       	cp	r25, r24
    cf7a:	11 f4       	brne	.+4      	; 0xcf80 <GSM_Cycle+0x362>
    cf7c:	0c 94 98 71 	jmp	0xe330	; 0xe330 <GSM_Cycle+0x1712>
					GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);
    cf80:	81 ee       	ldi	r24, 0xE1	; 225
    cf82:	97 e0       	ldi	r25, 0x07	; 7
    cf84:	60 e6       	ldi	r22, 0x60	; 96
    cf86:	7b e0       	ldi	r23, 0x0B	; 11
    cf88:	44 e6       	ldi	r20, 0x64	; 100
    cf8a:	0e 94 94 3b 	call	0x7728	; 0x7728 <GetByteFromFIFO>
					if(GSM_RxCharN==2)
    cf8e:	80 91 60 0b 	lds	r24, 0x0B60
    cf92:	82 30       	cpi	r24, 0x02	; 2
    cf94:	39 f7       	brne	.-50     	; 0xcf64 <GSM_Cycle+0x346>
    cf96:	da cf       	rjmp	.-76     	; 0xcf4c <GSM_Cycle+0x32e>
						}
					}
				}
			break;
		case GSM_WAIT_CSQ_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) {
    cf98:	81 ef       	ldi	r24, 0xF1	; 241
    cf9a:	93 e0       	ldi	r25, 0x03	; 3
    cf9c:	6a e4       	ldi	r22, 0x4A	; 74
    cf9e:	0e 94 3f 4e 	call	0x9c7e	; 0x9c7e <GSM_Wait_Response_P>
    cfa2:	88 23       	and	r24, r24
    cfa4:	09 f4       	brne	.+2      	; 0xcfa8 <GSM_Cycle+0x38a>
    cfa6:	5b ce       	rjmp	.-842    	; 0xcc5e <GSM_Cycle+0x40>
				if(CommandModeDestination==5){
    cfa8:	80 91 af 07 	lds	r24, 0x07AF
    cfac:	85 30       	cpi	r24, 0x05	; 5
    cfae:	11 f4       	brne	.+4      	; 0xcfb4 <GSM_Cycle+0x396>
    cfb0:	0c 94 0e 73 	jmp	0xe61c	; 0xe61c <GSM_Cycle+0x19fe>
					GSM_State  = GSM_Return2dataMode;
				}
				else{
					GSM_State=GSM_SEND_CIPMUX;
    cfb4:	8a e2       	ldi	r24, 0x2A	; 42
    cfb6:	80 93 f6 06 	sts	0x06F6, r24
    cfba:	51 ce       	rjmp	.-862    	; 0xcc5e <GSM_Cycle+0x40>
				GSM_Execute_Command(AT_CSQ, 500*GSM_DEBUG_DELAY); 
				InitFIFO();
				GSM_State++;
			break;
		case GSM_WAIT_CSQ:
				if(Timer16Stopp(TD_GSM)){
    cfbc:	80 91 e9 04 	lds	r24, 0x04E9
    cfc0:	0e 94 84 1f 	call	0x3f08	; 0x3f08 <Timer16Stopp>
    cfc4:	88 23       	and	r24, r24
    cfc6:	11 f4       	brne	.+4      	; 0xcfcc <GSM_Cycle+0x3ae>
    cfc8:	0c 94 82 72 	jmp	0xe504	; 0xe504 <GSM_Cycle+0x18e6>
						GSM_State = GSM_ReStart1;
    cfcc:	8a e4       	ldi	r24, 0x4A	; 74
    cfce:	80 93 f6 06 	sts	0x06F6, r24
    cfd2:	45 ce       	rjmp	.-886    	; 0xcc5e <GSM_Cycle+0x40>
			break;
		case GSM_ShutWait_:
			if(GSM_Wait_Response_P(RESP_SHUT_OK, GSM_ReStart1)) GSM_State++;
			break;
		case GSM_SEND_CGATT0:
			GSM_Execute_Command(AT_CGATT_0, 1000*GSM_DEBUG_DELAY); GSM_State++;
    cfd4:	8f ee       	ldi	r24, 0xEF	; 239
    cfd6:	95 e0       	ldi	r25, 0x05	; 5
    cfd8:	68 ee       	ldi	r22, 0xE8	; 232
    cfda:	73 e0       	ldi	r23, 0x03	; 3
    cfdc:	0e 94 9a 4e 	call	0x9d34	; 0x9d34 <GSM_Execute_Command>
    cfe0:	80 91 f6 06 	lds	r24, 0x06F6
    cfe4:	8f 5f       	subi	r24, 0xFF	; 255
    cfe6:	80 93 f6 06 	sts	0x06F6, r24
    cfea:	39 ce       	rjmp	.-910    	; 0xcc5e <GSM_Cycle+0x40>
			break;
		//------------------------    


		case GSM_SEND_ATD_Check_Ballance:	
			if(GSM_Flag & (1<<flg_TxCStr)){
    cfec:	80 91 d2 02 	lds	r24, 0x02D2
    cff0:	80 ff       	sbrs	r24, 0
    cff2:	4b c0       	rjmp	.+150    	; 0xd08a <GSM_Cycle+0x46c>
				sprintf_P(GSM_TxStr, AT_CUSD101);	
    cff4:	00 d0       	rcall	.+0      	; 0xcff6 <GSM_Cycle+0x3d8>
    cff6:	0f 92       	push	r0
    cff8:	8a e4       	ldi	r24, 0x4A	; 74
    cffa:	9a e0       	ldi	r25, 0x0A	; 10
    cffc:	ad b7       	in	r26, 0x3d	; 61
    cffe:	be b7       	in	r27, 0x3e	; 62
    d000:	12 96       	adiw	r26, 0x02	; 2
    d002:	9c 93       	st	X, r25
    d004:	8e 93       	st	-X, r24
    d006:	11 97       	sbiw	r26, 0x01	; 1
    d008:	07 ec       	ldi	r16, 0xC7	; 199
    d00a:	14 e0       	ldi	r17, 0x04	; 4
    d00c:	14 96       	adiw	r26, 0x04	; 4
    d00e:	1c 93       	st	X, r17
    d010:	0e 93       	st	-X, r16
    d012:	13 97       	sbiw	r26, 0x03	; 3
    d014:	0e 94 53 85 	call	0x10aa6	; 0x10aa6 <sprintf_P>
				GSMTxSz = strlen_P(AT_CUSD101);
    d018:	0f 90       	pop	r0
    d01a:	0f 90       	pop	r0
    d01c:	0f 90       	pop	r0
    d01e:	0f 90       	pop	r0
    d020:	c8 01       	movw	r24, r16
    d022:	0e 94 36 84 	call	0x1086c	; 0x1086c <strlen_P>
    d026:	80 93 bb 07 	sts	0x07BB, r24
				GSMTxSz += strcpy_EE(GSM_TxStr+GSMTxSz,GPRS_checkballancerequest);
    d02a:	80 91 bb 07 	lds	r24, 0x07BB
    d02e:	90 e0       	ldi	r25, 0x00	; 0
    d030:	86 5b       	subi	r24, 0xB6	; 182
    d032:	95 4f       	sbci	r25, 0xF5	; 245
    d034:	61 e3       	ldi	r22, 0x31	; 49
    d036:	70 e0       	ldi	r23, 0x00	; 0
    d038:	0e 94 ec 65 	call	0xcbd8	; 0xcbd8 <strcpy_EE>
    d03c:	90 91 bb 07 	lds	r25, 0x07BB
    d040:	98 0f       	add	r25, r24
    d042:	90 93 bb 07 	sts	0x07BB, r25
				GSM_TxStr[GSMTxSz]='"';
    d046:	e0 91 bb 07 	lds	r30, 0x07BB
    d04a:	f0 e0       	ldi	r31, 0x00	; 0
    d04c:	e6 5b       	subi	r30, 0xB6	; 182
    d04e:	f5 4f       	sbci	r31, 0xF5	; 245
    d050:	82 e2       	ldi	r24, 0x22	; 34
    d052:	80 83       	st	Z, r24
				GSM_TxStr[GSMTxSz+1]='\r';
    d054:	e0 91 bb 07 	lds	r30, 0x07BB
    d058:	f0 e0       	ldi	r31, 0x00	; 0
    d05a:	e6 5b       	subi	r30, 0xB6	; 182
    d05c:	f5 4f       	sbci	r31, 0xF5	; 245
    d05e:	8d e0       	ldi	r24, 0x0D	; 13
    d060:	81 83       	std	Z+1, r24	; 0x01
				GSM_TxStr[GSMTxSz+2]='\n';
    d062:	e0 91 bb 07 	lds	r30, 0x07BB
    d066:	f0 e0       	ldi	r31, 0x00	; 0
    d068:	e6 5b       	subi	r30, 0xB6	; 182
    d06a:	f5 4f       	sbci	r31, 0xF5	; 245
    d06c:	8a e0       	ldi	r24, 0x0A	; 10
    d06e:	82 83       	std	Z+2, r24	; 0x02
				GSMTxSz+=3;
    d070:	80 91 bb 07 	lds	r24, 0x07BB
    d074:	8d 5f       	subi	r24, 0xFD	; 253
    d076:	80 93 bb 07 	sts	0x07BB, r24
				GSM_SendFirstChar();
    d07a:	0e 94 28 3d 	call	0x7a50	; 0x7a50 <GSM_SendFirstChar>
				StartTimer16(TD_GSM, 1000);
    d07e:	80 91 e9 04 	lds	r24, 0x04E9
    d082:	68 ee       	ldi	r22, 0xE8	; 232
    d084:	73 e0       	ldi	r23, 0x03	; 3
    d086:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
			}
			GSM_State++;	
    d08a:	80 91 f6 06 	lds	r24, 0x06F6
    d08e:	8f 5f       	subi	r24, 0xFF	; 255
    d090:	80 93 f6 06 	sts	0x06F6, r24
			GSM_Temp = 0;
    d094:	10 92 db 05 	sts	0x05DB, r1
    d098:	e2 cd       	rjmp	.-1084   	; 0xcc5e <GSM_Cycle+0x40>
			SetIP(&GSM_ClientIP,0,0,0,0);
			GSM_Flag |=(1<<flg_TxCStr);
			GSM_State++;
			break;
		case GSM_ReStart2:
			if(Timer16Stopp(TD_GSM)){
    d09a:	80 91 e9 04 	lds	r24, 0x04E9
    d09e:	0e 94 84 1f 	call	0x3f08	; 0x3f08 <Timer16Stopp>
    d0a2:	88 23       	and	r24, r24
    d0a4:	09 f4       	brne	.+2      	; 0xd0a8 <GSM_Cycle+0x48a>
    d0a6:	db cd       	rjmp	.-1098   	; 0xcc5e <GSM_Cycle+0x40>
				GSM_State = GSM_PowerOn;
    d0a8:	10 92 f6 06 	sts	0x06F6, r1
    d0ac:	d8 cd       	rjmp	.-1104   	; 0xcc5e <GSM_Cycle+0x40>
		//------------------------

		
		//------------------------
		case GSM_ReStart1:
			GSM_ReStartN++;
    d0ae:	80 91 35 09 	lds	r24, 0x0935
    d0b2:	8f 5f       	subi	r24, 0xFF	; 255
    d0b4:	80 93 35 09 	sts	0x0935, r24
		cli();
		DDRL|=(1<<PL5);
		sei();
	}
	void GSM_PWRCNTRL_OFF(void){
		cli();
    d0b8:	f8 94       	cli
		PORTL|=(1<<PL5);
    d0ba:	80 91 0b 01 	lds	r24, 0x010B
    d0be:	80 62       	ori	r24, 0x20	; 32
    d0c0:	80 93 0b 01 	sts	0x010B, r24
		sei();
    d0c4:	78 94       	sei
			GSM_PWRCNTRL_OFF();
			StartTimer16(TD_GSM,1000);
    d0c6:	80 91 e9 04 	lds	r24, 0x04E9
    d0ca:	68 ee       	ldi	r22, 0xE8	; 232
    d0cc:	73 e0       	ldi	r23, 0x03	; 3
    d0ce:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
			RxBufOverFlow = 0;
    d0d2:	10 92 49 0b 	sts	0x0B49, r1
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    d0d6:	8f ef       	ldi	r24, 0xFF	; 255
    d0d8:	80 93 3e 07 	sts	0x073E, r24
	GSM_RX_FIFO_End = 255;
    d0dc:	80 93 53 06 	sts	0x0653, r24
	GSM_RxCharN = 0;
    d0e0:	10 92 60 0b 	sts	0x0B60, r1
	GSM_RX_FIFOOverFlow = 0;
    d0e4:	10 92 13 09 	sts	0x0913, r1
	GSM_RX_FIFOMax = 0;
    d0e8:	10 92 19 09 	sts	0x0919, r1
    d0ec:	e1 ee       	ldi	r30, 0xE1	; 225
    d0ee:	f7 e0       	ldi	r31, 0x07	; 7
			RxBufOverFlow = 0;
		//	WebSession=0;
			InitFIFO();
			for(int i=0;i<GSM_RXSTR_SIZE;i++)
			{
				GSM_RxStr[i]=0;	
    d0f0:	11 92       	st	Z+, r1
			GSM_PWRCNTRL_OFF();
			StartTimer16(TD_GSM,1000);
			RxBufOverFlow = 0;
		//	WebSession=0;
			InitFIFO();
			for(int i=0;i<GSM_RXSTR_SIZE;i++)
    d0f2:	28 e0       	ldi	r18, 0x08	; 8
    d0f4:	e5 34       	cpi	r30, 0x45	; 69
    d0f6:	f2 07       	cpc	r31, r18
    d0f8:	d9 f7       	brne	.-10     	; 0xd0f0 <GSM_Cycle+0x4d2>
			{
				GSM_RxStr[i]=0;	
			}
			SMS_FlgSz_Out = 0;	// ..          -  
    d0fa:	10 92 c9 07 	sts	0x07C9, r1
			GSM_ActiveConnection = NO_CONNECTION;
    d0fe:	8f ef       	ldi	r24, 0xFF	; 255
    d100:	80 93 d3 02 	sts	0x02D3, r24
	uint8_t IP4;
} IP_Addr;

//~~~~~~~~~~~~~~
void SetIP(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	IP->IP1 = IP1;
    d104:	10 92 4a 0b 	sts	0x0B4A, r1
	IP->IP2 = IP2;
    d108:	10 92 4b 0b 	sts	0x0B4B, r1
	IP->IP3 = IP3;
    d10c:	10 92 4c 0b 	sts	0x0B4C, r1
	IP->IP4 = IP4;
    d110:	10 92 4d 0b 	sts	0x0B4D, r1
			SetIP(&GSM_ClientIP,0,0,0,0);
			GSM_Flag |=(1<<flg_TxCStr);
    d114:	80 91 d2 02 	lds	r24, 0x02D2
    d118:	81 60       	ori	r24, 0x01	; 1
    d11a:	80 93 d2 02 	sts	0x02D2, r24
			GSM_State++;
    d11e:	80 91 f6 06 	lds	r24, 0x06F6
    d122:	8f 5f       	subi	r24, 0xFF	; 255
    d124:	80 93 f6 06 	sts	0x06F6, r24
    d128:	9a cd       	rjmp	.-1228   	; 0xcc5e <GSM_Cycle+0x40>
			break;
		case GSM_SEND_CGATT0:
			GSM_Execute_Command(AT_CGATT_0, 1000*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CGATT0_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    d12a:	81 ef       	ldi	r24, 0xF1	; 241
    d12c:	93 e0       	ldi	r25, 0x03	; 3
    d12e:	6a e4       	ldi	r22, 0x4A	; 74
    d130:	0e 94 3f 4e 	call	0x9c7e	; 0x9c7e <GSM_Wait_Response_P>
    d134:	88 23       	and	r24, r24
    d136:	09 f4       	brne	.+2      	; 0xd13a <GSM_Cycle+0x51c>
    d138:	92 cd       	rjmp	.-1244   	; 0xcc5e <GSM_Cycle+0x40>
				StartTimer16(TD_GSM, 1000);
    d13a:	80 91 e9 04 	lds	r24, 0x04E9
    d13e:	68 ee       	ldi	r22, 0xE8	; 232
    d140:	73 e0       	ldi	r23, 0x03	; 3
    d142:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
			 	GSM_State = GSM_SEND_ATD_Check_Ballance;
    d146:	8c e4       	ldi	r24, 0x4C	; 76
    d148:	80 93 f6 06 	sts	0x06F6, r24
    d14c:	88 cd       	rjmp	.-1264   	; 0xcc5e <GSM_Cycle+0x40>
			break;
		case GSM_WAIT_ATD_Check_Ballance_OK:
			if(GSM_Wait_Response_P(RESP_OK,GSM_SEND_CSQ)) GSM_State++;
			break;
		case GSM_WAIT_Ballance:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_SEND_CSQ;
    d14e:	80 91 e9 04 	lds	r24, 0x04E9
    d152:	0e 94 84 1f 	call	0x3f08	; 0x3f08 <Timer16Stopp>
    d156:	88 23       	and	r24, r24
    d158:	19 f0       	breq	.+6      	; 0xd160 <GSM_Cycle+0x542>
    d15a:	8f e4       	ldi	r24, 0x4F	; 79
    d15c:	80 93 f6 06 	sts	0x06F6, r24
			GSM_RxStr[GSM_RXSTR_SIZE-1]='\0';
    d160:	10 92 44 08 	sts	0x0844, r1
		
				GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);

				if(GSM_RxCharN >= 90){

					GSM_State = GSM_SEND_CSQ;
    d164:	1f e4       	ldi	r17, 0x4F	; 79
			if(GSM_Wait_Response_P(RESP_OK,GSM_SEND_CSQ)) GSM_State++;
			break;
		case GSM_WAIT_Ballance:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_SEND_CSQ;
			GSM_RxStr[GSM_RXSTR_SIZE-1]='\0';
			while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    d166:	90 91 3e 07 	lds	r25, 0x073E
    d16a:	80 91 53 06 	lds	r24, 0x0653
    d16e:	98 17       	cp	r25, r24
    d170:	09 f4       	brne	.+2      	; 0xd174 <GSM_Cycle+0x556>
    d172:	f4 c6       	rjmp	.+3560   	; 0xdf5c <GSM_Cycle+0x133e>
				
		
				GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);
    d174:	81 ee       	ldi	r24, 0xE1	; 225
    d176:	97 e0       	ldi	r25, 0x07	; 7
    d178:	60 e6       	ldi	r22, 0x60	; 96
    d17a:	7b e0       	ldi	r23, 0x0B	; 11
    d17c:	44 e6       	ldi	r20, 0x64	; 100
    d17e:	0e 94 94 3b 	call	0x7728	; 0x7728 <GetByteFromFIFO>

				if(GSM_RxCharN >= 90){
    d182:	80 91 60 0b 	lds	r24, 0x0B60
    d186:	8a 35       	cpi	r24, 0x5A	; 90
    d188:	70 f3       	brcs	.-36     	; 0xd166 <GSM_Cycle+0x548>

					GSM_State = GSM_SEND_CSQ;
    d18a:	10 93 f6 06 	sts	0x06F6, r17
    d18e:	eb cf       	rjmp	.-42     	; 0xd166 <GSM_Cycle+0x548>
			}
			GSM_State++;	
			GSM_Temp = 0;
			break;
		case GSM_WAIT_ATD_Check_Ballance_OK:
			if(GSM_Wait_Response_P(RESP_OK,GSM_SEND_CSQ)) GSM_State++;
    d190:	81 ef       	ldi	r24, 0xF1	; 241
    d192:	93 e0       	ldi	r25, 0x03	; 3
    d194:	6f e4       	ldi	r22, 0x4F	; 79
    d196:	0e 94 3f 4e 	call	0x9c7e	; 0x9c7e <GSM_Wait_Response_P>
    d19a:	88 23       	and	r24, r24
    d19c:	09 f4       	brne	.+2      	; 0xd1a0 <GSM_Cycle+0x582>
    d19e:	5f cd       	rjmp	.-1346   	; 0xcc5e <GSM_Cycle+0x40>
    d1a0:	80 91 f6 06 	lds	r24, 0x06F6
    d1a4:	8f 5f       	subi	r24, 0xFF	; 255
    d1a6:	80 93 f6 06 	sts	0x06F6, r24
    d1aa:	59 cd       	rjmp	.-1358   	; 0xcc5e <GSM_Cycle+0x40>
			}	
			break;

		//------------------------   GSM-
		case GSM_SEND_CSQ:
				GSM_Execute_Command(AT_CSQ, 500*GSM_DEBUG_DELAY); 
    d1ac:	8a ef       	ldi	r24, 0xFA	; 250
    d1ae:	95 e0       	ldi	r25, 0x05	; 5
    d1b0:	64 ef       	ldi	r22, 0xF4	; 244
    d1b2:	71 e0       	ldi	r23, 0x01	; 1
    d1b4:	0e 94 9a 4e 	call	0x9d34	; 0x9d34 <GSM_Execute_Command>
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    d1b8:	8f ef       	ldi	r24, 0xFF	; 255
    d1ba:	80 93 3e 07 	sts	0x073E, r24
	GSM_RX_FIFO_End = 255;
    d1be:	80 93 53 06 	sts	0x0653, r24
	GSM_RxCharN = 0;
    d1c2:	10 92 60 0b 	sts	0x0B60, r1
	GSM_RX_FIFOOverFlow = 0;
    d1c6:	10 92 13 09 	sts	0x0913, r1
	GSM_RX_FIFOMax = 0;
    d1ca:	10 92 19 09 	sts	0x0919, r1

		//------------------------   GSM-
		case GSM_SEND_CSQ:
				GSM_Execute_Command(AT_CSQ, 500*GSM_DEBUG_DELAY); 
				InitFIFO();
				GSM_State++;
    d1ce:	80 91 f6 06 	lds	r24, 0x06F6
    d1d2:	8f 5f       	subi	r24, 0xFF	; 255
    d1d4:	80 93 f6 06 	sts	0x06F6, r24
    d1d8:	42 cd       	rjmp	.-1404   	; 0xcc5e <GSM_Cycle+0x40>
			break;
		case GSM_WAIT_SMS_Inv:
			if(GSM_Wait_Char('>', GSM_ReStart1)) GSM_State++;
			break;
		case GSM_SEND_SMS_DATA:
			SMS_Data_Out[SMS_FlgSz_Out] = 0x1A;	// SMS Data end - char Ctrl-Z
    d1da:	60 91 c9 07 	lds	r22, 0x07C9
    d1de:	e6 2f       	mov	r30, r22
    d1e0:	f0 e0       	ldi	r31, 0x00	; 0
    d1e2:	e6 5b       	subi	r30, 0xB6	; 182
    d1e4:	f8 4f       	sbci	r31, 0xF8	; 248
    d1e6:	8a e1       	ldi	r24, 0x1A	; 26
    d1e8:	80 83       	st	Z, r24
			GSM_SendData((uint8_t *)SMS_Data_Out, SMS_FlgSz_Out+1);
    d1ea:	6f 5f       	subi	r22, 0xFF	; 255
    d1ec:	8a e4       	ldi	r24, 0x4A	; 74
    d1ee:	97 e0       	ldi	r25, 0x07	; 7
    d1f0:	0e 94 1d 44 	call	0x883a	; 0x883a <GSM_SendData>
			GSM_State++;
    d1f4:	80 91 f6 06 	lds	r24, 0x06F6
    d1f8:	8f 5f       	subi	r24, 0xFF	; 255
    d1fa:	80 93 f6 06 	sts	0x06F6, r24
    d1fe:	2f cd       	rjmp	.-1442   	; 0xcc5e <GSM_Cycle+0x40>
					}					
				}
			}
			break;
		case GSM_WAIT_SMS_Inv:
			if(GSM_Wait_Char('>', GSM_ReStart1)) GSM_State++;
    d200:	8e e3       	ldi	r24, 0x3E	; 62
    d202:	6a e4       	ldi	r22, 0x4A	; 74
    d204:	0e 94 06 3d 	call	0x7a0c	; 0x7a0c <GSM_Wait_Char>
    d208:	88 23       	and	r24, r24
    d20a:	09 f4       	brne	.+2      	; 0xd20e <GSM_Cycle+0x5f0>
    d20c:	28 cd       	rjmp	.-1456   	; 0xcc5e <GSM_Cycle+0x40>
    d20e:	80 91 f6 06 	lds	r24, 0x06F6
    d212:	8f 5f       	subi	r24, 0xFF	; 255
    d214:	80 93 f6 06 	sts	0x06F6, r24
    d218:	22 cd       	rjmp	.-1468   	; 0xcc5e <GSM_Cycle+0x40>
			}
			break;

		//------------------------
		case GSM_SEND_CMGS:
			if(GSM_Flag & (1<<flg_TxCStr)){			
    d21a:	80 91 d2 02 	lds	r24, 0x02D2
    d21e:	80 ff       	sbrs	r24, 0
    d220:	1e cd       	rjmp	.-1476   	; 0xcc5e <GSM_Cycle+0x40>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    d222:	4a e4       	ldi	r20, 0x4A	; 74
    d224:	e4 2e       	mov	r14, r20
    d226:	4a e0       	ldi	r20, 0x0A	; 10
    d228:	f4 2e       	mov	r15, r20
    d22a:	60 91 dc 05 	lds	r22, 0x05DC
    d22e:	8d e0       	ldi	r24, 0x0D	; 13
    d230:	68 9f       	mul	r22, r24
    d232:	b0 01       	movw	r22, r0
    d234:	11 24       	eor	r1, r1
    d236:	6b 53       	subi	r22, 0x3B	; 59
    d238:	7f 4f       	sbci	r23, 0xFF	; 255
    d23a:	c7 01       	movw	r24, r14
    d23c:	4d e0       	ldi	r20, 0x0D	; 13
    d23e:	50 e0       	ldi	r21, 0x00	; 0
    d240:	0e 94 40 87 	call	0x10e80	; 0x10e80 <__eerd_block_m2560>
				erbl(GSM_TxStr, SMS_Number+TempNum, MaxTelephN);
				GSMTxSz = strlen(GSM_TxStr);
    d244:	f7 01       	movw	r30, r14
    d246:	01 90       	ld	r0, Z+
    d248:	00 20       	and	r0, r0
    d24a:	e9 f7       	brne	.-6      	; 0xd246 <GSM_Cycle+0x628>
    d24c:	31 97       	sbiw	r30, 0x01	; 1
    d24e:	ee 19       	sub	r30, r14
    d250:	ff 09       	sbc	r31, r15
    d252:	e0 93 bb 07 	sts	0x07BB, r30
				uint8_t j=0;
				for(uint8_t i=0; i<GSMTxSz; i++)
    d256:	80 91 bb 07 	lds	r24, 0x07BB
    d25a:	88 23       	and	r24, r24
    d25c:	99 f0       	breq	.+38     	; 0xd284 <GSM_Cycle+0x666>
    d25e:	90 e0       	ldi	r25, 0x00	; 0
    d260:	20 e0       	ldi	r18, 0x00	; 0
					if(GSM_TxStr[i] != '0') j++;
    d262:	e9 2f       	mov	r30, r25
    d264:	f0 e0       	ldi	r31, 0x00	; 0
    d266:	e6 5b       	subi	r30, 0xB6	; 182
    d268:	f5 4f       	sbci	r31, 0xF5	; 245
    d26a:	80 81       	ld	r24, Z
    d26c:	80 33       	cpi	r24, 0x30	; 48
    d26e:	09 f0       	breq	.+2      	; 0xd272 <GSM_Cycle+0x654>
    d270:	2f 5f       	subi	r18, 0xFF	; 255
		case GSM_SEND_CMGS:
			if(GSM_Flag & (1<<flg_TxCStr)){			
				erbl(GSM_TxStr, SMS_Number+TempNum, MaxTelephN);
				GSMTxSz = strlen(GSM_TxStr);
				uint8_t j=0;
				for(uint8_t i=0; i<GSMTxSz; i++)
    d272:	9f 5f       	subi	r25, 0xFF	; 255
    d274:	80 91 bb 07 	lds	r24, 0x07BB
    d278:	98 17       	cp	r25, r24
    d27a:	98 f3       	brcs	.-26     	; 0xd262 <GSM_Cycle+0x644>
					if(GSM_TxStr[i] != '0') j++;
				if(j){
    d27c:	22 23       	and	r18, r18
    d27e:	11 f0       	breq	.+4      	; 0xd284 <GSM_Cycle+0x666>
    d280:	0c 94 34 73 	jmp	0xe668	; 0xe668 <GSM_Cycle+0x1a4a>
					GSM_SendFirstChar();
					StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
					GSM_State++;
				}
				else{
					TempNum++;
    d284:	80 91 dc 05 	lds	r24, 0x05DC
    d288:	8f 5f       	subi	r24, 0xFF	; 255
    d28a:	80 93 dc 05 	sts	0x05DC, r24
					if(TempNum>=MaxTelephDirSz){
    d28e:	83 30       	cpi	r24, 0x03	; 3
    d290:	08 f4       	brcc	.+2      	; 0xd294 <GSM_Cycle+0x676>
    d292:	e5 cc       	rjmp	.-1590   	; 0xcc5e <GSM_Cycle+0x40>
						//StartTimer16(TD_GSM,150);

						GSM_State = GSM_Return2dataMode;
    d294:	87 e5       	ldi	r24, 0x57	; 87
    d296:	80 93 f6 06 	sts	0x06F6, r24
				
						SMS_FlgSz_Out = 0;
    d29a:	10 92 c9 07 	sts	0x07C9, r1
    d29e:	df cc       	rjmp	.-1602   	; 0xcc5e <GSM_Cycle+0x40>
			break;

		case GSM_AnalyzeURC:			//  
			
			// 
			if( (strstr_P(GSM_RxStr, URC_CLOSED+2) != NULL) ){
    d2a0:	01 ee       	ldi	r16, 0xE1	; 225
    d2a2:	17 e0       	ldi	r17, 0x07	; 7
    d2a4:	c8 01       	movw	r24, r16
    d2a6:	64 ed       	ldi	r22, 0xD4	; 212
    d2a8:	73 e0       	ldi	r23, 0x03	; 3
    d2aa:	0e 94 58 84 	call	0x108b0	; 0x108b0 <strstr_P>
    d2ae:	89 2b       	or	r24, r25
    d2b0:	11 f4       	brne	.+4      	; 0xd2b6 <GSM_Cycle+0x698>
    d2b2:	0c 94 98 73 	jmp	0xe730	; 0xe730 <GSM_Cycle+0x1b12>
				GSM_State =GSM_ReStart1;
    d2b6:	8a e4       	ldi	r24, 0x4A	; 74
    d2b8:	80 93 f6 06 	sts	0x06F6, r24
    d2bc:	d0 cc       	rjmp	.-1632   	; 0xcc5e <GSM_Cycle+0x40>
		//------------------------


		//------------------------
		case GSM_CIPSHUT_:
			GSM_Execute_Command(AT_CIPSHUT, 1000*GSM_DEBUG_DELAY); GSM_State++;
    d2be:	84 ee       	ldi	r24, 0xE4	; 228
    d2c0:	95 e0       	ldi	r25, 0x05	; 5
    d2c2:	68 ee       	ldi	r22, 0xE8	; 232
    d2c4:	73 e0       	ldi	r23, 0x03	; 3
    d2c6:	0e 94 9a 4e 	call	0x9d34	; 0x9d34 <GSM_Execute_Command>
    d2ca:	80 91 f6 06 	lds	r24, 0x06F6
    d2ce:	8f 5f       	subi	r24, 0xFF	; 255
    d2d0:	80 93 f6 06 	sts	0x06F6, r24
    d2d4:	c4 cc       	rjmp	.-1656   	; 0xcc5e <GSM_Cycle+0x40>
			break;
		case GSM_ShutWait_:
			if(GSM_Wait_Response_P(RESP_SHUT_OK, GSM_ReStart1)) GSM_State++;
    d2d6:	89 e4       	ldi	r24, 0x49	; 73
    d2d8:	94 e0       	ldi	r25, 0x04	; 4
    d2da:	6a e4       	ldi	r22, 0x4A	; 74
    d2dc:	0e 94 3f 4e 	call	0x9c7e	; 0x9c7e <GSM_Wait_Response_P>
    d2e0:	88 23       	and	r24, r24
    d2e2:	09 f4       	brne	.+2      	; 0xd2e6 <GSM_Cycle+0x6c8>
    d2e4:	bc cc       	rjmp	.-1672   	; 0xcc5e <GSM_Cycle+0x40>
    d2e6:	80 91 f6 06 	lds	r24, 0x06F6
    d2ea:	8f 5f       	subi	r24, 0xFF	; 255
    d2ec:	80 93 f6 06 	sts	0x06F6, r24
    d2f0:	b6 cc       	rjmp	.-1684   	; 0xcc5e <GSM_Cycle+0x40>
			SMS_Data_Out[SMS_FlgSz_Out] = 0x1A;	// SMS Data end - char Ctrl-Z
			GSM_SendData((uint8_t *)SMS_Data_Out, SMS_FlgSz_Out+1);
			GSM_State++;
			break;		
		case GSM_WAIT_CMGS_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    d2f2:	81 ef       	ldi	r24, 0xF1	; 241
    d2f4:	93 e0       	ldi	r25, 0x03	; 3
    d2f6:	6a e4       	ldi	r22, 0x4A	; 74
    d2f8:	0e 94 3f 4e 	call	0x9c7e	; 0x9c7e <GSM_Wait_Response_P>
    d2fc:	88 23       	and	r24, r24
    d2fe:	09 f4       	brne	.+2      	; 0xd302 <GSM_Cycle+0x6e4>
    d300:	ae cc       	rjmp	.-1700   	; 0xcc5e <GSM_Cycle+0x40>
				if(++TempNum>=MaxTelephDirSz){
    d302:	80 91 dc 05 	lds	r24, 0x05DC
    d306:	8f 5f       	subi	r24, 0xFF	; 255
    d308:	80 93 dc 05 	sts	0x05DC, r24
    d30c:	83 30       	cpi	r24, 0x03	; 3
    d30e:	10 f4       	brcc	.+4      	; 0xd314 <GSM_Cycle+0x6f6>
    d310:	0c 94 f7 72 	jmp	0xe5ee	; 0xe5ee <GSM_Cycle+0x19d0>
					GSM_State = GSM_Return2dataMode;
    d314:	87 e5       	ldi	r24, 0x57	; 87
    d316:	80 93 f6 06 	sts	0x06F6, r24
					SMS_FlgSz_Out = 0;
    d31a:	10 92 c9 07 	sts	0x07C9, r1
    d31e:	9f cc       	rjmp	.-1730   	; 0xcc5e <GSM_Cycle+0x40>
				counter=1;

			}
			#endif	

			if(GetStringFromFIFO()){
    d320:	0e 94 fe 3b 	call	0x77fc	; 0x77fc <GetStringFromFIFO>
    d324:	88 23       	and	r24, r24
    d326:	09 f4       	brne	.+2      	; 0xd32a <GSM_Cycle+0x70c>
    d328:	9a cc       	rjmp	.-1740   	; 0xcc5e <GSM_Cycle+0x40>
				GSM_State = GSM_AnalyzeURC;
    d32a:	8f e3       	ldi	r24, 0x3F	; 63
    d32c:	80 93 f6 06 	sts	0x06F6, r24
				TempNum = 0;
    d330:	10 92 dc 05 	sts	0x05DC, r1
    d334:	94 cc       	rjmp	.-1752   	; 0xcc5e <GSM_Cycle+0x40>
			GSM_SendFirstChar();
			GSM_State = GSM_WAIT_PLAY_CONFIRM_FILE_OK;
			StartTimer16(TD_GSM, 2000);
			break;
		case GSM_WAIT_PLAY_CONFIRM_FILE_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_WAIT_PLAY_CONFIRM_FILE_OK)) 
    d336:	81 ef       	ldi	r24, 0xF1	; 241
    d338:	93 e0       	ldi	r25, 0x03	; 3
    d33a:	6e e1       	ldi	r22, 0x1E	; 30
    d33c:	0e 94 3f 4e 	call	0x9c7e	; 0x9c7e <GSM_Wait_Response_P>
    d340:	88 23       	and	r24, r24
    d342:	09 f4       	brne	.+2      	; 0xd346 <GSM_Cycle+0x728>
    d344:	8c cc       	rjmp	.-1768   	; 0xcc5e <GSM_Cycle+0x40>
				{
					GSM_State = GSM_WAIT_PLAY_CONFIRM_FILE_CREC_0;
    d346:	8f e1       	ldi	r24, 0x1F	; 31
    d348:	80 93 f6 06 	sts	0x06F6, r24
					StartTimer16(TD_GSM, 20000);
    d34c:	80 91 e9 04 	lds	r24, 0x04E9
    d350:	60 e2       	ldi	r22, 0x20	; 32
    d352:	7e e4       	ldi	r23, 0x4E	; 78
    d354:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
    d358:	82 cc       	rjmp	.-1788   	; 0xcc5e <GSM_Cycle+0x40>
			}

			break;

		case GSM_SEND_PLAY_CONFIRM_FILE: 
			ConfirmState = 1;
    d35a:	81 e0       	ldi	r24, 0x01	; 1
    d35c:	80 93 e1 02 	sts	0x02E1, r24
			sprintf_P(GSM_TxStr, PSTR("AT+CREC=4,\"C:\\User\\Confirm.amr\",0,100\r"));
    d360:	00 d0       	rcall	.+0      	; 0xd362 <GSM_Cycle+0x744>
    d362:	0f 92       	push	r0
    d364:	8a e4       	ldi	r24, 0x4A	; 74
    d366:	9a e0       	ldi	r25, 0x0A	; 10
    d368:	ed b7       	in	r30, 0x3d	; 61
    d36a:	fe b7       	in	r31, 0x3e	; 62
    d36c:	92 83       	std	Z+2, r25	; 0x02
    d36e:	81 83       	std	Z+1, r24	; 0x01
    d370:	85 e9       	ldi	r24, 0x95	; 149
    d372:	92 e3       	ldi	r25, 0x32	; 50
    d374:	94 83       	std	Z+4, r25	; 0x04
    d376:	83 83       	std	Z+3, r24	; 0x03
    d378:	0e 94 53 85 	call	0x10aa6	; 0x10aa6 <sprintf_P>
			GSMTxSz=38;
    d37c:	86 e2       	ldi	r24, 0x26	; 38
    d37e:	80 93 bb 07 	sts	0x07BB, r24
			GSM_SendFirstChar();
    d382:	0f 90       	pop	r0
    d384:	0f 90       	pop	r0
    d386:	0f 90       	pop	r0
    d388:	0f 90       	pop	r0
    d38a:	0e 94 28 3d 	call	0x7a50	; 0x7a50 <GSM_SendFirstChar>
			GSM_State = GSM_WAIT_PLAY_CONFIRM_FILE_OK;
    d38e:	8e e1       	ldi	r24, 0x1E	; 30
    d390:	80 93 f6 06 	sts	0x06F6, r24
			StartTimer16(TD_GSM, 2000);
    d394:	80 91 e9 04 	lds	r24, 0x04E9
    d398:	60 ed       	ldi	r22, 0xD0	; 208
    d39a:	77 e0       	ldi	r23, 0x07	; 7
    d39c:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
    d3a0:	5e cc       	rjmp	.-1860   	; 0xcc5e <GSM_Cycle+0x40>
			GSM_State = GSM_WAIT_CREC_0;
			StartTimer16(TD_GSM, 1000);
			GSM_SendFirstChar();
			break;
		case GSM_WAIT_CREC_0:
			if(GetStringFromFIFO()){
    d3a2:	0e 94 fe 3b 	call	0x77fc	; 0x77fc <GetStringFromFIFO>
    d3a6:	88 23       	and	r24, r24
    d3a8:	09 f4       	brne	.+2      	; 0xd3ac <GSM_Cycle+0x78e>
    d3aa:	8c c6       	rjmp	.+3352   	; 0xe0c4 <GSM_Cycle+0x14a6>
				if((strstr_P(GSM_RxStr, PSTR("+CREC: 0")) != NULL) ){
    d3ac:	81 ee       	ldi	r24, 0xE1	; 225
    d3ae:	97 e0       	ldi	r25, 0x07	; 7
    d3b0:	6c eb       	ldi	r22, 0xBC	; 188
    d3b2:	72 e3       	ldi	r23, 0x32	; 50
    d3b4:	0e 94 58 84 	call	0x108b0	; 0x108b0 <strstr_P>
    d3b8:	89 2b       	or	r24, r25
    d3ba:	09 f4       	brne	.+2      	; 0xd3be <GSM_Cycle+0x7a0>
    d3bc:	83 c6       	rjmp	.+3334   	; 0xe0c4 <GSM_Cycle+0x14a6>
					GSM_State = GSM_SEND_PLAY_CONFIRM_FILE;
    d3be:	8d e1       	ldi	r24, 0x1D	; 29
    d3c0:	80 93 f6 06 	sts	0x06F6, r24
    d3c4:	4c cc       	rjmp	.-1896   	; 0xcc5e <GSM_Cycle+0x40>
				}
			}

			break;
		case GSM_SEND_CREC_5:
			sprintf_P(GSM_TxStr, PSTR("AT+CREC=5\r"));
    d3c6:	00 d0       	rcall	.+0      	; 0xd3c8 <GSM_Cycle+0x7aa>
    d3c8:	0f 92       	push	r0
    d3ca:	8a e4       	ldi	r24, 0x4A	; 74
    d3cc:	9a e0       	ldi	r25, 0x0A	; 10
    d3ce:	ad b7       	in	r26, 0x3d	; 61
    d3d0:	be b7       	in	r27, 0x3e	; 62
    d3d2:	12 96       	adiw	r26, 0x02	; 2
    d3d4:	9c 93       	st	X, r25
    d3d6:	8e 93       	st	-X, r24
    d3d8:	11 97       	sbiw	r26, 0x01	; 1
    d3da:	85 ec       	ldi	r24, 0xC5	; 197
    d3dc:	92 e3       	ldi	r25, 0x32	; 50
    d3de:	14 96       	adiw	r26, 0x04	; 4
    d3e0:	9c 93       	st	X, r25
    d3e2:	8e 93       	st	-X, r24
    d3e4:	13 97       	sbiw	r26, 0x03	; 3
    d3e6:	0e 94 53 85 	call	0x10aa6	; 0x10aa6 <sprintf_P>
			GSMTxSz=10;
    d3ea:	8a e0       	ldi	r24, 0x0A	; 10
    d3ec:	80 93 bb 07 	sts	0x07BB, r24
			GSM_State = GSM_WAIT_CREC_0;
    d3f0:	8c e1       	ldi	r24, 0x1C	; 28
    d3f2:	80 93 f6 06 	sts	0x06F6, r24
			StartTimer16(TD_GSM, 1000);
    d3f6:	0f 90       	pop	r0
    d3f8:	0f 90       	pop	r0
    d3fa:	0f 90       	pop	r0
    d3fc:	0f 90       	pop	r0
    d3fe:	80 91 e9 04 	lds	r24, 0x04E9
    d402:	68 ee       	ldi	r22, 0xE8	; 232
    d404:	73 e0       	ldi	r23, 0x03	; 3
    d406:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
			GSM_SendFirstChar();
    d40a:	0e 94 28 3d 	call	0x7a50	; 0x7a50 <GSM_SendFirstChar>
    d40e:	27 cc       	rjmp	.-1970   	; 0xcc5e <GSM_Cycle+0x40>
			if(Timer16Stopp(TD_GSM)){
				GSM_State = GSM_WAIT_MESSAGE;
			}
			break;
		case GSM_WAIT_CONFIRMRESPONSE:
			if(GetStringFromFIFO()){
    d410:	0e 94 fe 3b 	call	0x77fc	; 0x77fc <GetStringFromFIFO>
    d414:	88 23       	and	r24, r24
    d416:	11 f0       	breq	.+4      	; 0xd41c <GSM_Cycle+0x7fe>
    d418:	0c 94 c2 72 	jmp	0xe584	; 0xe584 <GSM_Cycle+0x1966>
						StartTimer16(TD_GSM,2000);
						GSM_State = GSM_WAIT_DISCONNECT_CAUSE;
						
					}
			}
			if(Timer16Stopp(TD_GSM)){
    d41c:	80 91 e9 04 	lds	r24, 0x04E9
    d420:	0e 94 84 1f 	call	0x3f08	; 0x3f08 <Timer16Stopp>
    d424:	88 23       	and	r24, r24
    d426:	09 f4       	brne	.+2      	; 0xd42a <GSM_Cycle+0x80c>
    d428:	1a cc       	rjmp	.-1996   	; 0xcc5e <GSM_Cycle+0x40>
				if(RequestRepeatCounter<4){
    d42a:	80 91 e2 02 	lds	r24, 0x02E2
    d42e:	84 30       	cpi	r24, 0x04	; 4
    d430:	10 f0       	brcs	.+4      	; 0xd436 <GSM_Cycle+0x818>
    d432:	0c 94 f2 72 	jmp	0xe5e4	; 0xe5e4 <GSM_Cycle+0x19c6>
				GSM_State = GSM_SEND_PLAY_ALARM_FILE;
    d436:	84 e1       	ldi	r24, 0x14	; 20
    d438:	80 93 f6 06 	sts	0x06F6, r24
    d43c:	10 cc       	rjmp	.-2016   	; 0xcc5e <GSM_Cycle+0x40>
					GSM_State = GSM_WAIT_PLAY_CONFIRMREQUEST_FILE_CREC_0;
					StartTimer16(TD_GSM, 20000);
				}
			break;
		case GSM_WAIT_PLAY_CONFIRMREQUEST_FILE_CREC_0:
			if(GetStringFromFIFO()){
    d43e:	0e 94 fe 3b 	call	0x77fc	; 0x77fc <GetStringFromFIFO>
    d442:	88 23       	and	r24, r24
    d444:	09 f4       	brne	.+2      	; 0xd448 <GSM_Cycle+0x82a>
    d446:	51 c6       	rjmp	.+3234   	; 0xe0ea <GSM_Cycle+0x14cc>
				if((strstr_P(GSM_RxStr, PSTR("+CREC: 0")) != NULL) ){
    d448:	81 ee       	ldi	r24, 0xE1	; 225
    d44a:	97 e0       	ldi	r25, 0x07	; 7
    d44c:	60 e0       	ldi	r22, 0x00	; 0
    d44e:	73 e3       	ldi	r23, 0x33	; 51
    d450:	0e 94 58 84 	call	0x108b0	; 0x108b0 <strstr_P>
    d454:	89 2b       	or	r24, r25
    d456:	09 f4       	brne	.+2      	; 0xd45a <GSM_Cycle+0x83c>
    d458:	42 c6       	rjmp	.+3204   	; 0xe0de <GSM_Cycle+0x14c0>
					GSM_State = GSM_WAIT_CONFIRMRESPONSE;
    d45a:	8a e1       	ldi	r24, 0x1A	; 26
    d45c:	80 93 f6 06 	sts	0x06F6, r24
					StartTimer16(TD_GSM, 200);
    d460:	80 91 e9 04 	lds	r24, 0x04E9
    d464:	68 ec       	ldi	r22, 0xC8	; 200
    d466:	70 e0       	ldi	r23, 0x00	; 0
    d468:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
    d46c:	f8 cb       	rjmp	.-2064   	; 0xcc5e <GSM_Cycle+0x40>
			GSM_SendFirstChar();
			GSM_State = GSM_WAIT_PLAY_CONFIRMREQUEST_FILE_OK;
			StartTimer16(TD_GSM, 1000);
			break;
		case GSM_WAIT_PLAY_CONFIRMREQUEST_FILE_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_WAIT_MESSAGE)) 
    d46e:	81 ef       	ldi	r24, 0xF1	; 241
    d470:	93 e0       	ldi	r25, 0x03	; 3
    d472:	6e e0       	ldi	r22, 0x0E	; 14
    d474:	0e 94 3f 4e 	call	0x9c7e	; 0x9c7e <GSM_Wait_Response_P>
    d478:	88 23       	and	r24, r24
    d47a:	09 f4       	brne	.+2      	; 0xd47e <GSM_Cycle+0x860>
    d47c:	f0 cb       	rjmp	.-2080   	; 0xcc5e <GSM_Cycle+0x40>
				{
					GSM_State = GSM_WAIT_PLAY_CONFIRMREQUEST_FILE_CREC_0;
    d47e:	89 e1       	ldi	r24, 0x19	; 25
    d480:	80 93 f6 06 	sts	0x06F6, r24
					StartTimer16(TD_GSM, 20000);
    d484:	80 91 e9 04 	lds	r24, 0x04E9
    d488:	60 e2       	ldi	r22, 0x20	; 32
    d48a:	7e e4       	ldi	r23, 0x4E	; 78
    d48c:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
    d490:	e6 cb       	rjmp	.-2100   	; 0xcc5e <GSM_Cycle+0x40>
			if(Timer16Stopp(TD_GSM)){
				GSM_State = GSM_WAIT_MESSAGE;
			}
			break;
		case GSM_SEND_PLAY_CONFIRMREQUEST_FILE: 
			sprintf_P(GSM_TxStr, PSTR("AT+CREC=4,\"C:\\User\\ConfirmRequest.amr\",0,100\r"));
    d492:	00 d0       	rcall	.+0      	; 0xd494 <GSM_Cycle+0x876>
    d494:	0f 92       	push	r0
    d496:	8a e4       	ldi	r24, 0x4A	; 74
    d498:	9a e0       	ldi	r25, 0x0A	; 10
    d49a:	ed b7       	in	r30, 0x3d	; 61
    d49c:	fe b7       	in	r31, 0x3e	; 62
    d49e:	92 83       	std	Z+2, r25	; 0x02
    d4a0:	81 83       	std	Z+1, r24	; 0x01
    d4a2:	89 e0       	ldi	r24, 0x09	; 9
    d4a4:	93 e3       	ldi	r25, 0x33	; 51
    d4a6:	94 83       	std	Z+4, r25	; 0x04
    d4a8:	83 83       	std	Z+3, r24	; 0x03
    d4aa:	0e 94 53 85 	call	0x10aa6	; 0x10aa6 <sprintf_P>
			GSMTxSz=45;
    d4ae:	8d e2       	ldi	r24, 0x2D	; 45
    d4b0:	80 93 bb 07 	sts	0x07BB, r24
			GSM_SendFirstChar();
    d4b4:	0f 90       	pop	r0
    d4b6:	0f 90       	pop	r0
    d4b8:	0f 90       	pop	r0
    d4ba:	0f 90       	pop	r0
    d4bc:	0e 94 28 3d 	call	0x7a50	; 0x7a50 <GSM_SendFirstChar>
			GSM_State = GSM_WAIT_PLAY_CONFIRMREQUEST_FILE_OK;
    d4c0:	88 e1       	ldi	r24, 0x18	; 24
    d4c2:	80 93 f6 06 	sts	0x06F6, r24
			StartTimer16(TD_GSM, 1000);
    d4c6:	80 91 e9 04 	lds	r24, 0x04E9
    d4ca:	68 ee       	ldi	r22, 0xE8	; 232
    d4cc:	73 e0       	ldi	r23, 0x03	; 3
    d4ce:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
    d4d2:	c5 cb       	rjmp	.-2166   	; 0xcc5e <GSM_Cycle+0x40>
					GSM_State = GSM_WAIT_PLAY_ALARM_FILE_CREC_0;
					StartTimer16(TD_GSM, 20000);
				}
			break;
		case GSM_WAIT_PLAY_ALARM_FILE_CREC_0:
			if(GetStringFromFIFO()){
    d4d4:	0e 94 fe 3b 	call	0x77fc	; 0x77fc <GetStringFromFIFO>
    d4d8:	88 23       	and	r24, r24
    d4da:	09 f4       	brne	.+2      	; 0xd4de <GSM_Cycle+0x8c0>
    d4dc:	19 c6       	rjmp	.+3122   	; 0xe110 <GSM_Cycle+0x14f2>
				if((strstr_P(GSM_RxStr, PSTR("+CREC: 0")) != NULL) ){
    d4de:	81 ee       	ldi	r24, 0xE1	; 225
    d4e0:	97 e0       	ldi	r25, 0x07	; 7
    d4e2:	67 e3       	ldi	r22, 0x37	; 55
    d4e4:	73 e3       	ldi	r23, 0x33	; 51
    d4e6:	0e 94 58 84 	call	0x108b0	; 0x108b0 <strstr_P>
    d4ea:	89 2b       	or	r24, r25
    d4ec:	09 f4       	brne	.+2      	; 0xd4f0 <GSM_Cycle+0x8d2>
    d4ee:	0a c6       	rjmp	.+3092   	; 0xe104 <GSM_Cycle+0x14e6>
					GSM_State = GSM_SEND_PLAY_CONFIRMREQUEST_FILE;
    d4f0:	87 e1       	ldi	r24, 0x17	; 23
    d4f2:	80 93 f6 06 	sts	0x06F6, r24
    d4f6:	b3 cb       	rjmp	.-2202   	; 0xcc5e <GSM_Cycle+0x40>
			GSM_SendFirstChar();
			GSM_State = GSM_WAIT_PLAY_ALARM_FILE_OK;
			StartTimer16(TD_GSM, 1000);
			break;
		case GSM_WAIT_PLAY_ALARM_FILE_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_WAIT_MESSAGE)) 
    d4f8:	81 ef       	ldi	r24, 0xF1	; 241
    d4fa:	93 e0       	ldi	r25, 0x03	; 3
    d4fc:	6e e0       	ldi	r22, 0x0E	; 14
    d4fe:	0e 94 3f 4e 	call	0x9c7e	; 0x9c7e <GSM_Wait_Response_P>
    d502:	88 23       	and	r24, r24
    d504:	09 f4       	brne	.+2      	; 0xd508 <GSM_Cycle+0x8ea>
    d506:	ab cb       	rjmp	.-2218   	; 0xcc5e <GSM_Cycle+0x40>
				{
					GSM_State = GSM_WAIT_PLAY_ALARM_FILE_CREC_0;
    d508:	86 e1       	ldi	r24, 0x16	; 22
    d50a:	80 93 f6 06 	sts	0x06F6, r24
					StartTimer16(TD_GSM, 20000);
    d50e:	80 91 e9 04 	lds	r24, 0x04E9
    d512:	60 e2       	ldi	r22, 0x20	; 32
    d514:	7e e4       	ldi	r23, 0x4E	; 78
    d516:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
    d51a:	a1 cb       	rjmp	.-2238   	; 0xcc5e <GSM_Cycle+0x40>
			if(Timer16Stopp(TD_GSM)){
				GSM_State = GSM_WAIT_MESSAGE;
			}
			break;
		case GSM_WAIT_CCLC_3:
			if(GetStringFromFIFO()){
    d51c:	0e 94 fe 3b 	call	0x77fc	; 0x77fc <GetStringFromFIFO>
    d520:	88 23       	and	r24, r24
    d522:	09 f4       	brne	.+2      	; 0xd526 <GSM_Cycle+0x908>
    d524:	79 c6       	rjmp	.+3314   	; 0xe218 <GSM_Cycle+0x15fa>
				if( (strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 2,0,6,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 3,0,6,")) != NULL) ){
    d526:	81 ee       	ldi	r24, 0xE1	; 225
    d528:	97 e0       	ldi	r25, 0x07	; 7
    d52a:	60 e0       	ldi	r22, 0x00	; 0
    d52c:	74 e3       	ldi	r23, 0x34	; 52
    d52e:	0e 94 58 84 	call	0x108b0	; 0x108b0 <strstr_P>
    d532:	89 2b       	or	r24, r25
    d534:	11 f4       	brne	.+4      	; 0xd53a <GSM_Cycle+0x91c>
    d536:	0c 94 b6 73 	jmp	0xe76c	; 0xe76c <GSM_Cycle+0x1b4e>
					StartTimer16(TD_GSM, 6000);
    d53a:	80 91 e9 04 	lds	r24, 0x04E9
    d53e:	60 e7       	ldi	r22, 0x70	; 112
    d540:	77 e1       	ldi	r23, 0x17	; 23
    d542:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
					GSM_State = GSM_WAIT_MESSAGE;
    d546:	8e e0       	ldi	r24, 0x0E	; 14
    d548:	80 93 f6 06 	sts	0x06F6, r24
    d54c:	88 cb       	rjmp	.-2288   	; 0xcc5e <GSM_Cycle+0x40>
		case GSM_WAIT_ATD_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_WAIT_MESSAGE)) GSM_State = GSM_WAIT_CCLC_2;
			StartTimer16(TD_GSM, 1000);
			break;
		case GSM_WAIT_CCLC_2:
			if(GetStringFromFIFO()){
    d54e:	0e 94 fe 3b 	call	0x77fc	; 0x77fc <GetStringFromFIFO>
    d552:	88 23       	and	r24, r24
    d554:	09 f4       	brne	.+2      	; 0xd558 <GSM_Cycle+0x93a>
    d556:	41 c6       	rjmp	.+3202   	; 0xe1da <GSM_Cycle+0x15bc>
				if( (strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,2,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 2,0,2,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 3,0,2,")) != NULL) ){
    d558:	81 ee       	ldi	r24, 0xE1	; 225
    d55a:	97 e0       	ldi	r25, 0x07	; 7
    d55c:	6a e2       	ldi	r22, 0x2A	; 42
    d55e:	74 e3       	ldi	r23, 0x34	; 52
    d560:	0e 94 58 84 	call	0x108b0	; 0x108b0 <strstr_P>
    d564:	89 2b       	or	r24, r25
    d566:	09 f4       	brne	.+2      	; 0xd56a <GSM_Cycle+0x94c>
    d568:	26 c6       	rjmp	.+3148   	; 0xe1b6 <GSM_Cycle+0x1598>
					StartTimer16(TD_GSM, 2000);
    d56a:	80 91 e9 04 	lds	r24, 0x04E9
    d56e:	60 ed       	ldi	r22, 0xD0	; 208
    d570:	77 e0       	ldi	r23, 0x07	; 7
    d572:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
					GSM_State = GSM_WAIT_CCLC_3;
    d576:	82 e1       	ldi	r24, 0x12	; 18
    d578:	80 93 f6 06 	sts	0x06F6, r24
    d57c:	70 cb       	rjmp	.-2336   	; 0xcc5e <GSM_Cycle+0x40>
			if(Timer16Stopp(TD_GSM)){
				GSM_State = GSM_WAIT_MESSAGE;
			}
			break;
		case GSM_SEND_PLAY_ALARM_FILE: 
			RequestRepeatCounter++;
    d57e:	80 91 e2 02 	lds	r24, 0x02E2
    d582:	8f 5f       	subi	r24, 0xFF	; 255
    d584:	80 93 e2 02 	sts	0x02E2, r24
			sprintf_P(GSM_TxStr, PSTR("AT+CREC=4,\"C:\\User\\Alarm"));
    d588:	00 d0       	rcall	.+0      	; 0xd58a <GSM_Cycle+0x96c>
    d58a:	0f 92       	push	r0
    d58c:	ba e4       	ldi	r27, 0x4A	; 74
    d58e:	eb 2e       	mov	r14, r27
    d590:	ba e0       	ldi	r27, 0x0A	; 10
    d592:	fb 2e       	mov	r15, r27
    d594:	ad b7       	in	r26, 0x3d	; 61
    d596:	be b7       	in	r27, 0x3e	; 62
    d598:	12 96       	adiw	r26, 0x02	; 2
    d59a:	fc 92       	st	X, r15
    d59c:	ee 92       	st	-X, r14
    d59e:	11 97       	sbiw	r26, 0x01	; 1
    d5a0:	8d e4       	ldi	r24, 0x4D	; 77
    d5a2:	93 e3       	ldi	r25, 0x33	; 51
    d5a4:	14 96       	adiw	r26, 0x04	; 4
    d5a6:	9c 93       	st	X, r25
    d5a8:	8e 93       	st	-X, r24
    d5aa:	13 97       	sbiw	r26, 0x03	; 3
    d5ac:	0e 94 53 85 	call	0x10aa6	; 0x10aa6 <sprintf_P>
			GSMTxSz=24;
    d5b0:	88 e1       	ldi	r24, 0x18	; 24
    d5b2:	80 93 bb 07 	sts	0x07BB, r24
			sprintf(GSM_TxStr+GSMTxSz,"%u",Message[2]);
    d5b6:	80 91 bb 07 	lds	r24, 0x07BB
    d5ba:	0f 92       	push	r0
    d5bc:	0f 92       	push	r0
    d5be:	ed b7       	in	r30, 0x3d	; 61
    d5c0:	fe b7       	in	r31, 0x3e	; 62
    d5c2:	31 96       	adiw	r30, 0x01	; 1
    d5c4:	90 e0       	ldi	r25, 0x00	; 0
    d5c6:	8e 0d       	add	r24, r14
    d5c8:	9f 1d       	adc	r25, r15
    d5ca:	ad b7       	in	r26, 0x3d	; 61
    d5cc:	be b7       	in	r27, 0x3e	; 62
    d5ce:	12 96       	adiw	r26, 0x02	; 2
    d5d0:	9c 93       	st	X, r25
    d5d2:	8e 93       	st	-X, r24
    d5d4:	11 97       	sbiw	r26, 0x01	; 1
    d5d6:	82 eb       	ldi	r24, 0xB2	; 178
    d5d8:	92 e0       	ldi	r25, 0x02	; 2
    d5da:	93 83       	std	Z+3, r25	; 0x03
    d5dc:	82 83       	std	Z+2, r24	; 0x02
    d5de:	80 91 37 07 	lds	r24, 0x0737
    d5e2:	84 83       	std	Z+4, r24	; 0x04
    d5e4:	15 82       	std	Z+5, r1	; 0x05
    d5e6:	0e 94 22 85 	call	0x10a44	; 0x10a44 <sprintf>
			if(Message[2]>9){
    d5ea:	ed b7       	in	r30, 0x3d	; 61
    d5ec:	fe b7       	in	r31, 0x3e	; 62
    d5ee:	36 96       	adiw	r30, 0x06	; 6
    d5f0:	0f b6       	in	r0, 0x3f	; 63
    d5f2:	f8 94       	cli
    d5f4:	fe bf       	out	0x3e, r31	; 62
    d5f6:	0f be       	out	0x3f, r0	; 63
    d5f8:	ed bf       	out	0x3d, r30	; 61
    d5fa:	80 91 37 07 	lds	r24, 0x0737
    d5fe:	8a 30       	cpi	r24, 0x0A	; 10
    d600:	08 f4       	brcc	.+2      	; 0xd604 <GSM_Cycle+0x9e6>
    d602:	36 c6       	rjmp	.+3180   	; 0xe270 <GSM_Cycle+0x1652>
				GSMTxSz+=2;
    d604:	80 91 bb 07 	lds	r24, 0x07BB
    d608:	8e 5f       	subi	r24, 0xFE	; 254
    d60a:	80 93 bb 07 	sts	0x07BB, r24
			}
			else{
				GSMTxSz++;
			};
			sprintf_P(GSM_TxStr+GSMTxSz, PSTR(".amr\",0,100\r"));
    d60e:	80 91 bb 07 	lds	r24, 0x07BB
    d612:	00 d0       	rcall	.+0      	; 0xd614 <GSM_Cycle+0x9f6>
    d614:	0f 92       	push	r0
    d616:	90 e0       	ldi	r25, 0x00	; 0
    d618:	86 5b       	subi	r24, 0xB6	; 182
    d61a:	95 4f       	sbci	r25, 0xF5	; 245
    d61c:	ad b7       	in	r26, 0x3d	; 61
    d61e:	be b7       	in	r27, 0x3e	; 62
    d620:	12 96       	adiw	r26, 0x02	; 2
    d622:	9c 93       	st	X, r25
    d624:	8e 93       	st	-X, r24
    d626:	11 97       	sbiw	r26, 0x01	; 1
    d628:	80 e4       	ldi	r24, 0x40	; 64
    d62a:	93 e3       	ldi	r25, 0x33	; 51
    d62c:	14 96       	adiw	r26, 0x04	; 4
    d62e:	9c 93       	st	X, r25
    d630:	8e 93       	st	-X, r24
    d632:	13 97       	sbiw	r26, 0x03	; 3
    d634:	0e 94 53 85 	call	0x10aa6	; 0x10aa6 <sprintf_P>
			GSMTxSz += 12;
    d638:	80 91 bb 07 	lds	r24, 0x07BB
    d63c:	84 5f       	subi	r24, 0xF4	; 244
    d63e:	80 93 bb 07 	sts	0x07BB, r24
			GSM_SendFirstChar();
    d642:	0f 90       	pop	r0
    d644:	0f 90       	pop	r0
    d646:	0f 90       	pop	r0
    d648:	0f 90       	pop	r0
    d64a:	0e 94 28 3d 	call	0x7a50	; 0x7a50 <GSM_SendFirstChar>
			GSM_State = GSM_WAIT_PLAY_ALARM_FILE_OK;
    d64e:	85 e1       	ldi	r24, 0x15	; 21
    d650:	80 93 f6 06 	sts	0x06F6, r24
			StartTimer16(TD_GSM, 1000);
    d654:	80 91 e9 04 	lds	r24, 0x04E9
    d658:	68 ee       	ldi	r22, 0xE8	; 232
    d65a:	73 e0       	ldi	r23, 0x03	; 3
    d65c:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
    d660:	fe ca       	rjmp	.-2564   	; 0xcc5e <GSM_Cycle+0x40>
			if(Timer16Stopp(TD_GSM)){
				GSM_State = GSM_WAIT_MESSAGE;
			}
			break;
		case GSM_WAIT_CCLC_0:
			if(GetStringFromFIFO()){
    d662:	0e 94 fe 3b 	call	0x77fc	; 0x77fc <GetStringFromFIFO>
    d666:	88 23       	and	r24, r24
    d668:	09 f4       	brne	.+2      	; 0xd66c <GSM_Cycle+0xa4e>
    d66a:	f5 c5       	rjmp	.+3050   	; 0xe256 <GSM_Cycle+0x1638>
				if((strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,0,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,0,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,0,")) != NULL) ){
    d66c:	81 ee       	ldi	r24, 0xE1	; 225
    d66e:	97 e0       	ldi	r25, 0x07	; 7
    d670:	6c ea       	ldi	r22, 0xAC	; 172
    d672:	73 e3       	ldi	r23, 0x33	; 51
    d674:	0e 94 58 84 	call	0x108b0	; 0x108b0 <strstr_P>
    d678:	89 2b       	or	r24, r25
    d67a:	11 f4       	brne	.+4      	; 0xd680 <GSM_Cycle+0xa62>
    d67c:	0c 94 00 74 	jmp	0xe800	; 0xe800 <GSM_Cycle+0x1be2>
					RequestRepeatCounter = 0;
    d680:	10 92 e2 02 	sts	0x02E2, r1
					GSM_State = GSM_SEND_PLAY_ALARM_FILE;
    d684:	84 e1       	ldi	r24, 0x14	; 20
    d686:	80 93 f6 06 	sts	0x06F6, r24
    d68a:	e9 ca       	rjmp	.-2606   	; 0xcc5e <GSM_Cycle+0x40>
			GSM_SendFirstChar();
			GSM_State = GSM_WAIT_ATD_OK;
			StartTimer16(TD_GSM, 1000);
			break;
		case GSM_WAIT_ATD_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_WAIT_MESSAGE)) GSM_State = GSM_WAIT_CCLC_2;
    d68c:	81 ef       	ldi	r24, 0xF1	; 241
    d68e:	93 e0       	ldi	r25, 0x03	; 3
    d690:	6e e0       	ldi	r22, 0x0E	; 14
    d692:	0e 94 3f 4e 	call	0x9c7e	; 0x9c7e <GSM_Wait_Response_P>
    d696:	88 23       	and	r24, r24
    d698:	19 f0       	breq	.+6      	; 0xd6a0 <GSM_Cycle+0xa82>
    d69a:	81 e1       	ldi	r24, 0x11	; 17
    d69c:	80 93 f6 06 	sts	0x06F6, r24
			StartTimer16(TD_GSM, 1000);
    d6a0:	80 91 e9 04 	lds	r24, 0x04E9
    d6a4:	68 ee       	ldi	r22, 0xE8	; 232
    d6a6:	73 e0       	ldi	r23, 0x03	; 3
    d6a8:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
    d6ac:	d8 ca       	rjmp	.-2640   	; 0xcc5e <GSM_Cycle+0x40>
				break;
			}
			TransmitterState = 0;
			break;
		case GSM_SEND_ATD:
			sprintf_P(GSM_TxStr, ATD_PLUS);	GSMTxSz = strlen_P(ATD_PLUS);
    d6ae:	00 d0       	rcall	.+0      	; 0xd6b0 <GSM_Cycle+0xa92>
    d6b0:	0f 92       	push	r0
    d6b2:	8a e4       	ldi	r24, 0x4A	; 74
    d6b4:	9a e0       	ldi	r25, 0x0A	; 10
    d6b6:	ad b7       	in	r26, 0x3d	; 61
    d6b8:	be b7       	in	r27, 0x3e	; 62
    d6ba:	12 96       	adiw	r26, 0x02	; 2
    d6bc:	9c 93       	st	X, r25
    d6be:	8e 93       	st	-X, r24
    d6c0:	11 97       	sbiw	r26, 0x01	; 1
    d6c2:	02 ec       	ldi	r16, 0xC2	; 194
    d6c4:	14 e0       	ldi	r17, 0x04	; 4
    d6c6:	14 96       	adiw	r26, 0x04	; 4
    d6c8:	1c 93       	st	X, r17
    d6ca:	0e 93       	st	-X, r16
    d6cc:	13 97       	sbiw	r26, 0x03	; 3
    d6ce:	0e 94 53 85 	call	0x10aa6	; 0x10aa6 <sprintf_P>
    d6d2:	0f 90       	pop	r0
    d6d4:	0f 90       	pop	r0
    d6d6:	0f 90       	pop	r0
    d6d8:	0f 90       	pop	r0
    d6da:	c8 01       	movw	r24, r16
    d6dc:	0e 94 36 84 	call	0x1086c	; 0x1086c <strlen_P>
    d6e0:	80 93 bb 07 	sts	0x07BB, r24
			erbl(GSM_TxStr+GSMTxSz, CALL_Number+Message[1], MaxTelephN);
    d6e4:	80 91 bb 07 	lds	r24, 0x07BB
    d6e8:	90 e0       	ldi	r25, 0x00	; 0
    d6ea:	60 91 36 07 	lds	r22, 0x0736
    d6ee:	2d e0       	ldi	r18, 0x0D	; 13
    d6f0:	62 9f       	mul	r22, r18
    d6f2:	b0 01       	movw	r22, r0
    d6f4:	11 24       	eor	r1, r1
    d6f6:	64 51       	subi	r22, 0x14	; 20
    d6f8:	7f 4f       	sbci	r23, 0xFF	; 255
    d6fa:	86 5b       	subi	r24, 0xB6	; 182
    d6fc:	95 4f       	sbci	r25, 0xF5	; 245
    d6fe:	4d e0       	ldi	r20, 0x0D	; 13
    d700:	50 e0       	ldi	r21, 0x00	; 0
    d702:	0e 94 40 87 	call	0x10e80	; 0x10e80 <__eerd_block_m2560>
			GSMTxSz+=MaxTelephN-1;
    d706:	80 91 bb 07 	lds	r24, 0x07BB
    d70a:	84 5f       	subi	r24, 0xF4	; 244
    d70c:	80 93 bb 07 	sts	0x07BB, r24
			const char c=';';
    d710:	8b e3       	ldi	r24, 0x3B	; 59
    d712:	89 83       	std	Y+1, r24	; 0x01
			sprintf(GSM_TxStr+GSMTxSz,&c);GSMTxSz++;
    d714:	80 91 bb 07 	lds	r24, 0x07BB
    d718:	00 d0       	rcall	.+0      	; 0xd71a <GSM_Cycle+0xafc>
    d71a:	0f 92       	push	r0
    d71c:	90 e0       	ldi	r25, 0x00	; 0
    d71e:	86 5b       	subi	r24, 0xB6	; 182
    d720:	95 4f       	sbci	r25, 0xF5	; 245
    d722:	ed b7       	in	r30, 0x3d	; 61
    d724:	fe b7       	in	r31, 0x3e	; 62
    d726:	92 83       	std	Z+2, r25	; 0x02
    d728:	81 83       	std	Z+1, r24	; 0x01
    d72a:	ce 01       	movw	r24, r28
    d72c:	01 96       	adiw	r24, 0x01	; 1
    d72e:	94 83       	std	Z+4, r25	; 0x04
    d730:	83 83       	std	Z+3, r24	; 0x03
    d732:	0e 94 22 85 	call	0x10a44	; 0x10a44 <sprintf>
    d736:	80 91 bb 07 	lds	r24, 0x07BB
    d73a:	8f 5f       	subi	r24, 0xFF	; 255
    d73c:	80 93 bb 07 	sts	0x07BB, r24
			sprintf(GSM_TxStr + GSMTxSz, "\r");	GSMTxSz = GSMTxSz+1;
    d740:	e0 91 bb 07 	lds	r30, 0x07BB
    d744:	f0 e0       	ldi	r31, 0x00	; 0
    d746:	e6 5b       	subi	r30, 0xB6	; 182
    d748:	f5 4f       	sbci	r31, 0xF5	; 245
    d74a:	8d e0       	ldi	r24, 0x0D	; 13
    d74c:	90 e0       	ldi	r25, 0x00	; 0
    d74e:	91 83       	std	Z+1, r25	; 0x01
    d750:	80 83       	st	Z, r24
    d752:	80 91 bb 07 	lds	r24, 0x07BB
    d756:	8f 5f       	subi	r24, 0xFF	; 255
    d758:	80 93 bb 07 	sts	0x07BB, r24
			GSM_SendFirstChar();
    d75c:	0f 90       	pop	r0
    d75e:	0f 90       	pop	r0
    d760:	0f 90       	pop	r0
    d762:	0f 90       	pop	r0
    d764:	0e 94 28 3d 	call	0x7a50	; 0x7a50 <GSM_SendFirstChar>
			GSM_State = GSM_WAIT_ATD_OK;
    d768:	80 e1       	ldi	r24, 0x10	; 16
    d76a:	80 93 f6 06 	sts	0x06F6, r24
			StartTimer16(TD_GSM, 1000);
    d76e:	80 91 e9 04 	lds	r24, 0x04E9
    d772:	68 ee       	ldi	r22, 0xE8	; 232
    d774:	73 e0       	ldi	r23, 0x03	; 3
    d776:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
    d77a:	71 ca       	rjmp	.-2846   	; 0xcc5e <GSM_Cycle+0x40>
		case GSM_WAIT_DDET101_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;
		case GSM_WAIT_MESSAGE:
			
			if(Message[0]==1)
    d77c:	80 91 35 07 	lds	r24, 0x0735
    d780:	81 30       	cpi	r24, 0x01	; 1
    d782:	09 f4       	brne	.+2      	; 0xd786 <GSM_Cycle+0xb68>
    d784:	24 c7       	rjmp	.+3656   	; 0xe5ce <GSM_Cycle+0x19b0>
				ConfirmState = 0;
				TransmitterState = 1;
				GSM_State = GSM_SEND_ATD;
				break;
			}
			TransmitterState = 0;
    d786:	10 92 e3 02 	sts	0x02E3, r1
    d78a:	69 ca       	rjmp	.-2862   	; 0xcc5e <GSM_Cycle+0x40>
			break;
		case GSM_SEND_DDET101:
			GSM_Execute_Command(AT_DDET101,100*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_DDET101_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    d78c:	81 ef       	ldi	r24, 0xF1	; 241
    d78e:	93 e0       	ldi	r25, 0x03	; 3
    d790:	6a e4       	ldi	r22, 0x4A	; 74
    d792:	0e 94 3f 4e 	call	0x9c7e	; 0x9c7e <GSM_Wait_Response_P>
    d796:	88 23       	and	r24, r24
    d798:	09 f4       	brne	.+2      	; 0xd79c <GSM_Cycle+0xb7e>
    d79a:	61 ca       	rjmp	.-2878   	; 0xcc5e <GSM_Cycle+0x40>
    d79c:	80 91 f6 06 	lds	r24, 0x06F6
    d7a0:	8f 5f       	subi	r24, 0xFF	; 255
    d7a2:	80 93 f6 06 	sts	0x06F6, r24
    d7a6:	5b ca       	rjmp	.-2890   	; 0xcc5e <GSM_Cycle+0x40>
			break;
		case GSM_WAIT_CLCC_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;
		case GSM_SEND_DDET101:
			GSM_Execute_Command(AT_DDET101,100*GSM_DEBUG_DELAY); GSM_State++;
    d7a8:	80 e9       	ldi	r24, 0x90	; 144
    d7aa:	94 e0       	ldi	r25, 0x04	; 4
    d7ac:	64 e6       	ldi	r22, 0x64	; 100
    d7ae:	70 e0       	ldi	r23, 0x00	; 0
    d7b0:	0e 94 9a 4e 	call	0x9d34	; 0x9d34 <GSM_Execute_Command>
    d7b4:	80 91 f6 06 	lds	r24, 0x06F6
    d7b8:	8f 5f       	subi	r24, 0xFF	; 255
    d7ba:	80 93 f6 06 	sts	0x06F6, r24
    d7be:	4f ca       	rjmp	.-2914   	; 0xcc5e <GSM_Cycle+0x40>
			break;
		case GSM_SEND_CLCC1:
			GSM_Execute_Command(AT_CLCC1,100*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CLCC_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    d7c0:	81 ef       	ldi	r24, 0xF1	; 241
    d7c2:	93 e0       	ldi	r25, 0x03	; 3
    d7c4:	6a e4       	ldi	r22, 0x4A	; 74
    d7c6:	0e 94 3f 4e 	call	0x9c7e	; 0x9c7e <GSM_Wait_Response_P>
    d7ca:	88 23       	and	r24, r24
    d7cc:	09 f4       	brne	.+2      	; 0xd7d0 <GSM_Cycle+0xbb2>
    d7ce:	47 ca       	rjmp	.-2930   	; 0xcc5e <GSM_Cycle+0x40>
    d7d0:	80 91 f6 06 	lds	r24, 0x06F6
    d7d4:	8f 5f       	subi	r24, 0xFF	; 255
    d7d6:	80 93 f6 06 	sts	0x06F6, r24
    d7da:	41 ca       	rjmp	.-2942   	; 0xcc5e <GSM_Cycle+0x40>
			break;
		case GSM_WAIT_E0_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;
		case GSM_SEND_CLCC1:
			GSM_Execute_Command(AT_CLCC1,100*GSM_DEBUG_DELAY); GSM_State++;
    d7dc:	86 e8       	ldi	r24, 0x86	; 134
    d7de:	94 e0       	ldi	r25, 0x04	; 4
    d7e0:	64 e6       	ldi	r22, 0x64	; 100
    d7e2:	70 e0       	ldi	r23, 0x00	; 0
    d7e4:	0e 94 9a 4e 	call	0x9d34	; 0x9d34 <GSM_Execute_Command>
    d7e8:	80 91 f6 06 	lds	r24, 0x06F6
    d7ec:	8f 5f       	subi	r24, 0xFF	; 255
    d7ee:	80 93 f6 06 	sts	0x06F6, r24
    d7f2:	35 ca       	rjmp	.-2966   	; 0xcc5e <GSM_Cycle+0x40>
		//------------------------
		case GSM_SEND_E0:
			GSM_Execute_Command(AT_E0,100*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_E0_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    d7f4:	81 ef       	ldi	r24, 0xF1	; 241
    d7f6:	93 e0       	ldi	r25, 0x03	; 3
    d7f8:	6a e4       	ldi	r22, 0x4A	; 74
    d7fa:	0e 94 3f 4e 	call	0x9c7e	; 0x9c7e <GSM_Wait_Response_P>
    d7fe:	88 23       	and	r24, r24
    d800:	09 f4       	brne	.+2      	; 0xd804 <GSM_Cycle+0xbe6>
    d802:	2d ca       	rjmp	.-2982   	; 0xcc5e <GSM_Cycle+0x40>
    d804:	80 91 f6 06 	lds	r24, 0x06F6
    d808:	8f 5f       	subi	r24, 0xFF	; 255
    d80a:	80 93 f6 06 	sts	0x06F6, r24
    d80e:	27 ca       	rjmp	.-2994   	; 0xcc5e <GSM_Cycle+0x40>
		case GSM_WAIT_SMS_READY:
			if(GSM_Wait_Response_P(URC_SMS_READY, GSM_ReStart1))GSM_State++;
			break;
		//------------------------
		case GSM_SEND_E0:
			GSM_Execute_Command(AT_E0,100*GSM_DEBUG_DELAY); GSM_State++;
    d810:	81 e8       	ldi	r24, 0x81	; 129
    d812:	94 e0       	ldi	r25, 0x04	; 4
    d814:	64 e6       	ldi	r22, 0x64	; 100
    d816:	70 e0       	ldi	r23, 0x00	; 0
    d818:	0e 94 9a 4e 	call	0x9d34	; 0x9d34 <GSM_Execute_Command>
    d81c:	80 91 f6 06 	lds	r24, 0x06F6
    d820:	8f 5f       	subi	r24, 0xFF	; 255
    d822:	80 93 f6 06 	sts	0x06F6, r24
    d826:	1b ca       	rjmp	.-3018   	; 0xcc5e <GSM_Cycle+0x40>
				if(GSM_Modem == SIMCOM_SIM800) GSM_State = GSM_WAIT_SMS_READY;
				else GSM_State = GSM_SEND_E0;
			}
			break;
		case GSM_WAIT_SMS_READY:
			if(GSM_Wait_Response_P(URC_SMS_READY, GSM_ReStart1))GSM_State++;
    d828:	8c ea       	ldi	r24, 0xAC	; 172
    d82a:	93 e0       	ldi	r25, 0x03	; 3
    d82c:	6a e4       	ldi	r22, 0x4A	; 74
    d82e:	0e 94 3f 4e 	call	0x9c7e	; 0x9c7e <GSM_Wait_Response_P>
    d832:	88 23       	and	r24, r24
    d834:	09 f4       	brne	.+2      	; 0xd838 <GSM_Cycle+0xc1a>
    d836:	13 ca       	rjmp	.-3034   	; 0xcc5e <GSM_Cycle+0x40>
    d838:	80 91 f6 06 	lds	r24, 0x06F6
    d83c:	8f 5f       	subi	r24, 0xFF	; 255
    d83e:	80 93 f6 06 	sts	0x06F6, r24
    d842:	0d ca       	rjmp	.-3046   	; 0xcc5e <GSM_Cycle+0x40>

		case GSM_WAIT_RDY:
			if(GSM_Wait_Response_P(URC_RDY, GSM_ReStart1)) GSM_State++;
			break;
		case GSM_SEND_CGMM:
			GSM_Execute_Command(AT_CGMM,5000*GSM_DEBUG_DELAY); GSM_State++;
    d844:	8e e9       	ldi	r24, 0x9E	; 158
    d846:	94 e0       	ldi	r25, 0x04	; 4
    d848:	68 e8       	ldi	r22, 0x88	; 136
    d84a:	73 e1       	ldi	r23, 0x13	; 19
    d84c:	0e 94 9a 4e 	call	0x9d34	; 0x9d34 <GSM_Execute_Command>
    d850:	80 91 f6 06 	lds	r24, 0x06F6
    d854:	8f 5f       	subi	r24, 0xFF	; 255
    d856:	80 93 f6 06 	sts	0x06F6, r24
    d85a:	01 ca       	rjmp	.-3070   	; 0xcc5e <GSM_Cycle+0x40>
			GSM_Modem = NOT_RECOGNIZED;
			GSM_State = GSM_WAIT_RDY;
			break;

		case GSM_WAIT_RDY:
			if(GSM_Wait_Response_P(URC_RDY, GSM_ReStart1)) GSM_State++;
    d85c:	87 e8       	ldi	r24, 0x87	; 135
    d85e:	93 e0       	ldi	r25, 0x03	; 3
    d860:	6a e4       	ldi	r22, 0x4A	; 74
    d862:	0e 94 3f 4e 	call	0x9c7e	; 0x9c7e <GSM_Wait_Response_P>
    d866:	88 23       	and	r24, r24
    d868:	09 f4       	brne	.+2      	; 0xd86c <GSM_Cycle+0xc4e>
    d86a:	f9 c9       	rjmp	.-3086   	; 0xcc5e <GSM_Cycle+0x40>
    d86c:	80 91 f6 06 	lds	r24, 0x06F6
    d870:	8f 5f       	subi	r24, 0xFF	; 255
    d872:	80 93 f6 06 	sts	0x06F6, r24
    d876:	f3 c9       	rjmp	.-3098   	; 0xcc5e <GSM_Cycle+0x40>
inline static void GSM_Auto(){

	switch(GSM_State){

		case GSM_PowerOn:
			StartTimer16(TD_GSM,1000*GSM_DEBUG_DELAY);
    d878:	80 91 e9 04 	lds	r24, 0x04E9
    d87c:	68 ee       	ldi	r22, 0xE8	; 232
    d87e:	73 e0       	ldi	r23, 0x03	; 3
    d880:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
			StartTimer32(TD_GSM_Reset, 24UL*60UL*6000);	//    24 
    d884:	80 91 eb 04 	lds	r24, 0x04EB
    d888:	40 e0       	ldi	r20, 0x00	; 0
    d88a:	56 ed       	ldi	r21, 0xD6	; 214
    d88c:	63 e8       	ldi	r22, 0x83	; 131
    d88e:	70 e0       	ldi	r23, 0x00	; 0
    d890:	0e 94 87 1e 	call	0x3d0e	; 0x3d0e <StartTimer32>
			StartTimer32(TD_1hour_resetGPRS_timer, 360000); //     
    d894:	80 91 ed 04 	lds	r24, 0x04ED
    d898:	40 e4       	ldi	r20, 0x40	; 64
    d89a:	5e e7       	ldi	r21, 0x7E	; 126
    d89c:	65 e0       	ldi	r22, 0x05	; 5
    d89e:	70 e0       	ldi	r23, 0x00	; 0
    d8a0:	0e 94 87 1e 	call	0x3d0e	; 0x3d0e <StartTimer32>
			StartTimer16(TD_CheckModem,6000);//      5 	
    d8a4:	80 91 ee 04 	lds	r24, 0x04EE
    d8a8:	60 e7       	ldi	r22, 0x70	; 112
    d8aa:	77 e1       	ldi	r23, 0x17	; 23
    d8ac:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
	}
	void GSM_PWRCNTRL_ON(void){
		cli();
    d8b0:	f8 94       	cli
		PORTL &= ~(1<<PL5);
    d8b2:	80 91 0b 01 	lds	r24, 0x010B
    d8b6:	8f 7d       	andi	r24, 0xDF	; 223
    d8b8:	80 93 0b 01 	sts	0x010B, r24
		sei();
    d8bc:	78 94       	sei
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    d8be:	8f ef       	ldi	r24, 0xFF	; 255
    d8c0:	80 93 3e 07 	sts	0x073E, r24
	GSM_RX_FIFO_End = 255;
    d8c4:	80 93 53 06 	sts	0x0653, r24
	GSM_RxCharN = 0;
    d8c8:	10 92 60 0b 	sts	0x0B60, r1
	GSM_RX_FIFOOverFlow = 0;
    d8cc:	10 92 13 09 	sts	0x0913, r1
	GSM_RX_FIFOMax = 0;
    d8d0:	10 92 19 09 	sts	0x0919, r1
			StartTimer32(TD_GSM_Reset, 24UL*60UL*6000);	//    24 
			StartTimer32(TD_1hour_resetGPRS_timer, 360000); //     
			StartTimer16(TD_CheckModem,6000);//      5 	
			GSM_PWRCNTRL_ON();
			InitFIFO();
			counter=0;
    d8d4:	10 92 e0 02 	sts	0x02E0, r1
			GSM_Modem = NOT_RECOGNIZED;
    d8d8:	10 92 34 07 	sts	0x0734, r1
			GSM_State = GSM_WAIT_RDY;
    d8dc:	81 e0       	ldi	r24, 0x01	; 1
    d8de:	80 93 f6 06 	sts	0x06F6, r24
    d8e2:	bd c9       	rjmp	.-3206   	; 0xcc5e <GSM_Cycle+0x40>
		case GSM_WAIT_CPIN_READY:
			if(GSM_Wait_Response_P(URC_CPIN_READY, GSM_ReStart1)) GSM_State++;
			break;

		case GSM_WAIT_CALL_READY:
			if(GSM_Wait_Response_P(URC_CALL_READY, GSM_ReStart1)){
    d8e4:	81 ea       	ldi	r24, 0xA1	; 161
    d8e6:	93 e0       	ldi	r25, 0x03	; 3
    d8e8:	6a e4       	ldi	r22, 0x4A	; 74
    d8ea:	0e 94 3f 4e 	call	0x9c7e	; 0x9c7e <GSM_Wait_Response_P>
    d8ee:	88 23       	and	r24, r24
    d8f0:	09 f4       	brne	.+2      	; 0xd8f4 <GSM_Cycle+0xcd6>
    d8f2:	b5 c9       	rjmp	.-3222   	; 0xcc5e <GSM_Cycle+0x40>
				if(GSM_Modem == SIMCOM_SIM800) GSM_State = GSM_WAIT_SMS_READY;
    d8f4:	80 91 34 07 	lds	r24, 0x0734
    d8f8:	82 30       	cpi	r24, 0x02	; 2
    d8fa:	09 f4       	brne	.+2      	; 0xd8fe <GSM_Cycle+0xce0>
    d8fc:	8a c6       	rjmp	.+3348   	; 0xe612 <GSM_Cycle+0x19f4>
				else GSM_State = GSM_SEND_E0;
    d8fe:	88 e0       	ldi	r24, 0x08	; 8
    d900:	80 93 f6 06 	sts	0x06F6, r24
    d904:	ac c9       	rjmp	.-3240   	; 0xcc5e <GSM_Cycle+0x40>
			}
		case GSM_WAIT_CFUN:
			if(GSM_Wait_Response_P(URC_CFUN, GSM_ReStart1)) GSM_State++;
			break;
		case GSM_WAIT_CPIN_READY:
			if(GSM_Wait_Response_P(URC_CPIN_READY, GSM_ReStart1)) GSM_State++;
    d906:	84 e9       	ldi	r24, 0x94	; 148
    d908:	93 e0       	ldi	r25, 0x03	; 3
    d90a:	6a e4       	ldi	r22, 0x4A	; 74
    d90c:	0e 94 3f 4e 	call	0x9c7e	; 0x9c7e <GSM_Wait_Response_P>
    d910:	88 23       	and	r24, r24
    d912:	09 f4       	brne	.+2      	; 0xd916 <GSM_Cycle+0xcf8>
    d914:	a4 c9       	rjmp	.-3256   	; 0xcc5e <GSM_Cycle+0x40>
    d916:	80 91 f6 06 	lds	r24, 0x06F6
    d91a:	8f 5f       	subi	r24, 0xFF	; 255
    d91c:	80 93 f6 06 	sts	0x06F6, r24
    d920:	9e c9       	rjmp	.-3268   	; 0xcc5e <GSM_Cycle+0x40>
			}
			break;

		//------------------------
		case GSM_WAIT_1:
			GetStringFromFIFO();		//     FIFO
    d922:	0e 94 fe 3b 	call	0x77fc	; 0x77fc <GetStringFromFIFO>
			if(Timer16Stopp(TD_GSM)){
    d926:	80 91 e9 04 	lds	r24, 0x04E9
    d92a:	0e 94 84 1f 	call	0x3f08	; 0x3f08 <Timer16Stopp>
    d92e:	88 23       	and	r24, r24
    d930:	09 f4       	brne	.+2      	; 0xd934 <GSM_Cycle+0xd16>
    d932:	95 c9       	rjmp	.-3286   	; 0xcc5e <GSM_Cycle+0x40>
				GSM_State++;
    d934:	80 91 f6 06 	lds	r24, 0x06F6
    d938:	8f 5f       	subi	r24, 0xFF	; 255
    d93a:	80 93 f6 06 	sts	0x06F6, r24
				GSM_Temp = 0;
    d93e:	10 92 db 05 	sts	0x05DB, r1
    d942:	8d c9       	rjmp	.-3302   	; 0xcc5e <GSM_Cycle+0x40>
			if(GSM_MultiCon) GSM_Execute_Command(AT_CIPMODE_0, 100*GSM_DEBUG_DELAY);
			else GSM_Execute_Command(AT_CIPMODE_1, 100*GSM_DEBUG_DELAY);
			GSM_State++;
			break;
		case GSM_WAIT_CIPMODE_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    d944:	81 ef       	ldi	r24, 0xF1	; 241
    d946:	93 e0       	ldi	r25, 0x03	; 3
    d948:	6a e4       	ldi	r22, 0x4A	; 74
    d94a:	0e 94 3f 4e 	call	0x9c7e	; 0x9c7e <GSM_Wait_Response_P>
    d94e:	88 23       	and	r24, r24
    d950:	09 f4       	brne	.+2      	; 0xd954 <GSM_Cycle+0xd36>
    d952:	85 c9       	rjmp	.-3318   	; 0xcc5e <GSM_Cycle+0x40>
				GSM_State++;
    d954:	80 91 f6 06 	lds	r24, 0x06F6
    d958:	8f 5f       	subi	r24, 0xFF	; 255
    d95a:	80 93 f6 06 	sts	0x06F6, r24
				// between "Call Ready" and "+CMGS"; 8 sec min needs; for kyivstar vpni only
				StartTimer16(TD_GSM, 1000);
    d95e:	80 91 e9 04 	lds	r24, 0x04E9
    d962:	68 ee       	ldi	r22, 0xE8	; 232
    d964:	73 e0       	ldi	r23, 0x03	; 3
    d966:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
    d96a:	79 c9       	rjmp	.-3342   	; 0xcc5e <GSM_Cycle+0x40>
				}
				else GSM_State++;
			}
			break;
		case GSM_SEND_CIPMODE:
			if(GSM_MultiCon) GSM_Execute_Command(AT_CIPMODE_0, 100*GSM_DEBUG_DELAY);
    d96c:	80 91 73 0c 	lds	r24, 0x0C73
    d970:	88 23       	and	r24, r24
    d972:	09 f4       	brne	.+2      	; 0xd976 <GSM_Cycle+0xd58>
    d974:	83 c4       	rjmp	.+2310   	; 0xe27c <GSM_Cycle+0x165e>
    d976:	8b ef       	ldi	r24, 0xFB	; 251
    d978:	94 e0       	ldi	r25, 0x04	; 4
    d97a:	64 e6       	ldi	r22, 0x64	; 100
    d97c:	70 e0       	ldi	r23, 0x00	; 0
    d97e:	0e 94 9a 4e 	call	0x9d34	; 0x9d34 <GSM_Execute_Command>
			else GSM_Execute_Command(AT_CIPMODE_1, 100*GSM_DEBUG_DELAY);
			GSM_State++;
    d982:	80 91 f6 06 	lds	r24, 0x06F6
    d986:	8f 5f       	subi	r24, 0xFF	; 255
    d988:	80 93 f6 06 	sts	0x06F6, r24
    d98c:	68 c9       	rjmp	.-3376   	; 0xcc5e <GSM_Cycle+0x40>
			if(GSM_MultiCon) GSM_Execute_Command(AT_CIPMUX_1, 100*GSM_DEBUG_DELAY);
			else GSM_Execute_Command(AT_CIPMUX_0, 100*GSM_DEBUG_DELAY);
			GSM_State++; 
			break;
		case GSM_WAIT_CIPMUX_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    d98e:	81 ef       	ldi	r24, 0xF1	; 241
    d990:	93 e0       	ldi	r25, 0x03	; 3
    d992:	6a e4       	ldi	r22, 0x4A	; 74
    d994:	0e 94 3f 4e 	call	0x9c7e	; 0x9c7e <GSM_Wait_Response_P>
    d998:	88 23       	and	r24, r24
    d99a:	09 f4       	brne	.+2      	; 0xd99e <GSM_Cycle+0xd80>
    d99c:	60 c9       	rjmp	.-3392   	; 0xcc5e <GSM_Cycle+0x40>
				if(GSM_MultiCon){
    d99e:	80 91 73 0c 	lds	r24, 0x0C73
    d9a2:	88 23       	and	r24, r24
    d9a4:	09 f0       	breq	.+2      	; 0xd9a8 <GSM_Cycle+0xd8a>
    d9a6:	4e c6       	rjmp	.+3228   	; 0xe644 <GSM_Cycle+0x1a26>
					GSM_State = GSM_WAIT_1;
					// between "Call Ready" and "+CMGS"; 8 sec min needs; for kyivstar vpni only
					StartTimer16(TD_GSM, 1000);
				}
				else GSM_State++;
    d9a8:	80 91 f6 06 	lds	r24, 0x06F6
    d9ac:	8f 5f       	subi	r24, 0xFF	; 255
    d9ae:	80 93 f6 06 	sts	0x06F6, r24
    d9b2:	55 c9       	rjmp	.-3414   	; 0xcc5e <GSM_Cycle+0x40>

		case GSM_SEND_CSTT:
			GSM_Execute_Command(AT_CSTT, 300*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CSTT_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    d9b4:	81 ef       	ldi	r24, 0xF1	; 241
    d9b6:	93 e0       	ldi	r25, 0x03	; 3
    d9b8:	6a e4       	ldi	r22, 0x4A	; 74
    d9ba:	0e 94 3f 4e 	call	0x9c7e	; 0x9c7e <GSM_Wait_Response_P>
    d9be:	88 23       	and	r24, r24
    d9c0:	09 f4       	brne	.+2      	; 0xd9c4 <GSM_Cycle+0xda6>
    d9c2:	4d c9       	rjmp	.-3430   	; 0xcc5e <GSM_Cycle+0x40>
    d9c4:	80 91 f6 06 	lds	r24, 0x06F6
    d9c8:	8f 5f       	subi	r24, 0xFF	; 255
    d9ca:	80 93 f6 06 	sts	0x06F6, r24
    d9ce:	47 c9       	rjmp	.-3442   	; 0xcc5e <GSM_Cycle+0x40>



///------------------------ / (  )
		case GSM_SEND_CMGF:
			GSM_Execute_Command(AT_CMGF,100*GSM_DEBUG_DELAY); GSM_State++;
    d9d0:	83 ed       	ldi	r24, 0xD3	; 211
    d9d2:	94 e0       	ldi	r25, 0x04	; 4
    d9d4:	64 e6       	ldi	r22, 0x64	; 100
    d9d6:	70 e0       	ldi	r23, 0x00	; 0
    d9d8:	0e 94 9a 4e 	call	0x9d34	; 0x9d34 <GSM_Execute_Command>
    d9dc:	80 91 f6 06 	lds	r24, 0x06F6
    d9e0:	8f 5f       	subi	r24, 0xFF	; 255
    d9e2:	80 93 f6 06 	sts	0x06F6, r24
    d9e6:	3b c9       	rjmp	.-3466   	; 0xcc5e <GSM_Cycle+0x40>
			if(Timer16Stopp(TD_GSM)){
				GSM_State = GSM_WAIT_MESSAGE;
			}
			break;
		case GSM_WAIT_DISCONNECT_CAUSE:
			if(GetStringFromFIFO()){
    d9e8:	0e 94 fe 3b 	call	0x77fc	; 0x77fc <GetStringFromFIFO>
    d9ec:	88 23       	and	r24, r24
    d9ee:	09 f4       	brne	.+2      	; 0xd9f2 <GSM_Cycle+0xdd4>
    d9f0:	4c c4       	rjmp	.+2200   	; 0xe28a <GSM_Cycle+0x166c>
				if((strstr_P(GSM_RxStr, PSTR("OK")) != NULL) ){
    d9f2:	81 ee       	ldi	r24, 0xE1	; 225
    d9f4:	97 e0       	ldi	r25, 0x07	; 7
    d9f6:	65 e5       	ldi	r22, 0x55	; 85
    d9f8:	72 e3       	ldi	r23, 0x32	; 50
    d9fa:	0e 94 58 84 	call	0x108b0	; 0x108b0 <strstr_P>
    d9fe:	89 2b       	or	r24, r25
    da00:	09 f4       	brne	.+2      	; 0xda04 <GSM_Cycle+0xde6>
    da02:	dc c6       	rjmp	.+3512   	; 0xe7bc <GSM_Cycle+0x1b9e>
					GSM_State = GSM_WAIT_MESSAGE;
    da04:	8e e0       	ldi	r24, 0x0E	; 14
    da06:	80 93 f6 06 	sts	0x06F6, r24
    da0a:	29 c9       	rjmp	.-3502   	; 0xcc5e <GSM_Cycle+0x40>
			GSM_SendFirstChar();
			GSM_State = GSM_WAIT_CCLC_6;
			StartTimer16(TD_GSM, 1000);
			break;	
		case GSM_WAIT_CCLC_6:
			if(GetStringFromFIFO()){
    da0c:	0e 94 fe 3b 	call	0x77fc	; 0x77fc <GetStringFromFIFO>
    da10:	88 23       	and	r24, r24
    da12:	09 f4       	brne	.+2      	; 0xda16 <GSM_Cycle+0xdf8>
    da14:	4a c3       	rjmp	.+1684   	; 0xe0aa <GSM_Cycle+0x148c>
				if((strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6,")) != NULL) ){
    da16:	81 ee       	ldi	r24, 0xE1	; 225
    da18:	97 e0       	ldi	r25, 0x07	; 7
    da1a:	68 e5       	ldi	r22, 0x58	; 88
    da1c:	72 e3       	ldi	r23, 0x32	; 50
    da1e:	0e 94 58 84 	call	0x108b0	; 0x108b0 <strstr_P>
    da22:	89 2b       	or	r24, r25
    da24:	09 f4       	brne	.+2      	; 0xda28 <GSM_Cycle+0xe0a>
    da26:	41 c3       	rjmp	.+1666   	; 0xe0aa <GSM_Cycle+0x148c>
					GSM_State = GSM_WAIT_DISCONNECT_CAUSE;
    da28:	85 e2       	ldi	r24, 0x25	; 37
    da2a:	80 93 f6 06 	sts	0x06F6, r24
					StartTimer16(TD_GSM, 10000);
    da2e:	80 91 e9 04 	lds	r24, 0x04E9
    da32:	60 e1       	ldi	r22, 0x10	; 16
    da34:	77 e2       	ldi	r23, 0x27	; 39
    da36:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
    da3a:	11 c9       	rjmp	.-3550   	; 0xcc5e <GSM_Cycle+0x40>
				GSM_State = GSM_SEND_ATH;
				StartTimer16(TD_GSM, 10000);
			}
			break;	
		case GSM_SEND_ATH:
			sprintf_P(GSM_TxStr, PSTR("ATH\r"));
    da3c:	00 d0       	rcall	.+0      	; 0xda3e <GSM_Cycle+0xe20>
    da3e:	0f 92       	push	r0
    da40:	8a e4       	ldi	r24, 0x4A	; 74
    da42:	9a e0       	ldi	r25, 0x0A	; 10
    da44:	ed b7       	in	r30, 0x3d	; 61
    da46:	fe b7       	in	r31, 0x3e	; 62
    da48:	92 83       	std	Z+2, r25	; 0x02
    da4a:	81 83       	std	Z+1, r24	; 0x01
    da4c:	86 e6       	ldi	r24, 0x66	; 102
    da4e:	92 e3       	ldi	r25, 0x32	; 50
    da50:	94 83       	std	Z+4, r25	; 0x04
    da52:	83 83       	std	Z+3, r24	; 0x03
    da54:	0e 94 53 85 	call	0x10aa6	; 0x10aa6 <sprintf_P>
			GSMTxSz = 4;
    da58:	84 e0       	ldi	r24, 0x04	; 4
    da5a:	80 93 bb 07 	sts	0x07BB, r24
			GSM_SendFirstChar();
    da5e:	0f 90       	pop	r0
    da60:	0f 90       	pop	r0
    da62:	0f 90       	pop	r0
    da64:	0f 90       	pop	r0
    da66:	0e 94 28 3d 	call	0x7a50	; 0x7a50 <GSM_SendFirstChar>
			GSM_State = GSM_WAIT_CCLC_6;
    da6a:	84 e2       	ldi	r24, 0x24	; 36
    da6c:	80 93 f6 06 	sts	0x06F6, r24
			StartTimer16(TD_GSM, 1000);
    da70:	80 91 e9 04 	lds	r24, 0x04E9
    da74:	68 ee       	ldi	r22, 0xE8	; 232
    da76:	73 e0       	ldi	r23, 0x03	; 3
    da78:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
    da7c:	f0 c8       	rjmp	.-3616   	; 0xcc5e <GSM_Cycle+0x40>
					GSM_State = GSM_WAIT_PLAY_NOTCONFIRM_FILE_CREC_0;
					StartTimer16(TD_GSM, 20000);
				}
			break;
		case GSM_WAIT_PLAY_NOTCONFIRM_FILE_CREC_0:
			if(GSM_Wait_Response_P(RESP_CREC_0, GSM_SEND_ATD)) 
    da7e:	81 e5       	ldi	r24, 0x51	; 81
    da80:	94 e0       	ldi	r25, 0x04	; 4
    da82:	6f e0       	ldi	r22, 0x0F	; 15
    da84:	0e 94 3f 4e 	call	0x9c7e	; 0x9c7e <GSM_Wait_Response_P>
    da88:	88 23       	and	r24, r24
    da8a:	09 f4       	brne	.+2      	; 0xda8e <GSM_Cycle+0xe70>
    da8c:	e8 c8       	rjmp	.-3632   	; 0xcc5e <GSM_Cycle+0x40>
			{
				GSM_State = GSM_SEND_ATH;
    da8e:	83 e2       	ldi	r24, 0x23	; 35
    da90:	80 93 f6 06 	sts	0x06F6, r24
				StartTimer16(TD_GSM, 10000);
    da94:	80 91 e9 04 	lds	r24, 0x04E9
    da98:	60 e1       	ldi	r22, 0x10	; 16
    da9a:	77 e2       	ldi	r23, 0x27	; 39
    da9c:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
    daa0:	de c8       	rjmp	.-3652   	; 0xcc5e <GSM_Cycle+0x40>
			GSM_SendFirstChar();
			GSM_State = GSM_WAIT_PLAY_NOTCONFIRM_FILE_OK;
			StartTimer16(TD_GSM, 1000);
			break;
		case GSM_WAIT_PLAY_NOTCONFIRM_FILE_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_WAIT_PLAY_NOTCONFIRM_FILE_OK)) 
    daa2:	81 ef       	ldi	r24, 0xF1	; 241
    daa4:	93 e0       	ldi	r25, 0x03	; 3
    daa6:	61 e2       	ldi	r22, 0x21	; 33
    daa8:	0e 94 3f 4e 	call	0x9c7e	; 0x9c7e <GSM_Wait_Response_P>
    daac:	88 23       	and	r24, r24
    daae:	09 f4       	brne	.+2      	; 0xdab2 <GSM_Cycle+0xe94>
    dab0:	d6 c8       	rjmp	.-3668   	; 0xcc5e <GSM_Cycle+0x40>
				{
					GSM_State = GSM_WAIT_PLAY_NOTCONFIRM_FILE_CREC_0;
    dab2:	82 e2       	ldi	r24, 0x22	; 34
    dab4:	80 93 f6 06 	sts	0x06F6, r24
					StartTimer16(TD_GSM, 20000);
    dab8:	80 91 e9 04 	lds	r24, 0x04E9
    dabc:	60 e2       	ldi	r22, 0x20	; 32
    dabe:	7e e4       	ldi	r23, 0x4E	; 78
    dac0:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
    dac4:	cc c8       	rjmp	.-3688   	; 0xcc5e <GSM_Cycle+0x40>
				GSM_State = GSM_SEND_ATH;
				StartTimer16(TD_GSM, 10000);
			}
			break;
		case GSM_SEND_PLAY_NOTCONFIRM_FILE: 
			sprintf_P(GSM_TxStr, PSTR("AT+CREC=4,\"C:\\User\\NotConfirm.amr\",0,100\r"));
    dac6:	00 d0       	rcall	.+0      	; 0xdac8 <GSM_Cycle+0xeaa>
    dac8:	0f 92       	push	r0
    daca:	8a e4       	ldi	r24, 0x4A	; 74
    dacc:	9a e0       	ldi	r25, 0x0A	; 10
    dace:	ad b7       	in	r26, 0x3d	; 61
    dad0:	be b7       	in	r27, 0x3e	; 62
    dad2:	12 96       	adiw	r26, 0x02	; 2
    dad4:	9c 93       	st	X, r25
    dad6:	8e 93       	st	-X, r24
    dad8:	11 97       	sbiw	r26, 0x01	; 1
    dada:	8b e6       	ldi	r24, 0x6B	; 107
    dadc:	92 e3       	ldi	r25, 0x32	; 50
    dade:	14 96       	adiw	r26, 0x04	; 4
    dae0:	9c 93       	st	X, r25
    dae2:	8e 93       	st	-X, r24
    dae4:	13 97       	sbiw	r26, 0x03	; 3
    dae6:	0e 94 53 85 	call	0x10aa6	; 0x10aa6 <sprintf_P>
			GSMTxSz = 41;
    daea:	89 e2       	ldi	r24, 0x29	; 41
    daec:	80 93 bb 07 	sts	0x07BB, r24
			GSM_SendFirstChar();
    daf0:	0f 90       	pop	r0
    daf2:	0f 90       	pop	r0
    daf4:	0f 90       	pop	r0
    daf6:	0f 90       	pop	r0
    daf8:	0e 94 28 3d 	call	0x7a50	; 0x7a50 <GSM_SendFirstChar>
			GSM_State = GSM_WAIT_PLAY_NOTCONFIRM_FILE_OK;
    dafc:	81 e2       	ldi	r24, 0x21	; 33
    dafe:	80 93 f6 06 	sts	0x06F6, r24
			StartTimer16(TD_GSM, 1000);
    db02:	80 91 e9 04 	lds	r24, 0x04E9
    db06:	68 ee       	ldi	r22, 0xE8	; 232
    db08:	73 e0       	ldi	r23, 0x03	; 3
    db0a:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
    db0e:	a7 c8       	rjmp	.-3762   	; 0xcc5e <GSM_Cycle+0x40>
					GSM_State = GSM_WAIT_PLAY_CONFIRM_FILE_CREC_0;
					StartTimer16(TD_GSM, 20000);
				}
			break;
		case GSM_WAIT_PLAY_CONFIRM_FILE_CREC_0:
			if(GSM_Wait_Response_P(RESP_CREC_0, GSM_SEND_ATD)) 
    db10:	81 e5       	ldi	r24, 0x51	; 81
    db12:	94 e0       	ldi	r25, 0x04	; 4
    db14:	6f e0       	ldi	r22, 0x0F	; 15
    db16:	0e 94 3f 4e 	call	0x9c7e	; 0x9c7e <GSM_Wait_Response_P>
    db1a:	88 23       	and	r24, r24
    db1c:	09 f4       	brne	.+2      	; 0xdb20 <GSM_Cycle+0xf02>
    db1e:	9f c8       	rjmp	.-3778   	; 0xcc5e <GSM_Cycle+0x40>
			{
				GSM_State = GSM_SEND_ATH;
    db20:	83 e2       	ldi	r24, 0x23	; 35
    db22:	80 93 f6 06 	sts	0x06F6, r24
				StartTimer16(TD_GSM, 10000);
    db26:	80 91 e9 04 	lds	r24, 0x04E9
    db2a:	60 e1       	ldi	r22, 0x10	; 16
    db2c:	77 e2       	ldi	r23, 0x27	; 39
    db2e:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
    db32:	95 c8       	rjmp	.-3798   	; 0xcc5e <GSM_Cycle+0x40>
		case GSM_WAIT_CSMP_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State=GSM_SEND_ATD_Check_Ballance;
			break;
		//------------------------
		case GSM_SEND_CIPMUX:
			if(GSM_MultiCon) GSM_Execute_Command(AT_CIPMUX_1, 100*GSM_DEBUG_DELAY);
    db34:	80 91 73 0c 	lds	r24, 0x0C73
    db38:	88 23       	and	r24, r24
    db3a:	09 f4       	brne	.+2      	; 0xdb3e <GSM_Cycle+0xf20>
    db3c:	35 c3       	rjmp	.+1642   	; 0xe1a8 <GSM_Cycle+0x158a>
    db3e:	81 e2       	ldi	r24, 0x21	; 33
    db40:	95 e0       	ldi	r25, 0x05	; 5
    db42:	64 e6       	ldi	r22, 0x64	; 100
    db44:	70 e0       	ldi	r23, 0x00	; 0
    db46:	0e 94 9a 4e 	call	0x9d34	; 0x9d34 <GSM_Execute_Command>
			else GSM_Execute_Command(AT_CIPMUX_0, 100*GSM_DEBUG_DELAY);
			GSM_State++; 
    db4a:	80 91 f6 06 	lds	r24, 0x06F6
    db4e:	8f 5f       	subi	r24, 0xFF	; 255
    db50:	80 93 f6 06 	sts	0x06F6, r24
    db54:	84 c8       	rjmp	.-3832   	; 0xcc5e <GSM_Cycle+0x40>
			break;
		case GSM_SEND_CSMP:
			GSM_Execute_Command(AT_CSMP, 100*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CSMP_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State=GSM_SEND_ATD_Check_Ballance;
    db56:	81 ef       	ldi	r24, 0xF1	; 241
    db58:	93 e0       	ldi	r25, 0x03	; 3
    db5a:	6a e4       	ldi	r22, 0x4A	; 74
    db5c:	0e 94 3f 4e 	call	0x9c7e	; 0x9c7e <GSM_Wait_Response_P>
    db60:	88 23       	and	r24, r24
    db62:	09 f4       	brne	.+2      	; 0xdb66 <GSM_Cycle+0xf48>
    db64:	7c c8       	rjmp	.-3848   	; 0xcc5e <GSM_Cycle+0x40>
    db66:	8c e4       	ldi	r24, 0x4C	; 76
    db68:	80 93 f6 06 	sts	0x06F6, r24
    db6c:	78 c8       	rjmp	.-3856   	; 0xcc5e <GSM_Cycle+0x40>
			break;
		case GSM_WAIT_CMGF_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;
		case GSM_SEND_CSMP:
			GSM_Execute_Command(AT_CSMP, 100*GSM_DEBUG_DELAY); GSM_State++;
    db6e:	8d ed       	ldi	r24, 0xDD	; 221
    db70:	94 e0       	ldi	r25, 0x04	; 4
    db72:	64 e6       	ldi	r22, 0x64	; 100
    db74:	70 e0       	ldi	r23, 0x00	; 0
    db76:	0e 94 9a 4e 	call	0x9d34	; 0x9d34 <GSM_Execute_Command>
    db7a:	80 91 f6 06 	lds	r24, 0x06F6
    db7e:	8f 5f       	subi	r24, 0xFF	; 255
    db80:	80 93 f6 06 	sts	0x06F6, r24
    db84:	6c c8       	rjmp	.-3880   	; 0xcc5e <GSM_Cycle+0x40>
///------------------------ / (  )
		case GSM_SEND_CMGF:
			GSM_Execute_Command(AT_CMGF,100*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CMGF_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    db86:	81 ef       	ldi	r24, 0xF1	; 241
    db88:	93 e0       	ldi	r25, 0x03	; 3
    db8a:	6a e4       	ldi	r22, 0x4A	; 74
    db8c:	0e 94 3f 4e 	call	0x9c7e	; 0x9c7e <GSM_Wait_Response_P>
    db90:	88 23       	and	r24, r24
    db92:	09 f4       	brne	.+2      	; 0xdb96 <GSM_Cycle+0xf78>
    db94:	64 c8       	rjmp	.-3896   	; 0xcc5e <GSM_Cycle+0x40>
    db96:	80 91 f6 06 	lds	r24, 0x06F6
    db9a:	8f 5f       	subi	r24, 0xFF	; 255
    db9c:	80 93 f6 06 	sts	0x06F6, r24
    dba0:	5e c8       	rjmp	.-3908   	; 0xcc5e <GSM_Cycle+0x40>

		case GSM_SEND_CIFSR:
			GSM_Execute_Command(AT_CIFSR, 1000*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CIFSR_OK:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
    dba2:	80 91 e9 04 	lds	r24, 0x04E9
    dba6:	0e 94 84 1f 	call	0x3f08	; 0x3f08 <Timer16Stopp>
    dbaa:	88 23       	and	r24, r24
    dbac:	19 f0       	breq	.+6      	; 0xdbb4 <GSM_Cycle+0xf96>
    dbae:	8a e4       	ldi	r24, 0x4A	; 74
    dbb0:	80 93 f6 06 	sts	0x06F6, r24
			if(GetStringFromFIFO()){
    dbb4:	0e 94 fe 3b 	call	0x77fc	; 0x77fc <GetStringFromFIFO>
    dbb8:	88 23       	and	r24, r24
    dbba:	09 f4       	brne	.+2      	; 0xdbbe <GSM_Cycle+0xfa0>
    dbbc:	50 c8       	rjmp	.-3936   	; 0xcc5e <GSM_Cycle+0x40>
	uint8_t IP4;
} IP_Addr;

//~~~~~~~~~~~~~~
void SetIP(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	IP->IP1 = IP1;
    dbbe:	41 e3       	ldi	r20, 0x31	; 49
    dbc0:	59 e0       	ldi	r21, 0x09	; 9
    dbc2:	10 92 31 09 	sts	0x0931, r1
	IP->IP2 = IP2;
    dbc6:	ba 01       	movw	r22, r20
    dbc8:	6f 5f       	subi	r22, 0xFF	; 255
    dbca:	7f 4f       	sbci	r23, 0xFF	; 255
    dbcc:	10 92 32 09 	sts	0x0932, r1
	IP->IP3 = IP3;
    dbd0:	8a 01       	movw	r16, r20
    dbd2:	0e 5f       	subi	r16, 0xFE	; 254
    dbd4:	1f 4f       	sbci	r17, 0xFF	; 255
    dbd6:	10 92 33 09 	sts	0x0933, r1
	IP->IP4 = IP4;
    dbda:	e3 e0       	ldi	r30, 0x03	; 3
    dbdc:	ee 2e       	mov	r14, r30
    dbde:	f1 2c       	mov	r15, r1
    dbe0:	e4 0e       	add	r14, r20
    dbe2:	f5 1e       	adc	r15, r21
    dbe4:	10 92 34 09 	sts	0x0934, r1
    dbe8:	20 e0       	ldi	r18, 0x00	; 0
    dbea:	a1 ee       	ldi	r26, 0xE1	; 225
    dbec:	b7 e0       	ldi	r27, 0x07	; 7
				SetIP(&GSM_MyIP,0,0,0,0);
				for(uint8_t i=0; i<strlen(GSM_RxStr); i++)
					if(!isdigit(GSM_RxStr[i])) GSM_RxStr[i] = ' ';
    dbee:	30 e2       	ldi	r19, 0x20	; 32
			break;
		case GSM_WAIT_CIFSR_OK:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
			if(GetStringFromFIFO()){
				SetIP(&GSM_MyIP,0,0,0,0);
				for(uint8_t i=0; i<strlen(GSM_RxStr); i++)
    dbf0:	fd 01       	movw	r30, r26
    dbf2:	01 90       	ld	r0, Z+
    dbf4:	00 20       	and	r0, r0
    dbf6:	e9 f7       	brne	.-6      	; 0xdbf2 <GSM_Cycle+0xfd4>
    dbf8:	31 97       	sbiw	r30, 0x01	; 1
    dbfa:	e1 5e       	subi	r30, 0xE1	; 225
    dbfc:	f7 40       	sbci	r31, 0x07	; 7
    dbfe:	82 2f       	mov	r24, r18
    dc00:	90 e0       	ldi	r25, 0x00	; 0
    dc02:	8e 17       	cp	r24, r30
    dc04:	9f 07       	cpc	r25, r31
    dc06:	08 f0       	brcs	.+2      	; 0xdc0a <GSM_Cycle+0xfec>
    dc08:	90 c2       	rjmp	.+1312   	; 0xe12a <GSM_Cycle+0x150c>
					if(!isdigit(GSM_RxStr[i])) GSM_RxStr[i] = ' ';
    dc0a:	fc 01       	movw	r30, r24
    dc0c:	ef 51       	subi	r30, 0x1F	; 31
    dc0e:	f8 4f       	sbci	r31, 0xF8	; 248
    dc10:	80 81       	ld	r24, Z
    dc12:	90 e0       	ldi	r25, 0x00	; 0
    dc14:	c0 97       	sbiw	r24, 0x30	; 48
    dc16:	0a 97       	sbiw	r24, 0x0a	; 10
    dc18:	08 f0       	brcs	.+2      	; 0xdc1c <GSM_Cycle+0xffe>
    dc1a:	30 83       	st	Z, r19
			break;
		case GSM_WAIT_CIFSR_OK:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
			if(GetStringFromFIFO()){
				SetIP(&GSM_MyIP,0,0,0,0);
				for(uint8_t i=0; i<strlen(GSM_RxStr); i++)
    dc1c:	2f 5f       	subi	r18, 0xFF	; 255
    dc1e:	e8 cf       	rjmp	.-48     	; 0xdbf0 <GSM_Cycle+0xfd2>
			break;

	

		case GSM_SEND_CIFSR:
			GSM_Execute_Command(AT_CIFSR, 1000*GSM_DEBUG_DELAY); GSM_State++;
    dc20:	88 e5       	ldi	r24, 0x58	; 88
    dc22:	95 e0       	ldi	r25, 0x05	; 5
    dc24:	68 ee       	ldi	r22, 0xE8	; 232
    dc26:	73 e0       	ldi	r23, 0x03	; 3
    dc28:	0e 94 9a 4e 	call	0x9d34	; 0x9d34 <GSM_Execute_Command>
    dc2c:	80 91 f6 06 	lds	r24, 0x06F6
    dc30:	8f 5f       	subi	r24, 0xFF	; 255
    dc32:	80 93 f6 06 	sts	0x06F6, r24
    dc36:	13 c8       	rjmp	.-4058   	; 0xcc5e <GSM_Cycle+0x40>

		case GSM_SEND_CIICR:
			GSM_Execute_Command(AT_CIICR, 12000*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CIICR_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    dc38:	81 ef       	ldi	r24, 0xF1	; 241
    dc3a:	93 e0       	ldi	r25, 0x03	; 3
    dc3c:	6a e4       	ldi	r22, 0x4A	; 74
    dc3e:	0e 94 3f 4e 	call	0x9c7e	; 0x9c7e <GSM_Wait_Response_P>
    dc42:	88 23       	and	r24, r24
    dc44:	09 f4       	brne	.+2      	; 0xdc48 <GSM_Cycle+0x102a>
    dc46:	0b c8       	rjmp	.-4074   	; 0xcc5e <GSM_Cycle+0x40>
    dc48:	80 91 f6 06 	lds	r24, 0x06F6
    dc4c:	8f 5f       	subi	r24, 0xFF	; 255
    dc4e:	80 93 f6 06 	sts	0x06F6, r24
    dc52:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
		case GSM_WAIT_CSTT_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;

		case GSM_SEND_CIICR:
			GSM_Execute_Command(AT_CIICR, 12000*GSM_DEBUG_DELAY); GSM_State++;
    dc56:	8f e4       	ldi	r24, 0x4F	; 79
    dc58:	95 e0       	ldi	r25, 0x05	; 5
    dc5a:	60 ee       	ldi	r22, 0xE0	; 224
    dc5c:	7e e2       	ldi	r23, 0x2E	; 46
    dc5e:	0e 94 9a 4e 	call	0x9d34	; 0x9d34 <GSM_Execute_Command>
    dc62:	80 91 f6 06 	lds	r24, 0x06F6
    dc66:	8f 5f       	subi	r24, 0xFF	; 255
    dc68:	80 93 f6 06 	sts	0x06F6, r24
    dc6c:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
				}
		
			break;

		case GSM_WAIT_CIPSTART_TCP_CLIENT_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    dc70:	81 ef       	ldi	r24, 0xF1	; 241
    dc72:	93 e0       	ldi	r25, 0x03	; 3
    dc74:	6a e4       	ldi	r22, 0x4A	; 74
    dc76:	0e 94 3f 4e 	call	0x9c7e	; 0x9c7e <GSM_Wait_Response_P>
    dc7a:	88 23       	and	r24, r24
    dc7c:	11 f4       	brne	.+4      	; 0xdc82 <GSM_Cycle+0x1064>
    dc7e:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
    dc82:	80 91 f6 06 	lds	r24, 0x06F6
    dc86:	8f 5f       	subi	r24, 0xFF	; 255
    dc88:	80 93 f6 06 	sts	0x06F6, r24
    dc8c:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
			}			
			break;
		//------------------------
		case GSM_SEND_CIPSTART_TCP_CLIENT:
	
				if(GSM_Flag & (1<<flg_TxCStr)){
    dc90:	80 91 d2 02 	lds	r24, 0x02D2
    dc94:	80 fd       	sbrc	r24, 0
    dc96:	02 c0       	rjmp	.+4      	; 0xdc9c <GSM_Cycle+0x107e>
    dc98:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
					GSMTxSz = strlen_P(AT_CIPSTART_TCP_CLIENT);
    dc9c:	58 e8       	ldi	r21, 0x88	; 136
    dc9e:	e5 2e       	mov	r14, r21
    dca0:	55 e0       	ldi	r21, 0x05	; 5
    dca2:	f5 2e       	mov	r15, r21
    dca4:	c7 01       	movw	r24, r14
    dca6:	0e 94 36 84 	call	0x1086c	; 0x1086c <strlen_P>
    dcaa:	80 93 bb 07 	sts	0x07BB, r24
					sprintf_P(GSM_TxStr, AT_CIPSTART_TCP_CLIENT);
    dcae:	00 d0       	rcall	.+0      	; 0xdcb0 <GSM_Cycle+0x1092>
    dcb0:	0f 92       	push	r0
    dcb2:	0a e4       	ldi	r16, 0x4A	; 74
    dcb4:	1a e0       	ldi	r17, 0x0A	; 10
    dcb6:	ad b7       	in	r26, 0x3d	; 61
    dcb8:	be b7       	in	r27, 0x3e	; 62
    dcba:	12 96       	adiw	r26, 0x02	; 2
    dcbc:	1c 93       	st	X, r17
    dcbe:	0e 93       	st	-X, r16
    dcc0:	11 97       	sbiw	r26, 0x01	; 1
    dcc2:	14 96       	adiw	r26, 0x04	; 4
    dcc4:	fc 92       	st	X, r15
    dcc6:	ee 92       	st	-X, r14
    dcc8:	13 97       	sbiw	r26, 0x03	; 3
    dcca:	0e 94 53 85 	call	0x10aa6	; 0x10aa6 <sprintf_P>
					//GSM_TxStr[12] = 0x30+TempNum;
					sprintf(GSM_TxStr + GSMTxSz, "\"%u.%u.%u.%u\",\"%u\"\r",(unsigned int)erb(&TCP_ServerIP[0].IP1), (unsigned int)erb(&TCP_ServerIP[0].IP2), 
    dcce:	b0 90 bb 07 	lds	r11, 0x07BB
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    dcd2:	0f 90       	pop	r0
    dcd4:	0f 90       	pop	r0
    dcd6:	0f 90       	pop	r0
    dcd8:	0f 90       	pop	r0
    dcda:	81 e9       	ldi	r24, 0x91	; 145
    dcdc:	90 e0       	ldi	r25, 0x00	; 0
    dcde:	0e 94 50 87 	call	0x10ea0	; 0x10ea0 <__eerd_byte_m2560>
    dce2:	f8 2e       	mov	r15, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    dce4:	82 e9       	ldi	r24, 0x92	; 146
    dce6:	90 e0       	ldi	r25, 0x00	; 0
    dce8:	0e 94 50 87 	call	0x10ea0	; 0x10ea0 <__eerd_byte_m2560>
    dcec:	e8 2e       	mov	r14, r24
    dcee:	83 e9       	ldi	r24, 0x93	; 147
    dcf0:	90 e0       	ldi	r25, 0x00	; 0
    dcf2:	0e 94 50 87 	call	0x10ea0	; 0x10ea0 <__eerd_byte_m2560>
    dcf6:	d8 2e       	mov	r13, r24
    dcf8:	84 e9       	ldi	r24, 0x94	; 148
    dcfa:	90 e0       	ldi	r25, 0x00	; 0
    dcfc:	0e 94 50 87 	call	0x10ea0	; 0x10ea0 <__eerd_byte_m2560>
    dd00:	c8 2e       	mov	r12, r24
    dd02:	89 ea       	ldi	r24, 0xA9	; 169
    dd04:	90 e0       	ldi	r25, 0x00	; 0
    dd06:	0e 94 5e 87 	call	0x10ebc	; 0x10ebc <__eerd_word_m2560>
    dd0a:	ed b7       	in	r30, 0x3d	; 61
    dd0c:	fe b7       	in	r31, 0x3e	; 62
    dd0e:	3e 97       	sbiw	r30, 0x0e	; 14
    dd10:	0f b6       	in	r0, 0x3f	; 63
    dd12:	f8 94       	cli
    dd14:	fe bf       	out	0x3e, r31	; 62
    dd16:	0f be       	out	0x3f, r0	; 63
    dd18:	ed bf       	out	0x3d, r30	; 61
    dd1a:	31 96       	adiw	r30, 0x01	; 1
    dd1c:	2b 2d       	mov	r18, r11
    dd1e:	30 e0       	ldi	r19, 0x00	; 0
    dd20:	20 0f       	add	r18, r16
    dd22:	31 1f       	adc	r19, r17
    dd24:	ad b7       	in	r26, 0x3d	; 61
    dd26:	be b7       	in	r27, 0x3e	; 62
    dd28:	12 96       	adiw	r26, 0x02	; 2
    dd2a:	3c 93       	st	X, r19
    dd2c:	2e 93       	st	-X, r18
    dd2e:	11 97       	sbiw	r26, 0x01	; 1
    dd30:	28 eb       	ldi	r18, 0xB8	; 184
    dd32:	32 e0       	ldi	r19, 0x02	; 2
    dd34:	33 83       	std	Z+3, r19	; 0x03
    dd36:	22 83       	std	Z+2, r18	; 0x02
    dd38:	f4 82       	std	Z+4, r15	; 0x04
    dd3a:	15 82       	std	Z+5, r1	; 0x05
    dd3c:	e6 82       	std	Z+6, r14	; 0x06
    dd3e:	17 82       	std	Z+7, r1	; 0x07
    dd40:	d0 86       	std	Z+8, r13	; 0x08
    dd42:	11 86       	std	Z+9, r1	; 0x09
    dd44:	c2 86       	std	Z+10, r12	; 0x0a
    dd46:	13 86       	std	Z+11, r1	; 0x0b
    dd48:	95 87       	std	Z+13, r25	; 0x0d
    dd4a:	84 87       	std	Z+12, r24	; 0x0c
    dd4c:	0e 94 22 85 	call	0x10a44	; 0x10a44 <sprintf>
						(unsigned int)erb(&TCP_ServerIP[0].IP3), (unsigned int)erb(&TCP_ServerIP[0].IP4), (unsigned int)erw(&TCP_ServerPort[0]));
					GSMTxSz = strlen(GSM_TxStr);
    dd50:	f8 01       	movw	r30, r16
    dd52:	01 90       	ld	r0, Z+
    dd54:	00 20       	and	r0, r0
    dd56:	e9 f7       	brne	.-6      	; 0xdd52 <GSM_Cycle+0x1134>
    dd58:	8f 01       	movw	r16, r30
    dd5a:	01 50       	subi	r16, 0x01	; 1
    dd5c:	10 40       	sbci	r17, 0x00	; 0
    dd5e:	0a 54       	subi	r16, 0x4A	; 74
    dd60:	1a 40       	sbci	r17, 0x0A	; 10
    dd62:	00 93 bb 07 	sts	0x07BB, r16
					GSM_SendFirstChar();
    dd66:	2d b7       	in	r18, 0x3d	; 61
    dd68:	3e b7       	in	r19, 0x3e	; 62
    dd6a:	22 5f       	subi	r18, 0xF2	; 242
    dd6c:	3f 4f       	sbci	r19, 0xFF	; 255
    dd6e:	0f b6       	in	r0, 0x3f	; 63
    dd70:	f8 94       	cli
    dd72:	3e bf       	out	0x3e, r19	; 62
    dd74:	0f be       	out	0x3f, r0	; 63
    dd76:	2d bf       	out	0x3d, r18	; 61
    dd78:	0e 94 28 3d 	call	0x7a50	; 0x7a50 <GSM_SendFirstChar>
					StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    dd7c:	80 91 e9 04 	lds	r24, 0x04E9
    dd80:	64 ef       	ldi	r22, 0xF4	; 244
    dd82:	71 e0       	ldi	r23, 0x01	; 1
    dd84:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
					GSM_State++;
    dd88:	80 91 f6 06 	lds	r24, 0x06F6
    dd8c:	8f 5f       	subi	r24, 0xFF	; 255
    dd8e:	80 93 f6 06 	sts	0x06F6, r24
    dd92:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>

		case GSM_WAIT_CIPSTART_TCP_CLIENT_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;
		case GSM_WAIT_CIPSTART_TCP_CLIENT_CONNECT:
			if(GSM_Wait_Response_P(RESP_CONNECT, GSM_ReStart1)){
    dd96:	84 ef       	ldi	r24, 0xF4	; 244
    dd98:	93 e0       	ldi	r25, 0x03	; 3
    dd9a:	6a e4       	ldi	r22, 0x4A	; 74
    dd9c:	0e 94 3f 4e 	call	0x9c7e	; 0x9c7e <GSM_Wait_Response_P>
    dda0:	88 23       	and	r24, r24
    dda2:	11 f4       	brne	.+4      	; 0xdda8 <GSM_Cycle+0x118a>
    dda4:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
				 GSM_State = GSM_WAIT_IDENTIFICATION;
    dda8:	8e e3       	ldi	r24, 0x3E	; 62
    ddaa:	80 93 f6 06 	sts	0x06F6, r24
				 StartTimer16(TD_GSM, 1000*GSM_DEBUG_DELAY);
    ddae:	80 91 e9 04 	lds	r24, 0x04E9
    ddb2:	68 ee       	ldi	r22, 0xE8	; 232
    ddb4:	73 e0       	ldi	r23, 0x03	; 3
    ddb6:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
    ddba:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
				StartTimer16(TD_GSM, 300*GSM_DEBUG_DELAY);
			}
			GSM_State++;
			break;
		case GSM_WAIT_CIPCSGP_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    ddbe:	81 ef       	ldi	r24, 0xF1	; 241
    ddc0:	93 e0       	ldi	r25, 0x03	; 3
    ddc2:	6a e4       	ldi	r22, 0x4A	; 74
    ddc4:	0e 94 3f 4e 	call	0x9c7e	; 0x9c7e <GSM_Wait_Response_P>
    ddc8:	88 23       	and	r24, r24
    ddca:	11 f4       	brne	.+4      	; 0xddd0 <GSM_Cycle+0x11b2>
    ddcc:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
			 if(GSM_Modem == SIMCOM_SIM800)GSM_State++;
    ddd0:	80 91 34 07 	lds	r24, 0x0734
    ddd4:	82 30       	cpi	r24, 0x02	; 2
    ddd6:	09 f4       	brne	.+2      	; 0xddda <GSM_Cycle+0x11bc>
    ddd8:	2e c4       	rjmp	.+2140   	; 0xe636 <GSM_Cycle+0x1a18>
			 else GSM_State=GSM_SEND_CSTT;
    ddda:	85 e3       	ldi	r24, 0x35	; 53
    dddc:	80 93 f6 06 	sts	0x06F6, r24
    dde0:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
			if(GSM_Wait_Response_P(RESP_OK, GSM_SEND_CGATT)) GSM_State++;
			break;

		case GSM_SEND_CIPCSGP:
			//GSM_Execute_Command(AT_CIPCSGP, 300*GSM_DEBUG_DELAY); GSM_State++;
			if(GSM_Flag & (1<<flg_TxCStr)){
    dde4:	80 91 d2 02 	lds	r24, 0x02D2
    dde8:	80 fd       	sbrc	r24, 0
    ddea:	fb c2       	rjmp	.+1526   	; 0xe3e2 <GSM_Cycle+0x17c4>
				GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn_psw);
				sprintf(GSM_TxStr + GSMTxSz, "\"\r");	GSMTxSz = GSMTxSz+2;
				GSM_SendFirstChar();
				StartTimer16(TD_GSM, 300*GSM_DEBUG_DELAY);
			}
			GSM_State++;
    ddec:	80 91 f6 06 	lds	r24, 0x06F6
    ddf0:	8f 5f       	subi	r24, 0xFF	; 255
    ddf2:	80 93 f6 06 	sts	0x06F6, r24
    ddf6:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
			break;
		case GSM_SEND_CGATT:
			GSM_Execute_Command(AT_CGATT, 500*GSM_DEBUG_DELAY); GSM_Temp++; GSM_State++;
			break;
		case GSM_WAIT_CGATT_OK:
			if(GSM_Temp>20) GSM_State = GSM_ReStart1;
    ddfa:	80 91 db 05 	lds	r24, 0x05DB
    ddfe:	85 31       	cpi	r24, 0x15	; 21
    de00:	18 f0       	brcs	.+6      	; 0xde08 <GSM_Cycle+0x11ea>
    de02:	8a e4       	ldi	r24, 0x4A	; 74
    de04:	80 93 f6 06 	sts	0x06F6, r24
			if(GSM_Wait_Response_P(RESP_OK, GSM_SEND_CGATT)) GSM_State++;
    de08:	81 ef       	ldi	r24, 0xF1	; 241
    de0a:	93 e0       	ldi	r25, 0x03	; 3
    de0c:	6f e2       	ldi	r22, 0x2F	; 47
    de0e:	0e 94 3f 4e 	call	0x9c7e	; 0x9c7e <GSM_Wait_Response_P>
    de12:	88 23       	and	r24, r24
    de14:	11 f4       	brne	.+4      	; 0xde1a <GSM_Cycle+0x11fc>
    de16:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
    de1a:	80 91 f6 06 	lds	r24, 0x06F6
    de1e:	8f 5f       	subi	r24, 0xFF	; 255
    de20:	80 93 f6 06 	sts	0x06F6, r24
    de24:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>

		case GSM_SEND_CIPTKA:
			GSM_Execute_Command(AT_CIPTKA, 1000*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CIPTKA_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    de28:	81 ef       	ldi	r24, 0xF1	; 241
    de2a:	93 e0       	ldi	r25, 0x03	; 3
    de2c:	6a e4       	ldi	r22, 0x4A	; 74
    de2e:	0e 94 3f 4e 	call	0x9c7e	; 0x9c7e <GSM_Wait_Response_P>
    de32:	88 23       	and	r24, r24
    de34:	11 f4       	brne	.+4      	; 0xde3a <GSM_Cycle+0x121c>
    de36:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
    de3a:	80 91 f6 06 	lds	r24, 0x06F6
    de3e:	8f 5f       	subi	r24, 0xFF	; 255
    de40:	80 93 f6 06 	sts	0x06F6, r24
    de44:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
			 else GSM_State=GSM_SEND_CSTT;
			 }
			break;

		case GSM_SEND_CIPTKA:
			GSM_Execute_Command(AT_CIPTKA, 1000*GSM_DEBUG_DELAY); GSM_State++;
    de48:	81 e6       	ldi	r24, 0x61	; 97
    de4a:	95 e0       	ldi	r25, 0x05	; 5
    de4c:	68 ee       	ldi	r22, 0xE8	; 232
    de4e:	73 e0       	ldi	r23, 0x03	; 3
    de50:	0e 94 9a 4e 	call	0x9d34	; 0x9d34 <GSM_Execute_Command>
    de54:	80 91 f6 06 	lds	r24, 0x06F6
    de58:	8f 5f       	subi	r24, 0xFF	; 255
    de5a:	80 93 f6 06 	sts	0x06F6, r24
    de5e:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
		case GSM_WAIT_CIPTKA_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;

		case GSM_SEND_CSTT:
			GSM_Execute_Command(AT_CSTT, 300*GSM_DEBUG_DELAY); GSM_State++;
    de62:	87 e4       	ldi	r24, 0x47	; 71
    de64:	95 e0       	ldi	r25, 0x05	; 5
    de66:	6c e2       	ldi	r22, 0x2C	; 44
    de68:	71 e0       	ldi	r23, 0x01	; 1
    de6a:	0e 94 9a 4e 	call	0x9d34	; 0x9d34 <GSM_Execute_Command>
    de6e:	80 91 f6 06 	lds	r24, 0x06F6
    de72:	8f 5f       	subi	r24, 0xFF	; 255
    de74:	80 93 f6 06 	sts	0x06F6, r24
    de78:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
				GSM_State++;
				GSM_Temp = 0;
			}
			break;
		case GSM_SEND_CGATT:
			GSM_Execute_Command(AT_CGATT, 500*GSM_DEBUG_DELAY); GSM_Temp++; GSM_State++;
    de7c:	8d e2       	ldi	r24, 0x2D	; 45
    de7e:	95 e0       	ldi	r25, 0x05	; 5
    de80:	64 ef       	ldi	r22, 0xF4	; 244
    de82:	71 e0       	ldi	r23, 0x01	; 1
    de84:	0e 94 9a 4e 	call	0x9d34	; 0x9d34 <GSM_Execute_Command>
    de88:	80 91 db 05 	lds	r24, 0x05DB
    de8c:	8f 5f       	subi	r24, 0xFF	; 255
    de8e:	80 93 db 05 	sts	0x05DB, r24
    de92:	80 91 f6 06 	lds	r24, 0x06F6
    de96:	8f 5f       	subi	r24, 0xFF	; 255
    de98:	80 93 f6 06 	sts	0x06F6, r24
    de9c:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
				StartTimer16(TD_GSM,200);
				GSM_State++;
			}
			break;
		case GSM_SAVE_IPR:
			if(Timer16Stopp(TD_GSM)) GSM_State++;
    dea0:	80 91 e9 04 	lds	r24, 0x04E9
    dea4:	0e 94 84 1f 	call	0x3f08	; 0x3f08 <Timer16Stopp>
    dea8:	88 23       	and	r24, r24
    deaa:	11 f4       	brne	.+4      	; 0xdeb0 <GSM_Cycle+0x1292>
    deac:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
    deb0:	80 91 f6 06 	lds	r24, 0x06F6
    deb4:	8f 5f       	subi	r24, 0xFF	; 255
    deb6:	80 93 f6 06 	sts	0x06F6, r24
    deba:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
			break;
		case GSM_CFG_SEND_ATW:
			GSM_Execute_Command(AT_W, 100); GSM_State++;
			break;
		case GSM_CFG_WAIT_ATW_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_CFG_SEND_AT)){
    debe:	81 ef       	ldi	r24, 0xF1	; 241
    dec0:	93 e0       	ldi	r25, 0x03	; 3
    dec2:	61 e0       	ldi	r22, 0x01	; 1
    dec4:	0e 94 3f 4e 	call	0x9c7e	; 0x9c7e <GSM_Wait_Response_P>
    dec8:	88 23       	and	r24, r24
    deca:	11 f4       	brne	.+4      	; 0xded0 <GSM_Cycle+0x12b2>
    decc:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
				StartTimer16(TD_GSM,200);
    ded0:	80 91 e9 04 	lds	r24, 0x04E9
    ded4:	68 ec       	ldi	r22, 0xC8	; 200
    ded6:	70 e0       	ldi	r23, 0x00	; 0
    ded8:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
				GSM_State++;
    dedc:	80 91 f6 06 	lds	r24, 0x06F6
    dee0:	8f 5f       	subi	r24, 0xFF	; 255
    dee2:	80 93 f6 06 	sts	0x06F6, r24
    dee6:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
			break;
		case GSM_CFG_SEND_AT:
			if(Timer16Stopp(TD_GSM)) GSM_Execute_Command(AT_AT, 100); GSM_State++;
			break;
		case GSM_CFG_WAIT_AT_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_CFG_SEND_AT)) GSM_State++;
    deea:	81 ef       	ldi	r24, 0xF1	; 241
    deec:	93 e0       	ldi	r25, 0x03	; 3
    deee:	61 e0       	ldi	r22, 0x01	; 1
    def0:	0e 94 3f 4e 	call	0x9c7e	; 0x9c7e <GSM_Wait_Response_P>
    def4:	88 23       	and	r24, r24
    def6:	11 f4       	brne	.+4      	; 0xdefc <GSM_Cycle+0x12de>
    def8:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
    defc:	80 91 f6 06 	lds	r24, 0x06F6
    df00:	8f 5f       	subi	r24, 0xFF	; 255
    df02:	80 93 f6 06 	sts	0x06F6, r24
    df06:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
			StartTimer16(TD_GSM,200);
			GSM_PWRCNTRL_ON();
			GSM_State++;
			break;
		case GSM_CFG_SEND_AT:
			if(Timer16Stopp(TD_GSM)) GSM_Execute_Command(AT_AT, 100); GSM_State++;
    df0a:	80 91 e9 04 	lds	r24, 0x04E9
    df0e:	0e 94 84 1f 	call	0x3f08	; 0x3f08 <Timer16Stopp>
    df12:	88 23       	and	r24, r24
    df14:	31 f0       	breq	.+12     	; 0xdf22 <GSM_Cycle+0x1304>
    df16:	8d e6       	ldi	r24, 0x6D	; 109
    df18:	94 e0       	ldi	r25, 0x04	; 4
    df1a:	64 e6       	ldi	r22, 0x64	; 100
    df1c:	70 e0       	ldi	r23, 0x00	; 0
    df1e:	0e 94 9a 4e 	call	0x9d34	; 0x9d34 <GSM_Execute_Command>
    df22:	80 91 f6 06 	lds	r24, 0x06F6
    df26:	8f 5f       	subi	r24, 0xFF	; 255
    df28:	80 93 f6 06 	sts	0x06F6, r24
    df2c:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
			break;
		case GSM_CFG_SEND_IPR:
			GSM_Execute_Command(AT_IPR9600, 100); GSM_State++;
			break;
		case GSM_CFG_WAIT_IPR_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_CFG_SEND_AT)){
    df30:	81 ef       	ldi	r24, 0xF1	; 241
    df32:	93 e0       	ldi	r25, 0x03	; 3
    df34:	61 e0       	ldi	r22, 0x01	; 1
    df36:	0e 94 3f 4e 	call	0x9c7e	; 0x9c7e <GSM_Wait_Response_P>
    df3a:	88 23       	and	r24, r24
    df3c:	11 f4       	brne	.+4      	; 0xdf42 <GSM_Cycle+0x1324>
    df3e:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
				StartTimer16(TD_GSM,200);
    df42:	80 91 e9 04 	lds	r24, 0x04E9
    df46:	68 ec       	ldi	r22, 0xC8	; 200
    df48:	70 e0       	ldi	r23, 0x00	; 0
    df4a:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
				GSM_State++;
    df4e:	80 91 f6 06 	lds	r24, 0x06F6
    df52:	8f 5f       	subi	r24, 0xFF	; 255
    df54:	80 93 f6 06 	sts	0x06F6, r24
    df58:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
			if(GSM_Wait_Response_P(RESP_OK,GSM_SEND_CSQ)) GSM_State++;
			break;
		case GSM_WAIT_Ballance:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_SEND_CSQ;
			GSM_RxStr[GSM_RXSTR_SIZE-1]='\0';
			while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    df5c:	00 e0       	ldi	r16, 0x00	; 0
    df5e:	32 e0       	ldi	r19, 0x02	; 2
    df60:	c3 2e       	mov	r12, r19
    df62:	d1 2c       	mov	r13, r1
    df64:	cc 0e       	add	r12, r28
    df66:	dd 1e       	adc	r13, r29
    df68:	09 c0       	rjmp	.+18     	; 0xdf7c <GSM_Cycle+0x135e>
				}

			}//while
			char buf[20];
			uint8_t i=0;
			while( (erb(&GPRS_currency[i])!='\0') && ((erb(&GPRS_currency[i])!=' ')||i==0) ){
    df6a:	80 32       	cpi	r24, 0x20	; 32
    df6c:	11 f4       	brne	.+4      	; 0xdf72 <GSM_Cycle+0x1354>
    df6e:	00 23       	and	r16, r16
    df70:	71 f4       	brne	.+28     	; 0xdf8e <GSM_Cycle+0x1370>
				buf[i] = (char)erb(&GPRS_currency[i]);
    df72:	ec 0c       	add	r14, r12
    df74:	fd 1c       	adc	r15, r13
    df76:	f7 01       	movw	r30, r14
    df78:	80 83       	st	Z, r24
				i++;
    df7a:	0f 5f       	subi	r16, 0xFF	; 255
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    df7c:	e0 2e       	mov	r14, r16
    df7e:	ff 24       	eor	r15, r15
    df80:	c7 01       	movw	r24, r14
    df82:	8b 5b       	subi	r24, 0xBB	; 187
    df84:	9f 4f       	sbci	r25, 0xFF	; 255
    df86:	0e 94 50 87 	call	0x10ea0	; 0x10ea0 <__eerd_byte_m2560>
				}

			}//while
			char buf[20];
			uint8_t i=0;
			while( (erb(&GPRS_currency[i])!='\0') && ((erb(&GPRS_currency[i])!=' ')||i==0) ){
    df8a:	88 23       	and	r24, r24
    df8c:	71 f7       	brne	.-36     	; 0xdf6a <GSM_Cycle+0x134c>
				buf[i] = (char)erb(&GPRS_currency[i]);
				i++;
			}
			buf[i]='\0';
    df8e:	ec 0c       	add	r14, r12
    df90:	fd 1c       	adc	r15, r13
    df92:	d7 01       	movw	r26, r14
    df94:	1c 92       	st	X, r1
			char *istr=strstr(GSM_RxStr, buf);
    df96:	81 ee       	ldi	r24, 0xE1	; 225
    df98:	97 e0       	ldi	r25, 0x07	; 7
    df9a:	b6 01       	movw	r22, r12
    df9c:	0e 94 9a 84 	call	0x10934	; 0x10934 <strstr>
			if(istr)
    dfa0:	00 97       	sbiw	r24, 0x00	; 0
    dfa2:	11 f4       	brne	.+4      	; 0xdfa8 <GSM_Cycle+0x138a>
    dfa4:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
			{
					Ballance=*(istr-1)-0x30;
    dfa8:	fc 01       	movw	r30, r24
    dfaa:	82 91       	ld	r24, -Z
    dfac:	90 e0       	ldi	r25, 0x00	; 0
    dfae:	c0 97       	sbiw	r24, 0x30	; 48
    dfb0:	aa 27       	eor	r26, r26
    dfb2:	97 fd       	sbrc	r25, 7
    dfb4:	a0 95       	com	r26
    dfb6:	ba 2f       	mov	r27, r26
    dfb8:	80 93 fb 06 	sts	0x06FB, r24
    dfbc:	90 93 fc 06 	sts	0x06FC, r25
    dfc0:	a0 93 fd 06 	sts	0x06FD, r26
    dfc4:	b0 93 fe 06 	sts	0x06FE, r27
					Ballance+=(*(istr-2)-0x30)*10;
    dfc8:	22 91       	ld	r18, -Z
    dfca:	8f 01       	movw	r16, r30
    dfcc:	4a e0       	ldi	r20, 0x0A	; 10
    dfce:	24 9f       	mul	r18, r20
    dfd0:	90 01       	movw	r18, r0
    dfd2:	11 24       	eor	r1, r1
    dfd4:	20 5e       	subi	r18, 0xE0	; 224
    dfd6:	31 40       	sbci	r19, 0x01	; 1
    dfd8:	49 01       	movw	r8, r18
    dfda:	aa 24       	eor	r10, r10
    dfdc:	97 fc       	sbrc	r9, 7
    dfde:	a0 94       	com	r10
    dfe0:	ba 2c       	mov	r11, r10
    dfe2:	88 0e       	add	r8, r24
    dfe4:	99 1e       	adc	r9, r25
    dfe6:	aa 1e       	adc	r10, r26
    dfe8:	bb 1e       	adc	r11, r27
    dfea:	80 92 fb 06 	sts	0x06FB, r8
    dfee:	90 92 fc 06 	sts	0x06FC, r9
    dff2:	a0 92 fd 06 	sts	0x06FD, r10
    dff6:	b0 92 fe 06 	sts	0x06FE, r11
					uint8_t charnum=4;
					uint32_t razr=100;
					while((*(istr-charnum)>=0x30)&&(*(istr-charnum)<=0x39)){
    dffa:	02 50       	subi	r16, 0x02	; 2
    dffc:	10 40       	sbci	r17, 0x00	; 0
    dffe:	d8 01       	movw	r26, r16
    e000:	6c 91       	ld	r22, X
    e002:	0c 5f       	subi	r16, 0xFC	; 252
    e004:	1f 4f       	sbci	r17, 0xFF	; 255
    e006:	86 2f       	mov	r24, r22
    e008:	80 53       	subi	r24, 0x30	; 48
    e00a:	8a 30       	cpi	r24, 0x0A	; 10
    e00c:	88 f5       	brcc	.+98     	; 0xe070 <GSM_Cycle+0x1452>
    e00e:	24 e0       	ldi	r18, 0x04	; 4
    e010:	72 2e       	mov	r7, r18
    e012:	94 e6       	ldi	r25, 0x64	; 100
    e014:	c9 2e       	mov	r12, r25
    e016:	d1 2c       	mov	r13, r1
    e018:	e1 2c       	mov	r14, r1
    e01a:	f1 2c       	mov	r15, r1
						Ballance+=(*(istr-charnum)-0x30)*razr;
    e01c:	70 e0       	ldi	r23, 0x00	; 0
    e01e:	60 53       	subi	r22, 0x30	; 48
    e020:	70 40       	sbci	r23, 0x00	; 0
    e022:	88 27       	eor	r24, r24
    e024:	77 fd       	sbrc	r23, 7
    e026:	80 95       	com	r24
    e028:	98 2f       	mov	r25, r24
    e02a:	a7 01       	movw	r20, r14
    e02c:	96 01       	movw	r18, r12
    e02e:	0e 94 8c 87 	call	0x10f18	; 0x10f18 <__mulsi3>
    e032:	86 0e       	add	r8, r22
    e034:	97 1e       	adc	r9, r23
    e036:	a8 1e       	adc	r10, r24
    e038:	b9 1e       	adc	r11, r25
    e03a:	80 92 fb 06 	sts	0x06FB, r8
    e03e:	90 92 fc 06 	sts	0x06FC, r9
    e042:	a0 92 fd 06 	sts	0x06FD, r10
    e046:	b0 92 fe 06 	sts	0x06FE, r11
						razr*=10;
    e04a:	c7 01       	movw	r24, r14
    e04c:	b6 01       	movw	r22, r12
    e04e:	2a e0       	ldi	r18, 0x0A	; 10
    e050:	30 e0       	ldi	r19, 0x00	; 0
    e052:	40 e0       	ldi	r20, 0x00	; 0
    e054:	50 e0       	ldi	r21, 0x00	; 0
    e056:	0e 94 8c 87 	call	0x10f18	; 0x10f18 <__mulsi3>
    e05a:	6b 01       	movw	r12, r22
    e05c:	7c 01       	movw	r14, r24
						charnum++;	
    e05e:	73 94       	inc	r7
			{
					Ballance=*(istr-1)-0x30;
					Ballance+=(*(istr-2)-0x30)*10;
					uint8_t charnum=4;
					uint32_t razr=100;
					while((*(istr-charnum)>=0x30)&&(*(istr-charnum)<=0x39)){
    e060:	f8 01       	movw	r30, r16
    e062:	e7 19       	sub	r30, r7
    e064:	f1 09       	sbc	r31, r1
    e066:	60 81       	ld	r22, Z
    e068:	86 2f       	mov	r24, r22
    e06a:	80 53       	subi	r24, 0x30	; 48
    e06c:	8a 30       	cpi	r24, 0x0A	; 10
    e06e:	b0 f2       	brcs	.-84     	; 0xe01c <GSM_Cycle+0x13fe>
						Ballance+=(*(istr-charnum)-0x30)*razr;
						razr*=10;
						charnum++;	
					}
					if(*(istr-charnum)==0x2D)
    e070:	6d 32       	cpi	r22, 0x2D	; 45
    e072:	11 f0       	breq	.+4      	; 0xe078 <GSM_Cycle+0x145a>
    e074:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
					{
						Ballance*=-1;
    e078:	80 91 fb 06 	lds	r24, 0x06FB
    e07c:	90 91 fc 06 	lds	r25, 0x06FC
    e080:	a0 91 fd 06 	lds	r26, 0x06FD
    e084:	b0 91 fe 06 	lds	r27, 0x06FE
    e088:	b0 95       	com	r27
    e08a:	a0 95       	com	r26
    e08c:	90 95       	com	r25
    e08e:	81 95       	neg	r24
    e090:	9f 4f       	sbci	r25, 0xFF	; 255
    e092:	af 4f       	sbci	r26, 0xFF	; 255
    e094:	bf 4f       	sbci	r27, 0xFF	; 255
    e096:	80 93 fb 06 	sts	0x06FB, r24
    e09a:	90 93 fc 06 	sts	0x06FC, r25
    e09e:	a0 93 fd 06 	sts	0x06FD, r26
    e0a2:	b0 93 fe 06 	sts	0x06FE, r27
    e0a6:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
					GSM_State = GSM_WAIT_DISCONNECT_CAUSE;
					StartTimer16(TD_GSM, 10000);
					break;
				}
			}
			if(Timer16Stopp(TD_GSM)){
    e0aa:	80 91 e9 04 	lds	r24, 0x04E9
    e0ae:	0e 94 84 1f 	call	0x3f08	; 0x3f08 <Timer16Stopp>
    e0b2:	88 23       	and	r24, r24
    e0b4:	11 f4       	brne	.+4      	; 0xe0ba <GSM_Cycle+0x149c>
    e0b6:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
				GSM_State = GSM_WAIT_MESSAGE;
    e0ba:	8e e0       	ldi	r24, 0x0E	; 14
    e0bc:	80 93 f6 06 	sts	0x06F6, r24
    e0c0:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
				if((strstr_P(GSM_RxStr, PSTR("+CREC: 0")) != NULL) ){
					GSM_State = GSM_SEND_PLAY_CONFIRM_FILE;
					break;
				}
			}
			if(Timer16Stopp(TD_GSM)){
    e0c4:	80 91 e9 04 	lds	r24, 0x04E9
    e0c8:	0e 94 84 1f 	call	0x3f08	; 0x3f08 <Timer16Stopp>
    e0cc:	88 23       	and	r24, r24
    e0ce:	11 f4       	brne	.+4      	; 0xe0d4 <GSM_Cycle+0x14b6>
    e0d0:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
				GSM_State = GSM_WAIT_MESSAGE;
    e0d4:	8e e0       	ldi	r24, 0x0E	; 14
    e0d6:	80 93 f6 06 	sts	0x06F6, r24
    e0da:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
				if((strstr_P(GSM_RxStr, PSTR("+CREC: 0")) != NULL) ){
					GSM_State = GSM_WAIT_CONFIRMRESPONSE;
					StartTimer16(TD_GSM, 200);
					break;
				}
				if(analize_DTMF()){
    e0de:	0e 94 ad 4e 	call	0x9d5a	; 0x9d5a <analize_DTMF>
    e0e2:	88 23       	and	r24, r24
    e0e4:	11 f0       	breq	.+4      	; 0xe0ea <GSM_Cycle+0x14cc>
    e0e6:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
					break;
				}
			}
			if(Timer16Stopp(TD_GSM)){
    e0ea:	80 91 e9 04 	lds	r24, 0x04E9
    e0ee:	0e 94 84 1f 	call	0x3f08	; 0x3f08 <Timer16Stopp>
    e0f2:	88 23       	and	r24, r24
    e0f4:	11 f4       	brne	.+4      	; 0xe0fa <GSM_Cycle+0x14dc>
    e0f6:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
				GSM_State = GSM_WAIT_MESSAGE;
    e0fa:	8e e0       	ldi	r24, 0x0E	; 14
    e0fc:	80 93 f6 06 	sts	0x06F6, r24
    e100:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
			if(GetStringFromFIFO()){
				if((strstr_P(GSM_RxStr, PSTR("+CREC: 0")) != NULL) ){
					GSM_State = GSM_SEND_PLAY_CONFIRMREQUEST_FILE;
					break;
				}
				if(analize_DTMF()){
    e104:	0e 94 ad 4e 	call	0x9d5a	; 0x9d5a <analize_DTMF>
    e108:	88 23       	and	r24, r24
    e10a:	11 f0       	breq	.+4      	; 0xe110 <GSM_Cycle+0x14f2>
    e10c:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
					break;
				}
			}
			if(Timer16Stopp(TD_GSM)){
    e110:	80 91 e9 04 	lds	r24, 0x04E9
    e114:	0e 94 84 1f 	call	0x3f08	; 0x3f08 <Timer16Stopp>
    e118:	88 23       	and	r24, r24
    e11a:	11 f4       	brne	.+4      	; 0xe120 <GSM_Cycle+0x1502>
    e11c:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
				GSM_State = GSM_WAIT_MESSAGE;
    e120:	8e e0       	ldi	r24, 0x0E	; 14
    e122:	80 93 f6 06 	sts	0x06F6, r24
    e126:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
			if(GetStringFromFIFO()){
				SetIP(&GSM_MyIP,0,0,0,0);
				for(uint8_t i=0; i<strlen(GSM_RxStr); i++)
					if(!isdigit(GSM_RxStr[i])) GSM_RxStr[i] = ' ';
				sscanf_P(GSM_RxStr,PSTR("%hhu %hhu %hhu %hhu"), (unsigned char*)&GSM_MyIP.IP1, (unsigned char*)&GSM_MyIP.IP2, (unsigned char*)&GSM_MyIP.IP3, (unsigned char*)&GSM_MyIP.IP4);
    e12a:	ed b7       	in	r30, 0x3d	; 61
    e12c:	fe b7       	in	r31, 0x3e	; 62
    e12e:	3c 97       	sbiw	r30, 0x0c	; 12
    e130:	0f b6       	in	r0, 0x3f	; 63
    e132:	f8 94       	cli
    e134:	fe bf       	out	0x3e, r31	; 62
    e136:	0f be       	out	0x3f, r0	; 63
    e138:	ed bf       	out	0x3d, r30	; 61
    e13a:	31 96       	adiw	r30, 0x01	; 1
    e13c:	81 ee       	ldi	r24, 0xE1	; 225
    e13e:	97 e0       	ldi	r25, 0x07	; 7
    e140:	ad b7       	in	r26, 0x3d	; 61
    e142:	be b7       	in	r27, 0x3e	; 62
    e144:	12 96       	adiw	r26, 0x02	; 2
    e146:	9c 93       	st	X, r25
    e148:	8e 93       	st	-X, r24
    e14a:	11 97       	sbiw	r26, 0x01	; 1
    e14c:	81 e3       	ldi	r24, 0x31	; 49
    e14e:	92 e3       	ldi	r25, 0x32	; 50
    e150:	93 83       	std	Z+3, r25	; 0x03
    e152:	82 83       	std	Z+2, r24	; 0x02
    e154:	55 83       	std	Z+5, r21	; 0x05
    e156:	44 83       	std	Z+4, r20	; 0x04
    e158:	77 83       	std	Z+7, r23	; 0x07
    e15a:	66 83       	std	Z+6, r22	; 0x06
    e15c:	11 87       	std	Z+9, r17	; 0x09
    e15e:	00 87       	std	Z+8, r16	; 0x08
    e160:	f3 86       	std	Z+11, r15	; 0x0b
    e162:	e2 86       	std	Z+10, r14	; 0x0a
    e164:	0e 94 a7 85 	call	0x10b4e	; 0x10b4e <sscanf_P>
}
uint8_t IP_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	if((IP->IP1 == IP1) && (IP->IP2 == IP2) && (IP->IP3 == IP3) && (IP->IP4 == IP4)) return 1;
    e168:	ed b7       	in	r30, 0x3d	; 61
    e16a:	fe b7       	in	r31, 0x3e	; 62
    e16c:	3c 96       	adiw	r30, 0x0c	; 12
    e16e:	0f b6       	in	r0, 0x3f	; 63
    e170:	f8 94       	cli
    e172:	fe bf       	out	0x3e, r31	; 62
    e174:	0f be       	out	0x3f, r0	; 63
    e176:	ed bf       	out	0x3d, r30	; 61
    e178:	80 91 31 09 	lds	r24, 0x0931
    e17c:	88 23       	and	r24, r24
    e17e:	09 f0       	breq	.+2      	; 0xe182 <GSM_Cycle+0x1564>
    e180:	91 c0       	rjmp	.+290    	; 0xe2a4 <GSM_Cycle+0x1686>
    e182:	80 91 32 09 	lds	r24, 0x0932
    e186:	88 23       	and	r24, r24
    e188:	09 f0       	breq	.+2      	; 0xe18c <GSM_Cycle+0x156e>
    e18a:	8c c0       	rjmp	.+280    	; 0xe2a4 <GSM_Cycle+0x1686>
    e18c:	80 91 33 09 	lds	r24, 0x0933
    e190:	88 23       	and	r24, r24
    e192:	09 f0       	breq	.+2      	; 0xe196 <GSM_Cycle+0x1578>
    e194:	87 c0       	rjmp	.+270    	; 0xe2a4 <GSM_Cycle+0x1686>
    e196:	80 91 34 09 	lds	r24, 0x0934
    e19a:	88 23       	and	r24, r24
    e19c:	09 f0       	breq	.+2      	; 0xe1a0 <GSM_Cycle+0x1582>
    e19e:	82 c0       	rjmp	.+260    	; 0xe2a4 <GSM_Cycle+0x1686>
				if(!IP_compare_Const(&GSM_MyIP,0,0,0,0)){
				  GSM_State = GSM_SEND_CIPSTART_TCP_CLIENT;
				}
				TempNum=0;	//
    e1a0:	10 92 dc 05 	sts	0x05DC, r1
    e1a4:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State=GSM_SEND_ATD_Check_Ballance;
			break;
		//------------------------
		case GSM_SEND_CIPMUX:
			if(GSM_MultiCon) GSM_Execute_Command(AT_CIPMUX_1, 100*GSM_DEBUG_DELAY);
			else GSM_Execute_Command(AT_CIPMUX_0, 100*GSM_DEBUG_DELAY);
    e1a8:	85 e1       	ldi	r24, 0x15	; 21
    e1aa:	95 e0       	ldi	r25, 0x05	; 5
    e1ac:	64 e6       	ldi	r22, 0x64	; 100
    e1ae:	70 e0       	ldi	r23, 0x00	; 0
    e1b0:	0e 94 9a 4e 	call	0x9d34	; 0x9d34 <GSM_Execute_Command>
    e1b4:	ca cc       	rjmp	.-1644   	; 0xdb4a <GSM_Cycle+0xf2c>
			if(GSM_Wait_Response_P(RESP_OK, GSM_WAIT_MESSAGE)) GSM_State = GSM_WAIT_CCLC_2;
			StartTimer16(TD_GSM, 1000);
			break;
		case GSM_WAIT_CCLC_2:
			if(GetStringFromFIFO()){
				if( (strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,2,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 2,0,2,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 3,0,2,")) != NULL) ){
    e1b6:	81 ee       	ldi	r24, 0xE1	; 225
    e1b8:	97 e0       	ldi	r25, 0x07	; 7
    e1ba:	6c e1       	ldi	r22, 0x1C	; 28
    e1bc:	74 e3       	ldi	r23, 0x34	; 52
    e1be:	0e 94 58 84 	call	0x108b0	; 0x108b0 <strstr_P>
    e1c2:	89 2b       	or	r24, r25
    e1c4:	09 f0       	breq	.+2      	; 0xe1c8 <GSM_Cycle+0x15aa>
    e1c6:	d1 c9       	rjmp	.-3166   	; 0xd56a <GSM_Cycle+0x94c>
    e1c8:	81 ee       	ldi	r24, 0xE1	; 225
    e1ca:	97 e0       	ldi	r25, 0x07	; 7
    e1cc:	6e e0       	ldi	r22, 0x0E	; 14
    e1ce:	74 e3       	ldi	r23, 0x34	; 52
    e1d0:	0e 94 58 84 	call	0x108b0	; 0x108b0 <strstr_P>
    e1d4:	89 2b       	or	r24, r25
    e1d6:	09 f0       	breq	.+2      	; 0xe1da <GSM_Cycle+0x15bc>
    e1d8:	c8 c9       	rjmp	.-3184   	; 0xd56a <GSM_Cycle+0x94c>
					StartTimer16(TD_GSM, 2000);
					GSM_State = GSM_WAIT_CCLC_3;
					break;
				}
			}
			if(Timer16Stopp(TD_GSM)){
    e1da:	80 91 e9 04 	lds	r24, 0x04E9
    e1de:	0e 94 84 1f 	call	0x3f08	; 0x3f08 <Timer16Stopp>
    e1e2:	88 23       	and	r24, r24
    e1e4:	11 f4       	brne	.+4      	; 0xe1ea <GSM_Cycle+0x15cc>
    e1e6:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
				GSM_State = GSM_WAIT_MESSAGE;
    e1ea:	8e e0       	ldi	r24, 0x0E	; 14
    e1ec:	80 93 f6 06 	sts	0x06F6, r24
    e1f0:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
				if( (strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 2,0,6,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 3,0,6,")) != NULL) ){
					StartTimer16(TD_GSM, 6000);
					GSM_State = GSM_WAIT_MESSAGE;
					break;
				}
				if( (strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,3,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 2,0,3,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 3,0,3,")) != NULL) ){
    e1f4:	81 ee       	ldi	r24, 0xE1	; 225
    e1f6:	97 e0       	ldi	r25, 0x07	; 7
    e1f8:	68 ec       	ldi	r22, 0xC8	; 200
    e1fa:	73 e3       	ldi	r23, 0x33	; 51
    e1fc:	0e 94 58 84 	call	0x108b0	; 0x108b0 <strstr_P>
    e200:	89 2b       	or	r24, r25
    e202:	09 f0       	breq	.+2      	; 0xe206 <GSM_Cycle+0x15e8>
    e204:	d0 c2       	rjmp	.+1440   	; 0xe7a6 <GSM_Cycle+0x1b88>
    e206:	81 ee       	ldi	r24, 0xE1	; 225
    e208:	97 e0       	ldi	r25, 0x07	; 7
    e20a:	6a eb       	ldi	r22, 0xBA	; 186
    e20c:	73 e3       	ldi	r23, 0x33	; 51
    e20e:	0e 94 58 84 	call	0x108b0	; 0x108b0 <strstr_P>
    e212:	89 2b       	or	r24, r25
    e214:	09 f0       	breq	.+2      	; 0xe218 <GSM_Cycle+0x15fa>
    e216:	c7 c2       	rjmp	.+1422   	; 0xe7a6 <GSM_Cycle+0x1b88>
					GSM_State = GSM_WAIT_CCLC_0;
					break;
				}

			}
			if(Timer16Stopp(TD_GSM)){
    e218:	80 91 e9 04 	lds	r24, 0x04E9
    e21c:	0e 94 84 1f 	call	0x3f08	; 0x3f08 <Timer16Stopp>
    e220:	88 23       	and	r24, r24
    e222:	11 f4       	brne	.+4      	; 0xe228 <GSM_Cycle+0x160a>
    e224:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
				GSM_State = GSM_WAIT_MESSAGE;
    e228:	8e e0       	ldi	r24, 0x0E	; 14
    e22a:	80 93 f6 06 	sts	0x06F6, r24
    e22e:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
				if((strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,0,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,0,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,0,")) != NULL) ){
					RequestRepeatCounter = 0;
					GSM_State = GSM_SEND_PLAY_ALARM_FILE;
					break;
				}
				if( (strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6,")) != NULL)){
    e232:	81 ee       	ldi	r24, 0xE1	; 225
    e234:	97 e0       	ldi	r25, 0x07	; 7
    e236:	64 e7       	ldi	r22, 0x74	; 116
    e238:	73 e3       	ldi	r23, 0x33	; 51
    e23a:	0e 94 58 84 	call	0x108b0	; 0x108b0 <strstr_P>
    e23e:	89 2b       	or	r24, r25
    e240:	09 f0       	breq	.+2      	; 0xe244 <GSM_Cycle+0x1626>
    e242:	fb c2       	rjmp	.+1526   	; 0xe83a <GSM_Cycle+0x1c1c>
    e244:	81 ee       	ldi	r24, 0xE1	; 225
    e246:	97 e0       	ldi	r25, 0x07	; 7
    e248:	66 e6       	ldi	r22, 0x66	; 102
    e24a:	73 e3       	ldi	r23, 0x33	; 51
    e24c:	0e 94 58 84 	call	0x108b0	; 0x108b0 <strstr_P>
    e250:	89 2b       	or	r24, r25
    e252:	09 f0       	breq	.+2      	; 0xe256 <GSM_Cycle+0x1638>
    e254:	f2 c2       	rjmp	.+1508   	; 0xe83a <GSM_Cycle+0x1c1c>
					StartTimer16(TD_GSM, 6000);
					GSM_State = GSM_WAIT_DISCONNECT_CAUSE;
					break;
				}
			}
			if(Timer16Stopp(TD_GSM)){
    e256:	80 91 e9 04 	lds	r24, 0x04E9
    e25a:	0e 94 84 1f 	call	0x3f08	; 0x3f08 <Timer16Stopp>
    e25e:	88 23       	and	r24, r24
    e260:	11 f4       	brne	.+4      	; 0xe266 <GSM_Cycle+0x1648>
    e262:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
				GSM_State = GSM_WAIT_MESSAGE;
    e266:	8e e0       	ldi	r24, 0x0E	; 14
    e268:	80 93 f6 06 	sts	0x06F6, r24
    e26c:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
			sprintf(GSM_TxStr+GSMTxSz,"%u",Message[2]);
			if(Message[2]>9){
				GSMTxSz+=2;
			}
			else{
				GSMTxSz++;
    e270:	80 91 bb 07 	lds	r24, 0x07BB
    e274:	8f 5f       	subi	r24, 0xFF	; 255
    e276:	80 93 bb 07 	sts	0x07BB, r24
    e27a:	c9 c9       	rjmp	.-3182   	; 0xd60e <GSM_Cycle+0x9f0>
				else GSM_State++;
			}
			break;
		case GSM_SEND_CIPMODE:
			if(GSM_MultiCon) GSM_Execute_Command(AT_CIPMODE_0, 100*GSM_DEBUG_DELAY);
			else GSM_Execute_Command(AT_CIPMODE_1, 100*GSM_DEBUG_DELAY);
    e27c:	88 e0       	ldi	r24, 0x08	; 8
    e27e:	95 e0       	ldi	r25, 0x05	; 5
    e280:	64 e6       	ldi	r22, 0x64	; 100
    e282:	70 e0       	ldi	r23, 0x00	; 0
    e284:	0e 94 9a 4e 	call	0x9d34	; 0x9d34 <GSM_Execute_Command>
    e288:	7c cb       	rjmp	.-2312   	; 0xd982 <GSM_Cycle+0xd64>
					break;
				}
				GSM_State = GSM_WAIT_MESSAGE;
				break;
			}
			if(Timer16Stopp(TD_GSM)){
    e28a:	80 91 e9 04 	lds	r24, 0x04E9
    e28e:	0e 94 84 1f 	call	0x3f08	; 0x3f08 <Timer16Stopp>
    e292:	88 23       	and	r24, r24
    e294:	11 f4       	brne	.+4      	; 0xe29a <GSM_Cycle+0x167c>
    e296:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
				GSM_State = GSM_WAIT_MESSAGE;
    e29a:	8e e0       	ldi	r24, 0x0E	; 14
    e29c:	80 93 f6 06 	sts	0x06F6, r24
    e2a0:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
				SetIP(&GSM_MyIP,0,0,0,0);
				for(uint8_t i=0; i<strlen(GSM_RxStr); i++)
					if(!isdigit(GSM_RxStr[i])) GSM_RxStr[i] = ' ';
				sscanf_P(GSM_RxStr,PSTR("%hhu %hhu %hhu %hhu"), (unsigned char*)&GSM_MyIP.IP1, (unsigned char*)&GSM_MyIP.IP2, (unsigned char*)&GSM_MyIP.IP3, (unsigned char*)&GSM_MyIP.IP4);
				if(!IP_compare_Const(&GSM_MyIP,0,0,0,0)){
				  GSM_State = GSM_SEND_CIPSTART_TCP_CLIENT;
    e2a4:	8b e3       	ldi	r24, 0x3B	; 59
    e2a6:	80 93 f6 06 	sts	0x06F6, r24
    e2aa:	7a cf       	rjmp	.-268    	; 0xe1a0 <GSM_Cycle+0x1582>
					if(GSM_RxCharN==2)
						{
							if(!strncmp_P(GSM_RxStr, PSTR("\r\n"), 2)) {GSM_RxCharN=0;}
						}
					if(GSM_RxCharN >= 4){
						AppProtocol = 0;
    e2ac:	10 92 e7 08 	sts	0x08E7, r1
						if(!strncmp_P(GSM_RxStr, PSTR("GET "), 4)) {AppProtocol = _HTTP;GSM_State = GSM_DataMode;break;}//GET
    e2b0:	81 ee       	ldi	r24, 0xE1	; 225
    e2b2:	97 e0       	ldi	r25, 0x07	; 7
    e2b4:	69 e0       	ldi	r22, 0x09	; 9
    e2b6:	72 e3       	ldi	r23, 0x32	; 50
    e2b8:	44 e0       	ldi	r20, 0x04	; 4
    e2ba:	50 e0       	ldi	r21, 0x00	; 0
    e2bc:	0e 94 3f 84 	call	0x1087e	; 0x1087e <strncmp_P>
    e2c0:	89 2b       	or	r24, r25
    e2c2:	09 f4       	brne	.+2      	; 0xe2c6 <GSM_Cycle+0x16a8>
    e2c4:	3b c3       	rjmp	.+1654   	; 0xe93c <GSM_Cycle+0x1d1e>
						if(!strncmp_P(GSM_RxStr, PSTR("POST"), 4)) {AppProtocol = _HTTP;GSM_State = GSM_DataMode;break;}//POST
    e2c6:	81 ee       	ldi	r24, 0xE1	; 225
    e2c8:	97 e0       	ldi	r25, 0x07	; 7
    e2ca:	64 e0       	ldi	r22, 0x04	; 4
    e2cc:	72 e3       	ldi	r23, 0x32	; 50
    e2ce:	44 e0       	ldi	r20, 0x04	; 4
    e2d0:	50 e0       	ldi	r21, 0x00	; 0
    e2d2:	0e 94 3f 84 	call	0x1087e	; 0x1087e <strncmp_P>
    e2d6:	89 2b       	or	r24, r25
    e2d8:	09 f4       	brne	.+2      	; 0xe2dc <GSM_Cycle+0x16be>
    e2da:	30 c3       	rjmp	.+1632   	; 0xe93c <GSM_Cycle+0x1d1e>
						if(!strncmp_P(GSM_RxStr, PSTR("CLOS"), 4)) {AppProtocol = _HTTP;GSM_State = GSM_ReStart1;break;}// 
    e2dc:	81 ee       	ldi	r24, 0xE1	; 225
    e2de:	97 e0       	ldi	r25, 0x07	; 7
    e2e0:	6f ef       	ldi	r22, 0xFF	; 255
    e2e2:	71 e3       	ldi	r23, 0x31	; 49
    e2e4:	44 e0       	ldi	r20, 0x04	; 4
    e2e6:	50 e0       	ldi	r21, 0x00	; 0
    e2e8:	0e 94 3f 84 	call	0x1087e	; 0x1087e <strncmp_P>
    e2ec:	89 2b       	or	r24, r25
    e2ee:	09 f4       	brne	.+2      	; 0xe2f2 <GSM_Cycle+0x16d4>
    e2f0:	1e c3       	rjmp	.+1596   	; 0xe92e <GSM_Cycle+0x1d10>
						if(!strncmp_P(GSM_RxStr, PSTR("+PDP"), 4)) {AppProtocol = _HTTP;GSM_State = GSM_ReStart1;break;}//GPRS 
    e2f2:	81 ee       	ldi	r24, 0xE1	; 225
    e2f4:	97 e0       	ldi	r25, 0x07	; 7
    e2f6:	6a ef       	ldi	r22, 0xFA	; 250
    e2f8:	71 e3       	ldi	r23, 0x31	; 49
    e2fa:	44 e0       	ldi	r20, 0x04	; 4
    e2fc:	50 e0       	ldi	r21, 0x00	; 0
    e2fe:	0e 94 3f 84 	call	0x1087e	; 0x1087e <strncmp_P>
    e302:	89 2b       	or	r24, r25
    e304:	09 f4       	brne	.+2      	; 0xe308 <GSM_Cycle+0x16ea>
    e306:	13 c3       	rjmp	.+1574   	; 0xe92e <GSM_Cycle+0x1d10>
						if( (GSM_RxStr[0]==0) && (GSM_RxStr[1]==0)){AppProtocol = _HTTP;GSM_State = GSM_ReStart1;break;}//  
    e308:	80 91 e1 07 	lds	r24, 0x07E1
    e30c:	88 23       	and	r24, r24
    e30e:	29 f4       	brne	.+10     	; 0xe31a <GSM_Cycle+0x16fc>
    e310:	80 91 e2 07 	lds	r24, 0x07E2
    e314:	88 23       	and	r24, r24
    e316:	09 f4       	brne	.+2      	; 0xe31a <GSM_Cycle+0x16fc>
    e318:	0a c3       	rjmp	.+1556   	; 0xe92e <GSM_Cycle+0x1d10>
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    e31a:	8f ef       	ldi	r24, 0xFF	; 255
    e31c:	80 93 3e 07 	sts	0x073E, r24
	GSM_RX_FIFO_End = 255;
    e320:	80 93 53 06 	sts	0x0653, r24
	GSM_RxCharN = 0;
    e324:	10 92 60 0b 	sts	0x0B60, r1
	GSM_RX_FIFOOverFlow = 0;
    e328:	10 92 13 09 	sts	0x0913, r1
	GSM_RX_FIFOMax = 0;
    e32c:	10 92 19 09 	sts	0x0919, r1
						StartTimer16(TD_CleanFIFO,500);
						//break;
					}
				}//while
				//GSM_RxCharN=0;
				if(Timer16Stopp(TD_CleanFIFO)&&(GSM_RX_FIFO_Begin == GSM_RX_FIFO_End)){
    e330:	80 91 ef 04 	lds	r24, 0x04EF
    e334:	0e 94 84 1f 	call	0x3f08	; 0x3f08 <Timer16Stopp>
    e338:	88 23       	and	r24, r24
    e33a:	b9 f0       	breq	.+46     	; 0xe36a <GSM_Cycle+0x174c>
    e33c:	90 91 3e 07 	lds	r25, 0x073E
    e340:	80 91 53 06 	lds	r24, 0x0653
    e344:	98 17       	cp	r25, r24
    e346:	89 f4       	brne	.+34     	; 0xe36a <GSM_Cycle+0x174c>
					StartTimer16(TD_CleanFIFO,500);
    e348:	80 91 ef 04 	lds	r24, 0x04EF
    e34c:	64 ef       	ldi	r22, 0xF4	; 244
    e34e:	71 e0       	ldi	r23, 0x01	; 1
    e350:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    e354:	8f ef       	ldi	r24, 0xFF	; 255
    e356:	80 93 3e 07 	sts	0x073E, r24
	GSM_RX_FIFO_End = 255;
    e35a:	80 93 53 06 	sts	0x0653, r24
	GSM_RxCharN = 0;
    e35e:	10 92 60 0b 	sts	0x0B60, r1
	GSM_RX_FIFOOverFlow = 0;
    e362:	10 92 13 09 	sts	0x0913, r1
	GSM_RX_FIFOMax = 0;
    e366:	10 92 19 09 	sts	0x0919, r1
				if(Timer16Stopp(TD_CleanFIFO)&&(GSM_RX_FIFO_Begin == GSM_RX_FIFO_End)){
					StartTimer16(TD_CleanFIFO,500);
					InitFIFO();
				}

				if(Timer16Stopp(TD_data_start_delay)){
    e36a:	80 91 f0 04 	lds	r24, 0x04F0
    e36e:	0e 94 84 1f 	call	0x3f08	; 0x3f08 <Timer16Stopp>
    e372:	88 23       	and	r24, r24
    e374:	11 f4       	brne	.+4      	; 0xe37a <GSM_Cycle+0x175c>
    e376:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
					if(GPRS_FlgSz_Out && (GPRS_FlgSz_Out <= GPRS_Out_MaxSz)&&(GSM_Flag&(1<<flg_TxCStr))&&Timer16Stopp(TD_timer_after_page_transfer)&&(!dataSendFlg)){			
    e37a:	80 91 b1 07 	lds	r24, 0x07B1
    e37e:	88 23       	and	r24, r24
    e380:	11 f4       	brne	.+4      	; 0xe386 <GSM_Cycle+0x1768>
    e382:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
    e386:	80 91 d2 02 	lds	r24, 0x02D2
    e38a:	80 fd       	sbrc	r24, 0
    e38c:	02 c0       	rjmp	.+4      	; 0xe392 <GSM_Cycle+0x1774>
    e38e:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
    e392:	80 91 f1 04 	lds	r24, 0x04F1
    e396:	0e 94 84 1f 	call	0x3f08	; 0x3f08 <Timer16Stopp>
    e39a:	88 23       	and	r24, r24
    e39c:	11 f4       	brne	.+4      	; 0xe3a2 <GSM_Cycle+0x1784>
    e39e:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
    e3a2:	80 91 df 02 	lds	r24, 0x02DF
    e3a6:	88 23       	and	r24, r24
    e3a8:	11 f0       	breq	.+4      	; 0xe3ae <GSM_Cycle+0x1790>
    e3aa:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
							dataSendFlg=1;
    e3ae:	81 e0       	ldi	r24, 0x01	; 1
    e3b0:	80 93 df 02 	sts	0x02DF, r24
							GSM_AddHeaderSendData(GPRS_Data_Out, GPRS_FlgSz_Out);
    e3b4:	86 e4       	ldi	r24, 0x46	; 70
    e3b6:	99 e0       	ldi	r25, 0x09	; 9
    e3b8:	60 91 b1 07 	lds	r22, 0x07B1
    e3bc:	0e 94 2d 44 	call	0x885a	; 0x885a <GSM_AddHeaderSendData>
    e3c0:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
		/*	if(Timer16Stopp(TD_TCP_Connect)){	//        CommandMode
				GSM_State = GSM_Swtch2CommandMode;
				break;
			}*/
			//StartTimer16(TD_CheckModem,1000);
			if( (strstr_P(GSM_RxStr, URC_CLOSED+2) != NULL) ){
    e3c4:	81 ee       	ldi	r24, 0xE1	; 225
    e3c6:	97 e0       	ldi	r25, 0x07	; 7
    e3c8:	64 ed       	ldi	r22, 0xD4	; 212
    e3ca:	73 e0       	ldi	r23, 0x03	; 3
    e3cc:	0e 94 58 84 	call	0x108b0	; 0x108b0 <strstr_P>
    e3d0:	89 2b       	or	r24, r25
    e3d2:	11 f4       	brne	.+4      	; 0xe3d8 <GSM_Cycle+0x17ba>
    e3d4:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
				GSM_State =GSM_ReStart1;
    e3d8:	8a e4       	ldi	r24, 0x4A	; 74
    e3da:	80 93 f6 06 	sts	0x06F6, r24
    e3de:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
			break;

		case GSM_SEND_CIPCSGP:
			//GSM_Execute_Command(AT_CIPCSGP, 300*GSM_DEBUG_DELAY); GSM_State++;
			if(GSM_Flag & (1<<flg_TxCStr)){
				sprintf_P(GSM_TxStr, AT_CIPCSGP);	GSMTxSz = strlen_P(AT_CIPCSGP);
    e3e2:	00 d0       	rcall	.+0      	; 0xe3e4 <GSM_Cycle+0x17c6>
    e3e4:	0f 92       	push	r0
    e3e6:	8a e4       	ldi	r24, 0x4A	; 74
    e3e8:	9a e0       	ldi	r25, 0x0A	; 10
    e3ea:	ad b7       	in	r26, 0x3d	; 61
    e3ec:	be b7       	in	r27, 0x3e	; 62
    e3ee:	12 96       	adiw	r26, 0x02	; 2
    e3f0:	9c 93       	st	X, r25
    e3f2:	8e 93       	st	-X, r24
    e3f4:	11 97       	sbiw	r26, 0x01	; 1
    e3f6:	08 e3       	ldi	r16, 0x38	; 56
    e3f8:	15 e0       	ldi	r17, 0x05	; 5
    e3fa:	14 96       	adiw	r26, 0x04	; 4
    e3fc:	1c 93       	st	X, r17
    e3fe:	0e 93       	st	-X, r16
    e400:	13 97       	sbiw	r26, 0x03	; 3
    e402:	0e 94 53 85 	call	0x10aa6	; 0x10aa6 <sprintf_P>
    e406:	0f 90       	pop	r0
    e408:	0f 90       	pop	r0
    e40a:	0f 90       	pop	r0
    e40c:	0f 90       	pop	r0
    e40e:	c8 01       	movw	r24, r16
    e410:	0e 94 36 84 	call	0x1086c	; 0x1086c <strlen_P>
    e414:	80 93 bb 07 	sts	0x07BB, r24
				#if LCDXSz==40
					GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn);
				#else
					GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn1);
    e418:	80 91 bb 07 	lds	r24, 0x07BB
    e41c:	90 e0       	ldi	r25, 0x00	; 0
    e41e:	86 5b       	subi	r24, 0xB6	; 182
    e420:	95 4f       	sbci	r25, 0xF5	; 245
    e422:	69 e0       	ldi	r22, 0x09	; 9
    e424:	70 e0       	ldi	r23, 0x00	; 0
    e426:	0e 94 ec 65 	call	0xcbd8	; 0xcbd8 <strcpy_EE>
    e42a:	90 91 bb 07 	lds	r25, 0x07BB
    e42e:	98 0f       	add	r25, r24
    e430:	90 93 bb 07 	sts	0x07BB, r25
					GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn2);
    e434:	80 91 bb 07 	lds	r24, 0x07BB
    e438:	90 e0       	ldi	r25, 0x00	; 0
    e43a:	86 5b       	subi	r24, 0xB6	; 182
    e43c:	95 4f       	sbci	r25, 0xF5	; 245
    e43e:	6d e1       	ldi	r22, 0x1D	; 29
    e440:	70 e0       	ldi	r23, 0x00	; 0
    e442:	0e 94 ec 65 	call	0xcbd8	; 0xcbd8 <strcpy_EE>
    e446:	90 91 bb 07 	lds	r25, 0x07BB
    e44a:	98 0f       	add	r25, r24
    e44c:	90 93 bb 07 	sts	0x07BB, r25
				#endif
				sprintf(GSM_TxStr + GSMTxSz, "\",\"");	GSMTxSz = GSMTxSz+3;				
    e450:	e0 91 bb 07 	lds	r30, 0x07BB
    e454:	f0 e0       	ldi	r31, 0x00	; 0
    e456:	e6 5b       	subi	r30, 0xB6	; 182
    e458:	f5 4f       	sbci	r31, 0xF5	; 245
    e45a:	a2 e2       	ldi	r26, 0x22	; 34
    e45c:	ea 2e       	mov	r14, r26
    e45e:	ac e2       	ldi	r26, 0x2C	; 44
    e460:	fa 2e       	mov	r15, r26
    e462:	a2 e2       	ldi	r26, 0x22	; 34
    e464:	0a 2f       	mov	r16, r26
    e466:	11 2d       	mov	r17, r1
    e468:	e0 82       	st	Z, r14
    e46a:	f1 82       	std	Z+1, r15	; 0x01
    e46c:	02 83       	std	Z+2, r16	; 0x02
    e46e:	13 83       	std	Z+3, r17	; 0x03
    e470:	80 91 bb 07 	lds	r24, 0x07BB
    e474:	8d 5f       	subi	r24, 0xFD	; 253
    e476:	80 93 bb 07 	sts	0x07BB, r24
				GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn_user_name);
    e47a:	80 91 bb 07 	lds	r24, 0x07BB
    e47e:	90 e0       	ldi	r25, 0x00	; 0
    e480:	86 5b       	subi	r24, 0xB6	; 182
    e482:	95 4f       	sbci	r25, 0xF5	; 245
    e484:	69 e5       	ldi	r22, 0x59	; 89
    e486:	70 e0       	ldi	r23, 0x00	; 0
    e488:	0e 94 ec 65 	call	0xcbd8	; 0xcbd8 <strcpy_EE>
    e48c:	90 91 bb 07 	lds	r25, 0x07BB
    e490:	98 0f       	add	r25, r24
    e492:	90 93 bb 07 	sts	0x07BB, r25
				sprintf(GSM_TxStr + GSMTxSz, "\",\"");	GSMTxSz = GSMTxSz+3;
    e496:	e0 91 bb 07 	lds	r30, 0x07BB
    e49a:	f0 e0       	ldi	r31, 0x00	; 0
    e49c:	e6 5b       	subi	r30, 0xB6	; 182
    e49e:	f5 4f       	sbci	r31, 0xF5	; 245
    e4a0:	e0 82       	st	Z, r14
    e4a2:	f1 82       	std	Z+1, r15	; 0x01
    e4a4:	02 83       	std	Z+2, r16	; 0x02
    e4a6:	13 83       	std	Z+3, r17	; 0x03
    e4a8:	80 91 bb 07 	lds	r24, 0x07BB
    e4ac:	8d 5f       	subi	r24, 0xFD	; 253
    e4ae:	80 93 bb 07 	sts	0x07BB, r24
				GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn_psw);
    e4b2:	80 91 bb 07 	lds	r24, 0x07BB
    e4b6:	90 e0       	ldi	r25, 0x00	; 0
    e4b8:	86 5b       	subi	r24, 0xB6	; 182
    e4ba:	95 4f       	sbci	r25, 0xF5	; 245
    e4bc:	6d e6       	ldi	r22, 0x6D	; 109
    e4be:	70 e0       	ldi	r23, 0x00	; 0
    e4c0:	0e 94 ec 65 	call	0xcbd8	; 0xcbd8 <strcpy_EE>
    e4c4:	90 91 bb 07 	lds	r25, 0x07BB
    e4c8:	98 0f       	add	r25, r24
    e4ca:	90 93 bb 07 	sts	0x07BB, r25
				sprintf(GSM_TxStr + GSMTxSz, "\"\r");	GSMTxSz = GSMTxSz+2;
    e4ce:	80 91 bb 07 	lds	r24, 0x07BB
    e4d2:	e8 2f       	mov	r30, r24
    e4d4:	f0 e0       	ldi	r31, 0x00	; 0
    e4d6:	e6 5b       	subi	r30, 0xB6	; 182
    e4d8:	f5 4f       	sbci	r31, 0xF5	; 245
    e4da:	a5 eb       	ldi	r26, 0xB5	; 181
    e4dc:	b2 e0       	ldi	r27, 0x02	; 2
    e4de:	83 e0       	ldi	r24, 0x03	; 3
    e4e0:	0d 90       	ld	r0, X+
    e4e2:	01 92       	st	Z+, r0
    e4e4:	81 50       	subi	r24, 0x01	; 1
    e4e6:	e1 f7       	brne	.-8      	; 0xe4e0 <GSM_Cycle+0x18c2>
    e4e8:	80 91 bb 07 	lds	r24, 0x07BB
    e4ec:	8e 5f       	subi	r24, 0xFE	; 254
    e4ee:	80 93 bb 07 	sts	0x07BB, r24
				GSM_SendFirstChar();
    e4f2:	0e 94 28 3d 	call	0x7a50	; 0x7a50 <GSM_SendFirstChar>
				StartTimer16(TD_GSM, 300*GSM_DEBUG_DELAY);
    e4f6:	80 91 e9 04 	lds	r24, 0x04E9
    e4fa:	6c e2       	ldi	r22, 0x2C	; 44
    e4fc:	71 e0       	ldi	r23, 0x01	; 1
    e4fe:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
    e502:	74 cc       	rjmp	.-1816   	; 0xddec <GSM_Cycle+0x11ce>
		case GSM_WAIT_CSQ:
				if(Timer16Stopp(TD_GSM)){
						GSM_State = GSM_ReStart1;
				}
				else{				
					if(GetStringFromFIFO()){
    e504:	0e 94 fe 3b 	call	0x77fc	; 0x77fc <GetStringFromFIFO>
    e508:	88 23       	and	r24, r24
    e50a:	11 f4       	brne	.+4      	; 0xe510 <GSM_Cycle+0x18f2>
    e50c:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
						GSM_RSSI = 255; GSM_BER = 255;
    e510:	8f ef       	ldi	r24, 0xFF	; 255
    e512:	80 93 b2 06 	sts	0x06B2, r24
    e516:	80 93 cb 07 	sts	0x07CB, r24
						if(strstr_P(GSM_RxStr, RESP_CSQ) != NULL ){
    e51a:	01 ee       	ldi	r16, 0xE1	; 225
    e51c:	17 e0       	ldi	r17, 0x07	; 7
    e51e:	c8 01       	movw	r24, r16
    e520:	63 e4       	ldi	r22, 0x43	; 67
    e522:	74 e0       	ldi	r23, 0x04	; 4
    e524:	0e 94 58 84 	call	0x108b0	; 0x108b0 <strstr_P>
    e528:	89 2b       	or	r24, r25
    e52a:	11 f4       	brne	.+4      	; 0xe530 <GSM_Cycle+0x1912>
    e52c:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
							sscanf_P(GSM_RxStr,PSTR("+CSQ: %hhu,%hhu"), (unsigned char*)&GSM_RSSI, (unsigned char*)&GSM_BER);
    e530:	ed b7       	in	r30, 0x3d	; 61
    e532:	fe b7       	in	r31, 0x3e	; 62
    e534:	38 97       	sbiw	r30, 0x08	; 8
    e536:	0f b6       	in	r0, 0x3f	; 63
    e538:	f8 94       	cli
    e53a:	fe bf       	out	0x3e, r31	; 62
    e53c:	0f be       	out	0x3f, r0	; 63
    e53e:	ed bf       	out	0x3d, r30	; 61
    e540:	31 96       	adiw	r30, 0x01	; 1
    e542:	ad b7       	in	r26, 0x3d	; 61
    e544:	be b7       	in	r27, 0x3e	; 62
    e546:	12 96       	adiw	r26, 0x02	; 2
    e548:	1c 93       	st	X, r17
    e54a:	0e 93       	st	-X, r16
    e54c:	11 97       	sbiw	r26, 0x01	; 1
    e54e:	81 e1       	ldi	r24, 0x11	; 17
    e550:	92 e3       	ldi	r25, 0x32	; 50
    e552:	93 83       	std	Z+3, r25	; 0x03
    e554:	82 83       	std	Z+2, r24	; 0x02
    e556:	82 eb       	ldi	r24, 0xB2	; 178
    e558:	96 e0       	ldi	r25, 0x06	; 6
    e55a:	95 83       	std	Z+5, r25	; 0x05
    e55c:	84 83       	std	Z+4, r24	; 0x04
    e55e:	8b ec       	ldi	r24, 0xCB	; 203
    e560:	97 e0       	ldi	r25, 0x07	; 7
    e562:	97 83       	std	Z+7, r25	; 0x07
    e564:	86 83       	std	Z+6, r24	; 0x06
    e566:	0e 94 a7 85 	call	0x10b4e	; 0x10b4e <sscanf_P>
									
								GSM_State = GSM_WAIT_CSQ_OK;
    e56a:	81 e5       	ldi	r24, 0x51	; 81
    e56c:	80 93 f6 06 	sts	0x06F6, r24
    e570:	ed b7       	in	r30, 0x3d	; 61
    e572:	fe b7       	in	r31, 0x3e	; 62
    e574:	38 96       	adiw	r30, 0x08	; 8
    e576:	0f b6       	in	r0, 0x3f	; 63
    e578:	f8 94       	cli
    e57a:	fe bf       	out	0x3e, r31	; 62
    e57c:	0f be       	out	0x3f, r0	; 63
    e57e:	ed bf       	out	0x3d, r30	; 61
    e580:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
				GSM_State = GSM_WAIT_MESSAGE;
			}
			break;
		case GSM_WAIT_CONFIRMRESPONSE:
			if(GetStringFromFIFO()){
					if((strstr_P(GSM_RxStr, PSTR("+DTMF: 1")) != NULL) ){
    e584:	81 ee       	ldi	r24, 0xE1	; 225
    e586:	97 e0       	ldi	r25, 0x07	; 7
    e588:	67 ef       	ldi	r22, 0xF7	; 247
    e58a:	72 e3       	ldi	r23, 0x32	; 50
    e58c:	0e 94 58 84 	call	0x108b0	; 0x108b0 <strstr_P>
    e590:	89 2b       	or	r24, r25
    e592:	49 f0       	breq	.+18     	; 0xe5a6 <GSM_Cycle+0x1988>
						StartTimer16(TD_GSM,1000);
    e594:	80 91 e9 04 	lds	r24, 0x04E9
    e598:	68 ee       	ldi	r22, 0xE8	; 232
    e59a:	73 e0       	ldi	r23, 0x03	; 3
    e59c:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
						GSM_State = GSM_SEND_PLAY_CONFIRM_FILE;
    e5a0:	8d e1       	ldi	r24, 0x1D	; 29
    e5a2:	80 93 f6 06 	sts	0x06F6, r24
						
					}
					if((strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 2,0,6")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 3,0,6")) != NULL) ){
    e5a6:	81 ee       	ldi	r24, 0xE1	; 225
    e5a8:	97 e0       	ldi	r25, 0x07	; 7
    e5aa:	6a ee       	ldi	r22, 0xEA	; 234
    e5ac:	72 e3       	ldi	r23, 0x32	; 50
    e5ae:	0e 94 58 84 	call	0x108b0	; 0x108b0 <strstr_P>
    e5b2:	89 2b       	or	r24, r25
    e5b4:	09 f4       	brne	.+2      	; 0xe5b8 <GSM_Cycle+0x199a>
    e5b6:	10 c1       	rjmp	.+544    	; 0xe7d8 <GSM_Cycle+0x1bba>
						StartTimer16(TD_GSM,2000);
    e5b8:	80 91 e9 04 	lds	r24, 0x04E9
    e5bc:	60 ed       	ldi	r22, 0xD0	; 208
    e5be:	77 e0       	ldi	r23, 0x07	; 7
    e5c0:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
						GSM_State = GSM_WAIT_DISCONNECT_CAUSE;
    e5c4:	85 e2       	ldi	r24, 0x25	; 37
    e5c6:	80 93 f6 06 	sts	0x06F6, r24
    e5ca:	0c 94 0e 6a 	jmp	0xd41c	; 0xd41c <GSM_Cycle+0x7fe>
			break;
		case GSM_WAIT_MESSAGE:
			
			if(Message[0]==1)
			{
				Message[0]=0;
    e5ce:	10 92 35 07 	sts	0x0735, r1
				ConfirmState=0;
				ConfirmState = 0;
    e5d2:	10 92 e1 02 	sts	0x02E1, r1
				TransmitterState = 1;
    e5d6:	80 93 e3 02 	sts	0x02E3, r24
				GSM_State = GSM_SEND_ATD;
    e5da:	8f e0       	ldi	r24, 0x0F	; 15
    e5dc:	80 93 f6 06 	sts	0x06F6, r24
    e5e0:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
			if(Timer16Stopp(TD_GSM)){
				if(RequestRepeatCounter<4){
				GSM_State = GSM_SEND_PLAY_ALARM_FILE;
				}
				else{
				GSM_State = GSM_SEND_PLAY_NOTCONFIRM_FILE;				
    e5e4:	80 e2       	ldi	r24, 0x20	; 32
    e5e6:	80 93 f6 06 	sts	0x06F6, r24
    e5ea:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
				if(++TempNum>=MaxTelephDirSz){
					GSM_State = GSM_Return2dataMode;
					SMS_FlgSz_Out = 0;
					//StartTimer16(TD_GSM,150);
				}
				else GSM_State = GSM_SEND_CMGS;
    e5ee:	80 e4       	ldi	r24, 0x40	; 64
    e5f0:	80 93 f6 06 	sts	0x06F6, r24
    e5f4:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
			}
			break;
		case GSM_WAIT_D2C_SWITCH_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) {

				switch(CommandModeDestination){
    e5f8:	84 30       	cpi	r24, 0x04	; 4
    e5fa:	79 f1       	breq	.+94     	; 0xe65a <GSM_Cycle+0x1a3c>
    e5fc:	85 30       	cpi	r24, 0x05	; 5
    e5fe:	11 f0       	breq	.+4      	; 0xe604 <GSM_Cycle+0x19e6>
    e600:	0c 94 3b 67 	jmp	0xce76	; 0xce76 <GSM_Cycle+0x258>
					case 4:	
						GSM_State = GSM_SEND_ATD_Check_Ballance;
						counter=0;	
						break;
					case 5:	
						GSM_State = GSM_SEND_CSQ;
    e604:	8f e4       	ldi	r24, 0x4F	; 79
    e606:	80 93 f6 06 	sts	0x06F6, r24
						counter=0;	
    e60a:	10 92 e0 02 	sts	0x02E0, r1
    e60e:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
			if(GSM_Wait_Response_P(URC_CPIN_READY, GSM_ReStart1)) GSM_State++;
			break;

		case GSM_WAIT_CALL_READY:
			if(GSM_Wait_Response_P(URC_CALL_READY, GSM_ReStart1)){
				if(GSM_Modem == SIMCOM_SIM800) GSM_State = GSM_WAIT_SMS_READY;
    e612:	87 e0       	ldi	r24, 0x07	; 7
    e614:	80 93 f6 06 	sts	0x06F6, r24
    e618:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
				}
			break;
		case GSM_WAIT_CSQ_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) {
				if(CommandModeDestination==5){
					GSM_State  = GSM_Return2dataMode;
    e61c:	87 e5       	ldi	r24, 0x57	; 87
    e61e:	80 93 f6 06 	sts	0x06F6, r24
    e622:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
			if(GetStringFromFIFO()){
				if(!strcmp_P(GSM_RxStr, GSM_SIMCOM_SIM900R)) GSM_Modem = SIMCOM_SIM900R;
				if(!strcmp_P(GSM_RxStr, GSM_SIMCOM_SIM800)) GSM_Modem = SIMCOM_SIM800;
				if(!strcmp_P(GSM_RxStr, GSM_SIMCOM_SIM800C)) GSM_Modem = SIMCOM_SIM800;
				//Add here new model GSM-modem
				if(GSM_Modem != NOT_RECOGNIZED) GSM_State = GSM_WAIT_CALL_READY;
    e626:	80 91 34 07 	lds	r24, 0x0734
    e62a:	88 23       	and	r24, r24
    e62c:	11 f4       	brne	.+4      	; 0xe632 <GSM_Cycle+0x1a14>
    e62e:	0c 94 ce 66 	jmp	0xcd9c	; 0xcd9c <GSM_Cycle+0x17e>
    e632:	0c 94 cb 66 	jmp	0xcd96	; 0xcd96 <GSM_Cycle+0x178>
			}
			GSM_State++;
			break;
		case GSM_WAIT_CIPCSGP_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
			 if(GSM_Modem == SIMCOM_SIM800)GSM_State++;
    e636:	80 91 f6 06 	lds	r24, 0x06F6
    e63a:	8f 5f       	subi	r24, 0xFF	; 255
    e63c:	80 93 f6 06 	sts	0x06F6, r24
    e640:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
			GSM_State++; 
			break;
		case GSM_WAIT_CIPMUX_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
				if(GSM_MultiCon){
					GSM_State = GSM_WAIT_1;
    e644:	8e e2       	ldi	r24, 0x2E	; 46
    e646:	80 93 f6 06 	sts	0x06F6, r24
					// between "Call Ready" and "+CMGS"; 8 sec min needs; for kyivstar vpni only
					StartTimer16(TD_GSM, 1000);
    e64a:	80 91 e9 04 	lds	r24, 0x04E9
    e64e:	68 ee       	ldi	r22, 0xE8	; 232
    e650:	73 e0       	ldi	r23, 0x03	; 3
    e652:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
    e656:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
					case 2:	
						GSM_State = GSM_CIPSHUT_;
						counter=0;	
						break;						
					case 4:	
						GSM_State = GSM_SEND_ATD_Check_Ballance;
    e65a:	8c e4       	ldi	r24, 0x4C	; 76
    e65c:	80 93 f6 06 	sts	0x06F6, r24
						counter=0;	
    e660:	10 92 e0 02 	sts	0x02E0, r1
    e664:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
				GSMTxSz = strlen(GSM_TxStr);
				uint8_t j=0;
				for(uint8_t i=0; i<GSMTxSz; i++)
					if(GSM_TxStr[i] != '0') j++;
				if(j){
					GSMTxSz = strlen_P(AT_CMGS);
    e668:	00 ef       	ldi	r16, 0xF0	; 240
    e66a:	14 e0       	ldi	r17, 0x04	; 4
    e66c:	c8 01       	movw	r24, r16
    e66e:	0e 94 36 84 	call	0x1086c	; 0x1086c <strlen_P>
    e672:	80 93 bb 07 	sts	0x07BB, r24
					sprintf_P(GSM_TxStr, AT_CMGS);
    e676:	00 d0       	rcall	.+0      	; 0xe678 <GSM_Cycle+0x1a5a>
    e678:	0f 92       	push	r0
    e67a:	ad b7       	in	r26, 0x3d	; 61
    e67c:	be b7       	in	r27, 0x3e	; 62
    e67e:	12 96       	adiw	r26, 0x02	; 2
    e680:	fc 92       	st	X, r15
    e682:	ee 92       	st	-X, r14
    e684:	11 97       	sbiw	r26, 0x01	; 1
    e686:	14 96       	adiw	r26, 0x04	; 4
    e688:	1c 93       	st	X, r17
    e68a:	0e 93       	st	-X, r16
    e68c:	13 97       	sbiw	r26, 0x03	; 3
    e68e:	0e 94 53 85 	call	0x10aa6	; 0x10aa6 <sprintf_P>
					erbl(GSM_TxStr+GSMTxSz, SMS_Number+TempNum, MaxTelephN);
    e692:	80 91 bb 07 	lds	r24, 0x07BB
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    e696:	0f 90       	pop	r0
    e698:	0f 90       	pop	r0
    e69a:	0f 90       	pop	r0
    e69c:	0f 90       	pop	r0
    e69e:	90 e0       	ldi	r25, 0x00	; 0
    e6a0:	60 91 dc 05 	lds	r22, 0x05DC
    e6a4:	2d e0       	ldi	r18, 0x0D	; 13
    e6a6:	62 9f       	mul	r22, r18
    e6a8:	b0 01       	movw	r22, r0
    e6aa:	11 24       	eor	r1, r1
    e6ac:	6b 53       	subi	r22, 0x3B	; 59
    e6ae:	7f 4f       	sbci	r23, 0xFF	; 255
    e6b0:	86 5b       	subi	r24, 0xB6	; 182
    e6b2:	95 4f       	sbci	r25, 0xF5	; 245
    e6b4:	4d e0       	ldi	r20, 0x0D	; 13
    e6b6:	50 e0       	ldi	r21, 0x00	; 0
    e6b8:	0e 94 40 87 	call	0x10e80	; 0x10e80 <__eerd_block_m2560>
					GSMTxSz = strlen(GSM_TxStr);
    e6bc:	f7 01       	movw	r30, r14
    e6be:	01 90       	ld	r0, Z+
    e6c0:	00 20       	and	r0, r0
    e6c2:	e9 f7       	brne	.-6      	; 0xe6be <GSM_Cycle+0x1aa0>
    e6c4:	31 97       	sbiw	r30, 0x01	; 1
    e6c6:	ea 54       	subi	r30, 0x4A	; 74
    e6c8:	fa 40       	sbci	r31, 0x0A	; 10
    e6ca:	e0 93 bb 07 	sts	0x07BB, r30
					sprintf(GSM_TxStr + GSMTxSz, "\"\r");
    e6ce:	80 91 bb 07 	lds	r24, 0x07BB
    e6d2:	e8 2f       	mov	r30, r24
    e6d4:	f0 e0       	ldi	r31, 0x00	; 0
    e6d6:	e6 5b       	subi	r30, 0xB6	; 182
    e6d8:	f5 4f       	sbci	r31, 0xF5	; 245
    e6da:	a5 eb       	ldi	r26, 0xB5	; 181
    e6dc:	b2 e0       	ldi	r27, 0x02	; 2
    e6de:	83 e0       	ldi	r24, 0x03	; 3
    e6e0:	0d 90       	ld	r0, X+
    e6e2:	01 92       	st	Z+, r0
    e6e4:	81 50       	subi	r24, 0x01	; 1
    e6e6:	e1 f7       	brne	.-8      	; 0xe6e0 <GSM_Cycle+0x1ac2>
					GSMTxSz = strlen(GSM_TxStr);
    e6e8:	f7 01       	movw	r30, r14
    e6ea:	01 90       	ld	r0, Z+
    e6ec:	00 20       	and	r0, r0
    e6ee:	e9 f7       	brne	.-6      	; 0xe6ea <GSM_Cycle+0x1acc>
    e6f0:	31 97       	sbiw	r30, 0x01	; 1
    e6f2:	ea 54       	subi	r30, 0x4A	; 74
    e6f4:	fa 40       	sbci	r31, 0x0A	; 10
    e6f6:	e0 93 bb 07 	sts	0x07BB, r30
					GSM_SendFirstChar();
    e6fa:	0e 94 28 3d 	call	0x7a50	; 0x7a50 <GSM_SendFirstChar>
					StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    e6fe:	80 91 e9 04 	lds	r24, 0x04E9
    e702:	64 ef       	ldi	r22, 0xF4	; 244
    e704:	71 e0       	ldi	r23, 0x01	; 1
    e706:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
					GSM_State++;
    e70a:	80 91 f6 06 	lds	r24, 0x06F6
    e70e:	8f 5f       	subi	r24, 0xFF	; 255
    e710:	80 93 f6 06 	sts	0x06F6, r24
    e714:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>

				switch(CommandModeDestination){
					case 1:	GSM_State = GSM_SEND_CMGS;
						break;
					case 2:	
						GSM_State = GSM_CIPSHUT_;
    e718:	84 e4       	ldi	r24, 0x44	; 68
    e71a:	80 93 f6 06 	sts	0x06F6, r24
						counter=0;	
    e71e:	10 92 e0 02 	sts	0x02E0, r1
    e722:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
			break;
		case GSM_WAIT_D2C_SWITCH_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) {

				switch(CommandModeDestination){
					case 1:	GSM_State = GSM_SEND_CMGS;
    e726:	80 e4       	ldi	r24, 0x40	; 64
    e728:	80 93 f6 06 	sts	0x06F6, r24
    e72c:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
				GSM_State = GSM_ProtocolMode;
				InitFIFO();
				break;
			}
*/			
			if( (strstr_P(GSM_RxStr, PSTR("OK")) != NULL) ){
    e730:	c8 01       	movw	r24, r16
    e732:	6e e2       	ldi	r22, 0x2E	; 46
    e734:	72 e3       	ldi	r23, 0x32	; 50
    e736:	0e 94 58 84 	call	0x108b0	; 0x108b0 <strstr_P>
    e73a:	89 2b       	or	r24, r25
    e73c:	09 f4       	brne	.+2      	; 0xe740 <GSM_Cycle+0x1b22>
    e73e:	88 c0       	rjmp	.+272    	; 0xe850 <GSM_Cycle+0x1c32>
				StartTimer16(TD_data_start_delay,100);
    e740:	80 91 f0 04 	lds	r24, 0x04F0
    e744:	64 e6       	ldi	r22, 0x64	; 100
    e746:	70 e0       	ldi	r23, 0x00	; 0
    e748:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
				GSM_State = GSM_ProtocolMode;
    e74c:	82 e5       	ldi	r24, 0x52	; 82
    e74e:	80 93 f6 06 	sts	0x06F6, r24
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    e752:	8f ef       	ldi	r24, 0xFF	; 255
    e754:	80 93 3e 07 	sts	0x073E, r24
	GSM_RX_FIFO_End = 255;
    e758:	80 93 53 06 	sts	0x0653, r24
	GSM_RxCharN = 0;
    e75c:	10 92 60 0b 	sts	0x0B60, r1
	GSM_RX_FIFOOverFlow = 0;
    e760:	10 92 13 09 	sts	0x0913, r1
	GSM_RX_FIFOMax = 0;
    e764:	10 92 19 09 	sts	0x0919, r1
    e768:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
				GSM_State = GSM_WAIT_MESSAGE;
			}
			break;
		case GSM_WAIT_CCLC_3:
			if(GetStringFromFIFO()){
				if( (strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 2,0,6,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 3,0,6,")) != NULL) ){
    e76c:	81 ee       	ldi	r24, 0xE1	; 225
    e76e:	97 e0       	ldi	r25, 0x07	; 7
    e770:	62 ef       	ldi	r22, 0xF2	; 242
    e772:	73 e3       	ldi	r23, 0x33	; 51
    e774:	0e 94 58 84 	call	0x108b0	; 0x108b0 <strstr_P>
    e778:	89 2b       	or	r24, r25
    e77a:	11 f0       	breq	.+4      	; 0xe780 <GSM_Cycle+0x1b62>
    e77c:	0c 94 9d 6a 	jmp	0xd53a	; 0xd53a <GSM_Cycle+0x91c>
    e780:	81 ee       	ldi	r24, 0xE1	; 225
    e782:	97 e0       	ldi	r25, 0x07	; 7
    e784:	64 ee       	ldi	r22, 0xE4	; 228
    e786:	73 e3       	ldi	r23, 0x33	; 51
    e788:	0e 94 58 84 	call	0x108b0	; 0x108b0 <strstr_P>
    e78c:	89 2b       	or	r24, r25
    e78e:	11 f0       	breq	.+4      	; 0xe794 <GSM_Cycle+0x1b76>
    e790:	0c 94 9d 6a 	jmp	0xd53a	; 0xd53a <GSM_Cycle+0x91c>
					StartTimer16(TD_GSM, 6000);
					GSM_State = GSM_WAIT_MESSAGE;
					break;
				}
				if( (strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,3,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 2,0,3,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 3,0,3,")) != NULL) ){
    e794:	81 ee       	ldi	r24, 0xE1	; 225
    e796:	97 e0       	ldi	r25, 0x07	; 7
    e798:	66 ed       	ldi	r22, 0xD6	; 214
    e79a:	73 e3       	ldi	r23, 0x33	; 51
    e79c:	0e 94 58 84 	call	0x108b0	; 0x108b0 <strstr_P>
    e7a0:	89 2b       	or	r24, r25
    e7a2:	09 f4       	brne	.+2      	; 0xe7a6 <GSM_Cycle+0x1b88>
    e7a4:	27 cd       	rjmp	.-1458   	; 0xe1f4 <GSM_Cycle+0x15d6>
					StartTimer16(TD_GSM, 6000);
    e7a6:	80 91 e9 04 	lds	r24, 0x04E9
    e7aa:	60 e7       	ldi	r22, 0x70	; 112
    e7ac:	77 e1       	ldi	r23, 0x17	; 23
    e7ae:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
					GSM_State = GSM_WAIT_CCLC_0;
    e7b2:	83 e1       	ldi	r24, 0x13	; 19
    e7b4:	80 93 f6 06 	sts	0x06F6, r24
    e7b8:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
				if((strstr_P(GSM_RxStr, PSTR("OK")) != NULL) ){
					GSM_State = GSM_WAIT_MESSAGE;

					break;
				}
				if((strstr_P(GSM_RxStr, PSTR("BUSY")) != NULL) ){
    e7bc:	81 ee       	ldi	r24, 0xE1	; 225
    e7be:	97 e0       	ldi	r25, 0x07	; 7
    e7c0:	60 e5       	ldi	r22, 0x50	; 80
    e7c2:	72 e3       	ldi	r23, 0x32	; 50
    e7c4:	0e 94 58 84 	call	0x108b0	; 0x108b0 <strstr_P>
    e7c8:	89 2b       	or	r24, r25
    e7ca:	09 f4       	brne	.+2      	; 0xe7ce <GSM_Cycle+0x1bb0>
    e7cc:	be c0       	rjmp	.+380    	; 0xe94a <GSM_Cycle+0x1d2c>
					GSM_State = GSM_WAIT_MESSAGE;
    e7ce:	8e e0       	ldi	r24, 0x0E	; 14
    e7d0:	80 93 f6 06 	sts	0x06F6, r24
    e7d4:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
					if((strstr_P(GSM_RxStr, PSTR("+DTMF: 1")) != NULL) ){
						StartTimer16(TD_GSM,1000);
						GSM_State = GSM_SEND_PLAY_CONFIRM_FILE;
						
					}
					if((strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 2,0,6")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 3,0,6")) != NULL) ){
    e7d8:	81 ee       	ldi	r24, 0xE1	; 225
    e7da:	97 e0       	ldi	r25, 0x07	; 7
    e7dc:	6d ed       	ldi	r22, 0xDD	; 221
    e7de:	72 e3       	ldi	r23, 0x32	; 50
    e7e0:	0e 94 58 84 	call	0x108b0	; 0x108b0 <strstr_P>
    e7e4:	89 2b       	or	r24, r25
    e7e6:	09 f0       	breq	.+2      	; 0xe7ea <GSM_Cycle+0x1bcc>
    e7e8:	e7 ce       	rjmp	.-562    	; 0xe5b8 <GSM_Cycle+0x199a>
    e7ea:	81 ee       	ldi	r24, 0xE1	; 225
    e7ec:	97 e0       	ldi	r25, 0x07	; 7
    e7ee:	60 ed       	ldi	r22, 0xD0	; 208
    e7f0:	72 e3       	ldi	r23, 0x32	; 50
    e7f2:	0e 94 58 84 	call	0x108b0	; 0x108b0 <strstr_P>
    e7f6:	89 2b       	or	r24, r25
    e7f8:	09 f0       	breq	.+2      	; 0xe7fc <GSM_Cycle+0x1bde>
    e7fa:	de ce       	rjmp	.-580    	; 0xe5b8 <GSM_Cycle+0x199a>
    e7fc:	0c 94 0e 6a 	jmp	0xd41c	; 0xd41c <GSM_Cycle+0x7fe>
				GSM_State = GSM_WAIT_MESSAGE;
			}
			break;
		case GSM_WAIT_CCLC_0:
			if(GetStringFromFIFO()){
				if((strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,0,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,0,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,0,")) != NULL) ){
    e800:	81 ee       	ldi	r24, 0xE1	; 225
    e802:	97 e0       	ldi	r25, 0x07	; 7
    e804:	6e e9       	ldi	r22, 0x9E	; 158
    e806:	73 e3       	ldi	r23, 0x33	; 51
    e808:	0e 94 58 84 	call	0x108b0	; 0x108b0 <strstr_P>
    e80c:	89 2b       	or	r24, r25
    e80e:	11 f0       	breq	.+4      	; 0xe814 <GSM_Cycle+0x1bf6>
    e810:	0c 94 40 6b 	jmp	0xd680	; 0xd680 <GSM_Cycle+0xa62>
    e814:	81 ee       	ldi	r24, 0xE1	; 225
    e816:	97 e0       	ldi	r25, 0x07	; 7
    e818:	60 e9       	ldi	r22, 0x90	; 144
    e81a:	73 e3       	ldi	r23, 0x33	; 51
    e81c:	0e 94 58 84 	call	0x108b0	; 0x108b0 <strstr_P>
    e820:	89 2b       	or	r24, r25
    e822:	11 f0       	breq	.+4      	; 0xe828 <GSM_Cycle+0x1c0a>
    e824:	0c 94 40 6b 	jmp	0xd680	; 0xd680 <GSM_Cycle+0xa62>
					RequestRepeatCounter = 0;
					GSM_State = GSM_SEND_PLAY_ALARM_FILE;
					break;
				}
				if( (strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6,")) != NULL)){
    e828:	81 ee       	ldi	r24, 0xE1	; 225
    e82a:	97 e0       	ldi	r25, 0x07	; 7
    e82c:	62 e8       	ldi	r22, 0x82	; 130
    e82e:	73 e3       	ldi	r23, 0x33	; 51
    e830:	0e 94 58 84 	call	0x108b0	; 0x108b0 <strstr_P>
    e834:	89 2b       	or	r24, r25
    e836:	09 f4       	brne	.+2      	; 0xe83a <GSM_Cycle+0x1c1c>
    e838:	fc cc       	rjmp	.-1544   	; 0xe232 <GSM_Cycle+0x1614>
					StartTimer16(TD_GSM, 6000);
    e83a:	80 91 e9 04 	lds	r24, 0x04E9
    e83e:	60 e7       	ldi	r22, 0x70	; 112
    e840:	77 e1       	ldi	r23, 0x17	; 23
    e842:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
					GSM_State = GSM_WAIT_DISCONNECT_CAUSE;
    e846:	85 e2       	ldi	r24, 0x25	; 37
    e848:	80 93 f6 06 	sts	0x06F6, r24
    e84c:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
				break;
			}


			//  
			if( (strstr_P(GSM_RxStr, URC_CONNECT) != NULL) ){
    e850:	c8 01       	movw	r24, r16
    e852:	60 ec       	ldi	r22, 0xC0	; 192
    e854:	73 e0       	ldi	r23, 0x03	; 3
    e856:	0e 94 58 84 	call	0x108b0	; 0x108b0 <strstr_P>
    e85a:	89 2b       	or	r24, r25
    e85c:	b1 f0       	breq	.+44     	; 0xe88a <GSM_Cycle+0x1c6c>

				GSM_State = GSM_ProtocolMode;
    e85e:	82 e5       	ldi	r24, 0x52	; 82
    e860:	80 93 f6 06 	sts	0x06F6, r24
    e864:	f8 01       	movw	r30, r16
				for(int i=0;i<GSM_RXSTR_SIZE;i++)
				{
					GSM_RxStr[i]=0;	
    e866:	11 92       	st	Z+, r1

			//  
			if( (strstr_P(GSM_RxStr, URC_CONNECT) != NULL) ){

				GSM_State = GSM_ProtocolMode;
				for(int i=0;i<GSM_RXSTR_SIZE;i++)
    e868:	38 e0       	ldi	r19, 0x08	; 8
    e86a:	e5 34       	cpi	r30, 0x45	; 69
    e86c:	f3 07       	cpc	r31, r19
    e86e:	d9 f7       	brne	.-10     	; 0xe866 <GSM_Cycle+0x1c48>
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    e870:	8f ef       	ldi	r24, 0xFF	; 255
    e872:	80 93 3e 07 	sts	0x073E, r24
	GSM_RX_FIFO_End = 255;
    e876:	80 93 53 06 	sts	0x0653, r24
	GSM_RxCharN = 0;
    e87a:	10 92 60 0b 	sts	0x0B60, r1
	GSM_RX_FIFOOverFlow = 0;
    e87e:	10 92 13 09 	sts	0x0913, r1
	GSM_RX_FIFOMax = 0;
    e882:	10 92 19 09 	sts	0x0919, r1
    e886:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>

				break;
			}

			//  
			if(strstr_P(GSM_RxStr, URC_CLOSED) != NULL){
    e88a:	c8 01       	movw	r24, r16
    e88c:	62 ed       	ldi	r22, 0xD2	; 210
    e88e:	73 e0       	ldi	r23, 0x03	; 3
    e890:	0e 94 58 84 	call	0x108b0	; 0x108b0 <strstr_P>
    e894:	89 2b       	or	r24, r25
    e896:	99 f1       	breq	.+102    	; 0xe8fe <GSM_Cycle+0x1ce0>
				//  
				sscanf_P(GSM_RxStr,PSTR("%hhu, CLOSED"),(unsigned char*)&TempNum);
    e898:	00 d0       	rcall	.+0      	; 0xe89a <GSM_Cycle+0x1c7c>
    e89a:	00 d0       	rcall	.+0      	; 0xe89c <GSM_Cycle+0x1c7e>
    e89c:	ed b7       	in	r30, 0x3d	; 61
    e89e:	fe b7       	in	r31, 0x3e	; 62
    e8a0:	31 96       	adiw	r30, 0x01	; 1
    e8a2:	ad b7       	in	r26, 0x3d	; 61
    e8a4:	be b7       	in	r27, 0x3e	; 62
    e8a6:	12 96       	adiw	r26, 0x02	; 2
    e8a8:	1c 93       	st	X, r17
    e8aa:	0e 93       	st	-X, r16
    e8ac:	11 97       	sbiw	r26, 0x01	; 1
    e8ae:	81 e2       	ldi	r24, 0x21	; 33
    e8b0:	92 e3       	ldi	r25, 0x32	; 50
    e8b2:	93 83       	std	Z+3, r25	; 0x03
    e8b4:	82 83       	std	Z+2, r24	; 0x02
    e8b6:	8c ed       	ldi	r24, 0xDC	; 220
    e8b8:	95 e0       	ldi	r25, 0x05	; 5
    e8ba:	95 83       	std	Z+5, r25	; 0x05
    e8bc:	84 83       	std	Z+4, r24	; 0x04
    e8be:	0e 94 a7 85 	call	0x10b4e	; 0x10b4e <sscanf_P>
				if(GSM_ActiveConnection == TempNum){
    e8c2:	ed b7       	in	r30, 0x3d	; 61
    e8c4:	fe b7       	in	r31, 0x3e	; 62
    e8c6:	36 96       	adiw	r30, 0x06	; 6
    e8c8:	0f b6       	in	r0, 0x3f	; 63
    e8ca:	f8 94       	cli
    e8cc:	fe bf       	out	0x3e, r31	; 62
    e8ce:	0f be       	out	0x3f, r0	; 63
    e8d0:	ed bf       	out	0x3d, r30	; 61
    e8d2:	90 91 d3 02 	lds	r25, 0x02D3
    e8d6:	80 91 dc 05 	lds	r24, 0x05DC
    e8da:	98 17       	cp	r25, r24
    e8dc:	59 f4       	brne	.+22     	; 0xe8f4 <GSM_Cycle+0x1cd6>
					GSM_ActiveConnection = NO_CONNECTION;
    e8de:	8f ef       	ldi	r24, 0xFF	; 255
    e8e0:	80 93 d3 02 	sts	0x02D3, r24
	uint8_t IP4;
} IP_Addr;

//~~~~~~~~~~~~~~
void SetIP(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	IP->IP1 = IP1;
    e8e4:	10 92 4a 0b 	sts	0x0B4A, r1
	IP->IP2 = IP2;
    e8e8:	10 92 4b 0b 	sts	0x0B4B, r1
	IP->IP3 = IP3;
    e8ec:	10 92 4c 0b 	sts	0x0B4C, r1
	IP->IP4 = IP4;
    e8f0:	10 92 4d 0b 	sts	0x0B4D, r1
					SetIP(&GSM_ClientIP,0,0,0,0);
				}

				GSM_State = GSM_ReStart1;
    e8f4:	8a e4       	ldi	r24, 0x4A	; 74
    e8f6:	80 93 f6 06 	sts	0x06F6, r24
    e8fa:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
				break;
			}

			// +PDP DEACT
			if( (strstr_P(GSM_RxStr, URC_PDPDEACT) != NULL) ){
    e8fe:	c8 01       	movw	r24, r16
    e900:	6b ed       	ldi	r22, 0xDB	; 219
    e902:	73 e0       	ldi	r23, 0x03	; 3
    e904:	0e 94 58 84 	call	0x108b0	; 0x108b0 <strstr_P>
    e908:	89 2b       	or	r24, r25
    e90a:	29 f0       	breq	.+10     	; 0xe916 <GSM_Cycle+0x1cf8>
				GSM_State = GSM_SEND_E0;
    e90c:	88 e0       	ldi	r24, 0x08	; 8
    e90e:	80 93 f6 06 	sts	0x06F6, r24
    e912:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
			}



			//      
			if(strstr_P(GSM_RxStr, RESP_CSQ) != NULL ){
    e916:	c8 01       	movw	r24, r16
    e918:	63 e4       	ldi	r22, 0x43	; 67
    e91a:	74 e0       	ldi	r23, 0x04	; 4
    e91c:	0e 94 58 84 	call	0x108b0	; 0x108b0 <strstr_P>
    e920:	89 2b       	or	r24, r25
    e922:	01 f1       	breq	.+64     	; 0xe964 <GSM_Cycle+0x1d46>
				GSM_State = GSM_WAIT_CSQ;
    e924:	80 e5       	ldi	r24, 0x50	; 80
    e926:	80 93 f6 06 	sts	0x06F6, r24
    e92a:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
						AppProtocol = 0;
						if(!strncmp_P(GSM_RxStr, PSTR("GET "), 4)) {AppProtocol = _HTTP;GSM_State = GSM_DataMode;break;}//GET
						if(!strncmp_P(GSM_RxStr, PSTR("POST"), 4)) {AppProtocol = _HTTP;GSM_State = GSM_DataMode;break;}//POST
						if(!strncmp_P(GSM_RxStr, PSTR("CLOS"), 4)) {AppProtocol = _HTTP;GSM_State = GSM_ReStart1;break;}// 
						if(!strncmp_P(GSM_RxStr, PSTR("+PDP"), 4)) {AppProtocol = _HTTP;GSM_State = GSM_ReStart1;break;}//GPRS 
						if( (GSM_RxStr[0]==0) && (GSM_RxStr[1]==0)){AppProtocol = _HTTP;GSM_State = GSM_ReStart1;break;}//  
    e92e:	81 e0       	ldi	r24, 0x01	; 1
    e930:	80 93 e7 08 	sts	0x08E7, r24
    e934:	8a e4       	ldi	r24, 0x4A	; 74
    e936:	80 93 f6 06 	sts	0x06F6, r24
    e93a:	fa cc       	rjmp	.-1548   	; 0xe330 <GSM_Cycle+0x1712>
							if(!strncmp_P(GSM_RxStr, PSTR("\r\n"), 2)) {GSM_RxCharN=0;}
						}
					if(GSM_RxCharN >= 4){
						AppProtocol = 0;
						if(!strncmp_P(GSM_RxStr, PSTR("GET "), 4)) {AppProtocol = _HTTP;GSM_State = GSM_DataMode;break;}//GET
						if(!strncmp_P(GSM_RxStr, PSTR("POST"), 4)) {AppProtocol = _HTTP;GSM_State = GSM_DataMode;break;}//POST
    e93c:	81 e0       	ldi	r24, 0x01	; 1
    e93e:	80 93 e7 08 	sts	0x08E7, r24
    e942:	83 e5       	ldi	r24, 0x53	; 83
    e944:	80 93 f6 06 	sts	0x06F6, r24
    e948:	f3 cc       	rjmp	.-1562   	; 0xe330 <GSM_Cycle+0x1712>
				if((strstr_P(GSM_RxStr, PSTR("BUSY")) != NULL) ){
					GSM_State = GSM_WAIT_MESSAGE;

					break;
				}
				if((strstr_P(GSM_RxStr, PSTR("NO CARRIER")) != NULL) ){
    e94a:	81 ee       	ldi	r24, 0xE1	; 225
    e94c:	97 e0       	ldi	r25, 0x07	; 7
    e94e:	65 e4       	ldi	r22, 0x45	; 69
    e950:	72 e3       	ldi	r23, 0x32	; 50
    e952:	0e 94 58 84 	call	0x108b0	; 0x108b0 <strstr_P>
    e956:	89 2b       	or	r24, r25
    e958:	51 f0       	breq	.+20     	; 0xe96e <GSM_Cycle+0x1d50>
					GSM_State = GSM_WAIT_MESSAGE;
    e95a:	8e e0       	ldi	r24, 0x0E	; 14
    e95c:	80 93 f6 06 	sts	0x06F6, r24
    e960:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
				GSM_State = GSM_WAIT_CSQ;
				break;
			}

			// 
			GSM_State = GSM_WAIT_IDENTIFICATION;
    e964:	8e e3       	ldi	r24, 0x3E	; 62
    e966:	80 93 f6 06 	sts	0x06F6, r24
    e96a:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>
				if((strstr_P(GSM_RxStr, PSTR("NO CARRIER")) != NULL) ){
					GSM_State = GSM_WAIT_MESSAGE;

					break;
				}
				GSM_State = GSM_WAIT_MESSAGE;
    e96e:	8e e0       	ldi	r24, 0x0E	; 14
    e970:	80 93 f6 06 	sts	0x06F6, r24
    e974:	0c 94 2f 66 	jmp	0xcc5e	; 0xcc5e <GSM_Cycle+0x40>

0000e978 <USART_Cycle>:

// ~~~~~~~~~~~~~~
void
USART_Cycle(void)
{
	MB_Cycle();
    e978:	0e 94 39 3b 	call	0x7672	; 0x7672 <MB_Cycle>
	#ifdef GSM
		GSM_Cycle();
    e97c:	0e 94 0f 66 	call	0xcc1e	; 0xcc1e <GSM_Cycle>
	#endif
	#ifdef UDP_EASY
		UDP_RxProcess();
	#endif
}
    e980:	08 95       	ret

0000e982 <IP_E_compare_Const>:
}
uint8_t IP_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	if((IP->IP1 == IP1) && (IP->IP2 == IP2) && (IP->IP3 == IP3) && (IP->IP4 == IP4)) return 1;
	else return 0;
}
uint8_t IP_E_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
    e982:	ef 92       	push	r14
    e984:	ff 92       	push	r15
    e986:	0f 93       	push	r16
    e988:	1f 93       	push	r17
    e98a:	cf 93       	push	r28
    e98c:	df 93       	push	r29
    e98e:	ec 01       	movw	r28, r24
    e990:	16 2f       	mov	r17, r22
    e992:	f4 2e       	mov	r15, r20
    e994:	e2 2e       	mov	r14, r18
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    e996:	0e 94 50 87 	call	0x10ea0	; 0x10ea0 <__eerd_byte_m2560>
	if((erb(&IP->IP1) == IP1) && (erb(&IP->IP2) == IP2) && (erb(&IP->IP3) == IP3) && (erb(&IP->IP4) == IP4)) return 1;
    e99a:	18 17       	cp	r17, r24
    e99c:	49 f0       	breq	.+18     	; 0xe9b0 <IP_E_compare_Const+0x2e>
	else return 0;
}
    e99e:	90 e0       	ldi	r25, 0x00	; 0
    e9a0:	89 2f       	mov	r24, r25
    e9a2:	df 91       	pop	r29
    e9a4:	cf 91       	pop	r28
    e9a6:	1f 91       	pop	r17
    e9a8:	0f 91       	pop	r16
    e9aa:	ff 90       	pop	r15
    e9ac:	ef 90       	pop	r14
    e9ae:	08 95       	ret
    e9b0:	ce 01       	movw	r24, r28
    e9b2:	01 96       	adiw	r24, 0x01	; 1
    e9b4:	0e 94 50 87 	call	0x10ea0	; 0x10ea0 <__eerd_byte_m2560>
uint8_t IP_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	if((IP->IP1 == IP1) && (IP->IP2 == IP2) && (IP->IP3 == IP3) && (IP->IP4 == IP4)) return 1;
	else return 0;
}
uint8_t IP_E_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	if((erb(&IP->IP1) == IP1) && (erb(&IP->IP2) == IP2) && (erb(&IP->IP3) == IP3) && (erb(&IP->IP4) == IP4)) return 1;
    e9b8:	f8 16       	cp	r15, r24
    e9ba:	89 f7       	brne	.-30     	; 0xe99e <IP_E_compare_Const+0x1c>
    e9bc:	ce 01       	movw	r24, r28
    e9be:	02 96       	adiw	r24, 0x02	; 2
    e9c0:	0e 94 50 87 	call	0x10ea0	; 0x10ea0 <__eerd_byte_m2560>
    e9c4:	e8 16       	cp	r14, r24
    e9c6:	59 f7       	brne	.-42     	; 0xe99e <IP_E_compare_Const+0x1c>
    e9c8:	ce 01       	movw	r24, r28
    e9ca:	03 96       	adiw	r24, 0x03	; 3
    e9cc:	0e 94 50 87 	call	0x10ea0	; 0x10ea0 <__eerd_byte_m2560>
    e9d0:	90 e0       	ldi	r25, 0x00	; 0
    e9d2:	08 13       	cpse	r16, r24
    e9d4:	91 e0       	ldi	r25, 0x01	; 1
    e9d6:	81 e0       	ldi	r24, 0x01	; 1
    e9d8:	98 27       	eor	r25, r24
    e9da:	e2 cf       	rjmp	.-60     	; 0xe9a0 <IP_E_compare_Const+0x1e>

0000e9dc <MB_M_Init>:
}

// ~~~~~~~~~~~~~~~~~~~~
void
MB_M_Init(uint8_t MB_N)
{
    e9dc:	cf 92       	push	r12
    e9de:	df 92       	push	r13
    e9e0:	ef 92       	push	r14
    e9e2:	ff 92       	push	r15
    e9e4:	0f 93       	push	r16
    e9e6:	1f 93       	push	r17
	MB_M_Period[MB_N]		= erw(&MB_M_Param_EE[MB_N].Period);
    e9e8:	e8 2e       	mov	r14, r24
    e9ea:	ff 24       	eor	r15, r15
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    e9ec:	87 01       	movw	r16, r14
    e9ee:	00 0f       	add	r16, r16
    e9f0:	11 1f       	adc	r17, r17
    e9f2:	00 0f       	add	r16, r16
    e9f4:	11 1f       	adc	r17, r17
    e9f6:	0e 0d       	add	r16, r14
    e9f8:	1f 1d       	adc	r17, r15
    e9fa:	32 e9       	ldi	r19, 0x92	; 146
    e9fc:	c3 2e       	mov	r12, r19
    e9fe:	31 e0       	ldi	r19, 0x01	; 1
    ea00:	d3 2e       	mov	r13, r19
    ea02:	c6 01       	movw	r24, r12
    ea04:	80 0f       	add	r24, r16
    ea06:	91 1f       	adc	r25, r17
    ea08:	0e 94 5e 87 	call	0x10ebc	; 0x10ebc <__eerd_word_m2560>
    ea0c:	f7 01       	movw	r30, r14
    ea0e:	ee 0f       	add	r30, r30
    ea10:	ff 1f       	adc	r31, r31
    ea12:	e3 55       	subi	r30, 0x53	; 83
    ea14:	f9 4f       	sbci	r31, 0xF9	; 249
    ea16:	91 83       	std	Z+1, r25	; 0x01
    ea18:	80 83       	st	Z, r24
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    ea1a:	0e 5f       	subi	r16, 0xFE	; 254
    ea1c:	1f 4f       	sbci	r17, 0xFF	; 255
    ea1e:	c6 01       	movw	r24, r12
    ea20:	80 0f       	add	r24, r16
    ea22:	91 1f       	adc	r25, r17
    ea24:	0e 94 50 87 	call	0x10ea0	; 0x10ea0 <__eerd_byte_m2560>
	MB_M_Timeout[MB_N]	= erb(&MB_M_Param_EE[MB_N].Timeout);
    ea28:	f7 01       	movw	r30, r14
    ea2a:	e7 5d       	subi	r30, 0xD7	; 215
    ea2c:	f6 4f       	sbci	r31, 0xF6	; 246
    ea2e:	80 83       	st	Z, r24
    ea30:	0f 5f       	subi	r16, 0xFF	; 255
    ea32:	1f 4f       	sbci	r17, 0xFF	; 255
    ea34:	c6 01       	movw	r24, r12
    ea36:	80 0f       	add	r24, r16
    ea38:	91 1f       	adc	r25, r17
    ea3a:	0e 94 50 87 	call	0x10ea0	; 0x10ea0 <__eerd_byte_m2560>
	MB_M_Try[MB_N]			= erb(&MB_M_Param_EE[MB_N].Try);
    ea3e:	f7 01       	movw	r30, r14
    ea40:	e1 5c       	subi	r30, 0xC1	; 193
    ea42:	f8 4f       	sbci	r31, 0xF8	; 248
    ea44:	80 83       	st	Z, r24
    ea46:	0f 5f       	subi	r16, 0xFF	; 255
    ea48:	1f 4f       	sbci	r17, 0xFF	; 255
    ea4a:	c6 01       	movw	r24, r12
    ea4c:	80 0f       	add	r24, r16
    ea4e:	91 1f       	adc	r25, r17
    ea50:	0e 94 50 87 	call	0x10ea0	; 0x10ea0 <__eerd_byte_m2560>
	MB_M_TimeOff[MB_N]	= erb(&MB_M_Param_EE[MB_N].TimeOff);
    ea54:	2f ed       	ldi	r18, 0xDF	; 223
    ea56:	35 e0       	ldi	r19, 0x05	; 5
    ea58:	e2 0e       	add	r14, r18
    ea5a:	f3 1e       	adc	r15, r19
    ea5c:	f7 01       	movw	r30, r14
    ea5e:	80 83       	st	Z, r24

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    ea60:	80 91 d0 02 	lds	r24, 0x02D0
	VacantTimer16Sys += n;
    ea64:	8d 5f       	subi	r24, 0xFD	; 253
    ea66:	80 93 d0 02 	sts	0x02D0, r24
    ea6a:	83 50       	subi	r24, 0x03	; 3

	TD_MB = Timer16SysAlloc(Modbus_Qt*3);
    ea6c:	80 93 e8 04 	sts	0x04E8, r24
}
    ea70:	1f 91       	pop	r17
    ea72:	0f 91       	pop	r16
    ea74:	ff 90       	pop	r15
    ea76:	ef 90       	pop	r14
    ea78:	df 90       	pop	r13
    ea7a:	cf 90       	pop	r12
    ea7c:	08 95       	ret

0000ea7e <MB_S_Init>:
}

// ~~~~~~~~~~~~~~~~~~~~
void
MB_S_Init(uint8_t MB_N)
{
    ea7e:	0f 93       	push	r16
    ea80:	1f 93       	push	r17
    ea82:	08 2f       	mov	r16, r24
    ea84:	10 e0       	ldi	r17, 0x00	; 0
    ea86:	c8 01       	movw	r24, r16
    ea88:	89 56       	subi	r24, 0x69	; 105
    ea8a:	9e 4f       	sbci	r25, 0xFE	; 254
    ea8c:	0e 94 50 87 	call	0x10ea0	; 0x10ea0 <__eerd_byte_m2560>
	#ifndef MB_ADDR_DIP_SW
		MB_NativeAddr[MB_N] = erb(MB_NativeAddr_EE+MB_N);
    ea90:	00 52       	subi	r16, 0x20	; 32
    ea92:	1a 4f       	sbci	r17, 0xFA	; 250
    ea94:	f8 01       	movw	r30, r16
    ea96:	80 83       	st	Z, r24
	#endif
}
    ea98:	1f 91       	pop	r17
    ea9a:	0f 91       	pop	r16
    ea9c:	08 95       	ret

0000ea9e <SetBAUD>:
}

// ~~~~~~~~~~~~~~~~~~
void
SetBAUD(uint8_t MB_N)
{
    ea9e:	ef 92       	push	r14
    eaa0:	ff 92       	push	r15
    eaa2:	0f 93       	push	r16
    eaa4:	1f 93       	push	r17
	BR_Val *ptrBR_Val = BR_Tbl + (MB_BitRate_RAM[MB_N] = erb(&MB_Param[MB_N].BitRate));
    eaa6:	08 2f       	mov	r16, r24
    eaa8:	10 e0       	ldi	r17, 0x00	; 0
    eaaa:	78 01       	movw	r14, r16
    eaac:	ee 0c       	add	r14, r14
    eaae:	ff 1c       	adc	r15, r15
    eab0:	e0 0e       	add	r14, r16
    eab2:	f1 1e       	adc	r15, r17
    eab4:	c7 01       	movw	r24, r14
    eab6:	8a 5f       	subi	r24, 0xFA	; 250
    eab8:	9f 4f       	sbci	r25, 0xFF	; 255
    eaba:	0e 94 50 87 	call	0x10ea0	; 0x10ea0 <__eerd_byte_m2560>
    eabe:	98 2f       	mov	r25, r24
    eac0:	f8 01       	movw	r30, r16
    eac2:	e3 53       	subi	r30, 0x33	; 51
    eac4:	f8 4f       	sbci	r31, 0xF8	; 248
    eac6:	80 83       	st	Z, r24
    eac8:	83 e0       	ldi	r24, 0x03	; 3
    eaca:	98 9f       	mul	r25, r24
    eacc:	b0 01       	movw	r22, r0
    eace:	11 24       	eor	r1, r1
    ead0:	60 5c       	subi	r22, 0xC0	; 192
    ead2:	7c 4f       	sbci	r23, 0xFC	; 252

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    ead4:	00 0f       	add	r16, r16
    ead6:	11 1f       	adc	r17, r17
    ead8:	00 0f       	add	r16, r16
    eada:	11 1f       	adc	r17, r17
    eadc:	c8 01       	movw	r24, r16
    eade:	88 0f       	add	r24, r24
    eae0:	99 1f       	adc	r25, r25
    eae2:	88 0f       	add	r24, r24
    eae4:	99 1f       	adc	r25, r25
    eae6:	80 0f       	add	r24, r16
    eae8:	91 1f       	adc	r25, r17
    eaea:	0a 96       	adiw	r24, 0x0a	; 10
    eaec:	48 e6       	ldi	r20, 0x68	; 104
    eaee:	54 e3       	ldi	r21, 0x34	; 52
    eaf0:	9a 01       	movw	r18, r20
    eaf2:	28 0f       	add	r18, r24
    eaf4:	39 1f       	adc	r19, r25
    eaf6:	f9 01       	movw	r30, r18
    eaf8:	a5 91       	lpm	r26, Z+
    eafa:	b4 91       	lpm	r27, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    eafc:	fb 01       	movw	r30, r22
    eafe:	24 91       	lpm	r18, Z+
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		USART_Reg(MB_N, ubrrl) = prb((uint8_t*)&ptrBR_Val->UBRR);
    eb00:	2c 93       	st	X, r18

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    eb02:	02 97       	sbiw	r24, 0x02	; 2
    eb04:	84 0f       	add	r24, r20
    eb06:	95 1f       	adc	r25, r21
    eb08:	fc 01       	movw	r30, r24
    eb0a:	a5 91       	lpm	r26, Z+
    eb0c:	b4 91       	lpm	r27, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    eb0e:	6f 5f       	subi	r22, 0xFF	; 255
    eb10:	7f 4f       	sbci	r23, 0xFF	; 255
    eb12:	fb 01       	movw	r30, r22
    eb14:	84 91       	lpm	r24, Z+
		USART_Reg(MB_N, ubrrh) = prb((uint8_t*)&ptrBR_Val->UBRR+1);
    eb16:	8c 93       	st	X, r24

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    eb18:	c7 01       	movw	r24, r14
    eb1a:	88 0f       	add	r24, r24
    eb1c:	99 1f       	adc	r25, r25
    eb1e:	81 58       	subi	r24, 0x81	; 129
    eb20:	9b 4c       	sbci	r25, 0xCB	; 203
    eb22:	fc 01       	movw	r30, r24
    eb24:	a5 91       	lpm	r26, Z+
    eb26:	b4 91       	lpm	r27, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    eb28:	6f 5f       	subi	r22, 0xFF	; 255
    eb2a:	7f 4f       	sbci	r23, 0xFF	; 255
    eb2c:	fb 01       	movw	r30, r22
    eb2e:	84 91       	lpm	r24, Z+

		*(uint8_t*)prp(&MB_Timer[MB_N].OCR) = prb(&ptrBR_Val->Time35);
    eb30:	8c 93       	st	X, r24
		usart->BAUDCTRLA = prb((uint8_t*)&ptrBR_Val->UBRR);
		usart->BAUDCTRLB = prb((uint8_t*)&ptrBR_Val->UBRR+1) + USART_BSCALE0_bm;

		((TC1_t*)prp(MB_Timer+MB_N))->PER = prw(&ptrBR_Val->Time35);
	#endif
}
    eb32:	1f 91       	pop	r17
    eb34:	0f 91       	pop	r16
    eb36:	ff 90       	pop	r15
    eb38:	ef 90       	pop	r14
    eb3a:	08 95       	ret

0000eb3c <Key_MB0_BitRate>:
	{" BAUD: }}}}}bps     ", NULL, F_MB##N##_Baud}																														\
};																																																					\
MenuPage MenuModbus##N = {SetMenu(L_MB##N), 1};

#if Modbus_Qt == 1
	M_Modbus(0)
    eb3c:	80 e0       	ldi	r24, 0x00	; 0
    eb3e:	0e 94 4f 75 	call	0xea9e	; 0xea9e <SetBAUD>
    eb42:	08 95       	ret

0000eb44 <SetParity>:
// ~~~

// ~~~~~~~~~~~~~~~~~~~~
void
SetParity(uint8_t MB_N)
{
    eb44:	ff 92       	push	r15
    eb46:	0f 93       	push	r16
    eb48:	1f 93       	push	r17
    eb4a:	cf 93       	push	r28
    eb4c:	df 93       	push	r29
	uint8_t Parity = erb(&MB_Param[MB_N].Parity), S_B = erb(&MB_Param[MB_N].StopBits);
    eb4e:	c8 2f       	mov	r28, r24
    eb50:	d0 e0       	ldi	r29, 0x00	; 0
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    eb52:	8e 01       	movw	r16, r28
    eb54:	00 0f       	add	r16, r16
    eb56:	11 1f       	adc	r17, r17
    eb58:	0c 0f       	add	r16, r28
    eb5a:	1d 1f       	adc	r17, r29
    eb5c:	c8 01       	movw	r24, r16
    eb5e:	8c 5f       	subi	r24, 0xFC	; 252
    eb60:	9f 4f       	sbci	r25, 0xFF	; 255
    eb62:	0e 94 50 87 	call	0x10ea0	; 0x10ea0 <__eerd_byte_m2560>
    eb66:	f8 2e       	mov	r15, r24
    eb68:	0b 5f       	subi	r16, 0xFB	; 251
    eb6a:	1f 4f       	sbci	r17, 0xFF	; 255
    eb6c:	c8 01       	movw	r24, r16
    eb6e:	0e 94 50 87 	call	0x10ea0	; 0x10ea0 <__eerd_byte_m2560>
    eb72:	48 2f       	mov	r20, r24
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		uint8_t ucsrc = (~(1<<6) |(1<<2) |(1<<1)) &~(1<<0);
		if (Parity==NoParity) {
    eb74:	ff 20       	and	r15, r15
    eb76:	e1 f4       	brne	.+56     	; 0xebb0 <SetParity+0x6c>
			ucsrc &=~(1<<5) &~(1<<4);
			switch (S_B) {
    eb78:	81 30       	cpi	r24, 0x01	; 1
    eb7a:	09 f4       	brne	.+2      	; 0xeb7e <SetParity+0x3a>
    eb7c:	3d c0       	rjmp	.+122    	; 0xebf8 <SetParity+0xb4>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    eb7e:	ce 01       	movw	r24, r28
    eb80:	88 0f       	add	r24, r24
    eb82:	99 1f       	adc	r25, r25
    eb84:	88 0f       	add	r24, r24
    eb86:	99 1f       	adc	r25, r25
    eb88:	9c 01       	movw	r18, r24
    eb8a:	22 0f       	add	r18, r18
    eb8c:	33 1f       	adc	r19, r19
    eb8e:	22 0f       	add	r18, r18
    eb90:	33 1f       	adc	r19, r19
    eb92:	28 0f       	add	r18, r24
    eb94:	39 1f       	adc	r19, r25
    eb96:	22 59       	subi	r18, 0x92	; 146
    eb98:	3b 4c       	sbci	r19, 0xCB	; 203
    eb9a:	f9 01       	movw	r30, r18
    eb9c:	a5 91       	lpm	r26, Z+
    eb9e:	b4 91       	lpm	r27, Z+
		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
			ucsrc  |=(1<<7);
		#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
			ucsrc &=~(1<<7);
		#endif
		USART_Reg(MB_N, ucsrc) = ucsrc;
    eba0:	8e e0       	ldi	r24, 0x0E	; 14
    eba2:	8c 93       	st	X, r24
			}
		}
	#endif
	if (Parity!=NoParity && S_B!=1)
		ewb(&MB_Param[MB_N].StopBits, 1);
}
    eba4:	df 91       	pop	r29
    eba6:	cf 91       	pop	r28
    eba8:	1f 91       	pop	r17
    ebaa:	0f 91       	pop	r16
    ebac:	ff 90       	pop	r15
    ebae:	08 95       	ret
				break;
			}
		}
		else {
			ucsrc &=~(1<<3);
			switch (Parity) {
    ebb0:	81 e0       	ldi	r24, 0x01	; 1
    ebb2:	f8 16       	cp	r15, r24
    ebb4:	f9 f0       	breq	.+62     	; 0xebf4 <SetParity+0xb0>
			}
		}
	#endif
	if (Parity!=NoParity && S_B!=1)
		ewb(&MB_Param[MB_N].StopBits, 1);
}
    ebb6:	56 e3       	ldi	r21, 0x36	; 54
    ebb8:	ce 01       	movw	r24, r28
    ebba:	88 0f       	add	r24, r24
    ebbc:	99 1f       	adc	r25, r25
    ebbe:	88 0f       	add	r24, r24
    ebc0:	99 1f       	adc	r25, r25
    ebc2:	9c 01       	movw	r18, r24
    ebc4:	22 0f       	add	r18, r18
    ebc6:	33 1f       	adc	r19, r19
    ebc8:	22 0f       	add	r18, r18
    ebca:	33 1f       	adc	r19, r19
    ebcc:	28 0f       	add	r18, r24
    ebce:	39 1f       	adc	r19, r25
    ebd0:	22 59       	subi	r18, 0x92	; 146
    ebd2:	3b 4c       	sbci	r19, 0xCB	; 203
    ebd4:	f9 01       	movw	r30, r18
    ebd6:	a5 91       	lpm	r26, Z+
    ebd8:	b4 91       	lpm	r27, Z+
		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
			ucsrc  |=(1<<7);
		#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
			ucsrc &=~(1<<7);
		#endif
		USART_Reg(MB_N, ucsrc) = ucsrc;
    ebda:	5c 93       	st	X, r21
				usart->CTRLC |=USART_PMODE_ODD_gc;
				break;
			}
		}
	#endif
	if (Parity!=NoParity && S_B!=1)
    ebdc:	41 30       	cpi	r20, 0x01	; 1
    ebde:	21 f0       	breq	.+8      	; 0xebe8 <SetParity+0xa4>
		ewb(&MB_Param[MB_N].StopBits, 1);
    ebe0:	c8 01       	movw	r24, r16
    ebe2:	61 e0       	ldi	r22, 0x01	; 1
    ebe4:	0e 94 c9 4f 	call	0x9f92	; 0x9f92 <ewb>
}
    ebe8:	df 91       	pop	r29
    ebea:	cf 91       	pop	r28
    ebec:	1f 91       	pop	r17
    ebee:	0f 91       	pop	r16
    ebf0:	ff 90       	pop	r15
    ebf2:	08 95       	ret
				break;
			}
		}
		else {
			ucsrc &=~(1<<3);
			switch (Parity) {
    ebf4:	56 e2       	ldi	r21, 0x26	; 38
    ebf6:	e0 cf       	rjmp	.-64     	; 0xebb8 <SetParity+0x74>
    ebf8:	ce 01       	movw	r24, r28
    ebfa:	88 0f       	add	r24, r24
    ebfc:	99 1f       	adc	r25, r25
    ebfe:	88 0f       	add	r24, r24
    ec00:	99 1f       	adc	r25, r25
    ec02:	9c 01       	movw	r18, r24
    ec04:	22 0f       	add	r18, r18
    ec06:	33 1f       	adc	r19, r19
    ec08:	22 0f       	add	r18, r18
    ec0a:	33 1f       	adc	r19, r19
    ec0c:	28 0f       	add	r18, r24
    ec0e:	39 1f       	adc	r19, r25
    ec10:	22 59       	subi	r18, 0x92	; 146
    ec12:	3b 4c       	sbci	r19, 0xCB	; 203
    ec14:	f9 01       	movw	r30, r18
    ec16:	a5 91       	lpm	r26, Z+
    ec18:	b4 91       	lpm	r27, Z+
		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
			ucsrc  |=(1<<7);
		#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
			ucsrc &=~(1<<7);
		#endif
		USART_Reg(MB_N, ucsrc) = ucsrc;
    ec1a:	86 e0       	ldi	r24, 0x06	; 6
    ec1c:	8c 93       	st	X, r24
			}
		}
	#endif
	if (Parity!=NoParity && S_B!=1)
		ewb(&MB_Param[MB_N].StopBits, 1);
}
    ec1e:	df 91       	pop	r29
    ec20:	cf 91       	pop	r28
    ec22:	1f 91       	pop	r17
    ec24:	0f 91       	pop	r16
    ec26:	ff 90       	pop	r15
    ec28:	08 95       	ret

0000ec2a <Key_MB0_Parity>:
    ec2a:	80 e0       	ldi	r24, 0x00	; 0
    ec2c:	0e 94 a2 75 	call	0xeb44	; 0xeb44 <SetParity>
    ec30:	08 95       	ret

0000ec32 <MB_Init>:

// ~~~~~~~~~~
void
MB_Init(void)
{
	MB_PLC_Init();
    ec32:	0e 94 72 21 	call	0x42e4	; 0x42e4 <MB_PLC_Init>
		PORTE.DIR |=(1<<3);
	#endif
	for (uint8_t MB_N=0; MB_N<Modbus_Qt; MB_N++) {
		void MB_S_Init(uint8_t);
		void MB_M_Init(uint8_t);
		MB_State[MB_N] = MB_Initi;
    ec36:	10 92 c2 05 	sts	0x05C2, r1
    ec3a:	8a e6       	ldi	r24, 0x6A	; 106
    ec3c:	94 e3       	ldi	r25, 0x34	; 52
    ec3e:	fc 01       	movw	r30, r24
    ec40:	a5 91       	lpm	r26, Z+
    ec42:	b4 91       	lpm	r27, Z+
		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
			USART_Reg(MB_N, ucsra) = ~(1<<1) &~(1<<0);
    ec44:	8c ef       	ldi	r24, 0xFC	; 252
    ec46:	8c 93       	st	X, r24
    ec48:	8c e6       	ldi	r24, 0x6C	; 108
    ec4a:	94 e3       	ldi	r25, 0x34	; 52
    ec4c:	fc 01       	movw	r30, r24
    ec4e:	a5 91       	lpm	r26, Z+
    ec50:	b4 91       	lpm	r27, Z+
			USART_Reg(MB_N, ucsrb) = (((1<<7) &~(1<<6) &~(1<<5)) |(1<<4) |(1<<3)) &~(1<<2);
    ec52:	88 e9       	ldi	r24, 0x98	; 152
    ec54:	8c 93       	st	X, r24
			tc->CTRLD = TC_EVACT_OFF_gc;
			//tc->CTRLE = TC1_BYTEM_bm;
			tc->INTCTRLA |=TC_ERRINTLVL_OFF_gc;
			tc->INTCTRLB = 0;
		#endif
		SetParity(MB_N);
    ec56:	80 e0       	ldi	r24, 0x00	; 0
    ec58:	0e 94 a2 75 	call	0xeb44	; 0xeb44 <SetParity>
		SetBAUD(MB_N);
    ec5c:	80 e0       	ldi	r24, 0x00	; 0
    ec5e:	0e 94 4f 75 	call	0xea9e	; 0xea9e <SetBAUD>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    ec62:	ec e7       	ldi	r30, 0x7C	; 124
    ec64:	f4 e3       	ldi	r31, 0x34	; 52
    ec66:	84 91       	lpm	r24, Z+
		switch (prb(MB_Role+MB_N)) {
    ec68:	88 23       	and	r24, r24
    ec6a:	59 f4       	brne	.+22     	; 0xec82 <MB_Init+0x50>
		case Role_Slave:
			MB_S_Init(MB_N);
    ec6c:	80 e0       	ldi	r24, 0x00	; 0
    ec6e:	0e 94 3f 75 	call	0xea7e	; 0xea7e <MB_S_Init>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    ec72:	81 e8       	ldi	r24, 0x81	; 129
    ec74:	94 e3       	ldi	r25, 0x34	; 52
    ec76:	fc 01       	movw	r30, r24
    ec78:	25 91       	lpm	r18, Z+
    ec7a:	34 91       	lpm	r19, Z+
			break;
		case Role_Master:
			MB_M_Init(MB_N);
			break;
		}
		MB_StartTimer(MB_N);
    ec7c:	f9 01       	movw	r30, r18
    ec7e:	19 95       	eicall
	}
}
    ec80:	08 95       	ret
			tc->INTCTRLA |=TC_ERRINTLVL_OFF_gc;
			tc->INTCTRLB = 0;
		#endif
		SetParity(MB_N);
		SetBAUD(MB_N);
		switch (prb(MB_Role+MB_N)) {
    ec82:	81 30       	cpi	r24, 0x01	; 1
    ec84:	b1 f7       	brne	.-20     	; 0xec72 <MB_Init+0x40>
		case Role_Slave:
			MB_S_Init(MB_N);
			break;
		case Role_Master:
			MB_M_Init(MB_N);
    ec86:	80 e0       	ldi	r24, 0x00	; 0
    ec88:	0e 94 ee 74 	call	0xe9dc	; 0xe9dc <MB_M_Init>
    ec8c:	f2 cf       	rjmp	.-28     	; 0xec72 <MB_Init+0x40>

0000ec8e <USART_Init>:

// ~~~~~~~~~~~~~
void
USART_Init(void)
{
	MB_Init();
    ec8e:	0e 94 19 76 	call	0xec32	; 0xec32 <MB_Init>
	#ifdef GSM
		GSM_Init();
    ec92:	0e 94 90 3c 	call	0x7920	; 0x7920 <GSM_Init>
	#endif
	#ifdef UDP_EASY
		UDP_Init();
	#endif
}
    ec96:	08 95       	ret

0000ec98 <LCDBackLightStartTimer>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    ec98:	81 e9       	ldi	r24, 0x91	; 145
    ec9a:	91 e0       	ldi	r25, 0x01	; 1
    ec9c:	0e 94 50 87 	call	0x10ea0	; 0x10ea0 <__eerd_byte_m2560>
			PORT_BACKLIGHT &= ~BACKLIGHT;
		#endif
		IntOn();
	}
	void LCDBackLightStartTimer(void){
		switch(erb(&BackLightTimeEE)){
    eca0:	82 30       	cpi	r24, 0x02	; 2
    eca2:	e9 f0       	breq	.+58     	; 0xecde <LCDBackLightStartTimer+0x46>
    eca4:	83 30       	cpi	r24, 0x03	; 3
    eca6:	58 f0       	brcs	.+22     	; 0xecbe <LCDBackLightStartTimer+0x26>
    eca8:	83 30       	cpi	r24, 0x03	; 3
    ecaa:	01 f1       	breq	.+64     	; 0xecec <LCDBackLightStartTimer+0x54>
    ecac:	84 30       	cpi	r24, 0x04	; 4
    ecae:	81 f0       	breq	.+32     	; 0xecd0 <LCDBackLightStartTimer+0x38>
				break;	
			case BCKLT_10min:
				StartTimer16(TD_BackLight, 60000);
				break;
			default:
				StartTimer16(TD_BackLight, 3000);
    ecb0:	80 91 d8 04 	lds	r24, 0x04D8
    ecb4:	68 eb       	ldi	r22, 0xB8	; 184
    ecb6:	7b e0       	ldi	r23, 0x0B	; 11
    ecb8:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
    ecbc:	08 95       	ret
			PORT_BACKLIGHT &= ~BACKLIGHT;
		#endif
		IntOn();
	}
	void LCDBackLightStartTimer(void){
		switch(erb(&BackLightTimeEE)){
    ecbe:	88 23       	and	r24, r24
    ecc0:	b9 f7       	brne	.-18     	; 0xecb0 <LCDBackLightStartTimer+0x18>
			case BCKLT_10sec:
				StartTimer16(TD_BackLight, 1000);
    ecc2:	80 91 d8 04 	lds	r24, 0x04D8
    ecc6:	68 ee       	ldi	r22, 0xE8	; 232
    ecc8:	73 e0       	ldi	r23, 0x03	; 3
    ecca:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
    ecce:	08 95       	ret
				break;
			case BCKLT_3min:
				StartTimer16(TD_BackLight, 18000);
				break;	
			case BCKLT_10min:
				StartTimer16(TD_BackLight, 60000);
    ecd0:	80 91 d8 04 	lds	r24, 0x04D8
    ecd4:	60 e6       	ldi	r22, 0x60	; 96
    ecd6:	7a ee       	ldi	r23, 0xEA	; 234
    ecd8:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
    ecdc:	08 95       	ret
				break;
			case BCKLT_30sec:
				StartTimer16(TD_BackLight, 3000);
				break;
			case BCKLT_1min:
				StartTimer16(TD_BackLight, 6000);
    ecde:	80 91 d8 04 	lds	r24, 0x04D8
    ece2:	60 e7       	ldi	r22, 0x70	; 112
    ece4:	77 e1       	ldi	r23, 0x17	; 23
    ece6:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
    ecea:	08 95       	ret
				break;
			case BCKLT_3min:
				StartTimer16(TD_BackLight, 18000);
    ecec:	80 91 d8 04 	lds	r24, 0x04D8
    ecf0:	60 e5       	ldi	r22, 0x50	; 80
    ecf2:	76 e4       	ldi	r23, 0x46	; 70
    ecf4:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
    ecf8:	08 95       	ret

0000ecfa <LCDBackLightInit>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    ecfa:	9f b7       	in	r25, 0x3f	; 63
    ecfc:	90 78       	andi	r25, 0x80	; 128
    ecfe:	90 93 ee 02 	sts	0x02EE, r25
	cli();
    ed02:	f8 94       	cli
	enum BACKLIGHT_TIMES{ BCKLT_10sec, BCKLT_30sec, BCKLT_1min,  BCKLT_3min,  BCKLT_10min};
	static uint8_t EEMEM BackLightTimeEE = BCKLT_10sec;

	void LCDBackLightInit(void){
		IntOff();	
		DDR_BACKLIGHT |= BACKLIGHT;
    ed04:	80 91 0a 01 	lds	r24, 0x010A
    ed08:	80 64       	ori	r24, 0x40	; 64
    ed0a:	80 93 0a 01 	sts	0x010A, r24

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    ed0e:	99 23       	and	r25, r25
    ed10:	09 f0       	breq	.+2      	; 0xed14 <LCDBackLightInit+0x1a>
		sei();
    ed12:	78 94       	sei

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    ed14:	80 91 d0 02 	lds	r24, 0x02D0
	VacantTimer16Sys += n;
    ed18:	8f 5f       	subi	r24, 0xFF	; 255
    ed1a:	80 93 d0 02 	sts	0x02D0, r24
    ed1e:	81 50       	subi	r24, 0x01	; 1
		IntOn();	
		TD_BackLight = Timer16SysAlloc(1);
    ed20:	80 93 d8 04 	sts	0x04D8, r24
		if(BackLightMode != 2){
    ed24:	80 91 52 06 	lds	r24, 0x0652
    ed28:	82 30       	cpi	r24, 0x02	; 2
    ed2a:	21 f0       	breq	.+8      	; 0xed34 <LCDBackLightInit+0x3a>
			LCDBackLightOn();
    ed2c:	0e 94 52 2b 	call	0x56a4	; 0x56a4 <LCDBackLightOn>
			LCDBackLightStartTimer();
    ed30:	0e 94 4c 76 	call	0xec98	; 0xec98 <LCDBackLightStartTimer>
    ed34:	08 95       	ret

0000ed36 <LCD_Init>:
}

// ~~~~~~~~~~~~
void
LCD_Init (void)
{
    ed36:	ef 92       	push	r14
    ed38:	ff 92       	push	r15
    ed3a:	1f 93       	push	r17
    ed3c:	cf 93       	push	r28
    ed3e:	df 93       	push	r29
	uint8_t i, j;

	// LCD pins
	#ifdef Port_LCD_RW
		Port_LCD_RW &= ~LCD_RW;
    ed40:	43 98       	cbi	0x08, 3	; 8
		DDR_LCD_RW |= LCD_RW;
    ed42:	3b 9a       	sbi	0x07, 3	; 7
	#endif

	Port_LCD_RS &= ~LCD_RS;	
    ed44:	44 98       	cbi	0x08, 4	; 8
	DDR_LCD_RS |=LCD_RS;
    ed46:	3c 9a       	sbi	0x07, 4	; 7

	Port_LCD_E &= ~LCD_E;	
    ed48:	42 98       	cbi	0x08, 2	; 8
	DDR_LCD_E |=LCD_E;
    ed4a:	3a 9a       	sbi	0x07, 2	; 7

	#ifdef Port_LCD_DB0	
		DDR_LCD_DB0 |=DB0;
    ed4c:	39 9a       	sbi	0x07, 1	; 7
		DDR_LCD_DB1 |=DB1;
    ed4e:	38 9a       	sbi	0x07, 0	; 7
		DDR_LCD_DB2 |=DB2;
    ed50:	99 9a       	sbi	0x13, 1	; 19
		DDR_LCD_DB3 |=DB3;
    ed52:	98 9a       	sbi	0x13, 0	; 19
	#endif
	DDR_LCD_DB4 |=DB4;
    ed54:	57 9a       	sbi	0x0a, 7	; 10
	DDR_LCD_DB5 |=DB5;
    ed56:	56 9a       	sbi	0x0a, 6	; 10
	DDR_LCD_DB6 |=DB6;
    ed58:	55 9a       	sbi	0x0a, 5	; 10
	DDR_LCD_DB7 |=DB7;
    ed5a:	80 91 0a 01 	lds	r24, 0x010A
    ed5e:	80 68       	ori	r24, 0x80	; 128
    ed60:	80 93 0a 01 	sts	0x010A, r24
    ed64:	21 e3       	ldi	r18, 0x31	; 49
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    ed66:	40 ea       	ldi	r20, 0xA0	; 160
    ed68:	5f e0       	ldi	r21, 0x0F	; 15
    ed6a:	ca 01       	movw	r24, r20
    ed6c:	01 97       	sbiw	r24, 0x01	; 1
    ed6e:	f1 f7       	brne	.-4      	; 0xed6c <LCD_Init+0x36>

// ~~~~~~~~~~~~~~~~~~~~
void
Delay_ms(uint8_t Delay)
{
	while (Delay--)
    ed70:	21 50       	subi	r18, 0x01	; 1
    ed72:	d8 f7       	brcc	.-10     	; 0xed6a <LCD_Init+0x34>
#endif
// ~~~~~~~~~~~
static void
LCD_Rst0(void)
{
	cli();
    ed74:	f8 94       	cli
	Port_LCD_RS &=~LCD_RS;
    ed76:	44 98       	cbi	0x08, 4	; 8
	LCD_FuncSet0();
    ed78:	0e 94 ac 29 	call	0x5358	; 0x5358 <LCD_FuncSet0>
	sei();
    ed7c:	78 94       	sei
    ed7e:	80 ea       	ldi	r24, 0xA0	; 160
    ed80:	9f e0       	ldi	r25, 0x0F	; 15
    ed82:	fc 01       	movw	r30, r24
    ed84:	31 97       	sbiw	r30, 0x01	; 1
    ed86:	f1 f7       	brne	.-4      	; 0xed84 <LCD_Init+0x4e>
    ed88:	fc 01       	movw	r30, r24
    ed8a:	31 97       	sbiw	r30, 0x01	; 1
    ed8c:	f1 f7       	brne	.-4      	; 0xed8a <LCD_Init+0x54>
    ed8e:	fc 01       	movw	r30, r24
    ed90:	31 97       	sbiw	r30, 0x01	; 1
    ed92:	f1 f7       	brne	.-4      	; 0xed90 <LCD_Init+0x5a>
    ed94:	fc 01       	movw	r30, r24
    ed96:	31 97       	sbiw	r30, 0x01	; 1
    ed98:	f1 f7       	brne	.-4      	; 0xed96 <LCD_Init+0x60>
    ed9a:	01 97       	sbiw	r24, 0x01	; 1
    ed9c:	f1 f7       	brne	.-4      	; 0xed9a <LCD_Init+0x64>

// ~~~~~~~~~~~
static void
LCD_Rst1(void)
{
	LCD_FuncSet0();
    ed9e:	0e 94 ac 29 	call	0x5358	; 0x5358 <LCD_FuncSet0>
	Delay_us(200);				// 100 us needs
    eda2:	88 ec       	ldi	r24, 0xC8	; 200
    eda4:	90 e0       	ldi	r25, 0x00	; 0
    eda6:	0e 94 5a 21 	call	0x42b4	; 0x42b4 <Delay_us>
	LCD_FuncSet0();
    edaa:	0e 94 ac 29 	call	0x5358	; 0x5358 <LCD_FuncSet0>
	Delay_us(LCD_Delay);
    edae:	82 e3       	ldi	r24, 0x32	; 50
    edb0:	90 e0       	ldi	r25, 0x00	; 0
    edb2:	0e 94 5a 21 	call	0x42b4	; 0x42b4 <Delay_us>
	#ifdef Port_LCD_DB0	
		LCD_FuncSet0();
    edb6:	0e 94 ac 29 	call	0x5358	; 0x5358 <LCD_FuncSet0>
	#else
		LCD_FuncSet1();
	#endif
//// BF(Busy flag) can be checked follow
	Delay_us(LCD_Delay);
    edba:	82 e3       	ldi	r24, 0x32	; 50
    edbc:	90 e0       	ldi	r25, 0x00	; 0
    edbe:	0e 94 5a 21 	call	0x42b4	; 0x42b4 <Delay_us>
	Port_LCD_RS |=LCD_RS;
    edc2:	44 9a       	sbi	0x08, 4	; 8

	LCD_Rst0();
	Delay_ms(5);		// 4.1 ms needs
	LCD_Rst1();

	Port_LCD_RS &=~LCD_RS;
    edc4:	44 98       	cbi	0x08, 4	; 8

	#ifdef Port_LCD_DB0	
		Send_I(0b00111000);	//; 8-bits DL, 2 lines, 5x7 dots
    edc6:	88 e3       	ldi	r24, 0x38	; 56
    edc8:	0e 94 a5 29 	call	0x534a	; 0x534a <Send_I>
	#else
		Send_I(0b00101000);	//; 4-bits DL, 2 lines, 5x7 dots
	#endif
	Send_I(0b00001100);	//; Display on, cursor off, blink off	
    edcc:	8c e0       	ldi	r24, 0x0C	; 12
    edce:	0e 94 a5 29 	call	0x534a	; 0x534a <Send_I>
	Send_I(0b00000110);	//; cursor shift right, no display shift
    edd2:	86 e0       	ldi	r24, 0x06	; 6
    edd4:	0e 94 a5 29 	call	0x534a	; 0x534a <Send_I>


	Send_I(0b01000000);	//;    CG RAM   0.
    edd8:	80 e4       	ldi	r24, 0x40	; 64
    edda:	0e 94 a5 29 	call	0x534a	; 0x534a <Send_I>
	Port_LCD_RS |=LCD_RS;
    edde:	44 9a       	sbi	0x08, 4	; 8
    ede0:	8f e8       	ldi	r24, 0x8F	; 143
    ede2:	e8 2e       	mov	r14, r24
    ede4:	84 e3       	ldi	r24, 0x34	; 52
    ede6:	f8 2e       	mov	r15, r24
	for (i=0; i<8; i++)
    ede8:	e7 01       	movw	r28, r14
    edea:	10 e0       	ldi	r17, 0x00	; 0

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    edec:	fe 01       	movw	r30, r28
    edee:	84 91       	lpm	r24, Z+
		for (j=0; j<8; j++)
			Send_I(prb(CGRAM_LCD[i]+j));
    edf0:	0e 94 a5 29 	call	0x534a	; 0x534a <Send_I>


	Send_I(0b01000000);	//;    CG RAM   0.
	Port_LCD_RS |=LCD_RS;
	for (i=0; i<8; i++)
		for (j=0; j<8; j++)
    edf4:	1f 5f       	subi	r17, 0xFF	; 255
    edf6:	21 96       	adiw	r28, 0x01	; 1
    edf8:	18 30       	cpi	r17, 0x08	; 8
    edfa:	c1 f7       	brne	.-16     	; 0xedec <LCD_Init+0xb6>
    edfc:	88 e0       	ldi	r24, 0x08	; 8
    edfe:	90 e0       	ldi	r25, 0x00	; 0
    ee00:	e8 0e       	add	r14, r24
    ee02:	f9 1e       	adc	r15, r25
	Send_I(0b00000110);	//; cursor shift right, no display shift


	Send_I(0b01000000);	//;    CG RAM   0.
	Port_LCD_RS |=LCD_RS;
	for (i=0; i<8; i++)
    ee04:	9f ec       	ldi	r25, 0xCF	; 207
    ee06:	e9 16       	cp	r14, r25
    ee08:	94 e3       	ldi	r25, 0x34	; 52
    ee0a:	f9 06       	cpc	r15, r25
    ee0c:	69 f7       	brne	.-38     	; 0xede8 <LCD_Init+0xb2>
		for (j=0; j<8; j++)
			Send_I(prb(CGRAM_LCD[i]+j));

	Port_LCD_RS &=~LCD_RS;
    ee0e:	44 98       	cbi	0x08, 4	; 8
	Send(0b00000001);
    ee10:	81 e0       	ldi	r24, 0x01	; 1
    ee12:	0e 94 64 29 	call	0x52c8	; 0x52c8 <Send>
    ee16:	80 ea       	ldi	r24, 0xA0	; 160
    ee18:	9f e0       	ldi	r25, 0x0F	; 15
    ee1a:	fc 01       	movw	r30, r24
    ee1c:	31 97       	sbiw	r30, 0x01	; 1
    ee1e:	f1 f7       	brne	.-4      	; 0xee1c <LCD_Init+0xe6>
    ee20:	fc 01       	movw	r30, r24
    ee22:	31 97       	sbiw	r30, 0x01	; 1
    ee24:	f1 f7       	brne	.-4      	; 0xee22 <LCD_Init+0xec>
    ee26:	fc 01       	movw	r30, r24
    ee28:	31 97       	sbiw	r30, 0x01	; 1
    ee2a:	f1 f7       	brne	.-4      	; 0xee28 <LCD_Init+0xf2>
    ee2c:	fc 01       	movw	r30, r24
    ee2e:	31 97       	sbiw	r30, 0x01	; 1
    ee30:	f1 f7       	brne	.-4      	; 0xee2e <LCD_Init+0xf8>
    ee32:	01 97       	sbiw	r24, 0x01	; 1
    ee34:	f1 f7       	brne	.-4      	; 0xee32 <LCD_Init+0xfc>
	Delay_ms(5);				// By trial
	Port_LCD_RS |=LCD_RS;
    ee36:	44 9a       	sbi	0x08, 4	; 8
}

uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    ee38:	80 91 cf 02 	lds	r24, 0x02CF
	VacantTimer8Sys += n;
    ee3c:	8f 5f       	subi	r24, 0xFF	; 255
    ee3e:	80 93 cf 02 	sts	0x02CF, r24
    ee42:	81 50       	subi	r24, 0x01	; 1

	// Frame Timer
	TD_LCD = Timer8SysAlloc(1);
    ee44:	80 93 d7 04 	sts	0x04D7, r24
    ee48:	20 e0       	ldi	r18, 0x00	; 0
    ee4a:	30 e0       	ldi	r19, 0x00	; 0

	for (i=0; i<LCDYSz; i++)
		for (j=0; j<LCDXSz; j++)
			LCD_Buf[i][j] = ' ';
    ee4c:	40 e2       	ldi	r20, 0x20	; 32
	Port_LCD_RS |=LCD_RS;

	// Frame Timer
	TD_LCD = Timer8SysAlloc(1);

	for (i=0; i<LCDYSz; i++)
    ee4e:	c9 01       	movw	r24, r18
    ee50:	88 0f       	add	r24, r24
    ee52:	99 1f       	adc	r25, r25
    ee54:	82 0f       	add	r24, r18
    ee56:	93 1f       	adc	r25, r19
    ee58:	fc 01       	movw	r30, r24
    ee5a:	ee 0f       	add	r30, r30
    ee5c:	ff 1f       	adc	r31, r31
    ee5e:	ee 0f       	add	r30, r30
    ee60:	ff 1f       	adc	r31, r31
    ee62:	ee 0f       	add	r30, r30
    ee64:	ff 1f       	adc	r31, r31
    ee66:	e8 1b       	sub	r30, r24
    ee68:	f9 0b       	sbc	r31, r25
    ee6a:	e8 5a       	subi	r30, 0xA8	; 168
    ee6c:	f9 4f       	sbci	r31, 0xF9	; 249
    ee6e:	80 e0       	ldi	r24, 0x00	; 0
		for (j=0; j<LCDXSz; j++)
			LCD_Buf[i][j] = ' ';
    ee70:	41 93       	st	Z+, r20

	// Frame Timer
	TD_LCD = Timer8SysAlloc(1);

	for (i=0; i<LCDYSz; i++)
		for (j=0; j<LCDXSz; j++)
    ee72:	8f 5f       	subi	r24, 0xFF	; 255
    ee74:	84 31       	cpi	r24, 0x14	; 20
    ee76:	e1 f7       	brne	.-8      	; 0xee70 <LCD_Init+0x13a>
    ee78:	2f 5f       	subi	r18, 0xFF	; 255
    ee7a:	3f 4f       	sbci	r19, 0xFF	; 255
	Port_LCD_RS |=LCD_RS;

	// Frame Timer
	TD_LCD = Timer8SysAlloc(1);

	for (i=0; i<LCDYSz; i++)
    ee7c:	24 30       	cpi	r18, 0x04	; 4
    ee7e:	31 05       	cpc	r19, r1
    ee80:	31 f7       	brne	.-52     	; 0xee4e <LCD_Init+0x118>
		for (j=0; j<LCDXSz; j++)
			LCD_Buf[i][j] = ' ';

	#ifdef RTYP
		#ifndef QslRD
			*(uint8_t*)RTYP = R_PLC_Type;
    ee82:	87 e0       	ldi	r24, 0x07	; 7
    ee84:	80 93 91 08 	sts	0x0891, r24
		#endif	
	#endif

	#ifdef BACKLIGHT
		LCDBackLightInit();
    ee88:	0e 94 7d 76 	call	0xecfa	; 0xecfa <LCDBackLightInit>
	#endif
}
    ee8c:	df 91       	pop	r29
    ee8e:	cf 91       	pop	r28
    ee90:	1f 91       	pop	r17
    ee92:	ff 90       	pop	r15
    ee94:	ef 90       	pop	r14
    ee96:	08 95       	ret

0000ee98 <RTC_Summer_Time>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    ee98:	83 e0       	ldi	r24, 0x03	; 3
    ee9a:	90 e0       	ldi	r25, 0x00	; 0
    ee9c:	0e 94 50 87 	call	0x10ea0	; 0x10ea0 <__eerd_byte_m2560>
	
	return 0;
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void RTC_Summer_Time(void){
	if(erb(&SummerTime)){
    eea0:	88 23       	and	r24, r24
    eea2:	31 f0       	breq	.+12     	; 0xeeb0 <RTC_Summer_Time+0x18>
		//   ()  02:00:00   03:00:00    
		if( (Tm_Mon == 3) && (Tm_WDay == 0) && (Tm_MDay>=25) && (Tm_Hour == 2) ){
    eea4:	90 91 cc 07 	lds	r25, 0x07CC
    eea8:	93 30       	cpi	r25, 0x03	; 3
    eeaa:	b1 f0       	breq	.+44     	; 0xeed8 <RTC_Summer_Time+0x40>
				Tm_Hour=3;
				SetHour();
		}

		//   ()  04:00:00   03:00:00    
		if( (Tm_Mon == 10) && (Tm_WDay == 0) && (Tm_MDay>=25) ){
    eeac:	9a 30       	cpi	r25, 0x0A	; 10
    eeae:	09 f0       	breq	.+2      	; 0xeeb2 <RTC_Summer_Time+0x1a>
    eeb0:	08 95       	ret
    eeb2:	80 91 57 06 	lds	r24, 0x0657
    eeb6:	88 23       	and	r24, r24
    eeb8:	d9 f7       	brne	.-10     	; 0xeeb0 <RTC_Summer_Time+0x18>
    eeba:	80 91 5f 0b 	lds	r24, 0x0B5F
    eebe:	89 31       	cpi	r24, 0x19	; 25
    eec0:	b8 f3       	brcs	.-18     	; 0xeeb0 <RTC_Summer_Time+0x18>
				if(Tm_Hour == 4){
    eec2:	80 91 c1 05 	lds	r24, 0x05C1
    eec6:	84 30       	cpi	r24, 0x04	; 4
    eec8:	d1 f0       	breq	.+52     	; 0xeefe <RTC_Summer_Time+0x66>
						Tm_Hour=3;
						SetHour();
						NotSummerTimeFlag = 1;
					}
				}
				if(Tm_Hour < 2) NotSummerTimeFlag = 0;
    eeca:	82 30       	cpi	r24, 0x02	; 2
    eecc:	38 f1       	brcs	.+78     	; 0xef1c <RTC_Summer_Time+0x84>
				if(Tm_Hour >= 5) NotSummerTimeFlag = 0;
    eece:	85 30       	cpi	r24, 0x05	; 5
    eed0:	78 f3       	brcs	.-34     	; 0xeeb0 <RTC_Summer_Time+0x18>
    eed2:	10 92 dd 05 	sts	0x05DD, r1
    eed6:	08 95       	ret
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void RTC_Summer_Time(void){
	if(erb(&SummerTime)){
		//   ()  02:00:00   03:00:00    
		if( (Tm_Mon == 3) && (Tm_WDay == 0) && (Tm_MDay>=25) && (Tm_Hour == 2) ){
    eed8:	80 91 57 06 	lds	r24, 0x0657
    eedc:	88 23       	and	r24, r24
    eede:	41 f7       	brne	.-48     	; 0xeeb0 <RTC_Summer_Time+0x18>
    eee0:	80 91 5f 0b 	lds	r24, 0x0B5F
    eee4:	89 31       	cpi	r24, 0x19	; 25
    eee6:	20 f3       	brcs	.-56     	; 0xeeb0 <RTC_Summer_Time+0x18>
    eee8:	80 91 c1 05 	lds	r24, 0x05C1
    eeec:	82 30       	cpi	r24, 0x02	; 2
    eeee:	01 f7       	brne	.-64     	; 0xeeb0 <RTC_Summer_Time+0x18>
				Tm_Hour=3;
    eef0:	90 93 c1 05 	sts	0x05C1, r25
				SetHour();
    eef4:	0e 94 38 27 	call	0x4e70	; 0x4e70 <SetHour>
    eef8:	90 91 cc 07 	lds	r25, 0x07CC
    eefc:	d7 cf       	rjmp	.-82     	; 0xeeac <RTC_Summer_Time+0x14>
		}

		//   ()  04:00:00   03:00:00    
		if( (Tm_Mon == 10) && (Tm_WDay == 0) && (Tm_MDay>=25) ){
				if(Tm_Hour == 4){
					if(!NotSummerTimeFlag){
    eefe:	80 91 dd 05 	lds	r24, 0x05DD
    ef02:	88 23       	and	r24, r24
    ef04:	a9 f6       	brne	.-86     	; 0xeeb0 <RTC_Summer_Time+0x18>
						Tm_Hour=3;
    ef06:	83 e0       	ldi	r24, 0x03	; 3
    ef08:	80 93 c1 05 	sts	0x05C1, r24
						SetHour();
    ef0c:	0e 94 38 27 	call	0x4e70	; 0x4e70 <SetHour>
						NotSummerTimeFlag = 1;
    ef10:	81 e0       	ldi	r24, 0x01	; 1
    ef12:	80 93 dd 05 	sts	0x05DD, r24
    ef16:	80 91 c1 05 	lds	r24, 0x05C1
    ef1a:	d7 cf       	rjmp	.-82     	; 0xeeca <RTC_Summer_Time+0x32>
					}
				}
				if(Tm_Hour < 2) NotSummerTimeFlag = 0;
    ef1c:	10 92 dd 05 	sts	0x05DD, r1
    ef20:	d6 cf       	rjmp	.-84     	; 0xeece <RTC_Summer_Time+0x36>

0000ef22 <TWI_In>:
}

// ~~~~~~~~~
void
TWI_In(void)
{
    ef22:	cf 92       	push	r12
    ef24:	ef 92       	push	r14
    ef26:	0f 93       	push	r16
	if(Timer8Stopp(TD_TWI_Poll)){
    ef28:	00 91 d2 04 	lds	r16, 0x04D2
    ef2c:	80 2f       	mov	r24, r16
    ef2e:	0e 94 61 1f 	call	0x3ec2	; 0x3ec2 <Timer8Stopp>
    ef32:	88 23       	and	r24, r24
    ef34:	e1 f0       	breq	.+56     	; 0xef6e <TWI_In+0x4c>

		if (TWI_Phase == PCF_START){
    ef36:	80 91 c3 07 	lds	r24, 0x07C3
    ef3a:	88 23       	and	r24, r24
    ef3c:	99 f1       	breq	.+102    	; 0xefa4 <TWI_In+0x82>
			StartTWI();		// Send Start
			TWI_Phase++;
			StartTimer8(TD_TWI_Timeout,40);
			return;
		}
		if(Timer8Stopp(TD_TWI_Timeout)){	// 
    ef3e:	80 91 d3 04 	lds	r24, 0x04D3
    ef42:	0e 94 61 1f 	call	0x3ec2	; 0x3ec2 <Timer8Stopp>
    ef46:	88 23       	and	r24, r24
    ef48:	09 f0       	breq	.+2      	; 0xef4c <TWI_In+0x2a>
    ef4a:	4e c0       	rjmp	.+156    	; 0xefe8 <TWI_In+0xc6>
			TWI_Error();
			return;
		}

		if (!(TWCR &(1<<TWINT))) return;
    ef4c:	80 91 bc 00 	lds	r24, 0x00BC
    ef50:	87 ff       	sbrs	r24, 7
    ef52:	33 c0       	rjmp	.+102    	; 0xefba <TWI_In+0x98>

		switch(TWI_Phase) {
    ef54:	40 91 c3 07 	lds	r20, 0x07C3
    ef58:	84 2f       	mov	r24, r20
    ef5a:	90 e0       	ldi	r25, 0x00	; 0
    ef5c:	fc 01       	movw	r30, r24
    ef5e:	31 97       	sbiw	r30, 0x01	; 1
    ef60:	e1 31       	cpi	r30, 0x11	; 17
    ef62:	f1 05       	cpc	r31, r1
    ef64:	08 f4       	brcc	.+2      	; 0xef68 <TWI_In+0x46>
    ef66:	46 c0       	rjmp	.+140    	; 0xeff4 <TWI_In+0xd2>
			Tm_WDay = SetWeekday(Tm_Year, Tm_Mon, Tm_MDay);
			StartTimer8(TD_TWI_Poll, 49);
			TWI_Phase = 0xFF;
			break;
		}
		TWI_Phase++;
    ef68:	4f 5f       	subi	r20, 0xFF	; 255
    ef6a:	40 93 c3 07 	sts	0x07C3, r20
	}//Timer8Stopp(TD_TWI)

	if( Timer16Stopp(TD_RTC_Check) && (TWI_Phase == PCF_START) ){
    ef6e:	00 91 d4 04 	lds	r16, 0x04D4
    ef72:	80 2f       	mov	r24, r16
    ef74:	0e 94 84 1f 	call	0x3f08	; 0x3f08 <Timer16Stopp>
    ef78:	88 23       	and	r24, r24
    ef7a:	f9 f0       	breq	.+62     	; 0xefba <TWI_In+0x98>
    ef7c:	80 91 c3 07 	lds	r24, 0x07C3
    ef80:	88 23       	and	r24, r24
    ef82:	d9 f4       	brne	.+54     	; 0xefba <TWI_In+0x98>
		StartTimer16(TD_RTC_Check, 300);
    ef84:	80 2f       	mov	r24, r16
    ef86:	6c e2       	ldi	r22, 0x2C	; 44
    ef88:	71 e0       	ldi	r23, 0x01	; 1
    ef8a:	0e 94 48 1e 	call	0x3c90	; 0x3c90 <StartTimer16>
		if(RTC_Check() || PFC_Stop_bit){
    ef8e:	0e 94 5d 28 	call	0x50ba	; 0x50ba <RTC_Check>
    ef92:	88 23       	and	r24, r24
    ef94:	b1 f4       	brne	.+44     	; 0xefc2 <TWI_In+0xa0>
    ef96:	80 91 d5 04 	lds	r24, 0x04D5
    ef9a:	88 23       	and	r24, r24
    ef9c:	91 f4       	brne	.+36     	; 0xefc2 <TWI_In+0xa0>
			// RTC
			SetDateTime(TrueTime_Year, TrueTime_Mon, TrueTime_MDay, TrueTime_WDay, TrueTime_Hour, TrueTime_Min, TrueTime_Sec);
		}
		else RTC_GetTrueTime();
    ef9e:	0e 94 14 28 	call	0x5028	; 0x5028 <RTC_GetTrueTime>
    efa2:	1f c0       	rjmp	.+62     	; 0xefe2 <TWI_In+0xc0>
TWI_In(void)
{
	if(Timer8Stopp(TD_TWI_Poll)){

		if (TWI_Phase == PCF_START){
			StartTWI();		// Send Start
    efa4:	84 ea       	ldi	r24, 0xA4	; 164
    efa6:	80 93 bc 00 	sts	0x00BC, r24
			TWI_Phase++;
    efaa:	81 e0       	ldi	r24, 0x01	; 1
    efac:	80 93 c3 07 	sts	0x07C3, r24
			StartTimer8(TD_TWI_Timeout,40);
    efb0:	80 91 d3 04 	lds	r24, 0x04D3
    efb4:	68 e2       	ldi	r22, 0x28	; 40
    efb6:	0e 94 0d 1e 	call	0x3c1a	; 0x3c1a <StartTimer8>
		}
		else RTC_GetTrueTime();

		RTC_Summer_Time();
	}
}
    efba:	0f 91       	pop	r16
    efbc:	ef 90       	pop	r14
    efbe:	cf 90       	pop	r12
    efc0:	08 95       	ret

	if( Timer16Stopp(TD_RTC_Check) && (TWI_Phase == PCF_START) ){
		StartTimer16(TD_RTC_Check, 300);
		if(RTC_Check() || PFC_Stop_bit){
			// RTC
			SetDateTime(TrueTime_Year, TrueTime_Mon, TrueTime_MDay, TrueTime_WDay, TrueTime_Hour, TrueTime_Min, TrueTime_Sec);
    efc2:	80 91 c1 07 	lds	r24, 0x07C1
    efc6:	60 91 15 09 	lds	r22, 0x0915
    efca:	40 91 56 06 	lds	r20, 0x0656
    efce:	20 91 5e 0b 	lds	r18, 0x0B5E
    efd2:	00 91 d8 05 	lds	r16, 0x05D8
    efd6:	e0 90 16 09 	lds	r14, 0x0916
    efda:	c0 90 14 09 	lds	r12, 0x0914
    efde:	0e 94 60 27 	call	0x4ec0	; 0x4ec0 <SetDateTime>
		}
		else RTC_GetTrueTime();

		RTC_Summer_Time();
    efe2:	0e 94 4c 77 	call	0xee98	; 0xee98 <RTC_Summer_Time>
    efe6:	e9 cf       	rjmp	.-46     	; 0xefba <TWI_In+0x98>
			Tm_Mon = DecodBCD(TWDR & 0b00011111);
			if(Tm_Mon > 12) Tm_Mon = 0;	//
			RunTWI();		//NACK
			break;
		case PCF_Year:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_NACK){ TWI_Error(); return;}
    efe8:	0e 94 95 26 	call	0x4d2a	; 0x4d2a <TWI_Error>
		}
		else RTC_GetTrueTime();

		RTC_Summer_Time();
	}
}
    efec:	0f 91       	pop	r16
    efee:	ef 90       	pop	r14
    eff0:	cf 90       	pop	r12
    eff2:	08 95       	ret
			return;
		}

		if (!(TWCR &(1<<TWINT))) return;

		switch(TWI_Phase) {
    eff4:	ea 5a       	subi	r30, 0xAA	; 170
    eff6:	fe 4f       	sbci	r31, 0xFE	; 254
    eff8:	ee 0f       	add	r30, r30
    effa:	ff 1f       	adc	r31, r31
    effc:	05 90       	lpm	r0, Z+
    effe:	f4 91       	lpm	r31, Z+
    f000:	e0 2d       	mov	r30, r0
    f002:	19 94       	eijmp
		case PFC_ACKN:
			AcknTWI();
			break;

		case PCF_Se:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
    f004:	80 91 b9 00 	lds	r24, 0x00B9
    f008:	88 7f       	andi	r24, 0xF8	; 248
    f00a:	80 35       	cpi	r24, 0x50	; 80
    f00c:	69 f7       	brne	.-38     	; 0xefe8 <TWI_In+0xc6>
			Tm_Sec = DecodBCD(TWDR & 0b01111111);	// exclude ST bit
    f00e:	20 91 bb 00 	lds	r18, 0x00BB
    f012:	82 2f       	mov	r24, r18
    f014:	8f 77       	andi	r24, 0x7F	; 127
    f016:	82 95       	swap	r24
    f018:	8f 70       	andi	r24, 0x0F	; 15
    f01a:	3a e0       	ldi	r19, 0x0A	; 10
    f01c:	83 9f       	mul	r24, r19
    f01e:	c0 01       	movw	r24, r0
    f020:	11 24       	eor	r1, r1
    f022:	2f 70       	andi	r18, 0x0F	; 15
    f024:	28 0f       	add	r18, r24
    f026:	20 93 f7 06 	sts	0x06F7, r18
			PFC_Stop_bit = TWDR & 0b10000000;
    f02a:	80 91 bb 00 	lds	r24, 0x00BB
    f02e:	80 78       	andi	r24, 0x80	; 128
    f030:	80 93 d5 04 	sts	0x04D5, r24
/*			if(PFC_Stop_bit) NoTickCnt++;
			else NoTickCnt=0;*/
			AcknTWI();
    f034:	84 ec       	ldi	r24, 0xC4	; 196
    f036:	80 93 bc 00 	sts	0x00BC, r24
    f03a:	96 cf       	rjmp	.-212    	; 0xef68 <TWI_In+0x46>

		case PCF_REAP_START1:
			StartTWI();
			break;
		case PCF_CHECK_REAP_START1:
			if( (TWSR & 0b11111000) != TWI_STATUS_RP_START){ TWI_Error(); return;}
    f03c:	80 91 b9 00 	lds	r24, 0x00B9
    f040:	88 7f       	andi	r24, 0xF8	; 248
    f042:	80 31       	cpi	r24, 0x10	; 16
    f044:	89 f6       	brne	.-94     	; 0xefe8 <TWI_In+0xc6>
    f046:	48 e0       	ldi	r20, 0x08	; 8
			else TWI_Phase++;

		case PCF_SLA_R:
			SLA_R(PCF_SLA);
    f048:	81 ed       	ldi	r24, 0xD1	; 209
    f04a:	80 93 bb 00 	sts	0x00BB, r24
			RunTWI();
    f04e:	84 e8       	ldi	r24, 0x84	; 132
    f050:	80 93 bc 00 	sts	0x00BC, r24
    f054:	89 cf       	rjmp	.-238    	; 0xef68 <TWI_In+0x46>
		case PCF_Addr:
			TWDR = AddrSec;
			RunTWI();
			break;
		case PCF_CHECK_Addr:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATATX_ACK){ TWI_Error(); return;}
    f056:	80 91 b9 00 	lds	r24, 0x00B9
    f05a:	88 7f       	andi	r24, 0xF8	; 248
    f05c:	88 32       	cpi	r24, 0x28	; 40
    f05e:	21 f6       	brne	.-120    	; 0xefe8 <TWI_In+0xc6>
    f060:	46 e0       	ldi	r20, 0x06	; 6
			else TWI_Phase++;

		case PCF_REAP_START1:
			StartTWI();
    f062:	84 ea       	ldi	r24, 0xA4	; 164
    f064:	80 93 bc 00 	sts	0x00BC, r24
    f068:	7f cf       	rjmp	.-258    	; 0xef68 <TWI_In+0x46>
		case PCF_SLA_W:
			SLA_W(PCF_SLA);
			RunTWI();
			break;
		case PCF_CHECK_SLA_W:
			if( (TWSR & 0b11111000) != TWI_STATUS_SLAW_ACK){ TWI_Error(); return;}
    f06a:	80 91 b9 00 	lds	r24, 0x00B9
    f06e:	88 7f       	andi	r24, 0xF8	; 248
    f070:	88 31       	cpi	r24, 0x18	; 24
    f072:	09 f0       	breq	.+2      	; 0xf076 <TWI_In+0x154>
    f074:	b9 cf       	rjmp	.-142    	; 0xefe8 <TWI_In+0xc6>
    f076:	44 e0       	ldi	r20, 0x04	; 4
			else TWI_Phase++;

		case PCF_Addr:
			TWDR = AddrSec;
    f078:	10 92 bb 00 	sts	0x00BB, r1
			RunTWI();
    f07c:	84 e8       	ldi	r24, 0x84	; 132
    f07e:	80 93 bc 00 	sts	0x00BC, r24
    f082:	72 cf       	rjmp	.-284    	; 0xef68 <TWI_In+0x46>
		if (!(TWCR &(1<<TWINT))) return;

		switch(TWI_Phase) {
		
		case PCF_CHECK_START:
			if( (TWSR & 0b11111000) != TWI_STATUS_START){ TWI_Error(); return;}
    f084:	80 91 b9 00 	lds	r24, 0x00B9
    f088:	88 7f       	andi	r24, 0xF8	; 248
    f08a:	88 30       	cpi	r24, 0x08	; 8
    f08c:	09 f0       	breq	.+2      	; 0xf090 <TWI_In+0x16e>
    f08e:	ac cf       	rjmp	.-168    	; 0xefe8 <TWI_In+0xc6>
    f090:	42 e0       	ldi	r20, 0x02	; 2
			else TWI_Phase++;
			
		case PCF_SLA_W:
			SLA_W(PCF_SLA);
    f092:	80 ed       	ldi	r24, 0xD0	; 208
    f094:	80 93 bb 00 	sts	0x00BB, r24
			RunTWI();
    f098:	84 e8       	ldi	r24, 0x84	; 132
    f09a:	80 93 bc 00 	sts	0x00BC, r24
    f09e:	64 cf       	rjmp	.-312    	; 0xef68 <TWI_In+0x46>
		case PCF_SLA_R:
			SLA_R(PCF_SLA);
			RunTWI();
			break;
		case PCF_CHECK_SLA_R:
			if( (TWSR & 0b11111000) != TWI_STATUS_SLAR_ACK){ TWI_Error(); return;}
    f0a0:	80 91 b9 00 	lds	r24, 0x00B9
    f0a4:	88 7f       	andi	r24, 0xF8	; 248
    f0a6:	80 34       	cpi	r24, 0x40	; 64
    f0a8:	09 f0       	breq	.+2      	; 0xf0ac <TWI_In+0x18a>
    f0aa:	9e cf       	rjmp	.-196    	; 0xefe8 <TWI_In+0xc6>
    f0ac:	4a e0       	ldi	r20, 0x0A	; 10
    f0ae:	c2 cf       	rjmp	.-124    	; 0xf034 <TWI_In+0x112>
			Tm_Mon = DecodBCD(TWDR & 0b00011111);
			if(Tm_Mon > 12) Tm_Mon = 0;	//
			RunTWI();		//NACK
			break;
		case PCF_Year:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_NACK){ TWI_Error(); return;}
    f0b0:	80 91 b9 00 	lds	r24, 0x00B9
    f0b4:	88 7f       	andi	r24, 0xF8	; 248
    f0b6:	88 35       	cpi	r24, 0x58	; 88
    f0b8:	09 f0       	breq	.+2      	; 0xf0bc <TWI_In+0x19a>
    f0ba:	96 cf       	rjmp	.-212    	; 0xefe8 <TWI_In+0xc6>
			Tm_Year = DecodBCD(TWDR);
    f0bc:	80 91 bb 00 	lds	r24, 0x00BB

// ~~~~~~~~~~~~~~~~~~
uint8_t
DecodBCD(uint8_t BCD)
{
	return 10*(BCD>>4)+(BCD&0x0F);
    f0c0:	28 2f       	mov	r18, r24
    f0c2:	22 95       	swap	r18
    f0c4:	2f 70       	andi	r18, 0x0F	; 15
    f0c6:	9a e0       	ldi	r25, 0x0A	; 10
    f0c8:	29 9f       	mul	r18, r25
    f0ca:	90 01       	movw	r18, r0
    f0cc:	11 24       	eor	r1, r1
    f0ce:	8f 70       	andi	r24, 0x0F	; 15
    f0d0:	82 0f       	add	r24, r18
    f0d2:	80 93 de 05 	sts	0x05DE, r24
			StopTWI();
    f0d6:	94 e9       	ldi	r25, 0x94	; 148
    f0d8:	90 93 bc 00 	sts	0x00BC, r25
			Tm_WDay = SetWeekday(Tm_Year, Tm_Mon, Tm_MDay);
    f0dc:	60 91 cc 07 	lds	r22, 0x07CC
    f0e0:	40 91 5f 0b 	lds	r20, 0x0B5F
    f0e4:	0e 94 f8 26 	call	0x4df0	; 0x4df0 <SetWeekday>
    f0e8:	80 93 57 06 	sts	0x0657, r24
			StartTimer8(TD_TWI_Poll, 49);
    f0ec:	80 2f       	mov	r24, r16
    f0ee:	61 e3       	ldi	r22, 0x31	; 49
    f0f0:	0e 94 0d 1e 	call	0x3c1a	; 0x3c1a <StartTimer8>
    f0f4:	4f ef       	ldi	r20, 0xFF	; 255
    f0f6:	38 cf       	rjmp	.-400    	; 0xef68 <TWI_In+0x46>
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
			Tm_MDay = DecodBCD(TWDR & 0b00111111);
			AcknTWI();
			break;
		case PCF_Mo:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
    f0f8:	80 91 b9 00 	lds	r24, 0x00B9
    f0fc:	88 7f       	andi	r24, 0xF8	; 248
    f0fe:	80 35       	cpi	r24, 0x50	; 80
    f100:	09 f0       	breq	.+2      	; 0xf104 <TWI_In+0x1e2>
    f102:	72 cf       	rjmp	.-284    	; 0xefe8 <TWI_In+0xc6>
			Tm_Mon = DecodBCD(TWDR & 0b00011111);
    f104:	80 91 bb 00 	lds	r24, 0x00BB
    f108:	28 2f       	mov	r18, r24
    f10a:	2f 71       	andi	r18, 0x1F	; 31
    f10c:	22 95       	swap	r18
    f10e:	2f 70       	andi	r18, 0x0F	; 15
    f110:	9a e0       	ldi	r25, 0x0A	; 10
    f112:	29 9f       	mul	r18, r25
    f114:	90 01       	movw	r18, r0
    f116:	11 24       	eor	r1, r1
    f118:	8f 70       	andi	r24, 0x0F	; 15
    f11a:	82 0f       	add	r24, r18
    f11c:	80 93 cc 07 	sts	0x07CC, r24
			if(Tm_Mon > 12) Tm_Mon = 0;	//
    f120:	8d 30       	cpi	r24, 0x0D	; 13
    f122:	10 f0       	brcs	.+4      	; 0xf128 <TWI_In+0x206>
    f124:	10 92 cc 07 	sts	0x07CC, r1
			RunTWI();		//NACK
    f128:	84 e8       	ldi	r24, 0x84	; 132
    f12a:	80 93 bc 00 	sts	0x00BC, r24
    f12e:	1c cf       	rjmp	.-456    	; 0xef68 <TWI_In+0x46>
			TWDR;
			//Tm_WDay = DecodBCD(TWDR & 0b00000111); Ignore 
			AcknTWI();
			break;
		case PCF_MDay:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
    f130:	80 91 b9 00 	lds	r24, 0x00B9
    f134:	88 7f       	andi	r24, 0xF8	; 248
    f136:	80 35       	cpi	r24, 0x50	; 80
    f138:	09 f0       	breq	.+2      	; 0xf13c <TWI_In+0x21a>
    f13a:	56 cf       	rjmp	.-340    	; 0xefe8 <TWI_In+0xc6>
			Tm_MDay = DecodBCD(TWDR & 0b00111111);
    f13c:	20 91 bb 00 	lds	r18, 0x00BB
    f140:	82 2f       	mov	r24, r18
    f142:	8f 73       	andi	r24, 0x3F	; 63
    f144:	82 95       	swap	r24
    f146:	8f 70       	andi	r24, 0x0F	; 15
    f148:	3a e0       	ldi	r19, 0x0A	; 10
    f14a:	83 9f       	mul	r24, r19
    f14c:	c0 01       	movw	r24, r0
    f14e:	11 24       	eor	r1, r1
    f150:	2f 70       	andi	r18, 0x0F	; 15
    f152:	28 0f       	add	r18, r24
    f154:	20 93 5f 0b 	sts	0x0B5F, r18
			AcknTWI();
    f158:	84 ec       	ldi	r24, 0xC4	; 196
    f15a:	80 93 bc 00 	sts	0x00BC, r24
    f15e:	04 cf       	rjmp	.-504    	; 0xef68 <TWI_In+0x46>
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
			Tm_Hour = DecodBCD(TWDR & 0b00111111);
			AcknTWI();
			break;
		case PCF_WDay:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
    f160:	80 91 b9 00 	lds	r24, 0x00B9
    f164:	88 7f       	andi	r24, 0xF8	; 248
    f166:	80 35       	cpi	r24, 0x50	; 80
    f168:	09 f0       	breq	.+2      	; 0xf16c <TWI_In+0x24a>
    f16a:	3e cf       	rjmp	.-388    	; 0xefe8 <TWI_In+0xc6>
			TWDR;
    f16c:	80 91 bb 00 	lds	r24, 0x00BB
			//Tm_WDay = DecodBCD(TWDR & 0b00000111); Ignore 
			AcknTWI();
    f170:	84 ec       	ldi	r24, 0xC4	; 196
    f172:	80 93 bc 00 	sts	0x00BC, r24
    f176:	f8 ce       	rjmp	.-528    	; 0xef68 <TWI_In+0x46>
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
			Tm_Min = DecodBCD(TWDR & 0b01111111);
			AcknTWI();
			break;
		case PCF_Ho:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
    f178:	80 91 b9 00 	lds	r24, 0x00B9
    f17c:	88 7f       	andi	r24, 0xF8	; 248
    f17e:	80 35       	cpi	r24, 0x50	; 80
    f180:	09 f0       	breq	.+2      	; 0xf184 <TWI_In+0x262>
    f182:	32 cf       	rjmp	.-412    	; 0xefe8 <TWI_In+0xc6>
			Tm_Hour = DecodBCD(TWDR & 0b00111111);
    f184:	20 91 bb 00 	lds	r18, 0x00BB
    f188:	82 2f       	mov	r24, r18
    f18a:	8f 73       	andi	r24, 0x3F	; 63
    f18c:	82 95       	swap	r24
    f18e:	8f 70       	andi	r24, 0x0F	; 15
    f190:	3a e0       	ldi	r19, 0x0A	; 10
    f192:	83 9f       	mul	r24, r19
    f194:	c0 01       	movw	r24, r0
    f196:	11 24       	eor	r1, r1
    f198:	2f 70       	andi	r18, 0x0F	; 15
    f19a:	28 0f       	add	r18, r24
    f19c:	20 93 c1 05 	sts	0x05C1, r18
			AcknTWI();
    f1a0:	84 ec       	ldi	r24, 0xC4	; 196
    f1a2:	80 93 bc 00 	sts	0x00BC, r24
    f1a6:	e0 ce       	rjmp	.-576    	; 0xef68 <TWI_In+0x46>
/*			if(PFC_Stop_bit) NoTickCnt++;
			else NoTickCnt=0;*/
			AcknTWI();
			break;
		case PCF_Mi:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
    f1a8:	80 91 b9 00 	lds	r24, 0x00B9
    f1ac:	88 7f       	andi	r24, 0xF8	; 248
    f1ae:	80 35       	cpi	r24, 0x50	; 80
    f1b0:	09 f0       	breq	.+2      	; 0xf1b4 <TWI_In+0x292>
    f1b2:	1a cf       	rjmp	.-460    	; 0xefe8 <TWI_In+0xc6>
			Tm_Min = DecodBCD(TWDR & 0b01111111);
    f1b4:	20 91 bb 00 	lds	r18, 0x00BB
    f1b8:	82 2f       	mov	r24, r18
    f1ba:	8f 77       	andi	r24, 0x7F	; 127
    f1bc:	82 95       	swap	r24
    f1be:	8f 70       	andi	r24, 0x0F	; 15
    f1c0:	3a e0       	ldi	r19, 0x0A	; 10
    f1c2:	83 9f       	mul	r24, r19
    f1c4:	c0 01       	movw	r24, r0
    f1c6:	11 24       	eor	r1, r1
    f1c8:	2f 70       	andi	r18, 0x0F	; 15
    f1ca:	28 0f       	add	r18, r24
    f1cc:	20 93 51 06 	sts	0x0651, r18
			AcknTWI();
    f1d0:	84 ec       	ldi	r24, 0xC4	; 196
    f1d2:	80 93 bc 00 	sts	0x00BC, r24
    f1d6:	c8 ce       	rjmp	.-624    	; 0xef68 <TWI_In+0x46>

0000f1d8 <TimeInit>:

// ~~~~~~~~
void
WdtOn(void)
{
	wdt_reset();
    f1d8:	a8 95       	wdr
	wdt_enable(WDTO_2S);
    f1da:	2f e0       	ldi	r18, 0x0F	; 15
    f1dc:	88 e1       	ldi	r24, 0x18	; 24
    f1de:	90 e0       	ldi	r25, 0x00	; 0
    f1e0:	0f b6       	in	r0, 0x3f	; 63
    f1e2:	f8 94       	cli
    f1e4:	a8 95       	wdr
    f1e6:	80 93 60 00 	sts	0x0060, r24
    f1ea:	0f be       	out	0x3f, r0	; 63
    f1ec:	20 93 60 00 	sts	0x0060, r18

	// WDT
	WdtOn();

	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TCCR1A = 0;
    f1f0:	10 92 80 00 	sts	0x0080, r1
		TCCR1B = (((~(1<<WGM13) |(1<<WGM12)) &~(1<<CS12)) |(1<<CS11)) &~(1<<CS10);
    f1f4:	8a ee       	ldi	r24, 0xEA	; 234
    f1f6:	80 93 81 00 	sts	0x0081, r24
		OCR1A = 20000;
    f1fa:	80 e2       	ldi	r24, 0x20	; 32
    f1fc:	9e e4       	ldi	r25, 0x4E	; 78
    f1fe:	90 93 89 00 	sts	0x0089, r25
    f202:	80 93 88 00 	sts	0x0088, r24
		TCC0.CTRLE = ~TC0_BYTEM_bm;
	#endif
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__)
		TIMSK |=(1<<OCIE1A);
	#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TIMSK1 |=(1<<OCIE1A);
    f206:	80 91 6f 00 	lds	r24, 0x006F
    f20a:	82 60       	ori	r24, 0x02	; 2
    f20c:	80 93 6f 00 	sts	0x006F, r24
    f210:	80 e0       	ldi	r24, 0x00	; 0
    f212:	90 e0       	ldi	r25, 0x00	; 0
	#endif

	// Program timers (10 ms)
	uint8_t i;
	for (i=0; i<sizeof(Timer8Flg); i++)
		Timer8Flg[i] = 0xFF;
    f214:	2f ef       	ldi	r18, 0xFF	; 255
    f216:	fc 01       	movw	r30, r24
    f218:	ef 54       	subi	r30, 0x4F	; 79
    f21a:	fb 4f       	sbci	r31, 0xFB	; 251
    f21c:	20 83       	st	Z, r18
    f21e:	01 96       	adiw	r24, 0x01	; 1
		TCC0.INTCTRLB = 0;
	#endif

	// Program timers (10 ms)
	uint8_t i;
	for (i=0; i<sizeof(Timer8Flg); i++)
    f220:	8c 30       	cpi	r24, 0x0C	; 12
    f222:	91 05       	cpc	r25, r1
    f224:	c1 f7       	brne	.-16     	; 0xf216 <TimeInit+0x3e>
    f226:	80 e0       	ldi	r24, 0x00	; 0
    f228:	90 e0       	ldi	r25, 0x00	; 0
		Timer8Flg[i] = 0xFF;
	for (i=0; i<sizeof(Timer16Flg); i++)
		Timer16Flg[i] = 0xFF;
    f22a:	3f ef       	ldi	r19, 0xFF	; 255
    f22c:	fc 01       	movw	r30, r24
    f22e:	e3 54       	subi	r30, 0x43	; 67
    f230:	fb 4f       	sbci	r31, 0xFB	; 251
    f232:	2f ef       	ldi	r18, 0xFF	; 255
    f234:	30 83       	st	Z, r19
    f236:	01 96       	adiw	r24, 0x01	; 1

	// Program timers (10 ms)
	uint8_t i;
	for (i=0; i<sizeof(Timer8Flg); i++)
		Timer8Flg[i] = 0xFF;
	for (i=0; i<sizeof(Timer16Flg); i++)
    f238:	8d 30       	cpi	r24, 0x0D	; 13
    f23a:	91 05       	cpc	r25, r1
    f23c:	b9 f7       	brne	.-18     	; 0xf22c <TimeInit+0x54>
		Timer16Flg[i] = 0xFF;
	for (i=0; i<sizeof(Timer32Flg); i++)
		Timer32Flg[i] = 0xFF;
    f23e:	20 93 ca 04 	sts	0x04CA, r18
    f242:	20 93 cb 04 	sts	0x04CB, r18
    f246:	20 93 cc 04 	sts	0x04CC, r18
    f24a:	20 93 cd 04 	sts	0x04CD, r18
    f24e:	20 93 ce 04 	sts	0x04CE, r18
    f252:	20 93 cf 04 	sts	0x04CF, r18
    f256:	8d e9       	ldi	r24, 0x9D	; 157
    f258:	91 e0       	ldi	r25, 0x01	; 1
    f25a:	0e 94 50 87 	call	0x10ea0	; 0x10ea0 <__eerd_byte_m2560>

	// 1 s
	Timer1min = erb(&Timer1min_EE);
    f25e:	80 93 b0 06 	sts	0x06B0, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    f262:	8e e9       	ldi	r24, 0x9E	; 158
    f264:	91 e0       	ldi	r25, 0x01	; 1
    f266:	0e 94 5e 87 	call	0x10ebc	; 0x10ebc <__eerd_word_m2560>
	Timer1hour = erw(&Timer1hour_EE);
    f26a:	90 93 6c 0c 	sts	0x0C6C, r25
    f26e:	80 93 6b 0c 	sts	0x0C6B, r24

	// Application
	#ifdef InitTimer
		StartTimer16(InitTimer, InitTime);
	#endif
}
    f272:	08 95       	ret

0000f274 <MemCheckInit>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    f274:	8c e9       	ldi	r24, 0x9C	; 156
    f276:	91 e0       	ldi	r25, 0x01	; 1
    f278:	0e 94 50 87 	call	0x10ea0	; 0x10ea0 <__eerd_byte_m2560>
// ~~~~~~~~~~~~~~~
void
MemCheckInit(void)
{
//	TD_Mem = Timer32SysAlloc(1);
	if (!erb(&MemCheck_stor.ReprogFlg)) {
    f27c:	81 11       	cpse	r24, r1
    f27e:	08 95       	ret
		eeprom_write_word(&MemCheck_stor.CRC_Flash_stor, CRC_Flash_calc());
    f280:	0e 94 09 1d 	call	0x3a12	; 0x3a12 <CRC_Flash_calc>
    f284:	bc 01       	movw	r22, r24
    f286:	88 e9       	ldi	r24, 0x98	; 152
    f288:	91 e0       	ldi	r25, 0x01	; 1
    f28a:	0e 94 84 87 	call	0x10f08	; 0x10f08 <__eewr_word_m2560>
		eeprom_write_word(&MemCheck_stor.CRC_EEPROM_stor, CRC_EEPROM_calc());
    f28e:	0e 94 23 1d 	call	0x3a46	; 0x3a46 <CRC_EEPROM_calc>
    f292:	bc 01       	movw	r22, r24
    f294:	8a e9       	ldi	r24, 0x9A	; 154
    f296:	91 e0       	ldi	r25, 0x01	; 1
    f298:	0e 94 84 87 	call	0x10f08	; 0x10f08 <__eewr_word_m2560>
		eeprom_write_byte(&MemCheck_stor.ReprogFlg, 1);
    f29c:	8c e9       	ldi	r24, 0x9C	; 156
    f29e:	91 e0       	ldi	r25, 0x01	; 1
    f2a0:	61 e0       	ldi	r22, 0x01	; 1
    f2a2:	0e 94 6e 87 	call	0x10edc	; 0x10edc <__eewr_byte_m2560>
    f2a6:	08 95       	ret

0000f2a8 <main>:
}

// ~~~~~~~
int
main(void)
{
    f2a8:	cf 93       	push	r28
    f2aa:	df 93       	push	r29
	TimeInit();
    f2ac:	0e 94 ec 78 	call	0xf1d8	; 0xf1d8 <TimeInit>
	TimersInc();
    f2b0:	0e 94 34 50 	call	0xa068	; 0xa068 <TimersInc>
	MemCheckInit();
    f2b4:	0e 94 3a 79 	call	0xf274	; 0xf274 <MemCheckInit>
	LED_Init();
    f2b8:	0e 94 36 29 	call	0x526c	; 0x526c <LED_Init>

	LCD_Init();
    f2bc:	0e 94 9b 76 	call	0xed36	; 0xed36 <LCD_Init>

	KeypadInit();
    f2c0:	0e 94 e7 3e 	call	0x7dce	; 0x7dce <KeypadInit>
	MenuInit();
    f2c4:	0e 94 35 40 	call	0x806a	; 0x806a <MenuInit>
InterruInit(void)
{
	#ifdef PMIC
		PMIC.CTRL = (uint8_t)(~PMIC_RREN_bm &~PMIC_IVSEL_bm) |PMIC_HILVLEN_bm |PMIC_MEDLVLEN_bm |PMIC_LOLVLEN_bm;
	#endif
	sei();
    f2c8:	78 94       	sei
	InterruInit();
	DigitInit();
    f2ca:	0e 94 58 41 	call	0x82b0	; 0x82b0 <DI_Init>
    f2ce:	0e 94 67 42 	call	0x84ce	; 0x84ce <DO_Init>
	HSC_Init();

	AI_Init();
    f2d2:	0e 94 7c 42 	call	0x84f8	; 0x84f8 <AI_Init>

	SPI_Init();
    f2d6:	0e 94 be 23 	call	0x477c	; 0x477c <SPI_Init>

	PWM_Init();
    f2da:	0e 94 8a 21 	call	0x4314	; 0x4314 <PWM_Init>
	TWI_Init();
    f2de:	0e 94 79 26 	call	0x4cf2	; 0x4cf2 <TWI_Init>
#ifdef QslRD
	SlaveRD_Init();
#endif

	do {
		TimersInc();
    f2e2:	0e 94 34 50 	call	0xa068	; 0xa068 <TimersInc>
		wdt_reset();
    f2e6:	a8 95       	wdr
		DigitIn();
    f2e8:	0e 94 21 54 	call	0xa842	; 0xa842 <DigitIn>
		TWI_In();
    f2ec:	0e 94 91 77 	call	0xef22	; 0xef22 <TWI_In>
	StopTWI();
	TWI_Phase = PCF_START;
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t RTC_Ready(void){
	if(TWI_Phase == PCF_START) return 1;
    f2f0:	80 91 c3 07 	lds	r24, 0x07C3
    f2f4:	88 23       	and	r24, r24
    f2f6:	11 f4       	brne	.+4      	; 0xf2fc <main+0x54>
		if(RTC_Ready()) RTC_GetTrueTime();
    f2f8:	0e 94 14 28 	call	0x5028	; 0x5028 <RTC_GetTrueTime>
		LCD_Sweep();
    f2fc:	0e 94 e2 65 	call	0xcbc4	; 0xcbc4 <LCD_Sweep>
	#ifdef TerIdx
	} while(ThermInit(AnalogIn()-TerIdx) || !RTC_Ready());
	#elif !defined ADC_Miss
		AnalogIn();
    f300:	0e 94 8d 42 	call	0x851a	; 0x851a <AnalogIn>
	} while( (ADC_OK&&ThermInit(ADC_In())) || !RTC_Ready() );
    f304:	80 91 2b 09 	lds	r24, 0x092B
    f308:	90 91 2c 09 	lds	r25, 0x092C
    f30c:	89 2b       	or	r24, r25
    f30e:	69 f4       	brne	.+26     	; 0xf32a <main+0x82>
    f310:	80 91 b4 07 	lds	r24, 0x07B4
    f314:	90 91 b5 07 	lds	r25, 0x07B5
    f318:	89 2b       	or	r24, r25
    f31a:	39 f4       	brne	.+14     	; 0xf32a <main+0x82>
    f31c:	80 91 f8 06 	lds	r24, 0x06F8
    f320:	90 91 f9 06 	lds	r25, 0x06F9
    f324:	89 2b       	or	r24, r25
    f326:	09 f4       	brne	.+2      	; 0xf32a <main+0x82>
    f328:	6c c0       	rjmp	.+216    	; 0xf402 <main+0x15a>
    f32a:	80 91 c3 07 	lds	r24, 0x07C3
    f32e:	88 23       	and	r24, r24
    f330:	c1 f6       	brne	.-80     	; 0xf2e2 <main+0x3a>
	#else
	} while((AnalogIn()!=AI_Reg-1) || !RTC_Ready());
	#endif

	MemCheckMsg();
    f332:	0e 94 11 53 	call	0xa622	; 0xa622 <MemCheckMsg>

	ApplInit();
    f336:	0e 94 e2 43 	call	0x87c4	; 0x87c4 <ApplInit>

	USART_Init();
    f33a:	0e 94 47 76 	call	0xec8e	; 0xec8e <USART_Init>
	ScanCycleInit();
    f33e:	0e 94 ce 20 	call	0x419c	; 0x419c <ScanCycleInit>
	if(TimerAllocError()) ShowMsg(&MsgErr41);
    f342:	0e 94 b2 20 	call	0x4164	; 0x4164 <TimerAllocError>
    f346:	88 23       	and	r24, r24
    f348:	09 f0       	breq	.+2      	; 0xf34c <main+0xa4>
    f34a:	63 c0       	rjmp	.+198    	; 0xf412 <main+0x16a>

// ~~~~~~~~~~~~~~~~
void
Therm_ADC_Off(void)
{
	for (uint8_t i=0; i<TerReg; Temperature[i++]=ADC_Off_Mark);
    f34c:	c1 e0       	ldi	r28, 0x01	; 1
    f34e:	d0 e8       	ldi	r29, 0x80	; 128
    f350:	12 c0       	rjmp	.+36     	; 0xf376 <main+0xce>
			if(ADC_Work&&ADC_Phase==ADC_OFF) {
				Therm_ADC_Off();
				ShowMsg(&MsgErr21);
				ADC_Work = 0;
			}
			ThermChan(ADC_In());
    f352:	0e 94 15 22 	call	0x442a	; 0x442a <ADC_In>
    f356:	0e 94 43 53 	call	0xa686	; 0xa686 <ThermChan>
		#endif
		ThermExt();
		TWI_In();
    f35a:	0e 94 91 77 	call	0xef22	; 0xef22 <TWI_In>

		USART_Cycle();
    f35e:	0e 94 bc 74 	call	0xe978	; 0xe978 <USART_Cycle>
#ifdef QslRD
		SlaveRD();
#endif
		ApplCycle();
    f362:	0e 94 19 52 	call	0xa432	; 0xa432 <ApplCycle>
		
		LCD_Sweep();
    f366:	0e 94 e2 65 	call	0xcbc4	; 0xcbc4 <LCD_Sweep>
		DigitOut();
    f36a:	0e 94 18 42 	call	0x8430	; 0x8430 <DigitOut>
		DAC_Out();
		PWM_Out();
    f36e:	0e 94 a9 21 	call	0x4352	; 0x4352 <PWM_Out>
		#ifdef BACKLIGHT
			LCDBackLightControl();
    f372:	0e 94 6e 2b 	call	0x56dc	; 0x56dc <LCDBackLightControl>
	USART_Init();
	ScanCycleInit();
	if(TimerAllocError()) ShowMsg(&MsgErr41);

	for(;;) {	
		TimersInc();
    f376:	0e 94 34 50 	call	0xa068	; 0xa068 <TimersInc>
		TimeCycle();
    f37a:	0e 94 2e 21 	call	0x425c	; 0x425c <TimeCycle>
// ~~~~~~~~~~~~~~
static void
KeypadSweep(void)
{
	static T_KeyAct KeyAct[] PROGMEM = KEYS;
	T_KeyAct KA = prp(KeyAct+KeypadIn());
    f37e:	0e 94 fa 3e 	call	0x7df4	; 0x7df4 <KeypadIn>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    f382:	e8 2f       	mov	r30, r24
    f384:	f0 e0       	ldi	r31, 0x00	; 0
    f386:	ee 0f       	add	r30, r30
    f388:	ff 1f       	adc	r31, r31
    f38a:	e2 51       	subi	r30, 0x12	; 18
    f38c:	f0 4d       	sbci	r31, 0xD0	; 208
    f38e:	85 91       	lpm	r24, Z+
    f390:	94 91       	lpm	r25, Z+
	if(KA){
    f392:	00 97       	sbiw	r24, 0x00	; 0
    f394:	31 f0       	breq	.+12     	; 0xf3a2 <main+0xfa>
		KA();
    f396:	fc 01       	movw	r30, r24
    f398:	19 95       	eicall
		#ifdef BACKLIGHT
			if(BackLightMode == 1){
    f39a:	80 91 52 06 	lds	r24, 0x0652
    f39e:	81 30       	cpi	r24, 0x01	; 1
    f3a0:	59 f1       	breq	.+86     	; 0xf3f8 <main+0x150>
	for(;;) {	
		TimersInc();
		TimeCycle();

		KeypadSweep();
		DigitIn();
    f3a2:	0e 94 21 54 	call	0xa842	; 0xa842 <DigitIn>
		HSC_In();
		#ifdef TerIdx
			ThermChan(AnalogIn()-TerIdx);
		#else
			AnalogIn();
    f3a6:	0e 94 8d 42 	call	0x851a	; 0x851a <AnalogIn>
		#endif
		#if !defined ADC_Miss && !defined TerIdx
			static uint8_t ADC_Work = 1;
			if(ADC_Work&&ADC_Phase==ADC_OFF) {
    f3aa:	80 91 d8 02 	lds	r24, 0x02D8
    f3ae:	88 23       	and	r24, r24
    f3b0:	81 f2       	breq	.-96     	; 0xf352 <main+0xaa>
    f3b2:	80 91 6a 0b 	lds	r24, 0x0B6A
    f3b6:	84 30       	cpi	r24, 0x04	; 4
    f3b8:	61 f6       	brne	.-104    	; 0xf352 <main+0xaa>
    f3ba:	d0 93 46 06 	sts	0x0646, r29
    f3be:	c0 93 45 06 	sts	0x0645, r28
    f3c2:	d0 93 48 06 	sts	0x0648, r29
    f3c6:	c0 93 47 06 	sts	0x0647, r28
    f3ca:	d0 93 4a 06 	sts	0x064A, r29
    f3ce:	c0 93 49 06 	sts	0x0649, r28
    f3d2:	d0 93 4c 06 	sts	0x064C, r29
    f3d6:	c0 93 4b 06 	sts	0x064B, r28
    f3da:	d0 93 4e 06 	sts	0x064E, r29
    f3de:	c0 93 4d 06 	sts	0x064D, r28
    f3e2:	d0 93 50 06 	sts	0x0650, r29
    f3e6:	c0 93 4f 06 	sts	0x064F, r28
				Therm_ADC_Off();
				ShowMsg(&MsgErr21);
    f3ea:	8a e7       	ldi	r24, 0x7A	; 122
    f3ec:	98 e0       	ldi	r25, 0x08	; 8
    f3ee:	0e 94 24 40 	call	0x8048	; 0x8048 <ShowMsg>
				ADC_Work = 0;
    f3f2:	10 92 d8 02 	sts	0x02D8, r1
    f3f6:	ad cf       	rjmp	.-166    	; 0xf352 <main+0xaa>
	T_KeyAct KA = prp(KeyAct+KeypadIn());
	if(KA){
		KA();
		#ifdef BACKLIGHT
			if(BackLightMode == 1){
				LCDBackLightOn();
    f3f8:	0e 94 52 2b 	call	0x56a4	; 0x56a4 <LCDBackLightOn>
				LCDBackLightStartTimer();
    f3fc:	0e 94 4c 76 	call	0xec98	; 0xec98 <LCDBackLightStartTimer>
    f400:	d0 cf       	rjmp	.-96     	; 0xf3a2 <main+0xfa>
		LCD_Sweep();
	#ifdef TerIdx
	} while(ThermInit(AnalogIn()-TerIdx) || !RTC_Ready());
	#elif !defined ADC_Miss
		AnalogIn();
	} while( (ADC_OK&&ThermInit(ADC_In())) || !RTC_Ready() );
    f402:	0e 94 15 22 	call	0x442a	; 0x442a <ADC_In>
    f406:	0e 94 df 53 	call	0xa7be	; 0xa7be <ThermInit>
    f40a:	88 23       	and	r24, r24
    f40c:	09 f0       	breq	.+2      	; 0xf410 <main+0x168>
    f40e:	69 cf       	rjmp	.-302    	; 0xf2e2 <main+0x3a>
    f410:	8c cf       	rjmp	.-232    	; 0xf32a <main+0x82>

	ApplInit();

	USART_Init();
	ScanCycleInit();
	if(TimerAllocError()) ShowMsg(&MsgErr41);
    f412:	8f e2       	ldi	r24, 0x2F	; 47
    f414:	9a e1       	ldi	r25, 0x1A	; 26
    f416:	0e 94 24 40 	call	0x8048	; 0x8048 <ShowMsg>
    f41a:	98 cf       	rjmp	.-208    	; 0xf34c <main+0xa4>

0000f41c <EEMEMBackUpOk>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    f41c:	80 e0       	ldi	r24, 0x00	; 0
    f41e:	90 e0       	ldi	r25, 0x00	; 0
    f420:	0e 94 50 87 	call	0x10ea0	; 0x10ea0 <__eerd_byte_m2560>
	uint8_t Month;
	uint8_t Year;
}DateBackUp EEMEM = {0xFF,0xFF,0xFF};

uint8_t EEMEMBackUpOk(void){
	if( (erb(&DateBackUp.Day)==0xFF) || (erb(&DateBackUp.Month)==0xFF) || (erb(&DateBackUp.Year)== 0xFF) ) return 0;
    f424:	8f 3f       	cpi	r24, 0xFF	; 255
    f426:	81 f0       	breq	.+32     	; 0xf448 <EEMEMBackUpOk+0x2c>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    f428:	81 e0       	ldi	r24, 0x01	; 1
    f42a:	90 e0       	ldi	r25, 0x00	; 0
    f42c:	0e 94 50 87 	call	0x10ea0	; 0x10ea0 <__eerd_byte_m2560>
	uint8_t Month;
	uint8_t Year;
}DateBackUp EEMEM = {0xFF,0xFF,0xFF};

uint8_t EEMEMBackUpOk(void){
	if( (erb(&DateBackUp.Day)==0xFF) || (erb(&DateBackUp.Month)==0xFF) || (erb(&DateBackUp.Year)== 0xFF) ) return 0;
    f430:	8f 3f       	cpi	r24, 0xFF	; 255
    f432:	51 f0       	breq	.+20     	; 0xf448 <EEMEMBackUpOk+0x2c>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    f434:	82 e0       	ldi	r24, 0x02	; 2
    f436:	90 e0       	ldi	r25, 0x00	; 0
    f438:	0e 94 50 87 	call	0x10ea0	; 0x10ea0 <__eerd_byte_m2560>
    f43c:	90 e0       	ldi	r25, 0x00	; 0
    f43e:	8f 3f       	cpi	r24, 0xFF	; 255
    f440:	21 f0       	breq	.+8      	; 0xf44a <EEMEMBackUpOk+0x2e>
    f442:	91 e0       	ldi	r25, 0x01	; 1
}DateBackUp EEMEM = {0xFF,0xFF,0xFF};

uint8_t EEMEMBackUpOk(void){
	if( (erb(&DateBackUp.Day)==0xFF) || (erb(&DateBackUp.Month)==0xFF) || (erb(&DateBackUp.Year)== 0xFF) ) return 0;
	else return 1;
}
    f444:	89 2f       	mov	r24, r25
    f446:	08 95       	ret
	uint8_t Month;
	uint8_t Year;
}DateBackUp EEMEM = {0xFF,0xFF,0xFF};

uint8_t EEMEMBackUpOk(void){
	if( (erb(&DateBackUp.Day)==0xFF) || (erb(&DateBackUp.Month)==0xFF) || (erb(&DateBackUp.Year)== 0xFF) ) return 0;
    f448:	90 e0       	ldi	r25, 0x00	; 0
	else return 1;
}
    f44a:	89 2f       	mov	r24, r25
    f44c:	08 95       	ret

0000f44e <Menu_BackUp_Enter>:
			NULL, NULL, NULL, Menu_ConfirmationRest_Enter, NULL, NULL, NULL};
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	//		  
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	uint8_t Menu_BackUp_Enter(){
		switch(CurrLine){
    f44e:	80 91 ca 07 	lds	r24, 0x07CA
    f452:	82 30       	cpi	r24, 0x02	; 2
    f454:	11 f0       	breq	.+4      	; 0xf45a <Menu_BackUp_Enter+0xc>
			}
			NextPage = &Menu_ConfirmationRestore;
			break;
		}
		return StandartKey;
	}
    f456:	80 e0       	ldi	r24, 0x00	; 0
    f458:	08 95       	ret
	//		  
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	uint8_t Menu_BackUp_Enter(){
		switch(CurrLine){
		case 2:
			if(!EEMEMBackUpOk()){
    f45a:	0e 94 0e 7a 	call	0xf41c	; 0xf41c <EEMEMBackUpOk>
    f45e:	88 23       	and	r24, r24
    f460:	59 f4       	brne	.+22     	; 0xf478 <Menu_BackUp_Enter+0x2a>
				//   EEPROM,   BackUp- -  
				if(MemFail & 1<<MemFail_EEPROM){
    f462:	80 91 17 09 	lds	r24, 0x0917
    f466:	81 ff       	sbrs	r24, 1
    f468:	0f c0       	rjmp	.+30     	; 0xf488 <Menu_BackUp_Enter+0x3a>
					MemFailReset();
    f46a:	0e 94 a4 4f 	call	0x9f48	; 0x9f48 <MemFailReset>
					ShowMsg(&Msg_EEWarning);
    f46e:	8b e3       	ldi	r24, 0x3B	; 59
    f470:	93 e1       	ldi	r25, 0x13	; 19
    f472:	0e 94 24 40 	call	0x8048	; 0x8048 <ShowMsg>
    f476:	ef cf       	rjmp	.-34     	; 0xf456 <Menu_BackUp_Enter+0x8>
				}
				else ShowMsg(&Msg_NoBackUp);
				break;
			}
			NextPage = &Menu_ConfirmationRestore;
    f478:	8b ee       	ldi	r24, 0xEB	; 235
    f47a:	94 e1       	ldi	r25, 0x14	; 20
    f47c:	90 93 da 05 	sts	0x05DA, r25
    f480:	80 93 d9 05 	sts	0x05D9, r24
			break;
		}
		return StandartKey;
	}
    f484:	80 e0       	ldi	r24, 0x00	; 0
    f486:	08 95       	ret
				//   EEPROM,   BackUp- -  
				if(MemFail & 1<<MemFail_EEPROM){
					MemFailReset();
					ShowMsg(&Msg_EEWarning);
				}
				else ShowMsg(&Msg_NoBackUp);
    f488:	8d e9       	ldi	r24, 0x9D	; 157
    f48a:	93 e1       	ldi	r25, 0x13	; 19
    f48c:	0e 94 24 40 	call	0x8048	; 0x8048 <ShowMsg>
    f490:	e2 cf       	rjmp	.-60     	; 0xf456 <Menu_BackUp_Enter+0x8>

0000f492 <vfprintf>:
    f492:	2f 92       	push	r2
    f494:	3f 92       	push	r3
    f496:	4f 92       	push	r4
    f498:	5f 92       	push	r5
    f49a:	6f 92       	push	r6
    f49c:	7f 92       	push	r7
    f49e:	8f 92       	push	r8
    f4a0:	9f 92       	push	r9
    f4a2:	af 92       	push	r10
    f4a4:	bf 92       	push	r11
    f4a6:	cf 92       	push	r12
    f4a8:	df 92       	push	r13
    f4aa:	ef 92       	push	r14
    f4ac:	ff 92       	push	r15
    f4ae:	0f 93       	push	r16
    f4b0:	1f 93       	push	r17
    f4b2:	df 93       	push	r29
    f4b4:	cf 93       	push	r28
    f4b6:	cd b7       	in	r28, 0x3d	; 61
    f4b8:	de b7       	in	r29, 0x3e	; 62
    f4ba:	61 97       	sbiw	r28, 0x11	; 17
    f4bc:	0f b6       	in	r0, 0x3f	; 63
    f4be:	f8 94       	cli
    f4c0:	de bf       	out	0x3e, r29	; 62
    f4c2:	0f be       	out	0x3f, r0	; 63
    f4c4:	cd bf       	out	0x3d, r28	; 61
    f4c6:	3c 01       	movw	r6, r24
    f4c8:	7f 87       	std	Y+15, r23	; 0x0f
    f4ca:	6e 87       	std	Y+14, r22	; 0x0e
    f4cc:	6a 01       	movw	r12, r20
    f4ce:	fc 01       	movw	r30, r24
    f4d0:	17 82       	std	Z+7, r1	; 0x07
    f4d2:	16 82       	std	Z+6, r1	; 0x06
    f4d4:	83 81       	ldd	r24, Z+3	; 0x03
    f4d6:	81 fd       	sbrc	r24, 1
    f4d8:	03 c0       	rjmp	.+6      	; 0xf4e0 <vfprintf+0x4e>
    f4da:	6f ef       	ldi	r22, 0xFF	; 255
    f4dc:	7f ef       	ldi	r23, 0xFF	; 255
    f4de:	6f c3       	rjmp	.+1758   	; 0xfbbe <vfprintf+0x72c>
    f4e0:	9e 01       	movw	r18, r28
    f4e2:	2f 5f       	subi	r18, 0xFF	; 255
    f4e4:	3f 4f       	sbci	r19, 0xFF	; 255
    f4e6:	39 8b       	std	Y+17, r19	; 0x11
    f4e8:	28 8b       	std	Y+16, r18	; 0x10
    f4ea:	f3 01       	movw	r30, r6
    f4ec:	23 81       	ldd	r18, Z+3	; 0x03
    f4ee:	ee 85       	ldd	r30, Y+14	; 0x0e
    f4f0:	ff 85       	ldd	r31, Y+15	; 0x0f
    f4f2:	23 fd       	sbrc	r18, 3
    f4f4:	85 91       	lpm	r24, Z+
    f4f6:	23 ff       	sbrs	r18, 3
    f4f8:	81 91       	ld	r24, Z+
    f4fa:	ff 87       	std	Y+15, r31	; 0x0f
    f4fc:	ee 87       	std	Y+14, r30	; 0x0e
    f4fe:	88 23       	and	r24, r24
    f500:	09 f4       	brne	.+2      	; 0xf504 <vfprintf+0x72>
    f502:	5a c3       	rjmp	.+1716   	; 0xfbb8 <vfprintf+0x726>
    f504:	85 32       	cpi	r24, 0x25	; 37
    f506:	51 f4       	brne	.+20     	; 0xf51c <vfprintf+0x8a>
    f508:	ee 85       	ldd	r30, Y+14	; 0x0e
    f50a:	ff 85       	ldd	r31, Y+15	; 0x0f
    f50c:	23 fd       	sbrc	r18, 3
    f50e:	85 91       	lpm	r24, Z+
    f510:	23 ff       	sbrs	r18, 3
    f512:	81 91       	ld	r24, Z+
    f514:	ff 87       	std	Y+15, r31	; 0x0f
    f516:	ee 87       	std	Y+14, r30	; 0x0e
    f518:	85 32       	cpi	r24, 0x25	; 37
    f51a:	29 f4       	brne	.+10     	; 0xf526 <vfprintf+0x94>
    f51c:	90 e0       	ldi	r25, 0x00	; 0
    f51e:	b3 01       	movw	r22, r6
    f520:	0e 94 f6 84 	call	0x109ec	; 0x109ec <fputc>
    f524:	e2 cf       	rjmp	.-60     	; 0xf4ea <vfprintf+0x58>
    f526:	98 2f       	mov	r25, r24
    f528:	10 e0       	ldi	r17, 0x00	; 0
    f52a:	88 24       	eor	r8, r8
    f52c:	99 24       	eor	r9, r9
    f52e:	10 32       	cpi	r17, 0x20	; 32
    f530:	b0 f4       	brcc	.+44     	; 0xf55e <vfprintf+0xcc>
    f532:	9b 32       	cpi	r25, 0x2B	; 43
    f534:	69 f0       	breq	.+26     	; 0xf550 <vfprintf+0xbe>
    f536:	9c 32       	cpi	r25, 0x2C	; 44
    f538:	28 f4       	brcc	.+10     	; 0xf544 <vfprintf+0xb2>
    f53a:	90 32       	cpi	r25, 0x20	; 32
    f53c:	51 f0       	breq	.+20     	; 0xf552 <vfprintf+0xc0>
    f53e:	93 32       	cpi	r25, 0x23	; 35
    f540:	71 f4       	brne	.+28     	; 0xf55e <vfprintf+0xcc>
    f542:	0b c0       	rjmp	.+22     	; 0xf55a <vfprintf+0xc8>
    f544:	9d 32       	cpi	r25, 0x2D	; 45
    f546:	39 f0       	breq	.+14     	; 0xf556 <vfprintf+0xc4>
    f548:	90 33       	cpi	r25, 0x30	; 48
    f54a:	49 f4       	brne	.+18     	; 0xf55e <vfprintf+0xcc>
    f54c:	11 60       	ori	r17, 0x01	; 1
    f54e:	28 c0       	rjmp	.+80     	; 0xf5a0 <vfprintf+0x10e>
    f550:	12 60       	ori	r17, 0x02	; 2
    f552:	14 60       	ori	r17, 0x04	; 4
    f554:	25 c0       	rjmp	.+74     	; 0xf5a0 <vfprintf+0x10e>
    f556:	18 60       	ori	r17, 0x08	; 8
    f558:	23 c0       	rjmp	.+70     	; 0xf5a0 <vfprintf+0x10e>
    f55a:	10 61       	ori	r17, 0x10	; 16
    f55c:	21 c0       	rjmp	.+66     	; 0xf5a0 <vfprintf+0x10e>
    f55e:	17 fd       	sbrc	r17, 7
    f560:	2a c0       	rjmp	.+84     	; 0xf5b6 <vfprintf+0x124>
    f562:	89 2f       	mov	r24, r25
    f564:	80 53       	subi	r24, 0x30	; 48
    f566:	8a 30       	cpi	r24, 0x0A	; 10
    f568:	78 f4       	brcc	.+30     	; 0xf588 <vfprintf+0xf6>
    f56a:	16 ff       	sbrs	r17, 6
    f56c:	06 c0       	rjmp	.+12     	; 0xf57a <vfprintf+0xe8>
    f56e:	fa e0       	ldi	r31, 0x0A	; 10
    f570:	9f 9e       	mul	r9, r31
    f572:	90 2c       	mov	r9, r0
    f574:	11 24       	eor	r1, r1
    f576:	98 0e       	add	r9, r24
    f578:	13 c0       	rjmp	.+38     	; 0xf5a0 <vfprintf+0x10e>
    f57a:	3a e0       	ldi	r19, 0x0A	; 10
    f57c:	83 9e       	mul	r8, r19
    f57e:	80 2c       	mov	r8, r0
    f580:	11 24       	eor	r1, r1
    f582:	88 0e       	add	r8, r24
    f584:	10 62       	ori	r17, 0x20	; 32
    f586:	0c c0       	rjmp	.+24     	; 0xf5a0 <vfprintf+0x10e>
    f588:	9e 32       	cpi	r25, 0x2E	; 46
    f58a:	21 f4       	brne	.+8      	; 0xf594 <vfprintf+0x102>
    f58c:	16 fd       	sbrc	r17, 6
    f58e:	14 c3       	rjmp	.+1576   	; 0xfbb8 <vfprintf+0x726>
    f590:	10 64       	ori	r17, 0x40	; 64
    f592:	06 c0       	rjmp	.+12     	; 0xf5a0 <vfprintf+0x10e>
    f594:	9c 36       	cpi	r25, 0x6C	; 108
    f596:	11 f4       	brne	.+4      	; 0xf59c <vfprintf+0x10a>
    f598:	10 68       	ori	r17, 0x80	; 128
    f59a:	02 c0       	rjmp	.+4      	; 0xf5a0 <vfprintf+0x10e>
    f59c:	98 36       	cpi	r25, 0x68	; 104
    f59e:	59 f4       	brne	.+22     	; 0xf5b6 <vfprintf+0x124>
    f5a0:	ee 85       	ldd	r30, Y+14	; 0x0e
    f5a2:	ff 85       	ldd	r31, Y+15	; 0x0f
    f5a4:	23 fd       	sbrc	r18, 3
    f5a6:	95 91       	lpm	r25, Z+
    f5a8:	23 ff       	sbrs	r18, 3
    f5aa:	91 91       	ld	r25, Z+
    f5ac:	ff 87       	std	Y+15, r31	; 0x0f
    f5ae:	ee 87       	std	Y+14, r30	; 0x0e
    f5b0:	99 23       	and	r25, r25
    f5b2:	09 f0       	breq	.+2      	; 0xf5b6 <vfprintf+0x124>
    f5b4:	bc cf       	rjmp	.-136    	; 0xf52e <vfprintf+0x9c>
    f5b6:	89 2f       	mov	r24, r25
    f5b8:	85 54       	subi	r24, 0x45	; 69
    f5ba:	83 30       	cpi	r24, 0x03	; 3
    f5bc:	20 f4       	brcc	.+8      	; 0xf5c6 <vfprintf+0x134>
    f5be:	81 2f       	mov	r24, r17
    f5c0:	80 61       	ori	r24, 0x10	; 16
    f5c2:	90 5e       	subi	r25, 0xE0	; 224
    f5c4:	07 c0       	rjmp	.+14     	; 0xf5d4 <vfprintf+0x142>
    f5c6:	89 2f       	mov	r24, r25
    f5c8:	85 56       	subi	r24, 0x65	; 101
    f5ca:	83 30       	cpi	r24, 0x03	; 3
    f5cc:	08 f0       	brcs	.+2      	; 0xf5d0 <vfprintf+0x13e>
    f5ce:	9f c1       	rjmp	.+830    	; 0xf90e <vfprintf+0x47c>
    f5d0:	81 2f       	mov	r24, r17
    f5d2:	8f 7e       	andi	r24, 0xEF	; 239
    f5d4:	86 fd       	sbrc	r24, 6
    f5d6:	02 c0       	rjmp	.+4      	; 0xf5dc <vfprintf+0x14a>
    f5d8:	76 e0       	ldi	r23, 0x06	; 6
    f5da:	97 2e       	mov	r9, r23
    f5dc:	6f e3       	ldi	r22, 0x3F	; 63
    f5de:	f6 2e       	mov	r15, r22
    f5e0:	f8 22       	and	r15, r24
    f5e2:	95 36       	cpi	r25, 0x65	; 101
    f5e4:	19 f4       	brne	.+6      	; 0xf5ec <vfprintf+0x15a>
    f5e6:	f0 e4       	ldi	r31, 0x40	; 64
    f5e8:	ff 2a       	or	r15, r31
    f5ea:	07 c0       	rjmp	.+14     	; 0xf5fa <vfprintf+0x168>
    f5ec:	96 36       	cpi	r25, 0x66	; 102
    f5ee:	19 f4       	brne	.+6      	; 0xf5f6 <vfprintf+0x164>
    f5f0:	20 e8       	ldi	r18, 0x80	; 128
    f5f2:	f2 2a       	or	r15, r18
    f5f4:	02 c0       	rjmp	.+4      	; 0xf5fa <vfprintf+0x168>
    f5f6:	91 10       	cpse	r9, r1
    f5f8:	9a 94       	dec	r9
    f5fa:	f7 fe       	sbrs	r15, 7
    f5fc:	0a c0       	rjmp	.+20     	; 0xf612 <vfprintf+0x180>
    f5fe:	3b e3       	ldi	r19, 0x3B	; 59
    f600:	39 15       	cp	r19, r9
    f602:	18 f4       	brcc	.+6      	; 0xf60a <vfprintf+0x178>
    f604:	5c e3       	ldi	r21, 0x3C	; 60
    f606:	b5 2e       	mov	r11, r21
    f608:	02 c0       	rjmp	.+4      	; 0xf60e <vfprintf+0x17c>
    f60a:	b9 2c       	mov	r11, r9
    f60c:	b3 94       	inc	r11
    f60e:	27 e0       	ldi	r18, 0x07	; 7
    f610:	09 c0       	rjmp	.+18     	; 0xf624 <vfprintf+0x192>
    f612:	47 e0       	ldi	r20, 0x07	; 7
    f614:	49 15       	cp	r20, r9
    f616:	20 f4       	brcc	.+8      	; 0xf620 <vfprintf+0x18e>
    f618:	bb 24       	eor	r11, r11
    f61a:	47 e0       	ldi	r20, 0x07	; 7
    f61c:	94 2e       	mov	r9, r20
    f61e:	f7 cf       	rjmp	.-18     	; 0xf60e <vfprintf+0x17c>
    f620:	29 2d       	mov	r18, r9
    f622:	bb 24       	eor	r11, r11
    f624:	c6 01       	movw	r24, r12
    f626:	04 96       	adiw	r24, 0x04	; 4
    f628:	9d 87       	std	Y+13, r25	; 0x0d
    f62a:	8c 87       	std	Y+12, r24	; 0x0c
    f62c:	f6 01       	movw	r30, r12
    f62e:	60 81       	ld	r22, Z
    f630:	71 81       	ldd	r23, Z+1	; 0x01
    f632:	82 81       	ldd	r24, Z+2	; 0x02
    f634:	93 81       	ldd	r25, Z+3	; 0x03
    f636:	ae 01       	movw	r20, r28
    f638:	4f 5f       	subi	r20, 0xFF	; 255
    f63a:	5f 4f       	sbci	r21, 0xFF	; 255
    f63c:	0b 2d       	mov	r16, r11
    f63e:	0e 94 33 83 	call	0x10666	; 0x10666 <__ftoa_engine>
    f642:	6c 01       	movw	r12, r24
    f644:	09 81       	ldd	r16, Y+1	; 0x01
    f646:	20 2e       	mov	r2, r16
    f648:	33 24       	eor	r3, r3
    f64a:	00 ff       	sbrs	r16, 0
    f64c:	04 c0       	rjmp	.+8      	; 0xf656 <vfprintf+0x1c4>
    f64e:	03 fd       	sbrc	r16, 3
    f650:	02 c0       	rjmp	.+4      	; 0xf656 <vfprintf+0x1c4>
    f652:	1d e2       	ldi	r17, 0x2D	; 45
    f654:	09 c0       	rjmp	.+18     	; 0xf668 <vfprintf+0x1d6>
    f656:	f1 fe       	sbrs	r15, 1
    f658:	02 c0       	rjmp	.+4      	; 0xf65e <vfprintf+0x1cc>
    f65a:	1b e2       	ldi	r17, 0x2B	; 43
    f65c:	05 c0       	rjmp	.+10     	; 0xf668 <vfprintf+0x1d6>
    f65e:	f2 fc       	sbrc	r15, 2
    f660:	02 c0       	rjmp	.+4      	; 0xf666 <vfprintf+0x1d4>
    f662:	10 e0       	ldi	r17, 0x00	; 0
    f664:	01 c0       	rjmp	.+2      	; 0xf668 <vfprintf+0x1d6>
    f666:	10 e2       	ldi	r17, 0x20	; 32
    f668:	c1 01       	movw	r24, r2
    f66a:	8c 70       	andi	r24, 0x0C	; 12
    f66c:	90 70       	andi	r25, 0x00	; 0
    f66e:	89 2b       	or	r24, r25
    f670:	b9 f1       	breq	.+110    	; 0xf6e0 <vfprintf+0x24e>
    f672:	11 23       	and	r17, r17
    f674:	11 f4       	brne	.+4      	; 0xf67a <vfprintf+0x1e8>
    f676:	83 e0       	ldi	r24, 0x03	; 3
    f678:	01 c0       	rjmp	.+2      	; 0xf67c <vfprintf+0x1ea>
    f67a:	84 e0       	ldi	r24, 0x04	; 4
    f67c:	88 15       	cp	r24, r8
    f67e:	10 f0       	brcs	.+4      	; 0xf684 <vfprintf+0x1f2>
    f680:	88 24       	eor	r8, r8
    f682:	0a c0       	rjmp	.+20     	; 0xf698 <vfprintf+0x206>
    f684:	88 1a       	sub	r8, r24
    f686:	f3 fc       	sbrc	r15, 3
    f688:	07 c0       	rjmp	.+14     	; 0xf698 <vfprintf+0x206>
    f68a:	80 e2       	ldi	r24, 0x20	; 32
    f68c:	90 e0       	ldi	r25, 0x00	; 0
    f68e:	b3 01       	movw	r22, r6
    f690:	0e 94 f6 84 	call	0x109ec	; 0x109ec <fputc>
    f694:	8a 94       	dec	r8
    f696:	c9 f7       	brne	.-14     	; 0xf68a <vfprintf+0x1f8>
    f698:	11 23       	and	r17, r17
    f69a:	29 f0       	breq	.+10     	; 0xf6a6 <vfprintf+0x214>
    f69c:	81 2f       	mov	r24, r17
    f69e:	90 e0       	ldi	r25, 0x00	; 0
    f6a0:	b3 01       	movw	r22, r6
    f6a2:	0e 94 f6 84 	call	0x109ec	; 0x109ec <fputc>
    f6a6:	23 fe       	sbrs	r2, 3
    f6a8:	03 c0       	rjmp	.+6      	; 0xf6b0 <vfprintf+0x21e>
    f6aa:	0e ec       	ldi	r16, 0xCE	; 206
    f6ac:	12 e0       	ldi	r17, 0x02	; 2
    f6ae:	0e c0       	rjmp	.+28     	; 0xf6cc <vfprintf+0x23a>
    f6b0:	02 ed       	ldi	r16, 0xD2	; 210
    f6b2:	12 e0       	ldi	r17, 0x02	; 2
    f6b4:	0b c0       	rjmp	.+22     	; 0xf6cc <vfprintf+0x23a>
    f6b6:	e1 14       	cp	r14, r1
    f6b8:	f1 04       	cpc	r15, r1
    f6ba:	09 f0       	breq	.+2      	; 0xf6be <vfprintf+0x22c>
    f6bc:	80 52       	subi	r24, 0x20	; 32
    f6be:	90 e0       	ldi	r25, 0x00	; 0
    f6c0:	b3 01       	movw	r22, r6
    f6c2:	0e 94 f6 84 	call	0x109ec	; 0x109ec <fputc>
    f6c6:	0f 5f       	subi	r16, 0xFF	; 255
    f6c8:	1f 4f       	sbci	r17, 0xFF	; 255
    f6ca:	05 c0       	rjmp	.+10     	; 0xf6d6 <vfprintf+0x244>
    f6cc:	ef 2c       	mov	r14, r15
    f6ce:	ff 24       	eor	r15, r15
    f6d0:	f0 e1       	ldi	r31, 0x10	; 16
    f6d2:	ef 22       	and	r14, r31
    f6d4:	ff 24       	eor	r15, r15
    f6d6:	f8 01       	movw	r30, r16
    f6d8:	84 91       	lpm	r24, Z+
    f6da:	88 23       	and	r24, r24
    f6dc:	61 f7       	brne	.-40     	; 0xf6b6 <vfprintf+0x224>
    f6de:	14 c1       	rjmp	.+552    	; 0xf908 <vfprintf+0x476>
    f6e0:	f7 fe       	sbrs	r15, 7
    f6e2:	12 c0       	rjmp	.+36     	; 0xf708 <vfprintf+0x276>
    f6e4:	bc 0c       	add	r11, r12
    f6e6:	24 fe       	sbrs	r2, 4
    f6e8:	04 c0       	rjmp	.+8      	; 0xf6f2 <vfprintf+0x260>
    f6ea:	8a 81       	ldd	r24, Y+2	; 0x02
    f6ec:	81 33       	cpi	r24, 0x31	; 49
    f6ee:	09 f4       	brne	.+2      	; 0xf6f2 <vfprintf+0x260>
    f6f0:	ba 94       	dec	r11
    f6f2:	1b 14       	cp	r1, r11
    f6f4:	1c f0       	brlt	.+6      	; 0xf6fc <vfprintf+0x26a>
    f6f6:	bb 24       	eor	r11, r11
    f6f8:	b3 94       	inc	r11
    f6fa:	2d c0       	rjmp	.+90     	; 0xf756 <vfprintf+0x2c4>
    f6fc:	f8 e0       	ldi	r31, 0x08	; 8
    f6fe:	fb 15       	cp	r31, r11
    f700:	50 f5       	brcc	.+84     	; 0xf756 <vfprintf+0x2c4>
    f702:	38 e0       	ldi	r19, 0x08	; 8
    f704:	b3 2e       	mov	r11, r19
    f706:	27 c0       	rjmp	.+78     	; 0xf756 <vfprintf+0x2c4>
    f708:	f6 fc       	sbrc	r15, 6
    f70a:	25 c0       	rjmp	.+74     	; 0xf756 <vfprintf+0x2c4>
    f70c:	89 2d       	mov	r24, r9
    f70e:	90 e0       	ldi	r25, 0x00	; 0
    f710:	8c 15       	cp	r24, r12
    f712:	9d 05       	cpc	r25, r13
    f714:	4c f0       	brlt	.+18     	; 0xf728 <vfprintf+0x296>
    f716:	2c ef       	ldi	r18, 0xFC	; 252
    f718:	c2 16       	cp	r12, r18
    f71a:	2f ef       	ldi	r18, 0xFF	; 255
    f71c:	d2 06       	cpc	r13, r18
    f71e:	24 f0       	brlt	.+8      	; 0xf728 <vfprintf+0x296>
    f720:	30 e8       	ldi	r19, 0x80	; 128
    f722:	f3 2a       	or	r15, r19
    f724:	01 c0       	rjmp	.+2      	; 0xf728 <vfprintf+0x296>
    f726:	9a 94       	dec	r9
    f728:	99 20       	and	r9, r9
    f72a:	49 f0       	breq	.+18     	; 0xf73e <vfprintf+0x2ac>
    f72c:	e2 e0       	ldi	r30, 0x02	; 2
    f72e:	f0 e0       	ldi	r31, 0x00	; 0
    f730:	ec 0f       	add	r30, r28
    f732:	fd 1f       	adc	r31, r29
    f734:	e9 0d       	add	r30, r9
    f736:	f1 1d       	adc	r31, r1
    f738:	80 81       	ld	r24, Z
    f73a:	80 33       	cpi	r24, 0x30	; 48
    f73c:	a1 f3       	breq	.-24     	; 0xf726 <vfprintf+0x294>
    f73e:	f7 fe       	sbrs	r15, 7
    f740:	0a c0       	rjmp	.+20     	; 0xf756 <vfprintf+0x2c4>
    f742:	b9 2c       	mov	r11, r9
    f744:	b3 94       	inc	r11
    f746:	89 2d       	mov	r24, r9
    f748:	90 e0       	ldi	r25, 0x00	; 0
    f74a:	c8 16       	cp	r12, r24
    f74c:	d9 06       	cpc	r13, r25
    f74e:	14 f0       	brlt	.+4      	; 0xf754 <vfprintf+0x2c2>
    f750:	99 24       	eor	r9, r9
    f752:	01 c0       	rjmp	.+2      	; 0xf756 <vfprintf+0x2c4>
    f754:	9c 18       	sub	r9, r12
    f756:	f7 fc       	sbrc	r15, 7
    f758:	03 c0       	rjmp	.+6      	; 0xf760 <vfprintf+0x2ce>
    f75a:	25 e0       	ldi	r18, 0x05	; 5
    f75c:	30 e0       	ldi	r19, 0x00	; 0
    f75e:	09 c0       	rjmp	.+18     	; 0xf772 <vfprintf+0x2e0>
    f760:	1c 14       	cp	r1, r12
    f762:	1d 04       	cpc	r1, r13
    f764:	1c f0       	brlt	.+6      	; 0xf76c <vfprintf+0x2da>
    f766:	21 e0       	ldi	r18, 0x01	; 1
    f768:	30 e0       	ldi	r19, 0x00	; 0
    f76a:	03 c0       	rjmp	.+6      	; 0xf772 <vfprintf+0x2e0>
    f76c:	96 01       	movw	r18, r12
    f76e:	2f 5f       	subi	r18, 0xFF	; 255
    f770:	3f 4f       	sbci	r19, 0xFF	; 255
    f772:	11 23       	and	r17, r17
    f774:	11 f0       	breq	.+4      	; 0xf77a <vfprintf+0x2e8>
    f776:	2f 5f       	subi	r18, 0xFF	; 255
    f778:	3f 4f       	sbci	r19, 0xFF	; 255
    f77a:	99 20       	and	r9, r9
    f77c:	29 f0       	breq	.+10     	; 0xf788 <vfprintf+0x2f6>
    f77e:	89 2d       	mov	r24, r9
    f780:	90 e0       	ldi	r25, 0x00	; 0
    f782:	01 96       	adiw	r24, 0x01	; 1
    f784:	28 0f       	add	r18, r24
    f786:	39 1f       	adc	r19, r25
    f788:	88 2d       	mov	r24, r8
    f78a:	90 e0       	ldi	r25, 0x00	; 0
    f78c:	28 17       	cp	r18, r24
    f78e:	39 07       	cpc	r19, r25
    f790:	14 f0       	brlt	.+4      	; 0xf796 <vfprintf+0x304>
    f792:	88 24       	eor	r8, r8
    f794:	01 c0       	rjmp	.+2      	; 0xf798 <vfprintf+0x306>
    f796:	82 1a       	sub	r8, r18
    f798:	4f 2c       	mov	r4, r15
    f79a:	55 24       	eor	r5, r5
    f79c:	c2 01       	movw	r24, r4
    f79e:	89 70       	andi	r24, 0x09	; 9
    f7a0:	90 70       	andi	r25, 0x00	; 0
    f7a2:	89 2b       	or	r24, r25
    f7a4:	39 f0       	breq	.+14     	; 0xf7b4 <vfprintf+0x322>
    f7a6:	08 c0       	rjmp	.+16     	; 0xf7b8 <vfprintf+0x326>
    f7a8:	80 e2       	ldi	r24, 0x20	; 32
    f7aa:	90 e0       	ldi	r25, 0x00	; 0
    f7ac:	b3 01       	movw	r22, r6
    f7ae:	0e 94 f6 84 	call	0x109ec	; 0x109ec <fputc>
    f7b2:	8a 94       	dec	r8
    f7b4:	88 20       	and	r8, r8
    f7b6:	c1 f7       	brne	.-16     	; 0xf7a8 <vfprintf+0x316>
    f7b8:	11 23       	and	r17, r17
    f7ba:	29 f0       	breq	.+10     	; 0xf7c6 <vfprintf+0x334>
    f7bc:	81 2f       	mov	r24, r17
    f7be:	90 e0       	ldi	r25, 0x00	; 0
    f7c0:	b3 01       	movw	r22, r6
    f7c2:	0e 94 f6 84 	call	0x109ec	; 0x109ec <fputc>
    f7c6:	43 fe       	sbrs	r4, 3
    f7c8:	07 c0       	rjmp	.+14     	; 0xf7d8 <vfprintf+0x346>
    f7ca:	08 c0       	rjmp	.+16     	; 0xf7dc <vfprintf+0x34a>
    f7cc:	80 e3       	ldi	r24, 0x30	; 48
    f7ce:	90 e0       	ldi	r25, 0x00	; 0
    f7d0:	b3 01       	movw	r22, r6
    f7d2:	0e 94 f6 84 	call	0x109ec	; 0x109ec <fputc>
    f7d6:	8a 94       	dec	r8
    f7d8:	88 20       	and	r8, r8
    f7da:	c1 f7       	brne	.-16     	; 0xf7cc <vfprintf+0x33a>
    f7dc:	f7 fe       	sbrs	r15, 7
    f7de:	46 c0       	rjmp	.+140    	; 0xf86c <vfprintf+0x3da>
    f7e0:	86 01       	movw	r16, r12
    f7e2:	d7 fe       	sbrs	r13, 7
    f7e4:	02 c0       	rjmp	.+4      	; 0xf7ea <vfprintf+0x358>
    f7e6:	00 e0       	ldi	r16, 0x00	; 0
    f7e8:	10 e0       	ldi	r17, 0x00	; 0
    f7ea:	76 01       	movw	r14, r12
    f7ec:	08 94       	sec
    f7ee:	e1 1c       	adc	r14, r1
    f7f0:	f1 1c       	adc	r15, r1
    f7f2:	e0 1a       	sub	r14, r16
    f7f4:	f1 0a       	sbc	r15, r17
    f7f6:	41 e0       	ldi	r20, 0x01	; 1
    f7f8:	50 e0       	ldi	r21, 0x00	; 0
    f7fa:	4c 0f       	add	r20, r28
    f7fc:	5d 1f       	adc	r21, r29
    f7fe:	e4 0e       	add	r14, r20
    f800:	f5 1e       	adc	r15, r21
    f802:	26 01       	movw	r4, r12
    f804:	4b 18       	sub	r4, r11
    f806:	51 08       	sbc	r5, r1
    f808:	89 2d       	mov	r24, r9
    f80a:	90 e0       	ldi	r25, 0x00	; 0
    f80c:	aa 24       	eor	r10, r10
    f80e:	bb 24       	eor	r11, r11
    f810:	a8 1a       	sub	r10, r24
    f812:	b9 0a       	sbc	r11, r25
    f814:	5f ef       	ldi	r21, 0xFF	; 255
    f816:	0f 3f       	cpi	r16, 0xFF	; 255
    f818:	15 07       	cpc	r17, r21
    f81a:	29 f4       	brne	.+10     	; 0xf826 <vfprintf+0x394>
    f81c:	8e e2       	ldi	r24, 0x2E	; 46
    f81e:	90 e0       	ldi	r25, 0x00	; 0
    f820:	b3 01       	movw	r22, r6
    f822:	0e 94 f6 84 	call	0x109ec	; 0x109ec <fputc>
    f826:	c0 16       	cp	r12, r16
    f828:	d1 06       	cpc	r13, r17
    f82a:	34 f0       	brlt	.+12     	; 0xf838 <vfprintf+0x3a6>
    f82c:	40 16       	cp	r4, r16
    f82e:	51 06       	cpc	r5, r17
    f830:	1c f4       	brge	.+6      	; 0xf838 <vfprintf+0x3a6>
    f832:	f7 01       	movw	r30, r14
    f834:	80 81       	ld	r24, Z
    f836:	01 c0       	rjmp	.+2      	; 0xf83a <vfprintf+0x3a8>
    f838:	80 e3       	ldi	r24, 0x30	; 48
    f83a:	01 50       	subi	r16, 0x01	; 1
    f83c:	10 40       	sbci	r17, 0x00	; 0
    f83e:	08 94       	sec
    f840:	e1 1c       	adc	r14, r1
    f842:	f1 1c       	adc	r15, r1
    f844:	0a 15       	cp	r16, r10
    f846:	1b 05       	cpc	r17, r11
    f848:	2c f0       	brlt	.+10     	; 0xf854 <vfprintf+0x3c2>
    f84a:	90 e0       	ldi	r25, 0x00	; 0
    f84c:	b3 01       	movw	r22, r6
    f84e:	0e 94 f6 84 	call	0x109ec	; 0x109ec <fputc>
    f852:	e0 cf       	rjmp	.-64     	; 0xf814 <vfprintf+0x382>
    f854:	0c 15       	cp	r16, r12
    f856:	1d 05       	cpc	r17, r13
    f858:	39 f4       	brne	.+14     	; 0xf868 <vfprintf+0x3d6>
    f85a:	9a 81       	ldd	r25, Y+2	; 0x02
    f85c:	96 33       	cpi	r25, 0x36	; 54
    f85e:	18 f4       	brcc	.+6      	; 0xf866 <vfprintf+0x3d4>
    f860:	95 33       	cpi	r25, 0x35	; 53
    f862:	11 f4       	brne	.+4      	; 0xf868 <vfprintf+0x3d6>
    f864:	24 fe       	sbrs	r2, 4
    f866:	81 e3       	ldi	r24, 0x31	; 49
    f868:	90 e0       	ldi	r25, 0x00	; 0
    f86a:	4b c0       	rjmp	.+150    	; 0xf902 <vfprintf+0x470>
    f86c:	8a 81       	ldd	r24, Y+2	; 0x02
    f86e:	81 33       	cpi	r24, 0x31	; 49
    f870:	09 f0       	breq	.+2      	; 0xf874 <vfprintf+0x3e2>
    f872:	0f 7e       	andi	r16, 0xEF	; 239
    f874:	90 e0       	ldi	r25, 0x00	; 0
    f876:	b3 01       	movw	r22, r6
    f878:	0e 94 f6 84 	call	0x109ec	; 0x109ec <fputc>
    f87c:	99 20       	and	r9, r9
    f87e:	a1 f0       	breq	.+40     	; 0xf8a8 <vfprintf+0x416>
    f880:	8e e2       	ldi	r24, 0x2E	; 46
    f882:	90 e0       	ldi	r25, 0x00	; 0
    f884:	b3 01       	movw	r22, r6
    f886:	0e 94 f6 84 	call	0x109ec	; 0x109ec <fputc>
    f88a:	12 e0       	ldi	r17, 0x02	; 2
    f88c:	e1 e0       	ldi	r30, 0x01	; 1
    f88e:	f0 e0       	ldi	r31, 0x00	; 0
    f890:	ec 0f       	add	r30, r28
    f892:	fd 1f       	adc	r31, r29
    f894:	e1 0f       	add	r30, r17
    f896:	f1 1d       	adc	r31, r1
    f898:	1f 5f       	subi	r17, 0xFF	; 255
    f89a:	80 81       	ld	r24, Z
    f89c:	90 e0       	ldi	r25, 0x00	; 0
    f89e:	b3 01       	movw	r22, r6
    f8a0:	0e 94 f6 84 	call	0x109ec	; 0x109ec <fputc>
    f8a4:	9a 94       	dec	r9
    f8a6:	91 f7       	brne	.-28     	; 0xf88c <vfprintf+0x3fa>
    f8a8:	44 fc       	sbrc	r4, 4
    f8aa:	03 c0       	rjmp	.+6      	; 0xf8b2 <vfprintf+0x420>
    f8ac:	85 e6       	ldi	r24, 0x65	; 101
    f8ae:	90 e0       	ldi	r25, 0x00	; 0
    f8b0:	02 c0       	rjmp	.+4      	; 0xf8b6 <vfprintf+0x424>
    f8b2:	85 e4       	ldi	r24, 0x45	; 69
    f8b4:	90 e0       	ldi	r25, 0x00	; 0
    f8b6:	b3 01       	movw	r22, r6
    f8b8:	0e 94 f6 84 	call	0x109ec	; 0x109ec <fputc>
    f8bc:	d7 fc       	sbrc	r13, 7
    f8be:	05 c0       	rjmp	.+10     	; 0xf8ca <vfprintf+0x438>
    f8c0:	c1 14       	cp	r12, r1
    f8c2:	d1 04       	cpc	r13, r1
    f8c4:	41 f4       	brne	.+16     	; 0xf8d6 <vfprintf+0x444>
    f8c6:	04 ff       	sbrs	r16, 4
    f8c8:	06 c0       	rjmp	.+12     	; 0xf8d6 <vfprintf+0x444>
    f8ca:	d0 94       	com	r13
    f8cc:	c1 94       	neg	r12
    f8ce:	d1 08       	sbc	r13, r1
    f8d0:	d3 94       	inc	r13
    f8d2:	8d e2       	ldi	r24, 0x2D	; 45
    f8d4:	01 c0       	rjmp	.+2      	; 0xf8d8 <vfprintf+0x446>
    f8d6:	8b e2       	ldi	r24, 0x2B	; 43
    f8d8:	90 e0       	ldi	r25, 0x00	; 0
    f8da:	b3 01       	movw	r22, r6
    f8dc:	0e 94 f6 84 	call	0x109ec	; 0x109ec <fputc>
    f8e0:	80 e3       	ldi	r24, 0x30	; 48
    f8e2:	05 c0       	rjmp	.+10     	; 0xf8ee <vfprintf+0x45c>
    f8e4:	8f 5f       	subi	r24, 0xFF	; 255
    f8e6:	26 ef       	ldi	r18, 0xF6	; 246
    f8e8:	3f ef       	ldi	r19, 0xFF	; 255
    f8ea:	c2 0e       	add	r12, r18
    f8ec:	d3 1e       	adc	r13, r19
    f8ee:	3a e0       	ldi	r19, 0x0A	; 10
    f8f0:	c3 16       	cp	r12, r19
    f8f2:	d1 04       	cpc	r13, r1
    f8f4:	bc f7       	brge	.-18     	; 0xf8e4 <vfprintf+0x452>
    f8f6:	90 e0       	ldi	r25, 0x00	; 0
    f8f8:	b3 01       	movw	r22, r6
    f8fa:	0e 94 f6 84 	call	0x109ec	; 0x109ec <fputc>
    f8fe:	c6 01       	movw	r24, r12
    f900:	c0 96       	adiw	r24, 0x30	; 48
    f902:	b3 01       	movw	r22, r6
    f904:	0e 94 f6 84 	call	0x109ec	; 0x109ec <fputc>
    f908:	cc 84       	ldd	r12, Y+12	; 0x0c
    f90a:	dd 84       	ldd	r13, Y+13	; 0x0d
    f90c:	52 c1       	rjmp	.+676    	; 0xfbb2 <vfprintf+0x720>
    f90e:	93 36       	cpi	r25, 0x63	; 99
    f910:	31 f0       	breq	.+12     	; 0xf91e <vfprintf+0x48c>
    f912:	93 37       	cpi	r25, 0x73	; 115
    f914:	99 f0       	breq	.+38     	; 0xf93c <vfprintf+0x4aa>
    f916:	93 35       	cpi	r25, 0x53	; 83
    f918:	09 f0       	breq	.+2      	; 0xf91c <vfprintf+0x48a>
    f91a:	59 c0       	rjmp	.+178    	; 0xf9ce <vfprintf+0x53c>
    f91c:	23 c0       	rjmp	.+70     	; 0xf964 <vfprintf+0x4d2>
    f91e:	f6 01       	movw	r30, r12
    f920:	80 81       	ld	r24, Z
    f922:	89 83       	std	Y+1, r24	; 0x01
    f924:	5e 01       	movw	r10, r28
    f926:	08 94       	sec
    f928:	a1 1c       	adc	r10, r1
    f92a:	b1 1c       	adc	r11, r1
    f92c:	22 e0       	ldi	r18, 0x02	; 2
    f92e:	30 e0       	ldi	r19, 0x00	; 0
    f930:	c2 0e       	add	r12, r18
    f932:	d3 1e       	adc	r13, r19
    f934:	21 e0       	ldi	r18, 0x01	; 1
    f936:	e2 2e       	mov	r14, r18
    f938:	f1 2c       	mov	r15, r1
    f93a:	12 c0       	rjmp	.+36     	; 0xf960 <vfprintf+0x4ce>
    f93c:	f6 01       	movw	r30, r12
    f93e:	a0 80       	ld	r10, Z
    f940:	b1 80       	ldd	r11, Z+1	; 0x01
    f942:	16 fd       	sbrc	r17, 6
    f944:	03 c0       	rjmp	.+6      	; 0xf94c <vfprintf+0x4ba>
    f946:	6f ef       	ldi	r22, 0xFF	; 255
    f948:	7f ef       	ldi	r23, 0xFF	; 255
    f94a:	02 c0       	rjmp	.+4      	; 0xf950 <vfprintf+0x4be>
    f94c:	69 2d       	mov	r22, r9
    f94e:	70 e0       	ldi	r23, 0x00	; 0
    f950:	22 e0       	ldi	r18, 0x02	; 2
    f952:	30 e0       	ldi	r19, 0x00	; 0
    f954:	c2 0e       	add	r12, r18
    f956:	d3 1e       	adc	r13, r19
    f958:	c5 01       	movw	r24, r10
    f95a:	0e 94 8f 84 	call	0x1091e	; 0x1091e <strnlen>
    f95e:	7c 01       	movw	r14, r24
    f960:	1f 77       	andi	r17, 0x7F	; 127
    f962:	13 c0       	rjmp	.+38     	; 0xf98a <vfprintf+0x4f8>
    f964:	f6 01       	movw	r30, r12
    f966:	a0 80       	ld	r10, Z
    f968:	b1 80       	ldd	r11, Z+1	; 0x01
    f96a:	16 fd       	sbrc	r17, 6
    f96c:	03 c0       	rjmp	.+6      	; 0xf974 <vfprintf+0x4e2>
    f96e:	6f ef       	ldi	r22, 0xFF	; 255
    f970:	7f ef       	ldi	r23, 0xFF	; 255
    f972:	02 c0       	rjmp	.+4      	; 0xf978 <vfprintf+0x4e6>
    f974:	69 2d       	mov	r22, r9
    f976:	70 e0       	ldi	r23, 0x00	; 0
    f978:	22 e0       	ldi	r18, 0x02	; 2
    f97a:	30 e0       	ldi	r19, 0x00	; 0
    f97c:	c2 0e       	add	r12, r18
    f97e:	d3 1e       	adc	r13, r19
    f980:	c5 01       	movw	r24, r10
    f982:	0e 94 4d 84 	call	0x1089a	; 0x1089a <strnlen_P>
    f986:	7c 01       	movw	r14, r24
    f988:	10 68       	ori	r17, 0x80	; 128
    f98a:	13 ff       	sbrs	r17, 3
    f98c:	07 c0       	rjmp	.+14     	; 0xf99c <vfprintf+0x50a>
    f98e:	1b c0       	rjmp	.+54     	; 0xf9c6 <vfprintf+0x534>
    f990:	80 e2       	ldi	r24, 0x20	; 32
    f992:	90 e0       	ldi	r25, 0x00	; 0
    f994:	b3 01       	movw	r22, r6
    f996:	0e 94 f6 84 	call	0x109ec	; 0x109ec <fputc>
    f99a:	8a 94       	dec	r8
    f99c:	88 2d       	mov	r24, r8
    f99e:	90 e0       	ldi	r25, 0x00	; 0
    f9a0:	e8 16       	cp	r14, r24
    f9a2:	f9 06       	cpc	r15, r25
    f9a4:	a8 f3       	brcs	.-22     	; 0xf990 <vfprintf+0x4fe>
    f9a6:	0f c0       	rjmp	.+30     	; 0xf9c6 <vfprintf+0x534>
    f9a8:	f5 01       	movw	r30, r10
    f9aa:	17 fd       	sbrc	r17, 7
    f9ac:	85 91       	lpm	r24, Z+
    f9ae:	17 ff       	sbrs	r17, 7
    f9b0:	81 91       	ld	r24, Z+
    f9b2:	5f 01       	movw	r10, r30
    f9b4:	90 e0       	ldi	r25, 0x00	; 0
    f9b6:	b3 01       	movw	r22, r6
    f9b8:	0e 94 f6 84 	call	0x109ec	; 0x109ec <fputc>
    f9bc:	81 10       	cpse	r8, r1
    f9be:	8a 94       	dec	r8
    f9c0:	08 94       	sec
    f9c2:	e1 08       	sbc	r14, r1
    f9c4:	f1 08       	sbc	r15, r1
    f9c6:	e1 14       	cp	r14, r1
    f9c8:	f1 04       	cpc	r15, r1
    f9ca:	71 f7       	brne	.-36     	; 0xf9a8 <vfprintf+0x516>
    f9cc:	f2 c0       	rjmp	.+484    	; 0xfbb2 <vfprintf+0x720>
    f9ce:	94 36       	cpi	r25, 0x64	; 100
    f9d0:	11 f0       	breq	.+4      	; 0xf9d6 <vfprintf+0x544>
    f9d2:	99 36       	cpi	r25, 0x69	; 105
    f9d4:	89 f5       	brne	.+98     	; 0xfa38 <vfprintf+0x5a6>
    f9d6:	17 ff       	sbrs	r17, 7
    f9d8:	08 c0       	rjmp	.+16     	; 0xf9ea <vfprintf+0x558>
    f9da:	f6 01       	movw	r30, r12
    f9dc:	20 81       	ld	r18, Z
    f9de:	31 81       	ldd	r19, Z+1	; 0x01
    f9e0:	42 81       	ldd	r20, Z+2	; 0x02
    f9e2:	53 81       	ldd	r21, Z+3	; 0x03
    f9e4:	84 e0       	ldi	r24, 0x04	; 4
    f9e6:	90 e0       	ldi	r25, 0x00	; 0
    f9e8:	0a c0       	rjmp	.+20     	; 0xf9fe <vfprintf+0x56c>
    f9ea:	f6 01       	movw	r30, r12
    f9ec:	80 81       	ld	r24, Z
    f9ee:	91 81       	ldd	r25, Z+1	; 0x01
    f9f0:	9c 01       	movw	r18, r24
    f9f2:	44 27       	eor	r20, r20
    f9f4:	37 fd       	sbrc	r19, 7
    f9f6:	40 95       	com	r20
    f9f8:	54 2f       	mov	r21, r20
    f9fa:	82 e0       	ldi	r24, 0x02	; 2
    f9fc:	90 e0       	ldi	r25, 0x00	; 0
    f9fe:	c8 0e       	add	r12, r24
    fa00:	d9 1e       	adc	r13, r25
    fa02:	9f e6       	ldi	r25, 0x6F	; 111
    fa04:	f9 2e       	mov	r15, r25
    fa06:	f1 22       	and	r15, r17
    fa08:	57 ff       	sbrs	r21, 7
    fa0a:	09 c0       	rjmp	.+18     	; 0xfa1e <vfprintf+0x58c>
    fa0c:	50 95       	com	r21
    fa0e:	40 95       	com	r20
    fa10:	30 95       	com	r19
    fa12:	21 95       	neg	r18
    fa14:	3f 4f       	sbci	r19, 0xFF	; 255
    fa16:	4f 4f       	sbci	r20, 0xFF	; 255
    fa18:	5f 4f       	sbci	r21, 0xFF	; 255
    fa1a:	90 e8       	ldi	r25, 0x80	; 128
    fa1c:	f9 2a       	or	r15, r25
    fa1e:	ca 01       	movw	r24, r20
    fa20:	b9 01       	movw	r22, r18
    fa22:	ae 01       	movw	r20, r28
    fa24:	4f 5f       	subi	r20, 0xFF	; 255
    fa26:	5f 4f       	sbci	r21, 0xFF	; 255
    fa28:	2a e0       	ldi	r18, 0x0A	; 10
    fa2a:	30 e0       	ldi	r19, 0x00	; 0
    fa2c:	0e 94 e4 85 	call	0x10bc8	; 0x10bc8 <__ultoa_invert>
    fa30:	e8 2e       	mov	r14, r24
    fa32:	e8 89       	ldd	r30, Y+16	; 0x10
    fa34:	ee 1a       	sub	r14, r30
    fa36:	41 c0       	rjmp	.+130    	; 0xfaba <vfprintf+0x628>
    fa38:	95 37       	cpi	r25, 0x75	; 117
    fa3a:	21 f4       	brne	.+8      	; 0xfa44 <vfprintf+0x5b2>
    fa3c:	1f 7e       	andi	r17, 0xEF	; 239
    fa3e:	2a e0       	ldi	r18, 0x0A	; 10
    fa40:	30 e0       	ldi	r19, 0x00	; 0
    fa42:	1c c0       	rjmp	.+56     	; 0xfa7c <vfprintf+0x5ea>
    fa44:	19 7f       	andi	r17, 0xF9	; 249
    fa46:	9f 36       	cpi	r25, 0x6F	; 111
    fa48:	61 f0       	breq	.+24     	; 0xfa62 <vfprintf+0x5d0>
    fa4a:	90 37       	cpi	r25, 0x70	; 112
    fa4c:	20 f4       	brcc	.+8      	; 0xfa56 <vfprintf+0x5c4>
    fa4e:	98 35       	cpi	r25, 0x58	; 88
    fa50:	09 f0       	breq	.+2      	; 0xfa54 <vfprintf+0x5c2>
    fa52:	b2 c0       	rjmp	.+356    	; 0xfbb8 <vfprintf+0x726>
    fa54:	0f c0       	rjmp	.+30     	; 0xfa74 <vfprintf+0x5e2>
    fa56:	90 37       	cpi	r25, 0x70	; 112
    fa58:	39 f0       	breq	.+14     	; 0xfa68 <vfprintf+0x5d6>
    fa5a:	98 37       	cpi	r25, 0x78	; 120
    fa5c:	09 f0       	breq	.+2      	; 0xfa60 <vfprintf+0x5ce>
    fa5e:	ac c0       	rjmp	.+344    	; 0xfbb8 <vfprintf+0x726>
    fa60:	04 c0       	rjmp	.+8      	; 0xfa6a <vfprintf+0x5d8>
    fa62:	28 e0       	ldi	r18, 0x08	; 8
    fa64:	30 e0       	ldi	r19, 0x00	; 0
    fa66:	0a c0       	rjmp	.+20     	; 0xfa7c <vfprintf+0x5ea>
    fa68:	10 61       	ori	r17, 0x10	; 16
    fa6a:	14 fd       	sbrc	r17, 4
    fa6c:	14 60       	ori	r17, 0x04	; 4
    fa6e:	20 e1       	ldi	r18, 0x10	; 16
    fa70:	30 e0       	ldi	r19, 0x00	; 0
    fa72:	04 c0       	rjmp	.+8      	; 0xfa7c <vfprintf+0x5ea>
    fa74:	14 fd       	sbrc	r17, 4
    fa76:	16 60       	ori	r17, 0x06	; 6
    fa78:	20 e1       	ldi	r18, 0x10	; 16
    fa7a:	32 e0       	ldi	r19, 0x02	; 2
    fa7c:	17 ff       	sbrs	r17, 7
    fa7e:	08 c0       	rjmp	.+16     	; 0xfa90 <vfprintf+0x5fe>
    fa80:	f6 01       	movw	r30, r12
    fa82:	60 81       	ld	r22, Z
    fa84:	71 81       	ldd	r23, Z+1	; 0x01
    fa86:	82 81       	ldd	r24, Z+2	; 0x02
    fa88:	93 81       	ldd	r25, Z+3	; 0x03
    fa8a:	44 e0       	ldi	r20, 0x04	; 4
    fa8c:	50 e0       	ldi	r21, 0x00	; 0
    fa8e:	08 c0       	rjmp	.+16     	; 0xfaa0 <vfprintf+0x60e>
    fa90:	f6 01       	movw	r30, r12
    fa92:	80 81       	ld	r24, Z
    fa94:	91 81       	ldd	r25, Z+1	; 0x01
    fa96:	bc 01       	movw	r22, r24
    fa98:	80 e0       	ldi	r24, 0x00	; 0
    fa9a:	90 e0       	ldi	r25, 0x00	; 0
    fa9c:	42 e0       	ldi	r20, 0x02	; 2
    fa9e:	50 e0       	ldi	r21, 0x00	; 0
    faa0:	c4 0e       	add	r12, r20
    faa2:	d5 1e       	adc	r13, r21
    faa4:	ae 01       	movw	r20, r28
    faa6:	4f 5f       	subi	r20, 0xFF	; 255
    faa8:	5f 4f       	sbci	r21, 0xFF	; 255
    faaa:	0e 94 e4 85 	call	0x10bc8	; 0x10bc8 <__ultoa_invert>
    faae:	e8 2e       	mov	r14, r24
    fab0:	58 89       	ldd	r21, Y+16	; 0x10
    fab2:	e5 1a       	sub	r14, r21
    fab4:	8f e7       	ldi	r24, 0x7F	; 127
    fab6:	f8 2e       	mov	r15, r24
    fab8:	f1 22       	and	r15, r17
    faba:	f6 fe       	sbrs	r15, 6
    fabc:	0b c0       	rjmp	.+22     	; 0xfad4 <vfprintf+0x642>
    fabe:	8e ef       	ldi	r24, 0xFE	; 254
    fac0:	f8 22       	and	r15, r24
    fac2:	e9 14       	cp	r14, r9
    fac4:	38 f4       	brcc	.+14     	; 0xfad4 <vfprintf+0x642>
    fac6:	f4 fe       	sbrs	r15, 4
    fac8:	07 c0       	rjmp	.+14     	; 0xfad8 <vfprintf+0x646>
    faca:	f2 fc       	sbrc	r15, 2
    facc:	05 c0       	rjmp	.+10     	; 0xfad8 <vfprintf+0x646>
    face:	9f ee       	ldi	r25, 0xEF	; 239
    fad0:	f9 22       	and	r15, r25
    fad2:	02 c0       	rjmp	.+4      	; 0xfad8 <vfprintf+0x646>
    fad4:	1e 2d       	mov	r17, r14
    fad6:	01 c0       	rjmp	.+2      	; 0xfada <vfprintf+0x648>
    fad8:	19 2d       	mov	r17, r9
    fada:	f4 fe       	sbrs	r15, 4
    fadc:	0d c0       	rjmp	.+26     	; 0xfaf8 <vfprintf+0x666>
    fade:	fe 01       	movw	r30, r28
    fae0:	ee 0d       	add	r30, r14
    fae2:	f1 1d       	adc	r31, r1
    fae4:	80 81       	ld	r24, Z
    fae6:	80 33       	cpi	r24, 0x30	; 48
    fae8:	19 f4       	brne	.+6      	; 0xfaf0 <vfprintf+0x65e>
    faea:	e9 ee       	ldi	r30, 0xE9	; 233
    faec:	fe 22       	and	r15, r30
    faee:	08 c0       	rjmp	.+16     	; 0xfb00 <vfprintf+0x66e>
    faf0:	1f 5f       	subi	r17, 0xFF	; 255
    faf2:	f2 fe       	sbrs	r15, 2
    faf4:	05 c0       	rjmp	.+10     	; 0xfb00 <vfprintf+0x66e>
    faf6:	03 c0       	rjmp	.+6      	; 0xfafe <vfprintf+0x66c>
    faf8:	8f 2d       	mov	r24, r15
    fafa:	86 78       	andi	r24, 0x86	; 134
    fafc:	09 f0       	breq	.+2      	; 0xfb00 <vfprintf+0x66e>
    fafe:	1f 5f       	subi	r17, 0xFF	; 255
    fb00:	0f 2d       	mov	r16, r15
    fb02:	f3 fc       	sbrc	r15, 3
    fb04:	14 c0       	rjmp	.+40     	; 0xfb2e <vfprintf+0x69c>
    fb06:	f0 fe       	sbrs	r15, 0
    fb08:	0f c0       	rjmp	.+30     	; 0xfb28 <vfprintf+0x696>
    fb0a:	18 15       	cp	r17, r8
    fb0c:	10 f0       	brcs	.+4      	; 0xfb12 <vfprintf+0x680>
    fb0e:	9e 2c       	mov	r9, r14
    fb10:	0b c0       	rjmp	.+22     	; 0xfb28 <vfprintf+0x696>
    fb12:	9e 2c       	mov	r9, r14
    fb14:	98 0c       	add	r9, r8
    fb16:	91 1a       	sub	r9, r17
    fb18:	18 2d       	mov	r17, r8
    fb1a:	06 c0       	rjmp	.+12     	; 0xfb28 <vfprintf+0x696>
    fb1c:	80 e2       	ldi	r24, 0x20	; 32
    fb1e:	90 e0       	ldi	r25, 0x00	; 0
    fb20:	b3 01       	movw	r22, r6
    fb22:	0e 94 f6 84 	call	0x109ec	; 0x109ec <fputc>
    fb26:	1f 5f       	subi	r17, 0xFF	; 255
    fb28:	18 15       	cp	r17, r8
    fb2a:	c0 f3       	brcs	.-16     	; 0xfb1c <vfprintf+0x68a>
    fb2c:	04 c0       	rjmp	.+8      	; 0xfb36 <vfprintf+0x6a4>
    fb2e:	18 15       	cp	r17, r8
    fb30:	10 f4       	brcc	.+4      	; 0xfb36 <vfprintf+0x6a4>
    fb32:	81 1a       	sub	r8, r17
    fb34:	01 c0       	rjmp	.+2      	; 0xfb38 <vfprintf+0x6a6>
    fb36:	88 24       	eor	r8, r8
    fb38:	04 ff       	sbrs	r16, 4
    fb3a:	0f c0       	rjmp	.+30     	; 0xfb5a <vfprintf+0x6c8>
    fb3c:	80 e3       	ldi	r24, 0x30	; 48
    fb3e:	90 e0       	ldi	r25, 0x00	; 0
    fb40:	b3 01       	movw	r22, r6
    fb42:	0e 94 f6 84 	call	0x109ec	; 0x109ec <fputc>
    fb46:	02 ff       	sbrs	r16, 2
    fb48:	1d c0       	rjmp	.+58     	; 0xfb84 <vfprintf+0x6f2>
    fb4a:	01 fd       	sbrc	r16, 1
    fb4c:	03 c0       	rjmp	.+6      	; 0xfb54 <vfprintf+0x6c2>
    fb4e:	88 e7       	ldi	r24, 0x78	; 120
    fb50:	90 e0       	ldi	r25, 0x00	; 0
    fb52:	0e c0       	rjmp	.+28     	; 0xfb70 <vfprintf+0x6de>
    fb54:	88 e5       	ldi	r24, 0x58	; 88
    fb56:	90 e0       	ldi	r25, 0x00	; 0
    fb58:	0b c0       	rjmp	.+22     	; 0xfb70 <vfprintf+0x6de>
    fb5a:	80 2f       	mov	r24, r16
    fb5c:	86 78       	andi	r24, 0x86	; 134
    fb5e:	91 f0       	breq	.+36     	; 0xfb84 <vfprintf+0x6f2>
    fb60:	01 ff       	sbrs	r16, 1
    fb62:	02 c0       	rjmp	.+4      	; 0xfb68 <vfprintf+0x6d6>
    fb64:	8b e2       	ldi	r24, 0x2B	; 43
    fb66:	01 c0       	rjmp	.+2      	; 0xfb6a <vfprintf+0x6d8>
    fb68:	80 e2       	ldi	r24, 0x20	; 32
    fb6a:	f7 fc       	sbrc	r15, 7
    fb6c:	8d e2       	ldi	r24, 0x2D	; 45
    fb6e:	90 e0       	ldi	r25, 0x00	; 0
    fb70:	b3 01       	movw	r22, r6
    fb72:	0e 94 f6 84 	call	0x109ec	; 0x109ec <fputc>
    fb76:	06 c0       	rjmp	.+12     	; 0xfb84 <vfprintf+0x6f2>
    fb78:	80 e3       	ldi	r24, 0x30	; 48
    fb7a:	90 e0       	ldi	r25, 0x00	; 0
    fb7c:	b3 01       	movw	r22, r6
    fb7e:	0e 94 f6 84 	call	0x109ec	; 0x109ec <fputc>
    fb82:	9a 94       	dec	r9
    fb84:	e9 14       	cp	r14, r9
    fb86:	c0 f3       	brcs	.-16     	; 0xfb78 <vfprintf+0x6e6>
    fb88:	ea 94       	dec	r14
    fb8a:	e1 e0       	ldi	r30, 0x01	; 1
    fb8c:	f0 e0       	ldi	r31, 0x00	; 0
    fb8e:	ec 0f       	add	r30, r28
    fb90:	fd 1f       	adc	r31, r29
    fb92:	ee 0d       	add	r30, r14
    fb94:	f1 1d       	adc	r31, r1
    fb96:	80 81       	ld	r24, Z
    fb98:	90 e0       	ldi	r25, 0x00	; 0
    fb9a:	b3 01       	movw	r22, r6
    fb9c:	0e 94 f6 84 	call	0x109ec	; 0x109ec <fputc>
    fba0:	ee 20       	and	r14, r14
    fba2:	91 f7       	brne	.-28     	; 0xfb88 <vfprintf+0x6f6>
    fba4:	06 c0       	rjmp	.+12     	; 0xfbb2 <vfprintf+0x720>
    fba6:	80 e2       	ldi	r24, 0x20	; 32
    fba8:	90 e0       	ldi	r25, 0x00	; 0
    fbaa:	b3 01       	movw	r22, r6
    fbac:	0e 94 f6 84 	call	0x109ec	; 0x109ec <fputc>
    fbb0:	8a 94       	dec	r8
    fbb2:	88 20       	and	r8, r8
    fbb4:	c1 f7       	brne	.-16     	; 0xfba6 <vfprintf+0x714>
    fbb6:	99 cc       	rjmp	.-1742   	; 0xf4ea <vfprintf+0x58>
    fbb8:	f3 01       	movw	r30, r6
    fbba:	66 81       	ldd	r22, Z+6	; 0x06
    fbbc:	77 81       	ldd	r23, Z+7	; 0x07
    fbbe:	cb 01       	movw	r24, r22
    fbc0:	61 96       	adiw	r28, 0x11	; 17
    fbc2:	0f b6       	in	r0, 0x3f	; 63
    fbc4:	f8 94       	cli
    fbc6:	de bf       	out	0x3e, r29	; 62
    fbc8:	0f be       	out	0x3f, r0	; 63
    fbca:	cd bf       	out	0x3d, r28	; 61
    fbcc:	cf 91       	pop	r28
    fbce:	df 91       	pop	r29
    fbd0:	1f 91       	pop	r17
    fbd2:	0f 91       	pop	r16
    fbd4:	ff 90       	pop	r15
    fbd6:	ef 90       	pop	r14
    fbd8:	df 90       	pop	r13
    fbda:	cf 90       	pop	r12
    fbdc:	bf 90       	pop	r11
    fbde:	af 90       	pop	r10
    fbe0:	9f 90       	pop	r9
    fbe2:	8f 90       	pop	r8
    fbe4:	7f 90       	pop	r7
    fbe6:	6f 90       	pop	r6
    fbe8:	5f 90       	pop	r5
    fbea:	4f 90       	pop	r4
    fbec:	3f 90       	pop	r3
    fbee:	2f 90       	pop	r2
    fbf0:	08 95       	ret

0000fbf2 <putval>:
    fbf2:	fc 01       	movw	r30, r24
    fbf4:	20 fd       	sbrc	r18, 0
    fbf6:	08 c0       	rjmp	.+16     	; 0xfc08 <putval+0x16>
    fbf8:	23 fd       	sbrc	r18, 3
    fbfa:	05 c0       	rjmp	.+10     	; 0xfc06 <putval+0x14>
    fbfc:	22 ff       	sbrs	r18, 2
    fbfe:	02 c0       	rjmp	.+4      	; 0xfc04 <putval+0x12>
    fc00:	73 83       	std	Z+3, r23	; 0x03
    fc02:	62 83       	std	Z+2, r22	; 0x02
    fc04:	51 83       	std	Z+1, r21	; 0x01
    fc06:	40 83       	st	Z, r20
    fc08:	08 95       	ret

0000fc0a <mulacc>:
    fc0a:	ef 92       	push	r14
    fc0c:	ff 92       	push	r15
    fc0e:	0f 93       	push	r16
    fc10:	1f 93       	push	r17
    fc12:	44 ff       	sbrs	r20, 4
    fc14:	02 c0       	rjmp	.+4      	; 0xfc1a <mulacc+0x10>
    fc16:	33 e0       	ldi	r19, 0x03	; 3
    fc18:	11 c0       	rjmp	.+34     	; 0xfc3c <mulacc+0x32>
    fc1a:	46 ff       	sbrs	r20, 6
    fc1c:	02 c0       	rjmp	.+4      	; 0xfc22 <mulacc+0x18>
    fc1e:	34 e0       	ldi	r19, 0x04	; 4
    fc20:	0d c0       	rjmp	.+26     	; 0xfc3c <mulacc+0x32>
    fc22:	db 01       	movw	r26, r22
    fc24:	fc 01       	movw	r30, r24
    fc26:	aa 0f       	add	r26, r26
    fc28:	bb 1f       	adc	r27, r27
    fc2a:	ee 1f       	adc	r30, r30
    fc2c:	ff 1f       	adc	r31, r31
    fc2e:	10 94       	com	r1
    fc30:	d1 f7       	brne	.-12     	; 0xfc26 <mulacc+0x1c>
    fc32:	6a 0f       	add	r22, r26
    fc34:	7b 1f       	adc	r23, r27
    fc36:	8e 1f       	adc	r24, r30
    fc38:	9f 1f       	adc	r25, r31
    fc3a:	31 e0       	ldi	r19, 0x01	; 1
    fc3c:	66 0f       	add	r22, r22
    fc3e:	77 1f       	adc	r23, r23
    fc40:	88 1f       	adc	r24, r24
    fc42:	99 1f       	adc	r25, r25
    fc44:	31 50       	subi	r19, 0x01	; 1
    fc46:	d1 f7       	brne	.-12     	; 0xfc3c <mulacc+0x32>
    fc48:	7b 01       	movw	r14, r22
    fc4a:	8c 01       	movw	r16, r24
    fc4c:	e2 0e       	add	r14, r18
    fc4e:	f1 1c       	adc	r15, r1
    fc50:	01 1d       	adc	r16, r1
    fc52:	11 1d       	adc	r17, r1
    fc54:	a8 01       	movw	r20, r16
    fc56:	97 01       	movw	r18, r14
    fc58:	b7 01       	movw	r22, r14
    fc5a:	ca 01       	movw	r24, r20
    fc5c:	1f 91       	pop	r17
    fc5e:	0f 91       	pop	r16
    fc60:	ff 90       	pop	r15
    fc62:	ef 90       	pop	r14
    fc64:	08 95       	ret

0000fc66 <skip_spaces>:
    fc66:	0f 93       	push	r16
    fc68:	1f 93       	push	r17
    fc6a:	cf 93       	push	r28
    fc6c:	df 93       	push	r29
    fc6e:	8c 01       	movw	r16, r24
    fc70:	c8 01       	movw	r24, r16
    fc72:	0e 94 b4 84 	call	0x10968	; 0x10968 <fgetc>
    fc76:	ec 01       	movw	r28, r24
    fc78:	97 fd       	sbrc	r25, 7
    fc7a:	08 c0       	rjmp	.+16     	; 0xfc8c <skip_spaces+0x26>
    fc7c:	0e 94 0b 84 	call	0x10816	; 0x10816 <isspace>
    fc80:	89 2b       	or	r24, r25
    fc82:	b1 f7       	brne	.-20     	; 0xfc70 <skip_spaces+0xa>
    fc84:	ce 01       	movw	r24, r28
    fc86:	b8 01       	movw	r22, r16
    fc88:	0e 94 ca 85 	call	0x10b94	; 0x10b94 <ungetc>
    fc8c:	ce 01       	movw	r24, r28
    fc8e:	df 91       	pop	r29
    fc90:	cf 91       	pop	r28
    fc92:	1f 91       	pop	r17
    fc94:	0f 91       	pop	r16
    fc96:	08 95       	ret

0000fc98 <conv_int>:
    fc98:	8f 92       	push	r8
    fc9a:	9f 92       	push	r9
    fc9c:	af 92       	push	r10
    fc9e:	bf 92       	push	r11
    fca0:	df 92       	push	r13
    fca2:	ef 92       	push	r14
    fca4:	ff 92       	push	r15
    fca6:	0f 93       	push	r16
    fca8:	1f 93       	push	r17
    fcaa:	cf 93       	push	r28
    fcac:	df 93       	push	r29
    fcae:	5c 01       	movw	r10, r24
    fcb0:	eb 01       	movw	r28, r22
    fcb2:	4a 01       	movw	r8, r20
    fcb4:	12 2f       	mov	r17, r18
    fcb6:	0e 94 b4 84 	call	0x10968	; 0x10968 <fgetc>
    fcba:	ac 01       	movw	r20, r24
    fcbc:	8b 32       	cpi	r24, 0x2B	; 43
    fcbe:	19 f0       	breq	.+6      	; 0xfcc6 <conv_int+0x2e>
    fcc0:	8d 32       	cpi	r24, 0x2D	; 45
    fcc2:	51 f4       	brne	.+20     	; 0xfcd8 <conv_int+0x40>
    fcc4:	10 68       	ori	r17, 0x80	; 128
    fcc6:	21 97       	sbiw	r28, 0x01	; 1
    fcc8:	09 f4       	brne	.+2      	; 0xfccc <conv_int+0x34>
    fcca:	6d c0       	rjmp	.+218    	; 0xfda6 <conv_int+0x10e>
    fccc:	c5 01       	movw	r24, r10
    fcce:	0e 94 b4 84 	call	0x10968	; 0x10968 <fgetc>
    fcd2:	ac 01       	movw	r20, r24
    fcd4:	97 fd       	sbrc	r25, 7
    fcd6:	67 c0       	rjmp	.+206    	; 0xfda6 <conv_int+0x10e>
    fcd8:	6d ef       	ldi	r22, 0xFD	; 253
    fcda:	d6 2e       	mov	r13, r22
    fcdc:	d1 22       	and	r13, r17
    fcde:	8d 2d       	mov	r24, r13
    fce0:	80 73       	andi	r24, 0x30	; 48
    fce2:	01 f5       	brne	.+64     	; 0xfd24 <conv_int+0x8c>
    fce4:	40 33       	cpi	r20, 0x30	; 48
    fce6:	f1 f4       	brne	.+60     	; 0xfd24 <conv_int+0x8c>
    fce8:	21 97       	sbiw	r28, 0x01	; 1
    fcea:	09 f4       	brne	.+2      	; 0xfcee <conv_int+0x56>
    fcec:	47 c0       	rjmp	.+142    	; 0xfd7c <conv_int+0xe4>
    fcee:	c5 01       	movw	r24, r10
    fcf0:	0e 94 b4 84 	call	0x10968	; 0x10968 <fgetc>
    fcf4:	ac 01       	movw	r20, r24
    fcf6:	97 fd       	sbrc	r25, 7
    fcf8:	41 c0       	rjmp	.+130    	; 0xfd7c <conv_int+0xe4>
    fcfa:	82 e0       	ldi	r24, 0x02	; 2
    fcfc:	d8 2a       	or	r13, r24
    fcfe:	48 37       	cpi	r20, 0x78	; 120
    fd00:	11 f0       	breq	.+4      	; 0xfd06 <conv_int+0x6e>
    fd02:	48 35       	cpi	r20, 0x58	; 88
    fd04:	59 f4       	brne	.+22     	; 0xfd1c <conv_int+0x84>
    fd06:	80 e4       	ldi	r24, 0x40	; 64
    fd08:	d8 2a       	or	r13, r24
    fd0a:	21 97       	sbiw	r28, 0x01	; 1
    fd0c:	b9 f1       	breq	.+110    	; 0xfd7c <conv_int+0xe4>
    fd0e:	c5 01       	movw	r24, r10
    fd10:	0e 94 b4 84 	call	0x10968	; 0x10968 <fgetc>
    fd14:	ac 01       	movw	r20, r24
    fd16:	99 23       	and	r25, r25
    fd18:	2c f4       	brge	.+10     	; 0xfd24 <conv_int+0x8c>
    fd1a:	30 c0       	rjmp	.+96     	; 0xfd7c <conv_int+0xe4>
    fd1c:	d6 fc       	sbrc	r13, 6
    fd1e:	02 c0       	rjmp	.+4      	; 0xfd24 <conv_int+0x8c>
    fd20:	80 e1       	ldi	r24, 0x10	; 16
    fd22:	d8 2a       	or	r13, r24
    fd24:	ee 24       	eor	r14, r14
    fd26:	ff 24       	eor	r15, r15
    fd28:	87 01       	movw	r16, r14
    fd2a:	24 2f       	mov	r18, r20
    fd2c:	20 53       	subi	r18, 0x30	; 48
    fd2e:	28 30       	cpi	r18, 0x08	; 8
    fd30:	88 f0       	brcs	.+34     	; 0xfd54 <conv_int+0xbc>
    fd32:	d4 fc       	sbrc	r13, 4
    fd34:	09 c0       	rjmp	.+18     	; 0xfd48 <conv_int+0xb0>
    fd36:	2a 30       	cpi	r18, 0x0A	; 10
    fd38:	68 f0       	brcs	.+26     	; 0xfd54 <conv_int+0xbc>
    fd3a:	d6 fe       	sbrs	r13, 6
    fd3c:	05 c0       	rjmp	.+10     	; 0xfd48 <conv_int+0xb0>
    fd3e:	2f 7d       	andi	r18, 0xDF	; 223
    fd40:	82 2f       	mov	r24, r18
    fd42:	81 51       	subi	r24, 0x11	; 17
    fd44:	86 30       	cpi	r24, 0x06	; 6
    fd46:	28 f0       	brcs	.+10     	; 0xfd52 <conv_int+0xba>
    fd48:	ca 01       	movw	r24, r20
    fd4a:	b5 01       	movw	r22, r10
    fd4c:	0e 94 ca 85 	call	0x10b94	; 0x10b94 <ungetc>
    fd50:	12 c0       	rjmp	.+36     	; 0xfd76 <conv_int+0xde>
    fd52:	27 50       	subi	r18, 0x07	; 7
    fd54:	c8 01       	movw	r24, r16
    fd56:	b7 01       	movw	r22, r14
    fd58:	4d 2d       	mov	r20, r13
    fd5a:	0e 94 05 7e 	call	0xfc0a	; 0xfc0a <mulacc>
    fd5e:	7b 01       	movw	r14, r22
    fd60:	8c 01       	movw	r16, r24
    fd62:	82 e0       	ldi	r24, 0x02	; 2
    fd64:	d8 2a       	or	r13, r24
    fd66:	21 97       	sbiw	r28, 0x01	; 1
    fd68:	61 f0       	breq	.+24     	; 0xfd82 <conv_int+0xea>
    fd6a:	c5 01       	movw	r24, r10
    fd6c:	0e 94 b4 84 	call	0x10968	; 0x10968 <fgetc>
    fd70:	ac 01       	movw	r20, r24
    fd72:	97 ff       	sbrs	r25, 7
    fd74:	da cf       	rjmp	.-76     	; 0xfd2a <conv_int+0x92>
    fd76:	d1 fc       	sbrc	r13, 1
    fd78:	04 c0       	rjmp	.+8      	; 0xfd82 <conv_int+0xea>
    fd7a:	15 c0       	rjmp	.+42     	; 0xfda6 <conv_int+0x10e>
    fd7c:	ee 24       	eor	r14, r14
    fd7e:	ff 24       	eor	r15, r15
    fd80:	87 01       	movw	r16, r14
    fd82:	d7 fe       	sbrs	r13, 7
    fd84:	08 c0       	rjmp	.+16     	; 0xfd96 <conv_int+0xfe>
    fd86:	10 95       	com	r17
    fd88:	00 95       	com	r16
    fd8a:	f0 94       	com	r15
    fd8c:	e0 94       	com	r14
    fd8e:	e1 1c       	adc	r14, r1
    fd90:	f1 1c       	adc	r15, r1
    fd92:	01 1d       	adc	r16, r1
    fd94:	11 1d       	adc	r17, r1
    fd96:	c4 01       	movw	r24, r8
    fd98:	b8 01       	movw	r22, r16
    fd9a:	a7 01       	movw	r20, r14
    fd9c:	2d 2d       	mov	r18, r13
    fd9e:	0e 94 f9 7d 	call	0xfbf2	; 0xfbf2 <putval>
    fda2:	81 e0       	ldi	r24, 0x01	; 1
    fda4:	01 c0       	rjmp	.+2      	; 0xfda8 <conv_int+0x110>
    fda6:	80 e0       	ldi	r24, 0x00	; 0
    fda8:	df 91       	pop	r29
    fdaa:	cf 91       	pop	r28
    fdac:	1f 91       	pop	r17
    fdae:	0f 91       	pop	r16
    fdb0:	ff 90       	pop	r15
    fdb2:	ef 90       	pop	r14
    fdb4:	df 90       	pop	r13
    fdb6:	bf 90       	pop	r11
    fdb8:	af 90       	pop	r10
    fdba:	9f 90       	pop	r9
    fdbc:	8f 90       	pop	r8
    fdbe:	08 95       	ret

0000fdc0 <conv_brk>:
    fdc0:	6f 92       	push	r6
    fdc2:	7f 92       	push	r7
    fdc4:	8f 92       	push	r8
    fdc6:	9f 92       	push	r9
    fdc8:	af 92       	push	r10
    fdca:	bf 92       	push	r11
    fdcc:	cf 92       	push	r12
    fdce:	df 92       	push	r13
    fdd0:	ef 92       	push	r14
    fdd2:	ff 92       	push	r15
    fdd4:	0f 93       	push	r16
    fdd6:	1f 93       	push	r17
    fdd8:	df 93       	push	r29
    fdda:	cf 93       	push	r28
    fddc:	cd b7       	in	r28, 0x3d	; 61
    fdde:	de b7       	in	r29, 0x3e	; 62
    fde0:	a0 97       	sbiw	r28, 0x20	; 32
    fde2:	0f b6       	in	r0, 0x3f	; 63
    fde4:	f8 94       	cli
    fde6:	de bf       	out	0x3e, r29	; 62
    fde8:	0f be       	out	0x3f, r0	; 63
    fdea:	cd bf       	out	0x3d, r28	; 61
    fdec:	5c 01       	movw	r10, r24
    fdee:	6b 01       	movw	r12, r22
    fdf0:	8a 01       	movw	r16, r20
    fdf2:	79 01       	movw	r14, r18
    fdf4:	fe 01       	movw	r30, r28
    fdf6:	31 96       	adiw	r30, 0x01	; 1
    fdf8:	80 e2       	ldi	r24, 0x20	; 32
    fdfa:	df 01       	movw	r26, r30
    fdfc:	1d 92       	st	X+, r1
    fdfe:	8a 95       	dec	r24
    fe00:	e9 f7       	brne	.-6      	; 0xfdfc <conv_brk+0x3c>
    fe02:	70 e0       	ldi	r23, 0x00	; 0
    fe04:	30 e0       	ldi	r19, 0x00	; 0
    fe06:	60 e0       	ldi	r22, 0x00	; 0
    fe08:	40 e0       	ldi	r20, 0x00	; 0
    fe0a:	50 e0       	ldi	r21, 0x00	; 0
    fe0c:	3f 01       	movw	r6, r30
    fe0e:	a1 e0       	ldi	r26, 0x01	; 1
    fe10:	b0 e0       	ldi	r27, 0x00	; 0
    fe12:	f5 01       	movw	r30, r10
    fe14:	83 81       	ldd	r24, Z+3	; 0x03
    fe16:	f7 01       	movw	r30, r14
    fe18:	83 fd       	sbrc	r24, 3
    fe1a:	25 91       	lpm	r18, Z+
    fe1c:	83 ff       	sbrs	r24, 3
    fe1e:	21 91       	ld	r18, Z+
    fe20:	7f 01       	movw	r14, r30
    fe22:	22 23       	and	r18, r18
    fe24:	09 f4       	brne	.+2      	; 0xfe28 <conv_brk+0x68>
    fe26:	81 c0       	rjmp	.+258    	; 0xff2a <conv_brk+0x16a>
    fe28:	2e 35       	cpi	r18, 0x5E	; 94
    fe2a:	19 f4       	brne	.+6      	; 0xfe32 <conv_brk+0x72>
    fe2c:	41 15       	cp	r20, r1
    fe2e:	51 05       	cpc	r21, r1
    fe30:	69 f1       	breq	.+90     	; 0xfe8c <conv_brk+0xcc>
    fe32:	87 2f       	mov	r24, r23
    fe34:	90 e0       	ldi	r25, 0x00	; 0
    fe36:	84 17       	cp	r24, r20
    fe38:	95 07       	cpc	r25, r21
    fe3a:	44 f4       	brge	.+16     	; 0xfe4c <conv_brk+0x8c>
    fe3c:	2d 35       	cpi	r18, 0x5D	; 93
    fe3e:	51 f1       	breq	.+84     	; 0xfe94 <conv_brk+0xd4>
    fe40:	2d 32       	cpi	r18, 0x2D	; 45
    fe42:	21 f4       	brne	.+8      	; 0xfe4c <conv_brk+0x8c>
    fe44:	33 23       	and	r19, r19
    fe46:	29 f4       	brne	.+10     	; 0xfe52 <conv_brk+0x92>
    fe48:	31 e0       	ldi	r19, 0x01	; 1
    fe4a:	21 c0       	rjmp	.+66     	; 0xfe8e <conv_brk+0xce>
    fe4c:	33 23       	and	r19, r19
    fe4e:	09 f4       	brne	.+2      	; 0xfe52 <conv_brk+0x92>
    fe50:	62 2f       	mov	r22, r18
    fe52:	32 2f       	mov	r19, r18
    fe54:	83 2f       	mov	r24, r19
    fe56:	86 95       	lsr	r24
    fe58:	86 95       	lsr	r24
    fe5a:	86 95       	lsr	r24
    fe5c:	f3 01       	movw	r30, r6
    fe5e:	e8 0f       	add	r30, r24
    fe60:	f1 1d       	adc	r31, r1
    fe62:	83 2f       	mov	r24, r19
    fe64:	87 70       	andi	r24, 0x07	; 7
    fe66:	4d 01       	movw	r8, r26
    fe68:	02 c0       	rjmp	.+4      	; 0xfe6e <conv_brk+0xae>
    fe6a:	88 0c       	add	r8, r8
    fe6c:	99 1c       	adc	r9, r9
    fe6e:	8a 95       	dec	r24
    fe70:	e2 f7       	brpl	.-8      	; 0xfe6a <conv_brk+0xaa>
    fe72:	20 81       	ld	r18, Z
    fe74:	28 29       	or	r18, r8
    fe76:	20 83       	st	Z, r18
    fe78:	36 17       	cp	r19, r22
    fe7a:	11 f4       	brne	.+4      	; 0xfe80 <conv_brk+0xc0>
    fe7c:	30 e0       	ldi	r19, 0x00	; 0
    fe7e:	07 c0       	rjmp	.+14     	; 0xfe8e <conv_brk+0xce>
    fe80:	36 17       	cp	r19, r22
    fe82:	10 f4       	brcc	.+4      	; 0xfe88 <conv_brk+0xc8>
    fe84:	3f 5f       	subi	r19, 0xFF	; 255
    fe86:	e6 cf       	rjmp	.-52     	; 0xfe54 <conv_brk+0x94>
    fe88:	31 50       	subi	r19, 0x01	; 1
    fe8a:	e4 cf       	rjmp	.-56     	; 0xfe54 <conv_brk+0x94>
    fe8c:	71 e0       	ldi	r23, 0x01	; 1
    fe8e:	4f 5f       	subi	r20, 0xFF	; 255
    fe90:	5f 4f       	sbci	r21, 0xFF	; 255
    fe92:	bf cf       	rjmp	.-130    	; 0xfe12 <conv_brk+0x52>
    fe94:	33 23       	and	r19, r19
    fe96:	19 f0       	breq	.+6      	; 0xfe9e <conv_brk+0xde>
    fe98:	8e 81       	ldd	r24, Y+6	; 0x06
    fe9a:	80 62       	ori	r24, 0x20	; 32
    fe9c:	8e 83       	std	Y+6, r24	; 0x06
    fe9e:	77 23       	and	r23, r23
    fea0:	59 f0       	breq	.+22     	; 0xfeb8 <conv_brk+0xf8>
    fea2:	fe 01       	movw	r30, r28
    fea4:	31 96       	adiw	r30, 0x01	; 1
    fea6:	9e 01       	movw	r18, r28
    fea8:	2f 5d       	subi	r18, 0xDF	; 223
    feaa:	3f 4f       	sbci	r19, 0xFF	; 255
    feac:	80 81       	ld	r24, Z
    feae:	80 95       	com	r24
    feb0:	81 93       	st	Z+, r24
    feb2:	e2 17       	cp	r30, r18
    feb4:	f3 07       	cpc	r31, r19
    feb6:	d1 f7       	brne	.-12     	; 0xfeac <conv_brk+0xec>
    feb8:	99 24       	eor	r9, r9
    feba:	93 94       	inc	r9
    febc:	3e 01       	movw	r6, r28
    febe:	08 94       	sec
    fec0:	61 1c       	adc	r6, r1
    fec2:	71 1c       	adc	r7, r1
    fec4:	c5 01       	movw	r24, r10
    fec6:	0e 94 b4 84 	call	0x10968	; 0x10968 <fgetc>
    feca:	ac 01       	movw	r20, r24
    fecc:	97 fd       	sbrc	r25, 7
    fece:	25 c0       	rjmp	.+74     	; 0xff1a <conv_brk+0x15a>
    fed0:	86 95       	lsr	r24
    fed2:	86 95       	lsr	r24
    fed4:	86 95       	lsr	r24
    fed6:	f3 01       	movw	r30, r6
    fed8:	e8 0f       	add	r30, r24
    feda:	f1 1d       	adc	r31, r1
    fedc:	80 81       	ld	r24, Z
    fede:	90 e0       	ldi	r25, 0x00	; 0
    fee0:	9a 01       	movw	r18, r20
    fee2:	27 70       	andi	r18, 0x07	; 7
    fee4:	30 70       	andi	r19, 0x00	; 0
    fee6:	02 c0       	rjmp	.+4      	; 0xfeec <conv_brk+0x12c>
    fee8:	95 95       	asr	r25
    feea:	87 95       	ror	r24
    feec:	2a 95       	dec	r18
    feee:	e2 f7       	brpl	.-8      	; 0xfee8 <conv_brk+0x128>
    fef0:	80 fd       	sbrc	r24, 0
    fef2:	05 c0       	rjmp	.+10     	; 0xfefe <conv_brk+0x13e>
    fef4:	ca 01       	movw	r24, r20
    fef6:	b5 01       	movw	r22, r10
    fef8:	0e 94 ca 85 	call	0x10b94	; 0x10b94 <ungetc>
    fefc:	0e c0       	rjmp	.+28     	; 0xff1a <conv_brk+0x15a>
    fefe:	01 15       	cp	r16, r1
    ff00:	11 05       	cpc	r17, r1
    ff02:	19 f0       	breq	.+6      	; 0xff0a <conv_brk+0x14a>
    ff04:	d8 01       	movw	r26, r16
    ff06:	4d 93       	st	X+, r20
    ff08:	8d 01       	movw	r16, r26
    ff0a:	08 94       	sec
    ff0c:	c1 08       	sbc	r12, r1
    ff0e:	d1 08       	sbc	r13, r1
    ff10:	99 24       	eor	r9, r9
    ff12:	c1 14       	cp	r12, r1
    ff14:	d1 04       	cpc	r13, r1
    ff16:	b1 f6       	brne	.-84     	; 0xfec4 <conv_brk+0x104>
    ff18:	02 c0       	rjmp	.+4      	; 0xff1e <conv_brk+0x15e>
    ff1a:	99 20       	and	r9, r9
    ff1c:	31 f4       	brne	.+12     	; 0xff2a <conv_brk+0x16a>
    ff1e:	01 15       	cp	r16, r1
    ff20:	11 05       	cpc	r17, r1
    ff22:	29 f0       	breq	.+10     	; 0xff2e <conv_brk+0x16e>
    ff24:	f8 01       	movw	r30, r16
    ff26:	10 82       	st	Z, r1
    ff28:	02 c0       	rjmp	.+4      	; 0xff2e <conv_brk+0x16e>
    ff2a:	ee 24       	eor	r14, r14
    ff2c:	ff 24       	eor	r15, r15
    ff2e:	c7 01       	movw	r24, r14
    ff30:	a0 96       	adiw	r28, 0x20	; 32
    ff32:	0f b6       	in	r0, 0x3f	; 63
    ff34:	f8 94       	cli
    ff36:	de bf       	out	0x3e, r29	; 62
    ff38:	0f be       	out	0x3f, r0	; 63
    ff3a:	cd bf       	out	0x3d, r28	; 61
    ff3c:	cf 91       	pop	r28
    ff3e:	df 91       	pop	r29
    ff40:	1f 91       	pop	r17
    ff42:	0f 91       	pop	r16
    ff44:	ff 90       	pop	r15
    ff46:	ef 90       	pop	r14
    ff48:	df 90       	pop	r13
    ff4a:	cf 90       	pop	r12
    ff4c:	bf 90       	pop	r11
    ff4e:	af 90       	pop	r10
    ff50:	9f 90       	pop	r9
    ff52:	8f 90       	pop	r8
    ff54:	7f 90       	pop	r7
    ff56:	6f 90       	pop	r6
    ff58:	08 95       	ret

0000ff5a <conv_flt>:
    ff5a:	2f 92       	push	r2
    ff5c:	3f 92       	push	r3
    ff5e:	5f 92       	push	r5
    ff60:	6f 92       	push	r6
    ff62:	7f 92       	push	r7
    ff64:	8f 92       	push	r8
    ff66:	9f 92       	push	r9
    ff68:	af 92       	push	r10
    ff6a:	bf 92       	push	r11
    ff6c:	cf 92       	push	r12
    ff6e:	df 92       	push	r13
    ff70:	ef 92       	push	r14
    ff72:	ff 92       	push	r15
    ff74:	0f 93       	push	r16
    ff76:	1f 93       	push	r17
    ff78:	cf 93       	push	r28
    ff7a:	df 93       	push	r29
    ff7c:	3c 01       	movw	r6, r24
    ff7e:	7b 01       	movw	r14, r22
    ff80:	1a 01       	movw	r2, r20
    ff82:	0e 94 b4 84 	call	0x10968	; 0x10968 <fgetc>
    ff86:	ec 01       	movw	r28, r24
    ff88:	8b 32       	cpi	r24, 0x2B	; 43
    ff8a:	39 f0       	breq	.+14     	; 0xff9a <conv_flt+0x40>
    ff8c:	8d 32       	cpi	r24, 0x2D	; 45
    ff8e:	11 f0       	breq	.+4      	; 0xff94 <conv_flt+0x3a>
    ff90:	55 24       	eor	r5, r5
    ff92:	11 c0       	rjmp	.+34     	; 0xffb6 <conv_flt+0x5c>
    ff94:	b0 e8       	ldi	r27, 0x80	; 128
    ff96:	5b 2e       	mov	r5, r27
    ff98:	01 c0       	rjmp	.+2      	; 0xff9c <conv_flt+0x42>
    ff9a:	55 24       	eor	r5, r5
    ff9c:	08 94       	sec
    ff9e:	e1 08       	sbc	r14, r1
    ffa0:	f1 08       	sbc	r15, r1
    ffa2:	e1 14       	cp	r14, r1
    ffa4:	f1 04       	cpc	r15, r1
    ffa6:	09 f4       	brne	.+2      	; 0xffaa <conv_flt+0x50>
    ffa8:	18 c1       	rjmp	.+560    	; 0x101da <conv_flt+0x280>
    ffaa:	c3 01       	movw	r24, r6
    ffac:	0e 94 b4 84 	call	0x10968	; 0x10968 <fgetc>
    ffb0:	ec 01       	movw	r28, r24
    ffb2:	97 fd       	sbrc	r25, 7
    ffb4:	12 c1       	rjmp	.+548    	; 0x101da <conv_flt+0x280>
    ffb6:	ce 01       	movw	r24, r28
    ffb8:	0e 94 13 84 	call	0x10826	; 0x10826 <tolower>
    ffbc:	89 36       	cpi	r24, 0x69	; 105
    ffbe:	91 05       	cpc	r25, r1
    ffc0:	21 f0       	breq	.+8      	; 0xffca <conv_flt+0x70>
    ffc2:	8e 36       	cpi	r24, 0x6E	; 110
    ffc4:	91 05       	cpc	r25, r1
    ffc6:	99 f5       	brne	.+102    	; 0x1002e <conv_flt+0xd4>
    ffc8:	1d c0       	rjmp	.+58     	; 0x10004 <conv_flt+0xaa>
    ffca:	0b ee       	ldi	r16, 0xEB	; 235
    ffcc:	12 e0       	ldi	r17, 0x02	; 2
    ffce:	1c c0       	rjmp	.+56     	; 0x10008 <conv_flt+0xae>
    ffd0:	08 94       	sec
    ffd2:	e1 08       	sbc	r14, r1
    ffd4:	f1 08       	sbc	r15, r1
    ffd6:	e1 14       	cp	r14, r1
    ffd8:	f1 04       	cpc	r15, r1
    ffda:	71 f0       	breq	.+28     	; 0xfff8 <conv_flt+0x9e>
    ffdc:	c3 01       	movw	r24, r6
    ffde:	0e 94 b4 84 	call	0x10968	; 0x10968 <fgetc>
    ffe2:	ec 01       	movw	r28, r24
    ffe4:	97 fd       	sbrc	r25, 7
    ffe6:	08 c0       	rjmp	.+16     	; 0xfff8 <conv_flt+0x9e>
    ffe8:	0e 94 13 84 	call	0x10826	; 0x10826 <tolower>
    ffec:	d8 16       	cp	r13, r24
    ffee:	61 f0       	breq	.+24     	; 0x10008 <conv_flt+0xae>
    fff0:	ce 01       	movw	r24, r28
    fff2:	b3 01       	movw	r22, r6
    fff4:	0e 94 ca 85 	call	0x10b94	; 0x10b94 <ungetc>
    fff8:	22 e0       	ldi	r18, 0x02	; 2
    fffa:	0e 3e       	cpi	r16, 0xEE	; 238
    fffc:	12 07       	cpc	r17, r18
    fffe:	09 f0       	breq	.+2      	; 0x10002 <conv_flt+0xa8>
   10000:	ec c0       	rjmp	.+472    	; 0x101da <conv_flt+0x280>
   10002:	08 c0       	rjmp	.+16     	; 0x10014 <conv_flt+0xba>
   10004:	08 ee       	ldi	r16, 0xE8	; 232
   10006:	12 e0       	ldi	r17, 0x02	; 2
   10008:	f8 01       	movw	r30, r16
   1000a:	0f 5f       	subi	r16, 0xFF	; 255
   1000c:	1f 4f       	sbci	r17, 0xFF	; 255
   1000e:	d4 90       	lpm	r13, Z+
   10010:	dd 20       	and	r13, r13
   10012:	f1 f6       	brne	.-68     	; 0xffd0 <conv_flt+0x76>
   10014:	0b 5e       	subi	r16, 0xEB	; 235
   10016:	12 40       	sbci	r17, 0x02	; 2
   10018:	29 f0       	breq	.+10     	; 0x10024 <conv_flt+0xca>
   1001a:	80 e0       	ldi	r24, 0x00	; 0
   1001c:	90 e0       	ldi	r25, 0x00	; 0
   1001e:	a0 e8       	ldi	r26, 0x80	; 128
   10020:	bf e7       	ldi	r27, 0x7F	; 127
   10022:	cf c0       	rjmp	.+414    	; 0x101c2 <conv_flt+0x268>
   10024:	80 e0       	ldi	r24, 0x00	; 0
   10026:	90 e0       	ldi	r25, 0x00	; 0
   10028:	a0 ec       	ldi	r26, 0xC0	; 192
   1002a:	bf e7       	ldi	r27, 0x7F	; 127
   1002c:	ca c0       	rjmp	.+404    	; 0x101c2 <conv_flt+0x268>
   1002e:	cc 24       	eor	r12, r12
   10030:	dd 24       	eor	r13, r13
   10032:	88 24       	eor	r8, r8
   10034:	99 24       	eor	r9, r9
   10036:	54 01       	movw	r10, r8
   10038:	ae 01       	movw	r20, r28
   1003a:	40 53       	subi	r20, 0x30	; 48
   1003c:	24 2f       	mov	r18, r20
   1003e:	4a 30       	cpi	r20, 0x0A	; 10
   10040:	38 f5       	brcc	.+78     	; 0x10090 <conv_flt+0x136>
   10042:	52 e0       	ldi	r21, 0x02	; 2
   10044:	55 2a       	or	r5, r21
   10046:	85 2d       	mov	r24, r5
   10048:	90 e0       	ldi	r25, 0x00	; 0
   1004a:	ac 01       	movw	r20, r24
   1004c:	48 70       	andi	r20, 0x08	; 8
   1004e:	50 70       	andi	r21, 0x00	; 0
   10050:	52 fe       	sbrs	r5, 2
   10052:	06 c0       	rjmp	.+12     	; 0x10060 <conv_flt+0x106>
   10054:	45 2b       	or	r20, r21
   10056:	11 f5       	brne	.+68     	; 0x1009c <conv_flt+0x142>
   10058:	08 94       	sec
   1005a:	c1 1c       	adc	r12, r1
   1005c:	d1 1c       	adc	r13, r1
   1005e:	1e c0       	rjmp	.+60     	; 0x1009c <conv_flt+0x142>
   10060:	45 2b       	or	r20, r21
   10062:	19 f0       	breq	.+6      	; 0x1006a <conv_flt+0x110>
   10064:	08 94       	sec
   10066:	c1 08       	sbc	r12, r1
   10068:	d1 08       	sbc	r13, r1
   1006a:	c5 01       	movw	r24, r10
   1006c:	b4 01       	movw	r22, r8
   1006e:	40 e2       	ldi	r20, 0x20	; 32
   10070:	0e 94 05 7e 	call	0xfc0a	; 0xfc0a <mulacc>
   10074:	4b 01       	movw	r8, r22
   10076:	5c 01       	movw	r10, r24
   10078:	88 e9       	ldi	r24, 0x98	; 152
   1007a:	88 16       	cp	r8, r24
   1007c:	89 e9       	ldi	r24, 0x99	; 153
   1007e:	98 06       	cpc	r9, r24
   10080:	89 e9       	ldi	r24, 0x99	; 153
   10082:	a8 06       	cpc	r10, r24
   10084:	89 e1       	ldi	r24, 0x19	; 25
   10086:	b8 06       	cpc	r11, r24
   10088:	48 f0       	brcs	.+18     	; 0x1009c <conv_flt+0x142>
   1008a:	94 e0       	ldi	r25, 0x04	; 4
   1008c:	59 2a       	or	r5, r25
   1008e:	06 c0       	rjmp	.+12     	; 0x1009c <conv_flt+0x142>
   10090:	4e 3f       	cpi	r20, 0xFE	; 254
   10092:	81 f4       	brne	.+32     	; 0x100b4 <conv_flt+0x15a>
   10094:	53 fc       	sbrc	r5, 3
   10096:	0e c0       	rjmp	.+28     	; 0x100b4 <conv_flt+0x15a>
   10098:	e8 e0       	ldi	r30, 0x08	; 8
   1009a:	5e 2a       	or	r5, r30
   1009c:	08 94       	sec
   1009e:	e1 08       	sbc	r14, r1
   100a0:	f1 08       	sbc	r15, r1
   100a2:	e1 14       	cp	r14, r1
   100a4:	f1 04       	cpc	r15, r1
   100a6:	31 f0       	breq	.+12     	; 0x100b4 <conv_flt+0x15a>
   100a8:	c3 01       	movw	r24, r6
   100aa:	0e 94 b4 84 	call	0x10968	; 0x10968 <fgetc>
   100ae:	ec 01       	movw	r28, r24
   100b0:	97 ff       	sbrs	r25, 7
   100b2:	c2 cf       	rjmp	.-124    	; 0x10038 <conv_flt+0xde>
   100b4:	51 fe       	sbrs	r5, 1
   100b6:	91 c0       	rjmp	.+290    	; 0x101da <conv_flt+0x280>
   100b8:	c5 36       	cpi	r28, 0x65	; 101
   100ba:	19 f0       	breq	.+6      	; 0x100c2 <conv_flt+0x168>
   100bc:	c5 34       	cpi	r28, 0x45	; 69
   100be:	09 f0       	breq	.+2      	; 0x100c2 <conv_flt+0x168>
   100c0:	46 c0       	rjmp	.+140    	; 0x1014e <conv_flt+0x1f4>
   100c2:	08 94       	sec
   100c4:	e1 08       	sbc	r14, r1
   100c6:	f1 08       	sbc	r15, r1
   100c8:	e1 14       	cp	r14, r1
   100ca:	f1 04       	cpc	r15, r1
   100cc:	09 f4       	brne	.+2      	; 0x100d0 <conv_flt+0x176>
   100ce:	85 c0       	rjmp	.+266    	; 0x101da <conv_flt+0x280>
   100d0:	c3 01       	movw	r24, r6
   100d2:	0e 94 b4 84 	call	0x10968	; 0x10968 <fgetc>
   100d6:	ec 01       	movw	r28, r24
   100d8:	97 fd       	sbrc	r25, 7
   100da:	7f c0       	rjmp	.+254    	; 0x101da <conv_flt+0x280>
   100dc:	8b 32       	cpi	r24, 0x2B	; 43
   100de:	21 f0       	breq	.+8      	; 0x100e8 <conv_flt+0x18e>
   100e0:	8d 32       	cpi	r24, 0x2D	; 45
   100e2:	69 f4       	brne	.+26     	; 0x100fe <conv_flt+0x1a4>
   100e4:	f0 e1       	ldi	r31, 0x10	; 16
   100e6:	5f 2a       	or	r5, r31
   100e8:	08 94       	sec
   100ea:	e1 08       	sbc	r14, r1
   100ec:	f1 08       	sbc	r15, r1
   100ee:	e1 14       	cp	r14, r1
   100f0:	f1 04       	cpc	r15, r1
   100f2:	09 f4       	brne	.+2      	; 0x100f6 <conv_flt+0x19c>
   100f4:	72 c0       	rjmp	.+228    	; 0x101da <conv_flt+0x280>
   100f6:	c3 01       	movw	r24, r6
   100f8:	0e 94 b4 84 	call	0x10968	; 0x10968 <fgetc>
   100fc:	ec 01       	movw	r28, r24
   100fe:	ce 01       	movw	r24, r28
   10100:	c0 97       	sbiw	r24, 0x30	; 48
   10102:	0a 97       	sbiw	r24, 0x0a	; 10
   10104:	08 f0       	brcs	.+2      	; 0x10108 <conv_flt+0x1ae>
   10106:	69 c0       	rjmp	.+210    	; 0x101da <conv_flt+0x280>
   10108:	00 e0       	ldi	r16, 0x00	; 0
   1010a:	10 e0       	ldi	r17, 0x00	; 0
   1010c:	b8 01       	movw	r22, r16
   1010e:	88 27       	eor	r24, r24
   10110:	77 fd       	sbrc	r23, 7
   10112:	80 95       	com	r24
   10114:	98 2f       	mov	r25, r24
   10116:	ae 01       	movw	r20, r28
   10118:	40 53       	subi	r20, 0x30	; 48
   1011a:	24 2f       	mov	r18, r20
   1011c:	40 e2       	ldi	r20, 0x20	; 32
   1011e:	0e 94 05 7e 	call	0xfc0a	; 0xfc0a <mulacc>
   10122:	8b 01       	movw	r16, r22
   10124:	08 94       	sec
   10126:	e1 08       	sbc	r14, r1
   10128:	f1 08       	sbc	r15, r1
   1012a:	e1 14       	cp	r14, r1
   1012c:	f1 04       	cpc	r15, r1
   1012e:	39 f0       	breq	.+14     	; 0x1013e <conv_flt+0x1e4>
   10130:	c3 01       	movw	r24, r6
   10132:	0e 94 b4 84 	call	0x10968	; 0x10968 <fgetc>
   10136:	ec 01       	movw	r28, r24
   10138:	c0 97       	sbiw	r24, 0x30	; 48
   1013a:	0a 97       	sbiw	r24, 0x0a	; 10
   1013c:	38 f3       	brcs	.-50     	; 0x1010c <conv_flt+0x1b2>
   1013e:	b8 01       	movw	r22, r16
   10140:	54 fe       	sbrs	r5, 4
   10142:	03 c0       	rjmp	.+6      	; 0x1014a <conv_flt+0x1f0>
   10144:	70 95       	com	r23
   10146:	61 95       	neg	r22
   10148:	7f 4f       	sbci	r23, 0xFF	; 255
   1014a:	c6 0e       	add	r12, r22
   1014c:	d7 1e       	adc	r13, r23
   1014e:	ef 28       	or	r14, r15
   10150:	31 f0       	breq	.+12     	; 0x1015e <conv_flt+0x204>
   10152:	d7 fd       	sbrc	r29, 7
   10154:	04 c0       	rjmp	.+8      	; 0x1015e <conv_flt+0x204>
   10156:	ce 01       	movw	r24, r28
   10158:	b3 01       	movw	r22, r6
   1015a:	0e 94 ca 85 	call	0x10b94	; 0x10b94 <ungetc>
   1015e:	c5 01       	movw	r24, r10
   10160:	b4 01       	movw	r22, r8
   10162:	0e 94 3f 82 	call	0x1047e	; 0x1047e <__floatunsisf>
   10166:	d7 fe       	sbrs	r13, 7
   10168:	0d c0       	rjmp	.+26     	; 0x10184 <conv_flt+0x22a>
   1016a:	a7 e0       	ldi	r26, 0x07	; 7
   1016c:	ea 2e       	mov	r14, r26
   1016e:	a3 e0       	ldi	r26, 0x03	; 3
   10170:	fa 2e       	mov	r15, r26
   10172:	d0 94       	com	r13
   10174:	c1 94       	neg	r12
   10176:	d1 08       	sbc	r13, r1
   10178:	d3 94       	inc	r13
   1017a:	c0 e2       	ldi	r28, 0x20	; 32
   1017c:	d0 e0       	ldi	r29, 0x00	; 0
   1017e:	00 e0       	ldi	r16, 0x00	; 0
   10180:	10 e0       	ldi	r17, 0x00	; 0
   10182:	0e c0       	rjmp	.+28     	; 0x101a0 <conv_flt+0x246>
   10184:	ff e1       	ldi	r31, 0x1F	; 31
   10186:	ef 2e       	mov	r14, r31
   10188:	f3 e0       	ldi	r31, 0x03	; 3
   1018a:	ff 2e       	mov	r15, r31
   1018c:	f6 cf       	rjmp	.-20     	; 0x1017a <conv_flt+0x220>
   1018e:	f7 01       	movw	r30, r14
   10190:	25 91       	lpm	r18, Z+
   10192:	35 91       	lpm	r19, Z+
   10194:	45 91       	lpm	r20, Z+
   10196:	54 91       	lpm	r21, Z+
   10198:	0e 94 7c 82 	call	0x104f8	; 0x104f8 <__mulsf3>
   1019c:	cc 1a       	sub	r12, r28
   1019e:	dd 0a       	sbc	r13, r29
   101a0:	cc 16       	cp	r12, r28
   101a2:	dd 06       	cpc	r13, r29
   101a4:	a0 f7       	brcc	.-24     	; 0x1018e <conv_flt+0x234>
   101a6:	d6 95       	lsr	r29
   101a8:	c7 95       	ror	r28
   101aa:	0f 5f       	subi	r16, 0xFF	; 255
   101ac:	1f 4f       	sbci	r17, 0xFF	; 255
   101ae:	06 30       	cpi	r16, 0x06	; 6
   101b0:	11 05       	cpc	r17, r1
   101b2:	29 f0       	breq	.+10     	; 0x101be <conv_flt+0x264>
   101b4:	ec ef       	ldi	r30, 0xFC	; 252
   101b6:	ff ef       	ldi	r31, 0xFF	; 255
   101b8:	ee 0e       	add	r14, r30
   101ba:	ff 1e       	adc	r15, r31
   101bc:	f1 cf       	rjmp	.-30     	; 0x101a0 <conv_flt+0x246>
   101be:	dc 01       	movw	r26, r24
   101c0:	cb 01       	movw	r24, r22
   101c2:	57 fc       	sbrc	r5, 7
   101c4:	b0 58       	subi	r27, 0x80	; 128
   101c6:	21 14       	cp	r2, r1
   101c8:	31 04       	cpc	r3, r1
   101ca:	29 f0       	breq	.+10     	; 0x101d6 <conv_flt+0x27c>
   101cc:	f1 01       	movw	r30, r2
   101ce:	80 83       	st	Z, r24
   101d0:	91 83       	std	Z+1, r25	; 0x01
   101d2:	a2 83       	std	Z+2, r26	; 0x02
   101d4:	b3 83       	std	Z+3, r27	; 0x03
   101d6:	81 e0       	ldi	r24, 0x01	; 1
   101d8:	01 c0       	rjmp	.+2      	; 0x101dc <conv_flt+0x282>
   101da:	80 e0       	ldi	r24, 0x00	; 0
   101dc:	df 91       	pop	r29
   101de:	cf 91       	pop	r28
   101e0:	1f 91       	pop	r17
   101e2:	0f 91       	pop	r16
   101e4:	ff 90       	pop	r15
   101e6:	ef 90       	pop	r14
   101e8:	df 90       	pop	r13
   101ea:	cf 90       	pop	r12
   101ec:	bf 90       	pop	r11
   101ee:	af 90       	pop	r10
   101f0:	9f 90       	pop	r9
   101f2:	8f 90       	pop	r8
   101f4:	7f 90       	pop	r7
   101f6:	6f 90       	pop	r6
   101f8:	5f 90       	pop	r5
   101fa:	3f 90       	pop	r3
   101fc:	2f 90       	pop	r2
   101fe:	08 95       	ret

00010200 <vfscanf>:
   10200:	5f 92       	push	r5
   10202:	6f 92       	push	r6
   10204:	7f 92       	push	r7
   10206:	8f 92       	push	r8
   10208:	9f 92       	push	r9
   1020a:	af 92       	push	r10
   1020c:	bf 92       	push	r11
   1020e:	cf 92       	push	r12
   10210:	df 92       	push	r13
   10212:	ef 92       	push	r14
   10214:	ff 92       	push	r15
   10216:	0f 93       	push	r16
   10218:	1f 93       	push	r17
   1021a:	cf 93       	push	r28
   1021c:	df 93       	push	r29
   1021e:	4c 01       	movw	r8, r24
   10220:	5b 01       	movw	r10, r22
   10222:	3a 01       	movw	r6, r20
   10224:	fc 01       	movw	r30, r24
   10226:	17 82       	std	Z+7, r1	; 0x07
   10228:	16 82       	std	Z+6, r1	; 0x06
   1022a:	55 24       	eor	r5, r5
   1022c:	04 c1       	rjmp	.+520    	; 0x10436 <vfscanf+0x236>
   1022e:	81 2f       	mov	r24, r17
   10230:	90 e0       	ldi	r25, 0x00	; 0
   10232:	0e 94 0b 84 	call	0x10816	; 0x10816 <isspace>
   10236:	89 2b       	or	r24, r25
   10238:	21 f0       	breq	.+8      	; 0x10242 <vfscanf+0x42>
   1023a:	c4 01       	movw	r24, r8
   1023c:	0e 94 33 7e 	call	0xfc66	; 0xfc66 <skip_spaces>
   10240:	fa c0       	rjmp	.+500    	; 0x10436 <vfscanf+0x236>
   10242:	15 32       	cpi	r17, 0x25	; 37
   10244:	49 f4       	brne	.+18     	; 0x10258 <vfscanf+0x58>
   10246:	f5 01       	movw	r30, r10
   10248:	f3 fc       	sbrc	r15, 3
   1024a:	65 91       	lpm	r22, Z+
   1024c:	f3 fe       	sbrs	r15, 3
   1024e:	61 91       	ld	r22, Z+
   10250:	5f 01       	movw	r10, r30
   10252:	65 32       	cpi	r22, 0x25	; 37
   10254:	69 f4       	brne	.+26     	; 0x10270 <vfscanf+0x70>
   10256:	15 e2       	ldi	r17, 0x25	; 37
   10258:	c4 01       	movw	r24, r8
   1025a:	0e 94 b4 84 	call	0x10968	; 0x10968 <fgetc>
   1025e:	97 fd       	sbrc	r25, 7
   10260:	f6 c0       	rjmp	.+492    	; 0x1044e <vfscanf+0x24e>
   10262:	18 17       	cp	r17, r24
   10264:	09 f4       	brne	.+2      	; 0x10268 <vfscanf+0x68>
   10266:	e7 c0       	rjmp	.+462    	; 0x10436 <vfscanf+0x236>
   10268:	b4 01       	movw	r22, r8
   1026a:	0e 94 ca 85 	call	0x10b94	; 0x10b94 <ungetc>
   1026e:	f4 c0       	rjmp	.+488    	; 0x10458 <vfscanf+0x258>
   10270:	6a 32       	cpi	r22, 0x2A	; 42
   10272:	19 f0       	breq	.+6      	; 0x1027a <vfscanf+0x7a>
   10274:	16 2f       	mov	r17, r22
   10276:	00 e0       	ldi	r16, 0x00	; 0
   10278:	06 c0       	rjmp	.+12     	; 0x10286 <vfscanf+0x86>
   1027a:	f3 fc       	sbrc	r15, 3
   1027c:	15 91       	lpm	r17, Z+
   1027e:	f3 fe       	sbrs	r15, 3
   10280:	11 91       	ld	r17, Z+
   10282:	5f 01       	movw	r10, r30
   10284:	01 e0       	ldi	r16, 0x01	; 1
   10286:	cc 24       	eor	r12, r12
   10288:	dd 24       	eor	r13, r13
   1028a:	0e c0       	rjmp	.+28     	; 0x102a8 <vfscanf+0xa8>
   1028c:	02 60       	ori	r16, 0x02	; 2
   1028e:	b6 01       	movw	r22, r12
   10290:	80 e0       	ldi	r24, 0x00	; 0
   10292:	90 e0       	ldi	r25, 0x00	; 0
   10294:	40 e2       	ldi	r20, 0x20	; 32
   10296:	0e 94 05 7e 	call	0xfc0a	; 0xfc0a <mulacc>
   1029a:	6b 01       	movw	r12, r22
   1029c:	f5 01       	movw	r30, r10
   1029e:	f3 fc       	sbrc	r15, 3
   102a0:	15 91       	lpm	r17, Z+
   102a2:	f3 fe       	sbrs	r15, 3
   102a4:	11 91       	ld	r17, Z+
   102a6:	5f 01       	movw	r10, r30
   102a8:	21 2f       	mov	r18, r17
   102aa:	20 53       	subi	r18, 0x30	; 48
   102ac:	2a 30       	cpi	r18, 0x0A	; 10
   102ae:	70 f3       	brcs	.-36     	; 0x1028c <vfscanf+0x8c>
   102b0:	01 fd       	sbrc	r16, 1
   102b2:	04 c0       	rjmp	.+8      	; 0x102bc <vfscanf+0xbc>
   102b4:	cc 24       	eor	r12, r12
   102b6:	ca 94       	dec	r12
   102b8:	dc 2c       	mov	r13, r12
   102ba:	04 c0       	rjmp	.+8      	; 0x102c4 <vfscanf+0xc4>
   102bc:	c1 14       	cp	r12, r1
   102be:	d1 04       	cpc	r13, r1
   102c0:	09 f4       	brne	.+2      	; 0x102c4 <vfscanf+0xc4>
   102c2:	ca c0       	rjmp	.+404    	; 0x10458 <vfscanf+0x258>
   102c4:	18 36       	cpi	r17, 0x68	; 104
   102c6:	21 f0       	breq	.+8      	; 0x102d0 <vfscanf+0xd0>
   102c8:	1c 36       	cpi	r17, 0x6C	; 108
   102ca:	99 f4       	brne	.+38     	; 0x102f2 <vfscanf+0xf2>
   102cc:	f5 01       	movw	r30, r10
   102ce:	0b c0       	rjmp	.+22     	; 0x102e6 <vfscanf+0xe6>
   102d0:	f5 01       	movw	r30, r10
   102d2:	f3 fc       	sbrc	r15, 3
   102d4:	65 91       	lpm	r22, Z+
   102d6:	f3 fe       	sbrs	r15, 3
   102d8:	61 91       	ld	r22, Z+
   102da:	68 36       	cpi	r22, 0x68	; 104
   102dc:	19 f0       	breq	.+6      	; 0x102e4 <vfscanf+0xe4>
   102de:	5f 01       	movw	r10, r30
   102e0:	16 2f       	mov	r17, r22
   102e2:	07 c0       	rjmp	.+14     	; 0x102f2 <vfscanf+0xf2>
   102e4:	08 60       	ori	r16, 0x08	; 8
   102e6:	04 60       	ori	r16, 0x04	; 4
   102e8:	f3 fc       	sbrc	r15, 3
   102ea:	15 91       	lpm	r17, Z+
   102ec:	f3 fe       	sbrs	r15, 3
   102ee:	11 91       	ld	r17, Z+
   102f0:	5f 01       	movw	r10, r30
   102f2:	11 23       	and	r17, r17
   102f4:	09 f4       	brne	.+2      	; 0x102f8 <vfscanf+0xf8>
   102f6:	b0 c0       	rjmp	.+352    	; 0x10458 <vfscanf+0x258>
   102f8:	86 ed       	ldi	r24, 0xD6	; 214
   102fa:	92 e0       	ldi	r25, 0x02	; 2
   102fc:	61 2f       	mov	r22, r17
   102fe:	70 e0       	ldi	r23, 0x00	; 0
   10300:	0e 94 1b 84 	call	0x10836	; 0x10836 <strchr_P>
   10304:	89 2b       	or	r24, r25
   10306:	09 f4       	brne	.+2      	; 0x1030a <vfscanf+0x10a>
   10308:	a7 c0       	rjmp	.+334    	; 0x10458 <vfscanf+0x258>
   1030a:	80 2f       	mov	r24, r16
   1030c:	00 ff       	sbrs	r16, 0
   1030e:	03 c0       	rjmp	.+6      	; 0x10316 <vfscanf+0x116>
   10310:	ee 24       	eor	r14, r14
   10312:	ff 24       	eor	r15, r15
   10314:	07 c0       	rjmp	.+14     	; 0x10324 <vfscanf+0x124>
   10316:	f3 01       	movw	r30, r6
   10318:	e0 80       	ld	r14, Z
   1031a:	f1 80       	ldd	r15, Z+1	; 0x01
   1031c:	22 e0       	ldi	r18, 0x02	; 2
   1031e:	30 e0       	ldi	r19, 0x00	; 0
   10320:	62 0e       	add	r6, r18
   10322:	73 1e       	adc	r7, r19
   10324:	1e 36       	cpi	r17, 0x6E	; 110
   10326:	51 f4       	brne	.+20     	; 0x1033c <vfscanf+0x13c>
   10328:	f4 01       	movw	r30, r8
   1032a:	46 81       	ldd	r20, Z+6	; 0x06
   1032c:	57 81       	ldd	r21, Z+7	; 0x07
   1032e:	60 e0       	ldi	r22, 0x00	; 0
   10330:	70 e0       	ldi	r23, 0x00	; 0
   10332:	c7 01       	movw	r24, r14
   10334:	20 2f       	mov	r18, r16
   10336:	0e 94 f9 7d 	call	0xfbf2	; 0xfbf2 <putval>
   1033a:	7d c0       	rjmp	.+250    	; 0x10436 <vfscanf+0x236>
   1033c:	13 36       	cpi	r17, 0x63	; 99
   1033e:	b9 f4       	brne	.+46     	; 0x1036e <vfscanf+0x16e>
   10340:	81 fd       	sbrc	r24, 1
   10342:	03 c0       	rjmp	.+6      	; 0x1034a <vfscanf+0x14a>
   10344:	11 e0       	ldi	r17, 0x01	; 1
   10346:	c1 2e       	mov	r12, r17
   10348:	d1 2c       	mov	r13, r1
   1034a:	c4 01       	movw	r24, r8
   1034c:	0e 94 b4 84 	call	0x10968	; 0x10968 <fgetc>
   10350:	97 fd       	sbrc	r25, 7
   10352:	7d c0       	rjmp	.+250    	; 0x1044e <vfscanf+0x24e>
   10354:	e1 14       	cp	r14, r1
   10356:	f1 04       	cpc	r15, r1
   10358:	19 f0       	breq	.+6      	; 0x10360 <vfscanf+0x160>
   1035a:	f7 01       	movw	r30, r14
   1035c:	81 93       	st	Z+, r24
   1035e:	7f 01       	movw	r14, r30
   10360:	08 94       	sec
   10362:	c1 08       	sbc	r12, r1
   10364:	d1 08       	sbc	r13, r1
   10366:	c1 14       	cp	r12, r1
   10368:	d1 04       	cpc	r13, r1
   1036a:	79 f7       	brne	.-34     	; 0x1034a <vfscanf+0x14a>
   1036c:	62 c0       	rjmp	.+196    	; 0x10432 <vfscanf+0x232>
   1036e:	1b 35       	cpi	r17, 0x5B	; 91
   10370:	59 f4       	brne	.+22     	; 0x10388 <vfscanf+0x188>
   10372:	c4 01       	movw	r24, r8
   10374:	b6 01       	movw	r22, r12
   10376:	a7 01       	movw	r20, r14
   10378:	95 01       	movw	r18, r10
   1037a:	0e 94 e0 7e 	call	0xfdc0	; 0xfdc0 <conv_brk>
   1037e:	5c 01       	movw	r10, r24
   10380:	00 97       	sbiw	r24, 0x00	; 0
   10382:	09 f0       	breq	.+2      	; 0x10386 <vfscanf+0x186>
   10384:	56 c0       	rjmp	.+172    	; 0x10432 <vfscanf+0x232>
   10386:	50 c0       	rjmp	.+160    	; 0x10428 <vfscanf+0x228>
   10388:	c4 01       	movw	r24, r8
   1038a:	0e 94 33 7e 	call	0xfc66	; 0xfc66 <skip_spaces>
   1038e:	97 fd       	sbrc	r25, 7
   10390:	5e c0       	rjmp	.+188    	; 0x1044e <vfscanf+0x24e>
   10392:	1f 36       	cpi	r17, 0x6F	; 111
   10394:	d1 f1       	breq	.+116    	; 0x1040a <vfscanf+0x20a>
   10396:	10 37       	cpi	r17, 0x70	; 112
   10398:	38 f4       	brcc	.+14     	; 0x103a8 <vfscanf+0x1a8>
   1039a:	14 36       	cpi	r17, 0x64	; 100
   1039c:	a1 f1       	breq	.+104    	; 0x10406 <vfscanf+0x206>
   1039e:	19 36       	cpi	r17, 0x69	; 105
   103a0:	a9 f1       	breq	.+106    	; 0x1040c <vfscanf+0x20c>
   103a2:	18 35       	cpi	r17, 0x58	; 88
   103a4:	d1 f5       	brne	.+116    	; 0x1041a <vfscanf+0x21a>
   103a6:	2d c0       	rjmp	.+90     	; 0x10402 <vfscanf+0x202>
   103a8:	13 37       	cpi	r17, 0x73	; 115
   103aa:	51 f0       	breq	.+20     	; 0x103c0 <vfscanf+0x1c0>
   103ac:	14 37       	cpi	r17, 0x74	; 116
   103ae:	18 f4       	brcc	.+6      	; 0x103b6 <vfscanf+0x1b6>
   103b0:	10 37       	cpi	r17, 0x70	; 112
   103b2:	99 f5       	brne	.+102    	; 0x1041a <vfscanf+0x21a>
   103b4:	26 c0       	rjmp	.+76     	; 0x10402 <vfscanf+0x202>
   103b6:	15 37       	cpi	r17, 0x75	; 117
   103b8:	31 f1       	breq	.+76     	; 0x10406 <vfscanf+0x206>
   103ba:	18 37       	cpi	r17, 0x78	; 120
   103bc:	71 f5       	brne	.+92     	; 0x1041a <vfscanf+0x21a>
   103be:	21 c0       	rjmp	.+66     	; 0x10402 <vfscanf+0x202>
   103c0:	c4 01       	movw	r24, r8
   103c2:	0e 94 b4 84 	call	0x10968	; 0x10968 <fgetc>
   103c6:	ec 01       	movw	r28, r24
   103c8:	97 fd       	sbrc	r25, 7
   103ca:	15 c0       	rjmp	.+42     	; 0x103f6 <vfscanf+0x1f6>
   103cc:	0e 94 0b 84 	call	0x10816	; 0x10816 <isspace>
   103d0:	89 2b       	or	r24, r25
   103d2:	29 f0       	breq	.+10     	; 0x103de <vfscanf+0x1de>
   103d4:	ce 01       	movw	r24, r28
   103d6:	b4 01       	movw	r22, r8
   103d8:	0e 94 ca 85 	call	0x10b94	; 0x10b94 <ungetc>
   103dc:	0c c0       	rjmp	.+24     	; 0x103f6 <vfscanf+0x1f6>
   103de:	e1 14       	cp	r14, r1
   103e0:	f1 04       	cpc	r15, r1
   103e2:	19 f0       	breq	.+6      	; 0x103ea <vfscanf+0x1ea>
   103e4:	f7 01       	movw	r30, r14
   103e6:	c1 93       	st	Z+, r28
   103e8:	7f 01       	movw	r14, r30
   103ea:	08 94       	sec
   103ec:	c1 08       	sbc	r12, r1
   103ee:	d1 08       	sbc	r13, r1
   103f0:	c1 14       	cp	r12, r1
   103f2:	d1 04       	cpc	r13, r1
   103f4:	29 f7       	brne	.-54     	; 0x103c0 <vfscanf+0x1c0>
   103f6:	e1 14       	cp	r14, r1
   103f8:	f1 04       	cpc	r15, r1
   103fa:	d9 f0       	breq	.+54     	; 0x10432 <vfscanf+0x232>
   103fc:	f7 01       	movw	r30, r14
   103fe:	10 82       	st	Z, r1
   10400:	18 c0       	rjmp	.+48     	; 0x10432 <vfscanf+0x232>
   10402:	00 64       	ori	r16, 0x40	; 64
   10404:	03 c0       	rjmp	.+6      	; 0x1040c <vfscanf+0x20c>
   10406:	00 62       	ori	r16, 0x20	; 32
   10408:	01 c0       	rjmp	.+2      	; 0x1040c <vfscanf+0x20c>
   1040a:	00 61       	ori	r16, 0x10	; 16
   1040c:	c4 01       	movw	r24, r8
   1040e:	b6 01       	movw	r22, r12
   10410:	a7 01       	movw	r20, r14
   10412:	20 2f       	mov	r18, r16
   10414:	0e 94 4c 7e 	call	0xfc98	; 0xfc98 <conv_int>
   10418:	05 c0       	rjmp	.+10     	; 0x10424 <vfscanf+0x224>
   1041a:	c4 01       	movw	r24, r8
   1041c:	b6 01       	movw	r22, r12
   1041e:	a7 01       	movw	r20, r14
   10420:	0e 94 ad 7f 	call	0xff5a	; 0xff5a <conv_flt>
   10424:	88 23       	and	r24, r24
   10426:	29 f4       	brne	.+10     	; 0x10432 <vfscanf+0x232>
   10428:	f4 01       	movw	r30, r8
   1042a:	83 81       	ldd	r24, Z+3	; 0x03
   1042c:	80 73       	andi	r24, 0x30	; 48
   1042e:	79 f4       	brne	.+30     	; 0x1044e <vfscanf+0x24e>
   10430:	13 c0       	rjmp	.+38     	; 0x10458 <vfscanf+0x258>
   10432:	00 ff       	sbrs	r16, 0
   10434:	53 94       	inc	r5
   10436:	f4 01       	movw	r30, r8
   10438:	f3 80       	ldd	r15, Z+3	; 0x03
   1043a:	f5 01       	movw	r30, r10
   1043c:	f3 fc       	sbrc	r15, 3
   1043e:	15 91       	lpm	r17, Z+
   10440:	f3 fe       	sbrs	r15, 3
   10442:	11 91       	ld	r17, Z+
   10444:	5f 01       	movw	r10, r30
   10446:	11 23       	and	r17, r17
   10448:	09 f0       	breq	.+2      	; 0x1044c <vfscanf+0x24c>
   1044a:	f1 ce       	rjmp	.-542    	; 0x1022e <vfscanf+0x2e>
   1044c:	05 c0       	rjmp	.+10     	; 0x10458 <vfscanf+0x258>
   1044e:	55 20       	and	r5, r5
   10450:	19 f4       	brne	.+6      	; 0x10458 <vfscanf+0x258>
   10452:	2f ef       	ldi	r18, 0xFF	; 255
   10454:	3f ef       	ldi	r19, 0xFF	; 255
   10456:	02 c0       	rjmp	.+4      	; 0x1045c <vfscanf+0x25c>
   10458:	25 2d       	mov	r18, r5
   1045a:	30 e0       	ldi	r19, 0x00	; 0
   1045c:	c9 01       	movw	r24, r18
   1045e:	df 91       	pop	r29
   10460:	cf 91       	pop	r28
   10462:	1f 91       	pop	r17
   10464:	0f 91       	pop	r16
   10466:	ff 90       	pop	r15
   10468:	ef 90       	pop	r14
   1046a:	df 90       	pop	r13
   1046c:	cf 90       	pop	r12
   1046e:	bf 90       	pop	r11
   10470:	af 90       	pop	r10
   10472:	9f 90       	pop	r9
   10474:	8f 90       	pop	r8
   10476:	7f 90       	pop	r7
   10478:	6f 90       	pop	r6
   1047a:	5f 90       	pop	r5
   1047c:	08 95       	ret

0001047e <__floatunsisf>:
   1047e:	e8 94       	clt
   10480:	09 c0       	rjmp	.+18     	; 0x10494 <__floatsisf+0x12>

00010482 <__floatsisf>:
   10482:	97 fb       	bst	r25, 7
   10484:	3e f4       	brtc	.+14     	; 0x10494 <__floatsisf+0x12>
   10486:	90 95       	com	r25
   10488:	80 95       	com	r24
   1048a:	70 95       	com	r23
   1048c:	61 95       	neg	r22
   1048e:	7f 4f       	sbci	r23, 0xFF	; 255
   10490:	8f 4f       	sbci	r24, 0xFF	; 255
   10492:	9f 4f       	sbci	r25, 0xFF	; 255
   10494:	99 23       	and	r25, r25
   10496:	a9 f0       	breq	.+42     	; 0x104c2 <__floatsisf+0x40>
   10498:	f9 2f       	mov	r31, r25
   1049a:	96 e9       	ldi	r25, 0x96	; 150
   1049c:	bb 27       	eor	r27, r27
   1049e:	93 95       	inc	r25
   104a0:	f6 95       	lsr	r31
   104a2:	87 95       	ror	r24
   104a4:	77 95       	ror	r23
   104a6:	67 95       	ror	r22
   104a8:	b7 95       	ror	r27
   104aa:	f1 11       	cpse	r31, r1
   104ac:	f8 cf       	rjmp	.-16     	; 0x1049e <__floatsisf+0x1c>
   104ae:	fa f4       	brpl	.+62     	; 0x104ee <__floatsisf+0x6c>
   104b0:	bb 0f       	add	r27, r27
   104b2:	11 f4       	brne	.+4      	; 0x104b8 <__floatsisf+0x36>
   104b4:	60 ff       	sbrs	r22, 0
   104b6:	1b c0       	rjmp	.+54     	; 0x104ee <__floatsisf+0x6c>
   104b8:	6f 5f       	subi	r22, 0xFF	; 255
   104ba:	7f 4f       	sbci	r23, 0xFF	; 255
   104bc:	8f 4f       	sbci	r24, 0xFF	; 255
   104be:	9f 4f       	sbci	r25, 0xFF	; 255
   104c0:	16 c0       	rjmp	.+44     	; 0x104ee <__floatsisf+0x6c>
   104c2:	88 23       	and	r24, r24
   104c4:	11 f0       	breq	.+4      	; 0x104ca <__floatsisf+0x48>
   104c6:	96 e9       	ldi	r25, 0x96	; 150
   104c8:	11 c0       	rjmp	.+34     	; 0x104ec <__floatsisf+0x6a>
   104ca:	77 23       	and	r23, r23
   104cc:	21 f0       	breq	.+8      	; 0x104d6 <__floatsisf+0x54>
   104ce:	9e e8       	ldi	r25, 0x8E	; 142
   104d0:	87 2f       	mov	r24, r23
   104d2:	76 2f       	mov	r23, r22
   104d4:	05 c0       	rjmp	.+10     	; 0x104e0 <__floatsisf+0x5e>
   104d6:	66 23       	and	r22, r22
   104d8:	71 f0       	breq	.+28     	; 0x104f6 <__floatsisf+0x74>
   104da:	96 e8       	ldi	r25, 0x86	; 134
   104dc:	86 2f       	mov	r24, r22
   104de:	70 e0       	ldi	r23, 0x00	; 0
   104e0:	60 e0       	ldi	r22, 0x00	; 0
   104e2:	2a f0       	brmi	.+10     	; 0x104ee <__floatsisf+0x6c>
   104e4:	9a 95       	dec	r25
   104e6:	66 0f       	add	r22, r22
   104e8:	77 1f       	adc	r23, r23
   104ea:	88 1f       	adc	r24, r24
   104ec:	da f7       	brpl	.-10     	; 0x104e4 <__floatsisf+0x62>
   104ee:	88 0f       	add	r24, r24
   104f0:	96 95       	lsr	r25
   104f2:	87 95       	ror	r24
   104f4:	97 f9       	bld	r25, 7
   104f6:	08 95       	ret

000104f8 <__mulsf3>:
   104f8:	0b d0       	rcall	.+22     	; 0x10510 <__mulsf3x>
   104fa:	78 c0       	rjmp	.+240    	; 0x105ec <__fp_round>
   104fc:	69 d0       	rcall	.+210    	; 0x105d0 <__fp_pscA>
   104fe:	28 f0       	brcs	.+10     	; 0x1050a <__mulsf3+0x12>
   10500:	6e d0       	rcall	.+220    	; 0x105de <__fp_pscB>
   10502:	18 f0       	brcs	.+6      	; 0x1050a <__mulsf3+0x12>
   10504:	95 23       	and	r25, r21
   10506:	09 f0       	breq	.+2      	; 0x1050a <__mulsf3+0x12>
   10508:	5a c0       	rjmp	.+180    	; 0x105be <__fp_inf>
   1050a:	5f c0       	rjmp	.+190    	; 0x105ca <__fp_nan>
   1050c:	11 24       	eor	r1, r1
   1050e:	a2 c0       	rjmp	.+324    	; 0x10654 <__fp_szero>

00010510 <__mulsf3x>:
   10510:	7e d0       	rcall	.+252    	; 0x1060e <__fp_split3>
   10512:	a0 f3       	brcs	.-24     	; 0x104fc <__mulsf3+0x4>

00010514 <__mulsf3_pse>:
   10514:	95 9f       	mul	r25, r21
   10516:	d1 f3       	breq	.-12     	; 0x1050c <__mulsf3+0x14>
   10518:	95 0f       	add	r25, r21
   1051a:	50 e0       	ldi	r21, 0x00	; 0
   1051c:	55 1f       	adc	r21, r21
   1051e:	62 9f       	mul	r22, r18
   10520:	f0 01       	movw	r30, r0
   10522:	72 9f       	mul	r23, r18
   10524:	bb 27       	eor	r27, r27
   10526:	f0 0d       	add	r31, r0
   10528:	b1 1d       	adc	r27, r1
   1052a:	63 9f       	mul	r22, r19
   1052c:	aa 27       	eor	r26, r26
   1052e:	f0 0d       	add	r31, r0
   10530:	b1 1d       	adc	r27, r1
   10532:	aa 1f       	adc	r26, r26
   10534:	64 9f       	mul	r22, r20
   10536:	66 27       	eor	r22, r22
   10538:	b0 0d       	add	r27, r0
   1053a:	a1 1d       	adc	r26, r1
   1053c:	66 1f       	adc	r22, r22
   1053e:	82 9f       	mul	r24, r18
   10540:	22 27       	eor	r18, r18
   10542:	b0 0d       	add	r27, r0
   10544:	a1 1d       	adc	r26, r1
   10546:	62 1f       	adc	r22, r18
   10548:	73 9f       	mul	r23, r19
   1054a:	b0 0d       	add	r27, r0
   1054c:	a1 1d       	adc	r26, r1
   1054e:	62 1f       	adc	r22, r18
   10550:	83 9f       	mul	r24, r19
   10552:	a0 0d       	add	r26, r0
   10554:	61 1d       	adc	r22, r1
   10556:	22 1f       	adc	r18, r18
   10558:	74 9f       	mul	r23, r20
   1055a:	33 27       	eor	r19, r19
   1055c:	a0 0d       	add	r26, r0
   1055e:	61 1d       	adc	r22, r1
   10560:	23 1f       	adc	r18, r19
   10562:	84 9f       	mul	r24, r20
   10564:	60 0d       	add	r22, r0
   10566:	21 1d       	adc	r18, r1
   10568:	82 2f       	mov	r24, r18
   1056a:	76 2f       	mov	r23, r22
   1056c:	6a 2f       	mov	r22, r26
   1056e:	11 24       	eor	r1, r1
   10570:	9f 57       	subi	r25, 0x7F	; 127
   10572:	50 40       	sbci	r21, 0x00	; 0
   10574:	8a f0       	brmi	.+34     	; 0x10598 <__mulsf3_pse+0x84>
   10576:	e1 f0       	breq	.+56     	; 0x105b0 <__mulsf3_pse+0x9c>
   10578:	88 23       	and	r24, r24
   1057a:	4a f0       	brmi	.+18     	; 0x1058e <__mulsf3_pse+0x7a>
   1057c:	ee 0f       	add	r30, r30
   1057e:	ff 1f       	adc	r31, r31
   10580:	bb 1f       	adc	r27, r27
   10582:	66 1f       	adc	r22, r22
   10584:	77 1f       	adc	r23, r23
   10586:	88 1f       	adc	r24, r24
   10588:	91 50       	subi	r25, 0x01	; 1
   1058a:	50 40       	sbci	r21, 0x00	; 0
   1058c:	a9 f7       	brne	.-22     	; 0x10578 <__mulsf3_pse+0x64>
   1058e:	9e 3f       	cpi	r25, 0xFE	; 254
   10590:	51 05       	cpc	r21, r1
   10592:	70 f0       	brcs	.+28     	; 0x105b0 <__mulsf3_pse+0x9c>
   10594:	14 c0       	rjmp	.+40     	; 0x105be <__fp_inf>
   10596:	5e c0       	rjmp	.+188    	; 0x10654 <__fp_szero>
   10598:	5f 3f       	cpi	r21, 0xFF	; 255
   1059a:	ec f3       	brlt	.-6      	; 0x10596 <__mulsf3_pse+0x82>
   1059c:	98 3e       	cpi	r25, 0xE8	; 232
   1059e:	dc f3       	brlt	.-10     	; 0x10596 <__mulsf3_pse+0x82>
   105a0:	86 95       	lsr	r24
   105a2:	77 95       	ror	r23
   105a4:	67 95       	ror	r22
   105a6:	b7 95       	ror	r27
   105a8:	f7 95       	ror	r31
   105aa:	e7 95       	ror	r30
   105ac:	9f 5f       	subi	r25, 0xFF	; 255
   105ae:	c1 f7       	brne	.-16     	; 0x105a0 <__mulsf3_pse+0x8c>
   105b0:	fe 2b       	or	r31, r30
   105b2:	88 0f       	add	r24, r24
   105b4:	91 1d       	adc	r25, r1
   105b6:	96 95       	lsr	r25
   105b8:	87 95       	ror	r24
   105ba:	97 f9       	bld	r25, 7
   105bc:	08 95       	ret

000105be <__fp_inf>:
   105be:	97 f9       	bld	r25, 7
   105c0:	9f 67       	ori	r25, 0x7F	; 127
   105c2:	80 e8       	ldi	r24, 0x80	; 128
   105c4:	70 e0       	ldi	r23, 0x00	; 0
   105c6:	60 e0       	ldi	r22, 0x00	; 0
   105c8:	08 95       	ret

000105ca <__fp_nan>:
   105ca:	9f ef       	ldi	r25, 0xFF	; 255
   105cc:	80 ec       	ldi	r24, 0xC0	; 192
   105ce:	08 95       	ret

000105d0 <__fp_pscA>:
   105d0:	00 24       	eor	r0, r0
   105d2:	0a 94       	dec	r0
   105d4:	16 16       	cp	r1, r22
   105d6:	17 06       	cpc	r1, r23
   105d8:	18 06       	cpc	r1, r24
   105da:	09 06       	cpc	r0, r25
   105dc:	08 95       	ret

000105de <__fp_pscB>:
   105de:	00 24       	eor	r0, r0
   105e0:	0a 94       	dec	r0
   105e2:	12 16       	cp	r1, r18
   105e4:	13 06       	cpc	r1, r19
   105e6:	14 06       	cpc	r1, r20
   105e8:	05 06       	cpc	r0, r21
   105ea:	08 95       	ret

000105ec <__fp_round>:
   105ec:	09 2e       	mov	r0, r25
   105ee:	03 94       	inc	r0
   105f0:	00 0c       	add	r0, r0
   105f2:	11 f4       	brne	.+4      	; 0x105f8 <__fp_round+0xc>
   105f4:	88 23       	and	r24, r24
   105f6:	52 f0       	brmi	.+20     	; 0x1060c <__fp_round+0x20>
   105f8:	bb 0f       	add	r27, r27
   105fa:	40 f4       	brcc	.+16     	; 0x1060c <__fp_round+0x20>
   105fc:	bf 2b       	or	r27, r31
   105fe:	11 f4       	brne	.+4      	; 0x10604 <__fp_round+0x18>
   10600:	60 ff       	sbrs	r22, 0
   10602:	04 c0       	rjmp	.+8      	; 0x1060c <__fp_round+0x20>
   10604:	6f 5f       	subi	r22, 0xFF	; 255
   10606:	7f 4f       	sbci	r23, 0xFF	; 255
   10608:	8f 4f       	sbci	r24, 0xFF	; 255
   1060a:	9f 4f       	sbci	r25, 0xFF	; 255
   1060c:	08 95       	ret

0001060e <__fp_split3>:
   1060e:	57 fd       	sbrc	r21, 7
   10610:	90 58       	subi	r25, 0x80	; 128
   10612:	44 0f       	add	r20, r20
   10614:	55 1f       	adc	r21, r21
   10616:	59 f0       	breq	.+22     	; 0x1062e <__fp_splitA+0x10>
   10618:	5f 3f       	cpi	r21, 0xFF	; 255
   1061a:	71 f0       	breq	.+28     	; 0x10638 <__fp_splitA+0x1a>
   1061c:	47 95       	ror	r20

0001061e <__fp_splitA>:
   1061e:	88 0f       	add	r24, r24
   10620:	97 fb       	bst	r25, 7
   10622:	99 1f       	adc	r25, r25
   10624:	61 f0       	breq	.+24     	; 0x1063e <__fp_splitA+0x20>
   10626:	9f 3f       	cpi	r25, 0xFF	; 255
   10628:	79 f0       	breq	.+30     	; 0x10648 <__fp_splitA+0x2a>
   1062a:	87 95       	ror	r24
   1062c:	08 95       	ret
   1062e:	12 16       	cp	r1, r18
   10630:	13 06       	cpc	r1, r19
   10632:	14 06       	cpc	r1, r20
   10634:	55 1f       	adc	r21, r21
   10636:	f2 cf       	rjmp	.-28     	; 0x1061c <__fp_split3+0xe>
   10638:	46 95       	lsr	r20
   1063a:	f1 df       	rcall	.-30     	; 0x1061e <__fp_splitA>
   1063c:	08 c0       	rjmp	.+16     	; 0x1064e <__fp_splitA+0x30>
   1063e:	16 16       	cp	r1, r22
   10640:	17 06       	cpc	r1, r23
   10642:	18 06       	cpc	r1, r24
   10644:	99 1f       	adc	r25, r25
   10646:	f1 cf       	rjmp	.-30     	; 0x1062a <__fp_splitA+0xc>
   10648:	86 95       	lsr	r24
   1064a:	71 05       	cpc	r23, r1
   1064c:	61 05       	cpc	r22, r1
   1064e:	08 94       	sec
   10650:	08 95       	ret

00010652 <__fp_zero>:
   10652:	e8 94       	clt

00010654 <__fp_szero>:
   10654:	bb 27       	eor	r27, r27
   10656:	66 27       	eor	r22, r22
   10658:	77 27       	eor	r23, r23
   1065a:	cb 01       	movw	r24, r22
   1065c:	97 f9       	bld	r25, 7
   1065e:	08 95       	ret

00010660 <exit>:
   10660:	f8 94       	cli
   10662:	0c 94 1b 88 	jmp	0x11036	; 0x11036 <_exit>

00010666 <__ftoa_engine>:
   10666:	28 30       	cpi	r18, 0x08	; 8
   10668:	08 f0       	brcs	.+2      	; 0x1066c <__ftoa_engine+0x6>
   1066a:	27 e0       	ldi	r18, 0x07	; 7
   1066c:	33 27       	eor	r19, r19
   1066e:	da 01       	movw	r26, r20
   10670:	99 0f       	add	r25, r25
   10672:	31 1d       	adc	r19, r1
   10674:	87 fd       	sbrc	r24, 7
   10676:	91 60       	ori	r25, 0x01	; 1
   10678:	00 96       	adiw	r24, 0x00	; 0
   1067a:	61 05       	cpc	r22, r1
   1067c:	71 05       	cpc	r23, r1
   1067e:	39 f4       	brne	.+14     	; 0x1068e <__ftoa_engine+0x28>
   10680:	32 60       	ori	r19, 0x02	; 2
   10682:	2e 5f       	subi	r18, 0xFE	; 254
   10684:	3d 93       	st	X+, r19
   10686:	30 e3       	ldi	r19, 0x30	; 48
   10688:	2a 95       	dec	r18
   1068a:	e1 f7       	brne	.-8      	; 0x10684 <__ftoa_engine+0x1e>
   1068c:	08 95       	ret
   1068e:	9f 3f       	cpi	r25, 0xFF	; 255
   10690:	30 f0       	brcs	.+12     	; 0x1069e <__ftoa_engine+0x38>
   10692:	80 38       	cpi	r24, 0x80	; 128
   10694:	71 05       	cpc	r23, r1
   10696:	61 05       	cpc	r22, r1
   10698:	09 f0       	breq	.+2      	; 0x1069c <__ftoa_engine+0x36>
   1069a:	3c 5f       	subi	r19, 0xFC	; 252
   1069c:	3c 5f       	subi	r19, 0xFC	; 252
   1069e:	3d 93       	st	X+, r19
   106a0:	91 30       	cpi	r25, 0x01	; 1
   106a2:	08 f0       	brcs	.+2      	; 0x106a6 <__ftoa_engine+0x40>
   106a4:	80 68       	ori	r24, 0x80	; 128
   106a6:	91 1d       	adc	r25, r1
   106a8:	df 93       	push	r29
   106aa:	cf 93       	push	r28
   106ac:	1f 93       	push	r17
   106ae:	0f 93       	push	r16
   106b0:	ff 92       	push	r15
   106b2:	ef 92       	push	r14
   106b4:	19 2f       	mov	r17, r25
   106b6:	98 7f       	andi	r25, 0xF8	; 248
   106b8:	96 95       	lsr	r25
   106ba:	e9 2f       	mov	r30, r25
   106bc:	96 95       	lsr	r25
   106be:	96 95       	lsr	r25
   106c0:	e9 0f       	add	r30, r25
   106c2:	ff 27       	eor	r31, r31
   106c4:	ec 5c       	subi	r30, 0xCC	; 204
   106c6:	f7 4c       	sbci	r31, 0xC7	; 199
   106c8:	99 27       	eor	r25, r25
   106ca:	33 27       	eor	r19, r19
   106cc:	ee 24       	eor	r14, r14
   106ce:	ff 24       	eor	r15, r15
   106d0:	a7 01       	movw	r20, r14
   106d2:	e7 01       	movw	r28, r14
   106d4:	05 90       	lpm	r0, Z+
   106d6:	08 94       	sec
   106d8:	07 94       	ror	r0
   106da:	28 f4       	brcc	.+10     	; 0x106e6 <__ftoa_engine+0x80>
   106dc:	36 0f       	add	r19, r22
   106de:	e7 1e       	adc	r14, r23
   106e0:	f8 1e       	adc	r15, r24
   106e2:	49 1f       	adc	r20, r25
   106e4:	51 1d       	adc	r21, r1
   106e6:	66 0f       	add	r22, r22
   106e8:	77 1f       	adc	r23, r23
   106ea:	88 1f       	adc	r24, r24
   106ec:	99 1f       	adc	r25, r25
   106ee:	06 94       	lsr	r0
   106f0:	a1 f7       	brne	.-24     	; 0x106da <__ftoa_engine+0x74>
   106f2:	05 90       	lpm	r0, Z+
   106f4:	07 94       	ror	r0
   106f6:	28 f4       	brcc	.+10     	; 0x10702 <__ftoa_engine+0x9c>
   106f8:	e7 0e       	add	r14, r23
   106fa:	f8 1e       	adc	r15, r24
   106fc:	49 1f       	adc	r20, r25
   106fe:	56 1f       	adc	r21, r22
   10700:	c1 1d       	adc	r28, r1
   10702:	77 0f       	add	r23, r23
   10704:	88 1f       	adc	r24, r24
   10706:	99 1f       	adc	r25, r25
   10708:	66 1f       	adc	r22, r22
   1070a:	06 94       	lsr	r0
   1070c:	a1 f7       	brne	.-24     	; 0x106f6 <__ftoa_engine+0x90>
   1070e:	05 90       	lpm	r0, Z+
   10710:	07 94       	ror	r0
   10712:	28 f4       	brcc	.+10     	; 0x1071e <__ftoa_engine+0xb8>
   10714:	f8 0e       	add	r15, r24
   10716:	49 1f       	adc	r20, r25
   10718:	56 1f       	adc	r21, r22
   1071a:	c7 1f       	adc	r28, r23
   1071c:	d1 1d       	adc	r29, r1
   1071e:	88 0f       	add	r24, r24
   10720:	99 1f       	adc	r25, r25
   10722:	66 1f       	adc	r22, r22
   10724:	77 1f       	adc	r23, r23
   10726:	06 94       	lsr	r0
   10728:	a1 f7       	brne	.-24     	; 0x10712 <__ftoa_engine+0xac>
   1072a:	05 90       	lpm	r0, Z+
   1072c:	07 94       	ror	r0
   1072e:	20 f4       	brcc	.+8      	; 0x10738 <__ftoa_engine+0xd2>
   10730:	49 0f       	add	r20, r25
   10732:	56 1f       	adc	r21, r22
   10734:	c7 1f       	adc	r28, r23
   10736:	d8 1f       	adc	r29, r24
   10738:	99 0f       	add	r25, r25
   1073a:	66 1f       	adc	r22, r22
   1073c:	77 1f       	adc	r23, r23
   1073e:	88 1f       	adc	r24, r24
   10740:	06 94       	lsr	r0
   10742:	a9 f7       	brne	.-22     	; 0x1072e <__ftoa_engine+0xc8>
   10744:	84 91       	lpm	r24, Z+
   10746:	10 95       	com	r17
   10748:	17 70       	andi	r17, 0x07	; 7
   1074a:	41 f0       	breq	.+16     	; 0x1075c <__ftoa_engine+0xf6>
   1074c:	d6 95       	lsr	r29
   1074e:	c7 95       	ror	r28
   10750:	57 95       	ror	r21
   10752:	47 95       	ror	r20
   10754:	f7 94       	ror	r15
   10756:	e7 94       	ror	r14
   10758:	1a 95       	dec	r17
   1075a:	c1 f7       	brne	.-16     	; 0x1074c <__ftoa_engine+0xe6>
   1075c:	ea ed       	ldi	r30, 0xDA	; 218
   1075e:	f7 e3       	ldi	r31, 0x37	; 55
   10760:	68 94       	set
   10762:	15 90       	lpm	r1, Z+
   10764:	15 91       	lpm	r17, Z+
   10766:	35 91       	lpm	r19, Z+
   10768:	65 91       	lpm	r22, Z+
   1076a:	95 91       	lpm	r25, Z+
   1076c:	05 90       	lpm	r0, Z+
   1076e:	7f e2       	ldi	r23, 0x2F	; 47
   10770:	73 95       	inc	r23
   10772:	e1 18       	sub	r14, r1
   10774:	f1 0a       	sbc	r15, r17
   10776:	43 0b       	sbc	r20, r19
   10778:	56 0b       	sbc	r21, r22
   1077a:	c9 0b       	sbc	r28, r25
   1077c:	d0 09       	sbc	r29, r0
   1077e:	c0 f7       	brcc	.-16     	; 0x10770 <__ftoa_engine+0x10a>
   10780:	e1 0c       	add	r14, r1
   10782:	f1 1e       	adc	r15, r17
   10784:	43 1f       	adc	r20, r19
   10786:	56 1f       	adc	r21, r22
   10788:	c9 1f       	adc	r28, r25
   1078a:	d0 1d       	adc	r29, r0
   1078c:	7e f4       	brtc	.+30     	; 0x107ac <__ftoa_engine+0x146>
   1078e:	70 33       	cpi	r23, 0x30	; 48
   10790:	11 f4       	brne	.+4      	; 0x10796 <__ftoa_engine+0x130>
   10792:	8a 95       	dec	r24
   10794:	e6 cf       	rjmp	.-52     	; 0x10762 <__ftoa_engine+0xfc>
   10796:	e8 94       	clt
   10798:	01 50       	subi	r16, 0x01	; 1
   1079a:	30 f0       	brcs	.+12     	; 0x107a8 <__ftoa_engine+0x142>
   1079c:	08 0f       	add	r16, r24
   1079e:	0a f4       	brpl	.+2      	; 0x107a2 <__ftoa_engine+0x13c>
   107a0:	00 27       	eor	r16, r16
   107a2:	02 17       	cp	r16, r18
   107a4:	08 f4       	brcc	.+2      	; 0x107a8 <__ftoa_engine+0x142>
   107a6:	20 2f       	mov	r18, r16
   107a8:	23 95       	inc	r18
   107aa:	02 2f       	mov	r16, r18
   107ac:	7a 33       	cpi	r23, 0x3A	; 58
   107ae:	28 f0       	brcs	.+10     	; 0x107ba <__ftoa_engine+0x154>
   107b0:	79 e3       	ldi	r23, 0x39	; 57
   107b2:	7d 93       	st	X+, r23
   107b4:	2a 95       	dec	r18
   107b6:	e9 f7       	brne	.-6      	; 0x107b2 <__ftoa_engine+0x14c>
   107b8:	10 c0       	rjmp	.+32     	; 0x107da <__ftoa_engine+0x174>
   107ba:	7d 93       	st	X+, r23
   107bc:	2a 95       	dec	r18
   107be:	89 f6       	brne	.-94     	; 0x10762 <__ftoa_engine+0xfc>
   107c0:	06 94       	lsr	r0
   107c2:	97 95       	ror	r25
   107c4:	67 95       	ror	r22
   107c6:	37 95       	ror	r19
   107c8:	17 95       	ror	r17
   107ca:	17 94       	ror	r1
   107cc:	e1 18       	sub	r14, r1
   107ce:	f1 0a       	sbc	r15, r17
   107d0:	43 0b       	sbc	r20, r19
   107d2:	56 0b       	sbc	r21, r22
   107d4:	c9 0b       	sbc	r28, r25
   107d6:	d0 09       	sbc	r29, r0
   107d8:	98 f0       	brcs	.+38     	; 0x10800 <__ftoa_engine+0x19a>
   107da:	23 95       	inc	r18
   107dc:	7e 91       	ld	r23, -X
   107de:	73 95       	inc	r23
   107e0:	7a 33       	cpi	r23, 0x3A	; 58
   107e2:	08 f0       	brcs	.+2      	; 0x107e6 <__ftoa_engine+0x180>
   107e4:	70 e3       	ldi	r23, 0x30	; 48
   107e6:	7c 93       	st	X, r23
   107e8:	20 13       	cpse	r18, r16
   107ea:	b8 f7       	brcc	.-18     	; 0x107da <__ftoa_engine+0x174>
   107ec:	7e 91       	ld	r23, -X
   107ee:	70 61       	ori	r23, 0x10	; 16
   107f0:	7d 93       	st	X+, r23
   107f2:	30 f0       	brcs	.+12     	; 0x10800 <__ftoa_engine+0x19a>
   107f4:	83 95       	inc	r24
   107f6:	71 e3       	ldi	r23, 0x31	; 49
   107f8:	7d 93       	st	X+, r23
   107fa:	70 e3       	ldi	r23, 0x30	; 48
   107fc:	2a 95       	dec	r18
   107fe:	e1 f7       	brne	.-8      	; 0x107f8 <__ftoa_engine+0x192>
   10800:	11 24       	eor	r1, r1
   10802:	ef 90       	pop	r14
   10804:	ff 90       	pop	r15
   10806:	0f 91       	pop	r16
   10808:	1f 91       	pop	r17
   1080a:	cf 91       	pop	r28
   1080c:	df 91       	pop	r29
   1080e:	99 27       	eor	r25, r25
   10810:	87 fd       	sbrc	r24, 7
   10812:	90 95       	com	r25
   10814:	08 95       	ret

00010816 <isspace>:
   10816:	91 11       	cpse	r25, r1
   10818:	7c c3       	rjmp	.+1784   	; 0x10f12 <__ctype_isfalse>
   1081a:	80 32       	cpi	r24, 0x20	; 32
   1081c:	19 f0       	breq	.+6      	; 0x10824 <isspace+0xe>
   1081e:	89 50       	subi	r24, 0x09	; 9
   10820:	85 50       	subi	r24, 0x05	; 5
   10822:	d0 f7       	brcc	.-12     	; 0x10818 <isspace+0x2>
   10824:	08 95       	ret

00010826 <tolower>:
   10826:	91 11       	cpse	r25, r1
   10828:	08 95       	ret
   1082a:	81 54       	subi	r24, 0x41	; 65
   1082c:	8a 51       	subi	r24, 0x1A	; 26
   1082e:	08 f4       	brcc	.+2      	; 0x10832 <tolower+0xc>
   10830:	80 5e       	subi	r24, 0xE0	; 224
   10832:	85 5a       	subi	r24, 0xA5	; 165
   10834:	08 95       	ret

00010836 <strchr_P>:
   10836:	fc 01       	movw	r30, r24
   10838:	05 90       	lpm	r0, Z+
   1083a:	06 16       	cp	r0, r22
   1083c:	21 f0       	breq	.+8      	; 0x10846 <strchr_P+0x10>
   1083e:	00 20       	and	r0, r0
   10840:	d9 f7       	brne	.-10     	; 0x10838 <strchr_P+0x2>
   10842:	c0 01       	movw	r24, r0
   10844:	08 95       	ret
   10846:	31 97       	sbiw	r30, 0x01	; 1
   10848:	cf 01       	movw	r24, r30
   1084a:	08 95       	ret

0001084c <strcmp_P>:
   1084c:	fb 01       	movw	r30, r22
   1084e:	dc 01       	movw	r26, r24
   10850:	8d 91       	ld	r24, X+
   10852:	05 90       	lpm	r0, Z+
   10854:	80 19       	sub	r24, r0
   10856:	01 10       	cpse	r0, r1
   10858:	d9 f3       	breq	.-10     	; 0x10850 <strcmp_P+0x4>
   1085a:	99 0b       	sbc	r25, r25
   1085c:	08 95       	ret

0001085e <strcpy_P>:
   1085e:	fb 01       	movw	r30, r22
   10860:	dc 01       	movw	r26, r24
   10862:	05 90       	lpm	r0, Z+
   10864:	0d 92       	st	X+, r0
   10866:	00 20       	and	r0, r0
   10868:	e1 f7       	brne	.-8      	; 0x10862 <strcpy_P+0x4>
   1086a:	08 95       	ret

0001086c <strlen_P>:
   1086c:	fc 01       	movw	r30, r24
   1086e:	05 90       	lpm	r0, Z+
   10870:	00 20       	and	r0, r0
   10872:	e9 f7       	brne	.-6      	; 0x1086e <strlen_P+0x2>
   10874:	80 95       	com	r24
   10876:	90 95       	com	r25
   10878:	8e 0f       	add	r24, r30
   1087a:	9f 1f       	adc	r25, r31
   1087c:	08 95       	ret

0001087e <strncmp_P>:
   1087e:	fb 01       	movw	r30, r22
   10880:	dc 01       	movw	r26, r24
   10882:	41 50       	subi	r20, 0x01	; 1
   10884:	50 40       	sbci	r21, 0x00	; 0
   10886:	30 f0       	brcs	.+12     	; 0x10894 <strncmp_P+0x16>
   10888:	8d 91       	ld	r24, X+
   1088a:	05 90       	lpm	r0, Z+
   1088c:	80 19       	sub	r24, r0
   1088e:	19 f4       	brne	.+6      	; 0x10896 <strncmp_P+0x18>
   10890:	00 20       	and	r0, r0
   10892:	b9 f7       	brne	.-18     	; 0x10882 <strncmp_P+0x4>
   10894:	88 1b       	sub	r24, r24
   10896:	99 0b       	sbc	r25, r25
   10898:	08 95       	ret

0001089a <strnlen_P>:
   1089a:	fc 01       	movw	r30, r24
   1089c:	05 90       	lpm	r0, Z+
   1089e:	61 50       	subi	r22, 0x01	; 1
   108a0:	70 40       	sbci	r23, 0x00	; 0
   108a2:	01 10       	cpse	r0, r1
   108a4:	d8 f7       	brcc	.-10     	; 0x1089c <strnlen_P+0x2>
   108a6:	80 95       	com	r24
   108a8:	90 95       	com	r25
   108aa:	8e 0f       	add	r24, r30
   108ac:	9f 1f       	adc	r25, r31
   108ae:	08 95       	ret

000108b0 <strstr_P>:
   108b0:	fb 01       	movw	r30, r22
   108b2:	55 91       	lpm	r21, Z+
   108b4:	55 23       	and	r21, r21
   108b6:	a9 f0       	breq	.+42     	; 0x108e2 <strstr_P+0x32>
   108b8:	bf 01       	movw	r22, r30
   108ba:	dc 01       	movw	r26, r24
   108bc:	4d 91       	ld	r20, X+
   108be:	45 17       	cp	r20, r21
   108c0:	41 11       	cpse	r20, r1
   108c2:	e1 f7       	brne	.-8      	; 0x108bc <strstr_P+0xc>
   108c4:	59 f4       	brne	.+22     	; 0x108dc <strstr_P+0x2c>
   108c6:	cd 01       	movw	r24, r26
   108c8:	05 90       	lpm	r0, Z+
   108ca:	00 20       	and	r0, r0
   108cc:	49 f0       	breq	.+18     	; 0x108e0 <strstr_P+0x30>
   108ce:	4d 91       	ld	r20, X+
   108d0:	40 15       	cp	r20, r0
   108d2:	41 11       	cpse	r20, r1
   108d4:	c9 f3       	breq	.-14     	; 0x108c8 <strstr_P+0x18>
   108d6:	fb 01       	movw	r30, r22
   108d8:	41 11       	cpse	r20, r1
   108da:	ef cf       	rjmp	.-34     	; 0x108ba <strstr_P+0xa>
   108dc:	81 e0       	ldi	r24, 0x01	; 1
   108de:	90 e0       	ldi	r25, 0x00	; 0
   108e0:	01 97       	sbiw	r24, 0x01	; 1
   108e2:	08 95       	ret

000108e4 <memcpy>:
   108e4:	fb 01       	movw	r30, r22
   108e6:	dc 01       	movw	r26, r24
   108e8:	02 c0       	rjmp	.+4      	; 0x108ee <memcpy+0xa>
   108ea:	01 90       	ld	r0, Z+
   108ec:	0d 92       	st	X+, r0
   108ee:	41 50       	subi	r20, 0x01	; 1
   108f0:	50 40       	sbci	r21, 0x00	; 0
   108f2:	d8 f7       	brcc	.-10     	; 0x108ea <memcpy+0x6>
   108f4:	08 95       	ret

000108f6 <strchr>:
   108f6:	fc 01       	movw	r30, r24
   108f8:	81 91       	ld	r24, Z+
   108fa:	86 17       	cp	r24, r22
   108fc:	21 f0       	breq	.+8      	; 0x10906 <strchr+0x10>
   108fe:	88 23       	and	r24, r24
   10900:	d9 f7       	brne	.-10     	; 0x108f8 <strchr+0x2>
   10902:	99 27       	eor	r25, r25
   10904:	08 95       	ret
   10906:	31 97       	sbiw	r30, 0x01	; 1
   10908:	cf 01       	movw	r24, r30
   1090a:	08 95       	ret

0001090c <strcmp>:
   1090c:	fb 01       	movw	r30, r22
   1090e:	dc 01       	movw	r26, r24
   10910:	8d 91       	ld	r24, X+
   10912:	01 90       	ld	r0, Z+
   10914:	80 19       	sub	r24, r0
   10916:	01 10       	cpse	r0, r1
   10918:	d9 f3       	breq	.-10     	; 0x10910 <strcmp+0x4>
   1091a:	99 0b       	sbc	r25, r25
   1091c:	08 95       	ret

0001091e <strnlen>:
   1091e:	fc 01       	movw	r30, r24
   10920:	61 50       	subi	r22, 0x01	; 1
   10922:	70 40       	sbci	r23, 0x00	; 0
   10924:	01 90       	ld	r0, Z+
   10926:	01 10       	cpse	r0, r1
   10928:	d8 f7       	brcc	.-10     	; 0x10920 <strnlen+0x2>
   1092a:	80 95       	com	r24
   1092c:	90 95       	com	r25
   1092e:	8e 0f       	add	r24, r30
   10930:	9f 1f       	adc	r25, r31
   10932:	08 95       	ret

00010934 <strstr>:
   10934:	fb 01       	movw	r30, r22
   10936:	51 91       	ld	r21, Z+
   10938:	55 23       	and	r21, r21
   1093a:	a9 f0       	breq	.+42     	; 0x10966 <strstr+0x32>
   1093c:	bf 01       	movw	r22, r30
   1093e:	dc 01       	movw	r26, r24
   10940:	4d 91       	ld	r20, X+
   10942:	45 17       	cp	r20, r21
   10944:	41 11       	cpse	r20, r1
   10946:	e1 f7       	brne	.-8      	; 0x10940 <strstr+0xc>
   10948:	59 f4       	brne	.+22     	; 0x10960 <strstr+0x2c>
   1094a:	cd 01       	movw	r24, r26
   1094c:	01 90       	ld	r0, Z+
   1094e:	00 20       	and	r0, r0
   10950:	49 f0       	breq	.+18     	; 0x10964 <strstr+0x30>
   10952:	4d 91       	ld	r20, X+
   10954:	40 15       	cp	r20, r0
   10956:	41 11       	cpse	r20, r1
   10958:	c9 f3       	breq	.-14     	; 0x1094c <strstr+0x18>
   1095a:	fb 01       	movw	r30, r22
   1095c:	41 11       	cpse	r20, r1
   1095e:	ef cf       	rjmp	.-34     	; 0x1093e <strstr+0xa>
   10960:	81 e0       	ldi	r24, 0x01	; 1
   10962:	90 e0       	ldi	r25, 0x00	; 0
   10964:	01 97       	sbiw	r24, 0x01	; 1
   10966:	08 95       	ret

00010968 <fgetc>:
   10968:	cf 93       	push	r28
   1096a:	df 93       	push	r29
   1096c:	ec 01       	movw	r28, r24
   1096e:	4b 81       	ldd	r20, Y+3	; 0x03
   10970:	40 ff       	sbrs	r20, 0
   10972:	1a c0       	rjmp	.+52     	; 0x109a8 <fgetc+0x40>
   10974:	46 ff       	sbrs	r20, 6
   10976:	0a c0       	rjmp	.+20     	; 0x1098c <fgetc+0x24>
   10978:	4f 7b       	andi	r20, 0xBF	; 191
   1097a:	4b 83       	std	Y+3, r20	; 0x03
   1097c:	8e 81       	ldd	r24, Y+6	; 0x06
   1097e:	9f 81       	ldd	r25, Y+7	; 0x07
   10980:	01 96       	adiw	r24, 0x01	; 1
   10982:	9f 83       	std	Y+7, r25	; 0x07
   10984:	8e 83       	std	Y+6, r24	; 0x06
   10986:	8a 81       	ldd	r24, Y+2	; 0x02
   10988:	28 2f       	mov	r18, r24
   1098a:	2b c0       	rjmp	.+86     	; 0x109e2 <fgetc+0x7a>
   1098c:	42 ff       	sbrs	r20, 2
   1098e:	13 c0       	rjmp	.+38     	; 0x109b6 <fgetc+0x4e>
   10990:	e8 81       	ld	r30, Y
   10992:	f9 81       	ldd	r31, Y+1	; 0x01
   10994:	80 81       	ld	r24, Z
   10996:	28 2f       	mov	r18, r24
   10998:	33 27       	eor	r19, r19
   1099a:	27 fd       	sbrc	r18, 7
   1099c:	30 95       	com	r19
   1099e:	21 15       	cp	r18, r1
   109a0:	31 05       	cpc	r19, r1
   109a2:	29 f4       	brne	.+10     	; 0x109ae <fgetc+0x46>
   109a4:	40 62       	ori	r20, 0x20	; 32
   109a6:	4b 83       	std	Y+3, r20	; 0x03
   109a8:	2f ef       	ldi	r18, 0xFF	; 255
   109aa:	3f ef       	ldi	r19, 0xFF	; 255
   109ac:	1b c0       	rjmp	.+54     	; 0x109e4 <fgetc+0x7c>
   109ae:	31 96       	adiw	r30, 0x01	; 1
   109b0:	f9 83       	std	Y+1, r31	; 0x01
   109b2:	e8 83       	st	Y, r30
   109b4:	11 c0       	rjmp	.+34     	; 0x109d8 <fgetc+0x70>
   109b6:	ea 85       	ldd	r30, Y+10	; 0x0a
   109b8:	fb 85       	ldd	r31, Y+11	; 0x0b
   109ba:	ce 01       	movw	r24, r28
   109bc:	19 95       	eicall
   109be:	9c 01       	movw	r18, r24
   109c0:	97 ff       	sbrs	r25, 7
   109c2:	0a c0       	rjmp	.+20     	; 0x109d8 <fgetc+0x70>
   109c4:	9b 81       	ldd	r25, Y+3	; 0x03
   109c6:	2f 5f       	subi	r18, 0xFF	; 255
   109c8:	3f 4f       	sbci	r19, 0xFF	; 255
   109ca:	11 f0       	breq	.+4      	; 0x109d0 <fgetc+0x68>
   109cc:	80 e2       	ldi	r24, 0x20	; 32
   109ce:	01 c0       	rjmp	.+2      	; 0x109d2 <fgetc+0x6a>
   109d0:	80 e1       	ldi	r24, 0x10	; 16
   109d2:	89 2b       	or	r24, r25
   109d4:	8b 83       	std	Y+3, r24	; 0x03
   109d6:	e8 cf       	rjmp	.-48     	; 0x109a8 <fgetc+0x40>
   109d8:	8e 81       	ldd	r24, Y+6	; 0x06
   109da:	9f 81       	ldd	r25, Y+7	; 0x07
   109dc:	01 96       	adiw	r24, 0x01	; 1
   109de:	9f 83       	std	Y+7, r25	; 0x07
   109e0:	8e 83       	std	Y+6, r24	; 0x06
   109e2:	30 e0       	ldi	r19, 0x00	; 0
   109e4:	c9 01       	movw	r24, r18
   109e6:	df 91       	pop	r29
   109e8:	cf 91       	pop	r28
   109ea:	08 95       	ret

000109ec <fputc>:
   109ec:	0f 93       	push	r16
   109ee:	1f 93       	push	r17
   109f0:	cf 93       	push	r28
   109f2:	df 93       	push	r29
   109f4:	8c 01       	movw	r16, r24
   109f6:	eb 01       	movw	r28, r22
   109f8:	8b 81       	ldd	r24, Y+3	; 0x03
   109fa:	81 ff       	sbrs	r24, 1
   109fc:	1b c0       	rjmp	.+54     	; 0x10a34 <fputc+0x48>
   109fe:	82 ff       	sbrs	r24, 2
   10a00:	0d c0       	rjmp	.+26     	; 0x10a1c <fputc+0x30>
   10a02:	2e 81       	ldd	r18, Y+6	; 0x06
   10a04:	3f 81       	ldd	r19, Y+7	; 0x07
   10a06:	8c 81       	ldd	r24, Y+4	; 0x04
   10a08:	9d 81       	ldd	r25, Y+5	; 0x05
   10a0a:	28 17       	cp	r18, r24
   10a0c:	39 07       	cpc	r19, r25
   10a0e:	64 f4       	brge	.+24     	; 0x10a28 <fputc+0x3c>
   10a10:	e8 81       	ld	r30, Y
   10a12:	f9 81       	ldd	r31, Y+1	; 0x01
   10a14:	01 93       	st	Z+, r16
   10a16:	f9 83       	std	Y+1, r31	; 0x01
   10a18:	e8 83       	st	Y, r30
   10a1a:	06 c0       	rjmp	.+12     	; 0x10a28 <fputc+0x3c>
   10a1c:	e8 85       	ldd	r30, Y+8	; 0x08
   10a1e:	f9 85       	ldd	r31, Y+9	; 0x09
   10a20:	80 2f       	mov	r24, r16
   10a22:	19 95       	eicall
   10a24:	89 2b       	or	r24, r25
   10a26:	31 f4       	brne	.+12     	; 0x10a34 <fputc+0x48>
   10a28:	8e 81       	ldd	r24, Y+6	; 0x06
   10a2a:	9f 81       	ldd	r25, Y+7	; 0x07
   10a2c:	01 96       	adiw	r24, 0x01	; 1
   10a2e:	9f 83       	std	Y+7, r25	; 0x07
   10a30:	8e 83       	std	Y+6, r24	; 0x06
   10a32:	02 c0       	rjmp	.+4      	; 0x10a38 <fputc+0x4c>
   10a34:	0f ef       	ldi	r16, 0xFF	; 255
   10a36:	1f ef       	ldi	r17, 0xFF	; 255
   10a38:	c8 01       	movw	r24, r16
   10a3a:	df 91       	pop	r29
   10a3c:	cf 91       	pop	r28
   10a3e:	1f 91       	pop	r17
   10a40:	0f 91       	pop	r16
   10a42:	08 95       	ret

00010a44 <sprintf>:
   10a44:	0f 93       	push	r16
   10a46:	1f 93       	push	r17
   10a48:	df 93       	push	r29
   10a4a:	cf 93       	push	r28
   10a4c:	cd b7       	in	r28, 0x3d	; 61
   10a4e:	de b7       	in	r29, 0x3e	; 62
   10a50:	2e 97       	sbiw	r28, 0x0e	; 14
   10a52:	0f b6       	in	r0, 0x3f	; 63
   10a54:	f8 94       	cli
   10a56:	de bf       	out	0x3e, r29	; 62
   10a58:	0f be       	out	0x3f, r0	; 63
   10a5a:	cd bf       	out	0x3d, r28	; 61
   10a5c:	0e 89       	ldd	r16, Y+22	; 0x16
   10a5e:	1f 89       	ldd	r17, Y+23	; 0x17
   10a60:	86 e0       	ldi	r24, 0x06	; 6
   10a62:	8c 83       	std	Y+4, r24	; 0x04
   10a64:	1a 83       	std	Y+2, r17	; 0x02
   10a66:	09 83       	std	Y+1, r16	; 0x01
   10a68:	8f ef       	ldi	r24, 0xFF	; 255
   10a6a:	9f e7       	ldi	r25, 0x7F	; 127
   10a6c:	9e 83       	std	Y+6, r25	; 0x06
   10a6e:	8d 83       	std	Y+5, r24	; 0x05
   10a70:	9e 01       	movw	r18, r28
   10a72:	26 5e       	subi	r18, 0xE6	; 230
   10a74:	3f 4f       	sbci	r19, 0xFF	; 255
   10a76:	ce 01       	movw	r24, r28
   10a78:	01 96       	adiw	r24, 0x01	; 1
   10a7a:	68 8d       	ldd	r22, Y+24	; 0x18
   10a7c:	79 8d       	ldd	r23, Y+25	; 0x19
   10a7e:	a9 01       	movw	r20, r18
   10a80:	0e 94 49 7a 	call	0xf492	; 0xf492 <vfprintf>
   10a84:	2f 81       	ldd	r18, Y+7	; 0x07
   10a86:	38 85       	ldd	r19, Y+8	; 0x08
   10a88:	02 0f       	add	r16, r18
   10a8a:	13 1f       	adc	r17, r19
   10a8c:	f8 01       	movw	r30, r16
   10a8e:	10 82       	st	Z, r1
   10a90:	2e 96       	adiw	r28, 0x0e	; 14
   10a92:	0f b6       	in	r0, 0x3f	; 63
   10a94:	f8 94       	cli
   10a96:	de bf       	out	0x3e, r29	; 62
   10a98:	0f be       	out	0x3f, r0	; 63
   10a9a:	cd bf       	out	0x3d, r28	; 61
   10a9c:	cf 91       	pop	r28
   10a9e:	df 91       	pop	r29
   10aa0:	1f 91       	pop	r17
   10aa2:	0f 91       	pop	r16
   10aa4:	08 95       	ret

00010aa6 <sprintf_P>:
   10aa6:	0f 93       	push	r16
   10aa8:	1f 93       	push	r17
   10aaa:	df 93       	push	r29
   10aac:	cf 93       	push	r28
   10aae:	cd b7       	in	r28, 0x3d	; 61
   10ab0:	de b7       	in	r29, 0x3e	; 62
   10ab2:	2e 97       	sbiw	r28, 0x0e	; 14
   10ab4:	0f b6       	in	r0, 0x3f	; 63
   10ab6:	f8 94       	cli
   10ab8:	de bf       	out	0x3e, r29	; 62
   10aba:	0f be       	out	0x3f, r0	; 63
   10abc:	cd bf       	out	0x3d, r28	; 61
   10abe:	0e 89       	ldd	r16, Y+22	; 0x16
   10ac0:	1f 89       	ldd	r17, Y+23	; 0x17
   10ac2:	8e e0       	ldi	r24, 0x0E	; 14
   10ac4:	8c 83       	std	Y+4, r24	; 0x04
   10ac6:	1a 83       	std	Y+2, r17	; 0x02
   10ac8:	09 83       	std	Y+1, r16	; 0x01
   10aca:	8f ef       	ldi	r24, 0xFF	; 255
   10acc:	9f e7       	ldi	r25, 0x7F	; 127
   10ace:	9e 83       	std	Y+6, r25	; 0x06
   10ad0:	8d 83       	std	Y+5, r24	; 0x05
   10ad2:	9e 01       	movw	r18, r28
   10ad4:	26 5e       	subi	r18, 0xE6	; 230
   10ad6:	3f 4f       	sbci	r19, 0xFF	; 255
   10ad8:	ce 01       	movw	r24, r28
   10ada:	01 96       	adiw	r24, 0x01	; 1
   10adc:	68 8d       	ldd	r22, Y+24	; 0x18
   10ade:	79 8d       	ldd	r23, Y+25	; 0x19
   10ae0:	a9 01       	movw	r20, r18
   10ae2:	0e 94 49 7a 	call	0xf492	; 0xf492 <vfprintf>
   10ae6:	2f 81       	ldd	r18, Y+7	; 0x07
   10ae8:	38 85       	ldd	r19, Y+8	; 0x08
   10aea:	02 0f       	add	r16, r18
   10aec:	13 1f       	adc	r17, r19
   10aee:	f8 01       	movw	r30, r16
   10af0:	10 82       	st	Z, r1
   10af2:	2e 96       	adiw	r28, 0x0e	; 14
   10af4:	0f b6       	in	r0, 0x3f	; 63
   10af6:	f8 94       	cli
   10af8:	de bf       	out	0x3e, r29	; 62
   10afa:	0f be       	out	0x3f, r0	; 63
   10afc:	cd bf       	out	0x3d, r28	; 61
   10afe:	cf 91       	pop	r28
   10b00:	df 91       	pop	r29
   10b02:	1f 91       	pop	r17
   10b04:	0f 91       	pop	r16
   10b06:	08 95       	ret

00010b08 <sscanf>:
   10b08:	df 93       	push	r29
   10b0a:	cf 93       	push	r28
   10b0c:	cd b7       	in	r28, 0x3d	; 61
   10b0e:	de b7       	in	r29, 0x3e	; 62
   10b10:	2e 97       	sbiw	r28, 0x0e	; 14
   10b12:	0f b6       	in	r0, 0x3f	; 63
   10b14:	f8 94       	cli
   10b16:	de bf       	out	0x3e, r29	; 62
   10b18:	0f be       	out	0x3f, r0	; 63
   10b1a:	cd bf       	out	0x3d, r28	; 61
   10b1c:	85 e0       	ldi	r24, 0x05	; 5
   10b1e:	8c 83       	std	Y+4, r24	; 0x04
   10b20:	8c 89       	ldd	r24, Y+20	; 0x14
   10b22:	9d 89       	ldd	r25, Y+21	; 0x15
   10b24:	9a 83       	std	Y+2, r25	; 0x02
   10b26:	89 83       	std	Y+1, r24	; 0x01
   10b28:	9e 01       	movw	r18, r28
   10b2a:	28 5e       	subi	r18, 0xE8	; 232
   10b2c:	3f 4f       	sbci	r19, 0xFF	; 255
   10b2e:	ce 01       	movw	r24, r28
   10b30:	01 96       	adiw	r24, 0x01	; 1
   10b32:	6e 89       	ldd	r22, Y+22	; 0x16
   10b34:	7f 89       	ldd	r23, Y+23	; 0x17
   10b36:	a9 01       	movw	r20, r18
   10b38:	0e 94 00 81 	call	0x10200	; 0x10200 <vfscanf>
   10b3c:	2e 96       	adiw	r28, 0x0e	; 14
   10b3e:	0f b6       	in	r0, 0x3f	; 63
   10b40:	f8 94       	cli
   10b42:	de bf       	out	0x3e, r29	; 62
   10b44:	0f be       	out	0x3f, r0	; 63
   10b46:	cd bf       	out	0x3d, r28	; 61
   10b48:	cf 91       	pop	r28
   10b4a:	df 91       	pop	r29
   10b4c:	08 95       	ret

00010b4e <sscanf_P>:
   10b4e:	df 93       	push	r29
   10b50:	cf 93       	push	r28
   10b52:	cd b7       	in	r28, 0x3d	; 61
   10b54:	de b7       	in	r29, 0x3e	; 62
   10b56:	2e 97       	sbiw	r28, 0x0e	; 14
   10b58:	0f b6       	in	r0, 0x3f	; 63
   10b5a:	f8 94       	cli
   10b5c:	de bf       	out	0x3e, r29	; 62
   10b5e:	0f be       	out	0x3f, r0	; 63
   10b60:	cd bf       	out	0x3d, r28	; 61
   10b62:	8d e0       	ldi	r24, 0x0D	; 13
   10b64:	8c 83       	std	Y+4, r24	; 0x04
   10b66:	8c 89       	ldd	r24, Y+20	; 0x14
   10b68:	9d 89       	ldd	r25, Y+21	; 0x15
   10b6a:	9a 83       	std	Y+2, r25	; 0x02
   10b6c:	89 83       	std	Y+1, r24	; 0x01
   10b6e:	9e 01       	movw	r18, r28
   10b70:	28 5e       	subi	r18, 0xE8	; 232
   10b72:	3f 4f       	sbci	r19, 0xFF	; 255
   10b74:	ce 01       	movw	r24, r28
   10b76:	01 96       	adiw	r24, 0x01	; 1
   10b78:	6e 89       	ldd	r22, Y+22	; 0x16
   10b7a:	7f 89       	ldd	r23, Y+23	; 0x17
   10b7c:	a9 01       	movw	r20, r18
   10b7e:	0e 94 00 81 	call	0x10200	; 0x10200 <vfscanf>
   10b82:	2e 96       	adiw	r28, 0x0e	; 14
   10b84:	0f b6       	in	r0, 0x3f	; 63
   10b86:	f8 94       	cli
   10b88:	de bf       	out	0x3e, r29	; 62
   10b8a:	0f be       	out	0x3f, r0	; 63
   10b8c:	cd bf       	out	0x3d, r28	; 61
   10b8e:	cf 91       	pop	r28
   10b90:	df 91       	pop	r29
   10b92:	08 95       	ret

00010b94 <ungetc>:
   10b94:	9c 01       	movw	r18, r24
   10b96:	fb 01       	movw	r30, r22
   10b98:	83 81       	ldd	r24, Z+3	; 0x03
   10b9a:	80 ff       	sbrs	r24, 0
   10b9c:	11 c0       	rjmp	.+34     	; 0x10bc0 <ungetc+0x2c>
   10b9e:	86 fd       	sbrc	r24, 6
   10ba0:	0f c0       	rjmp	.+30     	; 0x10bc0 <ungetc+0x2c>
   10ba2:	9f ef       	ldi	r25, 0xFF	; 255
   10ba4:	2f 3f       	cpi	r18, 0xFF	; 255
   10ba6:	39 07       	cpc	r19, r25
   10ba8:	59 f0       	breq	.+22     	; 0x10bc0 <ungetc+0x2c>
   10baa:	22 83       	std	Z+2, r18	; 0x02
   10bac:	80 64       	ori	r24, 0x40	; 64
   10bae:	8f 7d       	andi	r24, 0xDF	; 223
   10bb0:	83 83       	std	Z+3, r24	; 0x03
   10bb2:	86 81       	ldd	r24, Z+6	; 0x06
   10bb4:	97 81       	ldd	r25, Z+7	; 0x07
   10bb6:	01 97       	sbiw	r24, 0x01	; 1
   10bb8:	97 83       	std	Z+7, r25	; 0x07
   10bba:	86 83       	std	Z+6, r24	; 0x06
   10bbc:	30 e0       	ldi	r19, 0x00	; 0
   10bbe:	02 c0       	rjmp	.+4      	; 0x10bc4 <ungetc+0x30>
   10bc0:	2f ef       	ldi	r18, 0xFF	; 255
   10bc2:	3f ef       	ldi	r19, 0xFF	; 255
   10bc4:	c9 01       	movw	r24, r18
   10bc6:	08 95       	ret

00010bc8 <__ultoa_invert>:
   10bc8:	fa 01       	movw	r30, r20
   10bca:	aa 27       	eor	r26, r26
   10bcc:	28 30       	cpi	r18, 0x08	; 8
   10bce:	51 f1       	breq	.+84     	; 0x10c24 <__ultoa_invert+0x5c>
   10bd0:	20 31       	cpi	r18, 0x10	; 16
   10bd2:	81 f1       	breq	.+96     	; 0x10c34 <__ultoa_invert+0x6c>
   10bd4:	e8 94       	clt
   10bd6:	6f 93       	push	r22
   10bd8:	6e 7f       	andi	r22, 0xFE	; 254
   10bda:	6e 5f       	subi	r22, 0xFE	; 254
   10bdc:	7f 4f       	sbci	r23, 0xFF	; 255
   10bde:	8f 4f       	sbci	r24, 0xFF	; 255
   10be0:	9f 4f       	sbci	r25, 0xFF	; 255
   10be2:	af 4f       	sbci	r26, 0xFF	; 255
   10be4:	b1 e0       	ldi	r27, 0x01	; 1
   10be6:	3e d0       	rcall	.+124    	; 0x10c64 <__ultoa_invert+0x9c>
   10be8:	b4 e0       	ldi	r27, 0x04	; 4
   10bea:	3c d0       	rcall	.+120    	; 0x10c64 <__ultoa_invert+0x9c>
   10bec:	67 0f       	add	r22, r23
   10bee:	78 1f       	adc	r23, r24
   10bf0:	89 1f       	adc	r24, r25
   10bf2:	9a 1f       	adc	r25, r26
   10bf4:	a1 1d       	adc	r26, r1
   10bf6:	68 0f       	add	r22, r24
   10bf8:	79 1f       	adc	r23, r25
   10bfa:	8a 1f       	adc	r24, r26
   10bfc:	91 1d       	adc	r25, r1
   10bfe:	a1 1d       	adc	r26, r1
   10c00:	6a 0f       	add	r22, r26
   10c02:	71 1d       	adc	r23, r1
   10c04:	81 1d       	adc	r24, r1
   10c06:	91 1d       	adc	r25, r1
   10c08:	a1 1d       	adc	r26, r1
   10c0a:	20 d0       	rcall	.+64     	; 0x10c4c <__ultoa_invert+0x84>
   10c0c:	09 f4       	brne	.+2      	; 0x10c10 <__ultoa_invert+0x48>
   10c0e:	68 94       	set
   10c10:	3f 91       	pop	r19
   10c12:	2a e0       	ldi	r18, 0x0A	; 10
   10c14:	26 9f       	mul	r18, r22
   10c16:	11 24       	eor	r1, r1
   10c18:	30 19       	sub	r19, r0
   10c1a:	30 5d       	subi	r19, 0xD0	; 208
   10c1c:	31 93       	st	Z+, r19
   10c1e:	de f6       	brtc	.-74     	; 0x10bd6 <__ultoa_invert+0xe>
   10c20:	cf 01       	movw	r24, r30
   10c22:	08 95       	ret
   10c24:	46 2f       	mov	r20, r22
   10c26:	47 70       	andi	r20, 0x07	; 7
   10c28:	40 5d       	subi	r20, 0xD0	; 208
   10c2a:	41 93       	st	Z+, r20
   10c2c:	b3 e0       	ldi	r27, 0x03	; 3
   10c2e:	0f d0       	rcall	.+30     	; 0x10c4e <__ultoa_invert+0x86>
   10c30:	c9 f7       	brne	.-14     	; 0x10c24 <__ultoa_invert+0x5c>
   10c32:	f6 cf       	rjmp	.-20     	; 0x10c20 <__ultoa_invert+0x58>
   10c34:	46 2f       	mov	r20, r22
   10c36:	4f 70       	andi	r20, 0x0F	; 15
   10c38:	40 5d       	subi	r20, 0xD0	; 208
   10c3a:	4a 33       	cpi	r20, 0x3A	; 58
   10c3c:	18 f0       	brcs	.+6      	; 0x10c44 <__ultoa_invert+0x7c>
   10c3e:	49 5d       	subi	r20, 0xD9	; 217
   10c40:	31 fd       	sbrc	r19, 1
   10c42:	40 52       	subi	r20, 0x20	; 32
   10c44:	41 93       	st	Z+, r20
   10c46:	02 d0       	rcall	.+4      	; 0x10c4c <__ultoa_invert+0x84>
   10c48:	a9 f7       	brne	.-22     	; 0x10c34 <__ultoa_invert+0x6c>
   10c4a:	ea cf       	rjmp	.-44     	; 0x10c20 <__ultoa_invert+0x58>
   10c4c:	b4 e0       	ldi	r27, 0x04	; 4
   10c4e:	a6 95       	lsr	r26
   10c50:	97 95       	ror	r25
   10c52:	87 95       	ror	r24
   10c54:	77 95       	ror	r23
   10c56:	67 95       	ror	r22
   10c58:	ba 95       	dec	r27
   10c5a:	c9 f7       	brne	.-14     	; 0x10c4e <__ultoa_invert+0x86>
   10c5c:	00 97       	sbiw	r24, 0x00	; 0
   10c5e:	61 05       	cpc	r22, r1
   10c60:	71 05       	cpc	r23, r1
   10c62:	08 95       	ret
   10c64:	9b 01       	movw	r18, r22
   10c66:	ac 01       	movw	r20, r24
   10c68:	0a 2e       	mov	r0, r26
   10c6a:	06 94       	lsr	r0
   10c6c:	57 95       	ror	r21
   10c6e:	47 95       	ror	r20
   10c70:	37 95       	ror	r19
   10c72:	27 95       	ror	r18
   10c74:	ba 95       	dec	r27
   10c76:	c9 f7       	brne	.-14     	; 0x10c6a <__ultoa_invert+0xa2>
   10c78:	62 0f       	add	r22, r18
   10c7a:	73 1f       	adc	r23, r19
   10c7c:	84 1f       	adc	r24, r20
   10c7e:	95 1f       	adc	r25, r21
   10c80:	a0 1d       	adc	r26, r0
   10c82:	08 95       	ret

00010c84 <__subsf3>:
   10c84:	50 58       	subi	r21, 0x80	; 128

00010c86 <__addsf3>:
   10c86:	bb 27       	eor	r27, r27
   10c88:	aa 27       	eor	r26, r26
   10c8a:	0e d0       	rcall	.+28     	; 0x10ca8 <__addsf3x>
   10c8c:	af cc       	rjmp	.-1698   	; 0x105ec <__fp_round>
   10c8e:	a0 dc       	rcall	.-1728   	; 0x105d0 <__fp_pscA>
   10c90:	30 f0       	brcs	.+12     	; 0x10c9e <__addsf3+0x18>
   10c92:	a5 dc       	rcall	.-1718   	; 0x105de <__fp_pscB>
   10c94:	20 f0       	brcs	.+8      	; 0x10c9e <__addsf3+0x18>
   10c96:	31 f4       	brne	.+12     	; 0x10ca4 <__addsf3+0x1e>
   10c98:	9f 3f       	cpi	r25, 0xFF	; 255
   10c9a:	11 f4       	brne	.+4      	; 0x10ca0 <__addsf3+0x1a>
   10c9c:	1e f4       	brtc	.+6      	; 0x10ca4 <__addsf3+0x1e>
   10c9e:	95 cc       	rjmp	.-1750   	; 0x105ca <__fp_nan>
   10ca0:	0e f4       	brtc	.+2      	; 0x10ca4 <__addsf3+0x1e>
   10ca2:	e0 95       	com	r30
   10ca4:	e7 fb       	bst	r30, 7
   10ca6:	8b cc       	rjmp	.-1770   	; 0x105be <__fp_inf>

00010ca8 <__addsf3x>:
   10ca8:	e9 2f       	mov	r30, r25
   10caa:	b1 dc       	rcall	.-1694   	; 0x1060e <__fp_split3>
   10cac:	80 f3       	brcs	.-32     	; 0x10c8e <__addsf3+0x8>
   10cae:	ba 17       	cp	r27, r26
   10cb0:	62 07       	cpc	r22, r18
   10cb2:	73 07       	cpc	r23, r19
   10cb4:	84 07       	cpc	r24, r20
   10cb6:	95 07       	cpc	r25, r21
   10cb8:	18 f0       	brcs	.+6      	; 0x10cc0 <__addsf3x+0x18>
   10cba:	71 f4       	brne	.+28     	; 0x10cd8 <__addsf3x+0x30>
   10cbc:	9e f5       	brtc	.+102    	; 0x10d24 <__addsf3x+0x7c>
   10cbe:	c9 cc       	rjmp	.-1646   	; 0x10652 <__fp_zero>
   10cc0:	0e f4       	brtc	.+2      	; 0x10cc4 <__addsf3x+0x1c>
   10cc2:	e0 95       	com	r30
   10cc4:	0b 2e       	mov	r0, r27
   10cc6:	ba 2f       	mov	r27, r26
   10cc8:	a0 2d       	mov	r26, r0
   10cca:	0b 01       	movw	r0, r22
   10ccc:	b9 01       	movw	r22, r18
   10cce:	90 01       	movw	r18, r0
   10cd0:	0c 01       	movw	r0, r24
   10cd2:	ca 01       	movw	r24, r20
   10cd4:	a0 01       	movw	r20, r0
   10cd6:	11 24       	eor	r1, r1
   10cd8:	ff 27       	eor	r31, r31
   10cda:	59 1b       	sub	r21, r25
   10cdc:	99 f0       	breq	.+38     	; 0x10d04 <__addsf3x+0x5c>
   10cde:	59 3f       	cpi	r21, 0xF9	; 249
   10ce0:	50 f4       	brcc	.+20     	; 0x10cf6 <__addsf3x+0x4e>
   10ce2:	50 3e       	cpi	r21, 0xE0	; 224
   10ce4:	68 f1       	brcs	.+90     	; 0x10d40 <__addsf3x+0x98>
   10ce6:	1a 16       	cp	r1, r26
   10ce8:	f0 40       	sbci	r31, 0x00	; 0
   10cea:	a2 2f       	mov	r26, r18
   10cec:	23 2f       	mov	r18, r19
   10cee:	34 2f       	mov	r19, r20
   10cf0:	44 27       	eor	r20, r20
   10cf2:	58 5f       	subi	r21, 0xF8	; 248
   10cf4:	f3 cf       	rjmp	.-26     	; 0x10cdc <__addsf3x+0x34>
   10cf6:	46 95       	lsr	r20
   10cf8:	37 95       	ror	r19
   10cfa:	27 95       	ror	r18
   10cfc:	a7 95       	ror	r26
   10cfe:	f0 40       	sbci	r31, 0x00	; 0
   10d00:	53 95       	inc	r21
   10d02:	c9 f7       	brne	.-14     	; 0x10cf6 <__addsf3x+0x4e>
   10d04:	7e f4       	brtc	.+30     	; 0x10d24 <__addsf3x+0x7c>
   10d06:	1f 16       	cp	r1, r31
   10d08:	ba 0b       	sbc	r27, r26
   10d0a:	62 0b       	sbc	r22, r18
   10d0c:	73 0b       	sbc	r23, r19
   10d0e:	84 0b       	sbc	r24, r20
   10d10:	ba f0       	brmi	.+46     	; 0x10d40 <__addsf3x+0x98>
   10d12:	91 50       	subi	r25, 0x01	; 1
   10d14:	a1 f0       	breq	.+40     	; 0x10d3e <__addsf3x+0x96>
   10d16:	ff 0f       	add	r31, r31
   10d18:	bb 1f       	adc	r27, r27
   10d1a:	66 1f       	adc	r22, r22
   10d1c:	77 1f       	adc	r23, r23
   10d1e:	88 1f       	adc	r24, r24
   10d20:	c2 f7       	brpl	.-16     	; 0x10d12 <__addsf3x+0x6a>
   10d22:	0e c0       	rjmp	.+28     	; 0x10d40 <__addsf3x+0x98>
   10d24:	ba 0f       	add	r27, r26
   10d26:	62 1f       	adc	r22, r18
   10d28:	73 1f       	adc	r23, r19
   10d2a:	84 1f       	adc	r24, r20
   10d2c:	48 f4       	brcc	.+18     	; 0x10d40 <__addsf3x+0x98>
   10d2e:	87 95       	ror	r24
   10d30:	77 95       	ror	r23
   10d32:	67 95       	ror	r22
   10d34:	b7 95       	ror	r27
   10d36:	f7 95       	ror	r31
   10d38:	9e 3f       	cpi	r25, 0xFE	; 254
   10d3a:	08 f0       	brcs	.+2      	; 0x10d3e <__addsf3x+0x96>
   10d3c:	b3 cf       	rjmp	.-154    	; 0x10ca4 <__addsf3+0x1e>
   10d3e:	93 95       	inc	r25
   10d40:	88 0f       	add	r24, r24
   10d42:	08 f0       	brcs	.+2      	; 0x10d46 <__addsf3x+0x9e>
   10d44:	99 27       	eor	r25, r25
   10d46:	ee 0f       	add	r30, r30
   10d48:	97 95       	ror	r25
   10d4a:	87 95       	ror	r24
   10d4c:	08 95       	ret

00010d4e <__divsf3>:
   10d4e:	0c d0       	rcall	.+24     	; 0x10d68 <__divsf3x>
   10d50:	4d cc       	rjmp	.-1894   	; 0x105ec <__fp_round>
   10d52:	45 dc       	rcall	.-1910   	; 0x105de <__fp_pscB>
   10d54:	40 f0       	brcs	.+16     	; 0x10d66 <__divsf3+0x18>
   10d56:	3c dc       	rcall	.-1928   	; 0x105d0 <__fp_pscA>
   10d58:	30 f0       	brcs	.+12     	; 0x10d66 <__divsf3+0x18>
   10d5a:	21 f4       	brne	.+8      	; 0x10d64 <__divsf3+0x16>
   10d5c:	5f 3f       	cpi	r21, 0xFF	; 255
   10d5e:	19 f0       	breq	.+6      	; 0x10d66 <__divsf3+0x18>
   10d60:	2e cc       	rjmp	.-1956   	; 0x105be <__fp_inf>
   10d62:	51 11       	cpse	r21, r1
   10d64:	77 cc       	rjmp	.-1810   	; 0x10654 <__fp_szero>
   10d66:	31 cc       	rjmp	.-1950   	; 0x105ca <__fp_nan>

00010d68 <__divsf3x>:
   10d68:	52 dc       	rcall	.-1884   	; 0x1060e <__fp_split3>
   10d6a:	98 f3       	brcs	.-26     	; 0x10d52 <__divsf3+0x4>

00010d6c <__divsf3_pse>:
   10d6c:	99 23       	and	r25, r25
   10d6e:	c9 f3       	breq	.-14     	; 0x10d62 <__divsf3+0x14>
   10d70:	55 23       	and	r21, r21
   10d72:	b1 f3       	breq	.-20     	; 0x10d60 <__divsf3+0x12>
   10d74:	95 1b       	sub	r25, r21
   10d76:	55 0b       	sbc	r21, r21
   10d78:	bb 27       	eor	r27, r27
   10d7a:	aa 27       	eor	r26, r26
   10d7c:	62 17       	cp	r22, r18
   10d7e:	73 07       	cpc	r23, r19
   10d80:	84 07       	cpc	r24, r20
   10d82:	38 f0       	brcs	.+14     	; 0x10d92 <__divsf3_pse+0x26>
   10d84:	9f 5f       	subi	r25, 0xFF	; 255
   10d86:	5f 4f       	sbci	r21, 0xFF	; 255
   10d88:	22 0f       	add	r18, r18
   10d8a:	33 1f       	adc	r19, r19
   10d8c:	44 1f       	adc	r20, r20
   10d8e:	aa 1f       	adc	r26, r26
   10d90:	a9 f3       	breq	.-22     	; 0x10d7c <__divsf3_pse+0x10>
   10d92:	33 d0       	rcall	.+102    	; 0x10dfa <__divsf3_pse+0x8e>
   10d94:	0e 2e       	mov	r0, r30
   10d96:	3a f0       	brmi	.+14     	; 0x10da6 <__divsf3_pse+0x3a>
   10d98:	e0 e8       	ldi	r30, 0x80	; 128
   10d9a:	30 d0       	rcall	.+96     	; 0x10dfc <__divsf3_pse+0x90>
   10d9c:	91 50       	subi	r25, 0x01	; 1
   10d9e:	50 40       	sbci	r21, 0x00	; 0
   10da0:	e6 95       	lsr	r30
   10da2:	00 1c       	adc	r0, r0
   10da4:	ca f7       	brpl	.-14     	; 0x10d98 <__divsf3_pse+0x2c>
   10da6:	29 d0       	rcall	.+82     	; 0x10dfa <__divsf3_pse+0x8e>
   10da8:	fe 2f       	mov	r31, r30
   10daa:	27 d0       	rcall	.+78     	; 0x10dfa <__divsf3_pse+0x8e>
   10dac:	66 0f       	add	r22, r22
   10dae:	77 1f       	adc	r23, r23
   10db0:	88 1f       	adc	r24, r24
   10db2:	bb 1f       	adc	r27, r27
   10db4:	26 17       	cp	r18, r22
   10db6:	37 07       	cpc	r19, r23
   10db8:	48 07       	cpc	r20, r24
   10dba:	ab 07       	cpc	r26, r27
   10dbc:	b0 e8       	ldi	r27, 0x80	; 128
   10dbe:	09 f0       	breq	.+2      	; 0x10dc2 <__divsf3_pse+0x56>
   10dc0:	bb 0b       	sbc	r27, r27
   10dc2:	80 2d       	mov	r24, r0
   10dc4:	bf 01       	movw	r22, r30
   10dc6:	ff 27       	eor	r31, r31
   10dc8:	93 58       	subi	r25, 0x83	; 131
   10dca:	5f 4f       	sbci	r21, 0xFF	; 255
   10dcc:	2a f0       	brmi	.+10     	; 0x10dd8 <__divsf3_pse+0x6c>
   10dce:	9e 3f       	cpi	r25, 0xFE	; 254
   10dd0:	51 05       	cpc	r21, r1
   10dd2:	68 f0       	brcs	.+26     	; 0x10dee <__divsf3_pse+0x82>
   10dd4:	f4 cb       	rjmp	.-2072   	; 0x105be <__fp_inf>
   10dd6:	3e cc       	rjmp	.-1924   	; 0x10654 <__fp_szero>
   10dd8:	5f 3f       	cpi	r21, 0xFF	; 255
   10dda:	ec f3       	brlt	.-6      	; 0x10dd6 <__divsf3_pse+0x6a>
   10ddc:	98 3e       	cpi	r25, 0xE8	; 232
   10dde:	dc f3       	brlt	.-10     	; 0x10dd6 <__divsf3_pse+0x6a>
   10de0:	86 95       	lsr	r24
   10de2:	77 95       	ror	r23
   10de4:	67 95       	ror	r22
   10de6:	b7 95       	ror	r27
   10de8:	f7 95       	ror	r31
   10dea:	9f 5f       	subi	r25, 0xFF	; 255
   10dec:	c9 f7       	brne	.-14     	; 0x10de0 <__divsf3_pse+0x74>
   10dee:	88 0f       	add	r24, r24
   10df0:	91 1d       	adc	r25, r1
   10df2:	96 95       	lsr	r25
   10df4:	87 95       	ror	r24
   10df6:	97 f9       	bld	r25, 7
   10df8:	08 95       	ret
   10dfa:	e1 e0       	ldi	r30, 0x01	; 1
   10dfc:	66 0f       	add	r22, r22
   10dfe:	77 1f       	adc	r23, r23
   10e00:	88 1f       	adc	r24, r24
   10e02:	bb 1f       	adc	r27, r27
   10e04:	62 17       	cp	r22, r18
   10e06:	73 07       	cpc	r23, r19
   10e08:	84 07       	cpc	r24, r20
   10e0a:	ba 07       	cpc	r27, r26
   10e0c:	20 f0       	brcs	.+8      	; 0x10e16 <__divsf3_pse+0xaa>
   10e0e:	62 1b       	sub	r22, r18
   10e10:	73 0b       	sbc	r23, r19
   10e12:	84 0b       	sbc	r24, r20
   10e14:	ba 0b       	sbc	r27, r26
   10e16:	ee 1f       	adc	r30, r30
   10e18:	88 f7       	brcc	.-30     	; 0x10dfc <__divsf3_pse+0x90>
   10e1a:	e0 95       	com	r30
   10e1c:	08 95       	ret

00010e1e <__fixsfsi>:
   10e1e:	04 d0       	rcall	.+8      	; 0x10e28 <__fixunssfsi>
   10e20:	68 94       	set
   10e22:	b1 11       	cpse	r27, r1
   10e24:	17 cc       	rjmp	.-2002   	; 0x10654 <__fp_szero>
   10e26:	08 95       	ret

00010e28 <__fixunssfsi>:
   10e28:	fa db       	rcall	.-2060   	; 0x1061e <__fp_splitA>
   10e2a:	88 f0       	brcs	.+34     	; 0x10e4e <__fixunssfsi+0x26>
   10e2c:	9f 57       	subi	r25, 0x7F	; 127
   10e2e:	90 f0       	brcs	.+36     	; 0x10e54 <__fixunssfsi+0x2c>
   10e30:	b9 2f       	mov	r27, r25
   10e32:	99 27       	eor	r25, r25
   10e34:	b7 51       	subi	r27, 0x17	; 23
   10e36:	a0 f0       	brcs	.+40     	; 0x10e60 <__fixunssfsi+0x38>
   10e38:	d1 f0       	breq	.+52     	; 0x10e6e <__fixunssfsi+0x46>
   10e3a:	66 0f       	add	r22, r22
   10e3c:	77 1f       	adc	r23, r23
   10e3e:	88 1f       	adc	r24, r24
   10e40:	99 1f       	adc	r25, r25
   10e42:	1a f0       	brmi	.+6      	; 0x10e4a <__fixunssfsi+0x22>
   10e44:	ba 95       	dec	r27
   10e46:	c9 f7       	brne	.-14     	; 0x10e3a <__fixunssfsi+0x12>
   10e48:	12 c0       	rjmp	.+36     	; 0x10e6e <__fixunssfsi+0x46>
   10e4a:	b1 30       	cpi	r27, 0x01	; 1
   10e4c:	81 f0       	breq	.+32     	; 0x10e6e <__fixunssfsi+0x46>
   10e4e:	01 dc       	rcall	.-2046   	; 0x10652 <__fp_zero>
   10e50:	b1 e0       	ldi	r27, 0x01	; 1
   10e52:	08 95       	ret
   10e54:	fe cb       	rjmp	.-2052   	; 0x10652 <__fp_zero>
   10e56:	67 2f       	mov	r22, r23
   10e58:	78 2f       	mov	r23, r24
   10e5a:	88 27       	eor	r24, r24
   10e5c:	b8 5f       	subi	r27, 0xF8	; 248
   10e5e:	39 f0       	breq	.+14     	; 0x10e6e <__fixunssfsi+0x46>
   10e60:	b9 3f       	cpi	r27, 0xF9	; 249
   10e62:	cc f3       	brlt	.-14     	; 0x10e56 <__fixunssfsi+0x2e>
   10e64:	86 95       	lsr	r24
   10e66:	77 95       	ror	r23
   10e68:	67 95       	ror	r22
   10e6a:	b3 95       	inc	r27
   10e6c:	d9 f7       	brne	.-10     	; 0x10e64 <__fixunssfsi+0x3c>
   10e6e:	3e f4       	brtc	.+14     	; 0x10e7e <__fixunssfsi+0x56>
   10e70:	90 95       	com	r25
   10e72:	80 95       	com	r24
   10e74:	70 95       	com	r23
   10e76:	61 95       	neg	r22
   10e78:	7f 4f       	sbci	r23, 0xFF	; 255
   10e7a:	8f 4f       	sbci	r24, 0xFF	; 255
   10e7c:	9f 4f       	sbci	r25, 0xFF	; 255
   10e7e:	08 95       	ret

00010e80 <__eerd_block_m2560>:
   10e80:	dc 01       	movw	r26, r24
   10e82:	cb 01       	movw	r24, r22

00010e84 <__eerd_blraw_m2560>:
   10e84:	fc 01       	movw	r30, r24
   10e86:	f9 99       	sbic	0x1f, 1	; 31
   10e88:	fe cf       	rjmp	.-4      	; 0x10e86 <__eerd_blraw_m2560+0x2>
   10e8a:	06 c0       	rjmp	.+12     	; 0x10e98 <__eerd_blraw_m2560+0x14>
   10e8c:	f2 bd       	out	0x22, r31	; 34
   10e8e:	e1 bd       	out	0x21, r30	; 33
   10e90:	f8 9a       	sbi	0x1f, 0	; 31
   10e92:	31 96       	adiw	r30, 0x01	; 1
   10e94:	00 b4       	in	r0, 0x20	; 32
   10e96:	0d 92       	st	X+, r0
   10e98:	41 50       	subi	r20, 0x01	; 1
   10e9a:	50 40       	sbci	r21, 0x00	; 0
   10e9c:	b8 f7       	brcc	.-18     	; 0x10e8c <__eerd_blraw_m2560+0x8>
   10e9e:	08 95       	ret

00010ea0 <__eerd_byte_m2560>:
   10ea0:	f9 99       	sbic	0x1f, 1	; 31
   10ea2:	fe cf       	rjmp	.-4      	; 0x10ea0 <__eerd_byte_m2560>
   10ea4:	92 bd       	out	0x22, r25	; 34
   10ea6:	81 bd       	out	0x21, r24	; 33
   10ea8:	f8 9a       	sbi	0x1f, 0	; 31
   10eaa:	99 27       	eor	r25, r25
   10eac:	80 b5       	in	r24, 0x20	; 32
   10eae:	08 95       	ret

00010eb0 <__eerd_dword_m2560>:
   10eb0:	a6 e1       	ldi	r26, 0x16	; 22
   10eb2:	b0 e0       	ldi	r27, 0x00	; 0
   10eb4:	44 e0       	ldi	r20, 0x04	; 4
   10eb6:	50 e0       	ldi	r21, 0x00	; 0
   10eb8:	0c 94 42 87 	jmp	0x10e84	; 0x10e84 <__eerd_blraw_m2560>

00010ebc <__eerd_word_m2560>:
   10ebc:	a8 e1       	ldi	r26, 0x18	; 24
   10ebe:	b0 e0       	ldi	r27, 0x00	; 0
   10ec0:	42 e0       	ldi	r20, 0x02	; 2
   10ec2:	50 e0       	ldi	r21, 0x00	; 0
   10ec4:	0c 94 42 87 	jmp	0x10e84	; 0x10e84 <__eerd_blraw_m2560>

00010ec8 <__eewr_block_m2560>:
   10ec8:	dc 01       	movw	r26, r24
   10eca:	cb 01       	movw	r24, r22
   10ecc:	03 c0       	rjmp	.+6      	; 0x10ed4 <__eewr_block_m2560+0xc>
   10ece:	2d 91       	ld	r18, X+
   10ed0:	0e 94 6f 87 	call	0x10ede	; 0x10ede <__eewr_r18_m2560>
   10ed4:	41 50       	subi	r20, 0x01	; 1
   10ed6:	50 40       	sbci	r21, 0x00	; 0
   10ed8:	d0 f7       	brcc	.-12     	; 0x10ece <__eewr_block_m2560+0x6>
   10eda:	08 95       	ret

00010edc <__eewr_byte_m2560>:
   10edc:	26 2f       	mov	r18, r22

00010ede <__eewr_r18_m2560>:
   10ede:	f9 99       	sbic	0x1f, 1	; 31
   10ee0:	fe cf       	rjmp	.-4      	; 0x10ede <__eewr_r18_m2560>
   10ee2:	1f ba       	out	0x1f, r1	; 31
   10ee4:	92 bd       	out	0x22, r25	; 34
   10ee6:	81 bd       	out	0x21, r24	; 33
   10ee8:	20 bd       	out	0x20, r18	; 32
   10eea:	0f b6       	in	r0, 0x3f	; 63
   10eec:	f8 94       	cli
   10eee:	fa 9a       	sbi	0x1f, 2	; 31
   10ef0:	f9 9a       	sbi	0x1f, 1	; 31
   10ef2:	0f be       	out	0x3f, r0	; 63
   10ef4:	01 96       	adiw	r24, 0x01	; 1
   10ef6:	08 95       	ret

00010ef8 <__eewr_dword_m2560>:
   10ef8:	24 2f       	mov	r18, r20
   10efa:	0e 94 6f 87 	call	0x10ede	; 0x10ede <__eewr_r18_m2560>
   10efe:	25 2f       	mov	r18, r21
   10f00:	0e 94 6f 87 	call	0x10ede	; 0x10ede <__eewr_r18_m2560>
   10f04:	0c 94 84 87 	jmp	0x10f08	; 0x10f08 <__eewr_word_m2560>

00010f08 <__eewr_word_m2560>:
   10f08:	0e 94 6e 87 	call	0x10edc	; 0x10edc <__eewr_byte_m2560>
   10f0c:	27 2f       	mov	r18, r23
   10f0e:	0c 94 6f 87 	jmp	0x10ede	; 0x10ede <__eewr_r18_m2560>

00010f12 <__ctype_isfalse>:
   10f12:	99 27       	eor	r25, r25
   10f14:	88 27       	eor	r24, r24

00010f16 <__ctype_istrue>:
   10f16:	08 95       	ret

00010f18 <__mulsi3>:
   10f18:	62 9f       	mul	r22, r18
   10f1a:	d0 01       	movw	r26, r0
   10f1c:	73 9f       	mul	r23, r19
   10f1e:	f0 01       	movw	r30, r0
   10f20:	82 9f       	mul	r24, r18
   10f22:	e0 0d       	add	r30, r0
   10f24:	f1 1d       	adc	r31, r1
   10f26:	64 9f       	mul	r22, r20
   10f28:	e0 0d       	add	r30, r0
   10f2a:	f1 1d       	adc	r31, r1
   10f2c:	92 9f       	mul	r25, r18
   10f2e:	f0 0d       	add	r31, r0
   10f30:	83 9f       	mul	r24, r19
   10f32:	f0 0d       	add	r31, r0
   10f34:	74 9f       	mul	r23, r20
   10f36:	f0 0d       	add	r31, r0
   10f38:	65 9f       	mul	r22, r21
   10f3a:	f0 0d       	add	r31, r0
   10f3c:	99 27       	eor	r25, r25
   10f3e:	72 9f       	mul	r23, r18
   10f40:	b0 0d       	add	r27, r0
   10f42:	e1 1d       	adc	r30, r1
   10f44:	f9 1f       	adc	r31, r25
   10f46:	63 9f       	mul	r22, r19
   10f48:	b0 0d       	add	r27, r0
   10f4a:	e1 1d       	adc	r30, r1
   10f4c:	f9 1f       	adc	r31, r25
   10f4e:	bd 01       	movw	r22, r26
   10f50:	cf 01       	movw	r24, r30
   10f52:	11 24       	eor	r1, r1
   10f54:	08 95       	ret

00010f56 <__udivmodqi4>:
   10f56:	99 1b       	sub	r25, r25
   10f58:	79 e0       	ldi	r23, 0x09	; 9
   10f5a:	04 c0       	rjmp	.+8      	; 0x10f64 <__udivmodqi4_ep>

00010f5c <__udivmodqi4_loop>:
   10f5c:	99 1f       	adc	r25, r25
   10f5e:	96 17       	cp	r25, r22
   10f60:	08 f0       	brcs	.+2      	; 0x10f64 <__udivmodqi4_ep>
   10f62:	96 1b       	sub	r25, r22

00010f64 <__udivmodqi4_ep>:
   10f64:	88 1f       	adc	r24, r24
   10f66:	7a 95       	dec	r23
   10f68:	c9 f7       	brne	.-14     	; 0x10f5c <__udivmodqi4_loop>
   10f6a:	80 95       	com	r24
   10f6c:	08 95       	ret

00010f6e <__udivmodhi4>:
   10f6e:	aa 1b       	sub	r26, r26
   10f70:	bb 1b       	sub	r27, r27
   10f72:	51 e1       	ldi	r21, 0x11	; 17
   10f74:	07 c0       	rjmp	.+14     	; 0x10f84 <__udivmodhi4_ep>

00010f76 <__udivmodhi4_loop>:
   10f76:	aa 1f       	adc	r26, r26
   10f78:	bb 1f       	adc	r27, r27
   10f7a:	a6 17       	cp	r26, r22
   10f7c:	b7 07       	cpc	r27, r23
   10f7e:	10 f0       	brcs	.+4      	; 0x10f84 <__udivmodhi4_ep>
   10f80:	a6 1b       	sub	r26, r22
   10f82:	b7 0b       	sbc	r27, r23

00010f84 <__udivmodhi4_ep>:
   10f84:	88 1f       	adc	r24, r24
   10f86:	99 1f       	adc	r25, r25
   10f88:	5a 95       	dec	r21
   10f8a:	a9 f7       	brne	.-22     	; 0x10f76 <__udivmodhi4_loop>
   10f8c:	80 95       	com	r24
   10f8e:	90 95       	com	r25
   10f90:	bc 01       	movw	r22, r24
   10f92:	cd 01       	movw	r24, r26
   10f94:	08 95       	ret

00010f96 <__divmodhi4>:
   10f96:	97 fb       	bst	r25, 7
   10f98:	09 2e       	mov	r0, r25
   10f9a:	07 26       	eor	r0, r23
   10f9c:	0a d0       	rcall	.+20     	; 0x10fb2 <__divmodhi4_neg1>
   10f9e:	77 fd       	sbrc	r23, 7
   10fa0:	04 d0       	rcall	.+8      	; 0x10faa <__divmodhi4_neg2>
   10fa2:	e5 df       	rcall	.-54     	; 0x10f6e <__udivmodhi4>
   10fa4:	06 d0       	rcall	.+12     	; 0x10fb2 <__divmodhi4_neg1>
   10fa6:	00 20       	and	r0, r0
   10fa8:	1a f4       	brpl	.+6      	; 0x10fb0 <__divmodhi4_exit>

00010faa <__divmodhi4_neg2>:
   10faa:	70 95       	com	r23
   10fac:	61 95       	neg	r22
   10fae:	7f 4f       	sbci	r23, 0xFF	; 255

00010fb0 <__divmodhi4_exit>:
   10fb0:	08 95       	ret

00010fb2 <__divmodhi4_neg1>:
   10fb2:	f6 f7       	brtc	.-4      	; 0x10fb0 <__divmodhi4_exit>
   10fb4:	90 95       	com	r25
   10fb6:	81 95       	neg	r24
   10fb8:	9f 4f       	sbci	r25, 0xFF	; 255
   10fba:	08 95       	ret

00010fbc <__udivmodsi4>:
   10fbc:	a1 e2       	ldi	r26, 0x21	; 33
   10fbe:	1a 2e       	mov	r1, r26
   10fc0:	aa 1b       	sub	r26, r26
   10fc2:	bb 1b       	sub	r27, r27
   10fc4:	fd 01       	movw	r30, r26
   10fc6:	0d c0       	rjmp	.+26     	; 0x10fe2 <__udivmodsi4_ep>

00010fc8 <__udivmodsi4_loop>:
   10fc8:	aa 1f       	adc	r26, r26
   10fca:	bb 1f       	adc	r27, r27
   10fcc:	ee 1f       	adc	r30, r30
   10fce:	ff 1f       	adc	r31, r31
   10fd0:	a2 17       	cp	r26, r18
   10fd2:	b3 07       	cpc	r27, r19
   10fd4:	e4 07       	cpc	r30, r20
   10fd6:	f5 07       	cpc	r31, r21
   10fd8:	20 f0       	brcs	.+8      	; 0x10fe2 <__udivmodsi4_ep>
   10fda:	a2 1b       	sub	r26, r18
   10fdc:	b3 0b       	sbc	r27, r19
   10fde:	e4 0b       	sbc	r30, r20
   10fe0:	f5 0b       	sbc	r31, r21

00010fe2 <__udivmodsi4_ep>:
   10fe2:	66 1f       	adc	r22, r22
   10fe4:	77 1f       	adc	r23, r23
   10fe6:	88 1f       	adc	r24, r24
   10fe8:	99 1f       	adc	r25, r25
   10fea:	1a 94       	dec	r1
   10fec:	69 f7       	brne	.-38     	; 0x10fc8 <__udivmodsi4_loop>
   10fee:	60 95       	com	r22
   10ff0:	70 95       	com	r23
   10ff2:	80 95       	com	r24
   10ff4:	90 95       	com	r25
   10ff6:	9b 01       	movw	r18, r22
   10ff8:	ac 01       	movw	r20, r24
   10ffa:	bd 01       	movw	r22, r26
   10ffc:	cf 01       	movw	r24, r30
   10ffe:	08 95       	ret

00011000 <__divmodsi4>:
   11000:	97 fb       	bst	r25, 7
   11002:	09 2e       	mov	r0, r25
   11004:	05 26       	eor	r0, r21
   11006:	0e d0       	rcall	.+28     	; 0x11024 <__divmodsi4_neg1>
   11008:	57 fd       	sbrc	r21, 7
   1100a:	04 d0       	rcall	.+8      	; 0x11014 <__divmodsi4_neg2>
   1100c:	d7 df       	rcall	.-82     	; 0x10fbc <__udivmodsi4>
   1100e:	0a d0       	rcall	.+20     	; 0x11024 <__divmodsi4_neg1>
   11010:	00 1c       	adc	r0, r0
   11012:	38 f4       	brcc	.+14     	; 0x11022 <__divmodsi4_exit>

00011014 <__divmodsi4_neg2>:
   11014:	50 95       	com	r21
   11016:	40 95       	com	r20
   11018:	30 95       	com	r19
   1101a:	21 95       	neg	r18
   1101c:	3f 4f       	sbci	r19, 0xFF	; 255
   1101e:	4f 4f       	sbci	r20, 0xFF	; 255
   11020:	5f 4f       	sbci	r21, 0xFF	; 255

00011022 <__divmodsi4_exit>:
   11022:	08 95       	ret

00011024 <__divmodsi4_neg1>:
   11024:	f6 f7       	brtc	.-4      	; 0x11022 <__divmodsi4_exit>
   11026:	90 95       	com	r25
   11028:	80 95       	com	r24
   1102a:	70 95       	com	r23
   1102c:	61 95       	neg	r22
   1102e:	7f 4f       	sbci	r23, 0xFF	; 255
   11030:	8f 4f       	sbci	r24, 0xFF	; 255
   11032:	9f 4f       	sbci	r25, 0xFF	; 255
   11034:	08 95       	ret

00011036 <_exit>:
   11036:	f8 94       	cli

00011038 <__stop_program>:
   11038:	ff cf       	rjmp	.-2      	; 0x11038 <__stop_program>
