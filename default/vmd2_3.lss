
vmd2_3.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000da  00800200  00010768  0001081c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00010768  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000952  008002da  008002da  000108f6  2**0
                  ALLOC
  3 .eeprom       00000140  00810000  00810000  000108f6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .debug_aranges 00000020  00000000  00000000  00010a36  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 00002ec6  00000000  00000000  00010a56  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000f8b9  00000000  00000000  0001391c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000072a  00000000  00000000  000231d5  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00008c4f  00000000  00000000  000238ff  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000012b0  00000000  00000000  0002c550  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00003749  00000000  00000000  0002d800  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000084aa  00000000  00000000  00030f49  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00001128  00000000  00000000  000393f3  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 57 19 	jmp	0x32ae	; 0x32ae <__ctors_end>
       4:	0c 94 78 19 	jmp	0x32f0	; 0x32f0 <__bad_interrupt>
       8:	0c 94 78 19 	jmp	0x32f0	; 0x32f0 <__bad_interrupt>
       c:	0c 94 78 19 	jmp	0x32f0	; 0x32f0 <__bad_interrupt>
      10:	0c 94 78 19 	jmp	0x32f0	; 0x32f0 <__bad_interrupt>
      14:	0c 94 78 19 	jmp	0x32f0	; 0x32f0 <__bad_interrupt>
      18:	0c 94 78 19 	jmp	0x32f0	; 0x32f0 <__bad_interrupt>
      1c:	0c 94 78 19 	jmp	0x32f0	; 0x32f0 <__bad_interrupt>
      20:	0c 94 78 19 	jmp	0x32f0	; 0x32f0 <__bad_interrupt>
      24:	0c 94 78 19 	jmp	0x32f0	; 0x32f0 <__bad_interrupt>
      28:	0c 94 78 19 	jmp	0x32f0	; 0x32f0 <__bad_interrupt>
      2c:	0c 94 78 19 	jmp	0x32f0	; 0x32f0 <__bad_interrupt>
      30:	0c 94 78 19 	jmp	0x32f0	; 0x32f0 <__bad_interrupt>
      34:	0c 94 23 29 	jmp	0x5246	; 0x5246 <__vector_13>
      38:	0c 94 78 19 	jmp	0x32f0	; 0x32f0 <__bad_interrupt>
      3c:	0c 94 78 19 	jmp	0x32f0	; 0x32f0 <__bad_interrupt>
      40:	0c 94 78 19 	jmp	0x32f0	; 0x32f0 <__bad_interrupt>
      44:	0c 94 c7 1d 	jmp	0x3b8e	; 0x3b8e <__vector_17>
      48:	0c 94 f0 26 	jmp	0x4de0	; 0x4de0 <__vector_18>
      4c:	0c 94 78 19 	jmp	0x32f0	; 0x32f0 <__bad_interrupt>
      50:	0c 94 78 19 	jmp	0x32f0	; 0x32f0 <__bad_interrupt>
      54:	0c 94 f1 28 	jmp	0x51e2	; 0x51e2 <__vector_21>
      58:	0c 94 78 19 	jmp	0x32f0	; 0x32f0 <__bad_interrupt>
      5c:	0c 94 78 19 	jmp	0x32f0	; 0x32f0 <__bad_interrupt>
      60:	0c 94 78 19 	jmp	0x32f0	; 0x32f0 <__bad_interrupt>
      64:	0c 94 56 3a 	jmp	0x74ac	; 0x74ac <__vector_25>
      68:	0c 94 aa 3a 	jmp	0x7554	; 0x7554 <__vector_26>
      6c:	0c 94 80 3a 	jmp	0x7500	; 0x7500 <__vector_27>
      70:	0c 94 78 19 	jmp	0x32f0	; 0x32f0 <__bad_interrupt>
      74:	0c 94 78 19 	jmp	0x32f0	; 0x32f0 <__bad_interrupt>
      78:	0c 94 78 19 	jmp	0x32f0	; 0x32f0 <__bad_interrupt>
      7c:	0c 94 78 19 	jmp	0x32f0	; 0x32f0 <__bad_interrupt>
      80:	0c 94 78 19 	jmp	0x32f0	; 0x32f0 <__bad_interrupt>
      84:	0c 94 78 19 	jmp	0x32f0	; 0x32f0 <__bad_interrupt>
      88:	0c 94 78 19 	jmp	0x32f0	; 0x32f0 <__bad_interrupt>
      8c:	0c 94 78 19 	jmp	0x32f0	; 0x32f0 <__bad_interrupt>
      90:	0c 94 d4 3a 	jmp	0x75a8	; 0x75a8 <__vector_36>
      94:	0c 94 28 3b 	jmp	0x7650	; 0x7650 <__vector_37>
      98:	0c 94 fe 3a 	jmp	0x75fc	; 0x75fc <__vector_38>
      9c:	0c 94 78 19 	jmp	0x32f0	; 0x32f0 <__bad_interrupt>
      a0:	0c 94 78 19 	jmp	0x32f0	; 0x32f0 <__bad_interrupt>
      a4:	0c 94 78 19 	jmp	0x32f0	; 0x32f0 <__bad_interrupt>
      a8:	0c 94 57 29 	jmp	0x52ae	; 0x52ae <__vector_42>
      ac:	0c 94 78 19 	jmp	0x32f0	; 0x32f0 <__bad_interrupt>
      b0:	0c 94 78 19 	jmp	0x32f0	; 0x32f0 <__bad_interrupt>
      b4:	0c 94 78 19 	jmp	0x32f0	; 0x32f0 <__bad_interrupt>
      b8:	0c 94 78 19 	jmp	0x32f0	; 0x32f0 <__bad_interrupt>
      bc:	0c 94 78 19 	jmp	0x32f0	; 0x32f0 <__bad_interrupt>
      c0:	0c 94 78 19 	jmp	0x32f0	; 0x32f0 <__bad_interrupt>
      c4:	0c 94 78 19 	jmp	0x32f0	; 0x32f0 <__bad_interrupt>
      c8:	0c 94 78 19 	jmp	0x32f0	; 0x32f0 <__bad_interrupt>
      cc:	0c 94 a2 3b 	jmp	0x7744	; 0x7744 <__vector_51>
      d0:	0c 94 52 3b 	jmp	0x76a4	; 0x76a4 <__vector_52>
      d4:	0c 94 7a 3b 	jmp	0x76f4	; 0x76f4 <__vector_53>
      d8:	0c 94 78 19 	jmp	0x32f0	; 0x32f0 <__bad_interrupt>
      dc:	0c 94 78 19 	jmp	0x32f0	; 0x32f0 <__bad_interrupt>
      e0:	0c 94 78 19 	jmp	0x32f0	; 0x32f0 <__bad_interrupt>
      e4:	0a 51       	subi	r16, 0x1A	; 26
      e6:	30 51       	subi	r19, 0x10	; 16
      e8:	41 51       	subi	r20, 0x11	; 17
      ea:	54 51       	subi	r21, 0x14	; 20
      ec:	0a 51       	subi	r16, 0x1A	; 26
      ee:	30 51       	subi	r19, 0x10	; 16
      f0:	94 50       	subi	r25, 0x04	; 4
      f2:	68 51       	subi	r22, 0x18	; 24
      f4:	78 51       	subi	r23, 0x18	; 24
      f6:	88 51       	subi	r24, 0x18	; 24
      f8:	9b 51       	subi	r25, 0x1B	; 27
      fa:	68 51       	subi	r22, 0x18	; 24
      fc:	78 51       	subi	r23, 0x18	; 24
      fe:	ae 51       	subi	r26, 0x1E	; 30
     100:	ae 51       	subi	r26, 0x1E	; 30
     102:	94 50       	subi	r25, 0x04	; 4
     104:	94 50       	subi	r25, 0x04	; 4
     106:	94 50       	subi	r25, 0x04	; 4
     108:	94 50       	subi	r25, 0x04	; 4
     10a:	94 50       	subi	r25, 0x04	; 4
     10c:	94 50       	subi	r25, 0x04	; 4
     10e:	94 50       	subi	r25, 0x04	; 4
     110:	94 50       	subi	r25, 0x04	; 4
     112:	94 50       	subi	r25, 0x04	; 4
     114:	94 50       	subi	r25, 0x04	; 4
     116:	94 50       	subi	r25, 0x04	; 4
     118:	94 50       	subi	r25, 0x04	; 4
     11a:	94 50       	subi	r25, 0x04	; 4
     11c:	94 50       	subi	r25, 0x04	; 4
     11e:	bc 51       	subi	r27, 0x1C	; 28
     120:	ca 51       	subi	r28, 0x1A	; 26
     122:	d9 51       	subi	r29, 0x19	; 25
     124:	ea 51       	subi	r30, 0x1A	; 26
     126:	da 54       	subi	r29, 0x4A	; 74
     128:	f9 54       	subi	r31, 0x49	; 73
     12a:	1a 55       	subi	r17, 0x5A	; 90
     12c:	3d 55       	subi	r19, 0x5D	; 93
     12e:	da 54       	subi	r29, 0x4A	; 74
     130:	f9 54       	subi	r31, 0x49	; 73
     132:	9c 54       	subi	r25, 0x4C	; 76
     134:	62 55       	subi	r22, 0x52	; 82
     136:	80 55       	subi	r24, 0x50	; 80
     138:	9f 55       	subi	r25, 0x5F	; 95
     13a:	c1 55       	subi	r28, 0x51	; 81
     13c:	62 55       	subi	r22, 0x52	; 82
     13e:	80 55       	subi	r24, 0x50	; 80
     140:	e4 55       	subi	r30, 0x54	; 84
     142:	e4 55       	subi	r30, 0x54	; 84
     144:	9c 54       	subi	r25, 0x4C	; 76
     146:	ec 55       	subi	r30, 0x5C	; 92
     148:	65 54       	subi	r22, 0x45	; 69
     14a:	23 56       	subi	r18, 0x63	; 99
     14c:	5a 56       	subi	r21, 0x6A	; 106
     14e:	ec 55       	subi	r30, 0x5C	; 92
     150:	65 54       	subi	r22, 0x45	; 69
     152:	9c 54       	subi	r25, 0x4C	; 76
     154:	9c 54       	subi	r25, 0x4C	; 76
     156:	9c 54       	subi	r25, 0x4C	; 76
     158:	97 56       	subi	r25, 0x67	; 103
     15a:	c1 56       	subi	r28, 0x61	; 97
     15c:	97 56       	subi	r25, 0x67	; 103
     15e:	c1 56       	subi	r28, 0x61	; 97
     160:	da 54       	subi	r29, 0x4A	; 74
     162:	f9 54       	subi	r31, 0x49	; 73
     164:	eb 56       	subi	r30, 0x6B	; 107
     166:	fc 56       	subi	r31, 0x6C	; 108
     168:	13 57       	subi	r17, 0x73	; 115
     16a:	b8 54       	subi	r27, 0x48	; 72
     16c:	f3 59       	subi	r31, 0x93	; 147
     16e:	f3 59       	subi	r31, 0x93	; 147
     170:	aa 59       	subi	r26, 0x9A	; 154
     172:	aa 59       	subi	r26, 0x9A	; 154
     174:	f3 59       	subi	r31, 0x93	; 147
     176:	f3 59       	subi	r31, 0x93	; 147
     178:	b6 58       	subi	r27, 0x86	; 134
     17a:	f3 59       	subi	r31, 0x93	; 147
     17c:	f3 59       	subi	r31, 0x93	; 147
     17e:	aa 59       	subi	r26, 0x9A	; 154
     180:	aa 59       	subi	r26, 0x9A	; 154
     182:	f3 59       	subi	r31, 0x93	; 147
     184:	f3 59       	subi	r31, 0x93	; 147
     186:	86 59       	subi	r24, 0x96	; 150
     188:	86 59       	subi	r24, 0x96	; 150
     18a:	b6 58       	subi	r27, 0x86	; 134
     18c:	6e 59       	subi	r22, 0x9E	; 158
     18e:	6e 59       	subi	r22, 0x9E	; 158
     190:	6e 59       	subi	r22, 0x9E	; 158
     192:	6e 59       	subi	r22, 0x9E	; 158
     194:	6e 59       	subi	r22, 0x9E	; 158
     196:	6e 59       	subi	r22, 0x9E	; 158
     198:	b6 58       	subi	r27, 0x86	; 134
     19a:	b6 58       	subi	r27, 0x86	; 134
     19c:	b6 58       	subi	r27, 0x86	; 134
     19e:	6e 59       	subi	r22, 0x9E	; 158
     1a0:	6e 59       	subi	r22, 0x9E	; 158
     1a2:	6e 59       	subi	r22, 0x9E	; 158
     1a4:	6e 59       	subi	r22, 0x9E	; 158
     1a6:	50 59       	subi	r21, 0x90	; 144
     1a8:	50 59       	subi	r21, 0x90	; 144
     1aa:	33 59       	subi	r19, 0x93	; 147
     1ac:	33 59       	subi	r19, 0x93	; 147
     1ae:	fb 58       	subi	r31, 0x8B	; 139
     1b0:	fb 58       	subi	r31, 0x8B	; 139
     1b2:	db 5c       	subi	r29, 0xCB	; 203
     1b4:	d2 5c       	subi	r29, 0xC2	; 194
     1b6:	ca 5c       	subi	r28, 0xCA	; 202
     1b8:	bf 5c       	subi	r27, 0xCF	; 207
     1ba:	b9 5c       	subi	r27, 0xC9	; 201
     1bc:	b0 5c       	subi	r27, 0xC0	; 192
     1be:	a7 5c       	subi	r26, 0xC7	; 199
     1c0:	a1 5c       	subi	r26, 0xC1	; 193
     1c2:	99 5c       	subi	r25, 0xC9	; 201
     1c4:	93 5c       	subi	r25, 0xC3	; 195
     1c6:	8b 5c       	subi	r24, 0xCB	; 203
     1c8:	85 5c       	subi	r24, 0xC5	; 197
     1ca:	7d 5c       	subi	r23, 0xCD	; 205
     1cc:	a1 5c       	subi	r26, 0xC1	; 193
     1ce:	85 5c       	subi	r24, 0xC5	; 197
     1d0:	74 5c       	subi	r23, 0xC4	; 196
     1d2:	6d 5c       	subi	r22, 0xCD	; 205
     1d4:	66 5c       	subi	r22, 0xC6	; 198
     1d6:	5f 5c       	subi	r21, 0xCF	; 207
     1d8:	58 5c       	subi	r21, 0xC8	; 200
     1da:	51 5c       	subi	r21, 0xC1	; 193
     1dc:	4a 5c       	subi	r20, 0xCA	; 202
     1de:	6d 5c       	subi	r22, 0xCD	; 205
     1e0:	51 5c       	subi	r21, 0xC1	; 193
     1e2:	41 5c       	subi	r20, 0xC1	; 193
     1e4:	3a 5c       	subi	r19, 0xCA	; 202
     1e6:	2c 5c       	subi	r18, 0xCC	; 204
     1e8:	25 5c       	subi	r18, 0xC5	; 197
     1ea:	17 5c       	subi	r17, 0xC7	; 199
     1ec:	f7 5b       	subi	r31, 0xB7	; 183
     1ee:	06 5c       	subi	r16, 0xC6	; 198
     1f0:	d0 5b       	subi	r29, 0xB0	; 176
     1f2:	83 5b       	subi	r24, 0xB3	; 179
     1f4:	cb 5b       	subi	r28, 0xBB	; 187
     1f6:	bd 5b       	subi	r27, 0xBD	; 189
     1f8:	e7 67       	ori	r30, 0x77	; 119
     1fa:	d9 67       	ori	r29, 0x79	; 121
     1fc:	cd 67       	ori	r28, 0x7D	; 125
     1fe:	41 62       	ori	r20, 0x21	; 33
     200:	74 62       	ori	r23, 0x24	; 36
     202:	2e 68       	ori	r18, 0x8E	; 142
     204:	1d 68       	ori	r17, 0x8D	; 141
     206:	bf 67       	ori	r27, 0x7F	; 127
     208:	b3 67       	ori	r27, 0x73	; 115
     20a:	a5 67       	ori	r26, 0x75	; 117
     20c:	99 67       	ori	r25, 0x79	; 121
     20e:	8b 67       	ori	r24, 0x7B	; 123
     210:	7f 67       	ori	r23, 0x7F	; 127
     212:	71 67       	ori	r23, 0x71	; 113
     214:	64 67       	ori	r22, 0x74	; 116
     216:	fd 66       	ori	r31, 0x6D	; 109
     218:	ec 66       	ori	r30, 0x6C	; 108
     21a:	4d 66       	ori	r20, 0x6D	; 109
     21c:	34 66       	ori	r19, 0x64	; 100
     21e:	d7 66       	ori	r29, 0x67	; 103
     220:	65 66       	ori	r22, 0x65	; 101
     222:	22 66       	ori	r18, 0x62	; 98
     224:	10 66       	ori	r17, 0x60	; 96
     226:	ef 65       	ori	r30, 0x5F	; 95
     228:	dd 65       	ori	r29, 0x5D	; 93
     22a:	c5 65       	ori	r28, 0x55	; 85
     22c:	ae 65       	ori	r26, 0x5E	; 94
     22e:	89 65       	ori	r24, 0x59	; 89
     230:	77 65       	ori	r23, 0x57	; 87
     232:	53 65       	ori	r21, 0x53	; 83
     234:	41 65       	ori	r20, 0x51	; 81
     236:	5c 69       	ori	r21, 0x9C	; 156
     238:	37 69       	ori	r19, 0x97	; 151
     23a:	25 69       	ori	r18, 0x95	; 149
     23c:	13 69       	ori	r17, 0x93	; 147
     23e:	f2 68       	ori	r31, 0x82	; 130
     240:	da 68       	ori	r29, 0x8A	; 138
     242:	c8 68       	ori	r28, 0x88	; 136
     244:	bc 68       	ori	r27, 0x8C	; 140
     246:	ae 68       	ori	r26, 0x8E	; 142
     248:	96 68       	ori	r25, 0x86	; 134
     24a:	a2 68       	ori	r26, 0x82	; 130
     24c:	85 68       	ori	r24, 0x85	; 133
     24e:	72 68       	ori	r23, 0x82	; 130
     250:	61 68       	ori	r22, 0x81	; 129
     252:	4d 68       	ori	r20, 0x8D	; 141
     254:	3c 68       	ori	r19, 0x8C	; 140
     256:	d3 69       	ori	r29, 0x93	; 147
     258:	bd 69       	ori	r27, 0x9D	; 157
     25a:	b3 69       	ori	r27, 0x93	; 147
     25c:	a2 69       	ori	r26, 0x92	; 146
     25e:	96 69       	ori	r25, 0x96	; 150
     260:	88 69       	ori	r24, 0x98	; 152
     262:	7c 69       	ori	r23, 0x9C	; 156
     264:	6e 69       	ori	r22, 0x9E	; 158
     266:	42 6a       	ori	r20, 0xA2	; 162
     268:	32 6a       	ori	r19, 0xA2	; 162
     26a:	25 6a       	ori	r18, 0xA5	; 165
     26c:	e5 69       	ori	r30, 0x95	; 149
     26e:	5f 6a       	ori	r21, 0xAF	; 175
     270:	4f 6a       	ori	r20, 0xAF	; 175
     272:	e2 6a       	ori	r30, 0xA2	; 162
     274:	36 65       	ori	r19, 0x56	; 86
     276:	f6 64       	ori	r31, 0x46	; 70
     278:	b3 64       	ori	r27, 0x43	; 67
     27a:	a6 64       	ori	r26, 0x46	; 70
     27c:	93 64       	ori	r25, 0x43	; 67
     27e:	1f 65       	ori	r17, 0x5F	; 95
     280:	05 65       	ori	r16, 0x55	; 85
     282:	11 65       	ori	r17, 0x51	; 81
     284:	90 63       	ori	r25, 0x30	; 48
     286:	3b 64       	ori	r19, 0x4B	; 75
     288:	d5 61       	ori	r29, 0x15	; 21
     28a:	d5 61       	ori	r29, 0x15	; 21
     28c:	fd 63       	ori	r31, 0x3D	; 61
     28e:	f3 63       	ori	r31, 0x33	; 51
     290:	9c 63       	ori	r25, 0x3C	; 60
     292:	6e 64       	ori	r22, 0x4E	; 78
     294:	4d 64       	ori	r20, 0x4D	; 77
     296:	7c 64       	ori	r23, 0x4C	; 76
     298:	84 63       	ori	r24, 0x34	; 52
     29a:	72 63       	ori	r23, 0x32	; 50
     29c:	40 63       	ori	r20, 0x30	; 48
     29e:	2e 63       	ori	r18, 0x3E	; 62
     2a0:	22 63       	ori	r18, 0x32	; 50
     2a2:	e5 62       	ori	r30, 0x25	; 37
     2a4:	cb 62       	ori	r28, 0x2B	; 43
     2a6:	ad 62       	ori	r26, 0x2D	; 45
     2a8:	9f 62       	ori	r25, 0x2F	; 47
     2aa:	82 62       	ori	r24, 0x22	; 34
     2ac:	dd 73       	andi	r29, 0x3D	; 61
     2ae:	e4 73       	andi	r30, 0x34	; 52
     2b0:	d0 73       	andi	r29, 0x30	; 48
     2b2:	d7 73       	andi	r29, 0x37	; 55
     2b4:	c6 73       	andi	r28, 0x36	; 54
     2b6:	cc 73       	andi	r28, 0x3C	; 60
     2b8:	b9 73       	andi	r27, 0x39	; 57
     2ba:	bf 73       	andi	r27, 0x3F	; 63
     2bc:	eb 73       	andi	r30, 0x3B	; 59
     2be:	b5 73       	andi	r27, 0x35	; 53
     2c0:	9d 73       	andi	r25, 0x3D	; 61
     2c2:	6f 74       	andi	r22, 0x4F	; 79
     2c4:	57 74       	andi	r21, 0x47	; 71
     2c6:	4b 74       	andi	r20, 0x4B	; 75
     2c8:	33 74       	andi	r19, 0x43	; 67
     2ca:	17 74       	andi	r17, 0x47	; 71
     2cc:	f3 73       	andi	r31, 0x33	; 51

000002ce <__c.1790>:
     2ce:	6e 61 6e 00                                         nan.

000002d2 <__c.1788>:
     2d2:	69 6e 66 00                                         inf.

000002d6 <__c.2085>:
     2d6:	63 64 69 6e 6f 70 73 75 78 58 5b 65 66 67 45 46     cdinopsuxX[efgEF
     2e6:	47 00                                               G.

000002e8 <pstr_an>:
     2e8:	61 6e 00                                            an.

000002eb <pstr_nfinity>:
     2eb:	6e 66 69 6e 69 74 79 00                             nfinity.

000002f3 <pwr_m10>:
     2f3:	cd cc cc 3d 0a d7 23 3c 17 b7 d1 38 77 cc 2b 32     ...=..#<...8w.+2
     303:	95 95 e6 24 1f b1 4f 0a                             ...$..O.

0000030b <pwr_p10>:
     30b:	00 00 20 41 00 00 c8 42 00 40 1c 46 20 bc be 4c     .. A...B.@.F ..L
     31b:	ca 1b 0e 5a ae c5 9d 74                             ...Z...t

00000323 <DaysMonth>:
     323:	00 1f 1c 1f 1e 1f 1e 1f 1f 1e 1f 1e 1f              .............

00000330 <Modbus_Map>:
     330:	76 07 20 00 fe 09 20 00 19 0b 04 00 fd 07 50 00     v. ... .......P.

00000340 <BR_Tbl>:
     340:	42 03 ff a0 01 fb cf 00 7d 67 00 3f 44 00 2a 33     B.......}g.?D.*3
     350:	00 1f 22 00 1b 19 00 1b 10 00 1b                    .."........

0000035b <GSM_SIMCOM_SIM900R>:
     35b:	53 49 4d 43 4f 4d 5f 53 49 4d 39 30 30 52 00        SIMCOM_SIM900R.

0000036a <GSM_SIMCOM_SIM800>:
     36a:	53 49 4d 43 4f 4d 5f 53 49 4d 38 30 30 00           SIMCOM_SIM800.

00000378 <GSM_SIMCOM_SIM800C>:
     378:	53 49 4d 43 4f 4d 5f 53 49 4d 38 30 30 43 00        SIMCOM_SIM800C.

00000387 <URC_RDY>:
     387:	52 44 59 00                                         RDY.

0000038b <URC_CFUN>:
     38b:	2b 43 46 55 4e 3a 20 31 00                          +CFUN: 1.

00000394 <URC_CPIN_READY>:
     394:	2b 43 50 49 4e 3a 20 52 45 41 44 59 00              +CPIN: READY.

000003a1 <URC_CALL_READY>:
     3a1:	43 61 6c 6c 20 52 65 61 64 79 00                    Call Ready.

000003ac <URC_SMS_READY>:
     3ac:	53 4d 53 20 52 65 61 64 79 00                       SMS Ready.

000003b6 <URC_REMOTE_IP>:
     3b6:	52 45 4d 4f 54 45 20 49 50 00                       REMOTE IP.

000003c0 <URC_CONNECT>:
     3c0:	43 4f 4e 4e 45 43 54 00                             CONNECT.

000003c8 <URC_RECEIVE>:
     3c8:	2b 52 45 43 45 49 56 45 2c 00                       +RECEIVE,.

000003d2 <URC_CLOSED>:
     3d2:	2c 20 43 4c 4f 53 45 44 00                          , CLOSED.

000003db <URC_PDPDEACT>:
     3db:	2b 50 44 50 20 44 45 41 43 54 00                    +PDP DEACT.

000003e6 <URC_NO_CARRIER>:
     3e6:	4e 4f 20 43 41 52 52 49 45 52 00                    NO CARRIER.

000003f1 <RESP_OK>:
     3f1:	4f 4b 00                                            OK.

000003f4 <RESP_CONNECT>:
     3f4:	43 4f 4e 4e 45 43 54 00                             CONNECT.

000003fc <RESP_CONNECT_OK>:
     3fc:	78 2c 20 43 4f 4e 4e 45 43 54 20 4f 4b 00           x, CONNECT OK.

0000040a <RESP_SERVER_OK>:
     40a:	53 45 52 56 45 52 20 4f 4b 00                       SERVER OK.

00000414 <RESP_SERVER_CLOSE>:
     414:	53 45 52 56 45 52 20 43 4c 4f 53 45 00              SERVER CLOSE.

00000421 <RESP_Invitation>:
     421:	3e 00                                               >.

00000423 <RESP_SEND_OK>:
     423:	78 2c 20 53 45 4e 44 20 4f 4b 00                    x, SEND OK.

0000042e <RESP_CLOSE_OK>:
     42e:	43 4c 4f 53 45 20 4f 4b 00                          CLOSE OK.

00000437 <RESP_CLOSE_OK_FAST>:
     437:	78 2c 20 43 4c 4f 53 45 20 4f 4b 00                 x, CLOSE OK.

00000443 <RESP_CSQ>:
     443:	2b 43 53 51 3a 00                                   +CSQ:.

00000449 <RESP_SHUT_OK>:
     449:	53 48 55 54 20 4f 4b 00                             SHUT OK.

00000451 <RESP_CREC_0>:
     451:	2b 43 52 45 43 3a 20 30 00                          +CREC: 0.

0000045a <ESC_SEQ>:
     45a:	2b 2b 2b 00                                         +++.

0000045e <IDENTIFICATION>:
     45e:	49 44 45 4e 54 49 46 49 43 41 54 49 4f 4e 00        IDENTIFICATION.

0000046d <AT_AT>:
     46d:	41 54 00                                            AT.

00000470 <AT_IPR9600>:
     470:	41 54 2b 49 50 52 3d 39 36 30 30 00                 AT+IPR=9600.

0000047c <AT_W>:
     47c:	41 54 26 57 00                                      AT&W.

00000481 <AT_E0>:
     481:	41 54 45 30 00                                      ATE0.

00000486 <AT_CLCC1>:
     486:	41 54 2b 43 4c 43 43 3d 31 00                       AT+CLCC=1.

00000490 <AT_DDET101>:
     490:	41 54 2b 44 44 45 54 3d 31 2c 30 2c 31 00           AT+DDET=1,0,1.

0000049e <AT_CGMM>:
     49e:	41 54 2b 43 47 4d 4d 00                             AT+CGMM.

000004a6 <AT_CCID>:
     4a6:	41 54 2b 43 43 49 44 00                             AT+CCID.

000004ae <AT_IFC>:
     4ae:	41 54 2b 49 46 43 3d 32 2c 32 00                    AT+IFC=2,2.

000004b9 <ATD101>:
     4b9:	41 54 44 2a 31 30 31 23 00                          ATD*101#.

000004c2 <ATD_PLUS>:
     4c2:	41 54 44 2b 00                                      ATD+.

000004c7 <AT_CUSD101>:
     4c7:	41 54 2b 43 55 53 44 3d 31 2c 22 00                 AT+CUSD=1,".

000004d3 <AT_CMGF>:
     4d3:	41 54 2b 43 4d 47 46 3d 31 00                       AT+CMGF=1.

000004dd <AT_CSMP>:
     4dd:	41 54 2b 43 53 4d 50 3d 31 37 2c 31 36 37 2c 30     AT+CSMP=17,167,0
     4ed:	2c 30 00                                            ,0.

000004f0 <AT_CMGS>:
     4f0:	41 54 2b 43 4d 47 53 3d 22 2b 00                    AT+CMGS="+.

000004fb <AT_CIPMODE_0>:
     4fb:	41 54 2b 43 49 50 4d 4f 44 45 3d 30 00              AT+CIPMODE=0.

00000508 <AT_CIPMODE_1>:
     508:	41 54 2b 43 49 50 4d 4f 44 45 3d 31 00              AT+CIPMODE=1.

00000515 <AT_CIPMUX_0>:
     515:	41 54 2b 43 49 50 4d 55 58 3d 30 00                 AT+CIPMUX=0.

00000521 <AT_CIPMUX_1>:
     521:	41 54 2b 43 49 50 4d 55 58 3d 31 00                 AT+CIPMUX=1.

0000052d <AT_CGATT>:
     52d:	41 54 2b 43 47 41 54 54 3d 31 00                    AT+CGATT=1.

00000538 <AT_CIPCSGP>:
     538:	41 54 2b 43 49 50 43 53 47 50 3d 31 2c 22 00        AT+CIPCSGP=1,".

00000547 <AT_CSTT>:
     547:	41 54 2b 43 53 54 54 00                             AT+CSTT.

0000054f <AT_CIICR>:
     54f:	41 54 2b 43 49 49 43 52 00                          AT+CIICR.

00000558 <AT_CIFSR>:
     558:	41 54 2b 43 49 46 53 52 00                          AT+CIFSR.

00000561 <AT_CIPTKA>:
     561:	41 54 2b 43 49 50 54 4b 41 3d 31 2c 33 30 2c 33     AT+CIPTKA=1,30,3
     571:	30 2c 31 00                                         0,1.

00000575 <AT_CIPSTART>:
     575:	41 54 2b 43 49 50 53 54 41 52 54 3d 22 55 44 50     AT+CIPSTART="UDP
     585:	22 2c 00                                            ",.

00000588 <AT_CIPSTART_TCP_CLIENT>:
     588:	41 54 2b 43 49 50 53 54 41 52 54 3d 22 54 43 50     AT+CIPSTART="TCP
     598:	22 2c 00                                            ",.

0000059b <AT_CIPSERVER>:
     59b:	41 54 2b 43 49 50 53 45 52 56 45 52 3d 31 2c 00     AT+CIPSERVER=1,.

000005ab <AT_SERVERCLOSE>:
     5ab:	41 54 2b 43 49 50 53 45 52 56 45 52 3d 30 00        AT+CIPSERVER=0.

000005ba <AT_CIPSEND>:
     5ba:	41 54 2b 43 49 50 53 45 4e 44 3d 00                 AT+CIPSEND=.

000005c6 <AT_CIPCLOSE_1>:
     5c6:	41 54 2b 43 49 50 43 4c 4f 53 45 3d 78 2c 31 00     AT+CIPCLOSE=x,1.

000005d6 <AT_CIPCLOSE>:
     5d6:	41 54 2b 43 49 50 43 4c 4f 53 45 3d 31 00           AT+CIPCLOSE=1.

000005e4 <AT_CIPSHUT>:
     5e4:	41 54 2b 43 49 50 53 48 55 54 00                    AT+CIPSHUT.

000005ef <AT_CGATT_0>:
     5ef:	41 54 2b 43 47 41 54 54 3d 30 00                    AT+CGATT=0.

000005fa <AT_CSQ>:
     5fa:	41 54 2b 43 53 51 00                                AT+CSQ.

00000601 <ATO>:
     601:	41 54 4f 00                                         ATO.

00000605 <Symbols_P>:
     605:	30 31 32 33 34 35 36 37 38 39 61 62 63 64 65 66     0123456789abcdef
     615:	67 68 69 6a 6b 6c 6d 6e 6f 70 71 72 73 74 75 76     ghijklmnopqrstuv
     625:	77 78 79 7a 41 42 43 44 45 46 47 48 49 4a 4b 4c     wxyzABCDEFGHIJKL
     635:	4d 4e 4f 50 51 52 53 54 55 56 57 58 59 5a e0 e1     MNOPQRSTUVWXYZ..
     645:	e2 e3 e4 e5 b8 ba e6 e7 e8 b3 bf e9 ea eb ec ed     ................
     655:	ee ef f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 fa fb fc fd     ................
     665:	fe ff c0 c1 c2 c3 c4 c5 a8 aa c6 c7 c8 b2 af c9     ................
     675:	ca cb cc cd ce cf d0 d1 d2 d3 d4 d5 d6 d7 d8 d9     ................
     685:	da db dc dd de df 20 2b 2d 3d 3c 3e 24 25 26 2e     ...... +-=<>$%&.
     695:	2c 3f 21 27 40 3a 28 29 22 7c 2a 23 2f 00           ,?!'@:()"|*#/.

000006a3 <OnlyDigits_P>:
     6a3:	30 31 32 33 34 35 36 37 38 39 00                    0123456789.

000006ae <Digits_P>:
     6ae:	30 31 32 33 34 35 36 37 38 39 65 2b 2d 2e 00        0123456789e+-..

000006bd <ThermFami>:
     6bd:	00 00 00 00 00 00                                   ......

000006c3 <TermisLim>:
     6c3:	00 00 00 00 0c fe 08 07 0c fe 08 07 0c fe 70 17     ..............p.
     6d3:	0c fe 70 17 0c fe 70 17 0c fe 70 17 0c fe 08 07     ..p...p...p.....

000006e3 <TermocLim>:
     6e3:	00 00 00 00 30 f8 e0 2e 70 17 50 46 30 f8 4c 1d     ....0...p.PF0.L.
     6f3:	30 f8 70 17                                         0.p.

000006f7 <Fail_Str>:
     6f7:	d1 e1 ee e9 20 00                                   .... .

000006fd <Norm_Str>:
     6fd:	cd ee f0 ec e0 00                                   ......

00000703 <DI_NO_Str>:
     703:	ed e5 f2 20 00                                      ... .

00000708 <DI_OK_Str>:
     708:	ed ee f0 ec 00                                      .....

0000070d <DI_Sta_Tbl>:
     70d:	03 07 08 07                                         ....

00000711 <DI_Op_Str>:
     711:	f0 e0 e7 ec 00                                      .....

00000716 <DI_Cl_Str>:
     716:	e7 e0 ec ea 00                                      .....

0000071b <DI_Tbl>:
     71b:	11 07 16 07                                         ....

0000071f <DI_Inv_Cl_Str>:
     71f:	ed 2e e7 2e 00                                      .....

00000724 <DI_Inv_Op_Str>:
     724:	ed 2e f0 2e 00                                      .....

00000729 <DI_Inv_Tbl>:
     729:	1f 07 24 07                                         ..$.

0000072d <DO_Op_Str>:
     72d:	e2 fb ea eb 00                                      .....

00000732 <DO_Cl_Str>:
     732:	e2 ea eb 20 00                                      ... .

00000737 <DO_Tbl>:
     737:	2d 07 32 07                                         -.2.

0000073b <F_ADC_3>:
     73b:	07 70 07 00 00 00                                   .p....

00000741 <F_ADC_4>:
     741:	07 e3 08 00 00 00                                   ......

00000747 <F_ADC_5>:
     747:	07 b5 06 00 00 00                                   ......

0000074d <List_ADC_Err>:
     74d:	20 2d 2d 2d 20 41 44 43 20 65 72 72 6f 72 73 20      --- ADC errors 
     75d:	2d 2d 2d 20 00 00 00 00 00 00 00 20 52 65 61 64     --- ....... Read
     76d:	20 66 61 69 6c 3a 20 20 20 20 7b 7b 7b 7b 7b 00      fail:    {{{{{.
     77d:	3b 07 00 00 00 00 20 43 61 6c 69 62 72 20 66 61     ;..... Calibr fa
     78d:	69 6c 3a 20 20 7b 7b 7b 7b 7b 00 41 07 00 00 00     il:  {{{{{.A....
     79d:	00 20 43 61 6c 69 62 72 20 62 72 65 61 6b 3a 20     . Calibr break: 
     7ad:	7b 7b 7b 7b 7b 00 47 07 00 00 00 00                 {{{{{.G.....

000007b9 <Menu_ADC_Err>:
     7b9:	4d 07 04 03 00 00 00 00 00 00 00 00 00 00 00 00     M...............
     7c9:	00 00 00 00                                         ....

000007cd <F_ADC_1>:
     7cd:	1d 22 0b 47 24 00                                   .".G$.

000007d3 <F_ADC_2>:
     7d3:	00 b1 06 00 00 00 00 ca 08 00 00 00                 ............

000007df <List_ADC>:
     7df:	20 d0 e5 e6 e8 ec 3a 20 7b 7b 7b 7b 7b 7b 7b 7b      .....: {{{{{{{{
     7ef:	7b 7b 7b 7b 00 cd 07 00 00 00 00 20 c2 f0 e5 ec     {{{{....... ....
     7ff:	ff 3a 7b 7b 30 ec f1 20 ca e0 ed e0 eb 3a 7b 00     .:{{0.. .....:{.
     80f:	d3 07 00 00 00 00 20 2d 20 ca e0 ed e0 eb fb 20     ...... - ...... 
     81f:	2d 20 20 20 20 20 20 20 20 20 00 00 00 00 00 68     -         .....h
     82f:	23 20 2d 20 ca e0 eb e8 e1 f0 ee e2 ea e0 20 2d     # - .......... -
     83f:	20 20 20 20 20 00 00 00 00 00 0c 24 20 2d 20 ce          ......$ - .
     84f:	f8 e8 e1 ea e8 20 2d 20 20 20 20 20 20 20 20 20     ..... -         
     85f:	00 00 00 00 00 b9 07                                .......

00000866 <MenuADC>:
     866:	df 07 05 02 00 00 00 00 00 00 00 00 00 00 00 00     ................
     876:	00 00 00 00                                         ....

0000087a <MsgErr21>:
     87a:	20 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f      _______________
     88a:	5f 5f 5f 20 00 00 00 20 49 6e 74 65 72 6e 61 6c     ___ ... Internal
     89a:	20 65 72 72 6f 72 20 32 31 3a 20 00 00 00 20 20      error 21: ...  
     8aa:	20 20 20 20 41 44 43 20 6f 66 66 20 20 20 20 20         ADC off     
     8ba:	20 20 00 00 00 20 20 20 20 20 20 20 20 20 20 20       ...           
     8ca:	20 20 20 20 20 20 20 20 20 00 00 00 00 00 00 00              .......
	...

000008dc <Therm_Off_Str>:
     8dc:	20 20 20 78 20 20 20 00                                x   .

000008e4 <ADC_Off_Str>:
     8e4:	2d 2d 2d 2d 2d 2d 2d 00                             -------.

000008ec <ThermTbl>:
     8ec:	dc 08 e4 08                                         ....

000008f0 <ThermOff_Str>:
     8f0:	ce f2 ea eb 2e 00                                   ......

000008f6 <TSM100_Str>:
     8f6:	d2 d1 cc 31 30 30 00                                ...100.

000008fd <TSM50_Str>:
     8fd:	d2 d1 cc 35 30 00                                   ...50.

00000903 <TSP100_Str>:
     903:	d2 d1 cf 31 30 30 00                                ...100.

0000090a <TSP50_Str>:
     90a:	d2 d1 cf 35 30 00                                   ...50.

00000910 <Pt100_Str>:
     910:	50 74 31 30 30 00                                   Pt100.

00000916 <Gr21_Str>:
     916:	c3 f0 32 31 00                                      ..21.

0000091b <Gr23_Str>:
     91b:	c3 f0 32 33 00                                      ..23.

00000920 <RTD_Name_List>:
     920:	f0 08 f6 08 fd 08 03 09 0a 09 10 09 16 09 1b 09     ................

00000930 <TC_K_Str>:
     930:	54 58 41 00                                         TXA.

00000934 <TC_B_Str>:
     934:	54 cf d0 00                                         T...

00000938 <TC_J_Str>:
     938:	54 c6 ca 00                                         T...

0000093c <TC_L_Str>:
     93c:	54 58 ca 00                                         TX..

00000940 <TC_Name_List>:
     940:	f0 08 30 09 34 09 38 09 3c 09                       ..0.4.8.<.

0000094a <NoPariStr>:
     94a:	ed e5 f2 00                                         ....

0000094e <EvenPariStr>:
     94e:	f7 e5 f2 ed fb e9 00                                .......

00000955 <OddPariStr>:
     955:	ed e5 f7 e5 f2 ed fb e9 00                          .........

0000095e <MBPariTbl>:
     95e:	4a 09 4e 09 55 09                                   J.N.U.

00000964 <BR_Str1200>:
     964:	31 32 30 30 00                                      1200.

00000969 <BR_Str2400>:
     969:	32 34 30 30 00                                      2400.

0000096e <BR_Str4800>:
     96e:	34 38 30 30 00                                      4800.

00000973 <BR_Str9600>:
     973:	39 36 30 30 00                                      9600.

00000978 <BR_Str14400>:
     978:	31 34 34 30 30 00                                   14400.

0000097e <BR_Str19200>:
     97e:	31 39 32 30 30 00                                   19200.

00000984 <BR_Str28800>:
     984:	32 38 38 30 30 00                                   28800.

0000098a <BR_Str38400>:
     98a:	33 38 34 30 30 00                                   38400.

00000990 <BR_Str57600>:
     990:	35 37 36 30 30 00                                   57600.

00000996 <BaudTbl>:
     996:	64 09 69 09 6e 09 73 09 78 09 7e 09 84 09 8a 09     d.i.n.s.x.~.....
     9a6:	90 09                                               ..

000009a8 <F_MB0_Pari>:
     9a8:	1e 04 00 00 00 00 00 02 00 00 00 b0 71 5e 09 00     ............q^..

000009b8 <F_MB0_Stopbits>:
     9b8:	01 05 00 01 00 00 00 02 00 00 00 b0 71 00 00 00     ............q...

000009c8 <F_MB0_Baud>:
     9c8:	1e 06 00 00 00 00 00 08 00 00 00 39 71 96 09 00     ...........9q...

000009d8 <MB0_CPT_04>:
     9d8:	0b ee 08 00 00 00 0b f6 08 00 00 00                 ............

000009e4 <MB0_CPT_15>:
     9e4:	0b f0 08 00 00 00 0b f8 08 00 00 00                 ............

000009f0 <MB0_CPT_26>:
     9f0:	0b f2 08 00 00 00 0b fa 08 00 00 00                 ............

000009fc <MB0_CPT_37>:
     9fc:	0b f4 08 00 00 00 0b fc 08 00 00 00                 ............

00000a08 <List_MB0_CPT>:
     a08:	43 50 31 3a 7b 7b 7b 7b 7b 20 20 43 50 35 3a 7b     CP1:{{{{{  CP5:{
     a18:	7b 7b 7b 7b 00 d8 09 00 00 00 00 43 50 32 3a 7b     {{{{.......CP2:{
     a28:	7b 7b 7b 7b 20 20 43 50 36 3a 7b 7b 7b 7b 7b 00     {{{{  CP6:{{{{{.
     a38:	e4 09 00 00 00 00 43 50 33 3a 7b 7b 7b 7b 7b 20     ......CP3:{{{{{ 
     a48:	20 43 50 37 3a 7b 7b 7b 7b 7b 00 f0 09 00 00 00      CP7:{{{{{......
     a58:	00 43 50 34 3a 7b 7b 7b 7b 7b 20 20 43 50 38 3a     .CP4:{{{{{  CP8:
     a68:	7b 7b 7b 7b 7b 00 fc 09 00 00 00 00                 {{{{{.......

00000a74 <M_MB0_CPT>:
     a74:	08 0a 04 03 00 00 00 00 00 00 00 00 53 40 00 00     ............S@..
     a84:	00 00 00 00                                         ....

00000a88 <L_MB0>:
     a88:	20 2d 2d 2d 2d 20 4d 6f 64 62 75 73 20 30 20 2d      ---- Modbus 0 -
     a98:	2d 2d 2d 20 00 00 00 00 00 00 00 20 d1 f7 e5 f2     --- ....... ....
     aa8:	f7 e8 ea e8 20 28 f1 e1 f0 ee f1 3a 2d 3e 29 00     .... (.....:->).
     ab8:	00 00 00 00 74 0a 20 cf e0 f0 e8 f2 e5 f2 3a 20     ....t. .......: 
     ac8:	7d 7d 7d 7d 7d 7d 7d 7d 20 20 00 00 00 a8 09 00     }}}}}}}}  ......
     ad8:	00 20 d1 f2 ee ef 2d e1 e8 f2 fb 3a 20 7d 20 20     . ....-....: }  
     ae8:	20 20 20 20 20 00 00 00 b8 09 00 00 20 42 41 55          ....... BAU
     af8:	44 3a 20 7d 7d 7d 7d 7d 62 70 73 20 20 20 20 20     D: }}}}}bps     
     b08:	00 00 00 c8 09 00 00                                .......

00000b0f <MenuModbus0>:
     b0f:	88 0a 05 01 00 00 00 00 00 00 00 00 00 00 00 00     ................
     b1f:	00 00 00 00                                         ....

00000b23 <List_Modbus>:
     b23:	20 4d 6f 64 62 75 73 20 30 20 20 20 20 20 20 20      Modbus 0       
     b33:	20 20 20 20 00 00 00 00 00 0f 0b 20 20 20 20 58         .......    X
     b43:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 00                    .
     b53:	00 00 00 00 00 00 20 20 20 20 58 20 20 20 20 20     ......    X     
     b63:	20 20 20 20 20 20 20 20 20 20 00 00 00 00 00 00               ......
     b73:	00 20 20 20 20 58 20 20 20 20 20 20 20 20 20 20     .    X          
     b83:	20 20 20 20 20 00 00 00 00 00 00 00                      .......

00000b8f <MenuModbus>:
     b8f:	23 0b 04 00 00 00 00 00 00 00 00 00 00 00 00 00     #...............
     b9f:	00 00 00 00                                         ....

00000ba3 <N_Str>:
     ba3:	cd e5 f2 00                                         ....

00000ba7 <Y_Str>:
     ba7:	c4 e0 00                                            ...

00000baa <YN_Tbl>:
     baa:	a3 0b a7 0b                                         ....

00000bae <F_SummerTime>:
     bae:	1e 03 00 00 00 00 00 01 00 00 00 00 00 aa 0b 00     ................

00000bbe <F_WDay>:
     bbe:	00 55 06 00 00 00                                   .U....

00000bc4 <F_DateTime>:
     bc4:	04 17 0b 01 00 00 00 1f 00 00 00 2f 24 00 00 00     .........../$...
     bd4:	04 85 07 01 00 00 00 0c 00 00 00 39 24 00 00 00     ...........9$...
     be4:	04 dc 05 00 00 00 00 63 00 00 00 43 24 00 00 00     .......c...C$...
     bf4:	04 bf 05 00 00 00 00 17 00 00 00 25 24 00 00 00     ...........%$...
     c04:	04 4f 06 00 00 00 00 3b 00 00 00 1b 24 00 00 00     .O.....;....$...
     c14:	04 b4 06 00 00 00 00 3b 00 00 00 11 24 00 00 00     .......;....$...

00000c24 <GSM_CNTL_AUTO_Str>:
     c24:	61 75 74 6f 20 20 00                                auto  .

00000c2b <GSM_CNTL_MANUAL_Str>:
     c2b:	6d 61 6e 75 61 6c 00                                manual.

00000c32 <GSM_CNTL_CONFIG_Str>:
     c32:	63 6f 6e 66 69 67 00                                config.

00000c39 <GSM_ControlList>:
     c39:	24 0c 2b 0c 32 0c                                   $.+.2.

00000c3f <GSM_Not_Recognize_Str>:
     c3f:	6e 6f 74 20 72 65 63 6f 67 00                       not recog.

00000c49 <GSM_SIMCOM_SIM900R_Str>:
     c49:	53 49 4d 39 30 30 52 20 20 00                       SIM900R  .

00000c53 <GSM_SIMCOM_SIM800_Str>:
     c53:	53 49 4d 38 30 30 20 20 20 00                       SIM800   .

00000c5d <GSM_ModemList>:
     c5d:	3f 0c 49 0c 53 0c                                   ?.I.S.

00000c63 <MenuGSM_Modem_State>:
     c63:	1d f1 06 5d 0c 00 00 b3 06 00 00 00                 ...]........

00000c6f <MenuGSM_State>:
     c6f:	00 b3 06 00 00 00                                   ......

00000c75 <MenuGSM_GSM_Cont>:
     c75:	1d 8a 07 00 00 00 00 02 00 00 00 62 40 39 0c 00     ...........b@9..

00000c85 <MenuGSM_GSM_MyIP>:
     c85:	00 e9 08 00 00 00 00 ea 08 00 00 00 00 eb 08 00     ................
     c95:	00 00 00 ec 08 00 00 00                             ........

00000c9d <MenuGSM_ClientIP>:
     c9d:	00 02 0b 00 00 00 00 03 0b 00 00 00 00 04 0b 00     ................
     cad:	00 00 00 05 0b 00 00 00                             ........

00000cb5 <MenuGSM_ActiveCon>:
     cb5:	00 d3 02 00 00 00                                   ......

00000cbb <MenuGSM_FIFOMax>:
     cbb:	00 d1 08 00 00 00                                   ......

00000cc1 <MenuGSM_APN1>:
     cc1:	22 09 00 00 00 00 00 06 00 00 00 00 00 00 00 00     "...............

00000cd1 <MenuGSM_APN2>:
     cd1:	22 1d 00 00 00 00 00 06 00 00 00 00 00 00 00 00     "...............

00000ce1 <MenuGSM_APN_USER_NAME>:
     ce1:	22 59 00 00 00 00 00 06 00 00 00 00 00 00 00 00     "Y..............

00000cf1 <MenuGSM_APN_PASSWORD>:
     cf1:	22 6d 00 00 00 00 00 06 00 00 00 00 00 00 00 00     "m..............

00000d01 <MenuGSM_IPUDP1>:
     d01:	01 81 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     d11:	01 82 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     d21:	01 83 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     d31:	01 84 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00000d41 <MenuGSM_IPUDP2>:
     d41:	01 85 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     d51:	01 86 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     d61:	01 87 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     d71:	01 88 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00000d81 <MenuGSM_IPUDP3>:
     d81:	01 89 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     d91:	01 8a 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     da1:	01 8b 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     db1:	01 8c 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00000dc1 <MenuGSM_IPUDP4>:
     dc1:	01 8d 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     dd1:	01 8e 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     de1:	01 8f 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     df1:	01 90 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00000e01 <MenuGSM_PortUDP1>:
     e01:	08 a1 00 00 00 00 00 ff ff 00 00 00 00 00 00 00     ................

00000e11 <MenuGSM_PortUDP2>:
     e11:	08 a3 00 00 00 00 00 ff ff 00 00 00 00 00 00 00     ................

00000e21 <MenuGSM_PortUDP3>:
     e21:	08 a5 00 00 00 00 00 ff ff 00 00 00 00 00 00 00     ................

00000e31 <MenuGSM_PortUDP4>:
     e31:	08 a7 00 00 00 00 00 ff ff 00 00 00 00 00 00 00     ................

00000e41 <MenuGSM_IPTCP1>:
     e41:	01 b3 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     e51:	01 b4 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     e61:	01 b5 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     e71:	01 b6 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00000e81 <MenuGSM_IPTCP2>:
     e81:	01 b7 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     e91:	01 b8 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     ea1:	01 b9 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     eb1:	01 ba 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00000ec1 <MenuGSM_IPTCP3>:
     ec1:	01 bb 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     ed1:	01 bc 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     ee1:	01 bd 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     ef1:	01 be 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00000f01 <MenuGSM_IPTCP4>:
     f01:	01 bf 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     f11:	01 c0 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     f21:	01 c1 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     f31:	01 c2 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00000f41 <MenuGSM_TCPPort>:
     f41:	08 b1 00 00 00 00 00 ff ff 00 00 00 00 00 00 00     ................

00000f51 <MenuGSM_TCPTimeout>:
     f51:	08 c3 00 64 00 00 00 ff ff 00 00 00 00 00 00 02     ...d............

00000f61 <MenuGSM_SMS>:
     f61:	01 13 01 00 00 00 00 01 00 00 00 00 00 00 00 00     ................

00000f71 <MenuGSM_VegaSN>:
     f71:	08 07 00 00 00 00 00 ff ff 00 00 00 00 00 00 00     ................

00000f81 <ListGSM>:
     f81:	20 cc ee e4 e5 ec 20 7b 7b 7b 7b 7b 7b 7b 7b 7b      ..... {{{{{{{{{
     f91:	20 7b 7b 7b 00 63 0c 00 00 00 00 20 43 6f 6e 74      {{{.c..... Cont
     fa1:	72 6f 6c 20 6d 6f 64 65 3a 7d 7d 7d 7d 7d 7d 00     rol mode:}}}}}}.
     fb1:	00 00 75 0c 00 00 20 4d 79 49 50 7b 7b 7b 2e 7b     ..u... MyIP{{{.{
     fc1:	7b 7b 2e 7b 7b 7b 2e 7b 7b 7b 00 85 0c 00 00 00     {{.{{{.{{{......
     fd1:	00 20 43 6c 49 50 7b 7b 7b 2e 7b 7b 7b 2e 7b 7b     . ClIP{{{.{{{.{{
     fe1:	7b 2e 7b 7b 7b 00 9d 0c 00 00 00 00 20 41 63 74     {.{{{....... Act
     ff1:	69 76 65 20 63 6f 6e 65 63 74 69 6f 6e 7b 7b 7b     ive conection{{{
    1001:	00 b5 0c 00 00 00 00 20 46 49 46 4f 3a 6d 61 78     ....... FIFO:max
    1011:	20 7b 7b 2f 37 30 62 79 74 65 20 00 bb 0c 00 00      {{/70byte .....
    1021:	00 00 20 2d 2d 2d 2d 2d 2d 2d 41 50 4e 2d 2d 2d     .. -------APN---
    1031:	2d 2d 2d 2d 2d 2d 00 00 00 00 00 00 00 20 7d 7d     ------....... }}
    1041:	7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d     }}}}}}}}}}}}}}}}
    1051:	7d 00 00 00 c1 0c 00 00 20 7d 7d 7d 7d 7d 7d 7d     }....... }}}}}}}
    1061:	7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 00 00 00 d1     }}}}}}}}}}}}....
    1071:	0c 00 00 20 2d 2d 2d 41 50 4e 2d 55 53 45 52 20     ... ---APN-USER 
    1081:	4e 41 4d 45 2d 2d 2d 00 00 00 00 00 00 00 20 7d     NAME---....... }
    1091:	7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d     }}}}}}}}}}}}}}}}
    10a1:	7d 7d 00 00 00 e1 0c 00 00 20 2d 2d 2d 41 50 4e     }}....... ---APN
    10b1:	2d 50 41 53 53 57 4f 52 44 2d 2d 2d 2d 00 00 00     -PASSWORD----...
    10c1:	00 00 00 00 20 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d     .... }}}}}}}}}}}
    10d1:	7d 7d 7d 7d 7d 7d 7d 7d 00 00 00 f1 0c 00 00 20     }}}}}}}}....... 
    10e1:	2d 2d 53 65 6e 64 20 55 44 50 20 74 6f 20 49 50     --Send UDP to IP
    10f1:	2d 2d 2d 00 00 00 00 00 00 00 20 49 50 31 3a 7d     ---....... IP1:}
    1101:	7d 7d 2e 7d 7d 7d 2e 7d 7d 7d 2e 7d 7d 7d 00 00     }}.}}}.}}}.}}}..
    1111:	00 01 0d 00 00 20 49 50 32 3a 7d 7d 7d 2e 7d 7d     ..... IP2:}}}.}}
    1121:	7d 2e 7d 7d 7d 2e 7d 7d 7d 00 00 00 41 0d 00 00     }.}}}.}}}...A...
    1131:	20 49 50 33 3a 7d 7d 7d 2e 7d 7d 7d 2e 7d 7d 7d      IP3:}}}.}}}.}}}
    1141:	2e 7d 7d 7d 00 00 00 81 0d 00 00 20 49 50 34 3a     .}}}....... IP4:
    1151:	7d 7d 7d 2e 7d 7d 7d 2e 7d 7d 7d 2e 7d 7d 7d 00     }}}.}}}.}}}.}}}.
    1161:	00 00 c1 0d 00 00 20 2d 2d 2d 2d 20 55 44 50 20     ...... ---- UDP 
    1171:	50 6f 72 74 20 2d 2d 2d 2d 2d 00 00 00 00 00 00     Port -----......
    1181:	00 20 49 50 31 20 50 6f 72 74 3a 7d 7d 7d 7d 7d     . IP1 Port:}}}}}
    1191:	20 20 20 20 20 00 00 00 01 0e 00 00 20 49 50 32          ....... IP2
    11a1:	20 50 6f 72 74 3a 7d 7d 7d 7d 7d 20 20 20 20 20      Port:}}}}}     
    11b1:	00 00 00 11 0e 00 00 20 49 50 33 20 50 6f 72 74     ....... IP3 Port
    11c1:	3a 7d 7d 7d 7d 7d 20 20 20 20 20 00 00 00 21 0e     :}}}}}     ...!.
    11d1:	00 00 20 49 50 34 20 50 6f 72 74 3a 7d 7d 7d 7d     .. IP4 Port:}}}}
    11e1:	7d 20 20 20 20 20 00 00 00 31 0e 00 00 20 2d 20     }     ...1... - 
    11f1:	54 43 50 20 49 50 20 46 69 72 65 77 61 6c 6c 2d     TCP IP Firewall-
    1201:	2d 00 00 00 00 00 00 00 20 49 50 31 3a 7d 7d 7d     -....... IP1:}}}
    1211:	2e 7d 7d 7d 2e 7d 7d 7d 2e 7d 7d 7d 00 00 00 41     .}}}.}}}.}}}...A
    1221:	0e 00 00 20 49 50 32 3a 7d 7d 7d 2e 7d 7d 7d 2e     ... IP2:}}}.}}}.
    1231:	7d 7d 7d 2e 7d 7d 7d 00 00 00 81 0e 00 00 20 49     }}}.}}}....... I
    1241:	50 33 3a 7d 7d 7d 2e 7d 7d 7d 2e 7d 7d 7d 2e 7d     P3:}}}.}}}.}}}.}
    1251:	7d 7d 00 00 00 c1 0e 00 00 20 49 50 34 3a 7d 7d     }}....... IP4:}}
    1261:	7d 2e 7d 7d 7d 2e 7d 7d 7d 2e 7d 7d 7d 00 00 00     }.}}}.}}}.}}}...
    1271:	01 0f 00 00 20 54 43 50 53 65 72 76 65 72 50 6f     .... TCPServerPo
    1281:	72 74 3a 7d 7d 7d 7d 7d 00 00 00 41 0f 00 00 20     rt:}}}}}...A... 
    1291:	54 69 6d 65 6f 75 74 20 54 43 50 3a 7d 7d 7d 7d     Timeout TCP:}}}}
    12a1:	7d 7d 63 00 00 00 51 0f 00 00 20 2d 2d 2d 2d 2d     }}c...Q... -----
    12b1:	2d 2d 20 53 4d 53 20 2d 2d 2d 2d 2d 2d 2d 00 00     -- SMS -------..
    12c1:	00 00 00 00 00 20 d0 e0 f1 f1 fb eb ea e0 20 53     ..... ........ S
    12d1:	4d 53 3a 20 20 20 7d 7d 7d 00 00 00 61 0f 00 00     MS:   }}}...a...
    12e1:	20 2d 2d 49 64 65 6e 74 69 66 69 63 61 74 69 6f      --Identificatio
    12f1:	6e 2d 2d 2d 00 00 00 00 00 00 00 20 56 65 67 61     n---....... Vega
    1301:	20 53 2f 4e 3a 20 20 20 20 20 7d 7d 7d 7d 7d 00      S/N:     }}}}}.
    1311:	00 00 71 0f 00 00                                   ..q...

00001317 <MenuGSM>:
    1317:	81 0f 22 00 00 00 00 00 00 00 00 00 00 00 00 00     ..".............
    1327:	00 00 00 00                                         ....

0000132b <Mem_OK_Tbl>:
    132b:	fd 06 f7 06                                         ....

0000132f <F_Ok_Flash>:
    132f:	1f cf 08 2b 13 00                                   ...+..

00001335 <F_Ok_EEPROM>:
    1335:	1f cf 08 2b 13 01                                   ...+..

0000133b <Msg_EEWarning>:
    133b:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    134b:	20 20 20 20 00 00 00 20 cf e5 f0 e5 e4 20 ef f0         ... ..... ..
    135b:	ee e4 ee eb e6 e5 ed e8 e5 ec 20 00 00 00 f0 e0     .......... .....
    136b:	e1 ee f2 fb 20 ef f0 ee e2 e5 f0 fc f2 e5 20 e2     .... ......... .
    137b:	f1 e5 00 00 00 20 20 20 20 20 20 ed e0 f1 f2 f0     .....      .....
    138b:	ee e9 ea e8 20 20 20 20 20 00 00 00 00 00 00 00     ....     .......
	...

0000139d <Msg_NoBackUp>:
    139d:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    13ad:	20 20 20 20 00 00 00 d1 ee f5 f0 e0 ed b8 ed ed         ............
    13bd:	fb f5 20 ed e0 f1 f2 f0 ee e5 ea 00 00 00 20 20     .. ...........  
    13cd:	20 20 ed e5 20 ee e1 ed e0 f0 f3 e6 e5 ed ee 20       .. .......... 
    13dd:	20 20 00 00 00 20 20 20 20 20 20 20 20 20 20 20       ...           
    13ed:	20 20 20 20 20 20 20 20 20 00 00 00 00 00 00 00              .......
	...

000013ff <Menu_ConfirmationSave_List>:
    13ff:	d1 ee f5 f0 e0 ed e8 f2 fc 20 ed e0 f1 f2 f0 ee     ......... ......
    140f:	e9 ea e8 3f 00 00 00 00 00 00 00 20 20 20 c4 e0     ...?.......   ..
    141f:	20 2d 20 ea ed ee ef ea e0 20 c2 d5 ce c4 20 00      - ...... .... .
    142f:	00 00 00 00 00 00 20 20 cd e5 f2 20 2d 20 ea ed     ......  ... - ..
    143f:	ee ef ea e0 20 c2 db d5 ce c4 00 00 00 00 00 00     .... ...........
    144f:	00 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20     .               
    145f:	20 20 20 20 20 00 00 00 00 00 00 00                      .......

0000146b <Menu_ConfirmationSave>:
    146b:	ff 13 04 03 00 00 00 00 00 00 00 00 85 40 00 00     .............@..
    147b:	00 00 00 00                                         ....

0000147f <Menu_ConfirmationRest_List>:
    147f:	c2 ee f1 f2 e0 ed ee e2 2e 20 ed e0 f1 f2 f0 ee     ......... ......
    148f:	e9 ea e8 3f 00 00 00 00 00 00 00 20 20 20 c4 e0     ...?.......   ..
    149f:	20 2d 20 ea ed ee ef ea e0 20 c2 d5 ce c4 20 00      - ...... .... .
    14af:	00 00 00 00 00 00 20 20 cd e5 f2 20 2d 20 ea ed     ......  ... - ..
    14bf:	ee ef ea e0 20 c2 db d5 ce c4 00 00 00 00 00 00     .... ...........
    14cf:	00 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20     .               
    14df:	20 20 20 20 20 00 00 00 00 00 00 00                      .......

000014eb <Menu_ConfirmationRestore>:
    14eb:	7f 14 04 03 00 00 00 00 00 00 00 00 7a 40 00 00     ............z@..
    14fb:	00 00 00 00                                         ....

000014ff <NoBackUp_Str>:
    14ff:	2d 2d 00                                            --.

00001502 <BackUp_Tbl>:
    1502:	ff 14                                               ..

00001504 <Menu_BackUp_IField>:
    1504:	05 00 00 02 15 00 05 01 00 02 15 00 05 02 00 02     ................
    1514:	15 00                                               ..

00001516 <Menu_BackUp_List>:
    1516:	d3 f1 f2 ed 2f d0 e5 e7 e5 f0 e2 ed e0 ff 20 ea     ..../......... .
    1526:	ee ef e8 ff 00 00 00 00 00 00 00 20 d1 ee f5 f0     ........... ....
    1536:	e0 ed e8 f2 fc 20 20 20 20 20 20 20 20 20 20 00     .....          .
    1546:	00 00 00 00 6b 14 20 c2 ee f1 f2 e0 ed ee e2 3a     ....k. ........:
    1556:	7b 7b 2e 7b 7b 2e 32 30 7b 7b 00 04 15 00 00 00     {{.{{.20{{......
    1566:	00 20 d1 ee f1 f2 2e 45 45 50 52 4f 4d 3a 20 7b     . .....EEPROM: {
    1576:	7b 7b 7b 7b 20 00 35 13 00 00 00 00                 {{{{ .5.....

00001582 <Menu_BackUp>:
    1582:	16 15 04 01 00 00 00 00 00 00 00 00 be 75 00 00     .............u..
    1592:	00 00 00 00                                         ....

00001596 <ListMem>:
    1596:	20 2d 2d 2d 2d 2d 20 4d 65 6d 6f 72 79 20 2d 2d      ----- Memory --
    15a6:	2d 2d 2d 20 00 00 00 00 00 00 00 20 46 6c 61 73     --- ....... Flas
    15b6:	68 3a 20 20 7b 7b 7b 7b 7b 20 20 20 20 20 20 00     h:  {{{{{      .
    15c6:	2f 13 00 00 00 00 20 45 45 50 52 4f 4d 3a 20 7b     /..... EEPROM: {
    15d6:	7b 7b 7b 7b 20 20 20 20 20 20 00 35 13 00 00 00     {{{{      .5....
    15e6:	00 20 52 65 73 65 74 20 45 45 50 52 4f 4d 20 66     . Reset EEPROM f
    15f6:	61 69 6c 20 20 00 00 00 00 00 00 00 20 42 61 63     ail  ....... Bac
    1606:	6b 55 70 20 45 45 50 52 4f 4d 20 20 20 20 20 20     kUp EEPROM      
    1616:	00 00 00 00 00 82 15                                .......

0000161d <MenuMem>:
    161d:	96 15 05 01 00 00 00 00 00 00 00 00 38 4c 00 00     ............8L..
    162d:	00 00 00 00                                         ....

00001631 <MsgErr11>:
    1631:	20 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f      _______________
    1641:	5f 5f 5f 20 00 00 00 20 49 6e 74 65 72 6e 61 6c     ___ ... Internal
    1651:	20 65 72 72 6f 72 20 31 31 3a 20 00 00 00 20 20      error 11: ...  
    1661:	20 20 20 46 6c 61 73 68 20 66 61 69 6c 20 20 20        Flash fail   
    1671:	20 20 00 00 00 20 20 20 20 20 20 20 20 20 20 20       ...           
    1681:	20 20 20 20 20 20 20 20 20 00 00 00 00 00 00 00              .......
	...

00001693 <MsgErr12>:
    1693:	20 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f      _______________
    16a3:	5f 5f 5f 20 00 00 00 20 49 6e 74 65 72 6e 61 6c     ___ ... Internal
    16b3:	20 65 72 72 6f 72 20 31 32 3a 20 00 00 00 20 20      error 12: ...  
    16c3:	20 20 45 45 50 52 4f 4d 20 66 61 69 6c 20 20 20       EEPROM fail   
    16d3:	20 20 00 00 00 20 20 20 20 20 20 20 20 20 20 20       ...           
    16e3:	20 20 20 20 20 20 20 20 20 00 00 00 00 00 00 00              .......
	...

000016f5 <MsgErr13>:
    16f5:	20 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f      _______________
    1705:	5f 5f 5f 20 00 00 00 20 49 6e 74 65 72 6e 61 6c     ___ ... Internal
    1715:	20 65 72 72 6f 72 20 31 33 3a 20 00 00 00 20 54      error 13: ... T
    1725:	6f 74 61 6c 20 6d 65 6d 6f 72 79 20 66 61 69 6c     otal memory fail
    1735:	20 20 00 00 00 20 20 20 20 20 20 20 20 20 20 20       ...           
    1745:	20 20 20 20 20 20 20 20 20 00 00 00 00 00 00 00              .......
	...

00001757 <MsgErrMemo>:
    1757:	00 00 31 16 93 16 f5 16                             ..1.....

0000175f <F_ScanCycle>:
    175f:	00 6a 07 00 00 00                                   .j....

00001765 <F_ScanCyclePerSec>:
    1765:	07 87 07 00 00 00                                   ......

0000176b <F_MaxScanCycle>:
    176b:	00 af 06 00 00 00                                   ......

00001771 <ListScanCycle>:
    1771:	20 2d 2d 2d 20 53 63 61 6e 20 43 79 63 6c 65 20      --- Scan Cycle 
    1781:	2d 2d 2d 20 00 00 00 00 00 00 00 20 53 63 61 6e     --- ....... Scan
    1791:	43 79 63 6c 65 3a 20 20 20 7b 7b 7b 30 6d 73 00     Cycle:   {{{0ms.
    17a1:	5f 17 00 00 00 00 20 53 63 61 6e 43 79 63 6c 50     _..... ScanCyclP
    17b1:	65 72 53 65 63 3a 7b 7b 7b 7b 00 65 17 00 00 00     erSec:{{{{.e....
    17c1:	00 20 4d 61 78 53 63 61 6e 43 79 63 6c 65 3a 7b     . MaxScanCycle:{
    17d1:	7b 7b 30 6d 73 00 6b 17 00 00 00 00                 {{0ms.k.....

000017dd <MenuScanCycle>:
    17dd:	71 17 04 01 00 00 00 00 00 00 00 00 66 40 00 00     q...........f@..
    17ed:	00 00 00 00                                         ....

000017f1 <F_WT>:
    17f1:	0b 23 0c 00 00 00 04 ae 06 00 00 00                 .#..........

000017fd <sec10_Str>:
    17fd:	31 30 20 f1 e5 ea 00                                10 ....

00001804 <sec30_Str>:
    1804:	33 30 20 f1 e5 ea 00                                30 ....

0000180b <min1_Str>:
    180b:	31 20 ec e8 ed 20 00                                1 ... .

00001812 <min3_Str>:
    1812:	33 20 ec e8 ed 20 00                                3 ... .

00001819 <min10_Str>:
    1819:	31 30 20 ec e8 ed 00                                10 ....

00001820 <BCKLT_Tbl>:
    1820:	fd 17 04 18 0b 18 12 18 19 18                       ..........

0000182a <F_Backlight>:
    182a:	1e 31 01 00 00 00 00 04 00 00 00 00 00 20 18 00     .1........... ..

0000183a <F_IonT>:
    183a:	08 2f 01 00 00 00 00 ff 03 00 00 00 00 00 00 00     ./..............

0000184a <F_Menu_EMICounter>:
    184a:	10 f6 06 00 00 00                                   ......

00001850 <ListSyst>:
    1850:	20 2d 20 d1 eb f3 e6 e5 e1 ed ee e5 20 ec e5 ed      - ......... ...
    1860:	fe 20 2d 20 00 00 00 00 00 00 00 20 c4 e8 f1 ea     . - ....... ....
    1870:	f0 e5 f2 ed fb e5 20 e2 f5 ee e4 fb 20 20 20 00     ...... .....   .
    1880:	00 00 00 00 6f 1e 20 c4 e8 f1 ea f0 e5 f2 ed fb     ....o. .........
    1890:	e5 20 e2 fb f5 ee e4 fb 20 20 00 00 00 00 00 33     . ......  .....3
    18a0:	21 20 c0 ed e0 eb ee e3 ee e2 fb e5 20 e2 f5 ee     ! .......... ...
    18b0:	e4 fb 20 20 20 00 00 00 00 00 e3 21 20 c0 ed e0     ..   ......! ...
    18c0:	eb ee e3 ee e2 fb e5 20 e2 fb f5 ee e4 fb 20 20     ....... ......  
    18d0:	00 00 00 00 00 a3 22 20 c0 d6 cf 20 20 20 20 20     ......" ...     
    18e0:	20 20 20 20 20 20 20 20 20 20 20 00 00 00 00 00                .....
    18f0:	66 08 20 d2 e5 f0 ec ee e4 e0 f2 f7 e8 ea e8 20     f. ............ 
    1900:	20 20 20 20 20 20 00 00 00 00 00 37 29 20 4d 6f           .....7) Mo
    1910:	64 62 75 73 20 20 20 20 20 20 20 20 20 20 20 20     dbus            
    1920:	20 00 00 00 00 00 8f 0b 20 cc ee e4 e5 ec 20 20      ....... .....  
    1930:	20 20 20 20 20 20 20 20 20 20 20 20 00 00 00 00                 ....
    1940:	00 17 13 20 7b 20 7d 7d 2e 7d 7d 2e 7d 7d 20 7d     ... { }}.}}.}} }
    1950:	7d 3a 7d 7d 3a 7d 7d 00 be 0b c4 0b 00 00 20 c0     }:}}:}}....... .
    1960:	e2 f2 ee cf e5 f0 e5 f5 cb e5 f2 ed c2 f0 3a 7d     ..............:}
    1970:	7d 7d 00 00 00 ae 0b 00 00 20 cd e0 f0 e0 e1 ee     }}....... ......
    1980:	f2 ea e0 3a 7b 7b 7b 7b 7b f7 7b 7b ec 00 f1 17     ...:{{{{{.{{....
    1990:	00 00 00 00 20 d1 ee f1 f2 ee ff ed e8 e5 20 ef     .... ......... .
    19a0:	e0 ec ff f2 e8 20 20 20 00 00 00 00 00 1d 16 20     .....   ....... 
    19b0:	53 63 61 6e 20 43 79 63 6c 65 3a 20 20 7b 7b 7b     Scan Cycle:  {{{
    19c0:	30 6d 73 00 5f 17 00 00 dd 17 20 cf ee f0 ee e3     0ms._..... .....
    19d0:	20 e8 ee ed ee e4 2e 3a 20 20 7d 7d 7d 7d 00 00      ......:  }}}}..
    19e0:	00 3a 18 00 00 20 cf ee e4 f1 e2 e5 f2 ea e0 c6     .:... ..........
    19f0:	ca c8 3a 7d 7d 7d 7d 7d 7d 00 00 00 2a 18 00 00     ..:}}}}}}...*...
    1a00:	20 d1 f7 b8 f2 2e dd cc cd 3a 7b 7b 7b 7b 7b 7b      ........:{{{{{{
    1a10:	7b 7b 7b 7b 00 4a 18 00 00 00 00                    {{{{.J.....

00001a1b <MenuSyst>:
    1a1b:	50 18 11 01 00 00 00 00 00 00 00 00 00 00 00 00     P...............
    1a2b:	00 00 00 00                                         ....

00001a2f <MsgErr41>:
    1a2f:	20 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f      _______________
    1a3f:	5f 5f 5f 20 00 00 00 20 49 6e 74 65 72 6e 61 6c     ___ ... Internal
    1a4f:	20 65 72 72 6f 72 20 34 31 3a 20 00 00 00 54 69      error 41: ...Ti
    1a5f:	6d 65 72 20 61 6c 6c 6f 63 61 74 69 6f 6e 20 65     mer allocation e
    1a6f:	72 72 00 00 00 20 20 20 20 20 20 20 20 20 20 20     rr...           
    1a7f:	20 20 20 20 20 20 20 20 20 00 00 00 00 00 00 00              .......
	...

00001a91 <F_DI1>:
    1a91:	1f fc 06 1b 07 00 1f 02 07 0d 07 00                 ............

00001a9d <F_DI2>:
    1a9d:	1f fc 06 1b 07 01 1f 02 07 0d 07 01                 ............

00001aa9 <F_DI3>:
    1aa9:	1f fc 06 1b 07 02 1f 02 07 0d 07 02                 ............

00001ab5 <F_DI4>:
    1ab5:	1f fc 06 1b 07 03 1f 02 07 0d 07 03                 ............

00001ac1 <F_DI5>:
    1ac1:	1f fc 06 1b 07 04 1f 02 07 0d 07 04                 ............

00001acd <F_DI6>:
    1acd:	1f fc 06 1b 07 05 1f 02 07 0d 07 05                 ............

00001ad9 <F_DI7>:
    1ad9:	1f fc 06 1b 07 06 1f 02 07 0d 07 06                 ............

00001ae5 <F_DI8>:
    1ae5:	1f fc 06 1b 07 07 1f 02 07 0d 07 07                 ............

00001af1 <F_DI9>:
    1af1:	1f fc 06 1b 07 08 1f 02 07 0d 07 08                 ............

00001afd <F_DI10>:
    1afd:	1f fc 06 1b 07 09 1f 02 07 0d 07 09                 ............

00001b09 <F_DI11>:
    1b09:	1f fc 06 1b 07 0a 1f 02 07 0d 07 0a                 ............

00001b15 <F_DI12>:
    1b15:	1f fc 06 1b 07 0b 1f 02 07 0d 07 0b                 ............

00001b21 <F_DI13>:
    1b21:	1f fc 06 1b 07 0c 1f 02 07 0d 07 0c                 ............

00001b2d <F_DI14>:
    1b2d:	1f fc 06 1b 07 0d 1f 02 07 0d 07 0d                 ............

00001b39 <F_DI15>:
    1b39:	1f fc 06 1b 07 0e 1f 02 07 0d 07 0e                 ............

00001b45 <F_DI16>:
    1b45:	1f fc 06 1b 07 0f 1f 02 07 0d 07 0f                 ............

00001b51 <F_DI17>:
    1b51:	1f fc 06 1b 07 10 1f 02 07 0d 07 10                 ............

00001b5d <F_DI18>:
    1b5d:	1f fc 06 1b 07 11 1f 02 07 0d 07 11                 ............

00001b69 <F_DII1>:
    1b69:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 00      ............)..

00001b79 <F_DII2>:
    1b79:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 01      ............)..

00001b89 <F_DII3>:
    1b89:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 02      ............)..

00001b99 <F_DII4>:
    1b99:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 03      ............)..

00001ba9 <F_DII5>:
    1ba9:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 04      ............)..

00001bb9 <F_DII6>:
    1bb9:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 05      ............)..

00001bc9 <F_DII7>:
    1bc9:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 06      ............)..

00001bd9 <F_DII8>:
    1bd9:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 07      ............)..

00001be9 <F_DII9>:
    1be9:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 08      ............)..

00001bf9 <F_DII10>:
    1bf9:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 09      ............)..

00001c09 <F_DII11>:
    1c09:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 0a      ............)..

00001c19 <F_DII12>:
    1c19:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 0b      ............)..

00001c29 <F_DII13>:
    1c29:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 0c      ............)..

00001c39 <F_DII14>:
    1c39:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 0d      ............)..

00001c49 <F_DII15>:
    1c49:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 0e      ............)..

00001c59 <F_DII16>:
    1c59:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 0f      ............)..

00001c69 <F_DII17>:
    1c69:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 10      ............)..

00001c79 <F_DII18>:
    1c79:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 11      ............)..

00001c89 <ListDI>:
    1c89:	20 4e 31 3a 20 20 7b 7b 7b 7b 20 7d 7d 7d 7d 20      N1:  {{{{ }}}} 
    1c99:	7b 7b 7b 7b 00 91 1a 69 1b 00 00 20 4e 32 3a 20     {{{{...i... N2: 
    1ca9:	20 7b 7b 7b 7b 20 7d 7d 7d 7d 20 7b 7b 7b 7b 00      {{{{ }}}} {{{{.
    1cb9:	9d 1a 79 1b 00 00 20 4e 33 3a 20 20 7b 7b 7b 7b     ..y... N3:  {{{{
    1cc9:	20 7d 7d 7d 7d 20 7b 7b 7b 7b 00 a9 1a 89 1b 00      }}}} {{{{......
    1cd9:	00 20 4e 34 3a 20 20 7b 7b 7b 7b 20 7d 7d 7d 7d     . N4:  {{{{ }}}}
    1ce9:	20 7b 7b 7b 7b 00 b5 1a 99 1b 00 00 20 4e 35 3a      {{{{....... N5:
    1cf9:	20 20 7b 7b 7b 7b 20 7d 7d 7d 7d 20 7b 7b 7b 7b       {{{{ }}}} {{{{
    1d09:	00 c1 1a a9 1b 00 00 20 4e 36 3a 20 20 7b 7b 7b     ....... N6:  {{{
    1d19:	7b 20 7d 7d 7d 7d 20 7b 7b 7b 7b 00 cd 1a b9 1b     { }}}} {{{{.....
    1d29:	00 00 20 4e 37 3a 20 20 7b 7b 7b 7b 20 7d 7d 7d     .. N7:  {{{{ }}}
    1d39:	7d 20 7b 7b 7b 7b 00 d9 1a c9 1b 00 00 20 4e 38     } {{{{....... N8
    1d49:	3a 20 20 7b 7b 7b 7b 20 7d 7d 7d 7d 20 7b 7b 7b     :  {{{{ }}}} {{{
    1d59:	7b 00 e5 1a d9 1b 00 00 20 4e 39 3a 20 20 7b 7b     {....... N9:  {{
    1d69:	7b 7b 20 7d 7d 7d 7d 20 7b 7b 7b 7b 00 f1 1a e9     {{ }}}} {{{{....
    1d79:	1b 00 00 20 4e 31 30 3a 20 7b 7b 7b 7b 20 7d 7d     ... N10: {{{{ }}
    1d89:	7d 7d 20 7b 7b 7b 7b 00 fd 1a f9 1b 00 00 20 4e     }} {{{{....... N
    1d99:	31 31 3a 20 7b 7b 7b 7b 20 7d 7d 7d 7d 20 7b 7b     11: {{{{ }}}} {{
    1da9:	7b 7b 00 09 1b 09 1c 00 00 20 4e 31 32 3a 20 7b     {{....... N12: {
    1db9:	7b 7b 7b 20 7d 7d 7d 7d 20 7b 7b 7b 7b 00 15 1b     {{{ }}}} {{{{...
    1dc9:	19 1c 00 00 20 4e 31 33 3a 20 7b 7b 7b 7b 20 7d     .... N13: {{{{ }
    1dd9:	7d 7d 7d 20 7b 7b 7b 7b 00 21 1b 29 1c 00 00 20     }}} {{{{.!.)... 
    1de9:	4e 31 34 3a 20 7b 7b 7b 7b 20 7d 7d 7d 7d 20 7b     N14: {{{{ }}}} {
    1df9:	7b 7b 7b 00 2d 1b 39 1c 00 00 20 4e 31 35 3a 20     {{{.-.9... N15: 
    1e09:	7b 7b 7b 7b 20 7d 7d 7d 7d 20 7b 7b 7b 7b 00 39     {{{{ }}}} {{{{.9
    1e19:	1b 49 1c 00 00 20 4e 31 36 3a 20 7b 7b 7b 7b 20     .I... N16: {{{{ 
    1e29:	7d 7d 7d 7d 20 7b 7b 7b 7b 00 45 1b 59 1c 00 00     }}}} {{{{.E.Y...
    1e39:	20 4e 31 37 3a 20 7b 7b 7b 7b 20 7d 7d 7d 7d 20      N17: {{{{ }}}} 
    1e49:	7b 7b 7b 7b 00 51 1b 69 1c 00 00 20 4e 31 38 3a     {{{{.Q.i... N18:
    1e59:	20 7b 7b 7b 7b 20 7d 7d 7d 7d 20 7b 7b 7b 7b 00      {{{{ }}}} {{{{.
    1e69:	5d 1b 79 1c 00 00                                   ].y...

00001e6f <MenuDI>:
    1e6f:	89 1c 12 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1e7f:	00 00 00 00                                         ....

00001e83 <F_DO1>:
    1e83:	1f 97 07 00 00 00 00 00 00 00 00 00 00 37 07 00     .............7..

00001e93 <F_DO2>:
    1e93:	1f 97 07 00 00 00 00 00 00 00 00 00 00 37 07 01     .............7..

00001ea3 <F_DO3>:
    1ea3:	1f 97 07 00 00 00 00 00 00 00 00 00 00 37 07 02     .............7..

00001eb3 <F_DO4>:
    1eb3:	1f 97 07 00 00 00 00 00 00 00 00 00 00 37 07 03     .............7..

00001ec3 <F_DO5>:
    1ec3:	1f 97 07 00 00 00 00 00 00 00 00 00 00 37 07 04     .............7..

00001ed3 <F_DO6>:
    1ed3:	1f 97 07 00 00 00 00 00 00 00 00 00 00 37 07 05     .............7..

00001ee3 <F_DO7>:
    1ee3:	1f 97 07 00 00 00 00 00 00 00 00 00 00 37 07 06     .............7..

00001ef3 <F_DO8>:
    1ef3:	1f 97 07 00 00 00 00 00 00 00 00 00 00 37 07 07     .............7..

00001f03 <F_DO9>:
    1f03:	1f 97 07 00 00 00 00 00 00 00 00 00 00 37 07 08     .............7..

00001f13 <F_DO10>:
    1f13:	1f 97 07 00 00 00 00 00 00 00 00 00 00 37 07 09     .............7..

00001f23 <F_DO11>:
    1f23:	1f 97 07 00 00 00 00 00 00 00 00 00 00 37 07 0a     .............7..

00001f33 <F_DO12>:
    1f33:	1f 97 07 00 00 00 00 00 00 00 00 00 00 37 07 0b     .............7..

00001f43 <F_DO13>:
    1f43:	1f 97 07 00 00 00 00 00 00 00 00 00 00 37 07 0c     .............7..

00001f53 <F_DO14>:
    1f53:	1f 97 07 00 00 00 00 00 00 00 00 00 00 37 07 0d     .............7..

00001f63 <F_DO15>:
    1f63:	1f 97 07 00 00 00 00 00 00 00 00 00 00 37 07 0e     .............7..

00001f73 <F_DO16>:
    1f73:	1f 97 07 00 00 00 00 00 00 00 00 00 00 37 07 0f     .............7..

00001f83 <ListDO>:
    1f83:	20 c2 fb f5 ee e4 20 4e 31 3a 20 20 20 20 20 7d      ..... N1:     }
    1f93:	7d 7d 7d 20 00 00 00 83 1e 00 00 20 c2 fb f5 ee     }}} ....... ....
    1fa3:	e4 20 4e 32 3a 20 20 20 20 20 7d 7d 7d 7d 20 00     . N2:     }}}} .
    1fb3:	00 00 93 1e 00 00 20 c2 fb f5 ee e4 20 4e 33 3a     ...... ..... N3:
    1fc3:	20 20 20 20 20 7d 7d 7d 7d 20 00 00 00 a3 1e 00          }}}} ......
    1fd3:	00 20 c2 fb f5 ee e4 20 4e 34 3a 20 20 20 20 20     . ..... N4:     
    1fe3:	7d 7d 7d 7d 20 00 00 00 b3 1e 00 00 20 c2 fb f5     }}}} ....... ...
    1ff3:	ee e4 20 4e 35 3a 20 20 20 20 20 7d 7d 7d 7d 20     .. N5:     }}}} 
    2003:	00 00 00 c3 1e 00 00 20 c2 fb f5 ee e4 20 4e 36     ....... ..... N6
    2013:	3a 20 20 20 20 20 7d 7d 7d 7d 20 00 00 00 d3 1e     :     }}}} .....
    2023:	00 00 20 c2 fb f5 ee e4 20 4e 37 3a 20 20 20 20     .. ..... N7:    
    2033:	20 7d 7d 7d 7d 20 00 00 00 e3 1e 00 00 20 c2 fb      }}}} ....... ..
    2043:	f5 ee e4 20 4e 38 3a 20 20 20 20 20 7d 7d 7d 7d     ... N8:     }}}}
    2053:	20 00 00 00 f3 1e 00 00 20 c2 fb f5 ee e4 20 4e      ....... ..... N
    2063:	39 3a 20 20 20 20 20 7d 7d 7d 7d 20 00 00 00 03     9:     }}}} ....
    2073:	1f 00 00 20 c2 fb f5 ee e4 20 4e 31 30 3a 20 20     ... ..... N10:  
    2083:	20 20 7d 7d 7d 7d 20 00 00 00 13 1f 00 00 20 c2       }}}} ....... .
    2093:	fb f5 ee e4 20 4e 31 31 3a 20 20 20 20 7d 7d 7d     .... N11:    }}}
    20a3:	7d 20 00 00 00 23 1f 00 00 20 c2 fb f5 ee e4 20     } ...#... ..... 
    20b3:	4e 31 32 3a 20 20 20 20 7d 7d 7d 7d 20 00 00 00     N12:    }}}} ...
    20c3:	33 1f 00 00 20 c2 fb f5 ee e4 20 4e 31 33 3a 20     3... ..... N13: 
    20d3:	20 20 20 7d 7d 7d 7d 20 00 00 00 43 1f 00 00 20        }}}} ...C... 
    20e3:	c2 fb f5 ee e4 20 4e 31 34 3a 20 20 20 20 7d 7d     ..... N14:    }}
    20f3:	7d 7d 20 00 00 00 53 1f 00 00 20 c2 fb f5 ee e4     }} ...S... .....
    2103:	20 4e 31 35 3a 20 20 20 20 7d 7d 7d 7d 20 00 00      N15:    }}}} ..
    2113:	00 63 1f 00 00 20 c2 fb f5 ee e4 20 4e 31 36 3a     .c... ..... N16:
    2123:	20 20 20 20 7d 7d 7d 7d 20 00 00 00 73 1f 00 00         }}}} ...s...

00002133 <MenuDO>:
    2133:	83 1f 10 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2143:	00 00 00 00                                         ....

00002147 <F_AI12>:
    2147:	0b 06 0b 00 00 00 0b 08 0b 00 00 00                 ............

00002153 <F_AI34>:
    2153:	0b 0a 0b 00 00 00 0b 0c 0b 00 00 00                 ............

0000215f <F_AI56>:
    215f:	0b 0e 0b 00 00 00 0b 10 0b 00 00 00                 ............

0000216b <F_AI78>:
    216b:	0b 12 0b 00 00 00 0b 14 0b 00 00 00                 ............

00002177 <ListAI>:
    2177:	20 4e 31 3a 20 7b 7b 7b 7b 7b 20 4e 32 3a 20 7b      N1: {{{{{ N2: {
    2187:	7b 7b 7b 7b 00 47 21 00 00 00 00 20 4e 33 3a 20     {{{{.G!.... N3: 
    2197:	7b 7b 7b 7b 7b 20 4e 34 3a 20 7b 7b 7b 7b 7b 00     {{{{{ N4: {{{{{.
    21a7:	53 21 00 00 00 00 20 4e 35 3a 20 7b 7b 7b 7b 7b     S!.... N5: {{{{{
    21b7:	20 4e 36 3a 20 7b 7b 7b 7b 7b 00 5f 21 00 00 00      N6: {{{{{._!...
    21c7:	00 20 4e 37 3a 20 7b 7b 7b 7b 7b 20 4e 38 3a 20     . N7: {{{{{ N8: 
    21d7:	7b 7b 7b 7b 7b 00 6b 21 00 00 00 00                 {{{{{.k!....

000021e3 <MenuAI>:
    21e3:	77 21 04 03 00 00 00 00 00 00 00 00 00 00 00 00     w!..............
    21f3:	00 00 00 00                                         ....

000021f7 <F_AO1>:
    21f7:	0e 8b 07 00 00 00 00 ff 03 00 00 00 00 00 00 00     ................

00002207 <F_AO2>:
    2207:	0e 8d 07 00 00 00 00 ff 03 00 00 00 00 00 00 00     ................

00002217 <F_AO3>:
    2217:	0e 8f 07 00 00 00 00 ff 03 00 00 00 00 00 00 00     ................

00002227 <F_AO4>:
    2227:	0e 91 07 00 00 00 00 ff 03 00 00 00 00 00 00 00     ................

00002237 <ListAO>:
    2237:	20 c2 fb f5 ee e4 20 4e 31 3a 20 20 20 20 20 7d      ..... N1:     }
    2247:	7d 7d 7d 7d 00 00 00 f7 21 00 00 20 c2 fb f5 ee     }}}}....!.. ....
    2257:	e4 20 4e 32 3a 20 20 20 20 20 7d 7d 7d 7d 7d 00     . N2:     }}}}}.
    2267:	00 00 07 22 00 00 20 c2 fb f5 ee e4 20 4e 33 3a     ...".. ..... N3:
    2277:	20 20 20 20 20 7d 7d 7d 7d 7d 00 00 00 17 22 00          }}}}}....".
    2287:	00 20 c2 fb f5 ee e4 20 4e 34 3a 20 20 20 20 20     . ..... N4:     
    2297:	7d 7d 7d 7d 7d 00 00 00 27 22 00 00                 }}}}}...'"..

000022a3 <MenuAO>:
    22a3:	37 22 04 00 00 00 00 00 00 00 00 00 00 00 00 00     7"..............
    22b3:	00 00 00 00                                         ....

000022b7 <F_ADC12>:
    22b7:	07 d3 08 00 00 00 07 d5 08 00 00 00                 ............

000022c3 <F_ADC34>:
    22c3:	07 d7 08 00 00 00 07 d9 08 00 00 00                 ............

000022cf <F_ADC56>:
    22cf:	07 db 08 00 00 00 07 dd 08 00 00 00                 ............

000022db <F_ADC_Ref>:
    22db:	07 df 08 00 00 00                                   ......

000022e1 <List_ADC_Chan>:
    22e1:	20 2d 2d 2d 20 ca e0 ed e0 eb fb 20 c0 d6 cf 20      --- ...... ... 
    22f1:	2d 2d 2d 20 00 00 00 00 00 00 00 20 4e 31 3a 20     --- ....... N1: 
    2301:	7b 7b 7b 7b 7b 20 4e 32 3a 20 7b 7b 7b 7b 7b 00     {{{{{ N2: {{{{{.
    2311:	b7 22 00 00 00 00 20 4e 33 3a 20 7b 7b 7b 7b 7b     .".... N3: {{{{{
    2321:	20 4e 34 3a 20 7b 7b 7b 7b 7b 00 c3 22 00 00 00      N4: {{{{{.."...
    2331:	00 20 4e 35 3a 20 7b 7b 7b 7b 7b 20 4e 36 3a 20     . N5: {{{{{ N6: 
    2341:	7b 7b 7b 7b 7b 00 cf 22 00 00 00 00 20 ce ef ee     {{{{{..".... ...
    2351:	f0 ed 2e 20 ea e0 ed e0 eb 3a 20 7b 7b 7b 7b 7b     ... .....: {{{{{
    2361:	00 db 22 00 00 00 00                                .."....

00002368 <Menu_ADC_Ch>:
    2368:	e1 22 05 01 00 00 00 00 00 00 00 00 00 00 00 00     ."..............
    2378:	00 00 00 00                                         ....

0000237c <F_ADC_Zero>:
    237c:	00 27 0c 00 00 00 04 26 0c 00 00 00 04 25 0c 00     .'.....&.....%..
	...

0000238e <F_ADC_Full>:
    238e:	00 2a 0c 00 00 00 04 29 0c 00 00 00 04 28 0c 00     .*.....).....(..
	...

000023a0 <List_ADC_Cali>:
    23a0:	20 2d 2d 2d 20 ca e0 eb e8 e1 f0 ee e2 ea e0 20      --- .......... 
    23b0:	2d 2d 2d 20 00 00 00 00 00 00 00 20 5a 65 72 6f     --- ....... Zero
    23c0:	3a 20 20 7b 7b 7b 20 7b 7b 7b 20 7b 7b 7b 20 00     :  {{{ {{{ {{{ .
    23d0:	7c 23 00 00 00 00 20 46 75 6c 6c 3a 20 20 7b 7b     |#.... Full:  {{
    23e0:	7b 20 7b 7b 7b 20 7b 7b 7b 20 00 8e 23 00 00 00     { {{{ {{{ ..#...
    23f0:	00 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20     .               
    2400:	20 20 20 20 20 00 00 00 00 00 00 00                      .......

0000240c <Menu_ADC_Cali>:
    240c:	a0 23 04 03 00 00 00 00 00 00 00 00 00 00 00 00     .#..............
    241c:	00 00 00 00                                         ....

00002420 <ADC_Rt_Str>:
    2420:	52 65 73 65 74 00                                   Reset.

00002426 <ADC_I1_Str>:
    2426:	49 6e 69 74 69 61 6c 69 73 61 74 00                 Initialisat.

00002432 <ADC_C1_Str>:
    2432:	43 61 6c 69 62 72 61 74 69 6f 6e 00                 Calibration.

0000243e <ADC_Re_Str>:
    243e:	52 65 61 64 00                                      Read.

00002443 <ADC_Of_Str>:
    2443:	4f 66 66 00                                         Off.

00002447 <ADC_Tbl>:
    2447:	20 24 26 24 32 24 3e 24 43 24                        $&$2$>$C$

00002451 <F_Therm1>:
    2451:	09 43 06 ec 08 01                                   .C....

00002457 <F_Therm2>:
    2457:	09 45 06 ec 08 01                                   .E....

0000245d <F_Therm3>:
    245d:	09 47 06 ec 08 01                                   .G....

00002463 <F_Therm4>:
    2463:	09 49 06 ec 08 01                                   .I....

00002469 <F_Therm5>:
    2469:	09 4b 06 ec 08 01                                   .K....

0000246f <F_Therm6>:
    246f:	09 4d 06 ec 08 01                                   .M....

00002475 <F_Thermis1>:
    2475:	1e 17 01 00 00 00 00 07 00 00 00 00 00 20 09 00     ............. ..

00002485 <F_Thermis2>:
    2485:	1e 18 01 00 00 00 00 07 00 00 00 00 00 20 09 00     ............. ..

00002495 <F_Thermis3>:
    2495:	1e 19 01 00 00 00 00 07 00 00 00 00 00 20 09 00     ............. ..

000024a5 <F_Thermis4>:
    24a5:	1e 1a 01 00 00 00 00 07 00 00 00 00 00 20 09 00     ............. ..

000024b5 <F_Thermis5>:
    24b5:	1e 1b 01 00 00 00 00 07 00 00 00 00 00 20 09 00     ............. ..

000024c5 <F_Thermis6>:
    24c5:	1e 1c 01 00 00 00 00 07 00 00 00 00 00 20 09 00     ............. ..

000024d5 <F_ThermisD1>:
    24d5:	03 1d 01 80 ff ff ff 7f 00 00 00 00 00 00 00 01     ................

000024e5 <F_ThermisD2>:
    24e5:	03 20 01 80 ff ff ff 7f 00 00 00 00 00 00 00 01     . ..............

000024f5 <F_ThermisD3>:
    24f5:	03 23 01 80 ff ff ff 7f 00 00 00 00 00 00 00 01     .#..............

00002505 <F_ThermisD4>:
    2505:	03 26 01 80 ff ff ff 7f 00 00 00 00 00 00 00 01     .&..............

00002515 <F_ThermisD5>:
    2515:	03 29 01 80 ff ff ff 7f 00 00 00 00 00 00 00 01     .)..............

00002525 <F_ThermisD6>:
    2525:	03 2c 01 80 ff ff ff 7f 00 00 00 00 00 00 00 01     .,..............

00002535 <F_ThermisA1>:
    2535:	08 1e 01 84 03 00 00 4c 04 00 00 00 00 00 00 03     .......L........

00002545 <F_ThermisA2>:
    2545:	08 21 01 84 03 00 00 4c 04 00 00 00 00 00 00 03     .!.....L........

00002555 <F_ThermisA3>:
    2555:	08 24 01 84 03 00 00 4c 04 00 00 00 00 00 00 03     .$.....L........

00002565 <F_ThermisA4>:
    2565:	08 27 01 84 03 00 00 4c 04 00 00 00 00 00 00 03     .'.....L........

00002575 <F_ThermisA5>:
    2575:	08 2a 01 84 03 00 00 4c 04 00 00 00 00 00 00 03     .*.....L........

00002585 <F_ThermisA6>:
    2585:	08 2d 01 84 03 00 00 4c 04 00 00 00 00 00 00 03     .-.....L........

00002595 <ListTherm1>:
    2595:	20 ca e0 ed e0 eb 20 4e 31 3a 20 7b 7b 7b 7b 7b      ..... N1: {{{{{
    25a5:	7b 7b 7c 43 00 51 24 00 00 00 00 20 d2 e5 f0 ec     {{|C.Q$.... ....
    25b5:	ee e4 e0 f2 f7 e8 ea 3a 20 7d 7d 7d 7d 7d 7d 00     .......: }}}}}}.
    25c5:	00 00 75 24 00 00 20 d1 e4 e2 e8 e3 3a 20 20 20     ..u$.. .....:   
    25d5:	20 20 20 7d 7d 7d 7d 7d 7c 43 00 00 00 d5 24 00        }}}}}|C....$.
    25e5:	00 20 ca ee fd f4 f4 e8 f6 e8 e5 ed f2 3a 20 20     . ...........:  
    25f5:	7d 7d 7d 7d 7d 00 00 00 35 25 00 00                 }}}}}...5%..

00002601 <MenuTherm1>:
    2601:	95 25 04 01 00 00 00 00 00 00 00 00 00 00 00 00     .%..............
    2611:	00 00 00 00                                         ....

00002615 <ListTherm2>:
    2615:	20 ca e0 ed e0 eb 20 4e 32 3a 20 7b 7b 7b 7b 7b      ..... N2: {{{{{
    2625:	7b 7b 7c 43 00 57 24 00 00 00 00 20 d2 e5 f0 ec     {{|C.W$.... ....
    2635:	ee e4 e0 f2 f7 e8 ea 3a 20 7d 7d 7d 7d 7d 7d 00     .......: }}}}}}.
    2645:	00 00 85 24 00 00 20 d1 e4 e2 e8 e3 3a 20 20 20     ...$.. .....:   
    2655:	20 20 20 7d 7d 7d 7d 7d 7c 43 00 00 00 e5 24 00        }}}}}|C....$.
    2665:	00 20 ca ee fd f4 f4 e8 f6 e8 e5 ed f2 3a 20 20     . ...........:  
    2675:	7d 7d 7d 7d 7d 00 00 00 45 25 00 00                 }}}}}...E%..

00002681 <MenuTherm2>:
    2681:	15 26 04 01 00 00 00 00 00 00 00 00 00 00 00 00     .&..............
    2691:	00 00 00 00                                         ....

00002695 <ListTherm3>:
    2695:	20 ca e0 ed e0 eb 20 4e 33 3a 20 7b 7b 7b 7b 7b      ..... N3: {{{{{
    26a5:	7b 7b 7c 43 00 5d 24 00 00 00 00 20 d2 e5 f0 ec     {{|C.]$.... ....
    26b5:	ee e4 e0 f2 f7 e8 ea 3a 20 7d 7d 7d 7d 7d 7d 00     .......: }}}}}}.
    26c5:	00 00 95 24 00 00 20 d1 e4 e2 e8 e3 3a 20 20 20     ...$.. .....:   
    26d5:	20 20 20 7d 7d 7d 7d 7d 7c 43 00 00 00 f5 24 00        }}}}}|C....$.
    26e5:	00 20 ca ee fd f4 f4 e8 f6 e8 e5 ed f2 3a 20 20     . ...........:  
    26f5:	7d 7d 7d 7d 7d 00 00 00 55 25 00 00                 }}}}}...U%..

00002701 <MenuTherm3>:
    2701:	95 26 04 01 00 00 00 00 00 00 00 00 00 00 00 00     .&..............
    2711:	00 00 00 00                                         ....

00002715 <ListTherm4>:
    2715:	20 ca e0 ed e0 eb 20 4e 34 3a 20 7b 7b 7b 7b 7b      ..... N4: {{{{{
    2725:	7b 7b 7c 43 00 63 24 00 00 00 00 20 d2 e5 f0 ec     {{|C.c$.... ....
    2735:	ee e4 e0 f2 f7 e8 ea 3a 20 7d 7d 7d 7d 7d 7d 00     .......: }}}}}}.
    2745:	00 00 a5 24 00 00 20 d1 e4 e2 e8 e3 3a 20 20 20     ...$.. .....:   
    2755:	20 20 20 7d 7d 7d 7d 7d 7c 43 00 00 00 05 25 00        }}}}}|C....%.
    2765:	00 20 ca ee fd f4 f4 e8 f6 e8 e5 ed f2 3a 20 20     . ...........:  
    2775:	7d 7d 7d 7d 7d 00 00 00 65 25 00 00                 }}}}}...e%..

00002781 <MenuTherm4>:
    2781:	15 27 04 01 00 00 00 00 00 00 00 00 00 00 00 00     .'..............
    2791:	00 00 00 00                                         ....

00002795 <ListTherm5>:
    2795:	20 ca e0 ed e0 eb 20 4e 35 3a 20 7b 7b 7b 7b 7b      ..... N5: {{{{{
    27a5:	7b 7b 7c 43 00 69 24 00 00 00 00 20 d2 e5 f0 ec     {{|C.i$.... ....
    27b5:	ee e4 e0 f2 f7 e8 ea 3a 20 7d 7d 7d 7d 7d 7d 00     .......: }}}}}}.
    27c5:	00 00 b5 24 00 00 20 d1 e4 e2 e8 e3 3a 20 20 20     ...$.. .....:   
    27d5:	20 20 20 7d 7d 7d 7d 7d 7c 43 00 00 00 15 25 00        }}}}}|C....%.
    27e5:	00 20 ca ee fd f4 f4 e8 f6 e8 e5 ed f2 3a 20 20     . ...........:  
    27f5:	7d 7d 7d 7d 7d 00 00 00 75 25 00 00                 }}}}}...u%..

00002801 <MenuTherm5>:
    2801:	95 27 04 01 00 00 00 00 00 00 00 00 00 00 00 00     .'..............
    2811:	00 00 00 00                                         ....

00002815 <ListTherm6>:
    2815:	20 ca e0 ed e0 eb 20 4e 36 3a 20 7b 7b 7b 7b 7b      ..... N6: {{{{{
    2825:	7b 7b 7c 43 00 6f 24 00 00 00 00 20 d2 e5 f0 ec     {{|C.o$.... ....
    2835:	ee e4 e0 f2 f7 e8 ea 3a 20 7d 7d 7d 7d 7d 7d 00     .......: }}}}}}.
    2845:	00 00 c5 24 00 00 20 d1 e4 e2 e8 e3 3a 20 20 20     ...$.. .....:   
    2855:	20 20 20 7d 7d 7d 7d 7d 7c 43 00 00 00 25 25 00        }}}}}|C...%%.
    2865:	00 20 ca ee fd f4 f4 e8 f6 e8 e5 ed f2 3a 20 20     . ...........:  
    2875:	7d 7d 7d 7d 7d 00 00 00 85 25 00 00                 }}}}}....%..

00002881 <MenuTherm6>:
    2881:	15 28 04 01 00 00 00 00 00 00 00 00 00 00 00 00     .(..............
    2891:	00 00 00 00                                         ....

00002895 <List_Therm>:
    2895:	20 ca e0 ed e0 eb 20 4e 31 3a 20 7b 7b 7b 7b 7b      ..... N1: {{{{{
    28a5:	7b 7b 7c 43 00 51 24 00 00 01 26 20 ca e0 ed e0     {{|C.Q$...& ....
    28b5:	eb 20 4e 32 3a 20 7b 7b 7b 7b 7b 7b 7b 7c 43 00     . N2: {{{{{{{|C.
    28c5:	57 24 00 00 81 26 20 ca e0 ed e0 eb 20 4e 33 3a     W$...& ..... N3:
    28d5:	20 7b 7b 7b 7b 7b 7b 7b 7c 43 00 5d 24 00 00 01      {{{{{{{|C.]$...
    28e5:	27 20 ca e0 ed e0 eb 20 4e 34 3a 20 7b 7b 7b 7b     ' ..... N4: {{{{
    28f5:	7b 7b 7b 7c 43 00 63 24 00 00 81 27 20 ca e0 ed     {{{|C.c$...' ...
    2905:	e0 eb 20 4e 35 3a 20 7b 7b 7b 7b 7b 7b 7b 7c 43     .. N5: {{{{{{{|C
    2915:	00 69 24 00 00 01 28 20 ca e0 ed e0 eb 20 4e 36     .i$...( ..... N6
    2925:	3a 20 7b 7b 7b 7b 7b 7b 7b 7c 43 00 6f 24 00 00     : {{{{{{{|C.o$..
    2935:	81 28                                               .(

00002937 <MenuTherm>:
    2937:	95 28 06 00 00 00 00 00 00 00 00 00 00 00 00 00     .(..............
    2947:	00 00 00 00                                         ....

0000294b <MB_Master_List>:
    294b:	00 00 00                                            ...

0000294e <MenuModem>:
    294e:	81 0f 22 00 b3 29 00 00 00 00 00 00 00 00 00 00     .."..)..........
    295e:	00 00 00 00                                         ....

00002962 <Menu0List>:
    2962:	20 2d 47 53 4d 2d f1 e8 e3 ed e0 eb e8 e7 e0 f2      -GSM-..........
    2972:	ee f0 2d 20 00 00 00 00 00 b3 29 20 d1 eb f3 e6     ..- ......) ....
    2982:	e5 e1 ed ee e5 20 20 20 20 20 20 20 20 20 20 00     .....          .
    2992:	00 00 00 00 1b 1a 20 cc ee e4 e5 ec 20 20 20 20     ...... .....    
    29a2:	20 20 20 20 20 20 20 20 20 20 00 00 00 00 00 4e               .....N
    29b2:	29                                                  )

000029b3 <Menu0>:
    29b3:	62 29 03 00 b3 29 00 00 00 00 00 00 00 00 00 00     b)...)..........
    29c3:	00 00 00 00                                         ....

000029c7 <KeyAct.9476>:
    29c7:	00 00 70 40 79 40 65 57 bd 52 0f 5b b4 5a           ..p@y@eW.R.[.Z

000029d5 <MaxThermType>:
    29d5:	07 02                                               ..

000029d7 <TerLimType>:
    29d7:	c3 06 e3 06                                         ....

000029db <TSM100Tbl>:
    29db:	00 00 e1 f6 91 08 30 f8 0e 28 18 fc a2 37 0c fe     ......0..(...7..
    29eb:	ea 46 00 00 49 65 e8 03 a6 83 d0 07 ff ff f4 17     .F..Ie..........

000029fb <TSM50Tbl>:
    29fb:	00 00 df f6 46 04 30 f8 13 0c 24 fa fe 13 18 fc     ....F.0...$.....
    2a0b:	c6 1b 0c fe 6b 23 00 00 03 2b f4 01 9a 32 e8 03     ....k#...+...2..
    2a1b:	30 3a dc 05 c9 41 d0 07 ff ff bd 38                 0:...A.....8

00002a27 <TSP100Tbl>:
    2a27:	00 00 f6 f5 c2 38 0c fe e2 46 00 00 b6 62 e8 03     .....8...F...b..
    2a37:	96 7d d0 07 ae 97 b8 0b ea b0 a0 0f 54 c9 88 13     .}..........T...
    2a47:	e2 e0 70 17 ff ff 97 1e                             ..p.....

00002a4f <TSP50Tbl>:
    2a4f:	00 00 1f f6 5f 1c 0c fe 56 31 e8 03 d0 3e d0 07     ...._...V1...>..
    2a5f:	d2 4b b8 0b 70 58 a0 0f aa 64 88 13 6c 70 70 17     .K..pX...d..lpp.
    2a6f:	ff ff 0e 47                                         ...G

00002a73 <Pt100Tbl>:
    2a73:	00 00 20 f6 fe 38 0c fe 48 62 e8 03 c4 7c d0 07     .. ..8..Hb...|..
    2a83:	6e 96 b8 0b 50 af a0 0f 56 c7 88 13 94 de 70 17     n...P...V.....p.
    2a93:	f6 f4 58 1b ff ff 8b 1f                             ..X.....

00002a9b <Gr21Tbl>:
    2a9b:	00 00 1e f6 1c 1a 0c fe 64 2d e8 03 c6 39 d0 07     ........d-...9..
    2aab:	c4 45 b8 0b 68 51 a0 0f 9e 5c 88 13 7a 67 70 17     .E..hQ...\..zgp.
    2abb:	ff ff ce 4f                                         ...O

00002abf <Gr23Tbl>:
    2abf:	00 00 d5 f6 7d 1d 0c fe 8b 25 00 00 8f 2d f4 01     ....}....%...-..
    2acf:	92 35 e8 03 95 3d dc 05 63 42 08 07 ff ff 3e 35     .5...=..cB....>5

00002adf <TC_B_Tbl>:
    2adf:	00 00 90 01 99 01 dc 05 7c 07 b8 0b 8e 15 88 13     ........|.......
    2aef:	1b 1f 70 17 30 2a 58 1b c4 36 40 1f b6 44 28 23     ..p.0*X..6@..D(#
    2aff:	f2 53 10 27 5a 64 f8 2a d0 75 e0 2e 40 88 c8 32     .S.'Zd.*.u..@..2
    2b0f:	78 9b b0 36 50 af 98 3a 82 c3 80 3e d2 d7 68 42     x..6P..:...>..hB
    2b1f:	ff ff 38 4a                                         ..8J

00002b23 <Mux.8925>:
    2b23:	06 00 07 00 00 08 01 08 02 08 03 08 04 08 05 08     ................

00002b33 <M.8850>:
    2b33:	00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f     ................

00002b43 <DI_M>:
    2b43:	07 01 08 01 06 01 40 00 07 01 08 01 06 01 80 00     ......@.........
    2b53:	04 01 05 01 03 01 80 00 21 00 22 00 20 00 01 00     ........!.". ...
    2b63:	21 00 22 00 20 00 02 00 21 00 22 00 20 00 04 00     !.". ...!.". ...
    2b73:	21 00 22 00 20 00 08 00 21 00 22 00 20 00 10 00     !.". ...!.". ...
    2b83:	21 00 22 00 20 00 20 00 21 00 22 00 20 00 40 00     !.". . .!.". .@.
    2b93:	21 00 22 00 20 00 80 00 33 00 34 00 32 00 04 00     !.". ...3.4.2...
    2ba3:	04 01 05 01 03 01 40 00 04 01 05 01 03 01 20 00     ......@....... .
    2bb3:	04 01 05 01 03 01 10 00 04 01 05 01 03 01 08 00     ................
    2bc3:	04 01 05 01 03 01 02 01 04 01 05 01 03 01 04 01     ................

00002bd3 <__c.6217>:
    2bd3:	2b 50 44 50 00                                      +PDP.

00002bd8 <__c.6215>:
    2bd8:	43 4c 4f 53 00                                      CLOS.

00002bdd <__c.6213>:
    2bdd:	50 4f 53 54 00                                      POST.

00002be2 <__c.6210>:
    2be2:	47 45 54 20 00                                      GET .

00002be7 <__c.6208>:
    2be7:	0d 0a 00                                            ...

00002bea <__c.6204>:
    2bea:	2b 43 53 51 3a 20 25 68 68 75 2c 25 68 68 75 00     +CSQ: %hhu,%hhu.

00002bfa <__c.6157>:
    2bfa:	25 68 68 75 2c 20 43 4c 4f 53 45 44 00              %hhu, CLOSED.

00002c07 <__c.6151>:
    2c07:	4f 4b 00                                            OK.

00002c0a <__c.6144>:
    2c0a:	25 68 68 75 20 25 68 68 75 20 25 68 68 75 20 25     %hhu %hhu %hhu %
    2c1a:	68 68 75 00                                         hhu.

00002c1e <__c.6117>:
    2c1e:	4e 4f 20 43 41 52 52 49 45 52 00                    NO CARRIER.

00002c29 <__c.6115>:
    2c29:	42 55 53 59 00                                      BUSY.

00002c2e <__c.6113>:
    2c2e:	4f 4b 00                                            OK.

00002c31 <__c.6110>:
    2c31:	2b 43 4c 43 43 3a 20 31 2c 30 2c 36 2c 00           +CLCC: 1,0,6,.

00002c3f <__c.6107>:
    2c3f:	41 54 48 0d 00                                      ATH..

00002c44 <__c.6102>:
    2c44:	41 54 2b 43 52 45 43 3d 34 2c 22 43 3a 5c 55 73     AT+CREC=4,"C:\Us
    2c54:	65 72 5c 4e 6f 74 43 6f 6e 66 69 72 6d 2e 61 6d     er\NotConfirm.am
    2c64:	72 22 2c 30 2c 31 30 30 0d 00                       r",0,100..

00002c6e <__c.6097>:
    2c6e:	41 54 2b 43 52 45 43 3d 34 2c 22 43 3a 5c 55 73     AT+CREC=4,"C:\Us
    2c7e:	65 72 5c 43 6f 6e 66 69 72 6d 2e 61 6d 72 22 2c     er\Confirm.amr",
    2c8e:	30 2c 31 30 30 0d 00                                0,100..

00002c95 <__c.6094>:
    2c95:	2b 43 52 45 43 3a 20 30 00                          +CREC: 0.

00002c9e <__c.6091>:
    2c9e:	41 54 2b 43 52 45 43 3d 35 0d 00                    AT+CREC=5..

00002ca9 <__c.6088>:
    2ca9:	2b 43 4c 43 43 3a 20 33 2c 30 2c 36 00              +CLCC: 3,0,6.

00002cb6 <__c.6086>:
    2cb6:	2b 43 4c 43 43 3a 20 32 2c 30 2c 36 00              +CLCC: 2,0,6.

00002cc3 <__c.6084>:
    2cc3:	2b 43 4c 43 43 3a 20 31 2c 30 2c 36 00              +CLCC: 1,0,6.

00002cd0 <__c.6082>:
    2cd0:	2b 44 54 4d 46 3a 20 31 00                          +DTMF: 1.

00002cd9 <__c.6079>:
    2cd9:	2b 43 52 45 43 3a 20 30 00                          +CREC: 0.

00002ce2 <__c.6075>:
    2ce2:	41 54 2b 43 52 45 43 3d 34 2c 22 43 3a 5c 55 73     AT+CREC=4,"C:\Us
    2cf2:	65 72 5c 43 6f 6e 66 69 72 6d 52 65 71 75 65 73     er\ConfirmReques
    2d02:	74 2e 61 6d 72 22 2c 30 2c 31 30 30 0d 00           t.amr",0,100..

00002d10 <__c.6072>:
    2d10:	2b 43 52 45 43 3a 20 30 00                          +CREC: 0.

00002d19 <__c.6068>:
    2d19:	2e 61 6d 72 22 2c 30 2c 31 30 30 0d 00              .amr",0,100..

00002d26 <__c.6066>:
    2d26:	41 54 2b 43 52 45 43 3d 34 2c 22 43 3a 5c 55 73     AT+CREC=4,"C:\Us
    2d36:	65 72 5c 41 6c 61 72 6d 00                          er\Alarm.

00002d3f <__c.6063>:
    2d3f:	2b 43 4c 43 43 3a 20 31 2c 30 2c 36 2c 00           +CLCC: 1,0,6,.

00002d4d <__c.6061>:
    2d4d:	2b 43 4c 43 43 3a 20 31 2c 30 2c 36 2c 00           +CLCC: 1,0,6,.

00002d5b <__c.6059>:
    2d5b:	2b 43 4c 43 43 3a 20 31 2c 30 2c 36 2c 00           +CLCC: 1,0,6,.

00002d69 <__c.6057>:
    2d69:	2b 43 4c 43 43 3a 20 31 2c 30 2c 30 2c 00           +CLCC: 1,0,0,.

00002d77 <__c.6055>:
    2d77:	2b 43 4c 43 43 3a 20 31 2c 30 2c 30 2c 00           +CLCC: 1,0,0,.

00002d85 <__c.6053>:
    2d85:	2b 43 4c 43 43 3a 20 31 2c 30 2c 30 2c 00           +CLCC: 1,0,0,.

00002d93 <__c.6050>:
    2d93:	2b 43 4c 43 43 3a 20 33 2c 30 2c 33 2c 00           +CLCC: 3,0,3,.

00002da1 <__c.6048>:
    2da1:	2b 43 4c 43 43 3a 20 32 2c 30 2c 33 2c 00           +CLCC: 2,0,3,.

00002daf <__c.6046>:
    2daf:	2b 43 4c 43 43 3a 20 31 2c 30 2c 33 2c 00           +CLCC: 1,0,3,.

00002dbd <__c.6044>:
    2dbd:	2b 43 4c 43 43 3a 20 33 2c 30 2c 36 2c 00           +CLCC: 3,0,6,.

00002dcb <__c.6042>:
    2dcb:	2b 43 4c 43 43 3a 20 32 2c 30 2c 36 2c 00           +CLCC: 2,0,6,.

00002dd9 <__c.6040>:
    2dd9:	2b 43 4c 43 43 3a 20 31 2c 30 2c 36 2c 00           +CLCC: 1,0,6,.

00002de7 <__c.6037>:
    2de7:	2b 43 4c 43 43 3a 20 33 2c 30 2c 32 2c 00           +CLCC: 3,0,2,.

00002df5 <__c.6035>:
    2df5:	2b 43 4c 43 43 3a 20 32 2c 30 2c 32 2c 00           +CLCC: 2,0,2,.

00002e03 <__c.6033>:
    2e03:	2b 43 4c 43 43 3a 20 31 2c 30 2c 32 2c 00           +CLCC: 1,0,2,.

00002e11 <__c.5999>:
    2e11:	2b 43 4c 43 43 3a 20 33 2c 30 2c 36 00              +CLCC: 3,0,6.

00002e1e <__c.5997>:
    2e1e:	2b 43 4c 43 43 3a 20 32 2c 30 2c 36 00              +CLCC: 2,0,6.

00002e2b <__c.5995>:
    2e2b:	2b 43 4c 43 43 3a 20 31 2c 30 2c 36 00              +CLCC: 1,0,6.

00002e38 <__c.5993>:
    2e38:	2b 44 54 4d 46 3a 20 31 00                          +DTMF: 1.

00002e41 <MB_Port>:
    2e41:	ce 00 c8 00 c9 00 ca 00 cd 00 cc 00 69 1e 6f 1e     ............i.o.
    2e51:	73 1e 74 1e                                         s.t.

00002e55 <MB_Role>:
	...

00002e56 <MB_Timer>:
    2e56:	46 00 47 00 6e 28 b2 00 b3 00 78 28 a4 00 a8 00     F.G.n(....x(....
    2e66:	84 28                                               .(

00002e68 <CGRAM_LCD>:
    2e68:	00 04 06 1f 06 04 00 00 06 09 09 06 00 00 00 00     ................
    2e78:	00 08 08 0e 0f 1f 0f 06 00 00 0e 11 1c 11 0e 00     ................
    2e88:	0e 11 10 1c 10 11 0e 00 0a 00 0c 04 04 04 0e 00     ................
    2e98:	0a 0e 04 04 04 04 0e 00 00 00 00 00 00 00 00 00     ................

00002ea8 <Win2LCD>:
    2ea8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    2eb8:	00 02 ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    2ec8:	20 21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f      !"#$%&'()*+,-./
    2ed8:	30 31 32 33 34 35 36 37 38 39 3a 3b 3c 3d 3e 3f     0123456789:;<=>?
    2ee8:	40 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e 4f     @ABCDEFGHIJKLMNO
    2ef8:	50 51 52 53 54 55 56 57 58 59 5a 5b 5c 5d 5e 5f     PQRSTUVWXYZ[\]^_
    2f08:	60 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e 6f     `abcdefghijklmno
    2f18:	70 71 72 73 74 75 76 77 78 79 7a 7b 01 7d e9 7f     pqrstuvwxyz{.}..
    2f28:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    2f38:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    2f48:	ff ff ff ff ff ff ff d9 a2 ff 04 ff ff ff ff 06     ................
    2f58:	ff ff 49 69 ff ff ff da b5 ff 03 ff ff ff ff 05     ..Ii............
    2f68:	41 a0 42 a1 e0 45 a3 a4 a5 a6 4b a7 4d 48 4f a8     A.B..E....K.MHO.
    2f78:	50 43 54 a9 aa 58 e1 ab ac e2 ad ae 62 af b0 b1     PCT..X......b...
    2f88:	61 b2 b3 b4 e3 65 b6 b7 b8 b9 ba bb bc bd 6f be     a....e........o.
    2f98:	70 63 bf 79 e4 78 e5 c0 c1 e6 c2 c3 c4 c5 c6 c7     pc.y.x..........

00002fa8 <LineAddr.3690>:
    2fa8:	80 c0 94 d4                                         ....

00002fac <Mux>:
    2fac:	00 01 02 03 04 05 06                                .......

00002fb3 <aCRCLo.1496>:
    2fb3:	00 c0 c1 01 c3 03 02 c2 c6 06 07 c7 05 c5 c4 04     ................
    2fc3:	cc 0c 0d cd 0f cf ce 0e 0a ca cb 0b c9 09 08 c8     ................
    2fd3:	d8 18 19 d9 1b db da 1a 1e de df 1f dd 1d 1c dc     ................
    2fe3:	14 d4 d5 15 d7 17 16 d6 d2 12 13 d3 11 d1 d0 10     ................
    2ff3:	f0 30 31 f1 33 f3 f2 32 36 f6 f7 37 f5 35 34 f4     .01.3..26..7.54.
    3003:	3c fc fd 3d ff 3f 3e fe fa 3a 3b fb 39 f9 f8 38     <..=.?>..:;.9..8
    3013:	28 e8 e9 29 eb 2b 2a ea ee 2e 2f ef 2d ed ec 2c     (..).+*.../.-..,
    3023:	e4 24 25 e5 27 e7 e6 26 22 e2 e3 23 e1 21 20 e0     .$%.'..&"..#.! .
    3033:	a0 60 61 a1 63 a3 a2 62 66 a6 a7 67 a5 65 64 a4     .`a.c..bf..g.ed.
    3043:	6c ac ad 6d af 6f 6e ae aa 6a 6b ab 69 a9 a8 68     l..m.on..jk.i..h
    3053:	78 b8 b9 79 bb 7b 7a ba be 7e 7f bf 7d bd bc 7c     x..y.{z..~..}..|
    3063:	b4 74 75 b5 77 b7 b6 76 72 b2 b3 73 b1 71 70 b0     .tu.w..vr..s.qp.
    3073:	50 90 91 51 93 53 52 92 96 56 57 97 55 95 94 54     P..Q.SR..VW.U..T
    3083:	9c 5c 5d 9d 5f 9f 9e 5e 5a 9a 9b 5b 99 59 58 98     .\]._..^Z..[.YX.
    3093:	88 48 49 89 4b 8b 8a 4a 4e 8e 8f 4f 8d 4d 4c 8c     .HI.K..JN..O.ML.
    30a3:	44 84 85 45 87 47 46 86 82 42 43 83 41 81 80 40     D..E.GF..BC.A..@

000030b3 <aCRCHi.1495>:
    30b3:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    30c3:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    30d3:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    30e3:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    30f3:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    3103:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    3113:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    3123:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    3133:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    3143:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    3153:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    3163:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    3173:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    3183:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    3193:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    31a3:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    31b3:	00 40 7a 10 f3 5a 00 a0 72 4e 18 09 00 10 a5 d4     .@z..Z..rN......
    31c3:	e8 00 00 e8 76 48 17 00 00 e4 0b 54 02 00 00 ca     ....vH.....T....
    31d3:	9a 3b 00 00 00 e1 f5 05 00 00 80 96 98 00 00 00     .;..............
    31e3:	40 42 0f 00 00 00 a0 86 01 00 00 00 10 27 00 00     @B...........'..
    31f3:	00 00 e8 03 00 00 00 00 64 00 00 00 00 00 0a 00     ........d.......
    3203:	00 00 00 00 01 00 00 00 00 00 2c 76 d8 88 dc 67     ..........,v...g
    3213:	4f 08 23 df c1 df ae 59 e1 b1 b7 96 e5 e3 e4 53     O.#....Y.......S
    3223:	c6 3a e6 51 99 76 96 e8 e6 c2 84 26 eb 89 8c 9b     .:.Q.v.....&....
    3233:	62 ed 40 7c 6f fc ef bc 9c 9f 40 f2 ba a5 6f a5     b.@|o.....@...o.
    3243:	f4 90 05 5a 2a f7 5c 93 6b 6c f9 67 6d c1 1b fc     ...Z*.\.kl.gm...
    3253:	e0 e4 0d 47 fe f5 20 e6 b5 00 d0 ed 90 2e 03 00     ...G.. .........
    3263:	94 35 77 05 00 80 84 1e 08 00 00 20 4e 0a 00 00     .5w........ N...
    3273:	00 c8 0c 33 33 33 33 0f 98 6e 12 83 11 41 ef 8d     ...3333..n...A..
    3283:	21 14 89 3b e6 55 16 cf fe e6 db 18 d1 84 4b 38     !..;.U........K8
    3293:	1b f7 7c 1d 90 1d a4 bb e4 24 20 32 84 72 5e 22     ..|......$ 2.r^"
    32a3:	81 00 c9 f1 24 ec a1 e5 3d 27 00                    ....$...='.

000032ae <__ctors_end>:
    32ae:	11 24       	eor	r1, r1
    32b0:	1f be       	out	0x3f, r1	; 63
    32b2:	cf ef       	ldi	r28, 0xFF	; 255
    32b4:	d1 e2       	ldi	r29, 0x21	; 33
    32b6:	de bf       	out	0x3e, r29	; 62
    32b8:	cd bf       	out	0x3d, r28	; 61
    32ba:	00 e0       	ldi	r16, 0x00	; 0
    32bc:	0c bf       	out	0x3c, r16	; 60

000032be <__do_copy_data>:
    32be:	12 e0       	ldi	r17, 0x02	; 2
    32c0:	a0 e0       	ldi	r26, 0x00	; 0
    32c2:	b2 e0       	ldi	r27, 0x02	; 2
    32c4:	e8 e6       	ldi	r30, 0x68	; 104
    32c6:	f7 e0       	ldi	r31, 0x07	; 7
    32c8:	01 e0       	ldi	r16, 0x01	; 1
    32ca:	0b bf       	out	0x3b, r16	; 59
    32cc:	02 c0       	rjmp	.+4      	; 0x32d2 <__do_copy_data+0x14>
    32ce:	07 90       	elpm	r0, Z+
    32d0:	0d 92       	st	X+, r0
    32d2:	aa 3d       	cpi	r26, 0xDA	; 218
    32d4:	b1 07       	cpc	r27, r17
    32d6:	d9 f7       	brne	.-10     	; 0x32ce <__do_copy_data+0x10>

000032d8 <__do_clear_bss>:
    32d8:	1c e0       	ldi	r17, 0x0C	; 12
    32da:	aa ed       	ldi	r26, 0xDA	; 218
    32dc:	b2 e0       	ldi	r27, 0x02	; 2
    32de:	01 c0       	rjmp	.+2      	; 0x32e2 <.do_clear_bss_start>

000032e0 <.do_clear_bss_loop>:
    32e0:	1d 92       	st	X+, r1

000032e2 <.do_clear_bss_start>:
    32e2:	ac 32       	cpi	r26, 0x2C	; 44
    32e4:	b1 07       	cpc	r27, r17
    32e6:	e1 f7       	brne	.-8      	; 0x32e0 <.do_clear_bss_loop>
    32e8:	0e 94 ef 74 	call	0xe9de	; 0xe9de <main>
    32ec:	0c 94 c7 7e 	jmp	0xfd8e	; 0xfd8e <exit>

000032f0 <__bad_interrupt>:
    32f0:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000032f4 <rrb>:
#include <stdint.h>

// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
rrb(const uint8_t *addr)
{
    32f4:	fc 01       	movw	r30, r24
	return *addr;
}
    32f6:	80 81       	ld	r24, Z
    32f8:	08 95       	ret

000032fa <prb>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    32fa:	fc 01       	movw	r30, r24
    32fc:	84 91       	lpm	r24, Z+
}
    32fe:	08 95       	ret

00003300 <prw>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    3300:	fc 01       	movw	r30, r24
    3302:	25 91       	lpm	r18, Z+
    3304:	34 91       	lpm	r19, Z+
}
    3306:	c9 01       	movw	r24, r18
    3308:	08 95       	ret

0000330a <prd>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    330a:	fc 01       	movw	r30, r24
    330c:	25 91       	lpm	r18, Z+
    330e:	35 91       	lpm	r19, Z+
    3310:	45 91       	lpm	r20, Z+
    3312:	54 91       	lpm	r21, Z+
}
    3314:	b9 01       	movw	r22, r18
    3316:	ca 01       	movw	r24, r20
    3318:	08 95       	ret

0000331a <prb_f>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#if FLASHEND>0xFFFF
uint8_t
prb_f(const prog_uint8_t *addr)
{
	return pgm_read_byte_far((uint16_t)addr+0x10000);
    331a:	a0 e0       	ldi	r26, 0x00	; 0
    331c:	b0 e0       	ldi	r27, 0x00	; 0
    331e:	80 50       	subi	r24, 0x00	; 0
    3320:	90 40       	sbci	r25, 0x00	; 0
    3322:	af 4f       	sbci	r26, 0xFF	; 255
    3324:	bf 4f       	sbci	r27, 0xFF	; 255
}
    3326:	ab bf       	out	0x3b, r26	; 59
    3328:	fc 01       	movw	r30, r24
    332a:	87 91       	elpm	r24, Z+
    332c:	08 95       	ret

0000332e <prc>:

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    332e:	fc 01       	movw	r30, r24
    3330:	84 91       	lpm	r24, Z+
}
    3332:	08 95       	ret

00003334 <prp>:

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    3334:	fc 01       	movw	r30, r24
    3336:	25 91       	lpm	r18, Z+
    3338:	34 91       	lpm	r19, Z+
}
    333a:	c9 01       	movw	r24, r18
    333c:	08 95       	ret

0000333e <CRC_Seed>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
CRC_Seed(uint8_t (*GetByte)(const uint8_t*), const uint8_t *Block, uint32_t Sz, uint16_t Seed)
{
    333e:	6f 92       	push	r6
    3340:	7f 92       	push	r7
    3342:	8f 92       	push	r8
    3344:	9f 92       	push	r9
    3346:	af 92       	push	r10
    3348:	bf 92       	push	r11
    334a:	cf 92       	push	r12
    334c:	df 92       	push	r13
    334e:	ef 92       	push	r14
    3350:	ff 92       	push	r15
    3352:	0f 93       	push	r16
    3354:	1f 93       	push	r17
    3356:	cf 93       	push	r28
    3358:	df 93       	push	r29
    335a:	3c 01       	movw	r6, r24
    335c:	eb 01       	movw	r28, r22
    335e:	49 01       	movw	r8, r18
    3360:	5a 01       	movw	r10, r20
    3362:	c1 2e       	mov	r12, r17
		0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54,
		0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98,
		0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
		0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 0x40
	};
	uint8_t CRCHi=Seed>>8, CRCLo=Seed;
    3364:	d0 2e       	mov	r13, r16
	for (uint32_t i=0; i<Sz; i++) {
    3366:	21 15       	cp	r18, r1
    3368:	31 05       	cpc	r19, r1
    336a:	41 05       	cpc	r20, r1
    336c:	51 05       	cpc	r21, r1
    336e:	f9 f0       	breq	.+62     	; 0x33ae <CRC_Seed+0x70>
    3370:	ee 24       	eor	r14, r14
    3372:	ff 24       	eor	r15, r15
    3374:	87 01       	movw	r16, r14
		uint8_t j = CRCLo^GetByte(Block+i);
    3376:	ce 01       	movw	r24, r28
    3378:	8e 0d       	add	r24, r14
    337a:	9f 1d       	adc	r25, r15
    337c:	f3 01       	movw	r30, r6
    337e:	19 95       	eicall
		CRCLo = CRCHi^prb(aCRCHi+j);
    3380:	d8 26       	eor	r13, r24
    3382:	2d 2d       	mov	r18, r13
    3384:	30 e0       	ldi	r19, 0x00	; 0

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    3386:	c9 01       	movw	r24, r18
    3388:	8d 54       	subi	r24, 0x4D	; 77
    338a:	9f 4c       	sbci	r25, 0xCF	; 207
    338c:	fc 01       	movw	r30, r24
    338e:	d4 90       	lpm	r13, Z+
		0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 0x40
	};
	uint8_t CRCHi=Seed>>8, CRCLo=Seed;
	for (uint32_t i=0; i<Sz; i++) {
		uint8_t j = CRCLo^GetByte(Block+i);
		CRCLo = CRCHi^prb(aCRCHi+j);
    3390:	dc 24       	eor	r13, r12

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    3392:	2d 54       	subi	r18, 0x4D	; 77
    3394:	30 4d       	sbci	r19, 0xD0	; 208
    3396:	f9 01       	movw	r30, r18
    3398:	c4 90       	lpm	r12, Z+
		0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98,
		0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
		0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 0x40
	};
	uint8_t CRCHi=Seed>>8, CRCLo=Seed;
	for (uint32_t i=0; i<Sz; i++) {
    339a:	08 94       	sec
    339c:	e1 1c       	adc	r14, r1
    339e:	f1 1c       	adc	r15, r1
    33a0:	01 1d       	adc	r16, r1
    33a2:	11 1d       	adc	r17, r1
    33a4:	e8 14       	cp	r14, r8
    33a6:	f9 04       	cpc	r15, r9
    33a8:	0a 05       	cpc	r16, r10
    33aa:	1b 05       	cpc	r17, r11
    33ac:	20 f3       	brcs	.-56     	; 0x3376 <CRC_Seed+0x38>
    33ae:	9c 2d       	mov	r25, r12
    33b0:	80 e0       	ldi	r24, 0x00	; 0
    33b2:	2d 2d       	mov	r18, r13
    33b4:	30 e0       	ldi	r19, 0x00	; 0
    33b6:	28 2b       	or	r18, r24
    33b8:	39 2b       	or	r19, r25
		uint8_t j = CRCLo^GetByte(Block+i);
		CRCLo = CRCHi^prb(aCRCHi+j);
		CRCHi = prb(aCRCLo+j);
	}
	return CRCHi<<8|CRCLo;
}
    33ba:	c9 01       	movw	r24, r18
    33bc:	df 91       	pop	r29
    33be:	cf 91       	pop	r28
    33c0:	1f 91       	pop	r17
    33c2:	0f 91       	pop	r16
    33c4:	ff 90       	pop	r15
    33c6:	ef 90       	pop	r14
    33c8:	df 90       	pop	r13
    33ca:	cf 90       	pop	r12
    33cc:	bf 90       	pop	r11
    33ce:	af 90       	pop	r10
    33d0:	9f 90       	pop	r9
    33d2:	8f 90       	pop	r8
    33d4:	7f 90       	pop	r7
    33d6:	6f 90       	pop	r6
    33d8:	08 95       	ret

000033da <CRC>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
CRC(uint8_t (*GetByte)(const uint8_t*), const uint8_t *Block, uint32_t Sz)
{
    33da:	0f 93       	push	r16
    33dc:	1f 93       	push	r17
	return CRC_Seed(GetByte, Block, Sz, 0xFFFF);
    33de:	0f ef       	ldi	r16, 0xFF	; 255
    33e0:	1f ef       	ldi	r17, 0xFF	; 255
    33e2:	0e 94 9f 19 	call	0x333e	; 0x333e <CRC_Seed>
}
    33e6:	1f 91       	pop	r17
    33e8:	0f 91       	pop	r16
    33ea:	08 95       	ret

000033ec <CRC_Flash_calc>:

// ~~~~~~~~~~~~~~~~~
static uint16_t
CRC_Flash_calc(void)
{
    33ec:	0f 93       	push	r16
    33ee:	1f 93       	push	r17
	#if FLASHEND<0xFFFF
		return CRC(prb, NULL, (uint32_t)FLASHEND+1);
	#else
		return CRC_Seed(prb_f, NULL, FLASHEND-0xFFFF, CRC(prb, NULL, 0x10000));
    33f0:	8d e7       	ldi	r24, 0x7D	; 125
    33f2:	99 e1       	ldi	r25, 0x19	; 25
    33f4:	60 e0       	ldi	r22, 0x00	; 0
    33f6:	70 e0       	ldi	r23, 0x00	; 0
    33f8:	20 e0       	ldi	r18, 0x00	; 0
    33fa:	30 e0       	ldi	r19, 0x00	; 0
    33fc:	41 e0       	ldi	r20, 0x01	; 1
    33fe:	50 e0       	ldi	r21, 0x00	; 0
    3400:	0e 94 ed 19 	call	0x33da	; 0x33da <CRC>
    3404:	8c 01       	movw	r16, r24
    3406:	8d e8       	ldi	r24, 0x8D	; 141
    3408:	99 e1       	ldi	r25, 0x19	; 25
    340a:	60 e0       	ldi	r22, 0x00	; 0
    340c:	70 e0       	ldi	r23, 0x00	; 0
    340e:	20 e0       	ldi	r18, 0x00	; 0
    3410:	30 e0       	ldi	r19, 0x00	; 0
    3412:	43 e0       	ldi	r20, 0x03	; 3
    3414:	50 e0       	ldi	r21, 0x00	; 0
    3416:	0e 94 9f 19 	call	0x333e	; 0x333e <CRC_Seed>
	#endif
}
    341a:	1f 91       	pop	r17
    341c:	0f 91       	pop	r16
    341e:	08 95       	ret

00003420 <CRC_EEPROM_calc>:

// ~~~~~~~~~~~~~~~~~~
static uint16_t
CRC_EEPROM_calc(void)
{
    3420:	cf 92       	push	r12
    3422:	df 92       	push	r13
    3424:	ef 92       	push	r14
    3426:	ff 92       	push	r15
    3428:	0f 93       	push	r16
    342a:	1f 93       	push	r17
	return
    342c:	99 ec       	ldi	r25, 0xC9	; 201
    342e:	c9 2e       	mov	r12, r25
    3430:	9e e4       	ldi	r25, 0x4E	; 78
    3432:	d9 2e       	mov	r13, r25
    3434:	88 e3       	ldi	r24, 0x38	; 56
    3436:	e8 2e       	mov	r14, r24
    3438:	81 e0       	ldi	r24, 0x01	; 1
    343a:	f8 2e       	mov	r15, r24
    343c:	97 01       	movw	r18, r14
    343e:	40 e0       	ldi	r20, 0x00	; 0
    3440:	50 e0       	ldi	r21, 0x00	; 0
    3442:	c6 01       	movw	r24, r12
    3444:	60 e0       	ldi	r22, 0x00	; 0
    3446:	70 e0       	ldi	r23, 0x00	; 0
    3448:	0e 94 ed 19 	call	0x33da	; 0x33da <CRC>
    344c:	8c 01       	movw	r16, r24
    344e:	2b ef       	ldi	r18, 0xFB	; 251
    3450:	3f e0       	ldi	r19, 0x0F	; 15
    3452:	2e 19       	sub	r18, r14
    3454:	3f 09       	sbc	r19, r15
    3456:	40 e0       	ldi	r20, 0x00	; 0
    3458:	50 e0       	ldi	r21, 0x00	; 0
    345a:	c6 01       	movw	r24, r12
    345c:	65 e0       	ldi	r22, 0x05	; 5
    345e:	70 e0       	ldi	r23, 0x00	; 0
    3460:	e6 0e       	add	r14, r22
    3462:	f7 1e       	adc	r15, r23
    3464:	b7 01       	movw	r22, r14
    3466:	0e 94 9f 19 	call	0x333e	; 0x333e <CRC_Seed>
		CRC_Seed(erb, (uint8_t*)&MemCheck_stor+sizeof(MemCheck_stor), E2END-((uint16_t)&MemCheck_stor-1)-sizeof(MemCheck_stor),
			CRC(erb, NULL, (uint16_t)&MemCheck_stor));
}
    346a:	1f 91       	pop	r17
    346c:	0f 91       	pop	r16
    346e:	ff 90       	pop	r15
    3470:	ef 90       	pop	r14
    3472:	df 90       	pop	r13
    3474:	cf 90       	pop	r12
    3476:	08 95       	ret

00003478 <InterruInit>:
InterruInit(void)
{
	#ifdef PMIC
		PMIC.CTRL = (uint8_t)(~PMIC_RREN_bm &~PMIC_IVSEL_bm) |PMIC_HILVLEN_bm |PMIC_MEDLVLEN_bm |PMIC_LOLVLEN_bm;
	#endif
	sei();
    3478:	78 94       	sei
}
    347a:	08 95       	ret

0000347c <IntOff>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    347c:	8f b7       	in	r24, 0x3f	; 63
    347e:	80 78       	andi	r24, 0x80	; 128
    3480:	80 93 ec 02 	sts	0x02EC, r24
	cli();
    3484:	f8 94       	cli
	return interru_enub_flg;
}
    3486:	08 95       	ret

00003488 <IntOn>:

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3488:	80 91 ec 02 	lds	r24, 0x02EC
    348c:	88 23       	and	r24, r24
    348e:	09 f0       	breq	.+2      	; 0x3492 <IntOn+0xa>
		sei();
    3490:	78 94       	sei
	return interru_enub_flg;
}
    3492:	08 95       	ret

00003494 <WdtOn>:

// ~~~~~~~~
void
WdtOn(void)
{
	wdt_reset();
    3494:	a8 95       	wdr
	wdt_enable(WDTO_2S);
    3496:	2f e0       	ldi	r18, 0x0F	; 15
    3498:	88 e1       	ldi	r24, 0x18	; 24
    349a:	90 e0       	ldi	r25, 0x00	; 0
    349c:	0f b6       	in	r0, 0x3f	; 63
    349e:	f8 94       	cli
    34a0:	a8 95       	wdr
    34a2:	80 93 60 00 	sts	0x0060, r24
    34a6:	0f be       	out	0x3f, r0	; 63
    34a8:	20 93 60 00 	sts	0x0060, r18
}
    34ac:	08 95       	ret

000034ae <Timer8_ISR_Alloc>:

// ~~~~~~~~~~~~~~
uint8_t
Timer8_ISR_Alloc(void)
{
	uint8_t N = VacantTimer8_ISR;
    34ae:	80 91 da 02 	lds	r24, 0x02DA
	VacantTimer8_ISR++;
    34b2:	8f 5f       	subi	r24, 0xFF	; 255
    34b4:	80 93 da 02 	sts	0x02DA, r24
    34b8:	81 50       	subi	r24, 0x01	; 1
	return N;
}
    34ba:	08 95       	ret

000034bc <Timer8Alloc>:

uint8_t
Timer8Alloc(void)
{
	uint8_t N = VacantTimer8;
    34bc:	80 91 cc 02 	lds	r24, 0x02CC
	VacantTimer8++;
    34c0:	8f 5f       	subi	r24, 0xFF	; 255
    34c2:	80 93 cc 02 	sts	0x02CC, r24
    34c6:	81 50       	subi	r24, 0x01	; 1
	return N;
}
    34c8:	08 95       	ret

000034ca <Timer16Alloc>:

// ~~~~~~~~~~~~~~~
uint8_t
Timer16Alloc(void)
{
	uint8_t N = VacantTimer16;
    34ca:	80 91 cd 02 	lds	r24, 0x02CD
	VacantTimer16++;
    34ce:	8f 5f       	subi	r24, 0xFF	; 255
    34d0:	80 93 cd 02 	sts	0x02CD, r24
    34d4:	81 50       	subi	r24, 0x01	; 1
	return N;
}
    34d6:	08 95       	ret

000034d8 <Timer32Alloc>:

// ~~~~~~~~~~~~~~~
uint8_t
Timer32Alloc(void)
{
	uint8_t N = VacantTimer32;
    34d8:	80 91 ce 02 	lds	r24, 0x02CE
	VacantTimer32++;
    34dc:	8f 5f       	subi	r24, 0xFF	; 255
    34de:	80 93 ce 02 	sts	0x02CE, r24
    34e2:	81 50       	subi	r24, 0x01	; 1
	return N;
}
    34e4:	08 95       	ret

000034e6 <Timer8_ISR_AppAlloc>:
// ~~~~~~~~~~~~~~

uint8_t
Timer8_ISR_AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    34e6:	88 23       	and	r24, r24
    34e8:	39 f0       	breq	.+14     	; 0x34f8 <Timer8_ISR_AppAlloc+0x12>
	uint8_t N = VacantTimer8_ISR;
    34ea:	90 91 da 02 	lds	r25, 0x02DA
	VacantTimer8_ISR+=n;
    34ee:	89 0f       	add	r24, r25
    34f0:	80 93 da 02 	sts	0x02DA, r24
	return N;
}
    34f4:	89 2f       	mov	r24, r25
    34f6:	08 95       	ret
// ~~~~~~~~~~~~~~

uint8_t
Timer8_ISR_AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    34f8:	90 e0       	ldi	r25, 0x00	; 0
	uint8_t N = VacantTimer8_ISR;
	VacantTimer8_ISR+=n;
	return N;
}
    34fa:	89 2f       	mov	r24, r25
    34fc:	08 95       	ret

000034fe <Timer8AppAlloc>:

uint8_t
Timer8AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    34fe:	88 23       	and	r24, r24
    3500:	39 f0       	breq	.+14     	; 0x3510 <Timer8AppAlloc+0x12>
	uint8_t N = VacantTimer8;
    3502:	90 91 cc 02 	lds	r25, 0x02CC
	VacantTimer8+=n;
    3506:	89 0f       	add	r24, r25
    3508:	80 93 cc 02 	sts	0x02CC, r24
	return N;
}
    350c:	89 2f       	mov	r24, r25
    350e:	08 95       	ret
}

uint8_t
Timer8AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    3510:	90 e0       	ldi	r25, 0x00	; 0
	uint8_t N = VacantTimer8;
	VacantTimer8+=n;
	return N;
}
    3512:	89 2f       	mov	r24, r25
    3514:	08 95       	ret

00003516 <Timer16AppAlloc>:

// ~~~~~~~~~~~~~~~
uint8_t
Timer16AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    3516:	88 23       	and	r24, r24
    3518:	39 f0       	breq	.+14     	; 0x3528 <Timer16AppAlloc+0x12>
	uint8_t N = VacantTimer16;
    351a:	90 91 cd 02 	lds	r25, 0x02CD
	VacantTimer16+=n;
    351e:	89 0f       	add	r24, r25
    3520:	80 93 cd 02 	sts	0x02CD, r24
	return N;
}
    3524:	89 2f       	mov	r24, r25
    3526:	08 95       	ret

// ~~~~~~~~~~~~~~~
uint8_t
Timer16AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    3528:	90 e0       	ldi	r25, 0x00	; 0
	uint8_t N = VacantTimer16;
	VacantTimer16+=n;
	return N;
}
    352a:	89 2f       	mov	r24, r25
    352c:	08 95       	ret

0000352e <Timer32AppAlloc>:

// ~~~~~~~~~~~~~~~
uint8_t
Timer32AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    352e:	88 23       	and	r24, r24
    3530:	39 f0       	breq	.+14     	; 0x3540 <Timer32AppAlloc+0x12>
	uint8_t N = VacantTimer32;
    3532:	90 91 ce 02 	lds	r25, 0x02CE
	VacantTimer32+=n;
    3536:	89 0f       	add	r24, r25
    3538:	80 93 ce 02 	sts	0x02CE, r24
	return N;
}
    353c:	89 2f       	mov	r24, r25
    353e:	08 95       	ret

// ~~~~~~~~~~~~~~~
uint8_t
Timer32AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    3540:	90 e0       	ldi	r25, 0x00	; 0
	uint8_t N = VacantTimer32;
	VacantTimer32+=n;
	return N;
}
    3542:	89 2f       	mov	r24, r25
    3544:	08 95       	ret

00003546 <Timer8_ISR_SysAlloc>:

// ~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer8_ISR_SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys_ISR;
    3546:	90 91 db 02 	lds	r25, 0x02DB
	VacantTimer8Sys_ISR += n;
    354a:	89 0f       	add	r24, r25
    354c:	80 93 db 02 	sts	0x02DB, r24
	return N;
}
    3550:	89 2f       	mov	r24, r25
    3552:	08 95       	ret

00003554 <Timer8SysAlloc>:

uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    3554:	90 91 cf 02 	lds	r25, 0x02CF
	VacantTimer8Sys += n;
    3558:	89 0f       	add	r24, r25
    355a:	80 93 cf 02 	sts	0x02CF, r24
	return N;
}
    355e:	89 2f       	mov	r24, r25
    3560:	08 95       	ret

00003562 <Timer16SysAlloc>:

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    3562:	90 91 d0 02 	lds	r25, 0x02D0
	VacantTimer16Sys += n;
    3566:	89 0f       	add	r24, r25
    3568:	80 93 d0 02 	sts	0x02D0, r24
	return N;
}
    356c:	89 2f       	mov	r24, r25
    356e:	08 95       	ret

00003570 <Timer32SysAlloc>:

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer32SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer32Sys;
    3570:	90 91 d1 02 	lds	r25, 0x02D1
	VacantTimer32Sys += n;
    3574:	89 0f       	add	r24, r25
    3576:	80 93 d1 02 	sts	0x02D1, r24
	return N;
}
    357a:	89 2f       	mov	r24, r25
    357c:	08 95       	ret

0000357e <StartTimer8_ISR>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
StartTimer8_ISR(uint8_t TimerN, uint8_t Timeout)
{
    357e:	98 2f       	mov	r25, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3580:	3f b7       	in	r19, 0x3f	; 63
    3582:	30 78       	andi	r19, 0x80	; 128
    3584:	30 93 ec 02 	sts	0x02EC, r19
	cli();
    3588:	f8 94       	cli
	IntOff();
	if ((Timer8_ISR[TimerN]=Timeout)>0)
    358a:	48 2f       	mov	r20, r24
    358c:	50 e0       	ldi	r21, 0x00	; 0
    358e:	fa 01       	movw	r30, r20
    3590:	e3 51       	subi	r30, 0x13	; 19
    3592:	fd 4f       	sbci	r31, 0xFD	; 253
    3594:	60 83       	st	Z, r22
    3596:	80 81       	ld	r24, Z
    3598:	88 23       	and	r24, r24
    359a:	c1 f0       	breq	.+48     	; 0x35cc <StartTimer8_ISR+0x4e>
		Timer8_ISR_Flg[TimerN/8] &=~(1<<TimerN%8);
    359c:	96 95       	lsr	r25
    359e:	96 95       	lsr	r25
    35a0:	96 95       	lsr	r25
    35a2:	e9 2f       	mov	r30, r25
    35a4:	f0 e0       	ldi	r31, 0x00	; 0
    35a6:	e3 55       	subi	r30, 0x53	; 83
    35a8:	fb 4f       	sbci	r31, 0xFB	; 251
    35aa:	20 81       	ld	r18, Z
    35ac:	47 70       	andi	r20, 0x07	; 7
    35ae:	50 70       	andi	r21, 0x00	; 0
    35b0:	81 e0       	ldi	r24, 0x01	; 1
    35b2:	90 e0       	ldi	r25, 0x00	; 0
    35b4:	02 c0       	rjmp	.+4      	; 0x35ba <StartTimer8_ISR+0x3c>
    35b6:	88 0f       	add	r24, r24
    35b8:	99 1f       	adc	r25, r25
    35ba:	4a 95       	dec	r20
    35bc:	e2 f7       	brpl	.-8      	; 0x35b6 <StartTimer8_ISR+0x38>
    35be:	80 95       	com	r24
    35c0:	82 23       	and	r24, r18
    35c2:	80 83       	st	Z, r24

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    35c4:	33 23       	and	r19, r19
    35c6:	09 f0       	breq	.+2      	; 0x35ca <StartTimer8_ISR+0x4c>
		sei();
    35c8:	78 94       	sei
    35ca:	08 95       	ret
	else
		Timer8_ISR_Flg[TimerN/8] |=(1<<TimerN%8);
    35cc:	96 95       	lsr	r25
    35ce:	96 95       	lsr	r25
    35d0:	96 95       	lsr	r25
    35d2:	e9 2f       	mov	r30, r25
    35d4:	f0 e0       	ldi	r31, 0x00	; 0
    35d6:	e3 55       	subi	r30, 0x53	; 83
    35d8:	fb 4f       	sbci	r31, 0xFB	; 251
    35da:	20 81       	ld	r18, Z
    35dc:	47 70       	andi	r20, 0x07	; 7
    35de:	50 70       	andi	r21, 0x00	; 0
    35e0:	81 e0       	ldi	r24, 0x01	; 1
    35e2:	90 e0       	ldi	r25, 0x00	; 0
    35e4:	02 c0       	rjmp	.+4      	; 0x35ea <StartTimer8_ISR+0x6c>
    35e6:	88 0f       	add	r24, r24
    35e8:	99 1f       	adc	r25, r25
    35ea:	4a 95       	dec	r20
    35ec:	e2 f7       	brpl	.-8      	; 0x35e6 <StartTimer8_ISR+0x68>
    35ee:	28 2b       	or	r18, r24
    35f0:	20 83       	st	Z, r18
    35f2:	e8 cf       	rjmp	.-48     	; 0x35c4 <StartTimer8_ISR+0x46>

000035f4 <StartTimer8>:
}


void
StartTimer8(uint8_t TimerN, uint8_t Timeout)
{
    35f4:	98 2f       	mov	r25, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    35f6:	3f b7       	in	r19, 0x3f	; 63
    35f8:	30 78       	andi	r19, 0x80	; 128
    35fa:	30 93 ec 02 	sts	0x02EC, r19
	cli();
    35fe:	f8 94       	cli
	IntOff();
	if ((Timer8[TimerN]=Timeout)>0)
    3600:	48 2f       	mov	r20, r24
    3602:	50 e0       	ldi	r21, 0x00	; 0
    3604:	fa 01       	movw	r30, r20
    3606:	eb 50       	subi	r30, 0x0B	; 11
    3608:	fd 4f       	sbci	r31, 0xFD	; 253
    360a:	60 83       	st	Z, r22
    360c:	80 81       	ld	r24, Z
    360e:	88 23       	and	r24, r24
    3610:	c1 f0       	breq	.+48     	; 0x3642 <StartTimer8+0x4e>
		Timer8Flg[TimerN/8] &=~(1<<TimerN%8);
    3612:	96 95       	lsr	r25
    3614:	96 95       	lsr	r25
    3616:	96 95       	lsr	r25
    3618:	e9 2f       	mov	r30, r25
    361a:	f0 e0       	ldi	r31, 0x00	; 0
    361c:	e1 55       	subi	r30, 0x51	; 81
    361e:	fb 4f       	sbci	r31, 0xFB	; 251
    3620:	20 81       	ld	r18, Z
    3622:	47 70       	andi	r20, 0x07	; 7
    3624:	50 70       	andi	r21, 0x00	; 0
    3626:	81 e0       	ldi	r24, 0x01	; 1
    3628:	90 e0       	ldi	r25, 0x00	; 0
    362a:	02 c0       	rjmp	.+4      	; 0x3630 <StartTimer8+0x3c>
    362c:	88 0f       	add	r24, r24
    362e:	99 1f       	adc	r25, r25
    3630:	4a 95       	dec	r20
    3632:	e2 f7       	brpl	.-8      	; 0x362c <StartTimer8+0x38>
    3634:	80 95       	com	r24
    3636:	82 23       	and	r24, r18
    3638:	80 83       	st	Z, r24

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    363a:	33 23       	and	r19, r19
    363c:	09 f0       	breq	.+2      	; 0x3640 <StartTimer8+0x4c>
		sei();
    363e:	78 94       	sei
    3640:	08 95       	ret
	else
		Timer8Flg[TimerN/8] |=(1<<TimerN%8);
    3642:	96 95       	lsr	r25
    3644:	96 95       	lsr	r25
    3646:	96 95       	lsr	r25
    3648:	e9 2f       	mov	r30, r25
    364a:	f0 e0       	ldi	r31, 0x00	; 0
    364c:	e1 55       	subi	r30, 0x51	; 81
    364e:	fb 4f       	sbci	r31, 0xFB	; 251
    3650:	20 81       	ld	r18, Z
    3652:	47 70       	andi	r20, 0x07	; 7
    3654:	50 70       	andi	r21, 0x00	; 0
    3656:	81 e0       	ldi	r24, 0x01	; 1
    3658:	90 e0       	ldi	r25, 0x00	; 0
    365a:	02 c0       	rjmp	.+4      	; 0x3660 <StartTimer8+0x6c>
    365c:	88 0f       	add	r24, r24
    365e:	99 1f       	adc	r25, r25
    3660:	4a 95       	dec	r20
    3662:	e2 f7       	brpl	.-8      	; 0x365c <StartTimer8+0x68>
    3664:	28 2b       	or	r18, r24
    3666:	20 83       	st	Z, r18
    3668:	e8 cf       	rjmp	.-48     	; 0x363a <StartTimer8+0x46>

0000366a <StartTimer16>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
StartTimer16(uint8_t TimerN, uint16_t Timeout)
{
    366a:	28 2f       	mov	r18, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    366c:	3f b7       	in	r19, 0x3f	; 63
    366e:	30 78       	andi	r19, 0x80	; 128
    3670:	30 93 ec 02 	sts	0x02EC, r19
	cli();
    3674:	f8 94       	cli
	IntOff();
	if ((Timer16[TimerN]=Timeout)>0)
    3676:	48 2f       	mov	r20, r24
    3678:	50 e0       	ldi	r21, 0x00	; 0
    367a:	fa 01       	movw	r30, r20
    367c:	ee 0f       	add	r30, r30
    367e:	ff 1f       	adc	r31, r31
    3680:	e3 5b       	subi	r30, 0xB3	; 179
    3682:	fc 4f       	sbci	r31, 0xFC	; 252
    3684:	71 83       	std	Z+1, r23	; 0x01
    3686:	60 83       	st	Z, r22
    3688:	80 81       	ld	r24, Z
    368a:	91 81       	ldd	r25, Z+1	; 0x01
    368c:	89 2b       	or	r24, r25
    368e:	c1 f0       	breq	.+48     	; 0x36c0 <StartTimer16+0x56>
		Timer16Flg[TimerN/8] &=~(1<<TimerN%8);
    3690:	26 95       	lsr	r18
    3692:	26 95       	lsr	r18
    3694:	26 95       	lsr	r18
    3696:	e2 2f       	mov	r30, r18
    3698:	f0 e0       	ldi	r31, 0x00	; 0
    369a:	e5 54       	subi	r30, 0x45	; 69
    369c:	fb 4f       	sbci	r31, 0xFB	; 251
    369e:	20 81       	ld	r18, Z
    36a0:	47 70       	andi	r20, 0x07	; 7
    36a2:	50 70       	andi	r21, 0x00	; 0
    36a4:	81 e0       	ldi	r24, 0x01	; 1
    36a6:	90 e0       	ldi	r25, 0x00	; 0
    36a8:	02 c0       	rjmp	.+4      	; 0x36ae <StartTimer16+0x44>
    36aa:	88 0f       	add	r24, r24
    36ac:	99 1f       	adc	r25, r25
    36ae:	4a 95       	dec	r20
    36b0:	e2 f7       	brpl	.-8      	; 0x36aa <StartTimer16+0x40>
    36b2:	80 95       	com	r24
    36b4:	82 23       	and	r24, r18
    36b6:	80 83       	st	Z, r24

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    36b8:	33 23       	and	r19, r19
    36ba:	09 f0       	breq	.+2      	; 0x36be <StartTimer16+0x54>
		sei();
    36bc:	78 94       	sei
    36be:	08 95       	ret
	else
		Timer16Flg[TimerN/8] |=(1<<TimerN%8);
    36c0:	26 95       	lsr	r18
    36c2:	26 95       	lsr	r18
    36c4:	26 95       	lsr	r18
    36c6:	e2 2f       	mov	r30, r18
    36c8:	f0 e0       	ldi	r31, 0x00	; 0
    36ca:	e5 54       	subi	r30, 0x45	; 69
    36cc:	fb 4f       	sbci	r31, 0xFB	; 251
    36ce:	20 81       	ld	r18, Z
    36d0:	47 70       	andi	r20, 0x07	; 7
    36d2:	50 70       	andi	r21, 0x00	; 0
    36d4:	81 e0       	ldi	r24, 0x01	; 1
    36d6:	90 e0       	ldi	r25, 0x00	; 0
    36d8:	02 c0       	rjmp	.+4      	; 0x36de <StartTimer16+0x74>
    36da:	88 0f       	add	r24, r24
    36dc:	99 1f       	adc	r25, r25
    36de:	4a 95       	dec	r20
    36e0:	e2 f7       	brpl	.-8      	; 0x36da <StartTimer16+0x70>
    36e2:	28 2b       	or	r18, r24
    36e4:	20 83       	st	Z, r18
    36e6:	e8 cf       	rjmp	.-48     	; 0x36b8 <StartTimer16+0x4e>

000036e8 <StartTimer32>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
StartTimer32(uint8_t TimerN, uint32_t Timeout)
{
    36e8:	cf 93       	push	r28
    36ea:	df 93       	push	r29
    36ec:	28 2f       	mov	r18, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    36ee:	3f b7       	in	r19, 0x3f	; 63
    36f0:	30 78       	andi	r19, 0x80	; 128
    36f2:	30 93 ec 02 	sts	0x02EC, r19
	cli();
    36f6:	f8 94       	cli
	IntOff();
	if ((Timer32[TimerN]=Timeout)>0)
    36f8:	c8 2f       	mov	r28, r24
    36fa:	d0 e0       	ldi	r29, 0x00	; 0
    36fc:	fe 01       	movw	r30, r28
    36fe:	ee 0f       	add	r30, r30
    3700:	ff 1f       	adc	r31, r31
    3702:	ee 0f       	add	r30, r30
    3704:	ff 1f       	adc	r31, r31
    3706:	e3 5f       	subi	r30, 0xF3	; 243
    3708:	fb 4f       	sbci	r31, 0xFB	; 251
    370a:	40 83       	st	Z, r20
    370c:	51 83       	std	Z+1, r21	; 0x01
    370e:	62 83       	std	Z+2, r22	; 0x02
    3710:	73 83       	std	Z+3, r23	; 0x03
    3712:	80 81       	ld	r24, Z
    3714:	91 81       	ldd	r25, Z+1	; 0x01
    3716:	a2 81       	ldd	r26, Z+2	; 0x02
    3718:	b3 81       	ldd	r27, Z+3	; 0x03
    371a:	00 97       	sbiw	r24, 0x00	; 0
    371c:	a1 05       	cpc	r26, r1
    371e:	b1 05       	cpc	r27, r1
    3720:	d1 f0       	breq	.+52     	; 0x3756 <StartTimer32+0x6e>
		Timer32Flg[TimerN/8] &=~(1<<TimerN%8);
    3722:	26 95       	lsr	r18
    3724:	26 95       	lsr	r18
    3726:	26 95       	lsr	r18
    3728:	e2 2f       	mov	r30, r18
    372a:	f0 e0       	ldi	r31, 0x00	; 0
    372c:	e8 53       	subi	r30, 0x38	; 56
    372e:	fb 4f       	sbci	r31, 0xFB	; 251
    3730:	20 81       	ld	r18, Z
    3732:	c7 70       	andi	r28, 0x07	; 7
    3734:	d0 70       	andi	r29, 0x00	; 0
    3736:	81 e0       	ldi	r24, 0x01	; 1
    3738:	90 e0       	ldi	r25, 0x00	; 0
    373a:	02 c0       	rjmp	.+4      	; 0x3740 <StartTimer32+0x58>
    373c:	88 0f       	add	r24, r24
    373e:	99 1f       	adc	r25, r25
    3740:	ca 95       	dec	r28
    3742:	e2 f7       	brpl	.-8      	; 0x373c <StartTimer32+0x54>
    3744:	80 95       	com	r24
    3746:	82 23       	and	r24, r18
    3748:	80 83       	st	Z, r24

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    374a:	33 23       	and	r19, r19
    374c:	09 f0       	breq	.+2      	; 0x3750 <StartTimer32+0x68>
		sei();
    374e:	78 94       	sei
	else
		Timer32Flg[TimerN/8] |=(1<<TimerN%8);
	IntOn();
}
    3750:	df 91       	pop	r29
    3752:	cf 91       	pop	r28
    3754:	08 95       	ret
{
	IntOff();
	if ((Timer32[TimerN]=Timeout)>0)
		Timer32Flg[TimerN/8] &=~(1<<TimerN%8);
	else
		Timer32Flg[TimerN/8] |=(1<<TimerN%8);
    3756:	26 95       	lsr	r18
    3758:	26 95       	lsr	r18
    375a:	26 95       	lsr	r18
    375c:	e2 2f       	mov	r30, r18
    375e:	f0 e0       	ldi	r31, 0x00	; 0
    3760:	e8 53       	subi	r30, 0x38	; 56
    3762:	fb 4f       	sbci	r31, 0xFB	; 251
    3764:	20 81       	ld	r18, Z
    3766:	c7 70       	andi	r28, 0x07	; 7
    3768:	d0 70       	andi	r29, 0x00	; 0
    376a:	81 e0       	ldi	r24, 0x01	; 1
    376c:	90 e0       	ldi	r25, 0x00	; 0
    376e:	02 c0       	rjmp	.+4      	; 0x3774 <StartTimer32+0x8c>
    3770:	88 0f       	add	r24, r24
    3772:	99 1f       	adc	r25, r25
    3774:	ca 95       	dec	r28
    3776:	e2 f7       	brpl	.-8      	; 0x3770 <StartTimer32+0x88>
    3778:	28 2b       	or	r18, r24
    377a:	20 83       	st	Z, r18
    377c:	e6 cf       	rjmp	.-52     	; 0x374a <StartTimer32+0x62>

0000377e <StopTimer8_ISR>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    377e:	4f b7       	in	r20, 0x3f	; 63
    3780:	40 78       	andi	r20, 0x80	; 128
    3782:	40 93 ec 02 	sts	0x02EC, r20
	cli();
    3786:	f8 94       	cli
// ~~~~~~~~~~~~~~~~~~~~~~~
void
StopTimer8_ISR(uint8_t TimerN)
{
	IntOff();
	Timer8_ISR_Flg[TimerN/8] |=(1<<TimerN%8);
    3788:	e8 2f       	mov	r30, r24
    378a:	e6 95       	lsr	r30
    378c:	e6 95       	lsr	r30
    378e:	e6 95       	lsr	r30
    3790:	f0 e0       	ldi	r31, 0x00	; 0
    3792:	e3 55       	subi	r30, 0x53	; 83
    3794:	fb 4f       	sbci	r31, 0xFB	; 251
    3796:	90 81       	ld	r25, Z
    3798:	87 70       	andi	r24, 0x07	; 7
    379a:	21 e0       	ldi	r18, 0x01	; 1
    379c:	30 e0       	ldi	r19, 0x00	; 0
    379e:	02 c0       	rjmp	.+4      	; 0x37a4 <StopTimer8_ISR+0x26>
    37a0:	22 0f       	add	r18, r18
    37a2:	33 1f       	adc	r19, r19
    37a4:	8a 95       	dec	r24
    37a6:	e2 f7       	brpl	.-8      	; 0x37a0 <StopTimer8_ISR+0x22>
    37a8:	92 2b       	or	r25, r18
    37aa:	90 83       	st	Z, r25

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    37ac:	44 23       	and	r20, r20
    37ae:	09 f0       	breq	.+2      	; 0x37b2 <StopTimer8_ISR+0x34>
		sei();
    37b0:	78 94       	sei
    37b2:	08 95       	ret

000037b4 <StopTimer8>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    37b4:	4f b7       	in	r20, 0x3f	; 63
    37b6:	40 78       	andi	r20, 0x80	; 128
    37b8:	40 93 ec 02 	sts	0x02EC, r20
	cli();
    37bc:	f8 94       	cli

void
StopTimer8(uint8_t TimerN)
{
	IntOff();
	Timer8Flg[TimerN/8] |=(1<<TimerN%8);
    37be:	e8 2f       	mov	r30, r24
    37c0:	e6 95       	lsr	r30
    37c2:	e6 95       	lsr	r30
    37c4:	e6 95       	lsr	r30
    37c6:	f0 e0       	ldi	r31, 0x00	; 0
    37c8:	e1 55       	subi	r30, 0x51	; 81
    37ca:	fb 4f       	sbci	r31, 0xFB	; 251
    37cc:	90 81       	ld	r25, Z
    37ce:	87 70       	andi	r24, 0x07	; 7
    37d0:	21 e0       	ldi	r18, 0x01	; 1
    37d2:	30 e0       	ldi	r19, 0x00	; 0
    37d4:	02 c0       	rjmp	.+4      	; 0x37da <StopTimer8+0x26>
    37d6:	22 0f       	add	r18, r18
    37d8:	33 1f       	adc	r19, r19
    37da:	8a 95       	dec	r24
    37dc:	e2 f7       	brpl	.-8      	; 0x37d6 <StopTimer8+0x22>
    37de:	92 2b       	or	r25, r18
    37e0:	90 83       	st	Z, r25

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    37e2:	44 23       	and	r20, r20
    37e4:	09 f0       	breq	.+2      	; 0x37e8 <StopTimer8+0x34>
		sei();
    37e6:	78 94       	sei
    37e8:	08 95       	ret

000037ea <StopTimer16>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    37ea:	4f b7       	in	r20, 0x3f	; 63
    37ec:	40 78       	andi	r20, 0x80	; 128
    37ee:	40 93 ec 02 	sts	0x02EC, r20
	cli();
    37f2:	f8 94       	cli
// ~~~~~~~~~~~~~~~~~~~~~~~~
void
StopTimer16(uint8_t TimerN)
{
	IntOff();
	Timer16Flg[TimerN/8] |=1<<TimerN%8;
    37f4:	e8 2f       	mov	r30, r24
    37f6:	e6 95       	lsr	r30
    37f8:	e6 95       	lsr	r30
    37fa:	e6 95       	lsr	r30
    37fc:	f0 e0       	ldi	r31, 0x00	; 0
    37fe:	e5 54       	subi	r30, 0x45	; 69
    3800:	fb 4f       	sbci	r31, 0xFB	; 251
    3802:	90 81       	ld	r25, Z
    3804:	87 70       	andi	r24, 0x07	; 7
    3806:	21 e0       	ldi	r18, 0x01	; 1
    3808:	30 e0       	ldi	r19, 0x00	; 0
    380a:	02 c0       	rjmp	.+4      	; 0x3810 <StopTimer16+0x26>
    380c:	22 0f       	add	r18, r18
    380e:	33 1f       	adc	r19, r19
    3810:	8a 95       	dec	r24
    3812:	e2 f7       	brpl	.-8      	; 0x380c <StopTimer16+0x22>
    3814:	92 2b       	or	r25, r18
    3816:	90 83       	st	Z, r25

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3818:	44 23       	and	r20, r20
    381a:	09 f0       	breq	.+2      	; 0x381e <StopTimer16+0x34>
		sei();
    381c:	78 94       	sei
    381e:	08 95       	ret

00003820 <StopTimer32>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3820:	4f b7       	in	r20, 0x3f	; 63
    3822:	40 78       	andi	r20, 0x80	; 128
    3824:	40 93 ec 02 	sts	0x02EC, r20
	cli();
    3828:	f8 94       	cli
// ~~~~~~~~~~~~~~~~~~~~~~~~
void
StopTimer32(uint8_t TimerN)
{
	IntOff();
	Timer32Flg[TimerN/8] |=1<<TimerN%8;
    382a:	e8 2f       	mov	r30, r24
    382c:	e6 95       	lsr	r30
    382e:	e6 95       	lsr	r30
    3830:	e6 95       	lsr	r30
    3832:	f0 e0       	ldi	r31, 0x00	; 0
    3834:	e8 53       	subi	r30, 0x38	; 56
    3836:	fb 4f       	sbci	r31, 0xFB	; 251
    3838:	90 81       	ld	r25, Z
    383a:	87 70       	andi	r24, 0x07	; 7
    383c:	21 e0       	ldi	r18, 0x01	; 1
    383e:	30 e0       	ldi	r19, 0x00	; 0
    3840:	02 c0       	rjmp	.+4      	; 0x3846 <StopTimer32+0x26>
    3842:	22 0f       	add	r18, r18
    3844:	33 1f       	adc	r19, r19
    3846:	8a 95       	dec	r24
    3848:	e2 f7       	brpl	.-8      	; 0x3842 <StopTimer32+0x22>
    384a:	92 2b       	or	r25, r18
    384c:	90 83       	st	Z, r25

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    384e:	44 23       	and	r20, r20
    3850:	09 f0       	breq	.+2      	; 0x3854 <StopTimer32+0x34>
		sei();
    3852:	78 94       	sei
    3854:	08 95       	ret

00003856 <Timer8Stopp_ISR>:
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer8Stopp_ISR(uint8_t TimerN)
{
	return (Timer8_ISR_Flg[TimerN/8] &(1<<TimerN%8)) && Timer8_ISR[TimerN]==0;
    3856:	e8 2f       	mov	r30, r24
    3858:	e6 95       	lsr	r30
    385a:	e6 95       	lsr	r30
    385c:	e6 95       	lsr	r30
    385e:	f0 e0       	ldi	r31, 0x00	; 0
    3860:	e3 55       	subi	r30, 0x53	; 83
    3862:	fb 4f       	sbci	r31, 0xFB	; 251
    3864:	20 81       	ld	r18, Z
    3866:	e8 2f       	mov	r30, r24
    3868:	f0 e0       	ldi	r31, 0x00	; 0
    386a:	30 e0       	ldi	r19, 0x00	; 0
    386c:	cf 01       	movw	r24, r30
    386e:	87 70       	andi	r24, 0x07	; 7
    3870:	90 70       	andi	r25, 0x00	; 0
    3872:	02 c0       	rjmp	.+4      	; 0x3878 <Timer8Stopp_ISR+0x22>
    3874:	35 95       	asr	r19
    3876:	27 95       	ror	r18
    3878:	8a 95       	dec	r24
    387a:	e2 f7       	brpl	.-8      	; 0x3874 <Timer8Stopp_ISR+0x1e>
    387c:	20 fd       	sbrc	r18, 0
    387e:	02 c0       	rjmp	.+4      	; 0x3884 <Timer8Stopp_ISR+0x2e>
    3880:	80 e0       	ldi	r24, 0x00	; 0
    3882:	08 95       	ret
    3884:	e3 51       	subi	r30, 0x13	; 19
    3886:	fd 4f       	sbci	r31, 0xFD	; 253
    3888:	90 81       	ld	r25, Z
    388a:	99 23       	and	r25, r25
    388c:	19 f4       	brne	.+6      	; 0x3894 <Timer8Stopp_ISR+0x3e>
    388e:	81 e0       	ldi	r24, 0x01	; 1
    3890:	89 27       	eor	r24, r25
}
    3892:	08 95       	ret
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer8Stopp_ISR(uint8_t TimerN)
{
	return (Timer8_ISR_Flg[TimerN/8] &(1<<TimerN%8)) && Timer8_ISR[TimerN]==0;
    3894:	91 e0       	ldi	r25, 0x01	; 1
    3896:	81 e0       	ldi	r24, 0x01	; 1
    3898:	89 27       	eor	r24, r25
}
    389a:	08 95       	ret

0000389c <Timer8Stopp>:

// ~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer8Stopp(uint8_t TimerN)
{
	return (Timer8Flg[TimerN/8] &(1<<TimerN%8)) && Timer8[TimerN]==0;
    389c:	e8 2f       	mov	r30, r24
    389e:	e6 95       	lsr	r30
    38a0:	e6 95       	lsr	r30
    38a2:	e6 95       	lsr	r30
    38a4:	f0 e0       	ldi	r31, 0x00	; 0
    38a6:	e1 55       	subi	r30, 0x51	; 81
    38a8:	fb 4f       	sbci	r31, 0xFB	; 251
    38aa:	20 81       	ld	r18, Z
    38ac:	e8 2f       	mov	r30, r24
    38ae:	f0 e0       	ldi	r31, 0x00	; 0
    38b0:	30 e0       	ldi	r19, 0x00	; 0
    38b2:	cf 01       	movw	r24, r30
    38b4:	87 70       	andi	r24, 0x07	; 7
    38b6:	90 70       	andi	r25, 0x00	; 0
    38b8:	02 c0       	rjmp	.+4      	; 0x38be <Timer8Stopp+0x22>
    38ba:	35 95       	asr	r19
    38bc:	27 95       	ror	r18
    38be:	8a 95       	dec	r24
    38c0:	e2 f7       	brpl	.-8      	; 0x38ba <Timer8Stopp+0x1e>
    38c2:	20 fd       	sbrc	r18, 0
    38c4:	02 c0       	rjmp	.+4      	; 0x38ca <Timer8Stopp+0x2e>
    38c6:	80 e0       	ldi	r24, 0x00	; 0
    38c8:	08 95       	ret
    38ca:	eb 50       	subi	r30, 0x0B	; 11
    38cc:	fd 4f       	sbci	r31, 0xFD	; 253
    38ce:	90 81       	ld	r25, Z
    38d0:	99 23       	and	r25, r25
    38d2:	19 f4       	brne	.+6      	; 0x38da <Timer8Stopp+0x3e>
    38d4:	81 e0       	ldi	r24, 0x01	; 1
    38d6:	89 27       	eor	r24, r25
}
    38d8:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer8Stopp(uint8_t TimerN)
{
	return (Timer8Flg[TimerN/8] &(1<<TimerN%8)) && Timer8[TimerN]==0;
    38da:	91 e0       	ldi	r25, 0x01	; 1
    38dc:	81 e0       	ldi	r24, 0x01	; 1
    38de:	89 27       	eor	r24, r25
}
    38e0:	08 95       	ret

000038e2 <Timer16Stopp>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    38e2:	4f b7       	in	r20, 0x3f	; 63
    38e4:	40 78       	andi	r20, 0x80	; 128
    38e6:	40 93 ec 02 	sts	0x02EC, r20
	cli();
    38ea:	f8 94       	cli
// ~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16Stopp(uint8_t TimerN)
{
	IntOff();
	uint8_t T_S = (Timer16Flg[TimerN/8] &(1<<TimerN%8)) && Timer16[TimerN]==0;
    38ec:	e8 2f       	mov	r30, r24
    38ee:	e6 95       	lsr	r30
    38f0:	e6 95       	lsr	r30
    38f2:	e6 95       	lsr	r30
    38f4:	f0 e0       	ldi	r31, 0x00	; 0
    38f6:	e5 54       	subi	r30, 0x45	; 69
    38f8:	fb 4f       	sbci	r31, 0xFB	; 251
    38fa:	20 81       	ld	r18, Z
    38fc:	e8 2f       	mov	r30, r24
    38fe:	f0 e0       	ldi	r31, 0x00	; 0
    3900:	30 e0       	ldi	r19, 0x00	; 0
    3902:	cf 01       	movw	r24, r30
    3904:	87 70       	andi	r24, 0x07	; 7
    3906:	90 70       	andi	r25, 0x00	; 0
    3908:	02 c0       	rjmp	.+4      	; 0x390e <Timer16Stopp+0x2c>
    390a:	35 95       	asr	r19
    390c:	27 95       	ror	r18
    390e:	8a 95       	dec	r24
    3910:	e2 f7       	brpl	.-8      	; 0x390a <Timer16Stopp+0x28>
    3912:	20 fd       	sbrc	r18, 0
    3914:	06 c0       	rjmp	.+12     	; 0x3922 <Timer16Stopp+0x40>
    3916:	20 e0       	ldi	r18, 0x00	; 0

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3918:	44 23       	and	r20, r20
    391a:	09 f0       	breq	.+2      	; 0x391e <Timer16Stopp+0x3c>
		sei();
    391c:	78 94       	sei
	IntOn();
	return T_S;
}
    391e:	82 2f       	mov	r24, r18
    3920:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16Stopp(uint8_t TimerN)
{
	IntOff();
	uint8_t T_S = (Timer16Flg[TimerN/8] &(1<<TimerN%8)) && Timer16[TimerN]==0;
    3922:	ee 0f       	add	r30, r30
    3924:	ff 1f       	adc	r31, r31
    3926:	e3 5b       	subi	r30, 0xB3	; 179
    3928:	fc 4f       	sbci	r31, 0xFC	; 252
    392a:	80 81       	ld	r24, Z
    392c:	91 81       	ldd	r25, Z+1	; 0x01
    392e:	20 e0       	ldi	r18, 0x00	; 0
    3930:	89 2b       	or	r24, r25
    3932:	19 f4       	brne	.+6      	; 0x393a <Timer16Stopp+0x58>
    3934:	81 e0       	ldi	r24, 0x01	; 1
    3936:	28 27       	eor	r18, r24
    3938:	ef cf       	rjmp	.-34     	; 0x3918 <Timer16Stopp+0x36>
    393a:	21 e0       	ldi	r18, 0x01	; 1
    393c:	81 e0       	ldi	r24, 0x01	; 1
    393e:	28 27       	eor	r18, r24
    3940:	eb cf       	rjmp	.-42     	; 0x3918 <Timer16Stopp+0x36>

00003942 <Timer32Stopp>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3942:	4f b7       	in	r20, 0x3f	; 63
    3944:	40 78       	andi	r20, 0x80	; 128
    3946:	40 93 ec 02 	sts	0x02EC, r20
	cli();
    394a:	f8 94       	cli
// ~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer32Stopp(uint8_t TimerN)
{
	IntOff();
	uint8_t T_S = (Timer32Flg[TimerN/8] &(1<<TimerN%8)) && Timer32[TimerN]==0;
    394c:	e8 2f       	mov	r30, r24
    394e:	e6 95       	lsr	r30
    3950:	e6 95       	lsr	r30
    3952:	e6 95       	lsr	r30
    3954:	f0 e0       	ldi	r31, 0x00	; 0
    3956:	e8 53       	subi	r30, 0x38	; 56
    3958:	fb 4f       	sbci	r31, 0xFB	; 251
    395a:	20 81       	ld	r18, Z
    395c:	e8 2f       	mov	r30, r24
    395e:	f0 e0       	ldi	r31, 0x00	; 0
    3960:	30 e0       	ldi	r19, 0x00	; 0
    3962:	cf 01       	movw	r24, r30
    3964:	87 70       	andi	r24, 0x07	; 7
    3966:	90 70       	andi	r25, 0x00	; 0
    3968:	02 c0       	rjmp	.+4      	; 0x396e <Timer32Stopp+0x2c>
    396a:	35 95       	asr	r19
    396c:	27 95       	ror	r18
    396e:	8a 95       	dec	r24
    3970:	e2 f7       	brpl	.-8      	; 0x396a <Timer32Stopp+0x28>
    3972:	20 fd       	sbrc	r18, 0
    3974:	06 c0       	rjmp	.+12     	; 0x3982 <Timer32Stopp+0x40>
    3976:	20 e0       	ldi	r18, 0x00	; 0

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3978:	44 23       	and	r20, r20
    397a:	09 f0       	breq	.+2      	; 0x397e <Timer32Stopp+0x3c>
		sei();
    397c:	78 94       	sei
	IntOn();
	return T_S;
}
    397e:	82 2f       	mov	r24, r18
    3980:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer32Stopp(uint8_t TimerN)
{
	IntOff();
	uint8_t T_S = (Timer32Flg[TimerN/8] &(1<<TimerN%8)) && Timer32[TimerN]==0;
    3982:	ee 0f       	add	r30, r30
    3984:	ff 1f       	adc	r31, r31
    3986:	ee 0f       	add	r30, r30
    3988:	ff 1f       	adc	r31, r31
    398a:	e3 5f       	subi	r30, 0xF3	; 243
    398c:	fb 4f       	sbci	r31, 0xFB	; 251
    398e:	80 81       	ld	r24, Z
    3990:	91 81       	ldd	r25, Z+1	; 0x01
    3992:	a2 81       	ldd	r26, Z+2	; 0x02
    3994:	b3 81       	ldd	r27, Z+3	; 0x03
    3996:	20 e0       	ldi	r18, 0x00	; 0
    3998:	00 97       	sbiw	r24, 0x00	; 0
    399a:	a1 05       	cpc	r26, r1
    399c:	b1 05       	cpc	r27, r1
    399e:	19 f4       	brne	.+6      	; 0x39a6 <Timer32Stopp+0x64>
    39a0:	81 e0       	ldi	r24, 0x01	; 1
    39a2:	28 27       	eor	r18, r24
    39a4:	e9 cf       	rjmp	.-46     	; 0x3978 <Timer32Stopp+0x36>
    39a6:	21 e0       	ldi	r18, 0x01	; 1
    39a8:	81 e0       	ldi	r24, 0x01	; 1
    39aa:	28 27       	eor	r18, r24
    39ac:	e5 cf       	rjmp	.-54     	; 0x3978 <Timer32Stopp+0x36>

000039ae <ResetTimer8_ISR>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    39ae:	5f b7       	in	r21, 0x3f	; 63
    39b0:	50 78       	andi	r21, 0x80	; 128
    39b2:	50 93 ec 02 	sts	0x02EC, r21
	cli();
    39b6:	f8 94       	cli
//~~~~~~~~~~~~~~~~~~~~~~~~~
void
ResetTimer8_ISR(uint8_t TimerN)
{
	IntOff();
	Timer8_ISR_Flg[TimerN/8] |=(1<<TimerN%8);
    39b8:	e8 2f       	mov	r30, r24
    39ba:	e6 95       	lsr	r30
    39bc:	e6 95       	lsr	r30
    39be:	e6 95       	lsr	r30
    39c0:	f0 e0       	ldi	r31, 0x00	; 0
    39c2:	e3 55       	subi	r30, 0x53	; 83
    39c4:	fb 4f       	sbci	r31, 0xFB	; 251
    39c6:	40 81       	ld	r20, Z
    39c8:	a8 2f       	mov	r26, r24
    39ca:	b0 e0       	ldi	r27, 0x00	; 0
    39cc:	9d 01       	movw	r18, r26
    39ce:	27 70       	andi	r18, 0x07	; 7
    39d0:	30 70       	andi	r19, 0x00	; 0
    39d2:	81 e0       	ldi	r24, 0x01	; 1
    39d4:	90 e0       	ldi	r25, 0x00	; 0
    39d6:	02 c0       	rjmp	.+4      	; 0x39dc <ResetTimer8_ISR+0x2e>
    39d8:	88 0f       	add	r24, r24
    39da:	99 1f       	adc	r25, r25
    39dc:	2a 95       	dec	r18
    39de:	e2 f7       	brpl	.-8      	; 0x39d8 <ResetTimer8_ISR+0x2a>
    39e0:	48 2b       	or	r20, r24
    39e2:	40 83       	st	Z, r20

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    39e4:	55 23       	and	r21, r21
    39e6:	09 f0       	breq	.+2      	; 0x39ea <ResetTimer8_ISR+0x3c>
		sei();
    39e8:	78 94       	sei
	IntOn();
	Timer8_ISR[TimerN] = 0;
    39ea:	a3 51       	subi	r26, 0x13	; 19
    39ec:	bd 4f       	sbci	r27, 0xFD	; 253
    39ee:	1c 92       	st	X, r1
}
    39f0:	08 95       	ret

000039f2 <ResetTimer8>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    39f2:	5f b7       	in	r21, 0x3f	; 63
    39f4:	50 78       	andi	r21, 0x80	; 128
    39f6:	50 93 ec 02 	sts	0x02EC, r21
	cli();
    39fa:	f8 94       	cli

void
ResetTimer8(uint8_t TimerN)
{
	IntOff();
	Timer8Flg[TimerN/8] |=(1<<TimerN%8);
    39fc:	e8 2f       	mov	r30, r24
    39fe:	e6 95       	lsr	r30
    3a00:	e6 95       	lsr	r30
    3a02:	e6 95       	lsr	r30
    3a04:	f0 e0       	ldi	r31, 0x00	; 0
    3a06:	e1 55       	subi	r30, 0x51	; 81
    3a08:	fb 4f       	sbci	r31, 0xFB	; 251
    3a0a:	40 81       	ld	r20, Z
    3a0c:	a8 2f       	mov	r26, r24
    3a0e:	b0 e0       	ldi	r27, 0x00	; 0
    3a10:	9d 01       	movw	r18, r26
    3a12:	27 70       	andi	r18, 0x07	; 7
    3a14:	30 70       	andi	r19, 0x00	; 0
    3a16:	81 e0       	ldi	r24, 0x01	; 1
    3a18:	90 e0       	ldi	r25, 0x00	; 0
    3a1a:	02 c0       	rjmp	.+4      	; 0x3a20 <ResetTimer8+0x2e>
    3a1c:	88 0f       	add	r24, r24
    3a1e:	99 1f       	adc	r25, r25
    3a20:	2a 95       	dec	r18
    3a22:	e2 f7       	brpl	.-8      	; 0x3a1c <ResetTimer8+0x2a>
    3a24:	48 2b       	or	r20, r24
    3a26:	40 83       	st	Z, r20

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3a28:	55 23       	and	r21, r21
    3a2a:	09 f0       	breq	.+2      	; 0x3a2e <ResetTimer8+0x3c>
		sei();
    3a2c:	78 94       	sei
	IntOn();
	Timer8[TimerN] = 0;
    3a2e:	ab 50       	subi	r26, 0x0B	; 11
    3a30:	bd 4f       	sbci	r27, 0xFD	; 253
    3a32:	1c 92       	st	X, r1
}
    3a34:	08 95       	ret

00003a36 <ResetTimer16>:

//~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ResetTimer16(uint8_t TimerN)
{
    3a36:	e8 2f       	mov	r30, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3a38:	5f b7       	in	r21, 0x3f	; 63
    3a3a:	50 78       	andi	r21, 0x80	; 128
    3a3c:	50 93 ec 02 	sts	0x02EC, r21
	cli();
    3a40:	f8 94       	cli
	IntOff();
	Timer16Flg[TimerN/8] |=1<<TimerN%8;
    3a42:	a8 2f       	mov	r26, r24
    3a44:	a6 95       	lsr	r26
    3a46:	a6 95       	lsr	r26
    3a48:	a6 95       	lsr	r26
    3a4a:	b0 e0       	ldi	r27, 0x00	; 0
    3a4c:	a5 54       	subi	r26, 0x45	; 69
    3a4e:	bb 4f       	sbci	r27, 0xFB	; 251
    3a50:	4c 91       	ld	r20, X
    3a52:	f0 e0       	ldi	r31, 0x00	; 0
    3a54:	9f 01       	movw	r18, r30
    3a56:	27 70       	andi	r18, 0x07	; 7
    3a58:	30 70       	andi	r19, 0x00	; 0
    3a5a:	81 e0       	ldi	r24, 0x01	; 1
    3a5c:	90 e0       	ldi	r25, 0x00	; 0
    3a5e:	02 c0       	rjmp	.+4      	; 0x3a64 <ResetTimer16+0x2e>
    3a60:	88 0f       	add	r24, r24
    3a62:	99 1f       	adc	r25, r25
    3a64:	2a 95       	dec	r18
    3a66:	e2 f7       	brpl	.-8      	; 0x3a60 <ResetTimer16+0x2a>
    3a68:	48 2b       	or	r20, r24
    3a6a:	4c 93       	st	X, r20
	Timer16[TimerN] = 0;
    3a6c:	ee 0f       	add	r30, r30
    3a6e:	ff 1f       	adc	r31, r31
    3a70:	e3 5b       	subi	r30, 0xB3	; 179
    3a72:	fc 4f       	sbci	r31, 0xFC	; 252
    3a74:	11 82       	std	Z+1, r1	; 0x01
    3a76:	10 82       	st	Z, r1

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3a78:	55 23       	and	r21, r21
    3a7a:	09 f0       	breq	.+2      	; 0x3a7e <ResetTimer16+0x48>
		sei();
    3a7c:	78 94       	sei
    3a7e:	08 95       	ret

00003a80 <ResetTimer32>:
}

//~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ResetTimer32(uint8_t TimerN)
{
    3a80:	e8 2f       	mov	r30, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3a82:	5f b7       	in	r21, 0x3f	; 63
    3a84:	50 78       	andi	r21, 0x80	; 128
    3a86:	50 93 ec 02 	sts	0x02EC, r21
	cli();
    3a8a:	f8 94       	cli
	IntOff();
	Timer32Flg[TimerN/8] |=1<<TimerN%8;
    3a8c:	a8 2f       	mov	r26, r24
    3a8e:	a6 95       	lsr	r26
    3a90:	a6 95       	lsr	r26
    3a92:	a6 95       	lsr	r26
    3a94:	b0 e0       	ldi	r27, 0x00	; 0
    3a96:	a8 53       	subi	r26, 0x38	; 56
    3a98:	bb 4f       	sbci	r27, 0xFB	; 251
    3a9a:	4c 91       	ld	r20, X
    3a9c:	f0 e0       	ldi	r31, 0x00	; 0
    3a9e:	9f 01       	movw	r18, r30
    3aa0:	27 70       	andi	r18, 0x07	; 7
    3aa2:	30 70       	andi	r19, 0x00	; 0
    3aa4:	81 e0       	ldi	r24, 0x01	; 1
    3aa6:	90 e0       	ldi	r25, 0x00	; 0
    3aa8:	02 c0       	rjmp	.+4      	; 0x3aae <ResetTimer32+0x2e>
    3aaa:	88 0f       	add	r24, r24
    3aac:	99 1f       	adc	r25, r25
    3aae:	2a 95       	dec	r18
    3ab0:	e2 f7       	brpl	.-8      	; 0x3aaa <ResetTimer32+0x2a>
    3ab2:	48 2b       	or	r20, r24
    3ab4:	4c 93       	st	X, r20
	Timer32[TimerN] = 0;
    3ab6:	ee 0f       	add	r30, r30
    3ab8:	ff 1f       	adc	r31, r31
    3aba:	ee 0f       	add	r30, r30
    3abc:	ff 1f       	adc	r31, r31
    3abe:	e3 5f       	subi	r30, 0xF3	; 243
    3ac0:	fb 4f       	sbci	r31, 0xFB	; 251
    3ac2:	10 82       	st	Z, r1
    3ac4:	11 82       	std	Z+1, r1	; 0x01
    3ac6:	12 82       	std	Z+2, r1	; 0x02
    3ac8:	13 82       	std	Z+3, r1	; 0x03

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3aca:	55 23       	and	r21, r21
    3acc:	09 f0       	breq	.+2      	; 0x3ad0 <ResetTimer32+0x50>
		sei();
    3ace:	78 94       	sei
    3ad0:	08 95       	ret

00003ad2 <GetTimer8_ISR>:

// ~~~~~~~~~~~~~~~~~~~~~~
uint8_t
GetTimer8_ISR(uint8_t TimerN)
{
	return Timer8_ISR[TimerN];
    3ad2:	ed ee       	ldi	r30, 0xED	; 237
    3ad4:	f2 e0       	ldi	r31, 0x02	; 2
    3ad6:	e8 0f       	add	r30, r24
    3ad8:	f1 1d       	adc	r31, r1
    3ada:	80 81       	ld	r24, Z
}
    3adc:	08 95       	ret

00003ade <GetTimer8>:
uint8_t
GetTimer8(uint8_t TimerN)
{
	return Timer8[TimerN];
    3ade:	e5 ef       	ldi	r30, 0xF5	; 245
    3ae0:	f2 e0       	ldi	r31, 0x02	; 2
    3ae2:	e8 0f       	add	r30, r24
    3ae4:	f1 1d       	adc	r31, r1
    3ae6:	80 81       	ld	r24, Z
}
    3ae8:	08 95       	ret

00003aea <GetTimer16>:

// ~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
GetTimer16(uint8_t TimerN)
{
    3aea:	e8 2f       	mov	r30, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3aec:	8f b7       	in	r24, 0x3f	; 63
    3aee:	80 78       	andi	r24, 0x80	; 128
    3af0:	80 93 ec 02 	sts	0x02EC, r24
	cli();
    3af4:	f8 94       	cli
	IntOff();
	uint16_t Time = Timer16[TimerN];
    3af6:	f0 e0       	ldi	r31, 0x00	; 0
    3af8:	ee 0f       	add	r30, r30
    3afa:	ff 1f       	adc	r31, r31
    3afc:	e3 5b       	subi	r30, 0xB3	; 179
    3afe:	fc 4f       	sbci	r31, 0xFC	; 252
    3b00:	01 90       	ld	r0, Z+
    3b02:	f0 81       	ld	r31, Z
    3b04:	e0 2d       	mov	r30, r0

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3b06:	88 23       	and	r24, r24
    3b08:	09 f0       	breq	.+2      	; 0x3b0c <GetTimer16+0x22>
		sei();
    3b0a:	78 94       	sei
	IntOn();
	return Time;
}
    3b0c:	cf 01       	movw	r24, r30
    3b0e:	08 95       	ret

00003b10 <GetTimer32>:

// ~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
GetTimer32(uint8_t TimerN)
{
    3b10:	e8 2f       	mov	r30, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3b12:	8f b7       	in	r24, 0x3f	; 63
    3b14:	80 78       	andi	r24, 0x80	; 128
    3b16:	80 93 ec 02 	sts	0x02EC, r24
	cli();
    3b1a:	f8 94       	cli
	IntOff();
	uint32_t Time = Timer32[TimerN];
    3b1c:	f0 e0       	ldi	r31, 0x00	; 0
    3b1e:	ee 0f       	add	r30, r30
    3b20:	ff 1f       	adc	r31, r31
    3b22:	ee 0f       	add	r30, r30
    3b24:	ff 1f       	adc	r31, r31
    3b26:	e3 5f       	subi	r30, 0xF3	; 243
    3b28:	fb 4f       	sbci	r31, 0xFB	; 251
    3b2a:	20 81       	ld	r18, Z
    3b2c:	31 81       	ldd	r19, Z+1	; 0x01
    3b2e:	42 81       	ldd	r20, Z+2	; 0x02
    3b30:	53 81       	ldd	r21, Z+3	; 0x03

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3b32:	88 23       	and	r24, r24
    3b34:	09 f0       	breq	.+2      	; 0x3b38 <GetTimer32+0x28>
		sei();
    3b36:	78 94       	sei
	IntOn();
	return Time;
}
    3b38:	b9 01       	movw	r22, r18
    3b3a:	ca 01       	movw	r24, r20
    3b3c:	08 95       	ret

00003b3e <TimerAllocError>:
// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t TimerAllocError(void){
	return ( (VacantTimer8Sys >=  Timer8TotNumber) || (VacantTimer16Sys >=  Timer16TotNumber) || (VacantTimer32Sys >=  Timer32TotNumber) ||
    3b3e:	80 91 cf 02 	lds	r24, 0x02CF
    3b42:	88 35       	cpi	r24, 0x58	; 88
    3b44:	a8 f4       	brcc	.+42     	; 0x3b70 <TimerAllocError+0x32>
    3b46:	80 91 d0 02 	lds	r24, 0x02D0
    3b4a:	80 36       	cpi	r24, 0x60	; 96
    3b4c:	88 f4       	brcc	.+34     	; 0x3b70 <TimerAllocError+0x32>
    3b4e:	80 91 d1 02 	lds	r24, 0x02D1
    3b52:	88 32       	cpi	r24, 0x28	; 40
    3b54:	68 f4       	brcc	.+26     	; 0x3b70 <TimerAllocError+0x32>
    3b56:	80 91 cc 02 	lds	r24, 0x02CC
    3b5a:	80 34       	cpi	r24, 0x40	; 64
    3b5c:	48 f4       	brcc	.+18     	; 0x3b70 <TimerAllocError+0x32>
    3b5e:	80 91 cd 02 	lds	r24, 0x02CD
    3b62:	88 34       	cpi	r24, 0x48	; 72
    3b64:	28 f4       	brcc	.+10     	; 0x3b70 <TimerAllocError+0x32>
    3b66:	90 e0       	ldi	r25, 0x00	; 0
    3b68:	80 91 ce 02 	lds	r24, 0x02CE
    3b6c:	80 32       	cpi	r24, 0x20	; 32
    3b6e:	08 f0       	brcs	.+2      	; 0x3b72 <TimerAllocError+0x34>
    3b70:	91 e0       	ldi	r25, 0x01	; 1
		 Timer8AllocErr() || Timer16AllocErr() || Timer32AllocErr() );
}
    3b72:	89 2f       	mov	r24, r25
    3b74:	08 95       	ret

00003b76 <ScanCycleInit>:
}

uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    3b76:	80 91 cf 02 	lds	r24, 0x02CF
	VacantTimer8Sys += n;
    3b7a:	8f 5f       	subi	r24, 0xFF	; 255
    3b7c:	80 93 cf 02 	sts	0x02CF, r24
    3b80:	81 50       	subi	r24, 0x01	; 1

// ~~~~~~~~~~~~~~~~
void
ScanCycleInit(void)
{
	TD_Scan = Timer8SysAlloc(1);
    3b82:	80 93 ce 04 	sts	0x04CE, r24
	StartTimer8(TD_Scan, 0xFF);
    3b86:	6f ef       	ldi	r22, 0xFF	; 255
    3b88:	0e 94 fa 1a 	call	0x35f4	; 0x35f4 <StartTimer8>
}
    3b8c:	08 95       	ret

00003b8e <__vector_17>:
#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
	ISR(TIMER1_COMPA_vect)
#elif defined (__AVR_ATxmega128A1__)
	ISR(TCC0_OVF_vect)
#endif
{
    3b8e:	1f 92       	push	r1
    3b90:	0f 92       	push	r0
    3b92:	0f b6       	in	r0, 0x3f	; 63
    3b94:	0f 92       	push	r0
    3b96:	0b b6       	in	r0, 0x3b	; 59
    3b98:	0f 92       	push	r0
    3b9a:	11 24       	eor	r1, r1
    3b9c:	2f 93       	push	r18
    3b9e:	4f 93       	push	r20
    3ba0:	5f 93       	push	r21
    3ba2:	6f 93       	push	r22
    3ba4:	7f 93       	push	r23
    3ba6:	8f 93       	push	r24
    3ba8:	9f 93       	push	r25
    3baa:	af 93       	push	r26
    3bac:	bf 93       	push	r27
    3bae:	ef 93       	push	r30
    3bb0:	ff 93       	push	r31
	TickCounter++;
    3bb2:	80 91 cf 04 	lds	r24, 0x04CF
    3bb6:	8f 5f       	subi	r24, 0xFF	; 255
    3bb8:	80 93 cf 04 	sts	0x04CF, r24
    3bbc:	40 e0       	ldi	r20, 0x00	; 0
    3bbe:	50 e0       	ldi	r21, 0x00	; 0
	uint8_t i;
	for (i=0; i<Timer8_ISR_TotNumber; i++)
			if (!(Timer8_ISR_Flg[i/8] &(1<<i%8)) && --Timer8_ISR[i]==0)
				Timer8_ISR_Flg[i/8] |=(1<<i%8);
    3bc0:	a1 e0       	ldi	r26, 0x01	; 1
    3bc2:	b0 e0       	ldi	r27, 0x00	; 0
#endif
{
	TickCounter++;
	uint8_t i;
	for (i=0; i<Timer8_ISR_TotNumber; i++)
			if (!(Timer8_ISR_Flg[i/8] &(1<<i%8)) && --Timer8_ISR[i]==0)
    3bc4:	80 91 ad 04 	lds	r24, 0x04AD
    3bc8:	ba 01       	movw	r22, r20
    3bca:	67 70       	andi	r22, 0x07	; 7
    3bcc:	70 70       	andi	r23, 0x00	; 0
    3bce:	90 e0       	ldi	r25, 0x00	; 0
    3bd0:	06 2e       	mov	r0, r22
    3bd2:	02 c0       	rjmp	.+4      	; 0x3bd8 <__vector_17+0x4a>
    3bd4:	95 95       	asr	r25
    3bd6:	87 95       	ror	r24
    3bd8:	0a 94       	dec	r0
    3bda:	e2 f7       	brpl	.-8      	; 0x3bd4 <__vector_17+0x46>
    3bdc:	80 fd       	sbrc	r24, 0
    3bde:	14 c0       	rjmp	.+40     	; 0x3c08 <__vector_17+0x7a>
    3be0:	fa 01       	movw	r30, r20
    3be2:	e3 51       	subi	r30, 0x13	; 19
    3be4:	fd 4f       	sbci	r31, 0xFD	; 253
    3be6:	80 81       	ld	r24, Z
    3be8:	81 50       	subi	r24, 0x01	; 1
    3bea:	80 83       	st	Z, r24
    3bec:	80 81       	ld	r24, Z
    3bee:	88 23       	and	r24, r24
    3bf0:	59 f4       	brne	.+22     	; 0x3c08 <__vector_17+0x7a>
				Timer8_ISR_Flg[i/8] |=(1<<i%8);
    3bf2:	20 91 ad 04 	lds	r18, 0x04AD
    3bf6:	cd 01       	movw	r24, r26
    3bf8:	02 c0       	rjmp	.+4      	; 0x3bfe <__vector_17+0x70>
    3bfa:	88 0f       	add	r24, r24
    3bfc:	99 1f       	adc	r25, r25
    3bfe:	6a 95       	dec	r22
    3c00:	e2 f7       	brpl	.-8      	; 0x3bfa <__vector_17+0x6c>
    3c02:	28 2b       	or	r18, r24
    3c04:	20 93 ad 04 	sts	0x04AD, r18
    3c08:	4f 5f       	subi	r20, 0xFF	; 255
    3c0a:	5f 4f       	sbci	r21, 0xFF	; 255
	ISR(TCC0_OVF_vect)
#endif
{
	TickCounter++;
	uint8_t i;
	for (i=0; i<Timer8_ISR_TotNumber; i++)
    3c0c:	48 30       	cpi	r20, 0x08	; 8
    3c0e:	51 05       	cpc	r21, r1
    3c10:	c9 f6       	brne	.-78     	; 0x3bc4 <__vector_17+0x36>
				Timer8_ISR_Flg[i/8] |=(1<<i%8);

	#ifdef HIGH_SPEED_COUNTER
		HSC_Process();
	#endif
}
    3c12:	ff 91       	pop	r31
    3c14:	ef 91       	pop	r30
    3c16:	bf 91       	pop	r27
    3c18:	af 91       	pop	r26
    3c1a:	9f 91       	pop	r25
    3c1c:	8f 91       	pop	r24
    3c1e:	7f 91       	pop	r23
    3c20:	6f 91       	pop	r22
    3c22:	5f 91       	pop	r21
    3c24:	4f 91       	pop	r20
    3c26:	2f 91       	pop	r18
    3c28:	0f 90       	pop	r0
    3c2a:	0b be       	out	0x3b, r0	; 59
    3c2c:	0f 90       	pop	r0
    3c2e:	0f be       	out	0x3f, r0	; 63
    3c30:	0f 90       	pop	r0
    3c32:	1f 90       	pop	r1
    3c34:	18 95       	reti

00003c36 <TimeCycle>:
// ~~~~~~~~~~~~
void
TimeCycle(void)
{
	// WDT
	wdt_reset();
    3c36:	a8 95       	wdr

	// Scan cycle
	ScanCount++;
    3c38:	80 91 6e 07 	lds	r24, 0x076E
    3c3c:	90 91 6f 07 	lds	r25, 0x076F
    3c40:	01 96       	adiw	r24, 0x01	; 1
    3c42:	90 93 6f 07 	sts	0x076F, r25
    3c46:	80 93 6e 07 	sts	0x076E, r24
	if ((ScanCycle=0xFF-Timer8[TD_Scan])>MaxScanCycle)
    3c4a:	90 91 ce 04 	lds	r25, 0x04CE
    3c4e:	e9 2f       	mov	r30, r25
    3c50:	f0 e0       	ldi	r31, 0x00	; 0
    3c52:	eb 50       	subi	r30, 0x0B	; 11
    3c54:	fd 4f       	sbci	r31, 0xFD	; 253
    3c56:	e0 81       	ld	r30, Z
    3c58:	e0 95       	com	r30
    3c5a:	e0 93 6a 07 	sts	0x076A, r30
    3c5e:	80 91 af 06 	lds	r24, 0x06AF
    3c62:	8e 17       	cp	r24, r30
    3c64:	10 f4       	brcc	.+4      	; 0x3c6a <TimeCycle+0x34>
		MaxScanCycle = ScanCycle;
    3c66:	e0 93 af 06 	sts	0x06AF, r30
	StartTimer8(TD_Scan, 0xFF);
    3c6a:	89 2f       	mov	r24, r25
    3c6c:	6f ef       	ldi	r22, 0xFF	; 255
    3c6e:	0e 94 fa 1a 	call	0x35f4	; 0x35f4 <StartTimer8>
}
    3c72:	08 95       	ret

00003c74 <MaxScanCycle_Clear>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
void
MaxScanCycle_Clear(void)
{
	MaxScanCycle = 0;
    3c74:	10 92 af 06 	sts	0x06AF, r1
}
    3c78:	08 95       	ret

00003c7a <Delay_ms>:

// ~~~~~~~~~~~~~~~~~~~~
void
Delay_ms(uint8_t Delay)
{
	while (Delay--)
    3c7a:	88 23       	and	r24, r24
    3c7c:	39 f0       	breq	.+14     	; 0x3c8c <Delay_ms+0x12>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3c7e:	20 ea       	ldi	r18, 0xA0	; 160
    3c80:	3f e0       	ldi	r19, 0x0F	; 15
    3c82:	f9 01       	movw	r30, r18
    3c84:	31 97       	sbiw	r30, 0x01	; 1
    3c86:	f1 f7       	brne	.-4      	; 0x3c84 <Delay_ms+0xa>
    3c88:	81 50       	subi	r24, 0x01	; 1
    3c8a:	d9 f7       	brne	.-10     	; 0x3c82 <Delay_ms+0x8>
    3c8c:	08 95       	ret

00003c8e <Delay_us>:
{
	/*uint8_t i;
	for(i=Delay/Delay_us_Max; i; i--)
		_delay_us(Delay_us_Max);*/
	//_delay_us(Delay%Delay_us_Max);
	Delay *= .8;	// By trial
    3c8e:	a0 e0       	ldi	r26, 0x00	; 0
    3c90:	b0 e0       	ldi	r27, 0x00	; 0
    3c92:	bc 01       	movw	r22, r24
    3c94:	cd 01       	movw	r24, r26
    3c96:	0e 94 d6 7d 	call	0xfbac	; 0xfbac <__floatunsisf>
    3c9a:	2d ec       	ldi	r18, 0xCD	; 205
    3c9c:	3c ec       	ldi	r19, 0xCC	; 204
    3c9e:	4c e4       	ldi	r20, 0x4C	; 76
    3ca0:	5f e3       	ldi	r21, 0x3F	; 63
    3ca2:	0e 94 13 7e 	call	0xfc26	; 0xfc26 <__mulsf3>
    3ca6:	0e 94 ab 82 	call	0x10556	; 0x10556 <__fixunssfsi>
    3caa:	cb 01       	movw	r24, r22
	while (Delay--)
    3cac:	67 2b       	or	r22, r23
    3cae:	31 f0       	breq	.+12     	; 0x3cbc <Delay_us+0x2e>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3cb0:	35 e0       	ldi	r19, 0x05	; 5
    3cb2:	23 2f       	mov	r18, r19
    3cb4:	2a 95       	dec	r18
    3cb6:	f1 f7       	brne	.-4      	; 0x3cb4 <Delay_us+0x26>
    3cb8:	01 97       	sbiw	r24, 0x01	; 1
    3cba:	d9 f7       	brne	.-10     	; 0x3cb2 <Delay_us+0x24>
    3cbc:	08 95       	ret

00003cbe <MB_PLC_Init>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#if defined vmd2_3
	void MB_PLC_Init(void)
	{
		// RS485
		DDRE |=(1<<PE2); PORTE &=~(1<<PE2);
    3cbe:	6a 9a       	sbi	0x0d, 2	; 13
    3cc0:	72 98       	cbi	0x0e, 2	; 14
		DDRD |=(1<<PD4); PORTD &=~(1<<PD4);
    3cc2:	54 9a       	sbi	0x0a, 4	; 10
    3cc4:	5c 98       	cbi	0x0b, 4	; 11
	#ifndef GSM
		DDRL |=(1<<PL5); PORTL &=~(1<<PL5);
	#endif
	}
    3cc6:	08 95       	ret

00003cc8 <RS485_0>:
	void RS485_0(void) {PORTE ^=(1<<PE2);}
    3cc8:	8e b1       	in	r24, 0x0e	; 14
    3cca:	94 e0       	ldi	r25, 0x04	; 4
    3ccc:	89 27       	eor	r24, r25
    3cce:	8e b9       	out	0x0e, r24	; 14
    3cd0:	08 95       	ret

00003cd2 <RS485_1>:
	void RS485_1(void) {PORTD ^=(1<<PD4);}
    3cd2:	8b b1       	in	r24, 0x0b	; 11
    3cd4:	90 e1       	ldi	r25, 0x10	; 16
    3cd6:	89 27       	eor	r24, r25
    3cd8:	8b b9       	out	0x0b, r24	; 11
    3cda:	08 95       	ret

00003cdc <MB_LED0>:
	}
	void RS485_0(void) {PORTE ^=(1<<PE2);}
	void RS485_1(void) {PORTC ^=(1<<PC0);}
#endif

void MB_LED0(void) {}
    3cdc:	08 95       	ret

00003cde <MB_LED1>:
void MB_LED1(void) {}
    3cde:	08 95       	ret

00003ce0 <MB_LED2>:
void MB_LED2(void) {}
    3ce0:	08 95       	ret

00003ce2 <MB_LED_Err_On_0>:

void MB_LED_Err_On_0(void)	{}
    3ce2:	08 95       	ret

00003ce4 <MB_LED_Err_Off_0>:
void MB_LED_Err_Off_0(void)	{}
    3ce4:	08 95       	ret

00003ce6 <MB_LED_Err_On_1>:
void MB_LED_Err_On_1(void)	{}
    3ce6:	08 95       	ret

00003ce8 <MB_LED_Err_Off_1>:
void MB_LED_Err_Off_1(void)	{}	
    3ce8:	08 95       	ret

00003cea <MB_LED_Err_On_2>:
void MB_LED_Err_On_2(void)	{}
    3cea:	08 95       	ret

00003cec <MB_LED_Err_Off_2>:
void MB_LED_Err_Off_2(void)	{}
    3cec:	08 95       	ret

00003cee <PWM_Init>:

// ~~~~~~~~~~~
void
PWM_Init(void)
{
	TCCR3A = (1<<COM3A1) | (0<<COM3A0) | (1<<COM3B1) | (0<<COM3B0) | (0<<COM3C1) | (0<<COM3C0) | (1<<WGM31) | (0<<WGM30);
    3cee:	32 ea       	ldi	r19, 0xA2	; 162
    3cf0:	30 93 90 00 	sts	0x0090, r19
	TCCR3B = (0<<CS32) | (0<<CS31) | (1<<CS30) | (1<<WGM33) | (1<<WGM32);	// Fpwm = 244Hz
    3cf4:	29 e1       	ldi	r18, 0x19	; 25
    3cf6:	20 93 91 00 	sts	0x0091, r18
	ICR3 = PWM_PERIOD_TC3;
    3cfa:	8f ef       	ldi	r24, 0xFF	; 255
    3cfc:	9f ef       	ldi	r25, 0xFF	; 255
    3cfe:	90 93 97 00 	sts	0x0097, r25
    3d02:	80 93 96 00 	sts	0x0096, r24
	DDRE |= (1<<PE3) | (1<<PE4);
    3d06:	8d b1       	in	r24, 0x0d	; 13
    3d08:	88 61       	ori	r24, 0x18	; 24
    3d0a:	8d b9       	out	0x0d, r24	; 13

	TCCR5A = (1<<COM5A1) | (0<<COM5A0) | (1<<COM5B1) | (0<<COM5B0) | (0<<COM5C1) | (0<<COM5C0) | (1<<WGM51) | (0<<WGM50);
    3d0c:	30 93 20 01 	sts	0x0120, r19
	TCCR5B = (0<<CS52) | (0<<CS51) | (1<<CS50) | (1<<WGM53) | (1<<WGM52);	// Fpwm = 244Hz
    3d10:	20 93 21 01 	sts	0x0121, r18
	ICR5 = PWM_PERIOD_TC5;
    3d14:	8e e7       	ldi	r24, 0x7E	; 126
    3d16:	9c e0       	ldi	r25, 0x0C	; 12
    3d18:	90 93 27 01 	sts	0x0127, r25
    3d1c:	80 93 26 01 	sts	0x0126, r24
	DDRL |= (1<<PL3) | (1<<PL4);
    3d20:	ea e0       	ldi	r30, 0x0A	; 10
    3d22:	f1 e0       	ldi	r31, 0x01	; 1
    3d24:	80 81       	ld	r24, Z
    3d26:	88 61       	ori	r24, 0x18	; 24
    3d28:	80 83       	st	Z, r24
}
    3d2a:	08 95       	ret

00003d2c <PWM_Out>:
void
PWM_Out(void)
{
	uint16_t Buf;

	Buf = Coef_AO_PWM_TC3*DAC_Output[0];
    3d2c:	60 91 8b 07 	lds	r22, 0x078B
    3d30:	70 91 8c 07 	lds	r23, 0x078C
    3d34:	80 e0       	ldi	r24, 0x00	; 0
    3d36:	90 e0       	ldi	r25, 0x00	; 0
    3d38:	0e 94 d6 7d 	call	0xfbac	; 0xfbac <__floatunsisf>
    3d3c:	28 e8       	ldi	r18, 0x88	; 136
    3d3e:	3f e1       	ldi	r19, 0x1F	; 31
    3d40:	40 e8       	ldi	r20, 0x80	; 128
    3d42:	52 e4       	ldi	r21, 0x42	; 66
    3d44:	0e 94 13 7e 	call	0xfc26	; 0xfc26 <__mulsf3>
    3d48:	0e 94 ab 82 	call	0x10556	; 0x10556 <__fixunssfsi>
    3d4c:	26 2f       	mov	r18, r22

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3d4e:	9f b7       	in	r25, 0x3f	; 63
	cli();
    3d50:	f8 94       	cli
	IntOff();
	OCR3AH = Buf>>8;
    3d52:	70 93 99 00 	sts	0x0099, r23
	OCR3AL = Buf;
    3d56:	20 93 98 00 	sts	0x0098, r18

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3d5a:	97 ff       	sbrs	r25, 7
    3d5c:	01 c0       	rjmp	.+2      	; 0x3d60 <PWM_Out+0x34>
		sei();
    3d5e:	78 94       	sei
	IntOn();

	Buf = Coef_AO_PWM_TC3*DAC_Output[1];
    3d60:	60 91 8d 07 	lds	r22, 0x078D
    3d64:	70 91 8e 07 	lds	r23, 0x078E
    3d68:	80 e0       	ldi	r24, 0x00	; 0
    3d6a:	90 e0       	ldi	r25, 0x00	; 0
    3d6c:	0e 94 d6 7d 	call	0xfbac	; 0xfbac <__floatunsisf>
    3d70:	28 e8       	ldi	r18, 0x88	; 136
    3d72:	3f e1       	ldi	r19, 0x1F	; 31
    3d74:	40 e8       	ldi	r20, 0x80	; 128
    3d76:	52 e4       	ldi	r21, 0x42	; 66
    3d78:	0e 94 13 7e 	call	0xfc26	; 0xfc26 <__mulsf3>
    3d7c:	0e 94 ab 82 	call	0x10556	; 0x10556 <__fixunssfsi>
    3d80:	26 2f       	mov	r18, r22

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3d82:	9f b7       	in	r25, 0x3f	; 63
	cli();
    3d84:	f8 94       	cli
	IntOff();
	OCR3BH = Buf>>8;
    3d86:	70 93 9b 00 	sts	0x009B, r23
	OCR3BL = Buf;
    3d8a:	20 93 9a 00 	sts	0x009A, r18

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3d8e:	97 ff       	sbrs	r25, 7
    3d90:	01 c0       	rjmp	.+2      	; 0x3d94 <PWM_Out+0x68>
		sei();
    3d92:	78 94       	sei
	IntOn();


	Buf = Coef_AO_PWM_TC5*DAC_Output[2];
    3d94:	60 91 8f 07 	lds	r22, 0x078F
    3d98:	70 91 90 07 	lds	r23, 0x0790
    3d9c:	80 e0       	ldi	r24, 0x00	; 0
    3d9e:	90 e0       	ldi	r25, 0x00	; 0
    3da0:	0e 94 d6 7d 	call	0xfbac	; 0xfbac <__floatunsisf>
    3da4:	25 e0       	ldi	r18, 0x05	; 5
    3da6:	32 e1       	ldi	r19, 0x12	; 18
    3da8:	48 e4       	ldi	r20, 0x48	; 72
    3daa:	50 e4       	ldi	r21, 0x40	; 64
    3dac:	0e 94 13 7e 	call	0xfc26	; 0xfc26 <__mulsf3>
    3db0:	0e 94 ab 82 	call	0x10556	; 0x10556 <__fixunssfsi>
    3db4:	26 2f       	mov	r18, r22

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3db6:	9f b7       	in	r25, 0x3f	; 63
	cli();
    3db8:	f8 94       	cli
	IntOff();
	OCR5AH = Buf>>8;
    3dba:	70 93 29 01 	sts	0x0129, r23
	OCR5AL = Buf;
    3dbe:	20 93 28 01 	sts	0x0128, r18

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3dc2:	97 ff       	sbrs	r25, 7
    3dc4:	01 c0       	rjmp	.+2      	; 0x3dc8 <PWM_Out+0x9c>
		sei();
    3dc6:	78 94       	sei
	IntOn();

	Buf = Coef_AO_PWM_TC5*DAC_Output[3];
    3dc8:	60 91 91 07 	lds	r22, 0x0791
    3dcc:	70 91 92 07 	lds	r23, 0x0792
    3dd0:	80 e0       	ldi	r24, 0x00	; 0
    3dd2:	90 e0       	ldi	r25, 0x00	; 0
    3dd4:	0e 94 d6 7d 	call	0xfbac	; 0xfbac <__floatunsisf>
    3dd8:	25 e0       	ldi	r18, 0x05	; 5
    3dda:	32 e1       	ldi	r19, 0x12	; 18
    3ddc:	48 e4       	ldi	r20, 0x48	; 72
    3dde:	50 e4       	ldi	r21, 0x40	; 64
    3de0:	0e 94 13 7e 	call	0xfc26	; 0xfc26 <__mulsf3>
    3de4:	0e 94 ab 82 	call	0x10556	; 0x10556 <__fixunssfsi>
    3de8:	26 2f       	mov	r18, r22

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3dea:	8f b7       	in	r24, 0x3f	; 63
    3dec:	80 78       	andi	r24, 0x80	; 128
    3dee:	80 93 ec 02 	sts	0x02EC, r24
	cli();
    3df2:	f8 94       	cli
	IntOff();
	OCR5BH = Buf>>8;
    3df4:	70 93 2b 01 	sts	0x012B, r23
	OCR5BL = Buf;
    3df8:	20 93 2a 01 	sts	0x012A, r18

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3dfc:	88 23       	and	r24, r24
    3dfe:	09 f0       	breq	.+2      	; 0x3e02 <PWM_Out+0xd6>
		sei();
    3e00:	78 94       	sei
    3e02:	08 95       	ret

00003e04 <ADC_In>:
}

// ~~~~~~~~~
uint8_t
ADC_In(void)
{
    3e04:	1f 93       	push	r17

// ~~~~~~~~~~~~~~~
inline static void
ADC_Select(void)
{
	SPCR |=(1<<CPOL);
    3e06:	8c b5       	in	r24, 0x2c	; 44
    3e08:	88 60       	ori	r24, 0x08	; 8
    3e0a:	8c bd       	out	0x2c, r24	; 44
	#ifdef CS_ADC
		cli();
    3e0c:	f8 94       	cli
		PortCS_ADC &=~CS_ADC;
    3e0e:	80 91 02 01 	lds	r24, 0x0102
    3e12:	87 7f       	andi	r24, 0xF7	; 247
    3e14:	80 93 02 01 	sts	0x0102, r24
		sei();
    3e18:	78 94       	sei
ADC_In(void)
{
	uint8_t Chan = ADC_Reg;
	ADC_Select();

	switch(ADC_Phase) {
    3e1a:	80 91 22 0b 	lds	r24, 0x0B22
    3e1e:	81 30       	cpi	r24, 0x01	; 1
    3e20:	09 f4       	brne	.+2      	; 0x3e24 <ADC_In+0x20>
    3e22:	ec c0       	rjmp	.+472    	; 0x3ffc <ADC_In+0x1f8>
    3e24:	81 30       	cpi	r24, 0x01	; 1
    3e26:	30 f5       	brcc	.+76     	; 0x3e74 <ADC_In+0x70>

// ~~~~~~~~~~~~~~~
inline static void
ADC_Rst(void)
{
	cli();
    3e28:	f8 94       	cli
	PortRESET_PER &=~RESET_PER;
    3e2a:	80 91 02 01 	lds	r24, 0x0102
    3e2e:	8f 7e       	andi	r24, 0xEF	; 239
    3e30:	80 93 02 01 	sts	0x0102, r24
	sei();
    3e34:	78 94       	sei
    3e36:	85 e0       	ldi	r24, 0x05	; 5
    3e38:	8a 95       	dec	r24
    3e3a:	f1 f7       	brne	.-4      	; 0x3e38 <ADC_In+0x34>
	_delay_us(1);							// 100 ns needs
	cli();
    3e3c:	f8 94       	cli
	PortRESET_PER |=RESET_PER;
    3e3e:	80 91 02 01 	lds	r24, 0x0102
    3e42:	80 61       	ori	r24, 0x10	; 16
    3e44:	80 93 02 01 	sts	0x0102, r24
	sei();
    3e48:	78 94       	sei
	StartTimer8_ISR(TD_ADC, 4);		// 16 ms needs
    3e4a:	80 91 f5 06 	lds	r24, 0x06F5
    3e4e:	64 e0       	ldi	r22, 0x04	; 4
	WaitSPI();
	SPDR = SR;
	WaitSPI();
	SPDR = SetpVal(CaliMode) &~ADC_FSYNC;
	WaitSPI();
	StartTimer8_ISR(TD_ADC, 36);
    3e50:	0e 94 bf 1a 	call	0x357e	; 0x357e <StartTimer8_ISR>
	ADC_Phase++;
    3e54:	80 91 22 0b 	lds	r24, 0x0B22
    3e58:	8f 5f       	subi	r24, 0xFF	; 255
    3e5a:	80 93 22 0b 	sts	0x0B22, r24
    3e5e:	17 e0       	ldi	r17, 0x07	; 7
// ~~~~~~~~~~~~~~~
inline static void
ADC_Desel(void)
{
	#ifdef CS_ADC
		cli();
    3e60:	f8 94       	cli
		PortCS_ADC |=CS_ADC;
    3e62:	80 91 02 01 	lds	r24, 0x0102
    3e66:	88 60       	ori	r24, 0x08	; 8
    3e68:	80 93 02 01 	sts	0x0102, r24
		sei();
    3e6c:	78 94       	sei
			IntOn();
		}
	#endif

	return Chan;
}
    3e6e:	81 2f       	mov	r24, r17
    3e70:	1f 91       	pop	r17
    3e72:	08 95       	ret
ADC_In(void)
{
	uint8_t Chan = ADC_Reg;
	ADC_Select();

	switch(ADC_Phase) {
    3e74:	82 30       	cpi	r24, 0x02	; 2
    3e76:	09 f4       	brne	.+2      	; 0x3e7a <ADC_In+0x76>
    3e78:	d2 c0       	rjmp	.+420    	; 0x401e <ADC_In+0x21a>
    3e7a:	83 30       	cpi	r24, 0x03	; 3
    3e7c:	11 f0       	breq	.+4      	; 0x3e82 <ADC_In+0x7e>
				StartTimer8_ISR(TD_ADC, ADC10ms);
			}
		}
		else if(Timer8Stopp_ISR(TD_ADC)) {
			ADC_ReadFail++;
			ADC_Phase = RST;
    3e7e:	17 e0       	ldi	r17, 0x07	; 7
    3e80:	ef cf       	rjmp	.-34     	; 0x3e60 <ADC_In+0x5c>
		default:
			SPDR = ADC_IN1(Reg);
			break;
		}
	#else
		SPDR = ADC_IN1(Reg);
    3e82:	88 e0       	ldi	r24, 0x08	; 8
    3e84:	8e bd       	out	0x2e, r24	; 46

// ~~~~~~~~~~~
static void
WaitADC2(void)
{
	WaitSPI();
    3e86:	0d b4       	in	r0, 0x2d	; 45
    3e88:	07 fe       	sbrs	r0, 7
    3e8a:	fd cf       	rjmp	.-6      	; 0x3e86 <ADC_In+0x82>
	SPDR = 0;
    3e8c:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    3e8e:	0d b4       	in	r0, 0x2d	; 45
    3e90:	07 fe       	sbrs	r0, 7
    3e92:	fd cf       	rjmp	.-6      	; 0x3e8e <ADC_In+0x8a>
			StartTimer8_ISR(TD_ADC, ADC10ms);
		break;
	case READ:
		ADC_IN(CommReg);
		WaitADC2();
		if(!(SPDR &ADC_DRDY)) {
    3e94:	0e b4       	in	r0, 0x2e	; 46
    3e96:	07 fc       	sbrc	r0, 7
    3e98:	da c0       	rjmp	.+436    	; 0x404e <ADC_In+0x24a>
		default:
			SPDR = ADC_IN1(Reg);
			break;
		}
	#else
		SPDR = ADC_IN1(Reg);
    3e9a:	88 e3       	ldi	r24, 0x38	; 56
    3e9c:	8e bd       	out	0x2e, r24	; 46

// ~~~~~~~~~~~
static void
WaitADC2(void)
{
	WaitSPI();
    3e9e:	0d b4       	in	r0, 0x2d	; 45
    3ea0:	07 fe       	sbrs	r0, 7
    3ea2:	fd cf       	rjmp	.-6      	; 0x3e9e <ADC_In+0x9a>
	SPDR = 0;
    3ea4:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    3ea6:	0d b4       	in	r0, 0x2d	; 45
    3ea8:	07 fe       	sbrs	r0, 7
    3eaa:	fd cf       	rjmp	.-6      	; 0x3ea6 <ADC_In+0xa2>
		WaitADC2();
		if(!(SPDR &ADC_DRDY)) {
			uint16_t Buf;
			ADC_IN(DataReg);
			WaitADC2();
			Buf = SPDR<<8;
    3eac:	3e b5       	in	r19, 0x2e	; 46

// ~~~~~~~~~~~
static void
WaitADC1(void)
{
	SPDR = 0;
    3eae:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    3eb0:	0d b4       	in	r0, 0x2d	; 45
    3eb2:	07 fe       	sbrs	r0, 7
    3eb4:	fd cf       	rjmp	.-6      	; 0x3eb0 <ADC_In+0xac>
			uint16_t Buf;
			ADC_IN(DataReg);
			WaitADC2();
			Buf = SPDR<<8;
			WaitADC1();
			Buf += SPDR;
    3eb6:	2e b5       	in	r18, 0x2e	; 46
		WaitADC2();
		if(!(SPDR &ADC_DRDY)) {
			uint16_t Buf;
			ADC_IN(DataReg);
			WaitADC2();
			Buf = SPDR<<8;
    3eb8:	93 2f       	mov	r25, r19
    3eba:	80 e0       	ldi	r24, 0x00	; 0
			WaitADC1();
			Buf += SPDR;
    3ebc:	ac 01       	movw	r20, r24
    3ebe:	42 0f       	add	r20, r18
    3ec0:	51 1d       	adc	r21, r1
    3ec2:	9a 01       	movw	r18, r20
			#ifdef ADC_Ref_Chan
				if (ADC_Chan==sizeof(Mux)-1 && ADC_Input[sizeof(Mux)-1]!=0 && (Buf<ADC_Ref-ADC_Ref_d || Buf>ADC_Ref+ADC_Ref_d)) {
    3ec4:	10 91 ca 08 	lds	r17, 0x08CA
    3ec8:	16 30       	cpi	r17, 0x06	; 6
    3eca:	09 f4       	brne	.+2      	; 0x3ece <ADC_In+0xca>
    3ecc:	19 c1       	rjmp	.+562    	; 0x4100 <ADC_In+0x2fc>
		default:
			SPDR = ADC_IN1(Reg);
			break;
		}
	#else
		SPDR = ADC_IN1(Reg);
    3ece:	80 e1       	ldi	r24, 0x10	; 16
    3ed0:	8e bd       	out	0x2e, r24	; 46
{
	Scale *Scl;
	int8_t i;

	ADC_IN(SetpReg);
	WaitSPI();
    3ed2:	0d b4       	in	r0, 0x2d	; 45
    3ed4:	07 fe       	sbrs	r0, 7
    3ed6:	fd cf       	rjmp	.-6      	; 0x3ed2 <ADC_In+0xce>
	SPDR = SetpVal(NormMode) |ADC_FSYNC;
    3ed8:	87 e0       	ldi	r24, 0x07	; 7
    3eda:	8e bd       	out	0x2e, r24	; 46
	WaitSPI();
    3edc:	0d b4       	in	r0, 0x2d	; 45
    3ede:	07 fe       	sbrs	r0, 7
    3ee0:	fd cf       	rjmp	.-6      	; 0x3edc <ADC_In+0xd8>
	ADC_Time = ADC10ms-Timer8_ISR[TD_ADC];
    3ee2:	40 91 f5 06 	lds	r20, 0x06F5
    3ee6:	e4 2f       	mov	r30, r20
    3ee8:	f0 e0       	ldi	r31, 0x00	; 0
    3eea:	e3 51       	subi	r30, 0x13	; 19
    3eec:	fd 4f       	sbci	r31, 0xFD	; 253
    3eee:	90 81       	ld	r25, Z
    3ef0:	84 e1       	ldi	r24, 0x14	; 20
    3ef2:	89 1b       	sub	r24, r25
    3ef4:	80 93 b1 06 	sts	0x06B1, r24
		default:
			SPDR = ADC_IN1(Reg);
			break;
		}
	#else
		SPDR = ADC_IN1(Reg);
    3ef8:	88 e6       	ldi	r24, 0x68	; 104
    3efa:	8e bd       	out	0x2e, r24	; 46

// ~~~~~~~~~~~
static void
WaitADC2(void)
{
	WaitSPI();
    3efc:	0d b4       	in	r0, 0x2d	; 45
    3efe:	07 fe       	sbrs	r0, 7
    3f00:	fd cf       	rjmp	.-6      	; 0x3efc <ADC_In+0xf8>
	SPDR = 0;
    3f02:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    3f04:	0d b4       	in	r0, 0x2d	; 45
    3f06:	07 fe       	sbrs	r0, 7
    3f08:	fd cf       	rjmp	.-6      	; 0x3f04 <ADC_In+0x100>
    3f0a:	e7 e2       	ldi	r30, 0x27	; 39
    3f0c:	fc e0       	ldi	r31, 0x0C	; 12
		Scl=&ADC_Scale1;
	#endif
	ADC_IN(ZeroReg);
	WaitADC2();
	for(i=2; i>=0; i--) {
		Scl->Zero[i] = SPDR;
    3f0e:	8e b5       	in	r24, 0x2e	; 46
    3f10:	80 83       	st	Z, r24

// ~~~~~~~~~~~
static void
WaitADC1(void)
{
	SPDR = 0;
    3f12:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    3f14:	0d b4       	in	r0, 0x2d	; 45
    3f16:	07 fe       	sbrs	r0, 7
    3f18:	fd cf       	rjmp	.-6      	; 0x3f14 <ADC_In+0x110>
    3f1a:	31 97       	sbiw	r30, 0x01	; 1
	#else
		Scl=&ADC_Scale1;
	#endif
	ADC_IN(ZeroReg);
	WaitADC2();
	for(i=2; i>=0; i--) {
    3f1c:	8c e0       	ldi	r24, 0x0C	; 12
    3f1e:	e4 32       	cpi	r30, 0x24	; 36
    3f20:	f8 07       	cpc	r31, r24
    3f22:	a9 f7       	brne	.-22     	; 0x3f0e <ADC_In+0x10a>

// ~~~~~~~~~~~
static void
WaitADC1(void)
{
	SPDR = 0;
    3f24:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    3f26:	0d b4       	in	r0, 0x2d	; 45
    3f28:	07 fe       	sbrs	r0, 7
    3f2a:	fd cf       	rjmp	.-6      	; 0x3f26 <ADC_In+0x122>
		default:
			SPDR = ADC_IN1(Reg);
			break;
		}
	#else
		SPDR = ADC_IN1(Reg);
    3f2c:	88 e7       	ldi	r24, 0x78	; 120
    3f2e:	8e bd       	out	0x2e, r24	; 46

// ~~~~~~~~~~~
static void
WaitADC2(void)
{
	WaitSPI();
    3f30:	0d b4       	in	r0, 0x2d	; 45
    3f32:	07 fe       	sbrs	r0, 7
    3f34:	fd cf       	rjmp	.-6      	; 0x3f30 <ADC_In+0x12c>
	SPDR = 0;
    3f36:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    3f38:	0d b4       	in	r0, 0x2d	; 45
    3f3a:	07 fe       	sbrs	r0, 7
    3f3c:	fd cf       	rjmp	.-6      	; 0x3f38 <ADC_In+0x134>
    3f3e:	ea e2       	ldi	r30, 0x2A	; 42
    3f40:	fc e0       	ldi	r31, 0x0C	; 12
	}
	WaitADC1();
	ADC_IN(FullReg);
	WaitADC2();
	for(i=2; i>=0; i--) {
		Scl->Full[i] = SPDR;
    3f42:	8e b5       	in	r24, 0x2e	; 46
    3f44:	80 83       	st	Z, r24

// ~~~~~~~~~~~
static void
WaitADC1(void)
{
	SPDR = 0;
    3f46:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    3f48:	0d b4       	in	r0, 0x2d	; 45
    3f4a:	07 fe       	sbrs	r0, 7
    3f4c:	fd cf       	rjmp	.-6      	; 0x3f48 <ADC_In+0x144>
    3f4e:	31 97       	sbiw	r30, 0x01	; 1
		WaitADC1();
	}
	WaitADC1();
	ADC_IN(FullReg);
	WaitADC2();
	for(i=2; i>=0; i--) {
    3f50:	5c e0       	ldi	r21, 0x0C	; 12
    3f52:	e7 32       	cpi	r30, 0x27	; 39
    3f54:	f5 07       	cpc	r31, r21
    3f56:	a9 f7       	brne	.-22     	; 0x3f42 <ADC_In+0x13e>

// ~~~~~~~~~~~
static void
WaitADC1(void)
{
	SPDR = 0;
    3f58:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    3f5a:	0d b4       	in	r0, 0x2d	; 45
    3f5c:	07 fe       	sbrs	r0, 7
    3f5e:	fd cf       	rjmp	.-6      	; 0x3f5a <ADC_In+0x156>
	for(i=2; i>=0; i--) {
		Scl->Full[i] = SPDR;
		WaitADC1();
	}
	WaitADC1();
	return Scl->Zero[2]<25 || Scl->Zero[2]>27 || Scl->Full[2]<200 || Scl->Full[2]>203;
    3f60:	80 91 27 0c 	lds	r24, 0x0C27
    3f64:	89 51       	subi	r24, 0x19	; 25
    3f66:	83 30       	cpi	r24, 0x03	; 3
    3f68:	08 f0       	brcs	.+2      	; 0x3f6c <ADC_In+0x168>
    3f6a:	85 c0       	rjmp	.+266    	; 0x4076 <ADC_In+0x272>
    3f6c:	80 91 2a 0c 	lds	r24, 0x0C2A
    3f70:	88 3c       	cpi	r24, 0xC8	; 200
    3f72:	08 f4       	brcc	.+2      	; 0x3f76 <ADC_In+0x172>
    3f74:	80 c0       	rjmp	.+256    	; 0x4076 <ADC_In+0x272>
    3f76:	8c 3c       	cpi	r24, 0xCC	; 204
    3f78:	08 f0       	brcs	.+2      	; 0x3f7c <ADC_In+0x178>
    3f7a:	7d c0       	rjmp	.+250    	; 0x4076 <ADC_In+0x272>
			if(ADC_Check()) {
				ADC_Break++;
				ADC_Phase = RST;
			}
			else {
				ADC_Input[ADC_Chan] = Buf;
    3f7c:	e1 2f       	mov	r30, r17
    3f7e:	f0 e0       	ldi	r31, 0x00	; 0
    3f80:	ee 0f       	add	r30, r30
    3f82:	ff 1f       	adc	r31, r31
    3f84:	ed 52       	subi	r30, 0x2D	; 45
    3f86:	f7 4f       	sbci	r31, 0xF7	; 247
    3f88:	31 83       	std	Z+1, r19	; 0x01
    3f8a:	20 83       	st	Z, r18

// ~~~~~~~~~~~~~~~
inline static void
SetMux(void)
{
	if(++ADC_Chan == ADC_Reg)
    3f8c:	81 2f       	mov	r24, r17
    3f8e:	8f 5f       	subi	r24, 0xFF	; 255
    3f90:	80 93 ca 08 	sts	0x08CA, r24
    3f94:	87 30       	cpi	r24, 0x07	; 7
    3f96:	11 f4       	brne	.+4      	; 0x3f9c <ADC_In+0x198>
		ADC_Chan = 0;
    3f98:	10 92 ca 08 	sts	0x08CA, r1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    3f9c:	e0 91 ca 08 	lds	r30, 0x08CA
    3fa0:	f0 e0       	ldi	r31, 0x00	; 0
    3fa2:	e4 55       	subi	r30, 0x54	; 84
    3fa4:	f0 4d       	sbci	r31, 0xD0	; 208
    3fa6:	94 91       	lpm	r25, Z+
		#if ADC_Reg>8
			if(ADC_Chan>=sizeof(Mux))
				return;
		#endif
		uint8_t Addr = prb(Mux+ADC_Chan);
		cli();
    3fa8:	f8 94       	cli
		if (Addr/4){
    3faa:	94 30       	cpi	r25, 0x04	; 4
    3fac:	08 f4       	brcc	.+2      	; 0x3fb0 <ADC_In+0x1ac>
    3fae:	ca c0       	rjmp	.+404    	; 0x4144 <ADC_In+0x340>
			Port_INH|=INH;
    3fb0:	77 9a       	sbi	0x0e, 7	; 14
			#ifdef Port_INH2
				Port_INH2 &=~INH2;
    3fb2:	80 91 02 01 	lds	r24, 0x0102
    3fb6:	8b 7f       	andi	r24, 0xFB	; 251
    3fb8:	80 93 02 01 	sts	0x0102, r24
			Port_INH &=~INH;
			#ifdef Port_INH2
				Port_INH2|=INH2;
			#endif
		}
		if (Addr%4/2)	Port_TER_B	|=TER_B;	else Port_TER_B	&=~TER_B;
    3fbc:	29 2f       	mov	r18, r25
    3fbe:	30 e0       	ldi	r19, 0x00	; 0
    3fc0:	c9 01       	movw	r24, r18
    3fc2:	83 70       	andi	r24, 0x03	; 3
    3fc4:	90 70       	andi	r25, 0x00	; 0
    3fc6:	01 96       	adiw	r24, 0x01	; 1
    3fc8:	03 97       	sbiw	r24, 0x03	; 3
    3fca:	08 f4       	brcc	.+2      	; 0x3fce <ADC_In+0x1ca>
    3fcc:	b9 c0       	rjmp	.+370    	; 0x4140 <ADC_In+0x33c>
    3fce:	76 9a       	sbi	0x0e, 6	; 14
		if (Addr%2)		Port_TER_A	|=TER_A;	else Port_TER_A	&=~TER_A;
    3fd0:	20 ff       	sbrs	r18, 0
    3fd2:	b4 c0       	rjmp	.+360    	; 0x413c <ADC_In+0x338>
    3fd4:	75 9a       	sbi	0x0e, 5	; 14
		sei();
    3fd6:	78 94       	sei
    3fd8:	85 e5       	ldi	r24, 0x55	; 85
    3fda:	8a 95       	dec	r24
    3fdc:	f1 f7       	brne	.-4      	; 0x3fda <ADC_In+0x1d6>
		default:
			SPDR = ADC_IN1(Reg);
			break;
		}
	#else
		SPDR = ADC_IN1(Reg);
    3fde:	80 e1       	ldi	r24, 0x10	; 16
    3fe0:	8e bd       	out	0x2e, r24	; 46
			else {
				ADC_Input[ADC_Chan] = Buf;
				Chan = ADC_Chan;
				SetMux();
				ADC_IN(SetpReg);
				WaitSPI();
    3fe2:	0d b4       	in	r0, 0x2d	; 45
    3fe4:	07 fe       	sbrs	r0, 7
    3fe6:	fd cf       	rjmp	.-6      	; 0x3fe2 <ADC_In+0x1de>
				SPDR = SetpVal(NormMode) &~ADC_FSYNC;
    3fe8:	86 e0       	ldi	r24, 0x06	; 6
    3fea:	8e bd       	out	0x2e, r24	; 46
				WaitSPI();
    3fec:	0d b4       	in	r0, 0x2d	; 45
    3fee:	07 fe       	sbrs	r0, 7
    3ff0:	fd cf       	rjmp	.-6      	; 0x3fec <ADC_In+0x1e8>
				StartTimer8_ISR(TD_ADC, ADC10ms);
    3ff2:	84 2f       	mov	r24, r20
    3ff4:	64 e1       	ldi	r22, 0x14	; 20
    3ff6:	0e 94 bf 1a 	call	0x357e	; 0x357e <StartTimer8_ISR>
    3ffa:	32 cf       	rjmp	.-412    	; 0x3e60 <ADC_In+0x5c>

// ~~~~~~~~~~~~~~~
inline static void
ADC_Init1(void)
{
	if(!Timer8Stopp_ISR(TD_ADC))
    3ffc:	80 91 f5 06 	lds	r24, 0x06F5
    4000:	0e 94 2b 1c 	call	0x3856	; 0x3856 <Timer8Stopp_ISR>
    4004:	88 23       	and	r24, r24
    4006:	09 f4       	brne	.+2      	; 0x400a <ADC_In+0x206>
    4008:	3a cf       	rjmp	.-396    	; 0x3e7e <ADC_In+0x7a>
    400a:	81 e0       	ldi	r24, 0x01	; 1
		return;
	uint8_t i = 0;
	while(i++<8) {	// 4 x 0xFF needs
		SPDR = 0xFF;
    400c:	9f ef       	ldi	r25, 0xFF	; 255
    400e:	9e bd       	out	0x2e, r25	; 46
		WaitSPI();
    4010:	0d b4       	in	r0, 0x2d	; 45
    4012:	07 fe       	sbrs	r0, 7
    4014:	fd cf       	rjmp	.-6      	; 0x4010 <ADC_In+0x20c>
ADC_Init1(void)
{
	if(!Timer8Stopp_ISR(TD_ADC))
		return;
	uint8_t i = 0;
	while(i++<8) {	// 4 x 0xFF needs
    4016:	88 30       	cpi	r24, 0x08	; 8
    4018:	d9 f1       	breq	.+118    	; 0x4090 <ADC_In+0x28c>
    401a:	8f 5f       	subi	r24, 0xFF	; 255
    401c:	f8 cf       	rjmp	.-16     	; 0x400e <ADC_In+0x20a>
// ~~~~~~~~~~~~~~~
static void
Calibr(uint8_t CR)
{
	static uint8_t Try;
	SPDR = CR;
    401e:	88 e0       	ldi	r24, 0x08	; 8
    4020:	8e bd       	out	0x2e, r24	; 46

// ~~~~~~~~~~~
static void
WaitADC2(void)
{
	WaitSPI();
    4022:	0d b4       	in	r0, 0x2d	; 45
    4024:	07 fe       	sbrs	r0, 7
    4026:	fd cf       	rjmp	.-6      	; 0x4022 <ADC_In+0x21e>
	SPDR = 0;
    4028:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    402a:	0d b4       	in	r0, 0x2d	; 45
    402c:	07 fe       	sbrs	r0, 7
    402e:	fd cf       	rjmp	.-6      	; 0x402a <ADC_In+0x226>
Calibr(uint8_t CR)
{
	static uint8_t Try;
	SPDR = CR;
	WaitADC2();
	if(!(SPDR &ADC_DRDY)) {
    4030:	0e b4       	in	r0, 0x2e	; 46
    4032:	07 fc       	sbrc	r0, 7
    4034:	45 c0       	rjmp	.+138    	; 0x40c0 <ADC_In+0x2bc>
		Try = 0;
    4036:	10 92 ea 02 	sts	0x02EA, r1
		ADC_Phase++;
    403a:	83 e0       	ldi	r24, 0x03	; 3
    403c:	80 93 22 0b 	sts	0x0B22, r24
		break;
	case CALI3:
		Calibr(ADC_IN3(CommReg));
#endif
		if (ADC_Phase==READ)
			StartTimer8_ISR(TD_ADC, ADC10ms);
    4040:	80 91 f5 06 	lds	r24, 0x06F5
    4044:	64 e1       	ldi	r22, 0x14	; 20
    4046:	0e 94 bf 1a 	call	0x357e	; 0x357e <StartTimer8_ISR>
    404a:	17 e0       	ldi	r17, 0x07	; 7
    404c:	09 cf       	rjmp	.-494    	; 0x3e60 <ADC_In+0x5c>
				SPDR = SetpVal(NormMode) &~ADC_FSYNC;
				WaitSPI();
				StartTimer8_ISR(TD_ADC, ADC10ms);
			}
		}
		else if(Timer8Stopp_ISR(TD_ADC)) {
    404e:	80 91 f5 06 	lds	r24, 0x06F5
    4052:	0e 94 2b 1c 	call	0x3856	; 0x3856 <Timer8Stopp_ISR>
    4056:	88 23       	and	r24, r24
    4058:	09 f4       	brne	.+2      	; 0x405c <ADC_In+0x258>
    405a:	11 cf       	rjmp	.-478    	; 0x3e7e <ADC_In+0x7a>
			ADC_ReadFail++;
    405c:	80 91 70 07 	lds	r24, 0x0770
    4060:	90 91 71 07 	lds	r25, 0x0771
    4064:	01 96       	adiw	r24, 0x01	; 1
    4066:	90 93 71 07 	sts	0x0771, r25
    406a:	80 93 70 07 	sts	0x0770, r24
			ADC_Phase = RST;
    406e:	10 92 22 0b 	sts	0x0B22, r1
    4072:	17 e0       	ldi	r17, 0x07	; 7
    4074:	f5 ce       	rjmp	.-534    	; 0x3e60 <ADC_In+0x5c>
					ADC_Chan--;
				}
				else
			#endif
			if(ADC_Check()) {
				ADC_Break++;
    4076:	80 91 b5 06 	lds	r24, 0x06B5
    407a:	90 91 b6 06 	lds	r25, 0x06B6
    407e:	01 96       	adiw	r24, 0x01	; 1
    4080:	90 93 b6 06 	sts	0x06B6, r25
    4084:	80 93 b5 06 	sts	0x06B5, r24
				ADC_Phase = RST;
    4088:	10 92 22 0b 	sts	0x0B22, r1
    408c:	17 e0       	ldi	r17, 0x07	; 7
    408e:	e8 ce       	rjmp	.-560    	; 0x3e60 <ADC_In+0x5c>

// ~~~~~~~~~~~~~~~~~~~~~~~~~
static void
Init(uint8_t CR, uint8_t SR)
{
	SPDR = CR;
    4090:	80 e2       	ldi	r24, 0x20	; 32
    4092:	8e bd       	out	0x2e, r24	; 46
	WaitSPI();
    4094:	0d b4       	in	r0, 0x2d	; 45
    4096:	07 fe       	sbrs	r0, 7
    4098:	fd cf       	rjmp	.-6      	; 0x4094 <ADC_In+0x290>
	SPDR=ClckVal;
    409a:	84 e0       	ldi	r24, 0x04	; 4
    409c:	8e bd       	out	0x2e, r24	; 46
	WaitSPI();
    409e:	0d b4       	in	r0, 0x2d	; 45
    40a0:	07 fe       	sbrs	r0, 7
    40a2:	fd cf       	rjmp	.-6      	; 0x409e <ADC_In+0x29a>
	SPDR = SR;
    40a4:	80 e1       	ldi	r24, 0x10	; 16
    40a6:	8e bd       	out	0x2e, r24	; 46
	WaitSPI();
    40a8:	0d b4       	in	r0, 0x2d	; 45
    40aa:	07 fe       	sbrs	r0, 7
    40ac:	fd cf       	rjmp	.-6      	; 0x40a8 <ADC_In+0x2a4>
	SPDR = SetpVal(CaliMode) &~ADC_FSYNC;
    40ae:	86 e4       	ldi	r24, 0x46	; 70
    40b0:	8e bd       	out	0x2e, r24	; 46
	WaitSPI();
    40b2:	0d b4       	in	r0, 0x2d	; 45
    40b4:	07 fe       	sbrs	r0, 7
    40b6:	fd cf       	rjmp	.-6      	; 0x40b2 <ADC_In+0x2ae>
	StartTimer8_ISR(TD_ADC, 36);
    40b8:	80 91 f5 06 	lds	r24, 0x06F5
    40bc:	64 e2       	ldi	r22, 0x24	; 36
    40be:	c8 ce       	rjmp	.-624    	; 0x3e50 <ADC_In+0x4c>
	WaitADC2();
	if(!(SPDR &ADC_DRDY)) {
		Try = 0;
		ADC_Phase++;
	}
	else if(Timer8Stopp_ISR(TD_ADC)) {
    40c0:	80 91 f5 06 	lds	r24, 0x06F5
    40c4:	0e 94 2b 1c 	call	0x3856	; 0x3856 <Timer8Stopp_ISR>
    40c8:	88 23       	and	r24, r24
    40ca:	99 f0       	breq	.+38     	; 0x40f2 <ADC_In+0x2ee>
		ADC_Fail++;
    40cc:	80 91 e3 08 	lds	r24, 0x08E3
    40d0:	90 91 e4 08 	lds	r25, 0x08E4
    40d4:	01 96       	adiw	r24, 0x01	; 1
    40d6:	90 93 e4 08 	sts	0x08E4, r25
    40da:	80 93 e3 08 	sts	0x08E3, r24
		ADC_Phase = ++Try<27 ? RST : ADC_OFF;
    40de:	80 91 ea 02 	lds	r24, 0x02EA
    40e2:	8f 5f       	subi	r24, 0xFF	; 255
    40e4:	80 93 ea 02 	sts	0x02EA, r24
    40e8:	8b 31       	cpi	r24, 0x1B	; 27
    40ea:	98 f1       	brcs	.+102    	; 0x4152 <ADC_In+0x34e>
    40ec:	84 e0       	ldi	r24, 0x04	; 4
    40ee:	80 93 22 0b 	sts	0x0B22, r24
		Init(ADC_IN3(ClckReg), ADC_IN3(SetpReg));
		break;
	case CALI3:
		Calibr(ADC_IN3(CommReg));
#endif
		if (ADC_Phase==READ)
    40f2:	80 91 22 0b 	lds	r24, 0x0B22
    40f6:	83 30       	cpi	r24, 0x03	; 3
    40f8:	09 f4       	brne	.+2      	; 0x40fc <ADC_In+0x2f8>
    40fa:	a2 cf       	rjmp	.-188    	; 0x4040 <ADC_In+0x23c>
				StartTimer8_ISR(TD_ADC, ADC10ms);
			}
		}
		else if(Timer8Stopp_ISR(TD_ADC)) {
			ADC_ReadFail++;
			ADC_Phase = RST;
    40fc:	17 e0       	ldi	r17, 0x07	; 7
    40fe:	b0 ce       	rjmp	.-672    	; 0x3e60 <ADC_In+0x5c>
			WaitADC2();
			Buf = SPDR<<8;
			WaitADC1();
			Buf += SPDR;
			#ifdef ADC_Ref_Chan
				if (ADC_Chan==sizeof(Mux)-1 && ADC_Input[sizeof(Mux)-1]!=0 && (Buf<ADC_Ref-ADC_Ref_d || Buf>ADC_Ref+ADC_Ref_d)) {
    4100:	80 91 df 08 	lds	r24, 0x08DF
    4104:	90 91 e0 08 	lds	r25, 0x08E0
    4108:	89 2b       	or	r24, r25
    410a:	09 f4       	brne	.+2      	; 0x410e <ADC_In+0x30a>
    410c:	e0 ce       	rjmp	.-576    	; 0x3ece <ADC_In+0xca>
    410e:	ca 01       	movw	r24, r20
    4110:	80 58       	subi	r24, 0x80	; 128
    4112:	9e 43       	sbci	r25, 0x3E	; 62
    4114:	81 5a       	subi	r24, 0xA1	; 161
    4116:	9f 40       	sbci	r25, 0x0F	; 15
    4118:	08 f4       	brcc	.+2      	; 0x411c <ADC_In+0x318>
    411a:	d9 ce       	rjmp	.-590    	; 0x3ece <ADC_In+0xca>
					ADC_Break++;
    411c:	80 91 b5 06 	lds	r24, 0x06B5
    4120:	90 91 b6 06 	lds	r25, 0x06B6
    4124:	01 96       	adiw	r24, 0x01	; 1
    4126:	90 93 b6 06 	sts	0x06B6, r25
    412a:	80 93 b5 06 	sts	0x06B5, r24
					ADC_Phase = RST;
    412e:	10 92 22 0b 	sts	0x0B22, r1
					ADC_Chan--;
    4132:	85 e0       	ldi	r24, 0x05	; 5
    4134:	80 93 ca 08 	sts	0x08CA, r24
    4138:	17 e0       	ldi	r17, 0x07	; 7
    413a:	92 ce       	rjmp	.-732    	; 0x3e60 <ADC_In+0x5c>
			#ifdef Port_INH2
				Port_INH2|=INH2;
			#endif
		}
		if (Addr%4/2)	Port_TER_B	|=TER_B;	else Port_TER_B	&=~TER_B;
		if (Addr%2)		Port_TER_A	|=TER_A;	else Port_TER_A	&=~TER_A;
    413c:	75 98       	cbi	0x0e, 5	; 14
    413e:	4b cf       	rjmp	.-362    	; 0x3fd6 <ADC_In+0x1d2>
			Port_INH &=~INH;
			#ifdef Port_INH2
				Port_INH2|=INH2;
			#endif
		}
		if (Addr%4/2)	Port_TER_B	|=TER_B;	else Port_TER_B	&=~TER_B;
    4140:	76 98       	cbi	0x0e, 6	; 14
    4142:	46 cf       	rjmp	.-372    	; 0x3fd0 <ADC_In+0x1cc>
			#ifdef Port_INH2
				Port_INH2 &=~INH2;
			#endif
		}
		else{
			Port_INH &=~INH;
    4144:	77 98       	cbi	0x0e, 7	; 14
			#ifdef Port_INH2
				Port_INH2|=INH2;
    4146:	80 91 02 01 	lds	r24, 0x0102
    414a:	84 60       	ori	r24, 0x04	; 4
    414c:	80 93 02 01 	sts	0x0102, r24
    4150:	35 cf       	rjmp	.-406    	; 0x3fbc <ADC_In+0x1b8>
		Try = 0;
		ADC_Phase++;
	}
	else if(Timer8Stopp_ISR(TD_ADC)) {
		ADC_Fail++;
		ADC_Phase = ++Try<27 ? RST : ADC_OFF;
    4152:	80 e0       	ldi	r24, 0x00	; 0
    4154:	cc cf       	rjmp	.-104    	; 0x40ee <ADC_In+0x2ea>

00004156 <SPI_Init>:
// Total
// ~~~~~~~~~~~
void
SPI_Init(void)
{
	cli();
    4156:	f8 94       	cli
	#if defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		DDRB = (DDRB &~(1<<DDB3)) |(1<<DDB2) |(1<<DDB1) |(1<<DDB0);
    4158:	84 b1       	in	r24, 0x04	; 4
    415a:	80 7f       	andi	r24, 0xF0	; 240
    415c:	87 60       	ori	r24, 0x07	; 7
    415e:	84 b9       	out	0x04, r24	; 4
		PORTB |=1<<PB3;
    4160:	2b 9a       	sbi	0x05, 3	; 5
	#elif defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
		DDRB = (DDRB &~(1<<DDB6)) |(1<<DDB5) |(1<<DDB7) |(1<<DDB4);
		PORTB |=1<<PB6;
	#endif
	SPCR = (uint8_t)((~(1<<SPIE) |(1<<SPE)) &~(1<<DORD)) |(1<<MSTR) |(1<<CPHA) |(1<<SPR1) |(1<<SPR0);
    4162:	8f e5       	ldi	r24, 0x5F	; 95
    4164:	8c bd       	out	0x2c, r24	; 44
	sei();
    4166:	78 94       	sei
		PortCS_DAC_2 |=CS_DAC_2;
		sei();
	#endif

	#ifndef ADC_Miss
		cli();
    4168:	f8 94       	cli
		#ifdef CS_ADC
			DDR_CS_ADC |=CS_ADC;
    416a:	80 91 01 01 	lds	r24, 0x0101
    416e:	88 60       	ori	r24, 0x08	; 8
    4170:	80 93 01 01 	sts	0x0101, r24
			PortCS_ADC |=CS_ADC;
    4174:	80 91 02 01 	lds	r24, 0x0102
    4178:	88 60       	ori	r24, 0x08	; 8
    417a:	80 93 02 01 	sts	0x0102, r24
		#endif
		DDR_RESET_PER |=RESET_PER;
    417e:	80 91 01 01 	lds	r24, 0x0101
    4182:	80 61       	ori	r24, 0x10	; 16
    4184:	80 93 01 01 	sts	0x0101, r24
		#ifdef ADC_Mux
			DDR_INH |=INH;
    4188:	6f 9a       	sbi	0x0d, 7	; 13
			#ifdef DDR_INH2			
				DDR_INH2 |=INH2;
    418a:	80 91 01 01 	lds	r24, 0x0101
    418e:	84 60       	ori	r24, 0x04	; 4
    4190:	80 93 01 01 	sts	0x0101, r24
			#endif
			DDR_TER_A |=TER_A;
    4194:	6d 9a       	sbi	0x0d, 5	; 13
			DDR_TER_B |=TER_B;
    4196:	6e 9a       	sbi	0x0d, 6	; 13
		#endif
		sei();
    4198:	78 94       	sei

// ~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer8_ISR_SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys_ISR;
    419a:	80 91 db 02 	lds	r24, 0x02DB
	VacantTimer8Sys_ISR += n;
    419e:	8f 5f       	subi	r24, 0xFF	; 255
    41a0:	80 93 db 02 	sts	0x02DB, r24
    41a4:	81 50       	subi	r24, 0x01	; 1

		TD_ADC = Timer8_ISR_SysAlloc(1);
    41a6:	80 93 f5 06 	sts	0x06F5, r24


		ADC_Chan = ADC_Reg-1;		// Ignore 1-st measurement after calibration
    41aa:	86 e0       	ldi	r24, 0x06	; 6
    41ac:	80 93 ca 08 	sts	0x08CA, r24

		while(ADC_In()==ADC_Reg && ADC_OK);
    41b0:	0e 94 02 1f 	call	0x3e04	; 0x3e04 <ADC_In>
    41b4:	87 30       	cpi	r24, 0x07	; 7
    41b6:	91 f4       	brne	.+36     	; 0x41dc <SPI_Init+0x86>
    41b8:	80 91 e3 08 	lds	r24, 0x08E3
    41bc:	90 91 e4 08 	lds	r25, 0x08E4
    41c0:	89 2b       	or	r24, r25
    41c2:	61 f4       	brne	.+24     	; 0x41dc <SPI_Init+0x86>
    41c4:	80 91 70 07 	lds	r24, 0x0770
    41c8:	90 91 71 07 	lds	r25, 0x0771
    41cc:	89 2b       	or	r24, r25
    41ce:	31 f4       	brne	.+12     	; 0x41dc <SPI_Init+0x86>
    41d0:	80 91 b5 06 	lds	r24, 0x06B5
    41d4:	90 91 b6 06 	lds	r25, 0x06B6
    41d8:	89 2b       	or	r24, r25
    41da:	51 f3       	breq	.-44     	; 0x41b0 <SPI_Init+0x5a>
    41dc:	08 95       	ret

000041de <Pow10>:
#include <string.h>

// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
    41de:	48 2f       	mov	r20, r24
	uint16_t Pow = 1;
	while(Exp--)
    41e0:	88 23       	and	r24, r24
    41e2:	89 f0       	breq	.+34     	; 0x4206 <Pow10+0x28>
    41e4:	21 e0       	ldi	r18, 0x01	; 1
    41e6:	30 e0       	ldi	r19, 0x00	; 0
		Pow *= 10;
    41e8:	c9 01       	movw	r24, r18
    41ea:	88 0f       	add	r24, r24
    41ec:	99 1f       	adc	r25, r25
    41ee:	22 0f       	add	r18, r18
    41f0:	33 1f       	adc	r19, r19
    41f2:	22 0f       	add	r18, r18
    41f4:	33 1f       	adc	r19, r19
    41f6:	22 0f       	add	r18, r18
    41f8:	33 1f       	adc	r19, r19
    41fa:	28 0f       	add	r18, r24
    41fc:	39 1f       	adc	r19, r25
    41fe:	41 50       	subi	r20, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    4200:	99 f7       	brne	.-26     	; 0x41e8 <Pow10+0xa>
		Pow *= 10;
	return Pow;
}
    4202:	c9 01       	movw	r24, r18
    4204:	08 95       	ret
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    4206:	21 e0       	ldi	r18, 0x01	; 1
    4208:	30 e0       	ldi	r19, 0x00	; 0
    420a:	fb cf       	rjmp	.-10     	; 0x4202 <Pow10+0x24>

0000420c <PowL10>:
	return Pow;
}
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
    420c:	1f 93       	push	r17
    420e:	18 2f       	mov	r17, r24
	uint32_t Pow = 1;
	while(Exp--)
    4210:	88 23       	and	r24, r24
    4212:	a1 f0       	breq	.+40     	; 0x423c <PowL10+0x30>
    4214:	21 e0       	ldi	r18, 0x01	; 1
    4216:	30 e0       	ldi	r19, 0x00	; 0
    4218:	40 e0       	ldi	r20, 0x00	; 0
    421a:	50 e0       	ldi	r21, 0x00	; 0
		Pow *= 10;
    421c:	ca 01       	movw	r24, r20
    421e:	b9 01       	movw	r22, r18
    4220:	2a e0       	ldi	r18, 0x0A	; 10
    4222:	30 e0       	ldi	r19, 0x00	; 0
    4224:	40 e0       	ldi	r20, 0x00	; 0
    4226:	50 e0       	ldi	r21, 0x00	; 0
    4228:	0e 94 23 83 	call	0x10646	; 0x10646 <__mulsi3>
    422c:	9b 01       	movw	r18, r22
    422e:	ac 01       	movw	r20, r24
    4230:	11 50       	subi	r17, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
	uint32_t Pow = 1;
	while(Exp--)
    4232:	a1 f7       	brne	.-24     	; 0x421c <PowL10+0x10>
		Pow *= 10;
	return Pow;
}
    4234:	b9 01       	movw	r22, r18
    4236:	ca 01       	movw	r24, r20
    4238:	1f 91       	pop	r17
    423a:	08 95       	ret
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
	uint32_t Pow = 1;
	while(Exp--)
    423c:	21 e0       	ldi	r18, 0x01	; 1
    423e:	30 e0       	ldi	r19, 0x00	; 0
    4240:	40 e0       	ldi	r20, 0x00	; 0
    4242:	50 e0       	ldi	r21, 0x00	; 0
    4244:	f7 cf       	rjmp	.-18     	; 0x4234 <PowL10+0x28>

00004246 <Log10>:
	return Pow;
}
// ~~~~~~~~~~~~~~~~~
uint8_t
Log10(uint32_t Numb)
{
    4246:	1f 93       	push	r17
	uint8_t Pos;
	for(Pos=0; Numb/=10; Pos++);
    4248:	2a e0       	ldi	r18, 0x0A	; 10
    424a:	30 e0       	ldi	r19, 0x00	; 0
    424c:	40 e0       	ldi	r20, 0x00	; 0
    424e:	50 e0       	ldi	r21, 0x00	; 0
    4250:	0e 94 75 83 	call	0x106ea	; 0x106ea <__udivmodsi4>
    4254:	c9 01       	movw	r24, r18
    4256:	da 01       	movw	r26, r20
    4258:	bc 01       	movw	r22, r24
    425a:	cd 01       	movw	r24, r26
    425c:	61 15       	cp	r22, r1
    425e:	71 05       	cpc	r23, r1
    4260:	81 05       	cpc	r24, r1
    4262:	91 05       	cpc	r25, r1
    4264:	a1 f0       	breq	.+40     	; 0x428e <Log10+0x48>
    4266:	10 e0       	ldi	r17, 0x00	; 0
    4268:	1f 5f       	subi	r17, 0xFF	; 255
    426a:	2a e0       	ldi	r18, 0x0A	; 10
    426c:	30 e0       	ldi	r19, 0x00	; 0
    426e:	40 e0       	ldi	r20, 0x00	; 0
    4270:	50 e0       	ldi	r21, 0x00	; 0
    4272:	0e 94 75 83 	call	0x106ea	; 0x106ea <__udivmodsi4>
    4276:	c9 01       	movw	r24, r18
    4278:	da 01       	movw	r26, r20
    427a:	bc 01       	movw	r22, r24
    427c:	cd 01       	movw	r24, r26
    427e:	61 15       	cp	r22, r1
    4280:	71 05       	cpc	r23, r1
    4282:	81 05       	cpc	r24, r1
    4284:	91 05       	cpc	r25, r1
    4286:	81 f7       	brne	.-32     	; 0x4268 <Log10+0x22>
	return Pos;
}
    4288:	81 2f       	mov	r24, r17
    428a:	1f 91       	pop	r17
    428c:	08 95       	ret
// ~~~~~~~~~~~~~~~~~
uint8_t
Log10(uint32_t Numb)
{
	uint8_t Pos;
	for(Pos=0; Numb/=10; Pos++);
    428e:	10 e0       	ldi	r17, 0x00	; 0
    4290:	fb cf       	rjmp	.-10     	; 0x4288 <Log10+0x42>

00004292 <CodBCD>:
// ~~~~~~~~~~~~~~~~~~~~

// ~~~~~~~~~~~~~~~~~~~
uint8_t
CodBCD(uint8_t Number)
{
    4292:	28 2f       	mov	r18, r24
    4294:	6a e0       	ldi	r22, 0x0A	; 10
    4296:	0e 94 42 83 	call	0x10684	; 0x10684 <__udivmodqi4>
    429a:	38 2f       	mov	r19, r24
    429c:	32 95       	swap	r19
    429e:	30 7f       	andi	r19, 0xF0	; 240
    42a0:	82 2f       	mov	r24, r18
    42a2:	0e 94 42 83 	call	0x10684	; 0x10684 <__udivmodqi4>
	return (Number/10<<4)+Number%10;
}
    42a6:	83 2f       	mov	r24, r19
    42a8:	89 0f       	add	r24, r25
    42aa:	08 95       	ret

000042ac <DecodBCD>:

// ~~~~~~~~~~~~~~~~~~
uint8_t
DecodBCD(uint8_t BCD)
{
    42ac:	28 2f       	mov	r18, r24
    42ae:	22 95       	swap	r18
    42b0:	2f 70       	andi	r18, 0x0F	; 15
    42b2:	9a e0       	ldi	r25, 0x0A	; 10
    42b4:	29 9f       	mul	r18, r25
    42b6:	90 01       	movw	r18, r0
    42b8:	11 24       	eor	r1, r1
    42ba:	8f 70       	andi	r24, 0x0F	; 15
	return 10*(BCD>>4)+(BCD&0x0F);
}
    42bc:	82 0f       	add	r24, r18
    42be:	08 95       	ret

000042c0 <LineFunc>:
} uLineGraph;

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
int16_t
LineFunc(const LineGraph *LG, int32_t x)
{
    42c0:	2f 92       	push	r2
    42c2:	3f 92       	push	r3
    42c4:	4f 92       	push	r4
    42c6:	5f 92       	push	r5
    42c8:	6f 92       	push	r6
    42ca:	7f 92       	push	r7
    42cc:	8f 92       	push	r8
    42ce:	9f 92       	push	r9
    42d0:	af 92       	push	r10
    42d2:	bf 92       	push	r11
    42d4:	cf 92       	push	r12
    42d6:	df 92       	push	r13
    42d8:	ef 92       	push	r14
    42da:	ff 92       	push	r15
    42dc:	0f 93       	push	r16
    42de:	1f 93       	push	r17
    42e0:	cf 93       	push	r28
    42e2:	df 93       	push	r29
    42e4:	ec 01       	movw	r28, r24
    42e6:	7a 01       	movw	r14, r20
    42e8:	8b 01       	movw	r16, r22
	int16_t y;
	if (LG->x1==LG->x2)
    42ea:	28 80       	ld	r2, Y
    42ec:	39 80       	ldd	r3, Y+1	; 0x01
    42ee:	4a 80       	ldd	r4, Y+2	; 0x02
    42f0:	5b 80       	ldd	r5, Y+3	; 0x03
    42f2:	6c 81       	ldd	r22, Y+4	; 0x04
    42f4:	7d 81       	ldd	r23, Y+5	; 0x05
    42f6:	8e 81       	ldd	r24, Y+6	; 0x06
    42f8:	9f 81       	ldd	r25, Y+7	; 0x07
    42fa:	26 16       	cp	r2, r22
    42fc:	37 06       	cpc	r3, r23
    42fe:	48 06       	cpc	r4, r24
    4300:	59 06       	cpc	r5, r25
    4302:	09 f4       	brne	.+2      	; 0x4306 <LineFunc+0x46>
    4304:	58 c0       	rjmp	.+176    	; 0x43b6 <LineFunc+0xf6>
		y = LG->y1;
	else {
		float x1=LG->x1, x2=LG->x2, y1=LG->y1, y2=LG->y2;
    4306:	0e 94 d8 7d 	call	0xfbb0	; 0xfbb0 <__floatsisf>
    430a:	5b 01       	movw	r10, r22
    430c:	6c 01       	movw	r12, r24
    430e:	6a 85       	ldd	r22, Y+10	; 0x0a
    4310:	7b 85       	ldd	r23, Y+11	; 0x0b
    4312:	88 27       	eor	r24, r24
    4314:	77 fd       	sbrc	r23, 7
    4316:	80 95       	com	r24
    4318:	98 2f       	mov	r25, r24
    431a:	0e 94 d8 7d 	call	0xfbb0	; 0xfbb0 <__floatsisf>
    431e:	3b 01       	movw	r6, r22
    4320:	4c 01       	movw	r8, r24
		y = (x-x2)*(y2-y1)/(x2-x1)+y2;
    4322:	c8 01       	movw	r24, r16
    4324:	b7 01       	movw	r22, r14
    4326:	0e 94 d8 7d 	call	0xfbb0	; 0xfbb0 <__floatsisf>
    432a:	a6 01       	movw	r20, r12
    432c:	95 01       	movw	r18, r10
    432e:	0e 94 d9 81 	call	0x103b2	; 0x103b2 <__subsf3>
    4332:	7b 01       	movw	r14, r22
    4334:	8c 01       	movw	r16, r24
    4336:	68 85       	ldd	r22, Y+8	; 0x08
    4338:	79 85       	ldd	r23, Y+9	; 0x09
    433a:	88 27       	eor	r24, r24
    433c:	77 fd       	sbrc	r23, 7
    433e:	80 95       	com	r24
    4340:	98 2f       	mov	r25, r24
    4342:	0e 94 d8 7d 	call	0xfbb0	; 0xfbb0 <__floatsisf>
    4346:	9b 01       	movw	r18, r22
    4348:	ac 01       	movw	r20, r24
    434a:	c4 01       	movw	r24, r8
    434c:	b3 01       	movw	r22, r6
    434e:	0e 94 d9 81 	call	0x103b2	; 0x103b2 <__subsf3>
    4352:	9b 01       	movw	r18, r22
    4354:	ac 01       	movw	r20, r24
    4356:	c8 01       	movw	r24, r16
    4358:	b7 01       	movw	r22, r14
    435a:	0e 94 13 7e 	call	0xfc26	; 0xfc26 <__mulsf3>
    435e:	7b 01       	movw	r14, r22
    4360:	8c 01       	movw	r16, r24
    4362:	c2 01       	movw	r24, r4
    4364:	b1 01       	movw	r22, r2
    4366:	0e 94 d8 7d 	call	0xfbb0	; 0xfbb0 <__floatsisf>
    436a:	9b 01       	movw	r18, r22
    436c:	ac 01       	movw	r20, r24
    436e:	c6 01       	movw	r24, r12
    4370:	b5 01       	movw	r22, r10
    4372:	0e 94 d9 81 	call	0x103b2	; 0x103b2 <__subsf3>
    4376:	9b 01       	movw	r18, r22
    4378:	ac 01       	movw	r20, r24
    437a:	c8 01       	movw	r24, r16
    437c:	b7 01       	movw	r22, r14
    437e:	0e 94 3e 82 	call	0x1047c	; 0x1047c <__divsf3>
    4382:	a4 01       	movw	r20, r8
    4384:	93 01       	movw	r18, r6
    4386:	0e 94 da 81 	call	0x103b4	; 0x103b4 <__addsf3>
    438a:	0e 94 a6 82 	call	0x1054c	; 0x1054c <__fixsfsi>
    438e:	cb 01       	movw	r24, r22
	}
	return y;
}
    4390:	df 91       	pop	r29
    4392:	cf 91       	pop	r28
    4394:	1f 91       	pop	r17
    4396:	0f 91       	pop	r16
    4398:	ff 90       	pop	r15
    439a:	ef 90       	pop	r14
    439c:	df 90       	pop	r13
    439e:	cf 90       	pop	r12
    43a0:	bf 90       	pop	r11
    43a2:	af 90       	pop	r10
    43a4:	9f 90       	pop	r9
    43a6:	8f 90       	pop	r8
    43a8:	7f 90       	pop	r7
    43aa:	6f 90       	pop	r6
    43ac:	5f 90       	pop	r5
    43ae:	4f 90       	pop	r4
    43b0:	3f 90       	pop	r3
    43b2:	2f 90       	pop	r2
    43b4:	08 95       	ret
int16_t
LineFunc(const LineGraph *LG, int32_t x)
{
	int16_t y;
	if (LG->x1==LG->x2)
		y = LG->y1;
    43b6:	88 85       	ldd	r24, Y+8	; 0x08
    43b8:	99 85       	ldd	r25, Y+9	; 0x09
    43ba:	ea cf       	rjmp	.-44     	; 0x4390 <LineFunc+0xd0>

000043bc <uLineFunc>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
int16_t
uLineFunc(const uLineGraph *LG, uint32_t x)
{
    43bc:	2f 92       	push	r2
    43be:	3f 92       	push	r3
    43c0:	4f 92       	push	r4
    43c2:	5f 92       	push	r5
    43c4:	6f 92       	push	r6
    43c6:	7f 92       	push	r7
    43c8:	8f 92       	push	r8
    43ca:	9f 92       	push	r9
    43cc:	af 92       	push	r10
    43ce:	bf 92       	push	r11
    43d0:	cf 92       	push	r12
    43d2:	df 92       	push	r13
    43d4:	ef 92       	push	r14
    43d6:	ff 92       	push	r15
    43d8:	0f 93       	push	r16
    43da:	1f 93       	push	r17
    43dc:	cf 93       	push	r28
    43de:	df 93       	push	r29
    43e0:	ec 01       	movw	r28, r24
    43e2:	7a 01       	movw	r14, r20
    43e4:	8b 01       	movw	r16, r22
	int16_t y;
	if (LG->x1==LG->x2)
    43e6:	28 80       	ld	r2, Y
    43e8:	39 80       	ldd	r3, Y+1	; 0x01
    43ea:	4a 80       	ldd	r4, Y+2	; 0x02
    43ec:	5b 80       	ldd	r5, Y+3	; 0x03
    43ee:	6c 81       	ldd	r22, Y+4	; 0x04
    43f0:	7d 81       	ldd	r23, Y+5	; 0x05
    43f2:	8e 81       	ldd	r24, Y+6	; 0x06
    43f4:	9f 81       	ldd	r25, Y+7	; 0x07
    43f6:	26 16       	cp	r2, r22
    43f8:	37 06       	cpc	r3, r23
    43fa:	48 06       	cpc	r4, r24
    43fc:	59 06       	cpc	r5, r25
    43fe:	09 f4       	brne	.+2      	; 0x4402 <uLineFunc+0x46>
    4400:	58 c0       	rjmp	.+176    	; 0x44b2 <uLineFunc+0xf6>
		y = LG->y1;
	else {
		float x1=LG->x1, x2=LG->x2, y1=LG->y1, y2=LG->y2;
    4402:	0e 94 d6 7d 	call	0xfbac	; 0xfbac <__floatunsisf>
    4406:	5b 01       	movw	r10, r22
    4408:	6c 01       	movw	r12, r24
    440a:	6a 85       	ldd	r22, Y+10	; 0x0a
    440c:	7b 85       	ldd	r23, Y+11	; 0x0b
    440e:	88 27       	eor	r24, r24
    4410:	77 fd       	sbrc	r23, 7
    4412:	80 95       	com	r24
    4414:	98 2f       	mov	r25, r24
    4416:	0e 94 d8 7d 	call	0xfbb0	; 0xfbb0 <__floatsisf>
    441a:	3b 01       	movw	r6, r22
    441c:	4c 01       	movw	r8, r24
		y = (x-x2)*(y2-y1)/(x2-x1)+y2;
    441e:	c8 01       	movw	r24, r16
    4420:	b7 01       	movw	r22, r14
    4422:	0e 94 d6 7d 	call	0xfbac	; 0xfbac <__floatunsisf>
    4426:	a6 01       	movw	r20, r12
    4428:	95 01       	movw	r18, r10
    442a:	0e 94 d9 81 	call	0x103b2	; 0x103b2 <__subsf3>
    442e:	7b 01       	movw	r14, r22
    4430:	8c 01       	movw	r16, r24
    4432:	68 85       	ldd	r22, Y+8	; 0x08
    4434:	79 85       	ldd	r23, Y+9	; 0x09
    4436:	88 27       	eor	r24, r24
    4438:	77 fd       	sbrc	r23, 7
    443a:	80 95       	com	r24
    443c:	98 2f       	mov	r25, r24
    443e:	0e 94 d8 7d 	call	0xfbb0	; 0xfbb0 <__floatsisf>
    4442:	9b 01       	movw	r18, r22
    4444:	ac 01       	movw	r20, r24
    4446:	c4 01       	movw	r24, r8
    4448:	b3 01       	movw	r22, r6
    444a:	0e 94 d9 81 	call	0x103b2	; 0x103b2 <__subsf3>
    444e:	9b 01       	movw	r18, r22
    4450:	ac 01       	movw	r20, r24
    4452:	c8 01       	movw	r24, r16
    4454:	b7 01       	movw	r22, r14
    4456:	0e 94 13 7e 	call	0xfc26	; 0xfc26 <__mulsf3>
    445a:	7b 01       	movw	r14, r22
    445c:	8c 01       	movw	r16, r24
    445e:	c2 01       	movw	r24, r4
    4460:	b1 01       	movw	r22, r2
    4462:	0e 94 d6 7d 	call	0xfbac	; 0xfbac <__floatunsisf>
    4466:	9b 01       	movw	r18, r22
    4468:	ac 01       	movw	r20, r24
    446a:	c6 01       	movw	r24, r12
    446c:	b5 01       	movw	r22, r10
    446e:	0e 94 d9 81 	call	0x103b2	; 0x103b2 <__subsf3>
    4472:	9b 01       	movw	r18, r22
    4474:	ac 01       	movw	r20, r24
    4476:	c8 01       	movw	r24, r16
    4478:	b7 01       	movw	r22, r14
    447a:	0e 94 3e 82 	call	0x1047c	; 0x1047c <__divsf3>
    447e:	a4 01       	movw	r20, r8
    4480:	93 01       	movw	r18, r6
    4482:	0e 94 da 81 	call	0x103b4	; 0x103b4 <__addsf3>
    4486:	0e 94 a6 82 	call	0x1054c	; 0x1054c <__fixsfsi>
    448a:	cb 01       	movw	r24, r22
	}
	return y;
}
    448c:	df 91       	pop	r29
    448e:	cf 91       	pop	r28
    4490:	1f 91       	pop	r17
    4492:	0f 91       	pop	r16
    4494:	ff 90       	pop	r15
    4496:	ef 90       	pop	r14
    4498:	df 90       	pop	r13
    449a:	cf 90       	pop	r12
    449c:	bf 90       	pop	r11
    449e:	af 90       	pop	r10
    44a0:	9f 90       	pop	r9
    44a2:	8f 90       	pop	r8
    44a4:	7f 90       	pop	r7
    44a6:	6f 90       	pop	r6
    44a8:	5f 90       	pop	r5
    44aa:	4f 90       	pop	r4
    44ac:	3f 90       	pop	r3
    44ae:	2f 90       	pop	r2
    44b0:	08 95       	ret
int16_t
uLineFunc(const uLineGraph *LG, uint32_t x)
{
	int16_t y;
	if (LG->x1==LG->x2)
		y = LG->y1;
    44b2:	88 85       	ldd	r24, Y+8	; 0x08
    44b4:	99 85       	ldd	r25, Y+9	; 0x09
    44b6:	ea cf       	rjmp	.-44     	; 0x448c <uLineFunc+0xd0>

000044b8 <PGM_uBrokLine>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
int16_t
PGM_uBrokLine(PGM_uDataPoint *Brok, uint16_t x)
{
    44b8:	af 92       	push	r10
    44ba:	bf 92       	push	r11
    44bc:	cf 92       	push	r12
    44be:	df 92       	push	r13
    44c0:	ef 92       	push	r14
    44c2:	ff 92       	push	r15
    44c4:	0f 93       	push	r16
    44c6:	1f 93       	push	r17
    44c8:	df 93       	push	r29
    44ca:	cf 93       	push	r28
    44cc:	cd b7       	in	r28, 0x3d	; 61
    44ce:	de b7       	in	r29, 0x3e	; 62
    44d0:	2c 97       	sbiw	r28, 0x0c	; 12
    44d2:	0f b6       	in	r0, 0x3f	; 63
    44d4:	f8 94       	cli
    44d6:	de bf       	out	0x3e, r29	; 62
    44d8:	0f be       	out	0x3f, r0	; 63
    44da:	cd bf       	out	0x3d, r28	; 61
    44dc:	dc 01       	movw	r26, r24

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    44de:	fc 01       	movw	r30, r24
    44e0:	85 91       	lpm	r24, Z+
    44e2:	94 91       	lpm	r25, Z+
	uLineGraph Segm;
	Segm.x2 = prw(&Brok->x);
    44e4:	7c 01       	movw	r14, r24
    44e6:	00 e0       	ldi	r16, 0x00	; 0
    44e8:	10 e0       	ldi	r17, 0x00	; 0
    44ea:	5b 01       	movw	r10, r22
    44ec:	cc 24       	eor	r12, r12
    44ee:	dd 24       	eor	r13, r13
	do {
		Segm.x1 = Segm.x2;
		Segm.x2 = prw(&(++Brok)->x);
    44f0:	cd 01       	movw	r24, r26
    44f2:	04 96       	adiw	r24, 0x04	; 4
    44f4:	fc 01       	movw	r30, r24
    44f6:	25 91       	lpm	r18, Z+
    44f8:	34 91       	lpm	r19, Z+
    44fa:	ad 01       	movw	r20, r26
    44fc:	b7 01       	movw	r22, r14
    44fe:	f8 01       	movw	r30, r16
    4500:	dc 01       	movw	r26, r24
    4502:	79 01       	movw	r14, r18
    4504:	00 e0       	ldi	r16, 0x00	; 0
    4506:	10 e0       	ldi	r17, 0x00	; 0
	} while(x>Segm.x2);
    4508:	ea 14       	cp	r14, r10
    450a:	fb 04       	cpc	r15, r11
    450c:	0c 05       	cpc	r16, r12
    450e:	1d 05       	cpc	r17, r13
    4510:	78 f3       	brcs	.-34     	; 0x44f0 <PGM_uBrokLine+0x38>
    4512:	ca 01       	movw	r24, r20
    4514:	9b 01       	movw	r18, r22
    4516:	af 01       	movw	r20, r30
    4518:	69 83       	std	Y+1, r22	; 0x01
    451a:	3a 83       	std	Y+2, r19	; 0x02
    451c:	eb 83       	std	Y+3, r30	; 0x03
    451e:	5c 83       	std	Y+4, r21	; 0x04
    4520:	ed 82       	std	Y+5, r14	; 0x05
    4522:	fe 82       	std	Y+6, r15	; 0x06
    4524:	0f 83       	std	Y+7, r16	; 0x07
    4526:	18 87       	std	Y+8, r17	; 0x08
    4528:	fc 01       	movw	r30, r24
    452a:	32 96       	adiw	r30, 0x02	; 2
    452c:	85 91       	lpm	r24, Z+
    452e:	94 91       	lpm	r25, Z+
	Segm.y1 = (int16_t)prw(&(Brok-1)->y);
    4530:	9a 87       	std	Y+10, r25	; 0x0a
    4532:	89 87       	std	Y+9, r24	; 0x09
    4534:	fd 01       	movw	r30, r26
    4536:	32 96       	adiw	r30, 0x02	; 2
    4538:	85 91       	lpm	r24, Z+
    453a:	94 91       	lpm	r25, Z+
	Segm.y2 = (int16_t)prw(&Brok->y);
    453c:	9c 87       	std	Y+12, r25	; 0x0c
    453e:	8b 87       	std	Y+11, r24	; 0x0b
	return uLineFunc(&Segm, x);
    4540:	ce 01       	movw	r24, r28
    4542:	01 96       	adiw	r24, 0x01	; 1
    4544:	b6 01       	movw	r22, r12
    4546:	a5 01       	movw	r20, r10
    4548:	0e 94 de 21 	call	0x43bc	; 0x43bc <uLineFunc>
}
    454c:	2c 96       	adiw	r28, 0x0c	; 12
    454e:	0f b6       	in	r0, 0x3f	; 63
    4550:	f8 94       	cli
    4552:	de bf       	out	0x3e, r29	; 62
    4554:	0f be       	out	0x3f, r0	; 63
    4556:	cd bf       	out	0x3d, r28	; 61
    4558:	cf 91       	pop	r28
    455a:	df 91       	pop	r29
    455c:	1f 91       	pop	r17
    455e:	0f 91       	pop	r16
    4560:	ff 90       	pop	r15
    4562:	ef 90       	pop	r14
    4564:	df 90       	pop	r13
    4566:	cf 90       	pop	r12
    4568:	bf 90       	pop	r11
    456a:	af 90       	pop	r10
    456c:	08 95       	ret

0000456e <InterBrokLine>:
	uint8_t WiAbsc, int16_t (*TblAbsc)[WiAbsc], uint8_t Absc,
	uint8_t WiOrdi, int16_t (*TblOrdi)[WiOrdi], uint8_t Ordi,
	uint8_t Len,
	int16_t x
)
{
    456e:	2f 92       	push	r2
    4570:	3f 92       	push	r3
    4572:	4f 92       	push	r4
    4574:	5f 92       	push	r5
    4576:	6f 92       	push	r6
    4578:	7f 92       	push	r7
    457a:	8f 92       	push	r8
    457c:	9f 92       	push	r9
    457e:	af 92       	push	r10
    4580:	bf 92       	push	r11
    4582:	cf 92       	push	r12
    4584:	df 92       	push	r13
    4586:	ef 92       	push	r14
    4588:	ff 92       	push	r15
    458a:	0f 93       	push	r16
    458c:	1f 93       	push	r17
    458e:	df 93       	push	r29
    4590:	cf 93       	push	r28
    4592:	cd b7       	in	r28, 0x3d	; 61
    4594:	de b7       	in	r29, 0x3e	; 62
    4596:	2e 97       	sbiw	r28, 0x0e	; 14
    4598:	0f b6       	in	r0, 0x3f	; 63
    459a:	f8 94       	cli
    459c:	de bf       	out	0x3e, r29	; 62
    459e:	0f be       	out	0x3f, r0	; 63
    45a0:	cd bf       	out	0x3d, r28	; 61
    45a2:	2b 01       	movw	r4, r22
    45a4:	2d 87       	std	Y+13, r18	; 0x0d
    45a6:	18 01       	movw	r2, r16
    45a8:	ee 86       	std	Y+14, r14	; 0x0e
    45aa:	7c 2d       	mov	r23, r12
	LineGraph Segm;
	uint8_t i = 0;
	Segm.x2=TblAbsc[0][Absc];
    45ac:	c4 2e       	mov	r12, r20
    45ae:	dd 24       	eor	r13, r13
    45b0:	cc 0c       	add	r12, r12
    45b2:	dd 1c       	adc	r13, r13
    45b4:	f2 01       	movw	r30, r4
    45b6:	ec 0d       	add	r30, r12
    45b8:	fd 1d       	adc	r31, r13
    45ba:	20 81       	ld	r18, Z
    45bc:	31 81       	ldd	r19, Z+1	; 0x01
    45be:	79 01       	movw	r14, r18
    45c0:	00 27       	eor	r16, r16
    45c2:	f7 fc       	sbrc	r15, 7
    45c4:	00 95       	com	r16
    45c6:	10 2f       	mov	r17, r16
    45c8:	ed 82       	std	Y+5, r14	; 0x05
    45ca:	fe 82       	std	Y+6, r15	; 0x06
    45cc:	0f 83       	std	Y+7, r16	; 0x07
    45ce:	18 87       	std	Y+8, r17	; 0x08
    45d0:	a8 2f       	mov	r26, r24
    45d2:	b0 e0       	ldi	r27, 0x00	; 0
    45d4:	aa 0f       	add	r26, r26
    45d6:	bb 1f       	adc	r27, r27
    45d8:	35 01       	movw	r6, r10
    45da:	88 24       	eor	r8, r8
    45dc:	77 fc       	sbrc	r7, 7
    45de:	80 94       	com	r8
    45e0:	98 2c       	mov	r9, r8
    45e2:	60 e0       	ldi	r22, 0x00	; 0
    45e4:	02 c0       	rjmp	.+4      	; 0x45ea <InterBrokLine+0x7c>
	do {
		Segm.x1 = Segm.x2;
		Segm.x2 = TblAbsc[++i][Absc];
	} while(x>Segm.x2 && i<Len);
    45e6:	79 01       	movw	r14, r18
    45e8:	8a 01       	movw	r16, r20
	LineGraph Segm;
	uint8_t i = 0;
	Segm.x2=TblAbsc[0][Absc];
	do {
		Segm.x1 = Segm.x2;
		Segm.x2 = TblAbsc[++i][Absc];
    45ea:	6f 5f       	subi	r22, 0xFF	; 255
    45ec:	a6 2e       	mov	r10, r22
    45ee:	bb 24       	eor	r11, r11
    45f0:	aa 9e       	mul	r10, r26
    45f2:	f0 01       	movw	r30, r0
    45f4:	ab 9e       	mul	r10, r27
    45f6:	f0 0d       	add	r31, r0
    45f8:	ba 9e       	mul	r11, r26
    45fa:	f0 0d       	add	r31, r0
    45fc:	11 24       	eor	r1, r1
    45fe:	e4 0d       	add	r30, r4
    4600:	f5 1d       	adc	r31, r5
    4602:	ec 0d       	add	r30, r12
    4604:	fd 1d       	adc	r31, r13
    4606:	80 81       	ld	r24, Z
    4608:	91 81       	ldd	r25, Z+1	; 0x01
    460a:	9c 01       	movw	r18, r24
    460c:	44 27       	eor	r20, r20
    460e:	37 fd       	sbrc	r19, 7
    4610:	40 95       	com	r20
    4612:	54 2f       	mov	r21, r20
	} while(x>Segm.x2 && i<Len);
    4614:	26 15       	cp	r18, r6
    4616:	37 05       	cpc	r19, r7
    4618:	48 05       	cpc	r20, r8
    461a:	59 05       	cpc	r21, r9
    461c:	14 f4       	brge	.+4      	; 0x4622 <InterBrokLine+0xb4>
    461e:	67 17       	cp	r22, r23
    4620:	10 f3       	brcs	.-60     	; 0x45e6 <InterBrokLine+0x78>
    4622:	e9 82       	std	Y+1, r14	; 0x01
    4624:	fa 82       	std	Y+2, r15	; 0x02
    4626:	0b 83       	std	Y+3, r16	; 0x03
    4628:	1c 83       	std	Y+4, r17	; 0x04
    462a:	2d 83       	std	Y+5, r18	; 0x05
    462c:	3e 83       	std	Y+6, r19	; 0x06
    462e:	4f 83       	std	Y+7, r20	; 0x07
    4630:	58 87       	std	Y+8, r21	; 0x08
	Segm.y1 = TblOrdi[i-1][Ordi];
    4632:	8d 85       	ldd	r24, Y+13	; 0x0d
    4634:	28 2f       	mov	r18, r24
    4636:	30 e0       	ldi	r19, 0x00	; 0
    4638:	22 0f       	add	r18, r18
    463a:	33 1f       	adc	r19, r19
    463c:	8e 85       	ldd	r24, Y+14	; 0x0e
    463e:	a8 2f       	mov	r26, r24
    4640:	b0 e0       	ldi	r27, 0x00	; 0
    4642:	08 94       	sec
    4644:	a1 08       	sbc	r10, r1
    4646:	b1 08       	sbc	r11, r1
    4648:	a2 9e       	mul	r10, r18
    464a:	f0 01       	movw	r30, r0
    464c:	a3 9e       	mul	r10, r19
    464e:	f0 0d       	add	r31, r0
    4650:	b2 9e       	mul	r11, r18
    4652:	f0 0d       	add	r31, r0
    4654:	11 24       	eor	r1, r1
    4656:	08 94       	sec
    4658:	a1 1c       	adc	r10, r1
    465a:	b1 1c       	adc	r11, r1
    465c:	e2 0d       	add	r30, r2
    465e:	f3 1d       	adc	r31, r3
    4660:	aa 0f       	add	r26, r26
    4662:	bb 1f       	adc	r27, r27
    4664:	ea 0f       	add	r30, r26
    4666:	fb 1f       	adc	r31, r27
    4668:	80 81       	ld	r24, Z
    466a:	91 81       	ldd	r25, Z+1	; 0x01
    466c:	9a 87       	std	Y+10, r25	; 0x0a
    466e:	89 87       	std	Y+9, r24	; 0x09
	Segm.y2 = TblOrdi[i][Ordi];
    4670:	a2 9e       	mul	r10, r18
    4672:	c0 01       	movw	r24, r0
    4674:	a3 9e       	mul	r10, r19
    4676:	90 0d       	add	r25, r0
    4678:	b2 9e       	mul	r11, r18
    467a:	90 0d       	add	r25, r0
    467c:	11 24       	eor	r1, r1
    467e:	82 0d       	add	r24, r2
    4680:	93 1d       	adc	r25, r3
    4682:	a8 0f       	add	r26, r24
    4684:	b9 1f       	adc	r27, r25
    4686:	8d 91       	ld	r24, X+
    4688:	9c 91       	ld	r25, X
    468a:	9c 87       	std	Y+12, r25	; 0x0c
    468c:	8b 87       	std	Y+11, r24	; 0x0b
	return LineFunc(&Segm, x);
    468e:	ce 01       	movw	r24, r28
    4690:	01 96       	adiw	r24, 0x01	; 1
    4692:	b4 01       	movw	r22, r8
    4694:	a3 01       	movw	r20, r6
    4696:	0e 94 60 21 	call	0x42c0	; 0x42c0 <LineFunc>
}
    469a:	2e 96       	adiw	r28, 0x0e	; 14
    469c:	0f b6       	in	r0, 0x3f	; 63
    469e:	f8 94       	cli
    46a0:	de bf       	out	0x3e, r29	; 62
    46a2:	0f be       	out	0x3f, r0	; 63
    46a4:	cd bf       	out	0x3d, r28	; 61
    46a6:	cf 91       	pop	r28
    46a8:	df 91       	pop	r29
    46aa:	1f 91       	pop	r17
    46ac:	0f 91       	pop	r16
    46ae:	ff 90       	pop	r15
    46b0:	ef 90       	pop	r14
    46b2:	df 90       	pop	r13
    46b4:	cf 90       	pop	r12
    46b6:	bf 90       	pop	r11
    46b8:	af 90       	pop	r10
    46ba:	9f 90       	pop	r9
    46bc:	8f 90       	pop	r8
    46be:	7f 90       	pop	r7
    46c0:	6f 90       	pop	r6
    46c2:	5f 90       	pop	r5
    46c4:	4f 90       	pop	r4
    46c6:	3f 90       	pop	r3
    46c8:	2f 90       	pop	r2
    46ca:	08 95       	ret

000046cc <TWI_Init>:
}

uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    46cc:	90 91 cf 02 	lds	r25, 0x02CF
	VacantTimer8Sys += n;
    46d0:	89 2f       	mov	r24, r25
    46d2:	8f 5f       	subi	r24, 0xFF	; 255

// ~~~~~~~~~~~
void
TWI_Init(void)
{
	TD_TWI_Poll = Timer8SysAlloc(1);
    46d4:	90 93 d0 04 	sts	0x04D0, r25
    46d8:	8f 5f       	subi	r24, 0xFF	; 255
    46da:	80 93 cf 02 	sts	0x02CF, r24
    46de:	81 50       	subi	r24, 0x01	; 1
	TD_TWI_Timeout = Timer8SysAlloc(1);
    46e0:	80 93 d1 04 	sts	0x04D1, r24

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    46e4:	80 91 d0 02 	lds	r24, 0x02D0
	VacantTimer16Sys += n;
    46e8:	8f 5f       	subi	r24, 0xFF	; 255
    46ea:	80 93 d0 02 	sts	0x02D0, r24
    46ee:	81 50       	subi	r24, 0x01	; 1
	TD_RTC_Check = Timer16SysAlloc(1);
    46f0:	80 93 d2 04 	sts	0x04D2, r24
	StartTimer16(TD_RTC_Check, 300);
    46f4:	6c e2       	ldi	r22, 0x2C	; 44
    46f6:	71 e0       	ldi	r23, 0x01	; 1
    46f8:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
	TWBR = 144;	//50
    46fc:	80 e9       	ldi	r24, 0x90	; 144
    46fe:	80 93 b8 00 	sts	0x00B8, r24
}
    4702:	08 95       	ret

00004704 <TWI_Error>:
// ~~~~~~~~~~~
void
TWI_Error(void)
{
	TWI_Error_Counter++;
    4704:	80 91 9d 08 	lds	r24, 0x089D
    4708:	90 91 9e 08 	lds	r25, 0x089E
    470c:	01 96       	adiw	r24, 0x01	; 1
    470e:	90 93 9e 08 	sts	0x089E, r25
    4712:	80 93 9d 08 	sts	0x089D, r24
	//StopTWI();
	PowerOffTWI();
    4716:	10 92 bc 00 	sts	0x00BC, r1
	TWI_Phase = PCF_START;
    471a:	10 92 7d 07 	sts	0x077D, r1
	StartTimer8(TD_TWI_Poll, 49);
    471e:	80 91 d0 04 	lds	r24, 0x04D0
    4722:	61 e3       	ldi	r22, 0x31	; 49
    4724:	0e 94 fa 1a 	call	0x35f4	; 0x35f4 <StartTimer8>
}
    4728:	08 95       	ret

0000472a <WriteRTC>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
WriteRTC(uint8_t Addr, uint8_t Dat)
{
    472a:	bf 92       	push	r11
    472c:	cf 92       	push	r12
    472e:	df 92       	push	r13
    4730:	ef 92       	push	r14
    4732:	ff 92       	push	r15
    4734:	0f 93       	push	r16
    4736:	1f 93       	push	r17
/*	if (!(TWCR &(1<<TWINT))){ //Wait for the end of current TWI operation and isuue STOP
		_delay_us(100);
		StopTWI();
		_delay_us(50);
	}*/
	PowerOffTWI();
    4738:	4c eb       	ldi	r20, 0xBC	; 188
    473a:	c4 2e       	mov	r12, r20
    473c:	d1 2c       	mov	r13, r1
    473e:	f6 01       	movw	r30, r12
    4740:	10 82       	st	Z, r1
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    4742:	e0 e9       	ldi	r30, 0x90	; 144
    4744:	f1 e0       	ldi	r31, 0x01	; 1
    4746:	31 97       	sbiw	r30, 0x01	; 1
    4748:	f1 f7       	brne	.-4      	; 0x4746 <WriteRTC+0x1c>
	_delay_us(100);
	//_delay_us(150);_delay_us(150);
	StartTWI();
    474a:	94 ea       	ldi	r25, 0xA4	; 164
    474c:	f6 01       	movw	r30, r12
    474e:	90 83       	st	Z, r25
    4750:	08 e5       	ldi	r16, 0x58	; 88
    4752:	12 e0       	ldi	r17, 0x02	; 2
    4754:	f8 01       	movw	r30, r16
    4756:	31 97       	sbiw	r30, 0x01	; 1
    4758:	f1 f7       	brne	.-4      	; 0x4756 <WriteRTC+0x2c>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = SLA_W(PCF_SLA);
    475a:	f8 01       	movw	r30, r16
    475c:	31 97       	sbiw	r30, 0x01	; 1
    475e:	f1 f7       	brne	.-4      	; 0x475c <WriteRTC+0x32>
    4760:	3b eb       	ldi	r19, 0xBB	; 187
    4762:	e3 2e       	mov	r14, r19
    4764:	f1 2c       	mov	r15, r1
    4766:	90 ed       	ldi	r25, 0xD0	; 208
    4768:	f7 01       	movw	r30, r14
    476a:	90 83       	st	Z, r25
    476c:	90 81       	ld	r25, Z
    476e:	90 83       	st	Z, r25
	RunTWI();
    4770:	24 e8       	ldi	r18, 0x84	; 132
    4772:	b2 2e       	mov	r11, r18
    4774:	f6 01       	movw	r30, r12
    4776:	b0 82       	st	Z, r11
    4778:	f8 01       	movw	r30, r16
    477a:	31 97       	sbiw	r30, 0x01	; 1
    477c:	f1 f7       	brne	.-4      	; 0x477a <WriteRTC+0x50>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = AddrSec+Addr;
    477e:	f8 01       	movw	r30, r16
    4780:	31 97       	sbiw	r30, 0x01	; 1
    4782:	f1 f7       	brne	.-4      	; 0x4780 <WriteRTC+0x56>
    4784:	f7 01       	movw	r30, r14
    4786:	80 83       	st	Z, r24
	RunTWI();
    4788:	f6 01       	movw	r30, r12
    478a:	b0 82       	st	Z, r11
    478c:	c8 01       	movw	r24, r16
    478e:	01 97       	sbiw	r24, 0x01	; 1
    4790:	f1 f7       	brne	.-4      	; 0x478e <WriteRTC+0x64>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = CodBCD(Dat);
    4792:	c8 01       	movw	r24, r16
    4794:	01 97       	sbiw	r24, 0x01	; 1
    4796:	f1 f7       	brne	.-4      	; 0x4794 <WriteRTC+0x6a>
    4798:	86 2f       	mov	r24, r22
    479a:	0e 94 49 21 	call	0x4292	; 0x4292 <CodBCD>
    479e:	f7 01       	movw	r30, r14
    47a0:	80 83       	st	Z, r24
	RunTWI();
    47a2:	f6 01       	movw	r30, r12
    47a4:	b0 82       	st	Z, r11
    47a6:	c8 01       	movw	r24, r16
    47a8:	01 97       	sbiw	r24, 0x01	; 1
    47aa:	f1 f7       	brne	.-4      	; 0x47a8 <WriteRTC+0x7e>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	StopTWI();
    47ac:	c8 01       	movw	r24, r16
    47ae:	01 97       	sbiw	r24, 0x01	; 1
    47b0:	f1 f7       	brne	.-4      	; 0x47ae <WriteRTC+0x84>
    47b2:	84 e9       	ldi	r24, 0x94	; 148
    47b4:	80 83       	st	Z, r24
	TWI_Phase = PCF_START;
    47b6:	10 92 7d 07 	sts	0x077D, r1
}
    47ba:	1f 91       	pop	r17
    47bc:	0f 91       	pop	r16
    47be:	ff 90       	pop	r15
    47c0:	ef 90       	pop	r14
    47c2:	df 90       	pop	r13
    47c4:	cf 90       	pop	r12
    47c6:	bf 90       	pop	r11
    47c8:	08 95       	ret

000047ca <SetWeekday>:
*/

// ~~~~~~~~~~~~~~~
// 31.12.00 was Su
uint8_t SetWeekday(uint8_t Year, uint8_t Month, uint8_t MDay)
{
    47ca:	a6 2f       	mov	r26, r22
	uint8_t DayCount;
	uint8_t LastYear = Year-1;
    47cc:	b8 2f       	mov	r27, r24
    47ce:	b1 50       	subi	r27, 0x01	; 1

	DayCount = (LastYear+LastYear/4);
    47d0:	5b 2f       	mov	r21, r27
    47d2:	56 95       	lsr	r21
    47d4:	56 95       	lsr	r21
    47d6:	5b 0f       	add	r21, r27
	for (uint8_t i=1; i<Month; DayCount+=prb(DaysMonth+i++)%7);
    47d8:	62 30       	cpi	r22, 0x02	; 2
    47da:	88 f0       	brcs	.+34     	; 0x47fe <SetWeekday+0x34>
    47dc:	e4 e2       	ldi	r30, 0x24	; 36
    47de:	f3 e0       	ldi	r31, 0x03	; 3
    47e0:	a2 50       	subi	r26, 0x02	; 2
    47e2:	2a 2f       	mov	r18, r26
    47e4:	30 e0       	ldi	r19, 0x00	; 0
    47e6:	ae 5f       	subi	r26, 0xFE	; 254
    47e8:	2b 5d       	subi	r18, 0xDB	; 219
    47ea:	3c 4f       	sbci	r19, 0xFC	; 252

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    47ec:	84 91       	lpm	r24, Z+
    47ee:	67 e0       	ldi	r22, 0x07	; 7
    47f0:	0e 94 42 83 	call	0x10684	; 0x10684 <__udivmodqi4>
    47f4:	59 0f       	add	r21, r25
    47f6:	31 96       	adiw	r30, 0x01	; 1
    47f8:	e2 17       	cp	r30, r18
    47fa:	f3 07       	cpc	r31, r19
    47fc:	b9 f7       	brne	.-18     	; 0x47ec <SetWeekday+0x22>
    47fe:	25 2f       	mov	r18, r21
	if (LastYear%4==3 && Month>2)
    4800:	b3 70       	andi	r27, 0x03	; 3
    4802:	b3 30       	cpi	r27, 0x03	; 3
    4804:	51 f0       	breq	.+20     	; 0x481a <SetWeekday+0x50>
		DayCount++;
    4806:	84 2f       	mov	r24, r20
    4808:	67 e0       	ldi	r22, 0x07	; 7
    480a:	0e 94 42 83 	call	0x10684	; 0x10684 <__udivmodqi4>
    480e:	82 2f       	mov	r24, r18
    4810:	89 0f       	add	r24, r25
    4812:	0e 94 42 83 	call	0x10684	; 0x10684 <__udivmodqi4>
	DayCount += MDay%7;
	return DayCount%7;
}
    4816:	89 2f       	mov	r24, r25
    4818:	08 95       	ret
	uint8_t DayCount;
	uint8_t LastYear = Year-1;

	DayCount = (LastYear+LastYear/4);
	for (uint8_t i=1; i<Month; DayCount+=prb(DaysMonth+i++)%7);
	if (LastYear%4==3 && Month>2)
    481a:	a3 30       	cpi	r26, 0x03	; 3
    481c:	a0 f3       	brcs	.-24     	; 0x4806 <SetWeekday+0x3c>
		DayCount++;
    481e:	2f 5f       	subi	r18, 0xFF	; 255
    4820:	f2 cf       	rjmp	.-28     	; 0x4806 <SetWeekday+0x3c>

00004822 <SetSec>:
}
// ~~~~~~~~~
void
SetSec(void)
{
	WriteRTC(0, Tm_Sec);
    4822:	80 e0       	ldi	r24, 0x00	; 0
    4824:	60 91 b4 06 	lds	r22, 0x06B4
    4828:	0e 94 95 23 	call	0x472a	; 0x472a <WriteRTC>
	TrueTime_Sec = Tm_Sec;
    482c:	80 91 b4 06 	lds	r24, 0x06B4
    4830:	80 93 cc 08 	sts	0x08CC, r24
}
    4834:	08 95       	ret

00004836 <SetMin>:

// ~~~~~~~~~
void
SetMin(void)
{
	WriteRTC(1, Tm_Min);
    4836:	81 e0       	ldi	r24, 0x01	; 1
    4838:	60 91 4f 06 	lds	r22, 0x064F
    483c:	0e 94 95 23 	call	0x472a	; 0x472a <WriteRTC>
	TrueTime_Min = Tm_Min;
    4840:	80 91 4f 06 	lds	r24, 0x064F
    4844:	80 93 ce 08 	sts	0x08CE, r24
}
    4848:	08 95       	ret

0000484a <SetHour>:

// ~~~~~~~~~~
void
SetHour(void)
{
	WriteRTC(2,  Tm_Hour);
    484a:	82 e0       	ldi	r24, 0x02	; 2
    484c:	60 91 bf 05 	lds	r22, 0x05BF
    4850:	0e 94 95 23 	call	0x472a	; 0x472a <WriteRTC>
	TrueTime_Hour = Tm_Hour;
    4854:	80 91 bf 05 	lds	r24, 0x05BF
    4858:	80 93 d6 05 	sts	0x05D6, r24
}
    485c:	08 95       	ret

0000485e <SetMDay>:
// ~~~~~~~~~~
void
SetMDay(void)
{
	WriteRTC(4,  Tm_MDay);
    485e:	84 e0       	ldi	r24, 0x04	; 4
    4860:	60 91 17 0b 	lds	r22, 0x0B17
    4864:	0e 94 95 23 	call	0x472a	; 0x472a <WriteRTC>
	TrueTime_MDay = Tm_MDay;
    4868:	80 91 17 0b 	lds	r24, 0x0B17
    486c:	80 93 54 06 	sts	0x0654, r24
}
    4870:	08 95       	ret

00004872 <SetMon>:
// ~~~~~~~~~
void
SetMon(void)
{
	WriteRTC(5, Tm_Mon);
    4872:	85 e0       	ldi	r24, 0x05	; 5
    4874:	60 91 85 07 	lds	r22, 0x0785
    4878:	0e 94 95 23 	call	0x472a	; 0x472a <WriteRTC>
	TrueTime_Mon = Tm_Mon;
    487c:	80 91 85 07 	lds	r24, 0x0785
    4880:	80 93 cd 08 	sts	0x08CD, r24
}
    4884:	08 95       	ret

00004886 <SetYear>:
// ~~~~~~~~~~~~~
void
SetYear(void)
{
	WriteRTC(6, Tm_Year);
    4886:	86 e0       	ldi	r24, 0x06	; 6
    4888:	60 91 dc 05 	lds	r22, 0x05DC
    488c:	0e 94 95 23 	call	0x472a	; 0x472a <WriteRTC>
	TrueTime_Year = Tm_Year;
    4890:	80 91 dc 05 	lds	r24, 0x05DC
    4894:	80 93 7b 07 	sts	0x077B, r24
}
    4898:	08 95       	ret

0000489a <SetDateTime>:
// ~~~~~~~~~~~~~
void
SetDateTime(uint8_t Year, uint8_t Month, uint8_t Day, uint8_t WDay, uint8_t Hour, uint8_t Min, uint8_t Sec){
    489a:	5f 92       	push	r5
    489c:	6f 92       	push	r6
    489e:	7f 92       	push	r7
    48a0:	8f 92       	push	r8
    48a2:	9f 92       	push	r9
    48a4:	af 92       	push	r10
    48a6:	bf 92       	push	r11
    48a8:	cf 92       	push	r12
    48aa:	df 92       	push	r13
    48ac:	ef 92       	push	r14
    48ae:	ff 92       	push	r15
    48b0:	0f 93       	push	r16
    48b2:	1f 93       	push	r17
    48b4:	58 2e       	mov	r5, r24
    48b6:	66 2e       	mov	r6, r22
    48b8:	74 2e       	mov	r7, r20
    48ba:	f2 2e       	mov	r15, r18
    48bc:	8c 2d       	mov	r24, r12
	PowerOffTWI();
    48be:	7c eb       	ldi	r23, 0xBC	; 188
    48c0:	87 2e       	mov	r8, r23
    48c2:	91 2c       	mov	r9, r1
    48c4:	f4 01       	movw	r30, r8
    48c6:	10 82       	st	Z, r1
    48c8:	e0 e9       	ldi	r30, 0x90	; 144
    48ca:	f1 e0       	ldi	r31, 0x01	; 1
    48cc:	31 97       	sbiw	r30, 0x01	; 1
    48ce:	f1 f7       	brne	.-4      	; 0x48cc <SetDateTime+0x32>
	_delay_us(100);
	//_delay_us(150);_delay_us(150);
	StartTWI();
    48d0:	94 ea       	ldi	r25, 0xA4	; 164
    48d2:	f4 01       	movw	r30, r8
    48d4:	90 83       	st	Z, r25
    48d6:	68 e5       	ldi	r22, 0x58	; 88
    48d8:	c6 2e       	mov	r12, r22
    48da:	62 e0       	ldi	r22, 0x02	; 2
    48dc:	d6 2e       	mov	r13, r22
    48de:	f6 01       	movw	r30, r12
    48e0:	31 97       	sbiw	r30, 0x01	; 1
    48e2:	f1 f7       	brne	.-4      	; 0x48e0 <SetDateTime+0x46>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = SLA_W(PCF_SLA);
    48e4:	f6 01       	movw	r30, r12
    48e6:	31 97       	sbiw	r30, 0x01	; 1
    48e8:	f1 f7       	brne	.-4      	; 0x48e6 <SetDateTime+0x4c>
    48ea:	5b eb       	ldi	r21, 0xBB	; 187
    48ec:	a5 2e       	mov	r10, r21
    48ee:	b1 2c       	mov	r11, r1
    48f0:	90 ed       	ldi	r25, 0xD0	; 208
    48f2:	f5 01       	movw	r30, r10
    48f4:	90 83       	st	Z, r25
    48f6:	90 81       	ld	r25, Z
    48f8:	90 83       	st	Z, r25
	RunTWI();
    48fa:	14 e8       	ldi	r17, 0x84	; 132
    48fc:	f4 01       	movw	r30, r8
    48fe:	10 83       	st	Z, r17
    4900:	f6 01       	movw	r30, r12
    4902:	31 97       	sbiw	r30, 0x01	; 1
    4904:	f1 f7       	brne	.-4      	; 0x4902 <SetDateTime+0x68>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = AddrSec;
    4906:	f6 01       	movw	r30, r12
    4908:	31 97       	sbiw	r30, 0x01	; 1
    490a:	f1 f7       	brne	.-4      	; 0x4908 <SetDateTime+0x6e>
    490c:	f5 01       	movw	r30, r10
    490e:	10 82       	st	Z, r1
	RunTWI();
    4910:	f4 01       	movw	r30, r8
    4912:	10 83       	st	Z, r17
    4914:	f6 01       	movw	r30, r12
    4916:	31 97       	sbiw	r30, 0x01	; 1
    4918:	f1 f7       	brne	.-4      	; 0x4916 <SetDateTime+0x7c>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = CodBCD(Sec);
    491a:	f6 01       	movw	r30, r12
    491c:	31 97       	sbiw	r30, 0x01	; 1
    491e:	f1 f7       	brne	.-4      	; 0x491c <SetDateTime+0x82>
    4920:	0e 94 49 21 	call	0x4292	; 0x4292 <CodBCD>
    4924:	f5 01       	movw	r30, r10
    4926:	80 83       	st	Z, r24
	RunTWI();
    4928:	f4 01       	movw	r30, r8
    492a:	10 83       	st	Z, r17
    492c:	c6 01       	movw	r24, r12
    492e:	01 97       	sbiw	r24, 0x01	; 1
    4930:	f1 f7       	brne	.-4      	; 0x492e <SetDateTime+0x94>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = CodBCD(Min);
    4932:	c6 01       	movw	r24, r12
    4934:	01 97       	sbiw	r24, 0x01	; 1
    4936:	f1 f7       	brne	.-4      	; 0x4934 <SetDateTime+0x9a>
    4938:	8e 2d       	mov	r24, r14
    493a:	0e 94 49 21 	call	0x4292	; 0x4292 <CodBCD>
    493e:	f5 01       	movw	r30, r10
    4940:	80 83       	st	Z, r24
	RunTWI();
    4942:	f4 01       	movw	r30, r8
    4944:	10 83       	st	Z, r17
    4946:	c6 01       	movw	r24, r12
    4948:	01 97       	sbiw	r24, 0x01	; 1
    494a:	f1 f7       	brne	.-4      	; 0x4948 <SetDateTime+0xae>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = CodBCD(Hour);
    494c:	c6 01       	movw	r24, r12
    494e:	01 97       	sbiw	r24, 0x01	; 1
    4950:	f1 f7       	brne	.-4      	; 0x494e <SetDateTime+0xb4>
    4952:	80 2f       	mov	r24, r16
    4954:	0e 94 49 21 	call	0x4292	; 0x4292 <CodBCD>
    4958:	f5 01       	movw	r30, r10
    495a:	80 83       	st	Z, r24
	RunTWI();
    495c:	f4 01       	movw	r30, r8
    495e:	10 83       	st	Z, r17
    4960:	c6 01       	movw	r24, r12
    4962:	01 97       	sbiw	r24, 0x01	; 1
    4964:	f1 f7       	brne	.-4      	; 0x4962 <SetDateTime+0xc8>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = WDay;
    4966:	c6 01       	movw	r24, r12
    4968:	01 97       	sbiw	r24, 0x01	; 1
    496a:	f1 f7       	brne	.-4      	; 0x4968 <SetDateTime+0xce>
    496c:	f5 01       	movw	r30, r10
    496e:	f0 82       	st	Z, r15
	RunTWI();
    4970:	f4 01       	movw	r30, r8
    4972:	10 83       	st	Z, r17
    4974:	c6 01       	movw	r24, r12
    4976:	01 97       	sbiw	r24, 0x01	; 1
    4978:	f1 f7       	brne	.-4      	; 0x4976 <SetDateTime+0xdc>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = CodBCD(Day);
    497a:	c6 01       	movw	r24, r12
    497c:	01 97       	sbiw	r24, 0x01	; 1
    497e:	f1 f7       	brne	.-4      	; 0x497c <SetDateTime+0xe2>
    4980:	87 2d       	mov	r24, r7
    4982:	0e 94 49 21 	call	0x4292	; 0x4292 <CodBCD>
    4986:	f5 01       	movw	r30, r10
    4988:	80 83       	st	Z, r24
	RunTWI();
    498a:	f4 01       	movw	r30, r8
    498c:	10 83       	st	Z, r17
    498e:	c6 01       	movw	r24, r12
    4990:	01 97       	sbiw	r24, 0x01	; 1
    4992:	f1 f7       	brne	.-4      	; 0x4990 <SetDateTime+0xf6>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = CodBCD(Month);
    4994:	c6 01       	movw	r24, r12
    4996:	01 97       	sbiw	r24, 0x01	; 1
    4998:	f1 f7       	brne	.-4      	; 0x4996 <SetDateTime+0xfc>
    499a:	86 2d       	mov	r24, r6
    499c:	0e 94 49 21 	call	0x4292	; 0x4292 <CodBCD>
    49a0:	f5 01       	movw	r30, r10
    49a2:	80 83       	st	Z, r24
	RunTWI();
    49a4:	f4 01       	movw	r30, r8
    49a6:	10 83       	st	Z, r17
    49a8:	c6 01       	movw	r24, r12
    49aa:	01 97       	sbiw	r24, 0x01	; 1
    49ac:	f1 f7       	brne	.-4      	; 0x49aa <SetDateTime+0x110>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = CodBCD(Year);
    49ae:	c6 01       	movw	r24, r12
    49b0:	01 97       	sbiw	r24, 0x01	; 1
    49b2:	f1 f7       	brne	.-4      	; 0x49b0 <SetDateTime+0x116>
    49b4:	85 2d       	mov	r24, r5
    49b6:	0e 94 49 21 	call	0x4292	; 0x4292 <CodBCD>
    49ba:	f5 01       	movw	r30, r10
    49bc:	80 83       	st	Z, r24
	RunTWI();
    49be:	f4 01       	movw	r30, r8
    49c0:	10 83       	st	Z, r17
    49c2:	c6 01       	movw	r24, r12
    49c4:	01 97       	sbiw	r24, 0x01	; 1
    49c6:	f1 f7       	brne	.-4      	; 0x49c4 <SetDateTime+0x12a>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	StopTWI();
    49c8:	c6 01       	movw	r24, r12
    49ca:	01 97       	sbiw	r24, 0x01	; 1
    49cc:	f1 f7       	brne	.-4      	; 0x49ca <SetDateTime+0x130>
    49ce:	84 e9       	ldi	r24, 0x94	; 148
    49d0:	80 83       	st	Z, r24
	TWI_Phase = PCF_START;
    49d2:	10 92 7d 07 	sts	0x077D, r1
}
    49d6:	1f 91       	pop	r17
    49d8:	0f 91       	pop	r16
    49da:	ff 90       	pop	r15
    49dc:	ef 90       	pop	r14
    49de:	df 90       	pop	r13
    49e0:	cf 90       	pop	r12
    49e2:	bf 90       	pop	r11
    49e4:	af 90       	pop	r10
    49e6:	9f 90       	pop	r9
    49e8:	8f 90       	pop	r8
    49ea:	7f 90       	pop	r7
    49ec:	6f 90       	pop	r6
    49ee:	5f 90       	pop	r5
    49f0:	08 95       	ret

000049f2 <RTC_Ready>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t RTC_Ready(void){
    49f2:	90 e0       	ldi	r25, 0x00	; 0
    49f4:	80 91 7d 07 	lds	r24, 0x077D
    49f8:	88 23       	and	r24, r24
    49fa:	09 f4       	brne	.+2      	; 0x49fe <RTC_Ready+0xc>
    49fc:	91 e0       	ldi	r25, 0x01	; 1
	if(TWI_Phase == PCF_START) return 1;
	else return 0;
}
    49fe:	89 2f       	mov	r24, r25
    4a00:	08 95       	ret

00004a02 <RTC_GetTrueTime>:
void RTC_GetTrueTime(void){
	TrueTime_Sec = Tm_Sec;
    4a02:	80 91 b4 06 	lds	r24, 0x06B4
    4a06:	80 93 cc 08 	sts	0x08CC, r24
	TrueTime_Min = Tm_Min;
    4a0a:	80 91 4f 06 	lds	r24, 0x064F
    4a0e:	80 93 ce 08 	sts	0x08CE, r24
	TrueTime_Hour = Tm_Hour;
    4a12:	80 91 bf 05 	lds	r24, 0x05BF
    4a16:	80 93 d6 05 	sts	0x05D6, r24
	TrueTime_MDay = Tm_MDay;
    4a1a:	40 91 17 0b 	lds	r20, 0x0B17
    4a1e:	40 93 54 06 	sts	0x0654, r20
	TrueTime_Mon = Tm_Mon;
    4a22:	60 91 85 07 	lds	r22, 0x0785
    4a26:	60 93 cd 08 	sts	0x08CD, r22
	TrueTime_Year = Tm_Year;
    4a2a:	80 91 dc 05 	lds	r24, 0x05DC
    4a2e:	80 93 7b 07 	sts	0x077B, r24
	TrueTime_WDay = SetWeekday(TrueTime_Year, TrueTime_Mon, TrueTime_MDay);
    4a32:	0e 94 e5 23 	call	0x47ca	; 0x47ca <SetWeekday>
    4a36:	80 93 16 0b 	sts	0x0B16, r24
}
    4a3a:	08 95       	ret

00004a3c <RTC_SetTrueTime>:
void RTC_SetTrueTime(uint8_t Year, uint8_t Month, uint8_t Day, uint8_t WDay, uint8_t Hour, uint8_t Min, uint8_t Sec){
    4a3c:	8f 92       	push	r8
    4a3e:	9f 92       	push	r9
    4a40:	af 92       	push	r10
    4a42:	bf 92       	push	r11
    4a44:	cf 92       	push	r12
    4a46:	df 92       	push	r13
    4a48:	ef 92       	push	r14
    4a4a:	ff 92       	push	r15
    4a4c:	0f 93       	push	r16
    4a4e:	1f 93       	push	r17
    4a50:	88 2e       	mov	r8, r24
    4a52:	a6 2e       	mov	r10, r22
    4a54:	b4 2e       	mov	r11, r20
    4a56:	92 2e       	mov	r9, r18
    4a58:	d0 2e       	mov	r13, r16
    4a5a:	fe 2c       	mov	r15, r14
    4a5c:	1c 2d       	mov	r17, r12
	SetDateTime(Year, Month, Day, WDay, Hour, Min, Sec);
    4a5e:	0e 94 4d 24 	call	0x489a	; 0x489a <SetDateTime>
	TrueTime_Sec = Sec;
    4a62:	10 93 cc 08 	sts	0x08CC, r17
	TrueTime_Min = Min;
    4a66:	f0 92 ce 08 	sts	0x08CE, r15
	TrueTime_Hour = Hour;
    4a6a:	d0 92 d6 05 	sts	0x05D6, r13
	TrueTime_MDay = Day;
    4a6e:	b0 92 54 06 	sts	0x0654, r11
	TrueTime_Mon = Month;
    4a72:	a0 92 cd 08 	sts	0x08CD, r10
	TrueTime_Year = Year;
    4a76:	80 92 7b 07 	sts	0x077B, r8
	TrueTime_WDay = WDay;
    4a7a:	90 92 16 0b 	sts	0x0B16, r9
}
    4a7e:	1f 91       	pop	r17
    4a80:	0f 91       	pop	r16
    4a82:	ff 90       	pop	r15
    4a84:	ef 90       	pop	r14
    4a86:	df 90       	pop	r13
    4a88:	cf 90       	pop	r12
    4a8a:	bf 90       	pop	r11
    4a8c:	af 90       	pop	r10
    4a8e:	9f 90       	pop	r9
    4a90:	8f 90       	pop	r8
    4a92:	08 95       	ret

00004a94 <RTC_Check>:

//  3 

uint8_t RTC_Check(void){

	if( (Tm_Year == TrueTime_Year)  && (Tm_Mon == TrueTime_Mon) && (Tm_MDay == TrueTime_MDay) &&
    4a94:	50 91 dc 05 	lds	r21, 0x05DC
    4a98:	40 91 7b 07 	lds	r20, 0x077B
    4a9c:	54 17       	cp	r21, r20
    4a9e:	59 f1       	breq	.+86     	; 0x4af6 <RTC_Check+0x62>
    4aa0:	90 91 cc 08 	lds	r25, 0x08CC
			(Tm_Hour == TrueTime_Hour) && (Tm_Min == TrueTime_Min) && (Tm_Sec == TrueTime_Sec) ) return 1;

	if(TrueTime_Sec>55){
    4aa4:	98 33       	cpi	r25, 0x38	; 56
    4aa6:	58 f0       	brcs	.+22     	; 0x4abe <RTC_Check+0x2a>
		if(TrueTime_Min == 59){
    4aa8:	80 91 ce 08 	lds	r24, 0x08CE
    4aac:	8b 33       	cpi	r24, 0x3B	; 59
    4aae:	09 f4       	brne	.+2      	; 0x4ab2 <RTC_Check+0x1e>
    4ab0:	5a c0       	rjmp	.+180    	; 0x4b66 <RTC_Check+0xd2>
			else{
				if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ) return 1;
			}
		}
		else{
			if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ||
    4ab2:	54 17       	cp	r21, r20
    4ab4:	09 f4       	brne	.+2      	; 0x4ab8 <RTC_Check+0x24>
    4ab6:	40 c0       	rjmp	.+128    	; 0x4b38 <RTC_Check+0xa4>
				(Tm_Hour != TrueTime_Hour) ) return 1;		
		}
	}
	else{
		if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ||
    4ab8:	21 e0       	ldi	r18, 0x01	; 1
			(Tm_Hour != TrueTime_Hour) || (Tm_Min != TrueTime_Min) ) return 1;
	}
	
	return 0;
}
    4aba:	82 2f       	mov	r24, r18
    4abc:	08 95       	ret
			if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ||
				(Tm_Hour != TrueTime_Hour) ) return 1;		
		}
	}
	else{
		if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ||
    4abe:	54 17       	cp	r21, r20
    4ac0:	d9 f7       	brne	.-10     	; 0x4ab8 <RTC_Check+0x24>
    4ac2:	90 91 85 07 	lds	r25, 0x0785
    4ac6:	80 91 cd 08 	lds	r24, 0x08CD
    4aca:	98 17       	cp	r25, r24
    4acc:	a9 f7       	brne	.-22     	; 0x4ab8 <RTC_Check+0x24>
    4ace:	90 91 17 0b 	lds	r25, 0x0B17
    4ad2:	80 91 54 06 	lds	r24, 0x0654
    4ad6:	98 17       	cp	r25, r24
    4ad8:	79 f7       	brne	.-34     	; 0x4ab8 <RTC_Check+0x24>
    4ada:	90 91 bf 05 	lds	r25, 0x05BF
    4ade:	80 91 d6 05 	lds	r24, 0x05D6
    4ae2:	98 17       	cp	r25, r24
    4ae4:	49 f7       	brne	.-46     	; 0x4ab8 <RTC_Check+0x24>
    4ae6:	20 e0       	ldi	r18, 0x00	; 0
    4ae8:	90 91 4f 06 	lds	r25, 0x064F
    4aec:	80 91 ce 08 	lds	r24, 0x08CE
    4af0:	98 17       	cp	r25, r24
    4af2:	11 f7       	brne	.-60     	; 0x4ab8 <RTC_Check+0x24>
    4af4:	e2 cf       	rjmp	.-60     	; 0x4aba <RTC_Check+0x26>

//  3 

uint8_t RTC_Check(void){

	if( (Tm_Year == TrueTime_Year)  && (Tm_Mon == TrueTime_Mon) && (Tm_MDay == TrueTime_MDay) &&
    4af6:	90 91 85 07 	lds	r25, 0x0785
    4afa:	80 91 cd 08 	lds	r24, 0x08CD
    4afe:	98 17       	cp	r25, r24
    4b00:	79 f6       	brne	.-98     	; 0x4aa0 <RTC_Check+0xc>
    4b02:	90 91 17 0b 	lds	r25, 0x0B17
    4b06:	80 91 54 06 	lds	r24, 0x0654
    4b0a:	98 17       	cp	r25, r24
    4b0c:	49 f6       	brne	.-110    	; 0x4aa0 <RTC_Check+0xc>
    4b0e:	90 91 bf 05 	lds	r25, 0x05BF
    4b12:	80 91 d6 05 	lds	r24, 0x05D6
    4b16:	98 17       	cp	r25, r24
    4b18:	19 f6       	brne	.-122    	; 0x4aa0 <RTC_Check+0xc>
    4b1a:	90 91 4f 06 	lds	r25, 0x064F
    4b1e:	80 91 ce 08 	lds	r24, 0x08CE
    4b22:	98 17       	cp	r25, r24
    4b24:	09 f0       	breq	.+2      	; 0x4b28 <RTC_Check+0x94>
    4b26:	bc cf       	rjmp	.-136    	; 0x4aa0 <RTC_Check+0xc>
    4b28:	80 91 b4 06 	lds	r24, 0x06B4
    4b2c:	90 91 cc 08 	lds	r25, 0x08CC
    4b30:	89 17       	cp	r24, r25
    4b32:	09 f0       	breq	.+2      	; 0x4b36 <RTC_Check+0xa2>
    4b34:	b7 cf       	rjmp	.-146    	; 0x4aa4 <RTC_Check+0x10>
    4b36:	c0 cf       	rjmp	.-128    	; 0x4ab8 <RTC_Check+0x24>
			else{
				if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ) return 1;
			}
		}
		else{
			if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ||
    4b38:	90 91 85 07 	lds	r25, 0x0785
    4b3c:	80 91 cd 08 	lds	r24, 0x08CD
    4b40:	98 17       	cp	r25, r24
    4b42:	09 f0       	breq	.+2      	; 0x4b46 <RTC_Check+0xb2>
    4b44:	b9 cf       	rjmp	.-142    	; 0x4ab8 <RTC_Check+0x24>
    4b46:	90 91 17 0b 	lds	r25, 0x0B17
    4b4a:	80 91 54 06 	lds	r24, 0x0654
    4b4e:	98 17       	cp	r25, r24
    4b50:	09 f0       	breq	.+2      	; 0x4b54 <RTC_Check+0xc0>
    4b52:	b2 cf       	rjmp	.-156    	; 0x4ab8 <RTC_Check+0x24>
    4b54:	20 e0       	ldi	r18, 0x00	; 0
    4b56:	90 91 bf 05 	lds	r25, 0x05BF
    4b5a:	80 91 d6 05 	lds	r24, 0x05D6
    4b5e:	98 17       	cp	r25, r24
    4b60:	09 f0       	breq	.+2      	; 0x4b64 <RTC_Check+0xd0>
    4b62:	aa cf       	rjmp	.-172    	; 0x4ab8 <RTC_Check+0x24>
    4b64:	aa cf       	rjmp	.-172    	; 0x4aba <RTC_Check+0x26>
	if( (Tm_Year == TrueTime_Year)  && (Tm_Mon == TrueTime_Mon) && (Tm_MDay == TrueTime_MDay) &&
			(Tm_Hour == TrueTime_Hour) && (Tm_Min == TrueTime_Min) && (Tm_Sec == TrueTime_Sec) ) return 1;

	if(TrueTime_Sec>55){
		if(TrueTime_Min == 59){
			if(TrueTime_Hour == 23){
    4b66:	80 91 d6 05 	lds	r24, 0x05D6
    4b6a:	87 31       	cpi	r24, 0x17	; 23
    4b6c:	99 f0       	breq	.+38     	; 0x4b94 <RTC_Check+0x100>
				else{
					if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) ) return 1;
				}
			}
			else{
				if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ) return 1;
    4b6e:	54 17       	cp	r21, r20
    4b70:	09 f0       	breq	.+2      	; 0x4b74 <RTC_Check+0xe0>
    4b72:	a2 cf       	rjmp	.-188    	; 0x4ab8 <RTC_Check+0x24>
    4b74:	90 91 85 07 	lds	r25, 0x0785
    4b78:	80 91 cd 08 	lds	r24, 0x08CD
    4b7c:	98 17       	cp	r25, r24
    4b7e:	09 f0       	breq	.+2      	; 0x4b82 <RTC_Check+0xee>
    4b80:	9b cf       	rjmp	.-202    	; 0x4ab8 <RTC_Check+0x24>
    4b82:	20 e0       	ldi	r18, 0x00	; 0
    4b84:	90 91 17 0b 	lds	r25, 0x0B17
    4b88:	80 91 54 06 	lds	r24, 0x0654
    4b8c:	98 17       	cp	r25, r24
    4b8e:	09 f0       	breq	.+2      	; 0x4b92 <RTC_Check+0xfe>
    4b90:	93 cf       	rjmp	.-218    	; 0x4ab8 <RTC_Check+0x24>
    4b92:	93 cf       	rjmp	.-218    	; 0x4aba <RTC_Check+0x26>
			(Tm_Hour == TrueTime_Hour) && (Tm_Min == TrueTime_Min) && (Tm_Sec == TrueTime_Sec) ) return 1;

	if(TrueTime_Sec>55){
		if(TrueTime_Min == 59){
			if(TrueTime_Hour == 23){
				if(TrueTime_MDay >= 28){
    4b94:	80 91 54 06 	lds	r24, 0x0654
    4b98:	8c 31       	cpi	r24, 0x1C	; 28
    4b9a:	48 f0       	brcs	.+18     	; 0x4bae <RTC_Check+0x11a>
					if(TrueTime_Mon == 12){
    4b9c:	80 91 cd 08 	lds	r24, 0x08CD
    4ba0:	8c 30       	cpi	r24, 0x0C	; 12
    4ba2:	89 f0       	breq	.+34     	; 0x4bc6 <RTC_Check+0x132>
						if( ((TrueTime_Year+1) == Tm_Year) || (TrueTime_Year==Tm_Year) || ((TrueTime_Year==99) && (Tm_Year==0)) ) return 0;
    4ba4:	20 e0       	ldi	r18, 0x00	; 0
    4ba6:	54 17       	cp	r21, r20
    4ba8:	09 f0       	breq	.+2      	; 0x4bac <RTC_Check+0x118>
    4baa:	86 cf       	rjmp	.-244    	; 0x4ab8 <RTC_Check+0x24>
    4bac:	86 cf       	rjmp	.-244    	; 0x4aba <RTC_Check+0x26>
					else{
						if(Tm_Year!= TrueTime_Year) return 1;
					}
				}
				else{
					if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) ) return 1;
    4bae:	54 17       	cp	r21, r20
    4bb0:	09 f0       	breq	.+2      	; 0x4bb4 <RTC_Check+0x120>
    4bb2:	82 cf       	rjmp	.-252    	; 0x4ab8 <RTC_Check+0x24>
    4bb4:	20 e0       	ldi	r18, 0x00	; 0
    4bb6:	90 91 85 07 	lds	r25, 0x0785
    4bba:	80 91 cd 08 	lds	r24, 0x08CD
    4bbe:	98 17       	cp	r25, r24
    4bc0:	09 f0       	breq	.+2      	; 0x4bc4 <RTC_Check+0x130>
    4bc2:	7a cf       	rjmp	.-268    	; 0x4ab8 <RTC_Check+0x24>
    4bc4:	7a cf       	rjmp	.-268    	; 0x4aba <RTC_Check+0x26>
	if(TrueTime_Sec>55){
		if(TrueTime_Min == 59){
			if(TrueTime_Hour == 23){
				if(TrueTime_MDay >= 28){
					if(TrueTime_Mon == 12){
						if( ((TrueTime_Year+1) == Tm_Year) || (TrueTime_Year==Tm_Year) || ((TrueTime_Year==99) && (Tm_Year==0)) ) return 0;
    4bc6:	84 2f       	mov	r24, r20
    4bc8:	90 e0       	ldi	r25, 0x00	; 0
    4bca:	01 96       	adiw	r24, 0x01	; 1
    4bcc:	25 2f       	mov	r18, r21
    4bce:	30 e0       	ldi	r19, 0x00	; 0
    4bd0:	82 17       	cp	r24, r18
    4bd2:	93 07       	cpc	r25, r19
    4bd4:	61 f0       	breq	.+24     	; 0x4bee <RTC_Check+0x15a>
    4bd6:	54 17       	cp	r21, r20
    4bd8:	51 f0       	breq	.+20     	; 0x4bee <RTC_Check+0x15a>
    4bda:	43 36       	cpi	r20, 0x63	; 99
    4bdc:	09 f0       	breq	.+2      	; 0x4be0 <RTC_Check+0x14c>
    4bde:	6c cf       	rjmp	.-296    	; 0x4ab8 <RTC_Check+0x24>
    4be0:	20 e0       	ldi	r18, 0x00	; 0
    4be2:	55 23       	and	r21, r21
    4be4:	09 f4       	brne	.+2      	; 0x4be8 <RTC_Check+0x154>
    4be6:	21 e0       	ldi	r18, 0x01	; 1
    4be8:	81 e0       	ldi	r24, 0x01	; 1
    4bea:	28 27       	eor	r18, r24
    4bec:	66 cf       	rjmp	.-308    	; 0x4aba <RTC_Check+0x26>
			if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ||
				(Tm_Hour != TrueTime_Hour) ) return 1;		
		}
	}
	else{
		if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ||
    4bee:	20 e0       	ldi	r18, 0x00	; 0
    4bf0:	64 cf       	rjmp	.-312    	; 0x4aba <RTC_Check+0x26>

00004bf2 <GSM_PWRCNTRL_Config>:
#endif

//  gsm_sim900r.h   PWRCNTRL
#ifdef vmd2_3
	void GSM_PWRCNTRL_Config(void){
		cli();
    4bf2:	f8 94       	cli
		DDRL|=(1<<PL5);
    4bf4:	ea e0       	ldi	r30, 0x0A	; 10
    4bf6:	f1 e0       	ldi	r31, 0x01	; 1
    4bf8:	80 81       	ld	r24, Z
    4bfa:	80 62       	ori	r24, 0x20	; 32
    4bfc:	80 83       	st	Z, r24
		sei();
    4bfe:	78 94       	sei
	}
    4c00:	08 95       	ret

00004c02 <GSM_PWRCNTRL_OFF>:
	void GSM_PWRCNTRL_OFF(void){
		cli();
    4c02:	f8 94       	cli
		PORTL|=(1<<PL5);
    4c04:	eb e0       	ldi	r30, 0x0B	; 11
    4c06:	f1 e0       	ldi	r31, 0x01	; 1
    4c08:	80 81       	ld	r24, Z
    4c0a:	80 62       	ori	r24, 0x20	; 32
    4c0c:	80 83       	st	Z, r24
		sei();
    4c0e:	78 94       	sei
	}
    4c10:	08 95       	ret

00004c12 <GSM_PWRCNTRL_ON>:
	void GSM_PWRCNTRL_ON(void){
		cli();
    4c12:	f8 94       	cli
		PORTL &= ~(1<<PL5);
    4c14:	eb e0       	ldi	r30, 0x0B	; 11
    4c16:	f1 e0       	ldi	r31, 0x01	; 1
    4c18:	80 81       	ld	r24, Z
    4c1a:	8f 7d       	andi	r24, 0xDF	; 223
    4c1c:	80 83       	st	Z, r24
		sei();
    4c1e:	78 94       	sei
	}
    4c20:	08 95       	ret

00004c22 <GSM_CTS_RTS_Config>:

	void GSM_CTS_RTS_Config(void){
		cli();
    4c22:	f8 94       	cli
		//TS
		DDRB &=~(1<<PB6);
    4c24:	26 98       	cbi	0x04, 6	; 4
		PORTB |=(1<<PB6);	//pull'up
    4c26:	2e 9a       	sbi	0x05, 6	; 5
		//RTS
		DDRG |= (1<<PG5);
    4c28:	9d 9a       	sbi	0x13, 5	; 19
		PORTG &= ~(1<<PG5);
    4c2a:	a5 98       	cbi	0x14, 5	; 20
		sei();
    4c2c:	78 94       	sei
	}
    4c2e:	08 95       	ret

00004c30 <GSM_CTS_State>:
	uint8_t GSM_CTS_State(void){
		return PINB & (1<<PB6);
    4c30:	83 b1       	in	r24, 0x03	; 3
	}
    4c32:	80 74       	andi	r24, 0x40	; 64
    4c34:	08 95       	ret

00004c36 <GSM_RTS_OFF>:
	void GSM_RTS_OFF(void){
		cli();
    4c36:	f8 94       	cli
		PORTG &= ~(1<<PG5);
    4c38:	a5 98       	cbi	0x14, 5	; 20
		sei();
    4c3a:	78 94       	sei
	}
    4c3c:	08 95       	ret

00004c3e <GSM_RTS_ON>:
	void GSM_RTS_ON(void){
		cli();
    4c3e:	f8 94       	cli
		PORTG |= (1<<PG5);
    4c40:	a5 9a       	sbi	0x14, 5	; 20
		sei();
    4c42:	78 94       	sei
	}
    4c44:	08 95       	ret

00004c46 <LED_Init>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    4c46:	8f b7       	in	r24, 0x3f	; 63
    4c48:	80 78       	andi	r24, 0x80	; 128
    4c4a:	80 93 ec 02 	sts	0x02EC, r24
	cli();
    4c4e:	f8 94       	cli
//~~~~~~~~~~~~
void
LED_Init(void)
{
	IntOff();
	DDR_LED |=PinLED;
    4c50:	83 9a       	sbi	0x10, 3	; 16
	LED_Rst();
    4c52:	8b 98       	cbi	0x11, 3	; 17

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    4c54:	88 23       	and	r24, r24
    4c56:	09 f0       	breq	.+2      	; 0x4c5a <LED_Init+0x14>
		sei();
    4c58:	78 94       	sei
    4c5a:	08 95       	ret

00004c5c <LED_On>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    4c5c:	8f b7       	in	r24, 0x3f	; 63
    4c5e:	80 78       	andi	r24, 0x80	; 128
    4c60:	80 93 ec 02 	sts	0x02EC, r24
	cli();
    4c64:	f8 94       	cli
// ~~~~~~~~~
void
LED_On(void)
{
	IntOff();
	LED_Set();
    4c66:	8b 9a       	sbi	0x11, 3	; 17

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    4c68:	88 23       	and	r24, r24
    4c6a:	09 f0       	breq	.+2      	; 0x4c6e <LED_On+0x12>
		sei();
    4c6c:	78 94       	sei
    4c6e:	08 95       	ret

00004c70 <LED_Off>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    4c70:	8f b7       	in	r24, 0x3f	; 63
    4c72:	80 78       	andi	r24, 0x80	; 128
    4c74:	80 93 ec 02 	sts	0x02EC, r24
	cli();
    4c78:	f8 94       	cli
// ~~~~~~~~~~
void
LED_Off(void)
{
	IntOff();
	LED_Rst();
    4c7a:	8b 98       	cbi	0x11, 3	; 17

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    4c7c:	88 23       	and	r24, r24
    4c7e:	09 f0       	breq	.+2      	; 0x4c82 <LED_Off+0x12>
		sei();
    4c80:	78 94       	sei
    4c82:	08 95       	ret

00004c84 <LED_Toggle>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    4c84:	8f b7       	in	r24, 0x3f	; 63
    4c86:	80 78       	andi	r24, 0x80	; 128
    4c88:	80 93 ec 02 	sts	0x02EC, r24
	cli();
    4c8c:	f8 94       	cli
// ~~~~~~~~~~~~~
uint8_t
LED_Toggle(void)
{
	IntOff();
	LED_Inv();
    4c8e:	91 b3       	in	r25, 0x11	; 17
    4c90:	28 e0       	ldi	r18, 0x08	; 8
    4c92:	92 27       	eor	r25, r18
    4c94:	91 bb       	out	0x11, r25	; 17

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    4c96:	88 23       	and	r24, r24
    4c98:	09 f0       	breq	.+2      	; 0x4c9c <LED_Toggle+0x18>
		sei();
    4c9a:	78 94       	sei
	IntOn();
	return PortLED &PinLED;
    4c9c:	81 b3       	in	r24, 0x11	; 17
}
    4c9e:	88 70       	andi	r24, 0x08	; 8
    4ca0:	08 95       	ret

00004ca2 <Send>:
#ifdef Port_LCD_DB0	//8-bit width data bus
	// ~~~~~~~~~~~~~~
	static void
	Send(uint8_t Val)
	{
		if (Val &(1<<0)) Port_LCD_DB0 |=DB0; else Port_LCD_DB0 &=~DB0;
    4ca2:	98 2f       	mov	r25, r24
    4ca4:	80 ff       	sbrs	r24, 0
    4ca6:	23 c0       	rjmp	.+70     	; 0x4cee <Send+0x4c>
    4ca8:	41 9a       	sbi	0x08, 1	; 8
		if (Val &(1<<1)) Port_LCD_DB1 |=DB1; else Port_LCD_DB1 &=~DB1;
    4caa:	91 ff       	sbrs	r25, 1
    4cac:	23 c0       	rjmp	.+70     	; 0x4cf4 <Send+0x52>
    4cae:	40 9a       	sbi	0x08, 0	; 8
		if (Val &(1<<2)) Port_LCD_DB2 |=DB2; else Port_LCD_DB2 &=~DB2;
    4cb0:	92 ff       	sbrs	r25, 2
    4cb2:	23 c0       	rjmp	.+70     	; 0x4cfa <Send+0x58>
    4cb4:	a1 9a       	sbi	0x14, 1	; 20
		if (Val &(1<<3)) Port_LCD_DB3 |=DB3; else Port_LCD_DB3 &=~DB3;
    4cb6:	93 ff       	sbrs	r25, 3
    4cb8:	23 c0       	rjmp	.+70     	; 0x4d00 <Send+0x5e>
    4cba:	a0 9a       	sbi	0x14, 0	; 20
		if (Val &(1<<4)) Port_LCD_DB4 |=DB4; else Port_LCD_DB4 &=~DB4;
    4cbc:	94 ff       	sbrs	r25, 4
    4cbe:	23 c0       	rjmp	.+70     	; 0x4d06 <Send+0x64>
    4cc0:	5f 9a       	sbi	0x0b, 7	; 11
		if (Val &(1<<5)) Port_LCD_DB5 |=DB5; else Port_LCD_DB5 &=~DB5;
    4cc2:	95 ff       	sbrs	r25, 5
    4cc4:	23 c0       	rjmp	.+70     	; 0x4d0c <Send+0x6a>
    4cc6:	5e 9a       	sbi	0x0b, 6	; 11
		if (Val &(1<<6)) Port_LCD_DB6 |=DB6; else Port_LCD_DB6 &=~DB6;
    4cc8:	96 ff       	sbrs	r25, 6
    4cca:	23 c0       	rjmp	.+70     	; 0x4d12 <Send+0x70>
    4ccc:	5d 9a       	sbi	0x0b, 5	; 11
		if (Val &(1<<7)) Port_LCD_DB7 |=DB7; else Port_LCD_DB7 &=~DB7;
    4cce:	87 fd       	sbrc	r24, 7
    4cd0:	23 c0       	rjmp	.+70     	; 0x4d18 <Send+0x76>
    4cd2:	80 91 0b 01 	lds	r24, 0x010B
    4cd6:	8f 77       	andi	r24, 0x7F	; 127
    4cd8:	80 93 0b 01 	sts	0x010B, r24

		Port_LCD_E |=LCD_E;
    4cdc:	42 9a       	sbi	0x08, 2	; 8
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    4cde:	85 e0       	ldi	r24, 0x05	; 5
    4ce0:	98 2f       	mov	r25, r24
    4ce2:	9a 95       	dec	r25
    4ce4:	f1 f7       	brne	.-4      	; 0x4ce2 <Send+0x40>
		_delay_us(1);		// 450 ns needs
		Port_LCD_E &=~LCD_E;
    4ce6:	42 98       	cbi	0x08, 2	; 8
    4ce8:	8a 95       	dec	r24
    4cea:	f1 f7       	brne	.-4      	; 0x4ce8 <Send+0x46>
		_delay_us(1);		// 10 ns needs
	}
    4cec:	08 95       	ret
#ifdef Port_LCD_DB0	//8-bit width data bus
	// ~~~~~~~~~~~~~~
	static void
	Send(uint8_t Val)
	{
		if (Val &(1<<0)) Port_LCD_DB0 |=DB0; else Port_LCD_DB0 &=~DB0;
    4cee:	41 98       	cbi	0x08, 1	; 8
		if (Val &(1<<1)) Port_LCD_DB1 |=DB1; else Port_LCD_DB1 &=~DB1;
    4cf0:	91 fd       	sbrc	r25, 1
    4cf2:	dd cf       	rjmp	.-70     	; 0x4cae <Send+0xc>
    4cf4:	40 98       	cbi	0x08, 0	; 8
		if (Val &(1<<2)) Port_LCD_DB2 |=DB2; else Port_LCD_DB2 &=~DB2;
    4cf6:	92 fd       	sbrc	r25, 2
    4cf8:	dd cf       	rjmp	.-70     	; 0x4cb4 <Send+0x12>
    4cfa:	a1 98       	cbi	0x14, 1	; 20
		if (Val &(1<<3)) Port_LCD_DB3 |=DB3; else Port_LCD_DB3 &=~DB3;
    4cfc:	93 fd       	sbrc	r25, 3
    4cfe:	dd cf       	rjmp	.-70     	; 0x4cba <Send+0x18>
    4d00:	a0 98       	cbi	0x14, 0	; 20
		if (Val &(1<<4)) Port_LCD_DB4 |=DB4; else Port_LCD_DB4 &=~DB4;
    4d02:	94 fd       	sbrc	r25, 4
    4d04:	dd cf       	rjmp	.-70     	; 0x4cc0 <Send+0x1e>
    4d06:	5f 98       	cbi	0x0b, 7	; 11
		if (Val &(1<<5)) Port_LCD_DB5 |=DB5; else Port_LCD_DB5 &=~DB5;
    4d08:	95 fd       	sbrc	r25, 5
    4d0a:	dd cf       	rjmp	.-70     	; 0x4cc6 <Send+0x24>
    4d0c:	5e 98       	cbi	0x0b, 6	; 11
		if (Val &(1<<6)) Port_LCD_DB6 |=DB6; else Port_LCD_DB6 &=~DB6;
    4d0e:	96 fd       	sbrc	r25, 6
    4d10:	dd cf       	rjmp	.-70     	; 0x4ccc <Send+0x2a>
    4d12:	5d 98       	cbi	0x0b, 5	; 11
		if (Val &(1<<7)) Port_LCD_DB7 |=DB7; else Port_LCD_DB7 &=~DB7;
    4d14:	87 ff       	sbrs	r24, 7
    4d16:	dd cf       	rjmp	.-70     	; 0x4cd2 <Send+0x30>
    4d18:	80 91 0b 01 	lds	r24, 0x010B
    4d1c:	80 68       	ori	r24, 0x80	; 128
    4d1e:	80 93 0b 01 	sts	0x010B, r24
    4d22:	dc cf       	rjmp	.-72     	; 0x4cdc <Send+0x3a>

00004d24 <Send_I>:
#endif
// ~~~~~~~~~~~~~~~~
static void
Send_I(uint8_t Val)
{
	Send(Val);
    4d24:	0e 94 51 26 	call	0x4ca2	; 0x4ca2 <Send>
	Delay_us(LCD_Delay);
    4d28:	82 e3       	ldi	r24, 0x32	; 50
    4d2a:	90 e0       	ldi	r25, 0x00	; 0
    4d2c:	0e 94 47 1e 	call	0x3c8e	; 0x3c8e <Delay_us>
}
    4d30:	08 95       	ret

00004d32 <LCD_FuncSet0>:

// ~~~~~~~~~~~
static void
LCD_FuncSet0(void)
{
	Port_LCD_DB4  |=DB4;
    4d32:	5f 9a       	sbi	0x0b, 7	; 11
	Port_LCD_DB5  |=DB5;
    4d34:	5e 9a       	sbi	0x0b, 6	; 11
	Port_LCD_DB6 &=~DB6;
    4d36:	5d 98       	cbi	0x0b, 5	; 11
	Port_LCD_DB7 &=~DB7;
    4d38:	eb e0       	ldi	r30, 0x0B	; 11
    4d3a:	f1 e0       	ldi	r31, 0x01	; 1
    4d3c:	80 81       	ld	r24, Z
    4d3e:	8f 77       	andi	r24, 0x7F	; 127
    4d40:	80 83       	st	Z, r24
}
    4d42:	08 95       	ret

00004d44 <LCD_Rdy>:
}

// ~~~~~~~~~~
uint8_t
LCD_Rdy(void)
{
    4d44:	1f 93       	push	r17
	uint8_t Rdy = Timer8Stopp(TD_LCD);
    4d46:	10 91 d5 04 	lds	r17, 0x04D5
    4d4a:	81 2f       	mov	r24, r17
    4d4c:	0e 94 4e 1c 	call	0x389c	; 0x389c <Timer8Stopp>
	Rdy = Rdy && !(TIMSK_LCD &(1<<OCIE1B));
    4d50:	88 23       	and	r24, r24
    4d52:	29 f0       	breq	.+10     	; 0x4d5e <LCD_Rdy+0x1a>
    4d54:	80 91 6f 00 	lds	r24, 0x006F
    4d58:	82 ff       	sbrs	r24, 2
    4d5a:	03 c0       	rjmp	.+6      	; 0x4d62 <LCD_Rdy+0x1e>
    4d5c:	80 e0       	ldi	r24, 0x00	; 0
	if (Rdy)
		StartTimer8(TD_LCD, 6);
	return Rdy;
}
    4d5e:	1f 91       	pop	r17
    4d60:	08 95       	ret
LCD_Rdy(void)
{
	uint8_t Rdy = Timer8Stopp(TD_LCD);
	Rdy = Rdy && !(TIMSK_LCD &(1<<OCIE1B));
	if (Rdy)
		StartTimer8(TD_LCD, 6);
    4d62:	81 2f       	mov	r24, r17
    4d64:	66 e0       	ldi	r22, 0x06	; 6
    4d66:	0e 94 fa 1a 	call	0x35f4	; 0x35f4 <StartTimer8>
    4d6a:	81 e0       	ldi	r24, 0x01	; 1
	return Rdy;
}
    4d6c:	1f 91       	pop	r17
    4d6e:	08 95       	ret

00004d70 <LCD_Out>:
LCD_Out(void)
{
	static uint8_t N;
	uint16_t LCD_delay = 100;	//50us

	if( (N>=20) && !LCD_Rst_Flg ){
    4d70:	90 91 e9 02 	lds	r25, 0x02E9
    4d74:	94 31       	cpi	r25, 0x14	; 20
    4d76:	20 f0       	brcs	.+8      	; 0x4d80 <LCD_Out+0x10>
    4d78:	80 91 d4 04 	lds	r24, 0x04D4
    4d7c:	88 23       	and	r24, r24
    4d7e:	19 f1       	breq	.+70     	; 0x4dc6 <LCD_Out+0x56>
		LCD_Rst0();
		LCD_Rst_Flg = 1;
		LCD_delay = 10000;	//5ms
	}
	else {
		N++;
    4d80:	9f 5f       	subi	r25, 0xFF	; 255
    4d82:	90 93 e9 02 	sts	0x02E9, r25
    4d86:	24 e6       	ldi	r18, 0x64	; 100
    4d88:	30 e0       	ldi	r19, 0x00	; 0
	}

	cli();
    4d8a:	f8 94       	cli
	LCD_delay = TCNT1 + LCD_delay;
    4d8c:	80 91 84 00 	lds	r24, 0x0084
    4d90:	90 91 85 00 	lds	r25, 0x0085
    4d94:	82 0f       	add	r24, r18
    4d96:	93 1f       	adc	r25, r19
	if(LCD_delay >= 20000) OCR1B = LCD_delay - 20000;
    4d98:	2e e4       	ldi	r18, 0x4E	; 78
    4d9a:	80 32       	cpi	r24, 0x20	; 32
    4d9c:	92 07       	cpc	r25, r18
    4d9e:	60 f4       	brcc	.+24     	; 0x4db8 <LCD_Out+0x48>
	else OCR1B = LCD_delay;
    4da0:	90 93 8b 00 	sts	0x008B, r25
    4da4:	80 93 8a 00 	sts	0x008A, r24
	TIFR_LCD |= (1<<OCF1B);
    4da8:	b2 9a       	sbi	0x16, 2	; 22
	TIMSK_LCD |= (1<<OCIE1B);
    4daa:	80 91 6f 00 	lds	r24, 0x006F
    4dae:	84 60       	ori	r24, 0x04	; 4
    4db0:	80 93 6f 00 	sts	0x006F, r24
	sei();
    4db4:	78 94       	sei
}
    4db6:	08 95       	ret
		N++;
	}

	cli();
	LCD_delay = TCNT1 + LCD_delay;
	if(LCD_delay >= 20000) OCR1B = LCD_delay - 20000;
    4db8:	80 52       	subi	r24, 0x20	; 32
    4dba:	9e 44       	sbci	r25, 0x4E	; 78
    4dbc:	90 93 8b 00 	sts	0x008B, r25
    4dc0:	80 93 8a 00 	sts	0x008A, r24
    4dc4:	f1 cf       	rjmp	.-30     	; 0x4da8 <LCD_Out+0x38>
{
	static uint8_t N;
	uint16_t LCD_delay = 100;	//50us

	if( (N>=20) && !LCD_Rst_Flg ){
		N = 0;
    4dc6:	10 92 e9 02 	sts	0x02E9, r1
#endif
// ~~~~~~~~~~~
static void
LCD_Rst0(void)
{
	cli();
    4dca:	f8 94       	cli
	Port_LCD_RS &=~LCD_RS;
    4dcc:	44 98       	cbi	0x08, 4	; 8
	LCD_FuncSet0();
    4dce:	0e 94 99 26 	call	0x4d32	; 0x4d32 <LCD_FuncSet0>
	sei();
    4dd2:	78 94       	sei
	uint16_t LCD_delay = 100;	//50us

	if( (N>=20) && !LCD_Rst_Flg ){
		N = 0;
		LCD_Rst0();
		LCD_Rst_Flg = 1;
    4dd4:	81 e0       	ldi	r24, 0x01	; 1
    4dd6:	80 93 d4 04 	sts	0x04D4, r24
    4dda:	20 e1       	ldi	r18, 0x10	; 16
    4ddc:	37 e2       	ldi	r19, 0x27	; 39
    4dde:	d5 cf       	rjmp	.-86     	; 0x4d8a <LCD_Out+0x1a>

00004de0 <__vector_18>:
	sei();
}

// ~~~~~~~~~~~~~~~~~~~~~~
// 40 us needs
ISR(TIMER1_COMPB_vect){
    4de0:	1f 92       	push	r1
    4de2:	0f 92       	push	r0
    4de4:	0f b6       	in	r0, 0x3f	; 63
    4de6:	0f 92       	push	r0
    4de8:	0b b6       	in	r0, 0x3b	; 59
    4dea:	0f 92       	push	r0
    4dec:	11 24       	eor	r1, r1
    4dee:	ff 92       	push	r15
    4df0:	0f 93       	push	r16
    4df2:	1f 93       	push	r17
    4df4:	2f 93       	push	r18
    4df6:	3f 93       	push	r19
    4df8:	4f 93       	push	r20
    4dfa:	5f 93       	push	r21
    4dfc:	6f 93       	push	r22
    4dfe:	7f 93       	push	r23
    4e00:	8f 93       	push	r24
    4e02:	9f 93       	push	r25
    4e04:	af 93       	push	r26
    4e06:	bf 93       	push	r27
    4e08:	ef 93       	push	r30
    4e0a:	ff 93       	push	r31

	uint16_t LCD_delay = 100;	//50us

	if (LCD_Rst_Flg) {
    4e0c:	80 91 d4 04 	lds	r24, 0x04D4
    4e10:	88 23       	and	r24, r24
    4e12:	f1 f0       	breq	.+60     	; 0x4e50 <__vector_18+0x70>
		switch(LCD_Rst_Flg){
    4e14:	10 91 d4 04 	lds	r17, 0x04D4
    4e18:	15 30       	cpi	r17, 0x05	; 5
    4e1a:	09 f4       	brne	.+2      	; 0x4e1e <__vector_18+0x3e>
    4e1c:	b5 c0       	rjmp	.+362    	; 0x4f88 <__vector_18+0x1a8>
    4e1e:	16 30       	cpi	r17, 0x06	; 6
    4e20:	08 f4       	brcc	.+2      	; 0x4e24 <__vector_18+0x44>
    4e22:	a1 c0       	rjmp	.+322    	; 0x4f66 <__vector_18+0x186>
    4e24:	17 30       	cpi	r17, 0x07	; 7
    4e26:	09 f4       	brne	.+2      	; 0x4e2a <__vector_18+0x4a>
    4e28:	15 c1       	rjmp	.+554    	; 0x5054 <__vector_18+0x274>
    4e2a:	17 30       	cpi	r17, 0x07	; 7
    4e2c:	08 f0       	brcs	.+2      	; 0x4e30 <__vector_18+0x50>
    4e2e:	dc c0       	rjmp	.+440    	; 0x4fe8 <__vector_18+0x208>
				break;
			case 5:
				Send(0b00001100);	//; Display on, cursor off, blink off	
				break;
			case 6:
				Send(0b00000110);	//; cursor shift right, no display shift
    4e30:	86 e0       	ldi	r24, 0x06	; 6
    4e32:	0e 94 51 26 	call	0x4ca2	; 0x4ca2 <Send>
				#endif
				Port_LCD_RS |=LCD_RS;
			default:
				LCD_Rst_Flg = 255;
		}
		if(LCD_Rst_Flg==1) LCD_delay = 400;	//200us
    4e36:	80 91 d4 04 	lds	r24, 0x04D4
    4e3a:	81 30       	cpi	r24, 0x01	; 1
    4e3c:	09 f4       	brne	.+2      	; 0x4e40 <__vector_18+0x60>
    4e3e:	a1 c0       	rjmp	.+322    	; 0x4f82 <__vector_18+0x1a2>
    4e40:	24 e6       	ldi	r18, 0x64	; 100
    4e42:	30 e0       	ldi	r19, 0x00	; 0

		LCD_Rst_Flg++;
    4e44:	80 91 d4 04 	lds	r24, 0x04D4
    4e48:	8f 5f       	subi	r24, 0xFF	; 255
    4e4a:	80 93 d4 04 	sts	0x04D4, r24
    4e4e:	5f c0       	rjmp	.+190    	; 0x4f0e <__vector_18+0x12e>
	else {
		static uint8_t X, Y;
		static prog_uint8_t LineAddr[] = {128, 192, 148, 212};
		unsigned char cursor_symb;
		
		if (X<LCDXSz) {
    4e50:	10 91 e6 02 	lds	r17, 0x02E6
    4e54:	14 31       	cpi	r17, 0x14	; 20
    4e56:	08 f0       	brcs	.+2      	; 0x4e5a <__vector_18+0x7a>
    4e58:	45 c0       	rjmp	.+138    	; 0x4ee4 <__vector_18+0x104>
			if((X>=CurrX)&&(X<(CurrX+StrSize))&&(Y==CurrLCD)){
    4e5a:	80 91 b7 06 	lds	r24, 0x06B7
    4e5e:	18 17       	cp	r17, r24
    4e60:	08 f4       	brcc	.+2      	; 0x4e64 <__vector_18+0x84>
    4e62:	96 c0       	rjmp	.+300    	; 0x4f90 <__vector_18+0x1b0>
    4e64:	61 2f       	mov	r22, r17
    4e66:	70 e0       	ldi	r23, 0x00	; 0
    4e68:	20 91 aa 06 	lds	r18, 0x06AA
    4e6c:	90 e0       	ldi	r25, 0x00	; 0
    4e6e:	82 0f       	add	r24, r18
    4e70:	91 1d       	adc	r25, r1
    4e72:	68 17       	cp	r22, r24
    4e74:	79 07       	cpc	r23, r25
    4e76:	0c f4       	brge	.+2      	; 0x4e7a <__vector_18+0x9a>
    4e78:	e4 c0       	rjmp	.+456    	; 0x5042 <__vector_18+0x262>
    4e7a:	e0 91 e5 02 	lds	r30, 0x02E5
    4e7e:	20 e0       	ldi	r18, 0x00	; 0
			else
			{
				cursor_symb=0;
			}

			Send(
    4e80:	4e 2f       	mov	r20, r30
    4e82:	50 e0       	ldi	r21, 0x00	; 0
    4e84:	90 91 d0 08 	lds	r25, 0x08D0
    4e88:	89 2f       	mov	r24, r25
    4e8a:	88 50       	subi	r24, 0x08	; 8
    4e8c:	83 30       	cpi	r24, 0x03	; 3
    4e8e:	18 f0       	brcs	.+6      	; 0x4e96 <__vector_18+0xb6>
    4e90:	9e 30       	cpi	r25, 0x0E	; 14
    4e92:	08 f4       	brcc	.+2      	; 0x4e96 <__vector_18+0xb6>
    4e94:	91 c0       	rjmp	.+290    	; 0x4fb8 <__vector_18+0x1d8>
    4e96:	22 23       	and	r18, r18
    4e98:	09 f4       	brne	.+2      	; 0x4e9c <__vector_18+0xbc>
    4e9a:	8e c0       	rjmp	.+284    	; 0x4fb8 <__vector_18+0x1d8>
    4e9c:	80 91 d6 02 	lds	r24, 0x02D6
    4ea0:	8f 3f       	cpi	r24, 0xFF	; 255
    4ea2:	09 f4       	brne	.+2      	; 0x4ea6 <__vector_18+0xc6>
    4ea4:	89 c0       	rjmp	.+274    	; 0x4fb8 <__vector_18+0x1d8>
    4ea6:	e2 2f       	mov	r30, r18
    4ea8:	f0 e0       	ldi	r31, 0x00	; 0
    4eaa:	e8 55       	subi	r30, 0x58	; 88
    4eac:	f1 4d       	sbci	r31, 0xD1	; 209
    4eae:	24 91       	lpm	r18, Z+
    4eb0:	fa 01       	movw	r30, r20
    4eb2:	ee 0f       	add	r30, r30
    4eb4:	ff 1f       	adc	r31, r31
    4eb6:	ee 0f       	add	r30, r30
    4eb8:	ff 1f       	adc	r31, r31
    4eba:	cf 01       	movw	r24, r30
    4ebc:	88 0f       	add	r24, r24
    4ebe:	99 1f       	adc	r25, r25
    4ec0:	88 0f       	add	r24, r24
    4ec2:	99 1f       	adc	r25, r25
    4ec4:	e8 0f       	add	r30, r24
    4ec6:	f9 1f       	adc	r31, r25
    4ec8:	e6 0f       	add	r30, r22
    4eca:	f7 1f       	adc	r31, r23
    4ecc:	e5 5b       	subi	r30, 0xB5	; 181
    4ece:	f7 4f       	sbci	r31, 0xF7	; 247
    4ed0:	20 83       	st	Z, r18
    4ed2:	82 2f       	mov	r24, r18
    4ed4:	0e 94 51 26 	call	0x4ca2	; 0x4ca2 <Send>
				#ifndef QslRD
					*((uint8_t*)RMON+Y*LCDXSz+X) =
				#endif
			#endif
				(((Blink>=8 && Blink<=10 )|| Blink>=14)&&cursor_symb&&(CurrField!=255))?prb(Win2LCD+(unsigned char)cursor_symb):(prb(Win2LCD+(unsigned char)LCD_Buf[Y][X])));
				X++;
    4ed8:	1f 5f       	subi	r17, 0xFF	; 255
    4eda:	10 93 e6 02 	sts	0x02E6, r17
    4ede:	24 e6       	ldi	r18, 0x64	; 100
    4ee0:	30 e0       	ldi	r19, 0x00	; 0
    4ee2:	15 c0       	rjmp	.+42     	; 0x4f0e <__vector_18+0x12e>
		}
		else {
			X = 0;
    4ee4:	10 92 e6 02 	sts	0x02E6, r1
			if (++Y==LCDYSz) {
    4ee8:	e0 91 e5 02 	lds	r30, 0x02E5
    4eec:	ef 5f       	subi	r30, 0xFF	; 255
    4eee:	e0 93 e5 02 	sts	0x02E5, r30
    4ef2:	e4 30       	cpi	r30, 0x04	; 4
    4ef4:	09 f4       	brne	.+2      	; 0x4ef8 <__vector_18+0x118>
    4ef6:	51 c0       	rjmp	.+162    	; 0x4f9a <__vector_18+0x1ba>
				Y = 0;
				TIMSK_LCD &= ~(1<<OCIE1B);	//stop Output CompareB interrups
			}
			Port_LCD_RS &=~LCD_RS;
    4ef8:	44 98       	cbi	0x08, 4	; 8
    4efa:	f0 e0       	ldi	r31, 0x00	; 0
    4efc:	e8 55       	subi	r30, 0x58	; 88
    4efe:	f0 4d       	sbci	r31, 0xD0	; 208
    4f00:	e4 91       	lpm	r30, Z+
			Send(prb(LineAddr+Y));
    4f02:	8e 2f       	mov	r24, r30
    4f04:	0e 94 51 26 	call	0x4ca2	; 0x4ca2 <Send>
			Port_LCD_RS |=LCD_RS;
    4f08:	44 9a       	sbi	0x08, 4	; 8
    4f0a:	24 e6       	ldi	r18, 0x64	; 100
    4f0c:	30 e0       	ldi	r19, 0x00	; 0
		}
	}
	LCD_delay = TCNT1 + LCD_delay;
    4f0e:	80 91 84 00 	lds	r24, 0x0084
    4f12:	90 91 85 00 	lds	r25, 0x0085
    4f16:	82 0f       	add	r24, r18
    4f18:	93 1f       	adc	r25, r19
	if(LCD_delay >= 20000) OCR1B = LCD_delay - 20000;
    4f1a:	2e e4       	ldi	r18, 0x4E	; 78
    4f1c:	80 32       	cpi	r24, 0x20	; 32
    4f1e:	92 07       	cpc	r25, r18
    4f20:	d8 f4       	brcc	.+54     	; 0x4f58 <__vector_18+0x178>
	else OCR1B = LCD_delay;
    4f22:	90 93 8b 00 	sts	0x008B, r25
    4f26:	80 93 8a 00 	sts	0x008A, r24
	TIFR_LCD |= (1<<OCF1B);
    4f2a:	b2 9a       	sbi	0x16, 2	; 22
}
    4f2c:	ff 91       	pop	r31
    4f2e:	ef 91       	pop	r30
    4f30:	bf 91       	pop	r27
    4f32:	af 91       	pop	r26
    4f34:	9f 91       	pop	r25
    4f36:	8f 91       	pop	r24
    4f38:	7f 91       	pop	r23
    4f3a:	6f 91       	pop	r22
    4f3c:	5f 91       	pop	r21
    4f3e:	4f 91       	pop	r20
    4f40:	3f 91       	pop	r19
    4f42:	2f 91       	pop	r18
    4f44:	1f 91       	pop	r17
    4f46:	0f 91       	pop	r16
    4f48:	ff 90       	pop	r15
    4f4a:	0f 90       	pop	r0
    4f4c:	0b be       	out	0x3b, r0	; 59
    4f4e:	0f 90       	pop	r0
    4f50:	0f be       	out	0x3f, r0	; 63
    4f52:	0f 90       	pop	r0
    4f54:	1f 90       	pop	r1
    4f56:	18 95       	reti
			Send(prb(LineAddr+Y));
			Port_LCD_RS |=LCD_RS;
		}
	}
	LCD_delay = TCNT1 + LCD_delay;
	if(LCD_delay >= 20000) OCR1B = LCD_delay - 20000;
    4f58:	80 52       	subi	r24, 0x20	; 32
    4f5a:	9e 44       	sbci	r25, 0x4E	; 78
    4f5c:	90 93 8b 00 	sts	0x008B, r25
    4f60:	80 93 8a 00 	sts	0x008A, r24
    4f64:	e2 cf       	rjmp	.-60     	; 0x4f2a <__vector_18+0x14a>
ISR(TIMER1_COMPB_vect){

	uint16_t LCD_delay = 100;	//50us

	if (LCD_Rst_Flg) {
		switch(LCD_Rst_Flg){
    4f66:	12 30       	cpi	r17, 0x02	; 2
    4f68:	21 f1       	breq	.+72     	; 0x4fb2 <__vector_18+0x1d2>
    4f6a:	13 30       	cpi	r17, 0x03	; 3
    4f6c:	f8 f4       	brcc	.+62     	; 0x4fac <__vector_18+0x1cc>
    4f6e:	11 30       	cpi	r17, 0x01	; 1
    4f70:	01 f1       	breq	.+64     	; 0x4fb2 <__vector_18+0x1d2>
				#else
					Send(0b00000010);	//RETURN HOME					
				#endif
				Port_LCD_RS |=LCD_RS;
			default:
				LCD_Rst_Flg = 255;
    4f72:	8f ef       	ldi	r24, 0xFF	; 255
    4f74:	80 93 d4 04 	sts	0x04D4, r24
		}
		if(LCD_Rst_Flg==1) LCD_delay = 400;	//200us
    4f78:	80 91 d4 04 	lds	r24, 0x04D4
    4f7c:	81 30       	cpi	r24, 0x01	; 1
    4f7e:	09 f0       	breq	.+2      	; 0x4f82 <__vector_18+0x1a2>
    4f80:	5f cf       	rjmp	.-322    	; 0x4e40 <__vector_18+0x60>
    4f82:	20 e9       	ldi	r18, 0x90	; 144
    4f84:	31 e0       	ldi	r19, 0x01	; 1
    4f86:	5e cf       	rjmp	.-324    	; 0x4e44 <__vector_18+0x64>
				#else
					Send(0b00101000);	//; 4-bits DL, 2 lines, 5x7 dots
				#endif
				break;
			case 5:
				Send(0b00001100);	//; Display on, cursor off, blink off	
    4f88:	8c e0       	ldi	r24, 0x0C	; 12
    4f8a:	0e 94 51 26 	call	0x4ca2	; 0x4ca2 <Send>
    4f8e:	53 cf       	rjmp	.-346    	; 0x4e36 <__vector_18+0x56>
    4f90:	61 2f       	mov	r22, r17
    4f92:	70 e0       	ldi	r23, 0x00	; 0
    4f94:	e0 91 e5 02 	lds	r30, 0x02E5
    4f98:	72 cf       	rjmp	.-284    	; 0x4e7e <__vector_18+0x9e>
				X++;
		}
		else {
			X = 0;
			if (++Y==LCDYSz) {
				Y = 0;
    4f9a:	10 92 e5 02 	sts	0x02E5, r1
				TIMSK_LCD &= ~(1<<OCIE1B);	//stop Output CompareB interrups
    4f9e:	80 91 6f 00 	lds	r24, 0x006F
    4fa2:	8b 7f       	andi	r24, 0xFB	; 251
    4fa4:	80 93 6f 00 	sts	0x006F, r24
    4fa8:	e0 e0       	ldi	r30, 0x00	; 0
    4faa:	a6 cf       	rjmp	.-180    	; 0x4ef8 <__vector_18+0x118>
ISR(TIMER1_COMPB_vect){

	uint16_t LCD_delay = 100;	//50us

	if (LCD_Rst_Flg) {
		switch(LCD_Rst_Flg){
    4fac:	13 30       	cpi	r17, 0x03	; 3
    4fae:	09 f0       	breq	.+2      	; 0x4fb2 <__vector_18+0x1d2>
    4fb0:	56 c0       	rjmp	.+172    	; 0x505e <__vector_18+0x27e>
			case 2:
				LCD_FuncSet0();
				break;
			case 3:
				#ifdef Port_LCD_DB0	
					LCD_FuncSet0();
    4fb2:	0e 94 99 26 	call	0x4d32	; 0x4d32 <LCD_FuncSet0>
    4fb6:	3f cf       	rjmp	.-386    	; 0x4e36 <__vector_18+0x56>
			else
			{
				cursor_symb=0;
			}

			Send(
    4fb8:	ca 01       	movw	r24, r20
    4fba:	88 0f       	add	r24, r24
    4fbc:	99 1f       	adc	r25, r25
    4fbe:	84 0f       	add	r24, r20
    4fc0:	95 1f       	adc	r25, r21
    4fc2:	fc 01       	movw	r30, r24
    4fc4:	ee 0f       	add	r30, r30
    4fc6:	ff 1f       	adc	r31, r31
    4fc8:	ee 0f       	add	r30, r30
    4fca:	ff 1f       	adc	r31, r31
    4fcc:	ee 0f       	add	r30, r30
    4fce:	ff 1f       	adc	r31, r31
    4fd0:	e8 1b       	sub	r30, r24
    4fd2:	f9 0b       	sbc	r31, r25
    4fd4:	e6 0f       	add	r30, r22
    4fd6:	f7 1f       	adc	r31, r23
    4fd8:	ea 5a       	subi	r30, 0xAA	; 170
    4fda:	f9 4f       	sbci	r31, 0xF9	; 249
    4fdc:	e0 81       	ld	r30, Z
    4fde:	f0 e0       	ldi	r31, 0x00	; 0
    4fe0:	e8 55       	subi	r30, 0x58	; 88
    4fe2:	f1 4d       	sbci	r31, 0xD1	; 209
    4fe4:	24 91       	lpm	r18, Z+
    4fe6:	64 cf       	rjmp	.-312    	; 0x4eb0 <__vector_18+0xd0>
ISR(TIMER1_COMPB_vect){

	uint16_t LCD_delay = 100;	//50us

	if (LCD_Rst_Flg) {
		switch(LCD_Rst_Flg){
    4fe8:	18 30       	cpi	r17, 0x08	; 8
    4fea:	49 f0       	breq	.+18     	; 0x4ffe <__vector_18+0x21e>
    4fec:	19 30       	cpi	r17, 0x09	; 9
    4fee:	09 f0       	breq	.+2      	; 0x4ff2 <__vector_18+0x212>
    4ff0:	c0 cf       	rjmp	.-128    	; 0x4f72 <__vector_18+0x192>
						else{i=0;LCD_Rst_Flg = 8;}
					}
				}
				break;
			case 9:
				Port_LCD_RS &=~LCD_RS;
    4ff2:	44 98       	cbi	0x08, 4	; 8
				#ifdef NOT_USE_LCD_RETURN_HOME_CMD
					Send(128);			//     
				#else
					Send(0b00000010);	//RETURN HOME					
    4ff4:	82 e0       	ldi	r24, 0x02	; 2
    4ff6:	0e 94 51 26 	call	0x4ca2	; 0x4ca2 <Send>
				#endif
				Port_LCD_RS |=LCD_RS;
    4ffa:	44 9a       	sbi	0x08, 4	; 8
    4ffc:	ba cf       	rjmp	.-140    	; 0x4f72 <__vector_18+0x192>
				Send(0b01000000);	//;    CG RAM   0.
				Port_LCD_RS |=LCD_RS;
				break;
			case 8:{
					static uint8_t i,j;
					LCD_Rst_Flg = 7;
    4ffe:	87 e0       	ldi	r24, 0x07	; 7
    5000:	80 93 d4 04 	sts	0x04D4, r24
					Send(prb(CGRAM_LCD[i]+j));
    5004:	f0 90 e8 02 	lds	r15, 0x02E8
    5008:	00 91 e7 02 	lds	r16, 0x02E7
    500c:	ef 2d       	mov	r30, r15
    500e:	f0 e0       	ldi	r31, 0x00	; 0
    5010:	ee 0f       	add	r30, r30
    5012:	ff 1f       	adc	r31, r31
    5014:	ee 0f       	add	r30, r30
    5016:	ff 1f       	adc	r31, r31
    5018:	ee 0f       	add	r30, r30
    501a:	ff 1f       	adc	r31, r31
    501c:	e0 0f       	add	r30, r16
    501e:	f1 1d       	adc	r31, r1
    5020:	e8 59       	subi	r30, 0x98	; 152
    5022:	f1 4d       	sbci	r31, 0xD1	; 209
    5024:	e4 91       	lpm	r30, Z+
    5026:	8e 2f       	mov	r24, r30
    5028:	0e 94 51 26 	call	0x4ca2	; 0x4ca2 <Send>
					if(j<7) j++;
    502c:	07 30       	cpi	r16, 0x07	; 7
    502e:	f0 f0       	brcs	.+60     	; 0x506c <__vector_18+0x28c>
					else{
						j=0;
    5030:	10 92 e7 02 	sts	0x02E7, r1
						if(i<7)i++;
    5034:	26 e0       	ldi	r18, 0x06	; 6
    5036:	2f 15       	cp	r18, r15
    5038:	e8 f0       	brcs	.+58     	; 0x5074 <__vector_18+0x294>
    503a:	f3 94       	inc	r15
    503c:	f0 92 e8 02 	sts	0x02E8, r15
    5040:	fa ce       	rjmp	.-524    	; 0x4e36 <__vector_18+0x56>
		static uint8_t X, Y;
		static prog_uint8_t LineAddr[] = {128, 192, 148, 212};
		unsigned char cursor_symb;
		
		if (X<LCDXSz) {
			if((X>=CurrX)&&(X<(CurrX+StrSize))&&(Y==CurrLCD)){
    5042:	e0 91 e5 02 	lds	r30, 0x02E5
    5046:	80 91 a0 08 	lds	r24, 0x08A0
    504a:	e8 17       	cp	r30, r24
    504c:	09 f0       	breq	.+2      	; 0x5050 <__vector_18+0x270>
    504e:	17 cf       	rjmp	.-466    	; 0x4e7e <__vector_18+0x9e>
    5050:	2f e5       	ldi	r18, 0x5F	; 95
    5052:	16 cf       	rjmp	.-468    	; 0x4e80 <__vector_18+0xa0>
				break;
			case 6:
				Send(0b00000110);	//; cursor shift right, no display shift
				break;
			case 7:
				Send(0b01000000);	//;    CG RAM   0.
    5054:	80 e4       	ldi	r24, 0x40	; 64
    5056:	0e 94 51 26 	call	0x4ca2	; 0x4ca2 <Send>
				Port_LCD_RS |=LCD_RS;
    505a:	44 9a       	sbi	0x08, 4	; 8
    505c:	ec ce       	rjmp	.-552    	; 0x4e36 <__vector_18+0x56>
ISR(TIMER1_COMPB_vect){

	uint16_t LCD_delay = 100;	//50us

	if (LCD_Rst_Flg) {
		switch(LCD_Rst_Flg){
    505e:	14 30       	cpi	r17, 0x04	; 4
    5060:	09 f0       	breq	.+2      	; 0x5064 <__vector_18+0x284>
    5062:	87 cf       	rjmp	.-242    	; 0x4f72 <__vector_18+0x192>
					LCD_FuncSet1();
				#endif
				break;
			case 4:
				#ifdef Port_LCD_DB0	
					Send(0b00111000);	//; 8-bits DL, 2 lines, 5x7 dots
    5064:	88 e3       	ldi	r24, 0x38	; 56
    5066:	0e 94 51 26 	call	0x4ca2	; 0x4ca2 <Send>
    506a:	e5 ce       	rjmp	.-566    	; 0x4e36 <__vector_18+0x56>
				break;
			case 8:{
					static uint8_t i,j;
					LCD_Rst_Flg = 7;
					Send(prb(CGRAM_LCD[i]+j));
					if(j<7) j++;
    506c:	0f 5f       	subi	r16, 0xFF	; 255
    506e:	00 93 e7 02 	sts	0x02E7, r16
    5072:	e1 ce       	rjmp	.-574    	; 0x4e36 <__vector_18+0x56>
					else{
						j=0;
						if(i<7)i++;
						else{i=0;LCD_Rst_Flg = 8;}
    5074:	10 92 e8 02 	sts	0x02E8, r1
    5078:	10 93 d4 04 	sts	0x04D4, r17
    507c:	dc ce       	rjmp	.-584    	; 0x4e36 <__vector_18+0x56>

0000507e <LCDBackLightOn>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    507e:	9f b7       	in	r25, 0x3f	; 63
    5080:	90 78       	andi	r25, 0x80	; 128
    5082:	90 93 ec 02 	sts	0x02EC, r25
	cli();
    5086:	f8 94       	cli
	void LCDBackLightOn(void){
		IntOff();	
		#ifdef BACKLIGHT_INVERSION
			PORT_BACKLIGHT &= ~BACKLIGHT;
		#else
			PORT_BACKLIGHT |= BACKLIGHT;
    5088:	80 91 0b 01 	lds	r24, 0x010B
    508c:	80 64       	ori	r24, 0x40	; 64
    508e:	80 93 0b 01 	sts	0x010B, r24

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    5092:	99 23       	and	r25, r25
    5094:	09 f0       	breq	.+2      	; 0x5098 <LCDBackLightOn+0x1a>
		sei();
    5096:	78 94       	sei
    5098:	08 95       	ret

0000509a <LCDBackLightOff>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    509a:	9f b7       	in	r25, 0x3f	; 63
    509c:	90 78       	andi	r25, 0x80	; 128
    509e:	90 93 ec 02 	sts	0x02EC, r25
	cli();
    50a2:	f8 94       	cli
	void LCDBackLightOff(void){
		IntOff();	
		#ifdef BACKLIGHT_INVERSION
			PORT_BACKLIGHT |= BACKLIGHT;
		#else
			PORT_BACKLIGHT &= ~BACKLIGHT;
    50a4:	80 91 0b 01 	lds	r24, 0x010B
    50a8:	8f 7b       	andi	r24, 0xBF	; 191
    50aa:	80 93 0b 01 	sts	0x010B, r24

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    50ae:	99 23       	and	r25, r25
    50b0:	09 f0       	breq	.+2      	; 0x50b4 <LCDBackLightOff+0x1a>
		sei();
    50b2:	78 94       	sei
    50b4:	08 95       	ret

000050b6 <LCDBackLightControl>:
				StartTimer16(TD_BackLight, 3000);
				break;			
		}
	}
	void LCDBackLightControl(void){
		switch(BackLightMode){
    50b6:	80 91 50 06 	lds	r24, 0x0650
    50ba:	81 30       	cpi	r24, 0x01	; 1
    50bc:	29 f0       	breq	.+10     	; 0x50c8 <LCDBackLightControl+0x12>
    50be:	82 30       	cpi	r24, 0x02	; 2
    50c0:	61 f0       	breq	.+24     	; 0x50da <LCDBackLightControl+0x24>
		case 1: if(Timer16Stopp(TD_BackLight)) LCDBackLightOff();
			break;
		case 2:
			break;
		default: LCDBackLightOn();
    50c2:	0e 94 3f 28 	call	0x507e	; 0x507e <LCDBackLightOn>
    50c6:	08 95       	ret
				break;			
		}
	}
	void LCDBackLightControl(void){
		switch(BackLightMode){
		case 1: if(Timer16Stopp(TD_BackLight)) LCDBackLightOff();
    50c8:	80 91 d6 04 	lds	r24, 0x04D6
    50cc:	0e 94 71 1c 	call	0x38e2	; 0x38e2 <Timer16Stopp>
    50d0:	88 23       	and	r24, r24
    50d2:	c9 f3       	breq	.-14     	; 0x50c6 <LCDBackLightControl+0x10>
    50d4:	0e 94 4d 28 	call	0x509a	; 0x509a <LCDBackLightOff>
    50d8:	08 95       	ret
    50da:	08 95       	ret

000050dc <StartTimer0>:
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
		TCCR0  = ((((1<<WGM01) &~(1<<WGM00)  &~(1<<COM01)  &~(1<<COM00)) |(1<<CS02)) &~(1<<CS01)) |(1<<CS00);
	#elif defined (__AVR_ATmega128__)
		TCCR0  =   ((1<<WGM01) &~(1<<WGM00)  &~(1<<COM01)  &~(1<<COM00)) |(1<<CS02)   |(1<<CS01)  |(1<<CS00);
	#elif defined (__AVR_ATmega1280__)  || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TCCR0A =    (1<<WGM01) &~(1<<WGM00)  &~(1<<COM0A1) &~(1<<COM0A0) &~(1<<COM0B1) &~(1<<COM0B0);
    50dc:	82 e0       	ldi	r24, 0x02	; 2
    50de:	84 bd       	out	0x24, r24	; 36
		TCCR0B = ((~(1<<WGM02)                                           |(1<<CS02)) &~(1<<CS01)) |(1<<CS00);
    50e0:	85 ef       	ldi	r24, 0xF5	; 245
    50e2:	85 bd       	out	0x25, r24	; 37
	#endif
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__)
		TIMSK |=(1<<OCIE0);
	#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TIMSK0 |=(1<<OCIE0A);
    50e4:	ee e6       	ldi	r30, 0x6E	; 110
    50e6:	f0 e0       	ldi	r31, 0x00	; 0
    50e8:	80 81       	ld	r24, Z
    50ea:	82 60       	ori	r24, 0x02	; 2
    50ec:	80 83       	st	Z, r24
	#endif
}
    50ee:	08 95       	ret

000050f0 <StartTimer2>:
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
		TCCR2  =   ((1<<WGM21) &~(1<<WGM20)  &~(1<<COM21)  &~(1<<COM20)) |(1<<CS22)   |(1<<CS21)  |(1<<CS20);
	#elif defined (__AVR_ATmega128__)
		TCCR2  = ((((1<<WGM21) &~(1<<WGM20)  &~(1<<COM21)  &~(1<<COM20)) |(1<<CS22)) &~(1<<CS21)) |(1<<CS20);
	#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TCCR2A =    (1<<WGM21) &~(1<<WGM20)  &~(1<<COM2A1) &~(1<<COM2A0) &~(1<<COM2B1) &~(1<<COM2B0);
    50f0:	82 e0       	ldi	r24, 0x02	; 2
    50f2:	80 93 b0 00 	sts	0x00B0, r24
		TCCR2B =   ~(1<<WGM22)                                           |(1<<CS22)   |(1<<CS21)  |(1<<CS20);
    50f6:	87 ef       	ldi	r24, 0xF7	; 247
    50f8:	80 93 b1 00 	sts	0x00B1, r24
	#endif
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__)
		TIMSK |=(1<<OCIE2);
	#elif  defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TIMSK2 |=(1<<OCIE2A);
    50fc:	e0 e7       	ldi	r30, 0x70	; 112
    50fe:	f0 e0       	ldi	r31, 0x00	; 0
    5100:	80 81       	ld	r24, Z
    5102:	82 60       	ori	r24, 0x02	; 2
    5104:	80 83       	st	Z, r24
	#endif
}
    5106:	08 95       	ret

00005108 <StartTimer4>:
#if defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
	//static void
	void
	StartTimer4(void)
	{
		TCCR4A = 0;
    5108:	10 92 a0 00 	sts	0x00A0, r1
		TCCR4B = (1<<WGM42) | (1<<CS42) | (0<<CS41) | (1<<CS40);	// clk/1024
    510c:	8d e0       	ldi	r24, 0x0D	; 13
    510e:	80 93 a1 00 	sts	0x00A1, r24
		TIMSK4 |=(1<<OCIE4A);
    5112:	e2 e7       	ldi	r30, 0x72	; 114
    5114:	f0 e0       	ldi	r31, 0x00	; 0
    5116:	80 81       	ld	r24, Z
    5118:	82 60       	ori	r24, 0x02	; 2
    511a:	80 83       	st	Z, r24
	}
    511c:	08 95       	ret

0000511e <MB_Timer_ISR>:
// ~~~

// ~~~~~~~~~~~~~~~~~~~
static void
MB_Timer_ISR(tc_t *tc)
{
    511e:	bc 01       	movw	r22, r24

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5120:	e6 e5       	ldi	r30, 0x56	; 86
    5122:	fe e2       	ldi	r31, 0x2E	; 46
    5124:	85 91       	lpm	r24, Z+
    5126:	94 91       	lpm	r25, Z+
	#if defined (__AVR_ATxmega128A1__)
		tc->INTCTRLA = (tc->INTCTRLA &~TC1_OVFINTLVL_gm) |TC_OVFINTLVL_OFF_gc;
		tc->CTRLA = TC_CLKSEL_OFF_gc;
	#endif
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Timer[MB_N]tc_f)!=tc; MB_N++);
    5128:	68 17       	cp	r22, r24
    512a:	79 07       	cpc	r23, r25
    512c:	09 f4       	brne	.+2      	; 0x5130 <MB_Timer_ISR+0x12>
    512e:	54 c0       	rjmp	.+168    	; 0x51d8 <MB_Timer_ISR+0xba>
    5130:	20 e0       	ldi	r18, 0x00	; 0
    5132:	2f 5f       	subi	r18, 0xFF	; 255
    5134:	42 2f       	mov	r20, r18
    5136:	50 e0       	ldi	r21, 0x00	; 0
    5138:	fa 01       	movw	r30, r20
    513a:	ee 0f       	add	r30, r30
    513c:	ff 1f       	adc	r31, r31
    513e:	e4 0f       	add	r30, r20
    5140:	f5 1f       	adc	r31, r21
    5142:	ee 0f       	add	r30, r30
    5144:	ff 1f       	adc	r31, r31
    5146:	ea 5a       	subi	r30, 0xAA	; 170
    5148:	f1 4d       	sbci	r31, 0xD1	; 209
    514a:	85 91       	lpm	r24, Z+
    514c:	94 91       	lpm	r25, Z+
    514e:	68 17       	cp	r22, r24
    5150:	79 07       	cpc	r23, r25
    5152:	79 f7       	brne	.-34     	; 0x5132 <MB_Timer_ISR+0x14>
    5154:	fa 01       	movw	r30, r20

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    5156:	eb 5a       	subi	r30, 0xAB	; 171
    5158:	f1 4d       	sbci	r31, 0xD1	; 209
    515a:	84 91       	lpm	r24, Z+

	
	switch (prb(MB_Role+MB_N)){
    515c:	88 23       	and	r24, r24
    515e:	f9 f4       	brne	.+62     	; 0x519e <MB_Timer_ISR+0x80>
	case Role_Slave:
		if(MB_Frame[MB_N][0]==MB_NativeAddr[MB_N]){	// Slave     -   MB_TimerFlag
    5160:	f4 2f       	mov	r31, r20
    5162:	ee 27       	eor	r30, r30
    5164:	ed 5d       	subi	r30, 0xDD	; 221
    5166:	f4 4f       	sbci	r31, 0xF4	; 244
    5168:	da 01       	movw	r26, r20
    516a:	a2 52       	subi	r26, 0x22	; 34
    516c:	ba 4f       	sbci	r27, 0xFA	; 250
    516e:	90 81       	ld	r25, Z
    5170:	8c 91       	ld	r24, X
    5172:	98 17       	cp	r25, r24
    5174:	21 f1       	breq	.+72     	; 0x51be <MB_Timer_ISR+0xa0>
			MB_TimerFlag |= (1<<MB_N);
		}
		else{
			MB_State[MB_N] = MB_Idle;
    5176:	fa 01       	movw	r30, r20
    5178:	e0 54       	subi	r30, 0x40	; 64
    517a:	fa 4f       	sbci	r31, 0xFA	; 250
    517c:	81 e0       	ldi	r24, 0x01	; 1
    517e:	80 83       	st	Z, r24
			MB_CPT[MB_N][0]++;
    5180:	fa 01       	movw	r30, r20
    5182:	e2 95       	swap	r30
    5184:	f2 95       	swap	r31
    5186:	f0 7f       	andi	r31, 0xF0	; 240
    5188:	fe 27       	eor	r31, r30
    518a:	e0 7f       	andi	r30, 0xF0	; 240
    518c:	fe 27       	eor	r31, r30
    518e:	e2 51       	subi	r30, 0x12	; 18
    5190:	f7 4f       	sbci	r31, 0xF7	; 247
    5192:	80 81       	ld	r24, Z
    5194:	91 81       	ldd	r25, Z+1	; 0x01
    5196:	01 96       	adiw	r24, 0x01	; 1
    5198:	91 83       	std	Z+1, r25	; 0x01
    519a:	80 83       	st	Z, r24
    519c:	08 95       	ret
	#endif
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Timer[MB_N]tc_f)!=tc; MB_N++);

	
	switch (prb(MB_Role+MB_N)){
    519e:	81 30       	cpi	r24, 0x01	; 1
    51a0:	09 f0       	breq	.+2      	; 0x51a4 <MB_Timer_ISR+0x86>
    51a2:	08 95       	ret
			MB_State[MB_N] = MB_Idle;
			MB_CPT[MB_N][0]++;
		}
		break;
	case Role_Master:
		MB_TimerFlag |= (1<<MB_N);
    51a4:	20 91 e2 08 	lds	r18, 0x08E2
    51a8:	81 e0       	ldi	r24, 0x01	; 1
    51aa:	90 e0       	ldi	r25, 0x00	; 0
    51ac:	02 c0       	rjmp	.+4      	; 0x51b2 <MB_Timer_ISR+0x94>
    51ae:	88 0f       	add	r24, r24
    51b0:	99 1f       	adc	r25, r25
    51b2:	4a 95       	dec	r20
    51b4:	e2 f7       	brpl	.-8      	; 0x51ae <MB_Timer_ISR+0x90>
    51b6:	28 2b       	or	r18, r24
    51b8:	20 93 e2 08 	sts	0x08E2, r18
    51bc:	08 95       	ret

	
	switch (prb(MB_Role+MB_N)){
	case Role_Slave:
		if(MB_Frame[MB_N][0]==MB_NativeAddr[MB_N]){	// Slave     -   MB_TimerFlag
			MB_TimerFlag |= (1<<MB_N);
    51be:	20 91 e2 08 	lds	r18, 0x08E2
    51c2:	81 e0       	ldi	r24, 0x01	; 1
    51c4:	90 e0       	ldi	r25, 0x00	; 0
    51c6:	02 c0       	rjmp	.+4      	; 0x51cc <MB_Timer_ISR+0xae>
    51c8:	88 0f       	add	r24, r24
    51ca:	99 1f       	adc	r25, r25
    51cc:	4a 95       	dec	r20
    51ce:	e2 f7       	brpl	.-8      	; 0x51c8 <MB_Timer_ISR+0xaa>
    51d0:	28 2b       	or	r18, r24
    51d2:	20 93 e2 08 	sts	0x08E2, r18
    51d6:	08 95       	ret
	#if defined (__AVR_ATxmega128A1__)
		tc->INTCTRLA = (tc->INTCTRLA &~TC1_OVFINTLVL_gm) |TC_OVFINTLVL_OFF_gc;
		tc->CTRLA = TC_CLKSEL_OFF_gc;
	#endif
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Timer[MB_N]tc_f)!=tc; MB_N++);
    51d8:	40 e0       	ldi	r20, 0x00	; 0
    51da:	50 e0       	ldi	r21, 0x00	; 0
    51dc:	e0 e0       	ldi	r30, 0x00	; 0
    51de:	f0 e0       	ldi	r31, 0x00	; 0
    51e0:	ba cf       	rjmp	.-140    	; 0x5156 <MB_Timer_ISR+0x38>

000051e2 <__vector_21>:
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#elif  defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) ||defined (__AVR_ATmega2561__)
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ISR(TIMER0_COMPA_vect)
{
    51e2:	1f 92       	push	r1
    51e4:	0f 92       	push	r0
    51e6:	0f b6       	in	r0, 0x3f	; 63
    51e8:	0f 92       	push	r0
    51ea:	0b b6       	in	r0, 0x3b	; 59
    51ec:	0f 92       	push	r0
    51ee:	11 24       	eor	r1, r1
    51f0:	2f 93       	push	r18
    51f2:	3f 93       	push	r19
    51f4:	4f 93       	push	r20
    51f6:	5f 93       	push	r21
    51f8:	6f 93       	push	r22
    51fa:	7f 93       	push	r23
    51fc:	8f 93       	push	r24
    51fe:	9f 93       	push	r25
    5200:	af 93       	push	r26
    5202:	bf 93       	push	r27
    5204:	ef 93       	push	r30
    5206:	ff 93       	push	r31
	TCCR0B &=~(1<<CS02) &~(1<<CS01) &~(1<<CS00);
    5208:	85 b5       	in	r24, 0x25	; 37
    520a:	88 7f       	andi	r24, 0xF8	; 248
    520c:	85 bd       	out	0x25, r24	; 37
	TIMSK0 &=~(1<<OCIE0A);
    520e:	ee e6       	ldi	r30, 0x6E	; 110
    5210:	f0 e0       	ldi	r31, 0x00	; 0
    5212:	80 81       	ld	r24, Z
    5214:	8d 7f       	andi	r24, 0xFD	; 253
    5216:	80 83       	st	Z, r24
	MB_Timer_ISR(&TCNT0);
    5218:	86 e4       	ldi	r24, 0x46	; 70
    521a:	90 e0       	ldi	r25, 0x00	; 0
    521c:	0e 94 8f 28 	call	0x511e	; 0x511e <MB_Timer_ISR>
}
    5220:	ff 91       	pop	r31
    5222:	ef 91       	pop	r30
    5224:	bf 91       	pop	r27
    5226:	af 91       	pop	r26
    5228:	9f 91       	pop	r25
    522a:	8f 91       	pop	r24
    522c:	7f 91       	pop	r23
    522e:	6f 91       	pop	r22
    5230:	5f 91       	pop	r21
    5232:	4f 91       	pop	r20
    5234:	3f 91       	pop	r19
    5236:	2f 91       	pop	r18
    5238:	0f 90       	pop	r0
    523a:	0b be       	out	0x3b, r0	; 59
    523c:	0f 90       	pop	r0
    523e:	0f be       	out	0x3f, r0	; 63
    5240:	0f 90       	pop	r0
    5242:	1f 90       	pop	r1
    5244:	18 95       	reti

00005246 <__vector_13>:

// ~~~~~~~~~~~~~~~~~~~
ISR(TIMER2_COMPA_vect)
{
    5246:	1f 92       	push	r1
    5248:	0f 92       	push	r0
    524a:	0f b6       	in	r0, 0x3f	; 63
    524c:	0f 92       	push	r0
    524e:	0b b6       	in	r0, 0x3b	; 59
    5250:	0f 92       	push	r0
    5252:	11 24       	eor	r1, r1
    5254:	2f 93       	push	r18
    5256:	3f 93       	push	r19
    5258:	4f 93       	push	r20
    525a:	5f 93       	push	r21
    525c:	6f 93       	push	r22
    525e:	7f 93       	push	r23
    5260:	8f 93       	push	r24
    5262:	9f 93       	push	r25
    5264:	af 93       	push	r26
    5266:	bf 93       	push	r27
    5268:	ef 93       	push	r30
    526a:	ff 93       	push	r31
	TCCR2B &=~(1<<CS22) &~(1<<CS21) &~(1<<CS20);
    526c:	e1 eb       	ldi	r30, 0xB1	; 177
    526e:	f0 e0       	ldi	r31, 0x00	; 0
    5270:	80 81       	ld	r24, Z
    5272:	88 7f       	andi	r24, 0xF8	; 248
    5274:	80 83       	st	Z, r24
	TIMSK2 &=~(1<<OCIE2A);
    5276:	e0 e7       	ldi	r30, 0x70	; 112
    5278:	f0 e0       	ldi	r31, 0x00	; 0
    527a:	80 81       	ld	r24, Z
    527c:	8d 7f       	andi	r24, 0xFD	; 253
    527e:	80 83       	st	Z, r24
	MB_Timer_ISR(&TCNT2);
    5280:	82 eb       	ldi	r24, 0xB2	; 178
    5282:	90 e0       	ldi	r25, 0x00	; 0
    5284:	0e 94 8f 28 	call	0x511e	; 0x511e <MB_Timer_ISR>
}
    5288:	ff 91       	pop	r31
    528a:	ef 91       	pop	r30
    528c:	bf 91       	pop	r27
    528e:	af 91       	pop	r26
    5290:	9f 91       	pop	r25
    5292:	8f 91       	pop	r24
    5294:	7f 91       	pop	r23
    5296:	6f 91       	pop	r22
    5298:	5f 91       	pop	r21
    529a:	4f 91       	pop	r20
    529c:	3f 91       	pop	r19
    529e:	2f 91       	pop	r18
    52a0:	0f 90       	pop	r0
    52a2:	0b be       	out	0x3b, r0	; 59
    52a4:	0f 90       	pop	r0
    52a6:	0f be       	out	0x3f, r0	; 63
    52a8:	0f 90       	pop	r0
    52aa:	1f 90       	pop	r1
    52ac:	18 95       	reti

000052ae <__vector_42>:
// ~~~~~~~~~~~~~~~~~~~
ISR(TIMER4_COMPA_vect)
{
    52ae:	1f 92       	push	r1
    52b0:	0f 92       	push	r0
    52b2:	0f b6       	in	r0, 0x3f	; 63
    52b4:	0f 92       	push	r0
    52b6:	0b b6       	in	r0, 0x3b	; 59
    52b8:	0f 92       	push	r0
    52ba:	11 24       	eor	r1, r1
    52bc:	2f 93       	push	r18
    52be:	3f 93       	push	r19
    52c0:	4f 93       	push	r20
    52c2:	5f 93       	push	r21
    52c4:	6f 93       	push	r22
    52c6:	7f 93       	push	r23
    52c8:	8f 93       	push	r24
    52ca:	9f 93       	push	r25
    52cc:	af 93       	push	r26
    52ce:	bf 93       	push	r27
    52d0:	ef 93       	push	r30
    52d2:	ff 93       	push	r31
	TCCR4B &=~(1<<CS42) &~(1<<CS41) &~(1<<CS40);
    52d4:	e1 ea       	ldi	r30, 0xA1	; 161
    52d6:	f0 e0       	ldi	r31, 0x00	; 0
    52d8:	80 81       	ld	r24, Z
    52da:	88 7f       	andi	r24, 0xF8	; 248
    52dc:	80 83       	st	Z, r24
	TIMSK4 &=~(1<<OCIE4A);
    52de:	e2 e7       	ldi	r30, 0x72	; 114
    52e0:	f0 e0       	ldi	r31, 0x00	; 0
    52e2:	80 81       	ld	r24, Z
    52e4:	8d 7f       	andi	r24, 0xFD	; 253
    52e6:	80 83       	st	Z, r24
	MB_Timer_ISR((uint8_t*)&TCNT4);
    52e8:	84 ea       	ldi	r24, 0xA4	; 164
    52ea:	90 e0       	ldi	r25, 0x00	; 0
    52ec:	0e 94 8f 28 	call	0x511e	; 0x511e <MB_Timer_ISR>
}
    52f0:	ff 91       	pop	r31
    52f2:	ef 91       	pop	r30
    52f4:	bf 91       	pop	r27
    52f6:	af 91       	pop	r26
    52f8:	9f 91       	pop	r25
    52fa:	8f 91       	pop	r24
    52fc:	7f 91       	pop	r23
    52fe:	6f 91       	pop	r22
    5300:	5f 91       	pop	r21
    5302:	4f 91       	pop	r20
    5304:	3f 91       	pop	r19
    5306:	2f 91       	pop	r18
    5308:	0f 90       	pop	r0
    530a:	0b be       	out	0x3b, r0	; 59
    530c:	0f 90       	pop	r0
    530e:	0f be       	out	0x3f, r0	; 63
    5310:	0f 90       	pop	r0
    5312:	1f 90       	pop	r1
    5314:	18 95       	reti

00005316 <MBRecept>:
		#endif
		MB_Err &=(1<<MB_N);
		return;
	}
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		Buf = USART_Reg(MB_N, ucsra);
    5316:	68 2f       	mov	r22, r24
    5318:	70 e0       	ldi	r23, 0x00	; 0

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    531a:	9b 01       	movw	r18, r22
    531c:	22 0f       	add	r18, r18
    531e:	33 1f       	adc	r19, r19
    5320:	cb 01       	movw	r24, r22
    5322:	88 0f       	add	r24, r24
    5324:	99 1f       	adc	r25, r25
    5326:	88 0f       	add	r24, r24
    5328:	99 1f       	adc	r25, r25
    532a:	88 0f       	add	r24, r24
    532c:	99 1f       	adc	r25, r25
    532e:	28 0f       	add	r18, r24
    5330:	39 1f       	adc	r19, r25
    5332:	22 0f       	add	r18, r18
    5334:	33 1f       	adc	r19, r19
    5336:	2d 5b       	subi	r18, 0xBD	; 189
    5338:	31 4d       	sbci	r19, 0xD1	; 209
    533a:	f9 01       	movw	r30, r18
    533c:	a5 91       	lpm	r26, Z+
    533e:	b4 91       	lpm	r27, Z+
    5340:	3c 91       	ld	r19, X
		MB_Frame[MB_N][MB_Frame_Sz[MB_N]++] = USART_Reg(MB_N, udr);
    5342:	ab 01       	movw	r20, r22
    5344:	4b 5f       	subi	r20, 0xFB	; 251
    5346:	58 4f       	sbci	r21, 0xF8	; 248
    5348:	fa 01       	movw	r30, r20
    534a:	20 81       	ld	r18, Z
    534c:	cb 01       	movw	r24, r22
    534e:	88 0f       	add	r24, r24
    5350:	99 1f       	adc	r25, r25
    5352:	88 0f       	add	r24, r24
    5354:	99 1f       	adc	r25, r25
    5356:	fc 01       	movw	r30, r24
    5358:	ee 0f       	add	r30, r30
    535a:	ff 1f       	adc	r31, r31
    535c:	ee 0f       	add	r30, r30
    535e:	ff 1f       	adc	r31, r31
    5360:	e8 0f       	add	r30, r24
    5362:	f9 1f       	adc	r31, r25
    5364:	ef 5b       	subi	r30, 0xBF	; 191
    5366:	f1 4d       	sbci	r31, 0xD1	; 209
    5368:	a5 91       	lpm	r26, Z+
    536a:	b4 91       	lpm	r27, Z+
    536c:	f6 2f       	mov	r31, r22
    536e:	ee 27       	eor	r30, r30
    5370:	e2 0f       	add	r30, r18
    5372:	f1 1d       	adc	r31, r1
    5374:	ed 5d       	subi	r30, 0xDD	; 221
    5376:	f4 4f       	sbci	r31, 0xF4	; 244
    5378:	8c 91       	ld	r24, X
    537a:	80 83       	st	Z, r24
    537c:	2f 5f       	subi	r18, 0xFF	; 255
    537e:	fa 01       	movw	r30, r20
    5380:	20 83       	st	Z, r18
	#elif defined (__AVR_ATxmega128A1__)
		USART_t *usart = prp(&MB_Port[MB_N].usart);
		Buf = usart->STATUS;
		MB_Frame[MB_N][MB_Frame_Sz[MB_N]++] = usart->DATA;
	#endif
	if (Buf &(1<<3))
    5382:	23 2f       	mov	r18, r19
    5384:	30 e0       	ldi	r19, 0x00	; 0
    5386:	23 ff       	sbrs	r18, 3
    5388:	0e c0       	rjmp	.+28     	; 0x53a6 <MBRecept+0x90>
		MB_CPT[MB_N][7]++;
    538a:	fb 01       	movw	r30, r22
    538c:	e2 95       	swap	r30
    538e:	f2 95       	swap	r31
    5390:	f0 7f       	andi	r31, 0xF0	; 240
    5392:	fe 27       	eor	r31, r30
    5394:	e0 7f       	andi	r30, 0xF0	; 240
    5396:	fe 27       	eor	r31, r30
    5398:	e2 51       	subi	r30, 0x12	; 18
    539a:	f7 4f       	sbci	r31, 0xF7	; 247
    539c:	86 85       	ldd	r24, Z+14	; 0x0e
    539e:	97 85       	ldd	r25, Z+15	; 0x0f
    53a0:	01 96       	adiw	r24, 0x01	; 1
    53a2:	97 87       	std	Z+15, r25	; 0x0f
    53a4:	86 87       	std	Z+14, r24	; 0x0e
	if (Buf &((1<<4) |(1<<3) |(1<<2)))
    53a6:	2c 71       	andi	r18, 0x1C	; 28
    53a8:	30 70       	andi	r19, 0x00	; 0
    53aa:	23 2b       	or	r18, r19
    53ac:	61 f0       	breq	.+24     	; 0x53c6 <MBRecept+0xb0>
		MB_Err |=(1<<MB_N);
    53ae:	81 e0       	ldi	r24, 0x01	; 1
    53b0:	90 e0       	ldi	r25, 0x00	; 0
    53b2:	02 c0       	rjmp	.+4      	; 0x53b8 <MBRecept+0xa2>
    53b4:	88 0f       	add	r24, r24
    53b6:	99 1f       	adc	r25, r25
    53b8:	6a 95       	dec	r22
    53ba:	e2 f7       	brpl	.-8      	; 0x53b4 <MBRecept+0x9e>
    53bc:	20 91 d7 04 	lds	r18, 0x04D7
    53c0:	28 2b       	or	r18, r24
    53c2:	20 93 d7 04 	sts	0x04D7, r18
    53c6:	08 95       	ret

000053c8 <MB_Transm>:
}

// ~~~~~~~~~~~~~~~~~~~~
void
MB_Transm(uint8_t MB_N)
{
    53c8:	af 92       	push	r10
    53ca:	bf 92       	push	r11
    53cc:	cf 92       	push	r12
    53ce:	df 92       	push	r13
    53d0:	ef 92       	push	r14
    53d2:	ff 92       	push	r15
    53d4:	0f 93       	push	r16
    53d6:	1f 93       	push	r17
	MB_State[MB_N] = MB_Trans;
    53d8:	e8 2e       	mov	r14, r24
    53da:	ff 24       	eor	r15, r15
    53dc:	f7 01       	movw	r30, r14
    53de:	e0 54       	subi	r30, 0x40	; 64
    53e0:	fa 4f       	sbci	r31, 0xFA	; 250
    53e2:	83 e0       	ldi	r24, 0x03	; 3
    53e4:	80 83       	st	Z, r24
    53e6:	57 01       	movw	r10, r14
    53e8:	aa 0c       	add	r10, r10
    53ea:	bb 1c       	adc	r11, r11
    53ec:	aa 0c       	add	r10, r10
    53ee:	bb 1c       	adc	r11, r11
    53f0:	85 01       	movw	r16, r10
    53f2:	00 0f       	add	r16, r16
    53f4:	11 1f       	adc	r17, r17
    53f6:	00 0f       	add	r16, r16
    53f8:	11 1f       	adc	r17, r17
    53fa:	0a 0d       	add	r16, r10
    53fc:	1b 1d       	adc	r17, r11
    53fe:	04 5f       	subi	r16, 0xF4	; 244
    5400:	1f 4f       	sbci	r17, 0xFF	; 255
    5402:	81 e4       	ldi	r24, 0x41	; 65
    5404:	c8 2e       	mov	r12, r24
    5406:	8e e2       	ldi	r24, 0x2E	; 46
    5408:	d8 2e       	mov	r13, r24
    540a:	c6 01       	movw	r24, r12
    540c:	80 0f       	add	r24, r16
    540e:	91 1f       	adc	r25, r17
    5410:	0c 50       	subi	r16, 0x0C	; 12
    5412:	10 40       	sbci	r17, 0x00	; 0
    5414:	fc 01       	movw	r30, r24
    5416:	25 91       	lpm	r18, Z+
    5418:	34 91       	lpm	r19, Z+
	USART_Func(MB_N, RS485);
    541a:	f9 01       	movw	r30, r18
    541c:	19 95       	eicall
    541e:	f6 01       	movw	r30, r12
    5420:	e0 0f       	add	r30, r16
    5422:	f1 1f       	adc	r31, r17
    5424:	a5 91       	lpm	r26, Z+
    5426:	b4 91       	lpm	r27, Z+
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		//USART_Reg(MB_N, ucsrb) |=(1<<6);
		USART_Reg(MB_N, udr) = MB_Frame[MB_N][0];
    5428:	fe 2d       	mov	r31, r14
    542a:	ee 27       	eor	r30, r30
    542c:	ed 5d       	subi	r30, 0xDD	; 221
    542e:	f4 4f       	sbci	r31, 0xF4	; 244
    5430:	80 81       	ld	r24, Z
    5432:	8c 93       	st	X, r24
    5434:	97 01       	movw	r18, r14
    5436:	22 0f       	add	r18, r18
    5438:	33 1f       	adc	r19, r19
    543a:	c7 01       	movw	r24, r14
    543c:	88 0f       	add	r24, r24
    543e:	99 1f       	adc	r25, r25
    5440:	88 0f       	add	r24, r24
    5442:	99 1f       	adc	r25, r25
    5444:	88 0f       	add	r24, r24
    5446:	99 1f       	adc	r25, r25
    5448:	28 0f       	add	r18, r24
    544a:	39 1f       	adc	r19, r25
    544c:	2f 5f       	subi	r18, 0xFF	; 255
    544e:	3f 4f       	sbci	r19, 0xFF	; 255
    5450:	22 0f       	add	r18, r18
    5452:	33 1f       	adc	r19, r19
    5454:	2c 0d       	add	r18, r12
    5456:	3d 1d       	adc	r19, r13
    5458:	f9 01       	movw	r30, r18
    545a:	a5 91       	lpm	r26, Z+
    545c:	b4 91       	lpm	r27, Z+

		USART_Reg(MB_N, ucsra) |=(1<<6);	//Clear TxC pending interrupt		
    545e:	8c 91       	ld	r24, X
    5460:	80 64       	ori	r24, 0x40	; 64
    5462:	8c 93       	st	X, r24
    5464:	c5 01       	movw	r24, r10
    5466:	8e 0d       	add	r24, r14
    5468:	9f 1d       	adc	r25, r15
    546a:	01 96       	adiw	r24, 0x01	; 1
    546c:	88 0f       	add	r24, r24
    546e:	99 1f       	adc	r25, r25
    5470:	88 0f       	add	r24, r24
    5472:	99 1f       	adc	r25, r25
    5474:	8c 0d       	add	r24, r12
    5476:	9d 1d       	adc	r25, r13
    5478:	fc 01       	movw	r30, r24
    547a:	a5 91       	lpm	r26, Z+
    547c:	b4 91       	lpm	r27, Z+
		USART_Reg(MB_N, ucsrb) |=(1<<5);
    547e:	8c 91       	ld	r24, X
    5480:	80 62       	ori	r24, 0x20	; 32
    5482:	8c 93       	st	X, r24
	#elif defined (__AVR_ATxmega128A1__)
		USART_t *usart = prp(&MB_Port[MB_N].usart);
		usart->CTRLA = (usart->CTRLA &~USART_TXCINTLVL_gm) |USART_TXCINTLVL_HI_gc;
		usart->DATA = MB_Frame[MB_N][0];
	#endif
}
    5484:	1f 91       	pop	r17
    5486:	0f 91       	pop	r16
    5488:	ff 90       	pop	r15
    548a:	ef 90       	pop	r14
    548c:	df 90       	pop	r13
    548e:	cf 90       	pop	r12
    5490:	bf 90       	pop	r11
    5492:	af 90       	pop	r10
    5494:	08 95       	ret

00005496 <Modbus_RX>:

// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_RX(usart_t *usart)
{
    5496:	cf 93       	push	r28
    5498:	df 93       	push	r29
    549a:	dc 01       	movw	r26, r24
    549c:	e1 e4       	ldi	r30, 0x41	; 65
    549e:	fe e2       	ldi	r31, 0x2E	; 46
    54a0:	85 91       	lpm	r24, Z+
    54a2:	94 91       	lpm	r25, Z+
// ~~~~~~~~~~~~~~~~~~~~~~
static uint8_t
MB_Port_N(usart_t *usart)
{
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Port[MB_N].usart_field)!=usart; MB_N++);
    54a4:	a8 17       	cp	r26, r24
    54a6:	b9 07       	cpc	r27, r25
    54a8:	09 f4       	brne	.+2      	; 0x54ac <Modbus_RX+0x16>
    54aa:	6e c0       	rjmp	.+220    	; 0x5588 <Modbus_RX+0xf2>
    54ac:	30 e0       	ldi	r19, 0x00	; 0
    54ae:	3f 5f       	subi	r19, 0xFF	; 255
    54b0:	c3 2f       	mov	r28, r19
    54b2:	d0 e0       	ldi	r29, 0x00	; 0
    54b4:	ce 01       	movw	r24, r28
    54b6:	88 0f       	add	r24, r24
    54b8:	99 1f       	adc	r25, r25
    54ba:	88 0f       	add	r24, r24
    54bc:	99 1f       	adc	r25, r25
    54be:	fc 01       	movw	r30, r24
    54c0:	ee 0f       	add	r30, r30
    54c2:	ff 1f       	adc	r31, r31
    54c4:	ee 0f       	add	r30, r30
    54c6:	ff 1f       	adc	r31, r31
    54c8:	e8 0f       	add	r30, r24
    54ca:	f9 1f       	adc	r31, r25
    54cc:	ef 5b       	subi	r30, 0xBF	; 191
    54ce:	f1 4d       	sbci	r31, 0xD1	; 209
    54d0:	85 91       	lpm	r24, Z+
    54d2:	94 91       	lpm	r25, Z+
    54d4:	a8 17       	cp	r26, r24
    54d6:	b9 07       	cpc	r27, r25
    54d8:	51 f7       	brne	.-44     	; 0x54ae <Modbus_RX+0x18>
// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_RX(usart_t *usart)
{
	uint8_t MB_N = MB_Port_N(usart);
	switch (MB_State[MB_N]) {
    54da:	fe 01       	movw	r30, r28
    54dc:	e0 54       	subi	r30, 0x40	; 64
    54de:	fa 4f       	sbci	r31, 0xFA	; 250
    54e0:	80 81       	ld	r24, Z
    54e2:	82 30       	cpi	r24, 0x02	; 2
    54e4:	19 f1       	breq	.+70     	; 0x552c <Modbus_RX+0x96>
    54e6:	83 30       	cpi	r24, 0x03	; 3
    54e8:	28 f0       	brcs	.+10     	; 0x54f4 <Modbus_RX+0x5e>
    54ea:	86 30       	cpi	r24, 0x06	; 6
    54ec:	d8 f0       	brcs	.+54     	; 0x5524 <Modbus_RX+0x8e>
	case MB_Trans: case MB_Proc: 
	case MB_NoReply: // MB_NoReply    MB_Recept ..  MB_M_Cycle   MB_Trans
		usart_data(usart);
		break;
	}
}
    54ee:	df 91       	pop	r29
    54f0:	cf 91       	pop	r28
    54f2:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_RX(usart_t *usart)
{
	uint8_t MB_N = MB_Port_N(usart);
	switch (MB_State[MB_N]) {
    54f4:	88 23       	and	r24, r24
    54f6:	f1 f4       	brne	.+60     	; 0x5534 <Modbus_RX+0x9e>
	case MB_Initi:
		MB_Frame[MB_N][0] = usart_data(usart);
    54f8:	8c 91       	ld	r24, X
    54fa:	fc 2f       	mov	r31, r28
    54fc:	ee 27       	eor	r30, r30
    54fe:	ed 5d       	subi	r30, 0xDD	; 221
    5500:	f4 4f       	sbci	r31, 0xF4	; 244
    5502:	80 83       	st	Z, r24
    5504:	ce 01       	movw	r24, r28
    5506:	88 0f       	add	r24, r24
    5508:	99 1f       	adc	r25, r25
    550a:	8c 0f       	add	r24, r28
    550c:	9d 1f       	adc	r25, r29
    550e:	88 0f       	add	r24, r24
    5510:	99 1f       	adc	r25, r25
    5512:	8a 5a       	subi	r24, 0xAA	; 170
    5514:	91 4d       	sbci	r25, 0xD1	; 209
    5516:	fc 01       	movw	r30, r24
    5518:	a5 91       	lpm	r26, Z+
    551a:	b4 91       	lpm	r27, Z+
		break;
	case MB_Recept:
		/*if(TCNT2>=prb(&(BR_Tbl+MB_BitRate_RAM[MB_N])->Time15))
			MB_Err &=(1<<MB_N);*/
		MBRecept(MB_N);
		MB_ClearTimer(MB_N);
    551c:	1c 92       	st	X, r1
	case MB_Trans: case MB_Proc: 
	case MB_NoReply: // MB_NoReply    MB_Recept ..  MB_M_Cycle   MB_Trans
		usart_data(usart);
		break;
	}
}
    551e:	df 91       	pop	r29
    5520:	cf 91       	pop	r28
    5522:	08 95       	ret
		MBRecept(MB_N);
		MB_ClearTimer(MB_N);
		break;
	case MB_Trans: case MB_Proc: 
	case MB_NoReply: // MB_NoReply    MB_Recept ..  MB_M_Cycle   MB_Trans
		usart_data(usart);
    5524:	8c 91       	ld	r24, X
		break;
	}
}
    5526:	df 91       	pop	r29
    5528:	cf 91       	pop	r28
    552a:	08 95       	ret
		MB_StartTimer(MB_N);
		break;
	case MB_Recept:
		/*if(TCNT2>=prb(&(BR_Tbl+MB_BitRate_RAM[MB_N])->Time15))
			MB_Err &=(1<<MB_N);*/
		MBRecept(MB_N);
    552c:	83 2f       	mov	r24, r19
    552e:	0e 94 8b 29 	call	0x5316	; 0x5316 <MBRecept>
    5532:	e8 cf       	rjmp	.-48     	; 0x5504 <Modbus_RX+0x6e>
// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_RX(usart_t *usart)
{
	uint8_t MB_N = MB_Port_N(usart);
	switch (MB_State[MB_N]) {
    5534:	81 30       	cpi	r24, 0x01	; 1
    5536:	d9 f6       	brne	.-74     	; 0x54ee <Modbus_RX+0x58>
	case MB_Initi:
		MB_Frame[MB_N][0] = usart_data(usart);
		MB_ClearTimer(MB_N);
		break;
	case MB_Idle: 
		MB_State[MB_N] = MB_Recept;
    5538:	82 e0       	ldi	r24, 0x02	; 2
    553a:	80 83       	st	Z, r24
		MB_Err &=~(1<<MB_N);
    553c:	81 e0       	ldi	r24, 0x01	; 1
    553e:	90 e0       	ldi	r25, 0x00	; 0
    5540:	0c 2e       	mov	r0, r28
    5542:	02 c0       	rjmp	.+4      	; 0x5548 <Modbus_RX+0xb2>
    5544:	88 0f       	add	r24, r24
    5546:	99 1f       	adc	r25, r25
    5548:	0a 94       	dec	r0
    554a:	e2 f7       	brpl	.-8      	; 0x5544 <Modbus_RX+0xae>
    554c:	80 95       	com	r24
    554e:	20 91 d7 04 	lds	r18, 0x04D7
    5552:	28 23       	and	r18, r24
    5554:	20 93 d7 04 	sts	0x04D7, r18
		MB_Frame_Sz[MB_N] = 0;
    5558:	fe 01       	movw	r30, r28
    555a:	eb 5f       	subi	r30, 0xFB	; 251
    555c:	f8 4f       	sbci	r31, 0xF8	; 248
    555e:	10 82       	st	Z, r1
		MBRecept(MB_N);
    5560:	83 2f       	mov	r24, r19
    5562:	0e 94 8b 29 	call	0x5316	; 0x5316 <MBRecept>
    5566:	ce 01       	movw	r24, r28
    5568:	88 0f       	add	r24, r24
    556a:	99 1f       	adc	r25, r25
    556c:	8c 0f       	add	r24, r28
    556e:	9d 1f       	adc	r25, r29
    5570:	88 0f       	add	r24, r24
    5572:	99 1f       	adc	r25, r25
    5574:	86 5a       	subi	r24, 0xA6	; 166
    5576:	91 4d       	sbci	r25, 0xD1	; 209
    5578:	fc 01       	movw	r30, r24
    557a:	25 91       	lpm	r18, Z+
    557c:	34 91       	lpm	r19, Z+
		MB_StartTimer(MB_N);
    557e:	f9 01       	movw	r30, r18
    5580:	19 95       	eicall
	case MB_Trans: case MB_Proc: 
	case MB_NoReply: // MB_NoReply    MB_Recept ..  MB_M_Cycle   MB_Trans
		usart_data(usart);
		break;
	}
}
    5582:	df 91       	pop	r29
    5584:	cf 91       	pop	r28
    5586:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~
static uint8_t
MB_Port_N(usart_t *usart)
{
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Port[MB_N].usart_field)!=usart; MB_N++);
    5588:	30 e0       	ldi	r19, 0x00	; 0
    558a:	c0 e0       	ldi	r28, 0x00	; 0
    558c:	d0 e0       	ldi	r29, 0x00	; 0
    558e:	a5 cf       	rjmp	.-182    	; 0x54da <Modbus_RX+0x44>

00005590 <CommErr>:
}

// ~~~~~~~~~~~~~~~~~~
uint8_t
CommErr(uint8_t MB_N)
{
    5590:	0f 93       	push	r16
    5592:	1f 93       	push	r17
    5594:	cf 93       	push	r28
    5596:	df 93       	push	r29
    5598:	38 2f       	mov	r19, r24
	uint8_t Sz = MB_Frame_Sz[MB_N]-2;
    559a:	c8 2f       	mov	r28, r24
    559c:	d0 e0       	ldi	r29, 0x00	; 0
    559e:	fe 01       	movw	r30, r28
    55a0:	eb 5f       	subi	r30, 0xFB	; 251
    55a2:	f8 4f       	sbci	r31, 0xF8	; 248
    55a4:	20 81       	ld	r18, Z
	uint8_t Err = MB_Err &(1<<MB_N) || MB_Frame_Sz[MB_N]<3 || *(uint16_t*)(MB_Frame[MB_N]+Sz)!=CRC(rrb, MB_Frame[MB_N], Sz);
    55a6:	80 91 d7 04 	lds	r24, 0x04D7
    55aa:	90 e0       	ldi	r25, 0x00	; 0
    55ac:	03 2e       	mov	r0, r19
    55ae:	02 c0       	rjmp	.+4      	; 0x55b4 <CommErr+0x24>
    55b0:	95 95       	asr	r25
    55b2:	87 95       	ror	r24
    55b4:	0a 94       	dec	r0
    55b6:	e2 f7       	brpl	.-8      	; 0x55b0 <CommErr+0x20>
    55b8:	80 ff       	sbrs	r24, 0
    55ba:	29 c0       	rjmp	.+82     	; 0x560e <CommErr+0x7e>
	if (Err) {
		MB_CPT[MB_N][1]++;
    55bc:	fe 01       	movw	r30, r28
    55be:	ee 0f       	add	r30, r30
    55c0:	ff 1f       	adc	r31, r31
    55c2:	ee 0f       	add	r30, r30
    55c4:	ff 1f       	adc	r31, r31
    55c6:	ee 0f       	add	r30, r30
    55c8:	ff 1f       	adc	r31, r31
    55ca:	ee 0f       	add	r30, r30
    55cc:	ff 1f       	adc	r31, r31
    55ce:	e0 51       	subi	r30, 0x10	; 16
    55d0:	f7 4f       	sbci	r31, 0xF7	; 247
    55d2:	80 81       	ld	r24, Z
    55d4:	91 81       	ldd	r25, Z+1	; 0x01
    55d6:	01 96       	adiw	r24, 0x01	; 1
    55d8:	91 83       	std	Z+1, r25	; 0x01
    55da:	80 83       	st	Z, r24
    55dc:	ce 01       	movw	r24, r28
    55de:	88 0f       	add	r24, r24
    55e0:	99 1f       	adc	r25, r25
    55e2:	88 0f       	add	r24, r24
    55e4:	99 1f       	adc	r25, r25
    55e6:	9c 01       	movw	r18, r24
    55e8:	22 0f       	add	r18, r18
    55ea:	33 1f       	adc	r19, r19
    55ec:	22 0f       	add	r18, r18
    55ee:	33 1f       	adc	r19, r19
    55f0:	28 0f       	add	r18, r24
    55f2:	39 1f       	adc	r19, r25
    55f4:	2f 5a       	subi	r18, 0xAF	; 175
    55f6:	31 4d       	sbci	r19, 0xD1	; 209
    55f8:	f9 01       	movw	r30, r18
    55fa:	85 91       	lpm	r24, Z+
    55fc:	94 91       	lpm	r25, Z+
		USART_Func(MB_N, LED_Err_On);
    55fe:	fc 01       	movw	r30, r24
    5600:	19 95       	eicall
    5602:	81 e0       	ldi	r24, 0x01	; 1
	else {
		MB_CPT[MB_N][0]++;
		USART_Func(MB_N, LED_Err_Off);
	}
	return Err;
}
    5604:	df 91       	pop	r29
    5606:	cf 91       	pop	r28
    5608:	1f 91       	pop	r17
    560a:	0f 91       	pop	r16
    560c:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~
uint8_t
CommErr(uint8_t MB_N)
{
	uint8_t Sz = MB_Frame_Sz[MB_N]-2;
	uint8_t Err = MB_Err &(1<<MB_N) || MB_Frame_Sz[MB_N]<3 || *(uint16_t*)(MB_Frame[MB_N]+Sz)!=CRC(rrb, MB_Frame[MB_N], Sz);
    560e:	23 30       	cpi	r18, 0x03	; 3
    5610:	a8 f2       	brcs	.-86     	; 0x55bc <CommErr+0x2c>

// ~~~~~~~~~~~~~~~~~~
uint8_t
CommErr(uint8_t MB_N)
{
	uint8_t Sz = MB_Frame_Sz[MB_N]-2;
    5612:	22 50       	subi	r18, 0x02	; 2
	uint8_t Err = MB_Err &(1<<MB_N) || MB_Frame_Sz[MB_N]<3 || *(uint16_t*)(MB_Frame[MB_N]+Sz)!=CRC(rrb, MB_Frame[MB_N], Sz);
    5614:	73 2f       	mov	r23, r19
    5616:	60 e0       	ldi	r22, 0x00	; 0
    5618:	fb 01       	movw	r30, r22
    561a:	e2 0f       	add	r30, r18
    561c:	f1 1d       	adc	r31, r1
    561e:	ed 5d       	subi	r30, 0xDD	; 221
    5620:	f4 4f       	sbci	r31, 0xF4	; 244
    5622:	00 81       	ld	r16, Z
    5624:	11 81       	ldd	r17, Z+1	; 0x01
    5626:	6d 5d       	subi	r22, 0xDD	; 221
    5628:	74 4f       	sbci	r23, 0xF4	; 244
    562a:	30 e0       	ldi	r19, 0x00	; 0
    562c:	40 e0       	ldi	r20, 0x00	; 0
    562e:	50 e0       	ldi	r21, 0x00	; 0
    5630:	8a e7       	ldi	r24, 0x7A	; 122
    5632:	99 e1       	ldi	r25, 0x19	; 25
    5634:	0e 94 ed 19 	call	0x33da	; 0x33da <CRC>
    5638:	08 17       	cp	r16, r24
    563a:	19 07       	cpc	r17, r25
    563c:	09 f0       	breq	.+2      	; 0x5640 <CommErr+0xb0>
    563e:	be cf       	rjmp	.-132    	; 0x55bc <CommErr+0x2c>
	if (Err) {
		MB_CPT[MB_N][1]++;
		USART_Func(MB_N, LED_Err_On);
	}
	else {
		MB_CPT[MB_N][0]++;
    5640:	fe 01       	movw	r30, r28
    5642:	e2 95       	swap	r30
    5644:	f2 95       	swap	r31
    5646:	f0 7f       	andi	r31, 0xF0	; 240
    5648:	fe 27       	eor	r31, r30
    564a:	e0 7f       	andi	r30, 0xF0	; 240
    564c:	fe 27       	eor	r31, r30
    564e:	e2 51       	subi	r30, 0x12	; 18
    5650:	f7 4f       	sbci	r31, 0xF7	; 247
    5652:	80 81       	ld	r24, Z
    5654:	91 81       	ldd	r25, Z+1	; 0x01
    5656:	01 96       	adiw	r24, 0x01	; 1
    5658:	91 83       	std	Z+1, r25	; 0x01
    565a:	80 83       	st	Z, r24
    565c:	ce 01       	movw	r24, r28
    565e:	88 0f       	add	r24, r24
    5660:	99 1f       	adc	r25, r25
    5662:	88 0f       	add	r24, r24
    5664:	99 1f       	adc	r25, r25
    5666:	9c 01       	movw	r18, r24
    5668:	22 0f       	add	r18, r18
    566a:	33 1f       	adc	r19, r19
    566c:	22 0f       	add	r18, r18
    566e:	33 1f       	adc	r19, r19
    5670:	28 0f       	add	r18, r24
    5672:	39 1f       	adc	r19, r25
    5674:	2d 5a       	subi	r18, 0xAD	; 173
    5676:	31 4d       	sbci	r19, 0xD1	; 209
    5678:	f9 01       	movw	r30, r18
    567a:	85 91       	lpm	r24, Z+
    567c:	94 91       	lpm	r25, Z+
		USART_Func(MB_N, LED_Err_Off);
    567e:	fc 01       	movw	r30, r24
    5680:	19 95       	eicall
    5682:	80 e0       	ldi	r24, 0x00	; 0
    5684:	bf cf       	rjmp	.-130    	; 0x5604 <CommErr+0x74>

00005686 <SetCRC_MB>:
}

// ~~~~~~~~~~~~~~~~~~~~
void
SetCRC_MB(uint8_t MB_N)
{
    5686:	df 92       	push	r13
    5688:	ef 92       	push	r14
    568a:	ff 92       	push	r15
    568c:	0f 93       	push	r16
    568e:	1f 93       	push	r17
	uint8_t Sz = MB_Frame_Sz[MB_N]-2;
    5690:	e5 e0       	ldi	r30, 0x05	; 5
    5692:	f7 e0       	ldi	r31, 0x07	; 7
    5694:	e8 0f       	add	r30, r24
    5696:	f1 1d       	adc	r31, r1
    5698:	d0 80       	ld	r13, Z
    569a:	9e ef       	ldi	r25, 0xFE	; 254
    569c:	d9 0e       	add	r13, r25
	*(uint16_t*)(MB_Frame[MB_N]+Sz) = CRC(rrb, MB_Frame[MB_N], Sz);
    569e:	18 2f       	mov	r17, r24
    56a0:	00 e0       	ldi	r16, 0x00	; 0
    56a2:	83 e2       	ldi	r24, 0x23	; 35
    56a4:	e8 2e       	mov	r14, r24
    56a6:	8b e0       	ldi	r24, 0x0B	; 11
    56a8:	f8 2e       	mov	r15, r24
    56aa:	b7 01       	movw	r22, r14
    56ac:	60 0f       	add	r22, r16
    56ae:	71 1f       	adc	r23, r17
    56b0:	2d 2d       	mov	r18, r13
    56b2:	30 e0       	ldi	r19, 0x00	; 0
    56b4:	40 e0       	ldi	r20, 0x00	; 0
    56b6:	50 e0       	ldi	r21, 0x00	; 0
    56b8:	8a e7       	ldi	r24, 0x7A	; 122
    56ba:	99 e1       	ldi	r25, 0x19	; 25
    56bc:	0e 94 ed 19 	call	0x33da	; 0x33da <CRC>
    56c0:	0d 0d       	add	r16, r13
    56c2:	11 1d       	adc	r17, r1
    56c4:	e0 0e       	add	r14, r16
    56c6:	f1 1e       	adc	r15, r17
    56c8:	f7 01       	movw	r30, r14
    56ca:	91 83       	std	Z+1, r25	; 0x01
    56cc:	80 83       	st	Z, r24
}
    56ce:	1f 91       	pop	r17
    56d0:	0f 91       	pop	r16
    56d2:	ff 90       	pop	r15
    56d4:	ef 90       	pop	r14
    56d6:	df 90       	pop	r13
    56d8:	08 95       	ret

000056da <MB_FrameReg>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
MB_FrameReg(uint8_t MB_N, uint8_t i)
{
	return MB_Frame[MB_N][i]<<8 | MB_Frame[MB_N][i+1];
    56da:	70 e0       	ldi	r23, 0x00	; 0
    56dc:	a3 e2       	ldi	r26, 0x23	; 35
    56de:	bb e0       	ldi	r27, 0x0B	; 11
    56e0:	f8 2f       	mov	r31, r24
    56e2:	e0 e0       	ldi	r30, 0x00	; 0
    56e4:	ea 0f       	add	r30, r26
    56e6:	fb 1f       	adc	r31, r27
    56e8:	e6 0f       	add	r30, r22
    56ea:	f7 1f       	adc	r31, r23
    56ec:	41 81       	ldd	r20, Z+1	; 0x01
    56ee:	50 e0       	ldi	r21, 0x00	; 0
    56f0:	38 2f       	mov	r19, r24
    56f2:	20 e0       	ldi	r18, 0x00	; 0
    56f4:	26 0f       	add	r18, r22
    56f6:	37 1f       	adc	r19, r23
    56f8:	a2 0f       	add	r26, r18
    56fa:	b3 1f       	adc	r27, r19
    56fc:	9c 91       	ld	r25, X
    56fe:	80 e0       	ldi	r24, 0x00	; 0
    5700:	48 2b       	or	r20, r24
    5702:	59 2b       	or	r21, r25
}
    5704:	ca 01       	movw	r24, r20
    5706:	08 95       	ret

00005708 <MB_CPT_Clear>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~
void
MB_CPT_Clear(uint8_t MB_N)
{
    5708:	90 e0       	ldi	r25, 0x00	; 0
    570a:	20 e0       	ldi	r18, 0x00	; 0
    570c:	30 e0       	ldi	r19, 0x00	; 0
    570e:	88 0f       	add	r24, r24
    5710:	99 1f       	adc	r25, r25
    5712:	88 0f       	add	r24, r24
    5714:	99 1f       	adc	r25, r25
    5716:	88 0f       	add	r24, r24
    5718:	99 1f       	adc	r25, r25
	for (uint8_t i=0; i<8; MB_CPT[MB_N][i++]=0);
    571a:	fc 01       	movw	r30, r24
    571c:	e2 0f       	add	r30, r18
    571e:	f3 1f       	adc	r31, r19
    5720:	ee 0f       	add	r30, r30
    5722:	ff 1f       	adc	r31, r31
    5724:	e2 51       	subi	r30, 0x12	; 18
    5726:	f7 4f       	sbci	r31, 0xF7	; 247
    5728:	11 82       	std	Z+1, r1	; 0x01
    572a:	10 82       	st	Z, r1
    572c:	2f 5f       	subi	r18, 0xFF	; 255
    572e:	3f 4f       	sbci	r19, 0xFF	; 255
    5730:	28 30       	cpi	r18, 0x08	; 8
    5732:	31 05       	cpc	r19, r1
    5734:	91 f7       	brne	.-28     	; 0x571a <MB_CPT_Clear+0x12>
}
    5736:	08 95       	ret

00005738 <MB_S_Timer_ISR>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_S_Timer_ISR(uint8_t MB_N)
{
    5738:	2f 92       	push	r2
    573a:	3f 92       	push	r3
    573c:	4f 92       	push	r4
    573e:	5f 92       	push	r5
    5740:	6f 92       	push	r6
    5742:	7f 92       	push	r7
    5744:	8f 92       	push	r8
    5746:	9f 92       	push	r9
    5748:	af 92       	push	r10
    574a:	bf 92       	push	r11
    574c:	cf 92       	push	r12
    574e:	df 92       	push	r13
    5750:	ef 92       	push	r14
    5752:	ff 92       	push	r15
    5754:	0f 93       	push	r16
    5756:	1f 93       	push	r17
    5758:	df 93       	push	r29
    575a:	cf 93       	push	r28
    575c:	cd b7       	in	r28, 0x3d	; 61
    575e:	de b7       	in	r29, 0x3e	; 62
    5760:	29 97       	sbiw	r28, 0x09	; 9
    5762:	0f b6       	in	r0, 0x3f	; 63
    5764:	f8 94       	cli
    5766:	de bf       	out	0x3e, r29	; 62
    5768:	0f be       	out	0x3f, r0	; 63
    576a:	cd bf       	out	0x3d, r28	; 61
    576c:	d8 2e       	mov	r13, r24
	switch (MB_State[MB_N]) {
    576e:	28 2f       	mov	r18, r24
    5770:	30 e0       	ldi	r19, 0x00	; 0
    5772:	39 87       	std	Y+9, r19	; 0x09
    5774:	28 87       	std	Y+8, r18	; 0x08
    5776:	89 01       	movw	r16, r18
    5778:	00 54       	subi	r16, 0x40	; 64
    577a:	1a 4f       	sbci	r17, 0xFA	; 250
    577c:	d8 01       	movw	r26, r16
    577e:	8c 91       	ld	r24, X
    5780:	88 23       	and	r24, r24
    5782:	b9 f1       	breq	.+110    	; 0x57f2 <MB_S_Timer_ISR+0xba>
    5784:	82 30       	cpi	r24, 0x02	; 2
    5786:	c9 f0       	breq	.+50     	; 0x57ba <MB_S_Timer_ISR+0x82>
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
		MB_S_CtrlProc(MB_N);
		break;
	}
}
    5788:	29 96       	adiw	r28, 0x09	; 9
    578a:	0f b6       	in	r0, 0x3f	; 63
    578c:	f8 94       	cli
    578e:	de bf       	out	0x3e, r29	; 62
    5790:	0f be       	out	0x3f, r0	; 63
    5792:	cd bf       	out	0x3d, r28	; 61
    5794:	cf 91       	pop	r28
    5796:	df 91       	pop	r29
    5798:	1f 91       	pop	r17
    579a:	0f 91       	pop	r16
    579c:	ff 90       	pop	r15
    579e:	ef 90       	pop	r14
    57a0:	df 90       	pop	r13
    57a2:	cf 90       	pop	r12
    57a4:	bf 90       	pop	r11
    57a6:	af 90       	pop	r10
    57a8:	9f 90       	pop	r9
    57aa:	8f 90       	pop	r8
    57ac:	7f 90       	pop	r7
    57ae:	6f 90       	pop	r6
    57b0:	5f 90       	pop	r5
    57b2:	4f 90       	pop	r4
    57b4:	3f 90       	pop	r3
    57b6:	2f 90       	pop	r2
    57b8:	08 95       	ret
	switch (MB_State[MB_N]) {
	case MB_Initi:
		MB_State[MB_N] = MB_Idle;
		break;
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
    57ba:	84 e0       	ldi	r24, 0x04	; 4
    57bc:	d8 01       	movw	r26, r16
    57be:	8c 93       	st	X, r24

// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
MB_S_CtrlProc(uint8_t MB_N)
{
	if (CommErr(MB_N)) {
    57c0:	8d 2d       	mov	r24, r13
    57c2:	0e 94 c8 2a 	call	0x5590	; 0x5590 <CommErr>
    57c6:	88 23       	and	r24, r24
    57c8:	a1 f4       	brne	.+40     	; 0x57f2 <MB_S_Timer_ISR+0xba>
		MB_State[MB_N] = MB_Idle;
		return;
	}
	if (MB_Frame[MB_N][0]!=0 && MB_Frame[MB_N][0]!=MB_NativeAddr[MB_N]) {
    57ca:	28 85       	ldd	r18, Y+8	; 0x08
    57cc:	39 85       	ldd	r19, Y+9	; 0x09
    57ce:	f2 2e       	mov	r15, r18
    57d0:	ee 24       	eor	r14, r14
    57d2:	f7 01       	movw	r30, r14
    57d4:	ed 5d       	subi	r30, 0xDD	; 221
    57d6:	f4 4f       	sbci	r31, 0xF4	; 244
    57d8:	90 81       	ld	r25, Z
    57da:	99 23       	and	r25, r25
    57dc:	71 f0       	breq	.+28     	; 0x57fa <MB_S_Timer_ISR+0xc2>
    57de:	f9 01       	movw	r30, r18
    57e0:	e2 52       	subi	r30, 0x22	; 34
    57e2:	fa 4f       	sbci	r31, 0xFA	; 250
    57e4:	80 81       	ld	r24, Z
    57e6:	98 17       	cp	r25, r24
    57e8:	41 f0       	breq	.+16     	; 0x57fa <MB_S_Timer_ISR+0xc2>
		MB_State[MB_N] = MB_Idle;
    57ea:	81 e0       	ldi	r24, 0x01	; 1
    57ec:	d8 01       	movw	r26, r16
    57ee:	8c 93       	st	X, r24
    57f0:	cb cf       	rjmp	.-106    	; 0x5788 <MB_S_Timer_ISR+0x50>
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
MB_S_CtrlProc(uint8_t MB_N)
{
	if (CommErr(MB_N)) {
		MB_State[MB_N] = MB_Idle;
    57f2:	81 e0       	ldi	r24, 0x01	; 1
    57f4:	f8 01       	movw	r30, r16
    57f6:	80 83       	st	Z, r24
    57f8:	c7 cf       	rjmp	.-114    	; 0x5788 <MB_S_Timer_ISR+0x50>
    57fa:	28 84       	ldd	r2, Y+8	; 0x08
    57fc:	39 84       	ldd	r3, Y+9	; 0x09
    57fe:	22 0c       	add	r2, r2
    5800:	33 1c       	adc	r3, r3
    5802:	22 0c       	add	r2, r2
    5804:	33 1c       	adc	r3, r3
    5806:	51 01       	movw	r10, r2
    5808:	aa 0c       	add	r10, r10
    580a:	bb 1c       	adc	r11, r11
    580c:	aa 0c       	add	r10, r10
    580e:	bb 1c       	adc	r11, r11
    5810:	a2 0c       	add	r10, r2
    5812:	b3 1c       	adc	r11, r3
    5814:	ef e4       	ldi	r30, 0x4F	; 79
    5816:	fe e2       	ldi	r31, 0x2E	; 46
    5818:	ae 0e       	add	r10, r30
    581a:	bf 1e       	adc	r11, r31
    581c:	f5 01       	movw	r30, r10
    581e:	25 91       	lpm	r18, Z+
    5820:	34 91       	lpm	r19, Z+
	}
	if (MB_Frame[MB_N][0]!=0 && MB_Frame[MB_N][0]!=MB_NativeAddr[MB_N]) {
		MB_State[MB_N] = MB_Idle;
		return;
	}
	USART_Func(MB_N, LED);
    5822:	f9 01       	movw	r30, r18
    5824:	19 95       	eicall
	MB_CPT[MB_N][3]++;
    5826:	68 84       	ldd	r6, Y+8	; 0x08
    5828:	79 84       	ldd	r7, Y+9	; 0x09
    582a:	62 94       	swap	r6
    582c:	72 94       	swap	r7
    582e:	b0 ef       	ldi	r27, 0xF0	; 240
    5830:	7b 22       	and	r7, r27
    5832:	76 24       	eor	r7, r6
    5834:	6b 22       	and	r6, r27
    5836:	76 24       	eor	r7, r6
    5838:	f3 01       	movw	r30, r6
    583a:	e2 51       	subi	r30, 0x12	; 18
    583c:	f7 4f       	sbci	r31, 0xF7	; 247
    583e:	86 81       	ldd	r24, Z+6	; 0x06
    5840:	97 81       	ldd	r25, Z+7	; 0x07
    5842:	01 96       	adiw	r24, 0x01	; 1
    5844:	97 83       	std	Z+7, r25	; 0x07
    5846:	86 83       	std	Z+6, r24	; 0x06

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
MB_FrameReg(uint8_t MB_N, uint8_t i)
{
	return MB_Frame[MB_N][i]<<8 | MB_Frame[MB_N][i+1];
    5848:	68 85       	ldd	r22, Y+8	; 0x08
    584a:	79 85       	ldd	r23, Y+9	; 0x09
    584c:	76 95       	lsr	r23
    584e:	76 2f       	mov	r23, r22
    5850:	66 27       	eor	r22, r22
    5852:	77 95       	ror	r23
    5854:	67 95       	ror	r22
    5856:	db 01       	movw	r26, r22
    5858:	aa 0f       	add	r26, r26
    585a:	bb 1f       	adc	r27, r27
    585c:	ab 5d       	subi	r26, 0xDB	; 219
    585e:	b4 4f       	sbci	r27, 0xF4	; 244
    5860:	9c 91       	ld	r25, X
    5862:	80 e0       	ldi	r24, 0x00	; 0
    5864:	a7 01       	movw	r20, r14
    5866:	4d 5d       	subi	r20, 0xDD	; 221
    5868:	54 4f       	sbci	r21, 0xF4	; 244
    586a:	fa 01       	movw	r30, r20
    586c:	23 81       	ldd	r18, Z+3	; 0x03
    586e:	82 2e       	mov	r8, r18
    5870:	99 24       	eor	r9, r9
    5872:	88 2a       	or	r8, r24
    5874:	99 2a       	or	r9, r25
inline static uint8_t
Process(uint8_t MB_N)
{
	uint8_t Err;
	uint16_t StartAddr = MB_FrameReg(MB_N, 2);
	switch (MB_Frame[MB_N][1]) {
    5876:	31 81       	ldd	r19, Z+1	; 0x01
    5878:	35 30       	cpi	r19, 0x05	; 5
    587a:	08 f0       	brcs	.+2      	; 0x587e <MB_S_Timer_ISR+0x146>
    587c:	52 c0       	rjmp	.+164    	; 0x5922 <MB_S_Timer_ISR+0x1ea>
    587e:	33 30       	cpi	r19, 0x03	; 3
    5880:	08 f4       	brcc	.+2      	; 0x5884 <MB_S_Timer_ISR+0x14c>
    5882:	72 c0       	rjmp	.+228    	; 0x5968 <MB_S_Timer_ISR+0x230>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_ReadReg(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame[MB_N][0]==0)
    5884:	fa 01       	movw	r30, r20
    5886:	80 81       	ld	r24, Z
    5888:	88 23       	and	r24, r24
    588a:	09 f4       	brne	.+2      	; 0x588e <MB_S_Timer_ISR+0x156>
    588c:	5c c0       	rjmp	.+184    	; 0x5946 <MB_S_Timer_ISR+0x20e>
		return 0xFF;
	if (MB_Frame_Sz[MB_N]!=8)
    588e:	25 e0       	ldi	r18, 0x05	; 5
    5890:	42 2e       	mov	r4, r18
    5892:	27 e0       	ldi	r18, 0x07	; 7
    5894:	52 2e       	mov	r5, r18
    5896:	88 85       	ldd	r24, Y+8	; 0x08
    5898:	99 85       	ldd	r25, Y+9	; 0x09
    589a:	48 0e       	add	r4, r24
    589c:	59 1e       	adc	r5, r25
    589e:	f2 01       	movw	r30, r4
    58a0:	80 81       	ld	r24, Z
    58a2:	88 30       	cpi	r24, 0x08	; 8
    58a4:	09 f4       	brne	.+2      	; 0x58a8 <MB_S_Timer_ISR+0x170>
    58a6:	27 c2       	rjmp	.+1102   	; 0x5cf6 <MB_S_Timer_ISR+0x5be>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_PresetSingle(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame_Sz[MB_N]!=8)
		return MB_Frame[MB_N][2]=IllegData;
    58a8:	83 e0       	ldi	r24, 0x03	; 3
    58aa:	8c 93       	st	X, r24
    58ac:	93 e0       	ldi	r25, 0x03	; 3
		break;
	default:
		Err = MB_Frame[MB_N][2] = IllegFunc;
		break;
	}
	if (MB_Frame[MB_N][0]) {
    58ae:	f7 01       	movw	r30, r14
    58b0:	ed 5d       	subi	r30, 0xDD	; 221
    58b2:	f4 4f       	sbci	r31, 0xF4	; 244
    58b4:	80 81       	ld	r24, Z
    58b6:	88 23       	and	r24, r24
    58b8:	81 f0       	breq	.+32     	; 0x58da <MB_S_Timer_ISR+0x1a2>
		if (Err) {
    58ba:	99 23       	and	r25, r25
    58bc:	49 f0       	breq	.+18     	; 0x58d0 <MB_S_Timer_ISR+0x198>
			MB_Frame[MB_N][1] |=(1<<7);
    58be:	81 81       	ldd	r24, Z+1	; 0x01
    58c0:	80 68       	ori	r24, 0x80	; 128
    58c2:	81 83       	std	Z+1, r24	; 0x01
			MB_Frame_Sz[MB_N] = 5;
    58c4:	e8 85       	ldd	r30, Y+8	; 0x08
    58c6:	f9 85       	ldd	r31, Y+9	; 0x09
    58c8:	eb 5f       	subi	r30, 0xFB	; 251
    58ca:	f8 4f       	sbci	r31, 0xF8	; 248
    58cc:	85 e0       	ldi	r24, 0x05	; 5
    58ce:	80 83       	st	Z, r24
		}
		SetCRC_MB(MB_N);
    58d0:	8d 2d       	mov	r24, r13
    58d2:	9d 83       	std	Y+5, r25	; 0x05
    58d4:	0e 94 43 2b 	call	0x5686	; 0x5686 <SetCRC_MB>
    58d8:	9d 81       	ldd	r25, Y+5	; 0x05
		MB_State[MB_N] = MB_Idle;
		return;
	}
	USART_Func(MB_N, LED);
	MB_CPT[MB_N][3]++;
	if (Process(MB_N))
    58da:	99 23       	and	r25, r25
    58dc:	a1 f5       	brne	.+104    	; 0x5946 <MB_S_Timer_ISR+0x20e>
		MB_CPT[MB_N][2]++;
	if (MB_Frame[MB_N][0])
    58de:	23 e2       	ldi	r18, 0x23	; 35
    58e0:	3b e0       	ldi	r19, 0x0B	; 11
    58e2:	e2 0e       	add	r14, r18
    58e4:	f3 1e       	adc	r15, r19
    58e6:	d7 01       	movw	r26, r14
    58e8:	8c 91       	ld	r24, X
    58ea:	88 23       	and	r24, r24
    58ec:	c9 f5       	brne	.+114    	; 0x5960 <MB_S_Timer_ISR+0x228>
		MB_Transm(MB_N);
	else {
		MB_CPT[MB_N][4]++;
    58ee:	e8 85       	ldd	r30, Y+8	; 0x08
    58f0:	f9 85       	ldd	r31, Y+9	; 0x09
    58f2:	ee 0f       	add	r30, r30
    58f4:	ff 1f       	adc	r31, r31
    58f6:	ee 0f       	add	r30, r30
    58f8:	ff 1f       	adc	r31, r31
    58fa:	ee 0f       	add	r30, r30
    58fc:	ff 1f       	adc	r31, r31
    58fe:	ee 0f       	add	r30, r30
    5900:	ff 1f       	adc	r31, r31
    5902:	ea 50       	subi	r30, 0x0A	; 10
    5904:	f7 4f       	sbci	r31, 0xF7	; 247
    5906:	80 81       	ld	r24, Z
    5908:	91 81       	ldd	r25, Z+1	; 0x01
    590a:	01 96       	adiw	r24, 0x01	; 1
    590c:	91 83       	std	Z+1, r25	; 0x01
    590e:	80 83       	st	Z, r24
		MB_State[MB_N] = MB_Idle;
    5910:	81 e0       	ldi	r24, 0x01	; 1
    5912:	f8 01       	movw	r30, r16
    5914:	80 83       	st	Z, r24
    5916:	f5 01       	movw	r30, r10
    5918:	85 91       	lpm	r24, Z+
    591a:	94 91       	lpm	r25, Z+
		USART_Func(MB_N, LED);
    591c:	fc 01       	movw	r30, r24
    591e:	19 95       	eicall
    5920:	33 cf       	rjmp	.-410    	; 0x5788 <MB_S_Timer_ISR+0x50>
inline static uint8_t
Process(uint8_t MB_N)
{
	uint8_t Err;
	uint16_t StartAddr = MB_FrameReg(MB_N, 2);
	switch (MB_Frame[MB_N][1]) {
    5922:	3f 30       	cpi	r19, 0x0F	; 15
    5924:	09 f4       	brne	.+2      	; 0x5928 <MB_S_Timer_ISR+0x1f0>
    5926:	1e c1       	rjmp	.+572    	; 0x5b64 <MB_S_Timer_ISR+0x42c>
    5928:	30 31       	cpi	r19, 0x10	; 16
    592a:	09 f4       	brne	.+2      	; 0x592e <MB_S_Timer_ISR+0x1f6>
    592c:	fc c0       	rjmp	.+504    	; 0x5b26 <MB_S_Timer_ISR+0x3ee>
    592e:	36 30       	cpi	r19, 0x06	; 6
    5930:	09 f4       	brne	.+2      	; 0x5934 <MB_S_Timer_ISR+0x1fc>
    5932:	bd c0       	rjmp	.+378    	; 0x5aae <MB_S_Timer_ISR+0x376>
		break;
	case 0x10:
		Err = MB_S_Preset(MB_N, StartAddr);
		break;
	default:
		Err = MB_Frame[MB_N][2] = IllegFunc;
    5934:	66 0f       	add	r22, r22
    5936:	77 1f       	adc	r23, r23
    5938:	6b 5d       	subi	r22, 0xDB	; 219
    593a:	74 4f       	sbci	r23, 0xF4	; 244
    593c:	81 e0       	ldi	r24, 0x01	; 1
    593e:	fb 01       	movw	r30, r22
    5940:	80 83       	st	Z, r24
    5942:	91 e0       	ldi	r25, 0x01	; 1
    5944:	b4 cf       	rjmp	.-152    	; 0x58ae <MB_S_Timer_ISR+0x176>
		return;
	}
	USART_Func(MB_N, LED);
	MB_CPT[MB_N][3]++;
	if (Process(MB_N))
		MB_CPT[MB_N][2]++;
    5946:	f1 01       	movw	r30, r2
    5948:	ee 0f       	add	r30, r30
    594a:	ff 1f       	adc	r31, r31
    594c:	ee 0f       	add	r30, r30
    594e:	ff 1f       	adc	r31, r31
    5950:	ee 50       	subi	r30, 0x0E	; 14
    5952:	f7 4f       	sbci	r31, 0xF7	; 247
    5954:	80 81       	ld	r24, Z
    5956:	91 81       	ldd	r25, Z+1	; 0x01
    5958:	01 96       	adiw	r24, 0x01	; 1
    595a:	91 83       	std	Z+1, r25	; 0x01
    595c:	80 83       	st	Z, r24
    595e:	bf cf       	rjmp	.-130    	; 0x58de <MB_S_Timer_ISR+0x1a6>
	if (MB_Frame[MB_N][0])
		MB_Transm(MB_N);
    5960:	8d 2d       	mov	r24, r13
    5962:	0e 94 e4 29 	call	0x53c8	; 0x53c8 <MB_Transm>
    5966:	10 cf       	rjmp	.-480    	; 0x5788 <MB_S_Timer_ISR+0x50>
inline static uint8_t
Process(uint8_t MB_N)
{
	uint8_t Err;
	uint16_t StartAddr = MB_FrameReg(MB_N, 2);
	switch (MB_Frame[MB_N][1]) {
    5968:	31 30       	cpi	r19, 0x01	; 1
    596a:	20 f3       	brcs	.-56     	; 0x5934 <MB_S_Timer_ISR+0x1fc>
*/
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_ReadDiscr(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame[MB_N][0]==0)
    596c:	fa 01       	movw	r30, r20
    596e:	80 81       	ld	r24, Z
    5970:	88 23       	and	r24, r24
    5972:	49 f3       	breq	.-46     	; 0x5946 <MB_S_Timer_ISR+0x20e>
		return 0xFF;
	if (MB_Frame_Sz[MB_N]!=8)
    5974:	e5 e0       	ldi	r30, 0x05	; 5
    5976:	4e 2e       	mov	r4, r30
    5978:	e7 e0       	ldi	r30, 0x07	; 7
    597a:	5e 2e       	mov	r5, r30
    597c:	88 85       	ldd	r24, Y+8	; 0x08
    597e:	99 85       	ldd	r25, Y+9	; 0x09
    5980:	48 0e       	add	r4, r24
    5982:	59 1e       	adc	r5, r25
    5984:	f2 01       	movw	r30, r4
    5986:	80 81       	ld	r24, Z
    5988:	88 30       	cpi	r24, 0x08	; 8
    598a:	09 f0       	breq	.+2      	; 0x598e <MB_S_Timer_ISR+0x256>
    598c:	8d cf       	rjmp	.-230    	; 0x58a8 <MB_S_Timer_ISR+0x170>
    598e:	88 85       	ldd	r24, Y+8	; 0x08
    5990:	99 85       	ldd	r25, Y+9	; 0x09
    5992:	f8 2f       	mov	r31, r24
    5994:	ee 27       	eor	r30, r30
    5996:	e9 5d       	subi	r30, 0xD9	; 217
    5998:	f4 4f       	sbci	r31, 0xF4	; 244
    599a:	90 81       	ld	r25, Z
    599c:	80 e0       	ldi	r24, 0x00	; 0
    599e:	da 01       	movw	r26, r20
    59a0:	15 96       	adiw	r26, 0x05	; 5
    59a2:	2c 91       	ld	r18, X
    59a4:	a2 2f       	mov	r26, r18
    59a6:	b0 e0       	ldi	r27, 0x00	; 0
    59a8:	a8 2b       	or	r26, r24
    59aa:	b9 2b       	or	r27, r25
		return MB_Frame[MB_N][2]=IllegData;
	uint16_t Qt = MB_FrameReg(MB_N, 4);
	if (StartAddr+Qt>(MB_Frame[MB_N][1]==1?prw(&Modbus_Map[MB_N].Coil_Qt):prw(&Modbus_Map[MB_N].Input_Qt)))
    59ac:	31 30       	cpi	r19, 0x01	; 1
    59ae:	09 f4       	brne	.+2      	; 0x59b2 <MB_S_Timer_ISR+0x27a>
    59b0:	44 c2       	rjmp	.+1160   	; 0x5e3a <MB_S_Timer_ISR+0x702>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    59b2:	f3 01       	movw	r30, r6
    59b4:	ea 5c       	subi	r30, 0xCA	; 202
    59b6:	fc 4f       	sbci	r31, 0xFC	; 252
    59b8:	45 91       	lpm	r20, Z+
    59ba:	54 91       	lpm	r21, Z+
    59bc:	cd 01       	movw	r24, r26
    59be:	88 0d       	add	r24, r8
    59c0:	99 1d       	adc	r25, r9
    59c2:	48 17       	cp	r20, r24
    59c4:	59 07       	cpc	r21, r25
    59c6:	08 f4       	brcc	.+2      	; 0x59ca <MB_S_Timer_ISR+0x292>
    59c8:	8d c1       	rjmp	.+794    	; 0x5ce4 <MB_S_Timer_ISR+0x5ac>
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
    59ca:	31 30       	cpi	r19, 0x01	; 1
    59cc:	09 f4       	brne	.+2      	; 0x59d0 <MB_S_Timer_ISR+0x298>
    59ce:	4a c2       	rjmp	.+1172   	; 0x5e64 <MB_S_Timer_ISR+0x72c>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    59d0:	f1 01       	movw	r30, r2
    59d2:	ee 0f       	add	r30, r30
    59d4:	ff 1f       	adc	r31, r31
    59d6:	ee 0f       	add	r30, r30
    59d8:	ff 1f       	adc	r31, r31
    59da:	ec 5c       	subi	r30, 0xCC	; 204
    59dc:	fc 4f       	sbci	r31, 0xFC	; 252
    59de:	85 91       	lpm	r24, Z+
    59e0:	94 91       	lpm	r25, Z+
    59e2:	28 2f       	mov	r18, r24
    59e4:	89 2f       	mov	r24, r25
    59e6:	62 2e       	mov	r6, r18
    59e8:	78 2e       	mov	r7, r24
	MB_Frame[MB_N][2] = Qt/8+(Qt%8>0);
    59ea:	20 e0       	ldi	r18, 0x00	; 0
    59ec:	cd 01       	movw	r24, r26
    59ee:	87 70       	andi	r24, 0x07	; 7
    59f0:	90 70       	andi	r25, 0x00	; 0
    59f2:	89 2b       	or	r24, r25
    59f4:	09 f0       	breq	.+2      	; 0x59f8 <MB_S_Timer_ISR+0x2c0>
    59f6:	21 e0       	ldi	r18, 0x01	; 1
    59f8:	cd 01       	movw	r24, r26
    59fa:	96 95       	lsr	r25
    59fc:	87 95       	ror	r24
    59fe:	96 95       	lsr	r25
    5a00:	87 95       	ror	r24
    5a02:	96 95       	lsr	r25
    5a04:	87 95       	ror	r24
    5a06:	82 0f       	add	r24, r18
    5a08:	66 0f       	add	r22, r22
    5a0a:	77 1f       	adc	r23, r23
    5a0c:	6b 5d       	subi	r22, 0xDB	; 219
    5a0e:	74 4f       	sbci	r23, 0xF4	; 244
    5a10:	fb 01       	movw	r30, r22
    5a12:	80 83       	st	Z, r24
	MB_Frame_Sz[MB_N] = MB_Frame[MB_N][2]+5;
    5a14:	8b 5f       	subi	r24, 0xFB	; 251
    5a16:	f2 01       	movw	r30, r4
    5a18:	80 83       	st	Z, r24
	for (uint8_t i=0; i<Qt; i++) {
    5a1a:	10 97       	sbiw	r26, 0x00	; 0
    5a1c:	09 f4       	brne	.+2      	; 0x5a20 <MB_S_Timer_ISR+0x2e8>
    5a1e:	22 c1       	rjmp	.+580    	; 0x5c64 <MB_S_Timer_ISR+0x52c>
    5a20:	60 e0       	ldi	r22, 0x00	; 0
    5a22:	20 e0       	ldi	r18, 0x00	; 0
    5a24:	30 e0       	ldi	r19, 0x00	; 0
    5a26:	80 e0       	ldi	r24, 0x00	; 0
    5a28:	90 e0       	ldi	r25, 0x00	; 0
		uint16_t j = StartAddr+i;
		uint8_t Byte=3+i/8, Bit=1<<i%8;
    5a2a:	e1 e0       	ldi	r30, 0x01	; 1
    5a2c:	4e 2e       	mov	r4, r30
    5a2e:	51 2c       	mov	r5, r1
    5a30:	10 c0       	rjmp	.+32     	; 0x5a52 <MB_S_Timer_ISR+0x31a>
		if (Discr[j/8] &(1<<j%8))
			MB_Frame[MB_N][Byte] |=Bit;
    5a32:	f7 01       	movw	r30, r14
    5a34:	e4 0f       	add	r30, r20
    5a36:	f1 1d       	adc	r31, r1
    5a38:	ed 5d       	subi	r30, 0xDD	; 221
    5a3a:	f4 4f       	sbci	r31, 0xF4	; 244
    5a3c:	80 81       	ld	r24, Z
    5a3e:	85 2b       	or	r24, r21
    5a40:	80 83       	st	Z, r24
	if (StartAddr+Qt>(MB_Frame[MB_N][1]==1?prw(&Modbus_Map[MB_N].Coil_Qt):prw(&Modbus_Map[MB_N].Input_Qt)))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
	MB_Frame[MB_N][2] = Qt/8+(Qt%8>0);
	MB_Frame_Sz[MB_N] = MB_Frame[MB_N][2]+5;
	for (uint8_t i=0; i<Qt; i++) {
    5a42:	6f 5f       	subi	r22, 0xFF	; 255
    5a44:	86 2f       	mov	r24, r22
    5a46:	90 e0       	ldi	r25, 0x00	; 0
    5a48:	9c 01       	movw	r18, r24
    5a4a:	8a 17       	cp	r24, r26
    5a4c:	9b 07       	cpc	r25, r27
    5a4e:	08 f0       	brcs	.+2      	; 0x5a52 <MB_S_Timer_ISR+0x31a>
    5a50:	09 c1       	rjmp	.+530    	; 0x5c64 <MB_S_Timer_ISR+0x52c>
		uint16_t j = StartAddr+i;
    5a52:	28 0d       	add	r18, r8
    5a54:	39 1d       	adc	r19, r9
		uint8_t Byte=3+i/8, Bit=1<<i%8;
    5a56:	46 2f       	mov	r20, r22
    5a58:	46 95       	lsr	r20
    5a5a:	46 95       	lsr	r20
    5a5c:	46 95       	lsr	r20
    5a5e:	4d 5f       	subi	r20, 0xFD	; 253
    5a60:	87 70       	andi	r24, 0x07	; 7
    5a62:	90 70       	andi	r25, 0x00	; 0
    5a64:	f2 01       	movw	r30, r4
    5a66:	02 c0       	rjmp	.+4      	; 0x5a6c <MB_S_Timer_ISR+0x334>
    5a68:	ee 0f       	add	r30, r30
    5a6a:	ff 1f       	adc	r31, r31
    5a6c:	8a 95       	dec	r24
    5a6e:	e2 f7       	brpl	.-8      	; 0x5a68 <MB_S_Timer_ISR+0x330>
    5a70:	5e 2f       	mov	r21, r30
		if (Discr[j/8] &(1<<j%8))
    5a72:	f9 01       	movw	r30, r18
    5a74:	f6 95       	lsr	r31
    5a76:	e7 95       	ror	r30
    5a78:	f6 95       	lsr	r31
    5a7a:	e7 95       	ror	r30
    5a7c:	f6 95       	lsr	r31
    5a7e:	e7 95       	ror	r30
    5a80:	e6 0d       	add	r30, r6
    5a82:	f7 1d       	adc	r31, r7
    5a84:	80 81       	ld	r24, Z
    5a86:	90 e0       	ldi	r25, 0x00	; 0
    5a88:	27 70       	andi	r18, 0x07	; 7
    5a8a:	30 70       	andi	r19, 0x00	; 0
    5a8c:	02 c0       	rjmp	.+4      	; 0x5a92 <MB_S_Timer_ISR+0x35a>
    5a8e:	95 95       	asr	r25
    5a90:	87 95       	ror	r24
    5a92:	2a 95       	dec	r18
    5a94:	e2 f7       	brpl	.-8      	; 0x5a8e <MB_S_Timer_ISR+0x356>
    5a96:	80 fd       	sbrc	r24, 0
    5a98:	cc cf       	rjmp	.-104    	; 0x5a32 <MB_S_Timer_ISR+0x2fa>
			MB_Frame[MB_N][Byte] |=Bit;
		else
			MB_Frame[MB_N][Byte] &=~Bit;
    5a9a:	f7 01       	movw	r30, r14
    5a9c:	e4 0f       	add	r30, r20
    5a9e:	f1 1d       	adc	r31, r1
    5aa0:	ed 5d       	subi	r30, 0xDD	; 221
    5aa2:	f4 4f       	sbci	r31, 0xF4	; 244
    5aa4:	50 95       	com	r21
    5aa6:	80 81       	ld	r24, Z
    5aa8:	58 23       	and	r21, r24
    5aaa:	50 83       	st	Z, r21
    5aac:	ca cf       	rjmp	.-108    	; 0x5a42 <MB_S_Timer_ISR+0x30a>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_PresetSingle(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame_Sz[MB_N]!=8)
    5aae:	68 85       	ldd	r22, Y+8	; 0x08
    5ab0:	79 85       	ldd	r23, Y+9	; 0x09
    5ab2:	6b 5f       	subi	r22, 0xFB	; 251
    5ab4:	78 4f       	sbci	r23, 0xF8	; 248
    5ab6:	fb 01       	movw	r30, r22
    5ab8:	c0 80       	ld	r12, Z
    5aba:	f8 e0       	ldi	r31, 0x08	; 8
    5abc:	cf 16       	cp	r12, r31
    5abe:	09 f0       	breq	.+2      	; 0x5ac2 <MB_S_Timer_ISR+0x38a>
    5ac0:	f3 ce       	rjmp	.-538    	; 0x58a8 <MB_S_Timer_ISR+0x170>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    5ac2:	f3 01       	movw	r30, r6
    5ac4:	e6 5c       	subi	r30, 0xC6	; 198
    5ac6:	fc 4f       	sbci	r31, 0xFC	; 252
    5ac8:	25 91       	lpm	r18, Z+
    5aca:	34 91       	lpm	r19, Z+
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+1>prw(&Modbus_Map[MB_N].HoldReg_Qt))
    5acc:	c4 01       	movw	r24, r8
    5ace:	01 96       	adiw	r24, 0x01	; 1
    5ad0:	28 17       	cp	r18, r24
    5ad2:	39 07       	cpc	r19, r25
    5ad4:	08 f4       	brcc	.+2      	; 0x5ad8 <MB_S_Timer_ISR+0x3a0>
    5ad6:	02 c1       	rjmp	.+516    	; 0x5cdc <MB_S_Timer_ISR+0x5a4>
		return MB_Frame[MB_N][2]=IllegAddr;
	MB_Frame_Sz[MB_N] = 8;
    5ad8:	db 01       	movw	r26, r22
    5ada:	cc 92       	st	X, r12

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5adc:	e8 85       	ldd	r30, Y+8	; 0x08
    5ade:	f9 85       	ldd	r31, Y+9	; 0x09
    5ae0:	ee 0f       	add	r30, r30
    5ae2:	ff 1f       	adc	r31, r31
    5ae4:	ee 0f       	add	r30, r30
    5ae6:	ff 1f       	adc	r31, r31
    5ae8:	ee 0f       	add	r30, r30
    5aea:	ff 1f       	adc	r31, r31
    5aec:	ee 0f       	add	r30, r30
    5aee:	ff 1f       	adc	r31, r31
    5af0:	e8 5c       	subi	r30, 0xC8	; 200
    5af2:	fc 4f       	sbci	r31, 0xFC	; 252
    5af4:	85 91       	lpm	r24, Z+
    5af6:	94 91       	lpm	r25, Z+
	*((uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+StartAddr) = MB_FrameReg(MB_N, 4);
    5af8:	88 0c       	add	r8, r8
    5afa:	99 1c       	adc	r9, r9
    5afc:	88 0e       	add	r8, r24
    5afe:	99 1e       	adc	r9, r25
    5b00:	28 85       	ldd	r18, Y+8	; 0x08
    5b02:	39 85       	ldd	r19, Y+9	; 0x09
    5b04:	f2 2f       	mov	r31, r18
    5b06:	ee 27       	eor	r30, r30
    5b08:	e9 5d       	subi	r30, 0xD9	; 217
    5b0a:	f4 4f       	sbci	r31, 0xF4	; 244
    5b0c:	90 81       	ld	r25, Z
    5b0e:	80 e0       	ldi	r24, 0x00	; 0
    5b10:	da 01       	movw	r26, r20
    5b12:	15 96       	adiw	r26, 0x05	; 5
    5b14:	2c 91       	ld	r18, X
    5b16:	30 e0       	ldi	r19, 0x00	; 0
    5b18:	82 2b       	or	r24, r18
    5b1a:	93 2b       	or	r25, r19
    5b1c:	f4 01       	movw	r30, r8
    5b1e:	91 83       	std	Z+1, r25	; 0x01
    5b20:	80 83       	st	Z, r24
    5b22:	90 e0       	ldi	r25, 0x00	; 0
    5b24:	c4 ce       	rjmp	.-632    	; 0x58ae <MB_S_Timer_ISR+0x176>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_Preset(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][6]+9 || MB_Frame[MB_N][5]*2!=MB_Frame[MB_N][6])
    5b26:	fa 01       	movw	r30, r20
    5b28:	86 81       	ldd	r24, Z+6	; 0x06
    5b2a:	28 2f       	mov	r18, r24
    5b2c:	30 e0       	ldi	r19, 0x00	; 0
    5b2e:	3f 83       	std	Y+7, r19	; 0x07
    5b30:	2e 83       	std	Y+6, r18	; 0x06
    5b32:	85 e0       	ldi	r24, 0x05	; 5
    5b34:	48 2e       	mov	r4, r24
    5b36:	87 e0       	ldi	r24, 0x07	; 7
    5b38:	58 2e       	mov	r5, r24
    5b3a:	88 85       	ldd	r24, Y+8	; 0x08
    5b3c:	99 85       	ldd	r25, Y+9	; 0x09
    5b3e:	48 0e       	add	r4, r24
    5b40:	59 1e       	adc	r5, r25
    5b42:	f2 01       	movw	r30, r4
    5b44:	80 81       	ld	r24, Z
    5b46:	90 e0       	ldi	r25, 0x00	; 0
    5b48:	27 5f       	subi	r18, 0xF7	; 247
    5b4a:	3f 4f       	sbci	r19, 0xFF	; 255
    5b4c:	82 17       	cp	r24, r18
    5b4e:	93 07       	cpc	r25, r19
    5b50:	99 f1       	breq	.+102    	; 0x5bb8 <MB_S_Timer_ISR+0x480>
		return MB_Frame[MB_N][2]=IllegData;
    5b52:	66 0f       	add	r22, r22
    5b54:	77 1f       	adc	r23, r23
    5b56:	6b 5d       	subi	r22, 0xDB	; 219
    5b58:	74 4f       	sbci	r23, 0xF4	; 244
    5b5a:	83 e0       	ldi	r24, 0x03	; 3
    5b5c:	db 01       	movw	r26, r22
    5b5e:	8c 93       	st	X, r24
    5b60:	93 e0       	ldi	r25, 0x03	; 3
    5b62:	a5 ce       	rjmp	.-694    	; 0x58ae <MB_S_Timer_ISR+0x176>
    5b64:	28 85       	ldd	r18, Y+8	; 0x08
    5b66:	39 85       	ldd	r19, Y+9	; 0x09
    5b68:	f2 2f       	mov	r31, r18
    5b6a:	ee 27       	eor	r30, r30
    5b6c:	e9 5d       	subi	r30, 0xD9	; 217
    5b6e:	f4 4f       	sbci	r31, 0xF4	; 244
    5b70:	e0 81       	ld	r30, Z
    5b72:	da 01       	movw	r26, r20
    5b74:	15 96       	adiw	r26, 0x05	; 5
    5b76:	fc 91       	ld	r31, X
    5b78:	15 97       	sbiw	r26, 0x05	; 5
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_Force(uint8_t MB_N, uint16_t StartAddr)
{
	uint16_t Qt = MB_FrameReg(MB_N, 4);
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][6]+9 || Qt/8+(Qt%8>0)!=MB_Frame[MB_N][6])
    5b7a:	16 96       	adiw	r26, 0x06	; 6
    5b7c:	2c 91       	ld	r18, X
    5b7e:	a5 e0       	ldi	r26, 0x05	; 5
    5b80:	4a 2e       	mov	r4, r26
    5b82:	a7 e0       	ldi	r26, 0x07	; 7
    5b84:	5a 2e       	mov	r5, r26
    5b86:	88 85       	ldd	r24, Y+8	; 0x08
    5b88:	99 85       	ldd	r25, Y+9	; 0x09
    5b8a:	48 0e       	add	r4, r24
    5b8c:	59 1e       	adc	r5, r25
    5b8e:	d2 01       	movw	r26, r4
    5b90:	8c 91       	ld	r24, X
    5b92:	90 e0       	ldi	r25, 0x00	; 0
    5b94:	42 2f       	mov	r20, r18
    5b96:	50 e0       	ldi	r21, 0x00	; 0
    5b98:	9a 01       	movw	r18, r20
    5b9a:	27 5f       	subi	r18, 0xF7	; 247
    5b9c:	3f 4f       	sbci	r19, 0xFF	; 255
    5b9e:	82 17       	cp	r24, r18
    5ba0:	93 07       	cpc	r25, r19
    5ba2:	09 f4       	brne	.+2      	; 0x5ba6 <MB_S_Timer_ISR+0x46e>
    5ba4:	61 c0       	rjmp	.+194    	; 0x5c68 <MB_S_Timer_ISR+0x530>
		return MB_Frame[MB_N][2]=IllegData;
    5ba6:	66 0f       	add	r22, r22
    5ba8:	77 1f       	adc	r23, r23
    5baa:	6b 5d       	subi	r22, 0xDB	; 219
    5bac:	74 4f       	sbci	r23, 0xF4	; 244
    5bae:	83 e0       	ldi	r24, 0x03	; 3
    5bb0:	fb 01       	movw	r30, r22
    5bb2:	80 83       	st	Z, r24
    5bb4:	93 e0       	ldi	r25, 0x03	; 3
    5bb6:	7b ce       	rjmp	.-778    	; 0x58ae <MB_S_Timer_ISR+0x176>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_Preset(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][6]+9 || MB_Frame[MB_N][5]*2!=MB_Frame[MB_N][6])
    5bb8:	9a 01       	movw	r18, r20
    5bba:	2b 5f       	subi	r18, 0xFB	; 251
    5bbc:	3f 4f       	sbci	r19, 0xFF	; 255
    5bbe:	3c 83       	std	Y+4, r19	; 0x04
    5bc0:	2b 83       	std	Y+3, r18	; 0x03
    5bc2:	fa 01       	movw	r30, r20
    5bc4:	c5 80       	ldd	r12, Z+5	; 0x05
    5bc6:	2c 2d       	mov	r18, r12
    5bc8:	30 e0       	ldi	r19, 0x00	; 0
    5bca:	c9 01       	movw	r24, r18
    5bcc:	88 0f       	add	r24, r24
    5bce:	99 1f       	adc	r25, r25
    5bd0:	ee 81       	ldd	r30, Y+6	; 0x06
    5bd2:	ff 81       	ldd	r31, Y+7	; 0x07
    5bd4:	e8 17       	cp	r30, r24
    5bd6:	f9 07       	cpc	r31, r25
    5bd8:	09 f0       	breq	.+2      	; 0x5bdc <MB_S_Timer_ISR+0x4a4>
    5bda:	bb cf       	rjmp	.-138    	; 0x5b52 <MB_S_Timer_ISR+0x41a>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    5bdc:	f3 01       	movw	r30, r6
    5bde:	e6 5c       	subi	r30, 0xC6	; 198
    5be0:	fc 4f       	sbci	r31, 0xFC	; 252
    5be2:	85 91       	lpm	r24, Z+
    5be4:	94 91       	lpm	r25, Z+
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+MB_Frame[MB_N][5]>prw(&Modbus_Map[MB_N].HoldReg_Qt))
    5be6:	28 0d       	add	r18, r8
    5be8:	39 1d       	adc	r19, r9
    5bea:	82 17       	cp	r24, r18
    5bec:	93 07       	cpc	r25, r19
    5bee:	08 f4       	brcc	.+2      	; 0x5bf2 <MB_S_Timer_ISR+0x4ba>
    5bf0:	75 c0       	rjmp	.+234    	; 0x5cdc <MB_S_Timer_ISR+0x5a4>
		return MB_Frame[MB_N][2]=IllegAddr;
	MB_Frame_Sz[MB_N] = 8;
    5bf2:	88 e0       	ldi	r24, 0x08	; 8
    5bf4:	f2 01       	movw	r30, r4
    5bf6:	80 83       	st	Z, r24

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5bf8:	e8 85       	ldd	r30, Y+8	; 0x08
    5bfa:	f9 85       	ldd	r31, Y+9	; 0x09
    5bfc:	ee 0f       	add	r30, r30
    5bfe:	ff 1f       	adc	r31, r31
    5c00:	ee 0f       	add	r30, r30
    5c02:	ff 1f       	adc	r31, r31
    5c04:	ee 0f       	add	r30, r30
    5c06:	ff 1f       	adc	r31, r31
    5c08:	ee 0f       	add	r30, r30
    5c0a:	ff 1f       	adc	r31, r31
    5c0c:	e8 5c       	subi	r30, 0xC8	; 200
    5c0e:	fc 4f       	sbci	r31, 0xFC	; 252
    5c10:	45 90       	lpm	r4, Z+
    5c12:	54 90       	lpm	r5, Z+
	uint16_t *HoldReg = prp(&Modbus_Map[MB_N].HoldReg);
	for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    5c14:	cc 20       	and	r12, r12
    5c16:	31 f1       	breq	.+76     	; 0x5c64 <MB_S_Timer_ISR+0x52c>
    5c18:	60 e0       	ldi	r22, 0x00	; 0
    5c1a:	6b 80       	ldd	r6, Y+3	; 0x03
    5c1c:	7c 80       	ldd	r7, Y+4	; 0x04
    5c1e:	a6 2f       	mov	r26, r22
    5c20:	b0 e0       	ldi	r27, 0x00	; 0
    5c22:	cd 01       	movw	r24, r26
    5c24:	88 0f       	add	r24, r24
    5c26:	99 1f       	adc	r25, r25
    5c28:	89 5f       	subi	r24, 0xF9	; 249
    5c2a:	28 2f       	mov	r18, r24
    5c2c:	30 e0       	ldi	r19, 0x00	; 0
		uint8_t j = i*2;
		HoldReg[StartAddr+i] = MB_FrameReg(MB_N, 7+j);
    5c2e:	a8 0d       	add	r26, r8
    5c30:	b9 1d       	adc	r27, r9
    5c32:	aa 0f       	add	r26, r26
    5c34:	bb 1f       	adc	r27, r27
    5c36:	a4 0d       	add	r26, r4
    5c38:	b5 1d       	adc	r27, r5
    5c3a:	fa 01       	movw	r30, r20
    5c3c:	e2 0f       	add	r30, r18
    5c3e:	f3 1f       	adc	r31, r19
    5c40:	81 81       	ldd	r24, Z+1	; 0x01
    5c42:	90 e0       	ldi	r25, 0x00	; 0
    5c44:	2e 0d       	add	r18, r14
    5c46:	3f 1d       	adc	r19, r15
    5c48:	2d 5d       	subi	r18, 0xDD	; 221
    5c4a:	34 4f       	sbci	r19, 0xF4	; 244
    5c4c:	f9 01       	movw	r30, r18
    5c4e:	30 81       	ld	r19, Z
    5c50:	20 e0       	ldi	r18, 0x00	; 0
    5c52:	82 2b       	or	r24, r18
    5c54:	93 2b       	or	r25, r19
    5c56:	8d 93       	st	X+, r24
    5c58:	9c 93       	st	X, r25
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+MB_Frame[MB_N][5]>prw(&Modbus_Map[MB_N].HoldReg_Qt))
		return MB_Frame[MB_N][2]=IllegAddr;
	MB_Frame_Sz[MB_N] = 8;
	uint16_t *HoldReg = prp(&Modbus_Map[MB_N].HoldReg);
	for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    5c5a:	6f 5f       	subi	r22, 0xFF	; 255
    5c5c:	d3 01       	movw	r26, r6
    5c5e:	8c 91       	ld	r24, X
    5c60:	68 17       	cp	r22, r24
    5c62:	e8 f2       	brcs	.-70     	; 0x5c1e <MB_S_Timer_ISR+0x4e6>
		break;
	case 0x10:
		Err = MB_S_Preset(MB_N, StartAddr);
		break;
	default:
		Err = MB_Frame[MB_N][2] = IllegFunc;
    5c64:	90 e0       	ldi	r25, 0x00	; 0
    5c66:	23 ce       	rjmp	.-954    	; 0x58ae <MB_S_Timer_ISR+0x176>
    5c68:	9e 2f       	mov	r25, r30
    5c6a:	80 e0       	ldi	r24, 0x00	; 0
    5c6c:	af 2f       	mov	r26, r31
    5c6e:	b0 e0       	ldi	r27, 0x00	; 0
    5c70:	a8 2b       	or	r26, r24
    5c72:	b9 2b       	or	r27, r25
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_Force(uint8_t MB_N, uint16_t StartAddr)
{
	uint16_t Qt = MB_FrameReg(MB_N, 4);
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][6]+9 || Qt/8+(Qt%8>0)!=MB_Frame[MB_N][6])
    5c74:	20 e0       	ldi	r18, 0x00	; 0
    5c76:	30 e0       	ldi	r19, 0x00	; 0
    5c78:	cd 01       	movw	r24, r26
    5c7a:	87 70       	andi	r24, 0x07	; 7
    5c7c:	90 70       	andi	r25, 0x00	; 0
    5c7e:	89 2b       	or	r24, r25
    5c80:	11 f0       	breq	.+4      	; 0x5c86 <MB_S_Timer_ISR+0x54e>
    5c82:	21 e0       	ldi	r18, 0x01	; 1
    5c84:	30 e0       	ldi	r19, 0x00	; 0
    5c86:	cd 01       	movw	r24, r26
    5c88:	96 95       	lsr	r25
    5c8a:	87 95       	ror	r24
    5c8c:	96 95       	lsr	r25
    5c8e:	87 95       	ror	r24
    5c90:	96 95       	lsr	r25
    5c92:	87 95       	ror	r24
    5c94:	28 0f       	add	r18, r24
    5c96:	39 1f       	adc	r19, r25
    5c98:	24 17       	cp	r18, r20
    5c9a:	35 07       	cpc	r19, r21
    5c9c:	09 f0       	breq	.+2      	; 0x5ca0 <MB_S_Timer_ISR+0x568>
    5c9e:	83 cf       	rjmp	.-250    	; 0x5ba6 <MB_S_Timer_ISR+0x46e>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    5ca0:	e8 85       	ldd	r30, Y+8	; 0x08
    5ca2:	f9 85       	ldd	r31, Y+9	; 0x09
    5ca4:	ee 0f       	add	r30, r30
    5ca6:	ff 1f       	adc	r31, r31
    5ca8:	ee 0f       	add	r30, r30
    5caa:	ff 1f       	adc	r31, r31
    5cac:	ee 0f       	add	r30, r30
    5cae:	ff 1f       	adc	r31, r31
    5cb0:	ee 0f       	add	r30, r30
    5cb2:	ff 1f       	adc	r31, r31
    5cb4:	ee 5c       	subi	r30, 0xCE	; 206
    5cb6:	fc 4f       	sbci	r31, 0xFC	; 252
    5cb8:	25 91       	lpm	r18, Z+
    5cba:	34 91       	lpm	r19, Z+
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+Qt > prw(&Modbus_Map[MB_N].Coil_Qt))
    5cbc:	cd 01       	movw	r24, r26
    5cbe:	88 0d       	add	r24, r8
    5cc0:	99 1d       	adc	r25, r9
    5cc2:	28 17       	cp	r18, r24
    5cc4:	39 07       	cpc	r19, r25
    5cc6:	08 f0       	brcs	.+2      	; 0x5cca <MB_S_Timer_ISR+0x592>
    5cc8:	5d c0       	rjmp	.+186    	; 0x5d84 <MB_S_Timer_ISR+0x64c>
		return MB_Frame[MB_N][2]=IllegAddr;
    5cca:	66 0f       	add	r22, r22
    5ccc:	77 1f       	adc	r23, r23
    5cce:	6b 5d       	subi	r22, 0xDB	; 219
    5cd0:	74 4f       	sbci	r23, 0xF4	; 244
    5cd2:	82 e0       	ldi	r24, 0x02	; 2
    5cd4:	db 01       	movw	r26, r22
    5cd6:	8c 93       	st	X, r24
    5cd8:	92 e0       	ldi	r25, 0x02	; 2
    5cda:	e9 cd       	rjmp	.-1070   	; 0x58ae <MB_S_Timer_ISR+0x176>
MB_S_Preset(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][6]+9 || MB_Frame[MB_N][5]*2!=MB_Frame[MB_N][6])
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+MB_Frame[MB_N][5]>prw(&Modbus_Map[MB_N].HoldReg_Qt))
		return MB_Frame[MB_N][2]=IllegAddr;
    5cdc:	82 e0       	ldi	r24, 0x02	; 2
    5cde:	8c 93       	st	X, r24
    5ce0:	92 e0       	ldi	r25, 0x02	; 2
    5ce2:	e5 cd       	rjmp	.-1078   	; 0x58ae <MB_S_Timer_ISR+0x176>
	if (MB_Frame[MB_N][0]==0)
		return 0xFF;
	if (MB_Frame_Sz[MB_N]!=8)
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+MB_Frame[MB_N][5]>(MB_Frame[MB_N][1]==3?prw(&Modbus_Map[MB_N].HoldReg_Qt):prw(&Modbus_Map[MB_N].InReg_Qt)))
		return MB_Frame[MB_N][2]=IllegAddr;
    5ce4:	66 0f       	add	r22, r22
    5ce6:	77 1f       	adc	r23, r23
    5ce8:	6b 5d       	subi	r22, 0xDB	; 219
    5cea:	74 4f       	sbci	r23, 0xF4	; 244
    5cec:	82 e0       	ldi	r24, 0x02	; 2
    5cee:	fb 01       	movw	r30, r22
    5cf0:	80 83       	st	Z, r24
    5cf2:	92 e0       	ldi	r25, 0x02	; 2
    5cf4:	dc cd       	rjmp	.-1096   	; 0x58ae <MB_S_Timer_ISR+0x176>
{
	if (MB_Frame[MB_N][0]==0)
		return 0xFF;
	if (MB_Frame_Sz[MB_N]!=8)
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+MB_Frame[MB_N][5]>(MB_Frame[MB_N][1]==3?prw(&Modbus_Map[MB_N].HoldReg_Qt):prw(&Modbus_Map[MB_N].InReg_Qt)))
    5cf6:	da 01       	movw	r26, r20
    5cf8:	15 96       	adiw	r26, 0x05	; 5
    5cfa:	8c 91       	ld	r24, X
    5cfc:	33 30       	cpi	r19, 0x03	; 3
    5cfe:	09 f4       	brne	.+2      	; 0x5d02 <MB_S_Timer_ISR+0x5ca>
    5d00:	ab c0       	rjmp	.+342    	; 0x5e58 <MB_S_Timer_ISR+0x720>
    5d02:	f3 01       	movw	r30, r6
    5d04:	e2 5c       	subi	r30, 0xC2	; 194
    5d06:	fc 4f       	sbci	r31, 0xFC	; 252
    5d08:	45 91       	lpm	r20, Z+
    5d0a:	54 91       	lpm	r21, Z+
    5d0c:	a8 2f       	mov	r26, r24
    5d0e:	b0 e0       	ldi	r27, 0x00	; 0
    5d10:	c4 01       	movw	r24, r8
    5d12:	8a 0f       	add	r24, r26
    5d14:	9b 1f       	adc	r25, r27
    5d16:	48 17       	cp	r20, r24
    5d18:	59 07       	cpc	r21, r25
    5d1a:	20 f3       	brcs	.-56     	; 0x5ce4 <MB_S_Timer_ISR+0x5ac>
		return MB_Frame[MB_N][2]=IllegAddr;
	uint16_t *Reg = (uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg)) + StartAddr;
    5d1c:	33 30       	cpi	r19, 0x03	; 3
    5d1e:	09 f4       	brne	.+2      	; 0x5d22 <MB_S_Timer_ISR+0x5ea>
    5d20:	a9 c0       	rjmp	.+338    	; 0x5e74 <MB_S_Timer_ISR+0x73c>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5d22:	f3 01       	movw	r30, r6
    5d24:	e4 5c       	subi	r30, 0xC4	; 196
    5d26:	fc 4f       	sbci	r31, 0xFC	; 252
    5d28:	85 91       	lpm	r24, Z+
    5d2a:	94 91       	lpm	r25, Z+
    5d2c:	94 01       	movw	r18, r8
    5d2e:	22 0f       	add	r18, r18
    5d30:	33 1f       	adc	r19, r19
    5d32:	28 0f       	add	r18, r24
    5d34:	39 1f       	adc	r19, r25
	MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][2] = MB_Frame[MB_N][5]*2) + 5;
    5d36:	cd 01       	movw	r24, r26
    5d38:	88 0f       	add	r24, r24
    5d3a:	99 1f       	adc	r25, r25
    5d3c:	66 0f       	add	r22, r22
    5d3e:	77 1f       	adc	r23, r23
    5d40:	6b 5d       	subi	r22, 0xDB	; 219
    5d42:	74 4f       	sbci	r23, 0xF4	; 244
    5d44:	db 01       	movw	r26, r22
    5d46:	8c 93       	st	X, r24
    5d48:	8b 5f       	subi	r24, 0xFB	; 251
    5d4a:	f2 01       	movw	r30, r4
    5d4c:	80 83       	st	Z, r24
	uint8_t Qt = MB_Frame[MB_N][5];
    5d4e:	f7 01       	movw	r30, r14
    5d50:	ed 5d       	subi	r30, 0xDD	; 221
    5d52:	f4 4f       	sbci	r31, 0xF4	; 244
    5d54:	45 81       	ldd	r20, Z+5	; 0x05
	for (uint8_t i=0; i<Qt; i++) {
    5d56:	44 23       	and	r20, r20
    5d58:	09 f4       	brne	.+2      	; 0x5d5c <MB_S_Timer_ISR+0x624>
    5d5a:	84 cf       	rjmp	.-248    	; 0x5c64 <MB_S_Timer_ISR+0x52c>
    5d5c:	d9 01       	movw	r26, r18
    5d5e:	90 e0       	ldi	r25, 0x00	; 0
		uint8_t j = i*2;
		MB_Frame[MB_N][3+j] = Reg[i]>>8;
    5d60:	9f 01       	movw	r18, r30
    5d62:	89 2f       	mov	r24, r25
    5d64:	88 0f       	add	r24, r24
    5d66:	f9 01       	movw	r30, r18
    5d68:	e8 0f       	add	r30, r24
    5d6a:	f1 1d       	adc	r31, r1
    5d6c:	11 96       	adiw	r26, 0x01	; 1
    5d6e:	8c 91       	ld	r24, X
    5d70:	11 97       	sbiw	r26, 0x01	; 1
    5d72:	83 83       	std	Z+3, r24	; 0x03
		MB_Frame[MB_N][4+j] = Reg[i];
    5d74:	8c 91       	ld	r24, X
    5d76:	84 83       	std	Z+4, r24	; 0x04
	if (StartAddr+MB_Frame[MB_N][5]>(MB_Frame[MB_N][1]==3?prw(&Modbus_Map[MB_N].HoldReg_Qt):prw(&Modbus_Map[MB_N].InReg_Qt)))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint16_t *Reg = (uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg)) + StartAddr;
	MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][2] = MB_Frame[MB_N][5]*2) + 5;
	uint8_t Qt = MB_Frame[MB_N][5];
	for (uint8_t i=0; i<Qt; i++) {
    5d78:	9f 5f       	subi	r25, 0xFF	; 255
    5d7a:	12 96       	adiw	r26, 0x02	; 2
    5d7c:	94 17       	cp	r25, r20
    5d7e:	88 f3       	brcs	.-30     	; 0x5d62 <MB_S_Timer_ISR+0x62a>
		break;
	case 0x10:
		Err = MB_S_Preset(MB_N, StartAddr);
		break;
	default:
		Err = MB_Frame[MB_N][2] = IllegFunc;
    5d80:	90 e0       	ldi	r25, 0x00	; 0
    5d82:	95 cd       	rjmp	.-1238   	; 0x58ae <MB_S_Timer_ISR+0x176>
    5d84:	93 01       	movw	r18, r6
    5d86:	20 5d       	subi	r18, 0xD0	; 208
    5d88:	3c 4f       	sbci	r19, 0xFC	; 252
    5d8a:	f9 01       	movw	r30, r18
    5d8c:	85 91       	lpm	r24, Z+
    5d8e:	94 91       	lpm	r25, Z+
    5d90:	9a 83       	std	Y+2, r25	; 0x02
    5d92:	89 83       	std	Y+1, r24	; 0x01
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][6]+9 || Qt/8+(Qt%8>0)!=MB_Frame[MB_N][6])
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+Qt > prw(&Modbus_Map[MB_N].Coil_Qt))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Coil = prp(&Modbus_Map[MB_N].Coil);
	MB_Frame_Sz[MB_N] = 8;
    5d94:	88 e0       	ldi	r24, 0x08	; 8
    5d96:	f2 01       	movw	r30, r4
    5d98:	80 83       	st	Z, r24
	for (uint8_t i=0; i<Qt; i++) {
    5d9a:	10 97       	sbiw	r26, 0x00	; 0
    5d9c:	09 f4       	brne	.+2      	; 0x5da0 <MB_S_Timer_ISR+0x668>
    5d9e:	62 cf       	rjmp	.-316    	; 0x5c64 <MB_S_Timer_ISR+0x52c>
    5da0:	cc 24       	eor	r12, r12
    5da2:	80 e0       	ldi	r24, 0x00	; 0
    5da4:	90 e0       	ldi	r25, 0x00	; 0
    5da6:	20 e0       	ldi	r18, 0x00	; 0
    5da8:	30 e0       	ldi	r19, 0x00	; 0
		uint16_t j = StartAddr+i;
		uint16_t Byte=j/8, Bit=1<<j%8;
    5daa:	e1 e0       	ldi	r30, 0x01	; 1
    5dac:	4e 2e       	mov	r4, r30
    5dae:	51 2c       	mov	r5, r1
		if (MB_Frame[MB_N][7+i/8] &(1<<i%8))
    5db0:	73 e2       	ldi	r23, 0x23	; 35
    5db2:	67 2e       	mov	r6, r23
    5db4:	7b e0       	ldi	r23, 0x0B	; 11
    5db6:	77 2e       	mov	r7, r23
    5db8:	6e 0c       	add	r6, r14
    5dba:	7f 1c       	adc	r7, r15
    5dbc:	10 c0       	rjmp	.+32     	; 0x5dde <MB_S_Timer_ISR+0x6a6>
			Coil[Byte] |=Bit;
    5dbe:	29 81       	ldd	r18, Y+1	; 0x01
    5dc0:	3a 81       	ldd	r19, Y+2	; 0x02
    5dc2:	24 0f       	add	r18, r20
    5dc4:	35 1f       	adc	r19, r21
    5dc6:	f9 01       	movw	r30, r18
    5dc8:	80 81       	ld	r24, Z
    5dca:	86 2b       	or	r24, r22
    5dcc:	80 83       	st	Z, r24
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+Qt > prw(&Modbus_Map[MB_N].Coil_Qt))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Coil = prp(&Modbus_Map[MB_N].Coil);
	MB_Frame_Sz[MB_N] = 8;
	for (uint8_t i=0; i<Qt; i++) {
    5dce:	c3 94       	inc	r12
    5dd0:	2c 2d       	mov	r18, r12
    5dd2:	30 e0       	ldi	r19, 0x00	; 0
    5dd4:	c9 01       	movw	r24, r18
    5dd6:	2a 17       	cp	r18, r26
    5dd8:	3b 07       	cpc	r19, r27
    5dda:	08 f0       	brcs	.+2      	; 0x5dde <MB_S_Timer_ISR+0x6a6>
    5ddc:	43 cf       	rjmp	.-378    	; 0x5c64 <MB_S_Timer_ISR+0x52c>
		uint16_t j = StartAddr+i;
    5dde:	88 0d       	add	r24, r8
    5de0:	99 1d       	adc	r25, r9
		uint16_t Byte=j/8, Bit=1<<j%8;
    5de2:	ac 01       	movw	r20, r24
    5de4:	56 95       	lsr	r21
    5de6:	47 95       	ror	r20
    5de8:	56 95       	lsr	r21
    5dea:	47 95       	ror	r20
    5dec:	56 95       	lsr	r21
    5dee:	47 95       	ror	r20
    5df0:	87 70       	andi	r24, 0x07	; 7
    5df2:	90 70       	andi	r25, 0x00	; 0
    5df4:	b2 01       	movw	r22, r4
    5df6:	02 c0       	rjmp	.+4      	; 0x5dfc <MB_S_Timer_ISR+0x6c4>
    5df8:	66 0f       	add	r22, r22
    5dfa:	77 1f       	adc	r23, r23
    5dfc:	8a 95       	dec	r24
    5dfe:	e2 f7       	brpl	.-8      	; 0x5df8 <MB_S_Timer_ISR+0x6c0>
		if (MB_Frame[MB_N][7+i/8] &(1<<i%8))
    5e00:	8c 2d       	mov	r24, r12
    5e02:	86 95       	lsr	r24
    5e04:	86 95       	lsr	r24
    5e06:	86 95       	lsr	r24
    5e08:	f3 01       	movw	r30, r6
    5e0a:	e8 0f       	add	r30, r24
    5e0c:	f1 1d       	adc	r31, r1
    5e0e:	87 81       	ldd	r24, Z+7	; 0x07
    5e10:	90 e0       	ldi	r25, 0x00	; 0
    5e12:	27 70       	andi	r18, 0x07	; 7
    5e14:	30 70       	andi	r19, 0x00	; 0
    5e16:	02 c0       	rjmp	.+4      	; 0x5e1c <MB_S_Timer_ISR+0x6e4>
    5e18:	95 95       	asr	r25
    5e1a:	87 95       	ror	r24
    5e1c:	2a 95       	dec	r18
    5e1e:	e2 f7       	brpl	.-8      	; 0x5e18 <MB_S_Timer_ISR+0x6e0>
    5e20:	80 fd       	sbrc	r24, 0
    5e22:	cd cf       	rjmp	.-102    	; 0x5dbe <MB_S_Timer_ISR+0x686>
			Coil[Byte] |=Bit;
		else
			Coil[Byte] &=~Bit;
    5e24:	29 81       	ldd	r18, Y+1	; 0x01
    5e26:	3a 81       	ldd	r19, Y+2	; 0x02
    5e28:	24 0f       	add	r18, r20
    5e2a:	35 1f       	adc	r19, r21
    5e2c:	96 2f       	mov	r25, r22
    5e2e:	90 95       	com	r25
    5e30:	f9 01       	movw	r30, r18
    5e32:	80 81       	ld	r24, Z
    5e34:	89 23       	and	r24, r25
    5e36:	80 83       	st	Z, r24
    5e38:	ca cf       	rjmp	.-108    	; 0x5dce <MB_S_Timer_ISR+0x696>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    5e3a:	e8 85       	ldd	r30, Y+8	; 0x08
    5e3c:	f9 85       	ldd	r31, Y+9	; 0x09
    5e3e:	ee 0f       	add	r30, r30
    5e40:	ff 1f       	adc	r31, r31
    5e42:	ee 0f       	add	r30, r30
    5e44:	ff 1f       	adc	r31, r31
    5e46:	ee 0f       	add	r30, r30
    5e48:	ff 1f       	adc	r31, r31
    5e4a:	ee 0f       	add	r30, r30
    5e4c:	ff 1f       	adc	r31, r31
    5e4e:	ee 5c       	subi	r30, 0xCE	; 206
    5e50:	fc 4f       	sbci	r31, 0xFC	; 252
    5e52:	45 91       	lpm	r20, Z+
    5e54:	54 91       	lpm	r21, Z+
    5e56:	b2 cd       	rjmp	.-1180   	; 0x59bc <MB_S_Timer_ISR+0x284>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5e58:	f3 01       	movw	r30, r6
    5e5a:	e6 5c       	subi	r30, 0xC6	; 198
    5e5c:	fc 4f       	sbci	r31, 0xFC	; 252
    5e5e:	45 91       	lpm	r20, Z+
    5e60:	54 91       	lpm	r21, Z+
    5e62:	54 cf       	rjmp	.-344    	; 0x5d0c <MB_S_Timer_ISR+0x5d4>
    5e64:	f3 01       	movw	r30, r6
    5e66:	e0 5d       	subi	r30, 0xD0	; 208
    5e68:	fc 4f       	sbci	r31, 0xFC	; 252
    5e6a:	85 91       	lpm	r24, Z+
    5e6c:	94 91       	lpm	r25, Z+
    5e6e:	28 2f       	mov	r18, r24
    5e70:	89 2f       	mov	r24, r25
    5e72:	b9 cd       	rjmp	.-1166   	; 0x59e6 <MB_S_Timer_ISR+0x2ae>
    5e74:	e8 85       	ldd	r30, Y+8	; 0x08
    5e76:	f9 85       	ldd	r31, Y+9	; 0x09
    5e78:	ee 0f       	add	r30, r30
    5e7a:	ff 1f       	adc	r31, r31
    5e7c:	ee 0f       	add	r30, r30
    5e7e:	ff 1f       	adc	r31, r31
    5e80:	ee 0f       	add	r30, r30
    5e82:	ff 1f       	adc	r31, r31
    5e84:	ee 0f       	add	r30, r30
    5e86:	ff 1f       	adc	r31, r31
    5e88:	e8 5c       	subi	r30, 0xC8	; 200
    5e8a:	fc 4f       	sbci	r31, 0xFC	; 252
    5e8c:	85 91       	lpm	r24, Z+
    5e8e:	94 91       	lpm	r25, Z+
    5e90:	4d cf       	rjmp	.-358    	; 0x5d2c <MB_S_Timer_ISR+0x5f4>

00005e92 <MB_S_Tx>:
    5e92:	94 e1       	ldi	r25, 0x14	; 20
    5e94:	89 9f       	mul	r24, r25
    5e96:	c0 01       	movw	r24, r0
    5e98:	11 24       	eor	r1, r1
    5e9a:	81 5b       	subi	r24, 0xB1	; 177
    5e9c:	91 4d       	sbci	r25, 0xD1	; 209
    5e9e:	fc 01       	movw	r30, r24
    5ea0:	25 91       	lpm	r18, Z+
    5ea2:	34 91       	lpm	r19, Z+

// ~~~~~~~~~~~~~~~~~~
void
MB_S_Tx(uint8_t MB_N)
{
	USART_Func(MB_N, LED);
    5ea4:	f9 01       	movw	r30, r18
    5ea6:	19 95       	eicall
}
    5ea8:	08 95       	ret

00005eaa <MB_Slave_Off>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
MB_Slave_Off(uint8_t MB_N, uint8_t S_N)
{
    5eaa:	21 e0       	ldi	r18, 0x01	; 1
    5eac:	30 e0       	ldi	r19, 0x00	; 0
    5eae:	40 e0       	ldi	r20, 0x00	; 0
    5eb0:	50 e0       	ldi	r21, 0x00	; 0
    5eb2:	04 c0       	rjmp	.+8      	; 0x5ebc <MB_Slave_Off+0x12>
    5eb4:	22 0f       	add	r18, r18
    5eb6:	33 1f       	adc	r19, r19
    5eb8:	44 1f       	adc	r20, r20
    5eba:	55 1f       	adc	r21, r21
    5ebc:	6a 95       	dec	r22
    5ebe:	d2 f7       	brpl	.-12     	; 0x5eb4 <MB_Slave_Off+0xa>
    5ec0:	e8 2f       	mov	r30, r24
    5ec2:	f0 e0       	ldi	r31, 0x00	; 0
    5ec4:	ee 0f       	add	r30, r30
    5ec6:	ff 1f       	adc	r31, r31
    5ec8:	ee 0f       	add	r30, r30
    5eca:	ff 1f       	adc	r31, r31
    5ecc:	eb 51       	subi	r30, 0x1B	; 27
    5ece:	f7 4f       	sbci	r31, 0xF7	; 247
    5ed0:	80 81       	ld	r24, Z
    5ed2:	91 81       	ldd	r25, Z+1	; 0x01
    5ed4:	a2 81       	ldd	r26, Z+2	; 0x02
    5ed6:	b3 81       	ldd	r27, Z+3	; 0x03
    5ed8:	28 23       	and	r18, r24
    5eda:	39 23       	and	r19, r25
    5edc:	4a 23       	and	r20, r26
    5ede:	5b 23       	and	r21, r27
	return SlaveOff[MB_N] &((uint32_t)1<<S_N);
}
    5ee0:	b9 01       	movw	r22, r18
    5ee2:	ca 01       	movw	r24, r20
    5ee4:	08 95       	ret

00005ee6 <GetReg>:
}

// ~~~~~~~~~~~~~~~~~
static uint16_t*
GetReg(uint8_t MB_N)
{
    5ee6:	98 2f       	mov	r25, r24
	return MB_SingleState[MB_N]!=MB_SingleExec?(uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+prw(&GetQuery(MB_N)->AllocAddr):MB_SingleQuery[MB_N].Buf;
    5ee8:	a8 2f       	mov	r26, r24
    5eea:	b0 e0       	ldi	r27, 0x00	; 0
    5eec:	fd 01       	movw	r30, r26
    5eee:	e3 55       	subi	r30, 0x53	; 83
    5ef0:	f9 4f       	sbci	r31, 0xF9	; 249
    5ef2:	80 81       	ld	r24, Z
    5ef4:	82 30       	cpi	r24, 0x02	; 2
    5ef6:	09 f4       	brne	.+2      	; 0x5efa <GetReg+0x14>
    5ef8:	39 c0       	rjmp	.+114    	; 0x5f6c <GetReg+0x86>
    5efa:	fd 01       	movw	r30, r26
    5efc:	ee 0f       	add	r30, r30
    5efe:	ff 1f       	adc	r31, r31
    5f00:	ee 0f       	add	r30, r30
    5f02:	ff 1f       	adc	r31, r31
    5f04:	ee 0f       	add	r30, r30
    5f06:	ff 1f       	adc	r31, r31
    5f08:	ee 0f       	add	r30, r30
    5f0a:	ff 1f       	adc	r31, r31
    5f0c:	e8 5c       	subi	r30, 0xC8	; 200
    5f0e:	fc 4f       	sbci	r31, 0xFC	; 252
    5f10:	45 91       	lpm	r20, Z+
    5f12:	54 91       	lpm	r21, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    5f14:	83 e0       	ldi	r24, 0x03	; 3
    5f16:	98 9f       	mul	r25, r24
    5f18:	f0 01       	movw	r30, r0
    5f1a:	11 24       	eor	r1, r1
    5f1c:	e5 5b       	subi	r30, 0xB5	; 181
    5f1e:	f6 4d       	sbci	r31, 0xD6	; 214
    5f20:	25 91       	lpm	r18, Z+
    5f22:	34 91       	lpm	r19, Z+
    5f24:	fd 01       	movw	r30, r26
    5f26:	ee 5a       	subi	r30, 0xAE	; 174
    5f28:	f9 4f       	sbci	r31, 0xF9	; 249
    5f2a:	80 81       	ld	r24, Z
    5f2c:	90 e0       	ldi	r25, 0x00	; 0
    5f2e:	88 0f       	add	r24, r24
    5f30:	99 1f       	adc	r25, r25
    5f32:	88 0f       	add	r24, r24
    5f34:	99 1f       	adc	r25, r25
    5f36:	28 0f       	add	r18, r24
    5f38:	39 1f       	adc	r19, r25
    5f3a:	2f 5f       	subi	r18, 0xFF	; 255
    5f3c:	3f 4f       	sbci	r19, 0xFF	; 255
    5f3e:	f9 01       	movw	r30, r18
    5f40:	65 91       	lpm	r22, Z+
    5f42:	74 91       	lpm	r23, Z+
    5f44:	ad 5a       	subi	r26, 0xAD	; 173
    5f46:	b9 4f       	sbci	r27, 0xF9	; 249
    5f48:	8c 91       	ld	r24, X
    5f4a:	27 e0       	ldi	r18, 0x07	; 7
    5f4c:	82 9f       	mul	r24, r18
    5f4e:	c0 01       	movw	r24, r0
    5f50:	11 24       	eor	r1, r1
    5f52:	68 0f       	add	r22, r24
    5f54:	79 1f       	adc	r23, r25
    5f56:	6b 5f       	subi	r22, 0xFB	; 251
    5f58:	7f 4f       	sbci	r23, 0xFF	; 255
    5f5a:	fb 01       	movw	r30, r22
    5f5c:	85 91       	lpm	r24, Z+
    5f5e:	94 91       	lpm	r25, Z+
    5f60:	88 0f       	add	r24, r24
    5f62:	99 1f       	adc	r25, r25
    5f64:	48 0f       	add	r20, r24
    5f66:	59 1f       	adc	r21, r25
}
    5f68:	ca 01       	movw	r24, r20
    5f6a:	08 95       	ret

// ~~~~~~~~~~~~~~~~~
static uint16_t*
GetReg(uint8_t MB_N)
{
	return MB_SingleState[MB_N]!=MB_SingleExec?(uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+prw(&GetQuery(MB_N)->AllocAddr):MB_SingleQuery[MB_N].Buf;
    5f6c:	aa 0f       	add	r26, r26
    5f6e:	bb 1f       	adc	r27, r27
    5f70:	aa 0f       	add	r26, r26
    5f72:	bb 1f       	adc	r27, r27
    5f74:	aa 0f       	add	r26, r26
    5f76:	bb 1f       	adc	r27, r27
    5f78:	a8 52       	subi	r26, 0x28	; 40
    5f7a:	bb 4f       	sbci	r27, 0xFB	; 251
    5f7c:	16 96       	adiw	r26, 0x06	; 6
    5f7e:	4d 91       	ld	r20, X+
    5f80:	5c 91       	ld	r21, X
    5f82:	17 97       	sbiw	r26, 0x07	; 7
}
    5f84:	ca 01       	movw	r24, r20
    5f86:	08 95       	ret

00005f88 <FormData>:

// ~~~~~~~~~~~~~~~~~~~
static void
FormData(uint8_t MB_N)
{
    5f88:	cf 92       	push	r12
    5f8a:	df 92       	push	r13
    5f8c:	ef 92       	push	r14
    5f8e:	ff 92       	push	r15
    5f90:	0f 93       	push	r16
    5f92:	1f 93       	push	r17
    5f94:	cf 93       	push	r28
    5f96:	df 93       	push	r29
    5f98:	e8 2e       	mov	r14, r24
	uint16_t Qt;
	uint16_t *Reg;
	switch (MB_Frame[MB_N][1]) {
    5f9a:	c8 2f       	mov	r28, r24
    5f9c:	d0 e0       	ldi	r29, 0x00	; 0
    5f9e:	7c 2f       	mov	r23, r28
    5fa0:	66 27       	eor	r22, r22
    5fa2:	8b 01       	movw	r16, r22
    5fa4:	0d 5d       	subi	r16, 0xDD	; 221
    5fa6:	14 4f       	sbci	r17, 0xF4	; 244
    5fa8:	f8 01       	movw	r30, r16
    5faa:	81 81       	ldd	r24, Z+1	; 0x01
    5fac:	86 30       	cpi	r24, 0x06	; 6
    5fae:	09 f4       	brne	.+2      	; 0x5fb2 <FormData+0x2a>
    5fb0:	4b c0       	rjmp	.+150    	; 0x6048 <FormData+0xc0>
    5fb2:	87 30       	cpi	r24, 0x07	; 7
    5fb4:	88 f0       	brcs	.+34     	; 0x5fd8 <FormData+0x50>
    5fb6:	8f 30       	cpi	r24, 0x0F	; 15
    5fb8:	09 f4       	brne	.+2      	; 0x5fbc <FormData+0x34>
    5fba:	5b c0       	rjmp	.+182    	; 0x6072 <FormData+0xea>
    5fbc:	80 31       	cpi	r24, 0x10	; 16
    5fbe:	a1 f0       	breq	.+40     	; 0x5fe8 <FormData+0x60>
			MB_Frame[MB_N][7+j] = Reg[i]>>8;
			MB_Frame[MB_N][8+j] = Reg[i];
		}
		break;
	}
	SetCRC_MB(MB_N);
    5fc0:	8e 2d       	mov	r24, r14
    5fc2:	0e 94 43 2b 	call	0x5686	; 0x5686 <SetCRC_MB>
}
    5fc6:	df 91       	pop	r29
    5fc8:	cf 91       	pop	r28
    5fca:	1f 91       	pop	r17
    5fcc:	0f 91       	pop	r16
    5fce:	ff 90       	pop	r15
    5fd0:	ef 90       	pop	r14
    5fd2:	df 90       	pop	r13
    5fd4:	cf 90       	pop	r12
    5fd6:	08 95       	ret
static void
FormData(uint8_t MB_N)
{
	uint16_t Qt;
	uint16_t *Reg;
	switch (MB_Frame[MB_N][1]) {
    5fd8:	81 50       	subi	r24, 0x01	; 1
    5fda:	84 30       	cpi	r24, 0x04	; 4
    5fdc:	88 f7       	brcc	.-30     	; 0x5fc0 <FormData+0x38>
	case 1: case 2: case 3: case 4:
		MB_Frame_Sz[MB_N] = 8;
    5fde:	cb 5f       	subi	r28, 0xFB	; 251
    5fe0:	d8 4f       	sbci	r29, 0xF8	; 248
    5fe2:	88 e0       	ldi	r24, 0x08	; 8
    5fe4:	88 83       	st	Y, r24
    5fe6:	ec cf       	rjmp	.-40     	; 0x5fc0 <FormData+0x38>
			else
				MB_Frame[MB_N][Byte] &=~Bit;
		}
		break;
	case 0x10:
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = MB_Frame[MB_N][5]*2) + 9;
    5fe8:	55 e0       	ldi	r21, 0x05	; 5
    5fea:	c5 2e       	mov	r12, r21
    5fec:	d1 2c       	mov	r13, r1
    5fee:	c0 0e       	add	r12, r16
    5ff0:	d1 1e       	adc	r13, r17
    5ff2:	f8 01       	movw	r30, r16
    5ff4:	85 81       	ldd	r24, Z+5	; 0x05
    5ff6:	90 e0       	ldi	r25, 0x00	; 0
    5ff8:	88 0f       	add	r24, r24
    5ffa:	99 1f       	adc	r25, r25
    5ffc:	86 83       	std	Z+6, r24	; 0x06
    5ffe:	cb 5f       	subi	r28, 0xFB	; 251
    6000:	d8 4f       	sbci	r29, 0xF8	; 248
    6002:	87 5f       	subi	r24, 0xF7	; 247
    6004:	88 83       	st	Y, r24
		Reg = GetReg(MB_N);
    6006:	8e 2d       	mov	r24, r14
    6008:	0e 94 73 2f 	call	0x5ee6	; 0x5ee6 <GetReg>
    600c:	bc 01       	movw	r22, r24
		for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    600e:	f8 01       	movw	r30, r16
    6010:	85 81       	ldd	r24, Z+5	; 0x05
    6012:	88 23       	and	r24, r24
    6014:	a9 f2       	breq	.-86     	; 0x5fc0 <FormData+0x38>
    6016:	20 e0       	ldi	r18, 0x00	; 0
			uint8_t j = i*2;
			MB_Frame[MB_N][7+j] = Reg[i]>>8;
    6018:	a8 01       	movw	r20, r16
		}
		break;
	case 0x10:
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = MB_Frame[MB_N][5]*2) + 9;
		Reg = GetReg(MB_N);
		for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    601a:	e6 01       	movw	r28, r12
			uint8_t j = i*2;
			MB_Frame[MB_N][7+j] = Reg[i]>>8;
    601c:	82 2f       	mov	r24, r18
    601e:	90 e0       	ldi	r25, 0x00	; 0
    6020:	88 0f       	add	r24, r24
    6022:	99 1f       	adc	r25, r25
    6024:	fb 01       	movw	r30, r22
    6026:	e8 0f       	add	r30, r24
    6028:	f9 1f       	adc	r31, r25
    602a:	da 01       	movw	r26, r20
    602c:	a8 0f       	add	r26, r24
    602e:	b1 1d       	adc	r27, r1
    6030:	81 81       	ldd	r24, Z+1	; 0x01
    6032:	17 96       	adiw	r26, 0x07	; 7
    6034:	8c 93       	st	X, r24
    6036:	17 97       	sbiw	r26, 0x07	; 7
			MB_Frame[MB_N][8+j] = Reg[i];
    6038:	80 81       	ld	r24, Z
    603a:	18 96       	adiw	r26, 0x08	; 8
    603c:	8c 93       	st	X, r24
		}
		break;
	case 0x10:
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = MB_Frame[MB_N][5]*2) + 9;
		Reg = GetReg(MB_N);
		for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    603e:	2f 5f       	subi	r18, 0xFF	; 255
    6040:	88 81       	ld	r24, Y
    6042:	28 17       	cp	r18, r24
    6044:	58 f3       	brcs	.-42     	; 0x601c <FormData+0x94>
    6046:	bc cf       	rjmp	.-136    	; 0x5fc0 <FormData+0x38>
		MB_Frame_Sz[MB_N] = 8;
		MB_Frame[MB_N][5] = 0;
		break;
	*/
	case 6:
		MB_Frame_Sz[MB_N] = 8;
    6048:	fe 01       	movw	r30, r28
    604a:	eb 5f       	subi	r30, 0xFB	; 251
    604c:	f8 4f       	sbci	r31, 0xF8	; 248
    604e:	88 e0       	ldi	r24, 0x08	; 8
    6050:	80 83       	st	Z, r24
		Reg = GetReg(MB_N);
    6052:	8e 2d       	mov	r24, r14
    6054:	0e 94 73 2f 	call	0x5ee6	; 0x5ee6 <GetReg>
    6058:	dc 01       	movw	r26, r24
		MB_Frame[MB_N][4] = *Reg>>8;
    605a:	fc 2f       	mov	r31, r28
    605c:	ee 27       	eor	r30, r30
    605e:	e9 5d       	subi	r30, 0xD9	; 217
    6060:	f4 4f       	sbci	r31, 0xF4	; 244
    6062:	11 96       	adiw	r26, 0x01	; 1
    6064:	8c 91       	ld	r24, X
    6066:	11 97       	sbiw	r26, 0x01	; 1
    6068:	80 83       	st	Z, r24
		MB_Frame[MB_N][5] = *Reg;
    606a:	8c 91       	ld	r24, X
    606c:	f8 01       	movw	r30, r16
    606e:	85 83       	std	Z+5, r24	; 0x05
    6070:	a7 cf       	rjmp	.-178    	; 0x5fc0 <FormData+0x38>
    6072:	fc 2f       	mov	r31, r28
    6074:	ee 27       	eor	r30, r30
    6076:	e9 5d       	subi	r30, 0xD9	; 217
    6078:	f4 4f       	sbci	r31, 0xF4	; 244
    607a:	90 81       	ld	r25, Z
    607c:	80 e0       	ldi	r24, 0x00	; 0
    607e:	f8 01       	movw	r30, r16
    6080:	25 81       	ldd	r18, Z+5	; 0x05
    6082:	02 2f       	mov	r16, r18
    6084:	10 e0       	ldi	r17, 0x00	; 0
    6086:	08 2b       	or	r16, r24
    6088:	19 2b       	or	r17, r25
		break;
	case 0x0F:
		Qt = MB_FrameReg(MB_N, 4);
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = Qt/8 + (Qt%8>0)) + 9;
    608a:	98 01       	movw	r18, r16
    608c:	36 95       	lsr	r19
    608e:	27 95       	ror	r18
    6090:	36 95       	lsr	r19
    6092:	27 95       	ror	r18
    6094:	36 95       	lsr	r19
    6096:	27 95       	ror	r18
    6098:	40 e0       	ldi	r20, 0x00	; 0
    609a:	c8 01       	movw	r24, r16
    609c:	87 70       	andi	r24, 0x07	; 7
    609e:	90 70       	andi	r25, 0x00	; 0
    60a0:	89 2b       	or	r24, r25
    60a2:	09 f0       	breq	.+2      	; 0x60a6 <FormData+0x11e>
    60a4:	8b c0       	rjmp	.+278    	; 0x61bc <FormData+0x234>
    60a6:	84 2f       	mov	r24, r20
    60a8:	82 0f       	add	r24, r18
    60aa:	fb 01       	movw	r30, r22
    60ac:	ed 5d       	subi	r30, 0xDD	; 221
    60ae:	f4 4f       	sbci	r31, 0xF4	; 244
    60b0:	86 83       	std	Z+6, r24	; 0x06
    60b2:	de 01       	movw	r26, r28
    60b4:	ab 5f       	subi	r26, 0xFB	; 251
    60b6:	b8 4f       	sbci	r27, 0xF8	; 248
    60b8:	87 5f       	subi	r24, 0xF7	; 247
    60ba:	8c 93       	st	X, r24
		MB_Frame[MB_N][7+Qt/8] = 0;
    60bc:	e2 0f       	add	r30, r18
    60be:	f3 1f       	adc	r31, r19
    60c0:	17 82       	std	Z+7, r1	; 0x07
		uint8_t *Discr;
		uint8_t Pin;
		if (MB_SingleState[MB_N]!=MB_SingleExec) {
    60c2:	fe 01       	movw	r30, r28
    60c4:	e3 55       	subi	r30, 0x53	; 83
    60c6:	f9 4f       	sbci	r31, 0xF9	; 249
    60c8:	80 81       	ld	r24, Z
    60ca:	82 30       	cpi	r24, 0x02	; 2
    60cc:	09 f4       	brne	.+2      	; 0x60d0 <FormData+0x148>
    60ce:	78 c0       	rjmp	.+240    	; 0x61c0 <FormData+0x238>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    60d0:	fe 01       	movw	r30, r28
    60d2:	e2 95       	swap	r30
    60d4:	f2 95       	swap	r31
    60d6:	f0 7f       	andi	r31, 0xF0	; 240
    60d8:	fe 27       	eor	r31, r30
    60da:	e0 7f       	andi	r30, 0xF0	; 240
    60dc:	fe 27       	eor	r31, r30
    60de:	e0 5d       	subi	r30, 0xD0	; 208
    60e0:	fc 4f       	sbci	r31, 0xFC	; 252
			Discr = prp(&Modbus_Map[MB_N].Coil);
    60e2:	a5 91       	lpm	r26, Z+
    60e4:	b4 91       	lpm	r27, Z+
    60e6:	83 e0       	ldi	r24, 0x03	; 3
    60e8:	e8 9e       	mul	r14, r24
    60ea:	f0 01       	movw	r30, r0
    60ec:	11 24       	eor	r1, r1
    60ee:	e5 5b       	subi	r30, 0xB5	; 181
    60f0:	f6 4d       	sbci	r31, 0xD6	; 214
    60f2:	25 91       	lpm	r18, Z+
    60f4:	34 91       	lpm	r19, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    60f6:	fe 01       	movw	r30, r28
    60f8:	ee 5a       	subi	r30, 0xAE	; 174
    60fa:	f9 4f       	sbci	r31, 0xF9	; 249
    60fc:	80 81       	ld	r24, Z
    60fe:	90 e0       	ldi	r25, 0x00	; 0
    6100:	88 0f       	add	r24, r24
    6102:	99 1f       	adc	r25, r25
    6104:	88 0f       	add	r24, r24
    6106:	99 1f       	adc	r25, r25
    6108:	28 0f       	add	r18, r24
    610a:	39 1f       	adc	r19, r25
    610c:	2f 5f       	subi	r18, 0xFF	; 255
    610e:	3f 4f       	sbci	r19, 0xFF	; 255
    6110:	f9 01       	movw	r30, r18
    6112:	45 91       	lpm	r20, Z+
    6114:	54 91       	lpm	r21, Z+
    6116:	cd 5a       	subi	r28, 0xAD	; 173
    6118:	d9 4f       	sbci	r29, 0xF9	; 249
    611a:	88 81       	ld	r24, Y
    611c:	27 e0       	ldi	r18, 0x07	; 7
    611e:	82 9f       	mul	r24, r18
    6120:	c0 01       	movw	r24, r0
    6122:	11 24       	eor	r1, r1
    6124:	48 0f       	add	r20, r24
    6126:	59 1f       	adc	r21, r25
    6128:	4b 5f       	subi	r20, 0xFB	; 251
    612a:	5f 4f       	sbci	r21, 0xFF	; 255
    612c:	fa 01       	movw	r30, r20
    612e:	85 91       	lpm	r24, Z+
    6130:	94 91       	lpm	r25, Z+
			Pin = prw(&GetQuery(MB_N)->AllocAddr);
    6132:	f8 2e       	mov	r15, r24
		}
		else {
			Discr = MB_SingleQuery[MB_N].Buf;
			Pin = 0;
		}
		for (uint8_t i=0; i<Qt; i++) {
    6134:	01 15       	cp	r16, r1
    6136:	11 05       	cpc	r17, r1
    6138:	09 f4       	brne	.+2      	; 0x613c <FormData+0x1b4>
    613a:	42 cf       	rjmp	.-380    	; 0x5fc0 <FormData+0x38>
    613c:	50 e0       	ldi	r21, 0x00	; 0
    613e:	80 e0       	ldi	r24, 0x00	; 0
    6140:	90 e0       	ldi	r25, 0x00	; 0
			uint8_t j = Pin+i;
			uint8_t Byte=7+i/8, Bit=1<<i%8;
    6142:	c1 e0       	ldi	r28, 0x01	; 1
    6144:	d0 e0       	ldi	r29, 0x00	; 0
    6146:	0f c0       	rjmp	.+30     	; 0x6166 <FormData+0x1de>
			if (Discr[j/8] &(1<<j%8))
				MB_Frame[MB_N][Byte] |=Bit;
    6148:	fb 01       	movw	r30, r22
    614a:	e3 0f       	add	r30, r19
    614c:	f1 1d       	adc	r31, r1
    614e:	ed 5d       	subi	r30, 0xDD	; 221
    6150:	f4 4f       	sbci	r31, 0xF4	; 244
    6152:	80 81       	ld	r24, Z
    6154:	84 2b       	or	r24, r20
    6156:	80 83       	st	Z, r24
		}
		else {
			Discr = MB_SingleQuery[MB_N].Buf;
			Pin = 0;
		}
		for (uint8_t i=0; i<Qt; i++) {
    6158:	5f 5f       	subi	r21, 0xFF	; 255
    615a:	85 2f       	mov	r24, r21
    615c:	90 e0       	ldi	r25, 0x00	; 0
    615e:	80 17       	cp	r24, r16
    6160:	91 07       	cpc	r25, r17
    6162:	08 f0       	brcs	.+2      	; 0x6166 <FormData+0x1de>
    6164:	2d cf       	rjmp	.-422    	; 0x5fc0 <FormData+0x38>
    6166:	25 2f       	mov	r18, r21
    6168:	2f 0d       	add	r18, r15
			uint8_t j = Pin+i;
			uint8_t Byte=7+i/8, Bit=1<<i%8;
    616a:	35 2f       	mov	r19, r21
    616c:	36 95       	lsr	r19
    616e:	36 95       	lsr	r19
    6170:	36 95       	lsr	r19
    6172:	39 5f       	subi	r19, 0xF9	; 249
    6174:	87 70       	andi	r24, 0x07	; 7
    6176:	90 70       	andi	r25, 0x00	; 0
    6178:	fe 01       	movw	r30, r28
    617a:	02 c0       	rjmp	.+4      	; 0x6180 <FormData+0x1f8>
    617c:	ee 0f       	add	r30, r30
    617e:	ff 1f       	adc	r31, r31
    6180:	8a 95       	dec	r24
    6182:	e2 f7       	brpl	.-8      	; 0x617c <FormData+0x1f4>
    6184:	4e 2f       	mov	r20, r30
			if (Discr[j/8] &(1<<j%8))
    6186:	82 2f       	mov	r24, r18
    6188:	86 95       	lsr	r24
    618a:	86 95       	lsr	r24
    618c:	86 95       	lsr	r24
    618e:	fd 01       	movw	r30, r26
    6190:	e8 0f       	add	r30, r24
    6192:	f1 1d       	adc	r31, r1
    6194:	80 81       	ld	r24, Z
    6196:	90 e0       	ldi	r25, 0x00	; 0
    6198:	27 70       	andi	r18, 0x07	; 7
    619a:	02 c0       	rjmp	.+4      	; 0x61a0 <FormData+0x218>
    619c:	95 95       	asr	r25
    619e:	87 95       	ror	r24
    61a0:	2a 95       	dec	r18
    61a2:	e2 f7       	brpl	.-8      	; 0x619c <FormData+0x214>
    61a4:	80 fd       	sbrc	r24, 0
    61a6:	d0 cf       	rjmp	.-96     	; 0x6148 <FormData+0x1c0>
				MB_Frame[MB_N][Byte] |=Bit;
			else
				MB_Frame[MB_N][Byte] &=~Bit;
    61a8:	fb 01       	movw	r30, r22
    61aa:	e3 0f       	add	r30, r19
    61ac:	f1 1d       	adc	r31, r1
    61ae:	ed 5d       	subi	r30, 0xDD	; 221
    61b0:	f4 4f       	sbci	r31, 0xF4	; 244
    61b2:	40 95       	com	r20
    61b4:	80 81       	ld	r24, Z
    61b6:	48 23       	and	r20, r24
    61b8:	40 83       	st	Z, r20
    61ba:	ce cf       	rjmp	.-100    	; 0x6158 <FormData+0x1d0>
		MB_Frame[MB_N][4] = *Reg>>8;
		MB_Frame[MB_N][5] = *Reg;
		break;
	case 0x0F:
		Qt = MB_FrameReg(MB_N, 4);
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = Qt/8 + (Qt%8>0)) + 9;
    61bc:	41 e0       	ldi	r20, 0x01	; 1
    61be:	73 cf       	rjmp	.-282    	; 0x60a6 <FormData+0x11e>
		if (MB_SingleState[MB_N]!=MB_SingleExec) {
			Discr = prp(&Modbus_Map[MB_N].Coil);
			Pin = prw(&GetQuery(MB_N)->AllocAddr);
		}
		else {
			Discr = MB_SingleQuery[MB_N].Buf;
    61c0:	cc 0f       	add	r28, r28
    61c2:	dd 1f       	adc	r29, r29
    61c4:	cc 0f       	add	r28, r28
    61c6:	dd 1f       	adc	r29, r29
    61c8:	cc 0f       	add	r28, r28
    61ca:	dd 1f       	adc	r29, r29
    61cc:	c8 52       	subi	r28, 0x28	; 40
    61ce:	db 4f       	sbci	r29, 0xFB	; 251
    61d0:	ae 81       	ldd	r26, Y+6	; 0x06
    61d2:	bf 81       	ldd	r27, Y+7	; 0x07
    61d4:	ff 24       	eor	r15, r15
    61d6:	ae cf       	rjmp	.-164    	; 0x6134 <FormData+0x1ac>

000061d8 <FormQuery>:
}

// ~~~~~~~~~~~~~~~~~~~~
static void
FormQuery(uint8_t MB_N)
{
    61d8:	cf 93       	push	r28
    61da:	df 93       	push	r29

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    61dc:	93 e0       	ldi	r25, 0x03	; 3
    61de:	89 9f       	mul	r24, r25
    61e0:	f0 01       	movw	r30, r0
    61e2:	11 24       	eor	r1, r1
    61e4:	e5 5b       	subi	r30, 0xB5	; 181
    61e6:	f6 4d       	sbci	r31, 0xD6	; 214
    61e8:	65 91       	lpm	r22, Z+
    61ea:	74 91       	lpm	r23, Z+

// ~~~~~~~~~~~~~~~~~~~
static MB_Slave*
GetSlave(uint8_t MB_N)
{
	return (MB_Slave*)prp(&(MB_Master_List+MB_N)->SlaveList)+CurrSlave[MB_N];
    61ec:	48 2f       	mov	r20, r24
    61ee:	50 e0       	ldi	r21, 0x00	; 0
    61f0:	fa 01       	movw	r30, r20
    61f2:	ee 5a       	subi	r30, 0xAE	; 174
    61f4:	f9 4f       	sbci	r31, 0xF9	; 249
    61f6:	20 81       	ld	r18, Z
    61f8:	30 e0       	ldi	r19, 0x00	; 0
    61fa:	22 0f       	add	r18, r18
    61fc:	33 1f       	adc	r19, r19
    61fe:	22 0f       	add	r18, r18
    6200:	33 1f       	adc	r19, r19
    6202:	62 0f       	add	r22, r18
    6204:	73 1f       	adc	r23, r19
    6206:	fb 01       	movw	r30, r22
    6208:	31 96       	adiw	r30, 0x01	; 1
    620a:	c5 91       	lpm	r28, Z+
    620c:	d4 91       	lpm	r29, Z+
// ~~~~~~~~~~~~~~~~~~~~
static void
FormQuery(uint8_t MB_N)
{
	MB_Slave *Slave = GetSlave(MB_N);
	MB_Query *Query = (MB_Query*)prp(&Slave->QueryList)+CurrQuery[MB_N];
    620e:	fa 01       	movw	r30, r20
    6210:	ed 5a       	subi	r30, 0xAD	; 173
    6212:	f9 4f       	sbci	r31, 0xF9	; 249
    6214:	20 81       	ld	r18, Z
    6216:	97 e0       	ldi	r25, 0x07	; 7
    6218:	29 9f       	mul	r18, r25
    621a:	90 01       	movw	r18, r0
    621c:	11 24       	eor	r1, r1
    621e:	c2 0f       	add	r28, r18
    6220:	d3 1f       	adc	r29, r19

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    6222:	fb 01       	movw	r30, r22
    6224:	94 91       	lpm	r25, Z+

	MB_Frame[MB_N][0] = prb(&Slave->Addr);
    6226:	23 e2       	ldi	r18, 0x23	; 35
    6228:	3b e0       	ldi	r19, 0x0B	; 11
    622a:	b4 2f       	mov	r27, r20
    622c:	aa 27       	eor	r26, r26
    622e:	a2 0f       	add	r26, r18
    6230:	b3 1f       	adc	r27, r19
    6232:	9c 93       	st	X, r25
    6234:	fe 01       	movw	r30, r28
    6236:	94 91       	lpm	r25, Z+
	MB_Frame[MB_N][1] = prb(&Query->Func);
    6238:	11 96       	adiw	r26, 0x01	; 1
    623a:	9c 93       	st	X, r25
    623c:	11 97       	sbiw	r26, 0x01	; 1
	MB_Frame[MB_N][2] = prb((uint8_t*)&Query->StartAddr+1);
    623e:	be 01       	movw	r22, r28
    6240:	6f 5f       	subi	r22, 0xFF	; 255
    6242:	7f 4f       	sbci	r23, 0xFF	; 255
    6244:	6f 5f       	subi	r22, 0xFF	; 255
    6246:	7f 4f       	sbci	r23, 0xFF	; 255
    6248:	fb 01       	movw	r30, r22
    624a:	94 91       	lpm	r25, Z+
    624c:	61 50       	subi	r22, 0x01	; 1
    624e:	70 40       	sbci	r23, 0x00	; 0
    6250:	fd 01       	movw	r30, r26
    6252:	92 83       	std	Z+2, r25	; 0x02
    6254:	fb 01       	movw	r30, r22
    6256:	94 91       	lpm	r25, Z+
	MB_Frame[MB_N][3] = prb((uint8_t*)&Query->StartAddr);
    6258:	13 96       	adiw	r26, 0x03	; 3
    625a:	9c 93       	st	X, r25
    625c:	13 97       	sbiw	r26, 0x03	; 3
    625e:	24 96       	adiw	r28, 0x04	; 4
    6260:	fe 01       	movw	r30, r28
    6262:	94 91       	lpm	r25, Z+
	MB_Frame[MB_N][4] = prb((uint8_t*)&Query->Qt+1);
    6264:	fd 01       	movw	r30, r26
    6266:	94 83       	std	Z+4, r25	; 0x04
    6268:	21 97       	sbiw	r28, 0x01	; 1
    626a:	fe 01       	movw	r30, r28
    626c:	94 91       	lpm	r25, Z+
	MB_Frame[MB_N][5] = prb((uint8_t*)&Query->Qt);
    626e:	15 96       	adiw	r26, 0x05	; 5
    6270:	9c 93       	st	X, r25

	FormData(MB_N);
    6272:	0e 94 c4 2f 	call	0x5f88	; 0x5f88 <FormData>
}
    6276:	df 91       	pop	r29
    6278:	cf 91       	pop	r28
    627a:	08 95       	ret

0000627c <FormSingle>:

// ~~~~~~~~~~~~~~~~~~~~~
static void
FormSingle(uint8_t MB_N)
{
    627c:	1f 93       	push	r17
    627e:	cf 93       	push	r28
    6280:	df 93       	push	r29
	MB_Frame[MB_N][0] = MB_SingleQuery[MB_N].Addr;
    6282:	a8 2f       	mov	r26, r24
    6284:	b0 e0       	ldi	r27, 0x00	; 0
    6286:	63 e2       	ldi	r22, 0x23	; 35
    6288:	7b e0       	ldi	r23, 0x0B	; 11
    628a:	5a 2f       	mov	r21, r26
    628c:	44 27       	eor	r20, r20
    628e:	46 0f       	add	r20, r22
    6290:	57 1f       	adc	r21, r23
    6292:	28 ed       	ldi	r18, 0xD8	; 216
    6294:	34 e0       	ldi	r19, 0x04	; 4
    6296:	fd 01       	movw	r30, r26
    6298:	ee 0f       	add	r30, r30
    629a:	ff 1f       	adc	r31, r31
    629c:	ee 0f       	add	r30, r30
    629e:	ff 1f       	adc	r31, r31
    62a0:	ee 0f       	add	r30, r30
    62a2:	ff 1f       	adc	r31, r31
    62a4:	e2 0f       	add	r30, r18
    62a6:	f3 1f       	adc	r31, r19
    62a8:	90 81       	ld	r25, Z
    62aa:	ea 01       	movw	r28, r20
    62ac:	98 83       	st	Y, r25
	MB_Frame[MB_N][1] = MB_SingleQuery[MB_N].Func;
    62ae:	91 81       	ldd	r25, Z+1	; 0x01
    62b0:	99 83       	std	Y+1, r25	; 0x01
	MB_Frame[MB_N][2] = MB_SingleQuery[MB_N].StartAddr>>8;
    62b2:	fd 01       	movw	r30, r26
    62b4:	ee 0f       	add	r30, r30
    62b6:	ff 1f       	adc	r31, r31
    62b8:	ee 0f       	add	r30, r30
    62ba:	ff 1f       	adc	r31, r31
    62bc:	ee 0f       	add	r30, r30
    62be:	ff 1f       	adc	r31, r31
    62c0:	32 96       	adiw	r30, 0x02	; 2
    62c2:	e2 0f       	add	r30, r18
    62c4:	f3 1f       	adc	r31, r19
    62c6:	10 81       	ld	r17, Z
    62c8:	91 81       	ldd	r25, Z+1	; 0x01
    62ca:	fa 01       	movw	r30, r20
    62cc:	92 83       	std	Z+2, r25	; 0x02
	MB_Frame[MB_N][3] = MB_SingleQuery[MB_N].StartAddr;
    62ce:	1b 83       	std	Y+3, r17	; 0x03
	MB_Frame[MB_N][4] = MB_SingleQuery[MB_N].Qt>>8;
    62d0:	fd 01       	movw	r30, r26
    62d2:	ee 0f       	add	r30, r30
    62d4:	ff 1f       	adc	r31, r31
    62d6:	ee 0f       	add	r30, r30
    62d8:	ff 1f       	adc	r31, r31
    62da:	ee 0f       	add	r30, r30
    62dc:	ff 1f       	adc	r31, r31
    62de:	34 96       	adiw	r30, 0x04	; 4
    62e0:	e2 0f       	add	r30, r18
    62e2:	f3 1f       	adc	r31, r19
    62e4:	10 81       	ld	r17, Z
    62e6:	91 81       	ldd	r25, Z+1	; 0x01
    62e8:	9c 83       	std	Y+4, r25	; 0x04
	MB_Frame[MB_N][5] = MB_SingleQuery[MB_N].Qt;
    62ea:	1d 83       	std	Y+5, r17	; 0x05
	
	MB_SingleState[MB_N] = MB_SingleExec;
    62ec:	a3 55       	subi	r26, 0x53	; 83
    62ee:	b9 4f       	sbci	r27, 0xF9	; 249
    62f0:	92 e0       	ldi	r25, 0x02	; 2
    62f2:	9c 93       	st	X, r25
	FormData(MB_N);
    62f4:	0e 94 c4 2f 	call	0x5f88	; 0x5f88 <FormData>
}
    62f8:	df 91       	pop	r29
    62fa:	cf 91       	pop	r28
    62fc:	1f 91       	pop	r17
    62fe:	08 95       	ret

00006300 <NextSlave>:

// ~~~~~~~~~~~~~~~~~~~~
static uint8_t
NextSlave(uint8_t MB_N)
{
    6300:	2f 92       	push	r2
    6302:	3f 92       	push	r3
    6304:	4f 92       	push	r4
    6306:	5f 92       	push	r5
    6308:	6f 92       	push	r6
    630a:	7f 92       	push	r7
    630c:	8f 92       	push	r8
    630e:	9f 92       	push	r9
    6310:	af 92       	push	r10
    6312:	bf 92       	push	r11
    6314:	cf 92       	push	r12
    6316:	df 92       	push	r13
    6318:	ef 92       	push	r14
    631a:	ff 92       	push	r15
    631c:	0f 93       	push	r16
    631e:	1f 93       	push	r17
    6320:	df 93       	push	r29
    6322:	cf 93       	push	r28
    6324:	00 d0       	rcall	.+0      	; 0x6326 <NextSlave+0x26>
    6326:	00 d0       	rcall	.+0      	; 0x6328 <NextSlave+0x28>
    6328:	cd b7       	in	r28, 0x3d	; 61
    632a:	de b7       	in	r29, 0x3e	; 62
    632c:	68 2e       	mov	r6, r24
    632e:	e3 e0       	ldi	r30, 0x03	; 3
    6330:	8e 9f       	mul	r24, r30
    6332:	f0 01       	movw	r30, r0
    6334:	11 24       	eor	r1, r1
    6336:	e3 5b       	subi	r30, 0xB3	; 179
    6338:	f6 4d       	sbci	r31, 0xD6	; 214
    633a:	04 91       	lpm	r16, Z+
    633c:	c8 2e       	mov	r12, r24
    633e:	dd 24       	eor	r13, r13
    6340:	a6 01       	movw	r20, r12
    6342:	4e 5a       	subi	r20, 0xAE	; 174
    6344:	59 4f       	sbci	r21, 0xF9	; 249
    6346:	5e 83       	std	Y+6, r21	; 0x06
    6348:	4d 83       	std	Y+5, r20	; 0x05
    634a:	fa 01       	movw	r30, r20
    634c:	20 81       	ld	r18, Z
    634e:	16 01       	movw	r2, r12
    6350:	22 0c       	add	r2, r2
    6352:	33 1c       	adc	r3, r3
    6354:	22 0c       	add	r2, r2
    6356:	33 1c       	adc	r3, r3
    6358:	f1 01       	movw	r30, r2
    635a:	ee 51       	subi	r30, 0x1E	; 30
    635c:	fb 4f       	sbci	r31, 0xFB	; 251
    635e:	80 80       	ld	r8, Z
    6360:	91 80       	ldd	r9, Z+1	; 0x01
    6362:	a2 80       	ldd	r10, Z+2	; 0x02
    6364:	b3 80       	ldd	r11, Z+3	; 0x03
	do
		if (++CurrSlave[MB_N]==SlaveQt) {
			CurrSlave[MB_N] = 0;
			Over = 1;

			if ((MB_Master_Cycle[MB_N]=0xFFFF-GetTimer16(TD_MB_Cycle+MB_N))>MB_Master_MaxCycle[MB_N])
    6366:	70 90 e6 04 	lds	r7, 0x04E6
    636a:	f2 e0       	ldi	r31, 0x02	; 2
    636c:	7f 0e       	add	r7, r31
    636e:	47 2d       	mov	r20, r7
    6370:	48 0f       	add	r20, r24
    6372:	4a 83       	std	Y+2, r20	; 0x02
    6374:	5e ef       	ldi	r21, 0xFE	; 254
    6376:	75 0e       	add	r7, r21
// ~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
GetTimer16(uint8_t TimerN)
{
	IntOff();
	uint16_t Time = Timer16[TimerN];
    6378:	e4 2e       	mov	r14, r20
    637a:	ff 24       	eor	r15, r15
    637c:	19 82       	std	Y+1, r1	; 0x01
    637e:	10 e0       	ldi	r17, 0x00	; 0
    6380:	ee 0c       	add	r14, r14
    6382:	ff 1c       	adc	r15, r15
    6384:	8d e4       	ldi	r24, 0x4D	; 77
    6386:	93 e0       	ldi	r25, 0x03	; 3
    6388:	e8 0e       	add	r14, r24
    638a:	f9 1e       	adc	r15, r25
    638c:	c6 01       	movw	r24, r12
    638e:	88 0f       	add	r24, r24
    6390:	99 1f       	adc	r25, r25
    6392:	fc 01       	movw	r30, r24
    6394:	ee 58       	subi	r30, 0x8E	; 142
    6396:	f8 4f       	sbci	r31, 0xF8	; 248
    6398:	fc 83       	std	Y+4, r31	; 0x04
    639a:	eb 83       	std	Y+3, r30	; 0x03
    639c:	fc eb       	ldi	r31, 0xBC	; 188
    639e:	4f 2e       	mov	r4, r31
    63a0:	f6 e0       	ldi	r31, 0x06	; 6
    63a2:	5f 2e       	mov	r5, r31
    63a4:	48 0e       	add	r4, r24
    63a6:	59 1e       	adc	r5, r25
    63a8:	14 c0       	rjmp	.+40     	; 0x63d2 <NextSlave+0xd2>
				MB_Master_MaxCycle[MB_N] = MB_Master_Cycle[MB_N];
			StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
		}
	while (SlaveSkip[MB_N] &((uint32_t)1<<CurrSlave[MB_N]) && ++i<SlaveQt);
    63aa:	ed 81       	ldd	r30, Y+5	; 0x05
    63ac:	fe 81       	ldd	r31, Y+6	; 0x06
    63ae:	20 81       	ld	r18, Z
    63b0:	d5 01       	movw	r26, r10
    63b2:	c4 01       	movw	r24, r8
    63b4:	02 2e       	mov	r0, r18
    63b6:	04 c0       	rjmp	.+8      	; 0x63c0 <NextSlave+0xc0>
    63b8:	b6 95       	lsr	r27
    63ba:	a7 95       	ror	r26
    63bc:	97 95       	ror	r25
    63be:	87 95       	ror	r24
    63c0:	0a 94       	dec	r0
    63c2:	d2 f7       	brpl	.-12     	; 0x63b8 <NextSlave+0xb8>
    63c4:	81 70       	andi	r24, 0x01	; 1
    63c6:	90 70       	andi	r25, 0x00	; 0
    63c8:	88 23       	and	r24, r24
    63ca:	61 f1       	breq	.+88     	; 0x6424 <NextSlave+0x124>
    63cc:	1f 5f       	subi	r17, 0xFF	; 255
    63ce:	10 17       	cp	r17, r16
    63d0:	48 f5       	brcc	.+82     	; 0x6424 <NextSlave+0x124>
{
	uint8_t Over = 0;
	uint8_t i = 0;
	uint8_t SlaveQt = prb(&(MB_Master_List+MB_N)->SlaveQt);
	do
		if (++CurrSlave[MB_N]==SlaveQt) {
    63d2:	82 2f       	mov	r24, r18
    63d4:	8f 5f       	subi	r24, 0xFF	; 255
    63d6:	ed 81       	ldd	r30, Y+5	; 0x05
    63d8:	fe 81       	ldd	r31, Y+6	; 0x06
    63da:	80 83       	st	Z, r24
    63dc:	80 17       	cp	r24, r16
    63de:	29 f7       	brne	.-54     	; 0x63aa <NextSlave+0xaa>
			CurrSlave[MB_N] = 0;
    63e0:	10 82       	st	Z, r1

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    63e2:	8f b7       	in	r24, 0x3f	; 63
    63e4:	80 78       	andi	r24, 0x80	; 128
    63e6:	80 93 ec 02 	sts	0x02EC, r24
	cli();
    63ea:	f8 94       	cli
    63ec:	f7 01       	movw	r30, r14
    63ee:	20 81       	ld	r18, Z
    63f0:	31 81       	ldd	r19, Z+1	; 0x01

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    63f2:	88 23       	and	r24, r24
    63f4:	09 f0       	breq	.+2      	; 0x63f8 <NextSlave+0xf8>
		sei();
    63f6:	78 94       	sei
			Over = 1;

			if ((MB_Master_Cycle[MB_N]=0xFFFF-GetTimer16(TD_MB_Cycle+MB_N))>MB_Master_MaxCycle[MB_N])
    63f8:	20 95       	com	r18
    63fa:	30 95       	com	r19
    63fc:	eb 81       	ldd	r30, Y+3	; 0x03
    63fe:	fc 81       	ldd	r31, Y+4	; 0x04
    6400:	31 83       	std	Z+1, r19	; 0x01
    6402:	20 83       	st	Z, r18
    6404:	f2 01       	movw	r30, r4
    6406:	80 81       	ld	r24, Z
    6408:	91 81       	ldd	r25, Z+1	; 0x01
    640a:	82 17       	cp	r24, r18
    640c:	93 07       	cpc	r25, r19
    640e:	10 f4       	brcc	.+4      	; 0x6414 <NextSlave+0x114>
				MB_Master_MaxCycle[MB_N] = MB_Master_Cycle[MB_N];
    6410:	31 83       	std	Z+1, r19	; 0x01
    6412:	20 83       	st	Z, r18
			StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
    6414:	8a 81       	ldd	r24, Y+2	; 0x02
    6416:	6f ef       	ldi	r22, 0xFF	; 255
    6418:	7f ef       	ldi	r23, 0xFF	; 255
    641a:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
    641e:	f1 e0       	ldi	r31, 0x01	; 1
    6420:	f9 83       	std	Y+1, r31	; 0x01
    6422:	c3 cf       	rjmp	.-122    	; 0x63aa <NextSlave+0xaa>
		}
	while (SlaveSkip[MB_N] &((uint32_t)1<<CurrSlave[MB_N]) && ++i<SlaveQt);
	if (i==SlaveQt) {
    6424:	10 17       	cp	r17, r16
    6426:	01 f1       	breq	.+64     	; 0x6468 <NextSlave+0x168>
		SlavesOn(MB_N);
		if (++CurrSlave[MB_N]==SlaveQt)
			CurrSlave[MB_N] = 0;
	}
	CurrQuery[MB_N] = 0;
    6428:	43 e5       	ldi	r20, 0x53	; 83
    642a:	56 e0       	ldi	r21, 0x06	; 6
    642c:	c4 0e       	add	r12, r20
    642e:	d5 1e       	adc	r13, r21
    6430:	f6 01       	movw	r30, r12
    6432:	10 82       	st	Z, r1
	return Over;
}
    6434:	89 81       	ldd	r24, Y+1	; 0x01
    6436:	26 96       	adiw	r28, 0x06	; 6
    6438:	0f b6       	in	r0, 0x3f	; 63
    643a:	f8 94       	cli
    643c:	de bf       	out	0x3e, r29	; 62
    643e:	0f be       	out	0x3f, r0	; 63
    6440:	cd bf       	out	0x3d, r28	; 61
    6442:	cf 91       	pop	r28
    6444:	df 91       	pop	r29
    6446:	1f 91       	pop	r17
    6448:	0f 91       	pop	r16
    644a:	ff 90       	pop	r15
    644c:	ef 90       	pop	r14
    644e:	df 90       	pop	r13
    6450:	cf 90       	pop	r12
    6452:	bf 90       	pop	r11
    6454:	af 90       	pop	r10
    6456:	9f 90       	pop	r9
    6458:	8f 90       	pop	r8
    645a:	7f 90       	pop	r7
    645c:	6f 90       	pop	r6
    645e:	5f 90       	pop	r5
    6460:	4f 90       	pop	r4
    6462:	3f 90       	pop	r3
    6464:	2f 90       	pop	r2
    6466:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~
static void
SlavesOn(uint8_t MB_N)
{
	SlaveSkip[MB_N] = 0;
    6468:	42 ee       	ldi	r20, 0xE2	; 226
    646a:	54 e0       	ldi	r21, 0x04	; 4
    646c:	24 0e       	add	r2, r20
    646e:	35 1e       	adc	r3, r21
    6470:	f1 01       	movw	r30, r2
    6472:	10 82       	st	Z, r1
    6474:	11 82       	std	Z+1, r1	; 0x01
    6476:	12 82       	std	Z+2, r1	; 0x02
    6478:	13 82       	std	Z+3, r1	; 0x03
	StartTimer16(TD_MB_SlaveOff+MB_N, 100*MB_M_TimeOff[MB_N]);
    647a:	73 94       	inc	r7
    647c:	f6 01       	movw	r30, r12
    647e:	e3 52       	subi	r30, 0x23	; 35
    6480:	fa 4f       	sbci	r31, 0xFA	; 250
    6482:	60 81       	ld	r22, Z
    6484:	84 e6       	ldi	r24, 0x64	; 100
    6486:	68 9f       	mul	r22, r24
    6488:	b0 01       	movw	r22, r0
    648a:	11 24       	eor	r1, r1
    648c:	87 2d       	mov	r24, r7
    648e:	86 0d       	add	r24, r6
    6490:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
			StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
		}
	while (SlaveSkip[MB_N] &((uint32_t)1<<CurrSlave[MB_N]) && ++i<SlaveQt);
	if (i==SlaveQt) {
		SlavesOn(MB_N);
		if (++CurrSlave[MB_N]==SlaveQt)
    6494:	ed 81       	ldd	r30, Y+5	; 0x05
    6496:	fe 81       	ldd	r31, Y+6	; 0x06
    6498:	80 81       	ld	r24, Z
    649a:	8f 5f       	subi	r24, 0xFF	; 255
    649c:	80 83       	st	Z, r24
    649e:	18 17       	cp	r17, r24
    64a0:	19 f6       	brne	.-122    	; 0x6428 <NextSlave+0x128>
			CurrSlave[MB_N] = 0;
    64a2:	10 82       	st	Z, r1
    64a4:	c1 cf       	rjmp	.-126    	; 0x6428 <NextSlave+0x128>

000064a6 <FailSlave>:
}

// ~~~~~~~~~~~~~~~~~~~~
static uint8_t
FailSlave(uint8_t MB_N)
{
    64a6:	ef 92       	push	r14
    64a8:	ff 92       	push	r15
    64aa:	1f 93       	push	r17
    64ac:	cf 93       	push	r28
    64ae:	df 93       	push	r29
    64b0:	18 2f       	mov	r17, r24
	uint8_t Over = 0;
	if (MB_SingleState[MB_N]==MB_SingleExec)
    64b2:	68 2f       	mov	r22, r24
    64b4:	70 e0       	ldi	r23, 0x00	; 0
    64b6:	fb 01       	movw	r30, r22
    64b8:	e3 55       	subi	r30, 0x53	; 83
    64ba:	f9 4f       	sbci	r31, 0xF9	; 249
    64bc:	80 81       	ld	r24, Z
    64be:	82 30       	cpi	r24, 0x02	; 2
    64c0:	19 f1       	breq	.+70     	; 0x6508 <FailSlave+0x62>
		MB_SingleState[MB_N] = MB_SingleIdle;
	else{
		MB_CPT[MB_N][4]++;	// -    
    64c2:	fb 01       	movw	r30, r22
    64c4:	ee 0f       	add	r30, r30
    64c6:	ff 1f       	adc	r31, r31
    64c8:	ee 0f       	add	r30, r30
    64ca:	ff 1f       	adc	r31, r31
    64cc:	ee 0f       	add	r30, r30
    64ce:	ff 1f       	adc	r31, r31
    64d0:	ee 0f       	add	r30, r30
    64d2:	ff 1f       	adc	r31, r31
    64d4:	ea 50       	subi	r30, 0x0A	; 10
    64d6:	f7 4f       	sbci	r31, 0xF7	; 247
    64d8:	80 81       	ld	r24, Z
    64da:	91 81       	ldd	r25, Z+1	; 0x01
    64dc:	01 96       	adiw	r24, 0x01	; 1
    64de:	91 83       	std	Z+1, r25	; 0x01
    64e0:	80 83       	st	Z, r24
		if (++Try[MB_N]==MB_M_Try[MB_N]) {
    64e2:	eb 01       	movw	r28, r22
    64e4:	cf 51       	subi	r28, 0x1F	; 31
    64e6:	db 4f       	sbci	r29, 0xFB	; 251
    64e8:	88 81       	ld	r24, Y
    64ea:	8f 5f       	subi	r24, 0xFF	; 255
    64ec:	88 83       	st	Y, r24
    64ee:	fb 01       	movw	r30, r22
    64f0:	e5 50       	subi	r30, 0x05	; 5
    64f2:	f9 4f       	sbci	r31, 0xF9	; 249
    64f4:	90 81       	ld	r25, Z
    64f6:	89 17       	cp	r24, r25
    64f8:	79 f0       	breq	.+30     	; 0x6518 <FailSlave+0x72>
    64fa:	80 e0       	ldi	r24, 0x00	; 0
			Try[MB_N] = 0;
			Over = NextSlave(MB_N);
		}
	}
	return Over;
}
    64fc:	df 91       	pop	r29
    64fe:	cf 91       	pop	r28
    6500:	1f 91       	pop	r17
    6502:	ff 90       	pop	r15
    6504:	ef 90       	pop	r14
    6506:	08 95       	ret
static uint8_t
FailSlave(uint8_t MB_N)
{
	uint8_t Over = 0;
	if (MB_SingleState[MB_N]==MB_SingleExec)
		MB_SingleState[MB_N] = MB_SingleIdle;
    6508:	10 82       	st	Z, r1
    650a:	80 e0       	ldi	r24, 0x00	; 0
			Try[MB_N] = 0;
			Over = NextSlave(MB_N);
		}
	}
	return Over;
}
    650c:	df 91       	pop	r29
    650e:	cf 91       	pop	r28
    6510:	1f 91       	pop	r17
    6512:	ff 90       	pop	r15
    6514:	ef 90       	pop	r14
    6516:	08 95       	ret
	if (MB_SingleState[MB_N]==MB_SingleExec)
		MB_SingleState[MB_N] = MB_SingleIdle;
	else{
		MB_CPT[MB_N][4]++;	// -    
		if (++Try[MB_N]==MB_M_Try[MB_N]) {
			uint32_t S_N = (uint32_t)1<<CurrSlave[MB_N];
    6518:	fb 01       	movw	r30, r22
    651a:	ee 5a       	subi	r30, 0xAE	; 174
    651c:	f9 4f       	sbci	r31, 0xF9	; 249
    651e:	21 e0       	ldi	r18, 0x01	; 1
    6520:	30 e0       	ldi	r19, 0x00	; 0
    6522:	40 e0       	ldi	r20, 0x00	; 0
    6524:	50 e0       	ldi	r21, 0x00	; 0
    6526:	00 80       	ld	r0, Z
    6528:	04 c0       	rjmp	.+8      	; 0x6532 <FailSlave+0x8c>
    652a:	22 0f       	add	r18, r18
    652c:	33 1f       	adc	r19, r19
    652e:	44 1f       	adc	r20, r20
    6530:	55 1f       	adc	r21, r21
    6532:	0a 94       	dec	r0
    6534:	d2 f7       	brpl	.-12     	; 0x652a <FailSlave+0x84>
			SlaveOff[MB_N] |=S_N;
    6536:	7b 01       	movw	r14, r22
    6538:	ee 0c       	add	r14, r14
    653a:	ff 1c       	adc	r15, r15
    653c:	ee 0c       	add	r14, r14
    653e:	ff 1c       	adc	r15, r15
    6540:	b7 01       	movw	r22, r14
    6542:	6b 51       	subi	r22, 0x1B	; 27
    6544:	77 4f       	sbci	r23, 0xF7	; 247
    6546:	fb 01       	movw	r30, r22
    6548:	80 81       	ld	r24, Z
    654a:	91 81       	ldd	r25, Z+1	; 0x01
    654c:	a2 81       	ldd	r26, Z+2	; 0x02
    654e:	b3 81       	ldd	r27, Z+3	; 0x03
    6550:	82 2b       	or	r24, r18
    6552:	93 2b       	or	r25, r19
    6554:	a4 2b       	or	r26, r20
    6556:	b5 2b       	or	r27, r21
    6558:	80 83       	st	Z, r24
    655a:	91 83       	std	Z+1, r25	; 0x01
    655c:	a2 83       	std	Z+2, r26	; 0x02
    655e:	b3 83       	std	Z+3, r27	; 0x03
			SlaveSkip[MB_N] |=S_N;
    6560:	f7 01       	movw	r30, r14
    6562:	ee 51       	subi	r30, 0x1E	; 30
    6564:	fb 4f       	sbci	r31, 0xFB	; 251
    6566:	80 81       	ld	r24, Z
    6568:	91 81       	ldd	r25, Z+1	; 0x01
    656a:	a2 81       	ldd	r26, Z+2	; 0x02
    656c:	b3 81       	ldd	r27, Z+3	; 0x03
    656e:	28 2b       	or	r18, r24
    6570:	39 2b       	or	r19, r25
    6572:	4a 2b       	or	r20, r26
    6574:	5b 2b       	or	r21, r27
    6576:	20 83       	st	Z, r18
    6578:	31 83       	std	Z+1, r19	; 0x01
    657a:	42 83       	std	Z+2, r20	; 0x02
    657c:	53 83       	std	Z+3, r21	; 0x03
			Try[MB_N] = 0;
    657e:	18 82       	st	Y, r1
			Over = NextSlave(MB_N);
    6580:	81 2f       	mov	r24, r17
    6582:	0e 94 80 31 	call	0x6300	; 0x6300 <NextSlave>
		}
	}
	return Over;
}
    6586:	df 91       	pop	r29
    6588:	cf 91       	pop	r28
    658a:	1f 91       	pop	r17
    658c:	ff 90       	pop	r15
    658e:	ef 90       	pop	r14
    6590:	08 95       	ret

00006592 <MB_M_Timer_ISR>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_M_Timer_ISR(uint8_t MB_N)
{
    6592:	4f 92       	push	r4
    6594:	5f 92       	push	r5
    6596:	6f 92       	push	r6
    6598:	7f 92       	push	r7
    659a:	8f 92       	push	r8
    659c:	9f 92       	push	r9
    659e:	af 92       	push	r10
    65a0:	bf 92       	push	r11
    65a2:	cf 92       	push	r12
    65a4:	df 92       	push	r13
    65a6:	ef 92       	push	r14
    65a8:	ff 92       	push	r15
    65aa:	0f 93       	push	r16
    65ac:	1f 93       	push	r17
    65ae:	cf 93       	push	r28
    65b0:	df 93       	push	r29
    65b2:	18 2f       	mov	r17, r24
	switch (MB_State[MB_N]) {
    65b4:	c8 2f       	mov	r28, r24
    65b6:	d0 e0       	ldi	r29, 0x00	; 0
    65b8:	fe 01       	movw	r30, r28
    65ba:	e0 54       	subi	r30, 0x40	; 64
    65bc:	fa 4f       	sbci	r31, 0xFA	; 250
    65be:	80 81       	ld	r24, Z
    65c0:	88 23       	and	r24, r24
    65c2:	f9 f4       	brne	.+62     	; 0x6602 <MB_M_Timer_ISR+0x70>
	case MB_Initi:
		StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
    65c4:	80 91 e6 04 	lds	r24, 0x04E6
    65c8:	8e 5f       	subi	r24, 0xFE	; 254
    65ca:	81 0f       	add	r24, r17
    65cc:	6f ef       	ldi	r22, 0xFF	; 255
    65ce:	7f ef       	ldi	r23, 0xFF	; 255
    65d0:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
		FormQuery(MB_N);
    65d4:	81 2f       	mov	r24, r17
    65d6:	0e 94 ec 30 	call	0x61d8	; 0x61d8 <FormQuery>
		MB_Transm(MB_N);
    65da:	81 2f       	mov	r24, r17
    65dc:	0e 94 e4 29 	call	0x53c8	; 0x53c8 <MB_Transm>
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
		MB_M_CtrlProc(MB_N);
		break;
	}
}
    65e0:	df 91       	pop	r29
    65e2:	cf 91       	pop	r28
    65e4:	1f 91       	pop	r17
    65e6:	0f 91       	pop	r16
    65e8:	ff 90       	pop	r15
    65ea:	ef 90       	pop	r14
    65ec:	df 90       	pop	r13
    65ee:	cf 90       	pop	r12
    65f0:	bf 90       	pop	r11
    65f2:	af 90       	pop	r10
    65f4:	9f 90       	pop	r9
    65f6:	8f 90       	pop	r8
    65f8:	7f 90       	pop	r7
    65fa:	6f 90       	pop	r6
    65fc:	5f 90       	pop	r5
    65fe:	4f 90       	pop	r4
    6600:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_M_Timer_ISR(uint8_t MB_N)
{
	switch (MB_State[MB_N]) {
    6602:	82 30       	cpi	r24, 0x02	; 2
    6604:	69 f7       	brne	.-38     	; 0x65e0 <MB_M_Timer_ISR+0x4e>
		StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
		FormQuery(MB_N);
		MB_Transm(MB_N);
		break;
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
    6606:	84 e0       	ldi	r24, 0x04	; 4
    6608:	80 83       	st	Z, r24
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
MB_M_CtrlProc(uint8_t MB_N)
{
	uint8_t Over = 0;
	LastProcSingle = MB_SingleState[MB_N]==MB_SingleExec;
    660a:	ed ea       	ldi	r30, 0xAD	; 173
    660c:	ae 2e       	mov	r10, r30
    660e:	e6 e0       	ldi	r30, 0x06	; 6
    6610:	be 2e       	mov	r11, r30
    6612:	ac 0e       	add	r10, r28
    6614:	bd 1e       	adc	r11, r29
    6616:	d5 01       	movw	r26, r10
    6618:	8c 91       	ld	r24, X
    661a:	90 e0       	ldi	r25, 0x00	; 0
    661c:	82 30       	cpi	r24, 0x02	; 2
    661e:	09 f4       	brne	.+2      	; 0x6622 <MB_M_Timer_ISR+0x90>
    6620:	4e c0       	rjmp	.+156    	; 0x66be <MB_M_Timer_ISR+0x12c>
    6622:	90 93 e0 04 	sts	0x04E0, r25
	if (CommErr(MB_N))
    6626:	81 2f       	mov	r24, r17
    6628:	0e 94 c8 2a 	call	0x5590	; 0x5590 <CommErr>
    662c:	88 23       	and	r24, r24
    662e:	91 f5       	brne	.+100    	; 0x6694 <MB_M_Timer_ISR+0x102>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6630:	7e 01       	movw	r14, r28
    6632:	ee 0c       	add	r14, r14
    6634:	ff 1c       	adc	r15, r15
    6636:	ee 0c       	add	r14, r14
    6638:	ff 1c       	adc	r15, r15
    663a:	c7 01       	movw	r24, r14
    663c:	88 0f       	add	r24, r24
    663e:	99 1f       	adc	r25, r25
    6640:	88 0f       	add	r24, r24
    6642:	99 1f       	adc	r25, r25
    6644:	8e 0d       	add	r24, r14
    6646:	9f 1d       	adc	r25, r15
    6648:	81 5b       	subi	r24, 0xB1	; 177
    664a:	91 4d       	sbci	r25, 0xD1	; 209
    664c:	fc 01       	movw	r30, r24
    664e:	25 91       	lpm	r18, Z+
    6650:	34 91       	lpm	r19, Z+
		Over = FailSlave(MB_N);
	else {
		USART_Func(MB_N, LED);
    6652:	f9 01       	movw	r30, r18
    6654:	19 95       	eicall
		MB_Slave *Slave;
		MB_Query *Query;
		uint8_t Addr, Func;
		if (LastProcSingle) {
    6656:	80 91 e0 04 	lds	r24, 0x04E0
    665a:	88 23       	and	r24, r24
    665c:	91 f1       	breq	.+100    	; 0x66c2 <MB_M_Timer_ISR+0x130>
			Addr = MB_SingleQuery[MB_N].Addr;
    665e:	fe 01       	movw	r30, r28
    6660:	ee 0f       	add	r30, r30
    6662:	ff 1f       	adc	r31, r31
    6664:	ee 0f       	add	r30, r30
    6666:	ff 1f       	adc	r31, r31
    6668:	ee 0f       	add	r30, r30
    666a:	ff 1f       	adc	r31, r31
    666c:	e8 52       	subi	r30, 0x28	; 40
    666e:	fb 4f       	sbci	r31, 0xFB	; 251
    6670:	20 81       	ld	r18, Z
			Func = MB_SingleQuery[MB_N].Func;
    6672:	91 81       	ldd	r25, Z+1	; 0x01
    6674:	40 e0       	ldi	r20, 0x00	; 0
    6676:	50 e0       	ldi	r21, 0x00	; 0
    6678:	60 e0       	ldi	r22, 0x00	; 0
    667a:	70 e0       	ldi	r23, 0x00	; 0
			Slave = GetSlave(MB_N);
			Query = (MB_Query*)prp(&Slave->QueryList)+CurrQuery[MB_N];
			Addr = prb(&Slave->Addr);
			Func = prb(&Query->Func);
		}
		if (MB_Frame[MB_N][0]!=Addr || MB_Frame[MB_N][1]!=Func)
    667c:	dc 2e       	mov	r13, r28
    667e:	cc 24       	eor	r12, r12
    6680:	f6 01       	movw	r30, r12
    6682:	ed 5d       	subi	r30, 0xDD	; 221
    6684:	f4 4f       	sbci	r31, 0xF4	; 244
    6686:	80 81       	ld	r24, Z
    6688:	82 17       	cp	r24, r18
    668a:	21 f4       	brne	.+8      	; 0x6694 <MB_M_Timer_ISR+0x102>
    668c:	a1 81       	ldd	r26, Z+1	; 0x01
    668e:	a9 17       	cp	r26, r25
    6690:	09 f4       	brne	.+2      	; 0x6694 <MB_M_Timer_ISR+0x102>
    6692:	3d c0       	rjmp	.+122    	; 0x670e <MB_M_Timer_ISR+0x17c>
				Err = MB_M_Force(MB_N, Query);
				break;
			}
			if (Err) {
				MB_CPT[MB_N][2]++;
				Over = FailSlave(MB_N);
    6694:	81 2f       	mov	r24, r17
    6696:	0e 94 53 32 	call	0x64a6	; 0x64a6 <FailSlave>
    669a:	98 2f       	mov	r25, r24
			}
		}
		/*if (Over)
			USART_Func(MB_N, LED);*/
	}
	StartTimer16(TD_MB_Idle+MB_N, Over?MB_M_Period[MB_N]:MB_M_Pause_Min);
    669c:	80 91 e6 04 	lds	r24, 0x04E6
    66a0:	81 0f       	add	r24, r17
    66a2:	99 23       	and	r25, r25
    66a4:	49 f0       	breq	.+18     	; 0x66b8 <MB_M_Timer_ISR+0x126>
    66a6:	cc 0f       	add	r28, r28
    66a8:	dd 1f       	adc	r29, r29
    66aa:	c5 55       	subi	r28, 0x55	; 85
    66ac:	d9 4f       	sbci	r29, 0xF9	; 249
    66ae:	68 81       	ld	r22, Y
    66b0:	79 81       	ldd	r23, Y+1	; 0x01
    66b2:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
    66b6:	94 cf       	rjmp	.-216    	; 0x65e0 <MB_M_Timer_ISR+0x4e>
    66b8:	65 e0       	ldi	r22, 0x05	; 5
    66ba:	70 e0       	ldi	r23, 0x00	; 0
    66bc:	fa cf       	rjmp	.-12     	; 0x66b2 <MB_M_Timer_ISR+0x120>
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
MB_M_CtrlProc(uint8_t MB_N)
{
	uint8_t Over = 0;
	LastProcSingle = MB_SingleState[MB_N]==MB_SingleExec;
    66be:	91 e0       	ldi	r25, 0x01	; 1
    66c0:	b0 cf       	rjmp	.-160    	; 0x6622 <MB_M_Timer_ISR+0x90>
    66c2:	83 e0       	ldi	r24, 0x03	; 3
    66c4:	18 9f       	mul	r17, r24
    66c6:	f0 01       	movw	r30, r0
    66c8:	11 24       	eor	r1, r1
    66ca:	e5 5b       	subi	r30, 0xB5	; 181
    66cc:	f6 4d       	sbci	r31, 0xD6	; 214
    66ce:	65 91       	lpm	r22, Z+
    66d0:	74 91       	lpm	r23, Z+

// ~~~~~~~~~~~~~~~~~~~
static MB_Slave*
GetSlave(uint8_t MB_N)
{
	return (MB_Slave*)prp(&(MB_Master_List+MB_N)->SlaveList)+CurrSlave[MB_N];
    66d2:	fe 01       	movw	r30, r28
    66d4:	ee 5a       	subi	r30, 0xAE	; 174
    66d6:	f9 4f       	sbci	r31, 0xF9	; 249
    66d8:	80 81       	ld	r24, Z
    66da:	90 e0       	ldi	r25, 0x00	; 0
    66dc:	88 0f       	add	r24, r24
    66de:	99 1f       	adc	r25, r25
    66e0:	88 0f       	add	r24, r24
    66e2:	99 1f       	adc	r25, r25
    66e4:	68 0f       	add	r22, r24
    66e6:	79 1f       	adc	r23, r25
    66e8:	fb 01       	movw	r30, r22
    66ea:	31 96       	adiw	r30, 0x01	; 1
    66ec:	45 91       	lpm	r20, Z+
    66ee:	54 91       	lpm	r21, Z+
			Addr = MB_SingleQuery[MB_N].Addr;
			Func = MB_SingleQuery[MB_N].Func;
		}
		else {
			Slave = GetSlave(MB_N);
			Query = (MB_Query*)prp(&Slave->QueryList)+CurrQuery[MB_N];
    66f0:	fe 01       	movw	r30, r28
    66f2:	ed 5a       	subi	r30, 0xAD	; 173
    66f4:	f9 4f       	sbci	r31, 0xF9	; 249
    66f6:	80 81       	ld	r24, Z
    66f8:	27 e0       	ldi	r18, 0x07	; 7
    66fa:	82 9f       	mul	r24, r18
    66fc:	c0 01       	movw	r24, r0
    66fe:	11 24       	eor	r1, r1
    6700:	48 0f       	add	r20, r24
    6702:	59 1f       	adc	r21, r25

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    6704:	fb 01       	movw	r30, r22
    6706:	24 91       	lpm	r18, Z+
		}
		if (MB_Frame[MB_N][0]!=Addr || MB_Frame[MB_N][1]!=Func)
			Over = FailSlave(MB_N);
		else {
			uint8_t Err;
			switch (Func) {
    6708:	fa 01       	movw	r30, r20
    670a:	94 91       	lpm	r25, Z+
    670c:	b7 cf       	rjmp	.-146    	; 0x667c <MB_M_Timer_ISR+0xea>
    670e:	95 30       	cpi	r25, 0x05	; 5
    6710:	18 f5       	brcc	.+70     	; 0x6758 <MB_M_Timer_ISR+0x1c6>
    6712:	93 30       	cpi	r25, 0x03	; 3
    6714:	08 f4       	brcc	.+2      	; 0x6718 <MB_M_Timer_ISR+0x186>
    6716:	ad c0       	rjmp	.+346    	; 0x6872 <MB_M_Timer_ISR+0x2e0>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_M_ReadReg(uint8_t MB_N, MB_Query *Query)
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || (LastProcSingle?MB_SingleQuery[MB_N].Qt:prw(&Query->Qt))*2!=MB_Frame[MB_N][2])
    6718:	fc 2f       	mov	r31, r28
    671a:	ee 27       	eor	r30, r30
    671c:	eb 5d       	subi	r30, 0xDB	; 219
    671e:	f4 4f       	sbci	r31, 0xF4	; 244
    6720:	b0 81       	ld	r27, Z
    6722:	fe 01       	movw	r30, r28
    6724:	eb 5f       	subi	r30, 0xFB	; 251
    6726:	f8 4f       	sbci	r31, 0xF8	; 248
    6728:	80 81       	ld	r24, Z
    672a:	90 e0       	ldi	r25, 0x00	; 0
    672c:	8b 2e       	mov	r8, r27
    672e:	99 24       	eor	r9, r9
    6730:	94 01       	movw	r18, r8
    6732:	2b 5f       	subi	r18, 0xFB	; 251
    6734:	3f 4f       	sbci	r19, 0xFF	; 255
    6736:	82 17       	cp	r24, r18
    6738:	93 07       	cpc	r25, r19
    673a:	09 f4       	brne	.+2      	; 0x673e <MB_M_Timer_ISR+0x1ac>
    673c:	94 c1       	rjmp	.+808    	; 0x6a66 <MB_M_Timer_ISR+0x4d4>
			case 0x0F: case 0x10:
				Err = MB_M_Force(MB_N, Query);
				break;
			}
			if (Err) {
				MB_CPT[MB_N][2]++;
    673e:	f7 01       	movw	r30, r14
    6740:	ee 0f       	add	r30, r30
    6742:	ff 1f       	adc	r31, r31
    6744:	ee 0f       	add	r30, r30
    6746:	ff 1f       	adc	r31, r31
    6748:	ee 50       	subi	r30, 0x0E	; 14
    674a:	f7 4f       	sbci	r31, 0xF7	; 247
    674c:	80 81       	ld	r24, Z
    674e:	91 81       	ldd	r25, Z+1	; 0x01
    6750:	01 96       	adiw	r24, 0x01	; 1
    6752:	91 83       	std	Z+1, r25	; 0x01
    6754:	80 83       	st	Z, r24
    6756:	9e cf       	rjmp	.-196    	; 0x6694 <MB_M_Timer_ISR+0x102>
		}
		if (MB_Frame[MB_N][0]!=Addr || MB_Frame[MB_N][1]!=Func)
			Over = FailSlave(MB_N);
		else {
			uint8_t Err;
			switch (Func) {
    6758:	96 30       	cpi	r25, 0x06	; 6
    675a:	09 f4       	brne	.+2      	; 0x675e <MB_M_Timer_ISR+0x1cc>
    675c:	18 c1       	rjmp	.+560    	; 0x698e <MB_M_Timer_ISR+0x3fc>
    675e:	96 30       	cpi	r25, 0x06	; 6
    6760:	08 f4       	brcc	.+2      	; 0x6764 <MB_M_Timer_ISR+0x1d2>
    6762:	43 c0       	rjmp	.+134    	; 0x67ea <MB_M_Timer_ISR+0x258>
    6764:	9f 50       	subi	r25, 0x0F	; 15
    6766:	92 30       	cpi	r25, 0x02	; 2
    6768:	08 f0       	brcs	.+2      	; 0x676c <MB_M_Timer_ISR+0x1da>
    676a:	3f c0       	rjmp	.+126    	; 0x67ea <MB_M_Timer_ISR+0x258>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_M_Force(uint8_t MB_N, MB_Query *Query)
{
	uint16_t StartAddr, Qt;
	if (LastProcSingle) {
    676c:	80 91 e0 04 	lds	r24, 0x04E0
    6770:	88 23       	and	r24, r24
    6772:	09 f4       	brne	.+2      	; 0x6776 <MB_M_Timer_ISR+0x1e4>
    6774:	4e c1       	rjmp	.+668    	; 0x6a12 <MB_M_Timer_ISR+0x480>
		StartAddr	= MB_SingleQuery[MB_N].StartAddr;
    6776:	f7 01       	movw	r30, r14
    6778:	ee 0f       	add	r30, r30
    677a:	ff 1f       	adc	r31, r31
    677c:	e6 52       	subi	r30, 0x26	; 38
    677e:	fb 4f       	sbci	r31, 0xFB	; 251
    6780:	80 80       	ld	r8, Z
    6782:	91 80       	ldd	r9, Z+1	; 0x01
		Qt				= MB_SingleQuery[MB_N].Qt;
    6784:	fe 01       	movw	r30, r28
    6786:	ee 0f       	add	r30, r30
    6788:	ff 1f       	adc	r31, r31
    678a:	ee 0f       	add	r30, r30
    678c:	ff 1f       	adc	r31, r31
    678e:	ee 0f       	add	r30, r30
    6790:	ff 1f       	adc	r31, r31
    6792:	e4 52       	subi	r30, 0x24	; 36
    6794:	fb 4f       	sbci	r31, 0xFB	; 251
    6796:	40 81       	ld	r20, Z
    6798:	51 81       	ldd	r21, Z+1	; 0x01
	}
	else {
		StartAddr	= prw(&Query->StartAddr);
		Qt				= prw(&Query->Qt);
	}
	return MB_Frame_Sz[MB_N]!=8 || MB_FrameReg(MB_N, 2)!=StartAddr || MB_FrameReg(MB_N, 4)!=Qt;
    679a:	fe 01       	movw	r30, r28
    679c:	eb 5f       	subi	r30, 0xFB	; 251
    679e:	f8 4f       	sbci	r31, 0xF8	; 248
    67a0:	80 81       	ld	r24, Z
    67a2:	88 30       	cpi	r24, 0x08	; 8
    67a4:	61 f6       	brne	.-104    	; 0x673e <MB_M_Timer_ISR+0x1ac>
    67a6:	fc 2f       	mov	r31, r28
    67a8:	ee 27       	eor	r30, r30
    67aa:	eb 5d       	subi	r30, 0xDB	; 219
    67ac:	f4 4f       	sbci	r31, 0xF4	; 244
    67ae:	30 81       	ld	r19, Z
    67b0:	20 e0       	ldi	r18, 0x00	; 0
    67b2:	d6 01       	movw	r26, r12
    67b4:	ad 5d       	subi	r26, 0xDD	; 221
    67b6:	b4 4f       	sbci	r27, 0xF4	; 244
    67b8:	13 96       	adiw	r26, 0x03	; 3
    67ba:	8c 91       	ld	r24, X
    67bc:	13 97       	sbiw	r26, 0x03	; 3
    67be:	90 e0       	ldi	r25, 0x00	; 0
    67c0:	28 2b       	or	r18, r24
    67c2:	39 2b       	or	r19, r25
    67c4:	28 15       	cp	r18, r8
    67c6:	39 05       	cpc	r19, r9
    67c8:	09 f0       	breq	.+2      	; 0x67cc <MB_M_Timer_ISR+0x23a>
    67ca:	b9 cf       	rjmp	.-142    	; 0x673e <MB_M_Timer_ISR+0x1ac>
    67cc:	fc 2f       	mov	r31, r28
    67ce:	ee 27       	eor	r30, r30
    67d0:	e9 5d       	subi	r30, 0xD9	; 217
    67d2:	f4 4f       	sbci	r31, 0xF4	; 244
    67d4:	90 81       	ld	r25, Z
    67d6:	80 e0       	ldi	r24, 0x00	; 0
    67d8:	15 96       	adiw	r26, 0x05	; 5
    67da:	2c 91       	ld	r18, X
    67dc:	30 e0       	ldi	r19, 0x00	; 0
    67de:	82 2b       	or	r24, r18
    67e0:	93 2b       	or	r25, r19
    67e2:	84 17       	cp	r24, r20
    67e4:	95 07       	cpc	r25, r21
    67e6:	09 f0       	breq	.+2      	; 0x67ea <MB_M_Timer_ISR+0x258>
    67e8:	aa cf       	rjmp	.-172    	; 0x673e <MB_M_Timer_ISR+0x1ac>
			}
			if (Err) {
				MB_CPT[MB_N][2]++;
				Over = FailSlave(MB_N);
			}
			else if (LastProcSingle)
    67ea:	80 91 e0 04 	lds	r24, 0x04E0
    67ee:	88 23       	and	r24, r24
    67f0:	41 f0       	breq	.+16     	; 0x6802 <MB_M_Timer_ISR+0x270>
				MB_SingleState[MB_N] = MB_SingleIdle;
    67f2:	d5 01       	movw	r26, r10
    67f4:	1c 92       	st	X, r1
			}
		}
		/*if (Over)
			USART_Func(MB_N, LED);*/
	}
	StartTimer16(TD_MB_Idle+MB_N, Over?MB_M_Period[MB_N]:MB_M_Pause_Min);
    67f6:	80 91 e6 04 	lds	r24, 0x04E6
    67fa:	81 0f       	add	r24, r17
    67fc:	65 e0       	ldi	r22, 0x05	; 5
    67fe:	70 e0       	ldi	r23, 0x00	; 0
    6800:	58 cf       	rjmp	.-336    	; 0x66b2 <MB_M_Timer_ISR+0x120>
				Over = FailSlave(MB_N);
			}
			else if (LastProcSingle)
				MB_SingleState[MB_N] = MB_SingleIdle;
			else {
				SlaveOff[MB_N] &=~((uint32_t)1<<CurrSlave[MB_N]);
    6802:	e5 ee       	ldi	r30, 0xE5	; 229
    6804:	f8 e0       	ldi	r31, 0x08	; 8
    6806:	ee 0e       	add	r14, r30
    6808:	ff 1e       	adc	r15, r31
    680a:	9e 01       	movw	r18, r28
    680c:	2e 5a       	subi	r18, 0xAE	; 174
    680e:	39 4f       	sbci	r19, 0xF9	; 249
    6810:	81 e0       	ldi	r24, 0x01	; 1
    6812:	90 e0       	ldi	r25, 0x00	; 0
    6814:	a0 e0       	ldi	r26, 0x00	; 0
    6816:	b0 e0       	ldi	r27, 0x00	; 0
    6818:	f9 01       	movw	r30, r18
    681a:	00 80       	ld	r0, Z
    681c:	04 c0       	rjmp	.+8      	; 0x6826 <MB_M_Timer_ISR+0x294>
    681e:	88 0f       	add	r24, r24
    6820:	99 1f       	adc	r25, r25
    6822:	aa 1f       	adc	r26, r26
    6824:	bb 1f       	adc	r27, r27
    6826:	0a 94       	dec	r0
    6828:	d2 f7       	brpl	.-12     	; 0x681e <MB_M_Timer_ISR+0x28c>
    682a:	80 95       	com	r24
    682c:	90 95       	com	r25
    682e:	a0 95       	com	r26
    6830:	b0 95       	com	r27
    6832:	f7 01       	movw	r30, r14
    6834:	20 81       	ld	r18, Z
    6836:	31 81       	ldd	r19, Z+1	; 0x01
    6838:	42 81       	ldd	r20, Z+2	; 0x02
    683a:	53 81       	ldd	r21, Z+3	; 0x03
    683c:	82 23       	and	r24, r18
    683e:	93 23       	and	r25, r19
    6840:	a4 23       	and	r26, r20
    6842:	b5 23       	and	r27, r21
    6844:	80 83       	st	Z, r24
    6846:	91 83       	std	Z+1, r25	; 0x01
    6848:	a2 83       	std	Z+2, r26	; 0x02
    684a:	b3 83       	std	Z+3, r27	; 0x03
				if (++CurrQuery[MB_N]==prb(&Slave->QueryQt))
    684c:	fe 01       	movw	r30, r28
    684e:	ed 5a       	subi	r30, 0xAD	; 173
    6850:	f9 4f       	sbci	r31, 0xF9	; 249
    6852:	80 81       	ld	r24, Z
    6854:	8f 5f       	subi	r24, 0xFF	; 255
    6856:	80 83       	st	Z, r24
    6858:	6d 5f       	subi	r22, 0xFD	; 253
    685a:	7f 4f       	sbci	r23, 0xFF	; 255
    685c:	fb 01       	movw	r30, r22
    685e:	94 91       	lpm	r25, Z+
    6860:	89 17       	cp	r24, r25
    6862:	09 f4       	brne	.+2      	; 0x6866 <MB_M_Timer_ISR+0x2d4>
    6864:	55 c1       	rjmp	.+682    	; 0x6b10 <MB_M_Timer_ISR+0x57e>
    6866:	90 e0       	ldi	r25, 0x00	; 0
					Over = NextSlave(MB_N);
				Try[MB_N] = 0;
    6868:	fe 01       	movw	r30, r28
    686a:	ef 51       	subi	r30, 0x1F	; 31
    686c:	fb 4f       	sbci	r31, 0xFB	; 251
    686e:	10 82       	st	Z, r1
    6870:	15 cf       	rjmp	.-470    	; 0x669c <MB_M_Timer_ISR+0x10a>
		}
		if (MB_Frame[MB_N][0]!=Addr || MB_Frame[MB_N][1]!=Func)
			Over = FailSlave(MB_N);
		else {
			uint8_t Err;
			switch (Func) {
    6872:	91 30       	cpi	r25, 0x01	; 1
    6874:	08 f4       	brcc	.+2      	; 0x6878 <MB_M_Timer_ISR+0x2e6>
    6876:	b9 cf       	rjmp	.-142    	; 0x67ea <MB_M_Timer_ISR+0x258>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_M_ReadDiscr(uint8_t MB_N, MB_Query *Query)
{
	uint8_t Qt = LastProcSingle ? MB_SingleQuery[MB_N].Qt : prb((uint8_t*)&Query->Qt);
    6878:	80 91 e0 04 	lds	r24, 0x04E0
    687c:	88 23       	and	r24, r24
    687e:	09 f4       	brne	.+2      	; 0x6882 <MB_M_Timer_ISR+0x2f0>
    6880:	eb c0       	rjmp	.+470    	; 0x6a58 <MB_M_Timer_ISR+0x4c6>
    6882:	fe 01       	movw	r30, r28
    6884:	ee 0f       	add	r30, r30
    6886:	ff 1f       	adc	r31, r31
    6888:	ee 0f       	add	r30, r30
    688a:	ff 1f       	adc	r31, r31
    688c:	ee 0f       	add	r30, r30
    688e:	ff 1f       	adc	r31, r31
    6890:	e4 52       	subi	r30, 0x24	; 36
    6892:	fb 4f       	sbci	r31, 0xFB	; 251
    6894:	b0 81       	ld	r27, Z
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || Qt/8+((Qt%8)>0)!=MB_Frame[MB_N][2])
    6896:	fc 2f       	mov	r31, r28
    6898:	ee 27       	eor	r30, r30
    689a:	eb 5d       	subi	r30, 0xDB	; 219
    689c:	f4 4f       	sbci	r31, 0xF4	; 244
    689e:	80 81       	ld	r24, Z
    68a0:	88 2e       	mov	r8, r24
    68a2:	99 24       	eor	r9, r9
    68a4:	fe 01       	movw	r30, r28
    68a6:	eb 5f       	subi	r30, 0xFB	; 251
    68a8:	f8 4f       	sbci	r31, 0xF8	; 248
    68aa:	80 81       	ld	r24, Z
    68ac:	90 e0       	ldi	r25, 0x00	; 0
    68ae:	94 01       	movw	r18, r8
    68b0:	2b 5f       	subi	r18, 0xFB	; 251
    68b2:	3f 4f       	sbci	r19, 0xFF	; 255
    68b4:	82 17       	cp	r24, r18
    68b6:	93 07       	cpc	r25, r19
    68b8:	09 f0       	breq	.+2      	; 0x68bc <MB_M_Timer_ISR+0x32a>
    68ba:	41 cf       	rjmp	.-382    	; 0x673e <MB_M_Timer_ISR+0x1ac>
    68bc:	20 e0       	ldi	r18, 0x00	; 0
    68be:	30 e0       	ldi	r19, 0x00	; 0
    68c0:	6b 2e       	mov	r6, r27
    68c2:	77 24       	eor	r7, r7
    68c4:	c3 01       	movw	r24, r6
    68c6:	87 70       	andi	r24, 0x07	; 7
    68c8:	90 70       	andi	r25, 0x00	; 0
    68ca:	18 16       	cp	r1, r24
    68cc:	19 06       	cpc	r1, r25
    68ce:	14 f4       	brge	.+4      	; 0x68d4 <MB_M_Timer_ISR+0x342>
    68d0:	21 e0       	ldi	r18, 0x01	; 1
    68d2:	30 e0       	ldi	r19, 0x00	; 0
    68d4:	b6 95       	lsr	r27
    68d6:	b6 95       	lsr	r27
    68d8:	b6 95       	lsr	r27
    68da:	2b 0f       	add	r18, r27
    68dc:	31 1d       	adc	r19, r1
    68de:	82 16       	cp	r8, r18
    68e0:	93 06       	cpc	r9, r19
    68e2:	09 f0       	breq	.+2      	; 0x68e6 <MB_M_Timer_ISR+0x354>
    68e4:	2c cf       	rjmp	.-424    	; 0x673e <MB_M_Timer_ISR+0x1ac>
		return 1;
	uint8_t *Discr;
	uint8_t Pin;
	if (LastProcSingle) {
    68e6:	80 91 e0 04 	lds	r24, 0x04E0
    68ea:	88 23       	and	r24, r24
    68ec:	09 f4       	brne	.+2      	; 0x68f0 <MB_M_Timer_ISR+0x35e>
    68ee:	1d c1       	rjmp	.+570    	; 0x6b2a <MB_M_Timer_ISR+0x598>
		Discr = MB_SingleQuery[MB_N].Buf;
    68f0:	fe 01       	movw	r30, r28
    68f2:	ee 0f       	add	r30, r30
    68f4:	ff 1f       	adc	r31, r31
    68f6:	ee 0f       	add	r30, r30
    68f8:	ff 1f       	adc	r31, r31
    68fa:	ee 0f       	add	r30, r30
    68fc:	ff 1f       	adc	r31, r31
    68fe:	e8 52       	subi	r30, 0x28	; 40
    6900:	fb 4f       	sbci	r31, 0xFB	; 251
    6902:	86 80       	ldd	r8, Z+6	; 0x06
    6904:	97 80       	ldd	r9, Z+7	; 0x07
    6906:	00 e0       	ldi	r16, 0x00	; 0
	}
	else {
		Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
		Pin = prw(&Query->AllocAddr);
	}
	for (uint16_t i=0; i<Qt; i++) {
    6908:	61 14       	cp	r6, r1
    690a:	71 04       	cpc	r7, r1
    690c:	09 f4       	brne	.+2      	; 0x6910 <MB_M_Timer_ISR+0x37e>
    690e:	6d cf       	rjmp	.-294    	; 0x67ea <MB_M_Timer_ISR+0x258>
    6910:	40 e0       	ldi	r20, 0x00	; 0
    6912:	50 e0       	ldi	r21, 0x00	; 0
		uint8_t j = Pin+i;
		uint8_t Byte=j/8, Bit=1<<j%8;
    6914:	21 e0       	ldi	r18, 0x01	; 1
    6916:	42 2e       	mov	r4, r18
    6918:	51 2c       	mov	r5, r1
		if (MB_Frame[MB_N][3+i/8] &(1<<i%8))
    691a:	83 e2       	ldi	r24, 0x23	; 35
    691c:	9b e0       	ldi	r25, 0x0B	; 11
    691e:	c8 0e       	add	r12, r24
    6920:	d9 1e       	adc	r13, r25
    6922:	0c c0       	rjmp	.+24     	; 0x693c <MB_M_Timer_ISR+0x3aa>
			Discr[Byte] |=Bit;
    6924:	f4 01       	movw	r30, r8
    6926:	eb 0f       	add	r30, r27
    6928:	f1 1d       	adc	r31, r1
    692a:	80 81       	ld	r24, Z
    692c:	8a 2b       	or	r24, r26
    692e:	80 83       	st	Z, r24
	}
	else {
		Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
		Pin = prw(&Query->AllocAddr);
	}
	for (uint16_t i=0; i<Qt; i++) {
    6930:	4f 5f       	subi	r20, 0xFF	; 255
    6932:	5f 4f       	sbci	r21, 0xFF	; 255
    6934:	46 15       	cp	r20, r6
    6936:	57 05       	cpc	r21, r7
    6938:	08 f0       	brcs	.+2      	; 0x693c <MB_M_Timer_ISR+0x3aa>
    693a:	57 cf       	rjmp	.-338    	; 0x67ea <MB_M_Timer_ISR+0x258>
    693c:	80 2f       	mov	r24, r16
    693e:	84 0f       	add	r24, r20
		uint8_t j = Pin+i;
		uint8_t Byte=j/8, Bit=1<<j%8;
    6940:	b8 2f       	mov	r27, r24
    6942:	b6 95       	lsr	r27
    6944:	b6 95       	lsr	r27
    6946:	b6 95       	lsr	r27
    6948:	87 70       	andi	r24, 0x07	; 7
    694a:	a4 2d       	mov	r26, r4
    694c:	01 c0       	rjmp	.+2      	; 0x6950 <MB_M_Timer_ISR+0x3be>
    694e:	aa 0f       	add	r26, r26
    6950:	8a 95       	dec	r24
    6952:	ea f7       	brpl	.-6      	; 0x694e <MB_M_Timer_ISR+0x3bc>
		if (MB_Frame[MB_N][3+i/8] &(1<<i%8))
    6954:	fa 01       	movw	r30, r20
    6956:	f6 95       	lsr	r31
    6958:	e7 95       	ror	r30
    695a:	f6 95       	lsr	r31
    695c:	e7 95       	ror	r30
    695e:	f6 95       	lsr	r31
    6960:	e7 95       	ror	r30
    6962:	ec 0d       	add	r30, r12
    6964:	fd 1d       	adc	r31, r13
    6966:	83 81       	ldd	r24, Z+3	; 0x03
    6968:	90 e0       	ldi	r25, 0x00	; 0
    696a:	9a 01       	movw	r18, r20
    696c:	27 70       	andi	r18, 0x07	; 7
    696e:	30 70       	andi	r19, 0x00	; 0
    6970:	02 c0       	rjmp	.+4      	; 0x6976 <MB_M_Timer_ISR+0x3e4>
    6972:	95 95       	asr	r25
    6974:	87 95       	ror	r24
    6976:	2a 95       	dec	r18
    6978:	e2 f7       	brpl	.-8      	; 0x6972 <MB_M_Timer_ISR+0x3e0>
    697a:	80 fd       	sbrc	r24, 0
    697c:	d3 cf       	rjmp	.-90     	; 0x6924 <MB_M_Timer_ISR+0x392>
			Discr[Byte] |=Bit;
		else
			Discr[Byte] &=~Bit;
    697e:	f4 01       	movw	r30, r8
    6980:	eb 0f       	add	r30, r27
    6982:	f1 1d       	adc	r31, r1
    6984:	a0 95       	com	r26
    6986:	80 81       	ld	r24, Z
    6988:	8a 23       	and	r24, r26
    698a:	80 83       	st	Z, r24
    698c:	d1 cf       	rjmp	.-94     	; 0x6930 <MB_M_Timer_ISR+0x39e>
inline static uint8_t
MB_M_PresetSingle(uint8_t MB_N, MB_Query *Query)
{
	uint16_t StartAddr;
	uint16_t *Reg;
	if (LastProcSingle) {
    698e:	80 91 e0 04 	lds	r24, 0x04E0
    6992:	88 23       	and	r24, r24
    6994:	09 f4       	brne	.+2      	; 0x6998 <MB_M_Timer_ISR+0x406>
    6996:	46 c0       	rjmp	.+140    	; 0x6a24 <MB_M_Timer_ISR+0x492>
		StartAddr = MB_SingleQuery[MB_N].StartAddr;
    6998:	f7 01       	movw	r30, r14
    699a:	ee 0f       	add	r30, r30
    699c:	ff 1f       	adc	r31, r31
    699e:	e6 52       	subi	r30, 0x26	; 38
    69a0:	fb 4f       	sbci	r31, 0xFB	; 251
    69a2:	80 80       	ld	r8, Z
    69a4:	91 80       	ldd	r9, Z+1	; 0x01
		Reg = MB_SingleQuery[MB_N].Buf;
    69a6:	fe 01       	movw	r30, r28
    69a8:	ee 0f       	add	r30, r30
    69aa:	ff 1f       	adc	r31, r31
    69ac:	ee 0f       	add	r30, r30
    69ae:	ff 1f       	adc	r31, r31
    69b0:	ee 0f       	add	r30, r30
    69b2:	ff 1f       	adc	r31, r31
    69b4:	e8 52       	subi	r30, 0x28	; 40
    69b6:	fb 4f       	sbci	r31, 0xFB	; 251
    69b8:	a6 81       	ldd	r26, Z+6	; 0x06
    69ba:	b7 81       	ldd	r27, Z+7	; 0x07
	}
	else {
		StartAddr = prw(&Query->StartAddr);
		Reg = (uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+prw(&Query->AllocAddr);
	}
	return MB_Frame_Sz[MB_N]!=8 || MB_FrameReg(MB_N, 2)!=StartAddr || MB_FrameReg(MB_N, 4)!=*Reg;
    69bc:	fe 01       	movw	r30, r28
    69be:	eb 5f       	subi	r30, 0xFB	; 251
    69c0:	f8 4f       	sbci	r31, 0xF8	; 248
    69c2:	80 81       	ld	r24, Z
    69c4:	88 30       	cpi	r24, 0x08	; 8
    69c6:	09 f0       	breq	.+2      	; 0x69ca <MB_M_Timer_ISR+0x438>
    69c8:	ba ce       	rjmp	.-652    	; 0x673e <MB_M_Timer_ISR+0x1ac>
    69ca:	fc 2f       	mov	r31, r28
    69cc:	ee 27       	eor	r30, r30
    69ce:	eb 5d       	subi	r30, 0xDB	; 219
    69d0:	f4 4f       	sbci	r31, 0xF4	; 244
    69d2:	30 81       	ld	r19, Z
    69d4:	20 e0       	ldi	r18, 0x00	; 0
    69d6:	a6 01       	movw	r20, r12
    69d8:	4d 5d       	subi	r20, 0xDD	; 221
    69da:	54 4f       	sbci	r21, 0xF4	; 244
    69dc:	fa 01       	movw	r30, r20
    69de:	83 81       	ldd	r24, Z+3	; 0x03
    69e0:	90 e0       	ldi	r25, 0x00	; 0
    69e2:	28 2b       	or	r18, r24
    69e4:	39 2b       	or	r19, r25
    69e6:	28 15       	cp	r18, r8
    69e8:	39 05       	cpc	r19, r9
    69ea:	09 f0       	breq	.+2      	; 0x69ee <MB_M_Timer_ISR+0x45c>
    69ec:	a8 ce       	rjmp	.-688    	; 0x673e <MB_M_Timer_ISR+0x1ac>
    69ee:	fc 2f       	mov	r31, r28
    69f0:	ee 27       	eor	r30, r30
    69f2:	e9 5d       	subi	r30, 0xD9	; 217
    69f4:	f4 4f       	sbci	r31, 0xF4	; 244
    69f6:	30 81       	ld	r19, Z
    69f8:	20 e0       	ldi	r18, 0x00	; 0
    69fa:	fa 01       	movw	r30, r20
    69fc:	85 81       	ldd	r24, Z+5	; 0x05
    69fe:	90 e0       	ldi	r25, 0x00	; 0
    6a00:	28 2b       	or	r18, r24
    6a02:	39 2b       	or	r19, r25
    6a04:	8d 91       	ld	r24, X+
    6a06:	9c 91       	ld	r25, X
    6a08:	28 17       	cp	r18, r24
    6a0a:	39 07       	cpc	r19, r25
    6a0c:	09 f0       	breq	.+2      	; 0x6a10 <MB_M_Timer_ISR+0x47e>
    6a0e:	97 ce       	rjmp	.-722    	; 0x673e <MB_M_Timer_ISR+0x1ac>
    6a10:	ec ce       	rjmp	.-552    	; 0x67ea <MB_M_Timer_ISR+0x258>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    6a12:	fa 01       	movw	r30, r20
    6a14:	31 96       	adiw	r30, 0x01	; 1
    6a16:	85 90       	lpm	r8, Z+
    6a18:	94 90       	lpm	r9, Z+

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6a1a:	fa 01       	movw	r30, r20
    6a1c:	33 96       	adiw	r30, 0x03	; 3
    6a1e:	45 91       	lpm	r20, Z+
    6a20:	54 91       	lpm	r21, Z+
    6a22:	bb ce       	rjmp	.-650    	; 0x679a <MB_M_Timer_ISR+0x208>
    6a24:	fa 01       	movw	r30, r20
    6a26:	31 96       	adiw	r30, 0x01	; 1
    6a28:	85 90       	lpm	r8, Z+
    6a2a:	94 90       	lpm	r9, Z+
    6a2c:	fe 01       	movw	r30, r28
    6a2e:	ee 0f       	add	r30, r30
    6a30:	ff 1f       	adc	r31, r31
    6a32:	ee 0f       	add	r30, r30
    6a34:	ff 1f       	adc	r31, r31
    6a36:	ee 0f       	add	r30, r30
    6a38:	ff 1f       	adc	r31, r31
    6a3a:	ee 0f       	add	r30, r30
    6a3c:	ff 1f       	adc	r31, r31
    6a3e:	e8 5c       	subi	r30, 0xC8	; 200
    6a40:	fc 4f       	sbci	r31, 0xFC	; 252
    6a42:	a5 91       	lpm	r26, Z+
    6a44:	b4 91       	lpm	r27, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    6a46:	fa 01       	movw	r30, r20
    6a48:	35 96       	adiw	r30, 0x05	; 5
    6a4a:	85 91       	lpm	r24, Z+
    6a4c:	94 91       	lpm	r25, Z+
		StartAddr = MB_SingleQuery[MB_N].StartAddr;
		Reg = MB_SingleQuery[MB_N].Buf;
	}
	else {
		StartAddr = prw(&Query->StartAddr);
		Reg = (uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+prw(&Query->AllocAddr);
    6a4e:	88 0f       	add	r24, r24
    6a50:	99 1f       	adc	r25, r25
    6a52:	a8 0f       	add	r26, r24
    6a54:	b9 1f       	adc	r27, r25
    6a56:	b2 cf       	rjmp	.-156    	; 0x69bc <MB_M_Timer_ISR+0x42a>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    6a58:	4d 5f       	subi	r20, 0xFD	; 253
    6a5a:	5f 4f       	sbci	r21, 0xFF	; 255
    6a5c:	fa 01       	movw	r30, r20
    6a5e:	b4 91       	lpm	r27, Z+
    6a60:	43 50       	subi	r20, 0x03	; 3
    6a62:	50 40       	sbci	r21, 0x00	; 0
    6a64:	18 cf       	rjmp	.-464    	; 0x6896 <MB_M_Timer_ISR+0x304>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_M_ReadReg(uint8_t MB_N, MB_Query *Query)
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || (LastProcSingle?MB_SingleQuery[MB_N].Qt:prw(&Query->Qt))*2!=MB_Frame[MB_N][2])
    6a66:	80 91 e0 04 	lds	r24, 0x04E0
    6a6a:	88 23       	and	r24, r24
    6a6c:	09 f4       	brne	.+2      	; 0x6a70 <MB_M_Timer_ISR+0x4de>
    6a6e:	55 c0       	rjmp	.+170    	; 0x6b1a <MB_M_Timer_ISR+0x588>
    6a70:	fe 01       	movw	r30, r28
    6a72:	ee 0f       	add	r30, r30
    6a74:	ff 1f       	adc	r31, r31
    6a76:	ee 0f       	add	r30, r30
    6a78:	ff 1f       	adc	r31, r31
    6a7a:	ee 0f       	add	r30, r30
    6a7c:	ff 1f       	adc	r31, r31
    6a7e:	e4 52       	subi	r30, 0x24	; 36
    6a80:	fb 4f       	sbci	r31, 0xFB	; 251
    6a82:	20 81       	ld	r18, Z
    6a84:	31 81       	ldd	r19, Z+1	; 0x01
    6a86:	22 0f       	add	r18, r18
    6a88:	33 1f       	adc	r19, r19
    6a8a:	82 16       	cp	r8, r18
    6a8c:	93 06       	cpc	r9, r19
    6a8e:	09 f0       	breq	.+2      	; 0x6a92 <MB_M_Timer_ISR+0x500>
    6a90:	56 ce       	rjmp	.-852    	; 0x673e <MB_M_Timer_ISR+0x1ac>
		return 1;
	uint16_t *Reg = LastProcSingle ?
		MB_SingleQuery[MB_N].Buf
	:
		(uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg))+prw(&Query->AllocAddr);
    6a92:	80 91 e0 04 	lds	r24, 0x04E0
    6a96:	88 23       	and	r24, r24
    6a98:	09 f4       	brne	.+2      	; 0x6a9c <MB_M_Timer_ISR+0x50a>
    6a9a:	5e c0       	rjmp	.+188    	; 0x6b58 <MB_M_Timer_ISR+0x5c6>
    6a9c:	fe 01       	movw	r30, r28
    6a9e:	ee 0f       	add	r30, r30
    6aa0:	ff 1f       	adc	r31, r31
    6aa2:	ee 0f       	add	r30, r30
    6aa4:	ff 1f       	adc	r31, r31
    6aa6:	ee 0f       	add	r30, r30
    6aa8:	ff 1f       	adc	r31, r31
    6aaa:	e8 52       	subi	r30, 0x28	; 40
    6aac:	fb 4f       	sbci	r31, 0xFB	; 251
    6aae:	26 81       	ldd	r18, Z+6	; 0x06
    6ab0:	37 81       	ldd	r19, Z+7	; 0x07
	for (int8_t j=MB_Frame[MB_N][2]/2-1; j>=0; j--) {
    6ab2:	4b 2f       	mov	r20, r27
    6ab4:	46 95       	lsr	r20
    6ab6:	41 50       	subi	r20, 0x01	; 1
    6ab8:	47 fd       	sbrc	r20, 7
    6aba:	97 ce       	rjmp	.-722    	; 0x67ea <MB_M_Timer_ISR+0x258>
    6abc:	84 2f       	mov	r24, r20
    6abe:	99 27       	eor	r25, r25
    6ac0:	87 fd       	sbrc	r24, 7
    6ac2:	90 95       	com	r25
    6ac4:	88 0f       	add	r24, r24
    6ac6:	99 1f       	adc	r25, r25
    6ac8:	58 2f       	mov	r21, r24
    6aca:	5d 5f       	subi	r21, 0xFD	; 253
    6acc:	28 0f       	add	r18, r24
    6ace:	39 1f       	adc	r19, r25
		int8_t i = j*2;
		Reg[j] = MB_FrameReg(MB_N, 3+i);
    6ad0:	83 e2       	ldi	r24, 0x23	; 35
    6ad2:	88 2e       	mov	r8, r24
    6ad4:	8b e0       	ldi	r24, 0x0B	; 11
    6ad6:	98 2e       	mov	r9, r24
    6ad8:	8c 0c       	add	r8, r12
    6ada:	9d 1c       	adc	r9, r13
    6adc:	e5 2f       	mov	r30, r21
    6ade:	f0 e0       	ldi	r31, 0x00	; 0
    6ae0:	d4 01       	movw	r26, r8
    6ae2:	ae 0f       	add	r26, r30
    6ae4:	bf 1f       	adc	r27, r31
    6ae6:	11 96       	adiw	r26, 0x01	; 1
    6ae8:	8c 91       	ld	r24, X
    6aea:	90 e0       	ldi	r25, 0x00	; 0
    6aec:	ec 0d       	add	r30, r12
    6aee:	fd 1d       	adc	r31, r13
    6af0:	ed 5d       	subi	r30, 0xDD	; 221
    6af2:	f4 4f       	sbci	r31, 0xF4	; 244
    6af4:	f0 81       	ld	r31, Z
    6af6:	e0 e0       	ldi	r30, 0x00	; 0
    6af8:	8e 2b       	or	r24, r30
    6afa:	9f 2b       	or	r25, r31
    6afc:	d9 01       	movw	r26, r18
    6afe:	8d 93       	st	X+, r24
    6b00:	9c 93       	st	X, r25
		return 1;
	uint16_t *Reg = LastProcSingle ?
		MB_SingleQuery[MB_N].Buf
	:
		(uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg))+prw(&Query->AllocAddr);
	for (int8_t j=MB_Frame[MB_N][2]/2-1; j>=0; j--) {
    6b02:	41 50       	subi	r20, 0x01	; 1
    6b04:	52 50       	subi	r21, 0x02	; 2
    6b06:	22 50       	subi	r18, 0x02	; 2
    6b08:	30 40       	sbci	r19, 0x00	; 0
    6b0a:	47 ff       	sbrs	r20, 7
    6b0c:	e7 cf       	rjmp	.-50     	; 0x6adc <MB_M_Timer_ISR+0x54a>
    6b0e:	6d ce       	rjmp	.-806    	; 0x67ea <MB_M_Timer_ISR+0x258>
			else if (LastProcSingle)
				MB_SingleState[MB_N] = MB_SingleIdle;
			else {
				SlaveOff[MB_N] &=~((uint32_t)1<<CurrSlave[MB_N]);
				if (++CurrQuery[MB_N]==prb(&Slave->QueryQt))
					Over = NextSlave(MB_N);
    6b10:	81 2f       	mov	r24, r17
    6b12:	0e 94 80 31 	call	0x6300	; 0x6300 <NextSlave>
    6b16:	98 2f       	mov	r25, r24
    6b18:	a7 ce       	rjmp	.-690    	; 0x6868 <MB_M_Timer_ISR+0x2d6>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    6b1a:	ca 01       	movw	r24, r20
    6b1c:	03 96       	adiw	r24, 0x03	; 3
    6b1e:	fc 01       	movw	r30, r24
    6b20:	25 91       	lpm	r18, Z+
    6b22:	34 91       	lpm	r19, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_M_ReadReg(uint8_t MB_N, MB_Query *Query)
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || (LastProcSingle?MB_SingleQuery[MB_N].Qt:prw(&Query->Qt))*2!=MB_Frame[MB_N][2])
    6b24:	22 0f       	add	r18, r18
    6b26:	33 1f       	adc	r19, r19
    6b28:	b0 cf       	rjmp	.-160    	; 0x6a8a <MB_M_Timer_ISR+0x4f8>
	if (LastProcSingle) {
		Discr = MB_SingleQuery[MB_N].Buf;
		Pin = 0;
	}
	else {
		Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
    6b2a:	a1 30       	cpi	r26, 0x01	; 1
    6b2c:	59 f1       	breq	.+86     	; 0x6b84 <MB_M_Timer_ISR+0x5f2>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6b2e:	f7 01       	movw	r30, r14
    6b30:	ee 0f       	add	r30, r30
    6b32:	ff 1f       	adc	r31, r31
    6b34:	ee 0f       	add	r30, r30
    6b36:	ff 1f       	adc	r31, r31
    6b38:	ec 5c       	subi	r30, 0xCC	; 204
    6b3a:	fc 4f       	sbci	r31, 0xFC	; 252
    6b3c:	85 91       	lpm	r24, Z+
    6b3e:	94 91       	lpm	r25, Z+
    6b40:	e8 2f       	mov	r30, r24
    6b42:	89 2f       	mov	r24, r25
    6b44:	2e 2f       	mov	r18, r30
    6b46:	38 2f       	mov	r19, r24
    6b48:	c9 01       	movw	r24, r18
    6b4a:	4c 01       	movw	r8, r24

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    6b4c:	fa 01       	movw	r30, r20
    6b4e:	35 96       	adiw	r30, 0x05	; 5
    6b50:	85 91       	lpm	r24, Z+
    6b52:	94 91       	lpm	r25, Z+
		Pin = prw(&Query->AllocAddr);
    6b54:	08 2f       	mov	r16, r24
    6b56:	d8 ce       	rjmp	.-592    	; 0x6908 <MB_M_Timer_ISR+0x376>
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || (LastProcSingle?MB_SingleQuery[MB_N].Qt:prw(&Query->Qt))*2!=MB_Frame[MB_N][2])
		return 1;
	uint16_t *Reg = LastProcSingle ?
		MB_SingleQuery[MB_N].Buf
	:
		(uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg))+prw(&Query->AllocAddr);
    6b58:	a3 30       	cpi	r26, 0x03	; 3
    6b5a:	11 f1       	breq	.+68     	; 0x6ba0 <MB_M_Timer_ISR+0x60e>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6b5c:	fe 01       	movw	r30, r28
    6b5e:	e2 95       	swap	r30
    6b60:	f2 95       	swap	r31
    6b62:	f0 7f       	andi	r31, 0xF0	; 240
    6b64:	fe 27       	eor	r31, r30
    6b66:	e0 7f       	andi	r30, 0xF0	; 240
    6b68:	fe 27       	eor	r31, r30
    6b6a:	e4 5c       	subi	r30, 0xC4	; 196
    6b6c:	fc 4f       	sbci	r31, 0xFC	; 252
    6b6e:	85 91       	lpm	r24, Z+
    6b70:	94 91       	lpm	r25, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    6b72:	fa 01       	movw	r30, r20
    6b74:	35 96       	adiw	r30, 0x05	; 5
    6b76:	25 91       	lpm	r18, Z+
    6b78:	34 91       	lpm	r19, Z+
    6b7a:	22 0f       	add	r18, r18
    6b7c:	33 1f       	adc	r19, r19
    6b7e:	28 0f       	add	r18, r24
    6b80:	39 1f       	adc	r19, r25
    6b82:	97 cf       	rjmp	.-210    	; 0x6ab2 <MB_M_Timer_ISR+0x520>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6b84:	fe 01       	movw	r30, r28
    6b86:	e2 95       	swap	r30
    6b88:	f2 95       	swap	r31
    6b8a:	f0 7f       	andi	r31, 0xF0	; 240
    6b8c:	fe 27       	eor	r31, r30
    6b8e:	e0 7f       	andi	r30, 0xF0	; 240
    6b90:	fe 27       	eor	r31, r30
    6b92:	e0 5d       	subi	r30, 0xD0	; 208
    6b94:	fc 4f       	sbci	r31, 0xFC	; 252
    6b96:	85 91       	lpm	r24, Z+
    6b98:	94 91       	lpm	r25, Z+
    6b9a:	e8 2f       	mov	r30, r24
    6b9c:	89 2f       	mov	r24, r25
    6b9e:	d2 cf       	rjmp	.-92     	; 0x6b44 <MB_M_Timer_ISR+0x5b2>

// ~~~~~~~~~~~~~~~~~~
void
MB_M_Tx(uint8_t MB_N)
{
	StartTimer16(TD_MB_Idle+MB_N, MB_M_Timeout[MB_N]);
    6ba0:	fe 01       	movw	r30, r28
    6ba2:	ee 0f       	add	r30, r30
    6ba4:	ff 1f       	adc	r31, r31
    6ba6:	ee 0f       	add	r30, r30
    6ba8:	ff 1f       	adc	r31, r31
    6baa:	ee 0f       	add	r30, r30
    6bac:	ff 1f       	adc	r31, r31
    6bae:	ee 0f       	add	r30, r30
    6bb0:	ff 1f       	adc	r31, r31
    6bb2:	e8 5c       	subi	r30, 0xC8	; 200
    6bb4:	fc 4f       	sbci	r31, 0xFC	; 252
    6bb6:	85 91       	lpm	r24, Z+
    6bb8:	94 91       	lpm	r25, Z+
    6bba:	db cf       	rjmp	.-74     	; 0x6b72 <MB_M_Timer_ISR+0x5e0>

00006bbc <MB_M_Tx>:
    6bbc:	90 91 e6 04 	lds	r25, 0x04E6
    6bc0:	e1 ee       	ldi	r30, 0xE1	; 225
    6bc2:	f8 e0       	ldi	r31, 0x08	; 8
    6bc4:	e8 0f       	add	r30, r24
    6bc6:	f1 1d       	adc	r31, r1
    6bc8:	60 81       	ld	r22, Z
    6bca:	89 0f       	add	r24, r25
    6bcc:	70 e0       	ldi	r23, 0x00	; 0
    6bce:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
}
    6bd2:	08 95       	ret

00006bd4 <Modbus_TX>:
}

// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_TX(usart_t *usart)
{
    6bd4:	cf 92       	push	r12
    6bd6:	df 92       	push	r13
    6bd8:	ef 92       	push	r14
    6bda:	ff 92       	push	r15
    6bdc:	1f 93       	push	r17
    6bde:	cf 93       	push	r28
    6be0:	df 93       	push	r29
    6be2:	dc 01       	movw	r26, r24
    6be4:	e1 e4       	ldi	r30, 0x41	; 65
    6be6:	fe e2       	ldi	r31, 0x2E	; 46
    6be8:	85 91       	lpm	r24, Z+
    6bea:	94 91       	lpm	r25, Z+
// ~~~~~~~~~~~~~~~~~~~~~~
static uint8_t
MB_Port_N(usart_t *usart)
{
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Port[MB_N].usart_field)!=usart; MB_N++);
    6bec:	a8 17       	cp	r26, r24
    6bee:	b9 07       	cpc	r27, r25
    6bf0:	09 f4       	brne	.+2      	; 0x6bf4 <Modbus_TX+0x20>
    6bf2:	c0 c0       	rjmp	.+384    	; 0x6d74 <Modbus_TX+0x1a0>
    6bf4:	10 e0       	ldi	r17, 0x00	; 0
    6bf6:	1f 5f       	subi	r17, 0xFF	; 255
    6bf8:	c1 2f       	mov	r28, r17
    6bfa:	d0 e0       	ldi	r29, 0x00	; 0
    6bfc:	ce 01       	movw	r24, r28
    6bfe:	88 0f       	add	r24, r24
    6c00:	99 1f       	adc	r25, r25
    6c02:	88 0f       	add	r24, r24
    6c04:	99 1f       	adc	r25, r25
    6c06:	fc 01       	movw	r30, r24
    6c08:	ee 0f       	add	r30, r30
    6c0a:	ff 1f       	adc	r31, r31
    6c0c:	ee 0f       	add	r30, r30
    6c0e:	ff 1f       	adc	r31, r31
    6c10:	e8 0f       	add	r30, r24
    6c12:	f9 1f       	adc	r31, r25
    6c14:	ef 5b       	subi	r30, 0xBF	; 191
    6c16:	f1 4d       	sbci	r31, 0xD1	; 209
    6c18:	85 91       	lpm	r24, Z+
    6c1a:	94 91       	lpm	r25, Z+
    6c1c:	a8 17       	cp	r26, r24
    6c1e:	b9 07       	cpc	r27, r25
    6c20:	51 f7       	brne	.-44     	; 0x6bf6 <Modbus_TX+0x22>
void
Modbus_TX(usart_t *usart)
{
	uint8_t MB_N = MB_Port_N(usart);
	static uint8_t Count[Modbus_Qt];
	if (Count[MB_N] == MB_Frame_Sz[MB_N]-2){
    6c22:	24 ee       	ldi	r18, 0xE4	; 228
    6c24:	c2 2e       	mov	r12, r18
    6c26:	22 e0       	ldi	r18, 0x02	; 2
    6c28:	d2 2e       	mov	r13, r18
    6c2a:	cc 0e       	add	r12, r28
    6c2c:	dd 1e       	adc	r13, r29
    6c2e:	f6 01       	movw	r30, r12
    6c30:	50 81       	ld	r21, Z
    6c32:	be 01       	movw	r22, r28
    6c34:	6b 5f       	subi	r22, 0xFB	; 251
    6c36:	78 4f       	sbci	r23, 0xF8	; 248
    6c38:	fb 01       	movw	r30, r22
    6c3a:	40 81       	ld	r20, Z
    6c3c:	25 2f       	mov	r18, r21
    6c3e:	30 e0       	ldi	r19, 0x00	; 0
    6c40:	84 2f       	mov	r24, r20
    6c42:	90 e0       	ldi	r25, 0x00	; 0
    6c44:	02 97       	sbiw	r24, 0x02	; 2
    6c46:	28 17       	cp	r18, r24
    6c48:	39 07       	cpc	r19, r25
    6c4a:	09 f4       	brne	.+2      	; 0x6c4e <Modbus_TX+0x7a>
    6c4c:	55 c0       	rjmp	.+170    	; 0x6cf8 <Modbus_TX+0x124>
		USART_Reg(MB_N, ucsrb) &=~(1<<5);
		USART_Reg(MB_N, ucsrb) |=(1<<6);
		USART_Reg(MB_N, ucsra) |=(1<<6);	//Clear TxC pending interrupt		
	}
	if (++Count[MB_N]<MB_Frame_Sz[MB_N]) {
    6c4e:	25 2f       	mov	r18, r21
    6c50:	2f 5f       	subi	r18, 0xFF	; 255
    6c52:	f6 01       	movw	r30, r12
    6c54:	20 83       	st	Z, r18
    6c56:	24 17       	cp	r18, r20
    6c58:	80 f4       	brcc	.+32     	; 0x6c7a <Modbus_TX+0xa6>
		usart_data(usart) = MB_Frame[MB_N][Count[MB_N]];
    6c5a:	fc 2f       	mov	r31, r28
    6c5c:	ee 27       	eor	r30, r30
    6c5e:	e2 0f       	add	r30, r18
    6c60:	f1 1d       	adc	r31, r1
    6c62:	ed 5d       	subi	r30, 0xDD	; 221
    6c64:	f4 4f       	sbci	r31, 0xF4	; 244
    6c66:	80 81       	ld	r24, Z
    6c68:	8c 93       	st	X, r24
		break;
	case Role_Master:
		MB_M_Tx(MB_N);
		break;
	}
}
    6c6a:	df 91       	pop	r29
    6c6c:	cf 91       	pop	r28
    6c6e:	1f 91       	pop	r17
    6c70:	ff 90       	pop	r15
    6c72:	ef 90       	pop	r14
    6c74:	df 90       	pop	r13
    6c76:	cf 90       	pop	r12
    6c78:	08 95       	ret
    6c7a:	9e 01       	movw	r18, r28
    6c7c:	22 0f       	add	r18, r18
    6c7e:	33 1f       	adc	r19, r19
    6c80:	22 0f       	add	r18, r18
    6c82:	33 1f       	adc	r19, r19
    6c84:	c9 01       	movw	r24, r18
    6c86:	8c 0f       	add	r24, r28
    6c88:	9d 1f       	adc	r25, r29
    6c8a:	88 0f       	add	r24, r24
    6c8c:	99 1f       	adc	r25, r25
    6c8e:	88 0f       	add	r24, r24
    6c90:	99 1f       	adc	r25, r25
    6c92:	8b 5b       	subi	r24, 0xBB	; 187
    6c94:	91 4d       	sbci	r25, 0xD1	; 209
    6c96:	fc 01       	movw	r30, r24
    6c98:	a5 91       	lpm	r26, Z+
    6c9a:	b4 91       	lpm	r27, Z+
	}

	void MB_S_Tx(uint8_t);
	void MB_M_Tx(uint8_t);
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		USART_Reg(MB_N, ucsrb) &=~((1<<6)|(1<<5)); 	// .  USART Data Register Empty Interrupt
    6c9c:	8c 91       	ld	r24, X
    6c9e:	8f 79       	andi	r24, 0x9F	; 159
    6ca0:	8c 93       	st	X, r24
    6ca2:	79 01       	movw	r14, r18
    6ca4:	ee 0c       	add	r14, r14
    6ca6:	ff 1c       	adc	r15, r15
    6ca8:	ee 0c       	add	r14, r14
    6caa:	ff 1c       	adc	r15, r15
    6cac:	e2 0e       	add	r14, r18
    6cae:	f3 1e       	adc	r15, r19
    6cb0:	c7 01       	movw	r24, r14
    6cb2:	83 5b       	subi	r24, 0xB3	; 179
    6cb4:	91 4d       	sbci	r25, 0xD1	; 209
    6cb6:	fc 01       	movw	r30, r24
    6cb8:	25 91       	lpm	r18, Z+
    6cba:	34 91       	lpm	r19, Z+
	#elif defined (__AVR_ATxmega128A1__)
		usart->CTRLA = (usart->CTRLA &~USART_TXCINTLVL_gm) |USART_TXCINTLVL_OFF_gc;
	#endif
	USART_Func(MB_N, RS485);
    6cbc:	f9 01       	movw	r30, r18
    6cbe:	19 95       	eicall
	Count[MB_N] = 0;
    6cc0:	f6 01       	movw	r30, r12
    6cc2:	10 82       	st	Z, r1
	//StartTime3_5();
	MB_State[MB_N] = MB_Idle;
    6cc4:	c0 54       	subi	r28, 0x40	; 64
    6cc6:	da 4f       	sbci	r29, 0xFA	; 250
    6cc8:	81 e0       	ldi	r24, 0x01	; 1
    6cca:	88 83       	st	Y, r24

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    6ccc:	e1 2f       	mov	r30, r17
    6cce:	f0 e0       	ldi	r31, 0x00	; 0
    6cd0:	eb 5a       	subi	r30, 0xAB	; 171
    6cd2:	f1 4d       	sbci	r31, 0xD1	; 209
    6cd4:	84 91       	lpm	r24, Z+
	switch (prb(MB_Role+MB_N)) {
    6cd6:	88 23       	and	r24, r24
    6cd8:	09 f4       	brne	.+2      	; 0x6cdc <Modbus_TX+0x108>
    6cda:	3c c0       	rjmp	.+120    	; 0x6d54 <Modbus_TX+0x180>
    6cdc:	81 30       	cpi	r24, 0x01	; 1
    6cde:	09 f0       	breq	.+2      	; 0x6ce2 <Modbus_TX+0x10e>
    6ce0:	c4 cf       	rjmp	.-120    	; 0x6c6a <Modbus_TX+0x96>
	case Role_Slave:
		MB_S_Tx(MB_N);
		break;
	case Role_Master:
		MB_M_Tx(MB_N);
    6ce2:	81 2f       	mov	r24, r17
    6ce4:	0e 94 de 35 	call	0x6bbc	; 0x6bbc <MB_M_Tx>
		break;
	}
}
    6ce8:	df 91       	pop	r29
    6cea:	cf 91       	pop	r28
    6cec:	1f 91       	pop	r17
    6cee:	ff 90       	pop	r15
    6cf0:	ef 90       	pop	r14
    6cf2:	df 90       	pop	r13
    6cf4:	cf 90       	pop	r12
    6cf6:	08 95       	ret

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6cf8:	fe 01       	movw	r30, r28
    6cfa:	ee 0f       	add	r30, r30
    6cfc:	ff 1f       	adc	r31, r31
    6cfe:	ee 0f       	add	r30, r30
    6d00:	ff 1f       	adc	r31, r31
    6d02:	ec 0f       	add	r30, r28
    6d04:	fd 1f       	adc	r31, r29
    6d06:	ee 0f       	add	r30, r30
    6d08:	ff 1f       	adc	r31, r31
    6d0a:	ee 0f       	add	r30, r30
    6d0c:	ff 1f       	adc	r31, r31
    6d0e:	eb 5b       	subi	r30, 0xBB	; 187
    6d10:	f1 4d       	sbci	r31, 0xD1	; 209
    6d12:	25 91       	lpm	r18, Z+
    6d14:	34 91       	lpm	r19, Z+
Modbus_TX(usart_t *usart)
{
	uint8_t MB_N = MB_Port_N(usart);
	static uint8_t Count[Modbus_Qt];
	if (Count[MB_N] == MB_Frame_Sz[MB_N]-2){
		USART_Reg(MB_N, ucsrb) &=~(1<<5);
    6d16:	f9 01       	movw	r30, r18
    6d18:	80 81       	ld	r24, Z
    6d1a:	8f 7d       	andi	r24, 0xDF	; 223
		USART_Reg(MB_N, ucsrb) |=(1<<6);
    6d1c:	80 64       	ori	r24, 0x40	; 64
    6d1e:	80 83       	st	Z, r24
    6d20:	9e 01       	movw	r18, r28
    6d22:	22 0f       	add	r18, r18
    6d24:	33 1f       	adc	r19, r19
    6d26:	ce 01       	movw	r24, r28
    6d28:	88 0f       	add	r24, r24
    6d2a:	99 1f       	adc	r25, r25
    6d2c:	88 0f       	add	r24, r24
    6d2e:	99 1f       	adc	r25, r25
    6d30:	88 0f       	add	r24, r24
    6d32:	99 1f       	adc	r25, r25
    6d34:	28 0f       	add	r18, r24
    6d36:	39 1f       	adc	r19, r25
    6d38:	22 0f       	add	r18, r18
    6d3a:	33 1f       	adc	r19, r19
    6d3c:	2d 5b       	subi	r18, 0xBD	; 189
    6d3e:	31 4d       	sbci	r19, 0xD1	; 209
    6d40:	f9 01       	movw	r30, r18
    6d42:	e5 90       	lpm	r14, Z+
    6d44:	f4 90       	lpm	r15, Z+
		USART_Reg(MB_N, ucsra) |=(1<<6);	//Clear TxC pending interrupt		
    6d46:	f7 01       	movw	r30, r14
    6d48:	80 81       	ld	r24, Z
    6d4a:	80 64       	ori	r24, 0x40	; 64
    6d4c:	80 83       	st	Z, r24
    6d4e:	fb 01       	movw	r30, r22
    6d50:	40 81       	ld	r20, Z
    6d52:	7d cf       	rjmp	.-262    	; 0x6c4e <Modbus_TX+0x7a>
    6d54:	c7 01       	movw	r24, r14
    6d56:	81 5b       	subi	r24, 0xB1	; 177
    6d58:	91 4d       	sbci	r25, 0xD1	; 209
    6d5a:	fc 01       	movw	r30, r24
    6d5c:	25 91       	lpm	r18, Z+
    6d5e:	34 91       	lpm	r19, Z+

// ~~~~~~~~~~~~~~~~~~
void
MB_S_Tx(uint8_t MB_N)
{
	USART_Func(MB_N, LED);
    6d60:	f9 01       	movw	r30, r18
    6d62:	19 95       	eicall
		break;
	case Role_Master:
		MB_M_Tx(MB_N);
		break;
	}
}
    6d64:	df 91       	pop	r29
    6d66:	cf 91       	pop	r28
    6d68:	1f 91       	pop	r17
    6d6a:	ff 90       	pop	r15
    6d6c:	ef 90       	pop	r14
    6d6e:	df 90       	pop	r13
    6d70:	cf 90       	pop	r12
    6d72:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~
static uint8_t
MB_Port_N(usart_t *usart)
{
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Port[MB_N].usart_field)!=usart; MB_N++);
    6d74:	10 e0       	ldi	r17, 0x00	; 0
    6d76:	c0 e0       	ldi	r28, 0x00	; 0
    6d78:	d0 e0       	ldi	r29, 0x00	; 0
    6d7a:	53 cf       	rjmp	.-346    	; 0x6c22 <Modbus_TX+0x4e>

00006d7c <MB_SingleRun>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_SingleRun(uint8_t MB_N, uint8_t Addr, uint8_t Func, uint16_t StartAddr, uint16_t Qt, void *Buf)
{
    6d7c:	df 92       	push	r13
    6d7e:	ef 92       	push	r14
    6d80:	ff 92       	push	r15
    6d82:	0f 93       	push	r16
    6d84:	1f 93       	push	r17
    6d86:	cf 93       	push	r28
    6d88:	df 93       	push	r29
    6d8a:	d8 2e       	mov	r13, r24
    6d8c:	94 2f       	mov	r25, r20
    6d8e:	a9 01       	movw	r20, r18
	if (MB_SingleState[MB_N]!=MB_SingleIdle)
    6d90:	c8 2f       	mov	r28, r24
    6d92:	d0 e0       	ldi	r29, 0x00	; 0
    6d94:	9e 01       	movw	r18, r28
    6d96:	23 55       	subi	r18, 0x53	; 83
    6d98:	39 4f       	sbci	r19, 0xF9	; 249
    6d9a:	f9 01       	movw	r30, r18
    6d9c:	80 81       	ld	r24, Z
    6d9e:	88 23       	and	r24, r24
    6da0:	91 f5       	brne	.+100    	; 0x6e06 <MB_SingleRun+0x8a>
		return;

	MB_SingleQuery[MB_N].Addr				= Addr;
    6da2:	de 01       	movw	r26, r28
    6da4:	aa 0f       	add	r26, r26
    6da6:	bb 1f       	adc	r27, r27
    6da8:	aa 0f       	add	r26, r26
    6daa:	bb 1f       	adc	r27, r27
    6dac:	aa 0f       	add	r26, r26
    6dae:	bb 1f       	adc	r27, r27
    6db0:	a8 52       	subi	r26, 0x28	; 40
    6db2:	bb 4f       	sbci	r27, 0xFB	; 251
    6db4:	6c 93       	st	X, r22
	MB_SingleQuery[MB_N].Func				= Func;
    6db6:	11 96       	adiw	r26, 0x01	; 1
    6db8:	9c 93       	st	X, r25
    6dba:	11 97       	sbiw	r26, 0x01	; 1
	MB_SingleQuery[MB_N].StartAddr	= StartAddr;
    6dbc:	be 01       	movw	r22, r28
    6dbe:	66 0f       	add	r22, r22
    6dc0:	77 1f       	adc	r23, r23
    6dc2:	66 0f       	add	r22, r22
    6dc4:	77 1f       	adc	r23, r23
    6dc6:	fb 01       	movw	r30, r22
    6dc8:	ee 0f       	add	r30, r30
    6dca:	ff 1f       	adc	r31, r31
    6dcc:	e6 52       	subi	r30, 0x26	; 38
    6dce:	fb 4f       	sbci	r31, 0xFB	; 251
    6dd0:	51 83       	std	Z+1, r21	; 0x01
    6dd2:	40 83       	st	Z, r20
	MB_SingleQuery[MB_N].Qt					= Qt;
    6dd4:	ae 01       	movw	r20, r28
    6dd6:	44 0f       	add	r20, r20
    6dd8:	55 1f       	adc	r21, r21
    6dda:	fa 01       	movw	r30, r20
    6ddc:	ee 0f       	add	r30, r30
    6dde:	ff 1f       	adc	r31, r31
    6de0:	ee 0f       	add	r30, r30
    6de2:	ff 1f       	adc	r31, r31
    6de4:	e4 52       	subi	r30, 0x24	; 36
    6de6:	fb 4f       	sbci	r31, 0xFB	; 251
    6de8:	11 83       	std	Z+1, r17	; 0x01
    6dea:	00 83       	st	Z, r16
	MB_SingleQuery[MB_N].Buf				= Buf;
    6dec:	17 96       	adiw	r26, 0x07	; 7
    6dee:	fc 92       	st	X, r15
    6df0:	ee 92       	st	-X, r14
    6df2:	16 97       	sbiw	r26, 0x06	; 6

	MB_SingleState[MB_N] = MB_SingleStart;
    6df4:	81 e0       	ldi	r24, 0x01	; 1
    6df6:	f9 01       	movw	r30, r18
    6df8:	80 83       	st	Z, r24
	if (MB_State[MB_N]==MB_Proc && !LastProcSingle) {
    6dfa:	fe 01       	movw	r30, r28
    6dfc:	e0 54       	subi	r30, 0x40	; 64
    6dfe:	fa 4f       	sbci	r31, 0xFA	; 250
    6e00:	80 81       	ld	r24, Z
    6e02:	84 30       	cpi	r24, 0x04	; 4
    6e04:	41 f0       	breq	.+16     	; 0x6e16 <MB_SingleRun+0x9a>
			IntOff();
			MB_Transm(MB_N);
			IntOn();
		}
	}
}
    6e06:	df 91       	pop	r29
    6e08:	cf 91       	pop	r28
    6e0a:	1f 91       	pop	r17
    6e0c:	0f 91       	pop	r16
    6e0e:	ff 90       	pop	r15
    6e10:	ef 90       	pop	r14
    6e12:	df 90       	pop	r13
    6e14:	08 95       	ret
	MB_SingleQuery[MB_N].StartAddr	= StartAddr;
	MB_SingleQuery[MB_N].Qt					= Qt;
	MB_SingleQuery[MB_N].Buf				= Buf;

	MB_SingleState[MB_N] = MB_SingleStart;
	if (MB_State[MB_N]==MB_Proc && !LastProcSingle) {
    6e16:	80 91 e0 04 	lds	r24, 0x04E0
    6e1a:	88 23       	and	r24, r24
    6e1c:	a1 f7       	brne	.-24     	; 0x6e06 <MB_SingleRun+0x8a>
		uint16_t T = (CurrSlave[MB_N]==0 ? MB_M_Period[MB_N] : MB_M_Timeout[MB_N]) - GetTimer16(TD_MB_Idle+MB_N);
    6e1e:	fe 01       	movw	r30, r28
    6e20:	ee 5a       	subi	r30, 0xAE	; 174
    6e22:	f9 4f       	sbci	r31, 0xF9	; 249
    6e24:	80 81       	ld	r24, Z
    6e26:	88 23       	and	r24, r24
    6e28:	09 f0       	breq	.+2      	; 0x6e2c <MB_SingleRun+0xb0>
    6e2a:	4d c0       	rjmp	.+154    	; 0x6ec6 <MB_SingleRun+0x14a>
    6e2c:	45 55       	subi	r20, 0x55	; 85
    6e2e:	59 4f       	sbci	r21, 0xF9	; 249
    6e30:	fa 01       	movw	r30, r20
    6e32:	40 81       	ld	r20, Z
    6e34:	51 81       	ldd	r21, Z+1	; 0x01
    6e36:	20 91 e6 04 	lds	r18, 0x04E6
    6e3a:	2d 0d       	add	r18, r13

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    6e3c:	8f b7       	in	r24, 0x3f	; 63
    6e3e:	80 78       	andi	r24, 0x80	; 128
    6e40:	80 93 ec 02 	sts	0x02EC, r24
	cli();
    6e44:	f8 94       	cli
    6e46:	e2 2f       	mov	r30, r18
    6e48:	f0 e0       	ldi	r31, 0x00	; 0
    6e4a:	ee 0f       	add	r30, r30
    6e4c:	ff 1f       	adc	r31, r31
    6e4e:	e3 5b       	subi	r30, 0xB3	; 179
    6e50:	fc 4f       	sbci	r31, 0xFC	; 252
    6e52:	a0 81       	ld	r26, Z
    6e54:	b1 81       	ldd	r27, Z+1	; 0x01

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    6e56:	88 23       	and	r24, r24
    6e58:	09 f0       	breq	.+2      	; 0x6e5c <MB_SingleRun+0xe0>
		sei();
    6e5a:	78 94       	sei
    6e5c:	ca 01       	movw	r24, r20
    6e5e:	8a 1b       	sub	r24, r26
    6e60:	9b 0b       	sbc	r25, r27
		if (T<MB_M_Pause_Min)
    6e62:	85 30       	cpi	r24, 0x05	; 5
    6e64:	91 05       	cpc	r25, r1
    6e66:	a8 f1       	brcs	.+106    	; 0x6ed2 <MB_SingleRun+0x156>

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    6e68:	8f b7       	in	r24, 0x3f	; 63
    6e6a:	80 78       	andi	r24, 0x80	; 128
    6e6c:	80 93 ec 02 	sts	0x02EC, r24
	cli();
    6e70:	f8 94       	cli
    6e72:	cb 01       	movw	r24, r22
    6e74:	88 0f       	add	r24, r24
    6e76:	99 1f       	adc	r25, r25
    6e78:	88 0f       	add	r24, r24
    6e7a:	99 1f       	adc	r25, r25
    6e7c:	86 0f       	add	r24, r22
    6e7e:	97 1f       	adc	r25, r23
    6e80:	81 5b       	subi	r24, 0xB1	; 177
    6e82:	91 4d       	sbci	r25, 0xD1	; 209
    6e84:	fc 01       	movw	r30, r24
    6e86:	25 91       	lpm	r18, Z+
    6e88:	34 91       	lpm	r19, Z+
			StartTimer16(TD_MB_Idle+MB_N, MB_M_Pause_Min-T);
		else {
			IntOff();
			USART_Func(MB_N, LED);
    6e8a:	f9 01       	movw	r30, r18
    6e8c:	19 95       	eicall

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    6e8e:	80 91 ec 02 	lds	r24, 0x02EC
    6e92:	88 23       	and	r24, r24
    6e94:	09 f0       	breq	.+2      	; 0x6e98 <MB_SingleRun+0x11c>
		sei();
    6e96:	78 94       	sei
			IntOn();
			ResetTimer16(TD_MB_Idle+MB_N);
    6e98:	80 91 e6 04 	lds	r24, 0x04E6
    6e9c:	8d 0d       	add	r24, r13
    6e9e:	0e 94 1b 1d 	call	0x3a36	; 0x3a36 <ResetTimer16>
			FormSingle(MB_N);
    6ea2:	8d 2d       	mov	r24, r13
    6ea4:	0e 94 3e 31 	call	0x627c	; 0x627c <FormSingle>

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    6ea8:	8f b7       	in	r24, 0x3f	; 63
    6eaa:	80 78       	andi	r24, 0x80	; 128
    6eac:	80 93 ec 02 	sts	0x02EC, r24
	cli();
    6eb0:	f8 94       	cli
			IntOff();
			MB_Transm(MB_N);
    6eb2:	8d 2d       	mov	r24, r13
    6eb4:	0e 94 e4 29 	call	0x53c8	; 0x53c8 <MB_Transm>

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    6eb8:	80 91 ec 02 	lds	r24, 0x02EC
    6ebc:	88 23       	and	r24, r24
    6ebe:	09 f4       	brne	.+2      	; 0x6ec2 <MB_SingleRun+0x146>
    6ec0:	a2 cf       	rjmp	.-188    	; 0x6e06 <MB_SingleRun+0x8a>
		sei();
    6ec2:	78 94       	sei
    6ec4:	a0 cf       	rjmp	.-192    	; 0x6e06 <MB_SingleRun+0x8a>
	MB_SingleQuery[MB_N].Qt					= Qt;
	MB_SingleQuery[MB_N].Buf				= Buf;

	MB_SingleState[MB_N] = MB_SingleStart;
	if (MB_State[MB_N]==MB_Proc && !LastProcSingle) {
		uint16_t T = (CurrSlave[MB_N]==0 ? MB_M_Period[MB_N] : MB_M_Timeout[MB_N]) - GetTimer16(TD_MB_Idle+MB_N);
    6ec6:	cf 51       	subi	r28, 0x1F	; 31
    6ec8:	d7 4f       	sbci	r29, 0xF7	; 247
    6eca:	88 81       	ld	r24, Y
    6ecc:	48 2f       	mov	r20, r24
    6ece:	50 e0       	ldi	r21, 0x00	; 0
    6ed0:	b2 cf       	rjmp	.-156    	; 0x6e36 <MB_SingleRun+0xba>
		if (T<MB_M_Pause_Min)
			StartTimer16(TD_MB_Idle+MB_N, MB_M_Pause_Min-T);
    6ed2:	65 e0       	ldi	r22, 0x05	; 5
    6ed4:	70 e0       	ldi	r23, 0x00	; 0
    6ed6:	68 1b       	sub	r22, r24
    6ed8:	79 0b       	sbc	r23, r25
    6eda:	82 2f       	mov	r24, r18
    6edc:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
    6ee0:	92 cf       	rjmp	.-220    	; 0x6e06 <MB_SingleRun+0x8a>

00006ee2 <MB_Master_MaxCycle_Clear>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_Master_MaxCycle_Clear(uint8_t MB_N)
{
	MB_Master_MaxCycle[MB_N] = 0;
    6ee2:	e8 2f       	mov	r30, r24
    6ee4:	f0 e0       	ldi	r31, 0x00	; 0
    6ee6:	ee 0f       	add	r30, r30
    6ee8:	ff 1f       	adc	r31, r31
    6eea:	e4 54       	subi	r30, 0x44	; 68
    6eec:	f9 4f       	sbci	r31, 0xF9	; 249
    6eee:	11 82       	std	Z+1, r1	; 0x01
    6ef0:	10 82       	st	Z, r1
}
    6ef2:	08 95       	ret

00006ef4 <MB_M_Cycle>:

// ~~~~~~~~~~~~~~~~~~~~~
void
MB_M_Cycle(uint8_t MB_N)
{
    6ef4:	ff 92       	push	r15
    6ef6:	0f 93       	push	r16
    6ef8:	1f 93       	push	r17
    6efa:	cf 93       	push	r28
    6efc:	df 93       	push	r29
    6efe:	f8 2e       	mov	r15, r24
	if (Timer16Stopp(TD_MB_SlaveOff+MB_N))
    6f00:	10 91 e6 04 	lds	r17, 0x04E6
    6f04:	18 0f       	add	r17, r24
    6f06:	01 2f       	mov	r16, r17
    6f08:	0f 5f       	subi	r16, 0xFF	; 255
    6f0a:	80 2f       	mov	r24, r16
    6f0c:	0e 94 71 1c 	call	0x38e2	; 0x38e2 <Timer16Stopp>
    6f10:	88 23       	and	r24, r24
    6f12:	d9 f4       	brne	.+54     	; 0x6f4a <MB_M_Cycle+0x56>
		SlavesOn(MB_N);

	if (Timer16Stopp(TD_MB_Idle+MB_N)){
    6f14:	81 2f       	mov	r24, r17
    6f16:	0e 94 71 1c 	call	0x38e2	; 0x38e2 <Timer16Stopp>
    6f1a:	88 23       	and	r24, r24
    6f1c:	81 f0       	breq	.+32     	; 0x6f3e <MB_M_Cycle+0x4a>
		cli();
    6f1e:	f8 94       	cli
		if(MB_State[MB_N] == MB_Idle) MB_State[MB_N] = MB_NoReply;
    6f20:	cf 2d       	mov	r28, r15
    6f22:	d0 e0       	ldi	r29, 0x00	; 0
    6f24:	fe 01       	movw	r30, r28
    6f26:	e0 54       	subi	r30, 0x40	; 64
    6f28:	fa 4f       	sbci	r31, 0xFA	; 250
    6f2a:	80 81       	ld	r24, Z
    6f2c:	81 30       	cpi	r24, 0x01	; 1
    6f2e:	29 f1       	breq	.+74     	; 0x6f7a <MB_M_Cycle+0x86>
		sei();
    6f30:	78 94       	sei
	}
	else return;
	
	switch (MB_State[MB_N]) {
    6f32:	80 81       	ld	r24, Z
    6f34:	84 30       	cpi	r24, 0x04	; 4
    6f36:	39 f1       	breq	.+78     	; 0x6f86 <MB_M_Cycle+0x92>
    6f38:	85 30       	cpi	r24, 0x05	; 5
    6f3a:	09 f4       	brne	.+2      	; 0x6f3e <MB_M_Cycle+0x4a>
    6f3c:	52 c0       	rjmp	.+164    	; 0x6fe2 <MB_M_Cycle+0xee>
		cli();
		MB_Transm(MB_N);
		sei();
		break;
	}
}
    6f3e:	df 91       	pop	r29
    6f40:	cf 91       	pop	r28
    6f42:	1f 91       	pop	r17
    6f44:	0f 91       	pop	r16
    6f46:	ff 90       	pop	r15
    6f48:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~
static void
SlavesOn(uint8_t MB_N)
{
	SlaveSkip[MB_N] = 0;
    6f4a:	af 2d       	mov	r26, r15
    6f4c:	b0 e0       	ldi	r27, 0x00	; 0
    6f4e:	fd 01       	movw	r30, r26
    6f50:	ee 0f       	add	r30, r30
    6f52:	ff 1f       	adc	r31, r31
    6f54:	ee 0f       	add	r30, r30
    6f56:	ff 1f       	adc	r31, r31
    6f58:	ee 51       	subi	r30, 0x1E	; 30
    6f5a:	fb 4f       	sbci	r31, 0xFB	; 251
    6f5c:	10 82       	st	Z, r1
    6f5e:	11 82       	std	Z+1, r1	; 0x01
    6f60:	12 82       	std	Z+2, r1	; 0x02
    6f62:	13 82       	std	Z+3, r1	; 0x03
	StartTimer16(TD_MB_SlaveOff+MB_N, 100*MB_M_TimeOff[MB_N]);
    6f64:	a3 52       	subi	r26, 0x23	; 35
    6f66:	ba 4f       	sbci	r27, 0xFA	; 250
    6f68:	6c 91       	ld	r22, X
    6f6a:	84 e6       	ldi	r24, 0x64	; 100
    6f6c:	68 9f       	mul	r22, r24
    6f6e:	b0 01       	movw	r22, r0
    6f70:	11 24       	eor	r1, r1
    6f72:	80 2f       	mov	r24, r16
    6f74:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
    6f78:	cd cf       	rjmp	.-102    	; 0x6f14 <MB_M_Cycle+0x20>
	if (Timer16Stopp(TD_MB_SlaveOff+MB_N))
		SlavesOn(MB_N);

	if (Timer16Stopp(TD_MB_Idle+MB_N)){
		cli();
		if(MB_State[MB_N] == MB_Idle) MB_State[MB_N] = MB_NoReply;
    6f7a:	85 e0       	ldi	r24, 0x05	; 5
    6f7c:	80 83       	st	Z, r24
		sei();
    6f7e:	78 94       	sei
	}
	else return;
	
	switch (MB_State[MB_N]) {
    6f80:	80 81       	ld	r24, Z
    6f82:	84 30       	cpi	r24, 0x04	; 4
    6f84:	c9 f6       	brne	.-78     	; 0x6f38 <MB_M_Cycle+0x44>
		cli();
		MB_Transm(MB_N);
		sei();
		break;
	case MB_Proc:
		cli();
    6f86:	f8 94       	cli
    6f88:	ce 01       	movw	r24, r28
    6f8a:	88 0f       	add	r24, r24
    6f8c:	99 1f       	adc	r25, r25
    6f8e:	88 0f       	add	r24, r24
    6f90:	99 1f       	adc	r25, r25
    6f92:	9c 01       	movw	r18, r24
    6f94:	22 0f       	add	r18, r18
    6f96:	33 1f       	adc	r19, r19
    6f98:	22 0f       	add	r18, r18
    6f9a:	33 1f       	adc	r19, r19
    6f9c:	28 0f       	add	r18, r24
    6f9e:	39 1f       	adc	r19, r25
    6fa0:	21 5b       	subi	r18, 0xB1	; 177
    6fa2:	31 4d       	sbci	r19, 0xD1	; 209
    6fa4:	f9 01       	movw	r30, r18
    6fa6:	85 91       	lpm	r24, Z+
    6fa8:	94 91       	lpm	r25, Z+
		USART_Func(MB_N, LED);
    6faa:	fc 01       	movw	r30, r24
    6fac:	19 95       	eicall
		sei();
    6fae:	78 94       	sei
		switch (MB_SingleState[MB_N]) {
    6fb0:	c3 55       	subi	r28, 0x53	; 83
    6fb2:	d9 4f       	sbci	r29, 0xF9	; 249
    6fb4:	88 81       	ld	r24, Y
    6fb6:	88 23       	and	r24, r24
    6fb8:	b1 f1       	breq	.+108    	; 0x7026 <MB_M_Cycle+0x132>
    6fba:	81 30       	cpi	r24, 0x01	; 1
    6fbc:	81 f1       	breq	.+96     	; 0x701e <MB_M_Cycle+0x12a>
				FormQuery(MB_N);
			else
				FormSingle(MB_N);
			break;
		}
		StartTimer16(TD_MB_Idle+MB_N, 0xFFFF);	//     
    6fbe:	80 91 e6 04 	lds	r24, 0x04E6
    6fc2:	8f 0d       	add	r24, r15
    6fc4:	6f ef       	ldi	r22, 0xFF	; 255
    6fc6:	7f ef       	ldi	r23, 0xFF	; 255
    6fc8:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
		cli();
    6fcc:	f8 94       	cli
		MB_Transm(MB_N);
    6fce:	8f 2d       	mov	r24, r15
    6fd0:	0e 94 e4 29 	call	0x53c8	; 0x53c8 <MB_Transm>
		sei();
    6fd4:	78 94       	sei
		break;
	}
}
    6fd6:	df 91       	pop	r29
    6fd8:	cf 91       	pop	r28
    6fda:	1f 91       	pop	r17
    6fdc:	0f 91       	pop	r16
    6fde:	ff 90       	pop	r15
    6fe0:	08 95       	ret
	}
	else return;
	
	switch (MB_State[MB_N]) {
	case MB_NoReply:
		FailSlave(MB_N);
    6fe2:	8f 2d       	mov	r24, r15
    6fe4:	0e 94 53 32 	call	0x64a6	; 0x64a6 <FailSlave>
		switch (MB_SingleState[MB_N]) {
    6fe8:	fe 01       	movw	r30, r28
    6fea:	e3 55       	subi	r30, 0x53	; 83
    6fec:	f9 4f       	sbci	r31, 0xF9	; 249
    6fee:	e0 81       	ld	r30, Z
    6ff0:	ee 23       	and	r30, r30
    6ff2:	e9 f4       	brne	.+58     	; 0x702e <MB_M_Cycle+0x13a>
		case MB_SingleIdle:
			FormQuery(MB_N);
    6ff4:	8f 2d       	mov	r24, r15
    6ff6:	0e 94 ec 30 	call	0x61d8	; 0x61d8 <FormQuery>
		case MB_SingleStart:
			if (Try[MB_N]==0)
				FormSingle(MB_N);
			break;
		}
		StartTimer16(TD_MB_Idle+MB_N, 0xFFFF);	//     
    6ffa:	80 91 e6 04 	lds	r24, 0x04E6
    6ffe:	8f 0d       	add	r24, r15
    7000:	6f ef       	ldi	r22, 0xFF	; 255
    7002:	7f ef       	ldi	r23, 0xFF	; 255
    7004:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
		cli();
    7008:	f8 94       	cli
		MB_Transm(MB_N);
    700a:	8f 2d       	mov	r24, r15
    700c:	0e 94 e4 29 	call	0x53c8	; 0x53c8 <MB_Transm>
		sei();
    7010:	78 94       	sei
		cli();
		MB_Transm(MB_N);
		sei();
		break;
	}
}
    7012:	df 91       	pop	r29
    7014:	cf 91       	pop	r28
    7016:	1f 91       	pop	r17
    7018:	0f 91       	pop	r16
    701a:	ff 90       	pop	r15
    701c:	08 95       	ret
		switch (MB_SingleState[MB_N]) {
		case MB_SingleIdle:
			FormQuery(MB_N);
			break;
		case MB_SingleStart:
			if (LastProcSingle)
    701e:	80 91 e0 04 	lds	r24, 0x04E0
    7022:	88 23       	and	r24, r24
    7024:	79 f0       	breq	.+30     	; 0x7044 <MB_M_Cycle+0x150>
				FormQuery(MB_N);
    7026:	8f 2d       	mov	r24, r15
    7028:	0e 94 ec 30 	call	0x61d8	; 0x61d8 <FormQuery>
    702c:	c8 cf       	rjmp	.-112    	; 0x6fbe <MB_M_Cycle+0xca>
	else return;
	
	switch (MB_State[MB_N]) {
	case MB_NoReply:
		FailSlave(MB_N);
		switch (MB_SingleState[MB_N]) {
    702e:	e1 30       	cpi	r30, 0x01	; 1
    7030:	21 f7       	brne	.-56     	; 0x6ffa <MB_M_Cycle+0x106>
		case MB_SingleIdle:
			FormQuery(MB_N);
			break;
		case MB_SingleStart:
			if (Try[MB_N]==0)
    7032:	cf 51       	subi	r28, 0x1F	; 31
    7034:	db 4f       	sbci	r29, 0xFB	; 251
    7036:	88 81       	ld	r24, Y
    7038:	88 23       	and	r24, r24
    703a:	f9 f6       	brne	.-66     	; 0x6ffa <MB_M_Cycle+0x106>
				FormSingle(MB_N);
    703c:	8f 2d       	mov	r24, r15
    703e:	0e 94 3e 31 	call	0x627c	; 0x627c <FormSingle>
    7042:	db cf       	rjmp	.-74     	; 0x6ffa <MB_M_Cycle+0x106>
			break;
		case MB_SingleStart:
			if (LastProcSingle)
				FormQuery(MB_N);
			else
				FormSingle(MB_N);
    7044:	8f 2d       	mov	r24, r15
    7046:	0e 94 3e 31 	call	0x627c	; 0x627c <FormSingle>
    704a:	b9 cf       	rjmp	.-142    	; 0x6fbe <MB_M_Cycle+0xca>

0000704c <MB_Cycle>:
}

// ~~~~~~~~~~~
void
MB_Cycle(void)
{
    704c:	cf 93       	push	r28
    704e:	df 93       	push	r29
	void MB_S_Timer_ISR(uint8_t);
	void MB_M_Timer_ISR(uint8_t);

	for (uint8_t MB_N=0; MB_N<Modbus_Qt; MB_N++){
		if(MB_TimerFlag & (1<<MB_N)){
    7050:	80 91 e2 08 	lds	r24, 0x08E2
    7054:	80 fd       	sbrc	r24, 0
    7056:	0c c0       	rjmp	.+24     	; 0x7070 <MB_Cycle+0x24>
    7058:	c5 e5       	ldi	r28, 0x55	; 85
    705a:	de e2       	ldi	r29, 0x2E	; 46

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    705c:	fe 01       	movw	r30, r28
    705e:	84 91       	lpm	r24, Z+
	}

	void MB_M_Cycle(uint8_t);

	for (uint8_t MB_N=0; MB_N<Modbus_Qt; MB_N++)
		if (prb(MB_Role+MB_N)==Role_Master)
    7060:	81 30       	cpi	r24, 0x01	; 1
    7062:	19 f4       	brne	.+6      	; 0x706a <MB_Cycle+0x1e>
			MB_M_Cycle(MB_N);
    7064:	80 e0       	ldi	r24, 0x00	; 0
    7066:	0e 94 7a 37 	call	0x6ef4	; 0x6ef4 <MB_M_Cycle>
}
    706a:	df 91       	pop	r29
    706c:	cf 91       	pop	r28
    706e:	08 95       	ret
	void MB_S_Timer_ISR(uint8_t);
	void MB_M_Timer_ISR(uint8_t);

	for (uint8_t MB_N=0; MB_N<Modbus_Qt; MB_N++){
		if(MB_TimerFlag & (1<<MB_N)){
			cli();
    7070:	f8 94       	cli
			MB_TimerFlag &= ~(1<<MB_N);
    7072:	80 91 e2 08 	lds	r24, 0x08E2
    7076:	8e 7f       	andi	r24, 0xFE	; 254
    7078:	80 93 e2 08 	sts	0x08E2, r24
			sei();
    707c:	78 94       	sei
    707e:	c5 e5       	ldi	r28, 0x55	; 85
    7080:	de e2       	ldi	r29, 0x2E	; 46
    7082:	fe 01       	movw	r30, r28
    7084:	84 91       	lpm	r24, Z+
			switch (prb(MB_Role+MB_N)) {
    7086:	88 23       	and	r24, r24
    7088:	21 f4       	brne	.+8      	; 0x7092 <MB_Cycle+0x46>
			case Role_Slave:
				MB_S_Timer_ISR(MB_N);
    708a:	80 e0       	ldi	r24, 0x00	; 0
    708c:	0e 94 9c 2b 	call	0x5738	; 0x5738 <MB_S_Timer_ISR>
    7090:	e5 cf       	rjmp	.-54     	; 0x705c <MB_Cycle+0x10>
	for (uint8_t MB_N=0; MB_N<Modbus_Qt; MB_N++){
		if(MB_TimerFlag & (1<<MB_N)){
			cli();
			MB_TimerFlag &= ~(1<<MB_N);
			sei();
			switch (prb(MB_Role+MB_N)) {
    7092:	81 30       	cpi	r24, 0x01	; 1
    7094:	19 f7       	brne	.-58     	; 0x705c <MB_Cycle+0x10>
			case Role_Slave:
				MB_S_Timer_ISR(MB_N);
				break;
			case Role_Master:
				MB_M_Timer_ISR(MB_N);
    7096:	80 e0       	ldi	r24, 0x00	; 0
    7098:	0e 94 c9 32 	call	0x6592	; 0x6592 <MB_M_Timer_ISR>
    709c:	df cf       	rjmp	.-66     	; 0x705c <MB_Cycle+0x10>

0000709e <SetIP>:
	uint8_t IP3;
	uint8_t IP4;
} IP_Addr;

//~~~~~~~~~~~~~~
void SetIP(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
    709e:	0f 93       	push	r16
    70a0:	fc 01       	movw	r30, r24
	IP->IP1 = IP1;
    70a2:	60 83       	st	Z, r22
	IP->IP2 = IP2;
    70a4:	41 83       	std	Z+1, r20	; 0x01
	IP->IP3 = IP3;
    70a6:	22 83       	std	Z+2, r18	; 0x02
	IP->IP4 = IP4;
    70a8:	03 83       	std	Z+3, r16	; 0x03
}
    70aa:	0f 91       	pop	r16
    70ac:	08 95       	ret

000070ae <IP_compare_Const>:
uint8_t IP_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
    70ae:	0f 93       	push	r16
    70b0:	fc 01       	movw	r30, r24
	if((IP->IP1 == IP1) && (IP->IP2 == IP2) && (IP->IP3 == IP3) && (IP->IP4 == IP4)) return 1;
    70b2:	80 81       	ld	r24, Z
    70b4:	86 17       	cp	r24, r22
    70b6:	21 f0       	breq	.+8      	; 0x70c0 <IP_compare_Const+0x12>
    70b8:	20 e0       	ldi	r18, 0x00	; 0
	else return 0;
}
    70ba:	82 2f       	mov	r24, r18
    70bc:	0f 91       	pop	r16
    70be:	08 95       	ret
	IP->IP2 = IP2;
	IP->IP3 = IP3;
	IP->IP4 = IP4;
}
uint8_t IP_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	if((IP->IP1 == IP1) && (IP->IP2 == IP2) && (IP->IP3 == IP3) && (IP->IP4 == IP4)) return 1;
    70c0:	81 81       	ldd	r24, Z+1	; 0x01
    70c2:	84 17       	cp	r24, r20
    70c4:	c9 f7       	brne	.-14     	; 0x70b8 <IP_compare_Const+0xa>
    70c6:	82 81       	ldd	r24, Z+2	; 0x02
    70c8:	82 17       	cp	r24, r18
    70ca:	b1 f7       	brne	.-20     	; 0x70b8 <IP_compare_Const+0xa>
    70cc:	20 e0       	ldi	r18, 0x00	; 0
    70ce:	83 81       	ldd	r24, Z+3	; 0x03
    70d0:	80 13       	cpse	r24, r16
    70d2:	21 e0       	ldi	r18, 0x01	; 1
    70d4:	81 e0       	ldi	r24, 0x01	; 1
    70d6:	28 27       	eor	r18, r24
    70d8:	f0 cf       	rjmp	.-32     	; 0x70ba <IP_compare_Const+0xc>

000070da <GSM_StartCalling>:
uint8_t numOfCheckBallanceRetry=0;

uint8_t Message[3];  // 
uint8_t GSMBusyState=0; // " " 0 -  , 1 -  
void GSM_StartCalling(uint8_t inputN,uint8_t abonentN){
	Message[0]=1;
    70da:	91 e0       	ldi	r25, 0x01	; 1
    70dc:	90 93 f2 06 	sts	0x06F2, r25
	Message[1]=inputN;
    70e0:	80 93 f3 06 	sts	0x06F3, r24
	Message[2]=abonentN;
    70e4:	60 93 f4 06 	sts	0x06F4, r22
}
    70e8:	08 95       	ret

000070ea <InitFIFO>:
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    70ea:	8f ef       	ldi	r24, 0xFF	; 255
    70ec:	80 93 fa 06 	sts	0x06FA, r24
	GSM_RX_FIFO_End = 255;
    70f0:	80 93 51 06 	sts	0x0651, r24
	GSM_RxCharN = 0;
    70f4:	10 92 18 0b 	sts	0x0B18, r1
	GSM_RX_FIFOOverFlow = 0;
    70f8:	10 92 cb 08 	sts	0x08CB, r1
	GSM_RX_FIFOMax = 0;
    70fc:	10 92 d1 08 	sts	0x08D1, r1
}
    7100:	08 95       	ret

00007102 <GetByteFromFIFO>:
// ~~~~~~~~~~~
void GetByteFromFIFO(uint8_t *ReadBuf, uint8_t *Index, uint8_t ReadBuf_Sz){
    7102:	0f 93       	push	r16
    7104:	1f 93       	push	r17
    7106:	cf 93       	push	r28
    7108:	df 93       	push	r29
    710a:	8c 01       	movw	r16, r24
    710c:	eb 01       	movw	r28, r22

	//Reset *Index if read buffer overflow
	if(*Index >= ReadBuf_Sz){
    710e:	88 81       	ld	r24, Y
    7110:	84 17       	cp	r24, r20
    7112:	08 f0       	brcs	.+2      	; 0x7116 <GetByteFromFIFO+0x14>
		*Index = 0;
    7114:	18 82       	st	Y, r1
		//TODO  
	}	

	if(GSM_RX_FIFO_Begin > GSM_RX_FIFO_End){
    7116:	80 91 fa 06 	lds	r24, 0x06FA
    711a:	e0 91 51 06 	lds	r30, 0x0651
    711e:	e8 17       	cp	r30, r24
    7120:	f8 f4       	brcc	.+62     	; 0x7160 <GetByteFromFIFO+0x5e>
		if((GSM_RX_FIFO_End != 255)&&(GSM_RX_FIFO_End != 255))			
    7122:	ef 3f       	cpi	r30, 0xFF	; 255
    7124:	61 f0       	breq	.+24     	; 0x713e <GetByteFromFIFO+0x3c>
			if(GSM_RX_FIFOMax < (GSM_RX_FIFO_Begin - GSM_RX_FIFO_End))
    7126:	20 91 d1 08 	lds	r18, 0x08D1
    712a:	80 91 fa 06 	lds	r24, 0x06FA
    712e:	30 e0       	ldi	r19, 0x00	; 0
    7130:	90 e0       	ldi	r25, 0x00	; 0
    7132:	8e 1b       	sub	r24, r30
    7134:	91 09       	sbc	r25, r1
    7136:	28 17       	cp	r18, r24
    7138:	39 07       	cpc	r19, r25
    713a:	0c f4       	brge	.+2      	; 0x713e <GetByteFromFIFO+0x3c>
    713c:	46 c0       	rjmp	.+140    	; 0x71ca <GetByteFromFIFO+0xc8>
				GSM_RX_FIFOMax =  GSM_RX_FIFO_Begin - GSM_RX_FIFO_End;
		GSM_RX_FIFO_End++;
    713e:	ef 5f       	subi	r30, 0xFF	; 255
    7140:	e0 93 51 06 	sts	0x0651, r30
		ReadBuf[*Index] = GSM_RX_FIFO[GSM_RX_FIFO_End];
    7144:	88 81       	ld	r24, Y
    7146:	d8 01       	movw	r26, r16
    7148:	a8 0f       	add	r26, r24
    714a:	b1 1d       	adc	r27, r1
    714c:	f0 e0       	ldi	r31, 0x00	; 0
    714e:	e1 52       	subi	r30, 0x21	; 33
    7150:	fa 4f       	sbci	r31, 0xFA	; 250
    7152:	80 81       	ld	r24, Z
    7154:	8c 93       	st	X, r24
		*Index=*Index+1;
    7156:	88 81       	ld	r24, Y
    7158:	8f 5f       	subi	r24, 0xFF	; 255
    715a:	88 83       	st	Y, r24
    715c:	e0 91 51 06 	lds	r30, 0x0651
	}
	if(GSM_RX_FIFO_End > GSM_RX_FIFO_Begin){
    7160:	80 91 fa 06 	lds	r24, 0x06FA
    7164:	8e 17       	cp	r24, r30
    7166:	28 f5       	brcc	.+74     	; 0x71b2 <GetByteFromFIFO+0xb0>
		if((GSM_RX_FIFO_End != 255)&&(GSM_RX_FIFO_End != 255))
    7168:	ef 3f       	cpi	r30, 0xFF	; 255
    716a:	99 f0       	breq	.+38     	; 0x7192 <GetByteFromFIFO+0x90>
			if(GSM_RX_FIFOMax < (GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End  + GSM_RX_FIFO_Begin))
    716c:	20 91 d1 08 	lds	r18, 0x08D1
    7170:	80 91 fa 06 	lds	r24, 0x06FA
    7174:	30 e0       	ldi	r19, 0x00	; 0
    7176:	90 e0       	ldi	r25, 0x00	; 0
    7178:	8c 59       	subi	r24, 0x9C	; 156
    717a:	9f 4f       	sbci	r25, 0xFF	; 255
    717c:	8e 1b       	sub	r24, r30
    717e:	91 09       	sbc	r25, r1
    7180:	28 17       	cp	r18, r24
    7182:	39 07       	cpc	r19, r25
    7184:	dc f0       	brlt	.+54     	; 0x71bc <GetByteFromFIFO+0xba>
				GSM_RX_FIFOMax = GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End  + GSM_RX_FIFO_Begin;
		GSM_RX_FIFO_End++;
    7186:	8e 2f       	mov	r24, r30
    7188:	8f 5f       	subi	r24, 0xFF	; 255
    718a:	80 93 51 06 	sts	0x0651, r24
		if(GSM_RX_FIFO_End >= GSM_RX_FIFO_SIZE) GSM_RX_FIFO_End = 0;
    718e:	84 36       	cpi	r24, 0x64	; 100
    7190:	10 f0       	brcs	.+4      	; 0x7196 <GetByteFromFIFO+0x94>
    7192:	10 92 51 06 	sts	0x0651, r1
		ReadBuf[*Index] = GSM_RX_FIFO[GSM_RX_FIFO_End];
    7196:	88 81       	ld	r24, Y
    7198:	08 0f       	add	r16, r24
    719a:	11 1d       	adc	r17, r1
    719c:	e0 91 51 06 	lds	r30, 0x0651
    71a0:	f0 e0       	ldi	r31, 0x00	; 0
    71a2:	e1 52       	subi	r30, 0x21	; 33
    71a4:	fa 4f       	sbci	r31, 0xFA	; 250
    71a6:	80 81       	ld	r24, Z
    71a8:	f8 01       	movw	r30, r16
    71aa:	80 83       	st	Z, r24
		*Index=*Index+1;
    71ac:	88 81       	ld	r24, Y
    71ae:	8f 5f       	subi	r24, 0xFF	; 255
    71b0:	88 83       	st	Y, r24
	}
}
    71b2:	df 91       	pop	r29
    71b4:	cf 91       	pop	r28
    71b6:	1f 91       	pop	r17
    71b8:	0f 91       	pop	r16
    71ba:	08 95       	ret
		*Index=*Index+1;
	}
	if(GSM_RX_FIFO_End > GSM_RX_FIFO_Begin){
		if((GSM_RX_FIFO_End != 255)&&(GSM_RX_FIFO_End != 255))
			if(GSM_RX_FIFOMax < (GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End  + GSM_RX_FIFO_Begin))
				GSM_RX_FIFOMax = GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End  + GSM_RX_FIFO_Begin;
    71bc:	80 91 fa 06 	lds	r24, 0x06FA
    71c0:	8c 59       	subi	r24, 0x9C	; 156
    71c2:	8e 1b       	sub	r24, r30
    71c4:	80 93 d1 08 	sts	0x08D1, r24
    71c8:	de cf       	rjmp	.-68     	; 0x7186 <GetByteFromFIFO+0x84>
	}	

	if(GSM_RX_FIFO_Begin > GSM_RX_FIFO_End){
		if((GSM_RX_FIFO_End != 255)&&(GSM_RX_FIFO_End != 255))			
			if(GSM_RX_FIFOMax < (GSM_RX_FIFO_Begin - GSM_RX_FIFO_End))
				GSM_RX_FIFOMax =  GSM_RX_FIFO_Begin - GSM_RX_FIFO_End;
    71ca:	80 91 fa 06 	lds	r24, 0x06FA
    71ce:	8e 1b       	sub	r24, r30
    71d0:	80 93 d1 08 	sts	0x08D1, r24
    71d4:	b4 cf       	rjmp	.-152    	; 0x713e <GetByteFromFIFO+0x3c>

000071d6 <GetStringFromFIFO>:
//        
uint8_t GetStringFromFIFO(void){

	uint8_t StrLength = 0;

	while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    71d6:	90 91 fa 06 	lds	r25, 0x06FA
    71da:	80 91 51 06 	lds	r24, 0x0651
    71de:	98 17       	cp	r25, r24
    71e0:	39 f1       	breq	.+78     	; 0x7230 <GetStringFromFIFO+0x5a>
		
		GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);
    71e2:	89 e9       	ldi	r24, 0x99	; 153
    71e4:	97 e0       	ldi	r25, 0x07	; 7
    71e6:	68 e1       	ldi	r22, 0x18	; 24
    71e8:	7b e0       	ldi	r23, 0x0B	; 11
    71ea:	44 e6       	ldi	r20, 0x64	; 100
    71ec:	0e 94 81 38 	call	0x7102	; 0x7102 <GetByteFromFIFO>

		//   : xxxxxxxxxxxxxxxx<CR><LF>
		//	'\r' CR - carridge return 0x0D
		//	'\n' LF - line feed 0x0A
		//   xxxxxxxxxxxxxxxx<\0>
		if( (GSM_RxCharN >= 2) && (GSM_RxStr[GSM_RxCharN-2]== '\r') && (GSM_RxStr[GSM_RxCharN-1]== '\n') ){
    71f0:	80 91 18 0b 	lds	r24, 0x0B18
    71f4:	82 30       	cpi	r24, 0x02	; 2
    71f6:	78 f3       	brcs	.-34     	; 0x71d6 <GetStringFromFIFO>
    71f8:	e0 91 18 0b 	lds	r30, 0x0B18
    71fc:	f0 e0       	ldi	r31, 0x00	; 0
    71fe:	e9 56       	subi	r30, 0x69	; 105
    7200:	f8 4f       	sbci	r31, 0xF8	; 248
    7202:	80 81       	ld	r24, Z
    7204:	8d 30       	cpi	r24, 0x0D	; 13
    7206:	39 f7       	brne	.-50     	; 0x71d6 <GetStringFromFIFO>
    7208:	e0 91 18 0b 	lds	r30, 0x0B18
    720c:	f0 e0       	ldi	r31, 0x00	; 0
    720e:	e8 56       	subi	r30, 0x68	; 104
    7210:	f8 4f       	sbci	r31, 0xF8	; 248
    7212:	80 81       	ld	r24, Z
    7214:	8a 30       	cpi	r24, 0x0A	; 10
    7216:	f9 f6       	brne	.-66     	; 0x71d6 <GetStringFromFIFO>
			GSM_RxStr[GSM_RxCharN-2] = '\0';
    7218:	e0 91 18 0b 	lds	r30, 0x0B18
    721c:	f0 e0       	ldi	r31, 0x00	; 0
    721e:	e9 56       	subi	r30, 0x69	; 105
    7220:	f8 4f       	sbci	r31, 0xF8	; 248
    7222:	10 82       	st	Z, r1
			StrLength = GSM_RxCharN-1;
    7224:	80 91 18 0b 	lds	r24, 0x0B18
    7228:	81 50       	subi	r24, 0x01	; 1
			GSM_RxCharN = 0;
    722a:	10 92 18 0b 	sts	0x0B18, r1
    722e:	08 95       	ret
//        
uint8_t GetStringFromFIFO(void){

	uint8_t StrLength = 0;

	while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    7230:	80 e0       	ldi	r24, 0x00	; 0
		}

	}//while
	
	return StrLength;
}
    7232:	08 95       	ret

00007234 <GetStringFromFIFOwithOverflowDetect>:

uint8_t GetStringFromFIFOwithOverflowDetect(void){
    7234:	04 c0       	rjmp	.+8      	; 0x723e <GetStringFromFIFOwithOverflowDetect+0xa>

		//   : xxxxxxxxxxxxxxxx<CR><LF>
		//	'\r' CR - carridge return 0x0D
		//	'\n' LF - line feed 0x0A
		//   xxxxxxxxxxxxxxxx<\0>
		if( ((GSM_RxCharN >= 2) && (GSM_RxStr[GSM_RxCharN-2]== '\r') && (GSM_RxStr[GSM_RxCharN-1]== '\n'))||(GSM_RxCharN==GSM_RXSTR_SIZE-1) ){
    7236:	80 91 18 0b 	lds	r24, 0x0B18
    723a:	83 36       	cpi	r24, 0x63	; 99
    723c:	09 f1       	breq	.+66     	; 0x7280 <GetStringFromFIFOwithOverflowDetect+0x4c>

uint8_t GetStringFromFIFOwithOverflowDetect(void){

	uint8_t StrLength = 0;

	while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    723e:	90 91 fa 06 	lds	r25, 0x06FA
    7242:	80 91 51 06 	lds	r24, 0x0651
    7246:	98 17       	cp	r25, r24
    7248:	39 f1       	breq	.+78     	; 0x7298 <GetStringFromFIFOwithOverflowDetect+0x64>
		
		GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);
    724a:	89 e9       	ldi	r24, 0x99	; 153
    724c:	97 e0       	ldi	r25, 0x07	; 7
    724e:	68 e1       	ldi	r22, 0x18	; 24
    7250:	7b e0       	ldi	r23, 0x0B	; 11
    7252:	44 e6       	ldi	r20, 0x64	; 100
    7254:	0e 94 81 38 	call	0x7102	; 0x7102 <GetByteFromFIFO>

		//   : xxxxxxxxxxxxxxxx<CR><LF>
		//	'\r' CR - carridge return 0x0D
		//	'\n' LF - line feed 0x0A
		//   xxxxxxxxxxxxxxxx<\0>
		if( ((GSM_RxCharN >= 2) && (GSM_RxStr[GSM_RxCharN-2]== '\r') && (GSM_RxStr[GSM_RxCharN-1]== '\n'))||(GSM_RxCharN==GSM_RXSTR_SIZE-1) ){
    7258:	80 91 18 0b 	lds	r24, 0x0B18
    725c:	82 30       	cpi	r24, 0x02	; 2
    725e:	58 f3       	brcs	.-42     	; 0x7236 <GetStringFromFIFOwithOverflowDetect+0x2>
    7260:	e0 91 18 0b 	lds	r30, 0x0B18
    7264:	f0 e0       	ldi	r31, 0x00	; 0
    7266:	e9 56       	subi	r30, 0x69	; 105
    7268:	f8 4f       	sbci	r31, 0xF8	; 248
    726a:	80 81       	ld	r24, Z
    726c:	8d 30       	cpi	r24, 0x0D	; 13
    726e:	19 f7       	brne	.-58     	; 0x7236 <GetStringFromFIFOwithOverflowDetect+0x2>
    7270:	e0 91 18 0b 	lds	r30, 0x0B18
    7274:	f0 e0       	ldi	r31, 0x00	; 0
    7276:	e8 56       	subi	r30, 0x68	; 104
    7278:	f8 4f       	sbci	r31, 0xF8	; 248
    727a:	80 81       	ld	r24, Z
    727c:	8a 30       	cpi	r24, 0x0A	; 10
    727e:	d9 f6       	brne	.-74     	; 0x7236 <GetStringFromFIFOwithOverflowDetect+0x2>
			GSM_RxStr[GSM_RxCharN-2] = '\0';
    7280:	e0 91 18 0b 	lds	r30, 0x0B18
    7284:	f0 e0       	ldi	r31, 0x00	; 0
    7286:	e9 56       	subi	r30, 0x69	; 105
    7288:	f8 4f       	sbci	r31, 0xF8	; 248
    728a:	10 82       	st	Z, r1
			StrLength = GSM_RxCharN-1;
    728c:	80 91 18 0b 	lds	r24, 0x0B18
    7290:	81 50       	subi	r24, 0x01	; 1
			GSM_RxCharN = 0;
    7292:	10 92 18 0b 	sts	0x0B18, r1
    7296:	08 95       	ret

uint8_t GetStringFromFIFOwithOverflowDetect(void){

	uint8_t StrLength = 0;

	while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    7298:	80 e0       	ldi	r24, 0x00	; 0
		}

	}//while
	
	return StrLength;
}
    729a:	08 95       	ret

0000729c <ForceEndStringFromFIFO>:
// ~~~~~~~~~~~
//    GSM_RxStr  <CR><LF>
uint8_t ForceEndStringFromFIFO(void){
	uint8_t StrLength;
	if(GSM_RxCharN > GSM_RXSTR_SIZE-1) GSM_RxCharN = GSM_RXSTR_SIZE-1;
    729c:	80 91 18 0b 	lds	r24, 0x0B18
    72a0:	84 36       	cpi	r24, 0x64	; 100
    72a2:	18 f0       	brcs	.+6      	; 0x72aa <ForceEndStringFromFIFO+0xe>
    72a4:	83 e6       	ldi	r24, 0x63	; 99
    72a6:	80 93 18 0b 	sts	0x0B18, r24
	StrLength = GSM_RxCharN;
    72aa:	80 91 18 0b 	lds	r24, 0x0B18
	GSM_RxStr[GSM_RxCharN]='\0';
    72ae:	e0 91 18 0b 	lds	r30, 0x0B18
    72b2:	f0 e0       	ldi	r31, 0x00	; 0
    72b4:	e7 56       	subi	r30, 0x67	; 103
    72b6:	f8 4f       	sbci	r31, 0xF8	; 248
    72b8:	10 82       	st	Z, r1
	GSM_RxCharN = 0;
    72ba:	10 92 18 0b 	sts	0x0B18, r1
	return StrLength;
}
    72be:	08 95       	ret

000072c0 <GetDataFromFIFO>:

// ~~~~~~~~~~~
uint8_t GetDataFromFIFO(const uint8_t Amount){
    72c0:	1f 93       	push	r17
    72c2:	18 2f       	mov	r17, r24

	while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    72c4:	90 91 fa 06 	lds	r25, 0x06FA
    72c8:	80 91 51 06 	lds	r24, 0x0651
    72cc:	98 17       	cp	r25, r24
    72ce:	81 f0       	breq	.+32     	; 0x72f0 <GetDataFromFIFO+0x30>
		GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);
    72d0:	89 e9       	ldi	r24, 0x99	; 153
    72d2:	97 e0       	ldi	r25, 0x07	; 7
    72d4:	68 e1       	ldi	r22, 0x18	; 24
    72d6:	7b e0       	ldi	r23, 0x0B	; 11
    72d8:	44 e6       	ldi	r20, 0x64	; 100
    72da:	0e 94 81 38 	call	0x7102	; 0x7102 <GetByteFromFIFO>
		if(GSM_RxCharN >= Amount){
    72de:	80 91 18 0b 	lds	r24, 0x0B18
    72e2:	81 17       	cp	r24, r17
    72e4:	78 f3       	brcs	.-34     	; 0x72c4 <GetDataFromFIFO+0x4>
			GSM_RxCharN = 0;
    72e6:	10 92 18 0b 	sts	0x0B18, r1
			return Amount;
		}
	}//while
	return GSM_RxCharN;
}
    72ea:	81 2f       	mov	r24, r17
    72ec:	1f 91       	pop	r17
    72ee:	08 95       	ret
		if(GSM_RxCharN >= Amount){
			GSM_RxCharN = 0;
			return Amount;
		}
	}//while
	return GSM_RxCharN;
    72f0:	10 91 18 0b 	lds	r17, 0x0B18
}
    72f4:	81 2f       	mov	r24, r17
    72f6:	1f 91       	pop	r17
    72f8:	08 95       	ret

000072fa <GSM_Init>:
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    72fa:	8f ef       	ldi	r24, 0xFF	; 255
    72fc:	80 93 fa 06 	sts	0x06FA, r24
	GSM_RX_FIFO_End = 255;
    7300:	80 93 51 06 	sts	0x0651, r24
	GSM_RxCharN = 0;
    7304:	10 92 18 0b 	sts	0x0B18, r1
	GSM_RX_FIFOOverFlow = 0;
    7308:	10 92 cb 08 	sts	0x08CB, r1
	GSM_RX_FIFOMax = 0;
    730c:	10 92 d1 08 	sts	0x08D1, r1
		USART_GSM.BAUDCTRLB = 0x00 + USART_BSCALE0_bm;
		USART_GSM.CTRLA = USART_RXCINTLVL_HI_gc;
		USART_GSM.CTRLB = (1<<USART_RXEN_bp) | (1<<USART_TXEN_bp) | (0<<USART_CLK2X_bp) | (0 << USART_MPCM_bp) | (0 << USART_TXB8_bp);
		USART_GSM.CTRLC = USART_CMODE_ASYNCHRONOUS_gc | USART_PMODE_DISABLED_gc | (0<< USART_SBMODE_bp) | USART_CHSIZE_8BIT_gc;
	#else
		UCSR_GSM_A = ~(1<<U2X_GSM) &~(1<<MPCM_GSM);
    7310:	8c ef       	ldi	r24, 0xFC	; 252
    7312:	80 93 d0 00 	sts	0x00D0, r24
		UCSR_GSM_B =  (1<<RXCIE_GSM) | (0<<TXCIE_GSM) | (0<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    7316:	88 e9       	ldi	r24, 0x98	; 152
    7318:	80 93 d1 00 	sts	0x00D1, r24
		#if defined (__AVR_ATmega2561__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__)			
			UCSR_GSM_C = (0<<UMSEL_GSM_1) | (0<<UMSEL_GSM_0) | (0<<UPM_GSM_1) | (0<<UPM_GSM_0) | (0<<USBS_GSM) | (1<<UCSZ_GSM_1) | (1<<UCSZ_GSM_0) | (0<<UCPOL_GSM);
    731c:	86 e0       	ldi	r24, 0x06	; 6
    731e:	80 93 d2 00 	sts	0x00D2, r24
		#else
			UCSR_GSM_C = ((~(1<<UMSEL_GSM) &~(1<<UPM_GSM_1) &~(1<<UPM_GSM_0) &~(1<<USBS_GSM)) |(1<<UCSZ_GSM_1) |(1<<UCSZ_GSM_0)) &~(1<<UCPOL_GSM);
		#endif
		UBRR_GSM_H = 0x00;
    7322:	10 92 d5 00 	sts	0x00D5, r1
		UBRR_GSM_L = 0x67;	// 9600
    7326:	87 e6       	ldi	r24, 0x67	; 103
    7328:	80 93 d4 00 	sts	0x00D4, r24
#endif

//  gsm_sim900r.h   PWRCNTRL
#ifdef vmd2_3
	void GSM_PWRCNTRL_Config(void){
		cli();
    732c:	f8 94       	cli
		DDRL|=(1<<PL5);
    732e:	ea e0       	ldi	r30, 0x0A	; 10
    7330:	f1 e0       	ldi	r31, 0x01	; 1
    7332:	80 81       	ld	r24, Z
    7334:	80 62       	ori	r24, 0x20	; 32
    7336:	80 83       	st	Z, r24
		sei();
    7338:	78 94       	sei
		cli();
		PORTL|=(1<<PL5);
		sei();
	}
	void GSM_PWRCNTRL_ON(void){
		cli();
    733a:	f8 94       	cli
		PORTL &= ~(1<<PL5);
    733c:	eb e0       	ldi	r30, 0x0B	; 11
    733e:	f1 e0       	ldi	r31, 0x01	; 1
    7340:	80 81       	ld	r24, Z
    7342:	8f 7d       	andi	r24, 0xDF	; 223
    7344:	80 83       	st	Z, r24
		sei();
    7346:	78 94       	sei

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    7348:	80 91 d0 02 	lds	r24, 0x02D0
	VacantTimer16Sys += n;
    734c:	98 2f       	mov	r25, r24
    734e:	9f 5f       	subi	r25, 0xFF	; 255
	GSM_PWRCNTRL_ON();
	#ifdef GSM_HW_FLOW_CONTROL
		GSM_CTS_RTS_Config();
	#endif

	TD_GSM = Timer16SysAlloc(1);
    7350:	80 93 e7 04 	sts	0x04E7, r24
    7354:	29 2f       	mov	r18, r25
    7356:	2f 5f       	subi	r18, 0xFF	; 255
	TD_TCP_Connect = Timer16SysAlloc(1);
    7358:	90 93 e8 04 	sts	0x04E8, r25

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer32SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer32Sys;
    735c:	90 91 d1 02 	lds	r25, 0x02D1
	VacantTimer32Sys += n;
    7360:	89 2f       	mov	r24, r25
    7362:	8f 5f       	subi	r24, 0xFF	; 255
	TD_GSM_Reset = Timer32SysAlloc(1);
    7364:	90 93 e9 04 	sts	0x04E9, r25
// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
	VacantTimer16Sys += n;
    7368:	92 2f       	mov	r25, r18
    736a:	9f 5f       	subi	r25, 0xFF	; 255
	TD_5min_timer = Timer16SysAlloc(1);
    736c:	20 93 ea 04 	sts	0x04EA, r18
// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer32SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer32Sys;
	VacantTimer32Sys += n;
    7370:	8f 5f       	subi	r24, 0xFF	; 255
    7372:	80 93 d1 02 	sts	0x02D1, r24
    7376:	81 50       	subi	r24, 0x01	; 1
	TD_1hour_resetGPRS_timer = Timer32SysAlloc(1);
    7378:	80 93 eb 04 	sts	0x04EB, r24
// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
	VacantTimer16Sys += n;
    737c:	89 2f       	mov	r24, r25
    737e:	8f 5f       	subi	r24, 0xFF	; 255
	TD_CheckModem = Timer16SysAlloc(1);
    7380:	90 93 ec 04 	sts	0x04EC, r25
    7384:	9e 5f       	subi	r25, 0xFE	; 254
	TD_CleanFIFO = Timer16SysAlloc(1);
    7386:	80 93 ed 04 	sts	0x04ED, r24
    738a:	8e 5f       	subi	r24, 0xFE	; 254
	TD_data_start_delay = Timer16SysAlloc(1);
    738c:	90 93 ee 04 	sts	0x04EE, r25
    7390:	8f 5f       	subi	r24, 0xFF	; 255
    7392:	80 93 d0 02 	sts	0x02D0, r24
    7396:	81 50       	subi	r24, 0x01	; 1
	TD_timer_after_page_transfer = Timer16SysAlloc(1);
    7398:	80 93 ef 04 	sts	0x04EF, r24

/*	for (uint8_t i=0; i<4; i++)
		GPRS_ServerAddr[i] = erb(GPRS_ServerAddr_EE+i);
*/
	GSM_Control = GSM_CNTL_AUTO;
    739c:	10 92 8a 07 	sts	0x078A, r1
	GSM_State = GSM_PowerOn;
    73a0:	10 92 b3 06 	sts	0x06B3, r1



}
    73a4:	08 95       	ret

000073a6 <GSM_RX>:
// ~~~~~~~~~
void
GSM_RX(void)
{
	char Char = UDR_GSM;
    73a6:	90 91 d6 00 	lds	r25, 0x00D6

	//---FIFO
	GSM_RX_FIFO_Begin++;
    73aa:	80 91 fa 06 	lds	r24, 0x06FA
    73ae:	8f 5f       	subi	r24, 0xFF	; 255
    73b0:	80 93 fa 06 	sts	0x06FA, r24
	if(GSM_RX_FIFO_Begin >= GSM_RX_FIFO_SIZE) GSM_RX_FIFO_Begin = 0;
    73b4:	80 91 fa 06 	lds	r24, 0x06FA
    73b8:	84 36       	cpi	r24, 0x64	; 100
    73ba:	10 f0       	brcs	.+4      	; 0x73c0 <GSM_RX+0x1a>
    73bc:	10 92 fa 06 	sts	0x06FA, r1
	GSM_RX_FIFO[GSM_RX_FIFO_Begin] = Char;
    73c0:	e0 91 fa 06 	lds	r30, 0x06FA
    73c4:	f0 e0       	ldi	r31, 0x00	; 0
    73c6:	e1 52       	subi	r30, 0x21	; 33
    73c8:	fa 4f       	sbci	r31, 0xFA	; 250
    73ca:	90 83       	st	Z, r25
	if(GSM_RX_FIFO_Begin == GSM_RX_FIFO_End){
    73cc:	90 91 fa 06 	lds	r25, 0x06FA
    73d0:	80 91 51 06 	lds	r24, 0x0651
    73d4:	98 13       	cpse	r25, r24
    73d6:	08 95       	ret
		GSM_RX_FIFOOverFlow = 1;
    73d8:	81 e0       	ldi	r24, 0x01	; 1
    73da:	80 93 cb 08 	sts	0x08CB, r24
		GSM_RX_FIFOMax = GSM_RX_FIFO_SIZE;
    73de:	84 e6       	ldi	r24, 0x64	; 100
    73e0:	80 93 d1 08 	sts	0x08D1, r24
    73e4:	08 95       	ret

000073e6 <GSM_Wait_Char>:
		else return 1;
	}
	else return 0;
}
// ~~~~~~~~~
uint8_t GSM_Wait_Char(char Char, uint8_t RestoreCMD){
    73e6:	0f 93       	push	r16
    73e8:	1f 93       	push	r17
    73ea:	08 2f       	mov	r16, r24
    73ec:	16 2f       	mov	r17, r22
	if(Timer16Stopp(TD_GSM)){
    73ee:	80 91 e7 04 	lds	r24, 0x04E7
    73f2:	0e 94 71 1c 	call	0x38e2	; 0x38e2 <Timer16Stopp>
    73f6:	88 23       	and	r24, r24
    73f8:	39 f0       	breq	.+14     	; 0x7408 <GSM_Wait_Char+0x22>
		GSM_State = RestoreCMD;
    73fa:	10 93 b3 06 	sts	0x06B3, r17
    73fe:	90 e0       	ldi	r25, 0x00	; 0
	if(GetDataFromFIFO(1)){
		if(GSM_RxStr[0] == Char)	return 1;
		else return 0;
	}
	else return 0;
}
    7400:	89 2f       	mov	r24, r25
    7402:	1f 91       	pop	r17
    7404:	0f 91       	pop	r16
    7406:	08 95       	ret
	if(Timer16Stopp(TD_GSM)){
		GSM_State = RestoreCMD;
		return 0;
	}
	//   
	if(GetDataFromFIFO(1)){
    7408:	81 e0       	ldi	r24, 0x01	; 1
    740a:	0e 94 60 39 	call	0x72c0	; 0x72c0 <GetDataFromFIFO>
    740e:	88 23       	and	r24, r24
    7410:	39 f0       	breq	.+14     	; 0x7420 <GSM_Wait_Char+0x3a>
    7412:	90 e0       	ldi	r25, 0x00	; 0
    7414:	80 91 99 07 	lds	r24, 0x0799
    7418:	80 17       	cp	r24, r16
    741a:	91 f7       	brne	.-28     	; 0x7400 <GSM_Wait_Char+0x1a>
    741c:	91 e0       	ldi	r25, 0x01	; 1
    741e:	f0 cf       	rjmp	.-32     	; 0x7400 <GSM_Wait_Char+0x1a>
    7420:	90 e0       	ldi	r25, 0x00	; 0
		if(GSM_RxStr[0] == Char)	return 1;
		else return 0;
	}
	else return 0;
}
    7422:	89 2f       	mov	r24, r25
    7424:	1f 91       	pop	r17
    7426:	0f 91       	pop	r16
    7428:	08 95       	ret

0000742a <GSM_SendFirstChar>:
// ~~~~~~~~~
void GSM_SendFirstChar(void){

	UDR_GSM = GSM_TxStr[0];
    742a:	80 91 02 0a 	lds	r24, 0x0A02
    742e:	80 93 d6 00 	sts	0x00D6, r24
	#ifdef GSM_DEBUG
		GPRS_TerminalProcess(GSM_TxStr[0]);
	#endif

	GSM_TxCharN = 1;
    7432:	81 e0       	ldi	r24, 0x01	; 1
    7434:	80 93 21 0b 	sts	0x0B21, r24
	cli();
    7438:	f8 94       	cli
	GSM_Flag &=~(1<<flg_TxCStr);	
    743a:	80 91 d2 02 	lds	r24, 0x02D2
    743e:	8e 7f       	andi	r24, 0xFE	; 254
    7440:	80 93 d2 02 	sts	0x02D2, r24
	sei();
    7444:	78 94       	sei
	cli();
    7446:	f8 94       	cli
	#if defined (__AVR_ATxmega128A1__)
		USART_GSM.CTRLA = USART_RXCINTLVL_HI_gc | USART_DREINTLVL_HI_gc;
	#else
		UCSR_GSM_B =  (1<<RXCIE_GSM) | (0<<TXCIE_GSM) | (1<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    7448:	88 eb       	ldi	r24, 0xB8	; 184
    744a:	80 93 d1 00 	sts	0x00D1, r24
	#endif
	
	sei();	
    744e:	78 94       	sei
}
    7450:	08 95       	ret

00007452 <GSM_DRE>:
		StartTimer16(TD_GSM, Timeout);
	}
}
// ~~~~~~~~~
void GSM_DRE(void){
	if(GSM_TxCharN < GSMTxSz){
    7452:	90 91 21 0b 	lds	r25, 0x0B21
    7456:	80 91 75 07 	lds	r24, 0x0775
    745a:	98 17       	cp	r25, r24
    745c:	20 f0       	brcs	.+8      	; 0x7466 <GSM_DRE+0x14>
	}
	else{
		#if defined (__AVR_ATxmega128A1__)
			USART_GSM.CTRLA = USART_RXCINTLVL_HI_gc | USART_TXCINTLVL_HI_gc;
		#else
			UCSR_GSM_B =  (1<<RXCIE_GSM) | (1<<TXCIE_GSM) | (0<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    745e:	88 ed       	ldi	r24, 0xD8	; 216
    7460:	80 93 d1 00 	sts	0x00D1, r24
    7464:	08 95       	ret
	}
}
// ~~~~~~~~~
void GSM_DRE(void){
	if(GSM_TxCharN < GSMTxSz){
		UDR_GSM = GSM_TxStr[GSM_TxCharN];
    7466:	e0 91 21 0b 	lds	r30, 0x0B21
    746a:	f0 e0       	ldi	r31, 0x00	; 0
    746c:	ee 5f       	subi	r30, 0xFE	; 254
    746e:	f5 4f       	sbci	r31, 0xF5	; 245
    7470:	80 81       	ld	r24, Z
    7472:	80 93 d6 00 	sts	0x00D6, r24
		#ifdef GSM_DEBUG
			GPRS_TerminalProcess(GSM_TxStr[GSM_TxCharN]);
		#endif
		GSM_TxCharN++;
    7476:	80 91 21 0b 	lds	r24, 0x0B21
    747a:	8f 5f       	subi	r24, 0xFF	; 255
    747c:	80 93 21 0b 	sts	0x0B21, r24
    7480:	08 95       	ret

00007482 <GSM_TX>:
}
// ~~~~~~~~~
void
GSM_TX(void)
{
	GSM_Flag |=(1<<flg_TxCStr);
    7482:	80 91 d2 02 	lds	r24, 0x02D2
    7486:	81 60       	ori	r24, 0x01	; 1
    7488:	80 93 d2 02 	sts	0x02D2, r24
	if(dataSendFlg){
    748c:	80 91 df 02 	lds	r24, 0x02DF
    7490:	88 23       	and	r24, r24
    7492:	21 f0       	breq	.+8      	; 0x749c <GSM_TX+0x1a>
	dataSendFlg=0;
    7494:	10 92 df 02 	sts	0x02DF, r1
	GPRS_FlgSz_Out=0;
    7498:	10 92 6d 07 	sts	0x076D, r1
	}
	#if defined (__AVR_ATxmega128A1__)
		USART_GSM.CTRLA = USART_RXCINTLVL_HI_gc;
	#else
		UCSR_GSM_B =  (1<<RXCIE_GSM) | (0<<TXCIE_GSM) | (0<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    749c:	88 e9       	ldi	r24, 0x98	; 152
    749e:	80 93 d1 00 	sts	0x00D1, r24
	#endif
}
    74a2:	08 95       	ret

000074a4 <GSM_Reset>:
GSM_Reset(void)
{
/*	IntOff();
	GSM_State = GSM_Restart;
	IntOn();*/
}
    74a4:	08 95       	ret

000074a6 <GSM_GotoNextVega>:

uint8_t GSM_GotoNextVega(void){
 return 0;
}
    74a6:	80 e0       	ldi	r24, 0x00	; 0
    74a8:	08 95       	ret

000074aa <GPRS_ServerAddr_Save>:
// ~~~~~~~~~~~~~~~~~~~~~~~~
void
GPRS_ServerAddr_Save(void)
{

}
    74aa:	08 95       	ret

000074ac <__vector_25>:
#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__)
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	#ifdef vmd2_3
		// ~~~~~~~~~~
		// USART0 - PORT0
		Modbus_ISR(0)
    74ac:	1f 92       	push	r1
    74ae:	0f 92       	push	r0
    74b0:	0f b6       	in	r0, 0x3f	; 63
    74b2:	0f 92       	push	r0
    74b4:	0b b6       	in	r0, 0x3b	; 59
    74b6:	0f 92       	push	r0
    74b8:	11 24       	eor	r1, r1
    74ba:	2f 93       	push	r18
    74bc:	3f 93       	push	r19
    74be:	4f 93       	push	r20
    74c0:	5f 93       	push	r21
    74c2:	6f 93       	push	r22
    74c4:	7f 93       	push	r23
    74c6:	8f 93       	push	r24
    74c8:	9f 93       	push	r25
    74ca:	af 93       	push	r26
    74cc:	bf 93       	push	r27
    74ce:	ef 93       	push	r30
    74d0:	ff 93       	push	r31
    74d2:	86 ec       	ldi	r24, 0xC6	; 198
    74d4:	90 e0       	ldi	r25, 0x00	; 0
    74d6:	0e 94 4b 2a 	call	0x5496	; 0x5496 <Modbus_RX>
    74da:	ff 91       	pop	r31
    74dc:	ef 91       	pop	r30
    74de:	bf 91       	pop	r27
    74e0:	af 91       	pop	r26
    74e2:	9f 91       	pop	r25
    74e4:	8f 91       	pop	r24
    74e6:	7f 91       	pop	r23
    74e8:	6f 91       	pop	r22
    74ea:	5f 91       	pop	r21
    74ec:	4f 91       	pop	r20
    74ee:	3f 91       	pop	r19
    74f0:	2f 91       	pop	r18
    74f2:	0f 90       	pop	r0
    74f4:	0b be       	out	0x3b, r0	; 59
    74f6:	0f 90       	pop	r0
    74f8:	0f be       	out	0x3f, r0	; 63
    74fa:	0f 90       	pop	r0
    74fc:	1f 90       	pop	r1
    74fe:	18 95       	reti

00007500 <__vector_27>:
    7500:	1f 92       	push	r1
    7502:	0f 92       	push	r0
    7504:	0f b6       	in	r0, 0x3f	; 63
    7506:	0f 92       	push	r0
    7508:	0b b6       	in	r0, 0x3b	; 59
    750a:	0f 92       	push	r0
    750c:	11 24       	eor	r1, r1
    750e:	2f 93       	push	r18
    7510:	3f 93       	push	r19
    7512:	4f 93       	push	r20
    7514:	5f 93       	push	r21
    7516:	6f 93       	push	r22
    7518:	7f 93       	push	r23
    751a:	8f 93       	push	r24
    751c:	9f 93       	push	r25
    751e:	af 93       	push	r26
    7520:	bf 93       	push	r27
    7522:	ef 93       	push	r30
    7524:	ff 93       	push	r31
    7526:	86 ec       	ldi	r24, 0xC6	; 198
    7528:	90 e0       	ldi	r25, 0x00	; 0
    752a:	0e 94 ea 35 	call	0x6bd4	; 0x6bd4 <Modbus_TX>
    752e:	ff 91       	pop	r31
    7530:	ef 91       	pop	r30
    7532:	bf 91       	pop	r27
    7534:	af 91       	pop	r26
    7536:	9f 91       	pop	r25
    7538:	8f 91       	pop	r24
    753a:	7f 91       	pop	r23
    753c:	6f 91       	pop	r22
    753e:	5f 91       	pop	r21
    7540:	4f 91       	pop	r20
    7542:	3f 91       	pop	r19
    7544:	2f 91       	pop	r18
    7546:	0f 90       	pop	r0
    7548:	0b be       	out	0x3b, r0	; 59
    754a:	0f 90       	pop	r0
    754c:	0f be       	out	0x3f, r0	; 63
    754e:	0f 90       	pop	r0
    7550:	1f 90       	pop	r1
    7552:	18 95       	reti

00007554 <__vector_26>:
    7554:	1f 92       	push	r1
    7556:	0f 92       	push	r0
    7558:	0f b6       	in	r0, 0x3f	; 63
    755a:	0f 92       	push	r0
    755c:	0b b6       	in	r0, 0x3b	; 59
    755e:	0f 92       	push	r0
    7560:	11 24       	eor	r1, r1
    7562:	2f 93       	push	r18
    7564:	3f 93       	push	r19
    7566:	4f 93       	push	r20
    7568:	5f 93       	push	r21
    756a:	6f 93       	push	r22
    756c:	7f 93       	push	r23
    756e:	8f 93       	push	r24
    7570:	9f 93       	push	r25
    7572:	af 93       	push	r26
    7574:	bf 93       	push	r27
    7576:	ef 93       	push	r30
    7578:	ff 93       	push	r31
    757a:	86 ec       	ldi	r24, 0xC6	; 198
    757c:	90 e0       	ldi	r25, 0x00	; 0
    757e:	0e 94 ea 35 	call	0x6bd4	; 0x6bd4 <Modbus_TX>
    7582:	ff 91       	pop	r31
    7584:	ef 91       	pop	r30
    7586:	bf 91       	pop	r27
    7588:	af 91       	pop	r26
    758a:	9f 91       	pop	r25
    758c:	8f 91       	pop	r24
    758e:	7f 91       	pop	r23
    7590:	6f 91       	pop	r22
    7592:	5f 91       	pop	r21
    7594:	4f 91       	pop	r20
    7596:	3f 91       	pop	r19
    7598:	2f 91       	pop	r18
    759a:	0f 90       	pop	r0
    759c:	0b be       	out	0x3b, r0	; 59
    759e:	0f 90       	pop	r0
    75a0:	0f be       	out	0x3f, r0	; 63
    75a2:	0f 90       	pop	r0
    75a4:	1f 90       	pop	r1
    75a6:	18 95       	reti

000075a8 <__vector_36>:

		// ~~~~~~~~~~
		// USART1 - PORT1
		Modbus_ISR(1)
    75a8:	1f 92       	push	r1
    75aa:	0f 92       	push	r0
    75ac:	0f b6       	in	r0, 0x3f	; 63
    75ae:	0f 92       	push	r0
    75b0:	0b b6       	in	r0, 0x3b	; 59
    75b2:	0f 92       	push	r0
    75b4:	11 24       	eor	r1, r1
    75b6:	2f 93       	push	r18
    75b8:	3f 93       	push	r19
    75ba:	4f 93       	push	r20
    75bc:	5f 93       	push	r21
    75be:	6f 93       	push	r22
    75c0:	7f 93       	push	r23
    75c2:	8f 93       	push	r24
    75c4:	9f 93       	push	r25
    75c6:	af 93       	push	r26
    75c8:	bf 93       	push	r27
    75ca:	ef 93       	push	r30
    75cc:	ff 93       	push	r31
    75ce:	8e ec       	ldi	r24, 0xCE	; 206
    75d0:	90 e0       	ldi	r25, 0x00	; 0
    75d2:	0e 94 4b 2a 	call	0x5496	; 0x5496 <Modbus_RX>
    75d6:	ff 91       	pop	r31
    75d8:	ef 91       	pop	r30
    75da:	bf 91       	pop	r27
    75dc:	af 91       	pop	r26
    75de:	9f 91       	pop	r25
    75e0:	8f 91       	pop	r24
    75e2:	7f 91       	pop	r23
    75e4:	6f 91       	pop	r22
    75e6:	5f 91       	pop	r21
    75e8:	4f 91       	pop	r20
    75ea:	3f 91       	pop	r19
    75ec:	2f 91       	pop	r18
    75ee:	0f 90       	pop	r0
    75f0:	0b be       	out	0x3b, r0	; 59
    75f2:	0f 90       	pop	r0
    75f4:	0f be       	out	0x3f, r0	; 63
    75f6:	0f 90       	pop	r0
    75f8:	1f 90       	pop	r1
    75fa:	18 95       	reti

000075fc <__vector_38>:
    75fc:	1f 92       	push	r1
    75fe:	0f 92       	push	r0
    7600:	0f b6       	in	r0, 0x3f	; 63
    7602:	0f 92       	push	r0
    7604:	0b b6       	in	r0, 0x3b	; 59
    7606:	0f 92       	push	r0
    7608:	11 24       	eor	r1, r1
    760a:	2f 93       	push	r18
    760c:	3f 93       	push	r19
    760e:	4f 93       	push	r20
    7610:	5f 93       	push	r21
    7612:	6f 93       	push	r22
    7614:	7f 93       	push	r23
    7616:	8f 93       	push	r24
    7618:	9f 93       	push	r25
    761a:	af 93       	push	r26
    761c:	bf 93       	push	r27
    761e:	ef 93       	push	r30
    7620:	ff 93       	push	r31
    7622:	8e ec       	ldi	r24, 0xCE	; 206
    7624:	90 e0       	ldi	r25, 0x00	; 0
    7626:	0e 94 ea 35 	call	0x6bd4	; 0x6bd4 <Modbus_TX>
    762a:	ff 91       	pop	r31
    762c:	ef 91       	pop	r30
    762e:	bf 91       	pop	r27
    7630:	af 91       	pop	r26
    7632:	9f 91       	pop	r25
    7634:	8f 91       	pop	r24
    7636:	7f 91       	pop	r23
    7638:	6f 91       	pop	r22
    763a:	5f 91       	pop	r21
    763c:	4f 91       	pop	r20
    763e:	3f 91       	pop	r19
    7640:	2f 91       	pop	r18
    7642:	0f 90       	pop	r0
    7644:	0b be       	out	0x3b, r0	; 59
    7646:	0f 90       	pop	r0
    7648:	0f be       	out	0x3f, r0	; 63
    764a:	0f 90       	pop	r0
    764c:	1f 90       	pop	r1
    764e:	18 95       	reti

00007650 <__vector_37>:
    7650:	1f 92       	push	r1
    7652:	0f 92       	push	r0
    7654:	0f b6       	in	r0, 0x3f	; 63
    7656:	0f 92       	push	r0
    7658:	0b b6       	in	r0, 0x3b	; 59
    765a:	0f 92       	push	r0
    765c:	11 24       	eor	r1, r1
    765e:	2f 93       	push	r18
    7660:	3f 93       	push	r19
    7662:	4f 93       	push	r20
    7664:	5f 93       	push	r21
    7666:	6f 93       	push	r22
    7668:	7f 93       	push	r23
    766a:	8f 93       	push	r24
    766c:	9f 93       	push	r25
    766e:	af 93       	push	r26
    7670:	bf 93       	push	r27
    7672:	ef 93       	push	r30
    7674:	ff 93       	push	r31
    7676:	8e ec       	ldi	r24, 0xCE	; 206
    7678:	90 e0       	ldi	r25, 0x00	; 0
    767a:	0e 94 ea 35 	call	0x6bd4	; 0x6bd4 <Modbus_TX>
    767e:	ff 91       	pop	r31
    7680:	ef 91       	pop	r30
    7682:	bf 91       	pop	r27
    7684:	af 91       	pop	r26
    7686:	9f 91       	pop	r25
    7688:	8f 91       	pop	r24
    768a:	7f 91       	pop	r23
    768c:	6f 91       	pop	r22
    768e:	5f 91       	pop	r21
    7690:	4f 91       	pop	r20
    7692:	3f 91       	pop	r19
    7694:	2f 91       	pop	r18
    7696:	0f 90       	pop	r0
    7698:	0b be       	out	0x3b, r0	; 59
    769a:	0f 90       	pop	r0
    769c:	0f be       	out	0x3f, r0	; 63
    769e:	0f 90       	pop	r0
    76a0:	1f 90       	pop	r1
    76a2:	18 95       	reti

000076a4 <__vector_52>:

		// USART2 - PORT2 (only GSM)
		#ifdef GSM
			#ifndef SIM300DZ
				ISR(USART2_UDRE_vect) {GSM_DRE();}
    76a4:	1f 92       	push	r1
    76a6:	0f 92       	push	r0
    76a8:	0f b6       	in	r0, 0x3f	; 63
    76aa:	0f 92       	push	r0
    76ac:	0b b6       	in	r0, 0x3b	; 59
    76ae:	0f 92       	push	r0
    76b0:	11 24       	eor	r1, r1
    76b2:	2f 93       	push	r18
    76b4:	3f 93       	push	r19
    76b6:	4f 93       	push	r20
    76b8:	5f 93       	push	r21
    76ba:	6f 93       	push	r22
    76bc:	7f 93       	push	r23
    76be:	8f 93       	push	r24
    76c0:	9f 93       	push	r25
    76c2:	af 93       	push	r26
    76c4:	bf 93       	push	r27
    76c6:	ef 93       	push	r30
    76c8:	ff 93       	push	r31
    76ca:	0e 94 29 3a 	call	0x7452	; 0x7452 <GSM_DRE>
    76ce:	ff 91       	pop	r31
    76d0:	ef 91       	pop	r30
    76d2:	bf 91       	pop	r27
    76d4:	af 91       	pop	r26
    76d6:	9f 91       	pop	r25
    76d8:	8f 91       	pop	r24
    76da:	7f 91       	pop	r23
    76dc:	6f 91       	pop	r22
    76de:	5f 91       	pop	r21
    76e0:	4f 91       	pop	r20
    76e2:	3f 91       	pop	r19
    76e4:	2f 91       	pop	r18
    76e6:	0f 90       	pop	r0
    76e8:	0b be       	out	0x3b, r0	; 59
    76ea:	0f 90       	pop	r0
    76ec:	0f be       	out	0x3f, r0	; 63
    76ee:	0f 90       	pop	r0
    76f0:	1f 90       	pop	r1
    76f2:	18 95       	reti

000076f4 <__vector_53>:
			#endif
			ISR(USART2_TX_vect) {GSM_TX();}
    76f4:	1f 92       	push	r1
    76f6:	0f 92       	push	r0
    76f8:	0f b6       	in	r0, 0x3f	; 63
    76fa:	0f 92       	push	r0
    76fc:	0b b6       	in	r0, 0x3b	; 59
    76fe:	0f 92       	push	r0
    7700:	11 24       	eor	r1, r1
    7702:	2f 93       	push	r18
    7704:	3f 93       	push	r19
    7706:	4f 93       	push	r20
    7708:	5f 93       	push	r21
    770a:	6f 93       	push	r22
    770c:	7f 93       	push	r23
    770e:	8f 93       	push	r24
    7710:	9f 93       	push	r25
    7712:	af 93       	push	r26
    7714:	bf 93       	push	r27
    7716:	ef 93       	push	r30
    7718:	ff 93       	push	r31
    771a:	0e 94 41 3a 	call	0x7482	; 0x7482 <GSM_TX>
    771e:	ff 91       	pop	r31
    7720:	ef 91       	pop	r30
    7722:	bf 91       	pop	r27
    7724:	af 91       	pop	r26
    7726:	9f 91       	pop	r25
    7728:	8f 91       	pop	r24
    772a:	7f 91       	pop	r23
    772c:	6f 91       	pop	r22
    772e:	5f 91       	pop	r21
    7730:	4f 91       	pop	r20
    7732:	3f 91       	pop	r19
    7734:	2f 91       	pop	r18
    7736:	0f 90       	pop	r0
    7738:	0b be       	out	0x3b, r0	; 59
    773a:	0f 90       	pop	r0
    773c:	0f be       	out	0x3f, r0	; 63
    773e:	0f 90       	pop	r0
    7740:	1f 90       	pop	r1
    7742:	18 95       	reti

00007744 <__vector_51>:
			ISR(USART2_RX_vect) {GSM_RX();}
    7744:	1f 92       	push	r1
    7746:	0f 92       	push	r0
    7748:	0f b6       	in	r0, 0x3f	; 63
    774a:	0f 92       	push	r0
    774c:	0b b6       	in	r0, 0x3b	; 59
    774e:	0f 92       	push	r0
    7750:	11 24       	eor	r1, r1
    7752:	2f 93       	push	r18
    7754:	3f 93       	push	r19
    7756:	4f 93       	push	r20
    7758:	5f 93       	push	r21
    775a:	6f 93       	push	r22
    775c:	7f 93       	push	r23
    775e:	8f 93       	push	r24
    7760:	9f 93       	push	r25
    7762:	af 93       	push	r26
    7764:	bf 93       	push	r27
    7766:	ef 93       	push	r30
    7768:	ff 93       	push	r31
    776a:	0e 94 d3 39 	call	0x73a6	; 0x73a6 <GSM_RX>
    776e:	ff 91       	pop	r31
    7770:	ef 91       	pop	r30
    7772:	bf 91       	pop	r27
    7774:	af 91       	pop	r26
    7776:	9f 91       	pop	r25
    7778:	8f 91       	pop	r24
    777a:	7f 91       	pop	r23
    777c:	6f 91       	pop	r22
    777e:	5f 91       	pop	r21
    7780:	4f 91       	pop	r20
    7782:	3f 91       	pop	r19
    7784:	2f 91       	pop	r18
    7786:	0f 90       	pop	r0
    7788:	0b be       	out	0x3b, r0	; 59
    778a:	0f 90       	pop	r0
    778c:	0f be       	out	0x3f, r0	; 63
    778e:	0f 90       	pop	r0
    7790:	1f 90       	pop	r1
    7792:	18 95       	reti

00007794 <KeypadInit>:
		for (uint8_t str=0; str<sizeof(KeyStr); str++) {
			uint8_t KS = prb(KeyStr+str);
			DDR_Key &=~KS;
			PortKey |=KS;
		}*/
		DDR_KeyROW1 |= KeyROW1;
    7794:	81 9a       	sbi	0x10, 1	; 16
		DDR_KeyROW2 |= KeyROW2;
    7796:	80 9a       	sbi	0x10, 0	; 16
		PortKeyROW1 |= KeyROW1;
    7798:	89 9a       	sbi	0x11, 1	; 17
		PortKeyROW2 |= KeyROW2;
    779a:	88 9a       	sbi	0x11, 0	; 17
		
		DDR_KeySTR1 &= ~KeySTR1;
    779c:	85 98       	cbi	0x10, 5	; 16
		DDR_KeySTR2 &= ~KeySTR2;
    779e:	84 98       	cbi	0x10, 4	; 16
		DDR_KeySTR3 &= ~KeySTR3;
    77a0:	82 98       	cbi	0x10, 2	; 16
		PortKeySTR1 |= KeySTR1;
    77a2:	8d 9a       	sbi	0x11, 5	; 17
		PortKeySTR2 |= KeySTR2;
    77a4:	8c 9a       	sbi	0x11, 4	; 17
		PortKeySTR3 |= KeySTR3;
    77a6:	8a 9a       	sbi	0x11, 2	; 17
}

uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    77a8:	80 91 cf 02 	lds	r24, 0x02CF
	VacantTimer8Sys += n;
    77ac:	8f 5f       	subi	r24, 0xFF	; 255
    77ae:	80 93 cf 02 	sts	0x02CF, r24
    77b2:	81 50       	subi	r24, 0x01	; 1
		PORTJ.DIRCLR = (1<<7);
		for (uint8_t str=1; str<sizeof(KeyStr); str++)
			PORTK.DIRCLR = prb(KeyStr+str);
		PORTJ.PIN7CTRL = PORTK.PIN0CTRL = PORTK.PIN1CTRL = PORTK.PIN2CTRL = PORTK.PIN3CTRL = PORT_OPC_PULLUP_gc;
	#endif
	TD_Keypad = Timer8SysAlloc(1);
    77b4:	80 93 f1 04 	sts	0x04F1, r24
}
    77b8:	08 95       	ret

000077ba <KeypadIn>:
	return KeyPressedNonFilter = Key;
}
// ~~~~~~~~~~~
uint8_t
KeypadIn(void)
{
    77ba:	0f 93       	push	r16
    77bc:	1f 93       	push	r17
			}
		}
		RowOff(KR);
	}*/

	cli(); PortKeyROW1 &= ~KeyROW1; sei();
    77be:	f8 94       	cli
    77c0:	89 98       	cbi	0x11, 1	; 17
    77c2:	78 94       	sei
    77c4:	85 e3       	ldi	r24, 0x35	; 53
    77c6:	8a 95       	dec	r24
    77c8:	f1 f7       	brne	.-4      	; 0x77c6 <KeypadIn+0xc>
	_delay_us(10);		// By trial
	if(!(PIN_KeySTR1 & (KeySTR1))){ Key=2; PresKeysQuant++;} 
    77ca:	7d 99       	sbic	0x0f, 5	; 15
    77cc:	38 c0       	rjmp	.+112    	; 0x783e <KeypadIn+0x84>
    77ce:	91 e0       	ldi	r25, 0x01	; 1
    77d0:	02 e0       	ldi	r16, 0x02	; 2
	if(!(PIN_KeySTR2 & (KeySTR2))){ Key=6; PresKeysQuant++;} 
    77d2:	7c 99       	sbic	0x0f, 4	; 15
    77d4:	02 c0       	rjmp	.+4      	; 0x77da <KeypadIn+0x20>
    77d6:	9f 5f       	subi	r25, 0xFF	; 255
    77d8:	06 e0       	ldi	r16, 0x06	; 6
	if(!(PIN_KeySTR3 & (KeySTR3))){ Key=4; PresKeysQuant++;} 
    77da:	7a 99       	sbic	0x0f, 2	; 15
    77dc:	02 c0       	rjmp	.+4      	; 0x77e2 <KeypadIn+0x28>
    77de:	9f 5f       	subi	r25, 0xFF	; 255
    77e0:	04 e0       	ldi	r16, 0x04	; 4
	cli(); PortKeyROW1 |= KeyROW1; sei();	
    77e2:	f8 94       	cli
    77e4:	89 9a       	sbi	0x11, 1	; 17
    77e6:	78 94       	sei

	cli(); PortKeyROW2 &= ~KeyROW2; sei();
    77e8:	f8 94       	cli
    77ea:	88 98       	cbi	0x11, 0	; 17
    77ec:	78 94       	sei
    77ee:	85 e3       	ldi	r24, 0x35	; 53
    77f0:	8a 95       	dec	r24
    77f2:	f1 f7       	brne	.-4      	; 0x77f0 <KeypadIn+0x36>
	_delay_us(10);		// By trial
	if(!(PIN_KeySTR1 & (KeySTR1))){ Key=1; PresKeysQuant++;}
    77f4:	7d 99       	sbic	0x0f, 5	; 15
    77f6:	02 c0       	rjmp	.+4      	; 0x77fc <KeypadIn+0x42>
    77f8:	9f 5f       	subi	r25, 0xFF	; 255
    77fa:	01 e0       	ldi	r16, 0x01	; 1
	if(!(PIN_KeySTR2 & (KeySTR2))){ Key=5; PresKeysQuant++;}
    77fc:	7c 99       	sbic	0x0f, 4	; 15
    77fe:	02 c0       	rjmp	.+4      	; 0x7804 <KeypadIn+0x4a>
    7800:	9f 5f       	subi	r25, 0xFF	; 255
    7802:	05 e0       	ldi	r16, 0x05	; 5
	if(!(PIN_KeySTR3 & (KeySTR3))){ Key=3; PresKeysQuant++;}
    7804:	7a 99       	sbic	0x0f, 2	; 15
    7806:	02 c0       	rjmp	.+4      	; 0x780c <KeypadIn+0x52>
    7808:	9f 5f       	subi	r25, 0xFF	; 255
    780a:	03 e0       	ldi	r16, 0x03	; 3
	cli(); PortKeyROW2 |= KeyROW2; sei();
    780c:	f8 94       	cli
    780e:	88 9a       	sbi	0x11, 0	; 17
    7810:	78 94       	sei
	if(PresKeysQuant!=1) Key = 0;
    7812:	91 30       	cpi	r25, 0x01	; 1
    7814:	09 f4       	brne	.+2      	; 0x7818 <KeypadIn+0x5e>
    7816:	4a c0       	rjmp	.+148    	; 0x78ac <KeypadIn+0xf2>

	return KeyPressedNonFilter = Key;
    7818:	10 92 c9 08 	sts	0x08C9, r1
    781c:	00 e0       	ldi	r16, 0x00	; 0
{
	static uint8_t PrevKey;
	uint8_t KeyResult = 0;
	uint8_t Key = KeypadScan();	//   
	if(Key) KeyPressedCounter++;
	if(Key != PrevKey){			//     -   
    781e:	80 91 e3 02 	lds	r24, 0x02E3
    7822:	80 17       	cp	r24, r16
    7824:	11 f0       	breq	.+4      	; 0x782a <KeypadIn+0x70>
		PrevKey = 0;
    7826:	10 92 e3 02 	sts	0x02E3, r1
	}
	
	if (Timer8Stopp(TD_Keypad)) {
    782a:	10 91 f1 04 	lds	r17, 0x04F1
    782e:	81 2f       	mov	r24, r17
    7830:	0e 94 4e 1c 	call	0x389c	; 0x389c <Timer8Stopp>
    7834:	88 23       	and	r24, r24
    7836:	31 f4       	brne	.+12     	; 0x7844 <KeypadIn+0x8a>
					for(I=0;I<=(KeyQuantity/8);I++) *((uint8_t*)RKEY+I) = 0;
				}
		#endif
	}
	return KeyResult;
}
    7838:	1f 91       	pop	r17
    783a:	0f 91       	pop	r16
    783c:	08 95       	ret
		RowOff(KR);
	}*/

	cli(); PortKeyROW1 &= ~KeyROW1; sei();
	_delay_us(10);		// By trial
	if(!(PIN_KeySTR1 & (KeySTR1))){ Key=2; PresKeysQuant++;} 
    783e:	90 e0       	ldi	r25, 0x00	; 0
    7840:	00 e0       	ldi	r16, 0x00	; 0
    7842:	c7 cf       	rjmp	.-114    	; 0x77d2 <KeypadIn+0x18>
	if(Key != PrevKey){			//     -   
		PrevKey = 0;
	}
	
	if (Timer8Stopp(TD_Keypad)) {
		StartTimer8(TD_Keypad, 6);	// By trial keystroke time == 70-180 ms
    7844:	81 2f       	mov	r24, r17
    7846:	66 e0       	ldi	r22, 0x06	; 6
    7848:	0e 94 fa 1a 	call	0x35f4	; 0x35f4 <StartTimer8>
		if (Key != PrevKey) {
    784c:	80 91 e3 02 	lds	r24, 0x02E3
    7850:	80 17       	cp	r24, r16
    7852:	09 f4       	brne	.+2      	; 0x7856 <KeypadIn+0x9c>
    7854:	44 c0       	rjmp	.+136    	; 0x78de <KeypadIn+0x124>
				PrevKey = Key;
    7856:	00 93 e3 02 	sts	0x02E3, r16
				Key = 0;
				KeyStroke = 0;
    785a:	10 92 f0 04 	sts	0x04F0, r1

		#ifdef RKEY
			#ifdef QslRD
				if(!*(uint8_t*)RNUM)
			#endif
				if (KeyResult==0) {
    785e:	40 e0       	ldi	r20, 0x00	; 0
    7860:	50 e0       	ldi	r21, 0x00	; 0
					uint8_t I = 0;
					while (1<<(I++ & 0b00000111) != *((uint8_t*)RKEY+(I>>3)) && I<=KeyQuantity);
    7862:	a1 e0       	ldi	r26, 0x01	; 1
    7864:	b0 e0       	ldi	r27, 0x00	; 0

		#ifdef RKEY
			#ifdef QslRD
				if(!*(uint8_t*)RNUM)
			#endif
				if (KeyResult==0) {
    7866:	e4 2f       	mov	r30, r20
    7868:	64 2f       	mov	r22, r20
    786a:	6f 5f       	subi	r22, 0xFF	; 255
					uint8_t I = 0;
					while (1<<(I++ & 0b00000111) != *((uint8_t*)RKEY+(I>>3)) && I<=KeyQuantity);
    786c:	9a 01       	movw	r18, r20
    786e:	27 70       	andi	r18, 0x07	; 7
    7870:	30 70       	andi	r19, 0x00	; 0
    7872:	cd 01       	movw	r24, r26
    7874:	02 c0       	rjmp	.+4      	; 0x787a <KeypadIn+0xc0>
    7876:	88 0f       	add	r24, r24
    7878:	99 1f       	adc	r25, r25
    787a:	2a 95       	dec	r18
    787c:	e2 f7       	brpl	.-8      	; 0x7876 <KeypadIn+0xbc>
    787e:	9c 01       	movw	r18, r24
    7880:	e6 95       	lsr	r30
    7882:	e6 95       	lsr	r30
    7884:	e6 95       	lsr	r30
    7886:	f0 e0       	ldi	r31, 0x00	; 0
    7888:	e7 58       	subi	r30, 0x87	; 135
    788a:	f8 4f       	sbci	r31, 0xF8	; 248
    788c:	80 81       	ld	r24, Z
    788e:	90 e0       	ldi	r25, 0x00	; 0
    7890:	28 17       	cp	r18, r24
    7892:	39 07       	cpc	r19, r25
    7894:	b1 f1       	breq	.+108    	; 0x7902 <KeypadIn+0x148>
    7896:	4f 5f       	subi	r20, 0xFF	; 255
    7898:	5f 4f       	sbci	r21, 0xFF	; 255
    789a:	47 30       	cpi	r20, 0x07	; 7
    789c:	51 05       	cpc	r21, r1
    789e:	19 f7       	brne	.-58     	; 0x7866 <KeypadIn+0xac>
					if (I<=KeyQuantity)
    78a0:	80 e0       	ldi	r24, 0x00	; 0
						KeyResult = I;
					for(I=0;I<=(KeyQuantity/8);I++) *((uint8_t*)RKEY+I) = 0;
    78a2:	10 92 79 07 	sts	0x0779, r1
				}
		#endif
	}
	return KeyResult;
}
    78a6:	1f 91       	pop	r17
    78a8:	0f 91       	pop	r16
    78aa:	08 95       	ret
	if(!(PIN_KeySTR2 & (KeySTR2))){ Key=5; PresKeysQuant++;}
	if(!(PIN_KeySTR3 & (KeySTR3))){ Key=3; PresKeysQuant++;}
	cli(); PortKeyROW2 |= KeyROW2; sei();
	if(PresKeysQuant!=1) Key = 0;

	return KeyPressedNonFilter = Key;
    78ac:	00 93 c9 08 	sts	0x08C9, r16
KeypadIn(void)
{
	static uint8_t PrevKey;
	uint8_t KeyResult = 0;
	uint8_t Key = KeypadScan();	//   
	if(Key) KeyPressedCounter++;
    78b0:	00 23       	and	r16, r16
    78b2:	09 f4       	brne	.+2      	; 0x78b6 <KeypadIn+0xfc>
    78b4:	b4 cf       	rjmp	.-152    	; 0x781e <KeypadIn+0x64>
    78b6:	80 91 f6 06 	lds	r24, 0x06F6
    78ba:	90 91 f7 06 	lds	r25, 0x06F7
    78be:	a0 91 f8 06 	lds	r26, 0x06F8
    78c2:	b0 91 f9 06 	lds	r27, 0x06F9
    78c6:	01 96       	adiw	r24, 0x01	; 1
    78c8:	a1 1d       	adc	r26, r1
    78ca:	b1 1d       	adc	r27, r1
    78cc:	80 93 f6 06 	sts	0x06F6, r24
    78d0:	90 93 f7 06 	sts	0x06F7, r25
    78d4:	a0 93 f8 06 	sts	0x06F8, r26
    78d8:	b0 93 f9 06 	sts	0x06F9, r27
    78dc:	a0 cf       	rjmp	.-192    	; 0x781e <KeypadIn+0x64>
				PrevKey = Key;
				Key = 0;
				KeyStroke = 0;
		}
		else{
			KeyPressed = KeyResult = Key;
    78de:	00 93 6c 07 	sts	0x076C, r16
			if(KeyStroke<0xFF && ++KeyStroke>1 && KeyStroke<=0xF) KeyResult = 0;
    78e2:	90 91 f0 04 	lds	r25, 0x04F0
    78e6:	9f 3f       	cpi	r25, 0xFF	; 255
    78e8:	41 f0       	breq	.+16     	; 0x78fa <KeypadIn+0x140>
    78ea:	9f 5f       	subi	r25, 0xFF	; 255
    78ec:	90 93 f0 04 	sts	0x04F0, r25
    78f0:	92 30       	cpi	r25, 0x02	; 2
    78f2:	18 f0       	brcs	.+6      	; 0x78fa <KeypadIn+0x140>
    78f4:	90 31       	cpi	r25, 0x10	; 16
    78f6:	08 f4       	brcc	.+2      	; 0x78fa <KeypadIn+0x140>
    78f8:	b2 cf       	rjmp	.-156    	; 0x785e <KeypadIn+0xa4>

		#ifdef RKEY
			#ifdef QslRD
				if(!*(uint8_t*)RNUM)
			#endif
				if (KeyResult==0) {
    78fa:	88 23       	and	r24, r24
    78fc:	09 f0       	breq	.+2      	; 0x7900 <KeypadIn+0x146>
    78fe:	9c cf       	rjmp	.-200    	; 0x7838 <KeypadIn+0x7e>
    7900:	ae cf       	rjmp	.-164    	; 0x785e <KeypadIn+0xa4>
					uint8_t I = 0;
					while (1<<(I++ & 0b00000111) != *((uint8_t*)RKEY+(I>>3)) && I<=KeyQuantity);
					if (I<=KeyQuantity)
    7902:	67 30       	cpi	r22, 0x07	; 7
    7904:	68 f6       	brcc	.-102    	; 0x78a0 <KeypadIn+0xe6>
    7906:	86 2f       	mov	r24, r22
    7908:	cc cf       	rjmp	.-104    	; 0x78a2 <KeypadIn+0xe8>

0000790a <InitBufStr>:
static uint8_t Minus;
// ~~~~~~~~~~~
char BufStr[LCDXSz+1];
uint8_t CurrFieldSize;

void InitBufStr(OutField *Field){
    790a:	e1 ec       	ldi	r30, 0xC1	; 193
    790c:	f5 e0       	ldi	r31, 0x05	; 5
	for(uint8_t i =0; i<LCDXSz; i++) BufStr[i]=' ';
    790e:	80 e2       	ldi	r24, 0x20	; 32
    7910:	81 93       	st	Z+, r24
    7912:	95 e0       	ldi	r25, 0x05	; 5
    7914:	e5 3d       	cpi	r30, 0xD5	; 213
    7916:	f9 07       	cpc	r31, r25
    7918:	d9 f7       	brne	.-10     	; 0x7910 <InitBufStr+0x6>
	BufStr[LCDXSz] ='\0';
    791a:	10 82       	st	Z, r1
	CurrFieldSize = 0;
    791c:	10 92 7a 07 	sts	0x077A, r1
	MultiSymbol = 0;
    7920:	10 92 f2 04 	sts	0x04F2, r1
}
    7924:	08 95       	ret

00007926 <EventFunc>:

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    7926:	fc 01       	movw	r30, r24
    7928:	85 91       	lpm	r24, Z+
    792a:	94 91       	lpm	r25, Z+
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
EventFunc(const MenuEvent *Event)
{
	MenuEvent Func = prp(Event);
	if (Func)
    792c:	00 97       	sbiw	r24, 0x00	; 0
    792e:	11 f0       	breq	.+4      	; 0x7934 <EventFunc+0xe>
		Func();
    7930:	fc 01       	movw	r30, r24
    7932:	19 95       	eicall
    7934:	08 95       	ret

00007936 <KeyFunc>:
    7936:	fc 01       	movw	r30, r24
    7938:	85 91       	lpm	r24, Z+
    793a:	94 91       	lpm	r25, Z+
// ~~~~~~~~~~~~~~~~~~~~~~~~
static uint8_t
KeyFunc(const MenuKey *Key)
{
	MenuKey Func=prp(Key);
	return Func && Func()==CustomKey;
    793c:	00 97       	sbiw	r24, 0x00	; 0
    793e:	51 f0       	breq	.+20     	; 0x7954 <KeyFunc+0x1e>
    7940:	fc 01       	movw	r30, r24
    7942:	19 95       	eicall
    7944:	90 e0       	ldi	r25, 0x00	; 0
    7946:	81 30       	cpi	r24, 0x01	; 1
    7948:	09 f0       	breq	.+2      	; 0x794c <KeyFunc+0x16>
    794a:	91 e0       	ldi	r25, 0x01	; 1
    794c:	81 e0       	ldi	r24, 0x01	; 1
    794e:	98 27       	eor	r25, r24
}
    7950:	89 2f       	mov	r24, r25
    7952:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~~~
static uint8_t
KeyFunc(const MenuKey *Key)
{
	MenuKey Func=prp(Key);
	return Func && Func()==CustomKey;
    7954:	90 e0       	ldi	r25, 0x00	; 0
}
    7956:	89 2f       	mov	r24, r25
    7958:	08 95       	ret

0000795a <GotoMenu>:

// ~~~~~~~~~~~~~~~~~~~~~
void
GotoMenu(MenuPage *Menu)
{
    795a:	cf 93       	push	r28
    795c:	df 93       	push	r29
    795e:	ec 01       	movw	r28, r24
	EventFunc(&CurrPage->Exit);
    7960:	80 91 d4 02 	lds	r24, 0x02D4
    7964:	90 91 d5 02 	lds	r25, 0x02D5
    7968:	0a 96       	adiw	r24, 0x0a	; 10
    796a:	0e 94 93 3c 	call	0x7926	; 0x7926 <EventFunc>
    796e:	fe 01       	movw	r30, r28
    7970:	34 96       	adiw	r30, 0x04	; 4
    7972:	85 91       	lpm	r24, Z+
    7974:	94 91       	lpm	r25, Z+
	if(prp(&Menu->OutPage))
    7976:	89 2b       	or	r24, r25
    7978:	c9 f0       	breq	.+50     	; 0x79ac <GotoMenu+0x52>
		MenuDepth=0;
    797a:	10 92 74 07 	sts	0x0774, r1
	else {
		MenuStack[MenuDepth].Page = CurrPage;
		MenuStack[MenuDepth].Line = CurrLine;
		MenuStack[MenuDepth++].LCD = CurrLCD;
	}
	CurrPage = Menu;
    797e:	d0 93 d5 02 	sts	0x02D5, r29
    7982:	c0 93 d4 02 	sts	0x02D4, r28

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    7986:	23 96       	adiw	r28, 0x03	; 3
    7988:	fe 01       	movw	r30, r28
    798a:	84 91       	lpm	r24, Z+
	CurrLine = CurrLCD = GetFix();
    798c:	80 93 a0 08 	sts	0x08A0, r24
    7990:	80 93 83 07 	sts	0x0783, r24
	CurrField = CurrPos = NullPos;
    7994:	8f ef       	ldi	r24, 0xFF	; 255
    7996:	80 93 d7 02 	sts	0x02D7, r24
    799a:	80 93 d6 02 	sts	0x02D6, r24
	EventFunc(&CurrPage->Load);
    799e:	ce 01       	movw	r24, r28
    79a0:	03 96       	adiw	r24, 0x03	; 3
    79a2:	0e 94 93 3c 	call	0x7926	; 0x7926 <EventFunc>
}
    79a6:	df 91       	pop	r29
    79a8:	cf 91       	pop	r28
    79aa:	08 95       	ret
{
	EventFunc(&CurrPage->Exit);
	if(prp(&Menu->OutPage))
		MenuDepth=0;
	else {
		MenuStack[MenuDepth].Page = CurrPage;
    79ac:	20 91 74 07 	lds	r18, 0x0774
    79b0:	e2 2f       	mov	r30, r18
    79b2:	f0 e0       	ldi	r31, 0x00	; 0
    79b4:	ee 0f       	add	r30, r30
    79b6:	ff 1f       	adc	r31, r31
    79b8:	ee 0f       	add	r30, r30
    79ba:	ff 1f       	adc	r31, r31
    79bc:	df 01       	movw	r26, r30
    79be:	af 55       	subi	r26, 0x5F	; 95
    79c0:	b7 4f       	sbci	r27, 0xF7	; 247
    79c2:	80 91 d4 02 	lds	r24, 0x02D4
    79c6:	90 91 d5 02 	lds	r25, 0x02D5
    79ca:	11 96       	adiw	r26, 0x01	; 1
    79cc:	9c 93       	st	X, r25
    79ce:	8e 93       	st	-X, r24
		MenuStack[MenuDepth].Line = CurrLine;
    79d0:	80 91 83 07 	lds	r24, 0x0783
    79d4:	13 96       	adiw	r26, 0x03	; 3
    79d6:	8c 93       	st	X, r24
		MenuStack[MenuDepth++].LCD = CurrLCD;
    79d8:	ed 55       	subi	r30, 0x5D	; 93
    79da:	f7 4f       	sbci	r31, 0xF7	; 247
    79dc:	80 91 a0 08 	lds	r24, 0x08A0
    79e0:	80 83       	st	Z, r24
    79e2:	2f 5f       	subi	r18, 0xFF	; 255
    79e4:	20 93 74 07 	sts	0x0774, r18
    79e8:	ca cf       	rjmp	.-108    	; 0x797e <GotoMenu+0x24>

000079ea <HideMsg>:

// ~~~~~~~~~~
uint8_t
HideMsg(void)
{
	if (CurrMsg) {
    79ea:	80 91 f3 04 	lds	r24, 0x04F3
    79ee:	90 91 f4 04 	lds	r25, 0x04F4
    79f2:	00 97       	sbiw	r24, 0x00	; 0
    79f4:	51 f0       	breq	.+20     	; 0x7a0a <HideMsg+0x20>
		EventFunc(&CurrMsg->Exit);
    79f6:	80 5a       	subi	r24, 0xA0	; 160
    79f8:	9f 4f       	sbci	r25, 0xFF	; 255
    79fa:	0e 94 93 3c 	call	0x7926	; 0x7926 <EventFunc>
		CurrMsg = NULL;
    79fe:	10 92 f4 04 	sts	0x04F4, r1
    7a02:	10 92 f3 04 	sts	0x04F3, r1
    7a06:	81 e0       	ldi	r24, 0x01	; 1
		return 1;
	}
	else
		return 0;
}
    7a08:	08 95       	ret

// ~~~~~~~~~~
uint8_t
HideMsg(void)
{
	if (CurrMsg) {
    7a0a:	80 e0       	ldi	r24, 0x00	; 0
    7a0c:	08 95       	ret

00007a0e <ShowMsg>:
}

// ~~~~~~~~~~~~~~~~~~
void
ShowMsg(MsgPage *Msg)
{
    7a0e:	0f 93       	push	r16
    7a10:	1f 93       	push	r17
    7a12:	8c 01       	movw	r16, r24
	HideMsg();
    7a14:	0e 94 f5 3c 	call	0x79ea	; 0x79ea <HideMsg>
	CurrMsg = Msg;
    7a18:	10 93 f4 04 	sts	0x04F4, r17
    7a1c:	00 93 f3 04 	sts	0x04F3, r16
	EventFunc(&CurrMsg->Load);
    7a20:	c8 01       	movw	r24, r16
    7a22:	84 5a       	subi	r24, 0xA4	; 164
    7a24:	9f 4f       	sbci	r25, 0xFF	; 255
    7a26:	0e 94 93 3c 	call	0x7926	; 0x7926 <EventFunc>
}
    7a2a:	1f 91       	pop	r17
    7a2c:	0f 91       	pop	r16
    7a2e:	08 95       	ret

00007a30 <MenuInit>:

// ~~~~~~~~~~~
void
MenuInit(void)
{
	CurrLCD = CurrLine = GetFix();
    7a30:	e0 91 d4 02 	lds	r30, 0x02D4
    7a34:	f0 91 d5 02 	lds	r31, 0x02D5
    7a38:	33 96       	adiw	r30, 0x03	; 3
    7a3a:	84 91       	lpm	r24, Z+
    7a3c:	80 93 83 07 	sts	0x0783, r24
    7a40:	80 93 a0 08 	sts	0x08A0, r24
	#ifdef InitMsg
		ShowMsg(&InitMsg);
	#endif
	EventFunc(&CurrPage->Load);
    7a44:	cf 01       	movw	r24, r30
    7a46:	03 96       	adiw	r24, 0x03	; 3
    7a48:	0e 94 93 3c 	call	0x7926	; 0x7926 <EventFunc>
}
    7a4c:	08 95       	ret

00007a4e <PosBlink>:
}

// ~~~~~~~~~~~~~~~~~~~~~
static void
PosBlink(T_Param *Param, char Cursor)
{
    7a4e:	fc 01       	movw	r30, r24
	CurrX=Param->Pos+Param->Size-CurrPos-(Param->Prec&&CurrPos>=Param->Prec?2:1)-LCD_Buf[Y1];
    7a50:	20 81       	ld	r18, Z
    7a52:	33 81       	ldd	r19, Z+3	; 0x03
    7a54:	90 91 d7 02 	lds	r25, 0x02D7
    7a58:	82 81       	ldd	r24, Z+2	; 0x02
    7a5a:	88 23       	and	r24, r24
    7a5c:	11 f0       	breq	.+4      	; 0x7a62 <PosBlink+0x14>
    7a5e:	98 17       	cp	r25, r24
    7a60:	a0 f4       	brcc	.+40     	; 0x7a8a <PosBlink+0x3c>
    7a62:	4f ef       	ldi	r20, 0xFF	; 255
    7a64:	39 1b       	sub	r19, r25
    7a66:	32 0f       	add	r19, r18
    7a68:	86 e5       	ldi	r24, 0x56	; 86
    7a6a:	96 e0       	ldi	r25, 0x06	; 6
    7a6c:	38 1b       	sub	r19, r24
    7a6e:	80 91 fd 09 	lds	r24, 0x09FD
    7a72:	25 e1       	ldi	r18, 0x15	; 21
    7a74:	82 9f       	mul	r24, r18
    7a76:	c0 01       	movw	r24, r0
    7a78:	11 24       	eor	r1, r1
    7a7a:	38 1b       	sub	r19, r24
    7a7c:	34 0f       	add	r19, r20
    7a7e:	30 93 b7 06 	sts	0x06B7, r19
	StrSize=1;
    7a82:	81 e0       	ldi	r24, 0x01	; 1
    7a84:	80 93 aa 06 	sts	0x06AA, r24
}
    7a88:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~~~
static void
PosBlink(T_Param *Param, char Cursor)
{
	CurrX=Param->Pos+Param->Size-CurrPos-(Param->Prec&&CurrPos>=Param->Prec?2:1)-LCD_Buf[Y1];
    7a8a:	4e ef       	ldi	r20, 0xFE	; 254
    7a8c:	eb cf       	rjmp	.-42     	; 0x7a64 <PosBlink+0x16>

00007a8e <GetCurrFieldSize>:

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    7a8e:	e0 91 d4 02 	lds	r30, 0x02D4
    7a92:	f0 91 d5 02 	lds	r31, 0x02D5
    7a96:	45 91       	lpm	r20, Z+
    7a98:	54 91       	lpm	r21, Z+
}
// ~~~~~~~~~~~~~~~~~~~~~~~
// Return size of CurrField. Use to determine size of Text, EE_Text OutField vars
uint8_t GetCurrFieldSize(void){
	uint8_t Size;
	MenuLine *Line=GetLine+CurrLine;
    7a9a:	80 91 83 07 	lds	r24, 0x0783
    7a9e:	2b e1       	ldi	r18, 0x1B	; 27
    7aa0:	82 9f       	mul	r24, r18
    7aa2:	c0 01       	movw	r24, r0
    7aa4:	11 24       	eor	r1, r1
    7aa6:	48 0f       	add	r20, r24
    7aa8:	59 1f       	adc	r21, r25
		while(prc(CurrStr+X)=='}'){
			X++;
			Size++;
		}
		if(Size){
			if(OF_N == CurrField) return Size;
    7aaa:	30 91 d6 02 	lds	r19, 0x02D6
    7aae:	90 e0       	ldi	r25, 0x00	; 0
    7ab0:	20 e0       	ldi	r18, 0x00	; 0

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    7ab2:	fa 01       	movw	r30, r20
    7ab4:	e9 0f       	add	r30, r25
    7ab6:	f1 1d       	adc	r31, r1
    7ab8:	e4 91       	lpm	r30, Z+
	MenuLine *Line=GetLine+CurrLine;
	PGM_P CurrStr=(PGM_P)(Line->Str);
	uint8_t OF_N = 0;
	for(uint8_t X=0; X<LCDXSz; X++){
		Size = 0;
		while(prc(CurrStr+X)=='}'){
    7aba:	ed 37       	cpi	r30, 0x7D	; 125
    7abc:	71 f4       	brne	.+28     	; 0x7ada <GetCurrFieldSize+0x4c>
			X++;
			Size++;
		}
		if(Size){
			if(OF_N == CurrField) return Size;
    7abe:	80 e0       	ldi	r24, 0x00	; 0
	PGM_P CurrStr=(PGM_P)(Line->Str);
	uint8_t OF_N = 0;
	for(uint8_t X=0; X<LCDXSz; X++){
		Size = 0;
		while(prc(CurrStr+X)=='}'){
			X++;
    7ac0:	9f 5f       	subi	r25, 0xFF	; 255
			Size++;
    7ac2:	8f 5f       	subi	r24, 0xFF	; 255
    7ac4:	fa 01       	movw	r30, r20
    7ac6:	e9 0f       	add	r30, r25
    7ac8:	f1 1d       	adc	r31, r1
    7aca:	e4 91       	lpm	r30, Z+
	MenuLine *Line=GetLine+CurrLine;
	PGM_P CurrStr=(PGM_P)(Line->Str);
	uint8_t OF_N = 0;
	for(uint8_t X=0; X<LCDXSz; X++){
		Size = 0;
		while(prc(CurrStr+X)=='}'){
    7acc:	ed 37       	cpi	r30, 0x7D	; 125
    7ace:	c1 f3       	breq	.-16     	; 0x7ac0 <GetCurrFieldSize+0x32>
			X++;
			Size++;
		}
		if(Size){
    7ad0:	88 23       	and	r24, r24
    7ad2:	19 f0       	breq	.+6      	; 0x7ada <GetCurrFieldSize+0x4c>
			if(OF_N == CurrField) return Size;
    7ad4:	23 17       	cp	r18, r19
    7ad6:	29 f0       	breq	.+10     	; 0x7ae2 <GetCurrFieldSize+0x54>
			OF_N++;
    7ad8:	2f 5f       	subi	r18, 0xFF	; 255
uint8_t GetCurrFieldSize(void){
	uint8_t Size;
	MenuLine *Line=GetLine+CurrLine;
	PGM_P CurrStr=(PGM_P)(Line->Str);
	uint8_t OF_N = 0;
	for(uint8_t X=0; X<LCDXSz; X++){
    7ada:	9f 5f       	subi	r25, 0xFF	; 255
    7adc:	94 31       	cpi	r25, 0x14	; 20
    7ade:	48 f3       	brcs	.-46     	; 0x7ab2 <GetCurrFieldSize+0x24>
		Size = 0;
		while(prc(CurrStr+X)=='}'){
    7ae0:	80 e0       	ldi	r24, 0x00	; 0
			if(OF_N == CurrField) return Size;
			OF_N++;
		}
	}
	return 0;
}
    7ae2:	08 95       	ret

00007ae4 <Inc>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
static int32_t
Inc(int8_t Dir, uint32_t Buf)
{
    7ae4:	5f 92       	push	r5
    7ae6:	6f 92       	push	r6
    7ae8:	7f 92       	push	r7
    7aea:	8f 92       	push	r8
    7aec:	9f 92       	push	r9
    7aee:	af 92       	push	r10
    7af0:	bf 92       	push	r11
    7af2:	cf 92       	push	r12
    7af4:	df 92       	push	r13
    7af6:	ef 92       	push	r14
    7af8:	ff 92       	push	r15
    7afa:	0f 93       	push	r16
    7afc:	1f 93       	push	r17
    7afe:	cf 93       	push	r28
    7b00:	df 93       	push	r29
    7b02:	58 2e       	mov	r5, r24
    7b04:	3a 01       	movw	r6, r20
    7b06:	4b 01       	movw	r8, r22
	uint32_t Pos = PowL10(CurrPos);
    7b08:	d0 90 d7 02 	lds	r13, 0x02D7
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
	uint32_t Pow = 1;
	while(Exp--)
    7b0c:	dd 20       	and	r13, r13
    7b0e:	09 f4       	brne	.+2      	; 0x7b12 <Inc+0x2e>
    7b10:	5f c0       	rjmp	.+190    	; 0x7bd0 <Inc+0xec>
    7b12:	61 e0       	ldi	r22, 0x01	; 1
    7b14:	e6 2e       	mov	r14, r22
    7b16:	f1 2c       	mov	r15, r1
    7b18:	01 2d       	mov	r16, r1
    7b1a:	11 2d       	mov	r17, r1
		Pow *= 10;
    7b1c:	c8 01       	movw	r24, r16
    7b1e:	b7 01       	movw	r22, r14
    7b20:	2a e0       	ldi	r18, 0x0A	; 10
    7b22:	30 e0       	ldi	r19, 0x00	; 0
    7b24:	40 e0       	ldi	r20, 0x00	; 0
    7b26:	50 e0       	ldi	r21, 0x00	; 0
    7b28:	0e 94 23 83 	call	0x10646	; 0x10646 <__mulsi3>
    7b2c:	7b 01       	movw	r14, r22
    7b2e:	8c 01       	movw	r16, r24
    7b30:	da 94       	dec	r13
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
	uint32_t Pow = 1;
	while(Exp--)
    7b32:	a1 f7       	brne	.-24     	; 0x7b1c <Inc+0x38>
    7b34:	5b 01       	movw	r10, r22
    7b36:	6c 01       	movw	r12, r24
	uint8_t Dig=Buf%(Pos*10)/Pos;
	if(Dig==(Dir==1?9:0)) {
    7b38:	81 e0       	ldi	r24, 0x01	; 1
    7b3a:	58 16       	cp	r5, r24
    7b3c:	09 f4       	brne	.+2      	; 0x7b40 <Inc+0x5c>
    7b3e:	45 c0       	rjmp	.+138    	; 0x7bca <Inc+0xe6>
    7b40:	c0 e0       	ldi	r28, 0x00	; 0
    7b42:	d0 e0       	ldi	r29, 0x00	; 0
    7b44:	c8 01       	movw	r24, r16
    7b46:	b7 01       	movw	r22, r14
    7b48:	2a e0       	ldi	r18, 0x0A	; 10
    7b4a:	30 e0       	ldi	r19, 0x00	; 0
    7b4c:	40 e0       	ldi	r20, 0x00	; 0
    7b4e:	50 e0       	ldi	r21, 0x00	; 0
    7b50:	0e 94 23 83 	call	0x10646	; 0x10646 <__mulsi3>
    7b54:	9b 01       	movw	r18, r22
    7b56:	ac 01       	movw	r20, r24
    7b58:	c4 01       	movw	r24, r8
    7b5a:	b3 01       	movw	r22, r6
    7b5c:	0e 94 75 83 	call	0x106ea	; 0x106ea <__udivmodsi4>
    7b60:	a8 01       	movw	r20, r16
    7b62:	97 01       	movw	r18, r14
    7b64:	0e 94 75 83 	call	0x106ea	; 0x106ea <__udivmodsi4>
    7b68:	30 e0       	ldi	r19, 0x00	; 0
    7b6a:	2c 17       	cp	r18, r28
    7b6c:	3d 07       	cpc	r19, r29
    7b6e:	99 f4       	brne	.+38     	; 0x7b96 <Inc+0xb2>
			Dir = -Dir;
    7b70:	51 94       	neg	r5
			Pos *= 9;
    7b72:	57 01       	movw	r10, r14
    7b74:	68 01       	movw	r12, r16
    7b76:	aa 0c       	add	r10, r10
    7b78:	bb 1c       	adc	r11, r11
    7b7a:	cc 1c       	adc	r12, r12
    7b7c:	dd 1c       	adc	r13, r13
    7b7e:	aa 0c       	add	r10, r10
    7b80:	bb 1c       	adc	r11, r11
    7b82:	cc 1c       	adc	r12, r12
    7b84:	dd 1c       	adc	r13, r13
    7b86:	aa 0c       	add	r10, r10
    7b88:	bb 1c       	adc	r11, r11
    7b8a:	cc 1c       	adc	r12, r12
    7b8c:	dd 1c       	adc	r13, r13
    7b8e:	ae 0c       	add	r10, r14
    7b90:	bf 1c       	adc	r11, r15
    7b92:	c0 1e       	adc	r12, r16
    7b94:	d1 1e       	adc	r13, r17
    7b96:	65 2d       	mov	r22, r5
    7b98:	77 27       	eor	r23, r23
    7b9a:	67 fd       	sbrc	r22, 7
    7b9c:	70 95       	com	r23
    7b9e:	87 2f       	mov	r24, r23
    7ba0:	97 2f       	mov	r25, r23
    7ba2:	a6 01       	movw	r20, r12
    7ba4:	95 01       	movw	r18, r10
    7ba6:	0e 94 23 83 	call	0x10646	; 0x10646 <__mulsi3>
	}
	return Pos*Dir;
}
    7baa:	df 91       	pop	r29
    7bac:	cf 91       	pop	r28
    7bae:	1f 91       	pop	r17
    7bb0:	0f 91       	pop	r16
    7bb2:	ff 90       	pop	r15
    7bb4:	ef 90       	pop	r14
    7bb6:	df 90       	pop	r13
    7bb8:	cf 90       	pop	r12
    7bba:	bf 90       	pop	r11
    7bbc:	af 90       	pop	r10
    7bbe:	9f 90       	pop	r9
    7bc0:	8f 90       	pop	r8
    7bc2:	7f 90       	pop	r7
    7bc4:	6f 90       	pop	r6
    7bc6:	5f 90       	pop	r5
    7bc8:	08 95       	ret
static int32_t
Inc(int8_t Dir, uint32_t Buf)
{
	uint32_t Pos = PowL10(CurrPos);
	uint8_t Dig=Buf%(Pos*10)/Pos;
	if(Dig==(Dir==1?9:0)) {
    7bca:	c9 e0       	ldi	r28, 0x09	; 9
    7bcc:	d0 e0       	ldi	r29, 0x00	; 0
    7bce:	ba cf       	rjmp	.-140    	; 0x7b44 <Inc+0x60>
    7bd0:	e1 e0       	ldi	r30, 0x01	; 1
    7bd2:	ee 2e       	mov	r14, r30
    7bd4:	f1 2c       	mov	r15, r1
    7bd6:	01 2d       	mov	r16, r1
    7bd8:	11 2d       	mov	r17, r1
    7bda:	71 e0       	ldi	r23, 0x01	; 1
    7bdc:	a7 2e       	mov	r10, r23
    7bde:	b1 2c       	mov	r11, r1
    7be0:	c1 2c       	mov	r12, r1
    7be2:	d1 2c       	mov	r13, r1
    7be4:	a9 cf       	rjmp	.-174    	; 0x7b38 <Inc+0x54>

00007be6 <MenuRight>:

// ~~~~~~~~~~~~
void
MenuRight(void)
{
}
    7be6:	08 95       	ret

00007be8 <MenuLeft>:

// ~~~~~~~~~~~~~
void
MenuLeft(void)
{
}
    7be8:	08 95       	ret

00007bea <MenuEnter>:

// ~~~~~~~~~~~~
void
MenuEnter(void)
{
}
    7bea:	08 95       	ret

00007bec <MenuEsc>:

// ~~~~~~~~~~
void
MenuEsc(void)
{
}
    7bec:	08 95       	ret

00007bee <DI_State>:
} DigInput;

// ~~~~~~~~~~~~~~~~~~
uint8_t
DI_State(uint8_t D_N)
{
    7bee:	28 2f       	mov	r18, r24
    7bf0:	86 95       	lsr	r24
    7bf2:	86 95       	lsr	r24
    7bf4:	86 95       	lsr	r24
    7bf6:	ec ef       	ldi	r30, 0xFC	; 252
    7bf8:	f6 e0       	ldi	r31, 0x06	; 6
    7bfa:	e8 0f       	add	r30, r24
    7bfc:	f1 1d       	adc	r31, r1
    7bfe:	80 81       	ld	r24, Z
    7c00:	90 e0       	ldi	r25, 0x00	; 0
    7c02:	27 70       	andi	r18, 0x07	; 7
    7c04:	02 c0       	rjmp	.+4      	; 0x7c0a <DI_State+0x1c>
    7c06:	95 95       	asr	r25
    7c08:	87 95       	ror	r24
    7c0a:	2a 95       	dec	r18
    7c0c:	e2 f7       	brpl	.-8      	; 0x7c06 <DI_State+0x18>
	return (DigInput.State[D_N/8] &(1<<D_N%8)) != 0;
}
    7c0e:	81 70       	andi	r24, 0x01	; 1
    7c10:	08 95       	ret

00007c12 <DI_Front>:

// ~~~~~~~~~~~~~~~~~~
uint8_t
DI_Front(uint8_t D_N)
{
    7c12:	e8 2f       	mov	r30, r24
	uint8_t Byte=D_N/8, Bit=1<<D_N%8;
    7c14:	28 2f       	mov	r18, r24
    7c16:	27 70       	andi	r18, 0x07	; 7
    7c18:	81 e0       	ldi	r24, 0x01	; 1
    7c1a:	90 e0       	ldi	r25, 0x00	; 0
    7c1c:	01 c0       	rjmp	.+2      	; 0x7c20 <DI_Front+0xe>
    7c1e:	88 0f       	add	r24, r24
    7c20:	2a 95       	dec	r18
    7c22:	ea f7       	brpl	.-6      	; 0x7c1e <DI_Front+0xc>
	uint8_t State = DigInput.State[Byte] &Bit;
    7c24:	e6 95       	lsr	r30
    7c26:	e6 95       	lsr	r30
    7c28:	e6 95       	lsr	r30
    7c2a:	f0 e0       	ldi	r31, 0x00	; 0
    7c2c:	e4 50       	subi	r30, 0x04	; 4
    7c2e:	f9 4f       	sbci	r31, 0xF9	; 249
    7c30:	90 81       	ld	r25, Z
    7c32:	98 23       	and	r25, r24
	return DigInput.StateOld[Byte] &Bit ? State?NoFront:FallFront : State?RiseFront:NoFront;
    7c34:	23 81       	ldd	r18, Z+3	; 0x03
    7c36:	82 23       	and	r24, r18
    7c38:	21 f0       	breq	.+8      	; 0x7c42 <DI_Front+0x30>
    7c3a:	99 23       	and	r25, r25
    7c3c:	41 f4       	brne	.+16     	; 0x7c4e <DI_Front+0x3c>
    7c3e:	82 e0       	ldi	r24, 0x02	; 2
    7c40:	08 95       	ret
    7c42:	89 2f       	mov	r24, r25
    7c44:	99 23       	and	r25, r25
    7c46:	09 f4       	brne	.+2      	; 0x7c4a <DI_Front+0x38>
}
    7c48:	08 95       	ret
uint8_t
DI_Front(uint8_t D_N)
{
	uint8_t Byte=D_N/8, Bit=1<<D_N%8;
	uint8_t State = DigInput.State[Byte] &Bit;
	return DigInput.StateOld[Byte] &Bit ? State?NoFront:FallFront : State?RiseFront:NoFront;
    7c4a:	81 e0       	ldi	r24, 0x01	; 1
}
    7c4c:	08 95       	ret
uint8_t
DI_Front(uint8_t D_N)
{
	uint8_t Byte=D_N/8, Bit=1<<D_N%8;
	uint8_t State = DigInput.State[Byte] &Bit;
	return DigInput.StateOld[Byte] &Bit ? State?NoFront:FallFront : State?RiseFront:NoFront;
    7c4e:	80 e0       	ldi	r24, 0x00	; 0
    7c50:	08 95       	ret

00007c52 <DI_Status>:
}

// ~~~~~~~~~~~~~~~~~~~
uint8_t
DI_Status(uint8_t D_N)
{
    7c52:	28 2f       	mov	r18, r24
    7c54:	86 95       	lsr	r24
    7c56:	86 95       	lsr	r24
    7c58:	86 95       	lsr	r24
    7c5a:	ec ef       	ldi	r30, 0xFC	; 252
    7c5c:	f6 e0       	ldi	r31, 0x06	; 6
    7c5e:	e8 0f       	add	r30, r24
    7c60:	f1 1d       	adc	r31, r1
    7c62:	86 81       	ldd	r24, Z+6	; 0x06
    7c64:	90 e0       	ldi	r25, 0x00	; 0
    7c66:	27 70       	andi	r18, 0x07	; 7
    7c68:	02 c0       	rjmp	.+4      	; 0x7c6e <DI_Status+0x1c>
    7c6a:	95 95       	asr	r25
    7c6c:	87 95       	ror	r24
    7c6e:	2a 95       	dec	r18
    7c70:	e2 f7       	brpl	.-8      	; 0x7c6a <DI_Status+0x18>
	return (DigInput.Status[D_N/8] &(1<<D_N%8)) != 0;
}
    7c72:	81 70       	andi	r24, 0x01	; 1
    7c74:	08 95       	ret

00007c76 <DI_Init>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

// ~~~~~~~~~~
void
DI_Init(void)
{
    7c76:	20 e0       	ldi	r18, 0x00	; 0
    7c78:	30 e0       	ldi	r19, 0x00	; 0
// ~~~~~~~~~~~~~~~
static void
DI_Init_Hard(void)
{
	for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
		cli();
    7c7a:	f8 94       	cli

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    7c7c:	a9 01       	movw	r20, r18
    7c7e:	44 0f       	add	r20, r20
    7c80:	55 1f       	adc	r21, r21
    7c82:	44 0f       	add	r20, r20
    7c84:	55 1f       	adc	r21, r21
    7c86:	44 0f       	add	r20, r20
    7c88:	55 1f       	adc	r21, r21
    7c8a:	ca 01       	movw	r24, r20
    7c8c:	8d 5b       	subi	r24, 0xBD	; 189
    7c8e:	94 4d       	sbci	r25, 0xD4	; 212
    7c90:	fc 01       	movw	r30, r24
    7c92:	a5 91       	lpm	r26, Z+
    7c94:	b4 91       	lpm	r27, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    7c96:	47 5b       	subi	r20, 0xB7	; 183
    7c98:	54 4d       	sbci	r21, 0xD4	; 212
    7c9a:	fa 01       	movw	r30, r20
    7c9c:	44 91       	lpm	r20, Z+
		*(uint8_t*)prp(&DI_M[D_N].DDR) &=~prb(&DI_M[D_N].P);
    7c9e:	94 2f       	mov	r25, r20
    7ca0:	90 95       	com	r25
    7ca2:	8c 91       	ld	r24, X
    7ca4:	89 23       	and	r24, r25
    7ca6:	8c 93       	st	X, r24

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    7ca8:	c9 01       	movw	r24, r18
    7caa:	88 0f       	add	r24, r24
    7cac:	99 1f       	adc	r25, r25
    7cae:	88 0f       	add	r24, r24
    7cb0:	99 1f       	adc	r25, r25
    7cb2:	88 0f       	add	r24, r24
    7cb4:	99 1f       	adc	r25, r25
    7cb6:	8b 5b       	subi	r24, 0xBB	; 187
    7cb8:	94 4d       	sbci	r25, 0xD4	; 212
    7cba:	fc 01       	movw	r30, r24
    7cbc:	a5 91       	lpm	r26, Z+
    7cbe:	b4 91       	lpm	r27, Z+
		*(uint8_t*)prp(&DI_M[D_N].PORT) |=prb(&DI_M[D_N].P);
    7cc0:	8c 91       	ld	r24, X
    7cc2:	84 2b       	or	r24, r20
    7cc4:	8c 93       	st	X, r24
		sei();
    7cc6:	78 94       	sei
    7cc8:	2f 5f       	subi	r18, 0xFF	; 255
    7cca:	3f 4f       	sbci	r19, 0xFF	; 255

// ~~~~~~~~~~~~~~~
static void
DI_Init_Hard(void)
{
	for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
    7ccc:	22 31       	cpi	r18, 0x12	; 18
    7cce:	31 05       	cpc	r19, r1
    7cd0:	a1 f6       	brne	.-88     	; 0x7c7a <DI_Init+0x4>
{
	DI_Init_Hard();
	#ifdef HSC_Reg
		HSC_Init();
	#endif
}
    7cd2:	08 95       	ret

00007cd4 <DO_State>:
} DigOutput;

// ~~~~~~~~~~~~~~~~~~
uint8_t
DO_State(uint8_t D_N)
{
    7cd4:	90 e0       	ldi	r25, 0x00	; 0
    7cd6:	e8 2f       	mov	r30, r24
    7cd8:	e6 95       	lsr	r30
    7cda:	e6 95       	lsr	r30
    7cdc:	e6 95       	lsr	r30
    7cde:	f0 e0       	ldi	r31, 0x00	; 0
    7ce0:	ed 56       	subi	r30, 0x6D	; 109
    7ce2:	f8 4f       	sbci	r31, 0xF8	; 248
    7ce4:	40 81       	ld	r20, Z
    7ce6:	50 e0       	ldi	r21, 0x00	; 0
    7ce8:	87 70       	andi	r24, 0x07	; 7
    7cea:	21 e0       	ldi	r18, 0x01	; 1
    7cec:	30 e0       	ldi	r19, 0x00	; 0
    7cee:	02 c0       	rjmp	.+4      	; 0x7cf4 <DO_State+0x20>
    7cf0:	22 0f       	add	r18, r18
    7cf2:	33 1f       	adc	r19, r19
    7cf4:	8a 95       	dec	r24
    7cf6:	e2 f7       	brpl	.-8      	; 0x7cf0 <DO_State+0x1c>
    7cf8:	42 23       	and	r20, r18
    7cfa:	53 23       	and	r21, r19
    7cfc:	14 16       	cp	r1, r20
    7cfe:	15 06       	cpc	r1, r21
    7d00:	0c f4       	brge	.+2      	; 0x7d04 <DO_State+0x30>
    7d02:	91 e0       	ldi	r25, 0x01	; 1
	return (DigOutput.State[D_N/8] &(1<<D_N%8)) > 0;
}
    7d04:	89 2f       	mov	r24, r25
    7d06:	08 95       	ret

00007d08 <DO_Front>:

// ~~~~~~~~~~~~~~~~~~
uint8_t
DO_Front(uint8_t D_N)
{
    7d08:	e8 2f       	mov	r30, r24
	uint8_t Byte=D_N/8, Bit=1<<D_N%8;
    7d0a:	28 2f       	mov	r18, r24
    7d0c:	27 70       	andi	r18, 0x07	; 7
    7d0e:	81 e0       	ldi	r24, 0x01	; 1
    7d10:	90 e0       	ldi	r25, 0x00	; 0
    7d12:	01 c0       	rjmp	.+2      	; 0x7d16 <DO_Front+0xe>
    7d14:	88 0f       	add	r24, r24
    7d16:	2a 95       	dec	r18
    7d18:	ea f7       	brpl	.-6      	; 0x7d14 <DO_Front+0xc>
	uint8_t State = DigOutput.State[Byte] &Bit;
    7d1a:	e6 95       	lsr	r30
    7d1c:	e6 95       	lsr	r30
    7d1e:	e6 95       	lsr	r30
    7d20:	f0 e0       	ldi	r31, 0x00	; 0
    7d22:	ed 56       	subi	r30, 0x6D	; 109
    7d24:	f8 4f       	sbci	r31, 0xF8	; 248
    7d26:	90 81       	ld	r25, Z
    7d28:	98 23       	and	r25, r24
	return DigOutput.StateOld[Byte] &Bit ? State?NoFront:FallFront : State?RiseFront:NoFront;
    7d2a:	22 81       	ldd	r18, Z+2	; 0x02
    7d2c:	82 23       	and	r24, r18
    7d2e:	21 f0       	breq	.+8      	; 0x7d38 <DO_Front+0x30>
    7d30:	99 23       	and	r25, r25
    7d32:	41 f4       	brne	.+16     	; 0x7d44 <DO_Front+0x3c>
    7d34:	82 e0       	ldi	r24, 0x02	; 2
    7d36:	08 95       	ret
    7d38:	89 2f       	mov	r24, r25
    7d3a:	99 23       	and	r25, r25
    7d3c:	09 f4       	brne	.+2      	; 0x7d40 <DO_Front+0x38>
}
    7d3e:	08 95       	ret
uint8_t
DO_Front(uint8_t D_N)
{
	uint8_t Byte=D_N/8, Bit=1<<D_N%8;
	uint8_t State = DigOutput.State[Byte] &Bit;
	return DigOutput.StateOld[Byte] &Bit ? State?NoFront:FallFront : State?RiseFront:NoFront;
    7d40:	81 e0       	ldi	r24, 0x01	; 1
}
    7d42:	08 95       	ret
uint8_t
DO_Front(uint8_t D_N)
{
	uint8_t Byte=D_N/8, Bit=1<<D_N%8;
	uint8_t State = DigOutput.State[Byte] &Bit;
	return DigOutput.StateOld[Byte] &Bit ? State?NoFront:FallFront : State?RiseFront:NoFront;
    7d44:	80 e0       	ldi	r24, 0x00	; 0
    7d46:	08 95       	ret

00007d48 <SetDigOut>:

// ~~~~~~~~~~~~~~~~~~~
void
SetDigOut(uint8_t D_N)
{
	DigOutput.Buf[D_N/8] |=(1<<D_N%8);
    7d48:	98 2f       	mov	r25, r24
    7d4a:	96 95       	lsr	r25
    7d4c:	96 95       	lsr	r25
    7d4e:	96 95       	lsr	r25
    7d50:	e3 e9       	ldi	r30, 0x93	; 147
    7d52:	f7 e0       	ldi	r31, 0x07	; 7
    7d54:	e9 0f       	add	r30, r25
    7d56:	f1 1d       	adc	r31, r1
    7d58:	87 70       	andi	r24, 0x07	; 7
    7d5a:	21 e0       	ldi	r18, 0x01	; 1
    7d5c:	30 e0       	ldi	r19, 0x00	; 0
    7d5e:	02 c0       	rjmp	.+4      	; 0x7d64 <SetDigOut+0x1c>
    7d60:	22 0f       	add	r18, r18
    7d62:	33 1f       	adc	r19, r19
    7d64:	8a 95       	dec	r24
    7d66:	e2 f7       	brpl	.-8      	; 0x7d60 <SetDigOut+0x18>
    7d68:	84 81       	ldd	r24, Z+4	; 0x04
    7d6a:	82 2b       	or	r24, r18
    7d6c:	84 83       	std	Z+4, r24	; 0x04
}
    7d6e:	08 95       	ret

00007d70 <ResDigOut>:

// ~~~~~~~~~~~~~~~~~~~
void
ResDigOut(uint8_t D_N)
{
	DigOutput.Buf[D_N/8] &=~(1<<D_N%8);
    7d70:	98 2f       	mov	r25, r24
    7d72:	96 95       	lsr	r25
    7d74:	96 95       	lsr	r25
    7d76:	96 95       	lsr	r25
    7d78:	e3 e9       	ldi	r30, 0x93	; 147
    7d7a:	f7 e0       	ldi	r31, 0x07	; 7
    7d7c:	e9 0f       	add	r30, r25
    7d7e:	f1 1d       	adc	r31, r1
    7d80:	87 70       	andi	r24, 0x07	; 7
    7d82:	21 e0       	ldi	r18, 0x01	; 1
    7d84:	30 e0       	ldi	r19, 0x00	; 0
    7d86:	02 c0       	rjmp	.+4      	; 0x7d8c <ResDigOut+0x1c>
    7d88:	22 0f       	add	r18, r18
    7d8a:	33 1f       	adc	r19, r19
    7d8c:	8a 95       	dec	r24
    7d8e:	e2 f7       	brpl	.-8      	; 0x7d88 <ResDigOut+0x18>
    7d90:	20 95       	com	r18
    7d92:	84 81       	ldd	r24, Z+4	; 0x04
    7d94:	28 23       	and	r18, r24
    7d96:	24 83       	std	Z+4, r18	; 0x04
}
    7d98:	08 95       	ret

00007d9a <TogDigOut>:

// ~~~~~~~~~~~~~~~~~~~
void
TogDigOut(uint8_t D_N)
{
	DigOutput.Buf[D_N/8] ^=(1<<D_N%8);
    7d9a:	98 2f       	mov	r25, r24
    7d9c:	96 95       	lsr	r25
    7d9e:	96 95       	lsr	r25
    7da0:	96 95       	lsr	r25
    7da2:	e3 e9       	ldi	r30, 0x93	; 147
    7da4:	f7 e0       	ldi	r31, 0x07	; 7
    7da6:	e9 0f       	add	r30, r25
    7da8:	f1 1d       	adc	r31, r1
    7daa:	87 70       	andi	r24, 0x07	; 7
    7dac:	21 e0       	ldi	r18, 0x01	; 1
    7dae:	30 e0       	ldi	r19, 0x00	; 0
    7db0:	02 c0       	rjmp	.+4      	; 0x7db6 <TogDigOut+0x1c>
    7db2:	22 0f       	add	r18, r18
    7db4:	33 1f       	adc	r19, r19
    7db6:	8a 95       	dec	r24
    7db8:	e2 f7       	brpl	.-8      	; 0x7db2 <TogDigOut+0x18>
    7dba:	84 81       	ldd	r24, Z+4	; 0x04
    7dbc:	82 27       	eor	r24, r18
    7dbe:	84 83       	std	Z+4, r24	; 0x04
}
    7dc0:	08 95       	ret

00007dc2 <SetAllDigOut>:

// ~~~~~~~~~~~~~~~
void
SetAllDigOut(void)
{
	for (uint8_t i=0; i<DO_Reg; DigOutput.Buf[i++]=0xFF);
    7dc2:	8f ef       	ldi	r24, 0xFF	; 255
    7dc4:	80 93 97 07 	sts	0x0797, r24
    7dc8:	80 93 98 07 	sts	0x0798, r24
}
    7dcc:	08 95       	ret

00007dce <DO_Enable>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    7dce:	8f b7       	in	r24, 0x3f	; 63
    7dd0:	80 78       	andi	r24, 0x80	; 128
    7dd2:	80 93 ec 02 	sts	0x02EC, r24
	cli();
    7dd6:	f8 94       	cli
void
DO_Enable(void)
{
	#ifdef Enable
		IntOff();
		PortEnable |=Enable;
    7dd8:	46 9a       	sbi	0x08, 6	; 8

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    7dda:	88 23       	and	r24, r24
    7ddc:	09 f0       	breq	.+2      	; 0x7de0 <DO_Enable+0x12>
		sei();
    7dde:	78 94       	sei
    7de0:	08 95       	ret

00007de2 <DO_Disable>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    7de2:	8f b7       	in	r24, 0x3f	; 63
    7de4:	80 78       	andi	r24, 0x80	; 128
    7de6:	80 93 ec 02 	sts	0x02EC, r24
	cli();
    7dea:	f8 94       	cli
void
DO_Disable()
{
	#ifdef Enable
		IntOff();
		PortEnable &=~Enable;
    7dec:	46 98       	cbi	0x08, 6	; 8

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    7dee:	88 23       	and	r24, r24
    7df0:	09 f0       	breq	.+2      	; 0x7df4 <DO_Disable+0x12>
		sei();
    7df2:	78 94       	sei
    7df4:	08 95       	ret

00007df6 <DigitOut>:

// ~~~~~~~~~~~
void
DigitOut(void)
{
	memcpy(DigOutput.StateOld, DigOutput.State, DO_Reg+DO_Reg_Ext);
    7df6:	90 91 93 07 	lds	r25, 0x0793
    7dfa:	80 91 94 07 	lds	r24, 0x0794
    7dfe:	80 93 96 07 	sts	0x0796, r24
    7e02:	90 93 95 07 	sts	0x0795, r25
	memcpy(DigOutput.State, DigOutput.Buf, DO_Reg);
    7e06:	90 91 97 07 	lds	r25, 0x0797
    7e0a:	80 91 98 07 	lds	r24, 0x0798
    7e0e:	80 93 94 07 	sts	0x0794, r24
    7e12:	90 93 93 07 	sts	0x0793, r25
    7e16:	20 e1       	ldi	r18, 0x10	; 16
    7e18:	35 e0       	ldi	r19, 0x05	; 5
    7e1a:	10 c0       	rjmp	.+32     	; 0x7e3c <DigitOut+0x46>
	uint8_t N = DO_Reg*8;
	while (N) {
		uint8_t D_N = prb(M+--N);
		cli();
		if (DigOutput.State[D_N/8] &(1<<D_N%8))
			PortData  |=Data;
    7e1c:	47 9a       	sbi	0x08, 7	; 8
		else
			PortData &=~Data;
		sei();
    7e1e:	78 94       	sei
    7e20:	83 2f       	mov	r24, r19
    7e22:	8a 95       	dec	r24
    7e24:	f1 f7       	brne	.-4      	; 0x7e22 <DigitOut+0x2c>
		_delay_us(1);				// 125 ns needs at 5V
		cli();
    7e26:	f8 94       	cli
		PortClock |=Clock;
    7e28:	45 9a       	sbi	0x08, 5	; 8
		sei();
    7e2a:	78 94       	sei
    7e2c:	83 2f       	mov	r24, r19
    7e2e:	8a 95       	dec	r24
    7e30:	f1 f7       	brne	.-4      	; 0x7e2e <DigitOut+0x38>
		_delay_us(1);				// 200 ns needs at 5V
		cli();
    7e32:	f8 94       	cli
		PortClock &=~Clock;
    7e34:	45 98       	cbi	0x08, 5	; 8
		sei();
    7e36:	78 94       	sei
DigitOut_Hard(void)
{
	static prog_uint8_t M[DO_Reg*8] = DO_Map;

	uint8_t N = DO_Reg*8;
	while (N) {
    7e38:	22 23       	and	r18, r18
    7e3a:	d1 f0       	breq	.+52     	; 0x7e70 <DigitOut+0x7a>
		uint8_t D_N = prb(M+--N);
    7e3c:	21 50       	subi	r18, 0x01	; 1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    7e3e:	e2 2f       	mov	r30, r18
    7e40:	f0 e0       	ldi	r31, 0x00	; 0
    7e42:	ed 5c       	subi	r30, 0xCD	; 205
    7e44:	f4 4d       	sbci	r31, 0xD4	; 212
    7e46:	e4 91       	lpm	r30, Z+
		cli();
    7e48:	f8 94       	cli
		if (DigOutput.State[D_N/8] &(1<<D_N%8))
    7e4a:	ae 2f       	mov	r26, r30
    7e4c:	a6 95       	lsr	r26
    7e4e:	a6 95       	lsr	r26
    7e50:	a6 95       	lsr	r26
    7e52:	b0 e0       	ldi	r27, 0x00	; 0
    7e54:	ad 56       	subi	r26, 0x6D	; 109
    7e56:	b8 4f       	sbci	r27, 0xF8	; 248
    7e58:	8c 91       	ld	r24, X
    7e5a:	90 e0       	ldi	r25, 0x00	; 0
    7e5c:	e7 70       	andi	r30, 0x07	; 7
    7e5e:	02 c0       	rjmp	.+4      	; 0x7e64 <DigitOut+0x6e>
    7e60:	95 95       	asr	r25
    7e62:	87 95       	ror	r24
    7e64:	ea 95       	dec	r30
    7e66:	e2 f7       	brpl	.-8      	; 0x7e60 <DigitOut+0x6a>
    7e68:	80 fd       	sbrc	r24, 0
    7e6a:	d8 cf       	rjmp	.-80     	; 0x7e1c <DigitOut+0x26>
			PortData  |=Data;
		else
			PortData &=~Data;
    7e6c:	47 98       	cbi	0x08, 7	; 8
    7e6e:	d7 cf       	rjmp	.-82     	; 0x7e1e <DigitOut+0x28>
		_delay_us(1);				// 200 ns needs at 5V
		cli();
		PortClock &=~Clock;
		sei();
	}
	cli();
    7e70:	f8 94       	cli
	PortStrobe |=Strobe;
    7e72:	80 91 05 01 	lds	r24, 0x0105
    7e76:	81 60       	ori	r24, 0x01	; 1
    7e78:	80 93 05 01 	sts	0x0105, r24
	sei();
    7e7c:	78 94       	sei
    7e7e:	85 e0       	ldi	r24, 0x05	; 5
    7e80:	8a 95       	dec	r24
    7e82:	f1 f7       	brne	.-4      	; 0x7e80 <DigitOut+0x8a>
	_delay_us(1);					// 200 ns needs at 5V
	cli();
    7e84:	f8 94       	cli
	PortStrobe &=~Strobe;
    7e86:	80 91 05 01 	lds	r24, 0x0105
    7e8a:	8e 7f       	andi	r24, 0xFE	; 254
    7e8c:	80 93 05 01 	sts	0x0105, r24
	sei();
    7e90:	78 94       	sei
				DigOutput.State[j] = (DigOutput_Ext)[i];
			(DigOutput_Ext)[i+DO_Reg_Ext] = DigOutput.Buf[j];
			IntOn();
		}
	#endif
}
    7e92:	08 95       	ret

00007e94 <DO_Init>:

// ~~~~~~~~~~~~~~~
static void
DO_Init_Hard(void)
{
	cli();
    7e94:	f8 94       	cli
	DDR_Strobe |= Strobe;
    7e96:	e4 e0       	ldi	r30, 0x04	; 4
    7e98:	f1 e0       	ldi	r31, 0x01	; 1
    7e9a:	80 81       	ld	r24, Z
    7e9c:	81 60       	ori	r24, 0x01	; 1
    7e9e:	80 83       	st	Z, r24
	DDR_Data |= Data;
    7ea0:	3f 9a       	sbi	0x07, 7	; 7
	DDR_Enable |= Enable;
    7ea2:	3e 9a       	sbi	0x07, 6	; 7
	DDR_Clock |=Clock;
    7ea4:	3d 9a       	sbi	0x07, 5	; 7
	PortStrobe &=~Strobe;
    7ea6:	e5 e0       	ldi	r30, 0x05	; 5
    7ea8:	f1 e0       	ldi	r31, 0x01	; 1
    7eaa:	80 81       	ld	r24, Z
    7eac:	8e 7f       	andi	r24, 0xFE	; 254
    7eae:	80 83       	st	Z, r24
	PortClock &=~Clock;
    7eb0:	45 98       	cbi	0x08, 5	; 8
	sei();
    7eb2:	78 94       	sei
// ~~~~~~~~~~
void
DO_Init(void)
{
	DO_Init_Hard();
	DigitOut();		// Clear all
    7eb4:	0e 94 fb 3e 	call	0x7df6	; 0x7df6 <DigitOut>
	DO_Enable();
    7eb8:	0e 94 e7 3e 	call	0x7dce	; 0x7dce <DO_Enable>
}
    7ebc:	08 95       	ret

00007ebe <AI_Init>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    7ebe:	e0 91 fe 04 	lds	r30, 0x04FE
    7ec2:	f0 e0       	ldi	r31, 0x00	; 0
    7ec4:	ee 0f       	add	r30, r30
    7ec6:	ff 1f       	adc	r31, r31
    7ec8:	ed 5d       	subi	r30, 0xDD	; 221
    7eca:	f4 4d       	sbci	r31, 0xD4	; 212
    7ecc:	85 91       	lpm	r24, Z+
    7ece:	94 91       	lpm	r25, Z+
// ~~~~~~~~~~~
static void
SetMuxAI(void)
{
	static prog_uint16_t Mux[] = AI_Mux;
	ADMUX = (uint8_t) prw(Mux+AI_N);
    7ed0:	80 93 7c 00 	sts	0x007C, r24
	#ifdef MUX5
		ADCSRB = (uint8_t) (prw(Mux+AI_N)>>8);
    7ed4:	90 93 7b 00 	sts	0x007B, r25
		#ifdef AN_C
			DDR_AN_C |=AN_C;
		#endif
	#endif
	SetMuxAI();
	ADCSRA = (((((1<<ADEN) |(1<<ADSC)) &~(1<<AD_Mode)) |(1<<ADIF)) &~(1<<ADIE)) |(1<<ADPS2) |(1<<ADPS1) |(1<<ADPS0);
    7ed8:	87 ed       	ldi	r24, 0xD7	; 215
    7eda:	80 93 7a 00 	sts	0x007A, r24
		}
	#endif
	#ifdef InitAI_10ms
		TD_InnADC = Timer8SysAlloc(AI_Reg);
	#endif
}
    7ede:	08 95       	ret

00007ee0 <AnalogIn>:

// ~~~~~~~~~~~
uint8_t
AnalogIn(void)
{
	if (ADCSRA &(1<<ADSC))
    7ee0:	80 91 7a 00 	lds	r24, 0x007A
    7ee4:	86 fd       	sbrc	r24, 6
    7ee6:	2c c0       	rjmp	.+88     	; 0x7f40 <AnalogIn+0x60>
		return AI_Reg;
	AnalogInput[AI_N] = ADCL;
    7ee8:	50 91 fe 04 	lds	r21, 0x04FE
    7eec:	65 2f       	mov	r22, r21
    7eee:	20 91 78 00 	lds	r18, 0x0078
	AnalogInput[AI_N] |= ADCH<<8;
    7ef2:	40 91 79 00 	lds	r20, 0x0079
    7ef6:	e5 2f       	mov	r30, r21
    7ef8:	f0 e0       	ldi	r31, 0x00	; 0
    7efa:	ee 0f       	add	r30, r30
    7efc:	ff 1f       	adc	r31, r31
    7efe:	ea 5f       	subi	r30, 0xFA	; 250
    7f00:	f4 4f       	sbci	r31, 0xF4	; 244
    7f02:	94 2f       	mov	r25, r20
    7f04:	80 e0       	ldi	r24, 0x00	; 0
    7f06:	30 e0       	ldi	r19, 0x00	; 0
    7f08:	82 2b       	or	r24, r18
    7f0a:	93 2b       	or	r25, r19
    7f0c:	91 83       	std	Z+1, r25	; 0x01
    7f0e:	80 83       	st	Z, r24
		}
		else
			Chan = AI_Reg;
	#endif

	if (++AI_N == AI_Reg)
    7f10:	5f 5f       	subi	r21, 0xFF	; 255
    7f12:	50 93 fe 04 	sts	0x04FE, r21
    7f16:	58 30       	cpi	r21, 0x08	; 8
    7f18:	b1 f0       	breq	.+44     	; 0x7f46 <AnalogIn+0x66>
    7f1a:	e5 2f       	mov	r30, r21
    7f1c:	f0 e0       	ldi	r31, 0x00	; 0
    7f1e:	ee 0f       	add	r30, r30
    7f20:	ff 1f       	adc	r31, r31
    7f22:	ed 5d       	subi	r30, 0xDD	; 221
    7f24:	f4 4d       	sbci	r31, 0xD4	; 212
    7f26:	85 91       	lpm	r24, Z+
    7f28:	94 91       	lpm	r25, Z+
// ~~~~~~~~~~~
static void
SetMuxAI(void)
{
	static prog_uint16_t Mux[] = AI_Mux;
	ADMUX = (uint8_t) prw(Mux+AI_N);
    7f2a:	80 93 7c 00 	sts	0x007C, r24
	#ifdef MUX5
		ADCSRB = (uint8_t) (prw(Mux+AI_N)>>8);
    7f2e:	90 93 7b 00 	sts	0x007B, r25
	#endif

	if (++AI_N == AI_Reg)
		AI_N = 0;
	SetMuxAI();
	ADCSRA |=(1<<ADSC);
    7f32:	80 91 7a 00 	lds	r24, 0x007A
    7f36:	80 64       	ori	r24, 0x40	; 64
    7f38:	80 93 7a 00 	sts	0x007A, r24
			IntOn();
		}
	#endif

	return Chan;
}
    7f3c:	86 2f       	mov	r24, r22
    7f3e:	08 95       	ret

// ~~~~~~~~~~~
uint8_t
AnalogIn(void)
{
	if (ADCSRA &(1<<ADSC))
    7f40:	68 e0       	ldi	r22, 0x08	; 8
			IntOn();
		}
	#endif

	return Chan;
}
    7f42:	86 2f       	mov	r24, r22
    7f44:	08 95       	ret
		else
			Chan = AI_Reg;
	#endif

	if (++AI_N == AI_Reg)
		AI_N = 0;
    7f46:	10 92 fe 04 	sts	0x04FE, r1
    7f4a:	50 e0       	ldi	r21, 0x00	; 0
    7f4c:	e6 cf       	rjmp	.-52     	; 0x7f1a <AnalogIn+0x3a>

00007f4e <Thermode>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
int16_t
Thermode(uint8_t T_Fami, uint8_t T_Type, uint16_t Code)
{
	if (T_Type==ThermOff)
    7f4e:	66 23       	and	r22, r22
    7f50:	f9 f0       	breq	.+62     	; 0x7f90 <Thermode+0x42>
		return Therm_Off_Mark;
	if (T_Fami==Thermis)
    7f52:	88 23       	and	r24, r24
    7f54:	91 f4       	brne	.+36     	; 0x7f7a <Thermode+0x2c>
		switch(T_Type) {
    7f56:	64 30       	cpi	r22, 0x04	; 4
    7f58:	d9 f1       	breq	.+118    	; 0x7fd0 <Thermode+0x82>
    7f5a:	65 30       	cpi	r22, 0x05	; 5
    7f5c:	60 f5       	brcc	.+88     	; 0x7fb6 <Thermode+0x68>
    7f5e:	62 30       	cpi	r22, 0x02	; 2
    7f60:	09 f4       	brne	.+2      	; 0x7f64 <Thermode+0x16>
    7f62:	4b c0       	rjmp	.+150    	; 0x7ffa <Thermode+0xac>
    7f64:	63 30       	cpi	r22, 0x03	; 3
    7f66:	d8 f5       	brcc	.+118    	; 0x7fde <Thermode+0x90>
    7f68:	61 30       	cpi	r22, 0x01	; 1
    7f6a:	a1 f4       	brne	.+40     	; 0x7f94 <Thermode+0x46>
		case TSM100:
			return ThermCalc(TSM100);
    7f6c:	8b ed       	ldi	r24, 0xDB	; 219
    7f6e:	99 e2       	ldi	r25, 0x29	; 41
    7f70:	ba 01       	movw	r22, r20
    7f72:	0e 94 5c 22 	call	0x44b8	; 0x44b8 <PGM_uBrokLine>
    7f76:	ac 01       	movw	r20, r24
    7f78:	0d c0       	rjmp	.+26     	; 0x7f94 <Thermode+0x46>
#endif
		default:
			return Code;
		}
	else	// T_Fami==Thermoc
		switch(T_Type) {
    7f7a:	61 30       	cpi	r22, 0x01	; 1
    7f7c:	69 f0       	breq	.+26     	; 0x7f98 <Thermode+0x4a>
    7f7e:	62 30       	cpi	r22, 0x02	; 2
    7f80:	49 f4       	brne	.+18     	; 0x7f94 <Thermode+0x46>
		case TC_K:
			return .1851*Code;
#endif
#if	TerInput==ADC_Input
		case TC_B:
			return ThermCalc(TC_B_);
    7f82:	8f ed       	ldi	r24, 0xDF	; 223
    7f84:	9a e2       	ldi	r25, 0x2A	; 42
    7f86:	ba 01       	movw	r22, r20
    7f88:	0e 94 5c 22 	call	0x44b8	; 0x44b8 <PGM_uBrokLine>
    7f8c:	ac 01       	movw	r20, r24
    7f8e:	02 c0       	rjmp	.+4      	; 0x7f94 <Thermode+0x46>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
int16_t
Thermode(uint8_t T_Fami, uint8_t T_Type, uint16_t Code)
{
	if (T_Type==ThermOff)
    7f90:	40 e0       	ldi	r20, 0x00	; 0
    7f92:	50 e8       	ldi	r21, 0x80	; 128
			return ThermCalc(TC_B_);
#endif
		default:
			return Code;
		}
}
    7f94:	ca 01       	movw	r24, r20
    7f96:	08 95       	ret
			return ThermCalc(TC_J_) + InnerTer;
		case TC_L:
			return ThermCalc(TC_L_) + InnerTer;
#else
		case TC_K:
			return .1851*Code;
    7f98:	ba 01       	movw	r22, r20
    7f9a:	80 e0       	ldi	r24, 0x00	; 0
    7f9c:	90 e0       	ldi	r25, 0x00	; 0
    7f9e:	0e 94 d6 7d 	call	0xfbac	; 0xfbac <__floatunsisf>
    7fa2:	2b ed       	ldi	r18, 0xDB	; 219
    7fa4:	3a e8       	ldi	r19, 0x8A	; 138
    7fa6:	4d e3       	ldi	r20, 0x3D	; 61
    7fa8:	5e e3       	ldi	r21, 0x3E	; 62
    7faa:	0e 94 13 7e 	call	0xfc26	; 0xfc26 <__mulsf3>
    7fae:	0e 94 a6 82 	call	0x1054c	; 0x1054c <__fixsfsi>
    7fb2:	ab 01       	movw	r20, r22
    7fb4:	ef cf       	rjmp	.-34     	; 0x7f94 <Thermode+0x46>
Thermode(uint8_t T_Fami, uint8_t T_Type, uint16_t Code)
{
	if (T_Type==ThermOff)
		return Therm_Off_Mark;
	if (T_Fami==Thermis)
		switch(T_Type) {
    7fb6:	66 30       	cpi	r22, 0x06	; 6
    7fb8:	39 f1       	breq	.+78     	; 0x8008 <Thermode+0xba>
    7fba:	66 30       	cpi	r22, 0x06	; 6
    7fbc:	b8 f0       	brcs	.+46     	; 0x7fec <Thermode+0x9e>
    7fbe:	67 30       	cpi	r22, 0x07	; 7
    7fc0:	49 f7       	brne	.-46     	; 0x7f94 <Thermode+0x46>
			return ThermCalc(Pt100);
#if	TerInput==ADC_Input
		case Gr21:
			return ThermCalc(Gr21);
		case Gr23:
			return ThermCalc(Gr23);
    7fc2:	8f eb       	ldi	r24, 0xBF	; 191
    7fc4:	9a e2       	ldi	r25, 0x2A	; 42
    7fc6:	ba 01       	movw	r22, r20
    7fc8:	0e 94 5c 22 	call	0x44b8	; 0x44b8 <PGM_uBrokLine>
    7fcc:	ac 01       	movw	r20, r24
    7fce:	e2 cf       	rjmp	.-60     	; 0x7f94 <Thermode+0x46>
		case TSM50:
			return ThermCalc(TSM50);
		case TSP100:
			return ThermCalc(TSP100);
		case TSP50:
			return ThermCalc(TSP50);
    7fd0:	8f e4       	ldi	r24, 0x4F	; 79
    7fd2:	9a e2       	ldi	r25, 0x2A	; 42
    7fd4:	ba 01       	movw	r22, r20
    7fd6:	0e 94 5c 22 	call	0x44b8	; 0x44b8 <PGM_uBrokLine>
    7fda:	ac 01       	movw	r20, r24
    7fdc:	db cf       	rjmp	.-74     	; 0x7f94 <Thermode+0x46>
		case TSM100:
			return ThermCalc(TSM100);
		case TSM50:
			return ThermCalc(TSM50);
		case TSP100:
			return ThermCalc(TSP100);
    7fde:	87 e2       	ldi	r24, 0x27	; 39
    7fe0:	9a e2       	ldi	r25, 0x2A	; 42
    7fe2:	ba 01       	movw	r22, r20
    7fe4:	0e 94 5c 22 	call	0x44b8	; 0x44b8 <PGM_uBrokLine>
    7fe8:	ac 01       	movw	r20, r24
    7fea:	d4 cf       	rjmp	.-88     	; 0x7f94 <Thermode+0x46>
		case TSP50:
			return ThermCalc(TSP50);
		case Pt100:
			return ThermCalc(Pt100);
    7fec:	83 e7       	ldi	r24, 0x73	; 115
    7fee:	9a e2       	ldi	r25, 0x2A	; 42
    7ff0:	ba 01       	movw	r22, r20
    7ff2:	0e 94 5c 22 	call	0x44b8	; 0x44b8 <PGM_uBrokLine>
    7ff6:	ac 01       	movw	r20, r24
    7ff8:	cd cf       	rjmp	.-102    	; 0x7f94 <Thermode+0x46>
	if (T_Fami==Thermis)
		switch(T_Type) {
		case TSM100:
			return ThermCalc(TSM100);
		case TSM50:
			return ThermCalc(TSM50);
    7ffa:	8b ef       	ldi	r24, 0xFB	; 251
    7ffc:	99 e2       	ldi	r25, 0x29	; 41
    7ffe:	ba 01       	movw	r22, r20
    8000:	0e 94 5c 22 	call	0x44b8	; 0x44b8 <PGM_uBrokLine>
    8004:	ac 01       	movw	r20, r24
    8006:	c6 cf       	rjmp	.-116    	; 0x7f94 <Thermode+0x46>
			return ThermCalc(TSP50);
		case Pt100:
			return ThermCalc(Pt100);
#if	TerInput==ADC_Input
		case Gr21:
			return ThermCalc(Gr21);
    8008:	8b e9       	ldi	r24, 0x9B	; 155
    800a:	9a e2       	ldi	r25, 0x2A	; 42
    800c:	ba 01       	movw	r22, r20
    800e:	0e 94 5c 22 	call	0x44b8	; 0x44b8 <PGM_uBrokLine>
    8012:	ac 01       	movw	r20, r24
    8014:	bf cf       	rjmp	.-130    	; 0x7f94 <Thermode+0x46>

00008016 <ThermExt>:
			IntOff();
			Temperature[TerReg+i] = (Temperature_Ext)[i];
			IntOn();
		}
	#endif
}
    8016:	08 95       	ret

00008018 <Therm_ADC_Off>:

// ~~~~~~~~~~~~~~~~
void
Therm_ADC_Off(void)
{
	for (uint8_t i=0; i<TerReg; Temperature[i++]=ADC_Off_Mark);
    8018:	81 e0       	ldi	r24, 0x01	; 1
    801a:	90 e8       	ldi	r25, 0x80	; 128
    801c:	90 93 44 06 	sts	0x0644, r25
    8020:	80 93 43 06 	sts	0x0643, r24
    8024:	90 93 46 06 	sts	0x0646, r25
    8028:	80 93 45 06 	sts	0x0645, r24
    802c:	90 93 48 06 	sts	0x0648, r25
    8030:	80 93 47 06 	sts	0x0647, r24
    8034:	90 93 4a 06 	sts	0x064A, r25
    8038:	80 93 49 06 	sts	0x0649, r24
    803c:	90 93 4c 06 	sts	0x064C, r25
    8040:	80 93 4b 06 	sts	0x064B, r24
    8044:	90 93 4e 06 	sts	0x064E, r25
    8048:	80 93 4d 06 	sts	0x064D, r24
}
    804c:	08 95       	ret

0000804e <ThermWrong>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
ThermWrong(uint8_t T_Fami, uint8_t T_Type, int16_t Ter)
{
	uint8_t TW = ThermNorm;
	if (T_Type!=ThermOff && T_Type<=prb(MaxThermType+T_Fami)) {
    804e:	66 23       	and	r22, r22
    8050:	31 f1       	breq	.+76     	; 0x809e <ThermWrong+0x50>
    8052:	28 2f       	mov	r18, r24
    8054:	30 e0       	ldi	r19, 0x00	; 0

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    8056:	f9 01       	movw	r30, r18
    8058:	eb 52       	subi	r30, 0x2B	; 43
    805a:	f6 4d       	sbci	r31, 0xD6	; 214
    805c:	e4 91       	lpm	r30, Z+
    805e:	e6 17       	cp	r30, r22
    8060:	f0 f0       	brcs	.+60     	; 0x809e <ThermWrong+0x50>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    8062:	f9 01       	movw	r30, r18
    8064:	ee 0f       	add	r30, r30
    8066:	ff 1f       	adc	r31, r31
    8068:	e9 52       	subi	r30, 0x29	; 41
    806a:	f6 4d       	sbci	r31, 0xD6	; 214
    806c:	25 91       	lpm	r18, Z+
    806e:	34 91       	lpm	r19, Z+
		TerLim *T_L = prp(TerLimType+T_Fami);
		if (Ter<(int16_t)prw(&T_L[T_Type].Low))
    8070:	86 2f       	mov	r24, r22
    8072:	90 e0       	ldi	r25, 0x00	; 0
    8074:	88 0f       	add	r24, r24
    8076:	99 1f       	adc	r25, r25
    8078:	88 0f       	add	r24, r24
    807a:	99 1f       	adc	r25, r25
    807c:	28 0f       	add	r18, r24
    807e:	39 1f       	adc	r19, r25

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    8080:	f9 01       	movw	r30, r18
    8082:	85 91       	lpm	r24, Z+
    8084:	94 91       	lpm	r25, Z+
    8086:	48 17       	cp	r20, r24
    8088:	59 07       	cpc	r21, r25
    808a:	5c f0       	brlt	.+22     	; 0x80a2 <ThermWrong+0x54>
    808c:	f9 01       	movw	r30, r18
    808e:	32 96       	adiw	r30, 0x02	; 2
    8090:	85 91       	lpm	r24, Z+
    8092:	94 91       	lpm	r25, Z+
			TW = ThermUnder;
		else if(Ter>(int16_t)prw(&T_L[T_Type].Upp))
    8094:	84 17       	cp	r24, r20
    8096:	95 07       	cpc	r25, r21
    8098:	14 f4       	brge	.+4      	; 0x809e <ThermWrong+0x50>
    809a:	82 e0       	ldi	r24, 0x02	; 2
    809c:	08 95       	ret
    809e:	80 e0       	ldi	r24, 0x00	; 0
			TW = ThermOver;
	}
	return TW;
}
    80a0:	08 95       	ret
ThermWrong(uint8_t T_Fami, uint8_t T_Type, int16_t Ter)
{
	uint8_t TW = ThermNorm;
	if (T_Type!=ThermOff && T_Type<=prb(MaxThermType+T_Fami)) {
		TerLim *T_L = prp(TerLimType+T_Fami);
		if (Ter<(int16_t)prw(&T_L[T_Type].Low))
    80a2:	81 e0       	ldi	r24, 0x01	; 1
    80a4:	08 95       	ret

000080a6 <Key_MB0_CPT_Clear>:
	{" BAUD: }}}}}bps     ", NULL, F_MB##N##_Baud}																														\
};																																																					\
MenuPage MenuModbus##N = {SetMenu(L_MB##N), 1};

#if Modbus_Qt == 1
	M_Modbus(0)
    80a6:	80 e0       	ldi	r24, 0x00	; 0
    80a8:	90 e0       	ldi	r25, 0x00	; 0

// ~~~~~~~~~~~~~~~~~~~~~~~
void
MB_CPT_Clear(uint8_t MB_N)
{
	for (uint8_t i=0; i<8; MB_CPT[MB_N][i++]=0);
    80aa:	fc 01       	movw	r30, r24
    80ac:	ee 0f       	add	r30, r30
    80ae:	ff 1f       	adc	r31, r31
    80b0:	e2 51       	subi	r30, 0x12	; 18
    80b2:	f7 4f       	sbci	r31, 0xF7	; 247
    80b4:	11 82       	std	Z+1, r1	; 0x01
    80b6:	10 82       	st	Z, r1
    80b8:	01 96       	adiw	r24, 0x01	; 1
    80ba:	88 30       	cpi	r24, 0x08	; 8
    80bc:	91 05       	cpc	r25, r1
    80be:	a9 f7       	brne	.-22     	; 0x80aa <Key_MB0_CPT_Clear+0x4>
    80c0:	81 e0       	ldi	r24, 0x01	; 1
    80c2:	08 95       	ret

000080c4 <ResetGSMState>:
	#ifdef GSM_DEBUG
		MenuPage MenuGSMConsole;
	#endif

	void ResetGSMState(void){
		GSM_State = GSM_ReStart1;
    80c4:	8a e4       	ldi	r24, 0x4A	; 74
    80c6:	80 93 b3 06 	sts	0x06B3, r24
	}
    80ca:	08 95       	ret

000080cc <Key_MaxScanCycle_Clear>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
InField F_ScanCycle[] = { {Byte, &ScanCycle} };
InField F_ScanCyclePerSec[] = { {Word, &ScanPerSec} }; 
InField F_MaxScanCycle[] = {{Byte, &MaxScanCycle}};

uint8_t Key_MaxScanCycle_Clear(void) {if(CurrLine==3) MaxScanCycle_Clear(); return StandartKey;}
    80cc:	80 91 83 07 	lds	r24, 0x0783
    80d0:	83 30       	cpi	r24, 0x03	; 3
    80d2:	11 f4       	brne	.+4      	; 0x80d8 <Key_MaxScanCycle_Clear+0xc>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
void
MaxScanCycle_Clear(void)
{
	MaxScanCycle = 0;
    80d4:	10 92 af 06 	sts	0x06AF, r1
    80d8:	80 e0       	ldi	r24, 0x00	; 0
    80da:	08 95       	ret

000080dc <ApplInit>:
void
ApplInit(void)
{
	

}
    80dc:	08 95       	ret

000080de <ApplCycle>:
// ~~~~~~~~~~~~
void
ApplCycle(void)
{

}
    80de:	08 95       	ret

000080e0 <StartKey>:
uint8_t numOfCheckBallanceRetry=0;

uint8_t Message[3];  // 
uint8_t GSMBusyState=0; // " " 0 -  , 1 -  
void GSM_StartCalling(uint8_t inputN,uint8_t abonentN){
	Message[0]=1;
    80e0:	81 e0       	ldi	r24, 0x01	; 1
    80e2:	80 93 f2 06 	sts	0x06F2, r24
	Message[1]=inputN;
    80e6:	10 92 f3 06 	sts	0x06F3, r1
	Message[2]=abonentN;
    80ea:	8c e0       	ldi	r24, 0x0C	; 12
    80ec:	80 93 f4 06 	sts	0x06F4, r24
// ~~~~~~~~~~~
void
StartKey(void)
{	
	GSM_StartCalling(0,12);
}
    80f0:	08 95       	ret

000080f2 <StopKey>:
// ~~~~~~~~~~
void
StopKey(void)
{
	
}
    80f2:	08 95       	ret

000080f4 <Menu_ConfirmationRest_Enter>:
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	//		   
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	uint8_t Menu_ConfirmationRest_Enter(){

		eeprom_write_byte((uint8_t*)E2END, 0xBB);
    80f4:	8f ef       	ldi	r24, 0xFF	; 255
    80f6:	9f e0       	ldi	r25, 0x0F	; 15
    80f8:	6b eb       	ldi	r22, 0xBB	; 187
    80fa:	0e 94 05 83 	call	0x1060a	; 0x1060a <__eewr_byte_m2560>
		eeprom_write_byte(&MemCheck_stor.ReprogFlg, 0);
    80fe:	8c e3       	ldi	r24, 0x3C	; 60
    8100:	91 e0       	ldi	r25, 0x01	; 1
    8102:	60 e0       	ldi	r22, 0x00	; 0
    8104:	0e 94 05 83 	call	0x1060a	; 0x1060a <__eewr_byte_m2560>
    8108:	ff cf       	rjmp	.-2      	; 0x8108 <Menu_ConfirmationRest_Enter+0x14>

0000810a <Menu_ConfirmationSave_Enter>:
	//		   
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	uint8_t Menu_ConfirmationSave_Enter(){

		//  backup-
		eeprom_write_byte((uint8_t*)E2END, 0xAA);
    810a:	8f ef       	ldi	r24, 0xFF	; 255
    810c:	9f e0       	ldi	r25, 0x0F	; 15
    810e:	6a ea       	ldi	r22, 0xAA	; 170
    8110:	0e 94 05 83 	call	0x1060a	; 0x1060a <__eewr_byte_m2560>
		eeprom_write_byte(&DateBackUp.Day, Tm_MDay);
    8114:	80 e0       	ldi	r24, 0x00	; 0
    8116:	90 e0       	ldi	r25, 0x00	; 0
    8118:	60 91 17 0b 	lds	r22, 0x0B17
    811c:	0e 94 05 83 	call	0x1060a	; 0x1060a <__eewr_byte_m2560>
		eeprom_write_byte(&DateBackUp.Month, Tm_Mon);
    8120:	81 e0       	ldi	r24, 0x01	; 1
    8122:	90 e0       	ldi	r25, 0x00	; 0
    8124:	60 91 85 07 	lds	r22, 0x0785
    8128:	0e 94 05 83 	call	0x1060a	; 0x1060a <__eewr_byte_m2560>
		#ifdef M41T56
			eeprom_write_byte(&DateBackUp.Year, Tm_Year);
    812c:	82 e0       	ldi	r24, 0x02	; 2
    812e:	90 e0       	ldi	r25, 0x00	; 0
    8130:	60 91 dc 05 	lds	r22, 0x05DC
    8134:	0e 94 05 83 	call	0x1060a	; 0x1060a <__eewr_byte_m2560>
		#else
			eeprom_write_byte(&DateBackUp.Year, erb(&Tm_Year));
		#endif
		eeprom_write_byte(&MemCheck_stor.ReprogFlg, 0);
    8138:	8c e3       	ldi	r24, 0x3C	; 60
    813a:	91 e0       	ldi	r25, 0x01	; 1
    813c:	60 e0       	ldi	r22, 0x00	; 0
    813e:	0e 94 05 83 	call	0x1060a	; 0x1060a <__eewr_byte_m2560>
    8142:	ff cf       	rjmp	.-2      	; 0x8142 <Menu_ConfirmationSave_Enter+0x38>

00008144 <GSM_SendData>:
	GSMTxSz = Size;
	memcpy(GSM_TxStr, Data_Out, GSMTxSz);
	GSM_SendFirstChar();
}
// ~~~~~~~~~
void GSM_SendData(uint8_t *Data_Out, uint8_t Size){
    8144:	58 2f       	mov	r21, r24
    8146:	79 2f       	mov	r23, r25
	GSMTxSz = Size;
    8148:	60 93 75 07 	sts	0x0775, r22
	memcpy(GSM_TxStr, Data_Out, GSMTxSz);
    814c:	40 91 75 07 	lds	r20, 0x0775
    8150:	22 e0       	ldi	r18, 0x02	; 2
    8152:	3a e0       	ldi	r19, 0x0A	; 10
    8154:	c9 01       	movw	r24, r18
    8156:	65 2f       	mov	r22, r21
    8158:	50 e0       	ldi	r21, 0x00	; 0
    815a:	0e 94 09 80 	call	0x10012	; 0x10012 <memcpy>
	GSM_SendFirstChar();
    815e:	0e 94 15 3a 	call	0x742a	; 0x742a <GSM_SendFirstChar>
}
    8162:	08 95       	ret

00008164 <GSM_AddHeaderSendData>:
	GSMTxSz++;
	GSM_SendFirstChar();
}
// ~~~~~~~~~
//   + CntrZ
void GSM_AddHeaderSendData(uint8_t *Data_Out, uint8_t Size){
    8164:	58 2f       	mov	r21, r24
    8166:	79 2f       	mov	r23, r25
	GSMTxSz = Size;
    8168:	60 93 75 07 	sts	0x0775, r22
	memcpy(GSM_TxStr, Data_Out, GSMTxSz);
    816c:	40 91 75 07 	lds	r20, 0x0775
    8170:	22 e0       	ldi	r18, 0x02	; 2
    8172:	3a e0       	ldi	r19, 0x0A	; 10
    8174:	c9 01       	movw	r24, r18
    8176:	65 2f       	mov	r22, r21
    8178:	50 e0       	ldi	r21, 0x00	; 0
    817a:	0e 94 09 80 	call	0x10012	; 0x10012 <memcpy>
	GSM_SendFirstChar();
    817e:	0e 94 15 3a 	call	0x742a	; 0x742a <GSM_SendFirstChar>
}
    8182:	08 95       	ret

00008184 <PresicionHanler>:
		ew##ty3((ty2*)Var, Min);						\
	else																	\
		ew##ty3((ty2*)Var, (ty2)Buf)
// ~~~~~~~~~~~~~~~~~~~~~~~
//Change BufStr due to precision for correct sscanf reading BufStr
void PresicionHanler(OutField *Field){
    8184:	cf 93       	push	r28
    8186:	df 93       	push	r29

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    8188:	ec 01       	movw	r28, r24
    818a:	2f 96       	adiw	r28, 0x0f	; 15
    818c:	fe 01       	movw	r30, r28
    818e:	84 91       	lpm	r24, Z+
	if(prb(&Field->Prec)){
    8190:	88 23       	and	r24, r24
    8192:	19 f4       	brne	.+6      	; 0x819a <PresicionHanler+0x16>
			}
			p++;
		}
	}
	
}
    8194:	df 91       	pop	r29
    8196:	cf 91       	pop	r28
    8198:	08 95       	ret
		ew##ty3((ty2*)Var, (ty2)Buf)
// ~~~~~~~~~~~~~~~~~~~~~~~
//Change BufStr due to precision for correct sscanf reading BufStr
void PresicionHanler(OutField *Field){
	if(prb(&Field->Prec)){
		char *p = strchr(BufStr,'.');	//seek for first decimal point
    819a:	81 ec       	ldi	r24, 0xC1	; 193
    819c:	95 e0       	ldi	r25, 0x05	; 5
    819e:	6e e2       	ldi	r22, 0x2E	; 46
    81a0:	70 e0       	ldi	r23, 0x00	; 0
    81a2:	0e 94 12 80 	call	0x10024	; 0x10024 <strchr>
		if(p==NULL){
    81a6:	00 97       	sbiw	r24, 0x00	; 0
    81a8:	01 f1       	breq	.+64     	; 0x81ea <PresicionHanler+0x66>
    81aa:	fe 01       	movw	r30, r28
    81ac:	24 91       	lpm	r18, Z+
			p = strchr(BufStr,' ');	//else seek for first space
		}
	  	for(uint8_t i=0; i<prb(&Field->Prec); i++){
    81ae:	22 23       	and	r18, r18
    81b0:	89 f3       	breq	.-30     	; 0x8194 <PresicionHanler+0x10>
    81b2:	fc 01       	movw	r30, r24
    81b4:	dc 01       	movw	r26, r24
    81b6:	11 96       	adiw	r26, 0x01	; 1
    81b8:	30 e0       	ldi	r19, 0x00	; 0
			if(*p == '.'){
				if(isdigit(*(p+1))){
					*p= *(p+1);
					*(p+1) = '.';
				}
				else *p='0'; 
    81ba:	60 e3       	ldi	r22, 0x30	; 48
    81bc:	52 2f       	mov	r21, r18
    81be:	07 c0       	rjmp	.+14     	; 0x81ce <PresicionHanler+0x4a>
		if(p==NULL){
			p = strchr(BufStr,' ');	//else seek for first space
		}
	  	for(uint8_t i=0; i<prb(&Field->Prec); i++){
			if(*p == ' ') *p='0'; 
			if(*p == '.'){
    81c0:	2e 32       	cpi	r18, 0x2E	; 46
    81c2:	51 f0       	breq	.+20     	; 0x81d8 <PresicionHanler+0x54>
	if(prb(&Field->Prec)){
		char *p = strchr(BufStr,'.');	//seek for first decimal point
		if(p==NULL){
			p = strchr(BufStr,' ');	//else seek for first space
		}
	  	for(uint8_t i=0; i<prb(&Field->Prec); i++){
    81c4:	3f 5f       	subi	r19, 0xFF	; 255
    81c6:	31 96       	adiw	r30, 0x01	; 1
    81c8:	11 96       	adiw	r26, 0x01	; 1
    81ca:	35 17       	cp	r19, r21
    81cc:	18 f7       	brcc	.-58     	; 0x8194 <PresicionHanler+0x10>
			if(*p == ' ') *p='0'; 
    81ce:	20 81       	ld	r18, Z
    81d0:	20 32       	cpi	r18, 0x20	; 32
    81d2:	b1 f7       	brne	.-20     	; 0x81c0 <PresicionHanler+0x3c>
			if(*p == '.'){
				if(isdigit(*(p+1))){
					*p= *(p+1);
					*(p+1) = '.';
				}
				else *p='0'; 
    81d4:	60 83       	st	Z, r22
    81d6:	f6 cf       	rjmp	.-20     	; 0x81c4 <PresicionHanler+0x40>
			p = strchr(BufStr,' ');	//else seek for first space
		}
	  	for(uint8_t i=0; i<prb(&Field->Prec); i++){
			if(*p == ' ') *p='0'; 
			if(*p == '.'){
				if(isdigit(*(p+1))){
    81d8:	4c 91       	ld	r20, X
    81da:	84 2f       	mov	r24, r20
    81dc:	90 e0       	ldi	r25, 0x00	; 0
    81de:	c0 97       	sbiw	r24, 0x30	; 48
    81e0:	0a 97       	sbiw	r24, 0x0a	; 10
    81e2:	c0 f7       	brcc	.-16     	; 0x81d4 <PresicionHanler+0x50>
					*p= *(p+1);
    81e4:	40 83       	st	Z, r20
					*(p+1) = '.';
    81e6:	2c 93       	st	X, r18
    81e8:	ed cf       	rjmp	.-38     	; 0x81c4 <PresicionHanler+0x40>
//Change BufStr due to precision for correct sscanf reading BufStr
void PresicionHanler(OutField *Field){
	if(prb(&Field->Prec)){
		char *p = strchr(BufStr,'.');	//seek for first decimal point
		if(p==NULL){
			p = strchr(BufStr,' ');	//else seek for first space
    81ea:	81 ec       	ldi	r24, 0xC1	; 193
    81ec:	95 e0       	ldi	r25, 0x05	; 5
    81ee:	60 e2       	ldi	r22, 0x20	; 32
    81f0:	70 e0       	ldi	r23, 0x00	; 0
    81f2:	0e 94 12 80 	call	0x10024	; 0x10024 <strchr>
    81f6:	d9 cf       	rjmp	.-78     	; 0x81aa <PresicionHanler+0x26>

000081f8 <GetMultiSymbol>:
	}
	return 0;
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~
//    MultiSymbol   
uint8_t GetMultiSymbol(PGM_P Str_P, char Char){
    81f8:	1f 93       	push	r17
    81fa:	18 2f       	mov	r17, r24
	PGM_P ptr_P= strchr_P(Str_P, Char);
    81fc:	70 e0       	ldi	r23, 0x00	; 0
    81fe:	0e 94 b2 7f 	call	0xff64	; 0xff64 <strchr_P>
	if(ptr_P) return (uint8_t)(ptr_P - Str_P);
    8202:	00 97       	sbiw	r24, 0x00	; 0
    8204:	19 f0       	breq	.+6      	; 0x820c <GetMultiSymbol+0x14>
    8206:	81 1b       	sub	r24, r17
	else return 0;
}
    8208:	1f 91       	pop	r17
    820a:	08 95       	ret
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~
//    MultiSymbol   
uint8_t GetMultiSymbol(PGM_P Str_P, char Char){
	PGM_P ptr_P= strchr_P(Str_P, Char);
	if(ptr_P) return (uint8_t)(ptr_P - Str_P);
    820c:	80 e0       	ldi	r24, 0x00	; 0
	else return 0;
}
    820e:	1f 91       	pop	r17
    8210:	08 95       	ret

00008212 <PutEnum>:
} T_Param;

// ~~~~~~~~~~~~~~~~~~~~
void
PutEnum(T_Param *Param)
{
    8212:	0f 93       	push	r16
    8214:	1f 93       	push	r17
    8216:	cf 93       	push	r28
    8218:	df 93       	push	r29
    821a:	8c 01       	movw	r16, r24

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    821c:	dc 01       	movw	r26, r24
    821e:	14 96       	adiw	r26, 0x04	; 4
    8220:	ed 91       	ld	r30, X+
    8222:	fc 91       	ld	r31, X
    8224:	15 97       	sbiw	r26, 0x05	; 5
    8226:	65 91       	lpm	r22, Z+
    8228:	74 91       	lpm	r23, Z+
	strcpy_P(Param->Pos, prp(Param->Txt));
    822a:	8d 91       	ld	r24, X+
    822c:	9c 91       	ld	r25, X
    822e:	0e 94 c6 7f 	call	0xff8c	; 0xff8c <strcpy_P>
	for(uint8_t i=strlen(Param->Pos); i<Param->Size; *(Param->Pos+i++)=' ');
    8232:	f8 01       	movw	r30, r16
    8234:	c0 81       	ld	r28, Z
    8236:	d1 81       	ldd	r29, Z+1	; 0x01
    8238:	fe 01       	movw	r30, r28
    823a:	01 90       	ld	r0, Z+
    823c:	00 20       	and	r0, r0
    823e:	e9 f7       	brne	.-6      	; 0x823a <PutEnum+0x28>
    8240:	31 97       	sbiw	r30, 0x01	; 1
    8242:	ec 1b       	sub	r30, r28
    8244:	d8 01       	movw	r26, r16
    8246:	13 96       	adiw	r26, 0x03	; 3
    8248:	8c 91       	ld	r24, X
    824a:	e8 17       	cp	r30, r24
    824c:	70 f4       	brcc	.+28     	; 0x826a <PutEnum+0x58>
    824e:	90 e2       	ldi	r25, 0x20	; 32
    8250:	02 c0       	rjmp	.+4      	; 0x8256 <PutEnum+0x44>
    8252:	cd 91       	ld	r28, X+
    8254:	dc 91       	ld	r29, X
    8256:	ce 0f       	add	r28, r30
    8258:	d1 1d       	adc	r29, r1
    825a:	98 83       	st	Y, r25
    825c:	ef 5f       	subi	r30, 0xFF	; 255
    825e:	d8 01       	movw	r26, r16
    8260:	13 96       	adiw	r26, 0x03	; 3
    8262:	8c 91       	ld	r24, X
    8264:	13 97       	sbiw	r26, 0x03	; 3
    8266:	e8 17       	cp	r30, r24
    8268:	a0 f3       	brcs	.-24     	; 0x8252 <PutEnum+0x40>
}
    826a:	df 91       	pop	r29
    826c:	cf 91       	pop	r28
    826e:	1f 91       	pop	r17
    8270:	0f 91       	pop	r16
    8272:	08 95       	ret

00008274 <Put_sbVal>:
}

// ~~~~~~~~~~~~~~~~~~~~~~
void
Put_sbVal(T_Param *Param)
{
    8274:	6f 92       	push	r6
    8276:	7f 92       	push	r7
    8278:	8f 92       	push	r8
    827a:	9f 92       	push	r9
    827c:	af 92       	push	r10
    827e:	bf 92       	push	r11
    8280:	cf 92       	push	r12
    8282:	df 92       	push	r13
    8284:	ef 92       	push	r14
    8286:	ff 92       	push	r15
    8288:	0f 93       	push	r16
    828a:	1f 93       	push	r17
    828c:	df 93       	push	r29
    828e:	cf 93       	push	r28
    8290:	cd b7       	in	r28, 0x3d	; 61
    8292:	de b7       	in	r29, 0x3e	; 62
    8294:	2c 97       	sbiw	r28, 0x0c	; 12
    8296:	0f b6       	in	r0, 0x3f	; 63
    8298:	f8 94       	cli
    829a:	de bf       	out	0x3e, r29	; 62
    829c:	0f be       	out	0x3f, r0	; 63
    829e:	cd bf       	out	0x3d, r28	; 61
    82a0:	5c 01       	movw	r10, r24
	char Format[] = "%0+ li.%. u";
    82a2:	be 01       	movw	r22, r28
    82a4:	6f 5f       	subi	r22, 0xFF	; 255
    82a6:	7f 4f       	sbci	r23, 0xFF	; 255
    82a8:	db 01       	movw	r26, r22
    82aa:	e0 e0       	ldi	r30, 0x00	; 0
    82ac:	f2 e0       	ldi	r31, 0x02	; 2
    82ae:	8c e0       	ldi	r24, 0x0C	; 12
    82b0:	01 90       	ld	r0, Z+
    82b2:	0d 92       	st	X+, r0
    82b4:	81 50       	subi	r24, 0x01	; 1
    82b6:	e1 f7       	brne	.-8      	; 0x82b0 <Put_sbVal+0x3c>
	Format[3] = '0'+Param->Size;
    82b8:	d5 01       	movw	r26, r10
    82ba:	13 96       	adiw	r26, 0x03	; 3
    82bc:	2c 91       	ld	r18, X
    82be:	13 97       	sbiw	r26, 0x03	; 3
    82c0:	20 5d       	subi	r18, 0xD0	; 208
    82c2:	2c 83       	std	Y+4, r18	; 0x04
	if(Param->Prec) {
    82c4:	12 96       	adiw	r26, 0x02	; 2
    82c6:	9c 91       	ld	r25, X
    82c8:	99 23       	and	r25, r25
    82ca:	09 f4       	brne	.+2      	; 0x82ce <Put_sbVal+0x5a>
    82cc:	8d c0       	rjmp	.+282    	; 0x83e8 <Put_sbVal+0x174>
		Format[3] -= Param->Prec+1;
    82ce:	89 2f       	mov	r24, r25
    82d0:	80 95       	com	r24
    82d2:	82 0f       	add	r24, r18
    82d4:	8c 83       	std	Y+4, r24	; 0x04
		Format[9] = '0'+Param->Prec;
    82d6:	90 5d       	subi	r25, 0xD0	; 208
    82d8:	9a 87       	std	Y+10, r25	; 0x0a
    82da:	90 53       	subi	r25, 0x30	; 48
		int16_t Div=Pow10(Param->Prec);
    82dc:	49 2f       	mov	r20, r25
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    82de:	21 e0       	ldi	r18, 0x01	; 1
    82e0:	30 e0       	ldi	r19, 0x00	; 0
		Pow *= 10;
    82e2:	c9 01       	movw	r24, r18
    82e4:	88 0f       	add	r24, r24
    82e6:	99 1f       	adc	r25, r25
    82e8:	22 0f       	add	r18, r18
    82ea:	33 1f       	adc	r19, r19
    82ec:	22 0f       	add	r18, r18
    82ee:	33 1f       	adc	r19, r19
    82f0:	22 0f       	add	r18, r18
    82f2:	33 1f       	adc	r19, r19
    82f4:	28 0f       	add	r18, r24
    82f6:	39 1f       	adc	r19, r25
    82f8:	41 50       	subi	r20, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    82fa:	99 f7       	brne	.-26     	; 0x82e2 <Put_sbVal+0x6e>
    82fc:	39 01       	movw	r6, r18
    82fe:	88 24       	eor	r8, r8
    8300:	77 fc       	sbrc	r7, 7
    8302:	80 94       	com	r8
    8304:	98 2c       	mov	r9, r8
		sprintf(Param->Pos, Format, sF_Buf/Div, (uint32_t)labs(sF_Buf)%Div);
    8306:	10 91 f9 04 	lds	r17, 0x04F9
    830a:	00 91 fa 04 	lds	r16, 0x04FA
    830e:	f0 90 fb 04 	lds	r15, 0x04FB
    8312:	e0 90 fc 04 	lds	r14, 0x04FC
    8316:	ed b7       	in	r30, 0x3d	; 61
    8318:	fe b7       	in	r31, 0x3e	; 62
    831a:	3c 97       	sbiw	r30, 0x0c	; 12
    831c:	0f b6       	in	r0, 0x3f	; 63
    831e:	f8 94       	cli
    8320:	fe bf       	out	0x3e, r31	; 62
    8322:	0f be       	out	0x3f, r0	; 63
    8324:	ed bf       	out	0x3d, r30	; 61
    8326:	cd b6       	in	r12, 0x3d	; 61
    8328:	de b6       	in	r13, 0x3e	; 62
    832a:	08 94       	sec
    832c:	c1 1c       	adc	r12, r1
    832e:	d1 1c       	adc	r13, r1
    8330:	d5 01       	movw	r26, r10
    8332:	8d 91       	ld	r24, X+
    8334:	9c 91       	ld	r25, X
    8336:	92 83       	std	Z+2, r25	; 0x02
    8338:	81 83       	std	Z+1, r24	; 0x01
    833a:	f6 01       	movw	r30, r12
    833c:	73 83       	std	Z+3, r23	; 0x03
    833e:	62 83       	std	Z+2, r22	; 0x02
    8340:	61 2f       	mov	r22, r17
    8342:	70 2f       	mov	r23, r16
    8344:	8f 2d       	mov	r24, r15
    8346:	9e 2d       	mov	r25, r14
    8348:	a4 01       	movw	r20, r8
    834a:	93 01       	movw	r18, r6
    834c:	0e 94 97 83 	call	0x1072e	; 0x1072e <__divmodsi4>
    8350:	d6 01       	movw	r26, r12
    8352:	14 96       	adiw	r26, 0x04	; 4
    8354:	2d 93       	st	X+, r18
    8356:	3d 93       	st	X+, r19
    8358:	4d 93       	st	X+, r20
    835a:	5c 93       	st	X, r21
    835c:	17 97       	sbiw	r26, 0x07	; 7
    835e:	21 2f       	mov	r18, r17
    8360:	30 2f       	mov	r19, r16
    8362:	4f 2d       	mov	r20, r15
    8364:	5e 2d       	mov	r21, r14
    8366:	c9 01       	movw	r24, r18
    8368:	da 01       	movw	r26, r20
    836a:	bc 01       	movw	r22, r24
    836c:	cd 01       	movw	r24, r26
    836e:	97 fd       	sbrc	r25, 7
    8370:	77 c0       	rjmp	.+238    	; 0x8460 <Put_sbVal+0x1ec>
    8372:	a4 01       	movw	r20, r8
    8374:	93 01       	movw	r18, r6
    8376:	0e 94 75 83 	call	0x106ea	; 0x106ea <__udivmodsi4>
    837a:	f6 01       	movw	r30, r12
    837c:	60 87       	std	Z+8, r22	; 0x08
    837e:	71 87       	std	Z+9, r23	; 0x09
    8380:	82 87       	std	Z+10, r24	; 0x0a
    8382:	93 87       	std	Z+11, r25	; 0x0b
    8384:	0e 94 b9 80 	call	0x10172	; 0x10172 <sprintf>
		if(sF_Buf<0) {
    8388:	8d b7       	in	r24, 0x3d	; 61
    838a:	9e b7       	in	r25, 0x3e	; 62
    838c:	0c 96       	adiw	r24, 0x0c	; 12
    838e:	0f b6       	in	r0, 0x3f	; 63
    8390:	f8 94       	cli
    8392:	9e bf       	out	0x3e, r25	; 62
    8394:	0f be       	out	0x3f, r0	; 63
    8396:	8d bf       	out	0x3d, r24	; 61
    8398:	80 91 f9 04 	lds	r24, 0x04F9
    839c:	90 91 fa 04 	lds	r25, 0x04FA
    83a0:	a0 91 fb 04 	lds	r26, 0x04FB
    83a4:	b0 91 fc 04 	lds	r27, 0x04FC
    83a8:	b7 fd       	sbrc	r27, 7
    83aa:	4a c0       	rjmp	.+148    	; 0x8440 <Put_sbVal+0x1cc>
	}
	else {
		Format[6] = '\0';
		sprintf(Param->Pos, Format, sF_Buf);
	}
	if(Minus)
    83ac:	80 91 fd 04 	lds	r24, 0x04FD
    83b0:	88 23       	and	r24, r24
    83b2:	29 f0       	breq	.+10     	; 0x83be <Put_sbVal+0x14a>
		*Param->Pos = '-';
    83b4:	d5 01       	movw	r26, r10
    83b6:	ed 91       	ld	r30, X+
    83b8:	fc 91       	ld	r31, X
    83ba:	8d e2       	ldi	r24, 0x2D	; 45
    83bc:	80 83       	st	Z, r24
}
    83be:	2c 96       	adiw	r28, 0x0c	; 12
    83c0:	0f b6       	in	r0, 0x3f	; 63
    83c2:	f8 94       	cli
    83c4:	de bf       	out	0x3e, r29	; 62
    83c6:	0f be       	out	0x3f, r0	; 63
    83c8:	cd bf       	out	0x3d, r28	; 61
    83ca:	cf 91       	pop	r28
    83cc:	df 91       	pop	r29
    83ce:	1f 91       	pop	r17
    83d0:	0f 91       	pop	r16
    83d2:	ff 90       	pop	r15
    83d4:	ef 90       	pop	r14
    83d6:	df 90       	pop	r13
    83d8:	cf 90       	pop	r12
    83da:	bf 90       	pop	r11
    83dc:	af 90       	pop	r10
    83de:	9f 90       	pop	r9
    83e0:	8f 90       	pop	r8
    83e2:	7f 90       	pop	r7
    83e4:	6f 90       	pop	r6
    83e6:	08 95       	ret
				Param->Pos++;
			*Param->Pos = '-';
		}
	}
	else {
		Format[6] = '\0';
    83e8:	1f 82       	std	Y+7, r1	; 0x07
		sprintf(Param->Pos, Format, sF_Buf);
    83ea:	ed b7       	in	r30, 0x3d	; 61
    83ec:	fe b7       	in	r31, 0x3e	; 62
    83ee:	38 97       	sbiw	r30, 0x08	; 8
    83f0:	0f b6       	in	r0, 0x3f	; 63
    83f2:	f8 94       	cli
    83f4:	fe bf       	out	0x3e, r31	; 62
    83f6:	0f be       	out	0x3f, r0	; 63
    83f8:	ed bf       	out	0x3d, r30	; 61
    83fa:	31 96       	adiw	r30, 0x01	; 1
    83fc:	d5 01       	movw	r26, r10
    83fe:	8d 91       	ld	r24, X+
    8400:	9c 91       	ld	r25, X
    8402:	ad b7       	in	r26, 0x3d	; 61
    8404:	be b7       	in	r27, 0x3e	; 62
    8406:	12 96       	adiw	r26, 0x02	; 2
    8408:	9c 93       	st	X, r25
    840a:	8e 93       	st	-X, r24
    840c:	11 97       	sbiw	r26, 0x01	; 1
    840e:	73 83       	std	Z+3, r23	; 0x03
    8410:	62 83       	std	Z+2, r22	; 0x02
    8412:	80 91 f9 04 	lds	r24, 0x04F9
    8416:	90 91 fa 04 	lds	r25, 0x04FA
    841a:	a0 91 fb 04 	lds	r26, 0x04FB
    841e:	b0 91 fc 04 	lds	r27, 0x04FC
    8422:	84 83       	std	Z+4, r24	; 0x04
    8424:	95 83       	std	Z+5, r25	; 0x05
    8426:	a6 83       	std	Z+6, r26	; 0x06
    8428:	b7 83       	std	Z+7, r27	; 0x07
    842a:	0e 94 b9 80 	call	0x10172	; 0x10172 <sprintf>
    842e:	ed b7       	in	r30, 0x3d	; 61
    8430:	fe b7       	in	r31, 0x3e	; 62
    8432:	38 96       	adiw	r30, 0x08	; 8
    8434:	0f b6       	in	r0, 0x3f	; 63
    8436:	f8 94       	cli
    8438:	fe bf       	out	0x3e, r31	; 62
    843a:	0f be       	out	0x3f, r0	; 63
    843c:	ed bf       	out	0x3d, r30	; 61
    843e:	b6 cf       	rjmp	.-148    	; 0x83ac <Put_sbVal+0x138>
		Format[3] -= Param->Prec+1;
		Format[9] = '0'+Param->Prec;
		int16_t Div=Pow10(Param->Prec);
		sprintf(Param->Pos, Format, sF_Buf/Div, (uint32_t)labs(sF_Buf)%Div);
		if(sF_Buf<0) {
			while(*Param->Pos==' ')
    8440:	d5 01       	movw	r26, r10
    8442:	ed 91       	ld	r30, X+
    8444:	fc 91       	ld	r31, X
    8446:	80 81       	ld	r24, Z
    8448:	80 32       	cpi	r24, 0x20	; 32
    844a:	39 f4       	brne	.+14     	; 0x845a <Put_sbVal+0x1e6>
				Param->Pos++;
    844c:	31 96       	adiw	r30, 0x01	; 1
    844e:	d5 01       	movw	r26, r10
    8450:	ed 93       	st	X+, r30
    8452:	fc 93       	st	X, r31
		Format[3] -= Param->Prec+1;
		Format[9] = '0'+Param->Prec;
		int16_t Div=Pow10(Param->Prec);
		sprintf(Param->Pos, Format, sF_Buf/Div, (uint32_t)labs(sF_Buf)%Div);
		if(sF_Buf<0) {
			while(*Param->Pos==' ')
    8454:	80 81       	ld	r24, Z
    8456:	80 32       	cpi	r24, 0x20	; 32
    8458:	c9 f3       	breq	.-14     	; 0x844c <Put_sbVal+0x1d8>
				Param->Pos++;
			*Param->Pos = '-';
    845a:	8d e2       	ldi	r24, 0x2D	; 45
    845c:	80 83       	st	Z, r24
    845e:	a6 cf       	rjmp	.-180    	; 0x83ac <Put_sbVal+0x138>
	Format[3] = '0'+Param->Size;
	if(Param->Prec) {
		Format[3] -= Param->Prec+1;
		Format[9] = '0'+Param->Prec;
		int16_t Div=Pow10(Param->Prec);
		sprintf(Param->Pos, Format, sF_Buf/Div, (uint32_t)labs(sF_Buf)%Div);
    8460:	90 95       	com	r25
    8462:	80 95       	com	r24
    8464:	70 95       	com	r23
    8466:	61 95       	neg	r22
    8468:	7f 4f       	sbci	r23, 0xFF	; 255
    846a:	8f 4f       	sbci	r24, 0xFF	; 255
    846c:	9f 4f       	sbci	r25, 0xFF	; 255
    846e:	81 cf       	rjmp	.-254    	; 0x8372 <Put_sbVal+0xfe>

00008470 <Put_bVal>:
}

// ~~~~~~~~~~~~~~~~~~~~~
void
Put_bVal(T_Param *Param)
{
    8470:	6f 92       	push	r6
    8472:	7f 92       	push	r7
    8474:	8f 92       	push	r8
    8476:	9f 92       	push	r9
    8478:	af 92       	push	r10
    847a:	bf 92       	push	r11
    847c:	cf 92       	push	r12
    847e:	df 92       	push	r13
    8480:	ef 92       	push	r14
    8482:	ff 92       	push	r15
    8484:	0f 93       	push	r16
    8486:	1f 93       	push	r17
    8488:	df 93       	push	r29
    848a:	cf 93       	push	r28
    848c:	cd b7       	in	r28, 0x3d	; 61
    848e:	de b7       	in	r29, 0x3e	; 62
    8490:	2b 97       	sbiw	r28, 0x0b	; 11
    8492:	0f b6       	in	r0, 0x3f	; 63
    8494:	f8 94       	cli
    8496:	de bf       	out	0x3e, r29	; 62
    8498:	0f be       	out	0x3f, r0	; 63
    849a:	cd bf       	out	0x3d, r28	; 61
    849c:	bc 01       	movw	r22, r24
	char Format[] = "%0 li.%. u";
    849e:	3e 01       	movw	r6, r28
    84a0:	08 94       	sec
    84a2:	61 1c       	adc	r6, r1
    84a4:	71 1c       	adc	r7, r1
    84a6:	d3 01       	movw	r26, r6
    84a8:	ec e0       	ldi	r30, 0x0C	; 12
    84aa:	f2 e0       	ldi	r31, 0x02	; 2
    84ac:	8b e0       	ldi	r24, 0x0B	; 11
    84ae:	01 90       	ld	r0, Z+
    84b0:	0d 92       	st	X+, r0
    84b2:	81 50       	subi	r24, 0x01	; 1
    84b4:	e1 f7       	brne	.-8      	; 0x84ae <Put_bVal+0x3e>
	Format[2] = '0'+Param->Size;
    84b6:	db 01       	movw	r26, r22
    84b8:	13 96       	adiw	r26, 0x03	; 3
    84ba:	2c 91       	ld	r18, X
    84bc:	13 97       	sbiw	r26, 0x03	; 3
    84be:	20 5d       	subi	r18, 0xD0	; 208
    84c0:	2b 83       	std	Y+3, r18	; 0x03
	if(Param->Prec) {
    84c2:	12 96       	adiw	r26, 0x02	; 2
    84c4:	9c 91       	ld	r25, X
    84c6:	99 23       	and	r25, r25
    84c8:	09 f4       	brne	.+2      	; 0x84cc <Put_bVal+0x5c>
    84ca:	6d c0       	rjmp	.+218    	; 0x85a6 <Put_bVal+0x136>
		Format[2] -= Param->Prec+1;
    84cc:	89 2f       	mov	r24, r25
    84ce:	80 95       	com	r24
    84d0:	82 0f       	add	r24, r18
    84d2:	8b 83       	std	Y+3, r24	; 0x03
		Format[8] = '0'+Param->Prec;
    84d4:	90 5d       	subi	r25, 0xD0	; 208
    84d6:	99 87       	std	Y+9, r25	; 0x09
    84d8:	90 53       	subi	r25, 0x30	; 48
		uint16_t Div=Pow10(Param->Prec);
    84da:	49 2f       	mov	r20, r25
    84dc:	21 e0       	ldi	r18, 0x01	; 1
    84de:	30 e0       	ldi	r19, 0x00	; 0
		Pow *= 10;
    84e0:	c9 01       	movw	r24, r18
    84e2:	88 0f       	add	r24, r24
    84e4:	99 1f       	adc	r25, r25
    84e6:	22 0f       	add	r18, r18
    84e8:	33 1f       	adc	r19, r19
    84ea:	22 0f       	add	r18, r18
    84ec:	33 1f       	adc	r19, r19
    84ee:	22 0f       	add	r18, r18
    84f0:	33 1f       	adc	r19, r19
    84f2:	28 0f       	add	r18, r24
    84f4:	39 1f       	adc	r19, r25
    84f6:	41 50       	subi	r20, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    84f8:	99 f7       	brne	.-26     	; 0x84e0 <Put_bVal+0x70>
    84fa:	49 01       	movw	r8, r18
    84fc:	aa 24       	eor	r10, r10
    84fe:	bb 24       	eor	r11, r11
		sprintf(Param->Pos, Format, F_Buf/Div, F_Buf%Div);
    8500:	c0 90 f5 04 	lds	r12, 0x04F5
    8504:	d0 90 f6 04 	lds	r13, 0x04F6
    8508:	e0 90 f7 04 	lds	r14, 0x04F7
    850c:	f0 90 f8 04 	lds	r15, 0x04F8
    8510:	ed b7       	in	r30, 0x3d	; 61
    8512:	fe b7       	in	r31, 0x3e	; 62
    8514:	3c 97       	sbiw	r30, 0x0c	; 12
    8516:	0f b6       	in	r0, 0x3f	; 63
    8518:	f8 94       	cli
    851a:	fe bf       	out	0x3e, r31	; 62
    851c:	0f be       	out	0x3f, r0	; 63
    851e:	ed bf       	out	0x3d, r30	; 61
    8520:	0d b7       	in	r16, 0x3d	; 61
    8522:	1e b7       	in	r17, 0x3e	; 62
    8524:	0f 5f       	subi	r16, 0xFF	; 255
    8526:	1f 4f       	sbci	r17, 0xFF	; 255
    8528:	db 01       	movw	r26, r22
    852a:	8d 91       	ld	r24, X+
    852c:	9c 91       	ld	r25, X
    852e:	92 83       	std	Z+2, r25	; 0x02
    8530:	81 83       	std	Z+1, r24	; 0x01
    8532:	f8 01       	movw	r30, r16
    8534:	73 82       	std	Z+3, r7	; 0x03
    8536:	62 82       	std	Z+2, r6	; 0x02
    8538:	c7 01       	movw	r24, r14
    853a:	b6 01       	movw	r22, r12
    853c:	a5 01       	movw	r20, r10
    853e:	94 01       	movw	r18, r8
    8540:	0e 94 75 83 	call	0x106ea	; 0x106ea <__udivmodsi4>
    8544:	d8 01       	movw	r26, r16
    8546:	14 96       	adiw	r26, 0x04	; 4
    8548:	2d 93       	st	X+, r18
    854a:	3d 93       	st	X+, r19
    854c:	4d 93       	st	X+, r20
    854e:	5c 93       	st	X, r21
    8550:	17 97       	sbiw	r26, 0x07	; 7
    8552:	c7 01       	movw	r24, r14
    8554:	b6 01       	movw	r22, r12
    8556:	a5 01       	movw	r20, r10
    8558:	94 01       	movw	r18, r8
    855a:	0e 94 75 83 	call	0x106ea	; 0x106ea <__udivmodsi4>
    855e:	f8 01       	movw	r30, r16
    8560:	60 87       	std	Z+8, r22	; 0x08
    8562:	71 87       	std	Z+9, r23	; 0x09
    8564:	82 87       	std	Z+10, r24	; 0x0a
    8566:	93 87       	std	Z+11, r25	; 0x0b
    8568:	0e 94 b9 80 	call	0x10172	; 0x10172 <sprintf>
    856c:	8d b7       	in	r24, 0x3d	; 61
    856e:	9e b7       	in	r25, 0x3e	; 62
    8570:	0c 96       	adiw	r24, 0x0c	; 12
    8572:	0f b6       	in	r0, 0x3f	; 63
    8574:	f8 94       	cli
    8576:	9e bf       	out	0x3e, r25	; 62
    8578:	0f be       	out	0x3f, r0	; 63
    857a:	8d bf       	out	0x3d, r24	; 61
	}
	else{
		Format[5] = '\0';
		sprintf(Param->Pos, Format, F_Buf);
	}
}
    857c:	2b 96       	adiw	r28, 0x0b	; 11
    857e:	0f b6       	in	r0, 0x3f	; 63
    8580:	f8 94       	cli
    8582:	de bf       	out	0x3e, r29	; 62
    8584:	0f be       	out	0x3f, r0	; 63
    8586:	cd bf       	out	0x3d, r28	; 61
    8588:	cf 91       	pop	r28
    858a:	df 91       	pop	r29
    858c:	1f 91       	pop	r17
    858e:	0f 91       	pop	r16
    8590:	ff 90       	pop	r15
    8592:	ef 90       	pop	r14
    8594:	df 90       	pop	r13
    8596:	cf 90       	pop	r12
    8598:	bf 90       	pop	r11
    859a:	af 90       	pop	r10
    859c:	9f 90       	pop	r9
    859e:	8f 90       	pop	r8
    85a0:	7f 90       	pop	r7
    85a2:	6f 90       	pop	r6
    85a4:	08 95       	ret
		Format[8] = '0'+Param->Prec;
		uint16_t Div=Pow10(Param->Prec);
		sprintf(Param->Pos, Format, F_Buf/Div, F_Buf%Div);
	}
	else{
		Format[5] = '\0';
    85a6:	1e 82       	std	Y+6, r1	; 0x06
		sprintf(Param->Pos, Format, F_Buf);
    85a8:	ad b7       	in	r26, 0x3d	; 61
    85aa:	be b7       	in	r27, 0x3e	; 62
    85ac:	18 97       	sbiw	r26, 0x08	; 8
    85ae:	0f b6       	in	r0, 0x3f	; 63
    85b0:	f8 94       	cli
    85b2:	be bf       	out	0x3e, r27	; 62
    85b4:	0f be       	out	0x3f, r0	; 63
    85b6:	ad bf       	out	0x3d, r26	; 61
    85b8:	ed b7       	in	r30, 0x3d	; 61
    85ba:	fe b7       	in	r31, 0x3e	; 62
    85bc:	31 96       	adiw	r30, 0x01	; 1
    85be:	db 01       	movw	r26, r22
    85c0:	8d 91       	ld	r24, X+
    85c2:	9c 91       	ld	r25, X
    85c4:	ad b7       	in	r26, 0x3d	; 61
    85c6:	be b7       	in	r27, 0x3e	; 62
    85c8:	12 96       	adiw	r26, 0x02	; 2
    85ca:	9c 93       	st	X, r25
    85cc:	8e 93       	st	-X, r24
    85ce:	11 97       	sbiw	r26, 0x01	; 1
    85d0:	73 82       	std	Z+3, r7	; 0x03
    85d2:	62 82       	std	Z+2, r6	; 0x02
    85d4:	80 91 f5 04 	lds	r24, 0x04F5
    85d8:	90 91 f6 04 	lds	r25, 0x04F6
    85dc:	a0 91 f7 04 	lds	r26, 0x04F7
    85e0:	b0 91 f8 04 	lds	r27, 0x04F8
    85e4:	84 83       	std	Z+4, r24	; 0x04
    85e6:	95 83       	std	Z+5, r25	; 0x05
    85e8:	a6 83       	std	Z+6, r26	; 0x06
    85ea:	b7 83       	std	Z+7, r27	; 0x07
    85ec:	0e 94 b9 80 	call	0x10172	; 0x10172 <sprintf>
    85f0:	ed b7       	in	r30, 0x3d	; 61
    85f2:	fe b7       	in	r31, 0x3e	; 62
    85f4:	38 96       	adiw	r30, 0x08	; 8
    85f6:	0f b6       	in	r0, 0x3f	; 63
    85f8:	f8 94       	cli
    85fa:	fe bf       	out	0x3e, r31	; 62
    85fc:	0f be       	out	0x3f, r0	; 63
    85fe:	ed bf       	out	0x3d, r30	; 61
    8600:	bd cf       	rjmp	.-134    	; 0x857c <Put_bVal+0x10c>

00008602 <Put_TextValAlignLeft>:
	char Format[8];
	//char Format[8] = "%10.10s";
	sprintf(Format,"%%%u.%us", Param->Size, Param->Size);
	sprintf(Param->Pos, Format, Val);
}
void Put_TextValAlignLeft(char* Val, T_Param *Param){
    8602:	cf 92       	push	r12
    8604:	df 92       	push	r13
    8606:	ef 92       	push	r14
    8608:	ff 92       	push	r15
    860a:	0f 93       	push	r16
    860c:	1f 93       	push	r17
    860e:	df 93       	push	r29
    8610:	cf 93       	push	r28
    8612:	cd b7       	in	r28, 0x3d	; 61
    8614:	de b7       	in	r29, 0x3e	; 62
    8616:	29 97       	sbiw	r28, 0x09	; 9
    8618:	0f b6       	in	r0, 0x3f	; 63
    861a:	f8 94       	cli
    861c:	de bf       	out	0x3e, r29	; 62
    861e:	0f be       	out	0x3f, r0	; 63
    8620:	cd bf       	out	0x3d, r28	; 61
    8622:	6c 01       	movw	r12, r24
    8624:	7b 01       	movw	r14, r22
	char Format[9];
	//char Format[8] = "%10.10s";
	sprintf(Format,"%%-%u.%us", Param->Size, Param->Size);
    8626:	db 01       	movw	r26, r22
    8628:	13 96       	adiw	r26, 0x03	; 3
    862a:	2c 91       	ld	r18, X
    862c:	ed b7       	in	r30, 0x3d	; 61
    862e:	fe b7       	in	r31, 0x3e	; 62
    8630:	38 97       	sbiw	r30, 0x08	; 8
    8632:	0f b6       	in	r0, 0x3f	; 63
    8634:	f8 94       	cli
    8636:	fe bf       	out	0x3e, r31	; 62
    8638:	0f be       	out	0x3f, r0	; 63
    863a:	ed bf       	out	0x3d, r30	; 61
    863c:	31 96       	adiw	r30, 0x01	; 1
    863e:	8e 01       	movw	r16, r28
    8640:	0f 5f       	subi	r16, 0xFF	; 255
    8642:	1f 4f       	sbci	r17, 0xFF	; 255
    8644:	ad b7       	in	r26, 0x3d	; 61
    8646:	be b7       	in	r27, 0x3e	; 62
    8648:	12 96       	adiw	r26, 0x02	; 2
    864a:	1c 93       	st	X, r17
    864c:	0e 93       	st	-X, r16
    864e:	11 97       	sbiw	r26, 0x01	; 1
    8650:	87 e1       	ldi	r24, 0x17	; 23
    8652:	92 e0       	ldi	r25, 0x02	; 2
    8654:	93 83       	std	Z+3, r25	; 0x03
    8656:	82 83       	std	Z+2, r24	; 0x02
    8658:	24 83       	std	Z+4, r18	; 0x04
    865a:	15 82       	std	Z+5, r1	; 0x05
    865c:	26 83       	std	Z+6, r18	; 0x06
    865e:	17 82       	std	Z+7, r1	; 0x07
    8660:	0e 94 b9 80 	call	0x10172	; 0x10172 <sprintf>
	sprintf(Param->Pos, Format, Val);
    8664:	0f 90       	pop	r0
    8666:	0f 90       	pop	r0
    8668:	ed b7       	in	r30, 0x3d	; 61
    866a:	fe b7       	in	r31, 0x3e	; 62
    866c:	31 96       	adiw	r30, 0x01	; 1
    866e:	d7 01       	movw	r26, r14
    8670:	8d 91       	ld	r24, X+
    8672:	9c 91       	ld	r25, X
    8674:	ad b7       	in	r26, 0x3d	; 61
    8676:	be b7       	in	r27, 0x3e	; 62
    8678:	12 96       	adiw	r26, 0x02	; 2
    867a:	9c 93       	st	X, r25
    867c:	8e 93       	st	-X, r24
    867e:	11 97       	sbiw	r26, 0x01	; 1
    8680:	13 83       	std	Z+3, r17	; 0x03
    8682:	02 83       	std	Z+2, r16	; 0x02
    8684:	d5 82       	std	Z+5, r13	; 0x05
    8686:	c4 82       	std	Z+4, r12	; 0x04
    8688:	0e 94 b9 80 	call	0x10172	; 0x10172 <sprintf>
    868c:	ed b7       	in	r30, 0x3d	; 61
    868e:	fe b7       	in	r31, 0x3e	; 62
    8690:	36 96       	adiw	r30, 0x06	; 6
    8692:	0f b6       	in	r0, 0x3f	; 63
    8694:	f8 94       	cli
    8696:	fe bf       	out	0x3e, r31	; 62
    8698:	0f be       	out	0x3f, r0	; 63
    869a:	ed bf       	out	0x3d, r30	; 61
}
    869c:	29 96       	adiw	r28, 0x09	; 9
    869e:	0f b6       	in	r0, 0x3f	; 63
    86a0:	f8 94       	cli
    86a2:	de bf       	out	0x3e, r29	; 62
    86a4:	0f be       	out	0x3f, r0	; 63
    86a6:	cd bf       	out	0x3d, r28	; 61
    86a8:	cf 91       	pop	r28
    86aa:	df 91       	pop	r29
    86ac:	1f 91       	pop	r17
    86ae:	0f 91       	pop	r16
    86b0:	ff 90       	pop	r15
    86b2:	ef 90       	pop	r14
    86b4:	df 90       	pop	r13
    86b6:	cf 90       	pop	r12
    86b8:	08 95       	ret

000086ba <Put_TextValAlignRight>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Put_TextVal -  
// if, for example, Filed width =12 -> sprintf(Param->Pos,"%12.12s",Val)
// min and max width = Param->Size and align right
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void Put_TextValAlignRight(char* Val, T_Param *Param){
    86ba:	cf 92       	push	r12
    86bc:	df 92       	push	r13
    86be:	ef 92       	push	r14
    86c0:	ff 92       	push	r15
    86c2:	0f 93       	push	r16
    86c4:	1f 93       	push	r17
    86c6:	df 93       	push	r29
    86c8:	cf 93       	push	r28
    86ca:	cd b7       	in	r28, 0x3d	; 61
    86cc:	de b7       	in	r29, 0x3e	; 62
    86ce:	28 97       	sbiw	r28, 0x08	; 8
    86d0:	0f b6       	in	r0, 0x3f	; 63
    86d2:	f8 94       	cli
    86d4:	de bf       	out	0x3e, r29	; 62
    86d6:	0f be       	out	0x3f, r0	; 63
    86d8:	cd bf       	out	0x3d, r28	; 61
    86da:	6c 01       	movw	r12, r24
    86dc:	7b 01       	movw	r14, r22
	char Format[8];
	//char Format[8] = "%10.10s";
	sprintf(Format,"%%%u.%us", Param->Size, Param->Size);
    86de:	db 01       	movw	r26, r22
    86e0:	13 96       	adiw	r26, 0x03	; 3
    86e2:	2c 91       	ld	r18, X
    86e4:	ed b7       	in	r30, 0x3d	; 61
    86e6:	fe b7       	in	r31, 0x3e	; 62
    86e8:	38 97       	sbiw	r30, 0x08	; 8
    86ea:	0f b6       	in	r0, 0x3f	; 63
    86ec:	f8 94       	cli
    86ee:	fe bf       	out	0x3e, r31	; 62
    86f0:	0f be       	out	0x3f, r0	; 63
    86f2:	ed bf       	out	0x3d, r30	; 61
    86f4:	31 96       	adiw	r30, 0x01	; 1
    86f6:	8e 01       	movw	r16, r28
    86f8:	0f 5f       	subi	r16, 0xFF	; 255
    86fa:	1f 4f       	sbci	r17, 0xFF	; 255
    86fc:	ad b7       	in	r26, 0x3d	; 61
    86fe:	be b7       	in	r27, 0x3e	; 62
    8700:	12 96       	adiw	r26, 0x02	; 2
    8702:	1c 93       	st	X, r17
    8704:	0e 93       	st	-X, r16
    8706:	11 97       	sbiw	r26, 0x01	; 1
    8708:	81 e2       	ldi	r24, 0x21	; 33
    870a:	92 e0       	ldi	r25, 0x02	; 2
    870c:	93 83       	std	Z+3, r25	; 0x03
    870e:	82 83       	std	Z+2, r24	; 0x02
    8710:	24 83       	std	Z+4, r18	; 0x04
    8712:	15 82       	std	Z+5, r1	; 0x05
    8714:	26 83       	std	Z+6, r18	; 0x06
    8716:	17 82       	std	Z+7, r1	; 0x07
    8718:	0e 94 b9 80 	call	0x10172	; 0x10172 <sprintf>
	sprintf(Param->Pos, Format, Val);
    871c:	0f 90       	pop	r0
    871e:	0f 90       	pop	r0
    8720:	ed b7       	in	r30, 0x3d	; 61
    8722:	fe b7       	in	r31, 0x3e	; 62
    8724:	31 96       	adiw	r30, 0x01	; 1
    8726:	d7 01       	movw	r26, r14
    8728:	8d 91       	ld	r24, X+
    872a:	9c 91       	ld	r25, X
    872c:	ad b7       	in	r26, 0x3d	; 61
    872e:	be b7       	in	r27, 0x3e	; 62
    8730:	12 96       	adiw	r26, 0x02	; 2
    8732:	9c 93       	st	X, r25
    8734:	8e 93       	st	-X, r24
    8736:	11 97       	sbiw	r26, 0x01	; 1
    8738:	13 83       	std	Z+3, r17	; 0x03
    873a:	02 83       	std	Z+2, r16	; 0x02
    873c:	d5 82       	std	Z+5, r13	; 0x05
    873e:	c4 82       	std	Z+4, r12	; 0x04
    8740:	0e 94 b9 80 	call	0x10172	; 0x10172 <sprintf>
    8744:	ed b7       	in	r30, 0x3d	; 61
    8746:	fe b7       	in	r31, 0x3e	; 62
    8748:	36 96       	adiw	r30, 0x06	; 6
    874a:	0f b6       	in	r0, 0x3f	; 63
    874c:	f8 94       	cli
    874e:	fe bf       	out	0x3e, r31	; 62
    8750:	0f be       	out	0x3f, r0	; 63
    8752:	ed bf       	out	0x3d, r30	; 61
}
    8754:	28 96       	adiw	r28, 0x08	; 8
    8756:	0f b6       	in	r0, 0x3f	; 63
    8758:	f8 94       	cli
    875a:	de bf       	out	0x3e, r29	; 62
    875c:	0f be       	out	0x3f, r0	; 63
    875e:	cd bf       	out	0x3d, r28	; 61
    8760:	cf 91       	pop	r28
    8762:	df 91       	pop	r29
    8764:	1f 91       	pop	r17
    8766:	0f 91       	pop	r16
    8768:	ff 90       	pop	r15
    876a:	ef 90       	pop	r14
    876c:	df 90       	pop	r13
    876e:	cf 90       	pop	r12
    8770:	08 95       	ret

00008772 <Put_GFVal>:
// Trailing zeros are removed from the fractional part of the result; 
// a decimal point appears only if it is followed by at least one digit.
// Max presicion - 8digits Why???
// Therefore Max Field size - 9
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void Put_GFVal(float Val, T_Param *Param){
    8772:	ef 92       	push	r14
    8774:	ff 92       	push	r15
    8776:	0f 93       	push	r16
    8778:	1f 93       	push	r17
    877a:	df 93       	push	r29
    877c:	cf 93       	push	r28
    877e:	cd b7       	in	r28, 0x3d	; 61
    8780:	de b7       	in	r29, 0x3e	; 62
    8782:	2f 97       	sbiw	r28, 0x0f	; 15
    8784:	0f b6       	in	r0, 0x3f	; 63
    8786:	f8 94       	cli
    8788:	de bf       	out	0x3e, r29	; 62
    878a:	0f be       	out	0x3f, r0	; 63
    878c:	cd bf       	out	0x3d, r28	; 61
    878e:	7b 01       	movw	r14, r22
    8790:	8c 01       	movw	r16, r24
    8792:	9a 01       	movw	r18, r20
	if(Param->Size < 10){
    8794:	da 01       	movw	r26, r20
    8796:	13 96       	adiw	r26, 0x03	; 3
    8798:	8c 91       	ld	r24, X
    879a:	8a 30       	cpi	r24, 0x0A	; 10
    879c:	08 f4       	brcc	.+2      	; 0x87a0 <Put_GFVal+0x2e>
    879e:	44 c0       	rjmp	.+136    	; 0x8828 <Put_GFVal+0xb6>
		Format[2] = '0'+Param->Size;
		Format[4] = '0'+Param->Prec;
		sprintf(Param->Pos, Format, Val);
	}
	else{
		char Format[] = "%+1 . g";
    87a0:	ae 01       	movw	r20, r28
    87a2:	48 5f       	subi	r20, 0xF8	; 248
    87a4:	5f 4f       	sbci	r21, 0xFF	; 255
    87a6:	da 01       	movw	r26, r20
    87a8:	ea e2       	ldi	r30, 0x2A	; 42
    87aa:	f2 e0       	ldi	r31, 0x02	; 2
    87ac:	88 e0       	ldi	r24, 0x08	; 8
    87ae:	01 90       	ld	r0, Z+
    87b0:	0d 92       	st	X+, r0
    87b2:	81 50       	subi	r24, 0x01	; 1
    87b4:	e1 f7       	brne	.-8      	; 0x87ae <Put_GFVal+0x3c>
		Format[3] = '0'+Param->Size-10;	
    87b6:	d9 01       	movw	r26, r18
    87b8:	13 96       	adiw	r26, 0x03	; 3
    87ba:	8c 91       	ld	r24, X
    87bc:	13 97       	sbiw	r26, 0x03	; 3
    87be:	8a 5d       	subi	r24, 0xDA	; 218
    87c0:	8b 87       	std	Y+11, r24	; 0x0b
		Format[5] = '0'+Param->Prec;
    87c2:	12 96       	adiw	r26, 0x02	; 2
    87c4:	8c 91       	ld	r24, X
    87c6:	12 97       	sbiw	r26, 0x02	; 2
    87c8:	80 5d       	subi	r24, 0xD0	; 208
    87ca:	8d 87       	std	Y+13, r24	; 0x0d
		sprintf(Param->Pos, Format, Val);
    87cc:	ed b7       	in	r30, 0x3d	; 61
    87ce:	fe b7       	in	r31, 0x3e	; 62
    87d0:	38 97       	sbiw	r30, 0x08	; 8
    87d2:	0f b6       	in	r0, 0x3f	; 63
    87d4:	f8 94       	cli
    87d6:	fe bf       	out	0x3e, r31	; 62
    87d8:	0f be       	out	0x3f, r0	; 63
    87da:	ed bf       	out	0x3d, r30	; 61
    87dc:	31 96       	adiw	r30, 0x01	; 1
    87de:	8d 91       	ld	r24, X+
    87e0:	9c 91       	ld	r25, X
    87e2:	ad b7       	in	r26, 0x3d	; 61
    87e4:	be b7       	in	r27, 0x3e	; 62
    87e6:	12 96       	adiw	r26, 0x02	; 2
    87e8:	9c 93       	st	X, r25
    87ea:	8e 93       	st	-X, r24
    87ec:	11 97       	sbiw	r26, 0x01	; 1
    87ee:	53 83       	std	Z+3, r21	; 0x03
    87f0:	42 83       	std	Z+2, r20	; 0x02
    87f2:	e4 82       	std	Z+4, r14	; 0x04
    87f4:	f5 82       	std	Z+5, r15	; 0x05
    87f6:	06 83       	std	Z+6, r16	; 0x06
    87f8:	17 83       	std	Z+7, r17	; 0x07
    87fa:	0e 94 b9 80 	call	0x10172	; 0x10172 <sprintf>
    87fe:	ed b7       	in	r30, 0x3d	; 61
    8800:	fe b7       	in	r31, 0x3e	; 62
    8802:	38 96       	adiw	r30, 0x08	; 8
    8804:	0f b6       	in	r0, 0x3f	; 63
    8806:	f8 94       	cli
    8808:	fe bf       	out	0x3e, r31	; 62
    880a:	0f be       	out	0x3f, r0	; 63
    880c:	ed bf       	out	0x3d, r30	; 61
	}
}
    880e:	2f 96       	adiw	r28, 0x0f	; 15
    8810:	0f b6       	in	r0, 0x3f	; 63
    8812:	f8 94       	cli
    8814:	de bf       	out	0x3e, r29	; 62
    8816:	0f be       	out	0x3f, r0	; 63
    8818:	cd bf       	out	0x3d, r28	; 61
    881a:	cf 91       	pop	r28
    881c:	df 91       	pop	r29
    881e:	1f 91       	pop	r17
    8820:	0f 91       	pop	r16
    8822:	ff 90       	pop	r15
    8824:	ef 90       	pop	r14
    8826:	08 95       	ret
// Max presicion - 8digits Why???
// Therefore Max Field size - 9
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void Put_GFVal(float Val, T_Param *Param){
	if(Param->Size < 10){
		char Format[] = "%+ . g";
    8828:	ae 01       	movw	r20, r28
    882a:	4f 5f       	subi	r20, 0xFF	; 255
    882c:	5f 4f       	sbci	r21, 0xFF	; 255
    882e:	da 01       	movw	r26, r20
    8830:	e2 e3       	ldi	r30, 0x32	; 50
    8832:	f2 e0       	ldi	r31, 0x02	; 2
    8834:	87 e0       	ldi	r24, 0x07	; 7
    8836:	01 90       	ld	r0, Z+
    8838:	0d 92       	st	X+, r0
    883a:	81 50       	subi	r24, 0x01	; 1
    883c:	e1 f7       	brne	.-8      	; 0x8836 <Put_GFVal+0xc4>
		Format[2] = '0'+Param->Size;
    883e:	f9 01       	movw	r30, r18
    8840:	83 81       	ldd	r24, Z+3	; 0x03
    8842:	80 5d       	subi	r24, 0xD0	; 208
    8844:	8b 83       	std	Y+3, r24	; 0x03
		Format[4] = '0'+Param->Prec;
    8846:	82 81       	ldd	r24, Z+2	; 0x02
    8848:	80 5d       	subi	r24, 0xD0	; 208
    884a:	8d 83       	std	Y+5, r24	; 0x05
		sprintf(Param->Pos, Format, Val);
    884c:	8d b7       	in	r24, 0x3d	; 61
    884e:	9e b7       	in	r25, 0x3e	; 62
    8850:	08 97       	sbiw	r24, 0x08	; 8
    8852:	0f b6       	in	r0, 0x3f	; 63
    8854:	f8 94       	cli
    8856:	9e bf       	out	0x3e, r25	; 62
    8858:	0f be       	out	0x3f, r0	; 63
    885a:	8d bf       	out	0x3d, r24	; 61
    885c:	ed b7       	in	r30, 0x3d	; 61
    885e:	fe b7       	in	r31, 0x3e	; 62
    8860:	31 96       	adiw	r30, 0x01	; 1
    8862:	d9 01       	movw	r26, r18
    8864:	bc cf       	rjmp	.-136    	; 0x87de <Put_GFVal+0x6c>

00008866 <Put_FFVal>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Put_FVal -  The double argument is rounded and converted to decimal notation in the format "[-]ddd.ddd"
// Max presicion - 8digits Why???
// Therefore Max Field size - 9
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void Put_FFVal(float Val, T_Param *Param){
    8866:	ef 92       	push	r14
    8868:	ff 92       	push	r15
    886a:	0f 93       	push	r16
    886c:	1f 93       	push	r17
    886e:	df 93       	push	r29
    8870:	cf 93       	push	r28
    8872:	cd b7       	in	r28, 0x3d	; 61
    8874:	de b7       	in	r29, 0x3e	; 62
    8876:	27 97       	sbiw	r28, 0x07	; 7
    8878:	0f b6       	in	r0, 0x3f	; 63
    887a:	f8 94       	cli
    887c:	de bf       	out	0x3e, r29	; 62
    887e:	0f be       	out	0x3f, r0	; 63
    8880:	cd bf       	out	0x3d, r28	; 61
    8882:	7b 01       	movw	r14, r22
    8884:	8c 01       	movw	r16, r24
    8886:	9a 01       	movw	r18, r20
	char Format[] = "%+ . f";
    8888:	ae 01       	movw	r20, r28
    888a:	4f 5f       	subi	r20, 0xFF	; 255
    888c:	5f 4f       	sbci	r21, 0xFF	; 255
    888e:	da 01       	movw	r26, r20
    8890:	e9 e3       	ldi	r30, 0x39	; 57
    8892:	f2 e0       	ldi	r31, 0x02	; 2
    8894:	87 e0       	ldi	r24, 0x07	; 7
    8896:	01 90       	ld	r0, Z+
    8898:	0d 92       	st	X+, r0
    889a:	81 50       	subi	r24, 0x01	; 1
    889c:	e1 f7       	brne	.-8      	; 0x8896 <Put_FFVal+0x30>
	Format[2] = '0'+Param->Size;
    889e:	d9 01       	movw	r26, r18
    88a0:	13 96       	adiw	r26, 0x03	; 3
    88a2:	8c 91       	ld	r24, X
    88a4:	13 97       	sbiw	r26, 0x03	; 3
    88a6:	80 5d       	subi	r24, 0xD0	; 208
    88a8:	8b 83       	std	Y+3, r24	; 0x03
	Format[4] = '0'+Param->Prec;	
    88aa:	12 96       	adiw	r26, 0x02	; 2
    88ac:	8c 91       	ld	r24, X
    88ae:	12 97       	sbiw	r26, 0x02	; 2
    88b0:	80 5d       	subi	r24, 0xD0	; 208
    88b2:	8d 83       	std	Y+5, r24	; 0x05
	sprintf(Param->Pos, Format, Val);
    88b4:	ed b7       	in	r30, 0x3d	; 61
    88b6:	fe b7       	in	r31, 0x3e	; 62
    88b8:	38 97       	sbiw	r30, 0x08	; 8
    88ba:	0f b6       	in	r0, 0x3f	; 63
    88bc:	f8 94       	cli
    88be:	fe bf       	out	0x3e, r31	; 62
    88c0:	0f be       	out	0x3f, r0	; 63
    88c2:	ed bf       	out	0x3d, r30	; 61
    88c4:	31 96       	adiw	r30, 0x01	; 1
    88c6:	8d 91       	ld	r24, X+
    88c8:	9c 91       	ld	r25, X
    88ca:	ad b7       	in	r26, 0x3d	; 61
    88cc:	be b7       	in	r27, 0x3e	; 62
    88ce:	12 96       	adiw	r26, 0x02	; 2
    88d0:	9c 93       	st	X, r25
    88d2:	8e 93       	st	-X, r24
    88d4:	11 97       	sbiw	r26, 0x01	; 1
    88d6:	53 83       	std	Z+3, r21	; 0x03
    88d8:	42 83       	std	Z+2, r20	; 0x02
    88da:	e4 82       	std	Z+4, r14	; 0x04
    88dc:	f5 82       	std	Z+5, r15	; 0x05
    88de:	06 83       	std	Z+6, r16	; 0x06
    88e0:	17 83       	std	Z+7, r17	; 0x07
    88e2:	0e 94 b9 80 	call	0x10172	; 0x10172 <sprintf>
    88e6:	ed b7       	in	r30, 0x3d	; 61
    88e8:	fe b7       	in	r31, 0x3e	; 62
    88ea:	38 96       	adiw	r30, 0x08	; 8
    88ec:	0f b6       	in	r0, 0x3f	; 63
    88ee:	f8 94       	cli
    88f0:	fe bf       	out	0x3e, r31	; 62
    88f2:	0f be       	out	0x3f, r0	; 63
    88f4:	ed bf       	out	0x3d, r30	; 61
}
    88f6:	27 96       	adiw	r28, 0x07	; 7
    88f8:	0f b6       	in	r0, 0x3f	; 63
    88fa:	f8 94       	cli
    88fc:	de bf       	out	0x3e, r29	; 62
    88fe:	0f be       	out	0x3f, r0	; 63
    8900:	cd bf       	out	0x3d, r28	; 61
    8902:	cf 91       	pop	r28
    8904:	df 91       	pop	r29
    8906:	1f 91       	pop	r17
    8908:	0f 91       	pop	r16
    890a:	ff 90       	pop	r15
    890c:	ef 90       	pop	r14
    890e:	08 95       	ret

00008910 <Put_zDVal>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Put_zDVal - print unsigned Longint with leading zeroes in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void 
Put_zDVal(uint32_t Val, T_Param *Param)
{
    8910:	2f 92       	push	r2
    8912:	3f 92       	push	r3
    8914:	4f 92       	push	r4
    8916:	5f 92       	push	r5
    8918:	6f 92       	push	r6
    891a:	7f 92       	push	r7
    891c:	8f 92       	push	r8
    891e:	9f 92       	push	r9
    8920:	af 92       	push	r10
    8922:	bf 92       	push	r11
    8924:	cf 92       	push	r12
    8926:	df 92       	push	r13
    8928:	ef 92       	push	r14
    892a:	ff 92       	push	r15
    892c:	0f 93       	push	r16
    892e:	1f 93       	push	r17
    8930:	df 93       	push	r29
    8932:	cf 93       	push	r28
    8934:	cd b7       	in	r28, 0x3d	; 61
    8936:	de b7       	in	r29, 0x3e	; 62
    8938:	2c 97       	sbiw	r28, 0x0c	; 12
    893a:	0f b6       	in	r0, 0x3f	; 63
    893c:	f8 94       	cli
    893e:	de bf       	out	0x3e, r29	; 62
    8940:	0f be       	out	0x3f, r0	; 63
    8942:	cd bf       	out	0x3d, r28	; 61
    8944:	1b 01       	movw	r2, r22
    8946:	2c 01       	movw	r4, r24
    8948:	3a 01       	movw	r6, r20
	uint32_t Idx = 0xFFFFFFFF-Val;
	if(Param->Txt && Idx<2) {
    894a:	da 01       	movw	r26, r20
    894c:	14 96       	adiw	r26, 0x04	; 4
    894e:	2d 91       	ld	r18, X+
    8950:	3c 91       	ld	r19, X
    8952:	15 97       	sbiw	r26, 0x05	; 5
    8954:	21 15       	cp	r18, r1
    8956:	31 05       	cpc	r19, r1
    8958:	61 f0       	breq	.+24     	; 0x8972 <Put_zDVal+0x62>
// Put_zDVal - print unsigned Longint with leading zeroes in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void 
Put_zDVal(uint32_t Val, T_Param *Param)
{
	uint32_t Idx = 0xFFFFFFFF-Val;
    895a:	dc 01       	movw	r26, r24
    895c:	cb 01       	movw	r24, r22
    895e:	80 95       	com	r24
    8960:	90 95       	com	r25
    8962:	a0 95       	com	r26
    8964:	b0 95       	com	r27
	if(Param->Txt && Idx<2) {
    8966:	82 30       	cpi	r24, 0x02	; 2
    8968:	91 05       	cpc	r25, r1
    896a:	a1 05       	cpc	r26, r1
    896c:	b1 05       	cpc	r27, r1
    896e:	08 f4       	brcc	.+2      	; 0x8972 <Put_zDVal+0x62>
    8970:	e5 c0       	rjmp	.+458    	; 0x8b3c <Put_zDVal+0x22c>
		Param->Txt += Idx;
		PutEnum(Param);
		return;
	}

	if(Param->Size==10 && Param->Prec==0){
    8972:	d3 01       	movw	r26, r6
    8974:	13 96       	adiw	r26, 0x03	; 3
    8976:	8c 91       	ld	r24, X
    8978:	13 97       	sbiw	r26, 0x03	; 3
    897a:	8a 30       	cpi	r24, 0x0A	; 10
    897c:	09 f4       	brne	.+2      	; 0x8980 <Put_zDVal+0x70>
    897e:	72 c0       	rjmp	.+228    	; 0x8a64 <Put_zDVal+0x154>
		sprintf(Param->Pos, "%010lu", Val);
		return;
	}
	char Format[] = "%0 lu.%. lu";
    8980:	de 01       	movw	r26, r28
    8982:	11 96       	adiw	r26, 0x01	; 1
    8984:	e7 e4       	ldi	r30, 0x47	; 71
    8986:	f2 e0       	ldi	r31, 0x02	; 2
    8988:	8c e0       	ldi	r24, 0x0C	; 12
    898a:	01 90       	ld	r0, Z+
    898c:	0d 92       	st	X+, r0
    898e:	81 50       	subi	r24, 0x01	; 1
    8990:	e1 f7       	brne	.-8      	; 0x898a <Put_zDVal+0x7a>
	Format[2] = '0'+Param->Size;
    8992:	d3 01       	movw	r26, r6
    8994:	13 96       	adiw	r26, 0x03	; 3
    8996:	2c 91       	ld	r18, X
    8998:	13 97       	sbiw	r26, 0x03	; 3
    899a:	20 5d       	subi	r18, 0xD0	; 208
    899c:	2b 83       	std	Y+3, r18	; 0x03
	if(Param->Prec) {
    899e:	12 96       	adiw	r26, 0x02	; 2
    89a0:	9c 91       	ld	r25, X
    89a2:	99 23       	and	r25, r25
    89a4:	09 f4       	brne	.+2      	; 0x89a8 <Put_zDVal+0x98>
    89a6:	a0 c0       	rjmp	.+320    	; 0x8ae8 <Put_zDVal+0x1d8>
		Format[2] -= Param->Prec+1;
    89a8:	89 2f       	mov	r24, r25
    89aa:	80 95       	com	r24
    89ac:	82 0f       	add	r24, r18
    89ae:	8b 83       	std	Y+3, r24	; 0x03
		Format[8] = '0'+Param->Prec;
    89b0:	90 5d       	subi	r25, 0xD0	; 208
    89b2:	99 87       	std	Y+9, r25	; 0x09
    89b4:	90 53       	subi	r25, 0x30	; 48
		uint32_t Div=PowL10(Param->Prec);
    89b6:	09 2f       	mov	r16, r25
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
	uint32_t Pow = 1;
	while(Exp--)
    89b8:	61 e0       	ldi	r22, 0x01	; 1
    89ba:	86 2e       	mov	r8, r22
    89bc:	91 2c       	mov	r9, r1
    89be:	a1 2c       	mov	r10, r1
    89c0:	b1 2c       	mov	r11, r1
		Pow *= 10;
    89c2:	c5 01       	movw	r24, r10
    89c4:	b4 01       	movw	r22, r8
    89c6:	2a e0       	ldi	r18, 0x0A	; 10
    89c8:	30 e0       	ldi	r19, 0x00	; 0
    89ca:	40 e0       	ldi	r20, 0x00	; 0
    89cc:	50 e0       	ldi	r21, 0x00	; 0
    89ce:	0e 94 23 83 	call	0x10646	; 0x10646 <__mulsi3>
    89d2:	4b 01       	movw	r8, r22
    89d4:	5c 01       	movw	r10, r24
    89d6:	01 50       	subi	r16, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
	uint32_t Pow = 1;
	while(Exp--)
    89d8:	a1 f7       	brne	.-24     	; 0x89c2 <Put_zDVal+0xb2>
    89da:	c2 01       	movw	r24, r4
    89dc:	b1 01       	movw	r22, r2
    89de:	94 01       	movw	r18, r8
    89e0:	a5 01       	movw	r20, r10
    89e2:	0e 94 75 83 	call	0x106ea	; 0x106ea <__udivmodsi4>
    89e6:	f6 2e       	mov	r15, r22
    89e8:	e7 2e       	mov	r14, r23
    89ea:	d8 2e       	mov	r13, r24
    89ec:	c9 2e       	mov	r12, r25
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
    89ee:	ed b7       	in	r30, 0x3d	; 61
    89f0:	fe b7       	in	r31, 0x3e	; 62
    89f2:	3c 97       	sbiw	r30, 0x0c	; 12
    89f4:	0f b6       	in	r0, 0x3f	; 63
    89f6:	f8 94       	cli
    89f8:	fe bf       	out	0x3e, r31	; 62
    89fa:	0f be       	out	0x3f, r0	; 63
    89fc:	ed bf       	out	0x3d, r30	; 61
    89fe:	0d b7       	in	r16, 0x3d	; 61
    8a00:	1e b7       	in	r17, 0x3e	; 62
    8a02:	0f 5f       	subi	r16, 0xFF	; 255
    8a04:	1f 4f       	sbci	r17, 0xFF	; 255
    8a06:	d3 01       	movw	r26, r6
    8a08:	8d 91       	ld	r24, X+
    8a0a:	9c 91       	ld	r25, X
    8a0c:	92 83       	std	Z+2, r25	; 0x02
    8a0e:	81 83       	std	Z+1, r24	; 0x01
    8a10:	81 e0       	ldi	r24, 0x01	; 1
    8a12:	90 e0       	ldi	r25, 0x00	; 0
    8a14:	8c 0f       	add	r24, r28
    8a16:	9d 1f       	adc	r25, r29
    8a18:	f8 01       	movw	r30, r16
    8a1a:	93 83       	std	Z+3, r25	; 0x03
    8a1c:	82 83       	std	Z+2, r24	; 0x02
    8a1e:	c2 01       	movw	r24, r4
    8a20:	b1 01       	movw	r22, r2
    8a22:	a5 01       	movw	r20, r10
    8a24:	94 01       	movw	r18, r8
    8a26:	0e 94 75 83 	call	0x106ea	; 0x106ea <__udivmodsi4>
    8a2a:	d8 01       	movw	r26, r16
    8a2c:	14 96       	adiw	r26, 0x04	; 4
    8a2e:	2d 93       	st	X+, r18
    8a30:	3d 93       	st	X+, r19
    8a32:	4d 93       	st	X+, r20
    8a34:	5c 93       	st	X, r21
    8a36:	17 97       	sbiw	r26, 0x07	; 7
    8a38:	18 96       	adiw	r26, 0x08	; 8
    8a3a:	fc 92       	st	X, r15
    8a3c:	18 97       	sbiw	r26, 0x08	; 8
    8a3e:	19 96       	adiw	r26, 0x09	; 9
    8a40:	ec 92       	st	X, r14
    8a42:	19 97       	sbiw	r26, 0x09	; 9
    8a44:	1a 96       	adiw	r26, 0x0a	; 10
    8a46:	dc 92       	st	X, r13
    8a48:	1a 97       	sbiw	r26, 0x0a	; 10
    8a4a:	1b 96       	adiw	r26, 0x0b	; 11
    8a4c:	cc 92       	st	X, r12
    8a4e:	0e 94 b9 80 	call	0x10172	; 0x10172 <sprintf>
    8a52:	ed b7       	in	r30, 0x3d	; 61
    8a54:	fe b7       	in	r31, 0x3e	; 62
    8a56:	3c 96       	adiw	r30, 0x0c	; 12
    8a58:	0f b6       	in	r0, 0x3f	; 63
    8a5a:	f8 94       	cli
    8a5c:	fe bf       	out	0x3e, r31	; 62
    8a5e:	0f be       	out	0x3f, r0	; 63
    8a60:	ed bf       	out	0x3d, r30	; 61
    8a62:	29 c0       	rjmp	.+82     	; 0x8ab6 <Put_zDVal+0x1a6>
		Param->Txt += Idx;
		PutEnum(Param);
		return;
	}

	if(Param->Size==10 && Param->Prec==0){
    8a64:	12 96       	adiw	r26, 0x02	; 2
    8a66:	8c 91       	ld	r24, X
    8a68:	12 97       	sbiw	r26, 0x02	; 2
    8a6a:	88 23       	and	r24, r24
    8a6c:	09 f0       	breq	.+2      	; 0x8a70 <Put_zDVal+0x160>
    8a6e:	88 cf       	rjmp	.-240    	; 0x8980 <Put_zDVal+0x70>
		sprintf(Param->Pos, "%010lu", Val);
    8a70:	ed b7       	in	r30, 0x3d	; 61
    8a72:	fe b7       	in	r31, 0x3e	; 62
    8a74:	38 97       	sbiw	r30, 0x08	; 8
    8a76:	0f b6       	in	r0, 0x3f	; 63
    8a78:	f8 94       	cli
    8a7a:	fe bf       	out	0x3e, r31	; 62
    8a7c:	0f be       	out	0x3f, r0	; 63
    8a7e:	ed bf       	out	0x3d, r30	; 61
    8a80:	31 96       	adiw	r30, 0x01	; 1
    8a82:	8d 91       	ld	r24, X+
    8a84:	9c 91       	ld	r25, X
    8a86:	ad b7       	in	r26, 0x3d	; 61
    8a88:	be b7       	in	r27, 0x3e	; 62
    8a8a:	12 96       	adiw	r26, 0x02	; 2
    8a8c:	9c 93       	st	X, r25
    8a8e:	8e 93       	st	-X, r24
    8a90:	11 97       	sbiw	r26, 0x01	; 1
    8a92:	80 e4       	ldi	r24, 0x40	; 64
    8a94:	92 e0       	ldi	r25, 0x02	; 2
    8a96:	93 83       	std	Z+3, r25	; 0x03
    8a98:	82 83       	std	Z+2, r24	; 0x02
    8a9a:	24 82       	std	Z+4, r2	; 0x04
    8a9c:	35 82       	std	Z+5, r3	; 0x05
    8a9e:	46 82       	std	Z+6, r4	; 0x06
    8aa0:	57 82       	std	Z+7, r5	; 0x07
    8aa2:	0e 94 b9 80 	call	0x10172	; 0x10172 <sprintf>
    8aa6:	ed b7       	in	r30, 0x3d	; 61
    8aa8:	fe b7       	in	r31, 0x3e	; 62
    8aaa:	38 96       	adiw	r30, 0x08	; 8
    8aac:	0f b6       	in	r0, 0x3f	; 63
    8aae:	f8 94       	cli
    8ab0:	fe bf       	out	0x3e, r31	; 62
    8ab2:	0f be       	out	0x3f, r0	; 63
    8ab4:	ed bf       	out	0x3d, r30	; 61
	}
	else {
		Format[5] = '\0';
		sprintf(Param->Pos, Format, Val);
	}
}
    8ab6:	2c 96       	adiw	r28, 0x0c	; 12
    8ab8:	0f b6       	in	r0, 0x3f	; 63
    8aba:	f8 94       	cli
    8abc:	de bf       	out	0x3e, r29	; 62
    8abe:	0f be       	out	0x3f, r0	; 63
    8ac0:	cd bf       	out	0x3d, r28	; 61
    8ac2:	cf 91       	pop	r28
    8ac4:	df 91       	pop	r29
    8ac6:	1f 91       	pop	r17
    8ac8:	0f 91       	pop	r16
    8aca:	ff 90       	pop	r15
    8acc:	ef 90       	pop	r14
    8ace:	df 90       	pop	r13
    8ad0:	cf 90       	pop	r12
    8ad2:	bf 90       	pop	r11
    8ad4:	af 90       	pop	r10
    8ad6:	9f 90       	pop	r9
    8ad8:	8f 90       	pop	r8
    8ada:	7f 90       	pop	r7
    8adc:	6f 90       	pop	r6
    8ade:	5f 90       	pop	r5
    8ae0:	4f 90       	pop	r4
    8ae2:	3f 90       	pop	r3
    8ae4:	2f 90       	pop	r2
    8ae6:	08 95       	ret
		Format[8] = '0'+Param->Prec;
		uint32_t Div=PowL10(Param->Prec);
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
	}
	else {
		Format[5] = '\0';
    8ae8:	1e 82       	std	Y+6, r1	; 0x06
		sprintf(Param->Pos, Format, Val);
    8aea:	8d b7       	in	r24, 0x3d	; 61
    8aec:	9e b7       	in	r25, 0x3e	; 62
    8aee:	08 97       	sbiw	r24, 0x08	; 8
    8af0:	0f b6       	in	r0, 0x3f	; 63
    8af2:	f8 94       	cli
    8af4:	9e bf       	out	0x3e, r25	; 62
    8af6:	0f be       	out	0x3f, r0	; 63
    8af8:	8d bf       	out	0x3d, r24	; 61
    8afa:	ed b7       	in	r30, 0x3d	; 61
    8afc:	fe b7       	in	r31, 0x3e	; 62
    8afe:	31 96       	adiw	r30, 0x01	; 1
    8b00:	d3 01       	movw	r26, r6
    8b02:	8d 91       	ld	r24, X+
    8b04:	9c 91       	ld	r25, X
    8b06:	ad b7       	in	r26, 0x3d	; 61
    8b08:	be b7       	in	r27, 0x3e	; 62
    8b0a:	12 96       	adiw	r26, 0x02	; 2
    8b0c:	9c 93       	st	X, r25
    8b0e:	8e 93       	st	-X, r24
    8b10:	11 97       	sbiw	r26, 0x01	; 1
    8b12:	81 e0       	ldi	r24, 0x01	; 1
    8b14:	90 e0       	ldi	r25, 0x00	; 0
    8b16:	8c 0f       	add	r24, r28
    8b18:	9d 1f       	adc	r25, r29
    8b1a:	93 83       	std	Z+3, r25	; 0x03
    8b1c:	82 83       	std	Z+2, r24	; 0x02
    8b1e:	24 82       	std	Z+4, r2	; 0x04
    8b20:	35 82       	std	Z+5, r3	; 0x05
    8b22:	46 82       	std	Z+6, r4	; 0x06
    8b24:	57 82       	std	Z+7, r5	; 0x07
    8b26:	0e 94 b9 80 	call	0x10172	; 0x10172 <sprintf>
    8b2a:	ad b7       	in	r26, 0x3d	; 61
    8b2c:	be b7       	in	r27, 0x3e	; 62
    8b2e:	18 96       	adiw	r26, 0x08	; 8
    8b30:	0f b6       	in	r0, 0x3f	; 63
    8b32:	f8 94       	cli
    8b34:	be bf       	out	0x3e, r27	; 62
    8b36:	0f be       	out	0x3f, r0	; 63
    8b38:	ad bf       	out	0x3d, r26	; 61
    8b3a:	bd cf       	rjmp	.-134    	; 0x8ab6 <Put_zDVal+0x1a6>
void 
Put_zDVal(uint32_t Val, T_Param *Param)
{
	uint32_t Idx = 0xFFFFFFFF-Val;
	if(Param->Txt && Idx<2) {
		Param->Txt += Idx;
    8b3c:	88 0f       	add	r24, r24
    8b3e:	99 1f       	adc	r25, r25
    8b40:	28 0f       	add	r18, r24
    8b42:	39 1f       	adc	r19, r25
    8b44:	fa 01       	movw	r30, r20
    8b46:	35 83       	std	Z+5, r19	; 0x05
    8b48:	24 83       	std	Z+4, r18	; 0x04
		PutEnum(Param);
    8b4a:	ca 01       	movw	r24, r20
    8b4c:	0e 94 09 41 	call	0x8212	; 0x8212 <PutEnum>
    8b50:	b2 cf       	rjmp	.-156    	; 0x8ab6 <Put_zDVal+0x1a6>

00008b52 <Put_sDVal>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Put_sDVal - print signed Longint in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_sDVal(int32_t Val, T_Param *Param)
{
    8b52:	cf 92       	push	r12
    8b54:	df 92       	push	r13
    8b56:	ef 92       	push	r14
    8b58:	ff 92       	push	r15
    8b5a:	0f 93       	push	r16
    8b5c:	1f 93       	push	r17
    8b5e:	df 93       	push	r29
    8b60:	cf 93       	push	r28
    8b62:	cd b7       	in	r28, 0x3d	; 61
    8b64:	de b7       	in	r29, 0x3e	; 62
    8b66:	2d 97       	sbiw	r28, 0x0d	; 13
    8b68:	0f b6       	in	r0, 0x3f	; 63
    8b6a:	f8 94       	cli
    8b6c:	de bf       	out	0x3e, r29	; 62
    8b6e:	0f be       	out	0x3f, r0	; 63
    8b70:	cd bf       	out	0x3d, r28	; 61
    8b72:	6b 01       	movw	r12, r22
    8b74:	7c 01       	movw	r14, r24
    8b76:	8a 01       	movw	r16, r20
	uint32_t Idx = 0x80000000+Val;
	if(Param->Txt && Idx<2) {
    8b78:	da 01       	movw	r26, r20
    8b7a:	14 96       	adiw	r26, 0x04	; 4
    8b7c:	2d 91       	ld	r18, X+
    8b7e:	3c 91       	ld	r19, X
    8b80:	15 97       	sbiw	r26, 0x05	; 5
    8b82:	21 15       	cp	r18, r1
    8b84:	31 05       	cpc	r19, r1
    8b86:	61 f0       	breq	.+24     	; 0x8ba0 <Put_sDVal+0x4e>
// Put_sDVal - print signed Longint in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_sDVal(int32_t Val, T_Param *Param)
{
	uint32_t Idx = 0x80000000+Val;
    8b88:	dc 01       	movw	r26, r24
    8b8a:	cb 01       	movw	r24, r22
    8b8c:	80 50       	subi	r24, 0x00	; 0
    8b8e:	90 40       	sbci	r25, 0x00	; 0
    8b90:	a0 40       	sbci	r26, 0x00	; 0
    8b92:	b0 48       	sbci	r27, 0x80	; 128
	if(Param->Txt && Idx<2) {
    8b94:	82 30       	cpi	r24, 0x02	; 2
    8b96:	91 05       	cpc	r25, r1
    8b98:	a1 05       	cpc	r26, r1
    8b9a:	b1 05       	cpc	r27, r1
    8b9c:	08 f4       	brcc	.+2      	; 0x8ba0 <Put_sDVal+0x4e>
    8b9e:	f7 c0       	rjmp	.+494    	; 0x8d8e <Put_sDVal+0x23c>
		Param->Txt += Idx;
		PutEnum(Param);
		return;
	}
	// standart specificator to print Longint in string
	if(Param->Size>9){
    8ba0:	d8 01       	movw	r26, r16
    8ba2:	13 96       	adiw	r26, 0x03	; 3
    8ba4:	8c 91       	ld	r24, X
    8ba6:	8a 30       	cpi	r24, 0x0A	; 10
    8ba8:	f8 f0       	brcs	.+62     	; 0x8be8 <Put_sDVal+0x96>
		char Format[] = "%+1 ld";
    8baa:	9e 01       	movw	r18, r28
    8bac:	29 5f       	subi	r18, 0xF9	; 249
    8bae:	3f 4f       	sbci	r19, 0xFF	; 255
    8bb0:	d9 01       	movw	r26, r18
    8bb2:	e3 e5       	ldi	r30, 0x53	; 83
    8bb4:	f2 e0       	ldi	r31, 0x02	; 2
    8bb6:	87 e0       	ldi	r24, 0x07	; 7
    8bb8:	01 90       	ld	r0, Z+
    8bba:	0d 92       	st	X+, r0
    8bbc:	81 50       	subi	r24, 0x01	; 1
    8bbe:	e1 f7       	brne	.-8      	; 0x8bb8 <Put_sDVal+0x66>
		Format[3] = '0'+Param->Size%10;
    8bc0:	f8 01       	movw	r30, r16
    8bc2:	83 81       	ldd	r24, Z+3	; 0x03
    8bc4:	6a e0       	ldi	r22, 0x0A	; 10
    8bc6:	0e 94 42 83 	call	0x10684	; 0x10684 <__udivmodqi4>
    8bca:	90 5d       	subi	r25, 0xD0	; 208
    8bcc:	9a 87       	std	Y+10, r25	; 0x0a
		sprintf(Param->Pos, Format, Val);
    8bce:	8d b7       	in	r24, 0x3d	; 61
    8bd0:	9e b7       	in	r25, 0x3e	; 62
    8bd2:	08 97       	sbiw	r24, 0x08	; 8
    8bd4:	0f b6       	in	r0, 0x3f	; 63
    8bd6:	f8 94       	cli
    8bd8:	9e bf       	out	0x3e, r25	; 62
    8bda:	0f be       	out	0x3f, r0	; 63
    8bdc:	8d bf       	out	0x3d, r24	; 61
    8bde:	ed b7       	in	r30, 0x3d	; 61
    8be0:	fe b7       	in	r31, 0x3e	; 62
    8be2:	31 96       	adiw	r30, 0x01	; 1
    8be4:	d8 01       	movw	r26, r16
    8be6:	1a c0       	rjmp	.+52     	; 0x8c1c <Put_sDVal+0xca>
	}
	else{
		char Format[] = "%+ ld";
    8be8:	9e 01       	movw	r18, r28
    8bea:	2f 5f       	subi	r18, 0xFF	; 255
    8bec:	3f 4f       	sbci	r19, 0xFF	; 255
    8bee:	d9 01       	movw	r26, r18
    8bf0:	ea e5       	ldi	r30, 0x5A	; 90
    8bf2:	f2 e0       	ldi	r31, 0x02	; 2
    8bf4:	86 e0       	ldi	r24, 0x06	; 6
    8bf6:	01 90       	ld	r0, Z+
    8bf8:	0d 92       	st	X+, r0
    8bfa:	81 50       	subi	r24, 0x01	; 1
    8bfc:	e1 f7       	brne	.-8      	; 0x8bf6 <Put_sDVal+0xa4>
		Format[2] = '0'+Param->Size;
    8bfe:	d8 01       	movw	r26, r16
    8c00:	13 96       	adiw	r26, 0x03	; 3
    8c02:	8c 91       	ld	r24, X
    8c04:	13 97       	sbiw	r26, 0x03	; 3
    8c06:	80 5d       	subi	r24, 0xD0	; 208
    8c08:	8b 83       	std	Y+3, r24	; 0x03
		sprintf(Param->Pos, Format, Val);
    8c0a:	ed b7       	in	r30, 0x3d	; 61
    8c0c:	fe b7       	in	r31, 0x3e	; 62
    8c0e:	38 97       	sbiw	r30, 0x08	; 8
    8c10:	0f b6       	in	r0, 0x3f	; 63
    8c12:	f8 94       	cli
    8c14:	fe bf       	out	0x3e, r31	; 62
    8c16:	0f be       	out	0x3f, r0	; 63
    8c18:	ed bf       	out	0x3d, r30	; 61
    8c1a:	31 96       	adiw	r30, 0x01	; 1
    8c1c:	8d 91       	ld	r24, X+
    8c1e:	9c 91       	ld	r25, X
    8c20:	ad b7       	in	r26, 0x3d	; 61
    8c22:	be b7       	in	r27, 0x3e	; 62
    8c24:	12 96       	adiw	r26, 0x02	; 2
    8c26:	9c 93       	st	X, r25
    8c28:	8e 93       	st	-X, r24
    8c2a:	11 97       	sbiw	r26, 0x01	; 1
    8c2c:	33 83       	std	Z+3, r19	; 0x03
    8c2e:	22 83       	std	Z+2, r18	; 0x02
    8c30:	c4 82       	std	Z+4, r12	; 0x04
    8c32:	d5 82       	std	Z+5, r13	; 0x05
    8c34:	e6 82       	std	Z+6, r14	; 0x06
    8c36:	f7 82       	std	Z+7, r15	; 0x07
    8c38:	0e 94 b9 80 	call	0x10172	; 0x10172 <sprintf>
    8c3c:	ed b7       	in	r30, 0x3d	; 61
    8c3e:	fe b7       	in	r31, 0x3e	; 62
    8c40:	38 96       	adiw	r30, 0x08	; 8
    8c42:	0f b6       	in	r0, 0x3f	; 63
    8c44:	f8 94       	cli
    8c46:	fe bf       	out	0x3e, r31	; 62
    8c48:	0f be       	out	0x3f, r0	; 63
    8c4a:	ed bf       	out	0x3d, r30	; 61
	}
	//Delete sign if zero
	if(!Val)Param->Pos[Param->Size-2] = ' ';
    8c4c:	c1 14       	cp	r12, r1
    8c4e:	d1 04       	cpc	r13, r1
    8c50:	e1 04       	cpc	r14, r1
    8c52:	f1 04       	cpc	r15, r1
    8c54:	59 f4       	brne	.+22     	; 0x8c6c <Put_sDVal+0x11a>
    8c56:	d8 01       	movw	r26, r16
    8c58:	13 96       	adiw	r26, 0x03	; 3
    8c5a:	8c 91       	ld	r24, X
    8c5c:	13 97       	sbiw	r26, 0x03	; 3
    8c5e:	ed 91       	ld	r30, X+
    8c60:	fc 91       	ld	r31, X
    8c62:	e8 0f       	add	r30, r24
    8c64:	f1 1d       	adc	r31, r1
    8c66:	32 97       	sbiw	r30, 0x02	; 2
    8c68:	80 e2       	ldi	r24, 0x20	; 32
    8c6a:	80 83       	st	Z, r24

	if(Param->Prec){
    8c6c:	f8 01       	movw	r30, r16
    8c6e:	92 81       	ldd	r25, Z+2	; 0x02
    8c70:	99 23       	and	r25, r25
    8c72:	09 f4       	brne	.+2      	; 0x8c76 <Put_sDVal+0x124>
    8c74:	41 c0       	rjmp	.+130    	; 0x8cf8 <Put_sDVal+0x1a6>
		//Insert decimal point
		for(uint8_t i=0; i< Param->Size - Param->Prec; i++){
    8c76:	83 81       	ldd	r24, Z+3	; 0x03
    8c78:	28 2f       	mov	r18, r24
    8c7a:	30 e0       	ldi	r19, 0x00	; 0
    8c7c:	29 1b       	sub	r18, r25
    8c7e:	31 09       	sbc	r19, r1
    8c80:	12 16       	cp	r1, r18
    8c82:	13 06       	cpc	r1, r19
    8c84:	d4 f4       	brge	.+52     	; 0x8cba <Put_sDVal+0x168>
    8c86:	40 e0       	ldi	r20, 0x00	; 0
    8c88:	80 e0       	ldi	r24, 0x00	; 0
    8c8a:	90 e0       	ldi	r25, 0x00	; 0
			Param->Pos[i] = Param->Pos[i+1];
    8c8c:	d8 01       	movw	r26, r16
    8c8e:	ed 91       	ld	r30, X+
    8c90:	fc 91       	ld	r31, X
    8c92:	11 97       	sbiw	r26, 0x01	; 1
    8c94:	e8 0f       	add	r30, r24
    8c96:	f9 1f       	adc	r31, r25
    8c98:	81 81       	ldd	r24, Z+1	; 0x01
    8c9a:	80 83       	st	Z, r24
	//Delete sign if zero
	if(!Val)Param->Pos[Param->Size-2] = ' ';

	if(Param->Prec){
		//Insert decimal point
		for(uint8_t i=0; i< Param->Size - Param->Prec; i++){
    8c9c:	4f 5f       	subi	r20, 0xFF	; 255
    8c9e:	13 96       	adiw	r26, 0x03	; 3
    8ca0:	8c 91       	ld	r24, X
    8ca2:	13 97       	sbiw	r26, 0x03	; 3
    8ca4:	28 2f       	mov	r18, r24
    8ca6:	30 e0       	ldi	r19, 0x00	; 0
    8ca8:	12 96       	adiw	r26, 0x02	; 2
    8caa:	8c 91       	ld	r24, X
    8cac:	28 1b       	sub	r18, r24
    8cae:	31 09       	sbc	r19, r1
    8cb0:	84 2f       	mov	r24, r20
    8cb2:	90 e0       	ldi	r25, 0x00	; 0
    8cb4:	82 17       	cp	r24, r18
    8cb6:	93 07       	cpc	r25, r19
    8cb8:	4c f3       	brlt	.-46     	; 0x8c8c <Put_sDVal+0x13a>
			Param->Pos[i] = Param->Pos[i+1];
		}
		Param->Pos[Param->Size - Param->Prec-1] = '.';
    8cba:	d8 01       	movw	r26, r16
    8cbc:	ed 91       	ld	r30, X+
    8cbe:	fc 91       	ld	r31, X
    8cc0:	11 97       	sbiw	r26, 0x01	; 1
    8cc2:	e2 0f       	add	r30, r18
    8cc4:	f3 1f       	adc	r31, r19
    8cc6:	31 97       	sbiw	r30, 0x01	; 1
    8cc8:	8e e2       	ldi	r24, 0x2E	; 46
    8cca:	80 83       	st	Z, r24
		//Fill zeros and shift sign for correct view
		char c = Param->Pos[Param->Size - Param->Prec-2];
    8ccc:	4d 91       	ld	r20, X+
    8cce:	5c 91       	ld	r21, X
    8cd0:	11 97       	sbiw	r26, 0x01	; 1
    8cd2:	13 96       	adiw	r26, 0x03	; 3
    8cd4:	9c 91       	ld	r25, X
    8cd6:	13 97       	sbiw	r26, 0x03	; 3
    8cd8:	e9 2f       	mov	r30, r25
    8cda:	f0 e0       	ldi	r31, 0x00	; 0
    8cdc:	12 96       	adiw	r26, 0x02	; 2
    8cde:	8c 91       	ld	r24, X
    8ce0:	e8 1b       	sub	r30, r24
    8ce2:	f1 09       	sbc	r31, r1
    8ce4:	e4 0f       	add	r30, r20
    8ce6:	f5 1f       	adc	r31, r21
    8ce8:	32 97       	sbiw	r30, 0x02	; 2
    8cea:	e0 81       	ld	r30, Z
		if(c ==' ' || c =='+' || c =='-'){
    8cec:	e0 32       	cpi	r30, 0x20	; 32
    8cee:	99 f0       	breq	.+38     	; 0x8d16 <Put_sDVal+0x1c4>
    8cf0:	eb 32       	cpi	r30, 0x2B	; 43
    8cf2:	89 f0       	breq	.+34     	; 0x8d16 <Put_sDVal+0x1c4>
    8cf4:	ed 32       	cpi	r30, 0x2D	; 45
    8cf6:	79 f0       	breq	.+30     	; 0x8d16 <Put_sDVal+0x1c4>
				}
			}
		}
	}

}
    8cf8:	2d 96       	adiw	r28, 0x0d	; 13
    8cfa:	0f b6       	in	r0, 0x3f	; 63
    8cfc:	f8 94       	cli
    8cfe:	de bf       	out	0x3e, r29	; 62
    8d00:	0f be       	out	0x3f, r0	; 63
    8d02:	cd bf       	out	0x3d, r28	; 61
    8d04:	cf 91       	pop	r28
    8d06:	df 91       	pop	r29
    8d08:	1f 91       	pop	r17
    8d0a:	0f 91       	pop	r16
    8d0c:	ff 90       	pop	r15
    8d0e:	ef 90       	pop	r14
    8d10:	df 90       	pop	r13
    8d12:	cf 90       	pop	r12
    8d14:	08 95       	ret
		}
		Param->Pos[Param->Size - Param->Prec-1] = '.';
		//Fill zeros and shift sign for correct view
		char c = Param->Pos[Param->Size - Param->Prec-2];
		if(c ==' ' || c =='+' || c =='-'){
			for(uint8_t i=Param->Size-1; i>1; i--){
    8d16:	e9 2f       	mov	r30, r25
    8d18:	e1 50       	subi	r30, 0x01	; 1
    8d1a:	e2 30       	cpi	r30, 0x02	; 2
    8d1c:	68 f3       	brcs	.-38     	; 0x8cf8 <Put_sDVal+0x1a6>
				if(Param->Pos[i] == ' '|| Param->Pos[i] == '+' || Param->Pos[i] == '-' ) Param->Pos[i]='0';
    8d1e:	90 e3       	ldi	r25, 0x30	; 48
    8d20:	09 c0       	rjmp	.+18     	; 0x8d34 <Put_sDVal+0x1e2>
    8d22:	8b 32       	cpi	r24, 0x2B	; 43
    8d24:	79 f0       	breq	.+30     	; 0x8d44 <Put_sDVal+0x1f2>
    8d26:	8d 32       	cpi	r24, 0x2D	; 45
    8d28:	69 f0       	breq	.+26     	; 0x8d44 <Put_sDVal+0x1f2>
				if(Param->Pos[i] == '.'){
    8d2a:	8e 32       	cpi	r24, 0x2E	; 46
    8d2c:	a9 f0       	breq	.+42     	; 0x8d58 <Put_sDVal+0x206>
		}
		Param->Pos[Param->Size - Param->Prec-1] = '.';
		//Fill zeros and shift sign for correct view
		char c = Param->Pos[Param->Size - Param->Prec-2];
		if(c ==' ' || c =='+' || c =='-'){
			for(uint8_t i=Param->Size-1; i>1; i--){
    8d2e:	e1 50       	subi	r30, 0x01	; 1
    8d30:	e2 30       	cpi	r30, 0x02	; 2
    8d32:	10 f3       	brcs	.-60     	; 0x8cf8 <Put_sDVal+0x1a6>
				if(Param->Pos[i] == ' '|| Param->Pos[i] == '+' || Param->Pos[i] == '-' ) Param->Pos[i]='0';
    8d34:	2e 2f       	mov	r18, r30
    8d36:	30 e0       	ldi	r19, 0x00	; 0
    8d38:	da 01       	movw	r26, r20
    8d3a:	a2 0f       	add	r26, r18
    8d3c:	b3 1f       	adc	r27, r19
    8d3e:	8c 91       	ld	r24, X
    8d40:	80 32       	cpi	r24, 0x20	; 32
    8d42:	79 f7       	brne	.-34     	; 0x8d22 <Put_sDVal+0x1d0>
    8d44:	9c 93       	st	X, r25
    8d46:	d8 01       	movw	r26, r16
    8d48:	4d 91       	ld	r20, X+
    8d4a:	5c 91       	ld	r21, X
    8d4c:	da 01       	movw	r26, r20
    8d4e:	a2 0f       	add	r26, r18
    8d50:	b3 1f       	adc	r27, r19
    8d52:	8c 91       	ld	r24, X
				if(Param->Pos[i] == '.'){
    8d54:	8e 32       	cpi	r24, 0x2E	; 46
    8d56:	59 f7       	brne	.-42     	; 0x8d2e <Put_sDVal+0x1dc>
					Param->Pos[i-1]='0';
    8d58:	11 97       	sbiw	r26, 0x01	; 1
    8d5a:	80 e3       	ldi	r24, 0x30	; 48
    8d5c:	8c 93       	st	X, r24
					if(Val>0)Param->Pos[i-2]='+';
    8d5e:	1c 14       	cp	r1, r12
    8d60:	1d 04       	cpc	r1, r13
    8d62:	1e 04       	cpc	r1, r14
    8d64:	1f 04       	cpc	r1, r15
    8d66:	44 f4       	brge	.+16     	; 0x8d78 <Put_sDVal+0x226>
    8d68:	d8 01       	movw	r26, r16
    8d6a:	ed 91       	ld	r30, X+
    8d6c:	fc 91       	ld	r31, X
    8d6e:	e2 0f       	add	r30, r18
    8d70:	f3 1f       	adc	r31, r19
    8d72:	32 97       	sbiw	r30, 0x02	; 2
    8d74:	8b e2       	ldi	r24, 0x2B	; 43
    8d76:	80 83       	st	Z, r24
					if(Val<0)Param->Pos[i-2]='-';
    8d78:	f7 fe       	sbrs	r15, 7
    8d7a:	be cf       	rjmp	.-132    	; 0x8cf8 <Put_sDVal+0x1a6>
    8d7c:	d8 01       	movw	r26, r16
    8d7e:	ed 91       	ld	r30, X+
    8d80:	fc 91       	ld	r31, X
    8d82:	e2 0f       	add	r30, r18
    8d84:	f3 1f       	adc	r31, r19
    8d86:	32 97       	sbiw	r30, 0x02	; 2
    8d88:	8d e2       	ldi	r24, 0x2D	; 45
    8d8a:	80 83       	st	Z, r24
    8d8c:	b5 cf       	rjmp	.-150    	; 0x8cf8 <Put_sDVal+0x1a6>
void
Put_sDVal(int32_t Val, T_Param *Param)
{
	uint32_t Idx = 0x80000000+Val;
	if(Param->Txt && Idx<2) {
		Param->Txt += Idx;
    8d8e:	88 0f       	add	r24, r24
    8d90:	99 1f       	adc	r25, r25
    8d92:	28 0f       	add	r18, r24
    8d94:	39 1f       	adc	r19, r25
    8d96:	fa 01       	movw	r30, r20
    8d98:	35 83       	std	Z+5, r19	; 0x05
    8d9a:	24 83       	std	Z+4, r18	; 0x04
		PutEnum(Param);
    8d9c:	ca 01       	movw	r24, r20
    8d9e:	0e 94 09 41 	call	0x8212	; 0x8212 <PutEnum>
    8da2:	aa cf       	rjmp	.-172    	; 0x8cf8 <Put_sDVal+0x1a6>

00008da4 <PutDVal>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// PutDVal - print unsigned Longint in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
PutDVal(uint32_t Val, T_Param *Param)
{
    8da4:	2f 92       	push	r2
    8da6:	3f 92       	push	r3
    8da8:	4f 92       	push	r4
    8daa:	5f 92       	push	r5
    8dac:	6f 92       	push	r6
    8dae:	7f 92       	push	r7
    8db0:	8f 92       	push	r8
    8db2:	9f 92       	push	r9
    8db4:	af 92       	push	r10
    8db6:	bf 92       	push	r11
    8db8:	cf 92       	push	r12
    8dba:	df 92       	push	r13
    8dbc:	ef 92       	push	r14
    8dbe:	ff 92       	push	r15
    8dc0:	0f 93       	push	r16
    8dc2:	1f 93       	push	r17
    8dc4:	df 93       	push	r29
    8dc6:	cf 93       	push	r28
    8dc8:	cd b7       	in	r28, 0x3d	; 61
    8dca:	de b7       	in	r29, 0x3e	; 62
    8dcc:	2b 97       	sbiw	r28, 0x0b	; 11
    8dce:	0f b6       	in	r0, 0x3f	; 63
    8dd0:	f8 94       	cli
    8dd2:	de bf       	out	0x3e, r29	; 62
    8dd4:	0f be       	out	0x3f, r0	; 63
    8dd6:	cd bf       	out	0x3d, r28	; 61
    8dd8:	1b 01       	movw	r2, r22
    8dda:	2c 01       	movw	r4, r24
    8ddc:	3a 01       	movw	r6, r20
	uint32_t Idx = 0xFFFFFFFF-Val;
	if(Param->Txt && Idx<2) {
    8dde:	da 01       	movw	r26, r20
    8de0:	14 96       	adiw	r26, 0x04	; 4
    8de2:	2d 91       	ld	r18, X+
    8de4:	3c 91       	ld	r19, X
    8de6:	15 97       	sbiw	r26, 0x05	; 5
    8de8:	21 15       	cp	r18, r1
    8dea:	31 05       	cpc	r19, r1
    8dec:	61 f0       	breq	.+24     	; 0x8e06 <PutDVal+0x62>
// PutDVal - print unsigned Longint in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
PutDVal(uint32_t Val, T_Param *Param)
{
	uint32_t Idx = 0xFFFFFFFF-Val;
    8dee:	dc 01       	movw	r26, r24
    8df0:	cb 01       	movw	r24, r22
    8df2:	80 95       	com	r24
    8df4:	90 95       	com	r25
    8df6:	a0 95       	com	r26
    8df8:	b0 95       	com	r27
	if(Param->Txt && Idx<2) {
    8dfa:	82 30       	cpi	r24, 0x02	; 2
    8dfc:	91 05       	cpc	r25, r1
    8dfe:	a1 05       	cpc	r26, r1
    8e00:	b1 05       	cpc	r27, r1
    8e02:	08 f4       	brcc	.+2      	; 0x8e06 <PutDVal+0x62>
    8e04:	e5 c0       	rjmp	.+458    	; 0x8fd0 <PutDVal+0x22c>
		Param->Txt += Idx;
		PutEnum(Param);
		return;
	}

	if(Param->Size==10 && Param->Prec==0){
    8e06:	d3 01       	movw	r26, r6
    8e08:	13 96       	adiw	r26, 0x03	; 3
    8e0a:	8c 91       	ld	r24, X
    8e0c:	13 97       	sbiw	r26, 0x03	; 3
    8e0e:	8a 30       	cpi	r24, 0x0A	; 10
    8e10:	09 f4       	brne	.+2      	; 0x8e14 <PutDVal+0x70>
    8e12:	72 c0       	rjmp	.+228    	; 0x8ef8 <PutDVal+0x154>
		sprintf(Param->Pos, "%10lu", Val);
		return;
	}
	char Format[] = "% lu.%. lu";
    8e14:	de 01       	movw	r26, r28
    8e16:	11 96       	adiw	r26, 0x01	; 1
    8e18:	e6 e6       	ldi	r30, 0x66	; 102
    8e1a:	f2 e0       	ldi	r31, 0x02	; 2
    8e1c:	8b e0       	ldi	r24, 0x0B	; 11
    8e1e:	01 90       	ld	r0, Z+
    8e20:	0d 92       	st	X+, r0
    8e22:	81 50       	subi	r24, 0x01	; 1
    8e24:	e1 f7       	brne	.-8      	; 0x8e1e <PutDVal+0x7a>
	Format[1] = '0'+Param->Size;
    8e26:	d3 01       	movw	r26, r6
    8e28:	13 96       	adiw	r26, 0x03	; 3
    8e2a:	2c 91       	ld	r18, X
    8e2c:	13 97       	sbiw	r26, 0x03	; 3
    8e2e:	20 5d       	subi	r18, 0xD0	; 208
    8e30:	2a 83       	std	Y+2, r18	; 0x02
	if(Param->Prec) {
    8e32:	12 96       	adiw	r26, 0x02	; 2
    8e34:	9c 91       	ld	r25, X
    8e36:	99 23       	and	r25, r25
    8e38:	09 f4       	brne	.+2      	; 0x8e3c <PutDVal+0x98>
    8e3a:	a0 c0       	rjmp	.+320    	; 0x8f7c <PutDVal+0x1d8>
		Format[1] -= Param->Prec+1;
    8e3c:	89 2f       	mov	r24, r25
    8e3e:	80 95       	com	r24
    8e40:	82 0f       	add	r24, r18
    8e42:	8a 83       	std	Y+2, r24	; 0x02
		Format[7] = '0'+Param->Prec;
    8e44:	90 5d       	subi	r25, 0xD0	; 208
    8e46:	98 87       	std	Y+8, r25	; 0x08
    8e48:	90 53       	subi	r25, 0x30	; 48
		uint32_t Div=PowL10(Param->Prec);
    8e4a:	09 2f       	mov	r16, r25
    8e4c:	f1 e0       	ldi	r31, 0x01	; 1
    8e4e:	8f 2e       	mov	r8, r31
    8e50:	91 2c       	mov	r9, r1
    8e52:	a1 2c       	mov	r10, r1
    8e54:	b1 2c       	mov	r11, r1
		Pow *= 10;
    8e56:	c5 01       	movw	r24, r10
    8e58:	b4 01       	movw	r22, r8
    8e5a:	2a e0       	ldi	r18, 0x0A	; 10
    8e5c:	30 e0       	ldi	r19, 0x00	; 0
    8e5e:	40 e0       	ldi	r20, 0x00	; 0
    8e60:	50 e0       	ldi	r21, 0x00	; 0
    8e62:	0e 94 23 83 	call	0x10646	; 0x10646 <__mulsi3>
    8e66:	4b 01       	movw	r8, r22
    8e68:	5c 01       	movw	r10, r24
    8e6a:	01 50       	subi	r16, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
	uint32_t Pow = 1;
	while(Exp--)
    8e6c:	a1 f7       	brne	.-24     	; 0x8e56 <PutDVal+0xb2>
    8e6e:	c2 01       	movw	r24, r4
    8e70:	b1 01       	movw	r22, r2
    8e72:	94 01       	movw	r18, r8
    8e74:	a5 01       	movw	r20, r10
    8e76:	0e 94 75 83 	call	0x106ea	; 0x106ea <__udivmodsi4>
    8e7a:	f6 2e       	mov	r15, r22
    8e7c:	e7 2e       	mov	r14, r23
    8e7e:	d8 2e       	mov	r13, r24
    8e80:	c9 2e       	mov	r12, r25
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
    8e82:	ed b7       	in	r30, 0x3d	; 61
    8e84:	fe b7       	in	r31, 0x3e	; 62
    8e86:	3c 97       	sbiw	r30, 0x0c	; 12
    8e88:	0f b6       	in	r0, 0x3f	; 63
    8e8a:	f8 94       	cli
    8e8c:	fe bf       	out	0x3e, r31	; 62
    8e8e:	0f be       	out	0x3f, r0	; 63
    8e90:	ed bf       	out	0x3d, r30	; 61
    8e92:	0d b7       	in	r16, 0x3d	; 61
    8e94:	1e b7       	in	r17, 0x3e	; 62
    8e96:	0f 5f       	subi	r16, 0xFF	; 255
    8e98:	1f 4f       	sbci	r17, 0xFF	; 255
    8e9a:	d3 01       	movw	r26, r6
    8e9c:	8d 91       	ld	r24, X+
    8e9e:	9c 91       	ld	r25, X
    8ea0:	92 83       	std	Z+2, r25	; 0x02
    8ea2:	81 83       	std	Z+1, r24	; 0x01
    8ea4:	81 e0       	ldi	r24, 0x01	; 1
    8ea6:	90 e0       	ldi	r25, 0x00	; 0
    8ea8:	8c 0f       	add	r24, r28
    8eaa:	9d 1f       	adc	r25, r29
    8eac:	f8 01       	movw	r30, r16
    8eae:	93 83       	std	Z+3, r25	; 0x03
    8eb0:	82 83       	std	Z+2, r24	; 0x02
    8eb2:	c2 01       	movw	r24, r4
    8eb4:	b1 01       	movw	r22, r2
    8eb6:	a5 01       	movw	r20, r10
    8eb8:	94 01       	movw	r18, r8
    8eba:	0e 94 75 83 	call	0x106ea	; 0x106ea <__udivmodsi4>
    8ebe:	d8 01       	movw	r26, r16
    8ec0:	14 96       	adiw	r26, 0x04	; 4
    8ec2:	2d 93       	st	X+, r18
    8ec4:	3d 93       	st	X+, r19
    8ec6:	4d 93       	st	X+, r20
    8ec8:	5c 93       	st	X, r21
    8eca:	17 97       	sbiw	r26, 0x07	; 7
    8ecc:	18 96       	adiw	r26, 0x08	; 8
    8ece:	fc 92       	st	X, r15
    8ed0:	18 97       	sbiw	r26, 0x08	; 8
    8ed2:	19 96       	adiw	r26, 0x09	; 9
    8ed4:	ec 92       	st	X, r14
    8ed6:	19 97       	sbiw	r26, 0x09	; 9
    8ed8:	1a 96       	adiw	r26, 0x0a	; 10
    8eda:	dc 92       	st	X, r13
    8edc:	1a 97       	sbiw	r26, 0x0a	; 10
    8ede:	1b 96       	adiw	r26, 0x0b	; 11
    8ee0:	cc 92       	st	X, r12
    8ee2:	0e 94 b9 80 	call	0x10172	; 0x10172 <sprintf>
    8ee6:	ed b7       	in	r30, 0x3d	; 61
    8ee8:	fe b7       	in	r31, 0x3e	; 62
    8eea:	3c 96       	adiw	r30, 0x0c	; 12
    8eec:	0f b6       	in	r0, 0x3f	; 63
    8eee:	f8 94       	cli
    8ef0:	fe bf       	out	0x3e, r31	; 62
    8ef2:	0f be       	out	0x3f, r0	; 63
    8ef4:	ed bf       	out	0x3d, r30	; 61
    8ef6:	29 c0       	rjmp	.+82     	; 0x8f4a <PutDVal+0x1a6>
		Param->Txt += Idx;
		PutEnum(Param);
		return;
	}

	if(Param->Size==10 && Param->Prec==0){
    8ef8:	12 96       	adiw	r26, 0x02	; 2
    8efa:	8c 91       	ld	r24, X
    8efc:	12 97       	sbiw	r26, 0x02	; 2
    8efe:	88 23       	and	r24, r24
    8f00:	09 f0       	breq	.+2      	; 0x8f04 <PutDVal+0x160>
    8f02:	88 cf       	rjmp	.-240    	; 0x8e14 <PutDVal+0x70>
		sprintf(Param->Pos, "%10lu", Val);
    8f04:	ed b7       	in	r30, 0x3d	; 61
    8f06:	fe b7       	in	r31, 0x3e	; 62
    8f08:	38 97       	sbiw	r30, 0x08	; 8
    8f0a:	0f b6       	in	r0, 0x3f	; 63
    8f0c:	f8 94       	cli
    8f0e:	fe bf       	out	0x3e, r31	; 62
    8f10:	0f be       	out	0x3f, r0	; 63
    8f12:	ed bf       	out	0x3d, r30	; 61
    8f14:	31 96       	adiw	r30, 0x01	; 1
    8f16:	8d 91       	ld	r24, X+
    8f18:	9c 91       	ld	r25, X
    8f1a:	ad b7       	in	r26, 0x3d	; 61
    8f1c:	be b7       	in	r27, 0x3e	; 62
    8f1e:	12 96       	adiw	r26, 0x02	; 2
    8f20:	9c 93       	st	X, r25
    8f22:	8e 93       	st	-X, r24
    8f24:	11 97       	sbiw	r26, 0x01	; 1
    8f26:	80 e6       	ldi	r24, 0x60	; 96
    8f28:	92 e0       	ldi	r25, 0x02	; 2
    8f2a:	93 83       	std	Z+3, r25	; 0x03
    8f2c:	82 83       	std	Z+2, r24	; 0x02
    8f2e:	24 82       	std	Z+4, r2	; 0x04
    8f30:	35 82       	std	Z+5, r3	; 0x05
    8f32:	46 82       	std	Z+6, r4	; 0x06
    8f34:	57 82       	std	Z+7, r5	; 0x07
    8f36:	0e 94 b9 80 	call	0x10172	; 0x10172 <sprintf>
    8f3a:	ed b7       	in	r30, 0x3d	; 61
    8f3c:	fe b7       	in	r31, 0x3e	; 62
    8f3e:	38 96       	adiw	r30, 0x08	; 8
    8f40:	0f b6       	in	r0, 0x3f	; 63
    8f42:	f8 94       	cli
    8f44:	fe bf       	out	0x3e, r31	; 62
    8f46:	0f be       	out	0x3f, r0	; 63
    8f48:	ed bf       	out	0x3d, r30	; 61
	}
	else {
		Format[4] = '\0';
		sprintf(Param->Pos, Format, Val);
	}
}
    8f4a:	2b 96       	adiw	r28, 0x0b	; 11
    8f4c:	0f b6       	in	r0, 0x3f	; 63
    8f4e:	f8 94       	cli
    8f50:	de bf       	out	0x3e, r29	; 62
    8f52:	0f be       	out	0x3f, r0	; 63
    8f54:	cd bf       	out	0x3d, r28	; 61
    8f56:	cf 91       	pop	r28
    8f58:	df 91       	pop	r29
    8f5a:	1f 91       	pop	r17
    8f5c:	0f 91       	pop	r16
    8f5e:	ff 90       	pop	r15
    8f60:	ef 90       	pop	r14
    8f62:	df 90       	pop	r13
    8f64:	cf 90       	pop	r12
    8f66:	bf 90       	pop	r11
    8f68:	af 90       	pop	r10
    8f6a:	9f 90       	pop	r9
    8f6c:	8f 90       	pop	r8
    8f6e:	7f 90       	pop	r7
    8f70:	6f 90       	pop	r6
    8f72:	5f 90       	pop	r5
    8f74:	4f 90       	pop	r4
    8f76:	3f 90       	pop	r3
    8f78:	2f 90       	pop	r2
    8f7a:	08 95       	ret
		Format[7] = '0'+Param->Prec;
		uint32_t Div=PowL10(Param->Prec);
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
	}
	else {
		Format[4] = '\0';
    8f7c:	1d 82       	std	Y+5, r1	; 0x05
		sprintf(Param->Pos, Format, Val);
    8f7e:	8d b7       	in	r24, 0x3d	; 61
    8f80:	9e b7       	in	r25, 0x3e	; 62
    8f82:	08 97       	sbiw	r24, 0x08	; 8
    8f84:	0f b6       	in	r0, 0x3f	; 63
    8f86:	f8 94       	cli
    8f88:	9e bf       	out	0x3e, r25	; 62
    8f8a:	0f be       	out	0x3f, r0	; 63
    8f8c:	8d bf       	out	0x3d, r24	; 61
    8f8e:	ed b7       	in	r30, 0x3d	; 61
    8f90:	fe b7       	in	r31, 0x3e	; 62
    8f92:	31 96       	adiw	r30, 0x01	; 1
    8f94:	d3 01       	movw	r26, r6
    8f96:	8d 91       	ld	r24, X+
    8f98:	9c 91       	ld	r25, X
    8f9a:	ad b7       	in	r26, 0x3d	; 61
    8f9c:	be b7       	in	r27, 0x3e	; 62
    8f9e:	12 96       	adiw	r26, 0x02	; 2
    8fa0:	9c 93       	st	X, r25
    8fa2:	8e 93       	st	-X, r24
    8fa4:	11 97       	sbiw	r26, 0x01	; 1
    8fa6:	81 e0       	ldi	r24, 0x01	; 1
    8fa8:	90 e0       	ldi	r25, 0x00	; 0
    8faa:	8c 0f       	add	r24, r28
    8fac:	9d 1f       	adc	r25, r29
    8fae:	93 83       	std	Z+3, r25	; 0x03
    8fb0:	82 83       	std	Z+2, r24	; 0x02
    8fb2:	24 82       	std	Z+4, r2	; 0x04
    8fb4:	35 82       	std	Z+5, r3	; 0x05
    8fb6:	46 82       	std	Z+6, r4	; 0x06
    8fb8:	57 82       	std	Z+7, r5	; 0x07
    8fba:	0e 94 b9 80 	call	0x10172	; 0x10172 <sprintf>
    8fbe:	ad b7       	in	r26, 0x3d	; 61
    8fc0:	be b7       	in	r27, 0x3e	; 62
    8fc2:	18 96       	adiw	r26, 0x08	; 8
    8fc4:	0f b6       	in	r0, 0x3f	; 63
    8fc6:	f8 94       	cli
    8fc8:	be bf       	out	0x3e, r27	; 62
    8fca:	0f be       	out	0x3f, r0	; 63
    8fcc:	ad bf       	out	0x3d, r26	; 61
    8fce:	bd cf       	rjmp	.-134    	; 0x8f4a <PutDVal+0x1a6>
void
PutDVal(uint32_t Val, T_Param *Param)
{
	uint32_t Idx = 0xFFFFFFFF-Val;
	if(Param->Txt && Idx<2) {
		Param->Txt += Idx;
    8fd0:	88 0f       	add	r24, r24
    8fd2:	99 1f       	adc	r25, r25
    8fd4:	28 0f       	add	r18, r24
    8fd6:	39 1f       	adc	r19, r25
    8fd8:	fa 01       	movw	r30, r20
    8fda:	35 83       	std	Z+5, r19	; 0x05
    8fdc:	24 83       	std	Z+4, r18	; 0x04
		PutEnum(Param);
    8fde:	ca 01       	movw	r24, r20
    8fe0:	0e 94 09 41 	call	0x8212	; 0x8212 <PutEnum>
    8fe4:	b2 cf       	rjmp	.-156    	; 0x8f4a <PutDVal+0x1a6>

00008fe6 <Put_zVal_h>:
	}
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_zVal_h(uint32_t Val, char Type, T_Param *Param)
{
    8fe6:	1f 93       	push	r17
    8fe8:	17 2f       	mov	r17, r23
    8fea:	58 2f       	mov	r21, r24
    8fec:	79 2f       	mov	r23, r25
    8fee:	d9 01       	movw	r26, r18
	if(Type=='b') sprintf(Param->Pos, "%02hx", (uint8_t)Val);
    8ff0:	42 36       	cpi	r20, 0x62	; 98
    8ff2:	71 f1       	breq	.+92     	; 0x9050 <Put_zVal_h+0x6a>
	if(Type=='w') sprintf(Param->Pos, "%04x", (uint16_t)Val);
    8ff4:	47 37       	cpi	r20, 0x77	; 119
    8ff6:	09 f4       	brne	.+2      	; 0x8ffa <Put_zVal_h+0x14>
    8ff8:	4a c0       	rjmp	.+148    	; 0x908e <Put_zVal_h+0xa8>
	if(Type=='l') sprintf(Param->Pos, "%08lx", Val);
    8ffa:	4c 36       	cpi	r20, 0x6C	; 108
    8ffc:	11 f0       	breq	.+4      	; 0x9002 <Put_zVal_h+0x1c>
}
    8ffe:	1f 91       	pop	r17
    9000:	08 95       	ret
void
Put_zVal_h(uint32_t Val, char Type, T_Param *Param)
{
	if(Type=='b') sprintf(Param->Pos, "%02hx", (uint8_t)Val);
	if(Type=='w') sprintf(Param->Pos, "%04x", (uint16_t)Val);
	if(Type=='l') sprintf(Param->Pos, "%08lx", Val);
    9002:	8d b7       	in	r24, 0x3d	; 61
    9004:	9e b7       	in	r25, 0x3e	; 62
    9006:	08 97       	sbiw	r24, 0x08	; 8
    9008:	0f b6       	in	r0, 0x3f	; 63
    900a:	f8 94       	cli
    900c:	9e bf       	out	0x3e, r25	; 62
    900e:	0f be       	out	0x3f, r0	; 63
    9010:	8d bf       	out	0x3d, r24	; 61
    9012:	ed b7       	in	r30, 0x3d	; 61
    9014:	fe b7       	in	r31, 0x3e	; 62
    9016:	31 96       	adiw	r30, 0x01	; 1
    9018:	8d 91       	ld	r24, X+
    901a:	9c 91       	ld	r25, X
    901c:	ad b7       	in	r26, 0x3d	; 61
    901e:	be b7       	in	r27, 0x3e	; 62
    9020:	12 96       	adiw	r26, 0x02	; 2
    9022:	9c 93       	st	X, r25
    9024:	8e 93       	st	-X, r24
    9026:	11 97       	sbiw	r26, 0x01	; 1
    9028:	8c e7       	ldi	r24, 0x7C	; 124
    902a:	92 e0       	ldi	r25, 0x02	; 2
    902c:	93 83       	std	Z+3, r25	; 0x03
    902e:	82 83       	std	Z+2, r24	; 0x02
    9030:	64 83       	std	Z+4, r22	; 0x04
    9032:	15 83       	std	Z+5, r17	; 0x05
    9034:	56 83       	std	Z+6, r21	; 0x06
    9036:	77 83       	std	Z+7, r23	; 0x07
    9038:	0e 94 b9 80 	call	0x10172	; 0x10172 <sprintf>
    903c:	8d b7       	in	r24, 0x3d	; 61
    903e:	9e b7       	in	r25, 0x3e	; 62
    9040:	08 96       	adiw	r24, 0x08	; 8
    9042:	0f b6       	in	r0, 0x3f	; 63
    9044:	f8 94       	cli
    9046:	9e bf       	out	0x3e, r25	; 62
    9048:	0f be       	out	0x3f, r0	; 63
    904a:	8d bf       	out	0x3d, r24	; 61
}
    904c:	1f 91       	pop	r17
    904e:	08 95       	ret
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_zVal_h(uint32_t Val, char Type, T_Param *Param)
{
	if(Type=='b') sprintf(Param->Pos, "%02hx", (uint8_t)Val);
    9050:	00 d0       	rcall	.+0      	; 0x9052 <Put_zVal_h+0x6c>
    9052:	00 d0       	rcall	.+0      	; 0x9054 <Put_zVal_h+0x6e>
    9054:	ed b7       	in	r30, 0x3d	; 61
    9056:	fe b7       	in	r31, 0x3e	; 62
    9058:	31 96       	adiw	r30, 0x01	; 1
    905a:	8d 91       	ld	r24, X+
    905c:	9c 91       	ld	r25, X
    905e:	ad b7       	in	r26, 0x3d	; 61
    9060:	be b7       	in	r27, 0x3e	; 62
    9062:	12 96       	adiw	r26, 0x02	; 2
    9064:	9c 93       	st	X, r25
    9066:	8e 93       	st	-X, r24
    9068:	11 97       	sbiw	r26, 0x01	; 1
    906a:	81 e7       	ldi	r24, 0x71	; 113
    906c:	92 e0       	ldi	r25, 0x02	; 2
    906e:	93 83       	std	Z+3, r25	; 0x03
    9070:	82 83       	std	Z+2, r24	; 0x02
    9072:	64 83       	std	Z+4, r22	; 0x04
    9074:	15 82       	std	Z+5, r1	; 0x05
    9076:	0e 94 b9 80 	call	0x10172	; 0x10172 <sprintf>
    907a:	8d b7       	in	r24, 0x3d	; 61
    907c:	9e b7       	in	r25, 0x3e	; 62
    907e:	06 96       	adiw	r24, 0x06	; 6
    9080:	0f b6       	in	r0, 0x3f	; 63
    9082:	f8 94       	cli
    9084:	9e bf       	out	0x3e, r25	; 62
    9086:	0f be       	out	0x3f, r0	; 63
    9088:	8d bf       	out	0x3d, r24	; 61
	if(Type=='w') sprintf(Param->Pos, "%04x", (uint16_t)Val);
	if(Type=='l') sprintf(Param->Pos, "%08lx", Val);
}
    908a:	1f 91       	pop	r17
    908c:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_zVal_h(uint32_t Val, char Type, T_Param *Param)
{
	if(Type=='b') sprintf(Param->Pos, "%02hx", (uint8_t)Val);
	if(Type=='w') sprintf(Param->Pos, "%04x", (uint16_t)Val);
    908e:	00 d0       	rcall	.+0      	; 0x9090 <Put_zVal_h+0xaa>
    9090:	00 d0       	rcall	.+0      	; 0x9092 <Put_zVal_h+0xac>
    9092:	ed b7       	in	r30, 0x3d	; 61
    9094:	fe b7       	in	r31, 0x3e	; 62
    9096:	31 96       	adiw	r30, 0x01	; 1
    9098:	8d 91       	ld	r24, X+
    909a:	9c 91       	ld	r25, X
    909c:	ad b7       	in	r26, 0x3d	; 61
    909e:	be b7       	in	r27, 0x3e	; 62
    90a0:	12 96       	adiw	r26, 0x02	; 2
    90a2:	9c 93       	st	X, r25
    90a4:	8e 93       	st	-X, r24
    90a6:	11 97       	sbiw	r26, 0x01	; 1
    90a8:	87 e7       	ldi	r24, 0x77	; 119
    90aa:	92 e0       	ldi	r25, 0x02	; 2
    90ac:	93 83       	std	Z+3, r25	; 0x03
    90ae:	82 83       	std	Z+2, r24	; 0x02
    90b0:	64 83       	std	Z+4, r22	; 0x04
    90b2:	15 83       	std	Z+5, r17	; 0x05
    90b4:	0e 94 b9 80 	call	0x10172	; 0x10172 <sprintf>
    90b8:	8d b7       	in	r24, 0x3d	; 61
    90ba:	9e b7       	in	r25, 0x3e	; 62
    90bc:	06 96       	adiw	r24, 0x06	; 6
    90be:	0f b6       	in	r0, 0x3f	; 63
    90c0:	f8 94       	cli
    90c2:	9e bf       	out	0x3e, r25	; 62
    90c4:	0f be       	out	0x3f, r0	; 63
    90c6:	8d bf       	out	0x3d, r24	; 61
	if(Type=='l') sprintf(Param->Pos, "%08lx", Val);
}
    90c8:	1f 91       	pop	r17
    90ca:	08 95       	ret

000090cc <Put_zVal>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_zVal(uint16_t Val, char Type, T_Param *Param)
{
    90cc:	af 92       	push	r10
    90ce:	bf 92       	push	r11
    90d0:	cf 92       	push	r12
    90d2:	df 92       	push	r13
    90d4:	ef 92       	push	r14
    90d6:	ff 92       	push	r15
    90d8:	0f 93       	push	r16
    90da:	1f 93       	push	r17
    90dc:	df 93       	push	r29
    90de:	cf 93       	push	r28
    90e0:	cd b7       	in	r28, 0x3d	; 61
    90e2:	de b7       	in	r29, 0x3e	; 62
    90e4:	2a 97       	sbiw	r28, 0x0a	; 10
    90e6:	0f b6       	in	r0, 0x3f	; 63
    90e8:	f8 94       	cli
    90ea:	de bf       	out	0x3e, r29	; 62
    90ec:	0f be       	out	0x3f, r0	; 63
    90ee:	cd bf       	out	0x3d, r28	; 61
    90f0:	6c 01       	movw	r12, r24
    90f2:	7a 01       	movw	r14, r20
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
    90f4:	67 37       	cpi	r22, 0x77	; 119
    90f6:	09 f4       	brne	.+2      	; 0x90fa <Put_zVal+0x2e>
    90f8:	79 c0       	rjmp	.+242    	; 0x91ec <Put_zVal+0x120>
    90fa:	8f ef       	ldi	r24, 0xFF	; 255
    90fc:	90 e0       	ldi	r25, 0x00	; 0
	if(Param->Txt && Idx<2) {
    90fe:	d7 01       	movw	r26, r14
    9100:	14 96       	adiw	r26, 0x04	; 4
    9102:	2d 91       	ld	r18, X+
    9104:	3c 91       	ld	r19, X
    9106:	15 97       	sbiw	r26, 0x05	; 5
    9108:	21 15       	cp	r18, r1
    910a:	31 05       	cpc	r19, r1
    910c:	31 f0       	breq	.+12     	; 0x911a <Put_zVal+0x4e>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_zVal(uint16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
    910e:	8c 19       	sub	r24, r12
    9110:	9d 09       	sbc	r25, r13
	if(Param->Txt && Idx<2) {
    9112:	82 30       	cpi	r24, 0x02	; 2
    9114:	91 05       	cpc	r25, r1
    9116:	08 f4       	brcc	.+2      	; 0x911a <Put_zVal+0x4e>
    9118:	8a c0       	rjmp	.+276    	; 0x922e <Put_zVal+0x162>
		Param->Txt += Idx;
		PutEnum(Param);
		return;
	}
	char Format[] = "%0 u.%. u";
    911a:	5e 01       	movw	r10, r28
    911c:	08 94       	sec
    911e:	a1 1c       	adc	r10, r1
    9120:	b1 1c       	adc	r11, r1
    9122:	d5 01       	movw	r26, r10
    9124:	e2 e8       	ldi	r30, 0x82	; 130
    9126:	f2 e0       	ldi	r31, 0x02	; 2
    9128:	8a e0       	ldi	r24, 0x0A	; 10
    912a:	01 90       	ld	r0, Z+
    912c:	0d 92       	st	X+, r0
    912e:	81 50       	subi	r24, 0x01	; 1
    9130:	e1 f7       	brne	.-8      	; 0x912a <Put_zVal+0x5e>
	Format[2] = '0'+Param->Size;
    9132:	f7 01       	movw	r30, r14
    9134:	23 81       	ldd	r18, Z+3	; 0x03
    9136:	20 5d       	subi	r18, 0xD0	; 208
    9138:	2b 83       	std	Y+3, r18	; 0x03
	if(Param->Prec) {
    913a:	92 81       	ldd	r25, Z+2	; 0x02
    913c:	99 23       	and	r25, r25
    913e:	09 f4       	brne	.+2      	; 0x9142 <Put_zVal+0x76>
    9140:	58 c0       	rjmp	.+176    	; 0x91f2 <Put_zVal+0x126>
		Format[2] -= Param->Prec+1;
    9142:	89 2f       	mov	r24, r25
    9144:	80 95       	com	r24
    9146:	82 0f       	add	r24, r18
    9148:	8b 83       	std	Y+3, r24	; 0x03
		Format[7] = '0'+Param->Prec;
    914a:	90 5d       	subi	r25, 0xD0	; 208
    914c:	98 87       	std	Y+8, r25	; 0x08
    914e:	90 53       	subi	r25, 0x30	; 48
		uint16_t Div=Pow10(Param->Prec);
    9150:	29 2f       	mov	r18, r25
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    9152:	01 e0       	ldi	r16, 0x01	; 1
    9154:	10 e0       	ldi	r17, 0x00	; 0
		Pow *= 10;
    9156:	c8 01       	movw	r24, r16
    9158:	88 0f       	add	r24, r24
    915a:	99 1f       	adc	r25, r25
    915c:	00 0f       	add	r16, r16
    915e:	11 1f       	adc	r17, r17
    9160:	00 0f       	add	r16, r16
    9162:	11 1f       	adc	r17, r17
    9164:	00 0f       	add	r16, r16
    9166:	11 1f       	adc	r17, r17
    9168:	08 0f       	add	r16, r24
    916a:	19 1f       	adc	r17, r25
    916c:	21 50       	subi	r18, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    916e:	99 f7       	brne	.-26     	; 0x9156 <Put_zVal+0x8a>
    9170:	c6 01       	movw	r24, r12
    9172:	b8 01       	movw	r22, r16
    9174:	0e 94 4e 83 	call	0x1069c	; 0x1069c <__udivmodhi4>
    9178:	9c 01       	movw	r18, r24
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
    917a:	8d b7       	in	r24, 0x3d	; 61
    917c:	9e b7       	in	r25, 0x3e	; 62
    917e:	08 97       	sbiw	r24, 0x08	; 8
    9180:	0f b6       	in	r0, 0x3f	; 63
    9182:	f8 94       	cli
    9184:	9e bf       	out	0x3e, r25	; 62
    9186:	0f be       	out	0x3f, r0	; 63
    9188:	8d bf       	out	0x3d, r24	; 61
    918a:	ed b7       	in	r30, 0x3d	; 61
    918c:	fe b7       	in	r31, 0x3e	; 62
    918e:	31 96       	adiw	r30, 0x01	; 1
    9190:	d7 01       	movw	r26, r14
    9192:	8d 91       	ld	r24, X+
    9194:	9c 91       	ld	r25, X
    9196:	ad b7       	in	r26, 0x3d	; 61
    9198:	be b7       	in	r27, 0x3e	; 62
    919a:	12 96       	adiw	r26, 0x02	; 2
    919c:	9c 93       	st	X, r25
    919e:	8e 93       	st	-X, r24
    91a0:	11 97       	sbiw	r26, 0x01	; 1
    91a2:	b3 82       	std	Z+3, r11	; 0x03
    91a4:	a2 82       	std	Z+2, r10	; 0x02
    91a6:	c6 01       	movw	r24, r12
    91a8:	b8 01       	movw	r22, r16
    91aa:	0e 94 4e 83 	call	0x1069c	; 0x1069c <__udivmodhi4>
    91ae:	75 83       	std	Z+5, r23	; 0x05
    91b0:	64 83       	std	Z+4, r22	; 0x04
    91b2:	26 83       	std	Z+6, r18	; 0x06
    91b4:	37 83       	std	Z+7, r19	; 0x07
    91b6:	0e 94 b9 80 	call	0x10172	; 0x10172 <sprintf>
    91ba:	ed b7       	in	r30, 0x3d	; 61
    91bc:	fe b7       	in	r31, 0x3e	; 62
    91be:	38 96       	adiw	r30, 0x08	; 8
    91c0:	0f b6       	in	r0, 0x3f	; 63
    91c2:	f8 94       	cli
    91c4:	fe bf       	out	0x3e, r31	; 62
    91c6:	0f be       	out	0x3f, r0	; 63
    91c8:	ed bf       	out	0x3d, r30	; 61
	}
	else {
		Format[4] = '\0';
		sprintf(Param->Pos, Format, Val);
	}
}
    91ca:	2a 96       	adiw	r28, 0x0a	; 10
    91cc:	0f b6       	in	r0, 0x3f	; 63
    91ce:	f8 94       	cli
    91d0:	de bf       	out	0x3e, r29	; 62
    91d2:	0f be       	out	0x3f, r0	; 63
    91d4:	cd bf       	out	0x3d, r28	; 61
    91d6:	cf 91       	pop	r28
    91d8:	df 91       	pop	r29
    91da:	1f 91       	pop	r17
    91dc:	0f 91       	pop	r16
    91de:	ff 90       	pop	r15
    91e0:	ef 90       	pop	r14
    91e2:	df 90       	pop	r13
    91e4:	cf 90       	pop	r12
    91e6:	bf 90       	pop	r11
    91e8:	af 90       	pop	r10
    91ea:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_zVal(uint16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
    91ec:	8f ef       	ldi	r24, 0xFF	; 255
    91ee:	9f ef       	ldi	r25, 0xFF	; 255
    91f0:	86 cf       	rjmp	.-244    	; 0x90fe <Put_zVal+0x32>
		Format[7] = '0'+Param->Prec;
		uint16_t Div=Pow10(Param->Prec);
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
	}
	else {
		Format[4] = '\0';
    91f2:	1d 82       	std	Y+5, r1	; 0x05
		sprintf(Param->Pos, Format, Val);
    91f4:	00 d0       	rcall	.+0      	; 0x91f6 <Put_zVal+0x12a>
    91f6:	00 d0       	rcall	.+0      	; 0x91f8 <Put_zVal+0x12c>
    91f8:	ed b7       	in	r30, 0x3d	; 61
    91fa:	fe b7       	in	r31, 0x3e	; 62
    91fc:	31 96       	adiw	r30, 0x01	; 1
    91fe:	d7 01       	movw	r26, r14
    9200:	8d 91       	ld	r24, X+
    9202:	9c 91       	ld	r25, X
    9204:	ad b7       	in	r26, 0x3d	; 61
    9206:	be b7       	in	r27, 0x3e	; 62
    9208:	12 96       	adiw	r26, 0x02	; 2
    920a:	9c 93       	st	X, r25
    920c:	8e 93       	st	-X, r24
    920e:	11 97       	sbiw	r26, 0x01	; 1
    9210:	b3 82       	std	Z+3, r11	; 0x03
    9212:	a2 82       	std	Z+2, r10	; 0x02
    9214:	d5 82       	std	Z+5, r13	; 0x05
    9216:	c4 82       	std	Z+4, r12	; 0x04
    9218:	0e 94 b9 80 	call	0x10172	; 0x10172 <sprintf>
    921c:	ed b7       	in	r30, 0x3d	; 61
    921e:	fe b7       	in	r31, 0x3e	; 62
    9220:	36 96       	adiw	r30, 0x06	; 6
    9222:	0f b6       	in	r0, 0x3f	; 63
    9224:	f8 94       	cli
    9226:	fe bf       	out	0x3e, r31	; 62
    9228:	0f be       	out	0x3f, r0	; 63
    922a:	ed bf       	out	0x3d, r30	; 61
    922c:	ce cf       	rjmp	.-100    	; 0x91ca <Put_zVal+0xfe>
void
Put_zVal(uint16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
	if(Param->Txt && Idx<2) {
		Param->Txt += Idx;
    922e:	88 0f       	add	r24, r24
    9230:	99 1f       	adc	r25, r25
    9232:	28 0f       	add	r18, r24
    9234:	39 1f       	adc	r19, r25
    9236:	15 96       	adiw	r26, 0x05	; 5
    9238:	3c 93       	st	X, r19
    923a:	2e 93       	st	-X, r18
    923c:	14 97       	sbiw	r26, 0x04	; 4
		PutEnum(Param);
    923e:	c7 01       	movw	r24, r14
    9240:	0e 94 09 41 	call	0x8212	; 0x8212 <PutEnum>
    9244:	c2 cf       	rjmp	.-124    	; 0x91ca <Put_zVal+0xfe>

00009246 <Put_sVal>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_sVal(int16_t Val, char Type, T_Param *Param)
{
    9246:	af 92       	push	r10
    9248:	bf 92       	push	r11
    924a:	cf 92       	push	r12
    924c:	df 92       	push	r13
    924e:	ef 92       	push	r14
    9250:	ff 92       	push	r15
    9252:	0f 93       	push	r16
    9254:	1f 93       	push	r17
    9256:	df 93       	push	r29
    9258:	cf 93       	push	r28
    925a:	cd b7       	in	r28, 0x3d	; 61
    925c:	de b7       	in	r29, 0x3e	; 62
    925e:	2a 97       	sbiw	r28, 0x0a	; 10
    9260:	0f b6       	in	r0, 0x3f	; 63
    9262:	f8 94       	cli
    9264:	de bf       	out	0x3e, r29	; 62
    9266:	0f be       	out	0x3f, r0	; 63
    9268:	cd bf       	out	0x3d, r28	; 61
    926a:	6c 01       	movw	r12, r24
    926c:	7a 01       	movw	r14, r20
	uint16_t Idx = (Type=='w'?0x8000:0x80)+Val;
    926e:	67 37       	cpi	r22, 0x77	; 119
    9270:	09 f4       	brne	.+2      	; 0x9274 <Put_sVal+0x2e>
    9272:	81 c0       	rjmp	.+258    	; 0x9376 <Put_sVal+0x130>
    9274:	80 e8       	ldi	r24, 0x80	; 128
    9276:	90 e0       	ldi	r25, 0x00	; 0
	if(Param->Txt && Idx<2) {
    9278:	d7 01       	movw	r26, r14
    927a:	14 96       	adiw	r26, 0x04	; 4
    927c:	2d 91       	ld	r18, X+
    927e:	3c 91       	ld	r19, X
    9280:	15 97       	sbiw	r26, 0x05	; 5
    9282:	21 15       	cp	r18, r1
    9284:	31 05       	cpc	r19, r1
    9286:	31 f0       	breq	.+12     	; 0x9294 <Put_sVal+0x4e>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_sVal(int16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0x8000:0x80)+Val;
    9288:	8c 0d       	add	r24, r12
    928a:	9d 1d       	adc	r25, r13
	if(Param->Txt && Idx<2) {
    928c:	82 30       	cpi	r24, 0x02	; 2
    928e:	91 05       	cpc	r25, r1
    9290:	08 f4       	brcc	.+2      	; 0x9294 <Put_sVal+0x4e>
    9292:	ac c0       	rjmp	.+344    	; 0x93ec <Put_sVal+0x1a6>
		Param->Txt += Idx;
		PutEnum(Param);
		return;
	}
	char Format[] = "%+ d.%. u";
    9294:	5e 01       	movw	r10, r28
    9296:	08 94       	sec
    9298:	a1 1c       	adc	r10, r1
    929a:	b1 1c       	adc	r11, r1
    929c:	d5 01       	movw	r26, r10
    929e:	ec e8       	ldi	r30, 0x8C	; 140
    92a0:	f2 e0       	ldi	r31, 0x02	; 2
    92a2:	8a e0       	ldi	r24, 0x0A	; 10
    92a4:	01 90       	ld	r0, Z+
    92a6:	0d 92       	st	X+, r0
    92a8:	81 50       	subi	r24, 0x01	; 1
    92aa:	e1 f7       	brne	.-8      	; 0x92a4 <Put_sVal+0x5e>
	if(Val==0)
    92ac:	c1 14       	cp	r12, r1
    92ae:	d1 04       	cpc	r13, r1
    92b0:	09 f4       	brne	.+2      	; 0x92b4 <Put_sVal+0x6e>
    92b2:	64 c0       	rjmp	.+200    	; 0x937c <Put_sVal+0x136>
		Format[1] = ' ';
	Format[2] = '0'+Param->Size;
    92b4:	f7 01       	movw	r30, r14
    92b6:	23 81       	ldd	r18, Z+3	; 0x03
    92b8:	20 5d       	subi	r18, 0xD0	; 208
    92ba:	2b 83       	std	Y+3, r18	; 0x03
	if(Param->Prec) {
    92bc:	92 81       	ldd	r25, Z+2	; 0x02
    92be:	99 23       	and	r25, r25
    92c0:	09 f4       	brne	.+2      	; 0x92c4 <Put_sVal+0x7e>
    92c2:	66 c0       	rjmp	.+204    	; 0x9390 <Put_sVal+0x14a>
		Format[2] -= Param->Prec+1;
    92c4:	89 2f       	mov	r24, r25
    92c6:	80 95       	com	r24
    92c8:	82 0f       	add	r24, r18
    92ca:	8b 83       	std	Y+3, r24	; 0x03
		Format[7] = '0'+Param->Prec;
    92cc:	90 5d       	subi	r25, 0xD0	; 208
    92ce:	98 87       	std	Y+8, r25	; 0x08
    92d0:	90 53       	subi	r25, 0x30	; 48
		int16_t Div=Pow10(Param->Prec);
    92d2:	29 2f       	mov	r18, r25
    92d4:	01 e0       	ldi	r16, 0x01	; 1
    92d6:	10 e0       	ldi	r17, 0x00	; 0
		Pow *= 10;
    92d8:	c8 01       	movw	r24, r16
    92da:	88 0f       	add	r24, r24
    92dc:	99 1f       	adc	r25, r25
    92de:	00 0f       	add	r16, r16
    92e0:	11 1f       	adc	r17, r17
    92e2:	00 0f       	add	r16, r16
    92e4:	11 1f       	adc	r17, r17
    92e6:	00 0f       	add	r16, r16
    92e8:	11 1f       	adc	r17, r17
    92ea:	08 0f       	add	r16, r24
    92ec:	19 1f       	adc	r17, r25
    92ee:	21 50       	subi	r18, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    92f0:	99 f7       	brne	.-26     	; 0x92d8 <Put_sVal+0x92>
    92f2:	c6 01       	movw	r24, r12
    92f4:	d7 fc       	sbrc	r13, 7
    92f6:	86 c0       	rjmp	.+268    	; 0x9404 <Put_sVal+0x1be>
    92f8:	b8 01       	movw	r22, r16
    92fa:	0e 94 4e 83 	call	0x1069c	; 0x1069c <__udivmodhi4>
    92fe:	9c 01       	movw	r18, r24
		sprintf(Param->Pos, Format, Val/Div, (uint16_t)abs(Val)%Div);
    9300:	8d b7       	in	r24, 0x3d	; 61
    9302:	9e b7       	in	r25, 0x3e	; 62
    9304:	08 97       	sbiw	r24, 0x08	; 8
    9306:	0f b6       	in	r0, 0x3f	; 63
    9308:	f8 94       	cli
    930a:	9e bf       	out	0x3e, r25	; 62
    930c:	0f be       	out	0x3f, r0	; 63
    930e:	8d bf       	out	0x3d, r24	; 61
    9310:	ed b7       	in	r30, 0x3d	; 61
    9312:	fe b7       	in	r31, 0x3e	; 62
    9314:	31 96       	adiw	r30, 0x01	; 1
    9316:	d7 01       	movw	r26, r14
    9318:	8d 91       	ld	r24, X+
    931a:	9c 91       	ld	r25, X
    931c:	ad b7       	in	r26, 0x3d	; 61
    931e:	be b7       	in	r27, 0x3e	; 62
    9320:	12 96       	adiw	r26, 0x02	; 2
    9322:	9c 93       	st	X, r25
    9324:	8e 93       	st	-X, r24
    9326:	11 97       	sbiw	r26, 0x01	; 1
    9328:	b3 82       	std	Z+3, r11	; 0x03
    932a:	a2 82       	std	Z+2, r10	; 0x02
    932c:	c6 01       	movw	r24, r12
    932e:	b8 01       	movw	r22, r16
    9330:	0e 94 62 83 	call	0x106c4	; 0x106c4 <__divmodhi4>
    9334:	75 83       	std	Z+5, r23	; 0x05
    9336:	64 83       	std	Z+4, r22	; 0x04
    9338:	26 83       	std	Z+6, r18	; 0x06
    933a:	37 83       	std	Z+7, r19	; 0x07
    933c:	0e 94 b9 80 	call	0x10172	; 0x10172 <sprintf>
		if(Val<0) {
    9340:	ed b7       	in	r30, 0x3d	; 61
    9342:	fe b7       	in	r31, 0x3e	; 62
    9344:	38 96       	adiw	r30, 0x08	; 8
    9346:	0f b6       	in	r0, 0x3f	; 63
    9348:	f8 94       	cli
    934a:	fe bf       	out	0x3e, r31	; 62
    934c:	0f be       	out	0x3f, r0	; 63
    934e:	ed bf       	out	0x3d, r30	; 61
    9350:	d7 fc       	sbrc	r13, 7
    9352:	3c c0       	rjmp	.+120    	; 0x93cc <Put_sVal+0x186>
	}
	else {
		Format[4] = '\0';
		sprintf(Param->Pos, Format, Val);
	}
}
    9354:	2a 96       	adiw	r28, 0x0a	; 10
    9356:	0f b6       	in	r0, 0x3f	; 63
    9358:	f8 94       	cli
    935a:	de bf       	out	0x3e, r29	; 62
    935c:	0f be       	out	0x3f, r0	; 63
    935e:	cd bf       	out	0x3d, r28	; 61
    9360:	cf 91       	pop	r28
    9362:	df 91       	pop	r29
    9364:	1f 91       	pop	r17
    9366:	0f 91       	pop	r16
    9368:	ff 90       	pop	r15
    936a:	ef 90       	pop	r14
    936c:	df 90       	pop	r13
    936e:	cf 90       	pop	r12
    9370:	bf 90       	pop	r11
    9372:	af 90       	pop	r10
    9374:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_sVal(int16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0x8000:0x80)+Val;
    9376:	80 e0       	ldi	r24, 0x00	; 0
    9378:	90 e8       	ldi	r25, 0x80	; 128
    937a:	7e cf       	rjmp	.-260    	; 0x9278 <Put_sVal+0x32>
		PutEnum(Param);
		return;
	}
	char Format[] = "%+ d.%. u";
	if(Val==0)
		Format[1] = ' ';
    937c:	80 e2       	ldi	r24, 0x20	; 32
    937e:	8a 83       	std	Y+2, r24	; 0x02
	Format[2] = '0'+Param->Size;
    9380:	f7 01       	movw	r30, r14
    9382:	23 81       	ldd	r18, Z+3	; 0x03
    9384:	20 5d       	subi	r18, 0xD0	; 208
    9386:	2b 83       	std	Y+3, r18	; 0x03
	if(Param->Prec) {
    9388:	92 81       	ldd	r25, Z+2	; 0x02
    938a:	99 23       	and	r25, r25
    938c:	09 f0       	breq	.+2      	; 0x9390 <Put_sVal+0x14a>
    938e:	9a cf       	rjmp	.-204    	; 0x92c4 <Put_sVal+0x7e>
				Param->Pos++;
			*Param->Pos = '-';
		}
	}
	else {
		Format[4] = '\0';
    9390:	1d 82       	std	Y+5, r1	; 0x05
		sprintf(Param->Pos, Format, Val);
    9392:	00 d0       	rcall	.+0      	; 0x9394 <Put_sVal+0x14e>
    9394:	00 d0       	rcall	.+0      	; 0x9396 <Put_sVal+0x150>
    9396:	ed b7       	in	r30, 0x3d	; 61
    9398:	fe b7       	in	r31, 0x3e	; 62
    939a:	31 96       	adiw	r30, 0x01	; 1
    939c:	d7 01       	movw	r26, r14
    939e:	8d 91       	ld	r24, X+
    93a0:	9c 91       	ld	r25, X
    93a2:	ad b7       	in	r26, 0x3d	; 61
    93a4:	be b7       	in	r27, 0x3e	; 62
    93a6:	12 96       	adiw	r26, 0x02	; 2
    93a8:	9c 93       	st	X, r25
    93aa:	8e 93       	st	-X, r24
    93ac:	11 97       	sbiw	r26, 0x01	; 1
    93ae:	b3 82       	std	Z+3, r11	; 0x03
    93b0:	a2 82       	std	Z+2, r10	; 0x02
    93b2:	d5 82       	std	Z+5, r13	; 0x05
    93b4:	c4 82       	std	Z+4, r12	; 0x04
    93b6:	0e 94 b9 80 	call	0x10172	; 0x10172 <sprintf>
    93ba:	ed b7       	in	r30, 0x3d	; 61
    93bc:	fe b7       	in	r31, 0x3e	; 62
    93be:	36 96       	adiw	r30, 0x06	; 6
    93c0:	0f b6       	in	r0, 0x3f	; 63
    93c2:	f8 94       	cli
    93c4:	fe bf       	out	0x3e, r31	; 62
    93c6:	0f be       	out	0x3f, r0	; 63
    93c8:	ed bf       	out	0x3d, r30	; 61
    93ca:	c4 cf       	rjmp	.-120    	; 0x9354 <Put_sVal+0x10e>
		Format[2] -= Param->Prec+1;
		Format[7] = '0'+Param->Prec;
		int16_t Div=Pow10(Param->Prec);
		sprintf(Param->Pos, Format, Val/Div, (uint16_t)abs(Val)%Div);
		if(Val<0) {
			while(*Param->Pos==' ')
    93cc:	d7 01       	movw	r26, r14
    93ce:	ed 91       	ld	r30, X+
    93d0:	fc 91       	ld	r31, X
    93d2:	80 81       	ld	r24, Z
    93d4:	80 32       	cpi	r24, 0x20	; 32
    93d6:	39 f4       	brne	.+14     	; 0x93e6 <Put_sVal+0x1a0>
				Param->Pos++;
    93d8:	31 96       	adiw	r30, 0x01	; 1
    93da:	d7 01       	movw	r26, r14
    93dc:	ed 93       	st	X+, r30
    93de:	fc 93       	st	X, r31
		Format[2] -= Param->Prec+1;
		Format[7] = '0'+Param->Prec;
		int16_t Div=Pow10(Param->Prec);
		sprintf(Param->Pos, Format, Val/Div, (uint16_t)abs(Val)%Div);
		if(Val<0) {
			while(*Param->Pos==' ')
    93e0:	80 81       	ld	r24, Z
    93e2:	80 32       	cpi	r24, 0x20	; 32
    93e4:	c9 f3       	breq	.-14     	; 0x93d8 <Put_sVal+0x192>
				Param->Pos++;
			*Param->Pos = '-';
    93e6:	8d e2       	ldi	r24, 0x2D	; 45
    93e8:	80 83       	st	Z, r24
    93ea:	b4 cf       	rjmp	.-152    	; 0x9354 <Put_sVal+0x10e>
void
Put_sVal(int16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0x8000:0x80)+Val;
	if(Param->Txt && Idx<2) {
		Param->Txt += Idx;
    93ec:	88 0f       	add	r24, r24
    93ee:	99 1f       	adc	r25, r25
    93f0:	28 0f       	add	r18, r24
    93f2:	39 1f       	adc	r19, r25
    93f4:	15 96       	adiw	r26, 0x05	; 5
    93f6:	3c 93       	st	X, r19
    93f8:	2e 93       	st	-X, r18
    93fa:	14 97       	sbiw	r26, 0x04	; 4
		PutEnum(Param);
    93fc:	c7 01       	movw	r24, r14
    93fe:	0e 94 09 41 	call	0x8212	; 0x8212 <PutEnum>
    9402:	a8 cf       	rjmp	.-176    	; 0x9354 <Put_sVal+0x10e>
    9404:	88 27       	eor	r24, r24
    9406:	99 27       	eor	r25, r25
    9408:	8c 19       	sub	r24, r12
    940a:	9d 09       	sbc	r25, r13
    940c:	75 cf       	rjmp	.-278    	; 0x92f8 <Put_sVal+0xb2>

0000940e <PutVal>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
PutVal(uint16_t Val, char Type, T_Param *Param)
{
    940e:	af 92       	push	r10
    9410:	bf 92       	push	r11
    9412:	cf 92       	push	r12
    9414:	df 92       	push	r13
    9416:	ef 92       	push	r14
    9418:	ff 92       	push	r15
    941a:	0f 93       	push	r16
    941c:	1f 93       	push	r17
    941e:	df 93       	push	r29
    9420:	cf 93       	push	r28
    9422:	cd b7       	in	r28, 0x3d	; 61
    9424:	de b7       	in	r29, 0x3e	; 62
    9426:	29 97       	sbiw	r28, 0x09	; 9
    9428:	0f b6       	in	r0, 0x3f	; 63
    942a:	f8 94       	cli
    942c:	de bf       	out	0x3e, r29	; 62
    942e:	0f be       	out	0x3f, r0	; 63
    9430:	cd bf       	out	0x3d, r28	; 61
    9432:	6c 01       	movw	r12, r24
    9434:	7a 01       	movw	r14, r20
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
    9436:	67 37       	cpi	r22, 0x77	; 119
    9438:	09 f4       	brne	.+2      	; 0x943c <PutVal+0x2e>
    943a:	79 c0       	rjmp	.+242    	; 0x952e <PutVal+0x120>
    943c:	8f ef       	ldi	r24, 0xFF	; 255
    943e:	90 e0       	ldi	r25, 0x00	; 0
	if(Param->Txt && Idx<2) {
    9440:	d7 01       	movw	r26, r14
    9442:	14 96       	adiw	r26, 0x04	; 4
    9444:	2d 91       	ld	r18, X+
    9446:	3c 91       	ld	r19, X
    9448:	15 97       	sbiw	r26, 0x05	; 5
    944a:	21 15       	cp	r18, r1
    944c:	31 05       	cpc	r19, r1
    944e:	31 f0       	breq	.+12     	; 0x945c <PutVal+0x4e>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
PutVal(uint16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
    9450:	8c 19       	sub	r24, r12
    9452:	9d 09       	sbc	r25, r13
	if(Param->Txt && Idx<2) {
    9454:	82 30       	cpi	r24, 0x02	; 2
    9456:	91 05       	cpc	r25, r1
    9458:	08 f4       	brcc	.+2      	; 0x945c <PutVal+0x4e>
    945a:	8a c0       	rjmp	.+276    	; 0x9570 <PutVal+0x162>
		Param->Txt += Idx;
		PutEnum(Param);
		return;
	}
	char Format[] = "% u.%. u";
    945c:	5e 01       	movw	r10, r28
    945e:	08 94       	sec
    9460:	a1 1c       	adc	r10, r1
    9462:	b1 1c       	adc	r11, r1
    9464:	d5 01       	movw	r26, r10
    9466:	e6 e9       	ldi	r30, 0x96	; 150
    9468:	f2 e0       	ldi	r31, 0x02	; 2
    946a:	89 e0       	ldi	r24, 0x09	; 9
    946c:	01 90       	ld	r0, Z+
    946e:	0d 92       	st	X+, r0
    9470:	81 50       	subi	r24, 0x01	; 1
    9472:	e1 f7       	brne	.-8      	; 0x946c <PutVal+0x5e>
	Format[1] = '0'+Param->Size;
    9474:	f7 01       	movw	r30, r14
    9476:	23 81       	ldd	r18, Z+3	; 0x03
    9478:	20 5d       	subi	r18, 0xD0	; 208
    947a:	2a 83       	std	Y+2, r18	; 0x02
	if(Param->Prec) {
    947c:	92 81       	ldd	r25, Z+2	; 0x02
    947e:	99 23       	and	r25, r25
    9480:	09 f4       	brne	.+2      	; 0x9484 <PutVal+0x76>
    9482:	58 c0       	rjmp	.+176    	; 0x9534 <PutVal+0x126>
		Format[1] -= Param->Prec+1;
    9484:	89 2f       	mov	r24, r25
    9486:	80 95       	com	r24
    9488:	82 0f       	add	r24, r18
    948a:	8a 83       	std	Y+2, r24	; 0x02
		Format[6] = '0'+Param->Prec;
    948c:	90 5d       	subi	r25, 0xD0	; 208
    948e:	9f 83       	std	Y+7, r25	; 0x07
    9490:	90 53       	subi	r25, 0x30	; 48
		uint16_t Div=Pow10(Param->Prec);
    9492:	29 2f       	mov	r18, r25
    9494:	01 e0       	ldi	r16, 0x01	; 1
    9496:	10 e0       	ldi	r17, 0x00	; 0
		Pow *= 10;
    9498:	c8 01       	movw	r24, r16
    949a:	88 0f       	add	r24, r24
    949c:	99 1f       	adc	r25, r25
    949e:	00 0f       	add	r16, r16
    94a0:	11 1f       	adc	r17, r17
    94a2:	00 0f       	add	r16, r16
    94a4:	11 1f       	adc	r17, r17
    94a6:	00 0f       	add	r16, r16
    94a8:	11 1f       	adc	r17, r17
    94aa:	08 0f       	add	r16, r24
    94ac:	19 1f       	adc	r17, r25
    94ae:	21 50       	subi	r18, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    94b0:	99 f7       	brne	.-26     	; 0x9498 <PutVal+0x8a>
    94b2:	c6 01       	movw	r24, r12
    94b4:	b8 01       	movw	r22, r16
    94b6:	0e 94 4e 83 	call	0x1069c	; 0x1069c <__udivmodhi4>
    94ba:	9c 01       	movw	r18, r24
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
    94bc:	8d b7       	in	r24, 0x3d	; 61
    94be:	9e b7       	in	r25, 0x3e	; 62
    94c0:	08 97       	sbiw	r24, 0x08	; 8
    94c2:	0f b6       	in	r0, 0x3f	; 63
    94c4:	f8 94       	cli
    94c6:	9e bf       	out	0x3e, r25	; 62
    94c8:	0f be       	out	0x3f, r0	; 63
    94ca:	8d bf       	out	0x3d, r24	; 61
    94cc:	ed b7       	in	r30, 0x3d	; 61
    94ce:	fe b7       	in	r31, 0x3e	; 62
    94d0:	31 96       	adiw	r30, 0x01	; 1
    94d2:	d7 01       	movw	r26, r14
    94d4:	8d 91       	ld	r24, X+
    94d6:	9c 91       	ld	r25, X
    94d8:	ad b7       	in	r26, 0x3d	; 61
    94da:	be b7       	in	r27, 0x3e	; 62
    94dc:	12 96       	adiw	r26, 0x02	; 2
    94de:	9c 93       	st	X, r25
    94e0:	8e 93       	st	-X, r24
    94e2:	11 97       	sbiw	r26, 0x01	; 1
    94e4:	b3 82       	std	Z+3, r11	; 0x03
    94e6:	a2 82       	std	Z+2, r10	; 0x02
    94e8:	c6 01       	movw	r24, r12
    94ea:	b8 01       	movw	r22, r16
    94ec:	0e 94 4e 83 	call	0x1069c	; 0x1069c <__udivmodhi4>
    94f0:	75 83       	std	Z+5, r23	; 0x05
    94f2:	64 83       	std	Z+4, r22	; 0x04
    94f4:	26 83       	std	Z+6, r18	; 0x06
    94f6:	37 83       	std	Z+7, r19	; 0x07
    94f8:	0e 94 b9 80 	call	0x10172	; 0x10172 <sprintf>
    94fc:	ed b7       	in	r30, 0x3d	; 61
    94fe:	fe b7       	in	r31, 0x3e	; 62
    9500:	38 96       	adiw	r30, 0x08	; 8
    9502:	0f b6       	in	r0, 0x3f	; 63
    9504:	f8 94       	cli
    9506:	fe bf       	out	0x3e, r31	; 62
    9508:	0f be       	out	0x3f, r0	; 63
    950a:	ed bf       	out	0x3d, r30	; 61
	}
	else {
		Format[3] = '\0';
		sprintf(Param->Pos, Format, Val);
	}
}
    950c:	29 96       	adiw	r28, 0x09	; 9
    950e:	0f b6       	in	r0, 0x3f	; 63
    9510:	f8 94       	cli
    9512:	de bf       	out	0x3e, r29	; 62
    9514:	0f be       	out	0x3f, r0	; 63
    9516:	cd bf       	out	0x3d, r28	; 61
    9518:	cf 91       	pop	r28
    951a:	df 91       	pop	r29
    951c:	1f 91       	pop	r17
    951e:	0f 91       	pop	r16
    9520:	ff 90       	pop	r15
    9522:	ef 90       	pop	r14
    9524:	df 90       	pop	r13
    9526:	cf 90       	pop	r12
    9528:	bf 90       	pop	r11
    952a:	af 90       	pop	r10
    952c:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
PutVal(uint16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
    952e:	8f ef       	ldi	r24, 0xFF	; 255
    9530:	9f ef       	ldi	r25, 0xFF	; 255
    9532:	86 cf       	rjmp	.-244    	; 0x9440 <PutVal+0x32>
		Format[6] = '0'+Param->Prec;
		uint16_t Div=Pow10(Param->Prec);
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
	}
	else {
		Format[3] = '\0';
    9534:	1c 82       	std	Y+4, r1	; 0x04
		sprintf(Param->Pos, Format, Val);
    9536:	00 d0       	rcall	.+0      	; 0x9538 <PutVal+0x12a>
    9538:	00 d0       	rcall	.+0      	; 0x953a <PutVal+0x12c>
    953a:	ed b7       	in	r30, 0x3d	; 61
    953c:	fe b7       	in	r31, 0x3e	; 62
    953e:	31 96       	adiw	r30, 0x01	; 1
    9540:	d7 01       	movw	r26, r14
    9542:	8d 91       	ld	r24, X+
    9544:	9c 91       	ld	r25, X
    9546:	ad b7       	in	r26, 0x3d	; 61
    9548:	be b7       	in	r27, 0x3e	; 62
    954a:	12 96       	adiw	r26, 0x02	; 2
    954c:	9c 93       	st	X, r25
    954e:	8e 93       	st	-X, r24
    9550:	11 97       	sbiw	r26, 0x01	; 1
    9552:	b3 82       	std	Z+3, r11	; 0x03
    9554:	a2 82       	std	Z+2, r10	; 0x02
    9556:	d5 82       	std	Z+5, r13	; 0x05
    9558:	c4 82       	std	Z+4, r12	; 0x04
    955a:	0e 94 b9 80 	call	0x10172	; 0x10172 <sprintf>
    955e:	ed b7       	in	r30, 0x3d	; 61
    9560:	fe b7       	in	r31, 0x3e	; 62
    9562:	36 96       	adiw	r30, 0x06	; 6
    9564:	0f b6       	in	r0, 0x3f	; 63
    9566:	f8 94       	cli
    9568:	fe bf       	out	0x3e, r31	; 62
    956a:	0f be       	out	0x3f, r0	; 63
    956c:	ed bf       	out	0x3d, r30	; 61
    956e:	ce cf       	rjmp	.-100    	; 0x950c <PutVal+0xfe>
void
PutVal(uint16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
	if(Param->Txt && Idx<2) {
		Param->Txt += Idx;
    9570:	88 0f       	add	r24, r24
    9572:	99 1f       	adc	r25, r25
    9574:	28 0f       	add	r18, r24
    9576:	39 1f       	adc	r19, r25
    9578:	15 96       	adiw	r26, 0x05	; 5
    957a:	3c 93       	st	X, r19
    957c:	2e 93       	st	-X, r18
    957e:	14 97       	sbiw	r26, 0x04	; 4
		PutEnum(Param);
    9580:	c7 01       	movw	r24, r14
    9582:	0e 94 09 41 	call	0x8212	; 0x8212 <PutEnum>
    9586:	c2 cf       	rjmp	.-124    	; 0x950c <PutVal+0xfe>

00009588 <GSM_Wait_Response_P>:
//	}
	if(strcmp(GSM_RxStr, Str))return 0;
	else return 1;
}
// ~~~~~~~~~
uint8_t GSM_Wait_Response_P(prog_char *Str_P, uint8_t RestoreCMD){
    9588:	1f 93       	push	r17
    958a:	cf 93       	push	r28
    958c:	df 93       	push	r29
    958e:	ec 01       	movw	r28, r24
    9590:	16 2f       	mov	r17, r22
	
	if(Timer16Stopp(TD_GSM) && RestoreCMD){
    9592:	80 91 e7 04 	lds	r24, 0x04E7
    9596:	0e 94 71 1c 	call	0x38e2	; 0x38e2 <Timer16Stopp>
    959a:	88 23       	and	r24, r24
    959c:	11 f0       	breq	.+4      	; 0x95a2 <GSM_Wait_Response_P+0x1a>
    959e:	11 23       	and	r17, r17
    95a0:	51 f4       	brne	.+20     	; 0x95b6 <GSM_Wait_Response_P+0x2e>
		GSM_State = RestoreCMD;
		return 0;
	}
	//  
	if(GetStringFromFIFO()){
    95a2:	0e 94 eb 38 	call	0x71d6	; 0x71d6 <GetStringFromFIFO>
    95a6:	88 23       	and	r24, r24
    95a8:	71 f4       	brne	.+28     	; 0x95c6 <GSM_Wait_Response_P+0x3e>
    95aa:	20 e0       	ldi	r18, 0x00	; 0
		if(strcmp_P(GSM_RxStr, Str_P)) return 0;
		else return 1;
	}
	else return 0;
}
    95ac:	82 2f       	mov	r24, r18
    95ae:	df 91       	pop	r29
    95b0:	cf 91       	pop	r28
    95b2:	1f 91       	pop	r17
    95b4:	08 95       	ret
}
// ~~~~~~~~~
uint8_t GSM_Wait_Response_P(prog_char *Str_P, uint8_t RestoreCMD){
	
	if(Timer16Stopp(TD_GSM) && RestoreCMD){
		GSM_State = RestoreCMD;
    95b6:	10 93 b3 06 	sts	0x06B3, r17
    95ba:	20 e0       	ldi	r18, 0x00	; 0
	if(GetStringFromFIFO()){
		if(strcmp_P(GSM_RxStr, Str_P)) return 0;
		else return 1;
	}
	else return 0;
}
    95bc:	82 2f       	mov	r24, r18
    95be:	df 91       	pop	r29
    95c0:	cf 91       	pop	r28
    95c2:	1f 91       	pop	r17
    95c4:	08 95       	ret
		GSM_State = RestoreCMD;
		return 0;
	}
	//  
	if(GetStringFromFIFO()){
		if(strcmp_P(GSM_RxStr, Str_P)) return 0;
    95c6:	89 e9       	ldi	r24, 0x99	; 153
    95c8:	97 e0       	ldi	r25, 0x07	; 7
    95ca:	be 01       	movw	r22, r28
    95cc:	0e 94 bd 7f 	call	0xff7a	; 0xff7a <strcmp_P>
    95d0:	20 e0       	ldi	r18, 0x00	; 0
    95d2:	89 2b       	or	r24, r25
    95d4:	59 f7       	brne	.-42     	; 0x95ac <GSM_Wait_Response_P+0x24>
    95d6:	21 e0       	ldi	r18, 0x01	; 1
		else return 1;
	}
	else return 0;
}
    95d8:	82 2f       	mov	r24, r18
    95da:	df 91       	pop	r29
    95dc:	cf 91       	pop	r28
    95de:	1f 91       	pop	r17
    95e0:	08 95       	ret

000095e2 <GSM_SendCR>:
	
	sei();	
}
// ~~~~~~~~~
//   + CR
void GSM_SendCR(prog_char *Str_P){
    95e2:	ef 92       	push	r14
    95e4:	ff 92       	push	r15
    95e6:	0f 93       	push	r16
    95e8:	1f 93       	push	r17
    95ea:	7c 01       	movw	r14, r24
	GSMTxSz = strlen_P(Str_P);
    95ec:	0e 94 cd 7f 	call	0xff9a	; 0xff9a <strlen_P>
    95f0:	80 93 75 07 	sts	0x0775, r24
	sprintf_P(GSM_TxStr, Str_P);
    95f4:	00 d0       	rcall	.+0      	; 0x95f6 <GSM_SendCR+0x14>
    95f6:	0f 92       	push	r0
    95f8:	02 e0       	ldi	r16, 0x02	; 2
    95fa:	1a e0       	ldi	r17, 0x0A	; 10
    95fc:	ed b7       	in	r30, 0x3d	; 61
    95fe:	fe b7       	in	r31, 0x3e	; 62
    9600:	12 83       	std	Z+2, r17	; 0x02
    9602:	01 83       	std	Z+1, r16	; 0x01
    9604:	f4 82       	std	Z+4, r15	; 0x04
    9606:	e3 82       	std	Z+3, r14	; 0x03
    9608:	0e 94 ea 80 	call	0x101d4	; 0x101d4 <sprintf_P>
	sprintf(GSM_TxStr + GSMTxSz, "\r");
    960c:	80 91 75 07 	lds	r24, 0x0775
    9610:	08 0f       	add	r16, r24
    9612:	11 1d       	adc	r17, r1
    9614:	8d e0       	ldi	r24, 0x0D	; 13
    9616:	90 e0       	ldi	r25, 0x00	; 0
    9618:	f8 01       	movw	r30, r16
    961a:	91 83       	std	Z+1, r25	; 0x01
    961c:	80 83       	st	Z, r24
	GSMTxSz++;
    961e:	80 91 75 07 	lds	r24, 0x0775
    9622:	8f 5f       	subi	r24, 0xFF	; 255
    9624:	80 93 75 07 	sts	0x0775, r24
	GSM_SendFirstChar();
    9628:	0f 90       	pop	r0
    962a:	0f 90       	pop	r0
    962c:	0f 90       	pop	r0
    962e:	0f 90       	pop	r0
    9630:	0e 94 15 3a 	call	0x742a	; 0x742a <GSM_SendFirstChar>
}
    9634:	1f 91       	pop	r17
    9636:	0f 91       	pop	r16
    9638:	ff 90       	pop	r15
    963a:	ef 90       	pop	r14
    963c:	08 95       	ret

0000963e <GSM_Execute_Command>:
	GSMTxSz = Size;
	memcpy(GSM_TxStr, Data_Out, GSMTxSz);
	GSM_SendFirstChar();
}
// ~~~~~~~~~
void GSM_Execute_Command(prog_char *Str_P, uint16_t Timeout){
    963e:	cf 93       	push	r28
    9640:	df 93       	push	r29
    9642:	9c 01       	movw	r18, r24
    9644:	eb 01       	movw	r28, r22
	if(GSM_Flag & (1<<flg_TxCStr)){
    9646:	80 91 d2 02 	lds	r24, 0x02D2
    964a:	80 ff       	sbrs	r24, 0
    964c:	08 c0       	rjmp	.+16     	; 0x965e <GSM_Execute_Command+0x20>
		GSM_SendCR(Str_P);
    964e:	c9 01       	movw	r24, r18
    9650:	0e 94 f1 4a 	call	0x95e2	; 0x95e2 <GSM_SendCR>
		StartTimer16(TD_GSM, Timeout);
    9654:	80 91 e7 04 	lds	r24, 0x04E7
    9658:	be 01       	movw	r22, r28
    965a:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
	}
}
    965e:	df 91       	pop	r29
    9660:	cf 91       	pop	r28
    9662:	08 95       	ret

00009664 <analize_DTMF>:
uint8_t GSM_GotoNextVega(void){
 return 0;
}
uint8_t counter=0;
uint8_t analize_DTMF(){
	if((strstr_P(GSM_RxStr, PSTR("+DTMF: 1")) != NULL) ){
    9664:	89 e9       	ldi	r24, 0x99	; 153
    9666:	97 e0       	ldi	r25, 0x07	; 7
    9668:	68 e3       	ldi	r22, 0x38	; 56
    966a:	7e e2       	ldi	r23, 0x2E	; 46
    966c:	0e 94 ef 7f 	call	0xffde	; 0xffde <strstr_P>
    9670:	89 2b       	or	r24, r25
    9672:	59 f0       	breq	.+22     	; 0x968a <analize_DTMF+0x26>
		StartTimer16(TD_GSM,1000);
    9674:	80 91 e7 04 	lds	r24, 0x04E7
    9678:	68 ee       	ldi	r22, 0xE8	; 232
    967a:	73 e0       	ldi	r23, 0x03	; 3
    967c:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
		GSM_State = GSM_SEND_CREC_5;
    9680:	8b e1       	ldi	r24, 0x1B	; 27
    9682:	80 93 b3 06 	sts	0x06B3, r24
    9686:	81 e0       	ldi	r24, 0x01	; 1
    9688:	08 95       	ret
		return 1;
	}
	if((strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 2,0,6")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 3,0,6")) != NULL) ){
    968a:	89 e9       	ldi	r24, 0x99	; 153
    968c:	97 e0       	ldi	r25, 0x07	; 7
    968e:	6b e2       	ldi	r22, 0x2B	; 43
    9690:	7e e2       	ldi	r23, 0x2E	; 46
    9692:	0e 94 ef 7f 	call	0xffde	; 0xffde <strstr_P>
    9696:	89 2b       	or	r24, r25
    9698:	59 f0       	breq	.+22     	; 0x96b0 <analize_DTMF+0x4c>
		StartTimer16(TD_GSM,2000);
    969a:	80 91 e7 04 	lds	r24, 0x04E7
    969e:	60 ed       	ldi	r22, 0xD0	; 208
    96a0:	77 e0       	ldi	r23, 0x07	; 7
    96a2:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
		GSM_State = GSM_WAIT_DISCONNECT_CAUSE;
    96a6:	85 e2       	ldi	r24, 0x25	; 37
    96a8:	80 93 b3 06 	sts	0x06B3, r24
    96ac:	81 e0       	ldi	r24, 0x01	; 1
		return 1;
	}
	return 0;
}
    96ae:	08 95       	ret
	if((strstr_P(GSM_RxStr, PSTR("+DTMF: 1")) != NULL) ){
		StartTimer16(TD_GSM,1000);
		GSM_State = GSM_SEND_CREC_5;
		return 1;
	}
	if((strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 2,0,6")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 3,0,6")) != NULL) ){
    96b0:	89 e9       	ldi	r24, 0x99	; 153
    96b2:	97 e0       	ldi	r25, 0x07	; 7
    96b4:	6e e1       	ldi	r22, 0x1E	; 30
    96b6:	7e e2       	ldi	r23, 0x2E	; 46
    96b8:	0e 94 ef 7f 	call	0xffde	; 0xffde <strstr_P>
    96bc:	89 2b       	or	r24, r25
    96be:	69 f7       	brne	.-38     	; 0x969a <analize_DTMF+0x36>
    96c0:	89 e9       	ldi	r24, 0x99	; 153
    96c2:	97 e0       	ldi	r25, 0x07	; 7
    96c4:	61 e1       	ldi	r22, 0x11	; 17
    96c6:	7e e2       	ldi	r23, 0x2E	; 46
    96c8:	0e 94 ef 7f 	call	0xffde	; 0xffde <strstr_P>
    96cc:	89 2b       	or	r24, r25
    96ce:	29 f7       	brne	.-54     	; 0x969a <analize_DTMF+0x36>
    96d0:	80 e0       	ldi	r24, 0x00	; 0
    96d2:	08 95       	ret

000096d4 <GSM_Wait_Response>:
	#endif

}
// ~~~~~~~~~
//   GetStringFromFIFO()!
uint8_t GSM_Wait_Response(char *Str, uint8_t RestoreCMD){
    96d4:	bc 01       	movw	r22, r24
//	if(Timer16Stopp(TD_GSM) && RestoreCMD){
//		GSM_State = RestoreCMD;
//		return 0;
//	}
	if(strcmp(GSM_RxStr, Str))return 0;
    96d6:	89 e9       	ldi	r24, 0x99	; 153
    96d8:	97 e0       	ldi	r25, 0x07	; 7
    96da:	0e 94 1d 80 	call	0x1003a	; 0x1003a <strcmp>
    96de:	9c 01       	movw	r18, r24
    96e0:	80 e0       	ldi	r24, 0x00	; 0
    96e2:	23 2b       	or	r18, r19
    96e4:	09 f4       	brne	.+2      	; 0x96e8 <GSM_Wait_Response+0x14>
    96e6:	81 e0       	ldi	r24, 0x01	; 1
	else return 1;
}
    96e8:	08 95       	ret

000096ea <DigiFilt>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
DigiFilt(const uint16_t *Array, uint8_t Edge)
{
    96ea:	6f 92       	push	r6
    96ec:	7f 92       	push	r7
    96ee:	8f 92       	push	r8
    96f0:	9f 92       	push	r9
    96f2:	bf 92       	push	r11
    96f4:	cf 92       	push	r12
    96f6:	df 92       	push	r13
    96f8:	ef 92       	push	r14
    96fa:	ff 92       	push	r15
    96fc:	0f 93       	push	r16
    96fe:	1f 93       	push	r17
    9700:	df 93       	push	r29
    9702:	cf 93       	push	r28
    9704:	cd b7       	in	r28, 0x3d	; 61
    9706:	de b7       	in	r29, 0x3e	; 62
    9708:	28 2f       	mov	r18, r24
    970a:	79 2f       	mov	r23, r25
    970c:	e6 2e       	mov	r14, r22
				Buf[i] = Buf[j];
				Buf[j] = Swap;
			}
	for(i=Edge; i<_Edge; Sum+=Buf[i++]);
	return Sum/(Edge*2);
}
    970e:	6d b6       	in	r6, 0x3d	; 61
    9710:	7e b6       	in	r7, 0x3e	; 62

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
DigiFilt(const uint16_t *Array, uint8_t Edge)
{
	uint8_t Sz = Edge*4;
    9712:	86 2e       	mov	r8, r22
    9714:	99 24       	eor	r9, r9
    9716:	f6 2e       	mov	r15, r22
    9718:	ff 0c       	add	r15, r15
    971a:	ff 0c       	add	r15, r15
	uint8_t _Edge = Sz-Edge;
    971c:	bf 2c       	mov	r11, r15
    971e:	b6 1a       	sub	r11, r22
	uint16_t Buf[Sz];
    9720:	ef 2d       	mov	r30, r15
    9722:	f0 e0       	ldi	r31, 0x00	; 0
    9724:	ee 0f       	add	r30, r30
    9726:	ff 1f       	adc	r31, r31
    9728:	8d b7       	in	r24, 0x3d	; 61
    972a:	9e b7       	in	r25, 0x3e	; 62
    972c:	8e 1b       	sub	r24, r30
    972e:	9f 0b       	sbc	r25, r31
    9730:	0f b6       	in	r0, 0x3f	; 63
    9732:	f8 94       	cli
    9734:	9e bf       	out	0x3e, r25	; 62
    9736:	0f be       	out	0x3f, r0	; 63
    9738:	8d bf       	out	0x3d, r24	; 61
    973a:	0d b7       	in	r16, 0x3d	; 61
    973c:	1e b7       	in	r17, 0x3e	; 62
    973e:	0f 5f       	subi	r16, 0xFF	; 255
    9740:	1f 4f       	sbci	r17, 0xFF	; 255
	uint32_t Sum = 0;
	uint16_t Swap;
	uint8_t i, j;
	memcpy(Buf, Array, Sz*2);
    9742:	c8 01       	movw	r24, r16
    9744:	62 2f       	mov	r22, r18
    9746:	af 01       	movw	r20, r30
    9748:	0e 94 09 80 	call	0x10012	; 0x10012 <memcpy>
	for(i=0; i<Edge; i++)
    974c:	ee 20       	and	r14, r14
    974e:	09 f1       	breq	.+66     	; 0x9792 <DigiFilt+0xa8>
    9750:	d8 01       	movw	r26, r16
    9752:	80 e0       	ldi	r24, 0x00	; 0
		for(j=i+1; j<Sz; j++)
    9754:	58 2f       	mov	r21, r24
    9756:	5f 5f       	subi	r21, 0xFF	; 255
    9758:	5f 15       	cp	r21, r15
    975a:	b8 f4       	brcc	.+46     	; 0x978a <DigiFilt+0xa0>
    975c:	45 2f       	mov	r20, r21
			if(Buf[j] < Buf[i]) {
    975e:	e4 2f       	mov	r30, r20
    9760:	f0 e0       	ldi	r31, 0x00	; 0
    9762:	ee 0f       	add	r30, r30
    9764:	ff 1f       	adc	r31, r31
    9766:	e0 0f       	add	r30, r16
    9768:	f1 1f       	adc	r31, r17
    976a:	20 81       	ld	r18, Z
    976c:	31 81       	ldd	r19, Z+1	; 0x01
    976e:	8d 91       	ld	r24, X+
    9770:	9c 91       	ld	r25, X
    9772:	11 97       	sbiw	r26, 0x01	; 1
    9774:	28 17       	cp	r18, r24
    9776:	39 07       	cpc	r19, r25
    9778:	28 f4       	brcc	.+10     	; 0x9784 <DigiFilt+0x9a>
				Swap = Buf[i];
				Buf[i] = Buf[j];
    977a:	11 96       	adiw	r26, 0x01	; 1
    977c:	3c 93       	st	X, r19
    977e:	2e 93       	st	-X, r18
				Buf[j] = Swap;
    9780:	91 83       	std	Z+1, r25	; 0x01
    9782:	80 83       	st	Z, r24
	uint32_t Sum = 0;
	uint16_t Swap;
	uint8_t i, j;
	memcpy(Buf, Array, Sz*2);
	for(i=0; i<Edge; i++)
		for(j=i+1; j<Sz; j++)
    9784:	4f 5f       	subi	r20, 0xFF	; 255
    9786:	4f 15       	cp	r20, r15
    9788:	50 f3       	brcs	.-44     	; 0x975e <DigiFilt+0x74>
    978a:	12 96       	adiw	r26, 0x02	; 2
    978c:	85 2f       	mov	r24, r21
	uint16_t Buf[Sz];
	uint32_t Sum = 0;
	uint16_t Swap;
	uint8_t i, j;
	memcpy(Buf, Array, Sz*2);
	for(i=0; i<Edge; i++)
    978e:	5e 15       	cp	r21, r14
    9790:	08 f3       	brcs	.-62     	; 0x9754 <DigiFilt+0x6a>
			if(Buf[j] < Buf[i]) {
				Swap = Buf[i];
				Buf[i] = Buf[j];
				Buf[j] = Swap;
			}
	for(i=Sz-1; i>=_Edge; i--)
    9792:	ef 2d       	mov	r30, r15
    9794:	e1 50       	subi	r30, 0x01	; 1
    9796:	eb 15       	cp	r30, r11
    9798:	10 f1       	brcs	.+68     	; 0x97de <DigiFilt+0xf4>
		for(j=i-1; j>=Edge; j--)
    979a:	5e 2f       	mov	r21, r30
    979c:	51 50       	subi	r21, 0x01	; 1
    979e:	5e 15       	cp	r21, r14
    97a0:	d8 f0       	brcs	.+54     	; 0x97d8 <DigiFilt+0xee>
    97a2:	f0 e0       	ldi	r31, 0x00	; 0
    97a4:	45 2f       	mov	r20, r21
    97a6:	ee 0f       	add	r30, r30
    97a8:	ff 1f       	adc	r31, r31
			if(Buf[j] > Buf[i]) {
    97aa:	e0 0f       	add	r30, r16
    97ac:	f1 1f       	adc	r31, r17
    97ae:	a4 2f       	mov	r26, r20
    97b0:	b0 e0       	ldi	r27, 0x00	; 0
    97b2:	aa 0f       	add	r26, r26
    97b4:	bb 1f       	adc	r27, r27
    97b6:	a0 0f       	add	r26, r16
    97b8:	b1 1f       	adc	r27, r17
    97ba:	2d 91       	ld	r18, X+
    97bc:	3c 91       	ld	r19, X
    97be:	11 97       	sbiw	r26, 0x01	; 1
    97c0:	80 81       	ld	r24, Z
    97c2:	91 81       	ldd	r25, Z+1	; 0x01
    97c4:	82 17       	cp	r24, r18
    97c6:	93 07       	cpc	r25, r19
    97c8:	20 f4       	brcc	.+8      	; 0x97d2 <DigiFilt+0xe8>
				Swap = Buf[i];
				Buf[i] = Buf[j];
    97ca:	31 83       	std	Z+1, r19	; 0x01
    97cc:	20 83       	st	Z, r18
				Buf[j] = Swap;
    97ce:	8d 93       	st	X+, r24
    97d0:	9c 93       	st	X, r25
				Swap = Buf[i];
				Buf[i] = Buf[j];
				Buf[j] = Swap;
			}
	for(i=Sz-1; i>=_Edge; i--)
		for(j=i-1; j>=Edge; j--)
    97d2:	41 50       	subi	r20, 0x01	; 1
    97d4:	4e 15       	cp	r20, r14
    97d6:	58 f7       	brcc	.-42     	; 0x97ae <DigiFilt+0xc4>
    97d8:	e5 2f       	mov	r30, r21
			if(Buf[j] < Buf[i]) {
				Swap = Buf[i];
				Buf[i] = Buf[j];
				Buf[j] = Swap;
			}
	for(i=Sz-1; i>=_Edge; i--)
    97da:	5b 15       	cp	r21, r11
    97dc:	f0 f6       	brcc	.-68     	; 0x979a <DigiFilt+0xb0>
			if(Buf[j] > Buf[i]) {
				Swap = Buf[i];
				Buf[i] = Buf[j];
				Buf[j] = Swap;
			}
	for(i=Edge; i<_Edge; Sum+=Buf[i++]);
    97de:	eb 14       	cp	r14, r11
    97e0:	a0 f5       	brcc	.+104    	; 0x984a <DigiFilt+0x160>
    97e2:	6e 2d       	mov	r22, r14
    97e4:	cc 24       	eor	r12, r12
    97e6:	dd 24       	eor	r13, r13
    97e8:	76 01       	movw	r14, r12
    97ea:	e6 2f       	mov	r30, r22
    97ec:	f0 e0       	ldi	r31, 0x00	; 0
    97ee:	ee 0f       	add	r30, r30
    97f0:	ff 1f       	adc	r31, r31
    97f2:	e0 0f       	add	r30, r16
    97f4:	f1 1f       	adc	r31, r17
    97f6:	80 81       	ld	r24, Z
    97f8:	91 81       	ldd	r25, Z+1	; 0x01
    97fa:	a0 e0       	ldi	r26, 0x00	; 0
    97fc:	b0 e0       	ldi	r27, 0x00	; 0
    97fe:	c8 0e       	add	r12, r24
    9800:	d9 1e       	adc	r13, r25
    9802:	ea 1e       	adc	r14, r26
    9804:	fb 1e       	adc	r15, r27
    9806:	6f 5f       	subi	r22, 0xFF	; 255
    9808:	6b 15       	cp	r22, r11
    980a:	78 f3       	brcs	.-34     	; 0x97ea <DigiFilt+0x100>
    980c:	88 0c       	add	r8, r8
    980e:	99 1c       	adc	r9, r9
    9810:	94 01       	movw	r18, r8
    9812:	44 27       	eor	r20, r20
    9814:	37 fd       	sbrc	r19, 7
    9816:	40 95       	com	r20
    9818:	54 2f       	mov	r21, r20
    981a:	c7 01       	movw	r24, r14
    981c:	b6 01       	movw	r22, r12
    981e:	0e 94 75 83 	call	0x106ea	; 0x106ea <__udivmodsi4>
    9822:	c9 01       	movw	r24, r18
	return Sum/(Edge*2);
}
    9824:	0f b6       	in	r0, 0x3f	; 63
    9826:	f8 94       	cli
    9828:	7e be       	out	0x3e, r7	; 62
    982a:	0f be       	out	0x3f, r0	; 63
    982c:	6d be       	out	0x3d, r6	; 61
    982e:	cf 91       	pop	r28
    9830:	df 91       	pop	r29
    9832:	1f 91       	pop	r17
    9834:	0f 91       	pop	r16
    9836:	ff 90       	pop	r15
    9838:	ef 90       	pop	r14
    983a:	df 90       	pop	r13
    983c:	cf 90       	pop	r12
    983e:	bf 90       	pop	r11
    9840:	9f 90       	pop	r9
    9842:	8f 90       	pop	r8
    9844:	7f 90       	pop	r7
    9846:	6f 90       	pop	r6
    9848:	08 95       	ret
			if(Buf[j] > Buf[i]) {
				Swap = Buf[i];
				Buf[i] = Buf[j];
				Buf[j] = Swap;
			}
	for(i=Edge; i<_Edge; Sum+=Buf[i++]);
    984a:	cc 24       	eor	r12, r12
    984c:	dd 24       	eor	r13, r13
    984e:	76 01       	movw	r14, r12
    9850:	dd cf       	rjmp	.-70     	; 0x980c <DigiFilt+0x122>

00009852 <MemFailReset>:

// ~~~~~~~~~~~~~~~
void
MemFailReset(void)
{
	if (MemFail &(1<<MemFail_EEPROM)) {
    9852:	80 91 cf 08 	lds	r24, 0x08CF
    9856:	81 ff       	sbrs	r24, 1
    9858:	08 95       	ret
		MemFail &=~(1<<MemFail_EEPROM);
    985a:	8d 7f       	andi	r24, 0xFD	; 253
    985c:	80 93 cf 08 	sts	0x08CF, r24
		eeprom_write_word(&MemCheck_stor.CRC_EEPROM_stor, CRC_EEPROM_calc());
    9860:	0e 94 10 1a 	call	0x3420	; 0x3420 <CRC_EEPROM_calc>
    9864:	bc 01       	movw	r22, r24
    9866:	8a e3       	ldi	r24, 0x3A	; 58
    9868:	91 e0       	ldi	r25, 0x01	; 1
    986a:	0e 94 1b 83 	call	0x10636	; 0x10636 <__eewr_word_m2560>
    986e:	08 95       	ret

00009870 <Key_Mem>:
		MenuPage Menu_BackUp = { SetMenu(Menu_BackUp_List), 1, NULL,
				NULL, NULL, NULL, Menu_BackUp_Enter, NULL, NULL, NULL};
#endif

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t Key_Mem(void) {if(CurrLine==3) MemFailReset(); return StandartKey;}
    9870:	80 91 83 07 	lds	r24, 0x0783
    9874:	83 30       	cpi	r24, 0x03	; 3
    9876:	11 f0       	breq	.+4      	; 0x987c <Key_Mem+0xc>
    9878:	80 e0       	ldi	r24, 0x00	; 0
    987a:	08 95       	ret
    987c:	0e 94 29 4c 	call	0x9852	; 0x9852 <MemFailReset>
    9880:	80 e0       	ldi	r24, 0x00	; 0
    9882:	08 95       	ret

00009884 <CRC_EEPROM_upd>:
// ~~~~~~~~~~~~~~~~~
// Duration: 48 ms
static void
CRC_EEPROM_upd(void)
{
	if (!(MemFail &(1<<MemFail_EEPROM)))
    9884:	80 91 cf 08 	lds	r24, 0x08CF
    9888:	81 fd       	sbrc	r24, 1
    988a:	08 95       	ret
		eeprom_write_word(&MemCheck_stor.CRC_EEPROM_stor, CRC_EEPROM_calc());
    988c:	0e 94 10 1a 	call	0x3420	; 0x3420 <CRC_EEPROM_calc>
    9890:	bc 01       	movw	r22, r24
    9892:	8a e3       	ldi	r24, 0x3A	; 58
    9894:	91 e0       	ldi	r25, 0x01	; 1
    9896:	0e 94 1b 83 	call	0x10636	; 0x10636 <__eewr_word_m2560>
    989a:	08 95       	ret

0000989c <ewb>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ewb(uint8_t *addr, uint8_t val)
{
	//IntOff();
	eeprom_write_byte(addr, val);
    989c:	0e 94 05 83 	call	0x1060a	; 0x1060a <__eewr_byte_m2560>
	CRC_EEPROM_upd();
    98a0:	0e 94 42 4c 	call	0x9884	; 0x9884 <CRC_EEPROM_upd>
	//IntOn();
}
    98a4:	08 95       	ret

000098a6 <MB_M_TimeOff_Set>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_M_TimeOff_Set(uint8_t MB_N)
{
	ewb(&MB_M_Param_EE[MB_N].TimeOff, MB_M_TimeOff[MB_N]);
    98a6:	e8 2f       	mov	r30, r24
    98a8:	f0 e0       	ldi	r31, 0x00	; 0
    98aa:	cf 01       	movw	r24, r30
    98ac:	88 0f       	add	r24, r24
    98ae:	99 1f       	adc	r25, r25
    98b0:	88 0f       	add	r24, r24
    98b2:	99 1f       	adc	r25, r25
    98b4:	8e 0f       	add	r24, r30
    98b6:	9f 1f       	adc	r25, r31
    98b8:	e3 52       	subi	r30, 0x23	; 35
    98ba:	fa 4f       	sbci	r31, 0xFA	; 250
    98bc:	8a 5c       	subi	r24, 0xCA	; 202
    98be:	9e 4f       	sbci	r25, 0xFE	; 254
    98c0:	60 81       	ld	r22, Z
    98c2:	0e 94 4e 4c 	call	0x989c	; 0x989c <ewb>
}
    98c6:	08 95       	ret

000098c8 <MB_M_Try_Set>:

// ~~~~~~~~~~~~~~~~~~~~~~~
void
MB_M_Try_Set(uint8_t MB_N)
{
	ewb(&MB_M_Param_EE[MB_N].Try, MB_M_Try[MB_N]);
    98c8:	e8 2f       	mov	r30, r24
    98ca:	f0 e0       	ldi	r31, 0x00	; 0
    98cc:	cf 01       	movw	r24, r30
    98ce:	88 0f       	add	r24, r24
    98d0:	99 1f       	adc	r25, r25
    98d2:	88 0f       	add	r24, r24
    98d4:	99 1f       	adc	r25, r25
    98d6:	8e 0f       	add	r24, r30
    98d8:	9f 1f       	adc	r25, r31
    98da:	e5 50       	subi	r30, 0x05	; 5
    98dc:	f9 4f       	sbci	r31, 0xF9	; 249
    98de:	8b 5c       	subi	r24, 0xCB	; 203
    98e0:	9e 4f       	sbci	r25, 0xFE	; 254
    98e2:	60 81       	ld	r22, Z
    98e4:	0e 94 4e 4c 	call	0x989c	; 0x989c <ewb>
}
    98e8:	08 95       	ret

000098ea <MB_M_Timeout_Set>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_M_Timeout_Set(uint8_t MB_N)
{
	ewb(&MB_M_Param_EE[MB_N].Timeout, MB_M_Timeout[MB_N]);
    98ea:	e8 2f       	mov	r30, r24
    98ec:	f0 e0       	ldi	r31, 0x00	; 0
    98ee:	cf 01       	movw	r24, r30
    98f0:	88 0f       	add	r24, r24
    98f2:	99 1f       	adc	r25, r25
    98f4:	88 0f       	add	r24, r24
    98f6:	99 1f       	adc	r25, r25
    98f8:	8e 0f       	add	r24, r30
    98fa:	9f 1f       	adc	r25, r31
    98fc:	ef 51       	subi	r30, 0x1F	; 31
    98fe:	f7 4f       	sbci	r31, 0xF7	; 247
    9900:	8c 5c       	subi	r24, 0xCC	; 204
    9902:	9e 4f       	sbci	r25, 0xFE	; 254
    9904:	60 81       	ld	r22, Z
    9906:	0e 94 4e 4c 	call	0x989c	; 0x989c <ewb>
}
    990a:	08 95       	ret

0000990c <Set_MB_Addr>:
	static uint8_t EEMEM MB_NativeAddr_EE[Modbus_Qt] = Init_MB_NativeAddr;
	// ~~~~~~~~~~~~~~~~~~~~~~
	void
	Set_MB_Addr(uint8_t MB_N)
	{
		ewb(MB_NativeAddr_EE+MB_N, MB_NativeAddr[MB_N]);
    990c:	e8 2f       	mov	r30, r24
    990e:	f0 e0       	ldi	r31, 0x00	; 0
    9910:	cf 01       	movw	r24, r30
    9912:	89 5c       	subi	r24, 0xC9	; 201
    9914:	9e 4f       	sbci	r25, 0xFE	; 254
    9916:	e2 52       	subi	r30, 0x22	; 34
    9918:	fa 4f       	sbci	r31, 0xFA	; 250
    991a:	60 81       	ld	r22, Z
    991c:	0e 94 4e 4c 	call	0x989c	; 0x989c <ewb>
	}
    9920:	08 95       	ret

00009922 <eww>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
eww(uint16_t *addr, uint16_t val)
{
	//IntOff();
	eeprom_write_word(addr, val);
    9922:	0e 94 1b 83 	call	0x10636	; 0x10636 <__eewr_word_m2560>
	CRC_EEPROM_upd();
    9926:	0e 94 42 4c 	call	0x9884	; 0x9884 <CRC_EEPROM_upd>
	//IntOn();
}
    992a:	08 95       	ret

0000992c <MB_M_Period_Set>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_M_Period_Set(uint8_t MB_N)
{
	eww(&MB_M_Param_EE[MB_N].Period, MB_M_Period[MB_N]);
    992c:	e8 2f       	mov	r30, r24
    992e:	f0 e0       	ldi	r31, 0x00	; 0
    9930:	cf 01       	movw	r24, r30
    9932:	88 0f       	add	r24, r24
    9934:	99 1f       	adc	r25, r25
    9936:	88 0f       	add	r24, r24
    9938:	99 1f       	adc	r25, r25
    993a:	8e 0f       	add	r24, r30
    993c:	9f 1f       	adc	r25, r31
    993e:	ee 0f       	add	r30, r30
    9940:	ff 1f       	adc	r31, r31
    9942:	e5 55       	subi	r30, 0x55	; 85
    9944:	f9 4f       	sbci	r31, 0xF9	; 249
    9946:	60 81       	ld	r22, Z
    9948:	71 81       	ldd	r23, Z+1	; 0x01
    994a:	8e 5c       	subi	r24, 0xCE	; 206
    994c:	9e 4f       	sbci	r25, 0xFE	; 254
    994e:	0e 94 91 4c 	call	0x9922	; 0x9922 <eww>
}
    9952:	08 95       	ret

00009954 <OnTimeSave>:

// ~~~~~~~~~~~~~
void
OnTimeSave(void)
{
	ewb(&Timer1min_EE, Timer1min);
    9954:	8d e3       	ldi	r24, 0x3D	; 61
    9956:	91 e0       	ldi	r25, 0x01	; 1
    9958:	60 91 ae 06 	lds	r22, 0x06AE
    995c:	0e 94 4e 4c 	call	0x989c	; 0x989c <ewb>
	eww(&Timer1hour_EE, Timer1hour);
    9960:	60 91 23 0c 	lds	r22, 0x0C23
    9964:	70 91 24 0c 	lds	r23, 0x0C24
    9968:	8e e3       	ldi	r24, 0x3E	; 62
    996a:	91 e0       	ldi	r25, 0x01	; 1
    996c:	0e 94 91 4c 	call	0x9922	; 0x9922 <eww>
}
    9970:	08 95       	ret

00009972 <TimersInc>:
		HSC_Process();
	#endif
}
void 
TimersInc(void)
{
    9972:	ef 92       	push	r14
    9974:	ff 92       	push	r15
    9976:	0f 93       	push	r16
    9978:	1f 93       	push	r17
    997a:	cf 93       	push	r28
    997c:	df 93       	push	r29
	uint8_t i, TickCounterVar;	
	cli();
    997e:	f8 94       	cli
	TickCounterVar = TickCounter;
    9980:	e0 90 cf 04 	lds	r14, 0x04CF
	TickCounter = 0;
    9984:	10 92 cf 04 	sts	0x04CF, r1
	sei();
    9988:	78 94       	sei
	for(uint8_t j=0;j<TickCounterVar;j++){
    998a:	ee 20       	and	r14, r14
    998c:	09 f4       	brne	.+2      	; 0x9990 <TimersInc+0x1e>
    998e:	c8 c0       	rjmp	.+400    	; 0x9b20 <TimersInc+0x1ae>
    9990:	ff 24       	eor	r15, r15
		LiveTime++;
	 	for (i=0; i<Timer8TotNumber; i++){
			cli();
			if (!(Timer8Flg[i/8] &(1<<i%8)) && --Timer8[i]==0)
				Timer8Flg[i/8] |=(1<<i%8);
    9992:	01 e0       	ldi	r16, 0x01	; 1
    9994:	10 e0       	ldi	r17, 0x00	; 0
	cli();
	TickCounterVar = TickCounter;
	TickCounter = 0;
	sei();
	for(uint8_t j=0;j<TickCounterVar;j++){
		LiveTime++;
    9996:	80 91 7e 07 	lds	r24, 0x077E
    999a:	90 91 7f 07 	lds	r25, 0x077F
    999e:	a0 91 80 07 	lds	r26, 0x0780
    99a2:	b0 91 81 07 	lds	r27, 0x0781
    99a6:	01 96       	adiw	r24, 0x01	; 1
    99a8:	a1 1d       	adc	r26, r1
    99aa:	b1 1d       	adc	r27, r1
    99ac:	80 93 7e 07 	sts	0x077E, r24
    99b0:	90 93 7f 07 	sts	0x077F, r25
    99b4:	a0 93 80 07 	sts	0x0780, r26
    99b8:	b0 93 81 07 	sts	0x0781, r27
    99bc:	40 e0       	ldi	r20, 0x00	; 0
    99be:	50 e0       	ldi	r21, 0x00	; 0
	 	for (i=0; i<Timer8TotNumber; i++){
			cli();
    99c0:	f8 94       	cli
			if (!(Timer8Flg[i/8] &(1<<i%8)) && --Timer8[i]==0)
    99c2:	84 2f       	mov	r24, r20
    99c4:	86 95       	lsr	r24
    99c6:	86 95       	lsr	r24
    99c8:	86 95       	lsr	r24
    99ca:	a8 2f       	mov	r26, r24
    99cc:	b0 e0       	ldi	r27, 0x00	; 0
    99ce:	a1 55       	subi	r26, 0x51	; 81
    99d0:	bb 4f       	sbci	r27, 0xFB	; 251
    99d2:	8c 91       	ld	r24, X
    99d4:	ba 01       	movw	r22, r20
    99d6:	67 70       	andi	r22, 0x07	; 7
    99d8:	70 70       	andi	r23, 0x00	; 0
    99da:	90 e0       	ldi	r25, 0x00	; 0
    99dc:	06 2e       	mov	r0, r22
    99de:	02 c0       	rjmp	.+4      	; 0x99e4 <TimersInc+0x72>
    99e0:	95 95       	asr	r25
    99e2:	87 95       	ror	r24
    99e4:	0a 94       	dec	r0
    99e6:	e2 f7       	brpl	.-8      	; 0x99e0 <TimersInc+0x6e>
    99e8:	80 fd       	sbrc	r24, 0
    99ea:	12 c0       	rjmp	.+36     	; 0x9a10 <TimersInc+0x9e>
    99ec:	fa 01       	movw	r30, r20
    99ee:	eb 50       	subi	r30, 0x0B	; 11
    99f0:	fd 4f       	sbci	r31, 0xFD	; 253
    99f2:	80 81       	ld	r24, Z
    99f4:	81 50       	subi	r24, 0x01	; 1
    99f6:	80 83       	st	Z, r24
    99f8:	80 81       	ld	r24, Z
    99fa:	88 23       	and	r24, r24
    99fc:	49 f4       	brne	.+18     	; 0x9a10 <TimersInc+0x9e>
				Timer8Flg[i/8] |=(1<<i%8);
    99fe:	2c 91       	ld	r18, X
    9a00:	c8 01       	movw	r24, r16
    9a02:	02 c0       	rjmp	.+4      	; 0x9a08 <TimersInc+0x96>
    9a04:	88 0f       	add	r24, r24
    9a06:	99 1f       	adc	r25, r25
    9a08:	6a 95       	dec	r22
    9a0a:	e2 f7       	brpl	.-8      	; 0x9a04 <TimersInc+0x92>
    9a0c:	28 2b       	or	r18, r24
    9a0e:	2c 93       	st	X, r18
			sei();
    9a10:	78 94       	sei
    9a12:	4f 5f       	subi	r20, 0xFF	; 255
    9a14:	5f 4f       	sbci	r21, 0xFF	; 255
	TickCounterVar = TickCounter;
	TickCounter = 0;
	sei();
	for(uint8_t j=0;j<TickCounterVar;j++){
		LiveTime++;
	 	for (i=0; i<Timer8TotNumber; i++){
    9a16:	48 35       	cpi	r20, 0x58	; 88
    9a18:	51 05       	cpc	r21, r1
    9a1a:	91 f6       	brne	.-92     	; 0x99c0 <TimersInc+0x4e>
    9a1c:	40 e0       	ldi	r20, 0x00	; 0
    9a1e:	50 e0       	ldi	r21, 0x00	; 0
			if (!(Timer8Flg[i/8] &(1<<i%8)) && --Timer8[i]==0)
				Timer8Flg[i/8] |=(1<<i%8);
			sei();
		}
		for (i=0; i<Timer16TotNumber; i++){
			cli();
    9a20:	f8 94       	cli
			if (!(Timer16Flg[i/8] &(1<<i%8)) && --Timer16[i]==0)
    9a22:	84 2f       	mov	r24, r20
    9a24:	86 95       	lsr	r24
    9a26:	86 95       	lsr	r24
    9a28:	86 95       	lsr	r24
    9a2a:	a8 2f       	mov	r26, r24
    9a2c:	b0 e0       	ldi	r27, 0x00	; 0
    9a2e:	a5 54       	subi	r26, 0x45	; 69
    9a30:	bb 4f       	sbci	r27, 0xFB	; 251
    9a32:	8c 91       	ld	r24, X
    9a34:	ba 01       	movw	r22, r20
    9a36:	67 70       	andi	r22, 0x07	; 7
    9a38:	70 70       	andi	r23, 0x00	; 0
    9a3a:	90 e0       	ldi	r25, 0x00	; 0
    9a3c:	06 2e       	mov	r0, r22
    9a3e:	02 c0       	rjmp	.+4      	; 0x9a44 <TimersInc+0xd2>
    9a40:	95 95       	asr	r25
    9a42:	87 95       	ror	r24
    9a44:	0a 94       	dec	r0
    9a46:	e2 f7       	brpl	.-8      	; 0x9a40 <TimersInc+0xce>
    9a48:	80 fd       	sbrc	r24, 0
    9a4a:	17 c0       	rjmp	.+46     	; 0x9a7a <TimersInc+0x108>
    9a4c:	fa 01       	movw	r30, r20
    9a4e:	ee 0f       	add	r30, r30
    9a50:	ff 1f       	adc	r31, r31
    9a52:	e3 5b       	subi	r30, 0xB3	; 179
    9a54:	fc 4f       	sbci	r31, 0xFC	; 252
    9a56:	80 81       	ld	r24, Z
    9a58:	91 81       	ldd	r25, Z+1	; 0x01
    9a5a:	01 97       	sbiw	r24, 0x01	; 1
    9a5c:	91 83       	std	Z+1, r25	; 0x01
    9a5e:	80 83       	st	Z, r24
    9a60:	80 81       	ld	r24, Z
    9a62:	91 81       	ldd	r25, Z+1	; 0x01
    9a64:	89 2b       	or	r24, r25
    9a66:	49 f4       	brne	.+18     	; 0x9a7a <TimersInc+0x108>
				Timer16Flg[i/8] |=(1<<i%8);
    9a68:	2c 91       	ld	r18, X
    9a6a:	c8 01       	movw	r24, r16
    9a6c:	02 c0       	rjmp	.+4      	; 0x9a72 <TimersInc+0x100>
    9a6e:	88 0f       	add	r24, r24
    9a70:	99 1f       	adc	r25, r25
    9a72:	6a 95       	dec	r22
    9a74:	e2 f7       	brpl	.-8      	; 0x9a6e <TimersInc+0xfc>
    9a76:	28 2b       	or	r18, r24
    9a78:	2c 93       	st	X, r18
			sei();
    9a7a:	78 94       	sei
    9a7c:	4f 5f       	subi	r20, 0xFF	; 255
    9a7e:	5f 4f       	sbci	r21, 0xFF	; 255
			cli();
			if (!(Timer8Flg[i/8] &(1<<i%8)) && --Timer8[i]==0)
				Timer8Flg[i/8] |=(1<<i%8);
			sei();
		}
		for (i=0; i<Timer16TotNumber; i++){
    9a80:	40 36       	cpi	r20, 0x60	; 96
    9a82:	51 05       	cpc	r21, r1
    9a84:	69 f6       	brne	.-102    	; 0x9a20 <TimersInc+0xae>
    9a86:	40 e0       	ldi	r20, 0x00	; 0
    9a88:	50 e0       	ldi	r21, 0x00	; 0
			if (!(Timer16Flg[i/8] &(1<<i%8)) && --Timer16[i]==0)
				Timer16Flg[i/8] |=(1<<i%8);
			sei();
		}
		for (i=0; i<Timer32TotNumber; i++){
			cli();
    9a8a:	f8 94       	cli
			if (!(Timer32Flg[i/8] &(1<<i%8)) && --Timer32[i]==0)
    9a8c:	84 2f       	mov	r24, r20
    9a8e:	86 95       	lsr	r24
    9a90:	86 95       	lsr	r24
    9a92:	86 95       	lsr	r24
    9a94:	c8 2f       	mov	r28, r24
    9a96:	d0 e0       	ldi	r29, 0x00	; 0
    9a98:	c8 53       	subi	r28, 0x38	; 56
    9a9a:	db 4f       	sbci	r29, 0xFB	; 251
    9a9c:	88 81       	ld	r24, Y
    9a9e:	ba 01       	movw	r22, r20
    9aa0:	67 70       	andi	r22, 0x07	; 7
    9aa2:	70 70       	andi	r23, 0x00	; 0
    9aa4:	90 e0       	ldi	r25, 0x00	; 0
    9aa6:	06 2e       	mov	r0, r22
    9aa8:	02 c0       	rjmp	.+4      	; 0x9aae <TimersInc+0x13c>
    9aaa:	95 95       	asr	r25
    9aac:	87 95       	ror	r24
    9aae:	0a 94       	dec	r0
    9ab0:	e2 f7       	brpl	.-8      	; 0x9aaa <TimersInc+0x138>
    9ab2:	80 fd       	sbrc	r24, 0
    9ab4:	23 c0       	rjmp	.+70     	; 0x9afc <TimersInc+0x18a>
    9ab6:	fa 01       	movw	r30, r20
    9ab8:	ee 0f       	add	r30, r30
    9aba:	ff 1f       	adc	r31, r31
    9abc:	ee 0f       	add	r30, r30
    9abe:	ff 1f       	adc	r31, r31
    9ac0:	e3 5f       	subi	r30, 0xF3	; 243
    9ac2:	fb 4f       	sbci	r31, 0xFB	; 251
    9ac4:	80 81       	ld	r24, Z
    9ac6:	91 81       	ldd	r25, Z+1	; 0x01
    9ac8:	a2 81       	ldd	r26, Z+2	; 0x02
    9aca:	b3 81       	ldd	r27, Z+3	; 0x03
    9acc:	01 97       	sbiw	r24, 0x01	; 1
    9ace:	a1 09       	sbc	r26, r1
    9ad0:	b1 09       	sbc	r27, r1
    9ad2:	80 83       	st	Z, r24
    9ad4:	91 83       	std	Z+1, r25	; 0x01
    9ad6:	a2 83       	std	Z+2, r26	; 0x02
    9ad8:	b3 83       	std	Z+3, r27	; 0x03
    9ada:	80 81       	ld	r24, Z
    9adc:	91 81       	ldd	r25, Z+1	; 0x01
    9ade:	a2 81       	ldd	r26, Z+2	; 0x02
    9ae0:	b3 81       	ldd	r27, Z+3	; 0x03
    9ae2:	00 97       	sbiw	r24, 0x00	; 0
    9ae4:	a1 05       	cpc	r26, r1
    9ae6:	b1 05       	cpc	r27, r1
    9ae8:	49 f4       	brne	.+18     	; 0x9afc <TimersInc+0x18a>
				Timer32Flg[i/8] |=(1<<i%8);	
    9aea:	28 81       	ld	r18, Y
    9aec:	c8 01       	movw	r24, r16
    9aee:	02 c0       	rjmp	.+4      	; 0x9af4 <TimersInc+0x182>
    9af0:	88 0f       	add	r24, r24
    9af2:	99 1f       	adc	r25, r25
    9af4:	6a 95       	dec	r22
    9af6:	e2 f7       	brpl	.-8      	; 0x9af0 <TimersInc+0x17e>
    9af8:	28 2b       	or	r18, r24
    9afa:	28 83       	st	Y, r18
			sei();
    9afc:	78 94       	sei
    9afe:	4f 5f       	subi	r20, 0xFF	; 255
    9b00:	5f 4f       	sbci	r21, 0xFF	; 255
			cli();
			if (!(Timer16Flg[i/8] &(1<<i%8)) && --Timer16[i]==0)
				Timer16Flg[i/8] |=(1<<i%8);
			sei();
		}
		for (i=0; i<Timer32TotNumber; i++){
    9b02:	48 32       	cpi	r20, 0x28	; 40
    9b04:	51 05       	cpc	r21, r1
    9b06:	09 f0       	breq	.+2      	; 0x9b0a <TimersInc+0x198>
    9b08:	c0 cf       	rjmp	.-128    	; 0x9a8a <TimersInc+0x118>
			sei();
		}

		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		static uint8_t Timer10ms;
		if (++Timer10ms==100) {
    9b0a:	80 91 eb 02 	lds	r24, 0x02EB
    9b0e:	8f 5f       	subi	r24, 0xFF	; 255
    9b10:	80 93 eb 02 	sts	0x02EB, r24
    9b14:	84 36       	cpi	r24, 0x64	; 100
    9b16:	59 f0       	breq	.+22     	; 0x9b2e <TimersInc+0x1bc>
	uint8_t i, TickCounterVar;	
	cli();
	TickCounterVar = TickCounter;
	TickCounter = 0;
	sei();
	for(uint8_t j=0;j<TickCounterVar;j++){
    9b18:	f3 94       	inc	r15
    9b1a:	fe 14       	cp	r15, r14
    9b1c:	08 f4       	brcc	.+2      	; 0x9b20 <TimersInc+0x1ae>
    9b1e:	3b cf       	rjmp	.-394    	; 0x9996 <TimersInc+0x24>
 			ScanCount = 0;
			RT();
		}
		#endif
	}
}
    9b20:	df 91       	pop	r29
    9b22:	cf 91       	pop	r28
    9b24:	1f 91       	pop	r17
    9b26:	0f 91       	pop	r16
    9b28:	ff 90       	pop	r15
    9b2a:	ef 90       	pop	r14
    9b2c:	08 95       	ret
		}

		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		static uint8_t Timer10ms;
		if (++Timer10ms==100) {
			Timer10ms = 0;
    9b2e:	10 92 eb 02 	sts	0x02EB, r1
			ScanPerSec = ScanCount;
    9b32:	80 91 6e 07 	lds	r24, 0x076E
    9b36:	90 91 6f 07 	lds	r25, 0x076F
    9b3a:	90 93 88 07 	sts	0x0788, r25
    9b3e:	80 93 87 07 	sts	0x0787, r24
 			ScanCount = 0;
    9b42:	10 92 6f 07 	sts	0x076F, r1
    9b46:	10 92 6e 07 	sts	0x076E, r1

// ~~~~~~~~~~~~~~~
inline static void
RT(void)
{
	if (++Timer1s==60) {
    9b4a:	80 91 d2 08 	lds	r24, 0x08D2
    9b4e:	8f 5f       	subi	r24, 0xFF	; 255
    9b50:	80 93 d2 08 	sts	0x08D2, r24
    9b54:	8c 33       	cpi	r24, 0x3C	; 60
    9b56:	01 f7       	brne	.-64     	; 0x9b18 <TimersInc+0x1a6>
		Timer1s = 0;
    9b58:	10 92 d2 08 	sts	0x08D2, r1
		if (++Timer1min==60) {
    9b5c:	80 91 ae 06 	lds	r24, 0x06AE
    9b60:	8f 5f       	subi	r24, 0xFF	; 255
    9b62:	80 93 ae 06 	sts	0x06AE, r24
    9b66:	8c 33       	cpi	r24, 0x3C	; 60
    9b68:	b9 f6       	brne	.-82     	; 0x9b18 <TimersInc+0x1a6>
			Timer1min = 0;
    9b6a:	10 92 ae 06 	sts	0x06AE, r1
			++Timer1hour;
    9b6e:	80 91 23 0c 	lds	r24, 0x0C23
    9b72:	90 91 24 0c 	lds	r25, 0x0C24
    9b76:	01 96       	adiw	r24, 0x01	; 1
    9b78:	90 93 24 0c 	sts	0x0C24, r25
    9b7c:	80 93 23 0c 	sts	0x0C23, r24
			OnTimeSave();
    9b80:	0e 94 aa 4c 	call	0x9954	; 0x9954 <OnTimeSave>
    9b84:	c9 cf       	rjmp	.-110    	; 0x9b18 <TimersInc+0x1a6>

00009b86 <ewbl>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ewbl(const void *src, void *dst, size_t n)
{
	//IntOff();
	eeprom_write_block(src, dst, n);
    9b86:	0e 94 fb 82 	call	0x105f6	; 0x105f6 <__eewr_block_m2560>
	CRC_EEPROM_upd();
    9b8a:	0e 94 42 4c 	call	0x9884	; 0x9884 <CRC_EEPROM_upd>
	//IntOn();
}
    9b8e:	08 95       	ret

00009b90 <ewd>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ewd(uint32_t *addr, uint32_t val)
{
	//IntOff();
	eeprom_write_dword(addr, val);
    9b90:	0e 94 13 83 	call	0x10626	; 0x10626 <__eewr_dword_m2560>
	CRC_EEPROM_upd();
    9b94:	0e 94 42 4c 	call	0x9884	; 0x9884 <CRC_EEPROM_upd>
	//IntOn();
}
    9b98:	08 95       	ret

00009b9a <erbl>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    9b9a:	0e 94 d7 82 	call	0x105ae	; 0x105ae <__eerd_block_m2560>
	//IntOn();
}
    9b9e:	08 95       	ret

00009ba0 <erd>:
// ~~~~~~~~~~~~~~~~~~~~~~
uint32_t
erd(const uint32_t *addr)
{
	//IntOff();
	uint32_t word = eeprom_read_dword(addr);
    9ba0:	0e 94 ef 82 	call	0x105de	; 0x105de <__eerd_dword_m2560>
	//IntOn();
	return word;
}
    9ba4:	08 95       	ret

00009ba6 <erw>:
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    9ba6:	0e 94 f5 82 	call	0x105ea	; 0x105ea <__eerd_word_m2560>
	//IntOn();
	return word;
}
    9baa:	08 95       	ret

00009bac <EE_InterBrokLine>:
	uint8_t WiAbsc, uint16_t (*TblAbsc)[WiAbsc], uint8_t Absc,
	uint8_t WiOrdi, uint16_t (*TblOrdi)[WiOrdi], uint8_t Ordi,
	uint8_t Len,
	int16_t x
)
{
    9bac:	2f 92       	push	r2
    9bae:	3f 92       	push	r3
    9bb0:	4f 92       	push	r4
    9bb2:	5f 92       	push	r5
    9bb4:	6f 92       	push	r6
    9bb6:	7f 92       	push	r7
    9bb8:	8f 92       	push	r8
    9bba:	9f 92       	push	r9
    9bbc:	af 92       	push	r10
    9bbe:	bf 92       	push	r11
    9bc0:	cf 92       	push	r12
    9bc2:	df 92       	push	r13
    9bc4:	ef 92       	push	r14
    9bc6:	ff 92       	push	r15
    9bc8:	0f 93       	push	r16
    9bca:	1f 93       	push	r17
    9bcc:	df 93       	push	r29
    9bce:	cf 93       	push	r28
    9bd0:	cd b7       	in	r28, 0x3d	; 61
    9bd2:	de b7       	in	r29, 0x3e	; 62
    9bd4:	2e 97       	sbiw	r28, 0x0e	; 14
    9bd6:	0f b6       	in	r0, 0x3f	; 63
    9bd8:	f8 94       	cli
    9bda:	de bf       	out	0x3e, r29	; 62
    9bdc:	0f be       	out	0x3f, r0	; 63
    9bde:	cd bf       	out	0x3d, r28	; 61
    9be0:	f8 2e       	mov	r15, r24
    9be2:	2b 01       	movw	r4, r22
    9be4:	2d 87       	std	Y+13, r18	; 0x0d
    9be6:	18 01       	movw	r2, r16
    9be8:	ee 86       	std	Y+14, r14	; 0x0e
    9bea:	0c 2d       	mov	r16, r12
	LineGraph Segm;
	uint8_t i = 0;
	Segm.x2 = (int16_t)erw(TblAbsc[0]+Absc);
    9bec:	c4 2e       	mov	r12, r20
    9bee:	dd 24       	eor	r13, r13
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    9bf0:	c6 01       	movw	r24, r12
    9bf2:	88 0f       	add	r24, r24
    9bf4:	99 1f       	adc	r25, r25
    9bf6:	86 0f       	add	r24, r22
    9bf8:	97 1f       	adc	r25, r23
    9bfa:	0e 94 f5 82 	call	0x105ea	; 0x105ea <__eerd_word_m2560>
    9bfe:	aa 27       	eor	r26, r26
    9c00:	97 fd       	sbrc	r25, 7
    9c02:	a0 95       	com	r26
    9c04:	ba 2f       	mov	r27, r26
    9c06:	8d 83       	std	Y+5, r24	; 0x05
    9c08:	9e 83       	std	Y+6, r25	; 0x06
    9c0a:	af 83       	std	Y+7, r26	; 0x07
    9c0c:	b8 87       	std	Y+8, r27	; 0x08
    9c0e:	ef 2c       	mov	r14, r15
    9c10:	ff 24       	eor	r15, r15
    9c12:	35 01       	movw	r6, r10
    9c14:	88 24       	eor	r8, r8
    9c16:	77 fc       	sbrc	r7, 7
    9c18:	80 94       	com	r8
    9c1a:	98 2c       	mov	r9, r8
    9c1c:	10 e0       	ldi	r17, 0x00	; 0
    9c1e:	9c 01       	movw	r18, r24
    9c20:	ad 01       	movw	r20, r26
	do {
		Segm.x1 = Segm.x2;
    9c22:	29 83       	std	Y+1, r18	; 0x01
    9c24:	3a 83       	std	Y+2, r19	; 0x02
    9c26:	4b 83       	std	Y+3, r20	; 0x03
    9c28:	5c 83       	std	Y+4, r21	; 0x04
		Segm.x2 = (int16_t)erw(TblAbsc[++i]+Absc);
    9c2a:	1f 5f       	subi	r17, 0xFF	; 255
    9c2c:	a1 2e       	mov	r10, r17
    9c2e:	bb 24       	eor	r11, r11
    9c30:	ae 9c       	mul	r10, r14
    9c32:	c0 01       	movw	r24, r0
    9c34:	af 9c       	mul	r10, r15
    9c36:	90 0d       	add	r25, r0
    9c38:	be 9c       	mul	r11, r14
    9c3a:	90 0d       	add	r25, r0
    9c3c:	11 24       	eor	r1, r1
    9c3e:	8c 0d       	add	r24, r12
    9c40:	9d 1d       	adc	r25, r13
    9c42:	88 0f       	add	r24, r24
    9c44:	99 1f       	adc	r25, r25
    9c46:	84 0d       	add	r24, r4
    9c48:	95 1d       	adc	r25, r5
    9c4a:	0e 94 f5 82 	call	0x105ea	; 0x105ea <__eerd_word_m2560>
    9c4e:	9c 01       	movw	r18, r24
    9c50:	44 27       	eor	r20, r20
    9c52:	37 fd       	sbrc	r19, 7
    9c54:	40 95       	com	r20
    9c56:	54 2f       	mov	r21, r20
    9c58:	2d 83       	std	Y+5, r18	; 0x05
    9c5a:	3e 83       	std	Y+6, r19	; 0x06
    9c5c:	4f 83       	std	Y+7, r20	; 0x07
    9c5e:	58 87       	std	Y+8, r21	; 0x08
	} while(x>Segm.x2 && i<Len);
    9c60:	26 15       	cp	r18, r6
    9c62:	37 05       	cpc	r19, r7
    9c64:	48 05       	cpc	r20, r8
    9c66:	59 05       	cpc	r21, r9
    9c68:	14 f4       	brge	.+4      	; 0x9c6e <EE_InterBrokLine+0xc2>
    9c6a:	10 17       	cp	r17, r16
    9c6c:	d0 f2       	brcs	.-76     	; 0x9c22 <EE_InterBrokLine+0x76>
	Segm.y1 = (int16_t)erw(TblOrdi[i-1]+Ordi);
    9c6e:	8d 85       	ldd	r24, Y+13	; 0x0d
    9c70:	08 2f       	mov	r16, r24
    9c72:	10 e0       	ldi	r17, 0x00	; 0
    9c74:	8e 85       	ldd	r24, Y+14	; 0x0e
    9c76:	e8 2e       	mov	r14, r24
    9c78:	ff 24       	eor	r15, r15
    9c7a:	08 94       	sec
    9c7c:	a1 08       	sbc	r10, r1
    9c7e:	b1 08       	sbc	r11, r1
    9c80:	a0 9e       	mul	r10, r16
    9c82:	c0 01       	movw	r24, r0
    9c84:	a1 9e       	mul	r10, r17
    9c86:	90 0d       	add	r25, r0
    9c88:	b0 9e       	mul	r11, r16
    9c8a:	90 0d       	add	r25, r0
    9c8c:	11 24       	eor	r1, r1
    9c8e:	08 94       	sec
    9c90:	a1 1c       	adc	r10, r1
    9c92:	b1 1c       	adc	r11, r1
    9c94:	8e 0d       	add	r24, r14
    9c96:	9f 1d       	adc	r25, r15
    9c98:	88 0f       	add	r24, r24
    9c9a:	99 1f       	adc	r25, r25
    9c9c:	82 0d       	add	r24, r2
    9c9e:	93 1d       	adc	r25, r3
    9ca0:	0e 94 f5 82 	call	0x105ea	; 0x105ea <__eerd_word_m2560>
    9ca4:	9a 87       	std	Y+10, r25	; 0x0a
    9ca6:	89 87       	std	Y+9, r24	; 0x09
    9ca8:	a0 9e       	mul	r10, r16
    9caa:	c0 01       	movw	r24, r0
    9cac:	a1 9e       	mul	r10, r17
    9cae:	90 0d       	add	r25, r0
    9cb0:	b0 9e       	mul	r11, r16
    9cb2:	90 0d       	add	r25, r0
    9cb4:	11 24       	eor	r1, r1
    9cb6:	8e 0d       	add	r24, r14
    9cb8:	9f 1d       	adc	r25, r15
    9cba:	88 0f       	add	r24, r24
    9cbc:	99 1f       	adc	r25, r25
    9cbe:	82 0d       	add	r24, r2
    9cc0:	93 1d       	adc	r25, r3
    9cc2:	0e 94 f5 82 	call	0x105ea	; 0x105ea <__eerd_word_m2560>
	Segm.y2 = (int16_t)erw(TblOrdi[i]+Ordi);
    9cc6:	9c 87       	std	Y+12, r25	; 0x0c
    9cc8:	8b 87       	std	Y+11, r24	; 0x0b
	return LineFunc(&Segm, x);
    9cca:	ce 01       	movw	r24, r28
    9ccc:	01 96       	adiw	r24, 0x01	; 1
    9cce:	b4 01       	movw	r22, r8
    9cd0:	a3 01       	movw	r20, r6
    9cd2:	0e 94 60 21 	call	0x42c0	; 0x42c0 <LineFunc>
}
    9cd6:	2e 96       	adiw	r28, 0x0e	; 14
    9cd8:	0f b6       	in	r0, 0x3f	; 63
    9cda:	f8 94       	cli
    9cdc:	de bf       	out	0x3e, r29	; 62
    9cde:	0f be       	out	0x3f, r0	; 63
    9ce0:	cd bf       	out	0x3d, r28	; 61
    9ce2:	cf 91       	pop	r28
    9ce4:	df 91       	pop	r29
    9ce6:	1f 91       	pop	r17
    9ce8:	0f 91       	pop	r16
    9cea:	ff 90       	pop	r15
    9cec:	ef 90       	pop	r14
    9cee:	df 90       	pop	r13
    9cf0:	cf 90       	pop	r12
    9cf2:	bf 90       	pop	r11
    9cf4:	af 90       	pop	r10
    9cf6:	9f 90       	pop	r9
    9cf8:	8f 90       	pop	r8
    9cfa:	7f 90       	pop	r7
    9cfc:	6f 90       	pop	r6
    9cfe:	5f 90       	pop	r5
    9d00:	4f 90       	pop	r4
    9d02:	3f 90       	pop	r3
    9d04:	2f 90       	pop	r2
    9d06:	08 95       	ret

00009d08 <MemCheck>:
}

// ~~~~~~~~~~~
uint8_t
MemCheck(void)
{
    9d08:	0f 93       	push	r16
    9d0a:	1f 93       	push	r17
//	uint8_t T = Timer32Stopp(TD_Mem);
//	if (T) {
//		StartTimer32(TD_Mem, 360000);
		if (!(MemFail &(1<<MemFail_Flash)) && CRC_Flash_calc()!=erw(&MemCheck_stor.CRC_Flash_stor))
    9d0c:	80 91 cf 08 	lds	r24, 0x08CF
    9d10:	80 ff       	sbrs	r24, 0
    9d12:	17 c0       	rjmp	.+46     	; 0x9d42 <MemCheck+0x3a>
			MemFail |=(1<<MemFail_Flash);
		if (!(MemFail &(1<<MemFail_EEPROM)) && CRC_EEPROM_calc()!=erw(&MemCheck_stor.CRC_EEPROM_stor))
    9d14:	81 ff       	sbrs	r24, 1
    9d16:	03 c0       	rjmp	.+6      	; 0x9d1e <MemCheck+0x16>
			MemFail |=(1<<MemFail_EEPROM);
//	}
//	return T && MemFail;
	return MemFail;
}
    9d18:	1f 91       	pop	r17
    9d1a:	0f 91       	pop	r16
    9d1c:	08 95       	ret
//	uint8_t T = Timer32Stopp(TD_Mem);
//	if (T) {
//		StartTimer32(TD_Mem, 360000);
		if (!(MemFail &(1<<MemFail_Flash)) && CRC_Flash_calc()!=erw(&MemCheck_stor.CRC_Flash_stor))
			MemFail |=(1<<MemFail_Flash);
		if (!(MemFail &(1<<MemFail_EEPROM)) && CRC_EEPROM_calc()!=erw(&MemCheck_stor.CRC_EEPROM_stor))
    9d1e:	0e 94 10 1a 	call	0x3420	; 0x3420 <CRC_EEPROM_calc>
    9d22:	8c 01       	movw	r16, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    9d24:	8a e3       	ldi	r24, 0x3A	; 58
    9d26:	91 e0       	ldi	r25, 0x01	; 1
    9d28:	0e 94 f5 82 	call	0x105ea	; 0x105ea <__eerd_word_m2560>
//	uint8_t T = Timer32Stopp(TD_Mem);
//	if (T) {
//		StartTimer32(TD_Mem, 360000);
		if (!(MemFail &(1<<MemFail_Flash)) && CRC_Flash_calc()!=erw(&MemCheck_stor.CRC_Flash_stor))
			MemFail |=(1<<MemFail_Flash);
		if (!(MemFail &(1<<MemFail_EEPROM)) && CRC_EEPROM_calc()!=erw(&MemCheck_stor.CRC_EEPROM_stor))
    9d2c:	08 17       	cp	r16, r24
    9d2e:	19 07       	cpc	r17, r25
    9d30:	d9 f0       	breq	.+54     	; 0x9d68 <MemCheck+0x60>
			MemFail |=(1<<MemFail_EEPROM);
    9d32:	80 91 cf 08 	lds	r24, 0x08CF
    9d36:	82 60       	ori	r24, 0x02	; 2
    9d38:	80 93 cf 08 	sts	0x08CF, r24
//	}
//	return T && MemFail;
	return MemFail;
}
    9d3c:	1f 91       	pop	r17
    9d3e:	0f 91       	pop	r16
    9d40:	08 95       	ret
MemCheck(void)
{
//	uint8_t T = Timer32Stopp(TD_Mem);
//	if (T) {
//		StartTimer32(TD_Mem, 360000);
		if (!(MemFail &(1<<MemFail_Flash)) && CRC_Flash_calc()!=erw(&MemCheck_stor.CRC_Flash_stor))
    9d42:	0e 94 f6 19 	call	0x33ec	; 0x33ec <CRC_Flash_calc>
    9d46:	8c 01       	movw	r16, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    9d48:	88 e3       	ldi	r24, 0x38	; 56
    9d4a:	91 e0       	ldi	r25, 0x01	; 1
    9d4c:	0e 94 f5 82 	call	0x105ea	; 0x105ea <__eerd_word_m2560>
MemCheck(void)
{
//	uint8_t T = Timer32Stopp(TD_Mem);
//	if (T) {
//		StartTimer32(TD_Mem, 360000);
		if (!(MemFail &(1<<MemFail_Flash)) && CRC_Flash_calc()!=erw(&MemCheck_stor.CRC_Flash_stor))
    9d50:	08 17       	cp	r16, r24
    9d52:	19 07       	cpc	r17, r25
    9d54:	31 f0       	breq	.+12     	; 0x9d62 <MemCheck+0x5a>
			MemFail |=(1<<MemFail_Flash);
    9d56:	80 91 cf 08 	lds	r24, 0x08CF
    9d5a:	81 60       	ori	r24, 0x01	; 1
    9d5c:	80 93 cf 08 	sts	0x08CF, r24
    9d60:	d9 cf       	rjmp	.-78     	; 0x9d14 <MemCheck+0xc>
    9d62:	80 91 cf 08 	lds	r24, 0x08CF
    9d66:	d6 cf       	rjmp	.-84     	; 0x9d14 <MemCheck+0xc>
    9d68:	80 91 cf 08 	lds	r24, 0x08CF
    9d6c:	d5 cf       	rjmp	.-86     	; 0x9d18 <MemCheck+0x10>

00009d6e <MemCheckMsg>:

// ~~~~~~~~~~~~~~
void
MemCheckMsg(void)
{
	if(MemCheck())
    9d6e:	0e 94 84 4e 	call	0x9d08	; 0x9d08 <MemCheck>
    9d72:	88 23       	and	r24, r24
    9d74:	09 f4       	brne	.+2      	; 0x9d78 <MemCheckMsg+0xa>
    9d76:	08 95       	ret

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    9d78:	80 91 cf 08 	lds	r24, 0x08CF
    9d7c:	e8 2f       	mov	r30, r24
    9d7e:	f0 e0       	ldi	r31, 0x00	; 0
    9d80:	ee 0f       	add	r30, r30
    9d82:	ff 1f       	adc	r31, r31
    9d84:	e9 5a       	subi	r30, 0xA9	; 169
    9d86:	f8 4e       	sbci	r31, 0xE8	; 232
		ShowMsg(prp(MsgErrMemo+MemFail));
    9d88:	85 91       	lpm	r24, Z+
    9d8a:	94 91       	lpm	r25, Z+
    9d8c:	0e 94 07 3d 	call	0x7a0e	; 0x7a0e <ShowMsg>
    9d90:	08 95       	ret

00009d92 <erb>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    9d92:	0e 94 e7 82 	call	0x105ce	; 0x105ce <__eerd_byte_m2560>
	//IntOn();
	return byte;
}
    9d96:	08 95       	ret

00009d98 <ThermChanWrong>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
ThermChanWrong(uint8_t ChanN)
{
    9d98:	ff 92       	push	r15
    9d9a:	0f 93       	push	r16
    9d9c:	1f 93       	push	r17
	return ThermWrong(prb(ThermFami+ChanN), erb(ThermType+ChanN), Temperature[ChanN]);
    9d9e:	08 2f       	mov	r16, r24
    9da0:	10 e0       	ldi	r17, 0x00	; 0

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    9da2:	f8 01       	movw	r30, r16
    9da4:	e3 54       	subi	r30, 0x43	; 67
    9da6:	f9 4f       	sbci	r31, 0xF9	; 249
    9da8:	f4 90       	lpm	r15, Z+
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    9daa:	c8 01       	movw	r24, r16
    9dac:	89 5e       	subi	r24, 0xE9	; 233
    9dae:	9e 4f       	sbci	r25, 0xFE	; 254
    9db0:	0e 94 e7 82 	call	0x105ce	; 0x105ce <__eerd_byte_m2560>
    9db4:	68 2f       	mov	r22, r24
    9db6:	00 0f       	add	r16, r16
    9db8:	11 1f       	adc	r17, r17
    9dba:	0d 5b       	subi	r16, 0xBD	; 189
    9dbc:	19 4f       	sbci	r17, 0xF9	; 249
    9dbe:	f8 01       	movw	r30, r16
    9dc0:	40 81       	ld	r20, Z
    9dc2:	51 81       	ldd	r21, Z+1	; 0x01
    9dc4:	8f 2d       	mov	r24, r15
    9dc6:	0e 94 27 40 	call	0x804e	; 0x804e <ThermWrong>
}
    9dca:	1f 91       	pop	r17
    9dcc:	0f 91       	pop	r16
    9dce:	ff 90       	pop	r15
    9dd0:	08 95       	ret

00009dd2 <ThermChan>:
}

// ~~~~~~~~~~~~~~~~~~~~~
void
ThermChan(uint8_t ChanN)
{
    9dd2:	8f 92       	push	r8
    9dd4:	9f 92       	push	r9
    9dd6:	af 92       	push	r10
    9dd8:	bf 92       	push	r11
    9dda:	cf 92       	push	r12
    9ddc:	df 92       	push	r13
    9dde:	ef 92       	push	r14
    9de0:	ff 92       	push	r15
    9de2:	0f 93       	push	r16
    9de4:	1f 93       	push	r17
    9de6:	cf 93       	push	r28
    9de8:	df 93       	push	r29
	if (ChanN>=TerReg)
    9dea:	86 30       	cpi	r24, 0x06	; 6
    9dec:	08 f0       	brcs	.+2      	; 0x9df0 <ThermChan+0x1e>
    9dee:	4c c0       	rjmp	.+152    	; 0x9e88 <ThermChan+0xb6>
		return;
    9df0:	e8 2e       	mov	r14, r24
    9df2:	ff 24       	eor	r15, r15
    9df4:	d7 01       	movw	r26, r14
    9df6:	aa 0f       	add	r26, r26
    9df8:	bb 1f       	adc	r27, r27
    9dfa:	a2 95       	swap	r26
    9dfc:	b2 95       	swap	r27
    9dfe:	b0 7f       	andi	r27, 0xF0	; 240
    9e00:	ba 27       	eor	r27, r26
    9e02:	a0 7f       	andi	r26, 0xF0	; 240
    9e04:	ba 27       	eor	r27, r26
    9e06:	fd 01       	movw	r30, r26
    9e08:	e5 5e       	subi	r30, 0xE5	; 229
    9e0a:	fa 4f       	sbci	r31, 0xFA	; 250
    9e0c:	2f e0       	ldi	r18, 0x0F	; 15
	for (uint8_t i=TerFiltLev*4-1; i; i--)
		TerBuf[ChanN][i] = TerBuf[ChanN][i-1];
    9e0e:	80 81       	ld	r24, Z
    9e10:	91 81       	ldd	r25, Z+1	; 0x01
    9e12:	93 83       	std	Z+3, r25	; 0x03
    9e14:	82 83       	std	Z+2, r24	; 0x02
void
ThermChan(uint8_t ChanN)
{
	if (ChanN>=TerReg)
		return;
	for (uint8_t i=TerFiltLev*4-1; i; i--)
    9e16:	21 50       	subi	r18, 0x01	; 1
    9e18:	32 97       	sbiw	r30, 0x02	; 2
    9e1a:	22 23       	and	r18, r18
    9e1c:	c1 f7       	brne	.-16     	; 0x9e0e <ThermChan+0x3c>
		TerBuf[ChanN][i] = TerBuf[ChanN][i-1];
	TerBuf[ChanN][0] = TerInput[ChanN];
    9e1e:	a1 50       	subi	r26, 0x01	; 1
    9e20:	bb 4f       	sbci	r27, 0xFB	; 251
    9e22:	47 01       	movw	r8, r14
    9e24:	88 0c       	add	r8, r8
    9e26:	99 1c       	adc	r9, r9
    9e28:	f4 01       	movw	r30, r8
    9e2a:	ed 52       	subi	r30, 0x2D	; 45
    9e2c:	f7 4f       	sbci	r31, 0xF7	; 247
    9e2e:	80 81       	ld	r24, Z
    9e30:	91 81       	ldd	r25, Z+1	; 0x01
    9e32:	8d 93       	st	X+, r24
    9e34:	9c 93       	st	X, r25

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    9e36:	f7 01       	movw	r30, r14
    9e38:	e3 54       	subi	r30, 0x43	; 67
    9e3a:	f9 4f       	sbci	r31, 0xF9	; 249
    9e3c:	c4 90       	lpm	r12, Z+
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    9e3e:	c7 01       	movw	r24, r14
    9e40:	89 5e       	subi	r24, 0xE9	; 233
    9e42:	9e 4f       	sbci	r25, 0xFE	; 254
    9e44:	0e 94 e7 82 	call	0x105ce	; 0x105ce <__eerd_byte_m2560>
    9e48:	18 2f       	mov	r17, r24
	int16_t Ter = Thermode(prb(ThermFami+ChanN), erb(ThermType+ChanN), DigiFilt(TerBuf[ChanN],TerFiltLev));
    9e4a:	c7 01       	movw	r24, r14
    9e4c:	88 0f       	add	r24, r24
    9e4e:	99 1f       	adc	r25, r25
    9e50:	82 95       	swap	r24
    9e52:	92 95       	swap	r25
    9e54:	90 7f       	andi	r25, 0xF0	; 240
    9e56:	98 27       	eor	r25, r24
    9e58:	80 7f       	andi	r24, 0xF0	; 240
    9e5a:	98 27       	eor	r25, r24
    9e5c:	81 50       	subi	r24, 0x01	; 1
    9e5e:	9b 4f       	sbci	r25, 0xFB	; 251
    9e60:	64 e0       	ldi	r22, 0x04	; 4
    9e62:	0e 94 75 4b 	call	0x96ea	; 0x96ea <DigiFilt>
    9e66:	ac 01       	movw	r20, r24
    9e68:	8c 2d       	mov	r24, r12
    9e6a:	61 2f       	mov	r22, r17
    9e6c:	0e 94 a7 3f 	call	0x7f4e	; 0x7f4e <Thermode>
    9e70:	ec 01       	movw	r28, r24
	if (Ter!=Therm_Off_Mark)
    9e72:	80 e8       	ldi	r24, 0x80	; 128
    9e74:	c0 30       	cpi	r28, 0x00	; 0
    9e76:	d8 07       	cpc	r29, r24
    9e78:	a1 f4       	brne	.+40     	; 0x9ea2 <ThermChan+0xd0>
		Ter = (Ter+(int8_t)erb(&ThermCorr[ChanN].D))*(erw(&ThermCorr[ChanN].A)/1000.0);
	Temperature[ChanN] = Ter;
    9e7a:	e3 e4       	ldi	r30, 0x43	; 67
    9e7c:	f6 e0       	ldi	r31, 0x06	; 6
    9e7e:	8e 0e       	add	r8, r30
    9e80:	9f 1e       	adc	r9, r31
    9e82:	f4 01       	movw	r30, r8
    9e84:	d1 83       	std	Z+1, r29	; 0x01
    9e86:	c0 83       	st	Z, r28
}
    9e88:	df 91       	pop	r29
    9e8a:	cf 91       	pop	r28
    9e8c:	1f 91       	pop	r17
    9e8e:	0f 91       	pop	r16
    9e90:	ff 90       	pop	r15
    9e92:	ef 90       	pop	r14
    9e94:	df 90       	pop	r13
    9e96:	cf 90       	pop	r12
    9e98:	bf 90       	pop	r11
    9e9a:	af 90       	pop	r10
    9e9c:	9f 90       	pop	r9
    9e9e:	8f 90       	pop	r8
    9ea0:	08 95       	ret
    9ea2:	64 01       	movw	r12, r8
    9ea4:	ce 0c       	add	r12, r14
    9ea6:	df 1c       	adc	r13, r15
    9ea8:	c6 01       	movw	r24, r12
    9eaa:	83 5e       	subi	r24, 0xE3	; 227
    9eac:	9e 4f       	sbci	r25, 0xFE	; 254
    9eae:	0e 94 e7 82 	call	0x105ce	; 0x105ce <__eerd_byte_m2560>
    9eb2:	e8 2e       	mov	r14, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    9eb4:	c6 01       	movw	r24, r12
    9eb6:	82 5e       	subi	r24, 0xE2	; 226
    9eb8:	9e 4f       	sbci	r25, 0xFE	; 254
    9eba:	0e 94 f5 82 	call	0x105ea	; 0x105ea <__eerd_word_m2560>
    9ebe:	5c 01       	movw	r10, r24
	for (uint8_t i=TerFiltLev*4-1; i; i--)
		TerBuf[ChanN][i] = TerBuf[ChanN][i-1];
	TerBuf[ChanN][0] = TerInput[ChanN];
	int16_t Ter = Thermode(prb(ThermFami+ChanN), erb(ThermType+ChanN), DigiFilt(TerBuf[ChanN],TerFiltLev));
	if (Ter!=Therm_Off_Mark)
		Ter = (Ter+(int8_t)erb(&ThermCorr[ChanN].D))*(erw(&ThermCorr[ChanN].A)/1000.0);
    9ec0:	ff 24       	eor	r15, r15
    9ec2:	e7 fc       	sbrc	r14, 7
    9ec4:	f0 94       	com	r15
    9ec6:	ec 0e       	add	r14, r28
    9ec8:	fd 1e       	adc	r15, r29
    9eca:	00 27       	eor	r16, r16
    9ecc:	f7 fc       	sbrc	r15, 7
    9ece:	00 95       	com	r16
    9ed0:	10 2f       	mov	r17, r16
    9ed2:	c8 01       	movw	r24, r16
    9ed4:	b7 01       	movw	r22, r14
    9ed6:	0e 94 d8 7d 	call	0xfbb0	; 0xfbb0 <__floatsisf>
    9eda:	7b 01       	movw	r14, r22
    9edc:	8c 01       	movw	r16, r24
    9ede:	cc 24       	eor	r12, r12
    9ee0:	dd 24       	eor	r13, r13
    9ee2:	c6 01       	movw	r24, r12
    9ee4:	b5 01       	movw	r22, r10
    9ee6:	0e 94 d6 7d 	call	0xfbac	; 0xfbac <__floatunsisf>
    9eea:	20 e0       	ldi	r18, 0x00	; 0
    9eec:	30 e0       	ldi	r19, 0x00	; 0
    9eee:	4a e7       	ldi	r20, 0x7A	; 122
    9ef0:	54 e4       	ldi	r21, 0x44	; 68
    9ef2:	0e 94 3e 82 	call	0x1047c	; 0x1047c <__divsf3>
    9ef6:	9b 01       	movw	r18, r22
    9ef8:	ac 01       	movw	r20, r24
    9efa:	c8 01       	movw	r24, r16
    9efc:	b7 01       	movw	r22, r14
    9efe:	0e 94 13 7e 	call	0xfc26	; 0xfc26 <__mulsf3>
    9f02:	0e 94 a6 82 	call	0x1054c	; 0x1054c <__fixsfsi>
    9f06:	eb 01       	movw	r28, r22
    9f08:	b8 cf       	rjmp	.-144    	; 0x9e7a <ThermChan+0xa8>

00009f0a <ThermInit>:
}

// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
ThermInit(uint8_t ChanN)
{
    9f0a:	ef 92       	push	r14
    9f0c:	ff 92       	push	r15
    9f0e:	0f 93       	push	r16
    9f10:	1f 93       	push	r17
    9f12:	cf 93       	push	r28
    9f14:	df 93       	push	r29
    9f16:	f8 2e       	mov	r15, r24
	if (ChanN<TerReg) {
    9f18:	85 e0       	ldi	r24, 0x05	; 5
    9f1a:	8f 15       	cp	r24, r15
    9f1c:	68 f1       	brcs	.+90     	; 0x9f78 <ThermInit+0x6e>
    9f1e:	8f 2d       	mov	r24, r15
    9f20:	90 e0       	ldi	r25, 0x00	; 0
    9f22:	8c 01       	movw	r16, r24
    9f24:	00 0f       	add	r16, r16
    9f26:	11 1f       	adc	r17, r17
    9f28:	f8 01       	movw	r30, r16
    9f2a:	ed 52       	subi	r30, 0x2D	; 45
    9f2c:	f7 4f       	sbci	r31, 0xF7	; 247
    9f2e:	c0 81       	ld	r28, Z
    9f30:	d1 81       	ldd	r29, Z+1	; 0x01
    9f32:	fc 01       	movw	r30, r24
    9f34:	ee 0f       	add	r30, r30
    9f36:	ff 1f       	adc	r31, r31
    9f38:	e2 95       	swap	r30
    9f3a:	f2 95       	swap	r31
    9f3c:	f0 7f       	andi	r31, 0xF0	; 240
    9f3e:	fe 27       	eor	r31, r30
    9f40:	e0 7f       	andi	r30, 0xF0	; 240
    9f42:	fe 27       	eor	r31, r30
    9f44:	e1 50       	subi	r30, 0x01	; 1
    9f46:	fb 4f       	sbci	r31, 0xFB	; 251
    9f48:	20 e0       	ldi	r18, 0x00	; 0
		for (uint8_t i=0; i<TerFiltLev*4; TerBuf[ChanN][i++]=TerInput[ChanN]);
    9f4a:	c1 93       	st	Z+, r28
    9f4c:	d1 93       	st	Z+, r29
    9f4e:	2f 5f       	subi	r18, 0xFF	; 255
    9f50:	20 31       	cpi	r18, 0x10	; 16
    9f52:	d9 f7       	brne	.-10     	; 0x9f4a <ThermInit+0x40>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    9f54:	fc 01       	movw	r30, r24
    9f56:	e3 54       	subi	r30, 0x43	; 67
    9f58:	f9 4f       	sbci	r31, 0xF9	; 249
    9f5a:	e4 90       	lpm	r14, Z+
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    9f5c:	89 5e       	subi	r24, 0xE9	; 233
    9f5e:	9e 4f       	sbci	r25, 0xFE	; 254
    9f60:	0e 94 e7 82 	call	0x105ce	; 0x105ce <__eerd_byte_m2560>
    9f64:	68 2f       	mov	r22, r24
		Temperature[ChanN] = Thermode(prb(ThermFami+ChanN), erb(ThermType+ChanN), TerInput[ChanN]);
    9f66:	8e 2d       	mov	r24, r14
    9f68:	ae 01       	movw	r20, r28
    9f6a:	0e 94 a7 3f 	call	0x7f4e	; 0x7f4e <Thermode>
    9f6e:	0d 5b       	subi	r16, 0xBD	; 189
    9f70:	19 4f       	sbci	r17, 0xF9	; 249
    9f72:	f8 01       	movw	r30, r16
    9f74:	91 83       	std	Z+1, r25	; 0x01
    9f76:	80 83       	st	Z, r24
    9f78:	80 e0       	ldi	r24, 0x00	; 0
    9f7a:	f5 e0       	ldi	r31, 0x05	; 5
    9f7c:	ff 12       	cpse	r15, r31
    9f7e:	81 e0       	ldi	r24, 0x01	; 1
	}
	return ChanN!=TerReg-1;
}
    9f80:	df 91       	pop	r29
    9f82:	cf 91       	pop	r28
    9f84:	1f 91       	pop	r17
    9f86:	0f 91       	pop	r16
    9f88:	ff 90       	pop	r15
    9f8a:	ef 90       	pop	r14
    9f8c:	08 95       	ret

00009f8e <DigitIn>:
}

// ~~~~~~~~~~
void
DigitIn(void)
{
    9f8e:	cf 93       	push	r28
    9f90:	df 93       	push	r29
	memcpy(DigInput.StateOld, DigInput.State, DI_Reg+DI_Reg_Ext);
    9f92:	ef ef       	ldi	r30, 0xFF	; 255
    9f94:	f6 e0       	ldi	r31, 0x06	; 6
    9f96:	df 01       	movw	r26, r30
    9f98:	13 97       	sbiw	r26, 0x03	; 3
    9f9a:	83 e0       	ldi	r24, 0x03	; 3
    9f9c:	0d 90       	ld	r0, X+
    9f9e:	01 92       	st	Z+, r0
    9fa0:	81 50       	subi	r24, 0x01	; 1
    9fa2:	e1 f7       	brne	.-8      	; 0x9f9c <DigitIn+0xe>
    9fa4:	84 e1       	ldi	r24, 0x14	; 20
    9fa6:	91 e0       	ldi	r25, 0x01	; 1
    9fa8:	0e 94 e7 82 	call	0x105ce	; 0x105ce <__eerd_byte_m2560>
	for (uint8_t i=0; i<DI_Reg; i++)
		DigInput.Status[i] = DigInput.State[i]^erb(DI_Invers+i);
    9fac:	90 91 fc 06 	lds	r25, 0x06FC
    9fb0:	98 27       	eor	r25, r24
    9fb2:	90 93 02 07 	sts	0x0702, r25
    9fb6:	85 e1       	ldi	r24, 0x15	; 21
    9fb8:	91 e0       	ldi	r25, 0x01	; 1
    9fba:	0e 94 e7 82 	call	0x105ce	; 0x105ce <__eerd_byte_m2560>
    9fbe:	90 91 fd 06 	lds	r25, 0x06FD
    9fc2:	98 27       	eor	r25, r24
    9fc4:	90 93 03 07 	sts	0x0703, r25
    9fc8:	86 e1       	ldi	r24, 0x16	; 22
    9fca:	91 e0       	ldi	r25, 0x01	; 1
    9fcc:	0e 94 e7 82 	call	0x105ce	; 0x105ce <__eerd_byte_m2560>
    9fd0:	90 91 fe 06 	lds	r25, 0x06FE
    9fd4:	98 27       	eor	r25, r24
    9fd6:	90 93 04 07 	sts	0x0704, r25
    9fda:	40 e0       	ldi	r20, 0x00	; 0
    9fdc:	50 e0       	ldi	r21, 0x00	; 0
#else
	static void
	DigitIn_Hard(void)
	{
		for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
			uint8_t Byte=D_N/8, Bit=1<<D_N%8;
    9fde:	a1 e0       	ldi	r26, 0x01	; 1
    9fe0:	b0 e0       	ldi	r27, 0x00	; 0
    9fe2:	1b c0       	rjmp	.+54     	; 0xa01a <DigitIn+0x8c>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    9fe4:	c9 01       	movw	r24, r18
    9fe6:	89 5b       	subi	r24, 0xB9	; 185
    9fe8:	94 4d       	sbci	r25, 0xD4	; 212
    9fea:	fc 01       	movw	r30, r24
    9fec:	c5 91       	lpm	r28, Z+
    9fee:	d4 91       	lpm	r29, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    9ff0:	27 5b       	subi	r18, 0xB7	; 183
    9ff2:	34 4d       	sbci	r19, 0xD4	; 212
    9ff4:	f9 01       	movw	r30, r18
    9ff6:	84 91       	lpm	r24, Z+
			if(prb(&DI_M[D_N].Inversion)){
				if (*(uint8_t*)prp(&DI_M[D_N].PIN) & prb(&DI_M[D_N].P))
    9ff8:	98 81       	ld	r25, Y
    9ffa:	89 23       	and	r24, r25
    9ffc:	09 f4       	brne	.+2      	; 0xa000 <DigitIn+0x72>
    9ffe:	3d c0       	rjmp	.+122    	; 0xa07a <DigitIn+0xec>
			}
			else{
				if (*(uint8_t*)prp(&DI_M[D_N].PIN) & prb(&DI_M[D_N].P))
					DigInput.State[Byte] &=~Bit;
				else
					DigInput.State[Byte]  |=Bit;
    a000:	e7 2f       	mov	r30, r23
    a002:	f0 e0       	ldi	r31, 0x00	; 0
    a004:	e4 50       	subi	r30, 0x04	; 4
    a006:	f9 4f       	sbci	r31, 0xF9	; 249
    a008:	80 81       	ld	r24, Z
    a00a:	86 2b       	or	r24, r22
    a00c:	80 83       	st	Z, r24
    a00e:	4f 5f       	subi	r20, 0xFF	; 255
    a010:	5f 4f       	sbci	r21, 0xFF	; 255
	void DigitIn_Hard(void);
#else
	static void
	DigitIn_Hard(void)
	{
		for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
    a012:	42 31       	cpi	r20, 0x12	; 18
    a014:	51 05       	cpc	r21, r1
    a016:	09 f4       	brne	.+2      	; 0xa01a <DigitIn+0x8c>
    a018:	3e c0       	rjmp	.+124    	; 0xa096 <DigitIn+0x108>
			uint8_t Byte=D_N/8, Bit=1<<D_N%8;
    a01a:	74 2f       	mov	r23, r20
    a01c:	76 95       	lsr	r23
    a01e:	76 95       	lsr	r23
    a020:	76 95       	lsr	r23
    a022:	ca 01       	movw	r24, r20
    a024:	87 70       	andi	r24, 0x07	; 7
    a026:	90 70       	andi	r25, 0x00	; 0
    a028:	9d 01       	movw	r18, r26
    a02a:	02 c0       	rjmp	.+4      	; 0xa030 <DigitIn+0xa2>
    a02c:	22 0f       	add	r18, r18
    a02e:	33 1f       	adc	r19, r19
    a030:	8a 95       	dec	r24
    a032:	e2 f7       	brpl	.-8      	; 0xa02c <DigitIn+0x9e>
    a034:	62 2f       	mov	r22, r18
    a036:	9a 01       	movw	r18, r20
    a038:	22 0f       	add	r18, r18
    a03a:	33 1f       	adc	r19, r19
    a03c:	22 0f       	add	r18, r18
    a03e:	33 1f       	adc	r19, r19
    a040:	22 0f       	add	r18, r18
    a042:	33 1f       	adc	r19, r19
    a044:	f9 01       	movw	r30, r18
    a046:	e6 5b       	subi	r30, 0xB6	; 182
    a048:	f4 4d       	sbci	r31, 0xD4	; 212
    a04a:	e4 91       	lpm	r30, Z+
			if(prb(&DI_M[D_N].Inversion)){
    a04c:	ee 23       	and	r30, r30
    a04e:	09 f0       	breq	.+2      	; 0xa052 <DigitIn+0xc4>
    a050:	c9 cf       	rjmp	.-110    	; 0x9fe4 <DigitIn+0x56>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    a052:	ca 01       	movw	r24, r20
    a054:	88 0f       	add	r24, r24
    a056:	99 1f       	adc	r25, r25
    a058:	88 0f       	add	r24, r24
    a05a:	99 1f       	adc	r25, r25
    a05c:	88 0f       	add	r24, r24
    a05e:	99 1f       	adc	r25, r25
    a060:	89 5b       	subi	r24, 0xB9	; 185
    a062:	94 4d       	sbci	r25, 0xD4	; 212
    a064:	fc 01       	movw	r30, r24
    a066:	c5 91       	lpm	r28, Z+
    a068:	d4 91       	lpm	r29, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    a06a:	27 5b       	subi	r18, 0xB7	; 183
    a06c:	34 4d       	sbci	r19, 0xD4	; 212
    a06e:	f9 01       	movw	r30, r18
    a070:	84 91       	lpm	r24, Z+
					DigInput.State[Byte] |=Bit;
				else
					DigInput.State[Byte] &=~Bit;
			}
			else{
				if (*(uint8_t*)prp(&DI_M[D_N].PIN) & prb(&DI_M[D_N].P))
    a072:	98 81       	ld	r25, Y
    a074:	89 23       	and	r24, r25
    a076:	09 f4       	brne	.+2      	; 0xa07a <DigitIn+0xec>
    a078:	c3 cf       	rjmp	.-122    	; 0xa000 <DigitIn+0x72>
					DigInput.State[Byte] &=~Bit;
    a07a:	e7 2f       	mov	r30, r23
    a07c:	f0 e0       	ldi	r31, 0x00	; 0
    a07e:	e4 50       	subi	r30, 0x04	; 4
    a080:	f9 4f       	sbci	r31, 0xF9	; 249
    a082:	60 95       	com	r22
    a084:	80 81       	ld	r24, Z
    a086:	68 23       	and	r22, r24
    a088:	60 83       	st	Z, r22
				else
					DigInput.State[Byte]  |=Bit;
    a08a:	4f 5f       	subi	r20, 0xFF	; 255
    a08c:	5f 4f       	sbci	r21, 0xFF	; 255
	void DigitIn_Hard(void);
#else
	static void
	DigitIn_Hard(void)
	{
		for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
    a08e:	42 31       	cpi	r20, 0x12	; 18
    a090:	51 05       	cpc	r21, r1
    a092:	09 f0       	breq	.+2      	; 0xa096 <DigitIn+0x108>
    a094:	c2 cf       	rjmp	.-124    	; 0xa01a <DigitIn+0x8c>
			DigInput.State[j]		= (DigInput_Ext)[i];
			DigInput.Status[j]	= (DigInput_Ext)[i+DI_Reg_Ext];
			IntOn();
		}
	#endif
}
    a096:	df 91       	pop	r29
    a098:	cf 91       	pop	r28
    a09a:	08 95       	ret

0000a09c <Field2Buf>:
	else return 0;
}
// ~~~~~~~~~~~~~~~~~~~~~~~
static void
Field2Buf(OutField *Field)
{
    a09c:	6f 92       	push	r6
    a09e:	7f 92       	push	r7
    a0a0:	8f 92       	push	r8
    a0a2:	9f 92       	push	r9
    a0a4:	af 92       	push	r10
    a0a6:	bf 92       	push	r11
    a0a8:	cf 92       	push	r12
    a0aa:	df 92       	push	r13
    a0ac:	ef 92       	push	r14
    a0ae:	ff 92       	push	r15
    a0b0:	0f 93       	push	r16
    a0b2:	1f 93       	push	r17
    a0b4:	df 93       	push	r29
    a0b6:	cf 93       	push	r28
    a0b8:	cd b7       	in	r28, 0x3d	; 61
    a0ba:	de b7       	in	r29, 0x3e	; 62
    a0bc:	6f 97       	sbiw	r28, 0x1f	; 31
    a0be:	0f b6       	in	r0, 0x3f	; 63
    a0c0:	f8 94       	cli
    a0c2:	de bf       	out	0x3e, r29	; 62
    a0c4:	0f be       	out	0x3f, r0	; 63
    a0c6:	cd bf       	out	0x3d, r28	; 61
    a0c8:	7c 01       	movw	r14, r24

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    a0ca:	fc 01       	movw	r30, r24
    a0cc:	31 96       	adiw	r30, 0x01	; 1
    a0ce:	c5 90       	lpm	r12, Z+
    a0d0:	d4 90       	lpm	r13, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    a0d2:	bf e0       	ldi	r27, 0x0F	; 15
    a0d4:	8b 2e       	mov	r8, r27
    a0d6:	91 2c       	mov	r9, r1
    a0d8:	88 0e       	add	r8, r24
    a0da:	99 1e       	adc	r9, r25
    a0dc:	f4 01       	movw	r30, r8
    a0de:	24 91       	lpm	r18, Z+
	void *Var = prp(&Field->Var);
	uint8_t BitN=prb(&Field->Prec), Mask=1<<BitN%8, *BitVar=(uint8_t*)Var+BitN/8;
    a0e0:	32 2f       	mov	r19, r18
    a0e2:	37 70       	andi	r19, 0x07	; 7
    a0e4:	81 e0       	ldi	r24, 0x01	; 1
    a0e6:	90 e0       	ldi	r25, 0x00	; 0
    a0e8:	18 2f       	mov	r17, r24
    a0ea:	01 c0       	rjmp	.+2      	; 0xa0ee <Field2Buf+0x52>
    a0ec:	11 0f       	add	r17, r17
    a0ee:	3a 95       	dec	r19
    a0f0:	ea f7       	brpl	.-6      	; 0xa0ec <Field2Buf+0x50>
    a0f2:	26 95       	lsr	r18
    a0f4:	26 95       	lsr	r18
    a0f6:	26 95       	lsr	r18
    a0f8:	56 01       	movw	r10, r12
    a0fa:	a2 0e       	add	r10, r18
    a0fc:	b1 1c       	adc	r11, r1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    a0fe:	a7 e0       	ldi	r26, 0x07	; 7
    a100:	6a 2e       	mov	r6, r26
    a102:	71 2c       	mov	r7, r1
    a104:	6e 0c       	add	r6, r14
    a106:	7f 1c       	adc	r7, r15
    a108:	f3 01       	movw	r30, r6
    a10a:	65 91       	lpm	r22, Z+
    a10c:	75 91       	lpm	r23, Z+
    a10e:	85 91       	lpm	r24, Z+
    a110:	94 91       	lpm	r25, Z+
	uint8_t Pos=Log10(prd(&Field->Max));
    a112:	0e 94 23 21 	call	0x4246	; 0x4246 <Log10>
    a116:	08 2f       	mov	r16, r24

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    a118:	f7 01       	movw	r30, r14
    a11a:	84 91       	lpm	r24, Z+
	uint8_t Oldstyle = 0;

	switch(prb(&Field->Type)) {
    a11c:	e8 2f       	mov	r30, r24
    a11e:	f0 e0       	ldi	r31, 0x00	; 0
    a120:	e1 32       	cpi	r30, 0x21	; 33
    a122:	f1 05       	cpc	r31, r1
    a124:	08 f4       	brcc	.+2      	; 0xa128 <Field2Buf+0x8c>
    a126:	6e c0       	rjmp	.+220    	; 0xa204 <Field2Buf+0x168>
		F_Buf = (erb(BitVar) &Mask) > 0;
		Oldstyle = 1;
		break;
	}

	Minus=0;
    a128:	10 92 fd 04 	sts	0x04FD, r1
	if(Oldstyle) return;

	InitBufStr(Field);
    a12c:	c7 01       	movw	r24, r14
    a12e:	0e 94 85 3c 	call	0x790a	; 0x790a <InitBufStr>
	CurrFieldSize = GetCurrFieldSize();
    a132:	0e 94 47 3d 	call	0x7a8e	; 0x7a8e <GetCurrFieldSize>
    a136:	48 2f       	mov	r20, r24
    a138:	80 93 7a 07 	sts	0x077A, r24
	CurrPos = CurrFieldSize - 1;
    a13c:	41 50       	subi	r20, 0x01	; 1
    a13e:	40 93 d7 02 	sts	0x02D7, r20
    a142:	4f 5f       	subi	r20, 0xFF	; 255
	float fTemp;
	T_Param Param;
	Param.Size = CurrFieldSize;
    a144:	48 87       	std	Y+8, r20	; 0x08
	Param.Pos = BufStr;
    a146:	81 ec       	ldi	r24, 0xC1	; 193
    a148:	95 e0       	ldi	r25, 0x05	; 5
    a14a:	9e 83       	std	Y+6, r25	; 0x06
    a14c:	8d 83       	std	Y+5, r24	; 0x05
    a14e:	f4 01       	movw	r30, r8
    a150:	84 91       	lpm	r24, Z+
	Param.Prec = prb(&Field->Prec);
    a152:	8f 83       	std	Y+7, r24	; 0x07
	Param.Txt = NULL;
    a154:	1a 86       	std	Y+10, r1	; 0x0a
    a156:	19 86       	std	Y+9, r1	; 0x09
    a158:	f7 01       	movw	r30, r14
    a15a:	84 91       	lpm	r24, Z+

	switch(prb(&Field->Type)) {
    a15c:	85 31       	cpi	r24, 0x15	; 21
    a15e:	09 f4       	brne	.+2      	; 0xa162 <Field2Buf+0xc6>
    a160:	74 c1       	rjmp	.+744    	; 0xa44a <Field2Buf+0x3ae>
    a162:	86 31       	cpi	r24, 0x16	; 22
    a164:	08 f4       	brcc	.+2      	; 0xa168 <Field2Buf+0xcc>
    a166:	56 c1       	rjmp	.+684    	; 0xa414 <Field2Buf+0x378>
    a168:	8b 31       	cpi	r24, 0x1B	; 27
    a16a:	09 f4       	brne	.+2      	; 0xa16e <Field2Buf+0xd2>
    a16c:	fe c1       	rjmp	.+1020   	; 0xa56a <Field2Buf+0x4ce>
    a16e:	8c 31       	cpi	r24, 0x1C	; 28
    a170:	08 f0       	brcs	.+2      	; 0xa174 <Field2Buf+0xd8>
    a172:	b7 c1       	rjmp	.+878    	; 0xa4e2 <Field2Buf+0x446>
    a174:	89 31       	cpi	r24, 0x19	; 25
    a176:	09 f4       	brne	.+2      	; 0xa17a <Field2Buf+0xde>
    a178:	92 c1       	rjmp	.+804    	; 0xa49e <Field2Buf+0x402>
    a17a:	8a 31       	cpi	r24, 0x1A	; 26
    a17c:	09 f0       	breq	.+2      	; 0xa180 <Field2Buf+0xe4>
    a17e:	5b c0       	rjmp	.+182    	; 0xa236 <Field2Buf+0x19a>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    a180:	7e 01       	movw	r14, r28
    a182:	08 94       	sec
    a184:	e1 1c       	adc	r14, r1
    a186:	f1 1c       	adc	r15, r1
    a188:	c7 01       	movw	r24, r14
    a18a:	b6 01       	movw	r22, r12
    a18c:	44 e0       	ldi	r20, 0x04	; 4
    a18e:	50 e0       	ldi	r21, 0x00	; 0
    a190:	0e 94 d7 82 	call	0x105ae	; 0x105ae <__eerd_block_m2560>
		Put_FFVal(*(float*)Var, &Param);
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
		break;
	case EE_FFloat:
		erbl(&fTemp, Var, 4);
		Put_FFVal(fTemp, &Param);
    a194:	69 81       	ldd	r22, Y+1	; 0x01
    a196:	7a 81       	ldd	r23, Y+2	; 0x02
    a198:	8b 81       	ldd	r24, Y+3	; 0x03
    a19a:	9c 81       	ldd	r25, Y+4	; 0x04
    a19c:	8e 01       	movw	r16, r28
    a19e:	0b 5f       	subi	r16, 0xFB	; 251
    a1a0:	1f 4f       	sbci	r17, 0xFF	; 255
    a1a2:	a8 01       	movw	r20, r16
    a1a4:	0e 94 33 44 	call	0x8866	; 0x8866 <Put_FFVal>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
    a1a8:	8e ea       	ldi	r24, 0xAE	; 174
    a1aa:	96 e0       	ldi	r25, 0x06	; 6
    a1ac:	60 91 c1 05 	lds	r22, 0x05C1
    a1b0:	0e 94 fc 40 	call	0x81f8	; 0x81f8 <GetMultiSymbol>
    a1b4:	80 93 f2 04 	sts	0x04F2, r24
	case GFloat:
		Put_GFVal(*(float*)Var, &Param);
    a1b8:	f6 01       	movw	r30, r12
    a1ba:	60 81       	ld	r22, Z
    a1bc:	71 81       	ldd	r23, Z+1	; 0x01
    a1be:	82 81       	ldd	r24, Z+2	; 0x02
    a1c0:	93 81       	ldd	r25, Z+3	; 0x03
    a1c2:	a8 01       	movw	r20, r16
    a1c4:	0e 94 b9 43 	call	0x8772	; 0x8772 <Put_GFVal>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
    a1c8:	8e ea       	ldi	r24, 0xAE	; 174
    a1ca:	96 e0       	ldi	r25, 0x06	; 6
    a1cc:	60 91 c1 05 	lds	r22, 0x05C1
    a1d0:	0e 94 fc 40 	call	0x81f8	; 0x81f8 <GetMultiSymbol>
    a1d4:	80 93 f2 04 	sts	0x04F2, r24
    a1d8:	c7 01       	movw	r24, r14
    a1da:	b6 01       	movw	r22, r12
    a1dc:	44 e0       	ldi	r20, 0x04	; 4
    a1de:	50 e0       	ldi	r21, 0x00	; 0
    a1e0:	0e 94 d7 82 	call	0x105ae	; 0x105ae <__eerd_block_m2560>
	case EE_GFloat:
		erbl(&fTemp, Var, 4);
		Put_GFVal(fTemp, &Param);
    a1e4:	69 81       	ldd	r22, Y+1	; 0x01
    a1e6:	7a 81       	ldd	r23, Y+2	; 0x02
    a1e8:	8b 81       	ldd	r24, Y+3	; 0x03
    a1ea:	9c 81       	ldd	r25, Y+4	; 0x04
    a1ec:	a8 01       	movw	r20, r16
    a1ee:	0e 94 b9 43 	call	0x8772	; 0x8772 <Put_GFVal>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
    a1f2:	8e ea       	ldi	r24, 0xAE	; 174
    a1f4:	96 e0       	ldi	r25, 0x06	; 6
    a1f6:	60 91 c1 05 	lds	r22, 0x05C1
    a1fa:	0e 94 fc 40 	call	0x81f8	; 0x81f8 <GetMultiSymbol>
    a1fe:	80 93 f2 04 	sts	0x04F2, r24
    a202:	19 c0       	rjmp	.+50     	; 0xa236 <Field2Buf+0x19a>
	void *Var = prp(&Field->Var);
	uint8_t BitN=prb(&Field->Prec), Mask=1<<BitN%8, *BitVar=(uint8_t*)Var+BitN/8;
	uint8_t Pos=Log10(prd(&Field->Max));
	uint8_t Oldstyle = 0;

	switch(prb(&Field->Type)) {
    a204:	ee 58       	subi	r30, 0x8E	; 142
    a206:	ff 4f       	sbci	r31, 0xFF	; 255
    a208:	ee 0f       	add	r30, r30
    a20a:	ff 1f       	adc	r31, r31
    a20c:	05 90       	lpm	r0, Z+
    a20e:	f4 91       	lpm	r31, Z+
    a210:	e0 2d       	mov	r30, r0
    a212:	19 94       	eijmp
	case Byte: case z_Byte:
		F_Buf = *(uint8_t*)Var;
    a214:	f6 01       	movw	r30, r12
    a216:	80 81       	ld	r24, Z
    a218:	90 e0       	ldi	r25, 0x00	; 0
    a21a:	a0 e0       	ldi	r26, 0x00	; 0
    a21c:	b0 e0       	ldi	r27, 0x00	; 0
    a21e:	80 93 f5 04 	sts	0x04F5, r24
    a222:	90 93 f6 04 	sts	0x04F6, r25
    a226:	a0 93 f7 04 	sts	0x04F7, r26
    a22a:	b0 93 f8 04 	sts	0x04F8, r27
		CurrPos = Pos;
    a22e:	00 93 d7 02 	sts	0x02D7, r16
		F_Buf = (erb(BitVar) &Mask) > 0;
		Oldstyle = 1;
		break;
	}

	Minus=0;
    a232:	10 92 fd 04 	sts	0x04FD, r1
				MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[0]);
			else MultiSymbol = GetMultiSymbol(Symbols_P, BufStr[0]);
		}
		break;
	}
}
    a236:	6f 96       	adiw	r28, 0x1f	; 31
    a238:	0f b6       	in	r0, 0x3f	; 63
    a23a:	f8 94       	cli
    a23c:	de bf       	out	0x3e, r29	; 62
    a23e:	0f be       	out	0x3f, r0	; 63
    a240:	cd bf       	out	0x3d, r28	; 61
    a242:	cf 91       	pop	r28
    a244:	df 91       	pop	r29
    a246:	1f 91       	pop	r17
    a248:	0f 91       	pop	r16
    a24a:	ff 90       	pop	r15
    a24c:	ef 90       	pop	r14
    a24e:	df 90       	pop	r13
    a250:	cf 90       	pop	r12
    a252:	bf 90       	pop	r11
    a254:	af 90       	pop	r10
    a256:	9f 90       	pop	r9
    a258:	8f 90       	pop	r8
    a25a:	7f 90       	pop	r7
    a25c:	6f 90       	pop	r6
    a25e:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    a260:	c6 01       	movw	r24, r12
    a262:	0e 94 e7 82 	call	0x105ce	; 0x105ce <__eerd_byte_m2560>
		sF_Buf = *(int8_t*)Var;
		CurrPos = Pos+1;
		Oldstyle = 1;
		break;
	case EE_Byte: case z_EE_Byte:
		F_Buf = erb((uint8_t*)Var);
    a266:	90 e0       	ldi	r25, 0x00	; 0
    a268:	a0 e0       	ldi	r26, 0x00	; 0
    a26a:	b0 e0       	ldi	r27, 0x00	; 0
    a26c:	80 93 f5 04 	sts	0x04F5, r24
    a270:	90 93 f6 04 	sts	0x04F6, r25
    a274:	a0 93 f7 04 	sts	0x04F7, r26
    a278:	b0 93 f8 04 	sts	0x04F8, r27
		CurrPos = Pos;
    a27c:	00 93 d7 02 	sts	0x02D7, r16
    a280:	d8 cf       	rjmp	.-80     	; 0xa232 <Field2Buf+0x196>
		F_Buf = *(uint8_t*)Var;
		CurrPos = Pos;
		Oldstyle = 1;
		break;
	case s_Byte:
		sF_Buf = *(int8_t*)Var;
    a282:	f6 01       	movw	r30, r12
    a284:	80 81       	ld	r24, Z
    a286:	99 27       	eor	r25, r25
    a288:	87 fd       	sbrc	r24, 7
    a28a:	90 95       	com	r25
    a28c:	a9 2f       	mov	r26, r25
    a28e:	b9 2f       	mov	r27, r25
    a290:	80 93 f9 04 	sts	0x04F9, r24
    a294:	90 93 fa 04 	sts	0x04FA, r25
    a298:	a0 93 fb 04 	sts	0x04FB, r26
    a29c:	b0 93 fc 04 	sts	0x04FC, r27
		CurrPos = Pos+1;
    a2a0:	0f 5f       	subi	r16, 0xFF	; 255
    a2a2:	00 93 d7 02 	sts	0x02D7, r16
    a2a6:	c5 cf       	rjmp	.-118    	; 0xa232 <Field2Buf+0x196>
    a2a8:	c6 01       	movw	r24, r12
    a2aa:	0e 94 e7 82 	call	0x105ce	; 0x105ce <__eerd_byte_m2560>
		F_Buf = erb((uint8_t*)Var);
		CurrPos = Pos;
		Oldstyle = 1;
		break;
	case s_EE_Byte:
		sF_Buf = (int8_t)erb((uint8_t*)Var);
    a2ae:	99 27       	eor	r25, r25
    a2b0:	87 fd       	sbrc	r24, 7
    a2b2:	90 95       	com	r25
    a2b4:	a9 2f       	mov	r26, r25
    a2b6:	b9 2f       	mov	r27, r25
    a2b8:	80 93 f9 04 	sts	0x04F9, r24
    a2bc:	90 93 fa 04 	sts	0x04FA, r25
    a2c0:	a0 93 fb 04 	sts	0x04FB, r26
    a2c4:	b0 93 fc 04 	sts	0x04FC, r27
		CurrPos = Pos+1;
    a2c8:	0f 5f       	subi	r16, 0xFF	; 255
    a2ca:	00 93 d7 02 	sts	0x02D7, r16
    a2ce:	b1 cf       	rjmp	.-158    	; 0xa232 <Field2Buf+0x196>
		Oldstyle = 1;
		break;

	case Word: case z_Word:
		F_Buf = *(uint16_t*)Var;
    a2d0:	f6 01       	movw	r30, r12
    a2d2:	80 81       	ld	r24, Z
    a2d4:	91 81       	ldd	r25, Z+1	; 0x01
    a2d6:	a0 e0       	ldi	r26, 0x00	; 0
    a2d8:	b0 e0       	ldi	r27, 0x00	; 0
    a2da:	80 93 f5 04 	sts	0x04F5, r24
    a2de:	90 93 f6 04 	sts	0x04F6, r25
    a2e2:	a0 93 f7 04 	sts	0x04F7, r26
    a2e6:	b0 93 f8 04 	sts	0x04F8, r27
		CurrPos = Pos;
    a2ea:	00 93 d7 02 	sts	0x02D7, r16
    a2ee:	a1 cf       	rjmp	.-190    	; 0xa232 <Field2Buf+0x196>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    a2f0:	c6 01       	movw	r24, r12
    a2f2:	0e 94 f5 82 	call	0x105ea	; 0x105ea <__eerd_word_m2560>
		Oldstyle = 1;
		break;
	case EE_Word: case z_EE_Word:
		F_Buf = erw((uint16_t*)Var);
    a2f6:	a0 e0       	ldi	r26, 0x00	; 0
    a2f8:	b0 e0       	ldi	r27, 0x00	; 0
    a2fa:	80 93 f5 04 	sts	0x04F5, r24
    a2fe:	90 93 f6 04 	sts	0x04F6, r25
    a302:	a0 93 f7 04 	sts	0x04F7, r26
    a306:	b0 93 f8 04 	sts	0x04F8, r27
		CurrPos = Pos;
    a30a:	00 93 d7 02 	sts	0x02D7, r16
    a30e:	91 cf       	rjmp	.-222    	; 0xa232 <Field2Buf+0x196>
		Oldstyle = 1;
		break;
	case s_Word:
		sF_Buf = *(int16_t*)Var;
    a310:	f6 01       	movw	r30, r12
    a312:	80 81       	ld	r24, Z
    a314:	91 81       	ldd	r25, Z+1	; 0x01
    a316:	aa 27       	eor	r26, r26
    a318:	97 fd       	sbrc	r25, 7
    a31a:	a0 95       	com	r26
    a31c:	ba 2f       	mov	r27, r26
    a31e:	80 93 f9 04 	sts	0x04F9, r24
    a322:	90 93 fa 04 	sts	0x04FA, r25
    a326:	a0 93 fb 04 	sts	0x04FB, r26
    a32a:	b0 93 fc 04 	sts	0x04FC, r27
		CurrPos = Pos+1;
    a32e:	0f 5f       	subi	r16, 0xFF	; 255
    a330:	00 93 d7 02 	sts	0x02D7, r16
    a334:	7e cf       	rjmp	.-260    	; 0xa232 <Field2Buf+0x196>
    a336:	c6 01       	movw	r24, r12
    a338:	0e 94 f5 82 	call	0x105ea	; 0x105ea <__eerd_word_m2560>
		Oldstyle = 1;
		break;
	case s_EE_Word:
		sF_Buf = (int16_t)erw((uint16_t*)Var);
    a33c:	aa 27       	eor	r26, r26
    a33e:	97 fd       	sbrc	r25, 7
    a340:	a0 95       	com	r26
    a342:	ba 2f       	mov	r27, r26
    a344:	80 93 f9 04 	sts	0x04F9, r24
    a348:	90 93 fa 04 	sts	0x04FA, r25
    a34c:	a0 93 fb 04 	sts	0x04FB, r26
    a350:	b0 93 fc 04 	sts	0x04FC, r27
		CurrPos = Pos+1;
    a354:	0f 5f       	subi	r16, 0xFF	; 255
    a356:	00 93 d7 02 	sts	0x02D7, r16
    a35a:	6b cf       	rjmp	.-298    	; 0xa232 <Field2Buf+0x196>
		Oldstyle = 1;
		break;
	case c_Word: case zc_Word:
		F_Buf = *(uint16_t*)Var;
    a35c:	f6 01       	movw	r30, r12
    a35e:	80 81       	ld	r24, Z
    a360:	91 81       	ldd	r25, Z+1	; 0x01
    a362:	a0 e0       	ldi	r26, 0x00	; 0
    a364:	b0 e0       	ldi	r27, 0x00	; 0
    a366:	80 93 f5 04 	sts	0x04F5, r24
    a36a:	90 93 f6 04 	sts	0x04F6, r25
    a36e:	a0 93 f7 04 	sts	0x04F7, r26
    a372:	b0 93 f8 04 	sts	0x04F8, r27
    a376:	5d cf       	rjmp	.-326    	; 0xa232 <Field2Buf+0x196>
		Oldstyle = 1;
		break;

	case Enum:
		F_Buf = *(uint8_t*)Var;
    a378:	f6 01       	movw	r30, r12
    a37a:	80 81       	ld	r24, Z
    a37c:	90 e0       	ldi	r25, 0x00	; 0
    a37e:	a0 e0       	ldi	r26, 0x00	; 0
    a380:	b0 e0       	ldi	r27, 0x00	; 0
    a382:	80 93 f5 04 	sts	0x04F5, r24
    a386:	90 93 f6 04 	sts	0x04F6, r25
    a38a:	a0 93 f7 04 	sts	0x04F7, r26
    a38e:	b0 93 f8 04 	sts	0x04F8, r27
    a392:	4f cf       	rjmp	.-354    	; 0xa232 <Field2Buf+0x196>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    a394:	c6 01       	movw	r24, r12
    a396:	0e 94 e7 82 	call	0x105ce	; 0x105ce <__eerd_byte_m2560>
		Oldstyle = 1;
		break;
	case EE_Enum:
		F_Buf = erb((uint8_t*)Var);
    a39a:	90 e0       	ldi	r25, 0x00	; 0
    a39c:	a0 e0       	ldi	r26, 0x00	; 0
    a39e:	b0 e0       	ldi	r27, 0x00	; 0
    a3a0:	80 93 f5 04 	sts	0x04F5, r24
    a3a4:	90 93 f6 04 	sts	0x04F6, r25
    a3a8:	a0 93 f7 04 	sts	0x04F7, r26
    a3ac:	b0 93 f8 04 	sts	0x04F8, r27
    a3b0:	40 cf       	rjmp	.-384    	; 0xa232 <Field2Buf+0x196>
		Oldstyle = 1;
		break;
	case Bit:
		F_Buf = (*BitVar &Mask) > 0;
    a3b2:	20 e0       	ldi	r18, 0x00	; 0
    a3b4:	30 e0       	ldi	r19, 0x00	; 0
    a3b6:	40 e0       	ldi	r20, 0x00	; 0
    a3b8:	50 e0       	ldi	r21, 0x00	; 0
    a3ba:	f5 01       	movw	r30, r10
    a3bc:	80 81       	ld	r24, Z
    a3be:	81 23       	and	r24, r17
    a3c0:	21 f5       	brne	.+72     	; 0xa40a <Field2Buf+0x36e>
    a3c2:	20 93 f5 04 	sts	0x04F5, r18
    a3c6:	30 93 f6 04 	sts	0x04F6, r19
    a3ca:	40 93 f7 04 	sts	0x04F7, r20
    a3ce:	50 93 f8 04 	sts	0x04F8, r21
    a3d2:	2f cf       	rjmp	.-418    	; 0xa232 <Field2Buf+0x196>
    a3d4:	c5 01       	movw	r24, r10
    a3d6:	0e 94 e7 82 	call	0x105ce	; 0x105ce <__eerd_byte_m2560>
		Oldstyle = 1;
		break;
	case EE_Bit:
		F_Buf = (erb(BitVar) &Mask) > 0;
    a3da:	10 92 f5 04 	sts	0x04F5, r1
    a3de:	10 92 f6 04 	sts	0x04F6, r1
    a3e2:	10 92 f7 04 	sts	0x04F7, r1
    a3e6:	10 92 f8 04 	sts	0x04F8, r1
    a3ea:	18 23       	and	r17, r24
    a3ec:	09 f4       	brne	.+2      	; 0xa3f0 <Field2Buf+0x354>
    a3ee:	21 cf       	rjmp	.-446    	; 0xa232 <Field2Buf+0x196>
    a3f0:	81 e0       	ldi	r24, 0x01	; 1
    a3f2:	90 e0       	ldi	r25, 0x00	; 0
    a3f4:	a0 e0       	ldi	r26, 0x00	; 0
    a3f6:	b0 e0       	ldi	r27, 0x00	; 0
    a3f8:	80 93 f5 04 	sts	0x04F5, r24
    a3fc:	90 93 f6 04 	sts	0x04F6, r25
    a400:	a0 93 f7 04 	sts	0x04F7, r26
    a404:	b0 93 f8 04 	sts	0x04F8, r27
    a408:	14 cf       	rjmp	.-472    	; 0xa232 <Field2Buf+0x196>
	case EE_Enum:
		F_Buf = erb((uint8_t*)Var);
		Oldstyle = 1;
		break;
	case Bit:
		F_Buf = (*BitVar &Mask) > 0;
    a40a:	21 e0       	ldi	r18, 0x01	; 1
    a40c:	30 e0       	ldi	r19, 0x00	; 0
    a40e:	40 e0       	ldi	r20, 0x00	; 0
    a410:	50 e0       	ldi	r21, 0x00	; 0
    a412:	d7 cf       	rjmp	.-82     	; 0xa3c2 <Field2Buf+0x326>
	Param.Size = CurrFieldSize;
	Param.Pos = BufStr;
	Param.Prec = prb(&Field->Prec);
	Param.Txt = NULL;

	switch(prb(&Field->Type)) {
    a414:	82 31       	cpi	r24, 0x12	; 18
    a416:	51 f1       	breq	.+84     	; 0xa46c <Field2Buf+0x3d0>
    a418:	83 31       	cpi	r24, 0x13	; 19
    a41a:	08 f0       	brcs	.+2      	; 0xa41e <Field2Buf+0x382>
    a41c:	53 c0       	rjmp	.+166    	; 0xa4c4 <Field2Buf+0x428>
    a41e:	80 31       	cpi	r24, 0x10	; 16
    a420:	c1 f1       	breq	.+112    	; 0xa492 <Field2Buf+0x3f6>
    a422:	81 31       	cpi	r24, 0x11	; 17
    a424:	09 f0       	breq	.+2      	; 0xa428 <Field2Buf+0x38c>
    a426:	07 cf       	rjmp	.-498    	; 0xa236 <Field2Buf+0x19a>
// ~~~~~~~~~~~~~~~~~~~~~~
uint32_t
erd(const uint32_t *addr)
{
	//IntOff();
	uint32_t word = eeprom_read_dword(addr);
    a428:	c6 01       	movw	r24, r12
    a42a:	0e 94 ef 82 	call	0x105de	; 0x105de <__eerd_dword_m2560>
	case z_Longint:
		Put_zDVal(*(uint32_t*)Var, &Param);
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
		break;
	case EE_Longint: 
		PutDVal(erd((uint32_t*)Var), &Param);
    a42e:	ae 01       	movw	r20, r28
    a430:	4b 5f       	subi	r20, 0xFB	; 251
    a432:	5f 4f       	sbci	r21, 0xFF	; 255
    a434:	0e 94 d2 46 	call	0x8da4	; 0x8da4 <PutDVal>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
    a438:	8e ea       	ldi	r24, 0xAE	; 174
    a43a:	96 e0       	ldi	r25, 0x06	; 6
    a43c:	60 91 c1 05 	lds	r22, 0x05C1
    a440:	0e 94 fc 40 	call	0x81f8	; 0x81f8 <GetMultiSymbol>
    a444:	80 93 f2 04 	sts	0x04F2, r24
    a448:	f6 ce       	rjmp	.-532    	; 0xa236 <Field2Buf+0x19a>
    a44a:	c6 01       	movw	r24, r12
    a44c:	0e 94 ef 82 	call	0x105de	; 0x105de <__eerd_dword_m2560>
		break;
	case z_EE_Longint:
		Put_zDVal(erd((uint32_t*)Var), &Param);
    a450:	ae 01       	movw	r20, r28
    a452:	4b 5f       	subi	r20, 0xFB	; 251
    a454:	5f 4f       	sbci	r21, 0xFF	; 255
    a456:	0e 94 88 44 	call	0x8910	; 0x8910 <Put_zDVal>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
    a45a:	8e ea       	ldi	r24, 0xAE	; 174
    a45c:	96 e0       	ldi	r25, 0x06	; 6
    a45e:	60 91 c1 05 	lds	r22, 0x05C1
    a462:	0e 94 fc 40 	call	0x81f8	; 0x81f8 <GetMultiSymbol>
    a466:	80 93 f2 04 	sts	0x04F2, r24
    a46a:	e5 ce       	rjmp	.-566    	; 0xa236 <Field2Buf+0x19a>
		break;
	case s_Longint:
		Put_sDVal(*(int32_t*)Var, &Param);
    a46c:	f6 01       	movw	r30, r12
    a46e:	60 81       	ld	r22, Z
    a470:	71 81       	ldd	r23, Z+1	; 0x01
    a472:	82 81       	ldd	r24, Z+2	; 0x02
    a474:	93 81       	ldd	r25, Z+3	; 0x03
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
		break;
	case s_EE_Longint:
		Put_sDVal((int32_t)erd((uint32_t*)Var), &Param);
    a476:	ae 01       	movw	r20, r28
    a478:	4b 5f       	subi	r20, 0xFB	; 251
    a47a:	5f 4f       	sbci	r21, 0xFF	; 255
    a47c:	0e 94 a9 45 	call	0x8b52	; 0x8b52 <Put_sDVal>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
    a480:	8e ea       	ldi	r24, 0xAE	; 174
    a482:	96 e0       	ldi	r25, 0x06	; 6
    a484:	60 91 c1 05 	lds	r22, 0x05C1
    a488:	0e 94 fc 40 	call	0x81f8	; 0x81f8 <GetMultiSymbol>
    a48c:	80 93 f2 04 	sts	0x04F2, r24
    a490:	d2 ce       	rjmp	.-604    	; 0xa236 <Field2Buf+0x19a>
	Param.Prec = prb(&Field->Prec);
	Param.Txt = NULL;

	switch(prb(&Field->Type)) {
	case Longint:
		PutDVal(*(uint32_t*)Var, &Param);
    a492:	f6 01       	movw	r30, r12
    a494:	60 81       	ld	r22, Z
    a496:	71 81       	ldd	r23, Z+1	; 0x01
    a498:	82 81       	ldd	r24, Z+2	; 0x02
    a49a:	93 81       	ldd	r25, Z+3	; 0x03
    a49c:	c8 cf       	rjmp	.-112    	; 0xa42e <Field2Buf+0x392>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
		break;


	case FFloat:
		Put_FFVal(*(float*)Var, &Param);
    a49e:	f6 01       	movw	r30, r12
    a4a0:	60 81       	ld	r22, Z
    a4a2:	71 81       	ldd	r23, Z+1	; 0x01
    a4a4:	82 81       	ldd	r24, Z+2	; 0x02
    a4a6:	93 81       	ldd	r25, Z+3	; 0x03
    a4a8:	ae 01       	movw	r20, r28
    a4aa:	4b 5f       	subi	r20, 0xFB	; 251
    a4ac:	5f 4f       	sbci	r21, 0xFF	; 255
    a4ae:	0e 94 33 44 	call	0x8866	; 0x8866 <Put_FFVal>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
    a4b2:	8e ea       	ldi	r24, 0xAE	; 174
    a4b4:	96 e0       	ldi	r25, 0x06	; 6
    a4b6:	60 91 c1 05 	lds	r22, 0x05C1
    a4ba:	0e 94 fc 40 	call	0x81f8	; 0x81f8 <GetMultiSymbol>
    a4be:	80 93 f2 04 	sts	0x04F2, r24
    a4c2:	b9 ce       	rjmp	.-654    	; 0xa236 <Field2Buf+0x19a>
	Param.Size = CurrFieldSize;
	Param.Pos = BufStr;
	Param.Prec = prb(&Field->Prec);
	Param.Txt = NULL;

	switch(prb(&Field->Type)) {
    a4c4:	83 31       	cpi	r24, 0x13	; 19
    a4c6:	49 f0       	breq	.+18     	; 0xa4da <Field2Buf+0x43e>
    a4c8:	84 31       	cpi	r24, 0x14	; 20
    a4ca:	09 f0       	breq	.+2      	; 0xa4ce <Field2Buf+0x432>
    a4cc:	b4 ce       	rjmp	.-664    	; 0xa236 <Field2Buf+0x19a>
	case Longint:
		PutDVal(*(uint32_t*)Var, &Param);
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
		break;
	case z_Longint:
		Put_zDVal(*(uint32_t*)Var, &Param);
    a4ce:	f6 01       	movw	r30, r12
    a4d0:	60 81       	ld	r22, Z
    a4d2:	71 81       	ldd	r23, Z+1	; 0x01
    a4d4:	82 81       	ldd	r24, Z+2	; 0x02
    a4d6:	93 81       	ldd	r25, Z+3	; 0x03
    a4d8:	bb cf       	rjmp	.-138    	; 0xa450 <Field2Buf+0x3b4>
    a4da:	c6 01       	movw	r24, r12
    a4dc:	0e 94 ef 82 	call	0x105de	; 0x105de <__eerd_dword_m2560>
    a4e0:	ca cf       	rjmp	.-108    	; 0xa476 <Field2Buf+0x3da>
	Param.Size = CurrFieldSize;
	Param.Pos = BufStr;
	Param.Prec = prb(&Field->Prec);
	Param.Txt = NULL;

	switch(prb(&Field->Type)) {
    a4e2:	81 32       	cpi	r24, 0x21	; 33
    a4e4:	69 f0       	breq	.+26     	; 0xa500 <Field2Buf+0x464>
    a4e6:	82 32       	cpi	r24, 0x22	; 34
    a4e8:	69 f1       	breq	.+90     	; 0xa544 <Field2Buf+0x4a8>
    a4ea:	8c 31       	cpi	r24, 0x1C	; 28
    a4ec:	09 f0       	breq	.+2      	; 0xa4f0 <Field2Buf+0x454>
    a4ee:	a3 ce       	rjmp	.-698    	; 0xa236 <Field2Buf+0x19a>
    a4f0:	8e 01       	movw	r16, r28
    a4f2:	0b 5f       	subi	r16, 0xFB	; 251
    a4f4:	1f 4f       	sbci	r17, 0xFF	; 255
    a4f6:	7e 01       	movw	r14, r28
    a4f8:	08 94       	sec
    a4fa:	e1 1c       	adc	r14, r1
    a4fc:	f1 1c       	adc	r15, r1
    a4fe:	6c ce       	rjmp	.-808    	; 0xa1d8 <Field2Buf+0x13c>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
		break;


	case Text:
		Put_TextValAlignLeft((char*)Var, &Param);
    a500:	c6 01       	movw	r24, r12
		
		break;
	case EE_Text:{
			char TempStr[LCDXSz+1];
			erbl(TempStr, Var, CurrFieldSize);
			Put_TextValAlignLeft(TempStr, &Param);
    a502:	be 01       	movw	r22, r28
    a504:	6b 5f       	subi	r22, 0xFB	; 251
    a506:	7f 4f       	sbci	r23, 0xFF	; 255
    a508:	0e 94 01 43 	call	0x8602	; 0x8602 <Put_TextValAlignLeft>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    a50c:	f7 01       	movw	r30, r14
    a50e:	33 96       	adiw	r30, 0x03	; 3
    a510:	85 91       	lpm	r24, Z+
    a512:	95 91       	lpm	r25, Z+
    a514:	a5 91       	lpm	r26, Z+
    a516:	b4 91       	lpm	r27, Z+
			if( (prd(&Field->Min) == DIGIT) && (prd(&Field->Max) == DIGIT) )
    a518:	00 97       	sbiw	r24, 0x00	; 0
    a51a:	a1 05       	cpc	r26, r1
    a51c:	b1 05       	cpc	r27, r1
    a51e:	49 f4       	brne	.+18     	; 0xa532 <Field2Buf+0x496>
    a520:	f3 01       	movw	r30, r6
    a522:	85 91       	lpm	r24, Z+
    a524:	95 91       	lpm	r25, Z+
    a526:	a5 91       	lpm	r26, Z+
    a528:	b4 91       	lpm	r27, Z+
    a52a:	00 97       	sbiw	r24, 0x00	; 0
    a52c:	a1 05       	cpc	r26, r1
    a52e:	b1 05       	cpc	r27, r1
    a530:	99 f0       	breq	.+38     	; 0xa558 <Field2Buf+0x4bc>
				MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[0]);
			else MultiSymbol = GetMultiSymbol(Symbols_P, BufStr[0]);
    a532:	85 e0       	ldi	r24, 0x05	; 5
    a534:	96 e0       	ldi	r25, 0x06	; 6
    a536:	60 91 c1 05 	lds	r22, 0x05C1
    a53a:	0e 94 fc 40 	call	0x81f8	; 0x81f8 <GetMultiSymbol>
    a53e:	80 93 f2 04 	sts	0x04F2, r24
    a542:	79 ce       	rjmp	.-782    	; 0xa236 <Field2Buf+0x19a>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    a544:	8e 01       	movw	r16, r28
    a546:	05 5f       	subi	r16, 0xF5	; 245
    a548:	1f 4f       	sbci	r17, 0xFF	; 255
    a54a:	c8 01       	movw	r24, r16
    a54c:	b6 01       	movw	r22, r12
    a54e:	50 e0       	ldi	r21, 0x00	; 0
    a550:	0e 94 d7 82 	call	0x105ae	; 0x105ae <__eerd_block_m2560>
		
		break;
	case EE_Text:{
			char TempStr[LCDXSz+1];
			erbl(TempStr, Var, CurrFieldSize);
			Put_TextValAlignLeft(TempStr, &Param);
    a554:	c8 01       	movw	r24, r16
    a556:	d5 cf       	rjmp	.-86     	; 0xa502 <Field2Buf+0x466>
			if( (prd(&Field->Min) == DIGIT) && (prd(&Field->Max) == DIGIT) )
				MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[0]);
    a558:	83 ea       	ldi	r24, 0xA3	; 163
    a55a:	96 e0       	ldi	r25, 0x06	; 6
    a55c:	60 91 c1 05 	lds	r22, 0x05C1
    a560:	0e 94 fc 40 	call	0x81f8	; 0x81f8 <GetMultiSymbol>
    a564:	80 93 f2 04 	sts	0x04F2, r24
    a568:	66 ce       	rjmp	.-820    	; 0xa236 <Field2Buf+0x19a>
    a56a:	8e 01       	movw	r16, r28
    a56c:	0b 5f       	subi	r16, 0xFB	; 251
    a56e:	1f 4f       	sbci	r17, 0xFF	; 255
    a570:	7e 01       	movw	r14, r28
    a572:	08 94       	sec
    a574:	e1 1c       	adc	r14, r1
    a576:	f1 1c       	adc	r15, r1
    a578:	1f ce       	rjmp	.-962    	; 0xa1b8 <Field2Buf+0x11c>

0000a57a <MenuEscLeft>:
}

// ~~~~~~~~~~~~~~
void
MenuEscLeft(void)
{
    a57a:	0f 93       	push	r16
    a57c:	1f 93       	push	r17
    a57e:	cf 93       	push	r28
    a580:	df 93       	push	r29
//	1) Hide current Message
	if(HideMsg()||KeyFunc(&CurrPage->Esc))
    a582:	0e 94 f5 3c 	call	0x79ea	; 0x79ea <HideMsg>
    a586:	88 23       	and	r24, r24
    a588:	29 f0       	breq	.+10     	; 0xa594 <MenuEscLeft+0x1a>
		else
			CurrPage=prp(&CurrPage->OutPage);
		CurrLine=CurrLCD=GetFix();
	}
	EventFunc(&CurrPage->Load);
}
    a58a:	df 91       	pop	r29
    a58c:	cf 91       	pop	r28
    a58e:	1f 91       	pop	r17
    a590:	0f 91       	pop	r16
    a592:	08 95       	ret
// ~~~~~~~~~~~~~~
void
MenuEscLeft(void)
{
//	1) Hide current Message
	if(HideMsg()||KeyFunc(&CurrPage->Esc))
    a594:	80 91 d4 02 	lds	r24, 0x02D4
    a598:	90 91 d5 02 	lds	r25, 0x02D5
    a59c:	0e 96       	adiw	r24, 0x0e	; 14
    a59e:	0e 94 9b 3c 	call	0x7936	; 0x7936 <KeyFunc>
    a5a2:	88 23       	and	r24, r24
    a5a4:	91 f7       	brne	.-28     	; 0xa58a <MenuEscLeft+0x10>
		return;

// 2) Variable
	if(CurrField!=NullPos) {
    a5a6:	30 91 d6 02 	lds	r19, 0x02D6
    a5aa:	3f 3f       	cpi	r19, 0xFF	; 255
    a5ac:	09 f4       	brne	.+2      	; 0xa5b0 <MenuEscLeft+0x36>
    a5ae:	c8 c0       	rjmp	.+400    	; 0xa740 <MenuEscLeft+0x1c6>
		if(CurrPos!=NullPos) {
    a5b0:	40 91 d7 02 	lds	r20, 0x02D7
    a5b4:	4f 3f       	cpi	r20, 0xFF	; 255
    a5b6:	09 f4       	brne	.+2      	; 0xa5ba <MenuEscLeft+0x40>
    a5b8:	5a c0       	rjmp	.+180    	; 0xa66e <MenuEscLeft+0xf4>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    a5ba:	80 91 d4 02 	lds	r24, 0x02D4
    a5be:	90 91 d5 02 	lds	r25, 0x02D5
    a5c2:	fc 01       	movw	r30, r24
    a5c4:	65 91       	lpm	r22, Z+
    a5c6:	74 91       	lpm	r23, Z+
			OutField *Field=GetField;
    a5c8:	80 91 83 07 	lds	r24, 0x0783
    a5cc:	2b e1       	ldi	r18, 0x1B	; 27
    a5ce:	82 9f       	mul	r24, r18
    a5d0:	c0 01       	movw	r24, r0
    a5d2:	11 24       	eor	r1, r1
    a5d4:	68 0f       	add	r22, r24
    a5d6:	79 1f       	adc	r23, r25
    a5d8:	69 5e       	subi	r22, 0xE9	; 233
    a5da:	7f 4f       	sbci	r23, 0xFF	; 255
    a5dc:	fb 01       	movw	r30, r22
    a5de:	c5 91       	lpm	r28, Z+
    a5e0:	d4 91       	lpm	r29, Z+
    a5e2:	83 2f       	mov	r24, r19
    a5e4:	90 e0       	ldi	r25, 0x00	; 0
    a5e6:	82 95       	swap	r24
    a5e8:	92 95       	swap	r25
    a5ea:	90 7f       	andi	r25, 0xF0	; 240
    a5ec:	98 27       	eor	r25, r24
    a5ee:	80 7f       	andi	r24, 0xF0	; 240
    a5f0:	98 27       	eor	r25, r24
    a5f2:	c8 0f       	add	r28, r24
    a5f4:	d9 1f       	adc	r29, r25

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    a5f6:	fe 01       	movw	r30, r28
    a5f8:	14 91       	lpm	r17, Z+
			uint8_t Type=prb(&Field->Type);
			uint8_t Pos;

			if( (Type == Text) || (Type == EE_Text) ||
    a5fa:	01 2f       	mov	r16, r17
    a5fc:	01 52       	subi	r16, 0x21	; 33
    a5fe:	02 30       	cpi	r16, 0x02	; 2
    a600:	00 f1       	brcs	.+64     	; 0xa642 <MenuEscLeft+0xc8>
    a602:	10 31       	cpi	r17, 0x10	; 16
    a604:	f1 f0       	breq	.+60     	; 0xa642 <MenuEscLeft+0xc8>
    a606:	11 31       	cpi	r17, 0x11	; 17
    a608:	e1 f0       	breq	.+56     	; 0xa642 <MenuEscLeft+0xc8>
    a60a:	12 31       	cpi	r17, 0x12	; 18
    a60c:	d1 f0       	breq	.+52     	; 0xa642 <MenuEscLeft+0xc8>
    a60e:	13 31       	cpi	r17, 0x13	; 19
    a610:	c1 f0       	breq	.+48     	; 0xa642 <MenuEscLeft+0xc8>
    a612:	14 31       	cpi	r17, 0x14	; 20
    a614:	b1 f0       	breq	.+44     	; 0xa642 <MenuEscLeft+0xc8>
    a616:	15 31       	cpi	r17, 0x15	; 21
    a618:	a1 f0       	breq	.+40     	; 0xa642 <MenuEscLeft+0xc8>
    a61a:	19 31       	cpi	r17, 0x19	; 25
    a61c:	91 f0       	breq	.+36     	; 0xa642 <MenuEscLeft+0xc8>
    a61e:	1a 31       	cpi	r17, 0x1A	; 26
    a620:	81 f0       	breq	.+32     	; 0xa642 <MenuEscLeft+0xc8>
    a622:	1b 31       	cpi	r17, 0x1B	; 27
    a624:	71 f0       	breq	.+28     	; 0xa642 <MenuEscLeft+0xc8>
    a626:	1c 31       	cpi	r17, 0x1C	; 28
    a628:	61 f0       	breq	.+24     	; 0xa642 <MenuEscLeft+0xc8>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    a62a:	fe 01       	movw	r30, r28
    a62c:	37 96       	adiw	r30, 0x07	; 7
    a62e:	65 91       	lpm	r22, Z+
    a630:	75 91       	lpm	r23, Z+
    a632:	85 91       	lpm	r24, Z+
    a634:	94 91       	lpm	r25, Z+
			 (Type == Longint) || (Type == EE_Longint)|| (Type == s_Longint) || (Type == s_EE_Longint) || (Type == z_Longint) || (Type == z_EE_Longint) ||
			 (Type == FFloat) || (Type == EE_FFloat) || (Type == GFloat) || (Type == EE_GFloat) ) 
			 	Pos = CurrFieldSize-1;
			else Pos=Log10(prd(&Field->Max));
    a636:	0e 94 23 21 	call	0x4246	; 0x4246 <Log10>
    a63a:	98 2f       	mov	r25, r24
    a63c:	40 91 d7 02 	lds	r20, 0x02D7
    a640:	03 c0       	rjmp	.+6      	; 0xa648 <MenuEscLeft+0xce>
			uint8_t Pos;

			if( (Type == Text) || (Type == EE_Text) ||
			 (Type == Longint) || (Type == EE_Longint)|| (Type == s_Longint) || (Type == s_EE_Longint) || (Type == z_Longint) || (Type == z_EE_Longint) ||
			 (Type == FFloat) || (Type == EE_FFloat) || (Type == GFloat) || (Type == EE_GFloat) ) 
			 	Pos = CurrFieldSize-1;
    a642:	90 91 7a 07 	lds	r25, 0x077A
    a646:	91 50       	subi	r25, 0x01	; 1
			else Pos=Log10(prd(&Field->Max));

			if(Type==s_Byte || Type==s_EE_Byte || Type==s_Word || Type==s_EE_Word)
    a648:	81 2f       	mov	r24, r17
    a64a:	82 50       	subi	r24, 0x02	; 2
    a64c:	82 30       	cpi	r24, 0x02	; 2
    a64e:	b0 f1       	brcs	.+108    	; 0xa6bc <MenuEscLeft+0x142>
    a650:	19 30       	cpi	r17, 0x09	; 9
    a652:	a1 f1       	breq	.+104    	; 0xa6bc <MenuEscLeft+0x142>
    a654:	1a 30       	cpi	r17, 0x0A	; 10
    a656:	91 f1       	breq	.+100    	; 0xa6bc <MenuEscLeft+0x142>
				Pos++;
			if(++CurrPos>Pos)
    a658:	24 2f       	mov	r18, r20
    a65a:	2f 5f       	subi	r18, 0xFF	; 255
    a65c:	20 93 d7 02 	sts	0x02D7, r18
    a660:	92 17       	cp	r25, r18
    a662:	70 f5       	brcc	.+92     	; 0xa6c0 <MenuEscLeft+0x146>
				CurrPos = NullPos;
    a664:	8f ef       	ldi	r24, 0xFF	; 255
    a666:	80 93 d7 02 	sts	0x02D7, r24
    a66a:	30 91 d6 02 	lds	r19, 0x02D6
				}
				return;
			}
		}
		//     
		if(--CurrField!=NullPos)
    a66e:	31 50       	subi	r19, 0x01	; 1
    a670:	30 93 d6 02 	sts	0x02D6, r19
    a674:	3f 3f       	cpi	r19, 0xFF	; 255
    a676:	09 f4       	brne	.+2      	; 0xa67a <MenuEscLeft+0x100>
    a678:	88 cf       	rjmp	.-240    	; 0xa58a <MenuEscLeft+0x10>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    a67a:	80 91 d4 02 	lds	r24, 0x02D4
    a67e:	90 91 d5 02 	lds	r25, 0x02D5
    a682:	fc 01       	movw	r30, r24
    a684:	45 91       	lpm	r20, Z+
    a686:	54 91       	lpm	r21, Z+
			Field2Buf(GetField);
    a688:	80 91 83 07 	lds	r24, 0x0783
    a68c:	2b e1       	ldi	r18, 0x1B	; 27
    a68e:	82 9f       	mul	r24, r18
    a690:	c0 01       	movw	r24, r0
    a692:	11 24       	eor	r1, r1
    a694:	48 0f       	add	r20, r24
    a696:	59 1f       	adc	r21, r25
    a698:	49 5e       	subi	r20, 0xE9	; 233
    a69a:	5f 4f       	sbci	r21, 0xFF	; 255
    a69c:	fa 01       	movw	r30, r20
    a69e:	85 91       	lpm	r24, Z+
    a6a0:	94 91       	lpm	r25, Z+
    a6a2:	23 2f       	mov	r18, r19
    a6a4:	30 e0       	ldi	r19, 0x00	; 0
    a6a6:	22 95       	swap	r18
    a6a8:	32 95       	swap	r19
    a6aa:	30 7f       	andi	r19, 0xF0	; 240
    a6ac:	32 27       	eor	r19, r18
    a6ae:	20 7f       	andi	r18, 0xF0	; 240
    a6b0:	32 27       	eor	r19, r18
    a6b2:	82 0f       	add	r24, r18
    a6b4:	93 1f       	adc	r25, r19
    a6b6:	0e 94 4e 50 	call	0xa09c	; 0xa09c <Field2Buf>
    a6ba:	67 cf       	rjmp	.-306    	; 0xa58a <MenuEscLeft+0x10>
			 (Type == FFloat) || (Type == EE_FFloat) || (Type == GFloat) || (Type == EE_GFloat) ) 
			 	Pos = CurrFieldSize-1;
			else Pos=Log10(prd(&Field->Max));

			if(Type==s_Byte || Type==s_EE_Byte || Type==s_Word || Type==s_EE_Word)
				Pos++;
    a6bc:	9f 5f       	subi	r25, 0xFF	; 255
    a6be:	cc cf       	rjmp	.-104    	; 0xa658 <MenuEscLeft+0xde>
			if(++CurrPos>Pos)
				CurrPos = NullPos;
			else{
				switch(Type){
    a6c0:	1d 31       	cpi	r17, 0x1D	; 29
    a6c2:	40 f1       	brcs	.+80     	; 0xa714 <MenuEscLeft+0x19a>
    a6c4:	02 30       	cpi	r16, 0x02	; 2
    a6c6:	08 f0       	brcs	.+2      	; 0xa6ca <MenuEscLeft+0x150>
    a6c8:	60 cf       	rjmp	.-320    	; 0xa58a <MenuEscLeft+0x10>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    a6ca:	fe 01       	movw	r30, r28
    a6cc:	33 96       	adiw	r30, 0x03	; 3
    a6ce:	85 91       	lpm	r24, Z+
    a6d0:	95 91       	lpm	r25, Z+
    a6d2:	a5 91       	lpm	r26, Z+
    a6d4:	b4 91       	lpm	r27, Z+
				case Text: case EE_Text:
					if( (prd(&Field->Min) == DIGIT) && (prd(&Field->Max) == DIGIT) )
    a6d6:	00 97       	sbiw	r24, 0x00	; 0
    a6d8:	a1 05       	cpc	r26, r1
    a6da:	b1 05       	cpc	r27, r1
    a6dc:	59 f4       	brne	.+22     	; 0xa6f4 <MenuEscLeft+0x17a>
    a6de:	fe 01       	movw	r30, r28
    a6e0:	37 96       	adiw	r30, 0x07	; 7
    a6e2:	85 91       	lpm	r24, Z+
    a6e4:	95 91       	lpm	r25, Z+
    a6e6:	a5 91       	lpm	r26, Z+
    a6e8:	b4 91       	lpm	r27, Z+
    a6ea:	00 97       	sbiw	r24, 0x00	; 0
    a6ec:	a1 05       	cpc	r26, r1
    a6ee:	b1 05       	cpc	r27, r1
    a6f0:	09 f4       	brne	.+2      	; 0xa6f4 <MenuEscLeft+0x17a>
    a6f2:	6f c0       	rjmp	.+222    	; 0xa7d2 <MenuEscLeft+0x258>
						MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[CurrFieldSize - 1 - CurrPos]);
					else MultiSymbol = GetMultiSymbol(Symbols_P, BufStr[CurrFieldSize - 1 - CurrPos]);
    a6f4:	e0 91 7a 07 	lds	r30, 0x077A
    a6f8:	f0 e0       	ldi	r31, 0x00	; 0
    a6fa:	31 97       	sbiw	r30, 0x01	; 1
    a6fc:	e2 1b       	sub	r30, r18
    a6fe:	f1 09       	sbc	r31, r1
    a700:	ef 53       	subi	r30, 0x3F	; 63
    a702:	fa 4f       	sbci	r31, 0xFA	; 250
    a704:	85 e0       	ldi	r24, 0x05	; 5
    a706:	96 e0       	ldi	r25, 0x06	; 6
    a708:	60 81       	ld	r22, Z
    a70a:	0e 94 fc 40 	call	0x81f8	; 0x81f8 <GetMultiSymbol>
    a70e:	80 93 f2 04 	sts	0x04F2, r24
    a712:	3b cf       	rjmp	.-394    	; 0xa58a <MenuEscLeft+0x10>
			if(Type==s_Byte || Type==s_EE_Byte || Type==s_Word || Type==s_EE_Word)
				Pos++;
			if(++CurrPos>Pos)
				CurrPos = NullPos;
			else{
				switch(Type){
    a714:	19 31       	cpi	r17, 0x19	; 25
    a716:	20 f4       	brcc	.+8      	; 0xa720 <MenuEscLeft+0x1a6>
    a718:	10 51       	subi	r17, 0x10	; 16
    a71a:	16 30       	cpi	r17, 0x06	; 6
    a71c:	08 f0       	brcs	.+2      	; 0xa720 <MenuEscLeft+0x1a6>
    a71e:	35 cf       	rjmp	.-406    	; 0xa58a <MenuEscLeft+0x10>
						MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[CurrFieldSize - 1 - CurrPos]);
					else MultiSymbol = GetMultiSymbol(Symbols_P, BufStr[CurrFieldSize - 1 - CurrPos]);
					break;
				case Longint: case z_Longint: case EE_Longint: case z_EE_Longint: case s_Longint: case s_EE_Longint:
				case FFloat: case EE_FFloat: case GFloat: case EE_GFloat:
					MultiSymbol = GetMultiSymbol(Digits_P, BufStr[CurrFieldSize - 1 - CurrPos]);
    a720:	e0 91 7a 07 	lds	r30, 0x077A
    a724:	f0 e0       	ldi	r31, 0x00	; 0
    a726:	31 97       	sbiw	r30, 0x01	; 1
    a728:	e2 1b       	sub	r30, r18
    a72a:	f1 09       	sbc	r31, r1
    a72c:	ef 53       	subi	r30, 0x3F	; 63
    a72e:	fa 4f       	sbci	r31, 0xFA	; 250
    a730:	8e ea       	ldi	r24, 0xAE	; 174
    a732:	96 e0       	ldi	r25, 0x06	; 6
    a734:	60 81       	ld	r22, Z
    a736:	0e 94 fc 40 	call	0x81f8	; 0x81f8 <GetMultiSymbol>
    a73a:	80 93 f2 04 	sts	0x04F2, r24
    a73e:	25 cf       	rjmp	.-438    	; 0xa58a <MenuEscLeft+0x10>
			Field2Buf(GetField);
		return;
	}

// 3) Go to menu
	EventFunc(&CurrPage->Exit);
    a740:	80 91 d4 02 	lds	r24, 0x02D4
    a744:	90 91 d5 02 	lds	r25, 0x02D5
    a748:	0a 96       	adiw	r24, 0x0a	; 10
    a74a:	0e 94 93 3c 	call	0x7926	; 0x7926 <EventFunc>
	if(MenuDepth) {
    a74e:	e0 91 74 07 	lds	r30, 0x0774
    a752:	ee 23       	and	r30, r30
    a754:	21 f1       	breq	.+72     	; 0xa79e <MenuEscLeft+0x224>
		CurrPage=MenuStack[--MenuDepth].Page;
    a756:	e1 50       	subi	r30, 0x01	; 1
    a758:	e0 93 74 07 	sts	0x0774, r30
    a75c:	f0 e0       	ldi	r31, 0x00	; 0
    a75e:	ee 0f       	add	r30, r30
    a760:	ff 1f       	adc	r31, r31
    a762:	ee 0f       	add	r30, r30
    a764:	ff 1f       	adc	r31, r31
    a766:	df 01       	movw	r26, r30
    a768:	af 55       	subi	r26, 0x5F	; 95
    a76a:	b7 4f       	sbci	r27, 0xF7	; 247
    a76c:	9c 91       	ld	r25, X
    a76e:	11 96       	adiw	r26, 0x01	; 1
    a770:	2c 91       	ld	r18, X
    a772:	11 97       	sbiw	r26, 0x01	; 1
    a774:	90 93 d4 02 	sts	0x02D4, r25
    a778:	20 93 d5 02 	sts	0x02D5, r18
		CurrLine=MenuStack[MenuDepth].Line;
    a77c:	13 96       	adiw	r26, 0x03	; 3
    a77e:	8c 91       	ld	r24, X
    a780:	80 93 83 07 	sts	0x0783, r24
		CurrLCD=MenuStack[MenuDepth].LCD;
    a784:	ed 55       	subi	r30, 0x5D	; 93
    a786:	f7 4f       	sbci	r31, 0xF7	; 247
    a788:	80 81       	ld	r24, Z
    a78a:	80 93 a0 08 	sts	0x08A0, r24
    a78e:	e9 2f       	mov	r30, r25
    a790:	f2 2f       	mov	r31, r18
    a792:	9f 01       	movw	r18, r30
		}
		else
			CurrPage=prp(&CurrPage->OutPage);
		CurrLine=CurrLCD=GetFix();
	}
	EventFunc(&CurrPage->Load);
    a794:	c9 01       	movw	r24, r18
    a796:	06 96       	adiw	r24, 0x06	; 6
    a798:	0e 94 93 3c 	call	0x7926	; 0x7926 <EventFunc>
    a79c:	f6 ce       	rjmp	.-532    	; 0xa58a <MenuEscLeft+0x10>
		CurrPage=MenuStack[--MenuDepth].Page;
		CurrLine=MenuStack[MenuDepth].Line;
		CurrLCD=MenuStack[MenuDepth].LCD;
	}
	else {
		if(NextPage) {
    a79e:	e0 91 d7 05 	lds	r30, 0x05D7
    a7a2:	f0 91 d8 05 	lds	r31, 0x05D8
    a7a6:	30 97       	sbiw	r30, 0x00	; 0
    a7a8:	21 f1       	breq	.+72     	; 0xa7f2 <MenuEscLeft+0x278>
			CurrPage=NextPage;
    a7aa:	f0 93 d5 02 	sts	0x02D5, r31
    a7ae:	e0 93 d4 02 	sts	0x02D4, r30
			NextPage=NULL;
    a7b2:	10 92 d8 05 	sts	0x05D8, r1
    a7b6:	10 92 d7 05 	sts	0x05D7, r1
    a7ba:	9f 01       	movw	r18, r30

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    a7bc:	2d 5f       	subi	r18, 0xFD	; 253
    a7be:	3f 4f       	sbci	r19, 0xFF	; 255
    a7c0:	f9 01       	movw	r30, r18
    a7c2:	84 91       	lpm	r24, Z+
    a7c4:	23 50       	subi	r18, 0x03	; 3
    a7c6:	30 40       	sbci	r19, 0x00	; 0
		}
		else
			CurrPage=prp(&CurrPage->OutPage);
		CurrLine=CurrLCD=GetFix();
    a7c8:	80 93 a0 08 	sts	0x08A0, r24
    a7cc:	80 93 83 07 	sts	0x0783, r24
    a7d0:	e1 cf       	rjmp	.-62     	; 0xa794 <MenuEscLeft+0x21a>
				CurrPos = NullPos;
			else{
				switch(Type){
				case Text: case EE_Text:
					if( (prd(&Field->Min) == DIGIT) && (prd(&Field->Max) == DIGIT) )
						MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[CurrFieldSize - 1 - CurrPos]);
    a7d2:	e0 91 7a 07 	lds	r30, 0x077A
    a7d6:	f0 e0       	ldi	r31, 0x00	; 0
    a7d8:	31 97       	sbiw	r30, 0x01	; 1
    a7da:	e2 1b       	sub	r30, r18
    a7dc:	f1 09       	sbc	r31, r1
    a7de:	ef 53       	subi	r30, 0x3F	; 63
    a7e0:	fa 4f       	sbci	r31, 0xFA	; 250
    a7e2:	83 ea       	ldi	r24, 0xA3	; 163
    a7e4:	96 e0       	ldi	r25, 0x06	; 6
    a7e6:	60 81       	ld	r22, Z
    a7e8:	0e 94 fc 40 	call	0x81f8	; 0x81f8 <GetMultiSymbol>
    a7ec:	80 93 f2 04 	sts	0x04F2, r24
    a7f0:	cc ce       	rjmp	.-616    	; 0xa58a <MenuEscLeft+0x10>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    a7f2:	80 91 d4 02 	lds	r24, 0x02D4
    a7f6:	90 91 d5 02 	lds	r25, 0x02D5
    a7fa:	04 96       	adiw	r24, 0x04	; 4
		if(NextPage) {
			CurrPage=NextPage;
			NextPage=NULL;
		}
		else
			CurrPage=prp(&CurrPage->OutPage);
    a7fc:	fc 01       	movw	r30, r24
    a7fe:	25 91       	lpm	r18, Z+
    a800:	34 91       	lpm	r19, Z+
    a802:	30 93 d5 02 	sts	0x02D5, r19
    a806:	20 93 d4 02 	sts	0x02D4, r18
    a80a:	d8 cf       	rjmp	.-80     	; 0xa7bc <MenuEscLeft+0x242>

0000a80c <Buf2Field>:
// ~~~~~~~~~~~~~~~~~~~~~~~
//       
//     -
static void
Buf2Field(OutField *Field)
{
    a80c:	3f 92       	push	r3
    a80e:	4f 92       	push	r4
    a810:	5f 92       	push	r5
    a812:	6f 92       	push	r6
    a814:	7f 92       	push	r7
    a816:	8f 92       	push	r8
    a818:	9f 92       	push	r9
    a81a:	af 92       	push	r10
    a81c:	bf 92       	push	r11
    a81e:	cf 92       	push	r12
    a820:	df 92       	push	r13
    a822:	ef 92       	push	r14
    a824:	ff 92       	push	r15
    a826:	0f 93       	push	r16
    a828:	1f 93       	push	r17
    a82a:	df 93       	push	r29
    a82c:	cf 93       	push	r28
    a82e:	cd b7       	in	r28, 0x3d	; 61
    a830:	de b7       	in	r29, 0x3e	; 62
    a832:	6d 97       	sbiw	r28, 0x1d	; 29
    a834:	0f b6       	in	r0, 0x3f	; 63
    a836:	f8 94       	cli
    a838:	de bf       	out	0x3e, r29	; 62
    a83a:	0f be       	out	0x3f, r0	; 63
    a83c:	cd bf       	out	0x3d, r28	; 61
    a83e:	6c 01       	movw	r12, r24
    a840:	fc 01       	movw	r30, r24
    a842:	31 96       	adiw	r30, 0x01	; 1
    a844:	45 90       	lpm	r4, Z+
    a846:	54 90       	lpm	r5, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    a848:	2f e0       	ldi	r18, 0x0F	; 15
    a84a:	30 e0       	ldi	r19, 0x00	; 0
    a84c:	c2 0e       	add	r12, r18
    a84e:	d3 1e       	adc	r13, r19
    a850:	f6 01       	movw	r30, r12
    a852:	24 91       	lpm	r18, Z+
    a854:	81 ef       	ldi	r24, 0xF1	; 241
    a856:	9f ef       	ldi	r25, 0xFF	; 255
    a858:	c8 0e       	add	r12, r24
    a85a:	d9 1e       	adc	r13, r25
	void *Var = prp(&Field->Var);
	uint8_t BitN=prb(&Field->Prec), Mask=1<<BitN%8, *BitVar=(uint8_t*)Var+BitN/8;
    a85c:	32 2f       	mov	r19, r18
    a85e:	37 70       	andi	r19, 0x07	; 7
    a860:	81 e0       	ldi	r24, 0x01	; 1
    a862:	90 e0       	ldi	r25, 0x00	; 0
    a864:	38 2e       	mov	r3, r24
    a866:	01 c0       	rjmp	.+2      	; 0xa86a <Buf2Field+0x5e>
    a868:	33 0c       	add	r3, r3
    a86a:	3a 95       	dec	r19
    a86c:	ea f7       	brpl	.-6      	; 0xa868 <Buf2Field+0x5c>
    a86e:	26 95       	lsr	r18
    a870:	26 95       	lsr	r18
    a872:	26 95       	lsr	r18
    a874:	32 01       	movw	r6, r4
    a876:	62 0e       	add	r6, r18
    a878:	71 1c       	adc	r7, r1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    a87a:	f6 01       	movw	r30, r12
    a87c:	33 96       	adiw	r30, 0x03	; 3
    a87e:	85 90       	lpm	r8, Z+
    a880:	95 90       	lpm	r9, Z+
    a882:	a5 90       	lpm	r10, Z+
    a884:	b4 90       	lpm	r11, Z+
	uint8_t EE_BitVar;
	uint32_t Min=prd(&Field->Min), Max=prd(&Field->Max);

	uint32_t Temp=0;
    a886:	f6 01       	movw	r30, r12
    a888:	37 96       	adiw	r30, 0x07	; 7
    a88a:	e5 90       	lpm	r14, Z+
    a88c:	f5 90       	lpm	r15, Z+
    a88e:	05 91       	lpm	r16, Z+
    a890:	14 91       	lpm	r17, Z+
    a892:	19 82       	std	Y+1, r1	; 0x01
    a894:	1a 82       	std	Y+2, r1	; 0x02
    a896:	1b 82       	std	Y+3, r1	; 0x03
    a898:	1c 82       	std	Y+4, r1	; 0x04
	float fTemp=0;
    a89a:	80 e0       	ldi	r24, 0x00	; 0
    a89c:	90 e0       	ldi	r25, 0x00	; 0
    a89e:	a0 e0       	ldi	r26, 0x00	; 0
    a8a0:	b0 e0       	ldi	r27, 0x00	; 0
    a8a2:	8d 83       	std	Y+5, r24	; 0x05
    a8a4:	9e 83       	std	Y+6, r25	; 0x06
    a8a6:	af 83       	std	Y+7, r26	; 0x07
    a8a8:	b8 87       	std	Y+8, r27	; 0x08

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    a8aa:	f6 01       	movw	r30, r12
    a8ac:	84 91       	lpm	r24, Z+

	switch(prb(&Field->Type)) {
    a8ae:	e8 2f       	mov	r30, r24
    a8b0:	f0 e0       	ldi	r31, 0x00	; 0
    a8b2:	e3 32       	cpi	r30, 0x23	; 35
    a8b4:	f1 05       	cpc	r31, r1
    a8b6:	08 f0       	brcs	.+2      	; 0xa8ba <Buf2Field+0xae>
    a8b8:	3f c0       	rjmp	.+126    	; 0xa938 <Buf2Field+0x12c>
    a8ba:	ed 56       	subi	r30, 0x6D	; 109
    a8bc:	ff 4f       	sbci	r31, 0xFF	; 255
    a8be:	ee 0f       	add	r30, r30
    a8c0:	ff 1f       	adc	r31, r31
    a8c2:	05 90       	lpm	r0, Z+
    a8c4:	f4 91       	lpm	r31, Z+
    a8c6:	e0 2d       	mov	r30, r0
    a8c8:	19 94       	eijmp
		PresicionHanler(Field);
		sscanf(BufStr,"%lud", (uint32_t*)&Temp);
		SetField32(Temp, uint32_t);
		break;
	case EE_Longint: case z_EE_Longint:
		PresicionHanler(Field);
    a8ca:	c6 01       	movw	r24, r12
    a8cc:	0e 94 c2 40 	call	0x8184	; 0x8184 <PresicionHanler>
		if(sscanf(BufStr,"%lud", (uint32_t*)&Temp) == 1){
    a8d0:	00 d0       	rcall	.+0      	; 0xa8d2 <Buf2Field+0xc6>
    a8d2:	00 d0       	rcall	.+0      	; 0xa8d4 <Buf2Field+0xc8>
    a8d4:	ed b7       	in	r30, 0x3d	; 61
    a8d6:	fe b7       	in	r31, 0x3e	; 62
    a8d8:	31 96       	adiw	r30, 0x01	; 1
    a8da:	81 ec       	ldi	r24, 0xC1	; 193
    a8dc:	95 e0       	ldi	r25, 0x05	; 5
    a8de:	ad b7       	in	r26, 0x3d	; 61
    a8e0:	be b7       	in	r27, 0x3e	; 62
    a8e2:	12 96       	adiw	r26, 0x02	; 2
    a8e4:	9c 93       	st	X, r25
    a8e6:	8e 93       	st	-X, r24
    a8e8:	11 97       	sbiw	r26, 0x01	; 1
    a8ea:	8f e9       	ldi	r24, 0x9F	; 159
    a8ec:	92 e0       	ldi	r25, 0x02	; 2
    a8ee:	93 83       	std	Z+3, r25	; 0x03
    a8f0:	82 83       	std	Z+2, r24	; 0x02
    a8f2:	ce 01       	movw	r24, r28
    a8f4:	01 96       	adiw	r24, 0x01	; 1
    a8f6:	95 83       	std	Z+5, r25	; 0x05
    a8f8:	84 83       	std	Z+4, r24	; 0x04
    a8fa:	0e 94 1b 81 	call	0x10236	; 0x10236 <sscanf>
    a8fe:	ed b7       	in	r30, 0x3d	; 61
    a900:	fe b7       	in	r31, 0x3e	; 62
    a902:	36 96       	adiw	r30, 0x06	; 6
    a904:	0f b6       	in	r0, 0x3f	; 63
    a906:	f8 94       	cli
    a908:	fe bf       	out	0x3e, r31	; 62
    a90a:	0f be       	out	0x3f, r0	; 63
    a90c:	ed bf       	out	0x3d, r30	; 61
    a90e:	01 97       	sbiw	r24, 0x01	; 1
    a910:	99 f4       	brne	.+38     	; 0xa938 <Buf2Field+0x12c>
			SetEEField32(Temp, uint32_t, uint32_t, d);
    a912:	49 81       	ldd	r20, Y+1	; 0x01
    a914:	5a 81       	ldd	r21, Y+2	; 0x02
    a916:	6b 81       	ldd	r22, Y+3	; 0x03
    a918:	7c 81       	ldd	r23, Y+4	; 0x04
    a91a:	e4 16       	cp	r14, r20
    a91c:	f5 06       	cpc	r15, r21
    a91e:	06 07       	cpc	r16, r22
    a920:	17 07       	cpc	r17, r23
    a922:	08 f4       	brcc	.+2      	; 0xa926 <Buf2Field+0x11a>
    a924:	cc c2       	rjmp	.+1432   	; 0xaebe <Buf2Field+0x6b2>
    a926:	48 15       	cp	r20, r8
    a928:	59 05       	cpc	r21, r9
    a92a:	6a 05       	cpc	r22, r10
    a92c:	7b 05       	cpc	r23, r11
    a92e:	08 f4       	brcc	.+2      	; 0xa932 <Buf2Field+0x126>
    a930:	f8 c1       	rjmp	.+1008   	; 0xad22 <Buf2Field+0x516>
		SetField32(Temp, int32_t);
		break;
	case s_EE_Longint:
		PresicionHanler(Field);
		if(sscanf(BufStr,"%ld", (int32_t*)&Temp) == 1){
			SetEEField32(Temp, int32_t, uint32_t, d);
    a932:	c2 01       	movw	r24, r4
    a934:	0e 94 c8 4d 	call	0x9b90	; 0x9b90 <ewd>
			ewbl(TempStr, Var, Width);
		}
		break;

	}
	EventFunc(&Field->Act);
    a938:	c6 01       	movw	r24, r12
    a93a:	0b 96       	adiw	r24, 0x0b	; 11
    a93c:	0e 94 93 3c 	call	0x7926	; 0x7926 <EventFunc>
}
    a940:	6d 96       	adiw	r28, 0x1d	; 29
    a942:	0f b6       	in	r0, 0x3f	; 63
    a944:	f8 94       	cli
    a946:	de bf       	out	0x3e, r29	; 62
    a948:	0f be       	out	0x3f, r0	; 63
    a94a:	cd bf       	out	0x3d, r28	; 61
    a94c:	cf 91       	pop	r28
    a94e:	df 91       	pop	r29
    a950:	1f 91       	pop	r17
    a952:	0f 91       	pop	r16
    a954:	ff 90       	pop	r15
    a956:	ef 90       	pop	r14
    a958:	df 90       	pop	r13
    a95a:	cf 90       	pop	r12
    a95c:	bf 90       	pop	r11
    a95e:	af 90       	pop	r10
    a960:	9f 90       	pop	r9
    a962:	8f 90       	pop	r8
    a964:	7f 90       	pop	r7
    a966:	6f 90       	pop	r6
    a968:	5f 90       	pop	r5
    a96a:	4f 90       	pop	r4
    a96c:	3f 90       	pop	r3
    a96e:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    a970:	8e 01       	movw	r16, r28
    a972:	07 5f       	subi	r16, 0xF7	; 247
    a974:	1f 4f       	sbci	r17, 0xFF	; 255
    a976:	c8 01       	movw	r24, r16
    a978:	b2 01       	movw	r22, r4
    a97a:	45 e1       	ldi	r20, 0x15	; 21
    a97c:	50 e0       	ldi	r21, 0x00	; 0
    a97e:	0e 94 d7 82 	call	0x105ae	; 0x105ae <__eerd_block_m2560>
		}
		break;
	case EE_Text:{
			char TempStr[LCDXSz+1];
			erbl(TempStr, Var, LCDXSz+1);
			uint8_t Width = strlen(TempStr);
    a982:	d8 01       	movw	r26, r16
    a984:	0d 90       	ld	r0, X+
    a986:	00 20       	and	r0, r0
    a988:	e9 f7       	brne	.-6      	; 0xa984 <Buf2Field+0x178>
    a98a:	7d 01       	movw	r14, r26
    a98c:	08 94       	sec
    a98e:	e1 08       	sbc	r14, r1
    a990:	f1 08       	sbc	r15, r1
    a992:	e0 1a       	sub	r14, r16
    a994:	f1 0a       	sbc	r15, r17
			memcpy(TempStr, BufStr, Width);
    a996:	21 ec       	ldi	r18, 0xC1	; 193
    a998:	35 e0       	ldi	r19, 0x05	; 5
    a99a:	c8 01       	movw	r24, r16
    a99c:	b9 01       	movw	r22, r18
    a99e:	4e 2d       	mov	r20, r14
    a9a0:	50 e0       	ldi	r21, 0x00	; 0
    a9a2:	0e 94 09 80 	call	0x10012	; 0x10012 <memcpy>
			ewbl(TempStr, Var, Width);
    a9a6:	c8 01       	movw	r24, r16
    a9a8:	b2 01       	movw	r22, r4
    a9aa:	4e 2d       	mov	r20, r14
    a9ac:	50 e0       	ldi	r21, 0x00	; 0
    a9ae:	0e 94 c3 4d 	call	0x9b86	; 0x9b86 <ewbl>
    a9b2:	c2 cf       	rjmp	.-124    	; 0xa938 <Buf2Field+0x12c>
	uint32_t Temp=0;
	float fTemp=0;

	switch(prb(&Field->Type)) {
	case Byte: case z_Byte: case Enum:
		SetField(F_Buf, uint8_t);
    a9b4:	20 91 f5 04 	lds	r18, 0x04F5
    a9b8:	30 91 f6 04 	lds	r19, 0x04F6
    a9bc:	40 91 f7 04 	lds	r20, 0x04F7
    a9c0:	50 91 f8 04 	lds	r21, 0x04F8
    a9c4:	8e 2d       	mov	r24, r14
    a9c6:	90 e0       	ldi	r25, 0x00	; 0
    a9c8:	a0 e0       	ldi	r26, 0x00	; 0
    a9ca:	b0 e0       	ldi	r27, 0x00	; 0
    a9cc:	82 17       	cp	r24, r18
    a9ce:	93 07       	cpc	r25, r19
    a9d0:	a4 07       	cpc	r26, r20
    a9d2:	b5 07       	cpc	r27, r21
    a9d4:	08 f4       	brcc	.+2      	; 0xa9d8 <Buf2Field+0x1cc>
    a9d6:	50 c2       	rjmp	.+1184   	; 0xae78 <Buf2Field+0x66c>
    a9d8:	88 2d       	mov	r24, r8
    a9da:	90 e0       	ldi	r25, 0x00	; 0
    a9dc:	a0 e0       	ldi	r26, 0x00	; 0
    a9de:	b0 e0       	ldi	r27, 0x00	; 0
    a9e0:	28 17       	cp	r18, r24
    a9e2:	39 07       	cpc	r19, r25
    a9e4:	4a 07       	cpc	r20, r26
    a9e6:	5b 07       	cpc	r21, r27
    a9e8:	08 f0       	brcs	.+2      	; 0xa9ec <Buf2Field+0x1e0>
    a9ea:	66 c2       	rjmp	.+1228   	; 0xaeb8 <Buf2Field+0x6ac>
    a9ec:	f2 01       	movw	r30, r4
    a9ee:	80 82       	st	Z, r8
    a9f0:	a3 cf       	rjmp	.-186    	; 0xa938 <Buf2Field+0x12c>
		break;
	case s_Byte:
		SetField(sF_Buf, int8_t);
		break;
	case EE_Byte: case z_EE_Byte: case EE_Enum:
		SetEEField(F_Buf, uint8_t, uint8_t, b);
    a9f2:	20 91 f5 04 	lds	r18, 0x04F5
    a9f6:	30 91 f6 04 	lds	r19, 0x04F6
    a9fa:	40 91 f7 04 	lds	r20, 0x04F7
    a9fe:	50 91 f8 04 	lds	r21, 0x04F8
    aa02:	8e 2d       	mov	r24, r14
    aa04:	90 e0       	ldi	r25, 0x00	; 0
    aa06:	a0 e0       	ldi	r26, 0x00	; 0
    aa08:	b0 e0       	ldi	r27, 0x00	; 0
    aa0a:	82 17       	cp	r24, r18
    aa0c:	93 07       	cpc	r25, r19
    aa0e:	a4 07       	cpc	r26, r20
    aa10:	b5 07       	cpc	r27, r21
    aa12:	08 f4       	brcc	.+2      	; 0xaa16 <Buf2Field+0x20a>
    aa14:	41 c2       	rjmp	.+1154   	; 0xae98 <Buf2Field+0x68c>
    aa16:	88 2d       	mov	r24, r8
    aa18:	90 e0       	ldi	r25, 0x00	; 0
    aa1a:	a0 e0       	ldi	r26, 0x00	; 0
    aa1c:	b0 e0       	ldi	r27, 0x00	; 0
    aa1e:	28 17       	cp	r18, r24
    aa20:	39 07       	cpc	r19, r25
    aa22:	4a 07       	cpc	r20, r26
    aa24:	5b 07       	cpc	r21, r27
    aa26:	08 f4       	brcc	.+2      	; 0xaa2a <Buf2Field+0x21e>
    aa28:	48 c0       	rjmp	.+144    	; 0xaaba <Buf2Field+0x2ae>
		break;
	case s_EE_Byte:
		SetEEField(sF_Buf, int8_t, uint8_t, b);
    aa2a:	c2 01       	movw	r24, r4
    aa2c:	62 2f       	mov	r22, r18
    aa2e:	0e 94 4e 4c 	call	0x989c	; 0x989c <ewb>
    aa32:	82 cf       	rjmp	.-252    	; 0xa938 <Buf2Field+0x12c>
	switch(prb(&Field->Type)) {
	case Byte: case z_Byte: case Enum:
		SetField(F_Buf, uint8_t);
		break;
	case s_Byte:
		SetField(sF_Buf, int8_t);
    aa34:	20 91 f9 04 	lds	r18, 0x04F9
    aa38:	30 91 fa 04 	lds	r19, 0x04FA
    aa3c:	40 91 fb 04 	lds	r20, 0x04FB
    aa40:	50 91 fc 04 	lds	r21, 0x04FC
    aa44:	8e 2d       	mov	r24, r14
    aa46:	99 27       	eor	r25, r25
    aa48:	87 fd       	sbrc	r24, 7
    aa4a:	90 95       	com	r25
    aa4c:	a9 2f       	mov	r26, r25
    aa4e:	b9 2f       	mov	r27, r25
    aa50:	82 17       	cp	r24, r18
    aa52:	93 07       	cpc	r25, r19
    aa54:	a4 07       	cpc	r26, r20
    aa56:	b5 07       	cpc	r27, r21
    aa58:	0c f4       	brge	.+2      	; 0xaa5c <Buf2Field+0x250>
    aa5a:	08 c2       	rjmp	.+1040   	; 0xae6c <Buf2Field+0x660>
    aa5c:	88 2d       	mov	r24, r8
    aa5e:	99 27       	eor	r25, r25
    aa60:	87 fd       	sbrc	r24, 7
    aa62:	90 95       	com	r25
    aa64:	a9 2f       	mov	r26, r25
    aa66:	b9 2f       	mov	r27, r25
    aa68:	28 17       	cp	r18, r24
    aa6a:	39 07       	cpc	r19, r25
    aa6c:	4a 07       	cpc	r20, r26
    aa6e:	5b 07       	cpc	r21, r27
    aa70:	0c f0       	brlt	.+2      	; 0xaa74 <Buf2Field+0x268>
    aa72:	17 c2       	rjmp	.+1070   	; 0xaea2 <Buf2Field+0x696>
    aa74:	d2 01       	movw	r26, r4
    aa76:	8c 92       	st	X, r8
    aa78:	5f cf       	rjmp	.-322    	; 0xa938 <Buf2Field+0x12c>
		break;
	case EE_Byte: case z_EE_Byte: case EE_Enum:
		SetEEField(F_Buf, uint8_t, uint8_t, b);
		break;
	case s_EE_Byte:
		SetEEField(sF_Buf, int8_t, uint8_t, b);
    aa7a:	20 91 f9 04 	lds	r18, 0x04F9
    aa7e:	30 91 fa 04 	lds	r19, 0x04FA
    aa82:	40 91 fb 04 	lds	r20, 0x04FB
    aa86:	50 91 fc 04 	lds	r21, 0x04FC
    aa8a:	8e 2d       	mov	r24, r14
    aa8c:	99 27       	eor	r25, r25
    aa8e:	87 fd       	sbrc	r24, 7
    aa90:	90 95       	com	r25
    aa92:	a9 2f       	mov	r26, r25
    aa94:	b9 2f       	mov	r27, r25
    aa96:	82 17       	cp	r24, r18
    aa98:	93 07       	cpc	r25, r19
    aa9a:	a4 07       	cpc	r26, r20
    aa9c:	b5 07       	cpc	r27, r21
    aa9e:	0c f4       	brge	.+2      	; 0xaaa2 <Buf2Field+0x296>
    aaa0:	fb c1       	rjmp	.+1014   	; 0xae98 <Buf2Field+0x68c>
    aaa2:	88 2d       	mov	r24, r8
    aaa4:	99 27       	eor	r25, r25
    aaa6:	87 fd       	sbrc	r24, 7
    aaa8:	90 95       	com	r25
    aaaa:	a9 2f       	mov	r26, r25
    aaac:	b9 2f       	mov	r27, r25
    aaae:	28 17       	cp	r18, r24
    aab0:	39 07       	cpc	r19, r25
    aab2:	4a 07       	cpc	r20, r26
    aab4:	5b 07       	cpc	r21, r27
    aab6:	0c f0       	brlt	.+2      	; 0xaaba <Buf2Field+0x2ae>
    aab8:	b8 cf       	rjmp	.-144    	; 0xaa2a <Buf2Field+0x21e>
    aaba:	c2 01       	movw	r24, r4
    aabc:	68 2d       	mov	r22, r8
    aabe:	0e 94 4e 4c 	call	0x989c	; 0x989c <ewb>
    aac2:	3a cf       	rjmp	.-396    	; 0xa938 <Buf2Field+0x12c>
		break;
	case Word: case z_Word:
		SetField(F_Buf, uint16_t);
    aac4:	20 91 f5 04 	lds	r18, 0x04F5
    aac8:	30 91 f6 04 	lds	r19, 0x04F6
    aacc:	40 91 f7 04 	lds	r20, 0x04F7
    aad0:	50 91 f8 04 	lds	r21, 0x04F8
    aad4:	c7 01       	movw	r24, r14
    aad6:	a0 e0       	ldi	r26, 0x00	; 0
    aad8:	b0 e0       	ldi	r27, 0x00	; 0
    aada:	82 17       	cp	r24, r18
    aadc:	93 07       	cpc	r25, r19
    aade:	a4 07       	cpc	r26, r20
    aae0:	b5 07       	cpc	r27, r21
    aae2:	08 f4       	brcc	.+2      	; 0xaae6 <Buf2Field+0x2da>
    aae4:	cc c1       	rjmp	.+920    	; 0xae7e <Buf2Field+0x672>
    aae6:	c4 01       	movw	r24, r8
    aae8:	a0 e0       	ldi	r26, 0x00	; 0
    aaea:	b0 e0       	ldi	r27, 0x00	; 0
    aaec:	28 17       	cp	r18, r24
    aaee:	39 07       	cpc	r19, r25
    aaf0:	4a 07       	cpc	r20, r26
    aaf2:	5b 07       	cpc	r21, r27
    aaf4:	08 f0       	brcs	.+2      	; 0xaaf8 <Buf2Field+0x2ec>
    aaf6:	d8 c1       	rjmp	.+944    	; 0xaea8 <Buf2Field+0x69c>
    aaf8:	f2 01       	movw	r30, r4
    aafa:	91 82       	std	Z+1, r9	; 0x01
    aafc:	80 82       	st	Z, r8
    aafe:	1c cf       	rjmp	.-456    	; 0xa938 <Buf2Field+0x12c>
		break;
	case EE_Word: case z_EE_Word:
		SetEEField(F_Buf, uint16_t, uint16_t, w);
    ab00:	20 91 f5 04 	lds	r18, 0x04F5
    ab04:	30 91 f6 04 	lds	r19, 0x04F6
    ab08:	40 91 f7 04 	lds	r20, 0x04F7
    ab0c:	50 91 f8 04 	lds	r21, 0x04F8
    ab10:	c7 01       	movw	r24, r14
    ab12:	a0 e0       	ldi	r26, 0x00	; 0
    ab14:	b0 e0       	ldi	r27, 0x00	; 0
    ab16:	82 17       	cp	r24, r18
    ab18:	93 07       	cpc	r25, r19
    ab1a:	a4 07       	cpc	r26, r20
    ab1c:	b5 07       	cpc	r27, r21
    ab1e:	08 f4       	brcc	.+2      	; 0xab22 <Buf2Field+0x316>
    ab20:	b6 c1       	rjmp	.+876    	; 0xae8e <Buf2Field+0x682>
    ab22:	c4 01       	movw	r24, r8
    ab24:	a0 e0       	ldi	r26, 0x00	; 0
    ab26:	b0 e0       	ldi	r27, 0x00	; 0
    ab28:	28 17       	cp	r18, r24
    ab2a:	39 07       	cpc	r19, r25
    ab2c:	4a 07       	cpc	r20, r26
    ab2e:	5b 07       	cpc	r21, r27
    ab30:	08 f4       	brcc	.+2      	; 0xab34 <Buf2Field+0x328>
    ab32:	45 c0       	rjmp	.+138    	; 0xabbe <Buf2Field+0x3b2>
		break;
	case s_Word:
		SetField(sF_Buf, int16_t);
		break;
	case s_EE_Word:
		SetEEField(sF_Buf, int16_t, uint16_t, w);
    ab34:	c2 01       	movw	r24, r4
    ab36:	b9 01       	movw	r22, r18
    ab38:	0e 94 91 4c 	call	0x9922	; 0x9922 <eww>
    ab3c:	fd ce       	rjmp	.-518    	; 0xa938 <Buf2Field+0x12c>
		break;
	case EE_Word: case z_EE_Word:
		SetEEField(F_Buf, uint16_t, uint16_t, w);
		break;
	case s_Word:
		SetField(sF_Buf, int16_t);
    ab3e:	20 91 f9 04 	lds	r18, 0x04F9
    ab42:	30 91 fa 04 	lds	r19, 0x04FA
    ab46:	40 91 fb 04 	lds	r20, 0x04FB
    ab4a:	50 91 fc 04 	lds	r21, 0x04FC
    ab4e:	c7 01       	movw	r24, r14
    ab50:	aa 27       	eor	r26, r26
    ab52:	97 fd       	sbrc	r25, 7
    ab54:	a0 95       	com	r26
    ab56:	ba 2f       	mov	r27, r26
    ab58:	82 17       	cp	r24, r18
    ab5a:	93 07       	cpc	r25, r19
    ab5c:	a4 07       	cpc	r26, r20
    ab5e:	b5 07       	cpc	r27, r21
    ab60:	0c f4       	brge	.+2      	; 0xab64 <Buf2Field+0x358>
    ab62:	91 c1       	rjmp	.+802    	; 0xae86 <Buf2Field+0x67a>
    ab64:	c4 01       	movw	r24, r8
    ab66:	aa 27       	eor	r26, r26
    ab68:	97 fd       	sbrc	r25, 7
    ab6a:	a0 95       	com	r26
    ab6c:	ba 2f       	mov	r27, r26
    ab6e:	28 17       	cp	r18, r24
    ab70:	39 07       	cpc	r19, r25
    ab72:	4a 07       	cpc	r20, r26
    ab74:	5b 07       	cpc	r21, r27
    ab76:	0c f0       	brlt	.+2      	; 0xab7a <Buf2Field+0x36e>
    ab78:	9b c1       	rjmp	.+822    	; 0xaeb0 <Buf2Field+0x6a4>
    ab7a:	d2 01       	movw	r26, r4
    ab7c:	8d 92       	st	X+, r8
    ab7e:	9c 92       	st	X, r9
    ab80:	db ce       	rjmp	.-586    	; 0xa938 <Buf2Field+0x12c>
		break;
	case s_EE_Word:
		SetEEField(sF_Buf, int16_t, uint16_t, w);
    ab82:	20 91 f9 04 	lds	r18, 0x04F9
    ab86:	30 91 fa 04 	lds	r19, 0x04FA
    ab8a:	40 91 fb 04 	lds	r20, 0x04FB
    ab8e:	50 91 fc 04 	lds	r21, 0x04FC
    ab92:	c7 01       	movw	r24, r14
    ab94:	aa 27       	eor	r26, r26
    ab96:	97 fd       	sbrc	r25, 7
    ab98:	a0 95       	com	r26
    ab9a:	ba 2f       	mov	r27, r26
    ab9c:	82 17       	cp	r24, r18
    ab9e:	93 07       	cpc	r25, r19
    aba0:	a4 07       	cpc	r26, r20
    aba2:	b5 07       	cpc	r27, r21
    aba4:	0c f4       	brge	.+2      	; 0xaba8 <Buf2Field+0x39c>
    aba6:	73 c1       	rjmp	.+742    	; 0xae8e <Buf2Field+0x682>
    aba8:	c4 01       	movw	r24, r8
    abaa:	aa 27       	eor	r26, r26
    abac:	97 fd       	sbrc	r25, 7
    abae:	a0 95       	com	r26
    abb0:	ba 2f       	mov	r27, r26
    abb2:	28 17       	cp	r18, r24
    abb4:	39 07       	cpc	r19, r25
    abb6:	4a 07       	cpc	r20, r26
    abb8:	5b 07       	cpc	r21, r27
    abba:	0c f0       	brlt	.+2      	; 0xabbe <Buf2Field+0x3b2>
    abbc:	bb cf       	rjmp	.-138    	; 0xab34 <Buf2Field+0x328>
    abbe:	c2 01       	movw	r24, r4
    abc0:	b4 01       	movw	r22, r8
    abc2:	0e 94 91 4c 	call	0x9922	; 0x9922 <eww>
    abc6:	b8 ce       	rjmp	.-656    	; 0xa938 <Buf2Field+0x12c>
		break;
	case c_Word: case zc_Word:
		*(uint16_t*)Var = F_Buf;
    abc8:	80 91 f5 04 	lds	r24, 0x04F5
    abcc:	90 91 f6 04 	lds	r25, 0x04F6
    abd0:	d2 01       	movw	r26, r4
    abd2:	8d 93       	st	X+, r24
    abd4:	9c 93       	st	X, r25
    abd6:	b0 ce       	rjmp	.-672    	; 0xa938 <Buf2Field+0x12c>
		break;


	case Longint: case z_Longint:
		//if(Limit_uByteVar(Temp)) sscanf(BufStr,"%ud", (unsigned short int*)&Temp);
		PresicionHanler(Field);
    abd8:	c6 01       	movw	r24, r12
    abda:	0e 94 c2 40 	call	0x8184	; 0x8184 <PresicionHanler>
		sscanf(BufStr,"%lud", (uint32_t*)&Temp);
    abde:	00 d0       	rcall	.+0      	; 0xabe0 <Buf2Field+0x3d4>
    abe0:	00 d0       	rcall	.+0      	; 0xabe2 <Buf2Field+0x3d6>
    abe2:	ed b7       	in	r30, 0x3d	; 61
    abe4:	fe b7       	in	r31, 0x3e	; 62
    abe6:	31 96       	adiw	r30, 0x01	; 1
    abe8:	81 ec       	ldi	r24, 0xC1	; 193
    abea:	95 e0       	ldi	r25, 0x05	; 5
    abec:	ad b7       	in	r26, 0x3d	; 61
    abee:	be b7       	in	r27, 0x3e	; 62
    abf0:	12 96       	adiw	r26, 0x02	; 2
    abf2:	9c 93       	st	X, r25
    abf4:	8e 93       	st	-X, r24
    abf6:	11 97       	sbiw	r26, 0x01	; 1
    abf8:	8f e9       	ldi	r24, 0x9F	; 159
    abfa:	92 e0       	ldi	r25, 0x02	; 2
    abfc:	93 83       	std	Z+3, r25	; 0x03
    abfe:	82 83       	std	Z+2, r24	; 0x02
    ac00:	ce 01       	movw	r24, r28
    ac02:	01 96       	adiw	r24, 0x01	; 1
    ac04:	95 83       	std	Z+5, r25	; 0x05
    ac06:	84 83       	std	Z+4, r24	; 0x04
    ac08:	0e 94 1b 81 	call	0x10236	; 0x10236 <sscanf>
		SetField32(Temp, uint32_t);
    ac0c:	89 81       	ldd	r24, Y+1	; 0x01
    ac0e:	9a 81       	ldd	r25, Y+2	; 0x02
    ac10:	ab 81       	ldd	r26, Y+3	; 0x03
    ac12:	bc 81       	ldd	r27, Y+4	; 0x04
    ac14:	ed b7       	in	r30, 0x3d	; 61
    ac16:	fe b7       	in	r31, 0x3e	; 62
    ac18:	36 96       	adiw	r30, 0x06	; 6
    ac1a:	0f b6       	in	r0, 0x3f	; 63
    ac1c:	f8 94       	cli
    ac1e:	fe bf       	out	0x3e, r31	; 62
    ac20:	0f be       	out	0x3f, r0	; 63
    ac22:	ed bf       	out	0x3d, r30	; 61
    ac24:	e8 16       	cp	r14, r24
    ac26:	f9 06       	cpc	r15, r25
    ac28:	0a 07       	cpc	r16, r26
    ac2a:	1b 07       	cpc	r17, r27
    ac2c:	08 f4       	brcc	.+2      	; 0xac30 <Buf2Field+0x424>
    ac2e:	17 c1       	rjmp	.+558    	; 0xae5e <Buf2Field+0x652>
    ac30:	88 15       	cp	r24, r8
    ac32:	99 05       	cpc	r25, r9
    ac34:	aa 05       	cpc	r26, r10
    ac36:	bb 05       	cpc	r27, r11
    ac38:	b8 f1       	brcs	.+110    	; 0xaca8 <Buf2Field+0x49c>
		break;
	case s_Longint:
		PresicionHanler(Field);
		//if(Limit_sByteVar(Temp)) sscanf(BufStr,"%hd", (short int*)&Temp);
		sscanf(BufStr,"%ld", (int32_t*)&Temp);
		SetField32(Temp, int32_t);
    ac3a:	f2 01       	movw	r30, r4
    ac3c:	80 83       	st	Z, r24
    ac3e:	91 83       	std	Z+1, r25	; 0x01
    ac40:	a2 83       	std	Z+2, r26	; 0x02
    ac42:	b3 83       	std	Z+3, r27	; 0x03
    ac44:	79 ce       	rjmp	.-782    	; 0xa938 <Buf2Field+0x12c>
		if(sscanf(BufStr,"%lud", (uint32_t*)&Temp) == 1){
			SetEEField32(Temp, uint32_t, uint32_t, d);
		}		
		break;
	case s_Longint:
		PresicionHanler(Field);
    ac46:	c6 01       	movw	r24, r12
    ac48:	0e 94 c2 40 	call	0x8184	; 0x8184 <PresicionHanler>
		//if(Limit_sByteVar(Temp)) sscanf(BufStr,"%hd", (short int*)&Temp);
		sscanf(BufStr,"%ld", (int32_t*)&Temp);
    ac4c:	00 d0       	rcall	.+0      	; 0xac4e <Buf2Field+0x442>
    ac4e:	00 d0       	rcall	.+0      	; 0xac50 <Buf2Field+0x444>
    ac50:	ed b7       	in	r30, 0x3d	; 61
    ac52:	fe b7       	in	r31, 0x3e	; 62
    ac54:	31 96       	adiw	r30, 0x01	; 1
    ac56:	81 ec       	ldi	r24, 0xC1	; 193
    ac58:	95 e0       	ldi	r25, 0x05	; 5
    ac5a:	ad b7       	in	r26, 0x3d	; 61
    ac5c:	be b7       	in	r27, 0x3e	; 62
    ac5e:	12 96       	adiw	r26, 0x02	; 2
    ac60:	9c 93       	st	X, r25
    ac62:	8e 93       	st	-X, r24
    ac64:	11 97       	sbiw	r26, 0x01	; 1
    ac66:	84 ea       	ldi	r24, 0xA4	; 164
    ac68:	92 e0       	ldi	r25, 0x02	; 2
    ac6a:	93 83       	std	Z+3, r25	; 0x03
    ac6c:	82 83       	std	Z+2, r24	; 0x02
    ac6e:	ce 01       	movw	r24, r28
    ac70:	01 96       	adiw	r24, 0x01	; 1
    ac72:	95 83       	std	Z+5, r25	; 0x05
    ac74:	84 83       	std	Z+4, r24	; 0x04
    ac76:	0e 94 1b 81 	call	0x10236	; 0x10236 <sscanf>
		SetField32(Temp, int32_t);
    ac7a:	89 81       	ldd	r24, Y+1	; 0x01
    ac7c:	9a 81       	ldd	r25, Y+2	; 0x02
    ac7e:	ab 81       	ldd	r26, Y+3	; 0x03
    ac80:	bc 81       	ldd	r27, Y+4	; 0x04
    ac82:	ed b7       	in	r30, 0x3d	; 61
    ac84:	fe b7       	in	r31, 0x3e	; 62
    ac86:	36 96       	adiw	r30, 0x06	; 6
    ac88:	0f b6       	in	r0, 0x3f	; 63
    ac8a:	f8 94       	cli
    ac8c:	fe bf       	out	0x3e, r31	; 62
    ac8e:	0f be       	out	0x3f, r0	; 63
    ac90:	ed bf       	out	0x3d, r30	; 61
    ac92:	e8 16       	cp	r14, r24
    ac94:	f9 06       	cpc	r15, r25
    ac96:	0a 07       	cpc	r16, r26
    ac98:	1b 07       	cpc	r17, r27
    ac9a:	0c f4       	brge	.+2      	; 0xac9e <Buf2Field+0x492>
    ac9c:	e0 c0       	rjmp	.+448    	; 0xae5e <Buf2Field+0x652>
    ac9e:	88 15       	cp	r24, r8
    aca0:	99 05       	cpc	r25, r9
    aca2:	aa 05       	cpc	r26, r10
    aca4:	bb 05       	cpc	r27, r11
    aca6:	4c f6       	brge	.-110    	; 0xac3a <Buf2Field+0x42e>
    aca8:	f2 01       	movw	r30, r4
    acaa:	80 82       	st	Z, r8
    acac:	91 82       	std	Z+1, r9	; 0x01
    acae:	a2 82       	std	Z+2, r10	; 0x02
    acb0:	b3 82       	std	Z+3, r11	; 0x03
    acb2:	42 ce       	rjmp	.-892    	; 0xa938 <Buf2Field+0x12c>
		break;
	case s_EE_Longint:
		PresicionHanler(Field);
    acb4:	c6 01       	movw	r24, r12
    acb6:	0e 94 c2 40 	call	0x8184	; 0x8184 <PresicionHanler>
		if(sscanf(BufStr,"%ld", (int32_t*)&Temp) == 1){
    acba:	00 d0       	rcall	.+0      	; 0xacbc <Buf2Field+0x4b0>
    acbc:	00 d0       	rcall	.+0      	; 0xacbe <Buf2Field+0x4b2>
    acbe:	ed b7       	in	r30, 0x3d	; 61
    acc0:	fe b7       	in	r31, 0x3e	; 62
    acc2:	31 96       	adiw	r30, 0x01	; 1
    acc4:	81 ec       	ldi	r24, 0xC1	; 193
    acc6:	95 e0       	ldi	r25, 0x05	; 5
    acc8:	ad b7       	in	r26, 0x3d	; 61
    acca:	be b7       	in	r27, 0x3e	; 62
    accc:	12 96       	adiw	r26, 0x02	; 2
    acce:	9c 93       	st	X, r25
    acd0:	8e 93       	st	-X, r24
    acd2:	11 97       	sbiw	r26, 0x01	; 1
    acd4:	84 ea       	ldi	r24, 0xA4	; 164
    acd6:	92 e0       	ldi	r25, 0x02	; 2
    acd8:	93 83       	std	Z+3, r25	; 0x03
    acda:	82 83       	std	Z+2, r24	; 0x02
    acdc:	ce 01       	movw	r24, r28
    acde:	01 96       	adiw	r24, 0x01	; 1
    ace0:	95 83       	std	Z+5, r25	; 0x05
    ace2:	84 83       	std	Z+4, r24	; 0x04
    ace4:	0e 94 1b 81 	call	0x10236	; 0x10236 <sscanf>
    ace8:	ed b7       	in	r30, 0x3d	; 61
    acea:	fe b7       	in	r31, 0x3e	; 62
    acec:	36 96       	adiw	r30, 0x06	; 6
    acee:	0f b6       	in	r0, 0x3f	; 63
    acf0:	f8 94       	cli
    acf2:	fe bf       	out	0x3e, r31	; 62
    acf4:	0f be       	out	0x3f, r0	; 63
    acf6:	ed bf       	out	0x3d, r30	; 61
    acf8:	01 97       	sbiw	r24, 0x01	; 1
    acfa:	09 f0       	breq	.+2      	; 0xacfe <Buf2Field+0x4f2>
    acfc:	1d ce       	rjmp	.-966    	; 0xa938 <Buf2Field+0x12c>
			SetEEField32(Temp, int32_t, uint32_t, d);
    acfe:	49 81       	ldd	r20, Y+1	; 0x01
    ad00:	5a 81       	ldd	r21, Y+2	; 0x02
    ad02:	6b 81       	ldd	r22, Y+3	; 0x03
    ad04:	7c 81       	ldd	r23, Y+4	; 0x04
    ad06:	ca 01       	movw	r24, r20
    ad08:	db 01       	movw	r26, r22
    ad0a:	e8 16       	cp	r14, r24
    ad0c:	f9 06       	cpc	r15, r25
    ad0e:	0a 07       	cpc	r16, r26
    ad10:	1b 07       	cpc	r17, r27
    ad12:	0c f4       	brge	.+2      	; 0xad16 <Buf2Field+0x50a>
    ad14:	d4 c0       	rjmp	.+424    	; 0xaebe <Buf2Field+0x6b2>
    ad16:	88 15       	cp	r24, r8
    ad18:	99 05       	cpc	r25, r9
    ad1a:	aa 05       	cpc	r26, r10
    ad1c:	bb 05       	cpc	r27, r11
    ad1e:	0c f0       	brlt	.+2      	; 0xad22 <Buf2Field+0x516>
    ad20:	08 ce       	rjmp	.-1008   	; 0xa932 <Buf2Field+0x126>
    ad22:	c2 01       	movw	r24, r4
    ad24:	b5 01       	movw	r22, r10
    ad26:	a4 01       	movw	r20, r8
    ad28:	0e 94 c8 4d 	call	0x9b90	; 0x9b90 <ewd>
    ad2c:	05 ce       	rjmp	.-1014   	; 0xa938 <Buf2Field+0x12c>
		}
		break;


	case FFloat: case GFloat:
		sscanf(BufStr,"%f", &fTemp);
    ad2e:	00 d0       	rcall	.+0      	; 0xad30 <Buf2Field+0x524>
    ad30:	00 d0       	rcall	.+0      	; 0xad32 <Buf2Field+0x526>
    ad32:	ed b7       	in	r30, 0x3d	; 61
    ad34:	fe b7       	in	r31, 0x3e	; 62
    ad36:	31 96       	adiw	r30, 0x01	; 1
    ad38:	81 ec       	ldi	r24, 0xC1	; 193
    ad3a:	95 e0       	ldi	r25, 0x05	; 5
    ad3c:	ad b7       	in	r26, 0x3d	; 61
    ad3e:	be b7       	in	r27, 0x3e	; 62
    ad40:	12 96       	adiw	r26, 0x02	; 2
    ad42:	9c 93       	st	X, r25
    ad44:	8e 93       	st	-X, r24
    ad46:	11 97       	sbiw	r26, 0x01	; 1
    ad48:	88 ea       	ldi	r24, 0xA8	; 168
    ad4a:	92 e0       	ldi	r25, 0x02	; 2
    ad4c:	93 83       	std	Z+3, r25	; 0x03
    ad4e:	82 83       	std	Z+2, r24	; 0x02
    ad50:	ce 01       	movw	r24, r28
    ad52:	05 96       	adiw	r24, 0x05	; 5
    ad54:	95 83       	std	Z+5, r25	; 0x05
    ad56:	84 83       	std	Z+4, r24	; 0x04
    ad58:	0e 94 1b 81 	call	0x10236	; 0x10236 <sscanf>
		*(float*)Var = fTemp;
    ad5c:	8d 81       	ldd	r24, Y+5	; 0x05
    ad5e:	9e 81       	ldd	r25, Y+6	; 0x06
    ad60:	af 81       	ldd	r26, Y+7	; 0x07
    ad62:	b8 85       	ldd	r27, Y+8	; 0x08
    ad64:	f2 01       	movw	r30, r4
    ad66:	80 83       	st	Z, r24
    ad68:	91 83       	std	Z+1, r25	; 0x01
    ad6a:	a2 83       	std	Z+2, r26	; 0x02
    ad6c:	b3 83       	std	Z+3, r27	; 0x03
    ad6e:	2d b7       	in	r18, 0x3d	; 61
    ad70:	3e b7       	in	r19, 0x3e	; 62
    ad72:	2a 5f       	subi	r18, 0xFA	; 250
    ad74:	3f 4f       	sbci	r19, 0xFF	; 255
    ad76:	0f b6       	in	r0, 0x3f	; 63
    ad78:	f8 94       	cli
    ad7a:	3e bf       	out	0x3e, r19	; 62
    ad7c:	0f be       	out	0x3f, r0	; 63
    ad7e:	2d bf       	out	0x3d, r18	; 61
    ad80:	db cd       	rjmp	.-1098   	; 0xa938 <Buf2Field+0x12c>
		break;
	case EE_FFloat: case EE_GFloat:
		if(sscanf(BufStr,"%f", &fTemp) == 1){
    ad82:	00 d0       	rcall	.+0      	; 0xad84 <Buf2Field+0x578>
    ad84:	00 d0       	rcall	.+0      	; 0xad86 <Buf2Field+0x57a>
    ad86:	ed b7       	in	r30, 0x3d	; 61
    ad88:	fe b7       	in	r31, 0x3e	; 62
    ad8a:	31 96       	adiw	r30, 0x01	; 1
    ad8c:	81 ec       	ldi	r24, 0xC1	; 193
    ad8e:	95 e0       	ldi	r25, 0x05	; 5
    ad90:	ad b7       	in	r26, 0x3d	; 61
    ad92:	be b7       	in	r27, 0x3e	; 62
    ad94:	12 96       	adiw	r26, 0x02	; 2
    ad96:	9c 93       	st	X, r25
    ad98:	8e 93       	st	-X, r24
    ad9a:	11 97       	sbiw	r26, 0x01	; 1
    ad9c:	88 ea       	ldi	r24, 0xA8	; 168
    ad9e:	92 e0       	ldi	r25, 0x02	; 2
    ada0:	93 83       	std	Z+3, r25	; 0x03
    ada2:	82 83       	std	Z+2, r24	; 0x02
    ada4:	8e 01       	movw	r16, r28
    ada6:	0b 5f       	subi	r16, 0xFB	; 251
    ada8:	1f 4f       	sbci	r17, 0xFF	; 255
    adaa:	15 83       	std	Z+5, r17	; 0x05
    adac:	04 83       	std	Z+4, r16	; 0x04
    adae:	0e 94 1b 81 	call	0x10236	; 0x10236 <sscanf>
    adb2:	ed b7       	in	r30, 0x3d	; 61
    adb4:	fe b7       	in	r31, 0x3e	; 62
    adb6:	36 96       	adiw	r30, 0x06	; 6
    adb8:	0f b6       	in	r0, 0x3f	; 63
    adba:	f8 94       	cli
    adbc:	fe bf       	out	0x3e, r31	; 62
    adbe:	0f be       	out	0x3f, r0	; 63
    adc0:	ed bf       	out	0x3d, r30	; 61
    adc2:	01 97       	sbiw	r24, 0x01	; 1
    adc4:	09 f0       	breq	.+2      	; 0xadc8 <Buf2Field+0x5bc>
    adc6:	b8 cd       	rjmp	.-1168   	; 0xa938 <Buf2Field+0x12c>
			ewbl(&fTemp, (float*)Var, 4);
    adc8:	c8 01       	movw	r24, r16
    adca:	b2 01       	movw	r22, r4
    adcc:	44 e0       	ldi	r20, 0x04	; 4
    adce:	50 e0       	ldi	r21, 0x00	; 0
    add0:	0e 94 c3 4d 	call	0x9b86	; 0x9b86 <ewbl>
    add4:	b1 cd       	rjmp	.-1182   	; 0xa938 <Buf2Field+0x12c>
		}
		break;


	case Bit:
		if(F_Buf)
    add6:	80 91 f5 04 	lds	r24, 0x04F5
    adda:	90 91 f6 04 	lds	r25, 0x04F6
    adde:	a0 91 f7 04 	lds	r26, 0x04F7
    ade2:	b0 91 f8 04 	lds	r27, 0x04F8
    ade6:	00 97       	sbiw	r24, 0x00	; 0
    ade8:	a1 05       	cpc	r26, r1
    adea:	b1 05       	cpc	r27, r1
    adec:	91 f1       	breq	.+100    	; 0xae52 <Buf2Field+0x646>
			*BitVar |=Mask;
    adee:	d3 01       	movw	r26, r6
    adf0:	8c 91       	ld	r24, X
    adf2:	83 29       	or	r24, r3
    adf4:	8c 93       	st	X, r24
    adf6:	a0 cd       	rjmp	.-1216   	; 0xa938 <Buf2Field+0x12c>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    adf8:	c3 01       	movw	r24, r6
    adfa:	0e 94 e7 82 	call	0x105ce	; 0x105ce <__eerd_byte_m2560>
    adfe:	28 2f       	mov	r18, r24
		else
			*BitVar &=~Mask;
		break;
	case EE_Bit:
		EE_BitVar=erb(BitVar);
		ewb(BitVar, F_Buf ? EE_BitVar |Mask : EE_BitVar &~Mask);
    ae00:	80 91 f5 04 	lds	r24, 0x04F5
    ae04:	90 91 f6 04 	lds	r25, 0x04F6
    ae08:	a0 91 f7 04 	lds	r26, 0x04F7
    ae0c:	b0 91 f8 04 	lds	r27, 0x04F8
    ae10:	00 97       	sbiw	r24, 0x00	; 0
    ae12:	a1 05       	cpc	r26, r1
    ae14:	b1 05       	cpc	r27, r1
    ae16:	d1 f4       	brne	.+52     	; 0xae4c <Buf2Field+0x640>
    ae18:	63 2d       	mov	r22, r3
    ae1a:	60 95       	com	r22
    ae1c:	62 23       	and	r22, r18
    ae1e:	c3 01       	movw	r24, r6
    ae20:	0e 94 4e 4c 	call	0x989c	; 0x989c <ewb>
    ae24:	89 cd       	rjmp	.-1262   	; 0xa938 <Buf2Field+0x12c>
		break;


	case Text:{
		//    
		uint8_t Field_width = strlen((char*)Var);
    ae26:	f2 01       	movw	r30, r4
    ae28:	01 90       	ld	r0, Z+
    ae2a:	00 20       	and	r0, r0
    ae2c:	e9 f7       	brne	.-6      	; 0xae28 <Buf2Field+0x61c>
    ae2e:	31 97       	sbiw	r30, 0x01	; 1
    ae30:	4e 2f       	mov	r20, r30
    ae32:	44 19       	sub	r20, r4
		if(Field_width > LCDXSz) Field_width = LCDXSz+1;
    ae34:	45 31       	cpi	r20, 0x15	; 21
    ae36:	e8 f0       	brcs	.+58     	; 0xae72 <Buf2Field+0x666>
    ae38:	e5 e1       	ldi	r30, 0x15	; 21
    ae3a:	f0 e0       	ldi	r31, 0x00	; 0
		memcpy(Var,BufStr,Field_width);
    ae3c:	21 ec       	ldi	r18, 0xC1	; 193
    ae3e:	35 e0       	ldi	r19, 0x05	; 5
    ae40:	c2 01       	movw	r24, r4
    ae42:	b9 01       	movw	r22, r18
    ae44:	af 01       	movw	r20, r30
    ae46:	0e 94 09 80 	call	0x10012	; 0x10012 <memcpy>
    ae4a:	76 cd       	rjmp	.-1300   	; 0xa938 <Buf2Field+0x12c>
		else
			*BitVar &=~Mask;
		break;
	case EE_Bit:
		EE_BitVar=erb(BitVar);
		ewb(BitVar, F_Buf ? EE_BitVar |Mask : EE_BitVar &~Mask);
    ae4c:	63 2d       	mov	r22, r3
    ae4e:	62 2b       	or	r22, r18
    ae50:	e6 cf       	rjmp	.-52     	; 0xae1e <Buf2Field+0x612>

	case Bit:
		if(F_Buf)
			*BitVar |=Mask;
		else
			*BitVar &=~Mask;
    ae52:	30 94       	com	r3
    ae54:	f3 01       	movw	r30, r6
    ae56:	80 81       	ld	r24, Z
    ae58:	83 21       	and	r24, r3
    ae5a:	80 83       	st	Z, r24
    ae5c:	6d cd       	rjmp	.-1318   	; 0xa938 <Buf2Field+0x12c>
		break;
	case s_Longint:
		PresicionHanler(Field);
		//if(Limit_sByteVar(Temp)) sscanf(BufStr,"%hd", (short int*)&Temp);
		sscanf(BufStr,"%ld", (int32_t*)&Temp);
		SetField32(Temp, int32_t);
    ae5e:	d2 01       	movw	r26, r4
    ae60:	ed 92       	st	X+, r14
    ae62:	fd 92       	st	X+, r15
    ae64:	0d 93       	st	X+, r16
    ae66:	1c 93       	st	X, r17
    ae68:	13 97       	sbiw	r26, 0x03	; 3
    ae6a:	66 cd       	rjmp	.-1332   	; 0xa938 <Buf2Field+0x12c>
	switch(prb(&Field->Type)) {
	case Byte: case z_Byte: case Enum:
		SetField(F_Buf, uint8_t);
		break;
	case s_Byte:
		SetField(sF_Buf, int8_t);
    ae6c:	f2 01       	movw	r30, r4
    ae6e:	e0 82       	st	Z, r14
    ae70:	63 cd       	rjmp	.-1338   	; 0xa938 <Buf2Field+0x12c>


	case Text:{
		//    
		uint8_t Field_width = strlen((char*)Var);
		if(Field_width > LCDXSz) Field_width = LCDXSz+1;
    ae72:	e4 2f       	mov	r30, r20
    ae74:	f0 e0       	ldi	r31, 0x00	; 0
    ae76:	e2 cf       	rjmp	.-60     	; 0xae3c <Buf2Field+0x630>
	uint32_t Temp=0;
	float fTemp=0;

	switch(prb(&Field->Type)) {
	case Byte: case z_Byte: case Enum:
		SetField(F_Buf, uint8_t);
    ae78:	d2 01       	movw	r26, r4
    ae7a:	ec 92       	st	X, r14
    ae7c:	5d cd       	rjmp	.-1350   	; 0xa938 <Buf2Field+0x12c>
		break;
	case s_EE_Byte:
		SetEEField(sF_Buf, int8_t, uint8_t, b);
		break;
	case Word: case z_Word:
		SetField(F_Buf, uint16_t);
    ae7e:	d2 01       	movw	r26, r4
    ae80:	ed 92       	st	X+, r14
    ae82:	fc 92       	st	X, r15
    ae84:	59 cd       	rjmp	.-1358   	; 0xa938 <Buf2Field+0x12c>
		break;
	case EE_Word: case z_EE_Word:
		SetEEField(F_Buf, uint16_t, uint16_t, w);
		break;
	case s_Word:
		SetField(sF_Buf, int16_t);
    ae86:	f2 01       	movw	r30, r4
    ae88:	f1 82       	std	Z+1, r15	; 0x01
    ae8a:	e0 82       	st	Z, r14
    ae8c:	55 cd       	rjmp	.-1366   	; 0xa938 <Buf2Field+0x12c>
		break;
	case s_EE_Word:
		SetEEField(sF_Buf, int16_t, uint16_t, w);
    ae8e:	c2 01       	movw	r24, r4
    ae90:	b7 01       	movw	r22, r14
    ae92:	0e 94 91 4c 	call	0x9922	; 0x9922 <eww>
    ae96:	50 cd       	rjmp	.-1376   	; 0xa938 <Buf2Field+0x12c>
		break;
	case EE_Byte: case z_EE_Byte: case EE_Enum:
		SetEEField(F_Buf, uint8_t, uint8_t, b);
		break;
	case s_EE_Byte:
		SetEEField(sF_Buf, int8_t, uint8_t, b);
    ae98:	c2 01       	movw	r24, r4
    ae9a:	6e 2d       	mov	r22, r14
    ae9c:	0e 94 4e 4c 	call	0x989c	; 0x989c <ewb>
    aea0:	4b cd       	rjmp	.-1386   	; 0xa938 <Buf2Field+0x12c>
	switch(prb(&Field->Type)) {
	case Byte: case z_Byte: case Enum:
		SetField(F_Buf, uint8_t);
		break;
	case s_Byte:
		SetField(sF_Buf, int8_t);
    aea2:	f2 01       	movw	r30, r4
    aea4:	20 83       	st	Z, r18
    aea6:	48 cd       	rjmp	.-1392   	; 0xa938 <Buf2Field+0x12c>
		break;
	case s_EE_Byte:
		SetEEField(sF_Buf, int8_t, uint8_t, b);
		break;
	case Word: case z_Word:
		SetField(F_Buf, uint16_t);
    aea8:	d2 01       	movw	r26, r4
    aeaa:	2d 93       	st	X+, r18
    aeac:	3c 93       	st	X, r19
    aeae:	44 cd       	rjmp	.-1400   	; 0xa938 <Buf2Field+0x12c>
		break;
	case EE_Word: case z_EE_Word:
		SetEEField(F_Buf, uint16_t, uint16_t, w);
		break;
	case s_Word:
		SetField(sF_Buf, int16_t);
    aeb0:	f2 01       	movw	r30, r4
    aeb2:	31 83       	std	Z+1, r19	; 0x01
    aeb4:	20 83       	st	Z, r18
    aeb6:	40 cd       	rjmp	.-1408   	; 0xa938 <Buf2Field+0x12c>
	uint32_t Temp=0;
	float fTemp=0;

	switch(prb(&Field->Type)) {
	case Byte: case z_Byte: case Enum:
		SetField(F_Buf, uint8_t);
    aeb8:	d2 01       	movw	r26, r4
    aeba:	2c 93       	st	X, r18
    aebc:	3d cd       	rjmp	.-1414   	; 0xa938 <Buf2Field+0x12c>
		SetField32(Temp, int32_t);
		break;
	case s_EE_Longint:
		PresicionHanler(Field);
		if(sscanf(BufStr,"%ld", (int32_t*)&Temp) == 1){
			SetEEField32(Temp, int32_t, uint32_t, d);
    aebe:	c2 01       	movw	r24, r4
    aec0:	b8 01       	movw	r22, r16
    aec2:	a7 01       	movw	r20, r14
    aec4:	0e 94 c8 4d 	call	0x9b90	; 0x9b90 <ewd>
    aec8:	37 cd       	rjmp	.-1426   	; 0xa938 <Buf2Field+0x12c>

0000aeca <MenuEnterRight>:
}

// ~~~~~~~~~~~~~~~~~
void
MenuEnterRight(void)
{
    aeca:	ef 92       	push	r14
    aecc:	ff 92       	push	r15
    aece:	0f 93       	push	r16
    aed0:	1f 93       	push	r17
    aed2:	cf 93       	push	r28
    aed4:	df 93       	push	r29
//	1) Hide current Message
	if(HideMsg()||KeyFunc(&CurrPage->Enter))
    aed6:	0e 94 f5 3c 	call	0x79ea	; 0x79ea <HideMsg>
    aeda:	88 23       	and	r24, r24
    aedc:	39 f0       	breq	.+14     	; 0xaeec <MenuEnterRight+0x22>
	if(NextPage || (NextPage=prp(&Line->InnPage))) {
		GotoMenu(NextPage);
		NextPage=NULL;
		return;
	}
}
    aede:	df 91       	pop	r29
    aee0:	cf 91       	pop	r28
    aee2:	1f 91       	pop	r17
    aee4:	0f 91       	pop	r16
    aee6:	ff 90       	pop	r15
    aee8:	ef 90       	pop	r14
    aeea:	08 95       	ret
// ~~~~~~~~~~~~~~~~~
void
MenuEnterRight(void)
{
//	1) Hide current Message
	if(HideMsg()||KeyFunc(&CurrPage->Enter))
    aeec:	80 91 d4 02 	lds	r24, 0x02D4
    aef0:	90 91 d5 02 	lds	r25, 0x02D5
    aef4:	0c 96       	adiw	r24, 0x0c	; 12
    aef6:	0e 94 9b 3c 	call	0x7936	; 0x7936 <KeyFunc>
    aefa:	88 23       	and	r24, r24
    aefc:	81 f7       	brne	.-32     	; 0xaede <MenuEnterRight+0x14>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    aefe:	40 91 d4 02 	lds	r20, 0x02D4
    af02:	50 91 d5 02 	lds	r21, 0x02D5
    af06:	fa 01       	movw	r30, r20
    af08:	c5 91       	lpm	r28, Z+
    af0a:	d4 91       	lpm	r29, Z+
		return;

	MenuLine *Line=GetLine+CurrLine;
    af0c:	90 91 83 07 	lds	r25, 0x0783
    af10:	8b e1       	ldi	r24, 0x1B	; 27
    af12:	98 9f       	mul	r25, r24
    af14:	b0 01       	movw	r22, r0
    af16:	11 24       	eor	r1, r1
    af18:	c6 0f       	add	r28, r22
    af1a:	d7 1f       	adc	r29, r23
    af1c:	fe 01       	movw	r30, r28
    af1e:	77 96       	adiw	r30, 0x17	; 23
    af20:	e5 90       	lpm	r14, Z+
    af22:	f4 90       	lpm	r15, Z+
	OutField *Field=prp(&Line->OF_List);

// 2) Variable
	if(Field){
    af24:	e1 14       	cp	r14, r1
    af26:	f1 04       	cpc	r15, r1
    af28:	09 f4       	brne	.+2      	; 0xaf2c <MenuEnterRight+0x62>
    af2a:	93 c0       	rjmp	.+294    	; 0xb052 <MenuEnterRight+0x188>
    af2c:	10 e0       	ldi	r17, 0x00	; 0
    af2e:	30 e0       	ldi	r19, 0x00	; 0
    af30:	80 e0       	ldi	r24, 0x00	; 0
    af32:	90 e0       	ldi	r25, 0x00	; 0
    af34:	05 c0       	rjmp	.+10     	; 0xaf40 <MenuEnterRight+0x76>
		uint8_t i=0;
		while(i<LCDXSz) {
			Char1 = Char2;
			Char2 = prc(CurrStr+i++);
			if (Char2=='}' && Char1!='}')
				FieldNumber++;
    af36:	01 96       	adiw	r24, 0x01	; 1
	// Define variable quantity 
		uint8_t FieldNumber = 0;
		PGM_P CurrStr=(PGM_P)(Line->Str);
		char Char1, Char2=0;
		uint8_t i=0;
		while(i<LCDXSz) {
    af38:	84 31       	cpi	r24, 0x14	; 20
    af3a:	91 05       	cpc	r25, r1
    af3c:	71 f0       	breq	.+28     	; 0xaf5a <MenuEnterRight+0x90>
    af3e:	32 2f       	mov	r19, r18

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    af40:	fe 01       	movw	r30, r28
    af42:	e8 0f       	add	r30, r24
    af44:	f9 1f       	adc	r31, r25
    af46:	24 91       	lpm	r18, Z+
			Char1 = Char2;
			Char2 = prc(CurrStr+i++);
			if (Char2=='}' && Char1!='}')
    af48:	2d 37       	cpi	r18, 0x7D	; 125
    af4a:	a9 f7       	brne	.-22     	; 0xaf36 <MenuEnterRight+0x6c>
    af4c:	3d 37       	cpi	r19, 0x7D	; 125
    af4e:	99 f3       	breq	.-26     	; 0xaf36 <MenuEnterRight+0x6c>
				FieldNumber++;
    af50:	1f 5f       	subi	r17, 0xFF	; 255
    af52:	01 96       	adiw	r24, 0x01	; 1
	// Define variable quantity 
		uint8_t FieldNumber = 0;
		PGM_P CurrStr=(PGM_P)(Line->Str);
		char Char1, Char2=0;
		uint8_t i=0;
		while(i<LCDXSz) {
    af54:	84 31       	cpi	r24, 0x14	; 20
    af56:	91 05       	cpc	r25, r1
    af58:	91 f7       	brne	.-28     	; 0xaf3e <MenuEnterRight+0x74>
			Char2 = prc(CurrStr+i++);
			if (Char2=='}' && Char1!='}')
				FieldNumber++;
		}
		//    Bit (:)   
		if(FieldNumber==1 && prb(&Field->Type)==Bit) {
    af5a:	11 30       	cpi	r17, 0x01	; 1
    af5c:	09 f4       	brne	.+2      	; 0xaf60 <MenuEnterRight+0x96>
    af5e:	b8 c0       	rjmp	.+368    	; 0xb0d0 <MenuEnterRight+0x206>
			EventFunc(&Field->Act);
			return;
		}

	//    
		if(CurrPos!=NullPos && --CurrPos!=NullPos){
    af60:	80 91 d7 02 	lds	r24, 0x02D7
    af64:	8f 3f       	cpi	r24, 0xFF	; 255
    af66:	09 f4       	brne	.+2      	; 0xaf6a <MenuEnterRight+0xa0>
    af68:	4a c0       	rjmp	.+148    	; 0xaffe <MenuEnterRight+0x134>
    af6a:	08 2f       	mov	r16, r24
    af6c:	01 50       	subi	r16, 0x01	; 1
    af6e:	00 93 d7 02 	sts	0x02D7, r16
    af72:	0f 3f       	cpi	r16, 0xFF	; 255
    af74:	09 f4       	brne	.+2      	; 0xaf78 <MenuEnterRight+0xae>
    af76:	43 c0       	rjmp	.+134    	; 0xaffe <MenuEnterRight+0x134>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    af78:	fa 01       	movw	r30, r20
    af7a:	45 91       	lpm	r20, Z+
    af7c:	54 91       	lpm	r21, Z+
			OutField *Field1=GetField;
    af7e:	46 0f       	add	r20, r22
    af80:	57 1f       	adc	r21, r23
    af82:	49 5e       	subi	r20, 0xE9	; 233
    af84:	5f 4f       	sbci	r21, 0xFF	; 255
    af86:	fa 01       	movw	r30, r20
    af88:	25 91       	lpm	r18, Z+
    af8a:	34 91       	lpm	r19, Z+
    af8c:	80 91 d6 02 	lds	r24, 0x02D6
    af90:	90 e0       	ldi	r25, 0x00	; 0
    af92:	82 95       	swap	r24
    af94:	92 95       	swap	r25
    af96:	90 7f       	andi	r25, 0xF0	; 240
    af98:	98 27       	eor	r25, r24
    af9a:	80 7f       	andi	r24, 0xF0	; 240
    af9c:	98 27       	eor	r25, r24
    af9e:	28 0f       	add	r18, r24
    afa0:	39 1f       	adc	r19, r25

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    afa2:	f9 01       	movw	r30, r18
    afa4:	84 91       	lpm	r24, Z+
			switch(prb(&Field1->Type)){
    afa6:	8d 31       	cpi	r24, 0x1D	; 29
    afa8:	08 f4       	brcc	.+2      	; 0xafac <MenuEnterRight+0xe2>
    afaa:	67 c0       	rjmp	.+206    	; 0xb07a <MenuEnterRight+0x1b0>
    afac:	81 52       	subi	r24, 0x21	; 33
    afae:	82 30       	cpi	r24, 0x02	; 2
    afb0:	08 f0       	brcs	.+2      	; 0xafb4 <MenuEnterRight+0xea>
    afb2:	95 cf       	rjmp	.-214    	; 0xaede <MenuEnterRight+0x14>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    afb4:	f9 01       	movw	r30, r18
    afb6:	33 96       	adiw	r30, 0x03	; 3
    afb8:	85 91       	lpm	r24, Z+
    afba:	95 91       	lpm	r25, Z+
    afbc:	a5 91       	lpm	r26, Z+
    afbe:	b4 91       	lpm	r27, Z+
			case Text: case EE_Text:
				if( (prd(&Field1->Min) == DIGIT) && (prd(&Field1->Max) == DIGIT) )
    afc0:	00 97       	sbiw	r24, 0x00	; 0
    afc2:	a1 05       	cpc	r26, r1
    afc4:	b1 05       	cpc	r27, r1
    afc6:	59 f4       	brne	.+22     	; 0xafde <MenuEnterRight+0x114>
    afc8:	f9 01       	movw	r30, r18
    afca:	37 96       	adiw	r30, 0x07	; 7
    afcc:	85 91       	lpm	r24, Z+
    afce:	95 91       	lpm	r25, Z+
    afd0:	a5 91       	lpm	r26, Z+
    afd2:	b4 91       	lpm	r27, Z+
    afd4:	00 97       	sbiw	r24, 0x00	; 0
    afd6:	a1 05       	cpc	r26, r1
    afd8:	b1 05       	cpc	r27, r1
    afda:	09 f4       	brne	.+2      	; 0xafde <MenuEnterRight+0x114>
    afdc:	a3 c0       	rjmp	.+326    	; 0xb124 <MenuEnterRight+0x25a>
					MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[CurrFieldSize - 1 - CurrPos]);
				else MultiSymbol = GetMultiSymbol(Symbols_P, BufStr[CurrFieldSize - 1 - CurrPos]);
    afde:	e0 91 7a 07 	lds	r30, 0x077A
    afe2:	f0 e0       	ldi	r31, 0x00	; 0
    afe4:	31 97       	sbiw	r30, 0x01	; 1
    afe6:	e0 1b       	sub	r30, r16
    afe8:	f1 09       	sbc	r31, r1
    afea:	ef 53       	subi	r30, 0x3F	; 63
    afec:	fa 4f       	sbci	r31, 0xFA	; 250
    afee:	85 e0       	ldi	r24, 0x05	; 5
    aff0:	96 e0       	ldi	r25, 0x06	; 6
    aff2:	60 81       	ld	r22, Z
    aff4:	0e 94 fc 40 	call	0x81f8	; 0x81f8 <GetMultiSymbol>
    aff8:	80 93 f2 04 	sts	0x04F2, r24
    affc:	70 cf       	rjmp	.-288    	; 0xaede <MenuEnterRight+0x14>
				break;		
			}
			return;
		}

		if(CurrField!=NullPos) {
    affe:	80 91 d6 02 	lds	r24, 0x02D6
    b002:	8f 3f       	cpi	r24, 0xFF	; 255
    b004:	81 f0       	breq	.+32     	; 0xb026 <MenuEnterRight+0x15c>
			Buf2Field(Field+CurrField);
    b006:	90 e0       	ldi	r25, 0x00	; 0
    b008:	82 95       	swap	r24
    b00a:	92 95       	swap	r25
    b00c:	90 7f       	andi	r25, 0xF0	; 240
    b00e:	98 27       	eor	r25, r24
    b010:	80 7f       	andi	r24, 0xF0	; 240
    b012:	98 27       	eor	r25, r24
    b014:	8e 0d       	add	r24, r14
    b016:	9f 1d       	adc	r25, r15
    b018:	0e 94 06 54 	call	0xa80c	; 0xa80c <Buf2Field>
			if(CurrField==NullPos)
    b01c:	80 91 d6 02 	lds	r24, 0x02D6
    b020:	8f 3f       	cpi	r24, 0xFF	; 255
    b022:	09 f4       	brne	.+2      	; 0xb026 <MenuEnterRight+0x15c>
    b024:	5c cf       	rjmp	.-328    	; 0xaede <MenuEnterRight+0x14>
				return;
		}
		//     
		if(++CurrField==FieldNumber)
    b026:	8f 5f       	subi	r24, 0xFF	; 255
    b028:	80 93 d6 02 	sts	0x02D6, r24
    b02c:	18 17       	cp	r17, r24
    b02e:	d9 f1       	breq	.+118    	; 0xb0a6 <MenuEnterRight+0x1dc>
			CurrField=NullPos;
		else
			Field2Buf(Field+CurrField);
    b030:	90 e0       	ldi	r25, 0x00	; 0
    b032:	82 95       	swap	r24
    b034:	92 95       	swap	r25
    b036:	90 7f       	andi	r25, 0xF0	; 240
    b038:	98 27       	eor	r25, r24
    b03a:	80 7f       	andi	r24, 0xF0	; 240
    b03c:	98 27       	eor	r25, r24
    b03e:	8e 0d       	add	r24, r14
    b040:	9f 1d       	adc	r25, r15
    b042:	0e 94 4e 50 	call	0xa09c	; 0xa09c <Field2Buf>
    b046:	40 91 d4 02 	lds	r20, 0x02D4
    b04a:	50 91 d5 02 	lds	r21, 0x02D5
    b04e:	90 91 83 07 	lds	r25, 0x0783

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    b052:	4e 5f       	subi	r20, 0xFE	; 254
    b054:	5f 4f       	sbci	r21, 0xFF	; 255
    b056:	fa 01       	movw	r30, r20
    b058:	84 91       	lpm	r24, Z+
	}

// 3) Go to menu
	if( CurrLine >= prb(&CurrPage->LineNumber) )
    b05a:	98 17       	cp	r25, r24
    b05c:	08 f0       	brcs	.+2      	; 0xb060 <MenuEnterRight+0x196>
    b05e:	3f cf       	rjmp	.-386    	; 0xaede <MenuEnterRight+0x14>
		return;

	if(NextPage || (NextPage=prp(&Line->InnPage))) {
    b060:	80 91 d7 05 	lds	r24, 0x05D7
    b064:	90 91 d8 05 	lds	r25, 0x05D8
    b068:	00 97       	sbiw	r24, 0x00	; 0
    b06a:	39 f1       	breq	.+78     	; 0xb0ba <MenuEnterRight+0x1f0>
		GotoMenu(NextPage);
    b06c:	0e 94 ad 3c 	call	0x795a	; 0x795a <GotoMenu>
		NextPage=NULL;
    b070:	10 92 d8 05 	sts	0x05D8, r1
    b074:	10 92 d7 05 	sts	0x05D7, r1
    b078:	32 cf       	rjmp	.-412    	; 0xaede <MenuEnterRight+0x14>
		}

	//    
		if(CurrPos!=NullPos && --CurrPos!=NullPos){
			OutField *Field1=GetField;
			switch(prb(&Field1->Type)){
    b07a:	89 31       	cpi	r24, 0x19	; 25
    b07c:	20 f4       	brcc	.+8      	; 0xb086 <MenuEnterRight+0x1bc>
    b07e:	80 51       	subi	r24, 0x10	; 16
    b080:	86 30       	cpi	r24, 0x06	; 6
    b082:	08 f0       	brcs	.+2      	; 0xb086 <MenuEnterRight+0x1bc>
    b084:	2c cf       	rjmp	.-424    	; 0xaede <MenuEnterRight+0x14>
					MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[CurrFieldSize - 1 - CurrPos]);
				else MultiSymbol = GetMultiSymbol(Symbols_P, BufStr[CurrFieldSize - 1 - CurrPos]);
				break;
			case Longint: case z_Longint: case EE_Longint: case z_EE_Longint: case s_Longint: case s_EE_Longint:
			case FFloat: case EE_FFloat: case GFloat: case EE_GFloat:
				MultiSymbol = GetMultiSymbol(Digits_P, BufStr[CurrFieldSize - 1 - CurrPos]);
    b086:	e0 91 7a 07 	lds	r30, 0x077A
    b08a:	f0 e0       	ldi	r31, 0x00	; 0
    b08c:	31 97       	sbiw	r30, 0x01	; 1
    b08e:	e0 1b       	sub	r30, r16
    b090:	f1 09       	sbc	r31, r1
    b092:	ef 53       	subi	r30, 0x3F	; 63
    b094:	fa 4f       	sbci	r31, 0xFA	; 250
    b096:	8e ea       	ldi	r24, 0xAE	; 174
    b098:	96 e0       	ldi	r25, 0x06	; 6
    b09a:	60 81       	ld	r22, Z
    b09c:	0e 94 fc 40 	call	0x81f8	; 0x81f8 <GetMultiSymbol>
    b0a0:	80 93 f2 04 	sts	0x04F2, r24
    b0a4:	1c cf       	rjmp	.-456    	; 0xaede <MenuEnterRight+0x14>
			if(CurrField==NullPos)
				return;
		}
		//     
		if(++CurrField==FieldNumber)
			CurrField=NullPos;
    b0a6:	8f ef       	ldi	r24, 0xFF	; 255
    b0a8:	80 93 d6 02 	sts	0x02D6, r24
    b0ac:	40 91 d4 02 	lds	r20, 0x02D4
    b0b0:	50 91 d5 02 	lds	r21, 0x02D5
    b0b4:	90 91 83 07 	lds	r25, 0x0783
    b0b8:	cc cf       	rjmp	.-104    	; 0xb052 <MenuEnterRight+0x188>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    b0ba:	fe 01       	movw	r30, r28
    b0bc:	79 96       	adiw	r30, 0x19	; 25
    b0be:	85 91       	lpm	r24, Z+
    b0c0:	94 91       	lpm	r25, Z+

// 3) Go to menu
	if( CurrLine >= prb(&CurrPage->LineNumber) )
		return;

	if(NextPage || (NextPage=prp(&Line->InnPage))) {
    b0c2:	90 93 d8 05 	sts	0x05D8, r25
    b0c6:	80 93 d7 05 	sts	0x05D7, r24
    b0ca:	00 97       	sbiw	r24, 0x00	; 0
    b0cc:	79 f6       	brne	.-98     	; 0xb06c <MenuEnterRight+0x1a2>
    b0ce:	07 cf       	rjmp	.-498    	; 0xaede <MenuEnterRight+0x14>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    b0d0:	f7 01       	movw	r30, r14
    b0d2:	84 91       	lpm	r24, Z+
			Char2 = prc(CurrStr+i++);
			if (Char2=='}' && Char1!='}')
				FieldNumber++;
		}
		//    Bit (:)   
		if(FieldNumber==1 && prb(&Field->Type)==Bit) {
    b0d4:	8f 31       	cpi	r24, 0x1F	; 31
    b0d6:	09 f0       	breq	.+2      	; 0xb0da <MenuEnterRight+0x210>
    b0d8:	43 cf       	rjmp	.-378    	; 0xaf60 <MenuEnterRight+0x96>
    b0da:	8f e0       	ldi	r24, 0x0F	; 15
    b0dc:	90 e0       	ldi	r25, 0x00	; 0
    b0de:	e8 0e       	add	r14, r24
    b0e0:	f9 1e       	adc	r15, r25
    b0e2:	f7 01       	movw	r30, r14
    b0e4:	24 91       	lpm	r18, Z+
    b0e6:	81 ef       	ldi	r24, 0xF1	; 241
    b0e8:	9f ef       	ldi	r25, 0xFF	; 255
    b0ea:	e8 0e       	add	r14, r24
    b0ec:	f9 1e       	adc	r15, r25

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    b0ee:	c7 01       	movw	r24, r14
    b0f0:	01 96       	adiw	r24, 0x01	; 1
    b0f2:	fc 01       	movw	r30, r24
    b0f4:	a5 91       	lpm	r26, Z+
    b0f6:	b4 91       	lpm	r27, Z+
			uint8_t BitN=prb(&Field->Prec);
			*((uint8_t*)prp(&Field->Var)+BitN/8) ^=(1<<BitN%8);
    b0f8:	82 2f       	mov	r24, r18
    b0fa:	86 95       	lsr	r24
    b0fc:	86 95       	lsr	r24
    b0fe:	86 95       	lsr	r24
    b100:	a8 0f       	add	r26, r24
    b102:	b1 1d       	adc	r27, r1
    b104:	27 70       	andi	r18, 0x07	; 7
    b106:	81 e0       	ldi	r24, 0x01	; 1
    b108:	90 e0       	ldi	r25, 0x00	; 0
    b10a:	02 c0       	rjmp	.+4      	; 0xb110 <MenuEnterRight+0x246>
    b10c:	88 0f       	add	r24, r24
    b10e:	99 1f       	adc	r25, r25
    b110:	2a 95       	dec	r18
    b112:	e2 f7       	brpl	.-8      	; 0xb10c <MenuEnterRight+0x242>
    b114:	2c 91       	ld	r18, X
    b116:	28 27       	eor	r18, r24
    b118:	2c 93       	st	X, r18
			EventFunc(&Field->Act);
    b11a:	c7 01       	movw	r24, r14
    b11c:	0b 96       	adiw	r24, 0x0b	; 11
    b11e:	0e 94 93 3c 	call	0x7926	; 0x7926 <EventFunc>
    b122:	dd ce       	rjmp	.-582    	; 0xaede <MenuEnterRight+0x14>
		if(CurrPos!=NullPos && --CurrPos!=NullPos){
			OutField *Field1=GetField;
			switch(prb(&Field1->Type)){
			case Text: case EE_Text:
				if( (prd(&Field1->Min) == DIGIT) && (prd(&Field1->Max) == DIGIT) )
					MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[CurrFieldSize - 1 - CurrPos]);
    b124:	e0 91 7a 07 	lds	r30, 0x077A
    b128:	f0 e0       	ldi	r31, 0x00	; 0
    b12a:	31 97       	sbiw	r30, 0x01	; 1
    b12c:	e0 1b       	sub	r30, r16
    b12e:	f1 09       	sbc	r31, r1
    b130:	ef 53       	subi	r30, 0x3F	; 63
    b132:	fa 4f       	sbci	r31, 0xFA	; 250
    b134:	83 ea       	ldi	r24, 0xA3	; 163
    b136:	96 e0       	ldi	r25, 0x06	; 6
    b138:	60 81       	ld	r22, Z
    b13a:	0e 94 fc 40 	call	0x81f8	; 0x81f8 <GetMultiSymbol>
    b13e:	80 93 f2 04 	sts	0x04F2, r24
    b142:	cd ce       	rjmp	.-614    	; 0xaede <MenuEnterRight+0x14>

0000b144 <MenuUD>:
	return Pos*Dir;
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
MenuUD(const MenuKey *Key, int8_t Dir, uint8_t LimLine, uint8_t LimLCD, uint8_t LimVar)
{
    b144:	af 92       	push	r10
    b146:	bf 92       	push	r11
    b148:	cf 92       	push	r12
    b14a:	df 92       	push	r13
    b14c:	ef 92       	push	r14
    b14e:	ff 92       	push	r15
    b150:	0f 93       	push	r16
    b152:	1f 93       	push	r17
    b154:	cf 93       	push	r28
    b156:	df 93       	push	r29
    b158:	fc 01       	movw	r30, r24
    b15a:	e6 2e       	mov	r14, r22
    b15c:	14 2f       	mov	r17, r20
    b15e:	f2 2e       	mov	r15, r18
	if(CurrMsg || KeyFunc(Key))
    b160:	80 91 f3 04 	lds	r24, 0x04F3
    b164:	90 91 f4 04 	lds	r25, 0x04F4
    b168:	89 2b       	or	r24, r25
    b16a:	59 f0       	breq	.+22     	; 0xb182 <MenuUD+0x3e>
		else 		{if(--MultiSymbol == 255) MultiSymbol = strlen_P(Digits_P)-1;}
		if(CurrPos!=NullPos)
			BufStr[CurrFieldSize - 1 - CurrPos] = prc(Digits_P + MultiSymbol);
		break;
	}
}
    b16c:	df 91       	pop	r29
    b16e:	cf 91       	pop	r28
    b170:	1f 91       	pop	r17
    b172:	0f 91       	pop	r16
    b174:	ff 90       	pop	r15
    b176:	ef 90       	pop	r14
    b178:	df 90       	pop	r13
    b17a:	cf 90       	pop	r12
    b17c:	bf 90       	pop	r11
    b17e:	af 90       	pop	r10
    b180:	08 95       	ret
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
MenuUD(const MenuKey *Key, int8_t Dir, uint8_t LimLine, uint8_t LimLCD, uint8_t LimVar)
{
	if(CurrMsg || KeyFunc(Key))
    b182:	cf 01       	movw	r24, r30
    b184:	0e 94 9b 3c 	call	0x7936	; 0x7936 <KeyFunc>
    b188:	88 23       	and	r24, r24
    b18a:	81 f7       	brne	.-32     	; 0xb16c <MenuUD+0x28>
		return;
	if(CurrField==NullPos) {
    b18c:	30 91 d6 02 	lds	r19, 0x02D6
    b190:	3f 3f       	cpi	r19, 0xFF	; 255
    b192:	09 f4       	brne	.+2      	; 0xb196 <MenuUD+0x52>
    b194:	48 c1       	rjmp	.+656    	; 0xb426 <MenuUD+0x2e2>
			if(LimLCD)
				CurrLCD -= Dir;
		}
		return;
	}
	Blink=0;
    b196:	10 92 d0 08 	sts	0x08D0, r1
    b19a:	80 91 d4 02 	lds	r24, 0x02D4
    b19e:	90 91 d5 02 	lds	r25, 0x02D5
    b1a2:	fc 01       	movw	r30, r24
    b1a4:	45 91       	lpm	r20, Z+
    b1a6:	54 91       	lpm	r21, Z+
	OutField *Field=GetField;
    b1a8:	80 91 83 07 	lds	r24, 0x0783
    b1ac:	2b e1       	ldi	r18, 0x1B	; 27
    b1ae:	82 9f       	mul	r24, r18
    b1b0:	c0 01       	movw	r24, r0
    b1b2:	11 24       	eor	r1, r1
    b1b4:	48 0f       	add	r20, r24
    b1b6:	59 1f       	adc	r21, r25
    b1b8:	49 5e       	subi	r20, 0xE9	; 233
    b1ba:	5f 4f       	sbci	r21, 0xFF	; 255
    b1bc:	fa 01       	movw	r30, r20
    b1be:	c5 91       	lpm	r28, Z+
    b1c0:	d4 91       	lpm	r29, Z+
    b1c2:	83 2f       	mov	r24, r19
    b1c4:	90 e0       	ldi	r25, 0x00	; 0
    b1c6:	82 95       	swap	r24
    b1c8:	92 95       	swap	r25
    b1ca:	90 7f       	andi	r25, 0xF0	; 240
    b1cc:	98 27       	eor	r25, r24
    b1ce:	80 7f       	andi	r24, 0xF0	; 240
    b1d0:	98 27       	eor	r25, r24
    b1d2:	c8 0f       	add	r28, r24
    b1d4:	d9 1f       	adc	r29, r25

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    b1d6:	fe 01       	movw	r30, r28
    b1d8:	84 91       	lpm	r24, Z+
	switch(prb(&Field->Type)) {
    b1da:	e8 2f       	mov	r30, r24
    b1dc:	f0 e0       	ldi	r31, 0x00	; 0
    b1de:	e3 32       	cpi	r30, 0x23	; 35
    b1e0:	f1 05       	cpc	r31, r1
    b1e2:	08 f0       	brcs	.+2      	; 0xb1e6 <MenuUD+0xa2>
    b1e4:	c3 cf       	rjmp	.-122    	; 0xb16c <MenuUD+0x28>
    b1e6:	ea 54       	subi	r30, 0x4A	; 74
    b1e8:	ff 4f       	sbci	r31, 0xFF	; 255
    b1ea:	ee 0f       	add	r30, r30
    b1ec:	ff 1f       	adc	r31, r31
    b1ee:	05 90       	lpm	r0, Z+
    b1f0:	f4 91       	lpm	r31, Z+
    b1f2:	e0 2d       	mov	r30, r0
    b1f4:	19 94       	eijmp

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    b1f6:	fe 01       	movw	r30, r28
    b1f8:	33 96       	adiw	r30, 0x03	; 3
    b1fa:	85 91       	lpm	r24, Z+
    b1fc:	95 91       	lpm	r25, Z+
    b1fe:	a5 91       	lpm	r26, Z+
    b200:	b4 91       	lpm	r27, Z+
		break;
	case Bit: case EE_Bit:
		F_Buf = !F_Buf;
		break;
	case Text: case EE_Text:
		if( (prd(&Field->Min) == DIGIT) && (prd(&Field->Max) == DIGIT) ){
    b202:	00 97       	sbiw	r24, 0x00	; 0
    b204:	a1 05       	cpc	r26, r1
    b206:	b1 05       	cpc	r27, r1
    b208:	09 f0       	breq	.+2      	; 0xb20c <MenuUD+0xc8>
    b20a:	1e c1       	rjmp	.+572    	; 0xb448 <MenuUD+0x304>
    b20c:	fe 01       	movw	r30, r28
    b20e:	37 96       	adiw	r30, 0x07	; 7
    b210:	85 91       	lpm	r24, Z+
    b212:	95 91       	lpm	r25, Z+
    b214:	a5 91       	lpm	r26, Z+
    b216:	b4 91       	lpm	r27, Z+
    b218:	00 97       	sbiw	r24, 0x00	; 0
    b21a:	a1 05       	cpc	r26, r1
    b21c:	b1 05       	cpc	r27, r1
    b21e:	09 f0       	breq	.+2      	; 0xb222 <MenuUD+0xde>
    b220:	13 c1       	rjmp	.+550    	; 0xb448 <MenuUD+0x304>
			if(Dir==1){	if(++MultiSymbol > 9) MultiSymbol = 0;}
    b222:	31 e0       	ldi	r19, 0x01	; 1
    b224:	e3 16       	cp	r14, r19
    b226:	09 f4       	brne	.+2      	; 0xb22a <MenuUD+0xe6>
    b228:	92 c1       	rjmp	.+804    	; 0xb54e <MenuUD+0x40a>
			else{		if(--MultiSymbol == 255) MultiSymbol = 9;}
    b22a:	80 91 f2 04 	lds	r24, 0x04F2
    b22e:	81 50       	subi	r24, 0x01	; 1
    b230:	80 93 f2 04 	sts	0x04F2, r24
    b234:	8f 3f       	cpi	r24, 0xFF	; 255
    b236:	09 f4       	brne	.+2      	; 0xb23a <MenuUD+0xf6>
    b238:	93 c1       	rjmp	.+806    	; 0xb560 <MenuUD+0x41c>
		}
		else{
			if(Dir==1){	if(++MultiSymbol >= strlen_P(Symbols_P)) MultiSymbol = 0;}
			else{		if(--MultiSymbol == 255) MultiSymbol = strlen_P(Symbols_P)-1;}
		}
		if(CurrPos!=NullPos)
    b23a:	90 91 d7 02 	lds	r25, 0x02D7
    b23e:	9f 3f       	cpi	r25, 0xFF	; 255
    b240:	09 f4       	brne	.+2      	; 0xb244 <MenuUD+0x100>
    b242:	94 cf       	rjmp	.-216    	; 0xb16c <MenuUD+0x28>

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    b244:	80 91 f2 04 	lds	r24, 0x04F2
    b248:	e8 2f       	mov	r30, r24
    b24a:	f0 e0       	ldi	r31, 0x00	; 0
    b24c:	eb 5f       	subi	r30, 0xFB	; 251
    b24e:	f9 4f       	sbci	r31, 0xF9	; 249
	case Longint: case z_Longint: case EE_Longint: case z_EE_Longint: case s_Longint: case s_EE_Longint:
	case FFloat: case EE_FFloat: case GFloat: case EE_GFloat:
		if(Dir==1)	{if(++MultiSymbol >= strlen_P(Digits_P)) MultiSymbol = 0;}
		else 		{if(--MultiSymbol == 255) MultiSymbol = strlen_P(Digits_P)-1;}
		if(CurrPos!=NullPos)
			BufStr[CurrFieldSize - 1 - CurrPos] = prc(Digits_P + MultiSymbol);
    b250:	84 91       	lpm	r24, Z+
    b252:	e0 91 7a 07 	lds	r30, 0x077A
    b256:	f0 e0       	ldi	r31, 0x00	; 0
    b258:	31 97       	sbiw	r30, 0x01	; 1
    b25a:	e9 1b       	sub	r30, r25
    b25c:	f1 09       	sbc	r31, r1
    b25e:	ef 53       	subi	r30, 0x3F	; 63
    b260:	fa 4f       	sbci	r31, 0xFA	; 250
    b262:	80 83       	st	Z, r24
    b264:	83 cf       	rjmp	.-250    	; 0xb16c <MenuUD+0x28>
	case Enum: case EE_Enum:
		if(LimVar)
			F_Buf += Dir;
		break;
	case Bit: case EE_Bit:
		F_Buf = !F_Buf;
    b266:	20 e0       	ldi	r18, 0x00	; 0
    b268:	30 e0       	ldi	r19, 0x00	; 0
    b26a:	40 e0       	ldi	r20, 0x00	; 0
    b26c:	50 e0       	ldi	r21, 0x00	; 0
    b26e:	80 91 f5 04 	lds	r24, 0x04F5
    b272:	90 91 f6 04 	lds	r25, 0x04F6
    b276:	a0 91 f7 04 	lds	r26, 0x04F7
    b27a:	b0 91 f8 04 	lds	r27, 0x04F8
    b27e:	00 97       	sbiw	r24, 0x00	; 0
    b280:	a1 05       	cpc	r26, r1
    b282:	b1 05       	cpc	r27, r1
    b284:	21 f4       	brne	.+8      	; 0xb28e <MenuUD+0x14a>
    b286:	21 e0       	ldi	r18, 0x01	; 1
    b288:	30 e0       	ldi	r19, 0x00	; 0
    b28a:	40 e0       	ldi	r20, 0x00	; 0
    b28c:	50 e0       	ldi	r21, 0x00	; 0
    b28e:	20 93 f5 04 	sts	0x04F5, r18
    b292:	30 93 f6 04 	sts	0x04F6, r19
    b296:	40 93 f7 04 	sts	0x04F7, r20
    b29a:	50 93 f8 04 	sts	0x04F8, r21
    b29e:	66 cf       	rjmp	.-308    	; 0xb16c <MenuUD+0x28>
			Buf2Field(Field);
			Field2Buf(Field);
		}
		break;
	case Enum: case EE_Enum:
		if(LimVar)
    b2a0:	00 23       	and	r16, r16
    b2a2:	09 f4       	brne	.+2      	; 0xb2a6 <MenuUD+0x162>
    b2a4:	63 cf       	rjmp	.-314    	; 0xb16c <MenuUD+0x28>
			F_Buf += Dir;
    b2a6:	2e 2d       	mov	r18, r14
    b2a8:	33 27       	eor	r19, r19
    b2aa:	27 fd       	sbrc	r18, 7
    b2ac:	30 95       	com	r19
    b2ae:	43 2f       	mov	r20, r19
    b2b0:	53 2f       	mov	r21, r19
    b2b2:	80 91 f5 04 	lds	r24, 0x04F5
    b2b6:	90 91 f6 04 	lds	r25, 0x04F6
    b2ba:	a0 91 f7 04 	lds	r26, 0x04F7
    b2be:	b0 91 f8 04 	lds	r27, 0x04F8
    b2c2:	82 0f       	add	r24, r18
    b2c4:	93 1f       	adc	r25, r19
    b2c6:	a4 1f       	adc	r26, r20
    b2c8:	b5 1f       	adc	r27, r21
    b2ca:	80 93 f5 04 	sts	0x04F5, r24
    b2ce:	90 93 f6 04 	sts	0x04F6, r25
    b2d2:	a0 93 f7 04 	sts	0x04F7, r26
    b2d6:	b0 93 f8 04 	sts	0x04F8, r27
    b2da:	48 cf       	rjmp	.-368    	; 0xb16c <MenuUD+0x28>
		if(CurrPos!=NullPos)
			BufStr[CurrFieldSize - 1 - CurrPos] = prc(Symbols_P + MultiSymbol);
		break;
	case Longint: case z_Longint: case EE_Longint: case z_EE_Longint: case s_Longint: case s_EE_Longint:
	case FFloat: case EE_FFloat: case GFloat: case EE_GFloat:
		if(Dir==1)	{if(++MultiSymbol >= strlen_P(Digits_P)) MultiSymbol = 0;}
    b2dc:	51 e0       	ldi	r21, 0x01	; 1
    b2de:	e5 16       	cp	r14, r21
    b2e0:	09 f4       	brne	.+2      	; 0xb2e4 <MenuUD+0x1a0>
    b2e2:	fb c0       	rjmp	.+502    	; 0xb4da <MenuUD+0x396>
		else 		{if(--MultiSymbol == 255) MultiSymbol = strlen_P(Digits_P)-1;}
    b2e4:	80 91 f2 04 	lds	r24, 0x04F2
    b2e8:	81 50       	subi	r24, 0x01	; 1
    b2ea:	80 93 f2 04 	sts	0x04F2, r24
    b2ee:	8f 3f       	cpi	r24, 0xFF	; 255
    b2f0:	09 f4       	brne	.+2      	; 0xb2f4 <MenuUD+0x1b0>
    b2f2:	14 c1       	rjmp	.+552    	; 0xb51c <MenuUD+0x3d8>
		if(CurrPos!=NullPos)
    b2f4:	90 91 d7 02 	lds	r25, 0x02D7
    b2f8:	9f 3f       	cpi	r25, 0xFF	; 255
    b2fa:	09 f4       	brne	.+2      	; 0xb2fe <MenuUD+0x1ba>
    b2fc:	37 cf       	rjmp	.-402    	; 0xb16c <MenuUD+0x28>
    b2fe:	80 91 f2 04 	lds	r24, 0x04F2
    b302:	e8 2f       	mov	r30, r24
    b304:	f0 e0       	ldi	r31, 0x00	; 0
    b306:	e2 55       	subi	r30, 0x52	; 82
    b308:	f9 4f       	sbci	r31, 0xF9	; 249
    b30a:	a2 cf       	rjmp	.-188    	; 0xb250 <MenuUD+0x10c>
			sF_Buf += Inc(Dir, sF_Buf);
		else if(sF_Buf<0 || sF_Buf==0 && Minus)
			Minus = (sF_Buf-=Inc(Dir, -sF_Buf))==0;
		break;
	case c_Word: case zc_Word:
		if(LimVar) {
    b30c:	00 23       	and	r16, r16
    b30e:	09 f4       	brne	.+2      	; 0xb312 <MenuUD+0x1ce>
    b310:	2d cf       	rjmp	.-422    	; 0xb16c <MenuUD+0x28>
			F_Buf += Dir;
    b312:	2e 2d       	mov	r18, r14
    b314:	33 27       	eor	r19, r19
    b316:	27 fd       	sbrc	r18, 7
    b318:	30 95       	com	r19
    b31a:	43 2f       	mov	r20, r19
    b31c:	53 2f       	mov	r21, r19
    b31e:	80 91 f5 04 	lds	r24, 0x04F5
    b322:	90 91 f6 04 	lds	r25, 0x04F6
    b326:	a0 91 f7 04 	lds	r26, 0x04F7
    b32a:	b0 91 f8 04 	lds	r27, 0x04F8
    b32e:	82 0f       	add	r24, r18
    b330:	93 1f       	adc	r25, r19
    b332:	a4 1f       	adc	r26, r20
    b334:	b5 1f       	adc	r27, r21
    b336:	80 93 f5 04 	sts	0x04F5, r24
    b33a:	90 93 f6 04 	sts	0x04F6, r25
    b33e:	a0 93 f7 04 	sts	0x04F7, r26
    b342:	b0 93 f8 04 	sts	0x04F8, r27
			Buf2Field(Field);
    b346:	ce 01       	movw	r24, r28
    b348:	0e 94 06 54 	call	0xa80c	; 0xa80c <Buf2Field>
			Field2Buf(Field);
    b34c:	ce 01       	movw	r24, r28
    b34e:	0e 94 4e 50 	call	0xa09c	; 0xa09c <Field2Buf>
    b352:	0c cf       	rjmp	.-488    	; 0xb16c <MenuUD+0x28>
	case Word: case EE_Word: case z_Word: case z_EE_Word:
		F_Buf += Inc(Dir, F_Buf);
		break;
	case s_Byte: case s_EE_Byte:
	case s_Word: case s_EE_Word:
		if(CurrPos==Log10(prd(&Field->Max))+1) {
    b354:	00 91 d7 02 	lds	r16, 0x02D7
    b358:	10 e0       	ldi	r17, 0x00	; 0

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    b35a:	fe 01       	movw	r30, r28
    b35c:	37 96       	adiw	r30, 0x07	; 7
    b35e:	65 91       	lpm	r22, Z+
    b360:	75 91       	lpm	r23, Z+
    b362:	85 91       	lpm	r24, Z+
    b364:	94 91       	lpm	r25, Z+
    b366:	0e 94 23 21 	call	0x4246	; 0x4246 <Log10>
    b36a:	90 e0       	ldi	r25, 0x00	; 0
    b36c:	01 96       	adiw	r24, 0x01	; 1
    b36e:	08 17       	cp	r16, r24
    b370:	19 07       	cpc	r17, r25
    b372:	09 f4       	brne	.+2      	; 0xb376 <MenuUD+0x232>
    b374:	9c c0       	rjmp	.+312    	; 0xb4ae <MenuUD+0x36a>
			if(sF_Buf==0)
				Minus = !Minus;
			else
				sF_Buf = -sF_Buf;
		}
		else if(sF_Buf>0 || sF_Buf==0 && !Minus)
    b376:	a0 90 f9 04 	lds	r10, 0x04F9
    b37a:	b0 90 fa 04 	lds	r11, 0x04FA
    b37e:	c0 90 fb 04 	lds	r12, 0x04FB
    b382:	d0 90 fc 04 	lds	r13, 0x04FC
    b386:	1a 14       	cp	r1, r10
    b388:	1b 04       	cpc	r1, r11
    b38a:	1c 04       	cpc	r1, r12
    b38c:	1d 04       	cpc	r1, r13
    b38e:	0c f4       	brge	.+2      	; 0xb392 <MenuUD+0x24e>
    b390:	74 c0       	rjmp	.+232    	; 0xb47a <MenuUD+0x336>
    b392:	a1 14       	cp	r10, r1
    b394:	b1 04       	cpc	r11, r1
    b396:	c1 04       	cpc	r12, r1
    b398:	d1 04       	cpc	r13, r1
    b39a:	09 f4       	brne	.+2      	; 0xb39e <MenuUD+0x25a>
    b39c:	69 c0       	rjmp	.+210    	; 0xb470 <MenuUD+0x32c>
			sF_Buf += Inc(Dir, sF_Buf);
		else if(sF_Buf<0 || sF_Buf==0 && Minus)
			Minus = (sF_Buf-=Inc(Dir, -sF_Buf))==0;
    b39e:	44 27       	eor	r20, r20
    b3a0:	55 27       	eor	r21, r21
    b3a2:	ba 01       	movw	r22, r20
    b3a4:	4a 19       	sub	r20, r10
    b3a6:	5b 09       	sbc	r21, r11
    b3a8:	6c 09       	sbc	r22, r12
    b3aa:	7d 09       	sbc	r23, r13
    b3ac:	8e 2d       	mov	r24, r14
    b3ae:	0e 94 72 3d 	call	0x7ae4	; 0x7ae4 <Inc>
    b3b2:	a6 01       	movw	r20, r12
    b3b4:	95 01       	movw	r18, r10
    b3b6:	26 1b       	sub	r18, r22
    b3b8:	37 0b       	sbc	r19, r23
    b3ba:	48 0b       	sbc	r20, r24
    b3bc:	59 0b       	sbc	r21, r25
    b3be:	20 93 f9 04 	sts	0x04F9, r18
    b3c2:	30 93 fa 04 	sts	0x04FA, r19
    b3c6:	40 93 fb 04 	sts	0x04FB, r20
    b3ca:	50 93 fc 04 	sts	0x04FC, r21
    b3ce:	10 92 fd 04 	sts	0x04FD, r1
    b3d2:	21 15       	cp	r18, r1
    b3d4:	31 05       	cpc	r19, r1
    b3d6:	41 05       	cpc	r20, r1
    b3d8:	51 05       	cpc	r21, r1
    b3da:	09 f0       	breq	.+2      	; 0xb3de <MenuUD+0x29a>
    b3dc:	c7 ce       	rjmp	.-626    	; 0xb16c <MenuUD+0x28>
    b3de:	81 e0       	ldi	r24, 0x01	; 1
    b3e0:	80 93 fd 04 	sts	0x04FD, r24
    b3e4:	c3 ce       	rjmp	.-634    	; 0xb16c <MenuUD+0x28>
	Blink=0;
	OutField *Field=GetField;
	switch(prb(&Field->Type)) {
	case Byte: case EE_Byte: case z_Byte: case z_EE_Byte:
	case Word: case EE_Word: case z_Word: case z_EE_Word:
		F_Buf += Inc(Dir, F_Buf);
    b3e6:	40 91 f5 04 	lds	r20, 0x04F5
    b3ea:	50 91 f6 04 	lds	r21, 0x04F6
    b3ee:	60 91 f7 04 	lds	r22, 0x04F7
    b3f2:	70 91 f8 04 	lds	r23, 0x04F8
    b3f6:	8e 2d       	mov	r24, r14
    b3f8:	0e 94 72 3d 	call	0x7ae4	; 0x7ae4 <Inc>
    b3fc:	20 91 f5 04 	lds	r18, 0x04F5
    b400:	30 91 f6 04 	lds	r19, 0x04F6
    b404:	40 91 f7 04 	lds	r20, 0x04F7
    b408:	50 91 f8 04 	lds	r21, 0x04F8
    b40c:	26 0f       	add	r18, r22
    b40e:	37 1f       	adc	r19, r23
    b410:	48 1f       	adc	r20, r24
    b412:	59 1f       	adc	r21, r25
    b414:	20 93 f5 04 	sts	0x04F5, r18
    b418:	30 93 f6 04 	sts	0x04F6, r19
    b41c:	40 93 f7 04 	sts	0x04F7, r20
    b420:	50 93 f8 04 	sts	0x04F8, r21
    b424:	a3 ce       	rjmp	.-698    	; 0xb16c <MenuUD+0x28>
MenuUD(const MenuKey *Key, int8_t Dir, uint8_t LimLine, uint8_t LimLCD, uint8_t LimVar)
{
	if(CurrMsg || KeyFunc(Key))
		return;
	if(CurrField==NullPos) {
		if(LimLine) {
    b426:	11 23       	and	r17, r17
    b428:	09 f4       	brne	.+2      	; 0xb42c <MenuUD+0x2e8>
    b42a:	a0 ce       	rjmp	.-704    	; 0xb16c <MenuUD+0x28>
			CurrLine -= Dir;
    b42c:	80 91 83 07 	lds	r24, 0x0783
    b430:	8e 19       	sub	r24, r14
    b432:	80 93 83 07 	sts	0x0783, r24
			if(LimLCD)
    b436:	ff 20       	and	r15, r15
    b438:	09 f4       	brne	.+2      	; 0xb43c <MenuUD+0x2f8>
    b43a:	98 ce       	rjmp	.-720    	; 0xb16c <MenuUD+0x28>
				CurrLCD -= Dir;
    b43c:	80 91 a0 08 	lds	r24, 0x08A0
    b440:	8e 19       	sub	r24, r14
    b442:	80 93 a0 08 	sts	0x08A0, r24
    b446:	92 ce       	rjmp	.-732    	; 0xb16c <MenuUD+0x28>
		if( (prd(&Field->Min) == DIGIT) && (prd(&Field->Max) == DIGIT) ){
			if(Dir==1){	if(++MultiSymbol > 9) MultiSymbol = 0;}
			else{		if(--MultiSymbol == 255) MultiSymbol = 9;}
		}
		else{
			if(Dir==1){	if(++MultiSymbol >= strlen_P(Symbols_P)) MultiSymbol = 0;}
    b448:	41 e0       	ldi	r20, 0x01	; 1
    b44a:	e4 16       	cp	r14, r20
    b44c:	09 f4       	brne	.+2      	; 0xb450 <MenuUD+0x30c>
    b44e:	6e c0       	rjmp	.+220    	; 0xb52c <MenuUD+0x3e8>
			else{		if(--MultiSymbol == 255) MultiSymbol = strlen_P(Symbols_P)-1;}
    b450:	80 91 f2 04 	lds	r24, 0x04F2
    b454:	81 50       	subi	r24, 0x01	; 1
    b456:	80 93 f2 04 	sts	0x04F2, r24
    b45a:	8f 3f       	cpi	r24, 0xFF	; 255
    b45c:	09 f0       	breq	.+2      	; 0xb460 <MenuUD+0x31c>
    b45e:	ed ce       	rjmp	.-550    	; 0xb23a <MenuUD+0xf6>
    b460:	85 e0       	ldi	r24, 0x05	; 5
    b462:	96 e0       	ldi	r25, 0x06	; 6
    b464:	0e 94 cd 7f 	call	0xff9a	; 0xff9a <strlen_P>
    b468:	81 50       	subi	r24, 0x01	; 1
    b46a:	80 93 f2 04 	sts	0x04F2, r24
    b46e:	e5 ce       	rjmp	.-566    	; 0xb23a <MenuUD+0xf6>
			if(sF_Buf==0)
				Minus = !Minus;
			else
				sF_Buf = -sF_Buf;
		}
		else if(sF_Buf>0 || sF_Buf==0 && !Minus)
    b470:	80 91 fd 04 	lds	r24, 0x04FD
    b474:	88 23       	and	r24, r24
    b476:	09 f0       	breq	.+2      	; 0xb47a <MenuUD+0x336>
    b478:	92 cf       	rjmp	.-220    	; 0xb39e <MenuUD+0x25a>
			sF_Buf += Inc(Dir, sF_Buf);
    b47a:	8e 2d       	mov	r24, r14
    b47c:	b6 01       	movw	r22, r12
    b47e:	a5 01       	movw	r20, r10
    b480:	0e 94 72 3d 	call	0x7ae4	; 0x7ae4 <Inc>
    b484:	20 91 f9 04 	lds	r18, 0x04F9
    b488:	30 91 fa 04 	lds	r19, 0x04FA
    b48c:	40 91 fb 04 	lds	r20, 0x04FB
    b490:	50 91 fc 04 	lds	r21, 0x04FC
    b494:	26 0f       	add	r18, r22
    b496:	37 1f       	adc	r19, r23
    b498:	48 1f       	adc	r20, r24
    b49a:	59 1f       	adc	r21, r25
    b49c:	20 93 f9 04 	sts	0x04F9, r18
    b4a0:	30 93 fa 04 	sts	0x04FA, r19
    b4a4:	40 93 fb 04 	sts	0x04FB, r20
    b4a8:	50 93 fc 04 	sts	0x04FC, r21
    b4ac:	5f ce       	rjmp	.-834    	; 0xb16c <MenuUD+0x28>
		F_Buf += Inc(Dir, F_Buf);
		break;
	case s_Byte: case s_EE_Byte:
	case s_Word: case s_EE_Word:
		if(CurrPos==Log10(prd(&Field->Max))+1) {
			if(sF_Buf==0)
    b4ae:	20 91 f9 04 	lds	r18, 0x04F9
    b4b2:	30 91 fa 04 	lds	r19, 0x04FA
    b4b6:	40 91 fb 04 	lds	r20, 0x04FB
    b4ba:	50 91 fc 04 	lds	r21, 0x04FC
    b4be:	21 15       	cp	r18, r1
    b4c0:	31 05       	cpc	r19, r1
    b4c2:	41 05       	cpc	r20, r1
    b4c4:	51 05       	cpc	r21, r1
    b4c6:	d1 f4       	brne	.+52     	; 0xb4fc <MenuUD+0x3b8>
				Minus = !Minus;
    b4c8:	90 e0       	ldi	r25, 0x00	; 0
    b4ca:	80 91 fd 04 	lds	r24, 0x04FD
    b4ce:	88 23       	and	r24, r24
    b4d0:	09 f4       	brne	.+2      	; 0xb4d4 <MenuUD+0x390>
    b4d2:	91 e0       	ldi	r25, 0x01	; 1
    b4d4:	90 93 fd 04 	sts	0x04FD, r25
    b4d8:	49 ce       	rjmp	.-878    	; 0xb16c <MenuUD+0x28>
		if(CurrPos!=NullPos)
			BufStr[CurrFieldSize - 1 - CurrPos] = prc(Symbols_P + MultiSymbol);
		break;
	case Longint: case z_Longint: case EE_Longint: case z_EE_Longint: case s_Longint: case s_EE_Longint:
	case FFloat: case EE_FFloat: case GFloat: case EE_GFloat:
		if(Dir==1)	{if(++MultiSymbol >= strlen_P(Digits_P)) MultiSymbol = 0;}
    b4da:	00 91 f2 04 	lds	r16, 0x04F2
    b4de:	0f 5f       	subi	r16, 0xFF	; 255
    b4e0:	00 93 f2 04 	sts	0x04F2, r16
    b4e4:	8e ea       	ldi	r24, 0xAE	; 174
    b4e6:	96 e0       	ldi	r25, 0x06	; 6
    b4e8:	0e 94 cd 7f 	call	0xff9a	; 0xff9a <strlen_P>
    b4ec:	10 e0       	ldi	r17, 0x00	; 0
    b4ee:	08 17       	cp	r16, r24
    b4f0:	19 07       	cpc	r17, r25
    b4f2:	08 f4       	brcc	.+2      	; 0xb4f6 <MenuUD+0x3b2>
    b4f4:	ff ce       	rjmp	.-514    	; 0xb2f4 <MenuUD+0x1b0>
    b4f6:	10 92 f2 04 	sts	0x04F2, r1
    b4fa:	fc ce       	rjmp	.-520    	; 0xb2f4 <MenuUD+0x1b0>
	case s_Word: case s_EE_Word:
		if(CurrPos==Log10(prd(&Field->Max))+1) {
			if(sF_Buf==0)
				Minus = !Minus;
			else
				sF_Buf = -sF_Buf;
    b4fc:	88 27       	eor	r24, r24
    b4fe:	99 27       	eor	r25, r25
    b500:	dc 01       	movw	r26, r24
    b502:	82 1b       	sub	r24, r18
    b504:	93 0b       	sbc	r25, r19
    b506:	a4 0b       	sbc	r26, r20
    b508:	b5 0b       	sbc	r27, r21
    b50a:	80 93 f9 04 	sts	0x04F9, r24
    b50e:	90 93 fa 04 	sts	0x04FA, r25
    b512:	a0 93 fb 04 	sts	0x04FB, r26
    b516:	b0 93 fc 04 	sts	0x04FC, r27
    b51a:	28 ce       	rjmp	.-944    	; 0xb16c <MenuUD+0x28>
			BufStr[CurrFieldSize - 1 - CurrPos] = prc(Symbols_P + MultiSymbol);
		break;
	case Longint: case z_Longint: case EE_Longint: case z_EE_Longint: case s_Longint: case s_EE_Longint:
	case FFloat: case EE_FFloat: case GFloat: case EE_GFloat:
		if(Dir==1)	{if(++MultiSymbol >= strlen_P(Digits_P)) MultiSymbol = 0;}
		else 		{if(--MultiSymbol == 255) MultiSymbol = strlen_P(Digits_P)-1;}
    b51c:	8e ea       	ldi	r24, 0xAE	; 174
    b51e:	96 e0       	ldi	r25, 0x06	; 6
    b520:	0e 94 cd 7f 	call	0xff9a	; 0xff9a <strlen_P>
    b524:	81 50       	subi	r24, 0x01	; 1
    b526:	80 93 f2 04 	sts	0x04F2, r24
    b52a:	e4 ce       	rjmp	.-568    	; 0xb2f4 <MenuUD+0x1b0>
		if( (prd(&Field->Min) == DIGIT) && (prd(&Field->Max) == DIGIT) ){
			if(Dir==1){	if(++MultiSymbol > 9) MultiSymbol = 0;}
			else{		if(--MultiSymbol == 255) MultiSymbol = 9;}
		}
		else{
			if(Dir==1){	if(++MultiSymbol >= strlen_P(Symbols_P)) MultiSymbol = 0;}
    b52c:	00 91 f2 04 	lds	r16, 0x04F2
    b530:	0f 5f       	subi	r16, 0xFF	; 255
    b532:	00 93 f2 04 	sts	0x04F2, r16
    b536:	85 e0       	ldi	r24, 0x05	; 5
    b538:	96 e0       	ldi	r25, 0x06	; 6
    b53a:	0e 94 cd 7f 	call	0xff9a	; 0xff9a <strlen_P>
    b53e:	10 e0       	ldi	r17, 0x00	; 0
    b540:	08 17       	cp	r16, r24
    b542:	19 07       	cpc	r17, r25
    b544:	08 f4       	brcc	.+2      	; 0xb548 <MenuUD+0x404>
    b546:	79 ce       	rjmp	.-782    	; 0xb23a <MenuUD+0xf6>
    b548:	10 92 f2 04 	sts	0x04F2, r1
    b54c:	76 ce       	rjmp	.-788    	; 0xb23a <MenuUD+0xf6>
	case Bit: case EE_Bit:
		F_Buf = !F_Buf;
		break;
	case Text: case EE_Text:
		if( (prd(&Field->Min) == DIGIT) && (prd(&Field->Max) == DIGIT) ){
			if(Dir==1){	if(++MultiSymbol > 9) MultiSymbol = 0;}
    b54e:	80 91 f2 04 	lds	r24, 0x04F2
    b552:	8f 5f       	subi	r24, 0xFF	; 255
    b554:	80 93 f2 04 	sts	0x04F2, r24
    b558:	8a 30       	cpi	r24, 0x0A	; 10
    b55a:	08 f4       	brcc	.+2      	; 0xb55e <MenuUD+0x41a>
    b55c:	6e ce       	rjmp	.-804    	; 0xb23a <MenuUD+0xf6>
    b55e:	f4 cf       	rjmp	.-24     	; 0xb548 <MenuUD+0x404>
			else{		if(--MultiSymbol == 255) MultiSymbol = 9;}
    b560:	89 e0       	ldi	r24, 0x09	; 9
    b562:	80 93 f2 04 	sts	0x04F2, r24
    b566:	69 ce       	rjmp	.-814    	; 0xb23a <MenuUD+0xf6>

0000b568 <MenuDown>:
}

// ~~~~~~~~~~~
void
MenuDown(void)
{
    b568:	ef 92       	push	r14
    b56a:	ff 92       	push	r15
    b56c:	0f 93       	push	r16
    b56e:	1f 93       	push	r17
    b570:	cf 93       	push	r28
    b572:	df 93       	push	r29
	MenuUD(&CurrPage->Down, -1, prb(&CurrPage->LineNumber)-CurrLine>1, CurrLCD<LCDYSz-1, F_Buf>prd(&GetField->Min));
    b574:	c0 91 d4 02 	lds	r28, 0x02D4
    b578:	d0 91 d5 02 	lds	r29, 0x02D5

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    b57c:	22 96       	adiw	r28, 0x02	; 2
    b57e:	fe 01       	movw	r30, r28
    b580:	24 91       	lpm	r18, Z+
    b582:	22 97       	sbiw	r28, 0x02	; 2
    b584:	40 91 83 07 	lds	r20, 0x0783

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    b588:	fe 01       	movw	r30, r28
    b58a:	65 91       	lpm	r22, Z+
    b58c:	74 91       	lpm	r23, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    b58e:	8b e1       	ldi	r24, 0x1B	; 27
    b590:	48 9f       	mul	r20, r24
    b592:	c0 01       	movw	r24, r0
    b594:	11 24       	eor	r1, r1
    b596:	68 0f       	add	r22, r24
    b598:	79 1f       	adc	r23, r25
    b59a:	69 5e       	subi	r22, 0xE9	; 233
    b59c:	7f 4f       	sbci	r23, 0xFF	; 255
    b59e:	fb 01       	movw	r30, r22
    b5a0:	a5 91       	lpm	r26, Z+
    b5a2:	b4 91       	lpm	r27, Z+
    b5a4:	80 91 d6 02 	lds	r24, 0x02D6
    b5a8:	90 e0       	ldi	r25, 0x00	; 0
    b5aa:	82 95       	swap	r24
    b5ac:	92 95       	swap	r25
    b5ae:	90 7f       	andi	r25, 0xF0	; 240
    b5b0:	98 27       	eor	r25, r24
    b5b2:	80 7f       	andi	r24, 0xF0	; 240
    b5b4:	98 27       	eor	r25, r24
    b5b6:	a8 0f       	add	r26, r24
    b5b8:	b9 1f       	adc	r27, r25
    b5ba:	13 96       	adiw	r26, 0x03	; 3
    b5bc:	fd 01       	movw	r30, r26
    b5be:	e5 90       	lpm	r14, Z+
    b5c0:	f5 90       	lpm	r15, Z+
    b5c2:	05 91       	lpm	r16, Z+
    b5c4:	14 91       	lpm	r17, Z+
    b5c6:	fe 01       	movw	r30, r28
    b5c8:	72 96       	adiw	r30, 0x12	; 18
    b5ca:	50 e0       	ldi	r21, 0x00	; 0
    b5cc:	30 e0       	ldi	r19, 0x00	; 0
    b5ce:	24 1b       	sub	r18, r20
    b5d0:	31 09       	sbc	r19, r1
    b5d2:	22 30       	cpi	r18, 0x02	; 2
    b5d4:	31 05       	cpc	r19, r1
    b5d6:	0c f0       	brlt	.+2      	; 0xb5da <MenuDown+0x72>
    b5d8:	51 e0       	ldi	r21, 0x01	; 1
    b5da:	20 e0       	ldi	r18, 0x00	; 0
    b5dc:	80 91 a0 08 	lds	r24, 0x08A0
    b5e0:	83 30       	cpi	r24, 0x03	; 3
    b5e2:	08 f4       	brcc	.+2      	; 0xb5e6 <MenuDown+0x7e>
    b5e4:	21 e0       	ldi	r18, 0x01	; 1
    b5e6:	30 e0       	ldi	r19, 0x00	; 0
    b5e8:	80 91 f5 04 	lds	r24, 0x04F5
    b5ec:	90 91 f6 04 	lds	r25, 0x04F6
    b5f0:	a0 91 f7 04 	lds	r26, 0x04F7
    b5f4:	b0 91 f8 04 	lds	r27, 0x04F8
    b5f8:	e8 16       	cp	r14, r24
    b5fa:	f9 06       	cpc	r15, r25
    b5fc:	0a 07       	cpc	r16, r26
    b5fe:	1b 07       	cpc	r17, r27
    b600:	08 f4       	brcc	.+2      	; 0xb604 <MenuDown+0x9c>
    b602:	31 e0       	ldi	r19, 0x01	; 1
    b604:	cf 01       	movw	r24, r30
    b606:	6f ef       	ldi	r22, 0xFF	; 255
    b608:	45 2f       	mov	r20, r21
    b60a:	03 2f       	mov	r16, r19
    b60c:	0e 94 a2 58 	call	0xb144	; 0xb144 <MenuUD>
}
    b610:	df 91       	pop	r29
    b612:	cf 91       	pop	r28
    b614:	1f 91       	pop	r17
    b616:	0f 91       	pop	r16
    b618:	ff 90       	pop	r15
    b61a:	ef 90       	pop	r14
    b61c:	08 95       	ret

0000b61e <MenuUp>:
}

// ~~~~~~~~~
void
MenuUp(void)
{
    b61e:	ef 92       	push	r14
    b620:	ff 92       	push	r15
    b622:	0f 93       	push	r16
    b624:	1f 93       	push	r17
	uint8_t Fix=GetFix();
    b626:	a0 91 d4 02 	lds	r26, 0x02D4
    b62a:	b0 91 d5 02 	lds	r27, 0x02D5

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    b62e:	13 96       	adiw	r26, 0x03	; 3
    b630:	fd 01       	movw	r30, r26
    b632:	34 91       	lpm	r19, Z+
    b634:	13 97       	sbiw	r26, 0x03	; 3
	MenuUD(&CurrPage->Up, 1, CurrLine>Fix, CurrLCD>Fix, F_Buf<prd(&GetField->Max));
    b636:	20 91 83 07 	lds	r18, 0x0783

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    b63a:	fd 01       	movw	r30, r26
    b63c:	45 91       	lpm	r20, Z+
    b63e:	54 91       	lpm	r21, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    b640:	8b e1       	ldi	r24, 0x1B	; 27
    b642:	28 9f       	mul	r18, r24
    b644:	c0 01       	movw	r24, r0
    b646:	11 24       	eor	r1, r1
    b648:	48 0f       	add	r20, r24
    b64a:	59 1f       	adc	r21, r25
    b64c:	49 5e       	subi	r20, 0xE9	; 233
    b64e:	5f 4f       	sbci	r21, 0xFF	; 255
    b650:	fa 01       	movw	r30, r20
    b652:	65 91       	lpm	r22, Z+
    b654:	74 91       	lpm	r23, Z+
    b656:	80 91 d6 02 	lds	r24, 0x02D6
    b65a:	90 e0       	ldi	r25, 0x00	; 0
    b65c:	82 95       	swap	r24
    b65e:	92 95       	swap	r25
    b660:	90 7f       	andi	r25, 0xF0	; 240
    b662:	98 27       	eor	r25, r24
    b664:	80 7f       	andi	r24, 0xF0	; 240
    b666:	98 27       	eor	r25, r24
    b668:	68 0f       	add	r22, r24
    b66a:	79 1f       	adc	r23, r25
    b66c:	69 5f       	subi	r22, 0xF9	; 249
    b66e:	7f 4f       	sbci	r23, 0xFF	; 255
    b670:	fb 01       	movw	r30, r22
    b672:	e5 90       	lpm	r14, Z+
    b674:	f5 90       	lpm	r15, Z+
    b676:	05 91       	lpm	r16, Z+
    b678:	14 91       	lpm	r17, Z+
    b67a:	fd 01       	movw	r30, r26
    b67c:	70 96       	adiw	r30, 0x10	; 16
    b67e:	40 e0       	ldi	r20, 0x00	; 0
    b680:	32 17       	cp	r19, r18
    b682:	08 f4       	brcc	.+2      	; 0xb686 <MenuUp+0x68>
    b684:	41 e0       	ldi	r20, 0x01	; 1
    b686:	20 e0       	ldi	r18, 0x00	; 0
    b688:	80 91 a0 08 	lds	r24, 0x08A0
    b68c:	38 17       	cp	r19, r24
    b68e:	08 f4       	brcc	.+2      	; 0xb692 <MenuUp+0x74>
    b690:	21 e0       	ldi	r18, 0x01	; 1
    b692:	30 e0       	ldi	r19, 0x00	; 0
    b694:	80 91 f5 04 	lds	r24, 0x04F5
    b698:	90 91 f6 04 	lds	r25, 0x04F6
    b69c:	a0 91 f7 04 	lds	r26, 0x04F7
    b6a0:	b0 91 f8 04 	lds	r27, 0x04F8
    b6a4:	8e 15       	cp	r24, r14
    b6a6:	9f 05       	cpc	r25, r15
    b6a8:	a0 07       	cpc	r26, r16
    b6aa:	b1 07       	cpc	r27, r17
    b6ac:	08 f4       	brcc	.+2      	; 0xb6b0 <MenuUp+0x92>
    b6ae:	31 e0       	ldi	r19, 0x01	; 1
    b6b0:	cf 01       	movw	r24, r30
    b6b2:	61 e0       	ldi	r22, 0x01	; 1
    b6b4:	03 2f       	mov	r16, r19
    b6b6:	0e 94 a2 58 	call	0xb144	; 0xb144 <MenuUD>
}
    b6ba:	1f 91       	pop	r17
    b6bc:	0f 91       	pop	r16
    b6be:	ff 90       	pop	r15
    b6c0:	ef 90       	pop	r14
    b6c2:	08 95       	ret

0000b6c4 <PutField>:
	sprintf(Param->Pos, Format, Val);
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
PutField(uint8_t Type, void *Var, T_Param *Param)
{
    b6c4:	af 92       	push	r10
    b6c6:	bf 92       	push	r11
    b6c8:	cf 92       	push	r12
    b6ca:	df 92       	push	r13
    b6cc:	ef 92       	push	r14
    b6ce:	ff 92       	push	r15
    b6d0:	0f 93       	push	r16
    b6d2:	1f 93       	push	r17
    b6d4:	df 93       	push	r29
    b6d6:	cf 93       	push	r28
    b6d8:	cd b7       	in	r28, 0x3d	; 61
    b6da:	de b7       	in	r29, 0x3e	; 62
    b6dc:	69 97       	sbiw	r28, 0x19	; 25
    b6de:	0f b6       	in	r0, 0x3f	; 63
    b6e0:	f8 94       	cli
    b6e2:	de bf       	out	0x3e, r29	; 62
    b6e4:	0f be       	out	0x3f, r0	; 63
    b6e6:	cd bf       	out	0x3d, r28	; 61
    b6e8:	db 01       	movw	r26, r22
    b6ea:	7a 01       	movw	r14, r20
	float fTemp;

	switch(Type) {
    b6ec:	e8 2f       	mov	r30, r24
    b6ee:	f0 e0       	ldi	r31, 0x00	; 0
    b6f0:	e3 32       	cpi	r30, 0x23	; 35
    b6f2:	f1 05       	cpc	r31, r1
    b6f4:	88 f5       	brcc	.+98     	; 0xb758 <PutField+0x94>
    b6f6:	e7 52       	subi	r30, 0x27	; 39
    b6f8:	ff 4f       	sbci	r31, 0xFF	; 255
    b6fa:	ee 0f       	add	r30, r30
    b6fc:	ff 1f       	adc	r31, r31
    b6fe:	05 90       	lpm	r0, Z+
    b700:	f4 91       	lpm	r31, Z+
    b702:	e0 2d       	mov	r30, r0
    b704:	19 94       	eijmp
		break;
	case Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((*((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
		break;
	case EE_Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((erb((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
    b706:	fa 01       	movw	r30, r20
    b708:	a0 80       	ld	r10, Z
    b70a:	b1 80       	ldd	r11, Z+1	; 0x01
    b70c:	c4 80       	ldd	r12, Z+4	; 0x04
    b70e:	d5 80       	ldd	r13, Z+5	; 0x05
    b710:	12 81       	ldd	r17, Z+2	; 0x02
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    b712:	81 2f       	mov	r24, r17
    b714:	86 95       	lsr	r24
    b716:	86 95       	lsr	r24
    b718:	86 95       	lsr	r24
    b71a:	9b 01       	movw	r18, r22
    b71c:	28 0f       	add	r18, r24
    b71e:	31 1d       	adc	r19, r1
    b720:	c9 01       	movw	r24, r18
    b722:	0e 94 e7 82 	call	0x105ce	; 0x105ce <__eerd_byte_m2560>
    b726:	17 70       	andi	r17, 0x07	; 7
    b728:	21 e0       	ldi	r18, 0x01	; 1
    b72a:	30 e0       	ldi	r19, 0x00	; 0
    b72c:	02 c0       	rjmp	.+4      	; 0xb732 <PutField+0x6e>
    b72e:	22 0f       	add	r18, r18
    b730:	33 1f       	adc	r19, r19
    b732:	1a 95       	dec	r17
    b734:	e2 f7       	brpl	.-8      	; 0xb72e <PutField+0x6a>
    b736:	90 e0       	ldi	r25, 0x00	; 0
    b738:	28 23       	and	r18, r24
    b73a:	39 23       	and	r19, r25
    b73c:	12 16       	cp	r1, r18
    b73e:	13 06       	cpc	r1, r19
    b740:	0c f0       	brlt	.+2      	; 0xb744 <PutField+0x80>
    b742:	3f c1       	rjmp	.+638    	; 0xb9c2 <PutField+0x2fe>
    b744:	82 e0       	ldi	r24, 0x02	; 2
    b746:	90 e0       	ldi	r25, 0x00	; 0

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    b748:	f6 01       	movw	r30, r12
    b74a:	e8 0f       	add	r30, r24
    b74c:	f9 1f       	adc	r31, r25
    b74e:	65 91       	lpm	r22, Z+
    b750:	74 91       	lpm	r23, Z+
    b752:	c5 01       	movw	r24, r10
    b754:	0e 94 c6 7f 	call	0xff8c	; 0xff8c <strcpy_P>
			erbl(TempStr, Var, Param->Size);
			Put_TextValAlignRight(TempStr, Param);
		}
		break;
	}
}
    b758:	69 96       	adiw	r28, 0x19	; 25
    b75a:	0f b6       	in	r0, 0x3f	; 63
    b75c:	f8 94       	cli
    b75e:	de bf       	out	0x3e, r29	; 62
    b760:	0f be       	out	0x3f, r0	; 63
    b762:	cd bf       	out	0x3d, r28	; 61
    b764:	cf 91       	pop	r28
    b766:	df 91       	pop	r29
    b768:	1f 91       	pop	r17
    b76a:	0f 91       	pop	r16
    b76c:	ff 90       	pop	r15
    b76e:	ef 90       	pop	r14
    b770:	df 90       	pop	r13
    b772:	cf 90       	pop	r12
    b774:	bf 90       	pop	r11
    b776:	af 90       	pop	r10
    b778:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    b77a:	8e 01       	movw	r16, r28
    b77c:	0b 5f       	subi	r16, 0xFB	; 251
    b77e:	1f 4f       	sbci	r17, 0xFF	; 255
    b780:	fa 01       	movw	r30, r20
    b782:	43 81       	ldd	r20, Z+3	; 0x03
    b784:	c8 01       	movw	r24, r16
    b786:	50 e0       	ldi	r21, 0x00	; 0
    b788:	0e 94 d7 82 	call	0x105ae	; 0x105ae <__eerd_block_m2560>
		Put_TextValAlignRight(Var, Param);
		break;
	case EE_Text:{
			char TempStr[LCDXSz+1];
			erbl(TempStr, Var, Param->Size);
			Put_TextValAlignRight(TempStr, Param);
    b78c:	c8 01       	movw	r24, r16
    b78e:	b7 01       	movw	r22, r14
    b790:	0e 94 5d 43 	call	0x86ba	; 0x86ba <Put_TextValAlignRight>
    b794:	e1 cf       	rjmp	.-62     	; 0xb758 <PutField+0x94>
	case EE_Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((erb((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
		break;

	case Text:
		Put_TextValAlignRight(Var, Param);
    b796:	cb 01       	movw	r24, r22
    b798:	ba 01       	movw	r22, r20
    b79a:	0e 94 5d 43 	call	0x86ba	; 0x86ba <Put_TextValAlignRight>
    b79e:	dc cf       	rjmp	.-72     	; 0xb758 <PutField+0x94>
	case EE_Enum:
		Param->Txt += erb((uint8_t*)Var);
		PutEnum(Param);
		break;
	case Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((*((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
    b7a0:	fa 01       	movw	r30, r20
    b7a2:	00 81       	ld	r16, Z
    b7a4:	11 81       	ldd	r17, Z+1	; 0x01
    b7a6:	64 81       	ldd	r22, Z+4	; 0x04
    b7a8:	75 81       	ldd	r23, Z+5	; 0x05
    b7aa:	42 81       	ldd	r20, Z+2	; 0x02
    b7ac:	84 2f       	mov	r24, r20
    b7ae:	86 95       	lsr	r24
    b7b0:	86 95       	lsr	r24
    b7b2:	86 95       	lsr	r24
    b7b4:	a8 0f       	add	r26, r24
    b7b6:	b1 1d       	adc	r27, r1
    b7b8:	2c 91       	ld	r18, X
    b7ba:	30 e0       	ldi	r19, 0x00	; 0
    b7bc:	47 70       	andi	r20, 0x07	; 7
    b7be:	81 e0       	ldi	r24, 0x01	; 1
    b7c0:	90 e0       	ldi	r25, 0x00	; 0
    b7c2:	02 c0       	rjmp	.+4      	; 0xb7c8 <PutField+0x104>
    b7c4:	88 0f       	add	r24, r24
    b7c6:	99 1f       	adc	r25, r25
    b7c8:	4a 95       	dec	r20
    b7ca:	e2 f7       	brpl	.-8      	; 0xb7c4 <PutField+0x100>
    b7cc:	28 23       	and	r18, r24
    b7ce:	39 23       	and	r19, r25
    b7d0:	12 16       	cp	r1, r18
    b7d2:	13 06       	cpc	r1, r19
    b7d4:	0c f0       	brlt	.+2      	; 0xb7d8 <PutField+0x114>
    b7d6:	f8 c0       	rjmp	.+496    	; 0xb9c8 <PutField+0x304>
    b7d8:	82 e0       	ldi	r24, 0x02	; 2
    b7da:	90 e0       	ldi	r25, 0x00	; 0

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    b7dc:	fb 01       	movw	r30, r22
    b7de:	e8 0f       	add	r30, r24
    b7e0:	f9 1f       	adc	r31, r25
    b7e2:	65 91       	lpm	r22, Z+
    b7e4:	74 91       	lpm	r23, Z+
    b7e6:	c8 01       	movw	r24, r16
    b7e8:	0e 94 c6 7f 	call	0xff8c	; 0xff8c <strcpy_P>
    b7ec:	b5 cf       	rjmp	.-150    	; 0xb758 <PutField+0x94>
		Put_GFVal(fTemp, Param);
		break;


	case Enum:
		Param->Txt += *(uint8_t*)Var;
    b7ee:	2c 91       	ld	r18, X
    b7f0:	30 e0       	ldi	r19, 0x00	; 0
    b7f2:	22 0f       	add	r18, r18
    b7f4:	33 1f       	adc	r19, r19
    b7f6:	f7 01       	movw	r30, r14
    b7f8:	84 81       	ldd	r24, Z+4	; 0x04
    b7fa:	95 81       	ldd	r25, Z+5	; 0x05
    b7fc:	82 0f       	add	r24, r18
    b7fe:	93 1f       	adc	r25, r19
    b800:	95 83       	std	Z+5, r25	; 0x05
    b802:	84 83       	std	Z+4, r24	; 0x04
		PutEnum(Param);
    b804:	c7 01       	movw	r24, r14
    b806:	0e 94 09 41 	call	0x8212	; 0x8212 <PutEnum>
    b80a:	a6 cf       	rjmp	.-180    	; 0xb758 <PutField+0x94>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    b80c:	cb 01       	movw	r24, r22
    b80e:	0e 94 e7 82 	call	0x105ce	; 0x105ce <__eerd_byte_m2560>
		break;
	case EE_Enum:
		Param->Txt += erb((uint8_t*)Var);
    b812:	90 e0       	ldi	r25, 0x00	; 0
    b814:	88 0f       	add	r24, r24
    b816:	99 1f       	adc	r25, r25
    b818:	f7 01       	movw	r30, r14
    b81a:	24 81       	ldd	r18, Z+4	; 0x04
    b81c:	35 81       	ldd	r19, Z+5	; 0x05
    b81e:	28 0f       	add	r18, r24
    b820:	39 1f       	adc	r19, r25
    b822:	35 83       	std	Z+5, r19	; 0x05
    b824:	24 83       	std	Z+4, r18	; 0x04
		PutEnum(Param);
    b826:	c7 01       	movw	r24, r14
    b828:	0e 94 09 41 	call	0x8212	; 0x8212 <PutEnum>
    b82c:	95 cf       	rjmp	.-214    	; 0xb758 <PutField+0x94>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    b82e:	ce 01       	movw	r24, r28
    b830:	01 96       	adiw	r24, 0x01	; 1
    b832:	44 e0       	ldi	r20, 0x04	; 4
    b834:	50 e0       	ldi	r21, 0x00	; 0
    b836:	0e 94 d7 82 	call	0x105ae	; 0x105ae <__eerd_block_m2560>
	case GFloat:
		Put_GFVal(*(float*)Var, Param);
		break;			
	case EE_GFloat:
		erbl(&fTemp, Var, 4);
		Put_GFVal(fTemp, Param);
    b83a:	69 81       	ldd	r22, Y+1	; 0x01
    b83c:	7a 81       	ldd	r23, Y+2	; 0x02
    b83e:	8b 81       	ldd	r24, Y+3	; 0x03
    b840:	9c 81       	ldd	r25, Y+4	; 0x04
    b842:	a7 01       	movw	r20, r14
    b844:	0e 94 b9 43 	call	0x8772	; 0x8772 <Put_GFVal>
    b848:	87 cf       	rjmp	.-242    	; 0xb758 <PutField+0x94>
	case EE_FFloat:
		erbl(&fTemp, Var, 4);
		Put_FFVal(fTemp, Param);
		break;
	case GFloat:
		Put_GFVal(*(float*)Var, Param);
    b84a:	6d 91       	ld	r22, X+
    b84c:	7d 91       	ld	r23, X+
    b84e:	8d 91       	ld	r24, X+
    b850:	9c 91       	ld	r25, X
    b852:	0e 94 b9 43 	call	0x8772	; 0x8772 <Put_GFVal>
    b856:	80 cf       	rjmp	.-256    	; 0xb758 <PutField+0x94>
    b858:	ce 01       	movw	r24, r28
    b85a:	01 96       	adiw	r24, 0x01	; 1
    b85c:	44 e0       	ldi	r20, 0x04	; 4
    b85e:	50 e0       	ldi	r21, 0x00	; 0
    b860:	0e 94 d7 82 	call	0x105ae	; 0x105ae <__eerd_block_m2560>
	case FFloat:
		Put_FFVal(*(float*)Var, Param);
		break;			
	case EE_FFloat:
		erbl(&fTemp, Var, 4);
		Put_FFVal(fTemp, Param);
    b864:	69 81       	ldd	r22, Y+1	; 0x01
    b866:	7a 81       	ldd	r23, Y+2	; 0x02
    b868:	8b 81       	ldd	r24, Y+3	; 0x03
    b86a:	9c 81       	ldd	r25, Y+4	; 0x04
    b86c:	a7 01       	movw	r20, r14
    b86e:	0e 94 33 44 	call	0x8866	; 0x8866 <Put_FFVal>
    b872:	72 cf       	rjmp	.-284    	; 0xb758 <PutField+0x94>
		Put_zDVal(erd((uint32_t*)Var), Param);
		break;

		
	case FFloat:
		Put_FFVal(*(float*)Var, Param);
    b874:	6d 91       	ld	r22, X+
    b876:	7d 91       	ld	r23, X+
    b878:	8d 91       	ld	r24, X+
    b87a:	9c 91       	ld	r25, X
    b87c:	0e 94 33 44 	call	0x8866	; 0x8866 <Put_FFVal>
    b880:	6b cf       	rjmp	.-298    	; 0xb758 <PutField+0x94>
		break;
	case zh_Word:
		Put_zVal_h(*(uint16_t*)Var, 'w', Param);
		break;
	case zh_Longint:
		Put_zVal_h(*(uint32_t*)Var, 'l', Param);
    b882:	6d 91       	ld	r22, X+
    b884:	7d 91       	ld	r23, X+
    b886:	8d 91       	ld	r24, X+
    b888:	9c 91       	ld	r25, X
    b88a:	4c e6       	ldi	r20, 0x6C	; 108
    b88c:	97 01       	movw	r18, r14
    b88e:	0e 94 f3 47 	call	0x8fe6	; 0x8fe6 <Put_zVal_h>
    b892:	62 cf       	rjmp	.-316    	; 0xb758 <PutField+0x94>
// ~~~~~~~~~~~~~~~~~~~~~~
uint32_t
erd(const uint32_t *addr)
{
	//IntOff();
	uint32_t word = eeprom_read_dword(addr);
    b894:	cb 01       	movw	r24, r22
    b896:	0e 94 ef 82 	call	0x105de	; 0x105de <__eerd_dword_m2560>
		break;
	case z_Longint: case zc_Longint:
		Put_zDVal(*(uint32_t*)Var, Param);
		break;
	case z_EE_Longint:
		Put_zDVal(erd((uint32_t*)Var), Param);
    b89a:	a7 01       	movw	r20, r14
    b89c:	0e 94 88 44 	call	0x8910	; 0x8910 <Put_zDVal>
    b8a0:	5b cf       	rjmp	.-330    	; 0xb758 <PutField+0x94>
		break;
	case s_EE_Longint:
		Put_sDVal((int32_t)erd((uint32_t*)Var), Param);
		break;
	case z_Longint: case zc_Longint:
		Put_zDVal(*(uint32_t*)Var, Param);
    b8a2:	6d 91       	ld	r22, X+
    b8a4:	7d 91       	ld	r23, X+
    b8a6:	8d 91       	ld	r24, X+
    b8a8:	9c 91       	ld	r25, X
    b8aa:	0e 94 88 44 	call	0x8910	; 0x8910 <Put_zDVal>
    b8ae:	54 cf       	rjmp	.-344    	; 0xb758 <PutField+0x94>
    b8b0:	cb 01       	movw	r24, r22
    b8b2:	0e 94 ef 82 	call	0x105de	; 0x105de <__eerd_dword_m2560>
		break;
	case s_Longint:
		Put_sDVal(*(int32_t*)Var, Param);
		break;
	case s_EE_Longint:
		Put_sDVal((int32_t)erd((uint32_t*)Var), Param);
    b8b6:	a7 01       	movw	r20, r14
    b8b8:	0e 94 a9 45 	call	0x8b52	; 0x8b52 <Put_sDVal>
    b8bc:	4d cf       	rjmp	.-358    	; 0xb758 <PutField+0x94>
		break;
	case EE_Longint:
		PutDVal(erd((uint32_t*)Var), Param);
		break;
	case s_Longint:
		Put_sDVal(*(int32_t*)Var, Param);
    b8be:	6d 91       	ld	r22, X+
    b8c0:	7d 91       	ld	r23, X+
    b8c2:	8d 91       	ld	r24, X+
    b8c4:	9c 91       	ld	r25, X
    b8c6:	0e 94 a9 45 	call	0x8b52	; 0x8b52 <Put_sDVal>
    b8ca:	46 cf       	rjmp	.-372    	; 0xb758 <PutField+0x94>
    b8cc:	cb 01       	movw	r24, r22
    b8ce:	0e 94 ef 82 	call	0x105de	; 0x105de <__eerd_dword_m2560>

	case Longint: case c_Longint:
		PutDVal(*(uint32_t*)Var, Param);
		break;
	case EE_Longint:
		PutDVal(erd((uint32_t*)Var), Param);
    b8d2:	a7 01       	movw	r20, r14
    b8d4:	0e 94 d2 46 	call	0x8da4	; 0x8da4 <PutDVal>
    b8d8:	3f cf       	rjmp	.-386    	; 0xb758 <PutField+0x94>
		Put_zVal(erw((uint16_t*)Var), 'w', Param);
		break;


	case Longint: case c_Longint:
		PutDVal(*(uint32_t*)Var, Param);
    b8da:	6d 91       	ld	r22, X+
    b8dc:	7d 91       	ld	r23, X+
    b8de:	8d 91       	ld	r24, X+
    b8e0:	9c 91       	ld	r25, X
    b8e2:	0e 94 d2 46 	call	0x8da4	; 0x8da4 <PutDVal>
    b8e6:	38 cf       	rjmp	.-400    	; 0xb758 <PutField+0x94>

	case zh_Byte:
		Put_zVal_h(*(uint8_t*)Var, 'b', Param);
		break;
	case zh_Word:
		Put_zVal_h(*(uint16_t*)Var, 'w', Param);
    b8e8:	6d 91       	ld	r22, X+
    b8ea:	7c 91       	ld	r23, X
    b8ec:	80 e0       	ldi	r24, 0x00	; 0
    b8ee:	90 e0       	ldi	r25, 0x00	; 0
    b8f0:	47 e7       	ldi	r20, 0x77	; 119
    b8f2:	97 01       	movw	r18, r14
    b8f4:	0e 94 f3 47 	call	0x8fe6	; 0x8fe6 <Put_zVal_h>
    b8f8:	2f cf       	rjmp	.-418    	; 0xb758 <PutField+0x94>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    b8fa:	cb 01       	movw	r24, r22
    b8fc:	0e 94 f5 82 	call	0x105ea	; 0x105ea <__eerd_word_m2560>
		break;
	case z_Word: case zc_Word:
		Put_zVal(*(uint16_t*)Var, 'w', Param);
		break;
	case z_EE_Word:
		Put_zVal(erw((uint16_t*)Var), 'w', Param);
    b900:	67 e7       	ldi	r22, 0x77	; 119
    b902:	a7 01       	movw	r20, r14
    b904:	0e 94 66 48 	call	0x90cc	; 0x90cc <Put_zVal>
    b908:	27 cf       	rjmp	.-434    	; 0xb758 <PutField+0x94>
		break;
	case s_EE_Word:
		Put_sVal((int16_t)erw((uint16_t*)Var), 'w', Param);
		break;
	case z_Word: case zc_Word:
		Put_zVal(*(uint16_t*)Var, 'w', Param);
    b90a:	8d 91       	ld	r24, X+
    b90c:	9c 91       	ld	r25, X
    b90e:	67 e7       	ldi	r22, 0x77	; 119
    b910:	0e 94 66 48 	call	0x90cc	; 0x90cc <Put_zVal>
    b914:	21 cf       	rjmp	.-446    	; 0xb758 <PutField+0x94>
    b916:	cb 01       	movw	r24, r22
    b918:	0e 94 f5 82 	call	0x105ea	; 0x105ea <__eerd_word_m2560>
		break;
	case s_Word:
		Put_sVal(*(int16_t*)Var, 'w', Param);
		break;
	case s_EE_Word:
		Put_sVal((int16_t)erw((uint16_t*)Var), 'w', Param);
    b91c:	67 e7       	ldi	r22, 0x77	; 119
    b91e:	a7 01       	movw	r20, r14
    b920:	0e 94 23 49 	call	0x9246	; 0x9246 <Put_sVal>
    b924:	19 cf       	rjmp	.-462    	; 0xb758 <PutField+0x94>
		break;
	case EE_Word:
		PutVal(erw((uint16_t*)Var), 'w', Param);
		break;
	case s_Word:
		Put_sVal(*(int16_t*)Var, 'w', Param);
    b926:	8d 91       	ld	r24, X+
    b928:	9c 91       	ld	r25, X
    b92a:	67 e7       	ldi	r22, 0x77	; 119
    b92c:	0e 94 23 49 	call	0x9246	; 0x9246 <Put_sVal>
    b930:	13 cf       	rjmp	.-474    	; 0xb758 <PutField+0x94>
    b932:	cb 01       	movw	r24, r22
    b934:	0e 94 f5 82 	call	0x105ea	; 0x105ea <__eerd_word_m2560>

	case Word: case c_Word:
		PutVal(*(uint16_t*)Var, 'w', Param);
		break;
	case EE_Word:
		PutVal(erw((uint16_t*)Var), 'w', Param);
    b938:	67 e7       	ldi	r22, 0x77	; 119
    b93a:	a7 01       	movw	r20, r14
    b93c:	0e 94 07 4a 	call	0x940e	; 0x940e <PutVal>
    b940:	0b cf       	rjmp	.-490    	; 0xb758 <PutField+0x94>
	case zh_Longint:
		Put_zVal_h(*(uint32_t*)Var, 'l', Param);
		break;

	case Word: case c_Word:
		PutVal(*(uint16_t*)Var, 'w', Param);
    b942:	8d 91       	ld	r24, X+
    b944:	9c 91       	ld	r25, X
    b946:	67 e7       	ldi	r22, 0x77	; 119
    b948:	0e 94 07 4a 	call	0x940e	; 0x940e <PutVal>
    b94c:	05 cf       	rjmp	.-502    	; 0xb758 <PutField+0x94>
	case z_EE_Byte:
		Put_zVal(erb((uint8_t*)Var), 'b', Param);
		break;

	case zh_Byte:
		Put_zVal_h(*(uint8_t*)Var, 'b', Param);
    b94e:	6c 91       	ld	r22, X
    b950:	70 e0       	ldi	r23, 0x00	; 0
    b952:	80 e0       	ldi	r24, 0x00	; 0
    b954:	90 e0       	ldi	r25, 0x00	; 0
    b956:	42 e6       	ldi	r20, 0x62	; 98
    b958:	97 01       	movw	r18, r14
    b95a:	0e 94 f3 47 	call	0x8fe6	; 0x8fe6 <Put_zVal_h>
    b95e:	fc ce       	rjmp	.-520    	; 0xb758 <PutField+0x94>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    b960:	cb 01       	movw	r24, r22
    b962:	0e 94 e7 82 	call	0x105ce	; 0x105ce <__eerd_byte_m2560>
		break;
	case z_Byte:
		Put_zVal(*(uint8_t*)Var, 'b', Param);
		break;
	case z_EE_Byte:
		Put_zVal(erb((uint8_t*)Var), 'b', Param);
    b966:	90 e0       	ldi	r25, 0x00	; 0
    b968:	62 e6       	ldi	r22, 0x62	; 98
    b96a:	a7 01       	movw	r20, r14
    b96c:	0e 94 66 48 	call	0x90cc	; 0x90cc <Put_zVal>
    b970:	f3 ce       	rjmp	.-538    	; 0xb758 <PutField+0x94>
		break;
	case s_EE_Byte:
		Put_sVal((int8_t)erb((uint8_t*)Var), 'b', Param);
		break;
	case z_Byte:
		Put_zVal(*(uint8_t*)Var, 'b', Param);
    b972:	8c 91       	ld	r24, X
    b974:	90 e0       	ldi	r25, 0x00	; 0
    b976:	62 e6       	ldi	r22, 0x62	; 98
    b978:	0e 94 66 48 	call	0x90cc	; 0x90cc <Put_zVal>
    b97c:	ed ce       	rjmp	.-550    	; 0xb758 <PutField+0x94>
    b97e:	cb 01       	movw	r24, r22
    b980:	0e 94 e7 82 	call	0x105ce	; 0x105ce <__eerd_byte_m2560>
		break;
	case s_Byte:
		Put_sVal(*(int8_t*)Var, 'b', Param);
		break;
	case s_EE_Byte:
		Put_sVal((int8_t)erb((uint8_t*)Var), 'b', Param);
    b984:	99 27       	eor	r25, r25
    b986:	87 fd       	sbrc	r24, 7
    b988:	90 95       	com	r25
    b98a:	62 e6       	ldi	r22, 0x62	; 98
    b98c:	a7 01       	movw	r20, r14
    b98e:	0e 94 23 49 	call	0x9246	; 0x9246 <Put_sVal>
    b992:	e2 ce       	rjmp	.-572    	; 0xb758 <PutField+0x94>
		break;
	case EE_Byte:
		PutVal(erb((uint8_t*)Var), 'b', Param);
		break;
	case s_Byte:
		Put_sVal(*(int8_t*)Var, 'b', Param);
    b994:	8c 91       	ld	r24, X
    b996:	99 27       	eor	r25, r25
    b998:	87 fd       	sbrc	r24, 7
    b99a:	90 95       	com	r25
    b99c:	62 e6       	ldi	r22, 0x62	; 98
    b99e:	0e 94 23 49 	call	0x9246	; 0x9246 <Put_sVal>
    b9a2:	da ce       	rjmp	.-588    	; 0xb758 <PutField+0x94>
    b9a4:	cb 01       	movw	r24, r22
    b9a6:	0e 94 e7 82 	call	0x105ce	; 0x105ce <__eerd_byte_m2560>
	switch(Type) {
	case Byte:
		PutVal(*(uint8_t*)Var, 'b', Param);
		break;
	case EE_Byte:
		PutVal(erb((uint8_t*)Var), 'b', Param);
    b9aa:	90 e0       	ldi	r25, 0x00	; 0
    b9ac:	62 e6       	ldi	r22, 0x62	; 98
    b9ae:	a7 01       	movw	r20, r14
    b9b0:	0e 94 07 4a 	call	0x940e	; 0x940e <PutVal>
    b9b4:	d1 ce       	rjmp	.-606    	; 0xb758 <PutField+0x94>
{
	float fTemp;

	switch(Type) {
	case Byte:
		PutVal(*(uint8_t*)Var, 'b', Param);
    b9b6:	8c 91       	ld	r24, X
    b9b8:	90 e0       	ldi	r25, 0x00	; 0
    b9ba:	62 e6       	ldi	r22, 0x62	; 98
    b9bc:	0e 94 07 4a 	call	0x940e	; 0x940e <PutVal>
    b9c0:	cb ce       	rjmp	.-618    	; 0xb758 <PutField+0x94>
		break;
	case Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((*((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
		break;
	case EE_Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((erb((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
    b9c2:	80 e0       	ldi	r24, 0x00	; 0
    b9c4:	90 e0       	ldi	r25, 0x00	; 0
    b9c6:	c0 ce       	rjmp	.-640    	; 0xb748 <PutField+0x84>
	case EE_Enum:
		Param->Txt += erb((uint8_t*)Var);
		PutEnum(Param);
		break;
	case Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((*((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
    b9c8:	80 e0       	ldi	r24, 0x00	; 0
    b9ca:	90 e0       	ldi	r25, 0x00	; 0
    b9cc:	07 cf       	rjmp	.-498    	; 0xb7dc <PutField+0x118>

0000b9ce <PutLine>:
	PosBlink(Param,'_');
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
PutLine(uint8_t LineN, uint8_t Y)
{
    b9ce:	2f 92       	push	r2
    b9d0:	3f 92       	push	r3
    b9d2:	4f 92       	push	r4
    b9d4:	5f 92       	push	r5
    b9d6:	6f 92       	push	r6
    b9d8:	7f 92       	push	r7
    b9da:	8f 92       	push	r8
    b9dc:	9f 92       	push	r9
    b9de:	af 92       	push	r10
    b9e0:	bf 92       	push	r11
    b9e2:	cf 92       	push	r12
    b9e4:	df 92       	push	r13
    b9e6:	ef 92       	push	r14
    b9e8:	ff 92       	push	r15
    b9ea:	0f 93       	push	r16
    b9ec:	1f 93       	push	r17
    b9ee:	df 93       	push	r29
    b9f0:	cf 93       	push	r28
    b9f2:	cd b7       	in	r28, 0x3d	; 61
    b9f4:	de b7       	in	r29, 0x3e	; 62
    b9f6:	60 97       	sbiw	r28, 0x10	; 16
    b9f8:	0f b6       	in	r0, 0x3f	; 63
    b9fa:	f8 94       	cli
    b9fc:	de bf       	out	0x3e, r29	; 62
    b9fe:	0f be       	out	0x3f, r0	; 63
    ba00:	cd bf       	out	0x3d, r28	; 61
    ba02:	8f 87       	std	Y+15, r24	; 0x0f
    ba04:	68 8b       	std	Y+16, r22	; 0x10

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    ba06:	e0 91 d4 02 	lds	r30, 0x02D4
    ba0a:	f0 91 d5 02 	lds	r31, 0x02D5
    ba0e:	e5 90       	lpm	r14, Z+
    ba10:	f4 90       	lpm	r15, Z+
	MenuLine *Line=GetLine+LineN;
    ba12:	8b e1       	ldi	r24, 0x1B	; 27
    ba14:	2f 85       	ldd	r18, Y+15	; 0x0f
    ba16:	28 9f       	mul	r18, r24
    ba18:	c0 01       	movw	r24, r0
    ba1a:	11 24       	eor	r1, r1
    ba1c:	e8 0e       	add	r14, r24
    ba1e:	f9 1e       	adc	r15, r25
	PGM_P CurrStr=(PGM_P)(Line->Str);
    ba20:	be 2c       	mov	r11, r14
    ba22:	af 2c       	mov	r10, r15
    ba24:	f7 01       	movw	r30, r14
    ba26:	75 96       	adiw	r30, 0x15	; 21
    ba28:	c5 90       	lpm	r12, Z+
    ba2a:	d4 90       	lpm	r13, Z+

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    ba2c:	f7 01       	movw	r30, r14
    ba2e:	77 96       	adiw	r30, 0x17	; 23
    ba30:	85 91       	lpm	r24, Z+
    ba32:	94 91       	lpm	r25, Z+
    ba34:	9e 87       	std	Y+14, r25	; 0x0e
    ba36:	8d 87       	std	Y+13, r24	; 0x0d
    ba38:	87 01       	movw	r16, r14
    ba3a:	f7 01       	movw	r30, r14
    ba3c:	84 91       	lpm	r24, Z+
	uint8_t X;
	uint8_t X0=0;
	uint8_t X1=LCDXSz;
	int8_t Xs = 0;
	//--- ">>" Align right
	if(prc(CurrStr+0) == '>' && prc(CurrStr+1) == '>'){
    ba3e:	8e 33       	cpi	r24, 0x3E	; 62
    ba40:	09 f4       	brne	.+2      	; 0xba44 <PutLine+0x76>
    ba42:	a6 c1       	rjmp	.+844    	; 0xbd90 <PutLine+0x3c2>
		X0 = LCDXSz - strlen_P(CurrStr) + 2;
		Xs = X0-2;
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';
    ba44:	40 e0       	ldi	r20, 0x00	; 0
    ba46:	50 e0       	ldi	r21, 0x00	; 0
    ba48:	f8 01       	movw	r30, r16
    ba4a:	84 91       	lpm	r24, Z+
	}
	//--- "<<" Align left
	if(prc(CurrStr+0) == '<' && prc(CurrStr+1) == '<'){
    ba4c:	8c 33       	cpi	r24, 0x3C	; 60
    ba4e:	09 f4       	brne	.+2      	; 0xba52 <PutLine+0x84>
    ba50:	8a c1       	rjmp	.+788    	; 0xbd66 <PutLine+0x398>
		X1 = strlen_P(CurrStr) - 2;
    ba52:	84 e1       	ldi	r24, 0x14	; 20
    ba54:	98 2e       	mov	r9, r24
    ba56:	f8 01       	movw	r30, r16
    ba58:	84 91       	lpm	r24, Z+
		X0 = 0;
		Xs = X0-2;
	}
	//--- "<>" Align center
	if(prc(CurrStr+0) == '<' && prc(CurrStr+1) == '>'){
    ba5a:	8c 33       	cpi	r24, 0x3C	; 60
    ba5c:	09 f4       	brne	.+2      	; 0xba60 <PutLine+0x92>
    ba5e:	56 c1       	rjmp	.+684    	; 0xbd0c <PutLine+0x33e>
		Xs = X0-2;
		X1 = X0 + (strlen_P(CurrStr) - 2);
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';		
	}
	//---
	for(X=X0; X<X1; X++){
    ba60:	49 15       	cp	r20, r9
    ba62:	08 f0       	brcs	.+2      	; 0xba66 <PutLine+0x98>
    ba64:	ac c0       	rjmp	.+344    	; 0xbbbe <PutLine+0x1f0>
static void
PutLine(uint8_t LineN, uint8_t Y)
{
	MenuLine *Line=GetLine+LineN;
	PGM_P CurrStr=(PGM_P)(Line->Str);
	InField *IF = prp(&Line->IF_List);
    ba66:	88 89       	ldd	r24, Y+16	; 0x10
    ba68:	28 2f       	mov	r18, r24
    ba6a:	30 e0       	ldi	r19, 0x00	; 0
    ba6c:	c9 01       	movw	r24, r18
    ba6e:	88 0f       	add	r24, r24
    ba70:	99 1f       	adc	r25, r25
    ba72:	82 0f       	add	r24, r18
    ba74:	93 1f       	adc	r25, r19
    ba76:	5c 01       	movw	r10, r24
    ba78:	aa 0c       	add	r10, r10
    ba7a:	bb 1c       	adc	r11, r11
    ba7c:	aa 0c       	add	r10, r10
    ba7e:	bb 1c       	adc	r11, r11
    ba80:	aa 0c       	add	r10, r10
    ba82:	bb 1c       	adc	r11, r11
    ba84:	a8 1a       	sub	r10, r24
    ba86:	b9 0a       	sbc	r11, r25
    ba88:	25 2e       	mov	r2, r21
    ba8a:	33 24       	eor	r3, r3
    ba8c:	27 fc       	sbrc	r2, 7
    ba8e:	30 94       	com	r3
    ba90:	04 2f       	mov	r16, r20
    ba92:	88 24       	eor	r8, r8
		switch(Char=prc(CurrStr+X-Xs)) {
		case '{':
			while((Char=prc(CurrStr + X - Xs + ++Param.Size))=='{');
			Param.Prec = prb(&IF->Prec);
			Param.Txt = prp(&IF->EnumList);
			PutField(prb(&IF->Type), prp(&IF->Var), &Param);
    ba94:	3e 01       	movw	r6, r28
    ba96:	08 94       	sec
    ba98:	61 1c       	adc	r6, r1
    ba9a:	71 1c       	adc	r7, r1
			else
				PutField(prb(&(OF+OF_N)->Type), prp(&(OF+OF_N)->Var), &Param);
			OF_N++;
			break;
		}
		LCD_Buf[Y][X+=Param.Size] = Char;
    ba9c:	25 01       	movw	r4, r10
    ba9e:	11 c0       	rjmp	.+34     	; 0xbac2 <PutLine+0xf4>
	for(X=X0; X<X1; X++){
		char Char;
		T_Param Param;
		Param.Pos = LCD_Buf[Y]+X;
		Param.Size = 0;
		switch(Char=prc(CurrStr+X-Xs)) {
    baa0:	1d 37       	cpi	r17, 0x7D	; 125
    baa2:	09 f4       	brne	.+2      	; 0xbaa6 <PutLine+0xd8>
    baa4:	4c c0       	rjmp	.+152    	; 0xbb3e <PutLine+0x170>
    baa6:	30 e0       	ldi	r19, 0x00	; 0
			else
				PutField(prb(&(OF+OF_N)->Type), prp(&(OF+OF_N)->Var), &Param);
			OF_N++;
			break;
		}
		LCD_Buf[Y][X+=Param.Size] = Char;
    baa8:	80 2f       	mov	r24, r16
    baaa:	83 0f       	add	r24, r19
    baac:	f2 01       	movw	r30, r4
    baae:	e8 0f       	add	r30, r24
    bab0:	f1 1d       	adc	r31, r1
    bab2:	ea 5a       	subi	r30, 0xAA	; 170
    bab4:	f9 4f       	sbci	r31, 0xF9	; 249
    bab6:	10 83       	st	Z, r17
		Xs = X0-2;
		X1 = X0 + (strlen_P(CurrStr) - 2);
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';		
	}
	//---
	for(X=X0; X<X1; X++){
    bab8:	08 2f       	mov	r16, r24
    baba:	0f 5f       	subi	r16, 0xFF	; 255
    babc:	09 15       	cp	r16, r9
    babe:	08 f0       	brcs	.+2      	; 0xbac2 <PutLine+0xf4>
    bac0:	7e c0       	rjmp	.+252    	; 0xbbbe <PutLine+0x1f0>
		char Char;
		T_Param Param;
		Param.Pos = LCD_Buf[Y]+X;
    bac2:	80 2f       	mov	r24, r16
    bac4:	90 e0       	ldi	r25, 0x00	; 0
    bac6:	9c 01       	movw	r18, r24
    bac8:	2a 0d       	add	r18, r10
    baca:	3b 1d       	adc	r19, r11
    bacc:	2a 5a       	subi	r18, 0xAA	; 170
    bace:	39 4f       	sbci	r19, 0xF9	; 249
    bad0:	3a 83       	std	Y+2, r19	; 0x02
    bad2:	29 83       	std	Y+1, r18	; 0x01
		Param.Size = 0;
		switch(Char=prc(CurrStr+X-Xs)) {
    bad4:	82 19       	sub	r24, r2
    bad6:	93 09       	sbc	r25, r3
    bad8:	f7 01       	movw	r30, r14
    bada:	e8 0f       	add	r30, r24
    badc:	f9 1f       	adc	r31, r25
    bade:	14 91       	lpm	r17, Z+
    bae0:	1b 37       	cpi	r17, 0x7B	; 123
    bae2:	f1 f6       	brne	.-68     	; 0xbaa0 <PutLine+0xd2>
    bae4:	21 e0       	ldi	r18, 0x01	; 1
    bae6:	01 c0       	rjmp	.+2      	; 0xbaea <PutLine+0x11c>
		case '{':
			while((Char=prc(CurrStr + X - Xs + ++Param.Size))=='{');
    bae8:	23 2f       	mov	r18, r19
    baea:	fc 01       	movw	r30, r24
    baec:	e2 0f       	add	r30, r18
    baee:	f1 1d       	adc	r31, r1
    baf0:	ee 0d       	add	r30, r14
    baf2:	ff 1d       	adc	r31, r15
    baf4:	14 91       	lpm	r17, Z+
    baf6:	32 2f       	mov	r19, r18
    baf8:	3f 5f       	subi	r19, 0xFF	; 255
    bafa:	1b 37       	cpi	r17, 0x7B	; 123
    bafc:	a9 f3       	breq	.-22     	; 0xbae8 <PutLine+0x11a>
    bafe:	2c 83       	std	Y+4, r18	; 0x04

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    bb00:	a5 e0       	ldi	r26, 0x05	; 5
    bb02:	b0 e0       	ldi	r27, 0x00	; 0
    bb04:	ca 0e       	add	r12, r26
    bb06:	db 1e       	adc	r13, r27
    bb08:	f6 01       	movw	r30, r12
    bb0a:	84 91       	lpm	r24, Z+
    bb0c:	2b ef       	ldi	r18, 0xFB	; 251
    bb0e:	3f ef       	ldi	r19, 0xFF	; 255
    bb10:	c2 0e       	add	r12, r18
    bb12:	d3 1e       	adc	r13, r19
			Param.Prec = prb(&IF->Prec);
    bb14:	8b 83       	std	Y+3, r24	; 0x03

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    bb16:	f6 01       	movw	r30, r12
    bb18:	33 96       	adiw	r30, 0x03	; 3
    bb1a:	85 91       	lpm	r24, Z+
    bb1c:	94 91       	lpm	r25, Z+
			Param.Txt = prp(&IF->EnumList);
    bb1e:	9e 83       	std	Y+6, r25	; 0x06
    bb20:	8d 83       	std	Y+5, r24	; 0x05

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    bb22:	f6 01       	movw	r30, r12
    bb24:	84 91       	lpm	r24, Z+

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    bb26:	31 96       	adiw	r30, 0x01	; 1
    bb28:	65 91       	lpm	r22, Z+
    bb2a:	74 91       	lpm	r23, Z+
			PutField(prb(&IF->Type), prp(&IF->Var), &Param);
    bb2c:	a3 01       	movw	r20, r6
    bb2e:	0e 94 62 5b 	call	0xb6c4	; 0xb6c4 <PutField>
			IF++;
    bb32:	26 e0       	ldi	r18, 0x06	; 6
    bb34:	30 e0       	ldi	r19, 0x00	; 0
    bb36:	c2 0e       	add	r12, r18
    bb38:	d3 1e       	adc	r13, r19
    bb3a:	3c 81       	ldd	r19, Y+4	; 0x04
    bb3c:	b5 cf       	rjmp	.-150    	; 0xbaa8 <PutLine+0xda>
			break;
    bb3e:	21 e0       	ldi	r18, 0x01	; 1
    bb40:	01 c0       	rjmp	.+2      	; 0xbb44 <PutLine+0x176>
		case '}':
			while((Char=prc(CurrStr+X - Xs + ++Param.Size))=='}');
    bb42:	23 2f       	mov	r18, r19

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    bb44:	fc 01       	movw	r30, r24
    bb46:	e2 0f       	add	r30, r18
    bb48:	f1 1d       	adc	r31, r1
    bb4a:	ee 0d       	add	r30, r14
    bb4c:	ff 1d       	adc	r31, r15
    bb4e:	14 91       	lpm	r17, Z+
    bb50:	32 2f       	mov	r19, r18
    bb52:	3f 5f       	subi	r19, 0xFF	; 255
    bb54:	1d 37       	cpi	r17, 0x7D	; 125
    bb56:	a9 f3       	breq	.-22     	; 0xbb42 <PutLine+0x174>
    bb58:	2c 83       	std	Y+4, r18	; 0x04
			Y1=Y;
    bb5a:	38 89       	ldd	r19, Y+16	; 0x10
    bb5c:	30 93 fd 09 	sts	0x09FD, r19
			Param.Prec = prb(&(OF+OF_N)->Prec);
    bb60:	48 2d       	mov	r20, r8
    bb62:	50 e0       	ldi	r21, 0x00	; 0
    bb64:	42 95       	swap	r20
    bb66:	52 95       	swap	r21
    bb68:	50 7f       	andi	r21, 0xF0	; 240
    bb6a:	54 27       	eor	r21, r20
    bb6c:	40 7f       	andi	r20, 0xF0	; 240
    bb6e:	54 27       	eor	r21, r20
    bb70:	8d 85       	ldd	r24, Y+13	; 0x0d
    bb72:	9e 85       	ldd	r25, Y+14	; 0x0e
    bb74:	48 0f       	add	r20, r24
    bb76:	59 1f       	adc	r21, r25

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    bb78:	41 5f       	subi	r20, 0xF1	; 241
    bb7a:	5f 4f       	sbci	r21, 0xFF	; 255
    bb7c:	fa 01       	movw	r30, r20
    bb7e:	84 91       	lpm	r24, Z+
    bb80:	4f 50       	subi	r20, 0x0F	; 15
    bb82:	50 40       	sbci	r21, 0x00	; 0
    bb84:	8b 83       	std	Y+3, r24	; 0x03

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    bb86:	ca 01       	movw	r24, r20
    bb88:	0d 96       	adiw	r24, 0x0d	; 13
    bb8a:	fc 01       	movw	r30, r24
    bb8c:	25 91       	lpm	r18, Z+
    bb8e:	34 91       	lpm	r19, Z+
			Param.Txt = prp(&(OF+OF_N)->EnumList);
    bb90:	3e 83       	std	Y+6, r19	; 0x06
    bb92:	2d 83       	std	Y+5, r18	; 0x05
			if(LineN==CurrLine && OF_N==CurrField)
    bb94:	80 91 83 07 	lds	r24, 0x0783
    bb98:	ff 85       	ldd	r31, Y+15	; 0x0f
    bb9a:	f8 17       	cp	r31, r24
    bb9c:	29 f4       	brne	.+10     	; 0xbba8 <PutLine+0x1da>
    bb9e:	80 91 d6 02 	lds	r24, 0x02D6
    bba2:	88 16       	cp	r8, r24
    bba4:	09 f4       	brne	.+2      	; 0xbba8 <PutLine+0x1da>
    bba6:	43 c0       	rjmp	.+134    	; 0xbc2e <PutLine+0x260>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    bba8:	fa 01       	movw	r30, r20
    bbaa:	84 91       	lpm	r24, Z+

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    bbac:	31 96       	adiw	r30, 0x01	; 1
    bbae:	65 91       	lpm	r22, Z+
    bbb0:	74 91       	lpm	r23, Z+
				}
				else{ 
					PutBuf(prb(&(OF+OF_N)->Type), &Param);
				}			
			else
				PutField(prb(&(OF+OF_N)->Type), prp(&(OF+OF_N)->Var), &Param);
    bbb2:	a3 01       	movw	r20, r6
    bbb4:	0e 94 62 5b 	call	0xb6c4	; 0xb6c4 <PutField>
    bbb8:	3c 81       	ldd	r19, Y+4	; 0x04
			OF_N++;
    bbba:	83 94       	inc	r8
    bbbc:	75 cf       	rjmp	.-278    	; 0xbaa8 <PutLine+0xda>
		}
		LCD_Buf[Y][X+=Param.Size] = Char;

	}
	X=X1;
	for(;X<LCDXSz; X++) LCD_Buf[Y][X] = ' ';
    bbbe:	f3 e1       	ldi	r31, 0x13	; 19
    bbc0:	f9 15       	cp	r31, r9
    bbc2:	e0 f0       	brcs	.+56     	; 0xbbfc <PutLine+0x22e>
    bbc4:	88 89       	ldd	r24, Y+16	; 0x10
    bbc6:	28 2f       	mov	r18, r24
    bbc8:	30 e0       	ldi	r19, 0x00	; 0
    bbca:	49 2d       	mov	r20, r9
    bbcc:	c9 01       	movw	r24, r18
    bbce:	88 0f       	add	r24, r24
    bbd0:	99 1f       	adc	r25, r25
    bbd2:	82 0f       	add	r24, r18
    bbd4:	93 1f       	adc	r25, r19
    bbd6:	9c 01       	movw	r18, r24
    bbd8:	22 0f       	add	r18, r18
    bbda:	33 1f       	adc	r19, r19
    bbdc:	22 0f       	add	r18, r18
    bbde:	33 1f       	adc	r19, r19
    bbe0:	22 0f       	add	r18, r18
    bbe2:	33 1f       	adc	r19, r19
    bbe4:	28 1b       	sub	r18, r24
    bbe6:	39 0b       	sbc	r19, r25
    bbe8:	80 e2       	ldi	r24, 0x20	; 32
    bbea:	f9 01       	movw	r30, r18
    bbec:	e4 0f       	add	r30, r20
    bbee:	f1 1d       	adc	r31, r1
    bbf0:	ea 5a       	subi	r30, 0xAA	; 170
    bbf2:	f9 4f       	sbci	r31, 0xF9	; 249
    bbf4:	80 83       	st	Z, r24
    bbf6:	4f 5f       	subi	r20, 0xFF	; 255
    bbf8:	44 31       	cpi	r20, 0x14	; 20
    bbfa:	b8 f3       	brcs	.-18     	; 0xbbea <PutLine+0x21c>

}
    bbfc:	60 96       	adiw	r28, 0x10	; 16
    bbfe:	0f b6       	in	r0, 0x3f	; 63
    bc00:	f8 94       	cli
    bc02:	de bf       	out	0x3e, r29	; 62
    bc04:	0f be       	out	0x3f, r0	; 63
    bc06:	cd bf       	out	0x3d, r28	; 61
    bc08:	cf 91       	pop	r28
    bc0a:	df 91       	pop	r29
    bc0c:	1f 91       	pop	r17
    bc0e:	0f 91       	pop	r16
    bc10:	ff 90       	pop	r15
    bc12:	ef 90       	pop	r14
    bc14:	df 90       	pop	r13
    bc16:	cf 90       	pop	r12
    bc18:	bf 90       	pop	r11
    bc1a:	af 90       	pop	r10
    bc1c:	9f 90       	pop	r9
    bc1e:	8f 90       	pop	r8
    bc20:	7f 90       	pop	r7
    bc22:	6f 90       	pop	r6
    bc24:	5f 90       	pop	r5
    bc26:	4f 90       	pop	r4
    bc28:	3f 90       	pop	r3
    bc2a:	2f 90       	pop	r2
    bc2c:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    bc2e:	fa 01       	movw	r30, r20
    bc30:	84 91       	lpm	r24, Z+
			Y1=Y;
			Param.Prec = prb(&(OF+OF_N)->Prec);
			Param.Txt = prp(&(OF+OF_N)->EnumList);
			if(LineN==CurrLine && OF_N==CurrField)
				//add new
				if( (prb(&(OF+OF_N)->Type) == Text) || (prb(&(OF+OF_N)->Type) == EE_Text ) ||
    bc32:	81 32       	cpi	r24, 0x21	; 33
    bc34:	61 f1       	breq	.+88     	; 0xbc8e <PutLine+0x2c0>
    bc36:	82 32       	cpi	r24, 0x22	; 34
    bc38:	51 f1       	breq	.+84     	; 0xbc8e <PutLine+0x2c0>
    bc3a:	80 31       	cpi	r24, 0x10	; 16
    bc3c:	41 f1       	breq	.+80     	; 0xbc8e <PutLine+0x2c0>
    bc3e:	84 31       	cpi	r24, 0x14	; 20
    bc40:	31 f1       	breq	.+76     	; 0xbc8e <PutLine+0x2c0>
    bc42:	81 31       	cpi	r24, 0x11	; 17
    bc44:	21 f1       	breq	.+72     	; 0xbc8e <PutLine+0x2c0>
    bc46:	85 31       	cpi	r24, 0x15	; 21
    bc48:	11 f1       	breq	.+68     	; 0xbc8e <PutLine+0x2c0>
    bc4a:	82 31       	cpi	r24, 0x12	; 18
    bc4c:	01 f1       	breq	.+64     	; 0xbc8e <PutLine+0x2c0>
    bc4e:	83 31       	cpi	r24, 0x13	; 19
    bc50:	f1 f0       	breq	.+60     	; 0xbc8e <PutLine+0x2c0>
    bc52:	89 31       	cpi	r24, 0x19	; 25
    bc54:	e1 f0       	breq	.+56     	; 0xbc8e <PutLine+0x2c0>
    bc56:	8b 31       	cpi	r24, 0x1B	; 27
    bc58:	d1 f0       	breq	.+52     	; 0xbc8e <PutLine+0x2c0>
    bc5a:	8a 31       	cpi	r24, 0x1A	; 26
    bc5c:	c1 f0       	breq	.+48     	; 0xbc8e <PutLine+0x2c0>
    bc5e:	8c 31       	cpi	r24, 0x1C	; 28
    bc60:	b1 f0       	breq	.+44     	; 0xbc8e <PutLine+0x2c0>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
PutBuf(uint8_t Type, T_Param *Param)
{
	switch(Type) {
    bc62:	89 30       	cpi	r24, 0x09	; 9
    bc64:	08 f0       	brcs	.+2      	; 0xbc68 <PutLine+0x29a>
    bc66:	b7 c0       	rjmp	.+366    	; 0xbdd6 <PutLine+0x408>
    bc68:	87 30       	cpi	r24, 0x07	; 7
    bc6a:	08 f0       	brcs	.+2      	; 0xbc6e <PutLine+0x2a0>
    bc6c:	b9 c0       	rjmp	.+370    	; 0xbde0 <PutLine+0x412>
    bc6e:	84 30       	cpi	r24, 0x04	; 4
    bc70:	08 f0       	brcs	.+2      	; 0xbc74 <PutLine+0x2a6>
    bc72:	e5 c0       	rjmp	.+458    	; 0xbe3e <PutLine+0x470>
    bc74:	82 30       	cpi	r24, 0x02	; 2
    bc76:	08 f4       	brcc	.+2      	; 0xbc7a <PutLine+0x2ac>
    bc78:	b3 c0       	rjmp	.+358    	; 0xbde0 <PutLine+0x412>
		Put_bVal(Param);
		PosBlink(Param,' ');
		break;
	case s_Byte: case s_EE_Byte:
	case s_Word: case s_EE_Word:
		Put_sbVal(Param);
    bc7a:	c3 01       	movw	r24, r6
    bc7c:	0e 94 3a 41 	call	0x8274	; 0x8274 <Put_sbVal>
		PosBlink(Param,' ');
    bc80:	c3 01       	movw	r24, r6
    bc82:	60 e2       	ldi	r22, 0x20	; 32
    bc84:	0e 94 27 3d 	call	0x7a4e	; 0x7a4e <PosBlink>
    bc88:	3c 81       	ldd	r19, Y+4	; 0x04
				else{ 
					PutBuf(prb(&(OF+OF_N)->Type), &Param);
				}			
			else
				PutField(prb(&(OF+OF_N)->Type), prp(&(OF+OF_N)->Var), &Param);
			OF_N++;
    bc8a:	83 94       	inc	r8
    bc8c:	0d cf       	rjmp	.-486    	; 0xbaa8 <PutLine+0xda>
// When use BufStr for variable edit
inline static void
PutBufStr(uint8_t Type, T_Param *Param)
{	
	char Format[6];
	sprintf(Format,"%%.%us", Param->Size);
    bc8e:	00 d0       	rcall	.+0      	; 0xbc90 <PutLine+0x2c2>
    bc90:	00 d0       	rcall	.+0      	; 0xbc92 <PutLine+0x2c4>
    bc92:	ed b7       	in	r30, 0x3d	; 61
    bc94:	fe b7       	in	r31, 0x3e	; 62
    bc96:	31 96       	adiw	r30, 0x01	; 1
    bc98:	27 e0       	ldi	r18, 0x07	; 7
    bc9a:	30 e0       	ldi	r19, 0x00	; 0
    bc9c:	2c 0f       	add	r18, r28
    bc9e:	3d 1f       	adc	r19, r29
    bca0:	ad b7       	in	r26, 0x3d	; 61
    bca2:	be b7       	in	r27, 0x3e	; 62
    bca4:	12 96       	adiw	r26, 0x02	; 2
    bca6:	3c 93       	st	X, r19
    bca8:	2e 93       	st	-X, r18
    bcaa:	11 97       	sbiw	r26, 0x01	; 1
    bcac:	8b ea       	ldi	r24, 0xAB	; 171
    bcae:	92 e0       	ldi	r25, 0x02	; 2
    bcb0:	93 83       	std	Z+3, r25	; 0x03
    bcb2:	82 83       	std	Z+2, r24	; 0x02
    bcb4:	8c 81       	ldd	r24, Y+4	; 0x04
    bcb6:	84 83       	std	Z+4, r24	; 0x04
    bcb8:	15 82       	std	Z+5, r1	; 0x05
    bcba:	0e 94 b9 80 	call	0x10172	; 0x10172 <sprintf>
	sprintf(Param->Pos, Format, BufStr);
    bcbe:	ed b7       	in	r30, 0x3d	; 61
    bcc0:	fe b7       	in	r31, 0x3e	; 62
    bcc2:	31 96       	adiw	r30, 0x01	; 1
    bcc4:	89 81       	ldd	r24, Y+1	; 0x01
    bcc6:	9a 81       	ldd	r25, Y+2	; 0x02
    bcc8:	ad b7       	in	r26, 0x3d	; 61
    bcca:	be b7       	in	r27, 0x3e	; 62
    bccc:	12 96       	adiw	r26, 0x02	; 2
    bcce:	9c 93       	st	X, r25
    bcd0:	8e 93       	st	-X, r24
    bcd2:	11 97       	sbiw	r26, 0x01	; 1
    bcd4:	27 e0       	ldi	r18, 0x07	; 7
    bcd6:	30 e0       	ldi	r19, 0x00	; 0
    bcd8:	2c 0f       	add	r18, r28
    bcda:	3d 1f       	adc	r19, r29
    bcdc:	33 83       	std	Z+3, r19	; 0x03
    bcde:	22 83       	std	Z+2, r18	; 0x02
    bce0:	81 ec       	ldi	r24, 0xC1	; 193
    bce2:	95 e0       	ldi	r25, 0x05	; 5
    bce4:	95 83       	std	Z+5, r25	; 0x05
    bce6:	84 83       	std	Z+4, r24	; 0x04
    bce8:	0e 94 b9 80 	call	0x10172	; 0x10172 <sprintf>
	Param->Prec = 0;
    bcec:	1b 82       	std	Y+3, r1	; 0x03
	PosBlink(Param,'_');
    bcee:	ad b7       	in	r26, 0x3d	; 61
    bcf0:	be b7       	in	r27, 0x3e	; 62
    bcf2:	16 96       	adiw	r26, 0x06	; 6
    bcf4:	0f b6       	in	r0, 0x3f	; 63
    bcf6:	f8 94       	cli
    bcf8:	be bf       	out	0x3e, r27	; 62
    bcfa:	0f be       	out	0x3f, r0	; 63
    bcfc:	ad bf       	out	0x3d, r26	; 61
    bcfe:	c3 01       	movw	r24, r6
    bd00:	6f e5       	ldi	r22, 0x5F	; 95
    bd02:	0e 94 27 3d 	call	0x7a4e	; 0x7a4e <PosBlink>
    bd06:	3c 81       	ldd	r19, Y+4	; 0x04
				else{ 
					PutBuf(prb(&(OF+OF_N)->Type), &Param);
				}			
			else
				PutField(prb(&(OF+OF_N)->Type), prp(&(OF+OF_N)->Var), &Param);
			OF_N++;
    bd08:	83 94       	inc	r8
    bd0a:	ce ce       	rjmp	.-612    	; 0xbaa8 <PutLine+0xda>

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    bd0c:	08 94       	sec
    bd0e:	e1 1c       	adc	r14, r1
    bd10:	f1 1c       	adc	r15, r1
    bd12:	f7 01       	movw	r30, r14
    bd14:	84 91       	lpm	r24, Z+
    bd16:	08 94       	sec
    bd18:	e1 08       	sbc	r14, r1
    bd1a:	f1 08       	sbc	r15, r1
		X1 = strlen_P(CurrStr) - 2;
		X0 = 0;
		Xs = X0-2;
	}
	//--- "<>" Align center
	if(prc(CurrStr+0) == '<' && prc(CurrStr+1) == '>'){
    bd1c:	8e 33       	cpi	r24, 0x3E	; 62
    bd1e:	09 f0       	breq	.+2      	; 0xbd22 <PutLine+0x354>
    bd20:	9f ce       	rjmp	.-706    	; 0xba60 <PutLine+0x92>
		X0 = (LCDXSz - strlen_P(CurrStr) + 2) / 2;
    bd22:	8b 2d       	mov	r24, r11
    bd24:	9a 2d       	mov	r25, r10
    bd26:	0e 94 cd 7f 	call	0xff9a	; 0xff9a <strlen_P>
    bd2a:	26 e1       	ldi	r18, 0x16	; 22
    bd2c:	30 e0       	ldi	r19, 0x00	; 0
    bd2e:	28 1b       	sub	r18, r24
    bd30:	39 0b       	sbc	r19, r25
    bd32:	36 95       	lsr	r19
    bd34:	27 95       	ror	r18
    bd36:	42 2f       	mov	r20, r18
		Xs = X0-2;
    bd38:	52 2f       	mov	r21, r18
    bd3a:	52 50       	subi	r21, 0x02	; 2
		X1 = X0 + (strlen_P(CurrStr) - 2);
    bd3c:	be ef       	ldi	r27, 0xFE	; 254
    bd3e:	9b 2e       	mov	r9, r27
    bd40:	98 0e       	add	r9, r24
    bd42:	92 0e       	add	r9, r18
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';		
    bd44:	22 23       	and	r18, r18
    bd46:	09 f4       	brne	.+2      	; 0xbd4a <PutLine+0x37c>
    bd48:	8b ce       	rjmp	.-746    	; 0xba60 <PutLine+0x92>
    bd4a:	85 e1       	ldi	r24, 0x15	; 21
    bd4c:	28 89       	ldd	r18, Y+16	; 0x10
    bd4e:	28 9f       	mul	r18, r24
    bd50:	f0 01       	movw	r30, r0
    bd52:	11 24       	eor	r1, r1
    bd54:	ea 5a       	subi	r30, 0xAA	; 170
    bd56:	f9 4f       	sbci	r31, 0xF9	; 249
    bd58:	80 e0       	ldi	r24, 0x00	; 0
    bd5a:	90 e2       	ldi	r25, 0x20	; 32
    bd5c:	91 93       	st	Z+, r25
    bd5e:	8f 5f       	subi	r24, 0xFF	; 255
    bd60:	84 17       	cp	r24, r20
    bd62:	e0 f3       	brcs	.-8      	; 0xbd5c <PutLine+0x38e>
    bd64:	7d ce       	rjmp	.-774    	; 0xba60 <PutLine+0x92>
    bd66:	08 94       	sec
    bd68:	e1 1c       	adc	r14, r1
    bd6a:	f1 1c       	adc	r15, r1
    bd6c:	f7 01       	movw	r30, r14
    bd6e:	84 91       	lpm	r24, Z+
    bd70:	08 94       	sec
    bd72:	e1 08       	sbc	r14, r1
    bd74:	f1 08       	sbc	r15, r1
		X0 = LCDXSz - strlen_P(CurrStr) + 2;
		Xs = X0-2;
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';
	}
	//--- "<<" Align left
	if(prc(CurrStr+0) == '<' && prc(CurrStr+1) == '<'){
    bd76:	8c 33       	cpi	r24, 0x3C	; 60
    bd78:	09 f0       	breq	.+2      	; 0xbd7c <PutLine+0x3ae>
    bd7a:	6b ce       	rjmp	.-810    	; 0xba52 <PutLine+0x84>
		X1 = strlen_P(CurrStr) - 2;
    bd7c:	8b 2d       	mov	r24, r11
    bd7e:	9a 2d       	mov	r25, r10
    bd80:	0e 94 cd 7f 	call	0xff9a	; 0xff9a <strlen_P>
    bd84:	9e ef       	ldi	r25, 0xFE	; 254
    bd86:	99 2e       	mov	r9, r25
    bd88:	98 0e       	add	r9, r24
    bd8a:	40 e0       	ldi	r20, 0x00	; 0
    bd8c:	5e ef       	ldi	r21, 0xFE	; 254
    bd8e:	63 ce       	rjmp	.-826    	; 0xba56 <PutLine+0x88>
    bd90:	08 94       	sec
    bd92:	e1 1c       	adc	r14, r1
    bd94:	f1 1c       	adc	r15, r1
    bd96:	f7 01       	movw	r30, r14
    bd98:	84 91       	lpm	r24, Z+
    bd9a:	08 94       	sec
    bd9c:	e1 08       	sbc	r14, r1
    bd9e:	f1 08       	sbc	r15, r1
	uint8_t X;
	uint8_t X0=0;
	uint8_t X1=LCDXSz;
	int8_t Xs = 0;
	//--- ">>" Align right
	if(prc(CurrStr+0) == '>' && prc(CurrStr+1) == '>'){
    bda0:	8e 33       	cpi	r24, 0x3E	; 62
    bda2:	09 f0       	breq	.+2      	; 0xbda6 <PutLine+0x3d8>
    bda4:	4f ce       	rjmp	.-866    	; 0xba44 <PutLine+0x76>
		X0 = LCDXSz - strlen_P(CurrStr) + 2;
    bda6:	c7 01       	movw	r24, r14
    bda8:	0e 94 cd 7f 	call	0xff9a	; 0xff9a <strlen_P>
    bdac:	46 e1       	ldi	r20, 0x16	; 22
    bdae:	48 1b       	sub	r20, r24
		Xs = X0-2;
    bdb0:	54 2f       	mov	r21, r20
    bdb2:	52 50       	subi	r21, 0x02	; 2
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';
    bdb4:	44 23       	and	r20, r20
    bdb6:	09 f4       	brne	.+2      	; 0xbdba <PutLine+0x3ec>
    bdb8:	47 ce       	rjmp	.-882    	; 0xba48 <PutLine+0x7a>
    bdba:	85 e1       	ldi	r24, 0x15	; 21
    bdbc:	28 89       	ldd	r18, Y+16	; 0x10
    bdbe:	28 9f       	mul	r18, r24
    bdc0:	f0 01       	movw	r30, r0
    bdc2:	11 24       	eor	r1, r1
    bdc4:	ea 5a       	subi	r30, 0xAA	; 170
    bdc6:	f9 4f       	sbci	r31, 0xF9	; 249
    bdc8:	80 e0       	ldi	r24, 0x00	; 0
    bdca:	90 e2       	ldi	r25, 0x20	; 32
    bdcc:	91 93       	st	Z+, r25
    bdce:	8f 5f       	subi	r24, 0xFF	; 255
    bdd0:	84 17       	cp	r24, r20
    bdd2:	e0 f3       	brcs	.-8      	; 0xbdcc <PutLine+0x3fe>
    bdd4:	39 ce       	rjmp	.-910    	; 0xba48 <PutLine+0x7a>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
PutBuf(uint8_t Type, T_Param *Param)
{
	switch(Type) {
    bdd6:	8d 30       	cpi	r24, 0x0D	; 13
    bdd8:	68 f4       	brcc	.+26     	; 0xbdf4 <PutLine+0x426>
    bdda:	8b 30       	cpi	r24, 0x0B	; 11
    bddc:	08 f4       	brcc	.+2      	; 0xbde0 <PutLine+0x412>
    bdde:	4d cf       	rjmp	.-358    	; 0xbc7a <PutLine+0x2ac>
	case Byte: case EE_Byte: case z_Byte: case z_EE_Byte:
	case Word: case EE_Word: case z_Word: case z_EE_Word:
		Put_bVal(Param);
    bde0:	c3 01       	movw	r24, r6
    bde2:	0e 94 38 42 	call	0x8470	; 0x8470 <Put_bVal>
		PosBlink(Param,' ');
    bde6:	c3 01       	movw	r24, r6
    bde8:	60 e2       	ldi	r22, 0x20	; 32
    bdea:	0e 94 27 3d 	call	0x7a4e	; 0x7a4e <PosBlink>
    bdee:	3c 81       	ldd	r19, Y+4	; 0x04
				else{ 
					PutBuf(prb(&(OF+OF_N)->Type), &Param);
				}			
			else
				PutField(prb(&(OF+OF_N)->Type), prp(&(OF+OF_N)->Var), &Param);
			OF_N++;
    bdf0:	83 94       	inc	r8
    bdf2:	5a ce       	rjmp	.-844    	; 0xbaa8 <PutLine+0xda>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
PutBuf(uint8_t Type, T_Param *Param)
{
	switch(Type) {
    bdf4:	8e 30       	cpi	r24, 0x0E	; 14
    bdf6:	b9 f1       	breq	.+110    	; 0xbe66 <PutLine+0x498>
    bdf8:	8e 30       	cpi	r24, 0x0E	; 14
    bdfa:	28 f1       	brcs	.+74     	; 0xbe46 <PutLine+0x478>
    bdfc:	8d 51       	subi	r24, 0x1D	; 29
    bdfe:	84 30       	cpi	r24, 0x04	; 4
    be00:	08 f0       	brcs	.+2      	; 0xbe04 <PutLine+0x436>
    be02:	da ce       	rjmp	.-588    	; 0xbbb8 <PutLine+0x1ea>
	case zc_Word:
		Put_zVal(F_Buf, 'w', Param);
		ValBlink(Param->Pos, Param->Size);
		break;
	case Enum: case EE_Enum: case Bit: case EE_Bit:
		Param->Txt += (uint8_t)F_Buf;
    be04:	80 91 f5 04 	lds	r24, 0x04F5
    be08:	90 e0       	ldi	r25, 0x00	; 0
    be0a:	88 0f       	add	r24, r24
    be0c:	99 1f       	adc	r25, r25
    be0e:	28 0f       	add	r18, r24
    be10:	39 1f       	adc	r19, r25
    be12:	3e 83       	std	Y+6, r19	; 0x06
    be14:	2d 83       	std	Y+5, r18	; 0x05
		PutEnum(Param);
    be16:	c3 01       	movw	r24, r6
    be18:	0e 94 09 41 	call	0x8212	; 0x8212 <PutEnum>
		ValBlink(Param->Pos, Param->Size);
    be1c:	3c 81       	ldd	r19, Y+4	; 0x04

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
ValBlink(char *Pos, uint8_t Sz)
{
	CurrX=Pos-LCD_Buf[Y1];
    be1e:	80 91 fd 09 	lds	r24, 0x09FD
    be22:	f5 e1       	ldi	r31, 0x15	; 21
    be24:	8f 9f       	mul	r24, r31
    be26:	c0 01       	movw	r24, r0
    be28:	11 24       	eor	r1, r1
    be2a:	8a 5a       	subi	r24, 0xAA	; 170
    be2c:	99 4f       	sbci	r25, 0xF9	; 249
    be2e:	29 81       	ldd	r18, Y+1	; 0x01
    be30:	28 1b       	sub	r18, r24
    be32:	20 93 b7 06 	sts	0x06B7, r18
	StrSize=Sz; 
    be36:	30 93 aa 06 	sts	0x06AA, r19
				else{ 
					PutBuf(prb(&(OF+OF_N)->Type), &Param);
				}			
			else
				PutField(prb(&(OF+OF_N)->Type), prp(&(OF+OF_N)->Var), &Param);
			OF_N++;
    be3a:	83 94       	inc	r8
    be3c:	35 ce       	rjmp	.-918    	; 0xbaa8 <PutLine+0xda>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
PutBuf(uint8_t Type, T_Param *Param)
{
	switch(Type) {
    be3e:	86 30       	cpi	r24, 0x06	; 6
    be40:	78 f2       	brcs	.-98     	; 0xbde0 <PutLine+0x412>
    be42:	3c 81       	ldd	r19, Y+4	; 0x04
    be44:	ba ce       	rjmp	.-652    	; 0xbbba <PutLine+0x1ec>
	case s_Word: case s_EE_Word:
		Put_sbVal(Param);
		PosBlink(Param,' ');
		break;
	case c_Word:
		PutVal(F_Buf, 'w', Param);
    be46:	80 91 f5 04 	lds	r24, 0x04F5
    be4a:	90 91 f6 04 	lds	r25, 0x04F6
    be4e:	67 e7       	ldi	r22, 0x77	; 119
    be50:	a3 01       	movw	r20, r6
    be52:	0e 94 07 4a 	call	0x940e	; 0x940e <PutVal>
		ValBlink(Param->Pos, Param->Size);
    be56:	3c 81       	ldd	r19, Y+4	; 0x04

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
ValBlink(char *Pos, uint8_t Sz)
{
	CurrX=Pos-LCD_Buf[Y1];
    be58:	80 91 fd 09 	lds	r24, 0x09FD
    be5c:	b5 e1       	ldi	r27, 0x15	; 21
    be5e:	8b 9f       	mul	r24, r27
    be60:	c0 01       	movw	r24, r0
    be62:	11 24       	eor	r1, r1
    be64:	e2 cf       	rjmp	.-60     	; 0xbe2a <PutLine+0x45c>
	case c_Word:
		PutVal(F_Buf, 'w', Param);
		ValBlink(Param->Pos, Param->Size);
		break;
	case zc_Word:
		Put_zVal(F_Buf, 'w', Param);
    be66:	80 91 f5 04 	lds	r24, 0x04F5
    be6a:	90 91 f6 04 	lds	r25, 0x04F6
    be6e:	67 e7       	ldi	r22, 0x77	; 119
    be70:	a3 01       	movw	r20, r6
    be72:	0e 94 66 48 	call	0x90cc	; 0x90cc <Put_zVal>
		ValBlink(Param->Pos, Param->Size);
    be76:	3c 81       	ldd	r19, Y+4	; 0x04

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
ValBlink(char *Pos, uint8_t Sz)
{
	CurrX=Pos-LCD_Buf[Y1];
    be78:	80 91 fd 09 	lds	r24, 0x09FD
    be7c:	e5 e1       	ldi	r30, 0x15	; 21
    be7e:	8e 9f       	mul	r24, r30
    be80:	c0 01       	movw	r24, r0
    be82:	11 24       	eor	r1, r1
    be84:	d2 cf       	rjmp	.-92     	; 0xbe2a <PutLine+0x45c>

0000be86 <MenuOut>:
	while(X<LCDXSz)	LCD_Buf[Y][X++] = ' ';
}
// ~~~~~~~~~~
void
MenuOut(void)
{
    be86:	2f 92       	push	r2
    be88:	3f 92       	push	r3
    be8a:	4f 92       	push	r4
    be8c:	5f 92       	push	r5
    be8e:	6f 92       	push	r6
    be90:	7f 92       	push	r7
    be92:	8f 92       	push	r8
    be94:	9f 92       	push	r9
    be96:	af 92       	push	r10
    be98:	bf 92       	push	r11
    be9a:	cf 92       	push	r12
    be9c:	df 92       	push	r13
    be9e:	ef 92       	push	r14
    bea0:	ff 92       	push	r15
    bea2:	0f 93       	push	r16
    bea4:	1f 93       	push	r17
    bea6:	df 93       	push	r29
    bea8:	cf 93       	push	r28
    beaa:	cd b7       	in	r28, 0x3d	; 61
    beac:	de b7       	in	r29, 0x3e	; 62
    beae:	2a 97       	sbiw	r28, 0x0a	; 10
    beb0:	0f b6       	in	r0, 0x3f	; 63
    beb2:	f8 94       	cli
    beb4:	de bf       	out	0x3e, r29	; 62
    beb6:	0f be       	out	0x3f, r0	; 63
    beb8:	cd bf       	out	0x3d, r28	; 61
	uint8_t Y;
	if(CurrMsg) {
    beba:	a0 90 f3 04 	lds	r10, 0x04F3
    bebe:	b0 90 f4 04 	lds	r11, 0x04F4
    bec2:	a1 14       	cp	r10, r1
    bec4:	b1 04       	cpc	r11, r1
    bec6:	09 f4       	brne	.+2      	; 0xbeca <MenuOut+0x44>
    bec8:	6a c1       	rjmp	.+724    	; 0xc19e <MenuOut+0x318>
    beca:	22 24       	eor	r2, r2
    becc:	33 24       	eor	r3, r3
    bece:	18 86       	std	Y+8, r1	; 0x08
    bed0:	1f 82       	std	Y+7, r1	; 0x07
	int8_t Xs = 0;
	//--- ">>" Align right
	if(prc(CurrStr+0) == '>' && prc(CurrStr+1) == '>'){
		X0 = LCDXSz - strlen_P(CurrStr) + 2;
		Xs = X0-2;
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';
    bed2:	80 e2       	ldi	r24, 0x20	; 32
    bed4:	48 2e       	mov	r4, r24
	#if TypeLCD==840
		const MsgLine *Line=(MsgLine*)prp(&CurrMsg->LineList)+Y;
	#else
		const MsgLine *Line=CurrMsg->LineList+Y;		
	#endif
	PGM_P CurrStr=(PGM_P)(Line->Str);
    bed6:	91 01       	movw	r18, r2
    bed8:	22 0f       	add	r18, r18
    beda:	33 1f       	adc	r19, r19
    bedc:	3a 87       	std	Y+10, r19	; 0x0a
    bede:	29 87       	std	Y+9, r18	; 0x09
    bee0:	49 01       	movw	r8, r18
    bee2:	82 0c       	add	r8, r2
    bee4:	93 1c       	adc	r9, r3
    bee6:	64 01       	movw	r12, r8
    bee8:	cc 0c       	add	r12, r12
    beea:	dd 1c       	adc	r13, r13
    beec:	cc 0c       	add	r12, r12
    beee:	dd 1c       	adc	r13, r13
    bef0:	cc 0c       	add	r12, r12
    bef2:	dd 1c       	adc	r13, r13
    bef4:	96 01       	movw	r18, r12
    bef6:	22 19       	sub	r18, r2
    bef8:	33 09       	sbc	r19, r3
    befa:	75 01       	movw	r14, r10
    befc:	e2 0e       	add	r14, r18
    befe:	f3 1e       	adc	r15, r19

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    bf00:	2b 5e       	subi	r18, 0xEB	; 235
    bf02:	3f 4f       	sbci	r19, 0xFF	; 255
    bf04:	c5 01       	movw	r24, r10
    bf06:	82 0f       	add	r24, r18
    bf08:	93 1f       	adc	r25, r19
    bf0a:	25 51       	subi	r18, 0x15	; 21
    bf0c:	30 40       	sbci	r19, 0x00	; 0
    bf0e:	fc 01       	movw	r30, r24
    bf10:	65 90       	lpm	r6, Z+
    bf12:	74 90       	lpm	r7, Z+

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    bf14:	f7 01       	movw	r30, r14
    bf16:	84 91       	lpm	r24, Z+
	uint8_t X;
	uint8_t X0=0;
	uint8_t X1=LCDXSz;
	int8_t Xs = 0;
	//--- ">>" Align right
	if(prc(CurrStr+0) == '>' && prc(CurrStr+1) == '>'){
    bf18:	8e 33       	cpi	r24, 0x3E	; 62
    bf1a:	09 f4       	brne	.+2      	; 0xbf1e <MenuOut+0x98>
    bf1c:	b3 c0       	rjmp	.+358    	; 0xc084 <MenuOut+0x1fe>
		X0 = LCDXSz - strlen_P(CurrStr) + 2;
		Xs = X0-2;
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';
    bf1e:	90 e0       	ldi	r25, 0x00	; 0
    bf20:	00 e0       	ldi	r16, 0x00	; 0
    bf22:	f7 01       	movw	r30, r14
    bf24:	84 91       	lpm	r24, Z+
	}
	//--- "<<" Align left
	if(prc(CurrStr+0) == '<' && prc(CurrStr+1) == '<'){
    bf26:	8c 33       	cpi	r24, 0x3C	; 60
    bf28:	09 f4       	brne	.+2      	; 0xbf2c <MenuOut+0xa6>
    bf2a:	cd c0       	rjmp	.+410    	; 0xc0c6 <MenuOut+0x240>
		X1 = strlen_P(CurrStr) - 2;
    bf2c:	f4 e1       	ldi	r31, 0x14	; 20
    bf2e:	5f 2e       	mov	r5, r31
    bf30:	f7 01       	movw	r30, r14
    bf32:	84 91       	lpm	r24, Z+
		X0 = 0;
		Xs = X0-2;
	}
	//--- "<>" Align center
	if(prc(CurrStr+0) == '<' && prc(CurrStr+1) == '>'){
    bf34:	8c 33       	cpi	r24, 0x3C	; 60
    bf36:	09 f4       	brne	.+2      	; 0xbf3a <MenuOut+0xb4>
    bf38:	e6 c0       	rjmp	.+460    	; 0xc106 <MenuOut+0x280>
		X1 = X0 + (strlen_P(CurrStr) - 2);
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';		
	}
	//---

	for(X=X0; X<X1; X++){
    bf3a:	05 15       	cp	r16, r5
    bf3c:	08 f0       	brcs	.+2      	; 0xbf40 <MenuOut+0xba>
    bf3e:	73 c0       	rjmp	.+230    	; 0xc026 <MenuOut+0x1a0>
		const MsgLine *Line=(MsgLine*)prp(&CurrMsg->LineList)+Y;
	#else
		const MsgLine *Line=CurrMsg->LineList+Y;		
	#endif
	PGM_P CurrStr=(PGM_P)(Line->Str);
	InField *IF = prp(&Line->IF_List);
    bf40:	73 01       	movw	r14, r6
    bf42:	69 2e       	mov	r6, r25
    bf44:	77 24       	eor	r7, r7
    bf46:	67 fc       	sbrc	r6, 7
    bf48:	70 94       	com	r7
    bf4a:	29 85       	ldd	r18, Y+9	; 0x09
    bf4c:	3a 85       	ldd	r19, Y+10	; 0x0a
    bf4e:	22 0d       	add	r18, r2
    bf50:	33 1d       	adc	r19, r3
    bf52:	c9 01       	movw	r24, r18
    bf54:	88 0f       	add	r24, r24
    bf56:	99 1f       	adc	r25, r25
    bf58:	88 0f       	add	r24, r24
    bf5a:	99 1f       	adc	r25, r25
    bf5c:	88 0f       	add	r24, r24
    bf5e:	99 1f       	adc	r25, r25
    bf60:	6c 01       	movw	r12, r24
    bf62:	c2 18       	sub	r12, r2
    bf64:	d3 08       	sbc	r13, r3
			Param.Txt = prp(&IF->EnumList);
			PutField(prb(&IF->Type), prp(&IF->Var), &Param);
			IF++;
			X += Param.Size;
		}
		LCD_Buf[Y][X] = Char;
    bf66:	4c 01       	movw	r8, r24
    bf68:	82 1a       	sub	r8, r18
    bf6a:	93 0a       	sbc	r9, r19
    bf6c:	09 c0       	rjmp	.+18     	; 0xbf80 <MenuOut+0xfa>
    bf6e:	a8 0d       	add	r26, r8
    bf70:	b9 1d       	adc	r27, r9
    bf72:	aa 5a       	subi	r26, 0xAA	; 170
    bf74:	b9 4f       	sbci	r27, 0xF9	; 249
    bf76:	1c 93       	st	X, r17
		X1 = X0 + (strlen_P(CurrStr) - 2);
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';		
	}
	//---

	for(X=X0; X<X1; X++){
    bf78:	0f 5f       	subi	r16, 0xFF	; 255
    bf7a:	05 15       	cp	r16, r5
    bf7c:	08 f0       	brcs	.+2      	; 0xbf80 <MenuOut+0xfa>
    bf7e:	4f c0       	rjmp	.+158    	; 0xc01e <MenuOut+0x198>
		char Char;
		if((Char=prc(CurrStr+X-Xs))=='{') {
    bf80:	a0 2f       	mov	r26, r16
    bf82:	b0 e0       	ldi	r27, 0x00	; 0
    bf84:	9d 01       	movw	r18, r26
    bf86:	26 19       	sub	r18, r6
    bf88:	37 09       	sbc	r19, r7
    bf8a:	f6 01       	movw	r30, r12
    bf8c:	e2 0f       	add	r30, r18
    bf8e:	f3 1f       	adc	r31, r19
    bf90:	ea 0d       	add	r30, r10
    bf92:	fb 1d       	adc	r31, r11
    bf94:	14 91       	lpm	r17, Z+
    bf96:	1b 37       	cpi	r17, 0x7B	; 123
    bf98:	51 f7       	brne	.-44     	; 0xbf6e <MenuOut+0xe8>
			T_Param Param;
			Param.Pos = LCD_Buf[Y]+X;
    bf9a:	8f 81       	ldd	r24, Y+7	; 0x07
    bf9c:	98 85       	ldd	r25, Y+8	; 0x08
    bf9e:	a8 0f       	add	r26, r24
    bfa0:	b9 1f       	adc	r27, r25
    bfa2:	aa 5a       	subi	r26, 0xAA	; 170
    bfa4:	b9 4f       	sbci	r27, 0xF9	; 249
    bfa6:	ba 83       	std	Y+2, r27	; 0x02
    bfa8:	a9 83       	std	Y+1, r26	; 0x01
    bfaa:	81 e0       	ldi	r24, 0x01	; 1
    bfac:	f9 01       	movw	r30, r18
    bfae:	e8 0f       	add	r30, r24
    bfb0:	f1 1d       	adc	r31, r1
    bfb2:	ec 0d       	add	r30, r12
    bfb4:	fd 1d       	adc	r31, r13
    bfb6:	ea 0d       	add	r30, r10
    bfb8:	fb 1d       	adc	r31, r11
    bfba:	14 91       	lpm	r17, Z+
    bfbc:	98 2f       	mov	r25, r24
    bfbe:	8f 5f       	subi	r24, 0xFF	; 255
			Param.Size = 0;
			while((Char=prc(CurrStr+X-Xs+ ++Param.Size))=='{');
    bfc0:	1b 37       	cpi	r17, 0x7B	; 123
    bfc2:	a1 f3       	breq	.-24     	; 0xbfac <MenuOut+0x126>
    bfc4:	9c 83       	std	Y+4, r25	; 0x04

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    bfc6:	e5 e0       	ldi	r30, 0x05	; 5
    bfc8:	f0 e0       	ldi	r31, 0x00	; 0
    bfca:	ee 0e       	add	r14, r30
    bfcc:	ff 1e       	adc	r15, r31
    bfce:	f7 01       	movw	r30, r14
    bfd0:	84 91       	lpm	r24, Z+
    bfd2:	2b ef       	ldi	r18, 0xFB	; 251
    bfd4:	3f ef       	ldi	r19, 0xFF	; 255
    bfd6:	e2 0e       	add	r14, r18
    bfd8:	f3 1e       	adc	r15, r19
			Param.Prec = prb(&IF->Prec);
    bfda:	8b 83       	std	Y+3, r24	; 0x03

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    bfdc:	f7 01       	movw	r30, r14
    bfde:	33 96       	adiw	r30, 0x03	; 3
    bfe0:	85 91       	lpm	r24, Z+
    bfe2:	94 91       	lpm	r25, Z+
			Param.Txt = prp(&IF->EnumList);
    bfe4:	9e 83       	std	Y+6, r25	; 0x06
    bfe6:	8d 83       	std	Y+5, r24	; 0x05

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    bfe8:	f7 01       	movw	r30, r14
    bfea:	84 91       	lpm	r24, Z+

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    bfec:	31 96       	adiw	r30, 0x01	; 1
    bfee:	65 91       	lpm	r22, Z+
    bff0:	74 91       	lpm	r23, Z+
			PutField(prb(&IF->Type), prp(&IF->Var), &Param);
    bff2:	ae 01       	movw	r20, r28
    bff4:	4f 5f       	subi	r20, 0xFF	; 255
    bff6:	5f 4f       	sbci	r21, 0xFF	; 255
    bff8:	0e 94 62 5b 	call	0xb6c4	; 0xb6c4 <PutField>
			IF++;
    bffc:	26 e0       	ldi	r18, 0x06	; 6
    bffe:	30 e0       	ldi	r19, 0x00	; 0
    c000:	e2 0e       	add	r14, r18
    c002:	f3 1e       	adc	r15, r19
			X += Param.Size;
    c004:	8c 81       	ldd	r24, Y+4	; 0x04
    c006:	08 0f       	add	r16, r24
    c008:	a0 2f       	mov	r26, r16
    c00a:	b0 e0       	ldi	r27, 0x00	; 0
		}
		LCD_Buf[Y][X] = Char;
    c00c:	a8 0d       	add	r26, r8
    c00e:	b9 1d       	adc	r27, r9
    c010:	aa 5a       	subi	r26, 0xAA	; 170
    c012:	b9 4f       	sbci	r27, 0xF9	; 249
    c014:	1c 93       	st	X, r17
		X1 = X0 + (strlen_P(CurrStr) - 2);
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';		
	}
	//---

	for(X=X0; X<X1; X++){
    c016:	0f 5f       	subi	r16, 0xFF	; 255
    c018:	05 15       	cp	r16, r5
    c01a:	08 f4       	brcc	.+2      	; 0xc01e <MenuOut+0x198>
    c01c:	b1 cf       	rjmp	.-158    	; 0xbf80 <MenuOut+0xfa>
    c01e:	a0 90 f3 04 	lds	r10, 0x04F3
    c022:	b0 90 f4 04 	lds	r11, 0x04F4
			X += Param.Size;
		}
		LCD_Buf[Y][X] = Char;
	}
	X=X1;
	for(;X<LCDXSz; X++) LCD_Buf[Y][X] = ' ';
    c026:	33 e1       	ldi	r19, 0x13	; 19
    c028:	35 15       	cp	r19, r5
    c02a:	08 f0       	brcs	.+2      	; 0xc02e <MenuOut+0x1a8>
    c02c:	9f c0       	rjmp	.+318    	; 0xc16c <MenuOut+0x2e6>
    c02e:	08 94       	sec
    c030:	21 1c       	adc	r2, r1
    c032:	31 1c       	adc	r3, r1
    c034:	ef 81       	ldd	r30, Y+7	; 0x07
    c036:	f8 85       	ldd	r31, Y+8	; 0x08
    c038:	75 96       	adiw	r30, 0x15	; 21
    c03a:	f8 87       	std	Y+8, r31	; 0x08
    c03c:	ef 83       	std	Y+7, r30	; 0x07
void
MenuOut(void)
{
	uint8_t Y;
	if(CurrMsg) {
		for(Y=0; Y<LCDYSz; PutMsgLine(Y++));
    c03e:	f4 e0       	ldi	r31, 0x04	; 4
    c040:	2f 16       	cp	r2, r31
    c042:	31 04       	cpc	r3, r1
    c044:	09 f0       	breq	.+2      	; 0xc048 <MenuOut+0x1c2>
    c046:	47 cf       	rjmp	.-370    	; 0xbed6 <MenuOut+0x50>
		EventFunc(&CurrMsg->Run);
    c048:	c5 01       	movw	r24, r10
    c04a:	82 5a       	subi	r24, 0xA2	; 162
    c04c:	9f 4f       	sbci	r25, 0xFF	; 255
    c04e:	0e 94 93 3c 	call	0x7926	; 0x7926 <EventFunc>
	if(prb(&CurrPage->LineNumber)>LCDYSz || Fix<LCDYSz-1 || prp(&(GetLine+CurrLine)->OF_List))
		LCD_Buf[CurrLCD][0] = CharCursor;
	if(++Blink>16)
		Blink=0;
	EventFunc(&CurrPage->Run);
}
    c052:	2a 96       	adiw	r28, 0x0a	; 10
    c054:	0f b6       	in	r0, 0x3f	; 63
    c056:	f8 94       	cli
    c058:	de bf       	out	0x3e, r29	; 62
    c05a:	0f be       	out	0x3f, r0	; 63
    c05c:	cd bf       	out	0x3d, r28	; 61
    c05e:	cf 91       	pop	r28
    c060:	df 91       	pop	r29
    c062:	1f 91       	pop	r17
    c064:	0f 91       	pop	r16
    c066:	ff 90       	pop	r15
    c068:	ef 90       	pop	r14
    c06a:	df 90       	pop	r13
    c06c:	cf 90       	pop	r12
    c06e:	bf 90       	pop	r11
    c070:	af 90       	pop	r10
    c072:	9f 90       	pop	r9
    c074:	8f 90       	pop	r8
    c076:	7f 90       	pop	r7
    c078:	6f 90       	pop	r6
    c07a:	5f 90       	pop	r5
    c07c:	4f 90       	pop	r4
    c07e:	3f 90       	pop	r3
    c080:	2f 90       	pop	r2
    c082:	08 95       	ret

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    c084:	f9 01       	movw	r30, r18
    c086:	31 96       	adiw	r30, 0x01	; 1
    c088:	ea 0d       	add	r30, r10
    c08a:	fb 1d       	adc	r31, r11
    c08c:	e4 91       	lpm	r30, Z+
	uint8_t X;
	uint8_t X0=0;
	uint8_t X1=LCDXSz;
	int8_t Xs = 0;
	//--- ">>" Align right
	if(prc(CurrStr+0) == '>' && prc(CurrStr+1) == '>'){
    c08e:	ee 33       	cpi	r30, 0x3E	; 62
    c090:	09 f0       	breq	.+2      	; 0xc094 <MenuOut+0x20e>
    c092:	45 cf       	rjmp	.-374    	; 0xbf1e <MenuOut+0x98>
		X0 = LCDXSz - strlen_P(CurrStr) + 2;
    c094:	c7 01       	movw	r24, r14
    c096:	0e 94 cd 7f 	call	0xff9a	; 0xff9a <strlen_P>
    c09a:	06 e1       	ldi	r16, 0x16	; 22
    c09c:	08 1b       	sub	r16, r24
		Xs = X0-2;
    c09e:	90 2f       	mov	r25, r16
    c0a0:	92 50       	subi	r25, 0x02	; 2
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';
    c0a2:	00 23       	and	r16, r16
    c0a4:	09 f4       	brne	.+2      	; 0xc0a8 <MenuOut+0x222>
    c0a6:	3d cf       	rjmp	.-390    	; 0xbf22 <MenuOut+0x9c>
    c0a8:	f6 01       	movw	r30, r12
    c0aa:	e8 19       	sub	r30, r8
    c0ac:	f9 09       	sbc	r31, r9
    c0ae:	ea 5a       	subi	r30, 0xAA	; 170
    c0b0:	f9 4f       	sbci	r31, 0xF9	; 249
    c0b2:	80 e0       	ldi	r24, 0x00	; 0
    c0b4:	41 92       	st	Z+, r4
    c0b6:	8f 5f       	subi	r24, 0xFF	; 255
    c0b8:	80 17       	cp	r24, r16
    c0ba:	e0 f3       	brcs	.-8      	; 0xc0b4 <MenuOut+0x22e>
    c0bc:	f7 01       	movw	r30, r14
    c0be:	84 91       	lpm	r24, Z+
	}
	//--- "<<" Align left
	if(prc(CurrStr+0) == '<' && prc(CurrStr+1) == '<'){
    c0c0:	8c 33       	cpi	r24, 0x3C	; 60
    c0c2:	09 f0       	breq	.+2      	; 0xc0c6 <MenuOut+0x240>
    c0c4:	33 cf       	rjmp	.-410    	; 0xbf2c <MenuOut+0xa6>
    c0c6:	e9 85       	ldd	r30, Y+9	; 0x09
    c0c8:	fa 85       	ldd	r31, Y+10	; 0x0a
    c0ca:	e2 0d       	add	r30, r2
    c0cc:	f3 1d       	adc	r31, r3
    c0ce:	ee 0f       	add	r30, r30
    c0d0:	ff 1f       	adc	r31, r31
    c0d2:	ee 0f       	add	r30, r30
    c0d4:	ff 1f       	adc	r31, r31
    c0d6:	ee 0f       	add	r30, r30
    c0d8:	ff 1f       	adc	r31, r31
    c0da:	e2 19       	sub	r30, r2
    c0dc:	f3 09       	sbc	r31, r3
    c0de:	31 96       	adiw	r30, 0x01	; 1
    c0e0:	ea 0d       	add	r30, r10
    c0e2:	fb 1d       	adc	r31, r11
    c0e4:	e4 91       	lpm	r30, Z+
    c0e6:	ec 33       	cpi	r30, 0x3C	; 60
    c0e8:	09 f0       	breq	.+2      	; 0xc0ec <MenuOut+0x266>
    c0ea:	20 cf       	rjmp	.-448    	; 0xbf2c <MenuOut+0xa6>
		X1 = strlen_P(CurrStr) - 2;
    c0ec:	c7 01       	movw	r24, r14
    c0ee:	0e 94 cd 7f 	call	0xff9a	; 0xff9a <strlen_P>
    c0f2:	ae ef       	ldi	r26, 0xFE	; 254
    c0f4:	5a 2e       	mov	r5, r26
    c0f6:	58 0e       	add	r5, r24
    c0f8:	9e ef       	ldi	r25, 0xFE	; 254
    c0fa:	00 e0       	ldi	r16, 0x00	; 0
    c0fc:	f7 01       	movw	r30, r14
    c0fe:	84 91       	lpm	r24, Z+
		X0 = 0;
		Xs = X0-2;
	}
	//--- "<>" Align center
	if(prc(CurrStr+0) == '<' && prc(CurrStr+1) == '>'){
    c100:	8c 33       	cpi	r24, 0x3C	; 60
    c102:	09 f0       	breq	.+2      	; 0xc106 <MenuOut+0x280>
    c104:	1a cf       	rjmp	.-460    	; 0xbf3a <MenuOut+0xb4>
    c106:	89 84       	ldd	r8, Y+9	; 0x09
    c108:	9a 84       	ldd	r9, Y+10	; 0x0a
    c10a:	82 0c       	add	r8, r2
    c10c:	93 1c       	adc	r9, r3
    c10e:	64 01       	movw	r12, r8
    c110:	cc 0c       	add	r12, r12
    c112:	dd 1c       	adc	r13, r13
    c114:	cc 0c       	add	r12, r12
    c116:	dd 1c       	adc	r13, r13
    c118:	cc 0c       	add	r12, r12
    c11a:	dd 1c       	adc	r13, r13
    c11c:	f6 01       	movw	r30, r12
    c11e:	e2 19       	sub	r30, r2
    c120:	f3 09       	sbc	r31, r3
    c122:	31 96       	adiw	r30, 0x01	; 1
    c124:	ea 0d       	add	r30, r10
    c126:	fb 1d       	adc	r31, r11
    c128:	e4 91       	lpm	r30, Z+
    c12a:	ee 33       	cpi	r30, 0x3E	; 62
    c12c:	09 f0       	breq	.+2      	; 0xc130 <MenuOut+0x2aa>
    c12e:	05 cf       	rjmp	.-502    	; 0xbf3a <MenuOut+0xb4>
		X0 = (LCDXSz - strlen_P(CurrStr) + 2) / 2;
    c130:	c7 01       	movw	r24, r14
    c132:	0e 94 cd 7f 	call	0xff9a	; 0xff9a <strlen_P>
    c136:	26 e1       	ldi	r18, 0x16	; 22
    c138:	30 e0       	ldi	r19, 0x00	; 0
    c13a:	28 1b       	sub	r18, r24
    c13c:	39 0b       	sbc	r19, r25
    c13e:	36 95       	lsr	r19
    c140:	27 95       	ror	r18
    c142:	02 2f       	mov	r16, r18
		Xs = X0-2;
    c144:	92 2f       	mov	r25, r18
    c146:	92 50       	subi	r25, 0x02	; 2
		X1 = X0 + (strlen_P(CurrStr) - 2);
    c148:	6e ef       	ldi	r22, 0xFE	; 254
    c14a:	56 2e       	mov	r5, r22
    c14c:	58 0e       	add	r5, r24
    c14e:	52 0e       	add	r5, r18
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';		
    c150:	22 23       	and	r18, r18
    c152:	09 f4       	brne	.+2      	; 0xc156 <MenuOut+0x2d0>
    c154:	f2 ce       	rjmp	.-540    	; 0xbf3a <MenuOut+0xb4>
    c156:	f6 01       	movw	r30, r12
    c158:	e8 19       	sub	r30, r8
    c15a:	f9 09       	sbc	r31, r9
    c15c:	ea 5a       	subi	r30, 0xAA	; 170
    c15e:	f9 4f       	sbci	r31, 0xF9	; 249
    c160:	80 e0       	ldi	r24, 0x00	; 0
    c162:	41 92       	st	Z+, r4
    c164:	8f 5f       	subi	r24, 0xFF	; 255
    c166:	80 17       	cp	r24, r16
    c168:	e0 f3       	brcs	.-8      	; 0xc162 <MenuOut+0x2dc>
    c16a:	e7 ce       	rjmp	.-562    	; 0xbf3a <MenuOut+0xb4>
			X += Param.Size;
		}
		LCD_Buf[Y][X] = Char;
	}
	X=X1;
	for(;X<LCDXSz; X++) LCD_Buf[Y][X] = ' ';
    c16c:	89 85       	ldd	r24, Y+9	; 0x09
    c16e:	9a 85       	ldd	r25, Y+10	; 0x0a
    c170:	82 0d       	add	r24, r2
    c172:	93 1d       	adc	r25, r3
    c174:	9c 01       	movw	r18, r24
    c176:	22 0f       	add	r18, r18
    c178:	33 1f       	adc	r19, r19
    c17a:	22 0f       	add	r18, r18
    c17c:	33 1f       	adc	r19, r19
    c17e:	22 0f       	add	r18, r18
    c180:	33 1f       	adc	r19, r19
    c182:	28 1b       	sub	r18, r24
    c184:	39 0b       	sbc	r19, r25
    c186:	f9 01       	movw	r30, r18
    c188:	e5 0d       	add	r30, r5
    c18a:	f1 1d       	adc	r31, r1
    c18c:	ea 5a       	subi	r30, 0xAA	; 170
    c18e:	f9 4f       	sbci	r31, 0xF9	; 249
    c190:	40 82       	st	Z, r4
    c192:	53 94       	inc	r5
    c194:	83 e1       	ldi	r24, 0x13	; 19
    c196:	85 15       	cp	r24, r5
    c198:	08 f4       	brcc	.+2      	; 0xc19c <MenuOut+0x316>
    c19a:	49 cf       	rjmp	.-366    	; 0xc02e <MenuOut+0x1a8>
    c19c:	f4 cf       	rjmp	.-24     	; 0xc186 <MenuOut+0x300>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    c19e:	40 91 d4 02 	lds	r20, 0x02D4
    c1a2:	50 91 d5 02 	lds	r21, 0x02D5
    c1a6:	4d 5f       	subi	r20, 0xFD	; 253
    c1a8:	5f 4f       	sbci	r21, 0xFF	; 255
    c1aa:	fa 01       	movw	r30, r20
    c1ac:	e4 90       	lpm	r14, Z+
    c1ae:	43 50       	subi	r20, 0x03	; 3
    c1b0:	50 40       	sbci	r21, 0x00	; 0
		for(Y=0; Y<LCDYSz; PutMsgLine(Y++));
		EventFunc(&CurrMsg->Run);
		return;
	}
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
    c1b2:	c0 90 83 07 	lds	r12, 0x0783
    c1b6:	d0 90 a0 08 	lds	r13, 0x08A0
	for(Y=0; Y<Fix; Y++)
    c1ba:	ee 20       	and	r14, r14
    c1bc:	09 f4       	brne	.+2      	; 0xc1c0 <MenuOut+0x33a>
    c1be:	a6 c0       	rjmp	.+332    	; 0xc30c <MenuOut+0x486>
    c1c0:	00 e0       	ldi	r16, 0x00	; 0
    c1c2:	10 e0       	ldi	r17, 0x00	; 0
// ~~~~~~~~~~~~~~~~~~
inline static void
PutBlankLine(uint8_t Y)
{
	uint8_t X=0;
	while(X<LCDXSz)	LCD_Buf[Y][X++] = ' ';
    c1c4:	80 e2       	ldi	r24, 0x20	; 32
    c1c6:	f8 2e       	mov	r15, r24
    c1c8:	4e 5f       	subi	r20, 0xFE	; 254
    c1ca:	5f 4f       	sbci	r21, 0xFF	; 255
    c1cc:	fa 01       	movw	r30, r20
    c1ce:	84 91       	lpm	r24, Z+
    c1d0:	42 50       	subi	r20, 0x02	; 2
    c1d2:	50 40       	sbci	r21, 0x00	; 0
		return;
	}
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
    c1d4:	08 17       	cp	r16, r24
    c1d6:	08 f4       	brcc	.+2      	; 0xc1da <MenuOut+0x354>
    c1d8:	69 c0       	rjmp	.+210    	; 0xc2ac <MenuOut+0x426>
    c1da:	c8 01       	movw	r24, r16
    c1dc:	88 0f       	add	r24, r24
    c1de:	99 1f       	adc	r25, r25
    c1e0:	80 0f       	add	r24, r16
    c1e2:	91 1f       	adc	r25, r17
    c1e4:	fc 01       	movw	r30, r24
    c1e6:	ee 0f       	add	r30, r30
    c1e8:	ff 1f       	adc	r31, r31
    c1ea:	ee 0f       	add	r30, r30
    c1ec:	ff 1f       	adc	r31, r31
    c1ee:	ee 0f       	add	r30, r30
    c1f0:	ff 1f       	adc	r31, r31
    c1f2:	e8 1b       	sub	r30, r24
    c1f4:	f9 0b       	sbc	r31, r25
    c1f6:	ea 5a       	subi	r30, 0xAA	; 170
    c1f8:	f9 4f       	sbci	r31, 0xF9	; 249
    c1fa:	80 e0       	ldi	r24, 0x00	; 0
// ~~~~~~~~~~~~~~~~~~
inline static void
PutBlankLine(uint8_t Y)
{
	uint8_t X=0;
	while(X<LCDXSz)	LCD_Buf[Y][X++] = ' ';
    c1fc:	f1 92       	st	Z+, r15
    c1fe:	8f 5f       	subi	r24, 0xFF	; 255
    c200:	84 31       	cpi	r24, 0x14	; 20
    c202:	e1 f7       	brne	.-8      	; 0xc1fc <MenuOut+0x376>
	}
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Y, Y);
    c204:	0f 5f       	subi	r16, 0xFF	; 255
    c206:	1f 4f       	sbci	r17, 0xFF	; 255
		EventFunc(&CurrMsg->Run);
		return;
	}
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
    c208:	0e 15       	cp	r16, r14
    c20a:	f0 f2       	brcs	.-68     	; 0xc1c8 <MenuOut+0x342>
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Y, Y);
	for(; Y<LCDYSz; Y++)
    c20c:	f3 e0       	ldi	r31, 0x03	; 3
    c20e:	fe 15       	cp	r31, r14
    c210:	f0 f0       	brcs	.+60     	; 0xc24e <MenuOut+0x3c8>
    c212:	1e 2d       	mov	r17, r14
		EventFunc(&CurrMsg->Run);
		return;
	}
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
    c214:	fc 2c       	mov	r15, r12
    c216:	fd 18       	sub	r15, r13
    c218:	f1 0e       	add	r15, r17
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Y, Y);
	for(; Y<LCDYSz; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
    c21a:	95 e1       	ldi	r25, 0x15	; 21
    c21c:	d9 2e       	mov	r13, r25
// ~~~~~~~~~~~~~~~~~~
inline static void
PutBlankLine(uint8_t Y)
{
	uint8_t X=0;
	while(X<LCDXSz)	LCD_Buf[Y][X++] = ' ';
    c21e:	00 e2       	ldi	r16, 0x20	; 32
    c220:	4e 5f       	subi	r20, 0xFE	; 254
    c222:	5f 4f       	sbci	r21, 0xFF	; 255
    c224:	fa 01       	movw	r30, r20
    c226:	84 91       	lpm	r24, Z+
    c228:	42 50       	subi	r20, 0x02	; 2
    c22a:	50 40       	sbci	r21, 0x00	; 0
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Y, Y);
	for(; Y<LCDYSz; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
    c22c:	18 17       	cp	r17, r24
    c22e:	08 f4       	brcc	.+2      	; 0xc232 <MenuOut+0x3ac>
    c230:	4b c0       	rjmp	.+150    	; 0xc2c8 <MenuOut+0x442>
    c232:	1d 9d       	mul	r17, r13
    c234:	f0 01       	movw	r30, r0
    c236:	11 24       	eor	r1, r1
    c238:	ea 5a       	subi	r30, 0xAA	; 170
    c23a:	f9 4f       	sbci	r31, 0xF9	; 249
    c23c:	80 e0       	ldi	r24, 0x00	; 0
// ~~~~~~~~~~~~~~~~~~
inline static void
PutBlankLine(uint8_t Y)
{
	uint8_t X=0;
	while(X<LCDXSz)	LCD_Buf[Y][X++] = ' ';
    c23e:	01 93       	st	Z+, r16
    c240:	8f 5f       	subi	r24, 0xFF	; 255
    c242:	84 31       	cpi	r24, 0x14	; 20
    c244:	e1 f7       	brne	.-8      	; 0xc23e <MenuOut+0x3b8>
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Y, Y);
	for(; Y<LCDYSz; Y++)
    c246:	1f 5f       	subi	r17, 0xFF	; 255
    c248:	f3 94       	inc	r15
    c24a:	14 30       	cpi	r17, 0x04	; 4
    c24c:	48 f3       	brcs	.-46     	; 0xc220 <MenuOut+0x39a>
    c24e:	4e 5f       	subi	r20, 0xFE	; 254
    c250:	5f 4f       	sbci	r21, 0xFF	; 255
    c252:	fa 01       	movw	r30, r20
    c254:	84 91       	lpm	r24, Z+
    c256:	42 50       	subi	r20, 0x02	; 2
    c258:	50 40       	sbci	r21, 0x00	; 0
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Dist+Y, Y);
	if(prb(&CurrPage->LineNumber)>LCDYSz || Fix<LCDYSz-1 || prp(&(GetLine+CurrLine)->OF_List))
    c25a:	85 30       	cpi	r24, 0x05	; 5
    c25c:	20 f4       	brcc	.+8      	; 0xc266 <MenuOut+0x3e0>
    c25e:	f2 e0       	ldi	r31, 0x02	; 2
    c260:	fe 15       	cp	r31, r14
    c262:	08 f4       	brcc	.+2      	; 0xc266 <MenuOut+0x3e0>
    c264:	3f c0       	rjmp	.+126    	; 0xc2e4 <MenuOut+0x45e>
		LCD_Buf[CurrLCD][0] = CharCursor;
    c266:	80 91 a0 08 	lds	r24, 0x08A0
    c26a:	90 e0       	ldi	r25, 0x00	; 0
    c26c:	9c 01       	movw	r18, r24
    c26e:	22 0f       	add	r18, r18
    c270:	33 1f       	adc	r19, r19
    c272:	28 0f       	add	r18, r24
    c274:	39 1f       	adc	r19, r25
    c276:	f9 01       	movw	r30, r18
    c278:	ee 0f       	add	r30, r30
    c27a:	ff 1f       	adc	r31, r31
    c27c:	ee 0f       	add	r30, r30
    c27e:	ff 1f       	adc	r31, r31
    c280:	ee 0f       	add	r30, r30
    c282:	ff 1f       	adc	r31, r31
    c284:	e2 1b       	sub	r30, r18
    c286:	f3 0b       	sbc	r31, r19
    c288:	ea 5a       	subi	r30, 0xAA	; 170
    c28a:	f9 4f       	sbci	r31, 0xF9	; 249
    c28c:	80 e1       	ldi	r24, 0x10	; 16
    c28e:	80 83       	st	Z, r24
	if(++Blink>16)
    c290:	80 91 d0 08 	lds	r24, 0x08D0
    c294:	8f 5f       	subi	r24, 0xFF	; 255
    c296:	80 93 d0 08 	sts	0x08D0, r24
    c29a:	81 31       	cpi	r24, 0x11	; 17
    c29c:	10 f0       	brcs	.+4      	; 0xc2a2 <MenuOut+0x41c>
		Blink=0;
    c29e:	10 92 d0 08 	sts	0x08D0, r1
	EventFunc(&CurrPage->Run);
    c2a2:	ca 01       	movw	r24, r20
    c2a4:	08 96       	adiw	r24, 0x08	; 8
    c2a6:	0e 94 93 3c 	call	0x7926	; 0x7926 <EventFunc>
    c2aa:	d3 ce       	rjmp	.-602    	; 0xc052 <MenuOut+0x1cc>
	}
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Y, Y);
    c2ac:	80 2f       	mov	r24, r16
    c2ae:	60 2f       	mov	r22, r16
    c2b0:	0e 94 e7 5c 	call	0xb9ce	; 0xb9ce <PutLine>
    c2b4:	40 91 d4 02 	lds	r20, 0x02D4
    c2b8:	50 91 d5 02 	lds	r21, 0x02D5
    c2bc:	0f 5f       	subi	r16, 0xFF	; 255
    c2be:	1f 4f       	sbci	r17, 0xFF	; 255
		EventFunc(&CurrMsg->Run);
		return;
	}
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
    c2c0:	0e 15       	cp	r16, r14
    c2c2:	08 f4       	brcc	.+2      	; 0xc2c6 <MenuOut+0x440>
    c2c4:	81 cf       	rjmp	.-254    	; 0xc1c8 <MenuOut+0x342>
    c2c6:	a2 cf       	rjmp	.-188    	; 0xc20c <MenuOut+0x386>
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Y, Y);
	for(; Y<LCDYSz; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Dist+Y, Y);
    c2c8:	8f 2d       	mov	r24, r15
    c2ca:	61 2f       	mov	r22, r17
    c2cc:	0e 94 e7 5c 	call	0xb9ce	; 0xb9ce <PutLine>
    c2d0:	40 91 d4 02 	lds	r20, 0x02D4
    c2d4:	50 91 d5 02 	lds	r21, 0x02D5
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Y, Y);
	for(; Y<LCDYSz; Y++)
    c2d8:	1f 5f       	subi	r17, 0xFF	; 255
    c2da:	f3 94       	inc	r15
    c2dc:	14 30       	cpi	r17, 0x04	; 4
    c2de:	08 f4       	brcc	.+2      	; 0xc2e2 <MenuOut+0x45c>
    c2e0:	9f cf       	rjmp	.-194    	; 0xc220 <MenuOut+0x39a>
    c2e2:	b5 cf       	rjmp	.-150    	; 0xc24e <MenuOut+0x3c8>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    c2e4:	fa 01       	movw	r30, r20
    c2e6:	65 91       	lpm	r22, Z+
    c2e8:	74 91       	lpm	r23, Z+
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Dist+Y, Y);
	if(prb(&CurrPage->LineNumber)>LCDYSz || Fix<LCDYSz-1 || prp(&(GetLine+CurrLine)->OF_List))
    c2ea:	80 91 83 07 	lds	r24, 0x0783
    c2ee:	2b e1       	ldi	r18, 0x1B	; 27
    c2f0:	82 9f       	mul	r24, r18
    c2f2:	c0 01       	movw	r24, r0
    c2f4:	11 24       	eor	r1, r1
    c2f6:	68 0f       	add	r22, r24
    c2f8:	79 1f       	adc	r23, r25
    c2fa:	69 5e       	subi	r22, 0xE9	; 233
    c2fc:	7f 4f       	sbci	r23, 0xFF	; 255
    c2fe:	fb 01       	movw	r30, r22
    c300:	85 91       	lpm	r24, Z+
    c302:	94 91       	lpm	r25, Z+
    c304:	89 2b       	or	r24, r25
    c306:	09 f0       	breq	.+2      	; 0xc30a <MenuOut+0x484>
    c308:	ae cf       	rjmp	.-164    	; 0xc266 <MenuOut+0x3e0>
    c30a:	c2 cf       	rjmp	.-124    	; 0xc290 <MenuOut+0x40a>
		EventFunc(&CurrMsg->Run);
		return;
	}
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
    c30c:	10 e0       	ldi	r17, 0x00	; 0
    c30e:	82 cf       	rjmp	.-252    	; 0xc214 <MenuOut+0x38e>

0000c310 <LCD_Sweep>:

// ~~~~~~~~~~~~
static void
LCD_Sweep(void)
{
	if(LCD_Rdy()) {
    c310:	0e 94 a2 26 	call	0x4d44	; 0x4d44 <LCD_Rdy>
    c314:	88 23       	and	r24, r24
    c316:	09 f4       	brne	.+2      	; 0xc31a <LCD_Sweep+0xa>
    c318:	08 95       	ret
		MenuOut();
    c31a:	0e 94 43 5f 	call	0xbe86	; 0xbe86 <MenuOut>
		LCD_Out();
    c31e:	0e 94 b8 26 	call	0x4d70	; 0x4d70 <LCD_Out>
    c322:	08 95       	ret

0000c324 <strcpy_EE>:
	}//while
	return GSM_RxCharN;
}
// ~~~~~~~~~~~
//    EEPROM   RAM     '\0'    EEPROM
uint8_t strcpy_EE(char* str_RAM, uint8_t* str_EE){
    c324:	cf 92       	push	r12
    c326:	df 92       	push	r13
    c328:	ef 92       	push	r14
    c32a:	ff 92       	push	r15
    c32c:	1f 93       	push	r17
    c32e:	cf 93       	push	r28
    c330:	df 93       	push	r29
    c332:	6c 01       	movw	r12, r24
    c334:	7b 01       	movw	r14, r22
    c336:	10 e0       	ldi	r17, 0x00	; 0
    c338:	06 c0       	rjmp	.+12     	; 0xc346 <strcpy_EE+0x22>
	uint8_t i=0;
	while( (erb(&str_EE[i])!='\0') && (erb(&str_EE[i])!=' ') ){
    c33a:	80 32       	cpi	r24, 0x20	; 32
    c33c:	69 f0       	breq	.+26     	; 0xc358 <strcpy_EE+0x34>
		str_RAM[i] = (char)erb(&str_EE[i]);
    c33e:	cc 0d       	add	r28, r12
    c340:	dd 1d       	adc	r29, r13
    c342:	88 83       	st	Y, r24
		i++;
    c344:	1f 5f       	subi	r17, 0xFF	; 255
}
// ~~~~~~~~~~~
//    EEPROM   RAM     '\0'    EEPROM
uint8_t strcpy_EE(char* str_RAM, uint8_t* str_EE){
	uint8_t i=0;
	while( (erb(&str_EE[i])!='\0') && (erb(&str_EE[i])!=' ') ){
    c346:	c1 2f       	mov	r28, r17
    c348:	d0 e0       	ldi	r29, 0x00	; 0
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    c34a:	c7 01       	movw	r24, r14
    c34c:	8c 0f       	add	r24, r28
    c34e:	9d 1f       	adc	r25, r29
    c350:	0e 94 e7 82 	call	0x105ce	; 0x105ce <__eerd_byte_m2560>
    c354:	88 23       	and	r24, r24
    c356:	89 f7       	brne	.-30     	; 0xc33a <strcpy_EE+0x16>
		str_RAM[i] = (char)erb(&str_EE[i]);
		i++;
	}
	return i;	
}
    c358:	81 2f       	mov	r24, r17
    c35a:	df 91       	pop	r29
    c35c:	cf 91       	pop	r28
    c35e:	1f 91       	pop	r17
    c360:	ff 90       	pop	r15
    c362:	ef 90       	pop	r14
    c364:	df 90       	pop	r13
    c366:	cf 90       	pop	r12
    c368:	08 95       	ret

0000c36a <GSM_Cycle>:
	}//switch
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
void
GSM_Cycle(void)
{
    c36a:	7f 92       	push	r7
    c36c:	8f 92       	push	r8
    c36e:	9f 92       	push	r9
    c370:	af 92       	push	r10
    c372:	bf 92       	push	r11
    c374:	cf 92       	push	r12
    c376:	df 92       	push	r13
    c378:	ef 92       	push	r14
    c37a:	ff 92       	push	r15
    c37c:	0f 93       	push	r16
    c37e:	1f 93       	push	r17
    c380:	df 93       	push	r29
    c382:	cf 93       	push	r28
    c384:	cd b7       	in	r28, 0x3d	; 61
    c386:	de b7       	in	r29, 0x3e	; 62
    c388:	65 97       	sbiw	r28, 0x15	; 21
    c38a:	0f b6       	in	r0, 0x3f	; 63
    c38c:	f8 94       	cli
    c38e:	de bf       	out	0x3e, r29	; 62
    c390:	0f be       	out	0x3f, r0	; 63
    c392:	cd bf       	out	0x3d, r28	; 61
	switch(GSM_Control){
    c394:	80 91 8a 07 	lds	r24, 0x078A
    c398:	88 23       	and	r24, r24
    c39a:	d9 f4       	brne	.+54     	; 0xc3d2 <GSM_Cycle+0x68>
uint8_t RequestRepeatCounter = 0;

// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Auto(){

	switch(GSM_State){
    c39c:	80 91 b3 06 	lds	r24, 0x06B3
    c3a0:	e8 2f       	mov	r30, r24
    c3a2:	f0 e0       	ldi	r31, 0x00	; 0
    c3a4:	ea 35       	cpi	r30, 0x5A	; 90
    c3a6:	f1 05       	cpc	r31, r1
    c3a8:	68 f1       	brcs	.+90     	; 0xc404 <GSM_Cycle+0x9a>
			break;	
		case GSM_CNTL_CONFIG:
			GSM_Config();
			break;								
	}
}
    c3aa:	65 96       	adiw	r28, 0x15	; 21
    c3ac:	0f b6       	in	r0, 0x3f	; 63
    c3ae:	f8 94       	cli
    c3b0:	de bf       	out	0x3e, r29	; 62
    c3b2:	0f be       	out	0x3f, r0	; 63
    c3b4:	cd bf       	out	0x3d, r28	; 61
    c3b6:	cf 91       	pop	r28
    c3b8:	df 91       	pop	r29
    c3ba:	1f 91       	pop	r17
    c3bc:	0f 91       	pop	r16
    c3be:	ff 90       	pop	r15
    c3c0:	ef 90       	pop	r14
    c3c2:	df 90       	pop	r13
    c3c4:	cf 90       	pop	r12
    c3c6:	bf 90       	pop	r11
    c3c8:	af 90       	pop	r10
    c3ca:	9f 90       	pop	r9
    c3cc:	8f 90       	pop	r8
    c3ce:	7f 90       	pop	r7
    c3d0:	08 95       	ret
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
void
GSM_Cycle(void)
{
	switch(GSM_Control){
    c3d2:	82 30       	cpi	r24, 0x02	; 2
    c3d4:	51 f7       	brne	.-44     	; 0xc3aa <GSM_Cycle+0x40>
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Manual(){}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Config(){
	switch(GSM_State){
    c3d6:	80 91 b3 06 	lds	r24, 0x06B3
    c3da:	84 30       	cpi	r24, 0x04	; 4
    c3dc:	11 f4       	brne	.+4      	; 0xc3e2 <GSM_Cycle+0x78>
    c3de:	0c 94 3e 6b 	jmp	0xd67c	; 0xd67c <GSM_Cycle+0x1312>
    c3e2:	85 30       	cpi	r24, 0x05	; 5
    c3e4:	b8 f0       	brcs	.+46     	; 0xc414 <GSM_Cycle+0xaa>
    c3e6:	86 30       	cpi	r24, 0x06	; 6
    c3e8:	11 f4       	brne	.+4      	; 0xc3ee <GSM_Cycle+0x84>
    c3ea:	0c 94 f6 6a 	jmp	0xd5ec	; 0xd5ec <GSM_Cycle+0x1282>
    c3ee:	86 30       	cpi	r24, 0x06	; 6
    c3f0:	48 f1       	brcs	.+82     	; 0xc444 <GSM_Cycle+0xda>
    c3f2:	87 30       	cpi	r24, 0x07	; 7
    c3f4:	11 f4       	brne	.+4      	; 0xc3fa <GSM_Cycle+0x90>
    c3f6:	0c 94 2f 6b 	jmp	0xd65e	; 0xd65e <GSM_Cycle+0x12f4>
    c3fa:	88 30       	cpi	r24, 0x08	; 8
    c3fc:	b1 f2       	breq	.-84     	; 0xc3aa <GSM_Cycle+0x40>
			if(Timer16Stopp(TD_GSM)) GSM_State++;
			break;
		case GSM_FINISH:			
			break;
		default:
			GSM_State = GSM_CFG_START;
    c3fe:	10 92 b3 06 	sts	0x06B3, r1
    c402:	d3 cf       	rjmp	.-90     	; 0xc3aa <GSM_Cycle+0x40>
uint8_t RequestRepeatCounter = 0;

// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Auto(){

	switch(GSM_State){
    c404:	e4 50       	subi	r30, 0x04	; 4
    c406:	ff 4f       	sbci	r31, 0xFF	; 255
    c408:	ee 0f       	add	r30, r30
    c40a:	ff 1f       	adc	r31, r31
    c40c:	05 90       	lpm	r0, Z+
    c40e:	f4 91       	lpm	r31, Z+
    c410:	e0 2d       	mov	r30, r0
    c412:	19 94       	eijmp
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Manual(){}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Config(){
	switch(GSM_State){
    c414:	81 30       	cpi	r24, 0x01	; 1
    c416:	11 f4       	brne	.+4      	; 0xc41c <GSM_Cycle+0xb2>
    c418:	0c 94 1c 6b 	jmp	0xd638	; 0xd638 <GSM_Cycle+0x12ce>
    c41c:	81 30       	cpi	r24, 0x01	; 1
    c41e:	f0 f0       	brcs	.+60     	; 0xc45c <GSM_Cycle+0xf2>
    c420:	82 30       	cpi	r24, 0x02	; 2
    c422:	11 f4       	brne	.+4      	; 0xc428 <GSM_Cycle+0xbe>
    c424:	0c 94 0c 6b 	jmp	0xd618	; 0xd618 <GSM_Cycle+0x12ae>
    c428:	83 30       	cpi	r24, 0x03	; 3
    c42a:	49 f7       	brne	.-46     	; 0xc3fe <GSM_Cycle+0x94>
			break;
		case GSM_CFG_WAIT_AT_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_CFG_SEND_AT)) GSM_State++;
			break;
		case GSM_CFG_SEND_IPR:
			GSM_Execute_Command(AT_IPR9600, 100); GSM_State++;
    c42c:	80 e7       	ldi	r24, 0x70	; 112
    c42e:	94 e0       	ldi	r25, 0x04	; 4
    c430:	64 e6       	ldi	r22, 0x64	; 100
    c432:	70 e0       	ldi	r23, 0x00	; 0
    c434:	0e 94 1f 4b 	call	0x963e	; 0x963e <GSM_Execute_Command>
    c438:	80 91 b3 06 	lds	r24, 0x06B3
    c43c:	8f 5f       	subi	r24, 0xFF	; 255
    c43e:	80 93 b3 06 	sts	0x06B3, r24
    c442:	b3 cf       	rjmp	.-154    	; 0xc3aa <GSM_Cycle+0x40>
				StartTimer16(TD_GSM,200);
				GSM_State++;
			}
			break;
		case GSM_CFG_SEND_ATW:
			GSM_Execute_Command(AT_W, 100); GSM_State++;
    c444:	8c e7       	ldi	r24, 0x7C	; 124
    c446:	94 e0       	ldi	r25, 0x04	; 4
    c448:	64 e6       	ldi	r22, 0x64	; 100
    c44a:	70 e0       	ldi	r23, 0x00	; 0
    c44c:	0e 94 1f 4b 	call	0x963e	; 0x963e <GSM_Execute_Command>
    c450:	80 91 b3 06 	lds	r24, 0x06B3
    c454:	8f 5f       	subi	r24, 0xFF	; 255
    c456:	80 93 b3 06 	sts	0x06B3, r24
    c45a:	a7 cf       	rjmp	.-178    	; 0xc3aa <GSM_Cycle+0x40>
inline static void GSM_Manual(){}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Config(){
	switch(GSM_State){
		case GSM_CFG_START:
			StartTimer16(TD_GSM,200);
    c45c:	80 91 e7 04 	lds	r24, 0x04E7
    c460:	68 ec       	ldi	r22, 0xC8	; 200
    c462:	70 e0       	ldi	r23, 0x00	; 0
    c464:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
		cli();
		PORTL|=(1<<PL5);
		sei();
	}
	void GSM_PWRCNTRL_ON(void){
		cli();
    c468:	f8 94       	cli
		PORTL &= ~(1<<PL5);
    c46a:	80 91 0b 01 	lds	r24, 0x010B
    c46e:	8f 7d       	andi	r24, 0xDF	; 223
    c470:	80 93 0b 01 	sts	0x010B, r24
		sei();
    c474:	78 94       	sei
			GSM_PWRCNTRL_ON();
			GSM_State++;
    c476:	80 91 b3 06 	lds	r24, 0x06B3
    c47a:	8f 5f       	subi	r24, 0xFF	; 255
    c47c:	80 93 b3 06 	sts	0x06B3, r24
    c480:	94 cf       	rjmp	.-216    	; 0xc3aa <GSM_Cycle+0x40>
			break;
		case GSM_SEND_CGMM:
			GSM_Execute_Command(AT_CGMM,5000*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CGMM_READ:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
    c482:	80 91 e7 04 	lds	r24, 0x04E7
    c486:	0e 94 71 1c 	call	0x38e2	; 0x38e2 <Timer16Stopp>
    c48a:	88 23       	and	r24, r24
    c48c:	19 f0       	breq	.+6      	; 0xc494 <GSM_Cycle+0x12a>
    c48e:	8a e4       	ldi	r24, 0x4A	; 74
    c490:	80 93 b3 06 	sts	0x06B3, r24
			if(GetStringFromFIFO()){
    c494:	0e 94 eb 38 	call	0x71d6	; 0x71d6 <GetStringFromFIFO>
    c498:	88 23       	and	r24, r24
    c49a:	31 f1       	breq	.+76     	; 0xc4e8 <GSM_Cycle+0x17e>
				if(!strcmp_P(GSM_RxStr, GSM_SIMCOM_SIM900R)) GSM_Modem = SIMCOM_SIM900R;
    c49c:	89 e9       	ldi	r24, 0x99	; 153
    c49e:	97 e0       	ldi	r25, 0x07	; 7
    c4a0:	6b e5       	ldi	r22, 0x5B	; 91
    c4a2:	73 e0       	ldi	r23, 0x03	; 3
    c4a4:	0e 94 bd 7f 	call	0xff7a	; 0xff7a <strcmp_P>
    c4a8:	89 2b       	or	r24, r25
    c4aa:	19 f4       	brne	.+6      	; 0xc4b2 <GSM_Cycle+0x148>
    c4ac:	81 e0       	ldi	r24, 0x01	; 1
    c4ae:	80 93 f1 06 	sts	0x06F1, r24
				if(!strcmp_P(GSM_RxStr, GSM_SIMCOM_SIM800)) GSM_Modem = SIMCOM_SIM800;
    c4b2:	89 e9       	ldi	r24, 0x99	; 153
    c4b4:	97 e0       	ldi	r25, 0x07	; 7
    c4b6:	6a e6       	ldi	r22, 0x6A	; 106
    c4b8:	73 e0       	ldi	r23, 0x03	; 3
    c4ba:	0e 94 bd 7f 	call	0xff7a	; 0xff7a <strcmp_P>
    c4be:	89 2b       	or	r24, r25
    c4c0:	19 f4       	brne	.+6      	; 0xc4c8 <GSM_Cycle+0x15e>
    c4c2:	82 e0       	ldi	r24, 0x02	; 2
    c4c4:	80 93 f1 06 	sts	0x06F1, r24
				if(!strcmp_P(GSM_RxStr, GSM_SIMCOM_SIM800C)) GSM_Modem = SIMCOM_SIM800;
    c4c8:	89 e9       	ldi	r24, 0x99	; 153
    c4ca:	97 e0       	ldi	r25, 0x07	; 7
    c4cc:	68 e7       	ldi	r22, 0x78	; 120
    c4ce:	73 e0       	ldi	r23, 0x03	; 3
    c4d0:	0e 94 bd 7f 	call	0xff7a	; 0xff7a <strcmp_P>
    c4d4:	89 2b       	or	r24, r25
    c4d6:	11 f0       	breq	.+4      	; 0xc4dc <GSM_Cycle+0x172>
    c4d8:	0c 94 b4 6e 	jmp	0xdd68	; 0xdd68 <GSM_Cycle+0x19fe>
    c4dc:	82 e0       	ldi	r24, 0x02	; 2
    c4de:	80 93 f1 06 	sts	0x06F1, r24
				//Add here new model GSM-modem
				if(GSM_Modem != NOT_RECOGNIZED) GSM_State = GSM_WAIT_CALL_READY;
    c4e2:	86 e0       	ldi	r24, 0x06	; 6
    c4e4:	80 93 b3 06 	sts	0x06B3, r24
			}
		case GSM_WAIT_CFUN:
			if(GSM_Wait_Response_P(URC_CFUN, GSM_ReStart1)) GSM_State++;
    c4e8:	8b e8       	ldi	r24, 0x8B	; 139
    c4ea:	93 e0       	ldi	r25, 0x03	; 3
    c4ec:	6a e4       	ldi	r22, 0x4A	; 74
    c4ee:	0e 94 c4 4a 	call	0x9588	; 0x9588 <GSM_Wait_Response_P>
    c4f2:	88 23       	and	r24, r24
    c4f4:	09 f4       	brne	.+2      	; 0xc4f8 <GSM_Cycle+0x18e>
    c4f6:	59 cf       	rjmp	.-334    	; 0xc3aa <GSM_Cycle+0x40>
    c4f8:	80 91 b3 06 	lds	r24, 0x06B3
    c4fc:	8f 5f       	subi	r24, 0xFF	; 255
    c4fe:	80 93 b3 06 	sts	0x06B3, r24
    c502:	53 cf       	rjmp	.-346    	; 0xc3aa <GSM_Cycle+0x40>
		case GSM_WAIT_R2D_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;

		case GSM_WAIT_R2D_CONNECT:
			if(GSM_Wait_Response_P(RESP_CONNECT, GSM_ReStart1)){ 				
    c504:	84 ef       	ldi	r24, 0xF4	; 244
    c506:	93 e0       	ldi	r25, 0x03	; 3
    c508:	6a e4       	ldi	r22, 0x4A	; 74
    c50a:	0e 94 c4 4a 	call	0x9588	; 0x9588 <GSM_Wait_Response_P>
    c50e:	88 23       	and	r24, r24
    c510:	09 f4       	brne	.+2      	; 0xc514 <GSM_Cycle+0x1aa>
    c512:	4b cf       	rjmp	.-362    	; 0xc3aa <GSM_Cycle+0x40>
				GSM_State=GSM_ProtocolMode;
    c514:	82 e5       	ldi	r24, 0x52	; 82
    c516:	80 93 b3 06 	sts	0x06B3, r24
				StartTimer16(TD_timer_after_page_transfer,100);
    c51a:	80 91 ef 04 	lds	r24, 0x04EF
    c51e:	64 e6       	ldi	r22, 0x64	; 100
    c520:	70 e0       	ldi	r23, 0x00	; 0
    c522:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    c526:	8f ef       	ldi	r24, 0xFF	; 255
    c528:	80 93 fa 06 	sts	0x06FA, r24
	GSM_RX_FIFO_End = 255;
    c52c:	80 93 51 06 	sts	0x0651, r24
	GSM_RxCharN = 0;
    c530:	10 92 18 0b 	sts	0x0B18, r1
	GSM_RX_FIFOOverFlow = 0;
    c534:	10 92 cb 08 	sts	0x08CB, r1
	GSM_RX_FIFOMax = 0;
    c538:	10 92 d1 08 	sts	0x08D1, r1
    c53c:	36 cf       	rjmp	.-404    	; 0xc3aa <GSM_Cycle+0x40>
			GSM_State=GSM_WAIT_R2D_CONNECT;
		
			break;

		case GSM_WAIT_R2D_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    c53e:	81 ef       	ldi	r24, 0xF1	; 241
    c540:	93 e0       	ldi	r25, 0x03	; 3
    c542:	6a e4       	ldi	r22, 0x4A	; 74
    c544:	0e 94 c4 4a 	call	0x9588	; 0x9588 <GSM_Wait_Response_P>
    c548:	88 23       	and	r24, r24
    c54a:	09 f4       	brne	.+2      	; 0xc54e <GSM_Cycle+0x1e4>
    c54c:	2e cf       	rjmp	.-420    	; 0xc3aa <GSM_Cycle+0x40>
    c54e:	80 91 b3 06 	lds	r24, 0x06B3
    c552:	8f 5f       	subi	r24, 0xFF	; 255
    c554:	80 93 b3 06 	sts	0x06B3, r24
    c558:	28 cf       	rjmp	.-432    	; 0xc3aa <GSM_Cycle+0x40>
			break;

		//----  data mode
		case GSM_Return2dataMode:

			CommandModeDestination=0;
    c55a:	10 92 6b 07 	sts	0x076B, r1
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    c55e:	8f ef       	ldi	r24, 0xFF	; 255
    c560:	80 93 fa 06 	sts	0x06FA, r24
	GSM_RX_FIFO_End = 255;
    c564:	80 93 51 06 	sts	0x0651, r24
	GSM_RxCharN = 0;
    c568:	10 92 18 0b 	sts	0x0B18, r1
	GSM_RX_FIFOOverFlow = 0;
    c56c:	10 92 cb 08 	sts	0x08CB, r1
	GSM_RX_FIFOMax = 0;
    c570:	10 92 d1 08 	sts	0x08D1, r1
    c574:	e9 e9       	ldi	r30, 0x99	; 153
    c576:	f7 e0       	ldi	r31, 0x07	; 7

			CommandModeDestination=0;
			InitFIFO();
			for(int i=0;i<GSM_RXSTR_SIZE;i++)
			{
				GSM_RxStr[i]=0;	
    c578:	11 92       	st	Z+, r1
		//----  data mode
		case GSM_Return2dataMode:

			CommandModeDestination=0;
			InitFIFO();
			for(int i=0;i<GSM_RXSTR_SIZE;i++)
    c57a:	b7 e0       	ldi	r27, 0x07	; 7
    c57c:	ed 3f       	cpi	r30, 0xFD	; 253
    c57e:	fb 07       	cpc	r31, r27
    c580:	d9 f7       	brne	.-10     	; 0xc578 <GSM_Cycle+0x20e>
			{
				GSM_RxStr[i]=0;	
			}
			GSM_Execute_Command(ATO, 600*GSM_DEBUG_DELAY); //GSM_State++;
    c582:	81 e0       	ldi	r24, 0x01	; 1
    c584:	96 e0       	ldi	r25, 0x06	; 6
    c586:	68 e5       	ldi	r22, 0x58	; 88
    c588:	72 e0       	ldi	r23, 0x02	; 2
    c58a:	0e 94 1f 4b 	call	0x963e	; 0x963e <GSM_Execute_Command>
			GSM_State=GSM_WAIT_R2D_CONNECT;
    c58e:	89 e5       	ldi	r24, 0x59	; 89
    c590:	80 93 b3 06 	sts	0x06B3, r24
    c594:	0a cf       	rjmp	.-492    	; 0xc3aa <GSM_Cycle+0x40>
				StartTimer16(TD_GSM,1000);	// min 500ms after +++
				GSM_State++;
			}
			break;
		case GSM_WAIT_D2C_SWITCH_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) {
    c596:	81 ef       	ldi	r24, 0xF1	; 241
    c598:	93 e0       	ldi	r25, 0x03	; 3
    c59a:	6a e4       	ldi	r22, 0x4A	; 74
    c59c:	0e 94 c4 4a 	call	0x9588	; 0x9588 <GSM_Wait_Response_P>
    c5a0:	88 23       	and	r24, r24
    c5a2:	09 f4       	brne	.+2      	; 0xc5a6 <GSM_Cycle+0x23c>
    c5a4:	02 cf       	rjmp	.-508    	; 0xc3aa <GSM_Cycle+0x40>

				switch(CommandModeDestination){
    c5a6:	80 91 6b 07 	lds	r24, 0x076B
    c5aa:	82 30       	cpi	r24, 0x02	; 2
    c5ac:	11 f4       	brne	.+4      	; 0xc5b2 <GSM_Cycle+0x248>
    c5ae:	0c 94 d4 6e 	jmp	0xdda8	; 0xdda8 <GSM_Cycle+0x1a3e>
    c5b2:	83 30       	cpi	r24, 0x03	; 3
    c5b4:	10 f0       	brcs	.+4      	; 0xc5ba <GSM_Cycle+0x250>
    c5b6:	0c 94 97 6e 	jmp	0xdd2e	; 0xdd2e <GSM_Cycle+0x19c4>
    c5ba:	81 30       	cpi	r24, 0x01	; 1
    c5bc:	11 f4       	brne	.+4      	; 0xc5c2 <GSM_Cycle+0x258>
    c5be:	0c 94 cf 6e 	jmp	0xdd9e	; 0xdd9e <GSM_Cycle+0x1a34>
						break;
					case 5:	
						GSM_State = GSM_SEND_CSQ;
						counter=0;	
						break;
					default:GSM_State = GSM_Return2dataMode;
    c5c2:	87 e5       	ldi	r24, 0x57	; 87
    c5c4:	80 93 b3 06 	sts	0x06B3, r24
    c5c8:	f0 ce       	rjmp	.-544    	; 0xc3aa <GSM_Cycle+0x40>
//IF WEB			WebClose();
			GSM_State++;

			break;
		case GSM_Swtch2CommandModePlus:
			if(Timer16Stopp(TD_GSM)){
    c5ca:	80 91 e7 04 	lds	r24, 0x04E7
    c5ce:	0e 94 71 1c 	call	0x38e2	; 0x38e2 <Timer16Stopp>
    c5d2:	88 23       	and	r24, r24
    c5d4:	09 f4       	brne	.+2      	; 0xc5d8 <GSM_Cycle+0x26e>
    c5d6:	e9 ce       	rjmp	.-558    	; 0xc3aa <GSM_Cycle+0x40>
    c5d8:	e9 e9       	ldi	r30, 0x99	; 153
    c5da:	f7 e0       	ldi	r31, 0x07	; 7
				for(int i=0;i<GSM_RXSTR_SIZE;i++)
				{
					GSM_RxStr[i]=0;	
    c5dc:	11 92       	st	Z+, r1
			GSM_State++;

			break;
		case GSM_Swtch2CommandModePlus:
			if(Timer16Stopp(TD_GSM)){
				for(int i=0;i<GSM_RXSTR_SIZE;i++)
    c5de:	27 e0       	ldi	r18, 0x07	; 7
    c5e0:	ed 3f       	cpi	r30, 0xFD	; 253
    c5e2:	f2 07       	cpc	r31, r18
    c5e4:	d9 f7       	brne	.-10     	; 0xc5dc <GSM_Cycle+0x272>
				{
					GSM_RxStr[i]=0;	
				}
				sprintf_P(GSM_TxStr, ESC_SEQ);
    c5e6:	00 d0       	rcall	.+0      	; 0xc5e8 <GSM_Cycle+0x27e>
    c5e8:	0f 92       	push	r0
    c5ea:	02 e0       	ldi	r16, 0x02	; 2
    c5ec:	1a e0       	ldi	r17, 0x0A	; 10
    c5ee:	ad b7       	in	r26, 0x3d	; 61
    c5f0:	be b7       	in	r27, 0x3e	; 62
    c5f2:	12 96       	adiw	r26, 0x02	; 2
    c5f4:	1c 93       	st	X, r17
    c5f6:	0e 93       	st	-X, r16
    c5f8:	11 97       	sbiw	r26, 0x01	; 1
    c5fa:	8a e5       	ldi	r24, 0x5A	; 90
    c5fc:	94 e0       	ldi	r25, 0x04	; 4
    c5fe:	14 96       	adiw	r26, 0x04	; 4
    c600:	9c 93       	st	X, r25
    c602:	8e 93       	st	-X, r24
    c604:	13 97       	sbiw	r26, 0x03	; 3
    c606:	0e 94 ea 80 	call	0x101d4	; 0x101d4 <sprintf_P>
				GSMTxSz = strlen(GSM_TxStr);
    c60a:	f8 01       	movw	r30, r16
    c60c:	01 90       	ld	r0, Z+
    c60e:	00 20       	and	r0, r0
    c610:	e9 f7       	brne	.-6      	; 0xc60c <GSM_Cycle+0x2a2>
    c612:	8f 01       	movw	r16, r30
    c614:	01 50       	subi	r16, 0x01	; 1
    c616:	10 40       	sbci	r17, 0x00	; 0
    c618:	02 50       	subi	r16, 0x02	; 2
    c61a:	1a 40       	sbci	r17, 0x0A	; 10
    c61c:	00 93 75 07 	sts	0x0775, r16
				GSM_SendFirstChar();
    c620:	0f 90       	pop	r0
    c622:	0f 90       	pop	r0
    c624:	0f 90       	pop	r0
    c626:	0f 90       	pop	r0
    c628:	0e 94 15 3a 	call	0x742a	; 0x742a <GSM_SendFirstChar>
				StartTimer16(TD_GSM,1000);	// min 500ms after +++
    c62c:	80 91 e7 04 	lds	r24, 0x04E7
    c630:	68 ee       	ldi	r22, 0xE8	; 232
    c632:	73 e0       	ldi	r23, 0x03	; 3
    c634:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
				GSM_State++;
    c638:	80 91 b3 06 	lds	r24, 0x06B3
    c63c:	8f 5f       	subi	r24, 0xFF	; 255
    c63e:	80 93 b3 06 	sts	0x06B3, r24
    c642:	b3 ce       	rjmp	.-666    	; 0xc3aa <GSM_Cycle+0x40>
				GSM_State =GSM_ReStart1;
				break;
			}			
			break;
		case GSM_Swtch2CommandMode:
			StartTimer16(TD_GSM,100);	// min 1000ms before +++
    c644:	80 91 e7 04 	lds	r24, 0x04E7
    c648:	64 e6       	ldi	r22, 0x64	; 100
    c64a:	70 e0       	ldi	r23, 0x00	; 0
    c64c:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
//IF WEB			WebClose();
			GSM_State++;
    c650:	80 91 b3 06 	lds	r24, 0x06B3
    c654:	8f 5f       	subi	r24, 0xFF	; 255
    c656:	80 93 b3 06 	sts	0x06B3, r24
    c65a:	a7 ce       	rjmp	.-690    	; 0xc3aa <GSM_Cycle+0x40>
			}
			break;

		case GSM_DataMode:
			// -----    
			if(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){	// if FIFO not empty
    c65c:	90 91 fa 06 	lds	r25, 0x06FA
    c660:	80 91 51 06 	lds	r24, 0x0651
    c664:	98 17       	cp	r25, r24
    c666:	11 f4       	brne	.+4      	; 0xc66c <GSM_Cycle+0x302>
    c668:	0c 94 88 6d 	jmp	0xdb10	; 0xdb10 <GSM_Cycle+0x17a6>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    c66c:	83 ec       	ldi	r24, 0xC3	; 195
    c66e:	90 e0       	ldi	r25, 0x00	; 0
    c670:	0e 94 f5 82 	call	0x105ea	; 0x105ea <__eerd_word_m2560>
    c674:	bc 01       	movw	r22, r24
				StartTimer16(TD_TCP_Connect, erw(&TCP_CONNECT_timeout));	//   
    c676:	80 91 e8 04 	lds	r24, 0x04E8
    c67a:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
    c67e:	95 ce       	rjmp	.-726    	; 0xc3aa <GSM_Cycle+0x40>
		//------------------------

		//-----------

		case GSM_ProtocolMode:
			if( (strstr_P(GSM_RxStr, URC_CLOSED+2) != NULL) ){
    c680:	89 e9       	ldi	r24, 0x99	; 153
    c682:	97 e0       	ldi	r25, 0x07	; 7
    c684:	64 ed       	ldi	r22, 0xD4	; 212
    c686:	73 e0       	ldi	r23, 0x03	; 3
    c688:	0e 94 ef 7f 	call	0xffde	; 0xffde <strstr_P>
    c68c:	89 2b       	or	r24, r25
    c68e:	b1 f0       	breq	.+44     	; 0xc6bc <GSM_Cycle+0x352>
					GSM_State =GSM_ReStart1;
    c690:	8a e4       	ldi	r24, 0x4A	; 74
    c692:	80 93 b3 06 	sts	0x06B3, r24
    c696:	89 ce       	rjmp	.-750    	; 0xc3aa <GSM_Cycle+0x40>

			while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){	
					GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);
					if(GSM_RxCharN==2)
						{
							if(!strncmp_P(GSM_RxStr, PSTR("\r\n"), 2)) {GSM_RxCharN=0;}
    c698:	89 e9       	ldi	r24, 0x99	; 153
    c69a:	97 e0       	ldi	r25, 0x07	; 7
    c69c:	67 ee       	ldi	r22, 0xE7	; 231
    c69e:	7b e2       	ldi	r23, 0x2B	; 43
    c6a0:	42 e0       	ldi	r20, 0x02	; 2
    c6a2:	50 e0       	ldi	r21, 0x00	; 0
    c6a4:	0e 94 d6 7f 	call	0xffac	; 0xffac <strncmp_P>
    c6a8:	89 2b       	or	r24, r25
    c6aa:	11 f4       	brne	.+4      	; 0xc6b0 <GSM_Cycle+0x346>
    c6ac:	10 92 18 0b 	sts	0x0B18, r1
						}
					if(GSM_RxCharN >= 4){
    c6b0:	80 91 18 0b 	lds	r24, 0x0B18
    c6b4:	84 30       	cpi	r24, 0x04	; 4
    c6b6:	10 f0       	brcs	.+4      	; 0xc6bc <GSM_Cycle+0x352>
    c6b8:	0c 94 fc 6c 	jmp	0xd9f8	; 0xd9f8 <GSM_Cycle+0x168e>
					break;
			}



			while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){	
    c6bc:	90 91 fa 06 	lds	r25, 0x06FA
    c6c0:	80 91 51 06 	lds	r24, 0x0651
    c6c4:	98 17       	cp	r25, r24
    c6c6:	11 f4       	brne	.+4      	; 0xc6cc <GSM_Cycle+0x362>
    c6c8:	0c 94 3e 6d 	jmp	0xda7c	; 0xda7c <GSM_Cycle+0x1712>
					GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);
    c6cc:	89 e9       	ldi	r24, 0x99	; 153
    c6ce:	97 e0       	ldi	r25, 0x07	; 7
    c6d0:	68 e1       	ldi	r22, 0x18	; 24
    c6d2:	7b e0       	ldi	r23, 0x0B	; 11
    c6d4:	44 e6       	ldi	r20, 0x64	; 100
    c6d6:	0e 94 81 38 	call	0x7102	; 0x7102 <GetByteFromFIFO>
					if(GSM_RxCharN==2)
    c6da:	80 91 18 0b 	lds	r24, 0x0B18
    c6de:	82 30       	cpi	r24, 0x02	; 2
    c6e0:	39 f7       	brne	.-50     	; 0xc6b0 <GSM_Cycle+0x346>
    c6e2:	da cf       	rjmp	.-76     	; 0xc698 <GSM_Cycle+0x32e>
						}
					}
				}
			break;
		case GSM_WAIT_CSQ_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) {
    c6e4:	81 ef       	ldi	r24, 0xF1	; 241
    c6e6:	93 e0       	ldi	r25, 0x03	; 3
    c6e8:	6a e4       	ldi	r22, 0x4A	; 74
    c6ea:	0e 94 c4 4a 	call	0x9588	; 0x9588 <GSM_Wait_Response_P>
    c6ee:	88 23       	and	r24, r24
    c6f0:	09 f4       	brne	.+2      	; 0xc6f4 <GSM_Cycle+0x38a>
    c6f2:	5b ce       	rjmp	.-842    	; 0xc3aa <GSM_Cycle+0x40>
				if(CommandModeDestination==5){
    c6f4:	80 91 6b 07 	lds	r24, 0x076B
    c6f8:	85 30       	cpi	r24, 0x05	; 5
    c6fa:	11 f4       	brne	.+4      	; 0xc700 <GSM_Cycle+0x396>
    c6fc:	0c 94 c3 6e 	jmp	0xdd86	; 0xdd86 <GSM_Cycle+0x1a1c>
					GSM_State  = GSM_Return2dataMode;
				}
				else{
					GSM_State=GSM_SEND_CIPMUX;
    c700:	8a e2       	ldi	r24, 0x2A	; 42
    c702:	80 93 b3 06 	sts	0x06B3, r24
    c706:	51 ce       	rjmp	.-862    	; 0xc3aa <GSM_Cycle+0x40>
				GSM_Execute_Command(AT_CSQ, 500*GSM_DEBUG_DELAY); 
				InitFIFO();
				GSM_State++;
			break;
		case GSM_WAIT_CSQ:
				if(Timer16Stopp(TD_GSM)){
    c708:	80 91 e7 04 	lds	r24, 0x04E7
    c70c:	0e 94 71 1c 	call	0x38e2	; 0x38e2 <Timer16Stopp>
    c710:	88 23       	and	r24, r24
    c712:	11 f4       	brne	.+4      	; 0xc718 <GSM_Cycle+0x3ae>
    c714:	0c 94 97 6d 	jmp	0xdb2e	; 0xdb2e <GSM_Cycle+0x17c4>
						GSM_State = GSM_ReStart1;
    c718:	8a e4       	ldi	r24, 0x4A	; 74
    c71a:	80 93 b3 06 	sts	0x06B3, r24
    c71e:	45 ce       	rjmp	.-886    	; 0xc3aa <GSM_Cycle+0x40>
			break;
		case GSM_ShutWait_:
			if(GSM_Wait_Response_P(RESP_SHUT_OK, GSM_ReStart1)) GSM_State++;
			break;
		case GSM_SEND_CGATT0:
			GSM_Execute_Command(AT_CGATT_0, 1000*GSM_DEBUG_DELAY); GSM_State++;
    c720:	8f ee       	ldi	r24, 0xEF	; 239
    c722:	95 e0       	ldi	r25, 0x05	; 5
    c724:	68 ee       	ldi	r22, 0xE8	; 232
    c726:	73 e0       	ldi	r23, 0x03	; 3
    c728:	0e 94 1f 4b 	call	0x963e	; 0x963e <GSM_Execute_Command>
    c72c:	80 91 b3 06 	lds	r24, 0x06B3
    c730:	8f 5f       	subi	r24, 0xFF	; 255
    c732:	80 93 b3 06 	sts	0x06B3, r24
    c736:	39 ce       	rjmp	.-910    	; 0xc3aa <GSM_Cycle+0x40>
			break;
		//------------------------    


		case GSM_SEND_ATD_Check_Ballance:	
			if(GSM_Flag & (1<<flg_TxCStr)){
    c738:	80 91 d2 02 	lds	r24, 0x02D2
    c73c:	80 ff       	sbrs	r24, 0
    c73e:	4b c0       	rjmp	.+150    	; 0xc7d6 <GSM_Cycle+0x46c>
				sprintf_P(GSM_TxStr, AT_CUSD101);	
    c740:	00 d0       	rcall	.+0      	; 0xc742 <GSM_Cycle+0x3d8>
    c742:	0f 92       	push	r0
    c744:	82 e0       	ldi	r24, 0x02	; 2
    c746:	9a e0       	ldi	r25, 0x0A	; 10
    c748:	ad b7       	in	r26, 0x3d	; 61
    c74a:	be b7       	in	r27, 0x3e	; 62
    c74c:	12 96       	adiw	r26, 0x02	; 2
    c74e:	9c 93       	st	X, r25
    c750:	8e 93       	st	-X, r24
    c752:	11 97       	sbiw	r26, 0x01	; 1
    c754:	07 ec       	ldi	r16, 0xC7	; 199
    c756:	14 e0       	ldi	r17, 0x04	; 4
    c758:	14 96       	adiw	r26, 0x04	; 4
    c75a:	1c 93       	st	X, r17
    c75c:	0e 93       	st	-X, r16
    c75e:	13 97       	sbiw	r26, 0x03	; 3
    c760:	0e 94 ea 80 	call	0x101d4	; 0x101d4 <sprintf_P>
				GSMTxSz = strlen_P(AT_CUSD101);
    c764:	0f 90       	pop	r0
    c766:	0f 90       	pop	r0
    c768:	0f 90       	pop	r0
    c76a:	0f 90       	pop	r0
    c76c:	c8 01       	movw	r24, r16
    c76e:	0e 94 cd 7f 	call	0xff9a	; 0xff9a <strlen_P>
    c772:	80 93 75 07 	sts	0x0775, r24
				GSMTxSz += strcpy_EE(GSM_TxStr+GSMTxSz,GPRS_checkballancerequest);
    c776:	80 91 75 07 	lds	r24, 0x0775
    c77a:	90 e0       	ldi	r25, 0x00	; 0
    c77c:	8e 5f       	subi	r24, 0xFE	; 254
    c77e:	95 4f       	sbci	r25, 0xF5	; 245
    c780:	61 e3       	ldi	r22, 0x31	; 49
    c782:	70 e0       	ldi	r23, 0x00	; 0
    c784:	0e 94 92 61 	call	0xc324	; 0xc324 <strcpy_EE>
    c788:	90 91 75 07 	lds	r25, 0x0775
    c78c:	98 0f       	add	r25, r24
    c78e:	90 93 75 07 	sts	0x0775, r25
				GSM_TxStr[GSMTxSz]='"';
    c792:	e0 91 75 07 	lds	r30, 0x0775
    c796:	f0 e0       	ldi	r31, 0x00	; 0
    c798:	ee 5f       	subi	r30, 0xFE	; 254
    c79a:	f5 4f       	sbci	r31, 0xF5	; 245
    c79c:	82 e2       	ldi	r24, 0x22	; 34
    c79e:	80 83       	st	Z, r24
				GSM_TxStr[GSMTxSz+1]='\r';
    c7a0:	e0 91 75 07 	lds	r30, 0x0775
    c7a4:	f0 e0       	ldi	r31, 0x00	; 0
    c7a6:	ee 5f       	subi	r30, 0xFE	; 254
    c7a8:	f5 4f       	sbci	r31, 0xF5	; 245
    c7aa:	8d e0       	ldi	r24, 0x0D	; 13
    c7ac:	81 83       	std	Z+1, r24	; 0x01
				GSM_TxStr[GSMTxSz+2]='\n';
    c7ae:	e0 91 75 07 	lds	r30, 0x0775
    c7b2:	f0 e0       	ldi	r31, 0x00	; 0
    c7b4:	ee 5f       	subi	r30, 0xFE	; 254
    c7b6:	f5 4f       	sbci	r31, 0xF5	; 245
    c7b8:	8a e0       	ldi	r24, 0x0A	; 10
    c7ba:	82 83       	std	Z+2, r24	; 0x02
				GSMTxSz+=3;
    c7bc:	80 91 75 07 	lds	r24, 0x0775
    c7c0:	8d 5f       	subi	r24, 0xFD	; 253
    c7c2:	80 93 75 07 	sts	0x0775, r24
				GSM_SendFirstChar();
    c7c6:	0e 94 15 3a 	call	0x742a	; 0x742a <GSM_SendFirstChar>
				StartTimer16(TD_GSM, 1000);
    c7ca:	80 91 e7 04 	lds	r24, 0x04E7
    c7ce:	68 ee       	ldi	r22, 0xE8	; 232
    c7d0:	73 e0       	ldi	r23, 0x03	; 3
    c7d2:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
			}
			GSM_State++;	
    c7d6:	80 91 b3 06 	lds	r24, 0x06B3
    c7da:	8f 5f       	subi	r24, 0xFF	; 255
    c7dc:	80 93 b3 06 	sts	0x06B3, r24
			GSM_Temp = 0;
    c7e0:	10 92 d9 05 	sts	0x05D9, r1
    c7e4:	e2 cd       	rjmp	.-1084   	; 0xc3aa <GSM_Cycle+0x40>
			SetIP(&GSM_ClientIP,0,0,0,0);
			GSM_Flag |=(1<<flg_TxCStr);
			GSM_State++;
			break;
		case GSM_ReStart2:
			if(Timer16Stopp(TD_GSM)){
    c7e6:	80 91 e7 04 	lds	r24, 0x04E7
    c7ea:	0e 94 71 1c 	call	0x38e2	; 0x38e2 <Timer16Stopp>
    c7ee:	88 23       	and	r24, r24
    c7f0:	09 f4       	brne	.+2      	; 0xc7f4 <GSM_Cycle+0x48a>
    c7f2:	db cd       	rjmp	.-1098   	; 0xc3aa <GSM_Cycle+0x40>
				GSM_State = GSM_PowerOn;
    c7f4:	10 92 b3 06 	sts	0x06B3, r1
    c7f8:	d8 cd       	rjmp	.-1104   	; 0xc3aa <GSM_Cycle+0x40>
		//------------------------

		
		//------------------------
		case GSM_ReStart1:
			GSM_ReStartN++;
    c7fa:	80 91 ed 08 	lds	r24, 0x08ED
    c7fe:	8f 5f       	subi	r24, 0xFF	; 255
    c800:	80 93 ed 08 	sts	0x08ED, r24
		cli();
		DDRL|=(1<<PL5);
		sei();
	}
	void GSM_PWRCNTRL_OFF(void){
		cli();
    c804:	f8 94       	cli
		PORTL|=(1<<PL5);
    c806:	80 91 0b 01 	lds	r24, 0x010B
    c80a:	80 62       	ori	r24, 0x20	; 32
    c80c:	80 93 0b 01 	sts	0x010B, r24
		sei();
    c810:	78 94       	sei
			GSM_PWRCNTRL_OFF();
			StartTimer16(TD_GSM,1000);
    c812:	80 91 e7 04 	lds	r24, 0x04E7
    c816:	68 ee       	ldi	r22, 0xE8	; 232
    c818:	73 e0       	ldi	r23, 0x03	; 3
    c81a:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
			RxBufOverFlow = 0;
    c81e:	10 92 01 0b 	sts	0x0B01, r1
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    c822:	8f ef       	ldi	r24, 0xFF	; 255
    c824:	80 93 fa 06 	sts	0x06FA, r24
	GSM_RX_FIFO_End = 255;
    c828:	80 93 51 06 	sts	0x0651, r24
	GSM_RxCharN = 0;
    c82c:	10 92 18 0b 	sts	0x0B18, r1
	GSM_RX_FIFOOverFlow = 0;
    c830:	10 92 cb 08 	sts	0x08CB, r1
	GSM_RX_FIFOMax = 0;
    c834:	10 92 d1 08 	sts	0x08D1, r1
    c838:	e9 e9       	ldi	r30, 0x99	; 153
    c83a:	f7 e0       	ldi	r31, 0x07	; 7
			RxBufOverFlow = 0;
		//	WebSession=0;
			InitFIFO();
			for(int i=0;i<GSM_RXSTR_SIZE;i++)
			{
				GSM_RxStr[i]=0;	
    c83c:	11 92       	st	Z+, r1
			GSM_PWRCNTRL_OFF();
			StartTimer16(TD_GSM,1000);
			RxBufOverFlow = 0;
		//	WebSession=0;
			InitFIFO();
			for(int i=0;i<GSM_RXSTR_SIZE;i++)
    c83e:	27 e0       	ldi	r18, 0x07	; 7
    c840:	ed 3f       	cpi	r30, 0xFD	; 253
    c842:	f2 07       	cpc	r31, r18
    c844:	d9 f7       	brne	.-10     	; 0xc83c <GSM_Cycle+0x4d2>
			{
				GSM_RxStr[i]=0;	
			}
			SMS_FlgSz_Out = 0;	// ..          -  
    c846:	10 92 82 07 	sts	0x0782, r1
			GSM_ActiveConnection = NO_CONNECTION;
    c84a:	8f ef       	ldi	r24, 0xFF	; 255
    c84c:	80 93 d3 02 	sts	0x02D3, r24
	uint8_t IP4;
} IP_Addr;

//~~~~~~~~~~~~~~
void SetIP(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	IP->IP1 = IP1;
    c850:	10 92 02 0b 	sts	0x0B02, r1
	IP->IP2 = IP2;
    c854:	10 92 03 0b 	sts	0x0B03, r1
	IP->IP3 = IP3;
    c858:	10 92 04 0b 	sts	0x0B04, r1
	IP->IP4 = IP4;
    c85c:	10 92 05 0b 	sts	0x0B05, r1
			SetIP(&GSM_ClientIP,0,0,0,0);
			GSM_Flag |=(1<<flg_TxCStr);
    c860:	80 91 d2 02 	lds	r24, 0x02D2
    c864:	81 60       	ori	r24, 0x01	; 1
    c866:	80 93 d2 02 	sts	0x02D2, r24
			GSM_State++;
    c86a:	80 91 b3 06 	lds	r24, 0x06B3
    c86e:	8f 5f       	subi	r24, 0xFF	; 255
    c870:	80 93 b3 06 	sts	0x06B3, r24
    c874:	9a cd       	rjmp	.-1228   	; 0xc3aa <GSM_Cycle+0x40>
			break;
		case GSM_SEND_CGATT0:
			GSM_Execute_Command(AT_CGATT_0, 1000*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CGATT0_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    c876:	81 ef       	ldi	r24, 0xF1	; 241
    c878:	93 e0       	ldi	r25, 0x03	; 3
    c87a:	6a e4       	ldi	r22, 0x4A	; 74
    c87c:	0e 94 c4 4a 	call	0x9588	; 0x9588 <GSM_Wait_Response_P>
    c880:	88 23       	and	r24, r24
    c882:	09 f4       	brne	.+2      	; 0xc886 <GSM_Cycle+0x51c>
    c884:	92 cd       	rjmp	.-1244   	; 0xc3aa <GSM_Cycle+0x40>
				StartTimer16(TD_GSM, 1000);
    c886:	80 91 e7 04 	lds	r24, 0x04E7
    c88a:	68 ee       	ldi	r22, 0xE8	; 232
    c88c:	73 e0       	ldi	r23, 0x03	; 3
    c88e:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
			 	GSM_State = GSM_SEND_ATD_Check_Ballance;
    c892:	8c e4       	ldi	r24, 0x4C	; 76
    c894:	80 93 b3 06 	sts	0x06B3, r24
    c898:	88 cd       	rjmp	.-1264   	; 0xc3aa <GSM_Cycle+0x40>
			break;
		case GSM_WAIT_ATD_Check_Ballance_OK:
			if(GSM_Wait_Response_P(RESP_OK,GSM_SEND_CSQ)) GSM_State++;
			break;
		case GSM_WAIT_Ballance:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_SEND_CSQ;
    c89a:	80 91 e7 04 	lds	r24, 0x04E7
    c89e:	0e 94 71 1c 	call	0x38e2	; 0x38e2 <Timer16Stopp>
    c8a2:	88 23       	and	r24, r24
    c8a4:	19 f0       	breq	.+6      	; 0xc8ac <GSM_Cycle+0x542>
    c8a6:	8f e4       	ldi	r24, 0x4F	; 79
    c8a8:	80 93 b3 06 	sts	0x06B3, r24
			GSM_RxStr[GSM_RXSTR_SIZE-1]='\0';
    c8ac:	10 92 fc 07 	sts	0x07FC, r1
		
				GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);

				if(GSM_RxCharN >= 90){

					GSM_State = GSM_SEND_CSQ;
    c8b0:	1f e4       	ldi	r17, 0x4F	; 79
			if(GSM_Wait_Response_P(RESP_OK,GSM_SEND_CSQ)) GSM_State++;
			break;
		case GSM_WAIT_Ballance:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_SEND_CSQ;
			GSM_RxStr[GSM_RXSTR_SIZE-1]='\0';
			while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    c8b2:	90 91 fa 06 	lds	r25, 0x06FA
    c8b6:	80 91 51 06 	lds	r24, 0x0651
    c8ba:	98 17       	cp	r25, r24
    c8bc:	09 f4       	brne	.+2      	; 0xc8c0 <GSM_Cycle+0x556>
    c8be:	f4 c6       	rjmp	.+3560   	; 0xd6a8 <GSM_Cycle+0x133e>
				
		
				GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);
    c8c0:	89 e9       	ldi	r24, 0x99	; 153
    c8c2:	97 e0       	ldi	r25, 0x07	; 7
    c8c4:	68 e1       	ldi	r22, 0x18	; 24
    c8c6:	7b e0       	ldi	r23, 0x0B	; 11
    c8c8:	44 e6       	ldi	r20, 0x64	; 100
    c8ca:	0e 94 81 38 	call	0x7102	; 0x7102 <GetByteFromFIFO>

				if(GSM_RxCharN >= 90){
    c8ce:	80 91 18 0b 	lds	r24, 0x0B18
    c8d2:	8a 35       	cpi	r24, 0x5A	; 90
    c8d4:	70 f3       	brcs	.-36     	; 0xc8b2 <GSM_Cycle+0x548>

					GSM_State = GSM_SEND_CSQ;
    c8d6:	10 93 b3 06 	sts	0x06B3, r17
    c8da:	eb cf       	rjmp	.-42     	; 0xc8b2 <GSM_Cycle+0x548>
			}
			GSM_State++;	
			GSM_Temp = 0;
			break;
		case GSM_WAIT_ATD_Check_Ballance_OK:
			if(GSM_Wait_Response_P(RESP_OK,GSM_SEND_CSQ)) GSM_State++;
    c8dc:	81 ef       	ldi	r24, 0xF1	; 241
    c8de:	93 e0       	ldi	r25, 0x03	; 3
    c8e0:	6f e4       	ldi	r22, 0x4F	; 79
    c8e2:	0e 94 c4 4a 	call	0x9588	; 0x9588 <GSM_Wait_Response_P>
    c8e6:	88 23       	and	r24, r24
    c8e8:	09 f4       	brne	.+2      	; 0xc8ec <GSM_Cycle+0x582>
    c8ea:	5f cd       	rjmp	.-1346   	; 0xc3aa <GSM_Cycle+0x40>
    c8ec:	80 91 b3 06 	lds	r24, 0x06B3
    c8f0:	8f 5f       	subi	r24, 0xFF	; 255
    c8f2:	80 93 b3 06 	sts	0x06B3, r24
    c8f6:	59 cd       	rjmp	.-1358   	; 0xc3aa <GSM_Cycle+0x40>
			}	
			break;

		//------------------------   GSM-
		case GSM_SEND_CSQ:
				GSM_Execute_Command(AT_CSQ, 500*GSM_DEBUG_DELAY); 
    c8f8:	8a ef       	ldi	r24, 0xFA	; 250
    c8fa:	95 e0       	ldi	r25, 0x05	; 5
    c8fc:	64 ef       	ldi	r22, 0xF4	; 244
    c8fe:	71 e0       	ldi	r23, 0x01	; 1
    c900:	0e 94 1f 4b 	call	0x963e	; 0x963e <GSM_Execute_Command>
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    c904:	8f ef       	ldi	r24, 0xFF	; 255
    c906:	80 93 fa 06 	sts	0x06FA, r24
	GSM_RX_FIFO_End = 255;
    c90a:	80 93 51 06 	sts	0x0651, r24
	GSM_RxCharN = 0;
    c90e:	10 92 18 0b 	sts	0x0B18, r1
	GSM_RX_FIFOOverFlow = 0;
    c912:	10 92 cb 08 	sts	0x08CB, r1
	GSM_RX_FIFOMax = 0;
    c916:	10 92 d1 08 	sts	0x08D1, r1

		//------------------------   GSM-
		case GSM_SEND_CSQ:
				GSM_Execute_Command(AT_CSQ, 500*GSM_DEBUG_DELAY); 
				InitFIFO();
				GSM_State++;
    c91a:	80 91 b3 06 	lds	r24, 0x06B3
    c91e:	8f 5f       	subi	r24, 0xFF	; 255
    c920:	80 93 b3 06 	sts	0x06B3, r24
    c924:	42 cd       	rjmp	.-1404   	; 0xc3aa <GSM_Cycle+0x40>
			break;
		case GSM_WAIT_SMS_Inv:
			if(GSM_Wait_Char('>', GSM_ReStart1)) GSM_State++;
			break;
		case GSM_SEND_SMS_DATA:
			SMS_Data_Out[SMS_FlgSz_Out] = 0x1A;	// SMS Data end - char Ctrl-Z
    c926:	60 91 82 07 	lds	r22, 0x0782
    c92a:	e6 2f       	mov	r30, r22
    c92c:	f0 e0       	ldi	r31, 0x00	; 0
    c92e:	ea 5f       	subi	r30, 0xFA	; 250
    c930:	f8 4f       	sbci	r31, 0xF8	; 248
    c932:	8a e1       	ldi	r24, 0x1A	; 26
    c934:	80 83       	st	Z, r24
			GSM_SendData((uint8_t *)SMS_Data_Out, SMS_FlgSz_Out+1);
    c936:	6f 5f       	subi	r22, 0xFF	; 255
    c938:	86 e0       	ldi	r24, 0x06	; 6
    c93a:	97 e0       	ldi	r25, 0x07	; 7
    c93c:	0e 94 a2 40 	call	0x8144	; 0x8144 <GSM_SendData>
			GSM_State++;
    c940:	80 91 b3 06 	lds	r24, 0x06B3
    c944:	8f 5f       	subi	r24, 0xFF	; 255
    c946:	80 93 b3 06 	sts	0x06B3, r24
    c94a:	2f cd       	rjmp	.-1442   	; 0xc3aa <GSM_Cycle+0x40>
					}					
				}
			}
			break;
		case GSM_WAIT_SMS_Inv:
			if(GSM_Wait_Char('>', GSM_ReStart1)) GSM_State++;
    c94c:	8e e3       	ldi	r24, 0x3E	; 62
    c94e:	6a e4       	ldi	r22, 0x4A	; 74
    c950:	0e 94 f3 39 	call	0x73e6	; 0x73e6 <GSM_Wait_Char>
    c954:	88 23       	and	r24, r24
    c956:	09 f4       	brne	.+2      	; 0xc95a <GSM_Cycle+0x5f0>
    c958:	28 cd       	rjmp	.-1456   	; 0xc3aa <GSM_Cycle+0x40>
    c95a:	80 91 b3 06 	lds	r24, 0x06B3
    c95e:	8f 5f       	subi	r24, 0xFF	; 255
    c960:	80 93 b3 06 	sts	0x06B3, r24
    c964:	22 cd       	rjmp	.-1468   	; 0xc3aa <GSM_Cycle+0x40>
			}
			break;

		//------------------------
		case GSM_SEND_CMGS:
			if(GSM_Flag & (1<<flg_TxCStr)){			
    c966:	80 91 d2 02 	lds	r24, 0x02D2
    c96a:	80 ff       	sbrs	r24, 0
    c96c:	1e cd       	rjmp	.-1476   	; 0xc3aa <GSM_Cycle+0x40>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    c96e:	42 e0       	ldi	r20, 0x02	; 2
    c970:	e4 2e       	mov	r14, r20
    c972:	4a e0       	ldi	r20, 0x0A	; 10
    c974:	f4 2e       	mov	r15, r20
    c976:	60 91 da 05 	lds	r22, 0x05DA
    c97a:	8d e0       	ldi	r24, 0x0D	; 13
    c97c:	68 9f       	mul	r22, r24
    c97e:	b0 01       	movw	r22, r0
    c980:	11 24       	eor	r1, r1
    c982:	6b 53       	subi	r22, 0x3B	; 59
    c984:	7f 4f       	sbci	r23, 0xFF	; 255
    c986:	c7 01       	movw	r24, r14
    c988:	4d e0       	ldi	r20, 0x0D	; 13
    c98a:	50 e0       	ldi	r21, 0x00	; 0
    c98c:	0e 94 d7 82 	call	0x105ae	; 0x105ae <__eerd_block_m2560>
				erbl(GSM_TxStr, SMS_Number+TempNum, MaxTelephN);
				GSMTxSz = strlen(GSM_TxStr);
    c990:	f7 01       	movw	r30, r14
    c992:	01 90       	ld	r0, Z+
    c994:	00 20       	and	r0, r0
    c996:	e9 f7       	brne	.-6      	; 0xc992 <GSM_Cycle+0x628>
    c998:	31 97       	sbiw	r30, 0x01	; 1
    c99a:	ee 19       	sub	r30, r14
    c99c:	ff 09       	sbc	r31, r15
    c99e:	e0 93 75 07 	sts	0x0775, r30
				uint8_t j=0;
				for(uint8_t i=0; i<GSMTxSz; i++)
    c9a2:	80 91 75 07 	lds	r24, 0x0775
    c9a6:	88 23       	and	r24, r24
    c9a8:	99 f0       	breq	.+38     	; 0xc9d0 <GSM_Cycle+0x666>
    c9aa:	90 e0       	ldi	r25, 0x00	; 0
    c9ac:	20 e0       	ldi	r18, 0x00	; 0
					if(GSM_TxStr[i] != '0') j++;
    c9ae:	e9 2f       	mov	r30, r25
    c9b0:	f0 e0       	ldi	r31, 0x00	; 0
    c9b2:	ee 5f       	subi	r30, 0xFE	; 254
    c9b4:	f5 4f       	sbci	r31, 0xF5	; 245
    c9b6:	80 81       	ld	r24, Z
    c9b8:	80 33       	cpi	r24, 0x30	; 48
    c9ba:	09 f0       	breq	.+2      	; 0xc9be <GSM_Cycle+0x654>
    c9bc:	2f 5f       	subi	r18, 0xFF	; 255
		case GSM_SEND_CMGS:
			if(GSM_Flag & (1<<flg_TxCStr)){			
				erbl(GSM_TxStr, SMS_Number+TempNum, MaxTelephN);
				GSMTxSz = strlen(GSM_TxStr);
				uint8_t j=0;
				for(uint8_t i=0; i<GSMTxSz; i++)
    c9be:	9f 5f       	subi	r25, 0xFF	; 255
    c9c0:	80 91 75 07 	lds	r24, 0x0775
    c9c4:	98 17       	cp	r25, r24
    c9c6:	98 f3       	brcs	.-26     	; 0xc9ae <GSM_Cycle+0x644>
					if(GSM_TxStr[i] != '0') j++;
				if(j){
    c9c8:	22 23       	and	r18, r18
    c9ca:	11 f0       	breq	.+4      	; 0xc9d0 <GSM_Cycle+0x666>
    c9cc:	0c 94 db 6e 	jmp	0xddb6	; 0xddb6 <GSM_Cycle+0x1a4c>
					GSM_SendFirstChar();
					StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
					GSM_State++;
				}
				else{
					TempNum++;
    c9d0:	80 91 da 05 	lds	r24, 0x05DA
    c9d4:	8f 5f       	subi	r24, 0xFF	; 255
    c9d6:	80 93 da 05 	sts	0x05DA, r24
					if(TempNum>=MaxTelephDirSz){
    c9da:	83 30       	cpi	r24, 0x03	; 3
    c9dc:	08 f4       	brcc	.+2      	; 0xc9e0 <GSM_Cycle+0x676>
    c9de:	e5 cc       	rjmp	.-1590   	; 0xc3aa <GSM_Cycle+0x40>
						//StartTimer16(TD_GSM,150);

						GSM_State = GSM_Return2dataMode;
    c9e0:	87 e5       	ldi	r24, 0x57	; 87
    c9e2:	80 93 b3 06 	sts	0x06B3, r24
				
						SMS_FlgSz_Out = 0;
    c9e6:	10 92 82 07 	sts	0x0782, r1
    c9ea:	df cc       	rjmp	.-1602   	; 0xc3aa <GSM_Cycle+0x40>
			break;

		case GSM_AnalyzeURC:			//  
			
			// 
			if( (strstr_P(GSM_RxStr, URC_CLOSED+2) != NULL) ){
    c9ec:	09 e9       	ldi	r16, 0x99	; 153
    c9ee:	17 e0       	ldi	r17, 0x07	; 7
    c9f0:	c8 01       	movw	r24, r16
    c9f2:	64 ed       	ldi	r22, 0xD4	; 212
    c9f4:	73 e0       	ldi	r23, 0x03	; 3
    c9f6:	0e 94 ef 7f 	call	0xffde	; 0xffde <strstr_P>
    c9fa:	89 2b       	or	r24, r25
    c9fc:	11 f4       	brne	.+4      	; 0xca02 <GSM_Cycle+0x698>
    c9fe:	0c 94 33 6f 	jmp	0xde66	; 0xde66 <GSM_Cycle+0x1afc>
				GSM_State =GSM_ReStart1;
    ca02:	8a e4       	ldi	r24, 0x4A	; 74
    ca04:	80 93 b3 06 	sts	0x06B3, r24
    ca08:	d0 cc       	rjmp	.-1632   	; 0xc3aa <GSM_Cycle+0x40>
		//------------------------


		//------------------------
		case GSM_CIPSHUT_:
			GSM_Execute_Command(AT_CIPSHUT, 1000*GSM_DEBUG_DELAY); GSM_State++;
    ca0a:	84 ee       	ldi	r24, 0xE4	; 228
    ca0c:	95 e0       	ldi	r25, 0x05	; 5
    ca0e:	68 ee       	ldi	r22, 0xE8	; 232
    ca10:	73 e0       	ldi	r23, 0x03	; 3
    ca12:	0e 94 1f 4b 	call	0x963e	; 0x963e <GSM_Execute_Command>
    ca16:	80 91 b3 06 	lds	r24, 0x06B3
    ca1a:	8f 5f       	subi	r24, 0xFF	; 255
    ca1c:	80 93 b3 06 	sts	0x06B3, r24
    ca20:	c4 cc       	rjmp	.-1656   	; 0xc3aa <GSM_Cycle+0x40>
			break;
		case GSM_ShutWait_:
			if(GSM_Wait_Response_P(RESP_SHUT_OK, GSM_ReStart1)) GSM_State++;
    ca22:	89 e4       	ldi	r24, 0x49	; 73
    ca24:	94 e0       	ldi	r25, 0x04	; 4
    ca26:	6a e4       	ldi	r22, 0x4A	; 74
    ca28:	0e 94 c4 4a 	call	0x9588	; 0x9588 <GSM_Wait_Response_P>
    ca2c:	88 23       	and	r24, r24
    ca2e:	09 f4       	brne	.+2      	; 0xca32 <GSM_Cycle+0x6c8>
    ca30:	bc cc       	rjmp	.-1672   	; 0xc3aa <GSM_Cycle+0x40>
    ca32:	80 91 b3 06 	lds	r24, 0x06B3
    ca36:	8f 5f       	subi	r24, 0xFF	; 255
    ca38:	80 93 b3 06 	sts	0x06B3, r24
    ca3c:	b6 cc       	rjmp	.-1684   	; 0xc3aa <GSM_Cycle+0x40>
			SMS_Data_Out[SMS_FlgSz_Out] = 0x1A;	// SMS Data end - char Ctrl-Z
			GSM_SendData((uint8_t *)SMS_Data_Out, SMS_FlgSz_Out+1);
			GSM_State++;
			break;		
		case GSM_WAIT_CMGS_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    ca3e:	81 ef       	ldi	r24, 0xF1	; 241
    ca40:	93 e0       	ldi	r25, 0x03	; 3
    ca42:	6a e4       	ldi	r22, 0x4A	; 74
    ca44:	0e 94 c4 4a 	call	0x9588	; 0x9588 <GSM_Wait_Response_P>
    ca48:	88 23       	and	r24, r24
    ca4a:	09 f4       	brne	.+2      	; 0xca4e <GSM_Cycle+0x6e4>
    ca4c:	ae cc       	rjmp	.-1700   	; 0xc3aa <GSM_Cycle+0x40>
				if(++TempNum>=MaxTelephDirSz){
    ca4e:	80 91 da 05 	lds	r24, 0x05DA
    ca52:	8f 5f       	subi	r24, 0xFF	; 255
    ca54:	80 93 da 05 	sts	0x05DA, r24
    ca58:	83 30       	cpi	r24, 0x03	; 3
    ca5a:	10 f4       	brcc	.+4      	; 0xca60 <GSM_Cycle+0x6f6>
    ca5c:	0c 94 92 6e 	jmp	0xdd24	; 0xdd24 <GSM_Cycle+0x19ba>
					GSM_State = GSM_Return2dataMode;
    ca60:	87 e5       	ldi	r24, 0x57	; 87
    ca62:	80 93 b3 06 	sts	0x06B3, r24
					SMS_FlgSz_Out = 0;
    ca66:	10 92 82 07 	sts	0x0782, r1
    ca6a:	9f cc       	rjmp	.-1730   	; 0xc3aa <GSM_Cycle+0x40>
				counter=1;

			}
			#endif	

			if(GetStringFromFIFO()){
    ca6c:	0e 94 eb 38 	call	0x71d6	; 0x71d6 <GetStringFromFIFO>
    ca70:	88 23       	and	r24, r24
    ca72:	09 f4       	brne	.+2      	; 0xca76 <GSM_Cycle+0x70c>
    ca74:	9a cc       	rjmp	.-1740   	; 0xc3aa <GSM_Cycle+0x40>
				GSM_State = GSM_AnalyzeURC;
    ca76:	8f e3       	ldi	r24, 0x3F	; 63
    ca78:	80 93 b3 06 	sts	0x06B3, r24
				TempNum = 0;
    ca7c:	10 92 da 05 	sts	0x05DA, r1
    ca80:	94 cc       	rjmp	.-1752   	; 0xc3aa <GSM_Cycle+0x40>
			GSM_SendFirstChar();
			GSM_State = GSM_WAIT_PLAY_CONFIRM_FILE_OK;
			StartTimer16(TD_GSM, 2000);
			break;
		case GSM_WAIT_PLAY_CONFIRM_FILE_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_WAIT_PLAY_CONFIRM_FILE_OK)) 
    ca82:	81 ef       	ldi	r24, 0xF1	; 241
    ca84:	93 e0       	ldi	r25, 0x03	; 3
    ca86:	6e e1       	ldi	r22, 0x1E	; 30
    ca88:	0e 94 c4 4a 	call	0x9588	; 0x9588 <GSM_Wait_Response_P>
    ca8c:	88 23       	and	r24, r24
    ca8e:	09 f4       	brne	.+2      	; 0xca92 <GSM_Cycle+0x728>
    ca90:	8c cc       	rjmp	.-1768   	; 0xc3aa <GSM_Cycle+0x40>
				{
					GSM_State = GSM_WAIT_PLAY_CONFIRM_FILE_CREC_0;
    ca92:	8f e1       	ldi	r24, 0x1F	; 31
    ca94:	80 93 b3 06 	sts	0x06B3, r24
					StartTimer16(TD_GSM, 20000);
    ca98:	80 91 e7 04 	lds	r24, 0x04E7
    ca9c:	60 e2       	ldi	r22, 0x20	; 32
    ca9e:	7e e4       	ldi	r23, 0x4E	; 78
    caa0:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
    caa4:	82 cc       	rjmp	.-1788   	; 0xc3aa <GSM_Cycle+0x40>
			}

			break;

		case GSM_SEND_PLAY_CONFIRM_FILE: 
			ConfirmState = 1;
    caa6:	81 e0       	ldi	r24, 0x01	; 1
    caa8:	80 93 e1 02 	sts	0x02E1, r24
			sprintf_P(GSM_TxStr, PSTR("AT+CREC=4,\"C:\\User\\Confirm.amr\",0,100\r"));
    caac:	00 d0       	rcall	.+0      	; 0xcaae <GSM_Cycle+0x744>
    caae:	0f 92       	push	r0
    cab0:	82 e0       	ldi	r24, 0x02	; 2
    cab2:	9a e0       	ldi	r25, 0x0A	; 10
    cab4:	ed b7       	in	r30, 0x3d	; 61
    cab6:	fe b7       	in	r31, 0x3e	; 62
    cab8:	92 83       	std	Z+2, r25	; 0x02
    caba:	81 83       	std	Z+1, r24	; 0x01
    cabc:	8e e6       	ldi	r24, 0x6E	; 110
    cabe:	9c e2       	ldi	r25, 0x2C	; 44
    cac0:	94 83       	std	Z+4, r25	; 0x04
    cac2:	83 83       	std	Z+3, r24	; 0x03
    cac4:	0e 94 ea 80 	call	0x101d4	; 0x101d4 <sprintf_P>
			GSMTxSz=38;
    cac8:	86 e2       	ldi	r24, 0x26	; 38
    caca:	80 93 75 07 	sts	0x0775, r24
			GSM_SendFirstChar();
    cace:	0f 90       	pop	r0
    cad0:	0f 90       	pop	r0
    cad2:	0f 90       	pop	r0
    cad4:	0f 90       	pop	r0
    cad6:	0e 94 15 3a 	call	0x742a	; 0x742a <GSM_SendFirstChar>
			GSM_State = GSM_WAIT_PLAY_CONFIRM_FILE_OK;
    cada:	8e e1       	ldi	r24, 0x1E	; 30
    cadc:	80 93 b3 06 	sts	0x06B3, r24
			StartTimer16(TD_GSM, 2000);
    cae0:	80 91 e7 04 	lds	r24, 0x04E7
    cae4:	60 ed       	ldi	r22, 0xD0	; 208
    cae6:	77 e0       	ldi	r23, 0x07	; 7
    cae8:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
    caec:	5e cc       	rjmp	.-1860   	; 0xc3aa <GSM_Cycle+0x40>
			GSM_State = GSM_WAIT_CREC_0;
			StartTimer16(TD_GSM, 1000);
			GSM_SendFirstChar();
			break;
		case GSM_WAIT_CREC_0:
			if(GetStringFromFIFO()){
    caee:	0e 94 eb 38 	call	0x71d6	; 0x71d6 <GetStringFromFIFO>
    caf2:	88 23       	and	r24, r24
    caf4:	09 f4       	brne	.+2      	; 0xcaf8 <GSM_Cycle+0x78e>
    caf6:	8c c6       	rjmp	.+3352   	; 0xd810 <GSM_Cycle+0x14a6>
				if((strstr_P(GSM_RxStr, PSTR("+CREC: 0")) != NULL) ){
    caf8:	89 e9       	ldi	r24, 0x99	; 153
    cafa:	97 e0       	ldi	r25, 0x07	; 7
    cafc:	65 e9       	ldi	r22, 0x95	; 149
    cafe:	7c e2       	ldi	r23, 0x2C	; 44
    cb00:	0e 94 ef 7f 	call	0xffde	; 0xffde <strstr_P>
    cb04:	89 2b       	or	r24, r25
    cb06:	09 f4       	brne	.+2      	; 0xcb0a <GSM_Cycle+0x7a0>
    cb08:	83 c6       	rjmp	.+3334   	; 0xd810 <GSM_Cycle+0x14a6>
					GSM_State = GSM_SEND_PLAY_CONFIRM_FILE;
    cb0a:	8d e1       	ldi	r24, 0x1D	; 29
    cb0c:	80 93 b3 06 	sts	0x06B3, r24
    cb10:	4c cc       	rjmp	.-1896   	; 0xc3aa <GSM_Cycle+0x40>
				}
			}

			break;
		case GSM_SEND_CREC_5:
			sprintf_P(GSM_TxStr, PSTR("AT+CREC=5\r"));
    cb12:	00 d0       	rcall	.+0      	; 0xcb14 <GSM_Cycle+0x7aa>
    cb14:	0f 92       	push	r0
    cb16:	82 e0       	ldi	r24, 0x02	; 2
    cb18:	9a e0       	ldi	r25, 0x0A	; 10
    cb1a:	ad b7       	in	r26, 0x3d	; 61
    cb1c:	be b7       	in	r27, 0x3e	; 62
    cb1e:	12 96       	adiw	r26, 0x02	; 2
    cb20:	9c 93       	st	X, r25
    cb22:	8e 93       	st	-X, r24
    cb24:	11 97       	sbiw	r26, 0x01	; 1
    cb26:	8e e9       	ldi	r24, 0x9E	; 158
    cb28:	9c e2       	ldi	r25, 0x2C	; 44
    cb2a:	14 96       	adiw	r26, 0x04	; 4
    cb2c:	9c 93       	st	X, r25
    cb2e:	8e 93       	st	-X, r24
    cb30:	13 97       	sbiw	r26, 0x03	; 3
    cb32:	0e 94 ea 80 	call	0x101d4	; 0x101d4 <sprintf_P>
			GSMTxSz=10;
    cb36:	8a e0       	ldi	r24, 0x0A	; 10
    cb38:	80 93 75 07 	sts	0x0775, r24
			GSM_State = GSM_WAIT_CREC_0;
    cb3c:	8c e1       	ldi	r24, 0x1C	; 28
    cb3e:	80 93 b3 06 	sts	0x06B3, r24
			StartTimer16(TD_GSM, 1000);
    cb42:	0f 90       	pop	r0
    cb44:	0f 90       	pop	r0
    cb46:	0f 90       	pop	r0
    cb48:	0f 90       	pop	r0
    cb4a:	80 91 e7 04 	lds	r24, 0x04E7
    cb4e:	68 ee       	ldi	r22, 0xE8	; 232
    cb50:	73 e0       	ldi	r23, 0x03	; 3
    cb52:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
			GSM_SendFirstChar();
    cb56:	0e 94 15 3a 	call	0x742a	; 0x742a <GSM_SendFirstChar>
    cb5a:	27 cc       	rjmp	.-1970   	; 0xc3aa <GSM_Cycle+0x40>
			if(Timer16Stopp(TD_GSM)){
				GSM_State = GSM_WAIT_MESSAGE;
			}
			break;
		case GSM_WAIT_CONFIRMRESPONSE:
			if(GetStringFromFIFO()){
    cb5c:	0e 94 eb 38 	call	0x71d6	; 0x71d6 <GetStringFromFIFO>
    cb60:	88 23       	and	r24, r24
    cb62:	11 f0       	breq	.+4      	; 0xcb68 <GSM_Cycle+0x7fe>
    cb64:	0c 94 68 6e 	jmp	0xdcd0	; 0xdcd0 <GSM_Cycle+0x1966>
						StartTimer16(TD_GSM,2000);
						GSM_State = GSM_WAIT_DISCONNECT_CAUSE;
						
					}
			}
			if(Timer16Stopp(TD_GSM)){
    cb68:	80 91 e7 04 	lds	r24, 0x04E7
    cb6c:	0e 94 71 1c 	call	0x38e2	; 0x38e2 <Timer16Stopp>
    cb70:	88 23       	and	r24, r24
    cb72:	09 f4       	brne	.+2      	; 0xcb76 <GSM_Cycle+0x80c>
    cb74:	1a cc       	rjmp	.-1996   	; 0xc3aa <GSM_Cycle+0x40>
				if(RequestRepeatCounter<4){
    cb76:	80 91 e2 02 	lds	r24, 0x02E2
    cb7a:	84 30       	cpi	r24, 0x04	; 4
    cb7c:	10 f0       	brcs	.+4      	; 0xcb82 <GSM_Cycle+0x818>
    cb7e:	0c 94 8d 6e 	jmp	0xdd1a	; 0xdd1a <GSM_Cycle+0x19b0>
				GSM_State = GSM_SEND_PLAY_ALARM_FILE;
    cb82:	84 e1       	ldi	r24, 0x14	; 20
    cb84:	80 93 b3 06 	sts	0x06B3, r24
    cb88:	10 cc       	rjmp	.-2016   	; 0xc3aa <GSM_Cycle+0x40>
					GSM_State = GSM_WAIT_PLAY_CONFIRMREQUEST_FILE_CREC_0;
					StartTimer16(TD_GSM, 20000);
				}
			break;
		case GSM_WAIT_PLAY_CONFIRMREQUEST_FILE_CREC_0:
			if(GetStringFromFIFO()){
    cb8a:	0e 94 eb 38 	call	0x71d6	; 0x71d6 <GetStringFromFIFO>
    cb8e:	88 23       	and	r24, r24
    cb90:	09 f4       	brne	.+2      	; 0xcb94 <GSM_Cycle+0x82a>
    cb92:	90 c6       	rjmp	.+3360   	; 0xd8b4 <GSM_Cycle+0x154a>
				if((strstr_P(GSM_RxStr, PSTR("+CREC: 0")) != NULL) ){
    cb94:	89 e9       	ldi	r24, 0x99	; 153
    cb96:	97 e0       	ldi	r25, 0x07	; 7
    cb98:	69 ed       	ldi	r22, 0xD9	; 217
    cb9a:	7c e2       	ldi	r23, 0x2C	; 44
    cb9c:	0e 94 ef 7f 	call	0xffde	; 0xffde <strstr_P>
    cba0:	89 2b       	or	r24, r25
    cba2:	09 f4       	brne	.+2      	; 0xcba6 <GSM_Cycle+0x83c>
    cba4:	81 c6       	rjmp	.+3330   	; 0xd8a8 <GSM_Cycle+0x153e>
					GSM_State = GSM_WAIT_CONFIRMRESPONSE;
    cba6:	8a e1       	ldi	r24, 0x1A	; 26
    cba8:	80 93 b3 06 	sts	0x06B3, r24
					StartTimer16(TD_GSM, 200);
    cbac:	80 91 e7 04 	lds	r24, 0x04E7
    cbb0:	68 ec       	ldi	r22, 0xC8	; 200
    cbb2:	70 e0       	ldi	r23, 0x00	; 0
    cbb4:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
    cbb8:	f8 cb       	rjmp	.-2064   	; 0xc3aa <GSM_Cycle+0x40>
			GSM_SendFirstChar();
			GSM_State = GSM_WAIT_PLAY_CONFIRMREQUEST_FILE_OK;
			StartTimer16(TD_GSM, 1000);
			break;
		case GSM_WAIT_PLAY_CONFIRMREQUEST_FILE_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_WAIT_MESSAGE)) 
    cbba:	81 ef       	ldi	r24, 0xF1	; 241
    cbbc:	93 e0       	ldi	r25, 0x03	; 3
    cbbe:	6e e0       	ldi	r22, 0x0E	; 14
    cbc0:	0e 94 c4 4a 	call	0x9588	; 0x9588 <GSM_Wait_Response_P>
    cbc4:	88 23       	and	r24, r24
    cbc6:	09 f4       	brne	.+2      	; 0xcbca <GSM_Cycle+0x860>
    cbc8:	f0 cb       	rjmp	.-2080   	; 0xc3aa <GSM_Cycle+0x40>
				{
					GSM_State = GSM_WAIT_PLAY_CONFIRMREQUEST_FILE_CREC_0;
    cbca:	89 e1       	ldi	r24, 0x19	; 25
    cbcc:	80 93 b3 06 	sts	0x06B3, r24
					StartTimer16(TD_GSM, 20000);
    cbd0:	80 91 e7 04 	lds	r24, 0x04E7
    cbd4:	60 e2       	ldi	r22, 0x20	; 32
    cbd6:	7e e4       	ldi	r23, 0x4E	; 78
    cbd8:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
    cbdc:	e6 cb       	rjmp	.-2100   	; 0xc3aa <GSM_Cycle+0x40>
			if(Timer16Stopp(TD_GSM)){
				GSM_State = GSM_WAIT_MESSAGE;
			}
			break;
		case GSM_SEND_PLAY_CONFIRMREQUEST_FILE: 
			sprintf_P(GSM_TxStr, PSTR("AT+CREC=4,\"C:\\User\\ConfirmRequest.amr\",0,100\r"));
    cbde:	00 d0       	rcall	.+0      	; 0xcbe0 <GSM_Cycle+0x876>
    cbe0:	0f 92       	push	r0
    cbe2:	82 e0       	ldi	r24, 0x02	; 2
    cbe4:	9a e0       	ldi	r25, 0x0A	; 10
    cbe6:	ed b7       	in	r30, 0x3d	; 61
    cbe8:	fe b7       	in	r31, 0x3e	; 62
    cbea:	92 83       	std	Z+2, r25	; 0x02
    cbec:	81 83       	std	Z+1, r24	; 0x01
    cbee:	82 ee       	ldi	r24, 0xE2	; 226
    cbf0:	9c e2       	ldi	r25, 0x2C	; 44
    cbf2:	94 83       	std	Z+4, r25	; 0x04
    cbf4:	83 83       	std	Z+3, r24	; 0x03
    cbf6:	0e 94 ea 80 	call	0x101d4	; 0x101d4 <sprintf_P>
			GSMTxSz=45;
    cbfa:	8d e2       	ldi	r24, 0x2D	; 45
    cbfc:	80 93 75 07 	sts	0x0775, r24
			GSM_SendFirstChar();
    cc00:	0f 90       	pop	r0
    cc02:	0f 90       	pop	r0
    cc04:	0f 90       	pop	r0
    cc06:	0f 90       	pop	r0
    cc08:	0e 94 15 3a 	call	0x742a	; 0x742a <GSM_SendFirstChar>
			GSM_State = GSM_WAIT_PLAY_CONFIRMREQUEST_FILE_OK;
    cc0c:	88 e1       	ldi	r24, 0x18	; 24
    cc0e:	80 93 b3 06 	sts	0x06B3, r24
			StartTimer16(TD_GSM, 1000);
    cc12:	80 91 e7 04 	lds	r24, 0x04E7
    cc16:	68 ee       	ldi	r22, 0xE8	; 232
    cc18:	73 e0       	ldi	r23, 0x03	; 3
    cc1a:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
    cc1e:	c5 cb       	rjmp	.-2166   	; 0xc3aa <GSM_Cycle+0x40>
					GSM_State = GSM_WAIT_PLAY_ALARM_FILE_CREC_0;
					StartTimer16(TD_GSM, 20000);
				}
			break;
		case GSM_WAIT_PLAY_ALARM_FILE_CREC_0:
			if(GetStringFromFIFO()){
    cc20:	0e 94 eb 38 	call	0x71d6	; 0x71d6 <GetStringFromFIFO>
    cc24:	88 23       	and	r24, r24
    cc26:	09 f4       	brne	.+2      	; 0xcc2a <GSM_Cycle+0x8c0>
    cc28:	58 c6       	rjmp	.+3248   	; 0xd8da <GSM_Cycle+0x1570>
				if((strstr_P(GSM_RxStr, PSTR("+CREC: 0")) != NULL) ){
    cc2a:	89 e9       	ldi	r24, 0x99	; 153
    cc2c:	97 e0       	ldi	r25, 0x07	; 7
    cc2e:	60 e1       	ldi	r22, 0x10	; 16
    cc30:	7d e2       	ldi	r23, 0x2D	; 45
    cc32:	0e 94 ef 7f 	call	0xffde	; 0xffde <strstr_P>
    cc36:	89 2b       	or	r24, r25
    cc38:	09 f4       	brne	.+2      	; 0xcc3c <GSM_Cycle+0x8d2>
    cc3a:	49 c6       	rjmp	.+3218   	; 0xd8ce <GSM_Cycle+0x1564>
					GSM_State = GSM_SEND_PLAY_CONFIRMREQUEST_FILE;
    cc3c:	87 e1       	ldi	r24, 0x17	; 23
    cc3e:	80 93 b3 06 	sts	0x06B3, r24
    cc42:	b3 cb       	rjmp	.-2202   	; 0xc3aa <GSM_Cycle+0x40>
			GSM_SendFirstChar();
			GSM_State = GSM_WAIT_PLAY_ALARM_FILE_OK;
			StartTimer16(TD_GSM, 1000);
			break;
		case GSM_WAIT_PLAY_ALARM_FILE_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_WAIT_MESSAGE)) 
    cc44:	81 ef       	ldi	r24, 0xF1	; 241
    cc46:	93 e0       	ldi	r25, 0x03	; 3
    cc48:	6e e0       	ldi	r22, 0x0E	; 14
    cc4a:	0e 94 c4 4a 	call	0x9588	; 0x9588 <GSM_Wait_Response_P>
    cc4e:	88 23       	and	r24, r24
    cc50:	09 f4       	brne	.+2      	; 0xcc54 <GSM_Cycle+0x8ea>
    cc52:	ab cb       	rjmp	.-2218   	; 0xc3aa <GSM_Cycle+0x40>
				{
					GSM_State = GSM_WAIT_PLAY_ALARM_FILE_CREC_0;
    cc54:	86 e1       	ldi	r24, 0x16	; 22
    cc56:	80 93 b3 06 	sts	0x06B3, r24
					StartTimer16(TD_GSM, 20000);
    cc5a:	80 91 e7 04 	lds	r24, 0x04E7
    cc5e:	60 e2       	ldi	r22, 0x20	; 32
    cc60:	7e e4       	ldi	r23, 0x4E	; 78
    cc62:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
    cc66:	a1 cb       	rjmp	.-2238   	; 0xc3aa <GSM_Cycle+0x40>
			if(Timer16Stopp(TD_GSM)){
				GSM_State = GSM_WAIT_MESSAGE;
			}
			break;
		case GSM_WAIT_CCLC_3:
			if(GetStringFromFIFO()){
    cc68:	0e 94 eb 38 	call	0x71d6	; 0x71d6 <GetStringFromFIFO>
    cc6c:	88 23       	and	r24, r24
    cc6e:	09 f4       	brne	.+2      	; 0xcc72 <GSM_Cycle+0x908>
    cc70:	72 c6       	rjmp	.+3300   	; 0xd956 <GSM_Cycle+0x15ec>
				if( (strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 2,0,6,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 3,0,6,")) != NULL) ){
    cc72:	89 e9       	ldi	r24, 0x99	; 153
    cc74:	97 e0       	ldi	r25, 0x07	; 7
    cc76:	69 ed       	ldi	r22, 0xD9	; 217
    cc78:	7d e2       	ldi	r23, 0x2D	; 45
    cc7a:	0e 94 ef 7f 	call	0xffde	; 0xffde <strstr_P>
    cc7e:	89 2b       	or	r24, r25
    cc80:	11 f4       	brne	.+4      	; 0xcc86 <GSM_Cycle+0x91c>
    cc82:	0c 94 51 6f 	jmp	0xdea2	; 0xdea2 <GSM_Cycle+0x1b38>
					StartTimer16(TD_GSM, 6000);
    cc86:	80 91 e7 04 	lds	r24, 0x04E7
    cc8a:	60 e7       	ldi	r22, 0x70	; 112
    cc8c:	77 e1       	ldi	r23, 0x17	; 23
    cc8e:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
					GSM_State = GSM_WAIT_MESSAGE;
    cc92:	8e e0       	ldi	r24, 0x0E	; 14
    cc94:	80 93 b3 06 	sts	0x06B3, r24
    cc98:	88 cb       	rjmp	.-2288   	; 0xc3aa <GSM_Cycle+0x40>
		case GSM_WAIT_ATD_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_WAIT_MESSAGE)) GSM_State = GSM_WAIT_CCLC_2;
			StartTimer16(TD_GSM, 1000);
			break;
		case GSM_WAIT_CCLC_2:
			if(GetStringFromFIFO()){
    cc9a:	0e 94 eb 38 	call	0x71d6	; 0x71d6 <GetStringFromFIFO>
    cc9e:	88 23       	and	r24, r24
    cca0:	09 f4       	brne	.+2      	; 0xcca4 <GSM_Cycle+0x93a>
    cca2:	3a c6       	rjmp	.+3188   	; 0xd918 <GSM_Cycle+0x15ae>
				if( (strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,2,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 2,0,2,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 3,0,2,")) != NULL) ){
    cca4:	89 e9       	ldi	r24, 0x99	; 153
    cca6:	97 e0       	ldi	r25, 0x07	; 7
    cca8:	63 e0       	ldi	r22, 0x03	; 3
    ccaa:	7e e2       	ldi	r23, 0x2E	; 46
    ccac:	0e 94 ef 7f 	call	0xffde	; 0xffde <strstr_P>
    ccb0:	89 2b       	or	r24, r25
    ccb2:	09 f4       	brne	.+2      	; 0xccb6 <GSM_Cycle+0x94c>
    ccb4:	1f c6       	rjmp	.+3134   	; 0xd8f4 <GSM_Cycle+0x158a>
					StartTimer16(TD_GSM, 2000);
    ccb6:	80 91 e7 04 	lds	r24, 0x04E7
    ccba:	60 ed       	ldi	r22, 0xD0	; 208
    ccbc:	77 e0       	ldi	r23, 0x07	; 7
    ccbe:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
					GSM_State = GSM_WAIT_CCLC_3;
    ccc2:	82 e1       	ldi	r24, 0x12	; 18
    ccc4:	80 93 b3 06 	sts	0x06B3, r24
    ccc8:	70 cb       	rjmp	.-2336   	; 0xc3aa <GSM_Cycle+0x40>
			if(Timer16Stopp(TD_GSM)){
				GSM_State = GSM_WAIT_MESSAGE;
			}
			break;
		case GSM_SEND_PLAY_ALARM_FILE: 
			RequestRepeatCounter++;
    ccca:	80 91 e2 02 	lds	r24, 0x02E2
    ccce:	8f 5f       	subi	r24, 0xFF	; 255
    ccd0:	80 93 e2 02 	sts	0x02E2, r24
			sprintf_P(GSM_TxStr, PSTR("AT+CREC=4,\"C:\\User\\Alarm"));
    ccd4:	00 d0       	rcall	.+0      	; 0xccd6 <GSM_Cycle+0x96c>
    ccd6:	0f 92       	push	r0
    ccd8:	b2 e0       	ldi	r27, 0x02	; 2
    ccda:	eb 2e       	mov	r14, r27
    ccdc:	ba e0       	ldi	r27, 0x0A	; 10
    ccde:	fb 2e       	mov	r15, r27
    cce0:	ad b7       	in	r26, 0x3d	; 61
    cce2:	be b7       	in	r27, 0x3e	; 62
    cce4:	12 96       	adiw	r26, 0x02	; 2
    cce6:	fc 92       	st	X, r15
    cce8:	ee 92       	st	-X, r14
    ccea:	11 97       	sbiw	r26, 0x01	; 1
    ccec:	86 e2       	ldi	r24, 0x26	; 38
    ccee:	9d e2       	ldi	r25, 0x2D	; 45
    ccf0:	14 96       	adiw	r26, 0x04	; 4
    ccf2:	9c 93       	st	X, r25
    ccf4:	8e 93       	st	-X, r24
    ccf6:	13 97       	sbiw	r26, 0x03	; 3
    ccf8:	0e 94 ea 80 	call	0x101d4	; 0x101d4 <sprintf_P>
			GSMTxSz=24;
    ccfc:	88 e1       	ldi	r24, 0x18	; 24
    ccfe:	80 93 75 07 	sts	0x0775, r24
			sprintf(GSM_TxStr+GSMTxSz,"%u",Message[2]);
    cd02:	80 91 75 07 	lds	r24, 0x0775
    cd06:	0f 92       	push	r0
    cd08:	0f 92       	push	r0
    cd0a:	ed b7       	in	r30, 0x3d	; 61
    cd0c:	fe b7       	in	r31, 0x3e	; 62
    cd0e:	31 96       	adiw	r30, 0x01	; 1
    cd10:	90 e0       	ldi	r25, 0x00	; 0
    cd12:	8e 0d       	add	r24, r14
    cd14:	9f 1d       	adc	r25, r15
    cd16:	ad b7       	in	r26, 0x3d	; 61
    cd18:	be b7       	in	r27, 0x3e	; 62
    cd1a:	12 96       	adiw	r26, 0x02	; 2
    cd1c:	9c 93       	st	X, r25
    cd1e:	8e 93       	st	-X, r24
    cd20:	11 97       	sbiw	r26, 0x01	; 1
    cd22:	82 eb       	ldi	r24, 0xB2	; 178
    cd24:	92 e0       	ldi	r25, 0x02	; 2
    cd26:	93 83       	std	Z+3, r25	; 0x03
    cd28:	82 83       	std	Z+2, r24	; 0x02
    cd2a:	80 91 f4 06 	lds	r24, 0x06F4
    cd2e:	84 83       	std	Z+4, r24	; 0x04
    cd30:	15 82       	std	Z+5, r1	; 0x05
    cd32:	0e 94 b9 80 	call	0x10172	; 0x10172 <sprintf>
			if(Message[2]>9){
    cd36:	ed b7       	in	r30, 0x3d	; 61
    cd38:	fe b7       	in	r31, 0x3e	; 62
    cd3a:	36 96       	adiw	r30, 0x06	; 6
    cd3c:	0f b6       	in	r0, 0x3f	; 63
    cd3e:	f8 94       	cli
    cd40:	fe bf       	out	0x3e, r31	; 62
    cd42:	0f be       	out	0x3f, r0	; 63
    cd44:	ed bf       	out	0x3d, r30	; 61
    cd46:	80 91 f4 06 	lds	r24, 0x06F4
    cd4a:	8a 30       	cpi	r24, 0x0A	; 10
    cd4c:	08 f4       	brcc	.+2      	; 0xcd50 <GSM_Cycle+0x9e6>
    cd4e:	47 c6       	rjmp	.+3214   	; 0xd9de <GSM_Cycle+0x1674>
				GSMTxSz+=2;
    cd50:	80 91 75 07 	lds	r24, 0x0775
    cd54:	8e 5f       	subi	r24, 0xFE	; 254
    cd56:	80 93 75 07 	sts	0x0775, r24
			}
			else{
				GSMTxSz++;
			};
			sprintf_P(GSM_TxStr+GSMTxSz, PSTR(".amr\",0,100\r"));
    cd5a:	80 91 75 07 	lds	r24, 0x0775
    cd5e:	00 d0       	rcall	.+0      	; 0xcd60 <GSM_Cycle+0x9f6>
    cd60:	0f 92       	push	r0
    cd62:	90 e0       	ldi	r25, 0x00	; 0
    cd64:	8e 5f       	subi	r24, 0xFE	; 254
    cd66:	95 4f       	sbci	r25, 0xF5	; 245
    cd68:	ad b7       	in	r26, 0x3d	; 61
    cd6a:	be b7       	in	r27, 0x3e	; 62
    cd6c:	12 96       	adiw	r26, 0x02	; 2
    cd6e:	9c 93       	st	X, r25
    cd70:	8e 93       	st	-X, r24
    cd72:	11 97       	sbiw	r26, 0x01	; 1
    cd74:	89 e1       	ldi	r24, 0x19	; 25
    cd76:	9d e2       	ldi	r25, 0x2D	; 45
    cd78:	14 96       	adiw	r26, 0x04	; 4
    cd7a:	9c 93       	st	X, r25
    cd7c:	8e 93       	st	-X, r24
    cd7e:	13 97       	sbiw	r26, 0x03	; 3
    cd80:	0e 94 ea 80 	call	0x101d4	; 0x101d4 <sprintf_P>
			GSMTxSz += 12;
    cd84:	80 91 75 07 	lds	r24, 0x0775
    cd88:	84 5f       	subi	r24, 0xF4	; 244
    cd8a:	80 93 75 07 	sts	0x0775, r24
			GSM_SendFirstChar();
    cd8e:	0f 90       	pop	r0
    cd90:	0f 90       	pop	r0
    cd92:	0f 90       	pop	r0
    cd94:	0f 90       	pop	r0
    cd96:	0e 94 15 3a 	call	0x742a	; 0x742a <GSM_SendFirstChar>
			GSM_State = GSM_WAIT_PLAY_ALARM_FILE_OK;
    cd9a:	85 e1       	ldi	r24, 0x15	; 21
    cd9c:	80 93 b3 06 	sts	0x06B3, r24
			StartTimer16(TD_GSM, 1000);
    cda0:	80 91 e7 04 	lds	r24, 0x04E7
    cda4:	68 ee       	ldi	r22, 0xE8	; 232
    cda6:	73 e0       	ldi	r23, 0x03	; 3
    cda8:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
    cdac:	fe ca       	rjmp	.-2564   	; 0xc3aa <GSM_Cycle+0x40>
			if(Timer16Stopp(TD_GSM)){
				GSM_State = GSM_WAIT_MESSAGE;
			}
			break;
		case GSM_WAIT_CCLC_0:
			if(GetStringFromFIFO()){
    cdae:	0e 94 eb 38 	call	0x71d6	; 0x71d6 <GetStringFromFIFO>
    cdb2:	88 23       	and	r24, r24
    cdb4:	09 f4       	brne	.+2      	; 0xcdb8 <GSM_Cycle+0xa4e>
    cdb6:	ee c5       	rjmp	.+3036   	; 0xd994 <GSM_Cycle+0x162a>
				if((strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,0,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,0,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,0,")) != NULL) ){
    cdb8:	89 e9       	ldi	r24, 0x99	; 153
    cdba:	97 e0       	ldi	r25, 0x07	; 7
    cdbc:	65 e8       	ldi	r22, 0x85	; 133
    cdbe:	7d e2       	ldi	r23, 0x2D	; 45
    cdc0:	0e 94 ef 7f 	call	0xffde	; 0xffde <strstr_P>
    cdc4:	89 2b       	or	r24, r25
    cdc6:	11 f4       	brne	.+4      	; 0xcdcc <GSM_Cycle+0xa62>
    cdc8:	0c 94 87 6f 	jmp	0xdf0e	; 0xdf0e <GSM_Cycle+0x1ba4>
					RequestRepeatCounter = 0;
    cdcc:	10 92 e2 02 	sts	0x02E2, r1
					GSM_State = GSM_SEND_PLAY_ALARM_FILE;
    cdd0:	84 e1       	ldi	r24, 0x14	; 20
    cdd2:	80 93 b3 06 	sts	0x06B3, r24
    cdd6:	e9 ca       	rjmp	.-2606   	; 0xc3aa <GSM_Cycle+0x40>
			GSM_SendFirstChar();
			GSM_State = GSM_WAIT_ATD_OK;
			StartTimer16(TD_GSM, 1000);
			break;
		case GSM_WAIT_ATD_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_WAIT_MESSAGE)) GSM_State = GSM_WAIT_CCLC_2;
    cdd8:	81 ef       	ldi	r24, 0xF1	; 241
    cdda:	93 e0       	ldi	r25, 0x03	; 3
    cddc:	6e e0       	ldi	r22, 0x0E	; 14
    cdde:	0e 94 c4 4a 	call	0x9588	; 0x9588 <GSM_Wait_Response_P>
    cde2:	88 23       	and	r24, r24
    cde4:	19 f0       	breq	.+6      	; 0xcdec <GSM_Cycle+0xa82>
    cde6:	81 e1       	ldi	r24, 0x11	; 17
    cde8:	80 93 b3 06 	sts	0x06B3, r24
			StartTimer16(TD_GSM, 1000);
    cdec:	80 91 e7 04 	lds	r24, 0x04E7
    cdf0:	68 ee       	ldi	r22, 0xE8	; 232
    cdf2:	73 e0       	ldi	r23, 0x03	; 3
    cdf4:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
    cdf8:	d8 ca       	rjmp	.-2640   	; 0xc3aa <GSM_Cycle+0x40>
				ConfirmState = 0;
				GSM_State = GSM_SEND_ATD;
			}
			break;
		case GSM_SEND_ATD:
			sprintf_P(GSM_TxStr, ATD_PLUS);	GSMTxSz = strlen_P(ATD_PLUS);
    cdfa:	00 d0       	rcall	.+0      	; 0xcdfc <GSM_Cycle+0xa92>
    cdfc:	0f 92       	push	r0
    cdfe:	82 e0       	ldi	r24, 0x02	; 2
    ce00:	9a e0       	ldi	r25, 0x0A	; 10
    ce02:	ad b7       	in	r26, 0x3d	; 61
    ce04:	be b7       	in	r27, 0x3e	; 62
    ce06:	12 96       	adiw	r26, 0x02	; 2
    ce08:	9c 93       	st	X, r25
    ce0a:	8e 93       	st	-X, r24
    ce0c:	11 97       	sbiw	r26, 0x01	; 1
    ce0e:	02 ec       	ldi	r16, 0xC2	; 194
    ce10:	14 e0       	ldi	r17, 0x04	; 4
    ce12:	14 96       	adiw	r26, 0x04	; 4
    ce14:	1c 93       	st	X, r17
    ce16:	0e 93       	st	-X, r16
    ce18:	13 97       	sbiw	r26, 0x03	; 3
    ce1a:	0e 94 ea 80 	call	0x101d4	; 0x101d4 <sprintf_P>
    ce1e:	0f 90       	pop	r0
    ce20:	0f 90       	pop	r0
    ce22:	0f 90       	pop	r0
    ce24:	0f 90       	pop	r0
    ce26:	c8 01       	movw	r24, r16
    ce28:	0e 94 cd 7f 	call	0xff9a	; 0xff9a <strlen_P>
    ce2c:	80 93 75 07 	sts	0x0775, r24
			erbl(GSM_TxStr+GSMTxSz, CALL_Number+Message[1], MaxTelephN);
    ce30:	80 91 75 07 	lds	r24, 0x0775
    ce34:	90 e0       	ldi	r25, 0x00	; 0
    ce36:	60 91 f3 06 	lds	r22, 0x06F3
    ce3a:	2d e0       	ldi	r18, 0x0D	; 13
    ce3c:	62 9f       	mul	r22, r18
    ce3e:	b0 01       	movw	r22, r0
    ce40:	11 24       	eor	r1, r1
    ce42:	64 51       	subi	r22, 0x14	; 20
    ce44:	7f 4f       	sbci	r23, 0xFF	; 255
    ce46:	8e 5f       	subi	r24, 0xFE	; 254
    ce48:	95 4f       	sbci	r25, 0xF5	; 245
    ce4a:	4d e0       	ldi	r20, 0x0D	; 13
    ce4c:	50 e0       	ldi	r21, 0x00	; 0
    ce4e:	0e 94 d7 82 	call	0x105ae	; 0x105ae <__eerd_block_m2560>
			GSMTxSz+=MaxTelephN-1;
    ce52:	80 91 75 07 	lds	r24, 0x0775
    ce56:	84 5f       	subi	r24, 0xF4	; 244
    ce58:	80 93 75 07 	sts	0x0775, r24
			const char c=';';
    ce5c:	8b e3       	ldi	r24, 0x3B	; 59
    ce5e:	89 83       	std	Y+1, r24	; 0x01
			sprintf(GSM_TxStr+GSMTxSz,&c);GSMTxSz++;
    ce60:	80 91 75 07 	lds	r24, 0x0775
    ce64:	00 d0       	rcall	.+0      	; 0xce66 <GSM_Cycle+0xafc>
    ce66:	0f 92       	push	r0
    ce68:	90 e0       	ldi	r25, 0x00	; 0
    ce6a:	8e 5f       	subi	r24, 0xFE	; 254
    ce6c:	95 4f       	sbci	r25, 0xF5	; 245
    ce6e:	ed b7       	in	r30, 0x3d	; 61
    ce70:	fe b7       	in	r31, 0x3e	; 62
    ce72:	92 83       	std	Z+2, r25	; 0x02
    ce74:	81 83       	std	Z+1, r24	; 0x01
    ce76:	ce 01       	movw	r24, r28
    ce78:	01 96       	adiw	r24, 0x01	; 1
    ce7a:	94 83       	std	Z+4, r25	; 0x04
    ce7c:	83 83       	std	Z+3, r24	; 0x03
    ce7e:	0e 94 b9 80 	call	0x10172	; 0x10172 <sprintf>
    ce82:	80 91 75 07 	lds	r24, 0x0775
    ce86:	8f 5f       	subi	r24, 0xFF	; 255
    ce88:	80 93 75 07 	sts	0x0775, r24
			sprintf(GSM_TxStr + GSMTxSz, "\r");	GSMTxSz = GSMTxSz+1;
    ce8c:	e0 91 75 07 	lds	r30, 0x0775
    ce90:	f0 e0       	ldi	r31, 0x00	; 0
    ce92:	ee 5f       	subi	r30, 0xFE	; 254
    ce94:	f5 4f       	sbci	r31, 0xF5	; 245
    ce96:	8d e0       	ldi	r24, 0x0D	; 13
    ce98:	90 e0       	ldi	r25, 0x00	; 0
    ce9a:	91 83       	std	Z+1, r25	; 0x01
    ce9c:	80 83       	st	Z, r24
    ce9e:	80 91 75 07 	lds	r24, 0x0775
    cea2:	8f 5f       	subi	r24, 0xFF	; 255
    cea4:	80 93 75 07 	sts	0x0775, r24
			GSM_SendFirstChar();
    cea8:	0f 90       	pop	r0
    ceaa:	0f 90       	pop	r0
    ceac:	0f 90       	pop	r0
    ceae:	0f 90       	pop	r0
    ceb0:	0e 94 15 3a 	call	0x742a	; 0x742a <GSM_SendFirstChar>
			GSM_State = GSM_WAIT_ATD_OK;
    ceb4:	80 e1       	ldi	r24, 0x10	; 16
    ceb6:	80 93 b3 06 	sts	0x06B3, r24
			StartTimer16(TD_GSM, 1000);
    ceba:	80 91 e7 04 	lds	r24, 0x04E7
    cebe:	68 ee       	ldi	r22, 0xE8	; 232
    cec0:	73 e0       	ldi	r23, 0x03	; 3
    cec2:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
    cec6:	71 ca       	rjmp	.-2846   	; 0xc3aa <GSM_Cycle+0x40>
			break;
		case GSM_WAIT_DDET101_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;
		case GSM_WAIT_MESSAGE:
			if(Message[0]==1)
    cec8:	80 91 f2 06 	lds	r24, 0x06F2
    cecc:	81 30       	cpi	r24, 0x01	; 1
    cece:	09 f0       	breq	.+2      	; 0xced2 <GSM_Cycle+0xb68>
    ced0:	6c ca       	rjmp	.-2856   	; 0xc3aa <GSM_Cycle+0x40>
			{
				Message[0]=0;
    ced2:	10 92 f2 06 	sts	0x06F2, r1
				ConfirmState=0;
				ConfirmState = 0;
    ced6:	10 92 e1 02 	sts	0x02E1, r1
				GSM_State = GSM_SEND_ATD;
    ceda:	8f e0       	ldi	r24, 0x0F	; 15
    cedc:	80 93 b3 06 	sts	0x06B3, r24
    cee0:	64 ca       	rjmp	.-2872   	; 0xc3aa <GSM_Cycle+0x40>
			break;
		case GSM_SEND_DDET101:
			GSM_Execute_Command(AT_DDET101,100*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_DDET101_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    cee2:	81 ef       	ldi	r24, 0xF1	; 241
    cee4:	93 e0       	ldi	r25, 0x03	; 3
    cee6:	6a e4       	ldi	r22, 0x4A	; 74
    cee8:	0e 94 c4 4a 	call	0x9588	; 0x9588 <GSM_Wait_Response_P>
    ceec:	88 23       	and	r24, r24
    ceee:	09 f4       	brne	.+2      	; 0xcef2 <GSM_Cycle+0xb88>
    cef0:	5c ca       	rjmp	.-2888   	; 0xc3aa <GSM_Cycle+0x40>
    cef2:	80 91 b3 06 	lds	r24, 0x06B3
    cef6:	8f 5f       	subi	r24, 0xFF	; 255
    cef8:	80 93 b3 06 	sts	0x06B3, r24
    cefc:	56 ca       	rjmp	.-2900   	; 0xc3aa <GSM_Cycle+0x40>
			break;
		case GSM_WAIT_CLCC_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;
		case GSM_SEND_DDET101:
			GSM_Execute_Command(AT_DDET101,100*GSM_DEBUG_DELAY); GSM_State++;
    cefe:	80 e9       	ldi	r24, 0x90	; 144
    cf00:	94 e0       	ldi	r25, 0x04	; 4
    cf02:	64 e6       	ldi	r22, 0x64	; 100
    cf04:	70 e0       	ldi	r23, 0x00	; 0
    cf06:	0e 94 1f 4b 	call	0x963e	; 0x963e <GSM_Execute_Command>
    cf0a:	80 91 b3 06 	lds	r24, 0x06B3
    cf0e:	8f 5f       	subi	r24, 0xFF	; 255
    cf10:	80 93 b3 06 	sts	0x06B3, r24
    cf14:	4a ca       	rjmp	.-2924   	; 0xc3aa <GSM_Cycle+0x40>
			break;
		case GSM_SEND_CLCC1:
			GSM_Execute_Command(AT_CLCC1,100*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CLCC_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    cf16:	81 ef       	ldi	r24, 0xF1	; 241
    cf18:	93 e0       	ldi	r25, 0x03	; 3
    cf1a:	6a e4       	ldi	r22, 0x4A	; 74
    cf1c:	0e 94 c4 4a 	call	0x9588	; 0x9588 <GSM_Wait_Response_P>
    cf20:	88 23       	and	r24, r24
    cf22:	09 f4       	brne	.+2      	; 0xcf26 <GSM_Cycle+0xbbc>
    cf24:	42 ca       	rjmp	.-2940   	; 0xc3aa <GSM_Cycle+0x40>
    cf26:	80 91 b3 06 	lds	r24, 0x06B3
    cf2a:	8f 5f       	subi	r24, 0xFF	; 255
    cf2c:	80 93 b3 06 	sts	0x06B3, r24
    cf30:	3c ca       	rjmp	.-2952   	; 0xc3aa <GSM_Cycle+0x40>
			break;
		case GSM_WAIT_E0_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;
		case GSM_SEND_CLCC1:
			GSM_Execute_Command(AT_CLCC1,100*GSM_DEBUG_DELAY); GSM_State++;
    cf32:	86 e8       	ldi	r24, 0x86	; 134
    cf34:	94 e0       	ldi	r25, 0x04	; 4
    cf36:	64 e6       	ldi	r22, 0x64	; 100
    cf38:	70 e0       	ldi	r23, 0x00	; 0
    cf3a:	0e 94 1f 4b 	call	0x963e	; 0x963e <GSM_Execute_Command>
    cf3e:	80 91 b3 06 	lds	r24, 0x06B3
    cf42:	8f 5f       	subi	r24, 0xFF	; 255
    cf44:	80 93 b3 06 	sts	0x06B3, r24
    cf48:	30 ca       	rjmp	.-2976   	; 0xc3aa <GSM_Cycle+0x40>
		//------------------------
		case GSM_SEND_E0:
			GSM_Execute_Command(AT_E0,100*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_E0_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    cf4a:	81 ef       	ldi	r24, 0xF1	; 241
    cf4c:	93 e0       	ldi	r25, 0x03	; 3
    cf4e:	6a e4       	ldi	r22, 0x4A	; 74
    cf50:	0e 94 c4 4a 	call	0x9588	; 0x9588 <GSM_Wait_Response_P>
    cf54:	88 23       	and	r24, r24
    cf56:	09 f4       	brne	.+2      	; 0xcf5a <GSM_Cycle+0xbf0>
    cf58:	28 ca       	rjmp	.-2992   	; 0xc3aa <GSM_Cycle+0x40>
    cf5a:	80 91 b3 06 	lds	r24, 0x06B3
    cf5e:	8f 5f       	subi	r24, 0xFF	; 255
    cf60:	80 93 b3 06 	sts	0x06B3, r24
    cf64:	22 ca       	rjmp	.-3004   	; 0xc3aa <GSM_Cycle+0x40>
		case GSM_WAIT_SMS_READY:
			if(GSM_Wait_Response_P(URC_SMS_READY, GSM_ReStart1))GSM_State++;
			break;
		//------------------------
		case GSM_SEND_E0:
			GSM_Execute_Command(AT_E0,100*GSM_DEBUG_DELAY); GSM_State++;
    cf66:	81 e8       	ldi	r24, 0x81	; 129
    cf68:	94 e0       	ldi	r25, 0x04	; 4
    cf6a:	64 e6       	ldi	r22, 0x64	; 100
    cf6c:	70 e0       	ldi	r23, 0x00	; 0
    cf6e:	0e 94 1f 4b 	call	0x963e	; 0x963e <GSM_Execute_Command>
    cf72:	80 91 b3 06 	lds	r24, 0x06B3
    cf76:	8f 5f       	subi	r24, 0xFF	; 255
    cf78:	80 93 b3 06 	sts	0x06B3, r24
    cf7c:	16 ca       	rjmp	.-3028   	; 0xc3aa <GSM_Cycle+0x40>
				if(GSM_Modem == SIMCOM_SIM800) GSM_State = GSM_WAIT_SMS_READY;
				else GSM_State = GSM_SEND_E0;
			}
			break;
		case GSM_WAIT_SMS_READY:
			if(GSM_Wait_Response_P(URC_SMS_READY, GSM_ReStart1))GSM_State++;
    cf7e:	8c ea       	ldi	r24, 0xAC	; 172
    cf80:	93 e0       	ldi	r25, 0x03	; 3
    cf82:	6a e4       	ldi	r22, 0x4A	; 74
    cf84:	0e 94 c4 4a 	call	0x9588	; 0x9588 <GSM_Wait_Response_P>
    cf88:	88 23       	and	r24, r24
    cf8a:	09 f4       	brne	.+2      	; 0xcf8e <GSM_Cycle+0xc24>
    cf8c:	0e ca       	rjmp	.-3044   	; 0xc3aa <GSM_Cycle+0x40>
    cf8e:	80 91 b3 06 	lds	r24, 0x06B3
    cf92:	8f 5f       	subi	r24, 0xFF	; 255
    cf94:	80 93 b3 06 	sts	0x06B3, r24
    cf98:	08 ca       	rjmp	.-3056   	; 0xc3aa <GSM_Cycle+0x40>

		case GSM_WAIT_RDY:
			if(GSM_Wait_Response_P(URC_RDY, GSM_ReStart1)) GSM_State++;
			break;
		case GSM_SEND_CGMM:
			GSM_Execute_Command(AT_CGMM,5000*GSM_DEBUG_DELAY); GSM_State++;
    cf9a:	8e e9       	ldi	r24, 0x9E	; 158
    cf9c:	94 e0       	ldi	r25, 0x04	; 4
    cf9e:	68 e8       	ldi	r22, 0x88	; 136
    cfa0:	73 e1       	ldi	r23, 0x13	; 19
    cfa2:	0e 94 1f 4b 	call	0x963e	; 0x963e <GSM_Execute_Command>
    cfa6:	80 91 b3 06 	lds	r24, 0x06B3
    cfaa:	8f 5f       	subi	r24, 0xFF	; 255
    cfac:	80 93 b3 06 	sts	0x06B3, r24
    cfb0:	fc c9       	rjmp	.-3080   	; 0xc3aa <GSM_Cycle+0x40>
			GSM_Modem = NOT_RECOGNIZED;
			GSM_State = GSM_WAIT_RDY;
			break;

		case GSM_WAIT_RDY:
			if(GSM_Wait_Response_P(URC_RDY, GSM_ReStart1)) GSM_State++;
    cfb2:	87 e8       	ldi	r24, 0x87	; 135
    cfb4:	93 e0       	ldi	r25, 0x03	; 3
    cfb6:	6a e4       	ldi	r22, 0x4A	; 74
    cfb8:	0e 94 c4 4a 	call	0x9588	; 0x9588 <GSM_Wait_Response_P>
    cfbc:	88 23       	and	r24, r24
    cfbe:	09 f4       	brne	.+2      	; 0xcfc2 <GSM_Cycle+0xc58>
    cfc0:	f4 c9       	rjmp	.-3096   	; 0xc3aa <GSM_Cycle+0x40>
    cfc2:	80 91 b3 06 	lds	r24, 0x06B3
    cfc6:	8f 5f       	subi	r24, 0xFF	; 255
    cfc8:	80 93 b3 06 	sts	0x06B3, r24
    cfcc:	ee c9       	rjmp	.-3108   	; 0xc3aa <GSM_Cycle+0x40>
inline static void GSM_Auto(){

	switch(GSM_State){

		case GSM_PowerOn:
			StartTimer16(TD_GSM,1000*GSM_DEBUG_DELAY);
    cfce:	80 91 e7 04 	lds	r24, 0x04E7
    cfd2:	68 ee       	ldi	r22, 0xE8	; 232
    cfd4:	73 e0       	ldi	r23, 0x03	; 3
    cfd6:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
			StartTimer32(TD_GSM_Reset, 24UL*60UL*6000);	//    24 
    cfda:	80 91 e9 04 	lds	r24, 0x04E9
    cfde:	40 e0       	ldi	r20, 0x00	; 0
    cfe0:	56 ed       	ldi	r21, 0xD6	; 214
    cfe2:	63 e8       	ldi	r22, 0x83	; 131
    cfe4:	70 e0       	ldi	r23, 0x00	; 0
    cfe6:	0e 94 74 1b 	call	0x36e8	; 0x36e8 <StartTimer32>
			StartTimer32(TD_1hour_resetGPRS_timer, 360000); //     
    cfea:	80 91 eb 04 	lds	r24, 0x04EB
    cfee:	40 e4       	ldi	r20, 0x40	; 64
    cff0:	5e e7       	ldi	r21, 0x7E	; 126
    cff2:	65 e0       	ldi	r22, 0x05	; 5
    cff4:	70 e0       	ldi	r23, 0x00	; 0
    cff6:	0e 94 74 1b 	call	0x36e8	; 0x36e8 <StartTimer32>
			StartTimer16(TD_CheckModem,6000);//      5 	
    cffa:	80 91 ec 04 	lds	r24, 0x04EC
    cffe:	60 e7       	ldi	r22, 0x70	; 112
    d000:	77 e1       	ldi	r23, 0x17	; 23
    d002:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
	}
	void GSM_PWRCNTRL_ON(void){
		cli();
    d006:	f8 94       	cli
		PORTL &= ~(1<<PL5);
    d008:	80 91 0b 01 	lds	r24, 0x010B
    d00c:	8f 7d       	andi	r24, 0xDF	; 223
    d00e:	80 93 0b 01 	sts	0x010B, r24
		sei();
    d012:	78 94       	sei
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    d014:	8f ef       	ldi	r24, 0xFF	; 255
    d016:	80 93 fa 06 	sts	0x06FA, r24
	GSM_RX_FIFO_End = 255;
    d01a:	80 93 51 06 	sts	0x0651, r24
	GSM_RxCharN = 0;
    d01e:	10 92 18 0b 	sts	0x0B18, r1
	GSM_RX_FIFOOverFlow = 0;
    d022:	10 92 cb 08 	sts	0x08CB, r1
	GSM_RX_FIFOMax = 0;
    d026:	10 92 d1 08 	sts	0x08D1, r1
			StartTimer32(TD_GSM_Reset, 24UL*60UL*6000);	//    24 
			StartTimer32(TD_1hour_resetGPRS_timer, 360000); //     
			StartTimer16(TD_CheckModem,6000);//      5 	
			GSM_PWRCNTRL_ON();
			InitFIFO();
			counter=0;
    d02a:	10 92 e0 02 	sts	0x02E0, r1
			GSM_Modem = NOT_RECOGNIZED;
    d02e:	10 92 f1 06 	sts	0x06F1, r1
			GSM_State = GSM_WAIT_RDY;
    d032:	81 e0       	ldi	r24, 0x01	; 1
    d034:	80 93 b3 06 	sts	0x06B3, r24
    d038:	b8 c9       	rjmp	.-3216   	; 0xc3aa <GSM_Cycle+0x40>
		case GSM_WAIT_CPIN_READY:
			if(GSM_Wait_Response_P(URC_CPIN_READY, GSM_ReStart1)) GSM_State++;
			break;

		case GSM_WAIT_CALL_READY:
			if(GSM_Wait_Response_P(URC_CALL_READY, GSM_ReStart1)){
    d03a:	81 ea       	ldi	r24, 0xA1	; 161
    d03c:	93 e0       	ldi	r25, 0x03	; 3
    d03e:	6a e4       	ldi	r22, 0x4A	; 74
    d040:	0e 94 c4 4a 	call	0x9588	; 0x9588 <GSM_Wait_Response_P>
    d044:	88 23       	and	r24, r24
    d046:	09 f4       	brne	.+2      	; 0xd04a <GSM_Cycle+0xce0>
    d048:	b0 c9       	rjmp	.-3232   	; 0xc3aa <GSM_Cycle+0x40>
				if(GSM_Modem == SIMCOM_SIM800) GSM_State = GSM_WAIT_SMS_READY;
    d04a:	80 91 f1 06 	lds	r24, 0x06F1
    d04e:	82 30       	cpi	r24, 0x02	; 2
    d050:	09 f4       	brne	.+2      	; 0xd054 <GSM_Cycle+0xcea>
    d052:	7a c6       	rjmp	.+3316   	; 0xdd48 <GSM_Cycle+0x19de>
				else GSM_State = GSM_SEND_E0;
    d054:	88 e0       	ldi	r24, 0x08	; 8
    d056:	80 93 b3 06 	sts	0x06B3, r24
    d05a:	a7 c9       	rjmp	.-3250   	; 0xc3aa <GSM_Cycle+0x40>
			}
		case GSM_WAIT_CFUN:
			if(GSM_Wait_Response_P(URC_CFUN, GSM_ReStart1)) GSM_State++;
			break;
		case GSM_WAIT_CPIN_READY:
			if(GSM_Wait_Response_P(URC_CPIN_READY, GSM_ReStart1)) GSM_State++;
    d05c:	84 e9       	ldi	r24, 0x94	; 148
    d05e:	93 e0       	ldi	r25, 0x03	; 3
    d060:	6a e4       	ldi	r22, 0x4A	; 74
    d062:	0e 94 c4 4a 	call	0x9588	; 0x9588 <GSM_Wait_Response_P>
    d066:	88 23       	and	r24, r24
    d068:	09 f4       	brne	.+2      	; 0xd06c <GSM_Cycle+0xd02>
    d06a:	9f c9       	rjmp	.-3266   	; 0xc3aa <GSM_Cycle+0x40>
    d06c:	80 91 b3 06 	lds	r24, 0x06B3
    d070:	8f 5f       	subi	r24, 0xFF	; 255
    d072:	80 93 b3 06 	sts	0x06B3, r24
    d076:	99 c9       	rjmp	.-3278   	; 0xc3aa <GSM_Cycle+0x40>
			}
			break;

		//------------------------
		case GSM_WAIT_1:
			GetStringFromFIFO();		//     FIFO
    d078:	0e 94 eb 38 	call	0x71d6	; 0x71d6 <GetStringFromFIFO>
			if(Timer16Stopp(TD_GSM)){
    d07c:	80 91 e7 04 	lds	r24, 0x04E7
    d080:	0e 94 71 1c 	call	0x38e2	; 0x38e2 <Timer16Stopp>
    d084:	88 23       	and	r24, r24
    d086:	09 f4       	brne	.+2      	; 0xd08a <GSM_Cycle+0xd20>
    d088:	90 c9       	rjmp	.-3296   	; 0xc3aa <GSM_Cycle+0x40>
				GSM_State++;
    d08a:	80 91 b3 06 	lds	r24, 0x06B3
    d08e:	8f 5f       	subi	r24, 0xFF	; 255
    d090:	80 93 b3 06 	sts	0x06B3, r24
				GSM_Temp = 0;
    d094:	10 92 d9 05 	sts	0x05D9, r1
    d098:	88 c9       	rjmp	.-3312   	; 0xc3aa <GSM_Cycle+0x40>
			if(GSM_MultiCon) GSM_Execute_Command(AT_CIPMODE_0, 100*GSM_DEBUG_DELAY);
			else GSM_Execute_Command(AT_CIPMODE_1, 100*GSM_DEBUG_DELAY);
			GSM_State++;
			break;
		case GSM_WAIT_CIPMODE_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    d09a:	81 ef       	ldi	r24, 0xF1	; 241
    d09c:	93 e0       	ldi	r25, 0x03	; 3
    d09e:	6a e4       	ldi	r22, 0x4A	; 74
    d0a0:	0e 94 c4 4a 	call	0x9588	; 0x9588 <GSM_Wait_Response_P>
    d0a4:	88 23       	and	r24, r24
    d0a6:	09 f4       	brne	.+2      	; 0xd0aa <GSM_Cycle+0xd40>
    d0a8:	80 c9       	rjmp	.-3328   	; 0xc3aa <GSM_Cycle+0x40>
				GSM_State++;
    d0aa:	80 91 b3 06 	lds	r24, 0x06B3
    d0ae:	8f 5f       	subi	r24, 0xFF	; 255
    d0b0:	80 93 b3 06 	sts	0x06B3, r24
				// between "Call Ready" and "+CMGS"; 8 sec min needs; for kyivstar vpni only
				StartTimer16(TD_GSM, 1000);
    d0b4:	80 91 e7 04 	lds	r24, 0x04E7
    d0b8:	68 ee       	ldi	r22, 0xE8	; 232
    d0ba:	73 e0       	ldi	r23, 0x03	; 3
    d0bc:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
    d0c0:	74 c9       	rjmp	.-3352   	; 0xc3aa <GSM_Cycle+0x40>
				}
				else GSM_State++;
			}
			break;
		case GSM_SEND_CIPMODE:
			if(GSM_MultiCon) GSM_Execute_Command(AT_CIPMODE_0, 100*GSM_DEBUG_DELAY);
    d0c2:	80 91 2b 0c 	lds	r24, 0x0C2B
    d0c6:	88 23       	and	r24, r24
    d0c8:	09 f4       	brne	.+2      	; 0xd0cc <GSM_Cycle+0xd62>
    d0ca:	8f c4       	rjmp	.+2334   	; 0xd9ea <GSM_Cycle+0x1680>
    d0cc:	8b ef       	ldi	r24, 0xFB	; 251
    d0ce:	94 e0       	ldi	r25, 0x04	; 4
    d0d0:	64 e6       	ldi	r22, 0x64	; 100
    d0d2:	70 e0       	ldi	r23, 0x00	; 0
    d0d4:	0e 94 1f 4b 	call	0x963e	; 0x963e <GSM_Execute_Command>
			else GSM_Execute_Command(AT_CIPMODE_1, 100*GSM_DEBUG_DELAY);
			GSM_State++;
    d0d8:	80 91 b3 06 	lds	r24, 0x06B3
    d0dc:	8f 5f       	subi	r24, 0xFF	; 255
    d0de:	80 93 b3 06 	sts	0x06B3, r24
    d0e2:	63 c9       	rjmp	.-3386   	; 0xc3aa <GSM_Cycle+0x40>
			if(GSM_MultiCon) GSM_Execute_Command(AT_CIPMUX_1, 100*GSM_DEBUG_DELAY);
			else GSM_Execute_Command(AT_CIPMUX_0, 100*GSM_DEBUG_DELAY);
			GSM_State++; 
			break;
		case GSM_WAIT_CIPMUX_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    d0e4:	81 ef       	ldi	r24, 0xF1	; 241
    d0e6:	93 e0       	ldi	r25, 0x03	; 3
    d0e8:	6a e4       	ldi	r22, 0x4A	; 74
    d0ea:	0e 94 c4 4a 	call	0x9588	; 0x9588 <GSM_Wait_Response_P>
    d0ee:	88 23       	and	r24, r24
    d0f0:	09 f4       	brne	.+2      	; 0xd0f4 <GSM_Cycle+0xd8a>
    d0f2:	5b c9       	rjmp	.-3402   	; 0xc3aa <GSM_Cycle+0x40>
				if(GSM_MultiCon){
    d0f4:	80 91 2b 0c 	lds	r24, 0x0C2B
    d0f8:	88 23       	and	r24, r24
    d0fa:	09 f0       	breq	.+2      	; 0xd0fe <GSM_Cycle+0xd94>
    d0fc:	2a c6       	rjmp	.+3156   	; 0xdd52 <GSM_Cycle+0x19e8>
					GSM_State = GSM_WAIT_1;
					// between "Call Ready" and "+CMGS"; 8 sec min needs; for kyivstar vpni only
					StartTimer16(TD_GSM, 1000);
				}
				else GSM_State++;
    d0fe:	80 91 b3 06 	lds	r24, 0x06B3
    d102:	8f 5f       	subi	r24, 0xFF	; 255
    d104:	80 93 b3 06 	sts	0x06B3, r24
    d108:	50 c9       	rjmp	.-3424   	; 0xc3aa <GSM_Cycle+0x40>
		case GSM_WAIT_CSMP_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State=GSM_SEND_ATD_Check_Ballance;
			break;
		//------------------------
		case GSM_SEND_CIPMUX:
			if(GSM_MultiCon) GSM_Execute_Command(AT_CIPMUX_1, 100*GSM_DEBUG_DELAY);
    d10a:	80 91 2b 0c 	lds	r24, 0x0C2B
    d10e:	88 23       	and	r24, r24
    d110:	09 f4       	brne	.+2      	; 0xd114 <GSM_Cycle+0xdaa>
    d112:	5e c4       	rjmp	.+2236   	; 0xd9d0 <GSM_Cycle+0x1666>
    d114:	81 e2       	ldi	r24, 0x21	; 33
    d116:	95 e0       	ldi	r25, 0x05	; 5
    d118:	64 e6       	ldi	r22, 0x64	; 100
    d11a:	70 e0       	ldi	r23, 0x00	; 0
    d11c:	0e 94 1f 4b 	call	0x963e	; 0x963e <GSM_Execute_Command>
			else GSM_Execute_Command(AT_CIPMUX_0, 100*GSM_DEBUG_DELAY);
			GSM_State++; 
    d120:	80 91 b3 06 	lds	r24, 0x06B3
    d124:	8f 5f       	subi	r24, 0xFF	; 255
    d126:	80 93 b3 06 	sts	0x06B3, r24
    d12a:	3f c9       	rjmp	.-3458   	; 0xc3aa <GSM_Cycle+0x40>
			break;
		case GSM_WAIT_CMGF_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;
		case GSM_SEND_CSMP:
			GSM_Execute_Command(AT_CSMP, 100*GSM_DEBUG_DELAY); GSM_State++;
    d12c:	8d ed       	ldi	r24, 0xDD	; 221
    d12e:	94 e0       	ldi	r25, 0x04	; 4
    d130:	64 e6       	ldi	r22, 0x64	; 100
    d132:	70 e0       	ldi	r23, 0x00	; 0
    d134:	0e 94 1f 4b 	call	0x963e	; 0x963e <GSM_Execute_Command>
    d138:	80 91 b3 06 	lds	r24, 0x06B3
    d13c:	8f 5f       	subi	r24, 0xFF	; 255
    d13e:	80 93 b3 06 	sts	0x06B3, r24
    d142:	33 c9       	rjmp	.-3482   	; 0xc3aa <GSM_Cycle+0x40>
			break;
		case GSM_WAIT_CSMP_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State=GSM_SEND_ATD_Check_Ballance;
    d144:	81 ef       	ldi	r24, 0xF1	; 241
    d146:	93 e0       	ldi	r25, 0x03	; 3
    d148:	6a e4       	ldi	r22, 0x4A	; 74
    d14a:	0e 94 c4 4a 	call	0x9588	; 0x9588 <GSM_Wait_Response_P>
    d14e:	88 23       	and	r24, r24
    d150:	09 f4       	brne	.+2      	; 0xd154 <GSM_Cycle+0xdea>
    d152:	2b c9       	rjmp	.-3498   	; 0xc3aa <GSM_Cycle+0x40>
    d154:	8c e4       	ldi	r24, 0x4C	; 76
    d156:	80 93 b3 06 	sts	0x06B3, r24
    d15a:	27 c9       	rjmp	.-3506   	; 0xc3aa <GSM_Cycle+0x40>
///------------------------ / (  )
		case GSM_SEND_CMGF:
			GSM_Execute_Command(AT_CMGF,100*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CMGF_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    d15c:	81 ef       	ldi	r24, 0xF1	; 241
    d15e:	93 e0       	ldi	r25, 0x03	; 3
    d160:	6a e4       	ldi	r22, 0x4A	; 74
    d162:	0e 94 c4 4a 	call	0x9588	; 0x9588 <GSM_Wait_Response_P>
    d166:	88 23       	and	r24, r24
    d168:	09 f4       	brne	.+2      	; 0xd16c <GSM_Cycle+0xe02>
    d16a:	1f c9       	rjmp	.-3522   	; 0xc3aa <GSM_Cycle+0x40>
    d16c:	80 91 b3 06 	lds	r24, 0x06B3
    d170:	8f 5f       	subi	r24, 0xFF	; 255
    d172:	80 93 b3 06 	sts	0x06B3, r24
    d176:	19 c9       	rjmp	.-3534   	; 0xc3aa <GSM_Cycle+0x40>



///------------------------ / (  )
		case GSM_SEND_CMGF:
			GSM_Execute_Command(AT_CMGF,100*GSM_DEBUG_DELAY); GSM_State++;
    d178:	83 ed       	ldi	r24, 0xD3	; 211
    d17a:	94 e0       	ldi	r25, 0x04	; 4
    d17c:	64 e6       	ldi	r22, 0x64	; 100
    d17e:	70 e0       	ldi	r23, 0x00	; 0
    d180:	0e 94 1f 4b 	call	0x963e	; 0x963e <GSM_Execute_Command>
    d184:	80 91 b3 06 	lds	r24, 0x06B3
    d188:	8f 5f       	subi	r24, 0xFF	; 255
    d18a:	80 93 b3 06 	sts	0x06B3, r24
    d18e:	0d c9       	rjmp	.-3558   	; 0xc3aa <GSM_Cycle+0x40>
			if(Timer16Stopp(TD_GSM)){
				GSM_State = GSM_WAIT_MESSAGE;
			}
			break;
		case GSM_WAIT_DISCONNECT_CAUSE:
			if(GetStringFromFIFO()){
    d190:	0e 94 eb 38 	call	0x71d6	; 0x71d6 <GetStringFromFIFO>
    d194:	88 23       	and	r24, r24
    d196:	09 f4       	brne	.+2      	; 0xd19a <GSM_Cycle+0xe30>
    d198:	0e c4       	rjmp	.+2076   	; 0xd9b6 <GSM_Cycle+0x164c>
				if((strstr_P(GSM_RxStr, PSTR("OK")) != NULL) ){
    d19a:	89 e9       	ldi	r24, 0x99	; 153
    d19c:	97 e0       	ldi	r25, 0x07	; 7
    d19e:	6e e2       	ldi	r22, 0x2E	; 46
    d1a0:	7c e2       	ldi	r23, 0x2C	; 44
    d1a2:	0e 94 ef 7f 	call	0xffde	; 0xffde <strstr_P>
    d1a6:	89 2b       	or	r24, r25
    d1a8:	09 f4       	brne	.+2      	; 0xd1ac <GSM_Cycle+0xe42>
    d1aa:	a3 c6       	rjmp	.+3398   	; 0xdef2 <GSM_Cycle+0x1b88>
					GSM_State = GSM_WAIT_MESSAGE;
    d1ac:	8e e0       	ldi	r24, 0x0E	; 14
    d1ae:	80 93 b3 06 	sts	0x06B3, r24
    d1b2:	fb c8       	rjmp	.-3594   	; 0xc3aa <GSM_Cycle+0x40>
			GSM_SendFirstChar();
			GSM_State = GSM_WAIT_CCLC_6;
			StartTimer16(TD_GSM, 1000);
			break;	
		case GSM_WAIT_CCLC_6:
			if(GetStringFromFIFO()){
    d1b4:	0e 94 eb 38 	call	0x71d6	; 0x71d6 <GetStringFromFIFO>
    d1b8:	88 23       	and	r24, r24
    d1ba:	09 f4       	brne	.+2      	; 0xd1be <GSM_Cycle+0xe54>
    d1bc:	1c c3       	rjmp	.+1592   	; 0xd7f6 <GSM_Cycle+0x148c>
				if((strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6,")) != NULL) ){
    d1be:	89 e9       	ldi	r24, 0x99	; 153
    d1c0:	97 e0       	ldi	r25, 0x07	; 7
    d1c2:	61 e3       	ldi	r22, 0x31	; 49
    d1c4:	7c e2       	ldi	r23, 0x2C	; 44
    d1c6:	0e 94 ef 7f 	call	0xffde	; 0xffde <strstr_P>
    d1ca:	89 2b       	or	r24, r25
    d1cc:	09 f4       	brne	.+2      	; 0xd1d0 <GSM_Cycle+0xe66>
    d1ce:	13 c3       	rjmp	.+1574   	; 0xd7f6 <GSM_Cycle+0x148c>
					GSM_State = GSM_WAIT_DISCONNECT_CAUSE;
    d1d0:	85 e2       	ldi	r24, 0x25	; 37
    d1d2:	80 93 b3 06 	sts	0x06B3, r24
					StartTimer16(TD_GSM, 10000);
    d1d6:	80 91 e7 04 	lds	r24, 0x04E7
    d1da:	60 e1       	ldi	r22, 0x10	; 16
    d1dc:	77 e2       	ldi	r23, 0x27	; 39
    d1de:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
    d1e2:	e3 c8       	rjmp	.-3642   	; 0xc3aa <GSM_Cycle+0x40>
				GSM_State = GSM_SEND_ATH;
				StartTimer16(TD_GSM, 10000);
			}
			break;	
		case GSM_SEND_ATH:
			sprintf_P(GSM_TxStr, PSTR("ATH\r"));
    d1e4:	00 d0       	rcall	.+0      	; 0xd1e6 <GSM_Cycle+0xe7c>
    d1e6:	0f 92       	push	r0
    d1e8:	82 e0       	ldi	r24, 0x02	; 2
    d1ea:	9a e0       	ldi	r25, 0x0A	; 10
    d1ec:	ed b7       	in	r30, 0x3d	; 61
    d1ee:	fe b7       	in	r31, 0x3e	; 62
    d1f0:	92 83       	std	Z+2, r25	; 0x02
    d1f2:	81 83       	std	Z+1, r24	; 0x01
    d1f4:	8f e3       	ldi	r24, 0x3F	; 63
    d1f6:	9c e2       	ldi	r25, 0x2C	; 44
    d1f8:	94 83       	std	Z+4, r25	; 0x04
    d1fa:	83 83       	std	Z+3, r24	; 0x03
    d1fc:	0e 94 ea 80 	call	0x101d4	; 0x101d4 <sprintf_P>
			GSMTxSz = 4;
    d200:	84 e0       	ldi	r24, 0x04	; 4
    d202:	80 93 75 07 	sts	0x0775, r24
			GSM_SendFirstChar();
    d206:	0f 90       	pop	r0
    d208:	0f 90       	pop	r0
    d20a:	0f 90       	pop	r0
    d20c:	0f 90       	pop	r0
    d20e:	0e 94 15 3a 	call	0x742a	; 0x742a <GSM_SendFirstChar>
			GSM_State = GSM_WAIT_CCLC_6;
    d212:	84 e2       	ldi	r24, 0x24	; 36
    d214:	80 93 b3 06 	sts	0x06B3, r24
			StartTimer16(TD_GSM, 1000);
    d218:	80 91 e7 04 	lds	r24, 0x04E7
    d21c:	68 ee       	ldi	r22, 0xE8	; 232
    d21e:	73 e0       	ldi	r23, 0x03	; 3
    d220:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
    d224:	c2 c8       	rjmp	.-3708   	; 0xc3aa <GSM_Cycle+0x40>
					GSM_State = GSM_WAIT_PLAY_NOTCONFIRM_FILE_CREC_0;
					StartTimer16(TD_GSM, 20000);
				}
			break;
		case GSM_WAIT_PLAY_NOTCONFIRM_FILE_CREC_0:
			if(GSM_Wait_Response_P(RESP_CREC_0, GSM_SEND_ATD)) 
    d226:	81 e5       	ldi	r24, 0x51	; 81
    d228:	94 e0       	ldi	r25, 0x04	; 4
    d22a:	6f e0       	ldi	r22, 0x0F	; 15
    d22c:	0e 94 c4 4a 	call	0x9588	; 0x9588 <GSM_Wait_Response_P>
    d230:	88 23       	and	r24, r24
    d232:	09 f4       	brne	.+2      	; 0xd236 <GSM_Cycle+0xecc>
    d234:	ba c8       	rjmp	.-3724   	; 0xc3aa <GSM_Cycle+0x40>
			{
				GSM_State = GSM_SEND_ATH;
    d236:	83 e2       	ldi	r24, 0x23	; 35
    d238:	80 93 b3 06 	sts	0x06B3, r24
				StartTimer16(TD_GSM, 10000);
    d23c:	80 91 e7 04 	lds	r24, 0x04E7
    d240:	60 e1       	ldi	r22, 0x10	; 16
    d242:	77 e2       	ldi	r23, 0x27	; 39
    d244:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
    d248:	b0 c8       	rjmp	.-3744   	; 0xc3aa <GSM_Cycle+0x40>
			GSM_SendFirstChar();
			GSM_State = GSM_WAIT_PLAY_NOTCONFIRM_FILE_OK;
			StartTimer16(TD_GSM, 1000);
			break;
		case GSM_WAIT_PLAY_NOTCONFIRM_FILE_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_WAIT_PLAY_NOTCONFIRM_FILE_OK)) 
    d24a:	81 ef       	ldi	r24, 0xF1	; 241
    d24c:	93 e0       	ldi	r25, 0x03	; 3
    d24e:	61 e2       	ldi	r22, 0x21	; 33
    d250:	0e 94 c4 4a 	call	0x9588	; 0x9588 <GSM_Wait_Response_P>
    d254:	88 23       	and	r24, r24
    d256:	09 f4       	brne	.+2      	; 0xd25a <GSM_Cycle+0xef0>
    d258:	a8 c8       	rjmp	.-3760   	; 0xc3aa <GSM_Cycle+0x40>
				{
					GSM_State = GSM_WAIT_PLAY_NOTCONFIRM_FILE_CREC_0;
    d25a:	82 e2       	ldi	r24, 0x22	; 34
    d25c:	80 93 b3 06 	sts	0x06B3, r24
					StartTimer16(TD_GSM, 20000);
    d260:	80 91 e7 04 	lds	r24, 0x04E7
    d264:	60 e2       	ldi	r22, 0x20	; 32
    d266:	7e e4       	ldi	r23, 0x4E	; 78
    d268:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
    d26c:	9e c8       	rjmp	.-3780   	; 0xc3aa <GSM_Cycle+0x40>
				GSM_State = GSM_SEND_ATH;
				StartTimer16(TD_GSM, 10000);
			}
			break;
		case GSM_SEND_PLAY_NOTCONFIRM_FILE: 
			sprintf_P(GSM_TxStr, PSTR("AT+CREC=4,\"C:\\User\\NotConfirm.amr\",0,100\r"));
    d26e:	00 d0       	rcall	.+0      	; 0xd270 <GSM_Cycle+0xf06>
    d270:	0f 92       	push	r0
    d272:	82 e0       	ldi	r24, 0x02	; 2
    d274:	9a e0       	ldi	r25, 0x0A	; 10
    d276:	ad b7       	in	r26, 0x3d	; 61
    d278:	be b7       	in	r27, 0x3e	; 62
    d27a:	12 96       	adiw	r26, 0x02	; 2
    d27c:	9c 93       	st	X, r25
    d27e:	8e 93       	st	-X, r24
    d280:	11 97       	sbiw	r26, 0x01	; 1
    d282:	84 e4       	ldi	r24, 0x44	; 68
    d284:	9c e2       	ldi	r25, 0x2C	; 44
    d286:	14 96       	adiw	r26, 0x04	; 4
    d288:	9c 93       	st	X, r25
    d28a:	8e 93       	st	-X, r24
    d28c:	13 97       	sbiw	r26, 0x03	; 3
    d28e:	0e 94 ea 80 	call	0x101d4	; 0x101d4 <sprintf_P>
			GSMTxSz = 41;
    d292:	89 e2       	ldi	r24, 0x29	; 41
    d294:	80 93 75 07 	sts	0x0775, r24
			GSM_SendFirstChar();
    d298:	0f 90       	pop	r0
    d29a:	0f 90       	pop	r0
    d29c:	0f 90       	pop	r0
    d29e:	0f 90       	pop	r0
    d2a0:	0e 94 15 3a 	call	0x742a	; 0x742a <GSM_SendFirstChar>
			GSM_State = GSM_WAIT_PLAY_NOTCONFIRM_FILE_OK;
    d2a4:	81 e2       	ldi	r24, 0x21	; 33
    d2a6:	80 93 b3 06 	sts	0x06B3, r24
			StartTimer16(TD_GSM, 1000);
    d2aa:	80 91 e7 04 	lds	r24, 0x04E7
    d2ae:	68 ee       	ldi	r22, 0xE8	; 232
    d2b0:	73 e0       	ldi	r23, 0x03	; 3
    d2b2:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
    d2b6:	79 c8       	rjmp	.-3854   	; 0xc3aa <GSM_Cycle+0x40>
					GSM_State = GSM_WAIT_PLAY_CONFIRM_FILE_CREC_0;
					StartTimer16(TD_GSM, 20000);
				}
			break;
		case GSM_WAIT_PLAY_CONFIRM_FILE_CREC_0:
			if(GSM_Wait_Response_P(RESP_CREC_0, GSM_SEND_ATD)) 
    d2b8:	81 e5       	ldi	r24, 0x51	; 81
    d2ba:	94 e0       	ldi	r25, 0x04	; 4
    d2bc:	6f e0       	ldi	r22, 0x0F	; 15
    d2be:	0e 94 c4 4a 	call	0x9588	; 0x9588 <GSM_Wait_Response_P>
    d2c2:	88 23       	and	r24, r24
    d2c4:	09 f4       	brne	.+2      	; 0xd2c8 <GSM_Cycle+0xf5e>
    d2c6:	71 c8       	rjmp	.-3870   	; 0xc3aa <GSM_Cycle+0x40>
			{
				GSM_State = GSM_SEND_ATH;
    d2c8:	83 e2       	ldi	r24, 0x23	; 35
    d2ca:	80 93 b3 06 	sts	0x06B3, r24
				StartTimer16(TD_GSM, 10000);
    d2ce:	80 91 e7 04 	lds	r24, 0x04E7
    d2d2:	60 e1       	ldi	r22, 0x10	; 16
    d2d4:	77 e2       	ldi	r23, 0x27	; 39
    d2d6:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
    d2da:	67 c8       	rjmp	.-3890   	; 0xc3aa <GSM_Cycle+0x40>

		case GSM_SEND_CSTT:
			GSM_Execute_Command(AT_CSTT, 300*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CSTT_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    d2dc:	81 ef       	ldi	r24, 0xF1	; 241
    d2de:	93 e0       	ldi	r25, 0x03	; 3
    d2e0:	6a e4       	ldi	r22, 0x4A	; 74
    d2e2:	0e 94 c4 4a 	call	0x9588	; 0x9588 <GSM_Wait_Response_P>
    d2e6:	88 23       	and	r24, r24
    d2e8:	09 f4       	brne	.+2      	; 0xd2ec <GSM_Cycle+0xf82>
    d2ea:	5f c8       	rjmp	.-3906   	; 0xc3aa <GSM_Cycle+0x40>
    d2ec:	80 91 b3 06 	lds	r24, 0x06B3
    d2f0:	8f 5f       	subi	r24, 0xFF	; 255
    d2f2:	80 93 b3 06 	sts	0x06B3, r24
    d2f6:	59 c8       	rjmp	.-3918   	; 0xc3aa <GSM_Cycle+0x40>
		case GSM_WAIT_CIPTKA_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;

		case GSM_SEND_CSTT:
			GSM_Execute_Command(AT_CSTT, 300*GSM_DEBUG_DELAY); GSM_State++;
    d2f8:	87 e4       	ldi	r24, 0x47	; 71
    d2fa:	95 e0       	ldi	r25, 0x05	; 5
    d2fc:	6c e2       	ldi	r22, 0x2C	; 44
    d2fe:	71 e0       	ldi	r23, 0x01	; 1
    d300:	0e 94 1f 4b 	call	0x963e	; 0x963e <GSM_Execute_Command>
    d304:	80 91 b3 06 	lds	r24, 0x06B3
    d308:	8f 5f       	subi	r24, 0xFF	; 255
    d30a:	80 93 b3 06 	sts	0x06B3, r24
    d30e:	4d c8       	rjmp	.-3942   	; 0xc3aa <GSM_Cycle+0x40>

		case GSM_SEND_CIPTKA:
			GSM_Execute_Command(AT_CIPTKA, 1000*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CIPTKA_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    d310:	81 ef       	ldi	r24, 0xF1	; 241
    d312:	93 e0       	ldi	r25, 0x03	; 3
    d314:	6a e4       	ldi	r22, 0x4A	; 74
    d316:	0e 94 c4 4a 	call	0x9588	; 0x9588 <GSM_Wait_Response_P>
    d31a:	88 23       	and	r24, r24
    d31c:	09 f4       	brne	.+2      	; 0xd320 <GSM_Cycle+0xfb6>
    d31e:	45 c8       	rjmp	.-3958   	; 0xc3aa <GSM_Cycle+0x40>
    d320:	80 91 b3 06 	lds	r24, 0x06B3
    d324:	8f 5f       	subi	r24, 0xFF	; 255
    d326:	80 93 b3 06 	sts	0x06B3, r24
    d32a:	3f c8       	rjmp	.-3970   	; 0xc3aa <GSM_Cycle+0x40>
			 else GSM_State=GSM_SEND_CSTT;
			 }
			break;

		case GSM_SEND_CIPTKA:
			GSM_Execute_Command(AT_CIPTKA, 1000*GSM_DEBUG_DELAY); GSM_State++;
    d32c:	81 e6       	ldi	r24, 0x61	; 97
    d32e:	95 e0       	ldi	r25, 0x05	; 5
    d330:	68 ee       	ldi	r22, 0xE8	; 232
    d332:	73 e0       	ldi	r23, 0x03	; 3
    d334:	0e 94 1f 4b 	call	0x963e	; 0x963e <GSM_Execute_Command>
    d338:	80 91 b3 06 	lds	r24, 0x06B3
    d33c:	8f 5f       	subi	r24, 0xFF	; 255
    d33e:	80 93 b3 06 	sts	0x06B3, r24
    d342:	33 c8       	rjmp	.-3994   	; 0xc3aa <GSM_Cycle+0x40>
				StartTimer16(TD_GSM, 300*GSM_DEBUG_DELAY);
			}
			GSM_State++;
			break;
		case GSM_WAIT_CIPCSGP_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    d344:	81 ef       	ldi	r24, 0xF1	; 241
    d346:	93 e0       	ldi	r25, 0x03	; 3
    d348:	6a e4       	ldi	r22, 0x4A	; 74
    d34a:	0e 94 c4 4a 	call	0x9588	; 0x9588 <GSM_Wait_Response_P>
    d34e:	88 23       	and	r24, r24
    d350:	09 f4       	brne	.+2      	; 0xd354 <GSM_Cycle+0xfea>
    d352:	2b c8       	rjmp	.-4010   	; 0xc3aa <GSM_Cycle+0x40>
			 if(GSM_Modem == SIMCOM_SIM800)GSM_State++;
    d354:	80 91 f1 06 	lds	r24, 0x06F1
    d358:	82 30       	cpi	r24, 0x02	; 2
    d35a:	09 f4       	brne	.+2      	; 0xd35e <GSM_Cycle+0xff4>
    d35c:	0d c5       	rjmp	.+2586   	; 0xdd78 <GSM_Cycle+0x1a0e>
			 else GSM_State=GSM_SEND_CSTT;
    d35e:	85 e3       	ldi	r24, 0x35	; 53
    d360:	80 93 b3 06 	sts	0x06B3, r24
    d364:	22 c8       	rjmp	.-4028   	; 0xc3aa <GSM_Cycle+0x40>
			if(GSM_Wait_Response_P(RESP_OK, GSM_SEND_CGATT)) GSM_State++;
			break;

		case GSM_SEND_CIPCSGP:
			//GSM_Execute_Command(AT_CIPCSGP, 300*GSM_DEBUG_DELAY); GSM_State++;
			if(GSM_Flag & (1<<flg_TxCStr)){
    d366:	80 91 d2 02 	lds	r24, 0x02D2
    d36a:	80 fd       	sbrc	r24, 0
    d36c:	20 c4       	rjmp	.+2112   	; 0xdbae <GSM_Cycle+0x1844>
				GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn_psw);
				sprintf(GSM_TxStr + GSMTxSz, "\"\r");	GSMTxSz = GSMTxSz+2;
				GSM_SendFirstChar();
				StartTimer16(TD_GSM, 300*GSM_DEBUG_DELAY);
			}
			GSM_State++;
    d36e:	80 91 b3 06 	lds	r24, 0x06B3
    d372:	8f 5f       	subi	r24, 0xFF	; 255
    d374:	80 93 b3 06 	sts	0x06B3, r24
    d378:	18 c8       	rjmp	.-4048   	; 0xc3aa <GSM_Cycle+0x40>
			break;
		case GSM_SEND_CGATT:
			GSM_Execute_Command(AT_CGATT, 500*GSM_DEBUG_DELAY); GSM_Temp++; GSM_State++;
			break;
		case GSM_WAIT_CGATT_OK:
			if(GSM_Temp>20) GSM_State = GSM_ReStart1;
    d37a:	80 91 d9 05 	lds	r24, 0x05D9
    d37e:	85 31       	cpi	r24, 0x15	; 21
    d380:	18 f0       	brcs	.+6      	; 0xd388 <GSM_Cycle+0x101e>
    d382:	8a e4       	ldi	r24, 0x4A	; 74
    d384:	80 93 b3 06 	sts	0x06B3, r24
			if(GSM_Wait_Response_P(RESP_OK, GSM_SEND_CGATT)) GSM_State++;
    d388:	81 ef       	ldi	r24, 0xF1	; 241
    d38a:	93 e0       	ldi	r25, 0x03	; 3
    d38c:	6f e2       	ldi	r22, 0x2F	; 47
    d38e:	0e 94 c4 4a 	call	0x9588	; 0x9588 <GSM_Wait_Response_P>
    d392:	88 23       	and	r24, r24
    d394:	09 f4       	brne	.+2      	; 0xd398 <GSM_Cycle+0x102e>
    d396:	09 c8       	rjmp	.-4078   	; 0xc3aa <GSM_Cycle+0x40>
    d398:	80 91 b3 06 	lds	r24, 0x06B3
    d39c:	8f 5f       	subi	r24, 0xFF	; 255
    d39e:	80 93 b3 06 	sts	0x06B3, r24
    d3a2:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
				GSM_State++;
				GSM_Temp = 0;
			}
			break;
		case GSM_SEND_CGATT:
			GSM_Execute_Command(AT_CGATT, 500*GSM_DEBUG_DELAY); GSM_Temp++; GSM_State++;
    d3a6:	8d e2       	ldi	r24, 0x2D	; 45
    d3a8:	95 e0       	ldi	r25, 0x05	; 5
    d3aa:	64 ef       	ldi	r22, 0xF4	; 244
    d3ac:	71 e0       	ldi	r23, 0x01	; 1
    d3ae:	0e 94 1f 4b 	call	0x963e	; 0x963e <GSM_Execute_Command>
    d3b2:	80 91 d9 05 	lds	r24, 0x05D9
    d3b6:	8f 5f       	subi	r24, 0xFF	; 255
    d3b8:	80 93 d9 05 	sts	0x05D9, r24
    d3bc:	80 91 b3 06 	lds	r24, 0x06B3
    d3c0:	8f 5f       	subi	r24, 0xFF	; 255
    d3c2:	80 93 b3 06 	sts	0x06B3, r24
    d3c6:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>

		case GSM_SEND_CIFSR:
			GSM_Execute_Command(AT_CIFSR, 1000*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CIFSR_OK:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
    d3ca:	80 91 e7 04 	lds	r24, 0x04E7
    d3ce:	0e 94 71 1c 	call	0x38e2	; 0x38e2 <Timer16Stopp>
    d3d2:	88 23       	and	r24, r24
    d3d4:	19 f0       	breq	.+6      	; 0xd3dc <GSM_Cycle+0x1072>
    d3d6:	8a e4       	ldi	r24, 0x4A	; 74
    d3d8:	80 93 b3 06 	sts	0x06B3, r24
			if(GetStringFromFIFO()){
    d3dc:	0e 94 eb 38 	call	0x71d6	; 0x71d6 <GetStringFromFIFO>
    d3e0:	88 23       	and	r24, r24
    d3e2:	11 f4       	brne	.+4      	; 0xd3e8 <GSM_Cycle+0x107e>
    d3e4:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
	uint8_t IP4;
} IP_Addr;

//~~~~~~~~~~~~~~
void SetIP(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	IP->IP1 = IP1;
    d3e8:	49 ee       	ldi	r20, 0xE9	; 233
    d3ea:	58 e0       	ldi	r21, 0x08	; 8
    d3ec:	10 92 e9 08 	sts	0x08E9, r1
	IP->IP2 = IP2;
    d3f0:	ba 01       	movw	r22, r20
    d3f2:	6f 5f       	subi	r22, 0xFF	; 255
    d3f4:	7f 4f       	sbci	r23, 0xFF	; 255
    d3f6:	10 92 ea 08 	sts	0x08EA, r1
	IP->IP3 = IP3;
    d3fa:	8a 01       	movw	r16, r20
    d3fc:	0e 5f       	subi	r16, 0xFE	; 254
    d3fe:	1f 4f       	sbci	r17, 0xFF	; 255
    d400:	10 92 eb 08 	sts	0x08EB, r1
	IP->IP4 = IP4;
    d404:	e3 e0       	ldi	r30, 0x03	; 3
    d406:	ee 2e       	mov	r14, r30
    d408:	f1 2c       	mov	r15, r1
    d40a:	e4 0e       	add	r14, r20
    d40c:	f5 1e       	adc	r15, r21
    d40e:	10 92 ec 08 	sts	0x08EC, r1
    d412:	20 e0       	ldi	r18, 0x00	; 0
    d414:	a9 e9       	ldi	r26, 0x99	; 153
    d416:	b7 e0       	ldi	r27, 0x07	; 7
				SetIP(&GSM_MyIP,0,0,0,0);
				for(uint8_t i=0; i<strlen(GSM_RxStr); i++)
					if(!isdigit(GSM_RxStr[i])) GSM_RxStr[i] = ' ';
    d418:	30 e2       	ldi	r19, 0x20	; 32
			break;
		case GSM_WAIT_CIFSR_OK:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
			if(GetStringFromFIFO()){
				SetIP(&GSM_MyIP,0,0,0,0);
				for(uint8_t i=0; i<strlen(GSM_RxStr); i++)
    d41a:	fd 01       	movw	r30, r26
    d41c:	01 90       	ld	r0, Z+
    d41e:	00 20       	and	r0, r0
    d420:	e9 f7       	brne	.-6      	; 0xd41c <GSM_Cycle+0x10b2>
    d422:	31 97       	sbiw	r30, 0x01	; 1
    d424:	e9 59       	subi	r30, 0x99	; 153
    d426:	f7 40       	sbci	r31, 0x07	; 7
    d428:	82 2f       	mov	r24, r18
    d42a:	90 e0       	ldi	r25, 0x00	; 0
    d42c:	8e 17       	cp	r24, r30
    d42e:	9f 07       	cpc	r25, r31
    d430:	08 f0       	brcs	.+2      	; 0xd434 <GSM_Cycle+0x10ca>
    d432:	fb c1       	rjmp	.+1014   	; 0xd82a <GSM_Cycle+0x14c0>
					if(!isdigit(GSM_RxStr[i])) GSM_RxStr[i] = ' ';
    d434:	fc 01       	movw	r30, r24
    d436:	e7 56       	subi	r30, 0x67	; 103
    d438:	f8 4f       	sbci	r31, 0xF8	; 248
    d43a:	80 81       	ld	r24, Z
    d43c:	90 e0       	ldi	r25, 0x00	; 0
    d43e:	c0 97       	sbiw	r24, 0x30	; 48
    d440:	0a 97       	sbiw	r24, 0x0a	; 10
    d442:	08 f0       	brcs	.+2      	; 0xd446 <GSM_Cycle+0x10dc>
    d444:	30 83       	st	Z, r19
			break;
		case GSM_WAIT_CIFSR_OK:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
			if(GetStringFromFIFO()){
				SetIP(&GSM_MyIP,0,0,0,0);
				for(uint8_t i=0; i<strlen(GSM_RxStr); i++)
    d446:	2f 5f       	subi	r18, 0xFF	; 255
    d448:	e8 cf       	rjmp	.-48     	; 0xd41a <GSM_Cycle+0x10b0>
			break;

	

		case GSM_SEND_CIFSR:
			GSM_Execute_Command(AT_CIFSR, 1000*GSM_DEBUG_DELAY); GSM_State++;
    d44a:	88 e5       	ldi	r24, 0x58	; 88
    d44c:	95 e0       	ldi	r25, 0x05	; 5
    d44e:	68 ee       	ldi	r22, 0xE8	; 232
    d450:	73 e0       	ldi	r23, 0x03	; 3
    d452:	0e 94 1f 4b 	call	0x963e	; 0x963e <GSM_Execute_Command>
    d456:	80 91 b3 06 	lds	r24, 0x06B3
    d45a:	8f 5f       	subi	r24, 0xFF	; 255
    d45c:	80 93 b3 06 	sts	0x06B3, r24
    d460:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>

		case GSM_SEND_CIICR:
			GSM_Execute_Command(AT_CIICR, 12000*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CIICR_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    d464:	81 ef       	ldi	r24, 0xF1	; 241
    d466:	93 e0       	ldi	r25, 0x03	; 3
    d468:	6a e4       	ldi	r22, 0x4A	; 74
    d46a:	0e 94 c4 4a 	call	0x9588	; 0x9588 <GSM_Wait_Response_P>
    d46e:	88 23       	and	r24, r24
    d470:	11 f4       	brne	.+4      	; 0xd476 <GSM_Cycle+0x110c>
    d472:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
    d476:	80 91 b3 06 	lds	r24, 0x06B3
    d47a:	8f 5f       	subi	r24, 0xFF	; 255
    d47c:	80 93 b3 06 	sts	0x06B3, r24
    d480:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
		case GSM_WAIT_CSTT_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;

		case GSM_SEND_CIICR:
			GSM_Execute_Command(AT_CIICR, 12000*GSM_DEBUG_DELAY); GSM_State++;
    d484:	8f e4       	ldi	r24, 0x4F	; 79
    d486:	95 e0       	ldi	r25, 0x05	; 5
    d488:	60 ee       	ldi	r22, 0xE0	; 224
    d48a:	7e e2       	ldi	r23, 0x2E	; 46
    d48c:	0e 94 1f 4b 	call	0x963e	; 0x963e <GSM_Execute_Command>
    d490:	80 91 b3 06 	lds	r24, 0x06B3
    d494:	8f 5f       	subi	r24, 0xFF	; 255
    d496:	80 93 b3 06 	sts	0x06B3, r24
    d49a:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
				}
		
			break;

		case GSM_WAIT_CIPSTART_TCP_CLIENT_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    d49e:	81 ef       	ldi	r24, 0xF1	; 241
    d4a0:	93 e0       	ldi	r25, 0x03	; 3
    d4a2:	6a e4       	ldi	r22, 0x4A	; 74
    d4a4:	0e 94 c4 4a 	call	0x9588	; 0x9588 <GSM_Wait_Response_P>
    d4a8:	88 23       	and	r24, r24
    d4aa:	11 f4       	brne	.+4      	; 0xd4b0 <GSM_Cycle+0x1146>
    d4ac:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
    d4b0:	80 91 b3 06 	lds	r24, 0x06B3
    d4b4:	8f 5f       	subi	r24, 0xFF	; 255
    d4b6:	80 93 b3 06 	sts	0x06B3, r24
    d4ba:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
			}			
			break;
		//------------------------
		case GSM_SEND_CIPSTART_TCP_CLIENT:
	
				if(GSM_Flag & (1<<flg_TxCStr)){
    d4be:	80 91 d2 02 	lds	r24, 0x02D2
    d4c2:	80 fd       	sbrc	r24, 0
    d4c4:	02 c0       	rjmp	.+4      	; 0xd4ca <GSM_Cycle+0x1160>
    d4c6:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
					GSMTxSz = strlen_P(AT_CIPSTART_TCP_CLIENT);
    d4ca:	58 e8       	ldi	r21, 0x88	; 136
    d4cc:	e5 2e       	mov	r14, r21
    d4ce:	55 e0       	ldi	r21, 0x05	; 5
    d4d0:	f5 2e       	mov	r15, r21
    d4d2:	c7 01       	movw	r24, r14
    d4d4:	0e 94 cd 7f 	call	0xff9a	; 0xff9a <strlen_P>
    d4d8:	80 93 75 07 	sts	0x0775, r24
					sprintf_P(GSM_TxStr, AT_CIPSTART_TCP_CLIENT);
    d4dc:	00 d0       	rcall	.+0      	; 0xd4de <GSM_Cycle+0x1174>
    d4de:	0f 92       	push	r0
    d4e0:	02 e0       	ldi	r16, 0x02	; 2
    d4e2:	1a e0       	ldi	r17, 0x0A	; 10
    d4e4:	ad b7       	in	r26, 0x3d	; 61
    d4e6:	be b7       	in	r27, 0x3e	; 62
    d4e8:	12 96       	adiw	r26, 0x02	; 2
    d4ea:	1c 93       	st	X, r17
    d4ec:	0e 93       	st	-X, r16
    d4ee:	11 97       	sbiw	r26, 0x01	; 1
    d4f0:	14 96       	adiw	r26, 0x04	; 4
    d4f2:	fc 92       	st	X, r15
    d4f4:	ee 92       	st	-X, r14
    d4f6:	13 97       	sbiw	r26, 0x03	; 3
    d4f8:	0e 94 ea 80 	call	0x101d4	; 0x101d4 <sprintf_P>
					//GSM_TxStr[12] = 0x30+TempNum;
					sprintf(GSM_TxStr + GSMTxSz, "\"%u.%u.%u.%u\",\"%u\"\r",(unsigned int)erb(&TCP_ServerIP[0].IP1), (unsigned int)erb(&TCP_ServerIP[0].IP2), 
    d4fc:	b0 90 75 07 	lds	r11, 0x0775
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    d500:	0f 90       	pop	r0
    d502:	0f 90       	pop	r0
    d504:	0f 90       	pop	r0
    d506:	0f 90       	pop	r0
    d508:	81 e9       	ldi	r24, 0x91	; 145
    d50a:	90 e0       	ldi	r25, 0x00	; 0
    d50c:	0e 94 e7 82 	call	0x105ce	; 0x105ce <__eerd_byte_m2560>
    d510:	f8 2e       	mov	r15, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    d512:	82 e9       	ldi	r24, 0x92	; 146
    d514:	90 e0       	ldi	r25, 0x00	; 0
    d516:	0e 94 e7 82 	call	0x105ce	; 0x105ce <__eerd_byte_m2560>
    d51a:	e8 2e       	mov	r14, r24
    d51c:	83 e9       	ldi	r24, 0x93	; 147
    d51e:	90 e0       	ldi	r25, 0x00	; 0
    d520:	0e 94 e7 82 	call	0x105ce	; 0x105ce <__eerd_byte_m2560>
    d524:	d8 2e       	mov	r13, r24
    d526:	84 e9       	ldi	r24, 0x94	; 148
    d528:	90 e0       	ldi	r25, 0x00	; 0
    d52a:	0e 94 e7 82 	call	0x105ce	; 0x105ce <__eerd_byte_m2560>
    d52e:	c8 2e       	mov	r12, r24
    d530:	89 ea       	ldi	r24, 0xA9	; 169
    d532:	90 e0       	ldi	r25, 0x00	; 0
    d534:	0e 94 f5 82 	call	0x105ea	; 0x105ea <__eerd_word_m2560>
    d538:	ed b7       	in	r30, 0x3d	; 61
    d53a:	fe b7       	in	r31, 0x3e	; 62
    d53c:	3e 97       	sbiw	r30, 0x0e	; 14
    d53e:	0f b6       	in	r0, 0x3f	; 63
    d540:	f8 94       	cli
    d542:	fe bf       	out	0x3e, r31	; 62
    d544:	0f be       	out	0x3f, r0	; 63
    d546:	ed bf       	out	0x3d, r30	; 61
    d548:	31 96       	adiw	r30, 0x01	; 1
    d54a:	2b 2d       	mov	r18, r11
    d54c:	30 e0       	ldi	r19, 0x00	; 0
    d54e:	20 0f       	add	r18, r16
    d550:	31 1f       	adc	r19, r17
    d552:	ad b7       	in	r26, 0x3d	; 61
    d554:	be b7       	in	r27, 0x3e	; 62
    d556:	12 96       	adiw	r26, 0x02	; 2
    d558:	3c 93       	st	X, r19
    d55a:	2e 93       	st	-X, r18
    d55c:	11 97       	sbiw	r26, 0x01	; 1
    d55e:	28 eb       	ldi	r18, 0xB8	; 184
    d560:	32 e0       	ldi	r19, 0x02	; 2
    d562:	33 83       	std	Z+3, r19	; 0x03
    d564:	22 83       	std	Z+2, r18	; 0x02
    d566:	f4 82       	std	Z+4, r15	; 0x04
    d568:	15 82       	std	Z+5, r1	; 0x05
    d56a:	e6 82       	std	Z+6, r14	; 0x06
    d56c:	17 82       	std	Z+7, r1	; 0x07
    d56e:	d0 86       	std	Z+8, r13	; 0x08
    d570:	11 86       	std	Z+9, r1	; 0x09
    d572:	c2 86       	std	Z+10, r12	; 0x0a
    d574:	13 86       	std	Z+11, r1	; 0x0b
    d576:	95 87       	std	Z+13, r25	; 0x0d
    d578:	84 87       	std	Z+12, r24	; 0x0c
    d57a:	0e 94 b9 80 	call	0x10172	; 0x10172 <sprintf>
						(unsigned int)erb(&TCP_ServerIP[0].IP3), (unsigned int)erb(&TCP_ServerIP[0].IP4), (unsigned int)erw(&TCP_ServerPort[0]));
					GSMTxSz = strlen(GSM_TxStr);
    d57e:	f8 01       	movw	r30, r16
    d580:	01 90       	ld	r0, Z+
    d582:	00 20       	and	r0, r0
    d584:	e9 f7       	brne	.-6      	; 0xd580 <GSM_Cycle+0x1216>
    d586:	8f 01       	movw	r16, r30
    d588:	01 50       	subi	r16, 0x01	; 1
    d58a:	10 40       	sbci	r17, 0x00	; 0
    d58c:	02 50       	subi	r16, 0x02	; 2
    d58e:	1a 40       	sbci	r17, 0x0A	; 10
    d590:	00 93 75 07 	sts	0x0775, r16
					GSM_SendFirstChar();
    d594:	2d b7       	in	r18, 0x3d	; 61
    d596:	3e b7       	in	r19, 0x3e	; 62
    d598:	22 5f       	subi	r18, 0xF2	; 242
    d59a:	3f 4f       	sbci	r19, 0xFF	; 255
    d59c:	0f b6       	in	r0, 0x3f	; 63
    d59e:	f8 94       	cli
    d5a0:	3e bf       	out	0x3e, r19	; 62
    d5a2:	0f be       	out	0x3f, r0	; 63
    d5a4:	2d bf       	out	0x3d, r18	; 61
    d5a6:	0e 94 15 3a 	call	0x742a	; 0x742a <GSM_SendFirstChar>
					StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    d5aa:	80 91 e7 04 	lds	r24, 0x04E7
    d5ae:	64 ef       	ldi	r22, 0xF4	; 244
    d5b0:	71 e0       	ldi	r23, 0x01	; 1
    d5b2:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
					GSM_State++;
    d5b6:	80 91 b3 06 	lds	r24, 0x06B3
    d5ba:	8f 5f       	subi	r24, 0xFF	; 255
    d5bc:	80 93 b3 06 	sts	0x06B3, r24
    d5c0:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>

		case GSM_WAIT_CIPSTART_TCP_CLIENT_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;
		case GSM_WAIT_CIPSTART_TCP_CLIENT_CONNECT:
			if(GSM_Wait_Response_P(RESP_CONNECT, GSM_ReStart1)){
    d5c4:	84 ef       	ldi	r24, 0xF4	; 244
    d5c6:	93 e0       	ldi	r25, 0x03	; 3
    d5c8:	6a e4       	ldi	r22, 0x4A	; 74
    d5ca:	0e 94 c4 4a 	call	0x9588	; 0x9588 <GSM_Wait_Response_P>
    d5ce:	88 23       	and	r24, r24
    d5d0:	11 f4       	brne	.+4      	; 0xd5d6 <GSM_Cycle+0x126c>
    d5d2:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
				 GSM_State = GSM_WAIT_IDENTIFICATION;
    d5d6:	8e e3       	ldi	r24, 0x3E	; 62
    d5d8:	80 93 b3 06 	sts	0x06B3, r24
				 StartTimer16(TD_GSM, 1000*GSM_DEBUG_DELAY);
    d5dc:	80 91 e7 04 	lds	r24, 0x04E7
    d5e0:	68 ee       	ldi	r22, 0xE8	; 232
    d5e2:	73 e0       	ldi	r23, 0x03	; 3
    d5e4:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
    d5e8:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
			break;
		case GSM_CFG_SEND_ATW:
			GSM_Execute_Command(AT_W, 100); GSM_State++;
			break;
		case GSM_CFG_WAIT_ATW_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_CFG_SEND_AT)){
    d5ec:	81 ef       	ldi	r24, 0xF1	; 241
    d5ee:	93 e0       	ldi	r25, 0x03	; 3
    d5f0:	61 e0       	ldi	r22, 0x01	; 1
    d5f2:	0e 94 c4 4a 	call	0x9588	; 0x9588 <GSM_Wait_Response_P>
    d5f6:	88 23       	and	r24, r24
    d5f8:	11 f4       	brne	.+4      	; 0xd5fe <GSM_Cycle+0x1294>
    d5fa:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
				StartTimer16(TD_GSM,200);
    d5fe:	80 91 e7 04 	lds	r24, 0x04E7
    d602:	68 ec       	ldi	r22, 0xC8	; 200
    d604:	70 e0       	ldi	r23, 0x00	; 0
    d606:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
				GSM_State++;
    d60a:	80 91 b3 06 	lds	r24, 0x06B3
    d60e:	8f 5f       	subi	r24, 0xFF	; 255
    d610:	80 93 b3 06 	sts	0x06B3, r24
    d614:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
			break;
		case GSM_CFG_SEND_AT:
			if(Timer16Stopp(TD_GSM)) GSM_Execute_Command(AT_AT, 100); GSM_State++;
			break;
		case GSM_CFG_WAIT_AT_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_CFG_SEND_AT)) GSM_State++;
    d618:	81 ef       	ldi	r24, 0xF1	; 241
    d61a:	93 e0       	ldi	r25, 0x03	; 3
    d61c:	61 e0       	ldi	r22, 0x01	; 1
    d61e:	0e 94 c4 4a 	call	0x9588	; 0x9588 <GSM_Wait_Response_P>
    d622:	88 23       	and	r24, r24
    d624:	11 f4       	brne	.+4      	; 0xd62a <GSM_Cycle+0x12c0>
    d626:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
    d62a:	80 91 b3 06 	lds	r24, 0x06B3
    d62e:	8f 5f       	subi	r24, 0xFF	; 255
    d630:	80 93 b3 06 	sts	0x06B3, r24
    d634:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
			StartTimer16(TD_GSM,200);
			GSM_PWRCNTRL_ON();
			GSM_State++;
			break;
		case GSM_CFG_SEND_AT:
			if(Timer16Stopp(TD_GSM)) GSM_Execute_Command(AT_AT, 100); GSM_State++;
    d638:	80 91 e7 04 	lds	r24, 0x04E7
    d63c:	0e 94 71 1c 	call	0x38e2	; 0x38e2 <Timer16Stopp>
    d640:	88 23       	and	r24, r24
    d642:	31 f0       	breq	.+12     	; 0xd650 <GSM_Cycle+0x12e6>
    d644:	8d e6       	ldi	r24, 0x6D	; 109
    d646:	94 e0       	ldi	r25, 0x04	; 4
    d648:	64 e6       	ldi	r22, 0x64	; 100
    d64a:	70 e0       	ldi	r23, 0x00	; 0
    d64c:	0e 94 1f 4b 	call	0x963e	; 0x963e <GSM_Execute_Command>
    d650:	80 91 b3 06 	lds	r24, 0x06B3
    d654:	8f 5f       	subi	r24, 0xFF	; 255
    d656:	80 93 b3 06 	sts	0x06B3, r24
    d65a:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
				StartTimer16(TD_GSM,200);
				GSM_State++;
			}
			break;
		case GSM_SAVE_IPR:
			if(Timer16Stopp(TD_GSM)) GSM_State++;
    d65e:	80 91 e7 04 	lds	r24, 0x04E7
    d662:	0e 94 71 1c 	call	0x38e2	; 0x38e2 <Timer16Stopp>
    d666:	88 23       	and	r24, r24
    d668:	11 f4       	brne	.+4      	; 0xd66e <GSM_Cycle+0x1304>
    d66a:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
    d66e:	80 91 b3 06 	lds	r24, 0x06B3
    d672:	8f 5f       	subi	r24, 0xFF	; 255
    d674:	80 93 b3 06 	sts	0x06B3, r24
    d678:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
			break;
		case GSM_CFG_SEND_IPR:
			GSM_Execute_Command(AT_IPR9600, 100); GSM_State++;
			break;
		case GSM_CFG_WAIT_IPR_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_CFG_SEND_AT)){
    d67c:	81 ef       	ldi	r24, 0xF1	; 241
    d67e:	93 e0       	ldi	r25, 0x03	; 3
    d680:	61 e0       	ldi	r22, 0x01	; 1
    d682:	0e 94 c4 4a 	call	0x9588	; 0x9588 <GSM_Wait_Response_P>
    d686:	88 23       	and	r24, r24
    d688:	11 f4       	brne	.+4      	; 0xd68e <GSM_Cycle+0x1324>
    d68a:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
				StartTimer16(TD_GSM,200);
    d68e:	80 91 e7 04 	lds	r24, 0x04E7
    d692:	68 ec       	ldi	r22, 0xC8	; 200
    d694:	70 e0       	ldi	r23, 0x00	; 0
    d696:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
				GSM_State++;
    d69a:	80 91 b3 06 	lds	r24, 0x06B3
    d69e:	8f 5f       	subi	r24, 0xFF	; 255
    d6a0:	80 93 b3 06 	sts	0x06B3, r24
    d6a4:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
			if(GSM_Wait_Response_P(RESP_OK,GSM_SEND_CSQ)) GSM_State++;
			break;
		case GSM_WAIT_Ballance:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_SEND_CSQ;
			GSM_RxStr[GSM_RXSTR_SIZE-1]='\0';
			while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    d6a8:	00 e0       	ldi	r16, 0x00	; 0
    d6aa:	32 e0       	ldi	r19, 0x02	; 2
    d6ac:	c3 2e       	mov	r12, r19
    d6ae:	d1 2c       	mov	r13, r1
    d6b0:	cc 0e       	add	r12, r28
    d6b2:	dd 1e       	adc	r13, r29
    d6b4:	09 c0       	rjmp	.+18     	; 0xd6c8 <GSM_Cycle+0x135e>
				}

			}//while
			char buf[20];
			uint8_t i=0;
			while( (erb(&GPRS_currency[i])!='\0') && ((erb(&GPRS_currency[i])!=' ')||i==0) ){
    d6b6:	80 32       	cpi	r24, 0x20	; 32
    d6b8:	11 f4       	brne	.+4      	; 0xd6be <GSM_Cycle+0x1354>
    d6ba:	00 23       	and	r16, r16
    d6bc:	71 f4       	brne	.+28     	; 0xd6da <GSM_Cycle+0x1370>
				buf[i] = (char)erb(&GPRS_currency[i]);
    d6be:	ec 0c       	add	r14, r12
    d6c0:	fd 1c       	adc	r15, r13
    d6c2:	f7 01       	movw	r30, r14
    d6c4:	80 83       	st	Z, r24
				i++;
    d6c6:	0f 5f       	subi	r16, 0xFF	; 255
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    d6c8:	e0 2e       	mov	r14, r16
    d6ca:	ff 24       	eor	r15, r15
    d6cc:	c7 01       	movw	r24, r14
    d6ce:	8b 5b       	subi	r24, 0xBB	; 187
    d6d0:	9f 4f       	sbci	r25, 0xFF	; 255
    d6d2:	0e 94 e7 82 	call	0x105ce	; 0x105ce <__eerd_byte_m2560>
				}

			}//while
			char buf[20];
			uint8_t i=0;
			while( (erb(&GPRS_currency[i])!='\0') && ((erb(&GPRS_currency[i])!=' ')||i==0) ){
    d6d6:	88 23       	and	r24, r24
    d6d8:	71 f7       	brne	.-36     	; 0xd6b6 <GSM_Cycle+0x134c>
				buf[i] = (char)erb(&GPRS_currency[i]);
				i++;
			}
			buf[i]='\0';
    d6da:	ec 0c       	add	r14, r12
    d6dc:	fd 1c       	adc	r15, r13
    d6de:	d7 01       	movw	r26, r14
    d6e0:	1c 92       	st	X, r1
			char *istr=strstr(GSM_RxStr, buf);
    d6e2:	89 e9       	ldi	r24, 0x99	; 153
    d6e4:	97 e0       	ldi	r25, 0x07	; 7
    d6e6:	b6 01       	movw	r22, r12
    d6e8:	0e 94 31 80 	call	0x10062	; 0x10062 <strstr>
			if(istr)
    d6ec:	00 97       	sbiw	r24, 0x00	; 0
    d6ee:	11 f4       	brne	.+4      	; 0xd6f4 <GSM_Cycle+0x138a>
    d6f0:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
			{
					Ballance=*(istr-1)-0x30;
    d6f4:	fc 01       	movw	r30, r24
    d6f6:	82 91       	ld	r24, -Z
    d6f8:	90 e0       	ldi	r25, 0x00	; 0
    d6fa:	c0 97       	sbiw	r24, 0x30	; 48
    d6fc:	aa 27       	eor	r26, r26
    d6fe:	97 fd       	sbrc	r25, 7
    d700:	a0 95       	com	r26
    d702:	ba 2f       	mov	r27, r26
    d704:	80 93 b8 06 	sts	0x06B8, r24
    d708:	90 93 b9 06 	sts	0x06B9, r25
    d70c:	a0 93 ba 06 	sts	0x06BA, r26
    d710:	b0 93 bb 06 	sts	0x06BB, r27
					Ballance+=(*(istr-2)-0x30)*10;
    d714:	22 91       	ld	r18, -Z
    d716:	8f 01       	movw	r16, r30
    d718:	4a e0       	ldi	r20, 0x0A	; 10
    d71a:	24 9f       	mul	r18, r20
    d71c:	90 01       	movw	r18, r0
    d71e:	11 24       	eor	r1, r1
    d720:	20 5e       	subi	r18, 0xE0	; 224
    d722:	31 40       	sbci	r19, 0x01	; 1
    d724:	49 01       	movw	r8, r18
    d726:	aa 24       	eor	r10, r10
    d728:	97 fc       	sbrc	r9, 7
    d72a:	a0 94       	com	r10
    d72c:	ba 2c       	mov	r11, r10
    d72e:	88 0e       	add	r8, r24
    d730:	99 1e       	adc	r9, r25
    d732:	aa 1e       	adc	r10, r26
    d734:	bb 1e       	adc	r11, r27
    d736:	80 92 b8 06 	sts	0x06B8, r8
    d73a:	90 92 b9 06 	sts	0x06B9, r9
    d73e:	a0 92 ba 06 	sts	0x06BA, r10
    d742:	b0 92 bb 06 	sts	0x06BB, r11
					uint8_t charnum=4;
					uint32_t razr=100;
					while((*(istr-charnum)>=0x30)&&(*(istr-charnum)<=0x39)){
    d746:	02 50       	subi	r16, 0x02	; 2
    d748:	10 40       	sbci	r17, 0x00	; 0
    d74a:	d8 01       	movw	r26, r16
    d74c:	6c 91       	ld	r22, X
    d74e:	0c 5f       	subi	r16, 0xFC	; 252
    d750:	1f 4f       	sbci	r17, 0xFF	; 255
    d752:	86 2f       	mov	r24, r22
    d754:	80 53       	subi	r24, 0x30	; 48
    d756:	8a 30       	cpi	r24, 0x0A	; 10
    d758:	88 f5       	brcc	.+98     	; 0xd7bc <GSM_Cycle+0x1452>
    d75a:	24 e0       	ldi	r18, 0x04	; 4
    d75c:	72 2e       	mov	r7, r18
    d75e:	94 e6       	ldi	r25, 0x64	; 100
    d760:	c9 2e       	mov	r12, r25
    d762:	d1 2c       	mov	r13, r1
    d764:	e1 2c       	mov	r14, r1
    d766:	f1 2c       	mov	r15, r1
						Ballance+=(*(istr-charnum)-0x30)*razr;
    d768:	70 e0       	ldi	r23, 0x00	; 0
    d76a:	60 53       	subi	r22, 0x30	; 48
    d76c:	70 40       	sbci	r23, 0x00	; 0
    d76e:	88 27       	eor	r24, r24
    d770:	77 fd       	sbrc	r23, 7
    d772:	80 95       	com	r24
    d774:	98 2f       	mov	r25, r24
    d776:	a7 01       	movw	r20, r14
    d778:	96 01       	movw	r18, r12
    d77a:	0e 94 23 83 	call	0x10646	; 0x10646 <__mulsi3>
    d77e:	86 0e       	add	r8, r22
    d780:	97 1e       	adc	r9, r23
    d782:	a8 1e       	adc	r10, r24
    d784:	b9 1e       	adc	r11, r25
    d786:	80 92 b8 06 	sts	0x06B8, r8
    d78a:	90 92 b9 06 	sts	0x06B9, r9
    d78e:	a0 92 ba 06 	sts	0x06BA, r10
    d792:	b0 92 bb 06 	sts	0x06BB, r11
						razr*=10;
    d796:	c7 01       	movw	r24, r14
    d798:	b6 01       	movw	r22, r12
    d79a:	2a e0       	ldi	r18, 0x0A	; 10
    d79c:	30 e0       	ldi	r19, 0x00	; 0
    d79e:	40 e0       	ldi	r20, 0x00	; 0
    d7a0:	50 e0       	ldi	r21, 0x00	; 0
    d7a2:	0e 94 23 83 	call	0x10646	; 0x10646 <__mulsi3>
    d7a6:	6b 01       	movw	r12, r22
    d7a8:	7c 01       	movw	r14, r24
						charnum++;	
    d7aa:	73 94       	inc	r7
			{
					Ballance=*(istr-1)-0x30;
					Ballance+=(*(istr-2)-0x30)*10;
					uint8_t charnum=4;
					uint32_t razr=100;
					while((*(istr-charnum)>=0x30)&&(*(istr-charnum)<=0x39)){
    d7ac:	f8 01       	movw	r30, r16
    d7ae:	e7 19       	sub	r30, r7
    d7b0:	f1 09       	sbc	r31, r1
    d7b2:	60 81       	ld	r22, Z
    d7b4:	86 2f       	mov	r24, r22
    d7b6:	80 53       	subi	r24, 0x30	; 48
    d7b8:	8a 30       	cpi	r24, 0x0A	; 10
    d7ba:	b0 f2       	brcs	.-84     	; 0xd768 <GSM_Cycle+0x13fe>
						Ballance+=(*(istr-charnum)-0x30)*razr;
						razr*=10;
						charnum++;	
					}
					if(*(istr-charnum)==0x2D)
    d7bc:	6d 32       	cpi	r22, 0x2D	; 45
    d7be:	11 f0       	breq	.+4      	; 0xd7c4 <GSM_Cycle+0x145a>
    d7c0:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
					{
						Ballance*=-1;
    d7c4:	80 91 b8 06 	lds	r24, 0x06B8
    d7c8:	90 91 b9 06 	lds	r25, 0x06B9
    d7cc:	a0 91 ba 06 	lds	r26, 0x06BA
    d7d0:	b0 91 bb 06 	lds	r27, 0x06BB
    d7d4:	b0 95       	com	r27
    d7d6:	a0 95       	com	r26
    d7d8:	90 95       	com	r25
    d7da:	81 95       	neg	r24
    d7dc:	9f 4f       	sbci	r25, 0xFF	; 255
    d7de:	af 4f       	sbci	r26, 0xFF	; 255
    d7e0:	bf 4f       	sbci	r27, 0xFF	; 255
    d7e2:	80 93 b8 06 	sts	0x06B8, r24
    d7e6:	90 93 b9 06 	sts	0x06B9, r25
    d7ea:	a0 93 ba 06 	sts	0x06BA, r26
    d7ee:	b0 93 bb 06 	sts	0x06BB, r27
    d7f2:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
					GSM_State = GSM_WAIT_DISCONNECT_CAUSE;
					StartTimer16(TD_GSM, 10000);
					break;
				}
			}
			if(Timer16Stopp(TD_GSM)){
    d7f6:	80 91 e7 04 	lds	r24, 0x04E7
    d7fa:	0e 94 71 1c 	call	0x38e2	; 0x38e2 <Timer16Stopp>
    d7fe:	88 23       	and	r24, r24
    d800:	11 f4       	brne	.+4      	; 0xd806 <GSM_Cycle+0x149c>
    d802:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
				GSM_State = GSM_WAIT_MESSAGE;
    d806:	8e e0       	ldi	r24, 0x0E	; 14
    d808:	80 93 b3 06 	sts	0x06B3, r24
    d80c:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
				if((strstr_P(GSM_RxStr, PSTR("+CREC: 0")) != NULL) ){
					GSM_State = GSM_SEND_PLAY_CONFIRM_FILE;
					break;
				}
			}
			if(Timer16Stopp(TD_GSM)){
    d810:	80 91 e7 04 	lds	r24, 0x04E7
    d814:	0e 94 71 1c 	call	0x38e2	; 0x38e2 <Timer16Stopp>
    d818:	88 23       	and	r24, r24
    d81a:	11 f4       	brne	.+4      	; 0xd820 <GSM_Cycle+0x14b6>
    d81c:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
				GSM_State = GSM_WAIT_MESSAGE;
    d820:	8e e0       	ldi	r24, 0x0E	; 14
    d822:	80 93 b3 06 	sts	0x06B3, r24
    d826:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
			if(GetStringFromFIFO()){
				SetIP(&GSM_MyIP,0,0,0,0);
				for(uint8_t i=0; i<strlen(GSM_RxStr); i++)
					if(!isdigit(GSM_RxStr[i])) GSM_RxStr[i] = ' ';
				sscanf_P(GSM_RxStr,PSTR("%hhu %hhu %hhu %hhu"), (unsigned char*)&GSM_MyIP.IP1, (unsigned char*)&GSM_MyIP.IP2, (unsigned char*)&GSM_MyIP.IP3, (unsigned char*)&GSM_MyIP.IP4);
    d82a:	ed b7       	in	r30, 0x3d	; 61
    d82c:	fe b7       	in	r31, 0x3e	; 62
    d82e:	3c 97       	sbiw	r30, 0x0c	; 12
    d830:	0f b6       	in	r0, 0x3f	; 63
    d832:	f8 94       	cli
    d834:	fe bf       	out	0x3e, r31	; 62
    d836:	0f be       	out	0x3f, r0	; 63
    d838:	ed bf       	out	0x3d, r30	; 61
    d83a:	31 96       	adiw	r30, 0x01	; 1
    d83c:	89 e9       	ldi	r24, 0x99	; 153
    d83e:	97 e0       	ldi	r25, 0x07	; 7
    d840:	ad b7       	in	r26, 0x3d	; 61
    d842:	be b7       	in	r27, 0x3e	; 62
    d844:	12 96       	adiw	r26, 0x02	; 2
    d846:	9c 93       	st	X, r25
    d848:	8e 93       	st	-X, r24
    d84a:	11 97       	sbiw	r26, 0x01	; 1
    d84c:	8a e0       	ldi	r24, 0x0A	; 10
    d84e:	9c e2       	ldi	r25, 0x2C	; 44
    d850:	93 83       	std	Z+3, r25	; 0x03
    d852:	82 83       	std	Z+2, r24	; 0x02
    d854:	55 83       	std	Z+5, r21	; 0x05
    d856:	44 83       	std	Z+4, r20	; 0x04
    d858:	77 83       	std	Z+7, r23	; 0x07
    d85a:	66 83       	std	Z+6, r22	; 0x06
    d85c:	11 87       	std	Z+9, r17	; 0x09
    d85e:	00 87       	std	Z+8, r16	; 0x08
    d860:	f3 86       	std	Z+11, r15	; 0x0b
    d862:	e2 86       	std	Z+10, r14	; 0x0a
    d864:	0e 94 3e 81 	call	0x1027c	; 0x1027c <sscanf_P>
}
uint8_t IP_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	if((IP->IP1 == IP1) && (IP->IP2 == IP2) && (IP->IP3 == IP3) && (IP->IP4 == IP4)) return 1;
    d868:	ed b7       	in	r30, 0x3d	; 61
    d86a:	fe b7       	in	r31, 0x3e	; 62
    d86c:	3c 96       	adiw	r30, 0x0c	; 12
    d86e:	0f b6       	in	r0, 0x3f	; 63
    d870:	f8 94       	cli
    d872:	fe bf       	out	0x3e, r31	; 62
    d874:	0f be       	out	0x3f, r0	; 63
    d876:	ed bf       	out	0x3d, r30	; 61
    d878:	80 91 e9 08 	lds	r24, 0x08E9
    d87c:	88 23       	and	r24, r24
    d87e:	09 f0       	breq	.+2      	; 0xd882 <GSM_Cycle+0x1518>
    d880:	96 c0       	rjmp	.+300    	; 0xd9ae <GSM_Cycle+0x1644>
    d882:	80 91 ea 08 	lds	r24, 0x08EA
    d886:	88 23       	and	r24, r24
    d888:	09 f0       	breq	.+2      	; 0xd88c <GSM_Cycle+0x1522>
    d88a:	91 c0       	rjmp	.+290    	; 0xd9ae <GSM_Cycle+0x1644>
    d88c:	80 91 eb 08 	lds	r24, 0x08EB
    d890:	88 23       	and	r24, r24
    d892:	09 f0       	breq	.+2      	; 0xd896 <GSM_Cycle+0x152c>
    d894:	8c c0       	rjmp	.+280    	; 0xd9ae <GSM_Cycle+0x1644>
    d896:	80 91 ec 08 	lds	r24, 0x08EC
    d89a:	88 23       	and	r24, r24
    d89c:	09 f0       	breq	.+2      	; 0xd8a0 <GSM_Cycle+0x1536>
    d89e:	87 c0       	rjmp	.+270    	; 0xd9ae <GSM_Cycle+0x1644>
				if(!IP_compare_Const(&GSM_MyIP,0,0,0,0)){
				  GSM_State = GSM_SEND_CIPSTART_TCP_CLIENT;
				}
				TempNum=0;	//
    d8a0:	10 92 da 05 	sts	0x05DA, r1
    d8a4:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
				if((strstr_P(GSM_RxStr, PSTR("+CREC: 0")) != NULL) ){
					GSM_State = GSM_WAIT_CONFIRMRESPONSE;
					StartTimer16(TD_GSM, 200);
					break;
				}
				if(analize_DTMF()){
    d8a8:	0e 94 32 4b 	call	0x9664	; 0x9664 <analize_DTMF>
    d8ac:	88 23       	and	r24, r24
    d8ae:	11 f0       	breq	.+4      	; 0xd8b4 <GSM_Cycle+0x154a>
    d8b0:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
					break;
				}
			}
			if(Timer16Stopp(TD_GSM)){
    d8b4:	80 91 e7 04 	lds	r24, 0x04E7
    d8b8:	0e 94 71 1c 	call	0x38e2	; 0x38e2 <Timer16Stopp>
    d8bc:	88 23       	and	r24, r24
    d8be:	11 f4       	brne	.+4      	; 0xd8c4 <GSM_Cycle+0x155a>
    d8c0:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
				GSM_State = GSM_WAIT_MESSAGE;
    d8c4:	8e e0       	ldi	r24, 0x0E	; 14
    d8c6:	80 93 b3 06 	sts	0x06B3, r24
    d8ca:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
			if(GetStringFromFIFO()){
				if((strstr_P(GSM_RxStr, PSTR("+CREC: 0")) != NULL) ){
					GSM_State = GSM_SEND_PLAY_CONFIRMREQUEST_FILE;
					break;
				}
				if(analize_DTMF()){
    d8ce:	0e 94 32 4b 	call	0x9664	; 0x9664 <analize_DTMF>
    d8d2:	88 23       	and	r24, r24
    d8d4:	11 f0       	breq	.+4      	; 0xd8da <GSM_Cycle+0x1570>
    d8d6:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
					break;
				}
			}
			if(Timer16Stopp(TD_GSM)){
    d8da:	80 91 e7 04 	lds	r24, 0x04E7
    d8de:	0e 94 71 1c 	call	0x38e2	; 0x38e2 <Timer16Stopp>
    d8e2:	88 23       	and	r24, r24
    d8e4:	11 f4       	brne	.+4      	; 0xd8ea <GSM_Cycle+0x1580>
    d8e6:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
				GSM_State = GSM_WAIT_MESSAGE;
    d8ea:	8e e0       	ldi	r24, 0x0E	; 14
    d8ec:	80 93 b3 06 	sts	0x06B3, r24
    d8f0:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
			if(GSM_Wait_Response_P(RESP_OK, GSM_WAIT_MESSAGE)) GSM_State = GSM_WAIT_CCLC_2;
			StartTimer16(TD_GSM, 1000);
			break;
		case GSM_WAIT_CCLC_2:
			if(GetStringFromFIFO()){
				if( (strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,2,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 2,0,2,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 3,0,2,")) != NULL) ){
    d8f4:	89 e9       	ldi	r24, 0x99	; 153
    d8f6:	97 e0       	ldi	r25, 0x07	; 7
    d8f8:	65 ef       	ldi	r22, 0xF5	; 245
    d8fa:	7d e2       	ldi	r23, 0x2D	; 45
    d8fc:	0e 94 ef 7f 	call	0xffde	; 0xffde <strstr_P>
    d900:	89 2b       	or	r24, r25
    d902:	09 f0       	breq	.+2      	; 0xd906 <GSM_Cycle+0x159c>
    d904:	d8 c9       	rjmp	.-3152   	; 0xccb6 <GSM_Cycle+0x94c>
    d906:	89 e9       	ldi	r24, 0x99	; 153
    d908:	97 e0       	ldi	r25, 0x07	; 7
    d90a:	67 ee       	ldi	r22, 0xE7	; 231
    d90c:	7d e2       	ldi	r23, 0x2D	; 45
    d90e:	0e 94 ef 7f 	call	0xffde	; 0xffde <strstr_P>
    d912:	89 2b       	or	r24, r25
    d914:	09 f0       	breq	.+2      	; 0xd918 <GSM_Cycle+0x15ae>
    d916:	cf c9       	rjmp	.-3170   	; 0xccb6 <GSM_Cycle+0x94c>
					StartTimer16(TD_GSM, 2000);
					GSM_State = GSM_WAIT_CCLC_3;
					break;
				}
			}
			if(Timer16Stopp(TD_GSM)){
    d918:	80 91 e7 04 	lds	r24, 0x04E7
    d91c:	0e 94 71 1c 	call	0x38e2	; 0x38e2 <Timer16Stopp>
    d920:	88 23       	and	r24, r24
    d922:	11 f4       	brne	.+4      	; 0xd928 <GSM_Cycle+0x15be>
    d924:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
				GSM_State = GSM_WAIT_MESSAGE;
    d928:	8e e0       	ldi	r24, 0x0E	; 14
    d92a:	80 93 b3 06 	sts	0x06B3, r24
    d92e:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
				if( (strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 2,0,6,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 3,0,6,")) != NULL) ){
					StartTimer16(TD_GSM, 6000);
					GSM_State = GSM_WAIT_MESSAGE;
					break;
				}
				if( (strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,3,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 2,0,3,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 3,0,3,")) != NULL) ){
    d932:	89 e9       	ldi	r24, 0x99	; 153
    d934:	97 e0       	ldi	r25, 0x07	; 7
    d936:	61 ea       	ldi	r22, 0xA1	; 161
    d938:	7d e2       	ldi	r23, 0x2D	; 45
    d93a:	0e 94 ef 7f 	call	0xffde	; 0xffde <strstr_P>
    d93e:	89 2b       	or	r24, r25
    d940:	09 f0       	breq	.+2      	; 0xd944 <GSM_Cycle+0x15da>
    d942:	cc c2       	rjmp	.+1432   	; 0xdedc <GSM_Cycle+0x1b72>
    d944:	89 e9       	ldi	r24, 0x99	; 153
    d946:	97 e0       	ldi	r25, 0x07	; 7
    d948:	63 e9       	ldi	r22, 0x93	; 147
    d94a:	7d e2       	ldi	r23, 0x2D	; 45
    d94c:	0e 94 ef 7f 	call	0xffde	; 0xffde <strstr_P>
    d950:	89 2b       	or	r24, r25
    d952:	09 f0       	breq	.+2      	; 0xd956 <GSM_Cycle+0x15ec>
    d954:	c3 c2       	rjmp	.+1414   	; 0xdedc <GSM_Cycle+0x1b72>
					GSM_State = GSM_WAIT_CCLC_0;
					break;
				}

			}
			if(Timer16Stopp(TD_GSM)){
    d956:	80 91 e7 04 	lds	r24, 0x04E7
    d95a:	0e 94 71 1c 	call	0x38e2	; 0x38e2 <Timer16Stopp>
    d95e:	88 23       	and	r24, r24
    d960:	11 f4       	brne	.+4      	; 0xd966 <GSM_Cycle+0x15fc>
    d962:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
				GSM_State = GSM_WAIT_MESSAGE;
    d966:	8e e0       	ldi	r24, 0x0E	; 14
    d968:	80 93 b3 06 	sts	0x06B3, r24
    d96c:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
				if((strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,0,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,0,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,0,")) != NULL) ){
					RequestRepeatCounter = 0;
					GSM_State = GSM_SEND_PLAY_ALARM_FILE;
					break;
				}
				if( (strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6,")) != NULL)){
    d970:	89 e9       	ldi	r24, 0x99	; 153
    d972:	97 e0       	ldi	r25, 0x07	; 7
    d974:	6d e4       	ldi	r22, 0x4D	; 77
    d976:	7d e2       	ldi	r23, 0x2D	; 45
    d978:	0e 94 ef 7f 	call	0xffde	; 0xffde <strstr_P>
    d97c:	89 2b       	or	r24, r25
    d97e:	09 f0       	breq	.+2      	; 0xd982 <GSM_Cycle+0x1618>
    d980:	e3 c2       	rjmp	.+1478   	; 0xdf48 <GSM_Cycle+0x1bde>
    d982:	89 e9       	ldi	r24, 0x99	; 153
    d984:	97 e0       	ldi	r25, 0x07	; 7
    d986:	6f e3       	ldi	r22, 0x3F	; 63
    d988:	7d e2       	ldi	r23, 0x2D	; 45
    d98a:	0e 94 ef 7f 	call	0xffde	; 0xffde <strstr_P>
    d98e:	89 2b       	or	r24, r25
    d990:	09 f0       	breq	.+2      	; 0xd994 <GSM_Cycle+0x162a>
    d992:	da c2       	rjmp	.+1460   	; 0xdf48 <GSM_Cycle+0x1bde>
					StartTimer16(TD_GSM, 6000);
					GSM_State = GSM_WAIT_DISCONNECT_CAUSE;
					break;
				}
			}
			if(Timer16Stopp(TD_GSM)){
    d994:	80 91 e7 04 	lds	r24, 0x04E7
    d998:	0e 94 71 1c 	call	0x38e2	; 0x38e2 <Timer16Stopp>
    d99c:	88 23       	and	r24, r24
    d99e:	11 f4       	brne	.+4      	; 0xd9a4 <GSM_Cycle+0x163a>
    d9a0:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
				GSM_State = GSM_WAIT_MESSAGE;
    d9a4:	8e e0       	ldi	r24, 0x0E	; 14
    d9a6:	80 93 b3 06 	sts	0x06B3, r24
    d9aa:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
				SetIP(&GSM_MyIP,0,0,0,0);
				for(uint8_t i=0; i<strlen(GSM_RxStr); i++)
					if(!isdigit(GSM_RxStr[i])) GSM_RxStr[i] = ' ';
				sscanf_P(GSM_RxStr,PSTR("%hhu %hhu %hhu %hhu"), (unsigned char*)&GSM_MyIP.IP1, (unsigned char*)&GSM_MyIP.IP2, (unsigned char*)&GSM_MyIP.IP3, (unsigned char*)&GSM_MyIP.IP4);
				if(!IP_compare_Const(&GSM_MyIP,0,0,0,0)){
				  GSM_State = GSM_SEND_CIPSTART_TCP_CLIENT;
    d9ae:	8b e3       	ldi	r24, 0x3B	; 59
    d9b0:	80 93 b3 06 	sts	0x06B3, r24
    d9b4:	75 cf       	rjmp	.-278    	; 0xd8a0 <GSM_Cycle+0x1536>
					break;
				}
				GSM_State = GSM_WAIT_MESSAGE;
				break;
			}
			if(Timer16Stopp(TD_GSM)){
    d9b6:	80 91 e7 04 	lds	r24, 0x04E7
    d9ba:	0e 94 71 1c 	call	0x38e2	; 0x38e2 <Timer16Stopp>
    d9be:	88 23       	and	r24, r24
    d9c0:	11 f4       	brne	.+4      	; 0xd9c6 <GSM_Cycle+0x165c>
    d9c2:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
				GSM_State = GSM_WAIT_MESSAGE;
    d9c6:	8e e0       	ldi	r24, 0x0E	; 14
    d9c8:	80 93 b3 06 	sts	0x06B3, r24
    d9cc:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State=GSM_SEND_ATD_Check_Ballance;
			break;
		//------------------------
		case GSM_SEND_CIPMUX:
			if(GSM_MultiCon) GSM_Execute_Command(AT_CIPMUX_1, 100*GSM_DEBUG_DELAY);
			else GSM_Execute_Command(AT_CIPMUX_0, 100*GSM_DEBUG_DELAY);
    d9d0:	85 e1       	ldi	r24, 0x15	; 21
    d9d2:	95 e0       	ldi	r25, 0x05	; 5
    d9d4:	64 e6       	ldi	r22, 0x64	; 100
    d9d6:	70 e0       	ldi	r23, 0x00	; 0
    d9d8:	0e 94 1f 4b 	call	0x963e	; 0x963e <GSM_Execute_Command>
    d9dc:	a1 cb       	rjmp	.-2238   	; 0xd120 <GSM_Cycle+0xdb6>
			sprintf(GSM_TxStr+GSMTxSz,"%u",Message[2]);
			if(Message[2]>9){
				GSMTxSz+=2;
			}
			else{
				GSMTxSz++;
    d9de:	80 91 75 07 	lds	r24, 0x0775
    d9e2:	8f 5f       	subi	r24, 0xFF	; 255
    d9e4:	80 93 75 07 	sts	0x0775, r24
    d9e8:	b8 c9       	rjmp	.-3216   	; 0xcd5a <GSM_Cycle+0x9f0>
				else GSM_State++;
			}
			break;
		case GSM_SEND_CIPMODE:
			if(GSM_MultiCon) GSM_Execute_Command(AT_CIPMODE_0, 100*GSM_DEBUG_DELAY);
			else GSM_Execute_Command(AT_CIPMODE_1, 100*GSM_DEBUG_DELAY);
    d9ea:	88 e0       	ldi	r24, 0x08	; 8
    d9ec:	95 e0       	ldi	r25, 0x05	; 5
    d9ee:	64 e6       	ldi	r22, 0x64	; 100
    d9f0:	70 e0       	ldi	r23, 0x00	; 0
    d9f2:	0e 94 1f 4b 	call	0x963e	; 0x963e <GSM_Execute_Command>
    d9f6:	70 cb       	rjmp	.-2336   	; 0xd0d8 <GSM_Cycle+0xd6e>
					if(GSM_RxCharN==2)
						{
							if(!strncmp_P(GSM_RxStr, PSTR("\r\n"), 2)) {GSM_RxCharN=0;}
						}
					if(GSM_RxCharN >= 4){
						AppProtocol = 0;
    d9f8:	10 92 9f 08 	sts	0x089F, r1
						if(!strncmp_P(GSM_RxStr, PSTR("GET "), 4)) {AppProtocol = _HTTP;GSM_State = GSM_DataMode;break;}//GET
    d9fc:	89 e9       	ldi	r24, 0x99	; 153
    d9fe:	97 e0       	ldi	r25, 0x07	; 7
    da00:	62 ee       	ldi	r22, 0xE2	; 226
    da02:	7b e2       	ldi	r23, 0x2B	; 43
    da04:	44 e0       	ldi	r20, 0x04	; 4
    da06:	50 e0       	ldi	r21, 0x00	; 0
    da08:	0e 94 d6 7f 	call	0xffac	; 0xffac <strncmp_P>
    da0c:	89 2b       	or	r24, r25
    da0e:	09 f4       	brne	.+2      	; 0xda12 <GSM_Cycle+0x16a8>
    da10:	1d c3       	rjmp	.+1594   	; 0xe04c <GSM_Cycle+0x1ce2>
						if(!strncmp_P(GSM_RxStr, PSTR("POST"), 4)) {AppProtocol = _HTTP;GSM_State = GSM_DataMode;break;}//POST
    da12:	89 e9       	ldi	r24, 0x99	; 153
    da14:	97 e0       	ldi	r25, 0x07	; 7
    da16:	6d ed       	ldi	r22, 0xDD	; 221
    da18:	7b e2       	ldi	r23, 0x2B	; 43
    da1a:	44 e0       	ldi	r20, 0x04	; 4
    da1c:	50 e0       	ldi	r21, 0x00	; 0
    da1e:	0e 94 d6 7f 	call	0xffac	; 0xffac <strncmp_P>
    da22:	89 2b       	or	r24, r25
    da24:	09 f4       	brne	.+2      	; 0xda28 <GSM_Cycle+0x16be>
    da26:	12 c3       	rjmp	.+1572   	; 0xe04c <GSM_Cycle+0x1ce2>
						if(!strncmp_P(GSM_RxStr, PSTR("CLOS"), 4)) {AppProtocol = _HTTP;GSM_State = GSM_ReStart1;break;}// 
    da28:	89 e9       	ldi	r24, 0x99	; 153
    da2a:	97 e0       	ldi	r25, 0x07	; 7
    da2c:	68 ed       	ldi	r22, 0xD8	; 216
    da2e:	7b e2       	ldi	r23, 0x2B	; 43
    da30:	44 e0       	ldi	r20, 0x04	; 4
    da32:	50 e0       	ldi	r21, 0x00	; 0
    da34:	0e 94 d6 7f 	call	0xffac	; 0xffac <strncmp_P>
    da38:	89 2b       	or	r24, r25
    da3a:	09 f4       	brne	.+2      	; 0xda3e <GSM_Cycle+0x16d4>
    da3c:	1a c3       	rjmp	.+1588   	; 0xe072 <GSM_Cycle+0x1d08>
						if(!strncmp_P(GSM_RxStr, PSTR("+PDP"), 4)) {AppProtocol = _HTTP;GSM_State = GSM_ReStart1;break;}//GPRS 
    da3e:	89 e9       	ldi	r24, 0x99	; 153
    da40:	97 e0       	ldi	r25, 0x07	; 7
    da42:	63 ed       	ldi	r22, 0xD3	; 211
    da44:	7b e2       	ldi	r23, 0x2B	; 43
    da46:	44 e0       	ldi	r20, 0x04	; 4
    da48:	50 e0       	ldi	r21, 0x00	; 0
    da4a:	0e 94 d6 7f 	call	0xffac	; 0xffac <strncmp_P>
    da4e:	89 2b       	or	r24, r25
    da50:	09 f4       	brne	.+2      	; 0xda54 <GSM_Cycle+0x16ea>
    da52:	0f c3       	rjmp	.+1566   	; 0xe072 <GSM_Cycle+0x1d08>
						if( (GSM_RxStr[0]==0) && (GSM_RxStr[1]==0)){AppProtocol = _HTTP;GSM_State = GSM_ReStart1;break;}//  
    da54:	80 91 99 07 	lds	r24, 0x0799
    da58:	88 23       	and	r24, r24
    da5a:	29 f4       	brne	.+10     	; 0xda66 <GSM_Cycle+0x16fc>
    da5c:	80 91 9a 07 	lds	r24, 0x079A
    da60:	88 23       	and	r24, r24
    da62:	09 f4       	brne	.+2      	; 0xda66 <GSM_Cycle+0x16fc>
    da64:	06 c3       	rjmp	.+1548   	; 0xe072 <GSM_Cycle+0x1d08>
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    da66:	8f ef       	ldi	r24, 0xFF	; 255
    da68:	80 93 fa 06 	sts	0x06FA, r24
	GSM_RX_FIFO_End = 255;
    da6c:	80 93 51 06 	sts	0x0651, r24
	GSM_RxCharN = 0;
    da70:	10 92 18 0b 	sts	0x0B18, r1
	GSM_RX_FIFOOverFlow = 0;
    da74:	10 92 cb 08 	sts	0x08CB, r1
	GSM_RX_FIFOMax = 0;
    da78:	10 92 d1 08 	sts	0x08D1, r1
						StartTimer16(TD_CleanFIFO,500);
						//break;
					}
				}//while
				//GSM_RxCharN=0;
				if(Timer16Stopp(TD_CleanFIFO)&&(GSM_RX_FIFO_Begin == GSM_RX_FIFO_End)){
    da7c:	80 91 ed 04 	lds	r24, 0x04ED
    da80:	0e 94 71 1c 	call	0x38e2	; 0x38e2 <Timer16Stopp>
    da84:	88 23       	and	r24, r24
    da86:	b9 f0       	breq	.+46     	; 0xdab6 <GSM_Cycle+0x174c>
    da88:	90 91 fa 06 	lds	r25, 0x06FA
    da8c:	80 91 51 06 	lds	r24, 0x0651
    da90:	98 17       	cp	r25, r24
    da92:	89 f4       	brne	.+34     	; 0xdab6 <GSM_Cycle+0x174c>
					StartTimer16(TD_CleanFIFO,500);
    da94:	80 91 ed 04 	lds	r24, 0x04ED
    da98:	64 ef       	ldi	r22, 0xF4	; 244
    da9a:	71 e0       	ldi	r23, 0x01	; 1
    da9c:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    daa0:	8f ef       	ldi	r24, 0xFF	; 255
    daa2:	80 93 fa 06 	sts	0x06FA, r24
	GSM_RX_FIFO_End = 255;
    daa6:	80 93 51 06 	sts	0x0651, r24
	GSM_RxCharN = 0;
    daaa:	10 92 18 0b 	sts	0x0B18, r1
	GSM_RX_FIFOOverFlow = 0;
    daae:	10 92 cb 08 	sts	0x08CB, r1
	GSM_RX_FIFOMax = 0;
    dab2:	10 92 d1 08 	sts	0x08D1, r1
				if(Timer16Stopp(TD_CleanFIFO)&&(GSM_RX_FIFO_Begin == GSM_RX_FIFO_End)){
					StartTimer16(TD_CleanFIFO,500);
					InitFIFO();
				}

				if(Timer16Stopp(TD_data_start_delay)){
    dab6:	80 91 ee 04 	lds	r24, 0x04EE
    daba:	0e 94 71 1c 	call	0x38e2	; 0x38e2 <Timer16Stopp>
    dabe:	88 23       	and	r24, r24
    dac0:	11 f4       	brne	.+4      	; 0xdac6 <GSM_Cycle+0x175c>
    dac2:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
					if(GPRS_FlgSz_Out && (GPRS_FlgSz_Out <= GPRS_Out_MaxSz)&&(GSM_Flag&(1<<flg_TxCStr))&&Timer16Stopp(TD_timer_after_page_transfer)&&(!dataSendFlg)){			
    dac6:	80 91 6d 07 	lds	r24, 0x076D
    daca:	88 23       	and	r24, r24
    dacc:	11 f4       	brne	.+4      	; 0xdad2 <GSM_Cycle+0x1768>
    dace:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
    dad2:	80 91 d2 02 	lds	r24, 0x02D2
    dad6:	80 fd       	sbrc	r24, 0
    dad8:	02 c0       	rjmp	.+4      	; 0xdade <GSM_Cycle+0x1774>
    dada:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
    dade:	80 91 ef 04 	lds	r24, 0x04EF
    dae2:	0e 94 71 1c 	call	0x38e2	; 0x38e2 <Timer16Stopp>
    dae6:	88 23       	and	r24, r24
    dae8:	11 f4       	brne	.+4      	; 0xdaee <GSM_Cycle+0x1784>
    daea:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
    daee:	80 91 df 02 	lds	r24, 0x02DF
    daf2:	88 23       	and	r24, r24
    daf4:	11 f0       	breq	.+4      	; 0xdafa <GSM_Cycle+0x1790>
    daf6:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
							dataSendFlg=1;
    dafa:	81 e0       	ldi	r24, 0x01	; 1
    dafc:	80 93 df 02 	sts	0x02DF, r24
							GSM_AddHeaderSendData(GPRS_Data_Out, GPRS_FlgSz_Out);
    db00:	8e ef       	ldi	r24, 0xFE	; 254
    db02:	98 e0       	ldi	r25, 0x08	; 8
    db04:	60 91 6d 07 	lds	r22, 0x076D
    db08:	0e 94 b2 40 	call	0x8164	; 0x8164 <GSM_AddHeaderSendData>
    db0c:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
		/*	if(Timer16Stopp(TD_TCP_Connect)){	//        CommandMode
				GSM_State = GSM_Swtch2CommandMode;
				break;
			}*/
			//StartTimer16(TD_CheckModem,1000);
			if( (strstr_P(GSM_RxStr, URC_CLOSED+2) != NULL) ){
    db10:	89 e9       	ldi	r24, 0x99	; 153
    db12:	97 e0       	ldi	r25, 0x07	; 7
    db14:	64 ed       	ldi	r22, 0xD4	; 212
    db16:	73 e0       	ldi	r23, 0x03	; 3
    db18:	0e 94 ef 7f 	call	0xffde	; 0xffde <strstr_P>
    db1c:	89 2b       	or	r24, r25
    db1e:	11 f4       	brne	.+4      	; 0xdb24 <GSM_Cycle+0x17ba>
    db20:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
				GSM_State =GSM_ReStart1;
    db24:	8a e4       	ldi	r24, 0x4A	; 74
    db26:	80 93 b3 06 	sts	0x06B3, r24
    db2a:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
		case GSM_WAIT_CSQ:
				if(Timer16Stopp(TD_GSM)){
						GSM_State = GSM_ReStart1;
				}
				else{				
					if(GetStringFromFIFO()){
    db2e:	0e 94 eb 38 	call	0x71d6	; 0x71d6 <GetStringFromFIFO>
    db32:	88 23       	and	r24, r24
    db34:	11 f4       	brne	.+4      	; 0xdb3a <GSM_Cycle+0x17d0>
    db36:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
						GSM_RSSI = 255; GSM_BER = 255;
    db3a:	8f ef       	ldi	r24, 0xFF	; 255
    db3c:	80 93 b0 06 	sts	0x06B0, r24
    db40:	80 93 84 07 	sts	0x0784, r24
						if(strstr_P(GSM_RxStr, RESP_CSQ) != NULL ){
    db44:	09 e9       	ldi	r16, 0x99	; 153
    db46:	17 e0       	ldi	r17, 0x07	; 7
    db48:	c8 01       	movw	r24, r16
    db4a:	63 e4       	ldi	r22, 0x43	; 67
    db4c:	74 e0       	ldi	r23, 0x04	; 4
    db4e:	0e 94 ef 7f 	call	0xffde	; 0xffde <strstr_P>
    db52:	89 2b       	or	r24, r25
    db54:	11 f4       	brne	.+4      	; 0xdb5a <GSM_Cycle+0x17f0>
    db56:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
							sscanf_P(GSM_RxStr,PSTR("+CSQ: %hhu,%hhu"), (unsigned char*)&GSM_RSSI, (unsigned char*)&GSM_BER);
    db5a:	ed b7       	in	r30, 0x3d	; 61
    db5c:	fe b7       	in	r31, 0x3e	; 62
    db5e:	38 97       	sbiw	r30, 0x08	; 8
    db60:	0f b6       	in	r0, 0x3f	; 63
    db62:	f8 94       	cli
    db64:	fe bf       	out	0x3e, r31	; 62
    db66:	0f be       	out	0x3f, r0	; 63
    db68:	ed bf       	out	0x3d, r30	; 61
    db6a:	31 96       	adiw	r30, 0x01	; 1
    db6c:	ad b7       	in	r26, 0x3d	; 61
    db6e:	be b7       	in	r27, 0x3e	; 62
    db70:	12 96       	adiw	r26, 0x02	; 2
    db72:	1c 93       	st	X, r17
    db74:	0e 93       	st	-X, r16
    db76:	11 97       	sbiw	r26, 0x01	; 1
    db78:	8a ee       	ldi	r24, 0xEA	; 234
    db7a:	9b e2       	ldi	r25, 0x2B	; 43
    db7c:	93 83       	std	Z+3, r25	; 0x03
    db7e:	82 83       	std	Z+2, r24	; 0x02
    db80:	80 eb       	ldi	r24, 0xB0	; 176
    db82:	96 e0       	ldi	r25, 0x06	; 6
    db84:	95 83       	std	Z+5, r25	; 0x05
    db86:	84 83       	std	Z+4, r24	; 0x04
    db88:	84 e8       	ldi	r24, 0x84	; 132
    db8a:	97 e0       	ldi	r25, 0x07	; 7
    db8c:	97 83       	std	Z+7, r25	; 0x07
    db8e:	86 83       	std	Z+6, r24	; 0x06
    db90:	0e 94 3e 81 	call	0x1027c	; 0x1027c <sscanf_P>
									
								GSM_State = GSM_WAIT_CSQ_OK;
    db94:	81 e5       	ldi	r24, 0x51	; 81
    db96:	80 93 b3 06 	sts	0x06B3, r24
    db9a:	ed b7       	in	r30, 0x3d	; 61
    db9c:	fe b7       	in	r31, 0x3e	; 62
    db9e:	38 96       	adiw	r30, 0x08	; 8
    dba0:	0f b6       	in	r0, 0x3f	; 63
    dba2:	f8 94       	cli
    dba4:	fe bf       	out	0x3e, r31	; 62
    dba6:	0f be       	out	0x3f, r0	; 63
    dba8:	ed bf       	out	0x3d, r30	; 61
    dbaa:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
			break;

		case GSM_SEND_CIPCSGP:
			//GSM_Execute_Command(AT_CIPCSGP, 300*GSM_DEBUG_DELAY); GSM_State++;
			if(GSM_Flag & (1<<flg_TxCStr)){
				sprintf_P(GSM_TxStr, AT_CIPCSGP);	GSMTxSz = strlen_P(AT_CIPCSGP);
    dbae:	00 d0       	rcall	.+0      	; 0xdbb0 <GSM_Cycle+0x1846>
    dbb0:	0f 92       	push	r0
    dbb2:	82 e0       	ldi	r24, 0x02	; 2
    dbb4:	9a e0       	ldi	r25, 0x0A	; 10
    dbb6:	ad b7       	in	r26, 0x3d	; 61
    dbb8:	be b7       	in	r27, 0x3e	; 62
    dbba:	12 96       	adiw	r26, 0x02	; 2
    dbbc:	9c 93       	st	X, r25
    dbbe:	8e 93       	st	-X, r24
    dbc0:	11 97       	sbiw	r26, 0x01	; 1
    dbc2:	08 e3       	ldi	r16, 0x38	; 56
    dbc4:	15 e0       	ldi	r17, 0x05	; 5
    dbc6:	14 96       	adiw	r26, 0x04	; 4
    dbc8:	1c 93       	st	X, r17
    dbca:	0e 93       	st	-X, r16
    dbcc:	13 97       	sbiw	r26, 0x03	; 3
    dbce:	0e 94 ea 80 	call	0x101d4	; 0x101d4 <sprintf_P>
    dbd2:	0f 90       	pop	r0
    dbd4:	0f 90       	pop	r0
    dbd6:	0f 90       	pop	r0
    dbd8:	0f 90       	pop	r0
    dbda:	c8 01       	movw	r24, r16
    dbdc:	0e 94 cd 7f 	call	0xff9a	; 0xff9a <strlen_P>
    dbe0:	80 93 75 07 	sts	0x0775, r24
				#if LCDXSz==40
					GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn);
				#else
					GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn1);
    dbe4:	80 91 75 07 	lds	r24, 0x0775
    dbe8:	90 e0       	ldi	r25, 0x00	; 0
    dbea:	8e 5f       	subi	r24, 0xFE	; 254
    dbec:	95 4f       	sbci	r25, 0xF5	; 245
    dbee:	69 e0       	ldi	r22, 0x09	; 9
    dbf0:	70 e0       	ldi	r23, 0x00	; 0
    dbf2:	0e 94 92 61 	call	0xc324	; 0xc324 <strcpy_EE>
    dbf6:	90 91 75 07 	lds	r25, 0x0775
    dbfa:	98 0f       	add	r25, r24
    dbfc:	90 93 75 07 	sts	0x0775, r25
					GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn2);
    dc00:	80 91 75 07 	lds	r24, 0x0775
    dc04:	90 e0       	ldi	r25, 0x00	; 0
    dc06:	8e 5f       	subi	r24, 0xFE	; 254
    dc08:	95 4f       	sbci	r25, 0xF5	; 245
    dc0a:	6d e1       	ldi	r22, 0x1D	; 29
    dc0c:	70 e0       	ldi	r23, 0x00	; 0
    dc0e:	0e 94 92 61 	call	0xc324	; 0xc324 <strcpy_EE>
    dc12:	90 91 75 07 	lds	r25, 0x0775
    dc16:	98 0f       	add	r25, r24
    dc18:	90 93 75 07 	sts	0x0775, r25
				#endif
				sprintf(GSM_TxStr + GSMTxSz, "\",\"");	GSMTxSz = GSMTxSz+3;				
    dc1c:	e0 91 75 07 	lds	r30, 0x0775
    dc20:	f0 e0       	ldi	r31, 0x00	; 0
    dc22:	ee 5f       	subi	r30, 0xFE	; 254
    dc24:	f5 4f       	sbci	r31, 0xF5	; 245
    dc26:	a2 e2       	ldi	r26, 0x22	; 34
    dc28:	ea 2e       	mov	r14, r26
    dc2a:	ac e2       	ldi	r26, 0x2C	; 44
    dc2c:	fa 2e       	mov	r15, r26
    dc2e:	a2 e2       	ldi	r26, 0x22	; 34
    dc30:	0a 2f       	mov	r16, r26
    dc32:	11 2d       	mov	r17, r1
    dc34:	e0 82       	st	Z, r14
    dc36:	f1 82       	std	Z+1, r15	; 0x01
    dc38:	02 83       	std	Z+2, r16	; 0x02
    dc3a:	13 83       	std	Z+3, r17	; 0x03
    dc3c:	80 91 75 07 	lds	r24, 0x0775
    dc40:	8d 5f       	subi	r24, 0xFD	; 253
    dc42:	80 93 75 07 	sts	0x0775, r24
				GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn_user_name);
    dc46:	80 91 75 07 	lds	r24, 0x0775
    dc4a:	90 e0       	ldi	r25, 0x00	; 0
    dc4c:	8e 5f       	subi	r24, 0xFE	; 254
    dc4e:	95 4f       	sbci	r25, 0xF5	; 245
    dc50:	69 e5       	ldi	r22, 0x59	; 89
    dc52:	70 e0       	ldi	r23, 0x00	; 0
    dc54:	0e 94 92 61 	call	0xc324	; 0xc324 <strcpy_EE>
    dc58:	90 91 75 07 	lds	r25, 0x0775
    dc5c:	98 0f       	add	r25, r24
    dc5e:	90 93 75 07 	sts	0x0775, r25
				sprintf(GSM_TxStr + GSMTxSz, "\",\"");	GSMTxSz = GSMTxSz+3;
    dc62:	e0 91 75 07 	lds	r30, 0x0775
    dc66:	f0 e0       	ldi	r31, 0x00	; 0
    dc68:	ee 5f       	subi	r30, 0xFE	; 254
    dc6a:	f5 4f       	sbci	r31, 0xF5	; 245
    dc6c:	e0 82       	st	Z, r14
    dc6e:	f1 82       	std	Z+1, r15	; 0x01
    dc70:	02 83       	std	Z+2, r16	; 0x02
    dc72:	13 83       	std	Z+3, r17	; 0x03
    dc74:	80 91 75 07 	lds	r24, 0x0775
    dc78:	8d 5f       	subi	r24, 0xFD	; 253
    dc7a:	80 93 75 07 	sts	0x0775, r24
				GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn_psw);
    dc7e:	80 91 75 07 	lds	r24, 0x0775
    dc82:	90 e0       	ldi	r25, 0x00	; 0
    dc84:	8e 5f       	subi	r24, 0xFE	; 254
    dc86:	95 4f       	sbci	r25, 0xF5	; 245
    dc88:	6d e6       	ldi	r22, 0x6D	; 109
    dc8a:	70 e0       	ldi	r23, 0x00	; 0
    dc8c:	0e 94 92 61 	call	0xc324	; 0xc324 <strcpy_EE>
    dc90:	90 91 75 07 	lds	r25, 0x0775
    dc94:	98 0f       	add	r25, r24
    dc96:	90 93 75 07 	sts	0x0775, r25
				sprintf(GSM_TxStr + GSMTxSz, "\"\r");	GSMTxSz = GSMTxSz+2;
    dc9a:	80 91 75 07 	lds	r24, 0x0775
    dc9e:	e8 2f       	mov	r30, r24
    dca0:	f0 e0       	ldi	r31, 0x00	; 0
    dca2:	ee 5f       	subi	r30, 0xFE	; 254
    dca4:	f5 4f       	sbci	r31, 0xF5	; 245
    dca6:	a5 eb       	ldi	r26, 0xB5	; 181
    dca8:	b2 e0       	ldi	r27, 0x02	; 2
    dcaa:	83 e0       	ldi	r24, 0x03	; 3
    dcac:	0d 90       	ld	r0, X+
    dcae:	01 92       	st	Z+, r0
    dcb0:	81 50       	subi	r24, 0x01	; 1
    dcb2:	e1 f7       	brne	.-8      	; 0xdcac <GSM_Cycle+0x1942>
    dcb4:	80 91 75 07 	lds	r24, 0x0775
    dcb8:	8e 5f       	subi	r24, 0xFE	; 254
    dcba:	80 93 75 07 	sts	0x0775, r24
				GSM_SendFirstChar();
    dcbe:	0e 94 15 3a 	call	0x742a	; 0x742a <GSM_SendFirstChar>
				StartTimer16(TD_GSM, 300*GSM_DEBUG_DELAY);
    dcc2:	80 91 e7 04 	lds	r24, 0x04E7
    dcc6:	6c e2       	ldi	r22, 0x2C	; 44
    dcc8:	71 e0       	ldi	r23, 0x01	; 1
    dcca:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
    dcce:	4f cb       	rjmp	.-2402   	; 0xd36e <GSM_Cycle+0x1004>
				GSM_State = GSM_WAIT_MESSAGE;
			}
			break;
		case GSM_WAIT_CONFIRMRESPONSE:
			if(GetStringFromFIFO()){
					if((strstr_P(GSM_RxStr, PSTR("+DTMF: 1")) != NULL) ){
    dcd0:	89 e9       	ldi	r24, 0x99	; 153
    dcd2:	97 e0       	ldi	r25, 0x07	; 7
    dcd4:	60 ed       	ldi	r22, 0xD0	; 208
    dcd6:	7c e2       	ldi	r23, 0x2C	; 44
    dcd8:	0e 94 ef 7f 	call	0xffde	; 0xffde <strstr_P>
    dcdc:	89 2b       	or	r24, r25
    dcde:	49 f0       	breq	.+18     	; 0xdcf2 <GSM_Cycle+0x1988>
						StartTimer16(TD_GSM,1000);
    dce0:	80 91 e7 04 	lds	r24, 0x04E7
    dce4:	68 ee       	ldi	r22, 0xE8	; 232
    dce6:	73 e0       	ldi	r23, 0x03	; 3
    dce8:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
						GSM_State = GSM_SEND_PLAY_CONFIRM_FILE;
    dcec:	8d e1       	ldi	r24, 0x1D	; 29
    dcee:	80 93 b3 06 	sts	0x06B3, r24
						
					}
					if((strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 2,0,6")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 3,0,6")) != NULL) ){
    dcf2:	89 e9       	ldi	r24, 0x99	; 153
    dcf4:	97 e0       	ldi	r25, 0x07	; 7
    dcf6:	63 ec       	ldi	r22, 0xC3	; 195
    dcf8:	7c e2       	ldi	r23, 0x2C	; 44
    dcfa:	0e 94 ef 7f 	call	0xffde	; 0xffde <strstr_P>
    dcfe:	89 2b       	or	r24, r25
    dd00:	09 f4       	brne	.+2      	; 0xdd04 <GSM_Cycle+0x199a>
    dd02:	2d c1       	rjmp	.+602    	; 0xdf5e <GSM_Cycle+0x1bf4>
						StartTimer16(TD_GSM,2000);
    dd04:	80 91 e7 04 	lds	r24, 0x04E7
    dd08:	60 ed       	ldi	r22, 0xD0	; 208
    dd0a:	77 e0       	ldi	r23, 0x07	; 7
    dd0c:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
						GSM_State = GSM_WAIT_DISCONNECT_CAUSE;
    dd10:	85 e2       	ldi	r24, 0x25	; 37
    dd12:	80 93 b3 06 	sts	0x06B3, r24
    dd16:	0c 94 b4 65 	jmp	0xcb68	; 0xcb68 <GSM_Cycle+0x7fe>
			if(Timer16Stopp(TD_GSM)){
				if(RequestRepeatCounter<4){
				GSM_State = GSM_SEND_PLAY_ALARM_FILE;
				}
				else{
				GSM_State = GSM_SEND_PLAY_NOTCONFIRM_FILE;				
    dd1a:	80 e2       	ldi	r24, 0x20	; 32
    dd1c:	80 93 b3 06 	sts	0x06B3, r24
    dd20:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
				if(++TempNum>=MaxTelephDirSz){
					GSM_State = GSM_Return2dataMode;
					SMS_FlgSz_Out = 0;
					//StartTimer16(TD_GSM,150);
				}
				else GSM_State = GSM_SEND_CMGS;
    dd24:	80 e4       	ldi	r24, 0x40	; 64
    dd26:	80 93 b3 06 	sts	0x06B3, r24
    dd2a:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
			}
			break;
		case GSM_WAIT_D2C_SWITCH_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) {

				switch(CommandModeDestination){
    dd2e:	84 30       	cpi	r24, 0x04	; 4
    dd30:	79 f1       	breq	.+94     	; 0xdd90 <GSM_Cycle+0x1a26>
    dd32:	85 30       	cpi	r24, 0x05	; 5
    dd34:	11 f0       	breq	.+4      	; 0xdd3a <GSM_Cycle+0x19d0>
    dd36:	0c 94 e1 62 	jmp	0xc5c2	; 0xc5c2 <GSM_Cycle+0x258>
					case 4:	
						GSM_State = GSM_SEND_ATD_Check_Ballance;
						counter=0;	
						break;
					case 5:	
						GSM_State = GSM_SEND_CSQ;
    dd3a:	8f e4       	ldi	r24, 0x4F	; 79
    dd3c:	80 93 b3 06 	sts	0x06B3, r24
						counter=0;	
    dd40:	10 92 e0 02 	sts	0x02E0, r1
    dd44:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
			if(GSM_Wait_Response_P(URC_CPIN_READY, GSM_ReStart1)) GSM_State++;
			break;

		case GSM_WAIT_CALL_READY:
			if(GSM_Wait_Response_P(URC_CALL_READY, GSM_ReStart1)){
				if(GSM_Modem == SIMCOM_SIM800) GSM_State = GSM_WAIT_SMS_READY;
    dd48:	87 e0       	ldi	r24, 0x07	; 7
    dd4a:	80 93 b3 06 	sts	0x06B3, r24
    dd4e:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
			GSM_State++; 
			break;
		case GSM_WAIT_CIPMUX_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
				if(GSM_MultiCon){
					GSM_State = GSM_WAIT_1;
    dd52:	8e e2       	ldi	r24, 0x2E	; 46
    dd54:	80 93 b3 06 	sts	0x06B3, r24
					// between "Call Ready" and "+CMGS"; 8 sec min needs; for kyivstar vpni only
					StartTimer16(TD_GSM, 1000);
    dd58:	80 91 e7 04 	lds	r24, 0x04E7
    dd5c:	68 ee       	ldi	r22, 0xE8	; 232
    dd5e:	73 e0       	ldi	r23, 0x03	; 3
    dd60:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
    dd64:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
			if(GetStringFromFIFO()){
				if(!strcmp_P(GSM_RxStr, GSM_SIMCOM_SIM900R)) GSM_Modem = SIMCOM_SIM900R;
				if(!strcmp_P(GSM_RxStr, GSM_SIMCOM_SIM800)) GSM_Modem = SIMCOM_SIM800;
				if(!strcmp_P(GSM_RxStr, GSM_SIMCOM_SIM800C)) GSM_Modem = SIMCOM_SIM800;
				//Add here new model GSM-modem
				if(GSM_Modem != NOT_RECOGNIZED) GSM_State = GSM_WAIT_CALL_READY;
    dd68:	80 91 f1 06 	lds	r24, 0x06F1
    dd6c:	88 23       	and	r24, r24
    dd6e:	11 f4       	brne	.+4      	; 0xdd74 <GSM_Cycle+0x1a0a>
    dd70:	0c 94 74 62 	jmp	0xc4e8	; 0xc4e8 <GSM_Cycle+0x17e>
    dd74:	0c 94 71 62 	jmp	0xc4e2	; 0xc4e2 <GSM_Cycle+0x178>
			}
			GSM_State++;
			break;
		case GSM_WAIT_CIPCSGP_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
			 if(GSM_Modem == SIMCOM_SIM800)GSM_State++;
    dd78:	80 91 b3 06 	lds	r24, 0x06B3
    dd7c:	8f 5f       	subi	r24, 0xFF	; 255
    dd7e:	80 93 b3 06 	sts	0x06B3, r24
    dd82:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
				}
			break;
		case GSM_WAIT_CSQ_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) {
				if(CommandModeDestination==5){
					GSM_State  = GSM_Return2dataMode;
    dd86:	87 e5       	ldi	r24, 0x57	; 87
    dd88:	80 93 b3 06 	sts	0x06B3, r24
    dd8c:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
					case 2:	
						GSM_State = GSM_CIPSHUT_;
						counter=0;	
						break;						
					case 4:	
						GSM_State = GSM_SEND_ATD_Check_Ballance;
    dd90:	8c e4       	ldi	r24, 0x4C	; 76
    dd92:	80 93 b3 06 	sts	0x06B3, r24
						counter=0;	
    dd96:	10 92 e0 02 	sts	0x02E0, r1
    dd9a:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
			break;
		case GSM_WAIT_D2C_SWITCH_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) {

				switch(CommandModeDestination){
					case 1:	GSM_State = GSM_SEND_CMGS;
    dd9e:	80 e4       	ldi	r24, 0x40	; 64
    dda0:	80 93 b3 06 	sts	0x06B3, r24
    dda4:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
						break;
					case 2:	
						GSM_State = GSM_CIPSHUT_;
    dda8:	84 e4       	ldi	r24, 0x44	; 68
    ddaa:	80 93 b3 06 	sts	0x06B3, r24
						counter=0;	
    ddae:	10 92 e0 02 	sts	0x02E0, r1
    ddb2:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
				GSMTxSz = strlen(GSM_TxStr);
				uint8_t j=0;
				for(uint8_t i=0; i<GSMTxSz; i++)
					if(GSM_TxStr[i] != '0') j++;
				if(j){
					GSMTxSz = strlen_P(AT_CMGS);
    ddb6:	00 ef       	ldi	r16, 0xF0	; 240
    ddb8:	14 e0       	ldi	r17, 0x04	; 4
    ddba:	c8 01       	movw	r24, r16
    ddbc:	0e 94 cd 7f 	call	0xff9a	; 0xff9a <strlen_P>
    ddc0:	80 93 75 07 	sts	0x0775, r24
					sprintf_P(GSM_TxStr, AT_CMGS);
    ddc4:	00 d0       	rcall	.+0      	; 0xddc6 <GSM_Cycle+0x1a5c>
    ddc6:	0f 92       	push	r0
    ddc8:	ad b7       	in	r26, 0x3d	; 61
    ddca:	be b7       	in	r27, 0x3e	; 62
    ddcc:	12 96       	adiw	r26, 0x02	; 2
    ddce:	fc 92       	st	X, r15
    ddd0:	ee 92       	st	-X, r14
    ddd2:	11 97       	sbiw	r26, 0x01	; 1
    ddd4:	14 96       	adiw	r26, 0x04	; 4
    ddd6:	1c 93       	st	X, r17
    ddd8:	0e 93       	st	-X, r16
    ddda:	13 97       	sbiw	r26, 0x03	; 3
    dddc:	0e 94 ea 80 	call	0x101d4	; 0x101d4 <sprintf_P>
					erbl(GSM_TxStr+GSMTxSz, SMS_Number+TempNum, MaxTelephN);
    dde0:	80 91 75 07 	lds	r24, 0x0775
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    dde4:	0f 90       	pop	r0
    dde6:	0f 90       	pop	r0
    dde8:	0f 90       	pop	r0
    ddea:	0f 90       	pop	r0
    ddec:	90 e0       	ldi	r25, 0x00	; 0
    ddee:	60 91 da 05 	lds	r22, 0x05DA
    ddf2:	2d e0       	ldi	r18, 0x0D	; 13
    ddf4:	62 9f       	mul	r22, r18
    ddf6:	b0 01       	movw	r22, r0
    ddf8:	11 24       	eor	r1, r1
    ddfa:	6b 53       	subi	r22, 0x3B	; 59
    ddfc:	7f 4f       	sbci	r23, 0xFF	; 255
    ddfe:	8e 5f       	subi	r24, 0xFE	; 254
    de00:	95 4f       	sbci	r25, 0xF5	; 245
    de02:	4d e0       	ldi	r20, 0x0D	; 13
    de04:	50 e0       	ldi	r21, 0x00	; 0
    de06:	0e 94 d7 82 	call	0x105ae	; 0x105ae <__eerd_block_m2560>
					GSMTxSz = strlen(GSM_TxStr);
    de0a:	f7 01       	movw	r30, r14
    de0c:	01 90       	ld	r0, Z+
    de0e:	00 20       	and	r0, r0
    de10:	e9 f7       	brne	.-6      	; 0xde0c <GSM_Cycle+0x1aa2>
    de12:	31 97       	sbiw	r30, 0x01	; 1
    de14:	e2 50       	subi	r30, 0x02	; 2
    de16:	fa 40       	sbci	r31, 0x0A	; 10
    de18:	e0 93 75 07 	sts	0x0775, r30
					sprintf(GSM_TxStr + GSMTxSz, "\"\r");
    de1c:	80 91 75 07 	lds	r24, 0x0775
    de20:	e8 2f       	mov	r30, r24
    de22:	f0 e0       	ldi	r31, 0x00	; 0
    de24:	ee 5f       	subi	r30, 0xFE	; 254
    de26:	f5 4f       	sbci	r31, 0xF5	; 245
    de28:	a5 eb       	ldi	r26, 0xB5	; 181
    de2a:	b2 e0       	ldi	r27, 0x02	; 2
    de2c:	83 e0       	ldi	r24, 0x03	; 3
    de2e:	0d 90       	ld	r0, X+
    de30:	01 92       	st	Z+, r0
    de32:	81 50       	subi	r24, 0x01	; 1
    de34:	e1 f7       	brne	.-8      	; 0xde2e <GSM_Cycle+0x1ac4>
					GSMTxSz = strlen(GSM_TxStr);
    de36:	f7 01       	movw	r30, r14
    de38:	01 90       	ld	r0, Z+
    de3a:	00 20       	and	r0, r0
    de3c:	e9 f7       	brne	.-6      	; 0xde38 <GSM_Cycle+0x1ace>
    de3e:	31 97       	sbiw	r30, 0x01	; 1
    de40:	e2 50       	subi	r30, 0x02	; 2
    de42:	fa 40       	sbci	r31, 0x0A	; 10
    de44:	e0 93 75 07 	sts	0x0775, r30
					GSM_SendFirstChar();
    de48:	0e 94 15 3a 	call	0x742a	; 0x742a <GSM_SendFirstChar>
					StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    de4c:	80 91 e7 04 	lds	r24, 0x04E7
    de50:	64 ef       	ldi	r22, 0xF4	; 244
    de52:	71 e0       	ldi	r23, 0x01	; 1
    de54:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
					GSM_State++;
    de58:	80 91 b3 06 	lds	r24, 0x06B3
    de5c:	8f 5f       	subi	r24, 0xFF	; 255
    de5e:	80 93 b3 06 	sts	0x06B3, r24
    de62:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
				GSM_State = GSM_ProtocolMode;
				InitFIFO();
				break;
			}
*/			
			if( (strstr_P(GSM_RxStr, PSTR("OK")) != NULL) ){
    de66:	c8 01       	movw	r24, r16
    de68:	67 e0       	ldi	r22, 0x07	; 7
    de6a:	7c e2       	ldi	r23, 0x2C	; 44
    de6c:	0e 94 ef 7f 	call	0xffde	; 0xffde <strstr_P>
    de70:	89 2b       	or	r24, r25
    de72:	09 f4       	brne	.+2      	; 0xde76 <GSM_Cycle+0x1b0c>
    de74:	88 c0       	rjmp	.+272    	; 0xdf86 <GSM_Cycle+0x1c1c>
				StartTimer16(TD_data_start_delay,100);
    de76:	80 91 ee 04 	lds	r24, 0x04EE
    de7a:	64 e6       	ldi	r22, 0x64	; 100
    de7c:	70 e0       	ldi	r23, 0x00	; 0
    de7e:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
				GSM_State = GSM_ProtocolMode;
    de82:	82 e5       	ldi	r24, 0x52	; 82
    de84:	80 93 b3 06 	sts	0x06B3, r24
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    de88:	8f ef       	ldi	r24, 0xFF	; 255
    de8a:	80 93 fa 06 	sts	0x06FA, r24
	GSM_RX_FIFO_End = 255;
    de8e:	80 93 51 06 	sts	0x0651, r24
	GSM_RxCharN = 0;
    de92:	10 92 18 0b 	sts	0x0B18, r1
	GSM_RX_FIFOOverFlow = 0;
    de96:	10 92 cb 08 	sts	0x08CB, r1
	GSM_RX_FIFOMax = 0;
    de9a:	10 92 d1 08 	sts	0x08D1, r1
    de9e:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
				GSM_State = GSM_WAIT_MESSAGE;
			}
			break;
		case GSM_WAIT_CCLC_3:
			if(GetStringFromFIFO()){
				if( (strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 2,0,6,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 3,0,6,")) != NULL) ){
    dea2:	89 e9       	ldi	r24, 0x99	; 153
    dea4:	97 e0       	ldi	r25, 0x07	; 7
    dea6:	6b ec       	ldi	r22, 0xCB	; 203
    dea8:	7d e2       	ldi	r23, 0x2D	; 45
    deaa:	0e 94 ef 7f 	call	0xffde	; 0xffde <strstr_P>
    deae:	89 2b       	or	r24, r25
    deb0:	11 f0       	breq	.+4      	; 0xdeb6 <GSM_Cycle+0x1b4c>
    deb2:	0c 94 43 66 	jmp	0xcc86	; 0xcc86 <GSM_Cycle+0x91c>
    deb6:	89 e9       	ldi	r24, 0x99	; 153
    deb8:	97 e0       	ldi	r25, 0x07	; 7
    deba:	6d eb       	ldi	r22, 0xBD	; 189
    debc:	7d e2       	ldi	r23, 0x2D	; 45
    debe:	0e 94 ef 7f 	call	0xffde	; 0xffde <strstr_P>
    dec2:	89 2b       	or	r24, r25
    dec4:	11 f0       	breq	.+4      	; 0xdeca <GSM_Cycle+0x1b60>
    dec6:	0c 94 43 66 	jmp	0xcc86	; 0xcc86 <GSM_Cycle+0x91c>
					StartTimer16(TD_GSM, 6000);
					GSM_State = GSM_WAIT_MESSAGE;
					break;
				}
				if( (strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,3,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 2,0,3,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 3,0,3,")) != NULL) ){
    deca:	89 e9       	ldi	r24, 0x99	; 153
    decc:	97 e0       	ldi	r25, 0x07	; 7
    dece:	6f ea       	ldi	r22, 0xAF	; 175
    ded0:	7d e2       	ldi	r23, 0x2D	; 45
    ded2:	0e 94 ef 7f 	call	0xffde	; 0xffde <strstr_P>
    ded6:	89 2b       	or	r24, r25
    ded8:	09 f4       	brne	.+2      	; 0xdedc <GSM_Cycle+0x1b72>
    deda:	2b cd       	rjmp	.-1450   	; 0xd932 <GSM_Cycle+0x15c8>
					StartTimer16(TD_GSM, 6000);
    dedc:	80 91 e7 04 	lds	r24, 0x04E7
    dee0:	60 e7       	ldi	r22, 0x70	; 112
    dee2:	77 e1       	ldi	r23, 0x17	; 23
    dee4:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
					GSM_State = GSM_WAIT_CCLC_0;
    dee8:	83 e1       	ldi	r24, 0x13	; 19
    deea:	80 93 b3 06 	sts	0x06B3, r24
    deee:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
				if((strstr_P(GSM_RxStr, PSTR("OK")) != NULL) ){
					GSM_State = GSM_WAIT_MESSAGE;

					break;
				}
				if((strstr_P(GSM_RxStr, PSTR("BUSY")) != NULL) ){
    def2:	89 e9       	ldi	r24, 0x99	; 153
    def4:	97 e0       	ldi	r25, 0x07	; 7
    def6:	69 e2       	ldi	r22, 0x29	; 41
    def8:	7c e2       	ldi	r23, 0x2C	; 44
    defa:	0e 94 ef 7f 	call	0xffde	; 0xffde <strstr_P>
    defe:	89 2b       	or	r24, r25
    df00:	09 f4       	brne	.+2      	; 0xdf04 <GSM_Cycle+0x1b9a>
    df02:	be c0       	rjmp	.+380    	; 0xe080 <GSM_Cycle+0x1d16>
					GSM_State = GSM_WAIT_MESSAGE;
    df04:	8e e0       	ldi	r24, 0x0E	; 14
    df06:	80 93 b3 06 	sts	0x06B3, r24
    df0a:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
				GSM_State = GSM_WAIT_MESSAGE;
			}
			break;
		case GSM_WAIT_CCLC_0:
			if(GetStringFromFIFO()){
				if((strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,0,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,0,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,0,")) != NULL) ){
    df0e:	89 e9       	ldi	r24, 0x99	; 153
    df10:	97 e0       	ldi	r25, 0x07	; 7
    df12:	67 e7       	ldi	r22, 0x77	; 119
    df14:	7d e2       	ldi	r23, 0x2D	; 45
    df16:	0e 94 ef 7f 	call	0xffde	; 0xffde <strstr_P>
    df1a:	89 2b       	or	r24, r25
    df1c:	11 f0       	breq	.+4      	; 0xdf22 <GSM_Cycle+0x1bb8>
    df1e:	0c 94 e6 66 	jmp	0xcdcc	; 0xcdcc <GSM_Cycle+0xa62>
    df22:	89 e9       	ldi	r24, 0x99	; 153
    df24:	97 e0       	ldi	r25, 0x07	; 7
    df26:	69 e6       	ldi	r22, 0x69	; 105
    df28:	7d e2       	ldi	r23, 0x2D	; 45
    df2a:	0e 94 ef 7f 	call	0xffde	; 0xffde <strstr_P>
    df2e:	89 2b       	or	r24, r25
    df30:	11 f0       	breq	.+4      	; 0xdf36 <GSM_Cycle+0x1bcc>
    df32:	0c 94 e6 66 	jmp	0xcdcc	; 0xcdcc <GSM_Cycle+0xa62>
					RequestRepeatCounter = 0;
					GSM_State = GSM_SEND_PLAY_ALARM_FILE;
					break;
				}
				if( (strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6,")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6,")) != NULL)){
    df36:	89 e9       	ldi	r24, 0x99	; 153
    df38:	97 e0       	ldi	r25, 0x07	; 7
    df3a:	6b e5       	ldi	r22, 0x5B	; 91
    df3c:	7d e2       	ldi	r23, 0x2D	; 45
    df3e:	0e 94 ef 7f 	call	0xffde	; 0xffde <strstr_P>
    df42:	89 2b       	or	r24, r25
    df44:	09 f4       	brne	.+2      	; 0xdf48 <GSM_Cycle+0x1bde>
    df46:	14 cd       	rjmp	.-1496   	; 0xd970 <GSM_Cycle+0x1606>
					StartTimer16(TD_GSM, 6000);
    df48:	80 91 e7 04 	lds	r24, 0x04E7
    df4c:	60 e7       	ldi	r22, 0x70	; 112
    df4e:	77 e1       	ldi	r23, 0x17	; 23
    df50:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
					GSM_State = GSM_WAIT_DISCONNECT_CAUSE;
    df54:	85 e2       	ldi	r24, 0x25	; 37
    df56:	80 93 b3 06 	sts	0x06B3, r24
    df5a:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
					if((strstr_P(GSM_RxStr, PSTR("+DTMF: 1")) != NULL) ){
						StartTimer16(TD_GSM,1000);
						GSM_State = GSM_SEND_PLAY_CONFIRM_FILE;
						
					}
					if((strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 2,0,6")) != NULL)||(strstr_P(GSM_RxStr, PSTR("+CLCC: 3,0,6")) != NULL) ){
    df5e:	89 e9       	ldi	r24, 0x99	; 153
    df60:	97 e0       	ldi	r25, 0x07	; 7
    df62:	66 eb       	ldi	r22, 0xB6	; 182
    df64:	7c e2       	ldi	r23, 0x2C	; 44
    df66:	0e 94 ef 7f 	call	0xffde	; 0xffde <strstr_P>
    df6a:	89 2b       	or	r24, r25
    df6c:	09 f0       	breq	.+2      	; 0xdf70 <GSM_Cycle+0x1c06>
    df6e:	ca ce       	rjmp	.-620    	; 0xdd04 <GSM_Cycle+0x199a>
    df70:	89 e9       	ldi	r24, 0x99	; 153
    df72:	97 e0       	ldi	r25, 0x07	; 7
    df74:	69 ea       	ldi	r22, 0xA9	; 169
    df76:	7c e2       	ldi	r23, 0x2C	; 44
    df78:	0e 94 ef 7f 	call	0xffde	; 0xffde <strstr_P>
    df7c:	89 2b       	or	r24, r25
    df7e:	09 f0       	breq	.+2      	; 0xdf82 <GSM_Cycle+0x1c18>
    df80:	c1 ce       	rjmp	.-638    	; 0xdd04 <GSM_Cycle+0x199a>
    df82:	0c 94 b4 65 	jmp	0xcb68	; 0xcb68 <GSM_Cycle+0x7fe>
				break;
			}


			//  
			if( (strstr_P(GSM_RxStr, URC_CONNECT) != NULL) ){
    df86:	c8 01       	movw	r24, r16
    df88:	60 ec       	ldi	r22, 0xC0	; 192
    df8a:	73 e0       	ldi	r23, 0x03	; 3
    df8c:	0e 94 ef 7f 	call	0xffde	; 0xffde <strstr_P>
    df90:	89 2b       	or	r24, r25
    df92:	b1 f0       	breq	.+44     	; 0xdfc0 <GSM_Cycle+0x1c56>

				GSM_State = GSM_ProtocolMode;
    df94:	82 e5       	ldi	r24, 0x52	; 82
    df96:	80 93 b3 06 	sts	0x06B3, r24
    df9a:	f8 01       	movw	r30, r16
				for(int i=0;i<GSM_RXSTR_SIZE;i++)
				{
					GSM_RxStr[i]=0;	
    df9c:	11 92       	st	Z+, r1

			//  
			if( (strstr_P(GSM_RxStr, URC_CONNECT) != NULL) ){

				GSM_State = GSM_ProtocolMode;
				for(int i=0;i<GSM_RXSTR_SIZE;i++)
    df9e:	37 e0       	ldi	r19, 0x07	; 7
    dfa0:	ed 3f       	cpi	r30, 0xFD	; 253
    dfa2:	f3 07       	cpc	r31, r19
    dfa4:	d9 f7       	brne	.-10     	; 0xdf9c <GSM_Cycle+0x1c32>
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    dfa6:	8f ef       	ldi	r24, 0xFF	; 255
    dfa8:	80 93 fa 06 	sts	0x06FA, r24
	GSM_RX_FIFO_End = 255;
    dfac:	80 93 51 06 	sts	0x0651, r24
	GSM_RxCharN = 0;
    dfb0:	10 92 18 0b 	sts	0x0B18, r1
	GSM_RX_FIFOOverFlow = 0;
    dfb4:	10 92 cb 08 	sts	0x08CB, r1
	GSM_RX_FIFOMax = 0;
    dfb8:	10 92 d1 08 	sts	0x08D1, r1
    dfbc:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>

				break;
			}

			//  
			if(strstr_P(GSM_RxStr, URC_CLOSED) != NULL){
    dfc0:	c8 01       	movw	r24, r16
    dfc2:	62 ed       	ldi	r22, 0xD2	; 210
    dfc4:	73 e0       	ldi	r23, 0x03	; 3
    dfc6:	0e 94 ef 7f 	call	0xffde	; 0xffde <strstr_P>
    dfca:	89 2b       	or	r24, r25
    dfcc:	99 f1       	breq	.+102    	; 0xe034 <GSM_Cycle+0x1cca>
				//  
				sscanf_P(GSM_RxStr,PSTR("%hhu, CLOSED"),(unsigned char*)&TempNum);
    dfce:	00 d0       	rcall	.+0      	; 0xdfd0 <GSM_Cycle+0x1c66>
    dfd0:	00 d0       	rcall	.+0      	; 0xdfd2 <GSM_Cycle+0x1c68>
    dfd2:	ed b7       	in	r30, 0x3d	; 61
    dfd4:	fe b7       	in	r31, 0x3e	; 62
    dfd6:	31 96       	adiw	r30, 0x01	; 1
    dfd8:	ad b7       	in	r26, 0x3d	; 61
    dfda:	be b7       	in	r27, 0x3e	; 62
    dfdc:	12 96       	adiw	r26, 0x02	; 2
    dfde:	1c 93       	st	X, r17
    dfe0:	0e 93       	st	-X, r16
    dfe2:	11 97       	sbiw	r26, 0x01	; 1
    dfe4:	8a ef       	ldi	r24, 0xFA	; 250
    dfe6:	9b e2       	ldi	r25, 0x2B	; 43
    dfe8:	93 83       	std	Z+3, r25	; 0x03
    dfea:	82 83       	std	Z+2, r24	; 0x02
    dfec:	8a ed       	ldi	r24, 0xDA	; 218
    dfee:	95 e0       	ldi	r25, 0x05	; 5
    dff0:	95 83       	std	Z+5, r25	; 0x05
    dff2:	84 83       	std	Z+4, r24	; 0x04
    dff4:	0e 94 3e 81 	call	0x1027c	; 0x1027c <sscanf_P>
				if(GSM_ActiveConnection == TempNum){
    dff8:	ed b7       	in	r30, 0x3d	; 61
    dffa:	fe b7       	in	r31, 0x3e	; 62
    dffc:	36 96       	adiw	r30, 0x06	; 6
    dffe:	0f b6       	in	r0, 0x3f	; 63
    e000:	f8 94       	cli
    e002:	fe bf       	out	0x3e, r31	; 62
    e004:	0f be       	out	0x3f, r0	; 63
    e006:	ed bf       	out	0x3d, r30	; 61
    e008:	90 91 d3 02 	lds	r25, 0x02D3
    e00c:	80 91 da 05 	lds	r24, 0x05DA
    e010:	98 17       	cp	r25, r24
    e012:	59 f4       	brne	.+22     	; 0xe02a <GSM_Cycle+0x1cc0>
					GSM_ActiveConnection = NO_CONNECTION;
    e014:	8f ef       	ldi	r24, 0xFF	; 255
    e016:	80 93 d3 02 	sts	0x02D3, r24
	uint8_t IP4;
} IP_Addr;

//~~~~~~~~~~~~~~
void SetIP(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	IP->IP1 = IP1;
    e01a:	10 92 02 0b 	sts	0x0B02, r1
	IP->IP2 = IP2;
    e01e:	10 92 03 0b 	sts	0x0B03, r1
	IP->IP3 = IP3;
    e022:	10 92 04 0b 	sts	0x0B04, r1
	IP->IP4 = IP4;
    e026:	10 92 05 0b 	sts	0x0B05, r1
					SetIP(&GSM_ClientIP,0,0,0,0);
				}

				GSM_State = GSM_ReStart1;
    e02a:	8a e4       	ldi	r24, 0x4A	; 74
    e02c:	80 93 b3 06 	sts	0x06B3, r24
    e030:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
				break;
			}

			// +PDP DEACT
			if( (strstr_P(GSM_RxStr, URC_PDPDEACT) != NULL) ){
    e034:	c8 01       	movw	r24, r16
    e036:	6b ed       	ldi	r22, 0xDB	; 219
    e038:	73 e0       	ldi	r23, 0x03	; 3
    e03a:	0e 94 ef 7f 	call	0xffde	; 0xffde <strstr_P>
    e03e:	89 2b       	or	r24, r25
    e040:	61 f0       	breq	.+24     	; 0xe05a <GSM_Cycle+0x1cf0>
				GSM_State = GSM_SEND_E0;
    e042:	88 e0       	ldi	r24, 0x08	; 8
    e044:	80 93 b3 06 	sts	0x06B3, r24
    e048:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
							if(!strncmp_P(GSM_RxStr, PSTR("\r\n"), 2)) {GSM_RxCharN=0;}
						}
					if(GSM_RxCharN >= 4){
						AppProtocol = 0;
						if(!strncmp_P(GSM_RxStr, PSTR("GET "), 4)) {AppProtocol = _HTTP;GSM_State = GSM_DataMode;break;}//GET
						if(!strncmp_P(GSM_RxStr, PSTR("POST"), 4)) {AppProtocol = _HTTP;GSM_State = GSM_DataMode;break;}//POST
    e04c:	81 e0       	ldi	r24, 0x01	; 1
    e04e:	80 93 9f 08 	sts	0x089F, r24
    e052:	83 e5       	ldi	r24, 0x53	; 83
    e054:	80 93 b3 06 	sts	0x06B3, r24
    e058:	11 cd       	rjmp	.-1502   	; 0xda7c <GSM_Cycle+0x1712>
			}



			//      
			if(strstr_P(GSM_RxStr, RESP_CSQ) != NULL ){
    e05a:	c8 01       	movw	r24, r16
    e05c:	63 e4       	ldi	r22, 0x43	; 67
    e05e:	74 e0       	ldi	r23, 0x04	; 4
    e060:	0e 94 ef 7f 	call	0xffde	; 0xffde <strstr_P>
    e064:	89 2b       	or	r24, r25
    e066:	c9 f0       	breq	.+50     	; 0xe09a <GSM_Cycle+0x1d30>
				GSM_State = GSM_WAIT_CSQ;
    e068:	80 e5       	ldi	r24, 0x50	; 80
    e06a:	80 93 b3 06 	sts	0x06B3, r24
    e06e:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
						AppProtocol = 0;
						if(!strncmp_P(GSM_RxStr, PSTR("GET "), 4)) {AppProtocol = _HTTP;GSM_State = GSM_DataMode;break;}//GET
						if(!strncmp_P(GSM_RxStr, PSTR("POST"), 4)) {AppProtocol = _HTTP;GSM_State = GSM_DataMode;break;}//POST
						if(!strncmp_P(GSM_RxStr, PSTR("CLOS"), 4)) {AppProtocol = _HTTP;GSM_State = GSM_ReStart1;break;}// 
						if(!strncmp_P(GSM_RxStr, PSTR("+PDP"), 4)) {AppProtocol = _HTTP;GSM_State = GSM_ReStart1;break;}//GPRS 
						if( (GSM_RxStr[0]==0) && (GSM_RxStr[1]==0)){AppProtocol = _HTTP;GSM_State = GSM_ReStart1;break;}//  
    e072:	81 e0       	ldi	r24, 0x01	; 1
    e074:	80 93 9f 08 	sts	0x089F, r24
    e078:	8a e4       	ldi	r24, 0x4A	; 74
    e07a:	80 93 b3 06 	sts	0x06B3, r24
    e07e:	fe cc       	rjmp	.-1540   	; 0xda7c <GSM_Cycle+0x1712>
				if((strstr_P(GSM_RxStr, PSTR("BUSY")) != NULL) ){
					GSM_State = GSM_WAIT_MESSAGE;

					break;
				}
				if((strstr_P(GSM_RxStr, PSTR("NO CARRIER")) != NULL) ){
    e080:	89 e9       	ldi	r24, 0x99	; 153
    e082:	97 e0       	ldi	r25, 0x07	; 7
    e084:	6e e1       	ldi	r22, 0x1E	; 30
    e086:	7c e2       	ldi	r23, 0x2C	; 44
    e088:	0e 94 ef 7f 	call	0xffde	; 0xffde <strstr_P>
    e08c:	89 2b       	or	r24, r25
    e08e:	51 f0       	breq	.+20     	; 0xe0a4 <GSM_Cycle+0x1d3a>
					GSM_State = GSM_WAIT_MESSAGE;
    e090:	8e e0       	ldi	r24, 0x0E	; 14
    e092:	80 93 b3 06 	sts	0x06B3, r24
    e096:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
				GSM_State = GSM_WAIT_CSQ;
				break;
			}

			// 
			GSM_State = GSM_WAIT_IDENTIFICATION;
    e09a:	8e e3       	ldi	r24, 0x3E	; 62
    e09c:	80 93 b3 06 	sts	0x06B3, r24
    e0a0:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>
				if((strstr_P(GSM_RxStr, PSTR("NO CARRIER")) != NULL) ){
					GSM_State = GSM_WAIT_MESSAGE;

					break;
				}
				GSM_State = GSM_WAIT_MESSAGE;
    e0a4:	8e e0       	ldi	r24, 0x0E	; 14
    e0a6:	80 93 b3 06 	sts	0x06B3, r24
    e0aa:	0c 94 d5 61 	jmp	0xc3aa	; 0xc3aa <GSM_Cycle+0x40>

0000e0ae <USART_Cycle>:

// ~~~~~~~~~~~~~~
void
USART_Cycle(void)
{
	MB_Cycle();
    e0ae:	0e 94 26 38 	call	0x704c	; 0x704c <MB_Cycle>
	#ifdef GSM
		GSM_Cycle();
    e0b2:	0e 94 b5 61 	call	0xc36a	; 0xc36a <GSM_Cycle>
	#endif
	#ifdef UDP_EASY
		UDP_RxProcess();
	#endif
}
    e0b6:	08 95       	ret

0000e0b8 <IP_E_compare_Const>:
}
uint8_t IP_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	if((IP->IP1 == IP1) && (IP->IP2 == IP2) && (IP->IP3 == IP3) && (IP->IP4 == IP4)) return 1;
	else return 0;
}
uint8_t IP_E_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
    e0b8:	ef 92       	push	r14
    e0ba:	ff 92       	push	r15
    e0bc:	0f 93       	push	r16
    e0be:	1f 93       	push	r17
    e0c0:	cf 93       	push	r28
    e0c2:	df 93       	push	r29
    e0c4:	ec 01       	movw	r28, r24
    e0c6:	16 2f       	mov	r17, r22
    e0c8:	f4 2e       	mov	r15, r20
    e0ca:	e2 2e       	mov	r14, r18
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    e0cc:	0e 94 e7 82 	call	0x105ce	; 0x105ce <__eerd_byte_m2560>
	if((erb(&IP->IP1) == IP1) && (erb(&IP->IP2) == IP2) && (erb(&IP->IP3) == IP3) && (erb(&IP->IP4) == IP4)) return 1;
    e0d0:	18 17       	cp	r17, r24
    e0d2:	49 f0       	breq	.+18     	; 0xe0e6 <IP_E_compare_Const+0x2e>
	else return 0;
}
    e0d4:	90 e0       	ldi	r25, 0x00	; 0
    e0d6:	89 2f       	mov	r24, r25
    e0d8:	df 91       	pop	r29
    e0da:	cf 91       	pop	r28
    e0dc:	1f 91       	pop	r17
    e0de:	0f 91       	pop	r16
    e0e0:	ff 90       	pop	r15
    e0e2:	ef 90       	pop	r14
    e0e4:	08 95       	ret
    e0e6:	ce 01       	movw	r24, r28
    e0e8:	01 96       	adiw	r24, 0x01	; 1
    e0ea:	0e 94 e7 82 	call	0x105ce	; 0x105ce <__eerd_byte_m2560>
uint8_t IP_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	if((IP->IP1 == IP1) && (IP->IP2 == IP2) && (IP->IP3 == IP3) && (IP->IP4 == IP4)) return 1;
	else return 0;
}
uint8_t IP_E_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	if((erb(&IP->IP1) == IP1) && (erb(&IP->IP2) == IP2) && (erb(&IP->IP3) == IP3) && (erb(&IP->IP4) == IP4)) return 1;
    e0ee:	f8 16       	cp	r15, r24
    e0f0:	89 f7       	brne	.-30     	; 0xe0d4 <IP_E_compare_Const+0x1c>
    e0f2:	ce 01       	movw	r24, r28
    e0f4:	02 96       	adiw	r24, 0x02	; 2
    e0f6:	0e 94 e7 82 	call	0x105ce	; 0x105ce <__eerd_byte_m2560>
    e0fa:	e8 16       	cp	r14, r24
    e0fc:	59 f7       	brne	.-42     	; 0xe0d4 <IP_E_compare_Const+0x1c>
    e0fe:	ce 01       	movw	r24, r28
    e100:	03 96       	adiw	r24, 0x03	; 3
    e102:	0e 94 e7 82 	call	0x105ce	; 0x105ce <__eerd_byte_m2560>
    e106:	90 e0       	ldi	r25, 0x00	; 0
    e108:	08 13       	cpse	r16, r24
    e10a:	91 e0       	ldi	r25, 0x01	; 1
    e10c:	81 e0       	ldi	r24, 0x01	; 1
    e10e:	98 27       	eor	r25, r24
    e110:	e2 cf       	rjmp	.-60     	; 0xe0d6 <IP_E_compare_Const+0x1e>

0000e112 <MB_M_Init>:
}

// ~~~~~~~~~~~~~~~~~~~~
void
MB_M_Init(uint8_t MB_N)
{
    e112:	cf 92       	push	r12
    e114:	df 92       	push	r13
    e116:	ef 92       	push	r14
    e118:	ff 92       	push	r15
    e11a:	0f 93       	push	r16
    e11c:	1f 93       	push	r17
	MB_M_Period[MB_N]		= erw(&MB_M_Param_EE[MB_N].Period);
    e11e:	e8 2e       	mov	r14, r24
    e120:	ff 24       	eor	r15, r15
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    e122:	87 01       	movw	r16, r14
    e124:	00 0f       	add	r16, r16
    e126:	11 1f       	adc	r17, r17
    e128:	00 0f       	add	r16, r16
    e12a:	11 1f       	adc	r17, r17
    e12c:	0e 0d       	add	r16, r14
    e12e:	1f 1d       	adc	r17, r15
    e130:	32 e3       	ldi	r19, 0x32	; 50
    e132:	c3 2e       	mov	r12, r19
    e134:	31 e0       	ldi	r19, 0x01	; 1
    e136:	d3 2e       	mov	r13, r19
    e138:	c6 01       	movw	r24, r12
    e13a:	80 0f       	add	r24, r16
    e13c:	91 1f       	adc	r25, r17
    e13e:	0e 94 f5 82 	call	0x105ea	; 0x105ea <__eerd_word_m2560>
    e142:	f7 01       	movw	r30, r14
    e144:	ee 0f       	add	r30, r30
    e146:	ff 1f       	adc	r31, r31
    e148:	e5 55       	subi	r30, 0x55	; 85
    e14a:	f9 4f       	sbci	r31, 0xF9	; 249
    e14c:	91 83       	std	Z+1, r25	; 0x01
    e14e:	80 83       	st	Z, r24
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    e150:	0e 5f       	subi	r16, 0xFE	; 254
    e152:	1f 4f       	sbci	r17, 0xFF	; 255
    e154:	c6 01       	movw	r24, r12
    e156:	80 0f       	add	r24, r16
    e158:	91 1f       	adc	r25, r17
    e15a:	0e 94 e7 82 	call	0x105ce	; 0x105ce <__eerd_byte_m2560>
	MB_M_Timeout[MB_N]	= erb(&MB_M_Param_EE[MB_N].Timeout);
    e15e:	f7 01       	movw	r30, r14
    e160:	ef 51       	subi	r30, 0x1F	; 31
    e162:	f7 4f       	sbci	r31, 0xF7	; 247
    e164:	80 83       	st	Z, r24
    e166:	0f 5f       	subi	r16, 0xFF	; 255
    e168:	1f 4f       	sbci	r17, 0xFF	; 255
    e16a:	c6 01       	movw	r24, r12
    e16c:	80 0f       	add	r24, r16
    e16e:	91 1f       	adc	r25, r17
    e170:	0e 94 e7 82 	call	0x105ce	; 0x105ce <__eerd_byte_m2560>
	MB_M_Try[MB_N]			= erb(&MB_M_Param_EE[MB_N].Try);
    e174:	f7 01       	movw	r30, r14
    e176:	e5 50       	subi	r30, 0x05	; 5
    e178:	f9 4f       	sbci	r31, 0xF9	; 249
    e17a:	80 83       	st	Z, r24
    e17c:	0f 5f       	subi	r16, 0xFF	; 255
    e17e:	1f 4f       	sbci	r17, 0xFF	; 255
    e180:	c6 01       	movw	r24, r12
    e182:	80 0f       	add	r24, r16
    e184:	91 1f       	adc	r25, r17
    e186:	0e 94 e7 82 	call	0x105ce	; 0x105ce <__eerd_byte_m2560>
	MB_M_TimeOff[MB_N]	= erb(&MB_M_Param_EE[MB_N].TimeOff);
    e18a:	2d ed       	ldi	r18, 0xDD	; 221
    e18c:	35 e0       	ldi	r19, 0x05	; 5
    e18e:	e2 0e       	add	r14, r18
    e190:	f3 1e       	adc	r15, r19
    e192:	f7 01       	movw	r30, r14
    e194:	80 83       	st	Z, r24

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    e196:	80 91 d0 02 	lds	r24, 0x02D0
	VacantTimer16Sys += n;
    e19a:	8d 5f       	subi	r24, 0xFD	; 253
    e19c:	80 93 d0 02 	sts	0x02D0, r24
    e1a0:	83 50       	subi	r24, 0x03	; 3

	TD_MB = Timer16SysAlloc(Modbus_Qt*3);
    e1a2:	80 93 e6 04 	sts	0x04E6, r24
}
    e1a6:	1f 91       	pop	r17
    e1a8:	0f 91       	pop	r16
    e1aa:	ff 90       	pop	r15
    e1ac:	ef 90       	pop	r14
    e1ae:	df 90       	pop	r13
    e1b0:	cf 90       	pop	r12
    e1b2:	08 95       	ret

0000e1b4 <MB_S_Init>:
}

// ~~~~~~~~~~~~~~~~~~~~
void
MB_S_Init(uint8_t MB_N)
{
    e1b4:	0f 93       	push	r16
    e1b6:	1f 93       	push	r17
    e1b8:	08 2f       	mov	r16, r24
    e1ba:	10 e0       	ldi	r17, 0x00	; 0
    e1bc:	c8 01       	movw	r24, r16
    e1be:	89 5c       	subi	r24, 0xC9	; 201
    e1c0:	9e 4f       	sbci	r25, 0xFE	; 254
    e1c2:	0e 94 e7 82 	call	0x105ce	; 0x105ce <__eerd_byte_m2560>
	#ifndef MB_ADDR_DIP_SW
		MB_NativeAddr[MB_N] = erb(MB_NativeAddr_EE+MB_N);
    e1c6:	02 52       	subi	r16, 0x22	; 34
    e1c8:	1a 4f       	sbci	r17, 0xFA	; 250
    e1ca:	f8 01       	movw	r30, r16
    e1cc:	80 83       	st	Z, r24
	#endif
}
    e1ce:	1f 91       	pop	r17
    e1d0:	0f 91       	pop	r16
    e1d2:	08 95       	ret

0000e1d4 <SetBAUD>:
}

// ~~~~~~~~~~~~~~~~~~
void
SetBAUD(uint8_t MB_N)
{
    e1d4:	ef 92       	push	r14
    e1d6:	ff 92       	push	r15
    e1d8:	0f 93       	push	r16
    e1da:	1f 93       	push	r17
	BR_Val *ptrBR_Val = BR_Tbl + (MB_BitRate_RAM[MB_N] = erb(&MB_Param[MB_N].BitRate));
    e1dc:	08 2f       	mov	r16, r24
    e1de:	10 e0       	ldi	r17, 0x00	; 0
    e1e0:	78 01       	movw	r14, r16
    e1e2:	ee 0c       	add	r14, r14
    e1e4:	ff 1c       	adc	r15, r15
    e1e6:	e0 0e       	add	r14, r16
    e1e8:	f1 1e       	adc	r15, r17
    e1ea:	c7 01       	movw	r24, r14
    e1ec:	8a 5f       	subi	r24, 0xFA	; 250
    e1ee:	9f 4f       	sbci	r25, 0xFF	; 255
    e1f0:	0e 94 e7 82 	call	0x105ce	; 0x105ce <__eerd_byte_m2560>
    e1f4:	98 2f       	mov	r25, r24
    e1f6:	f8 01       	movw	r30, r16
    e1f8:	ea 57       	subi	r30, 0x7A	; 122
    e1fa:	f8 4f       	sbci	r31, 0xF8	; 248
    e1fc:	80 83       	st	Z, r24
    e1fe:	83 e0       	ldi	r24, 0x03	; 3
    e200:	98 9f       	mul	r25, r24
    e202:	b0 01       	movw	r22, r0
    e204:	11 24       	eor	r1, r1
    e206:	60 5c       	subi	r22, 0xC0	; 192
    e208:	7c 4f       	sbci	r23, 0xFC	; 252

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    e20a:	00 0f       	add	r16, r16
    e20c:	11 1f       	adc	r17, r17
    e20e:	00 0f       	add	r16, r16
    e210:	11 1f       	adc	r17, r17
    e212:	c8 01       	movw	r24, r16
    e214:	88 0f       	add	r24, r24
    e216:	99 1f       	adc	r25, r25
    e218:	88 0f       	add	r24, r24
    e21a:	99 1f       	adc	r25, r25
    e21c:	80 0f       	add	r24, r16
    e21e:	91 1f       	adc	r25, r17
    e220:	0a 96       	adiw	r24, 0x0a	; 10
    e222:	41 e4       	ldi	r20, 0x41	; 65
    e224:	5e e2       	ldi	r21, 0x2E	; 46
    e226:	9a 01       	movw	r18, r20
    e228:	28 0f       	add	r18, r24
    e22a:	39 1f       	adc	r19, r25
    e22c:	f9 01       	movw	r30, r18
    e22e:	a5 91       	lpm	r26, Z+
    e230:	b4 91       	lpm	r27, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    e232:	fb 01       	movw	r30, r22
    e234:	24 91       	lpm	r18, Z+
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		USART_Reg(MB_N, ubrrl) = prb((uint8_t*)&ptrBR_Val->UBRR);
    e236:	2c 93       	st	X, r18

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    e238:	02 97       	sbiw	r24, 0x02	; 2
    e23a:	84 0f       	add	r24, r20
    e23c:	95 1f       	adc	r25, r21
    e23e:	fc 01       	movw	r30, r24
    e240:	a5 91       	lpm	r26, Z+
    e242:	b4 91       	lpm	r27, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    e244:	6f 5f       	subi	r22, 0xFF	; 255
    e246:	7f 4f       	sbci	r23, 0xFF	; 255
    e248:	fb 01       	movw	r30, r22
    e24a:	84 91       	lpm	r24, Z+
		USART_Reg(MB_N, ubrrh) = prb((uint8_t*)&ptrBR_Val->UBRR+1);
    e24c:	8c 93       	st	X, r24

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    e24e:	c7 01       	movw	r24, r14
    e250:	88 0f       	add	r24, r24
    e252:	99 1f       	adc	r25, r25
    e254:	88 5a       	subi	r24, 0xA8	; 168
    e256:	91 4d       	sbci	r25, 0xD1	; 209
    e258:	fc 01       	movw	r30, r24
    e25a:	a5 91       	lpm	r26, Z+
    e25c:	b4 91       	lpm	r27, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    e25e:	6f 5f       	subi	r22, 0xFF	; 255
    e260:	7f 4f       	sbci	r23, 0xFF	; 255
    e262:	fb 01       	movw	r30, r22
    e264:	84 91       	lpm	r24, Z+

		*(uint8_t*)prp(&MB_Timer[MB_N].OCR) = prb(&ptrBR_Val->Time35);
    e266:	8c 93       	st	X, r24
		usart->BAUDCTRLA = prb((uint8_t*)&ptrBR_Val->UBRR);
		usart->BAUDCTRLB = prb((uint8_t*)&ptrBR_Val->UBRR+1) + USART_BSCALE0_bm;

		((TC1_t*)prp(MB_Timer+MB_N))->PER = prw(&ptrBR_Val->Time35);
	#endif
}
    e268:	1f 91       	pop	r17
    e26a:	0f 91       	pop	r16
    e26c:	ff 90       	pop	r15
    e26e:	ef 90       	pop	r14
    e270:	08 95       	ret

0000e272 <Key_MB0_BitRate>:
	{" BAUD: }}}}}bps     ", NULL, F_MB##N##_Baud}																														\
};																																																					\
MenuPage MenuModbus##N = {SetMenu(L_MB##N), 1};

#if Modbus_Qt == 1
	M_Modbus(0)
    e272:	80 e0       	ldi	r24, 0x00	; 0
    e274:	0e 94 ea 70 	call	0xe1d4	; 0xe1d4 <SetBAUD>
    e278:	08 95       	ret

0000e27a <SetParity>:
// ~~~

// ~~~~~~~~~~~~~~~~~~~~
void
SetParity(uint8_t MB_N)
{
    e27a:	ff 92       	push	r15
    e27c:	0f 93       	push	r16
    e27e:	1f 93       	push	r17
    e280:	cf 93       	push	r28
    e282:	df 93       	push	r29
	uint8_t Parity = erb(&MB_Param[MB_N].Parity), S_B = erb(&MB_Param[MB_N].StopBits);
    e284:	c8 2f       	mov	r28, r24
    e286:	d0 e0       	ldi	r29, 0x00	; 0
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    e288:	8e 01       	movw	r16, r28
    e28a:	00 0f       	add	r16, r16
    e28c:	11 1f       	adc	r17, r17
    e28e:	0c 0f       	add	r16, r28
    e290:	1d 1f       	adc	r17, r29
    e292:	c8 01       	movw	r24, r16
    e294:	8c 5f       	subi	r24, 0xFC	; 252
    e296:	9f 4f       	sbci	r25, 0xFF	; 255
    e298:	0e 94 e7 82 	call	0x105ce	; 0x105ce <__eerd_byte_m2560>
    e29c:	f8 2e       	mov	r15, r24
    e29e:	0b 5f       	subi	r16, 0xFB	; 251
    e2a0:	1f 4f       	sbci	r17, 0xFF	; 255
    e2a2:	c8 01       	movw	r24, r16
    e2a4:	0e 94 e7 82 	call	0x105ce	; 0x105ce <__eerd_byte_m2560>
    e2a8:	48 2f       	mov	r20, r24
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		uint8_t ucsrc = (~(1<<6) |(1<<2) |(1<<1)) &~(1<<0);
		if (Parity==NoParity) {
    e2aa:	ff 20       	and	r15, r15
    e2ac:	e1 f4       	brne	.+56     	; 0xe2e6 <SetParity+0x6c>
			ucsrc &=~(1<<5) &~(1<<4);
			switch (S_B) {
    e2ae:	81 30       	cpi	r24, 0x01	; 1
    e2b0:	09 f4       	brne	.+2      	; 0xe2b4 <SetParity+0x3a>
    e2b2:	3d c0       	rjmp	.+122    	; 0xe32e <SetParity+0xb4>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    e2b4:	ce 01       	movw	r24, r28
    e2b6:	88 0f       	add	r24, r24
    e2b8:	99 1f       	adc	r25, r25
    e2ba:	88 0f       	add	r24, r24
    e2bc:	99 1f       	adc	r25, r25
    e2be:	9c 01       	movw	r18, r24
    e2c0:	22 0f       	add	r18, r18
    e2c2:	33 1f       	adc	r19, r19
    e2c4:	22 0f       	add	r18, r18
    e2c6:	33 1f       	adc	r19, r19
    e2c8:	28 0f       	add	r18, r24
    e2ca:	39 1f       	adc	r19, r25
    e2cc:	29 5b       	subi	r18, 0xB9	; 185
    e2ce:	31 4d       	sbci	r19, 0xD1	; 209
    e2d0:	f9 01       	movw	r30, r18
    e2d2:	a5 91       	lpm	r26, Z+
    e2d4:	b4 91       	lpm	r27, Z+
		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
			ucsrc  |=(1<<7);
		#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
			ucsrc &=~(1<<7);
		#endif
		USART_Reg(MB_N, ucsrc) = ucsrc;
    e2d6:	8e e0       	ldi	r24, 0x0E	; 14
    e2d8:	8c 93       	st	X, r24
			}
		}
	#endif
	if (Parity!=NoParity && S_B!=1)
		ewb(&MB_Param[MB_N].StopBits, 1);
}
    e2da:	df 91       	pop	r29
    e2dc:	cf 91       	pop	r28
    e2de:	1f 91       	pop	r17
    e2e0:	0f 91       	pop	r16
    e2e2:	ff 90       	pop	r15
    e2e4:	08 95       	ret
				break;
			}
		}
		else {
			ucsrc &=~(1<<3);
			switch (Parity) {
    e2e6:	81 e0       	ldi	r24, 0x01	; 1
    e2e8:	f8 16       	cp	r15, r24
    e2ea:	f9 f0       	breq	.+62     	; 0xe32a <SetParity+0xb0>
			}
		}
	#endif
	if (Parity!=NoParity && S_B!=1)
		ewb(&MB_Param[MB_N].StopBits, 1);
}
    e2ec:	56 e3       	ldi	r21, 0x36	; 54
    e2ee:	ce 01       	movw	r24, r28
    e2f0:	88 0f       	add	r24, r24
    e2f2:	99 1f       	adc	r25, r25
    e2f4:	88 0f       	add	r24, r24
    e2f6:	99 1f       	adc	r25, r25
    e2f8:	9c 01       	movw	r18, r24
    e2fa:	22 0f       	add	r18, r18
    e2fc:	33 1f       	adc	r19, r19
    e2fe:	22 0f       	add	r18, r18
    e300:	33 1f       	adc	r19, r19
    e302:	28 0f       	add	r18, r24
    e304:	39 1f       	adc	r19, r25
    e306:	29 5b       	subi	r18, 0xB9	; 185
    e308:	31 4d       	sbci	r19, 0xD1	; 209
    e30a:	f9 01       	movw	r30, r18
    e30c:	a5 91       	lpm	r26, Z+
    e30e:	b4 91       	lpm	r27, Z+
		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
			ucsrc  |=(1<<7);
		#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
			ucsrc &=~(1<<7);
		#endif
		USART_Reg(MB_N, ucsrc) = ucsrc;
    e310:	5c 93       	st	X, r21
				usart->CTRLC |=USART_PMODE_ODD_gc;
				break;
			}
		}
	#endif
	if (Parity!=NoParity && S_B!=1)
    e312:	41 30       	cpi	r20, 0x01	; 1
    e314:	21 f0       	breq	.+8      	; 0xe31e <SetParity+0xa4>
		ewb(&MB_Param[MB_N].StopBits, 1);
    e316:	c8 01       	movw	r24, r16
    e318:	61 e0       	ldi	r22, 0x01	; 1
    e31a:	0e 94 4e 4c 	call	0x989c	; 0x989c <ewb>
}
    e31e:	df 91       	pop	r29
    e320:	cf 91       	pop	r28
    e322:	1f 91       	pop	r17
    e324:	0f 91       	pop	r16
    e326:	ff 90       	pop	r15
    e328:	08 95       	ret
				break;
			}
		}
		else {
			ucsrc &=~(1<<3);
			switch (Parity) {
    e32a:	56 e2       	ldi	r21, 0x26	; 38
    e32c:	e0 cf       	rjmp	.-64     	; 0xe2ee <SetParity+0x74>
    e32e:	ce 01       	movw	r24, r28
    e330:	88 0f       	add	r24, r24
    e332:	99 1f       	adc	r25, r25
    e334:	88 0f       	add	r24, r24
    e336:	99 1f       	adc	r25, r25
    e338:	9c 01       	movw	r18, r24
    e33a:	22 0f       	add	r18, r18
    e33c:	33 1f       	adc	r19, r19
    e33e:	22 0f       	add	r18, r18
    e340:	33 1f       	adc	r19, r19
    e342:	28 0f       	add	r18, r24
    e344:	39 1f       	adc	r19, r25
    e346:	29 5b       	subi	r18, 0xB9	; 185
    e348:	31 4d       	sbci	r19, 0xD1	; 209
    e34a:	f9 01       	movw	r30, r18
    e34c:	a5 91       	lpm	r26, Z+
    e34e:	b4 91       	lpm	r27, Z+
		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
			ucsrc  |=(1<<7);
		#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
			ucsrc &=~(1<<7);
		#endif
		USART_Reg(MB_N, ucsrc) = ucsrc;
    e350:	86 e0       	ldi	r24, 0x06	; 6
    e352:	8c 93       	st	X, r24
			}
		}
	#endif
	if (Parity!=NoParity && S_B!=1)
		ewb(&MB_Param[MB_N].StopBits, 1);
}
    e354:	df 91       	pop	r29
    e356:	cf 91       	pop	r28
    e358:	1f 91       	pop	r17
    e35a:	0f 91       	pop	r16
    e35c:	ff 90       	pop	r15
    e35e:	08 95       	ret

0000e360 <Key_MB0_Parity>:
    e360:	80 e0       	ldi	r24, 0x00	; 0
    e362:	0e 94 3d 71 	call	0xe27a	; 0xe27a <SetParity>
    e366:	08 95       	ret

0000e368 <MB_Init>:

// ~~~~~~~~~~
void
MB_Init(void)
{
	MB_PLC_Init();
    e368:	0e 94 5f 1e 	call	0x3cbe	; 0x3cbe <MB_PLC_Init>
		PORTE.DIR |=(1<<3);
	#endif
	for (uint8_t MB_N=0; MB_N<Modbus_Qt; MB_N++) {
		void MB_S_Init(uint8_t);
		void MB_M_Init(uint8_t);
		MB_State[MB_N] = MB_Initi;
    e36c:	10 92 c0 05 	sts	0x05C0, r1
    e370:	83 e4       	ldi	r24, 0x43	; 67
    e372:	9e e2       	ldi	r25, 0x2E	; 46
    e374:	fc 01       	movw	r30, r24
    e376:	a5 91       	lpm	r26, Z+
    e378:	b4 91       	lpm	r27, Z+
		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
			USART_Reg(MB_N, ucsra) = ~(1<<1) &~(1<<0);
    e37a:	8c ef       	ldi	r24, 0xFC	; 252
    e37c:	8c 93       	st	X, r24
    e37e:	85 e4       	ldi	r24, 0x45	; 69
    e380:	9e e2       	ldi	r25, 0x2E	; 46
    e382:	fc 01       	movw	r30, r24
    e384:	a5 91       	lpm	r26, Z+
    e386:	b4 91       	lpm	r27, Z+
			USART_Reg(MB_N, ucsrb) = (((1<<7) &~(1<<6) &~(1<<5)) |(1<<4) |(1<<3)) &~(1<<2);
    e388:	88 e9       	ldi	r24, 0x98	; 152
    e38a:	8c 93       	st	X, r24
			tc->CTRLD = TC_EVACT_OFF_gc;
			//tc->CTRLE = TC1_BYTEM_bm;
			tc->INTCTRLA |=TC_ERRINTLVL_OFF_gc;
			tc->INTCTRLB = 0;
		#endif
		SetParity(MB_N);
    e38c:	80 e0       	ldi	r24, 0x00	; 0
    e38e:	0e 94 3d 71 	call	0xe27a	; 0xe27a <SetParity>
		SetBAUD(MB_N);
    e392:	80 e0       	ldi	r24, 0x00	; 0
    e394:	0e 94 ea 70 	call	0xe1d4	; 0xe1d4 <SetBAUD>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    e398:	e5 e5       	ldi	r30, 0x55	; 85
    e39a:	fe e2       	ldi	r31, 0x2E	; 46
    e39c:	84 91       	lpm	r24, Z+
		switch (prb(MB_Role+MB_N)) {
    e39e:	88 23       	and	r24, r24
    e3a0:	59 f4       	brne	.+22     	; 0xe3b8 <MB_Init+0x50>
		case Role_Slave:
			MB_S_Init(MB_N);
    e3a2:	80 e0       	ldi	r24, 0x00	; 0
    e3a4:	0e 94 da 70 	call	0xe1b4	; 0xe1b4 <MB_S_Init>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    e3a8:	8a e5       	ldi	r24, 0x5A	; 90
    e3aa:	9e e2       	ldi	r25, 0x2E	; 46
    e3ac:	fc 01       	movw	r30, r24
    e3ae:	25 91       	lpm	r18, Z+
    e3b0:	34 91       	lpm	r19, Z+
			break;
		case Role_Master:
			MB_M_Init(MB_N);
			break;
		}
		MB_StartTimer(MB_N);
    e3b2:	f9 01       	movw	r30, r18
    e3b4:	19 95       	eicall
	}
}
    e3b6:	08 95       	ret
			tc->INTCTRLA |=TC_ERRINTLVL_OFF_gc;
			tc->INTCTRLB = 0;
		#endif
		SetParity(MB_N);
		SetBAUD(MB_N);
		switch (prb(MB_Role+MB_N)) {
    e3b8:	81 30       	cpi	r24, 0x01	; 1
    e3ba:	b1 f7       	brne	.-20     	; 0xe3a8 <MB_Init+0x40>
		case Role_Slave:
			MB_S_Init(MB_N);
			break;
		case Role_Master:
			MB_M_Init(MB_N);
    e3bc:	80 e0       	ldi	r24, 0x00	; 0
    e3be:	0e 94 89 70 	call	0xe112	; 0xe112 <MB_M_Init>
    e3c2:	f2 cf       	rjmp	.-28     	; 0xe3a8 <MB_Init+0x40>

0000e3c4 <USART_Init>:

// ~~~~~~~~~~~~~
void
USART_Init(void)
{
	MB_Init();
    e3c4:	0e 94 b4 71 	call	0xe368	; 0xe368 <MB_Init>
	#ifdef GSM
		GSM_Init();
    e3c8:	0e 94 7d 39 	call	0x72fa	; 0x72fa <GSM_Init>
	#endif
	#ifdef UDP_EASY
		UDP_Init();
	#endif
}
    e3cc:	08 95       	ret

0000e3ce <LCDBackLightStartTimer>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    e3ce:	81 e3       	ldi	r24, 0x31	; 49
    e3d0:	91 e0       	ldi	r25, 0x01	; 1
    e3d2:	0e 94 e7 82 	call	0x105ce	; 0x105ce <__eerd_byte_m2560>
			PORT_BACKLIGHT &= ~BACKLIGHT;
		#endif
		IntOn();
	}
	void LCDBackLightStartTimer(void){
		switch(erb(&BackLightTimeEE)){
    e3d6:	82 30       	cpi	r24, 0x02	; 2
    e3d8:	e9 f0       	breq	.+58     	; 0xe414 <LCDBackLightStartTimer+0x46>
    e3da:	83 30       	cpi	r24, 0x03	; 3
    e3dc:	58 f0       	brcs	.+22     	; 0xe3f4 <LCDBackLightStartTimer+0x26>
    e3de:	83 30       	cpi	r24, 0x03	; 3
    e3e0:	01 f1       	breq	.+64     	; 0xe422 <LCDBackLightStartTimer+0x54>
    e3e2:	84 30       	cpi	r24, 0x04	; 4
    e3e4:	81 f0       	breq	.+32     	; 0xe406 <LCDBackLightStartTimer+0x38>
				break;	
			case BCKLT_10min:
				StartTimer16(TD_BackLight, 60000);
				break;
			default:
				StartTimer16(TD_BackLight, 3000);
    e3e6:	80 91 d6 04 	lds	r24, 0x04D6
    e3ea:	68 eb       	ldi	r22, 0xB8	; 184
    e3ec:	7b e0       	ldi	r23, 0x0B	; 11
    e3ee:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
    e3f2:	08 95       	ret
			PORT_BACKLIGHT &= ~BACKLIGHT;
		#endif
		IntOn();
	}
	void LCDBackLightStartTimer(void){
		switch(erb(&BackLightTimeEE)){
    e3f4:	88 23       	and	r24, r24
    e3f6:	b9 f7       	brne	.-18     	; 0xe3e6 <LCDBackLightStartTimer+0x18>
			case BCKLT_10sec:
				StartTimer16(TD_BackLight, 1000);
    e3f8:	80 91 d6 04 	lds	r24, 0x04D6
    e3fc:	68 ee       	ldi	r22, 0xE8	; 232
    e3fe:	73 e0       	ldi	r23, 0x03	; 3
    e400:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
    e404:	08 95       	ret
				break;
			case BCKLT_3min:
				StartTimer16(TD_BackLight, 18000);
				break;	
			case BCKLT_10min:
				StartTimer16(TD_BackLight, 60000);
    e406:	80 91 d6 04 	lds	r24, 0x04D6
    e40a:	60 e6       	ldi	r22, 0x60	; 96
    e40c:	7a ee       	ldi	r23, 0xEA	; 234
    e40e:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
    e412:	08 95       	ret
				break;
			case BCKLT_30sec:
				StartTimer16(TD_BackLight, 3000);
				break;
			case BCKLT_1min:
				StartTimer16(TD_BackLight, 6000);
    e414:	80 91 d6 04 	lds	r24, 0x04D6
    e418:	60 e7       	ldi	r22, 0x70	; 112
    e41a:	77 e1       	ldi	r23, 0x17	; 23
    e41c:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
    e420:	08 95       	ret
				break;
			case BCKLT_3min:
				StartTimer16(TD_BackLight, 18000);
    e422:	80 91 d6 04 	lds	r24, 0x04D6
    e426:	60 e5       	ldi	r22, 0x50	; 80
    e428:	76 e4       	ldi	r23, 0x46	; 70
    e42a:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
    e42e:	08 95       	ret

0000e430 <LCDBackLightInit>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    e430:	9f b7       	in	r25, 0x3f	; 63
    e432:	90 78       	andi	r25, 0x80	; 128
    e434:	90 93 ec 02 	sts	0x02EC, r25
	cli();
    e438:	f8 94       	cli
	enum BACKLIGHT_TIMES{ BCKLT_10sec, BCKLT_30sec, BCKLT_1min,  BCKLT_3min,  BCKLT_10min};
	static uint8_t EEMEM BackLightTimeEE = BCKLT_10sec;

	void LCDBackLightInit(void){
		IntOff();	
		DDR_BACKLIGHT |= BACKLIGHT;
    e43a:	80 91 0a 01 	lds	r24, 0x010A
    e43e:	80 64       	ori	r24, 0x40	; 64
    e440:	80 93 0a 01 	sts	0x010A, r24

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    e444:	99 23       	and	r25, r25
    e446:	09 f0       	breq	.+2      	; 0xe44a <LCDBackLightInit+0x1a>
		sei();
    e448:	78 94       	sei

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    e44a:	80 91 d0 02 	lds	r24, 0x02D0
	VacantTimer16Sys += n;
    e44e:	8f 5f       	subi	r24, 0xFF	; 255
    e450:	80 93 d0 02 	sts	0x02D0, r24
    e454:	81 50       	subi	r24, 0x01	; 1
		IntOn();	
		TD_BackLight = Timer16SysAlloc(1);
    e456:	80 93 d6 04 	sts	0x04D6, r24
		if(BackLightMode != 2){
    e45a:	80 91 50 06 	lds	r24, 0x0650
    e45e:	82 30       	cpi	r24, 0x02	; 2
    e460:	21 f0       	breq	.+8      	; 0xe46a <LCDBackLightInit+0x3a>
			LCDBackLightOn();
    e462:	0e 94 3f 28 	call	0x507e	; 0x507e <LCDBackLightOn>
			LCDBackLightStartTimer();
    e466:	0e 94 e7 71 	call	0xe3ce	; 0xe3ce <LCDBackLightStartTimer>
    e46a:	08 95       	ret

0000e46c <LCD_Init>:
}

// ~~~~~~~~~~~~
void
LCD_Init (void)
{
    e46c:	ef 92       	push	r14
    e46e:	ff 92       	push	r15
    e470:	1f 93       	push	r17
    e472:	cf 93       	push	r28
    e474:	df 93       	push	r29
	uint8_t i, j;

	// LCD pins
	#ifdef Port_LCD_RW
		Port_LCD_RW &= ~LCD_RW;
    e476:	43 98       	cbi	0x08, 3	; 8
		DDR_LCD_RW |= LCD_RW;
    e478:	3b 9a       	sbi	0x07, 3	; 7
	#endif

	Port_LCD_RS &= ~LCD_RS;	
    e47a:	44 98       	cbi	0x08, 4	; 8
	DDR_LCD_RS |=LCD_RS;
    e47c:	3c 9a       	sbi	0x07, 4	; 7

	Port_LCD_E &= ~LCD_E;	
    e47e:	42 98       	cbi	0x08, 2	; 8
	DDR_LCD_E |=LCD_E;
    e480:	3a 9a       	sbi	0x07, 2	; 7

	#ifdef Port_LCD_DB0	
		DDR_LCD_DB0 |=DB0;
    e482:	39 9a       	sbi	0x07, 1	; 7
		DDR_LCD_DB1 |=DB1;
    e484:	38 9a       	sbi	0x07, 0	; 7
		DDR_LCD_DB2 |=DB2;
    e486:	99 9a       	sbi	0x13, 1	; 19
		DDR_LCD_DB3 |=DB3;
    e488:	98 9a       	sbi	0x13, 0	; 19
	#endif
	DDR_LCD_DB4 |=DB4;
    e48a:	57 9a       	sbi	0x0a, 7	; 10
	DDR_LCD_DB5 |=DB5;
    e48c:	56 9a       	sbi	0x0a, 6	; 10
	DDR_LCD_DB6 |=DB6;
    e48e:	55 9a       	sbi	0x0a, 5	; 10
	DDR_LCD_DB7 |=DB7;
    e490:	80 91 0a 01 	lds	r24, 0x010A
    e494:	80 68       	ori	r24, 0x80	; 128
    e496:	80 93 0a 01 	sts	0x010A, r24
    e49a:	21 e3       	ldi	r18, 0x31	; 49
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    e49c:	40 ea       	ldi	r20, 0xA0	; 160
    e49e:	5f e0       	ldi	r21, 0x0F	; 15
    e4a0:	ca 01       	movw	r24, r20
    e4a2:	01 97       	sbiw	r24, 0x01	; 1
    e4a4:	f1 f7       	brne	.-4      	; 0xe4a2 <LCD_Init+0x36>

// ~~~~~~~~~~~~~~~~~~~~
void
Delay_ms(uint8_t Delay)
{
	while (Delay--)
    e4a6:	21 50       	subi	r18, 0x01	; 1
    e4a8:	d8 f7       	brcc	.-10     	; 0xe4a0 <LCD_Init+0x34>
#endif
// ~~~~~~~~~~~
static void
LCD_Rst0(void)
{
	cli();
    e4aa:	f8 94       	cli
	Port_LCD_RS &=~LCD_RS;
    e4ac:	44 98       	cbi	0x08, 4	; 8
	LCD_FuncSet0();
    e4ae:	0e 94 99 26 	call	0x4d32	; 0x4d32 <LCD_FuncSet0>
	sei();
    e4b2:	78 94       	sei
    e4b4:	80 ea       	ldi	r24, 0xA0	; 160
    e4b6:	9f e0       	ldi	r25, 0x0F	; 15
    e4b8:	fc 01       	movw	r30, r24
    e4ba:	31 97       	sbiw	r30, 0x01	; 1
    e4bc:	f1 f7       	brne	.-4      	; 0xe4ba <LCD_Init+0x4e>
    e4be:	fc 01       	movw	r30, r24
    e4c0:	31 97       	sbiw	r30, 0x01	; 1
    e4c2:	f1 f7       	brne	.-4      	; 0xe4c0 <LCD_Init+0x54>
    e4c4:	fc 01       	movw	r30, r24
    e4c6:	31 97       	sbiw	r30, 0x01	; 1
    e4c8:	f1 f7       	brne	.-4      	; 0xe4c6 <LCD_Init+0x5a>
    e4ca:	fc 01       	movw	r30, r24
    e4cc:	31 97       	sbiw	r30, 0x01	; 1
    e4ce:	f1 f7       	brne	.-4      	; 0xe4cc <LCD_Init+0x60>
    e4d0:	01 97       	sbiw	r24, 0x01	; 1
    e4d2:	f1 f7       	brne	.-4      	; 0xe4d0 <LCD_Init+0x64>

// ~~~~~~~~~~~
static void
LCD_Rst1(void)
{
	LCD_FuncSet0();
    e4d4:	0e 94 99 26 	call	0x4d32	; 0x4d32 <LCD_FuncSet0>
	Delay_us(200);				// 100 us needs
    e4d8:	88 ec       	ldi	r24, 0xC8	; 200
    e4da:	90 e0       	ldi	r25, 0x00	; 0
    e4dc:	0e 94 47 1e 	call	0x3c8e	; 0x3c8e <Delay_us>
	LCD_FuncSet0();
    e4e0:	0e 94 99 26 	call	0x4d32	; 0x4d32 <LCD_FuncSet0>
	Delay_us(LCD_Delay);
    e4e4:	82 e3       	ldi	r24, 0x32	; 50
    e4e6:	90 e0       	ldi	r25, 0x00	; 0
    e4e8:	0e 94 47 1e 	call	0x3c8e	; 0x3c8e <Delay_us>
	#ifdef Port_LCD_DB0	
		LCD_FuncSet0();
    e4ec:	0e 94 99 26 	call	0x4d32	; 0x4d32 <LCD_FuncSet0>
	#else
		LCD_FuncSet1();
	#endif
//// BF(Busy flag) can be checked follow
	Delay_us(LCD_Delay);
    e4f0:	82 e3       	ldi	r24, 0x32	; 50
    e4f2:	90 e0       	ldi	r25, 0x00	; 0
    e4f4:	0e 94 47 1e 	call	0x3c8e	; 0x3c8e <Delay_us>
	Port_LCD_RS |=LCD_RS;
    e4f8:	44 9a       	sbi	0x08, 4	; 8

	LCD_Rst0();
	Delay_ms(5);		// 4.1 ms needs
	LCD_Rst1();

	Port_LCD_RS &=~LCD_RS;
    e4fa:	44 98       	cbi	0x08, 4	; 8

	#ifdef Port_LCD_DB0	
		Send_I(0b00111000);	//; 8-bits DL, 2 lines, 5x7 dots
    e4fc:	88 e3       	ldi	r24, 0x38	; 56
    e4fe:	0e 94 92 26 	call	0x4d24	; 0x4d24 <Send_I>
	#else
		Send_I(0b00101000);	//; 4-bits DL, 2 lines, 5x7 dots
	#endif
	Send_I(0b00001100);	//; Display on, cursor off, blink off	
    e502:	8c e0       	ldi	r24, 0x0C	; 12
    e504:	0e 94 92 26 	call	0x4d24	; 0x4d24 <Send_I>
	Send_I(0b00000110);	//; cursor shift right, no display shift
    e508:	86 e0       	ldi	r24, 0x06	; 6
    e50a:	0e 94 92 26 	call	0x4d24	; 0x4d24 <Send_I>


	Send_I(0b01000000);	//;    CG RAM   0.
    e50e:	80 e4       	ldi	r24, 0x40	; 64
    e510:	0e 94 92 26 	call	0x4d24	; 0x4d24 <Send_I>
	Port_LCD_RS |=LCD_RS;
    e514:	44 9a       	sbi	0x08, 4	; 8
    e516:	88 e6       	ldi	r24, 0x68	; 104
    e518:	e8 2e       	mov	r14, r24
    e51a:	8e e2       	ldi	r24, 0x2E	; 46
    e51c:	f8 2e       	mov	r15, r24
	for (i=0; i<8; i++)
    e51e:	e7 01       	movw	r28, r14
    e520:	10 e0       	ldi	r17, 0x00	; 0

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    e522:	fe 01       	movw	r30, r28
    e524:	84 91       	lpm	r24, Z+
		for (j=0; j<8; j++)
			Send_I(prb(CGRAM_LCD[i]+j));
    e526:	0e 94 92 26 	call	0x4d24	; 0x4d24 <Send_I>


	Send_I(0b01000000);	//;    CG RAM   0.
	Port_LCD_RS |=LCD_RS;
	for (i=0; i<8; i++)
		for (j=0; j<8; j++)
    e52a:	1f 5f       	subi	r17, 0xFF	; 255
    e52c:	21 96       	adiw	r28, 0x01	; 1
    e52e:	18 30       	cpi	r17, 0x08	; 8
    e530:	c1 f7       	brne	.-16     	; 0xe522 <LCD_Init+0xb6>
    e532:	88 e0       	ldi	r24, 0x08	; 8
    e534:	90 e0       	ldi	r25, 0x00	; 0
    e536:	e8 0e       	add	r14, r24
    e538:	f9 1e       	adc	r15, r25
	Send_I(0b00000110);	//; cursor shift right, no display shift


	Send_I(0b01000000);	//;    CG RAM   0.
	Port_LCD_RS |=LCD_RS;
	for (i=0; i<8; i++)
    e53a:	98 ea       	ldi	r25, 0xA8	; 168
    e53c:	e9 16       	cp	r14, r25
    e53e:	9e e2       	ldi	r25, 0x2E	; 46
    e540:	f9 06       	cpc	r15, r25
    e542:	69 f7       	brne	.-38     	; 0xe51e <LCD_Init+0xb2>
		for (j=0; j<8; j++)
			Send_I(prb(CGRAM_LCD[i]+j));

	Port_LCD_RS &=~LCD_RS;
    e544:	44 98       	cbi	0x08, 4	; 8
	Send(0b00000001);
    e546:	81 e0       	ldi	r24, 0x01	; 1
    e548:	0e 94 51 26 	call	0x4ca2	; 0x4ca2 <Send>
    e54c:	80 ea       	ldi	r24, 0xA0	; 160
    e54e:	9f e0       	ldi	r25, 0x0F	; 15
    e550:	fc 01       	movw	r30, r24
    e552:	31 97       	sbiw	r30, 0x01	; 1
    e554:	f1 f7       	brne	.-4      	; 0xe552 <LCD_Init+0xe6>
    e556:	fc 01       	movw	r30, r24
    e558:	31 97       	sbiw	r30, 0x01	; 1
    e55a:	f1 f7       	brne	.-4      	; 0xe558 <LCD_Init+0xec>
    e55c:	fc 01       	movw	r30, r24
    e55e:	31 97       	sbiw	r30, 0x01	; 1
    e560:	f1 f7       	brne	.-4      	; 0xe55e <LCD_Init+0xf2>
    e562:	fc 01       	movw	r30, r24
    e564:	31 97       	sbiw	r30, 0x01	; 1
    e566:	f1 f7       	brne	.-4      	; 0xe564 <LCD_Init+0xf8>
    e568:	01 97       	sbiw	r24, 0x01	; 1
    e56a:	f1 f7       	brne	.-4      	; 0xe568 <LCD_Init+0xfc>
	Delay_ms(5);				// By trial
	Port_LCD_RS |=LCD_RS;
    e56c:	44 9a       	sbi	0x08, 4	; 8
}

uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    e56e:	80 91 cf 02 	lds	r24, 0x02CF
	VacantTimer8Sys += n;
    e572:	8f 5f       	subi	r24, 0xFF	; 255
    e574:	80 93 cf 02 	sts	0x02CF, r24
    e578:	81 50       	subi	r24, 0x01	; 1

	// Frame Timer
	TD_LCD = Timer8SysAlloc(1);
    e57a:	80 93 d5 04 	sts	0x04D5, r24
    e57e:	20 e0       	ldi	r18, 0x00	; 0
    e580:	30 e0       	ldi	r19, 0x00	; 0

	for (i=0; i<LCDYSz; i++)
		for (j=0; j<LCDXSz; j++)
			LCD_Buf[i][j] = ' ';
    e582:	40 e2       	ldi	r20, 0x20	; 32
	Port_LCD_RS |=LCD_RS;

	// Frame Timer
	TD_LCD = Timer8SysAlloc(1);

	for (i=0; i<LCDYSz; i++)
    e584:	c9 01       	movw	r24, r18
    e586:	88 0f       	add	r24, r24
    e588:	99 1f       	adc	r25, r25
    e58a:	82 0f       	add	r24, r18
    e58c:	93 1f       	adc	r25, r19
    e58e:	fc 01       	movw	r30, r24
    e590:	ee 0f       	add	r30, r30
    e592:	ff 1f       	adc	r31, r31
    e594:	ee 0f       	add	r30, r30
    e596:	ff 1f       	adc	r31, r31
    e598:	ee 0f       	add	r30, r30
    e59a:	ff 1f       	adc	r31, r31
    e59c:	e8 1b       	sub	r30, r24
    e59e:	f9 0b       	sbc	r31, r25
    e5a0:	ea 5a       	subi	r30, 0xAA	; 170
    e5a2:	f9 4f       	sbci	r31, 0xF9	; 249
    e5a4:	80 e0       	ldi	r24, 0x00	; 0
		for (j=0; j<LCDXSz; j++)
			LCD_Buf[i][j] = ' ';
    e5a6:	41 93       	st	Z+, r20

	// Frame Timer
	TD_LCD = Timer8SysAlloc(1);

	for (i=0; i<LCDYSz; i++)
		for (j=0; j<LCDXSz; j++)
    e5a8:	8f 5f       	subi	r24, 0xFF	; 255
    e5aa:	84 31       	cpi	r24, 0x14	; 20
    e5ac:	e1 f7       	brne	.-8      	; 0xe5a6 <LCD_Init+0x13a>
    e5ae:	2f 5f       	subi	r18, 0xFF	; 255
    e5b0:	3f 4f       	sbci	r19, 0xFF	; 255
	Port_LCD_RS |=LCD_RS;

	// Frame Timer
	TD_LCD = Timer8SysAlloc(1);

	for (i=0; i<LCDYSz; i++)
    e5b2:	24 30       	cpi	r18, 0x04	; 4
    e5b4:	31 05       	cpc	r19, r1
    e5b6:	31 f7       	brne	.-52     	; 0xe584 <LCD_Init+0x118>
		for (j=0; j<LCDXSz; j++)
			LCD_Buf[i][j] = ' ';

	#ifdef RTYP
		#ifndef QslRD
			*(uint8_t*)RTYP = R_PLC_Type;
    e5b8:	87 e0       	ldi	r24, 0x07	; 7
    e5ba:	80 93 49 08 	sts	0x0849, r24
		#endif	
	#endif

	#ifdef BACKLIGHT
		LCDBackLightInit();
    e5be:	0e 94 18 72 	call	0xe430	; 0xe430 <LCDBackLightInit>
	#endif
}
    e5c2:	df 91       	pop	r29
    e5c4:	cf 91       	pop	r28
    e5c6:	1f 91       	pop	r17
    e5c8:	ff 90       	pop	r15
    e5ca:	ef 90       	pop	r14
    e5cc:	08 95       	ret

0000e5ce <RTC_Summer_Time>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    e5ce:	83 e0       	ldi	r24, 0x03	; 3
    e5d0:	90 e0       	ldi	r25, 0x00	; 0
    e5d2:	0e 94 e7 82 	call	0x105ce	; 0x105ce <__eerd_byte_m2560>
	
	return 0;
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void RTC_Summer_Time(void){
	if(erb(&SummerTime)){
    e5d6:	88 23       	and	r24, r24
    e5d8:	31 f0       	breq	.+12     	; 0xe5e6 <RTC_Summer_Time+0x18>
		//   ()  02:00:00   03:00:00    
		if( (Tm_Mon == 3) && (Tm_WDay == 0) && (Tm_MDay>=25) && (Tm_Hour == 2) ){
    e5da:	90 91 85 07 	lds	r25, 0x0785
    e5de:	93 30       	cpi	r25, 0x03	; 3
    e5e0:	b1 f0       	breq	.+44     	; 0xe60e <RTC_Summer_Time+0x40>
				Tm_Hour=3;
				SetHour();
		}

		//   ()  04:00:00   03:00:00    
		if( (Tm_Mon == 10) && (Tm_WDay == 0) && (Tm_MDay>=25) ){
    e5e2:	9a 30       	cpi	r25, 0x0A	; 10
    e5e4:	09 f0       	breq	.+2      	; 0xe5e8 <RTC_Summer_Time+0x1a>
    e5e6:	08 95       	ret
    e5e8:	80 91 55 06 	lds	r24, 0x0655
    e5ec:	88 23       	and	r24, r24
    e5ee:	d9 f7       	brne	.-10     	; 0xe5e6 <RTC_Summer_Time+0x18>
    e5f0:	80 91 17 0b 	lds	r24, 0x0B17
    e5f4:	89 31       	cpi	r24, 0x19	; 25
    e5f6:	b8 f3       	brcs	.-18     	; 0xe5e6 <RTC_Summer_Time+0x18>
				if(Tm_Hour == 4){
    e5f8:	80 91 bf 05 	lds	r24, 0x05BF
    e5fc:	84 30       	cpi	r24, 0x04	; 4
    e5fe:	d1 f0       	breq	.+52     	; 0xe634 <RTC_Summer_Time+0x66>
						Tm_Hour=3;
						SetHour();
						NotSummerTimeFlag = 1;
					}
				}
				if(Tm_Hour < 2) NotSummerTimeFlag = 0;
    e600:	82 30       	cpi	r24, 0x02	; 2
    e602:	38 f1       	brcs	.+78     	; 0xe652 <RTC_Summer_Time+0x84>
				if(Tm_Hour >= 5) NotSummerTimeFlag = 0;
    e604:	85 30       	cpi	r24, 0x05	; 5
    e606:	78 f3       	brcs	.-34     	; 0xe5e6 <RTC_Summer_Time+0x18>
    e608:	10 92 db 05 	sts	0x05DB, r1
    e60c:	08 95       	ret
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void RTC_Summer_Time(void){
	if(erb(&SummerTime)){
		//   ()  02:00:00   03:00:00    
		if( (Tm_Mon == 3) && (Tm_WDay == 0) && (Tm_MDay>=25) && (Tm_Hour == 2) ){
    e60e:	80 91 55 06 	lds	r24, 0x0655
    e612:	88 23       	and	r24, r24
    e614:	41 f7       	brne	.-48     	; 0xe5e6 <RTC_Summer_Time+0x18>
    e616:	80 91 17 0b 	lds	r24, 0x0B17
    e61a:	89 31       	cpi	r24, 0x19	; 25
    e61c:	20 f3       	brcs	.-56     	; 0xe5e6 <RTC_Summer_Time+0x18>
    e61e:	80 91 bf 05 	lds	r24, 0x05BF
    e622:	82 30       	cpi	r24, 0x02	; 2
    e624:	01 f7       	brne	.-64     	; 0xe5e6 <RTC_Summer_Time+0x18>
				Tm_Hour=3;
    e626:	90 93 bf 05 	sts	0x05BF, r25
				SetHour();
    e62a:	0e 94 25 24 	call	0x484a	; 0x484a <SetHour>
    e62e:	90 91 85 07 	lds	r25, 0x0785
    e632:	d7 cf       	rjmp	.-82     	; 0xe5e2 <RTC_Summer_Time+0x14>
		}

		//   ()  04:00:00   03:00:00    
		if( (Tm_Mon == 10) && (Tm_WDay == 0) && (Tm_MDay>=25) ){
				if(Tm_Hour == 4){
					if(!NotSummerTimeFlag){
    e634:	80 91 db 05 	lds	r24, 0x05DB
    e638:	88 23       	and	r24, r24
    e63a:	a9 f6       	brne	.-86     	; 0xe5e6 <RTC_Summer_Time+0x18>
						Tm_Hour=3;
    e63c:	83 e0       	ldi	r24, 0x03	; 3
    e63e:	80 93 bf 05 	sts	0x05BF, r24
						SetHour();
    e642:	0e 94 25 24 	call	0x484a	; 0x484a <SetHour>
						NotSummerTimeFlag = 1;
    e646:	81 e0       	ldi	r24, 0x01	; 1
    e648:	80 93 db 05 	sts	0x05DB, r24
    e64c:	80 91 bf 05 	lds	r24, 0x05BF
    e650:	d7 cf       	rjmp	.-82     	; 0xe600 <RTC_Summer_Time+0x32>
					}
				}
				if(Tm_Hour < 2) NotSummerTimeFlag = 0;
    e652:	10 92 db 05 	sts	0x05DB, r1
    e656:	d6 cf       	rjmp	.-84     	; 0xe604 <RTC_Summer_Time+0x36>

0000e658 <TWI_In>:
}

// ~~~~~~~~~
void
TWI_In(void)
{
    e658:	cf 92       	push	r12
    e65a:	ef 92       	push	r14
    e65c:	0f 93       	push	r16
	if(Timer8Stopp(TD_TWI_Poll)){
    e65e:	00 91 d0 04 	lds	r16, 0x04D0
    e662:	80 2f       	mov	r24, r16
    e664:	0e 94 4e 1c 	call	0x389c	; 0x389c <Timer8Stopp>
    e668:	88 23       	and	r24, r24
    e66a:	e1 f0       	breq	.+56     	; 0xe6a4 <TWI_In+0x4c>

		if (TWI_Phase == PCF_START){
    e66c:	80 91 7d 07 	lds	r24, 0x077D
    e670:	88 23       	and	r24, r24
    e672:	99 f1       	breq	.+102    	; 0xe6da <TWI_In+0x82>
			StartTWI();		// Send Start
			TWI_Phase++;
			StartTimer8(TD_TWI_Timeout,40);
			return;
		}
		if(Timer8Stopp(TD_TWI_Timeout)){	// 
    e674:	80 91 d1 04 	lds	r24, 0x04D1
    e678:	0e 94 4e 1c 	call	0x389c	; 0x389c <Timer8Stopp>
    e67c:	88 23       	and	r24, r24
    e67e:	09 f0       	breq	.+2      	; 0xe682 <TWI_In+0x2a>
    e680:	4e c0       	rjmp	.+156    	; 0xe71e <TWI_In+0xc6>
			TWI_Error();
			return;
		}

		if (!(TWCR &(1<<TWINT))) return;
    e682:	80 91 bc 00 	lds	r24, 0x00BC
    e686:	87 ff       	sbrs	r24, 7
    e688:	33 c0       	rjmp	.+102    	; 0xe6f0 <TWI_In+0x98>

		switch(TWI_Phase) {
    e68a:	40 91 7d 07 	lds	r20, 0x077D
    e68e:	84 2f       	mov	r24, r20
    e690:	90 e0       	ldi	r25, 0x00	; 0
    e692:	fc 01       	movw	r30, r24
    e694:	31 97       	sbiw	r30, 0x01	; 1
    e696:	e1 31       	cpi	r30, 0x11	; 17
    e698:	f1 05       	cpc	r31, r1
    e69a:	08 f4       	brcc	.+2      	; 0xe69e <TWI_In+0x46>
    e69c:	46 c0       	rjmp	.+140    	; 0xe72a <TWI_In+0xd2>
			Tm_WDay = SetWeekday(Tm_Year, Tm_Mon, Tm_MDay);
			StartTimer8(TD_TWI_Poll, 49);
			TWI_Phase = 0xFF;
			break;
		}
		TWI_Phase++;
    e69e:	4f 5f       	subi	r20, 0xFF	; 255
    e6a0:	40 93 7d 07 	sts	0x077D, r20
	}//Timer8Stopp(TD_TWI)

	if( Timer16Stopp(TD_RTC_Check) && (TWI_Phase == PCF_START) ){
    e6a4:	00 91 d2 04 	lds	r16, 0x04D2
    e6a8:	80 2f       	mov	r24, r16
    e6aa:	0e 94 71 1c 	call	0x38e2	; 0x38e2 <Timer16Stopp>
    e6ae:	88 23       	and	r24, r24
    e6b0:	f9 f0       	breq	.+62     	; 0xe6f0 <TWI_In+0x98>
    e6b2:	80 91 7d 07 	lds	r24, 0x077D
    e6b6:	88 23       	and	r24, r24
    e6b8:	d9 f4       	brne	.+54     	; 0xe6f0 <TWI_In+0x98>
		StartTimer16(TD_RTC_Check, 300);
    e6ba:	80 2f       	mov	r24, r16
    e6bc:	6c e2       	ldi	r22, 0x2C	; 44
    e6be:	71 e0       	ldi	r23, 0x01	; 1
    e6c0:	0e 94 35 1b 	call	0x366a	; 0x366a <StartTimer16>
		if(RTC_Check() || PFC_Stop_bit){
    e6c4:	0e 94 4a 25 	call	0x4a94	; 0x4a94 <RTC_Check>
    e6c8:	88 23       	and	r24, r24
    e6ca:	b1 f4       	brne	.+44     	; 0xe6f8 <TWI_In+0xa0>
    e6cc:	80 91 d3 04 	lds	r24, 0x04D3
    e6d0:	88 23       	and	r24, r24
    e6d2:	91 f4       	brne	.+36     	; 0xe6f8 <TWI_In+0xa0>
			// RTC
			SetDateTime(TrueTime_Year, TrueTime_Mon, TrueTime_MDay, TrueTime_WDay, TrueTime_Hour, TrueTime_Min, TrueTime_Sec);
		}
		else RTC_GetTrueTime();
    e6d4:	0e 94 01 25 	call	0x4a02	; 0x4a02 <RTC_GetTrueTime>
    e6d8:	1f c0       	rjmp	.+62     	; 0xe718 <TWI_In+0xc0>
TWI_In(void)
{
	if(Timer8Stopp(TD_TWI_Poll)){

		if (TWI_Phase == PCF_START){
			StartTWI();		// Send Start
    e6da:	84 ea       	ldi	r24, 0xA4	; 164
    e6dc:	80 93 bc 00 	sts	0x00BC, r24
			TWI_Phase++;
    e6e0:	81 e0       	ldi	r24, 0x01	; 1
    e6e2:	80 93 7d 07 	sts	0x077D, r24
			StartTimer8(TD_TWI_Timeout,40);
    e6e6:	80 91 d1 04 	lds	r24, 0x04D1
    e6ea:	68 e2       	ldi	r22, 0x28	; 40
    e6ec:	0e 94 fa 1a 	call	0x35f4	; 0x35f4 <StartTimer8>
		}
		else RTC_GetTrueTime();

		RTC_Summer_Time();
	}
}
    e6f0:	0f 91       	pop	r16
    e6f2:	ef 90       	pop	r14
    e6f4:	cf 90       	pop	r12
    e6f6:	08 95       	ret

	if( Timer16Stopp(TD_RTC_Check) && (TWI_Phase == PCF_START) ){
		StartTimer16(TD_RTC_Check, 300);
		if(RTC_Check() || PFC_Stop_bit){
			// RTC
			SetDateTime(TrueTime_Year, TrueTime_Mon, TrueTime_MDay, TrueTime_WDay, TrueTime_Hour, TrueTime_Min, TrueTime_Sec);
    e6f8:	80 91 7b 07 	lds	r24, 0x077B
    e6fc:	60 91 cd 08 	lds	r22, 0x08CD
    e700:	40 91 54 06 	lds	r20, 0x0654
    e704:	20 91 16 0b 	lds	r18, 0x0B16
    e708:	00 91 d6 05 	lds	r16, 0x05D6
    e70c:	e0 90 ce 08 	lds	r14, 0x08CE
    e710:	c0 90 cc 08 	lds	r12, 0x08CC
    e714:	0e 94 4d 24 	call	0x489a	; 0x489a <SetDateTime>
		}
		else RTC_GetTrueTime();

		RTC_Summer_Time();
    e718:	0e 94 e7 72 	call	0xe5ce	; 0xe5ce <RTC_Summer_Time>
    e71c:	e9 cf       	rjmp	.-46     	; 0xe6f0 <TWI_In+0x98>
			Tm_Mon = DecodBCD(TWDR & 0b00011111);
			if(Tm_Mon > 12) Tm_Mon = 0;	//
			RunTWI();		//NACK
			break;
		case PCF_Year:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_NACK){ TWI_Error(); return;}
    e71e:	0e 94 82 23 	call	0x4704	; 0x4704 <TWI_Error>
		}
		else RTC_GetTrueTime();

		RTC_Summer_Time();
	}
}
    e722:	0f 91       	pop	r16
    e724:	ef 90       	pop	r14
    e726:	cf 90       	pop	r12
    e728:	08 95       	ret
			return;
		}

		if (!(TWCR &(1<<TWINT))) return;

		switch(TWI_Phase) {
    e72a:	ea 5a       	subi	r30, 0xAA	; 170
    e72c:	fe 4f       	sbci	r31, 0xFE	; 254
    e72e:	ee 0f       	add	r30, r30
    e730:	ff 1f       	adc	r31, r31
    e732:	05 90       	lpm	r0, Z+
    e734:	f4 91       	lpm	r31, Z+
    e736:	e0 2d       	mov	r30, r0
    e738:	19 94       	eijmp
		case PFC_ACKN:
			AcknTWI();
			break;

		case PCF_Se:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
    e73a:	80 91 b9 00 	lds	r24, 0x00B9
    e73e:	88 7f       	andi	r24, 0xF8	; 248
    e740:	80 35       	cpi	r24, 0x50	; 80
    e742:	69 f7       	brne	.-38     	; 0xe71e <TWI_In+0xc6>
			Tm_Sec = DecodBCD(TWDR & 0b01111111);	// exclude ST bit
    e744:	20 91 bb 00 	lds	r18, 0x00BB
    e748:	82 2f       	mov	r24, r18
    e74a:	8f 77       	andi	r24, 0x7F	; 127
    e74c:	82 95       	swap	r24
    e74e:	8f 70       	andi	r24, 0x0F	; 15
    e750:	3a e0       	ldi	r19, 0x0A	; 10
    e752:	83 9f       	mul	r24, r19
    e754:	c0 01       	movw	r24, r0
    e756:	11 24       	eor	r1, r1
    e758:	2f 70       	andi	r18, 0x0F	; 15
    e75a:	28 0f       	add	r18, r24
    e75c:	20 93 b4 06 	sts	0x06B4, r18
			PFC_Stop_bit = TWDR & 0b10000000;
    e760:	80 91 bb 00 	lds	r24, 0x00BB
    e764:	80 78       	andi	r24, 0x80	; 128
    e766:	80 93 d3 04 	sts	0x04D3, r24
/*			if(PFC_Stop_bit) NoTickCnt++;
			else NoTickCnt=0;*/
			AcknTWI();
    e76a:	84 ec       	ldi	r24, 0xC4	; 196
    e76c:	80 93 bc 00 	sts	0x00BC, r24
    e770:	96 cf       	rjmp	.-212    	; 0xe69e <TWI_In+0x46>

		case PCF_REAP_START1:
			StartTWI();
			break;
		case PCF_CHECK_REAP_START1:
			if( (TWSR & 0b11111000) != TWI_STATUS_RP_START){ TWI_Error(); return;}
    e772:	80 91 b9 00 	lds	r24, 0x00B9
    e776:	88 7f       	andi	r24, 0xF8	; 248
    e778:	80 31       	cpi	r24, 0x10	; 16
    e77a:	89 f6       	brne	.-94     	; 0xe71e <TWI_In+0xc6>
    e77c:	48 e0       	ldi	r20, 0x08	; 8
			else TWI_Phase++;

		case PCF_SLA_R:
			SLA_R(PCF_SLA);
    e77e:	81 ed       	ldi	r24, 0xD1	; 209
    e780:	80 93 bb 00 	sts	0x00BB, r24
			RunTWI();
    e784:	84 e8       	ldi	r24, 0x84	; 132
    e786:	80 93 bc 00 	sts	0x00BC, r24
    e78a:	89 cf       	rjmp	.-238    	; 0xe69e <TWI_In+0x46>
		case PCF_Addr:
			TWDR = AddrSec;
			RunTWI();
			break;
		case PCF_CHECK_Addr:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATATX_ACK){ TWI_Error(); return;}
    e78c:	80 91 b9 00 	lds	r24, 0x00B9
    e790:	88 7f       	andi	r24, 0xF8	; 248
    e792:	88 32       	cpi	r24, 0x28	; 40
    e794:	21 f6       	brne	.-120    	; 0xe71e <TWI_In+0xc6>
    e796:	46 e0       	ldi	r20, 0x06	; 6
			else TWI_Phase++;

		case PCF_REAP_START1:
			StartTWI();
    e798:	84 ea       	ldi	r24, 0xA4	; 164
    e79a:	80 93 bc 00 	sts	0x00BC, r24
    e79e:	7f cf       	rjmp	.-258    	; 0xe69e <TWI_In+0x46>
		case PCF_SLA_W:
			SLA_W(PCF_SLA);
			RunTWI();
			break;
		case PCF_CHECK_SLA_W:
			if( (TWSR & 0b11111000) != TWI_STATUS_SLAW_ACK){ TWI_Error(); return;}
    e7a0:	80 91 b9 00 	lds	r24, 0x00B9
    e7a4:	88 7f       	andi	r24, 0xF8	; 248
    e7a6:	88 31       	cpi	r24, 0x18	; 24
    e7a8:	09 f0       	breq	.+2      	; 0xe7ac <TWI_In+0x154>
    e7aa:	b9 cf       	rjmp	.-142    	; 0xe71e <TWI_In+0xc6>
    e7ac:	44 e0       	ldi	r20, 0x04	; 4
			else TWI_Phase++;

		case PCF_Addr:
			TWDR = AddrSec;
    e7ae:	10 92 bb 00 	sts	0x00BB, r1
			RunTWI();
    e7b2:	84 e8       	ldi	r24, 0x84	; 132
    e7b4:	80 93 bc 00 	sts	0x00BC, r24
    e7b8:	72 cf       	rjmp	.-284    	; 0xe69e <TWI_In+0x46>
		if (!(TWCR &(1<<TWINT))) return;

		switch(TWI_Phase) {
		
		case PCF_CHECK_START:
			if( (TWSR & 0b11111000) != TWI_STATUS_START){ TWI_Error(); return;}
    e7ba:	80 91 b9 00 	lds	r24, 0x00B9
    e7be:	88 7f       	andi	r24, 0xF8	; 248
    e7c0:	88 30       	cpi	r24, 0x08	; 8
    e7c2:	09 f0       	breq	.+2      	; 0xe7c6 <TWI_In+0x16e>
    e7c4:	ac cf       	rjmp	.-168    	; 0xe71e <TWI_In+0xc6>
    e7c6:	42 e0       	ldi	r20, 0x02	; 2
			else TWI_Phase++;
			
		case PCF_SLA_W:
			SLA_W(PCF_SLA);
    e7c8:	80 ed       	ldi	r24, 0xD0	; 208
    e7ca:	80 93 bb 00 	sts	0x00BB, r24
			RunTWI();
    e7ce:	84 e8       	ldi	r24, 0x84	; 132
    e7d0:	80 93 bc 00 	sts	0x00BC, r24
    e7d4:	64 cf       	rjmp	.-312    	; 0xe69e <TWI_In+0x46>
		case PCF_SLA_R:
			SLA_R(PCF_SLA);
			RunTWI();
			break;
		case PCF_CHECK_SLA_R:
			if( (TWSR & 0b11111000) != TWI_STATUS_SLAR_ACK){ TWI_Error(); return;}
    e7d6:	80 91 b9 00 	lds	r24, 0x00B9
    e7da:	88 7f       	andi	r24, 0xF8	; 248
    e7dc:	80 34       	cpi	r24, 0x40	; 64
    e7de:	09 f0       	breq	.+2      	; 0xe7e2 <TWI_In+0x18a>
    e7e0:	9e cf       	rjmp	.-196    	; 0xe71e <TWI_In+0xc6>
    e7e2:	4a e0       	ldi	r20, 0x0A	; 10
    e7e4:	c2 cf       	rjmp	.-124    	; 0xe76a <TWI_In+0x112>
			Tm_Mon = DecodBCD(TWDR & 0b00011111);
			if(Tm_Mon > 12) Tm_Mon = 0;	//
			RunTWI();		//NACK
			break;
		case PCF_Year:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_NACK){ TWI_Error(); return;}
    e7e6:	80 91 b9 00 	lds	r24, 0x00B9
    e7ea:	88 7f       	andi	r24, 0xF8	; 248
    e7ec:	88 35       	cpi	r24, 0x58	; 88
    e7ee:	09 f0       	breq	.+2      	; 0xe7f2 <TWI_In+0x19a>
    e7f0:	96 cf       	rjmp	.-212    	; 0xe71e <TWI_In+0xc6>
			Tm_Year = DecodBCD(TWDR);
    e7f2:	80 91 bb 00 	lds	r24, 0x00BB

// ~~~~~~~~~~~~~~~~~~
uint8_t
DecodBCD(uint8_t BCD)
{
	return 10*(BCD>>4)+(BCD&0x0F);
    e7f6:	28 2f       	mov	r18, r24
    e7f8:	22 95       	swap	r18
    e7fa:	2f 70       	andi	r18, 0x0F	; 15
    e7fc:	9a e0       	ldi	r25, 0x0A	; 10
    e7fe:	29 9f       	mul	r18, r25
    e800:	90 01       	movw	r18, r0
    e802:	11 24       	eor	r1, r1
    e804:	8f 70       	andi	r24, 0x0F	; 15
    e806:	82 0f       	add	r24, r18
    e808:	80 93 dc 05 	sts	0x05DC, r24
			StopTWI();
    e80c:	94 e9       	ldi	r25, 0x94	; 148
    e80e:	90 93 bc 00 	sts	0x00BC, r25
			Tm_WDay = SetWeekday(Tm_Year, Tm_Mon, Tm_MDay);
    e812:	60 91 85 07 	lds	r22, 0x0785
    e816:	40 91 17 0b 	lds	r20, 0x0B17
    e81a:	0e 94 e5 23 	call	0x47ca	; 0x47ca <SetWeekday>
    e81e:	80 93 55 06 	sts	0x0655, r24
			StartTimer8(TD_TWI_Poll, 49);
    e822:	80 2f       	mov	r24, r16
    e824:	61 e3       	ldi	r22, 0x31	; 49
    e826:	0e 94 fa 1a 	call	0x35f4	; 0x35f4 <StartTimer8>
    e82a:	4f ef       	ldi	r20, 0xFF	; 255
    e82c:	38 cf       	rjmp	.-400    	; 0xe69e <TWI_In+0x46>
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
			Tm_MDay = DecodBCD(TWDR & 0b00111111);
			AcknTWI();
			break;
		case PCF_Mo:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
    e82e:	80 91 b9 00 	lds	r24, 0x00B9
    e832:	88 7f       	andi	r24, 0xF8	; 248
    e834:	80 35       	cpi	r24, 0x50	; 80
    e836:	09 f0       	breq	.+2      	; 0xe83a <TWI_In+0x1e2>
    e838:	72 cf       	rjmp	.-284    	; 0xe71e <TWI_In+0xc6>
			Tm_Mon = DecodBCD(TWDR & 0b00011111);
    e83a:	80 91 bb 00 	lds	r24, 0x00BB
    e83e:	28 2f       	mov	r18, r24
    e840:	2f 71       	andi	r18, 0x1F	; 31
    e842:	22 95       	swap	r18
    e844:	2f 70       	andi	r18, 0x0F	; 15
    e846:	9a e0       	ldi	r25, 0x0A	; 10
    e848:	29 9f       	mul	r18, r25
    e84a:	90 01       	movw	r18, r0
    e84c:	11 24       	eor	r1, r1
    e84e:	8f 70       	andi	r24, 0x0F	; 15
    e850:	82 0f       	add	r24, r18
    e852:	80 93 85 07 	sts	0x0785, r24
			if(Tm_Mon > 12) Tm_Mon = 0;	//
    e856:	8d 30       	cpi	r24, 0x0D	; 13
    e858:	10 f0       	brcs	.+4      	; 0xe85e <TWI_In+0x206>
    e85a:	10 92 85 07 	sts	0x0785, r1
			RunTWI();		//NACK
    e85e:	84 e8       	ldi	r24, 0x84	; 132
    e860:	80 93 bc 00 	sts	0x00BC, r24
    e864:	1c cf       	rjmp	.-456    	; 0xe69e <TWI_In+0x46>
			TWDR;
			//Tm_WDay = DecodBCD(TWDR & 0b00000111); Ignore 
			AcknTWI();
			break;
		case PCF_MDay:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
    e866:	80 91 b9 00 	lds	r24, 0x00B9
    e86a:	88 7f       	andi	r24, 0xF8	; 248
    e86c:	80 35       	cpi	r24, 0x50	; 80
    e86e:	09 f0       	breq	.+2      	; 0xe872 <TWI_In+0x21a>
    e870:	56 cf       	rjmp	.-340    	; 0xe71e <TWI_In+0xc6>
			Tm_MDay = DecodBCD(TWDR & 0b00111111);
    e872:	20 91 bb 00 	lds	r18, 0x00BB
    e876:	82 2f       	mov	r24, r18
    e878:	8f 73       	andi	r24, 0x3F	; 63
    e87a:	82 95       	swap	r24
    e87c:	8f 70       	andi	r24, 0x0F	; 15
    e87e:	3a e0       	ldi	r19, 0x0A	; 10
    e880:	83 9f       	mul	r24, r19
    e882:	c0 01       	movw	r24, r0
    e884:	11 24       	eor	r1, r1
    e886:	2f 70       	andi	r18, 0x0F	; 15
    e888:	28 0f       	add	r18, r24
    e88a:	20 93 17 0b 	sts	0x0B17, r18
			AcknTWI();
    e88e:	84 ec       	ldi	r24, 0xC4	; 196
    e890:	80 93 bc 00 	sts	0x00BC, r24
    e894:	04 cf       	rjmp	.-504    	; 0xe69e <TWI_In+0x46>
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
			Tm_Hour = DecodBCD(TWDR & 0b00111111);
			AcknTWI();
			break;
		case PCF_WDay:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
    e896:	80 91 b9 00 	lds	r24, 0x00B9
    e89a:	88 7f       	andi	r24, 0xF8	; 248
    e89c:	80 35       	cpi	r24, 0x50	; 80
    e89e:	09 f0       	breq	.+2      	; 0xe8a2 <TWI_In+0x24a>
    e8a0:	3e cf       	rjmp	.-388    	; 0xe71e <TWI_In+0xc6>
			TWDR;
    e8a2:	80 91 bb 00 	lds	r24, 0x00BB
			//Tm_WDay = DecodBCD(TWDR & 0b00000111); Ignore 
			AcknTWI();
    e8a6:	84 ec       	ldi	r24, 0xC4	; 196
    e8a8:	80 93 bc 00 	sts	0x00BC, r24
    e8ac:	f8 ce       	rjmp	.-528    	; 0xe69e <TWI_In+0x46>
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
			Tm_Min = DecodBCD(TWDR & 0b01111111);
			AcknTWI();
			break;
		case PCF_Ho:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
    e8ae:	80 91 b9 00 	lds	r24, 0x00B9
    e8b2:	88 7f       	andi	r24, 0xF8	; 248
    e8b4:	80 35       	cpi	r24, 0x50	; 80
    e8b6:	09 f0       	breq	.+2      	; 0xe8ba <TWI_In+0x262>
    e8b8:	32 cf       	rjmp	.-412    	; 0xe71e <TWI_In+0xc6>
			Tm_Hour = DecodBCD(TWDR & 0b00111111);
    e8ba:	20 91 bb 00 	lds	r18, 0x00BB
    e8be:	82 2f       	mov	r24, r18
    e8c0:	8f 73       	andi	r24, 0x3F	; 63
    e8c2:	82 95       	swap	r24
    e8c4:	8f 70       	andi	r24, 0x0F	; 15
    e8c6:	3a e0       	ldi	r19, 0x0A	; 10
    e8c8:	83 9f       	mul	r24, r19
    e8ca:	c0 01       	movw	r24, r0
    e8cc:	11 24       	eor	r1, r1
    e8ce:	2f 70       	andi	r18, 0x0F	; 15
    e8d0:	28 0f       	add	r18, r24
    e8d2:	20 93 bf 05 	sts	0x05BF, r18
			AcknTWI();
    e8d6:	84 ec       	ldi	r24, 0xC4	; 196
    e8d8:	80 93 bc 00 	sts	0x00BC, r24
    e8dc:	e0 ce       	rjmp	.-576    	; 0xe69e <TWI_In+0x46>
/*			if(PFC_Stop_bit) NoTickCnt++;
			else NoTickCnt=0;*/
			AcknTWI();
			break;
		case PCF_Mi:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
    e8de:	80 91 b9 00 	lds	r24, 0x00B9
    e8e2:	88 7f       	andi	r24, 0xF8	; 248
    e8e4:	80 35       	cpi	r24, 0x50	; 80
    e8e6:	09 f0       	breq	.+2      	; 0xe8ea <TWI_In+0x292>
    e8e8:	1a cf       	rjmp	.-460    	; 0xe71e <TWI_In+0xc6>
			Tm_Min = DecodBCD(TWDR & 0b01111111);
    e8ea:	20 91 bb 00 	lds	r18, 0x00BB
    e8ee:	82 2f       	mov	r24, r18
    e8f0:	8f 77       	andi	r24, 0x7F	; 127
    e8f2:	82 95       	swap	r24
    e8f4:	8f 70       	andi	r24, 0x0F	; 15
    e8f6:	3a e0       	ldi	r19, 0x0A	; 10
    e8f8:	83 9f       	mul	r24, r19
    e8fa:	c0 01       	movw	r24, r0
    e8fc:	11 24       	eor	r1, r1
    e8fe:	2f 70       	andi	r18, 0x0F	; 15
    e900:	28 0f       	add	r18, r24
    e902:	20 93 4f 06 	sts	0x064F, r18
			AcknTWI();
    e906:	84 ec       	ldi	r24, 0xC4	; 196
    e908:	80 93 bc 00 	sts	0x00BC, r24
    e90c:	c8 ce       	rjmp	.-624    	; 0xe69e <TWI_In+0x46>

0000e90e <TimeInit>:

// ~~~~~~~~
void
WdtOn(void)
{
	wdt_reset();
    e90e:	a8 95       	wdr
	wdt_enable(WDTO_2S);
    e910:	2f e0       	ldi	r18, 0x0F	; 15
    e912:	88 e1       	ldi	r24, 0x18	; 24
    e914:	90 e0       	ldi	r25, 0x00	; 0
    e916:	0f b6       	in	r0, 0x3f	; 63
    e918:	f8 94       	cli
    e91a:	a8 95       	wdr
    e91c:	80 93 60 00 	sts	0x0060, r24
    e920:	0f be       	out	0x3f, r0	; 63
    e922:	20 93 60 00 	sts	0x0060, r18

	// WDT
	WdtOn();

	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TCCR1A = 0;
    e926:	10 92 80 00 	sts	0x0080, r1
		TCCR1B = (((~(1<<WGM13) |(1<<WGM12)) &~(1<<CS12)) |(1<<CS11)) &~(1<<CS10);
    e92a:	8a ee       	ldi	r24, 0xEA	; 234
    e92c:	80 93 81 00 	sts	0x0081, r24
		OCR1A = 20000;
    e930:	80 e2       	ldi	r24, 0x20	; 32
    e932:	9e e4       	ldi	r25, 0x4E	; 78
    e934:	90 93 89 00 	sts	0x0089, r25
    e938:	80 93 88 00 	sts	0x0088, r24
		TCC0.CTRLE = ~TC0_BYTEM_bm;
	#endif
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__)
		TIMSK |=(1<<OCIE1A);
	#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TIMSK1 |=(1<<OCIE1A);
    e93c:	80 91 6f 00 	lds	r24, 0x006F
    e940:	82 60       	ori	r24, 0x02	; 2
    e942:	80 93 6f 00 	sts	0x006F, r24
    e946:	80 e0       	ldi	r24, 0x00	; 0
    e948:	90 e0       	ldi	r25, 0x00	; 0
	#endif

	// Program timers (10 ms)
	uint8_t i;
	for (i=0; i<sizeof(Timer8Flg); i++)
		Timer8Flg[i] = 0xFF;
    e94a:	2f ef       	ldi	r18, 0xFF	; 255
    e94c:	fc 01       	movw	r30, r24
    e94e:	e1 55       	subi	r30, 0x51	; 81
    e950:	fb 4f       	sbci	r31, 0xFB	; 251
    e952:	20 83       	st	Z, r18
    e954:	01 96       	adiw	r24, 0x01	; 1
		TCC0.INTCTRLB = 0;
	#endif

	// Program timers (10 ms)
	uint8_t i;
	for (i=0; i<sizeof(Timer8Flg); i++)
    e956:	8c 30       	cpi	r24, 0x0C	; 12
    e958:	91 05       	cpc	r25, r1
    e95a:	c1 f7       	brne	.-16     	; 0xe94c <TimeInit+0x3e>
    e95c:	80 e0       	ldi	r24, 0x00	; 0
    e95e:	90 e0       	ldi	r25, 0x00	; 0
		Timer8Flg[i] = 0xFF;
	for (i=0; i<sizeof(Timer16Flg); i++)
		Timer16Flg[i] = 0xFF;
    e960:	3f ef       	ldi	r19, 0xFF	; 255
    e962:	fc 01       	movw	r30, r24
    e964:	e5 54       	subi	r30, 0x45	; 69
    e966:	fb 4f       	sbci	r31, 0xFB	; 251
    e968:	2f ef       	ldi	r18, 0xFF	; 255
    e96a:	30 83       	st	Z, r19
    e96c:	01 96       	adiw	r24, 0x01	; 1

	// Program timers (10 ms)
	uint8_t i;
	for (i=0; i<sizeof(Timer8Flg); i++)
		Timer8Flg[i] = 0xFF;
	for (i=0; i<sizeof(Timer16Flg); i++)
    e96e:	8d 30       	cpi	r24, 0x0D	; 13
    e970:	91 05       	cpc	r25, r1
    e972:	b9 f7       	brne	.-18     	; 0xe962 <TimeInit+0x54>
		Timer16Flg[i] = 0xFF;
	for (i=0; i<sizeof(Timer32Flg); i++)
		Timer32Flg[i] = 0xFF;
    e974:	20 93 c8 04 	sts	0x04C8, r18
    e978:	20 93 c9 04 	sts	0x04C9, r18
    e97c:	20 93 ca 04 	sts	0x04CA, r18
    e980:	20 93 cb 04 	sts	0x04CB, r18
    e984:	20 93 cc 04 	sts	0x04CC, r18
    e988:	20 93 cd 04 	sts	0x04CD, r18
    e98c:	8d e3       	ldi	r24, 0x3D	; 61
    e98e:	91 e0       	ldi	r25, 0x01	; 1
    e990:	0e 94 e7 82 	call	0x105ce	; 0x105ce <__eerd_byte_m2560>

	// 1 s
	Timer1min = erb(&Timer1min_EE);
    e994:	80 93 ae 06 	sts	0x06AE, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    e998:	8e e3       	ldi	r24, 0x3E	; 62
    e99a:	91 e0       	ldi	r25, 0x01	; 1
    e99c:	0e 94 f5 82 	call	0x105ea	; 0x105ea <__eerd_word_m2560>
	Timer1hour = erw(&Timer1hour_EE);
    e9a0:	90 93 24 0c 	sts	0x0C24, r25
    e9a4:	80 93 23 0c 	sts	0x0C23, r24

	// Application
	#ifdef InitTimer
		StartTimer16(InitTimer, InitTime);
	#endif
}
    e9a8:	08 95       	ret

0000e9aa <MemCheckInit>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    e9aa:	8c e3       	ldi	r24, 0x3C	; 60
    e9ac:	91 e0       	ldi	r25, 0x01	; 1
    e9ae:	0e 94 e7 82 	call	0x105ce	; 0x105ce <__eerd_byte_m2560>
// ~~~~~~~~~~~~~~~
void
MemCheckInit(void)
{
//	TD_Mem = Timer32SysAlloc(1);
	if (!erb(&MemCheck_stor.ReprogFlg)) {
    e9b2:	81 11       	cpse	r24, r1
    e9b4:	08 95       	ret
		eeprom_write_word(&MemCheck_stor.CRC_Flash_stor, CRC_Flash_calc());
    e9b6:	0e 94 f6 19 	call	0x33ec	; 0x33ec <CRC_Flash_calc>
    e9ba:	bc 01       	movw	r22, r24
    e9bc:	88 e3       	ldi	r24, 0x38	; 56
    e9be:	91 e0       	ldi	r25, 0x01	; 1
    e9c0:	0e 94 1b 83 	call	0x10636	; 0x10636 <__eewr_word_m2560>
		eeprom_write_word(&MemCheck_stor.CRC_EEPROM_stor, CRC_EEPROM_calc());
    e9c4:	0e 94 10 1a 	call	0x3420	; 0x3420 <CRC_EEPROM_calc>
    e9c8:	bc 01       	movw	r22, r24
    e9ca:	8a e3       	ldi	r24, 0x3A	; 58
    e9cc:	91 e0       	ldi	r25, 0x01	; 1
    e9ce:	0e 94 1b 83 	call	0x10636	; 0x10636 <__eewr_word_m2560>
		eeprom_write_byte(&MemCheck_stor.ReprogFlg, 1);
    e9d2:	8c e3       	ldi	r24, 0x3C	; 60
    e9d4:	91 e0       	ldi	r25, 0x01	; 1
    e9d6:	61 e0       	ldi	r22, 0x01	; 1
    e9d8:	0e 94 05 83 	call	0x1060a	; 0x1060a <__eewr_byte_m2560>
    e9dc:	08 95       	ret

0000e9de <main>:
}

// ~~~~~~~
int
main(void)
{
    e9de:	cf 93       	push	r28
    e9e0:	df 93       	push	r29
	TimeInit();
    e9e2:	0e 94 87 74 	call	0xe90e	; 0xe90e <TimeInit>
	TimersInc();
    e9e6:	0e 94 b9 4c 	call	0x9972	; 0x9972 <TimersInc>
	MemCheckInit();
    e9ea:	0e 94 d5 74 	call	0xe9aa	; 0xe9aa <MemCheckInit>
	LED_Init();
    e9ee:	0e 94 23 26 	call	0x4c46	; 0x4c46 <LED_Init>

	LCD_Init();
    e9f2:	0e 94 36 72 	call	0xe46c	; 0xe46c <LCD_Init>

	KeypadInit();
    e9f6:	0e 94 ca 3b 	call	0x7794	; 0x7794 <KeypadInit>
	MenuInit();
    e9fa:	0e 94 18 3d 	call	0x7a30	; 0x7a30 <MenuInit>
InterruInit(void)
{
	#ifdef PMIC
		PMIC.CTRL = (uint8_t)(~PMIC_RREN_bm &~PMIC_IVSEL_bm) |PMIC_HILVLEN_bm |PMIC_MEDLVLEN_bm |PMIC_LOLVLEN_bm;
	#endif
	sei();
    e9fe:	78 94       	sei
	InterruInit();
	DigitInit();
    ea00:	0e 94 3b 3e 	call	0x7c76	; 0x7c76 <DI_Init>
    ea04:	0e 94 4a 3f 	call	0x7e94	; 0x7e94 <DO_Init>
	HSC_Init();

	AI_Init();
    ea08:	0e 94 5f 3f 	call	0x7ebe	; 0x7ebe <AI_Init>

	SPI_Init();
    ea0c:	0e 94 ab 20 	call	0x4156	; 0x4156 <SPI_Init>

	PWM_Init();
    ea10:	0e 94 77 1e 	call	0x3cee	; 0x3cee <PWM_Init>
	TWI_Init();
    ea14:	0e 94 66 23 	call	0x46cc	; 0x46cc <TWI_Init>
#ifdef QslRD
	SlaveRD_Init();
#endif

	do {
		TimersInc();
    ea18:	0e 94 b9 4c 	call	0x9972	; 0x9972 <TimersInc>
		wdt_reset();
    ea1c:	a8 95       	wdr
		DigitIn();
    ea1e:	0e 94 c7 4f 	call	0x9f8e	; 0x9f8e <DigitIn>
		TWI_In();
    ea22:	0e 94 2c 73 	call	0xe658	; 0xe658 <TWI_In>
	StopTWI();
	TWI_Phase = PCF_START;
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t RTC_Ready(void){
	if(TWI_Phase == PCF_START) return 1;
    ea26:	80 91 7d 07 	lds	r24, 0x077D
    ea2a:	88 23       	and	r24, r24
    ea2c:	11 f4       	brne	.+4      	; 0xea32 <main+0x54>
		if(RTC_Ready()) RTC_GetTrueTime();
    ea2e:	0e 94 01 25 	call	0x4a02	; 0x4a02 <RTC_GetTrueTime>
		LCD_Sweep();
    ea32:	0e 94 88 61 	call	0xc310	; 0xc310 <LCD_Sweep>
	#ifdef TerIdx
	} while(ThermInit(AnalogIn()-TerIdx) || !RTC_Ready());
	#elif !defined ADC_Miss
		AnalogIn();
    ea36:	0e 94 70 3f 	call	0x7ee0	; 0x7ee0 <AnalogIn>
	} while( (ADC_OK&&ThermInit(ADC_In())) || !RTC_Ready() );
    ea3a:	80 91 e3 08 	lds	r24, 0x08E3
    ea3e:	90 91 e4 08 	lds	r25, 0x08E4
    ea42:	89 2b       	or	r24, r25
    ea44:	69 f4       	brne	.+26     	; 0xea60 <main+0x82>
    ea46:	80 91 70 07 	lds	r24, 0x0770
    ea4a:	90 91 71 07 	lds	r25, 0x0771
    ea4e:	89 2b       	or	r24, r25
    ea50:	39 f4       	brne	.+14     	; 0xea60 <main+0x82>
    ea52:	80 91 b5 06 	lds	r24, 0x06B5
    ea56:	90 91 b6 06 	lds	r25, 0x06B6
    ea5a:	89 2b       	or	r24, r25
    ea5c:	09 f4       	brne	.+2      	; 0xea60 <main+0x82>
    ea5e:	68 c0       	rjmp	.+208    	; 0xeb30 <main+0x152>
    ea60:	80 91 7d 07 	lds	r24, 0x077D
    ea64:	88 23       	and	r24, r24
    ea66:	c1 f6       	brne	.-80     	; 0xea18 <main+0x3a>
	#else
	} while((AnalogIn()!=AI_Reg-1) || !RTC_Ready());
	#endif

	MemCheckMsg();
    ea68:	0e 94 b7 4e 	call	0x9d6e	; 0x9d6e <MemCheckMsg>

	ApplInit();

	USART_Init();
    ea6c:	0e 94 e2 71 	call	0xe3c4	; 0xe3c4 <USART_Init>
	ScanCycleInit();
    ea70:	0e 94 bb 1d 	call	0x3b76	; 0x3b76 <ScanCycleInit>
	if(TimerAllocError()) ShowMsg(&MsgErr41);
    ea74:	0e 94 9f 1d 	call	0x3b3e	; 0x3b3e <TimerAllocError>
    ea78:	88 23       	and	r24, r24
    ea7a:	09 f0       	breq	.+2      	; 0xea7e <main+0xa0>
    ea7c:	61 c0       	rjmp	.+194    	; 0xeb40 <main+0x162>

// ~~~~~~~~~~~~~~~~
void
Therm_ADC_Off(void)
{
	for (uint8_t i=0; i<TerReg; Temperature[i++]=ADC_Off_Mark);
    ea7e:	c1 e0       	ldi	r28, 0x01	; 1
    ea80:	d0 e8       	ldi	r29, 0x80	; 128
    ea82:	10 c0       	rjmp	.+32     	; 0xeaa4 <main+0xc6>
			if(ADC_Work&&ADC_Phase==ADC_OFF) {
				Therm_ADC_Off();
				ShowMsg(&MsgErr21);
				ADC_Work = 0;
			}
			ThermChan(ADC_In());
    ea84:	0e 94 02 1f 	call	0x3e04	; 0x3e04 <ADC_In>
    ea88:	0e 94 e9 4e 	call	0x9dd2	; 0x9dd2 <ThermChan>
		#endif
		ThermExt();
		TWI_In();
    ea8c:	0e 94 2c 73 	call	0xe658	; 0xe658 <TWI_In>

		USART_Cycle();
    ea90:	0e 94 57 70 	call	0xe0ae	; 0xe0ae <USART_Cycle>
#ifdef QslRD
		SlaveRD();
#endif
		ApplCycle();
		
		LCD_Sweep();
    ea94:	0e 94 88 61 	call	0xc310	; 0xc310 <LCD_Sweep>
		DigitOut();
    ea98:	0e 94 fb 3e 	call	0x7df6	; 0x7df6 <DigitOut>
		DAC_Out();
		PWM_Out();
    ea9c:	0e 94 96 1e 	call	0x3d2c	; 0x3d2c <PWM_Out>
		#ifdef BACKLIGHT
			LCDBackLightControl();
    eaa0:	0e 94 5b 28 	call	0x50b6	; 0x50b6 <LCDBackLightControl>
	USART_Init();
	ScanCycleInit();
	if(TimerAllocError()) ShowMsg(&MsgErr41);

	for(;;) {	
		TimersInc();
    eaa4:	0e 94 b9 4c 	call	0x9972	; 0x9972 <TimersInc>
		TimeCycle();
    eaa8:	0e 94 1b 1e 	call	0x3c36	; 0x3c36 <TimeCycle>
// ~~~~~~~~~~~~~~
static void
KeypadSweep(void)
{
	static T_KeyAct KeyAct[] PROGMEM = KEYS;
	T_KeyAct KA = prp(KeyAct+KeypadIn());
    eaac:	0e 94 dd 3b 	call	0x77ba	; 0x77ba <KeypadIn>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    eab0:	e8 2f       	mov	r30, r24
    eab2:	f0 e0       	ldi	r31, 0x00	; 0
    eab4:	ee 0f       	add	r30, r30
    eab6:	ff 1f       	adc	r31, r31
    eab8:	e9 53       	subi	r30, 0x39	; 57
    eaba:	f6 4d       	sbci	r31, 0xD6	; 214
    eabc:	85 91       	lpm	r24, Z+
    eabe:	94 91       	lpm	r25, Z+
	if(KA){
    eac0:	00 97       	sbiw	r24, 0x00	; 0
    eac2:	31 f0       	breq	.+12     	; 0xead0 <main+0xf2>
		KA();
    eac4:	fc 01       	movw	r30, r24
    eac6:	19 95       	eicall
		#ifdef BACKLIGHT
			if(BackLightMode == 1){
    eac8:	80 91 50 06 	lds	r24, 0x0650
    eacc:	81 30       	cpi	r24, 0x01	; 1
    eace:	59 f1       	breq	.+86     	; 0xeb26 <main+0x148>
	for(;;) {	
		TimersInc();
		TimeCycle();

		KeypadSweep();
		DigitIn();
    ead0:	0e 94 c7 4f 	call	0x9f8e	; 0x9f8e <DigitIn>
		HSC_In();
		#ifdef TerIdx
			ThermChan(AnalogIn()-TerIdx);
		#else
			AnalogIn();
    ead4:	0e 94 70 3f 	call	0x7ee0	; 0x7ee0 <AnalogIn>
		#endif
		#if !defined ADC_Miss && !defined TerIdx
			static uint8_t ADC_Work = 1;
			if(ADC_Work&&ADC_Phase==ADC_OFF) {
    ead8:	80 91 d8 02 	lds	r24, 0x02D8
    eadc:	88 23       	and	r24, r24
    eade:	91 f2       	breq	.-92     	; 0xea84 <main+0xa6>
    eae0:	80 91 22 0b 	lds	r24, 0x0B22
    eae4:	84 30       	cpi	r24, 0x04	; 4
    eae6:	71 f6       	brne	.-100    	; 0xea84 <main+0xa6>
    eae8:	d0 93 44 06 	sts	0x0644, r29
    eaec:	c0 93 43 06 	sts	0x0643, r28
    eaf0:	d0 93 46 06 	sts	0x0646, r29
    eaf4:	c0 93 45 06 	sts	0x0645, r28
    eaf8:	d0 93 48 06 	sts	0x0648, r29
    eafc:	c0 93 47 06 	sts	0x0647, r28
    eb00:	d0 93 4a 06 	sts	0x064A, r29
    eb04:	c0 93 49 06 	sts	0x0649, r28
    eb08:	d0 93 4c 06 	sts	0x064C, r29
    eb0c:	c0 93 4b 06 	sts	0x064B, r28
    eb10:	d0 93 4e 06 	sts	0x064E, r29
    eb14:	c0 93 4d 06 	sts	0x064D, r28
				Therm_ADC_Off();
				ShowMsg(&MsgErr21);
    eb18:	8a e7       	ldi	r24, 0x7A	; 122
    eb1a:	98 e0       	ldi	r25, 0x08	; 8
    eb1c:	0e 94 07 3d 	call	0x7a0e	; 0x7a0e <ShowMsg>
				ADC_Work = 0;
    eb20:	10 92 d8 02 	sts	0x02D8, r1
    eb24:	af cf       	rjmp	.-162    	; 0xea84 <main+0xa6>
	T_KeyAct KA = prp(KeyAct+KeypadIn());
	if(KA){
		KA();
		#ifdef BACKLIGHT
			if(BackLightMode == 1){
				LCDBackLightOn();
    eb26:	0e 94 3f 28 	call	0x507e	; 0x507e <LCDBackLightOn>
				LCDBackLightStartTimer();
    eb2a:	0e 94 e7 71 	call	0xe3ce	; 0xe3ce <LCDBackLightStartTimer>
    eb2e:	d0 cf       	rjmp	.-96     	; 0xead0 <main+0xf2>
		LCD_Sweep();
	#ifdef TerIdx
	} while(ThermInit(AnalogIn()-TerIdx) || !RTC_Ready());
	#elif !defined ADC_Miss
		AnalogIn();
	} while( (ADC_OK&&ThermInit(ADC_In())) || !RTC_Ready() );
    eb30:	0e 94 02 1f 	call	0x3e04	; 0x3e04 <ADC_In>
    eb34:	0e 94 85 4f 	call	0x9f0a	; 0x9f0a <ThermInit>
    eb38:	88 23       	and	r24, r24
    eb3a:	09 f0       	breq	.+2      	; 0xeb3e <main+0x160>
    eb3c:	6d cf       	rjmp	.-294    	; 0xea18 <main+0x3a>
    eb3e:	90 cf       	rjmp	.-224    	; 0xea60 <main+0x82>

	ApplInit();

	USART_Init();
	ScanCycleInit();
	if(TimerAllocError()) ShowMsg(&MsgErr41);
    eb40:	8f e2       	ldi	r24, 0x2F	; 47
    eb42:	9a e1       	ldi	r25, 0x1A	; 26
    eb44:	0e 94 07 3d 	call	0x7a0e	; 0x7a0e <ShowMsg>
    eb48:	9a cf       	rjmp	.-204    	; 0xea7e <main+0xa0>

0000eb4a <EEMEMBackUpOk>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    eb4a:	80 e0       	ldi	r24, 0x00	; 0
    eb4c:	90 e0       	ldi	r25, 0x00	; 0
    eb4e:	0e 94 e7 82 	call	0x105ce	; 0x105ce <__eerd_byte_m2560>
	uint8_t Month;
	uint8_t Year;
}DateBackUp EEMEM = {0xFF,0xFF,0xFF};

uint8_t EEMEMBackUpOk(void){
	if( (erb(&DateBackUp.Day)==0xFF) || (erb(&DateBackUp.Month)==0xFF) || (erb(&DateBackUp.Year)== 0xFF) ) return 0;
    eb52:	8f 3f       	cpi	r24, 0xFF	; 255
    eb54:	81 f0       	breq	.+32     	; 0xeb76 <EEMEMBackUpOk+0x2c>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    eb56:	81 e0       	ldi	r24, 0x01	; 1
    eb58:	90 e0       	ldi	r25, 0x00	; 0
    eb5a:	0e 94 e7 82 	call	0x105ce	; 0x105ce <__eerd_byte_m2560>
	uint8_t Month;
	uint8_t Year;
}DateBackUp EEMEM = {0xFF,0xFF,0xFF};

uint8_t EEMEMBackUpOk(void){
	if( (erb(&DateBackUp.Day)==0xFF) || (erb(&DateBackUp.Month)==0xFF) || (erb(&DateBackUp.Year)== 0xFF) ) return 0;
    eb5e:	8f 3f       	cpi	r24, 0xFF	; 255
    eb60:	51 f0       	breq	.+20     	; 0xeb76 <EEMEMBackUpOk+0x2c>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    eb62:	82 e0       	ldi	r24, 0x02	; 2
    eb64:	90 e0       	ldi	r25, 0x00	; 0
    eb66:	0e 94 e7 82 	call	0x105ce	; 0x105ce <__eerd_byte_m2560>
    eb6a:	90 e0       	ldi	r25, 0x00	; 0
    eb6c:	8f 3f       	cpi	r24, 0xFF	; 255
    eb6e:	21 f0       	breq	.+8      	; 0xeb78 <EEMEMBackUpOk+0x2e>
    eb70:	91 e0       	ldi	r25, 0x01	; 1
}DateBackUp EEMEM = {0xFF,0xFF,0xFF};

uint8_t EEMEMBackUpOk(void){
	if( (erb(&DateBackUp.Day)==0xFF) || (erb(&DateBackUp.Month)==0xFF) || (erb(&DateBackUp.Year)== 0xFF) ) return 0;
	else return 1;
}
    eb72:	89 2f       	mov	r24, r25
    eb74:	08 95       	ret
	uint8_t Month;
	uint8_t Year;
}DateBackUp EEMEM = {0xFF,0xFF,0xFF};

uint8_t EEMEMBackUpOk(void){
	if( (erb(&DateBackUp.Day)==0xFF) || (erb(&DateBackUp.Month)==0xFF) || (erb(&DateBackUp.Year)== 0xFF) ) return 0;
    eb76:	90 e0       	ldi	r25, 0x00	; 0
	else return 1;
}
    eb78:	89 2f       	mov	r24, r25
    eb7a:	08 95       	ret

0000eb7c <Menu_BackUp_Enter>:
			NULL, NULL, NULL, Menu_ConfirmationRest_Enter, NULL, NULL, NULL};
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	//		  
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	uint8_t Menu_BackUp_Enter(){
		switch(CurrLine){
    eb7c:	80 91 83 07 	lds	r24, 0x0783
    eb80:	82 30       	cpi	r24, 0x02	; 2
    eb82:	11 f0       	breq	.+4      	; 0xeb88 <Menu_BackUp_Enter+0xc>
			}
			NextPage = &Menu_ConfirmationRestore;
			break;
		}
		return StandartKey;
	}
    eb84:	80 e0       	ldi	r24, 0x00	; 0
    eb86:	08 95       	ret
	//		  
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	uint8_t Menu_BackUp_Enter(){
		switch(CurrLine){
		case 2:
			if(!EEMEMBackUpOk()){
    eb88:	0e 94 a5 75 	call	0xeb4a	; 0xeb4a <EEMEMBackUpOk>
    eb8c:	88 23       	and	r24, r24
    eb8e:	59 f4       	brne	.+22     	; 0xeba6 <Menu_BackUp_Enter+0x2a>
				//   EEPROM,   BackUp- -  
				if(MemFail & 1<<MemFail_EEPROM){
    eb90:	80 91 cf 08 	lds	r24, 0x08CF
    eb94:	81 ff       	sbrs	r24, 1
    eb96:	0f c0       	rjmp	.+30     	; 0xebb6 <Menu_BackUp_Enter+0x3a>
					MemFailReset();
    eb98:	0e 94 29 4c 	call	0x9852	; 0x9852 <MemFailReset>
					ShowMsg(&Msg_EEWarning);
    eb9c:	8b e3       	ldi	r24, 0x3B	; 59
    eb9e:	93 e1       	ldi	r25, 0x13	; 19
    eba0:	0e 94 07 3d 	call	0x7a0e	; 0x7a0e <ShowMsg>
    eba4:	ef cf       	rjmp	.-34     	; 0xeb84 <Menu_BackUp_Enter+0x8>
				}
				else ShowMsg(&Msg_NoBackUp);
				break;
			}
			NextPage = &Menu_ConfirmationRestore;
    eba6:	8b ee       	ldi	r24, 0xEB	; 235
    eba8:	94 e1       	ldi	r25, 0x14	; 20
    ebaa:	90 93 d8 05 	sts	0x05D8, r25
    ebae:	80 93 d7 05 	sts	0x05D7, r24
			break;
		}
		return StandartKey;
	}
    ebb2:	80 e0       	ldi	r24, 0x00	; 0
    ebb4:	08 95       	ret
				//   EEPROM,   BackUp- -  
				if(MemFail & 1<<MemFail_EEPROM){
					MemFailReset();
					ShowMsg(&Msg_EEWarning);
				}
				else ShowMsg(&Msg_NoBackUp);
    ebb6:	8d e9       	ldi	r24, 0x9D	; 157
    ebb8:	93 e1       	ldi	r25, 0x13	; 19
    ebba:	0e 94 07 3d 	call	0x7a0e	; 0x7a0e <ShowMsg>
    ebbe:	e2 cf       	rjmp	.-60     	; 0xeb84 <Menu_BackUp_Enter+0x8>

0000ebc0 <vfprintf>:
    ebc0:	2f 92       	push	r2
    ebc2:	3f 92       	push	r3
    ebc4:	4f 92       	push	r4
    ebc6:	5f 92       	push	r5
    ebc8:	6f 92       	push	r6
    ebca:	7f 92       	push	r7
    ebcc:	8f 92       	push	r8
    ebce:	9f 92       	push	r9
    ebd0:	af 92       	push	r10
    ebd2:	bf 92       	push	r11
    ebd4:	cf 92       	push	r12
    ebd6:	df 92       	push	r13
    ebd8:	ef 92       	push	r14
    ebda:	ff 92       	push	r15
    ebdc:	0f 93       	push	r16
    ebde:	1f 93       	push	r17
    ebe0:	df 93       	push	r29
    ebe2:	cf 93       	push	r28
    ebe4:	cd b7       	in	r28, 0x3d	; 61
    ebe6:	de b7       	in	r29, 0x3e	; 62
    ebe8:	61 97       	sbiw	r28, 0x11	; 17
    ebea:	0f b6       	in	r0, 0x3f	; 63
    ebec:	f8 94       	cli
    ebee:	de bf       	out	0x3e, r29	; 62
    ebf0:	0f be       	out	0x3f, r0	; 63
    ebf2:	cd bf       	out	0x3d, r28	; 61
    ebf4:	3c 01       	movw	r6, r24
    ebf6:	7f 87       	std	Y+15, r23	; 0x0f
    ebf8:	6e 87       	std	Y+14, r22	; 0x0e
    ebfa:	6a 01       	movw	r12, r20
    ebfc:	fc 01       	movw	r30, r24
    ebfe:	17 82       	std	Z+7, r1	; 0x07
    ec00:	16 82       	std	Z+6, r1	; 0x06
    ec02:	83 81       	ldd	r24, Z+3	; 0x03
    ec04:	81 fd       	sbrc	r24, 1
    ec06:	03 c0       	rjmp	.+6      	; 0xec0e <vfprintf+0x4e>
    ec08:	6f ef       	ldi	r22, 0xFF	; 255
    ec0a:	7f ef       	ldi	r23, 0xFF	; 255
    ec0c:	6f c3       	rjmp	.+1758   	; 0xf2ec <vfprintf+0x72c>
    ec0e:	9e 01       	movw	r18, r28
    ec10:	2f 5f       	subi	r18, 0xFF	; 255
    ec12:	3f 4f       	sbci	r19, 0xFF	; 255
    ec14:	39 8b       	std	Y+17, r19	; 0x11
    ec16:	28 8b       	std	Y+16, r18	; 0x10
    ec18:	f3 01       	movw	r30, r6
    ec1a:	23 81       	ldd	r18, Z+3	; 0x03
    ec1c:	ee 85       	ldd	r30, Y+14	; 0x0e
    ec1e:	ff 85       	ldd	r31, Y+15	; 0x0f
    ec20:	23 fd       	sbrc	r18, 3
    ec22:	85 91       	lpm	r24, Z+
    ec24:	23 ff       	sbrs	r18, 3
    ec26:	81 91       	ld	r24, Z+
    ec28:	ff 87       	std	Y+15, r31	; 0x0f
    ec2a:	ee 87       	std	Y+14, r30	; 0x0e
    ec2c:	88 23       	and	r24, r24
    ec2e:	09 f4       	brne	.+2      	; 0xec32 <vfprintf+0x72>
    ec30:	5a c3       	rjmp	.+1716   	; 0xf2e6 <vfprintf+0x726>
    ec32:	85 32       	cpi	r24, 0x25	; 37
    ec34:	51 f4       	brne	.+20     	; 0xec4a <vfprintf+0x8a>
    ec36:	ee 85       	ldd	r30, Y+14	; 0x0e
    ec38:	ff 85       	ldd	r31, Y+15	; 0x0f
    ec3a:	23 fd       	sbrc	r18, 3
    ec3c:	85 91       	lpm	r24, Z+
    ec3e:	23 ff       	sbrs	r18, 3
    ec40:	81 91       	ld	r24, Z+
    ec42:	ff 87       	std	Y+15, r31	; 0x0f
    ec44:	ee 87       	std	Y+14, r30	; 0x0e
    ec46:	85 32       	cpi	r24, 0x25	; 37
    ec48:	29 f4       	brne	.+10     	; 0xec54 <vfprintf+0x94>
    ec4a:	90 e0       	ldi	r25, 0x00	; 0
    ec4c:	b3 01       	movw	r22, r6
    ec4e:	0e 94 8d 80 	call	0x1011a	; 0x1011a <fputc>
    ec52:	e2 cf       	rjmp	.-60     	; 0xec18 <vfprintf+0x58>
    ec54:	98 2f       	mov	r25, r24
    ec56:	10 e0       	ldi	r17, 0x00	; 0
    ec58:	88 24       	eor	r8, r8
    ec5a:	99 24       	eor	r9, r9
    ec5c:	10 32       	cpi	r17, 0x20	; 32
    ec5e:	b0 f4       	brcc	.+44     	; 0xec8c <vfprintf+0xcc>
    ec60:	9b 32       	cpi	r25, 0x2B	; 43
    ec62:	69 f0       	breq	.+26     	; 0xec7e <vfprintf+0xbe>
    ec64:	9c 32       	cpi	r25, 0x2C	; 44
    ec66:	28 f4       	brcc	.+10     	; 0xec72 <vfprintf+0xb2>
    ec68:	90 32       	cpi	r25, 0x20	; 32
    ec6a:	51 f0       	breq	.+20     	; 0xec80 <vfprintf+0xc0>
    ec6c:	93 32       	cpi	r25, 0x23	; 35
    ec6e:	71 f4       	brne	.+28     	; 0xec8c <vfprintf+0xcc>
    ec70:	0b c0       	rjmp	.+22     	; 0xec88 <vfprintf+0xc8>
    ec72:	9d 32       	cpi	r25, 0x2D	; 45
    ec74:	39 f0       	breq	.+14     	; 0xec84 <vfprintf+0xc4>
    ec76:	90 33       	cpi	r25, 0x30	; 48
    ec78:	49 f4       	brne	.+18     	; 0xec8c <vfprintf+0xcc>
    ec7a:	11 60       	ori	r17, 0x01	; 1
    ec7c:	28 c0       	rjmp	.+80     	; 0xecce <vfprintf+0x10e>
    ec7e:	12 60       	ori	r17, 0x02	; 2
    ec80:	14 60       	ori	r17, 0x04	; 4
    ec82:	25 c0       	rjmp	.+74     	; 0xecce <vfprintf+0x10e>
    ec84:	18 60       	ori	r17, 0x08	; 8
    ec86:	23 c0       	rjmp	.+70     	; 0xecce <vfprintf+0x10e>
    ec88:	10 61       	ori	r17, 0x10	; 16
    ec8a:	21 c0       	rjmp	.+66     	; 0xecce <vfprintf+0x10e>
    ec8c:	17 fd       	sbrc	r17, 7
    ec8e:	2a c0       	rjmp	.+84     	; 0xece4 <vfprintf+0x124>
    ec90:	89 2f       	mov	r24, r25
    ec92:	80 53       	subi	r24, 0x30	; 48
    ec94:	8a 30       	cpi	r24, 0x0A	; 10
    ec96:	78 f4       	brcc	.+30     	; 0xecb6 <vfprintf+0xf6>
    ec98:	16 ff       	sbrs	r17, 6
    ec9a:	06 c0       	rjmp	.+12     	; 0xeca8 <vfprintf+0xe8>
    ec9c:	fa e0       	ldi	r31, 0x0A	; 10
    ec9e:	9f 9e       	mul	r9, r31
    eca0:	90 2c       	mov	r9, r0
    eca2:	11 24       	eor	r1, r1
    eca4:	98 0e       	add	r9, r24
    eca6:	13 c0       	rjmp	.+38     	; 0xecce <vfprintf+0x10e>
    eca8:	3a e0       	ldi	r19, 0x0A	; 10
    ecaa:	83 9e       	mul	r8, r19
    ecac:	80 2c       	mov	r8, r0
    ecae:	11 24       	eor	r1, r1
    ecb0:	88 0e       	add	r8, r24
    ecb2:	10 62       	ori	r17, 0x20	; 32
    ecb4:	0c c0       	rjmp	.+24     	; 0xecce <vfprintf+0x10e>
    ecb6:	9e 32       	cpi	r25, 0x2E	; 46
    ecb8:	21 f4       	brne	.+8      	; 0xecc2 <vfprintf+0x102>
    ecba:	16 fd       	sbrc	r17, 6
    ecbc:	14 c3       	rjmp	.+1576   	; 0xf2e6 <vfprintf+0x726>
    ecbe:	10 64       	ori	r17, 0x40	; 64
    ecc0:	06 c0       	rjmp	.+12     	; 0xecce <vfprintf+0x10e>
    ecc2:	9c 36       	cpi	r25, 0x6C	; 108
    ecc4:	11 f4       	brne	.+4      	; 0xecca <vfprintf+0x10a>
    ecc6:	10 68       	ori	r17, 0x80	; 128
    ecc8:	02 c0       	rjmp	.+4      	; 0xecce <vfprintf+0x10e>
    ecca:	98 36       	cpi	r25, 0x68	; 104
    eccc:	59 f4       	brne	.+22     	; 0xece4 <vfprintf+0x124>
    ecce:	ee 85       	ldd	r30, Y+14	; 0x0e
    ecd0:	ff 85       	ldd	r31, Y+15	; 0x0f
    ecd2:	23 fd       	sbrc	r18, 3
    ecd4:	95 91       	lpm	r25, Z+
    ecd6:	23 ff       	sbrs	r18, 3
    ecd8:	91 91       	ld	r25, Z+
    ecda:	ff 87       	std	Y+15, r31	; 0x0f
    ecdc:	ee 87       	std	Y+14, r30	; 0x0e
    ecde:	99 23       	and	r25, r25
    ece0:	09 f0       	breq	.+2      	; 0xece4 <vfprintf+0x124>
    ece2:	bc cf       	rjmp	.-136    	; 0xec5c <vfprintf+0x9c>
    ece4:	89 2f       	mov	r24, r25
    ece6:	85 54       	subi	r24, 0x45	; 69
    ece8:	83 30       	cpi	r24, 0x03	; 3
    ecea:	20 f4       	brcc	.+8      	; 0xecf4 <vfprintf+0x134>
    ecec:	81 2f       	mov	r24, r17
    ecee:	80 61       	ori	r24, 0x10	; 16
    ecf0:	90 5e       	subi	r25, 0xE0	; 224
    ecf2:	07 c0       	rjmp	.+14     	; 0xed02 <vfprintf+0x142>
    ecf4:	89 2f       	mov	r24, r25
    ecf6:	85 56       	subi	r24, 0x65	; 101
    ecf8:	83 30       	cpi	r24, 0x03	; 3
    ecfa:	08 f0       	brcs	.+2      	; 0xecfe <vfprintf+0x13e>
    ecfc:	9f c1       	rjmp	.+830    	; 0xf03c <vfprintf+0x47c>
    ecfe:	81 2f       	mov	r24, r17
    ed00:	8f 7e       	andi	r24, 0xEF	; 239
    ed02:	86 fd       	sbrc	r24, 6
    ed04:	02 c0       	rjmp	.+4      	; 0xed0a <vfprintf+0x14a>
    ed06:	76 e0       	ldi	r23, 0x06	; 6
    ed08:	97 2e       	mov	r9, r23
    ed0a:	6f e3       	ldi	r22, 0x3F	; 63
    ed0c:	f6 2e       	mov	r15, r22
    ed0e:	f8 22       	and	r15, r24
    ed10:	95 36       	cpi	r25, 0x65	; 101
    ed12:	19 f4       	brne	.+6      	; 0xed1a <vfprintf+0x15a>
    ed14:	f0 e4       	ldi	r31, 0x40	; 64
    ed16:	ff 2a       	or	r15, r31
    ed18:	07 c0       	rjmp	.+14     	; 0xed28 <vfprintf+0x168>
    ed1a:	96 36       	cpi	r25, 0x66	; 102
    ed1c:	19 f4       	brne	.+6      	; 0xed24 <vfprintf+0x164>
    ed1e:	20 e8       	ldi	r18, 0x80	; 128
    ed20:	f2 2a       	or	r15, r18
    ed22:	02 c0       	rjmp	.+4      	; 0xed28 <vfprintf+0x168>
    ed24:	91 10       	cpse	r9, r1
    ed26:	9a 94       	dec	r9
    ed28:	f7 fe       	sbrs	r15, 7
    ed2a:	0a c0       	rjmp	.+20     	; 0xed40 <vfprintf+0x180>
    ed2c:	3b e3       	ldi	r19, 0x3B	; 59
    ed2e:	39 15       	cp	r19, r9
    ed30:	18 f4       	brcc	.+6      	; 0xed38 <vfprintf+0x178>
    ed32:	5c e3       	ldi	r21, 0x3C	; 60
    ed34:	b5 2e       	mov	r11, r21
    ed36:	02 c0       	rjmp	.+4      	; 0xed3c <vfprintf+0x17c>
    ed38:	b9 2c       	mov	r11, r9
    ed3a:	b3 94       	inc	r11
    ed3c:	27 e0       	ldi	r18, 0x07	; 7
    ed3e:	09 c0       	rjmp	.+18     	; 0xed52 <vfprintf+0x192>
    ed40:	47 e0       	ldi	r20, 0x07	; 7
    ed42:	49 15       	cp	r20, r9
    ed44:	20 f4       	brcc	.+8      	; 0xed4e <vfprintf+0x18e>
    ed46:	bb 24       	eor	r11, r11
    ed48:	47 e0       	ldi	r20, 0x07	; 7
    ed4a:	94 2e       	mov	r9, r20
    ed4c:	f7 cf       	rjmp	.-18     	; 0xed3c <vfprintf+0x17c>
    ed4e:	29 2d       	mov	r18, r9
    ed50:	bb 24       	eor	r11, r11
    ed52:	c6 01       	movw	r24, r12
    ed54:	04 96       	adiw	r24, 0x04	; 4
    ed56:	9d 87       	std	Y+13, r25	; 0x0d
    ed58:	8c 87       	std	Y+12, r24	; 0x0c
    ed5a:	f6 01       	movw	r30, r12
    ed5c:	60 81       	ld	r22, Z
    ed5e:	71 81       	ldd	r23, Z+1	; 0x01
    ed60:	82 81       	ldd	r24, Z+2	; 0x02
    ed62:	93 81       	ldd	r25, Z+3	; 0x03
    ed64:	ae 01       	movw	r20, r28
    ed66:	4f 5f       	subi	r20, 0xFF	; 255
    ed68:	5f 4f       	sbci	r21, 0xFF	; 255
    ed6a:	0b 2d       	mov	r16, r11
    ed6c:	0e 94 ca 7e 	call	0xfd94	; 0xfd94 <__ftoa_engine>
    ed70:	6c 01       	movw	r12, r24
    ed72:	09 81       	ldd	r16, Y+1	; 0x01
    ed74:	20 2e       	mov	r2, r16
    ed76:	33 24       	eor	r3, r3
    ed78:	00 ff       	sbrs	r16, 0
    ed7a:	04 c0       	rjmp	.+8      	; 0xed84 <vfprintf+0x1c4>
    ed7c:	03 fd       	sbrc	r16, 3
    ed7e:	02 c0       	rjmp	.+4      	; 0xed84 <vfprintf+0x1c4>
    ed80:	1d e2       	ldi	r17, 0x2D	; 45
    ed82:	09 c0       	rjmp	.+18     	; 0xed96 <vfprintf+0x1d6>
    ed84:	f1 fe       	sbrs	r15, 1
    ed86:	02 c0       	rjmp	.+4      	; 0xed8c <vfprintf+0x1cc>
    ed88:	1b e2       	ldi	r17, 0x2B	; 43
    ed8a:	05 c0       	rjmp	.+10     	; 0xed96 <vfprintf+0x1d6>
    ed8c:	f2 fc       	sbrc	r15, 2
    ed8e:	02 c0       	rjmp	.+4      	; 0xed94 <vfprintf+0x1d4>
    ed90:	10 e0       	ldi	r17, 0x00	; 0
    ed92:	01 c0       	rjmp	.+2      	; 0xed96 <vfprintf+0x1d6>
    ed94:	10 e2       	ldi	r17, 0x20	; 32
    ed96:	c1 01       	movw	r24, r2
    ed98:	8c 70       	andi	r24, 0x0C	; 12
    ed9a:	90 70       	andi	r25, 0x00	; 0
    ed9c:	89 2b       	or	r24, r25
    ed9e:	b9 f1       	breq	.+110    	; 0xee0e <vfprintf+0x24e>
    eda0:	11 23       	and	r17, r17
    eda2:	11 f4       	brne	.+4      	; 0xeda8 <vfprintf+0x1e8>
    eda4:	83 e0       	ldi	r24, 0x03	; 3
    eda6:	01 c0       	rjmp	.+2      	; 0xedaa <vfprintf+0x1ea>
    eda8:	84 e0       	ldi	r24, 0x04	; 4
    edaa:	88 15       	cp	r24, r8
    edac:	10 f0       	brcs	.+4      	; 0xedb2 <vfprintf+0x1f2>
    edae:	88 24       	eor	r8, r8
    edb0:	0a c0       	rjmp	.+20     	; 0xedc6 <vfprintf+0x206>
    edb2:	88 1a       	sub	r8, r24
    edb4:	f3 fc       	sbrc	r15, 3
    edb6:	07 c0       	rjmp	.+14     	; 0xedc6 <vfprintf+0x206>
    edb8:	80 e2       	ldi	r24, 0x20	; 32
    edba:	90 e0       	ldi	r25, 0x00	; 0
    edbc:	b3 01       	movw	r22, r6
    edbe:	0e 94 8d 80 	call	0x1011a	; 0x1011a <fputc>
    edc2:	8a 94       	dec	r8
    edc4:	c9 f7       	brne	.-14     	; 0xedb8 <vfprintf+0x1f8>
    edc6:	11 23       	and	r17, r17
    edc8:	29 f0       	breq	.+10     	; 0xedd4 <vfprintf+0x214>
    edca:	81 2f       	mov	r24, r17
    edcc:	90 e0       	ldi	r25, 0x00	; 0
    edce:	b3 01       	movw	r22, r6
    edd0:	0e 94 8d 80 	call	0x1011a	; 0x1011a <fputc>
    edd4:	23 fe       	sbrs	r2, 3
    edd6:	03 c0       	rjmp	.+6      	; 0xedde <vfprintf+0x21e>
    edd8:	0e ec       	ldi	r16, 0xCE	; 206
    edda:	12 e0       	ldi	r17, 0x02	; 2
    eddc:	0e c0       	rjmp	.+28     	; 0xedfa <vfprintf+0x23a>
    edde:	02 ed       	ldi	r16, 0xD2	; 210
    ede0:	12 e0       	ldi	r17, 0x02	; 2
    ede2:	0b c0       	rjmp	.+22     	; 0xedfa <vfprintf+0x23a>
    ede4:	e1 14       	cp	r14, r1
    ede6:	f1 04       	cpc	r15, r1
    ede8:	09 f0       	breq	.+2      	; 0xedec <vfprintf+0x22c>
    edea:	80 52       	subi	r24, 0x20	; 32
    edec:	90 e0       	ldi	r25, 0x00	; 0
    edee:	b3 01       	movw	r22, r6
    edf0:	0e 94 8d 80 	call	0x1011a	; 0x1011a <fputc>
    edf4:	0f 5f       	subi	r16, 0xFF	; 255
    edf6:	1f 4f       	sbci	r17, 0xFF	; 255
    edf8:	05 c0       	rjmp	.+10     	; 0xee04 <vfprintf+0x244>
    edfa:	ef 2c       	mov	r14, r15
    edfc:	ff 24       	eor	r15, r15
    edfe:	f0 e1       	ldi	r31, 0x10	; 16
    ee00:	ef 22       	and	r14, r31
    ee02:	ff 24       	eor	r15, r15
    ee04:	f8 01       	movw	r30, r16
    ee06:	84 91       	lpm	r24, Z+
    ee08:	88 23       	and	r24, r24
    ee0a:	61 f7       	brne	.-40     	; 0xede4 <vfprintf+0x224>
    ee0c:	14 c1       	rjmp	.+552    	; 0xf036 <vfprintf+0x476>
    ee0e:	f7 fe       	sbrs	r15, 7
    ee10:	12 c0       	rjmp	.+36     	; 0xee36 <vfprintf+0x276>
    ee12:	bc 0c       	add	r11, r12
    ee14:	24 fe       	sbrs	r2, 4
    ee16:	04 c0       	rjmp	.+8      	; 0xee20 <vfprintf+0x260>
    ee18:	8a 81       	ldd	r24, Y+2	; 0x02
    ee1a:	81 33       	cpi	r24, 0x31	; 49
    ee1c:	09 f4       	brne	.+2      	; 0xee20 <vfprintf+0x260>
    ee1e:	ba 94       	dec	r11
    ee20:	1b 14       	cp	r1, r11
    ee22:	1c f0       	brlt	.+6      	; 0xee2a <vfprintf+0x26a>
    ee24:	bb 24       	eor	r11, r11
    ee26:	b3 94       	inc	r11
    ee28:	2d c0       	rjmp	.+90     	; 0xee84 <vfprintf+0x2c4>
    ee2a:	f8 e0       	ldi	r31, 0x08	; 8
    ee2c:	fb 15       	cp	r31, r11
    ee2e:	50 f5       	brcc	.+84     	; 0xee84 <vfprintf+0x2c4>
    ee30:	38 e0       	ldi	r19, 0x08	; 8
    ee32:	b3 2e       	mov	r11, r19
    ee34:	27 c0       	rjmp	.+78     	; 0xee84 <vfprintf+0x2c4>
    ee36:	f6 fc       	sbrc	r15, 6
    ee38:	25 c0       	rjmp	.+74     	; 0xee84 <vfprintf+0x2c4>
    ee3a:	89 2d       	mov	r24, r9
    ee3c:	90 e0       	ldi	r25, 0x00	; 0
    ee3e:	8c 15       	cp	r24, r12
    ee40:	9d 05       	cpc	r25, r13
    ee42:	4c f0       	brlt	.+18     	; 0xee56 <vfprintf+0x296>
    ee44:	2c ef       	ldi	r18, 0xFC	; 252
    ee46:	c2 16       	cp	r12, r18
    ee48:	2f ef       	ldi	r18, 0xFF	; 255
    ee4a:	d2 06       	cpc	r13, r18
    ee4c:	24 f0       	brlt	.+8      	; 0xee56 <vfprintf+0x296>
    ee4e:	30 e8       	ldi	r19, 0x80	; 128
    ee50:	f3 2a       	or	r15, r19
    ee52:	01 c0       	rjmp	.+2      	; 0xee56 <vfprintf+0x296>
    ee54:	9a 94       	dec	r9
    ee56:	99 20       	and	r9, r9
    ee58:	49 f0       	breq	.+18     	; 0xee6c <vfprintf+0x2ac>
    ee5a:	e2 e0       	ldi	r30, 0x02	; 2
    ee5c:	f0 e0       	ldi	r31, 0x00	; 0
    ee5e:	ec 0f       	add	r30, r28
    ee60:	fd 1f       	adc	r31, r29
    ee62:	e9 0d       	add	r30, r9
    ee64:	f1 1d       	adc	r31, r1
    ee66:	80 81       	ld	r24, Z
    ee68:	80 33       	cpi	r24, 0x30	; 48
    ee6a:	a1 f3       	breq	.-24     	; 0xee54 <vfprintf+0x294>
    ee6c:	f7 fe       	sbrs	r15, 7
    ee6e:	0a c0       	rjmp	.+20     	; 0xee84 <vfprintf+0x2c4>
    ee70:	b9 2c       	mov	r11, r9
    ee72:	b3 94       	inc	r11
    ee74:	89 2d       	mov	r24, r9
    ee76:	90 e0       	ldi	r25, 0x00	; 0
    ee78:	c8 16       	cp	r12, r24
    ee7a:	d9 06       	cpc	r13, r25
    ee7c:	14 f0       	brlt	.+4      	; 0xee82 <vfprintf+0x2c2>
    ee7e:	99 24       	eor	r9, r9
    ee80:	01 c0       	rjmp	.+2      	; 0xee84 <vfprintf+0x2c4>
    ee82:	9c 18       	sub	r9, r12
    ee84:	f7 fc       	sbrc	r15, 7
    ee86:	03 c0       	rjmp	.+6      	; 0xee8e <vfprintf+0x2ce>
    ee88:	25 e0       	ldi	r18, 0x05	; 5
    ee8a:	30 e0       	ldi	r19, 0x00	; 0
    ee8c:	09 c0       	rjmp	.+18     	; 0xeea0 <vfprintf+0x2e0>
    ee8e:	1c 14       	cp	r1, r12
    ee90:	1d 04       	cpc	r1, r13
    ee92:	1c f0       	brlt	.+6      	; 0xee9a <vfprintf+0x2da>
    ee94:	21 e0       	ldi	r18, 0x01	; 1
    ee96:	30 e0       	ldi	r19, 0x00	; 0
    ee98:	03 c0       	rjmp	.+6      	; 0xeea0 <vfprintf+0x2e0>
    ee9a:	96 01       	movw	r18, r12
    ee9c:	2f 5f       	subi	r18, 0xFF	; 255
    ee9e:	3f 4f       	sbci	r19, 0xFF	; 255
    eea0:	11 23       	and	r17, r17
    eea2:	11 f0       	breq	.+4      	; 0xeea8 <vfprintf+0x2e8>
    eea4:	2f 5f       	subi	r18, 0xFF	; 255
    eea6:	3f 4f       	sbci	r19, 0xFF	; 255
    eea8:	99 20       	and	r9, r9
    eeaa:	29 f0       	breq	.+10     	; 0xeeb6 <vfprintf+0x2f6>
    eeac:	89 2d       	mov	r24, r9
    eeae:	90 e0       	ldi	r25, 0x00	; 0
    eeb0:	01 96       	adiw	r24, 0x01	; 1
    eeb2:	28 0f       	add	r18, r24
    eeb4:	39 1f       	adc	r19, r25
    eeb6:	88 2d       	mov	r24, r8
    eeb8:	90 e0       	ldi	r25, 0x00	; 0
    eeba:	28 17       	cp	r18, r24
    eebc:	39 07       	cpc	r19, r25
    eebe:	14 f0       	brlt	.+4      	; 0xeec4 <vfprintf+0x304>
    eec0:	88 24       	eor	r8, r8
    eec2:	01 c0       	rjmp	.+2      	; 0xeec6 <vfprintf+0x306>
    eec4:	82 1a       	sub	r8, r18
    eec6:	4f 2c       	mov	r4, r15
    eec8:	55 24       	eor	r5, r5
    eeca:	c2 01       	movw	r24, r4
    eecc:	89 70       	andi	r24, 0x09	; 9
    eece:	90 70       	andi	r25, 0x00	; 0
    eed0:	89 2b       	or	r24, r25
    eed2:	39 f0       	breq	.+14     	; 0xeee2 <vfprintf+0x322>
    eed4:	08 c0       	rjmp	.+16     	; 0xeee6 <vfprintf+0x326>
    eed6:	80 e2       	ldi	r24, 0x20	; 32
    eed8:	90 e0       	ldi	r25, 0x00	; 0
    eeda:	b3 01       	movw	r22, r6
    eedc:	0e 94 8d 80 	call	0x1011a	; 0x1011a <fputc>
    eee0:	8a 94       	dec	r8
    eee2:	88 20       	and	r8, r8
    eee4:	c1 f7       	brne	.-16     	; 0xeed6 <vfprintf+0x316>
    eee6:	11 23       	and	r17, r17
    eee8:	29 f0       	breq	.+10     	; 0xeef4 <vfprintf+0x334>
    eeea:	81 2f       	mov	r24, r17
    eeec:	90 e0       	ldi	r25, 0x00	; 0
    eeee:	b3 01       	movw	r22, r6
    eef0:	0e 94 8d 80 	call	0x1011a	; 0x1011a <fputc>
    eef4:	43 fe       	sbrs	r4, 3
    eef6:	07 c0       	rjmp	.+14     	; 0xef06 <vfprintf+0x346>
    eef8:	08 c0       	rjmp	.+16     	; 0xef0a <vfprintf+0x34a>
    eefa:	80 e3       	ldi	r24, 0x30	; 48
    eefc:	90 e0       	ldi	r25, 0x00	; 0
    eefe:	b3 01       	movw	r22, r6
    ef00:	0e 94 8d 80 	call	0x1011a	; 0x1011a <fputc>
    ef04:	8a 94       	dec	r8
    ef06:	88 20       	and	r8, r8
    ef08:	c1 f7       	brne	.-16     	; 0xeefa <vfprintf+0x33a>
    ef0a:	f7 fe       	sbrs	r15, 7
    ef0c:	46 c0       	rjmp	.+140    	; 0xef9a <vfprintf+0x3da>
    ef0e:	86 01       	movw	r16, r12
    ef10:	d7 fe       	sbrs	r13, 7
    ef12:	02 c0       	rjmp	.+4      	; 0xef18 <vfprintf+0x358>
    ef14:	00 e0       	ldi	r16, 0x00	; 0
    ef16:	10 e0       	ldi	r17, 0x00	; 0
    ef18:	76 01       	movw	r14, r12
    ef1a:	08 94       	sec
    ef1c:	e1 1c       	adc	r14, r1
    ef1e:	f1 1c       	adc	r15, r1
    ef20:	e0 1a       	sub	r14, r16
    ef22:	f1 0a       	sbc	r15, r17
    ef24:	41 e0       	ldi	r20, 0x01	; 1
    ef26:	50 e0       	ldi	r21, 0x00	; 0
    ef28:	4c 0f       	add	r20, r28
    ef2a:	5d 1f       	adc	r21, r29
    ef2c:	e4 0e       	add	r14, r20
    ef2e:	f5 1e       	adc	r15, r21
    ef30:	26 01       	movw	r4, r12
    ef32:	4b 18       	sub	r4, r11
    ef34:	51 08       	sbc	r5, r1
    ef36:	89 2d       	mov	r24, r9
    ef38:	90 e0       	ldi	r25, 0x00	; 0
    ef3a:	aa 24       	eor	r10, r10
    ef3c:	bb 24       	eor	r11, r11
    ef3e:	a8 1a       	sub	r10, r24
    ef40:	b9 0a       	sbc	r11, r25
    ef42:	5f ef       	ldi	r21, 0xFF	; 255
    ef44:	0f 3f       	cpi	r16, 0xFF	; 255
    ef46:	15 07       	cpc	r17, r21
    ef48:	29 f4       	brne	.+10     	; 0xef54 <vfprintf+0x394>
    ef4a:	8e e2       	ldi	r24, 0x2E	; 46
    ef4c:	90 e0       	ldi	r25, 0x00	; 0
    ef4e:	b3 01       	movw	r22, r6
    ef50:	0e 94 8d 80 	call	0x1011a	; 0x1011a <fputc>
    ef54:	c0 16       	cp	r12, r16
    ef56:	d1 06       	cpc	r13, r17
    ef58:	34 f0       	brlt	.+12     	; 0xef66 <vfprintf+0x3a6>
    ef5a:	40 16       	cp	r4, r16
    ef5c:	51 06       	cpc	r5, r17
    ef5e:	1c f4       	brge	.+6      	; 0xef66 <vfprintf+0x3a6>
    ef60:	f7 01       	movw	r30, r14
    ef62:	80 81       	ld	r24, Z
    ef64:	01 c0       	rjmp	.+2      	; 0xef68 <vfprintf+0x3a8>
    ef66:	80 e3       	ldi	r24, 0x30	; 48
    ef68:	01 50       	subi	r16, 0x01	; 1
    ef6a:	10 40       	sbci	r17, 0x00	; 0
    ef6c:	08 94       	sec
    ef6e:	e1 1c       	adc	r14, r1
    ef70:	f1 1c       	adc	r15, r1
    ef72:	0a 15       	cp	r16, r10
    ef74:	1b 05       	cpc	r17, r11
    ef76:	2c f0       	brlt	.+10     	; 0xef82 <vfprintf+0x3c2>
    ef78:	90 e0       	ldi	r25, 0x00	; 0
    ef7a:	b3 01       	movw	r22, r6
    ef7c:	0e 94 8d 80 	call	0x1011a	; 0x1011a <fputc>
    ef80:	e0 cf       	rjmp	.-64     	; 0xef42 <vfprintf+0x382>
    ef82:	0c 15       	cp	r16, r12
    ef84:	1d 05       	cpc	r17, r13
    ef86:	39 f4       	brne	.+14     	; 0xef96 <vfprintf+0x3d6>
    ef88:	9a 81       	ldd	r25, Y+2	; 0x02
    ef8a:	96 33       	cpi	r25, 0x36	; 54
    ef8c:	18 f4       	brcc	.+6      	; 0xef94 <vfprintf+0x3d4>
    ef8e:	95 33       	cpi	r25, 0x35	; 53
    ef90:	11 f4       	brne	.+4      	; 0xef96 <vfprintf+0x3d6>
    ef92:	24 fe       	sbrs	r2, 4
    ef94:	81 e3       	ldi	r24, 0x31	; 49
    ef96:	90 e0       	ldi	r25, 0x00	; 0
    ef98:	4b c0       	rjmp	.+150    	; 0xf030 <vfprintf+0x470>
    ef9a:	8a 81       	ldd	r24, Y+2	; 0x02
    ef9c:	81 33       	cpi	r24, 0x31	; 49
    ef9e:	09 f0       	breq	.+2      	; 0xefa2 <vfprintf+0x3e2>
    efa0:	0f 7e       	andi	r16, 0xEF	; 239
    efa2:	90 e0       	ldi	r25, 0x00	; 0
    efa4:	b3 01       	movw	r22, r6
    efa6:	0e 94 8d 80 	call	0x1011a	; 0x1011a <fputc>
    efaa:	99 20       	and	r9, r9
    efac:	a1 f0       	breq	.+40     	; 0xefd6 <vfprintf+0x416>
    efae:	8e e2       	ldi	r24, 0x2E	; 46
    efb0:	90 e0       	ldi	r25, 0x00	; 0
    efb2:	b3 01       	movw	r22, r6
    efb4:	0e 94 8d 80 	call	0x1011a	; 0x1011a <fputc>
    efb8:	12 e0       	ldi	r17, 0x02	; 2
    efba:	e1 e0       	ldi	r30, 0x01	; 1
    efbc:	f0 e0       	ldi	r31, 0x00	; 0
    efbe:	ec 0f       	add	r30, r28
    efc0:	fd 1f       	adc	r31, r29
    efc2:	e1 0f       	add	r30, r17
    efc4:	f1 1d       	adc	r31, r1
    efc6:	1f 5f       	subi	r17, 0xFF	; 255
    efc8:	80 81       	ld	r24, Z
    efca:	90 e0       	ldi	r25, 0x00	; 0
    efcc:	b3 01       	movw	r22, r6
    efce:	0e 94 8d 80 	call	0x1011a	; 0x1011a <fputc>
    efd2:	9a 94       	dec	r9
    efd4:	91 f7       	brne	.-28     	; 0xefba <vfprintf+0x3fa>
    efd6:	44 fc       	sbrc	r4, 4
    efd8:	03 c0       	rjmp	.+6      	; 0xefe0 <vfprintf+0x420>
    efda:	85 e6       	ldi	r24, 0x65	; 101
    efdc:	90 e0       	ldi	r25, 0x00	; 0
    efde:	02 c0       	rjmp	.+4      	; 0xefe4 <vfprintf+0x424>
    efe0:	85 e4       	ldi	r24, 0x45	; 69
    efe2:	90 e0       	ldi	r25, 0x00	; 0
    efe4:	b3 01       	movw	r22, r6
    efe6:	0e 94 8d 80 	call	0x1011a	; 0x1011a <fputc>
    efea:	d7 fc       	sbrc	r13, 7
    efec:	05 c0       	rjmp	.+10     	; 0xeff8 <vfprintf+0x438>
    efee:	c1 14       	cp	r12, r1
    eff0:	d1 04       	cpc	r13, r1
    eff2:	41 f4       	brne	.+16     	; 0xf004 <vfprintf+0x444>
    eff4:	04 ff       	sbrs	r16, 4
    eff6:	06 c0       	rjmp	.+12     	; 0xf004 <vfprintf+0x444>
    eff8:	d0 94       	com	r13
    effa:	c1 94       	neg	r12
    effc:	d1 08       	sbc	r13, r1
    effe:	d3 94       	inc	r13
    f000:	8d e2       	ldi	r24, 0x2D	; 45
    f002:	01 c0       	rjmp	.+2      	; 0xf006 <vfprintf+0x446>
    f004:	8b e2       	ldi	r24, 0x2B	; 43
    f006:	90 e0       	ldi	r25, 0x00	; 0
    f008:	b3 01       	movw	r22, r6
    f00a:	0e 94 8d 80 	call	0x1011a	; 0x1011a <fputc>
    f00e:	80 e3       	ldi	r24, 0x30	; 48
    f010:	05 c0       	rjmp	.+10     	; 0xf01c <vfprintf+0x45c>
    f012:	8f 5f       	subi	r24, 0xFF	; 255
    f014:	26 ef       	ldi	r18, 0xF6	; 246
    f016:	3f ef       	ldi	r19, 0xFF	; 255
    f018:	c2 0e       	add	r12, r18
    f01a:	d3 1e       	adc	r13, r19
    f01c:	3a e0       	ldi	r19, 0x0A	; 10
    f01e:	c3 16       	cp	r12, r19
    f020:	d1 04       	cpc	r13, r1
    f022:	bc f7       	brge	.-18     	; 0xf012 <vfprintf+0x452>
    f024:	90 e0       	ldi	r25, 0x00	; 0
    f026:	b3 01       	movw	r22, r6
    f028:	0e 94 8d 80 	call	0x1011a	; 0x1011a <fputc>
    f02c:	c6 01       	movw	r24, r12
    f02e:	c0 96       	adiw	r24, 0x30	; 48
    f030:	b3 01       	movw	r22, r6
    f032:	0e 94 8d 80 	call	0x1011a	; 0x1011a <fputc>
    f036:	cc 84       	ldd	r12, Y+12	; 0x0c
    f038:	dd 84       	ldd	r13, Y+13	; 0x0d
    f03a:	52 c1       	rjmp	.+676    	; 0xf2e0 <vfprintf+0x720>
    f03c:	93 36       	cpi	r25, 0x63	; 99
    f03e:	31 f0       	breq	.+12     	; 0xf04c <vfprintf+0x48c>
    f040:	93 37       	cpi	r25, 0x73	; 115
    f042:	99 f0       	breq	.+38     	; 0xf06a <vfprintf+0x4aa>
    f044:	93 35       	cpi	r25, 0x53	; 83
    f046:	09 f0       	breq	.+2      	; 0xf04a <vfprintf+0x48a>
    f048:	59 c0       	rjmp	.+178    	; 0xf0fc <vfprintf+0x53c>
    f04a:	23 c0       	rjmp	.+70     	; 0xf092 <vfprintf+0x4d2>
    f04c:	f6 01       	movw	r30, r12
    f04e:	80 81       	ld	r24, Z
    f050:	89 83       	std	Y+1, r24	; 0x01
    f052:	5e 01       	movw	r10, r28
    f054:	08 94       	sec
    f056:	a1 1c       	adc	r10, r1
    f058:	b1 1c       	adc	r11, r1
    f05a:	22 e0       	ldi	r18, 0x02	; 2
    f05c:	30 e0       	ldi	r19, 0x00	; 0
    f05e:	c2 0e       	add	r12, r18
    f060:	d3 1e       	adc	r13, r19
    f062:	21 e0       	ldi	r18, 0x01	; 1
    f064:	e2 2e       	mov	r14, r18
    f066:	f1 2c       	mov	r15, r1
    f068:	12 c0       	rjmp	.+36     	; 0xf08e <vfprintf+0x4ce>
    f06a:	f6 01       	movw	r30, r12
    f06c:	a0 80       	ld	r10, Z
    f06e:	b1 80       	ldd	r11, Z+1	; 0x01
    f070:	16 fd       	sbrc	r17, 6
    f072:	03 c0       	rjmp	.+6      	; 0xf07a <vfprintf+0x4ba>
    f074:	6f ef       	ldi	r22, 0xFF	; 255
    f076:	7f ef       	ldi	r23, 0xFF	; 255
    f078:	02 c0       	rjmp	.+4      	; 0xf07e <vfprintf+0x4be>
    f07a:	69 2d       	mov	r22, r9
    f07c:	70 e0       	ldi	r23, 0x00	; 0
    f07e:	22 e0       	ldi	r18, 0x02	; 2
    f080:	30 e0       	ldi	r19, 0x00	; 0
    f082:	c2 0e       	add	r12, r18
    f084:	d3 1e       	adc	r13, r19
    f086:	c5 01       	movw	r24, r10
    f088:	0e 94 26 80 	call	0x1004c	; 0x1004c <strnlen>
    f08c:	7c 01       	movw	r14, r24
    f08e:	1f 77       	andi	r17, 0x7F	; 127
    f090:	13 c0       	rjmp	.+38     	; 0xf0b8 <vfprintf+0x4f8>
    f092:	f6 01       	movw	r30, r12
    f094:	a0 80       	ld	r10, Z
    f096:	b1 80       	ldd	r11, Z+1	; 0x01
    f098:	16 fd       	sbrc	r17, 6
    f09a:	03 c0       	rjmp	.+6      	; 0xf0a2 <vfprintf+0x4e2>
    f09c:	6f ef       	ldi	r22, 0xFF	; 255
    f09e:	7f ef       	ldi	r23, 0xFF	; 255
    f0a0:	02 c0       	rjmp	.+4      	; 0xf0a6 <vfprintf+0x4e6>
    f0a2:	69 2d       	mov	r22, r9
    f0a4:	70 e0       	ldi	r23, 0x00	; 0
    f0a6:	22 e0       	ldi	r18, 0x02	; 2
    f0a8:	30 e0       	ldi	r19, 0x00	; 0
    f0aa:	c2 0e       	add	r12, r18
    f0ac:	d3 1e       	adc	r13, r19
    f0ae:	c5 01       	movw	r24, r10
    f0b0:	0e 94 e4 7f 	call	0xffc8	; 0xffc8 <strnlen_P>
    f0b4:	7c 01       	movw	r14, r24
    f0b6:	10 68       	ori	r17, 0x80	; 128
    f0b8:	13 ff       	sbrs	r17, 3
    f0ba:	07 c0       	rjmp	.+14     	; 0xf0ca <vfprintf+0x50a>
    f0bc:	1b c0       	rjmp	.+54     	; 0xf0f4 <vfprintf+0x534>
    f0be:	80 e2       	ldi	r24, 0x20	; 32
    f0c0:	90 e0       	ldi	r25, 0x00	; 0
    f0c2:	b3 01       	movw	r22, r6
    f0c4:	0e 94 8d 80 	call	0x1011a	; 0x1011a <fputc>
    f0c8:	8a 94       	dec	r8
    f0ca:	88 2d       	mov	r24, r8
    f0cc:	90 e0       	ldi	r25, 0x00	; 0
    f0ce:	e8 16       	cp	r14, r24
    f0d0:	f9 06       	cpc	r15, r25
    f0d2:	a8 f3       	brcs	.-22     	; 0xf0be <vfprintf+0x4fe>
    f0d4:	0f c0       	rjmp	.+30     	; 0xf0f4 <vfprintf+0x534>
    f0d6:	f5 01       	movw	r30, r10
    f0d8:	17 fd       	sbrc	r17, 7
    f0da:	85 91       	lpm	r24, Z+
    f0dc:	17 ff       	sbrs	r17, 7
    f0de:	81 91       	ld	r24, Z+
    f0e0:	5f 01       	movw	r10, r30
    f0e2:	90 e0       	ldi	r25, 0x00	; 0
    f0e4:	b3 01       	movw	r22, r6
    f0e6:	0e 94 8d 80 	call	0x1011a	; 0x1011a <fputc>
    f0ea:	81 10       	cpse	r8, r1
    f0ec:	8a 94       	dec	r8
    f0ee:	08 94       	sec
    f0f0:	e1 08       	sbc	r14, r1
    f0f2:	f1 08       	sbc	r15, r1
    f0f4:	e1 14       	cp	r14, r1
    f0f6:	f1 04       	cpc	r15, r1
    f0f8:	71 f7       	brne	.-36     	; 0xf0d6 <vfprintf+0x516>
    f0fa:	f2 c0       	rjmp	.+484    	; 0xf2e0 <vfprintf+0x720>
    f0fc:	94 36       	cpi	r25, 0x64	; 100
    f0fe:	11 f0       	breq	.+4      	; 0xf104 <vfprintf+0x544>
    f100:	99 36       	cpi	r25, 0x69	; 105
    f102:	89 f5       	brne	.+98     	; 0xf166 <vfprintf+0x5a6>
    f104:	17 ff       	sbrs	r17, 7
    f106:	08 c0       	rjmp	.+16     	; 0xf118 <vfprintf+0x558>
    f108:	f6 01       	movw	r30, r12
    f10a:	20 81       	ld	r18, Z
    f10c:	31 81       	ldd	r19, Z+1	; 0x01
    f10e:	42 81       	ldd	r20, Z+2	; 0x02
    f110:	53 81       	ldd	r21, Z+3	; 0x03
    f112:	84 e0       	ldi	r24, 0x04	; 4
    f114:	90 e0       	ldi	r25, 0x00	; 0
    f116:	0a c0       	rjmp	.+20     	; 0xf12c <vfprintf+0x56c>
    f118:	f6 01       	movw	r30, r12
    f11a:	80 81       	ld	r24, Z
    f11c:	91 81       	ldd	r25, Z+1	; 0x01
    f11e:	9c 01       	movw	r18, r24
    f120:	44 27       	eor	r20, r20
    f122:	37 fd       	sbrc	r19, 7
    f124:	40 95       	com	r20
    f126:	54 2f       	mov	r21, r20
    f128:	82 e0       	ldi	r24, 0x02	; 2
    f12a:	90 e0       	ldi	r25, 0x00	; 0
    f12c:	c8 0e       	add	r12, r24
    f12e:	d9 1e       	adc	r13, r25
    f130:	9f e6       	ldi	r25, 0x6F	; 111
    f132:	f9 2e       	mov	r15, r25
    f134:	f1 22       	and	r15, r17
    f136:	57 ff       	sbrs	r21, 7
    f138:	09 c0       	rjmp	.+18     	; 0xf14c <vfprintf+0x58c>
    f13a:	50 95       	com	r21
    f13c:	40 95       	com	r20
    f13e:	30 95       	com	r19
    f140:	21 95       	neg	r18
    f142:	3f 4f       	sbci	r19, 0xFF	; 255
    f144:	4f 4f       	sbci	r20, 0xFF	; 255
    f146:	5f 4f       	sbci	r21, 0xFF	; 255
    f148:	90 e8       	ldi	r25, 0x80	; 128
    f14a:	f9 2a       	or	r15, r25
    f14c:	ca 01       	movw	r24, r20
    f14e:	b9 01       	movw	r22, r18
    f150:	ae 01       	movw	r20, r28
    f152:	4f 5f       	subi	r20, 0xFF	; 255
    f154:	5f 4f       	sbci	r21, 0xFF	; 255
    f156:	2a e0       	ldi	r18, 0x0A	; 10
    f158:	30 e0       	ldi	r19, 0x00	; 0
    f15a:	0e 94 7b 81 	call	0x102f6	; 0x102f6 <__ultoa_invert>
    f15e:	e8 2e       	mov	r14, r24
    f160:	e8 89       	ldd	r30, Y+16	; 0x10
    f162:	ee 1a       	sub	r14, r30
    f164:	41 c0       	rjmp	.+130    	; 0xf1e8 <vfprintf+0x628>
    f166:	95 37       	cpi	r25, 0x75	; 117
    f168:	21 f4       	brne	.+8      	; 0xf172 <vfprintf+0x5b2>
    f16a:	1f 7e       	andi	r17, 0xEF	; 239
    f16c:	2a e0       	ldi	r18, 0x0A	; 10
    f16e:	30 e0       	ldi	r19, 0x00	; 0
    f170:	1c c0       	rjmp	.+56     	; 0xf1aa <vfprintf+0x5ea>
    f172:	19 7f       	andi	r17, 0xF9	; 249
    f174:	9f 36       	cpi	r25, 0x6F	; 111
    f176:	61 f0       	breq	.+24     	; 0xf190 <vfprintf+0x5d0>
    f178:	90 37       	cpi	r25, 0x70	; 112
    f17a:	20 f4       	brcc	.+8      	; 0xf184 <vfprintf+0x5c4>
    f17c:	98 35       	cpi	r25, 0x58	; 88
    f17e:	09 f0       	breq	.+2      	; 0xf182 <vfprintf+0x5c2>
    f180:	b2 c0       	rjmp	.+356    	; 0xf2e6 <vfprintf+0x726>
    f182:	0f c0       	rjmp	.+30     	; 0xf1a2 <vfprintf+0x5e2>
    f184:	90 37       	cpi	r25, 0x70	; 112
    f186:	39 f0       	breq	.+14     	; 0xf196 <vfprintf+0x5d6>
    f188:	98 37       	cpi	r25, 0x78	; 120
    f18a:	09 f0       	breq	.+2      	; 0xf18e <vfprintf+0x5ce>
    f18c:	ac c0       	rjmp	.+344    	; 0xf2e6 <vfprintf+0x726>
    f18e:	04 c0       	rjmp	.+8      	; 0xf198 <vfprintf+0x5d8>
    f190:	28 e0       	ldi	r18, 0x08	; 8
    f192:	30 e0       	ldi	r19, 0x00	; 0
    f194:	0a c0       	rjmp	.+20     	; 0xf1aa <vfprintf+0x5ea>
    f196:	10 61       	ori	r17, 0x10	; 16
    f198:	14 fd       	sbrc	r17, 4
    f19a:	14 60       	ori	r17, 0x04	; 4
    f19c:	20 e1       	ldi	r18, 0x10	; 16
    f19e:	30 e0       	ldi	r19, 0x00	; 0
    f1a0:	04 c0       	rjmp	.+8      	; 0xf1aa <vfprintf+0x5ea>
    f1a2:	14 fd       	sbrc	r17, 4
    f1a4:	16 60       	ori	r17, 0x06	; 6
    f1a6:	20 e1       	ldi	r18, 0x10	; 16
    f1a8:	32 e0       	ldi	r19, 0x02	; 2
    f1aa:	17 ff       	sbrs	r17, 7
    f1ac:	08 c0       	rjmp	.+16     	; 0xf1be <vfprintf+0x5fe>
    f1ae:	f6 01       	movw	r30, r12
    f1b0:	60 81       	ld	r22, Z
    f1b2:	71 81       	ldd	r23, Z+1	; 0x01
    f1b4:	82 81       	ldd	r24, Z+2	; 0x02
    f1b6:	93 81       	ldd	r25, Z+3	; 0x03
    f1b8:	44 e0       	ldi	r20, 0x04	; 4
    f1ba:	50 e0       	ldi	r21, 0x00	; 0
    f1bc:	08 c0       	rjmp	.+16     	; 0xf1ce <vfprintf+0x60e>
    f1be:	f6 01       	movw	r30, r12
    f1c0:	80 81       	ld	r24, Z
    f1c2:	91 81       	ldd	r25, Z+1	; 0x01
    f1c4:	bc 01       	movw	r22, r24
    f1c6:	80 e0       	ldi	r24, 0x00	; 0
    f1c8:	90 e0       	ldi	r25, 0x00	; 0
    f1ca:	42 e0       	ldi	r20, 0x02	; 2
    f1cc:	50 e0       	ldi	r21, 0x00	; 0
    f1ce:	c4 0e       	add	r12, r20
    f1d0:	d5 1e       	adc	r13, r21
    f1d2:	ae 01       	movw	r20, r28
    f1d4:	4f 5f       	subi	r20, 0xFF	; 255
    f1d6:	5f 4f       	sbci	r21, 0xFF	; 255
    f1d8:	0e 94 7b 81 	call	0x102f6	; 0x102f6 <__ultoa_invert>
    f1dc:	e8 2e       	mov	r14, r24
    f1de:	58 89       	ldd	r21, Y+16	; 0x10
    f1e0:	e5 1a       	sub	r14, r21
    f1e2:	8f e7       	ldi	r24, 0x7F	; 127
    f1e4:	f8 2e       	mov	r15, r24
    f1e6:	f1 22       	and	r15, r17
    f1e8:	f6 fe       	sbrs	r15, 6
    f1ea:	0b c0       	rjmp	.+22     	; 0xf202 <vfprintf+0x642>
    f1ec:	8e ef       	ldi	r24, 0xFE	; 254
    f1ee:	f8 22       	and	r15, r24
    f1f0:	e9 14       	cp	r14, r9
    f1f2:	38 f4       	brcc	.+14     	; 0xf202 <vfprintf+0x642>
    f1f4:	f4 fe       	sbrs	r15, 4
    f1f6:	07 c0       	rjmp	.+14     	; 0xf206 <vfprintf+0x646>
    f1f8:	f2 fc       	sbrc	r15, 2
    f1fa:	05 c0       	rjmp	.+10     	; 0xf206 <vfprintf+0x646>
    f1fc:	9f ee       	ldi	r25, 0xEF	; 239
    f1fe:	f9 22       	and	r15, r25
    f200:	02 c0       	rjmp	.+4      	; 0xf206 <vfprintf+0x646>
    f202:	1e 2d       	mov	r17, r14
    f204:	01 c0       	rjmp	.+2      	; 0xf208 <vfprintf+0x648>
    f206:	19 2d       	mov	r17, r9
    f208:	f4 fe       	sbrs	r15, 4
    f20a:	0d c0       	rjmp	.+26     	; 0xf226 <vfprintf+0x666>
    f20c:	fe 01       	movw	r30, r28
    f20e:	ee 0d       	add	r30, r14
    f210:	f1 1d       	adc	r31, r1
    f212:	80 81       	ld	r24, Z
    f214:	80 33       	cpi	r24, 0x30	; 48
    f216:	19 f4       	brne	.+6      	; 0xf21e <vfprintf+0x65e>
    f218:	e9 ee       	ldi	r30, 0xE9	; 233
    f21a:	fe 22       	and	r15, r30
    f21c:	08 c0       	rjmp	.+16     	; 0xf22e <vfprintf+0x66e>
    f21e:	1f 5f       	subi	r17, 0xFF	; 255
    f220:	f2 fe       	sbrs	r15, 2
    f222:	05 c0       	rjmp	.+10     	; 0xf22e <vfprintf+0x66e>
    f224:	03 c0       	rjmp	.+6      	; 0xf22c <vfprintf+0x66c>
    f226:	8f 2d       	mov	r24, r15
    f228:	86 78       	andi	r24, 0x86	; 134
    f22a:	09 f0       	breq	.+2      	; 0xf22e <vfprintf+0x66e>
    f22c:	1f 5f       	subi	r17, 0xFF	; 255
    f22e:	0f 2d       	mov	r16, r15
    f230:	f3 fc       	sbrc	r15, 3
    f232:	14 c0       	rjmp	.+40     	; 0xf25c <vfprintf+0x69c>
    f234:	f0 fe       	sbrs	r15, 0
    f236:	0f c0       	rjmp	.+30     	; 0xf256 <vfprintf+0x696>
    f238:	18 15       	cp	r17, r8
    f23a:	10 f0       	brcs	.+4      	; 0xf240 <vfprintf+0x680>
    f23c:	9e 2c       	mov	r9, r14
    f23e:	0b c0       	rjmp	.+22     	; 0xf256 <vfprintf+0x696>
    f240:	9e 2c       	mov	r9, r14
    f242:	98 0c       	add	r9, r8
    f244:	91 1a       	sub	r9, r17
    f246:	18 2d       	mov	r17, r8
    f248:	06 c0       	rjmp	.+12     	; 0xf256 <vfprintf+0x696>
    f24a:	80 e2       	ldi	r24, 0x20	; 32
    f24c:	90 e0       	ldi	r25, 0x00	; 0
    f24e:	b3 01       	movw	r22, r6
    f250:	0e 94 8d 80 	call	0x1011a	; 0x1011a <fputc>
    f254:	1f 5f       	subi	r17, 0xFF	; 255
    f256:	18 15       	cp	r17, r8
    f258:	c0 f3       	brcs	.-16     	; 0xf24a <vfprintf+0x68a>
    f25a:	04 c0       	rjmp	.+8      	; 0xf264 <vfprintf+0x6a4>
    f25c:	18 15       	cp	r17, r8
    f25e:	10 f4       	brcc	.+4      	; 0xf264 <vfprintf+0x6a4>
    f260:	81 1a       	sub	r8, r17
    f262:	01 c0       	rjmp	.+2      	; 0xf266 <vfprintf+0x6a6>
    f264:	88 24       	eor	r8, r8
    f266:	04 ff       	sbrs	r16, 4
    f268:	0f c0       	rjmp	.+30     	; 0xf288 <vfprintf+0x6c8>
    f26a:	80 e3       	ldi	r24, 0x30	; 48
    f26c:	90 e0       	ldi	r25, 0x00	; 0
    f26e:	b3 01       	movw	r22, r6
    f270:	0e 94 8d 80 	call	0x1011a	; 0x1011a <fputc>
    f274:	02 ff       	sbrs	r16, 2
    f276:	1d c0       	rjmp	.+58     	; 0xf2b2 <vfprintf+0x6f2>
    f278:	01 fd       	sbrc	r16, 1
    f27a:	03 c0       	rjmp	.+6      	; 0xf282 <vfprintf+0x6c2>
    f27c:	88 e7       	ldi	r24, 0x78	; 120
    f27e:	90 e0       	ldi	r25, 0x00	; 0
    f280:	0e c0       	rjmp	.+28     	; 0xf29e <vfprintf+0x6de>
    f282:	88 e5       	ldi	r24, 0x58	; 88
    f284:	90 e0       	ldi	r25, 0x00	; 0
    f286:	0b c0       	rjmp	.+22     	; 0xf29e <vfprintf+0x6de>
    f288:	80 2f       	mov	r24, r16
    f28a:	86 78       	andi	r24, 0x86	; 134
    f28c:	91 f0       	breq	.+36     	; 0xf2b2 <vfprintf+0x6f2>
    f28e:	01 ff       	sbrs	r16, 1
    f290:	02 c0       	rjmp	.+4      	; 0xf296 <vfprintf+0x6d6>
    f292:	8b e2       	ldi	r24, 0x2B	; 43
    f294:	01 c0       	rjmp	.+2      	; 0xf298 <vfprintf+0x6d8>
    f296:	80 e2       	ldi	r24, 0x20	; 32
    f298:	f7 fc       	sbrc	r15, 7
    f29a:	8d e2       	ldi	r24, 0x2D	; 45
    f29c:	90 e0       	ldi	r25, 0x00	; 0
    f29e:	b3 01       	movw	r22, r6
    f2a0:	0e 94 8d 80 	call	0x1011a	; 0x1011a <fputc>
    f2a4:	06 c0       	rjmp	.+12     	; 0xf2b2 <vfprintf+0x6f2>
    f2a6:	80 e3       	ldi	r24, 0x30	; 48
    f2a8:	90 e0       	ldi	r25, 0x00	; 0
    f2aa:	b3 01       	movw	r22, r6
    f2ac:	0e 94 8d 80 	call	0x1011a	; 0x1011a <fputc>
    f2b0:	9a 94       	dec	r9
    f2b2:	e9 14       	cp	r14, r9
    f2b4:	c0 f3       	brcs	.-16     	; 0xf2a6 <vfprintf+0x6e6>
    f2b6:	ea 94       	dec	r14
    f2b8:	e1 e0       	ldi	r30, 0x01	; 1
    f2ba:	f0 e0       	ldi	r31, 0x00	; 0
    f2bc:	ec 0f       	add	r30, r28
    f2be:	fd 1f       	adc	r31, r29
    f2c0:	ee 0d       	add	r30, r14
    f2c2:	f1 1d       	adc	r31, r1
    f2c4:	80 81       	ld	r24, Z
    f2c6:	90 e0       	ldi	r25, 0x00	; 0
    f2c8:	b3 01       	movw	r22, r6
    f2ca:	0e 94 8d 80 	call	0x1011a	; 0x1011a <fputc>
    f2ce:	ee 20       	and	r14, r14
    f2d0:	91 f7       	brne	.-28     	; 0xf2b6 <vfprintf+0x6f6>
    f2d2:	06 c0       	rjmp	.+12     	; 0xf2e0 <vfprintf+0x720>
    f2d4:	80 e2       	ldi	r24, 0x20	; 32
    f2d6:	90 e0       	ldi	r25, 0x00	; 0
    f2d8:	b3 01       	movw	r22, r6
    f2da:	0e 94 8d 80 	call	0x1011a	; 0x1011a <fputc>
    f2de:	8a 94       	dec	r8
    f2e0:	88 20       	and	r8, r8
    f2e2:	c1 f7       	brne	.-16     	; 0xf2d4 <vfprintf+0x714>
    f2e4:	99 cc       	rjmp	.-1742   	; 0xec18 <vfprintf+0x58>
    f2e6:	f3 01       	movw	r30, r6
    f2e8:	66 81       	ldd	r22, Z+6	; 0x06
    f2ea:	77 81       	ldd	r23, Z+7	; 0x07
    f2ec:	cb 01       	movw	r24, r22
    f2ee:	61 96       	adiw	r28, 0x11	; 17
    f2f0:	0f b6       	in	r0, 0x3f	; 63
    f2f2:	f8 94       	cli
    f2f4:	de bf       	out	0x3e, r29	; 62
    f2f6:	0f be       	out	0x3f, r0	; 63
    f2f8:	cd bf       	out	0x3d, r28	; 61
    f2fa:	cf 91       	pop	r28
    f2fc:	df 91       	pop	r29
    f2fe:	1f 91       	pop	r17
    f300:	0f 91       	pop	r16
    f302:	ff 90       	pop	r15
    f304:	ef 90       	pop	r14
    f306:	df 90       	pop	r13
    f308:	cf 90       	pop	r12
    f30a:	bf 90       	pop	r11
    f30c:	af 90       	pop	r10
    f30e:	9f 90       	pop	r9
    f310:	8f 90       	pop	r8
    f312:	7f 90       	pop	r7
    f314:	6f 90       	pop	r6
    f316:	5f 90       	pop	r5
    f318:	4f 90       	pop	r4
    f31a:	3f 90       	pop	r3
    f31c:	2f 90       	pop	r2
    f31e:	08 95       	ret

0000f320 <putval>:
    f320:	fc 01       	movw	r30, r24
    f322:	20 fd       	sbrc	r18, 0
    f324:	08 c0       	rjmp	.+16     	; 0xf336 <putval+0x16>
    f326:	23 fd       	sbrc	r18, 3
    f328:	05 c0       	rjmp	.+10     	; 0xf334 <putval+0x14>
    f32a:	22 ff       	sbrs	r18, 2
    f32c:	02 c0       	rjmp	.+4      	; 0xf332 <putval+0x12>
    f32e:	73 83       	std	Z+3, r23	; 0x03
    f330:	62 83       	std	Z+2, r22	; 0x02
    f332:	51 83       	std	Z+1, r21	; 0x01
    f334:	40 83       	st	Z, r20
    f336:	08 95       	ret

0000f338 <mulacc>:
    f338:	ef 92       	push	r14
    f33a:	ff 92       	push	r15
    f33c:	0f 93       	push	r16
    f33e:	1f 93       	push	r17
    f340:	44 ff       	sbrs	r20, 4
    f342:	02 c0       	rjmp	.+4      	; 0xf348 <mulacc+0x10>
    f344:	33 e0       	ldi	r19, 0x03	; 3
    f346:	11 c0       	rjmp	.+34     	; 0xf36a <mulacc+0x32>
    f348:	46 ff       	sbrs	r20, 6
    f34a:	02 c0       	rjmp	.+4      	; 0xf350 <mulacc+0x18>
    f34c:	34 e0       	ldi	r19, 0x04	; 4
    f34e:	0d c0       	rjmp	.+26     	; 0xf36a <mulacc+0x32>
    f350:	db 01       	movw	r26, r22
    f352:	fc 01       	movw	r30, r24
    f354:	aa 0f       	add	r26, r26
    f356:	bb 1f       	adc	r27, r27
    f358:	ee 1f       	adc	r30, r30
    f35a:	ff 1f       	adc	r31, r31
    f35c:	10 94       	com	r1
    f35e:	d1 f7       	brne	.-12     	; 0xf354 <mulacc+0x1c>
    f360:	6a 0f       	add	r22, r26
    f362:	7b 1f       	adc	r23, r27
    f364:	8e 1f       	adc	r24, r30
    f366:	9f 1f       	adc	r25, r31
    f368:	31 e0       	ldi	r19, 0x01	; 1
    f36a:	66 0f       	add	r22, r22
    f36c:	77 1f       	adc	r23, r23
    f36e:	88 1f       	adc	r24, r24
    f370:	99 1f       	adc	r25, r25
    f372:	31 50       	subi	r19, 0x01	; 1
    f374:	d1 f7       	brne	.-12     	; 0xf36a <mulacc+0x32>
    f376:	7b 01       	movw	r14, r22
    f378:	8c 01       	movw	r16, r24
    f37a:	e2 0e       	add	r14, r18
    f37c:	f1 1c       	adc	r15, r1
    f37e:	01 1d       	adc	r16, r1
    f380:	11 1d       	adc	r17, r1
    f382:	a8 01       	movw	r20, r16
    f384:	97 01       	movw	r18, r14
    f386:	b7 01       	movw	r22, r14
    f388:	ca 01       	movw	r24, r20
    f38a:	1f 91       	pop	r17
    f38c:	0f 91       	pop	r16
    f38e:	ff 90       	pop	r15
    f390:	ef 90       	pop	r14
    f392:	08 95       	ret

0000f394 <skip_spaces>:
    f394:	0f 93       	push	r16
    f396:	1f 93       	push	r17
    f398:	cf 93       	push	r28
    f39a:	df 93       	push	r29
    f39c:	8c 01       	movw	r16, r24
    f39e:	c8 01       	movw	r24, r16
    f3a0:	0e 94 4b 80 	call	0x10096	; 0x10096 <fgetc>
    f3a4:	ec 01       	movw	r28, r24
    f3a6:	97 fd       	sbrc	r25, 7
    f3a8:	08 c0       	rjmp	.+16     	; 0xf3ba <skip_spaces+0x26>
    f3aa:	0e 94 a2 7f 	call	0xff44	; 0xff44 <isspace>
    f3ae:	89 2b       	or	r24, r25
    f3b0:	b1 f7       	brne	.-20     	; 0xf39e <skip_spaces+0xa>
    f3b2:	ce 01       	movw	r24, r28
    f3b4:	b8 01       	movw	r22, r16
    f3b6:	0e 94 61 81 	call	0x102c2	; 0x102c2 <ungetc>
    f3ba:	ce 01       	movw	r24, r28
    f3bc:	df 91       	pop	r29
    f3be:	cf 91       	pop	r28
    f3c0:	1f 91       	pop	r17
    f3c2:	0f 91       	pop	r16
    f3c4:	08 95       	ret

0000f3c6 <conv_int>:
    f3c6:	8f 92       	push	r8
    f3c8:	9f 92       	push	r9
    f3ca:	af 92       	push	r10
    f3cc:	bf 92       	push	r11
    f3ce:	df 92       	push	r13
    f3d0:	ef 92       	push	r14
    f3d2:	ff 92       	push	r15
    f3d4:	0f 93       	push	r16
    f3d6:	1f 93       	push	r17
    f3d8:	cf 93       	push	r28
    f3da:	df 93       	push	r29
    f3dc:	5c 01       	movw	r10, r24
    f3de:	eb 01       	movw	r28, r22
    f3e0:	4a 01       	movw	r8, r20
    f3e2:	12 2f       	mov	r17, r18
    f3e4:	0e 94 4b 80 	call	0x10096	; 0x10096 <fgetc>
    f3e8:	ac 01       	movw	r20, r24
    f3ea:	8b 32       	cpi	r24, 0x2B	; 43
    f3ec:	19 f0       	breq	.+6      	; 0xf3f4 <conv_int+0x2e>
    f3ee:	8d 32       	cpi	r24, 0x2D	; 45
    f3f0:	51 f4       	brne	.+20     	; 0xf406 <conv_int+0x40>
    f3f2:	10 68       	ori	r17, 0x80	; 128
    f3f4:	21 97       	sbiw	r28, 0x01	; 1
    f3f6:	09 f4       	brne	.+2      	; 0xf3fa <conv_int+0x34>
    f3f8:	6d c0       	rjmp	.+218    	; 0xf4d4 <conv_int+0x10e>
    f3fa:	c5 01       	movw	r24, r10
    f3fc:	0e 94 4b 80 	call	0x10096	; 0x10096 <fgetc>
    f400:	ac 01       	movw	r20, r24
    f402:	97 fd       	sbrc	r25, 7
    f404:	67 c0       	rjmp	.+206    	; 0xf4d4 <conv_int+0x10e>
    f406:	6d ef       	ldi	r22, 0xFD	; 253
    f408:	d6 2e       	mov	r13, r22
    f40a:	d1 22       	and	r13, r17
    f40c:	8d 2d       	mov	r24, r13
    f40e:	80 73       	andi	r24, 0x30	; 48
    f410:	01 f5       	brne	.+64     	; 0xf452 <conv_int+0x8c>
    f412:	40 33       	cpi	r20, 0x30	; 48
    f414:	f1 f4       	brne	.+60     	; 0xf452 <conv_int+0x8c>
    f416:	21 97       	sbiw	r28, 0x01	; 1
    f418:	09 f4       	brne	.+2      	; 0xf41c <conv_int+0x56>
    f41a:	47 c0       	rjmp	.+142    	; 0xf4aa <conv_int+0xe4>
    f41c:	c5 01       	movw	r24, r10
    f41e:	0e 94 4b 80 	call	0x10096	; 0x10096 <fgetc>
    f422:	ac 01       	movw	r20, r24
    f424:	97 fd       	sbrc	r25, 7
    f426:	41 c0       	rjmp	.+130    	; 0xf4aa <conv_int+0xe4>
    f428:	82 e0       	ldi	r24, 0x02	; 2
    f42a:	d8 2a       	or	r13, r24
    f42c:	48 37       	cpi	r20, 0x78	; 120
    f42e:	11 f0       	breq	.+4      	; 0xf434 <conv_int+0x6e>
    f430:	48 35       	cpi	r20, 0x58	; 88
    f432:	59 f4       	brne	.+22     	; 0xf44a <conv_int+0x84>
    f434:	80 e4       	ldi	r24, 0x40	; 64
    f436:	d8 2a       	or	r13, r24
    f438:	21 97       	sbiw	r28, 0x01	; 1
    f43a:	b9 f1       	breq	.+110    	; 0xf4aa <conv_int+0xe4>
    f43c:	c5 01       	movw	r24, r10
    f43e:	0e 94 4b 80 	call	0x10096	; 0x10096 <fgetc>
    f442:	ac 01       	movw	r20, r24
    f444:	99 23       	and	r25, r25
    f446:	2c f4       	brge	.+10     	; 0xf452 <conv_int+0x8c>
    f448:	30 c0       	rjmp	.+96     	; 0xf4aa <conv_int+0xe4>
    f44a:	d6 fc       	sbrc	r13, 6
    f44c:	02 c0       	rjmp	.+4      	; 0xf452 <conv_int+0x8c>
    f44e:	80 e1       	ldi	r24, 0x10	; 16
    f450:	d8 2a       	or	r13, r24
    f452:	ee 24       	eor	r14, r14
    f454:	ff 24       	eor	r15, r15
    f456:	87 01       	movw	r16, r14
    f458:	24 2f       	mov	r18, r20
    f45a:	20 53       	subi	r18, 0x30	; 48
    f45c:	28 30       	cpi	r18, 0x08	; 8
    f45e:	88 f0       	brcs	.+34     	; 0xf482 <conv_int+0xbc>
    f460:	d4 fc       	sbrc	r13, 4
    f462:	09 c0       	rjmp	.+18     	; 0xf476 <conv_int+0xb0>
    f464:	2a 30       	cpi	r18, 0x0A	; 10
    f466:	68 f0       	brcs	.+26     	; 0xf482 <conv_int+0xbc>
    f468:	d6 fe       	sbrs	r13, 6
    f46a:	05 c0       	rjmp	.+10     	; 0xf476 <conv_int+0xb0>
    f46c:	2f 7d       	andi	r18, 0xDF	; 223
    f46e:	82 2f       	mov	r24, r18
    f470:	81 51       	subi	r24, 0x11	; 17
    f472:	86 30       	cpi	r24, 0x06	; 6
    f474:	28 f0       	brcs	.+10     	; 0xf480 <conv_int+0xba>
    f476:	ca 01       	movw	r24, r20
    f478:	b5 01       	movw	r22, r10
    f47a:	0e 94 61 81 	call	0x102c2	; 0x102c2 <ungetc>
    f47e:	12 c0       	rjmp	.+36     	; 0xf4a4 <conv_int+0xde>
    f480:	27 50       	subi	r18, 0x07	; 7
    f482:	c8 01       	movw	r24, r16
    f484:	b7 01       	movw	r22, r14
    f486:	4d 2d       	mov	r20, r13
    f488:	0e 94 9c 79 	call	0xf338	; 0xf338 <mulacc>
    f48c:	7b 01       	movw	r14, r22
    f48e:	8c 01       	movw	r16, r24
    f490:	82 e0       	ldi	r24, 0x02	; 2
    f492:	d8 2a       	or	r13, r24
    f494:	21 97       	sbiw	r28, 0x01	; 1
    f496:	61 f0       	breq	.+24     	; 0xf4b0 <conv_int+0xea>
    f498:	c5 01       	movw	r24, r10
    f49a:	0e 94 4b 80 	call	0x10096	; 0x10096 <fgetc>
    f49e:	ac 01       	movw	r20, r24
    f4a0:	97 ff       	sbrs	r25, 7
    f4a2:	da cf       	rjmp	.-76     	; 0xf458 <conv_int+0x92>
    f4a4:	d1 fc       	sbrc	r13, 1
    f4a6:	04 c0       	rjmp	.+8      	; 0xf4b0 <conv_int+0xea>
    f4a8:	15 c0       	rjmp	.+42     	; 0xf4d4 <conv_int+0x10e>
    f4aa:	ee 24       	eor	r14, r14
    f4ac:	ff 24       	eor	r15, r15
    f4ae:	87 01       	movw	r16, r14
    f4b0:	d7 fe       	sbrs	r13, 7
    f4b2:	08 c0       	rjmp	.+16     	; 0xf4c4 <conv_int+0xfe>
    f4b4:	10 95       	com	r17
    f4b6:	00 95       	com	r16
    f4b8:	f0 94       	com	r15
    f4ba:	e0 94       	com	r14
    f4bc:	e1 1c       	adc	r14, r1
    f4be:	f1 1c       	adc	r15, r1
    f4c0:	01 1d       	adc	r16, r1
    f4c2:	11 1d       	adc	r17, r1
    f4c4:	c4 01       	movw	r24, r8
    f4c6:	b8 01       	movw	r22, r16
    f4c8:	a7 01       	movw	r20, r14
    f4ca:	2d 2d       	mov	r18, r13
    f4cc:	0e 94 90 79 	call	0xf320	; 0xf320 <putval>
    f4d0:	81 e0       	ldi	r24, 0x01	; 1
    f4d2:	01 c0       	rjmp	.+2      	; 0xf4d6 <conv_int+0x110>
    f4d4:	80 e0       	ldi	r24, 0x00	; 0
    f4d6:	df 91       	pop	r29
    f4d8:	cf 91       	pop	r28
    f4da:	1f 91       	pop	r17
    f4dc:	0f 91       	pop	r16
    f4de:	ff 90       	pop	r15
    f4e0:	ef 90       	pop	r14
    f4e2:	df 90       	pop	r13
    f4e4:	bf 90       	pop	r11
    f4e6:	af 90       	pop	r10
    f4e8:	9f 90       	pop	r9
    f4ea:	8f 90       	pop	r8
    f4ec:	08 95       	ret

0000f4ee <conv_brk>:
    f4ee:	6f 92       	push	r6
    f4f0:	7f 92       	push	r7
    f4f2:	8f 92       	push	r8
    f4f4:	9f 92       	push	r9
    f4f6:	af 92       	push	r10
    f4f8:	bf 92       	push	r11
    f4fa:	cf 92       	push	r12
    f4fc:	df 92       	push	r13
    f4fe:	ef 92       	push	r14
    f500:	ff 92       	push	r15
    f502:	0f 93       	push	r16
    f504:	1f 93       	push	r17
    f506:	df 93       	push	r29
    f508:	cf 93       	push	r28
    f50a:	cd b7       	in	r28, 0x3d	; 61
    f50c:	de b7       	in	r29, 0x3e	; 62
    f50e:	a0 97       	sbiw	r28, 0x20	; 32
    f510:	0f b6       	in	r0, 0x3f	; 63
    f512:	f8 94       	cli
    f514:	de bf       	out	0x3e, r29	; 62
    f516:	0f be       	out	0x3f, r0	; 63
    f518:	cd bf       	out	0x3d, r28	; 61
    f51a:	5c 01       	movw	r10, r24
    f51c:	6b 01       	movw	r12, r22
    f51e:	8a 01       	movw	r16, r20
    f520:	79 01       	movw	r14, r18
    f522:	fe 01       	movw	r30, r28
    f524:	31 96       	adiw	r30, 0x01	; 1
    f526:	80 e2       	ldi	r24, 0x20	; 32
    f528:	df 01       	movw	r26, r30
    f52a:	1d 92       	st	X+, r1
    f52c:	8a 95       	dec	r24
    f52e:	e9 f7       	brne	.-6      	; 0xf52a <conv_brk+0x3c>
    f530:	70 e0       	ldi	r23, 0x00	; 0
    f532:	30 e0       	ldi	r19, 0x00	; 0
    f534:	60 e0       	ldi	r22, 0x00	; 0
    f536:	40 e0       	ldi	r20, 0x00	; 0
    f538:	50 e0       	ldi	r21, 0x00	; 0
    f53a:	3f 01       	movw	r6, r30
    f53c:	a1 e0       	ldi	r26, 0x01	; 1
    f53e:	b0 e0       	ldi	r27, 0x00	; 0
    f540:	f5 01       	movw	r30, r10
    f542:	83 81       	ldd	r24, Z+3	; 0x03
    f544:	f7 01       	movw	r30, r14
    f546:	83 fd       	sbrc	r24, 3
    f548:	25 91       	lpm	r18, Z+
    f54a:	83 ff       	sbrs	r24, 3
    f54c:	21 91       	ld	r18, Z+
    f54e:	7f 01       	movw	r14, r30
    f550:	22 23       	and	r18, r18
    f552:	09 f4       	brne	.+2      	; 0xf556 <conv_brk+0x68>
    f554:	81 c0       	rjmp	.+258    	; 0xf658 <conv_brk+0x16a>
    f556:	2e 35       	cpi	r18, 0x5E	; 94
    f558:	19 f4       	brne	.+6      	; 0xf560 <conv_brk+0x72>
    f55a:	41 15       	cp	r20, r1
    f55c:	51 05       	cpc	r21, r1
    f55e:	69 f1       	breq	.+90     	; 0xf5ba <conv_brk+0xcc>
    f560:	87 2f       	mov	r24, r23
    f562:	90 e0       	ldi	r25, 0x00	; 0
    f564:	84 17       	cp	r24, r20
    f566:	95 07       	cpc	r25, r21
    f568:	44 f4       	brge	.+16     	; 0xf57a <conv_brk+0x8c>
    f56a:	2d 35       	cpi	r18, 0x5D	; 93
    f56c:	51 f1       	breq	.+84     	; 0xf5c2 <conv_brk+0xd4>
    f56e:	2d 32       	cpi	r18, 0x2D	; 45
    f570:	21 f4       	brne	.+8      	; 0xf57a <conv_brk+0x8c>
    f572:	33 23       	and	r19, r19
    f574:	29 f4       	brne	.+10     	; 0xf580 <conv_brk+0x92>
    f576:	31 e0       	ldi	r19, 0x01	; 1
    f578:	21 c0       	rjmp	.+66     	; 0xf5bc <conv_brk+0xce>
    f57a:	33 23       	and	r19, r19
    f57c:	09 f4       	brne	.+2      	; 0xf580 <conv_brk+0x92>
    f57e:	62 2f       	mov	r22, r18
    f580:	32 2f       	mov	r19, r18
    f582:	83 2f       	mov	r24, r19
    f584:	86 95       	lsr	r24
    f586:	86 95       	lsr	r24
    f588:	86 95       	lsr	r24
    f58a:	f3 01       	movw	r30, r6
    f58c:	e8 0f       	add	r30, r24
    f58e:	f1 1d       	adc	r31, r1
    f590:	83 2f       	mov	r24, r19
    f592:	87 70       	andi	r24, 0x07	; 7
    f594:	4d 01       	movw	r8, r26
    f596:	02 c0       	rjmp	.+4      	; 0xf59c <conv_brk+0xae>
    f598:	88 0c       	add	r8, r8
    f59a:	99 1c       	adc	r9, r9
    f59c:	8a 95       	dec	r24
    f59e:	e2 f7       	brpl	.-8      	; 0xf598 <conv_brk+0xaa>
    f5a0:	20 81       	ld	r18, Z
    f5a2:	28 29       	or	r18, r8
    f5a4:	20 83       	st	Z, r18
    f5a6:	36 17       	cp	r19, r22
    f5a8:	11 f4       	brne	.+4      	; 0xf5ae <conv_brk+0xc0>
    f5aa:	30 e0       	ldi	r19, 0x00	; 0
    f5ac:	07 c0       	rjmp	.+14     	; 0xf5bc <conv_brk+0xce>
    f5ae:	36 17       	cp	r19, r22
    f5b0:	10 f4       	brcc	.+4      	; 0xf5b6 <conv_brk+0xc8>
    f5b2:	3f 5f       	subi	r19, 0xFF	; 255
    f5b4:	e6 cf       	rjmp	.-52     	; 0xf582 <conv_brk+0x94>
    f5b6:	31 50       	subi	r19, 0x01	; 1
    f5b8:	e4 cf       	rjmp	.-56     	; 0xf582 <conv_brk+0x94>
    f5ba:	71 e0       	ldi	r23, 0x01	; 1
    f5bc:	4f 5f       	subi	r20, 0xFF	; 255
    f5be:	5f 4f       	sbci	r21, 0xFF	; 255
    f5c0:	bf cf       	rjmp	.-130    	; 0xf540 <conv_brk+0x52>
    f5c2:	33 23       	and	r19, r19
    f5c4:	19 f0       	breq	.+6      	; 0xf5cc <conv_brk+0xde>
    f5c6:	8e 81       	ldd	r24, Y+6	; 0x06
    f5c8:	80 62       	ori	r24, 0x20	; 32
    f5ca:	8e 83       	std	Y+6, r24	; 0x06
    f5cc:	77 23       	and	r23, r23
    f5ce:	59 f0       	breq	.+22     	; 0xf5e6 <conv_brk+0xf8>
    f5d0:	fe 01       	movw	r30, r28
    f5d2:	31 96       	adiw	r30, 0x01	; 1
    f5d4:	9e 01       	movw	r18, r28
    f5d6:	2f 5d       	subi	r18, 0xDF	; 223
    f5d8:	3f 4f       	sbci	r19, 0xFF	; 255
    f5da:	80 81       	ld	r24, Z
    f5dc:	80 95       	com	r24
    f5de:	81 93       	st	Z+, r24
    f5e0:	e2 17       	cp	r30, r18
    f5e2:	f3 07       	cpc	r31, r19
    f5e4:	d1 f7       	brne	.-12     	; 0xf5da <conv_brk+0xec>
    f5e6:	99 24       	eor	r9, r9
    f5e8:	93 94       	inc	r9
    f5ea:	3e 01       	movw	r6, r28
    f5ec:	08 94       	sec
    f5ee:	61 1c       	adc	r6, r1
    f5f0:	71 1c       	adc	r7, r1
    f5f2:	c5 01       	movw	r24, r10
    f5f4:	0e 94 4b 80 	call	0x10096	; 0x10096 <fgetc>
    f5f8:	ac 01       	movw	r20, r24
    f5fa:	97 fd       	sbrc	r25, 7
    f5fc:	25 c0       	rjmp	.+74     	; 0xf648 <conv_brk+0x15a>
    f5fe:	86 95       	lsr	r24
    f600:	86 95       	lsr	r24
    f602:	86 95       	lsr	r24
    f604:	f3 01       	movw	r30, r6
    f606:	e8 0f       	add	r30, r24
    f608:	f1 1d       	adc	r31, r1
    f60a:	80 81       	ld	r24, Z
    f60c:	90 e0       	ldi	r25, 0x00	; 0
    f60e:	9a 01       	movw	r18, r20
    f610:	27 70       	andi	r18, 0x07	; 7
    f612:	30 70       	andi	r19, 0x00	; 0
    f614:	02 c0       	rjmp	.+4      	; 0xf61a <conv_brk+0x12c>
    f616:	95 95       	asr	r25
    f618:	87 95       	ror	r24
    f61a:	2a 95       	dec	r18
    f61c:	e2 f7       	brpl	.-8      	; 0xf616 <conv_brk+0x128>
    f61e:	80 fd       	sbrc	r24, 0
    f620:	05 c0       	rjmp	.+10     	; 0xf62c <conv_brk+0x13e>
    f622:	ca 01       	movw	r24, r20
    f624:	b5 01       	movw	r22, r10
    f626:	0e 94 61 81 	call	0x102c2	; 0x102c2 <ungetc>
    f62a:	0e c0       	rjmp	.+28     	; 0xf648 <conv_brk+0x15a>
    f62c:	01 15       	cp	r16, r1
    f62e:	11 05       	cpc	r17, r1
    f630:	19 f0       	breq	.+6      	; 0xf638 <conv_brk+0x14a>
    f632:	d8 01       	movw	r26, r16
    f634:	4d 93       	st	X+, r20
    f636:	8d 01       	movw	r16, r26
    f638:	08 94       	sec
    f63a:	c1 08       	sbc	r12, r1
    f63c:	d1 08       	sbc	r13, r1
    f63e:	99 24       	eor	r9, r9
    f640:	c1 14       	cp	r12, r1
    f642:	d1 04       	cpc	r13, r1
    f644:	b1 f6       	brne	.-84     	; 0xf5f2 <conv_brk+0x104>
    f646:	02 c0       	rjmp	.+4      	; 0xf64c <conv_brk+0x15e>
    f648:	99 20       	and	r9, r9
    f64a:	31 f4       	brne	.+12     	; 0xf658 <conv_brk+0x16a>
    f64c:	01 15       	cp	r16, r1
    f64e:	11 05       	cpc	r17, r1
    f650:	29 f0       	breq	.+10     	; 0xf65c <conv_brk+0x16e>
    f652:	f8 01       	movw	r30, r16
    f654:	10 82       	st	Z, r1
    f656:	02 c0       	rjmp	.+4      	; 0xf65c <conv_brk+0x16e>
    f658:	ee 24       	eor	r14, r14
    f65a:	ff 24       	eor	r15, r15
    f65c:	c7 01       	movw	r24, r14
    f65e:	a0 96       	adiw	r28, 0x20	; 32
    f660:	0f b6       	in	r0, 0x3f	; 63
    f662:	f8 94       	cli
    f664:	de bf       	out	0x3e, r29	; 62
    f666:	0f be       	out	0x3f, r0	; 63
    f668:	cd bf       	out	0x3d, r28	; 61
    f66a:	cf 91       	pop	r28
    f66c:	df 91       	pop	r29
    f66e:	1f 91       	pop	r17
    f670:	0f 91       	pop	r16
    f672:	ff 90       	pop	r15
    f674:	ef 90       	pop	r14
    f676:	df 90       	pop	r13
    f678:	cf 90       	pop	r12
    f67a:	bf 90       	pop	r11
    f67c:	af 90       	pop	r10
    f67e:	9f 90       	pop	r9
    f680:	8f 90       	pop	r8
    f682:	7f 90       	pop	r7
    f684:	6f 90       	pop	r6
    f686:	08 95       	ret

0000f688 <conv_flt>:
    f688:	2f 92       	push	r2
    f68a:	3f 92       	push	r3
    f68c:	5f 92       	push	r5
    f68e:	6f 92       	push	r6
    f690:	7f 92       	push	r7
    f692:	8f 92       	push	r8
    f694:	9f 92       	push	r9
    f696:	af 92       	push	r10
    f698:	bf 92       	push	r11
    f69a:	cf 92       	push	r12
    f69c:	df 92       	push	r13
    f69e:	ef 92       	push	r14
    f6a0:	ff 92       	push	r15
    f6a2:	0f 93       	push	r16
    f6a4:	1f 93       	push	r17
    f6a6:	cf 93       	push	r28
    f6a8:	df 93       	push	r29
    f6aa:	3c 01       	movw	r6, r24
    f6ac:	7b 01       	movw	r14, r22
    f6ae:	1a 01       	movw	r2, r20
    f6b0:	0e 94 4b 80 	call	0x10096	; 0x10096 <fgetc>
    f6b4:	ec 01       	movw	r28, r24
    f6b6:	8b 32       	cpi	r24, 0x2B	; 43
    f6b8:	39 f0       	breq	.+14     	; 0xf6c8 <conv_flt+0x40>
    f6ba:	8d 32       	cpi	r24, 0x2D	; 45
    f6bc:	11 f0       	breq	.+4      	; 0xf6c2 <conv_flt+0x3a>
    f6be:	55 24       	eor	r5, r5
    f6c0:	11 c0       	rjmp	.+34     	; 0xf6e4 <conv_flt+0x5c>
    f6c2:	b0 e8       	ldi	r27, 0x80	; 128
    f6c4:	5b 2e       	mov	r5, r27
    f6c6:	01 c0       	rjmp	.+2      	; 0xf6ca <conv_flt+0x42>
    f6c8:	55 24       	eor	r5, r5
    f6ca:	08 94       	sec
    f6cc:	e1 08       	sbc	r14, r1
    f6ce:	f1 08       	sbc	r15, r1
    f6d0:	e1 14       	cp	r14, r1
    f6d2:	f1 04       	cpc	r15, r1
    f6d4:	09 f4       	brne	.+2      	; 0xf6d8 <conv_flt+0x50>
    f6d6:	18 c1       	rjmp	.+560    	; 0xf908 <conv_flt+0x280>
    f6d8:	c3 01       	movw	r24, r6
    f6da:	0e 94 4b 80 	call	0x10096	; 0x10096 <fgetc>
    f6de:	ec 01       	movw	r28, r24
    f6e0:	97 fd       	sbrc	r25, 7
    f6e2:	12 c1       	rjmp	.+548    	; 0xf908 <conv_flt+0x280>
    f6e4:	ce 01       	movw	r24, r28
    f6e6:	0e 94 aa 7f 	call	0xff54	; 0xff54 <tolower>
    f6ea:	89 36       	cpi	r24, 0x69	; 105
    f6ec:	91 05       	cpc	r25, r1
    f6ee:	21 f0       	breq	.+8      	; 0xf6f8 <conv_flt+0x70>
    f6f0:	8e 36       	cpi	r24, 0x6E	; 110
    f6f2:	91 05       	cpc	r25, r1
    f6f4:	99 f5       	brne	.+102    	; 0xf75c <conv_flt+0xd4>
    f6f6:	1d c0       	rjmp	.+58     	; 0xf732 <conv_flt+0xaa>
    f6f8:	0b ee       	ldi	r16, 0xEB	; 235
    f6fa:	12 e0       	ldi	r17, 0x02	; 2
    f6fc:	1c c0       	rjmp	.+56     	; 0xf736 <conv_flt+0xae>
    f6fe:	08 94       	sec
    f700:	e1 08       	sbc	r14, r1
    f702:	f1 08       	sbc	r15, r1
    f704:	e1 14       	cp	r14, r1
    f706:	f1 04       	cpc	r15, r1
    f708:	71 f0       	breq	.+28     	; 0xf726 <conv_flt+0x9e>
    f70a:	c3 01       	movw	r24, r6
    f70c:	0e 94 4b 80 	call	0x10096	; 0x10096 <fgetc>
    f710:	ec 01       	movw	r28, r24
    f712:	97 fd       	sbrc	r25, 7
    f714:	08 c0       	rjmp	.+16     	; 0xf726 <conv_flt+0x9e>
    f716:	0e 94 aa 7f 	call	0xff54	; 0xff54 <tolower>
    f71a:	d8 16       	cp	r13, r24
    f71c:	61 f0       	breq	.+24     	; 0xf736 <conv_flt+0xae>
    f71e:	ce 01       	movw	r24, r28
    f720:	b3 01       	movw	r22, r6
    f722:	0e 94 61 81 	call	0x102c2	; 0x102c2 <ungetc>
    f726:	22 e0       	ldi	r18, 0x02	; 2
    f728:	0e 3e       	cpi	r16, 0xEE	; 238
    f72a:	12 07       	cpc	r17, r18
    f72c:	09 f0       	breq	.+2      	; 0xf730 <conv_flt+0xa8>
    f72e:	ec c0       	rjmp	.+472    	; 0xf908 <conv_flt+0x280>
    f730:	08 c0       	rjmp	.+16     	; 0xf742 <conv_flt+0xba>
    f732:	08 ee       	ldi	r16, 0xE8	; 232
    f734:	12 e0       	ldi	r17, 0x02	; 2
    f736:	f8 01       	movw	r30, r16
    f738:	0f 5f       	subi	r16, 0xFF	; 255
    f73a:	1f 4f       	sbci	r17, 0xFF	; 255
    f73c:	d4 90       	lpm	r13, Z+
    f73e:	dd 20       	and	r13, r13
    f740:	f1 f6       	brne	.-68     	; 0xf6fe <conv_flt+0x76>
    f742:	0b 5e       	subi	r16, 0xEB	; 235
    f744:	12 40       	sbci	r17, 0x02	; 2
    f746:	29 f0       	breq	.+10     	; 0xf752 <conv_flt+0xca>
    f748:	80 e0       	ldi	r24, 0x00	; 0
    f74a:	90 e0       	ldi	r25, 0x00	; 0
    f74c:	a0 e8       	ldi	r26, 0x80	; 128
    f74e:	bf e7       	ldi	r27, 0x7F	; 127
    f750:	cf c0       	rjmp	.+414    	; 0xf8f0 <conv_flt+0x268>
    f752:	80 e0       	ldi	r24, 0x00	; 0
    f754:	90 e0       	ldi	r25, 0x00	; 0
    f756:	a0 ec       	ldi	r26, 0xC0	; 192
    f758:	bf e7       	ldi	r27, 0x7F	; 127
    f75a:	ca c0       	rjmp	.+404    	; 0xf8f0 <conv_flt+0x268>
    f75c:	cc 24       	eor	r12, r12
    f75e:	dd 24       	eor	r13, r13
    f760:	88 24       	eor	r8, r8
    f762:	99 24       	eor	r9, r9
    f764:	54 01       	movw	r10, r8
    f766:	ae 01       	movw	r20, r28
    f768:	40 53       	subi	r20, 0x30	; 48
    f76a:	24 2f       	mov	r18, r20
    f76c:	4a 30       	cpi	r20, 0x0A	; 10
    f76e:	38 f5       	brcc	.+78     	; 0xf7be <conv_flt+0x136>
    f770:	52 e0       	ldi	r21, 0x02	; 2
    f772:	55 2a       	or	r5, r21
    f774:	85 2d       	mov	r24, r5
    f776:	90 e0       	ldi	r25, 0x00	; 0
    f778:	ac 01       	movw	r20, r24
    f77a:	48 70       	andi	r20, 0x08	; 8
    f77c:	50 70       	andi	r21, 0x00	; 0
    f77e:	52 fe       	sbrs	r5, 2
    f780:	06 c0       	rjmp	.+12     	; 0xf78e <conv_flt+0x106>
    f782:	45 2b       	or	r20, r21
    f784:	11 f5       	brne	.+68     	; 0xf7ca <conv_flt+0x142>
    f786:	08 94       	sec
    f788:	c1 1c       	adc	r12, r1
    f78a:	d1 1c       	adc	r13, r1
    f78c:	1e c0       	rjmp	.+60     	; 0xf7ca <conv_flt+0x142>
    f78e:	45 2b       	or	r20, r21
    f790:	19 f0       	breq	.+6      	; 0xf798 <conv_flt+0x110>
    f792:	08 94       	sec
    f794:	c1 08       	sbc	r12, r1
    f796:	d1 08       	sbc	r13, r1
    f798:	c5 01       	movw	r24, r10
    f79a:	b4 01       	movw	r22, r8
    f79c:	40 e2       	ldi	r20, 0x20	; 32
    f79e:	0e 94 9c 79 	call	0xf338	; 0xf338 <mulacc>
    f7a2:	4b 01       	movw	r8, r22
    f7a4:	5c 01       	movw	r10, r24
    f7a6:	88 e9       	ldi	r24, 0x98	; 152
    f7a8:	88 16       	cp	r8, r24
    f7aa:	89 e9       	ldi	r24, 0x99	; 153
    f7ac:	98 06       	cpc	r9, r24
    f7ae:	89 e9       	ldi	r24, 0x99	; 153
    f7b0:	a8 06       	cpc	r10, r24
    f7b2:	89 e1       	ldi	r24, 0x19	; 25
    f7b4:	b8 06       	cpc	r11, r24
    f7b6:	48 f0       	brcs	.+18     	; 0xf7ca <conv_flt+0x142>
    f7b8:	94 e0       	ldi	r25, 0x04	; 4
    f7ba:	59 2a       	or	r5, r25
    f7bc:	06 c0       	rjmp	.+12     	; 0xf7ca <conv_flt+0x142>
    f7be:	4e 3f       	cpi	r20, 0xFE	; 254
    f7c0:	81 f4       	brne	.+32     	; 0xf7e2 <conv_flt+0x15a>
    f7c2:	53 fc       	sbrc	r5, 3
    f7c4:	0e c0       	rjmp	.+28     	; 0xf7e2 <conv_flt+0x15a>
    f7c6:	e8 e0       	ldi	r30, 0x08	; 8
    f7c8:	5e 2a       	or	r5, r30
    f7ca:	08 94       	sec
    f7cc:	e1 08       	sbc	r14, r1
    f7ce:	f1 08       	sbc	r15, r1
    f7d0:	e1 14       	cp	r14, r1
    f7d2:	f1 04       	cpc	r15, r1
    f7d4:	31 f0       	breq	.+12     	; 0xf7e2 <conv_flt+0x15a>
    f7d6:	c3 01       	movw	r24, r6
    f7d8:	0e 94 4b 80 	call	0x10096	; 0x10096 <fgetc>
    f7dc:	ec 01       	movw	r28, r24
    f7de:	97 ff       	sbrs	r25, 7
    f7e0:	c2 cf       	rjmp	.-124    	; 0xf766 <conv_flt+0xde>
    f7e2:	51 fe       	sbrs	r5, 1
    f7e4:	91 c0       	rjmp	.+290    	; 0xf908 <conv_flt+0x280>
    f7e6:	c5 36       	cpi	r28, 0x65	; 101
    f7e8:	19 f0       	breq	.+6      	; 0xf7f0 <conv_flt+0x168>
    f7ea:	c5 34       	cpi	r28, 0x45	; 69
    f7ec:	09 f0       	breq	.+2      	; 0xf7f0 <conv_flt+0x168>
    f7ee:	46 c0       	rjmp	.+140    	; 0xf87c <conv_flt+0x1f4>
    f7f0:	08 94       	sec
    f7f2:	e1 08       	sbc	r14, r1
    f7f4:	f1 08       	sbc	r15, r1
    f7f6:	e1 14       	cp	r14, r1
    f7f8:	f1 04       	cpc	r15, r1
    f7fa:	09 f4       	brne	.+2      	; 0xf7fe <conv_flt+0x176>
    f7fc:	85 c0       	rjmp	.+266    	; 0xf908 <conv_flt+0x280>
    f7fe:	c3 01       	movw	r24, r6
    f800:	0e 94 4b 80 	call	0x10096	; 0x10096 <fgetc>
    f804:	ec 01       	movw	r28, r24
    f806:	97 fd       	sbrc	r25, 7
    f808:	7f c0       	rjmp	.+254    	; 0xf908 <conv_flt+0x280>
    f80a:	8b 32       	cpi	r24, 0x2B	; 43
    f80c:	21 f0       	breq	.+8      	; 0xf816 <conv_flt+0x18e>
    f80e:	8d 32       	cpi	r24, 0x2D	; 45
    f810:	69 f4       	brne	.+26     	; 0xf82c <conv_flt+0x1a4>
    f812:	f0 e1       	ldi	r31, 0x10	; 16
    f814:	5f 2a       	or	r5, r31
    f816:	08 94       	sec
    f818:	e1 08       	sbc	r14, r1
    f81a:	f1 08       	sbc	r15, r1
    f81c:	e1 14       	cp	r14, r1
    f81e:	f1 04       	cpc	r15, r1
    f820:	09 f4       	brne	.+2      	; 0xf824 <conv_flt+0x19c>
    f822:	72 c0       	rjmp	.+228    	; 0xf908 <conv_flt+0x280>
    f824:	c3 01       	movw	r24, r6
    f826:	0e 94 4b 80 	call	0x10096	; 0x10096 <fgetc>
    f82a:	ec 01       	movw	r28, r24
    f82c:	ce 01       	movw	r24, r28
    f82e:	c0 97       	sbiw	r24, 0x30	; 48
    f830:	0a 97       	sbiw	r24, 0x0a	; 10
    f832:	08 f0       	brcs	.+2      	; 0xf836 <conv_flt+0x1ae>
    f834:	69 c0       	rjmp	.+210    	; 0xf908 <conv_flt+0x280>
    f836:	00 e0       	ldi	r16, 0x00	; 0
    f838:	10 e0       	ldi	r17, 0x00	; 0
    f83a:	b8 01       	movw	r22, r16
    f83c:	88 27       	eor	r24, r24
    f83e:	77 fd       	sbrc	r23, 7
    f840:	80 95       	com	r24
    f842:	98 2f       	mov	r25, r24
    f844:	ae 01       	movw	r20, r28
    f846:	40 53       	subi	r20, 0x30	; 48
    f848:	24 2f       	mov	r18, r20
    f84a:	40 e2       	ldi	r20, 0x20	; 32
    f84c:	0e 94 9c 79 	call	0xf338	; 0xf338 <mulacc>
    f850:	8b 01       	movw	r16, r22
    f852:	08 94       	sec
    f854:	e1 08       	sbc	r14, r1
    f856:	f1 08       	sbc	r15, r1
    f858:	e1 14       	cp	r14, r1
    f85a:	f1 04       	cpc	r15, r1
    f85c:	39 f0       	breq	.+14     	; 0xf86c <conv_flt+0x1e4>
    f85e:	c3 01       	movw	r24, r6
    f860:	0e 94 4b 80 	call	0x10096	; 0x10096 <fgetc>
    f864:	ec 01       	movw	r28, r24
    f866:	c0 97       	sbiw	r24, 0x30	; 48
    f868:	0a 97       	sbiw	r24, 0x0a	; 10
    f86a:	38 f3       	brcs	.-50     	; 0xf83a <conv_flt+0x1b2>
    f86c:	b8 01       	movw	r22, r16
    f86e:	54 fe       	sbrs	r5, 4
    f870:	03 c0       	rjmp	.+6      	; 0xf878 <conv_flt+0x1f0>
    f872:	70 95       	com	r23
    f874:	61 95       	neg	r22
    f876:	7f 4f       	sbci	r23, 0xFF	; 255
    f878:	c6 0e       	add	r12, r22
    f87a:	d7 1e       	adc	r13, r23
    f87c:	ef 28       	or	r14, r15
    f87e:	31 f0       	breq	.+12     	; 0xf88c <conv_flt+0x204>
    f880:	d7 fd       	sbrc	r29, 7
    f882:	04 c0       	rjmp	.+8      	; 0xf88c <conv_flt+0x204>
    f884:	ce 01       	movw	r24, r28
    f886:	b3 01       	movw	r22, r6
    f888:	0e 94 61 81 	call	0x102c2	; 0x102c2 <ungetc>
    f88c:	c5 01       	movw	r24, r10
    f88e:	b4 01       	movw	r22, r8
    f890:	0e 94 d6 7d 	call	0xfbac	; 0xfbac <__floatunsisf>
    f894:	d7 fe       	sbrs	r13, 7
    f896:	0d c0       	rjmp	.+26     	; 0xf8b2 <conv_flt+0x22a>
    f898:	a7 e0       	ldi	r26, 0x07	; 7
    f89a:	ea 2e       	mov	r14, r26
    f89c:	a3 e0       	ldi	r26, 0x03	; 3
    f89e:	fa 2e       	mov	r15, r26
    f8a0:	d0 94       	com	r13
    f8a2:	c1 94       	neg	r12
    f8a4:	d1 08       	sbc	r13, r1
    f8a6:	d3 94       	inc	r13
    f8a8:	c0 e2       	ldi	r28, 0x20	; 32
    f8aa:	d0 e0       	ldi	r29, 0x00	; 0
    f8ac:	00 e0       	ldi	r16, 0x00	; 0
    f8ae:	10 e0       	ldi	r17, 0x00	; 0
    f8b0:	0e c0       	rjmp	.+28     	; 0xf8ce <conv_flt+0x246>
    f8b2:	ff e1       	ldi	r31, 0x1F	; 31
    f8b4:	ef 2e       	mov	r14, r31
    f8b6:	f3 e0       	ldi	r31, 0x03	; 3
    f8b8:	ff 2e       	mov	r15, r31
    f8ba:	f6 cf       	rjmp	.-20     	; 0xf8a8 <conv_flt+0x220>
    f8bc:	f7 01       	movw	r30, r14
    f8be:	25 91       	lpm	r18, Z+
    f8c0:	35 91       	lpm	r19, Z+
    f8c2:	45 91       	lpm	r20, Z+
    f8c4:	54 91       	lpm	r21, Z+
    f8c6:	0e 94 13 7e 	call	0xfc26	; 0xfc26 <__mulsf3>
    f8ca:	cc 1a       	sub	r12, r28
    f8cc:	dd 0a       	sbc	r13, r29
    f8ce:	cc 16       	cp	r12, r28
    f8d0:	dd 06       	cpc	r13, r29
    f8d2:	a0 f7       	brcc	.-24     	; 0xf8bc <conv_flt+0x234>
    f8d4:	d6 95       	lsr	r29
    f8d6:	c7 95       	ror	r28
    f8d8:	0f 5f       	subi	r16, 0xFF	; 255
    f8da:	1f 4f       	sbci	r17, 0xFF	; 255
    f8dc:	06 30       	cpi	r16, 0x06	; 6
    f8de:	11 05       	cpc	r17, r1
    f8e0:	29 f0       	breq	.+10     	; 0xf8ec <conv_flt+0x264>
    f8e2:	ec ef       	ldi	r30, 0xFC	; 252
    f8e4:	ff ef       	ldi	r31, 0xFF	; 255
    f8e6:	ee 0e       	add	r14, r30
    f8e8:	ff 1e       	adc	r15, r31
    f8ea:	f1 cf       	rjmp	.-30     	; 0xf8ce <conv_flt+0x246>
    f8ec:	dc 01       	movw	r26, r24
    f8ee:	cb 01       	movw	r24, r22
    f8f0:	57 fc       	sbrc	r5, 7
    f8f2:	b0 58       	subi	r27, 0x80	; 128
    f8f4:	21 14       	cp	r2, r1
    f8f6:	31 04       	cpc	r3, r1
    f8f8:	29 f0       	breq	.+10     	; 0xf904 <conv_flt+0x27c>
    f8fa:	f1 01       	movw	r30, r2
    f8fc:	80 83       	st	Z, r24
    f8fe:	91 83       	std	Z+1, r25	; 0x01
    f900:	a2 83       	std	Z+2, r26	; 0x02
    f902:	b3 83       	std	Z+3, r27	; 0x03
    f904:	81 e0       	ldi	r24, 0x01	; 1
    f906:	01 c0       	rjmp	.+2      	; 0xf90a <conv_flt+0x282>
    f908:	80 e0       	ldi	r24, 0x00	; 0
    f90a:	df 91       	pop	r29
    f90c:	cf 91       	pop	r28
    f90e:	1f 91       	pop	r17
    f910:	0f 91       	pop	r16
    f912:	ff 90       	pop	r15
    f914:	ef 90       	pop	r14
    f916:	df 90       	pop	r13
    f918:	cf 90       	pop	r12
    f91a:	bf 90       	pop	r11
    f91c:	af 90       	pop	r10
    f91e:	9f 90       	pop	r9
    f920:	8f 90       	pop	r8
    f922:	7f 90       	pop	r7
    f924:	6f 90       	pop	r6
    f926:	5f 90       	pop	r5
    f928:	3f 90       	pop	r3
    f92a:	2f 90       	pop	r2
    f92c:	08 95       	ret

0000f92e <vfscanf>:
    f92e:	5f 92       	push	r5
    f930:	6f 92       	push	r6
    f932:	7f 92       	push	r7
    f934:	8f 92       	push	r8
    f936:	9f 92       	push	r9
    f938:	af 92       	push	r10
    f93a:	bf 92       	push	r11
    f93c:	cf 92       	push	r12
    f93e:	df 92       	push	r13
    f940:	ef 92       	push	r14
    f942:	ff 92       	push	r15
    f944:	0f 93       	push	r16
    f946:	1f 93       	push	r17
    f948:	cf 93       	push	r28
    f94a:	df 93       	push	r29
    f94c:	4c 01       	movw	r8, r24
    f94e:	5b 01       	movw	r10, r22
    f950:	3a 01       	movw	r6, r20
    f952:	fc 01       	movw	r30, r24
    f954:	17 82       	std	Z+7, r1	; 0x07
    f956:	16 82       	std	Z+6, r1	; 0x06
    f958:	55 24       	eor	r5, r5
    f95a:	04 c1       	rjmp	.+520    	; 0xfb64 <vfscanf+0x236>
    f95c:	81 2f       	mov	r24, r17
    f95e:	90 e0       	ldi	r25, 0x00	; 0
    f960:	0e 94 a2 7f 	call	0xff44	; 0xff44 <isspace>
    f964:	89 2b       	or	r24, r25
    f966:	21 f0       	breq	.+8      	; 0xf970 <vfscanf+0x42>
    f968:	c4 01       	movw	r24, r8
    f96a:	0e 94 ca 79 	call	0xf394	; 0xf394 <skip_spaces>
    f96e:	fa c0       	rjmp	.+500    	; 0xfb64 <vfscanf+0x236>
    f970:	15 32       	cpi	r17, 0x25	; 37
    f972:	49 f4       	brne	.+18     	; 0xf986 <vfscanf+0x58>
    f974:	f5 01       	movw	r30, r10
    f976:	f3 fc       	sbrc	r15, 3
    f978:	65 91       	lpm	r22, Z+
    f97a:	f3 fe       	sbrs	r15, 3
    f97c:	61 91       	ld	r22, Z+
    f97e:	5f 01       	movw	r10, r30
    f980:	65 32       	cpi	r22, 0x25	; 37
    f982:	69 f4       	brne	.+26     	; 0xf99e <vfscanf+0x70>
    f984:	15 e2       	ldi	r17, 0x25	; 37
    f986:	c4 01       	movw	r24, r8
    f988:	0e 94 4b 80 	call	0x10096	; 0x10096 <fgetc>
    f98c:	97 fd       	sbrc	r25, 7
    f98e:	f6 c0       	rjmp	.+492    	; 0xfb7c <vfscanf+0x24e>
    f990:	18 17       	cp	r17, r24
    f992:	09 f4       	brne	.+2      	; 0xf996 <vfscanf+0x68>
    f994:	e7 c0       	rjmp	.+462    	; 0xfb64 <vfscanf+0x236>
    f996:	b4 01       	movw	r22, r8
    f998:	0e 94 61 81 	call	0x102c2	; 0x102c2 <ungetc>
    f99c:	f4 c0       	rjmp	.+488    	; 0xfb86 <vfscanf+0x258>
    f99e:	6a 32       	cpi	r22, 0x2A	; 42
    f9a0:	19 f0       	breq	.+6      	; 0xf9a8 <vfscanf+0x7a>
    f9a2:	16 2f       	mov	r17, r22
    f9a4:	00 e0       	ldi	r16, 0x00	; 0
    f9a6:	06 c0       	rjmp	.+12     	; 0xf9b4 <vfscanf+0x86>
    f9a8:	f3 fc       	sbrc	r15, 3
    f9aa:	15 91       	lpm	r17, Z+
    f9ac:	f3 fe       	sbrs	r15, 3
    f9ae:	11 91       	ld	r17, Z+
    f9b0:	5f 01       	movw	r10, r30
    f9b2:	01 e0       	ldi	r16, 0x01	; 1
    f9b4:	cc 24       	eor	r12, r12
    f9b6:	dd 24       	eor	r13, r13
    f9b8:	0e c0       	rjmp	.+28     	; 0xf9d6 <vfscanf+0xa8>
    f9ba:	02 60       	ori	r16, 0x02	; 2
    f9bc:	b6 01       	movw	r22, r12
    f9be:	80 e0       	ldi	r24, 0x00	; 0
    f9c0:	90 e0       	ldi	r25, 0x00	; 0
    f9c2:	40 e2       	ldi	r20, 0x20	; 32
    f9c4:	0e 94 9c 79 	call	0xf338	; 0xf338 <mulacc>
    f9c8:	6b 01       	movw	r12, r22
    f9ca:	f5 01       	movw	r30, r10
    f9cc:	f3 fc       	sbrc	r15, 3
    f9ce:	15 91       	lpm	r17, Z+
    f9d0:	f3 fe       	sbrs	r15, 3
    f9d2:	11 91       	ld	r17, Z+
    f9d4:	5f 01       	movw	r10, r30
    f9d6:	21 2f       	mov	r18, r17
    f9d8:	20 53       	subi	r18, 0x30	; 48
    f9da:	2a 30       	cpi	r18, 0x0A	; 10
    f9dc:	70 f3       	brcs	.-36     	; 0xf9ba <vfscanf+0x8c>
    f9de:	01 fd       	sbrc	r16, 1
    f9e0:	04 c0       	rjmp	.+8      	; 0xf9ea <vfscanf+0xbc>
    f9e2:	cc 24       	eor	r12, r12
    f9e4:	ca 94       	dec	r12
    f9e6:	dc 2c       	mov	r13, r12
    f9e8:	04 c0       	rjmp	.+8      	; 0xf9f2 <vfscanf+0xc4>
    f9ea:	c1 14       	cp	r12, r1
    f9ec:	d1 04       	cpc	r13, r1
    f9ee:	09 f4       	brne	.+2      	; 0xf9f2 <vfscanf+0xc4>
    f9f0:	ca c0       	rjmp	.+404    	; 0xfb86 <vfscanf+0x258>
    f9f2:	18 36       	cpi	r17, 0x68	; 104
    f9f4:	21 f0       	breq	.+8      	; 0xf9fe <vfscanf+0xd0>
    f9f6:	1c 36       	cpi	r17, 0x6C	; 108
    f9f8:	99 f4       	brne	.+38     	; 0xfa20 <vfscanf+0xf2>
    f9fa:	f5 01       	movw	r30, r10
    f9fc:	0b c0       	rjmp	.+22     	; 0xfa14 <vfscanf+0xe6>
    f9fe:	f5 01       	movw	r30, r10
    fa00:	f3 fc       	sbrc	r15, 3
    fa02:	65 91       	lpm	r22, Z+
    fa04:	f3 fe       	sbrs	r15, 3
    fa06:	61 91       	ld	r22, Z+
    fa08:	68 36       	cpi	r22, 0x68	; 104
    fa0a:	19 f0       	breq	.+6      	; 0xfa12 <vfscanf+0xe4>
    fa0c:	5f 01       	movw	r10, r30
    fa0e:	16 2f       	mov	r17, r22
    fa10:	07 c0       	rjmp	.+14     	; 0xfa20 <vfscanf+0xf2>
    fa12:	08 60       	ori	r16, 0x08	; 8
    fa14:	04 60       	ori	r16, 0x04	; 4
    fa16:	f3 fc       	sbrc	r15, 3
    fa18:	15 91       	lpm	r17, Z+
    fa1a:	f3 fe       	sbrs	r15, 3
    fa1c:	11 91       	ld	r17, Z+
    fa1e:	5f 01       	movw	r10, r30
    fa20:	11 23       	and	r17, r17
    fa22:	09 f4       	brne	.+2      	; 0xfa26 <vfscanf+0xf8>
    fa24:	b0 c0       	rjmp	.+352    	; 0xfb86 <vfscanf+0x258>
    fa26:	86 ed       	ldi	r24, 0xD6	; 214
    fa28:	92 e0       	ldi	r25, 0x02	; 2
    fa2a:	61 2f       	mov	r22, r17
    fa2c:	70 e0       	ldi	r23, 0x00	; 0
    fa2e:	0e 94 b2 7f 	call	0xff64	; 0xff64 <strchr_P>
    fa32:	89 2b       	or	r24, r25
    fa34:	09 f4       	brne	.+2      	; 0xfa38 <vfscanf+0x10a>
    fa36:	a7 c0       	rjmp	.+334    	; 0xfb86 <vfscanf+0x258>
    fa38:	80 2f       	mov	r24, r16
    fa3a:	00 ff       	sbrs	r16, 0
    fa3c:	03 c0       	rjmp	.+6      	; 0xfa44 <vfscanf+0x116>
    fa3e:	ee 24       	eor	r14, r14
    fa40:	ff 24       	eor	r15, r15
    fa42:	07 c0       	rjmp	.+14     	; 0xfa52 <vfscanf+0x124>
    fa44:	f3 01       	movw	r30, r6
    fa46:	e0 80       	ld	r14, Z
    fa48:	f1 80       	ldd	r15, Z+1	; 0x01
    fa4a:	22 e0       	ldi	r18, 0x02	; 2
    fa4c:	30 e0       	ldi	r19, 0x00	; 0
    fa4e:	62 0e       	add	r6, r18
    fa50:	73 1e       	adc	r7, r19
    fa52:	1e 36       	cpi	r17, 0x6E	; 110
    fa54:	51 f4       	brne	.+20     	; 0xfa6a <vfscanf+0x13c>
    fa56:	f4 01       	movw	r30, r8
    fa58:	46 81       	ldd	r20, Z+6	; 0x06
    fa5a:	57 81       	ldd	r21, Z+7	; 0x07
    fa5c:	60 e0       	ldi	r22, 0x00	; 0
    fa5e:	70 e0       	ldi	r23, 0x00	; 0
    fa60:	c7 01       	movw	r24, r14
    fa62:	20 2f       	mov	r18, r16
    fa64:	0e 94 90 79 	call	0xf320	; 0xf320 <putval>
    fa68:	7d c0       	rjmp	.+250    	; 0xfb64 <vfscanf+0x236>
    fa6a:	13 36       	cpi	r17, 0x63	; 99
    fa6c:	b9 f4       	brne	.+46     	; 0xfa9c <vfscanf+0x16e>
    fa6e:	81 fd       	sbrc	r24, 1
    fa70:	03 c0       	rjmp	.+6      	; 0xfa78 <vfscanf+0x14a>
    fa72:	11 e0       	ldi	r17, 0x01	; 1
    fa74:	c1 2e       	mov	r12, r17
    fa76:	d1 2c       	mov	r13, r1
    fa78:	c4 01       	movw	r24, r8
    fa7a:	0e 94 4b 80 	call	0x10096	; 0x10096 <fgetc>
    fa7e:	97 fd       	sbrc	r25, 7
    fa80:	7d c0       	rjmp	.+250    	; 0xfb7c <vfscanf+0x24e>
    fa82:	e1 14       	cp	r14, r1
    fa84:	f1 04       	cpc	r15, r1
    fa86:	19 f0       	breq	.+6      	; 0xfa8e <vfscanf+0x160>
    fa88:	f7 01       	movw	r30, r14
    fa8a:	81 93       	st	Z+, r24
    fa8c:	7f 01       	movw	r14, r30
    fa8e:	08 94       	sec
    fa90:	c1 08       	sbc	r12, r1
    fa92:	d1 08       	sbc	r13, r1
    fa94:	c1 14       	cp	r12, r1
    fa96:	d1 04       	cpc	r13, r1
    fa98:	79 f7       	brne	.-34     	; 0xfa78 <vfscanf+0x14a>
    fa9a:	62 c0       	rjmp	.+196    	; 0xfb60 <vfscanf+0x232>
    fa9c:	1b 35       	cpi	r17, 0x5B	; 91
    fa9e:	59 f4       	brne	.+22     	; 0xfab6 <vfscanf+0x188>
    faa0:	c4 01       	movw	r24, r8
    faa2:	b6 01       	movw	r22, r12
    faa4:	a7 01       	movw	r20, r14
    faa6:	95 01       	movw	r18, r10
    faa8:	0e 94 77 7a 	call	0xf4ee	; 0xf4ee <conv_brk>
    faac:	5c 01       	movw	r10, r24
    faae:	00 97       	sbiw	r24, 0x00	; 0
    fab0:	09 f0       	breq	.+2      	; 0xfab4 <vfscanf+0x186>
    fab2:	56 c0       	rjmp	.+172    	; 0xfb60 <vfscanf+0x232>
    fab4:	50 c0       	rjmp	.+160    	; 0xfb56 <vfscanf+0x228>
    fab6:	c4 01       	movw	r24, r8
    fab8:	0e 94 ca 79 	call	0xf394	; 0xf394 <skip_spaces>
    fabc:	97 fd       	sbrc	r25, 7
    fabe:	5e c0       	rjmp	.+188    	; 0xfb7c <vfscanf+0x24e>
    fac0:	1f 36       	cpi	r17, 0x6F	; 111
    fac2:	d1 f1       	breq	.+116    	; 0xfb38 <vfscanf+0x20a>
    fac4:	10 37       	cpi	r17, 0x70	; 112
    fac6:	38 f4       	brcc	.+14     	; 0xfad6 <vfscanf+0x1a8>
    fac8:	14 36       	cpi	r17, 0x64	; 100
    faca:	a1 f1       	breq	.+104    	; 0xfb34 <vfscanf+0x206>
    facc:	19 36       	cpi	r17, 0x69	; 105
    face:	a9 f1       	breq	.+106    	; 0xfb3a <vfscanf+0x20c>
    fad0:	18 35       	cpi	r17, 0x58	; 88
    fad2:	d1 f5       	brne	.+116    	; 0xfb48 <vfscanf+0x21a>
    fad4:	2d c0       	rjmp	.+90     	; 0xfb30 <vfscanf+0x202>
    fad6:	13 37       	cpi	r17, 0x73	; 115
    fad8:	51 f0       	breq	.+20     	; 0xfaee <vfscanf+0x1c0>
    fada:	14 37       	cpi	r17, 0x74	; 116
    fadc:	18 f4       	brcc	.+6      	; 0xfae4 <vfscanf+0x1b6>
    fade:	10 37       	cpi	r17, 0x70	; 112
    fae0:	99 f5       	brne	.+102    	; 0xfb48 <vfscanf+0x21a>
    fae2:	26 c0       	rjmp	.+76     	; 0xfb30 <vfscanf+0x202>
    fae4:	15 37       	cpi	r17, 0x75	; 117
    fae6:	31 f1       	breq	.+76     	; 0xfb34 <vfscanf+0x206>
    fae8:	18 37       	cpi	r17, 0x78	; 120
    faea:	71 f5       	brne	.+92     	; 0xfb48 <vfscanf+0x21a>
    faec:	21 c0       	rjmp	.+66     	; 0xfb30 <vfscanf+0x202>
    faee:	c4 01       	movw	r24, r8
    faf0:	0e 94 4b 80 	call	0x10096	; 0x10096 <fgetc>
    faf4:	ec 01       	movw	r28, r24
    faf6:	97 fd       	sbrc	r25, 7
    faf8:	15 c0       	rjmp	.+42     	; 0xfb24 <vfscanf+0x1f6>
    fafa:	0e 94 a2 7f 	call	0xff44	; 0xff44 <isspace>
    fafe:	89 2b       	or	r24, r25
    fb00:	29 f0       	breq	.+10     	; 0xfb0c <vfscanf+0x1de>
    fb02:	ce 01       	movw	r24, r28
    fb04:	b4 01       	movw	r22, r8
    fb06:	0e 94 61 81 	call	0x102c2	; 0x102c2 <ungetc>
    fb0a:	0c c0       	rjmp	.+24     	; 0xfb24 <vfscanf+0x1f6>
    fb0c:	e1 14       	cp	r14, r1
    fb0e:	f1 04       	cpc	r15, r1
    fb10:	19 f0       	breq	.+6      	; 0xfb18 <vfscanf+0x1ea>
    fb12:	f7 01       	movw	r30, r14
    fb14:	c1 93       	st	Z+, r28
    fb16:	7f 01       	movw	r14, r30
    fb18:	08 94       	sec
    fb1a:	c1 08       	sbc	r12, r1
    fb1c:	d1 08       	sbc	r13, r1
    fb1e:	c1 14       	cp	r12, r1
    fb20:	d1 04       	cpc	r13, r1
    fb22:	29 f7       	brne	.-54     	; 0xfaee <vfscanf+0x1c0>
    fb24:	e1 14       	cp	r14, r1
    fb26:	f1 04       	cpc	r15, r1
    fb28:	d9 f0       	breq	.+54     	; 0xfb60 <vfscanf+0x232>
    fb2a:	f7 01       	movw	r30, r14
    fb2c:	10 82       	st	Z, r1
    fb2e:	18 c0       	rjmp	.+48     	; 0xfb60 <vfscanf+0x232>
    fb30:	00 64       	ori	r16, 0x40	; 64
    fb32:	03 c0       	rjmp	.+6      	; 0xfb3a <vfscanf+0x20c>
    fb34:	00 62       	ori	r16, 0x20	; 32
    fb36:	01 c0       	rjmp	.+2      	; 0xfb3a <vfscanf+0x20c>
    fb38:	00 61       	ori	r16, 0x10	; 16
    fb3a:	c4 01       	movw	r24, r8
    fb3c:	b6 01       	movw	r22, r12
    fb3e:	a7 01       	movw	r20, r14
    fb40:	20 2f       	mov	r18, r16
    fb42:	0e 94 e3 79 	call	0xf3c6	; 0xf3c6 <conv_int>
    fb46:	05 c0       	rjmp	.+10     	; 0xfb52 <vfscanf+0x224>
    fb48:	c4 01       	movw	r24, r8
    fb4a:	b6 01       	movw	r22, r12
    fb4c:	a7 01       	movw	r20, r14
    fb4e:	0e 94 44 7b 	call	0xf688	; 0xf688 <conv_flt>
    fb52:	88 23       	and	r24, r24
    fb54:	29 f4       	brne	.+10     	; 0xfb60 <vfscanf+0x232>
    fb56:	f4 01       	movw	r30, r8
    fb58:	83 81       	ldd	r24, Z+3	; 0x03
    fb5a:	80 73       	andi	r24, 0x30	; 48
    fb5c:	79 f4       	brne	.+30     	; 0xfb7c <vfscanf+0x24e>
    fb5e:	13 c0       	rjmp	.+38     	; 0xfb86 <vfscanf+0x258>
    fb60:	00 ff       	sbrs	r16, 0
    fb62:	53 94       	inc	r5
    fb64:	f4 01       	movw	r30, r8
    fb66:	f3 80       	ldd	r15, Z+3	; 0x03
    fb68:	f5 01       	movw	r30, r10
    fb6a:	f3 fc       	sbrc	r15, 3
    fb6c:	15 91       	lpm	r17, Z+
    fb6e:	f3 fe       	sbrs	r15, 3
    fb70:	11 91       	ld	r17, Z+
    fb72:	5f 01       	movw	r10, r30
    fb74:	11 23       	and	r17, r17
    fb76:	09 f0       	breq	.+2      	; 0xfb7a <vfscanf+0x24c>
    fb78:	f1 ce       	rjmp	.-542    	; 0xf95c <vfscanf+0x2e>
    fb7a:	05 c0       	rjmp	.+10     	; 0xfb86 <vfscanf+0x258>
    fb7c:	55 20       	and	r5, r5
    fb7e:	19 f4       	brne	.+6      	; 0xfb86 <vfscanf+0x258>
    fb80:	2f ef       	ldi	r18, 0xFF	; 255
    fb82:	3f ef       	ldi	r19, 0xFF	; 255
    fb84:	02 c0       	rjmp	.+4      	; 0xfb8a <vfscanf+0x25c>
    fb86:	25 2d       	mov	r18, r5
    fb88:	30 e0       	ldi	r19, 0x00	; 0
    fb8a:	c9 01       	movw	r24, r18
    fb8c:	df 91       	pop	r29
    fb8e:	cf 91       	pop	r28
    fb90:	1f 91       	pop	r17
    fb92:	0f 91       	pop	r16
    fb94:	ff 90       	pop	r15
    fb96:	ef 90       	pop	r14
    fb98:	df 90       	pop	r13
    fb9a:	cf 90       	pop	r12
    fb9c:	bf 90       	pop	r11
    fb9e:	af 90       	pop	r10
    fba0:	9f 90       	pop	r9
    fba2:	8f 90       	pop	r8
    fba4:	7f 90       	pop	r7
    fba6:	6f 90       	pop	r6
    fba8:	5f 90       	pop	r5
    fbaa:	08 95       	ret

0000fbac <__floatunsisf>:
    fbac:	e8 94       	clt
    fbae:	09 c0       	rjmp	.+18     	; 0xfbc2 <__floatsisf+0x12>

0000fbb0 <__floatsisf>:
    fbb0:	97 fb       	bst	r25, 7
    fbb2:	3e f4       	brtc	.+14     	; 0xfbc2 <__floatsisf+0x12>
    fbb4:	90 95       	com	r25
    fbb6:	80 95       	com	r24
    fbb8:	70 95       	com	r23
    fbba:	61 95       	neg	r22
    fbbc:	7f 4f       	sbci	r23, 0xFF	; 255
    fbbe:	8f 4f       	sbci	r24, 0xFF	; 255
    fbc0:	9f 4f       	sbci	r25, 0xFF	; 255
    fbc2:	99 23       	and	r25, r25
    fbc4:	a9 f0       	breq	.+42     	; 0xfbf0 <__floatsisf+0x40>
    fbc6:	f9 2f       	mov	r31, r25
    fbc8:	96 e9       	ldi	r25, 0x96	; 150
    fbca:	bb 27       	eor	r27, r27
    fbcc:	93 95       	inc	r25
    fbce:	f6 95       	lsr	r31
    fbd0:	87 95       	ror	r24
    fbd2:	77 95       	ror	r23
    fbd4:	67 95       	ror	r22
    fbd6:	b7 95       	ror	r27
    fbd8:	f1 11       	cpse	r31, r1
    fbda:	f8 cf       	rjmp	.-16     	; 0xfbcc <__floatsisf+0x1c>
    fbdc:	fa f4       	brpl	.+62     	; 0xfc1c <__floatsisf+0x6c>
    fbde:	bb 0f       	add	r27, r27
    fbe0:	11 f4       	brne	.+4      	; 0xfbe6 <__floatsisf+0x36>
    fbe2:	60 ff       	sbrs	r22, 0
    fbe4:	1b c0       	rjmp	.+54     	; 0xfc1c <__floatsisf+0x6c>
    fbe6:	6f 5f       	subi	r22, 0xFF	; 255
    fbe8:	7f 4f       	sbci	r23, 0xFF	; 255
    fbea:	8f 4f       	sbci	r24, 0xFF	; 255
    fbec:	9f 4f       	sbci	r25, 0xFF	; 255
    fbee:	16 c0       	rjmp	.+44     	; 0xfc1c <__floatsisf+0x6c>
    fbf0:	88 23       	and	r24, r24
    fbf2:	11 f0       	breq	.+4      	; 0xfbf8 <__floatsisf+0x48>
    fbf4:	96 e9       	ldi	r25, 0x96	; 150
    fbf6:	11 c0       	rjmp	.+34     	; 0xfc1a <__floatsisf+0x6a>
    fbf8:	77 23       	and	r23, r23
    fbfa:	21 f0       	breq	.+8      	; 0xfc04 <__floatsisf+0x54>
    fbfc:	9e e8       	ldi	r25, 0x8E	; 142
    fbfe:	87 2f       	mov	r24, r23
    fc00:	76 2f       	mov	r23, r22
    fc02:	05 c0       	rjmp	.+10     	; 0xfc0e <__floatsisf+0x5e>
    fc04:	66 23       	and	r22, r22
    fc06:	71 f0       	breq	.+28     	; 0xfc24 <__floatsisf+0x74>
    fc08:	96 e8       	ldi	r25, 0x86	; 134
    fc0a:	86 2f       	mov	r24, r22
    fc0c:	70 e0       	ldi	r23, 0x00	; 0
    fc0e:	60 e0       	ldi	r22, 0x00	; 0
    fc10:	2a f0       	brmi	.+10     	; 0xfc1c <__floatsisf+0x6c>
    fc12:	9a 95       	dec	r25
    fc14:	66 0f       	add	r22, r22
    fc16:	77 1f       	adc	r23, r23
    fc18:	88 1f       	adc	r24, r24
    fc1a:	da f7       	brpl	.-10     	; 0xfc12 <__floatsisf+0x62>
    fc1c:	88 0f       	add	r24, r24
    fc1e:	96 95       	lsr	r25
    fc20:	87 95       	ror	r24
    fc22:	97 f9       	bld	r25, 7
    fc24:	08 95       	ret

0000fc26 <__mulsf3>:
    fc26:	0b d0       	rcall	.+22     	; 0xfc3e <__mulsf3x>
    fc28:	78 c0       	rjmp	.+240    	; 0xfd1a <__fp_round>
    fc2a:	69 d0       	rcall	.+210    	; 0xfcfe <__fp_pscA>
    fc2c:	28 f0       	brcs	.+10     	; 0xfc38 <__mulsf3+0x12>
    fc2e:	6e d0       	rcall	.+220    	; 0xfd0c <__fp_pscB>
    fc30:	18 f0       	brcs	.+6      	; 0xfc38 <__mulsf3+0x12>
    fc32:	95 23       	and	r25, r21
    fc34:	09 f0       	breq	.+2      	; 0xfc38 <__mulsf3+0x12>
    fc36:	5a c0       	rjmp	.+180    	; 0xfcec <__fp_inf>
    fc38:	5f c0       	rjmp	.+190    	; 0xfcf8 <__fp_nan>
    fc3a:	11 24       	eor	r1, r1
    fc3c:	a2 c0       	rjmp	.+324    	; 0xfd82 <__fp_szero>

0000fc3e <__mulsf3x>:
    fc3e:	7e d0       	rcall	.+252    	; 0xfd3c <__fp_split3>
    fc40:	a0 f3       	brcs	.-24     	; 0xfc2a <__mulsf3+0x4>

0000fc42 <__mulsf3_pse>:
    fc42:	95 9f       	mul	r25, r21
    fc44:	d1 f3       	breq	.-12     	; 0xfc3a <__mulsf3+0x14>
    fc46:	95 0f       	add	r25, r21
    fc48:	50 e0       	ldi	r21, 0x00	; 0
    fc4a:	55 1f       	adc	r21, r21
    fc4c:	62 9f       	mul	r22, r18
    fc4e:	f0 01       	movw	r30, r0
    fc50:	72 9f       	mul	r23, r18
    fc52:	bb 27       	eor	r27, r27
    fc54:	f0 0d       	add	r31, r0
    fc56:	b1 1d       	adc	r27, r1
    fc58:	63 9f       	mul	r22, r19
    fc5a:	aa 27       	eor	r26, r26
    fc5c:	f0 0d       	add	r31, r0
    fc5e:	b1 1d       	adc	r27, r1
    fc60:	aa 1f       	adc	r26, r26
    fc62:	64 9f       	mul	r22, r20
    fc64:	66 27       	eor	r22, r22
    fc66:	b0 0d       	add	r27, r0
    fc68:	a1 1d       	adc	r26, r1
    fc6a:	66 1f       	adc	r22, r22
    fc6c:	82 9f       	mul	r24, r18
    fc6e:	22 27       	eor	r18, r18
    fc70:	b0 0d       	add	r27, r0
    fc72:	a1 1d       	adc	r26, r1
    fc74:	62 1f       	adc	r22, r18
    fc76:	73 9f       	mul	r23, r19
    fc78:	b0 0d       	add	r27, r0
    fc7a:	a1 1d       	adc	r26, r1
    fc7c:	62 1f       	adc	r22, r18
    fc7e:	83 9f       	mul	r24, r19
    fc80:	a0 0d       	add	r26, r0
    fc82:	61 1d       	adc	r22, r1
    fc84:	22 1f       	adc	r18, r18
    fc86:	74 9f       	mul	r23, r20
    fc88:	33 27       	eor	r19, r19
    fc8a:	a0 0d       	add	r26, r0
    fc8c:	61 1d       	adc	r22, r1
    fc8e:	23 1f       	adc	r18, r19
    fc90:	84 9f       	mul	r24, r20
    fc92:	60 0d       	add	r22, r0
    fc94:	21 1d       	adc	r18, r1
    fc96:	82 2f       	mov	r24, r18
    fc98:	76 2f       	mov	r23, r22
    fc9a:	6a 2f       	mov	r22, r26
    fc9c:	11 24       	eor	r1, r1
    fc9e:	9f 57       	subi	r25, 0x7F	; 127
    fca0:	50 40       	sbci	r21, 0x00	; 0
    fca2:	8a f0       	brmi	.+34     	; 0xfcc6 <__mulsf3_pse+0x84>
    fca4:	e1 f0       	breq	.+56     	; 0xfcde <__mulsf3_pse+0x9c>
    fca6:	88 23       	and	r24, r24
    fca8:	4a f0       	brmi	.+18     	; 0xfcbc <__mulsf3_pse+0x7a>
    fcaa:	ee 0f       	add	r30, r30
    fcac:	ff 1f       	adc	r31, r31
    fcae:	bb 1f       	adc	r27, r27
    fcb0:	66 1f       	adc	r22, r22
    fcb2:	77 1f       	adc	r23, r23
    fcb4:	88 1f       	adc	r24, r24
    fcb6:	91 50       	subi	r25, 0x01	; 1
    fcb8:	50 40       	sbci	r21, 0x00	; 0
    fcba:	a9 f7       	brne	.-22     	; 0xfca6 <__mulsf3_pse+0x64>
    fcbc:	9e 3f       	cpi	r25, 0xFE	; 254
    fcbe:	51 05       	cpc	r21, r1
    fcc0:	70 f0       	brcs	.+28     	; 0xfcde <__mulsf3_pse+0x9c>
    fcc2:	14 c0       	rjmp	.+40     	; 0xfcec <__fp_inf>
    fcc4:	5e c0       	rjmp	.+188    	; 0xfd82 <__fp_szero>
    fcc6:	5f 3f       	cpi	r21, 0xFF	; 255
    fcc8:	ec f3       	brlt	.-6      	; 0xfcc4 <__mulsf3_pse+0x82>
    fcca:	98 3e       	cpi	r25, 0xE8	; 232
    fccc:	dc f3       	brlt	.-10     	; 0xfcc4 <__mulsf3_pse+0x82>
    fcce:	86 95       	lsr	r24
    fcd0:	77 95       	ror	r23
    fcd2:	67 95       	ror	r22
    fcd4:	b7 95       	ror	r27
    fcd6:	f7 95       	ror	r31
    fcd8:	e7 95       	ror	r30
    fcda:	9f 5f       	subi	r25, 0xFF	; 255
    fcdc:	c1 f7       	brne	.-16     	; 0xfcce <__mulsf3_pse+0x8c>
    fcde:	fe 2b       	or	r31, r30
    fce0:	88 0f       	add	r24, r24
    fce2:	91 1d       	adc	r25, r1
    fce4:	96 95       	lsr	r25
    fce6:	87 95       	ror	r24
    fce8:	97 f9       	bld	r25, 7
    fcea:	08 95       	ret

0000fcec <__fp_inf>:
    fcec:	97 f9       	bld	r25, 7
    fcee:	9f 67       	ori	r25, 0x7F	; 127
    fcf0:	80 e8       	ldi	r24, 0x80	; 128
    fcf2:	70 e0       	ldi	r23, 0x00	; 0
    fcf4:	60 e0       	ldi	r22, 0x00	; 0
    fcf6:	08 95       	ret

0000fcf8 <__fp_nan>:
    fcf8:	9f ef       	ldi	r25, 0xFF	; 255
    fcfa:	80 ec       	ldi	r24, 0xC0	; 192
    fcfc:	08 95       	ret

0000fcfe <__fp_pscA>:
    fcfe:	00 24       	eor	r0, r0
    fd00:	0a 94       	dec	r0
    fd02:	16 16       	cp	r1, r22
    fd04:	17 06       	cpc	r1, r23
    fd06:	18 06       	cpc	r1, r24
    fd08:	09 06       	cpc	r0, r25
    fd0a:	08 95       	ret

0000fd0c <__fp_pscB>:
    fd0c:	00 24       	eor	r0, r0
    fd0e:	0a 94       	dec	r0
    fd10:	12 16       	cp	r1, r18
    fd12:	13 06       	cpc	r1, r19
    fd14:	14 06       	cpc	r1, r20
    fd16:	05 06       	cpc	r0, r21
    fd18:	08 95       	ret

0000fd1a <__fp_round>:
    fd1a:	09 2e       	mov	r0, r25
    fd1c:	03 94       	inc	r0
    fd1e:	00 0c       	add	r0, r0
    fd20:	11 f4       	brne	.+4      	; 0xfd26 <__fp_round+0xc>
    fd22:	88 23       	and	r24, r24
    fd24:	52 f0       	brmi	.+20     	; 0xfd3a <__fp_round+0x20>
    fd26:	bb 0f       	add	r27, r27
    fd28:	40 f4       	brcc	.+16     	; 0xfd3a <__fp_round+0x20>
    fd2a:	bf 2b       	or	r27, r31
    fd2c:	11 f4       	brne	.+4      	; 0xfd32 <__fp_round+0x18>
    fd2e:	60 ff       	sbrs	r22, 0
    fd30:	04 c0       	rjmp	.+8      	; 0xfd3a <__fp_round+0x20>
    fd32:	6f 5f       	subi	r22, 0xFF	; 255
    fd34:	7f 4f       	sbci	r23, 0xFF	; 255
    fd36:	8f 4f       	sbci	r24, 0xFF	; 255
    fd38:	9f 4f       	sbci	r25, 0xFF	; 255
    fd3a:	08 95       	ret

0000fd3c <__fp_split3>:
    fd3c:	57 fd       	sbrc	r21, 7
    fd3e:	90 58       	subi	r25, 0x80	; 128
    fd40:	44 0f       	add	r20, r20
    fd42:	55 1f       	adc	r21, r21
    fd44:	59 f0       	breq	.+22     	; 0xfd5c <__fp_splitA+0x10>
    fd46:	5f 3f       	cpi	r21, 0xFF	; 255
    fd48:	71 f0       	breq	.+28     	; 0xfd66 <__fp_splitA+0x1a>
    fd4a:	47 95       	ror	r20

0000fd4c <__fp_splitA>:
    fd4c:	88 0f       	add	r24, r24
    fd4e:	97 fb       	bst	r25, 7
    fd50:	99 1f       	adc	r25, r25
    fd52:	61 f0       	breq	.+24     	; 0xfd6c <__fp_splitA+0x20>
    fd54:	9f 3f       	cpi	r25, 0xFF	; 255
    fd56:	79 f0       	breq	.+30     	; 0xfd76 <__fp_splitA+0x2a>
    fd58:	87 95       	ror	r24
    fd5a:	08 95       	ret
    fd5c:	12 16       	cp	r1, r18
    fd5e:	13 06       	cpc	r1, r19
    fd60:	14 06       	cpc	r1, r20
    fd62:	55 1f       	adc	r21, r21
    fd64:	f2 cf       	rjmp	.-28     	; 0xfd4a <__fp_split3+0xe>
    fd66:	46 95       	lsr	r20
    fd68:	f1 df       	rcall	.-30     	; 0xfd4c <__fp_splitA>
    fd6a:	08 c0       	rjmp	.+16     	; 0xfd7c <__fp_splitA+0x30>
    fd6c:	16 16       	cp	r1, r22
    fd6e:	17 06       	cpc	r1, r23
    fd70:	18 06       	cpc	r1, r24
    fd72:	99 1f       	adc	r25, r25
    fd74:	f1 cf       	rjmp	.-30     	; 0xfd58 <__fp_splitA+0xc>
    fd76:	86 95       	lsr	r24
    fd78:	71 05       	cpc	r23, r1
    fd7a:	61 05       	cpc	r22, r1
    fd7c:	08 94       	sec
    fd7e:	08 95       	ret

0000fd80 <__fp_zero>:
    fd80:	e8 94       	clt

0000fd82 <__fp_szero>:
    fd82:	bb 27       	eor	r27, r27
    fd84:	66 27       	eor	r22, r22
    fd86:	77 27       	eor	r23, r23
    fd88:	cb 01       	movw	r24, r22
    fd8a:	97 f9       	bld	r25, 7
    fd8c:	08 95       	ret

0000fd8e <exit>:
    fd8e:	f8 94       	cli
    fd90:	0c 94 b2 83 	jmp	0x10764	; 0x10764 <_exit>

0000fd94 <__ftoa_engine>:
    fd94:	28 30       	cpi	r18, 0x08	; 8
    fd96:	08 f0       	brcs	.+2      	; 0xfd9a <__ftoa_engine+0x6>
    fd98:	27 e0       	ldi	r18, 0x07	; 7
    fd9a:	33 27       	eor	r19, r19
    fd9c:	da 01       	movw	r26, r20
    fd9e:	99 0f       	add	r25, r25
    fda0:	31 1d       	adc	r19, r1
    fda2:	87 fd       	sbrc	r24, 7
    fda4:	91 60       	ori	r25, 0x01	; 1
    fda6:	00 96       	adiw	r24, 0x00	; 0
    fda8:	61 05       	cpc	r22, r1
    fdaa:	71 05       	cpc	r23, r1
    fdac:	39 f4       	brne	.+14     	; 0xfdbc <__ftoa_engine+0x28>
    fdae:	32 60       	ori	r19, 0x02	; 2
    fdb0:	2e 5f       	subi	r18, 0xFE	; 254
    fdb2:	3d 93       	st	X+, r19
    fdb4:	30 e3       	ldi	r19, 0x30	; 48
    fdb6:	2a 95       	dec	r18
    fdb8:	e1 f7       	brne	.-8      	; 0xfdb2 <__ftoa_engine+0x1e>
    fdba:	08 95       	ret
    fdbc:	9f 3f       	cpi	r25, 0xFF	; 255
    fdbe:	30 f0       	brcs	.+12     	; 0xfdcc <__ftoa_engine+0x38>
    fdc0:	80 38       	cpi	r24, 0x80	; 128
    fdc2:	71 05       	cpc	r23, r1
    fdc4:	61 05       	cpc	r22, r1
    fdc6:	09 f0       	breq	.+2      	; 0xfdca <__ftoa_engine+0x36>
    fdc8:	3c 5f       	subi	r19, 0xFC	; 252
    fdca:	3c 5f       	subi	r19, 0xFC	; 252
    fdcc:	3d 93       	st	X+, r19
    fdce:	91 30       	cpi	r25, 0x01	; 1
    fdd0:	08 f0       	brcs	.+2      	; 0xfdd4 <__ftoa_engine+0x40>
    fdd2:	80 68       	ori	r24, 0x80	; 128
    fdd4:	91 1d       	adc	r25, r1
    fdd6:	df 93       	push	r29
    fdd8:	cf 93       	push	r28
    fdda:	1f 93       	push	r17
    fddc:	0f 93       	push	r16
    fdde:	ff 92       	push	r15
    fde0:	ef 92       	push	r14
    fde2:	19 2f       	mov	r17, r25
    fde4:	98 7f       	andi	r25, 0xF8	; 248
    fde6:	96 95       	lsr	r25
    fde8:	e9 2f       	mov	r30, r25
    fdea:	96 95       	lsr	r25
    fdec:	96 95       	lsr	r25
    fdee:	e9 0f       	add	r30, r25
    fdf0:	ff 27       	eor	r31, r31
    fdf2:	e3 5f       	subi	r30, 0xF3	; 243
    fdf4:	fd 4c       	sbci	r31, 0xCD	; 205
    fdf6:	99 27       	eor	r25, r25
    fdf8:	33 27       	eor	r19, r19
    fdfa:	ee 24       	eor	r14, r14
    fdfc:	ff 24       	eor	r15, r15
    fdfe:	a7 01       	movw	r20, r14
    fe00:	e7 01       	movw	r28, r14
    fe02:	05 90       	lpm	r0, Z+
    fe04:	08 94       	sec
    fe06:	07 94       	ror	r0
    fe08:	28 f4       	brcc	.+10     	; 0xfe14 <__ftoa_engine+0x80>
    fe0a:	36 0f       	add	r19, r22
    fe0c:	e7 1e       	adc	r14, r23
    fe0e:	f8 1e       	adc	r15, r24
    fe10:	49 1f       	adc	r20, r25
    fe12:	51 1d       	adc	r21, r1
    fe14:	66 0f       	add	r22, r22
    fe16:	77 1f       	adc	r23, r23
    fe18:	88 1f       	adc	r24, r24
    fe1a:	99 1f       	adc	r25, r25
    fe1c:	06 94       	lsr	r0
    fe1e:	a1 f7       	brne	.-24     	; 0xfe08 <__ftoa_engine+0x74>
    fe20:	05 90       	lpm	r0, Z+
    fe22:	07 94       	ror	r0
    fe24:	28 f4       	brcc	.+10     	; 0xfe30 <__ftoa_engine+0x9c>
    fe26:	e7 0e       	add	r14, r23
    fe28:	f8 1e       	adc	r15, r24
    fe2a:	49 1f       	adc	r20, r25
    fe2c:	56 1f       	adc	r21, r22
    fe2e:	c1 1d       	adc	r28, r1
    fe30:	77 0f       	add	r23, r23
    fe32:	88 1f       	adc	r24, r24
    fe34:	99 1f       	adc	r25, r25
    fe36:	66 1f       	adc	r22, r22
    fe38:	06 94       	lsr	r0
    fe3a:	a1 f7       	brne	.-24     	; 0xfe24 <__ftoa_engine+0x90>
    fe3c:	05 90       	lpm	r0, Z+
    fe3e:	07 94       	ror	r0
    fe40:	28 f4       	brcc	.+10     	; 0xfe4c <__ftoa_engine+0xb8>
    fe42:	f8 0e       	add	r15, r24
    fe44:	49 1f       	adc	r20, r25
    fe46:	56 1f       	adc	r21, r22
    fe48:	c7 1f       	adc	r28, r23
    fe4a:	d1 1d       	adc	r29, r1
    fe4c:	88 0f       	add	r24, r24
    fe4e:	99 1f       	adc	r25, r25
    fe50:	66 1f       	adc	r22, r22
    fe52:	77 1f       	adc	r23, r23
    fe54:	06 94       	lsr	r0
    fe56:	a1 f7       	brne	.-24     	; 0xfe40 <__ftoa_engine+0xac>
    fe58:	05 90       	lpm	r0, Z+
    fe5a:	07 94       	ror	r0
    fe5c:	20 f4       	brcc	.+8      	; 0xfe66 <__ftoa_engine+0xd2>
    fe5e:	49 0f       	add	r20, r25
    fe60:	56 1f       	adc	r21, r22
    fe62:	c7 1f       	adc	r28, r23
    fe64:	d8 1f       	adc	r29, r24
    fe66:	99 0f       	add	r25, r25
    fe68:	66 1f       	adc	r22, r22
    fe6a:	77 1f       	adc	r23, r23
    fe6c:	88 1f       	adc	r24, r24
    fe6e:	06 94       	lsr	r0
    fe70:	a9 f7       	brne	.-22     	; 0xfe5c <__ftoa_engine+0xc8>
    fe72:	84 91       	lpm	r24, Z+
    fe74:	10 95       	com	r17
    fe76:	17 70       	andi	r17, 0x07	; 7
    fe78:	41 f0       	breq	.+16     	; 0xfe8a <__ftoa_engine+0xf6>
    fe7a:	d6 95       	lsr	r29
    fe7c:	c7 95       	ror	r28
    fe7e:	57 95       	ror	r21
    fe80:	47 95       	ror	r20
    fe82:	f7 94       	ror	r15
    fe84:	e7 94       	ror	r14
    fe86:	1a 95       	dec	r17
    fe88:	c1 f7       	brne	.-16     	; 0xfe7a <__ftoa_engine+0xe6>
    fe8a:	e3 eb       	ldi	r30, 0xB3	; 179
    fe8c:	f1 e3       	ldi	r31, 0x31	; 49
    fe8e:	68 94       	set
    fe90:	15 90       	lpm	r1, Z+
    fe92:	15 91       	lpm	r17, Z+
    fe94:	35 91       	lpm	r19, Z+
    fe96:	65 91       	lpm	r22, Z+
    fe98:	95 91       	lpm	r25, Z+
    fe9a:	05 90       	lpm	r0, Z+
    fe9c:	7f e2       	ldi	r23, 0x2F	; 47
    fe9e:	73 95       	inc	r23
    fea0:	e1 18       	sub	r14, r1
    fea2:	f1 0a       	sbc	r15, r17
    fea4:	43 0b       	sbc	r20, r19
    fea6:	56 0b       	sbc	r21, r22
    fea8:	c9 0b       	sbc	r28, r25
    feaa:	d0 09       	sbc	r29, r0
    feac:	c0 f7       	brcc	.-16     	; 0xfe9e <__ftoa_engine+0x10a>
    feae:	e1 0c       	add	r14, r1
    feb0:	f1 1e       	adc	r15, r17
    feb2:	43 1f       	adc	r20, r19
    feb4:	56 1f       	adc	r21, r22
    feb6:	c9 1f       	adc	r28, r25
    feb8:	d0 1d       	adc	r29, r0
    feba:	7e f4       	brtc	.+30     	; 0xfeda <__ftoa_engine+0x146>
    febc:	70 33       	cpi	r23, 0x30	; 48
    febe:	11 f4       	brne	.+4      	; 0xfec4 <__ftoa_engine+0x130>
    fec0:	8a 95       	dec	r24
    fec2:	e6 cf       	rjmp	.-52     	; 0xfe90 <__ftoa_engine+0xfc>
    fec4:	e8 94       	clt
    fec6:	01 50       	subi	r16, 0x01	; 1
    fec8:	30 f0       	brcs	.+12     	; 0xfed6 <__ftoa_engine+0x142>
    feca:	08 0f       	add	r16, r24
    fecc:	0a f4       	brpl	.+2      	; 0xfed0 <__ftoa_engine+0x13c>
    fece:	00 27       	eor	r16, r16
    fed0:	02 17       	cp	r16, r18
    fed2:	08 f4       	brcc	.+2      	; 0xfed6 <__ftoa_engine+0x142>
    fed4:	20 2f       	mov	r18, r16
    fed6:	23 95       	inc	r18
    fed8:	02 2f       	mov	r16, r18
    feda:	7a 33       	cpi	r23, 0x3A	; 58
    fedc:	28 f0       	brcs	.+10     	; 0xfee8 <__ftoa_engine+0x154>
    fede:	79 e3       	ldi	r23, 0x39	; 57
    fee0:	7d 93       	st	X+, r23
    fee2:	2a 95       	dec	r18
    fee4:	e9 f7       	brne	.-6      	; 0xfee0 <__ftoa_engine+0x14c>
    fee6:	10 c0       	rjmp	.+32     	; 0xff08 <__ftoa_engine+0x174>
    fee8:	7d 93       	st	X+, r23
    feea:	2a 95       	dec	r18
    feec:	89 f6       	brne	.-94     	; 0xfe90 <__ftoa_engine+0xfc>
    feee:	06 94       	lsr	r0
    fef0:	97 95       	ror	r25
    fef2:	67 95       	ror	r22
    fef4:	37 95       	ror	r19
    fef6:	17 95       	ror	r17
    fef8:	17 94       	ror	r1
    fefa:	e1 18       	sub	r14, r1
    fefc:	f1 0a       	sbc	r15, r17
    fefe:	43 0b       	sbc	r20, r19
    ff00:	56 0b       	sbc	r21, r22
    ff02:	c9 0b       	sbc	r28, r25
    ff04:	d0 09       	sbc	r29, r0
    ff06:	98 f0       	brcs	.+38     	; 0xff2e <__ftoa_engine+0x19a>
    ff08:	23 95       	inc	r18
    ff0a:	7e 91       	ld	r23, -X
    ff0c:	73 95       	inc	r23
    ff0e:	7a 33       	cpi	r23, 0x3A	; 58
    ff10:	08 f0       	brcs	.+2      	; 0xff14 <__ftoa_engine+0x180>
    ff12:	70 e3       	ldi	r23, 0x30	; 48
    ff14:	7c 93       	st	X, r23
    ff16:	20 13       	cpse	r18, r16
    ff18:	b8 f7       	brcc	.-18     	; 0xff08 <__ftoa_engine+0x174>
    ff1a:	7e 91       	ld	r23, -X
    ff1c:	70 61       	ori	r23, 0x10	; 16
    ff1e:	7d 93       	st	X+, r23
    ff20:	30 f0       	brcs	.+12     	; 0xff2e <__ftoa_engine+0x19a>
    ff22:	83 95       	inc	r24
    ff24:	71 e3       	ldi	r23, 0x31	; 49
    ff26:	7d 93       	st	X+, r23
    ff28:	70 e3       	ldi	r23, 0x30	; 48
    ff2a:	2a 95       	dec	r18
    ff2c:	e1 f7       	brne	.-8      	; 0xff26 <__ftoa_engine+0x192>
    ff2e:	11 24       	eor	r1, r1
    ff30:	ef 90       	pop	r14
    ff32:	ff 90       	pop	r15
    ff34:	0f 91       	pop	r16
    ff36:	1f 91       	pop	r17
    ff38:	cf 91       	pop	r28
    ff3a:	df 91       	pop	r29
    ff3c:	99 27       	eor	r25, r25
    ff3e:	87 fd       	sbrc	r24, 7
    ff40:	90 95       	com	r25
    ff42:	08 95       	ret

0000ff44 <isspace>:
    ff44:	91 11       	cpse	r25, r1
    ff46:	7c c3       	rjmp	.+1784   	; 0x10640 <__ctype_isfalse>
    ff48:	80 32       	cpi	r24, 0x20	; 32
    ff4a:	19 f0       	breq	.+6      	; 0xff52 <isspace+0xe>
    ff4c:	89 50       	subi	r24, 0x09	; 9
    ff4e:	85 50       	subi	r24, 0x05	; 5
    ff50:	d0 f7       	brcc	.-12     	; 0xff46 <isspace+0x2>
    ff52:	08 95       	ret

0000ff54 <tolower>:
    ff54:	91 11       	cpse	r25, r1
    ff56:	08 95       	ret
    ff58:	81 54       	subi	r24, 0x41	; 65
    ff5a:	8a 51       	subi	r24, 0x1A	; 26
    ff5c:	08 f4       	brcc	.+2      	; 0xff60 <tolower+0xc>
    ff5e:	80 5e       	subi	r24, 0xE0	; 224
    ff60:	85 5a       	subi	r24, 0xA5	; 165
    ff62:	08 95       	ret

0000ff64 <strchr_P>:
    ff64:	fc 01       	movw	r30, r24
    ff66:	05 90       	lpm	r0, Z+
    ff68:	06 16       	cp	r0, r22
    ff6a:	21 f0       	breq	.+8      	; 0xff74 <strchr_P+0x10>
    ff6c:	00 20       	and	r0, r0
    ff6e:	d9 f7       	brne	.-10     	; 0xff66 <strchr_P+0x2>
    ff70:	c0 01       	movw	r24, r0
    ff72:	08 95       	ret
    ff74:	31 97       	sbiw	r30, 0x01	; 1
    ff76:	cf 01       	movw	r24, r30
    ff78:	08 95       	ret

0000ff7a <strcmp_P>:
    ff7a:	fb 01       	movw	r30, r22
    ff7c:	dc 01       	movw	r26, r24
    ff7e:	8d 91       	ld	r24, X+
    ff80:	05 90       	lpm	r0, Z+
    ff82:	80 19       	sub	r24, r0
    ff84:	01 10       	cpse	r0, r1
    ff86:	d9 f3       	breq	.-10     	; 0xff7e <strcmp_P+0x4>
    ff88:	99 0b       	sbc	r25, r25
    ff8a:	08 95       	ret

0000ff8c <strcpy_P>:
    ff8c:	fb 01       	movw	r30, r22
    ff8e:	dc 01       	movw	r26, r24
    ff90:	05 90       	lpm	r0, Z+
    ff92:	0d 92       	st	X+, r0
    ff94:	00 20       	and	r0, r0
    ff96:	e1 f7       	brne	.-8      	; 0xff90 <strcpy_P+0x4>
    ff98:	08 95       	ret

0000ff9a <strlen_P>:
    ff9a:	fc 01       	movw	r30, r24
    ff9c:	05 90       	lpm	r0, Z+
    ff9e:	00 20       	and	r0, r0
    ffa0:	e9 f7       	brne	.-6      	; 0xff9c <strlen_P+0x2>
    ffa2:	80 95       	com	r24
    ffa4:	90 95       	com	r25
    ffa6:	8e 0f       	add	r24, r30
    ffa8:	9f 1f       	adc	r25, r31
    ffaa:	08 95       	ret

0000ffac <strncmp_P>:
    ffac:	fb 01       	movw	r30, r22
    ffae:	dc 01       	movw	r26, r24
    ffb0:	41 50       	subi	r20, 0x01	; 1
    ffb2:	50 40       	sbci	r21, 0x00	; 0
    ffb4:	30 f0       	brcs	.+12     	; 0xffc2 <strncmp_P+0x16>
    ffb6:	8d 91       	ld	r24, X+
    ffb8:	05 90       	lpm	r0, Z+
    ffba:	80 19       	sub	r24, r0
    ffbc:	19 f4       	brne	.+6      	; 0xffc4 <strncmp_P+0x18>
    ffbe:	00 20       	and	r0, r0
    ffc0:	b9 f7       	brne	.-18     	; 0xffb0 <strncmp_P+0x4>
    ffc2:	88 1b       	sub	r24, r24
    ffc4:	99 0b       	sbc	r25, r25
    ffc6:	08 95       	ret

0000ffc8 <strnlen_P>:
    ffc8:	fc 01       	movw	r30, r24
    ffca:	05 90       	lpm	r0, Z+
    ffcc:	61 50       	subi	r22, 0x01	; 1
    ffce:	70 40       	sbci	r23, 0x00	; 0
    ffd0:	01 10       	cpse	r0, r1
    ffd2:	d8 f7       	brcc	.-10     	; 0xffca <strnlen_P+0x2>
    ffd4:	80 95       	com	r24
    ffd6:	90 95       	com	r25
    ffd8:	8e 0f       	add	r24, r30
    ffda:	9f 1f       	adc	r25, r31
    ffdc:	08 95       	ret

0000ffde <strstr_P>:
    ffde:	fb 01       	movw	r30, r22
    ffe0:	55 91       	lpm	r21, Z+
    ffe2:	55 23       	and	r21, r21
    ffe4:	a9 f0       	breq	.+42     	; 0x10010 <strstr_P+0x32>
    ffe6:	bf 01       	movw	r22, r30
    ffe8:	dc 01       	movw	r26, r24
    ffea:	4d 91       	ld	r20, X+
    ffec:	45 17       	cp	r20, r21
    ffee:	41 11       	cpse	r20, r1
    fff0:	e1 f7       	brne	.-8      	; 0xffea <strstr_P+0xc>
    fff2:	59 f4       	brne	.+22     	; 0x1000a <strstr_P+0x2c>
    fff4:	cd 01       	movw	r24, r26
    fff6:	05 90       	lpm	r0, Z+
    fff8:	00 20       	and	r0, r0
    fffa:	49 f0       	breq	.+18     	; 0x1000e <strstr_P+0x30>
    fffc:	4d 91       	ld	r20, X+
    fffe:	40 15       	cp	r20, r0
   10000:	41 11       	cpse	r20, r1
   10002:	c9 f3       	breq	.-14     	; 0xfff6 <strstr_P+0x18>
   10004:	fb 01       	movw	r30, r22
   10006:	41 11       	cpse	r20, r1
   10008:	ef cf       	rjmp	.-34     	; 0xffe8 <strstr_P+0xa>
   1000a:	81 e0       	ldi	r24, 0x01	; 1
   1000c:	90 e0       	ldi	r25, 0x00	; 0
   1000e:	01 97       	sbiw	r24, 0x01	; 1
   10010:	08 95       	ret

00010012 <memcpy>:
   10012:	fb 01       	movw	r30, r22
   10014:	dc 01       	movw	r26, r24
   10016:	02 c0       	rjmp	.+4      	; 0x1001c <memcpy+0xa>
   10018:	01 90       	ld	r0, Z+
   1001a:	0d 92       	st	X+, r0
   1001c:	41 50       	subi	r20, 0x01	; 1
   1001e:	50 40       	sbci	r21, 0x00	; 0
   10020:	d8 f7       	brcc	.-10     	; 0x10018 <memcpy+0x6>
   10022:	08 95       	ret

00010024 <strchr>:
   10024:	fc 01       	movw	r30, r24
   10026:	81 91       	ld	r24, Z+
   10028:	86 17       	cp	r24, r22
   1002a:	21 f0       	breq	.+8      	; 0x10034 <strchr+0x10>
   1002c:	88 23       	and	r24, r24
   1002e:	d9 f7       	brne	.-10     	; 0x10026 <strchr+0x2>
   10030:	99 27       	eor	r25, r25
   10032:	08 95       	ret
   10034:	31 97       	sbiw	r30, 0x01	; 1
   10036:	cf 01       	movw	r24, r30
   10038:	08 95       	ret

0001003a <strcmp>:
   1003a:	fb 01       	movw	r30, r22
   1003c:	dc 01       	movw	r26, r24
   1003e:	8d 91       	ld	r24, X+
   10040:	01 90       	ld	r0, Z+
   10042:	80 19       	sub	r24, r0
   10044:	01 10       	cpse	r0, r1
   10046:	d9 f3       	breq	.-10     	; 0x1003e <strcmp+0x4>
   10048:	99 0b       	sbc	r25, r25
   1004a:	08 95       	ret

0001004c <strnlen>:
   1004c:	fc 01       	movw	r30, r24
   1004e:	61 50       	subi	r22, 0x01	; 1
   10050:	70 40       	sbci	r23, 0x00	; 0
   10052:	01 90       	ld	r0, Z+
   10054:	01 10       	cpse	r0, r1
   10056:	d8 f7       	brcc	.-10     	; 0x1004e <strnlen+0x2>
   10058:	80 95       	com	r24
   1005a:	90 95       	com	r25
   1005c:	8e 0f       	add	r24, r30
   1005e:	9f 1f       	adc	r25, r31
   10060:	08 95       	ret

00010062 <strstr>:
   10062:	fb 01       	movw	r30, r22
   10064:	51 91       	ld	r21, Z+
   10066:	55 23       	and	r21, r21
   10068:	a9 f0       	breq	.+42     	; 0x10094 <strstr+0x32>
   1006a:	bf 01       	movw	r22, r30
   1006c:	dc 01       	movw	r26, r24
   1006e:	4d 91       	ld	r20, X+
   10070:	45 17       	cp	r20, r21
   10072:	41 11       	cpse	r20, r1
   10074:	e1 f7       	brne	.-8      	; 0x1006e <strstr+0xc>
   10076:	59 f4       	brne	.+22     	; 0x1008e <strstr+0x2c>
   10078:	cd 01       	movw	r24, r26
   1007a:	01 90       	ld	r0, Z+
   1007c:	00 20       	and	r0, r0
   1007e:	49 f0       	breq	.+18     	; 0x10092 <strstr+0x30>
   10080:	4d 91       	ld	r20, X+
   10082:	40 15       	cp	r20, r0
   10084:	41 11       	cpse	r20, r1
   10086:	c9 f3       	breq	.-14     	; 0x1007a <strstr+0x18>
   10088:	fb 01       	movw	r30, r22
   1008a:	41 11       	cpse	r20, r1
   1008c:	ef cf       	rjmp	.-34     	; 0x1006c <strstr+0xa>
   1008e:	81 e0       	ldi	r24, 0x01	; 1
   10090:	90 e0       	ldi	r25, 0x00	; 0
   10092:	01 97       	sbiw	r24, 0x01	; 1
   10094:	08 95       	ret

00010096 <fgetc>:
   10096:	cf 93       	push	r28
   10098:	df 93       	push	r29
   1009a:	ec 01       	movw	r28, r24
   1009c:	4b 81       	ldd	r20, Y+3	; 0x03
   1009e:	40 ff       	sbrs	r20, 0
   100a0:	1a c0       	rjmp	.+52     	; 0x100d6 <fgetc+0x40>
   100a2:	46 ff       	sbrs	r20, 6
   100a4:	0a c0       	rjmp	.+20     	; 0x100ba <fgetc+0x24>
   100a6:	4f 7b       	andi	r20, 0xBF	; 191
   100a8:	4b 83       	std	Y+3, r20	; 0x03
   100aa:	8e 81       	ldd	r24, Y+6	; 0x06
   100ac:	9f 81       	ldd	r25, Y+7	; 0x07
   100ae:	01 96       	adiw	r24, 0x01	; 1
   100b0:	9f 83       	std	Y+7, r25	; 0x07
   100b2:	8e 83       	std	Y+6, r24	; 0x06
   100b4:	8a 81       	ldd	r24, Y+2	; 0x02
   100b6:	28 2f       	mov	r18, r24
   100b8:	2b c0       	rjmp	.+86     	; 0x10110 <fgetc+0x7a>
   100ba:	42 ff       	sbrs	r20, 2
   100bc:	13 c0       	rjmp	.+38     	; 0x100e4 <fgetc+0x4e>
   100be:	e8 81       	ld	r30, Y
   100c0:	f9 81       	ldd	r31, Y+1	; 0x01
   100c2:	80 81       	ld	r24, Z
   100c4:	28 2f       	mov	r18, r24
   100c6:	33 27       	eor	r19, r19
   100c8:	27 fd       	sbrc	r18, 7
   100ca:	30 95       	com	r19
   100cc:	21 15       	cp	r18, r1
   100ce:	31 05       	cpc	r19, r1
   100d0:	29 f4       	brne	.+10     	; 0x100dc <fgetc+0x46>
   100d2:	40 62       	ori	r20, 0x20	; 32
   100d4:	4b 83       	std	Y+3, r20	; 0x03
   100d6:	2f ef       	ldi	r18, 0xFF	; 255
   100d8:	3f ef       	ldi	r19, 0xFF	; 255
   100da:	1b c0       	rjmp	.+54     	; 0x10112 <fgetc+0x7c>
   100dc:	31 96       	adiw	r30, 0x01	; 1
   100de:	f9 83       	std	Y+1, r31	; 0x01
   100e0:	e8 83       	st	Y, r30
   100e2:	11 c0       	rjmp	.+34     	; 0x10106 <fgetc+0x70>
   100e4:	ea 85       	ldd	r30, Y+10	; 0x0a
   100e6:	fb 85       	ldd	r31, Y+11	; 0x0b
   100e8:	ce 01       	movw	r24, r28
   100ea:	19 95       	eicall
   100ec:	9c 01       	movw	r18, r24
   100ee:	97 ff       	sbrs	r25, 7
   100f0:	0a c0       	rjmp	.+20     	; 0x10106 <fgetc+0x70>
   100f2:	9b 81       	ldd	r25, Y+3	; 0x03
   100f4:	2f 5f       	subi	r18, 0xFF	; 255
   100f6:	3f 4f       	sbci	r19, 0xFF	; 255
   100f8:	11 f0       	breq	.+4      	; 0x100fe <fgetc+0x68>
   100fa:	80 e2       	ldi	r24, 0x20	; 32
   100fc:	01 c0       	rjmp	.+2      	; 0x10100 <fgetc+0x6a>
   100fe:	80 e1       	ldi	r24, 0x10	; 16
   10100:	89 2b       	or	r24, r25
   10102:	8b 83       	std	Y+3, r24	; 0x03
   10104:	e8 cf       	rjmp	.-48     	; 0x100d6 <fgetc+0x40>
   10106:	8e 81       	ldd	r24, Y+6	; 0x06
   10108:	9f 81       	ldd	r25, Y+7	; 0x07
   1010a:	01 96       	adiw	r24, 0x01	; 1
   1010c:	9f 83       	std	Y+7, r25	; 0x07
   1010e:	8e 83       	std	Y+6, r24	; 0x06
   10110:	30 e0       	ldi	r19, 0x00	; 0
   10112:	c9 01       	movw	r24, r18
   10114:	df 91       	pop	r29
   10116:	cf 91       	pop	r28
   10118:	08 95       	ret

0001011a <fputc>:
   1011a:	0f 93       	push	r16
   1011c:	1f 93       	push	r17
   1011e:	cf 93       	push	r28
   10120:	df 93       	push	r29
   10122:	8c 01       	movw	r16, r24
   10124:	eb 01       	movw	r28, r22
   10126:	8b 81       	ldd	r24, Y+3	; 0x03
   10128:	81 ff       	sbrs	r24, 1
   1012a:	1b c0       	rjmp	.+54     	; 0x10162 <fputc+0x48>
   1012c:	82 ff       	sbrs	r24, 2
   1012e:	0d c0       	rjmp	.+26     	; 0x1014a <fputc+0x30>
   10130:	2e 81       	ldd	r18, Y+6	; 0x06
   10132:	3f 81       	ldd	r19, Y+7	; 0x07
   10134:	8c 81       	ldd	r24, Y+4	; 0x04
   10136:	9d 81       	ldd	r25, Y+5	; 0x05
   10138:	28 17       	cp	r18, r24
   1013a:	39 07       	cpc	r19, r25
   1013c:	64 f4       	brge	.+24     	; 0x10156 <fputc+0x3c>
   1013e:	e8 81       	ld	r30, Y
   10140:	f9 81       	ldd	r31, Y+1	; 0x01
   10142:	01 93       	st	Z+, r16
   10144:	f9 83       	std	Y+1, r31	; 0x01
   10146:	e8 83       	st	Y, r30
   10148:	06 c0       	rjmp	.+12     	; 0x10156 <fputc+0x3c>
   1014a:	e8 85       	ldd	r30, Y+8	; 0x08
   1014c:	f9 85       	ldd	r31, Y+9	; 0x09
   1014e:	80 2f       	mov	r24, r16
   10150:	19 95       	eicall
   10152:	89 2b       	or	r24, r25
   10154:	31 f4       	brne	.+12     	; 0x10162 <fputc+0x48>
   10156:	8e 81       	ldd	r24, Y+6	; 0x06
   10158:	9f 81       	ldd	r25, Y+7	; 0x07
   1015a:	01 96       	adiw	r24, 0x01	; 1
   1015c:	9f 83       	std	Y+7, r25	; 0x07
   1015e:	8e 83       	std	Y+6, r24	; 0x06
   10160:	02 c0       	rjmp	.+4      	; 0x10166 <fputc+0x4c>
   10162:	0f ef       	ldi	r16, 0xFF	; 255
   10164:	1f ef       	ldi	r17, 0xFF	; 255
   10166:	c8 01       	movw	r24, r16
   10168:	df 91       	pop	r29
   1016a:	cf 91       	pop	r28
   1016c:	1f 91       	pop	r17
   1016e:	0f 91       	pop	r16
   10170:	08 95       	ret

00010172 <sprintf>:
   10172:	0f 93       	push	r16
   10174:	1f 93       	push	r17
   10176:	df 93       	push	r29
   10178:	cf 93       	push	r28
   1017a:	cd b7       	in	r28, 0x3d	; 61
   1017c:	de b7       	in	r29, 0x3e	; 62
   1017e:	2e 97       	sbiw	r28, 0x0e	; 14
   10180:	0f b6       	in	r0, 0x3f	; 63
   10182:	f8 94       	cli
   10184:	de bf       	out	0x3e, r29	; 62
   10186:	0f be       	out	0x3f, r0	; 63
   10188:	cd bf       	out	0x3d, r28	; 61
   1018a:	0e 89       	ldd	r16, Y+22	; 0x16
   1018c:	1f 89       	ldd	r17, Y+23	; 0x17
   1018e:	86 e0       	ldi	r24, 0x06	; 6
   10190:	8c 83       	std	Y+4, r24	; 0x04
   10192:	1a 83       	std	Y+2, r17	; 0x02
   10194:	09 83       	std	Y+1, r16	; 0x01
   10196:	8f ef       	ldi	r24, 0xFF	; 255
   10198:	9f e7       	ldi	r25, 0x7F	; 127
   1019a:	9e 83       	std	Y+6, r25	; 0x06
   1019c:	8d 83       	std	Y+5, r24	; 0x05
   1019e:	9e 01       	movw	r18, r28
   101a0:	26 5e       	subi	r18, 0xE6	; 230
   101a2:	3f 4f       	sbci	r19, 0xFF	; 255
   101a4:	ce 01       	movw	r24, r28
   101a6:	01 96       	adiw	r24, 0x01	; 1
   101a8:	68 8d       	ldd	r22, Y+24	; 0x18
   101aa:	79 8d       	ldd	r23, Y+25	; 0x19
   101ac:	a9 01       	movw	r20, r18
   101ae:	0e 94 e0 75 	call	0xebc0	; 0xebc0 <vfprintf>
   101b2:	2f 81       	ldd	r18, Y+7	; 0x07
   101b4:	38 85       	ldd	r19, Y+8	; 0x08
   101b6:	02 0f       	add	r16, r18
   101b8:	13 1f       	adc	r17, r19
   101ba:	f8 01       	movw	r30, r16
   101bc:	10 82       	st	Z, r1
   101be:	2e 96       	adiw	r28, 0x0e	; 14
   101c0:	0f b6       	in	r0, 0x3f	; 63
   101c2:	f8 94       	cli
   101c4:	de bf       	out	0x3e, r29	; 62
   101c6:	0f be       	out	0x3f, r0	; 63
   101c8:	cd bf       	out	0x3d, r28	; 61
   101ca:	cf 91       	pop	r28
   101cc:	df 91       	pop	r29
   101ce:	1f 91       	pop	r17
   101d0:	0f 91       	pop	r16
   101d2:	08 95       	ret

000101d4 <sprintf_P>:
   101d4:	0f 93       	push	r16
   101d6:	1f 93       	push	r17
   101d8:	df 93       	push	r29
   101da:	cf 93       	push	r28
   101dc:	cd b7       	in	r28, 0x3d	; 61
   101de:	de b7       	in	r29, 0x3e	; 62
   101e0:	2e 97       	sbiw	r28, 0x0e	; 14
   101e2:	0f b6       	in	r0, 0x3f	; 63
   101e4:	f8 94       	cli
   101e6:	de bf       	out	0x3e, r29	; 62
   101e8:	0f be       	out	0x3f, r0	; 63
   101ea:	cd bf       	out	0x3d, r28	; 61
   101ec:	0e 89       	ldd	r16, Y+22	; 0x16
   101ee:	1f 89       	ldd	r17, Y+23	; 0x17
   101f0:	8e e0       	ldi	r24, 0x0E	; 14
   101f2:	8c 83       	std	Y+4, r24	; 0x04
   101f4:	1a 83       	std	Y+2, r17	; 0x02
   101f6:	09 83       	std	Y+1, r16	; 0x01
   101f8:	8f ef       	ldi	r24, 0xFF	; 255
   101fa:	9f e7       	ldi	r25, 0x7F	; 127
   101fc:	9e 83       	std	Y+6, r25	; 0x06
   101fe:	8d 83       	std	Y+5, r24	; 0x05
   10200:	9e 01       	movw	r18, r28
   10202:	26 5e       	subi	r18, 0xE6	; 230
   10204:	3f 4f       	sbci	r19, 0xFF	; 255
   10206:	ce 01       	movw	r24, r28
   10208:	01 96       	adiw	r24, 0x01	; 1
   1020a:	68 8d       	ldd	r22, Y+24	; 0x18
   1020c:	79 8d       	ldd	r23, Y+25	; 0x19
   1020e:	a9 01       	movw	r20, r18
   10210:	0e 94 e0 75 	call	0xebc0	; 0xebc0 <vfprintf>
   10214:	2f 81       	ldd	r18, Y+7	; 0x07
   10216:	38 85       	ldd	r19, Y+8	; 0x08
   10218:	02 0f       	add	r16, r18
   1021a:	13 1f       	adc	r17, r19
   1021c:	f8 01       	movw	r30, r16
   1021e:	10 82       	st	Z, r1
   10220:	2e 96       	adiw	r28, 0x0e	; 14
   10222:	0f b6       	in	r0, 0x3f	; 63
   10224:	f8 94       	cli
   10226:	de bf       	out	0x3e, r29	; 62
   10228:	0f be       	out	0x3f, r0	; 63
   1022a:	cd bf       	out	0x3d, r28	; 61
   1022c:	cf 91       	pop	r28
   1022e:	df 91       	pop	r29
   10230:	1f 91       	pop	r17
   10232:	0f 91       	pop	r16
   10234:	08 95       	ret

00010236 <sscanf>:
   10236:	df 93       	push	r29
   10238:	cf 93       	push	r28
   1023a:	cd b7       	in	r28, 0x3d	; 61
   1023c:	de b7       	in	r29, 0x3e	; 62
   1023e:	2e 97       	sbiw	r28, 0x0e	; 14
   10240:	0f b6       	in	r0, 0x3f	; 63
   10242:	f8 94       	cli
   10244:	de bf       	out	0x3e, r29	; 62
   10246:	0f be       	out	0x3f, r0	; 63
   10248:	cd bf       	out	0x3d, r28	; 61
   1024a:	85 e0       	ldi	r24, 0x05	; 5
   1024c:	8c 83       	std	Y+4, r24	; 0x04
   1024e:	8c 89       	ldd	r24, Y+20	; 0x14
   10250:	9d 89       	ldd	r25, Y+21	; 0x15
   10252:	9a 83       	std	Y+2, r25	; 0x02
   10254:	89 83       	std	Y+1, r24	; 0x01
   10256:	9e 01       	movw	r18, r28
   10258:	28 5e       	subi	r18, 0xE8	; 232
   1025a:	3f 4f       	sbci	r19, 0xFF	; 255
   1025c:	ce 01       	movw	r24, r28
   1025e:	01 96       	adiw	r24, 0x01	; 1
   10260:	6e 89       	ldd	r22, Y+22	; 0x16
   10262:	7f 89       	ldd	r23, Y+23	; 0x17
   10264:	a9 01       	movw	r20, r18
   10266:	0e 94 97 7c 	call	0xf92e	; 0xf92e <vfscanf>
   1026a:	2e 96       	adiw	r28, 0x0e	; 14
   1026c:	0f b6       	in	r0, 0x3f	; 63
   1026e:	f8 94       	cli
   10270:	de bf       	out	0x3e, r29	; 62
   10272:	0f be       	out	0x3f, r0	; 63
   10274:	cd bf       	out	0x3d, r28	; 61
   10276:	cf 91       	pop	r28
   10278:	df 91       	pop	r29
   1027a:	08 95       	ret

0001027c <sscanf_P>:
   1027c:	df 93       	push	r29
   1027e:	cf 93       	push	r28
   10280:	cd b7       	in	r28, 0x3d	; 61
   10282:	de b7       	in	r29, 0x3e	; 62
   10284:	2e 97       	sbiw	r28, 0x0e	; 14
   10286:	0f b6       	in	r0, 0x3f	; 63
   10288:	f8 94       	cli
   1028a:	de bf       	out	0x3e, r29	; 62
   1028c:	0f be       	out	0x3f, r0	; 63
   1028e:	cd bf       	out	0x3d, r28	; 61
   10290:	8d e0       	ldi	r24, 0x0D	; 13
   10292:	8c 83       	std	Y+4, r24	; 0x04
   10294:	8c 89       	ldd	r24, Y+20	; 0x14
   10296:	9d 89       	ldd	r25, Y+21	; 0x15
   10298:	9a 83       	std	Y+2, r25	; 0x02
   1029a:	89 83       	std	Y+1, r24	; 0x01
   1029c:	9e 01       	movw	r18, r28
   1029e:	28 5e       	subi	r18, 0xE8	; 232
   102a0:	3f 4f       	sbci	r19, 0xFF	; 255
   102a2:	ce 01       	movw	r24, r28
   102a4:	01 96       	adiw	r24, 0x01	; 1
   102a6:	6e 89       	ldd	r22, Y+22	; 0x16
   102a8:	7f 89       	ldd	r23, Y+23	; 0x17
   102aa:	a9 01       	movw	r20, r18
   102ac:	0e 94 97 7c 	call	0xf92e	; 0xf92e <vfscanf>
   102b0:	2e 96       	adiw	r28, 0x0e	; 14
   102b2:	0f b6       	in	r0, 0x3f	; 63
   102b4:	f8 94       	cli
   102b6:	de bf       	out	0x3e, r29	; 62
   102b8:	0f be       	out	0x3f, r0	; 63
   102ba:	cd bf       	out	0x3d, r28	; 61
   102bc:	cf 91       	pop	r28
   102be:	df 91       	pop	r29
   102c0:	08 95       	ret

000102c2 <ungetc>:
   102c2:	9c 01       	movw	r18, r24
   102c4:	fb 01       	movw	r30, r22
   102c6:	83 81       	ldd	r24, Z+3	; 0x03
   102c8:	80 ff       	sbrs	r24, 0
   102ca:	11 c0       	rjmp	.+34     	; 0x102ee <ungetc+0x2c>
   102cc:	86 fd       	sbrc	r24, 6
   102ce:	0f c0       	rjmp	.+30     	; 0x102ee <ungetc+0x2c>
   102d0:	9f ef       	ldi	r25, 0xFF	; 255
   102d2:	2f 3f       	cpi	r18, 0xFF	; 255
   102d4:	39 07       	cpc	r19, r25
   102d6:	59 f0       	breq	.+22     	; 0x102ee <ungetc+0x2c>
   102d8:	22 83       	std	Z+2, r18	; 0x02
   102da:	80 64       	ori	r24, 0x40	; 64
   102dc:	8f 7d       	andi	r24, 0xDF	; 223
   102de:	83 83       	std	Z+3, r24	; 0x03
   102e0:	86 81       	ldd	r24, Z+6	; 0x06
   102e2:	97 81       	ldd	r25, Z+7	; 0x07
   102e4:	01 97       	sbiw	r24, 0x01	; 1
   102e6:	97 83       	std	Z+7, r25	; 0x07
   102e8:	86 83       	std	Z+6, r24	; 0x06
   102ea:	30 e0       	ldi	r19, 0x00	; 0
   102ec:	02 c0       	rjmp	.+4      	; 0x102f2 <ungetc+0x30>
   102ee:	2f ef       	ldi	r18, 0xFF	; 255
   102f0:	3f ef       	ldi	r19, 0xFF	; 255
   102f2:	c9 01       	movw	r24, r18
   102f4:	08 95       	ret

000102f6 <__ultoa_invert>:
   102f6:	fa 01       	movw	r30, r20
   102f8:	aa 27       	eor	r26, r26
   102fa:	28 30       	cpi	r18, 0x08	; 8
   102fc:	51 f1       	breq	.+84     	; 0x10352 <__ultoa_invert+0x5c>
   102fe:	20 31       	cpi	r18, 0x10	; 16
   10300:	81 f1       	breq	.+96     	; 0x10362 <__ultoa_invert+0x6c>
   10302:	e8 94       	clt
   10304:	6f 93       	push	r22
   10306:	6e 7f       	andi	r22, 0xFE	; 254
   10308:	6e 5f       	subi	r22, 0xFE	; 254
   1030a:	7f 4f       	sbci	r23, 0xFF	; 255
   1030c:	8f 4f       	sbci	r24, 0xFF	; 255
   1030e:	9f 4f       	sbci	r25, 0xFF	; 255
   10310:	af 4f       	sbci	r26, 0xFF	; 255
   10312:	b1 e0       	ldi	r27, 0x01	; 1
   10314:	3e d0       	rcall	.+124    	; 0x10392 <__ultoa_invert+0x9c>
   10316:	b4 e0       	ldi	r27, 0x04	; 4
   10318:	3c d0       	rcall	.+120    	; 0x10392 <__ultoa_invert+0x9c>
   1031a:	67 0f       	add	r22, r23
   1031c:	78 1f       	adc	r23, r24
   1031e:	89 1f       	adc	r24, r25
   10320:	9a 1f       	adc	r25, r26
   10322:	a1 1d       	adc	r26, r1
   10324:	68 0f       	add	r22, r24
   10326:	79 1f       	adc	r23, r25
   10328:	8a 1f       	adc	r24, r26
   1032a:	91 1d       	adc	r25, r1
   1032c:	a1 1d       	adc	r26, r1
   1032e:	6a 0f       	add	r22, r26
   10330:	71 1d       	adc	r23, r1
   10332:	81 1d       	adc	r24, r1
   10334:	91 1d       	adc	r25, r1
   10336:	a1 1d       	adc	r26, r1
   10338:	20 d0       	rcall	.+64     	; 0x1037a <__ultoa_invert+0x84>
   1033a:	09 f4       	brne	.+2      	; 0x1033e <__ultoa_invert+0x48>
   1033c:	68 94       	set
   1033e:	3f 91       	pop	r19
   10340:	2a e0       	ldi	r18, 0x0A	; 10
   10342:	26 9f       	mul	r18, r22
   10344:	11 24       	eor	r1, r1
   10346:	30 19       	sub	r19, r0
   10348:	30 5d       	subi	r19, 0xD0	; 208
   1034a:	31 93       	st	Z+, r19
   1034c:	de f6       	brtc	.-74     	; 0x10304 <__ultoa_invert+0xe>
   1034e:	cf 01       	movw	r24, r30
   10350:	08 95       	ret
   10352:	46 2f       	mov	r20, r22
   10354:	47 70       	andi	r20, 0x07	; 7
   10356:	40 5d       	subi	r20, 0xD0	; 208
   10358:	41 93       	st	Z+, r20
   1035a:	b3 e0       	ldi	r27, 0x03	; 3
   1035c:	0f d0       	rcall	.+30     	; 0x1037c <__ultoa_invert+0x86>
   1035e:	c9 f7       	brne	.-14     	; 0x10352 <__ultoa_invert+0x5c>
   10360:	f6 cf       	rjmp	.-20     	; 0x1034e <__ultoa_invert+0x58>
   10362:	46 2f       	mov	r20, r22
   10364:	4f 70       	andi	r20, 0x0F	; 15
   10366:	40 5d       	subi	r20, 0xD0	; 208
   10368:	4a 33       	cpi	r20, 0x3A	; 58
   1036a:	18 f0       	brcs	.+6      	; 0x10372 <__ultoa_invert+0x7c>
   1036c:	49 5d       	subi	r20, 0xD9	; 217
   1036e:	31 fd       	sbrc	r19, 1
   10370:	40 52       	subi	r20, 0x20	; 32
   10372:	41 93       	st	Z+, r20
   10374:	02 d0       	rcall	.+4      	; 0x1037a <__ultoa_invert+0x84>
   10376:	a9 f7       	brne	.-22     	; 0x10362 <__ultoa_invert+0x6c>
   10378:	ea cf       	rjmp	.-44     	; 0x1034e <__ultoa_invert+0x58>
   1037a:	b4 e0       	ldi	r27, 0x04	; 4
   1037c:	a6 95       	lsr	r26
   1037e:	97 95       	ror	r25
   10380:	87 95       	ror	r24
   10382:	77 95       	ror	r23
   10384:	67 95       	ror	r22
   10386:	ba 95       	dec	r27
   10388:	c9 f7       	brne	.-14     	; 0x1037c <__ultoa_invert+0x86>
   1038a:	00 97       	sbiw	r24, 0x00	; 0
   1038c:	61 05       	cpc	r22, r1
   1038e:	71 05       	cpc	r23, r1
   10390:	08 95       	ret
   10392:	9b 01       	movw	r18, r22
   10394:	ac 01       	movw	r20, r24
   10396:	0a 2e       	mov	r0, r26
   10398:	06 94       	lsr	r0
   1039a:	57 95       	ror	r21
   1039c:	47 95       	ror	r20
   1039e:	37 95       	ror	r19
   103a0:	27 95       	ror	r18
   103a2:	ba 95       	dec	r27
   103a4:	c9 f7       	brne	.-14     	; 0x10398 <__ultoa_invert+0xa2>
   103a6:	62 0f       	add	r22, r18
   103a8:	73 1f       	adc	r23, r19
   103aa:	84 1f       	adc	r24, r20
   103ac:	95 1f       	adc	r25, r21
   103ae:	a0 1d       	adc	r26, r0
   103b0:	08 95       	ret

000103b2 <__subsf3>:
   103b2:	50 58       	subi	r21, 0x80	; 128

000103b4 <__addsf3>:
   103b4:	bb 27       	eor	r27, r27
   103b6:	aa 27       	eor	r26, r26
   103b8:	0e d0       	rcall	.+28     	; 0x103d6 <__addsf3x>
   103ba:	af cc       	rjmp	.-1698   	; 0xfd1a <__fp_round>
   103bc:	a0 dc       	rcall	.-1728   	; 0xfcfe <__fp_pscA>
   103be:	30 f0       	brcs	.+12     	; 0x103cc <__addsf3+0x18>
   103c0:	a5 dc       	rcall	.-1718   	; 0xfd0c <__fp_pscB>
   103c2:	20 f0       	brcs	.+8      	; 0x103cc <__addsf3+0x18>
   103c4:	31 f4       	brne	.+12     	; 0x103d2 <__addsf3+0x1e>
   103c6:	9f 3f       	cpi	r25, 0xFF	; 255
   103c8:	11 f4       	brne	.+4      	; 0x103ce <__addsf3+0x1a>
   103ca:	1e f4       	brtc	.+6      	; 0x103d2 <__addsf3+0x1e>
   103cc:	95 cc       	rjmp	.-1750   	; 0xfcf8 <__fp_nan>
   103ce:	0e f4       	brtc	.+2      	; 0x103d2 <__addsf3+0x1e>
   103d0:	e0 95       	com	r30
   103d2:	e7 fb       	bst	r30, 7
   103d4:	8b cc       	rjmp	.-1770   	; 0xfcec <__fp_inf>

000103d6 <__addsf3x>:
   103d6:	e9 2f       	mov	r30, r25
   103d8:	b1 dc       	rcall	.-1694   	; 0xfd3c <__fp_split3>
   103da:	80 f3       	brcs	.-32     	; 0x103bc <__addsf3+0x8>
   103dc:	ba 17       	cp	r27, r26
   103de:	62 07       	cpc	r22, r18
   103e0:	73 07       	cpc	r23, r19
   103e2:	84 07       	cpc	r24, r20
   103e4:	95 07       	cpc	r25, r21
   103e6:	18 f0       	brcs	.+6      	; 0x103ee <__addsf3x+0x18>
   103e8:	71 f4       	brne	.+28     	; 0x10406 <__addsf3x+0x30>
   103ea:	9e f5       	brtc	.+102    	; 0x10452 <__addsf3x+0x7c>
   103ec:	c9 cc       	rjmp	.-1646   	; 0xfd80 <__fp_zero>
   103ee:	0e f4       	brtc	.+2      	; 0x103f2 <__addsf3x+0x1c>
   103f0:	e0 95       	com	r30
   103f2:	0b 2e       	mov	r0, r27
   103f4:	ba 2f       	mov	r27, r26
   103f6:	a0 2d       	mov	r26, r0
   103f8:	0b 01       	movw	r0, r22
   103fa:	b9 01       	movw	r22, r18
   103fc:	90 01       	movw	r18, r0
   103fe:	0c 01       	movw	r0, r24
   10400:	ca 01       	movw	r24, r20
   10402:	a0 01       	movw	r20, r0
   10404:	11 24       	eor	r1, r1
   10406:	ff 27       	eor	r31, r31
   10408:	59 1b       	sub	r21, r25
   1040a:	99 f0       	breq	.+38     	; 0x10432 <__addsf3x+0x5c>
   1040c:	59 3f       	cpi	r21, 0xF9	; 249
   1040e:	50 f4       	brcc	.+20     	; 0x10424 <__addsf3x+0x4e>
   10410:	50 3e       	cpi	r21, 0xE0	; 224
   10412:	68 f1       	brcs	.+90     	; 0x1046e <__addsf3x+0x98>
   10414:	1a 16       	cp	r1, r26
   10416:	f0 40       	sbci	r31, 0x00	; 0
   10418:	a2 2f       	mov	r26, r18
   1041a:	23 2f       	mov	r18, r19
   1041c:	34 2f       	mov	r19, r20
   1041e:	44 27       	eor	r20, r20
   10420:	58 5f       	subi	r21, 0xF8	; 248
   10422:	f3 cf       	rjmp	.-26     	; 0x1040a <__addsf3x+0x34>
   10424:	46 95       	lsr	r20
   10426:	37 95       	ror	r19
   10428:	27 95       	ror	r18
   1042a:	a7 95       	ror	r26
   1042c:	f0 40       	sbci	r31, 0x00	; 0
   1042e:	53 95       	inc	r21
   10430:	c9 f7       	brne	.-14     	; 0x10424 <__addsf3x+0x4e>
   10432:	7e f4       	brtc	.+30     	; 0x10452 <__addsf3x+0x7c>
   10434:	1f 16       	cp	r1, r31
   10436:	ba 0b       	sbc	r27, r26
   10438:	62 0b       	sbc	r22, r18
   1043a:	73 0b       	sbc	r23, r19
   1043c:	84 0b       	sbc	r24, r20
   1043e:	ba f0       	brmi	.+46     	; 0x1046e <__addsf3x+0x98>
   10440:	91 50       	subi	r25, 0x01	; 1
   10442:	a1 f0       	breq	.+40     	; 0x1046c <__addsf3x+0x96>
   10444:	ff 0f       	add	r31, r31
   10446:	bb 1f       	adc	r27, r27
   10448:	66 1f       	adc	r22, r22
   1044a:	77 1f       	adc	r23, r23
   1044c:	88 1f       	adc	r24, r24
   1044e:	c2 f7       	brpl	.-16     	; 0x10440 <__addsf3x+0x6a>
   10450:	0e c0       	rjmp	.+28     	; 0x1046e <__addsf3x+0x98>
   10452:	ba 0f       	add	r27, r26
   10454:	62 1f       	adc	r22, r18
   10456:	73 1f       	adc	r23, r19
   10458:	84 1f       	adc	r24, r20
   1045a:	48 f4       	brcc	.+18     	; 0x1046e <__addsf3x+0x98>
   1045c:	87 95       	ror	r24
   1045e:	77 95       	ror	r23
   10460:	67 95       	ror	r22
   10462:	b7 95       	ror	r27
   10464:	f7 95       	ror	r31
   10466:	9e 3f       	cpi	r25, 0xFE	; 254
   10468:	08 f0       	brcs	.+2      	; 0x1046c <__addsf3x+0x96>
   1046a:	b3 cf       	rjmp	.-154    	; 0x103d2 <__addsf3+0x1e>
   1046c:	93 95       	inc	r25
   1046e:	88 0f       	add	r24, r24
   10470:	08 f0       	brcs	.+2      	; 0x10474 <__addsf3x+0x9e>
   10472:	99 27       	eor	r25, r25
   10474:	ee 0f       	add	r30, r30
   10476:	97 95       	ror	r25
   10478:	87 95       	ror	r24
   1047a:	08 95       	ret

0001047c <__divsf3>:
   1047c:	0c d0       	rcall	.+24     	; 0x10496 <__divsf3x>
   1047e:	4d cc       	rjmp	.-1894   	; 0xfd1a <__fp_round>
   10480:	45 dc       	rcall	.-1910   	; 0xfd0c <__fp_pscB>
   10482:	40 f0       	brcs	.+16     	; 0x10494 <__divsf3+0x18>
   10484:	3c dc       	rcall	.-1928   	; 0xfcfe <__fp_pscA>
   10486:	30 f0       	brcs	.+12     	; 0x10494 <__divsf3+0x18>
   10488:	21 f4       	brne	.+8      	; 0x10492 <__divsf3+0x16>
   1048a:	5f 3f       	cpi	r21, 0xFF	; 255
   1048c:	19 f0       	breq	.+6      	; 0x10494 <__divsf3+0x18>
   1048e:	2e cc       	rjmp	.-1956   	; 0xfcec <__fp_inf>
   10490:	51 11       	cpse	r21, r1
   10492:	77 cc       	rjmp	.-1810   	; 0xfd82 <__fp_szero>
   10494:	31 cc       	rjmp	.-1950   	; 0xfcf8 <__fp_nan>

00010496 <__divsf3x>:
   10496:	52 dc       	rcall	.-1884   	; 0xfd3c <__fp_split3>
   10498:	98 f3       	brcs	.-26     	; 0x10480 <__divsf3+0x4>

0001049a <__divsf3_pse>:
   1049a:	99 23       	and	r25, r25
   1049c:	c9 f3       	breq	.-14     	; 0x10490 <__divsf3+0x14>
   1049e:	55 23       	and	r21, r21
   104a0:	b1 f3       	breq	.-20     	; 0x1048e <__divsf3+0x12>
   104a2:	95 1b       	sub	r25, r21
   104a4:	55 0b       	sbc	r21, r21
   104a6:	bb 27       	eor	r27, r27
   104a8:	aa 27       	eor	r26, r26
   104aa:	62 17       	cp	r22, r18
   104ac:	73 07       	cpc	r23, r19
   104ae:	84 07       	cpc	r24, r20
   104b0:	38 f0       	brcs	.+14     	; 0x104c0 <__divsf3_pse+0x26>
   104b2:	9f 5f       	subi	r25, 0xFF	; 255
   104b4:	5f 4f       	sbci	r21, 0xFF	; 255
   104b6:	22 0f       	add	r18, r18
   104b8:	33 1f       	adc	r19, r19
   104ba:	44 1f       	adc	r20, r20
   104bc:	aa 1f       	adc	r26, r26
   104be:	a9 f3       	breq	.-22     	; 0x104aa <__divsf3_pse+0x10>
   104c0:	33 d0       	rcall	.+102    	; 0x10528 <__divsf3_pse+0x8e>
   104c2:	0e 2e       	mov	r0, r30
   104c4:	3a f0       	brmi	.+14     	; 0x104d4 <__divsf3_pse+0x3a>
   104c6:	e0 e8       	ldi	r30, 0x80	; 128
   104c8:	30 d0       	rcall	.+96     	; 0x1052a <__divsf3_pse+0x90>
   104ca:	91 50       	subi	r25, 0x01	; 1
   104cc:	50 40       	sbci	r21, 0x00	; 0
   104ce:	e6 95       	lsr	r30
   104d0:	00 1c       	adc	r0, r0
   104d2:	ca f7       	brpl	.-14     	; 0x104c6 <__divsf3_pse+0x2c>
   104d4:	29 d0       	rcall	.+82     	; 0x10528 <__divsf3_pse+0x8e>
   104d6:	fe 2f       	mov	r31, r30
   104d8:	27 d0       	rcall	.+78     	; 0x10528 <__divsf3_pse+0x8e>
   104da:	66 0f       	add	r22, r22
   104dc:	77 1f       	adc	r23, r23
   104de:	88 1f       	adc	r24, r24
   104e0:	bb 1f       	adc	r27, r27
   104e2:	26 17       	cp	r18, r22
   104e4:	37 07       	cpc	r19, r23
   104e6:	48 07       	cpc	r20, r24
   104e8:	ab 07       	cpc	r26, r27
   104ea:	b0 e8       	ldi	r27, 0x80	; 128
   104ec:	09 f0       	breq	.+2      	; 0x104f0 <__divsf3_pse+0x56>
   104ee:	bb 0b       	sbc	r27, r27
   104f0:	80 2d       	mov	r24, r0
   104f2:	bf 01       	movw	r22, r30
   104f4:	ff 27       	eor	r31, r31
   104f6:	93 58       	subi	r25, 0x83	; 131
   104f8:	5f 4f       	sbci	r21, 0xFF	; 255
   104fa:	2a f0       	brmi	.+10     	; 0x10506 <__divsf3_pse+0x6c>
   104fc:	9e 3f       	cpi	r25, 0xFE	; 254
   104fe:	51 05       	cpc	r21, r1
   10500:	68 f0       	brcs	.+26     	; 0x1051c <__divsf3_pse+0x82>
   10502:	f4 cb       	rjmp	.-2072   	; 0xfcec <__fp_inf>
   10504:	3e cc       	rjmp	.-1924   	; 0xfd82 <__fp_szero>
   10506:	5f 3f       	cpi	r21, 0xFF	; 255
   10508:	ec f3       	brlt	.-6      	; 0x10504 <__divsf3_pse+0x6a>
   1050a:	98 3e       	cpi	r25, 0xE8	; 232
   1050c:	dc f3       	brlt	.-10     	; 0x10504 <__divsf3_pse+0x6a>
   1050e:	86 95       	lsr	r24
   10510:	77 95       	ror	r23
   10512:	67 95       	ror	r22
   10514:	b7 95       	ror	r27
   10516:	f7 95       	ror	r31
   10518:	9f 5f       	subi	r25, 0xFF	; 255
   1051a:	c9 f7       	brne	.-14     	; 0x1050e <__divsf3_pse+0x74>
   1051c:	88 0f       	add	r24, r24
   1051e:	91 1d       	adc	r25, r1
   10520:	96 95       	lsr	r25
   10522:	87 95       	ror	r24
   10524:	97 f9       	bld	r25, 7
   10526:	08 95       	ret
   10528:	e1 e0       	ldi	r30, 0x01	; 1
   1052a:	66 0f       	add	r22, r22
   1052c:	77 1f       	adc	r23, r23
   1052e:	88 1f       	adc	r24, r24
   10530:	bb 1f       	adc	r27, r27
   10532:	62 17       	cp	r22, r18
   10534:	73 07       	cpc	r23, r19
   10536:	84 07       	cpc	r24, r20
   10538:	ba 07       	cpc	r27, r26
   1053a:	20 f0       	brcs	.+8      	; 0x10544 <__divsf3_pse+0xaa>
   1053c:	62 1b       	sub	r22, r18
   1053e:	73 0b       	sbc	r23, r19
   10540:	84 0b       	sbc	r24, r20
   10542:	ba 0b       	sbc	r27, r26
   10544:	ee 1f       	adc	r30, r30
   10546:	88 f7       	brcc	.-30     	; 0x1052a <__divsf3_pse+0x90>
   10548:	e0 95       	com	r30
   1054a:	08 95       	ret

0001054c <__fixsfsi>:
   1054c:	04 d0       	rcall	.+8      	; 0x10556 <__fixunssfsi>
   1054e:	68 94       	set
   10550:	b1 11       	cpse	r27, r1
   10552:	17 cc       	rjmp	.-2002   	; 0xfd82 <__fp_szero>
   10554:	08 95       	ret

00010556 <__fixunssfsi>:
   10556:	fa db       	rcall	.-2060   	; 0xfd4c <__fp_splitA>
   10558:	88 f0       	brcs	.+34     	; 0x1057c <__fixunssfsi+0x26>
   1055a:	9f 57       	subi	r25, 0x7F	; 127
   1055c:	90 f0       	brcs	.+36     	; 0x10582 <__fixunssfsi+0x2c>
   1055e:	b9 2f       	mov	r27, r25
   10560:	99 27       	eor	r25, r25
   10562:	b7 51       	subi	r27, 0x17	; 23
   10564:	a0 f0       	brcs	.+40     	; 0x1058e <__fixunssfsi+0x38>
   10566:	d1 f0       	breq	.+52     	; 0x1059c <__fixunssfsi+0x46>
   10568:	66 0f       	add	r22, r22
   1056a:	77 1f       	adc	r23, r23
   1056c:	88 1f       	adc	r24, r24
   1056e:	99 1f       	adc	r25, r25
   10570:	1a f0       	brmi	.+6      	; 0x10578 <__fixunssfsi+0x22>
   10572:	ba 95       	dec	r27
   10574:	c9 f7       	brne	.-14     	; 0x10568 <__fixunssfsi+0x12>
   10576:	12 c0       	rjmp	.+36     	; 0x1059c <__fixunssfsi+0x46>
   10578:	b1 30       	cpi	r27, 0x01	; 1
   1057a:	81 f0       	breq	.+32     	; 0x1059c <__fixunssfsi+0x46>
   1057c:	01 dc       	rcall	.-2046   	; 0xfd80 <__fp_zero>
   1057e:	b1 e0       	ldi	r27, 0x01	; 1
   10580:	08 95       	ret
   10582:	fe cb       	rjmp	.-2052   	; 0xfd80 <__fp_zero>
   10584:	67 2f       	mov	r22, r23
   10586:	78 2f       	mov	r23, r24
   10588:	88 27       	eor	r24, r24
   1058a:	b8 5f       	subi	r27, 0xF8	; 248
   1058c:	39 f0       	breq	.+14     	; 0x1059c <__fixunssfsi+0x46>
   1058e:	b9 3f       	cpi	r27, 0xF9	; 249
   10590:	cc f3       	brlt	.-14     	; 0x10584 <__fixunssfsi+0x2e>
   10592:	86 95       	lsr	r24
   10594:	77 95       	ror	r23
   10596:	67 95       	ror	r22
   10598:	b3 95       	inc	r27
   1059a:	d9 f7       	brne	.-10     	; 0x10592 <__fixunssfsi+0x3c>
   1059c:	3e f4       	brtc	.+14     	; 0x105ac <__fixunssfsi+0x56>
   1059e:	90 95       	com	r25
   105a0:	80 95       	com	r24
   105a2:	70 95       	com	r23
   105a4:	61 95       	neg	r22
   105a6:	7f 4f       	sbci	r23, 0xFF	; 255
   105a8:	8f 4f       	sbci	r24, 0xFF	; 255
   105aa:	9f 4f       	sbci	r25, 0xFF	; 255
   105ac:	08 95       	ret

000105ae <__eerd_block_m2560>:
   105ae:	dc 01       	movw	r26, r24
   105b0:	cb 01       	movw	r24, r22

000105b2 <__eerd_blraw_m2560>:
   105b2:	fc 01       	movw	r30, r24
   105b4:	f9 99       	sbic	0x1f, 1	; 31
   105b6:	fe cf       	rjmp	.-4      	; 0x105b4 <__eerd_blraw_m2560+0x2>
   105b8:	06 c0       	rjmp	.+12     	; 0x105c6 <__eerd_blraw_m2560+0x14>
   105ba:	f2 bd       	out	0x22, r31	; 34
   105bc:	e1 bd       	out	0x21, r30	; 33
   105be:	f8 9a       	sbi	0x1f, 0	; 31
   105c0:	31 96       	adiw	r30, 0x01	; 1
   105c2:	00 b4       	in	r0, 0x20	; 32
   105c4:	0d 92       	st	X+, r0
   105c6:	41 50       	subi	r20, 0x01	; 1
   105c8:	50 40       	sbci	r21, 0x00	; 0
   105ca:	b8 f7       	brcc	.-18     	; 0x105ba <__eerd_blraw_m2560+0x8>
   105cc:	08 95       	ret

000105ce <__eerd_byte_m2560>:
   105ce:	f9 99       	sbic	0x1f, 1	; 31
   105d0:	fe cf       	rjmp	.-4      	; 0x105ce <__eerd_byte_m2560>
   105d2:	92 bd       	out	0x22, r25	; 34
   105d4:	81 bd       	out	0x21, r24	; 33
   105d6:	f8 9a       	sbi	0x1f, 0	; 31
   105d8:	99 27       	eor	r25, r25
   105da:	80 b5       	in	r24, 0x20	; 32
   105dc:	08 95       	ret

000105de <__eerd_dword_m2560>:
   105de:	a6 e1       	ldi	r26, 0x16	; 22
   105e0:	b0 e0       	ldi	r27, 0x00	; 0
   105e2:	44 e0       	ldi	r20, 0x04	; 4
   105e4:	50 e0       	ldi	r21, 0x00	; 0
   105e6:	0c 94 d9 82 	jmp	0x105b2	; 0x105b2 <__eerd_blraw_m2560>

000105ea <__eerd_word_m2560>:
   105ea:	a8 e1       	ldi	r26, 0x18	; 24
   105ec:	b0 e0       	ldi	r27, 0x00	; 0
   105ee:	42 e0       	ldi	r20, 0x02	; 2
   105f0:	50 e0       	ldi	r21, 0x00	; 0
   105f2:	0c 94 d9 82 	jmp	0x105b2	; 0x105b2 <__eerd_blraw_m2560>

000105f6 <__eewr_block_m2560>:
   105f6:	dc 01       	movw	r26, r24
   105f8:	cb 01       	movw	r24, r22
   105fa:	03 c0       	rjmp	.+6      	; 0x10602 <__eewr_block_m2560+0xc>
   105fc:	2d 91       	ld	r18, X+
   105fe:	0e 94 06 83 	call	0x1060c	; 0x1060c <__eewr_r18_m2560>
   10602:	41 50       	subi	r20, 0x01	; 1
   10604:	50 40       	sbci	r21, 0x00	; 0
   10606:	d0 f7       	brcc	.-12     	; 0x105fc <__eewr_block_m2560+0x6>
   10608:	08 95       	ret

0001060a <__eewr_byte_m2560>:
   1060a:	26 2f       	mov	r18, r22

0001060c <__eewr_r18_m2560>:
   1060c:	f9 99       	sbic	0x1f, 1	; 31
   1060e:	fe cf       	rjmp	.-4      	; 0x1060c <__eewr_r18_m2560>
   10610:	1f ba       	out	0x1f, r1	; 31
   10612:	92 bd       	out	0x22, r25	; 34
   10614:	81 bd       	out	0x21, r24	; 33
   10616:	20 bd       	out	0x20, r18	; 32
   10618:	0f b6       	in	r0, 0x3f	; 63
   1061a:	f8 94       	cli
   1061c:	fa 9a       	sbi	0x1f, 2	; 31
   1061e:	f9 9a       	sbi	0x1f, 1	; 31
   10620:	0f be       	out	0x3f, r0	; 63
   10622:	01 96       	adiw	r24, 0x01	; 1
   10624:	08 95       	ret

00010626 <__eewr_dword_m2560>:
   10626:	24 2f       	mov	r18, r20
   10628:	0e 94 06 83 	call	0x1060c	; 0x1060c <__eewr_r18_m2560>
   1062c:	25 2f       	mov	r18, r21
   1062e:	0e 94 06 83 	call	0x1060c	; 0x1060c <__eewr_r18_m2560>
   10632:	0c 94 1b 83 	jmp	0x10636	; 0x10636 <__eewr_word_m2560>

00010636 <__eewr_word_m2560>:
   10636:	0e 94 05 83 	call	0x1060a	; 0x1060a <__eewr_byte_m2560>
   1063a:	27 2f       	mov	r18, r23
   1063c:	0c 94 06 83 	jmp	0x1060c	; 0x1060c <__eewr_r18_m2560>

00010640 <__ctype_isfalse>:
   10640:	99 27       	eor	r25, r25
   10642:	88 27       	eor	r24, r24

00010644 <__ctype_istrue>:
   10644:	08 95       	ret

00010646 <__mulsi3>:
   10646:	62 9f       	mul	r22, r18
   10648:	d0 01       	movw	r26, r0
   1064a:	73 9f       	mul	r23, r19
   1064c:	f0 01       	movw	r30, r0
   1064e:	82 9f       	mul	r24, r18
   10650:	e0 0d       	add	r30, r0
   10652:	f1 1d       	adc	r31, r1
   10654:	64 9f       	mul	r22, r20
   10656:	e0 0d       	add	r30, r0
   10658:	f1 1d       	adc	r31, r1
   1065a:	92 9f       	mul	r25, r18
   1065c:	f0 0d       	add	r31, r0
   1065e:	83 9f       	mul	r24, r19
   10660:	f0 0d       	add	r31, r0
   10662:	74 9f       	mul	r23, r20
   10664:	f0 0d       	add	r31, r0
   10666:	65 9f       	mul	r22, r21
   10668:	f0 0d       	add	r31, r0
   1066a:	99 27       	eor	r25, r25
   1066c:	72 9f       	mul	r23, r18
   1066e:	b0 0d       	add	r27, r0
   10670:	e1 1d       	adc	r30, r1
   10672:	f9 1f       	adc	r31, r25
   10674:	63 9f       	mul	r22, r19
   10676:	b0 0d       	add	r27, r0
   10678:	e1 1d       	adc	r30, r1
   1067a:	f9 1f       	adc	r31, r25
   1067c:	bd 01       	movw	r22, r26
   1067e:	cf 01       	movw	r24, r30
   10680:	11 24       	eor	r1, r1
   10682:	08 95       	ret

00010684 <__udivmodqi4>:
   10684:	99 1b       	sub	r25, r25
   10686:	79 e0       	ldi	r23, 0x09	; 9
   10688:	04 c0       	rjmp	.+8      	; 0x10692 <__udivmodqi4_ep>

0001068a <__udivmodqi4_loop>:
   1068a:	99 1f       	adc	r25, r25
   1068c:	96 17       	cp	r25, r22
   1068e:	08 f0       	brcs	.+2      	; 0x10692 <__udivmodqi4_ep>
   10690:	96 1b       	sub	r25, r22

00010692 <__udivmodqi4_ep>:
   10692:	88 1f       	adc	r24, r24
   10694:	7a 95       	dec	r23
   10696:	c9 f7       	brne	.-14     	; 0x1068a <__udivmodqi4_loop>
   10698:	80 95       	com	r24
   1069a:	08 95       	ret

0001069c <__udivmodhi4>:
   1069c:	aa 1b       	sub	r26, r26
   1069e:	bb 1b       	sub	r27, r27
   106a0:	51 e1       	ldi	r21, 0x11	; 17
   106a2:	07 c0       	rjmp	.+14     	; 0x106b2 <__udivmodhi4_ep>

000106a4 <__udivmodhi4_loop>:
   106a4:	aa 1f       	adc	r26, r26
   106a6:	bb 1f       	adc	r27, r27
   106a8:	a6 17       	cp	r26, r22
   106aa:	b7 07       	cpc	r27, r23
   106ac:	10 f0       	brcs	.+4      	; 0x106b2 <__udivmodhi4_ep>
   106ae:	a6 1b       	sub	r26, r22
   106b0:	b7 0b       	sbc	r27, r23

000106b2 <__udivmodhi4_ep>:
   106b2:	88 1f       	adc	r24, r24
   106b4:	99 1f       	adc	r25, r25
   106b6:	5a 95       	dec	r21
   106b8:	a9 f7       	brne	.-22     	; 0x106a4 <__udivmodhi4_loop>
   106ba:	80 95       	com	r24
   106bc:	90 95       	com	r25
   106be:	bc 01       	movw	r22, r24
   106c0:	cd 01       	movw	r24, r26
   106c2:	08 95       	ret

000106c4 <__divmodhi4>:
   106c4:	97 fb       	bst	r25, 7
   106c6:	09 2e       	mov	r0, r25
   106c8:	07 26       	eor	r0, r23
   106ca:	0a d0       	rcall	.+20     	; 0x106e0 <__divmodhi4_neg1>
   106cc:	77 fd       	sbrc	r23, 7
   106ce:	04 d0       	rcall	.+8      	; 0x106d8 <__divmodhi4_neg2>
   106d0:	e5 df       	rcall	.-54     	; 0x1069c <__udivmodhi4>
   106d2:	06 d0       	rcall	.+12     	; 0x106e0 <__divmodhi4_neg1>
   106d4:	00 20       	and	r0, r0
   106d6:	1a f4       	brpl	.+6      	; 0x106de <__divmodhi4_exit>

000106d8 <__divmodhi4_neg2>:
   106d8:	70 95       	com	r23
   106da:	61 95       	neg	r22
   106dc:	7f 4f       	sbci	r23, 0xFF	; 255

000106de <__divmodhi4_exit>:
   106de:	08 95       	ret

000106e0 <__divmodhi4_neg1>:
   106e0:	f6 f7       	brtc	.-4      	; 0x106de <__divmodhi4_exit>
   106e2:	90 95       	com	r25
   106e4:	81 95       	neg	r24
   106e6:	9f 4f       	sbci	r25, 0xFF	; 255
   106e8:	08 95       	ret

000106ea <__udivmodsi4>:
   106ea:	a1 e2       	ldi	r26, 0x21	; 33
   106ec:	1a 2e       	mov	r1, r26
   106ee:	aa 1b       	sub	r26, r26
   106f0:	bb 1b       	sub	r27, r27
   106f2:	fd 01       	movw	r30, r26
   106f4:	0d c0       	rjmp	.+26     	; 0x10710 <__udivmodsi4_ep>

000106f6 <__udivmodsi4_loop>:
   106f6:	aa 1f       	adc	r26, r26
   106f8:	bb 1f       	adc	r27, r27
   106fa:	ee 1f       	adc	r30, r30
   106fc:	ff 1f       	adc	r31, r31
   106fe:	a2 17       	cp	r26, r18
   10700:	b3 07       	cpc	r27, r19
   10702:	e4 07       	cpc	r30, r20
   10704:	f5 07       	cpc	r31, r21
   10706:	20 f0       	brcs	.+8      	; 0x10710 <__udivmodsi4_ep>
   10708:	a2 1b       	sub	r26, r18
   1070a:	b3 0b       	sbc	r27, r19
   1070c:	e4 0b       	sbc	r30, r20
   1070e:	f5 0b       	sbc	r31, r21

00010710 <__udivmodsi4_ep>:
   10710:	66 1f       	adc	r22, r22
   10712:	77 1f       	adc	r23, r23
   10714:	88 1f       	adc	r24, r24
   10716:	99 1f       	adc	r25, r25
   10718:	1a 94       	dec	r1
   1071a:	69 f7       	brne	.-38     	; 0x106f6 <__udivmodsi4_loop>
   1071c:	60 95       	com	r22
   1071e:	70 95       	com	r23
   10720:	80 95       	com	r24
   10722:	90 95       	com	r25
   10724:	9b 01       	movw	r18, r22
   10726:	ac 01       	movw	r20, r24
   10728:	bd 01       	movw	r22, r26
   1072a:	cf 01       	movw	r24, r30
   1072c:	08 95       	ret

0001072e <__divmodsi4>:
   1072e:	97 fb       	bst	r25, 7
   10730:	09 2e       	mov	r0, r25
   10732:	05 26       	eor	r0, r21
   10734:	0e d0       	rcall	.+28     	; 0x10752 <__divmodsi4_neg1>
   10736:	57 fd       	sbrc	r21, 7
   10738:	04 d0       	rcall	.+8      	; 0x10742 <__divmodsi4_neg2>
   1073a:	d7 df       	rcall	.-82     	; 0x106ea <__udivmodsi4>
   1073c:	0a d0       	rcall	.+20     	; 0x10752 <__divmodsi4_neg1>
   1073e:	00 1c       	adc	r0, r0
   10740:	38 f4       	brcc	.+14     	; 0x10750 <__divmodsi4_exit>

00010742 <__divmodsi4_neg2>:
   10742:	50 95       	com	r21
   10744:	40 95       	com	r20
   10746:	30 95       	com	r19
   10748:	21 95       	neg	r18
   1074a:	3f 4f       	sbci	r19, 0xFF	; 255
   1074c:	4f 4f       	sbci	r20, 0xFF	; 255
   1074e:	5f 4f       	sbci	r21, 0xFF	; 255

00010750 <__divmodsi4_exit>:
   10750:	08 95       	ret

00010752 <__divmodsi4_neg1>:
   10752:	f6 f7       	brtc	.-4      	; 0x10750 <__divmodsi4_exit>
   10754:	90 95       	com	r25
   10756:	80 95       	com	r24
   10758:	70 95       	com	r23
   1075a:	61 95       	neg	r22
   1075c:	7f 4f       	sbci	r23, 0xFF	; 255
   1075e:	8f 4f       	sbci	r24, 0xFF	; 255
   10760:	9f 4f       	sbci	r25, 0xFF	; 255
   10762:	08 95       	ret

00010764 <_exit>:
   10764:	f8 94       	cli

00010766 <__stop_program>:
   10766:	ff cf       	rjmp	.-2      	; 0x10766 <__stop_program>
