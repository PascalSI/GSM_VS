
vmd2_3.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000da  00800200  00010550  00010604  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00010550  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000952  008002da  008002da  000106de  2**0
                  ALLOC
  3 .eeprom       00000140  00810000  00810000  000106de  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .debug_aranges 00000020  00000000  00000000  0001081e  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 00002ec6  00000000  00000000  0001083e  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000f73b  00000000  00000000  00013704  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000072a  00000000  00000000  00022e3f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00008c04  00000000  00000000  00023569  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000012b0  00000000  00000000  0002c170  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00003749  00000000  00000000  0002d420  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000084aa  00000000  00000000  00030b69  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000010c0  00000000  00000000  00039013  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 ec 18 	jmp	0x31d8	; 0x31d8 <__ctors_end>
       4:	0c 94 0d 19 	jmp	0x321a	; 0x321a <__bad_interrupt>
       8:	0c 94 0d 19 	jmp	0x321a	; 0x321a <__bad_interrupt>
       c:	0c 94 0d 19 	jmp	0x321a	; 0x321a <__bad_interrupt>
      10:	0c 94 0d 19 	jmp	0x321a	; 0x321a <__bad_interrupt>
      14:	0c 94 0d 19 	jmp	0x321a	; 0x321a <__bad_interrupt>
      18:	0c 94 0d 19 	jmp	0x321a	; 0x321a <__bad_interrupt>
      1c:	0c 94 0d 19 	jmp	0x321a	; 0x321a <__bad_interrupt>
      20:	0c 94 0d 19 	jmp	0x321a	; 0x321a <__bad_interrupt>
      24:	0c 94 0d 19 	jmp	0x321a	; 0x321a <__bad_interrupt>
      28:	0c 94 0d 19 	jmp	0x321a	; 0x321a <__bad_interrupt>
      2c:	0c 94 0d 19 	jmp	0x321a	; 0x321a <__bad_interrupt>
      30:	0c 94 0d 19 	jmp	0x321a	; 0x321a <__bad_interrupt>
      34:	0c 94 b8 28 	jmp	0x5170	; 0x5170 <__vector_13>
      38:	0c 94 0d 19 	jmp	0x321a	; 0x321a <__bad_interrupt>
      3c:	0c 94 0d 19 	jmp	0x321a	; 0x321a <__bad_interrupt>
      40:	0c 94 0d 19 	jmp	0x321a	; 0x321a <__bad_interrupt>
      44:	0c 94 5c 1d 	jmp	0x3ab8	; 0x3ab8 <__vector_17>
      48:	0c 94 85 26 	jmp	0x4d0a	; 0x4d0a <__vector_18>
      4c:	0c 94 0d 19 	jmp	0x321a	; 0x321a <__bad_interrupt>
      50:	0c 94 0d 19 	jmp	0x321a	; 0x321a <__bad_interrupt>
      54:	0c 94 86 28 	jmp	0x510c	; 0x510c <__vector_21>
      58:	0c 94 0d 19 	jmp	0x321a	; 0x321a <__bad_interrupt>
      5c:	0c 94 0d 19 	jmp	0x321a	; 0x321a <__bad_interrupt>
      60:	0c 94 0d 19 	jmp	0x321a	; 0x321a <__bad_interrupt>
      64:	0c 94 eb 39 	jmp	0x73d6	; 0x73d6 <__vector_25>
      68:	0c 94 3f 3a 	jmp	0x747e	; 0x747e <__vector_26>
      6c:	0c 94 15 3a 	jmp	0x742a	; 0x742a <__vector_27>
      70:	0c 94 0d 19 	jmp	0x321a	; 0x321a <__bad_interrupt>
      74:	0c 94 0d 19 	jmp	0x321a	; 0x321a <__bad_interrupt>
      78:	0c 94 0d 19 	jmp	0x321a	; 0x321a <__bad_interrupt>
      7c:	0c 94 0d 19 	jmp	0x321a	; 0x321a <__bad_interrupt>
      80:	0c 94 0d 19 	jmp	0x321a	; 0x321a <__bad_interrupt>
      84:	0c 94 0d 19 	jmp	0x321a	; 0x321a <__bad_interrupt>
      88:	0c 94 0d 19 	jmp	0x321a	; 0x321a <__bad_interrupt>
      8c:	0c 94 0d 19 	jmp	0x321a	; 0x321a <__bad_interrupt>
      90:	0c 94 69 3a 	jmp	0x74d2	; 0x74d2 <__vector_36>
      94:	0c 94 bd 3a 	jmp	0x757a	; 0x757a <__vector_37>
      98:	0c 94 93 3a 	jmp	0x7526	; 0x7526 <__vector_38>
      9c:	0c 94 0d 19 	jmp	0x321a	; 0x321a <__bad_interrupt>
      a0:	0c 94 0d 19 	jmp	0x321a	; 0x321a <__bad_interrupt>
      a4:	0c 94 0d 19 	jmp	0x321a	; 0x321a <__bad_interrupt>
      a8:	0c 94 ec 28 	jmp	0x51d8	; 0x51d8 <__vector_42>
      ac:	0c 94 0d 19 	jmp	0x321a	; 0x321a <__bad_interrupt>
      b0:	0c 94 0d 19 	jmp	0x321a	; 0x321a <__bad_interrupt>
      b4:	0c 94 0d 19 	jmp	0x321a	; 0x321a <__bad_interrupt>
      b8:	0c 94 0d 19 	jmp	0x321a	; 0x321a <__bad_interrupt>
      bc:	0c 94 0d 19 	jmp	0x321a	; 0x321a <__bad_interrupt>
      c0:	0c 94 0d 19 	jmp	0x321a	; 0x321a <__bad_interrupt>
      c4:	0c 94 0d 19 	jmp	0x321a	; 0x321a <__bad_interrupt>
      c8:	0c 94 0d 19 	jmp	0x321a	; 0x321a <__bad_interrupt>
      cc:	0c 94 37 3b 	jmp	0x766e	; 0x766e <__vector_51>
      d0:	0c 94 e7 3a 	jmp	0x75ce	; 0x75ce <__vector_52>
      d4:	0c 94 0f 3b 	jmp	0x761e	; 0x761e <__vector_53>
      d8:	0c 94 0d 19 	jmp	0x321a	; 0x321a <__bad_interrupt>
      dc:	0c 94 0d 19 	jmp	0x321a	; 0x321a <__bad_interrupt>
      e0:	0c 94 0d 19 	jmp	0x321a	; 0x321a <__bad_interrupt>
      e4:	8f 50       	subi	r24, 0x0F	; 15
      e6:	b5 50       	subi	r27, 0x05	; 5
      e8:	c6 50       	subi	r28, 0x06	; 6
      ea:	d9 50       	subi	r29, 0x09	; 9
      ec:	8f 50       	subi	r24, 0x0F	; 15
      ee:	b5 50       	subi	r27, 0x05	; 5
      f0:	19 50       	subi	r17, 0x09	; 9
      f2:	ed 50       	subi	r30, 0x0D	; 13
      f4:	fd 50       	subi	r31, 0x0D	; 13
      f6:	0d 51       	subi	r16, 0x1D	; 29
      f8:	20 51       	subi	r18, 0x10	; 16
      fa:	ed 50       	subi	r30, 0x0D	; 13
      fc:	fd 50       	subi	r31, 0x0D	; 13
      fe:	33 51       	subi	r19, 0x13	; 19
     100:	33 51       	subi	r19, 0x13	; 19
     102:	19 50       	subi	r17, 0x09	; 9
     104:	19 50       	subi	r17, 0x09	; 9
     106:	19 50       	subi	r17, 0x09	; 9
     108:	19 50       	subi	r17, 0x09	; 9
     10a:	19 50       	subi	r17, 0x09	; 9
     10c:	19 50       	subi	r17, 0x09	; 9
     10e:	19 50       	subi	r17, 0x09	; 9
     110:	19 50       	subi	r17, 0x09	; 9
     112:	19 50       	subi	r17, 0x09	; 9
     114:	19 50       	subi	r17, 0x09	; 9
     116:	19 50       	subi	r17, 0x09	; 9
     118:	19 50       	subi	r17, 0x09	; 9
     11a:	19 50       	subi	r17, 0x09	; 9
     11c:	19 50       	subi	r17, 0x09	; 9
     11e:	41 51       	subi	r20, 0x11	; 17
     120:	4f 51       	subi	r20, 0x1F	; 31
     122:	5e 51       	subi	r21, 0x1E	; 30
     124:	6f 51       	subi	r22, 0x1F	; 31
     126:	5f 54       	subi	r21, 0x4F	; 79
     128:	7e 54       	subi	r23, 0x4E	; 78
     12a:	9f 54       	subi	r25, 0x4F	; 79
     12c:	c2 54       	subi	r28, 0x42	; 66
     12e:	5f 54       	subi	r21, 0x4F	; 79
     130:	7e 54       	subi	r23, 0x4E	; 78
     132:	21 54       	subi	r18, 0x41	; 65
     134:	e7 54       	subi	r30, 0x47	; 71
     136:	05 55       	subi	r16, 0x55	; 85
     138:	24 55       	subi	r18, 0x54	; 84
     13a:	46 55       	subi	r20, 0x56	; 86
     13c:	e7 54       	subi	r30, 0x47	; 71
     13e:	05 55       	subi	r16, 0x55	; 85
     140:	69 55       	subi	r22, 0x59	; 89
     142:	69 55       	subi	r22, 0x59	; 89
     144:	21 54       	subi	r18, 0x41	; 65
     146:	71 55       	subi	r23, 0x51	; 81
     148:	ea 53       	subi	r30, 0x3A	; 58
     14a:	a8 55       	subi	r26, 0x58	; 88
     14c:	df 55       	subi	r29, 0x5F	; 95
     14e:	71 55       	subi	r23, 0x51	; 81
     150:	ea 53       	subi	r30, 0x3A	; 58
     152:	21 54       	subi	r18, 0x41	; 65
     154:	21 54       	subi	r18, 0x41	; 65
     156:	21 54       	subi	r18, 0x41	; 65
     158:	1c 56       	subi	r17, 0x6C	; 108
     15a:	46 56       	subi	r20, 0x66	; 102
     15c:	1c 56       	subi	r17, 0x6C	; 108
     15e:	46 56       	subi	r20, 0x66	; 102
     160:	5f 54       	subi	r21, 0x4F	; 79
     162:	7e 54       	subi	r23, 0x4E	; 78
     164:	70 56       	subi	r23, 0x60	; 96
     166:	81 56       	subi	r24, 0x61	; 97
     168:	98 56       	subi	r25, 0x68	; 104
     16a:	3d 54       	subi	r19, 0x4D	; 77
     16c:	78 59       	subi	r23, 0x98	; 152
     16e:	78 59       	subi	r23, 0x98	; 152
     170:	2f 59       	subi	r18, 0x9F	; 159
     172:	2f 59       	subi	r18, 0x9F	; 159
     174:	78 59       	subi	r23, 0x98	; 152
     176:	78 59       	subi	r23, 0x98	; 152
     178:	3b 58       	subi	r19, 0x8B	; 139
     17a:	78 59       	subi	r23, 0x98	; 152
     17c:	78 59       	subi	r23, 0x98	; 152
     17e:	2f 59       	subi	r18, 0x9F	; 159
     180:	2f 59       	subi	r18, 0x9F	; 159
     182:	78 59       	subi	r23, 0x98	; 152
     184:	78 59       	subi	r23, 0x98	; 152
     186:	0b 59       	subi	r16, 0x9B	; 155
     188:	0b 59       	subi	r16, 0x9B	; 155
     18a:	3b 58       	subi	r19, 0x8B	; 139
     18c:	f3 58       	subi	r31, 0x83	; 131
     18e:	f3 58       	subi	r31, 0x83	; 131
     190:	f3 58       	subi	r31, 0x83	; 131
     192:	f3 58       	subi	r31, 0x83	; 131
     194:	f3 58       	subi	r31, 0x83	; 131
     196:	f3 58       	subi	r31, 0x83	; 131
     198:	3b 58       	subi	r19, 0x8B	; 139
     19a:	3b 58       	subi	r19, 0x8B	; 139
     19c:	3b 58       	subi	r19, 0x8B	; 139
     19e:	f3 58       	subi	r31, 0x83	; 131
     1a0:	f3 58       	subi	r31, 0x83	; 131
     1a2:	f3 58       	subi	r31, 0x83	; 131
     1a4:	f3 58       	subi	r31, 0x83	; 131
     1a6:	d5 58       	subi	r29, 0x85	; 133
     1a8:	d5 58       	subi	r29, 0x85	; 133
     1aa:	b8 58       	subi	r27, 0x88	; 136
     1ac:	b8 58       	subi	r27, 0x88	; 136
     1ae:	80 58       	subi	r24, 0x80	; 128
     1b0:	80 58       	subi	r24, 0x80	; 128
     1b2:	60 5c       	subi	r22, 0xC0	; 192
     1b4:	57 5c       	subi	r21, 0xC7	; 199
     1b6:	4f 5c       	subi	r20, 0xCF	; 207
     1b8:	44 5c       	subi	r20, 0xC4	; 196
     1ba:	3e 5c       	subi	r19, 0xCE	; 206
     1bc:	35 5c       	subi	r19, 0xC5	; 197
     1be:	2c 5c       	subi	r18, 0xCC	; 204
     1c0:	26 5c       	subi	r18, 0xC6	; 198
     1c2:	1e 5c       	subi	r17, 0xCE	; 206
     1c4:	18 5c       	subi	r17, 0xC8	; 200
     1c6:	10 5c       	subi	r17, 0xC0	; 192
     1c8:	0a 5c       	subi	r16, 0xCA	; 202
     1ca:	02 5c       	subi	r16, 0xC2	; 194
     1cc:	26 5c       	subi	r18, 0xC6	; 198
     1ce:	0a 5c       	subi	r16, 0xCA	; 202
     1d0:	f9 5b       	subi	r31, 0xB9	; 185
     1d2:	f2 5b       	subi	r31, 0xB2	; 178
     1d4:	eb 5b       	subi	r30, 0xBB	; 187
     1d6:	e4 5b       	subi	r30, 0xB4	; 180
     1d8:	dd 5b       	subi	r29, 0xBD	; 189
     1da:	d6 5b       	subi	r29, 0xB6	; 182
     1dc:	cf 5b       	subi	r28, 0xBF	; 191
     1de:	f2 5b       	subi	r31, 0xB2	; 178
     1e0:	d6 5b       	subi	r29, 0xB6	; 182
     1e2:	c6 5b       	subi	r28, 0xB6	; 182
     1e4:	bf 5b       	subi	r27, 0xBF	; 191
     1e6:	b1 5b       	subi	r27, 0xB1	; 177
     1e8:	aa 5b       	subi	r26, 0xBA	; 186
     1ea:	9c 5b       	subi	r25, 0xBC	; 188
     1ec:	7c 5b       	subi	r23, 0xBC	; 188
     1ee:	8b 5b       	subi	r24, 0xBB	; 187
     1f0:	55 5b       	subi	r21, 0xB5	; 181
     1f2:	08 5b       	subi	r16, 0xB8	; 184
     1f4:	50 5b       	subi	r21, 0xB0	; 176
     1f6:	42 5b       	subi	r20, 0xB2	; 178
     1f8:	6f 67       	ori	r22, 0x7F	; 127
     1fa:	61 67       	ori	r22, 0x71	; 113
     1fc:	55 67       	ori	r21, 0x75	; 117
     1fe:	c6 61       	ori	r28, 0x16	; 22
     200:	f9 61       	ori	r31, 0x19	; 25
     202:	b6 67       	ori	r27, 0x76	; 118
     204:	a5 67       	ori	r26, 0x75	; 117
     206:	47 67       	ori	r20, 0x77	; 119
     208:	3b 67       	ori	r19, 0x7B	; 123
     20a:	2d 67       	ori	r18, 0x7D	; 125
     20c:	21 67       	ori	r18, 0x71	; 113
     20e:	13 67       	ori	r17, 0x73	; 115
     210:	07 67       	ori	r16, 0x77	; 119
     212:	f9 66       	ori	r31, 0x69	; 105
     214:	ec 66       	ori	r30, 0x6C	; 108
     216:	85 66       	ori	r24, 0x65	; 101
     218:	74 66       	ori	r23, 0x64	; 100
     21a:	5c 66       	ori	r21, 0x6C	; 108
     21c:	43 66       	ori	r20, 0x63	; 99
     21e:	2e 66       	ori	r18, 0x6E	; 110
     220:	bc 65       	ori	r27, 0x5C	; 92
     222:	aa 65       	ori	r26, 0x5A	; 90
     224:	98 65       	ori	r25, 0x58	; 88
     226:	77 65       	ori	r23, 0x57	; 87
     228:	65 65       	ori	r22, 0x55	; 85
     22a:	4d 65       	ori	r20, 0x5D	; 93
     22c:	33 65       	ori	r19, 0x53	; 83
     22e:	0e 65       	ori	r16, 0x5E	; 94
     230:	fc 64       	ori	r31, 0x4C	; 76
     232:	d8 64       	ori	r29, 0x48	; 72
     234:	c6 64       	ori	r28, 0x46	; 70
     236:	e4 68       	ori	r30, 0x84	; 132
     238:	bf 68       	ori	r27, 0x8F	; 143
     23a:	ad 68       	ori	r26, 0x8D	; 141
     23c:	9b 68       	ori	r25, 0x8B	; 139
     23e:	7a 68       	ori	r23, 0x8A	; 138
     240:	62 68       	ori	r22, 0x82	; 130
     242:	50 68       	ori	r21, 0x80	; 128
     244:	44 68       	ori	r20, 0x84	; 132
     246:	36 68       	ori	r19, 0x86	; 134
     248:	1e 68       	ori	r17, 0x8E	; 142
     24a:	2a 68       	ori	r18, 0x8A	; 138
     24c:	0d 68       	ori	r16, 0x8D	; 141
     24e:	fa 67       	ori	r31, 0x7A	; 122
     250:	e9 67       	ori	r30, 0x79	; 121
     252:	d5 67       	ori	r29, 0x75	; 117
     254:	c4 67       	ori	r28, 0x74	; 116
     256:	6d 6a       	ori	r22, 0xAD	; 173
     258:	45 69       	ori	r20, 0x95	; 149
     25a:	3b 69       	ori	r19, 0x9B	; 155
     25c:	2a 69       	ori	r18, 0x9A	; 154
     25e:	1e 69       	ori	r17, 0x9E	; 158
     260:	10 69       	ori	r17, 0x90	; 144
     262:	04 69       	ori	r16, 0x94	; 148
     264:	f6 68       	ori	r31, 0x86	; 134
     266:	b9 69       	ori	r27, 0x99	; 153
     268:	a9 69       	ori	r26, 0x99	; 153
     26a:	9c 69       	ori	r25, 0x9C	; 156
     26c:	5c 69       	ori	r21, 0x9C	; 156
     26e:	d6 69       	ori	r29, 0x96	; 150
     270:	c6 69       	ori	r28, 0x96	; 150
     272:	59 6a       	ori	r21, 0xA9	; 169
     274:	bb 64       	ori	r27, 0x4B	; 75
     276:	7b 64       	ori	r23, 0x4B	; 75
     278:	38 64       	ori	r19, 0x48	; 72
     27a:	2b 64       	ori	r18, 0x4B	; 75
     27c:	18 64       	ori	r17, 0x48	; 72
     27e:	a4 64       	ori	r26, 0x44	; 68
     280:	8a 64       	ori	r24, 0x4A	; 74
     282:	96 64       	ori	r25, 0x46	; 70
     284:	15 63       	ori	r17, 0x35	; 53
     286:	c0 63       	ori	r28, 0x30	; 48
     288:	5a 61       	ori	r21, 0x1A	; 26
     28a:	5a 61       	ori	r21, 0x1A	; 26
     28c:	82 63       	ori	r24, 0x32	; 50
     28e:	78 63       	ori	r23, 0x38	; 56
     290:	21 63       	ori	r18, 0x31	; 49
     292:	f3 63       	ori	r31, 0x33	; 51
     294:	d2 63       	ori	r29, 0x32	; 50
     296:	01 64       	ori	r16, 0x41	; 65
     298:	09 63       	ori	r16, 0x39	; 57
     29a:	f7 62       	ori	r31, 0x27	; 39
     29c:	c5 62       	ori	r28, 0x25	; 37
     29e:	b3 62       	ori	r27, 0x23	; 35
     2a0:	a7 62       	ori	r26, 0x27	; 39
     2a2:	6a 62       	ori	r22, 0x2A	; 42
     2a4:	50 62       	ori	r21, 0x20	; 32
     2a6:	32 62       	ori	r19, 0x22	; 34
     2a8:	24 62       	ori	r18, 0x24	; 36
     2aa:	07 62       	ori	r16, 0x27	; 39
     2ac:	d1 72       	andi	r29, 0x21	; 33
     2ae:	d8 72       	andi	r29, 0x28	; 40
     2b0:	c4 72       	andi	r28, 0x24	; 36
     2b2:	cb 72       	andi	r28, 0x2B	; 43
     2b4:	ba 72       	andi	r27, 0x2A	; 42
     2b6:	c0 72       	andi	r28, 0x20	; 32
     2b8:	ad 72       	andi	r26, 0x2D	; 45
     2ba:	b3 72       	andi	r27, 0x23	; 35
     2bc:	df 72       	andi	r29, 0x2F	; 47
     2be:	a9 72       	andi	r26, 0x29	; 41
     2c0:	91 72       	andi	r25, 0x21	; 33
     2c2:	63 73       	andi	r22, 0x33	; 51
     2c4:	4b 73       	andi	r20, 0x3B	; 59
     2c6:	3f 73       	andi	r19, 0x3F	; 63
     2c8:	27 73       	andi	r18, 0x37	; 55
     2ca:	0b 73       	andi	r16, 0x3B	; 59
     2cc:	e7 72       	andi	r30, 0x27	; 39

000002ce <__c.1790>:
     2ce:	6e 61 6e 00                                         nan.

000002d2 <__c.1788>:
     2d2:	69 6e 66 00                                         inf.

000002d6 <__c.2085>:
     2d6:	63 64 69 6e 6f 70 73 75 78 58 5b 65 66 67 45 46     cdinopsuxX[efgEF
     2e6:	47 00                                               G.

000002e8 <pstr_an>:
     2e8:	61 6e 00                                            an.

000002eb <pstr_nfinity>:
     2eb:	6e 66 69 6e 69 74 79 00                             nfinity.

000002f3 <pwr_m10>:
     2f3:	cd cc cc 3d 0a d7 23 3c 17 b7 d1 38 77 cc 2b 32     ...=..#<...8w.+2
     303:	95 95 e6 24 1f b1 4f 0a                             ...$..O.

0000030b <pwr_p10>:
     30b:	00 00 20 41 00 00 c8 42 00 40 1c 46 20 bc be 4c     .. A...B.@.F ..L
     31b:	ca 1b 0e 5a ae c5 9d 74                             ...Z...t

00000323 <DaysMonth>:
     323:	00 1f 1c 1f 1e 1f 1e 1f 1f 1e 1f 1e 1f              .............

00000330 <Modbus_Map>:
     330:	76 07 20 00 fe 09 20 00 19 0b 04 00 fd 07 50 00     v. ... .......P.

00000340 <BR_Tbl>:
     340:	42 03 ff a0 01 fb cf 00 7d 67 00 3f 44 00 2a 33     B.......}g.?D.*3
     350:	00 1f 22 00 1b 19 00 1b 10 00 1b                    .."........

0000035b <GSM_SIMCOM_SIM900R>:
     35b:	53 49 4d 43 4f 4d 5f 53 49 4d 39 30 30 52 00        SIMCOM_SIM900R.

0000036a <GSM_SIMCOM_SIM800>:
     36a:	53 49 4d 43 4f 4d 5f 53 49 4d 38 30 30 00           SIMCOM_SIM800.

00000378 <GSM_SIMCOM_SIM800C>:
     378:	53 49 4d 43 4f 4d 5f 53 49 4d 38 30 30 43 00        SIMCOM_SIM800C.

00000387 <URC_RDY>:
     387:	52 44 59 00                                         RDY.

0000038b <URC_CFUN>:
     38b:	2b 43 46 55 4e 3a 20 31 00                          +CFUN: 1.

00000394 <URC_CPIN_READY>:
     394:	2b 43 50 49 4e 3a 20 52 45 41 44 59 00              +CPIN: READY.

000003a1 <URC_CALL_READY>:
     3a1:	43 61 6c 6c 20 52 65 61 64 79 00                    Call Ready.

000003ac <URC_SMS_READY>:
     3ac:	53 4d 53 20 52 65 61 64 79 00                       SMS Ready.

000003b6 <URC_REMOTE_IP>:
     3b6:	52 45 4d 4f 54 45 20 49 50 00                       REMOTE IP.

000003c0 <URC_CONNECT>:
     3c0:	43 4f 4e 4e 45 43 54 00                             CONNECT.

000003c8 <URC_RECEIVE>:
     3c8:	2b 52 45 43 45 49 56 45 2c 00                       +RECEIVE,.

000003d2 <URC_CLOSED>:
     3d2:	2c 20 43 4c 4f 53 45 44 00                          , CLOSED.

000003db <URC_PDPDEACT>:
     3db:	2b 50 44 50 20 44 45 41 43 54 00                    +PDP DEACT.

000003e6 <URC_NO_CARRIER>:
     3e6:	4e 4f 20 43 41 52 52 49 45 52 00                    NO CARRIER.

000003f1 <RESP_OK>:
     3f1:	4f 4b 00                                            OK.

000003f4 <RESP_CONNECT>:
     3f4:	43 4f 4e 4e 45 43 54 00                             CONNECT.

000003fc <RESP_CONNECT_OK>:
     3fc:	78 2c 20 43 4f 4e 4e 45 43 54 20 4f 4b 00           x, CONNECT OK.

0000040a <RESP_SERVER_OK>:
     40a:	53 45 52 56 45 52 20 4f 4b 00                       SERVER OK.

00000414 <RESP_SERVER_CLOSE>:
     414:	53 45 52 56 45 52 20 43 4c 4f 53 45 00              SERVER CLOSE.

00000421 <RESP_Invitation>:
     421:	3e 00                                               >.

00000423 <RESP_SEND_OK>:
     423:	78 2c 20 53 45 4e 44 20 4f 4b 00                    x, SEND OK.

0000042e <RESP_CLOSE_OK>:
     42e:	43 4c 4f 53 45 20 4f 4b 00                          CLOSE OK.

00000437 <RESP_CLOSE_OK_FAST>:
     437:	78 2c 20 43 4c 4f 53 45 20 4f 4b 00                 x, CLOSE OK.

00000443 <RESP_CSQ>:
     443:	2b 43 53 51 3a 00                                   +CSQ:.

00000449 <RESP_SHUT_OK>:
     449:	53 48 55 54 20 4f 4b 00                             SHUT OK.

00000451 <RESP_CREC_0>:
     451:	2b 43 52 45 43 3a 20 30 00                          +CREC: 0.

0000045a <ESC_SEQ>:
     45a:	2b 2b 2b 00                                         +++.

0000045e <IDENTIFICATION>:
     45e:	49 44 45 4e 54 49 46 49 43 41 54 49 4f 4e 00        IDENTIFICATION.

0000046d <AT_AT>:
     46d:	41 54 00                                            AT.

00000470 <AT_IPR9600>:
     470:	41 54 2b 49 50 52 3d 39 36 30 30 00                 AT+IPR=9600.

0000047c <AT_W>:
     47c:	41 54 26 57 00                                      AT&W.

00000481 <AT_E0>:
     481:	41 54 45 30 00                                      ATE0.

00000486 <AT_CLCC1>:
     486:	41 54 2b 43 4c 43 43 3d 31 00                       AT+CLCC=1.

00000490 <AT_DDET101>:
     490:	41 54 2b 44 44 45 54 3d 31 2c 30 2c 31 00           AT+DDET=1,0,1.

0000049e <AT_CGMM>:
     49e:	41 54 2b 43 47 4d 4d 00                             AT+CGMM.

000004a6 <AT_CCID>:
     4a6:	41 54 2b 43 43 49 44 00                             AT+CCID.

000004ae <AT_IFC>:
     4ae:	41 54 2b 49 46 43 3d 32 2c 32 00                    AT+IFC=2,2.

000004b9 <ATD101>:
     4b9:	41 54 44 2a 31 30 31 23 00                          ATD*101#.

000004c2 <ATD_PLUS>:
     4c2:	41 54 44 2b 00                                      ATD+.

000004c7 <AT_CUSD101>:
     4c7:	41 54 2b 43 55 53 44 3d 31 2c 22 00                 AT+CUSD=1,".

000004d3 <AT_CMGF>:
     4d3:	41 54 2b 43 4d 47 46 3d 31 00                       AT+CMGF=1.

000004dd <AT_CSMP>:
     4dd:	41 54 2b 43 53 4d 50 3d 31 37 2c 31 36 37 2c 30     AT+CSMP=17,167,0
     4ed:	2c 30 00                                            ,0.

000004f0 <AT_CMGS>:
     4f0:	41 54 2b 43 4d 47 53 3d 22 2b 00                    AT+CMGS="+.

000004fb <AT_CIPMODE_0>:
     4fb:	41 54 2b 43 49 50 4d 4f 44 45 3d 30 00              AT+CIPMODE=0.

00000508 <AT_CIPMODE_1>:
     508:	41 54 2b 43 49 50 4d 4f 44 45 3d 31 00              AT+CIPMODE=1.

00000515 <AT_CIPMUX_0>:
     515:	41 54 2b 43 49 50 4d 55 58 3d 30 00                 AT+CIPMUX=0.

00000521 <AT_CIPMUX_1>:
     521:	41 54 2b 43 49 50 4d 55 58 3d 31 00                 AT+CIPMUX=1.

0000052d <AT_CGATT>:
     52d:	41 54 2b 43 47 41 54 54 3d 31 00                    AT+CGATT=1.

00000538 <AT_CIPCSGP>:
     538:	41 54 2b 43 49 50 43 53 47 50 3d 31 2c 22 00        AT+CIPCSGP=1,".

00000547 <AT_CSTT>:
     547:	41 54 2b 43 53 54 54 00                             AT+CSTT.

0000054f <AT_CIICR>:
     54f:	41 54 2b 43 49 49 43 52 00                          AT+CIICR.

00000558 <AT_CIFSR>:
     558:	41 54 2b 43 49 46 53 52 00                          AT+CIFSR.

00000561 <AT_CIPTKA>:
     561:	41 54 2b 43 49 50 54 4b 41 3d 31 2c 33 30 2c 33     AT+CIPTKA=1,30,3
     571:	30 2c 31 00                                         0,1.

00000575 <AT_CIPSTART>:
     575:	41 54 2b 43 49 50 53 54 41 52 54 3d 22 55 44 50     AT+CIPSTART="UDP
     585:	22 2c 00                                            ",.

00000588 <AT_CIPSTART_TCP_CLIENT>:
     588:	41 54 2b 43 49 50 53 54 41 52 54 3d 22 54 43 50     AT+CIPSTART="TCP
     598:	22 2c 00                                            ",.

0000059b <AT_CIPSERVER>:
     59b:	41 54 2b 43 49 50 53 45 52 56 45 52 3d 31 2c 00     AT+CIPSERVER=1,.

000005ab <AT_SERVERCLOSE>:
     5ab:	41 54 2b 43 49 50 53 45 52 56 45 52 3d 30 00        AT+CIPSERVER=0.

000005ba <AT_CIPSEND>:
     5ba:	41 54 2b 43 49 50 53 45 4e 44 3d 00                 AT+CIPSEND=.

000005c6 <AT_CIPCLOSE_1>:
     5c6:	41 54 2b 43 49 50 43 4c 4f 53 45 3d 78 2c 31 00     AT+CIPCLOSE=x,1.

000005d6 <AT_CIPCLOSE>:
     5d6:	41 54 2b 43 49 50 43 4c 4f 53 45 3d 31 00           AT+CIPCLOSE=1.

000005e4 <AT_CIPSHUT>:
     5e4:	41 54 2b 43 49 50 53 48 55 54 00                    AT+CIPSHUT.

000005ef <AT_CGATT_0>:
     5ef:	41 54 2b 43 47 41 54 54 3d 30 00                    AT+CGATT=0.

000005fa <AT_CSQ>:
     5fa:	41 54 2b 43 53 51 00                                AT+CSQ.

00000601 <ATO>:
     601:	41 54 4f 00                                         ATO.

00000605 <Symbols_P>:
     605:	30 31 32 33 34 35 36 37 38 39 61 62 63 64 65 66     0123456789abcdef
     615:	67 68 69 6a 6b 6c 6d 6e 6f 70 71 72 73 74 75 76     ghijklmnopqrstuv
     625:	77 78 79 7a 41 42 43 44 45 46 47 48 49 4a 4b 4c     wxyzABCDEFGHIJKL
     635:	4d 4e 4f 50 51 52 53 54 55 56 57 58 59 5a e0 e1     MNOPQRSTUVWXYZ..
     645:	e2 e3 e4 e5 b8 ba e6 e7 e8 b3 bf e9 ea eb ec ed     ................
     655:	ee ef f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 fa fb fc fd     ................
     665:	fe ff c0 c1 c2 c3 c4 c5 a8 aa c6 c7 c8 b2 af c9     ................
     675:	ca cb cc cd ce cf d0 d1 d2 d3 d4 d5 d6 d7 d8 d9     ................
     685:	da db dc dd de df 20 2b 2d 3d 3c 3e 24 25 26 2e     ...... +-=<>$%&.
     695:	2c 3f 21 27 40 3a 28 29 22 7c 2a 23 2f 00           ,?!'@:()"|*#/.

000006a3 <OnlyDigits_P>:
     6a3:	30 31 32 33 34 35 36 37 38 39 00                    0123456789.

000006ae <Digits_P>:
     6ae:	30 31 32 33 34 35 36 37 38 39 65 2b 2d 2e 00        0123456789e+-..

000006bd <ThermFami>:
     6bd:	00 00 00 00 00 00                                   ......

000006c3 <TermisLim>:
     6c3:	00 00 00 00 0c fe 08 07 0c fe 08 07 0c fe 70 17     ..............p.
     6d3:	0c fe 70 17 0c fe 70 17 0c fe 70 17 0c fe 08 07     ..p...p...p.....

000006e3 <TermocLim>:
     6e3:	00 00 00 00 30 f8 e0 2e 70 17 50 46 30 f8 4c 1d     ....0...p.PF0.L.
     6f3:	30 f8 70 17                                         0.p.

000006f7 <Fail_Str>:
     6f7:	d1 e1 ee e9 20 00                                   .... .

000006fd <Norm_Str>:
     6fd:	cd ee f0 ec e0 00                                   ......

00000703 <DI_NO_Str>:
     703:	ed e5 f2 20 00                                      ... .

00000708 <DI_OK_Str>:
     708:	ed ee f0 ec 00                                      .....

0000070d <DI_Sta_Tbl>:
     70d:	03 07 08 07                                         ....

00000711 <DI_Op_Str>:
     711:	f0 e0 e7 ec 00                                      .....

00000716 <DI_Cl_Str>:
     716:	e7 e0 ec ea 00                                      .....

0000071b <DI_Tbl>:
     71b:	11 07 16 07                                         ....

0000071f <DI_Inv_Cl_Str>:
     71f:	ed 2e e7 2e 00                                      .....

00000724 <DI_Inv_Op_Str>:
     724:	ed 2e f0 2e 00                                      .....

00000729 <DI_Inv_Tbl>:
     729:	1f 07 24 07                                         ..$.

0000072d <DO_Op_Str>:
     72d:	e2 fb ea eb 00                                      .....

00000732 <DO_Cl_Str>:
     732:	e2 ea eb 20 00                                      ... .

00000737 <DO_Tbl>:
     737:	2d 07 32 07                                         -.2.

0000073b <F_ADC_3>:
     73b:	07 70 07 00 00 00                                   .p....

00000741 <F_ADC_4>:
     741:	07 e3 08 00 00 00                                   ......

00000747 <F_ADC_5>:
     747:	07 b5 06 00 00 00                                   ......

0000074d <List_ADC_Err>:
     74d:	20 2d 2d 2d 20 41 44 43 20 65 72 72 6f 72 73 20      --- ADC errors 
     75d:	2d 2d 2d 20 00 00 00 00 00 00 00 20 52 65 61 64     --- ....... Read
     76d:	20 66 61 69 6c 3a 20 20 20 20 7b 7b 7b 7b 7b 00      fail:    {{{{{.
     77d:	3b 07 00 00 00 00 20 43 61 6c 69 62 72 20 66 61     ;..... Calibr fa
     78d:	69 6c 3a 20 20 7b 7b 7b 7b 7b 00 41 07 00 00 00     il:  {{{{{.A....
     79d:	00 20 43 61 6c 69 62 72 20 62 72 65 61 6b 3a 20     . Calibr break: 
     7ad:	7b 7b 7b 7b 7b 00 47 07 00 00 00 00                 {{{{{.G.....

000007b9 <Menu_ADC_Err>:
     7b9:	4d 07 04 03 00 00 00 00 00 00 00 00 00 00 00 00     M...............
     7c9:	00 00 00 00                                         ....

000007cd <F_ADC_1>:
     7cd:	1d 22 0b 47 24 00                                   .".G$.

000007d3 <F_ADC_2>:
     7d3:	00 b1 06 00 00 00 00 ca 08 00 00 00                 ............

000007df <List_ADC>:
     7df:	20 d0 e5 e6 e8 ec 3a 20 7b 7b 7b 7b 7b 7b 7b 7b      .....: {{{{{{{{
     7ef:	7b 7b 7b 7b 00 cd 07 00 00 00 00 20 c2 f0 e5 ec     {{{{....... ....
     7ff:	ff 3a 7b 7b 30 ec f1 20 ca e0 ed e0 eb 3a 7b 00     .:{{0.. .....:{.
     80f:	d3 07 00 00 00 00 20 2d 20 ca e0 ed e0 eb fb 20     ...... - ...... 
     81f:	2d 20 20 20 20 20 20 20 20 20 00 00 00 00 00 68     -         .....h
     82f:	23 20 2d 20 ca e0 eb e8 e1 f0 ee e2 ea e0 20 2d     # - .......... -
     83f:	20 20 20 20 20 00 00 00 00 00 0c 24 20 2d 20 ce          ......$ - .
     84f:	f8 e8 e1 ea e8 20 2d 20 20 20 20 20 20 20 20 20     ..... -         
     85f:	00 00 00 00 00 b9 07                                .......

00000866 <MenuADC>:
     866:	df 07 05 02 00 00 00 00 00 00 00 00 00 00 00 00     ................
     876:	00 00 00 00                                         ....

0000087a <MsgErr21>:
     87a:	20 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f      _______________
     88a:	5f 5f 5f 20 00 00 00 20 49 6e 74 65 72 6e 61 6c     ___ ... Internal
     89a:	20 65 72 72 6f 72 20 32 31 3a 20 00 00 00 20 20      error 21: ...  
     8aa:	20 20 20 20 41 44 43 20 6f 66 66 20 20 20 20 20         ADC off     
     8ba:	20 20 00 00 00 20 20 20 20 20 20 20 20 20 20 20       ...           
     8ca:	20 20 20 20 20 20 20 20 20 00 00 00 00 00 00 00              .......
	...

000008dc <Therm_Off_Str>:
     8dc:	20 20 20 78 20 20 20 00                                x   .

000008e4 <ADC_Off_Str>:
     8e4:	2d 2d 2d 2d 2d 2d 2d 00                             -------.

000008ec <ThermTbl>:
     8ec:	dc 08 e4 08                                         ....

000008f0 <ThermOff_Str>:
     8f0:	ce f2 ea eb 2e 00                                   ......

000008f6 <TSM100_Str>:
     8f6:	d2 d1 cc 31 30 30 00                                ...100.

000008fd <TSM50_Str>:
     8fd:	d2 d1 cc 35 30 00                                   ...50.

00000903 <TSP100_Str>:
     903:	d2 d1 cf 31 30 30 00                                ...100.

0000090a <TSP50_Str>:
     90a:	d2 d1 cf 35 30 00                                   ...50.

00000910 <Pt100_Str>:
     910:	50 74 31 30 30 00                                   Pt100.

00000916 <Gr21_Str>:
     916:	c3 f0 32 31 00                                      ..21.

0000091b <Gr23_Str>:
     91b:	c3 f0 32 33 00                                      ..23.

00000920 <RTD_Name_List>:
     920:	f0 08 f6 08 fd 08 03 09 0a 09 10 09 16 09 1b 09     ................

00000930 <TC_K_Str>:
     930:	54 58 41 00                                         TXA.

00000934 <TC_B_Str>:
     934:	54 cf d0 00                                         T...

00000938 <TC_J_Str>:
     938:	54 c6 ca 00                                         T...

0000093c <TC_L_Str>:
     93c:	54 58 ca 00                                         TX..

00000940 <TC_Name_List>:
     940:	f0 08 30 09 34 09 38 09 3c 09                       ..0.4.8.<.

0000094a <NoPariStr>:
     94a:	ed e5 f2 00                                         ....

0000094e <EvenPariStr>:
     94e:	f7 e5 f2 ed fb e9 00                                .......

00000955 <OddPariStr>:
     955:	ed e5 f7 e5 f2 ed fb e9 00                          .........

0000095e <MBPariTbl>:
     95e:	4a 09 4e 09 55 09                                   J.N.U.

00000964 <BR_Str1200>:
     964:	31 32 30 30 00                                      1200.

00000969 <BR_Str2400>:
     969:	32 34 30 30 00                                      2400.

0000096e <BR_Str4800>:
     96e:	34 38 30 30 00                                      4800.

00000973 <BR_Str9600>:
     973:	39 36 30 30 00                                      9600.

00000978 <BR_Str14400>:
     978:	31 34 34 30 30 00                                   14400.

0000097e <BR_Str19200>:
     97e:	31 39 32 30 30 00                                   19200.

00000984 <BR_Str28800>:
     984:	32 38 38 30 30 00                                   28800.

0000098a <BR_Str38400>:
     98a:	33 38 34 30 30 00                                   38400.

00000990 <BR_Str57600>:
     990:	35 37 36 30 30 00                                   57600.

00000996 <BaudTbl>:
     996:	64 09 69 09 6e 09 73 09 78 09 7e 09 84 09 8a 09     d.i.n.s.x.~.....
     9a6:	90 09                                               ..

000009a8 <F_MB0_Pari>:
     9a8:	1e 04 00 00 00 00 00 02 00 00 00 a4 70 5e 09 00     ............p^..

000009b8 <F_MB0_Stopbits>:
     9b8:	01 05 00 01 00 00 00 02 00 00 00 a4 70 00 00 00     ............p...

000009c8 <F_MB0_Baud>:
     9c8:	1e 06 00 00 00 00 00 08 00 00 00 2d 70 96 09 00     ...........-p...

000009d8 <MB0_CPT_04>:
     9d8:	0b ee 08 00 00 00 0b f6 08 00 00 00                 ............

000009e4 <MB0_CPT_15>:
     9e4:	0b f0 08 00 00 00 0b f8 08 00 00 00                 ............

000009f0 <MB0_CPT_26>:
     9f0:	0b f2 08 00 00 00 0b fa 08 00 00 00                 ............

000009fc <MB0_CPT_37>:
     9fc:	0b f4 08 00 00 00 0b fc 08 00 00 00                 ............

00000a08 <List_MB0_CPT>:
     a08:	43 50 31 3a 7b 7b 7b 7b 7b 20 20 43 50 35 3a 7b     CP1:{{{{{  CP5:{
     a18:	7b 7b 7b 7b 00 d8 09 00 00 00 00 43 50 32 3a 7b     {{{{.......CP2:{
     a28:	7b 7b 7b 7b 20 20 43 50 36 3a 7b 7b 7b 7b 7b 00     {{{{  CP6:{{{{{.
     a38:	e4 09 00 00 00 00 43 50 33 3a 7b 7b 7b 7b 7b 20     ......CP3:{{{{{ 
     a48:	20 43 50 37 3a 7b 7b 7b 7b 7b 00 f0 09 00 00 00      CP7:{{{{{......
     a58:	00 43 50 34 3a 7b 7b 7b 7b 7b 20 20 43 50 38 3a     .CP4:{{{{{  CP8:
     a68:	7b 7b 7b 7b 7b 00 fc 09 00 00 00 00                 {{{{{.......

00000a74 <M_MB0_CPT>:
     a74:	08 0a 04 03 00 00 00 00 00 00 00 00 e8 3f 00 00     .............?..
     a84:	00 00 00 00                                         ....

00000a88 <L_MB0>:
     a88:	20 2d 2d 2d 2d 20 4d 6f 64 62 75 73 20 30 20 2d      ---- Modbus 0 -
     a98:	2d 2d 2d 20 00 00 00 00 00 00 00 20 d1 f7 e5 f2     --- ....... ....
     aa8:	f7 e8 ea e8 20 28 f1 e1 f0 ee f1 3a 2d 3e 29 00     .... (.....:->).
     ab8:	00 00 00 00 74 0a 20 cf e0 f0 e8 f2 e5 f2 3a 20     ....t. .......: 
     ac8:	7d 7d 7d 7d 7d 7d 7d 7d 20 20 00 00 00 a8 09 00     }}}}}}}}  ......
     ad8:	00 20 d1 f2 ee ef 2d e1 e8 f2 fb 3a 20 7d 20 20     . ....-....: }  
     ae8:	20 20 20 20 20 00 00 00 b8 09 00 00 20 42 41 55          ....... BAU
     af8:	44 3a 20 7d 7d 7d 7d 7d 62 70 73 20 20 20 20 20     D: }}}}}bps     
     b08:	00 00 00 c8 09 00 00                                .......

00000b0f <MenuModbus0>:
     b0f:	88 0a 05 01 00 00 00 00 00 00 00 00 00 00 00 00     ................
     b1f:	00 00 00 00                                         ....

00000b23 <List_Modbus>:
     b23:	20 4d 6f 64 62 75 73 20 30 20 20 20 20 20 20 20      Modbus 0       
     b33:	20 20 20 20 00 00 00 00 00 0f 0b 20 20 20 20 58         .......    X
     b43:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 00                    .
     b53:	00 00 00 00 00 00 20 20 20 20 58 20 20 20 20 20     ......    X     
     b63:	20 20 20 20 20 20 20 20 20 20 00 00 00 00 00 00               ......
     b73:	00 20 20 20 20 58 20 20 20 20 20 20 20 20 20 20     .    X          
     b83:	20 20 20 20 20 00 00 00 00 00 00 00                      .......

00000b8f <MenuModbus>:
     b8f:	23 0b 04 00 00 00 00 00 00 00 00 00 00 00 00 00     #...............
     b9f:	00 00 00 00                                         ....

00000ba3 <N_Str>:
     ba3:	cd e5 f2 00                                         ....

00000ba7 <Y_Str>:
     ba7:	c4 e0 00                                            ...

00000baa <YN_Tbl>:
     baa:	a3 0b a7 0b                                         ....

00000bae <F_SummerTime>:
     bae:	1e 03 00 00 00 00 00 01 00 00 00 00 00 aa 0b 00     ................

00000bbe <F_WDay>:
     bbe:	00 55 06 00 00 00                                   .U....

00000bc4 <F_DateTime>:
     bc4:	04 17 0b 01 00 00 00 1f 00 00 00 c4 23 00 00 00     ............#...
     bd4:	04 85 07 01 00 00 00 0c 00 00 00 ce 23 00 00 00     ............#...
     be4:	04 dc 05 00 00 00 00 63 00 00 00 d8 23 00 00 00     .......c....#...
     bf4:	04 bf 05 00 00 00 00 17 00 00 00 ba 23 00 00 00     ............#...
     c04:	04 4f 06 00 00 00 00 3b 00 00 00 b0 23 00 00 00     .O.....;....#...
     c14:	04 b4 06 00 00 00 00 3b 00 00 00 a6 23 00 00 00     .......;....#...

00000c24 <GSM_CNTL_AUTO_Str>:
     c24:	61 75 74 6f 20 20 00                                auto  .

00000c2b <GSM_CNTL_MANUAL_Str>:
     c2b:	6d 61 6e 75 61 6c 00                                manual.

00000c32 <GSM_CNTL_CONFIG_Str>:
     c32:	63 6f 6e 66 69 67 00                                config.

00000c39 <GSM_ControlList>:
     c39:	24 0c 2b 0c 32 0c                                   $.+.2.

00000c3f <GSM_Not_Recognize_Str>:
     c3f:	6e 6f 74 20 72 65 63 6f 67 00                       not recog.

00000c49 <GSM_SIMCOM_SIM900R_Str>:
     c49:	53 49 4d 39 30 30 52 20 20 00                       SIM900R  .

00000c53 <GSM_SIMCOM_SIM800_Str>:
     c53:	53 49 4d 38 30 30 20 20 20 00                       SIM800   .

00000c5d <GSM_ModemList>:
     c5d:	3f 0c 49 0c 53 0c                                   ?.I.S.

00000c63 <MenuGSM_Modem_State>:
     c63:	1d f1 06 5d 0c 00 00 b3 06 00 00 00                 ...]........

00000c6f <MenuGSM_State>:
     c6f:	00 b3 06 00 00 00                                   ......

00000c75 <MenuGSM_GSM_Cont>:
     c75:	1d 8a 07 00 00 00 00 02 00 00 00 f7 3f 39 0c 00     ............?9..

00000c85 <MenuGSM_GSM_MyIP>:
     c85:	00 e9 08 00 00 00 00 ea 08 00 00 00 00 eb 08 00     ................
     c95:	00 00 00 ec 08 00 00 00                             ........

00000c9d <MenuGSM_ClientIP>:
     c9d:	00 02 0b 00 00 00 00 03 0b 00 00 00 00 04 0b 00     ................
     cad:	00 00 00 05 0b 00 00 00                             ........

00000cb5 <MenuGSM_ActiveCon>:
     cb5:	00 d3 02 00 00 00                                   ......

00000cbb <MenuGSM_FIFOMax>:
     cbb:	00 d1 08 00 00 00                                   ......

00000cc1 <MenuGSM_APN1>:
     cc1:	22 09 00 00 00 00 00 06 00 00 00 00 00 00 00 00     "...............

00000cd1 <MenuGSM_APN2>:
     cd1:	22 1d 00 00 00 00 00 06 00 00 00 00 00 00 00 00     "...............

00000ce1 <MenuGSM_APN_USER_NAME>:
     ce1:	22 59 00 00 00 00 00 06 00 00 00 00 00 00 00 00     "Y..............

00000cf1 <MenuGSM_APN_PASSWORD>:
     cf1:	22 6d 00 00 00 00 00 06 00 00 00 00 00 00 00 00     "m..............

00000d01 <MenuGSM_IPUDP1>:
     d01:	01 81 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     d11:	01 82 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     d21:	01 83 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     d31:	01 84 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00000d41 <MenuGSM_IPUDP2>:
     d41:	01 85 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     d51:	01 86 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     d61:	01 87 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     d71:	01 88 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00000d81 <MenuGSM_IPUDP3>:
     d81:	01 89 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     d91:	01 8a 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     da1:	01 8b 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     db1:	01 8c 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00000dc1 <MenuGSM_IPUDP4>:
     dc1:	01 8d 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     dd1:	01 8e 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     de1:	01 8f 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     df1:	01 90 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00000e01 <MenuGSM_PortUDP1>:
     e01:	08 a1 00 00 00 00 00 ff ff 00 00 00 00 00 00 00     ................

00000e11 <MenuGSM_PortUDP2>:
     e11:	08 a3 00 00 00 00 00 ff ff 00 00 00 00 00 00 00     ................

00000e21 <MenuGSM_PortUDP3>:
     e21:	08 a5 00 00 00 00 00 ff ff 00 00 00 00 00 00 00     ................

00000e31 <MenuGSM_PortUDP4>:
     e31:	08 a7 00 00 00 00 00 ff ff 00 00 00 00 00 00 00     ................

00000e41 <MenuGSM_IPTCP1>:
     e41:	01 b3 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     e51:	01 b4 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     e61:	01 b5 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     e71:	01 b6 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00000e81 <MenuGSM_IPTCP2>:
     e81:	01 b7 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     e91:	01 b8 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     ea1:	01 b9 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     eb1:	01 ba 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00000ec1 <MenuGSM_IPTCP3>:
     ec1:	01 bb 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     ed1:	01 bc 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     ee1:	01 bd 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     ef1:	01 be 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00000f01 <MenuGSM_IPTCP4>:
     f01:	01 bf 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     f11:	01 c0 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     f21:	01 c1 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................
     f31:	01 c2 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00000f41 <MenuGSM_TCPPort>:
     f41:	08 b1 00 00 00 00 00 ff ff 00 00 00 00 00 00 00     ................

00000f51 <MenuGSM_TCPTimeout>:
     f51:	08 c3 00 64 00 00 00 ff ff 00 00 00 00 00 00 02     ...d............

00000f61 <MenuGSM_SMS>:
     f61:	01 13 01 00 00 00 00 01 00 00 00 00 00 00 00 00     ................

00000f71 <MenuGSM_VegaSN>:
     f71:	08 07 00 00 00 00 00 ff ff 00 00 00 00 00 00 00     ................

00000f81 <ListGSM>:
     f81:	20 cc ee e4 e5 ec 20 7b 7b 7b 7b 7b 7b 7b 7b 7b      ..... {{{{{{{{{
     f91:	20 7b 7b 7b 00 63 0c 00 00 00 00 20 43 6f 6e 74      {{{.c..... Cont
     fa1:	72 6f 6c 20 6d 6f 64 65 3a 7d 7d 7d 7d 7d 7d 00     rol mode:}}}}}}.
     fb1:	00 00 75 0c 00 00 20 4d 79 49 50 7b 7b 7b 2e 7b     ..u... MyIP{{{.{
     fc1:	7b 7b 2e 7b 7b 7b 2e 7b 7b 7b 00 85 0c 00 00 00     {{.{{{.{{{......
     fd1:	00 20 43 6c 49 50 7b 7b 7b 2e 7b 7b 7b 2e 7b 7b     . ClIP{{{.{{{.{{
     fe1:	7b 2e 7b 7b 7b 00 9d 0c 00 00 00 00 20 41 63 74     {.{{{....... Act
     ff1:	69 76 65 20 63 6f 6e 65 63 74 69 6f 6e 7b 7b 7b     ive conection{{{
    1001:	00 b5 0c 00 00 00 00 20 46 49 46 4f 3a 6d 61 78     ....... FIFO:max
    1011:	20 7b 7b 2f 37 30 62 79 74 65 20 00 bb 0c 00 00      {{/70byte .....
    1021:	00 00 20 2d 2d 2d 2d 2d 2d 2d 41 50 4e 2d 2d 2d     .. -------APN---
    1031:	2d 2d 2d 2d 2d 2d 00 00 00 00 00 00 00 20 7d 7d     ------....... }}
    1041:	7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d     }}}}}}}}}}}}}}}}
    1051:	7d 00 00 00 c1 0c 00 00 20 7d 7d 7d 7d 7d 7d 7d     }....... }}}}}}}
    1061:	7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 00 00 00 d1     }}}}}}}}}}}}....
    1071:	0c 00 00 20 2d 2d 2d 41 50 4e 2d 55 53 45 52 20     ... ---APN-USER 
    1081:	4e 41 4d 45 2d 2d 2d 00 00 00 00 00 00 00 20 7d     NAME---....... }
    1091:	7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d     }}}}}}}}}}}}}}}}
    10a1:	7d 7d 00 00 00 e1 0c 00 00 20 2d 2d 2d 41 50 4e     }}....... ---APN
    10b1:	2d 50 41 53 53 57 4f 52 44 2d 2d 2d 2d 00 00 00     -PASSWORD----...
    10c1:	00 00 00 00 20 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d 7d     .... }}}}}}}}}}}
    10d1:	7d 7d 7d 7d 7d 7d 7d 7d 00 00 00 f1 0c 00 00 20     }}}}}}}}....... 
    10e1:	2d 2d 53 65 6e 64 20 55 44 50 20 74 6f 20 49 50     --Send UDP to IP
    10f1:	2d 2d 2d 00 00 00 00 00 00 00 20 49 50 31 3a 7d     ---....... IP1:}
    1101:	7d 7d 2e 7d 7d 7d 2e 7d 7d 7d 2e 7d 7d 7d 00 00     }}.}}}.}}}.}}}..
    1111:	00 01 0d 00 00 20 49 50 32 3a 7d 7d 7d 2e 7d 7d     ..... IP2:}}}.}}
    1121:	7d 2e 7d 7d 7d 2e 7d 7d 7d 00 00 00 41 0d 00 00     }.}}}.}}}...A...
    1131:	20 49 50 33 3a 7d 7d 7d 2e 7d 7d 7d 2e 7d 7d 7d      IP3:}}}.}}}.}}}
    1141:	2e 7d 7d 7d 00 00 00 81 0d 00 00 20 49 50 34 3a     .}}}....... IP4:
    1151:	7d 7d 7d 2e 7d 7d 7d 2e 7d 7d 7d 2e 7d 7d 7d 00     }}}.}}}.}}}.}}}.
    1161:	00 00 c1 0d 00 00 20 2d 2d 2d 2d 20 55 44 50 20     ...... ---- UDP 
    1171:	50 6f 72 74 20 2d 2d 2d 2d 2d 00 00 00 00 00 00     Port -----......
    1181:	00 20 49 50 31 20 50 6f 72 74 3a 7d 7d 7d 7d 7d     . IP1 Port:}}}}}
    1191:	20 20 20 20 20 00 00 00 01 0e 00 00 20 49 50 32          ....... IP2
    11a1:	20 50 6f 72 74 3a 7d 7d 7d 7d 7d 20 20 20 20 20      Port:}}}}}     
    11b1:	00 00 00 11 0e 00 00 20 49 50 33 20 50 6f 72 74     ....... IP3 Port
    11c1:	3a 7d 7d 7d 7d 7d 20 20 20 20 20 00 00 00 21 0e     :}}}}}     ...!.
    11d1:	00 00 20 49 50 34 20 50 6f 72 74 3a 7d 7d 7d 7d     .. IP4 Port:}}}}
    11e1:	7d 20 20 20 20 20 00 00 00 31 0e 00 00 20 2d 20     }     ...1... - 
    11f1:	54 43 50 20 49 50 20 46 69 72 65 77 61 6c 6c 2d     TCP IP Firewall-
    1201:	2d 00 00 00 00 00 00 00 20 49 50 31 3a 7d 7d 7d     -....... IP1:}}}
    1211:	2e 7d 7d 7d 2e 7d 7d 7d 2e 7d 7d 7d 00 00 00 41     .}}}.}}}.}}}...A
    1221:	0e 00 00 20 49 50 32 3a 7d 7d 7d 2e 7d 7d 7d 2e     ... IP2:}}}.}}}.
    1231:	7d 7d 7d 2e 7d 7d 7d 00 00 00 81 0e 00 00 20 49     }}}.}}}....... I
    1241:	50 33 3a 7d 7d 7d 2e 7d 7d 7d 2e 7d 7d 7d 2e 7d     P3:}}}.}}}.}}}.}
    1251:	7d 7d 00 00 00 c1 0e 00 00 20 49 50 34 3a 7d 7d     }}....... IP4:}}
    1261:	7d 2e 7d 7d 7d 2e 7d 7d 7d 2e 7d 7d 7d 00 00 00     }.}}}.}}}.}}}...
    1271:	01 0f 00 00 20 54 43 50 53 65 72 76 65 72 50 6f     .... TCPServerPo
    1281:	72 74 3a 7d 7d 7d 7d 7d 00 00 00 41 0f 00 00 20     rt:}}}}}...A... 
    1291:	54 69 6d 65 6f 75 74 20 54 43 50 3a 7d 7d 7d 7d     Timeout TCP:}}}}
    12a1:	7d 7d 63 00 00 00 51 0f 00 00 20 2d 2d 2d 2d 2d     }}c...Q... -----
    12b1:	2d 2d 20 53 4d 53 20 2d 2d 2d 2d 2d 2d 2d 00 00     -- SMS -------..
    12c1:	00 00 00 00 00 20 d0 e0 f1 f1 fb eb ea e0 20 53     ..... ........ S
    12d1:	4d 53 3a 20 20 20 7d 7d 7d 00 00 00 61 0f 00 00     MS:   }}}...a...
    12e1:	20 2d 2d 49 64 65 6e 74 69 66 69 63 61 74 69 6f      --Identificatio
    12f1:	6e 2d 2d 2d 00 00 00 00 00 00 00 20 56 65 67 61     n---....... Vega
    1301:	20 53 2f 4e 3a 20 20 20 20 20 7d 7d 7d 7d 7d 00      S/N:     }}}}}.
    1311:	00 00 71 0f 00 00                                   ..q...

00001317 <MenuGSM>:
    1317:	81 0f 22 00 00 00 00 00 00 00 00 00 00 00 00 00     ..".............
    1327:	00 00 00 00                                         ....

0000132b <Mem_OK_Tbl>:
    132b:	fd 06 f7 06                                         ....

0000132f <F_Ok_Flash>:
    132f:	1f cf 08 2b 13 00                                   ...+..

00001335 <F_Ok_EEPROM>:
    1335:	1f cf 08 2b 13 01                                   ...+..

0000133b <Msg_EEWarning>:
    133b:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    134b:	20 20 20 20 00 00 00 20 cf e5 f0 e5 e4 20 ef f0         ... ..... ..
    135b:	ee e4 ee eb e6 e5 ed e8 e5 ec 20 00 00 00 f0 e0     .......... .....
    136b:	e1 ee f2 fb 20 ef f0 ee e2 e5 f0 fc f2 e5 20 e2     .... ......... .
    137b:	f1 e5 00 00 00 20 20 20 20 20 20 ed e0 f1 f2 f0     .....      .....
    138b:	ee e9 ea e8 20 20 20 20 20 00 00 00 00 00 00 00     ....     .......
	...

0000139d <Msg_NoBackUp>:
    139d:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    13ad:	20 20 20 20 00 00 00 d1 ee f5 f0 e0 ed b8 ed ed         ............
    13bd:	fb f5 20 ed e0 f1 f2 f0 ee e5 ea 00 00 00 20 20     .. ...........  
    13cd:	20 20 ed e5 20 ee e1 ed e0 f0 f3 e6 e5 ed ee 20       .. .......... 
    13dd:	20 20 00 00 00 20 20 20 20 20 20 20 20 20 20 20       ...           
    13ed:	20 20 20 20 20 20 20 20 20 00 00 00 00 00 00 00              .......
	...

000013ff <Menu_ConfirmationSave_List>:
    13ff:	d1 ee f5 f0 e0 ed e8 f2 fc 20 ed e0 f1 f2 f0 ee     ......... ......
    140f:	e9 ea e8 3f 00 00 00 00 00 00 00 20 20 20 c4 e0     ...?.......   ..
    141f:	20 2d 20 ea ed ee ef ea e0 20 c2 d5 ce c4 20 00      - ...... .... .
    142f:	00 00 00 00 00 00 20 20 cd e5 f2 20 2d 20 ea ed     ......  ... - ..
    143f:	ee ef ea e0 20 c2 db d5 ce c4 00 00 00 00 00 00     .... ...........
    144f:	00 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20     .               
    145f:	20 20 20 20 20 00 00 00 00 00 00 00                      .......

0000146b <Menu_ConfirmationSave>:
    146b:	ff 13 04 03 00 00 00 00 00 00 00 00 1a 40 00 00     .............@..
    147b:	00 00 00 00                                         ....

0000147f <Menu_ConfirmationRest_List>:
    147f:	c2 ee f1 f2 e0 ed ee e2 2e 20 ed e0 f1 f2 f0 ee     ......... ......
    148f:	e9 ea e8 3f 00 00 00 00 00 00 00 20 20 20 c4 e0     ...?.......   ..
    149f:	20 2d 20 ea ed ee ef ea e0 20 c2 d5 ce c4 20 00      - ...... .... .
    14af:	00 00 00 00 00 00 20 20 cd e5 f2 20 2d 20 ea ed     ......  ... - ..
    14bf:	ee ef ea e0 20 c2 db d5 ce c4 00 00 00 00 00 00     .... ...........
    14cf:	00 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20     .               
    14df:	20 20 20 20 20 00 00 00 00 00 00 00                      .......

000014eb <Menu_ConfirmationRestore>:
    14eb:	7f 14 04 03 00 00 00 00 00 00 00 00 0f 40 00 00     .............@..
    14fb:	00 00 00 00                                         ....

000014ff <NoBackUp_Str>:
    14ff:	2d 2d 00                                            --.

00001502 <BackUp_Tbl>:
    1502:	ff 14                                               ..

00001504 <Menu_BackUp_IField>:
    1504:	05 00 00 02 15 00 05 01 00 02 15 00 05 02 00 02     ................
    1514:	15 00                                               ..

00001516 <Menu_BackUp_List>:
    1516:	d3 f1 f2 ed 2f d0 e5 e7 e5 f0 e2 ed e0 ff 20 ea     ..../......... .
    1526:	ee ef e8 ff 00 00 00 00 00 00 00 20 d1 ee f5 f0     ........... ....
    1536:	e0 ed e8 f2 fc 20 20 20 20 20 20 20 20 20 20 00     .....          .
    1546:	00 00 00 00 6b 14 20 c2 ee f1 f2 e0 ed ee e2 3a     ....k. ........:
    1556:	7b 7b 2e 7b 7b 2e 32 30 7b 7b 00 04 15 00 00 00     {{.{{.20{{......
    1566:	00 20 d1 ee f1 f2 2e 45 45 50 52 4f 4d 3a 20 7b     . .....EEPROM: {
    1576:	7b 7b 7b 7b 20 00 35 13 00 00 00 00                 {{{{ .5.....

00001582 <Menu_BackUp>:
    1582:	16 15 04 01 00 00 00 00 00 00 00 00 b2 74 00 00     .............t..
    1592:	00 00 00 00                                         ....

00001596 <ListMem>:
    1596:	20 2d 2d 2d 2d 2d 20 4d 65 6d 6f 72 79 20 2d 2d      ----- Memory --
    15a6:	2d 2d 2d 20 00 00 00 00 00 00 00 20 46 6c 61 73     --- ....... Flas
    15b6:	68 3a 20 20 7b 7b 7b 7b 7b 20 20 20 20 20 20 00     h:  {{{{{      .
    15c6:	2f 13 00 00 00 00 20 45 45 50 52 4f 4d 3a 20 7b     /..... EEPROM: {
    15d6:	7b 7b 7b 7b 20 20 20 20 20 20 00 35 13 00 00 00     {{{{      .5....
    15e6:	00 20 52 65 73 65 74 20 45 45 50 52 4f 4d 20 66     . Reset EEPROM f
    15f6:	61 69 6c 20 20 00 00 00 00 00 00 00 20 42 61 63     ail  ....... Bac
    1606:	6b 55 70 20 45 45 50 52 4f 4d 20 20 20 20 20 20     kUp EEPROM      
    1616:	00 00 00 00 00 82 15                                .......

0000161d <MenuMem>:
    161d:	96 15 05 01 00 00 00 00 00 00 00 00 bd 4b 00 00     .............K..
    162d:	00 00 00 00                                         ....

00001631 <MsgErr11>:
    1631:	20 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f      _______________
    1641:	5f 5f 5f 20 00 00 00 20 49 6e 74 65 72 6e 61 6c     ___ ... Internal
    1651:	20 65 72 72 6f 72 20 31 31 3a 20 00 00 00 20 20      error 11: ...  
    1661:	20 20 20 46 6c 61 73 68 20 66 61 69 6c 20 20 20        Flash fail   
    1671:	20 20 00 00 00 20 20 20 20 20 20 20 20 20 20 20       ...           
    1681:	20 20 20 20 20 20 20 20 20 00 00 00 00 00 00 00              .......
	...

00001693 <MsgErr12>:
    1693:	20 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f      _______________
    16a3:	5f 5f 5f 20 00 00 00 20 49 6e 74 65 72 6e 61 6c     ___ ... Internal
    16b3:	20 65 72 72 6f 72 20 31 32 3a 20 00 00 00 20 20      error 12: ...  
    16c3:	20 20 45 45 50 52 4f 4d 20 66 61 69 6c 20 20 20       EEPROM fail   
    16d3:	20 20 00 00 00 20 20 20 20 20 20 20 20 20 20 20       ...           
    16e3:	20 20 20 20 20 20 20 20 20 00 00 00 00 00 00 00              .......
	...

000016f5 <MsgErr13>:
    16f5:	20 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f      _______________
    1705:	5f 5f 5f 20 00 00 00 20 49 6e 74 65 72 6e 61 6c     ___ ... Internal
    1715:	20 65 72 72 6f 72 20 31 33 3a 20 00 00 00 20 54      error 13: ... T
    1725:	6f 74 61 6c 20 6d 65 6d 6f 72 79 20 66 61 69 6c     otal memory fail
    1735:	20 20 00 00 00 20 20 20 20 20 20 20 20 20 20 20       ...           
    1745:	20 20 20 20 20 20 20 20 20 00 00 00 00 00 00 00              .......
	...

00001757 <MsgErrMemo>:
    1757:	00 00 31 16 93 16 f5 16                             ..1.....

0000175f <F_ScanCycle>:
    175f:	00 6a 07 00 00 00                                   .j....

00001765 <F_ScanCyclePerSec>:
    1765:	07 87 07 00 00 00                                   ......

0000176b <F_MaxScanCycle>:
    176b:	00 af 06 00 00 00                                   ......

00001771 <ListScanCycle>:
    1771:	20 2d 2d 2d 20 53 63 61 6e 20 43 79 63 6c 65 20      --- Scan Cycle 
    1781:	2d 2d 2d 20 00 00 00 00 00 00 00 20 53 63 61 6e     --- ....... Scan
    1791:	43 79 63 6c 65 3a 20 20 20 7b 7b 7b 30 6d 73 00     Cycle:   {{{0ms.
    17a1:	5f 17 00 00 00 00 20 53 63 61 6e 43 79 63 6c 50     _..... ScanCyclP
    17b1:	65 72 53 65 63 3a 7b 7b 7b 7b 00 65 17 00 00 00     erSec:{{{{.e....
    17c1:	00 20 4d 61 78 53 63 61 6e 43 79 63 6c 65 3a 7b     . MaxScanCycle:{
    17d1:	7b 7b 30 6d 73 00 6b 17 00 00 00 00                 {{0ms.k.....

000017dd <MenuScanCycle>:
    17dd:	71 17 04 01 00 00 00 00 00 00 00 00 fb 3f 00 00     q............?..
    17ed:	00 00 00 00                                         ....

000017f1 <F_WT>:
    17f1:	0b 23 0c 00 00 00 04 ae 06 00 00 00                 .#..........

000017fd <sec10_Str>:
    17fd:	31 30 20 f1 e5 ea 00                                10 ....

00001804 <sec30_Str>:
    1804:	33 30 20 f1 e5 ea 00                                30 ....

0000180b <min1_Str>:
    180b:	31 20 ec e8 ed 20 00                                1 ... .

00001812 <min3_Str>:
    1812:	33 20 ec e8 ed 20 00                                3 ... .

00001819 <min10_Str>:
    1819:	31 30 20 ec e8 ed 00                                10 ....

00001820 <BCKLT_Tbl>:
    1820:	fd 17 04 18 0b 18 12 18 19 18                       ..........

0000182a <F_Backlight>:
    182a:	1e 31 01 00 00 00 00 04 00 00 00 00 00 20 18 00     .1........... ..

0000183a <F_IonT>:
    183a:	08 2f 01 00 00 00 00 ff 03 00 00 00 00 00 00 00     ./..............

0000184a <F_Menu_EMICounter>:
    184a:	10 f6 06 00 00 00                                   ......

00001850 <ListSyst>:
    1850:	20 2d 20 d1 eb f3 e6 e5 e1 ed ee e5 20 ec e5 ed      - ......... ...
    1860:	fe 20 2d 20 00 00 00 00 00 00 00 20 c4 e8 f1 ea     . - ....... ....
    1870:	f0 e5 f2 ed fb e5 20 e2 f5 ee e4 fb 20 20 20 00     ...... .....   .
    1880:	00 00 00 00 6f 1e 20 c4 e8 f1 ea f0 e5 f2 ed fb     ....o. .........
    1890:	e5 20 e2 fb f5 ee e4 fb 20 20 00 00 00 00 00 33     . ......  .....3
    18a0:	21 20 c0 ed e0 eb ee e3 ee e2 fb e5 20 e2 f5 ee     ! .......... ...
    18b0:	e4 fb 20 20 20 00 00 00 00 00 e3 21 20 c0 ed e0     ..   ......! ...
    18c0:	eb ee e3 ee e2 fb e5 20 e2 fb f5 ee e4 fb 20 20     ....... ......  
    18d0:	00 00 00 00 00 a3 22 20 c0 d6 cf 20 20 20 20 20     ......" ...     
    18e0:	20 20 20 20 20 20 20 20 20 20 20 00 00 00 00 00                .....
    18f0:	66 08 20 d2 e5 f0 ec ee e4 e0 f2 f7 e8 ea e8 20     f. ............ 
    1900:	20 20 20 20 20 20 00 00 00 00 00 37 29 20 4d 6f           .....7) Mo
    1910:	64 62 75 73 20 20 20 20 20 20 20 20 20 20 20 20     dbus            
    1920:	20 00 00 00 00 00 8f 0b 20 cc ee e4 e5 ec 20 20      ....... .....  
    1930:	20 20 20 20 20 20 20 20 20 20 20 20 00 00 00 00                 ....
    1940:	00 17 13 20 7b 20 7d 7d 2e 7d 7d 2e 7d 7d 20 7d     ... { }}.}}.}} }
    1950:	7d 3a 7d 7d 3a 7d 7d 00 be 0b c4 0b 00 00 20 c0     }:}}:}}....... .
    1960:	e2 f2 ee cf e5 f0 e5 f5 cb e5 f2 ed c2 f0 3a 7d     ..............:}
    1970:	7d 7d 00 00 00 ae 0b 00 00 20 cd e0 f0 e0 e1 ee     }}....... ......
    1980:	f2 ea e0 3a 7b 7b 7b 7b 7b f7 7b 7b ec 00 f1 17     ...:{{{{{.{{....
    1990:	00 00 00 00 20 d1 ee f1 f2 ee ff ed e8 e5 20 ef     .... ......... .
    19a0:	e0 ec ff f2 e8 20 20 20 00 00 00 00 00 1d 16 20     .....   ....... 
    19b0:	53 63 61 6e 20 43 79 63 6c 65 3a 20 20 7b 7b 7b     Scan Cycle:  {{{
    19c0:	30 6d 73 00 5f 17 00 00 dd 17 20 cf ee f0 ee e3     0ms._..... .....
    19d0:	20 e8 ee ed ee e4 2e 3a 20 20 7d 7d 7d 7d 00 00      ......:  }}}}..
    19e0:	00 3a 18 00 00 20 cf ee e4 f1 e2 e5 f2 ea e0 c6     .:... ..........
    19f0:	ca c8 3a 7d 7d 7d 7d 7d 7d 00 00 00 2a 18 00 00     ..:}}}}}}...*...
    1a00:	20 d1 f7 b8 f2 2e dd cc cd 3a 7b 7b 7b 7b 7b 7b      ........:{{{{{{
    1a10:	7b 7b 7b 7b 00 4a 18 00 00 00 00                    {{{{.J.....

00001a1b <MenuSyst>:
    1a1b:	50 18 11 01 00 00 00 00 00 00 00 00 00 00 00 00     P...............
    1a2b:	00 00 00 00                                         ....

00001a2f <MsgErr41>:
    1a2f:	20 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f 5f      _______________
    1a3f:	5f 5f 5f 20 00 00 00 20 49 6e 74 65 72 6e 61 6c     ___ ... Internal
    1a4f:	20 65 72 72 6f 72 20 34 31 3a 20 00 00 00 54 69      error 41: ...Ti
    1a5f:	6d 65 72 20 61 6c 6c 6f 63 61 74 69 6f 6e 20 65     mer allocation e
    1a6f:	72 72 00 00 00 20 20 20 20 20 20 20 20 20 20 20     rr...           
    1a7f:	20 20 20 20 20 20 20 20 20 00 00 00 00 00 00 00              .......
	...

00001a91 <F_DI1>:
    1a91:	1f fc 06 1b 07 00 1f 02 07 0d 07 00                 ............

00001a9d <F_DI2>:
    1a9d:	1f fc 06 1b 07 01 1f 02 07 0d 07 01                 ............

00001aa9 <F_DI3>:
    1aa9:	1f fc 06 1b 07 02 1f 02 07 0d 07 02                 ............

00001ab5 <F_DI4>:
    1ab5:	1f fc 06 1b 07 03 1f 02 07 0d 07 03                 ............

00001ac1 <F_DI5>:
    1ac1:	1f fc 06 1b 07 04 1f 02 07 0d 07 04                 ............

00001acd <F_DI6>:
    1acd:	1f fc 06 1b 07 05 1f 02 07 0d 07 05                 ............

00001ad9 <F_DI7>:
    1ad9:	1f fc 06 1b 07 06 1f 02 07 0d 07 06                 ............

00001ae5 <F_DI8>:
    1ae5:	1f fc 06 1b 07 07 1f 02 07 0d 07 07                 ............

00001af1 <F_DI9>:
    1af1:	1f fc 06 1b 07 08 1f 02 07 0d 07 08                 ............

00001afd <F_DI10>:
    1afd:	1f fc 06 1b 07 09 1f 02 07 0d 07 09                 ............

00001b09 <F_DI11>:
    1b09:	1f fc 06 1b 07 0a 1f 02 07 0d 07 0a                 ............

00001b15 <F_DI12>:
    1b15:	1f fc 06 1b 07 0b 1f 02 07 0d 07 0b                 ............

00001b21 <F_DI13>:
    1b21:	1f fc 06 1b 07 0c 1f 02 07 0d 07 0c                 ............

00001b2d <F_DI14>:
    1b2d:	1f fc 06 1b 07 0d 1f 02 07 0d 07 0d                 ............

00001b39 <F_DI15>:
    1b39:	1f fc 06 1b 07 0e 1f 02 07 0d 07 0e                 ............

00001b45 <F_DI16>:
    1b45:	1f fc 06 1b 07 0f 1f 02 07 0d 07 0f                 ............

00001b51 <F_DI17>:
    1b51:	1f fc 06 1b 07 10 1f 02 07 0d 07 10                 ............

00001b5d <F_DI18>:
    1b5d:	1f fc 06 1b 07 11 1f 02 07 0d 07 11                 ............

00001b69 <F_DII1>:
    1b69:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 00      ............)..

00001b79 <F_DII2>:
    1b79:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 01      ............)..

00001b89 <F_DII3>:
    1b89:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 02      ............)..

00001b99 <F_DII4>:
    1b99:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 03      ............)..

00001ba9 <F_DII5>:
    1ba9:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 04      ............)..

00001bb9 <F_DII6>:
    1bb9:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 05      ............)..

00001bc9 <F_DII7>:
    1bc9:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 06      ............)..

00001bd9 <F_DII8>:
    1bd9:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 07      ............)..

00001be9 <F_DII9>:
    1be9:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 08      ............)..

00001bf9 <F_DII10>:
    1bf9:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 09      ............)..

00001c09 <F_DII11>:
    1c09:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 0a      ............)..

00001c19 <F_DII12>:
    1c19:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 0b      ............)..

00001c29 <F_DII13>:
    1c29:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 0c      ............)..

00001c39 <F_DII14>:
    1c39:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 0d      ............)..

00001c49 <F_DII15>:
    1c49:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 0e      ............)..

00001c59 <F_DII16>:
    1c59:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 0f      ............)..

00001c69 <F_DII17>:
    1c69:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 10      ............)..

00001c79 <F_DII18>:
    1c79:	20 14 01 00 00 00 00 00 00 00 00 00 00 29 07 11      ............)..

00001c89 <ListDI>:
    1c89:	20 4e 31 3a 20 20 7b 7b 7b 7b 20 7d 7d 7d 7d 20      N1:  {{{{ }}}} 
    1c99:	7b 7b 7b 7b 00 91 1a 69 1b 00 00 20 4e 32 3a 20     {{{{...i... N2: 
    1ca9:	20 7b 7b 7b 7b 20 7d 7d 7d 7d 20 7b 7b 7b 7b 00      {{{{ }}}} {{{{.
    1cb9:	9d 1a 79 1b 00 00 20 4e 33 3a 20 20 7b 7b 7b 7b     ..y... N3:  {{{{
    1cc9:	20 7d 7d 7d 7d 20 7b 7b 7b 7b 00 a9 1a 89 1b 00      }}}} {{{{......
    1cd9:	00 20 4e 34 3a 20 20 7b 7b 7b 7b 20 7d 7d 7d 7d     . N4:  {{{{ }}}}
    1ce9:	20 7b 7b 7b 7b 00 b5 1a 99 1b 00 00 20 4e 35 3a      {{{{....... N5:
    1cf9:	20 20 7b 7b 7b 7b 20 7d 7d 7d 7d 20 7b 7b 7b 7b       {{{{ }}}} {{{{
    1d09:	00 c1 1a a9 1b 00 00 20 4e 36 3a 20 20 7b 7b 7b     ....... N6:  {{{
    1d19:	7b 20 7d 7d 7d 7d 20 7b 7b 7b 7b 00 cd 1a b9 1b     { }}}} {{{{.....
    1d29:	00 00 20 4e 37 3a 20 20 7b 7b 7b 7b 20 7d 7d 7d     .. N7:  {{{{ }}}
    1d39:	7d 20 7b 7b 7b 7b 00 d9 1a c9 1b 00 00 20 4e 38     } {{{{....... N8
    1d49:	3a 20 20 7b 7b 7b 7b 20 7d 7d 7d 7d 20 7b 7b 7b     :  {{{{ }}}} {{{
    1d59:	7b 00 e5 1a d9 1b 00 00 20 4e 39 3a 20 20 7b 7b     {....... N9:  {{
    1d69:	7b 7b 20 7d 7d 7d 7d 20 7b 7b 7b 7b 00 f1 1a e9     {{ }}}} {{{{....
    1d79:	1b 00 00 20 4e 31 30 3a 20 7b 7b 7b 7b 20 7d 7d     ... N10: {{{{ }}
    1d89:	7d 7d 20 7b 7b 7b 7b 00 fd 1a f9 1b 00 00 20 4e     }} {{{{....... N
    1d99:	31 31 3a 20 7b 7b 7b 7b 20 7d 7d 7d 7d 20 7b 7b     11: {{{{ }}}} {{
    1da9:	7b 7b 00 09 1b 09 1c 00 00 20 4e 31 32 3a 20 7b     {{....... N12: {
    1db9:	7b 7b 7b 20 7d 7d 7d 7d 20 7b 7b 7b 7b 00 15 1b     {{{ }}}} {{{{...
    1dc9:	19 1c 00 00 20 4e 31 33 3a 20 7b 7b 7b 7b 20 7d     .... N13: {{{{ }
    1dd9:	7d 7d 7d 20 7b 7b 7b 7b 00 21 1b 29 1c 00 00 20     }}} {{{{.!.)... 
    1de9:	4e 31 34 3a 20 7b 7b 7b 7b 20 7d 7d 7d 7d 20 7b     N14: {{{{ }}}} {
    1df9:	7b 7b 7b 00 2d 1b 39 1c 00 00 20 4e 31 35 3a 20     {{{.-.9... N15: 
    1e09:	7b 7b 7b 7b 20 7d 7d 7d 7d 20 7b 7b 7b 7b 00 39     {{{{ }}}} {{{{.9
    1e19:	1b 49 1c 00 00 20 4e 31 36 3a 20 7b 7b 7b 7b 20     .I... N16: {{{{ 
    1e29:	7d 7d 7d 7d 20 7b 7b 7b 7b 00 45 1b 59 1c 00 00     }}}} {{{{.E.Y...
    1e39:	20 4e 31 37 3a 20 7b 7b 7b 7b 20 7d 7d 7d 7d 20      N17: {{{{ }}}} 
    1e49:	7b 7b 7b 7b 00 51 1b 69 1c 00 00 20 4e 31 38 3a     {{{{.Q.i... N18:
    1e59:	20 7b 7b 7b 7b 20 7d 7d 7d 7d 20 7b 7b 7b 7b 00      {{{{ }}}} {{{{.
    1e69:	5d 1b 79 1c 00 00                                   ].y...

00001e6f <MenuDI>:
    1e6f:	89 1c 12 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1e7f:	00 00 00 00                                         ....

00001e83 <F_DO1>:
    1e83:	1f 97 07 00 00 00 00 00 00 00 00 00 00 37 07 00     .............7..

00001e93 <F_DO2>:
    1e93:	1f 97 07 00 00 00 00 00 00 00 00 00 00 37 07 01     .............7..

00001ea3 <F_DO3>:
    1ea3:	1f 97 07 00 00 00 00 00 00 00 00 00 00 37 07 02     .............7..

00001eb3 <F_DO4>:
    1eb3:	1f 97 07 00 00 00 00 00 00 00 00 00 00 37 07 03     .............7..

00001ec3 <F_DO5>:
    1ec3:	1f 97 07 00 00 00 00 00 00 00 00 00 00 37 07 04     .............7..

00001ed3 <F_DO6>:
    1ed3:	1f 97 07 00 00 00 00 00 00 00 00 00 00 37 07 05     .............7..

00001ee3 <F_DO7>:
    1ee3:	1f 97 07 00 00 00 00 00 00 00 00 00 00 37 07 06     .............7..

00001ef3 <F_DO8>:
    1ef3:	1f 97 07 00 00 00 00 00 00 00 00 00 00 37 07 07     .............7..

00001f03 <F_DO9>:
    1f03:	1f 97 07 00 00 00 00 00 00 00 00 00 00 37 07 08     .............7..

00001f13 <F_DO10>:
    1f13:	1f 97 07 00 00 00 00 00 00 00 00 00 00 37 07 09     .............7..

00001f23 <F_DO11>:
    1f23:	1f 97 07 00 00 00 00 00 00 00 00 00 00 37 07 0a     .............7..

00001f33 <F_DO12>:
    1f33:	1f 97 07 00 00 00 00 00 00 00 00 00 00 37 07 0b     .............7..

00001f43 <F_DO13>:
    1f43:	1f 97 07 00 00 00 00 00 00 00 00 00 00 37 07 0c     .............7..

00001f53 <F_DO14>:
    1f53:	1f 97 07 00 00 00 00 00 00 00 00 00 00 37 07 0d     .............7..

00001f63 <F_DO15>:
    1f63:	1f 97 07 00 00 00 00 00 00 00 00 00 00 37 07 0e     .............7..

00001f73 <F_DO16>:
    1f73:	1f 97 07 00 00 00 00 00 00 00 00 00 00 37 07 0f     .............7..

00001f83 <ListDO>:
    1f83:	20 c2 fb f5 ee e4 20 4e 31 3a 20 20 20 20 20 7d      ..... N1:     }
    1f93:	7d 7d 7d 20 00 00 00 83 1e 00 00 20 c2 fb f5 ee     }}} ....... ....
    1fa3:	e4 20 4e 32 3a 20 20 20 20 20 7d 7d 7d 7d 20 00     . N2:     }}}} .
    1fb3:	00 00 93 1e 00 00 20 c2 fb f5 ee e4 20 4e 33 3a     ...... ..... N3:
    1fc3:	20 20 20 20 20 7d 7d 7d 7d 20 00 00 00 a3 1e 00          }}}} ......
    1fd3:	00 20 c2 fb f5 ee e4 20 4e 34 3a 20 20 20 20 20     . ..... N4:     
    1fe3:	7d 7d 7d 7d 20 00 00 00 b3 1e 00 00 20 c2 fb f5     }}}} ....... ...
    1ff3:	ee e4 20 4e 35 3a 20 20 20 20 20 7d 7d 7d 7d 20     .. N5:     }}}} 
    2003:	00 00 00 c3 1e 00 00 20 c2 fb f5 ee e4 20 4e 36     ....... ..... N6
    2013:	3a 20 20 20 20 20 7d 7d 7d 7d 20 00 00 00 d3 1e     :     }}}} .....
    2023:	00 00 20 c2 fb f5 ee e4 20 4e 37 3a 20 20 20 20     .. ..... N7:    
    2033:	20 7d 7d 7d 7d 20 00 00 00 e3 1e 00 00 20 c2 fb      }}}} ....... ..
    2043:	f5 ee e4 20 4e 38 3a 20 20 20 20 20 7d 7d 7d 7d     ... N8:     }}}}
    2053:	20 00 00 00 f3 1e 00 00 20 c2 fb f5 ee e4 20 4e      ....... ..... N
    2063:	39 3a 20 20 20 20 20 7d 7d 7d 7d 20 00 00 00 03     9:     }}}} ....
    2073:	1f 00 00 20 c2 fb f5 ee e4 20 4e 31 30 3a 20 20     ... ..... N10:  
    2083:	20 20 7d 7d 7d 7d 20 00 00 00 13 1f 00 00 20 c2       }}}} ....... .
    2093:	fb f5 ee e4 20 4e 31 31 3a 20 20 20 20 7d 7d 7d     .... N11:    }}}
    20a3:	7d 20 00 00 00 23 1f 00 00 20 c2 fb f5 ee e4 20     } ...#... ..... 
    20b3:	4e 31 32 3a 20 20 20 20 7d 7d 7d 7d 20 00 00 00     N12:    }}}} ...
    20c3:	33 1f 00 00 20 c2 fb f5 ee e4 20 4e 31 33 3a 20     3... ..... N13: 
    20d3:	20 20 20 7d 7d 7d 7d 20 00 00 00 43 1f 00 00 20        }}}} ...C... 
    20e3:	c2 fb f5 ee e4 20 4e 31 34 3a 20 20 20 20 7d 7d     ..... N14:    }}
    20f3:	7d 7d 20 00 00 00 53 1f 00 00 20 c2 fb f5 ee e4     }} ...S... .....
    2103:	20 4e 31 35 3a 20 20 20 20 7d 7d 7d 7d 20 00 00      N15:    }}}} ..
    2113:	00 63 1f 00 00 20 c2 fb f5 ee e4 20 4e 31 36 3a     .c... ..... N16:
    2123:	20 20 20 20 7d 7d 7d 7d 20 00 00 00 73 1f 00 00         }}}} ...s...

00002133 <MenuDO>:
    2133:	83 1f 10 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    2143:	00 00 00 00                                         ....

00002147 <F_AI12>:
    2147:	0b 06 0b 00 00 00 0b 08 0b 00 00 00                 ............

00002153 <F_AI34>:
    2153:	0b 0a 0b 00 00 00 0b 0c 0b 00 00 00                 ............

0000215f <F_AI56>:
    215f:	0b 0e 0b 00 00 00 0b 10 0b 00 00 00                 ............

0000216b <F_AI78>:
    216b:	0b 12 0b 00 00 00 0b 14 0b 00 00 00                 ............

00002177 <ListAI>:
    2177:	20 4e 31 3a 20 7b 7b 7b 7b 7b 20 4e 32 3a 20 7b      N1: {{{{{ N2: {
    2187:	7b 7b 7b 7b 00 47 21 00 00 00 00 20 4e 33 3a 20     {{{{.G!.... N3: 
    2197:	7b 7b 7b 7b 7b 20 4e 34 3a 20 7b 7b 7b 7b 7b 00     {{{{{ N4: {{{{{.
    21a7:	53 21 00 00 00 00 20 4e 35 3a 20 7b 7b 7b 7b 7b     S!.... N5: {{{{{
    21b7:	20 4e 36 3a 20 7b 7b 7b 7b 7b 00 5f 21 00 00 00      N6: {{{{{._!...
    21c7:	00 20 4e 37 3a 20 7b 7b 7b 7b 7b 20 4e 38 3a 20     . N7: {{{{{ N8: 
    21d7:	7b 7b 7b 7b 7b 00 6b 21 00 00 00 00                 {{{{{.k!....

000021e3 <MenuAI>:
    21e3:	77 21 04 03 00 00 00 00 00 00 00 00 00 00 00 00     w!..............
    21f3:	00 00 00 00                                         ....

000021f7 <F_AO1>:
    21f7:	0e 8b 07 00 00 00 00 ff 03 00 00 00 00 00 00 00     ................

00002207 <F_AO2>:
    2207:	0e 8d 07 00 00 00 00 ff 03 00 00 00 00 00 00 00     ................

00002217 <F_AO3>:
    2217:	0e 8f 07 00 00 00 00 ff 03 00 00 00 00 00 00 00     ................

00002227 <F_AO4>:
    2227:	0e 91 07 00 00 00 00 ff 03 00 00 00 00 00 00 00     ................

00002237 <ListAO>:
    2237:	20 c2 fb f5 ee e4 20 4e 31 3a 20 20 20 20 20 7d      ..... N1:     }
    2247:	7d 7d 7d 7d 00 00 00 f7 21 00 00 20 c2 fb f5 ee     }}}}....!.. ....
    2257:	e4 20 4e 32 3a 20 20 20 20 20 7d 7d 7d 7d 7d 00     . N2:     }}}}}.
    2267:	00 00 07 22 00 00 20 c2 fb f5 ee e4 20 4e 33 3a     ...".. ..... N3:
    2277:	20 20 20 20 20 7d 7d 7d 7d 7d 00 00 00 17 22 00          }}}}}....".
    2287:	00 20 c2 fb f5 ee e4 20 4e 34 3a 20 20 20 20 20     . ..... N4:     
    2297:	7d 7d 7d 7d 7d 00 00 00 27 22 00 00                 }}}}}...'"..

000022a3 <MenuAO>:
    22a3:	37 22 04 00 00 00 00 00 00 00 00 00 00 00 00 00     7"..............
    22b3:	00 00 00 00                                         ....

000022b7 <F_ADC12>:
    22b7:	07 d3 08 00 00 00 07 d5 08 00 00 00                 ............

000022c3 <F_ADC34>:
    22c3:	07 d7 08 00 00 00 07 d9 08 00 00 00                 ............

000022cf <F_ADC56>:
    22cf:	07 db 08 00 00 00 07 dd 08 00 00 00                 ............

000022db <F_ADC_Ref>:
    22db:	07 df 08 00 00 00                                   ......

000022e1 <List_ADC_Chan>:
    22e1:	20 2d 2d 2d 20 ca e0 ed e0 eb fb 20 c0 d6 cf 20      --- ...... ... 
    22f1:	2d 2d 2d 20 00 00 00 00 00 00 00 20 4e 31 3a 20     --- ....... N1: 
    2301:	7b 7b 7b 7b 7b 20 4e 32 3a 20 7b 7b 7b 7b 7b 00     {{{{{ N2: {{{{{.
    2311:	b7 22 00 00 00 00 20 4e 33 3a 20 7b 7b 7b 7b 7b     .".... N3: {{{{{
    2321:	20 4e 34 3a 20 7b 7b 7b 7b 7b 00 c3 22 00 00 00      N4: {{{{{.."...
    2331:	00 20 4e 35 3a 20 7b 7b 7b 7b 7b 20 4e 36 3a 20     . N5: {{{{{ N6: 
    2341:	7b 7b 7b 7b 7b 00 cf 22 00 00 00 00 20 ce ef ee     {{{{{..".... ...
    2351:	f0 ed 2e 20 ea e0 ed e0 eb 3a 20 7b 7b 7b 7b 7b     ... .....: {{{{{
    2361:	00 db 22 00 00 00 00                                .."....

00002368 <Menu_ADC_Ch>:
    2368:	e1 22 05 01 00 00 00 00 00 00 00 00 00 00 00 00     ."..............
    2378:	00 00 00 00                                         ....

0000237c <F_ADC_Zero>:
    237c:	00 27 0c 00 00 00 04 26 0c 00 00 00 04 25 0c 00     .'.....&.....%..
	...

0000238e <F_ADC_Full>:
    238e:	00 2a 0c 00 00 00 04 29 0c 00 00 00 04 28 0c 00     .*.....).....(..
	...

000023a0 <List_ADC_Cali>:
    23a0:	20 2d 2d 2d 20 ca e0 eb e8 e1 f0 ee e2 ea e0 20      --- .......... 
    23b0:	2d 2d 2d 20 00 00 00 00 00 00 00 20 5a 65 72 6f     --- ....... Zero
    23c0:	3a 20 20 7b 7b 7b 20 7b 7b 7b 20 7b 7b 7b 20 00     :  {{{ {{{ {{{ .
    23d0:	7c 23 00 00 00 00 20 46 75 6c 6c 3a 20 20 7b 7b     |#.... Full:  {{
    23e0:	7b 20 7b 7b 7b 20 7b 7b 7b 20 00 8e 23 00 00 00     { {{{ {{{ ..#...
    23f0:	00 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20     .               
    2400:	20 20 20 20 20 00 00 00 00 00 00 00                      .......

0000240c <Menu_ADC_Cali>:
    240c:	a0 23 04 03 00 00 00 00 00 00 00 00 00 00 00 00     .#..............
    241c:	00 00 00 00                                         ....

00002420 <ADC_Rt_Str>:
    2420:	52 65 73 65 74 00                                   Reset.

00002426 <ADC_I1_Str>:
    2426:	49 6e 69 74 69 61 6c 69 73 61 74 00                 Initialisat.

00002432 <ADC_C1_Str>:
    2432:	43 61 6c 69 62 72 61 74 69 6f 6e 00                 Calibration.

0000243e <ADC_Re_Str>:
    243e:	52 65 61 64 00                                      Read.

00002443 <ADC_Of_Str>:
    2443:	4f 66 66 00                                         Off.

00002447 <ADC_Tbl>:
    2447:	20 24 26 24 32 24 3e 24 43 24                        $&$2$>$C$

00002451 <F_Therm1>:
    2451:	09 43 06 ec 08 01                                   .C....

00002457 <F_Therm2>:
    2457:	09 45 06 ec 08 01                                   .E....

0000245d <F_Therm3>:
    245d:	09 47 06 ec 08 01                                   .G....

00002463 <F_Therm4>:
    2463:	09 49 06 ec 08 01                                   .I....

00002469 <F_Therm5>:
    2469:	09 4b 06 ec 08 01                                   .K....

0000246f <F_Therm6>:
    246f:	09 4d 06 ec 08 01                                   .M....

00002475 <F_Thermis1>:
    2475:	1e 17 01 00 00 00 00 07 00 00 00 00 00 20 09 00     ............. ..

00002485 <F_Thermis2>:
    2485:	1e 18 01 00 00 00 00 07 00 00 00 00 00 20 09 00     ............. ..

00002495 <F_Thermis3>:
    2495:	1e 19 01 00 00 00 00 07 00 00 00 00 00 20 09 00     ............. ..

000024a5 <F_Thermis4>:
    24a5:	1e 1a 01 00 00 00 00 07 00 00 00 00 00 20 09 00     ............. ..

000024b5 <F_Thermis5>:
    24b5:	1e 1b 01 00 00 00 00 07 00 00 00 00 00 20 09 00     ............. ..

000024c5 <F_Thermis6>:
    24c5:	1e 1c 01 00 00 00 00 07 00 00 00 00 00 20 09 00     ............. ..

000024d5 <F_ThermisD1>:
    24d5:	03 1d 01 80 ff ff ff 7f 00 00 00 00 00 00 00 01     ................

000024e5 <F_ThermisD2>:
    24e5:	03 20 01 80 ff ff ff 7f 00 00 00 00 00 00 00 01     . ..............

000024f5 <F_ThermisD3>:
    24f5:	03 23 01 80 ff ff ff 7f 00 00 00 00 00 00 00 01     .#..............

00002505 <F_ThermisD4>:
    2505:	03 26 01 80 ff ff ff 7f 00 00 00 00 00 00 00 01     .&..............

00002515 <F_ThermisD5>:
    2515:	03 29 01 80 ff ff ff 7f 00 00 00 00 00 00 00 01     .)..............

00002525 <F_ThermisD6>:
    2525:	03 2c 01 80 ff ff ff 7f 00 00 00 00 00 00 00 01     .,..............

00002535 <F_ThermisA1>:
    2535:	08 1e 01 84 03 00 00 4c 04 00 00 00 00 00 00 03     .......L........

00002545 <F_ThermisA2>:
    2545:	08 21 01 84 03 00 00 4c 04 00 00 00 00 00 00 03     .!.....L........

00002555 <F_ThermisA3>:
    2555:	08 24 01 84 03 00 00 4c 04 00 00 00 00 00 00 03     .$.....L........

00002565 <F_ThermisA4>:
    2565:	08 27 01 84 03 00 00 4c 04 00 00 00 00 00 00 03     .'.....L........

00002575 <F_ThermisA5>:
    2575:	08 2a 01 84 03 00 00 4c 04 00 00 00 00 00 00 03     .*.....L........

00002585 <F_ThermisA6>:
    2585:	08 2d 01 84 03 00 00 4c 04 00 00 00 00 00 00 03     .-.....L........

00002595 <ListTherm1>:
    2595:	20 ca e0 ed e0 eb 20 4e 31 3a 20 7b 7b 7b 7b 7b      ..... N1: {{{{{
    25a5:	7b 7b 7c 43 00 51 24 00 00 00 00 20 d2 e5 f0 ec     {{|C.Q$.... ....
    25b5:	ee e4 e0 f2 f7 e8 ea 3a 20 7d 7d 7d 7d 7d 7d 00     .......: }}}}}}.
    25c5:	00 00 75 24 00 00 20 d1 e4 e2 e8 e3 3a 20 20 20     ..u$.. .....:   
    25d5:	20 20 20 7d 7d 7d 7d 7d 7c 43 00 00 00 d5 24 00        }}}}}|C....$.
    25e5:	00 20 ca ee fd f4 f4 e8 f6 e8 e5 ed f2 3a 20 20     . ...........:  
    25f5:	7d 7d 7d 7d 7d 00 00 00 35 25 00 00                 }}}}}...5%..

00002601 <MenuTherm1>:
    2601:	95 25 04 01 00 00 00 00 00 00 00 00 00 00 00 00     .%..............
    2611:	00 00 00 00                                         ....

00002615 <ListTherm2>:
    2615:	20 ca e0 ed e0 eb 20 4e 32 3a 20 7b 7b 7b 7b 7b      ..... N2: {{{{{
    2625:	7b 7b 7c 43 00 57 24 00 00 00 00 20 d2 e5 f0 ec     {{|C.W$.... ....
    2635:	ee e4 e0 f2 f7 e8 ea 3a 20 7d 7d 7d 7d 7d 7d 00     .......: }}}}}}.
    2645:	00 00 85 24 00 00 20 d1 e4 e2 e8 e3 3a 20 20 20     ...$.. .....:   
    2655:	20 20 20 7d 7d 7d 7d 7d 7c 43 00 00 00 e5 24 00        }}}}}|C....$.
    2665:	00 20 ca ee fd f4 f4 e8 f6 e8 e5 ed f2 3a 20 20     . ...........:  
    2675:	7d 7d 7d 7d 7d 00 00 00 45 25 00 00                 }}}}}...E%..

00002681 <MenuTherm2>:
    2681:	15 26 04 01 00 00 00 00 00 00 00 00 00 00 00 00     .&..............
    2691:	00 00 00 00                                         ....

00002695 <ListTherm3>:
    2695:	20 ca e0 ed e0 eb 20 4e 33 3a 20 7b 7b 7b 7b 7b      ..... N3: {{{{{
    26a5:	7b 7b 7c 43 00 5d 24 00 00 00 00 20 d2 e5 f0 ec     {{|C.]$.... ....
    26b5:	ee e4 e0 f2 f7 e8 ea 3a 20 7d 7d 7d 7d 7d 7d 00     .......: }}}}}}.
    26c5:	00 00 95 24 00 00 20 d1 e4 e2 e8 e3 3a 20 20 20     ...$.. .....:   
    26d5:	20 20 20 7d 7d 7d 7d 7d 7c 43 00 00 00 f5 24 00        }}}}}|C....$.
    26e5:	00 20 ca ee fd f4 f4 e8 f6 e8 e5 ed f2 3a 20 20     . ...........:  
    26f5:	7d 7d 7d 7d 7d 00 00 00 55 25 00 00                 }}}}}...U%..

00002701 <MenuTherm3>:
    2701:	95 26 04 01 00 00 00 00 00 00 00 00 00 00 00 00     .&..............
    2711:	00 00 00 00                                         ....

00002715 <ListTherm4>:
    2715:	20 ca e0 ed e0 eb 20 4e 34 3a 20 7b 7b 7b 7b 7b      ..... N4: {{{{{
    2725:	7b 7b 7c 43 00 63 24 00 00 00 00 20 d2 e5 f0 ec     {{|C.c$.... ....
    2735:	ee e4 e0 f2 f7 e8 ea 3a 20 7d 7d 7d 7d 7d 7d 00     .......: }}}}}}.
    2745:	00 00 a5 24 00 00 20 d1 e4 e2 e8 e3 3a 20 20 20     ...$.. .....:   
    2755:	20 20 20 7d 7d 7d 7d 7d 7c 43 00 00 00 05 25 00        }}}}}|C....%.
    2765:	00 20 ca ee fd f4 f4 e8 f6 e8 e5 ed f2 3a 20 20     . ...........:  
    2775:	7d 7d 7d 7d 7d 00 00 00 65 25 00 00                 }}}}}...e%..

00002781 <MenuTherm4>:
    2781:	15 27 04 01 00 00 00 00 00 00 00 00 00 00 00 00     .'..............
    2791:	00 00 00 00                                         ....

00002795 <ListTherm5>:
    2795:	20 ca e0 ed e0 eb 20 4e 35 3a 20 7b 7b 7b 7b 7b      ..... N5: {{{{{
    27a5:	7b 7b 7c 43 00 69 24 00 00 00 00 20 d2 e5 f0 ec     {{|C.i$.... ....
    27b5:	ee e4 e0 f2 f7 e8 ea 3a 20 7d 7d 7d 7d 7d 7d 00     .......: }}}}}}.
    27c5:	00 00 b5 24 00 00 20 d1 e4 e2 e8 e3 3a 20 20 20     ...$.. .....:   
    27d5:	20 20 20 7d 7d 7d 7d 7d 7c 43 00 00 00 15 25 00        }}}}}|C....%.
    27e5:	00 20 ca ee fd f4 f4 e8 f6 e8 e5 ed f2 3a 20 20     . ...........:  
    27f5:	7d 7d 7d 7d 7d 00 00 00 75 25 00 00                 }}}}}...u%..

00002801 <MenuTherm5>:
    2801:	95 27 04 01 00 00 00 00 00 00 00 00 00 00 00 00     .'..............
    2811:	00 00 00 00                                         ....

00002815 <ListTherm6>:
    2815:	20 ca e0 ed e0 eb 20 4e 36 3a 20 7b 7b 7b 7b 7b      ..... N6: {{{{{
    2825:	7b 7b 7c 43 00 6f 24 00 00 00 00 20 d2 e5 f0 ec     {{|C.o$.... ....
    2835:	ee e4 e0 f2 f7 e8 ea 3a 20 7d 7d 7d 7d 7d 7d 00     .......: }}}}}}.
    2845:	00 00 c5 24 00 00 20 d1 e4 e2 e8 e3 3a 20 20 20     ...$.. .....:   
    2855:	20 20 20 7d 7d 7d 7d 7d 7c 43 00 00 00 25 25 00        }}}}}|C...%%.
    2865:	00 20 ca ee fd f4 f4 e8 f6 e8 e5 ed f2 3a 20 20     . ...........:  
    2875:	7d 7d 7d 7d 7d 00 00 00 85 25 00 00                 }}}}}....%..

00002881 <MenuTherm6>:
    2881:	15 28 04 01 00 00 00 00 00 00 00 00 00 00 00 00     .(..............
    2891:	00 00 00 00                                         ....

00002895 <List_Therm>:
    2895:	20 ca e0 ed e0 eb 20 4e 31 3a 20 7b 7b 7b 7b 7b      ..... N1: {{{{{
    28a5:	7b 7b 7c 43 00 51 24 00 00 01 26 20 ca e0 ed e0     {{|C.Q$...& ....
    28b5:	eb 20 4e 32 3a 20 7b 7b 7b 7b 7b 7b 7b 7c 43 00     . N2: {{{{{{{|C.
    28c5:	57 24 00 00 81 26 20 ca e0 ed e0 eb 20 4e 33 3a     W$...& ..... N3:
    28d5:	20 7b 7b 7b 7b 7b 7b 7b 7c 43 00 5d 24 00 00 01      {{{{{{{|C.]$...
    28e5:	27 20 ca e0 ed e0 eb 20 4e 34 3a 20 7b 7b 7b 7b     ' ..... N4: {{{{
    28f5:	7b 7b 7b 7c 43 00 63 24 00 00 81 27 20 ca e0 ed     {{{|C.c$...' ...
    2905:	e0 eb 20 4e 35 3a 20 7b 7b 7b 7b 7b 7b 7b 7c 43     .. N5: {{{{{{{|C
    2915:	00 69 24 00 00 01 28 20 ca e0 ed e0 eb 20 4e 36     .i$...( ..... N6
    2925:	3a 20 7b 7b 7b 7b 7b 7b 7b 7c 43 00 6f 24 00 00     : {{{{{{{|C.o$..
    2935:	81 28                                               .(

00002937 <MenuTherm>:
    2937:	95 28 06 00 00 00 00 00 00 00 00 00 00 00 00 00     .(..............
    2947:	00 00 00 00                                         ....

0000294b <MB_Master_List>:
    294b:	00 00 00                                            ...

0000294e <MenuModem>:
    294e:	81 0f 22 00 b3 29 00 00 00 00 00 00 00 00 00 00     .."..)..........
    295e:	00 00 00 00                                         ....

00002962 <Menu0List>:
    2962:	20 2d 47 53 4d 2d f1 e8 e3 ed e0 eb e8 e7 e0 f2      -GSM-..........
    2972:	ee f0 2d 20 00 00 00 00 00 b3 29 20 d1 eb f3 e6     ..- ......) ....
    2982:	e5 e1 ed ee e5 20 20 20 20 20 20 20 20 20 20 00     .....          .
    2992:	00 00 00 00 1b 1a 20 cc ee e4 e5 ec 20 20 20 20     ...... .....    
    29a2:	20 20 20 20 20 20 20 20 20 20 00 00 00 00 00 4e               .....N
    29b2:	29                                                  )

000029b3 <Menu0>:
    29b3:	62 29 03 00 b3 29 00 00 00 00 00 00 00 00 00 00     b)...)..........
    29c3:	00 00 00 00                                         ....

000029c7 <KeyAct.9415>:
    29c7:	00 00 05 40 0e 40 ea 56 42 52 94 5a 39 5a           ...@.@.VBR.Z9Z

000029d5 <MaxThermType>:
    29d5:	07 02                                               ..

000029d7 <TerLimType>:
    29d7:	c3 06 e3 06                                         ....

000029db <TSM100Tbl>:
    29db:	00 00 e1 f6 91 08 30 f8 0e 28 18 fc a2 37 0c fe     ......0..(...7..
    29eb:	ea 46 00 00 49 65 e8 03 a6 83 d0 07 ff ff f4 17     .F..Ie..........

000029fb <TSM50Tbl>:
    29fb:	00 00 df f6 46 04 30 f8 13 0c 24 fa fe 13 18 fc     ....F.0...$.....
    2a0b:	c6 1b 0c fe 6b 23 00 00 03 2b f4 01 9a 32 e8 03     ....k#...+...2..
    2a1b:	30 3a dc 05 c9 41 d0 07 ff ff bd 38                 0:...A.....8

00002a27 <TSP100Tbl>:
    2a27:	00 00 f6 f5 c2 38 0c fe e2 46 00 00 b6 62 e8 03     .....8...F...b..
    2a37:	96 7d d0 07 ae 97 b8 0b ea b0 a0 0f 54 c9 88 13     .}..........T...
    2a47:	e2 e0 70 17 ff ff 97 1e                             ..p.....

00002a4f <TSP50Tbl>:
    2a4f:	00 00 1f f6 5f 1c 0c fe 56 31 e8 03 d0 3e d0 07     ...._...V1...>..
    2a5f:	d2 4b b8 0b 70 58 a0 0f aa 64 88 13 6c 70 70 17     .K..pX...d..lpp.
    2a6f:	ff ff 0e 47                                         ...G

00002a73 <Pt100Tbl>:
    2a73:	00 00 20 f6 fe 38 0c fe 48 62 e8 03 c4 7c d0 07     .. ..8..Hb...|..
    2a83:	6e 96 b8 0b 50 af a0 0f 56 c7 88 13 94 de 70 17     n...P...V.....p.
    2a93:	f6 f4 58 1b ff ff 8b 1f                             ..X.....

00002a9b <Gr21Tbl>:
    2a9b:	00 00 1e f6 1c 1a 0c fe 64 2d e8 03 c6 39 d0 07     ........d-...9..
    2aab:	c4 45 b8 0b 68 51 a0 0f 9e 5c 88 13 7a 67 70 17     .E..hQ...\..zgp.
    2abb:	ff ff ce 4f                                         ...O

00002abf <Gr23Tbl>:
    2abf:	00 00 d5 f6 7d 1d 0c fe 8b 25 00 00 8f 2d f4 01     ....}....%...-..
    2acf:	92 35 e8 03 95 3d dc 05 63 42 08 07 ff ff 3e 35     .5...=..cB....>5

00002adf <TC_B_Tbl>:
    2adf:	00 00 90 01 99 01 dc 05 7c 07 b8 0b 8e 15 88 13     ........|.......
    2aef:	1b 1f 70 17 30 2a 58 1b c4 36 40 1f b6 44 28 23     ..p.0*X..6@..D(#
    2aff:	f2 53 10 27 5a 64 f8 2a d0 75 e0 2e 40 88 c8 32     .S.'Zd.*.u..@..2
    2b0f:	78 9b b0 36 50 af 98 3a 82 c3 80 3e d2 d7 68 42     x..6P..:...>..hB
    2b1f:	ff ff 38 4a                                         ..8J

00002b23 <Mux.8864>:
    2b23:	06 00 07 00 00 08 01 08 02 08 03 08 04 08 05 08     ................

00002b33 <M.8789>:
    2b33:	00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f     ................

00002b43 <DI_M>:
    2b43:	07 01 08 01 06 01 40 00 07 01 08 01 06 01 80 00     ......@.........
    2b53:	04 01 05 01 03 01 80 00 21 00 22 00 20 00 01 00     ........!.". ...
    2b63:	21 00 22 00 20 00 02 00 21 00 22 00 20 00 04 00     !.". ...!.". ...
    2b73:	21 00 22 00 20 00 08 00 21 00 22 00 20 00 10 00     !.". ...!.". ...
    2b83:	21 00 22 00 20 00 20 00 21 00 22 00 20 00 40 00     !.". . .!.". .@.
    2b93:	21 00 22 00 20 00 80 00 33 00 34 00 32 00 04 00     !.". ...3.4.2...
    2ba3:	04 01 05 01 03 01 40 00 04 01 05 01 03 01 20 00     ......@....... .
    2bb3:	04 01 05 01 03 01 10 00 04 01 05 01 03 01 08 00     ................
    2bc3:	04 01 05 01 03 01 02 01 04 01 05 01 03 01 04 01     ................

00002bd3 <__c.6181>:
    2bd3:	2b 50 44 50 00                                      +PDP.

00002bd8 <__c.6179>:
    2bd8:	43 4c 4f 53 00                                      CLOS.

00002bdd <__c.6177>:
    2bdd:	50 4f 53 54 00                                      POST.

00002be2 <__c.6174>:
    2be2:	47 45 54 20 00                                      GET .

00002be7 <__c.6172>:
    2be7:	0d 0a 00                                            ...

00002bea <__c.6168>:
    2bea:	2b 43 53 51 3a 20 25 68 68 75 2c 25 68 68 75 00     +CSQ: %hhu,%hhu.

00002bfa <__c.6121>:
    2bfa:	25 68 68 75 2c 20 43 4c 4f 53 45 44 00              %hhu, CLOSED.

00002c07 <__c.6115>:
    2c07:	4f 4b 00                                            OK.

00002c0a <__c.6108>:
    2c0a:	25 68 68 75 20 25 68 68 75 20 25 68 68 75 20 25     %hhu %hhu %hhu %
    2c1a:	68 68 75 00                                         hhu.

00002c1e <__c.6081>:
    2c1e:	4e 4f 20 43 41 52 52 49 45 52 00                    NO CARRIER.

00002c29 <__c.6079>:
    2c29:	42 55 53 59 00                                      BUSY.

00002c2e <__c.6077>:
    2c2e:	4f 4b 00                                            OK.

00002c31 <__c.6074>:
    2c31:	2b 43 4c 43 43 3a 20 31 2c 30 2c 36 2c 00           +CLCC: 1,0,6,.

00002c3f <__c.6071>:
    2c3f:	41 54 48 0d 00                                      ATH..

00002c44 <__c.6066>:
    2c44:	41 54 2b 43 52 45 43 3d 34 2c 22 43 3a 5c 55 73     AT+CREC=4,"C:\Us
    2c54:	65 72 5c 4e 6f 74 43 6f 6e 66 69 72 6d 2e 61 6d     er\NotConfirm.am
    2c64:	72 22 2c 30 2c 31 30 30 0d 00                       r",0,100..

00002c6e <__c.6061>:
    2c6e:	41 54 2b 43 52 45 43 3d 34 2c 22 43 3a 5c 55 73     AT+CREC=4,"C:\Us
    2c7e:	65 72 5c 43 6f 6e 66 69 72 6d 2e 61 6d 72 22 2c     er\Confirm.amr",
    2c8e:	30 2c 31 30 30 0d 00                                0,100..

00002c95 <__c.6058>:
    2c95:	2b 43 52 45 43 3a 20 30 00                          +CREC: 0.

00002c9e <__c.6055>:
    2c9e:	41 54 2b 43 52 45 43 3d 35 0d 00                    AT+CREC=5..

00002ca9 <__c.6051>:
    2ca9:	2b 43 52 45 43 3a 20 30 00                          +CREC: 0.

00002cb2 <__c.6047>:
    2cb2:	41 54 2b 43 52 45 43 3d 34 2c 22 43 3a 5c 55 73     AT+CREC=4,"C:\Us
    2cc2:	65 72 5c 43 6f 6e 66 69 72 6d 52 65 71 75 65 73     er\ConfirmReques
    2cd2:	74 2e 61 6d 72 22 2c 30 2c 31 30 30 0d 00           t.amr",0,100..

00002ce0 <__c.6044>:
    2ce0:	2b 43 52 45 43 3a 20 30 00                          +CREC: 0.

00002ce9 <__c.6040>:
    2ce9:	2e 61 6d 72 22 2c 30 2c 31 30 30 0d 00              .amr",0,100..

00002cf6 <__c.6038>:
    2cf6:	41 54 2b 43 52 45 43 3d 34 2c 22 43 3a 5c 55 73     AT+CREC=4,"C:\Us
    2d06:	65 72 5c 41 6c 61 72 6d 00                          er\Alarm.

00002d0f <__c.6035>:
    2d0f:	2b 43 4c 43 43 3a 20 31 2c 30 2c 36 2c 00           +CLCC: 1,0,6,.

00002d1d <__c.6033>:
    2d1d:	2b 43 4c 43 43 3a 20 31 2c 30 2c 30 2c 00           +CLCC: 1,0,0,.

00002d2b <__c.6030>:
    2d2b:	2b 43 4c 43 43 3a 20 31 2c 30 2c 33 2c 00           +CLCC: 1,0,3,.

00002d39 <__c.6028>:
    2d39:	2b 43 4c 43 43 3a 20 31 2c 30 2c 36 2c 00           +CLCC: 1,0,6,.

00002d47 <__c.6025>:
    2d47:	2b 43 4c 43 43 3a 20 31 2c 30 2c 32 2c 00           +CLCC: 1,0,2,.

00002d55 <__c.5995>:
    2d55:	2b 43 4c 43 43 3a 20 31 2c 30 2c 36 00              +CLCC: 1,0,6.

00002d62 <__c.5993>:
    2d62:	2b 44 54 4d 46 3a 20 31 00                          +DTMF: 1.

00002d6b <MB_Port>:
    2d6b:	ce 00 c8 00 c9 00 ca 00 cd 00 cc 00 fe 1d 04 1e     ................
    2d7b:	08 1e 09 1e                                         ....

00002d7f <MB_Role>:
	...

00002d80 <MB_Timer>:
    2d80:	46 00 47 00 03 28 b2 00 b3 00 0d 28 a4 00 a8 00     F.G..(.....(....
    2d90:	19 28                                               .(

00002d92 <CGRAM_LCD>:
    2d92:	00 04 06 1f 06 04 00 00 06 09 09 06 00 00 00 00     ................
    2da2:	00 08 08 0e 0f 1f 0f 06 00 00 0e 11 1c 11 0e 00     ................
    2db2:	0e 11 10 1c 10 11 0e 00 0a 00 0c 04 04 04 0e 00     ................
    2dc2:	0a 0e 04 04 04 04 0e 00 00 00 00 00 00 00 00 00     ................

00002dd2 <Win2LCD>:
    2dd2:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    2de2:	00 02 ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    2df2:	20 21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f      !"#$%&'()*+,-./
    2e02:	30 31 32 33 34 35 36 37 38 39 3a 3b 3c 3d 3e 3f     0123456789:;<=>?
    2e12:	40 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e 4f     @ABCDEFGHIJKLMNO
    2e22:	50 51 52 53 54 55 56 57 58 59 5a 5b 5c 5d 5e 5f     PQRSTUVWXYZ[\]^_
    2e32:	60 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e 6f     `abcdefghijklmno
    2e42:	70 71 72 73 74 75 76 77 78 79 7a 7b 01 7d e9 7f     pqrstuvwxyz{.}..
    2e52:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    2e62:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    2e72:	ff ff ff ff ff ff ff d9 a2 ff 04 ff ff ff ff 06     ................
    2e82:	ff ff 49 69 ff ff ff da b5 ff 03 ff ff ff ff 05     ..Ii............
    2e92:	41 a0 42 a1 e0 45 a3 a4 a5 a6 4b a7 4d 48 4f a8     A.B..E....K.MHO.
    2ea2:	50 43 54 a9 aa 58 e1 ab ac e2 ad ae 62 af b0 b1     PCT..X......b...
    2eb2:	61 b2 b3 b4 e3 65 b6 b7 b8 b9 ba bb bc bd 6f be     a....e........o.
    2ec2:	70 63 bf 79 e4 78 e5 c0 c1 e6 c2 c3 c4 c5 c6 c7     pc.y.x..........

00002ed2 <LineAddr.3690>:
    2ed2:	80 c0 94 d4                                         ....

00002ed6 <Mux>:
    2ed6:	00 01 02 03 04 05 06                                .......

00002edd <aCRCLo.1496>:
    2edd:	00 c0 c1 01 c3 03 02 c2 c6 06 07 c7 05 c5 c4 04     ................
    2eed:	cc 0c 0d cd 0f cf ce 0e 0a ca cb 0b c9 09 08 c8     ................
    2efd:	d8 18 19 d9 1b db da 1a 1e de df 1f dd 1d 1c dc     ................
    2f0d:	14 d4 d5 15 d7 17 16 d6 d2 12 13 d3 11 d1 d0 10     ................
    2f1d:	f0 30 31 f1 33 f3 f2 32 36 f6 f7 37 f5 35 34 f4     .01.3..26..7.54.
    2f2d:	3c fc fd 3d ff 3f 3e fe fa 3a 3b fb 39 f9 f8 38     <..=.?>..:;.9..8
    2f3d:	28 e8 e9 29 eb 2b 2a ea ee 2e 2f ef 2d ed ec 2c     (..).+*.../.-..,
    2f4d:	e4 24 25 e5 27 e7 e6 26 22 e2 e3 23 e1 21 20 e0     .$%.'..&"..#.! .
    2f5d:	a0 60 61 a1 63 a3 a2 62 66 a6 a7 67 a5 65 64 a4     .`a.c..bf..g.ed.
    2f6d:	6c ac ad 6d af 6f 6e ae aa 6a 6b ab 69 a9 a8 68     l..m.on..jk.i..h
    2f7d:	78 b8 b9 79 bb 7b 7a ba be 7e 7f bf 7d bd bc 7c     x..y.{z..~..}..|
    2f8d:	b4 74 75 b5 77 b7 b6 76 72 b2 b3 73 b1 71 70 b0     .tu.w..vr..s.qp.
    2f9d:	50 90 91 51 93 53 52 92 96 56 57 97 55 95 94 54     P..Q.SR..VW.U..T
    2fad:	9c 5c 5d 9d 5f 9f 9e 5e 5a 9a 9b 5b 99 59 58 98     .\]._..^Z..[.YX.
    2fbd:	88 48 49 89 4b 8b 8a 4a 4e 8e 8f 4f 8d 4d 4c 8c     .HI.K..JN..O.ML.
    2fcd:	44 84 85 45 87 47 46 86 82 42 43 83 41 81 80 40     D..E.GF..BC.A..@

00002fdd <aCRCHi.1495>:
    2fdd:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    2fed:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    2ffd:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    300d:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    301d:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    302d:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    303d:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    304d:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    305d:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    306d:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    307d:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    308d:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    309d:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    30ad:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    30bd:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    30cd:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    30dd:	00 40 7a 10 f3 5a 00 a0 72 4e 18 09 00 10 a5 d4     .@z..Z..rN......
    30ed:	e8 00 00 e8 76 48 17 00 00 e4 0b 54 02 00 00 ca     ....vH.....T....
    30fd:	9a 3b 00 00 00 e1 f5 05 00 00 80 96 98 00 00 00     .;..............
    310d:	40 42 0f 00 00 00 a0 86 01 00 00 00 10 27 00 00     @B...........'..
    311d:	00 00 e8 03 00 00 00 00 64 00 00 00 00 00 0a 00     ........d.......
    312d:	00 00 00 00 01 00 00 00 00 00 2c 76 d8 88 dc 67     ..........,v...g
    313d:	4f 08 23 df c1 df ae 59 e1 b1 b7 96 e5 e3 e4 53     O.#....Y.......S
    314d:	c6 3a e6 51 99 76 96 e8 e6 c2 84 26 eb 89 8c 9b     .:.Q.v.....&....
    315d:	62 ed 40 7c 6f fc ef bc 9c 9f 40 f2 ba a5 6f a5     b.@|o.....@...o.
    316d:	f4 90 05 5a 2a f7 5c 93 6b 6c f9 67 6d c1 1b fc     ...Z*.\.kl.gm...
    317d:	e0 e4 0d 47 fe f5 20 e6 b5 00 d0 ed 90 2e 03 00     ...G.. .........
    318d:	94 35 77 05 00 80 84 1e 08 00 00 20 4e 0a 00 00     .5w........ N...
    319d:	00 c8 0c 33 33 33 33 0f 98 6e 12 83 11 41 ef 8d     ...3333..n...A..
    31ad:	21 14 89 3b e6 55 16 cf fe e6 db 18 d1 84 4b 38     !..;.U........K8
    31bd:	1b f7 7c 1d 90 1d a4 bb e4 24 20 32 84 72 5e 22     ..|......$ 2.r^"
    31cd:	81 00 c9 f1 24 ec a1 e5 3d 27 00                    ....$...='.

000031d8 <__ctors_end>:
    31d8:	11 24       	eor	r1, r1
    31da:	1f be       	out	0x3f, r1	; 63
    31dc:	cf ef       	ldi	r28, 0xFF	; 255
    31de:	d1 e2       	ldi	r29, 0x21	; 33
    31e0:	de bf       	out	0x3e, r29	; 62
    31e2:	cd bf       	out	0x3d, r28	; 61
    31e4:	00 e0       	ldi	r16, 0x00	; 0
    31e6:	0c bf       	out	0x3c, r16	; 60

000031e8 <__do_copy_data>:
    31e8:	12 e0       	ldi	r17, 0x02	; 2
    31ea:	a0 e0       	ldi	r26, 0x00	; 0
    31ec:	b2 e0       	ldi	r27, 0x02	; 2
    31ee:	e0 e5       	ldi	r30, 0x50	; 80
    31f0:	f5 e0       	ldi	r31, 0x05	; 5
    31f2:	01 e0       	ldi	r16, 0x01	; 1
    31f4:	0b bf       	out	0x3b, r16	; 59
    31f6:	02 c0       	rjmp	.+4      	; 0x31fc <__do_copy_data+0x14>
    31f8:	07 90       	elpm	r0, Z+
    31fa:	0d 92       	st	X+, r0
    31fc:	aa 3d       	cpi	r26, 0xDA	; 218
    31fe:	b1 07       	cpc	r27, r17
    3200:	d9 f7       	brne	.-10     	; 0x31f8 <__do_copy_data+0x10>

00003202 <__do_clear_bss>:
    3202:	1c e0       	ldi	r17, 0x0C	; 12
    3204:	aa ed       	ldi	r26, 0xDA	; 218
    3206:	b2 e0       	ldi	r27, 0x02	; 2
    3208:	01 c0       	rjmp	.+2      	; 0x320c <.do_clear_bss_start>

0000320a <.do_clear_bss_loop>:
    320a:	1d 92       	st	X+, r1

0000320c <.do_clear_bss_start>:
    320c:	ac 32       	cpi	r26, 0x2C	; 44
    320e:	b1 07       	cpc	r27, r17
    3210:	e1 f7       	brne	.-8      	; 0x320a <.do_clear_bss_loop>
    3212:	0e 94 e3 73 	call	0xe7c6	; 0xe7c6 <main>
    3216:	0c 94 bb 7d 	jmp	0xfb76	; 0xfb76 <exit>

0000321a <__bad_interrupt>:
    321a:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000321e <rrb>:
#include <stdint.h>

// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
rrb(const uint8_t *addr)
{
    321e:	fc 01       	movw	r30, r24
	return *addr;
}
    3220:	80 81       	ld	r24, Z
    3222:	08 95       	ret

00003224 <prb>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    3224:	fc 01       	movw	r30, r24
    3226:	84 91       	lpm	r24, Z+
}
    3228:	08 95       	ret

0000322a <prw>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    322a:	fc 01       	movw	r30, r24
    322c:	25 91       	lpm	r18, Z+
    322e:	34 91       	lpm	r19, Z+
}
    3230:	c9 01       	movw	r24, r18
    3232:	08 95       	ret

00003234 <prd>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    3234:	fc 01       	movw	r30, r24
    3236:	25 91       	lpm	r18, Z+
    3238:	35 91       	lpm	r19, Z+
    323a:	45 91       	lpm	r20, Z+
    323c:	54 91       	lpm	r21, Z+
}
    323e:	b9 01       	movw	r22, r18
    3240:	ca 01       	movw	r24, r20
    3242:	08 95       	ret

00003244 <prb_f>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#if FLASHEND>0xFFFF
uint8_t
prb_f(const prog_uint8_t *addr)
{
	return pgm_read_byte_far((uint16_t)addr+0x10000);
    3244:	a0 e0       	ldi	r26, 0x00	; 0
    3246:	b0 e0       	ldi	r27, 0x00	; 0
    3248:	80 50       	subi	r24, 0x00	; 0
    324a:	90 40       	sbci	r25, 0x00	; 0
    324c:	af 4f       	sbci	r26, 0xFF	; 255
    324e:	bf 4f       	sbci	r27, 0xFF	; 255
}
    3250:	ab bf       	out	0x3b, r26	; 59
    3252:	fc 01       	movw	r30, r24
    3254:	87 91       	elpm	r24, Z+
    3256:	08 95       	ret

00003258 <prc>:

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    3258:	fc 01       	movw	r30, r24
    325a:	84 91       	lpm	r24, Z+
}
    325c:	08 95       	ret

0000325e <prp>:

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    325e:	fc 01       	movw	r30, r24
    3260:	25 91       	lpm	r18, Z+
    3262:	34 91       	lpm	r19, Z+
}
    3264:	c9 01       	movw	r24, r18
    3266:	08 95       	ret

00003268 <CRC_Seed>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
CRC_Seed(uint8_t (*GetByte)(const uint8_t*), const uint8_t *Block, uint32_t Sz, uint16_t Seed)
{
    3268:	6f 92       	push	r6
    326a:	7f 92       	push	r7
    326c:	8f 92       	push	r8
    326e:	9f 92       	push	r9
    3270:	af 92       	push	r10
    3272:	bf 92       	push	r11
    3274:	cf 92       	push	r12
    3276:	df 92       	push	r13
    3278:	ef 92       	push	r14
    327a:	ff 92       	push	r15
    327c:	0f 93       	push	r16
    327e:	1f 93       	push	r17
    3280:	cf 93       	push	r28
    3282:	df 93       	push	r29
    3284:	3c 01       	movw	r6, r24
    3286:	eb 01       	movw	r28, r22
    3288:	49 01       	movw	r8, r18
    328a:	5a 01       	movw	r10, r20
    328c:	c1 2e       	mov	r12, r17
		0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54,
		0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98,
		0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
		0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 0x40
	};
	uint8_t CRCHi=Seed>>8, CRCLo=Seed;
    328e:	d0 2e       	mov	r13, r16
	for (uint32_t i=0; i<Sz; i++) {
    3290:	21 15       	cp	r18, r1
    3292:	31 05       	cpc	r19, r1
    3294:	41 05       	cpc	r20, r1
    3296:	51 05       	cpc	r21, r1
    3298:	f9 f0       	breq	.+62     	; 0x32d8 <CRC_Seed+0x70>
    329a:	ee 24       	eor	r14, r14
    329c:	ff 24       	eor	r15, r15
    329e:	87 01       	movw	r16, r14
		uint8_t j = CRCLo^GetByte(Block+i);
    32a0:	ce 01       	movw	r24, r28
    32a2:	8e 0d       	add	r24, r14
    32a4:	9f 1d       	adc	r25, r15
    32a6:	f3 01       	movw	r30, r6
    32a8:	19 95       	eicall
		CRCLo = CRCHi^prb(aCRCHi+j);
    32aa:	d8 26       	eor	r13, r24
    32ac:	2d 2d       	mov	r18, r13
    32ae:	30 e0       	ldi	r19, 0x00	; 0

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    32b0:	c9 01       	movw	r24, r18
    32b2:	83 52       	subi	r24, 0x23	; 35
    32b4:	90 4d       	sbci	r25, 0xD0	; 208
    32b6:	fc 01       	movw	r30, r24
    32b8:	d4 90       	lpm	r13, Z+
		0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 0x40
	};
	uint8_t CRCHi=Seed>>8, CRCLo=Seed;
	for (uint32_t i=0; i<Sz; i++) {
		uint8_t j = CRCLo^GetByte(Block+i);
		CRCLo = CRCHi^prb(aCRCHi+j);
    32ba:	dc 24       	eor	r13, r12

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    32bc:	23 52       	subi	r18, 0x23	; 35
    32be:	31 4d       	sbci	r19, 0xD1	; 209
    32c0:	f9 01       	movw	r30, r18
    32c2:	c4 90       	lpm	r12, Z+
		0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98,
		0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
		0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 0x40
	};
	uint8_t CRCHi=Seed>>8, CRCLo=Seed;
	for (uint32_t i=0; i<Sz; i++) {
    32c4:	08 94       	sec
    32c6:	e1 1c       	adc	r14, r1
    32c8:	f1 1c       	adc	r15, r1
    32ca:	01 1d       	adc	r16, r1
    32cc:	11 1d       	adc	r17, r1
    32ce:	e8 14       	cp	r14, r8
    32d0:	f9 04       	cpc	r15, r9
    32d2:	0a 05       	cpc	r16, r10
    32d4:	1b 05       	cpc	r17, r11
    32d6:	20 f3       	brcs	.-56     	; 0x32a0 <CRC_Seed+0x38>
    32d8:	9c 2d       	mov	r25, r12
    32da:	80 e0       	ldi	r24, 0x00	; 0
    32dc:	2d 2d       	mov	r18, r13
    32de:	30 e0       	ldi	r19, 0x00	; 0
    32e0:	28 2b       	or	r18, r24
    32e2:	39 2b       	or	r19, r25
		uint8_t j = CRCLo^GetByte(Block+i);
		CRCLo = CRCHi^prb(aCRCHi+j);
		CRCHi = prb(aCRCLo+j);
	}
	return CRCHi<<8|CRCLo;
}
    32e4:	c9 01       	movw	r24, r18
    32e6:	df 91       	pop	r29
    32e8:	cf 91       	pop	r28
    32ea:	1f 91       	pop	r17
    32ec:	0f 91       	pop	r16
    32ee:	ff 90       	pop	r15
    32f0:	ef 90       	pop	r14
    32f2:	df 90       	pop	r13
    32f4:	cf 90       	pop	r12
    32f6:	bf 90       	pop	r11
    32f8:	af 90       	pop	r10
    32fa:	9f 90       	pop	r9
    32fc:	8f 90       	pop	r8
    32fe:	7f 90       	pop	r7
    3300:	6f 90       	pop	r6
    3302:	08 95       	ret

00003304 <CRC>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
CRC(uint8_t (*GetByte)(const uint8_t*), const uint8_t *Block, uint32_t Sz)
{
    3304:	0f 93       	push	r16
    3306:	1f 93       	push	r17
	return CRC_Seed(GetByte, Block, Sz, 0xFFFF);
    3308:	0f ef       	ldi	r16, 0xFF	; 255
    330a:	1f ef       	ldi	r17, 0xFF	; 255
    330c:	0e 94 34 19 	call	0x3268	; 0x3268 <CRC_Seed>
}
    3310:	1f 91       	pop	r17
    3312:	0f 91       	pop	r16
    3314:	08 95       	ret

00003316 <CRC_Flash_calc>:

// ~~~~~~~~~~~~~~~~~
static uint16_t
CRC_Flash_calc(void)
{
    3316:	0f 93       	push	r16
    3318:	1f 93       	push	r17
	#if FLASHEND<0xFFFF
		return CRC(prb, NULL, (uint32_t)FLASHEND+1);
	#else
		return CRC_Seed(prb_f, NULL, FLASHEND-0xFFFF, CRC(prb, NULL, 0x10000));
    331a:	82 e1       	ldi	r24, 0x12	; 18
    331c:	99 e1       	ldi	r25, 0x19	; 25
    331e:	60 e0       	ldi	r22, 0x00	; 0
    3320:	70 e0       	ldi	r23, 0x00	; 0
    3322:	20 e0       	ldi	r18, 0x00	; 0
    3324:	30 e0       	ldi	r19, 0x00	; 0
    3326:	41 e0       	ldi	r20, 0x01	; 1
    3328:	50 e0       	ldi	r21, 0x00	; 0
    332a:	0e 94 82 19 	call	0x3304	; 0x3304 <CRC>
    332e:	8c 01       	movw	r16, r24
    3330:	82 e2       	ldi	r24, 0x22	; 34
    3332:	99 e1       	ldi	r25, 0x19	; 25
    3334:	60 e0       	ldi	r22, 0x00	; 0
    3336:	70 e0       	ldi	r23, 0x00	; 0
    3338:	20 e0       	ldi	r18, 0x00	; 0
    333a:	30 e0       	ldi	r19, 0x00	; 0
    333c:	43 e0       	ldi	r20, 0x03	; 3
    333e:	50 e0       	ldi	r21, 0x00	; 0
    3340:	0e 94 34 19 	call	0x3268	; 0x3268 <CRC_Seed>
	#endif
}
    3344:	1f 91       	pop	r17
    3346:	0f 91       	pop	r16
    3348:	08 95       	ret

0000334a <CRC_EEPROM_calc>:

// ~~~~~~~~~~~~~~~~~~
static uint16_t
CRC_EEPROM_calc(void)
{
    334a:	cf 92       	push	r12
    334c:	df 92       	push	r13
    334e:	ef 92       	push	r14
    3350:	ff 92       	push	r15
    3352:	0f 93       	push	r16
    3354:	1f 93       	push	r17
	return
    3356:	9e e4       	ldi	r25, 0x4E	; 78
    3358:	c9 2e       	mov	r12, r25
    335a:	9e e4       	ldi	r25, 0x4E	; 78
    335c:	d9 2e       	mov	r13, r25
    335e:	88 e3       	ldi	r24, 0x38	; 56
    3360:	e8 2e       	mov	r14, r24
    3362:	81 e0       	ldi	r24, 0x01	; 1
    3364:	f8 2e       	mov	r15, r24
    3366:	97 01       	movw	r18, r14
    3368:	40 e0       	ldi	r20, 0x00	; 0
    336a:	50 e0       	ldi	r21, 0x00	; 0
    336c:	c6 01       	movw	r24, r12
    336e:	60 e0       	ldi	r22, 0x00	; 0
    3370:	70 e0       	ldi	r23, 0x00	; 0
    3372:	0e 94 82 19 	call	0x3304	; 0x3304 <CRC>
    3376:	8c 01       	movw	r16, r24
    3378:	2b ef       	ldi	r18, 0xFB	; 251
    337a:	3f e0       	ldi	r19, 0x0F	; 15
    337c:	2e 19       	sub	r18, r14
    337e:	3f 09       	sbc	r19, r15
    3380:	40 e0       	ldi	r20, 0x00	; 0
    3382:	50 e0       	ldi	r21, 0x00	; 0
    3384:	c6 01       	movw	r24, r12
    3386:	65 e0       	ldi	r22, 0x05	; 5
    3388:	70 e0       	ldi	r23, 0x00	; 0
    338a:	e6 0e       	add	r14, r22
    338c:	f7 1e       	adc	r15, r23
    338e:	b7 01       	movw	r22, r14
    3390:	0e 94 34 19 	call	0x3268	; 0x3268 <CRC_Seed>
		CRC_Seed(erb, (uint8_t*)&MemCheck_stor+sizeof(MemCheck_stor), E2END-((uint16_t)&MemCheck_stor-1)-sizeof(MemCheck_stor),
			CRC(erb, NULL, (uint16_t)&MemCheck_stor));
}
    3394:	1f 91       	pop	r17
    3396:	0f 91       	pop	r16
    3398:	ff 90       	pop	r15
    339a:	ef 90       	pop	r14
    339c:	df 90       	pop	r13
    339e:	cf 90       	pop	r12
    33a0:	08 95       	ret

000033a2 <InterruInit>:
InterruInit(void)
{
	#ifdef PMIC
		PMIC.CTRL = (uint8_t)(~PMIC_RREN_bm &~PMIC_IVSEL_bm) |PMIC_HILVLEN_bm |PMIC_MEDLVLEN_bm |PMIC_LOLVLEN_bm;
	#endif
	sei();
    33a2:	78 94       	sei
}
    33a4:	08 95       	ret

000033a6 <IntOff>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    33a6:	8f b7       	in	r24, 0x3f	; 63
    33a8:	80 78       	andi	r24, 0x80	; 128
    33aa:	80 93 ec 02 	sts	0x02EC, r24
	cli();
    33ae:	f8 94       	cli
	return interru_enub_flg;
}
    33b0:	08 95       	ret

000033b2 <IntOn>:

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    33b2:	80 91 ec 02 	lds	r24, 0x02EC
    33b6:	88 23       	and	r24, r24
    33b8:	09 f0       	breq	.+2      	; 0x33bc <IntOn+0xa>
		sei();
    33ba:	78 94       	sei
	return interru_enub_flg;
}
    33bc:	08 95       	ret

000033be <WdtOn>:

// ~~~~~~~~
void
WdtOn(void)
{
	wdt_reset();
    33be:	a8 95       	wdr
	wdt_enable(WDTO_2S);
    33c0:	2f e0       	ldi	r18, 0x0F	; 15
    33c2:	88 e1       	ldi	r24, 0x18	; 24
    33c4:	90 e0       	ldi	r25, 0x00	; 0
    33c6:	0f b6       	in	r0, 0x3f	; 63
    33c8:	f8 94       	cli
    33ca:	a8 95       	wdr
    33cc:	80 93 60 00 	sts	0x0060, r24
    33d0:	0f be       	out	0x3f, r0	; 63
    33d2:	20 93 60 00 	sts	0x0060, r18
}
    33d6:	08 95       	ret

000033d8 <Timer8_ISR_Alloc>:

// ~~~~~~~~~~~~~~
uint8_t
Timer8_ISR_Alloc(void)
{
	uint8_t N = VacantTimer8_ISR;
    33d8:	80 91 da 02 	lds	r24, 0x02DA
	VacantTimer8_ISR++;
    33dc:	8f 5f       	subi	r24, 0xFF	; 255
    33de:	80 93 da 02 	sts	0x02DA, r24
    33e2:	81 50       	subi	r24, 0x01	; 1
	return N;
}
    33e4:	08 95       	ret

000033e6 <Timer8Alloc>:

uint8_t
Timer8Alloc(void)
{
	uint8_t N = VacantTimer8;
    33e6:	80 91 cc 02 	lds	r24, 0x02CC
	VacantTimer8++;
    33ea:	8f 5f       	subi	r24, 0xFF	; 255
    33ec:	80 93 cc 02 	sts	0x02CC, r24
    33f0:	81 50       	subi	r24, 0x01	; 1
	return N;
}
    33f2:	08 95       	ret

000033f4 <Timer16Alloc>:

// ~~~~~~~~~~~~~~~
uint8_t
Timer16Alloc(void)
{
	uint8_t N = VacantTimer16;
    33f4:	80 91 cd 02 	lds	r24, 0x02CD
	VacantTimer16++;
    33f8:	8f 5f       	subi	r24, 0xFF	; 255
    33fa:	80 93 cd 02 	sts	0x02CD, r24
    33fe:	81 50       	subi	r24, 0x01	; 1
	return N;
}
    3400:	08 95       	ret

00003402 <Timer32Alloc>:

// ~~~~~~~~~~~~~~~
uint8_t
Timer32Alloc(void)
{
	uint8_t N = VacantTimer32;
    3402:	80 91 ce 02 	lds	r24, 0x02CE
	VacantTimer32++;
    3406:	8f 5f       	subi	r24, 0xFF	; 255
    3408:	80 93 ce 02 	sts	0x02CE, r24
    340c:	81 50       	subi	r24, 0x01	; 1
	return N;
}
    340e:	08 95       	ret

00003410 <Timer8_ISR_AppAlloc>:
// ~~~~~~~~~~~~~~

uint8_t
Timer8_ISR_AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    3410:	88 23       	and	r24, r24
    3412:	39 f0       	breq	.+14     	; 0x3422 <Timer8_ISR_AppAlloc+0x12>
	uint8_t N = VacantTimer8_ISR;
    3414:	90 91 da 02 	lds	r25, 0x02DA
	VacantTimer8_ISR+=n;
    3418:	89 0f       	add	r24, r25
    341a:	80 93 da 02 	sts	0x02DA, r24
	return N;
}
    341e:	89 2f       	mov	r24, r25
    3420:	08 95       	ret
// ~~~~~~~~~~~~~~

uint8_t
Timer8_ISR_AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    3422:	90 e0       	ldi	r25, 0x00	; 0
	uint8_t N = VacantTimer8_ISR;
	VacantTimer8_ISR+=n;
	return N;
}
    3424:	89 2f       	mov	r24, r25
    3426:	08 95       	ret

00003428 <Timer8AppAlloc>:

uint8_t
Timer8AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    3428:	88 23       	and	r24, r24
    342a:	39 f0       	breq	.+14     	; 0x343a <Timer8AppAlloc+0x12>
	uint8_t N = VacantTimer8;
    342c:	90 91 cc 02 	lds	r25, 0x02CC
	VacantTimer8+=n;
    3430:	89 0f       	add	r24, r25
    3432:	80 93 cc 02 	sts	0x02CC, r24
	return N;
}
    3436:	89 2f       	mov	r24, r25
    3438:	08 95       	ret
}

uint8_t
Timer8AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    343a:	90 e0       	ldi	r25, 0x00	; 0
	uint8_t N = VacantTimer8;
	VacantTimer8+=n;
	return N;
}
    343c:	89 2f       	mov	r24, r25
    343e:	08 95       	ret

00003440 <Timer16AppAlloc>:

// ~~~~~~~~~~~~~~~
uint8_t
Timer16AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    3440:	88 23       	and	r24, r24
    3442:	39 f0       	breq	.+14     	; 0x3452 <Timer16AppAlloc+0x12>
	uint8_t N = VacantTimer16;
    3444:	90 91 cd 02 	lds	r25, 0x02CD
	VacantTimer16+=n;
    3448:	89 0f       	add	r24, r25
    344a:	80 93 cd 02 	sts	0x02CD, r24
	return N;
}
    344e:	89 2f       	mov	r24, r25
    3450:	08 95       	ret

// ~~~~~~~~~~~~~~~
uint8_t
Timer16AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    3452:	90 e0       	ldi	r25, 0x00	; 0
	uint8_t N = VacantTimer16;
	VacantTimer16+=n;
	return N;
}
    3454:	89 2f       	mov	r24, r25
    3456:	08 95       	ret

00003458 <Timer32AppAlloc>:

// ~~~~~~~~~~~~~~~
uint8_t
Timer32AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    3458:	88 23       	and	r24, r24
    345a:	39 f0       	breq	.+14     	; 0x346a <Timer32AppAlloc+0x12>
	uint8_t N = VacantTimer32;
    345c:	90 91 ce 02 	lds	r25, 0x02CE
	VacantTimer32+=n;
    3460:	89 0f       	add	r24, r25
    3462:	80 93 ce 02 	sts	0x02CE, r24
	return N;
}
    3466:	89 2f       	mov	r24, r25
    3468:	08 95       	ret

// ~~~~~~~~~~~~~~~
uint8_t
Timer32AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    346a:	90 e0       	ldi	r25, 0x00	; 0
	uint8_t N = VacantTimer32;
	VacantTimer32+=n;
	return N;
}
    346c:	89 2f       	mov	r24, r25
    346e:	08 95       	ret

00003470 <Timer8_ISR_SysAlloc>:

// ~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer8_ISR_SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys_ISR;
    3470:	90 91 db 02 	lds	r25, 0x02DB
	VacantTimer8Sys_ISR += n;
    3474:	89 0f       	add	r24, r25
    3476:	80 93 db 02 	sts	0x02DB, r24
	return N;
}
    347a:	89 2f       	mov	r24, r25
    347c:	08 95       	ret

0000347e <Timer8SysAlloc>:

uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    347e:	90 91 cf 02 	lds	r25, 0x02CF
	VacantTimer8Sys += n;
    3482:	89 0f       	add	r24, r25
    3484:	80 93 cf 02 	sts	0x02CF, r24
	return N;
}
    3488:	89 2f       	mov	r24, r25
    348a:	08 95       	ret

0000348c <Timer16SysAlloc>:

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    348c:	90 91 d0 02 	lds	r25, 0x02D0
	VacantTimer16Sys += n;
    3490:	89 0f       	add	r24, r25
    3492:	80 93 d0 02 	sts	0x02D0, r24
	return N;
}
    3496:	89 2f       	mov	r24, r25
    3498:	08 95       	ret

0000349a <Timer32SysAlloc>:

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer32SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer32Sys;
    349a:	90 91 d1 02 	lds	r25, 0x02D1
	VacantTimer32Sys += n;
    349e:	89 0f       	add	r24, r25
    34a0:	80 93 d1 02 	sts	0x02D1, r24
	return N;
}
    34a4:	89 2f       	mov	r24, r25
    34a6:	08 95       	ret

000034a8 <StartTimer8_ISR>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
StartTimer8_ISR(uint8_t TimerN, uint8_t Timeout)
{
    34a8:	98 2f       	mov	r25, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    34aa:	3f b7       	in	r19, 0x3f	; 63
    34ac:	30 78       	andi	r19, 0x80	; 128
    34ae:	30 93 ec 02 	sts	0x02EC, r19
	cli();
    34b2:	f8 94       	cli
	IntOff();
	if ((Timer8_ISR[TimerN]=Timeout)>0)
    34b4:	48 2f       	mov	r20, r24
    34b6:	50 e0       	ldi	r21, 0x00	; 0
    34b8:	fa 01       	movw	r30, r20
    34ba:	e3 51       	subi	r30, 0x13	; 19
    34bc:	fd 4f       	sbci	r31, 0xFD	; 253
    34be:	60 83       	st	Z, r22
    34c0:	80 81       	ld	r24, Z
    34c2:	88 23       	and	r24, r24
    34c4:	c1 f0       	breq	.+48     	; 0x34f6 <StartTimer8_ISR+0x4e>
		Timer8_ISR_Flg[TimerN/8] &=~(1<<TimerN%8);
    34c6:	96 95       	lsr	r25
    34c8:	96 95       	lsr	r25
    34ca:	96 95       	lsr	r25
    34cc:	e9 2f       	mov	r30, r25
    34ce:	f0 e0       	ldi	r31, 0x00	; 0
    34d0:	e3 55       	subi	r30, 0x53	; 83
    34d2:	fb 4f       	sbci	r31, 0xFB	; 251
    34d4:	20 81       	ld	r18, Z
    34d6:	47 70       	andi	r20, 0x07	; 7
    34d8:	50 70       	andi	r21, 0x00	; 0
    34da:	81 e0       	ldi	r24, 0x01	; 1
    34dc:	90 e0       	ldi	r25, 0x00	; 0
    34de:	02 c0       	rjmp	.+4      	; 0x34e4 <StartTimer8_ISR+0x3c>
    34e0:	88 0f       	add	r24, r24
    34e2:	99 1f       	adc	r25, r25
    34e4:	4a 95       	dec	r20
    34e6:	e2 f7       	brpl	.-8      	; 0x34e0 <StartTimer8_ISR+0x38>
    34e8:	80 95       	com	r24
    34ea:	82 23       	and	r24, r18
    34ec:	80 83       	st	Z, r24

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    34ee:	33 23       	and	r19, r19
    34f0:	09 f0       	breq	.+2      	; 0x34f4 <StartTimer8_ISR+0x4c>
		sei();
    34f2:	78 94       	sei
    34f4:	08 95       	ret
	else
		Timer8_ISR_Flg[TimerN/8] |=(1<<TimerN%8);
    34f6:	96 95       	lsr	r25
    34f8:	96 95       	lsr	r25
    34fa:	96 95       	lsr	r25
    34fc:	e9 2f       	mov	r30, r25
    34fe:	f0 e0       	ldi	r31, 0x00	; 0
    3500:	e3 55       	subi	r30, 0x53	; 83
    3502:	fb 4f       	sbci	r31, 0xFB	; 251
    3504:	20 81       	ld	r18, Z
    3506:	47 70       	andi	r20, 0x07	; 7
    3508:	50 70       	andi	r21, 0x00	; 0
    350a:	81 e0       	ldi	r24, 0x01	; 1
    350c:	90 e0       	ldi	r25, 0x00	; 0
    350e:	02 c0       	rjmp	.+4      	; 0x3514 <StartTimer8_ISR+0x6c>
    3510:	88 0f       	add	r24, r24
    3512:	99 1f       	adc	r25, r25
    3514:	4a 95       	dec	r20
    3516:	e2 f7       	brpl	.-8      	; 0x3510 <StartTimer8_ISR+0x68>
    3518:	28 2b       	or	r18, r24
    351a:	20 83       	st	Z, r18
    351c:	e8 cf       	rjmp	.-48     	; 0x34ee <StartTimer8_ISR+0x46>

0000351e <StartTimer8>:
}


void
StartTimer8(uint8_t TimerN, uint8_t Timeout)
{
    351e:	98 2f       	mov	r25, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3520:	3f b7       	in	r19, 0x3f	; 63
    3522:	30 78       	andi	r19, 0x80	; 128
    3524:	30 93 ec 02 	sts	0x02EC, r19
	cli();
    3528:	f8 94       	cli
	IntOff();
	if ((Timer8[TimerN]=Timeout)>0)
    352a:	48 2f       	mov	r20, r24
    352c:	50 e0       	ldi	r21, 0x00	; 0
    352e:	fa 01       	movw	r30, r20
    3530:	eb 50       	subi	r30, 0x0B	; 11
    3532:	fd 4f       	sbci	r31, 0xFD	; 253
    3534:	60 83       	st	Z, r22
    3536:	80 81       	ld	r24, Z
    3538:	88 23       	and	r24, r24
    353a:	c1 f0       	breq	.+48     	; 0x356c <StartTimer8+0x4e>
		Timer8Flg[TimerN/8] &=~(1<<TimerN%8);
    353c:	96 95       	lsr	r25
    353e:	96 95       	lsr	r25
    3540:	96 95       	lsr	r25
    3542:	e9 2f       	mov	r30, r25
    3544:	f0 e0       	ldi	r31, 0x00	; 0
    3546:	e1 55       	subi	r30, 0x51	; 81
    3548:	fb 4f       	sbci	r31, 0xFB	; 251
    354a:	20 81       	ld	r18, Z
    354c:	47 70       	andi	r20, 0x07	; 7
    354e:	50 70       	andi	r21, 0x00	; 0
    3550:	81 e0       	ldi	r24, 0x01	; 1
    3552:	90 e0       	ldi	r25, 0x00	; 0
    3554:	02 c0       	rjmp	.+4      	; 0x355a <StartTimer8+0x3c>
    3556:	88 0f       	add	r24, r24
    3558:	99 1f       	adc	r25, r25
    355a:	4a 95       	dec	r20
    355c:	e2 f7       	brpl	.-8      	; 0x3556 <StartTimer8+0x38>
    355e:	80 95       	com	r24
    3560:	82 23       	and	r24, r18
    3562:	80 83       	st	Z, r24

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3564:	33 23       	and	r19, r19
    3566:	09 f0       	breq	.+2      	; 0x356a <StartTimer8+0x4c>
		sei();
    3568:	78 94       	sei
    356a:	08 95       	ret
	else
		Timer8Flg[TimerN/8] |=(1<<TimerN%8);
    356c:	96 95       	lsr	r25
    356e:	96 95       	lsr	r25
    3570:	96 95       	lsr	r25
    3572:	e9 2f       	mov	r30, r25
    3574:	f0 e0       	ldi	r31, 0x00	; 0
    3576:	e1 55       	subi	r30, 0x51	; 81
    3578:	fb 4f       	sbci	r31, 0xFB	; 251
    357a:	20 81       	ld	r18, Z
    357c:	47 70       	andi	r20, 0x07	; 7
    357e:	50 70       	andi	r21, 0x00	; 0
    3580:	81 e0       	ldi	r24, 0x01	; 1
    3582:	90 e0       	ldi	r25, 0x00	; 0
    3584:	02 c0       	rjmp	.+4      	; 0x358a <StartTimer8+0x6c>
    3586:	88 0f       	add	r24, r24
    3588:	99 1f       	adc	r25, r25
    358a:	4a 95       	dec	r20
    358c:	e2 f7       	brpl	.-8      	; 0x3586 <StartTimer8+0x68>
    358e:	28 2b       	or	r18, r24
    3590:	20 83       	st	Z, r18
    3592:	e8 cf       	rjmp	.-48     	; 0x3564 <StartTimer8+0x46>

00003594 <StartTimer16>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
StartTimer16(uint8_t TimerN, uint16_t Timeout)
{
    3594:	28 2f       	mov	r18, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3596:	3f b7       	in	r19, 0x3f	; 63
    3598:	30 78       	andi	r19, 0x80	; 128
    359a:	30 93 ec 02 	sts	0x02EC, r19
	cli();
    359e:	f8 94       	cli
	IntOff();
	if ((Timer16[TimerN]=Timeout)>0)
    35a0:	48 2f       	mov	r20, r24
    35a2:	50 e0       	ldi	r21, 0x00	; 0
    35a4:	fa 01       	movw	r30, r20
    35a6:	ee 0f       	add	r30, r30
    35a8:	ff 1f       	adc	r31, r31
    35aa:	e3 5b       	subi	r30, 0xB3	; 179
    35ac:	fc 4f       	sbci	r31, 0xFC	; 252
    35ae:	71 83       	std	Z+1, r23	; 0x01
    35b0:	60 83       	st	Z, r22
    35b2:	80 81       	ld	r24, Z
    35b4:	91 81       	ldd	r25, Z+1	; 0x01
    35b6:	89 2b       	or	r24, r25
    35b8:	c1 f0       	breq	.+48     	; 0x35ea <StartTimer16+0x56>
		Timer16Flg[TimerN/8] &=~(1<<TimerN%8);
    35ba:	26 95       	lsr	r18
    35bc:	26 95       	lsr	r18
    35be:	26 95       	lsr	r18
    35c0:	e2 2f       	mov	r30, r18
    35c2:	f0 e0       	ldi	r31, 0x00	; 0
    35c4:	e5 54       	subi	r30, 0x45	; 69
    35c6:	fb 4f       	sbci	r31, 0xFB	; 251
    35c8:	20 81       	ld	r18, Z
    35ca:	47 70       	andi	r20, 0x07	; 7
    35cc:	50 70       	andi	r21, 0x00	; 0
    35ce:	81 e0       	ldi	r24, 0x01	; 1
    35d0:	90 e0       	ldi	r25, 0x00	; 0
    35d2:	02 c0       	rjmp	.+4      	; 0x35d8 <StartTimer16+0x44>
    35d4:	88 0f       	add	r24, r24
    35d6:	99 1f       	adc	r25, r25
    35d8:	4a 95       	dec	r20
    35da:	e2 f7       	brpl	.-8      	; 0x35d4 <StartTimer16+0x40>
    35dc:	80 95       	com	r24
    35de:	82 23       	and	r24, r18
    35e0:	80 83       	st	Z, r24

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    35e2:	33 23       	and	r19, r19
    35e4:	09 f0       	breq	.+2      	; 0x35e8 <StartTimer16+0x54>
		sei();
    35e6:	78 94       	sei
    35e8:	08 95       	ret
	else
		Timer16Flg[TimerN/8] |=(1<<TimerN%8);
    35ea:	26 95       	lsr	r18
    35ec:	26 95       	lsr	r18
    35ee:	26 95       	lsr	r18
    35f0:	e2 2f       	mov	r30, r18
    35f2:	f0 e0       	ldi	r31, 0x00	; 0
    35f4:	e5 54       	subi	r30, 0x45	; 69
    35f6:	fb 4f       	sbci	r31, 0xFB	; 251
    35f8:	20 81       	ld	r18, Z
    35fa:	47 70       	andi	r20, 0x07	; 7
    35fc:	50 70       	andi	r21, 0x00	; 0
    35fe:	81 e0       	ldi	r24, 0x01	; 1
    3600:	90 e0       	ldi	r25, 0x00	; 0
    3602:	02 c0       	rjmp	.+4      	; 0x3608 <StartTimer16+0x74>
    3604:	88 0f       	add	r24, r24
    3606:	99 1f       	adc	r25, r25
    3608:	4a 95       	dec	r20
    360a:	e2 f7       	brpl	.-8      	; 0x3604 <StartTimer16+0x70>
    360c:	28 2b       	or	r18, r24
    360e:	20 83       	st	Z, r18
    3610:	e8 cf       	rjmp	.-48     	; 0x35e2 <StartTimer16+0x4e>

00003612 <StartTimer32>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
StartTimer32(uint8_t TimerN, uint32_t Timeout)
{
    3612:	cf 93       	push	r28
    3614:	df 93       	push	r29
    3616:	28 2f       	mov	r18, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3618:	3f b7       	in	r19, 0x3f	; 63
    361a:	30 78       	andi	r19, 0x80	; 128
    361c:	30 93 ec 02 	sts	0x02EC, r19
	cli();
    3620:	f8 94       	cli
	IntOff();
	if ((Timer32[TimerN]=Timeout)>0)
    3622:	c8 2f       	mov	r28, r24
    3624:	d0 e0       	ldi	r29, 0x00	; 0
    3626:	fe 01       	movw	r30, r28
    3628:	ee 0f       	add	r30, r30
    362a:	ff 1f       	adc	r31, r31
    362c:	ee 0f       	add	r30, r30
    362e:	ff 1f       	adc	r31, r31
    3630:	e3 5f       	subi	r30, 0xF3	; 243
    3632:	fb 4f       	sbci	r31, 0xFB	; 251
    3634:	40 83       	st	Z, r20
    3636:	51 83       	std	Z+1, r21	; 0x01
    3638:	62 83       	std	Z+2, r22	; 0x02
    363a:	73 83       	std	Z+3, r23	; 0x03
    363c:	80 81       	ld	r24, Z
    363e:	91 81       	ldd	r25, Z+1	; 0x01
    3640:	a2 81       	ldd	r26, Z+2	; 0x02
    3642:	b3 81       	ldd	r27, Z+3	; 0x03
    3644:	00 97       	sbiw	r24, 0x00	; 0
    3646:	a1 05       	cpc	r26, r1
    3648:	b1 05       	cpc	r27, r1
    364a:	d1 f0       	breq	.+52     	; 0x3680 <StartTimer32+0x6e>
		Timer32Flg[TimerN/8] &=~(1<<TimerN%8);
    364c:	26 95       	lsr	r18
    364e:	26 95       	lsr	r18
    3650:	26 95       	lsr	r18
    3652:	e2 2f       	mov	r30, r18
    3654:	f0 e0       	ldi	r31, 0x00	; 0
    3656:	e8 53       	subi	r30, 0x38	; 56
    3658:	fb 4f       	sbci	r31, 0xFB	; 251
    365a:	20 81       	ld	r18, Z
    365c:	c7 70       	andi	r28, 0x07	; 7
    365e:	d0 70       	andi	r29, 0x00	; 0
    3660:	81 e0       	ldi	r24, 0x01	; 1
    3662:	90 e0       	ldi	r25, 0x00	; 0
    3664:	02 c0       	rjmp	.+4      	; 0x366a <StartTimer32+0x58>
    3666:	88 0f       	add	r24, r24
    3668:	99 1f       	adc	r25, r25
    366a:	ca 95       	dec	r28
    366c:	e2 f7       	brpl	.-8      	; 0x3666 <StartTimer32+0x54>
    366e:	80 95       	com	r24
    3670:	82 23       	and	r24, r18
    3672:	80 83       	st	Z, r24

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3674:	33 23       	and	r19, r19
    3676:	09 f0       	breq	.+2      	; 0x367a <StartTimer32+0x68>
		sei();
    3678:	78 94       	sei
	else
		Timer32Flg[TimerN/8] |=(1<<TimerN%8);
	IntOn();
}
    367a:	df 91       	pop	r29
    367c:	cf 91       	pop	r28
    367e:	08 95       	ret
{
	IntOff();
	if ((Timer32[TimerN]=Timeout)>0)
		Timer32Flg[TimerN/8] &=~(1<<TimerN%8);
	else
		Timer32Flg[TimerN/8] |=(1<<TimerN%8);
    3680:	26 95       	lsr	r18
    3682:	26 95       	lsr	r18
    3684:	26 95       	lsr	r18
    3686:	e2 2f       	mov	r30, r18
    3688:	f0 e0       	ldi	r31, 0x00	; 0
    368a:	e8 53       	subi	r30, 0x38	; 56
    368c:	fb 4f       	sbci	r31, 0xFB	; 251
    368e:	20 81       	ld	r18, Z
    3690:	c7 70       	andi	r28, 0x07	; 7
    3692:	d0 70       	andi	r29, 0x00	; 0
    3694:	81 e0       	ldi	r24, 0x01	; 1
    3696:	90 e0       	ldi	r25, 0x00	; 0
    3698:	02 c0       	rjmp	.+4      	; 0x369e <StartTimer32+0x8c>
    369a:	88 0f       	add	r24, r24
    369c:	99 1f       	adc	r25, r25
    369e:	ca 95       	dec	r28
    36a0:	e2 f7       	brpl	.-8      	; 0x369a <StartTimer32+0x88>
    36a2:	28 2b       	or	r18, r24
    36a4:	20 83       	st	Z, r18
    36a6:	e6 cf       	rjmp	.-52     	; 0x3674 <StartTimer32+0x62>

000036a8 <StopTimer8_ISR>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    36a8:	4f b7       	in	r20, 0x3f	; 63
    36aa:	40 78       	andi	r20, 0x80	; 128
    36ac:	40 93 ec 02 	sts	0x02EC, r20
	cli();
    36b0:	f8 94       	cli
// ~~~~~~~~~~~~~~~~~~~~~~~
void
StopTimer8_ISR(uint8_t TimerN)
{
	IntOff();
	Timer8_ISR_Flg[TimerN/8] |=(1<<TimerN%8);
    36b2:	e8 2f       	mov	r30, r24
    36b4:	e6 95       	lsr	r30
    36b6:	e6 95       	lsr	r30
    36b8:	e6 95       	lsr	r30
    36ba:	f0 e0       	ldi	r31, 0x00	; 0
    36bc:	e3 55       	subi	r30, 0x53	; 83
    36be:	fb 4f       	sbci	r31, 0xFB	; 251
    36c0:	90 81       	ld	r25, Z
    36c2:	87 70       	andi	r24, 0x07	; 7
    36c4:	21 e0       	ldi	r18, 0x01	; 1
    36c6:	30 e0       	ldi	r19, 0x00	; 0
    36c8:	02 c0       	rjmp	.+4      	; 0x36ce <StopTimer8_ISR+0x26>
    36ca:	22 0f       	add	r18, r18
    36cc:	33 1f       	adc	r19, r19
    36ce:	8a 95       	dec	r24
    36d0:	e2 f7       	brpl	.-8      	; 0x36ca <StopTimer8_ISR+0x22>
    36d2:	92 2b       	or	r25, r18
    36d4:	90 83       	st	Z, r25

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    36d6:	44 23       	and	r20, r20
    36d8:	09 f0       	breq	.+2      	; 0x36dc <StopTimer8_ISR+0x34>
		sei();
    36da:	78 94       	sei
    36dc:	08 95       	ret

000036de <StopTimer8>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    36de:	4f b7       	in	r20, 0x3f	; 63
    36e0:	40 78       	andi	r20, 0x80	; 128
    36e2:	40 93 ec 02 	sts	0x02EC, r20
	cli();
    36e6:	f8 94       	cli

void
StopTimer8(uint8_t TimerN)
{
	IntOff();
	Timer8Flg[TimerN/8] |=(1<<TimerN%8);
    36e8:	e8 2f       	mov	r30, r24
    36ea:	e6 95       	lsr	r30
    36ec:	e6 95       	lsr	r30
    36ee:	e6 95       	lsr	r30
    36f0:	f0 e0       	ldi	r31, 0x00	; 0
    36f2:	e1 55       	subi	r30, 0x51	; 81
    36f4:	fb 4f       	sbci	r31, 0xFB	; 251
    36f6:	90 81       	ld	r25, Z
    36f8:	87 70       	andi	r24, 0x07	; 7
    36fa:	21 e0       	ldi	r18, 0x01	; 1
    36fc:	30 e0       	ldi	r19, 0x00	; 0
    36fe:	02 c0       	rjmp	.+4      	; 0x3704 <StopTimer8+0x26>
    3700:	22 0f       	add	r18, r18
    3702:	33 1f       	adc	r19, r19
    3704:	8a 95       	dec	r24
    3706:	e2 f7       	brpl	.-8      	; 0x3700 <StopTimer8+0x22>
    3708:	92 2b       	or	r25, r18
    370a:	90 83       	st	Z, r25

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    370c:	44 23       	and	r20, r20
    370e:	09 f0       	breq	.+2      	; 0x3712 <StopTimer8+0x34>
		sei();
    3710:	78 94       	sei
    3712:	08 95       	ret

00003714 <StopTimer16>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3714:	4f b7       	in	r20, 0x3f	; 63
    3716:	40 78       	andi	r20, 0x80	; 128
    3718:	40 93 ec 02 	sts	0x02EC, r20
	cli();
    371c:	f8 94       	cli
// ~~~~~~~~~~~~~~~~~~~~~~~~
void
StopTimer16(uint8_t TimerN)
{
	IntOff();
	Timer16Flg[TimerN/8] |=1<<TimerN%8;
    371e:	e8 2f       	mov	r30, r24
    3720:	e6 95       	lsr	r30
    3722:	e6 95       	lsr	r30
    3724:	e6 95       	lsr	r30
    3726:	f0 e0       	ldi	r31, 0x00	; 0
    3728:	e5 54       	subi	r30, 0x45	; 69
    372a:	fb 4f       	sbci	r31, 0xFB	; 251
    372c:	90 81       	ld	r25, Z
    372e:	87 70       	andi	r24, 0x07	; 7
    3730:	21 e0       	ldi	r18, 0x01	; 1
    3732:	30 e0       	ldi	r19, 0x00	; 0
    3734:	02 c0       	rjmp	.+4      	; 0x373a <StopTimer16+0x26>
    3736:	22 0f       	add	r18, r18
    3738:	33 1f       	adc	r19, r19
    373a:	8a 95       	dec	r24
    373c:	e2 f7       	brpl	.-8      	; 0x3736 <StopTimer16+0x22>
    373e:	92 2b       	or	r25, r18
    3740:	90 83       	st	Z, r25

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3742:	44 23       	and	r20, r20
    3744:	09 f0       	breq	.+2      	; 0x3748 <StopTimer16+0x34>
		sei();
    3746:	78 94       	sei
    3748:	08 95       	ret

0000374a <StopTimer32>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    374a:	4f b7       	in	r20, 0x3f	; 63
    374c:	40 78       	andi	r20, 0x80	; 128
    374e:	40 93 ec 02 	sts	0x02EC, r20
	cli();
    3752:	f8 94       	cli
// ~~~~~~~~~~~~~~~~~~~~~~~~
void
StopTimer32(uint8_t TimerN)
{
	IntOff();
	Timer32Flg[TimerN/8] |=1<<TimerN%8;
    3754:	e8 2f       	mov	r30, r24
    3756:	e6 95       	lsr	r30
    3758:	e6 95       	lsr	r30
    375a:	e6 95       	lsr	r30
    375c:	f0 e0       	ldi	r31, 0x00	; 0
    375e:	e8 53       	subi	r30, 0x38	; 56
    3760:	fb 4f       	sbci	r31, 0xFB	; 251
    3762:	90 81       	ld	r25, Z
    3764:	87 70       	andi	r24, 0x07	; 7
    3766:	21 e0       	ldi	r18, 0x01	; 1
    3768:	30 e0       	ldi	r19, 0x00	; 0
    376a:	02 c0       	rjmp	.+4      	; 0x3770 <StopTimer32+0x26>
    376c:	22 0f       	add	r18, r18
    376e:	33 1f       	adc	r19, r19
    3770:	8a 95       	dec	r24
    3772:	e2 f7       	brpl	.-8      	; 0x376c <StopTimer32+0x22>
    3774:	92 2b       	or	r25, r18
    3776:	90 83       	st	Z, r25

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3778:	44 23       	and	r20, r20
    377a:	09 f0       	breq	.+2      	; 0x377e <StopTimer32+0x34>
		sei();
    377c:	78 94       	sei
    377e:	08 95       	ret

00003780 <Timer8Stopp_ISR>:
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer8Stopp_ISR(uint8_t TimerN)
{
	return (Timer8_ISR_Flg[TimerN/8] &(1<<TimerN%8)) && Timer8_ISR[TimerN]==0;
    3780:	e8 2f       	mov	r30, r24
    3782:	e6 95       	lsr	r30
    3784:	e6 95       	lsr	r30
    3786:	e6 95       	lsr	r30
    3788:	f0 e0       	ldi	r31, 0x00	; 0
    378a:	e3 55       	subi	r30, 0x53	; 83
    378c:	fb 4f       	sbci	r31, 0xFB	; 251
    378e:	20 81       	ld	r18, Z
    3790:	e8 2f       	mov	r30, r24
    3792:	f0 e0       	ldi	r31, 0x00	; 0
    3794:	30 e0       	ldi	r19, 0x00	; 0
    3796:	cf 01       	movw	r24, r30
    3798:	87 70       	andi	r24, 0x07	; 7
    379a:	90 70       	andi	r25, 0x00	; 0
    379c:	02 c0       	rjmp	.+4      	; 0x37a2 <Timer8Stopp_ISR+0x22>
    379e:	35 95       	asr	r19
    37a0:	27 95       	ror	r18
    37a2:	8a 95       	dec	r24
    37a4:	e2 f7       	brpl	.-8      	; 0x379e <Timer8Stopp_ISR+0x1e>
    37a6:	20 fd       	sbrc	r18, 0
    37a8:	02 c0       	rjmp	.+4      	; 0x37ae <Timer8Stopp_ISR+0x2e>
    37aa:	80 e0       	ldi	r24, 0x00	; 0
    37ac:	08 95       	ret
    37ae:	e3 51       	subi	r30, 0x13	; 19
    37b0:	fd 4f       	sbci	r31, 0xFD	; 253
    37b2:	90 81       	ld	r25, Z
    37b4:	99 23       	and	r25, r25
    37b6:	19 f4       	brne	.+6      	; 0x37be <Timer8Stopp_ISR+0x3e>
    37b8:	81 e0       	ldi	r24, 0x01	; 1
    37ba:	89 27       	eor	r24, r25
}
    37bc:	08 95       	ret
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer8Stopp_ISR(uint8_t TimerN)
{
	return (Timer8_ISR_Flg[TimerN/8] &(1<<TimerN%8)) && Timer8_ISR[TimerN]==0;
    37be:	91 e0       	ldi	r25, 0x01	; 1
    37c0:	81 e0       	ldi	r24, 0x01	; 1
    37c2:	89 27       	eor	r24, r25
}
    37c4:	08 95       	ret

000037c6 <Timer8Stopp>:

// ~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer8Stopp(uint8_t TimerN)
{
	return (Timer8Flg[TimerN/8] &(1<<TimerN%8)) && Timer8[TimerN]==0;
    37c6:	e8 2f       	mov	r30, r24
    37c8:	e6 95       	lsr	r30
    37ca:	e6 95       	lsr	r30
    37cc:	e6 95       	lsr	r30
    37ce:	f0 e0       	ldi	r31, 0x00	; 0
    37d0:	e1 55       	subi	r30, 0x51	; 81
    37d2:	fb 4f       	sbci	r31, 0xFB	; 251
    37d4:	20 81       	ld	r18, Z
    37d6:	e8 2f       	mov	r30, r24
    37d8:	f0 e0       	ldi	r31, 0x00	; 0
    37da:	30 e0       	ldi	r19, 0x00	; 0
    37dc:	cf 01       	movw	r24, r30
    37de:	87 70       	andi	r24, 0x07	; 7
    37e0:	90 70       	andi	r25, 0x00	; 0
    37e2:	02 c0       	rjmp	.+4      	; 0x37e8 <Timer8Stopp+0x22>
    37e4:	35 95       	asr	r19
    37e6:	27 95       	ror	r18
    37e8:	8a 95       	dec	r24
    37ea:	e2 f7       	brpl	.-8      	; 0x37e4 <Timer8Stopp+0x1e>
    37ec:	20 fd       	sbrc	r18, 0
    37ee:	02 c0       	rjmp	.+4      	; 0x37f4 <Timer8Stopp+0x2e>
    37f0:	80 e0       	ldi	r24, 0x00	; 0
    37f2:	08 95       	ret
    37f4:	eb 50       	subi	r30, 0x0B	; 11
    37f6:	fd 4f       	sbci	r31, 0xFD	; 253
    37f8:	90 81       	ld	r25, Z
    37fa:	99 23       	and	r25, r25
    37fc:	19 f4       	brne	.+6      	; 0x3804 <Timer8Stopp+0x3e>
    37fe:	81 e0       	ldi	r24, 0x01	; 1
    3800:	89 27       	eor	r24, r25
}
    3802:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer8Stopp(uint8_t TimerN)
{
	return (Timer8Flg[TimerN/8] &(1<<TimerN%8)) && Timer8[TimerN]==0;
    3804:	91 e0       	ldi	r25, 0x01	; 1
    3806:	81 e0       	ldi	r24, 0x01	; 1
    3808:	89 27       	eor	r24, r25
}
    380a:	08 95       	ret

0000380c <Timer16Stopp>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    380c:	4f b7       	in	r20, 0x3f	; 63
    380e:	40 78       	andi	r20, 0x80	; 128
    3810:	40 93 ec 02 	sts	0x02EC, r20
	cli();
    3814:	f8 94       	cli
// ~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16Stopp(uint8_t TimerN)
{
	IntOff();
	uint8_t T_S = (Timer16Flg[TimerN/8] &(1<<TimerN%8)) && Timer16[TimerN]==0;
    3816:	e8 2f       	mov	r30, r24
    3818:	e6 95       	lsr	r30
    381a:	e6 95       	lsr	r30
    381c:	e6 95       	lsr	r30
    381e:	f0 e0       	ldi	r31, 0x00	; 0
    3820:	e5 54       	subi	r30, 0x45	; 69
    3822:	fb 4f       	sbci	r31, 0xFB	; 251
    3824:	20 81       	ld	r18, Z
    3826:	e8 2f       	mov	r30, r24
    3828:	f0 e0       	ldi	r31, 0x00	; 0
    382a:	30 e0       	ldi	r19, 0x00	; 0
    382c:	cf 01       	movw	r24, r30
    382e:	87 70       	andi	r24, 0x07	; 7
    3830:	90 70       	andi	r25, 0x00	; 0
    3832:	02 c0       	rjmp	.+4      	; 0x3838 <Timer16Stopp+0x2c>
    3834:	35 95       	asr	r19
    3836:	27 95       	ror	r18
    3838:	8a 95       	dec	r24
    383a:	e2 f7       	brpl	.-8      	; 0x3834 <Timer16Stopp+0x28>
    383c:	20 fd       	sbrc	r18, 0
    383e:	06 c0       	rjmp	.+12     	; 0x384c <Timer16Stopp+0x40>
    3840:	20 e0       	ldi	r18, 0x00	; 0

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3842:	44 23       	and	r20, r20
    3844:	09 f0       	breq	.+2      	; 0x3848 <Timer16Stopp+0x3c>
		sei();
    3846:	78 94       	sei
	IntOn();
	return T_S;
}
    3848:	82 2f       	mov	r24, r18
    384a:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16Stopp(uint8_t TimerN)
{
	IntOff();
	uint8_t T_S = (Timer16Flg[TimerN/8] &(1<<TimerN%8)) && Timer16[TimerN]==0;
    384c:	ee 0f       	add	r30, r30
    384e:	ff 1f       	adc	r31, r31
    3850:	e3 5b       	subi	r30, 0xB3	; 179
    3852:	fc 4f       	sbci	r31, 0xFC	; 252
    3854:	80 81       	ld	r24, Z
    3856:	91 81       	ldd	r25, Z+1	; 0x01
    3858:	20 e0       	ldi	r18, 0x00	; 0
    385a:	89 2b       	or	r24, r25
    385c:	19 f4       	brne	.+6      	; 0x3864 <Timer16Stopp+0x58>
    385e:	81 e0       	ldi	r24, 0x01	; 1
    3860:	28 27       	eor	r18, r24
    3862:	ef cf       	rjmp	.-34     	; 0x3842 <Timer16Stopp+0x36>
    3864:	21 e0       	ldi	r18, 0x01	; 1
    3866:	81 e0       	ldi	r24, 0x01	; 1
    3868:	28 27       	eor	r18, r24
    386a:	eb cf       	rjmp	.-42     	; 0x3842 <Timer16Stopp+0x36>

0000386c <Timer32Stopp>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    386c:	4f b7       	in	r20, 0x3f	; 63
    386e:	40 78       	andi	r20, 0x80	; 128
    3870:	40 93 ec 02 	sts	0x02EC, r20
	cli();
    3874:	f8 94       	cli
// ~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer32Stopp(uint8_t TimerN)
{
	IntOff();
	uint8_t T_S = (Timer32Flg[TimerN/8] &(1<<TimerN%8)) && Timer32[TimerN]==0;
    3876:	e8 2f       	mov	r30, r24
    3878:	e6 95       	lsr	r30
    387a:	e6 95       	lsr	r30
    387c:	e6 95       	lsr	r30
    387e:	f0 e0       	ldi	r31, 0x00	; 0
    3880:	e8 53       	subi	r30, 0x38	; 56
    3882:	fb 4f       	sbci	r31, 0xFB	; 251
    3884:	20 81       	ld	r18, Z
    3886:	e8 2f       	mov	r30, r24
    3888:	f0 e0       	ldi	r31, 0x00	; 0
    388a:	30 e0       	ldi	r19, 0x00	; 0
    388c:	cf 01       	movw	r24, r30
    388e:	87 70       	andi	r24, 0x07	; 7
    3890:	90 70       	andi	r25, 0x00	; 0
    3892:	02 c0       	rjmp	.+4      	; 0x3898 <Timer32Stopp+0x2c>
    3894:	35 95       	asr	r19
    3896:	27 95       	ror	r18
    3898:	8a 95       	dec	r24
    389a:	e2 f7       	brpl	.-8      	; 0x3894 <Timer32Stopp+0x28>
    389c:	20 fd       	sbrc	r18, 0
    389e:	06 c0       	rjmp	.+12     	; 0x38ac <Timer32Stopp+0x40>
    38a0:	20 e0       	ldi	r18, 0x00	; 0

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    38a2:	44 23       	and	r20, r20
    38a4:	09 f0       	breq	.+2      	; 0x38a8 <Timer32Stopp+0x3c>
		sei();
    38a6:	78 94       	sei
	IntOn();
	return T_S;
}
    38a8:	82 2f       	mov	r24, r18
    38aa:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer32Stopp(uint8_t TimerN)
{
	IntOff();
	uint8_t T_S = (Timer32Flg[TimerN/8] &(1<<TimerN%8)) && Timer32[TimerN]==0;
    38ac:	ee 0f       	add	r30, r30
    38ae:	ff 1f       	adc	r31, r31
    38b0:	ee 0f       	add	r30, r30
    38b2:	ff 1f       	adc	r31, r31
    38b4:	e3 5f       	subi	r30, 0xF3	; 243
    38b6:	fb 4f       	sbci	r31, 0xFB	; 251
    38b8:	80 81       	ld	r24, Z
    38ba:	91 81       	ldd	r25, Z+1	; 0x01
    38bc:	a2 81       	ldd	r26, Z+2	; 0x02
    38be:	b3 81       	ldd	r27, Z+3	; 0x03
    38c0:	20 e0       	ldi	r18, 0x00	; 0
    38c2:	00 97       	sbiw	r24, 0x00	; 0
    38c4:	a1 05       	cpc	r26, r1
    38c6:	b1 05       	cpc	r27, r1
    38c8:	19 f4       	brne	.+6      	; 0x38d0 <Timer32Stopp+0x64>
    38ca:	81 e0       	ldi	r24, 0x01	; 1
    38cc:	28 27       	eor	r18, r24
    38ce:	e9 cf       	rjmp	.-46     	; 0x38a2 <Timer32Stopp+0x36>
    38d0:	21 e0       	ldi	r18, 0x01	; 1
    38d2:	81 e0       	ldi	r24, 0x01	; 1
    38d4:	28 27       	eor	r18, r24
    38d6:	e5 cf       	rjmp	.-54     	; 0x38a2 <Timer32Stopp+0x36>

000038d8 <ResetTimer8_ISR>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    38d8:	5f b7       	in	r21, 0x3f	; 63
    38da:	50 78       	andi	r21, 0x80	; 128
    38dc:	50 93 ec 02 	sts	0x02EC, r21
	cli();
    38e0:	f8 94       	cli
//~~~~~~~~~~~~~~~~~~~~~~~~~
void
ResetTimer8_ISR(uint8_t TimerN)
{
	IntOff();
	Timer8_ISR_Flg[TimerN/8] |=(1<<TimerN%8);
    38e2:	e8 2f       	mov	r30, r24
    38e4:	e6 95       	lsr	r30
    38e6:	e6 95       	lsr	r30
    38e8:	e6 95       	lsr	r30
    38ea:	f0 e0       	ldi	r31, 0x00	; 0
    38ec:	e3 55       	subi	r30, 0x53	; 83
    38ee:	fb 4f       	sbci	r31, 0xFB	; 251
    38f0:	40 81       	ld	r20, Z
    38f2:	a8 2f       	mov	r26, r24
    38f4:	b0 e0       	ldi	r27, 0x00	; 0
    38f6:	9d 01       	movw	r18, r26
    38f8:	27 70       	andi	r18, 0x07	; 7
    38fa:	30 70       	andi	r19, 0x00	; 0
    38fc:	81 e0       	ldi	r24, 0x01	; 1
    38fe:	90 e0       	ldi	r25, 0x00	; 0
    3900:	02 c0       	rjmp	.+4      	; 0x3906 <ResetTimer8_ISR+0x2e>
    3902:	88 0f       	add	r24, r24
    3904:	99 1f       	adc	r25, r25
    3906:	2a 95       	dec	r18
    3908:	e2 f7       	brpl	.-8      	; 0x3902 <ResetTimer8_ISR+0x2a>
    390a:	48 2b       	or	r20, r24
    390c:	40 83       	st	Z, r20

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    390e:	55 23       	and	r21, r21
    3910:	09 f0       	breq	.+2      	; 0x3914 <ResetTimer8_ISR+0x3c>
		sei();
    3912:	78 94       	sei
	IntOn();
	Timer8_ISR[TimerN] = 0;
    3914:	a3 51       	subi	r26, 0x13	; 19
    3916:	bd 4f       	sbci	r27, 0xFD	; 253
    3918:	1c 92       	st	X, r1
}
    391a:	08 95       	ret

0000391c <ResetTimer8>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    391c:	5f b7       	in	r21, 0x3f	; 63
    391e:	50 78       	andi	r21, 0x80	; 128
    3920:	50 93 ec 02 	sts	0x02EC, r21
	cli();
    3924:	f8 94       	cli

void
ResetTimer8(uint8_t TimerN)
{
	IntOff();
	Timer8Flg[TimerN/8] |=(1<<TimerN%8);
    3926:	e8 2f       	mov	r30, r24
    3928:	e6 95       	lsr	r30
    392a:	e6 95       	lsr	r30
    392c:	e6 95       	lsr	r30
    392e:	f0 e0       	ldi	r31, 0x00	; 0
    3930:	e1 55       	subi	r30, 0x51	; 81
    3932:	fb 4f       	sbci	r31, 0xFB	; 251
    3934:	40 81       	ld	r20, Z
    3936:	a8 2f       	mov	r26, r24
    3938:	b0 e0       	ldi	r27, 0x00	; 0
    393a:	9d 01       	movw	r18, r26
    393c:	27 70       	andi	r18, 0x07	; 7
    393e:	30 70       	andi	r19, 0x00	; 0
    3940:	81 e0       	ldi	r24, 0x01	; 1
    3942:	90 e0       	ldi	r25, 0x00	; 0
    3944:	02 c0       	rjmp	.+4      	; 0x394a <ResetTimer8+0x2e>
    3946:	88 0f       	add	r24, r24
    3948:	99 1f       	adc	r25, r25
    394a:	2a 95       	dec	r18
    394c:	e2 f7       	brpl	.-8      	; 0x3946 <ResetTimer8+0x2a>
    394e:	48 2b       	or	r20, r24
    3950:	40 83       	st	Z, r20

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3952:	55 23       	and	r21, r21
    3954:	09 f0       	breq	.+2      	; 0x3958 <ResetTimer8+0x3c>
		sei();
    3956:	78 94       	sei
	IntOn();
	Timer8[TimerN] = 0;
    3958:	ab 50       	subi	r26, 0x0B	; 11
    395a:	bd 4f       	sbci	r27, 0xFD	; 253
    395c:	1c 92       	st	X, r1
}
    395e:	08 95       	ret

00003960 <ResetTimer16>:

//~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ResetTimer16(uint8_t TimerN)
{
    3960:	e8 2f       	mov	r30, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3962:	5f b7       	in	r21, 0x3f	; 63
    3964:	50 78       	andi	r21, 0x80	; 128
    3966:	50 93 ec 02 	sts	0x02EC, r21
	cli();
    396a:	f8 94       	cli
	IntOff();
	Timer16Flg[TimerN/8] |=1<<TimerN%8;
    396c:	a8 2f       	mov	r26, r24
    396e:	a6 95       	lsr	r26
    3970:	a6 95       	lsr	r26
    3972:	a6 95       	lsr	r26
    3974:	b0 e0       	ldi	r27, 0x00	; 0
    3976:	a5 54       	subi	r26, 0x45	; 69
    3978:	bb 4f       	sbci	r27, 0xFB	; 251
    397a:	4c 91       	ld	r20, X
    397c:	f0 e0       	ldi	r31, 0x00	; 0
    397e:	9f 01       	movw	r18, r30
    3980:	27 70       	andi	r18, 0x07	; 7
    3982:	30 70       	andi	r19, 0x00	; 0
    3984:	81 e0       	ldi	r24, 0x01	; 1
    3986:	90 e0       	ldi	r25, 0x00	; 0
    3988:	02 c0       	rjmp	.+4      	; 0x398e <ResetTimer16+0x2e>
    398a:	88 0f       	add	r24, r24
    398c:	99 1f       	adc	r25, r25
    398e:	2a 95       	dec	r18
    3990:	e2 f7       	brpl	.-8      	; 0x398a <ResetTimer16+0x2a>
    3992:	48 2b       	or	r20, r24
    3994:	4c 93       	st	X, r20
	Timer16[TimerN] = 0;
    3996:	ee 0f       	add	r30, r30
    3998:	ff 1f       	adc	r31, r31
    399a:	e3 5b       	subi	r30, 0xB3	; 179
    399c:	fc 4f       	sbci	r31, 0xFC	; 252
    399e:	11 82       	std	Z+1, r1	; 0x01
    39a0:	10 82       	st	Z, r1

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    39a2:	55 23       	and	r21, r21
    39a4:	09 f0       	breq	.+2      	; 0x39a8 <ResetTimer16+0x48>
		sei();
    39a6:	78 94       	sei
    39a8:	08 95       	ret

000039aa <ResetTimer32>:
}

//~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ResetTimer32(uint8_t TimerN)
{
    39aa:	e8 2f       	mov	r30, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    39ac:	5f b7       	in	r21, 0x3f	; 63
    39ae:	50 78       	andi	r21, 0x80	; 128
    39b0:	50 93 ec 02 	sts	0x02EC, r21
	cli();
    39b4:	f8 94       	cli
	IntOff();
	Timer32Flg[TimerN/8] |=1<<TimerN%8;
    39b6:	a8 2f       	mov	r26, r24
    39b8:	a6 95       	lsr	r26
    39ba:	a6 95       	lsr	r26
    39bc:	a6 95       	lsr	r26
    39be:	b0 e0       	ldi	r27, 0x00	; 0
    39c0:	a8 53       	subi	r26, 0x38	; 56
    39c2:	bb 4f       	sbci	r27, 0xFB	; 251
    39c4:	4c 91       	ld	r20, X
    39c6:	f0 e0       	ldi	r31, 0x00	; 0
    39c8:	9f 01       	movw	r18, r30
    39ca:	27 70       	andi	r18, 0x07	; 7
    39cc:	30 70       	andi	r19, 0x00	; 0
    39ce:	81 e0       	ldi	r24, 0x01	; 1
    39d0:	90 e0       	ldi	r25, 0x00	; 0
    39d2:	02 c0       	rjmp	.+4      	; 0x39d8 <ResetTimer32+0x2e>
    39d4:	88 0f       	add	r24, r24
    39d6:	99 1f       	adc	r25, r25
    39d8:	2a 95       	dec	r18
    39da:	e2 f7       	brpl	.-8      	; 0x39d4 <ResetTimer32+0x2a>
    39dc:	48 2b       	or	r20, r24
    39de:	4c 93       	st	X, r20
	Timer32[TimerN] = 0;
    39e0:	ee 0f       	add	r30, r30
    39e2:	ff 1f       	adc	r31, r31
    39e4:	ee 0f       	add	r30, r30
    39e6:	ff 1f       	adc	r31, r31
    39e8:	e3 5f       	subi	r30, 0xF3	; 243
    39ea:	fb 4f       	sbci	r31, 0xFB	; 251
    39ec:	10 82       	st	Z, r1
    39ee:	11 82       	std	Z+1, r1	; 0x01
    39f0:	12 82       	std	Z+2, r1	; 0x02
    39f2:	13 82       	std	Z+3, r1	; 0x03

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    39f4:	55 23       	and	r21, r21
    39f6:	09 f0       	breq	.+2      	; 0x39fa <ResetTimer32+0x50>
		sei();
    39f8:	78 94       	sei
    39fa:	08 95       	ret

000039fc <GetTimer8_ISR>:

// ~~~~~~~~~~~~~~~~~~~~~~
uint8_t
GetTimer8_ISR(uint8_t TimerN)
{
	return Timer8_ISR[TimerN];
    39fc:	ed ee       	ldi	r30, 0xED	; 237
    39fe:	f2 e0       	ldi	r31, 0x02	; 2
    3a00:	e8 0f       	add	r30, r24
    3a02:	f1 1d       	adc	r31, r1
    3a04:	80 81       	ld	r24, Z
}
    3a06:	08 95       	ret

00003a08 <GetTimer8>:
uint8_t
GetTimer8(uint8_t TimerN)
{
	return Timer8[TimerN];
    3a08:	e5 ef       	ldi	r30, 0xF5	; 245
    3a0a:	f2 e0       	ldi	r31, 0x02	; 2
    3a0c:	e8 0f       	add	r30, r24
    3a0e:	f1 1d       	adc	r31, r1
    3a10:	80 81       	ld	r24, Z
}
    3a12:	08 95       	ret

00003a14 <GetTimer16>:

// ~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
GetTimer16(uint8_t TimerN)
{
    3a14:	e8 2f       	mov	r30, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3a16:	8f b7       	in	r24, 0x3f	; 63
    3a18:	80 78       	andi	r24, 0x80	; 128
    3a1a:	80 93 ec 02 	sts	0x02EC, r24
	cli();
    3a1e:	f8 94       	cli
	IntOff();
	uint16_t Time = Timer16[TimerN];
    3a20:	f0 e0       	ldi	r31, 0x00	; 0
    3a22:	ee 0f       	add	r30, r30
    3a24:	ff 1f       	adc	r31, r31
    3a26:	e3 5b       	subi	r30, 0xB3	; 179
    3a28:	fc 4f       	sbci	r31, 0xFC	; 252
    3a2a:	01 90       	ld	r0, Z+
    3a2c:	f0 81       	ld	r31, Z
    3a2e:	e0 2d       	mov	r30, r0

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3a30:	88 23       	and	r24, r24
    3a32:	09 f0       	breq	.+2      	; 0x3a36 <GetTimer16+0x22>
		sei();
    3a34:	78 94       	sei
	IntOn();
	return Time;
}
    3a36:	cf 01       	movw	r24, r30
    3a38:	08 95       	ret

00003a3a <GetTimer32>:

// ~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
GetTimer32(uint8_t TimerN)
{
    3a3a:	e8 2f       	mov	r30, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3a3c:	8f b7       	in	r24, 0x3f	; 63
    3a3e:	80 78       	andi	r24, 0x80	; 128
    3a40:	80 93 ec 02 	sts	0x02EC, r24
	cli();
    3a44:	f8 94       	cli
	IntOff();
	uint32_t Time = Timer32[TimerN];
    3a46:	f0 e0       	ldi	r31, 0x00	; 0
    3a48:	ee 0f       	add	r30, r30
    3a4a:	ff 1f       	adc	r31, r31
    3a4c:	ee 0f       	add	r30, r30
    3a4e:	ff 1f       	adc	r31, r31
    3a50:	e3 5f       	subi	r30, 0xF3	; 243
    3a52:	fb 4f       	sbci	r31, 0xFB	; 251
    3a54:	20 81       	ld	r18, Z
    3a56:	31 81       	ldd	r19, Z+1	; 0x01
    3a58:	42 81       	ldd	r20, Z+2	; 0x02
    3a5a:	53 81       	ldd	r21, Z+3	; 0x03

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3a5c:	88 23       	and	r24, r24
    3a5e:	09 f0       	breq	.+2      	; 0x3a62 <GetTimer32+0x28>
		sei();
    3a60:	78 94       	sei
	IntOn();
	return Time;
}
    3a62:	b9 01       	movw	r22, r18
    3a64:	ca 01       	movw	r24, r20
    3a66:	08 95       	ret

00003a68 <TimerAllocError>:
// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t TimerAllocError(void){
	return ( (VacantTimer8Sys >=  Timer8TotNumber) || (VacantTimer16Sys >=  Timer16TotNumber) || (VacantTimer32Sys >=  Timer32TotNumber) ||
    3a68:	80 91 cf 02 	lds	r24, 0x02CF
    3a6c:	88 35       	cpi	r24, 0x58	; 88
    3a6e:	a8 f4       	brcc	.+42     	; 0x3a9a <TimerAllocError+0x32>
    3a70:	80 91 d0 02 	lds	r24, 0x02D0
    3a74:	80 36       	cpi	r24, 0x60	; 96
    3a76:	88 f4       	brcc	.+34     	; 0x3a9a <TimerAllocError+0x32>
    3a78:	80 91 d1 02 	lds	r24, 0x02D1
    3a7c:	88 32       	cpi	r24, 0x28	; 40
    3a7e:	68 f4       	brcc	.+26     	; 0x3a9a <TimerAllocError+0x32>
    3a80:	80 91 cc 02 	lds	r24, 0x02CC
    3a84:	80 34       	cpi	r24, 0x40	; 64
    3a86:	48 f4       	brcc	.+18     	; 0x3a9a <TimerAllocError+0x32>
    3a88:	80 91 cd 02 	lds	r24, 0x02CD
    3a8c:	88 34       	cpi	r24, 0x48	; 72
    3a8e:	28 f4       	brcc	.+10     	; 0x3a9a <TimerAllocError+0x32>
    3a90:	90 e0       	ldi	r25, 0x00	; 0
    3a92:	80 91 ce 02 	lds	r24, 0x02CE
    3a96:	80 32       	cpi	r24, 0x20	; 32
    3a98:	08 f0       	brcs	.+2      	; 0x3a9c <TimerAllocError+0x34>
    3a9a:	91 e0       	ldi	r25, 0x01	; 1
		 Timer8AllocErr() || Timer16AllocErr() || Timer32AllocErr() );
}
    3a9c:	89 2f       	mov	r24, r25
    3a9e:	08 95       	ret

00003aa0 <ScanCycleInit>:
}

uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    3aa0:	80 91 cf 02 	lds	r24, 0x02CF
	VacantTimer8Sys += n;
    3aa4:	8f 5f       	subi	r24, 0xFF	; 255
    3aa6:	80 93 cf 02 	sts	0x02CF, r24
    3aaa:	81 50       	subi	r24, 0x01	; 1

// ~~~~~~~~~~~~~~~~
void
ScanCycleInit(void)
{
	TD_Scan = Timer8SysAlloc(1);
    3aac:	80 93 ce 04 	sts	0x04CE, r24
	StartTimer8(TD_Scan, 0xFF);
    3ab0:	6f ef       	ldi	r22, 0xFF	; 255
    3ab2:	0e 94 8f 1a 	call	0x351e	; 0x351e <StartTimer8>
}
    3ab6:	08 95       	ret

00003ab8 <__vector_17>:
#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
	ISR(TIMER1_COMPA_vect)
#elif defined (__AVR_ATxmega128A1__)
	ISR(TCC0_OVF_vect)
#endif
{
    3ab8:	1f 92       	push	r1
    3aba:	0f 92       	push	r0
    3abc:	0f b6       	in	r0, 0x3f	; 63
    3abe:	0f 92       	push	r0
    3ac0:	0b b6       	in	r0, 0x3b	; 59
    3ac2:	0f 92       	push	r0
    3ac4:	11 24       	eor	r1, r1
    3ac6:	2f 93       	push	r18
    3ac8:	4f 93       	push	r20
    3aca:	5f 93       	push	r21
    3acc:	6f 93       	push	r22
    3ace:	7f 93       	push	r23
    3ad0:	8f 93       	push	r24
    3ad2:	9f 93       	push	r25
    3ad4:	af 93       	push	r26
    3ad6:	bf 93       	push	r27
    3ad8:	ef 93       	push	r30
    3ada:	ff 93       	push	r31
	TickCounter++;
    3adc:	80 91 cf 04 	lds	r24, 0x04CF
    3ae0:	8f 5f       	subi	r24, 0xFF	; 255
    3ae2:	80 93 cf 04 	sts	0x04CF, r24
    3ae6:	40 e0       	ldi	r20, 0x00	; 0
    3ae8:	50 e0       	ldi	r21, 0x00	; 0
	uint8_t i;
	for (i=0; i<Timer8_ISR_TotNumber; i++)
			if (!(Timer8_ISR_Flg[i/8] &(1<<i%8)) && --Timer8_ISR[i]==0)
				Timer8_ISR_Flg[i/8] |=(1<<i%8);
    3aea:	a1 e0       	ldi	r26, 0x01	; 1
    3aec:	b0 e0       	ldi	r27, 0x00	; 0
#endif
{
	TickCounter++;
	uint8_t i;
	for (i=0; i<Timer8_ISR_TotNumber; i++)
			if (!(Timer8_ISR_Flg[i/8] &(1<<i%8)) && --Timer8_ISR[i]==0)
    3aee:	80 91 ad 04 	lds	r24, 0x04AD
    3af2:	ba 01       	movw	r22, r20
    3af4:	67 70       	andi	r22, 0x07	; 7
    3af6:	70 70       	andi	r23, 0x00	; 0
    3af8:	90 e0       	ldi	r25, 0x00	; 0
    3afa:	06 2e       	mov	r0, r22
    3afc:	02 c0       	rjmp	.+4      	; 0x3b02 <__vector_17+0x4a>
    3afe:	95 95       	asr	r25
    3b00:	87 95       	ror	r24
    3b02:	0a 94       	dec	r0
    3b04:	e2 f7       	brpl	.-8      	; 0x3afe <__vector_17+0x46>
    3b06:	80 fd       	sbrc	r24, 0
    3b08:	14 c0       	rjmp	.+40     	; 0x3b32 <__vector_17+0x7a>
    3b0a:	fa 01       	movw	r30, r20
    3b0c:	e3 51       	subi	r30, 0x13	; 19
    3b0e:	fd 4f       	sbci	r31, 0xFD	; 253
    3b10:	80 81       	ld	r24, Z
    3b12:	81 50       	subi	r24, 0x01	; 1
    3b14:	80 83       	st	Z, r24
    3b16:	80 81       	ld	r24, Z
    3b18:	88 23       	and	r24, r24
    3b1a:	59 f4       	brne	.+22     	; 0x3b32 <__vector_17+0x7a>
				Timer8_ISR_Flg[i/8] |=(1<<i%8);
    3b1c:	20 91 ad 04 	lds	r18, 0x04AD
    3b20:	cd 01       	movw	r24, r26
    3b22:	02 c0       	rjmp	.+4      	; 0x3b28 <__vector_17+0x70>
    3b24:	88 0f       	add	r24, r24
    3b26:	99 1f       	adc	r25, r25
    3b28:	6a 95       	dec	r22
    3b2a:	e2 f7       	brpl	.-8      	; 0x3b24 <__vector_17+0x6c>
    3b2c:	28 2b       	or	r18, r24
    3b2e:	20 93 ad 04 	sts	0x04AD, r18
    3b32:	4f 5f       	subi	r20, 0xFF	; 255
    3b34:	5f 4f       	sbci	r21, 0xFF	; 255
	ISR(TCC0_OVF_vect)
#endif
{
	TickCounter++;
	uint8_t i;
	for (i=0; i<Timer8_ISR_TotNumber; i++)
    3b36:	48 30       	cpi	r20, 0x08	; 8
    3b38:	51 05       	cpc	r21, r1
    3b3a:	c9 f6       	brne	.-78     	; 0x3aee <__vector_17+0x36>
				Timer8_ISR_Flg[i/8] |=(1<<i%8);

	#ifdef HIGH_SPEED_COUNTER
		HSC_Process();
	#endif
}
    3b3c:	ff 91       	pop	r31
    3b3e:	ef 91       	pop	r30
    3b40:	bf 91       	pop	r27
    3b42:	af 91       	pop	r26
    3b44:	9f 91       	pop	r25
    3b46:	8f 91       	pop	r24
    3b48:	7f 91       	pop	r23
    3b4a:	6f 91       	pop	r22
    3b4c:	5f 91       	pop	r21
    3b4e:	4f 91       	pop	r20
    3b50:	2f 91       	pop	r18
    3b52:	0f 90       	pop	r0
    3b54:	0b be       	out	0x3b, r0	; 59
    3b56:	0f 90       	pop	r0
    3b58:	0f be       	out	0x3f, r0	; 63
    3b5a:	0f 90       	pop	r0
    3b5c:	1f 90       	pop	r1
    3b5e:	18 95       	reti

00003b60 <TimeCycle>:
// ~~~~~~~~~~~~
void
TimeCycle(void)
{
	// WDT
	wdt_reset();
    3b60:	a8 95       	wdr

	// Scan cycle
	ScanCount++;
    3b62:	80 91 6e 07 	lds	r24, 0x076E
    3b66:	90 91 6f 07 	lds	r25, 0x076F
    3b6a:	01 96       	adiw	r24, 0x01	; 1
    3b6c:	90 93 6f 07 	sts	0x076F, r25
    3b70:	80 93 6e 07 	sts	0x076E, r24
	if ((ScanCycle=0xFF-Timer8[TD_Scan])>MaxScanCycle)
    3b74:	90 91 ce 04 	lds	r25, 0x04CE
    3b78:	e9 2f       	mov	r30, r25
    3b7a:	f0 e0       	ldi	r31, 0x00	; 0
    3b7c:	eb 50       	subi	r30, 0x0B	; 11
    3b7e:	fd 4f       	sbci	r31, 0xFD	; 253
    3b80:	e0 81       	ld	r30, Z
    3b82:	e0 95       	com	r30
    3b84:	e0 93 6a 07 	sts	0x076A, r30
    3b88:	80 91 af 06 	lds	r24, 0x06AF
    3b8c:	8e 17       	cp	r24, r30
    3b8e:	10 f4       	brcc	.+4      	; 0x3b94 <TimeCycle+0x34>
		MaxScanCycle = ScanCycle;
    3b90:	e0 93 af 06 	sts	0x06AF, r30
	StartTimer8(TD_Scan, 0xFF);
    3b94:	89 2f       	mov	r24, r25
    3b96:	6f ef       	ldi	r22, 0xFF	; 255
    3b98:	0e 94 8f 1a 	call	0x351e	; 0x351e <StartTimer8>
}
    3b9c:	08 95       	ret

00003b9e <MaxScanCycle_Clear>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
void
MaxScanCycle_Clear(void)
{
	MaxScanCycle = 0;
    3b9e:	10 92 af 06 	sts	0x06AF, r1
}
    3ba2:	08 95       	ret

00003ba4 <Delay_ms>:

// ~~~~~~~~~~~~~~~~~~~~
void
Delay_ms(uint8_t Delay)
{
	while (Delay--)
    3ba4:	88 23       	and	r24, r24
    3ba6:	39 f0       	breq	.+14     	; 0x3bb6 <Delay_ms+0x12>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3ba8:	20 ea       	ldi	r18, 0xA0	; 160
    3baa:	3f e0       	ldi	r19, 0x0F	; 15
    3bac:	f9 01       	movw	r30, r18
    3bae:	31 97       	sbiw	r30, 0x01	; 1
    3bb0:	f1 f7       	brne	.-4      	; 0x3bae <Delay_ms+0xa>
    3bb2:	81 50       	subi	r24, 0x01	; 1
    3bb4:	d9 f7       	brne	.-10     	; 0x3bac <Delay_ms+0x8>
    3bb6:	08 95       	ret

00003bb8 <Delay_us>:
{
	/*uint8_t i;
	for(i=Delay/Delay_us_Max; i; i--)
		_delay_us(Delay_us_Max);*/
	//_delay_us(Delay%Delay_us_Max);
	Delay *= .8;	// By trial
    3bb8:	a0 e0       	ldi	r26, 0x00	; 0
    3bba:	b0 e0       	ldi	r27, 0x00	; 0
    3bbc:	bc 01       	movw	r22, r24
    3bbe:	cd 01       	movw	r24, r26
    3bc0:	0e 94 ca 7c 	call	0xf994	; 0xf994 <__floatunsisf>
    3bc4:	2d ec       	ldi	r18, 0xCD	; 205
    3bc6:	3c ec       	ldi	r19, 0xCC	; 204
    3bc8:	4c e4       	ldi	r20, 0x4C	; 76
    3bca:	5f e3       	ldi	r21, 0x3F	; 63
    3bcc:	0e 94 07 7d 	call	0xfa0e	; 0xfa0e <__mulsf3>
    3bd0:	0e 94 9f 81 	call	0x1033e	; 0x1033e <__fixunssfsi>
    3bd4:	cb 01       	movw	r24, r22
	while (Delay--)
    3bd6:	67 2b       	or	r22, r23
    3bd8:	31 f0       	breq	.+12     	; 0x3be6 <Delay_us+0x2e>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3bda:	35 e0       	ldi	r19, 0x05	; 5
    3bdc:	23 2f       	mov	r18, r19
    3bde:	2a 95       	dec	r18
    3be0:	f1 f7       	brne	.-4      	; 0x3bde <Delay_us+0x26>
    3be2:	01 97       	sbiw	r24, 0x01	; 1
    3be4:	d9 f7       	brne	.-10     	; 0x3bdc <Delay_us+0x24>
    3be6:	08 95       	ret

00003be8 <MB_PLC_Init>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#if defined vmd2_3
	void MB_PLC_Init(void)
	{
		// RS485
		DDRE |=(1<<PE2); PORTE &=~(1<<PE2);
    3be8:	6a 9a       	sbi	0x0d, 2	; 13
    3bea:	72 98       	cbi	0x0e, 2	; 14
		DDRD |=(1<<PD4); PORTD &=~(1<<PD4);
    3bec:	54 9a       	sbi	0x0a, 4	; 10
    3bee:	5c 98       	cbi	0x0b, 4	; 11
	#ifndef GSM
		DDRL |=(1<<PL5); PORTL &=~(1<<PL5);
	#endif
	}
    3bf0:	08 95       	ret

00003bf2 <RS485_0>:
	void RS485_0(void) {PORTE ^=(1<<PE2);}
    3bf2:	8e b1       	in	r24, 0x0e	; 14
    3bf4:	94 e0       	ldi	r25, 0x04	; 4
    3bf6:	89 27       	eor	r24, r25
    3bf8:	8e b9       	out	0x0e, r24	; 14
    3bfa:	08 95       	ret

00003bfc <RS485_1>:
	void RS485_1(void) {PORTD ^=(1<<PD4);}
    3bfc:	8b b1       	in	r24, 0x0b	; 11
    3bfe:	90 e1       	ldi	r25, 0x10	; 16
    3c00:	89 27       	eor	r24, r25
    3c02:	8b b9       	out	0x0b, r24	; 11
    3c04:	08 95       	ret

00003c06 <MB_LED0>:
	}
	void RS485_0(void) {PORTE ^=(1<<PE2);}
	void RS485_1(void) {PORTC ^=(1<<PC0);}
#endif

void MB_LED0(void) {}
    3c06:	08 95       	ret

00003c08 <MB_LED1>:
void MB_LED1(void) {}
    3c08:	08 95       	ret

00003c0a <MB_LED2>:
void MB_LED2(void) {}
    3c0a:	08 95       	ret

00003c0c <MB_LED_Err_On_0>:

void MB_LED_Err_On_0(void)	{}
    3c0c:	08 95       	ret

00003c0e <MB_LED_Err_Off_0>:
void MB_LED_Err_Off_0(void)	{}
    3c0e:	08 95       	ret

00003c10 <MB_LED_Err_On_1>:
void MB_LED_Err_On_1(void)	{}
    3c10:	08 95       	ret

00003c12 <MB_LED_Err_Off_1>:
void MB_LED_Err_Off_1(void)	{}	
    3c12:	08 95       	ret

00003c14 <MB_LED_Err_On_2>:
void MB_LED_Err_On_2(void)	{}
    3c14:	08 95       	ret

00003c16 <MB_LED_Err_Off_2>:
void MB_LED_Err_Off_2(void)	{}
    3c16:	08 95       	ret

00003c18 <PWM_Init>:

// ~~~~~~~~~~~
void
PWM_Init(void)
{
	TCCR3A = (1<<COM3A1) | (0<<COM3A0) | (1<<COM3B1) | (0<<COM3B0) | (0<<COM3C1) | (0<<COM3C0) | (1<<WGM31) | (0<<WGM30);
    3c18:	32 ea       	ldi	r19, 0xA2	; 162
    3c1a:	30 93 90 00 	sts	0x0090, r19
	TCCR3B = (0<<CS32) | (0<<CS31) | (1<<CS30) | (1<<WGM33) | (1<<WGM32);	// Fpwm = 244Hz
    3c1e:	29 e1       	ldi	r18, 0x19	; 25
    3c20:	20 93 91 00 	sts	0x0091, r18
	ICR3 = PWM_PERIOD_TC3;
    3c24:	8f ef       	ldi	r24, 0xFF	; 255
    3c26:	9f ef       	ldi	r25, 0xFF	; 255
    3c28:	90 93 97 00 	sts	0x0097, r25
    3c2c:	80 93 96 00 	sts	0x0096, r24
	DDRE |= (1<<PE3) | (1<<PE4);
    3c30:	8d b1       	in	r24, 0x0d	; 13
    3c32:	88 61       	ori	r24, 0x18	; 24
    3c34:	8d b9       	out	0x0d, r24	; 13

	TCCR5A = (1<<COM5A1) | (0<<COM5A0) | (1<<COM5B1) | (0<<COM5B0) | (0<<COM5C1) | (0<<COM5C0) | (1<<WGM51) | (0<<WGM50);
    3c36:	30 93 20 01 	sts	0x0120, r19
	TCCR5B = (0<<CS52) | (0<<CS51) | (1<<CS50) | (1<<WGM53) | (1<<WGM52);	// Fpwm = 244Hz
    3c3a:	20 93 21 01 	sts	0x0121, r18
	ICR5 = PWM_PERIOD_TC5;
    3c3e:	8e e7       	ldi	r24, 0x7E	; 126
    3c40:	9c e0       	ldi	r25, 0x0C	; 12
    3c42:	90 93 27 01 	sts	0x0127, r25
    3c46:	80 93 26 01 	sts	0x0126, r24
	DDRL |= (1<<PL3) | (1<<PL4);
    3c4a:	ea e0       	ldi	r30, 0x0A	; 10
    3c4c:	f1 e0       	ldi	r31, 0x01	; 1
    3c4e:	80 81       	ld	r24, Z
    3c50:	88 61       	ori	r24, 0x18	; 24
    3c52:	80 83       	st	Z, r24
}
    3c54:	08 95       	ret

00003c56 <PWM_Out>:
void
PWM_Out(void)
{
	uint16_t Buf;

	Buf = Coef_AO_PWM_TC3*DAC_Output[0];
    3c56:	60 91 8b 07 	lds	r22, 0x078B
    3c5a:	70 91 8c 07 	lds	r23, 0x078C
    3c5e:	80 e0       	ldi	r24, 0x00	; 0
    3c60:	90 e0       	ldi	r25, 0x00	; 0
    3c62:	0e 94 ca 7c 	call	0xf994	; 0xf994 <__floatunsisf>
    3c66:	28 e8       	ldi	r18, 0x88	; 136
    3c68:	3f e1       	ldi	r19, 0x1F	; 31
    3c6a:	40 e8       	ldi	r20, 0x80	; 128
    3c6c:	52 e4       	ldi	r21, 0x42	; 66
    3c6e:	0e 94 07 7d 	call	0xfa0e	; 0xfa0e <__mulsf3>
    3c72:	0e 94 9f 81 	call	0x1033e	; 0x1033e <__fixunssfsi>
    3c76:	26 2f       	mov	r18, r22

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3c78:	9f b7       	in	r25, 0x3f	; 63
	cli();
    3c7a:	f8 94       	cli
	IntOff();
	OCR3AH = Buf>>8;
    3c7c:	70 93 99 00 	sts	0x0099, r23
	OCR3AL = Buf;
    3c80:	20 93 98 00 	sts	0x0098, r18

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3c84:	97 ff       	sbrs	r25, 7
    3c86:	01 c0       	rjmp	.+2      	; 0x3c8a <PWM_Out+0x34>
		sei();
    3c88:	78 94       	sei
	IntOn();

	Buf = Coef_AO_PWM_TC3*DAC_Output[1];
    3c8a:	60 91 8d 07 	lds	r22, 0x078D
    3c8e:	70 91 8e 07 	lds	r23, 0x078E
    3c92:	80 e0       	ldi	r24, 0x00	; 0
    3c94:	90 e0       	ldi	r25, 0x00	; 0
    3c96:	0e 94 ca 7c 	call	0xf994	; 0xf994 <__floatunsisf>
    3c9a:	28 e8       	ldi	r18, 0x88	; 136
    3c9c:	3f e1       	ldi	r19, 0x1F	; 31
    3c9e:	40 e8       	ldi	r20, 0x80	; 128
    3ca0:	52 e4       	ldi	r21, 0x42	; 66
    3ca2:	0e 94 07 7d 	call	0xfa0e	; 0xfa0e <__mulsf3>
    3ca6:	0e 94 9f 81 	call	0x1033e	; 0x1033e <__fixunssfsi>
    3caa:	26 2f       	mov	r18, r22

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3cac:	9f b7       	in	r25, 0x3f	; 63
	cli();
    3cae:	f8 94       	cli
	IntOff();
	OCR3BH = Buf>>8;
    3cb0:	70 93 9b 00 	sts	0x009B, r23
	OCR3BL = Buf;
    3cb4:	20 93 9a 00 	sts	0x009A, r18

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3cb8:	97 ff       	sbrs	r25, 7
    3cba:	01 c0       	rjmp	.+2      	; 0x3cbe <PWM_Out+0x68>
		sei();
    3cbc:	78 94       	sei
	IntOn();


	Buf = Coef_AO_PWM_TC5*DAC_Output[2];
    3cbe:	60 91 8f 07 	lds	r22, 0x078F
    3cc2:	70 91 90 07 	lds	r23, 0x0790
    3cc6:	80 e0       	ldi	r24, 0x00	; 0
    3cc8:	90 e0       	ldi	r25, 0x00	; 0
    3cca:	0e 94 ca 7c 	call	0xf994	; 0xf994 <__floatunsisf>
    3cce:	25 e0       	ldi	r18, 0x05	; 5
    3cd0:	32 e1       	ldi	r19, 0x12	; 18
    3cd2:	48 e4       	ldi	r20, 0x48	; 72
    3cd4:	50 e4       	ldi	r21, 0x40	; 64
    3cd6:	0e 94 07 7d 	call	0xfa0e	; 0xfa0e <__mulsf3>
    3cda:	0e 94 9f 81 	call	0x1033e	; 0x1033e <__fixunssfsi>
    3cde:	26 2f       	mov	r18, r22

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3ce0:	9f b7       	in	r25, 0x3f	; 63
	cli();
    3ce2:	f8 94       	cli
	IntOff();
	OCR5AH = Buf>>8;
    3ce4:	70 93 29 01 	sts	0x0129, r23
	OCR5AL = Buf;
    3ce8:	20 93 28 01 	sts	0x0128, r18

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3cec:	97 ff       	sbrs	r25, 7
    3cee:	01 c0       	rjmp	.+2      	; 0x3cf2 <PWM_Out+0x9c>
		sei();
    3cf0:	78 94       	sei
	IntOn();

	Buf = Coef_AO_PWM_TC5*DAC_Output[3];
    3cf2:	60 91 91 07 	lds	r22, 0x0791
    3cf6:	70 91 92 07 	lds	r23, 0x0792
    3cfa:	80 e0       	ldi	r24, 0x00	; 0
    3cfc:	90 e0       	ldi	r25, 0x00	; 0
    3cfe:	0e 94 ca 7c 	call	0xf994	; 0xf994 <__floatunsisf>
    3d02:	25 e0       	ldi	r18, 0x05	; 5
    3d04:	32 e1       	ldi	r19, 0x12	; 18
    3d06:	48 e4       	ldi	r20, 0x48	; 72
    3d08:	50 e4       	ldi	r21, 0x40	; 64
    3d0a:	0e 94 07 7d 	call	0xfa0e	; 0xfa0e <__mulsf3>
    3d0e:	0e 94 9f 81 	call	0x1033e	; 0x1033e <__fixunssfsi>
    3d12:	26 2f       	mov	r18, r22

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    3d14:	8f b7       	in	r24, 0x3f	; 63
    3d16:	80 78       	andi	r24, 0x80	; 128
    3d18:	80 93 ec 02 	sts	0x02EC, r24
	cli();
    3d1c:	f8 94       	cli
	IntOff();
	OCR5BH = Buf>>8;
    3d1e:	70 93 2b 01 	sts	0x012B, r23
	OCR5BL = Buf;
    3d22:	20 93 2a 01 	sts	0x012A, r18

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    3d26:	88 23       	and	r24, r24
    3d28:	09 f0       	breq	.+2      	; 0x3d2c <PWM_Out+0xd6>
		sei();
    3d2a:	78 94       	sei
    3d2c:	08 95       	ret

00003d2e <ADC_In>:
}

// ~~~~~~~~~
uint8_t
ADC_In(void)
{
    3d2e:	1f 93       	push	r17

// ~~~~~~~~~~~~~~~
inline static void
ADC_Select(void)
{
	SPCR |=(1<<CPOL);
    3d30:	8c b5       	in	r24, 0x2c	; 44
    3d32:	88 60       	ori	r24, 0x08	; 8
    3d34:	8c bd       	out	0x2c, r24	; 44
	#ifdef CS_ADC
		cli();
    3d36:	f8 94       	cli
		PortCS_ADC &=~CS_ADC;
    3d38:	80 91 02 01 	lds	r24, 0x0102
    3d3c:	87 7f       	andi	r24, 0xF7	; 247
    3d3e:	80 93 02 01 	sts	0x0102, r24
		sei();
    3d42:	78 94       	sei
ADC_In(void)
{
	uint8_t Chan = ADC_Reg;
	ADC_Select();

	switch(ADC_Phase) {
    3d44:	80 91 22 0b 	lds	r24, 0x0B22
    3d48:	81 30       	cpi	r24, 0x01	; 1
    3d4a:	09 f4       	brne	.+2      	; 0x3d4e <ADC_In+0x20>
    3d4c:	ec c0       	rjmp	.+472    	; 0x3f26 <ADC_In+0x1f8>
    3d4e:	81 30       	cpi	r24, 0x01	; 1
    3d50:	30 f5       	brcc	.+76     	; 0x3d9e <ADC_In+0x70>

// ~~~~~~~~~~~~~~~
inline static void
ADC_Rst(void)
{
	cli();
    3d52:	f8 94       	cli
	PortRESET_PER &=~RESET_PER;
    3d54:	80 91 02 01 	lds	r24, 0x0102
    3d58:	8f 7e       	andi	r24, 0xEF	; 239
    3d5a:	80 93 02 01 	sts	0x0102, r24
	sei();
    3d5e:	78 94       	sei
    3d60:	85 e0       	ldi	r24, 0x05	; 5
    3d62:	8a 95       	dec	r24
    3d64:	f1 f7       	brne	.-4      	; 0x3d62 <ADC_In+0x34>
	_delay_us(1);							// 100 ns needs
	cli();
    3d66:	f8 94       	cli
	PortRESET_PER |=RESET_PER;
    3d68:	80 91 02 01 	lds	r24, 0x0102
    3d6c:	80 61       	ori	r24, 0x10	; 16
    3d6e:	80 93 02 01 	sts	0x0102, r24
	sei();
    3d72:	78 94       	sei
	StartTimer8_ISR(TD_ADC, 4);		// 16 ms needs
    3d74:	80 91 f5 06 	lds	r24, 0x06F5
    3d78:	64 e0       	ldi	r22, 0x04	; 4
	WaitSPI();
	SPDR = SR;
	WaitSPI();
	SPDR = SetpVal(CaliMode) &~ADC_FSYNC;
	WaitSPI();
	StartTimer8_ISR(TD_ADC, 36);
    3d7a:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <StartTimer8_ISR>
	ADC_Phase++;
    3d7e:	80 91 22 0b 	lds	r24, 0x0B22
    3d82:	8f 5f       	subi	r24, 0xFF	; 255
    3d84:	80 93 22 0b 	sts	0x0B22, r24
    3d88:	17 e0       	ldi	r17, 0x07	; 7
// ~~~~~~~~~~~~~~~
inline static void
ADC_Desel(void)
{
	#ifdef CS_ADC
		cli();
    3d8a:	f8 94       	cli
		PortCS_ADC |=CS_ADC;
    3d8c:	80 91 02 01 	lds	r24, 0x0102
    3d90:	88 60       	ori	r24, 0x08	; 8
    3d92:	80 93 02 01 	sts	0x0102, r24
		sei();
    3d96:	78 94       	sei
			IntOn();
		}
	#endif

	return Chan;
}
    3d98:	81 2f       	mov	r24, r17
    3d9a:	1f 91       	pop	r17
    3d9c:	08 95       	ret
ADC_In(void)
{
	uint8_t Chan = ADC_Reg;
	ADC_Select();

	switch(ADC_Phase) {
    3d9e:	82 30       	cpi	r24, 0x02	; 2
    3da0:	09 f4       	brne	.+2      	; 0x3da4 <ADC_In+0x76>
    3da2:	d2 c0       	rjmp	.+420    	; 0x3f48 <ADC_In+0x21a>
    3da4:	83 30       	cpi	r24, 0x03	; 3
    3da6:	11 f0       	breq	.+4      	; 0x3dac <ADC_In+0x7e>
				StartTimer8_ISR(TD_ADC, ADC10ms);
			}
		}
		else if(Timer8Stopp_ISR(TD_ADC)) {
			ADC_ReadFail++;
			ADC_Phase = RST;
    3da8:	17 e0       	ldi	r17, 0x07	; 7
    3daa:	ef cf       	rjmp	.-34     	; 0x3d8a <ADC_In+0x5c>
		default:
			SPDR = ADC_IN1(Reg);
			break;
		}
	#else
		SPDR = ADC_IN1(Reg);
    3dac:	88 e0       	ldi	r24, 0x08	; 8
    3dae:	8e bd       	out	0x2e, r24	; 46

// ~~~~~~~~~~~
static void
WaitADC2(void)
{
	WaitSPI();
    3db0:	0d b4       	in	r0, 0x2d	; 45
    3db2:	07 fe       	sbrs	r0, 7
    3db4:	fd cf       	rjmp	.-6      	; 0x3db0 <ADC_In+0x82>
	SPDR = 0;
    3db6:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    3db8:	0d b4       	in	r0, 0x2d	; 45
    3dba:	07 fe       	sbrs	r0, 7
    3dbc:	fd cf       	rjmp	.-6      	; 0x3db8 <ADC_In+0x8a>
			StartTimer8_ISR(TD_ADC, ADC10ms);
		break;
	case READ:
		ADC_IN(CommReg);
		WaitADC2();
		if(!(SPDR &ADC_DRDY)) {
    3dbe:	0e b4       	in	r0, 0x2e	; 46
    3dc0:	07 fc       	sbrc	r0, 7
    3dc2:	da c0       	rjmp	.+436    	; 0x3f78 <ADC_In+0x24a>
		default:
			SPDR = ADC_IN1(Reg);
			break;
		}
	#else
		SPDR = ADC_IN1(Reg);
    3dc4:	88 e3       	ldi	r24, 0x38	; 56
    3dc6:	8e bd       	out	0x2e, r24	; 46

// ~~~~~~~~~~~
static void
WaitADC2(void)
{
	WaitSPI();
    3dc8:	0d b4       	in	r0, 0x2d	; 45
    3dca:	07 fe       	sbrs	r0, 7
    3dcc:	fd cf       	rjmp	.-6      	; 0x3dc8 <ADC_In+0x9a>
	SPDR = 0;
    3dce:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    3dd0:	0d b4       	in	r0, 0x2d	; 45
    3dd2:	07 fe       	sbrs	r0, 7
    3dd4:	fd cf       	rjmp	.-6      	; 0x3dd0 <ADC_In+0xa2>
		WaitADC2();
		if(!(SPDR &ADC_DRDY)) {
			uint16_t Buf;
			ADC_IN(DataReg);
			WaitADC2();
			Buf = SPDR<<8;
    3dd6:	3e b5       	in	r19, 0x2e	; 46

// ~~~~~~~~~~~
static void
WaitADC1(void)
{
	SPDR = 0;
    3dd8:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    3dda:	0d b4       	in	r0, 0x2d	; 45
    3ddc:	07 fe       	sbrs	r0, 7
    3dde:	fd cf       	rjmp	.-6      	; 0x3dda <ADC_In+0xac>
			uint16_t Buf;
			ADC_IN(DataReg);
			WaitADC2();
			Buf = SPDR<<8;
			WaitADC1();
			Buf += SPDR;
    3de0:	2e b5       	in	r18, 0x2e	; 46
		WaitADC2();
		if(!(SPDR &ADC_DRDY)) {
			uint16_t Buf;
			ADC_IN(DataReg);
			WaitADC2();
			Buf = SPDR<<8;
    3de2:	93 2f       	mov	r25, r19
    3de4:	80 e0       	ldi	r24, 0x00	; 0
			WaitADC1();
			Buf += SPDR;
    3de6:	ac 01       	movw	r20, r24
    3de8:	42 0f       	add	r20, r18
    3dea:	51 1d       	adc	r21, r1
    3dec:	9a 01       	movw	r18, r20
			#ifdef ADC_Ref_Chan
				if (ADC_Chan==sizeof(Mux)-1 && ADC_Input[sizeof(Mux)-1]!=0 && (Buf<ADC_Ref-ADC_Ref_d || Buf>ADC_Ref+ADC_Ref_d)) {
    3dee:	10 91 ca 08 	lds	r17, 0x08CA
    3df2:	16 30       	cpi	r17, 0x06	; 6
    3df4:	09 f4       	brne	.+2      	; 0x3df8 <ADC_In+0xca>
    3df6:	19 c1       	rjmp	.+562    	; 0x402a <ADC_In+0x2fc>
		default:
			SPDR = ADC_IN1(Reg);
			break;
		}
	#else
		SPDR = ADC_IN1(Reg);
    3df8:	80 e1       	ldi	r24, 0x10	; 16
    3dfa:	8e bd       	out	0x2e, r24	; 46
{
	Scale *Scl;
	int8_t i;

	ADC_IN(SetpReg);
	WaitSPI();
    3dfc:	0d b4       	in	r0, 0x2d	; 45
    3dfe:	07 fe       	sbrs	r0, 7
    3e00:	fd cf       	rjmp	.-6      	; 0x3dfc <ADC_In+0xce>
	SPDR = SetpVal(NormMode) |ADC_FSYNC;
    3e02:	87 e0       	ldi	r24, 0x07	; 7
    3e04:	8e bd       	out	0x2e, r24	; 46
	WaitSPI();
    3e06:	0d b4       	in	r0, 0x2d	; 45
    3e08:	07 fe       	sbrs	r0, 7
    3e0a:	fd cf       	rjmp	.-6      	; 0x3e06 <ADC_In+0xd8>
	ADC_Time = ADC10ms-Timer8_ISR[TD_ADC];
    3e0c:	40 91 f5 06 	lds	r20, 0x06F5
    3e10:	e4 2f       	mov	r30, r20
    3e12:	f0 e0       	ldi	r31, 0x00	; 0
    3e14:	e3 51       	subi	r30, 0x13	; 19
    3e16:	fd 4f       	sbci	r31, 0xFD	; 253
    3e18:	90 81       	ld	r25, Z
    3e1a:	84 e1       	ldi	r24, 0x14	; 20
    3e1c:	89 1b       	sub	r24, r25
    3e1e:	80 93 b1 06 	sts	0x06B1, r24
		default:
			SPDR = ADC_IN1(Reg);
			break;
		}
	#else
		SPDR = ADC_IN1(Reg);
    3e22:	88 e6       	ldi	r24, 0x68	; 104
    3e24:	8e bd       	out	0x2e, r24	; 46

// ~~~~~~~~~~~
static void
WaitADC2(void)
{
	WaitSPI();
    3e26:	0d b4       	in	r0, 0x2d	; 45
    3e28:	07 fe       	sbrs	r0, 7
    3e2a:	fd cf       	rjmp	.-6      	; 0x3e26 <ADC_In+0xf8>
	SPDR = 0;
    3e2c:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    3e2e:	0d b4       	in	r0, 0x2d	; 45
    3e30:	07 fe       	sbrs	r0, 7
    3e32:	fd cf       	rjmp	.-6      	; 0x3e2e <ADC_In+0x100>
    3e34:	e7 e2       	ldi	r30, 0x27	; 39
    3e36:	fc e0       	ldi	r31, 0x0C	; 12
		Scl=&ADC_Scale1;
	#endif
	ADC_IN(ZeroReg);
	WaitADC2();
	for(i=2; i>=0; i--) {
		Scl->Zero[i] = SPDR;
    3e38:	8e b5       	in	r24, 0x2e	; 46
    3e3a:	80 83       	st	Z, r24

// ~~~~~~~~~~~
static void
WaitADC1(void)
{
	SPDR = 0;
    3e3c:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    3e3e:	0d b4       	in	r0, 0x2d	; 45
    3e40:	07 fe       	sbrs	r0, 7
    3e42:	fd cf       	rjmp	.-6      	; 0x3e3e <ADC_In+0x110>
    3e44:	31 97       	sbiw	r30, 0x01	; 1
	#else
		Scl=&ADC_Scale1;
	#endif
	ADC_IN(ZeroReg);
	WaitADC2();
	for(i=2; i>=0; i--) {
    3e46:	8c e0       	ldi	r24, 0x0C	; 12
    3e48:	e4 32       	cpi	r30, 0x24	; 36
    3e4a:	f8 07       	cpc	r31, r24
    3e4c:	a9 f7       	brne	.-22     	; 0x3e38 <ADC_In+0x10a>

// ~~~~~~~~~~~
static void
WaitADC1(void)
{
	SPDR = 0;
    3e4e:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    3e50:	0d b4       	in	r0, 0x2d	; 45
    3e52:	07 fe       	sbrs	r0, 7
    3e54:	fd cf       	rjmp	.-6      	; 0x3e50 <ADC_In+0x122>
		default:
			SPDR = ADC_IN1(Reg);
			break;
		}
	#else
		SPDR = ADC_IN1(Reg);
    3e56:	88 e7       	ldi	r24, 0x78	; 120
    3e58:	8e bd       	out	0x2e, r24	; 46

// ~~~~~~~~~~~
static void
WaitADC2(void)
{
	WaitSPI();
    3e5a:	0d b4       	in	r0, 0x2d	; 45
    3e5c:	07 fe       	sbrs	r0, 7
    3e5e:	fd cf       	rjmp	.-6      	; 0x3e5a <ADC_In+0x12c>
	SPDR = 0;
    3e60:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    3e62:	0d b4       	in	r0, 0x2d	; 45
    3e64:	07 fe       	sbrs	r0, 7
    3e66:	fd cf       	rjmp	.-6      	; 0x3e62 <ADC_In+0x134>
    3e68:	ea e2       	ldi	r30, 0x2A	; 42
    3e6a:	fc e0       	ldi	r31, 0x0C	; 12
	}
	WaitADC1();
	ADC_IN(FullReg);
	WaitADC2();
	for(i=2; i>=0; i--) {
		Scl->Full[i] = SPDR;
    3e6c:	8e b5       	in	r24, 0x2e	; 46
    3e6e:	80 83       	st	Z, r24

// ~~~~~~~~~~~
static void
WaitADC1(void)
{
	SPDR = 0;
    3e70:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    3e72:	0d b4       	in	r0, 0x2d	; 45
    3e74:	07 fe       	sbrs	r0, 7
    3e76:	fd cf       	rjmp	.-6      	; 0x3e72 <ADC_In+0x144>
    3e78:	31 97       	sbiw	r30, 0x01	; 1
		WaitADC1();
	}
	WaitADC1();
	ADC_IN(FullReg);
	WaitADC2();
	for(i=2; i>=0; i--) {
    3e7a:	5c e0       	ldi	r21, 0x0C	; 12
    3e7c:	e7 32       	cpi	r30, 0x27	; 39
    3e7e:	f5 07       	cpc	r31, r21
    3e80:	a9 f7       	brne	.-22     	; 0x3e6c <ADC_In+0x13e>

// ~~~~~~~~~~~
static void
WaitADC1(void)
{
	SPDR = 0;
    3e82:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    3e84:	0d b4       	in	r0, 0x2d	; 45
    3e86:	07 fe       	sbrs	r0, 7
    3e88:	fd cf       	rjmp	.-6      	; 0x3e84 <ADC_In+0x156>
	for(i=2; i>=0; i--) {
		Scl->Full[i] = SPDR;
		WaitADC1();
	}
	WaitADC1();
	return Scl->Zero[2]<25 || Scl->Zero[2]>27 || Scl->Full[2]<200 || Scl->Full[2]>203;
    3e8a:	80 91 27 0c 	lds	r24, 0x0C27
    3e8e:	89 51       	subi	r24, 0x19	; 25
    3e90:	83 30       	cpi	r24, 0x03	; 3
    3e92:	08 f0       	brcs	.+2      	; 0x3e96 <ADC_In+0x168>
    3e94:	85 c0       	rjmp	.+266    	; 0x3fa0 <ADC_In+0x272>
    3e96:	80 91 2a 0c 	lds	r24, 0x0C2A
    3e9a:	88 3c       	cpi	r24, 0xC8	; 200
    3e9c:	08 f4       	brcc	.+2      	; 0x3ea0 <ADC_In+0x172>
    3e9e:	80 c0       	rjmp	.+256    	; 0x3fa0 <ADC_In+0x272>
    3ea0:	8c 3c       	cpi	r24, 0xCC	; 204
    3ea2:	08 f0       	brcs	.+2      	; 0x3ea6 <ADC_In+0x178>
    3ea4:	7d c0       	rjmp	.+250    	; 0x3fa0 <ADC_In+0x272>
			if(ADC_Check()) {
				ADC_Break++;
				ADC_Phase = RST;
			}
			else {
				ADC_Input[ADC_Chan] = Buf;
    3ea6:	e1 2f       	mov	r30, r17
    3ea8:	f0 e0       	ldi	r31, 0x00	; 0
    3eaa:	ee 0f       	add	r30, r30
    3eac:	ff 1f       	adc	r31, r31
    3eae:	ed 52       	subi	r30, 0x2D	; 45
    3eb0:	f7 4f       	sbci	r31, 0xF7	; 247
    3eb2:	31 83       	std	Z+1, r19	; 0x01
    3eb4:	20 83       	st	Z, r18

// ~~~~~~~~~~~~~~~
inline static void
SetMux(void)
{
	if(++ADC_Chan == ADC_Reg)
    3eb6:	81 2f       	mov	r24, r17
    3eb8:	8f 5f       	subi	r24, 0xFF	; 255
    3eba:	80 93 ca 08 	sts	0x08CA, r24
    3ebe:	87 30       	cpi	r24, 0x07	; 7
    3ec0:	11 f4       	brne	.+4      	; 0x3ec6 <ADC_In+0x198>
		ADC_Chan = 0;
    3ec2:	10 92 ca 08 	sts	0x08CA, r1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    3ec6:	e0 91 ca 08 	lds	r30, 0x08CA
    3eca:	f0 e0       	ldi	r31, 0x00	; 0
    3ecc:	ea 52       	subi	r30, 0x2A	; 42
    3ece:	f1 4d       	sbci	r31, 0xD1	; 209
    3ed0:	94 91       	lpm	r25, Z+
		#if ADC_Reg>8
			if(ADC_Chan>=sizeof(Mux))
				return;
		#endif
		uint8_t Addr = prb(Mux+ADC_Chan);
		cli();
    3ed2:	f8 94       	cli
		if (Addr/4){
    3ed4:	94 30       	cpi	r25, 0x04	; 4
    3ed6:	08 f4       	brcc	.+2      	; 0x3eda <ADC_In+0x1ac>
    3ed8:	ca c0       	rjmp	.+404    	; 0x406e <ADC_In+0x340>
			Port_INH|=INH;
    3eda:	77 9a       	sbi	0x0e, 7	; 14
			#ifdef Port_INH2
				Port_INH2 &=~INH2;
    3edc:	80 91 02 01 	lds	r24, 0x0102
    3ee0:	8b 7f       	andi	r24, 0xFB	; 251
    3ee2:	80 93 02 01 	sts	0x0102, r24
			Port_INH &=~INH;
			#ifdef Port_INH2
				Port_INH2|=INH2;
			#endif
		}
		if (Addr%4/2)	Port_TER_B	|=TER_B;	else Port_TER_B	&=~TER_B;
    3ee6:	29 2f       	mov	r18, r25
    3ee8:	30 e0       	ldi	r19, 0x00	; 0
    3eea:	c9 01       	movw	r24, r18
    3eec:	83 70       	andi	r24, 0x03	; 3
    3eee:	90 70       	andi	r25, 0x00	; 0
    3ef0:	01 96       	adiw	r24, 0x01	; 1
    3ef2:	03 97       	sbiw	r24, 0x03	; 3
    3ef4:	08 f4       	brcc	.+2      	; 0x3ef8 <ADC_In+0x1ca>
    3ef6:	b9 c0       	rjmp	.+370    	; 0x406a <ADC_In+0x33c>
    3ef8:	76 9a       	sbi	0x0e, 6	; 14
		if (Addr%2)		Port_TER_A	|=TER_A;	else Port_TER_A	&=~TER_A;
    3efa:	20 ff       	sbrs	r18, 0
    3efc:	b4 c0       	rjmp	.+360    	; 0x4066 <ADC_In+0x338>
    3efe:	75 9a       	sbi	0x0e, 5	; 14
		sei();
    3f00:	78 94       	sei
    3f02:	85 e5       	ldi	r24, 0x55	; 85
    3f04:	8a 95       	dec	r24
    3f06:	f1 f7       	brne	.-4      	; 0x3f04 <ADC_In+0x1d6>
		default:
			SPDR = ADC_IN1(Reg);
			break;
		}
	#else
		SPDR = ADC_IN1(Reg);
    3f08:	80 e1       	ldi	r24, 0x10	; 16
    3f0a:	8e bd       	out	0x2e, r24	; 46
			else {
				ADC_Input[ADC_Chan] = Buf;
				Chan = ADC_Chan;
				SetMux();
				ADC_IN(SetpReg);
				WaitSPI();
    3f0c:	0d b4       	in	r0, 0x2d	; 45
    3f0e:	07 fe       	sbrs	r0, 7
    3f10:	fd cf       	rjmp	.-6      	; 0x3f0c <ADC_In+0x1de>
				SPDR = SetpVal(NormMode) &~ADC_FSYNC;
    3f12:	86 e0       	ldi	r24, 0x06	; 6
    3f14:	8e bd       	out	0x2e, r24	; 46
				WaitSPI();
    3f16:	0d b4       	in	r0, 0x2d	; 45
    3f18:	07 fe       	sbrs	r0, 7
    3f1a:	fd cf       	rjmp	.-6      	; 0x3f16 <ADC_In+0x1e8>
				StartTimer8_ISR(TD_ADC, ADC10ms);
    3f1c:	84 2f       	mov	r24, r20
    3f1e:	64 e1       	ldi	r22, 0x14	; 20
    3f20:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <StartTimer8_ISR>
    3f24:	32 cf       	rjmp	.-412    	; 0x3d8a <ADC_In+0x5c>

// ~~~~~~~~~~~~~~~
inline static void
ADC_Init1(void)
{
	if(!Timer8Stopp_ISR(TD_ADC))
    3f26:	80 91 f5 06 	lds	r24, 0x06F5
    3f2a:	0e 94 c0 1b 	call	0x3780	; 0x3780 <Timer8Stopp_ISR>
    3f2e:	88 23       	and	r24, r24
    3f30:	09 f4       	brne	.+2      	; 0x3f34 <ADC_In+0x206>
    3f32:	3a cf       	rjmp	.-396    	; 0x3da8 <ADC_In+0x7a>
    3f34:	81 e0       	ldi	r24, 0x01	; 1
		return;
	uint8_t i = 0;
	while(i++<8) {	// 4 x 0xFF needs
		SPDR = 0xFF;
    3f36:	9f ef       	ldi	r25, 0xFF	; 255
    3f38:	9e bd       	out	0x2e, r25	; 46
		WaitSPI();
    3f3a:	0d b4       	in	r0, 0x2d	; 45
    3f3c:	07 fe       	sbrs	r0, 7
    3f3e:	fd cf       	rjmp	.-6      	; 0x3f3a <ADC_In+0x20c>
ADC_Init1(void)
{
	if(!Timer8Stopp_ISR(TD_ADC))
		return;
	uint8_t i = 0;
	while(i++<8) {	// 4 x 0xFF needs
    3f40:	88 30       	cpi	r24, 0x08	; 8
    3f42:	d9 f1       	breq	.+118    	; 0x3fba <ADC_In+0x28c>
    3f44:	8f 5f       	subi	r24, 0xFF	; 255
    3f46:	f8 cf       	rjmp	.-16     	; 0x3f38 <ADC_In+0x20a>
// ~~~~~~~~~~~~~~~
static void
Calibr(uint8_t CR)
{
	static uint8_t Try;
	SPDR = CR;
    3f48:	88 e0       	ldi	r24, 0x08	; 8
    3f4a:	8e bd       	out	0x2e, r24	; 46

// ~~~~~~~~~~~
static void
WaitADC2(void)
{
	WaitSPI();
    3f4c:	0d b4       	in	r0, 0x2d	; 45
    3f4e:	07 fe       	sbrs	r0, 7
    3f50:	fd cf       	rjmp	.-6      	; 0x3f4c <ADC_In+0x21e>
	SPDR = 0;
    3f52:	1e bc       	out	0x2e, r1	; 46
	WaitSPI();
    3f54:	0d b4       	in	r0, 0x2d	; 45
    3f56:	07 fe       	sbrs	r0, 7
    3f58:	fd cf       	rjmp	.-6      	; 0x3f54 <ADC_In+0x226>
Calibr(uint8_t CR)
{
	static uint8_t Try;
	SPDR = CR;
	WaitADC2();
	if(!(SPDR &ADC_DRDY)) {
    3f5a:	0e b4       	in	r0, 0x2e	; 46
    3f5c:	07 fc       	sbrc	r0, 7
    3f5e:	45 c0       	rjmp	.+138    	; 0x3fea <ADC_In+0x2bc>
		Try = 0;
    3f60:	10 92 ea 02 	sts	0x02EA, r1
		ADC_Phase++;
    3f64:	83 e0       	ldi	r24, 0x03	; 3
    3f66:	80 93 22 0b 	sts	0x0B22, r24
		break;
	case CALI3:
		Calibr(ADC_IN3(CommReg));
#endif
		if (ADC_Phase==READ)
			StartTimer8_ISR(TD_ADC, ADC10ms);
    3f6a:	80 91 f5 06 	lds	r24, 0x06F5
    3f6e:	64 e1       	ldi	r22, 0x14	; 20
    3f70:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <StartTimer8_ISR>
    3f74:	17 e0       	ldi	r17, 0x07	; 7
    3f76:	09 cf       	rjmp	.-494    	; 0x3d8a <ADC_In+0x5c>
				SPDR = SetpVal(NormMode) &~ADC_FSYNC;
				WaitSPI();
				StartTimer8_ISR(TD_ADC, ADC10ms);
			}
		}
		else if(Timer8Stopp_ISR(TD_ADC)) {
    3f78:	80 91 f5 06 	lds	r24, 0x06F5
    3f7c:	0e 94 c0 1b 	call	0x3780	; 0x3780 <Timer8Stopp_ISR>
    3f80:	88 23       	and	r24, r24
    3f82:	09 f4       	brne	.+2      	; 0x3f86 <ADC_In+0x258>
    3f84:	11 cf       	rjmp	.-478    	; 0x3da8 <ADC_In+0x7a>
			ADC_ReadFail++;
    3f86:	80 91 70 07 	lds	r24, 0x0770
    3f8a:	90 91 71 07 	lds	r25, 0x0771
    3f8e:	01 96       	adiw	r24, 0x01	; 1
    3f90:	90 93 71 07 	sts	0x0771, r25
    3f94:	80 93 70 07 	sts	0x0770, r24
			ADC_Phase = RST;
    3f98:	10 92 22 0b 	sts	0x0B22, r1
    3f9c:	17 e0       	ldi	r17, 0x07	; 7
    3f9e:	f5 ce       	rjmp	.-534    	; 0x3d8a <ADC_In+0x5c>
					ADC_Chan--;
				}
				else
			#endif
			if(ADC_Check()) {
				ADC_Break++;
    3fa0:	80 91 b5 06 	lds	r24, 0x06B5
    3fa4:	90 91 b6 06 	lds	r25, 0x06B6
    3fa8:	01 96       	adiw	r24, 0x01	; 1
    3faa:	90 93 b6 06 	sts	0x06B6, r25
    3fae:	80 93 b5 06 	sts	0x06B5, r24
				ADC_Phase = RST;
    3fb2:	10 92 22 0b 	sts	0x0B22, r1
    3fb6:	17 e0       	ldi	r17, 0x07	; 7
    3fb8:	e8 ce       	rjmp	.-560    	; 0x3d8a <ADC_In+0x5c>

// ~~~~~~~~~~~~~~~~~~~~~~~~~
static void
Init(uint8_t CR, uint8_t SR)
{
	SPDR = CR;
    3fba:	80 e2       	ldi	r24, 0x20	; 32
    3fbc:	8e bd       	out	0x2e, r24	; 46
	WaitSPI();
    3fbe:	0d b4       	in	r0, 0x2d	; 45
    3fc0:	07 fe       	sbrs	r0, 7
    3fc2:	fd cf       	rjmp	.-6      	; 0x3fbe <ADC_In+0x290>
	SPDR=ClckVal;
    3fc4:	84 e0       	ldi	r24, 0x04	; 4
    3fc6:	8e bd       	out	0x2e, r24	; 46
	WaitSPI();
    3fc8:	0d b4       	in	r0, 0x2d	; 45
    3fca:	07 fe       	sbrs	r0, 7
    3fcc:	fd cf       	rjmp	.-6      	; 0x3fc8 <ADC_In+0x29a>
	SPDR = SR;
    3fce:	80 e1       	ldi	r24, 0x10	; 16
    3fd0:	8e bd       	out	0x2e, r24	; 46
	WaitSPI();
    3fd2:	0d b4       	in	r0, 0x2d	; 45
    3fd4:	07 fe       	sbrs	r0, 7
    3fd6:	fd cf       	rjmp	.-6      	; 0x3fd2 <ADC_In+0x2a4>
	SPDR = SetpVal(CaliMode) &~ADC_FSYNC;
    3fd8:	86 e4       	ldi	r24, 0x46	; 70
    3fda:	8e bd       	out	0x2e, r24	; 46
	WaitSPI();
    3fdc:	0d b4       	in	r0, 0x2d	; 45
    3fde:	07 fe       	sbrs	r0, 7
    3fe0:	fd cf       	rjmp	.-6      	; 0x3fdc <ADC_In+0x2ae>
	StartTimer8_ISR(TD_ADC, 36);
    3fe2:	80 91 f5 06 	lds	r24, 0x06F5
    3fe6:	64 e2       	ldi	r22, 0x24	; 36
    3fe8:	c8 ce       	rjmp	.-624    	; 0x3d7a <ADC_In+0x4c>
	WaitADC2();
	if(!(SPDR &ADC_DRDY)) {
		Try = 0;
		ADC_Phase++;
	}
	else if(Timer8Stopp_ISR(TD_ADC)) {
    3fea:	80 91 f5 06 	lds	r24, 0x06F5
    3fee:	0e 94 c0 1b 	call	0x3780	; 0x3780 <Timer8Stopp_ISR>
    3ff2:	88 23       	and	r24, r24
    3ff4:	99 f0       	breq	.+38     	; 0x401c <ADC_In+0x2ee>
		ADC_Fail++;
    3ff6:	80 91 e3 08 	lds	r24, 0x08E3
    3ffa:	90 91 e4 08 	lds	r25, 0x08E4
    3ffe:	01 96       	adiw	r24, 0x01	; 1
    4000:	90 93 e4 08 	sts	0x08E4, r25
    4004:	80 93 e3 08 	sts	0x08E3, r24
		ADC_Phase = ++Try<27 ? RST : ADC_OFF;
    4008:	80 91 ea 02 	lds	r24, 0x02EA
    400c:	8f 5f       	subi	r24, 0xFF	; 255
    400e:	80 93 ea 02 	sts	0x02EA, r24
    4012:	8b 31       	cpi	r24, 0x1B	; 27
    4014:	98 f1       	brcs	.+102    	; 0x407c <ADC_In+0x34e>
    4016:	84 e0       	ldi	r24, 0x04	; 4
    4018:	80 93 22 0b 	sts	0x0B22, r24
		Init(ADC_IN3(ClckReg), ADC_IN3(SetpReg));
		break;
	case CALI3:
		Calibr(ADC_IN3(CommReg));
#endif
		if (ADC_Phase==READ)
    401c:	80 91 22 0b 	lds	r24, 0x0B22
    4020:	83 30       	cpi	r24, 0x03	; 3
    4022:	09 f4       	brne	.+2      	; 0x4026 <ADC_In+0x2f8>
    4024:	a2 cf       	rjmp	.-188    	; 0x3f6a <ADC_In+0x23c>
				StartTimer8_ISR(TD_ADC, ADC10ms);
			}
		}
		else if(Timer8Stopp_ISR(TD_ADC)) {
			ADC_ReadFail++;
			ADC_Phase = RST;
    4026:	17 e0       	ldi	r17, 0x07	; 7
    4028:	b0 ce       	rjmp	.-672    	; 0x3d8a <ADC_In+0x5c>
			WaitADC2();
			Buf = SPDR<<8;
			WaitADC1();
			Buf += SPDR;
			#ifdef ADC_Ref_Chan
				if (ADC_Chan==sizeof(Mux)-1 && ADC_Input[sizeof(Mux)-1]!=0 && (Buf<ADC_Ref-ADC_Ref_d || Buf>ADC_Ref+ADC_Ref_d)) {
    402a:	80 91 df 08 	lds	r24, 0x08DF
    402e:	90 91 e0 08 	lds	r25, 0x08E0
    4032:	89 2b       	or	r24, r25
    4034:	09 f4       	brne	.+2      	; 0x4038 <ADC_In+0x30a>
    4036:	e0 ce       	rjmp	.-576    	; 0x3df8 <ADC_In+0xca>
    4038:	ca 01       	movw	r24, r20
    403a:	80 58       	subi	r24, 0x80	; 128
    403c:	9e 43       	sbci	r25, 0x3E	; 62
    403e:	81 5a       	subi	r24, 0xA1	; 161
    4040:	9f 40       	sbci	r25, 0x0F	; 15
    4042:	08 f4       	brcc	.+2      	; 0x4046 <ADC_In+0x318>
    4044:	d9 ce       	rjmp	.-590    	; 0x3df8 <ADC_In+0xca>
					ADC_Break++;
    4046:	80 91 b5 06 	lds	r24, 0x06B5
    404a:	90 91 b6 06 	lds	r25, 0x06B6
    404e:	01 96       	adiw	r24, 0x01	; 1
    4050:	90 93 b6 06 	sts	0x06B6, r25
    4054:	80 93 b5 06 	sts	0x06B5, r24
					ADC_Phase = RST;
    4058:	10 92 22 0b 	sts	0x0B22, r1
					ADC_Chan--;
    405c:	85 e0       	ldi	r24, 0x05	; 5
    405e:	80 93 ca 08 	sts	0x08CA, r24
    4062:	17 e0       	ldi	r17, 0x07	; 7
    4064:	92 ce       	rjmp	.-732    	; 0x3d8a <ADC_In+0x5c>
			#ifdef Port_INH2
				Port_INH2|=INH2;
			#endif
		}
		if (Addr%4/2)	Port_TER_B	|=TER_B;	else Port_TER_B	&=~TER_B;
		if (Addr%2)		Port_TER_A	|=TER_A;	else Port_TER_A	&=~TER_A;
    4066:	75 98       	cbi	0x0e, 5	; 14
    4068:	4b cf       	rjmp	.-362    	; 0x3f00 <ADC_In+0x1d2>
			Port_INH &=~INH;
			#ifdef Port_INH2
				Port_INH2|=INH2;
			#endif
		}
		if (Addr%4/2)	Port_TER_B	|=TER_B;	else Port_TER_B	&=~TER_B;
    406a:	76 98       	cbi	0x0e, 6	; 14
    406c:	46 cf       	rjmp	.-372    	; 0x3efa <ADC_In+0x1cc>
			#ifdef Port_INH2
				Port_INH2 &=~INH2;
			#endif
		}
		else{
			Port_INH &=~INH;
    406e:	77 98       	cbi	0x0e, 7	; 14
			#ifdef Port_INH2
				Port_INH2|=INH2;
    4070:	80 91 02 01 	lds	r24, 0x0102
    4074:	84 60       	ori	r24, 0x04	; 4
    4076:	80 93 02 01 	sts	0x0102, r24
    407a:	35 cf       	rjmp	.-406    	; 0x3ee6 <ADC_In+0x1b8>
		Try = 0;
		ADC_Phase++;
	}
	else if(Timer8Stopp_ISR(TD_ADC)) {
		ADC_Fail++;
		ADC_Phase = ++Try<27 ? RST : ADC_OFF;
    407c:	80 e0       	ldi	r24, 0x00	; 0
    407e:	cc cf       	rjmp	.-104    	; 0x4018 <ADC_In+0x2ea>

00004080 <SPI_Init>:
// Total
// ~~~~~~~~~~~
void
SPI_Init(void)
{
	cli();
    4080:	f8 94       	cli
	#if defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		DDRB = (DDRB &~(1<<DDB3)) |(1<<DDB2) |(1<<DDB1) |(1<<DDB0);
    4082:	84 b1       	in	r24, 0x04	; 4
    4084:	80 7f       	andi	r24, 0xF0	; 240
    4086:	87 60       	ori	r24, 0x07	; 7
    4088:	84 b9       	out	0x04, r24	; 4
		PORTB |=1<<PB3;
    408a:	2b 9a       	sbi	0x05, 3	; 5
	#elif defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
		DDRB = (DDRB &~(1<<DDB6)) |(1<<DDB5) |(1<<DDB7) |(1<<DDB4);
		PORTB |=1<<PB6;
	#endif
	SPCR = (uint8_t)((~(1<<SPIE) |(1<<SPE)) &~(1<<DORD)) |(1<<MSTR) |(1<<CPHA) |(1<<SPR1) |(1<<SPR0);
    408c:	8f e5       	ldi	r24, 0x5F	; 95
    408e:	8c bd       	out	0x2c, r24	; 44
	sei();
    4090:	78 94       	sei
		PortCS_DAC_2 |=CS_DAC_2;
		sei();
	#endif

	#ifndef ADC_Miss
		cli();
    4092:	f8 94       	cli
		#ifdef CS_ADC
			DDR_CS_ADC |=CS_ADC;
    4094:	80 91 01 01 	lds	r24, 0x0101
    4098:	88 60       	ori	r24, 0x08	; 8
    409a:	80 93 01 01 	sts	0x0101, r24
			PortCS_ADC |=CS_ADC;
    409e:	80 91 02 01 	lds	r24, 0x0102
    40a2:	88 60       	ori	r24, 0x08	; 8
    40a4:	80 93 02 01 	sts	0x0102, r24
		#endif
		DDR_RESET_PER |=RESET_PER;
    40a8:	80 91 01 01 	lds	r24, 0x0101
    40ac:	80 61       	ori	r24, 0x10	; 16
    40ae:	80 93 01 01 	sts	0x0101, r24
		#ifdef ADC_Mux
			DDR_INH |=INH;
    40b2:	6f 9a       	sbi	0x0d, 7	; 13
			#ifdef DDR_INH2			
				DDR_INH2 |=INH2;
    40b4:	80 91 01 01 	lds	r24, 0x0101
    40b8:	84 60       	ori	r24, 0x04	; 4
    40ba:	80 93 01 01 	sts	0x0101, r24
			#endif
			DDR_TER_A |=TER_A;
    40be:	6d 9a       	sbi	0x0d, 5	; 13
			DDR_TER_B |=TER_B;
    40c0:	6e 9a       	sbi	0x0d, 6	; 13
		#endif
		sei();
    40c2:	78 94       	sei

// ~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer8_ISR_SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys_ISR;
    40c4:	80 91 db 02 	lds	r24, 0x02DB
	VacantTimer8Sys_ISR += n;
    40c8:	8f 5f       	subi	r24, 0xFF	; 255
    40ca:	80 93 db 02 	sts	0x02DB, r24
    40ce:	81 50       	subi	r24, 0x01	; 1

		TD_ADC = Timer8_ISR_SysAlloc(1);
    40d0:	80 93 f5 06 	sts	0x06F5, r24


		ADC_Chan = ADC_Reg-1;		// Ignore 1-st measurement after calibration
    40d4:	86 e0       	ldi	r24, 0x06	; 6
    40d6:	80 93 ca 08 	sts	0x08CA, r24

		while(ADC_In()==ADC_Reg && ADC_OK);
    40da:	0e 94 97 1e 	call	0x3d2e	; 0x3d2e <ADC_In>
    40de:	87 30       	cpi	r24, 0x07	; 7
    40e0:	91 f4       	brne	.+36     	; 0x4106 <SPI_Init+0x86>
    40e2:	80 91 e3 08 	lds	r24, 0x08E3
    40e6:	90 91 e4 08 	lds	r25, 0x08E4
    40ea:	89 2b       	or	r24, r25
    40ec:	61 f4       	brne	.+24     	; 0x4106 <SPI_Init+0x86>
    40ee:	80 91 70 07 	lds	r24, 0x0770
    40f2:	90 91 71 07 	lds	r25, 0x0771
    40f6:	89 2b       	or	r24, r25
    40f8:	31 f4       	brne	.+12     	; 0x4106 <SPI_Init+0x86>
    40fa:	80 91 b5 06 	lds	r24, 0x06B5
    40fe:	90 91 b6 06 	lds	r25, 0x06B6
    4102:	89 2b       	or	r24, r25
    4104:	51 f3       	breq	.-44     	; 0x40da <SPI_Init+0x5a>
    4106:	08 95       	ret

00004108 <Pow10>:
#include <string.h>

// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
    4108:	48 2f       	mov	r20, r24
	uint16_t Pow = 1;
	while(Exp--)
    410a:	88 23       	and	r24, r24
    410c:	89 f0       	breq	.+34     	; 0x4130 <Pow10+0x28>
    410e:	21 e0       	ldi	r18, 0x01	; 1
    4110:	30 e0       	ldi	r19, 0x00	; 0
		Pow *= 10;
    4112:	c9 01       	movw	r24, r18
    4114:	88 0f       	add	r24, r24
    4116:	99 1f       	adc	r25, r25
    4118:	22 0f       	add	r18, r18
    411a:	33 1f       	adc	r19, r19
    411c:	22 0f       	add	r18, r18
    411e:	33 1f       	adc	r19, r19
    4120:	22 0f       	add	r18, r18
    4122:	33 1f       	adc	r19, r19
    4124:	28 0f       	add	r18, r24
    4126:	39 1f       	adc	r19, r25
    4128:	41 50       	subi	r20, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    412a:	99 f7       	brne	.-26     	; 0x4112 <Pow10+0xa>
		Pow *= 10;
	return Pow;
}
    412c:	c9 01       	movw	r24, r18
    412e:	08 95       	ret
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    4130:	21 e0       	ldi	r18, 0x01	; 1
    4132:	30 e0       	ldi	r19, 0x00	; 0
    4134:	fb cf       	rjmp	.-10     	; 0x412c <Pow10+0x24>

00004136 <PowL10>:
	return Pow;
}
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
    4136:	1f 93       	push	r17
    4138:	18 2f       	mov	r17, r24
	uint32_t Pow = 1;
	while(Exp--)
    413a:	88 23       	and	r24, r24
    413c:	a1 f0       	breq	.+40     	; 0x4166 <PowL10+0x30>
    413e:	21 e0       	ldi	r18, 0x01	; 1
    4140:	30 e0       	ldi	r19, 0x00	; 0
    4142:	40 e0       	ldi	r20, 0x00	; 0
    4144:	50 e0       	ldi	r21, 0x00	; 0
		Pow *= 10;
    4146:	ca 01       	movw	r24, r20
    4148:	b9 01       	movw	r22, r18
    414a:	2a e0       	ldi	r18, 0x0A	; 10
    414c:	30 e0       	ldi	r19, 0x00	; 0
    414e:	40 e0       	ldi	r20, 0x00	; 0
    4150:	50 e0       	ldi	r21, 0x00	; 0
    4152:	0e 94 17 82 	call	0x1042e	; 0x1042e <__mulsi3>
    4156:	9b 01       	movw	r18, r22
    4158:	ac 01       	movw	r20, r24
    415a:	11 50       	subi	r17, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
	uint32_t Pow = 1;
	while(Exp--)
    415c:	a1 f7       	brne	.-24     	; 0x4146 <PowL10+0x10>
		Pow *= 10;
	return Pow;
}
    415e:	b9 01       	movw	r22, r18
    4160:	ca 01       	movw	r24, r20
    4162:	1f 91       	pop	r17
    4164:	08 95       	ret
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
	uint32_t Pow = 1;
	while(Exp--)
    4166:	21 e0       	ldi	r18, 0x01	; 1
    4168:	30 e0       	ldi	r19, 0x00	; 0
    416a:	40 e0       	ldi	r20, 0x00	; 0
    416c:	50 e0       	ldi	r21, 0x00	; 0
    416e:	f7 cf       	rjmp	.-18     	; 0x415e <PowL10+0x28>

00004170 <Log10>:
	return Pow;
}
// ~~~~~~~~~~~~~~~~~
uint8_t
Log10(uint32_t Numb)
{
    4170:	1f 93       	push	r17
	uint8_t Pos;
	for(Pos=0; Numb/=10; Pos++);
    4172:	2a e0       	ldi	r18, 0x0A	; 10
    4174:	30 e0       	ldi	r19, 0x00	; 0
    4176:	40 e0       	ldi	r20, 0x00	; 0
    4178:	50 e0       	ldi	r21, 0x00	; 0
    417a:	0e 94 69 82 	call	0x104d2	; 0x104d2 <__udivmodsi4>
    417e:	c9 01       	movw	r24, r18
    4180:	da 01       	movw	r26, r20
    4182:	bc 01       	movw	r22, r24
    4184:	cd 01       	movw	r24, r26
    4186:	61 15       	cp	r22, r1
    4188:	71 05       	cpc	r23, r1
    418a:	81 05       	cpc	r24, r1
    418c:	91 05       	cpc	r25, r1
    418e:	a1 f0       	breq	.+40     	; 0x41b8 <Log10+0x48>
    4190:	10 e0       	ldi	r17, 0x00	; 0
    4192:	1f 5f       	subi	r17, 0xFF	; 255
    4194:	2a e0       	ldi	r18, 0x0A	; 10
    4196:	30 e0       	ldi	r19, 0x00	; 0
    4198:	40 e0       	ldi	r20, 0x00	; 0
    419a:	50 e0       	ldi	r21, 0x00	; 0
    419c:	0e 94 69 82 	call	0x104d2	; 0x104d2 <__udivmodsi4>
    41a0:	c9 01       	movw	r24, r18
    41a2:	da 01       	movw	r26, r20
    41a4:	bc 01       	movw	r22, r24
    41a6:	cd 01       	movw	r24, r26
    41a8:	61 15       	cp	r22, r1
    41aa:	71 05       	cpc	r23, r1
    41ac:	81 05       	cpc	r24, r1
    41ae:	91 05       	cpc	r25, r1
    41b0:	81 f7       	brne	.-32     	; 0x4192 <Log10+0x22>
	return Pos;
}
    41b2:	81 2f       	mov	r24, r17
    41b4:	1f 91       	pop	r17
    41b6:	08 95       	ret
// ~~~~~~~~~~~~~~~~~
uint8_t
Log10(uint32_t Numb)
{
	uint8_t Pos;
	for(Pos=0; Numb/=10; Pos++);
    41b8:	10 e0       	ldi	r17, 0x00	; 0
    41ba:	fb cf       	rjmp	.-10     	; 0x41b2 <Log10+0x42>

000041bc <CodBCD>:
// ~~~~~~~~~~~~~~~~~~~~

// ~~~~~~~~~~~~~~~~~~~
uint8_t
CodBCD(uint8_t Number)
{
    41bc:	28 2f       	mov	r18, r24
    41be:	6a e0       	ldi	r22, 0x0A	; 10
    41c0:	0e 94 36 82 	call	0x1046c	; 0x1046c <__udivmodqi4>
    41c4:	38 2f       	mov	r19, r24
    41c6:	32 95       	swap	r19
    41c8:	30 7f       	andi	r19, 0xF0	; 240
    41ca:	82 2f       	mov	r24, r18
    41cc:	0e 94 36 82 	call	0x1046c	; 0x1046c <__udivmodqi4>
	return (Number/10<<4)+Number%10;
}
    41d0:	83 2f       	mov	r24, r19
    41d2:	89 0f       	add	r24, r25
    41d4:	08 95       	ret

000041d6 <DecodBCD>:

// ~~~~~~~~~~~~~~~~~~
uint8_t
DecodBCD(uint8_t BCD)
{
    41d6:	28 2f       	mov	r18, r24
    41d8:	22 95       	swap	r18
    41da:	2f 70       	andi	r18, 0x0F	; 15
    41dc:	9a e0       	ldi	r25, 0x0A	; 10
    41de:	29 9f       	mul	r18, r25
    41e0:	90 01       	movw	r18, r0
    41e2:	11 24       	eor	r1, r1
    41e4:	8f 70       	andi	r24, 0x0F	; 15
	return 10*(BCD>>4)+(BCD&0x0F);
}
    41e6:	82 0f       	add	r24, r18
    41e8:	08 95       	ret

000041ea <LineFunc>:
} uLineGraph;

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
int16_t
LineFunc(const LineGraph *LG, int32_t x)
{
    41ea:	2f 92       	push	r2
    41ec:	3f 92       	push	r3
    41ee:	4f 92       	push	r4
    41f0:	5f 92       	push	r5
    41f2:	6f 92       	push	r6
    41f4:	7f 92       	push	r7
    41f6:	8f 92       	push	r8
    41f8:	9f 92       	push	r9
    41fa:	af 92       	push	r10
    41fc:	bf 92       	push	r11
    41fe:	cf 92       	push	r12
    4200:	df 92       	push	r13
    4202:	ef 92       	push	r14
    4204:	ff 92       	push	r15
    4206:	0f 93       	push	r16
    4208:	1f 93       	push	r17
    420a:	cf 93       	push	r28
    420c:	df 93       	push	r29
    420e:	ec 01       	movw	r28, r24
    4210:	7a 01       	movw	r14, r20
    4212:	8b 01       	movw	r16, r22
	int16_t y;
	if (LG->x1==LG->x2)
    4214:	28 80       	ld	r2, Y
    4216:	39 80       	ldd	r3, Y+1	; 0x01
    4218:	4a 80       	ldd	r4, Y+2	; 0x02
    421a:	5b 80       	ldd	r5, Y+3	; 0x03
    421c:	6c 81       	ldd	r22, Y+4	; 0x04
    421e:	7d 81       	ldd	r23, Y+5	; 0x05
    4220:	8e 81       	ldd	r24, Y+6	; 0x06
    4222:	9f 81       	ldd	r25, Y+7	; 0x07
    4224:	26 16       	cp	r2, r22
    4226:	37 06       	cpc	r3, r23
    4228:	48 06       	cpc	r4, r24
    422a:	59 06       	cpc	r5, r25
    422c:	09 f4       	brne	.+2      	; 0x4230 <LineFunc+0x46>
    422e:	58 c0       	rjmp	.+176    	; 0x42e0 <LineFunc+0xf6>
		y = LG->y1;
	else {
		float x1=LG->x1, x2=LG->x2, y1=LG->y1, y2=LG->y2;
    4230:	0e 94 cc 7c 	call	0xf998	; 0xf998 <__floatsisf>
    4234:	5b 01       	movw	r10, r22
    4236:	6c 01       	movw	r12, r24
    4238:	6a 85       	ldd	r22, Y+10	; 0x0a
    423a:	7b 85       	ldd	r23, Y+11	; 0x0b
    423c:	88 27       	eor	r24, r24
    423e:	77 fd       	sbrc	r23, 7
    4240:	80 95       	com	r24
    4242:	98 2f       	mov	r25, r24
    4244:	0e 94 cc 7c 	call	0xf998	; 0xf998 <__floatsisf>
    4248:	3b 01       	movw	r6, r22
    424a:	4c 01       	movw	r8, r24
		y = (x-x2)*(y2-y1)/(x2-x1)+y2;
    424c:	c8 01       	movw	r24, r16
    424e:	b7 01       	movw	r22, r14
    4250:	0e 94 cc 7c 	call	0xf998	; 0xf998 <__floatsisf>
    4254:	a6 01       	movw	r20, r12
    4256:	95 01       	movw	r18, r10
    4258:	0e 94 cd 80 	call	0x1019a	; 0x1019a <__subsf3>
    425c:	7b 01       	movw	r14, r22
    425e:	8c 01       	movw	r16, r24
    4260:	68 85       	ldd	r22, Y+8	; 0x08
    4262:	79 85       	ldd	r23, Y+9	; 0x09
    4264:	88 27       	eor	r24, r24
    4266:	77 fd       	sbrc	r23, 7
    4268:	80 95       	com	r24
    426a:	98 2f       	mov	r25, r24
    426c:	0e 94 cc 7c 	call	0xf998	; 0xf998 <__floatsisf>
    4270:	9b 01       	movw	r18, r22
    4272:	ac 01       	movw	r20, r24
    4274:	c4 01       	movw	r24, r8
    4276:	b3 01       	movw	r22, r6
    4278:	0e 94 cd 80 	call	0x1019a	; 0x1019a <__subsf3>
    427c:	9b 01       	movw	r18, r22
    427e:	ac 01       	movw	r20, r24
    4280:	c8 01       	movw	r24, r16
    4282:	b7 01       	movw	r22, r14
    4284:	0e 94 07 7d 	call	0xfa0e	; 0xfa0e <__mulsf3>
    4288:	7b 01       	movw	r14, r22
    428a:	8c 01       	movw	r16, r24
    428c:	c2 01       	movw	r24, r4
    428e:	b1 01       	movw	r22, r2
    4290:	0e 94 cc 7c 	call	0xf998	; 0xf998 <__floatsisf>
    4294:	9b 01       	movw	r18, r22
    4296:	ac 01       	movw	r20, r24
    4298:	c6 01       	movw	r24, r12
    429a:	b5 01       	movw	r22, r10
    429c:	0e 94 cd 80 	call	0x1019a	; 0x1019a <__subsf3>
    42a0:	9b 01       	movw	r18, r22
    42a2:	ac 01       	movw	r20, r24
    42a4:	c8 01       	movw	r24, r16
    42a6:	b7 01       	movw	r22, r14
    42a8:	0e 94 32 81 	call	0x10264	; 0x10264 <__divsf3>
    42ac:	a4 01       	movw	r20, r8
    42ae:	93 01       	movw	r18, r6
    42b0:	0e 94 ce 80 	call	0x1019c	; 0x1019c <__addsf3>
    42b4:	0e 94 9a 81 	call	0x10334	; 0x10334 <__fixsfsi>
    42b8:	cb 01       	movw	r24, r22
	}
	return y;
}
    42ba:	df 91       	pop	r29
    42bc:	cf 91       	pop	r28
    42be:	1f 91       	pop	r17
    42c0:	0f 91       	pop	r16
    42c2:	ff 90       	pop	r15
    42c4:	ef 90       	pop	r14
    42c6:	df 90       	pop	r13
    42c8:	cf 90       	pop	r12
    42ca:	bf 90       	pop	r11
    42cc:	af 90       	pop	r10
    42ce:	9f 90       	pop	r9
    42d0:	8f 90       	pop	r8
    42d2:	7f 90       	pop	r7
    42d4:	6f 90       	pop	r6
    42d6:	5f 90       	pop	r5
    42d8:	4f 90       	pop	r4
    42da:	3f 90       	pop	r3
    42dc:	2f 90       	pop	r2
    42de:	08 95       	ret
int16_t
LineFunc(const LineGraph *LG, int32_t x)
{
	int16_t y;
	if (LG->x1==LG->x2)
		y = LG->y1;
    42e0:	88 85       	ldd	r24, Y+8	; 0x08
    42e2:	99 85       	ldd	r25, Y+9	; 0x09
    42e4:	ea cf       	rjmp	.-44     	; 0x42ba <LineFunc+0xd0>

000042e6 <uLineFunc>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
int16_t
uLineFunc(const uLineGraph *LG, uint32_t x)
{
    42e6:	2f 92       	push	r2
    42e8:	3f 92       	push	r3
    42ea:	4f 92       	push	r4
    42ec:	5f 92       	push	r5
    42ee:	6f 92       	push	r6
    42f0:	7f 92       	push	r7
    42f2:	8f 92       	push	r8
    42f4:	9f 92       	push	r9
    42f6:	af 92       	push	r10
    42f8:	bf 92       	push	r11
    42fa:	cf 92       	push	r12
    42fc:	df 92       	push	r13
    42fe:	ef 92       	push	r14
    4300:	ff 92       	push	r15
    4302:	0f 93       	push	r16
    4304:	1f 93       	push	r17
    4306:	cf 93       	push	r28
    4308:	df 93       	push	r29
    430a:	ec 01       	movw	r28, r24
    430c:	7a 01       	movw	r14, r20
    430e:	8b 01       	movw	r16, r22
	int16_t y;
	if (LG->x1==LG->x2)
    4310:	28 80       	ld	r2, Y
    4312:	39 80       	ldd	r3, Y+1	; 0x01
    4314:	4a 80       	ldd	r4, Y+2	; 0x02
    4316:	5b 80       	ldd	r5, Y+3	; 0x03
    4318:	6c 81       	ldd	r22, Y+4	; 0x04
    431a:	7d 81       	ldd	r23, Y+5	; 0x05
    431c:	8e 81       	ldd	r24, Y+6	; 0x06
    431e:	9f 81       	ldd	r25, Y+7	; 0x07
    4320:	26 16       	cp	r2, r22
    4322:	37 06       	cpc	r3, r23
    4324:	48 06       	cpc	r4, r24
    4326:	59 06       	cpc	r5, r25
    4328:	09 f4       	brne	.+2      	; 0x432c <uLineFunc+0x46>
    432a:	58 c0       	rjmp	.+176    	; 0x43dc <uLineFunc+0xf6>
		y = LG->y1;
	else {
		float x1=LG->x1, x2=LG->x2, y1=LG->y1, y2=LG->y2;
    432c:	0e 94 ca 7c 	call	0xf994	; 0xf994 <__floatunsisf>
    4330:	5b 01       	movw	r10, r22
    4332:	6c 01       	movw	r12, r24
    4334:	6a 85       	ldd	r22, Y+10	; 0x0a
    4336:	7b 85       	ldd	r23, Y+11	; 0x0b
    4338:	88 27       	eor	r24, r24
    433a:	77 fd       	sbrc	r23, 7
    433c:	80 95       	com	r24
    433e:	98 2f       	mov	r25, r24
    4340:	0e 94 cc 7c 	call	0xf998	; 0xf998 <__floatsisf>
    4344:	3b 01       	movw	r6, r22
    4346:	4c 01       	movw	r8, r24
		y = (x-x2)*(y2-y1)/(x2-x1)+y2;
    4348:	c8 01       	movw	r24, r16
    434a:	b7 01       	movw	r22, r14
    434c:	0e 94 ca 7c 	call	0xf994	; 0xf994 <__floatunsisf>
    4350:	a6 01       	movw	r20, r12
    4352:	95 01       	movw	r18, r10
    4354:	0e 94 cd 80 	call	0x1019a	; 0x1019a <__subsf3>
    4358:	7b 01       	movw	r14, r22
    435a:	8c 01       	movw	r16, r24
    435c:	68 85       	ldd	r22, Y+8	; 0x08
    435e:	79 85       	ldd	r23, Y+9	; 0x09
    4360:	88 27       	eor	r24, r24
    4362:	77 fd       	sbrc	r23, 7
    4364:	80 95       	com	r24
    4366:	98 2f       	mov	r25, r24
    4368:	0e 94 cc 7c 	call	0xf998	; 0xf998 <__floatsisf>
    436c:	9b 01       	movw	r18, r22
    436e:	ac 01       	movw	r20, r24
    4370:	c4 01       	movw	r24, r8
    4372:	b3 01       	movw	r22, r6
    4374:	0e 94 cd 80 	call	0x1019a	; 0x1019a <__subsf3>
    4378:	9b 01       	movw	r18, r22
    437a:	ac 01       	movw	r20, r24
    437c:	c8 01       	movw	r24, r16
    437e:	b7 01       	movw	r22, r14
    4380:	0e 94 07 7d 	call	0xfa0e	; 0xfa0e <__mulsf3>
    4384:	7b 01       	movw	r14, r22
    4386:	8c 01       	movw	r16, r24
    4388:	c2 01       	movw	r24, r4
    438a:	b1 01       	movw	r22, r2
    438c:	0e 94 ca 7c 	call	0xf994	; 0xf994 <__floatunsisf>
    4390:	9b 01       	movw	r18, r22
    4392:	ac 01       	movw	r20, r24
    4394:	c6 01       	movw	r24, r12
    4396:	b5 01       	movw	r22, r10
    4398:	0e 94 cd 80 	call	0x1019a	; 0x1019a <__subsf3>
    439c:	9b 01       	movw	r18, r22
    439e:	ac 01       	movw	r20, r24
    43a0:	c8 01       	movw	r24, r16
    43a2:	b7 01       	movw	r22, r14
    43a4:	0e 94 32 81 	call	0x10264	; 0x10264 <__divsf3>
    43a8:	a4 01       	movw	r20, r8
    43aa:	93 01       	movw	r18, r6
    43ac:	0e 94 ce 80 	call	0x1019c	; 0x1019c <__addsf3>
    43b0:	0e 94 9a 81 	call	0x10334	; 0x10334 <__fixsfsi>
    43b4:	cb 01       	movw	r24, r22
	}
	return y;
}
    43b6:	df 91       	pop	r29
    43b8:	cf 91       	pop	r28
    43ba:	1f 91       	pop	r17
    43bc:	0f 91       	pop	r16
    43be:	ff 90       	pop	r15
    43c0:	ef 90       	pop	r14
    43c2:	df 90       	pop	r13
    43c4:	cf 90       	pop	r12
    43c6:	bf 90       	pop	r11
    43c8:	af 90       	pop	r10
    43ca:	9f 90       	pop	r9
    43cc:	8f 90       	pop	r8
    43ce:	7f 90       	pop	r7
    43d0:	6f 90       	pop	r6
    43d2:	5f 90       	pop	r5
    43d4:	4f 90       	pop	r4
    43d6:	3f 90       	pop	r3
    43d8:	2f 90       	pop	r2
    43da:	08 95       	ret
int16_t
uLineFunc(const uLineGraph *LG, uint32_t x)
{
	int16_t y;
	if (LG->x1==LG->x2)
		y = LG->y1;
    43dc:	88 85       	ldd	r24, Y+8	; 0x08
    43de:	99 85       	ldd	r25, Y+9	; 0x09
    43e0:	ea cf       	rjmp	.-44     	; 0x43b6 <uLineFunc+0xd0>

000043e2 <PGM_uBrokLine>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
int16_t
PGM_uBrokLine(PGM_uDataPoint *Brok, uint16_t x)
{
    43e2:	af 92       	push	r10
    43e4:	bf 92       	push	r11
    43e6:	cf 92       	push	r12
    43e8:	df 92       	push	r13
    43ea:	ef 92       	push	r14
    43ec:	ff 92       	push	r15
    43ee:	0f 93       	push	r16
    43f0:	1f 93       	push	r17
    43f2:	df 93       	push	r29
    43f4:	cf 93       	push	r28
    43f6:	cd b7       	in	r28, 0x3d	; 61
    43f8:	de b7       	in	r29, 0x3e	; 62
    43fa:	2c 97       	sbiw	r28, 0x0c	; 12
    43fc:	0f b6       	in	r0, 0x3f	; 63
    43fe:	f8 94       	cli
    4400:	de bf       	out	0x3e, r29	; 62
    4402:	0f be       	out	0x3f, r0	; 63
    4404:	cd bf       	out	0x3d, r28	; 61
    4406:	dc 01       	movw	r26, r24

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    4408:	fc 01       	movw	r30, r24
    440a:	85 91       	lpm	r24, Z+
    440c:	94 91       	lpm	r25, Z+
	uLineGraph Segm;
	Segm.x2 = prw(&Brok->x);
    440e:	7c 01       	movw	r14, r24
    4410:	00 e0       	ldi	r16, 0x00	; 0
    4412:	10 e0       	ldi	r17, 0x00	; 0
    4414:	5b 01       	movw	r10, r22
    4416:	cc 24       	eor	r12, r12
    4418:	dd 24       	eor	r13, r13
	do {
		Segm.x1 = Segm.x2;
		Segm.x2 = prw(&(++Brok)->x);
    441a:	cd 01       	movw	r24, r26
    441c:	04 96       	adiw	r24, 0x04	; 4
    441e:	fc 01       	movw	r30, r24
    4420:	25 91       	lpm	r18, Z+
    4422:	34 91       	lpm	r19, Z+
    4424:	ad 01       	movw	r20, r26
    4426:	b7 01       	movw	r22, r14
    4428:	f8 01       	movw	r30, r16
    442a:	dc 01       	movw	r26, r24
    442c:	79 01       	movw	r14, r18
    442e:	00 e0       	ldi	r16, 0x00	; 0
    4430:	10 e0       	ldi	r17, 0x00	; 0
	} while(x>Segm.x2);
    4432:	ea 14       	cp	r14, r10
    4434:	fb 04       	cpc	r15, r11
    4436:	0c 05       	cpc	r16, r12
    4438:	1d 05       	cpc	r17, r13
    443a:	78 f3       	brcs	.-34     	; 0x441a <PGM_uBrokLine+0x38>
    443c:	ca 01       	movw	r24, r20
    443e:	9b 01       	movw	r18, r22
    4440:	af 01       	movw	r20, r30
    4442:	69 83       	std	Y+1, r22	; 0x01
    4444:	3a 83       	std	Y+2, r19	; 0x02
    4446:	eb 83       	std	Y+3, r30	; 0x03
    4448:	5c 83       	std	Y+4, r21	; 0x04
    444a:	ed 82       	std	Y+5, r14	; 0x05
    444c:	fe 82       	std	Y+6, r15	; 0x06
    444e:	0f 83       	std	Y+7, r16	; 0x07
    4450:	18 87       	std	Y+8, r17	; 0x08
    4452:	fc 01       	movw	r30, r24
    4454:	32 96       	adiw	r30, 0x02	; 2
    4456:	85 91       	lpm	r24, Z+
    4458:	94 91       	lpm	r25, Z+
	Segm.y1 = (int16_t)prw(&(Brok-1)->y);
    445a:	9a 87       	std	Y+10, r25	; 0x0a
    445c:	89 87       	std	Y+9, r24	; 0x09
    445e:	fd 01       	movw	r30, r26
    4460:	32 96       	adiw	r30, 0x02	; 2
    4462:	85 91       	lpm	r24, Z+
    4464:	94 91       	lpm	r25, Z+
	Segm.y2 = (int16_t)prw(&Brok->y);
    4466:	9c 87       	std	Y+12, r25	; 0x0c
    4468:	8b 87       	std	Y+11, r24	; 0x0b
	return uLineFunc(&Segm, x);
    446a:	ce 01       	movw	r24, r28
    446c:	01 96       	adiw	r24, 0x01	; 1
    446e:	b6 01       	movw	r22, r12
    4470:	a5 01       	movw	r20, r10
    4472:	0e 94 73 21 	call	0x42e6	; 0x42e6 <uLineFunc>
}
    4476:	2c 96       	adiw	r28, 0x0c	; 12
    4478:	0f b6       	in	r0, 0x3f	; 63
    447a:	f8 94       	cli
    447c:	de bf       	out	0x3e, r29	; 62
    447e:	0f be       	out	0x3f, r0	; 63
    4480:	cd bf       	out	0x3d, r28	; 61
    4482:	cf 91       	pop	r28
    4484:	df 91       	pop	r29
    4486:	1f 91       	pop	r17
    4488:	0f 91       	pop	r16
    448a:	ff 90       	pop	r15
    448c:	ef 90       	pop	r14
    448e:	df 90       	pop	r13
    4490:	cf 90       	pop	r12
    4492:	bf 90       	pop	r11
    4494:	af 90       	pop	r10
    4496:	08 95       	ret

00004498 <InterBrokLine>:
	uint8_t WiAbsc, int16_t (*TblAbsc)[WiAbsc], uint8_t Absc,
	uint8_t WiOrdi, int16_t (*TblOrdi)[WiOrdi], uint8_t Ordi,
	uint8_t Len,
	int16_t x
)
{
    4498:	2f 92       	push	r2
    449a:	3f 92       	push	r3
    449c:	4f 92       	push	r4
    449e:	5f 92       	push	r5
    44a0:	6f 92       	push	r6
    44a2:	7f 92       	push	r7
    44a4:	8f 92       	push	r8
    44a6:	9f 92       	push	r9
    44a8:	af 92       	push	r10
    44aa:	bf 92       	push	r11
    44ac:	cf 92       	push	r12
    44ae:	df 92       	push	r13
    44b0:	ef 92       	push	r14
    44b2:	ff 92       	push	r15
    44b4:	0f 93       	push	r16
    44b6:	1f 93       	push	r17
    44b8:	df 93       	push	r29
    44ba:	cf 93       	push	r28
    44bc:	cd b7       	in	r28, 0x3d	; 61
    44be:	de b7       	in	r29, 0x3e	; 62
    44c0:	2e 97       	sbiw	r28, 0x0e	; 14
    44c2:	0f b6       	in	r0, 0x3f	; 63
    44c4:	f8 94       	cli
    44c6:	de bf       	out	0x3e, r29	; 62
    44c8:	0f be       	out	0x3f, r0	; 63
    44ca:	cd bf       	out	0x3d, r28	; 61
    44cc:	2b 01       	movw	r4, r22
    44ce:	2d 87       	std	Y+13, r18	; 0x0d
    44d0:	18 01       	movw	r2, r16
    44d2:	ee 86       	std	Y+14, r14	; 0x0e
    44d4:	7c 2d       	mov	r23, r12
	LineGraph Segm;
	uint8_t i = 0;
	Segm.x2=TblAbsc[0][Absc];
    44d6:	c4 2e       	mov	r12, r20
    44d8:	dd 24       	eor	r13, r13
    44da:	cc 0c       	add	r12, r12
    44dc:	dd 1c       	adc	r13, r13
    44de:	f2 01       	movw	r30, r4
    44e0:	ec 0d       	add	r30, r12
    44e2:	fd 1d       	adc	r31, r13
    44e4:	20 81       	ld	r18, Z
    44e6:	31 81       	ldd	r19, Z+1	; 0x01
    44e8:	79 01       	movw	r14, r18
    44ea:	00 27       	eor	r16, r16
    44ec:	f7 fc       	sbrc	r15, 7
    44ee:	00 95       	com	r16
    44f0:	10 2f       	mov	r17, r16
    44f2:	ed 82       	std	Y+5, r14	; 0x05
    44f4:	fe 82       	std	Y+6, r15	; 0x06
    44f6:	0f 83       	std	Y+7, r16	; 0x07
    44f8:	18 87       	std	Y+8, r17	; 0x08
    44fa:	a8 2f       	mov	r26, r24
    44fc:	b0 e0       	ldi	r27, 0x00	; 0
    44fe:	aa 0f       	add	r26, r26
    4500:	bb 1f       	adc	r27, r27
    4502:	35 01       	movw	r6, r10
    4504:	88 24       	eor	r8, r8
    4506:	77 fc       	sbrc	r7, 7
    4508:	80 94       	com	r8
    450a:	98 2c       	mov	r9, r8
    450c:	60 e0       	ldi	r22, 0x00	; 0
    450e:	02 c0       	rjmp	.+4      	; 0x4514 <InterBrokLine+0x7c>
	do {
		Segm.x1 = Segm.x2;
		Segm.x2 = TblAbsc[++i][Absc];
	} while(x>Segm.x2 && i<Len);
    4510:	79 01       	movw	r14, r18
    4512:	8a 01       	movw	r16, r20
	LineGraph Segm;
	uint8_t i = 0;
	Segm.x2=TblAbsc[0][Absc];
	do {
		Segm.x1 = Segm.x2;
		Segm.x2 = TblAbsc[++i][Absc];
    4514:	6f 5f       	subi	r22, 0xFF	; 255
    4516:	a6 2e       	mov	r10, r22
    4518:	bb 24       	eor	r11, r11
    451a:	aa 9e       	mul	r10, r26
    451c:	f0 01       	movw	r30, r0
    451e:	ab 9e       	mul	r10, r27
    4520:	f0 0d       	add	r31, r0
    4522:	ba 9e       	mul	r11, r26
    4524:	f0 0d       	add	r31, r0
    4526:	11 24       	eor	r1, r1
    4528:	e4 0d       	add	r30, r4
    452a:	f5 1d       	adc	r31, r5
    452c:	ec 0d       	add	r30, r12
    452e:	fd 1d       	adc	r31, r13
    4530:	80 81       	ld	r24, Z
    4532:	91 81       	ldd	r25, Z+1	; 0x01
    4534:	9c 01       	movw	r18, r24
    4536:	44 27       	eor	r20, r20
    4538:	37 fd       	sbrc	r19, 7
    453a:	40 95       	com	r20
    453c:	54 2f       	mov	r21, r20
	} while(x>Segm.x2 && i<Len);
    453e:	26 15       	cp	r18, r6
    4540:	37 05       	cpc	r19, r7
    4542:	48 05       	cpc	r20, r8
    4544:	59 05       	cpc	r21, r9
    4546:	14 f4       	brge	.+4      	; 0x454c <InterBrokLine+0xb4>
    4548:	67 17       	cp	r22, r23
    454a:	10 f3       	brcs	.-60     	; 0x4510 <InterBrokLine+0x78>
    454c:	e9 82       	std	Y+1, r14	; 0x01
    454e:	fa 82       	std	Y+2, r15	; 0x02
    4550:	0b 83       	std	Y+3, r16	; 0x03
    4552:	1c 83       	std	Y+4, r17	; 0x04
    4554:	2d 83       	std	Y+5, r18	; 0x05
    4556:	3e 83       	std	Y+6, r19	; 0x06
    4558:	4f 83       	std	Y+7, r20	; 0x07
    455a:	58 87       	std	Y+8, r21	; 0x08
	Segm.y1 = TblOrdi[i-1][Ordi];
    455c:	8d 85       	ldd	r24, Y+13	; 0x0d
    455e:	28 2f       	mov	r18, r24
    4560:	30 e0       	ldi	r19, 0x00	; 0
    4562:	22 0f       	add	r18, r18
    4564:	33 1f       	adc	r19, r19
    4566:	8e 85       	ldd	r24, Y+14	; 0x0e
    4568:	a8 2f       	mov	r26, r24
    456a:	b0 e0       	ldi	r27, 0x00	; 0
    456c:	08 94       	sec
    456e:	a1 08       	sbc	r10, r1
    4570:	b1 08       	sbc	r11, r1
    4572:	a2 9e       	mul	r10, r18
    4574:	f0 01       	movw	r30, r0
    4576:	a3 9e       	mul	r10, r19
    4578:	f0 0d       	add	r31, r0
    457a:	b2 9e       	mul	r11, r18
    457c:	f0 0d       	add	r31, r0
    457e:	11 24       	eor	r1, r1
    4580:	08 94       	sec
    4582:	a1 1c       	adc	r10, r1
    4584:	b1 1c       	adc	r11, r1
    4586:	e2 0d       	add	r30, r2
    4588:	f3 1d       	adc	r31, r3
    458a:	aa 0f       	add	r26, r26
    458c:	bb 1f       	adc	r27, r27
    458e:	ea 0f       	add	r30, r26
    4590:	fb 1f       	adc	r31, r27
    4592:	80 81       	ld	r24, Z
    4594:	91 81       	ldd	r25, Z+1	; 0x01
    4596:	9a 87       	std	Y+10, r25	; 0x0a
    4598:	89 87       	std	Y+9, r24	; 0x09
	Segm.y2 = TblOrdi[i][Ordi];
    459a:	a2 9e       	mul	r10, r18
    459c:	c0 01       	movw	r24, r0
    459e:	a3 9e       	mul	r10, r19
    45a0:	90 0d       	add	r25, r0
    45a2:	b2 9e       	mul	r11, r18
    45a4:	90 0d       	add	r25, r0
    45a6:	11 24       	eor	r1, r1
    45a8:	82 0d       	add	r24, r2
    45aa:	93 1d       	adc	r25, r3
    45ac:	a8 0f       	add	r26, r24
    45ae:	b9 1f       	adc	r27, r25
    45b0:	8d 91       	ld	r24, X+
    45b2:	9c 91       	ld	r25, X
    45b4:	9c 87       	std	Y+12, r25	; 0x0c
    45b6:	8b 87       	std	Y+11, r24	; 0x0b
	return LineFunc(&Segm, x);
    45b8:	ce 01       	movw	r24, r28
    45ba:	01 96       	adiw	r24, 0x01	; 1
    45bc:	b4 01       	movw	r22, r8
    45be:	a3 01       	movw	r20, r6
    45c0:	0e 94 f5 20 	call	0x41ea	; 0x41ea <LineFunc>
}
    45c4:	2e 96       	adiw	r28, 0x0e	; 14
    45c6:	0f b6       	in	r0, 0x3f	; 63
    45c8:	f8 94       	cli
    45ca:	de bf       	out	0x3e, r29	; 62
    45cc:	0f be       	out	0x3f, r0	; 63
    45ce:	cd bf       	out	0x3d, r28	; 61
    45d0:	cf 91       	pop	r28
    45d2:	df 91       	pop	r29
    45d4:	1f 91       	pop	r17
    45d6:	0f 91       	pop	r16
    45d8:	ff 90       	pop	r15
    45da:	ef 90       	pop	r14
    45dc:	df 90       	pop	r13
    45de:	cf 90       	pop	r12
    45e0:	bf 90       	pop	r11
    45e2:	af 90       	pop	r10
    45e4:	9f 90       	pop	r9
    45e6:	8f 90       	pop	r8
    45e8:	7f 90       	pop	r7
    45ea:	6f 90       	pop	r6
    45ec:	5f 90       	pop	r5
    45ee:	4f 90       	pop	r4
    45f0:	3f 90       	pop	r3
    45f2:	2f 90       	pop	r2
    45f4:	08 95       	ret

000045f6 <TWI_Init>:
}

uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    45f6:	90 91 cf 02 	lds	r25, 0x02CF
	VacantTimer8Sys += n;
    45fa:	89 2f       	mov	r24, r25
    45fc:	8f 5f       	subi	r24, 0xFF	; 255

// ~~~~~~~~~~~
void
TWI_Init(void)
{
	TD_TWI_Poll = Timer8SysAlloc(1);
    45fe:	90 93 d0 04 	sts	0x04D0, r25
    4602:	8f 5f       	subi	r24, 0xFF	; 255
    4604:	80 93 cf 02 	sts	0x02CF, r24
    4608:	81 50       	subi	r24, 0x01	; 1
	TD_TWI_Timeout = Timer8SysAlloc(1);
    460a:	80 93 d1 04 	sts	0x04D1, r24

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    460e:	80 91 d0 02 	lds	r24, 0x02D0
	VacantTimer16Sys += n;
    4612:	8f 5f       	subi	r24, 0xFF	; 255
    4614:	80 93 d0 02 	sts	0x02D0, r24
    4618:	81 50       	subi	r24, 0x01	; 1
	TD_RTC_Check = Timer16SysAlloc(1);
    461a:	80 93 d2 04 	sts	0x04D2, r24
	StartTimer16(TD_RTC_Check, 300);
    461e:	6c e2       	ldi	r22, 0x2C	; 44
    4620:	71 e0       	ldi	r23, 0x01	; 1
    4622:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
	TWBR = 144;	//50
    4626:	80 e9       	ldi	r24, 0x90	; 144
    4628:	80 93 b8 00 	sts	0x00B8, r24
}
    462c:	08 95       	ret

0000462e <TWI_Error>:
// ~~~~~~~~~~~
void
TWI_Error(void)
{
	TWI_Error_Counter++;
    462e:	80 91 9d 08 	lds	r24, 0x089D
    4632:	90 91 9e 08 	lds	r25, 0x089E
    4636:	01 96       	adiw	r24, 0x01	; 1
    4638:	90 93 9e 08 	sts	0x089E, r25
    463c:	80 93 9d 08 	sts	0x089D, r24
	//StopTWI();
	PowerOffTWI();
    4640:	10 92 bc 00 	sts	0x00BC, r1
	TWI_Phase = PCF_START;
    4644:	10 92 7d 07 	sts	0x077D, r1
	StartTimer8(TD_TWI_Poll, 49);
    4648:	80 91 d0 04 	lds	r24, 0x04D0
    464c:	61 e3       	ldi	r22, 0x31	; 49
    464e:	0e 94 8f 1a 	call	0x351e	; 0x351e <StartTimer8>
}
    4652:	08 95       	ret

00004654 <WriteRTC>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
WriteRTC(uint8_t Addr, uint8_t Dat)
{
    4654:	bf 92       	push	r11
    4656:	cf 92       	push	r12
    4658:	df 92       	push	r13
    465a:	ef 92       	push	r14
    465c:	ff 92       	push	r15
    465e:	0f 93       	push	r16
    4660:	1f 93       	push	r17
/*	if (!(TWCR &(1<<TWINT))){ //Wait for the end of current TWI operation and isuue STOP
		_delay_us(100);
		StopTWI();
		_delay_us(50);
	}*/
	PowerOffTWI();
    4662:	4c eb       	ldi	r20, 0xBC	; 188
    4664:	c4 2e       	mov	r12, r20
    4666:	d1 2c       	mov	r13, r1
    4668:	f6 01       	movw	r30, r12
    466a:	10 82       	st	Z, r1
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    466c:	e0 e9       	ldi	r30, 0x90	; 144
    466e:	f1 e0       	ldi	r31, 0x01	; 1
    4670:	31 97       	sbiw	r30, 0x01	; 1
    4672:	f1 f7       	brne	.-4      	; 0x4670 <WriteRTC+0x1c>
	_delay_us(100);
	//_delay_us(150);_delay_us(150);
	StartTWI();
    4674:	94 ea       	ldi	r25, 0xA4	; 164
    4676:	f6 01       	movw	r30, r12
    4678:	90 83       	st	Z, r25
    467a:	08 e5       	ldi	r16, 0x58	; 88
    467c:	12 e0       	ldi	r17, 0x02	; 2
    467e:	f8 01       	movw	r30, r16
    4680:	31 97       	sbiw	r30, 0x01	; 1
    4682:	f1 f7       	brne	.-4      	; 0x4680 <WriteRTC+0x2c>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = SLA_W(PCF_SLA);
    4684:	f8 01       	movw	r30, r16
    4686:	31 97       	sbiw	r30, 0x01	; 1
    4688:	f1 f7       	brne	.-4      	; 0x4686 <WriteRTC+0x32>
    468a:	3b eb       	ldi	r19, 0xBB	; 187
    468c:	e3 2e       	mov	r14, r19
    468e:	f1 2c       	mov	r15, r1
    4690:	90 ed       	ldi	r25, 0xD0	; 208
    4692:	f7 01       	movw	r30, r14
    4694:	90 83       	st	Z, r25
    4696:	90 81       	ld	r25, Z
    4698:	90 83       	st	Z, r25
	RunTWI();
    469a:	24 e8       	ldi	r18, 0x84	; 132
    469c:	b2 2e       	mov	r11, r18
    469e:	f6 01       	movw	r30, r12
    46a0:	b0 82       	st	Z, r11
    46a2:	f8 01       	movw	r30, r16
    46a4:	31 97       	sbiw	r30, 0x01	; 1
    46a6:	f1 f7       	brne	.-4      	; 0x46a4 <WriteRTC+0x50>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = AddrSec+Addr;
    46a8:	f8 01       	movw	r30, r16
    46aa:	31 97       	sbiw	r30, 0x01	; 1
    46ac:	f1 f7       	brne	.-4      	; 0x46aa <WriteRTC+0x56>
    46ae:	f7 01       	movw	r30, r14
    46b0:	80 83       	st	Z, r24
	RunTWI();
    46b2:	f6 01       	movw	r30, r12
    46b4:	b0 82       	st	Z, r11
    46b6:	c8 01       	movw	r24, r16
    46b8:	01 97       	sbiw	r24, 0x01	; 1
    46ba:	f1 f7       	brne	.-4      	; 0x46b8 <WriteRTC+0x64>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = CodBCD(Dat);
    46bc:	c8 01       	movw	r24, r16
    46be:	01 97       	sbiw	r24, 0x01	; 1
    46c0:	f1 f7       	brne	.-4      	; 0x46be <WriteRTC+0x6a>
    46c2:	86 2f       	mov	r24, r22
    46c4:	0e 94 de 20 	call	0x41bc	; 0x41bc <CodBCD>
    46c8:	f7 01       	movw	r30, r14
    46ca:	80 83       	st	Z, r24
	RunTWI();
    46cc:	f6 01       	movw	r30, r12
    46ce:	b0 82       	st	Z, r11
    46d0:	c8 01       	movw	r24, r16
    46d2:	01 97       	sbiw	r24, 0x01	; 1
    46d4:	f1 f7       	brne	.-4      	; 0x46d2 <WriteRTC+0x7e>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	StopTWI();
    46d6:	c8 01       	movw	r24, r16
    46d8:	01 97       	sbiw	r24, 0x01	; 1
    46da:	f1 f7       	brne	.-4      	; 0x46d8 <WriteRTC+0x84>
    46dc:	84 e9       	ldi	r24, 0x94	; 148
    46de:	80 83       	st	Z, r24
	TWI_Phase = PCF_START;
    46e0:	10 92 7d 07 	sts	0x077D, r1
}
    46e4:	1f 91       	pop	r17
    46e6:	0f 91       	pop	r16
    46e8:	ff 90       	pop	r15
    46ea:	ef 90       	pop	r14
    46ec:	df 90       	pop	r13
    46ee:	cf 90       	pop	r12
    46f0:	bf 90       	pop	r11
    46f2:	08 95       	ret

000046f4 <SetWeekday>:
*/

// ~~~~~~~~~~~~~~~
// 31.12.00 was Su
uint8_t SetWeekday(uint8_t Year, uint8_t Month, uint8_t MDay)
{
    46f4:	a6 2f       	mov	r26, r22
	uint8_t DayCount;
	uint8_t LastYear = Year-1;
    46f6:	b8 2f       	mov	r27, r24
    46f8:	b1 50       	subi	r27, 0x01	; 1

	DayCount = (LastYear+LastYear/4);
    46fa:	5b 2f       	mov	r21, r27
    46fc:	56 95       	lsr	r21
    46fe:	56 95       	lsr	r21
    4700:	5b 0f       	add	r21, r27
	for (uint8_t i=1; i<Month; DayCount+=prb(DaysMonth+i++)%7);
    4702:	62 30       	cpi	r22, 0x02	; 2
    4704:	88 f0       	brcs	.+34     	; 0x4728 <SetWeekday+0x34>
    4706:	e4 e2       	ldi	r30, 0x24	; 36
    4708:	f3 e0       	ldi	r31, 0x03	; 3
    470a:	a2 50       	subi	r26, 0x02	; 2
    470c:	2a 2f       	mov	r18, r26
    470e:	30 e0       	ldi	r19, 0x00	; 0
    4710:	ae 5f       	subi	r26, 0xFE	; 254
    4712:	2b 5d       	subi	r18, 0xDB	; 219
    4714:	3c 4f       	sbci	r19, 0xFC	; 252

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    4716:	84 91       	lpm	r24, Z+
    4718:	67 e0       	ldi	r22, 0x07	; 7
    471a:	0e 94 36 82 	call	0x1046c	; 0x1046c <__udivmodqi4>
    471e:	59 0f       	add	r21, r25
    4720:	31 96       	adiw	r30, 0x01	; 1
    4722:	e2 17       	cp	r30, r18
    4724:	f3 07       	cpc	r31, r19
    4726:	b9 f7       	brne	.-18     	; 0x4716 <SetWeekday+0x22>
    4728:	25 2f       	mov	r18, r21
	if (LastYear%4==3 && Month>2)
    472a:	b3 70       	andi	r27, 0x03	; 3
    472c:	b3 30       	cpi	r27, 0x03	; 3
    472e:	51 f0       	breq	.+20     	; 0x4744 <SetWeekday+0x50>
		DayCount++;
    4730:	84 2f       	mov	r24, r20
    4732:	67 e0       	ldi	r22, 0x07	; 7
    4734:	0e 94 36 82 	call	0x1046c	; 0x1046c <__udivmodqi4>
    4738:	82 2f       	mov	r24, r18
    473a:	89 0f       	add	r24, r25
    473c:	0e 94 36 82 	call	0x1046c	; 0x1046c <__udivmodqi4>
	DayCount += MDay%7;
	return DayCount%7;
}
    4740:	89 2f       	mov	r24, r25
    4742:	08 95       	ret
	uint8_t DayCount;
	uint8_t LastYear = Year-1;

	DayCount = (LastYear+LastYear/4);
	for (uint8_t i=1; i<Month; DayCount+=prb(DaysMonth+i++)%7);
	if (LastYear%4==3 && Month>2)
    4744:	a3 30       	cpi	r26, 0x03	; 3
    4746:	a0 f3       	brcs	.-24     	; 0x4730 <SetWeekday+0x3c>
		DayCount++;
    4748:	2f 5f       	subi	r18, 0xFF	; 255
    474a:	f2 cf       	rjmp	.-28     	; 0x4730 <SetWeekday+0x3c>

0000474c <SetSec>:
}
// ~~~~~~~~~
void
SetSec(void)
{
	WriteRTC(0, Tm_Sec);
    474c:	80 e0       	ldi	r24, 0x00	; 0
    474e:	60 91 b4 06 	lds	r22, 0x06B4
    4752:	0e 94 2a 23 	call	0x4654	; 0x4654 <WriteRTC>
	TrueTime_Sec = Tm_Sec;
    4756:	80 91 b4 06 	lds	r24, 0x06B4
    475a:	80 93 cc 08 	sts	0x08CC, r24
}
    475e:	08 95       	ret

00004760 <SetMin>:

// ~~~~~~~~~
void
SetMin(void)
{
	WriteRTC(1, Tm_Min);
    4760:	81 e0       	ldi	r24, 0x01	; 1
    4762:	60 91 4f 06 	lds	r22, 0x064F
    4766:	0e 94 2a 23 	call	0x4654	; 0x4654 <WriteRTC>
	TrueTime_Min = Tm_Min;
    476a:	80 91 4f 06 	lds	r24, 0x064F
    476e:	80 93 ce 08 	sts	0x08CE, r24
}
    4772:	08 95       	ret

00004774 <SetHour>:

// ~~~~~~~~~~
void
SetHour(void)
{
	WriteRTC(2,  Tm_Hour);
    4774:	82 e0       	ldi	r24, 0x02	; 2
    4776:	60 91 bf 05 	lds	r22, 0x05BF
    477a:	0e 94 2a 23 	call	0x4654	; 0x4654 <WriteRTC>
	TrueTime_Hour = Tm_Hour;
    477e:	80 91 bf 05 	lds	r24, 0x05BF
    4782:	80 93 d6 05 	sts	0x05D6, r24
}
    4786:	08 95       	ret

00004788 <SetMDay>:
// ~~~~~~~~~~
void
SetMDay(void)
{
	WriteRTC(4,  Tm_MDay);
    4788:	84 e0       	ldi	r24, 0x04	; 4
    478a:	60 91 17 0b 	lds	r22, 0x0B17
    478e:	0e 94 2a 23 	call	0x4654	; 0x4654 <WriteRTC>
	TrueTime_MDay = Tm_MDay;
    4792:	80 91 17 0b 	lds	r24, 0x0B17
    4796:	80 93 54 06 	sts	0x0654, r24
}
    479a:	08 95       	ret

0000479c <SetMon>:
// ~~~~~~~~~
void
SetMon(void)
{
	WriteRTC(5, Tm_Mon);
    479c:	85 e0       	ldi	r24, 0x05	; 5
    479e:	60 91 85 07 	lds	r22, 0x0785
    47a2:	0e 94 2a 23 	call	0x4654	; 0x4654 <WriteRTC>
	TrueTime_Mon = Tm_Mon;
    47a6:	80 91 85 07 	lds	r24, 0x0785
    47aa:	80 93 cd 08 	sts	0x08CD, r24
}
    47ae:	08 95       	ret

000047b0 <SetYear>:
// ~~~~~~~~~~~~~
void
SetYear(void)
{
	WriteRTC(6, Tm_Year);
    47b0:	86 e0       	ldi	r24, 0x06	; 6
    47b2:	60 91 dc 05 	lds	r22, 0x05DC
    47b6:	0e 94 2a 23 	call	0x4654	; 0x4654 <WriteRTC>
	TrueTime_Year = Tm_Year;
    47ba:	80 91 dc 05 	lds	r24, 0x05DC
    47be:	80 93 7b 07 	sts	0x077B, r24
}
    47c2:	08 95       	ret

000047c4 <SetDateTime>:
// ~~~~~~~~~~~~~
void
SetDateTime(uint8_t Year, uint8_t Month, uint8_t Day, uint8_t WDay, uint8_t Hour, uint8_t Min, uint8_t Sec){
    47c4:	5f 92       	push	r5
    47c6:	6f 92       	push	r6
    47c8:	7f 92       	push	r7
    47ca:	8f 92       	push	r8
    47cc:	9f 92       	push	r9
    47ce:	af 92       	push	r10
    47d0:	bf 92       	push	r11
    47d2:	cf 92       	push	r12
    47d4:	df 92       	push	r13
    47d6:	ef 92       	push	r14
    47d8:	ff 92       	push	r15
    47da:	0f 93       	push	r16
    47dc:	1f 93       	push	r17
    47de:	58 2e       	mov	r5, r24
    47e0:	66 2e       	mov	r6, r22
    47e2:	74 2e       	mov	r7, r20
    47e4:	f2 2e       	mov	r15, r18
    47e6:	8c 2d       	mov	r24, r12
	PowerOffTWI();
    47e8:	7c eb       	ldi	r23, 0xBC	; 188
    47ea:	87 2e       	mov	r8, r23
    47ec:	91 2c       	mov	r9, r1
    47ee:	f4 01       	movw	r30, r8
    47f0:	10 82       	st	Z, r1
    47f2:	e0 e9       	ldi	r30, 0x90	; 144
    47f4:	f1 e0       	ldi	r31, 0x01	; 1
    47f6:	31 97       	sbiw	r30, 0x01	; 1
    47f8:	f1 f7       	brne	.-4      	; 0x47f6 <SetDateTime+0x32>
	_delay_us(100);
	//_delay_us(150);_delay_us(150);
	StartTWI();
    47fa:	94 ea       	ldi	r25, 0xA4	; 164
    47fc:	f4 01       	movw	r30, r8
    47fe:	90 83       	st	Z, r25
    4800:	68 e5       	ldi	r22, 0x58	; 88
    4802:	c6 2e       	mov	r12, r22
    4804:	62 e0       	ldi	r22, 0x02	; 2
    4806:	d6 2e       	mov	r13, r22
    4808:	f6 01       	movw	r30, r12
    480a:	31 97       	sbiw	r30, 0x01	; 1
    480c:	f1 f7       	brne	.-4      	; 0x480a <SetDateTime+0x46>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = SLA_W(PCF_SLA);
    480e:	f6 01       	movw	r30, r12
    4810:	31 97       	sbiw	r30, 0x01	; 1
    4812:	f1 f7       	brne	.-4      	; 0x4810 <SetDateTime+0x4c>
    4814:	5b eb       	ldi	r21, 0xBB	; 187
    4816:	a5 2e       	mov	r10, r21
    4818:	b1 2c       	mov	r11, r1
    481a:	90 ed       	ldi	r25, 0xD0	; 208
    481c:	f5 01       	movw	r30, r10
    481e:	90 83       	st	Z, r25
    4820:	90 81       	ld	r25, Z
    4822:	90 83       	st	Z, r25
	RunTWI();
    4824:	14 e8       	ldi	r17, 0x84	; 132
    4826:	f4 01       	movw	r30, r8
    4828:	10 83       	st	Z, r17
    482a:	f6 01       	movw	r30, r12
    482c:	31 97       	sbiw	r30, 0x01	; 1
    482e:	f1 f7       	brne	.-4      	; 0x482c <SetDateTime+0x68>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = AddrSec;
    4830:	f6 01       	movw	r30, r12
    4832:	31 97       	sbiw	r30, 0x01	; 1
    4834:	f1 f7       	brne	.-4      	; 0x4832 <SetDateTime+0x6e>
    4836:	f5 01       	movw	r30, r10
    4838:	10 82       	st	Z, r1
	RunTWI();
    483a:	f4 01       	movw	r30, r8
    483c:	10 83       	st	Z, r17
    483e:	f6 01       	movw	r30, r12
    4840:	31 97       	sbiw	r30, 0x01	; 1
    4842:	f1 f7       	brne	.-4      	; 0x4840 <SetDateTime+0x7c>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = CodBCD(Sec);
    4844:	f6 01       	movw	r30, r12
    4846:	31 97       	sbiw	r30, 0x01	; 1
    4848:	f1 f7       	brne	.-4      	; 0x4846 <SetDateTime+0x82>
    484a:	0e 94 de 20 	call	0x41bc	; 0x41bc <CodBCD>
    484e:	f5 01       	movw	r30, r10
    4850:	80 83       	st	Z, r24
	RunTWI();
    4852:	f4 01       	movw	r30, r8
    4854:	10 83       	st	Z, r17
    4856:	c6 01       	movw	r24, r12
    4858:	01 97       	sbiw	r24, 0x01	; 1
    485a:	f1 f7       	brne	.-4      	; 0x4858 <SetDateTime+0x94>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = CodBCD(Min);
    485c:	c6 01       	movw	r24, r12
    485e:	01 97       	sbiw	r24, 0x01	; 1
    4860:	f1 f7       	brne	.-4      	; 0x485e <SetDateTime+0x9a>
    4862:	8e 2d       	mov	r24, r14
    4864:	0e 94 de 20 	call	0x41bc	; 0x41bc <CodBCD>
    4868:	f5 01       	movw	r30, r10
    486a:	80 83       	st	Z, r24
	RunTWI();
    486c:	f4 01       	movw	r30, r8
    486e:	10 83       	st	Z, r17
    4870:	c6 01       	movw	r24, r12
    4872:	01 97       	sbiw	r24, 0x01	; 1
    4874:	f1 f7       	brne	.-4      	; 0x4872 <SetDateTime+0xae>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = CodBCD(Hour);
    4876:	c6 01       	movw	r24, r12
    4878:	01 97       	sbiw	r24, 0x01	; 1
    487a:	f1 f7       	brne	.-4      	; 0x4878 <SetDateTime+0xb4>
    487c:	80 2f       	mov	r24, r16
    487e:	0e 94 de 20 	call	0x41bc	; 0x41bc <CodBCD>
    4882:	f5 01       	movw	r30, r10
    4884:	80 83       	st	Z, r24
	RunTWI();
    4886:	f4 01       	movw	r30, r8
    4888:	10 83       	st	Z, r17
    488a:	c6 01       	movw	r24, r12
    488c:	01 97       	sbiw	r24, 0x01	; 1
    488e:	f1 f7       	brne	.-4      	; 0x488c <SetDateTime+0xc8>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = WDay;
    4890:	c6 01       	movw	r24, r12
    4892:	01 97       	sbiw	r24, 0x01	; 1
    4894:	f1 f7       	brne	.-4      	; 0x4892 <SetDateTime+0xce>
    4896:	f5 01       	movw	r30, r10
    4898:	f0 82       	st	Z, r15
	RunTWI();
    489a:	f4 01       	movw	r30, r8
    489c:	10 83       	st	Z, r17
    489e:	c6 01       	movw	r24, r12
    48a0:	01 97       	sbiw	r24, 0x01	; 1
    48a2:	f1 f7       	brne	.-4      	; 0x48a0 <SetDateTime+0xdc>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = CodBCD(Day);
    48a4:	c6 01       	movw	r24, r12
    48a6:	01 97       	sbiw	r24, 0x01	; 1
    48a8:	f1 f7       	brne	.-4      	; 0x48a6 <SetDateTime+0xe2>
    48aa:	87 2d       	mov	r24, r7
    48ac:	0e 94 de 20 	call	0x41bc	; 0x41bc <CodBCD>
    48b0:	f5 01       	movw	r30, r10
    48b2:	80 83       	st	Z, r24
	RunTWI();
    48b4:	f4 01       	movw	r30, r8
    48b6:	10 83       	st	Z, r17
    48b8:	c6 01       	movw	r24, r12
    48ba:	01 97       	sbiw	r24, 0x01	; 1
    48bc:	f1 f7       	brne	.-4      	; 0x48ba <SetDateTime+0xf6>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = CodBCD(Month);
    48be:	c6 01       	movw	r24, r12
    48c0:	01 97       	sbiw	r24, 0x01	; 1
    48c2:	f1 f7       	brne	.-4      	; 0x48c0 <SetDateTime+0xfc>
    48c4:	86 2d       	mov	r24, r6
    48c6:	0e 94 de 20 	call	0x41bc	; 0x41bc <CodBCD>
    48ca:	f5 01       	movw	r30, r10
    48cc:	80 83       	st	Z, r24
	RunTWI();
    48ce:	f4 01       	movw	r30, r8
    48d0:	10 83       	st	Z, r17
    48d2:	c6 01       	movw	r24, r12
    48d4:	01 97       	sbiw	r24, 0x01	; 1
    48d6:	f1 f7       	brne	.-4      	; 0x48d4 <SetDateTime+0x110>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	TWDR = CodBCD(Year);
    48d8:	c6 01       	movw	r24, r12
    48da:	01 97       	sbiw	r24, 0x01	; 1
    48dc:	f1 f7       	brne	.-4      	; 0x48da <SetDateTime+0x116>
    48de:	85 2d       	mov	r24, r5
    48e0:	0e 94 de 20 	call	0x41bc	; 0x41bc <CodBCD>
    48e4:	f5 01       	movw	r30, r10
    48e6:	80 83       	st	Z, r24
	RunTWI();
    48e8:	f4 01       	movw	r30, r8
    48ea:	10 83       	st	Z, r17
    48ec:	c6 01       	movw	r24, r12
    48ee:	01 97       	sbiw	r24, 0x01	; 1
    48f0:	f1 f7       	brne	.-4      	; 0x48ee <SetDateTime+0x12a>
	//WaitTWI();
	_delay_us(150);_delay_us(150);
	StopTWI();
    48f2:	c6 01       	movw	r24, r12
    48f4:	01 97       	sbiw	r24, 0x01	; 1
    48f6:	f1 f7       	brne	.-4      	; 0x48f4 <SetDateTime+0x130>
    48f8:	84 e9       	ldi	r24, 0x94	; 148
    48fa:	80 83       	st	Z, r24
	TWI_Phase = PCF_START;
    48fc:	10 92 7d 07 	sts	0x077D, r1
}
    4900:	1f 91       	pop	r17
    4902:	0f 91       	pop	r16
    4904:	ff 90       	pop	r15
    4906:	ef 90       	pop	r14
    4908:	df 90       	pop	r13
    490a:	cf 90       	pop	r12
    490c:	bf 90       	pop	r11
    490e:	af 90       	pop	r10
    4910:	9f 90       	pop	r9
    4912:	8f 90       	pop	r8
    4914:	7f 90       	pop	r7
    4916:	6f 90       	pop	r6
    4918:	5f 90       	pop	r5
    491a:	08 95       	ret

0000491c <RTC_Ready>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t RTC_Ready(void){
    491c:	90 e0       	ldi	r25, 0x00	; 0
    491e:	80 91 7d 07 	lds	r24, 0x077D
    4922:	88 23       	and	r24, r24
    4924:	09 f4       	brne	.+2      	; 0x4928 <RTC_Ready+0xc>
    4926:	91 e0       	ldi	r25, 0x01	; 1
	if(TWI_Phase == PCF_START) return 1;
	else return 0;
}
    4928:	89 2f       	mov	r24, r25
    492a:	08 95       	ret

0000492c <RTC_GetTrueTime>:
void RTC_GetTrueTime(void){
	TrueTime_Sec = Tm_Sec;
    492c:	80 91 b4 06 	lds	r24, 0x06B4
    4930:	80 93 cc 08 	sts	0x08CC, r24
	TrueTime_Min = Tm_Min;
    4934:	80 91 4f 06 	lds	r24, 0x064F
    4938:	80 93 ce 08 	sts	0x08CE, r24
	TrueTime_Hour = Tm_Hour;
    493c:	80 91 bf 05 	lds	r24, 0x05BF
    4940:	80 93 d6 05 	sts	0x05D6, r24
	TrueTime_MDay = Tm_MDay;
    4944:	40 91 17 0b 	lds	r20, 0x0B17
    4948:	40 93 54 06 	sts	0x0654, r20
	TrueTime_Mon = Tm_Mon;
    494c:	60 91 85 07 	lds	r22, 0x0785
    4950:	60 93 cd 08 	sts	0x08CD, r22
	TrueTime_Year = Tm_Year;
    4954:	80 91 dc 05 	lds	r24, 0x05DC
    4958:	80 93 7b 07 	sts	0x077B, r24
	TrueTime_WDay = SetWeekday(TrueTime_Year, TrueTime_Mon, TrueTime_MDay);
    495c:	0e 94 7a 23 	call	0x46f4	; 0x46f4 <SetWeekday>
    4960:	80 93 16 0b 	sts	0x0B16, r24
}
    4964:	08 95       	ret

00004966 <RTC_SetTrueTime>:
void RTC_SetTrueTime(uint8_t Year, uint8_t Month, uint8_t Day, uint8_t WDay, uint8_t Hour, uint8_t Min, uint8_t Sec){
    4966:	8f 92       	push	r8
    4968:	9f 92       	push	r9
    496a:	af 92       	push	r10
    496c:	bf 92       	push	r11
    496e:	cf 92       	push	r12
    4970:	df 92       	push	r13
    4972:	ef 92       	push	r14
    4974:	ff 92       	push	r15
    4976:	0f 93       	push	r16
    4978:	1f 93       	push	r17
    497a:	88 2e       	mov	r8, r24
    497c:	a6 2e       	mov	r10, r22
    497e:	b4 2e       	mov	r11, r20
    4980:	92 2e       	mov	r9, r18
    4982:	d0 2e       	mov	r13, r16
    4984:	fe 2c       	mov	r15, r14
    4986:	1c 2d       	mov	r17, r12
	SetDateTime(Year, Month, Day, WDay, Hour, Min, Sec);
    4988:	0e 94 e2 23 	call	0x47c4	; 0x47c4 <SetDateTime>
	TrueTime_Sec = Sec;
    498c:	10 93 cc 08 	sts	0x08CC, r17
	TrueTime_Min = Min;
    4990:	f0 92 ce 08 	sts	0x08CE, r15
	TrueTime_Hour = Hour;
    4994:	d0 92 d6 05 	sts	0x05D6, r13
	TrueTime_MDay = Day;
    4998:	b0 92 54 06 	sts	0x0654, r11
	TrueTime_Mon = Month;
    499c:	a0 92 cd 08 	sts	0x08CD, r10
	TrueTime_Year = Year;
    49a0:	80 92 7b 07 	sts	0x077B, r8
	TrueTime_WDay = WDay;
    49a4:	90 92 16 0b 	sts	0x0B16, r9
}
    49a8:	1f 91       	pop	r17
    49aa:	0f 91       	pop	r16
    49ac:	ff 90       	pop	r15
    49ae:	ef 90       	pop	r14
    49b0:	df 90       	pop	r13
    49b2:	cf 90       	pop	r12
    49b4:	bf 90       	pop	r11
    49b6:	af 90       	pop	r10
    49b8:	9f 90       	pop	r9
    49ba:	8f 90       	pop	r8
    49bc:	08 95       	ret

000049be <RTC_Check>:

//  3 

uint8_t RTC_Check(void){

	if( (Tm_Year == TrueTime_Year)  && (Tm_Mon == TrueTime_Mon) && (Tm_MDay == TrueTime_MDay) &&
    49be:	50 91 dc 05 	lds	r21, 0x05DC
    49c2:	40 91 7b 07 	lds	r20, 0x077B
    49c6:	54 17       	cp	r21, r20
    49c8:	59 f1       	breq	.+86     	; 0x4a20 <RTC_Check+0x62>
    49ca:	90 91 cc 08 	lds	r25, 0x08CC
			(Tm_Hour == TrueTime_Hour) && (Tm_Min == TrueTime_Min) && (Tm_Sec == TrueTime_Sec) ) return 1;

	if(TrueTime_Sec>55){
    49ce:	98 33       	cpi	r25, 0x38	; 56
    49d0:	58 f0       	brcs	.+22     	; 0x49e8 <RTC_Check+0x2a>
		if(TrueTime_Min == 59){
    49d2:	80 91 ce 08 	lds	r24, 0x08CE
    49d6:	8b 33       	cpi	r24, 0x3B	; 59
    49d8:	09 f4       	brne	.+2      	; 0x49dc <RTC_Check+0x1e>
    49da:	5a c0       	rjmp	.+180    	; 0x4a90 <RTC_Check+0xd2>
			else{
				if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ) return 1;
			}
		}
		else{
			if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ||
    49dc:	54 17       	cp	r21, r20
    49de:	09 f4       	brne	.+2      	; 0x49e2 <RTC_Check+0x24>
    49e0:	40 c0       	rjmp	.+128    	; 0x4a62 <RTC_Check+0xa4>
				(Tm_Hour != TrueTime_Hour) ) return 1;		
		}
	}
	else{
		if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ||
    49e2:	21 e0       	ldi	r18, 0x01	; 1
			(Tm_Hour != TrueTime_Hour) || (Tm_Min != TrueTime_Min) ) return 1;
	}
	
	return 0;
}
    49e4:	82 2f       	mov	r24, r18
    49e6:	08 95       	ret
			if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ||
				(Tm_Hour != TrueTime_Hour) ) return 1;		
		}
	}
	else{
		if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ||
    49e8:	54 17       	cp	r21, r20
    49ea:	d9 f7       	brne	.-10     	; 0x49e2 <RTC_Check+0x24>
    49ec:	90 91 85 07 	lds	r25, 0x0785
    49f0:	80 91 cd 08 	lds	r24, 0x08CD
    49f4:	98 17       	cp	r25, r24
    49f6:	a9 f7       	brne	.-22     	; 0x49e2 <RTC_Check+0x24>
    49f8:	90 91 17 0b 	lds	r25, 0x0B17
    49fc:	80 91 54 06 	lds	r24, 0x0654
    4a00:	98 17       	cp	r25, r24
    4a02:	79 f7       	brne	.-34     	; 0x49e2 <RTC_Check+0x24>
    4a04:	90 91 bf 05 	lds	r25, 0x05BF
    4a08:	80 91 d6 05 	lds	r24, 0x05D6
    4a0c:	98 17       	cp	r25, r24
    4a0e:	49 f7       	brne	.-46     	; 0x49e2 <RTC_Check+0x24>
    4a10:	20 e0       	ldi	r18, 0x00	; 0
    4a12:	90 91 4f 06 	lds	r25, 0x064F
    4a16:	80 91 ce 08 	lds	r24, 0x08CE
    4a1a:	98 17       	cp	r25, r24
    4a1c:	11 f7       	brne	.-60     	; 0x49e2 <RTC_Check+0x24>
    4a1e:	e2 cf       	rjmp	.-60     	; 0x49e4 <RTC_Check+0x26>

//  3 

uint8_t RTC_Check(void){

	if( (Tm_Year == TrueTime_Year)  && (Tm_Mon == TrueTime_Mon) && (Tm_MDay == TrueTime_MDay) &&
    4a20:	90 91 85 07 	lds	r25, 0x0785
    4a24:	80 91 cd 08 	lds	r24, 0x08CD
    4a28:	98 17       	cp	r25, r24
    4a2a:	79 f6       	brne	.-98     	; 0x49ca <RTC_Check+0xc>
    4a2c:	90 91 17 0b 	lds	r25, 0x0B17
    4a30:	80 91 54 06 	lds	r24, 0x0654
    4a34:	98 17       	cp	r25, r24
    4a36:	49 f6       	brne	.-110    	; 0x49ca <RTC_Check+0xc>
    4a38:	90 91 bf 05 	lds	r25, 0x05BF
    4a3c:	80 91 d6 05 	lds	r24, 0x05D6
    4a40:	98 17       	cp	r25, r24
    4a42:	19 f6       	brne	.-122    	; 0x49ca <RTC_Check+0xc>
    4a44:	90 91 4f 06 	lds	r25, 0x064F
    4a48:	80 91 ce 08 	lds	r24, 0x08CE
    4a4c:	98 17       	cp	r25, r24
    4a4e:	09 f0       	breq	.+2      	; 0x4a52 <RTC_Check+0x94>
    4a50:	bc cf       	rjmp	.-136    	; 0x49ca <RTC_Check+0xc>
    4a52:	80 91 b4 06 	lds	r24, 0x06B4
    4a56:	90 91 cc 08 	lds	r25, 0x08CC
    4a5a:	89 17       	cp	r24, r25
    4a5c:	09 f0       	breq	.+2      	; 0x4a60 <RTC_Check+0xa2>
    4a5e:	b7 cf       	rjmp	.-146    	; 0x49ce <RTC_Check+0x10>
    4a60:	c0 cf       	rjmp	.-128    	; 0x49e2 <RTC_Check+0x24>
			else{
				if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ) return 1;
			}
		}
		else{
			if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ||
    4a62:	90 91 85 07 	lds	r25, 0x0785
    4a66:	80 91 cd 08 	lds	r24, 0x08CD
    4a6a:	98 17       	cp	r25, r24
    4a6c:	09 f0       	breq	.+2      	; 0x4a70 <RTC_Check+0xb2>
    4a6e:	b9 cf       	rjmp	.-142    	; 0x49e2 <RTC_Check+0x24>
    4a70:	90 91 17 0b 	lds	r25, 0x0B17
    4a74:	80 91 54 06 	lds	r24, 0x0654
    4a78:	98 17       	cp	r25, r24
    4a7a:	09 f0       	breq	.+2      	; 0x4a7e <RTC_Check+0xc0>
    4a7c:	b2 cf       	rjmp	.-156    	; 0x49e2 <RTC_Check+0x24>
    4a7e:	20 e0       	ldi	r18, 0x00	; 0
    4a80:	90 91 bf 05 	lds	r25, 0x05BF
    4a84:	80 91 d6 05 	lds	r24, 0x05D6
    4a88:	98 17       	cp	r25, r24
    4a8a:	09 f0       	breq	.+2      	; 0x4a8e <RTC_Check+0xd0>
    4a8c:	aa cf       	rjmp	.-172    	; 0x49e2 <RTC_Check+0x24>
    4a8e:	aa cf       	rjmp	.-172    	; 0x49e4 <RTC_Check+0x26>
	if( (Tm_Year == TrueTime_Year)  && (Tm_Mon == TrueTime_Mon) && (Tm_MDay == TrueTime_MDay) &&
			(Tm_Hour == TrueTime_Hour) && (Tm_Min == TrueTime_Min) && (Tm_Sec == TrueTime_Sec) ) return 1;

	if(TrueTime_Sec>55){
		if(TrueTime_Min == 59){
			if(TrueTime_Hour == 23){
    4a90:	80 91 d6 05 	lds	r24, 0x05D6
    4a94:	87 31       	cpi	r24, 0x17	; 23
    4a96:	99 f0       	breq	.+38     	; 0x4abe <RTC_Check+0x100>
				else{
					if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) ) return 1;
				}
			}
			else{
				if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ) return 1;
    4a98:	54 17       	cp	r21, r20
    4a9a:	09 f0       	breq	.+2      	; 0x4a9e <RTC_Check+0xe0>
    4a9c:	a2 cf       	rjmp	.-188    	; 0x49e2 <RTC_Check+0x24>
    4a9e:	90 91 85 07 	lds	r25, 0x0785
    4aa2:	80 91 cd 08 	lds	r24, 0x08CD
    4aa6:	98 17       	cp	r25, r24
    4aa8:	09 f0       	breq	.+2      	; 0x4aac <RTC_Check+0xee>
    4aaa:	9b cf       	rjmp	.-202    	; 0x49e2 <RTC_Check+0x24>
    4aac:	20 e0       	ldi	r18, 0x00	; 0
    4aae:	90 91 17 0b 	lds	r25, 0x0B17
    4ab2:	80 91 54 06 	lds	r24, 0x0654
    4ab6:	98 17       	cp	r25, r24
    4ab8:	09 f0       	breq	.+2      	; 0x4abc <RTC_Check+0xfe>
    4aba:	93 cf       	rjmp	.-218    	; 0x49e2 <RTC_Check+0x24>
    4abc:	93 cf       	rjmp	.-218    	; 0x49e4 <RTC_Check+0x26>
			(Tm_Hour == TrueTime_Hour) && (Tm_Min == TrueTime_Min) && (Tm_Sec == TrueTime_Sec) ) return 1;

	if(TrueTime_Sec>55){
		if(TrueTime_Min == 59){
			if(TrueTime_Hour == 23){
				if(TrueTime_MDay >= 28){
    4abe:	80 91 54 06 	lds	r24, 0x0654
    4ac2:	8c 31       	cpi	r24, 0x1C	; 28
    4ac4:	48 f0       	brcs	.+18     	; 0x4ad8 <RTC_Check+0x11a>
					if(TrueTime_Mon == 12){
    4ac6:	80 91 cd 08 	lds	r24, 0x08CD
    4aca:	8c 30       	cpi	r24, 0x0C	; 12
    4acc:	89 f0       	breq	.+34     	; 0x4af0 <RTC_Check+0x132>
						if( ((TrueTime_Year+1) == Tm_Year) || (TrueTime_Year==Tm_Year) || ((TrueTime_Year==99) && (Tm_Year==0)) ) return 0;
    4ace:	20 e0       	ldi	r18, 0x00	; 0
    4ad0:	54 17       	cp	r21, r20
    4ad2:	09 f0       	breq	.+2      	; 0x4ad6 <RTC_Check+0x118>
    4ad4:	86 cf       	rjmp	.-244    	; 0x49e2 <RTC_Check+0x24>
    4ad6:	86 cf       	rjmp	.-244    	; 0x49e4 <RTC_Check+0x26>
					else{
						if(Tm_Year!= TrueTime_Year) return 1;
					}
				}
				else{
					if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) ) return 1;
    4ad8:	54 17       	cp	r21, r20
    4ada:	09 f0       	breq	.+2      	; 0x4ade <RTC_Check+0x120>
    4adc:	82 cf       	rjmp	.-252    	; 0x49e2 <RTC_Check+0x24>
    4ade:	20 e0       	ldi	r18, 0x00	; 0
    4ae0:	90 91 85 07 	lds	r25, 0x0785
    4ae4:	80 91 cd 08 	lds	r24, 0x08CD
    4ae8:	98 17       	cp	r25, r24
    4aea:	09 f0       	breq	.+2      	; 0x4aee <RTC_Check+0x130>
    4aec:	7a cf       	rjmp	.-268    	; 0x49e2 <RTC_Check+0x24>
    4aee:	7a cf       	rjmp	.-268    	; 0x49e4 <RTC_Check+0x26>
	if(TrueTime_Sec>55){
		if(TrueTime_Min == 59){
			if(TrueTime_Hour == 23){
				if(TrueTime_MDay >= 28){
					if(TrueTime_Mon == 12){
						if( ((TrueTime_Year+1) == Tm_Year) || (TrueTime_Year==Tm_Year) || ((TrueTime_Year==99) && (Tm_Year==0)) ) return 0;
    4af0:	84 2f       	mov	r24, r20
    4af2:	90 e0       	ldi	r25, 0x00	; 0
    4af4:	01 96       	adiw	r24, 0x01	; 1
    4af6:	25 2f       	mov	r18, r21
    4af8:	30 e0       	ldi	r19, 0x00	; 0
    4afa:	82 17       	cp	r24, r18
    4afc:	93 07       	cpc	r25, r19
    4afe:	61 f0       	breq	.+24     	; 0x4b18 <RTC_Check+0x15a>
    4b00:	54 17       	cp	r21, r20
    4b02:	51 f0       	breq	.+20     	; 0x4b18 <RTC_Check+0x15a>
    4b04:	43 36       	cpi	r20, 0x63	; 99
    4b06:	09 f0       	breq	.+2      	; 0x4b0a <RTC_Check+0x14c>
    4b08:	6c cf       	rjmp	.-296    	; 0x49e2 <RTC_Check+0x24>
    4b0a:	20 e0       	ldi	r18, 0x00	; 0
    4b0c:	55 23       	and	r21, r21
    4b0e:	09 f4       	brne	.+2      	; 0x4b12 <RTC_Check+0x154>
    4b10:	21 e0       	ldi	r18, 0x01	; 1
    4b12:	81 e0       	ldi	r24, 0x01	; 1
    4b14:	28 27       	eor	r18, r24
    4b16:	66 cf       	rjmp	.-308    	; 0x49e4 <RTC_Check+0x26>
			if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ||
				(Tm_Hour != TrueTime_Hour) ) return 1;		
		}
	}
	else{
		if( (Tm_Year!= TrueTime_Year)  || (Tm_Mon != TrueTime_Mon) || (Tm_MDay != TrueTime_MDay) ||
    4b18:	20 e0       	ldi	r18, 0x00	; 0
    4b1a:	64 cf       	rjmp	.-312    	; 0x49e4 <RTC_Check+0x26>

00004b1c <GSM_PWRCNTRL_Config>:
#endif

//  gsm_sim900r.h   PWRCNTRL
#ifdef vmd2_3
	void GSM_PWRCNTRL_Config(void){
		cli();
    4b1c:	f8 94       	cli
		DDRL|=(1<<PL5);
    4b1e:	ea e0       	ldi	r30, 0x0A	; 10
    4b20:	f1 e0       	ldi	r31, 0x01	; 1
    4b22:	80 81       	ld	r24, Z
    4b24:	80 62       	ori	r24, 0x20	; 32
    4b26:	80 83       	st	Z, r24
		sei();
    4b28:	78 94       	sei
	}
    4b2a:	08 95       	ret

00004b2c <GSM_PWRCNTRL_OFF>:
	void GSM_PWRCNTRL_OFF(void){
		cli();
    4b2c:	f8 94       	cli
		PORTL|=(1<<PL5);
    4b2e:	eb e0       	ldi	r30, 0x0B	; 11
    4b30:	f1 e0       	ldi	r31, 0x01	; 1
    4b32:	80 81       	ld	r24, Z
    4b34:	80 62       	ori	r24, 0x20	; 32
    4b36:	80 83       	st	Z, r24
		sei();
    4b38:	78 94       	sei
	}
    4b3a:	08 95       	ret

00004b3c <GSM_PWRCNTRL_ON>:
	void GSM_PWRCNTRL_ON(void){
		cli();
    4b3c:	f8 94       	cli
		PORTL &= ~(1<<PL5);
    4b3e:	eb e0       	ldi	r30, 0x0B	; 11
    4b40:	f1 e0       	ldi	r31, 0x01	; 1
    4b42:	80 81       	ld	r24, Z
    4b44:	8f 7d       	andi	r24, 0xDF	; 223
    4b46:	80 83       	st	Z, r24
		sei();
    4b48:	78 94       	sei
	}
    4b4a:	08 95       	ret

00004b4c <GSM_CTS_RTS_Config>:

	void GSM_CTS_RTS_Config(void){
		cli();
    4b4c:	f8 94       	cli
		//TS
		DDRB &=~(1<<PB6);
    4b4e:	26 98       	cbi	0x04, 6	; 4
		PORTB |=(1<<PB6);	//pull'up
    4b50:	2e 9a       	sbi	0x05, 6	; 5
		//RTS
		DDRG |= (1<<PG5);
    4b52:	9d 9a       	sbi	0x13, 5	; 19
		PORTG &= ~(1<<PG5);
    4b54:	a5 98       	cbi	0x14, 5	; 20
		sei();
    4b56:	78 94       	sei
	}
    4b58:	08 95       	ret

00004b5a <GSM_CTS_State>:
	uint8_t GSM_CTS_State(void){
		return PINB & (1<<PB6);
    4b5a:	83 b1       	in	r24, 0x03	; 3
	}
    4b5c:	80 74       	andi	r24, 0x40	; 64
    4b5e:	08 95       	ret

00004b60 <GSM_RTS_OFF>:
	void GSM_RTS_OFF(void){
		cli();
    4b60:	f8 94       	cli
		PORTG &= ~(1<<PG5);
    4b62:	a5 98       	cbi	0x14, 5	; 20
		sei();
    4b64:	78 94       	sei
	}
    4b66:	08 95       	ret

00004b68 <GSM_RTS_ON>:
	void GSM_RTS_ON(void){
		cli();
    4b68:	f8 94       	cli
		PORTG |= (1<<PG5);
    4b6a:	a5 9a       	sbi	0x14, 5	; 20
		sei();
    4b6c:	78 94       	sei
	}
    4b6e:	08 95       	ret

00004b70 <LED_Init>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    4b70:	8f b7       	in	r24, 0x3f	; 63
    4b72:	80 78       	andi	r24, 0x80	; 128
    4b74:	80 93 ec 02 	sts	0x02EC, r24
	cli();
    4b78:	f8 94       	cli
//~~~~~~~~~~~~
void
LED_Init(void)
{
	IntOff();
	DDR_LED |=PinLED;
    4b7a:	83 9a       	sbi	0x10, 3	; 16
	LED_Rst();
    4b7c:	8b 98       	cbi	0x11, 3	; 17

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    4b7e:	88 23       	and	r24, r24
    4b80:	09 f0       	breq	.+2      	; 0x4b84 <LED_Init+0x14>
		sei();
    4b82:	78 94       	sei
    4b84:	08 95       	ret

00004b86 <LED_On>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    4b86:	8f b7       	in	r24, 0x3f	; 63
    4b88:	80 78       	andi	r24, 0x80	; 128
    4b8a:	80 93 ec 02 	sts	0x02EC, r24
	cli();
    4b8e:	f8 94       	cli
// ~~~~~~~~~
void
LED_On(void)
{
	IntOff();
	LED_Set();
    4b90:	8b 9a       	sbi	0x11, 3	; 17

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    4b92:	88 23       	and	r24, r24
    4b94:	09 f0       	breq	.+2      	; 0x4b98 <LED_On+0x12>
		sei();
    4b96:	78 94       	sei
    4b98:	08 95       	ret

00004b9a <LED_Off>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    4b9a:	8f b7       	in	r24, 0x3f	; 63
    4b9c:	80 78       	andi	r24, 0x80	; 128
    4b9e:	80 93 ec 02 	sts	0x02EC, r24
	cli();
    4ba2:	f8 94       	cli
// ~~~~~~~~~~
void
LED_Off(void)
{
	IntOff();
	LED_Rst();
    4ba4:	8b 98       	cbi	0x11, 3	; 17

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    4ba6:	88 23       	and	r24, r24
    4ba8:	09 f0       	breq	.+2      	; 0x4bac <LED_Off+0x12>
		sei();
    4baa:	78 94       	sei
    4bac:	08 95       	ret

00004bae <LED_Toggle>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    4bae:	8f b7       	in	r24, 0x3f	; 63
    4bb0:	80 78       	andi	r24, 0x80	; 128
    4bb2:	80 93 ec 02 	sts	0x02EC, r24
	cli();
    4bb6:	f8 94       	cli
// ~~~~~~~~~~~~~
uint8_t
LED_Toggle(void)
{
	IntOff();
	LED_Inv();
    4bb8:	91 b3       	in	r25, 0x11	; 17
    4bba:	28 e0       	ldi	r18, 0x08	; 8
    4bbc:	92 27       	eor	r25, r18
    4bbe:	91 bb       	out	0x11, r25	; 17

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    4bc0:	88 23       	and	r24, r24
    4bc2:	09 f0       	breq	.+2      	; 0x4bc6 <LED_Toggle+0x18>
		sei();
    4bc4:	78 94       	sei
	IntOn();
	return PortLED &PinLED;
    4bc6:	81 b3       	in	r24, 0x11	; 17
}
    4bc8:	88 70       	andi	r24, 0x08	; 8
    4bca:	08 95       	ret

00004bcc <Send>:
#ifdef Port_LCD_DB0	//8-bit width data bus
	// ~~~~~~~~~~~~~~
	static void
	Send(uint8_t Val)
	{
		if (Val &(1<<0)) Port_LCD_DB0 |=DB0; else Port_LCD_DB0 &=~DB0;
    4bcc:	98 2f       	mov	r25, r24
    4bce:	80 ff       	sbrs	r24, 0
    4bd0:	23 c0       	rjmp	.+70     	; 0x4c18 <Send+0x4c>
    4bd2:	41 9a       	sbi	0x08, 1	; 8
		if (Val &(1<<1)) Port_LCD_DB1 |=DB1; else Port_LCD_DB1 &=~DB1;
    4bd4:	91 ff       	sbrs	r25, 1
    4bd6:	23 c0       	rjmp	.+70     	; 0x4c1e <Send+0x52>
    4bd8:	40 9a       	sbi	0x08, 0	; 8
		if (Val &(1<<2)) Port_LCD_DB2 |=DB2; else Port_LCD_DB2 &=~DB2;
    4bda:	92 ff       	sbrs	r25, 2
    4bdc:	23 c0       	rjmp	.+70     	; 0x4c24 <Send+0x58>
    4bde:	a1 9a       	sbi	0x14, 1	; 20
		if (Val &(1<<3)) Port_LCD_DB3 |=DB3; else Port_LCD_DB3 &=~DB3;
    4be0:	93 ff       	sbrs	r25, 3
    4be2:	23 c0       	rjmp	.+70     	; 0x4c2a <Send+0x5e>
    4be4:	a0 9a       	sbi	0x14, 0	; 20
		if (Val &(1<<4)) Port_LCD_DB4 |=DB4; else Port_LCD_DB4 &=~DB4;
    4be6:	94 ff       	sbrs	r25, 4
    4be8:	23 c0       	rjmp	.+70     	; 0x4c30 <Send+0x64>
    4bea:	5f 9a       	sbi	0x0b, 7	; 11
		if (Val &(1<<5)) Port_LCD_DB5 |=DB5; else Port_LCD_DB5 &=~DB5;
    4bec:	95 ff       	sbrs	r25, 5
    4bee:	23 c0       	rjmp	.+70     	; 0x4c36 <Send+0x6a>
    4bf0:	5e 9a       	sbi	0x0b, 6	; 11
		if (Val &(1<<6)) Port_LCD_DB6 |=DB6; else Port_LCD_DB6 &=~DB6;
    4bf2:	96 ff       	sbrs	r25, 6
    4bf4:	23 c0       	rjmp	.+70     	; 0x4c3c <Send+0x70>
    4bf6:	5d 9a       	sbi	0x0b, 5	; 11
		if (Val &(1<<7)) Port_LCD_DB7 |=DB7; else Port_LCD_DB7 &=~DB7;
    4bf8:	87 fd       	sbrc	r24, 7
    4bfa:	23 c0       	rjmp	.+70     	; 0x4c42 <Send+0x76>
    4bfc:	80 91 0b 01 	lds	r24, 0x010B
    4c00:	8f 77       	andi	r24, 0x7F	; 127
    4c02:	80 93 0b 01 	sts	0x010B, r24

		Port_LCD_E |=LCD_E;
    4c06:	42 9a       	sbi	0x08, 2	; 8
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    4c08:	85 e0       	ldi	r24, 0x05	; 5
    4c0a:	98 2f       	mov	r25, r24
    4c0c:	9a 95       	dec	r25
    4c0e:	f1 f7       	brne	.-4      	; 0x4c0c <Send+0x40>
		_delay_us(1);		// 450 ns needs
		Port_LCD_E &=~LCD_E;
    4c10:	42 98       	cbi	0x08, 2	; 8
    4c12:	8a 95       	dec	r24
    4c14:	f1 f7       	brne	.-4      	; 0x4c12 <Send+0x46>
		_delay_us(1);		// 10 ns needs
	}
    4c16:	08 95       	ret
#ifdef Port_LCD_DB0	//8-bit width data bus
	// ~~~~~~~~~~~~~~
	static void
	Send(uint8_t Val)
	{
		if (Val &(1<<0)) Port_LCD_DB0 |=DB0; else Port_LCD_DB0 &=~DB0;
    4c18:	41 98       	cbi	0x08, 1	; 8
		if (Val &(1<<1)) Port_LCD_DB1 |=DB1; else Port_LCD_DB1 &=~DB1;
    4c1a:	91 fd       	sbrc	r25, 1
    4c1c:	dd cf       	rjmp	.-70     	; 0x4bd8 <Send+0xc>
    4c1e:	40 98       	cbi	0x08, 0	; 8
		if (Val &(1<<2)) Port_LCD_DB2 |=DB2; else Port_LCD_DB2 &=~DB2;
    4c20:	92 fd       	sbrc	r25, 2
    4c22:	dd cf       	rjmp	.-70     	; 0x4bde <Send+0x12>
    4c24:	a1 98       	cbi	0x14, 1	; 20
		if (Val &(1<<3)) Port_LCD_DB3 |=DB3; else Port_LCD_DB3 &=~DB3;
    4c26:	93 fd       	sbrc	r25, 3
    4c28:	dd cf       	rjmp	.-70     	; 0x4be4 <Send+0x18>
    4c2a:	a0 98       	cbi	0x14, 0	; 20
		if (Val &(1<<4)) Port_LCD_DB4 |=DB4; else Port_LCD_DB4 &=~DB4;
    4c2c:	94 fd       	sbrc	r25, 4
    4c2e:	dd cf       	rjmp	.-70     	; 0x4bea <Send+0x1e>
    4c30:	5f 98       	cbi	0x0b, 7	; 11
		if (Val &(1<<5)) Port_LCD_DB5 |=DB5; else Port_LCD_DB5 &=~DB5;
    4c32:	95 fd       	sbrc	r25, 5
    4c34:	dd cf       	rjmp	.-70     	; 0x4bf0 <Send+0x24>
    4c36:	5e 98       	cbi	0x0b, 6	; 11
		if (Val &(1<<6)) Port_LCD_DB6 |=DB6; else Port_LCD_DB6 &=~DB6;
    4c38:	96 fd       	sbrc	r25, 6
    4c3a:	dd cf       	rjmp	.-70     	; 0x4bf6 <Send+0x2a>
    4c3c:	5d 98       	cbi	0x0b, 5	; 11
		if (Val &(1<<7)) Port_LCD_DB7 |=DB7; else Port_LCD_DB7 &=~DB7;
    4c3e:	87 ff       	sbrs	r24, 7
    4c40:	dd cf       	rjmp	.-70     	; 0x4bfc <Send+0x30>
    4c42:	80 91 0b 01 	lds	r24, 0x010B
    4c46:	80 68       	ori	r24, 0x80	; 128
    4c48:	80 93 0b 01 	sts	0x010B, r24
    4c4c:	dc cf       	rjmp	.-72     	; 0x4c06 <Send+0x3a>

00004c4e <Send_I>:
#endif
// ~~~~~~~~~~~~~~~~
static void
Send_I(uint8_t Val)
{
	Send(Val);
    4c4e:	0e 94 e6 25 	call	0x4bcc	; 0x4bcc <Send>
	Delay_us(LCD_Delay);
    4c52:	82 e3       	ldi	r24, 0x32	; 50
    4c54:	90 e0       	ldi	r25, 0x00	; 0
    4c56:	0e 94 dc 1d 	call	0x3bb8	; 0x3bb8 <Delay_us>
}
    4c5a:	08 95       	ret

00004c5c <LCD_FuncSet0>:

// ~~~~~~~~~~~
static void
LCD_FuncSet0(void)
{
	Port_LCD_DB4  |=DB4;
    4c5c:	5f 9a       	sbi	0x0b, 7	; 11
	Port_LCD_DB5  |=DB5;
    4c5e:	5e 9a       	sbi	0x0b, 6	; 11
	Port_LCD_DB6 &=~DB6;
    4c60:	5d 98       	cbi	0x0b, 5	; 11
	Port_LCD_DB7 &=~DB7;
    4c62:	eb e0       	ldi	r30, 0x0B	; 11
    4c64:	f1 e0       	ldi	r31, 0x01	; 1
    4c66:	80 81       	ld	r24, Z
    4c68:	8f 77       	andi	r24, 0x7F	; 127
    4c6a:	80 83       	st	Z, r24
}
    4c6c:	08 95       	ret

00004c6e <LCD_Rdy>:
}

// ~~~~~~~~~~
uint8_t
LCD_Rdy(void)
{
    4c6e:	1f 93       	push	r17
	uint8_t Rdy = Timer8Stopp(TD_LCD);
    4c70:	10 91 d5 04 	lds	r17, 0x04D5
    4c74:	81 2f       	mov	r24, r17
    4c76:	0e 94 e3 1b 	call	0x37c6	; 0x37c6 <Timer8Stopp>
	Rdy = Rdy && !(TIMSK_LCD &(1<<OCIE1B));
    4c7a:	88 23       	and	r24, r24
    4c7c:	29 f0       	breq	.+10     	; 0x4c88 <LCD_Rdy+0x1a>
    4c7e:	80 91 6f 00 	lds	r24, 0x006F
    4c82:	82 ff       	sbrs	r24, 2
    4c84:	03 c0       	rjmp	.+6      	; 0x4c8c <LCD_Rdy+0x1e>
    4c86:	80 e0       	ldi	r24, 0x00	; 0
	if (Rdy)
		StartTimer8(TD_LCD, 6);
	return Rdy;
}
    4c88:	1f 91       	pop	r17
    4c8a:	08 95       	ret
LCD_Rdy(void)
{
	uint8_t Rdy = Timer8Stopp(TD_LCD);
	Rdy = Rdy && !(TIMSK_LCD &(1<<OCIE1B));
	if (Rdy)
		StartTimer8(TD_LCD, 6);
    4c8c:	81 2f       	mov	r24, r17
    4c8e:	66 e0       	ldi	r22, 0x06	; 6
    4c90:	0e 94 8f 1a 	call	0x351e	; 0x351e <StartTimer8>
    4c94:	81 e0       	ldi	r24, 0x01	; 1
	return Rdy;
}
    4c96:	1f 91       	pop	r17
    4c98:	08 95       	ret

00004c9a <LCD_Out>:
LCD_Out(void)
{
	static uint8_t N;
	uint16_t LCD_delay = 100;	//50us

	if( (N>=20) && !LCD_Rst_Flg ){
    4c9a:	90 91 e9 02 	lds	r25, 0x02E9
    4c9e:	94 31       	cpi	r25, 0x14	; 20
    4ca0:	20 f0       	brcs	.+8      	; 0x4caa <LCD_Out+0x10>
    4ca2:	80 91 d4 04 	lds	r24, 0x04D4
    4ca6:	88 23       	and	r24, r24
    4ca8:	19 f1       	breq	.+70     	; 0x4cf0 <LCD_Out+0x56>
		LCD_Rst0();
		LCD_Rst_Flg = 1;
		LCD_delay = 10000;	//5ms
	}
	else {
		N++;
    4caa:	9f 5f       	subi	r25, 0xFF	; 255
    4cac:	90 93 e9 02 	sts	0x02E9, r25
    4cb0:	24 e6       	ldi	r18, 0x64	; 100
    4cb2:	30 e0       	ldi	r19, 0x00	; 0
	}

	cli();
    4cb4:	f8 94       	cli
	LCD_delay = TCNT1 + LCD_delay;
    4cb6:	80 91 84 00 	lds	r24, 0x0084
    4cba:	90 91 85 00 	lds	r25, 0x0085
    4cbe:	82 0f       	add	r24, r18
    4cc0:	93 1f       	adc	r25, r19
	if(LCD_delay >= 20000) OCR1B = LCD_delay - 20000;
    4cc2:	2e e4       	ldi	r18, 0x4E	; 78
    4cc4:	80 32       	cpi	r24, 0x20	; 32
    4cc6:	92 07       	cpc	r25, r18
    4cc8:	60 f4       	brcc	.+24     	; 0x4ce2 <LCD_Out+0x48>
	else OCR1B = LCD_delay;
    4cca:	90 93 8b 00 	sts	0x008B, r25
    4cce:	80 93 8a 00 	sts	0x008A, r24
	TIFR_LCD |= (1<<OCF1B);
    4cd2:	b2 9a       	sbi	0x16, 2	; 22
	TIMSK_LCD |= (1<<OCIE1B);
    4cd4:	80 91 6f 00 	lds	r24, 0x006F
    4cd8:	84 60       	ori	r24, 0x04	; 4
    4cda:	80 93 6f 00 	sts	0x006F, r24
	sei();
    4cde:	78 94       	sei
}
    4ce0:	08 95       	ret
		N++;
	}

	cli();
	LCD_delay = TCNT1 + LCD_delay;
	if(LCD_delay >= 20000) OCR1B = LCD_delay - 20000;
    4ce2:	80 52       	subi	r24, 0x20	; 32
    4ce4:	9e 44       	sbci	r25, 0x4E	; 78
    4ce6:	90 93 8b 00 	sts	0x008B, r25
    4cea:	80 93 8a 00 	sts	0x008A, r24
    4cee:	f1 cf       	rjmp	.-30     	; 0x4cd2 <LCD_Out+0x38>
{
	static uint8_t N;
	uint16_t LCD_delay = 100;	//50us

	if( (N>=20) && !LCD_Rst_Flg ){
		N = 0;
    4cf0:	10 92 e9 02 	sts	0x02E9, r1
#endif
// ~~~~~~~~~~~
static void
LCD_Rst0(void)
{
	cli();
    4cf4:	f8 94       	cli
	Port_LCD_RS &=~LCD_RS;
    4cf6:	44 98       	cbi	0x08, 4	; 8
	LCD_FuncSet0();
    4cf8:	0e 94 2e 26 	call	0x4c5c	; 0x4c5c <LCD_FuncSet0>
	sei();
    4cfc:	78 94       	sei
	uint16_t LCD_delay = 100;	//50us

	if( (N>=20) && !LCD_Rst_Flg ){
		N = 0;
		LCD_Rst0();
		LCD_Rst_Flg = 1;
    4cfe:	81 e0       	ldi	r24, 0x01	; 1
    4d00:	80 93 d4 04 	sts	0x04D4, r24
    4d04:	20 e1       	ldi	r18, 0x10	; 16
    4d06:	37 e2       	ldi	r19, 0x27	; 39
    4d08:	d5 cf       	rjmp	.-86     	; 0x4cb4 <LCD_Out+0x1a>

00004d0a <__vector_18>:
	sei();
}

// ~~~~~~~~~~~~~~~~~~~~~~
// 40 us needs
ISR(TIMER1_COMPB_vect){
    4d0a:	1f 92       	push	r1
    4d0c:	0f 92       	push	r0
    4d0e:	0f b6       	in	r0, 0x3f	; 63
    4d10:	0f 92       	push	r0
    4d12:	0b b6       	in	r0, 0x3b	; 59
    4d14:	0f 92       	push	r0
    4d16:	11 24       	eor	r1, r1
    4d18:	ff 92       	push	r15
    4d1a:	0f 93       	push	r16
    4d1c:	1f 93       	push	r17
    4d1e:	2f 93       	push	r18
    4d20:	3f 93       	push	r19
    4d22:	4f 93       	push	r20
    4d24:	5f 93       	push	r21
    4d26:	6f 93       	push	r22
    4d28:	7f 93       	push	r23
    4d2a:	8f 93       	push	r24
    4d2c:	9f 93       	push	r25
    4d2e:	af 93       	push	r26
    4d30:	bf 93       	push	r27
    4d32:	ef 93       	push	r30
    4d34:	ff 93       	push	r31

	uint16_t LCD_delay = 100;	//50us

	if (LCD_Rst_Flg) {
    4d36:	80 91 d4 04 	lds	r24, 0x04D4
    4d3a:	88 23       	and	r24, r24
    4d3c:	f1 f0       	breq	.+60     	; 0x4d7a <__vector_18+0x70>
		switch(LCD_Rst_Flg){
    4d3e:	10 91 d4 04 	lds	r17, 0x04D4
    4d42:	15 30       	cpi	r17, 0x05	; 5
    4d44:	09 f4       	brne	.+2      	; 0x4d48 <__vector_18+0x3e>
    4d46:	b5 c0       	rjmp	.+362    	; 0x4eb2 <__vector_18+0x1a8>
    4d48:	16 30       	cpi	r17, 0x06	; 6
    4d4a:	08 f4       	brcc	.+2      	; 0x4d4e <__vector_18+0x44>
    4d4c:	a1 c0       	rjmp	.+322    	; 0x4e90 <__vector_18+0x186>
    4d4e:	17 30       	cpi	r17, 0x07	; 7
    4d50:	09 f4       	brne	.+2      	; 0x4d54 <__vector_18+0x4a>
    4d52:	15 c1       	rjmp	.+554    	; 0x4f7e <__vector_18+0x274>
    4d54:	17 30       	cpi	r17, 0x07	; 7
    4d56:	08 f0       	brcs	.+2      	; 0x4d5a <__vector_18+0x50>
    4d58:	dc c0       	rjmp	.+440    	; 0x4f12 <__vector_18+0x208>
				break;
			case 5:
				Send(0b00001100);	//; Display on, cursor off, blink off	
				break;
			case 6:
				Send(0b00000110);	//; cursor shift right, no display shift
    4d5a:	86 e0       	ldi	r24, 0x06	; 6
    4d5c:	0e 94 e6 25 	call	0x4bcc	; 0x4bcc <Send>
				#endif
				Port_LCD_RS |=LCD_RS;
			default:
				LCD_Rst_Flg = 255;
		}
		if(LCD_Rst_Flg==1) LCD_delay = 400;	//200us
    4d60:	80 91 d4 04 	lds	r24, 0x04D4
    4d64:	81 30       	cpi	r24, 0x01	; 1
    4d66:	09 f4       	brne	.+2      	; 0x4d6a <__vector_18+0x60>
    4d68:	a1 c0       	rjmp	.+322    	; 0x4eac <__vector_18+0x1a2>
    4d6a:	24 e6       	ldi	r18, 0x64	; 100
    4d6c:	30 e0       	ldi	r19, 0x00	; 0

		LCD_Rst_Flg++;
    4d6e:	80 91 d4 04 	lds	r24, 0x04D4
    4d72:	8f 5f       	subi	r24, 0xFF	; 255
    4d74:	80 93 d4 04 	sts	0x04D4, r24
    4d78:	5f c0       	rjmp	.+190    	; 0x4e38 <__vector_18+0x12e>
	else {
		static uint8_t X, Y;
		static prog_uint8_t LineAddr[] = {128, 192, 148, 212};
		unsigned char cursor_symb;
		
		if (X<LCDXSz) {
    4d7a:	10 91 e6 02 	lds	r17, 0x02E6
    4d7e:	14 31       	cpi	r17, 0x14	; 20
    4d80:	08 f0       	brcs	.+2      	; 0x4d84 <__vector_18+0x7a>
    4d82:	45 c0       	rjmp	.+138    	; 0x4e0e <__vector_18+0x104>
			if((X>=CurrX)&&(X<(CurrX+StrSize))&&(Y==CurrLCD)){
    4d84:	80 91 b7 06 	lds	r24, 0x06B7
    4d88:	18 17       	cp	r17, r24
    4d8a:	08 f4       	brcc	.+2      	; 0x4d8e <__vector_18+0x84>
    4d8c:	96 c0       	rjmp	.+300    	; 0x4eba <__vector_18+0x1b0>
    4d8e:	61 2f       	mov	r22, r17
    4d90:	70 e0       	ldi	r23, 0x00	; 0
    4d92:	20 91 aa 06 	lds	r18, 0x06AA
    4d96:	90 e0       	ldi	r25, 0x00	; 0
    4d98:	82 0f       	add	r24, r18
    4d9a:	91 1d       	adc	r25, r1
    4d9c:	68 17       	cp	r22, r24
    4d9e:	79 07       	cpc	r23, r25
    4da0:	0c f4       	brge	.+2      	; 0x4da4 <__vector_18+0x9a>
    4da2:	e4 c0       	rjmp	.+456    	; 0x4f6c <__vector_18+0x262>
    4da4:	e0 91 e5 02 	lds	r30, 0x02E5
    4da8:	20 e0       	ldi	r18, 0x00	; 0
			else
			{
				cursor_symb=0;
			}

			Send(
    4daa:	4e 2f       	mov	r20, r30
    4dac:	50 e0       	ldi	r21, 0x00	; 0
    4dae:	90 91 d0 08 	lds	r25, 0x08D0
    4db2:	89 2f       	mov	r24, r25
    4db4:	88 50       	subi	r24, 0x08	; 8
    4db6:	83 30       	cpi	r24, 0x03	; 3
    4db8:	18 f0       	brcs	.+6      	; 0x4dc0 <__vector_18+0xb6>
    4dba:	9e 30       	cpi	r25, 0x0E	; 14
    4dbc:	08 f4       	brcc	.+2      	; 0x4dc0 <__vector_18+0xb6>
    4dbe:	91 c0       	rjmp	.+290    	; 0x4ee2 <__vector_18+0x1d8>
    4dc0:	22 23       	and	r18, r18
    4dc2:	09 f4       	brne	.+2      	; 0x4dc6 <__vector_18+0xbc>
    4dc4:	8e c0       	rjmp	.+284    	; 0x4ee2 <__vector_18+0x1d8>
    4dc6:	80 91 d6 02 	lds	r24, 0x02D6
    4dca:	8f 3f       	cpi	r24, 0xFF	; 255
    4dcc:	09 f4       	brne	.+2      	; 0x4dd0 <__vector_18+0xc6>
    4dce:	89 c0       	rjmp	.+274    	; 0x4ee2 <__vector_18+0x1d8>
    4dd0:	e2 2f       	mov	r30, r18
    4dd2:	f0 e0       	ldi	r31, 0x00	; 0
    4dd4:	ee 52       	subi	r30, 0x2E	; 46
    4dd6:	f2 4d       	sbci	r31, 0xD2	; 210
    4dd8:	24 91       	lpm	r18, Z+
    4dda:	fa 01       	movw	r30, r20
    4ddc:	ee 0f       	add	r30, r30
    4dde:	ff 1f       	adc	r31, r31
    4de0:	ee 0f       	add	r30, r30
    4de2:	ff 1f       	adc	r31, r31
    4de4:	cf 01       	movw	r24, r30
    4de6:	88 0f       	add	r24, r24
    4de8:	99 1f       	adc	r25, r25
    4dea:	88 0f       	add	r24, r24
    4dec:	99 1f       	adc	r25, r25
    4dee:	e8 0f       	add	r30, r24
    4df0:	f9 1f       	adc	r31, r25
    4df2:	e6 0f       	add	r30, r22
    4df4:	f7 1f       	adc	r31, r23
    4df6:	e5 5b       	subi	r30, 0xB5	; 181
    4df8:	f7 4f       	sbci	r31, 0xF7	; 247
    4dfa:	20 83       	st	Z, r18
    4dfc:	82 2f       	mov	r24, r18
    4dfe:	0e 94 e6 25 	call	0x4bcc	; 0x4bcc <Send>
				#ifndef QslRD
					*((uint8_t*)RMON+Y*LCDXSz+X) =
				#endif
			#endif
				(((Blink>=8 && Blink<=10 )|| Blink>=14)&&cursor_symb&&(CurrField!=255))?prb(Win2LCD+(unsigned char)cursor_symb):(prb(Win2LCD+(unsigned char)LCD_Buf[Y][X])));
				X++;
    4e02:	1f 5f       	subi	r17, 0xFF	; 255
    4e04:	10 93 e6 02 	sts	0x02E6, r17
    4e08:	24 e6       	ldi	r18, 0x64	; 100
    4e0a:	30 e0       	ldi	r19, 0x00	; 0
    4e0c:	15 c0       	rjmp	.+42     	; 0x4e38 <__vector_18+0x12e>
		}
		else {
			X = 0;
    4e0e:	10 92 e6 02 	sts	0x02E6, r1
			if (++Y==LCDYSz) {
    4e12:	e0 91 e5 02 	lds	r30, 0x02E5
    4e16:	ef 5f       	subi	r30, 0xFF	; 255
    4e18:	e0 93 e5 02 	sts	0x02E5, r30
    4e1c:	e4 30       	cpi	r30, 0x04	; 4
    4e1e:	09 f4       	brne	.+2      	; 0x4e22 <__vector_18+0x118>
    4e20:	51 c0       	rjmp	.+162    	; 0x4ec4 <__vector_18+0x1ba>
				Y = 0;
				TIMSK_LCD &= ~(1<<OCIE1B);	//stop Output CompareB interrups
			}
			Port_LCD_RS &=~LCD_RS;
    4e22:	44 98       	cbi	0x08, 4	; 8
    4e24:	f0 e0       	ldi	r31, 0x00	; 0
    4e26:	ee 52       	subi	r30, 0x2E	; 46
    4e28:	f1 4d       	sbci	r31, 0xD1	; 209
    4e2a:	e4 91       	lpm	r30, Z+
			Send(prb(LineAddr+Y));
    4e2c:	8e 2f       	mov	r24, r30
    4e2e:	0e 94 e6 25 	call	0x4bcc	; 0x4bcc <Send>
			Port_LCD_RS |=LCD_RS;
    4e32:	44 9a       	sbi	0x08, 4	; 8
    4e34:	24 e6       	ldi	r18, 0x64	; 100
    4e36:	30 e0       	ldi	r19, 0x00	; 0
		}
	}
	LCD_delay = TCNT1 + LCD_delay;
    4e38:	80 91 84 00 	lds	r24, 0x0084
    4e3c:	90 91 85 00 	lds	r25, 0x0085
    4e40:	82 0f       	add	r24, r18
    4e42:	93 1f       	adc	r25, r19
	if(LCD_delay >= 20000) OCR1B = LCD_delay - 20000;
    4e44:	2e e4       	ldi	r18, 0x4E	; 78
    4e46:	80 32       	cpi	r24, 0x20	; 32
    4e48:	92 07       	cpc	r25, r18
    4e4a:	d8 f4       	brcc	.+54     	; 0x4e82 <__vector_18+0x178>
	else OCR1B = LCD_delay;
    4e4c:	90 93 8b 00 	sts	0x008B, r25
    4e50:	80 93 8a 00 	sts	0x008A, r24
	TIFR_LCD |= (1<<OCF1B);
    4e54:	b2 9a       	sbi	0x16, 2	; 22
}
    4e56:	ff 91       	pop	r31
    4e58:	ef 91       	pop	r30
    4e5a:	bf 91       	pop	r27
    4e5c:	af 91       	pop	r26
    4e5e:	9f 91       	pop	r25
    4e60:	8f 91       	pop	r24
    4e62:	7f 91       	pop	r23
    4e64:	6f 91       	pop	r22
    4e66:	5f 91       	pop	r21
    4e68:	4f 91       	pop	r20
    4e6a:	3f 91       	pop	r19
    4e6c:	2f 91       	pop	r18
    4e6e:	1f 91       	pop	r17
    4e70:	0f 91       	pop	r16
    4e72:	ff 90       	pop	r15
    4e74:	0f 90       	pop	r0
    4e76:	0b be       	out	0x3b, r0	; 59
    4e78:	0f 90       	pop	r0
    4e7a:	0f be       	out	0x3f, r0	; 63
    4e7c:	0f 90       	pop	r0
    4e7e:	1f 90       	pop	r1
    4e80:	18 95       	reti
			Send(prb(LineAddr+Y));
			Port_LCD_RS |=LCD_RS;
		}
	}
	LCD_delay = TCNT1 + LCD_delay;
	if(LCD_delay >= 20000) OCR1B = LCD_delay - 20000;
    4e82:	80 52       	subi	r24, 0x20	; 32
    4e84:	9e 44       	sbci	r25, 0x4E	; 78
    4e86:	90 93 8b 00 	sts	0x008B, r25
    4e8a:	80 93 8a 00 	sts	0x008A, r24
    4e8e:	e2 cf       	rjmp	.-60     	; 0x4e54 <__vector_18+0x14a>
ISR(TIMER1_COMPB_vect){

	uint16_t LCD_delay = 100;	//50us

	if (LCD_Rst_Flg) {
		switch(LCD_Rst_Flg){
    4e90:	12 30       	cpi	r17, 0x02	; 2
    4e92:	21 f1       	breq	.+72     	; 0x4edc <__vector_18+0x1d2>
    4e94:	13 30       	cpi	r17, 0x03	; 3
    4e96:	f8 f4       	brcc	.+62     	; 0x4ed6 <__vector_18+0x1cc>
    4e98:	11 30       	cpi	r17, 0x01	; 1
    4e9a:	01 f1       	breq	.+64     	; 0x4edc <__vector_18+0x1d2>
				#else
					Send(0b00000010);	//RETURN HOME					
				#endif
				Port_LCD_RS |=LCD_RS;
			default:
				LCD_Rst_Flg = 255;
    4e9c:	8f ef       	ldi	r24, 0xFF	; 255
    4e9e:	80 93 d4 04 	sts	0x04D4, r24
		}
		if(LCD_Rst_Flg==1) LCD_delay = 400;	//200us
    4ea2:	80 91 d4 04 	lds	r24, 0x04D4
    4ea6:	81 30       	cpi	r24, 0x01	; 1
    4ea8:	09 f0       	breq	.+2      	; 0x4eac <__vector_18+0x1a2>
    4eaa:	5f cf       	rjmp	.-322    	; 0x4d6a <__vector_18+0x60>
    4eac:	20 e9       	ldi	r18, 0x90	; 144
    4eae:	31 e0       	ldi	r19, 0x01	; 1
    4eb0:	5e cf       	rjmp	.-324    	; 0x4d6e <__vector_18+0x64>
				#else
					Send(0b00101000);	//; 4-bits DL, 2 lines, 5x7 dots
				#endif
				break;
			case 5:
				Send(0b00001100);	//; Display on, cursor off, blink off	
    4eb2:	8c e0       	ldi	r24, 0x0C	; 12
    4eb4:	0e 94 e6 25 	call	0x4bcc	; 0x4bcc <Send>
    4eb8:	53 cf       	rjmp	.-346    	; 0x4d60 <__vector_18+0x56>
    4eba:	61 2f       	mov	r22, r17
    4ebc:	70 e0       	ldi	r23, 0x00	; 0
    4ebe:	e0 91 e5 02 	lds	r30, 0x02E5
    4ec2:	72 cf       	rjmp	.-284    	; 0x4da8 <__vector_18+0x9e>
				X++;
		}
		else {
			X = 0;
			if (++Y==LCDYSz) {
				Y = 0;
    4ec4:	10 92 e5 02 	sts	0x02E5, r1
				TIMSK_LCD &= ~(1<<OCIE1B);	//stop Output CompareB interrups
    4ec8:	80 91 6f 00 	lds	r24, 0x006F
    4ecc:	8b 7f       	andi	r24, 0xFB	; 251
    4ece:	80 93 6f 00 	sts	0x006F, r24
    4ed2:	e0 e0       	ldi	r30, 0x00	; 0
    4ed4:	a6 cf       	rjmp	.-180    	; 0x4e22 <__vector_18+0x118>
ISR(TIMER1_COMPB_vect){

	uint16_t LCD_delay = 100;	//50us

	if (LCD_Rst_Flg) {
		switch(LCD_Rst_Flg){
    4ed6:	13 30       	cpi	r17, 0x03	; 3
    4ed8:	09 f0       	breq	.+2      	; 0x4edc <__vector_18+0x1d2>
    4eda:	56 c0       	rjmp	.+172    	; 0x4f88 <__vector_18+0x27e>
			case 2:
				LCD_FuncSet0();
				break;
			case 3:
				#ifdef Port_LCD_DB0	
					LCD_FuncSet0();
    4edc:	0e 94 2e 26 	call	0x4c5c	; 0x4c5c <LCD_FuncSet0>
    4ee0:	3f cf       	rjmp	.-386    	; 0x4d60 <__vector_18+0x56>
			else
			{
				cursor_symb=0;
			}

			Send(
    4ee2:	ca 01       	movw	r24, r20
    4ee4:	88 0f       	add	r24, r24
    4ee6:	99 1f       	adc	r25, r25
    4ee8:	84 0f       	add	r24, r20
    4eea:	95 1f       	adc	r25, r21
    4eec:	fc 01       	movw	r30, r24
    4eee:	ee 0f       	add	r30, r30
    4ef0:	ff 1f       	adc	r31, r31
    4ef2:	ee 0f       	add	r30, r30
    4ef4:	ff 1f       	adc	r31, r31
    4ef6:	ee 0f       	add	r30, r30
    4ef8:	ff 1f       	adc	r31, r31
    4efa:	e8 1b       	sub	r30, r24
    4efc:	f9 0b       	sbc	r31, r25
    4efe:	e6 0f       	add	r30, r22
    4f00:	f7 1f       	adc	r31, r23
    4f02:	ea 5a       	subi	r30, 0xAA	; 170
    4f04:	f9 4f       	sbci	r31, 0xF9	; 249
    4f06:	e0 81       	ld	r30, Z
    4f08:	f0 e0       	ldi	r31, 0x00	; 0
    4f0a:	ee 52       	subi	r30, 0x2E	; 46
    4f0c:	f2 4d       	sbci	r31, 0xD2	; 210
    4f0e:	24 91       	lpm	r18, Z+
    4f10:	64 cf       	rjmp	.-312    	; 0x4dda <__vector_18+0xd0>
ISR(TIMER1_COMPB_vect){

	uint16_t LCD_delay = 100;	//50us

	if (LCD_Rst_Flg) {
		switch(LCD_Rst_Flg){
    4f12:	18 30       	cpi	r17, 0x08	; 8
    4f14:	49 f0       	breq	.+18     	; 0x4f28 <__vector_18+0x21e>
    4f16:	19 30       	cpi	r17, 0x09	; 9
    4f18:	09 f0       	breq	.+2      	; 0x4f1c <__vector_18+0x212>
    4f1a:	c0 cf       	rjmp	.-128    	; 0x4e9c <__vector_18+0x192>
						else{i=0;LCD_Rst_Flg = 8;}
					}
				}
				break;
			case 9:
				Port_LCD_RS &=~LCD_RS;
    4f1c:	44 98       	cbi	0x08, 4	; 8
				#ifdef NOT_USE_LCD_RETURN_HOME_CMD
					Send(128);			//     
				#else
					Send(0b00000010);	//RETURN HOME					
    4f1e:	82 e0       	ldi	r24, 0x02	; 2
    4f20:	0e 94 e6 25 	call	0x4bcc	; 0x4bcc <Send>
				#endif
				Port_LCD_RS |=LCD_RS;
    4f24:	44 9a       	sbi	0x08, 4	; 8
    4f26:	ba cf       	rjmp	.-140    	; 0x4e9c <__vector_18+0x192>
				Send(0b01000000);	//;    CG RAM   0.
				Port_LCD_RS |=LCD_RS;
				break;
			case 8:{
					static uint8_t i,j;
					LCD_Rst_Flg = 7;
    4f28:	87 e0       	ldi	r24, 0x07	; 7
    4f2a:	80 93 d4 04 	sts	0x04D4, r24
					Send(prb(CGRAM_LCD[i]+j));
    4f2e:	f0 90 e8 02 	lds	r15, 0x02E8
    4f32:	00 91 e7 02 	lds	r16, 0x02E7
    4f36:	ef 2d       	mov	r30, r15
    4f38:	f0 e0       	ldi	r31, 0x00	; 0
    4f3a:	ee 0f       	add	r30, r30
    4f3c:	ff 1f       	adc	r31, r31
    4f3e:	ee 0f       	add	r30, r30
    4f40:	ff 1f       	adc	r31, r31
    4f42:	ee 0f       	add	r30, r30
    4f44:	ff 1f       	adc	r31, r31
    4f46:	e0 0f       	add	r30, r16
    4f48:	f1 1d       	adc	r31, r1
    4f4a:	ee 56       	subi	r30, 0x6E	; 110
    4f4c:	f2 4d       	sbci	r31, 0xD2	; 210
    4f4e:	e4 91       	lpm	r30, Z+
    4f50:	8e 2f       	mov	r24, r30
    4f52:	0e 94 e6 25 	call	0x4bcc	; 0x4bcc <Send>
					if(j<7) j++;
    4f56:	07 30       	cpi	r16, 0x07	; 7
    4f58:	f0 f0       	brcs	.+60     	; 0x4f96 <__vector_18+0x28c>
					else{
						j=0;
    4f5a:	10 92 e7 02 	sts	0x02E7, r1
						if(i<7)i++;
    4f5e:	26 e0       	ldi	r18, 0x06	; 6
    4f60:	2f 15       	cp	r18, r15
    4f62:	e8 f0       	brcs	.+58     	; 0x4f9e <__vector_18+0x294>
    4f64:	f3 94       	inc	r15
    4f66:	f0 92 e8 02 	sts	0x02E8, r15
    4f6a:	fa ce       	rjmp	.-524    	; 0x4d60 <__vector_18+0x56>
		static uint8_t X, Y;
		static prog_uint8_t LineAddr[] = {128, 192, 148, 212};
		unsigned char cursor_symb;
		
		if (X<LCDXSz) {
			if((X>=CurrX)&&(X<(CurrX+StrSize))&&(Y==CurrLCD)){
    4f6c:	e0 91 e5 02 	lds	r30, 0x02E5
    4f70:	80 91 a0 08 	lds	r24, 0x08A0
    4f74:	e8 17       	cp	r30, r24
    4f76:	09 f0       	breq	.+2      	; 0x4f7a <__vector_18+0x270>
    4f78:	17 cf       	rjmp	.-466    	; 0x4da8 <__vector_18+0x9e>
    4f7a:	2f e5       	ldi	r18, 0x5F	; 95
    4f7c:	16 cf       	rjmp	.-468    	; 0x4daa <__vector_18+0xa0>
				break;
			case 6:
				Send(0b00000110);	//; cursor shift right, no display shift
				break;
			case 7:
				Send(0b01000000);	//;    CG RAM   0.
    4f7e:	80 e4       	ldi	r24, 0x40	; 64
    4f80:	0e 94 e6 25 	call	0x4bcc	; 0x4bcc <Send>
				Port_LCD_RS |=LCD_RS;
    4f84:	44 9a       	sbi	0x08, 4	; 8
    4f86:	ec ce       	rjmp	.-552    	; 0x4d60 <__vector_18+0x56>
ISR(TIMER1_COMPB_vect){

	uint16_t LCD_delay = 100;	//50us

	if (LCD_Rst_Flg) {
		switch(LCD_Rst_Flg){
    4f88:	14 30       	cpi	r17, 0x04	; 4
    4f8a:	09 f0       	breq	.+2      	; 0x4f8e <__vector_18+0x284>
    4f8c:	87 cf       	rjmp	.-242    	; 0x4e9c <__vector_18+0x192>
					LCD_FuncSet1();
				#endif
				break;
			case 4:
				#ifdef Port_LCD_DB0	
					Send(0b00111000);	//; 8-bits DL, 2 lines, 5x7 dots
    4f8e:	88 e3       	ldi	r24, 0x38	; 56
    4f90:	0e 94 e6 25 	call	0x4bcc	; 0x4bcc <Send>
    4f94:	e5 ce       	rjmp	.-566    	; 0x4d60 <__vector_18+0x56>
				break;
			case 8:{
					static uint8_t i,j;
					LCD_Rst_Flg = 7;
					Send(prb(CGRAM_LCD[i]+j));
					if(j<7) j++;
    4f96:	0f 5f       	subi	r16, 0xFF	; 255
    4f98:	00 93 e7 02 	sts	0x02E7, r16
    4f9c:	e1 ce       	rjmp	.-574    	; 0x4d60 <__vector_18+0x56>
					else{
						j=0;
						if(i<7)i++;
						else{i=0;LCD_Rst_Flg = 8;}
    4f9e:	10 92 e8 02 	sts	0x02E8, r1
    4fa2:	10 93 d4 04 	sts	0x04D4, r17
    4fa6:	dc ce       	rjmp	.-584    	; 0x4d60 <__vector_18+0x56>

00004fa8 <LCDBackLightOn>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    4fa8:	9f b7       	in	r25, 0x3f	; 63
    4faa:	90 78       	andi	r25, 0x80	; 128
    4fac:	90 93 ec 02 	sts	0x02EC, r25
	cli();
    4fb0:	f8 94       	cli
	void LCDBackLightOn(void){
		IntOff();	
		#ifdef BACKLIGHT_INVERSION
			PORT_BACKLIGHT &= ~BACKLIGHT;
		#else
			PORT_BACKLIGHT |= BACKLIGHT;
    4fb2:	80 91 0b 01 	lds	r24, 0x010B
    4fb6:	80 64       	ori	r24, 0x40	; 64
    4fb8:	80 93 0b 01 	sts	0x010B, r24

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    4fbc:	99 23       	and	r25, r25
    4fbe:	09 f0       	breq	.+2      	; 0x4fc2 <LCDBackLightOn+0x1a>
		sei();
    4fc0:	78 94       	sei
    4fc2:	08 95       	ret

00004fc4 <LCDBackLightOff>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    4fc4:	9f b7       	in	r25, 0x3f	; 63
    4fc6:	90 78       	andi	r25, 0x80	; 128
    4fc8:	90 93 ec 02 	sts	0x02EC, r25
	cli();
    4fcc:	f8 94       	cli
	void LCDBackLightOff(void){
		IntOff();	
		#ifdef BACKLIGHT_INVERSION
			PORT_BACKLIGHT |= BACKLIGHT;
		#else
			PORT_BACKLIGHT &= ~BACKLIGHT;
    4fce:	80 91 0b 01 	lds	r24, 0x010B
    4fd2:	8f 7b       	andi	r24, 0xBF	; 191
    4fd4:	80 93 0b 01 	sts	0x010B, r24

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    4fd8:	99 23       	and	r25, r25
    4fda:	09 f0       	breq	.+2      	; 0x4fde <LCDBackLightOff+0x1a>
		sei();
    4fdc:	78 94       	sei
    4fde:	08 95       	ret

00004fe0 <LCDBackLightControl>:
				StartTimer16(TD_BackLight, 3000);
				break;			
		}
	}
	void LCDBackLightControl(void){
		switch(BackLightMode){
    4fe0:	80 91 50 06 	lds	r24, 0x0650
    4fe4:	81 30       	cpi	r24, 0x01	; 1
    4fe6:	29 f0       	breq	.+10     	; 0x4ff2 <LCDBackLightControl+0x12>
    4fe8:	82 30       	cpi	r24, 0x02	; 2
    4fea:	61 f0       	breq	.+24     	; 0x5004 <LCDBackLightControl+0x24>
		case 1: if(Timer16Stopp(TD_BackLight)) LCDBackLightOff();
			break;
		case 2:
			break;
		default: LCDBackLightOn();
    4fec:	0e 94 d4 27 	call	0x4fa8	; 0x4fa8 <LCDBackLightOn>
    4ff0:	08 95       	ret
				break;			
		}
	}
	void LCDBackLightControl(void){
		switch(BackLightMode){
		case 1: if(Timer16Stopp(TD_BackLight)) LCDBackLightOff();
    4ff2:	80 91 d6 04 	lds	r24, 0x04D6
    4ff6:	0e 94 06 1c 	call	0x380c	; 0x380c <Timer16Stopp>
    4ffa:	88 23       	and	r24, r24
    4ffc:	c9 f3       	breq	.-14     	; 0x4ff0 <LCDBackLightControl+0x10>
    4ffe:	0e 94 e2 27 	call	0x4fc4	; 0x4fc4 <LCDBackLightOff>
    5002:	08 95       	ret
    5004:	08 95       	ret

00005006 <StartTimer0>:
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
		TCCR0  = ((((1<<WGM01) &~(1<<WGM00)  &~(1<<COM01)  &~(1<<COM00)) |(1<<CS02)) &~(1<<CS01)) |(1<<CS00);
	#elif defined (__AVR_ATmega128__)
		TCCR0  =   ((1<<WGM01) &~(1<<WGM00)  &~(1<<COM01)  &~(1<<COM00)) |(1<<CS02)   |(1<<CS01)  |(1<<CS00);
	#elif defined (__AVR_ATmega1280__)  || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TCCR0A =    (1<<WGM01) &~(1<<WGM00)  &~(1<<COM0A1) &~(1<<COM0A0) &~(1<<COM0B1) &~(1<<COM0B0);
    5006:	82 e0       	ldi	r24, 0x02	; 2
    5008:	84 bd       	out	0x24, r24	; 36
		TCCR0B = ((~(1<<WGM02)                                           |(1<<CS02)) &~(1<<CS01)) |(1<<CS00);
    500a:	85 ef       	ldi	r24, 0xF5	; 245
    500c:	85 bd       	out	0x25, r24	; 37
	#endif
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__)
		TIMSK |=(1<<OCIE0);
	#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TIMSK0 |=(1<<OCIE0A);
    500e:	ee e6       	ldi	r30, 0x6E	; 110
    5010:	f0 e0       	ldi	r31, 0x00	; 0
    5012:	80 81       	ld	r24, Z
    5014:	82 60       	ori	r24, 0x02	; 2
    5016:	80 83       	st	Z, r24
	#endif
}
    5018:	08 95       	ret

0000501a <StartTimer2>:
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
		TCCR2  =   ((1<<WGM21) &~(1<<WGM20)  &~(1<<COM21)  &~(1<<COM20)) |(1<<CS22)   |(1<<CS21)  |(1<<CS20);
	#elif defined (__AVR_ATmega128__)
		TCCR2  = ((((1<<WGM21) &~(1<<WGM20)  &~(1<<COM21)  &~(1<<COM20)) |(1<<CS22)) &~(1<<CS21)) |(1<<CS20);
	#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TCCR2A =    (1<<WGM21) &~(1<<WGM20)  &~(1<<COM2A1) &~(1<<COM2A0) &~(1<<COM2B1) &~(1<<COM2B0);
    501a:	82 e0       	ldi	r24, 0x02	; 2
    501c:	80 93 b0 00 	sts	0x00B0, r24
		TCCR2B =   ~(1<<WGM22)                                           |(1<<CS22)   |(1<<CS21)  |(1<<CS20);
    5020:	87 ef       	ldi	r24, 0xF7	; 247
    5022:	80 93 b1 00 	sts	0x00B1, r24
	#endif
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__)
		TIMSK |=(1<<OCIE2);
	#elif  defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TIMSK2 |=(1<<OCIE2A);
    5026:	e0 e7       	ldi	r30, 0x70	; 112
    5028:	f0 e0       	ldi	r31, 0x00	; 0
    502a:	80 81       	ld	r24, Z
    502c:	82 60       	ori	r24, 0x02	; 2
    502e:	80 83       	st	Z, r24
	#endif
}
    5030:	08 95       	ret

00005032 <StartTimer4>:
#if defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
	//static void
	void
	StartTimer4(void)
	{
		TCCR4A = 0;
    5032:	10 92 a0 00 	sts	0x00A0, r1
		TCCR4B = (1<<WGM42) | (1<<CS42) | (0<<CS41) | (1<<CS40);	// clk/1024
    5036:	8d e0       	ldi	r24, 0x0D	; 13
    5038:	80 93 a1 00 	sts	0x00A1, r24
		TIMSK4 |=(1<<OCIE4A);
    503c:	e2 e7       	ldi	r30, 0x72	; 114
    503e:	f0 e0       	ldi	r31, 0x00	; 0
    5040:	80 81       	ld	r24, Z
    5042:	82 60       	ori	r24, 0x02	; 2
    5044:	80 83       	st	Z, r24
	}
    5046:	08 95       	ret

00005048 <MB_Timer_ISR>:
// ~~~

// ~~~~~~~~~~~~~~~~~~~
static void
MB_Timer_ISR(tc_t *tc)
{
    5048:	bc 01       	movw	r22, r24

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    504a:	e0 e8       	ldi	r30, 0x80	; 128
    504c:	fd e2       	ldi	r31, 0x2D	; 45
    504e:	85 91       	lpm	r24, Z+
    5050:	94 91       	lpm	r25, Z+
	#if defined (__AVR_ATxmega128A1__)
		tc->INTCTRLA = (tc->INTCTRLA &~TC1_OVFINTLVL_gm) |TC_OVFINTLVL_OFF_gc;
		tc->CTRLA = TC_CLKSEL_OFF_gc;
	#endif
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Timer[MB_N]tc_f)!=tc; MB_N++);
    5052:	68 17       	cp	r22, r24
    5054:	79 07       	cpc	r23, r25
    5056:	09 f4       	brne	.+2      	; 0x505a <MB_Timer_ISR+0x12>
    5058:	54 c0       	rjmp	.+168    	; 0x5102 <MB_Timer_ISR+0xba>
    505a:	20 e0       	ldi	r18, 0x00	; 0
    505c:	2f 5f       	subi	r18, 0xFF	; 255
    505e:	42 2f       	mov	r20, r18
    5060:	50 e0       	ldi	r21, 0x00	; 0
    5062:	fa 01       	movw	r30, r20
    5064:	ee 0f       	add	r30, r30
    5066:	ff 1f       	adc	r31, r31
    5068:	e4 0f       	add	r30, r20
    506a:	f5 1f       	adc	r31, r21
    506c:	ee 0f       	add	r30, r30
    506e:	ff 1f       	adc	r31, r31
    5070:	e0 58       	subi	r30, 0x80	; 128
    5072:	f2 4d       	sbci	r31, 0xD2	; 210
    5074:	85 91       	lpm	r24, Z+
    5076:	94 91       	lpm	r25, Z+
    5078:	68 17       	cp	r22, r24
    507a:	79 07       	cpc	r23, r25
    507c:	79 f7       	brne	.-34     	; 0x505c <MB_Timer_ISR+0x14>
    507e:	fa 01       	movw	r30, r20

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    5080:	e1 58       	subi	r30, 0x81	; 129
    5082:	f2 4d       	sbci	r31, 0xD2	; 210
    5084:	84 91       	lpm	r24, Z+

	
	switch (prb(MB_Role+MB_N)){
    5086:	88 23       	and	r24, r24
    5088:	f9 f4       	brne	.+62     	; 0x50c8 <MB_Timer_ISR+0x80>
	case Role_Slave:
		if(MB_Frame[MB_N][0]==MB_NativeAddr[MB_N]){	// Slave     -   MB_TimerFlag
    508a:	f4 2f       	mov	r31, r20
    508c:	ee 27       	eor	r30, r30
    508e:	ed 5d       	subi	r30, 0xDD	; 221
    5090:	f4 4f       	sbci	r31, 0xF4	; 244
    5092:	da 01       	movw	r26, r20
    5094:	a2 52       	subi	r26, 0x22	; 34
    5096:	ba 4f       	sbci	r27, 0xFA	; 250
    5098:	90 81       	ld	r25, Z
    509a:	8c 91       	ld	r24, X
    509c:	98 17       	cp	r25, r24
    509e:	21 f1       	breq	.+72     	; 0x50e8 <MB_Timer_ISR+0xa0>
			MB_TimerFlag |= (1<<MB_N);
		}
		else{
			MB_State[MB_N] = MB_Idle;
    50a0:	fa 01       	movw	r30, r20
    50a2:	e0 54       	subi	r30, 0x40	; 64
    50a4:	fa 4f       	sbci	r31, 0xFA	; 250
    50a6:	81 e0       	ldi	r24, 0x01	; 1
    50a8:	80 83       	st	Z, r24
			MB_CPT[MB_N][0]++;
    50aa:	fa 01       	movw	r30, r20
    50ac:	e2 95       	swap	r30
    50ae:	f2 95       	swap	r31
    50b0:	f0 7f       	andi	r31, 0xF0	; 240
    50b2:	fe 27       	eor	r31, r30
    50b4:	e0 7f       	andi	r30, 0xF0	; 240
    50b6:	fe 27       	eor	r31, r30
    50b8:	e2 51       	subi	r30, 0x12	; 18
    50ba:	f7 4f       	sbci	r31, 0xF7	; 247
    50bc:	80 81       	ld	r24, Z
    50be:	91 81       	ldd	r25, Z+1	; 0x01
    50c0:	01 96       	adiw	r24, 0x01	; 1
    50c2:	91 83       	std	Z+1, r25	; 0x01
    50c4:	80 83       	st	Z, r24
    50c6:	08 95       	ret
	#endif
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Timer[MB_N]tc_f)!=tc; MB_N++);

	
	switch (prb(MB_Role+MB_N)){
    50c8:	81 30       	cpi	r24, 0x01	; 1
    50ca:	09 f0       	breq	.+2      	; 0x50ce <MB_Timer_ISR+0x86>
    50cc:	08 95       	ret
			MB_State[MB_N] = MB_Idle;
			MB_CPT[MB_N][0]++;
		}
		break;
	case Role_Master:
		MB_TimerFlag |= (1<<MB_N);
    50ce:	20 91 e2 08 	lds	r18, 0x08E2
    50d2:	81 e0       	ldi	r24, 0x01	; 1
    50d4:	90 e0       	ldi	r25, 0x00	; 0
    50d6:	02 c0       	rjmp	.+4      	; 0x50dc <MB_Timer_ISR+0x94>
    50d8:	88 0f       	add	r24, r24
    50da:	99 1f       	adc	r25, r25
    50dc:	4a 95       	dec	r20
    50de:	e2 f7       	brpl	.-8      	; 0x50d8 <MB_Timer_ISR+0x90>
    50e0:	28 2b       	or	r18, r24
    50e2:	20 93 e2 08 	sts	0x08E2, r18
    50e6:	08 95       	ret

	
	switch (prb(MB_Role+MB_N)){
	case Role_Slave:
		if(MB_Frame[MB_N][0]==MB_NativeAddr[MB_N]){	// Slave     -   MB_TimerFlag
			MB_TimerFlag |= (1<<MB_N);
    50e8:	20 91 e2 08 	lds	r18, 0x08E2
    50ec:	81 e0       	ldi	r24, 0x01	; 1
    50ee:	90 e0       	ldi	r25, 0x00	; 0
    50f0:	02 c0       	rjmp	.+4      	; 0x50f6 <MB_Timer_ISR+0xae>
    50f2:	88 0f       	add	r24, r24
    50f4:	99 1f       	adc	r25, r25
    50f6:	4a 95       	dec	r20
    50f8:	e2 f7       	brpl	.-8      	; 0x50f2 <MB_Timer_ISR+0xaa>
    50fa:	28 2b       	or	r18, r24
    50fc:	20 93 e2 08 	sts	0x08E2, r18
    5100:	08 95       	ret
	#if defined (__AVR_ATxmega128A1__)
		tc->INTCTRLA = (tc->INTCTRLA &~TC1_OVFINTLVL_gm) |TC_OVFINTLVL_OFF_gc;
		tc->CTRLA = TC_CLKSEL_OFF_gc;
	#endif
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Timer[MB_N]tc_f)!=tc; MB_N++);
    5102:	40 e0       	ldi	r20, 0x00	; 0
    5104:	50 e0       	ldi	r21, 0x00	; 0
    5106:	e0 e0       	ldi	r30, 0x00	; 0
    5108:	f0 e0       	ldi	r31, 0x00	; 0
    510a:	ba cf       	rjmp	.-140    	; 0x5080 <MB_Timer_ISR+0x38>

0000510c <__vector_21>:
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#elif  defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) ||defined (__AVR_ATmega2561__)
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ISR(TIMER0_COMPA_vect)
{
    510c:	1f 92       	push	r1
    510e:	0f 92       	push	r0
    5110:	0f b6       	in	r0, 0x3f	; 63
    5112:	0f 92       	push	r0
    5114:	0b b6       	in	r0, 0x3b	; 59
    5116:	0f 92       	push	r0
    5118:	11 24       	eor	r1, r1
    511a:	2f 93       	push	r18
    511c:	3f 93       	push	r19
    511e:	4f 93       	push	r20
    5120:	5f 93       	push	r21
    5122:	6f 93       	push	r22
    5124:	7f 93       	push	r23
    5126:	8f 93       	push	r24
    5128:	9f 93       	push	r25
    512a:	af 93       	push	r26
    512c:	bf 93       	push	r27
    512e:	ef 93       	push	r30
    5130:	ff 93       	push	r31
	TCCR0B &=~(1<<CS02) &~(1<<CS01) &~(1<<CS00);
    5132:	85 b5       	in	r24, 0x25	; 37
    5134:	88 7f       	andi	r24, 0xF8	; 248
    5136:	85 bd       	out	0x25, r24	; 37
	TIMSK0 &=~(1<<OCIE0A);
    5138:	ee e6       	ldi	r30, 0x6E	; 110
    513a:	f0 e0       	ldi	r31, 0x00	; 0
    513c:	80 81       	ld	r24, Z
    513e:	8d 7f       	andi	r24, 0xFD	; 253
    5140:	80 83       	st	Z, r24
	MB_Timer_ISR(&TCNT0);
    5142:	86 e4       	ldi	r24, 0x46	; 70
    5144:	90 e0       	ldi	r25, 0x00	; 0
    5146:	0e 94 24 28 	call	0x5048	; 0x5048 <MB_Timer_ISR>
}
    514a:	ff 91       	pop	r31
    514c:	ef 91       	pop	r30
    514e:	bf 91       	pop	r27
    5150:	af 91       	pop	r26
    5152:	9f 91       	pop	r25
    5154:	8f 91       	pop	r24
    5156:	7f 91       	pop	r23
    5158:	6f 91       	pop	r22
    515a:	5f 91       	pop	r21
    515c:	4f 91       	pop	r20
    515e:	3f 91       	pop	r19
    5160:	2f 91       	pop	r18
    5162:	0f 90       	pop	r0
    5164:	0b be       	out	0x3b, r0	; 59
    5166:	0f 90       	pop	r0
    5168:	0f be       	out	0x3f, r0	; 63
    516a:	0f 90       	pop	r0
    516c:	1f 90       	pop	r1
    516e:	18 95       	reti

00005170 <__vector_13>:

// ~~~~~~~~~~~~~~~~~~~
ISR(TIMER2_COMPA_vect)
{
    5170:	1f 92       	push	r1
    5172:	0f 92       	push	r0
    5174:	0f b6       	in	r0, 0x3f	; 63
    5176:	0f 92       	push	r0
    5178:	0b b6       	in	r0, 0x3b	; 59
    517a:	0f 92       	push	r0
    517c:	11 24       	eor	r1, r1
    517e:	2f 93       	push	r18
    5180:	3f 93       	push	r19
    5182:	4f 93       	push	r20
    5184:	5f 93       	push	r21
    5186:	6f 93       	push	r22
    5188:	7f 93       	push	r23
    518a:	8f 93       	push	r24
    518c:	9f 93       	push	r25
    518e:	af 93       	push	r26
    5190:	bf 93       	push	r27
    5192:	ef 93       	push	r30
    5194:	ff 93       	push	r31
	TCCR2B &=~(1<<CS22) &~(1<<CS21) &~(1<<CS20);
    5196:	e1 eb       	ldi	r30, 0xB1	; 177
    5198:	f0 e0       	ldi	r31, 0x00	; 0
    519a:	80 81       	ld	r24, Z
    519c:	88 7f       	andi	r24, 0xF8	; 248
    519e:	80 83       	st	Z, r24
	TIMSK2 &=~(1<<OCIE2A);
    51a0:	e0 e7       	ldi	r30, 0x70	; 112
    51a2:	f0 e0       	ldi	r31, 0x00	; 0
    51a4:	80 81       	ld	r24, Z
    51a6:	8d 7f       	andi	r24, 0xFD	; 253
    51a8:	80 83       	st	Z, r24
	MB_Timer_ISR(&TCNT2);
    51aa:	82 eb       	ldi	r24, 0xB2	; 178
    51ac:	90 e0       	ldi	r25, 0x00	; 0
    51ae:	0e 94 24 28 	call	0x5048	; 0x5048 <MB_Timer_ISR>
}
    51b2:	ff 91       	pop	r31
    51b4:	ef 91       	pop	r30
    51b6:	bf 91       	pop	r27
    51b8:	af 91       	pop	r26
    51ba:	9f 91       	pop	r25
    51bc:	8f 91       	pop	r24
    51be:	7f 91       	pop	r23
    51c0:	6f 91       	pop	r22
    51c2:	5f 91       	pop	r21
    51c4:	4f 91       	pop	r20
    51c6:	3f 91       	pop	r19
    51c8:	2f 91       	pop	r18
    51ca:	0f 90       	pop	r0
    51cc:	0b be       	out	0x3b, r0	; 59
    51ce:	0f 90       	pop	r0
    51d0:	0f be       	out	0x3f, r0	; 63
    51d2:	0f 90       	pop	r0
    51d4:	1f 90       	pop	r1
    51d6:	18 95       	reti

000051d8 <__vector_42>:
// ~~~~~~~~~~~~~~~~~~~
ISR(TIMER4_COMPA_vect)
{
    51d8:	1f 92       	push	r1
    51da:	0f 92       	push	r0
    51dc:	0f b6       	in	r0, 0x3f	; 63
    51de:	0f 92       	push	r0
    51e0:	0b b6       	in	r0, 0x3b	; 59
    51e2:	0f 92       	push	r0
    51e4:	11 24       	eor	r1, r1
    51e6:	2f 93       	push	r18
    51e8:	3f 93       	push	r19
    51ea:	4f 93       	push	r20
    51ec:	5f 93       	push	r21
    51ee:	6f 93       	push	r22
    51f0:	7f 93       	push	r23
    51f2:	8f 93       	push	r24
    51f4:	9f 93       	push	r25
    51f6:	af 93       	push	r26
    51f8:	bf 93       	push	r27
    51fa:	ef 93       	push	r30
    51fc:	ff 93       	push	r31
	TCCR4B &=~(1<<CS42) &~(1<<CS41) &~(1<<CS40);
    51fe:	e1 ea       	ldi	r30, 0xA1	; 161
    5200:	f0 e0       	ldi	r31, 0x00	; 0
    5202:	80 81       	ld	r24, Z
    5204:	88 7f       	andi	r24, 0xF8	; 248
    5206:	80 83       	st	Z, r24
	TIMSK4 &=~(1<<OCIE4A);
    5208:	e2 e7       	ldi	r30, 0x72	; 114
    520a:	f0 e0       	ldi	r31, 0x00	; 0
    520c:	80 81       	ld	r24, Z
    520e:	8d 7f       	andi	r24, 0xFD	; 253
    5210:	80 83       	st	Z, r24
	MB_Timer_ISR((uint8_t*)&TCNT4);
    5212:	84 ea       	ldi	r24, 0xA4	; 164
    5214:	90 e0       	ldi	r25, 0x00	; 0
    5216:	0e 94 24 28 	call	0x5048	; 0x5048 <MB_Timer_ISR>
}
    521a:	ff 91       	pop	r31
    521c:	ef 91       	pop	r30
    521e:	bf 91       	pop	r27
    5220:	af 91       	pop	r26
    5222:	9f 91       	pop	r25
    5224:	8f 91       	pop	r24
    5226:	7f 91       	pop	r23
    5228:	6f 91       	pop	r22
    522a:	5f 91       	pop	r21
    522c:	4f 91       	pop	r20
    522e:	3f 91       	pop	r19
    5230:	2f 91       	pop	r18
    5232:	0f 90       	pop	r0
    5234:	0b be       	out	0x3b, r0	; 59
    5236:	0f 90       	pop	r0
    5238:	0f be       	out	0x3f, r0	; 63
    523a:	0f 90       	pop	r0
    523c:	1f 90       	pop	r1
    523e:	18 95       	reti

00005240 <MBRecept>:
		#endif
		MB_Err &=(1<<MB_N);
		return;
	}
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		Buf = USART_Reg(MB_N, ucsra);
    5240:	68 2f       	mov	r22, r24
    5242:	70 e0       	ldi	r23, 0x00	; 0

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5244:	9b 01       	movw	r18, r22
    5246:	22 0f       	add	r18, r18
    5248:	33 1f       	adc	r19, r19
    524a:	cb 01       	movw	r24, r22
    524c:	88 0f       	add	r24, r24
    524e:	99 1f       	adc	r25, r25
    5250:	88 0f       	add	r24, r24
    5252:	99 1f       	adc	r25, r25
    5254:	88 0f       	add	r24, r24
    5256:	99 1f       	adc	r25, r25
    5258:	28 0f       	add	r18, r24
    525a:	39 1f       	adc	r19, r25
    525c:	22 0f       	add	r18, r18
    525e:	33 1f       	adc	r19, r19
    5260:	23 59       	subi	r18, 0x93	; 147
    5262:	32 4d       	sbci	r19, 0xD2	; 210
    5264:	f9 01       	movw	r30, r18
    5266:	a5 91       	lpm	r26, Z+
    5268:	b4 91       	lpm	r27, Z+
    526a:	3c 91       	ld	r19, X
		MB_Frame[MB_N][MB_Frame_Sz[MB_N]++] = USART_Reg(MB_N, udr);
    526c:	ab 01       	movw	r20, r22
    526e:	4b 5f       	subi	r20, 0xFB	; 251
    5270:	58 4f       	sbci	r21, 0xF8	; 248
    5272:	fa 01       	movw	r30, r20
    5274:	20 81       	ld	r18, Z
    5276:	cb 01       	movw	r24, r22
    5278:	88 0f       	add	r24, r24
    527a:	99 1f       	adc	r25, r25
    527c:	88 0f       	add	r24, r24
    527e:	99 1f       	adc	r25, r25
    5280:	fc 01       	movw	r30, r24
    5282:	ee 0f       	add	r30, r30
    5284:	ff 1f       	adc	r31, r31
    5286:	ee 0f       	add	r30, r30
    5288:	ff 1f       	adc	r31, r31
    528a:	e8 0f       	add	r30, r24
    528c:	f9 1f       	adc	r31, r25
    528e:	e5 59       	subi	r30, 0x95	; 149
    5290:	f2 4d       	sbci	r31, 0xD2	; 210
    5292:	a5 91       	lpm	r26, Z+
    5294:	b4 91       	lpm	r27, Z+
    5296:	f6 2f       	mov	r31, r22
    5298:	ee 27       	eor	r30, r30
    529a:	e2 0f       	add	r30, r18
    529c:	f1 1d       	adc	r31, r1
    529e:	ed 5d       	subi	r30, 0xDD	; 221
    52a0:	f4 4f       	sbci	r31, 0xF4	; 244
    52a2:	8c 91       	ld	r24, X
    52a4:	80 83       	st	Z, r24
    52a6:	2f 5f       	subi	r18, 0xFF	; 255
    52a8:	fa 01       	movw	r30, r20
    52aa:	20 83       	st	Z, r18
	#elif defined (__AVR_ATxmega128A1__)
		USART_t *usart = prp(&MB_Port[MB_N].usart);
		Buf = usart->STATUS;
		MB_Frame[MB_N][MB_Frame_Sz[MB_N]++] = usart->DATA;
	#endif
	if (Buf &(1<<3))
    52ac:	23 2f       	mov	r18, r19
    52ae:	30 e0       	ldi	r19, 0x00	; 0
    52b0:	23 ff       	sbrs	r18, 3
    52b2:	0e c0       	rjmp	.+28     	; 0x52d0 <MBRecept+0x90>
		MB_CPT[MB_N][7]++;
    52b4:	fb 01       	movw	r30, r22
    52b6:	e2 95       	swap	r30
    52b8:	f2 95       	swap	r31
    52ba:	f0 7f       	andi	r31, 0xF0	; 240
    52bc:	fe 27       	eor	r31, r30
    52be:	e0 7f       	andi	r30, 0xF0	; 240
    52c0:	fe 27       	eor	r31, r30
    52c2:	e2 51       	subi	r30, 0x12	; 18
    52c4:	f7 4f       	sbci	r31, 0xF7	; 247
    52c6:	86 85       	ldd	r24, Z+14	; 0x0e
    52c8:	97 85       	ldd	r25, Z+15	; 0x0f
    52ca:	01 96       	adiw	r24, 0x01	; 1
    52cc:	97 87       	std	Z+15, r25	; 0x0f
    52ce:	86 87       	std	Z+14, r24	; 0x0e
	if (Buf &((1<<4) |(1<<3) |(1<<2)))
    52d0:	2c 71       	andi	r18, 0x1C	; 28
    52d2:	30 70       	andi	r19, 0x00	; 0
    52d4:	23 2b       	or	r18, r19
    52d6:	61 f0       	breq	.+24     	; 0x52f0 <MBRecept+0xb0>
		MB_Err |=(1<<MB_N);
    52d8:	81 e0       	ldi	r24, 0x01	; 1
    52da:	90 e0       	ldi	r25, 0x00	; 0
    52dc:	02 c0       	rjmp	.+4      	; 0x52e2 <MBRecept+0xa2>
    52de:	88 0f       	add	r24, r24
    52e0:	99 1f       	adc	r25, r25
    52e2:	6a 95       	dec	r22
    52e4:	e2 f7       	brpl	.-8      	; 0x52de <MBRecept+0x9e>
    52e6:	20 91 d7 04 	lds	r18, 0x04D7
    52ea:	28 2b       	or	r18, r24
    52ec:	20 93 d7 04 	sts	0x04D7, r18
    52f0:	08 95       	ret

000052f2 <MB_Transm>:
}

// ~~~~~~~~~~~~~~~~~~~~
void
MB_Transm(uint8_t MB_N)
{
    52f2:	af 92       	push	r10
    52f4:	bf 92       	push	r11
    52f6:	cf 92       	push	r12
    52f8:	df 92       	push	r13
    52fa:	ef 92       	push	r14
    52fc:	ff 92       	push	r15
    52fe:	0f 93       	push	r16
    5300:	1f 93       	push	r17
	MB_State[MB_N] = MB_Trans;
    5302:	e8 2e       	mov	r14, r24
    5304:	ff 24       	eor	r15, r15
    5306:	f7 01       	movw	r30, r14
    5308:	e0 54       	subi	r30, 0x40	; 64
    530a:	fa 4f       	sbci	r31, 0xFA	; 250
    530c:	83 e0       	ldi	r24, 0x03	; 3
    530e:	80 83       	st	Z, r24
    5310:	57 01       	movw	r10, r14
    5312:	aa 0c       	add	r10, r10
    5314:	bb 1c       	adc	r11, r11
    5316:	aa 0c       	add	r10, r10
    5318:	bb 1c       	adc	r11, r11
    531a:	85 01       	movw	r16, r10
    531c:	00 0f       	add	r16, r16
    531e:	11 1f       	adc	r17, r17
    5320:	00 0f       	add	r16, r16
    5322:	11 1f       	adc	r17, r17
    5324:	0a 0d       	add	r16, r10
    5326:	1b 1d       	adc	r17, r11
    5328:	04 5f       	subi	r16, 0xF4	; 244
    532a:	1f 4f       	sbci	r17, 0xFF	; 255
    532c:	8b e6       	ldi	r24, 0x6B	; 107
    532e:	c8 2e       	mov	r12, r24
    5330:	8d e2       	ldi	r24, 0x2D	; 45
    5332:	d8 2e       	mov	r13, r24
    5334:	c6 01       	movw	r24, r12
    5336:	80 0f       	add	r24, r16
    5338:	91 1f       	adc	r25, r17
    533a:	0c 50       	subi	r16, 0x0C	; 12
    533c:	10 40       	sbci	r17, 0x00	; 0
    533e:	fc 01       	movw	r30, r24
    5340:	25 91       	lpm	r18, Z+
    5342:	34 91       	lpm	r19, Z+
	USART_Func(MB_N, RS485);
    5344:	f9 01       	movw	r30, r18
    5346:	19 95       	eicall
    5348:	f6 01       	movw	r30, r12
    534a:	e0 0f       	add	r30, r16
    534c:	f1 1f       	adc	r31, r17
    534e:	a5 91       	lpm	r26, Z+
    5350:	b4 91       	lpm	r27, Z+
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		//USART_Reg(MB_N, ucsrb) |=(1<<6);
		USART_Reg(MB_N, udr) = MB_Frame[MB_N][0];
    5352:	fe 2d       	mov	r31, r14
    5354:	ee 27       	eor	r30, r30
    5356:	ed 5d       	subi	r30, 0xDD	; 221
    5358:	f4 4f       	sbci	r31, 0xF4	; 244
    535a:	80 81       	ld	r24, Z
    535c:	8c 93       	st	X, r24
    535e:	97 01       	movw	r18, r14
    5360:	22 0f       	add	r18, r18
    5362:	33 1f       	adc	r19, r19
    5364:	c7 01       	movw	r24, r14
    5366:	88 0f       	add	r24, r24
    5368:	99 1f       	adc	r25, r25
    536a:	88 0f       	add	r24, r24
    536c:	99 1f       	adc	r25, r25
    536e:	88 0f       	add	r24, r24
    5370:	99 1f       	adc	r25, r25
    5372:	28 0f       	add	r18, r24
    5374:	39 1f       	adc	r19, r25
    5376:	2f 5f       	subi	r18, 0xFF	; 255
    5378:	3f 4f       	sbci	r19, 0xFF	; 255
    537a:	22 0f       	add	r18, r18
    537c:	33 1f       	adc	r19, r19
    537e:	2c 0d       	add	r18, r12
    5380:	3d 1d       	adc	r19, r13
    5382:	f9 01       	movw	r30, r18
    5384:	a5 91       	lpm	r26, Z+
    5386:	b4 91       	lpm	r27, Z+

		USART_Reg(MB_N, ucsra) |=(1<<6);	//Clear TxC pending interrupt		
    5388:	8c 91       	ld	r24, X
    538a:	80 64       	ori	r24, 0x40	; 64
    538c:	8c 93       	st	X, r24
    538e:	c5 01       	movw	r24, r10
    5390:	8e 0d       	add	r24, r14
    5392:	9f 1d       	adc	r25, r15
    5394:	01 96       	adiw	r24, 0x01	; 1
    5396:	88 0f       	add	r24, r24
    5398:	99 1f       	adc	r25, r25
    539a:	88 0f       	add	r24, r24
    539c:	99 1f       	adc	r25, r25
    539e:	8c 0d       	add	r24, r12
    53a0:	9d 1d       	adc	r25, r13
    53a2:	fc 01       	movw	r30, r24
    53a4:	a5 91       	lpm	r26, Z+
    53a6:	b4 91       	lpm	r27, Z+
		USART_Reg(MB_N, ucsrb) |=(1<<5);
    53a8:	8c 91       	ld	r24, X
    53aa:	80 62       	ori	r24, 0x20	; 32
    53ac:	8c 93       	st	X, r24
	#elif defined (__AVR_ATxmega128A1__)
		USART_t *usart = prp(&MB_Port[MB_N].usart);
		usart->CTRLA = (usart->CTRLA &~USART_TXCINTLVL_gm) |USART_TXCINTLVL_HI_gc;
		usart->DATA = MB_Frame[MB_N][0];
	#endif
}
    53ae:	1f 91       	pop	r17
    53b0:	0f 91       	pop	r16
    53b2:	ff 90       	pop	r15
    53b4:	ef 90       	pop	r14
    53b6:	df 90       	pop	r13
    53b8:	cf 90       	pop	r12
    53ba:	bf 90       	pop	r11
    53bc:	af 90       	pop	r10
    53be:	08 95       	ret

000053c0 <Modbus_RX>:

// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_RX(usart_t *usart)
{
    53c0:	cf 93       	push	r28
    53c2:	df 93       	push	r29
    53c4:	dc 01       	movw	r26, r24
    53c6:	eb e6       	ldi	r30, 0x6B	; 107
    53c8:	fd e2       	ldi	r31, 0x2D	; 45
    53ca:	85 91       	lpm	r24, Z+
    53cc:	94 91       	lpm	r25, Z+
// ~~~~~~~~~~~~~~~~~~~~~~
static uint8_t
MB_Port_N(usart_t *usart)
{
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Port[MB_N].usart_field)!=usart; MB_N++);
    53ce:	a8 17       	cp	r26, r24
    53d0:	b9 07       	cpc	r27, r25
    53d2:	09 f4       	brne	.+2      	; 0x53d6 <Modbus_RX+0x16>
    53d4:	6e c0       	rjmp	.+220    	; 0x54b2 <Modbus_RX+0xf2>
    53d6:	30 e0       	ldi	r19, 0x00	; 0
    53d8:	3f 5f       	subi	r19, 0xFF	; 255
    53da:	c3 2f       	mov	r28, r19
    53dc:	d0 e0       	ldi	r29, 0x00	; 0
    53de:	ce 01       	movw	r24, r28
    53e0:	88 0f       	add	r24, r24
    53e2:	99 1f       	adc	r25, r25
    53e4:	88 0f       	add	r24, r24
    53e6:	99 1f       	adc	r25, r25
    53e8:	fc 01       	movw	r30, r24
    53ea:	ee 0f       	add	r30, r30
    53ec:	ff 1f       	adc	r31, r31
    53ee:	ee 0f       	add	r30, r30
    53f0:	ff 1f       	adc	r31, r31
    53f2:	e8 0f       	add	r30, r24
    53f4:	f9 1f       	adc	r31, r25
    53f6:	e5 59       	subi	r30, 0x95	; 149
    53f8:	f2 4d       	sbci	r31, 0xD2	; 210
    53fa:	85 91       	lpm	r24, Z+
    53fc:	94 91       	lpm	r25, Z+
    53fe:	a8 17       	cp	r26, r24
    5400:	b9 07       	cpc	r27, r25
    5402:	51 f7       	brne	.-44     	; 0x53d8 <Modbus_RX+0x18>
// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_RX(usart_t *usart)
{
	uint8_t MB_N = MB_Port_N(usart);
	switch (MB_State[MB_N]) {
    5404:	fe 01       	movw	r30, r28
    5406:	e0 54       	subi	r30, 0x40	; 64
    5408:	fa 4f       	sbci	r31, 0xFA	; 250
    540a:	80 81       	ld	r24, Z
    540c:	82 30       	cpi	r24, 0x02	; 2
    540e:	19 f1       	breq	.+70     	; 0x5456 <Modbus_RX+0x96>
    5410:	83 30       	cpi	r24, 0x03	; 3
    5412:	28 f0       	brcs	.+10     	; 0x541e <Modbus_RX+0x5e>
    5414:	86 30       	cpi	r24, 0x06	; 6
    5416:	d8 f0       	brcs	.+54     	; 0x544e <Modbus_RX+0x8e>
	case MB_Trans: case MB_Proc: 
	case MB_NoReply: // MB_NoReply    MB_Recept ..  MB_M_Cycle   MB_Trans
		usart_data(usart);
		break;
	}
}
    5418:	df 91       	pop	r29
    541a:	cf 91       	pop	r28
    541c:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_RX(usart_t *usart)
{
	uint8_t MB_N = MB_Port_N(usart);
	switch (MB_State[MB_N]) {
    541e:	88 23       	and	r24, r24
    5420:	f1 f4       	brne	.+60     	; 0x545e <Modbus_RX+0x9e>
	case MB_Initi:
		MB_Frame[MB_N][0] = usart_data(usart);
    5422:	8c 91       	ld	r24, X
    5424:	fc 2f       	mov	r31, r28
    5426:	ee 27       	eor	r30, r30
    5428:	ed 5d       	subi	r30, 0xDD	; 221
    542a:	f4 4f       	sbci	r31, 0xF4	; 244
    542c:	80 83       	st	Z, r24
    542e:	ce 01       	movw	r24, r28
    5430:	88 0f       	add	r24, r24
    5432:	99 1f       	adc	r25, r25
    5434:	8c 0f       	add	r24, r28
    5436:	9d 1f       	adc	r25, r29
    5438:	88 0f       	add	r24, r24
    543a:	99 1f       	adc	r25, r25
    543c:	80 58       	subi	r24, 0x80	; 128
    543e:	92 4d       	sbci	r25, 0xD2	; 210
    5440:	fc 01       	movw	r30, r24
    5442:	a5 91       	lpm	r26, Z+
    5444:	b4 91       	lpm	r27, Z+
		break;
	case MB_Recept:
		/*if(TCNT2>=prb(&(BR_Tbl+MB_BitRate_RAM[MB_N])->Time15))
			MB_Err &=(1<<MB_N);*/
		MBRecept(MB_N);
		MB_ClearTimer(MB_N);
    5446:	1c 92       	st	X, r1
	case MB_Trans: case MB_Proc: 
	case MB_NoReply: // MB_NoReply    MB_Recept ..  MB_M_Cycle   MB_Trans
		usart_data(usart);
		break;
	}
}
    5448:	df 91       	pop	r29
    544a:	cf 91       	pop	r28
    544c:	08 95       	ret
		MBRecept(MB_N);
		MB_ClearTimer(MB_N);
		break;
	case MB_Trans: case MB_Proc: 
	case MB_NoReply: // MB_NoReply    MB_Recept ..  MB_M_Cycle   MB_Trans
		usart_data(usart);
    544e:	8c 91       	ld	r24, X
		break;
	}
}
    5450:	df 91       	pop	r29
    5452:	cf 91       	pop	r28
    5454:	08 95       	ret
		MB_StartTimer(MB_N);
		break;
	case MB_Recept:
		/*if(TCNT2>=prb(&(BR_Tbl+MB_BitRate_RAM[MB_N])->Time15))
			MB_Err &=(1<<MB_N);*/
		MBRecept(MB_N);
    5456:	83 2f       	mov	r24, r19
    5458:	0e 94 20 29 	call	0x5240	; 0x5240 <MBRecept>
    545c:	e8 cf       	rjmp	.-48     	; 0x542e <Modbus_RX+0x6e>
// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_RX(usart_t *usart)
{
	uint8_t MB_N = MB_Port_N(usart);
	switch (MB_State[MB_N]) {
    545e:	81 30       	cpi	r24, 0x01	; 1
    5460:	d9 f6       	brne	.-74     	; 0x5418 <Modbus_RX+0x58>
	case MB_Initi:
		MB_Frame[MB_N][0] = usart_data(usart);
		MB_ClearTimer(MB_N);
		break;
	case MB_Idle: 
		MB_State[MB_N] = MB_Recept;
    5462:	82 e0       	ldi	r24, 0x02	; 2
    5464:	80 83       	st	Z, r24
		MB_Err &=~(1<<MB_N);
    5466:	81 e0       	ldi	r24, 0x01	; 1
    5468:	90 e0       	ldi	r25, 0x00	; 0
    546a:	0c 2e       	mov	r0, r28
    546c:	02 c0       	rjmp	.+4      	; 0x5472 <Modbus_RX+0xb2>
    546e:	88 0f       	add	r24, r24
    5470:	99 1f       	adc	r25, r25
    5472:	0a 94       	dec	r0
    5474:	e2 f7       	brpl	.-8      	; 0x546e <Modbus_RX+0xae>
    5476:	80 95       	com	r24
    5478:	20 91 d7 04 	lds	r18, 0x04D7
    547c:	28 23       	and	r18, r24
    547e:	20 93 d7 04 	sts	0x04D7, r18
		MB_Frame_Sz[MB_N] = 0;
    5482:	fe 01       	movw	r30, r28
    5484:	eb 5f       	subi	r30, 0xFB	; 251
    5486:	f8 4f       	sbci	r31, 0xF8	; 248
    5488:	10 82       	st	Z, r1
		MBRecept(MB_N);
    548a:	83 2f       	mov	r24, r19
    548c:	0e 94 20 29 	call	0x5240	; 0x5240 <MBRecept>
    5490:	ce 01       	movw	r24, r28
    5492:	88 0f       	add	r24, r24
    5494:	99 1f       	adc	r25, r25
    5496:	8c 0f       	add	r24, r28
    5498:	9d 1f       	adc	r25, r29
    549a:	88 0f       	add	r24, r24
    549c:	99 1f       	adc	r25, r25
    549e:	8c 57       	subi	r24, 0x7C	; 124
    54a0:	92 4d       	sbci	r25, 0xD2	; 210
    54a2:	fc 01       	movw	r30, r24
    54a4:	25 91       	lpm	r18, Z+
    54a6:	34 91       	lpm	r19, Z+
		MB_StartTimer(MB_N);
    54a8:	f9 01       	movw	r30, r18
    54aa:	19 95       	eicall
	case MB_Trans: case MB_Proc: 
	case MB_NoReply: // MB_NoReply    MB_Recept ..  MB_M_Cycle   MB_Trans
		usart_data(usart);
		break;
	}
}
    54ac:	df 91       	pop	r29
    54ae:	cf 91       	pop	r28
    54b0:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~
static uint8_t
MB_Port_N(usart_t *usart)
{
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Port[MB_N].usart_field)!=usart; MB_N++);
    54b2:	30 e0       	ldi	r19, 0x00	; 0
    54b4:	c0 e0       	ldi	r28, 0x00	; 0
    54b6:	d0 e0       	ldi	r29, 0x00	; 0
    54b8:	a5 cf       	rjmp	.-182    	; 0x5404 <Modbus_RX+0x44>

000054ba <CommErr>:
}

// ~~~~~~~~~~~~~~~~~~
uint8_t
CommErr(uint8_t MB_N)
{
    54ba:	0f 93       	push	r16
    54bc:	1f 93       	push	r17
    54be:	cf 93       	push	r28
    54c0:	df 93       	push	r29
    54c2:	38 2f       	mov	r19, r24
	uint8_t Sz = MB_Frame_Sz[MB_N]-2;
    54c4:	c8 2f       	mov	r28, r24
    54c6:	d0 e0       	ldi	r29, 0x00	; 0
    54c8:	fe 01       	movw	r30, r28
    54ca:	eb 5f       	subi	r30, 0xFB	; 251
    54cc:	f8 4f       	sbci	r31, 0xF8	; 248
    54ce:	20 81       	ld	r18, Z
	uint8_t Err = MB_Err &(1<<MB_N) || MB_Frame_Sz[MB_N]<3 || *(uint16_t*)(MB_Frame[MB_N]+Sz)!=CRC(rrb, MB_Frame[MB_N], Sz);
    54d0:	80 91 d7 04 	lds	r24, 0x04D7
    54d4:	90 e0       	ldi	r25, 0x00	; 0
    54d6:	03 2e       	mov	r0, r19
    54d8:	02 c0       	rjmp	.+4      	; 0x54de <CommErr+0x24>
    54da:	95 95       	asr	r25
    54dc:	87 95       	ror	r24
    54de:	0a 94       	dec	r0
    54e0:	e2 f7       	brpl	.-8      	; 0x54da <CommErr+0x20>
    54e2:	80 ff       	sbrs	r24, 0
    54e4:	29 c0       	rjmp	.+82     	; 0x5538 <CommErr+0x7e>
	if (Err) {
		MB_CPT[MB_N][1]++;
    54e6:	fe 01       	movw	r30, r28
    54e8:	ee 0f       	add	r30, r30
    54ea:	ff 1f       	adc	r31, r31
    54ec:	ee 0f       	add	r30, r30
    54ee:	ff 1f       	adc	r31, r31
    54f0:	ee 0f       	add	r30, r30
    54f2:	ff 1f       	adc	r31, r31
    54f4:	ee 0f       	add	r30, r30
    54f6:	ff 1f       	adc	r31, r31
    54f8:	e0 51       	subi	r30, 0x10	; 16
    54fa:	f7 4f       	sbci	r31, 0xF7	; 247
    54fc:	80 81       	ld	r24, Z
    54fe:	91 81       	ldd	r25, Z+1	; 0x01
    5500:	01 96       	adiw	r24, 0x01	; 1
    5502:	91 83       	std	Z+1, r25	; 0x01
    5504:	80 83       	st	Z, r24
    5506:	ce 01       	movw	r24, r28
    5508:	88 0f       	add	r24, r24
    550a:	99 1f       	adc	r25, r25
    550c:	88 0f       	add	r24, r24
    550e:	99 1f       	adc	r25, r25
    5510:	9c 01       	movw	r18, r24
    5512:	22 0f       	add	r18, r18
    5514:	33 1f       	adc	r19, r19
    5516:	22 0f       	add	r18, r18
    5518:	33 1f       	adc	r19, r19
    551a:	28 0f       	add	r18, r24
    551c:	39 1f       	adc	r19, r25
    551e:	25 58       	subi	r18, 0x85	; 133
    5520:	32 4d       	sbci	r19, 0xD2	; 210
    5522:	f9 01       	movw	r30, r18
    5524:	85 91       	lpm	r24, Z+
    5526:	94 91       	lpm	r25, Z+
		USART_Func(MB_N, LED_Err_On);
    5528:	fc 01       	movw	r30, r24
    552a:	19 95       	eicall
    552c:	81 e0       	ldi	r24, 0x01	; 1
	else {
		MB_CPT[MB_N][0]++;
		USART_Func(MB_N, LED_Err_Off);
	}
	return Err;
}
    552e:	df 91       	pop	r29
    5530:	cf 91       	pop	r28
    5532:	1f 91       	pop	r17
    5534:	0f 91       	pop	r16
    5536:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~
uint8_t
CommErr(uint8_t MB_N)
{
	uint8_t Sz = MB_Frame_Sz[MB_N]-2;
	uint8_t Err = MB_Err &(1<<MB_N) || MB_Frame_Sz[MB_N]<3 || *(uint16_t*)(MB_Frame[MB_N]+Sz)!=CRC(rrb, MB_Frame[MB_N], Sz);
    5538:	23 30       	cpi	r18, 0x03	; 3
    553a:	a8 f2       	brcs	.-86     	; 0x54e6 <CommErr+0x2c>

// ~~~~~~~~~~~~~~~~~~
uint8_t
CommErr(uint8_t MB_N)
{
	uint8_t Sz = MB_Frame_Sz[MB_N]-2;
    553c:	22 50       	subi	r18, 0x02	; 2
	uint8_t Err = MB_Err &(1<<MB_N) || MB_Frame_Sz[MB_N]<3 || *(uint16_t*)(MB_Frame[MB_N]+Sz)!=CRC(rrb, MB_Frame[MB_N], Sz);
    553e:	73 2f       	mov	r23, r19
    5540:	60 e0       	ldi	r22, 0x00	; 0
    5542:	fb 01       	movw	r30, r22
    5544:	e2 0f       	add	r30, r18
    5546:	f1 1d       	adc	r31, r1
    5548:	ed 5d       	subi	r30, 0xDD	; 221
    554a:	f4 4f       	sbci	r31, 0xF4	; 244
    554c:	00 81       	ld	r16, Z
    554e:	11 81       	ldd	r17, Z+1	; 0x01
    5550:	6d 5d       	subi	r22, 0xDD	; 221
    5552:	74 4f       	sbci	r23, 0xF4	; 244
    5554:	30 e0       	ldi	r19, 0x00	; 0
    5556:	40 e0       	ldi	r20, 0x00	; 0
    5558:	50 e0       	ldi	r21, 0x00	; 0
    555a:	8f e0       	ldi	r24, 0x0F	; 15
    555c:	99 e1       	ldi	r25, 0x19	; 25
    555e:	0e 94 82 19 	call	0x3304	; 0x3304 <CRC>
    5562:	08 17       	cp	r16, r24
    5564:	19 07       	cpc	r17, r25
    5566:	09 f0       	breq	.+2      	; 0x556a <CommErr+0xb0>
    5568:	be cf       	rjmp	.-132    	; 0x54e6 <CommErr+0x2c>
	if (Err) {
		MB_CPT[MB_N][1]++;
		USART_Func(MB_N, LED_Err_On);
	}
	else {
		MB_CPT[MB_N][0]++;
    556a:	fe 01       	movw	r30, r28
    556c:	e2 95       	swap	r30
    556e:	f2 95       	swap	r31
    5570:	f0 7f       	andi	r31, 0xF0	; 240
    5572:	fe 27       	eor	r31, r30
    5574:	e0 7f       	andi	r30, 0xF0	; 240
    5576:	fe 27       	eor	r31, r30
    5578:	e2 51       	subi	r30, 0x12	; 18
    557a:	f7 4f       	sbci	r31, 0xF7	; 247
    557c:	80 81       	ld	r24, Z
    557e:	91 81       	ldd	r25, Z+1	; 0x01
    5580:	01 96       	adiw	r24, 0x01	; 1
    5582:	91 83       	std	Z+1, r25	; 0x01
    5584:	80 83       	st	Z, r24
    5586:	ce 01       	movw	r24, r28
    5588:	88 0f       	add	r24, r24
    558a:	99 1f       	adc	r25, r25
    558c:	88 0f       	add	r24, r24
    558e:	99 1f       	adc	r25, r25
    5590:	9c 01       	movw	r18, r24
    5592:	22 0f       	add	r18, r18
    5594:	33 1f       	adc	r19, r19
    5596:	22 0f       	add	r18, r18
    5598:	33 1f       	adc	r19, r19
    559a:	28 0f       	add	r18, r24
    559c:	39 1f       	adc	r19, r25
    559e:	23 58       	subi	r18, 0x83	; 131
    55a0:	32 4d       	sbci	r19, 0xD2	; 210
    55a2:	f9 01       	movw	r30, r18
    55a4:	85 91       	lpm	r24, Z+
    55a6:	94 91       	lpm	r25, Z+
		USART_Func(MB_N, LED_Err_Off);
    55a8:	fc 01       	movw	r30, r24
    55aa:	19 95       	eicall
    55ac:	80 e0       	ldi	r24, 0x00	; 0
    55ae:	bf cf       	rjmp	.-130    	; 0x552e <CommErr+0x74>

000055b0 <SetCRC_MB>:
}

// ~~~~~~~~~~~~~~~~~~~~
void
SetCRC_MB(uint8_t MB_N)
{
    55b0:	df 92       	push	r13
    55b2:	ef 92       	push	r14
    55b4:	ff 92       	push	r15
    55b6:	0f 93       	push	r16
    55b8:	1f 93       	push	r17
	uint8_t Sz = MB_Frame_Sz[MB_N]-2;
    55ba:	e5 e0       	ldi	r30, 0x05	; 5
    55bc:	f7 e0       	ldi	r31, 0x07	; 7
    55be:	e8 0f       	add	r30, r24
    55c0:	f1 1d       	adc	r31, r1
    55c2:	d0 80       	ld	r13, Z
    55c4:	9e ef       	ldi	r25, 0xFE	; 254
    55c6:	d9 0e       	add	r13, r25
	*(uint16_t*)(MB_Frame[MB_N]+Sz) = CRC(rrb, MB_Frame[MB_N], Sz);
    55c8:	18 2f       	mov	r17, r24
    55ca:	00 e0       	ldi	r16, 0x00	; 0
    55cc:	83 e2       	ldi	r24, 0x23	; 35
    55ce:	e8 2e       	mov	r14, r24
    55d0:	8b e0       	ldi	r24, 0x0B	; 11
    55d2:	f8 2e       	mov	r15, r24
    55d4:	b7 01       	movw	r22, r14
    55d6:	60 0f       	add	r22, r16
    55d8:	71 1f       	adc	r23, r17
    55da:	2d 2d       	mov	r18, r13
    55dc:	30 e0       	ldi	r19, 0x00	; 0
    55de:	40 e0       	ldi	r20, 0x00	; 0
    55e0:	50 e0       	ldi	r21, 0x00	; 0
    55e2:	8f e0       	ldi	r24, 0x0F	; 15
    55e4:	99 e1       	ldi	r25, 0x19	; 25
    55e6:	0e 94 82 19 	call	0x3304	; 0x3304 <CRC>
    55ea:	0d 0d       	add	r16, r13
    55ec:	11 1d       	adc	r17, r1
    55ee:	e0 0e       	add	r14, r16
    55f0:	f1 1e       	adc	r15, r17
    55f2:	f7 01       	movw	r30, r14
    55f4:	91 83       	std	Z+1, r25	; 0x01
    55f6:	80 83       	st	Z, r24
}
    55f8:	1f 91       	pop	r17
    55fa:	0f 91       	pop	r16
    55fc:	ff 90       	pop	r15
    55fe:	ef 90       	pop	r14
    5600:	df 90       	pop	r13
    5602:	08 95       	ret

00005604 <MB_FrameReg>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
MB_FrameReg(uint8_t MB_N, uint8_t i)
{
	return MB_Frame[MB_N][i]<<8 | MB_Frame[MB_N][i+1];
    5604:	70 e0       	ldi	r23, 0x00	; 0
    5606:	a3 e2       	ldi	r26, 0x23	; 35
    5608:	bb e0       	ldi	r27, 0x0B	; 11
    560a:	f8 2f       	mov	r31, r24
    560c:	e0 e0       	ldi	r30, 0x00	; 0
    560e:	ea 0f       	add	r30, r26
    5610:	fb 1f       	adc	r31, r27
    5612:	e6 0f       	add	r30, r22
    5614:	f7 1f       	adc	r31, r23
    5616:	41 81       	ldd	r20, Z+1	; 0x01
    5618:	50 e0       	ldi	r21, 0x00	; 0
    561a:	38 2f       	mov	r19, r24
    561c:	20 e0       	ldi	r18, 0x00	; 0
    561e:	26 0f       	add	r18, r22
    5620:	37 1f       	adc	r19, r23
    5622:	a2 0f       	add	r26, r18
    5624:	b3 1f       	adc	r27, r19
    5626:	9c 91       	ld	r25, X
    5628:	80 e0       	ldi	r24, 0x00	; 0
    562a:	48 2b       	or	r20, r24
    562c:	59 2b       	or	r21, r25
}
    562e:	ca 01       	movw	r24, r20
    5630:	08 95       	ret

00005632 <MB_CPT_Clear>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~
void
MB_CPT_Clear(uint8_t MB_N)
{
    5632:	90 e0       	ldi	r25, 0x00	; 0
    5634:	20 e0       	ldi	r18, 0x00	; 0
    5636:	30 e0       	ldi	r19, 0x00	; 0
    5638:	88 0f       	add	r24, r24
    563a:	99 1f       	adc	r25, r25
    563c:	88 0f       	add	r24, r24
    563e:	99 1f       	adc	r25, r25
    5640:	88 0f       	add	r24, r24
    5642:	99 1f       	adc	r25, r25
	for (uint8_t i=0; i<8; MB_CPT[MB_N][i++]=0);
    5644:	fc 01       	movw	r30, r24
    5646:	e2 0f       	add	r30, r18
    5648:	f3 1f       	adc	r31, r19
    564a:	ee 0f       	add	r30, r30
    564c:	ff 1f       	adc	r31, r31
    564e:	e2 51       	subi	r30, 0x12	; 18
    5650:	f7 4f       	sbci	r31, 0xF7	; 247
    5652:	11 82       	std	Z+1, r1	; 0x01
    5654:	10 82       	st	Z, r1
    5656:	2f 5f       	subi	r18, 0xFF	; 255
    5658:	3f 4f       	sbci	r19, 0xFF	; 255
    565a:	28 30       	cpi	r18, 0x08	; 8
    565c:	31 05       	cpc	r19, r1
    565e:	91 f7       	brne	.-28     	; 0x5644 <MB_CPT_Clear+0x12>
}
    5660:	08 95       	ret

00005662 <MB_S_Timer_ISR>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_S_Timer_ISR(uint8_t MB_N)
{
    5662:	2f 92       	push	r2
    5664:	3f 92       	push	r3
    5666:	4f 92       	push	r4
    5668:	5f 92       	push	r5
    566a:	6f 92       	push	r6
    566c:	7f 92       	push	r7
    566e:	8f 92       	push	r8
    5670:	9f 92       	push	r9
    5672:	af 92       	push	r10
    5674:	bf 92       	push	r11
    5676:	cf 92       	push	r12
    5678:	df 92       	push	r13
    567a:	ef 92       	push	r14
    567c:	ff 92       	push	r15
    567e:	0f 93       	push	r16
    5680:	1f 93       	push	r17
    5682:	df 93       	push	r29
    5684:	cf 93       	push	r28
    5686:	cd b7       	in	r28, 0x3d	; 61
    5688:	de b7       	in	r29, 0x3e	; 62
    568a:	29 97       	sbiw	r28, 0x09	; 9
    568c:	0f b6       	in	r0, 0x3f	; 63
    568e:	f8 94       	cli
    5690:	de bf       	out	0x3e, r29	; 62
    5692:	0f be       	out	0x3f, r0	; 63
    5694:	cd bf       	out	0x3d, r28	; 61
    5696:	d8 2e       	mov	r13, r24
	switch (MB_State[MB_N]) {
    5698:	28 2f       	mov	r18, r24
    569a:	30 e0       	ldi	r19, 0x00	; 0
    569c:	39 87       	std	Y+9, r19	; 0x09
    569e:	28 87       	std	Y+8, r18	; 0x08
    56a0:	89 01       	movw	r16, r18
    56a2:	00 54       	subi	r16, 0x40	; 64
    56a4:	1a 4f       	sbci	r17, 0xFA	; 250
    56a6:	d8 01       	movw	r26, r16
    56a8:	8c 91       	ld	r24, X
    56aa:	88 23       	and	r24, r24
    56ac:	b9 f1       	breq	.+110    	; 0x571c <MB_S_Timer_ISR+0xba>
    56ae:	82 30       	cpi	r24, 0x02	; 2
    56b0:	c9 f0       	breq	.+50     	; 0x56e4 <MB_S_Timer_ISR+0x82>
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
		MB_S_CtrlProc(MB_N);
		break;
	}
}
    56b2:	29 96       	adiw	r28, 0x09	; 9
    56b4:	0f b6       	in	r0, 0x3f	; 63
    56b6:	f8 94       	cli
    56b8:	de bf       	out	0x3e, r29	; 62
    56ba:	0f be       	out	0x3f, r0	; 63
    56bc:	cd bf       	out	0x3d, r28	; 61
    56be:	cf 91       	pop	r28
    56c0:	df 91       	pop	r29
    56c2:	1f 91       	pop	r17
    56c4:	0f 91       	pop	r16
    56c6:	ff 90       	pop	r15
    56c8:	ef 90       	pop	r14
    56ca:	df 90       	pop	r13
    56cc:	cf 90       	pop	r12
    56ce:	bf 90       	pop	r11
    56d0:	af 90       	pop	r10
    56d2:	9f 90       	pop	r9
    56d4:	8f 90       	pop	r8
    56d6:	7f 90       	pop	r7
    56d8:	6f 90       	pop	r6
    56da:	5f 90       	pop	r5
    56dc:	4f 90       	pop	r4
    56de:	3f 90       	pop	r3
    56e0:	2f 90       	pop	r2
    56e2:	08 95       	ret
	switch (MB_State[MB_N]) {
	case MB_Initi:
		MB_State[MB_N] = MB_Idle;
		break;
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
    56e4:	84 e0       	ldi	r24, 0x04	; 4
    56e6:	d8 01       	movw	r26, r16
    56e8:	8c 93       	st	X, r24

// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
MB_S_CtrlProc(uint8_t MB_N)
{
	if (CommErr(MB_N)) {
    56ea:	8d 2d       	mov	r24, r13
    56ec:	0e 94 5d 2a 	call	0x54ba	; 0x54ba <CommErr>
    56f0:	88 23       	and	r24, r24
    56f2:	a1 f4       	brne	.+40     	; 0x571c <MB_S_Timer_ISR+0xba>
		MB_State[MB_N] = MB_Idle;
		return;
	}
	if (MB_Frame[MB_N][0]!=0 && MB_Frame[MB_N][0]!=MB_NativeAddr[MB_N]) {
    56f4:	28 85       	ldd	r18, Y+8	; 0x08
    56f6:	39 85       	ldd	r19, Y+9	; 0x09
    56f8:	f2 2e       	mov	r15, r18
    56fa:	ee 24       	eor	r14, r14
    56fc:	f7 01       	movw	r30, r14
    56fe:	ed 5d       	subi	r30, 0xDD	; 221
    5700:	f4 4f       	sbci	r31, 0xF4	; 244
    5702:	90 81       	ld	r25, Z
    5704:	99 23       	and	r25, r25
    5706:	71 f0       	breq	.+28     	; 0x5724 <MB_S_Timer_ISR+0xc2>
    5708:	f9 01       	movw	r30, r18
    570a:	e2 52       	subi	r30, 0x22	; 34
    570c:	fa 4f       	sbci	r31, 0xFA	; 250
    570e:	80 81       	ld	r24, Z
    5710:	98 17       	cp	r25, r24
    5712:	41 f0       	breq	.+16     	; 0x5724 <MB_S_Timer_ISR+0xc2>
		MB_State[MB_N] = MB_Idle;
    5714:	81 e0       	ldi	r24, 0x01	; 1
    5716:	d8 01       	movw	r26, r16
    5718:	8c 93       	st	X, r24
    571a:	cb cf       	rjmp	.-106    	; 0x56b2 <MB_S_Timer_ISR+0x50>
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
MB_S_CtrlProc(uint8_t MB_N)
{
	if (CommErr(MB_N)) {
		MB_State[MB_N] = MB_Idle;
    571c:	81 e0       	ldi	r24, 0x01	; 1
    571e:	f8 01       	movw	r30, r16
    5720:	80 83       	st	Z, r24
    5722:	c7 cf       	rjmp	.-114    	; 0x56b2 <MB_S_Timer_ISR+0x50>
    5724:	28 84       	ldd	r2, Y+8	; 0x08
    5726:	39 84       	ldd	r3, Y+9	; 0x09
    5728:	22 0c       	add	r2, r2
    572a:	33 1c       	adc	r3, r3
    572c:	22 0c       	add	r2, r2
    572e:	33 1c       	adc	r3, r3
    5730:	51 01       	movw	r10, r2
    5732:	aa 0c       	add	r10, r10
    5734:	bb 1c       	adc	r11, r11
    5736:	aa 0c       	add	r10, r10
    5738:	bb 1c       	adc	r11, r11
    573a:	a2 0c       	add	r10, r2
    573c:	b3 1c       	adc	r11, r3
    573e:	e9 e7       	ldi	r30, 0x79	; 121
    5740:	fd e2       	ldi	r31, 0x2D	; 45
    5742:	ae 0e       	add	r10, r30
    5744:	bf 1e       	adc	r11, r31
    5746:	f5 01       	movw	r30, r10
    5748:	25 91       	lpm	r18, Z+
    574a:	34 91       	lpm	r19, Z+
	}
	if (MB_Frame[MB_N][0]!=0 && MB_Frame[MB_N][0]!=MB_NativeAddr[MB_N]) {
		MB_State[MB_N] = MB_Idle;
		return;
	}
	USART_Func(MB_N, LED);
    574c:	f9 01       	movw	r30, r18
    574e:	19 95       	eicall
	MB_CPT[MB_N][3]++;
    5750:	68 84       	ldd	r6, Y+8	; 0x08
    5752:	79 84       	ldd	r7, Y+9	; 0x09
    5754:	62 94       	swap	r6
    5756:	72 94       	swap	r7
    5758:	b0 ef       	ldi	r27, 0xF0	; 240
    575a:	7b 22       	and	r7, r27
    575c:	76 24       	eor	r7, r6
    575e:	6b 22       	and	r6, r27
    5760:	76 24       	eor	r7, r6
    5762:	f3 01       	movw	r30, r6
    5764:	e2 51       	subi	r30, 0x12	; 18
    5766:	f7 4f       	sbci	r31, 0xF7	; 247
    5768:	86 81       	ldd	r24, Z+6	; 0x06
    576a:	97 81       	ldd	r25, Z+7	; 0x07
    576c:	01 96       	adiw	r24, 0x01	; 1
    576e:	97 83       	std	Z+7, r25	; 0x07
    5770:	86 83       	std	Z+6, r24	; 0x06

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
MB_FrameReg(uint8_t MB_N, uint8_t i)
{
	return MB_Frame[MB_N][i]<<8 | MB_Frame[MB_N][i+1];
    5772:	68 85       	ldd	r22, Y+8	; 0x08
    5774:	79 85       	ldd	r23, Y+9	; 0x09
    5776:	76 95       	lsr	r23
    5778:	76 2f       	mov	r23, r22
    577a:	66 27       	eor	r22, r22
    577c:	77 95       	ror	r23
    577e:	67 95       	ror	r22
    5780:	db 01       	movw	r26, r22
    5782:	aa 0f       	add	r26, r26
    5784:	bb 1f       	adc	r27, r27
    5786:	ab 5d       	subi	r26, 0xDB	; 219
    5788:	b4 4f       	sbci	r27, 0xF4	; 244
    578a:	9c 91       	ld	r25, X
    578c:	80 e0       	ldi	r24, 0x00	; 0
    578e:	a7 01       	movw	r20, r14
    5790:	4d 5d       	subi	r20, 0xDD	; 221
    5792:	54 4f       	sbci	r21, 0xF4	; 244
    5794:	fa 01       	movw	r30, r20
    5796:	23 81       	ldd	r18, Z+3	; 0x03
    5798:	82 2e       	mov	r8, r18
    579a:	99 24       	eor	r9, r9
    579c:	88 2a       	or	r8, r24
    579e:	99 2a       	or	r9, r25
inline static uint8_t
Process(uint8_t MB_N)
{
	uint8_t Err;
	uint16_t StartAddr = MB_FrameReg(MB_N, 2);
	switch (MB_Frame[MB_N][1]) {
    57a0:	31 81       	ldd	r19, Z+1	; 0x01
    57a2:	35 30       	cpi	r19, 0x05	; 5
    57a4:	08 f0       	brcs	.+2      	; 0x57a8 <MB_S_Timer_ISR+0x146>
    57a6:	52 c0       	rjmp	.+164    	; 0x584c <MB_S_Timer_ISR+0x1ea>
    57a8:	33 30       	cpi	r19, 0x03	; 3
    57aa:	08 f4       	brcc	.+2      	; 0x57ae <MB_S_Timer_ISR+0x14c>
    57ac:	72 c0       	rjmp	.+228    	; 0x5892 <MB_S_Timer_ISR+0x230>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_ReadReg(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame[MB_N][0]==0)
    57ae:	fa 01       	movw	r30, r20
    57b0:	80 81       	ld	r24, Z
    57b2:	88 23       	and	r24, r24
    57b4:	09 f4       	brne	.+2      	; 0x57b8 <MB_S_Timer_ISR+0x156>
    57b6:	5c c0       	rjmp	.+184    	; 0x5870 <MB_S_Timer_ISR+0x20e>
		return 0xFF;
	if (MB_Frame_Sz[MB_N]!=8)
    57b8:	25 e0       	ldi	r18, 0x05	; 5
    57ba:	42 2e       	mov	r4, r18
    57bc:	27 e0       	ldi	r18, 0x07	; 7
    57be:	52 2e       	mov	r5, r18
    57c0:	88 85       	ldd	r24, Y+8	; 0x08
    57c2:	99 85       	ldd	r25, Y+9	; 0x09
    57c4:	48 0e       	add	r4, r24
    57c6:	59 1e       	adc	r5, r25
    57c8:	f2 01       	movw	r30, r4
    57ca:	80 81       	ld	r24, Z
    57cc:	88 30       	cpi	r24, 0x08	; 8
    57ce:	09 f4       	brne	.+2      	; 0x57d2 <MB_S_Timer_ISR+0x170>
    57d0:	27 c2       	rjmp	.+1102   	; 0x5c20 <MB_S_Timer_ISR+0x5be>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_PresetSingle(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame_Sz[MB_N]!=8)
		return MB_Frame[MB_N][2]=IllegData;
    57d2:	83 e0       	ldi	r24, 0x03	; 3
    57d4:	8c 93       	st	X, r24
    57d6:	93 e0       	ldi	r25, 0x03	; 3
		break;
	default:
		Err = MB_Frame[MB_N][2] = IllegFunc;
		break;
	}
	if (MB_Frame[MB_N][0]) {
    57d8:	f7 01       	movw	r30, r14
    57da:	ed 5d       	subi	r30, 0xDD	; 221
    57dc:	f4 4f       	sbci	r31, 0xF4	; 244
    57de:	80 81       	ld	r24, Z
    57e0:	88 23       	and	r24, r24
    57e2:	81 f0       	breq	.+32     	; 0x5804 <MB_S_Timer_ISR+0x1a2>
		if (Err) {
    57e4:	99 23       	and	r25, r25
    57e6:	49 f0       	breq	.+18     	; 0x57fa <MB_S_Timer_ISR+0x198>
			MB_Frame[MB_N][1] |=(1<<7);
    57e8:	81 81       	ldd	r24, Z+1	; 0x01
    57ea:	80 68       	ori	r24, 0x80	; 128
    57ec:	81 83       	std	Z+1, r24	; 0x01
			MB_Frame_Sz[MB_N] = 5;
    57ee:	e8 85       	ldd	r30, Y+8	; 0x08
    57f0:	f9 85       	ldd	r31, Y+9	; 0x09
    57f2:	eb 5f       	subi	r30, 0xFB	; 251
    57f4:	f8 4f       	sbci	r31, 0xF8	; 248
    57f6:	85 e0       	ldi	r24, 0x05	; 5
    57f8:	80 83       	st	Z, r24
		}
		SetCRC_MB(MB_N);
    57fa:	8d 2d       	mov	r24, r13
    57fc:	9d 83       	std	Y+5, r25	; 0x05
    57fe:	0e 94 d8 2a 	call	0x55b0	; 0x55b0 <SetCRC_MB>
    5802:	9d 81       	ldd	r25, Y+5	; 0x05
		MB_State[MB_N] = MB_Idle;
		return;
	}
	USART_Func(MB_N, LED);
	MB_CPT[MB_N][3]++;
	if (Process(MB_N))
    5804:	99 23       	and	r25, r25
    5806:	a1 f5       	brne	.+104    	; 0x5870 <MB_S_Timer_ISR+0x20e>
		MB_CPT[MB_N][2]++;
	if (MB_Frame[MB_N][0])
    5808:	23 e2       	ldi	r18, 0x23	; 35
    580a:	3b e0       	ldi	r19, 0x0B	; 11
    580c:	e2 0e       	add	r14, r18
    580e:	f3 1e       	adc	r15, r19
    5810:	d7 01       	movw	r26, r14
    5812:	8c 91       	ld	r24, X
    5814:	88 23       	and	r24, r24
    5816:	c9 f5       	brne	.+114    	; 0x588a <MB_S_Timer_ISR+0x228>
		MB_Transm(MB_N);
	else {
		MB_CPT[MB_N][4]++;
    5818:	e8 85       	ldd	r30, Y+8	; 0x08
    581a:	f9 85       	ldd	r31, Y+9	; 0x09
    581c:	ee 0f       	add	r30, r30
    581e:	ff 1f       	adc	r31, r31
    5820:	ee 0f       	add	r30, r30
    5822:	ff 1f       	adc	r31, r31
    5824:	ee 0f       	add	r30, r30
    5826:	ff 1f       	adc	r31, r31
    5828:	ee 0f       	add	r30, r30
    582a:	ff 1f       	adc	r31, r31
    582c:	ea 50       	subi	r30, 0x0A	; 10
    582e:	f7 4f       	sbci	r31, 0xF7	; 247
    5830:	80 81       	ld	r24, Z
    5832:	91 81       	ldd	r25, Z+1	; 0x01
    5834:	01 96       	adiw	r24, 0x01	; 1
    5836:	91 83       	std	Z+1, r25	; 0x01
    5838:	80 83       	st	Z, r24
		MB_State[MB_N] = MB_Idle;
    583a:	81 e0       	ldi	r24, 0x01	; 1
    583c:	f8 01       	movw	r30, r16
    583e:	80 83       	st	Z, r24
    5840:	f5 01       	movw	r30, r10
    5842:	85 91       	lpm	r24, Z+
    5844:	94 91       	lpm	r25, Z+
		USART_Func(MB_N, LED);
    5846:	fc 01       	movw	r30, r24
    5848:	19 95       	eicall
    584a:	33 cf       	rjmp	.-410    	; 0x56b2 <MB_S_Timer_ISR+0x50>
inline static uint8_t
Process(uint8_t MB_N)
{
	uint8_t Err;
	uint16_t StartAddr = MB_FrameReg(MB_N, 2);
	switch (MB_Frame[MB_N][1]) {
    584c:	3f 30       	cpi	r19, 0x0F	; 15
    584e:	09 f4       	brne	.+2      	; 0x5852 <MB_S_Timer_ISR+0x1f0>
    5850:	1e c1       	rjmp	.+572    	; 0x5a8e <MB_S_Timer_ISR+0x42c>
    5852:	30 31       	cpi	r19, 0x10	; 16
    5854:	09 f4       	brne	.+2      	; 0x5858 <MB_S_Timer_ISR+0x1f6>
    5856:	fc c0       	rjmp	.+504    	; 0x5a50 <MB_S_Timer_ISR+0x3ee>
    5858:	36 30       	cpi	r19, 0x06	; 6
    585a:	09 f4       	brne	.+2      	; 0x585e <MB_S_Timer_ISR+0x1fc>
    585c:	bd c0       	rjmp	.+378    	; 0x59d8 <MB_S_Timer_ISR+0x376>
		break;
	case 0x10:
		Err = MB_S_Preset(MB_N, StartAddr);
		break;
	default:
		Err = MB_Frame[MB_N][2] = IllegFunc;
    585e:	66 0f       	add	r22, r22
    5860:	77 1f       	adc	r23, r23
    5862:	6b 5d       	subi	r22, 0xDB	; 219
    5864:	74 4f       	sbci	r23, 0xF4	; 244
    5866:	81 e0       	ldi	r24, 0x01	; 1
    5868:	fb 01       	movw	r30, r22
    586a:	80 83       	st	Z, r24
    586c:	91 e0       	ldi	r25, 0x01	; 1
    586e:	b4 cf       	rjmp	.-152    	; 0x57d8 <MB_S_Timer_ISR+0x176>
		return;
	}
	USART_Func(MB_N, LED);
	MB_CPT[MB_N][3]++;
	if (Process(MB_N))
		MB_CPT[MB_N][2]++;
    5870:	f1 01       	movw	r30, r2
    5872:	ee 0f       	add	r30, r30
    5874:	ff 1f       	adc	r31, r31
    5876:	ee 0f       	add	r30, r30
    5878:	ff 1f       	adc	r31, r31
    587a:	ee 50       	subi	r30, 0x0E	; 14
    587c:	f7 4f       	sbci	r31, 0xF7	; 247
    587e:	80 81       	ld	r24, Z
    5880:	91 81       	ldd	r25, Z+1	; 0x01
    5882:	01 96       	adiw	r24, 0x01	; 1
    5884:	91 83       	std	Z+1, r25	; 0x01
    5886:	80 83       	st	Z, r24
    5888:	bf cf       	rjmp	.-130    	; 0x5808 <MB_S_Timer_ISR+0x1a6>
	if (MB_Frame[MB_N][0])
		MB_Transm(MB_N);
    588a:	8d 2d       	mov	r24, r13
    588c:	0e 94 79 29 	call	0x52f2	; 0x52f2 <MB_Transm>
    5890:	10 cf       	rjmp	.-480    	; 0x56b2 <MB_S_Timer_ISR+0x50>
inline static uint8_t
Process(uint8_t MB_N)
{
	uint8_t Err;
	uint16_t StartAddr = MB_FrameReg(MB_N, 2);
	switch (MB_Frame[MB_N][1]) {
    5892:	31 30       	cpi	r19, 0x01	; 1
    5894:	20 f3       	brcs	.-56     	; 0x585e <MB_S_Timer_ISR+0x1fc>
*/
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_ReadDiscr(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame[MB_N][0]==0)
    5896:	fa 01       	movw	r30, r20
    5898:	80 81       	ld	r24, Z
    589a:	88 23       	and	r24, r24
    589c:	49 f3       	breq	.-46     	; 0x5870 <MB_S_Timer_ISR+0x20e>
		return 0xFF;
	if (MB_Frame_Sz[MB_N]!=8)
    589e:	e5 e0       	ldi	r30, 0x05	; 5
    58a0:	4e 2e       	mov	r4, r30
    58a2:	e7 e0       	ldi	r30, 0x07	; 7
    58a4:	5e 2e       	mov	r5, r30
    58a6:	88 85       	ldd	r24, Y+8	; 0x08
    58a8:	99 85       	ldd	r25, Y+9	; 0x09
    58aa:	48 0e       	add	r4, r24
    58ac:	59 1e       	adc	r5, r25
    58ae:	f2 01       	movw	r30, r4
    58b0:	80 81       	ld	r24, Z
    58b2:	88 30       	cpi	r24, 0x08	; 8
    58b4:	09 f0       	breq	.+2      	; 0x58b8 <MB_S_Timer_ISR+0x256>
    58b6:	8d cf       	rjmp	.-230    	; 0x57d2 <MB_S_Timer_ISR+0x170>
    58b8:	88 85       	ldd	r24, Y+8	; 0x08
    58ba:	99 85       	ldd	r25, Y+9	; 0x09
    58bc:	f8 2f       	mov	r31, r24
    58be:	ee 27       	eor	r30, r30
    58c0:	e9 5d       	subi	r30, 0xD9	; 217
    58c2:	f4 4f       	sbci	r31, 0xF4	; 244
    58c4:	90 81       	ld	r25, Z
    58c6:	80 e0       	ldi	r24, 0x00	; 0
    58c8:	da 01       	movw	r26, r20
    58ca:	15 96       	adiw	r26, 0x05	; 5
    58cc:	2c 91       	ld	r18, X
    58ce:	a2 2f       	mov	r26, r18
    58d0:	b0 e0       	ldi	r27, 0x00	; 0
    58d2:	a8 2b       	or	r26, r24
    58d4:	b9 2b       	or	r27, r25
		return MB_Frame[MB_N][2]=IllegData;
	uint16_t Qt = MB_FrameReg(MB_N, 4);
	if (StartAddr+Qt>(MB_Frame[MB_N][1]==1?prw(&Modbus_Map[MB_N].Coil_Qt):prw(&Modbus_Map[MB_N].Input_Qt)))
    58d6:	31 30       	cpi	r19, 0x01	; 1
    58d8:	09 f4       	brne	.+2      	; 0x58dc <MB_S_Timer_ISR+0x27a>
    58da:	44 c2       	rjmp	.+1160   	; 0x5d64 <MB_S_Timer_ISR+0x702>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    58dc:	f3 01       	movw	r30, r6
    58de:	ea 5c       	subi	r30, 0xCA	; 202
    58e0:	fc 4f       	sbci	r31, 0xFC	; 252
    58e2:	45 91       	lpm	r20, Z+
    58e4:	54 91       	lpm	r21, Z+
    58e6:	cd 01       	movw	r24, r26
    58e8:	88 0d       	add	r24, r8
    58ea:	99 1d       	adc	r25, r9
    58ec:	48 17       	cp	r20, r24
    58ee:	59 07       	cpc	r21, r25
    58f0:	08 f4       	brcc	.+2      	; 0x58f4 <MB_S_Timer_ISR+0x292>
    58f2:	8d c1       	rjmp	.+794    	; 0x5c0e <MB_S_Timer_ISR+0x5ac>
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
    58f4:	31 30       	cpi	r19, 0x01	; 1
    58f6:	09 f4       	brne	.+2      	; 0x58fa <MB_S_Timer_ISR+0x298>
    58f8:	4a c2       	rjmp	.+1172   	; 0x5d8e <MB_S_Timer_ISR+0x72c>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    58fa:	f1 01       	movw	r30, r2
    58fc:	ee 0f       	add	r30, r30
    58fe:	ff 1f       	adc	r31, r31
    5900:	ee 0f       	add	r30, r30
    5902:	ff 1f       	adc	r31, r31
    5904:	ec 5c       	subi	r30, 0xCC	; 204
    5906:	fc 4f       	sbci	r31, 0xFC	; 252
    5908:	85 91       	lpm	r24, Z+
    590a:	94 91       	lpm	r25, Z+
    590c:	28 2f       	mov	r18, r24
    590e:	89 2f       	mov	r24, r25
    5910:	62 2e       	mov	r6, r18
    5912:	78 2e       	mov	r7, r24
	MB_Frame[MB_N][2] = Qt/8+(Qt%8>0);
    5914:	20 e0       	ldi	r18, 0x00	; 0
    5916:	cd 01       	movw	r24, r26
    5918:	87 70       	andi	r24, 0x07	; 7
    591a:	90 70       	andi	r25, 0x00	; 0
    591c:	89 2b       	or	r24, r25
    591e:	09 f0       	breq	.+2      	; 0x5922 <MB_S_Timer_ISR+0x2c0>
    5920:	21 e0       	ldi	r18, 0x01	; 1
    5922:	cd 01       	movw	r24, r26
    5924:	96 95       	lsr	r25
    5926:	87 95       	ror	r24
    5928:	96 95       	lsr	r25
    592a:	87 95       	ror	r24
    592c:	96 95       	lsr	r25
    592e:	87 95       	ror	r24
    5930:	82 0f       	add	r24, r18
    5932:	66 0f       	add	r22, r22
    5934:	77 1f       	adc	r23, r23
    5936:	6b 5d       	subi	r22, 0xDB	; 219
    5938:	74 4f       	sbci	r23, 0xF4	; 244
    593a:	fb 01       	movw	r30, r22
    593c:	80 83       	st	Z, r24
	MB_Frame_Sz[MB_N] = MB_Frame[MB_N][2]+5;
    593e:	8b 5f       	subi	r24, 0xFB	; 251
    5940:	f2 01       	movw	r30, r4
    5942:	80 83       	st	Z, r24
	for (uint8_t i=0; i<Qt; i++) {
    5944:	10 97       	sbiw	r26, 0x00	; 0
    5946:	09 f4       	brne	.+2      	; 0x594a <MB_S_Timer_ISR+0x2e8>
    5948:	22 c1       	rjmp	.+580    	; 0x5b8e <MB_S_Timer_ISR+0x52c>
    594a:	60 e0       	ldi	r22, 0x00	; 0
    594c:	20 e0       	ldi	r18, 0x00	; 0
    594e:	30 e0       	ldi	r19, 0x00	; 0
    5950:	80 e0       	ldi	r24, 0x00	; 0
    5952:	90 e0       	ldi	r25, 0x00	; 0
		uint16_t j = StartAddr+i;
		uint8_t Byte=3+i/8, Bit=1<<i%8;
    5954:	e1 e0       	ldi	r30, 0x01	; 1
    5956:	4e 2e       	mov	r4, r30
    5958:	51 2c       	mov	r5, r1
    595a:	10 c0       	rjmp	.+32     	; 0x597c <MB_S_Timer_ISR+0x31a>
		if (Discr[j/8] &(1<<j%8))
			MB_Frame[MB_N][Byte] |=Bit;
    595c:	f7 01       	movw	r30, r14
    595e:	e4 0f       	add	r30, r20
    5960:	f1 1d       	adc	r31, r1
    5962:	ed 5d       	subi	r30, 0xDD	; 221
    5964:	f4 4f       	sbci	r31, 0xF4	; 244
    5966:	80 81       	ld	r24, Z
    5968:	85 2b       	or	r24, r21
    596a:	80 83       	st	Z, r24
	if (StartAddr+Qt>(MB_Frame[MB_N][1]==1?prw(&Modbus_Map[MB_N].Coil_Qt):prw(&Modbus_Map[MB_N].Input_Qt)))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
	MB_Frame[MB_N][2] = Qt/8+(Qt%8>0);
	MB_Frame_Sz[MB_N] = MB_Frame[MB_N][2]+5;
	for (uint8_t i=0; i<Qt; i++) {
    596c:	6f 5f       	subi	r22, 0xFF	; 255
    596e:	86 2f       	mov	r24, r22
    5970:	90 e0       	ldi	r25, 0x00	; 0
    5972:	9c 01       	movw	r18, r24
    5974:	8a 17       	cp	r24, r26
    5976:	9b 07       	cpc	r25, r27
    5978:	08 f0       	brcs	.+2      	; 0x597c <MB_S_Timer_ISR+0x31a>
    597a:	09 c1       	rjmp	.+530    	; 0x5b8e <MB_S_Timer_ISR+0x52c>
		uint16_t j = StartAddr+i;
    597c:	28 0d       	add	r18, r8
    597e:	39 1d       	adc	r19, r9
		uint8_t Byte=3+i/8, Bit=1<<i%8;
    5980:	46 2f       	mov	r20, r22
    5982:	46 95       	lsr	r20
    5984:	46 95       	lsr	r20
    5986:	46 95       	lsr	r20
    5988:	4d 5f       	subi	r20, 0xFD	; 253
    598a:	87 70       	andi	r24, 0x07	; 7
    598c:	90 70       	andi	r25, 0x00	; 0
    598e:	f2 01       	movw	r30, r4
    5990:	02 c0       	rjmp	.+4      	; 0x5996 <MB_S_Timer_ISR+0x334>
    5992:	ee 0f       	add	r30, r30
    5994:	ff 1f       	adc	r31, r31
    5996:	8a 95       	dec	r24
    5998:	e2 f7       	brpl	.-8      	; 0x5992 <MB_S_Timer_ISR+0x330>
    599a:	5e 2f       	mov	r21, r30
		if (Discr[j/8] &(1<<j%8))
    599c:	f9 01       	movw	r30, r18
    599e:	f6 95       	lsr	r31
    59a0:	e7 95       	ror	r30
    59a2:	f6 95       	lsr	r31
    59a4:	e7 95       	ror	r30
    59a6:	f6 95       	lsr	r31
    59a8:	e7 95       	ror	r30
    59aa:	e6 0d       	add	r30, r6
    59ac:	f7 1d       	adc	r31, r7
    59ae:	80 81       	ld	r24, Z
    59b0:	90 e0       	ldi	r25, 0x00	; 0
    59b2:	27 70       	andi	r18, 0x07	; 7
    59b4:	30 70       	andi	r19, 0x00	; 0
    59b6:	02 c0       	rjmp	.+4      	; 0x59bc <MB_S_Timer_ISR+0x35a>
    59b8:	95 95       	asr	r25
    59ba:	87 95       	ror	r24
    59bc:	2a 95       	dec	r18
    59be:	e2 f7       	brpl	.-8      	; 0x59b8 <MB_S_Timer_ISR+0x356>
    59c0:	80 fd       	sbrc	r24, 0
    59c2:	cc cf       	rjmp	.-104    	; 0x595c <MB_S_Timer_ISR+0x2fa>
			MB_Frame[MB_N][Byte] |=Bit;
		else
			MB_Frame[MB_N][Byte] &=~Bit;
    59c4:	f7 01       	movw	r30, r14
    59c6:	e4 0f       	add	r30, r20
    59c8:	f1 1d       	adc	r31, r1
    59ca:	ed 5d       	subi	r30, 0xDD	; 221
    59cc:	f4 4f       	sbci	r31, 0xF4	; 244
    59ce:	50 95       	com	r21
    59d0:	80 81       	ld	r24, Z
    59d2:	58 23       	and	r21, r24
    59d4:	50 83       	st	Z, r21
    59d6:	ca cf       	rjmp	.-108    	; 0x596c <MB_S_Timer_ISR+0x30a>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_PresetSingle(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame_Sz[MB_N]!=8)
    59d8:	68 85       	ldd	r22, Y+8	; 0x08
    59da:	79 85       	ldd	r23, Y+9	; 0x09
    59dc:	6b 5f       	subi	r22, 0xFB	; 251
    59de:	78 4f       	sbci	r23, 0xF8	; 248
    59e0:	fb 01       	movw	r30, r22
    59e2:	c0 80       	ld	r12, Z
    59e4:	f8 e0       	ldi	r31, 0x08	; 8
    59e6:	cf 16       	cp	r12, r31
    59e8:	09 f0       	breq	.+2      	; 0x59ec <MB_S_Timer_ISR+0x38a>
    59ea:	f3 ce       	rjmp	.-538    	; 0x57d2 <MB_S_Timer_ISR+0x170>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    59ec:	f3 01       	movw	r30, r6
    59ee:	e6 5c       	subi	r30, 0xC6	; 198
    59f0:	fc 4f       	sbci	r31, 0xFC	; 252
    59f2:	25 91       	lpm	r18, Z+
    59f4:	34 91       	lpm	r19, Z+
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+1>prw(&Modbus_Map[MB_N].HoldReg_Qt))
    59f6:	c4 01       	movw	r24, r8
    59f8:	01 96       	adiw	r24, 0x01	; 1
    59fa:	28 17       	cp	r18, r24
    59fc:	39 07       	cpc	r19, r25
    59fe:	08 f4       	brcc	.+2      	; 0x5a02 <MB_S_Timer_ISR+0x3a0>
    5a00:	02 c1       	rjmp	.+516    	; 0x5c06 <MB_S_Timer_ISR+0x5a4>
		return MB_Frame[MB_N][2]=IllegAddr;
	MB_Frame_Sz[MB_N] = 8;
    5a02:	db 01       	movw	r26, r22
    5a04:	cc 92       	st	X, r12

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5a06:	e8 85       	ldd	r30, Y+8	; 0x08
    5a08:	f9 85       	ldd	r31, Y+9	; 0x09
    5a0a:	ee 0f       	add	r30, r30
    5a0c:	ff 1f       	adc	r31, r31
    5a0e:	ee 0f       	add	r30, r30
    5a10:	ff 1f       	adc	r31, r31
    5a12:	ee 0f       	add	r30, r30
    5a14:	ff 1f       	adc	r31, r31
    5a16:	ee 0f       	add	r30, r30
    5a18:	ff 1f       	adc	r31, r31
    5a1a:	e8 5c       	subi	r30, 0xC8	; 200
    5a1c:	fc 4f       	sbci	r31, 0xFC	; 252
    5a1e:	85 91       	lpm	r24, Z+
    5a20:	94 91       	lpm	r25, Z+
	*((uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+StartAddr) = MB_FrameReg(MB_N, 4);
    5a22:	88 0c       	add	r8, r8
    5a24:	99 1c       	adc	r9, r9
    5a26:	88 0e       	add	r8, r24
    5a28:	99 1e       	adc	r9, r25
    5a2a:	28 85       	ldd	r18, Y+8	; 0x08
    5a2c:	39 85       	ldd	r19, Y+9	; 0x09
    5a2e:	f2 2f       	mov	r31, r18
    5a30:	ee 27       	eor	r30, r30
    5a32:	e9 5d       	subi	r30, 0xD9	; 217
    5a34:	f4 4f       	sbci	r31, 0xF4	; 244
    5a36:	90 81       	ld	r25, Z
    5a38:	80 e0       	ldi	r24, 0x00	; 0
    5a3a:	da 01       	movw	r26, r20
    5a3c:	15 96       	adiw	r26, 0x05	; 5
    5a3e:	2c 91       	ld	r18, X
    5a40:	30 e0       	ldi	r19, 0x00	; 0
    5a42:	82 2b       	or	r24, r18
    5a44:	93 2b       	or	r25, r19
    5a46:	f4 01       	movw	r30, r8
    5a48:	91 83       	std	Z+1, r25	; 0x01
    5a4a:	80 83       	st	Z, r24
    5a4c:	90 e0       	ldi	r25, 0x00	; 0
    5a4e:	c4 ce       	rjmp	.-632    	; 0x57d8 <MB_S_Timer_ISR+0x176>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_Preset(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][6]+9 || MB_Frame[MB_N][5]*2!=MB_Frame[MB_N][6])
    5a50:	fa 01       	movw	r30, r20
    5a52:	86 81       	ldd	r24, Z+6	; 0x06
    5a54:	28 2f       	mov	r18, r24
    5a56:	30 e0       	ldi	r19, 0x00	; 0
    5a58:	3f 83       	std	Y+7, r19	; 0x07
    5a5a:	2e 83       	std	Y+6, r18	; 0x06
    5a5c:	85 e0       	ldi	r24, 0x05	; 5
    5a5e:	48 2e       	mov	r4, r24
    5a60:	87 e0       	ldi	r24, 0x07	; 7
    5a62:	58 2e       	mov	r5, r24
    5a64:	88 85       	ldd	r24, Y+8	; 0x08
    5a66:	99 85       	ldd	r25, Y+9	; 0x09
    5a68:	48 0e       	add	r4, r24
    5a6a:	59 1e       	adc	r5, r25
    5a6c:	f2 01       	movw	r30, r4
    5a6e:	80 81       	ld	r24, Z
    5a70:	90 e0       	ldi	r25, 0x00	; 0
    5a72:	27 5f       	subi	r18, 0xF7	; 247
    5a74:	3f 4f       	sbci	r19, 0xFF	; 255
    5a76:	82 17       	cp	r24, r18
    5a78:	93 07       	cpc	r25, r19
    5a7a:	99 f1       	breq	.+102    	; 0x5ae2 <MB_S_Timer_ISR+0x480>
		return MB_Frame[MB_N][2]=IllegData;
    5a7c:	66 0f       	add	r22, r22
    5a7e:	77 1f       	adc	r23, r23
    5a80:	6b 5d       	subi	r22, 0xDB	; 219
    5a82:	74 4f       	sbci	r23, 0xF4	; 244
    5a84:	83 e0       	ldi	r24, 0x03	; 3
    5a86:	db 01       	movw	r26, r22
    5a88:	8c 93       	st	X, r24
    5a8a:	93 e0       	ldi	r25, 0x03	; 3
    5a8c:	a5 ce       	rjmp	.-694    	; 0x57d8 <MB_S_Timer_ISR+0x176>
    5a8e:	28 85       	ldd	r18, Y+8	; 0x08
    5a90:	39 85       	ldd	r19, Y+9	; 0x09
    5a92:	f2 2f       	mov	r31, r18
    5a94:	ee 27       	eor	r30, r30
    5a96:	e9 5d       	subi	r30, 0xD9	; 217
    5a98:	f4 4f       	sbci	r31, 0xF4	; 244
    5a9a:	e0 81       	ld	r30, Z
    5a9c:	da 01       	movw	r26, r20
    5a9e:	15 96       	adiw	r26, 0x05	; 5
    5aa0:	fc 91       	ld	r31, X
    5aa2:	15 97       	sbiw	r26, 0x05	; 5
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_Force(uint8_t MB_N, uint16_t StartAddr)
{
	uint16_t Qt = MB_FrameReg(MB_N, 4);
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][6]+9 || Qt/8+(Qt%8>0)!=MB_Frame[MB_N][6])
    5aa4:	16 96       	adiw	r26, 0x06	; 6
    5aa6:	2c 91       	ld	r18, X
    5aa8:	a5 e0       	ldi	r26, 0x05	; 5
    5aaa:	4a 2e       	mov	r4, r26
    5aac:	a7 e0       	ldi	r26, 0x07	; 7
    5aae:	5a 2e       	mov	r5, r26
    5ab0:	88 85       	ldd	r24, Y+8	; 0x08
    5ab2:	99 85       	ldd	r25, Y+9	; 0x09
    5ab4:	48 0e       	add	r4, r24
    5ab6:	59 1e       	adc	r5, r25
    5ab8:	d2 01       	movw	r26, r4
    5aba:	8c 91       	ld	r24, X
    5abc:	90 e0       	ldi	r25, 0x00	; 0
    5abe:	42 2f       	mov	r20, r18
    5ac0:	50 e0       	ldi	r21, 0x00	; 0
    5ac2:	9a 01       	movw	r18, r20
    5ac4:	27 5f       	subi	r18, 0xF7	; 247
    5ac6:	3f 4f       	sbci	r19, 0xFF	; 255
    5ac8:	82 17       	cp	r24, r18
    5aca:	93 07       	cpc	r25, r19
    5acc:	09 f4       	brne	.+2      	; 0x5ad0 <MB_S_Timer_ISR+0x46e>
    5ace:	61 c0       	rjmp	.+194    	; 0x5b92 <MB_S_Timer_ISR+0x530>
		return MB_Frame[MB_N][2]=IllegData;
    5ad0:	66 0f       	add	r22, r22
    5ad2:	77 1f       	adc	r23, r23
    5ad4:	6b 5d       	subi	r22, 0xDB	; 219
    5ad6:	74 4f       	sbci	r23, 0xF4	; 244
    5ad8:	83 e0       	ldi	r24, 0x03	; 3
    5ada:	fb 01       	movw	r30, r22
    5adc:	80 83       	st	Z, r24
    5ade:	93 e0       	ldi	r25, 0x03	; 3
    5ae0:	7b ce       	rjmp	.-778    	; 0x57d8 <MB_S_Timer_ISR+0x176>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_Preset(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][6]+9 || MB_Frame[MB_N][5]*2!=MB_Frame[MB_N][6])
    5ae2:	9a 01       	movw	r18, r20
    5ae4:	2b 5f       	subi	r18, 0xFB	; 251
    5ae6:	3f 4f       	sbci	r19, 0xFF	; 255
    5ae8:	3c 83       	std	Y+4, r19	; 0x04
    5aea:	2b 83       	std	Y+3, r18	; 0x03
    5aec:	fa 01       	movw	r30, r20
    5aee:	c5 80       	ldd	r12, Z+5	; 0x05
    5af0:	2c 2d       	mov	r18, r12
    5af2:	30 e0       	ldi	r19, 0x00	; 0
    5af4:	c9 01       	movw	r24, r18
    5af6:	88 0f       	add	r24, r24
    5af8:	99 1f       	adc	r25, r25
    5afa:	ee 81       	ldd	r30, Y+6	; 0x06
    5afc:	ff 81       	ldd	r31, Y+7	; 0x07
    5afe:	e8 17       	cp	r30, r24
    5b00:	f9 07       	cpc	r31, r25
    5b02:	09 f0       	breq	.+2      	; 0x5b06 <MB_S_Timer_ISR+0x4a4>
    5b04:	bb cf       	rjmp	.-138    	; 0x5a7c <MB_S_Timer_ISR+0x41a>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    5b06:	f3 01       	movw	r30, r6
    5b08:	e6 5c       	subi	r30, 0xC6	; 198
    5b0a:	fc 4f       	sbci	r31, 0xFC	; 252
    5b0c:	85 91       	lpm	r24, Z+
    5b0e:	94 91       	lpm	r25, Z+
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+MB_Frame[MB_N][5]>prw(&Modbus_Map[MB_N].HoldReg_Qt))
    5b10:	28 0d       	add	r18, r8
    5b12:	39 1d       	adc	r19, r9
    5b14:	82 17       	cp	r24, r18
    5b16:	93 07       	cpc	r25, r19
    5b18:	08 f4       	brcc	.+2      	; 0x5b1c <MB_S_Timer_ISR+0x4ba>
    5b1a:	75 c0       	rjmp	.+234    	; 0x5c06 <MB_S_Timer_ISR+0x5a4>
		return MB_Frame[MB_N][2]=IllegAddr;
	MB_Frame_Sz[MB_N] = 8;
    5b1c:	88 e0       	ldi	r24, 0x08	; 8
    5b1e:	f2 01       	movw	r30, r4
    5b20:	80 83       	st	Z, r24

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5b22:	e8 85       	ldd	r30, Y+8	; 0x08
    5b24:	f9 85       	ldd	r31, Y+9	; 0x09
    5b26:	ee 0f       	add	r30, r30
    5b28:	ff 1f       	adc	r31, r31
    5b2a:	ee 0f       	add	r30, r30
    5b2c:	ff 1f       	adc	r31, r31
    5b2e:	ee 0f       	add	r30, r30
    5b30:	ff 1f       	adc	r31, r31
    5b32:	ee 0f       	add	r30, r30
    5b34:	ff 1f       	adc	r31, r31
    5b36:	e8 5c       	subi	r30, 0xC8	; 200
    5b38:	fc 4f       	sbci	r31, 0xFC	; 252
    5b3a:	45 90       	lpm	r4, Z+
    5b3c:	54 90       	lpm	r5, Z+
	uint16_t *HoldReg = prp(&Modbus_Map[MB_N].HoldReg);
	for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    5b3e:	cc 20       	and	r12, r12
    5b40:	31 f1       	breq	.+76     	; 0x5b8e <MB_S_Timer_ISR+0x52c>
    5b42:	60 e0       	ldi	r22, 0x00	; 0
    5b44:	6b 80       	ldd	r6, Y+3	; 0x03
    5b46:	7c 80       	ldd	r7, Y+4	; 0x04
    5b48:	a6 2f       	mov	r26, r22
    5b4a:	b0 e0       	ldi	r27, 0x00	; 0
    5b4c:	cd 01       	movw	r24, r26
    5b4e:	88 0f       	add	r24, r24
    5b50:	99 1f       	adc	r25, r25
    5b52:	89 5f       	subi	r24, 0xF9	; 249
    5b54:	28 2f       	mov	r18, r24
    5b56:	30 e0       	ldi	r19, 0x00	; 0
		uint8_t j = i*2;
		HoldReg[StartAddr+i] = MB_FrameReg(MB_N, 7+j);
    5b58:	a8 0d       	add	r26, r8
    5b5a:	b9 1d       	adc	r27, r9
    5b5c:	aa 0f       	add	r26, r26
    5b5e:	bb 1f       	adc	r27, r27
    5b60:	a4 0d       	add	r26, r4
    5b62:	b5 1d       	adc	r27, r5
    5b64:	fa 01       	movw	r30, r20
    5b66:	e2 0f       	add	r30, r18
    5b68:	f3 1f       	adc	r31, r19
    5b6a:	81 81       	ldd	r24, Z+1	; 0x01
    5b6c:	90 e0       	ldi	r25, 0x00	; 0
    5b6e:	2e 0d       	add	r18, r14
    5b70:	3f 1d       	adc	r19, r15
    5b72:	2d 5d       	subi	r18, 0xDD	; 221
    5b74:	34 4f       	sbci	r19, 0xF4	; 244
    5b76:	f9 01       	movw	r30, r18
    5b78:	30 81       	ld	r19, Z
    5b7a:	20 e0       	ldi	r18, 0x00	; 0
    5b7c:	82 2b       	or	r24, r18
    5b7e:	93 2b       	or	r25, r19
    5b80:	8d 93       	st	X+, r24
    5b82:	9c 93       	st	X, r25
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+MB_Frame[MB_N][5]>prw(&Modbus_Map[MB_N].HoldReg_Qt))
		return MB_Frame[MB_N][2]=IllegAddr;
	MB_Frame_Sz[MB_N] = 8;
	uint16_t *HoldReg = prp(&Modbus_Map[MB_N].HoldReg);
	for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    5b84:	6f 5f       	subi	r22, 0xFF	; 255
    5b86:	d3 01       	movw	r26, r6
    5b88:	8c 91       	ld	r24, X
    5b8a:	68 17       	cp	r22, r24
    5b8c:	e8 f2       	brcs	.-70     	; 0x5b48 <MB_S_Timer_ISR+0x4e6>
		break;
	case 0x10:
		Err = MB_S_Preset(MB_N, StartAddr);
		break;
	default:
		Err = MB_Frame[MB_N][2] = IllegFunc;
    5b8e:	90 e0       	ldi	r25, 0x00	; 0
    5b90:	23 ce       	rjmp	.-954    	; 0x57d8 <MB_S_Timer_ISR+0x176>
    5b92:	9e 2f       	mov	r25, r30
    5b94:	80 e0       	ldi	r24, 0x00	; 0
    5b96:	af 2f       	mov	r26, r31
    5b98:	b0 e0       	ldi	r27, 0x00	; 0
    5b9a:	a8 2b       	or	r26, r24
    5b9c:	b9 2b       	or	r27, r25
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_Force(uint8_t MB_N, uint16_t StartAddr)
{
	uint16_t Qt = MB_FrameReg(MB_N, 4);
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][6]+9 || Qt/8+(Qt%8>0)!=MB_Frame[MB_N][6])
    5b9e:	20 e0       	ldi	r18, 0x00	; 0
    5ba0:	30 e0       	ldi	r19, 0x00	; 0
    5ba2:	cd 01       	movw	r24, r26
    5ba4:	87 70       	andi	r24, 0x07	; 7
    5ba6:	90 70       	andi	r25, 0x00	; 0
    5ba8:	89 2b       	or	r24, r25
    5baa:	11 f0       	breq	.+4      	; 0x5bb0 <MB_S_Timer_ISR+0x54e>
    5bac:	21 e0       	ldi	r18, 0x01	; 1
    5bae:	30 e0       	ldi	r19, 0x00	; 0
    5bb0:	cd 01       	movw	r24, r26
    5bb2:	96 95       	lsr	r25
    5bb4:	87 95       	ror	r24
    5bb6:	96 95       	lsr	r25
    5bb8:	87 95       	ror	r24
    5bba:	96 95       	lsr	r25
    5bbc:	87 95       	ror	r24
    5bbe:	28 0f       	add	r18, r24
    5bc0:	39 1f       	adc	r19, r25
    5bc2:	24 17       	cp	r18, r20
    5bc4:	35 07       	cpc	r19, r21
    5bc6:	09 f0       	breq	.+2      	; 0x5bca <MB_S_Timer_ISR+0x568>
    5bc8:	83 cf       	rjmp	.-250    	; 0x5ad0 <MB_S_Timer_ISR+0x46e>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    5bca:	e8 85       	ldd	r30, Y+8	; 0x08
    5bcc:	f9 85       	ldd	r31, Y+9	; 0x09
    5bce:	ee 0f       	add	r30, r30
    5bd0:	ff 1f       	adc	r31, r31
    5bd2:	ee 0f       	add	r30, r30
    5bd4:	ff 1f       	adc	r31, r31
    5bd6:	ee 0f       	add	r30, r30
    5bd8:	ff 1f       	adc	r31, r31
    5bda:	ee 0f       	add	r30, r30
    5bdc:	ff 1f       	adc	r31, r31
    5bde:	ee 5c       	subi	r30, 0xCE	; 206
    5be0:	fc 4f       	sbci	r31, 0xFC	; 252
    5be2:	25 91       	lpm	r18, Z+
    5be4:	34 91       	lpm	r19, Z+
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+Qt > prw(&Modbus_Map[MB_N].Coil_Qt))
    5be6:	cd 01       	movw	r24, r26
    5be8:	88 0d       	add	r24, r8
    5bea:	99 1d       	adc	r25, r9
    5bec:	28 17       	cp	r18, r24
    5bee:	39 07       	cpc	r19, r25
    5bf0:	08 f0       	brcs	.+2      	; 0x5bf4 <MB_S_Timer_ISR+0x592>
    5bf2:	5d c0       	rjmp	.+186    	; 0x5cae <MB_S_Timer_ISR+0x64c>
		return MB_Frame[MB_N][2]=IllegAddr;
    5bf4:	66 0f       	add	r22, r22
    5bf6:	77 1f       	adc	r23, r23
    5bf8:	6b 5d       	subi	r22, 0xDB	; 219
    5bfa:	74 4f       	sbci	r23, 0xF4	; 244
    5bfc:	82 e0       	ldi	r24, 0x02	; 2
    5bfe:	db 01       	movw	r26, r22
    5c00:	8c 93       	st	X, r24
    5c02:	92 e0       	ldi	r25, 0x02	; 2
    5c04:	e9 cd       	rjmp	.-1070   	; 0x57d8 <MB_S_Timer_ISR+0x176>
MB_S_Preset(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][6]+9 || MB_Frame[MB_N][5]*2!=MB_Frame[MB_N][6])
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+MB_Frame[MB_N][5]>prw(&Modbus_Map[MB_N].HoldReg_Qt))
		return MB_Frame[MB_N][2]=IllegAddr;
    5c06:	82 e0       	ldi	r24, 0x02	; 2
    5c08:	8c 93       	st	X, r24
    5c0a:	92 e0       	ldi	r25, 0x02	; 2
    5c0c:	e5 cd       	rjmp	.-1078   	; 0x57d8 <MB_S_Timer_ISR+0x176>
	if (MB_Frame[MB_N][0]==0)
		return 0xFF;
	if (MB_Frame_Sz[MB_N]!=8)
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+MB_Frame[MB_N][5]>(MB_Frame[MB_N][1]==3?prw(&Modbus_Map[MB_N].HoldReg_Qt):prw(&Modbus_Map[MB_N].InReg_Qt)))
		return MB_Frame[MB_N][2]=IllegAddr;
    5c0e:	66 0f       	add	r22, r22
    5c10:	77 1f       	adc	r23, r23
    5c12:	6b 5d       	subi	r22, 0xDB	; 219
    5c14:	74 4f       	sbci	r23, 0xF4	; 244
    5c16:	82 e0       	ldi	r24, 0x02	; 2
    5c18:	fb 01       	movw	r30, r22
    5c1a:	80 83       	st	Z, r24
    5c1c:	92 e0       	ldi	r25, 0x02	; 2
    5c1e:	dc cd       	rjmp	.-1096   	; 0x57d8 <MB_S_Timer_ISR+0x176>
{
	if (MB_Frame[MB_N][0]==0)
		return 0xFF;
	if (MB_Frame_Sz[MB_N]!=8)
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+MB_Frame[MB_N][5]>(MB_Frame[MB_N][1]==3?prw(&Modbus_Map[MB_N].HoldReg_Qt):prw(&Modbus_Map[MB_N].InReg_Qt)))
    5c20:	da 01       	movw	r26, r20
    5c22:	15 96       	adiw	r26, 0x05	; 5
    5c24:	8c 91       	ld	r24, X
    5c26:	33 30       	cpi	r19, 0x03	; 3
    5c28:	09 f4       	brne	.+2      	; 0x5c2c <MB_S_Timer_ISR+0x5ca>
    5c2a:	ab c0       	rjmp	.+342    	; 0x5d82 <MB_S_Timer_ISR+0x720>
    5c2c:	f3 01       	movw	r30, r6
    5c2e:	e2 5c       	subi	r30, 0xC2	; 194
    5c30:	fc 4f       	sbci	r31, 0xFC	; 252
    5c32:	45 91       	lpm	r20, Z+
    5c34:	54 91       	lpm	r21, Z+
    5c36:	a8 2f       	mov	r26, r24
    5c38:	b0 e0       	ldi	r27, 0x00	; 0
    5c3a:	c4 01       	movw	r24, r8
    5c3c:	8a 0f       	add	r24, r26
    5c3e:	9b 1f       	adc	r25, r27
    5c40:	48 17       	cp	r20, r24
    5c42:	59 07       	cpc	r21, r25
    5c44:	20 f3       	brcs	.-56     	; 0x5c0e <MB_S_Timer_ISR+0x5ac>
		return MB_Frame[MB_N][2]=IllegAddr;
	uint16_t *Reg = (uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg)) + StartAddr;
    5c46:	33 30       	cpi	r19, 0x03	; 3
    5c48:	09 f4       	brne	.+2      	; 0x5c4c <MB_S_Timer_ISR+0x5ea>
    5c4a:	a9 c0       	rjmp	.+338    	; 0x5d9e <MB_S_Timer_ISR+0x73c>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5c4c:	f3 01       	movw	r30, r6
    5c4e:	e4 5c       	subi	r30, 0xC4	; 196
    5c50:	fc 4f       	sbci	r31, 0xFC	; 252
    5c52:	85 91       	lpm	r24, Z+
    5c54:	94 91       	lpm	r25, Z+
    5c56:	94 01       	movw	r18, r8
    5c58:	22 0f       	add	r18, r18
    5c5a:	33 1f       	adc	r19, r19
    5c5c:	28 0f       	add	r18, r24
    5c5e:	39 1f       	adc	r19, r25
	MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][2] = MB_Frame[MB_N][5]*2) + 5;
    5c60:	cd 01       	movw	r24, r26
    5c62:	88 0f       	add	r24, r24
    5c64:	99 1f       	adc	r25, r25
    5c66:	66 0f       	add	r22, r22
    5c68:	77 1f       	adc	r23, r23
    5c6a:	6b 5d       	subi	r22, 0xDB	; 219
    5c6c:	74 4f       	sbci	r23, 0xF4	; 244
    5c6e:	db 01       	movw	r26, r22
    5c70:	8c 93       	st	X, r24
    5c72:	8b 5f       	subi	r24, 0xFB	; 251
    5c74:	f2 01       	movw	r30, r4
    5c76:	80 83       	st	Z, r24
	uint8_t Qt = MB_Frame[MB_N][5];
    5c78:	f7 01       	movw	r30, r14
    5c7a:	ed 5d       	subi	r30, 0xDD	; 221
    5c7c:	f4 4f       	sbci	r31, 0xF4	; 244
    5c7e:	45 81       	ldd	r20, Z+5	; 0x05
	for (uint8_t i=0; i<Qt; i++) {
    5c80:	44 23       	and	r20, r20
    5c82:	09 f4       	brne	.+2      	; 0x5c86 <MB_S_Timer_ISR+0x624>
    5c84:	84 cf       	rjmp	.-248    	; 0x5b8e <MB_S_Timer_ISR+0x52c>
    5c86:	d9 01       	movw	r26, r18
    5c88:	90 e0       	ldi	r25, 0x00	; 0
		uint8_t j = i*2;
		MB_Frame[MB_N][3+j] = Reg[i]>>8;
    5c8a:	9f 01       	movw	r18, r30
    5c8c:	89 2f       	mov	r24, r25
    5c8e:	88 0f       	add	r24, r24
    5c90:	f9 01       	movw	r30, r18
    5c92:	e8 0f       	add	r30, r24
    5c94:	f1 1d       	adc	r31, r1
    5c96:	11 96       	adiw	r26, 0x01	; 1
    5c98:	8c 91       	ld	r24, X
    5c9a:	11 97       	sbiw	r26, 0x01	; 1
    5c9c:	83 83       	std	Z+3, r24	; 0x03
		MB_Frame[MB_N][4+j] = Reg[i];
    5c9e:	8c 91       	ld	r24, X
    5ca0:	84 83       	std	Z+4, r24	; 0x04
	if (StartAddr+MB_Frame[MB_N][5]>(MB_Frame[MB_N][1]==3?prw(&Modbus_Map[MB_N].HoldReg_Qt):prw(&Modbus_Map[MB_N].InReg_Qt)))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint16_t *Reg = (uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg)) + StartAddr;
	MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][2] = MB_Frame[MB_N][5]*2) + 5;
	uint8_t Qt = MB_Frame[MB_N][5];
	for (uint8_t i=0; i<Qt; i++) {
    5ca2:	9f 5f       	subi	r25, 0xFF	; 255
    5ca4:	12 96       	adiw	r26, 0x02	; 2
    5ca6:	94 17       	cp	r25, r20
    5ca8:	88 f3       	brcs	.-30     	; 0x5c8c <MB_S_Timer_ISR+0x62a>
		break;
	case 0x10:
		Err = MB_S_Preset(MB_N, StartAddr);
		break;
	default:
		Err = MB_Frame[MB_N][2] = IllegFunc;
    5caa:	90 e0       	ldi	r25, 0x00	; 0
    5cac:	95 cd       	rjmp	.-1238   	; 0x57d8 <MB_S_Timer_ISR+0x176>
    5cae:	93 01       	movw	r18, r6
    5cb0:	20 5d       	subi	r18, 0xD0	; 208
    5cb2:	3c 4f       	sbci	r19, 0xFC	; 252
    5cb4:	f9 01       	movw	r30, r18
    5cb6:	85 91       	lpm	r24, Z+
    5cb8:	94 91       	lpm	r25, Z+
    5cba:	9a 83       	std	Y+2, r25	; 0x02
    5cbc:	89 83       	std	Y+1, r24	; 0x01
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][6]+9 || Qt/8+(Qt%8>0)!=MB_Frame[MB_N][6])
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+Qt > prw(&Modbus_Map[MB_N].Coil_Qt))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Coil = prp(&Modbus_Map[MB_N].Coil);
	MB_Frame_Sz[MB_N] = 8;
    5cbe:	88 e0       	ldi	r24, 0x08	; 8
    5cc0:	f2 01       	movw	r30, r4
    5cc2:	80 83       	st	Z, r24
	for (uint8_t i=0; i<Qt; i++) {
    5cc4:	10 97       	sbiw	r26, 0x00	; 0
    5cc6:	09 f4       	brne	.+2      	; 0x5cca <MB_S_Timer_ISR+0x668>
    5cc8:	62 cf       	rjmp	.-316    	; 0x5b8e <MB_S_Timer_ISR+0x52c>
    5cca:	cc 24       	eor	r12, r12
    5ccc:	80 e0       	ldi	r24, 0x00	; 0
    5cce:	90 e0       	ldi	r25, 0x00	; 0
    5cd0:	20 e0       	ldi	r18, 0x00	; 0
    5cd2:	30 e0       	ldi	r19, 0x00	; 0
		uint16_t j = StartAddr+i;
		uint16_t Byte=j/8, Bit=1<<j%8;
    5cd4:	e1 e0       	ldi	r30, 0x01	; 1
    5cd6:	4e 2e       	mov	r4, r30
    5cd8:	51 2c       	mov	r5, r1
		if (MB_Frame[MB_N][7+i/8] &(1<<i%8))
    5cda:	73 e2       	ldi	r23, 0x23	; 35
    5cdc:	67 2e       	mov	r6, r23
    5cde:	7b e0       	ldi	r23, 0x0B	; 11
    5ce0:	77 2e       	mov	r7, r23
    5ce2:	6e 0c       	add	r6, r14
    5ce4:	7f 1c       	adc	r7, r15
    5ce6:	10 c0       	rjmp	.+32     	; 0x5d08 <MB_S_Timer_ISR+0x6a6>
			Coil[Byte] |=Bit;
    5ce8:	29 81       	ldd	r18, Y+1	; 0x01
    5cea:	3a 81       	ldd	r19, Y+2	; 0x02
    5cec:	24 0f       	add	r18, r20
    5cee:	35 1f       	adc	r19, r21
    5cf0:	f9 01       	movw	r30, r18
    5cf2:	80 81       	ld	r24, Z
    5cf4:	86 2b       	or	r24, r22
    5cf6:	80 83       	st	Z, r24
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+Qt > prw(&Modbus_Map[MB_N].Coil_Qt))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Coil = prp(&Modbus_Map[MB_N].Coil);
	MB_Frame_Sz[MB_N] = 8;
	for (uint8_t i=0; i<Qt; i++) {
    5cf8:	c3 94       	inc	r12
    5cfa:	2c 2d       	mov	r18, r12
    5cfc:	30 e0       	ldi	r19, 0x00	; 0
    5cfe:	c9 01       	movw	r24, r18
    5d00:	2a 17       	cp	r18, r26
    5d02:	3b 07       	cpc	r19, r27
    5d04:	08 f0       	brcs	.+2      	; 0x5d08 <MB_S_Timer_ISR+0x6a6>
    5d06:	43 cf       	rjmp	.-378    	; 0x5b8e <MB_S_Timer_ISR+0x52c>
		uint16_t j = StartAddr+i;
    5d08:	88 0d       	add	r24, r8
    5d0a:	99 1d       	adc	r25, r9
		uint16_t Byte=j/8, Bit=1<<j%8;
    5d0c:	ac 01       	movw	r20, r24
    5d0e:	56 95       	lsr	r21
    5d10:	47 95       	ror	r20
    5d12:	56 95       	lsr	r21
    5d14:	47 95       	ror	r20
    5d16:	56 95       	lsr	r21
    5d18:	47 95       	ror	r20
    5d1a:	87 70       	andi	r24, 0x07	; 7
    5d1c:	90 70       	andi	r25, 0x00	; 0
    5d1e:	b2 01       	movw	r22, r4
    5d20:	02 c0       	rjmp	.+4      	; 0x5d26 <MB_S_Timer_ISR+0x6c4>
    5d22:	66 0f       	add	r22, r22
    5d24:	77 1f       	adc	r23, r23
    5d26:	8a 95       	dec	r24
    5d28:	e2 f7       	brpl	.-8      	; 0x5d22 <MB_S_Timer_ISR+0x6c0>
		if (MB_Frame[MB_N][7+i/8] &(1<<i%8))
    5d2a:	8c 2d       	mov	r24, r12
    5d2c:	86 95       	lsr	r24
    5d2e:	86 95       	lsr	r24
    5d30:	86 95       	lsr	r24
    5d32:	f3 01       	movw	r30, r6
    5d34:	e8 0f       	add	r30, r24
    5d36:	f1 1d       	adc	r31, r1
    5d38:	87 81       	ldd	r24, Z+7	; 0x07
    5d3a:	90 e0       	ldi	r25, 0x00	; 0
    5d3c:	27 70       	andi	r18, 0x07	; 7
    5d3e:	30 70       	andi	r19, 0x00	; 0
    5d40:	02 c0       	rjmp	.+4      	; 0x5d46 <MB_S_Timer_ISR+0x6e4>
    5d42:	95 95       	asr	r25
    5d44:	87 95       	ror	r24
    5d46:	2a 95       	dec	r18
    5d48:	e2 f7       	brpl	.-8      	; 0x5d42 <MB_S_Timer_ISR+0x6e0>
    5d4a:	80 fd       	sbrc	r24, 0
    5d4c:	cd cf       	rjmp	.-102    	; 0x5ce8 <MB_S_Timer_ISR+0x686>
			Coil[Byte] |=Bit;
		else
			Coil[Byte] &=~Bit;
    5d4e:	29 81       	ldd	r18, Y+1	; 0x01
    5d50:	3a 81       	ldd	r19, Y+2	; 0x02
    5d52:	24 0f       	add	r18, r20
    5d54:	35 1f       	adc	r19, r21
    5d56:	96 2f       	mov	r25, r22
    5d58:	90 95       	com	r25
    5d5a:	f9 01       	movw	r30, r18
    5d5c:	80 81       	ld	r24, Z
    5d5e:	89 23       	and	r24, r25
    5d60:	80 83       	st	Z, r24
    5d62:	ca cf       	rjmp	.-108    	; 0x5cf8 <MB_S_Timer_ISR+0x696>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    5d64:	e8 85       	ldd	r30, Y+8	; 0x08
    5d66:	f9 85       	ldd	r31, Y+9	; 0x09
    5d68:	ee 0f       	add	r30, r30
    5d6a:	ff 1f       	adc	r31, r31
    5d6c:	ee 0f       	add	r30, r30
    5d6e:	ff 1f       	adc	r31, r31
    5d70:	ee 0f       	add	r30, r30
    5d72:	ff 1f       	adc	r31, r31
    5d74:	ee 0f       	add	r30, r30
    5d76:	ff 1f       	adc	r31, r31
    5d78:	ee 5c       	subi	r30, 0xCE	; 206
    5d7a:	fc 4f       	sbci	r31, 0xFC	; 252
    5d7c:	45 91       	lpm	r20, Z+
    5d7e:	54 91       	lpm	r21, Z+
    5d80:	b2 cd       	rjmp	.-1180   	; 0x58e6 <MB_S_Timer_ISR+0x284>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5d82:	f3 01       	movw	r30, r6
    5d84:	e6 5c       	subi	r30, 0xC6	; 198
    5d86:	fc 4f       	sbci	r31, 0xFC	; 252
    5d88:	45 91       	lpm	r20, Z+
    5d8a:	54 91       	lpm	r21, Z+
    5d8c:	54 cf       	rjmp	.-344    	; 0x5c36 <MB_S_Timer_ISR+0x5d4>
    5d8e:	f3 01       	movw	r30, r6
    5d90:	e0 5d       	subi	r30, 0xD0	; 208
    5d92:	fc 4f       	sbci	r31, 0xFC	; 252
    5d94:	85 91       	lpm	r24, Z+
    5d96:	94 91       	lpm	r25, Z+
    5d98:	28 2f       	mov	r18, r24
    5d9a:	89 2f       	mov	r24, r25
    5d9c:	b9 cd       	rjmp	.-1166   	; 0x5910 <MB_S_Timer_ISR+0x2ae>
    5d9e:	e8 85       	ldd	r30, Y+8	; 0x08
    5da0:	f9 85       	ldd	r31, Y+9	; 0x09
    5da2:	ee 0f       	add	r30, r30
    5da4:	ff 1f       	adc	r31, r31
    5da6:	ee 0f       	add	r30, r30
    5da8:	ff 1f       	adc	r31, r31
    5daa:	ee 0f       	add	r30, r30
    5dac:	ff 1f       	adc	r31, r31
    5dae:	ee 0f       	add	r30, r30
    5db0:	ff 1f       	adc	r31, r31
    5db2:	e8 5c       	subi	r30, 0xC8	; 200
    5db4:	fc 4f       	sbci	r31, 0xFC	; 252
    5db6:	85 91       	lpm	r24, Z+
    5db8:	94 91       	lpm	r25, Z+
    5dba:	4d cf       	rjmp	.-358    	; 0x5c56 <MB_S_Timer_ISR+0x5f4>

00005dbc <MB_S_Tx>:
    5dbc:	94 e1       	ldi	r25, 0x14	; 20
    5dbe:	89 9f       	mul	r24, r25
    5dc0:	c0 01       	movw	r24, r0
    5dc2:	11 24       	eor	r1, r1
    5dc4:	87 58       	subi	r24, 0x87	; 135
    5dc6:	92 4d       	sbci	r25, 0xD2	; 210
    5dc8:	fc 01       	movw	r30, r24
    5dca:	25 91       	lpm	r18, Z+
    5dcc:	34 91       	lpm	r19, Z+

// ~~~~~~~~~~~~~~~~~~
void
MB_S_Tx(uint8_t MB_N)
{
	USART_Func(MB_N, LED);
    5dce:	f9 01       	movw	r30, r18
    5dd0:	19 95       	eicall
}
    5dd2:	08 95       	ret

00005dd4 <MB_Slave_Off>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
MB_Slave_Off(uint8_t MB_N, uint8_t S_N)
{
    5dd4:	21 e0       	ldi	r18, 0x01	; 1
    5dd6:	30 e0       	ldi	r19, 0x00	; 0
    5dd8:	40 e0       	ldi	r20, 0x00	; 0
    5dda:	50 e0       	ldi	r21, 0x00	; 0
    5ddc:	04 c0       	rjmp	.+8      	; 0x5de6 <MB_Slave_Off+0x12>
    5dde:	22 0f       	add	r18, r18
    5de0:	33 1f       	adc	r19, r19
    5de2:	44 1f       	adc	r20, r20
    5de4:	55 1f       	adc	r21, r21
    5de6:	6a 95       	dec	r22
    5de8:	d2 f7       	brpl	.-12     	; 0x5dde <MB_Slave_Off+0xa>
    5dea:	e8 2f       	mov	r30, r24
    5dec:	f0 e0       	ldi	r31, 0x00	; 0
    5dee:	ee 0f       	add	r30, r30
    5df0:	ff 1f       	adc	r31, r31
    5df2:	ee 0f       	add	r30, r30
    5df4:	ff 1f       	adc	r31, r31
    5df6:	eb 51       	subi	r30, 0x1B	; 27
    5df8:	f7 4f       	sbci	r31, 0xF7	; 247
    5dfa:	80 81       	ld	r24, Z
    5dfc:	91 81       	ldd	r25, Z+1	; 0x01
    5dfe:	a2 81       	ldd	r26, Z+2	; 0x02
    5e00:	b3 81       	ldd	r27, Z+3	; 0x03
    5e02:	28 23       	and	r18, r24
    5e04:	39 23       	and	r19, r25
    5e06:	4a 23       	and	r20, r26
    5e08:	5b 23       	and	r21, r27
	return SlaveOff[MB_N] &((uint32_t)1<<S_N);
}
    5e0a:	b9 01       	movw	r22, r18
    5e0c:	ca 01       	movw	r24, r20
    5e0e:	08 95       	ret

00005e10 <GetReg>:
}

// ~~~~~~~~~~~~~~~~~
static uint16_t*
GetReg(uint8_t MB_N)
{
    5e10:	98 2f       	mov	r25, r24
	return MB_SingleState[MB_N]!=MB_SingleExec?(uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+prw(&GetQuery(MB_N)->AllocAddr):MB_SingleQuery[MB_N].Buf;
    5e12:	a8 2f       	mov	r26, r24
    5e14:	b0 e0       	ldi	r27, 0x00	; 0
    5e16:	fd 01       	movw	r30, r26
    5e18:	e3 55       	subi	r30, 0x53	; 83
    5e1a:	f9 4f       	sbci	r31, 0xF9	; 249
    5e1c:	80 81       	ld	r24, Z
    5e1e:	82 30       	cpi	r24, 0x02	; 2
    5e20:	09 f4       	brne	.+2      	; 0x5e24 <GetReg+0x14>
    5e22:	39 c0       	rjmp	.+114    	; 0x5e96 <GetReg+0x86>
    5e24:	fd 01       	movw	r30, r26
    5e26:	ee 0f       	add	r30, r30
    5e28:	ff 1f       	adc	r31, r31
    5e2a:	ee 0f       	add	r30, r30
    5e2c:	ff 1f       	adc	r31, r31
    5e2e:	ee 0f       	add	r30, r30
    5e30:	ff 1f       	adc	r31, r31
    5e32:	ee 0f       	add	r30, r30
    5e34:	ff 1f       	adc	r31, r31
    5e36:	e8 5c       	subi	r30, 0xC8	; 200
    5e38:	fc 4f       	sbci	r31, 0xFC	; 252
    5e3a:	45 91       	lpm	r20, Z+
    5e3c:	54 91       	lpm	r21, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    5e3e:	83 e0       	ldi	r24, 0x03	; 3
    5e40:	98 9f       	mul	r25, r24
    5e42:	f0 01       	movw	r30, r0
    5e44:	11 24       	eor	r1, r1
    5e46:	e5 5b       	subi	r30, 0xB5	; 181
    5e48:	f6 4d       	sbci	r31, 0xD6	; 214
    5e4a:	25 91       	lpm	r18, Z+
    5e4c:	34 91       	lpm	r19, Z+
    5e4e:	fd 01       	movw	r30, r26
    5e50:	ee 5a       	subi	r30, 0xAE	; 174
    5e52:	f9 4f       	sbci	r31, 0xF9	; 249
    5e54:	80 81       	ld	r24, Z
    5e56:	90 e0       	ldi	r25, 0x00	; 0
    5e58:	88 0f       	add	r24, r24
    5e5a:	99 1f       	adc	r25, r25
    5e5c:	88 0f       	add	r24, r24
    5e5e:	99 1f       	adc	r25, r25
    5e60:	28 0f       	add	r18, r24
    5e62:	39 1f       	adc	r19, r25
    5e64:	2f 5f       	subi	r18, 0xFF	; 255
    5e66:	3f 4f       	sbci	r19, 0xFF	; 255
    5e68:	f9 01       	movw	r30, r18
    5e6a:	65 91       	lpm	r22, Z+
    5e6c:	74 91       	lpm	r23, Z+
    5e6e:	ad 5a       	subi	r26, 0xAD	; 173
    5e70:	b9 4f       	sbci	r27, 0xF9	; 249
    5e72:	8c 91       	ld	r24, X
    5e74:	27 e0       	ldi	r18, 0x07	; 7
    5e76:	82 9f       	mul	r24, r18
    5e78:	c0 01       	movw	r24, r0
    5e7a:	11 24       	eor	r1, r1
    5e7c:	68 0f       	add	r22, r24
    5e7e:	79 1f       	adc	r23, r25
    5e80:	6b 5f       	subi	r22, 0xFB	; 251
    5e82:	7f 4f       	sbci	r23, 0xFF	; 255
    5e84:	fb 01       	movw	r30, r22
    5e86:	85 91       	lpm	r24, Z+
    5e88:	94 91       	lpm	r25, Z+
    5e8a:	88 0f       	add	r24, r24
    5e8c:	99 1f       	adc	r25, r25
    5e8e:	48 0f       	add	r20, r24
    5e90:	59 1f       	adc	r21, r25
}
    5e92:	ca 01       	movw	r24, r20
    5e94:	08 95       	ret

// ~~~~~~~~~~~~~~~~~
static uint16_t*
GetReg(uint8_t MB_N)
{
	return MB_SingleState[MB_N]!=MB_SingleExec?(uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+prw(&GetQuery(MB_N)->AllocAddr):MB_SingleQuery[MB_N].Buf;
    5e96:	aa 0f       	add	r26, r26
    5e98:	bb 1f       	adc	r27, r27
    5e9a:	aa 0f       	add	r26, r26
    5e9c:	bb 1f       	adc	r27, r27
    5e9e:	aa 0f       	add	r26, r26
    5ea0:	bb 1f       	adc	r27, r27
    5ea2:	a8 52       	subi	r26, 0x28	; 40
    5ea4:	bb 4f       	sbci	r27, 0xFB	; 251
    5ea6:	16 96       	adiw	r26, 0x06	; 6
    5ea8:	4d 91       	ld	r20, X+
    5eaa:	5c 91       	ld	r21, X
    5eac:	17 97       	sbiw	r26, 0x07	; 7
}
    5eae:	ca 01       	movw	r24, r20
    5eb0:	08 95       	ret

00005eb2 <FormData>:

// ~~~~~~~~~~~~~~~~~~~
static void
FormData(uint8_t MB_N)
{
    5eb2:	cf 92       	push	r12
    5eb4:	df 92       	push	r13
    5eb6:	ef 92       	push	r14
    5eb8:	ff 92       	push	r15
    5eba:	0f 93       	push	r16
    5ebc:	1f 93       	push	r17
    5ebe:	cf 93       	push	r28
    5ec0:	df 93       	push	r29
    5ec2:	e8 2e       	mov	r14, r24
	uint16_t Qt;
	uint16_t *Reg;
	switch (MB_Frame[MB_N][1]) {
    5ec4:	c8 2f       	mov	r28, r24
    5ec6:	d0 e0       	ldi	r29, 0x00	; 0
    5ec8:	7c 2f       	mov	r23, r28
    5eca:	66 27       	eor	r22, r22
    5ecc:	8b 01       	movw	r16, r22
    5ece:	0d 5d       	subi	r16, 0xDD	; 221
    5ed0:	14 4f       	sbci	r17, 0xF4	; 244
    5ed2:	f8 01       	movw	r30, r16
    5ed4:	81 81       	ldd	r24, Z+1	; 0x01
    5ed6:	86 30       	cpi	r24, 0x06	; 6
    5ed8:	09 f4       	brne	.+2      	; 0x5edc <FormData+0x2a>
    5eda:	4b c0       	rjmp	.+150    	; 0x5f72 <FormData+0xc0>
    5edc:	87 30       	cpi	r24, 0x07	; 7
    5ede:	88 f0       	brcs	.+34     	; 0x5f02 <FormData+0x50>
    5ee0:	8f 30       	cpi	r24, 0x0F	; 15
    5ee2:	09 f4       	brne	.+2      	; 0x5ee6 <FormData+0x34>
    5ee4:	5b c0       	rjmp	.+182    	; 0x5f9c <FormData+0xea>
    5ee6:	80 31       	cpi	r24, 0x10	; 16
    5ee8:	a1 f0       	breq	.+40     	; 0x5f12 <FormData+0x60>
			MB_Frame[MB_N][7+j] = Reg[i]>>8;
			MB_Frame[MB_N][8+j] = Reg[i];
		}
		break;
	}
	SetCRC_MB(MB_N);
    5eea:	8e 2d       	mov	r24, r14
    5eec:	0e 94 d8 2a 	call	0x55b0	; 0x55b0 <SetCRC_MB>
}
    5ef0:	df 91       	pop	r29
    5ef2:	cf 91       	pop	r28
    5ef4:	1f 91       	pop	r17
    5ef6:	0f 91       	pop	r16
    5ef8:	ff 90       	pop	r15
    5efa:	ef 90       	pop	r14
    5efc:	df 90       	pop	r13
    5efe:	cf 90       	pop	r12
    5f00:	08 95       	ret
static void
FormData(uint8_t MB_N)
{
	uint16_t Qt;
	uint16_t *Reg;
	switch (MB_Frame[MB_N][1]) {
    5f02:	81 50       	subi	r24, 0x01	; 1
    5f04:	84 30       	cpi	r24, 0x04	; 4
    5f06:	88 f7       	brcc	.-30     	; 0x5eea <FormData+0x38>
	case 1: case 2: case 3: case 4:
		MB_Frame_Sz[MB_N] = 8;
    5f08:	cb 5f       	subi	r28, 0xFB	; 251
    5f0a:	d8 4f       	sbci	r29, 0xF8	; 248
    5f0c:	88 e0       	ldi	r24, 0x08	; 8
    5f0e:	88 83       	st	Y, r24
    5f10:	ec cf       	rjmp	.-40     	; 0x5eea <FormData+0x38>
			else
				MB_Frame[MB_N][Byte] &=~Bit;
		}
		break;
	case 0x10:
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = MB_Frame[MB_N][5]*2) + 9;
    5f12:	55 e0       	ldi	r21, 0x05	; 5
    5f14:	c5 2e       	mov	r12, r21
    5f16:	d1 2c       	mov	r13, r1
    5f18:	c0 0e       	add	r12, r16
    5f1a:	d1 1e       	adc	r13, r17
    5f1c:	f8 01       	movw	r30, r16
    5f1e:	85 81       	ldd	r24, Z+5	; 0x05
    5f20:	90 e0       	ldi	r25, 0x00	; 0
    5f22:	88 0f       	add	r24, r24
    5f24:	99 1f       	adc	r25, r25
    5f26:	86 83       	std	Z+6, r24	; 0x06
    5f28:	cb 5f       	subi	r28, 0xFB	; 251
    5f2a:	d8 4f       	sbci	r29, 0xF8	; 248
    5f2c:	87 5f       	subi	r24, 0xF7	; 247
    5f2e:	88 83       	st	Y, r24
		Reg = GetReg(MB_N);
    5f30:	8e 2d       	mov	r24, r14
    5f32:	0e 94 08 2f 	call	0x5e10	; 0x5e10 <GetReg>
    5f36:	bc 01       	movw	r22, r24
		for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    5f38:	f8 01       	movw	r30, r16
    5f3a:	85 81       	ldd	r24, Z+5	; 0x05
    5f3c:	88 23       	and	r24, r24
    5f3e:	a9 f2       	breq	.-86     	; 0x5eea <FormData+0x38>
    5f40:	20 e0       	ldi	r18, 0x00	; 0
			uint8_t j = i*2;
			MB_Frame[MB_N][7+j] = Reg[i]>>8;
    5f42:	a8 01       	movw	r20, r16
		}
		break;
	case 0x10:
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = MB_Frame[MB_N][5]*2) + 9;
		Reg = GetReg(MB_N);
		for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    5f44:	e6 01       	movw	r28, r12
			uint8_t j = i*2;
			MB_Frame[MB_N][7+j] = Reg[i]>>8;
    5f46:	82 2f       	mov	r24, r18
    5f48:	90 e0       	ldi	r25, 0x00	; 0
    5f4a:	88 0f       	add	r24, r24
    5f4c:	99 1f       	adc	r25, r25
    5f4e:	fb 01       	movw	r30, r22
    5f50:	e8 0f       	add	r30, r24
    5f52:	f9 1f       	adc	r31, r25
    5f54:	da 01       	movw	r26, r20
    5f56:	a8 0f       	add	r26, r24
    5f58:	b1 1d       	adc	r27, r1
    5f5a:	81 81       	ldd	r24, Z+1	; 0x01
    5f5c:	17 96       	adiw	r26, 0x07	; 7
    5f5e:	8c 93       	st	X, r24
    5f60:	17 97       	sbiw	r26, 0x07	; 7
			MB_Frame[MB_N][8+j] = Reg[i];
    5f62:	80 81       	ld	r24, Z
    5f64:	18 96       	adiw	r26, 0x08	; 8
    5f66:	8c 93       	st	X, r24
		}
		break;
	case 0x10:
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = MB_Frame[MB_N][5]*2) + 9;
		Reg = GetReg(MB_N);
		for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    5f68:	2f 5f       	subi	r18, 0xFF	; 255
    5f6a:	88 81       	ld	r24, Y
    5f6c:	28 17       	cp	r18, r24
    5f6e:	58 f3       	brcs	.-42     	; 0x5f46 <FormData+0x94>
    5f70:	bc cf       	rjmp	.-136    	; 0x5eea <FormData+0x38>
		MB_Frame_Sz[MB_N] = 8;
		MB_Frame[MB_N][5] = 0;
		break;
	*/
	case 6:
		MB_Frame_Sz[MB_N] = 8;
    5f72:	fe 01       	movw	r30, r28
    5f74:	eb 5f       	subi	r30, 0xFB	; 251
    5f76:	f8 4f       	sbci	r31, 0xF8	; 248
    5f78:	88 e0       	ldi	r24, 0x08	; 8
    5f7a:	80 83       	st	Z, r24
		Reg = GetReg(MB_N);
    5f7c:	8e 2d       	mov	r24, r14
    5f7e:	0e 94 08 2f 	call	0x5e10	; 0x5e10 <GetReg>
    5f82:	dc 01       	movw	r26, r24
		MB_Frame[MB_N][4] = *Reg>>8;
    5f84:	fc 2f       	mov	r31, r28
    5f86:	ee 27       	eor	r30, r30
    5f88:	e9 5d       	subi	r30, 0xD9	; 217
    5f8a:	f4 4f       	sbci	r31, 0xF4	; 244
    5f8c:	11 96       	adiw	r26, 0x01	; 1
    5f8e:	8c 91       	ld	r24, X
    5f90:	11 97       	sbiw	r26, 0x01	; 1
    5f92:	80 83       	st	Z, r24
		MB_Frame[MB_N][5] = *Reg;
    5f94:	8c 91       	ld	r24, X
    5f96:	f8 01       	movw	r30, r16
    5f98:	85 83       	std	Z+5, r24	; 0x05
    5f9a:	a7 cf       	rjmp	.-178    	; 0x5eea <FormData+0x38>
    5f9c:	fc 2f       	mov	r31, r28
    5f9e:	ee 27       	eor	r30, r30
    5fa0:	e9 5d       	subi	r30, 0xD9	; 217
    5fa2:	f4 4f       	sbci	r31, 0xF4	; 244
    5fa4:	90 81       	ld	r25, Z
    5fa6:	80 e0       	ldi	r24, 0x00	; 0
    5fa8:	f8 01       	movw	r30, r16
    5faa:	25 81       	ldd	r18, Z+5	; 0x05
    5fac:	02 2f       	mov	r16, r18
    5fae:	10 e0       	ldi	r17, 0x00	; 0
    5fb0:	08 2b       	or	r16, r24
    5fb2:	19 2b       	or	r17, r25
		break;
	case 0x0F:
		Qt = MB_FrameReg(MB_N, 4);
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = Qt/8 + (Qt%8>0)) + 9;
    5fb4:	98 01       	movw	r18, r16
    5fb6:	36 95       	lsr	r19
    5fb8:	27 95       	ror	r18
    5fba:	36 95       	lsr	r19
    5fbc:	27 95       	ror	r18
    5fbe:	36 95       	lsr	r19
    5fc0:	27 95       	ror	r18
    5fc2:	40 e0       	ldi	r20, 0x00	; 0
    5fc4:	c8 01       	movw	r24, r16
    5fc6:	87 70       	andi	r24, 0x07	; 7
    5fc8:	90 70       	andi	r25, 0x00	; 0
    5fca:	89 2b       	or	r24, r25
    5fcc:	09 f0       	breq	.+2      	; 0x5fd0 <FormData+0x11e>
    5fce:	8b c0       	rjmp	.+278    	; 0x60e6 <FormData+0x234>
    5fd0:	84 2f       	mov	r24, r20
    5fd2:	82 0f       	add	r24, r18
    5fd4:	fb 01       	movw	r30, r22
    5fd6:	ed 5d       	subi	r30, 0xDD	; 221
    5fd8:	f4 4f       	sbci	r31, 0xF4	; 244
    5fda:	86 83       	std	Z+6, r24	; 0x06
    5fdc:	de 01       	movw	r26, r28
    5fde:	ab 5f       	subi	r26, 0xFB	; 251
    5fe0:	b8 4f       	sbci	r27, 0xF8	; 248
    5fe2:	87 5f       	subi	r24, 0xF7	; 247
    5fe4:	8c 93       	st	X, r24
		MB_Frame[MB_N][7+Qt/8] = 0;
    5fe6:	e2 0f       	add	r30, r18
    5fe8:	f3 1f       	adc	r31, r19
    5fea:	17 82       	std	Z+7, r1	; 0x07
		uint8_t *Discr;
		uint8_t Pin;
		if (MB_SingleState[MB_N]!=MB_SingleExec) {
    5fec:	fe 01       	movw	r30, r28
    5fee:	e3 55       	subi	r30, 0x53	; 83
    5ff0:	f9 4f       	sbci	r31, 0xF9	; 249
    5ff2:	80 81       	ld	r24, Z
    5ff4:	82 30       	cpi	r24, 0x02	; 2
    5ff6:	09 f4       	brne	.+2      	; 0x5ffa <FormData+0x148>
    5ff8:	78 c0       	rjmp	.+240    	; 0x60ea <FormData+0x238>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5ffa:	fe 01       	movw	r30, r28
    5ffc:	e2 95       	swap	r30
    5ffe:	f2 95       	swap	r31
    6000:	f0 7f       	andi	r31, 0xF0	; 240
    6002:	fe 27       	eor	r31, r30
    6004:	e0 7f       	andi	r30, 0xF0	; 240
    6006:	fe 27       	eor	r31, r30
    6008:	e0 5d       	subi	r30, 0xD0	; 208
    600a:	fc 4f       	sbci	r31, 0xFC	; 252
			Discr = prp(&Modbus_Map[MB_N].Coil);
    600c:	a5 91       	lpm	r26, Z+
    600e:	b4 91       	lpm	r27, Z+
    6010:	83 e0       	ldi	r24, 0x03	; 3
    6012:	e8 9e       	mul	r14, r24
    6014:	f0 01       	movw	r30, r0
    6016:	11 24       	eor	r1, r1
    6018:	e5 5b       	subi	r30, 0xB5	; 181
    601a:	f6 4d       	sbci	r31, 0xD6	; 214
    601c:	25 91       	lpm	r18, Z+
    601e:	34 91       	lpm	r19, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    6020:	fe 01       	movw	r30, r28
    6022:	ee 5a       	subi	r30, 0xAE	; 174
    6024:	f9 4f       	sbci	r31, 0xF9	; 249
    6026:	80 81       	ld	r24, Z
    6028:	90 e0       	ldi	r25, 0x00	; 0
    602a:	88 0f       	add	r24, r24
    602c:	99 1f       	adc	r25, r25
    602e:	88 0f       	add	r24, r24
    6030:	99 1f       	adc	r25, r25
    6032:	28 0f       	add	r18, r24
    6034:	39 1f       	adc	r19, r25
    6036:	2f 5f       	subi	r18, 0xFF	; 255
    6038:	3f 4f       	sbci	r19, 0xFF	; 255
    603a:	f9 01       	movw	r30, r18
    603c:	45 91       	lpm	r20, Z+
    603e:	54 91       	lpm	r21, Z+
    6040:	cd 5a       	subi	r28, 0xAD	; 173
    6042:	d9 4f       	sbci	r29, 0xF9	; 249
    6044:	88 81       	ld	r24, Y
    6046:	27 e0       	ldi	r18, 0x07	; 7
    6048:	82 9f       	mul	r24, r18
    604a:	c0 01       	movw	r24, r0
    604c:	11 24       	eor	r1, r1
    604e:	48 0f       	add	r20, r24
    6050:	59 1f       	adc	r21, r25
    6052:	4b 5f       	subi	r20, 0xFB	; 251
    6054:	5f 4f       	sbci	r21, 0xFF	; 255
    6056:	fa 01       	movw	r30, r20
    6058:	85 91       	lpm	r24, Z+
    605a:	94 91       	lpm	r25, Z+
			Pin = prw(&GetQuery(MB_N)->AllocAddr);
    605c:	f8 2e       	mov	r15, r24
		}
		else {
			Discr = MB_SingleQuery[MB_N].Buf;
			Pin = 0;
		}
		for (uint8_t i=0; i<Qt; i++) {
    605e:	01 15       	cp	r16, r1
    6060:	11 05       	cpc	r17, r1
    6062:	09 f4       	brne	.+2      	; 0x6066 <FormData+0x1b4>
    6064:	42 cf       	rjmp	.-380    	; 0x5eea <FormData+0x38>
    6066:	50 e0       	ldi	r21, 0x00	; 0
    6068:	80 e0       	ldi	r24, 0x00	; 0
    606a:	90 e0       	ldi	r25, 0x00	; 0
			uint8_t j = Pin+i;
			uint8_t Byte=7+i/8, Bit=1<<i%8;
    606c:	c1 e0       	ldi	r28, 0x01	; 1
    606e:	d0 e0       	ldi	r29, 0x00	; 0
    6070:	0f c0       	rjmp	.+30     	; 0x6090 <FormData+0x1de>
			if (Discr[j/8] &(1<<j%8))
				MB_Frame[MB_N][Byte] |=Bit;
    6072:	fb 01       	movw	r30, r22
    6074:	e3 0f       	add	r30, r19
    6076:	f1 1d       	adc	r31, r1
    6078:	ed 5d       	subi	r30, 0xDD	; 221
    607a:	f4 4f       	sbci	r31, 0xF4	; 244
    607c:	80 81       	ld	r24, Z
    607e:	84 2b       	or	r24, r20
    6080:	80 83       	st	Z, r24
		}
		else {
			Discr = MB_SingleQuery[MB_N].Buf;
			Pin = 0;
		}
		for (uint8_t i=0; i<Qt; i++) {
    6082:	5f 5f       	subi	r21, 0xFF	; 255
    6084:	85 2f       	mov	r24, r21
    6086:	90 e0       	ldi	r25, 0x00	; 0
    6088:	80 17       	cp	r24, r16
    608a:	91 07       	cpc	r25, r17
    608c:	08 f0       	brcs	.+2      	; 0x6090 <FormData+0x1de>
    608e:	2d cf       	rjmp	.-422    	; 0x5eea <FormData+0x38>
    6090:	25 2f       	mov	r18, r21
    6092:	2f 0d       	add	r18, r15
			uint8_t j = Pin+i;
			uint8_t Byte=7+i/8, Bit=1<<i%8;
    6094:	35 2f       	mov	r19, r21
    6096:	36 95       	lsr	r19
    6098:	36 95       	lsr	r19
    609a:	36 95       	lsr	r19
    609c:	39 5f       	subi	r19, 0xF9	; 249
    609e:	87 70       	andi	r24, 0x07	; 7
    60a0:	90 70       	andi	r25, 0x00	; 0
    60a2:	fe 01       	movw	r30, r28
    60a4:	02 c0       	rjmp	.+4      	; 0x60aa <FormData+0x1f8>
    60a6:	ee 0f       	add	r30, r30
    60a8:	ff 1f       	adc	r31, r31
    60aa:	8a 95       	dec	r24
    60ac:	e2 f7       	brpl	.-8      	; 0x60a6 <FormData+0x1f4>
    60ae:	4e 2f       	mov	r20, r30
			if (Discr[j/8] &(1<<j%8))
    60b0:	82 2f       	mov	r24, r18
    60b2:	86 95       	lsr	r24
    60b4:	86 95       	lsr	r24
    60b6:	86 95       	lsr	r24
    60b8:	fd 01       	movw	r30, r26
    60ba:	e8 0f       	add	r30, r24
    60bc:	f1 1d       	adc	r31, r1
    60be:	80 81       	ld	r24, Z
    60c0:	90 e0       	ldi	r25, 0x00	; 0
    60c2:	27 70       	andi	r18, 0x07	; 7
    60c4:	02 c0       	rjmp	.+4      	; 0x60ca <FormData+0x218>
    60c6:	95 95       	asr	r25
    60c8:	87 95       	ror	r24
    60ca:	2a 95       	dec	r18
    60cc:	e2 f7       	brpl	.-8      	; 0x60c6 <FormData+0x214>
    60ce:	80 fd       	sbrc	r24, 0
    60d0:	d0 cf       	rjmp	.-96     	; 0x6072 <FormData+0x1c0>
				MB_Frame[MB_N][Byte] |=Bit;
			else
				MB_Frame[MB_N][Byte] &=~Bit;
    60d2:	fb 01       	movw	r30, r22
    60d4:	e3 0f       	add	r30, r19
    60d6:	f1 1d       	adc	r31, r1
    60d8:	ed 5d       	subi	r30, 0xDD	; 221
    60da:	f4 4f       	sbci	r31, 0xF4	; 244
    60dc:	40 95       	com	r20
    60de:	80 81       	ld	r24, Z
    60e0:	48 23       	and	r20, r24
    60e2:	40 83       	st	Z, r20
    60e4:	ce cf       	rjmp	.-100    	; 0x6082 <FormData+0x1d0>
		MB_Frame[MB_N][4] = *Reg>>8;
		MB_Frame[MB_N][5] = *Reg;
		break;
	case 0x0F:
		Qt = MB_FrameReg(MB_N, 4);
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = Qt/8 + (Qt%8>0)) + 9;
    60e6:	41 e0       	ldi	r20, 0x01	; 1
    60e8:	73 cf       	rjmp	.-282    	; 0x5fd0 <FormData+0x11e>
		if (MB_SingleState[MB_N]!=MB_SingleExec) {
			Discr = prp(&Modbus_Map[MB_N].Coil);
			Pin = prw(&GetQuery(MB_N)->AllocAddr);
		}
		else {
			Discr = MB_SingleQuery[MB_N].Buf;
    60ea:	cc 0f       	add	r28, r28
    60ec:	dd 1f       	adc	r29, r29
    60ee:	cc 0f       	add	r28, r28
    60f0:	dd 1f       	adc	r29, r29
    60f2:	cc 0f       	add	r28, r28
    60f4:	dd 1f       	adc	r29, r29
    60f6:	c8 52       	subi	r28, 0x28	; 40
    60f8:	db 4f       	sbci	r29, 0xFB	; 251
    60fa:	ae 81       	ldd	r26, Y+6	; 0x06
    60fc:	bf 81       	ldd	r27, Y+7	; 0x07
    60fe:	ff 24       	eor	r15, r15
    6100:	ae cf       	rjmp	.-164    	; 0x605e <FormData+0x1ac>

00006102 <FormQuery>:
}

// ~~~~~~~~~~~~~~~~~~~~
static void
FormQuery(uint8_t MB_N)
{
    6102:	cf 93       	push	r28
    6104:	df 93       	push	r29

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6106:	93 e0       	ldi	r25, 0x03	; 3
    6108:	89 9f       	mul	r24, r25
    610a:	f0 01       	movw	r30, r0
    610c:	11 24       	eor	r1, r1
    610e:	e5 5b       	subi	r30, 0xB5	; 181
    6110:	f6 4d       	sbci	r31, 0xD6	; 214
    6112:	65 91       	lpm	r22, Z+
    6114:	74 91       	lpm	r23, Z+

// ~~~~~~~~~~~~~~~~~~~
static MB_Slave*
GetSlave(uint8_t MB_N)
{
	return (MB_Slave*)prp(&(MB_Master_List+MB_N)->SlaveList)+CurrSlave[MB_N];
    6116:	48 2f       	mov	r20, r24
    6118:	50 e0       	ldi	r21, 0x00	; 0
    611a:	fa 01       	movw	r30, r20
    611c:	ee 5a       	subi	r30, 0xAE	; 174
    611e:	f9 4f       	sbci	r31, 0xF9	; 249
    6120:	20 81       	ld	r18, Z
    6122:	30 e0       	ldi	r19, 0x00	; 0
    6124:	22 0f       	add	r18, r18
    6126:	33 1f       	adc	r19, r19
    6128:	22 0f       	add	r18, r18
    612a:	33 1f       	adc	r19, r19
    612c:	62 0f       	add	r22, r18
    612e:	73 1f       	adc	r23, r19
    6130:	fb 01       	movw	r30, r22
    6132:	31 96       	adiw	r30, 0x01	; 1
    6134:	c5 91       	lpm	r28, Z+
    6136:	d4 91       	lpm	r29, Z+
// ~~~~~~~~~~~~~~~~~~~~
static void
FormQuery(uint8_t MB_N)
{
	MB_Slave *Slave = GetSlave(MB_N);
	MB_Query *Query = (MB_Query*)prp(&Slave->QueryList)+CurrQuery[MB_N];
    6138:	fa 01       	movw	r30, r20
    613a:	ed 5a       	subi	r30, 0xAD	; 173
    613c:	f9 4f       	sbci	r31, 0xF9	; 249
    613e:	20 81       	ld	r18, Z
    6140:	97 e0       	ldi	r25, 0x07	; 7
    6142:	29 9f       	mul	r18, r25
    6144:	90 01       	movw	r18, r0
    6146:	11 24       	eor	r1, r1
    6148:	c2 0f       	add	r28, r18
    614a:	d3 1f       	adc	r29, r19

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    614c:	fb 01       	movw	r30, r22
    614e:	94 91       	lpm	r25, Z+

	MB_Frame[MB_N][0] = prb(&Slave->Addr);
    6150:	23 e2       	ldi	r18, 0x23	; 35
    6152:	3b e0       	ldi	r19, 0x0B	; 11
    6154:	b4 2f       	mov	r27, r20
    6156:	aa 27       	eor	r26, r26
    6158:	a2 0f       	add	r26, r18
    615a:	b3 1f       	adc	r27, r19
    615c:	9c 93       	st	X, r25
    615e:	fe 01       	movw	r30, r28
    6160:	94 91       	lpm	r25, Z+
	MB_Frame[MB_N][1] = prb(&Query->Func);
    6162:	11 96       	adiw	r26, 0x01	; 1
    6164:	9c 93       	st	X, r25
    6166:	11 97       	sbiw	r26, 0x01	; 1
	MB_Frame[MB_N][2] = prb((uint8_t*)&Query->StartAddr+1);
    6168:	be 01       	movw	r22, r28
    616a:	6f 5f       	subi	r22, 0xFF	; 255
    616c:	7f 4f       	sbci	r23, 0xFF	; 255
    616e:	6f 5f       	subi	r22, 0xFF	; 255
    6170:	7f 4f       	sbci	r23, 0xFF	; 255
    6172:	fb 01       	movw	r30, r22
    6174:	94 91       	lpm	r25, Z+
    6176:	61 50       	subi	r22, 0x01	; 1
    6178:	70 40       	sbci	r23, 0x00	; 0
    617a:	fd 01       	movw	r30, r26
    617c:	92 83       	std	Z+2, r25	; 0x02
    617e:	fb 01       	movw	r30, r22
    6180:	94 91       	lpm	r25, Z+
	MB_Frame[MB_N][3] = prb((uint8_t*)&Query->StartAddr);
    6182:	13 96       	adiw	r26, 0x03	; 3
    6184:	9c 93       	st	X, r25
    6186:	13 97       	sbiw	r26, 0x03	; 3
    6188:	24 96       	adiw	r28, 0x04	; 4
    618a:	fe 01       	movw	r30, r28
    618c:	94 91       	lpm	r25, Z+
	MB_Frame[MB_N][4] = prb((uint8_t*)&Query->Qt+1);
    618e:	fd 01       	movw	r30, r26
    6190:	94 83       	std	Z+4, r25	; 0x04
    6192:	21 97       	sbiw	r28, 0x01	; 1
    6194:	fe 01       	movw	r30, r28
    6196:	94 91       	lpm	r25, Z+
	MB_Frame[MB_N][5] = prb((uint8_t*)&Query->Qt);
    6198:	15 96       	adiw	r26, 0x05	; 5
    619a:	9c 93       	st	X, r25

	FormData(MB_N);
    619c:	0e 94 59 2f 	call	0x5eb2	; 0x5eb2 <FormData>
}
    61a0:	df 91       	pop	r29
    61a2:	cf 91       	pop	r28
    61a4:	08 95       	ret

000061a6 <FormSingle>:

// ~~~~~~~~~~~~~~~~~~~~~
static void
FormSingle(uint8_t MB_N)
{
    61a6:	1f 93       	push	r17
    61a8:	cf 93       	push	r28
    61aa:	df 93       	push	r29
	MB_Frame[MB_N][0] = MB_SingleQuery[MB_N].Addr;
    61ac:	a8 2f       	mov	r26, r24
    61ae:	b0 e0       	ldi	r27, 0x00	; 0
    61b0:	63 e2       	ldi	r22, 0x23	; 35
    61b2:	7b e0       	ldi	r23, 0x0B	; 11
    61b4:	5a 2f       	mov	r21, r26
    61b6:	44 27       	eor	r20, r20
    61b8:	46 0f       	add	r20, r22
    61ba:	57 1f       	adc	r21, r23
    61bc:	28 ed       	ldi	r18, 0xD8	; 216
    61be:	34 e0       	ldi	r19, 0x04	; 4
    61c0:	fd 01       	movw	r30, r26
    61c2:	ee 0f       	add	r30, r30
    61c4:	ff 1f       	adc	r31, r31
    61c6:	ee 0f       	add	r30, r30
    61c8:	ff 1f       	adc	r31, r31
    61ca:	ee 0f       	add	r30, r30
    61cc:	ff 1f       	adc	r31, r31
    61ce:	e2 0f       	add	r30, r18
    61d0:	f3 1f       	adc	r31, r19
    61d2:	90 81       	ld	r25, Z
    61d4:	ea 01       	movw	r28, r20
    61d6:	98 83       	st	Y, r25
	MB_Frame[MB_N][1] = MB_SingleQuery[MB_N].Func;
    61d8:	91 81       	ldd	r25, Z+1	; 0x01
    61da:	99 83       	std	Y+1, r25	; 0x01
	MB_Frame[MB_N][2] = MB_SingleQuery[MB_N].StartAddr>>8;
    61dc:	fd 01       	movw	r30, r26
    61de:	ee 0f       	add	r30, r30
    61e0:	ff 1f       	adc	r31, r31
    61e2:	ee 0f       	add	r30, r30
    61e4:	ff 1f       	adc	r31, r31
    61e6:	ee 0f       	add	r30, r30
    61e8:	ff 1f       	adc	r31, r31
    61ea:	32 96       	adiw	r30, 0x02	; 2
    61ec:	e2 0f       	add	r30, r18
    61ee:	f3 1f       	adc	r31, r19
    61f0:	10 81       	ld	r17, Z
    61f2:	91 81       	ldd	r25, Z+1	; 0x01
    61f4:	fa 01       	movw	r30, r20
    61f6:	92 83       	std	Z+2, r25	; 0x02
	MB_Frame[MB_N][3] = MB_SingleQuery[MB_N].StartAddr;
    61f8:	1b 83       	std	Y+3, r17	; 0x03
	MB_Frame[MB_N][4] = MB_SingleQuery[MB_N].Qt>>8;
    61fa:	fd 01       	movw	r30, r26
    61fc:	ee 0f       	add	r30, r30
    61fe:	ff 1f       	adc	r31, r31
    6200:	ee 0f       	add	r30, r30
    6202:	ff 1f       	adc	r31, r31
    6204:	ee 0f       	add	r30, r30
    6206:	ff 1f       	adc	r31, r31
    6208:	34 96       	adiw	r30, 0x04	; 4
    620a:	e2 0f       	add	r30, r18
    620c:	f3 1f       	adc	r31, r19
    620e:	10 81       	ld	r17, Z
    6210:	91 81       	ldd	r25, Z+1	; 0x01
    6212:	9c 83       	std	Y+4, r25	; 0x04
	MB_Frame[MB_N][5] = MB_SingleQuery[MB_N].Qt;
    6214:	1d 83       	std	Y+5, r17	; 0x05
	
	MB_SingleState[MB_N] = MB_SingleExec;
    6216:	a3 55       	subi	r26, 0x53	; 83
    6218:	b9 4f       	sbci	r27, 0xF9	; 249
    621a:	92 e0       	ldi	r25, 0x02	; 2
    621c:	9c 93       	st	X, r25
	FormData(MB_N);
    621e:	0e 94 59 2f 	call	0x5eb2	; 0x5eb2 <FormData>
}
    6222:	df 91       	pop	r29
    6224:	cf 91       	pop	r28
    6226:	1f 91       	pop	r17
    6228:	08 95       	ret

0000622a <NextSlave>:

// ~~~~~~~~~~~~~~~~~~~~
static uint8_t
NextSlave(uint8_t MB_N)
{
    622a:	2f 92       	push	r2
    622c:	3f 92       	push	r3
    622e:	4f 92       	push	r4
    6230:	5f 92       	push	r5
    6232:	6f 92       	push	r6
    6234:	7f 92       	push	r7
    6236:	8f 92       	push	r8
    6238:	9f 92       	push	r9
    623a:	af 92       	push	r10
    623c:	bf 92       	push	r11
    623e:	cf 92       	push	r12
    6240:	df 92       	push	r13
    6242:	ef 92       	push	r14
    6244:	ff 92       	push	r15
    6246:	0f 93       	push	r16
    6248:	1f 93       	push	r17
    624a:	df 93       	push	r29
    624c:	cf 93       	push	r28
    624e:	00 d0       	rcall	.+0      	; 0x6250 <NextSlave+0x26>
    6250:	00 d0       	rcall	.+0      	; 0x6252 <NextSlave+0x28>
    6252:	cd b7       	in	r28, 0x3d	; 61
    6254:	de b7       	in	r29, 0x3e	; 62
    6256:	68 2e       	mov	r6, r24
    6258:	e3 e0       	ldi	r30, 0x03	; 3
    625a:	8e 9f       	mul	r24, r30
    625c:	f0 01       	movw	r30, r0
    625e:	11 24       	eor	r1, r1
    6260:	e3 5b       	subi	r30, 0xB3	; 179
    6262:	f6 4d       	sbci	r31, 0xD6	; 214
    6264:	04 91       	lpm	r16, Z+
    6266:	c8 2e       	mov	r12, r24
    6268:	dd 24       	eor	r13, r13
    626a:	a6 01       	movw	r20, r12
    626c:	4e 5a       	subi	r20, 0xAE	; 174
    626e:	59 4f       	sbci	r21, 0xF9	; 249
    6270:	5e 83       	std	Y+6, r21	; 0x06
    6272:	4d 83       	std	Y+5, r20	; 0x05
    6274:	fa 01       	movw	r30, r20
    6276:	20 81       	ld	r18, Z
    6278:	16 01       	movw	r2, r12
    627a:	22 0c       	add	r2, r2
    627c:	33 1c       	adc	r3, r3
    627e:	22 0c       	add	r2, r2
    6280:	33 1c       	adc	r3, r3
    6282:	f1 01       	movw	r30, r2
    6284:	ee 51       	subi	r30, 0x1E	; 30
    6286:	fb 4f       	sbci	r31, 0xFB	; 251
    6288:	80 80       	ld	r8, Z
    628a:	91 80       	ldd	r9, Z+1	; 0x01
    628c:	a2 80       	ldd	r10, Z+2	; 0x02
    628e:	b3 80       	ldd	r11, Z+3	; 0x03
	do
		if (++CurrSlave[MB_N]==SlaveQt) {
			CurrSlave[MB_N] = 0;
			Over = 1;

			if ((MB_Master_Cycle[MB_N]=0xFFFF-GetTimer16(TD_MB_Cycle+MB_N))>MB_Master_MaxCycle[MB_N])
    6290:	70 90 e6 04 	lds	r7, 0x04E6
    6294:	f2 e0       	ldi	r31, 0x02	; 2
    6296:	7f 0e       	add	r7, r31
    6298:	47 2d       	mov	r20, r7
    629a:	48 0f       	add	r20, r24
    629c:	4a 83       	std	Y+2, r20	; 0x02
    629e:	5e ef       	ldi	r21, 0xFE	; 254
    62a0:	75 0e       	add	r7, r21
// ~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
GetTimer16(uint8_t TimerN)
{
	IntOff();
	uint16_t Time = Timer16[TimerN];
    62a2:	e4 2e       	mov	r14, r20
    62a4:	ff 24       	eor	r15, r15
    62a6:	19 82       	std	Y+1, r1	; 0x01
    62a8:	10 e0       	ldi	r17, 0x00	; 0
    62aa:	ee 0c       	add	r14, r14
    62ac:	ff 1c       	adc	r15, r15
    62ae:	8d e4       	ldi	r24, 0x4D	; 77
    62b0:	93 e0       	ldi	r25, 0x03	; 3
    62b2:	e8 0e       	add	r14, r24
    62b4:	f9 1e       	adc	r15, r25
    62b6:	c6 01       	movw	r24, r12
    62b8:	88 0f       	add	r24, r24
    62ba:	99 1f       	adc	r25, r25
    62bc:	fc 01       	movw	r30, r24
    62be:	ee 58       	subi	r30, 0x8E	; 142
    62c0:	f8 4f       	sbci	r31, 0xF8	; 248
    62c2:	fc 83       	std	Y+4, r31	; 0x04
    62c4:	eb 83       	std	Y+3, r30	; 0x03
    62c6:	fc eb       	ldi	r31, 0xBC	; 188
    62c8:	4f 2e       	mov	r4, r31
    62ca:	f6 e0       	ldi	r31, 0x06	; 6
    62cc:	5f 2e       	mov	r5, r31
    62ce:	48 0e       	add	r4, r24
    62d0:	59 1e       	adc	r5, r25
    62d2:	14 c0       	rjmp	.+40     	; 0x62fc <NextSlave+0xd2>
				MB_Master_MaxCycle[MB_N] = MB_Master_Cycle[MB_N];
			StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
		}
	while (SlaveSkip[MB_N] &((uint32_t)1<<CurrSlave[MB_N]) && ++i<SlaveQt);
    62d4:	ed 81       	ldd	r30, Y+5	; 0x05
    62d6:	fe 81       	ldd	r31, Y+6	; 0x06
    62d8:	20 81       	ld	r18, Z
    62da:	d5 01       	movw	r26, r10
    62dc:	c4 01       	movw	r24, r8
    62de:	02 2e       	mov	r0, r18
    62e0:	04 c0       	rjmp	.+8      	; 0x62ea <NextSlave+0xc0>
    62e2:	b6 95       	lsr	r27
    62e4:	a7 95       	ror	r26
    62e6:	97 95       	ror	r25
    62e8:	87 95       	ror	r24
    62ea:	0a 94       	dec	r0
    62ec:	d2 f7       	brpl	.-12     	; 0x62e2 <NextSlave+0xb8>
    62ee:	81 70       	andi	r24, 0x01	; 1
    62f0:	90 70       	andi	r25, 0x00	; 0
    62f2:	88 23       	and	r24, r24
    62f4:	61 f1       	breq	.+88     	; 0x634e <NextSlave+0x124>
    62f6:	1f 5f       	subi	r17, 0xFF	; 255
    62f8:	10 17       	cp	r17, r16
    62fa:	48 f5       	brcc	.+82     	; 0x634e <NextSlave+0x124>
{
	uint8_t Over = 0;
	uint8_t i = 0;
	uint8_t SlaveQt = prb(&(MB_Master_List+MB_N)->SlaveQt);
	do
		if (++CurrSlave[MB_N]==SlaveQt) {
    62fc:	82 2f       	mov	r24, r18
    62fe:	8f 5f       	subi	r24, 0xFF	; 255
    6300:	ed 81       	ldd	r30, Y+5	; 0x05
    6302:	fe 81       	ldd	r31, Y+6	; 0x06
    6304:	80 83       	st	Z, r24
    6306:	80 17       	cp	r24, r16
    6308:	29 f7       	brne	.-54     	; 0x62d4 <NextSlave+0xaa>
			CurrSlave[MB_N] = 0;
    630a:	10 82       	st	Z, r1

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    630c:	8f b7       	in	r24, 0x3f	; 63
    630e:	80 78       	andi	r24, 0x80	; 128
    6310:	80 93 ec 02 	sts	0x02EC, r24
	cli();
    6314:	f8 94       	cli
    6316:	f7 01       	movw	r30, r14
    6318:	20 81       	ld	r18, Z
    631a:	31 81       	ldd	r19, Z+1	; 0x01

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    631c:	88 23       	and	r24, r24
    631e:	09 f0       	breq	.+2      	; 0x6322 <NextSlave+0xf8>
		sei();
    6320:	78 94       	sei
			Over = 1;

			if ((MB_Master_Cycle[MB_N]=0xFFFF-GetTimer16(TD_MB_Cycle+MB_N))>MB_Master_MaxCycle[MB_N])
    6322:	20 95       	com	r18
    6324:	30 95       	com	r19
    6326:	eb 81       	ldd	r30, Y+3	; 0x03
    6328:	fc 81       	ldd	r31, Y+4	; 0x04
    632a:	31 83       	std	Z+1, r19	; 0x01
    632c:	20 83       	st	Z, r18
    632e:	f2 01       	movw	r30, r4
    6330:	80 81       	ld	r24, Z
    6332:	91 81       	ldd	r25, Z+1	; 0x01
    6334:	82 17       	cp	r24, r18
    6336:	93 07       	cpc	r25, r19
    6338:	10 f4       	brcc	.+4      	; 0x633e <NextSlave+0x114>
				MB_Master_MaxCycle[MB_N] = MB_Master_Cycle[MB_N];
    633a:	31 83       	std	Z+1, r19	; 0x01
    633c:	20 83       	st	Z, r18
			StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
    633e:	8a 81       	ldd	r24, Y+2	; 0x02
    6340:	6f ef       	ldi	r22, 0xFF	; 255
    6342:	7f ef       	ldi	r23, 0xFF	; 255
    6344:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
    6348:	f1 e0       	ldi	r31, 0x01	; 1
    634a:	f9 83       	std	Y+1, r31	; 0x01
    634c:	c3 cf       	rjmp	.-122    	; 0x62d4 <NextSlave+0xaa>
		}
	while (SlaveSkip[MB_N] &((uint32_t)1<<CurrSlave[MB_N]) && ++i<SlaveQt);
	if (i==SlaveQt) {
    634e:	10 17       	cp	r17, r16
    6350:	01 f1       	breq	.+64     	; 0x6392 <NextSlave+0x168>
		SlavesOn(MB_N);
		if (++CurrSlave[MB_N]==SlaveQt)
			CurrSlave[MB_N] = 0;
	}
	CurrQuery[MB_N] = 0;
    6352:	43 e5       	ldi	r20, 0x53	; 83
    6354:	56 e0       	ldi	r21, 0x06	; 6
    6356:	c4 0e       	add	r12, r20
    6358:	d5 1e       	adc	r13, r21
    635a:	f6 01       	movw	r30, r12
    635c:	10 82       	st	Z, r1
	return Over;
}
    635e:	89 81       	ldd	r24, Y+1	; 0x01
    6360:	26 96       	adiw	r28, 0x06	; 6
    6362:	0f b6       	in	r0, 0x3f	; 63
    6364:	f8 94       	cli
    6366:	de bf       	out	0x3e, r29	; 62
    6368:	0f be       	out	0x3f, r0	; 63
    636a:	cd bf       	out	0x3d, r28	; 61
    636c:	cf 91       	pop	r28
    636e:	df 91       	pop	r29
    6370:	1f 91       	pop	r17
    6372:	0f 91       	pop	r16
    6374:	ff 90       	pop	r15
    6376:	ef 90       	pop	r14
    6378:	df 90       	pop	r13
    637a:	cf 90       	pop	r12
    637c:	bf 90       	pop	r11
    637e:	af 90       	pop	r10
    6380:	9f 90       	pop	r9
    6382:	8f 90       	pop	r8
    6384:	7f 90       	pop	r7
    6386:	6f 90       	pop	r6
    6388:	5f 90       	pop	r5
    638a:	4f 90       	pop	r4
    638c:	3f 90       	pop	r3
    638e:	2f 90       	pop	r2
    6390:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~
static void
SlavesOn(uint8_t MB_N)
{
	SlaveSkip[MB_N] = 0;
    6392:	42 ee       	ldi	r20, 0xE2	; 226
    6394:	54 e0       	ldi	r21, 0x04	; 4
    6396:	24 0e       	add	r2, r20
    6398:	35 1e       	adc	r3, r21
    639a:	f1 01       	movw	r30, r2
    639c:	10 82       	st	Z, r1
    639e:	11 82       	std	Z+1, r1	; 0x01
    63a0:	12 82       	std	Z+2, r1	; 0x02
    63a2:	13 82       	std	Z+3, r1	; 0x03
	StartTimer16(TD_MB_SlaveOff+MB_N, 100*MB_M_TimeOff[MB_N]);
    63a4:	73 94       	inc	r7
    63a6:	f6 01       	movw	r30, r12
    63a8:	e3 52       	subi	r30, 0x23	; 35
    63aa:	fa 4f       	sbci	r31, 0xFA	; 250
    63ac:	60 81       	ld	r22, Z
    63ae:	84 e6       	ldi	r24, 0x64	; 100
    63b0:	68 9f       	mul	r22, r24
    63b2:	b0 01       	movw	r22, r0
    63b4:	11 24       	eor	r1, r1
    63b6:	87 2d       	mov	r24, r7
    63b8:	86 0d       	add	r24, r6
    63ba:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
			StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
		}
	while (SlaveSkip[MB_N] &((uint32_t)1<<CurrSlave[MB_N]) && ++i<SlaveQt);
	if (i==SlaveQt) {
		SlavesOn(MB_N);
		if (++CurrSlave[MB_N]==SlaveQt)
    63be:	ed 81       	ldd	r30, Y+5	; 0x05
    63c0:	fe 81       	ldd	r31, Y+6	; 0x06
    63c2:	80 81       	ld	r24, Z
    63c4:	8f 5f       	subi	r24, 0xFF	; 255
    63c6:	80 83       	st	Z, r24
    63c8:	18 17       	cp	r17, r24
    63ca:	19 f6       	brne	.-122    	; 0x6352 <NextSlave+0x128>
			CurrSlave[MB_N] = 0;
    63cc:	10 82       	st	Z, r1
    63ce:	c1 cf       	rjmp	.-126    	; 0x6352 <NextSlave+0x128>

000063d0 <FailSlave>:
}

// ~~~~~~~~~~~~~~~~~~~~
static uint8_t
FailSlave(uint8_t MB_N)
{
    63d0:	ef 92       	push	r14
    63d2:	ff 92       	push	r15
    63d4:	1f 93       	push	r17
    63d6:	cf 93       	push	r28
    63d8:	df 93       	push	r29
    63da:	18 2f       	mov	r17, r24
	uint8_t Over = 0;
	if (MB_SingleState[MB_N]==MB_SingleExec)
    63dc:	68 2f       	mov	r22, r24
    63de:	70 e0       	ldi	r23, 0x00	; 0
    63e0:	fb 01       	movw	r30, r22
    63e2:	e3 55       	subi	r30, 0x53	; 83
    63e4:	f9 4f       	sbci	r31, 0xF9	; 249
    63e6:	80 81       	ld	r24, Z
    63e8:	82 30       	cpi	r24, 0x02	; 2
    63ea:	19 f1       	breq	.+70     	; 0x6432 <FailSlave+0x62>
		MB_SingleState[MB_N] = MB_SingleIdle;
	else{
		MB_CPT[MB_N][4]++;	// -    
    63ec:	fb 01       	movw	r30, r22
    63ee:	ee 0f       	add	r30, r30
    63f0:	ff 1f       	adc	r31, r31
    63f2:	ee 0f       	add	r30, r30
    63f4:	ff 1f       	adc	r31, r31
    63f6:	ee 0f       	add	r30, r30
    63f8:	ff 1f       	adc	r31, r31
    63fa:	ee 0f       	add	r30, r30
    63fc:	ff 1f       	adc	r31, r31
    63fe:	ea 50       	subi	r30, 0x0A	; 10
    6400:	f7 4f       	sbci	r31, 0xF7	; 247
    6402:	80 81       	ld	r24, Z
    6404:	91 81       	ldd	r25, Z+1	; 0x01
    6406:	01 96       	adiw	r24, 0x01	; 1
    6408:	91 83       	std	Z+1, r25	; 0x01
    640a:	80 83       	st	Z, r24
		if (++Try[MB_N]==MB_M_Try[MB_N]) {
    640c:	eb 01       	movw	r28, r22
    640e:	cf 51       	subi	r28, 0x1F	; 31
    6410:	db 4f       	sbci	r29, 0xFB	; 251
    6412:	88 81       	ld	r24, Y
    6414:	8f 5f       	subi	r24, 0xFF	; 255
    6416:	88 83       	st	Y, r24
    6418:	fb 01       	movw	r30, r22
    641a:	e5 50       	subi	r30, 0x05	; 5
    641c:	f9 4f       	sbci	r31, 0xF9	; 249
    641e:	90 81       	ld	r25, Z
    6420:	89 17       	cp	r24, r25
    6422:	79 f0       	breq	.+30     	; 0x6442 <FailSlave+0x72>
    6424:	80 e0       	ldi	r24, 0x00	; 0
			Try[MB_N] = 0;
			Over = NextSlave(MB_N);
		}
	}
	return Over;
}
    6426:	df 91       	pop	r29
    6428:	cf 91       	pop	r28
    642a:	1f 91       	pop	r17
    642c:	ff 90       	pop	r15
    642e:	ef 90       	pop	r14
    6430:	08 95       	ret
static uint8_t
FailSlave(uint8_t MB_N)
{
	uint8_t Over = 0;
	if (MB_SingleState[MB_N]==MB_SingleExec)
		MB_SingleState[MB_N] = MB_SingleIdle;
    6432:	10 82       	st	Z, r1
    6434:	80 e0       	ldi	r24, 0x00	; 0
			Try[MB_N] = 0;
			Over = NextSlave(MB_N);
		}
	}
	return Over;
}
    6436:	df 91       	pop	r29
    6438:	cf 91       	pop	r28
    643a:	1f 91       	pop	r17
    643c:	ff 90       	pop	r15
    643e:	ef 90       	pop	r14
    6440:	08 95       	ret
	if (MB_SingleState[MB_N]==MB_SingleExec)
		MB_SingleState[MB_N] = MB_SingleIdle;
	else{
		MB_CPT[MB_N][4]++;	// -    
		if (++Try[MB_N]==MB_M_Try[MB_N]) {
			uint32_t S_N = (uint32_t)1<<CurrSlave[MB_N];
    6442:	fb 01       	movw	r30, r22
    6444:	ee 5a       	subi	r30, 0xAE	; 174
    6446:	f9 4f       	sbci	r31, 0xF9	; 249
    6448:	21 e0       	ldi	r18, 0x01	; 1
    644a:	30 e0       	ldi	r19, 0x00	; 0
    644c:	40 e0       	ldi	r20, 0x00	; 0
    644e:	50 e0       	ldi	r21, 0x00	; 0
    6450:	00 80       	ld	r0, Z
    6452:	04 c0       	rjmp	.+8      	; 0x645c <FailSlave+0x8c>
    6454:	22 0f       	add	r18, r18
    6456:	33 1f       	adc	r19, r19
    6458:	44 1f       	adc	r20, r20
    645a:	55 1f       	adc	r21, r21
    645c:	0a 94       	dec	r0
    645e:	d2 f7       	brpl	.-12     	; 0x6454 <FailSlave+0x84>
			SlaveOff[MB_N] |=S_N;
    6460:	7b 01       	movw	r14, r22
    6462:	ee 0c       	add	r14, r14
    6464:	ff 1c       	adc	r15, r15
    6466:	ee 0c       	add	r14, r14
    6468:	ff 1c       	adc	r15, r15
    646a:	b7 01       	movw	r22, r14
    646c:	6b 51       	subi	r22, 0x1B	; 27
    646e:	77 4f       	sbci	r23, 0xF7	; 247
    6470:	fb 01       	movw	r30, r22
    6472:	80 81       	ld	r24, Z
    6474:	91 81       	ldd	r25, Z+1	; 0x01
    6476:	a2 81       	ldd	r26, Z+2	; 0x02
    6478:	b3 81       	ldd	r27, Z+3	; 0x03
    647a:	82 2b       	or	r24, r18
    647c:	93 2b       	or	r25, r19
    647e:	a4 2b       	or	r26, r20
    6480:	b5 2b       	or	r27, r21
    6482:	80 83       	st	Z, r24
    6484:	91 83       	std	Z+1, r25	; 0x01
    6486:	a2 83       	std	Z+2, r26	; 0x02
    6488:	b3 83       	std	Z+3, r27	; 0x03
			SlaveSkip[MB_N] |=S_N;
    648a:	f7 01       	movw	r30, r14
    648c:	ee 51       	subi	r30, 0x1E	; 30
    648e:	fb 4f       	sbci	r31, 0xFB	; 251
    6490:	80 81       	ld	r24, Z
    6492:	91 81       	ldd	r25, Z+1	; 0x01
    6494:	a2 81       	ldd	r26, Z+2	; 0x02
    6496:	b3 81       	ldd	r27, Z+3	; 0x03
    6498:	28 2b       	or	r18, r24
    649a:	39 2b       	or	r19, r25
    649c:	4a 2b       	or	r20, r26
    649e:	5b 2b       	or	r21, r27
    64a0:	20 83       	st	Z, r18
    64a2:	31 83       	std	Z+1, r19	; 0x01
    64a4:	42 83       	std	Z+2, r20	; 0x02
    64a6:	53 83       	std	Z+3, r21	; 0x03
			Try[MB_N] = 0;
    64a8:	18 82       	st	Y, r1
			Over = NextSlave(MB_N);
    64aa:	81 2f       	mov	r24, r17
    64ac:	0e 94 15 31 	call	0x622a	; 0x622a <NextSlave>
		}
	}
	return Over;
}
    64b0:	df 91       	pop	r29
    64b2:	cf 91       	pop	r28
    64b4:	1f 91       	pop	r17
    64b6:	ff 90       	pop	r15
    64b8:	ef 90       	pop	r14
    64ba:	08 95       	ret

000064bc <MB_M_Timer_ISR>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_M_Timer_ISR(uint8_t MB_N)
{
    64bc:	4f 92       	push	r4
    64be:	5f 92       	push	r5
    64c0:	6f 92       	push	r6
    64c2:	7f 92       	push	r7
    64c4:	8f 92       	push	r8
    64c6:	9f 92       	push	r9
    64c8:	af 92       	push	r10
    64ca:	bf 92       	push	r11
    64cc:	cf 92       	push	r12
    64ce:	df 92       	push	r13
    64d0:	ef 92       	push	r14
    64d2:	ff 92       	push	r15
    64d4:	0f 93       	push	r16
    64d6:	1f 93       	push	r17
    64d8:	cf 93       	push	r28
    64da:	df 93       	push	r29
    64dc:	18 2f       	mov	r17, r24
	switch (MB_State[MB_N]) {
    64de:	c8 2f       	mov	r28, r24
    64e0:	d0 e0       	ldi	r29, 0x00	; 0
    64e2:	fe 01       	movw	r30, r28
    64e4:	e0 54       	subi	r30, 0x40	; 64
    64e6:	fa 4f       	sbci	r31, 0xFA	; 250
    64e8:	80 81       	ld	r24, Z
    64ea:	88 23       	and	r24, r24
    64ec:	f9 f4       	brne	.+62     	; 0x652c <MB_M_Timer_ISR+0x70>
	case MB_Initi:
		StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
    64ee:	80 91 e6 04 	lds	r24, 0x04E6
    64f2:	8e 5f       	subi	r24, 0xFE	; 254
    64f4:	81 0f       	add	r24, r17
    64f6:	6f ef       	ldi	r22, 0xFF	; 255
    64f8:	7f ef       	ldi	r23, 0xFF	; 255
    64fa:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
		FormQuery(MB_N);
    64fe:	81 2f       	mov	r24, r17
    6500:	0e 94 81 30 	call	0x6102	; 0x6102 <FormQuery>
		MB_Transm(MB_N);
    6504:	81 2f       	mov	r24, r17
    6506:	0e 94 79 29 	call	0x52f2	; 0x52f2 <MB_Transm>
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
		MB_M_CtrlProc(MB_N);
		break;
	}
}
    650a:	df 91       	pop	r29
    650c:	cf 91       	pop	r28
    650e:	1f 91       	pop	r17
    6510:	0f 91       	pop	r16
    6512:	ff 90       	pop	r15
    6514:	ef 90       	pop	r14
    6516:	df 90       	pop	r13
    6518:	cf 90       	pop	r12
    651a:	bf 90       	pop	r11
    651c:	af 90       	pop	r10
    651e:	9f 90       	pop	r9
    6520:	8f 90       	pop	r8
    6522:	7f 90       	pop	r7
    6524:	6f 90       	pop	r6
    6526:	5f 90       	pop	r5
    6528:	4f 90       	pop	r4
    652a:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_M_Timer_ISR(uint8_t MB_N)
{
	switch (MB_State[MB_N]) {
    652c:	82 30       	cpi	r24, 0x02	; 2
    652e:	69 f7       	brne	.-38     	; 0x650a <MB_M_Timer_ISR+0x4e>
		StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
		FormQuery(MB_N);
		MB_Transm(MB_N);
		break;
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
    6530:	84 e0       	ldi	r24, 0x04	; 4
    6532:	80 83       	st	Z, r24
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
MB_M_CtrlProc(uint8_t MB_N)
{
	uint8_t Over = 0;
	LastProcSingle = MB_SingleState[MB_N]==MB_SingleExec;
    6534:	ed ea       	ldi	r30, 0xAD	; 173
    6536:	ae 2e       	mov	r10, r30
    6538:	e6 e0       	ldi	r30, 0x06	; 6
    653a:	be 2e       	mov	r11, r30
    653c:	ac 0e       	add	r10, r28
    653e:	bd 1e       	adc	r11, r29
    6540:	d5 01       	movw	r26, r10
    6542:	8c 91       	ld	r24, X
    6544:	90 e0       	ldi	r25, 0x00	; 0
    6546:	82 30       	cpi	r24, 0x02	; 2
    6548:	09 f4       	brne	.+2      	; 0x654c <MB_M_Timer_ISR+0x90>
    654a:	4e c0       	rjmp	.+156    	; 0x65e8 <MB_M_Timer_ISR+0x12c>
    654c:	90 93 e0 04 	sts	0x04E0, r25
	if (CommErr(MB_N))
    6550:	81 2f       	mov	r24, r17
    6552:	0e 94 5d 2a 	call	0x54ba	; 0x54ba <CommErr>
    6556:	88 23       	and	r24, r24
    6558:	91 f5       	brne	.+100    	; 0x65be <MB_M_Timer_ISR+0x102>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    655a:	7e 01       	movw	r14, r28
    655c:	ee 0c       	add	r14, r14
    655e:	ff 1c       	adc	r15, r15
    6560:	ee 0c       	add	r14, r14
    6562:	ff 1c       	adc	r15, r15
    6564:	c7 01       	movw	r24, r14
    6566:	88 0f       	add	r24, r24
    6568:	99 1f       	adc	r25, r25
    656a:	88 0f       	add	r24, r24
    656c:	99 1f       	adc	r25, r25
    656e:	8e 0d       	add	r24, r14
    6570:	9f 1d       	adc	r25, r15
    6572:	87 58       	subi	r24, 0x87	; 135
    6574:	92 4d       	sbci	r25, 0xD2	; 210
    6576:	fc 01       	movw	r30, r24
    6578:	25 91       	lpm	r18, Z+
    657a:	34 91       	lpm	r19, Z+
		Over = FailSlave(MB_N);
	else {
		USART_Func(MB_N, LED);
    657c:	f9 01       	movw	r30, r18
    657e:	19 95       	eicall
		MB_Slave *Slave;
		MB_Query *Query;
		uint8_t Addr, Func;
		if (LastProcSingle) {
    6580:	80 91 e0 04 	lds	r24, 0x04E0
    6584:	88 23       	and	r24, r24
    6586:	91 f1       	breq	.+100    	; 0x65ec <MB_M_Timer_ISR+0x130>
			Addr = MB_SingleQuery[MB_N].Addr;
    6588:	fe 01       	movw	r30, r28
    658a:	ee 0f       	add	r30, r30
    658c:	ff 1f       	adc	r31, r31
    658e:	ee 0f       	add	r30, r30
    6590:	ff 1f       	adc	r31, r31
    6592:	ee 0f       	add	r30, r30
    6594:	ff 1f       	adc	r31, r31
    6596:	e8 52       	subi	r30, 0x28	; 40
    6598:	fb 4f       	sbci	r31, 0xFB	; 251
    659a:	20 81       	ld	r18, Z
			Func = MB_SingleQuery[MB_N].Func;
    659c:	91 81       	ldd	r25, Z+1	; 0x01
    659e:	40 e0       	ldi	r20, 0x00	; 0
    65a0:	50 e0       	ldi	r21, 0x00	; 0
    65a2:	60 e0       	ldi	r22, 0x00	; 0
    65a4:	70 e0       	ldi	r23, 0x00	; 0
			Slave = GetSlave(MB_N);
			Query = (MB_Query*)prp(&Slave->QueryList)+CurrQuery[MB_N];
			Addr = prb(&Slave->Addr);
			Func = prb(&Query->Func);
		}
		if (MB_Frame[MB_N][0]!=Addr || MB_Frame[MB_N][1]!=Func)
    65a6:	dc 2e       	mov	r13, r28
    65a8:	cc 24       	eor	r12, r12
    65aa:	f6 01       	movw	r30, r12
    65ac:	ed 5d       	subi	r30, 0xDD	; 221
    65ae:	f4 4f       	sbci	r31, 0xF4	; 244
    65b0:	80 81       	ld	r24, Z
    65b2:	82 17       	cp	r24, r18
    65b4:	21 f4       	brne	.+8      	; 0x65be <MB_M_Timer_ISR+0x102>
    65b6:	a1 81       	ldd	r26, Z+1	; 0x01
    65b8:	a9 17       	cp	r26, r25
    65ba:	09 f4       	brne	.+2      	; 0x65be <MB_M_Timer_ISR+0x102>
    65bc:	3d c0       	rjmp	.+122    	; 0x6638 <MB_M_Timer_ISR+0x17c>
				Err = MB_M_Force(MB_N, Query);
				break;
			}
			if (Err) {
				MB_CPT[MB_N][2]++;
				Over = FailSlave(MB_N);
    65be:	81 2f       	mov	r24, r17
    65c0:	0e 94 e8 31 	call	0x63d0	; 0x63d0 <FailSlave>
    65c4:	98 2f       	mov	r25, r24
			}
		}
		/*if (Over)
			USART_Func(MB_N, LED);*/
	}
	StartTimer16(TD_MB_Idle+MB_N, Over?MB_M_Period[MB_N]:MB_M_Pause_Min);
    65c6:	80 91 e6 04 	lds	r24, 0x04E6
    65ca:	81 0f       	add	r24, r17
    65cc:	99 23       	and	r25, r25
    65ce:	49 f0       	breq	.+18     	; 0x65e2 <MB_M_Timer_ISR+0x126>
    65d0:	cc 0f       	add	r28, r28
    65d2:	dd 1f       	adc	r29, r29
    65d4:	c5 55       	subi	r28, 0x55	; 85
    65d6:	d9 4f       	sbci	r29, 0xF9	; 249
    65d8:	68 81       	ld	r22, Y
    65da:	79 81       	ldd	r23, Y+1	; 0x01
    65dc:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
    65e0:	94 cf       	rjmp	.-216    	; 0x650a <MB_M_Timer_ISR+0x4e>
    65e2:	65 e0       	ldi	r22, 0x05	; 5
    65e4:	70 e0       	ldi	r23, 0x00	; 0
    65e6:	fa cf       	rjmp	.-12     	; 0x65dc <MB_M_Timer_ISR+0x120>
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
MB_M_CtrlProc(uint8_t MB_N)
{
	uint8_t Over = 0;
	LastProcSingle = MB_SingleState[MB_N]==MB_SingleExec;
    65e8:	91 e0       	ldi	r25, 0x01	; 1
    65ea:	b0 cf       	rjmp	.-160    	; 0x654c <MB_M_Timer_ISR+0x90>
    65ec:	83 e0       	ldi	r24, 0x03	; 3
    65ee:	18 9f       	mul	r17, r24
    65f0:	f0 01       	movw	r30, r0
    65f2:	11 24       	eor	r1, r1
    65f4:	e5 5b       	subi	r30, 0xB5	; 181
    65f6:	f6 4d       	sbci	r31, 0xD6	; 214
    65f8:	65 91       	lpm	r22, Z+
    65fa:	74 91       	lpm	r23, Z+

// ~~~~~~~~~~~~~~~~~~~
static MB_Slave*
GetSlave(uint8_t MB_N)
{
	return (MB_Slave*)prp(&(MB_Master_List+MB_N)->SlaveList)+CurrSlave[MB_N];
    65fc:	fe 01       	movw	r30, r28
    65fe:	ee 5a       	subi	r30, 0xAE	; 174
    6600:	f9 4f       	sbci	r31, 0xF9	; 249
    6602:	80 81       	ld	r24, Z
    6604:	90 e0       	ldi	r25, 0x00	; 0
    6606:	88 0f       	add	r24, r24
    6608:	99 1f       	adc	r25, r25
    660a:	88 0f       	add	r24, r24
    660c:	99 1f       	adc	r25, r25
    660e:	68 0f       	add	r22, r24
    6610:	79 1f       	adc	r23, r25
    6612:	fb 01       	movw	r30, r22
    6614:	31 96       	adiw	r30, 0x01	; 1
    6616:	45 91       	lpm	r20, Z+
    6618:	54 91       	lpm	r21, Z+
			Addr = MB_SingleQuery[MB_N].Addr;
			Func = MB_SingleQuery[MB_N].Func;
		}
		else {
			Slave = GetSlave(MB_N);
			Query = (MB_Query*)prp(&Slave->QueryList)+CurrQuery[MB_N];
    661a:	fe 01       	movw	r30, r28
    661c:	ed 5a       	subi	r30, 0xAD	; 173
    661e:	f9 4f       	sbci	r31, 0xF9	; 249
    6620:	80 81       	ld	r24, Z
    6622:	27 e0       	ldi	r18, 0x07	; 7
    6624:	82 9f       	mul	r24, r18
    6626:	c0 01       	movw	r24, r0
    6628:	11 24       	eor	r1, r1
    662a:	48 0f       	add	r20, r24
    662c:	59 1f       	adc	r21, r25

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    662e:	fb 01       	movw	r30, r22
    6630:	24 91       	lpm	r18, Z+
		}
		if (MB_Frame[MB_N][0]!=Addr || MB_Frame[MB_N][1]!=Func)
			Over = FailSlave(MB_N);
		else {
			uint8_t Err;
			switch (Func) {
    6632:	fa 01       	movw	r30, r20
    6634:	94 91       	lpm	r25, Z+
    6636:	b7 cf       	rjmp	.-146    	; 0x65a6 <MB_M_Timer_ISR+0xea>
    6638:	95 30       	cpi	r25, 0x05	; 5
    663a:	18 f5       	brcc	.+70     	; 0x6682 <MB_M_Timer_ISR+0x1c6>
    663c:	93 30       	cpi	r25, 0x03	; 3
    663e:	08 f4       	brcc	.+2      	; 0x6642 <MB_M_Timer_ISR+0x186>
    6640:	ad c0       	rjmp	.+346    	; 0x679c <MB_M_Timer_ISR+0x2e0>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_M_ReadReg(uint8_t MB_N, MB_Query *Query)
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || (LastProcSingle?MB_SingleQuery[MB_N].Qt:prw(&Query->Qt))*2!=MB_Frame[MB_N][2])
    6642:	fc 2f       	mov	r31, r28
    6644:	ee 27       	eor	r30, r30
    6646:	eb 5d       	subi	r30, 0xDB	; 219
    6648:	f4 4f       	sbci	r31, 0xF4	; 244
    664a:	b0 81       	ld	r27, Z
    664c:	fe 01       	movw	r30, r28
    664e:	eb 5f       	subi	r30, 0xFB	; 251
    6650:	f8 4f       	sbci	r31, 0xF8	; 248
    6652:	80 81       	ld	r24, Z
    6654:	90 e0       	ldi	r25, 0x00	; 0
    6656:	8b 2e       	mov	r8, r27
    6658:	99 24       	eor	r9, r9
    665a:	94 01       	movw	r18, r8
    665c:	2b 5f       	subi	r18, 0xFB	; 251
    665e:	3f 4f       	sbci	r19, 0xFF	; 255
    6660:	82 17       	cp	r24, r18
    6662:	93 07       	cpc	r25, r19
    6664:	09 f4       	brne	.+2      	; 0x6668 <MB_M_Timer_ISR+0x1ac>
    6666:	94 c1       	rjmp	.+808    	; 0x6990 <MB_M_Timer_ISR+0x4d4>
			case 0x0F: case 0x10:
				Err = MB_M_Force(MB_N, Query);
				break;
			}
			if (Err) {
				MB_CPT[MB_N][2]++;
    6668:	f7 01       	movw	r30, r14
    666a:	ee 0f       	add	r30, r30
    666c:	ff 1f       	adc	r31, r31
    666e:	ee 0f       	add	r30, r30
    6670:	ff 1f       	adc	r31, r31
    6672:	ee 50       	subi	r30, 0x0E	; 14
    6674:	f7 4f       	sbci	r31, 0xF7	; 247
    6676:	80 81       	ld	r24, Z
    6678:	91 81       	ldd	r25, Z+1	; 0x01
    667a:	01 96       	adiw	r24, 0x01	; 1
    667c:	91 83       	std	Z+1, r25	; 0x01
    667e:	80 83       	st	Z, r24
    6680:	9e cf       	rjmp	.-196    	; 0x65be <MB_M_Timer_ISR+0x102>
		}
		if (MB_Frame[MB_N][0]!=Addr || MB_Frame[MB_N][1]!=Func)
			Over = FailSlave(MB_N);
		else {
			uint8_t Err;
			switch (Func) {
    6682:	96 30       	cpi	r25, 0x06	; 6
    6684:	09 f4       	brne	.+2      	; 0x6688 <MB_M_Timer_ISR+0x1cc>
    6686:	18 c1       	rjmp	.+560    	; 0x68b8 <MB_M_Timer_ISR+0x3fc>
    6688:	96 30       	cpi	r25, 0x06	; 6
    668a:	08 f4       	brcc	.+2      	; 0x668e <MB_M_Timer_ISR+0x1d2>
    668c:	43 c0       	rjmp	.+134    	; 0x6714 <MB_M_Timer_ISR+0x258>
    668e:	9f 50       	subi	r25, 0x0F	; 15
    6690:	92 30       	cpi	r25, 0x02	; 2
    6692:	08 f0       	brcs	.+2      	; 0x6696 <MB_M_Timer_ISR+0x1da>
    6694:	3f c0       	rjmp	.+126    	; 0x6714 <MB_M_Timer_ISR+0x258>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_M_Force(uint8_t MB_N, MB_Query *Query)
{
	uint16_t StartAddr, Qt;
	if (LastProcSingle) {
    6696:	80 91 e0 04 	lds	r24, 0x04E0
    669a:	88 23       	and	r24, r24
    669c:	09 f4       	brne	.+2      	; 0x66a0 <MB_M_Timer_ISR+0x1e4>
    669e:	4e c1       	rjmp	.+668    	; 0x693c <MB_M_Timer_ISR+0x480>
		StartAddr	= MB_SingleQuery[MB_N].StartAddr;
    66a0:	f7 01       	movw	r30, r14
    66a2:	ee 0f       	add	r30, r30
    66a4:	ff 1f       	adc	r31, r31
    66a6:	e6 52       	subi	r30, 0x26	; 38
    66a8:	fb 4f       	sbci	r31, 0xFB	; 251
    66aa:	80 80       	ld	r8, Z
    66ac:	91 80       	ldd	r9, Z+1	; 0x01
		Qt				= MB_SingleQuery[MB_N].Qt;
    66ae:	fe 01       	movw	r30, r28
    66b0:	ee 0f       	add	r30, r30
    66b2:	ff 1f       	adc	r31, r31
    66b4:	ee 0f       	add	r30, r30
    66b6:	ff 1f       	adc	r31, r31
    66b8:	ee 0f       	add	r30, r30
    66ba:	ff 1f       	adc	r31, r31
    66bc:	e4 52       	subi	r30, 0x24	; 36
    66be:	fb 4f       	sbci	r31, 0xFB	; 251
    66c0:	40 81       	ld	r20, Z
    66c2:	51 81       	ldd	r21, Z+1	; 0x01
	}
	else {
		StartAddr	= prw(&Query->StartAddr);
		Qt				= prw(&Query->Qt);
	}
	return MB_Frame_Sz[MB_N]!=8 || MB_FrameReg(MB_N, 2)!=StartAddr || MB_FrameReg(MB_N, 4)!=Qt;
    66c4:	fe 01       	movw	r30, r28
    66c6:	eb 5f       	subi	r30, 0xFB	; 251
    66c8:	f8 4f       	sbci	r31, 0xF8	; 248
    66ca:	80 81       	ld	r24, Z
    66cc:	88 30       	cpi	r24, 0x08	; 8
    66ce:	61 f6       	brne	.-104    	; 0x6668 <MB_M_Timer_ISR+0x1ac>
    66d0:	fc 2f       	mov	r31, r28
    66d2:	ee 27       	eor	r30, r30
    66d4:	eb 5d       	subi	r30, 0xDB	; 219
    66d6:	f4 4f       	sbci	r31, 0xF4	; 244
    66d8:	30 81       	ld	r19, Z
    66da:	20 e0       	ldi	r18, 0x00	; 0
    66dc:	d6 01       	movw	r26, r12
    66de:	ad 5d       	subi	r26, 0xDD	; 221
    66e0:	b4 4f       	sbci	r27, 0xF4	; 244
    66e2:	13 96       	adiw	r26, 0x03	; 3
    66e4:	8c 91       	ld	r24, X
    66e6:	13 97       	sbiw	r26, 0x03	; 3
    66e8:	90 e0       	ldi	r25, 0x00	; 0
    66ea:	28 2b       	or	r18, r24
    66ec:	39 2b       	or	r19, r25
    66ee:	28 15       	cp	r18, r8
    66f0:	39 05       	cpc	r19, r9
    66f2:	09 f0       	breq	.+2      	; 0x66f6 <MB_M_Timer_ISR+0x23a>
    66f4:	b9 cf       	rjmp	.-142    	; 0x6668 <MB_M_Timer_ISR+0x1ac>
    66f6:	fc 2f       	mov	r31, r28
    66f8:	ee 27       	eor	r30, r30
    66fa:	e9 5d       	subi	r30, 0xD9	; 217
    66fc:	f4 4f       	sbci	r31, 0xF4	; 244
    66fe:	90 81       	ld	r25, Z
    6700:	80 e0       	ldi	r24, 0x00	; 0
    6702:	15 96       	adiw	r26, 0x05	; 5
    6704:	2c 91       	ld	r18, X
    6706:	30 e0       	ldi	r19, 0x00	; 0
    6708:	82 2b       	or	r24, r18
    670a:	93 2b       	or	r25, r19
    670c:	84 17       	cp	r24, r20
    670e:	95 07       	cpc	r25, r21
    6710:	09 f0       	breq	.+2      	; 0x6714 <MB_M_Timer_ISR+0x258>
    6712:	aa cf       	rjmp	.-172    	; 0x6668 <MB_M_Timer_ISR+0x1ac>
			}
			if (Err) {
				MB_CPT[MB_N][2]++;
				Over = FailSlave(MB_N);
			}
			else if (LastProcSingle)
    6714:	80 91 e0 04 	lds	r24, 0x04E0
    6718:	88 23       	and	r24, r24
    671a:	41 f0       	breq	.+16     	; 0x672c <MB_M_Timer_ISR+0x270>
				MB_SingleState[MB_N] = MB_SingleIdle;
    671c:	d5 01       	movw	r26, r10
    671e:	1c 92       	st	X, r1
			}
		}
		/*if (Over)
			USART_Func(MB_N, LED);*/
	}
	StartTimer16(TD_MB_Idle+MB_N, Over?MB_M_Period[MB_N]:MB_M_Pause_Min);
    6720:	80 91 e6 04 	lds	r24, 0x04E6
    6724:	81 0f       	add	r24, r17
    6726:	65 e0       	ldi	r22, 0x05	; 5
    6728:	70 e0       	ldi	r23, 0x00	; 0
    672a:	58 cf       	rjmp	.-336    	; 0x65dc <MB_M_Timer_ISR+0x120>
				Over = FailSlave(MB_N);
			}
			else if (LastProcSingle)
				MB_SingleState[MB_N] = MB_SingleIdle;
			else {
				SlaveOff[MB_N] &=~((uint32_t)1<<CurrSlave[MB_N]);
    672c:	e5 ee       	ldi	r30, 0xE5	; 229
    672e:	f8 e0       	ldi	r31, 0x08	; 8
    6730:	ee 0e       	add	r14, r30
    6732:	ff 1e       	adc	r15, r31
    6734:	9e 01       	movw	r18, r28
    6736:	2e 5a       	subi	r18, 0xAE	; 174
    6738:	39 4f       	sbci	r19, 0xF9	; 249
    673a:	81 e0       	ldi	r24, 0x01	; 1
    673c:	90 e0       	ldi	r25, 0x00	; 0
    673e:	a0 e0       	ldi	r26, 0x00	; 0
    6740:	b0 e0       	ldi	r27, 0x00	; 0
    6742:	f9 01       	movw	r30, r18
    6744:	00 80       	ld	r0, Z
    6746:	04 c0       	rjmp	.+8      	; 0x6750 <MB_M_Timer_ISR+0x294>
    6748:	88 0f       	add	r24, r24
    674a:	99 1f       	adc	r25, r25
    674c:	aa 1f       	adc	r26, r26
    674e:	bb 1f       	adc	r27, r27
    6750:	0a 94       	dec	r0
    6752:	d2 f7       	brpl	.-12     	; 0x6748 <MB_M_Timer_ISR+0x28c>
    6754:	80 95       	com	r24
    6756:	90 95       	com	r25
    6758:	a0 95       	com	r26
    675a:	b0 95       	com	r27
    675c:	f7 01       	movw	r30, r14
    675e:	20 81       	ld	r18, Z
    6760:	31 81       	ldd	r19, Z+1	; 0x01
    6762:	42 81       	ldd	r20, Z+2	; 0x02
    6764:	53 81       	ldd	r21, Z+3	; 0x03
    6766:	82 23       	and	r24, r18
    6768:	93 23       	and	r25, r19
    676a:	a4 23       	and	r26, r20
    676c:	b5 23       	and	r27, r21
    676e:	80 83       	st	Z, r24
    6770:	91 83       	std	Z+1, r25	; 0x01
    6772:	a2 83       	std	Z+2, r26	; 0x02
    6774:	b3 83       	std	Z+3, r27	; 0x03
				if (++CurrQuery[MB_N]==prb(&Slave->QueryQt))
    6776:	fe 01       	movw	r30, r28
    6778:	ed 5a       	subi	r30, 0xAD	; 173
    677a:	f9 4f       	sbci	r31, 0xF9	; 249
    677c:	80 81       	ld	r24, Z
    677e:	8f 5f       	subi	r24, 0xFF	; 255
    6780:	80 83       	st	Z, r24
    6782:	6d 5f       	subi	r22, 0xFD	; 253
    6784:	7f 4f       	sbci	r23, 0xFF	; 255
    6786:	fb 01       	movw	r30, r22
    6788:	94 91       	lpm	r25, Z+
    678a:	89 17       	cp	r24, r25
    678c:	09 f4       	brne	.+2      	; 0x6790 <MB_M_Timer_ISR+0x2d4>
    678e:	55 c1       	rjmp	.+682    	; 0x6a3a <MB_M_Timer_ISR+0x57e>
    6790:	90 e0       	ldi	r25, 0x00	; 0
					Over = NextSlave(MB_N);
				Try[MB_N] = 0;
    6792:	fe 01       	movw	r30, r28
    6794:	ef 51       	subi	r30, 0x1F	; 31
    6796:	fb 4f       	sbci	r31, 0xFB	; 251
    6798:	10 82       	st	Z, r1
    679a:	15 cf       	rjmp	.-470    	; 0x65c6 <MB_M_Timer_ISR+0x10a>
		}
		if (MB_Frame[MB_N][0]!=Addr || MB_Frame[MB_N][1]!=Func)
			Over = FailSlave(MB_N);
		else {
			uint8_t Err;
			switch (Func) {
    679c:	91 30       	cpi	r25, 0x01	; 1
    679e:	08 f4       	brcc	.+2      	; 0x67a2 <MB_M_Timer_ISR+0x2e6>
    67a0:	b9 cf       	rjmp	.-142    	; 0x6714 <MB_M_Timer_ISR+0x258>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_M_ReadDiscr(uint8_t MB_N, MB_Query *Query)
{
	uint8_t Qt = LastProcSingle ? MB_SingleQuery[MB_N].Qt : prb((uint8_t*)&Query->Qt);
    67a2:	80 91 e0 04 	lds	r24, 0x04E0
    67a6:	88 23       	and	r24, r24
    67a8:	09 f4       	brne	.+2      	; 0x67ac <MB_M_Timer_ISR+0x2f0>
    67aa:	eb c0       	rjmp	.+470    	; 0x6982 <MB_M_Timer_ISR+0x4c6>
    67ac:	fe 01       	movw	r30, r28
    67ae:	ee 0f       	add	r30, r30
    67b0:	ff 1f       	adc	r31, r31
    67b2:	ee 0f       	add	r30, r30
    67b4:	ff 1f       	adc	r31, r31
    67b6:	ee 0f       	add	r30, r30
    67b8:	ff 1f       	adc	r31, r31
    67ba:	e4 52       	subi	r30, 0x24	; 36
    67bc:	fb 4f       	sbci	r31, 0xFB	; 251
    67be:	b0 81       	ld	r27, Z
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || Qt/8+((Qt%8)>0)!=MB_Frame[MB_N][2])
    67c0:	fc 2f       	mov	r31, r28
    67c2:	ee 27       	eor	r30, r30
    67c4:	eb 5d       	subi	r30, 0xDB	; 219
    67c6:	f4 4f       	sbci	r31, 0xF4	; 244
    67c8:	80 81       	ld	r24, Z
    67ca:	88 2e       	mov	r8, r24
    67cc:	99 24       	eor	r9, r9
    67ce:	fe 01       	movw	r30, r28
    67d0:	eb 5f       	subi	r30, 0xFB	; 251
    67d2:	f8 4f       	sbci	r31, 0xF8	; 248
    67d4:	80 81       	ld	r24, Z
    67d6:	90 e0       	ldi	r25, 0x00	; 0
    67d8:	94 01       	movw	r18, r8
    67da:	2b 5f       	subi	r18, 0xFB	; 251
    67dc:	3f 4f       	sbci	r19, 0xFF	; 255
    67de:	82 17       	cp	r24, r18
    67e0:	93 07       	cpc	r25, r19
    67e2:	09 f0       	breq	.+2      	; 0x67e6 <MB_M_Timer_ISR+0x32a>
    67e4:	41 cf       	rjmp	.-382    	; 0x6668 <MB_M_Timer_ISR+0x1ac>
    67e6:	20 e0       	ldi	r18, 0x00	; 0
    67e8:	30 e0       	ldi	r19, 0x00	; 0
    67ea:	6b 2e       	mov	r6, r27
    67ec:	77 24       	eor	r7, r7
    67ee:	c3 01       	movw	r24, r6
    67f0:	87 70       	andi	r24, 0x07	; 7
    67f2:	90 70       	andi	r25, 0x00	; 0
    67f4:	18 16       	cp	r1, r24
    67f6:	19 06       	cpc	r1, r25
    67f8:	14 f4       	brge	.+4      	; 0x67fe <MB_M_Timer_ISR+0x342>
    67fa:	21 e0       	ldi	r18, 0x01	; 1
    67fc:	30 e0       	ldi	r19, 0x00	; 0
    67fe:	b6 95       	lsr	r27
    6800:	b6 95       	lsr	r27
    6802:	b6 95       	lsr	r27
    6804:	2b 0f       	add	r18, r27
    6806:	31 1d       	adc	r19, r1
    6808:	82 16       	cp	r8, r18
    680a:	93 06       	cpc	r9, r19
    680c:	09 f0       	breq	.+2      	; 0x6810 <MB_M_Timer_ISR+0x354>
    680e:	2c cf       	rjmp	.-424    	; 0x6668 <MB_M_Timer_ISR+0x1ac>
		return 1;
	uint8_t *Discr;
	uint8_t Pin;
	if (LastProcSingle) {
    6810:	80 91 e0 04 	lds	r24, 0x04E0
    6814:	88 23       	and	r24, r24
    6816:	09 f4       	brne	.+2      	; 0x681a <MB_M_Timer_ISR+0x35e>
    6818:	1d c1       	rjmp	.+570    	; 0x6a54 <MB_M_Timer_ISR+0x598>
		Discr = MB_SingleQuery[MB_N].Buf;
    681a:	fe 01       	movw	r30, r28
    681c:	ee 0f       	add	r30, r30
    681e:	ff 1f       	adc	r31, r31
    6820:	ee 0f       	add	r30, r30
    6822:	ff 1f       	adc	r31, r31
    6824:	ee 0f       	add	r30, r30
    6826:	ff 1f       	adc	r31, r31
    6828:	e8 52       	subi	r30, 0x28	; 40
    682a:	fb 4f       	sbci	r31, 0xFB	; 251
    682c:	86 80       	ldd	r8, Z+6	; 0x06
    682e:	97 80       	ldd	r9, Z+7	; 0x07
    6830:	00 e0       	ldi	r16, 0x00	; 0
	}
	else {
		Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
		Pin = prw(&Query->AllocAddr);
	}
	for (uint16_t i=0; i<Qt; i++) {
    6832:	61 14       	cp	r6, r1
    6834:	71 04       	cpc	r7, r1
    6836:	09 f4       	brne	.+2      	; 0x683a <MB_M_Timer_ISR+0x37e>
    6838:	6d cf       	rjmp	.-294    	; 0x6714 <MB_M_Timer_ISR+0x258>
    683a:	40 e0       	ldi	r20, 0x00	; 0
    683c:	50 e0       	ldi	r21, 0x00	; 0
		uint8_t j = Pin+i;
		uint8_t Byte=j/8, Bit=1<<j%8;
    683e:	21 e0       	ldi	r18, 0x01	; 1
    6840:	42 2e       	mov	r4, r18
    6842:	51 2c       	mov	r5, r1
		if (MB_Frame[MB_N][3+i/8] &(1<<i%8))
    6844:	83 e2       	ldi	r24, 0x23	; 35
    6846:	9b e0       	ldi	r25, 0x0B	; 11
    6848:	c8 0e       	add	r12, r24
    684a:	d9 1e       	adc	r13, r25
    684c:	0c c0       	rjmp	.+24     	; 0x6866 <MB_M_Timer_ISR+0x3aa>
			Discr[Byte] |=Bit;
    684e:	f4 01       	movw	r30, r8
    6850:	eb 0f       	add	r30, r27
    6852:	f1 1d       	adc	r31, r1
    6854:	80 81       	ld	r24, Z
    6856:	8a 2b       	or	r24, r26
    6858:	80 83       	st	Z, r24
	}
	else {
		Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
		Pin = prw(&Query->AllocAddr);
	}
	for (uint16_t i=0; i<Qt; i++) {
    685a:	4f 5f       	subi	r20, 0xFF	; 255
    685c:	5f 4f       	sbci	r21, 0xFF	; 255
    685e:	46 15       	cp	r20, r6
    6860:	57 05       	cpc	r21, r7
    6862:	08 f0       	brcs	.+2      	; 0x6866 <MB_M_Timer_ISR+0x3aa>
    6864:	57 cf       	rjmp	.-338    	; 0x6714 <MB_M_Timer_ISR+0x258>
    6866:	80 2f       	mov	r24, r16
    6868:	84 0f       	add	r24, r20
		uint8_t j = Pin+i;
		uint8_t Byte=j/8, Bit=1<<j%8;
    686a:	b8 2f       	mov	r27, r24
    686c:	b6 95       	lsr	r27
    686e:	b6 95       	lsr	r27
    6870:	b6 95       	lsr	r27
    6872:	87 70       	andi	r24, 0x07	; 7
    6874:	a4 2d       	mov	r26, r4
    6876:	01 c0       	rjmp	.+2      	; 0x687a <MB_M_Timer_ISR+0x3be>
    6878:	aa 0f       	add	r26, r26
    687a:	8a 95       	dec	r24
    687c:	ea f7       	brpl	.-6      	; 0x6878 <MB_M_Timer_ISR+0x3bc>
		if (MB_Frame[MB_N][3+i/8] &(1<<i%8))
    687e:	fa 01       	movw	r30, r20
    6880:	f6 95       	lsr	r31
    6882:	e7 95       	ror	r30
    6884:	f6 95       	lsr	r31
    6886:	e7 95       	ror	r30
    6888:	f6 95       	lsr	r31
    688a:	e7 95       	ror	r30
    688c:	ec 0d       	add	r30, r12
    688e:	fd 1d       	adc	r31, r13
    6890:	83 81       	ldd	r24, Z+3	; 0x03
    6892:	90 e0       	ldi	r25, 0x00	; 0
    6894:	9a 01       	movw	r18, r20
    6896:	27 70       	andi	r18, 0x07	; 7
    6898:	30 70       	andi	r19, 0x00	; 0
    689a:	02 c0       	rjmp	.+4      	; 0x68a0 <MB_M_Timer_ISR+0x3e4>
    689c:	95 95       	asr	r25
    689e:	87 95       	ror	r24
    68a0:	2a 95       	dec	r18
    68a2:	e2 f7       	brpl	.-8      	; 0x689c <MB_M_Timer_ISR+0x3e0>
    68a4:	80 fd       	sbrc	r24, 0
    68a6:	d3 cf       	rjmp	.-90     	; 0x684e <MB_M_Timer_ISR+0x392>
			Discr[Byte] |=Bit;
		else
			Discr[Byte] &=~Bit;
    68a8:	f4 01       	movw	r30, r8
    68aa:	eb 0f       	add	r30, r27
    68ac:	f1 1d       	adc	r31, r1
    68ae:	a0 95       	com	r26
    68b0:	80 81       	ld	r24, Z
    68b2:	8a 23       	and	r24, r26
    68b4:	80 83       	st	Z, r24
    68b6:	d1 cf       	rjmp	.-94     	; 0x685a <MB_M_Timer_ISR+0x39e>
inline static uint8_t
MB_M_PresetSingle(uint8_t MB_N, MB_Query *Query)
{
	uint16_t StartAddr;
	uint16_t *Reg;
	if (LastProcSingle) {
    68b8:	80 91 e0 04 	lds	r24, 0x04E0
    68bc:	88 23       	and	r24, r24
    68be:	09 f4       	brne	.+2      	; 0x68c2 <MB_M_Timer_ISR+0x406>
    68c0:	46 c0       	rjmp	.+140    	; 0x694e <MB_M_Timer_ISR+0x492>
		StartAddr = MB_SingleQuery[MB_N].StartAddr;
    68c2:	f7 01       	movw	r30, r14
    68c4:	ee 0f       	add	r30, r30
    68c6:	ff 1f       	adc	r31, r31
    68c8:	e6 52       	subi	r30, 0x26	; 38
    68ca:	fb 4f       	sbci	r31, 0xFB	; 251
    68cc:	80 80       	ld	r8, Z
    68ce:	91 80       	ldd	r9, Z+1	; 0x01
		Reg = MB_SingleQuery[MB_N].Buf;
    68d0:	fe 01       	movw	r30, r28
    68d2:	ee 0f       	add	r30, r30
    68d4:	ff 1f       	adc	r31, r31
    68d6:	ee 0f       	add	r30, r30
    68d8:	ff 1f       	adc	r31, r31
    68da:	ee 0f       	add	r30, r30
    68dc:	ff 1f       	adc	r31, r31
    68de:	e8 52       	subi	r30, 0x28	; 40
    68e0:	fb 4f       	sbci	r31, 0xFB	; 251
    68e2:	a6 81       	ldd	r26, Z+6	; 0x06
    68e4:	b7 81       	ldd	r27, Z+7	; 0x07
	}
	else {
		StartAddr = prw(&Query->StartAddr);
		Reg = (uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+prw(&Query->AllocAddr);
	}
	return MB_Frame_Sz[MB_N]!=8 || MB_FrameReg(MB_N, 2)!=StartAddr || MB_FrameReg(MB_N, 4)!=*Reg;
    68e6:	fe 01       	movw	r30, r28
    68e8:	eb 5f       	subi	r30, 0xFB	; 251
    68ea:	f8 4f       	sbci	r31, 0xF8	; 248
    68ec:	80 81       	ld	r24, Z
    68ee:	88 30       	cpi	r24, 0x08	; 8
    68f0:	09 f0       	breq	.+2      	; 0x68f4 <MB_M_Timer_ISR+0x438>
    68f2:	ba ce       	rjmp	.-652    	; 0x6668 <MB_M_Timer_ISR+0x1ac>
    68f4:	fc 2f       	mov	r31, r28
    68f6:	ee 27       	eor	r30, r30
    68f8:	eb 5d       	subi	r30, 0xDB	; 219
    68fa:	f4 4f       	sbci	r31, 0xF4	; 244
    68fc:	30 81       	ld	r19, Z
    68fe:	20 e0       	ldi	r18, 0x00	; 0
    6900:	a6 01       	movw	r20, r12
    6902:	4d 5d       	subi	r20, 0xDD	; 221
    6904:	54 4f       	sbci	r21, 0xF4	; 244
    6906:	fa 01       	movw	r30, r20
    6908:	83 81       	ldd	r24, Z+3	; 0x03
    690a:	90 e0       	ldi	r25, 0x00	; 0
    690c:	28 2b       	or	r18, r24
    690e:	39 2b       	or	r19, r25
    6910:	28 15       	cp	r18, r8
    6912:	39 05       	cpc	r19, r9
    6914:	09 f0       	breq	.+2      	; 0x6918 <MB_M_Timer_ISR+0x45c>
    6916:	a8 ce       	rjmp	.-688    	; 0x6668 <MB_M_Timer_ISR+0x1ac>
    6918:	fc 2f       	mov	r31, r28
    691a:	ee 27       	eor	r30, r30
    691c:	e9 5d       	subi	r30, 0xD9	; 217
    691e:	f4 4f       	sbci	r31, 0xF4	; 244
    6920:	30 81       	ld	r19, Z
    6922:	20 e0       	ldi	r18, 0x00	; 0
    6924:	fa 01       	movw	r30, r20
    6926:	85 81       	ldd	r24, Z+5	; 0x05
    6928:	90 e0       	ldi	r25, 0x00	; 0
    692a:	28 2b       	or	r18, r24
    692c:	39 2b       	or	r19, r25
    692e:	8d 91       	ld	r24, X+
    6930:	9c 91       	ld	r25, X
    6932:	28 17       	cp	r18, r24
    6934:	39 07       	cpc	r19, r25
    6936:	09 f0       	breq	.+2      	; 0x693a <MB_M_Timer_ISR+0x47e>
    6938:	97 ce       	rjmp	.-722    	; 0x6668 <MB_M_Timer_ISR+0x1ac>
    693a:	ec ce       	rjmp	.-552    	; 0x6714 <MB_M_Timer_ISR+0x258>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    693c:	fa 01       	movw	r30, r20
    693e:	31 96       	adiw	r30, 0x01	; 1
    6940:	85 90       	lpm	r8, Z+
    6942:	94 90       	lpm	r9, Z+

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6944:	fa 01       	movw	r30, r20
    6946:	33 96       	adiw	r30, 0x03	; 3
    6948:	45 91       	lpm	r20, Z+
    694a:	54 91       	lpm	r21, Z+
    694c:	bb ce       	rjmp	.-650    	; 0x66c4 <MB_M_Timer_ISR+0x208>
    694e:	fa 01       	movw	r30, r20
    6950:	31 96       	adiw	r30, 0x01	; 1
    6952:	85 90       	lpm	r8, Z+
    6954:	94 90       	lpm	r9, Z+
    6956:	fe 01       	movw	r30, r28
    6958:	ee 0f       	add	r30, r30
    695a:	ff 1f       	adc	r31, r31
    695c:	ee 0f       	add	r30, r30
    695e:	ff 1f       	adc	r31, r31
    6960:	ee 0f       	add	r30, r30
    6962:	ff 1f       	adc	r31, r31
    6964:	ee 0f       	add	r30, r30
    6966:	ff 1f       	adc	r31, r31
    6968:	e8 5c       	subi	r30, 0xC8	; 200
    696a:	fc 4f       	sbci	r31, 0xFC	; 252
    696c:	a5 91       	lpm	r26, Z+
    696e:	b4 91       	lpm	r27, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    6970:	fa 01       	movw	r30, r20
    6972:	35 96       	adiw	r30, 0x05	; 5
    6974:	85 91       	lpm	r24, Z+
    6976:	94 91       	lpm	r25, Z+
		StartAddr = MB_SingleQuery[MB_N].StartAddr;
		Reg = MB_SingleQuery[MB_N].Buf;
	}
	else {
		StartAddr = prw(&Query->StartAddr);
		Reg = (uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+prw(&Query->AllocAddr);
    6978:	88 0f       	add	r24, r24
    697a:	99 1f       	adc	r25, r25
    697c:	a8 0f       	add	r26, r24
    697e:	b9 1f       	adc	r27, r25
    6980:	b2 cf       	rjmp	.-156    	; 0x68e6 <MB_M_Timer_ISR+0x42a>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    6982:	4d 5f       	subi	r20, 0xFD	; 253
    6984:	5f 4f       	sbci	r21, 0xFF	; 255
    6986:	fa 01       	movw	r30, r20
    6988:	b4 91       	lpm	r27, Z+
    698a:	43 50       	subi	r20, 0x03	; 3
    698c:	50 40       	sbci	r21, 0x00	; 0
    698e:	18 cf       	rjmp	.-464    	; 0x67c0 <MB_M_Timer_ISR+0x304>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_M_ReadReg(uint8_t MB_N, MB_Query *Query)
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || (LastProcSingle?MB_SingleQuery[MB_N].Qt:prw(&Query->Qt))*2!=MB_Frame[MB_N][2])
    6990:	80 91 e0 04 	lds	r24, 0x04E0
    6994:	88 23       	and	r24, r24
    6996:	09 f4       	brne	.+2      	; 0x699a <MB_M_Timer_ISR+0x4de>
    6998:	55 c0       	rjmp	.+170    	; 0x6a44 <MB_M_Timer_ISR+0x588>
    699a:	fe 01       	movw	r30, r28
    699c:	ee 0f       	add	r30, r30
    699e:	ff 1f       	adc	r31, r31
    69a0:	ee 0f       	add	r30, r30
    69a2:	ff 1f       	adc	r31, r31
    69a4:	ee 0f       	add	r30, r30
    69a6:	ff 1f       	adc	r31, r31
    69a8:	e4 52       	subi	r30, 0x24	; 36
    69aa:	fb 4f       	sbci	r31, 0xFB	; 251
    69ac:	20 81       	ld	r18, Z
    69ae:	31 81       	ldd	r19, Z+1	; 0x01
    69b0:	22 0f       	add	r18, r18
    69b2:	33 1f       	adc	r19, r19
    69b4:	82 16       	cp	r8, r18
    69b6:	93 06       	cpc	r9, r19
    69b8:	09 f0       	breq	.+2      	; 0x69bc <MB_M_Timer_ISR+0x500>
    69ba:	56 ce       	rjmp	.-852    	; 0x6668 <MB_M_Timer_ISR+0x1ac>
		return 1;
	uint16_t *Reg = LastProcSingle ?
		MB_SingleQuery[MB_N].Buf
	:
		(uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg))+prw(&Query->AllocAddr);
    69bc:	80 91 e0 04 	lds	r24, 0x04E0
    69c0:	88 23       	and	r24, r24
    69c2:	09 f4       	brne	.+2      	; 0x69c6 <MB_M_Timer_ISR+0x50a>
    69c4:	5e c0       	rjmp	.+188    	; 0x6a82 <MB_M_Timer_ISR+0x5c6>
    69c6:	fe 01       	movw	r30, r28
    69c8:	ee 0f       	add	r30, r30
    69ca:	ff 1f       	adc	r31, r31
    69cc:	ee 0f       	add	r30, r30
    69ce:	ff 1f       	adc	r31, r31
    69d0:	ee 0f       	add	r30, r30
    69d2:	ff 1f       	adc	r31, r31
    69d4:	e8 52       	subi	r30, 0x28	; 40
    69d6:	fb 4f       	sbci	r31, 0xFB	; 251
    69d8:	26 81       	ldd	r18, Z+6	; 0x06
    69da:	37 81       	ldd	r19, Z+7	; 0x07
	for (int8_t j=MB_Frame[MB_N][2]/2-1; j>=0; j--) {
    69dc:	4b 2f       	mov	r20, r27
    69de:	46 95       	lsr	r20
    69e0:	41 50       	subi	r20, 0x01	; 1
    69e2:	47 fd       	sbrc	r20, 7
    69e4:	97 ce       	rjmp	.-722    	; 0x6714 <MB_M_Timer_ISR+0x258>
    69e6:	84 2f       	mov	r24, r20
    69e8:	99 27       	eor	r25, r25
    69ea:	87 fd       	sbrc	r24, 7
    69ec:	90 95       	com	r25
    69ee:	88 0f       	add	r24, r24
    69f0:	99 1f       	adc	r25, r25
    69f2:	58 2f       	mov	r21, r24
    69f4:	5d 5f       	subi	r21, 0xFD	; 253
    69f6:	28 0f       	add	r18, r24
    69f8:	39 1f       	adc	r19, r25
		int8_t i = j*2;
		Reg[j] = MB_FrameReg(MB_N, 3+i);
    69fa:	83 e2       	ldi	r24, 0x23	; 35
    69fc:	88 2e       	mov	r8, r24
    69fe:	8b e0       	ldi	r24, 0x0B	; 11
    6a00:	98 2e       	mov	r9, r24
    6a02:	8c 0c       	add	r8, r12
    6a04:	9d 1c       	adc	r9, r13
    6a06:	e5 2f       	mov	r30, r21
    6a08:	f0 e0       	ldi	r31, 0x00	; 0
    6a0a:	d4 01       	movw	r26, r8
    6a0c:	ae 0f       	add	r26, r30
    6a0e:	bf 1f       	adc	r27, r31
    6a10:	11 96       	adiw	r26, 0x01	; 1
    6a12:	8c 91       	ld	r24, X
    6a14:	90 e0       	ldi	r25, 0x00	; 0
    6a16:	ec 0d       	add	r30, r12
    6a18:	fd 1d       	adc	r31, r13
    6a1a:	ed 5d       	subi	r30, 0xDD	; 221
    6a1c:	f4 4f       	sbci	r31, 0xF4	; 244
    6a1e:	f0 81       	ld	r31, Z
    6a20:	e0 e0       	ldi	r30, 0x00	; 0
    6a22:	8e 2b       	or	r24, r30
    6a24:	9f 2b       	or	r25, r31
    6a26:	d9 01       	movw	r26, r18
    6a28:	8d 93       	st	X+, r24
    6a2a:	9c 93       	st	X, r25
		return 1;
	uint16_t *Reg = LastProcSingle ?
		MB_SingleQuery[MB_N].Buf
	:
		(uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg))+prw(&Query->AllocAddr);
	for (int8_t j=MB_Frame[MB_N][2]/2-1; j>=0; j--) {
    6a2c:	41 50       	subi	r20, 0x01	; 1
    6a2e:	52 50       	subi	r21, 0x02	; 2
    6a30:	22 50       	subi	r18, 0x02	; 2
    6a32:	30 40       	sbci	r19, 0x00	; 0
    6a34:	47 ff       	sbrs	r20, 7
    6a36:	e7 cf       	rjmp	.-50     	; 0x6a06 <MB_M_Timer_ISR+0x54a>
    6a38:	6d ce       	rjmp	.-806    	; 0x6714 <MB_M_Timer_ISR+0x258>
			else if (LastProcSingle)
				MB_SingleState[MB_N] = MB_SingleIdle;
			else {
				SlaveOff[MB_N] &=~((uint32_t)1<<CurrSlave[MB_N]);
				if (++CurrQuery[MB_N]==prb(&Slave->QueryQt))
					Over = NextSlave(MB_N);
    6a3a:	81 2f       	mov	r24, r17
    6a3c:	0e 94 15 31 	call	0x622a	; 0x622a <NextSlave>
    6a40:	98 2f       	mov	r25, r24
    6a42:	a7 ce       	rjmp	.-690    	; 0x6792 <MB_M_Timer_ISR+0x2d6>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    6a44:	ca 01       	movw	r24, r20
    6a46:	03 96       	adiw	r24, 0x03	; 3
    6a48:	fc 01       	movw	r30, r24
    6a4a:	25 91       	lpm	r18, Z+
    6a4c:	34 91       	lpm	r19, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_M_ReadReg(uint8_t MB_N, MB_Query *Query)
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || (LastProcSingle?MB_SingleQuery[MB_N].Qt:prw(&Query->Qt))*2!=MB_Frame[MB_N][2])
    6a4e:	22 0f       	add	r18, r18
    6a50:	33 1f       	adc	r19, r19
    6a52:	b0 cf       	rjmp	.-160    	; 0x69b4 <MB_M_Timer_ISR+0x4f8>
	if (LastProcSingle) {
		Discr = MB_SingleQuery[MB_N].Buf;
		Pin = 0;
	}
	else {
		Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
    6a54:	a1 30       	cpi	r26, 0x01	; 1
    6a56:	59 f1       	breq	.+86     	; 0x6aae <MB_M_Timer_ISR+0x5f2>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6a58:	f7 01       	movw	r30, r14
    6a5a:	ee 0f       	add	r30, r30
    6a5c:	ff 1f       	adc	r31, r31
    6a5e:	ee 0f       	add	r30, r30
    6a60:	ff 1f       	adc	r31, r31
    6a62:	ec 5c       	subi	r30, 0xCC	; 204
    6a64:	fc 4f       	sbci	r31, 0xFC	; 252
    6a66:	85 91       	lpm	r24, Z+
    6a68:	94 91       	lpm	r25, Z+
    6a6a:	e8 2f       	mov	r30, r24
    6a6c:	89 2f       	mov	r24, r25
    6a6e:	2e 2f       	mov	r18, r30
    6a70:	38 2f       	mov	r19, r24
    6a72:	c9 01       	movw	r24, r18
    6a74:	4c 01       	movw	r8, r24

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    6a76:	fa 01       	movw	r30, r20
    6a78:	35 96       	adiw	r30, 0x05	; 5
    6a7a:	85 91       	lpm	r24, Z+
    6a7c:	94 91       	lpm	r25, Z+
		Pin = prw(&Query->AllocAddr);
    6a7e:	08 2f       	mov	r16, r24
    6a80:	d8 ce       	rjmp	.-592    	; 0x6832 <MB_M_Timer_ISR+0x376>
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || (LastProcSingle?MB_SingleQuery[MB_N].Qt:prw(&Query->Qt))*2!=MB_Frame[MB_N][2])
		return 1;
	uint16_t *Reg = LastProcSingle ?
		MB_SingleQuery[MB_N].Buf
	:
		(uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg))+prw(&Query->AllocAddr);
    6a82:	a3 30       	cpi	r26, 0x03	; 3
    6a84:	11 f1       	breq	.+68     	; 0x6aca <MB_M_Timer_ISR+0x60e>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6a86:	fe 01       	movw	r30, r28
    6a88:	e2 95       	swap	r30
    6a8a:	f2 95       	swap	r31
    6a8c:	f0 7f       	andi	r31, 0xF0	; 240
    6a8e:	fe 27       	eor	r31, r30
    6a90:	e0 7f       	andi	r30, 0xF0	; 240
    6a92:	fe 27       	eor	r31, r30
    6a94:	e4 5c       	subi	r30, 0xC4	; 196
    6a96:	fc 4f       	sbci	r31, 0xFC	; 252
    6a98:	85 91       	lpm	r24, Z+
    6a9a:	94 91       	lpm	r25, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    6a9c:	fa 01       	movw	r30, r20
    6a9e:	35 96       	adiw	r30, 0x05	; 5
    6aa0:	25 91       	lpm	r18, Z+
    6aa2:	34 91       	lpm	r19, Z+
    6aa4:	22 0f       	add	r18, r18
    6aa6:	33 1f       	adc	r19, r19
    6aa8:	28 0f       	add	r18, r24
    6aaa:	39 1f       	adc	r19, r25
    6aac:	97 cf       	rjmp	.-210    	; 0x69dc <MB_M_Timer_ISR+0x520>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6aae:	fe 01       	movw	r30, r28
    6ab0:	e2 95       	swap	r30
    6ab2:	f2 95       	swap	r31
    6ab4:	f0 7f       	andi	r31, 0xF0	; 240
    6ab6:	fe 27       	eor	r31, r30
    6ab8:	e0 7f       	andi	r30, 0xF0	; 240
    6aba:	fe 27       	eor	r31, r30
    6abc:	e0 5d       	subi	r30, 0xD0	; 208
    6abe:	fc 4f       	sbci	r31, 0xFC	; 252
    6ac0:	85 91       	lpm	r24, Z+
    6ac2:	94 91       	lpm	r25, Z+
    6ac4:	e8 2f       	mov	r30, r24
    6ac6:	89 2f       	mov	r24, r25
    6ac8:	d2 cf       	rjmp	.-92     	; 0x6a6e <MB_M_Timer_ISR+0x5b2>

// ~~~~~~~~~~~~~~~~~~
void
MB_M_Tx(uint8_t MB_N)
{
	StartTimer16(TD_MB_Idle+MB_N, MB_M_Timeout[MB_N]);
    6aca:	fe 01       	movw	r30, r28
    6acc:	ee 0f       	add	r30, r30
    6ace:	ff 1f       	adc	r31, r31
    6ad0:	ee 0f       	add	r30, r30
    6ad2:	ff 1f       	adc	r31, r31
    6ad4:	ee 0f       	add	r30, r30
    6ad6:	ff 1f       	adc	r31, r31
    6ad8:	ee 0f       	add	r30, r30
    6ada:	ff 1f       	adc	r31, r31
    6adc:	e8 5c       	subi	r30, 0xC8	; 200
    6ade:	fc 4f       	sbci	r31, 0xFC	; 252
    6ae0:	85 91       	lpm	r24, Z+
    6ae2:	94 91       	lpm	r25, Z+
    6ae4:	db cf       	rjmp	.-74     	; 0x6a9c <MB_M_Timer_ISR+0x5e0>

00006ae6 <MB_M_Tx>:
    6ae6:	90 91 e6 04 	lds	r25, 0x04E6
    6aea:	e1 ee       	ldi	r30, 0xE1	; 225
    6aec:	f8 e0       	ldi	r31, 0x08	; 8
    6aee:	e8 0f       	add	r30, r24
    6af0:	f1 1d       	adc	r31, r1
    6af2:	60 81       	ld	r22, Z
    6af4:	89 0f       	add	r24, r25
    6af6:	70 e0       	ldi	r23, 0x00	; 0
    6af8:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
}
    6afc:	08 95       	ret

00006afe <Modbus_TX>:
}

// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_TX(usart_t *usart)
{
    6afe:	cf 92       	push	r12
    6b00:	df 92       	push	r13
    6b02:	ef 92       	push	r14
    6b04:	ff 92       	push	r15
    6b06:	1f 93       	push	r17
    6b08:	cf 93       	push	r28
    6b0a:	df 93       	push	r29
    6b0c:	dc 01       	movw	r26, r24
    6b0e:	eb e6       	ldi	r30, 0x6B	; 107
    6b10:	fd e2       	ldi	r31, 0x2D	; 45
    6b12:	85 91       	lpm	r24, Z+
    6b14:	94 91       	lpm	r25, Z+
// ~~~~~~~~~~~~~~~~~~~~~~
static uint8_t
MB_Port_N(usart_t *usart)
{
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Port[MB_N].usart_field)!=usart; MB_N++);
    6b16:	a8 17       	cp	r26, r24
    6b18:	b9 07       	cpc	r27, r25
    6b1a:	09 f4       	brne	.+2      	; 0x6b1e <Modbus_TX+0x20>
    6b1c:	c0 c0       	rjmp	.+384    	; 0x6c9e <Modbus_TX+0x1a0>
    6b1e:	10 e0       	ldi	r17, 0x00	; 0
    6b20:	1f 5f       	subi	r17, 0xFF	; 255
    6b22:	c1 2f       	mov	r28, r17
    6b24:	d0 e0       	ldi	r29, 0x00	; 0
    6b26:	ce 01       	movw	r24, r28
    6b28:	88 0f       	add	r24, r24
    6b2a:	99 1f       	adc	r25, r25
    6b2c:	88 0f       	add	r24, r24
    6b2e:	99 1f       	adc	r25, r25
    6b30:	fc 01       	movw	r30, r24
    6b32:	ee 0f       	add	r30, r30
    6b34:	ff 1f       	adc	r31, r31
    6b36:	ee 0f       	add	r30, r30
    6b38:	ff 1f       	adc	r31, r31
    6b3a:	e8 0f       	add	r30, r24
    6b3c:	f9 1f       	adc	r31, r25
    6b3e:	e5 59       	subi	r30, 0x95	; 149
    6b40:	f2 4d       	sbci	r31, 0xD2	; 210
    6b42:	85 91       	lpm	r24, Z+
    6b44:	94 91       	lpm	r25, Z+
    6b46:	a8 17       	cp	r26, r24
    6b48:	b9 07       	cpc	r27, r25
    6b4a:	51 f7       	brne	.-44     	; 0x6b20 <Modbus_TX+0x22>
void
Modbus_TX(usart_t *usart)
{
	uint8_t MB_N = MB_Port_N(usart);
	static uint8_t Count[Modbus_Qt];
	if (Count[MB_N] == MB_Frame_Sz[MB_N]-2){
    6b4c:	24 ee       	ldi	r18, 0xE4	; 228
    6b4e:	c2 2e       	mov	r12, r18
    6b50:	22 e0       	ldi	r18, 0x02	; 2
    6b52:	d2 2e       	mov	r13, r18
    6b54:	cc 0e       	add	r12, r28
    6b56:	dd 1e       	adc	r13, r29
    6b58:	f6 01       	movw	r30, r12
    6b5a:	50 81       	ld	r21, Z
    6b5c:	be 01       	movw	r22, r28
    6b5e:	6b 5f       	subi	r22, 0xFB	; 251
    6b60:	78 4f       	sbci	r23, 0xF8	; 248
    6b62:	fb 01       	movw	r30, r22
    6b64:	40 81       	ld	r20, Z
    6b66:	25 2f       	mov	r18, r21
    6b68:	30 e0       	ldi	r19, 0x00	; 0
    6b6a:	84 2f       	mov	r24, r20
    6b6c:	90 e0       	ldi	r25, 0x00	; 0
    6b6e:	02 97       	sbiw	r24, 0x02	; 2
    6b70:	28 17       	cp	r18, r24
    6b72:	39 07       	cpc	r19, r25
    6b74:	09 f4       	brne	.+2      	; 0x6b78 <Modbus_TX+0x7a>
    6b76:	55 c0       	rjmp	.+170    	; 0x6c22 <Modbus_TX+0x124>
		USART_Reg(MB_N, ucsrb) &=~(1<<5);
		USART_Reg(MB_N, ucsrb) |=(1<<6);
		USART_Reg(MB_N, ucsra) |=(1<<6);	//Clear TxC pending interrupt		
	}
	if (++Count[MB_N]<MB_Frame_Sz[MB_N]) {
    6b78:	25 2f       	mov	r18, r21
    6b7a:	2f 5f       	subi	r18, 0xFF	; 255
    6b7c:	f6 01       	movw	r30, r12
    6b7e:	20 83       	st	Z, r18
    6b80:	24 17       	cp	r18, r20
    6b82:	80 f4       	brcc	.+32     	; 0x6ba4 <Modbus_TX+0xa6>
		usart_data(usart) = MB_Frame[MB_N][Count[MB_N]];
    6b84:	fc 2f       	mov	r31, r28
    6b86:	ee 27       	eor	r30, r30
    6b88:	e2 0f       	add	r30, r18
    6b8a:	f1 1d       	adc	r31, r1
    6b8c:	ed 5d       	subi	r30, 0xDD	; 221
    6b8e:	f4 4f       	sbci	r31, 0xF4	; 244
    6b90:	80 81       	ld	r24, Z
    6b92:	8c 93       	st	X, r24
		break;
	case Role_Master:
		MB_M_Tx(MB_N);
		break;
	}
}
    6b94:	df 91       	pop	r29
    6b96:	cf 91       	pop	r28
    6b98:	1f 91       	pop	r17
    6b9a:	ff 90       	pop	r15
    6b9c:	ef 90       	pop	r14
    6b9e:	df 90       	pop	r13
    6ba0:	cf 90       	pop	r12
    6ba2:	08 95       	ret
    6ba4:	9e 01       	movw	r18, r28
    6ba6:	22 0f       	add	r18, r18
    6ba8:	33 1f       	adc	r19, r19
    6baa:	22 0f       	add	r18, r18
    6bac:	33 1f       	adc	r19, r19
    6bae:	c9 01       	movw	r24, r18
    6bb0:	8c 0f       	add	r24, r28
    6bb2:	9d 1f       	adc	r25, r29
    6bb4:	88 0f       	add	r24, r24
    6bb6:	99 1f       	adc	r25, r25
    6bb8:	88 0f       	add	r24, r24
    6bba:	99 1f       	adc	r25, r25
    6bbc:	81 59       	subi	r24, 0x91	; 145
    6bbe:	92 4d       	sbci	r25, 0xD2	; 210
    6bc0:	fc 01       	movw	r30, r24
    6bc2:	a5 91       	lpm	r26, Z+
    6bc4:	b4 91       	lpm	r27, Z+
	}

	void MB_S_Tx(uint8_t);
	void MB_M_Tx(uint8_t);
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		USART_Reg(MB_N, ucsrb) &=~((1<<6)|(1<<5)); 	// .  USART Data Register Empty Interrupt
    6bc6:	8c 91       	ld	r24, X
    6bc8:	8f 79       	andi	r24, 0x9F	; 159
    6bca:	8c 93       	st	X, r24
    6bcc:	79 01       	movw	r14, r18
    6bce:	ee 0c       	add	r14, r14
    6bd0:	ff 1c       	adc	r15, r15
    6bd2:	ee 0c       	add	r14, r14
    6bd4:	ff 1c       	adc	r15, r15
    6bd6:	e2 0e       	add	r14, r18
    6bd8:	f3 1e       	adc	r15, r19
    6bda:	c7 01       	movw	r24, r14
    6bdc:	89 58       	subi	r24, 0x89	; 137
    6bde:	92 4d       	sbci	r25, 0xD2	; 210
    6be0:	fc 01       	movw	r30, r24
    6be2:	25 91       	lpm	r18, Z+
    6be4:	34 91       	lpm	r19, Z+
	#elif defined (__AVR_ATxmega128A1__)
		usart->CTRLA = (usart->CTRLA &~USART_TXCINTLVL_gm) |USART_TXCINTLVL_OFF_gc;
	#endif
	USART_Func(MB_N, RS485);
    6be6:	f9 01       	movw	r30, r18
    6be8:	19 95       	eicall
	Count[MB_N] = 0;
    6bea:	f6 01       	movw	r30, r12
    6bec:	10 82       	st	Z, r1
	//StartTime3_5();
	MB_State[MB_N] = MB_Idle;
    6bee:	c0 54       	subi	r28, 0x40	; 64
    6bf0:	da 4f       	sbci	r29, 0xFA	; 250
    6bf2:	81 e0       	ldi	r24, 0x01	; 1
    6bf4:	88 83       	st	Y, r24

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    6bf6:	e1 2f       	mov	r30, r17
    6bf8:	f0 e0       	ldi	r31, 0x00	; 0
    6bfa:	e1 58       	subi	r30, 0x81	; 129
    6bfc:	f2 4d       	sbci	r31, 0xD2	; 210
    6bfe:	84 91       	lpm	r24, Z+
	switch (prb(MB_Role+MB_N)) {
    6c00:	88 23       	and	r24, r24
    6c02:	09 f4       	brne	.+2      	; 0x6c06 <Modbus_TX+0x108>
    6c04:	3c c0       	rjmp	.+120    	; 0x6c7e <Modbus_TX+0x180>
    6c06:	81 30       	cpi	r24, 0x01	; 1
    6c08:	09 f0       	breq	.+2      	; 0x6c0c <Modbus_TX+0x10e>
    6c0a:	c4 cf       	rjmp	.-120    	; 0x6b94 <Modbus_TX+0x96>
	case Role_Slave:
		MB_S_Tx(MB_N);
		break;
	case Role_Master:
		MB_M_Tx(MB_N);
    6c0c:	81 2f       	mov	r24, r17
    6c0e:	0e 94 73 35 	call	0x6ae6	; 0x6ae6 <MB_M_Tx>
		break;
	}
}
    6c12:	df 91       	pop	r29
    6c14:	cf 91       	pop	r28
    6c16:	1f 91       	pop	r17
    6c18:	ff 90       	pop	r15
    6c1a:	ef 90       	pop	r14
    6c1c:	df 90       	pop	r13
    6c1e:	cf 90       	pop	r12
    6c20:	08 95       	ret

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6c22:	fe 01       	movw	r30, r28
    6c24:	ee 0f       	add	r30, r30
    6c26:	ff 1f       	adc	r31, r31
    6c28:	ee 0f       	add	r30, r30
    6c2a:	ff 1f       	adc	r31, r31
    6c2c:	ec 0f       	add	r30, r28
    6c2e:	fd 1f       	adc	r31, r29
    6c30:	ee 0f       	add	r30, r30
    6c32:	ff 1f       	adc	r31, r31
    6c34:	ee 0f       	add	r30, r30
    6c36:	ff 1f       	adc	r31, r31
    6c38:	e1 59       	subi	r30, 0x91	; 145
    6c3a:	f2 4d       	sbci	r31, 0xD2	; 210
    6c3c:	25 91       	lpm	r18, Z+
    6c3e:	34 91       	lpm	r19, Z+
Modbus_TX(usart_t *usart)
{
	uint8_t MB_N = MB_Port_N(usart);
	static uint8_t Count[Modbus_Qt];
	if (Count[MB_N] == MB_Frame_Sz[MB_N]-2){
		USART_Reg(MB_N, ucsrb) &=~(1<<5);
    6c40:	f9 01       	movw	r30, r18
    6c42:	80 81       	ld	r24, Z
    6c44:	8f 7d       	andi	r24, 0xDF	; 223
		USART_Reg(MB_N, ucsrb) |=(1<<6);
    6c46:	80 64       	ori	r24, 0x40	; 64
    6c48:	80 83       	st	Z, r24
    6c4a:	9e 01       	movw	r18, r28
    6c4c:	22 0f       	add	r18, r18
    6c4e:	33 1f       	adc	r19, r19
    6c50:	ce 01       	movw	r24, r28
    6c52:	88 0f       	add	r24, r24
    6c54:	99 1f       	adc	r25, r25
    6c56:	88 0f       	add	r24, r24
    6c58:	99 1f       	adc	r25, r25
    6c5a:	88 0f       	add	r24, r24
    6c5c:	99 1f       	adc	r25, r25
    6c5e:	28 0f       	add	r18, r24
    6c60:	39 1f       	adc	r19, r25
    6c62:	22 0f       	add	r18, r18
    6c64:	33 1f       	adc	r19, r19
    6c66:	23 59       	subi	r18, 0x93	; 147
    6c68:	32 4d       	sbci	r19, 0xD2	; 210
    6c6a:	f9 01       	movw	r30, r18
    6c6c:	e5 90       	lpm	r14, Z+
    6c6e:	f4 90       	lpm	r15, Z+
		USART_Reg(MB_N, ucsra) |=(1<<6);	//Clear TxC pending interrupt		
    6c70:	f7 01       	movw	r30, r14
    6c72:	80 81       	ld	r24, Z
    6c74:	80 64       	ori	r24, 0x40	; 64
    6c76:	80 83       	st	Z, r24
    6c78:	fb 01       	movw	r30, r22
    6c7a:	40 81       	ld	r20, Z
    6c7c:	7d cf       	rjmp	.-262    	; 0x6b78 <Modbus_TX+0x7a>
    6c7e:	c7 01       	movw	r24, r14
    6c80:	87 58       	subi	r24, 0x87	; 135
    6c82:	92 4d       	sbci	r25, 0xD2	; 210
    6c84:	fc 01       	movw	r30, r24
    6c86:	25 91       	lpm	r18, Z+
    6c88:	34 91       	lpm	r19, Z+

// ~~~~~~~~~~~~~~~~~~
void
MB_S_Tx(uint8_t MB_N)
{
	USART_Func(MB_N, LED);
    6c8a:	f9 01       	movw	r30, r18
    6c8c:	19 95       	eicall
		break;
	case Role_Master:
		MB_M_Tx(MB_N);
		break;
	}
}
    6c8e:	df 91       	pop	r29
    6c90:	cf 91       	pop	r28
    6c92:	1f 91       	pop	r17
    6c94:	ff 90       	pop	r15
    6c96:	ef 90       	pop	r14
    6c98:	df 90       	pop	r13
    6c9a:	cf 90       	pop	r12
    6c9c:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~
static uint8_t
MB_Port_N(usart_t *usart)
{
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Port[MB_N].usart_field)!=usart; MB_N++);
    6c9e:	10 e0       	ldi	r17, 0x00	; 0
    6ca0:	c0 e0       	ldi	r28, 0x00	; 0
    6ca2:	d0 e0       	ldi	r29, 0x00	; 0
    6ca4:	53 cf       	rjmp	.-346    	; 0x6b4c <Modbus_TX+0x4e>

00006ca6 <MB_SingleRun>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_SingleRun(uint8_t MB_N, uint8_t Addr, uint8_t Func, uint16_t StartAddr, uint16_t Qt, void *Buf)
{
    6ca6:	df 92       	push	r13
    6ca8:	ef 92       	push	r14
    6caa:	ff 92       	push	r15
    6cac:	0f 93       	push	r16
    6cae:	1f 93       	push	r17
    6cb0:	cf 93       	push	r28
    6cb2:	df 93       	push	r29
    6cb4:	d8 2e       	mov	r13, r24
    6cb6:	94 2f       	mov	r25, r20
    6cb8:	a9 01       	movw	r20, r18
	if (MB_SingleState[MB_N]!=MB_SingleIdle)
    6cba:	c8 2f       	mov	r28, r24
    6cbc:	d0 e0       	ldi	r29, 0x00	; 0
    6cbe:	9e 01       	movw	r18, r28
    6cc0:	23 55       	subi	r18, 0x53	; 83
    6cc2:	39 4f       	sbci	r19, 0xF9	; 249
    6cc4:	f9 01       	movw	r30, r18
    6cc6:	80 81       	ld	r24, Z
    6cc8:	88 23       	and	r24, r24
    6cca:	91 f5       	brne	.+100    	; 0x6d30 <MB_SingleRun+0x8a>
		return;

	MB_SingleQuery[MB_N].Addr				= Addr;
    6ccc:	de 01       	movw	r26, r28
    6cce:	aa 0f       	add	r26, r26
    6cd0:	bb 1f       	adc	r27, r27
    6cd2:	aa 0f       	add	r26, r26
    6cd4:	bb 1f       	adc	r27, r27
    6cd6:	aa 0f       	add	r26, r26
    6cd8:	bb 1f       	adc	r27, r27
    6cda:	a8 52       	subi	r26, 0x28	; 40
    6cdc:	bb 4f       	sbci	r27, 0xFB	; 251
    6cde:	6c 93       	st	X, r22
	MB_SingleQuery[MB_N].Func				= Func;
    6ce0:	11 96       	adiw	r26, 0x01	; 1
    6ce2:	9c 93       	st	X, r25
    6ce4:	11 97       	sbiw	r26, 0x01	; 1
	MB_SingleQuery[MB_N].StartAddr	= StartAddr;
    6ce6:	be 01       	movw	r22, r28
    6ce8:	66 0f       	add	r22, r22
    6cea:	77 1f       	adc	r23, r23
    6cec:	66 0f       	add	r22, r22
    6cee:	77 1f       	adc	r23, r23
    6cf0:	fb 01       	movw	r30, r22
    6cf2:	ee 0f       	add	r30, r30
    6cf4:	ff 1f       	adc	r31, r31
    6cf6:	e6 52       	subi	r30, 0x26	; 38
    6cf8:	fb 4f       	sbci	r31, 0xFB	; 251
    6cfa:	51 83       	std	Z+1, r21	; 0x01
    6cfc:	40 83       	st	Z, r20
	MB_SingleQuery[MB_N].Qt					= Qt;
    6cfe:	ae 01       	movw	r20, r28
    6d00:	44 0f       	add	r20, r20
    6d02:	55 1f       	adc	r21, r21
    6d04:	fa 01       	movw	r30, r20
    6d06:	ee 0f       	add	r30, r30
    6d08:	ff 1f       	adc	r31, r31
    6d0a:	ee 0f       	add	r30, r30
    6d0c:	ff 1f       	adc	r31, r31
    6d0e:	e4 52       	subi	r30, 0x24	; 36
    6d10:	fb 4f       	sbci	r31, 0xFB	; 251
    6d12:	11 83       	std	Z+1, r17	; 0x01
    6d14:	00 83       	st	Z, r16
	MB_SingleQuery[MB_N].Buf				= Buf;
    6d16:	17 96       	adiw	r26, 0x07	; 7
    6d18:	fc 92       	st	X, r15
    6d1a:	ee 92       	st	-X, r14
    6d1c:	16 97       	sbiw	r26, 0x06	; 6

	MB_SingleState[MB_N] = MB_SingleStart;
    6d1e:	81 e0       	ldi	r24, 0x01	; 1
    6d20:	f9 01       	movw	r30, r18
    6d22:	80 83       	st	Z, r24
	if (MB_State[MB_N]==MB_Proc && !LastProcSingle) {
    6d24:	fe 01       	movw	r30, r28
    6d26:	e0 54       	subi	r30, 0x40	; 64
    6d28:	fa 4f       	sbci	r31, 0xFA	; 250
    6d2a:	80 81       	ld	r24, Z
    6d2c:	84 30       	cpi	r24, 0x04	; 4
    6d2e:	41 f0       	breq	.+16     	; 0x6d40 <MB_SingleRun+0x9a>
			IntOff();
			MB_Transm(MB_N);
			IntOn();
		}
	}
}
    6d30:	df 91       	pop	r29
    6d32:	cf 91       	pop	r28
    6d34:	1f 91       	pop	r17
    6d36:	0f 91       	pop	r16
    6d38:	ff 90       	pop	r15
    6d3a:	ef 90       	pop	r14
    6d3c:	df 90       	pop	r13
    6d3e:	08 95       	ret
	MB_SingleQuery[MB_N].StartAddr	= StartAddr;
	MB_SingleQuery[MB_N].Qt					= Qt;
	MB_SingleQuery[MB_N].Buf				= Buf;

	MB_SingleState[MB_N] = MB_SingleStart;
	if (MB_State[MB_N]==MB_Proc && !LastProcSingle) {
    6d40:	80 91 e0 04 	lds	r24, 0x04E0
    6d44:	88 23       	and	r24, r24
    6d46:	a1 f7       	brne	.-24     	; 0x6d30 <MB_SingleRun+0x8a>
		uint16_t T = (CurrSlave[MB_N]==0 ? MB_M_Period[MB_N] : MB_M_Timeout[MB_N]) - GetTimer16(TD_MB_Idle+MB_N);
    6d48:	fe 01       	movw	r30, r28
    6d4a:	ee 5a       	subi	r30, 0xAE	; 174
    6d4c:	f9 4f       	sbci	r31, 0xF9	; 249
    6d4e:	80 81       	ld	r24, Z
    6d50:	88 23       	and	r24, r24
    6d52:	09 f0       	breq	.+2      	; 0x6d56 <MB_SingleRun+0xb0>
    6d54:	4d c0       	rjmp	.+154    	; 0x6df0 <MB_SingleRun+0x14a>
    6d56:	45 55       	subi	r20, 0x55	; 85
    6d58:	59 4f       	sbci	r21, 0xF9	; 249
    6d5a:	fa 01       	movw	r30, r20
    6d5c:	40 81       	ld	r20, Z
    6d5e:	51 81       	ldd	r21, Z+1	; 0x01
    6d60:	20 91 e6 04 	lds	r18, 0x04E6
    6d64:	2d 0d       	add	r18, r13

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    6d66:	8f b7       	in	r24, 0x3f	; 63
    6d68:	80 78       	andi	r24, 0x80	; 128
    6d6a:	80 93 ec 02 	sts	0x02EC, r24
	cli();
    6d6e:	f8 94       	cli
    6d70:	e2 2f       	mov	r30, r18
    6d72:	f0 e0       	ldi	r31, 0x00	; 0
    6d74:	ee 0f       	add	r30, r30
    6d76:	ff 1f       	adc	r31, r31
    6d78:	e3 5b       	subi	r30, 0xB3	; 179
    6d7a:	fc 4f       	sbci	r31, 0xFC	; 252
    6d7c:	a0 81       	ld	r26, Z
    6d7e:	b1 81       	ldd	r27, Z+1	; 0x01

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    6d80:	88 23       	and	r24, r24
    6d82:	09 f0       	breq	.+2      	; 0x6d86 <MB_SingleRun+0xe0>
		sei();
    6d84:	78 94       	sei
    6d86:	ca 01       	movw	r24, r20
    6d88:	8a 1b       	sub	r24, r26
    6d8a:	9b 0b       	sbc	r25, r27
		if (T<MB_M_Pause_Min)
    6d8c:	85 30       	cpi	r24, 0x05	; 5
    6d8e:	91 05       	cpc	r25, r1
    6d90:	a8 f1       	brcs	.+106    	; 0x6dfc <MB_SingleRun+0x156>

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    6d92:	8f b7       	in	r24, 0x3f	; 63
    6d94:	80 78       	andi	r24, 0x80	; 128
    6d96:	80 93 ec 02 	sts	0x02EC, r24
	cli();
    6d9a:	f8 94       	cli
    6d9c:	cb 01       	movw	r24, r22
    6d9e:	88 0f       	add	r24, r24
    6da0:	99 1f       	adc	r25, r25
    6da2:	88 0f       	add	r24, r24
    6da4:	99 1f       	adc	r25, r25
    6da6:	86 0f       	add	r24, r22
    6da8:	97 1f       	adc	r25, r23
    6daa:	87 58       	subi	r24, 0x87	; 135
    6dac:	92 4d       	sbci	r25, 0xD2	; 210
    6dae:	fc 01       	movw	r30, r24
    6db0:	25 91       	lpm	r18, Z+
    6db2:	34 91       	lpm	r19, Z+
			StartTimer16(TD_MB_Idle+MB_N, MB_M_Pause_Min-T);
		else {
			IntOff();
			USART_Func(MB_N, LED);
    6db4:	f9 01       	movw	r30, r18
    6db6:	19 95       	eicall

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    6db8:	80 91 ec 02 	lds	r24, 0x02EC
    6dbc:	88 23       	and	r24, r24
    6dbe:	09 f0       	breq	.+2      	; 0x6dc2 <MB_SingleRun+0x11c>
		sei();
    6dc0:	78 94       	sei
			IntOn();
			ResetTimer16(TD_MB_Idle+MB_N);
    6dc2:	80 91 e6 04 	lds	r24, 0x04E6
    6dc6:	8d 0d       	add	r24, r13
    6dc8:	0e 94 b0 1c 	call	0x3960	; 0x3960 <ResetTimer16>
			FormSingle(MB_N);
    6dcc:	8d 2d       	mov	r24, r13
    6dce:	0e 94 d3 30 	call	0x61a6	; 0x61a6 <FormSingle>

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    6dd2:	8f b7       	in	r24, 0x3f	; 63
    6dd4:	80 78       	andi	r24, 0x80	; 128
    6dd6:	80 93 ec 02 	sts	0x02EC, r24
	cli();
    6dda:	f8 94       	cli
			IntOff();
			MB_Transm(MB_N);
    6ddc:	8d 2d       	mov	r24, r13
    6dde:	0e 94 79 29 	call	0x52f2	; 0x52f2 <MB_Transm>

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    6de2:	80 91 ec 02 	lds	r24, 0x02EC
    6de6:	88 23       	and	r24, r24
    6de8:	09 f4       	brne	.+2      	; 0x6dec <MB_SingleRun+0x146>
    6dea:	a2 cf       	rjmp	.-188    	; 0x6d30 <MB_SingleRun+0x8a>
		sei();
    6dec:	78 94       	sei
    6dee:	a0 cf       	rjmp	.-192    	; 0x6d30 <MB_SingleRun+0x8a>
	MB_SingleQuery[MB_N].Qt					= Qt;
	MB_SingleQuery[MB_N].Buf				= Buf;

	MB_SingleState[MB_N] = MB_SingleStart;
	if (MB_State[MB_N]==MB_Proc && !LastProcSingle) {
		uint16_t T = (CurrSlave[MB_N]==0 ? MB_M_Period[MB_N] : MB_M_Timeout[MB_N]) - GetTimer16(TD_MB_Idle+MB_N);
    6df0:	cf 51       	subi	r28, 0x1F	; 31
    6df2:	d7 4f       	sbci	r29, 0xF7	; 247
    6df4:	88 81       	ld	r24, Y
    6df6:	48 2f       	mov	r20, r24
    6df8:	50 e0       	ldi	r21, 0x00	; 0
    6dfa:	b2 cf       	rjmp	.-156    	; 0x6d60 <MB_SingleRun+0xba>
		if (T<MB_M_Pause_Min)
			StartTimer16(TD_MB_Idle+MB_N, MB_M_Pause_Min-T);
    6dfc:	65 e0       	ldi	r22, 0x05	; 5
    6dfe:	70 e0       	ldi	r23, 0x00	; 0
    6e00:	68 1b       	sub	r22, r24
    6e02:	79 0b       	sbc	r23, r25
    6e04:	82 2f       	mov	r24, r18
    6e06:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
    6e0a:	92 cf       	rjmp	.-220    	; 0x6d30 <MB_SingleRun+0x8a>

00006e0c <MB_Master_MaxCycle_Clear>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_Master_MaxCycle_Clear(uint8_t MB_N)
{
	MB_Master_MaxCycle[MB_N] = 0;
    6e0c:	e8 2f       	mov	r30, r24
    6e0e:	f0 e0       	ldi	r31, 0x00	; 0
    6e10:	ee 0f       	add	r30, r30
    6e12:	ff 1f       	adc	r31, r31
    6e14:	e4 54       	subi	r30, 0x44	; 68
    6e16:	f9 4f       	sbci	r31, 0xF9	; 249
    6e18:	11 82       	std	Z+1, r1	; 0x01
    6e1a:	10 82       	st	Z, r1
}
    6e1c:	08 95       	ret

00006e1e <MB_M_Cycle>:

// ~~~~~~~~~~~~~~~~~~~~~
void
MB_M_Cycle(uint8_t MB_N)
{
    6e1e:	ff 92       	push	r15
    6e20:	0f 93       	push	r16
    6e22:	1f 93       	push	r17
    6e24:	cf 93       	push	r28
    6e26:	df 93       	push	r29
    6e28:	f8 2e       	mov	r15, r24
	if (Timer16Stopp(TD_MB_SlaveOff+MB_N))
    6e2a:	10 91 e6 04 	lds	r17, 0x04E6
    6e2e:	18 0f       	add	r17, r24
    6e30:	01 2f       	mov	r16, r17
    6e32:	0f 5f       	subi	r16, 0xFF	; 255
    6e34:	80 2f       	mov	r24, r16
    6e36:	0e 94 06 1c 	call	0x380c	; 0x380c <Timer16Stopp>
    6e3a:	88 23       	and	r24, r24
    6e3c:	d9 f4       	brne	.+54     	; 0x6e74 <MB_M_Cycle+0x56>
		SlavesOn(MB_N);

	if (Timer16Stopp(TD_MB_Idle+MB_N)){
    6e3e:	81 2f       	mov	r24, r17
    6e40:	0e 94 06 1c 	call	0x380c	; 0x380c <Timer16Stopp>
    6e44:	88 23       	and	r24, r24
    6e46:	81 f0       	breq	.+32     	; 0x6e68 <MB_M_Cycle+0x4a>
		cli();
    6e48:	f8 94       	cli
		if(MB_State[MB_N] == MB_Idle) MB_State[MB_N] = MB_NoReply;
    6e4a:	cf 2d       	mov	r28, r15
    6e4c:	d0 e0       	ldi	r29, 0x00	; 0
    6e4e:	fe 01       	movw	r30, r28
    6e50:	e0 54       	subi	r30, 0x40	; 64
    6e52:	fa 4f       	sbci	r31, 0xFA	; 250
    6e54:	80 81       	ld	r24, Z
    6e56:	81 30       	cpi	r24, 0x01	; 1
    6e58:	29 f1       	breq	.+74     	; 0x6ea4 <MB_M_Cycle+0x86>
		sei();
    6e5a:	78 94       	sei
	}
	else return;
	
	switch (MB_State[MB_N]) {
    6e5c:	80 81       	ld	r24, Z
    6e5e:	84 30       	cpi	r24, 0x04	; 4
    6e60:	39 f1       	breq	.+78     	; 0x6eb0 <MB_M_Cycle+0x92>
    6e62:	85 30       	cpi	r24, 0x05	; 5
    6e64:	09 f4       	brne	.+2      	; 0x6e68 <MB_M_Cycle+0x4a>
    6e66:	52 c0       	rjmp	.+164    	; 0x6f0c <MB_M_Cycle+0xee>
		cli();
		MB_Transm(MB_N);
		sei();
		break;
	}
}
    6e68:	df 91       	pop	r29
    6e6a:	cf 91       	pop	r28
    6e6c:	1f 91       	pop	r17
    6e6e:	0f 91       	pop	r16
    6e70:	ff 90       	pop	r15
    6e72:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~
static void
SlavesOn(uint8_t MB_N)
{
	SlaveSkip[MB_N] = 0;
    6e74:	af 2d       	mov	r26, r15
    6e76:	b0 e0       	ldi	r27, 0x00	; 0
    6e78:	fd 01       	movw	r30, r26
    6e7a:	ee 0f       	add	r30, r30
    6e7c:	ff 1f       	adc	r31, r31
    6e7e:	ee 0f       	add	r30, r30
    6e80:	ff 1f       	adc	r31, r31
    6e82:	ee 51       	subi	r30, 0x1E	; 30
    6e84:	fb 4f       	sbci	r31, 0xFB	; 251
    6e86:	10 82       	st	Z, r1
    6e88:	11 82       	std	Z+1, r1	; 0x01
    6e8a:	12 82       	std	Z+2, r1	; 0x02
    6e8c:	13 82       	std	Z+3, r1	; 0x03
	StartTimer16(TD_MB_SlaveOff+MB_N, 100*MB_M_TimeOff[MB_N]);
    6e8e:	a3 52       	subi	r26, 0x23	; 35
    6e90:	ba 4f       	sbci	r27, 0xFA	; 250
    6e92:	6c 91       	ld	r22, X
    6e94:	84 e6       	ldi	r24, 0x64	; 100
    6e96:	68 9f       	mul	r22, r24
    6e98:	b0 01       	movw	r22, r0
    6e9a:	11 24       	eor	r1, r1
    6e9c:	80 2f       	mov	r24, r16
    6e9e:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
    6ea2:	cd cf       	rjmp	.-102    	; 0x6e3e <MB_M_Cycle+0x20>
	if (Timer16Stopp(TD_MB_SlaveOff+MB_N))
		SlavesOn(MB_N);

	if (Timer16Stopp(TD_MB_Idle+MB_N)){
		cli();
		if(MB_State[MB_N] == MB_Idle) MB_State[MB_N] = MB_NoReply;
    6ea4:	85 e0       	ldi	r24, 0x05	; 5
    6ea6:	80 83       	st	Z, r24
		sei();
    6ea8:	78 94       	sei
	}
	else return;
	
	switch (MB_State[MB_N]) {
    6eaa:	80 81       	ld	r24, Z
    6eac:	84 30       	cpi	r24, 0x04	; 4
    6eae:	c9 f6       	brne	.-78     	; 0x6e62 <MB_M_Cycle+0x44>
		cli();
		MB_Transm(MB_N);
		sei();
		break;
	case MB_Proc:
		cli();
    6eb0:	f8 94       	cli
    6eb2:	ce 01       	movw	r24, r28
    6eb4:	88 0f       	add	r24, r24
    6eb6:	99 1f       	adc	r25, r25
    6eb8:	88 0f       	add	r24, r24
    6eba:	99 1f       	adc	r25, r25
    6ebc:	9c 01       	movw	r18, r24
    6ebe:	22 0f       	add	r18, r18
    6ec0:	33 1f       	adc	r19, r19
    6ec2:	22 0f       	add	r18, r18
    6ec4:	33 1f       	adc	r19, r19
    6ec6:	28 0f       	add	r18, r24
    6ec8:	39 1f       	adc	r19, r25
    6eca:	27 58       	subi	r18, 0x87	; 135
    6ecc:	32 4d       	sbci	r19, 0xD2	; 210
    6ece:	f9 01       	movw	r30, r18
    6ed0:	85 91       	lpm	r24, Z+
    6ed2:	94 91       	lpm	r25, Z+
		USART_Func(MB_N, LED);
    6ed4:	fc 01       	movw	r30, r24
    6ed6:	19 95       	eicall
		sei();
    6ed8:	78 94       	sei
		switch (MB_SingleState[MB_N]) {
    6eda:	c3 55       	subi	r28, 0x53	; 83
    6edc:	d9 4f       	sbci	r29, 0xF9	; 249
    6ede:	88 81       	ld	r24, Y
    6ee0:	88 23       	and	r24, r24
    6ee2:	b1 f1       	breq	.+108    	; 0x6f50 <MB_M_Cycle+0x132>
    6ee4:	81 30       	cpi	r24, 0x01	; 1
    6ee6:	81 f1       	breq	.+96     	; 0x6f48 <MB_M_Cycle+0x12a>
				FormQuery(MB_N);
			else
				FormSingle(MB_N);
			break;
		}
		StartTimer16(TD_MB_Idle+MB_N, 0xFFFF);	//     
    6ee8:	80 91 e6 04 	lds	r24, 0x04E6
    6eec:	8f 0d       	add	r24, r15
    6eee:	6f ef       	ldi	r22, 0xFF	; 255
    6ef0:	7f ef       	ldi	r23, 0xFF	; 255
    6ef2:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
		cli();
    6ef6:	f8 94       	cli
		MB_Transm(MB_N);
    6ef8:	8f 2d       	mov	r24, r15
    6efa:	0e 94 79 29 	call	0x52f2	; 0x52f2 <MB_Transm>
		sei();
    6efe:	78 94       	sei
		break;
	}
}
    6f00:	df 91       	pop	r29
    6f02:	cf 91       	pop	r28
    6f04:	1f 91       	pop	r17
    6f06:	0f 91       	pop	r16
    6f08:	ff 90       	pop	r15
    6f0a:	08 95       	ret
	}
	else return;
	
	switch (MB_State[MB_N]) {
	case MB_NoReply:
		FailSlave(MB_N);
    6f0c:	8f 2d       	mov	r24, r15
    6f0e:	0e 94 e8 31 	call	0x63d0	; 0x63d0 <FailSlave>
		switch (MB_SingleState[MB_N]) {
    6f12:	fe 01       	movw	r30, r28
    6f14:	e3 55       	subi	r30, 0x53	; 83
    6f16:	f9 4f       	sbci	r31, 0xF9	; 249
    6f18:	e0 81       	ld	r30, Z
    6f1a:	ee 23       	and	r30, r30
    6f1c:	e9 f4       	brne	.+58     	; 0x6f58 <MB_M_Cycle+0x13a>
		case MB_SingleIdle:
			FormQuery(MB_N);
    6f1e:	8f 2d       	mov	r24, r15
    6f20:	0e 94 81 30 	call	0x6102	; 0x6102 <FormQuery>
		case MB_SingleStart:
			if (Try[MB_N]==0)
				FormSingle(MB_N);
			break;
		}
		StartTimer16(TD_MB_Idle+MB_N, 0xFFFF);	//     
    6f24:	80 91 e6 04 	lds	r24, 0x04E6
    6f28:	8f 0d       	add	r24, r15
    6f2a:	6f ef       	ldi	r22, 0xFF	; 255
    6f2c:	7f ef       	ldi	r23, 0xFF	; 255
    6f2e:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
		cli();
    6f32:	f8 94       	cli
		MB_Transm(MB_N);
    6f34:	8f 2d       	mov	r24, r15
    6f36:	0e 94 79 29 	call	0x52f2	; 0x52f2 <MB_Transm>
		sei();
    6f3a:	78 94       	sei
		cli();
		MB_Transm(MB_N);
		sei();
		break;
	}
}
    6f3c:	df 91       	pop	r29
    6f3e:	cf 91       	pop	r28
    6f40:	1f 91       	pop	r17
    6f42:	0f 91       	pop	r16
    6f44:	ff 90       	pop	r15
    6f46:	08 95       	ret
		switch (MB_SingleState[MB_N]) {
		case MB_SingleIdle:
			FormQuery(MB_N);
			break;
		case MB_SingleStart:
			if (LastProcSingle)
    6f48:	80 91 e0 04 	lds	r24, 0x04E0
    6f4c:	88 23       	and	r24, r24
    6f4e:	79 f0       	breq	.+30     	; 0x6f6e <MB_M_Cycle+0x150>
				FormQuery(MB_N);
    6f50:	8f 2d       	mov	r24, r15
    6f52:	0e 94 81 30 	call	0x6102	; 0x6102 <FormQuery>
    6f56:	c8 cf       	rjmp	.-112    	; 0x6ee8 <MB_M_Cycle+0xca>
	else return;
	
	switch (MB_State[MB_N]) {
	case MB_NoReply:
		FailSlave(MB_N);
		switch (MB_SingleState[MB_N]) {
    6f58:	e1 30       	cpi	r30, 0x01	; 1
    6f5a:	21 f7       	brne	.-56     	; 0x6f24 <MB_M_Cycle+0x106>
		case MB_SingleIdle:
			FormQuery(MB_N);
			break;
		case MB_SingleStart:
			if (Try[MB_N]==0)
    6f5c:	cf 51       	subi	r28, 0x1F	; 31
    6f5e:	db 4f       	sbci	r29, 0xFB	; 251
    6f60:	88 81       	ld	r24, Y
    6f62:	88 23       	and	r24, r24
    6f64:	f9 f6       	brne	.-66     	; 0x6f24 <MB_M_Cycle+0x106>
				FormSingle(MB_N);
    6f66:	8f 2d       	mov	r24, r15
    6f68:	0e 94 d3 30 	call	0x61a6	; 0x61a6 <FormSingle>
    6f6c:	db cf       	rjmp	.-74     	; 0x6f24 <MB_M_Cycle+0x106>
			break;
		case MB_SingleStart:
			if (LastProcSingle)
				FormQuery(MB_N);
			else
				FormSingle(MB_N);
    6f6e:	8f 2d       	mov	r24, r15
    6f70:	0e 94 d3 30 	call	0x61a6	; 0x61a6 <FormSingle>
    6f74:	b9 cf       	rjmp	.-142    	; 0x6ee8 <MB_M_Cycle+0xca>

00006f76 <MB_Cycle>:
}

// ~~~~~~~~~~~
void
MB_Cycle(void)
{
    6f76:	cf 93       	push	r28
    6f78:	df 93       	push	r29
	void MB_S_Timer_ISR(uint8_t);
	void MB_M_Timer_ISR(uint8_t);

	for (uint8_t MB_N=0; MB_N<Modbus_Qt; MB_N++){
		if(MB_TimerFlag & (1<<MB_N)){
    6f7a:	80 91 e2 08 	lds	r24, 0x08E2
    6f7e:	80 fd       	sbrc	r24, 0
    6f80:	0c c0       	rjmp	.+24     	; 0x6f9a <MB_Cycle+0x24>
    6f82:	cf e7       	ldi	r28, 0x7F	; 127
    6f84:	dd e2       	ldi	r29, 0x2D	; 45

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    6f86:	fe 01       	movw	r30, r28
    6f88:	84 91       	lpm	r24, Z+
	}

	void MB_M_Cycle(uint8_t);

	for (uint8_t MB_N=0; MB_N<Modbus_Qt; MB_N++)
		if (prb(MB_Role+MB_N)==Role_Master)
    6f8a:	81 30       	cpi	r24, 0x01	; 1
    6f8c:	19 f4       	brne	.+6      	; 0x6f94 <MB_Cycle+0x1e>
			MB_M_Cycle(MB_N);
    6f8e:	80 e0       	ldi	r24, 0x00	; 0
    6f90:	0e 94 0f 37 	call	0x6e1e	; 0x6e1e <MB_M_Cycle>
}
    6f94:	df 91       	pop	r29
    6f96:	cf 91       	pop	r28
    6f98:	08 95       	ret
	void MB_S_Timer_ISR(uint8_t);
	void MB_M_Timer_ISR(uint8_t);

	for (uint8_t MB_N=0; MB_N<Modbus_Qt; MB_N++){
		if(MB_TimerFlag & (1<<MB_N)){
			cli();
    6f9a:	f8 94       	cli
			MB_TimerFlag &= ~(1<<MB_N);
    6f9c:	80 91 e2 08 	lds	r24, 0x08E2
    6fa0:	8e 7f       	andi	r24, 0xFE	; 254
    6fa2:	80 93 e2 08 	sts	0x08E2, r24
			sei();
    6fa6:	78 94       	sei
    6fa8:	cf e7       	ldi	r28, 0x7F	; 127
    6faa:	dd e2       	ldi	r29, 0x2D	; 45
    6fac:	fe 01       	movw	r30, r28
    6fae:	84 91       	lpm	r24, Z+
			switch (prb(MB_Role+MB_N)) {
    6fb0:	88 23       	and	r24, r24
    6fb2:	21 f4       	brne	.+8      	; 0x6fbc <MB_Cycle+0x46>
			case Role_Slave:
				MB_S_Timer_ISR(MB_N);
    6fb4:	80 e0       	ldi	r24, 0x00	; 0
    6fb6:	0e 94 31 2b 	call	0x5662	; 0x5662 <MB_S_Timer_ISR>
    6fba:	e5 cf       	rjmp	.-54     	; 0x6f86 <MB_Cycle+0x10>
	for (uint8_t MB_N=0; MB_N<Modbus_Qt; MB_N++){
		if(MB_TimerFlag & (1<<MB_N)){
			cli();
			MB_TimerFlag &= ~(1<<MB_N);
			sei();
			switch (prb(MB_Role+MB_N)) {
    6fbc:	81 30       	cpi	r24, 0x01	; 1
    6fbe:	19 f7       	brne	.-58     	; 0x6f86 <MB_Cycle+0x10>
			case Role_Slave:
				MB_S_Timer_ISR(MB_N);
				break;
			case Role_Master:
				MB_M_Timer_ISR(MB_N);
    6fc0:	80 e0       	ldi	r24, 0x00	; 0
    6fc2:	0e 94 5e 32 	call	0x64bc	; 0x64bc <MB_M_Timer_ISR>
    6fc6:	df cf       	rjmp	.-66     	; 0x6f86 <MB_Cycle+0x10>

00006fc8 <SetIP>:
	uint8_t IP3;
	uint8_t IP4;
} IP_Addr;

//~~~~~~~~~~~~~~
void SetIP(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
    6fc8:	0f 93       	push	r16
    6fca:	fc 01       	movw	r30, r24
	IP->IP1 = IP1;
    6fcc:	60 83       	st	Z, r22
	IP->IP2 = IP2;
    6fce:	41 83       	std	Z+1, r20	; 0x01
	IP->IP3 = IP3;
    6fd0:	22 83       	std	Z+2, r18	; 0x02
	IP->IP4 = IP4;
    6fd2:	03 83       	std	Z+3, r16	; 0x03
}
    6fd4:	0f 91       	pop	r16
    6fd6:	08 95       	ret

00006fd8 <IP_compare_Const>:
uint8_t IP_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
    6fd8:	0f 93       	push	r16
    6fda:	fc 01       	movw	r30, r24
	if((IP->IP1 == IP1) && (IP->IP2 == IP2) && (IP->IP3 == IP3) && (IP->IP4 == IP4)) return 1;
    6fdc:	80 81       	ld	r24, Z
    6fde:	86 17       	cp	r24, r22
    6fe0:	21 f0       	breq	.+8      	; 0x6fea <IP_compare_Const+0x12>
    6fe2:	20 e0       	ldi	r18, 0x00	; 0
	else return 0;
}
    6fe4:	82 2f       	mov	r24, r18
    6fe6:	0f 91       	pop	r16
    6fe8:	08 95       	ret
	IP->IP2 = IP2;
	IP->IP3 = IP3;
	IP->IP4 = IP4;
}
uint8_t IP_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	if((IP->IP1 == IP1) && (IP->IP2 == IP2) && (IP->IP3 == IP3) && (IP->IP4 == IP4)) return 1;
    6fea:	81 81       	ldd	r24, Z+1	; 0x01
    6fec:	84 17       	cp	r24, r20
    6fee:	c9 f7       	brne	.-14     	; 0x6fe2 <IP_compare_Const+0xa>
    6ff0:	82 81       	ldd	r24, Z+2	; 0x02
    6ff2:	82 17       	cp	r24, r18
    6ff4:	b1 f7       	brne	.-20     	; 0x6fe2 <IP_compare_Const+0xa>
    6ff6:	20 e0       	ldi	r18, 0x00	; 0
    6ff8:	83 81       	ldd	r24, Z+3	; 0x03
    6ffa:	80 13       	cpse	r24, r16
    6ffc:	21 e0       	ldi	r18, 0x01	; 1
    6ffe:	81 e0       	ldi	r24, 0x01	; 1
    7000:	28 27       	eor	r18, r24
    7002:	f0 cf       	rjmp	.-32     	; 0x6fe4 <IP_compare_Const+0xc>

00007004 <GSM_StartCalling>:
uint8_t numOfCheckBallanceRetry=0;

uint8_t Message[3];  // 
uint8_t GSMBusyState=0; // " " 0 -  , 1 -  
void GSM_StartCalling(uint8_t inputN,uint8_t abonentN){
	Message[0]=1;
    7004:	91 e0       	ldi	r25, 0x01	; 1
    7006:	90 93 f2 06 	sts	0x06F2, r25
	Message[1]=inputN;
    700a:	80 93 f3 06 	sts	0x06F3, r24
	Message[2]=abonentN;
    700e:	60 93 f4 06 	sts	0x06F4, r22
}
    7012:	08 95       	ret

00007014 <InitFIFO>:
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    7014:	8f ef       	ldi	r24, 0xFF	; 255
    7016:	80 93 fa 06 	sts	0x06FA, r24
	GSM_RX_FIFO_End = 255;
    701a:	80 93 51 06 	sts	0x0651, r24
	GSM_RxCharN = 0;
    701e:	10 92 18 0b 	sts	0x0B18, r1
	GSM_RX_FIFOOverFlow = 0;
    7022:	10 92 cb 08 	sts	0x08CB, r1
	GSM_RX_FIFOMax = 0;
    7026:	10 92 d1 08 	sts	0x08D1, r1
}
    702a:	08 95       	ret

0000702c <GetByteFromFIFO>:
// ~~~~~~~~~~~
void GetByteFromFIFO(uint8_t *ReadBuf, uint8_t *Index, uint8_t ReadBuf_Sz){
    702c:	0f 93       	push	r16
    702e:	1f 93       	push	r17
    7030:	cf 93       	push	r28
    7032:	df 93       	push	r29
    7034:	8c 01       	movw	r16, r24
    7036:	eb 01       	movw	r28, r22

	//Reset *Index if read buffer overflow
	if(*Index >= ReadBuf_Sz){
    7038:	88 81       	ld	r24, Y
    703a:	84 17       	cp	r24, r20
    703c:	08 f0       	brcs	.+2      	; 0x7040 <GetByteFromFIFO+0x14>
		*Index = 0;
    703e:	18 82       	st	Y, r1
		//TODO  
	}	

	if(GSM_RX_FIFO_Begin > GSM_RX_FIFO_End){
    7040:	80 91 fa 06 	lds	r24, 0x06FA
    7044:	e0 91 51 06 	lds	r30, 0x0651
    7048:	e8 17       	cp	r30, r24
    704a:	f8 f4       	brcc	.+62     	; 0x708a <GetByteFromFIFO+0x5e>
		if((GSM_RX_FIFO_End != 255)&&(GSM_RX_FIFO_End != 255))			
    704c:	ef 3f       	cpi	r30, 0xFF	; 255
    704e:	61 f0       	breq	.+24     	; 0x7068 <GetByteFromFIFO+0x3c>
			if(GSM_RX_FIFOMax < (GSM_RX_FIFO_Begin - GSM_RX_FIFO_End))
    7050:	20 91 d1 08 	lds	r18, 0x08D1
    7054:	80 91 fa 06 	lds	r24, 0x06FA
    7058:	30 e0       	ldi	r19, 0x00	; 0
    705a:	90 e0       	ldi	r25, 0x00	; 0
    705c:	8e 1b       	sub	r24, r30
    705e:	91 09       	sbc	r25, r1
    7060:	28 17       	cp	r18, r24
    7062:	39 07       	cpc	r19, r25
    7064:	0c f4       	brge	.+2      	; 0x7068 <GetByteFromFIFO+0x3c>
    7066:	46 c0       	rjmp	.+140    	; 0x70f4 <GetByteFromFIFO+0xc8>
				GSM_RX_FIFOMax =  GSM_RX_FIFO_Begin - GSM_RX_FIFO_End;
		GSM_RX_FIFO_End++;
    7068:	ef 5f       	subi	r30, 0xFF	; 255
    706a:	e0 93 51 06 	sts	0x0651, r30
		ReadBuf[*Index] = GSM_RX_FIFO[GSM_RX_FIFO_End];
    706e:	88 81       	ld	r24, Y
    7070:	d8 01       	movw	r26, r16
    7072:	a8 0f       	add	r26, r24
    7074:	b1 1d       	adc	r27, r1
    7076:	f0 e0       	ldi	r31, 0x00	; 0
    7078:	e1 52       	subi	r30, 0x21	; 33
    707a:	fa 4f       	sbci	r31, 0xFA	; 250
    707c:	80 81       	ld	r24, Z
    707e:	8c 93       	st	X, r24
		*Index=*Index+1;
    7080:	88 81       	ld	r24, Y
    7082:	8f 5f       	subi	r24, 0xFF	; 255
    7084:	88 83       	st	Y, r24
    7086:	e0 91 51 06 	lds	r30, 0x0651
	}
	if(GSM_RX_FIFO_End > GSM_RX_FIFO_Begin){
    708a:	80 91 fa 06 	lds	r24, 0x06FA
    708e:	8e 17       	cp	r24, r30
    7090:	28 f5       	brcc	.+74     	; 0x70dc <GetByteFromFIFO+0xb0>
		if((GSM_RX_FIFO_End != 255)&&(GSM_RX_FIFO_End != 255))
    7092:	ef 3f       	cpi	r30, 0xFF	; 255
    7094:	99 f0       	breq	.+38     	; 0x70bc <GetByteFromFIFO+0x90>
			if(GSM_RX_FIFOMax < (GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End  + GSM_RX_FIFO_Begin))
    7096:	20 91 d1 08 	lds	r18, 0x08D1
    709a:	80 91 fa 06 	lds	r24, 0x06FA
    709e:	30 e0       	ldi	r19, 0x00	; 0
    70a0:	90 e0       	ldi	r25, 0x00	; 0
    70a2:	8c 59       	subi	r24, 0x9C	; 156
    70a4:	9f 4f       	sbci	r25, 0xFF	; 255
    70a6:	8e 1b       	sub	r24, r30
    70a8:	91 09       	sbc	r25, r1
    70aa:	28 17       	cp	r18, r24
    70ac:	39 07       	cpc	r19, r25
    70ae:	dc f0       	brlt	.+54     	; 0x70e6 <GetByteFromFIFO+0xba>
				GSM_RX_FIFOMax = GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End  + GSM_RX_FIFO_Begin;
		GSM_RX_FIFO_End++;
    70b0:	8e 2f       	mov	r24, r30
    70b2:	8f 5f       	subi	r24, 0xFF	; 255
    70b4:	80 93 51 06 	sts	0x0651, r24
		if(GSM_RX_FIFO_End >= GSM_RX_FIFO_SIZE) GSM_RX_FIFO_End = 0;
    70b8:	84 36       	cpi	r24, 0x64	; 100
    70ba:	10 f0       	brcs	.+4      	; 0x70c0 <GetByteFromFIFO+0x94>
    70bc:	10 92 51 06 	sts	0x0651, r1
		ReadBuf[*Index] = GSM_RX_FIFO[GSM_RX_FIFO_End];
    70c0:	88 81       	ld	r24, Y
    70c2:	08 0f       	add	r16, r24
    70c4:	11 1d       	adc	r17, r1
    70c6:	e0 91 51 06 	lds	r30, 0x0651
    70ca:	f0 e0       	ldi	r31, 0x00	; 0
    70cc:	e1 52       	subi	r30, 0x21	; 33
    70ce:	fa 4f       	sbci	r31, 0xFA	; 250
    70d0:	80 81       	ld	r24, Z
    70d2:	f8 01       	movw	r30, r16
    70d4:	80 83       	st	Z, r24
		*Index=*Index+1;
    70d6:	88 81       	ld	r24, Y
    70d8:	8f 5f       	subi	r24, 0xFF	; 255
    70da:	88 83       	st	Y, r24
	}
}
    70dc:	df 91       	pop	r29
    70de:	cf 91       	pop	r28
    70e0:	1f 91       	pop	r17
    70e2:	0f 91       	pop	r16
    70e4:	08 95       	ret
		*Index=*Index+1;
	}
	if(GSM_RX_FIFO_End > GSM_RX_FIFO_Begin){
		if((GSM_RX_FIFO_End != 255)&&(GSM_RX_FIFO_End != 255))
			if(GSM_RX_FIFOMax < (GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End  + GSM_RX_FIFO_Begin))
				GSM_RX_FIFOMax = GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End  + GSM_RX_FIFO_Begin;
    70e6:	80 91 fa 06 	lds	r24, 0x06FA
    70ea:	8c 59       	subi	r24, 0x9C	; 156
    70ec:	8e 1b       	sub	r24, r30
    70ee:	80 93 d1 08 	sts	0x08D1, r24
    70f2:	de cf       	rjmp	.-68     	; 0x70b0 <GetByteFromFIFO+0x84>
	}	

	if(GSM_RX_FIFO_Begin > GSM_RX_FIFO_End){
		if((GSM_RX_FIFO_End != 255)&&(GSM_RX_FIFO_End != 255))			
			if(GSM_RX_FIFOMax < (GSM_RX_FIFO_Begin - GSM_RX_FIFO_End))
				GSM_RX_FIFOMax =  GSM_RX_FIFO_Begin - GSM_RX_FIFO_End;
    70f4:	80 91 fa 06 	lds	r24, 0x06FA
    70f8:	8e 1b       	sub	r24, r30
    70fa:	80 93 d1 08 	sts	0x08D1, r24
    70fe:	b4 cf       	rjmp	.-152    	; 0x7068 <GetByteFromFIFO+0x3c>

00007100 <GetStringFromFIFO>:
//        
uint8_t GetStringFromFIFO(void){

	uint8_t StrLength = 0;

	while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    7100:	90 91 fa 06 	lds	r25, 0x06FA
    7104:	80 91 51 06 	lds	r24, 0x0651
    7108:	98 17       	cp	r25, r24
    710a:	39 f1       	breq	.+78     	; 0x715a <GetStringFromFIFO+0x5a>
		
		GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);
    710c:	89 e9       	ldi	r24, 0x99	; 153
    710e:	97 e0       	ldi	r25, 0x07	; 7
    7110:	68 e1       	ldi	r22, 0x18	; 24
    7112:	7b e0       	ldi	r23, 0x0B	; 11
    7114:	44 e6       	ldi	r20, 0x64	; 100
    7116:	0e 94 16 38 	call	0x702c	; 0x702c <GetByteFromFIFO>

		//   : xxxxxxxxxxxxxxxx<CR><LF>
		//	'\r' CR - carridge return 0x0D
		//	'\n' LF - line feed 0x0A
		//   xxxxxxxxxxxxxxxx<\0>
		if( (GSM_RxCharN >= 2) && (GSM_RxStr[GSM_RxCharN-2]== '\r') && (GSM_RxStr[GSM_RxCharN-1]== '\n') ){
    711a:	80 91 18 0b 	lds	r24, 0x0B18
    711e:	82 30       	cpi	r24, 0x02	; 2
    7120:	78 f3       	brcs	.-34     	; 0x7100 <GetStringFromFIFO>
    7122:	e0 91 18 0b 	lds	r30, 0x0B18
    7126:	f0 e0       	ldi	r31, 0x00	; 0
    7128:	e9 56       	subi	r30, 0x69	; 105
    712a:	f8 4f       	sbci	r31, 0xF8	; 248
    712c:	80 81       	ld	r24, Z
    712e:	8d 30       	cpi	r24, 0x0D	; 13
    7130:	39 f7       	brne	.-50     	; 0x7100 <GetStringFromFIFO>
    7132:	e0 91 18 0b 	lds	r30, 0x0B18
    7136:	f0 e0       	ldi	r31, 0x00	; 0
    7138:	e8 56       	subi	r30, 0x68	; 104
    713a:	f8 4f       	sbci	r31, 0xF8	; 248
    713c:	80 81       	ld	r24, Z
    713e:	8a 30       	cpi	r24, 0x0A	; 10
    7140:	f9 f6       	brne	.-66     	; 0x7100 <GetStringFromFIFO>
			GSM_RxStr[GSM_RxCharN-2] = '\0';
    7142:	e0 91 18 0b 	lds	r30, 0x0B18
    7146:	f0 e0       	ldi	r31, 0x00	; 0
    7148:	e9 56       	subi	r30, 0x69	; 105
    714a:	f8 4f       	sbci	r31, 0xF8	; 248
    714c:	10 82       	st	Z, r1
			StrLength = GSM_RxCharN-1;
    714e:	80 91 18 0b 	lds	r24, 0x0B18
    7152:	81 50       	subi	r24, 0x01	; 1
			GSM_RxCharN = 0;
    7154:	10 92 18 0b 	sts	0x0B18, r1
    7158:	08 95       	ret
//        
uint8_t GetStringFromFIFO(void){

	uint8_t StrLength = 0;

	while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    715a:	80 e0       	ldi	r24, 0x00	; 0
		}

	}//while
	
	return StrLength;
}
    715c:	08 95       	ret

0000715e <GetStringFromFIFOwithOverflowDetect>:

uint8_t GetStringFromFIFOwithOverflowDetect(void){
    715e:	04 c0       	rjmp	.+8      	; 0x7168 <GetStringFromFIFOwithOverflowDetect+0xa>

		//   : xxxxxxxxxxxxxxxx<CR><LF>
		//	'\r' CR - carridge return 0x0D
		//	'\n' LF - line feed 0x0A
		//   xxxxxxxxxxxxxxxx<\0>
		if( ((GSM_RxCharN >= 2) && (GSM_RxStr[GSM_RxCharN-2]== '\r') && (GSM_RxStr[GSM_RxCharN-1]== '\n'))||(GSM_RxCharN==GSM_RXSTR_SIZE-1) ){
    7160:	80 91 18 0b 	lds	r24, 0x0B18
    7164:	83 36       	cpi	r24, 0x63	; 99
    7166:	09 f1       	breq	.+66     	; 0x71aa <GetStringFromFIFOwithOverflowDetect+0x4c>

uint8_t GetStringFromFIFOwithOverflowDetect(void){

	uint8_t StrLength = 0;

	while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    7168:	90 91 fa 06 	lds	r25, 0x06FA
    716c:	80 91 51 06 	lds	r24, 0x0651
    7170:	98 17       	cp	r25, r24
    7172:	39 f1       	breq	.+78     	; 0x71c2 <GetStringFromFIFOwithOverflowDetect+0x64>
		
		GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);
    7174:	89 e9       	ldi	r24, 0x99	; 153
    7176:	97 e0       	ldi	r25, 0x07	; 7
    7178:	68 e1       	ldi	r22, 0x18	; 24
    717a:	7b e0       	ldi	r23, 0x0B	; 11
    717c:	44 e6       	ldi	r20, 0x64	; 100
    717e:	0e 94 16 38 	call	0x702c	; 0x702c <GetByteFromFIFO>

		//   : xxxxxxxxxxxxxxxx<CR><LF>
		//	'\r' CR - carridge return 0x0D
		//	'\n' LF - line feed 0x0A
		//   xxxxxxxxxxxxxxxx<\0>
		if( ((GSM_RxCharN >= 2) && (GSM_RxStr[GSM_RxCharN-2]== '\r') && (GSM_RxStr[GSM_RxCharN-1]== '\n'))||(GSM_RxCharN==GSM_RXSTR_SIZE-1) ){
    7182:	80 91 18 0b 	lds	r24, 0x0B18
    7186:	82 30       	cpi	r24, 0x02	; 2
    7188:	58 f3       	brcs	.-42     	; 0x7160 <GetStringFromFIFOwithOverflowDetect+0x2>
    718a:	e0 91 18 0b 	lds	r30, 0x0B18
    718e:	f0 e0       	ldi	r31, 0x00	; 0
    7190:	e9 56       	subi	r30, 0x69	; 105
    7192:	f8 4f       	sbci	r31, 0xF8	; 248
    7194:	80 81       	ld	r24, Z
    7196:	8d 30       	cpi	r24, 0x0D	; 13
    7198:	19 f7       	brne	.-58     	; 0x7160 <GetStringFromFIFOwithOverflowDetect+0x2>
    719a:	e0 91 18 0b 	lds	r30, 0x0B18
    719e:	f0 e0       	ldi	r31, 0x00	; 0
    71a0:	e8 56       	subi	r30, 0x68	; 104
    71a2:	f8 4f       	sbci	r31, 0xF8	; 248
    71a4:	80 81       	ld	r24, Z
    71a6:	8a 30       	cpi	r24, 0x0A	; 10
    71a8:	d9 f6       	brne	.-74     	; 0x7160 <GetStringFromFIFOwithOverflowDetect+0x2>
			GSM_RxStr[GSM_RxCharN-2] = '\0';
    71aa:	e0 91 18 0b 	lds	r30, 0x0B18
    71ae:	f0 e0       	ldi	r31, 0x00	; 0
    71b0:	e9 56       	subi	r30, 0x69	; 105
    71b2:	f8 4f       	sbci	r31, 0xF8	; 248
    71b4:	10 82       	st	Z, r1
			StrLength = GSM_RxCharN-1;
    71b6:	80 91 18 0b 	lds	r24, 0x0B18
    71ba:	81 50       	subi	r24, 0x01	; 1
			GSM_RxCharN = 0;
    71bc:	10 92 18 0b 	sts	0x0B18, r1
    71c0:	08 95       	ret

uint8_t GetStringFromFIFOwithOverflowDetect(void){

	uint8_t StrLength = 0;

	while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    71c2:	80 e0       	ldi	r24, 0x00	; 0
		}

	}//while
	
	return StrLength;
}
    71c4:	08 95       	ret

000071c6 <ForceEndStringFromFIFO>:
// ~~~~~~~~~~~
//    GSM_RxStr  <CR><LF>
uint8_t ForceEndStringFromFIFO(void){
	uint8_t StrLength;
	if(GSM_RxCharN > GSM_RXSTR_SIZE-1) GSM_RxCharN = GSM_RXSTR_SIZE-1;
    71c6:	80 91 18 0b 	lds	r24, 0x0B18
    71ca:	84 36       	cpi	r24, 0x64	; 100
    71cc:	18 f0       	brcs	.+6      	; 0x71d4 <ForceEndStringFromFIFO+0xe>
    71ce:	83 e6       	ldi	r24, 0x63	; 99
    71d0:	80 93 18 0b 	sts	0x0B18, r24
	StrLength = GSM_RxCharN;
    71d4:	80 91 18 0b 	lds	r24, 0x0B18
	GSM_RxStr[GSM_RxCharN]='\0';
    71d8:	e0 91 18 0b 	lds	r30, 0x0B18
    71dc:	f0 e0       	ldi	r31, 0x00	; 0
    71de:	e7 56       	subi	r30, 0x67	; 103
    71e0:	f8 4f       	sbci	r31, 0xF8	; 248
    71e2:	10 82       	st	Z, r1
	GSM_RxCharN = 0;
    71e4:	10 92 18 0b 	sts	0x0B18, r1
	return StrLength;
}
    71e8:	08 95       	ret

000071ea <GetDataFromFIFO>:

// ~~~~~~~~~~~
uint8_t GetDataFromFIFO(const uint8_t Amount){
    71ea:	1f 93       	push	r17
    71ec:	18 2f       	mov	r17, r24

	while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    71ee:	90 91 fa 06 	lds	r25, 0x06FA
    71f2:	80 91 51 06 	lds	r24, 0x0651
    71f6:	98 17       	cp	r25, r24
    71f8:	81 f0       	breq	.+32     	; 0x721a <GetDataFromFIFO+0x30>
		GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);
    71fa:	89 e9       	ldi	r24, 0x99	; 153
    71fc:	97 e0       	ldi	r25, 0x07	; 7
    71fe:	68 e1       	ldi	r22, 0x18	; 24
    7200:	7b e0       	ldi	r23, 0x0B	; 11
    7202:	44 e6       	ldi	r20, 0x64	; 100
    7204:	0e 94 16 38 	call	0x702c	; 0x702c <GetByteFromFIFO>
		if(GSM_RxCharN >= Amount){
    7208:	80 91 18 0b 	lds	r24, 0x0B18
    720c:	81 17       	cp	r24, r17
    720e:	78 f3       	brcs	.-34     	; 0x71ee <GetDataFromFIFO+0x4>
			GSM_RxCharN = 0;
    7210:	10 92 18 0b 	sts	0x0B18, r1
			return Amount;
		}
	}//while
	return GSM_RxCharN;
}
    7214:	81 2f       	mov	r24, r17
    7216:	1f 91       	pop	r17
    7218:	08 95       	ret
		if(GSM_RxCharN >= Amount){
			GSM_RxCharN = 0;
			return Amount;
		}
	}//while
	return GSM_RxCharN;
    721a:	10 91 18 0b 	lds	r17, 0x0B18
}
    721e:	81 2f       	mov	r24, r17
    7220:	1f 91       	pop	r17
    7222:	08 95       	ret

00007224 <GSM_Init>:
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    7224:	8f ef       	ldi	r24, 0xFF	; 255
    7226:	80 93 fa 06 	sts	0x06FA, r24
	GSM_RX_FIFO_End = 255;
    722a:	80 93 51 06 	sts	0x0651, r24
	GSM_RxCharN = 0;
    722e:	10 92 18 0b 	sts	0x0B18, r1
	GSM_RX_FIFOOverFlow = 0;
    7232:	10 92 cb 08 	sts	0x08CB, r1
	GSM_RX_FIFOMax = 0;
    7236:	10 92 d1 08 	sts	0x08D1, r1
		USART_GSM.BAUDCTRLB = 0x00 + USART_BSCALE0_bm;
		USART_GSM.CTRLA = USART_RXCINTLVL_HI_gc;
		USART_GSM.CTRLB = (1<<USART_RXEN_bp) | (1<<USART_TXEN_bp) | (0<<USART_CLK2X_bp) | (0 << USART_MPCM_bp) | (0 << USART_TXB8_bp);
		USART_GSM.CTRLC = USART_CMODE_ASYNCHRONOUS_gc | USART_PMODE_DISABLED_gc | (0<< USART_SBMODE_bp) | USART_CHSIZE_8BIT_gc;
	#else
		UCSR_GSM_A = ~(1<<U2X_GSM) &~(1<<MPCM_GSM);
    723a:	8c ef       	ldi	r24, 0xFC	; 252
    723c:	80 93 d0 00 	sts	0x00D0, r24
		UCSR_GSM_B =  (1<<RXCIE_GSM) | (0<<TXCIE_GSM) | (0<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    7240:	88 e9       	ldi	r24, 0x98	; 152
    7242:	80 93 d1 00 	sts	0x00D1, r24
		#if defined (__AVR_ATmega2561__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__)			
			UCSR_GSM_C = (0<<UMSEL_GSM_1) | (0<<UMSEL_GSM_0) | (0<<UPM_GSM_1) | (0<<UPM_GSM_0) | (0<<USBS_GSM) | (1<<UCSZ_GSM_1) | (1<<UCSZ_GSM_0) | (0<<UCPOL_GSM);
    7246:	86 e0       	ldi	r24, 0x06	; 6
    7248:	80 93 d2 00 	sts	0x00D2, r24
		#else
			UCSR_GSM_C = ((~(1<<UMSEL_GSM) &~(1<<UPM_GSM_1) &~(1<<UPM_GSM_0) &~(1<<USBS_GSM)) |(1<<UCSZ_GSM_1) |(1<<UCSZ_GSM_0)) &~(1<<UCPOL_GSM);
		#endif
		UBRR_GSM_H = 0x00;
    724c:	10 92 d5 00 	sts	0x00D5, r1
		UBRR_GSM_L = 0x67;	// 9600
    7250:	87 e6       	ldi	r24, 0x67	; 103
    7252:	80 93 d4 00 	sts	0x00D4, r24
#endif

//  gsm_sim900r.h   PWRCNTRL
#ifdef vmd2_3
	void GSM_PWRCNTRL_Config(void){
		cli();
    7256:	f8 94       	cli
		DDRL|=(1<<PL5);
    7258:	ea e0       	ldi	r30, 0x0A	; 10
    725a:	f1 e0       	ldi	r31, 0x01	; 1
    725c:	80 81       	ld	r24, Z
    725e:	80 62       	ori	r24, 0x20	; 32
    7260:	80 83       	st	Z, r24
		sei();
    7262:	78 94       	sei
		cli();
		PORTL|=(1<<PL5);
		sei();
	}
	void GSM_PWRCNTRL_ON(void){
		cli();
    7264:	f8 94       	cli
		PORTL &= ~(1<<PL5);
    7266:	eb e0       	ldi	r30, 0x0B	; 11
    7268:	f1 e0       	ldi	r31, 0x01	; 1
    726a:	80 81       	ld	r24, Z
    726c:	8f 7d       	andi	r24, 0xDF	; 223
    726e:	80 83       	st	Z, r24
		sei();
    7270:	78 94       	sei

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    7272:	80 91 d0 02 	lds	r24, 0x02D0
	VacantTimer16Sys += n;
    7276:	98 2f       	mov	r25, r24
    7278:	9f 5f       	subi	r25, 0xFF	; 255
	GSM_PWRCNTRL_ON();
	#ifdef GSM_HW_FLOW_CONTROL
		GSM_CTS_RTS_Config();
	#endif

	TD_GSM = Timer16SysAlloc(1);
    727a:	80 93 e7 04 	sts	0x04E7, r24
    727e:	29 2f       	mov	r18, r25
    7280:	2f 5f       	subi	r18, 0xFF	; 255
	TD_TCP_Connect = Timer16SysAlloc(1);
    7282:	90 93 e8 04 	sts	0x04E8, r25

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer32SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer32Sys;
    7286:	90 91 d1 02 	lds	r25, 0x02D1
	VacantTimer32Sys += n;
    728a:	89 2f       	mov	r24, r25
    728c:	8f 5f       	subi	r24, 0xFF	; 255
	TD_GSM_Reset = Timer32SysAlloc(1);
    728e:	90 93 e9 04 	sts	0x04E9, r25
// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
	VacantTimer16Sys += n;
    7292:	92 2f       	mov	r25, r18
    7294:	9f 5f       	subi	r25, 0xFF	; 255
	TD_5min_timer = Timer16SysAlloc(1);
    7296:	20 93 ea 04 	sts	0x04EA, r18
// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer32SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer32Sys;
	VacantTimer32Sys += n;
    729a:	8f 5f       	subi	r24, 0xFF	; 255
    729c:	80 93 d1 02 	sts	0x02D1, r24
    72a0:	81 50       	subi	r24, 0x01	; 1
	TD_1hour_resetGPRS_timer = Timer32SysAlloc(1);
    72a2:	80 93 eb 04 	sts	0x04EB, r24
// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
	VacantTimer16Sys += n;
    72a6:	89 2f       	mov	r24, r25
    72a8:	8f 5f       	subi	r24, 0xFF	; 255
	TD_CheckModem = Timer16SysAlloc(1);
    72aa:	90 93 ec 04 	sts	0x04EC, r25
    72ae:	9e 5f       	subi	r25, 0xFE	; 254
	TD_CleanFIFO = Timer16SysAlloc(1);
    72b0:	80 93 ed 04 	sts	0x04ED, r24
    72b4:	8e 5f       	subi	r24, 0xFE	; 254
	TD_data_start_delay = Timer16SysAlloc(1);
    72b6:	90 93 ee 04 	sts	0x04EE, r25
    72ba:	8f 5f       	subi	r24, 0xFF	; 255
    72bc:	80 93 d0 02 	sts	0x02D0, r24
    72c0:	81 50       	subi	r24, 0x01	; 1
	TD_timer_after_page_transfer = Timer16SysAlloc(1);
    72c2:	80 93 ef 04 	sts	0x04EF, r24

/*	for (uint8_t i=0; i<4; i++)
		GPRS_ServerAddr[i] = erb(GPRS_ServerAddr_EE+i);
*/
	GSM_Control = GSM_CNTL_AUTO;
    72c6:	10 92 8a 07 	sts	0x078A, r1
	GSM_State = GSM_PowerOn;
    72ca:	10 92 b3 06 	sts	0x06B3, r1



}
    72ce:	08 95       	ret

000072d0 <GSM_RX>:
// ~~~~~~~~~
void
GSM_RX(void)
{
	char Char = UDR_GSM;
    72d0:	90 91 d6 00 	lds	r25, 0x00D6

	//---FIFO
	GSM_RX_FIFO_Begin++;
    72d4:	80 91 fa 06 	lds	r24, 0x06FA
    72d8:	8f 5f       	subi	r24, 0xFF	; 255
    72da:	80 93 fa 06 	sts	0x06FA, r24
	if(GSM_RX_FIFO_Begin >= GSM_RX_FIFO_SIZE) GSM_RX_FIFO_Begin = 0;
    72de:	80 91 fa 06 	lds	r24, 0x06FA
    72e2:	84 36       	cpi	r24, 0x64	; 100
    72e4:	10 f0       	brcs	.+4      	; 0x72ea <GSM_RX+0x1a>
    72e6:	10 92 fa 06 	sts	0x06FA, r1
	GSM_RX_FIFO[GSM_RX_FIFO_Begin] = Char;
    72ea:	e0 91 fa 06 	lds	r30, 0x06FA
    72ee:	f0 e0       	ldi	r31, 0x00	; 0
    72f0:	e1 52       	subi	r30, 0x21	; 33
    72f2:	fa 4f       	sbci	r31, 0xFA	; 250
    72f4:	90 83       	st	Z, r25
	if(GSM_RX_FIFO_Begin == GSM_RX_FIFO_End){
    72f6:	90 91 fa 06 	lds	r25, 0x06FA
    72fa:	80 91 51 06 	lds	r24, 0x0651
    72fe:	98 13       	cpse	r25, r24
    7300:	08 95       	ret
		GSM_RX_FIFOOverFlow = 1;
    7302:	81 e0       	ldi	r24, 0x01	; 1
    7304:	80 93 cb 08 	sts	0x08CB, r24
		GSM_RX_FIFOMax = GSM_RX_FIFO_SIZE;
    7308:	84 e6       	ldi	r24, 0x64	; 100
    730a:	80 93 d1 08 	sts	0x08D1, r24
    730e:	08 95       	ret

00007310 <GSM_Wait_Char>:
		else return 1;
	}
	else return 0;
}
// ~~~~~~~~~
uint8_t GSM_Wait_Char(char Char, uint8_t RestoreCMD){
    7310:	0f 93       	push	r16
    7312:	1f 93       	push	r17
    7314:	08 2f       	mov	r16, r24
    7316:	16 2f       	mov	r17, r22
	if(Timer16Stopp(TD_GSM)){
    7318:	80 91 e7 04 	lds	r24, 0x04E7
    731c:	0e 94 06 1c 	call	0x380c	; 0x380c <Timer16Stopp>
    7320:	88 23       	and	r24, r24
    7322:	39 f0       	breq	.+14     	; 0x7332 <GSM_Wait_Char+0x22>
		GSM_State = RestoreCMD;
    7324:	10 93 b3 06 	sts	0x06B3, r17
    7328:	90 e0       	ldi	r25, 0x00	; 0
	if(GetDataFromFIFO(1)){
		if(GSM_RxStr[0] == Char)	return 1;
		else return 0;
	}
	else return 0;
}
    732a:	89 2f       	mov	r24, r25
    732c:	1f 91       	pop	r17
    732e:	0f 91       	pop	r16
    7330:	08 95       	ret
	if(Timer16Stopp(TD_GSM)){
		GSM_State = RestoreCMD;
		return 0;
	}
	//   
	if(GetDataFromFIFO(1)){
    7332:	81 e0       	ldi	r24, 0x01	; 1
    7334:	0e 94 f5 38 	call	0x71ea	; 0x71ea <GetDataFromFIFO>
    7338:	88 23       	and	r24, r24
    733a:	39 f0       	breq	.+14     	; 0x734a <GSM_Wait_Char+0x3a>
    733c:	90 e0       	ldi	r25, 0x00	; 0
    733e:	80 91 99 07 	lds	r24, 0x0799
    7342:	80 17       	cp	r24, r16
    7344:	91 f7       	brne	.-28     	; 0x732a <GSM_Wait_Char+0x1a>
    7346:	91 e0       	ldi	r25, 0x01	; 1
    7348:	f0 cf       	rjmp	.-32     	; 0x732a <GSM_Wait_Char+0x1a>
    734a:	90 e0       	ldi	r25, 0x00	; 0
		if(GSM_RxStr[0] == Char)	return 1;
		else return 0;
	}
	else return 0;
}
    734c:	89 2f       	mov	r24, r25
    734e:	1f 91       	pop	r17
    7350:	0f 91       	pop	r16
    7352:	08 95       	ret

00007354 <GSM_SendFirstChar>:
// ~~~~~~~~~
void GSM_SendFirstChar(void){

	UDR_GSM = GSM_TxStr[0];
    7354:	80 91 02 0a 	lds	r24, 0x0A02
    7358:	80 93 d6 00 	sts	0x00D6, r24
	#ifdef GSM_DEBUG
		GPRS_TerminalProcess(GSM_TxStr[0]);
	#endif

	GSM_TxCharN = 1;
    735c:	81 e0       	ldi	r24, 0x01	; 1
    735e:	80 93 21 0b 	sts	0x0B21, r24
	cli();
    7362:	f8 94       	cli
	GSM_Flag &=~(1<<flg_TxCStr);	
    7364:	80 91 d2 02 	lds	r24, 0x02D2
    7368:	8e 7f       	andi	r24, 0xFE	; 254
    736a:	80 93 d2 02 	sts	0x02D2, r24
	sei();
    736e:	78 94       	sei
	cli();
    7370:	f8 94       	cli
	#if defined (__AVR_ATxmega128A1__)
		USART_GSM.CTRLA = USART_RXCINTLVL_HI_gc | USART_DREINTLVL_HI_gc;
	#else
		UCSR_GSM_B =  (1<<RXCIE_GSM) | (0<<TXCIE_GSM) | (1<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    7372:	88 eb       	ldi	r24, 0xB8	; 184
    7374:	80 93 d1 00 	sts	0x00D1, r24
	#endif
	
	sei();	
    7378:	78 94       	sei
}
    737a:	08 95       	ret

0000737c <GSM_DRE>:
		StartTimer16(TD_GSM, Timeout);
	}
}
// ~~~~~~~~~
void GSM_DRE(void){
	if(GSM_TxCharN < GSMTxSz){
    737c:	90 91 21 0b 	lds	r25, 0x0B21
    7380:	80 91 75 07 	lds	r24, 0x0775
    7384:	98 17       	cp	r25, r24
    7386:	20 f0       	brcs	.+8      	; 0x7390 <GSM_DRE+0x14>
	}
	else{
		#if defined (__AVR_ATxmega128A1__)
			USART_GSM.CTRLA = USART_RXCINTLVL_HI_gc | USART_TXCINTLVL_HI_gc;
		#else
			UCSR_GSM_B =  (1<<RXCIE_GSM) | (1<<TXCIE_GSM) | (0<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    7388:	88 ed       	ldi	r24, 0xD8	; 216
    738a:	80 93 d1 00 	sts	0x00D1, r24
    738e:	08 95       	ret
	}
}
// ~~~~~~~~~
void GSM_DRE(void){
	if(GSM_TxCharN < GSMTxSz){
		UDR_GSM = GSM_TxStr[GSM_TxCharN];
    7390:	e0 91 21 0b 	lds	r30, 0x0B21
    7394:	f0 e0       	ldi	r31, 0x00	; 0
    7396:	ee 5f       	subi	r30, 0xFE	; 254
    7398:	f5 4f       	sbci	r31, 0xF5	; 245
    739a:	80 81       	ld	r24, Z
    739c:	80 93 d6 00 	sts	0x00D6, r24
		#ifdef GSM_DEBUG
			GPRS_TerminalProcess(GSM_TxStr[GSM_TxCharN]);
		#endif
		GSM_TxCharN++;
    73a0:	80 91 21 0b 	lds	r24, 0x0B21
    73a4:	8f 5f       	subi	r24, 0xFF	; 255
    73a6:	80 93 21 0b 	sts	0x0B21, r24
    73aa:	08 95       	ret

000073ac <GSM_TX>:
}
// ~~~~~~~~~
void
GSM_TX(void)
{
	GSM_Flag |=(1<<flg_TxCStr);
    73ac:	80 91 d2 02 	lds	r24, 0x02D2
    73b0:	81 60       	ori	r24, 0x01	; 1
    73b2:	80 93 d2 02 	sts	0x02D2, r24
	if(dataSendFlg){
    73b6:	80 91 df 02 	lds	r24, 0x02DF
    73ba:	88 23       	and	r24, r24
    73bc:	21 f0       	breq	.+8      	; 0x73c6 <GSM_TX+0x1a>
	dataSendFlg=0;
    73be:	10 92 df 02 	sts	0x02DF, r1
	GPRS_FlgSz_Out=0;
    73c2:	10 92 6d 07 	sts	0x076D, r1
	}
	#if defined (__AVR_ATxmega128A1__)
		USART_GSM.CTRLA = USART_RXCINTLVL_HI_gc;
	#else
		UCSR_GSM_B =  (1<<RXCIE_GSM) | (0<<TXCIE_GSM) | (0<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    73c6:	88 e9       	ldi	r24, 0x98	; 152
    73c8:	80 93 d1 00 	sts	0x00D1, r24
	#endif
}
    73cc:	08 95       	ret

000073ce <GSM_Reset>:
GSM_Reset(void)
{
/*	IntOff();
	GSM_State = GSM_Restart;
	IntOn();*/
}
    73ce:	08 95       	ret

000073d0 <GSM_GotoNextVega>:

uint8_t GSM_GotoNextVega(void){
 return 0;
}
    73d0:	80 e0       	ldi	r24, 0x00	; 0
    73d2:	08 95       	ret

000073d4 <GPRS_ServerAddr_Save>:
// ~~~~~~~~~~~~~~~~~~~~~~~~
void
GPRS_ServerAddr_Save(void)
{

}
    73d4:	08 95       	ret

000073d6 <__vector_25>:
#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__)
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	#ifdef vmd2_3
		// ~~~~~~~~~~
		// USART0 - PORT0
		Modbus_ISR(0)
    73d6:	1f 92       	push	r1
    73d8:	0f 92       	push	r0
    73da:	0f b6       	in	r0, 0x3f	; 63
    73dc:	0f 92       	push	r0
    73de:	0b b6       	in	r0, 0x3b	; 59
    73e0:	0f 92       	push	r0
    73e2:	11 24       	eor	r1, r1
    73e4:	2f 93       	push	r18
    73e6:	3f 93       	push	r19
    73e8:	4f 93       	push	r20
    73ea:	5f 93       	push	r21
    73ec:	6f 93       	push	r22
    73ee:	7f 93       	push	r23
    73f0:	8f 93       	push	r24
    73f2:	9f 93       	push	r25
    73f4:	af 93       	push	r26
    73f6:	bf 93       	push	r27
    73f8:	ef 93       	push	r30
    73fa:	ff 93       	push	r31
    73fc:	86 ec       	ldi	r24, 0xC6	; 198
    73fe:	90 e0       	ldi	r25, 0x00	; 0
    7400:	0e 94 e0 29 	call	0x53c0	; 0x53c0 <Modbus_RX>
    7404:	ff 91       	pop	r31
    7406:	ef 91       	pop	r30
    7408:	bf 91       	pop	r27
    740a:	af 91       	pop	r26
    740c:	9f 91       	pop	r25
    740e:	8f 91       	pop	r24
    7410:	7f 91       	pop	r23
    7412:	6f 91       	pop	r22
    7414:	5f 91       	pop	r21
    7416:	4f 91       	pop	r20
    7418:	3f 91       	pop	r19
    741a:	2f 91       	pop	r18
    741c:	0f 90       	pop	r0
    741e:	0b be       	out	0x3b, r0	; 59
    7420:	0f 90       	pop	r0
    7422:	0f be       	out	0x3f, r0	; 63
    7424:	0f 90       	pop	r0
    7426:	1f 90       	pop	r1
    7428:	18 95       	reti

0000742a <__vector_27>:
    742a:	1f 92       	push	r1
    742c:	0f 92       	push	r0
    742e:	0f b6       	in	r0, 0x3f	; 63
    7430:	0f 92       	push	r0
    7432:	0b b6       	in	r0, 0x3b	; 59
    7434:	0f 92       	push	r0
    7436:	11 24       	eor	r1, r1
    7438:	2f 93       	push	r18
    743a:	3f 93       	push	r19
    743c:	4f 93       	push	r20
    743e:	5f 93       	push	r21
    7440:	6f 93       	push	r22
    7442:	7f 93       	push	r23
    7444:	8f 93       	push	r24
    7446:	9f 93       	push	r25
    7448:	af 93       	push	r26
    744a:	bf 93       	push	r27
    744c:	ef 93       	push	r30
    744e:	ff 93       	push	r31
    7450:	86 ec       	ldi	r24, 0xC6	; 198
    7452:	90 e0       	ldi	r25, 0x00	; 0
    7454:	0e 94 7f 35 	call	0x6afe	; 0x6afe <Modbus_TX>
    7458:	ff 91       	pop	r31
    745a:	ef 91       	pop	r30
    745c:	bf 91       	pop	r27
    745e:	af 91       	pop	r26
    7460:	9f 91       	pop	r25
    7462:	8f 91       	pop	r24
    7464:	7f 91       	pop	r23
    7466:	6f 91       	pop	r22
    7468:	5f 91       	pop	r21
    746a:	4f 91       	pop	r20
    746c:	3f 91       	pop	r19
    746e:	2f 91       	pop	r18
    7470:	0f 90       	pop	r0
    7472:	0b be       	out	0x3b, r0	; 59
    7474:	0f 90       	pop	r0
    7476:	0f be       	out	0x3f, r0	; 63
    7478:	0f 90       	pop	r0
    747a:	1f 90       	pop	r1
    747c:	18 95       	reti

0000747e <__vector_26>:
    747e:	1f 92       	push	r1
    7480:	0f 92       	push	r0
    7482:	0f b6       	in	r0, 0x3f	; 63
    7484:	0f 92       	push	r0
    7486:	0b b6       	in	r0, 0x3b	; 59
    7488:	0f 92       	push	r0
    748a:	11 24       	eor	r1, r1
    748c:	2f 93       	push	r18
    748e:	3f 93       	push	r19
    7490:	4f 93       	push	r20
    7492:	5f 93       	push	r21
    7494:	6f 93       	push	r22
    7496:	7f 93       	push	r23
    7498:	8f 93       	push	r24
    749a:	9f 93       	push	r25
    749c:	af 93       	push	r26
    749e:	bf 93       	push	r27
    74a0:	ef 93       	push	r30
    74a2:	ff 93       	push	r31
    74a4:	86 ec       	ldi	r24, 0xC6	; 198
    74a6:	90 e0       	ldi	r25, 0x00	; 0
    74a8:	0e 94 7f 35 	call	0x6afe	; 0x6afe <Modbus_TX>
    74ac:	ff 91       	pop	r31
    74ae:	ef 91       	pop	r30
    74b0:	bf 91       	pop	r27
    74b2:	af 91       	pop	r26
    74b4:	9f 91       	pop	r25
    74b6:	8f 91       	pop	r24
    74b8:	7f 91       	pop	r23
    74ba:	6f 91       	pop	r22
    74bc:	5f 91       	pop	r21
    74be:	4f 91       	pop	r20
    74c0:	3f 91       	pop	r19
    74c2:	2f 91       	pop	r18
    74c4:	0f 90       	pop	r0
    74c6:	0b be       	out	0x3b, r0	; 59
    74c8:	0f 90       	pop	r0
    74ca:	0f be       	out	0x3f, r0	; 63
    74cc:	0f 90       	pop	r0
    74ce:	1f 90       	pop	r1
    74d0:	18 95       	reti

000074d2 <__vector_36>:

		// ~~~~~~~~~~
		// USART1 - PORT1
		Modbus_ISR(1)
    74d2:	1f 92       	push	r1
    74d4:	0f 92       	push	r0
    74d6:	0f b6       	in	r0, 0x3f	; 63
    74d8:	0f 92       	push	r0
    74da:	0b b6       	in	r0, 0x3b	; 59
    74dc:	0f 92       	push	r0
    74de:	11 24       	eor	r1, r1
    74e0:	2f 93       	push	r18
    74e2:	3f 93       	push	r19
    74e4:	4f 93       	push	r20
    74e6:	5f 93       	push	r21
    74e8:	6f 93       	push	r22
    74ea:	7f 93       	push	r23
    74ec:	8f 93       	push	r24
    74ee:	9f 93       	push	r25
    74f0:	af 93       	push	r26
    74f2:	bf 93       	push	r27
    74f4:	ef 93       	push	r30
    74f6:	ff 93       	push	r31
    74f8:	8e ec       	ldi	r24, 0xCE	; 206
    74fa:	90 e0       	ldi	r25, 0x00	; 0
    74fc:	0e 94 e0 29 	call	0x53c0	; 0x53c0 <Modbus_RX>
    7500:	ff 91       	pop	r31
    7502:	ef 91       	pop	r30
    7504:	bf 91       	pop	r27
    7506:	af 91       	pop	r26
    7508:	9f 91       	pop	r25
    750a:	8f 91       	pop	r24
    750c:	7f 91       	pop	r23
    750e:	6f 91       	pop	r22
    7510:	5f 91       	pop	r21
    7512:	4f 91       	pop	r20
    7514:	3f 91       	pop	r19
    7516:	2f 91       	pop	r18
    7518:	0f 90       	pop	r0
    751a:	0b be       	out	0x3b, r0	; 59
    751c:	0f 90       	pop	r0
    751e:	0f be       	out	0x3f, r0	; 63
    7520:	0f 90       	pop	r0
    7522:	1f 90       	pop	r1
    7524:	18 95       	reti

00007526 <__vector_38>:
    7526:	1f 92       	push	r1
    7528:	0f 92       	push	r0
    752a:	0f b6       	in	r0, 0x3f	; 63
    752c:	0f 92       	push	r0
    752e:	0b b6       	in	r0, 0x3b	; 59
    7530:	0f 92       	push	r0
    7532:	11 24       	eor	r1, r1
    7534:	2f 93       	push	r18
    7536:	3f 93       	push	r19
    7538:	4f 93       	push	r20
    753a:	5f 93       	push	r21
    753c:	6f 93       	push	r22
    753e:	7f 93       	push	r23
    7540:	8f 93       	push	r24
    7542:	9f 93       	push	r25
    7544:	af 93       	push	r26
    7546:	bf 93       	push	r27
    7548:	ef 93       	push	r30
    754a:	ff 93       	push	r31
    754c:	8e ec       	ldi	r24, 0xCE	; 206
    754e:	90 e0       	ldi	r25, 0x00	; 0
    7550:	0e 94 7f 35 	call	0x6afe	; 0x6afe <Modbus_TX>
    7554:	ff 91       	pop	r31
    7556:	ef 91       	pop	r30
    7558:	bf 91       	pop	r27
    755a:	af 91       	pop	r26
    755c:	9f 91       	pop	r25
    755e:	8f 91       	pop	r24
    7560:	7f 91       	pop	r23
    7562:	6f 91       	pop	r22
    7564:	5f 91       	pop	r21
    7566:	4f 91       	pop	r20
    7568:	3f 91       	pop	r19
    756a:	2f 91       	pop	r18
    756c:	0f 90       	pop	r0
    756e:	0b be       	out	0x3b, r0	; 59
    7570:	0f 90       	pop	r0
    7572:	0f be       	out	0x3f, r0	; 63
    7574:	0f 90       	pop	r0
    7576:	1f 90       	pop	r1
    7578:	18 95       	reti

0000757a <__vector_37>:
    757a:	1f 92       	push	r1
    757c:	0f 92       	push	r0
    757e:	0f b6       	in	r0, 0x3f	; 63
    7580:	0f 92       	push	r0
    7582:	0b b6       	in	r0, 0x3b	; 59
    7584:	0f 92       	push	r0
    7586:	11 24       	eor	r1, r1
    7588:	2f 93       	push	r18
    758a:	3f 93       	push	r19
    758c:	4f 93       	push	r20
    758e:	5f 93       	push	r21
    7590:	6f 93       	push	r22
    7592:	7f 93       	push	r23
    7594:	8f 93       	push	r24
    7596:	9f 93       	push	r25
    7598:	af 93       	push	r26
    759a:	bf 93       	push	r27
    759c:	ef 93       	push	r30
    759e:	ff 93       	push	r31
    75a0:	8e ec       	ldi	r24, 0xCE	; 206
    75a2:	90 e0       	ldi	r25, 0x00	; 0
    75a4:	0e 94 7f 35 	call	0x6afe	; 0x6afe <Modbus_TX>
    75a8:	ff 91       	pop	r31
    75aa:	ef 91       	pop	r30
    75ac:	bf 91       	pop	r27
    75ae:	af 91       	pop	r26
    75b0:	9f 91       	pop	r25
    75b2:	8f 91       	pop	r24
    75b4:	7f 91       	pop	r23
    75b6:	6f 91       	pop	r22
    75b8:	5f 91       	pop	r21
    75ba:	4f 91       	pop	r20
    75bc:	3f 91       	pop	r19
    75be:	2f 91       	pop	r18
    75c0:	0f 90       	pop	r0
    75c2:	0b be       	out	0x3b, r0	; 59
    75c4:	0f 90       	pop	r0
    75c6:	0f be       	out	0x3f, r0	; 63
    75c8:	0f 90       	pop	r0
    75ca:	1f 90       	pop	r1
    75cc:	18 95       	reti

000075ce <__vector_52>:

		// USART2 - PORT2 (only GSM)
		#ifdef GSM
			#ifndef SIM300DZ
				ISR(USART2_UDRE_vect) {GSM_DRE();}
    75ce:	1f 92       	push	r1
    75d0:	0f 92       	push	r0
    75d2:	0f b6       	in	r0, 0x3f	; 63
    75d4:	0f 92       	push	r0
    75d6:	0b b6       	in	r0, 0x3b	; 59
    75d8:	0f 92       	push	r0
    75da:	11 24       	eor	r1, r1
    75dc:	2f 93       	push	r18
    75de:	3f 93       	push	r19
    75e0:	4f 93       	push	r20
    75e2:	5f 93       	push	r21
    75e4:	6f 93       	push	r22
    75e6:	7f 93       	push	r23
    75e8:	8f 93       	push	r24
    75ea:	9f 93       	push	r25
    75ec:	af 93       	push	r26
    75ee:	bf 93       	push	r27
    75f0:	ef 93       	push	r30
    75f2:	ff 93       	push	r31
    75f4:	0e 94 be 39 	call	0x737c	; 0x737c <GSM_DRE>
    75f8:	ff 91       	pop	r31
    75fa:	ef 91       	pop	r30
    75fc:	bf 91       	pop	r27
    75fe:	af 91       	pop	r26
    7600:	9f 91       	pop	r25
    7602:	8f 91       	pop	r24
    7604:	7f 91       	pop	r23
    7606:	6f 91       	pop	r22
    7608:	5f 91       	pop	r21
    760a:	4f 91       	pop	r20
    760c:	3f 91       	pop	r19
    760e:	2f 91       	pop	r18
    7610:	0f 90       	pop	r0
    7612:	0b be       	out	0x3b, r0	; 59
    7614:	0f 90       	pop	r0
    7616:	0f be       	out	0x3f, r0	; 63
    7618:	0f 90       	pop	r0
    761a:	1f 90       	pop	r1
    761c:	18 95       	reti

0000761e <__vector_53>:
			#endif
			ISR(USART2_TX_vect) {GSM_TX();}
    761e:	1f 92       	push	r1
    7620:	0f 92       	push	r0
    7622:	0f b6       	in	r0, 0x3f	; 63
    7624:	0f 92       	push	r0
    7626:	0b b6       	in	r0, 0x3b	; 59
    7628:	0f 92       	push	r0
    762a:	11 24       	eor	r1, r1
    762c:	2f 93       	push	r18
    762e:	3f 93       	push	r19
    7630:	4f 93       	push	r20
    7632:	5f 93       	push	r21
    7634:	6f 93       	push	r22
    7636:	7f 93       	push	r23
    7638:	8f 93       	push	r24
    763a:	9f 93       	push	r25
    763c:	af 93       	push	r26
    763e:	bf 93       	push	r27
    7640:	ef 93       	push	r30
    7642:	ff 93       	push	r31
    7644:	0e 94 d6 39 	call	0x73ac	; 0x73ac <GSM_TX>
    7648:	ff 91       	pop	r31
    764a:	ef 91       	pop	r30
    764c:	bf 91       	pop	r27
    764e:	af 91       	pop	r26
    7650:	9f 91       	pop	r25
    7652:	8f 91       	pop	r24
    7654:	7f 91       	pop	r23
    7656:	6f 91       	pop	r22
    7658:	5f 91       	pop	r21
    765a:	4f 91       	pop	r20
    765c:	3f 91       	pop	r19
    765e:	2f 91       	pop	r18
    7660:	0f 90       	pop	r0
    7662:	0b be       	out	0x3b, r0	; 59
    7664:	0f 90       	pop	r0
    7666:	0f be       	out	0x3f, r0	; 63
    7668:	0f 90       	pop	r0
    766a:	1f 90       	pop	r1
    766c:	18 95       	reti

0000766e <__vector_51>:
			ISR(USART2_RX_vect) {GSM_RX();}
    766e:	1f 92       	push	r1
    7670:	0f 92       	push	r0
    7672:	0f b6       	in	r0, 0x3f	; 63
    7674:	0f 92       	push	r0
    7676:	0b b6       	in	r0, 0x3b	; 59
    7678:	0f 92       	push	r0
    767a:	11 24       	eor	r1, r1
    767c:	2f 93       	push	r18
    767e:	3f 93       	push	r19
    7680:	4f 93       	push	r20
    7682:	5f 93       	push	r21
    7684:	6f 93       	push	r22
    7686:	7f 93       	push	r23
    7688:	8f 93       	push	r24
    768a:	9f 93       	push	r25
    768c:	af 93       	push	r26
    768e:	bf 93       	push	r27
    7690:	ef 93       	push	r30
    7692:	ff 93       	push	r31
    7694:	0e 94 68 39 	call	0x72d0	; 0x72d0 <GSM_RX>
    7698:	ff 91       	pop	r31
    769a:	ef 91       	pop	r30
    769c:	bf 91       	pop	r27
    769e:	af 91       	pop	r26
    76a0:	9f 91       	pop	r25
    76a2:	8f 91       	pop	r24
    76a4:	7f 91       	pop	r23
    76a6:	6f 91       	pop	r22
    76a8:	5f 91       	pop	r21
    76aa:	4f 91       	pop	r20
    76ac:	3f 91       	pop	r19
    76ae:	2f 91       	pop	r18
    76b0:	0f 90       	pop	r0
    76b2:	0b be       	out	0x3b, r0	; 59
    76b4:	0f 90       	pop	r0
    76b6:	0f be       	out	0x3f, r0	; 63
    76b8:	0f 90       	pop	r0
    76ba:	1f 90       	pop	r1
    76bc:	18 95       	reti

000076be <KeypadInit>:
		for (uint8_t str=0; str<sizeof(KeyStr); str++) {
			uint8_t KS = prb(KeyStr+str);
			DDR_Key &=~KS;
			PortKey |=KS;
		}*/
		DDR_KeyROW1 |= KeyROW1;
    76be:	81 9a       	sbi	0x10, 1	; 16
		DDR_KeyROW2 |= KeyROW2;
    76c0:	80 9a       	sbi	0x10, 0	; 16
		PortKeyROW1 |= KeyROW1;
    76c2:	89 9a       	sbi	0x11, 1	; 17
		PortKeyROW2 |= KeyROW2;
    76c4:	88 9a       	sbi	0x11, 0	; 17
		
		DDR_KeySTR1 &= ~KeySTR1;
    76c6:	85 98       	cbi	0x10, 5	; 16
		DDR_KeySTR2 &= ~KeySTR2;
    76c8:	84 98       	cbi	0x10, 4	; 16
		DDR_KeySTR3 &= ~KeySTR3;
    76ca:	82 98       	cbi	0x10, 2	; 16
		PortKeySTR1 |= KeySTR1;
    76cc:	8d 9a       	sbi	0x11, 5	; 17
		PortKeySTR2 |= KeySTR2;
    76ce:	8c 9a       	sbi	0x11, 4	; 17
		PortKeySTR3 |= KeySTR3;
    76d0:	8a 9a       	sbi	0x11, 2	; 17
}

uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    76d2:	80 91 cf 02 	lds	r24, 0x02CF
	VacantTimer8Sys += n;
    76d6:	8f 5f       	subi	r24, 0xFF	; 255
    76d8:	80 93 cf 02 	sts	0x02CF, r24
    76dc:	81 50       	subi	r24, 0x01	; 1
		PORTJ.DIRCLR = (1<<7);
		for (uint8_t str=1; str<sizeof(KeyStr); str++)
			PORTK.DIRCLR = prb(KeyStr+str);
		PORTJ.PIN7CTRL = PORTK.PIN0CTRL = PORTK.PIN1CTRL = PORTK.PIN2CTRL = PORTK.PIN3CTRL = PORT_OPC_PULLUP_gc;
	#endif
	TD_Keypad = Timer8SysAlloc(1);
    76de:	80 93 f1 04 	sts	0x04F1, r24
}
    76e2:	08 95       	ret

000076e4 <KeypadIn>:
	return KeyPressedNonFilter = Key;
}
// ~~~~~~~~~~~
uint8_t
KeypadIn(void)
{
    76e4:	0f 93       	push	r16
    76e6:	1f 93       	push	r17
			}
		}
		RowOff(KR);
	}*/

	cli(); PortKeyROW1 &= ~KeyROW1; sei();
    76e8:	f8 94       	cli
    76ea:	89 98       	cbi	0x11, 1	; 17
    76ec:	78 94       	sei
    76ee:	85 e3       	ldi	r24, 0x35	; 53
    76f0:	8a 95       	dec	r24
    76f2:	f1 f7       	brne	.-4      	; 0x76f0 <KeypadIn+0xc>
	_delay_us(10);		// By trial
	if(!(PIN_KeySTR1 & (KeySTR1))){ Key=2; PresKeysQuant++;} 
    76f4:	7d 99       	sbic	0x0f, 5	; 15
    76f6:	38 c0       	rjmp	.+112    	; 0x7768 <KeypadIn+0x84>
    76f8:	91 e0       	ldi	r25, 0x01	; 1
    76fa:	02 e0       	ldi	r16, 0x02	; 2
	if(!(PIN_KeySTR2 & (KeySTR2))){ Key=6; PresKeysQuant++;} 
    76fc:	7c 99       	sbic	0x0f, 4	; 15
    76fe:	02 c0       	rjmp	.+4      	; 0x7704 <KeypadIn+0x20>
    7700:	9f 5f       	subi	r25, 0xFF	; 255
    7702:	06 e0       	ldi	r16, 0x06	; 6
	if(!(PIN_KeySTR3 & (KeySTR3))){ Key=4; PresKeysQuant++;} 
    7704:	7a 99       	sbic	0x0f, 2	; 15
    7706:	02 c0       	rjmp	.+4      	; 0x770c <KeypadIn+0x28>
    7708:	9f 5f       	subi	r25, 0xFF	; 255
    770a:	04 e0       	ldi	r16, 0x04	; 4
	cli(); PortKeyROW1 |= KeyROW1; sei();	
    770c:	f8 94       	cli
    770e:	89 9a       	sbi	0x11, 1	; 17
    7710:	78 94       	sei

	cli(); PortKeyROW2 &= ~KeyROW2; sei();
    7712:	f8 94       	cli
    7714:	88 98       	cbi	0x11, 0	; 17
    7716:	78 94       	sei
    7718:	85 e3       	ldi	r24, 0x35	; 53
    771a:	8a 95       	dec	r24
    771c:	f1 f7       	brne	.-4      	; 0x771a <KeypadIn+0x36>
	_delay_us(10);		// By trial
	if(!(PIN_KeySTR1 & (KeySTR1))){ Key=1; PresKeysQuant++;}
    771e:	7d 99       	sbic	0x0f, 5	; 15
    7720:	02 c0       	rjmp	.+4      	; 0x7726 <KeypadIn+0x42>
    7722:	9f 5f       	subi	r25, 0xFF	; 255
    7724:	01 e0       	ldi	r16, 0x01	; 1
	if(!(PIN_KeySTR2 & (KeySTR2))){ Key=5; PresKeysQuant++;}
    7726:	7c 99       	sbic	0x0f, 4	; 15
    7728:	02 c0       	rjmp	.+4      	; 0x772e <KeypadIn+0x4a>
    772a:	9f 5f       	subi	r25, 0xFF	; 255
    772c:	05 e0       	ldi	r16, 0x05	; 5
	if(!(PIN_KeySTR3 & (KeySTR3))){ Key=3; PresKeysQuant++;}
    772e:	7a 99       	sbic	0x0f, 2	; 15
    7730:	02 c0       	rjmp	.+4      	; 0x7736 <KeypadIn+0x52>
    7732:	9f 5f       	subi	r25, 0xFF	; 255
    7734:	03 e0       	ldi	r16, 0x03	; 3
	cli(); PortKeyROW2 |= KeyROW2; sei();
    7736:	f8 94       	cli
    7738:	88 9a       	sbi	0x11, 0	; 17
    773a:	78 94       	sei
	if(PresKeysQuant!=1) Key = 0;
    773c:	91 30       	cpi	r25, 0x01	; 1
    773e:	09 f4       	brne	.+2      	; 0x7742 <KeypadIn+0x5e>
    7740:	4a c0       	rjmp	.+148    	; 0x77d6 <KeypadIn+0xf2>

	return KeyPressedNonFilter = Key;
    7742:	10 92 c9 08 	sts	0x08C9, r1
    7746:	00 e0       	ldi	r16, 0x00	; 0
{
	static uint8_t PrevKey;
	uint8_t KeyResult = 0;
	uint8_t Key = KeypadScan();	//   
	if(Key) KeyPressedCounter++;
	if(Key != PrevKey){			//     -   
    7748:	80 91 e3 02 	lds	r24, 0x02E3
    774c:	80 17       	cp	r24, r16
    774e:	11 f0       	breq	.+4      	; 0x7754 <KeypadIn+0x70>
		PrevKey = 0;
    7750:	10 92 e3 02 	sts	0x02E3, r1
	}
	
	if (Timer8Stopp(TD_Keypad)) {
    7754:	10 91 f1 04 	lds	r17, 0x04F1
    7758:	81 2f       	mov	r24, r17
    775a:	0e 94 e3 1b 	call	0x37c6	; 0x37c6 <Timer8Stopp>
    775e:	88 23       	and	r24, r24
    7760:	31 f4       	brne	.+12     	; 0x776e <KeypadIn+0x8a>
					for(I=0;I<=(KeyQuantity/8);I++) *((uint8_t*)RKEY+I) = 0;
				}
		#endif
	}
	return KeyResult;
}
    7762:	1f 91       	pop	r17
    7764:	0f 91       	pop	r16
    7766:	08 95       	ret
		RowOff(KR);
	}*/

	cli(); PortKeyROW1 &= ~KeyROW1; sei();
	_delay_us(10);		// By trial
	if(!(PIN_KeySTR1 & (KeySTR1))){ Key=2; PresKeysQuant++;} 
    7768:	90 e0       	ldi	r25, 0x00	; 0
    776a:	00 e0       	ldi	r16, 0x00	; 0
    776c:	c7 cf       	rjmp	.-114    	; 0x76fc <KeypadIn+0x18>
	if(Key != PrevKey){			//     -   
		PrevKey = 0;
	}
	
	if (Timer8Stopp(TD_Keypad)) {
		StartTimer8(TD_Keypad, 6);	// By trial keystroke time == 70-180 ms
    776e:	81 2f       	mov	r24, r17
    7770:	66 e0       	ldi	r22, 0x06	; 6
    7772:	0e 94 8f 1a 	call	0x351e	; 0x351e <StartTimer8>
		if (Key != PrevKey) {
    7776:	80 91 e3 02 	lds	r24, 0x02E3
    777a:	80 17       	cp	r24, r16
    777c:	09 f4       	brne	.+2      	; 0x7780 <KeypadIn+0x9c>
    777e:	44 c0       	rjmp	.+136    	; 0x7808 <KeypadIn+0x124>
				PrevKey = Key;
    7780:	00 93 e3 02 	sts	0x02E3, r16
				Key = 0;
				KeyStroke = 0;
    7784:	10 92 f0 04 	sts	0x04F0, r1

		#ifdef RKEY
			#ifdef QslRD
				if(!*(uint8_t*)RNUM)
			#endif
				if (KeyResult==0) {
    7788:	40 e0       	ldi	r20, 0x00	; 0
    778a:	50 e0       	ldi	r21, 0x00	; 0
					uint8_t I = 0;
					while (1<<(I++ & 0b00000111) != *((uint8_t*)RKEY+(I>>3)) && I<=KeyQuantity);
    778c:	a1 e0       	ldi	r26, 0x01	; 1
    778e:	b0 e0       	ldi	r27, 0x00	; 0

		#ifdef RKEY
			#ifdef QslRD
				if(!*(uint8_t*)RNUM)
			#endif
				if (KeyResult==0) {
    7790:	e4 2f       	mov	r30, r20
    7792:	64 2f       	mov	r22, r20
    7794:	6f 5f       	subi	r22, 0xFF	; 255
					uint8_t I = 0;
					while (1<<(I++ & 0b00000111) != *((uint8_t*)RKEY+(I>>3)) && I<=KeyQuantity);
    7796:	9a 01       	movw	r18, r20
    7798:	27 70       	andi	r18, 0x07	; 7
    779a:	30 70       	andi	r19, 0x00	; 0
    779c:	cd 01       	movw	r24, r26
    779e:	02 c0       	rjmp	.+4      	; 0x77a4 <KeypadIn+0xc0>
    77a0:	88 0f       	add	r24, r24
    77a2:	99 1f       	adc	r25, r25
    77a4:	2a 95       	dec	r18
    77a6:	e2 f7       	brpl	.-8      	; 0x77a0 <KeypadIn+0xbc>
    77a8:	9c 01       	movw	r18, r24
    77aa:	e6 95       	lsr	r30
    77ac:	e6 95       	lsr	r30
    77ae:	e6 95       	lsr	r30
    77b0:	f0 e0       	ldi	r31, 0x00	; 0
    77b2:	e7 58       	subi	r30, 0x87	; 135
    77b4:	f8 4f       	sbci	r31, 0xF8	; 248
    77b6:	80 81       	ld	r24, Z
    77b8:	90 e0       	ldi	r25, 0x00	; 0
    77ba:	28 17       	cp	r18, r24
    77bc:	39 07       	cpc	r19, r25
    77be:	b1 f1       	breq	.+108    	; 0x782c <KeypadIn+0x148>
    77c0:	4f 5f       	subi	r20, 0xFF	; 255
    77c2:	5f 4f       	sbci	r21, 0xFF	; 255
    77c4:	47 30       	cpi	r20, 0x07	; 7
    77c6:	51 05       	cpc	r21, r1
    77c8:	19 f7       	brne	.-58     	; 0x7790 <KeypadIn+0xac>
					if (I<=KeyQuantity)
    77ca:	80 e0       	ldi	r24, 0x00	; 0
						KeyResult = I;
					for(I=0;I<=(KeyQuantity/8);I++) *((uint8_t*)RKEY+I) = 0;
    77cc:	10 92 79 07 	sts	0x0779, r1
				}
		#endif
	}
	return KeyResult;
}
    77d0:	1f 91       	pop	r17
    77d2:	0f 91       	pop	r16
    77d4:	08 95       	ret
	if(!(PIN_KeySTR2 & (KeySTR2))){ Key=5; PresKeysQuant++;}
	if(!(PIN_KeySTR3 & (KeySTR3))){ Key=3; PresKeysQuant++;}
	cli(); PortKeyROW2 |= KeyROW2; sei();
	if(PresKeysQuant!=1) Key = 0;

	return KeyPressedNonFilter = Key;
    77d6:	00 93 c9 08 	sts	0x08C9, r16
KeypadIn(void)
{
	static uint8_t PrevKey;
	uint8_t KeyResult = 0;
	uint8_t Key = KeypadScan();	//   
	if(Key) KeyPressedCounter++;
    77da:	00 23       	and	r16, r16
    77dc:	09 f4       	brne	.+2      	; 0x77e0 <KeypadIn+0xfc>
    77de:	b4 cf       	rjmp	.-152    	; 0x7748 <KeypadIn+0x64>
    77e0:	80 91 f6 06 	lds	r24, 0x06F6
    77e4:	90 91 f7 06 	lds	r25, 0x06F7
    77e8:	a0 91 f8 06 	lds	r26, 0x06F8
    77ec:	b0 91 f9 06 	lds	r27, 0x06F9
    77f0:	01 96       	adiw	r24, 0x01	; 1
    77f2:	a1 1d       	adc	r26, r1
    77f4:	b1 1d       	adc	r27, r1
    77f6:	80 93 f6 06 	sts	0x06F6, r24
    77fa:	90 93 f7 06 	sts	0x06F7, r25
    77fe:	a0 93 f8 06 	sts	0x06F8, r26
    7802:	b0 93 f9 06 	sts	0x06F9, r27
    7806:	a0 cf       	rjmp	.-192    	; 0x7748 <KeypadIn+0x64>
				PrevKey = Key;
				Key = 0;
				KeyStroke = 0;
		}
		else{
			KeyPressed = KeyResult = Key;
    7808:	00 93 6c 07 	sts	0x076C, r16
			if(KeyStroke<0xFF && ++KeyStroke>1 && KeyStroke<=0xF) KeyResult = 0;
    780c:	90 91 f0 04 	lds	r25, 0x04F0
    7810:	9f 3f       	cpi	r25, 0xFF	; 255
    7812:	41 f0       	breq	.+16     	; 0x7824 <KeypadIn+0x140>
    7814:	9f 5f       	subi	r25, 0xFF	; 255
    7816:	90 93 f0 04 	sts	0x04F0, r25
    781a:	92 30       	cpi	r25, 0x02	; 2
    781c:	18 f0       	brcs	.+6      	; 0x7824 <KeypadIn+0x140>
    781e:	90 31       	cpi	r25, 0x10	; 16
    7820:	08 f4       	brcc	.+2      	; 0x7824 <KeypadIn+0x140>
    7822:	b2 cf       	rjmp	.-156    	; 0x7788 <KeypadIn+0xa4>

		#ifdef RKEY
			#ifdef QslRD
				if(!*(uint8_t*)RNUM)
			#endif
				if (KeyResult==0) {
    7824:	88 23       	and	r24, r24
    7826:	09 f0       	breq	.+2      	; 0x782a <KeypadIn+0x146>
    7828:	9c cf       	rjmp	.-200    	; 0x7762 <KeypadIn+0x7e>
    782a:	ae cf       	rjmp	.-164    	; 0x7788 <KeypadIn+0xa4>
					uint8_t I = 0;
					while (1<<(I++ & 0b00000111) != *((uint8_t*)RKEY+(I>>3)) && I<=KeyQuantity);
					if (I<=KeyQuantity)
    782c:	67 30       	cpi	r22, 0x07	; 7
    782e:	68 f6       	brcc	.-102    	; 0x77ca <KeypadIn+0xe6>
    7830:	86 2f       	mov	r24, r22
    7832:	cc cf       	rjmp	.-104    	; 0x77cc <KeypadIn+0xe8>

00007834 <InitBufStr>:
static uint8_t Minus;
// ~~~~~~~~~~~
char BufStr[LCDXSz+1];
uint8_t CurrFieldSize;

void InitBufStr(OutField *Field){
    7834:	e1 ec       	ldi	r30, 0xC1	; 193
    7836:	f5 e0       	ldi	r31, 0x05	; 5
	for(uint8_t i =0; i<LCDXSz; i++) BufStr[i]=' ';
    7838:	80 e2       	ldi	r24, 0x20	; 32
    783a:	81 93       	st	Z+, r24
    783c:	95 e0       	ldi	r25, 0x05	; 5
    783e:	e5 3d       	cpi	r30, 0xD5	; 213
    7840:	f9 07       	cpc	r31, r25
    7842:	d9 f7       	brne	.-10     	; 0x783a <InitBufStr+0x6>
	BufStr[LCDXSz] ='\0';
    7844:	10 82       	st	Z, r1
	CurrFieldSize = 0;
    7846:	10 92 7a 07 	sts	0x077A, r1
	MultiSymbol = 0;
    784a:	10 92 f2 04 	sts	0x04F2, r1
}
    784e:	08 95       	ret

00007850 <EventFunc>:

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    7850:	fc 01       	movw	r30, r24
    7852:	85 91       	lpm	r24, Z+
    7854:	94 91       	lpm	r25, Z+
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
EventFunc(const MenuEvent *Event)
{
	MenuEvent Func = prp(Event);
	if (Func)
    7856:	00 97       	sbiw	r24, 0x00	; 0
    7858:	11 f0       	breq	.+4      	; 0x785e <EventFunc+0xe>
		Func();
    785a:	fc 01       	movw	r30, r24
    785c:	19 95       	eicall
    785e:	08 95       	ret

00007860 <KeyFunc>:
    7860:	fc 01       	movw	r30, r24
    7862:	85 91       	lpm	r24, Z+
    7864:	94 91       	lpm	r25, Z+
// ~~~~~~~~~~~~~~~~~~~~~~~~
static uint8_t
KeyFunc(const MenuKey *Key)
{
	MenuKey Func=prp(Key);
	return Func && Func()==CustomKey;
    7866:	00 97       	sbiw	r24, 0x00	; 0
    7868:	51 f0       	breq	.+20     	; 0x787e <KeyFunc+0x1e>
    786a:	fc 01       	movw	r30, r24
    786c:	19 95       	eicall
    786e:	90 e0       	ldi	r25, 0x00	; 0
    7870:	81 30       	cpi	r24, 0x01	; 1
    7872:	09 f0       	breq	.+2      	; 0x7876 <KeyFunc+0x16>
    7874:	91 e0       	ldi	r25, 0x01	; 1
    7876:	81 e0       	ldi	r24, 0x01	; 1
    7878:	98 27       	eor	r25, r24
}
    787a:	89 2f       	mov	r24, r25
    787c:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~~~
static uint8_t
KeyFunc(const MenuKey *Key)
{
	MenuKey Func=prp(Key);
	return Func && Func()==CustomKey;
    787e:	90 e0       	ldi	r25, 0x00	; 0
}
    7880:	89 2f       	mov	r24, r25
    7882:	08 95       	ret

00007884 <GotoMenu>:

// ~~~~~~~~~~~~~~~~~~~~~
void
GotoMenu(MenuPage *Menu)
{
    7884:	cf 93       	push	r28
    7886:	df 93       	push	r29
    7888:	ec 01       	movw	r28, r24
	EventFunc(&CurrPage->Exit);
    788a:	80 91 d4 02 	lds	r24, 0x02D4
    788e:	90 91 d5 02 	lds	r25, 0x02D5
    7892:	0a 96       	adiw	r24, 0x0a	; 10
    7894:	0e 94 28 3c 	call	0x7850	; 0x7850 <EventFunc>
    7898:	fe 01       	movw	r30, r28
    789a:	34 96       	adiw	r30, 0x04	; 4
    789c:	85 91       	lpm	r24, Z+
    789e:	94 91       	lpm	r25, Z+
	if(prp(&Menu->OutPage))
    78a0:	89 2b       	or	r24, r25
    78a2:	c9 f0       	breq	.+50     	; 0x78d6 <GotoMenu+0x52>
		MenuDepth=0;
    78a4:	10 92 74 07 	sts	0x0774, r1
	else {
		MenuStack[MenuDepth].Page = CurrPage;
		MenuStack[MenuDepth].Line = CurrLine;
		MenuStack[MenuDepth++].LCD = CurrLCD;
	}
	CurrPage = Menu;
    78a8:	d0 93 d5 02 	sts	0x02D5, r29
    78ac:	c0 93 d4 02 	sts	0x02D4, r28

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    78b0:	23 96       	adiw	r28, 0x03	; 3
    78b2:	fe 01       	movw	r30, r28
    78b4:	84 91       	lpm	r24, Z+
	CurrLine = CurrLCD = GetFix();
    78b6:	80 93 a0 08 	sts	0x08A0, r24
    78ba:	80 93 83 07 	sts	0x0783, r24
	CurrField = CurrPos = NullPos;
    78be:	8f ef       	ldi	r24, 0xFF	; 255
    78c0:	80 93 d7 02 	sts	0x02D7, r24
    78c4:	80 93 d6 02 	sts	0x02D6, r24
	EventFunc(&CurrPage->Load);
    78c8:	ce 01       	movw	r24, r28
    78ca:	03 96       	adiw	r24, 0x03	; 3
    78cc:	0e 94 28 3c 	call	0x7850	; 0x7850 <EventFunc>
}
    78d0:	df 91       	pop	r29
    78d2:	cf 91       	pop	r28
    78d4:	08 95       	ret
{
	EventFunc(&CurrPage->Exit);
	if(prp(&Menu->OutPage))
		MenuDepth=0;
	else {
		MenuStack[MenuDepth].Page = CurrPage;
    78d6:	20 91 74 07 	lds	r18, 0x0774
    78da:	e2 2f       	mov	r30, r18
    78dc:	f0 e0       	ldi	r31, 0x00	; 0
    78de:	ee 0f       	add	r30, r30
    78e0:	ff 1f       	adc	r31, r31
    78e2:	ee 0f       	add	r30, r30
    78e4:	ff 1f       	adc	r31, r31
    78e6:	df 01       	movw	r26, r30
    78e8:	af 55       	subi	r26, 0x5F	; 95
    78ea:	b7 4f       	sbci	r27, 0xF7	; 247
    78ec:	80 91 d4 02 	lds	r24, 0x02D4
    78f0:	90 91 d5 02 	lds	r25, 0x02D5
    78f4:	11 96       	adiw	r26, 0x01	; 1
    78f6:	9c 93       	st	X, r25
    78f8:	8e 93       	st	-X, r24
		MenuStack[MenuDepth].Line = CurrLine;
    78fa:	80 91 83 07 	lds	r24, 0x0783
    78fe:	13 96       	adiw	r26, 0x03	; 3
    7900:	8c 93       	st	X, r24
		MenuStack[MenuDepth++].LCD = CurrLCD;
    7902:	ed 55       	subi	r30, 0x5D	; 93
    7904:	f7 4f       	sbci	r31, 0xF7	; 247
    7906:	80 91 a0 08 	lds	r24, 0x08A0
    790a:	80 83       	st	Z, r24
    790c:	2f 5f       	subi	r18, 0xFF	; 255
    790e:	20 93 74 07 	sts	0x0774, r18
    7912:	ca cf       	rjmp	.-108    	; 0x78a8 <GotoMenu+0x24>

00007914 <HideMsg>:

// ~~~~~~~~~~
uint8_t
HideMsg(void)
{
	if (CurrMsg) {
    7914:	80 91 f3 04 	lds	r24, 0x04F3
    7918:	90 91 f4 04 	lds	r25, 0x04F4
    791c:	00 97       	sbiw	r24, 0x00	; 0
    791e:	51 f0       	breq	.+20     	; 0x7934 <HideMsg+0x20>
		EventFunc(&CurrMsg->Exit);
    7920:	80 5a       	subi	r24, 0xA0	; 160
    7922:	9f 4f       	sbci	r25, 0xFF	; 255
    7924:	0e 94 28 3c 	call	0x7850	; 0x7850 <EventFunc>
		CurrMsg = NULL;
    7928:	10 92 f4 04 	sts	0x04F4, r1
    792c:	10 92 f3 04 	sts	0x04F3, r1
    7930:	81 e0       	ldi	r24, 0x01	; 1
		return 1;
	}
	else
		return 0;
}
    7932:	08 95       	ret

// ~~~~~~~~~~
uint8_t
HideMsg(void)
{
	if (CurrMsg) {
    7934:	80 e0       	ldi	r24, 0x00	; 0
    7936:	08 95       	ret

00007938 <ShowMsg>:
}

// ~~~~~~~~~~~~~~~~~~
void
ShowMsg(MsgPage *Msg)
{
    7938:	0f 93       	push	r16
    793a:	1f 93       	push	r17
    793c:	8c 01       	movw	r16, r24
	HideMsg();
    793e:	0e 94 8a 3c 	call	0x7914	; 0x7914 <HideMsg>
	CurrMsg = Msg;
    7942:	10 93 f4 04 	sts	0x04F4, r17
    7946:	00 93 f3 04 	sts	0x04F3, r16
	EventFunc(&CurrMsg->Load);
    794a:	c8 01       	movw	r24, r16
    794c:	84 5a       	subi	r24, 0xA4	; 164
    794e:	9f 4f       	sbci	r25, 0xFF	; 255
    7950:	0e 94 28 3c 	call	0x7850	; 0x7850 <EventFunc>
}
    7954:	1f 91       	pop	r17
    7956:	0f 91       	pop	r16
    7958:	08 95       	ret

0000795a <MenuInit>:

// ~~~~~~~~~~~
void
MenuInit(void)
{
	CurrLCD = CurrLine = GetFix();
    795a:	e0 91 d4 02 	lds	r30, 0x02D4
    795e:	f0 91 d5 02 	lds	r31, 0x02D5
    7962:	33 96       	adiw	r30, 0x03	; 3
    7964:	84 91       	lpm	r24, Z+
    7966:	80 93 83 07 	sts	0x0783, r24
    796a:	80 93 a0 08 	sts	0x08A0, r24
	#ifdef InitMsg
		ShowMsg(&InitMsg);
	#endif
	EventFunc(&CurrPage->Load);
    796e:	cf 01       	movw	r24, r30
    7970:	03 96       	adiw	r24, 0x03	; 3
    7972:	0e 94 28 3c 	call	0x7850	; 0x7850 <EventFunc>
}
    7976:	08 95       	ret

00007978 <PosBlink>:
}

// ~~~~~~~~~~~~~~~~~~~~~
static void
PosBlink(T_Param *Param, char Cursor)
{
    7978:	fc 01       	movw	r30, r24
	CurrX=Param->Pos+Param->Size-CurrPos-(Param->Prec&&CurrPos>=Param->Prec?2:1)-LCD_Buf[Y1];
    797a:	20 81       	ld	r18, Z
    797c:	33 81       	ldd	r19, Z+3	; 0x03
    797e:	90 91 d7 02 	lds	r25, 0x02D7
    7982:	82 81       	ldd	r24, Z+2	; 0x02
    7984:	88 23       	and	r24, r24
    7986:	11 f0       	breq	.+4      	; 0x798c <PosBlink+0x14>
    7988:	98 17       	cp	r25, r24
    798a:	a0 f4       	brcc	.+40     	; 0x79b4 <PosBlink+0x3c>
    798c:	4f ef       	ldi	r20, 0xFF	; 255
    798e:	39 1b       	sub	r19, r25
    7990:	32 0f       	add	r19, r18
    7992:	86 e5       	ldi	r24, 0x56	; 86
    7994:	96 e0       	ldi	r25, 0x06	; 6
    7996:	38 1b       	sub	r19, r24
    7998:	80 91 fd 09 	lds	r24, 0x09FD
    799c:	25 e1       	ldi	r18, 0x15	; 21
    799e:	82 9f       	mul	r24, r18
    79a0:	c0 01       	movw	r24, r0
    79a2:	11 24       	eor	r1, r1
    79a4:	38 1b       	sub	r19, r24
    79a6:	34 0f       	add	r19, r20
    79a8:	30 93 b7 06 	sts	0x06B7, r19
	StrSize=1;
    79ac:	81 e0       	ldi	r24, 0x01	; 1
    79ae:	80 93 aa 06 	sts	0x06AA, r24
}
    79b2:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~~~
static void
PosBlink(T_Param *Param, char Cursor)
{
	CurrX=Param->Pos+Param->Size-CurrPos-(Param->Prec&&CurrPos>=Param->Prec?2:1)-LCD_Buf[Y1];
    79b4:	4e ef       	ldi	r20, 0xFE	; 254
    79b6:	eb cf       	rjmp	.-42     	; 0x798e <PosBlink+0x16>

000079b8 <GetCurrFieldSize>:

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    79b8:	e0 91 d4 02 	lds	r30, 0x02D4
    79bc:	f0 91 d5 02 	lds	r31, 0x02D5
    79c0:	45 91       	lpm	r20, Z+
    79c2:	54 91       	lpm	r21, Z+
}
// ~~~~~~~~~~~~~~~~~~~~~~~
// Return size of CurrField. Use to determine size of Text, EE_Text OutField vars
uint8_t GetCurrFieldSize(void){
	uint8_t Size;
	MenuLine *Line=GetLine+CurrLine;
    79c4:	80 91 83 07 	lds	r24, 0x0783
    79c8:	2b e1       	ldi	r18, 0x1B	; 27
    79ca:	82 9f       	mul	r24, r18
    79cc:	c0 01       	movw	r24, r0
    79ce:	11 24       	eor	r1, r1
    79d0:	48 0f       	add	r20, r24
    79d2:	59 1f       	adc	r21, r25
		while(prc(CurrStr+X)=='}'){
			X++;
			Size++;
		}
		if(Size){
			if(OF_N == CurrField) return Size;
    79d4:	30 91 d6 02 	lds	r19, 0x02D6
    79d8:	90 e0       	ldi	r25, 0x00	; 0
    79da:	20 e0       	ldi	r18, 0x00	; 0

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    79dc:	fa 01       	movw	r30, r20
    79de:	e9 0f       	add	r30, r25
    79e0:	f1 1d       	adc	r31, r1
    79e2:	e4 91       	lpm	r30, Z+
	MenuLine *Line=GetLine+CurrLine;
	PGM_P CurrStr=(PGM_P)(Line->Str);
	uint8_t OF_N = 0;
	for(uint8_t X=0; X<LCDXSz; X++){
		Size = 0;
		while(prc(CurrStr+X)=='}'){
    79e4:	ed 37       	cpi	r30, 0x7D	; 125
    79e6:	71 f4       	brne	.+28     	; 0x7a04 <GetCurrFieldSize+0x4c>
			X++;
			Size++;
		}
		if(Size){
			if(OF_N == CurrField) return Size;
    79e8:	80 e0       	ldi	r24, 0x00	; 0
	PGM_P CurrStr=(PGM_P)(Line->Str);
	uint8_t OF_N = 0;
	for(uint8_t X=0; X<LCDXSz; X++){
		Size = 0;
		while(prc(CurrStr+X)=='}'){
			X++;
    79ea:	9f 5f       	subi	r25, 0xFF	; 255
			Size++;
    79ec:	8f 5f       	subi	r24, 0xFF	; 255
    79ee:	fa 01       	movw	r30, r20
    79f0:	e9 0f       	add	r30, r25
    79f2:	f1 1d       	adc	r31, r1
    79f4:	e4 91       	lpm	r30, Z+
	MenuLine *Line=GetLine+CurrLine;
	PGM_P CurrStr=(PGM_P)(Line->Str);
	uint8_t OF_N = 0;
	for(uint8_t X=0; X<LCDXSz; X++){
		Size = 0;
		while(prc(CurrStr+X)=='}'){
    79f6:	ed 37       	cpi	r30, 0x7D	; 125
    79f8:	c1 f3       	breq	.-16     	; 0x79ea <GetCurrFieldSize+0x32>
			X++;
			Size++;
		}
		if(Size){
    79fa:	88 23       	and	r24, r24
    79fc:	19 f0       	breq	.+6      	; 0x7a04 <GetCurrFieldSize+0x4c>
			if(OF_N == CurrField) return Size;
    79fe:	23 17       	cp	r18, r19
    7a00:	29 f0       	breq	.+10     	; 0x7a0c <GetCurrFieldSize+0x54>
			OF_N++;
    7a02:	2f 5f       	subi	r18, 0xFF	; 255
uint8_t GetCurrFieldSize(void){
	uint8_t Size;
	MenuLine *Line=GetLine+CurrLine;
	PGM_P CurrStr=(PGM_P)(Line->Str);
	uint8_t OF_N = 0;
	for(uint8_t X=0; X<LCDXSz; X++){
    7a04:	9f 5f       	subi	r25, 0xFF	; 255
    7a06:	94 31       	cpi	r25, 0x14	; 20
    7a08:	48 f3       	brcs	.-46     	; 0x79dc <GetCurrFieldSize+0x24>
		Size = 0;
		while(prc(CurrStr+X)=='}'){
    7a0a:	80 e0       	ldi	r24, 0x00	; 0
			if(OF_N == CurrField) return Size;
			OF_N++;
		}
	}
	return 0;
}
    7a0c:	08 95       	ret

00007a0e <Inc>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
static int32_t
Inc(int8_t Dir, uint32_t Buf)
{
    7a0e:	5f 92       	push	r5
    7a10:	6f 92       	push	r6
    7a12:	7f 92       	push	r7
    7a14:	8f 92       	push	r8
    7a16:	9f 92       	push	r9
    7a18:	af 92       	push	r10
    7a1a:	bf 92       	push	r11
    7a1c:	cf 92       	push	r12
    7a1e:	df 92       	push	r13
    7a20:	ef 92       	push	r14
    7a22:	ff 92       	push	r15
    7a24:	0f 93       	push	r16
    7a26:	1f 93       	push	r17
    7a28:	cf 93       	push	r28
    7a2a:	df 93       	push	r29
    7a2c:	58 2e       	mov	r5, r24
    7a2e:	3a 01       	movw	r6, r20
    7a30:	4b 01       	movw	r8, r22
	uint32_t Pos = PowL10(CurrPos);
    7a32:	d0 90 d7 02 	lds	r13, 0x02D7
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
	uint32_t Pow = 1;
	while(Exp--)
    7a36:	dd 20       	and	r13, r13
    7a38:	09 f4       	brne	.+2      	; 0x7a3c <Inc+0x2e>
    7a3a:	5f c0       	rjmp	.+190    	; 0x7afa <Inc+0xec>
    7a3c:	61 e0       	ldi	r22, 0x01	; 1
    7a3e:	e6 2e       	mov	r14, r22
    7a40:	f1 2c       	mov	r15, r1
    7a42:	01 2d       	mov	r16, r1
    7a44:	11 2d       	mov	r17, r1
		Pow *= 10;
    7a46:	c8 01       	movw	r24, r16
    7a48:	b7 01       	movw	r22, r14
    7a4a:	2a e0       	ldi	r18, 0x0A	; 10
    7a4c:	30 e0       	ldi	r19, 0x00	; 0
    7a4e:	40 e0       	ldi	r20, 0x00	; 0
    7a50:	50 e0       	ldi	r21, 0x00	; 0
    7a52:	0e 94 17 82 	call	0x1042e	; 0x1042e <__mulsi3>
    7a56:	7b 01       	movw	r14, r22
    7a58:	8c 01       	movw	r16, r24
    7a5a:	da 94       	dec	r13
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
	uint32_t Pow = 1;
	while(Exp--)
    7a5c:	a1 f7       	brne	.-24     	; 0x7a46 <Inc+0x38>
    7a5e:	5b 01       	movw	r10, r22
    7a60:	6c 01       	movw	r12, r24
	uint8_t Dig=Buf%(Pos*10)/Pos;
	if(Dig==(Dir==1?9:0)) {
    7a62:	81 e0       	ldi	r24, 0x01	; 1
    7a64:	58 16       	cp	r5, r24
    7a66:	09 f4       	brne	.+2      	; 0x7a6a <Inc+0x5c>
    7a68:	45 c0       	rjmp	.+138    	; 0x7af4 <Inc+0xe6>
    7a6a:	c0 e0       	ldi	r28, 0x00	; 0
    7a6c:	d0 e0       	ldi	r29, 0x00	; 0
    7a6e:	c8 01       	movw	r24, r16
    7a70:	b7 01       	movw	r22, r14
    7a72:	2a e0       	ldi	r18, 0x0A	; 10
    7a74:	30 e0       	ldi	r19, 0x00	; 0
    7a76:	40 e0       	ldi	r20, 0x00	; 0
    7a78:	50 e0       	ldi	r21, 0x00	; 0
    7a7a:	0e 94 17 82 	call	0x1042e	; 0x1042e <__mulsi3>
    7a7e:	9b 01       	movw	r18, r22
    7a80:	ac 01       	movw	r20, r24
    7a82:	c4 01       	movw	r24, r8
    7a84:	b3 01       	movw	r22, r6
    7a86:	0e 94 69 82 	call	0x104d2	; 0x104d2 <__udivmodsi4>
    7a8a:	a8 01       	movw	r20, r16
    7a8c:	97 01       	movw	r18, r14
    7a8e:	0e 94 69 82 	call	0x104d2	; 0x104d2 <__udivmodsi4>
    7a92:	30 e0       	ldi	r19, 0x00	; 0
    7a94:	2c 17       	cp	r18, r28
    7a96:	3d 07       	cpc	r19, r29
    7a98:	99 f4       	brne	.+38     	; 0x7ac0 <Inc+0xb2>
			Dir = -Dir;
    7a9a:	51 94       	neg	r5
			Pos *= 9;
    7a9c:	57 01       	movw	r10, r14
    7a9e:	68 01       	movw	r12, r16
    7aa0:	aa 0c       	add	r10, r10
    7aa2:	bb 1c       	adc	r11, r11
    7aa4:	cc 1c       	adc	r12, r12
    7aa6:	dd 1c       	adc	r13, r13
    7aa8:	aa 0c       	add	r10, r10
    7aaa:	bb 1c       	adc	r11, r11
    7aac:	cc 1c       	adc	r12, r12
    7aae:	dd 1c       	adc	r13, r13
    7ab0:	aa 0c       	add	r10, r10
    7ab2:	bb 1c       	adc	r11, r11
    7ab4:	cc 1c       	adc	r12, r12
    7ab6:	dd 1c       	adc	r13, r13
    7ab8:	ae 0c       	add	r10, r14
    7aba:	bf 1c       	adc	r11, r15
    7abc:	c0 1e       	adc	r12, r16
    7abe:	d1 1e       	adc	r13, r17
    7ac0:	65 2d       	mov	r22, r5
    7ac2:	77 27       	eor	r23, r23
    7ac4:	67 fd       	sbrc	r22, 7
    7ac6:	70 95       	com	r23
    7ac8:	87 2f       	mov	r24, r23
    7aca:	97 2f       	mov	r25, r23
    7acc:	a6 01       	movw	r20, r12
    7ace:	95 01       	movw	r18, r10
    7ad0:	0e 94 17 82 	call	0x1042e	; 0x1042e <__mulsi3>
	}
	return Pos*Dir;
}
    7ad4:	df 91       	pop	r29
    7ad6:	cf 91       	pop	r28
    7ad8:	1f 91       	pop	r17
    7ada:	0f 91       	pop	r16
    7adc:	ff 90       	pop	r15
    7ade:	ef 90       	pop	r14
    7ae0:	df 90       	pop	r13
    7ae2:	cf 90       	pop	r12
    7ae4:	bf 90       	pop	r11
    7ae6:	af 90       	pop	r10
    7ae8:	9f 90       	pop	r9
    7aea:	8f 90       	pop	r8
    7aec:	7f 90       	pop	r7
    7aee:	6f 90       	pop	r6
    7af0:	5f 90       	pop	r5
    7af2:	08 95       	ret
static int32_t
Inc(int8_t Dir, uint32_t Buf)
{
	uint32_t Pos = PowL10(CurrPos);
	uint8_t Dig=Buf%(Pos*10)/Pos;
	if(Dig==(Dir==1?9:0)) {
    7af4:	c9 e0       	ldi	r28, 0x09	; 9
    7af6:	d0 e0       	ldi	r29, 0x00	; 0
    7af8:	ba cf       	rjmp	.-140    	; 0x7a6e <Inc+0x60>
    7afa:	e1 e0       	ldi	r30, 0x01	; 1
    7afc:	ee 2e       	mov	r14, r30
    7afe:	f1 2c       	mov	r15, r1
    7b00:	01 2d       	mov	r16, r1
    7b02:	11 2d       	mov	r17, r1
    7b04:	71 e0       	ldi	r23, 0x01	; 1
    7b06:	a7 2e       	mov	r10, r23
    7b08:	b1 2c       	mov	r11, r1
    7b0a:	c1 2c       	mov	r12, r1
    7b0c:	d1 2c       	mov	r13, r1
    7b0e:	a9 cf       	rjmp	.-174    	; 0x7a62 <Inc+0x54>

00007b10 <MenuRight>:

// ~~~~~~~~~~~~
void
MenuRight(void)
{
}
    7b10:	08 95       	ret

00007b12 <MenuLeft>:

// ~~~~~~~~~~~~~
void
MenuLeft(void)
{
}
    7b12:	08 95       	ret

00007b14 <MenuEnter>:

// ~~~~~~~~~~~~
void
MenuEnter(void)
{
}
    7b14:	08 95       	ret

00007b16 <MenuEsc>:

// ~~~~~~~~~~
void
MenuEsc(void)
{
}
    7b16:	08 95       	ret

00007b18 <DI_State>:
} DigInput;

// ~~~~~~~~~~~~~~~~~~
uint8_t
DI_State(uint8_t D_N)
{
    7b18:	28 2f       	mov	r18, r24
    7b1a:	86 95       	lsr	r24
    7b1c:	86 95       	lsr	r24
    7b1e:	86 95       	lsr	r24
    7b20:	ec ef       	ldi	r30, 0xFC	; 252
    7b22:	f6 e0       	ldi	r31, 0x06	; 6
    7b24:	e8 0f       	add	r30, r24
    7b26:	f1 1d       	adc	r31, r1
    7b28:	80 81       	ld	r24, Z
    7b2a:	90 e0       	ldi	r25, 0x00	; 0
    7b2c:	27 70       	andi	r18, 0x07	; 7
    7b2e:	02 c0       	rjmp	.+4      	; 0x7b34 <DI_State+0x1c>
    7b30:	95 95       	asr	r25
    7b32:	87 95       	ror	r24
    7b34:	2a 95       	dec	r18
    7b36:	e2 f7       	brpl	.-8      	; 0x7b30 <DI_State+0x18>
	return (DigInput.State[D_N/8] &(1<<D_N%8)) != 0;
}
    7b38:	81 70       	andi	r24, 0x01	; 1
    7b3a:	08 95       	ret

00007b3c <DI_Front>:

// ~~~~~~~~~~~~~~~~~~
uint8_t
DI_Front(uint8_t D_N)
{
    7b3c:	e8 2f       	mov	r30, r24
	uint8_t Byte=D_N/8, Bit=1<<D_N%8;
    7b3e:	28 2f       	mov	r18, r24
    7b40:	27 70       	andi	r18, 0x07	; 7
    7b42:	81 e0       	ldi	r24, 0x01	; 1
    7b44:	90 e0       	ldi	r25, 0x00	; 0
    7b46:	01 c0       	rjmp	.+2      	; 0x7b4a <DI_Front+0xe>
    7b48:	88 0f       	add	r24, r24
    7b4a:	2a 95       	dec	r18
    7b4c:	ea f7       	brpl	.-6      	; 0x7b48 <DI_Front+0xc>
	uint8_t State = DigInput.State[Byte] &Bit;
    7b4e:	e6 95       	lsr	r30
    7b50:	e6 95       	lsr	r30
    7b52:	e6 95       	lsr	r30
    7b54:	f0 e0       	ldi	r31, 0x00	; 0
    7b56:	e4 50       	subi	r30, 0x04	; 4
    7b58:	f9 4f       	sbci	r31, 0xF9	; 249
    7b5a:	90 81       	ld	r25, Z
    7b5c:	98 23       	and	r25, r24
	return DigInput.StateOld[Byte] &Bit ? State?NoFront:FallFront : State?RiseFront:NoFront;
    7b5e:	23 81       	ldd	r18, Z+3	; 0x03
    7b60:	82 23       	and	r24, r18
    7b62:	21 f0       	breq	.+8      	; 0x7b6c <DI_Front+0x30>
    7b64:	99 23       	and	r25, r25
    7b66:	41 f4       	brne	.+16     	; 0x7b78 <DI_Front+0x3c>
    7b68:	82 e0       	ldi	r24, 0x02	; 2
    7b6a:	08 95       	ret
    7b6c:	89 2f       	mov	r24, r25
    7b6e:	99 23       	and	r25, r25
    7b70:	09 f4       	brne	.+2      	; 0x7b74 <DI_Front+0x38>
}
    7b72:	08 95       	ret
uint8_t
DI_Front(uint8_t D_N)
{
	uint8_t Byte=D_N/8, Bit=1<<D_N%8;
	uint8_t State = DigInput.State[Byte] &Bit;
	return DigInput.StateOld[Byte] &Bit ? State?NoFront:FallFront : State?RiseFront:NoFront;
    7b74:	81 e0       	ldi	r24, 0x01	; 1
}
    7b76:	08 95       	ret
uint8_t
DI_Front(uint8_t D_N)
{
	uint8_t Byte=D_N/8, Bit=1<<D_N%8;
	uint8_t State = DigInput.State[Byte] &Bit;
	return DigInput.StateOld[Byte] &Bit ? State?NoFront:FallFront : State?RiseFront:NoFront;
    7b78:	80 e0       	ldi	r24, 0x00	; 0
    7b7a:	08 95       	ret

00007b7c <DI_Status>:
}

// ~~~~~~~~~~~~~~~~~~~
uint8_t
DI_Status(uint8_t D_N)
{
    7b7c:	28 2f       	mov	r18, r24
    7b7e:	86 95       	lsr	r24
    7b80:	86 95       	lsr	r24
    7b82:	86 95       	lsr	r24
    7b84:	ec ef       	ldi	r30, 0xFC	; 252
    7b86:	f6 e0       	ldi	r31, 0x06	; 6
    7b88:	e8 0f       	add	r30, r24
    7b8a:	f1 1d       	adc	r31, r1
    7b8c:	86 81       	ldd	r24, Z+6	; 0x06
    7b8e:	90 e0       	ldi	r25, 0x00	; 0
    7b90:	27 70       	andi	r18, 0x07	; 7
    7b92:	02 c0       	rjmp	.+4      	; 0x7b98 <DI_Status+0x1c>
    7b94:	95 95       	asr	r25
    7b96:	87 95       	ror	r24
    7b98:	2a 95       	dec	r18
    7b9a:	e2 f7       	brpl	.-8      	; 0x7b94 <DI_Status+0x18>
	return (DigInput.Status[D_N/8] &(1<<D_N%8)) != 0;
}
    7b9c:	81 70       	andi	r24, 0x01	; 1
    7b9e:	08 95       	ret

00007ba0 <DI_Init>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

// ~~~~~~~~~~
void
DI_Init(void)
{
    7ba0:	20 e0       	ldi	r18, 0x00	; 0
    7ba2:	30 e0       	ldi	r19, 0x00	; 0
// ~~~~~~~~~~~~~~~
static void
DI_Init_Hard(void)
{
	for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
		cli();
    7ba4:	f8 94       	cli

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    7ba6:	a9 01       	movw	r20, r18
    7ba8:	44 0f       	add	r20, r20
    7baa:	55 1f       	adc	r21, r21
    7bac:	44 0f       	add	r20, r20
    7bae:	55 1f       	adc	r21, r21
    7bb0:	44 0f       	add	r20, r20
    7bb2:	55 1f       	adc	r21, r21
    7bb4:	ca 01       	movw	r24, r20
    7bb6:	8d 5b       	subi	r24, 0xBD	; 189
    7bb8:	94 4d       	sbci	r25, 0xD4	; 212
    7bba:	fc 01       	movw	r30, r24
    7bbc:	a5 91       	lpm	r26, Z+
    7bbe:	b4 91       	lpm	r27, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    7bc0:	47 5b       	subi	r20, 0xB7	; 183
    7bc2:	54 4d       	sbci	r21, 0xD4	; 212
    7bc4:	fa 01       	movw	r30, r20
    7bc6:	44 91       	lpm	r20, Z+
		*(uint8_t*)prp(&DI_M[D_N].DDR) &=~prb(&DI_M[D_N].P);
    7bc8:	94 2f       	mov	r25, r20
    7bca:	90 95       	com	r25
    7bcc:	8c 91       	ld	r24, X
    7bce:	89 23       	and	r24, r25
    7bd0:	8c 93       	st	X, r24

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    7bd2:	c9 01       	movw	r24, r18
    7bd4:	88 0f       	add	r24, r24
    7bd6:	99 1f       	adc	r25, r25
    7bd8:	88 0f       	add	r24, r24
    7bda:	99 1f       	adc	r25, r25
    7bdc:	88 0f       	add	r24, r24
    7bde:	99 1f       	adc	r25, r25
    7be0:	8b 5b       	subi	r24, 0xBB	; 187
    7be2:	94 4d       	sbci	r25, 0xD4	; 212
    7be4:	fc 01       	movw	r30, r24
    7be6:	a5 91       	lpm	r26, Z+
    7be8:	b4 91       	lpm	r27, Z+
		*(uint8_t*)prp(&DI_M[D_N].PORT) |=prb(&DI_M[D_N].P);
    7bea:	8c 91       	ld	r24, X
    7bec:	84 2b       	or	r24, r20
    7bee:	8c 93       	st	X, r24
		sei();
    7bf0:	78 94       	sei
    7bf2:	2f 5f       	subi	r18, 0xFF	; 255
    7bf4:	3f 4f       	sbci	r19, 0xFF	; 255

// ~~~~~~~~~~~~~~~
static void
DI_Init_Hard(void)
{
	for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
    7bf6:	22 31       	cpi	r18, 0x12	; 18
    7bf8:	31 05       	cpc	r19, r1
    7bfa:	a1 f6       	brne	.-88     	; 0x7ba4 <DI_Init+0x4>
{
	DI_Init_Hard();
	#ifdef HSC_Reg
		HSC_Init();
	#endif
}
    7bfc:	08 95       	ret

00007bfe <DO_State>:
} DigOutput;

// ~~~~~~~~~~~~~~~~~~
uint8_t
DO_State(uint8_t D_N)
{
    7bfe:	90 e0       	ldi	r25, 0x00	; 0
    7c00:	e8 2f       	mov	r30, r24
    7c02:	e6 95       	lsr	r30
    7c04:	e6 95       	lsr	r30
    7c06:	e6 95       	lsr	r30
    7c08:	f0 e0       	ldi	r31, 0x00	; 0
    7c0a:	ed 56       	subi	r30, 0x6D	; 109
    7c0c:	f8 4f       	sbci	r31, 0xF8	; 248
    7c0e:	40 81       	ld	r20, Z
    7c10:	50 e0       	ldi	r21, 0x00	; 0
    7c12:	87 70       	andi	r24, 0x07	; 7
    7c14:	21 e0       	ldi	r18, 0x01	; 1
    7c16:	30 e0       	ldi	r19, 0x00	; 0
    7c18:	02 c0       	rjmp	.+4      	; 0x7c1e <DO_State+0x20>
    7c1a:	22 0f       	add	r18, r18
    7c1c:	33 1f       	adc	r19, r19
    7c1e:	8a 95       	dec	r24
    7c20:	e2 f7       	brpl	.-8      	; 0x7c1a <DO_State+0x1c>
    7c22:	42 23       	and	r20, r18
    7c24:	53 23       	and	r21, r19
    7c26:	14 16       	cp	r1, r20
    7c28:	15 06       	cpc	r1, r21
    7c2a:	0c f4       	brge	.+2      	; 0x7c2e <DO_State+0x30>
    7c2c:	91 e0       	ldi	r25, 0x01	; 1
	return (DigOutput.State[D_N/8] &(1<<D_N%8)) > 0;
}
    7c2e:	89 2f       	mov	r24, r25
    7c30:	08 95       	ret

00007c32 <DO_Front>:

// ~~~~~~~~~~~~~~~~~~
uint8_t
DO_Front(uint8_t D_N)
{
    7c32:	e8 2f       	mov	r30, r24
	uint8_t Byte=D_N/8, Bit=1<<D_N%8;
    7c34:	28 2f       	mov	r18, r24
    7c36:	27 70       	andi	r18, 0x07	; 7
    7c38:	81 e0       	ldi	r24, 0x01	; 1
    7c3a:	90 e0       	ldi	r25, 0x00	; 0
    7c3c:	01 c0       	rjmp	.+2      	; 0x7c40 <DO_Front+0xe>
    7c3e:	88 0f       	add	r24, r24
    7c40:	2a 95       	dec	r18
    7c42:	ea f7       	brpl	.-6      	; 0x7c3e <DO_Front+0xc>
	uint8_t State = DigOutput.State[Byte] &Bit;
    7c44:	e6 95       	lsr	r30
    7c46:	e6 95       	lsr	r30
    7c48:	e6 95       	lsr	r30
    7c4a:	f0 e0       	ldi	r31, 0x00	; 0
    7c4c:	ed 56       	subi	r30, 0x6D	; 109
    7c4e:	f8 4f       	sbci	r31, 0xF8	; 248
    7c50:	90 81       	ld	r25, Z
    7c52:	98 23       	and	r25, r24
	return DigOutput.StateOld[Byte] &Bit ? State?NoFront:FallFront : State?RiseFront:NoFront;
    7c54:	22 81       	ldd	r18, Z+2	; 0x02
    7c56:	82 23       	and	r24, r18
    7c58:	21 f0       	breq	.+8      	; 0x7c62 <DO_Front+0x30>
    7c5a:	99 23       	and	r25, r25
    7c5c:	41 f4       	brne	.+16     	; 0x7c6e <DO_Front+0x3c>
    7c5e:	82 e0       	ldi	r24, 0x02	; 2
    7c60:	08 95       	ret
    7c62:	89 2f       	mov	r24, r25
    7c64:	99 23       	and	r25, r25
    7c66:	09 f4       	brne	.+2      	; 0x7c6a <DO_Front+0x38>
}
    7c68:	08 95       	ret
uint8_t
DO_Front(uint8_t D_N)
{
	uint8_t Byte=D_N/8, Bit=1<<D_N%8;
	uint8_t State = DigOutput.State[Byte] &Bit;
	return DigOutput.StateOld[Byte] &Bit ? State?NoFront:FallFront : State?RiseFront:NoFront;
    7c6a:	81 e0       	ldi	r24, 0x01	; 1
}
    7c6c:	08 95       	ret
uint8_t
DO_Front(uint8_t D_N)
{
	uint8_t Byte=D_N/8, Bit=1<<D_N%8;
	uint8_t State = DigOutput.State[Byte] &Bit;
	return DigOutput.StateOld[Byte] &Bit ? State?NoFront:FallFront : State?RiseFront:NoFront;
    7c6e:	80 e0       	ldi	r24, 0x00	; 0
    7c70:	08 95       	ret

00007c72 <SetDigOut>:

// ~~~~~~~~~~~~~~~~~~~
void
SetDigOut(uint8_t D_N)
{
	DigOutput.Buf[D_N/8] |=(1<<D_N%8);
    7c72:	98 2f       	mov	r25, r24
    7c74:	96 95       	lsr	r25
    7c76:	96 95       	lsr	r25
    7c78:	96 95       	lsr	r25
    7c7a:	e3 e9       	ldi	r30, 0x93	; 147
    7c7c:	f7 e0       	ldi	r31, 0x07	; 7
    7c7e:	e9 0f       	add	r30, r25
    7c80:	f1 1d       	adc	r31, r1
    7c82:	87 70       	andi	r24, 0x07	; 7
    7c84:	21 e0       	ldi	r18, 0x01	; 1
    7c86:	30 e0       	ldi	r19, 0x00	; 0
    7c88:	02 c0       	rjmp	.+4      	; 0x7c8e <SetDigOut+0x1c>
    7c8a:	22 0f       	add	r18, r18
    7c8c:	33 1f       	adc	r19, r19
    7c8e:	8a 95       	dec	r24
    7c90:	e2 f7       	brpl	.-8      	; 0x7c8a <SetDigOut+0x18>
    7c92:	84 81       	ldd	r24, Z+4	; 0x04
    7c94:	82 2b       	or	r24, r18
    7c96:	84 83       	std	Z+4, r24	; 0x04
}
    7c98:	08 95       	ret

00007c9a <ResDigOut>:

// ~~~~~~~~~~~~~~~~~~~
void
ResDigOut(uint8_t D_N)
{
	DigOutput.Buf[D_N/8] &=~(1<<D_N%8);
    7c9a:	98 2f       	mov	r25, r24
    7c9c:	96 95       	lsr	r25
    7c9e:	96 95       	lsr	r25
    7ca0:	96 95       	lsr	r25
    7ca2:	e3 e9       	ldi	r30, 0x93	; 147
    7ca4:	f7 e0       	ldi	r31, 0x07	; 7
    7ca6:	e9 0f       	add	r30, r25
    7ca8:	f1 1d       	adc	r31, r1
    7caa:	87 70       	andi	r24, 0x07	; 7
    7cac:	21 e0       	ldi	r18, 0x01	; 1
    7cae:	30 e0       	ldi	r19, 0x00	; 0
    7cb0:	02 c0       	rjmp	.+4      	; 0x7cb6 <ResDigOut+0x1c>
    7cb2:	22 0f       	add	r18, r18
    7cb4:	33 1f       	adc	r19, r19
    7cb6:	8a 95       	dec	r24
    7cb8:	e2 f7       	brpl	.-8      	; 0x7cb2 <ResDigOut+0x18>
    7cba:	20 95       	com	r18
    7cbc:	84 81       	ldd	r24, Z+4	; 0x04
    7cbe:	28 23       	and	r18, r24
    7cc0:	24 83       	std	Z+4, r18	; 0x04
}
    7cc2:	08 95       	ret

00007cc4 <TogDigOut>:

// ~~~~~~~~~~~~~~~~~~~
void
TogDigOut(uint8_t D_N)
{
	DigOutput.Buf[D_N/8] ^=(1<<D_N%8);
    7cc4:	98 2f       	mov	r25, r24
    7cc6:	96 95       	lsr	r25
    7cc8:	96 95       	lsr	r25
    7cca:	96 95       	lsr	r25
    7ccc:	e3 e9       	ldi	r30, 0x93	; 147
    7cce:	f7 e0       	ldi	r31, 0x07	; 7
    7cd0:	e9 0f       	add	r30, r25
    7cd2:	f1 1d       	adc	r31, r1
    7cd4:	87 70       	andi	r24, 0x07	; 7
    7cd6:	21 e0       	ldi	r18, 0x01	; 1
    7cd8:	30 e0       	ldi	r19, 0x00	; 0
    7cda:	02 c0       	rjmp	.+4      	; 0x7ce0 <TogDigOut+0x1c>
    7cdc:	22 0f       	add	r18, r18
    7cde:	33 1f       	adc	r19, r19
    7ce0:	8a 95       	dec	r24
    7ce2:	e2 f7       	brpl	.-8      	; 0x7cdc <TogDigOut+0x18>
    7ce4:	84 81       	ldd	r24, Z+4	; 0x04
    7ce6:	82 27       	eor	r24, r18
    7ce8:	84 83       	std	Z+4, r24	; 0x04
}
    7cea:	08 95       	ret

00007cec <SetAllDigOut>:

// ~~~~~~~~~~~~~~~
void
SetAllDigOut(void)
{
	for (uint8_t i=0; i<DO_Reg; DigOutput.Buf[i++]=0xFF);
    7cec:	8f ef       	ldi	r24, 0xFF	; 255
    7cee:	80 93 97 07 	sts	0x0797, r24
    7cf2:	80 93 98 07 	sts	0x0798, r24
}
    7cf6:	08 95       	ret

00007cf8 <DO_Enable>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    7cf8:	8f b7       	in	r24, 0x3f	; 63
    7cfa:	80 78       	andi	r24, 0x80	; 128
    7cfc:	80 93 ec 02 	sts	0x02EC, r24
	cli();
    7d00:	f8 94       	cli
void
DO_Enable(void)
{
	#ifdef Enable
		IntOff();
		PortEnable |=Enable;
    7d02:	46 9a       	sbi	0x08, 6	; 8

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    7d04:	88 23       	and	r24, r24
    7d06:	09 f0       	breq	.+2      	; 0x7d0a <DO_Enable+0x12>
		sei();
    7d08:	78 94       	sei
    7d0a:	08 95       	ret

00007d0c <DO_Disable>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    7d0c:	8f b7       	in	r24, 0x3f	; 63
    7d0e:	80 78       	andi	r24, 0x80	; 128
    7d10:	80 93 ec 02 	sts	0x02EC, r24
	cli();
    7d14:	f8 94       	cli
void
DO_Disable()
{
	#ifdef Enable
		IntOff();
		PortEnable &=~Enable;
    7d16:	46 98       	cbi	0x08, 6	; 8

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    7d18:	88 23       	and	r24, r24
    7d1a:	09 f0       	breq	.+2      	; 0x7d1e <DO_Disable+0x12>
		sei();
    7d1c:	78 94       	sei
    7d1e:	08 95       	ret

00007d20 <DigitOut>:

// ~~~~~~~~~~~
void
DigitOut(void)
{
	memcpy(DigOutput.StateOld, DigOutput.State, DO_Reg+DO_Reg_Ext);
    7d20:	90 91 93 07 	lds	r25, 0x0793
    7d24:	80 91 94 07 	lds	r24, 0x0794
    7d28:	80 93 96 07 	sts	0x0796, r24
    7d2c:	90 93 95 07 	sts	0x0795, r25
	memcpy(DigOutput.State, DigOutput.Buf, DO_Reg);
    7d30:	90 91 97 07 	lds	r25, 0x0797
    7d34:	80 91 98 07 	lds	r24, 0x0798
    7d38:	80 93 94 07 	sts	0x0794, r24
    7d3c:	90 93 93 07 	sts	0x0793, r25
    7d40:	20 e1       	ldi	r18, 0x10	; 16
    7d42:	35 e0       	ldi	r19, 0x05	; 5
    7d44:	10 c0       	rjmp	.+32     	; 0x7d66 <DigitOut+0x46>
	uint8_t N = DO_Reg*8;
	while (N) {
		uint8_t D_N = prb(M+--N);
		cli();
		if (DigOutput.State[D_N/8] &(1<<D_N%8))
			PortData  |=Data;
    7d46:	47 9a       	sbi	0x08, 7	; 8
		else
			PortData &=~Data;
		sei();
    7d48:	78 94       	sei
    7d4a:	83 2f       	mov	r24, r19
    7d4c:	8a 95       	dec	r24
    7d4e:	f1 f7       	brne	.-4      	; 0x7d4c <DigitOut+0x2c>
		_delay_us(1);				// 125 ns needs at 5V
		cli();
    7d50:	f8 94       	cli
		PortClock |=Clock;
    7d52:	45 9a       	sbi	0x08, 5	; 8
		sei();
    7d54:	78 94       	sei
    7d56:	83 2f       	mov	r24, r19
    7d58:	8a 95       	dec	r24
    7d5a:	f1 f7       	brne	.-4      	; 0x7d58 <DigitOut+0x38>
		_delay_us(1);				// 200 ns needs at 5V
		cli();
    7d5c:	f8 94       	cli
		PortClock &=~Clock;
    7d5e:	45 98       	cbi	0x08, 5	; 8
		sei();
    7d60:	78 94       	sei
DigitOut_Hard(void)
{
	static prog_uint8_t M[DO_Reg*8] = DO_Map;

	uint8_t N = DO_Reg*8;
	while (N) {
    7d62:	22 23       	and	r18, r18
    7d64:	d1 f0       	breq	.+52     	; 0x7d9a <DigitOut+0x7a>
		uint8_t D_N = prb(M+--N);
    7d66:	21 50       	subi	r18, 0x01	; 1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    7d68:	e2 2f       	mov	r30, r18
    7d6a:	f0 e0       	ldi	r31, 0x00	; 0
    7d6c:	ed 5c       	subi	r30, 0xCD	; 205
    7d6e:	f4 4d       	sbci	r31, 0xD4	; 212
    7d70:	e4 91       	lpm	r30, Z+
		cli();
    7d72:	f8 94       	cli
		if (DigOutput.State[D_N/8] &(1<<D_N%8))
    7d74:	ae 2f       	mov	r26, r30
    7d76:	a6 95       	lsr	r26
    7d78:	a6 95       	lsr	r26
    7d7a:	a6 95       	lsr	r26
    7d7c:	b0 e0       	ldi	r27, 0x00	; 0
    7d7e:	ad 56       	subi	r26, 0x6D	; 109
    7d80:	b8 4f       	sbci	r27, 0xF8	; 248
    7d82:	8c 91       	ld	r24, X
    7d84:	90 e0       	ldi	r25, 0x00	; 0
    7d86:	e7 70       	andi	r30, 0x07	; 7
    7d88:	02 c0       	rjmp	.+4      	; 0x7d8e <DigitOut+0x6e>
    7d8a:	95 95       	asr	r25
    7d8c:	87 95       	ror	r24
    7d8e:	ea 95       	dec	r30
    7d90:	e2 f7       	brpl	.-8      	; 0x7d8a <DigitOut+0x6a>
    7d92:	80 fd       	sbrc	r24, 0
    7d94:	d8 cf       	rjmp	.-80     	; 0x7d46 <DigitOut+0x26>
			PortData  |=Data;
		else
			PortData &=~Data;
    7d96:	47 98       	cbi	0x08, 7	; 8
    7d98:	d7 cf       	rjmp	.-82     	; 0x7d48 <DigitOut+0x28>
		_delay_us(1);				// 200 ns needs at 5V
		cli();
		PortClock &=~Clock;
		sei();
	}
	cli();
    7d9a:	f8 94       	cli
	PortStrobe |=Strobe;
    7d9c:	80 91 05 01 	lds	r24, 0x0105
    7da0:	81 60       	ori	r24, 0x01	; 1
    7da2:	80 93 05 01 	sts	0x0105, r24
	sei();
    7da6:	78 94       	sei
    7da8:	85 e0       	ldi	r24, 0x05	; 5
    7daa:	8a 95       	dec	r24
    7dac:	f1 f7       	brne	.-4      	; 0x7daa <DigitOut+0x8a>
	_delay_us(1);					// 200 ns needs at 5V
	cli();
    7dae:	f8 94       	cli
	PortStrobe &=~Strobe;
    7db0:	80 91 05 01 	lds	r24, 0x0105
    7db4:	8e 7f       	andi	r24, 0xFE	; 254
    7db6:	80 93 05 01 	sts	0x0105, r24
	sei();
    7dba:	78 94       	sei
				DigOutput.State[j] = (DigOutput_Ext)[i];
			(DigOutput_Ext)[i+DO_Reg_Ext] = DigOutput.Buf[j];
			IntOn();
		}
	#endif
}
    7dbc:	08 95       	ret

00007dbe <DO_Init>:

// ~~~~~~~~~~~~~~~
static void
DO_Init_Hard(void)
{
	cli();
    7dbe:	f8 94       	cli
	DDR_Strobe |= Strobe;
    7dc0:	e4 e0       	ldi	r30, 0x04	; 4
    7dc2:	f1 e0       	ldi	r31, 0x01	; 1
    7dc4:	80 81       	ld	r24, Z
    7dc6:	81 60       	ori	r24, 0x01	; 1
    7dc8:	80 83       	st	Z, r24
	DDR_Data |= Data;
    7dca:	3f 9a       	sbi	0x07, 7	; 7
	DDR_Enable |= Enable;
    7dcc:	3e 9a       	sbi	0x07, 6	; 7
	DDR_Clock |=Clock;
    7dce:	3d 9a       	sbi	0x07, 5	; 7
	PortStrobe &=~Strobe;
    7dd0:	e5 e0       	ldi	r30, 0x05	; 5
    7dd2:	f1 e0       	ldi	r31, 0x01	; 1
    7dd4:	80 81       	ld	r24, Z
    7dd6:	8e 7f       	andi	r24, 0xFE	; 254
    7dd8:	80 83       	st	Z, r24
	PortClock &=~Clock;
    7dda:	45 98       	cbi	0x08, 5	; 8
	sei();
    7ddc:	78 94       	sei
// ~~~~~~~~~~
void
DO_Init(void)
{
	DO_Init_Hard();
	DigitOut();		// Clear all
    7dde:	0e 94 90 3e 	call	0x7d20	; 0x7d20 <DigitOut>
	DO_Enable();
    7de2:	0e 94 7c 3e 	call	0x7cf8	; 0x7cf8 <DO_Enable>
}
    7de6:	08 95       	ret

00007de8 <AI_Init>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    7de8:	e0 91 fe 04 	lds	r30, 0x04FE
    7dec:	f0 e0       	ldi	r31, 0x00	; 0
    7dee:	ee 0f       	add	r30, r30
    7df0:	ff 1f       	adc	r31, r31
    7df2:	ed 5d       	subi	r30, 0xDD	; 221
    7df4:	f4 4d       	sbci	r31, 0xD4	; 212
    7df6:	85 91       	lpm	r24, Z+
    7df8:	94 91       	lpm	r25, Z+
// ~~~~~~~~~~~
static void
SetMuxAI(void)
{
	static prog_uint16_t Mux[] = AI_Mux;
	ADMUX = (uint8_t) prw(Mux+AI_N);
    7dfa:	80 93 7c 00 	sts	0x007C, r24
	#ifdef MUX5
		ADCSRB = (uint8_t) (prw(Mux+AI_N)>>8);
    7dfe:	90 93 7b 00 	sts	0x007B, r25
		#ifdef AN_C
			DDR_AN_C |=AN_C;
		#endif
	#endif
	SetMuxAI();
	ADCSRA = (((((1<<ADEN) |(1<<ADSC)) &~(1<<AD_Mode)) |(1<<ADIF)) &~(1<<ADIE)) |(1<<ADPS2) |(1<<ADPS1) |(1<<ADPS0);
    7e02:	87 ed       	ldi	r24, 0xD7	; 215
    7e04:	80 93 7a 00 	sts	0x007A, r24
		}
	#endif
	#ifdef InitAI_10ms
		TD_InnADC = Timer8SysAlloc(AI_Reg);
	#endif
}
    7e08:	08 95       	ret

00007e0a <AnalogIn>:

// ~~~~~~~~~~~
uint8_t
AnalogIn(void)
{
	if (ADCSRA &(1<<ADSC))
    7e0a:	80 91 7a 00 	lds	r24, 0x007A
    7e0e:	86 fd       	sbrc	r24, 6
    7e10:	2c c0       	rjmp	.+88     	; 0x7e6a <AnalogIn+0x60>
		return AI_Reg;
	AnalogInput[AI_N] = ADCL;
    7e12:	50 91 fe 04 	lds	r21, 0x04FE
    7e16:	65 2f       	mov	r22, r21
    7e18:	20 91 78 00 	lds	r18, 0x0078
	AnalogInput[AI_N] |= ADCH<<8;
    7e1c:	40 91 79 00 	lds	r20, 0x0079
    7e20:	e5 2f       	mov	r30, r21
    7e22:	f0 e0       	ldi	r31, 0x00	; 0
    7e24:	ee 0f       	add	r30, r30
    7e26:	ff 1f       	adc	r31, r31
    7e28:	ea 5f       	subi	r30, 0xFA	; 250
    7e2a:	f4 4f       	sbci	r31, 0xF4	; 244
    7e2c:	94 2f       	mov	r25, r20
    7e2e:	80 e0       	ldi	r24, 0x00	; 0
    7e30:	30 e0       	ldi	r19, 0x00	; 0
    7e32:	82 2b       	or	r24, r18
    7e34:	93 2b       	or	r25, r19
    7e36:	91 83       	std	Z+1, r25	; 0x01
    7e38:	80 83       	st	Z, r24
		}
		else
			Chan = AI_Reg;
	#endif

	if (++AI_N == AI_Reg)
    7e3a:	5f 5f       	subi	r21, 0xFF	; 255
    7e3c:	50 93 fe 04 	sts	0x04FE, r21
    7e40:	58 30       	cpi	r21, 0x08	; 8
    7e42:	b1 f0       	breq	.+44     	; 0x7e70 <AnalogIn+0x66>
    7e44:	e5 2f       	mov	r30, r21
    7e46:	f0 e0       	ldi	r31, 0x00	; 0
    7e48:	ee 0f       	add	r30, r30
    7e4a:	ff 1f       	adc	r31, r31
    7e4c:	ed 5d       	subi	r30, 0xDD	; 221
    7e4e:	f4 4d       	sbci	r31, 0xD4	; 212
    7e50:	85 91       	lpm	r24, Z+
    7e52:	94 91       	lpm	r25, Z+
// ~~~~~~~~~~~
static void
SetMuxAI(void)
{
	static prog_uint16_t Mux[] = AI_Mux;
	ADMUX = (uint8_t) prw(Mux+AI_N);
    7e54:	80 93 7c 00 	sts	0x007C, r24
	#ifdef MUX5
		ADCSRB = (uint8_t) (prw(Mux+AI_N)>>8);
    7e58:	90 93 7b 00 	sts	0x007B, r25
	#endif

	if (++AI_N == AI_Reg)
		AI_N = 0;
	SetMuxAI();
	ADCSRA |=(1<<ADSC);
    7e5c:	80 91 7a 00 	lds	r24, 0x007A
    7e60:	80 64       	ori	r24, 0x40	; 64
    7e62:	80 93 7a 00 	sts	0x007A, r24
			IntOn();
		}
	#endif

	return Chan;
}
    7e66:	86 2f       	mov	r24, r22
    7e68:	08 95       	ret

// ~~~~~~~~~~~
uint8_t
AnalogIn(void)
{
	if (ADCSRA &(1<<ADSC))
    7e6a:	68 e0       	ldi	r22, 0x08	; 8
			IntOn();
		}
	#endif

	return Chan;
}
    7e6c:	86 2f       	mov	r24, r22
    7e6e:	08 95       	ret
		else
			Chan = AI_Reg;
	#endif

	if (++AI_N == AI_Reg)
		AI_N = 0;
    7e70:	10 92 fe 04 	sts	0x04FE, r1
    7e74:	50 e0       	ldi	r21, 0x00	; 0
    7e76:	e6 cf       	rjmp	.-52     	; 0x7e44 <AnalogIn+0x3a>

00007e78 <Thermode>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
int16_t
Thermode(uint8_t T_Fami, uint8_t T_Type, uint16_t Code)
{
	if (T_Type==ThermOff)
    7e78:	66 23       	and	r22, r22
    7e7a:	f9 f0       	breq	.+62     	; 0x7eba <Thermode+0x42>
		return Therm_Off_Mark;
	if (T_Fami==Thermis)
    7e7c:	88 23       	and	r24, r24
    7e7e:	91 f4       	brne	.+36     	; 0x7ea4 <Thermode+0x2c>
		switch(T_Type) {
    7e80:	64 30       	cpi	r22, 0x04	; 4
    7e82:	d9 f1       	breq	.+118    	; 0x7efa <Thermode+0x82>
    7e84:	65 30       	cpi	r22, 0x05	; 5
    7e86:	60 f5       	brcc	.+88     	; 0x7ee0 <Thermode+0x68>
    7e88:	62 30       	cpi	r22, 0x02	; 2
    7e8a:	09 f4       	brne	.+2      	; 0x7e8e <Thermode+0x16>
    7e8c:	4b c0       	rjmp	.+150    	; 0x7f24 <Thermode+0xac>
    7e8e:	63 30       	cpi	r22, 0x03	; 3
    7e90:	d8 f5       	brcc	.+118    	; 0x7f08 <Thermode+0x90>
    7e92:	61 30       	cpi	r22, 0x01	; 1
    7e94:	a1 f4       	brne	.+40     	; 0x7ebe <Thermode+0x46>
		case TSM100:
			return ThermCalc(TSM100);
    7e96:	8b ed       	ldi	r24, 0xDB	; 219
    7e98:	99 e2       	ldi	r25, 0x29	; 41
    7e9a:	ba 01       	movw	r22, r20
    7e9c:	0e 94 f1 21 	call	0x43e2	; 0x43e2 <PGM_uBrokLine>
    7ea0:	ac 01       	movw	r20, r24
    7ea2:	0d c0       	rjmp	.+26     	; 0x7ebe <Thermode+0x46>
#endif
		default:
			return Code;
		}
	else	// T_Fami==Thermoc
		switch(T_Type) {
    7ea4:	61 30       	cpi	r22, 0x01	; 1
    7ea6:	69 f0       	breq	.+26     	; 0x7ec2 <Thermode+0x4a>
    7ea8:	62 30       	cpi	r22, 0x02	; 2
    7eaa:	49 f4       	brne	.+18     	; 0x7ebe <Thermode+0x46>
		case TC_K:
			return .1851*Code;
#endif
#if	TerInput==ADC_Input
		case TC_B:
			return ThermCalc(TC_B_);
    7eac:	8f ed       	ldi	r24, 0xDF	; 223
    7eae:	9a e2       	ldi	r25, 0x2A	; 42
    7eb0:	ba 01       	movw	r22, r20
    7eb2:	0e 94 f1 21 	call	0x43e2	; 0x43e2 <PGM_uBrokLine>
    7eb6:	ac 01       	movw	r20, r24
    7eb8:	02 c0       	rjmp	.+4      	; 0x7ebe <Thermode+0x46>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
int16_t
Thermode(uint8_t T_Fami, uint8_t T_Type, uint16_t Code)
{
	if (T_Type==ThermOff)
    7eba:	40 e0       	ldi	r20, 0x00	; 0
    7ebc:	50 e8       	ldi	r21, 0x80	; 128
			return ThermCalc(TC_B_);
#endif
		default:
			return Code;
		}
}
    7ebe:	ca 01       	movw	r24, r20
    7ec0:	08 95       	ret
			return ThermCalc(TC_J_) + InnerTer;
		case TC_L:
			return ThermCalc(TC_L_) + InnerTer;
#else
		case TC_K:
			return .1851*Code;
    7ec2:	ba 01       	movw	r22, r20
    7ec4:	80 e0       	ldi	r24, 0x00	; 0
    7ec6:	90 e0       	ldi	r25, 0x00	; 0
    7ec8:	0e 94 ca 7c 	call	0xf994	; 0xf994 <__floatunsisf>
    7ecc:	2b ed       	ldi	r18, 0xDB	; 219
    7ece:	3a e8       	ldi	r19, 0x8A	; 138
    7ed0:	4d e3       	ldi	r20, 0x3D	; 61
    7ed2:	5e e3       	ldi	r21, 0x3E	; 62
    7ed4:	0e 94 07 7d 	call	0xfa0e	; 0xfa0e <__mulsf3>
    7ed8:	0e 94 9a 81 	call	0x10334	; 0x10334 <__fixsfsi>
    7edc:	ab 01       	movw	r20, r22
    7ede:	ef cf       	rjmp	.-34     	; 0x7ebe <Thermode+0x46>
Thermode(uint8_t T_Fami, uint8_t T_Type, uint16_t Code)
{
	if (T_Type==ThermOff)
		return Therm_Off_Mark;
	if (T_Fami==Thermis)
		switch(T_Type) {
    7ee0:	66 30       	cpi	r22, 0x06	; 6
    7ee2:	39 f1       	breq	.+78     	; 0x7f32 <Thermode+0xba>
    7ee4:	66 30       	cpi	r22, 0x06	; 6
    7ee6:	b8 f0       	brcs	.+46     	; 0x7f16 <Thermode+0x9e>
    7ee8:	67 30       	cpi	r22, 0x07	; 7
    7eea:	49 f7       	brne	.-46     	; 0x7ebe <Thermode+0x46>
			return ThermCalc(Pt100);
#if	TerInput==ADC_Input
		case Gr21:
			return ThermCalc(Gr21);
		case Gr23:
			return ThermCalc(Gr23);
    7eec:	8f eb       	ldi	r24, 0xBF	; 191
    7eee:	9a e2       	ldi	r25, 0x2A	; 42
    7ef0:	ba 01       	movw	r22, r20
    7ef2:	0e 94 f1 21 	call	0x43e2	; 0x43e2 <PGM_uBrokLine>
    7ef6:	ac 01       	movw	r20, r24
    7ef8:	e2 cf       	rjmp	.-60     	; 0x7ebe <Thermode+0x46>
		case TSM50:
			return ThermCalc(TSM50);
		case TSP100:
			return ThermCalc(TSP100);
		case TSP50:
			return ThermCalc(TSP50);
    7efa:	8f e4       	ldi	r24, 0x4F	; 79
    7efc:	9a e2       	ldi	r25, 0x2A	; 42
    7efe:	ba 01       	movw	r22, r20
    7f00:	0e 94 f1 21 	call	0x43e2	; 0x43e2 <PGM_uBrokLine>
    7f04:	ac 01       	movw	r20, r24
    7f06:	db cf       	rjmp	.-74     	; 0x7ebe <Thermode+0x46>
		case TSM100:
			return ThermCalc(TSM100);
		case TSM50:
			return ThermCalc(TSM50);
		case TSP100:
			return ThermCalc(TSP100);
    7f08:	87 e2       	ldi	r24, 0x27	; 39
    7f0a:	9a e2       	ldi	r25, 0x2A	; 42
    7f0c:	ba 01       	movw	r22, r20
    7f0e:	0e 94 f1 21 	call	0x43e2	; 0x43e2 <PGM_uBrokLine>
    7f12:	ac 01       	movw	r20, r24
    7f14:	d4 cf       	rjmp	.-88     	; 0x7ebe <Thermode+0x46>
		case TSP50:
			return ThermCalc(TSP50);
		case Pt100:
			return ThermCalc(Pt100);
    7f16:	83 e7       	ldi	r24, 0x73	; 115
    7f18:	9a e2       	ldi	r25, 0x2A	; 42
    7f1a:	ba 01       	movw	r22, r20
    7f1c:	0e 94 f1 21 	call	0x43e2	; 0x43e2 <PGM_uBrokLine>
    7f20:	ac 01       	movw	r20, r24
    7f22:	cd cf       	rjmp	.-102    	; 0x7ebe <Thermode+0x46>
	if (T_Fami==Thermis)
		switch(T_Type) {
		case TSM100:
			return ThermCalc(TSM100);
		case TSM50:
			return ThermCalc(TSM50);
    7f24:	8b ef       	ldi	r24, 0xFB	; 251
    7f26:	99 e2       	ldi	r25, 0x29	; 41
    7f28:	ba 01       	movw	r22, r20
    7f2a:	0e 94 f1 21 	call	0x43e2	; 0x43e2 <PGM_uBrokLine>
    7f2e:	ac 01       	movw	r20, r24
    7f30:	c6 cf       	rjmp	.-116    	; 0x7ebe <Thermode+0x46>
			return ThermCalc(TSP50);
		case Pt100:
			return ThermCalc(Pt100);
#if	TerInput==ADC_Input
		case Gr21:
			return ThermCalc(Gr21);
    7f32:	8b e9       	ldi	r24, 0x9B	; 155
    7f34:	9a e2       	ldi	r25, 0x2A	; 42
    7f36:	ba 01       	movw	r22, r20
    7f38:	0e 94 f1 21 	call	0x43e2	; 0x43e2 <PGM_uBrokLine>
    7f3c:	ac 01       	movw	r20, r24
    7f3e:	bf cf       	rjmp	.-130    	; 0x7ebe <Thermode+0x46>

00007f40 <ThermExt>:
			IntOff();
			Temperature[TerReg+i] = (Temperature_Ext)[i];
			IntOn();
		}
	#endif
}
    7f40:	08 95       	ret

00007f42 <Therm_ADC_Off>:

// ~~~~~~~~~~~~~~~~
void
Therm_ADC_Off(void)
{
	for (uint8_t i=0; i<TerReg; Temperature[i++]=ADC_Off_Mark);
    7f42:	81 e0       	ldi	r24, 0x01	; 1
    7f44:	90 e8       	ldi	r25, 0x80	; 128
    7f46:	90 93 44 06 	sts	0x0644, r25
    7f4a:	80 93 43 06 	sts	0x0643, r24
    7f4e:	90 93 46 06 	sts	0x0646, r25
    7f52:	80 93 45 06 	sts	0x0645, r24
    7f56:	90 93 48 06 	sts	0x0648, r25
    7f5a:	80 93 47 06 	sts	0x0647, r24
    7f5e:	90 93 4a 06 	sts	0x064A, r25
    7f62:	80 93 49 06 	sts	0x0649, r24
    7f66:	90 93 4c 06 	sts	0x064C, r25
    7f6a:	80 93 4b 06 	sts	0x064B, r24
    7f6e:	90 93 4e 06 	sts	0x064E, r25
    7f72:	80 93 4d 06 	sts	0x064D, r24
}
    7f76:	08 95       	ret

00007f78 <ThermWrong>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
ThermWrong(uint8_t T_Fami, uint8_t T_Type, int16_t Ter)
{
	uint8_t TW = ThermNorm;
	if (T_Type!=ThermOff && T_Type<=prb(MaxThermType+T_Fami)) {
    7f78:	66 23       	and	r22, r22
    7f7a:	31 f1       	breq	.+76     	; 0x7fc8 <ThermWrong+0x50>
    7f7c:	28 2f       	mov	r18, r24
    7f7e:	30 e0       	ldi	r19, 0x00	; 0

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    7f80:	f9 01       	movw	r30, r18
    7f82:	eb 52       	subi	r30, 0x2B	; 43
    7f84:	f6 4d       	sbci	r31, 0xD6	; 214
    7f86:	e4 91       	lpm	r30, Z+
    7f88:	e6 17       	cp	r30, r22
    7f8a:	f0 f0       	brcs	.+60     	; 0x7fc8 <ThermWrong+0x50>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    7f8c:	f9 01       	movw	r30, r18
    7f8e:	ee 0f       	add	r30, r30
    7f90:	ff 1f       	adc	r31, r31
    7f92:	e9 52       	subi	r30, 0x29	; 41
    7f94:	f6 4d       	sbci	r31, 0xD6	; 214
    7f96:	25 91       	lpm	r18, Z+
    7f98:	34 91       	lpm	r19, Z+
		TerLim *T_L = prp(TerLimType+T_Fami);
		if (Ter<(int16_t)prw(&T_L[T_Type].Low))
    7f9a:	86 2f       	mov	r24, r22
    7f9c:	90 e0       	ldi	r25, 0x00	; 0
    7f9e:	88 0f       	add	r24, r24
    7fa0:	99 1f       	adc	r25, r25
    7fa2:	88 0f       	add	r24, r24
    7fa4:	99 1f       	adc	r25, r25
    7fa6:	28 0f       	add	r18, r24
    7fa8:	39 1f       	adc	r19, r25

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    7faa:	f9 01       	movw	r30, r18
    7fac:	85 91       	lpm	r24, Z+
    7fae:	94 91       	lpm	r25, Z+
    7fb0:	48 17       	cp	r20, r24
    7fb2:	59 07       	cpc	r21, r25
    7fb4:	5c f0       	brlt	.+22     	; 0x7fcc <ThermWrong+0x54>
    7fb6:	f9 01       	movw	r30, r18
    7fb8:	32 96       	adiw	r30, 0x02	; 2
    7fba:	85 91       	lpm	r24, Z+
    7fbc:	94 91       	lpm	r25, Z+
			TW = ThermUnder;
		else if(Ter>(int16_t)prw(&T_L[T_Type].Upp))
    7fbe:	84 17       	cp	r24, r20
    7fc0:	95 07       	cpc	r25, r21
    7fc2:	14 f4       	brge	.+4      	; 0x7fc8 <ThermWrong+0x50>
    7fc4:	82 e0       	ldi	r24, 0x02	; 2
    7fc6:	08 95       	ret
    7fc8:	80 e0       	ldi	r24, 0x00	; 0
			TW = ThermOver;
	}
	return TW;
}
    7fca:	08 95       	ret
ThermWrong(uint8_t T_Fami, uint8_t T_Type, int16_t Ter)
{
	uint8_t TW = ThermNorm;
	if (T_Type!=ThermOff && T_Type<=prb(MaxThermType+T_Fami)) {
		TerLim *T_L = prp(TerLimType+T_Fami);
		if (Ter<(int16_t)prw(&T_L[T_Type].Low))
    7fcc:	81 e0       	ldi	r24, 0x01	; 1
    7fce:	08 95       	ret

00007fd0 <Key_MB0_CPT_Clear>:
	{" BAUD: }}}}}bps     ", NULL, F_MB##N##_Baud}																														\
};																																																					\
MenuPage MenuModbus##N = {SetMenu(L_MB##N), 1};

#if Modbus_Qt == 1
	M_Modbus(0)
    7fd0:	80 e0       	ldi	r24, 0x00	; 0
    7fd2:	90 e0       	ldi	r25, 0x00	; 0

// ~~~~~~~~~~~~~~~~~~~~~~~
void
MB_CPT_Clear(uint8_t MB_N)
{
	for (uint8_t i=0; i<8; MB_CPT[MB_N][i++]=0);
    7fd4:	fc 01       	movw	r30, r24
    7fd6:	ee 0f       	add	r30, r30
    7fd8:	ff 1f       	adc	r31, r31
    7fda:	e2 51       	subi	r30, 0x12	; 18
    7fdc:	f7 4f       	sbci	r31, 0xF7	; 247
    7fde:	11 82       	std	Z+1, r1	; 0x01
    7fe0:	10 82       	st	Z, r1
    7fe2:	01 96       	adiw	r24, 0x01	; 1
    7fe4:	88 30       	cpi	r24, 0x08	; 8
    7fe6:	91 05       	cpc	r25, r1
    7fe8:	a9 f7       	brne	.-22     	; 0x7fd4 <Key_MB0_CPT_Clear+0x4>
    7fea:	81 e0       	ldi	r24, 0x01	; 1
    7fec:	08 95       	ret

00007fee <ResetGSMState>:
	#ifdef GSM_DEBUG
		MenuPage MenuGSMConsole;
	#endif

	void ResetGSMState(void){
		GSM_State = GSM_ReStart1;
    7fee:	8a e4       	ldi	r24, 0x4A	; 74
    7ff0:	80 93 b3 06 	sts	0x06B3, r24
	}
    7ff4:	08 95       	ret

00007ff6 <Key_MaxScanCycle_Clear>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
InField F_ScanCycle[] = { {Byte, &ScanCycle} };
InField F_ScanCyclePerSec[] = { {Word, &ScanPerSec} }; 
InField F_MaxScanCycle[] = {{Byte, &MaxScanCycle}};

uint8_t Key_MaxScanCycle_Clear(void) {if(CurrLine==3) MaxScanCycle_Clear(); return StandartKey;}
    7ff6:	80 91 83 07 	lds	r24, 0x0783
    7ffa:	83 30       	cpi	r24, 0x03	; 3
    7ffc:	11 f4       	brne	.+4      	; 0x8002 <Key_MaxScanCycle_Clear+0xc>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
void
MaxScanCycle_Clear(void)
{
	MaxScanCycle = 0;
    7ffe:	10 92 af 06 	sts	0x06AF, r1
    8002:	80 e0       	ldi	r24, 0x00	; 0
    8004:	08 95       	ret

00008006 <ApplInit>:
void
ApplInit(void)
{
	

}
    8006:	08 95       	ret

00008008 <ApplCycle>:
// ~~~~~~~~~~~~
void
ApplCycle(void)
{

}
    8008:	08 95       	ret

0000800a <StartKey>:
uint8_t numOfCheckBallanceRetry=0;

uint8_t Message[3];  // 
uint8_t GSMBusyState=0; // " " 0 -  , 1 -  
void GSM_StartCalling(uint8_t inputN,uint8_t abonentN){
	Message[0]=1;
    800a:	81 e0       	ldi	r24, 0x01	; 1
    800c:	80 93 f2 06 	sts	0x06F2, r24
	Message[1]=inputN;
    8010:	10 92 f3 06 	sts	0x06F3, r1
	Message[2]=abonentN;
    8014:	8c e0       	ldi	r24, 0x0C	; 12
    8016:	80 93 f4 06 	sts	0x06F4, r24
// ~~~~~~~~~~~
void
StartKey(void)
{	
	GSM_StartCalling(0,12);
}
    801a:	08 95       	ret

0000801c <StopKey>:
// ~~~~~~~~~~
void
StopKey(void)
{
	
}
    801c:	08 95       	ret

0000801e <Menu_ConfirmationRest_Enter>:
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	//		   
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	uint8_t Menu_ConfirmationRest_Enter(){

		eeprom_write_byte((uint8_t*)E2END, 0xBB);
    801e:	8f ef       	ldi	r24, 0xFF	; 255
    8020:	9f e0       	ldi	r25, 0x0F	; 15
    8022:	6b eb       	ldi	r22, 0xBB	; 187
    8024:	0e 94 f9 81 	call	0x103f2	; 0x103f2 <__eewr_byte_m2560>
		eeprom_write_byte(&MemCheck_stor.ReprogFlg, 0);
    8028:	8c e3       	ldi	r24, 0x3C	; 60
    802a:	91 e0       	ldi	r25, 0x01	; 1
    802c:	60 e0       	ldi	r22, 0x00	; 0
    802e:	0e 94 f9 81 	call	0x103f2	; 0x103f2 <__eewr_byte_m2560>
    8032:	ff cf       	rjmp	.-2      	; 0x8032 <Menu_ConfirmationRest_Enter+0x14>

00008034 <Menu_ConfirmationSave_Enter>:
	//		   
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	uint8_t Menu_ConfirmationSave_Enter(){

		//  backup-
		eeprom_write_byte((uint8_t*)E2END, 0xAA);
    8034:	8f ef       	ldi	r24, 0xFF	; 255
    8036:	9f e0       	ldi	r25, 0x0F	; 15
    8038:	6a ea       	ldi	r22, 0xAA	; 170
    803a:	0e 94 f9 81 	call	0x103f2	; 0x103f2 <__eewr_byte_m2560>
		eeprom_write_byte(&DateBackUp.Day, Tm_MDay);
    803e:	80 e0       	ldi	r24, 0x00	; 0
    8040:	90 e0       	ldi	r25, 0x00	; 0
    8042:	60 91 17 0b 	lds	r22, 0x0B17
    8046:	0e 94 f9 81 	call	0x103f2	; 0x103f2 <__eewr_byte_m2560>
		eeprom_write_byte(&DateBackUp.Month, Tm_Mon);
    804a:	81 e0       	ldi	r24, 0x01	; 1
    804c:	90 e0       	ldi	r25, 0x00	; 0
    804e:	60 91 85 07 	lds	r22, 0x0785
    8052:	0e 94 f9 81 	call	0x103f2	; 0x103f2 <__eewr_byte_m2560>
		#ifdef M41T56
			eeprom_write_byte(&DateBackUp.Year, Tm_Year);
    8056:	82 e0       	ldi	r24, 0x02	; 2
    8058:	90 e0       	ldi	r25, 0x00	; 0
    805a:	60 91 dc 05 	lds	r22, 0x05DC
    805e:	0e 94 f9 81 	call	0x103f2	; 0x103f2 <__eewr_byte_m2560>
		#else
			eeprom_write_byte(&DateBackUp.Year, erb(&Tm_Year));
		#endif
		eeprom_write_byte(&MemCheck_stor.ReprogFlg, 0);
    8062:	8c e3       	ldi	r24, 0x3C	; 60
    8064:	91 e0       	ldi	r25, 0x01	; 1
    8066:	60 e0       	ldi	r22, 0x00	; 0
    8068:	0e 94 f9 81 	call	0x103f2	; 0x103f2 <__eewr_byte_m2560>
    806c:	ff cf       	rjmp	.-2      	; 0x806c <Menu_ConfirmationSave_Enter+0x38>

0000806e <GSM_SendData>:
	GSMTxSz = Size;
	memcpy(GSM_TxStr, Data_Out, GSMTxSz);
	GSM_SendFirstChar();
}
// ~~~~~~~~~
void GSM_SendData(uint8_t *Data_Out, uint8_t Size){
    806e:	58 2f       	mov	r21, r24
    8070:	79 2f       	mov	r23, r25
	GSMTxSz = Size;
    8072:	60 93 75 07 	sts	0x0775, r22
	memcpy(GSM_TxStr, Data_Out, GSMTxSz);
    8076:	40 91 75 07 	lds	r20, 0x0775
    807a:	22 e0       	ldi	r18, 0x02	; 2
    807c:	3a e0       	ldi	r19, 0x0A	; 10
    807e:	c9 01       	movw	r24, r18
    8080:	65 2f       	mov	r22, r21
    8082:	50 e0       	ldi	r21, 0x00	; 0
    8084:	0e 94 fd 7e 	call	0xfdfa	; 0xfdfa <memcpy>
	GSM_SendFirstChar();
    8088:	0e 94 aa 39 	call	0x7354	; 0x7354 <GSM_SendFirstChar>
}
    808c:	08 95       	ret

0000808e <GSM_AddHeaderSendData>:
	GSMTxSz++;
	GSM_SendFirstChar();
}
// ~~~~~~~~~
//   + CntrZ
void GSM_AddHeaderSendData(uint8_t *Data_Out, uint8_t Size){
    808e:	58 2f       	mov	r21, r24
    8090:	79 2f       	mov	r23, r25
	GSMTxSz = Size;
    8092:	60 93 75 07 	sts	0x0775, r22
	memcpy(GSM_TxStr, Data_Out, GSMTxSz);
    8096:	40 91 75 07 	lds	r20, 0x0775
    809a:	22 e0       	ldi	r18, 0x02	; 2
    809c:	3a e0       	ldi	r19, 0x0A	; 10
    809e:	c9 01       	movw	r24, r18
    80a0:	65 2f       	mov	r22, r21
    80a2:	50 e0       	ldi	r21, 0x00	; 0
    80a4:	0e 94 fd 7e 	call	0xfdfa	; 0xfdfa <memcpy>
	GSM_SendFirstChar();
    80a8:	0e 94 aa 39 	call	0x7354	; 0x7354 <GSM_SendFirstChar>
}
    80ac:	08 95       	ret

000080ae <PresicionHanler>:
		ew##ty3((ty2*)Var, Min);						\
	else																	\
		ew##ty3((ty2*)Var, (ty2)Buf)
// ~~~~~~~~~~~~~~~~~~~~~~~
//Change BufStr due to precision for correct sscanf reading BufStr
void PresicionHanler(OutField *Field){
    80ae:	cf 93       	push	r28
    80b0:	df 93       	push	r29

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    80b2:	ec 01       	movw	r28, r24
    80b4:	2f 96       	adiw	r28, 0x0f	; 15
    80b6:	fe 01       	movw	r30, r28
    80b8:	84 91       	lpm	r24, Z+
	if(prb(&Field->Prec)){
    80ba:	88 23       	and	r24, r24
    80bc:	19 f4       	brne	.+6      	; 0x80c4 <PresicionHanler+0x16>
			}
			p++;
		}
	}
	
}
    80be:	df 91       	pop	r29
    80c0:	cf 91       	pop	r28
    80c2:	08 95       	ret
		ew##ty3((ty2*)Var, (ty2)Buf)
// ~~~~~~~~~~~~~~~~~~~~~~~
//Change BufStr due to precision for correct sscanf reading BufStr
void PresicionHanler(OutField *Field){
	if(prb(&Field->Prec)){
		char *p = strchr(BufStr,'.');	//seek for first decimal point
    80c4:	81 ec       	ldi	r24, 0xC1	; 193
    80c6:	95 e0       	ldi	r25, 0x05	; 5
    80c8:	6e e2       	ldi	r22, 0x2E	; 46
    80ca:	70 e0       	ldi	r23, 0x00	; 0
    80cc:	0e 94 06 7f 	call	0xfe0c	; 0xfe0c <strchr>
		if(p==NULL){
    80d0:	00 97       	sbiw	r24, 0x00	; 0
    80d2:	01 f1       	breq	.+64     	; 0x8114 <PresicionHanler+0x66>
    80d4:	fe 01       	movw	r30, r28
    80d6:	24 91       	lpm	r18, Z+
			p = strchr(BufStr,' ');	//else seek for first space
		}
	  	for(uint8_t i=0; i<prb(&Field->Prec); i++){
    80d8:	22 23       	and	r18, r18
    80da:	89 f3       	breq	.-30     	; 0x80be <PresicionHanler+0x10>
    80dc:	fc 01       	movw	r30, r24
    80de:	dc 01       	movw	r26, r24
    80e0:	11 96       	adiw	r26, 0x01	; 1
    80e2:	30 e0       	ldi	r19, 0x00	; 0
			if(*p == '.'){
				if(isdigit(*(p+1))){
					*p= *(p+1);
					*(p+1) = '.';
				}
				else *p='0'; 
    80e4:	60 e3       	ldi	r22, 0x30	; 48
    80e6:	52 2f       	mov	r21, r18
    80e8:	07 c0       	rjmp	.+14     	; 0x80f8 <PresicionHanler+0x4a>
		if(p==NULL){
			p = strchr(BufStr,' ');	//else seek for first space
		}
	  	for(uint8_t i=0; i<prb(&Field->Prec); i++){
			if(*p == ' ') *p='0'; 
			if(*p == '.'){
    80ea:	2e 32       	cpi	r18, 0x2E	; 46
    80ec:	51 f0       	breq	.+20     	; 0x8102 <PresicionHanler+0x54>
	if(prb(&Field->Prec)){
		char *p = strchr(BufStr,'.');	//seek for first decimal point
		if(p==NULL){
			p = strchr(BufStr,' ');	//else seek for first space
		}
	  	for(uint8_t i=0; i<prb(&Field->Prec); i++){
    80ee:	3f 5f       	subi	r19, 0xFF	; 255
    80f0:	31 96       	adiw	r30, 0x01	; 1
    80f2:	11 96       	adiw	r26, 0x01	; 1
    80f4:	35 17       	cp	r19, r21
    80f6:	18 f7       	brcc	.-58     	; 0x80be <PresicionHanler+0x10>
			if(*p == ' ') *p='0'; 
    80f8:	20 81       	ld	r18, Z
    80fa:	20 32       	cpi	r18, 0x20	; 32
    80fc:	b1 f7       	brne	.-20     	; 0x80ea <PresicionHanler+0x3c>
			if(*p == '.'){
				if(isdigit(*(p+1))){
					*p= *(p+1);
					*(p+1) = '.';
				}
				else *p='0'; 
    80fe:	60 83       	st	Z, r22
    8100:	f6 cf       	rjmp	.-20     	; 0x80ee <PresicionHanler+0x40>
			p = strchr(BufStr,' ');	//else seek for first space
		}
	  	for(uint8_t i=0; i<prb(&Field->Prec); i++){
			if(*p == ' ') *p='0'; 
			if(*p == '.'){
				if(isdigit(*(p+1))){
    8102:	4c 91       	ld	r20, X
    8104:	84 2f       	mov	r24, r20
    8106:	90 e0       	ldi	r25, 0x00	; 0
    8108:	c0 97       	sbiw	r24, 0x30	; 48
    810a:	0a 97       	sbiw	r24, 0x0a	; 10
    810c:	c0 f7       	brcc	.-16     	; 0x80fe <PresicionHanler+0x50>
					*p= *(p+1);
    810e:	40 83       	st	Z, r20
					*(p+1) = '.';
    8110:	2c 93       	st	X, r18
    8112:	ed cf       	rjmp	.-38     	; 0x80ee <PresicionHanler+0x40>
//Change BufStr due to precision for correct sscanf reading BufStr
void PresicionHanler(OutField *Field){
	if(prb(&Field->Prec)){
		char *p = strchr(BufStr,'.');	//seek for first decimal point
		if(p==NULL){
			p = strchr(BufStr,' ');	//else seek for first space
    8114:	81 ec       	ldi	r24, 0xC1	; 193
    8116:	95 e0       	ldi	r25, 0x05	; 5
    8118:	60 e2       	ldi	r22, 0x20	; 32
    811a:	70 e0       	ldi	r23, 0x00	; 0
    811c:	0e 94 06 7f 	call	0xfe0c	; 0xfe0c <strchr>
    8120:	d9 cf       	rjmp	.-78     	; 0x80d4 <PresicionHanler+0x26>

00008122 <GetMultiSymbol>:
	}
	return 0;
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~
//    MultiSymbol   
uint8_t GetMultiSymbol(PGM_P Str_P, char Char){
    8122:	1f 93       	push	r17
    8124:	18 2f       	mov	r17, r24
	PGM_P ptr_P= strchr_P(Str_P, Char);
    8126:	70 e0       	ldi	r23, 0x00	; 0
    8128:	0e 94 a6 7e 	call	0xfd4c	; 0xfd4c <strchr_P>
	if(ptr_P) return (uint8_t)(ptr_P - Str_P);
    812c:	00 97       	sbiw	r24, 0x00	; 0
    812e:	19 f0       	breq	.+6      	; 0x8136 <GetMultiSymbol+0x14>
    8130:	81 1b       	sub	r24, r17
	else return 0;
}
    8132:	1f 91       	pop	r17
    8134:	08 95       	ret
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~
//    MultiSymbol   
uint8_t GetMultiSymbol(PGM_P Str_P, char Char){
	PGM_P ptr_P= strchr_P(Str_P, Char);
	if(ptr_P) return (uint8_t)(ptr_P - Str_P);
    8136:	80 e0       	ldi	r24, 0x00	; 0
	else return 0;
}
    8138:	1f 91       	pop	r17
    813a:	08 95       	ret

0000813c <PutEnum>:
} T_Param;

// ~~~~~~~~~~~~~~~~~~~~
void
PutEnum(T_Param *Param)
{
    813c:	0f 93       	push	r16
    813e:	1f 93       	push	r17
    8140:	cf 93       	push	r28
    8142:	df 93       	push	r29
    8144:	8c 01       	movw	r16, r24

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    8146:	dc 01       	movw	r26, r24
    8148:	14 96       	adiw	r26, 0x04	; 4
    814a:	ed 91       	ld	r30, X+
    814c:	fc 91       	ld	r31, X
    814e:	15 97       	sbiw	r26, 0x05	; 5
    8150:	65 91       	lpm	r22, Z+
    8152:	74 91       	lpm	r23, Z+
	strcpy_P(Param->Pos, prp(Param->Txt));
    8154:	8d 91       	ld	r24, X+
    8156:	9c 91       	ld	r25, X
    8158:	0e 94 ba 7e 	call	0xfd74	; 0xfd74 <strcpy_P>
	for(uint8_t i=strlen(Param->Pos); i<Param->Size; *(Param->Pos+i++)=' ');
    815c:	f8 01       	movw	r30, r16
    815e:	c0 81       	ld	r28, Z
    8160:	d1 81       	ldd	r29, Z+1	; 0x01
    8162:	fe 01       	movw	r30, r28
    8164:	01 90       	ld	r0, Z+
    8166:	00 20       	and	r0, r0
    8168:	e9 f7       	brne	.-6      	; 0x8164 <PutEnum+0x28>
    816a:	31 97       	sbiw	r30, 0x01	; 1
    816c:	ec 1b       	sub	r30, r28
    816e:	d8 01       	movw	r26, r16
    8170:	13 96       	adiw	r26, 0x03	; 3
    8172:	8c 91       	ld	r24, X
    8174:	e8 17       	cp	r30, r24
    8176:	70 f4       	brcc	.+28     	; 0x8194 <PutEnum+0x58>
    8178:	90 e2       	ldi	r25, 0x20	; 32
    817a:	02 c0       	rjmp	.+4      	; 0x8180 <PutEnum+0x44>
    817c:	cd 91       	ld	r28, X+
    817e:	dc 91       	ld	r29, X
    8180:	ce 0f       	add	r28, r30
    8182:	d1 1d       	adc	r29, r1
    8184:	98 83       	st	Y, r25
    8186:	ef 5f       	subi	r30, 0xFF	; 255
    8188:	d8 01       	movw	r26, r16
    818a:	13 96       	adiw	r26, 0x03	; 3
    818c:	8c 91       	ld	r24, X
    818e:	13 97       	sbiw	r26, 0x03	; 3
    8190:	e8 17       	cp	r30, r24
    8192:	a0 f3       	brcs	.-24     	; 0x817c <PutEnum+0x40>
}
    8194:	df 91       	pop	r29
    8196:	cf 91       	pop	r28
    8198:	1f 91       	pop	r17
    819a:	0f 91       	pop	r16
    819c:	08 95       	ret

0000819e <Put_sbVal>:
}

// ~~~~~~~~~~~~~~~~~~~~~~
void
Put_sbVal(T_Param *Param)
{
    819e:	6f 92       	push	r6
    81a0:	7f 92       	push	r7
    81a2:	8f 92       	push	r8
    81a4:	9f 92       	push	r9
    81a6:	af 92       	push	r10
    81a8:	bf 92       	push	r11
    81aa:	cf 92       	push	r12
    81ac:	df 92       	push	r13
    81ae:	ef 92       	push	r14
    81b0:	ff 92       	push	r15
    81b2:	0f 93       	push	r16
    81b4:	1f 93       	push	r17
    81b6:	df 93       	push	r29
    81b8:	cf 93       	push	r28
    81ba:	cd b7       	in	r28, 0x3d	; 61
    81bc:	de b7       	in	r29, 0x3e	; 62
    81be:	2c 97       	sbiw	r28, 0x0c	; 12
    81c0:	0f b6       	in	r0, 0x3f	; 63
    81c2:	f8 94       	cli
    81c4:	de bf       	out	0x3e, r29	; 62
    81c6:	0f be       	out	0x3f, r0	; 63
    81c8:	cd bf       	out	0x3d, r28	; 61
    81ca:	5c 01       	movw	r10, r24
	char Format[] = "%0+ li.%. u";
    81cc:	be 01       	movw	r22, r28
    81ce:	6f 5f       	subi	r22, 0xFF	; 255
    81d0:	7f 4f       	sbci	r23, 0xFF	; 255
    81d2:	db 01       	movw	r26, r22
    81d4:	e0 e0       	ldi	r30, 0x00	; 0
    81d6:	f2 e0       	ldi	r31, 0x02	; 2
    81d8:	8c e0       	ldi	r24, 0x0C	; 12
    81da:	01 90       	ld	r0, Z+
    81dc:	0d 92       	st	X+, r0
    81de:	81 50       	subi	r24, 0x01	; 1
    81e0:	e1 f7       	brne	.-8      	; 0x81da <Put_sbVal+0x3c>
	Format[3] = '0'+Param->Size;
    81e2:	d5 01       	movw	r26, r10
    81e4:	13 96       	adiw	r26, 0x03	; 3
    81e6:	2c 91       	ld	r18, X
    81e8:	13 97       	sbiw	r26, 0x03	; 3
    81ea:	20 5d       	subi	r18, 0xD0	; 208
    81ec:	2c 83       	std	Y+4, r18	; 0x04
	if(Param->Prec) {
    81ee:	12 96       	adiw	r26, 0x02	; 2
    81f0:	9c 91       	ld	r25, X
    81f2:	99 23       	and	r25, r25
    81f4:	09 f4       	brne	.+2      	; 0x81f8 <Put_sbVal+0x5a>
    81f6:	8d c0       	rjmp	.+282    	; 0x8312 <Put_sbVal+0x174>
		Format[3] -= Param->Prec+1;
    81f8:	89 2f       	mov	r24, r25
    81fa:	80 95       	com	r24
    81fc:	82 0f       	add	r24, r18
    81fe:	8c 83       	std	Y+4, r24	; 0x04
		Format[9] = '0'+Param->Prec;
    8200:	90 5d       	subi	r25, 0xD0	; 208
    8202:	9a 87       	std	Y+10, r25	; 0x0a
    8204:	90 53       	subi	r25, 0x30	; 48
		int16_t Div=Pow10(Param->Prec);
    8206:	49 2f       	mov	r20, r25
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    8208:	21 e0       	ldi	r18, 0x01	; 1
    820a:	30 e0       	ldi	r19, 0x00	; 0
		Pow *= 10;
    820c:	c9 01       	movw	r24, r18
    820e:	88 0f       	add	r24, r24
    8210:	99 1f       	adc	r25, r25
    8212:	22 0f       	add	r18, r18
    8214:	33 1f       	adc	r19, r19
    8216:	22 0f       	add	r18, r18
    8218:	33 1f       	adc	r19, r19
    821a:	22 0f       	add	r18, r18
    821c:	33 1f       	adc	r19, r19
    821e:	28 0f       	add	r18, r24
    8220:	39 1f       	adc	r19, r25
    8222:	41 50       	subi	r20, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    8224:	99 f7       	brne	.-26     	; 0x820c <Put_sbVal+0x6e>
    8226:	39 01       	movw	r6, r18
    8228:	88 24       	eor	r8, r8
    822a:	77 fc       	sbrc	r7, 7
    822c:	80 94       	com	r8
    822e:	98 2c       	mov	r9, r8
		sprintf(Param->Pos, Format, sF_Buf/Div, (uint32_t)labs(sF_Buf)%Div);
    8230:	10 91 f9 04 	lds	r17, 0x04F9
    8234:	00 91 fa 04 	lds	r16, 0x04FA
    8238:	f0 90 fb 04 	lds	r15, 0x04FB
    823c:	e0 90 fc 04 	lds	r14, 0x04FC
    8240:	ed b7       	in	r30, 0x3d	; 61
    8242:	fe b7       	in	r31, 0x3e	; 62
    8244:	3c 97       	sbiw	r30, 0x0c	; 12
    8246:	0f b6       	in	r0, 0x3f	; 63
    8248:	f8 94       	cli
    824a:	fe bf       	out	0x3e, r31	; 62
    824c:	0f be       	out	0x3f, r0	; 63
    824e:	ed bf       	out	0x3d, r30	; 61
    8250:	cd b6       	in	r12, 0x3d	; 61
    8252:	de b6       	in	r13, 0x3e	; 62
    8254:	08 94       	sec
    8256:	c1 1c       	adc	r12, r1
    8258:	d1 1c       	adc	r13, r1
    825a:	d5 01       	movw	r26, r10
    825c:	8d 91       	ld	r24, X+
    825e:	9c 91       	ld	r25, X
    8260:	92 83       	std	Z+2, r25	; 0x02
    8262:	81 83       	std	Z+1, r24	; 0x01
    8264:	f6 01       	movw	r30, r12
    8266:	73 83       	std	Z+3, r23	; 0x03
    8268:	62 83       	std	Z+2, r22	; 0x02
    826a:	61 2f       	mov	r22, r17
    826c:	70 2f       	mov	r23, r16
    826e:	8f 2d       	mov	r24, r15
    8270:	9e 2d       	mov	r25, r14
    8272:	a4 01       	movw	r20, r8
    8274:	93 01       	movw	r18, r6
    8276:	0e 94 8b 82 	call	0x10516	; 0x10516 <__divmodsi4>
    827a:	d6 01       	movw	r26, r12
    827c:	14 96       	adiw	r26, 0x04	; 4
    827e:	2d 93       	st	X+, r18
    8280:	3d 93       	st	X+, r19
    8282:	4d 93       	st	X+, r20
    8284:	5c 93       	st	X, r21
    8286:	17 97       	sbiw	r26, 0x07	; 7
    8288:	21 2f       	mov	r18, r17
    828a:	30 2f       	mov	r19, r16
    828c:	4f 2d       	mov	r20, r15
    828e:	5e 2d       	mov	r21, r14
    8290:	c9 01       	movw	r24, r18
    8292:	da 01       	movw	r26, r20
    8294:	bc 01       	movw	r22, r24
    8296:	cd 01       	movw	r24, r26
    8298:	97 fd       	sbrc	r25, 7
    829a:	77 c0       	rjmp	.+238    	; 0x838a <Put_sbVal+0x1ec>
    829c:	a4 01       	movw	r20, r8
    829e:	93 01       	movw	r18, r6
    82a0:	0e 94 69 82 	call	0x104d2	; 0x104d2 <__udivmodsi4>
    82a4:	f6 01       	movw	r30, r12
    82a6:	60 87       	std	Z+8, r22	; 0x08
    82a8:	71 87       	std	Z+9, r23	; 0x09
    82aa:	82 87       	std	Z+10, r24	; 0x0a
    82ac:	93 87       	std	Z+11, r25	; 0x0b
    82ae:	0e 94 ad 7f 	call	0xff5a	; 0xff5a <sprintf>
		if(sF_Buf<0) {
    82b2:	8d b7       	in	r24, 0x3d	; 61
    82b4:	9e b7       	in	r25, 0x3e	; 62
    82b6:	0c 96       	adiw	r24, 0x0c	; 12
    82b8:	0f b6       	in	r0, 0x3f	; 63
    82ba:	f8 94       	cli
    82bc:	9e bf       	out	0x3e, r25	; 62
    82be:	0f be       	out	0x3f, r0	; 63
    82c0:	8d bf       	out	0x3d, r24	; 61
    82c2:	80 91 f9 04 	lds	r24, 0x04F9
    82c6:	90 91 fa 04 	lds	r25, 0x04FA
    82ca:	a0 91 fb 04 	lds	r26, 0x04FB
    82ce:	b0 91 fc 04 	lds	r27, 0x04FC
    82d2:	b7 fd       	sbrc	r27, 7
    82d4:	4a c0       	rjmp	.+148    	; 0x836a <Put_sbVal+0x1cc>
	}
	else {
		Format[6] = '\0';
		sprintf(Param->Pos, Format, sF_Buf);
	}
	if(Minus)
    82d6:	80 91 fd 04 	lds	r24, 0x04FD
    82da:	88 23       	and	r24, r24
    82dc:	29 f0       	breq	.+10     	; 0x82e8 <Put_sbVal+0x14a>
		*Param->Pos = '-';
    82de:	d5 01       	movw	r26, r10
    82e0:	ed 91       	ld	r30, X+
    82e2:	fc 91       	ld	r31, X
    82e4:	8d e2       	ldi	r24, 0x2D	; 45
    82e6:	80 83       	st	Z, r24
}
    82e8:	2c 96       	adiw	r28, 0x0c	; 12
    82ea:	0f b6       	in	r0, 0x3f	; 63
    82ec:	f8 94       	cli
    82ee:	de bf       	out	0x3e, r29	; 62
    82f0:	0f be       	out	0x3f, r0	; 63
    82f2:	cd bf       	out	0x3d, r28	; 61
    82f4:	cf 91       	pop	r28
    82f6:	df 91       	pop	r29
    82f8:	1f 91       	pop	r17
    82fa:	0f 91       	pop	r16
    82fc:	ff 90       	pop	r15
    82fe:	ef 90       	pop	r14
    8300:	df 90       	pop	r13
    8302:	cf 90       	pop	r12
    8304:	bf 90       	pop	r11
    8306:	af 90       	pop	r10
    8308:	9f 90       	pop	r9
    830a:	8f 90       	pop	r8
    830c:	7f 90       	pop	r7
    830e:	6f 90       	pop	r6
    8310:	08 95       	ret
				Param->Pos++;
			*Param->Pos = '-';
		}
	}
	else {
		Format[6] = '\0';
    8312:	1f 82       	std	Y+7, r1	; 0x07
		sprintf(Param->Pos, Format, sF_Buf);
    8314:	ed b7       	in	r30, 0x3d	; 61
    8316:	fe b7       	in	r31, 0x3e	; 62
    8318:	38 97       	sbiw	r30, 0x08	; 8
    831a:	0f b6       	in	r0, 0x3f	; 63
    831c:	f8 94       	cli
    831e:	fe bf       	out	0x3e, r31	; 62
    8320:	0f be       	out	0x3f, r0	; 63
    8322:	ed bf       	out	0x3d, r30	; 61
    8324:	31 96       	adiw	r30, 0x01	; 1
    8326:	d5 01       	movw	r26, r10
    8328:	8d 91       	ld	r24, X+
    832a:	9c 91       	ld	r25, X
    832c:	ad b7       	in	r26, 0x3d	; 61
    832e:	be b7       	in	r27, 0x3e	; 62
    8330:	12 96       	adiw	r26, 0x02	; 2
    8332:	9c 93       	st	X, r25
    8334:	8e 93       	st	-X, r24
    8336:	11 97       	sbiw	r26, 0x01	; 1
    8338:	73 83       	std	Z+3, r23	; 0x03
    833a:	62 83       	std	Z+2, r22	; 0x02
    833c:	80 91 f9 04 	lds	r24, 0x04F9
    8340:	90 91 fa 04 	lds	r25, 0x04FA
    8344:	a0 91 fb 04 	lds	r26, 0x04FB
    8348:	b0 91 fc 04 	lds	r27, 0x04FC
    834c:	84 83       	std	Z+4, r24	; 0x04
    834e:	95 83       	std	Z+5, r25	; 0x05
    8350:	a6 83       	std	Z+6, r26	; 0x06
    8352:	b7 83       	std	Z+7, r27	; 0x07
    8354:	0e 94 ad 7f 	call	0xff5a	; 0xff5a <sprintf>
    8358:	ed b7       	in	r30, 0x3d	; 61
    835a:	fe b7       	in	r31, 0x3e	; 62
    835c:	38 96       	adiw	r30, 0x08	; 8
    835e:	0f b6       	in	r0, 0x3f	; 63
    8360:	f8 94       	cli
    8362:	fe bf       	out	0x3e, r31	; 62
    8364:	0f be       	out	0x3f, r0	; 63
    8366:	ed bf       	out	0x3d, r30	; 61
    8368:	b6 cf       	rjmp	.-148    	; 0x82d6 <Put_sbVal+0x138>
		Format[3] -= Param->Prec+1;
		Format[9] = '0'+Param->Prec;
		int16_t Div=Pow10(Param->Prec);
		sprintf(Param->Pos, Format, sF_Buf/Div, (uint32_t)labs(sF_Buf)%Div);
		if(sF_Buf<0) {
			while(*Param->Pos==' ')
    836a:	d5 01       	movw	r26, r10
    836c:	ed 91       	ld	r30, X+
    836e:	fc 91       	ld	r31, X
    8370:	80 81       	ld	r24, Z
    8372:	80 32       	cpi	r24, 0x20	; 32
    8374:	39 f4       	brne	.+14     	; 0x8384 <Put_sbVal+0x1e6>
				Param->Pos++;
    8376:	31 96       	adiw	r30, 0x01	; 1
    8378:	d5 01       	movw	r26, r10
    837a:	ed 93       	st	X+, r30
    837c:	fc 93       	st	X, r31
		Format[3] -= Param->Prec+1;
		Format[9] = '0'+Param->Prec;
		int16_t Div=Pow10(Param->Prec);
		sprintf(Param->Pos, Format, sF_Buf/Div, (uint32_t)labs(sF_Buf)%Div);
		if(sF_Buf<0) {
			while(*Param->Pos==' ')
    837e:	80 81       	ld	r24, Z
    8380:	80 32       	cpi	r24, 0x20	; 32
    8382:	c9 f3       	breq	.-14     	; 0x8376 <Put_sbVal+0x1d8>
				Param->Pos++;
			*Param->Pos = '-';
    8384:	8d e2       	ldi	r24, 0x2D	; 45
    8386:	80 83       	st	Z, r24
    8388:	a6 cf       	rjmp	.-180    	; 0x82d6 <Put_sbVal+0x138>
	Format[3] = '0'+Param->Size;
	if(Param->Prec) {
		Format[3] -= Param->Prec+1;
		Format[9] = '0'+Param->Prec;
		int16_t Div=Pow10(Param->Prec);
		sprintf(Param->Pos, Format, sF_Buf/Div, (uint32_t)labs(sF_Buf)%Div);
    838a:	90 95       	com	r25
    838c:	80 95       	com	r24
    838e:	70 95       	com	r23
    8390:	61 95       	neg	r22
    8392:	7f 4f       	sbci	r23, 0xFF	; 255
    8394:	8f 4f       	sbci	r24, 0xFF	; 255
    8396:	9f 4f       	sbci	r25, 0xFF	; 255
    8398:	81 cf       	rjmp	.-254    	; 0x829c <Put_sbVal+0xfe>

0000839a <Put_bVal>:
}

// ~~~~~~~~~~~~~~~~~~~~~
void
Put_bVal(T_Param *Param)
{
    839a:	6f 92       	push	r6
    839c:	7f 92       	push	r7
    839e:	8f 92       	push	r8
    83a0:	9f 92       	push	r9
    83a2:	af 92       	push	r10
    83a4:	bf 92       	push	r11
    83a6:	cf 92       	push	r12
    83a8:	df 92       	push	r13
    83aa:	ef 92       	push	r14
    83ac:	ff 92       	push	r15
    83ae:	0f 93       	push	r16
    83b0:	1f 93       	push	r17
    83b2:	df 93       	push	r29
    83b4:	cf 93       	push	r28
    83b6:	cd b7       	in	r28, 0x3d	; 61
    83b8:	de b7       	in	r29, 0x3e	; 62
    83ba:	2b 97       	sbiw	r28, 0x0b	; 11
    83bc:	0f b6       	in	r0, 0x3f	; 63
    83be:	f8 94       	cli
    83c0:	de bf       	out	0x3e, r29	; 62
    83c2:	0f be       	out	0x3f, r0	; 63
    83c4:	cd bf       	out	0x3d, r28	; 61
    83c6:	bc 01       	movw	r22, r24
	char Format[] = "%0 li.%. u";
    83c8:	3e 01       	movw	r6, r28
    83ca:	08 94       	sec
    83cc:	61 1c       	adc	r6, r1
    83ce:	71 1c       	adc	r7, r1
    83d0:	d3 01       	movw	r26, r6
    83d2:	ec e0       	ldi	r30, 0x0C	; 12
    83d4:	f2 e0       	ldi	r31, 0x02	; 2
    83d6:	8b e0       	ldi	r24, 0x0B	; 11
    83d8:	01 90       	ld	r0, Z+
    83da:	0d 92       	st	X+, r0
    83dc:	81 50       	subi	r24, 0x01	; 1
    83de:	e1 f7       	brne	.-8      	; 0x83d8 <Put_bVal+0x3e>
	Format[2] = '0'+Param->Size;
    83e0:	db 01       	movw	r26, r22
    83e2:	13 96       	adiw	r26, 0x03	; 3
    83e4:	2c 91       	ld	r18, X
    83e6:	13 97       	sbiw	r26, 0x03	; 3
    83e8:	20 5d       	subi	r18, 0xD0	; 208
    83ea:	2b 83       	std	Y+3, r18	; 0x03
	if(Param->Prec) {
    83ec:	12 96       	adiw	r26, 0x02	; 2
    83ee:	9c 91       	ld	r25, X
    83f0:	99 23       	and	r25, r25
    83f2:	09 f4       	brne	.+2      	; 0x83f6 <Put_bVal+0x5c>
    83f4:	6d c0       	rjmp	.+218    	; 0x84d0 <Put_bVal+0x136>
		Format[2] -= Param->Prec+1;
    83f6:	89 2f       	mov	r24, r25
    83f8:	80 95       	com	r24
    83fa:	82 0f       	add	r24, r18
    83fc:	8b 83       	std	Y+3, r24	; 0x03
		Format[8] = '0'+Param->Prec;
    83fe:	90 5d       	subi	r25, 0xD0	; 208
    8400:	99 87       	std	Y+9, r25	; 0x09
    8402:	90 53       	subi	r25, 0x30	; 48
		uint16_t Div=Pow10(Param->Prec);
    8404:	49 2f       	mov	r20, r25
    8406:	21 e0       	ldi	r18, 0x01	; 1
    8408:	30 e0       	ldi	r19, 0x00	; 0
		Pow *= 10;
    840a:	c9 01       	movw	r24, r18
    840c:	88 0f       	add	r24, r24
    840e:	99 1f       	adc	r25, r25
    8410:	22 0f       	add	r18, r18
    8412:	33 1f       	adc	r19, r19
    8414:	22 0f       	add	r18, r18
    8416:	33 1f       	adc	r19, r19
    8418:	22 0f       	add	r18, r18
    841a:	33 1f       	adc	r19, r19
    841c:	28 0f       	add	r18, r24
    841e:	39 1f       	adc	r19, r25
    8420:	41 50       	subi	r20, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    8422:	99 f7       	brne	.-26     	; 0x840a <Put_bVal+0x70>
    8424:	49 01       	movw	r8, r18
    8426:	aa 24       	eor	r10, r10
    8428:	bb 24       	eor	r11, r11
		sprintf(Param->Pos, Format, F_Buf/Div, F_Buf%Div);
    842a:	c0 90 f5 04 	lds	r12, 0x04F5
    842e:	d0 90 f6 04 	lds	r13, 0x04F6
    8432:	e0 90 f7 04 	lds	r14, 0x04F7
    8436:	f0 90 f8 04 	lds	r15, 0x04F8
    843a:	ed b7       	in	r30, 0x3d	; 61
    843c:	fe b7       	in	r31, 0x3e	; 62
    843e:	3c 97       	sbiw	r30, 0x0c	; 12
    8440:	0f b6       	in	r0, 0x3f	; 63
    8442:	f8 94       	cli
    8444:	fe bf       	out	0x3e, r31	; 62
    8446:	0f be       	out	0x3f, r0	; 63
    8448:	ed bf       	out	0x3d, r30	; 61
    844a:	0d b7       	in	r16, 0x3d	; 61
    844c:	1e b7       	in	r17, 0x3e	; 62
    844e:	0f 5f       	subi	r16, 0xFF	; 255
    8450:	1f 4f       	sbci	r17, 0xFF	; 255
    8452:	db 01       	movw	r26, r22
    8454:	8d 91       	ld	r24, X+
    8456:	9c 91       	ld	r25, X
    8458:	92 83       	std	Z+2, r25	; 0x02
    845a:	81 83       	std	Z+1, r24	; 0x01
    845c:	f8 01       	movw	r30, r16
    845e:	73 82       	std	Z+3, r7	; 0x03
    8460:	62 82       	std	Z+2, r6	; 0x02
    8462:	c7 01       	movw	r24, r14
    8464:	b6 01       	movw	r22, r12
    8466:	a5 01       	movw	r20, r10
    8468:	94 01       	movw	r18, r8
    846a:	0e 94 69 82 	call	0x104d2	; 0x104d2 <__udivmodsi4>
    846e:	d8 01       	movw	r26, r16
    8470:	14 96       	adiw	r26, 0x04	; 4
    8472:	2d 93       	st	X+, r18
    8474:	3d 93       	st	X+, r19
    8476:	4d 93       	st	X+, r20
    8478:	5c 93       	st	X, r21
    847a:	17 97       	sbiw	r26, 0x07	; 7
    847c:	c7 01       	movw	r24, r14
    847e:	b6 01       	movw	r22, r12
    8480:	a5 01       	movw	r20, r10
    8482:	94 01       	movw	r18, r8
    8484:	0e 94 69 82 	call	0x104d2	; 0x104d2 <__udivmodsi4>
    8488:	f8 01       	movw	r30, r16
    848a:	60 87       	std	Z+8, r22	; 0x08
    848c:	71 87       	std	Z+9, r23	; 0x09
    848e:	82 87       	std	Z+10, r24	; 0x0a
    8490:	93 87       	std	Z+11, r25	; 0x0b
    8492:	0e 94 ad 7f 	call	0xff5a	; 0xff5a <sprintf>
    8496:	8d b7       	in	r24, 0x3d	; 61
    8498:	9e b7       	in	r25, 0x3e	; 62
    849a:	0c 96       	adiw	r24, 0x0c	; 12
    849c:	0f b6       	in	r0, 0x3f	; 63
    849e:	f8 94       	cli
    84a0:	9e bf       	out	0x3e, r25	; 62
    84a2:	0f be       	out	0x3f, r0	; 63
    84a4:	8d bf       	out	0x3d, r24	; 61
	}
	else{
		Format[5] = '\0';
		sprintf(Param->Pos, Format, F_Buf);
	}
}
    84a6:	2b 96       	adiw	r28, 0x0b	; 11
    84a8:	0f b6       	in	r0, 0x3f	; 63
    84aa:	f8 94       	cli
    84ac:	de bf       	out	0x3e, r29	; 62
    84ae:	0f be       	out	0x3f, r0	; 63
    84b0:	cd bf       	out	0x3d, r28	; 61
    84b2:	cf 91       	pop	r28
    84b4:	df 91       	pop	r29
    84b6:	1f 91       	pop	r17
    84b8:	0f 91       	pop	r16
    84ba:	ff 90       	pop	r15
    84bc:	ef 90       	pop	r14
    84be:	df 90       	pop	r13
    84c0:	cf 90       	pop	r12
    84c2:	bf 90       	pop	r11
    84c4:	af 90       	pop	r10
    84c6:	9f 90       	pop	r9
    84c8:	8f 90       	pop	r8
    84ca:	7f 90       	pop	r7
    84cc:	6f 90       	pop	r6
    84ce:	08 95       	ret
		Format[8] = '0'+Param->Prec;
		uint16_t Div=Pow10(Param->Prec);
		sprintf(Param->Pos, Format, F_Buf/Div, F_Buf%Div);
	}
	else{
		Format[5] = '\0';
    84d0:	1e 82       	std	Y+6, r1	; 0x06
		sprintf(Param->Pos, Format, F_Buf);
    84d2:	ad b7       	in	r26, 0x3d	; 61
    84d4:	be b7       	in	r27, 0x3e	; 62
    84d6:	18 97       	sbiw	r26, 0x08	; 8
    84d8:	0f b6       	in	r0, 0x3f	; 63
    84da:	f8 94       	cli
    84dc:	be bf       	out	0x3e, r27	; 62
    84de:	0f be       	out	0x3f, r0	; 63
    84e0:	ad bf       	out	0x3d, r26	; 61
    84e2:	ed b7       	in	r30, 0x3d	; 61
    84e4:	fe b7       	in	r31, 0x3e	; 62
    84e6:	31 96       	adiw	r30, 0x01	; 1
    84e8:	db 01       	movw	r26, r22
    84ea:	8d 91       	ld	r24, X+
    84ec:	9c 91       	ld	r25, X
    84ee:	ad b7       	in	r26, 0x3d	; 61
    84f0:	be b7       	in	r27, 0x3e	; 62
    84f2:	12 96       	adiw	r26, 0x02	; 2
    84f4:	9c 93       	st	X, r25
    84f6:	8e 93       	st	-X, r24
    84f8:	11 97       	sbiw	r26, 0x01	; 1
    84fa:	73 82       	std	Z+3, r7	; 0x03
    84fc:	62 82       	std	Z+2, r6	; 0x02
    84fe:	80 91 f5 04 	lds	r24, 0x04F5
    8502:	90 91 f6 04 	lds	r25, 0x04F6
    8506:	a0 91 f7 04 	lds	r26, 0x04F7
    850a:	b0 91 f8 04 	lds	r27, 0x04F8
    850e:	84 83       	std	Z+4, r24	; 0x04
    8510:	95 83       	std	Z+5, r25	; 0x05
    8512:	a6 83       	std	Z+6, r26	; 0x06
    8514:	b7 83       	std	Z+7, r27	; 0x07
    8516:	0e 94 ad 7f 	call	0xff5a	; 0xff5a <sprintf>
    851a:	ed b7       	in	r30, 0x3d	; 61
    851c:	fe b7       	in	r31, 0x3e	; 62
    851e:	38 96       	adiw	r30, 0x08	; 8
    8520:	0f b6       	in	r0, 0x3f	; 63
    8522:	f8 94       	cli
    8524:	fe bf       	out	0x3e, r31	; 62
    8526:	0f be       	out	0x3f, r0	; 63
    8528:	ed bf       	out	0x3d, r30	; 61
    852a:	bd cf       	rjmp	.-134    	; 0x84a6 <Put_bVal+0x10c>

0000852c <Put_TextValAlignLeft>:
	char Format[8];
	//char Format[8] = "%10.10s";
	sprintf(Format,"%%%u.%us", Param->Size, Param->Size);
	sprintf(Param->Pos, Format, Val);
}
void Put_TextValAlignLeft(char* Val, T_Param *Param){
    852c:	cf 92       	push	r12
    852e:	df 92       	push	r13
    8530:	ef 92       	push	r14
    8532:	ff 92       	push	r15
    8534:	0f 93       	push	r16
    8536:	1f 93       	push	r17
    8538:	df 93       	push	r29
    853a:	cf 93       	push	r28
    853c:	cd b7       	in	r28, 0x3d	; 61
    853e:	de b7       	in	r29, 0x3e	; 62
    8540:	29 97       	sbiw	r28, 0x09	; 9
    8542:	0f b6       	in	r0, 0x3f	; 63
    8544:	f8 94       	cli
    8546:	de bf       	out	0x3e, r29	; 62
    8548:	0f be       	out	0x3f, r0	; 63
    854a:	cd bf       	out	0x3d, r28	; 61
    854c:	6c 01       	movw	r12, r24
    854e:	7b 01       	movw	r14, r22
	char Format[9];
	//char Format[8] = "%10.10s";
	sprintf(Format,"%%-%u.%us", Param->Size, Param->Size);
    8550:	db 01       	movw	r26, r22
    8552:	13 96       	adiw	r26, 0x03	; 3
    8554:	2c 91       	ld	r18, X
    8556:	ed b7       	in	r30, 0x3d	; 61
    8558:	fe b7       	in	r31, 0x3e	; 62
    855a:	38 97       	sbiw	r30, 0x08	; 8
    855c:	0f b6       	in	r0, 0x3f	; 63
    855e:	f8 94       	cli
    8560:	fe bf       	out	0x3e, r31	; 62
    8562:	0f be       	out	0x3f, r0	; 63
    8564:	ed bf       	out	0x3d, r30	; 61
    8566:	31 96       	adiw	r30, 0x01	; 1
    8568:	8e 01       	movw	r16, r28
    856a:	0f 5f       	subi	r16, 0xFF	; 255
    856c:	1f 4f       	sbci	r17, 0xFF	; 255
    856e:	ad b7       	in	r26, 0x3d	; 61
    8570:	be b7       	in	r27, 0x3e	; 62
    8572:	12 96       	adiw	r26, 0x02	; 2
    8574:	1c 93       	st	X, r17
    8576:	0e 93       	st	-X, r16
    8578:	11 97       	sbiw	r26, 0x01	; 1
    857a:	87 e1       	ldi	r24, 0x17	; 23
    857c:	92 e0       	ldi	r25, 0x02	; 2
    857e:	93 83       	std	Z+3, r25	; 0x03
    8580:	82 83       	std	Z+2, r24	; 0x02
    8582:	24 83       	std	Z+4, r18	; 0x04
    8584:	15 82       	std	Z+5, r1	; 0x05
    8586:	26 83       	std	Z+6, r18	; 0x06
    8588:	17 82       	std	Z+7, r1	; 0x07
    858a:	0e 94 ad 7f 	call	0xff5a	; 0xff5a <sprintf>
	sprintf(Param->Pos, Format, Val);
    858e:	0f 90       	pop	r0
    8590:	0f 90       	pop	r0
    8592:	ed b7       	in	r30, 0x3d	; 61
    8594:	fe b7       	in	r31, 0x3e	; 62
    8596:	31 96       	adiw	r30, 0x01	; 1
    8598:	d7 01       	movw	r26, r14
    859a:	8d 91       	ld	r24, X+
    859c:	9c 91       	ld	r25, X
    859e:	ad b7       	in	r26, 0x3d	; 61
    85a0:	be b7       	in	r27, 0x3e	; 62
    85a2:	12 96       	adiw	r26, 0x02	; 2
    85a4:	9c 93       	st	X, r25
    85a6:	8e 93       	st	-X, r24
    85a8:	11 97       	sbiw	r26, 0x01	; 1
    85aa:	13 83       	std	Z+3, r17	; 0x03
    85ac:	02 83       	std	Z+2, r16	; 0x02
    85ae:	d5 82       	std	Z+5, r13	; 0x05
    85b0:	c4 82       	std	Z+4, r12	; 0x04
    85b2:	0e 94 ad 7f 	call	0xff5a	; 0xff5a <sprintf>
    85b6:	ed b7       	in	r30, 0x3d	; 61
    85b8:	fe b7       	in	r31, 0x3e	; 62
    85ba:	36 96       	adiw	r30, 0x06	; 6
    85bc:	0f b6       	in	r0, 0x3f	; 63
    85be:	f8 94       	cli
    85c0:	fe bf       	out	0x3e, r31	; 62
    85c2:	0f be       	out	0x3f, r0	; 63
    85c4:	ed bf       	out	0x3d, r30	; 61
}
    85c6:	29 96       	adiw	r28, 0x09	; 9
    85c8:	0f b6       	in	r0, 0x3f	; 63
    85ca:	f8 94       	cli
    85cc:	de bf       	out	0x3e, r29	; 62
    85ce:	0f be       	out	0x3f, r0	; 63
    85d0:	cd bf       	out	0x3d, r28	; 61
    85d2:	cf 91       	pop	r28
    85d4:	df 91       	pop	r29
    85d6:	1f 91       	pop	r17
    85d8:	0f 91       	pop	r16
    85da:	ff 90       	pop	r15
    85dc:	ef 90       	pop	r14
    85de:	df 90       	pop	r13
    85e0:	cf 90       	pop	r12
    85e2:	08 95       	ret

000085e4 <Put_TextValAlignRight>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Put_TextVal -  
// if, for example, Filed width =12 -> sprintf(Param->Pos,"%12.12s",Val)
// min and max width = Param->Size and align right
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void Put_TextValAlignRight(char* Val, T_Param *Param){
    85e4:	cf 92       	push	r12
    85e6:	df 92       	push	r13
    85e8:	ef 92       	push	r14
    85ea:	ff 92       	push	r15
    85ec:	0f 93       	push	r16
    85ee:	1f 93       	push	r17
    85f0:	df 93       	push	r29
    85f2:	cf 93       	push	r28
    85f4:	cd b7       	in	r28, 0x3d	; 61
    85f6:	de b7       	in	r29, 0x3e	; 62
    85f8:	28 97       	sbiw	r28, 0x08	; 8
    85fa:	0f b6       	in	r0, 0x3f	; 63
    85fc:	f8 94       	cli
    85fe:	de bf       	out	0x3e, r29	; 62
    8600:	0f be       	out	0x3f, r0	; 63
    8602:	cd bf       	out	0x3d, r28	; 61
    8604:	6c 01       	movw	r12, r24
    8606:	7b 01       	movw	r14, r22
	char Format[8];
	//char Format[8] = "%10.10s";
	sprintf(Format,"%%%u.%us", Param->Size, Param->Size);
    8608:	db 01       	movw	r26, r22
    860a:	13 96       	adiw	r26, 0x03	; 3
    860c:	2c 91       	ld	r18, X
    860e:	ed b7       	in	r30, 0x3d	; 61
    8610:	fe b7       	in	r31, 0x3e	; 62
    8612:	38 97       	sbiw	r30, 0x08	; 8
    8614:	0f b6       	in	r0, 0x3f	; 63
    8616:	f8 94       	cli
    8618:	fe bf       	out	0x3e, r31	; 62
    861a:	0f be       	out	0x3f, r0	; 63
    861c:	ed bf       	out	0x3d, r30	; 61
    861e:	31 96       	adiw	r30, 0x01	; 1
    8620:	8e 01       	movw	r16, r28
    8622:	0f 5f       	subi	r16, 0xFF	; 255
    8624:	1f 4f       	sbci	r17, 0xFF	; 255
    8626:	ad b7       	in	r26, 0x3d	; 61
    8628:	be b7       	in	r27, 0x3e	; 62
    862a:	12 96       	adiw	r26, 0x02	; 2
    862c:	1c 93       	st	X, r17
    862e:	0e 93       	st	-X, r16
    8630:	11 97       	sbiw	r26, 0x01	; 1
    8632:	81 e2       	ldi	r24, 0x21	; 33
    8634:	92 e0       	ldi	r25, 0x02	; 2
    8636:	93 83       	std	Z+3, r25	; 0x03
    8638:	82 83       	std	Z+2, r24	; 0x02
    863a:	24 83       	std	Z+4, r18	; 0x04
    863c:	15 82       	std	Z+5, r1	; 0x05
    863e:	26 83       	std	Z+6, r18	; 0x06
    8640:	17 82       	std	Z+7, r1	; 0x07
    8642:	0e 94 ad 7f 	call	0xff5a	; 0xff5a <sprintf>
	sprintf(Param->Pos, Format, Val);
    8646:	0f 90       	pop	r0
    8648:	0f 90       	pop	r0
    864a:	ed b7       	in	r30, 0x3d	; 61
    864c:	fe b7       	in	r31, 0x3e	; 62
    864e:	31 96       	adiw	r30, 0x01	; 1
    8650:	d7 01       	movw	r26, r14
    8652:	8d 91       	ld	r24, X+
    8654:	9c 91       	ld	r25, X
    8656:	ad b7       	in	r26, 0x3d	; 61
    8658:	be b7       	in	r27, 0x3e	; 62
    865a:	12 96       	adiw	r26, 0x02	; 2
    865c:	9c 93       	st	X, r25
    865e:	8e 93       	st	-X, r24
    8660:	11 97       	sbiw	r26, 0x01	; 1
    8662:	13 83       	std	Z+3, r17	; 0x03
    8664:	02 83       	std	Z+2, r16	; 0x02
    8666:	d5 82       	std	Z+5, r13	; 0x05
    8668:	c4 82       	std	Z+4, r12	; 0x04
    866a:	0e 94 ad 7f 	call	0xff5a	; 0xff5a <sprintf>
    866e:	ed b7       	in	r30, 0x3d	; 61
    8670:	fe b7       	in	r31, 0x3e	; 62
    8672:	36 96       	adiw	r30, 0x06	; 6
    8674:	0f b6       	in	r0, 0x3f	; 63
    8676:	f8 94       	cli
    8678:	fe bf       	out	0x3e, r31	; 62
    867a:	0f be       	out	0x3f, r0	; 63
    867c:	ed bf       	out	0x3d, r30	; 61
}
    867e:	28 96       	adiw	r28, 0x08	; 8
    8680:	0f b6       	in	r0, 0x3f	; 63
    8682:	f8 94       	cli
    8684:	de bf       	out	0x3e, r29	; 62
    8686:	0f be       	out	0x3f, r0	; 63
    8688:	cd bf       	out	0x3d, r28	; 61
    868a:	cf 91       	pop	r28
    868c:	df 91       	pop	r29
    868e:	1f 91       	pop	r17
    8690:	0f 91       	pop	r16
    8692:	ff 90       	pop	r15
    8694:	ef 90       	pop	r14
    8696:	df 90       	pop	r13
    8698:	cf 90       	pop	r12
    869a:	08 95       	ret

0000869c <Put_GFVal>:
// Trailing zeros are removed from the fractional part of the result; 
// a decimal point appears only if it is followed by at least one digit.
// Max presicion - 8digits Why???
// Therefore Max Field size - 9
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void Put_GFVal(float Val, T_Param *Param){
    869c:	ef 92       	push	r14
    869e:	ff 92       	push	r15
    86a0:	0f 93       	push	r16
    86a2:	1f 93       	push	r17
    86a4:	df 93       	push	r29
    86a6:	cf 93       	push	r28
    86a8:	cd b7       	in	r28, 0x3d	; 61
    86aa:	de b7       	in	r29, 0x3e	; 62
    86ac:	2f 97       	sbiw	r28, 0x0f	; 15
    86ae:	0f b6       	in	r0, 0x3f	; 63
    86b0:	f8 94       	cli
    86b2:	de bf       	out	0x3e, r29	; 62
    86b4:	0f be       	out	0x3f, r0	; 63
    86b6:	cd bf       	out	0x3d, r28	; 61
    86b8:	7b 01       	movw	r14, r22
    86ba:	8c 01       	movw	r16, r24
    86bc:	9a 01       	movw	r18, r20
	if(Param->Size < 10){
    86be:	da 01       	movw	r26, r20
    86c0:	13 96       	adiw	r26, 0x03	; 3
    86c2:	8c 91       	ld	r24, X
    86c4:	8a 30       	cpi	r24, 0x0A	; 10
    86c6:	08 f4       	brcc	.+2      	; 0x86ca <Put_GFVal+0x2e>
    86c8:	44 c0       	rjmp	.+136    	; 0x8752 <Put_GFVal+0xb6>
		Format[2] = '0'+Param->Size;
		Format[4] = '0'+Param->Prec;
		sprintf(Param->Pos, Format, Val);
	}
	else{
		char Format[] = "%+1 . g";
    86ca:	ae 01       	movw	r20, r28
    86cc:	48 5f       	subi	r20, 0xF8	; 248
    86ce:	5f 4f       	sbci	r21, 0xFF	; 255
    86d0:	da 01       	movw	r26, r20
    86d2:	ea e2       	ldi	r30, 0x2A	; 42
    86d4:	f2 e0       	ldi	r31, 0x02	; 2
    86d6:	88 e0       	ldi	r24, 0x08	; 8
    86d8:	01 90       	ld	r0, Z+
    86da:	0d 92       	st	X+, r0
    86dc:	81 50       	subi	r24, 0x01	; 1
    86de:	e1 f7       	brne	.-8      	; 0x86d8 <Put_GFVal+0x3c>
		Format[3] = '0'+Param->Size-10;	
    86e0:	d9 01       	movw	r26, r18
    86e2:	13 96       	adiw	r26, 0x03	; 3
    86e4:	8c 91       	ld	r24, X
    86e6:	13 97       	sbiw	r26, 0x03	; 3
    86e8:	8a 5d       	subi	r24, 0xDA	; 218
    86ea:	8b 87       	std	Y+11, r24	; 0x0b
		Format[5] = '0'+Param->Prec;
    86ec:	12 96       	adiw	r26, 0x02	; 2
    86ee:	8c 91       	ld	r24, X
    86f0:	12 97       	sbiw	r26, 0x02	; 2
    86f2:	80 5d       	subi	r24, 0xD0	; 208
    86f4:	8d 87       	std	Y+13, r24	; 0x0d
		sprintf(Param->Pos, Format, Val);
    86f6:	ed b7       	in	r30, 0x3d	; 61
    86f8:	fe b7       	in	r31, 0x3e	; 62
    86fa:	38 97       	sbiw	r30, 0x08	; 8
    86fc:	0f b6       	in	r0, 0x3f	; 63
    86fe:	f8 94       	cli
    8700:	fe bf       	out	0x3e, r31	; 62
    8702:	0f be       	out	0x3f, r0	; 63
    8704:	ed bf       	out	0x3d, r30	; 61
    8706:	31 96       	adiw	r30, 0x01	; 1
    8708:	8d 91       	ld	r24, X+
    870a:	9c 91       	ld	r25, X
    870c:	ad b7       	in	r26, 0x3d	; 61
    870e:	be b7       	in	r27, 0x3e	; 62
    8710:	12 96       	adiw	r26, 0x02	; 2
    8712:	9c 93       	st	X, r25
    8714:	8e 93       	st	-X, r24
    8716:	11 97       	sbiw	r26, 0x01	; 1
    8718:	53 83       	std	Z+3, r21	; 0x03
    871a:	42 83       	std	Z+2, r20	; 0x02
    871c:	e4 82       	std	Z+4, r14	; 0x04
    871e:	f5 82       	std	Z+5, r15	; 0x05
    8720:	06 83       	std	Z+6, r16	; 0x06
    8722:	17 83       	std	Z+7, r17	; 0x07
    8724:	0e 94 ad 7f 	call	0xff5a	; 0xff5a <sprintf>
    8728:	ed b7       	in	r30, 0x3d	; 61
    872a:	fe b7       	in	r31, 0x3e	; 62
    872c:	38 96       	adiw	r30, 0x08	; 8
    872e:	0f b6       	in	r0, 0x3f	; 63
    8730:	f8 94       	cli
    8732:	fe bf       	out	0x3e, r31	; 62
    8734:	0f be       	out	0x3f, r0	; 63
    8736:	ed bf       	out	0x3d, r30	; 61
	}
}
    8738:	2f 96       	adiw	r28, 0x0f	; 15
    873a:	0f b6       	in	r0, 0x3f	; 63
    873c:	f8 94       	cli
    873e:	de bf       	out	0x3e, r29	; 62
    8740:	0f be       	out	0x3f, r0	; 63
    8742:	cd bf       	out	0x3d, r28	; 61
    8744:	cf 91       	pop	r28
    8746:	df 91       	pop	r29
    8748:	1f 91       	pop	r17
    874a:	0f 91       	pop	r16
    874c:	ff 90       	pop	r15
    874e:	ef 90       	pop	r14
    8750:	08 95       	ret
// Max presicion - 8digits Why???
// Therefore Max Field size - 9
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void Put_GFVal(float Val, T_Param *Param){
	if(Param->Size < 10){
		char Format[] = "%+ . g";
    8752:	ae 01       	movw	r20, r28
    8754:	4f 5f       	subi	r20, 0xFF	; 255
    8756:	5f 4f       	sbci	r21, 0xFF	; 255
    8758:	da 01       	movw	r26, r20
    875a:	e2 e3       	ldi	r30, 0x32	; 50
    875c:	f2 e0       	ldi	r31, 0x02	; 2
    875e:	87 e0       	ldi	r24, 0x07	; 7
    8760:	01 90       	ld	r0, Z+
    8762:	0d 92       	st	X+, r0
    8764:	81 50       	subi	r24, 0x01	; 1
    8766:	e1 f7       	brne	.-8      	; 0x8760 <Put_GFVal+0xc4>
		Format[2] = '0'+Param->Size;
    8768:	f9 01       	movw	r30, r18
    876a:	83 81       	ldd	r24, Z+3	; 0x03
    876c:	80 5d       	subi	r24, 0xD0	; 208
    876e:	8b 83       	std	Y+3, r24	; 0x03
		Format[4] = '0'+Param->Prec;
    8770:	82 81       	ldd	r24, Z+2	; 0x02
    8772:	80 5d       	subi	r24, 0xD0	; 208
    8774:	8d 83       	std	Y+5, r24	; 0x05
		sprintf(Param->Pos, Format, Val);
    8776:	8d b7       	in	r24, 0x3d	; 61
    8778:	9e b7       	in	r25, 0x3e	; 62
    877a:	08 97       	sbiw	r24, 0x08	; 8
    877c:	0f b6       	in	r0, 0x3f	; 63
    877e:	f8 94       	cli
    8780:	9e bf       	out	0x3e, r25	; 62
    8782:	0f be       	out	0x3f, r0	; 63
    8784:	8d bf       	out	0x3d, r24	; 61
    8786:	ed b7       	in	r30, 0x3d	; 61
    8788:	fe b7       	in	r31, 0x3e	; 62
    878a:	31 96       	adiw	r30, 0x01	; 1
    878c:	d9 01       	movw	r26, r18
    878e:	bc cf       	rjmp	.-136    	; 0x8708 <Put_GFVal+0x6c>

00008790 <Put_FFVal>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Put_FVal -  The double argument is rounded and converted to decimal notation in the format "[-]ddd.ddd"
// Max presicion - 8digits Why???
// Therefore Max Field size - 9
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void Put_FFVal(float Val, T_Param *Param){
    8790:	ef 92       	push	r14
    8792:	ff 92       	push	r15
    8794:	0f 93       	push	r16
    8796:	1f 93       	push	r17
    8798:	df 93       	push	r29
    879a:	cf 93       	push	r28
    879c:	cd b7       	in	r28, 0x3d	; 61
    879e:	de b7       	in	r29, 0x3e	; 62
    87a0:	27 97       	sbiw	r28, 0x07	; 7
    87a2:	0f b6       	in	r0, 0x3f	; 63
    87a4:	f8 94       	cli
    87a6:	de bf       	out	0x3e, r29	; 62
    87a8:	0f be       	out	0x3f, r0	; 63
    87aa:	cd bf       	out	0x3d, r28	; 61
    87ac:	7b 01       	movw	r14, r22
    87ae:	8c 01       	movw	r16, r24
    87b0:	9a 01       	movw	r18, r20
	char Format[] = "%+ . f";
    87b2:	ae 01       	movw	r20, r28
    87b4:	4f 5f       	subi	r20, 0xFF	; 255
    87b6:	5f 4f       	sbci	r21, 0xFF	; 255
    87b8:	da 01       	movw	r26, r20
    87ba:	e9 e3       	ldi	r30, 0x39	; 57
    87bc:	f2 e0       	ldi	r31, 0x02	; 2
    87be:	87 e0       	ldi	r24, 0x07	; 7
    87c0:	01 90       	ld	r0, Z+
    87c2:	0d 92       	st	X+, r0
    87c4:	81 50       	subi	r24, 0x01	; 1
    87c6:	e1 f7       	brne	.-8      	; 0x87c0 <Put_FFVal+0x30>
	Format[2] = '0'+Param->Size;
    87c8:	d9 01       	movw	r26, r18
    87ca:	13 96       	adiw	r26, 0x03	; 3
    87cc:	8c 91       	ld	r24, X
    87ce:	13 97       	sbiw	r26, 0x03	; 3
    87d0:	80 5d       	subi	r24, 0xD0	; 208
    87d2:	8b 83       	std	Y+3, r24	; 0x03
	Format[4] = '0'+Param->Prec;	
    87d4:	12 96       	adiw	r26, 0x02	; 2
    87d6:	8c 91       	ld	r24, X
    87d8:	12 97       	sbiw	r26, 0x02	; 2
    87da:	80 5d       	subi	r24, 0xD0	; 208
    87dc:	8d 83       	std	Y+5, r24	; 0x05
	sprintf(Param->Pos, Format, Val);
    87de:	ed b7       	in	r30, 0x3d	; 61
    87e0:	fe b7       	in	r31, 0x3e	; 62
    87e2:	38 97       	sbiw	r30, 0x08	; 8
    87e4:	0f b6       	in	r0, 0x3f	; 63
    87e6:	f8 94       	cli
    87e8:	fe bf       	out	0x3e, r31	; 62
    87ea:	0f be       	out	0x3f, r0	; 63
    87ec:	ed bf       	out	0x3d, r30	; 61
    87ee:	31 96       	adiw	r30, 0x01	; 1
    87f0:	8d 91       	ld	r24, X+
    87f2:	9c 91       	ld	r25, X
    87f4:	ad b7       	in	r26, 0x3d	; 61
    87f6:	be b7       	in	r27, 0x3e	; 62
    87f8:	12 96       	adiw	r26, 0x02	; 2
    87fa:	9c 93       	st	X, r25
    87fc:	8e 93       	st	-X, r24
    87fe:	11 97       	sbiw	r26, 0x01	; 1
    8800:	53 83       	std	Z+3, r21	; 0x03
    8802:	42 83       	std	Z+2, r20	; 0x02
    8804:	e4 82       	std	Z+4, r14	; 0x04
    8806:	f5 82       	std	Z+5, r15	; 0x05
    8808:	06 83       	std	Z+6, r16	; 0x06
    880a:	17 83       	std	Z+7, r17	; 0x07
    880c:	0e 94 ad 7f 	call	0xff5a	; 0xff5a <sprintf>
    8810:	ed b7       	in	r30, 0x3d	; 61
    8812:	fe b7       	in	r31, 0x3e	; 62
    8814:	38 96       	adiw	r30, 0x08	; 8
    8816:	0f b6       	in	r0, 0x3f	; 63
    8818:	f8 94       	cli
    881a:	fe bf       	out	0x3e, r31	; 62
    881c:	0f be       	out	0x3f, r0	; 63
    881e:	ed bf       	out	0x3d, r30	; 61
}
    8820:	27 96       	adiw	r28, 0x07	; 7
    8822:	0f b6       	in	r0, 0x3f	; 63
    8824:	f8 94       	cli
    8826:	de bf       	out	0x3e, r29	; 62
    8828:	0f be       	out	0x3f, r0	; 63
    882a:	cd bf       	out	0x3d, r28	; 61
    882c:	cf 91       	pop	r28
    882e:	df 91       	pop	r29
    8830:	1f 91       	pop	r17
    8832:	0f 91       	pop	r16
    8834:	ff 90       	pop	r15
    8836:	ef 90       	pop	r14
    8838:	08 95       	ret

0000883a <Put_zDVal>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Put_zDVal - print unsigned Longint with leading zeroes in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void 
Put_zDVal(uint32_t Val, T_Param *Param)
{
    883a:	2f 92       	push	r2
    883c:	3f 92       	push	r3
    883e:	4f 92       	push	r4
    8840:	5f 92       	push	r5
    8842:	6f 92       	push	r6
    8844:	7f 92       	push	r7
    8846:	8f 92       	push	r8
    8848:	9f 92       	push	r9
    884a:	af 92       	push	r10
    884c:	bf 92       	push	r11
    884e:	cf 92       	push	r12
    8850:	df 92       	push	r13
    8852:	ef 92       	push	r14
    8854:	ff 92       	push	r15
    8856:	0f 93       	push	r16
    8858:	1f 93       	push	r17
    885a:	df 93       	push	r29
    885c:	cf 93       	push	r28
    885e:	cd b7       	in	r28, 0x3d	; 61
    8860:	de b7       	in	r29, 0x3e	; 62
    8862:	2c 97       	sbiw	r28, 0x0c	; 12
    8864:	0f b6       	in	r0, 0x3f	; 63
    8866:	f8 94       	cli
    8868:	de bf       	out	0x3e, r29	; 62
    886a:	0f be       	out	0x3f, r0	; 63
    886c:	cd bf       	out	0x3d, r28	; 61
    886e:	1b 01       	movw	r2, r22
    8870:	2c 01       	movw	r4, r24
    8872:	3a 01       	movw	r6, r20
	uint32_t Idx = 0xFFFFFFFF-Val;
	if(Param->Txt && Idx<2) {
    8874:	da 01       	movw	r26, r20
    8876:	14 96       	adiw	r26, 0x04	; 4
    8878:	2d 91       	ld	r18, X+
    887a:	3c 91       	ld	r19, X
    887c:	15 97       	sbiw	r26, 0x05	; 5
    887e:	21 15       	cp	r18, r1
    8880:	31 05       	cpc	r19, r1
    8882:	61 f0       	breq	.+24     	; 0x889c <Put_zDVal+0x62>
// Put_zDVal - print unsigned Longint with leading zeroes in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void 
Put_zDVal(uint32_t Val, T_Param *Param)
{
	uint32_t Idx = 0xFFFFFFFF-Val;
    8884:	dc 01       	movw	r26, r24
    8886:	cb 01       	movw	r24, r22
    8888:	80 95       	com	r24
    888a:	90 95       	com	r25
    888c:	a0 95       	com	r26
    888e:	b0 95       	com	r27
	if(Param->Txt && Idx<2) {
    8890:	82 30       	cpi	r24, 0x02	; 2
    8892:	91 05       	cpc	r25, r1
    8894:	a1 05       	cpc	r26, r1
    8896:	b1 05       	cpc	r27, r1
    8898:	08 f4       	brcc	.+2      	; 0x889c <Put_zDVal+0x62>
    889a:	e5 c0       	rjmp	.+458    	; 0x8a66 <Put_zDVal+0x22c>
		Param->Txt += Idx;
		PutEnum(Param);
		return;
	}

	if(Param->Size==10 && Param->Prec==0){
    889c:	d3 01       	movw	r26, r6
    889e:	13 96       	adiw	r26, 0x03	; 3
    88a0:	8c 91       	ld	r24, X
    88a2:	13 97       	sbiw	r26, 0x03	; 3
    88a4:	8a 30       	cpi	r24, 0x0A	; 10
    88a6:	09 f4       	brne	.+2      	; 0x88aa <Put_zDVal+0x70>
    88a8:	72 c0       	rjmp	.+228    	; 0x898e <Put_zDVal+0x154>
		sprintf(Param->Pos, "%010lu", Val);
		return;
	}
	char Format[] = "%0 lu.%. lu";
    88aa:	de 01       	movw	r26, r28
    88ac:	11 96       	adiw	r26, 0x01	; 1
    88ae:	e7 e4       	ldi	r30, 0x47	; 71
    88b0:	f2 e0       	ldi	r31, 0x02	; 2
    88b2:	8c e0       	ldi	r24, 0x0C	; 12
    88b4:	01 90       	ld	r0, Z+
    88b6:	0d 92       	st	X+, r0
    88b8:	81 50       	subi	r24, 0x01	; 1
    88ba:	e1 f7       	brne	.-8      	; 0x88b4 <Put_zDVal+0x7a>
	Format[2] = '0'+Param->Size;
    88bc:	d3 01       	movw	r26, r6
    88be:	13 96       	adiw	r26, 0x03	; 3
    88c0:	2c 91       	ld	r18, X
    88c2:	13 97       	sbiw	r26, 0x03	; 3
    88c4:	20 5d       	subi	r18, 0xD0	; 208
    88c6:	2b 83       	std	Y+3, r18	; 0x03
	if(Param->Prec) {
    88c8:	12 96       	adiw	r26, 0x02	; 2
    88ca:	9c 91       	ld	r25, X
    88cc:	99 23       	and	r25, r25
    88ce:	09 f4       	brne	.+2      	; 0x88d2 <Put_zDVal+0x98>
    88d0:	a0 c0       	rjmp	.+320    	; 0x8a12 <Put_zDVal+0x1d8>
		Format[2] -= Param->Prec+1;
    88d2:	89 2f       	mov	r24, r25
    88d4:	80 95       	com	r24
    88d6:	82 0f       	add	r24, r18
    88d8:	8b 83       	std	Y+3, r24	; 0x03
		Format[8] = '0'+Param->Prec;
    88da:	90 5d       	subi	r25, 0xD0	; 208
    88dc:	99 87       	std	Y+9, r25	; 0x09
    88de:	90 53       	subi	r25, 0x30	; 48
		uint32_t Div=PowL10(Param->Prec);
    88e0:	09 2f       	mov	r16, r25
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
	uint32_t Pow = 1;
	while(Exp--)
    88e2:	61 e0       	ldi	r22, 0x01	; 1
    88e4:	86 2e       	mov	r8, r22
    88e6:	91 2c       	mov	r9, r1
    88e8:	a1 2c       	mov	r10, r1
    88ea:	b1 2c       	mov	r11, r1
		Pow *= 10;
    88ec:	c5 01       	movw	r24, r10
    88ee:	b4 01       	movw	r22, r8
    88f0:	2a e0       	ldi	r18, 0x0A	; 10
    88f2:	30 e0       	ldi	r19, 0x00	; 0
    88f4:	40 e0       	ldi	r20, 0x00	; 0
    88f6:	50 e0       	ldi	r21, 0x00	; 0
    88f8:	0e 94 17 82 	call	0x1042e	; 0x1042e <__mulsi3>
    88fc:	4b 01       	movw	r8, r22
    88fe:	5c 01       	movw	r10, r24
    8900:	01 50       	subi	r16, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
	uint32_t Pow = 1;
	while(Exp--)
    8902:	a1 f7       	brne	.-24     	; 0x88ec <Put_zDVal+0xb2>
    8904:	c2 01       	movw	r24, r4
    8906:	b1 01       	movw	r22, r2
    8908:	94 01       	movw	r18, r8
    890a:	a5 01       	movw	r20, r10
    890c:	0e 94 69 82 	call	0x104d2	; 0x104d2 <__udivmodsi4>
    8910:	f6 2e       	mov	r15, r22
    8912:	e7 2e       	mov	r14, r23
    8914:	d8 2e       	mov	r13, r24
    8916:	c9 2e       	mov	r12, r25
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
    8918:	ed b7       	in	r30, 0x3d	; 61
    891a:	fe b7       	in	r31, 0x3e	; 62
    891c:	3c 97       	sbiw	r30, 0x0c	; 12
    891e:	0f b6       	in	r0, 0x3f	; 63
    8920:	f8 94       	cli
    8922:	fe bf       	out	0x3e, r31	; 62
    8924:	0f be       	out	0x3f, r0	; 63
    8926:	ed bf       	out	0x3d, r30	; 61
    8928:	0d b7       	in	r16, 0x3d	; 61
    892a:	1e b7       	in	r17, 0x3e	; 62
    892c:	0f 5f       	subi	r16, 0xFF	; 255
    892e:	1f 4f       	sbci	r17, 0xFF	; 255
    8930:	d3 01       	movw	r26, r6
    8932:	8d 91       	ld	r24, X+
    8934:	9c 91       	ld	r25, X
    8936:	92 83       	std	Z+2, r25	; 0x02
    8938:	81 83       	std	Z+1, r24	; 0x01
    893a:	81 e0       	ldi	r24, 0x01	; 1
    893c:	90 e0       	ldi	r25, 0x00	; 0
    893e:	8c 0f       	add	r24, r28
    8940:	9d 1f       	adc	r25, r29
    8942:	f8 01       	movw	r30, r16
    8944:	93 83       	std	Z+3, r25	; 0x03
    8946:	82 83       	std	Z+2, r24	; 0x02
    8948:	c2 01       	movw	r24, r4
    894a:	b1 01       	movw	r22, r2
    894c:	a5 01       	movw	r20, r10
    894e:	94 01       	movw	r18, r8
    8950:	0e 94 69 82 	call	0x104d2	; 0x104d2 <__udivmodsi4>
    8954:	d8 01       	movw	r26, r16
    8956:	14 96       	adiw	r26, 0x04	; 4
    8958:	2d 93       	st	X+, r18
    895a:	3d 93       	st	X+, r19
    895c:	4d 93       	st	X+, r20
    895e:	5c 93       	st	X, r21
    8960:	17 97       	sbiw	r26, 0x07	; 7
    8962:	18 96       	adiw	r26, 0x08	; 8
    8964:	fc 92       	st	X, r15
    8966:	18 97       	sbiw	r26, 0x08	; 8
    8968:	19 96       	adiw	r26, 0x09	; 9
    896a:	ec 92       	st	X, r14
    896c:	19 97       	sbiw	r26, 0x09	; 9
    896e:	1a 96       	adiw	r26, 0x0a	; 10
    8970:	dc 92       	st	X, r13
    8972:	1a 97       	sbiw	r26, 0x0a	; 10
    8974:	1b 96       	adiw	r26, 0x0b	; 11
    8976:	cc 92       	st	X, r12
    8978:	0e 94 ad 7f 	call	0xff5a	; 0xff5a <sprintf>
    897c:	ed b7       	in	r30, 0x3d	; 61
    897e:	fe b7       	in	r31, 0x3e	; 62
    8980:	3c 96       	adiw	r30, 0x0c	; 12
    8982:	0f b6       	in	r0, 0x3f	; 63
    8984:	f8 94       	cli
    8986:	fe bf       	out	0x3e, r31	; 62
    8988:	0f be       	out	0x3f, r0	; 63
    898a:	ed bf       	out	0x3d, r30	; 61
    898c:	29 c0       	rjmp	.+82     	; 0x89e0 <Put_zDVal+0x1a6>
		Param->Txt += Idx;
		PutEnum(Param);
		return;
	}

	if(Param->Size==10 && Param->Prec==0){
    898e:	12 96       	adiw	r26, 0x02	; 2
    8990:	8c 91       	ld	r24, X
    8992:	12 97       	sbiw	r26, 0x02	; 2
    8994:	88 23       	and	r24, r24
    8996:	09 f0       	breq	.+2      	; 0x899a <Put_zDVal+0x160>
    8998:	88 cf       	rjmp	.-240    	; 0x88aa <Put_zDVal+0x70>
		sprintf(Param->Pos, "%010lu", Val);
    899a:	ed b7       	in	r30, 0x3d	; 61
    899c:	fe b7       	in	r31, 0x3e	; 62
    899e:	38 97       	sbiw	r30, 0x08	; 8
    89a0:	0f b6       	in	r0, 0x3f	; 63
    89a2:	f8 94       	cli
    89a4:	fe bf       	out	0x3e, r31	; 62
    89a6:	0f be       	out	0x3f, r0	; 63
    89a8:	ed bf       	out	0x3d, r30	; 61
    89aa:	31 96       	adiw	r30, 0x01	; 1
    89ac:	8d 91       	ld	r24, X+
    89ae:	9c 91       	ld	r25, X
    89b0:	ad b7       	in	r26, 0x3d	; 61
    89b2:	be b7       	in	r27, 0x3e	; 62
    89b4:	12 96       	adiw	r26, 0x02	; 2
    89b6:	9c 93       	st	X, r25
    89b8:	8e 93       	st	-X, r24
    89ba:	11 97       	sbiw	r26, 0x01	; 1
    89bc:	80 e4       	ldi	r24, 0x40	; 64
    89be:	92 e0       	ldi	r25, 0x02	; 2
    89c0:	93 83       	std	Z+3, r25	; 0x03
    89c2:	82 83       	std	Z+2, r24	; 0x02
    89c4:	24 82       	std	Z+4, r2	; 0x04
    89c6:	35 82       	std	Z+5, r3	; 0x05
    89c8:	46 82       	std	Z+6, r4	; 0x06
    89ca:	57 82       	std	Z+7, r5	; 0x07
    89cc:	0e 94 ad 7f 	call	0xff5a	; 0xff5a <sprintf>
    89d0:	ed b7       	in	r30, 0x3d	; 61
    89d2:	fe b7       	in	r31, 0x3e	; 62
    89d4:	38 96       	adiw	r30, 0x08	; 8
    89d6:	0f b6       	in	r0, 0x3f	; 63
    89d8:	f8 94       	cli
    89da:	fe bf       	out	0x3e, r31	; 62
    89dc:	0f be       	out	0x3f, r0	; 63
    89de:	ed bf       	out	0x3d, r30	; 61
	}
	else {
		Format[5] = '\0';
		sprintf(Param->Pos, Format, Val);
	}
}
    89e0:	2c 96       	adiw	r28, 0x0c	; 12
    89e2:	0f b6       	in	r0, 0x3f	; 63
    89e4:	f8 94       	cli
    89e6:	de bf       	out	0x3e, r29	; 62
    89e8:	0f be       	out	0x3f, r0	; 63
    89ea:	cd bf       	out	0x3d, r28	; 61
    89ec:	cf 91       	pop	r28
    89ee:	df 91       	pop	r29
    89f0:	1f 91       	pop	r17
    89f2:	0f 91       	pop	r16
    89f4:	ff 90       	pop	r15
    89f6:	ef 90       	pop	r14
    89f8:	df 90       	pop	r13
    89fa:	cf 90       	pop	r12
    89fc:	bf 90       	pop	r11
    89fe:	af 90       	pop	r10
    8a00:	9f 90       	pop	r9
    8a02:	8f 90       	pop	r8
    8a04:	7f 90       	pop	r7
    8a06:	6f 90       	pop	r6
    8a08:	5f 90       	pop	r5
    8a0a:	4f 90       	pop	r4
    8a0c:	3f 90       	pop	r3
    8a0e:	2f 90       	pop	r2
    8a10:	08 95       	ret
		Format[8] = '0'+Param->Prec;
		uint32_t Div=PowL10(Param->Prec);
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
	}
	else {
		Format[5] = '\0';
    8a12:	1e 82       	std	Y+6, r1	; 0x06
		sprintf(Param->Pos, Format, Val);
    8a14:	8d b7       	in	r24, 0x3d	; 61
    8a16:	9e b7       	in	r25, 0x3e	; 62
    8a18:	08 97       	sbiw	r24, 0x08	; 8
    8a1a:	0f b6       	in	r0, 0x3f	; 63
    8a1c:	f8 94       	cli
    8a1e:	9e bf       	out	0x3e, r25	; 62
    8a20:	0f be       	out	0x3f, r0	; 63
    8a22:	8d bf       	out	0x3d, r24	; 61
    8a24:	ed b7       	in	r30, 0x3d	; 61
    8a26:	fe b7       	in	r31, 0x3e	; 62
    8a28:	31 96       	adiw	r30, 0x01	; 1
    8a2a:	d3 01       	movw	r26, r6
    8a2c:	8d 91       	ld	r24, X+
    8a2e:	9c 91       	ld	r25, X
    8a30:	ad b7       	in	r26, 0x3d	; 61
    8a32:	be b7       	in	r27, 0x3e	; 62
    8a34:	12 96       	adiw	r26, 0x02	; 2
    8a36:	9c 93       	st	X, r25
    8a38:	8e 93       	st	-X, r24
    8a3a:	11 97       	sbiw	r26, 0x01	; 1
    8a3c:	81 e0       	ldi	r24, 0x01	; 1
    8a3e:	90 e0       	ldi	r25, 0x00	; 0
    8a40:	8c 0f       	add	r24, r28
    8a42:	9d 1f       	adc	r25, r29
    8a44:	93 83       	std	Z+3, r25	; 0x03
    8a46:	82 83       	std	Z+2, r24	; 0x02
    8a48:	24 82       	std	Z+4, r2	; 0x04
    8a4a:	35 82       	std	Z+5, r3	; 0x05
    8a4c:	46 82       	std	Z+6, r4	; 0x06
    8a4e:	57 82       	std	Z+7, r5	; 0x07
    8a50:	0e 94 ad 7f 	call	0xff5a	; 0xff5a <sprintf>
    8a54:	ad b7       	in	r26, 0x3d	; 61
    8a56:	be b7       	in	r27, 0x3e	; 62
    8a58:	18 96       	adiw	r26, 0x08	; 8
    8a5a:	0f b6       	in	r0, 0x3f	; 63
    8a5c:	f8 94       	cli
    8a5e:	be bf       	out	0x3e, r27	; 62
    8a60:	0f be       	out	0x3f, r0	; 63
    8a62:	ad bf       	out	0x3d, r26	; 61
    8a64:	bd cf       	rjmp	.-134    	; 0x89e0 <Put_zDVal+0x1a6>
void 
Put_zDVal(uint32_t Val, T_Param *Param)
{
	uint32_t Idx = 0xFFFFFFFF-Val;
	if(Param->Txt && Idx<2) {
		Param->Txt += Idx;
    8a66:	88 0f       	add	r24, r24
    8a68:	99 1f       	adc	r25, r25
    8a6a:	28 0f       	add	r18, r24
    8a6c:	39 1f       	adc	r19, r25
    8a6e:	fa 01       	movw	r30, r20
    8a70:	35 83       	std	Z+5, r19	; 0x05
    8a72:	24 83       	std	Z+4, r18	; 0x04
		PutEnum(Param);
    8a74:	ca 01       	movw	r24, r20
    8a76:	0e 94 9e 40 	call	0x813c	; 0x813c <PutEnum>
    8a7a:	b2 cf       	rjmp	.-156    	; 0x89e0 <Put_zDVal+0x1a6>

00008a7c <Put_sDVal>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Put_sDVal - print signed Longint in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_sDVal(int32_t Val, T_Param *Param)
{
    8a7c:	cf 92       	push	r12
    8a7e:	df 92       	push	r13
    8a80:	ef 92       	push	r14
    8a82:	ff 92       	push	r15
    8a84:	0f 93       	push	r16
    8a86:	1f 93       	push	r17
    8a88:	df 93       	push	r29
    8a8a:	cf 93       	push	r28
    8a8c:	cd b7       	in	r28, 0x3d	; 61
    8a8e:	de b7       	in	r29, 0x3e	; 62
    8a90:	2d 97       	sbiw	r28, 0x0d	; 13
    8a92:	0f b6       	in	r0, 0x3f	; 63
    8a94:	f8 94       	cli
    8a96:	de bf       	out	0x3e, r29	; 62
    8a98:	0f be       	out	0x3f, r0	; 63
    8a9a:	cd bf       	out	0x3d, r28	; 61
    8a9c:	6b 01       	movw	r12, r22
    8a9e:	7c 01       	movw	r14, r24
    8aa0:	8a 01       	movw	r16, r20
	uint32_t Idx = 0x80000000+Val;
	if(Param->Txt && Idx<2) {
    8aa2:	da 01       	movw	r26, r20
    8aa4:	14 96       	adiw	r26, 0x04	; 4
    8aa6:	2d 91       	ld	r18, X+
    8aa8:	3c 91       	ld	r19, X
    8aaa:	15 97       	sbiw	r26, 0x05	; 5
    8aac:	21 15       	cp	r18, r1
    8aae:	31 05       	cpc	r19, r1
    8ab0:	61 f0       	breq	.+24     	; 0x8aca <Put_sDVal+0x4e>
// Put_sDVal - print signed Longint in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_sDVal(int32_t Val, T_Param *Param)
{
	uint32_t Idx = 0x80000000+Val;
    8ab2:	dc 01       	movw	r26, r24
    8ab4:	cb 01       	movw	r24, r22
    8ab6:	80 50       	subi	r24, 0x00	; 0
    8ab8:	90 40       	sbci	r25, 0x00	; 0
    8aba:	a0 40       	sbci	r26, 0x00	; 0
    8abc:	b0 48       	sbci	r27, 0x80	; 128
	if(Param->Txt && Idx<2) {
    8abe:	82 30       	cpi	r24, 0x02	; 2
    8ac0:	91 05       	cpc	r25, r1
    8ac2:	a1 05       	cpc	r26, r1
    8ac4:	b1 05       	cpc	r27, r1
    8ac6:	08 f4       	brcc	.+2      	; 0x8aca <Put_sDVal+0x4e>
    8ac8:	f7 c0       	rjmp	.+494    	; 0x8cb8 <Put_sDVal+0x23c>
		Param->Txt += Idx;
		PutEnum(Param);
		return;
	}
	// standart specificator to print Longint in string
	if(Param->Size>9){
    8aca:	d8 01       	movw	r26, r16
    8acc:	13 96       	adiw	r26, 0x03	; 3
    8ace:	8c 91       	ld	r24, X
    8ad0:	8a 30       	cpi	r24, 0x0A	; 10
    8ad2:	f8 f0       	brcs	.+62     	; 0x8b12 <Put_sDVal+0x96>
		char Format[] = "%+1 ld";
    8ad4:	9e 01       	movw	r18, r28
    8ad6:	29 5f       	subi	r18, 0xF9	; 249
    8ad8:	3f 4f       	sbci	r19, 0xFF	; 255
    8ada:	d9 01       	movw	r26, r18
    8adc:	e3 e5       	ldi	r30, 0x53	; 83
    8ade:	f2 e0       	ldi	r31, 0x02	; 2
    8ae0:	87 e0       	ldi	r24, 0x07	; 7
    8ae2:	01 90       	ld	r0, Z+
    8ae4:	0d 92       	st	X+, r0
    8ae6:	81 50       	subi	r24, 0x01	; 1
    8ae8:	e1 f7       	brne	.-8      	; 0x8ae2 <Put_sDVal+0x66>
		Format[3] = '0'+Param->Size%10;
    8aea:	f8 01       	movw	r30, r16
    8aec:	83 81       	ldd	r24, Z+3	; 0x03
    8aee:	6a e0       	ldi	r22, 0x0A	; 10
    8af0:	0e 94 36 82 	call	0x1046c	; 0x1046c <__udivmodqi4>
    8af4:	90 5d       	subi	r25, 0xD0	; 208
    8af6:	9a 87       	std	Y+10, r25	; 0x0a
		sprintf(Param->Pos, Format, Val);
    8af8:	8d b7       	in	r24, 0x3d	; 61
    8afa:	9e b7       	in	r25, 0x3e	; 62
    8afc:	08 97       	sbiw	r24, 0x08	; 8
    8afe:	0f b6       	in	r0, 0x3f	; 63
    8b00:	f8 94       	cli
    8b02:	9e bf       	out	0x3e, r25	; 62
    8b04:	0f be       	out	0x3f, r0	; 63
    8b06:	8d bf       	out	0x3d, r24	; 61
    8b08:	ed b7       	in	r30, 0x3d	; 61
    8b0a:	fe b7       	in	r31, 0x3e	; 62
    8b0c:	31 96       	adiw	r30, 0x01	; 1
    8b0e:	d8 01       	movw	r26, r16
    8b10:	1a c0       	rjmp	.+52     	; 0x8b46 <Put_sDVal+0xca>
	}
	else{
		char Format[] = "%+ ld";
    8b12:	9e 01       	movw	r18, r28
    8b14:	2f 5f       	subi	r18, 0xFF	; 255
    8b16:	3f 4f       	sbci	r19, 0xFF	; 255
    8b18:	d9 01       	movw	r26, r18
    8b1a:	ea e5       	ldi	r30, 0x5A	; 90
    8b1c:	f2 e0       	ldi	r31, 0x02	; 2
    8b1e:	86 e0       	ldi	r24, 0x06	; 6
    8b20:	01 90       	ld	r0, Z+
    8b22:	0d 92       	st	X+, r0
    8b24:	81 50       	subi	r24, 0x01	; 1
    8b26:	e1 f7       	brne	.-8      	; 0x8b20 <Put_sDVal+0xa4>
		Format[2] = '0'+Param->Size;
    8b28:	d8 01       	movw	r26, r16
    8b2a:	13 96       	adiw	r26, 0x03	; 3
    8b2c:	8c 91       	ld	r24, X
    8b2e:	13 97       	sbiw	r26, 0x03	; 3
    8b30:	80 5d       	subi	r24, 0xD0	; 208
    8b32:	8b 83       	std	Y+3, r24	; 0x03
		sprintf(Param->Pos, Format, Val);
    8b34:	ed b7       	in	r30, 0x3d	; 61
    8b36:	fe b7       	in	r31, 0x3e	; 62
    8b38:	38 97       	sbiw	r30, 0x08	; 8
    8b3a:	0f b6       	in	r0, 0x3f	; 63
    8b3c:	f8 94       	cli
    8b3e:	fe bf       	out	0x3e, r31	; 62
    8b40:	0f be       	out	0x3f, r0	; 63
    8b42:	ed bf       	out	0x3d, r30	; 61
    8b44:	31 96       	adiw	r30, 0x01	; 1
    8b46:	8d 91       	ld	r24, X+
    8b48:	9c 91       	ld	r25, X
    8b4a:	ad b7       	in	r26, 0x3d	; 61
    8b4c:	be b7       	in	r27, 0x3e	; 62
    8b4e:	12 96       	adiw	r26, 0x02	; 2
    8b50:	9c 93       	st	X, r25
    8b52:	8e 93       	st	-X, r24
    8b54:	11 97       	sbiw	r26, 0x01	; 1
    8b56:	33 83       	std	Z+3, r19	; 0x03
    8b58:	22 83       	std	Z+2, r18	; 0x02
    8b5a:	c4 82       	std	Z+4, r12	; 0x04
    8b5c:	d5 82       	std	Z+5, r13	; 0x05
    8b5e:	e6 82       	std	Z+6, r14	; 0x06
    8b60:	f7 82       	std	Z+7, r15	; 0x07
    8b62:	0e 94 ad 7f 	call	0xff5a	; 0xff5a <sprintf>
    8b66:	ed b7       	in	r30, 0x3d	; 61
    8b68:	fe b7       	in	r31, 0x3e	; 62
    8b6a:	38 96       	adiw	r30, 0x08	; 8
    8b6c:	0f b6       	in	r0, 0x3f	; 63
    8b6e:	f8 94       	cli
    8b70:	fe bf       	out	0x3e, r31	; 62
    8b72:	0f be       	out	0x3f, r0	; 63
    8b74:	ed bf       	out	0x3d, r30	; 61
	}
	//Delete sign if zero
	if(!Val)Param->Pos[Param->Size-2] = ' ';
    8b76:	c1 14       	cp	r12, r1
    8b78:	d1 04       	cpc	r13, r1
    8b7a:	e1 04       	cpc	r14, r1
    8b7c:	f1 04       	cpc	r15, r1
    8b7e:	59 f4       	brne	.+22     	; 0x8b96 <Put_sDVal+0x11a>
    8b80:	d8 01       	movw	r26, r16
    8b82:	13 96       	adiw	r26, 0x03	; 3
    8b84:	8c 91       	ld	r24, X
    8b86:	13 97       	sbiw	r26, 0x03	; 3
    8b88:	ed 91       	ld	r30, X+
    8b8a:	fc 91       	ld	r31, X
    8b8c:	e8 0f       	add	r30, r24
    8b8e:	f1 1d       	adc	r31, r1
    8b90:	32 97       	sbiw	r30, 0x02	; 2
    8b92:	80 e2       	ldi	r24, 0x20	; 32
    8b94:	80 83       	st	Z, r24

	if(Param->Prec){
    8b96:	f8 01       	movw	r30, r16
    8b98:	92 81       	ldd	r25, Z+2	; 0x02
    8b9a:	99 23       	and	r25, r25
    8b9c:	09 f4       	brne	.+2      	; 0x8ba0 <Put_sDVal+0x124>
    8b9e:	41 c0       	rjmp	.+130    	; 0x8c22 <Put_sDVal+0x1a6>
		//Insert decimal point
		for(uint8_t i=0; i< Param->Size - Param->Prec; i++){
    8ba0:	83 81       	ldd	r24, Z+3	; 0x03
    8ba2:	28 2f       	mov	r18, r24
    8ba4:	30 e0       	ldi	r19, 0x00	; 0
    8ba6:	29 1b       	sub	r18, r25
    8ba8:	31 09       	sbc	r19, r1
    8baa:	12 16       	cp	r1, r18
    8bac:	13 06       	cpc	r1, r19
    8bae:	d4 f4       	brge	.+52     	; 0x8be4 <Put_sDVal+0x168>
    8bb0:	40 e0       	ldi	r20, 0x00	; 0
    8bb2:	80 e0       	ldi	r24, 0x00	; 0
    8bb4:	90 e0       	ldi	r25, 0x00	; 0
			Param->Pos[i] = Param->Pos[i+1];
    8bb6:	d8 01       	movw	r26, r16
    8bb8:	ed 91       	ld	r30, X+
    8bba:	fc 91       	ld	r31, X
    8bbc:	11 97       	sbiw	r26, 0x01	; 1
    8bbe:	e8 0f       	add	r30, r24
    8bc0:	f9 1f       	adc	r31, r25
    8bc2:	81 81       	ldd	r24, Z+1	; 0x01
    8bc4:	80 83       	st	Z, r24
	//Delete sign if zero
	if(!Val)Param->Pos[Param->Size-2] = ' ';

	if(Param->Prec){
		//Insert decimal point
		for(uint8_t i=0; i< Param->Size - Param->Prec; i++){
    8bc6:	4f 5f       	subi	r20, 0xFF	; 255
    8bc8:	13 96       	adiw	r26, 0x03	; 3
    8bca:	8c 91       	ld	r24, X
    8bcc:	13 97       	sbiw	r26, 0x03	; 3
    8bce:	28 2f       	mov	r18, r24
    8bd0:	30 e0       	ldi	r19, 0x00	; 0
    8bd2:	12 96       	adiw	r26, 0x02	; 2
    8bd4:	8c 91       	ld	r24, X
    8bd6:	28 1b       	sub	r18, r24
    8bd8:	31 09       	sbc	r19, r1
    8bda:	84 2f       	mov	r24, r20
    8bdc:	90 e0       	ldi	r25, 0x00	; 0
    8bde:	82 17       	cp	r24, r18
    8be0:	93 07       	cpc	r25, r19
    8be2:	4c f3       	brlt	.-46     	; 0x8bb6 <Put_sDVal+0x13a>
			Param->Pos[i] = Param->Pos[i+1];
		}
		Param->Pos[Param->Size - Param->Prec-1] = '.';
    8be4:	d8 01       	movw	r26, r16
    8be6:	ed 91       	ld	r30, X+
    8be8:	fc 91       	ld	r31, X
    8bea:	11 97       	sbiw	r26, 0x01	; 1
    8bec:	e2 0f       	add	r30, r18
    8bee:	f3 1f       	adc	r31, r19
    8bf0:	31 97       	sbiw	r30, 0x01	; 1
    8bf2:	8e e2       	ldi	r24, 0x2E	; 46
    8bf4:	80 83       	st	Z, r24
		//Fill zeros and shift sign for correct view
		char c = Param->Pos[Param->Size - Param->Prec-2];
    8bf6:	4d 91       	ld	r20, X+
    8bf8:	5c 91       	ld	r21, X
    8bfa:	11 97       	sbiw	r26, 0x01	; 1
    8bfc:	13 96       	adiw	r26, 0x03	; 3
    8bfe:	9c 91       	ld	r25, X
    8c00:	13 97       	sbiw	r26, 0x03	; 3
    8c02:	e9 2f       	mov	r30, r25
    8c04:	f0 e0       	ldi	r31, 0x00	; 0
    8c06:	12 96       	adiw	r26, 0x02	; 2
    8c08:	8c 91       	ld	r24, X
    8c0a:	e8 1b       	sub	r30, r24
    8c0c:	f1 09       	sbc	r31, r1
    8c0e:	e4 0f       	add	r30, r20
    8c10:	f5 1f       	adc	r31, r21
    8c12:	32 97       	sbiw	r30, 0x02	; 2
    8c14:	e0 81       	ld	r30, Z
		if(c ==' ' || c =='+' || c =='-'){
    8c16:	e0 32       	cpi	r30, 0x20	; 32
    8c18:	99 f0       	breq	.+38     	; 0x8c40 <Put_sDVal+0x1c4>
    8c1a:	eb 32       	cpi	r30, 0x2B	; 43
    8c1c:	89 f0       	breq	.+34     	; 0x8c40 <Put_sDVal+0x1c4>
    8c1e:	ed 32       	cpi	r30, 0x2D	; 45
    8c20:	79 f0       	breq	.+30     	; 0x8c40 <Put_sDVal+0x1c4>
				}
			}
		}
	}

}
    8c22:	2d 96       	adiw	r28, 0x0d	; 13
    8c24:	0f b6       	in	r0, 0x3f	; 63
    8c26:	f8 94       	cli
    8c28:	de bf       	out	0x3e, r29	; 62
    8c2a:	0f be       	out	0x3f, r0	; 63
    8c2c:	cd bf       	out	0x3d, r28	; 61
    8c2e:	cf 91       	pop	r28
    8c30:	df 91       	pop	r29
    8c32:	1f 91       	pop	r17
    8c34:	0f 91       	pop	r16
    8c36:	ff 90       	pop	r15
    8c38:	ef 90       	pop	r14
    8c3a:	df 90       	pop	r13
    8c3c:	cf 90       	pop	r12
    8c3e:	08 95       	ret
		}
		Param->Pos[Param->Size - Param->Prec-1] = '.';
		//Fill zeros and shift sign for correct view
		char c = Param->Pos[Param->Size - Param->Prec-2];
		if(c ==' ' || c =='+' || c =='-'){
			for(uint8_t i=Param->Size-1; i>1; i--){
    8c40:	e9 2f       	mov	r30, r25
    8c42:	e1 50       	subi	r30, 0x01	; 1
    8c44:	e2 30       	cpi	r30, 0x02	; 2
    8c46:	68 f3       	brcs	.-38     	; 0x8c22 <Put_sDVal+0x1a6>
				if(Param->Pos[i] == ' '|| Param->Pos[i] == '+' || Param->Pos[i] == '-' ) Param->Pos[i]='0';
    8c48:	90 e3       	ldi	r25, 0x30	; 48
    8c4a:	09 c0       	rjmp	.+18     	; 0x8c5e <Put_sDVal+0x1e2>
    8c4c:	8b 32       	cpi	r24, 0x2B	; 43
    8c4e:	79 f0       	breq	.+30     	; 0x8c6e <Put_sDVal+0x1f2>
    8c50:	8d 32       	cpi	r24, 0x2D	; 45
    8c52:	69 f0       	breq	.+26     	; 0x8c6e <Put_sDVal+0x1f2>
				if(Param->Pos[i] == '.'){
    8c54:	8e 32       	cpi	r24, 0x2E	; 46
    8c56:	a9 f0       	breq	.+42     	; 0x8c82 <Put_sDVal+0x206>
		}
		Param->Pos[Param->Size - Param->Prec-1] = '.';
		//Fill zeros and shift sign for correct view
		char c = Param->Pos[Param->Size - Param->Prec-2];
		if(c ==' ' || c =='+' || c =='-'){
			for(uint8_t i=Param->Size-1; i>1; i--){
    8c58:	e1 50       	subi	r30, 0x01	; 1
    8c5a:	e2 30       	cpi	r30, 0x02	; 2
    8c5c:	10 f3       	brcs	.-60     	; 0x8c22 <Put_sDVal+0x1a6>
				if(Param->Pos[i] == ' '|| Param->Pos[i] == '+' || Param->Pos[i] == '-' ) Param->Pos[i]='0';
    8c5e:	2e 2f       	mov	r18, r30
    8c60:	30 e0       	ldi	r19, 0x00	; 0
    8c62:	da 01       	movw	r26, r20
    8c64:	a2 0f       	add	r26, r18
    8c66:	b3 1f       	adc	r27, r19
    8c68:	8c 91       	ld	r24, X
    8c6a:	80 32       	cpi	r24, 0x20	; 32
    8c6c:	79 f7       	brne	.-34     	; 0x8c4c <Put_sDVal+0x1d0>
    8c6e:	9c 93       	st	X, r25
    8c70:	d8 01       	movw	r26, r16
    8c72:	4d 91       	ld	r20, X+
    8c74:	5c 91       	ld	r21, X
    8c76:	da 01       	movw	r26, r20
    8c78:	a2 0f       	add	r26, r18
    8c7a:	b3 1f       	adc	r27, r19
    8c7c:	8c 91       	ld	r24, X
				if(Param->Pos[i] == '.'){
    8c7e:	8e 32       	cpi	r24, 0x2E	; 46
    8c80:	59 f7       	brne	.-42     	; 0x8c58 <Put_sDVal+0x1dc>
					Param->Pos[i-1]='0';
    8c82:	11 97       	sbiw	r26, 0x01	; 1
    8c84:	80 e3       	ldi	r24, 0x30	; 48
    8c86:	8c 93       	st	X, r24
					if(Val>0)Param->Pos[i-2]='+';
    8c88:	1c 14       	cp	r1, r12
    8c8a:	1d 04       	cpc	r1, r13
    8c8c:	1e 04       	cpc	r1, r14
    8c8e:	1f 04       	cpc	r1, r15
    8c90:	44 f4       	brge	.+16     	; 0x8ca2 <Put_sDVal+0x226>
    8c92:	d8 01       	movw	r26, r16
    8c94:	ed 91       	ld	r30, X+
    8c96:	fc 91       	ld	r31, X
    8c98:	e2 0f       	add	r30, r18
    8c9a:	f3 1f       	adc	r31, r19
    8c9c:	32 97       	sbiw	r30, 0x02	; 2
    8c9e:	8b e2       	ldi	r24, 0x2B	; 43
    8ca0:	80 83       	st	Z, r24
					if(Val<0)Param->Pos[i-2]='-';
    8ca2:	f7 fe       	sbrs	r15, 7
    8ca4:	be cf       	rjmp	.-132    	; 0x8c22 <Put_sDVal+0x1a6>
    8ca6:	d8 01       	movw	r26, r16
    8ca8:	ed 91       	ld	r30, X+
    8caa:	fc 91       	ld	r31, X
    8cac:	e2 0f       	add	r30, r18
    8cae:	f3 1f       	adc	r31, r19
    8cb0:	32 97       	sbiw	r30, 0x02	; 2
    8cb2:	8d e2       	ldi	r24, 0x2D	; 45
    8cb4:	80 83       	st	Z, r24
    8cb6:	b5 cf       	rjmp	.-150    	; 0x8c22 <Put_sDVal+0x1a6>
void
Put_sDVal(int32_t Val, T_Param *Param)
{
	uint32_t Idx = 0x80000000+Val;
	if(Param->Txt && Idx<2) {
		Param->Txt += Idx;
    8cb8:	88 0f       	add	r24, r24
    8cba:	99 1f       	adc	r25, r25
    8cbc:	28 0f       	add	r18, r24
    8cbe:	39 1f       	adc	r19, r25
    8cc0:	fa 01       	movw	r30, r20
    8cc2:	35 83       	std	Z+5, r19	; 0x05
    8cc4:	24 83       	std	Z+4, r18	; 0x04
		PutEnum(Param);
    8cc6:	ca 01       	movw	r24, r20
    8cc8:	0e 94 9e 40 	call	0x813c	; 0x813c <PutEnum>
    8ccc:	aa cf       	rjmp	.-172    	; 0x8c22 <Put_sDVal+0x1a6>

00008cce <PutDVal>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// PutDVal - print unsigned Longint in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
PutDVal(uint32_t Val, T_Param *Param)
{
    8cce:	2f 92       	push	r2
    8cd0:	3f 92       	push	r3
    8cd2:	4f 92       	push	r4
    8cd4:	5f 92       	push	r5
    8cd6:	6f 92       	push	r6
    8cd8:	7f 92       	push	r7
    8cda:	8f 92       	push	r8
    8cdc:	9f 92       	push	r9
    8cde:	af 92       	push	r10
    8ce0:	bf 92       	push	r11
    8ce2:	cf 92       	push	r12
    8ce4:	df 92       	push	r13
    8ce6:	ef 92       	push	r14
    8ce8:	ff 92       	push	r15
    8cea:	0f 93       	push	r16
    8cec:	1f 93       	push	r17
    8cee:	df 93       	push	r29
    8cf0:	cf 93       	push	r28
    8cf2:	cd b7       	in	r28, 0x3d	; 61
    8cf4:	de b7       	in	r29, 0x3e	; 62
    8cf6:	2b 97       	sbiw	r28, 0x0b	; 11
    8cf8:	0f b6       	in	r0, 0x3f	; 63
    8cfa:	f8 94       	cli
    8cfc:	de bf       	out	0x3e, r29	; 62
    8cfe:	0f be       	out	0x3f, r0	; 63
    8d00:	cd bf       	out	0x3d, r28	; 61
    8d02:	1b 01       	movw	r2, r22
    8d04:	2c 01       	movw	r4, r24
    8d06:	3a 01       	movw	r6, r20
	uint32_t Idx = 0xFFFFFFFF-Val;
	if(Param->Txt && Idx<2) {
    8d08:	da 01       	movw	r26, r20
    8d0a:	14 96       	adiw	r26, 0x04	; 4
    8d0c:	2d 91       	ld	r18, X+
    8d0e:	3c 91       	ld	r19, X
    8d10:	15 97       	sbiw	r26, 0x05	; 5
    8d12:	21 15       	cp	r18, r1
    8d14:	31 05       	cpc	r19, r1
    8d16:	61 f0       	breq	.+24     	; 0x8d30 <PutDVal+0x62>
// PutDVal - print unsigned Longint in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
PutDVal(uint32_t Val, T_Param *Param)
{
	uint32_t Idx = 0xFFFFFFFF-Val;
    8d18:	dc 01       	movw	r26, r24
    8d1a:	cb 01       	movw	r24, r22
    8d1c:	80 95       	com	r24
    8d1e:	90 95       	com	r25
    8d20:	a0 95       	com	r26
    8d22:	b0 95       	com	r27
	if(Param->Txt && Idx<2) {
    8d24:	82 30       	cpi	r24, 0x02	; 2
    8d26:	91 05       	cpc	r25, r1
    8d28:	a1 05       	cpc	r26, r1
    8d2a:	b1 05       	cpc	r27, r1
    8d2c:	08 f4       	brcc	.+2      	; 0x8d30 <PutDVal+0x62>
    8d2e:	e5 c0       	rjmp	.+458    	; 0x8efa <PutDVal+0x22c>
		Param->Txt += Idx;
		PutEnum(Param);
		return;
	}

	if(Param->Size==10 && Param->Prec==0){
    8d30:	d3 01       	movw	r26, r6
    8d32:	13 96       	adiw	r26, 0x03	; 3
    8d34:	8c 91       	ld	r24, X
    8d36:	13 97       	sbiw	r26, 0x03	; 3
    8d38:	8a 30       	cpi	r24, 0x0A	; 10
    8d3a:	09 f4       	brne	.+2      	; 0x8d3e <PutDVal+0x70>
    8d3c:	72 c0       	rjmp	.+228    	; 0x8e22 <PutDVal+0x154>
		sprintf(Param->Pos, "%10lu", Val);
		return;
	}
	char Format[] = "% lu.%. lu";
    8d3e:	de 01       	movw	r26, r28
    8d40:	11 96       	adiw	r26, 0x01	; 1
    8d42:	e6 e6       	ldi	r30, 0x66	; 102
    8d44:	f2 e0       	ldi	r31, 0x02	; 2
    8d46:	8b e0       	ldi	r24, 0x0B	; 11
    8d48:	01 90       	ld	r0, Z+
    8d4a:	0d 92       	st	X+, r0
    8d4c:	81 50       	subi	r24, 0x01	; 1
    8d4e:	e1 f7       	brne	.-8      	; 0x8d48 <PutDVal+0x7a>
	Format[1] = '0'+Param->Size;
    8d50:	d3 01       	movw	r26, r6
    8d52:	13 96       	adiw	r26, 0x03	; 3
    8d54:	2c 91       	ld	r18, X
    8d56:	13 97       	sbiw	r26, 0x03	; 3
    8d58:	20 5d       	subi	r18, 0xD0	; 208
    8d5a:	2a 83       	std	Y+2, r18	; 0x02
	if(Param->Prec) {
    8d5c:	12 96       	adiw	r26, 0x02	; 2
    8d5e:	9c 91       	ld	r25, X
    8d60:	99 23       	and	r25, r25
    8d62:	09 f4       	brne	.+2      	; 0x8d66 <PutDVal+0x98>
    8d64:	a0 c0       	rjmp	.+320    	; 0x8ea6 <PutDVal+0x1d8>
		Format[1] -= Param->Prec+1;
    8d66:	89 2f       	mov	r24, r25
    8d68:	80 95       	com	r24
    8d6a:	82 0f       	add	r24, r18
    8d6c:	8a 83       	std	Y+2, r24	; 0x02
		Format[7] = '0'+Param->Prec;
    8d6e:	90 5d       	subi	r25, 0xD0	; 208
    8d70:	98 87       	std	Y+8, r25	; 0x08
    8d72:	90 53       	subi	r25, 0x30	; 48
		uint32_t Div=PowL10(Param->Prec);
    8d74:	09 2f       	mov	r16, r25
    8d76:	f1 e0       	ldi	r31, 0x01	; 1
    8d78:	8f 2e       	mov	r8, r31
    8d7a:	91 2c       	mov	r9, r1
    8d7c:	a1 2c       	mov	r10, r1
    8d7e:	b1 2c       	mov	r11, r1
		Pow *= 10;
    8d80:	c5 01       	movw	r24, r10
    8d82:	b4 01       	movw	r22, r8
    8d84:	2a e0       	ldi	r18, 0x0A	; 10
    8d86:	30 e0       	ldi	r19, 0x00	; 0
    8d88:	40 e0       	ldi	r20, 0x00	; 0
    8d8a:	50 e0       	ldi	r21, 0x00	; 0
    8d8c:	0e 94 17 82 	call	0x1042e	; 0x1042e <__mulsi3>
    8d90:	4b 01       	movw	r8, r22
    8d92:	5c 01       	movw	r10, r24
    8d94:	01 50       	subi	r16, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
	uint32_t Pow = 1;
	while(Exp--)
    8d96:	a1 f7       	brne	.-24     	; 0x8d80 <PutDVal+0xb2>
    8d98:	c2 01       	movw	r24, r4
    8d9a:	b1 01       	movw	r22, r2
    8d9c:	94 01       	movw	r18, r8
    8d9e:	a5 01       	movw	r20, r10
    8da0:	0e 94 69 82 	call	0x104d2	; 0x104d2 <__udivmodsi4>
    8da4:	f6 2e       	mov	r15, r22
    8da6:	e7 2e       	mov	r14, r23
    8da8:	d8 2e       	mov	r13, r24
    8daa:	c9 2e       	mov	r12, r25
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
    8dac:	ed b7       	in	r30, 0x3d	; 61
    8dae:	fe b7       	in	r31, 0x3e	; 62
    8db0:	3c 97       	sbiw	r30, 0x0c	; 12
    8db2:	0f b6       	in	r0, 0x3f	; 63
    8db4:	f8 94       	cli
    8db6:	fe bf       	out	0x3e, r31	; 62
    8db8:	0f be       	out	0x3f, r0	; 63
    8dba:	ed bf       	out	0x3d, r30	; 61
    8dbc:	0d b7       	in	r16, 0x3d	; 61
    8dbe:	1e b7       	in	r17, 0x3e	; 62
    8dc0:	0f 5f       	subi	r16, 0xFF	; 255
    8dc2:	1f 4f       	sbci	r17, 0xFF	; 255
    8dc4:	d3 01       	movw	r26, r6
    8dc6:	8d 91       	ld	r24, X+
    8dc8:	9c 91       	ld	r25, X
    8dca:	92 83       	std	Z+2, r25	; 0x02
    8dcc:	81 83       	std	Z+1, r24	; 0x01
    8dce:	81 e0       	ldi	r24, 0x01	; 1
    8dd0:	90 e0       	ldi	r25, 0x00	; 0
    8dd2:	8c 0f       	add	r24, r28
    8dd4:	9d 1f       	adc	r25, r29
    8dd6:	f8 01       	movw	r30, r16
    8dd8:	93 83       	std	Z+3, r25	; 0x03
    8dda:	82 83       	std	Z+2, r24	; 0x02
    8ddc:	c2 01       	movw	r24, r4
    8dde:	b1 01       	movw	r22, r2
    8de0:	a5 01       	movw	r20, r10
    8de2:	94 01       	movw	r18, r8
    8de4:	0e 94 69 82 	call	0x104d2	; 0x104d2 <__udivmodsi4>
    8de8:	d8 01       	movw	r26, r16
    8dea:	14 96       	adiw	r26, 0x04	; 4
    8dec:	2d 93       	st	X+, r18
    8dee:	3d 93       	st	X+, r19
    8df0:	4d 93       	st	X+, r20
    8df2:	5c 93       	st	X, r21
    8df4:	17 97       	sbiw	r26, 0x07	; 7
    8df6:	18 96       	adiw	r26, 0x08	; 8
    8df8:	fc 92       	st	X, r15
    8dfa:	18 97       	sbiw	r26, 0x08	; 8
    8dfc:	19 96       	adiw	r26, 0x09	; 9
    8dfe:	ec 92       	st	X, r14
    8e00:	19 97       	sbiw	r26, 0x09	; 9
    8e02:	1a 96       	adiw	r26, 0x0a	; 10
    8e04:	dc 92       	st	X, r13
    8e06:	1a 97       	sbiw	r26, 0x0a	; 10
    8e08:	1b 96       	adiw	r26, 0x0b	; 11
    8e0a:	cc 92       	st	X, r12
    8e0c:	0e 94 ad 7f 	call	0xff5a	; 0xff5a <sprintf>
    8e10:	ed b7       	in	r30, 0x3d	; 61
    8e12:	fe b7       	in	r31, 0x3e	; 62
    8e14:	3c 96       	adiw	r30, 0x0c	; 12
    8e16:	0f b6       	in	r0, 0x3f	; 63
    8e18:	f8 94       	cli
    8e1a:	fe bf       	out	0x3e, r31	; 62
    8e1c:	0f be       	out	0x3f, r0	; 63
    8e1e:	ed bf       	out	0x3d, r30	; 61
    8e20:	29 c0       	rjmp	.+82     	; 0x8e74 <PutDVal+0x1a6>
		Param->Txt += Idx;
		PutEnum(Param);
		return;
	}

	if(Param->Size==10 && Param->Prec==0){
    8e22:	12 96       	adiw	r26, 0x02	; 2
    8e24:	8c 91       	ld	r24, X
    8e26:	12 97       	sbiw	r26, 0x02	; 2
    8e28:	88 23       	and	r24, r24
    8e2a:	09 f0       	breq	.+2      	; 0x8e2e <PutDVal+0x160>
    8e2c:	88 cf       	rjmp	.-240    	; 0x8d3e <PutDVal+0x70>
		sprintf(Param->Pos, "%10lu", Val);
    8e2e:	ed b7       	in	r30, 0x3d	; 61
    8e30:	fe b7       	in	r31, 0x3e	; 62
    8e32:	38 97       	sbiw	r30, 0x08	; 8
    8e34:	0f b6       	in	r0, 0x3f	; 63
    8e36:	f8 94       	cli
    8e38:	fe bf       	out	0x3e, r31	; 62
    8e3a:	0f be       	out	0x3f, r0	; 63
    8e3c:	ed bf       	out	0x3d, r30	; 61
    8e3e:	31 96       	adiw	r30, 0x01	; 1
    8e40:	8d 91       	ld	r24, X+
    8e42:	9c 91       	ld	r25, X
    8e44:	ad b7       	in	r26, 0x3d	; 61
    8e46:	be b7       	in	r27, 0x3e	; 62
    8e48:	12 96       	adiw	r26, 0x02	; 2
    8e4a:	9c 93       	st	X, r25
    8e4c:	8e 93       	st	-X, r24
    8e4e:	11 97       	sbiw	r26, 0x01	; 1
    8e50:	80 e6       	ldi	r24, 0x60	; 96
    8e52:	92 e0       	ldi	r25, 0x02	; 2
    8e54:	93 83       	std	Z+3, r25	; 0x03
    8e56:	82 83       	std	Z+2, r24	; 0x02
    8e58:	24 82       	std	Z+4, r2	; 0x04
    8e5a:	35 82       	std	Z+5, r3	; 0x05
    8e5c:	46 82       	std	Z+6, r4	; 0x06
    8e5e:	57 82       	std	Z+7, r5	; 0x07
    8e60:	0e 94 ad 7f 	call	0xff5a	; 0xff5a <sprintf>
    8e64:	ed b7       	in	r30, 0x3d	; 61
    8e66:	fe b7       	in	r31, 0x3e	; 62
    8e68:	38 96       	adiw	r30, 0x08	; 8
    8e6a:	0f b6       	in	r0, 0x3f	; 63
    8e6c:	f8 94       	cli
    8e6e:	fe bf       	out	0x3e, r31	; 62
    8e70:	0f be       	out	0x3f, r0	; 63
    8e72:	ed bf       	out	0x3d, r30	; 61
	}
	else {
		Format[4] = '\0';
		sprintf(Param->Pos, Format, Val);
	}
}
    8e74:	2b 96       	adiw	r28, 0x0b	; 11
    8e76:	0f b6       	in	r0, 0x3f	; 63
    8e78:	f8 94       	cli
    8e7a:	de bf       	out	0x3e, r29	; 62
    8e7c:	0f be       	out	0x3f, r0	; 63
    8e7e:	cd bf       	out	0x3d, r28	; 61
    8e80:	cf 91       	pop	r28
    8e82:	df 91       	pop	r29
    8e84:	1f 91       	pop	r17
    8e86:	0f 91       	pop	r16
    8e88:	ff 90       	pop	r15
    8e8a:	ef 90       	pop	r14
    8e8c:	df 90       	pop	r13
    8e8e:	cf 90       	pop	r12
    8e90:	bf 90       	pop	r11
    8e92:	af 90       	pop	r10
    8e94:	9f 90       	pop	r9
    8e96:	8f 90       	pop	r8
    8e98:	7f 90       	pop	r7
    8e9a:	6f 90       	pop	r6
    8e9c:	5f 90       	pop	r5
    8e9e:	4f 90       	pop	r4
    8ea0:	3f 90       	pop	r3
    8ea2:	2f 90       	pop	r2
    8ea4:	08 95       	ret
		Format[7] = '0'+Param->Prec;
		uint32_t Div=PowL10(Param->Prec);
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
	}
	else {
		Format[4] = '\0';
    8ea6:	1d 82       	std	Y+5, r1	; 0x05
		sprintf(Param->Pos, Format, Val);
    8ea8:	8d b7       	in	r24, 0x3d	; 61
    8eaa:	9e b7       	in	r25, 0x3e	; 62
    8eac:	08 97       	sbiw	r24, 0x08	; 8
    8eae:	0f b6       	in	r0, 0x3f	; 63
    8eb0:	f8 94       	cli
    8eb2:	9e bf       	out	0x3e, r25	; 62
    8eb4:	0f be       	out	0x3f, r0	; 63
    8eb6:	8d bf       	out	0x3d, r24	; 61
    8eb8:	ed b7       	in	r30, 0x3d	; 61
    8eba:	fe b7       	in	r31, 0x3e	; 62
    8ebc:	31 96       	adiw	r30, 0x01	; 1
    8ebe:	d3 01       	movw	r26, r6
    8ec0:	8d 91       	ld	r24, X+
    8ec2:	9c 91       	ld	r25, X
    8ec4:	ad b7       	in	r26, 0x3d	; 61
    8ec6:	be b7       	in	r27, 0x3e	; 62
    8ec8:	12 96       	adiw	r26, 0x02	; 2
    8eca:	9c 93       	st	X, r25
    8ecc:	8e 93       	st	-X, r24
    8ece:	11 97       	sbiw	r26, 0x01	; 1
    8ed0:	81 e0       	ldi	r24, 0x01	; 1
    8ed2:	90 e0       	ldi	r25, 0x00	; 0
    8ed4:	8c 0f       	add	r24, r28
    8ed6:	9d 1f       	adc	r25, r29
    8ed8:	93 83       	std	Z+3, r25	; 0x03
    8eda:	82 83       	std	Z+2, r24	; 0x02
    8edc:	24 82       	std	Z+4, r2	; 0x04
    8ede:	35 82       	std	Z+5, r3	; 0x05
    8ee0:	46 82       	std	Z+6, r4	; 0x06
    8ee2:	57 82       	std	Z+7, r5	; 0x07
    8ee4:	0e 94 ad 7f 	call	0xff5a	; 0xff5a <sprintf>
    8ee8:	ad b7       	in	r26, 0x3d	; 61
    8eea:	be b7       	in	r27, 0x3e	; 62
    8eec:	18 96       	adiw	r26, 0x08	; 8
    8eee:	0f b6       	in	r0, 0x3f	; 63
    8ef0:	f8 94       	cli
    8ef2:	be bf       	out	0x3e, r27	; 62
    8ef4:	0f be       	out	0x3f, r0	; 63
    8ef6:	ad bf       	out	0x3d, r26	; 61
    8ef8:	bd cf       	rjmp	.-134    	; 0x8e74 <PutDVal+0x1a6>
void
PutDVal(uint32_t Val, T_Param *Param)
{
	uint32_t Idx = 0xFFFFFFFF-Val;
	if(Param->Txt && Idx<2) {
		Param->Txt += Idx;
    8efa:	88 0f       	add	r24, r24
    8efc:	99 1f       	adc	r25, r25
    8efe:	28 0f       	add	r18, r24
    8f00:	39 1f       	adc	r19, r25
    8f02:	fa 01       	movw	r30, r20
    8f04:	35 83       	std	Z+5, r19	; 0x05
    8f06:	24 83       	std	Z+4, r18	; 0x04
		PutEnum(Param);
    8f08:	ca 01       	movw	r24, r20
    8f0a:	0e 94 9e 40 	call	0x813c	; 0x813c <PutEnum>
    8f0e:	b2 cf       	rjmp	.-156    	; 0x8e74 <PutDVal+0x1a6>

00008f10 <Put_zVal_h>:
	}
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_zVal_h(uint32_t Val, char Type, T_Param *Param)
{
    8f10:	1f 93       	push	r17
    8f12:	17 2f       	mov	r17, r23
    8f14:	58 2f       	mov	r21, r24
    8f16:	79 2f       	mov	r23, r25
    8f18:	d9 01       	movw	r26, r18
	if(Type=='b') sprintf(Param->Pos, "%02hx", (uint8_t)Val);
    8f1a:	42 36       	cpi	r20, 0x62	; 98
    8f1c:	71 f1       	breq	.+92     	; 0x8f7a <Put_zVal_h+0x6a>
	if(Type=='w') sprintf(Param->Pos, "%04x", (uint16_t)Val);
    8f1e:	47 37       	cpi	r20, 0x77	; 119
    8f20:	09 f4       	brne	.+2      	; 0x8f24 <Put_zVal_h+0x14>
    8f22:	4a c0       	rjmp	.+148    	; 0x8fb8 <Put_zVal_h+0xa8>
	if(Type=='l') sprintf(Param->Pos, "%08lx", Val);
    8f24:	4c 36       	cpi	r20, 0x6C	; 108
    8f26:	11 f0       	breq	.+4      	; 0x8f2c <Put_zVal_h+0x1c>
}
    8f28:	1f 91       	pop	r17
    8f2a:	08 95       	ret
void
Put_zVal_h(uint32_t Val, char Type, T_Param *Param)
{
	if(Type=='b') sprintf(Param->Pos, "%02hx", (uint8_t)Val);
	if(Type=='w') sprintf(Param->Pos, "%04x", (uint16_t)Val);
	if(Type=='l') sprintf(Param->Pos, "%08lx", Val);
    8f2c:	8d b7       	in	r24, 0x3d	; 61
    8f2e:	9e b7       	in	r25, 0x3e	; 62
    8f30:	08 97       	sbiw	r24, 0x08	; 8
    8f32:	0f b6       	in	r0, 0x3f	; 63
    8f34:	f8 94       	cli
    8f36:	9e bf       	out	0x3e, r25	; 62
    8f38:	0f be       	out	0x3f, r0	; 63
    8f3a:	8d bf       	out	0x3d, r24	; 61
    8f3c:	ed b7       	in	r30, 0x3d	; 61
    8f3e:	fe b7       	in	r31, 0x3e	; 62
    8f40:	31 96       	adiw	r30, 0x01	; 1
    8f42:	8d 91       	ld	r24, X+
    8f44:	9c 91       	ld	r25, X
    8f46:	ad b7       	in	r26, 0x3d	; 61
    8f48:	be b7       	in	r27, 0x3e	; 62
    8f4a:	12 96       	adiw	r26, 0x02	; 2
    8f4c:	9c 93       	st	X, r25
    8f4e:	8e 93       	st	-X, r24
    8f50:	11 97       	sbiw	r26, 0x01	; 1
    8f52:	8c e7       	ldi	r24, 0x7C	; 124
    8f54:	92 e0       	ldi	r25, 0x02	; 2
    8f56:	93 83       	std	Z+3, r25	; 0x03
    8f58:	82 83       	std	Z+2, r24	; 0x02
    8f5a:	64 83       	std	Z+4, r22	; 0x04
    8f5c:	15 83       	std	Z+5, r17	; 0x05
    8f5e:	56 83       	std	Z+6, r21	; 0x06
    8f60:	77 83       	std	Z+7, r23	; 0x07
    8f62:	0e 94 ad 7f 	call	0xff5a	; 0xff5a <sprintf>
    8f66:	8d b7       	in	r24, 0x3d	; 61
    8f68:	9e b7       	in	r25, 0x3e	; 62
    8f6a:	08 96       	adiw	r24, 0x08	; 8
    8f6c:	0f b6       	in	r0, 0x3f	; 63
    8f6e:	f8 94       	cli
    8f70:	9e bf       	out	0x3e, r25	; 62
    8f72:	0f be       	out	0x3f, r0	; 63
    8f74:	8d bf       	out	0x3d, r24	; 61
}
    8f76:	1f 91       	pop	r17
    8f78:	08 95       	ret
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_zVal_h(uint32_t Val, char Type, T_Param *Param)
{
	if(Type=='b') sprintf(Param->Pos, "%02hx", (uint8_t)Val);
    8f7a:	00 d0       	rcall	.+0      	; 0x8f7c <Put_zVal_h+0x6c>
    8f7c:	00 d0       	rcall	.+0      	; 0x8f7e <Put_zVal_h+0x6e>
    8f7e:	ed b7       	in	r30, 0x3d	; 61
    8f80:	fe b7       	in	r31, 0x3e	; 62
    8f82:	31 96       	adiw	r30, 0x01	; 1
    8f84:	8d 91       	ld	r24, X+
    8f86:	9c 91       	ld	r25, X
    8f88:	ad b7       	in	r26, 0x3d	; 61
    8f8a:	be b7       	in	r27, 0x3e	; 62
    8f8c:	12 96       	adiw	r26, 0x02	; 2
    8f8e:	9c 93       	st	X, r25
    8f90:	8e 93       	st	-X, r24
    8f92:	11 97       	sbiw	r26, 0x01	; 1
    8f94:	81 e7       	ldi	r24, 0x71	; 113
    8f96:	92 e0       	ldi	r25, 0x02	; 2
    8f98:	93 83       	std	Z+3, r25	; 0x03
    8f9a:	82 83       	std	Z+2, r24	; 0x02
    8f9c:	64 83       	std	Z+4, r22	; 0x04
    8f9e:	15 82       	std	Z+5, r1	; 0x05
    8fa0:	0e 94 ad 7f 	call	0xff5a	; 0xff5a <sprintf>
    8fa4:	8d b7       	in	r24, 0x3d	; 61
    8fa6:	9e b7       	in	r25, 0x3e	; 62
    8fa8:	06 96       	adiw	r24, 0x06	; 6
    8faa:	0f b6       	in	r0, 0x3f	; 63
    8fac:	f8 94       	cli
    8fae:	9e bf       	out	0x3e, r25	; 62
    8fb0:	0f be       	out	0x3f, r0	; 63
    8fb2:	8d bf       	out	0x3d, r24	; 61
	if(Type=='w') sprintf(Param->Pos, "%04x", (uint16_t)Val);
	if(Type=='l') sprintf(Param->Pos, "%08lx", Val);
}
    8fb4:	1f 91       	pop	r17
    8fb6:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_zVal_h(uint32_t Val, char Type, T_Param *Param)
{
	if(Type=='b') sprintf(Param->Pos, "%02hx", (uint8_t)Val);
	if(Type=='w') sprintf(Param->Pos, "%04x", (uint16_t)Val);
    8fb8:	00 d0       	rcall	.+0      	; 0x8fba <Put_zVal_h+0xaa>
    8fba:	00 d0       	rcall	.+0      	; 0x8fbc <Put_zVal_h+0xac>
    8fbc:	ed b7       	in	r30, 0x3d	; 61
    8fbe:	fe b7       	in	r31, 0x3e	; 62
    8fc0:	31 96       	adiw	r30, 0x01	; 1
    8fc2:	8d 91       	ld	r24, X+
    8fc4:	9c 91       	ld	r25, X
    8fc6:	ad b7       	in	r26, 0x3d	; 61
    8fc8:	be b7       	in	r27, 0x3e	; 62
    8fca:	12 96       	adiw	r26, 0x02	; 2
    8fcc:	9c 93       	st	X, r25
    8fce:	8e 93       	st	-X, r24
    8fd0:	11 97       	sbiw	r26, 0x01	; 1
    8fd2:	87 e7       	ldi	r24, 0x77	; 119
    8fd4:	92 e0       	ldi	r25, 0x02	; 2
    8fd6:	93 83       	std	Z+3, r25	; 0x03
    8fd8:	82 83       	std	Z+2, r24	; 0x02
    8fda:	64 83       	std	Z+4, r22	; 0x04
    8fdc:	15 83       	std	Z+5, r17	; 0x05
    8fde:	0e 94 ad 7f 	call	0xff5a	; 0xff5a <sprintf>
    8fe2:	8d b7       	in	r24, 0x3d	; 61
    8fe4:	9e b7       	in	r25, 0x3e	; 62
    8fe6:	06 96       	adiw	r24, 0x06	; 6
    8fe8:	0f b6       	in	r0, 0x3f	; 63
    8fea:	f8 94       	cli
    8fec:	9e bf       	out	0x3e, r25	; 62
    8fee:	0f be       	out	0x3f, r0	; 63
    8ff0:	8d bf       	out	0x3d, r24	; 61
	if(Type=='l') sprintf(Param->Pos, "%08lx", Val);
}
    8ff2:	1f 91       	pop	r17
    8ff4:	08 95       	ret

00008ff6 <Put_zVal>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_zVal(uint16_t Val, char Type, T_Param *Param)
{
    8ff6:	af 92       	push	r10
    8ff8:	bf 92       	push	r11
    8ffa:	cf 92       	push	r12
    8ffc:	df 92       	push	r13
    8ffe:	ef 92       	push	r14
    9000:	ff 92       	push	r15
    9002:	0f 93       	push	r16
    9004:	1f 93       	push	r17
    9006:	df 93       	push	r29
    9008:	cf 93       	push	r28
    900a:	cd b7       	in	r28, 0x3d	; 61
    900c:	de b7       	in	r29, 0x3e	; 62
    900e:	2a 97       	sbiw	r28, 0x0a	; 10
    9010:	0f b6       	in	r0, 0x3f	; 63
    9012:	f8 94       	cli
    9014:	de bf       	out	0x3e, r29	; 62
    9016:	0f be       	out	0x3f, r0	; 63
    9018:	cd bf       	out	0x3d, r28	; 61
    901a:	6c 01       	movw	r12, r24
    901c:	7a 01       	movw	r14, r20
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
    901e:	67 37       	cpi	r22, 0x77	; 119
    9020:	09 f4       	brne	.+2      	; 0x9024 <Put_zVal+0x2e>
    9022:	79 c0       	rjmp	.+242    	; 0x9116 <Put_zVal+0x120>
    9024:	8f ef       	ldi	r24, 0xFF	; 255
    9026:	90 e0       	ldi	r25, 0x00	; 0
	if(Param->Txt && Idx<2) {
    9028:	d7 01       	movw	r26, r14
    902a:	14 96       	adiw	r26, 0x04	; 4
    902c:	2d 91       	ld	r18, X+
    902e:	3c 91       	ld	r19, X
    9030:	15 97       	sbiw	r26, 0x05	; 5
    9032:	21 15       	cp	r18, r1
    9034:	31 05       	cpc	r19, r1
    9036:	31 f0       	breq	.+12     	; 0x9044 <Put_zVal+0x4e>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_zVal(uint16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
    9038:	8c 19       	sub	r24, r12
    903a:	9d 09       	sbc	r25, r13
	if(Param->Txt && Idx<2) {
    903c:	82 30       	cpi	r24, 0x02	; 2
    903e:	91 05       	cpc	r25, r1
    9040:	08 f4       	brcc	.+2      	; 0x9044 <Put_zVal+0x4e>
    9042:	8a c0       	rjmp	.+276    	; 0x9158 <Put_zVal+0x162>
		Param->Txt += Idx;
		PutEnum(Param);
		return;
	}
	char Format[] = "%0 u.%. u";
    9044:	5e 01       	movw	r10, r28
    9046:	08 94       	sec
    9048:	a1 1c       	adc	r10, r1
    904a:	b1 1c       	adc	r11, r1
    904c:	d5 01       	movw	r26, r10
    904e:	e2 e8       	ldi	r30, 0x82	; 130
    9050:	f2 e0       	ldi	r31, 0x02	; 2
    9052:	8a e0       	ldi	r24, 0x0A	; 10
    9054:	01 90       	ld	r0, Z+
    9056:	0d 92       	st	X+, r0
    9058:	81 50       	subi	r24, 0x01	; 1
    905a:	e1 f7       	brne	.-8      	; 0x9054 <Put_zVal+0x5e>
	Format[2] = '0'+Param->Size;
    905c:	f7 01       	movw	r30, r14
    905e:	23 81       	ldd	r18, Z+3	; 0x03
    9060:	20 5d       	subi	r18, 0xD0	; 208
    9062:	2b 83       	std	Y+3, r18	; 0x03
	if(Param->Prec) {
    9064:	92 81       	ldd	r25, Z+2	; 0x02
    9066:	99 23       	and	r25, r25
    9068:	09 f4       	brne	.+2      	; 0x906c <Put_zVal+0x76>
    906a:	58 c0       	rjmp	.+176    	; 0x911c <Put_zVal+0x126>
		Format[2] -= Param->Prec+1;
    906c:	89 2f       	mov	r24, r25
    906e:	80 95       	com	r24
    9070:	82 0f       	add	r24, r18
    9072:	8b 83       	std	Y+3, r24	; 0x03
		Format[7] = '0'+Param->Prec;
    9074:	90 5d       	subi	r25, 0xD0	; 208
    9076:	98 87       	std	Y+8, r25	; 0x08
    9078:	90 53       	subi	r25, 0x30	; 48
		uint16_t Div=Pow10(Param->Prec);
    907a:	29 2f       	mov	r18, r25
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    907c:	01 e0       	ldi	r16, 0x01	; 1
    907e:	10 e0       	ldi	r17, 0x00	; 0
		Pow *= 10;
    9080:	c8 01       	movw	r24, r16
    9082:	88 0f       	add	r24, r24
    9084:	99 1f       	adc	r25, r25
    9086:	00 0f       	add	r16, r16
    9088:	11 1f       	adc	r17, r17
    908a:	00 0f       	add	r16, r16
    908c:	11 1f       	adc	r17, r17
    908e:	00 0f       	add	r16, r16
    9090:	11 1f       	adc	r17, r17
    9092:	08 0f       	add	r16, r24
    9094:	19 1f       	adc	r17, r25
    9096:	21 50       	subi	r18, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    9098:	99 f7       	brne	.-26     	; 0x9080 <Put_zVal+0x8a>
    909a:	c6 01       	movw	r24, r12
    909c:	b8 01       	movw	r22, r16
    909e:	0e 94 42 82 	call	0x10484	; 0x10484 <__udivmodhi4>
    90a2:	9c 01       	movw	r18, r24
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
    90a4:	8d b7       	in	r24, 0x3d	; 61
    90a6:	9e b7       	in	r25, 0x3e	; 62
    90a8:	08 97       	sbiw	r24, 0x08	; 8
    90aa:	0f b6       	in	r0, 0x3f	; 63
    90ac:	f8 94       	cli
    90ae:	9e bf       	out	0x3e, r25	; 62
    90b0:	0f be       	out	0x3f, r0	; 63
    90b2:	8d bf       	out	0x3d, r24	; 61
    90b4:	ed b7       	in	r30, 0x3d	; 61
    90b6:	fe b7       	in	r31, 0x3e	; 62
    90b8:	31 96       	adiw	r30, 0x01	; 1
    90ba:	d7 01       	movw	r26, r14
    90bc:	8d 91       	ld	r24, X+
    90be:	9c 91       	ld	r25, X
    90c0:	ad b7       	in	r26, 0x3d	; 61
    90c2:	be b7       	in	r27, 0x3e	; 62
    90c4:	12 96       	adiw	r26, 0x02	; 2
    90c6:	9c 93       	st	X, r25
    90c8:	8e 93       	st	-X, r24
    90ca:	11 97       	sbiw	r26, 0x01	; 1
    90cc:	b3 82       	std	Z+3, r11	; 0x03
    90ce:	a2 82       	std	Z+2, r10	; 0x02
    90d0:	c6 01       	movw	r24, r12
    90d2:	b8 01       	movw	r22, r16
    90d4:	0e 94 42 82 	call	0x10484	; 0x10484 <__udivmodhi4>
    90d8:	75 83       	std	Z+5, r23	; 0x05
    90da:	64 83       	std	Z+4, r22	; 0x04
    90dc:	26 83       	std	Z+6, r18	; 0x06
    90de:	37 83       	std	Z+7, r19	; 0x07
    90e0:	0e 94 ad 7f 	call	0xff5a	; 0xff5a <sprintf>
    90e4:	ed b7       	in	r30, 0x3d	; 61
    90e6:	fe b7       	in	r31, 0x3e	; 62
    90e8:	38 96       	adiw	r30, 0x08	; 8
    90ea:	0f b6       	in	r0, 0x3f	; 63
    90ec:	f8 94       	cli
    90ee:	fe bf       	out	0x3e, r31	; 62
    90f0:	0f be       	out	0x3f, r0	; 63
    90f2:	ed bf       	out	0x3d, r30	; 61
	}
	else {
		Format[4] = '\0';
		sprintf(Param->Pos, Format, Val);
	}
}
    90f4:	2a 96       	adiw	r28, 0x0a	; 10
    90f6:	0f b6       	in	r0, 0x3f	; 63
    90f8:	f8 94       	cli
    90fa:	de bf       	out	0x3e, r29	; 62
    90fc:	0f be       	out	0x3f, r0	; 63
    90fe:	cd bf       	out	0x3d, r28	; 61
    9100:	cf 91       	pop	r28
    9102:	df 91       	pop	r29
    9104:	1f 91       	pop	r17
    9106:	0f 91       	pop	r16
    9108:	ff 90       	pop	r15
    910a:	ef 90       	pop	r14
    910c:	df 90       	pop	r13
    910e:	cf 90       	pop	r12
    9110:	bf 90       	pop	r11
    9112:	af 90       	pop	r10
    9114:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_zVal(uint16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
    9116:	8f ef       	ldi	r24, 0xFF	; 255
    9118:	9f ef       	ldi	r25, 0xFF	; 255
    911a:	86 cf       	rjmp	.-244    	; 0x9028 <Put_zVal+0x32>
		Format[7] = '0'+Param->Prec;
		uint16_t Div=Pow10(Param->Prec);
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
	}
	else {
		Format[4] = '\0';
    911c:	1d 82       	std	Y+5, r1	; 0x05
		sprintf(Param->Pos, Format, Val);
    911e:	00 d0       	rcall	.+0      	; 0x9120 <Put_zVal+0x12a>
    9120:	00 d0       	rcall	.+0      	; 0x9122 <Put_zVal+0x12c>
    9122:	ed b7       	in	r30, 0x3d	; 61
    9124:	fe b7       	in	r31, 0x3e	; 62
    9126:	31 96       	adiw	r30, 0x01	; 1
    9128:	d7 01       	movw	r26, r14
    912a:	8d 91       	ld	r24, X+
    912c:	9c 91       	ld	r25, X
    912e:	ad b7       	in	r26, 0x3d	; 61
    9130:	be b7       	in	r27, 0x3e	; 62
    9132:	12 96       	adiw	r26, 0x02	; 2
    9134:	9c 93       	st	X, r25
    9136:	8e 93       	st	-X, r24
    9138:	11 97       	sbiw	r26, 0x01	; 1
    913a:	b3 82       	std	Z+3, r11	; 0x03
    913c:	a2 82       	std	Z+2, r10	; 0x02
    913e:	d5 82       	std	Z+5, r13	; 0x05
    9140:	c4 82       	std	Z+4, r12	; 0x04
    9142:	0e 94 ad 7f 	call	0xff5a	; 0xff5a <sprintf>
    9146:	ed b7       	in	r30, 0x3d	; 61
    9148:	fe b7       	in	r31, 0x3e	; 62
    914a:	36 96       	adiw	r30, 0x06	; 6
    914c:	0f b6       	in	r0, 0x3f	; 63
    914e:	f8 94       	cli
    9150:	fe bf       	out	0x3e, r31	; 62
    9152:	0f be       	out	0x3f, r0	; 63
    9154:	ed bf       	out	0x3d, r30	; 61
    9156:	ce cf       	rjmp	.-100    	; 0x90f4 <Put_zVal+0xfe>
void
Put_zVal(uint16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
	if(Param->Txt && Idx<2) {
		Param->Txt += Idx;
    9158:	88 0f       	add	r24, r24
    915a:	99 1f       	adc	r25, r25
    915c:	28 0f       	add	r18, r24
    915e:	39 1f       	adc	r19, r25
    9160:	15 96       	adiw	r26, 0x05	; 5
    9162:	3c 93       	st	X, r19
    9164:	2e 93       	st	-X, r18
    9166:	14 97       	sbiw	r26, 0x04	; 4
		PutEnum(Param);
    9168:	c7 01       	movw	r24, r14
    916a:	0e 94 9e 40 	call	0x813c	; 0x813c <PutEnum>
    916e:	c2 cf       	rjmp	.-124    	; 0x90f4 <Put_zVal+0xfe>

00009170 <Put_sVal>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_sVal(int16_t Val, char Type, T_Param *Param)
{
    9170:	af 92       	push	r10
    9172:	bf 92       	push	r11
    9174:	cf 92       	push	r12
    9176:	df 92       	push	r13
    9178:	ef 92       	push	r14
    917a:	ff 92       	push	r15
    917c:	0f 93       	push	r16
    917e:	1f 93       	push	r17
    9180:	df 93       	push	r29
    9182:	cf 93       	push	r28
    9184:	cd b7       	in	r28, 0x3d	; 61
    9186:	de b7       	in	r29, 0x3e	; 62
    9188:	2a 97       	sbiw	r28, 0x0a	; 10
    918a:	0f b6       	in	r0, 0x3f	; 63
    918c:	f8 94       	cli
    918e:	de bf       	out	0x3e, r29	; 62
    9190:	0f be       	out	0x3f, r0	; 63
    9192:	cd bf       	out	0x3d, r28	; 61
    9194:	6c 01       	movw	r12, r24
    9196:	7a 01       	movw	r14, r20
	uint16_t Idx = (Type=='w'?0x8000:0x80)+Val;
    9198:	67 37       	cpi	r22, 0x77	; 119
    919a:	09 f4       	brne	.+2      	; 0x919e <Put_sVal+0x2e>
    919c:	81 c0       	rjmp	.+258    	; 0x92a0 <Put_sVal+0x130>
    919e:	80 e8       	ldi	r24, 0x80	; 128
    91a0:	90 e0       	ldi	r25, 0x00	; 0
	if(Param->Txt && Idx<2) {
    91a2:	d7 01       	movw	r26, r14
    91a4:	14 96       	adiw	r26, 0x04	; 4
    91a6:	2d 91       	ld	r18, X+
    91a8:	3c 91       	ld	r19, X
    91aa:	15 97       	sbiw	r26, 0x05	; 5
    91ac:	21 15       	cp	r18, r1
    91ae:	31 05       	cpc	r19, r1
    91b0:	31 f0       	breq	.+12     	; 0x91be <Put_sVal+0x4e>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_sVal(int16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0x8000:0x80)+Val;
    91b2:	8c 0d       	add	r24, r12
    91b4:	9d 1d       	adc	r25, r13
	if(Param->Txt && Idx<2) {
    91b6:	82 30       	cpi	r24, 0x02	; 2
    91b8:	91 05       	cpc	r25, r1
    91ba:	08 f4       	brcc	.+2      	; 0x91be <Put_sVal+0x4e>
    91bc:	ac c0       	rjmp	.+344    	; 0x9316 <Put_sVal+0x1a6>
		Param->Txt += Idx;
		PutEnum(Param);
		return;
	}
	char Format[] = "%+ d.%. u";
    91be:	5e 01       	movw	r10, r28
    91c0:	08 94       	sec
    91c2:	a1 1c       	adc	r10, r1
    91c4:	b1 1c       	adc	r11, r1
    91c6:	d5 01       	movw	r26, r10
    91c8:	ec e8       	ldi	r30, 0x8C	; 140
    91ca:	f2 e0       	ldi	r31, 0x02	; 2
    91cc:	8a e0       	ldi	r24, 0x0A	; 10
    91ce:	01 90       	ld	r0, Z+
    91d0:	0d 92       	st	X+, r0
    91d2:	81 50       	subi	r24, 0x01	; 1
    91d4:	e1 f7       	brne	.-8      	; 0x91ce <Put_sVal+0x5e>
	if(Val==0)
    91d6:	c1 14       	cp	r12, r1
    91d8:	d1 04       	cpc	r13, r1
    91da:	09 f4       	brne	.+2      	; 0x91de <Put_sVal+0x6e>
    91dc:	64 c0       	rjmp	.+200    	; 0x92a6 <Put_sVal+0x136>
		Format[1] = ' ';
	Format[2] = '0'+Param->Size;
    91de:	f7 01       	movw	r30, r14
    91e0:	23 81       	ldd	r18, Z+3	; 0x03
    91e2:	20 5d       	subi	r18, 0xD0	; 208
    91e4:	2b 83       	std	Y+3, r18	; 0x03
	if(Param->Prec) {
    91e6:	92 81       	ldd	r25, Z+2	; 0x02
    91e8:	99 23       	and	r25, r25
    91ea:	09 f4       	brne	.+2      	; 0x91ee <Put_sVal+0x7e>
    91ec:	66 c0       	rjmp	.+204    	; 0x92ba <Put_sVal+0x14a>
		Format[2] -= Param->Prec+1;
    91ee:	89 2f       	mov	r24, r25
    91f0:	80 95       	com	r24
    91f2:	82 0f       	add	r24, r18
    91f4:	8b 83       	std	Y+3, r24	; 0x03
		Format[7] = '0'+Param->Prec;
    91f6:	90 5d       	subi	r25, 0xD0	; 208
    91f8:	98 87       	std	Y+8, r25	; 0x08
    91fa:	90 53       	subi	r25, 0x30	; 48
		int16_t Div=Pow10(Param->Prec);
    91fc:	29 2f       	mov	r18, r25
    91fe:	01 e0       	ldi	r16, 0x01	; 1
    9200:	10 e0       	ldi	r17, 0x00	; 0
		Pow *= 10;
    9202:	c8 01       	movw	r24, r16
    9204:	88 0f       	add	r24, r24
    9206:	99 1f       	adc	r25, r25
    9208:	00 0f       	add	r16, r16
    920a:	11 1f       	adc	r17, r17
    920c:	00 0f       	add	r16, r16
    920e:	11 1f       	adc	r17, r17
    9210:	00 0f       	add	r16, r16
    9212:	11 1f       	adc	r17, r17
    9214:	08 0f       	add	r16, r24
    9216:	19 1f       	adc	r17, r25
    9218:	21 50       	subi	r18, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    921a:	99 f7       	brne	.-26     	; 0x9202 <Put_sVal+0x92>
    921c:	c6 01       	movw	r24, r12
    921e:	d7 fc       	sbrc	r13, 7
    9220:	86 c0       	rjmp	.+268    	; 0x932e <Put_sVal+0x1be>
    9222:	b8 01       	movw	r22, r16
    9224:	0e 94 42 82 	call	0x10484	; 0x10484 <__udivmodhi4>
    9228:	9c 01       	movw	r18, r24
		sprintf(Param->Pos, Format, Val/Div, (uint16_t)abs(Val)%Div);
    922a:	8d b7       	in	r24, 0x3d	; 61
    922c:	9e b7       	in	r25, 0x3e	; 62
    922e:	08 97       	sbiw	r24, 0x08	; 8
    9230:	0f b6       	in	r0, 0x3f	; 63
    9232:	f8 94       	cli
    9234:	9e bf       	out	0x3e, r25	; 62
    9236:	0f be       	out	0x3f, r0	; 63
    9238:	8d bf       	out	0x3d, r24	; 61
    923a:	ed b7       	in	r30, 0x3d	; 61
    923c:	fe b7       	in	r31, 0x3e	; 62
    923e:	31 96       	adiw	r30, 0x01	; 1
    9240:	d7 01       	movw	r26, r14
    9242:	8d 91       	ld	r24, X+
    9244:	9c 91       	ld	r25, X
    9246:	ad b7       	in	r26, 0x3d	; 61
    9248:	be b7       	in	r27, 0x3e	; 62
    924a:	12 96       	adiw	r26, 0x02	; 2
    924c:	9c 93       	st	X, r25
    924e:	8e 93       	st	-X, r24
    9250:	11 97       	sbiw	r26, 0x01	; 1
    9252:	b3 82       	std	Z+3, r11	; 0x03
    9254:	a2 82       	std	Z+2, r10	; 0x02
    9256:	c6 01       	movw	r24, r12
    9258:	b8 01       	movw	r22, r16
    925a:	0e 94 56 82 	call	0x104ac	; 0x104ac <__divmodhi4>
    925e:	75 83       	std	Z+5, r23	; 0x05
    9260:	64 83       	std	Z+4, r22	; 0x04
    9262:	26 83       	std	Z+6, r18	; 0x06
    9264:	37 83       	std	Z+7, r19	; 0x07
    9266:	0e 94 ad 7f 	call	0xff5a	; 0xff5a <sprintf>
		if(Val<0) {
    926a:	ed b7       	in	r30, 0x3d	; 61
    926c:	fe b7       	in	r31, 0x3e	; 62
    926e:	38 96       	adiw	r30, 0x08	; 8
    9270:	0f b6       	in	r0, 0x3f	; 63
    9272:	f8 94       	cli
    9274:	fe bf       	out	0x3e, r31	; 62
    9276:	0f be       	out	0x3f, r0	; 63
    9278:	ed bf       	out	0x3d, r30	; 61
    927a:	d7 fc       	sbrc	r13, 7
    927c:	3c c0       	rjmp	.+120    	; 0x92f6 <Put_sVal+0x186>
	}
	else {
		Format[4] = '\0';
		sprintf(Param->Pos, Format, Val);
	}
}
    927e:	2a 96       	adiw	r28, 0x0a	; 10
    9280:	0f b6       	in	r0, 0x3f	; 63
    9282:	f8 94       	cli
    9284:	de bf       	out	0x3e, r29	; 62
    9286:	0f be       	out	0x3f, r0	; 63
    9288:	cd bf       	out	0x3d, r28	; 61
    928a:	cf 91       	pop	r28
    928c:	df 91       	pop	r29
    928e:	1f 91       	pop	r17
    9290:	0f 91       	pop	r16
    9292:	ff 90       	pop	r15
    9294:	ef 90       	pop	r14
    9296:	df 90       	pop	r13
    9298:	cf 90       	pop	r12
    929a:	bf 90       	pop	r11
    929c:	af 90       	pop	r10
    929e:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_sVal(int16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0x8000:0x80)+Val;
    92a0:	80 e0       	ldi	r24, 0x00	; 0
    92a2:	90 e8       	ldi	r25, 0x80	; 128
    92a4:	7e cf       	rjmp	.-260    	; 0x91a2 <Put_sVal+0x32>
		PutEnum(Param);
		return;
	}
	char Format[] = "%+ d.%. u";
	if(Val==0)
		Format[1] = ' ';
    92a6:	80 e2       	ldi	r24, 0x20	; 32
    92a8:	8a 83       	std	Y+2, r24	; 0x02
	Format[2] = '0'+Param->Size;
    92aa:	f7 01       	movw	r30, r14
    92ac:	23 81       	ldd	r18, Z+3	; 0x03
    92ae:	20 5d       	subi	r18, 0xD0	; 208
    92b0:	2b 83       	std	Y+3, r18	; 0x03
	if(Param->Prec) {
    92b2:	92 81       	ldd	r25, Z+2	; 0x02
    92b4:	99 23       	and	r25, r25
    92b6:	09 f0       	breq	.+2      	; 0x92ba <Put_sVal+0x14a>
    92b8:	9a cf       	rjmp	.-204    	; 0x91ee <Put_sVal+0x7e>
				Param->Pos++;
			*Param->Pos = '-';
		}
	}
	else {
		Format[4] = '\0';
    92ba:	1d 82       	std	Y+5, r1	; 0x05
		sprintf(Param->Pos, Format, Val);
    92bc:	00 d0       	rcall	.+0      	; 0x92be <Put_sVal+0x14e>
    92be:	00 d0       	rcall	.+0      	; 0x92c0 <Put_sVal+0x150>
    92c0:	ed b7       	in	r30, 0x3d	; 61
    92c2:	fe b7       	in	r31, 0x3e	; 62
    92c4:	31 96       	adiw	r30, 0x01	; 1
    92c6:	d7 01       	movw	r26, r14
    92c8:	8d 91       	ld	r24, X+
    92ca:	9c 91       	ld	r25, X
    92cc:	ad b7       	in	r26, 0x3d	; 61
    92ce:	be b7       	in	r27, 0x3e	; 62
    92d0:	12 96       	adiw	r26, 0x02	; 2
    92d2:	9c 93       	st	X, r25
    92d4:	8e 93       	st	-X, r24
    92d6:	11 97       	sbiw	r26, 0x01	; 1
    92d8:	b3 82       	std	Z+3, r11	; 0x03
    92da:	a2 82       	std	Z+2, r10	; 0x02
    92dc:	d5 82       	std	Z+5, r13	; 0x05
    92de:	c4 82       	std	Z+4, r12	; 0x04
    92e0:	0e 94 ad 7f 	call	0xff5a	; 0xff5a <sprintf>
    92e4:	ed b7       	in	r30, 0x3d	; 61
    92e6:	fe b7       	in	r31, 0x3e	; 62
    92e8:	36 96       	adiw	r30, 0x06	; 6
    92ea:	0f b6       	in	r0, 0x3f	; 63
    92ec:	f8 94       	cli
    92ee:	fe bf       	out	0x3e, r31	; 62
    92f0:	0f be       	out	0x3f, r0	; 63
    92f2:	ed bf       	out	0x3d, r30	; 61
    92f4:	c4 cf       	rjmp	.-120    	; 0x927e <Put_sVal+0x10e>
		Format[2] -= Param->Prec+1;
		Format[7] = '0'+Param->Prec;
		int16_t Div=Pow10(Param->Prec);
		sprintf(Param->Pos, Format, Val/Div, (uint16_t)abs(Val)%Div);
		if(Val<0) {
			while(*Param->Pos==' ')
    92f6:	d7 01       	movw	r26, r14
    92f8:	ed 91       	ld	r30, X+
    92fa:	fc 91       	ld	r31, X
    92fc:	80 81       	ld	r24, Z
    92fe:	80 32       	cpi	r24, 0x20	; 32
    9300:	39 f4       	brne	.+14     	; 0x9310 <Put_sVal+0x1a0>
				Param->Pos++;
    9302:	31 96       	adiw	r30, 0x01	; 1
    9304:	d7 01       	movw	r26, r14
    9306:	ed 93       	st	X+, r30
    9308:	fc 93       	st	X, r31
		Format[2] -= Param->Prec+1;
		Format[7] = '0'+Param->Prec;
		int16_t Div=Pow10(Param->Prec);
		sprintf(Param->Pos, Format, Val/Div, (uint16_t)abs(Val)%Div);
		if(Val<0) {
			while(*Param->Pos==' ')
    930a:	80 81       	ld	r24, Z
    930c:	80 32       	cpi	r24, 0x20	; 32
    930e:	c9 f3       	breq	.-14     	; 0x9302 <Put_sVal+0x192>
				Param->Pos++;
			*Param->Pos = '-';
    9310:	8d e2       	ldi	r24, 0x2D	; 45
    9312:	80 83       	st	Z, r24
    9314:	b4 cf       	rjmp	.-152    	; 0x927e <Put_sVal+0x10e>
void
Put_sVal(int16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0x8000:0x80)+Val;
	if(Param->Txt && Idx<2) {
		Param->Txt += Idx;
    9316:	88 0f       	add	r24, r24
    9318:	99 1f       	adc	r25, r25
    931a:	28 0f       	add	r18, r24
    931c:	39 1f       	adc	r19, r25
    931e:	15 96       	adiw	r26, 0x05	; 5
    9320:	3c 93       	st	X, r19
    9322:	2e 93       	st	-X, r18
    9324:	14 97       	sbiw	r26, 0x04	; 4
		PutEnum(Param);
    9326:	c7 01       	movw	r24, r14
    9328:	0e 94 9e 40 	call	0x813c	; 0x813c <PutEnum>
    932c:	a8 cf       	rjmp	.-176    	; 0x927e <Put_sVal+0x10e>
    932e:	88 27       	eor	r24, r24
    9330:	99 27       	eor	r25, r25
    9332:	8c 19       	sub	r24, r12
    9334:	9d 09       	sbc	r25, r13
    9336:	75 cf       	rjmp	.-278    	; 0x9222 <Put_sVal+0xb2>

00009338 <PutVal>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
PutVal(uint16_t Val, char Type, T_Param *Param)
{
    9338:	af 92       	push	r10
    933a:	bf 92       	push	r11
    933c:	cf 92       	push	r12
    933e:	df 92       	push	r13
    9340:	ef 92       	push	r14
    9342:	ff 92       	push	r15
    9344:	0f 93       	push	r16
    9346:	1f 93       	push	r17
    9348:	df 93       	push	r29
    934a:	cf 93       	push	r28
    934c:	cd b7       	in	r28, 0x3d	; 61
    934e:	de b7       	in	r29, 0x3e	; 62
    9350:	29 97       	sbiw	r28, 0x09	; 9
    9352:	0f b6       	in	r0, 0x3f	; 63
    9354:	f8 94       	cli
    9356:	de bf       	out	0x3e, r29	; 62
    9358:	0f be       	out	0x3f, r0	; 63
    935a:	cd bf       	out	0x3d, r28	; 61
    935c:	6c 01       	movw	r12, r24
    935e:	7a 01       	movw	r14, r20
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
    9360:	67 37       	cpi	r22, 0x77	; 119
    9362:	09 f4       	brne	.+2      	; 0x9366 <PutVal+0x2e>
    9364:	79 c0       	rjmp	.+242    	; 0x9458 <PutVal+0x120>
    9366:	8f ef       	ldi	r24, 0xFF	; 255
    9368:	90 e0       	ldi	r25, 0x00	; 0
	if(Param->Txt && Idx<2) {
    936a:	d7 01       	movw	r26, r14
    936c:	14 96       	adiw	r26, 0x04	; 4
    936e:	2d 91       	ld	r18, X+
    9370:	3c 91       	ld	r19, X
    9372:	15 97       	sbiw	r26, 0x05	; 5
    9374:	21 15       	cp	r18, r1
    9376:	31 05       	cpc	r19, r1
    9378:	31 f0       	breq	.+12     	; 0x9386 <PutVal+0x4e>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
PutVal(uint16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
    937a:	8c 19       	sub	r24, r12
    937c:	9d 09       	sbc	r25, r13
	if(Param->Txt && Idx<2) {
    937e:	82 30       	cpi	r24, 0x02	; 2
    9380:	91 05       	cpc	r25, r1
    9382:	08 f4       	brcc	.+2      	; 0x9386 <PutVal+0x4e>
    9384:	8a c0       	rjmp	.+276    	; 0x949a <PutVal+0x162>
		Param->Txt += Idx;
		PutEnum(Param);
		return;
	}
	char Format[] = "% u.%. u";
    9386:	5e 01       	movw	r10, r28
    9388:	08 94       	sec
    938a:	a1 1c       	adc	r10, r1
    938c:	b1 1c       	adc	r11, r1
    938e:	d5 01       	movw	r26, r10
    9390:	e6 e9       	ldi	r30, 0x96	; 150
    9392:	f2 e0       	ldi	r31, 0x02	; 2
    9394:	89 e0       	ldi	r24, 0x09	; 9
    9396:	01 90       	ld	r0, Z+
    9398:	0d 92       	st	X+, r0
    939a:	81 50       	subi	r24, 0x01	; 1
    939c:	e1 f7       	brne	.-8      	; 0x9396 <PutVal+0x5e>
	Format[1] = '0'+Param->Size;
    939e:	f7 01       	movw	r30, r14
    93a0:	23 81       	ldd	r18, Z+3	; 0x03
    93a2:	20 5d       	subi	r18, 0xD0	; 208
    93a4:	2a 83       	std	Y+2, r18	; 0x02
	if(Param->Prec) {
    93a6:	92 81       	ldd	r25, Z+2	; 0x02
    93a8:	99 23       	and	r25, r25
    93aa:	09 f4       	brne	.+2      	; 0x93ae <PutVal+0x76>
    93ac:	58 c0       	rjmp	.+176    	; 0x945e <PutVal+0x126>
		Format[1] -= Param->Prec+1;
    93ae:	89 2f       	mov	r24, r25
    93b0:	80 95       	com	r24
    93b2:	82 0f       	add	r24, r18
    93b4:	8a 83       	std	Y+2, r24	; 0x02
		Format[6] = '0'+Param->Prec;
    93b6:	90 5d       	subi	r25, 0xD0	; 208
    93b8:	9f 83       	std	Y+7, r25	; 0x07
    93ba:	90 53       	subi	r25, 0x30	; 48
		uint16_t Div=Pow10(Param->Prec);
    93bc:	29 2f       	mov	r18, r25
    93be:	01 e0       	ldi	r16, 0x01	; 1
    93c0:	10 e0       	ldi	r17, 0x00	; 0
		Pow *= 10;
    93c2:	c8 01       	movw	r24, r16
    93c4:	88 0f       	add	r24, r24
    93c6:	99 1f       	adc	r25, r25
    93c8:	00 0f       	add	r16, r16
    93ca:	11 1f       	adc	r17, r17
    93cc:	00 0f       	add	r16, r16
    93ce:	11 1f       	adc	r17, r17
    93d0:	00 0f       	add	r16, r16
    93d2:	11 1f       	adc	r17, r17
    93d4:	08 0f       	add	r16, r24
    93d6:	19 1f       	adc	r17, r25
    93d8:	21 50       	subi	r18, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    93da:	99 f7       	brne	.-26     	; 0x93c2 <PutVal+0x8a>
    93dc:	c6 01       	movw	r24, r12
    93de:	b8 01       	movw	r22, r16
    93e0:	0e 94 42 82 	call	0x10484	; 0x10484 <__udivmodhi4>
    93e4:	9c 01       	movw	r18, r24
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
    93e6:	8d b7       	in	r24, 0x3d	; 61
    93e8:	9e b7       	in	r25, 0x3e	; 62
    93ea:	08 97       	sbiw	r24, 0x08	; 8
    93ec:	0f b6       	in	r0, 0x3f	; 63
    93ee:	f8 94       	cli
    93f0:	9e bf       	out	0x3e, r25	; 62
    93f2:	0f be       	out	0x3f, r0	; 63
    93f4:	8d bf       	out	0x3d, r24	; 61
    93f6:	ed b7       	in	r30, 0x3d	; 61
    93f8:	fe b7       	in	r31, 0x3e	; 62
    93fa:	31 96       	adiw	r30, 0x01	; 1
    93fc:	d7 01       	movw	r26, r14
    93fe:	8d 91       	ld	r24, X+
    9400:	9c 91       	ld	r25, X
    9402:	ad b7       	in	r26, 0x3d	; 61
    9404:	be b7       	in	r27, 0x3e	; 62
    9406:	12 96       	adiw	r26, 0x02	; 2
    9408:	9c 93       	st	X, r25
    940a:	8e 93       	st	-X, r24
    940c:	11 97       	sbiw	r26, 0x01	; 1
    940e:	b3 82       	std	Z+3, r11	; 0x03
    9410:	a2 82       	std	Z+2, r10	; 0x02
    9412:	c6 01       	movw	r24, r12
    9414:	b8 01       	movw	r22, r16
    9416:	0e 94 42 82 	call	0x10484	; 0x10484 <__udivmodhi4>
    941a:	75 83       	std	Z+5, r23	; 0x05
    941c:	64 83       	std	Z+4, r22	; 0x04
    941e:	26 83       	std	Z+6, r18	; 0x06
    9420:	37 83       	std	Z+7, r19	; 0x07
    9422:	0e 94 ad 7f 	call	0xff5a	; 0xff5a <sprintf>
    9426:	ed b7       	in	r30, 0x3d	; 61
    9428:	fe b7       	in	r31, 0x3e	; 62
    942a:	38 96       	adiw	r30, 0x08	; 8
    942c:	0f b6       	in	r0, 0x3f	; 63
    942e:	f8 94       	cli
    9430:	fe bf       	out	0x3e, r31	; 62
    9432:	0f be       	out	0x3f, r0	; 63
    9434:	ed bf       	out	0x3d, r30	; 61
	}
	else {
		Format[3] = '\0';
		sprintf(Param->Pos, Format, Val);
	}
}
    9436:	29 96       	adiw	r28, 0x09	; 9
    9438:	0f b6       	in	r0, 0x3f	; 63
    943a:	f8 94       	cli
    943c:	de bf       	out	0x3e, r29	; 62
    943e:	0f be       	out	0x3f, r0	; 63
    9440:	cd bf       	out	0x3d, r28	; 61
    9442:	cf 91       	pop	r28
    9444:	df 91       	pop	r29
    9446:	1f 91       	pop	r17
    9448:	0f 91       	pop	r16
    944a:	ff 90       	pop	r15
    944c:	ef 90       	pop	r14
    944e:	df 90       	pop	r13
    9450:	cf 90       	pop	r12
    9452:	bf 90       	pop	r11
    9454:	af 90       	pop	r10
    9456:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
PutVal(uint16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
    9458:	8f ef       	ldi	r24, 0xFF	; 255
    945a:	9f ef       	ldi	r25, 0xFF	; 255
    945c:	86 cf       	rjmp	.-244    	; 0x936a <PutVal+0x32>
		Format[6] = '0'+Param->Prec;
		uint16_t Div=Pow10(Param->Prec);
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
	}
	else {
		Format[3] = '\0';
    945e:	1c 82       	std	Y+4, r1	; 0x04
		sprintf(Param->Pos, Format, Val);
    9460:	00 d0       	rcall	.+0      	; 0x9462 <PutVal+0x12a>
    9462:	00 d0       	rcall	.+0      	; 0x9464 <PutVal+0x12c>
    9464:	ed b7       	in	r30, 0x3d	; 61
    9466:	fe b7       	in	r31, 0x3e	; 62
    9468:	31 96       	adiw	r30, 0x01	; 1
    946a:	d7 01       	movw	r26, r14
    946c:	8d 91       	ld	r24, X+
    946e:	9c 91       	ld	r25, X
    9470:	ad b7       	in	r26, 0x3d	; 61
    9472:	be b7       	in	r27, 0x3e	; 62
    9474:	12 96       	adiw	r26, 0x02	; 2
    9476:	9c 93       	st	X, r25
    9478:	8e 93       	st	-X, r24
    947a:	11 97       	sbiw	r26, 0x01	; 1
    947c:	b3 82       	std	Z+3, r11	; 0x03
    947e:	a2 82       	std	Z+2, r10	; 0x02
    9480:	d5 82       	std	Z+5, r13	; 0x05
    9482:	c4 82       	std	Z+4, r12	; 0x04
    9484:	0e 94 ad 7f 	call	0xff5a	; 0xff5a <sprintf>
    9488:	ed b7       	in	r30, 0x3d	; 61
    948a:	fe b7       	in	r31, 0x3e	; 62
    948c:	36 96       	adiw	r30, 0x06	; 6
    948e:	0f b6       	in	r0, 0x3f	; 63
    9490:	f8 94       	cli
    9492:	fe bf       	out	0x3e, r31	; 62
    9494:	0f be       	out	0x3f, r0	; 63
    9496:	ed bf       	out	0x3d, r30	; 61
    9498:	ce cf       	rjmp	.-100    	; 0x9436 <PutVal+0xfe>
void
PutVal(uint16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
	if(Param->Txt && Idx<2) {
		Param->Txt += Idx;
    949a:	88 0f       	add	r24, r24
    949c:	99 1f       	adc	r25, r25
    949e:	28 0f       	add	r18, r24
    94a0:	39 1f       	adc	r19, r25
    94a2:	15 96       	adiw	r26, 0x05	; 5
    94a4:	3c 93       	st	X, r19
    94a6:	2e 93       	st	-X, r18
    94a8:	14 97       	sbiw	r26, 0x04	; 4
		PutEnum(Param);
    94aa:	c7 01       	movw	r24, r14
    94ac:	0e 94 9e 40 	call	0x813c	; 0x813c <PutEnum>
    94b0:	c2 cf       	rjmp	.-124    	; 0x9436 <PutVal+0xfe>

000094b2 <GSM_Wait_Response_P>:
//	}
	if(strcmp(GSM_RxStr, Str))return 0;
	else return 1;
}
// ~~~~~~~~~
uint8_t GSM_Wait_Response_P(prog_char *Str_P, uint8_t RestoreCMD){
    94b2:	1f 93       	push	r17
    94b4:	cf 93       	push	r28
    94b6:	df 93       	push	r29
    94b8:	ec 01       	movw	r28, r24
    94ba:	16 2f       	mov	r17, r22
	
	if(Timer16Stopp(TD_GSM) && RestoreCMD){
    94bc:	80 91 e7 04 	lds	r24, 0x04E7
    94c0:	0e 94 06 1c 	call	0x380c	; 0x380c <Timer16Stopp>
    94c4:	88 23       	and	r24, r24
    94c6:	11 f0       	breq	.+4      	; 0x94cc <GSM_Wait_Response_P+0x1a>
    94c8:	11 23       	and	r17, r17
    94ca:	51 f4       	brne	.+20     	; 0x94e0 <GSM_Wait_Response_P+0x2e>
		GSM_State = RestoreCMD;
		return 0;
	}
	//  
	if(GetStringFromFIFO()){
    94cc:	0e 94 80 38 	call	0x7100	; 0x7100 <GetStringFromFIFO>
    94d0:	88 23       	and	r24, r24
    94d2:	71 f4       	brne	.+28     	; 0x94f0 <GSM_Wait_Response_P+0x3e>
    94d4:	20 e0       	ldi	r18, 0x00	; 0
		if(strcmp_P(GSM_RxStr, Str_P)) return 0;
		else return 1;
	}
	else return 0;
}
    94d6:	82 2f       	mov	r24, r18
    94d8:	df 91       	pop	r29
    94da:	cf 91       	pop	r28
    94dc:	1f 91       	pop	r17
    94de:	08 95       	ret
}
// ~~~~~~~~~
uint8_t GSM_Wait_Response_P(prog_char *Str_P, uint8_t RestoreCMD){
	
	if(Timer16Stopp(TD_GSM) && RestoreCMD){
		GSM_State = RestoreCMD;
    94e0:	10 93 b3 06 	sts	0x06B3, r17
    94e4:	20 e0       	ldi	r18, 0x00	; 0
	if(GetStringFromFIFO()){
		if(strcmp_P(GSM_RxStr, Str_P)) return 0;
		else return 1;
	}
	else return 0;
}
    94e6:	82 2f       	mov	r24, r18
    94e8:	df 91       	pop	r29
    94ea:	cf 91       	pop	r28
    94ec:	1f 91       	pop	r17
    94ee:	08 95       	ret
		GSM_State = RestoreCMD;
		return 0;
	}
	//  
	if(GetStringFromFIFO()){
		if(strcmp_P(GSM_RxStr, Str_P)) return 0;
    94f0:	89 e9       	ldi	r24, 0x99	; 153
    94f2:	97 e0       	ldi	r25, 0x07	; 7
    94f4:	be 01       	movw	r22, r28
    94f6:	0e 94 b1 7e 	call	0xfd62	; 0xfd62 <strcmp_P>
    94fa:	20 e0       	ldi	r18, 0x00	; 0
    94fc:	89 2b       	or	r24, r25
    94fe:	59 f7       	brne	.-42     	; 0x94d6 <GSM_Wait_Response_P+0x24>
    9500:	21 e0       	ldi	r18, 0x01	; 1
		else return 1;
	}
	else return 0;
}
    9502:	82 2f       	mov	r24, r18
    9504:	df 91       	pop	r29
    9506:	cf 91       	pop	r28
    9508:	1f 91       	pop	r17
    950a:	08 95       	ret

0000950c <GSM_SendCR>:
	
	sei();	
}
// ~~~~~~~~~
//   + CR
void GSM_SendCR(prog_char *Str_P){
    950c:	ef 92       	push	r14
    950e:	ff 92       	push	r15
    9510:	0f 93       	push	r16
    9512:	1f 93       	push	r17
    9514:	7c 01       	movw	r14, r24
	GSMTxSz = strlen_P(Str_P);
    9516:	0e 94 c1 7e 	call	0xfd82	; 0xfd82 <strlen_P>
    951a:	80 93 75 07 	sts	0x0775, r24
	sprintf_P(GSM_TxStr, Str_P);
    951e:	00 d0       	rcall	.+0      	; 0x9520 <GSM_SendCR+0x14>
    9520:	0f 92       	push	r0
    9522:	02 e0       	ldi	r16, 0x02	; 2
    9524:	1a e0       	ldi	r17, 0x0A	; 10
    9526:	ed b7       	in	r30, 0x3d	; 61
    9528:	fe b7       	in	r31, 0x3e	; 62
    952a:	12 83       	std	Z+2, r17	; 0x02
    952c:	01 83       	std	Z+1, r16	; 0x01
    952e:	f4 82       	std	Z+4, r15	; 0x04
    9530:	e3 82       	std	Z+3, r14	; 0x03
    9532:	0e 94 de 7f 	call	0xffbc	; 0xffbc <sprintf_P>
	sprintf(GSM_TxStr + GSMTxSz, "\r");
    9536:	80 91 75 07 	lds	r24, 0x0775
    953a:	08 0f       	add	r16, r24
    953c:	11 1d       	adc	r17, r1
    953e:	8d e0       	ldi	r24, 0x0D	; 13
    9540:	90 e0       	ldi	r25, 0x00	; 0
    9542:	f8 01       	movw	r30, r16
    9544:	91 83       	std	Z+1, r25	; 0x01
    9546:	80 83       	st	Z, r24
	GSMTxSz++;
    9548:	80 91 75 07 	lds	r24, 0x0775
    954c:	8f 5f       	subi	r24, 0xFF	; 255
    954e:	80 93 75 07 	sts	0x0775, r24
	GSM_SendFirstChar();
    9552:	0f 90       	pop	r0
    9554:	0f 90       	pop	r0
    9556:	0f 90       	pop	r0
    9558:	0f 90       	pop	r0
    955a:	0e 94 aa 39 	call	0x7354	; 0x7354 <GSM_SendFirstChar>
}
    955e:	1f 91       	pop	r17
    9560:	0f 91       	pop	r16
    9562:	ff 90       	pop	r15
    9564:	ef 90       	pop	r14
    9566:	08 95       	ret

00009568 <GSM_Execute_Command>:
	GSMTxSz = Size;
	memcpy(GSM_TxStr, Data_Out, GSMTxSz);
	GSM_SendFirstChar();
}
// ~~~~~~~~~
void GSM_Execute_Command(prog_char *Str_P, uint16_t Timeout){
    9568:	cf 93       	push	r28
    956a:	df 93       	push	r29
    956c:	9c 01       	movw	r18, r24
    956e:	eb 01       	movw	r28, r22
	if(GSM_Flag & (1<<flg_TxCStr)){
    9570:	80 91 d2 02 	lds	r24, 0x02D2
    9574:	80 ff       	sbrs	r24, 0
    9576:	08 c0       	rjmp	.+16     	; 0x9588 <GSM_Execute_Command+0x20>
		GSM_SendCR(Str_P);
    9578:	c9 01       	movw	r24, r18
    957a:	0e 94 86 4a 	call	0x950c	; 0x950c <GSM_SendCR>
		StartTimer16(TD_GSM, Timeout);
    957e:	80 91 e7 04 	lds	r24, 0x04E7
    9582:	be 01       	movw	r22, r28
    9584:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
	}
}
    9588:	df 91       	pop	r29
    958a:	cf 91       	pop	r28
    958c:	08 95       	ret

0000958e <analize_DTMF>:
uint8_t GSM_GotoNextVega(void){
 return 0;
}
uint8_t counter=0;
uint8_t analize_DTMF(){
	if((strstr_P(GSM_RxStr, PSTR("+DTMF: 1")) != NULL) ){
    958e:	89 e9       	ldi	r24, 0x99	; 153
    9590:	97 e0       	ldi	r25, 0x07	; 7
    9592:	62 e6       	ldi	r22, 0x62	; 98
    9594:	7d e2       	ldi	r23, 0x2D	; 45
    9596:	0e 94 e3 7e 	call	0xfdc6	; 0xfdc6 <strstr_P>
    959a:	89 2b       	or	r24, r25
    959c:	59 f0       	breq	.+22     	; 0x95b4 <analize_DTMF+0x26>
		StartTimer16(TD_GSM,1000);
    959e:	80 91 e7 04 	lds	r24, 0x04E7
    95a2:	68 ee       	ldi	r22, 0xE8	; 232
    95a4:	73 e0       	ldi	r23, 0x03	; 3
    95a6:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
		GSM_State = GSM_SEND_CREC_5;
    95aa:	8b e1       	ldi	r24, 0x1B	; 27
    95ac:	80 93 b3 06 	sts	0x06B3, r24
    95b0:	81 e0       	ldi	r24, 0x01	; 1
    95b2:	08 95       	ret
		return 1;
	}
	if((strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6")) != NULL) ){
    95b4:	89 e9       	ldi	r24, 0x99	; 153
    95b6:	97 e0       	ldi	r25, 0x07	; 7
    95b8:	65 e5       	ldi	r22, 0x55	; 85
    95ba:	7d e2       	ldi	r23, 0x2D	; 45
    95bc:	0e 94 e3 7e 	call	0xfdc6	; 0xfdc6 <strstr_P>
    95c0:	89 2b       	or	r24, r25
    95c2:	59 f0       	breq	.+22     	; 0x95da <analize_DTMF+0x4c>
		StartTimer16(TD_GSM,2000);
    95c4:	80 91 e7 04 	lds	r24, 0x04E7
    95c8:	60 ed       	ldi	r22, 0xD0	; 208
    95ca:	77 e0       	ldi	r23, 0x07	; 7
    95cc:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
		GSM_State = GSM_WAIT_DISCONNECT_CAUSE;
    95d0:	85 e2       	ldi	r24, 0x25	; 37
    95d2:	80 93 b3 06 	sts	0x06B3, r24
    95d6:	81 e0       	ldi	r24, 0x01	; 1
		return 1;
	}
	return 0;
}
    95d8:	08 95       	ret
	if((strstr_P(GSM_RxStr, PSTR("+DTMF: 1")) != NULL) ){
		StartTimer16(TD_GSM,1000);
		GSM_State = GSM_SEND_CREC_5;
		return 1;
	}
	if((strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6")) != NULL) ){
    95da:	80 e0       	ldi	r24, 0x00	; 0
    95dc:	08 95       	ret

000095de <GSM_Wait_Response>:
	#endif

}
// ~~~~~~~~~
//   GetStringFromFIFO()!
uint8_t GSM_Wait_Response(char *Str, uint8_t RestoreCMD){
    95de:	bc 01       	movw	r22, r24
//	if(Timer16Stopp(TD_GSM) && RestoreCMD){
//		GSM_State = RestoreCMD;
//		return 0;
//	}
	if(strcmp(GSM_RxStr, Str))return 0;
    95e0:	89 e9       	ldi	r24, 0x99	; 153
    95e2:	97 e0       	ldi	r25, 0x07	; 7
    95e4:	0e 94 11 7f 	call	0xfe22	; 0xfe22 <strcmp>
    95e8:	9c 01       	movw	r18, r24
    95ea:	80 e0       	ldi	r24, 0x00	; 0
    95ec:	23 2b       	or	r18, r19
    95ee:	09 f4       	brne	.+2      	; 0x95f2 <GSM_Wait_Response+0x14>
    95f0:	81 e0       	ldi	r24, 0x01	; 1
	else return 1;
}
    95f2:	08 95       	ret

000095f4 <DigiFilt>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
DigiFilt(const uint16_t *Array, uint8_t Edge)
{
    95f4:	6f 92       	push	r6
    95f6:	7f 92       	push	r7
    95f8:	8f 92       	push	r8
    95fa:	9f 92       	push	r9
    95fc:	bf 92       	push	r11
    95fe:	cf 92       	push	r12
    9600:	df 92       	push	r13
    9602:	ef 92       	push	r14
    9604:	ff 92       	push	r15
    9606:	0f 93       	push	r16
    9608:	1f 93       	push	r17
    960a:	df 93       	push	r29
    960c:	cf 93       	push	r28
    960e:	cd b7       	in	r28, 0x3d	; 61
    9610:	de b7       	in	r29, 0x3e	; 62
    9612:	28 2f       	mov	r18, r24
    9614:	79 2f       	mov	r23, r25
    9616:	e6 2e       	mov	r14, r22
				Buf[i] = Buf[j];
				Buf[j] = Swap;
			}
	for(i=Edge; i<_Edge; Sum+=Buf[i++]);
	return Sum/(Edge*2);
}
    9618:	6d b6       	in	r6, 0x3d	; 61
    961a:	7e b6       	in	r7, 0x3e	; 62

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
DigiFilt(const uint16_t *Array, uint8_t Edge)
{
	uint8_t Sz = Edge*4;
    961c:	86 2e       	mov	r8, r22
    961e:	99 24       	eor	r9, r9
    9620:	f6 2e       	mov	r15, r22
    9622:	ff 0c       	add	r15, r15
    9624:	ff 0c       	add	r15, r15
	uint8_t _Edge = Sz-Edge;
    9626:	bf 2c       	mov	r11, r15
    9628:	b6 1a       	sub	r11, r22
	uint16_t Buf[Sz];
    962a:	ef 2d       	mov	r30, r15
    962c:	f0 e0       	ldi	r31, 0x00	; 0
    962e:	ee 0f       	add	r30, r30
    9630:	ff 1f       	adc	r31, r31
    9632:	8d b7       	in	r24, 0x3d	; 61
    9634:	9e b7       	in	r25, 0x3e	; 62
    9636:	8e 1b       	sub	r24, r30
    9638:	9f 0b       	sbc	r25, r31
    963a:	0f b6       	in	r0, 0x3f	; 63
    963c:	f8 94       	cli
    963e:	9e bf       	out	0x3e, r25	; 62
    9640:	0f be       	out	0x3f, r0	; 63
    9642:	8d bf       	out	0x3d, r24	; 61
    9644:	0d b7       	in	r16, 0x3d	; 61
    9646:	1e b7       	in	r17, 0x3e	; 62
    9648:	0f 5f       	subi	r16, 0xFF	; 255
    964a:	1f 4f       	sbci	r17, 0xFF	; 255
	uint32_t Sum = 0;
	uint16_t Swap;
	uint8_t i, j;
	memcpy(Buf, Array, Sz*2);
    964c:	c8 01       	movw	r24, r16
    964e:	62 2f       	mov	r22, r18
    9650:	af 01       	movw	r20, r30
    9652:	0e 94 fd 7e 	call	0xfdfa	; 0xfdfa <memcpy>
	for(i=0; i<Edge; i++)
    9656:	ee 20       	and	r14, r14
    9658:	09 f1       	breq	.+66     	; 0x969c <DigiFilt+0xa8>
    965a:	d8 01       	movw	r26, r16
    965c:	80 e0       	ldi	r24, 0x00	; 0
		for(j=i+1; j<Sz; j++)
    965e:	58 2f       	mov	r21, r24
    9660:	5f 5f       	subi	r21, 0xFF	; 255
    9662:	5f 15       	cp	r21, r15
    9664:	b8 f4       	brcc	.+46     	; 0x9694 <DigiFilt+0xa0>
    9666:	45 2f       	mov	r20, r21
			if(Buf[j] < Buf[i]) {
    9668:	e4 2f       	mov	r30, r20
    966a:	f0 e0       	ldi	r31, 0x00	; 0
    966c:	ee 0f       	add	r30, r30
    966e:	ff 1f       	adc	r31, r31
    9670:	e0 0f       	add	r30, r16
    9672:	f1 1f       	adc	r31, r17
    9674:	20 81       	ld	r18, Z
    9676:	31 81       	ldd	r19, Z+1	; 0x01
    9678:	8d 91       	ld	r24, X+
    967a:	9c 91       	ld	r25, X
    967c:	11 97       	sbiw	r26, 0x01	; 1
    967e:	28 17       	cp	r18, r24
    9680:	39 07       	cpc	r19, r25
    9682:	28 f4       	brcc	.+10     	; 0x968e <DigiFilt+0x9a>
				Swap = Buf[i];
				Buf[i] = Buf[j];
    9684:	11 96       	adiw	r26, 0x01	; 1
    9686:	3c 93       	st	X, r19
    9688:	2e 93       	st	-X, r18
				Buf[j] = Swap;
    968a:	91 83       	std	Z+1, r25	; 0x01
    968c:	80 83       	st	Z, r24
	uint32_t Sum = 0;
	uint16_t Swap;
	uint8_t i, j;
	memcpy(Buf, Array, Sz*2);
	for(i=0; i<Edge; i++)
		for(j=i+1; j<Sz; j++)
    968e:	4f 5f       	subi	r20, 0xFF	; 255
    9690:	4f 15       	cp	r20, r15
    9692:	50 f3       	brcs	.-44     	; 0x9668 <DigiFilt+0x74>
    9694:	12 96       	adiw	r26, 0x02	; 2
    9696:	85 2f       	mov	r24, r21
	uint16_t Buf[Sz];
	uint32_t Sum = 0;
	uint16_t Swap;
	uint8_t i, j;
	memcpy(Buf, Array, Sz*2);
	for(i=0; i<Edge; i++)
    9698:	5e 15       	cp	r21, r14
    969a:	08 f3       	brcs	.-62     	; 0x965e <DigiFilt+0x6a>
			if(Buf[j] < Buf[i]) {
				Swap = Buf[i];
				Buf[i] = Buf[j];
				Buf[j] = Swap;
			}
	for(i=Sz-1; i>=_Edge; i--)
    969c:	ef 2d       	mov	r30, r15
    969e:	e1 50       	subi	r30, 0x01	; 1
    96a0:	eb 15       	cp	r30, r11
    96a2:	10 f1       	brcs	.+68     	; 0x96e8 <DigiFilt+0xf4>
		for(j=i-1; j>=Edge; j--)
    96a4:	5e 2f       	mov	r21, r30
    96a6:	51 50       	subi	r21, 0x01	; 1
    96a8:	5e 15       	cp	r21, r14
    96aa:	d8 f0       	brcs	.+54     	; 0x96e2 <DigiFilt+0xee>
    96ac:	f0 e0       	ldi	r31, 0x00	; 0
    96ae:	45 2f       	mov	r20, r21
    96b0:	ee 0f       	add	r30, r30
    96b2:	ff 1f       	adc	r31, r31
			if(Buf[j] > Buf[i]) {
    96b4:	e0 0f       	add	r30, r16
    96b6:	f1 1f       	adc	r31, r17
    96b8:	a4 2f       	mov	r26, r20
    96ba:	b0 e0       	ldi	r27, 0x00	; 0
    96bc:	aa 0f       	add	r26, r26
    96be:	bb 1f       	adc	r27, r27
    96c0:	a0 0f       	add	r26, r16
    96c2:	b1 1f       	adc	r27, r17
    96c4:	2d 91       	ld	r18, X+
    96c6:	3c 91       	ld	r19, X
    96c8:	11 97       	sbiw	r26, 0x01	; 1
    96ca:	80 81       	ld	r24, Z
    96cc:	91 81       	ldd	r25, Z+1	; 0x01
    96ce:	82 17       	cp	r24, r18
    96d0:	93 07       	cpc	r25, r19
    96d2:	20 f4       	brcc	.+8      	; 0x96dc <DigiFilt+0xe8>
				Swap = Buf[i];
				Buf[i] = Buf[j];
    96d4:	31 83       	std	Z+1, r19	; 0x01
    96d6:	20 83       	st	Z, r18
				Buf[j] = Swap;
    96d8:	8d 93       	st	X+, r24
    96da:	9c 93       	st	X, r25
				Swap = Buf[i];
				Buf[i] = Buf[j];
				Buf[j] = Swap;
			}
	for(i=Sz-1; i>=_Edge; i--)
		for(j=i-1; j>=Edge; j--)
    96dc:	41 50       	subi	r20, 0x01	; 1
    96de:	4e 15       	cp	r20, r14
    96e0:	58 f7       	brcc	.-42     	; 0x96b8 <DigiFilt+0xc4>
    96e2:	e5 2f       	mov	r30, r21
			if(Buf[j] < Buf[i]) {
				Swap = Buf[i];
				Buf[i] = Buf[j];
				Buf[j] = Swap;
			}
	for(i=Sz-1; i>=_Edge; i--)
    96e4:	5b 15       	cp	r21, r11
    96e6:	f0 f6       	brcc	.-68     	; 0x96a4 <DigiFilt+0xb0>
			if(Buf[j] > Buf[i]) {
				Swap = Buf[i];
				Buf[i] = Buf[j];
				Buf[j] = Swap;
			}
	for(i=Edge; i<_Edge; Sum+=Buf[i++]);
    96e8:	eb 14       	cp	r14, r11
    96ea:	a0 f5       	brcc	.+104    	; 0x9754 <DigiFilt+0x160>
    96ec:	6e 2d       	mov	r22, r14
    96ee:	cc 24       	eor	r12, r12
    96f0:	dd 24       	eor	r13, r13
    96f2:	76 01       	movw	r14, r12
    96f4:	e6 2f       	mov	r30, r22
    96f6:	f0 e0       	ldi	r31, 0x00	; 0
    96f8:	ee 0f       	add	r30, r30
    96fa:	ff 1f       	adc	r31, r31
    96fc:	e0 0f       	add	r30, r16
    96fe:	f1 1f       	adc	r31, r17
    9700:	80 81       	ld	r24, Z
    9702:	91 81       	ldd	r25, Z+1	; 0x01
    9704:	a0 e0       	ldi	r26, 0x00	; 0
    9706:	b0 e0       	ldi	r27, 0x00	; 0
    9708:	c8 0e       	add	r12, r24
    970a:	d9 1e       	adc	r13, r25
    970c:	ea 1e       	adc	r14, r26
    970e:	fb 1e       	adc	r15, r27
    9710:	6f 5f       	subi	r22, 0xFF	; 255
    9712:	6b 15       	cp	r22, r11
    9714:	78 f3       	brcs	.-34     	; 0x96f4 <DigiFilt+0x100>
    9716:	88 0c       	add	r8, r8
    9718:	99 1c       	adc	r9, r9
    971a:	94 01       	movw	r18, r8
    971c:	44 27       	eor	r20, r20
    971e:	37 fd       	sbrc	r19, 7
    9720:	40 95       	com	r20
    9722:	54 2f       	mov	r21, r20
    9724:	c7 01       	movw	r24, r14
    9726:	b6 01       	movw	r22, r12
    9728:	0e 94 69 82 	call	0x104d2	; 0x104d2 <__udivmodsi4>
    972c:	c9 01       	movw	r24, r18
	return Sum/(Edge*2);
}
    972e:	0f b6       	in	r0, 0x3f	; 63
    9730:	f8 94       	cli
    9732:	7e be       	out	0x3e, r7	; 62
    9734:	0f be       	out	0x3f, r0	; 63
    9736:	6d be       	out	0x3d, r6	; 61
    9738:	cf 91       	pop	r28
    973a:	df 91       	pop	r29
    973c:	1f 91       	pop	r17
    973e:	0f 91       	pop	r16
    9740:	ff 90       	pop	r15
    9742:	ef 90       	pop	r14
    9744:	df 90       	pop	r13
    9746:	cf 90       	pop	r12
    9748:	bf 90       	pop	r11
    974a:	9f 90       	pop	r9
    974c:	8f 90       	pop	r8
    974e:	7f 90       	pop	r7
    9750:	6f 90       	pop	r6
    9752:	08 95       	ret
			if(Buf[j] > Buf[i]) {
				Swap = Buf[i];
				Buf[i] = Buf[j];
				Buf[j] = Swap;
			}
	for(i=Edge; i<_Edge; Sum+=Buf[i++]);
    9754:	cc 24       	eor	r12, r12
    9756:	dd 24       	eor	r13, r13
    9758:	76 01       	movw	r14, r12
    975a:	dd cf       	rjmp	.-70     	; 0x9716 <DigiFilt+0x122>

0000975c <MemFailReset>:

// ~~~~~~~~~~~~~~~
void
MemFailReset(void)
{
	if (MemFail &(1<<MemFail_EEPROM)) {
    975c:	80 91 cf 08 	lds	r24, 0x08CF
    9760:	81 ff       	sbrs	r24, 1
    9762:	08 95       	ret
		MemFail &=~(1<<MemFail_EEPROM);
    9764:	8d 7f       	andi	r24, 0xFD	; 253
    9766:	80 93 cf 08 	sts	0x08CF, r24
		eeprom_write_word(&MemCheck_stor.CRC_EEPROM_stor, CRC_EEPROM_calc());
    976a:	0e 94 a5 19 	call	0x334a	; 0x334a <CRC_EEPROM_calc>
    976e:	bc 01       	movw	r22, r24
    9770:	8a e3       	ldi	r24, 0x3A	; 58
    9772:	91 e0       	ldi	r25, 0x01	; 1
    9774:	0e 94 0f 82 	call	0x1041e	; 0x1041e <__eewr_word_m2560>
    9778:	08 95       	ret

0000977a <Key_Mem>:
		MenuPage Menu_BackUp = { SetMenu(Menu_BackUp_List), 1, NULL,
				NULL, NULL, NULL, Menu_BackUp_Enter, NULL, NULL, NULL};
#endif

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t Key_Mem(void) {if(CurrLine==3) MemFailReset(); return StandartKey;}
    977a:	80 91 83 07 	lds	r24, 0x0783
    977e:	83 30       	cpi	r24, 0x03	; 3
    9780:	11 f0       	breq	.+4      	; 0x9786 <Key_Mem+0xc>
    9782:	80 e0       	ldi	r24, 0x00	; 0
    9784:	08 95       	ret
    9786:	0e 94 ae 4b 	call	0x975c	; 0x975c <MemFailReset>
    978a:	80 e0       	ldi	r24, 0x00	; 0
    978c:	08 95       	ret

0000978e <CRC_EEPROM_upd>:
// ~~~~~~~~~~~~~~~~~
// Duration: 48 ms
static void
CRC_EEPROM_upd(void)
{
	if (!(MemFail &(1<<MemFail_EEPROM)))
    978e:	80 91 cf 08 	lds	r24, 0x08CF
    9792:	81 fd       	sbrc	r24, 1
    9794:	08 95       	ret
		eeprom_write_word(&MemCheck_stor.CRC_EEPROM_stor, CRC_EEPROM_calc());
    9796:	0e 94 a5 19 	call	0x334a	; 0x334a <CRC_EEPROM_calc>
    979a:	bc 01       	movw	r22, r24
    979c:	8a e3       	ldi	r24, 0x3A	; 58
    979e:	91 e0       	ldi	r25, 0x01	; 1
    97a0:	0e 94 0f 82 	call	0x1041e	; 0x1041e <__eewr_word_m2560>
    97a4:	08 95       	ret

000097a6 <ewb>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ewb(uint8_t *addr, uint8_t val)
{
	//IntOff();
	eeprom_write_byte(addr, val);
    97a6:	0e 94 f9 81 	call	0x103f2	; 0x103f2 <__eewr_byte_m2560>
	CRC_EEPROM_upd();
    97aa:	0e 94 c7 4b 	call	0x978e	; 0x978e <CRC_EEPROM_upd>
	//IntOn();
}
    97ae:	08 95       	ret

000097b0 <MB_M_TimeOff_Set>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_M_TimeOff_Set(uint8_t MB_N)
{
	ewb(&MB_M_Param_EE[MB_N].TimeOff, MB_M_TimeOff[MB_N]);
    97b0:	e8 2f       	mov	r30, r24
    97b2:	f0 e0       	ldi	r31, 0x00	; 0
    97b4:	cf 01       	movw	r24, r30
    97b6:	88 0f       	add	r24, r24
    97b8:	99 1f       	adc	r25, r25
    97ba:	88 0f       	add	r24, r24
    97bc:	99 1f       	adc	r25, r25
    97be:	8e 0f       	add	r24, r30
    97c0:	9f 1f       	adc	r25, r31
    97c2:	e3 52       	subi	r30, 0x23	; 35
    97c4:	fa 4f       	sbci	r31, 0xFA	; 250
    97c6:	8a 5c       	subi	r24, 0xCA	; 202
    97c8:	9e 4f       	sbci	r25, 0xFE	; 254
    97ca:	60 81       	ld	r22, Z
    97cc:	0e 94 d3 4b 	call	0x97a6	; 0x97a6 <ewb>
}
    97d0:	08 95       	ret

000097d2 <MB_M_Try_Set>:

// ~~~~~~~~~~~~~~~~~~~~~~~
void
MB_M_Try_Set(uint8_t MB_N)
{
	ewb(&MB_M_Param_EE[MB_N].Try, MB_M_Try[MB_N]);
    97d2:	e8 2f       	mov	r30, r24
    97d4:	f0 e0       	ldi	r31, 0x00	; 0
    97d6:	cf 01       	movw	r24, r30
    97d8:	88 0f       	add	r24, r24
    97da:	99 1f       	adc	r25, r25
    97dc:	88 0f       	add	r24, r24
    97de:	99 1f       	adc	r25, r25
    97e0:	8e 0f       	add	r24, r30
    97e2:	9f 1f       	adc	r25, r31
    97e4:	e5 50       	subi	r30, 0x05	; 5
    97e6:	f9 4f       	sbci	r31, 0xF9	; 249
    97e8:	8b 5c       	subi	r24, 0xCB	; 203
    97ea:	9e 4f       	sbci	r25, 0xFE	; 254
    97ec:	60 81       	ld	r22, Z
    97ee:	0e 94 d3 4b 	call	0x97a6	; 0x97a6 <ewb>
}
    97f2:	08 95       	ret

000097f4 <MB_M_Timeout_Set>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_M_Timeout_Set(uint8_t MB_N)
{
	ewb(&MB_M_Param_EE[MB_N].Timeout, MB_M_Timeout[MB_N]);
    97f4:	e8 2f       	mov	r30, r24
    97f6:	f0 e0       	ldi	r31, 0x00	; 0
    97f8:	cf 01       	movw	r24, r30
    97fa:	88 0f       	add	r24, r24
    97fc:	99 1f       	adc	r25, r25
    97fe:	88 0f       	add	r24, r24
    9800:	99 1f       	adc	r25, r25
    9802:	8e 0f       	add	r24, r30
    9804:	9f 1f       	adc	r25, r31
    9806:	ef 51       	subi	r30, 0x1F	; 31
    9808:	f7 4f       	sbci	r31, 0xF7	; 247
    980a:	8c 5c       	subi	r24, 0xCC	; 204
    980c:	9e 4f       	sbci	r25, 0xFE	; 254
    980e:	60 81       	ld	r22, Z
    9810:	0e 94 d3 4b 	call	0x97a6	; 0x97a6 <ewb>
}
    9814:	08 95       	ret

00009816 <Set_MB_Addr>:
	static uint8_t EEMEM MB_NativeAddr_EE[Modbus_Qt] = Init_MB_NativeAddr;
	// ~~~~~~~~~~~~~~~~~~~~~~
	void
	Set_MB_Addr(uint8_t MB_N)
	{
		ewb(MB_NativeAddr_EE+MB_N, MB_NativeAddr[MB_N]);
    9816:	e8 2f       	mov	r30, r24
    9818:	f0 e0       	ldi	r31, 0x00	; 0
    981a:	cf 01       	movw	r24, r30
    981c:	89 5c       	subi	r24, 0xC9	; 201
    981e:	9e 4f       	sbci	r25, 0xFE	; 254
    9820:	e2 52       	subi	r30, 0x22	; 34
    9822:	fa 4f       	sbci	r31, 0xFA	; 250
    9824:	60 81       	ld	r22, Z
    9826:	0e 94 d3 4b 	call	0x97a6	; 0x97a6 <ewb>
	}
    982a:	08 95       	ret

0000982c <eww>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
eww(uint16_t *addr, uint16_t val)
{
	//IntOff();
	eeprom_write_word(addr, val);
    982c:	0e 94 0f 82 	call	0x1041e	; 0x1041e <__eewr_word_m2560>
	CRC_EEPROM_upd();
    9830:	0e 94 c7 4b 	call	0x978e	; 0x978e <CRC_EEPROM_upd>
	//IntOn();
}
    9834:	08 95       	ret

00009836 <MB_M_Period_Set>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_M_Period_Set(uint8_t MB_N)
{
	eww(&MB_M_Param_EE[MB_N].Period, MB_M_Period[MB_N]);
    9836:	e8 2f       	mov	r30, r24
    9838:	f0 e0       	ldi	r31, 0x00	; 0
    983a:	cf 01       	movw	r24, r30
    983c:	88 0f       	add	r24, r24
    983e:	99 1f       	adc	r25, r25
    9840:	88 0f       	add	r24, r24
    9842:	99 1f       	adc	r25, r25
    9844:	8e 0f       	add	r24, r30
    9846:	9f 1f       	adc	r25, r31
    9848:	ee 0f       	add	r30, r30
    984a:	ff 1f       	adc	r31, r31
    984c:	e5 55       	subi	r30, 0x55	; 85
    984e:	f9 4f       	sbci	r31, 0xF9	; 249
    9850:	60 81       	ld	r22, Z
    9852:	71 81       	ldd	r23, Z+1	; 0x01
    9854:	8e 5c       	subi	r24, 0xCE	; 206
    9856:	9e 4f       	sbci	r25, 0xFE	; 254
    9858:	0e 94 16 4c 	call	0x982c	; 0x982c <eww>
}
    985c:	08 95       	ret

0000985e <OnTimeSave>:

// ~~~~~~~~~~~~~
void
OnTimeSave(void)
{
	ewb(&Timer1min_EE, Timer1min);
    985e:	8d e3       	ldi	r24, 0x3D	; 61
    9860:	91 e0       	ldi	r25, 0x01	; 1
    9862:	60 91 ae 06 	lds	r22, 0x06AE
    9866:	0e 94 d3 4b 	call	0x97a6	; 0x97a6 <ewb>
	eww(&Timer1hour_EE, Timer1hour);
    986a:	60 91 23 0c 	lds	r22, 0x0C23
    986e:	70 91 24 0c 	lds	r23, 0x0C24
    9872:	8e e3       	ldi	r24, 0x3E	; 62
    9874:	91 e0       	ldi	r25, 0x01	; 1
    9876:	0e 94 16 4c 	call	0x982c	; 0x982c <eww>
}
    987a:	08 95       	ret

0000987c <TimersInc>:
		HSC_Process();
	#endif
}
void 
TimersInc(void)
{
    987c:	ef 92       	push	r14
    987e:	ff 92       	push	r15
    9880:	0f 93       	push	r16
    9882:	1f 93       	push	r17
    9884:	cf 93       	push	r28
    9886:	df 93       	push	r29
	uint8_t i, TickCounterVar;	
	cli();
    9888:	f8 94       	cli
	TickCounterVar = TickCounter;
    988a:	e0 90 cf 04 	lds	r14, 0x04CF
	TickCounter = 0;
    988e:	10 92 cf 04 	sts	0x04CF, r1
	sei();
    9892:	78 94       	sei
	for(uint8_t j=0;j<TickCounterVar;j++){
    9894:	ee 20       	and	r14, r14
    9896:	09 f4       	brne	.+2      	; 0x989a <TimersInc+0x1e>
    9898:	c8 c0       	rjmp	.+400    	; 0x9a2a <TimersInc+0x1ae>
    989a:	ff 24       	eor	r15, r15
		LiveTime++;
	 	for (i=0; i<Timer8TotNumber; i++){
			cli();
			if (!(Timer8Flg[i/8] &(1<<i%8)) && --Timer8[i]==0)
				Timer8Flg[i/8] |=(1<<i%8);
    989c:	01 e0       	ldi	r16, 0x01	; 1
    989e:	10 e0       	ldi	r17, 0x00	; 0
	cli();
	TickCounterVar = TickCounter;
	TickCounter = 0;
	sei();
	for(uint8_t j=0;j<TickCounterVar;j++){
		LiveTime++;
    98a0:	80 91 7e 07 	lds	r24, 0x077E
    98a4:	90 91 7f 07 	lds	r25, 0x077F
    98a8:	a0 91 80 07 	lds	r26, 0x0780
    98ac:	b0 91 81 07 	lds	r27, 0x0781
    98b0:	01 96       	adiw	r24, 0x01	; 1
    98b2:	a1 1d       	adc	r26, r1
    98b4:	b1 1d       	adc	r27, r1
    98b6:	80 93 7e 07 	sts	0x077E, r24
    98ba:	90 93 7f 07 	sts	0x077F, r25
    98be:	a0 93 80 07 	sts	0x0780, r26
    98c2:	b0 93 81 07 	sts	0x0781, r27
    98c6:	40 e0       	ldi	r20, 0x00	; 0
    98c8:	50 e0       	ldi	r21, 0x00	; 0
	 	for (i=0; i<Timer8TotNumber; i++){
			cli();
    98ca:	f8 94       	cli
			if (!(Timer8Flg[i/8] &(1<<i%8)) && --Timer8[i]==0)
    98cc:	84 2f       	mov	r24, r20
    98ce:	86 95       	lsr	r24
    98d0:	86 95       	lsr	r24
    98d2:	86 95       	lsr	r24
    98d4:	a8 2f       	mov	r26, r24
    98d6:	b0 e0       	ldi	r27, 0x00	; 0
    98d8:	a1 55       	subi	r26, 0x51	; 81
    98da:	bb 4f       	sbci	r27, 0xFB	; 251
    98dc:	8c 91       	ld	r24, X
    98de:	ba 01       	movw	r22, r20
    98e0:	67 70       	andi	r22, 0x07	; 7
    98e2:	70 70       	andi	r23, 0x00	; 0
    98e4:	90 e0       	ldi	r25, 0x00	; 0
    98e6:	06 2e       	mov	r0, r22
    98e8:	02 c0       	rjmp	.+4      	; 0x98ee <TimersInc+0x72>
    98ea:	95 95       	asr	r25
    98ec:	87 95       	ror	r24
    98ee:	0a 94       	dec	r0
    98f0:	e2 f7       	brpl	.-8      	; 0x98ea <TimersInc+0x6e>
    98f2:	80 fd       	sbrc	r24, 0
    98f4:	12 c0       	rjmp	.+36     	; 0x991a <TimersInc+0x9e>
    98f6:	fa 01       	movw	r30, r20
    98f8:	eb 50       	subi	r30, 0x0B	; 11
    98fa:	fd 4f       	sbci	r31, 0xFD	; 253
    98fc:	80 81       	ld	r24, Z
    98fe:	81 50       	subi	r24, 0x01	; 1
    9900:	80 83       	st	Z, r24
    9902:	80 81       	ld	r24, Z
    9904:	88 23       	and	r24, r24
    9906:	49 f4       	brne	.+18     	; 0x991a <TimersInc+0x9e>
				Timer8Flg[i/8] |=(1<<i%8);
    9908:	2c 91       	ld	r18, X
    990a:	c8 01       	movw	r24, r16
    990c:	02 c0       	rjmp	.+4      	; 0x9912 <TimersInc+0x96>
    990e:	88 0f       	add	r24, r24
    9910:	99 1f       	adc	r25, r25
    9912:	6a 95       	dec	r22
    9914:	e2 f7       	brpl	.-8      	; 0x990e <TimersInc+0x92>
    9916:	28 2b       	or	r18, r24
    9918:	2c 93       	st	X, r18
			sei();
    991a:	78 94       	sei
    991c:	4f 5f       	subi	r20, 0xFF	; 255
    991e:	5f 4f       	sbci	r21, 0xFF	; 255
	TickCounterVar = TickCounter;
	TickCounter = 0;
	sei();
	for(uint8_t j=0;j<TickCounterVar;j++){
		LiveTime++;
	 	for (i=0; i<Timer8TotNumber; i++){
    9920:	48 35       	cpi	r20, 0x58	; 88
    9922:	51 05       	cpc	r21, r1
    9924:	91 f6       	brne	.-92     	; 0x98ca <TimersInc+0x4e>
    9926:	40 e0       	ldi	r20, 0x00	; 0
    9928:	50 e0       	ldi	r21, 0x00	; 0
			if (!(Timer8Flg[i/8] &(1<<i%8)) && --Timer8[i]==0)
				Timer8Flg[i/8] |=(1<<i%8);
			sei();
		}
		for (i=0; i<Timer16TotNumber; i++){
			cli();
    992a:	f8 94       	cli
			if (!(Timer16Flg[i/8] &(1<<i%8)) && --Timer16[i]==0)
    992c:	84 2f       	mov	r24, r20
    992e:	86 95       	lsr	r24
    9930:	86 95       	lsr	r24
    9932:	86 95       	lsr	r24
    9934:	a8 2f       	mov	r26, r24
    9936:	b0 e0       	ldi	r27, 0x00	; 0
    9938:	a5 54       	subi	r26, 0x45	; 69
    993a:	bb 4f       	sbci	r27, 0xFB	; 251
    993c:	8c 91       	ld	r24, X
    993e:	ba 01       	movw	r22, r20
    9940:	67 70       	andi	r22, 0x07	; 7
    9942:	70 70       	andi	r23, 0x00	; 0
    9944:	90 e0       	ldi	r25, 0x00	; 0
    9946:	06 2e       	mov	r0, r22
    9948:	02 c0       	rjmp	.+4      	; 0x994e <TimersInc+0xd2>
    994a:	95 95       	asr	r25
    994c:	87 95       	ror	r24
    994e:	0a 94       	dec	r0
    9950:	e2 f7       	brpl	.-8      	; 0x994a <TimersInc+0xce>
    9952:	80 fd       	sbrc	r24, 0
    9954:	17 c0       	rjmp	.+46     	; 0x9984 <TimersInc+0x108>
    9956:	fa 01       	movw	r30, r20
    9958:	ee 0f       	add	r30, r30
    995a:	ff 1f       	adc	r31, r31
    995c:	e3 5b       	subi	r30, 0xB3	; 179
    995e:	fc 4f       	sbci	r31, 0xFC	; 252
    9960:	80 81       	ld	r24, Z
    9962:	91 81       	ldd	r25, Z+1	; 0x01
    9964:	01 97       	sbiw	r24, 0x01	; 1
    9966:	91 83       	std	Z+1, r25	; 0x01
    9968:	80 83       	st	Z, r24
    996a:	80 81       	ld	r24, Z
    996c:	91 81       	ldd	r25, Z+1	; 0x01
    996e:	89 2b       	or	r24, r25
    9970:	49 f4       	brne	.+18     	; 0x9984 <TimersInc+0x108>
				Timer16Flg[i/8] |=(1<<i%8);
    9972:	2c 91       	ld	r18, X
    9974:	c8 01       	movw	r24, r16
    9976:	02 c0       	rjmp	.+4      	; 0x997c <TimersInc+0x100>
    9978:	88 0f       	add	r24, r24
    997a:	99 1f       	adc	r25, r25
    997c:	6a 95       	dec	r22
    997e:	e2 f7       	brpl	.-8      	; 0x9978 <TimersInc+0xfc>
    9980:	28 2b       	or	r18, r24
    9982:	2c 93       	st	X, r18
			sei();
    9984:	78 94       	sei
    9986:	4f 5f       	subi	r20, 0xFF	; 255
    9988:	5f 4f       	sbci	r21, 0xFF	; 255
			cli();
			if (!(Timer8Flg[i/8] &(1<<i%8)) && --Timer8[i]==0)
				Timer8Flg[i/8] |=(1<<i%8);
			sei();
		}
		for (i=0; i<Timer16TotNumber; i++){
    998a:	40 36       	cpi	r20, 0x60	; 96
    998c:	51 05       	cpc	r21, r1
    998e:	69 f6       	brne	.-102    	; 0x992a <TimersInc+0xae>
    9990:	40 e0       	ldi	r20, 0x00	; 0
    9992:	50 e0       	ldi	r21, 0x00	; 0
			if (!(Timer16Flg[i/8] &(1<<i%8)) && --Timer16[i]==0)
				Timer16Flg[i/8] |=(1<<i%8);
			sei();
		}
		for (i=0; i<Timer32TotNumber; i++){
			cli();
    9994:	f8 94       	cli
			if (!(Timer32Flg[i/8] &(1<<i%8)) && --Timer32[i]==0)
    9996:	84 2f       	mov	r24, r20
    9998:	86 95       	lsr	r24
    999a:	86 95       	lsr	r24
    999c:	86 95       	lsr	r24
    999e:	c8 2f       	mov	r28, r24
    99a0:	d0 e0       	ldi	r29, 0x00	; 0
    99a2:	c8 53       	subi	r28, 0x38	; 56
    99a4:	db 4f       	sbci	r29, 0xFB	; 251
    99a6:	88 81       	ld	r24, Y
    99a8:	ba 01       	movw	r22, r20
    99aa:	67 70       	andi	r22, 0x07	; 7
    99ac:	70 70       	andi	r23, 0x00	; 0
    99ae:	90 e0       	ldi	r25, 0x00	; 0
    99b0:	06 2e       	mov	r0, r22
    99b2:	02 c0       	rjmp	.+4      	; 0x99b8 <TimersInc+0x13c>
    99b4:	95 95       	asr	r25
    99b6:	87 95       	ror	r24
    99b8:	0a 94       	dec	r0
    99ba:	e2 f7       	brpl	.-8      	; 0x99b4 <TimersInc+0x138>
    99bc:	80 fd       	sbrc	r24, 0
    99be:	23 c0       	rjmp	.+70     	; 0x9a06 <TimersInc+0x18a>
    99c0:	fa 01       	movw	r30, r20
    99c2:	ee 0f       	add	r30, r30
    99c4:	ff 1f       	adc	r31, r31
    99c6:	ee 0f       	add	r30, r30
    99c8:	ff 1f       	adc	r31, r31
    99ca:	e3 5f       	subi	r30, 0xF3	; 243
    99cc:	fb 4f       	sbci	r31, 0xFB	; 251
    99ce:	80 81       	ld	r24, Z
    99d0:	91 81       	ldd	r25, Z+1	; 0x01
    99d2:	a2 81       	ldd	r26, Z+2	; 0x02
    99d4:	b3 81       	ldd	r27, Z+3	; 0x03
    99d6:	01 97       	sbiw	r24, 0x01	; 1
    99d8:	a1 09       	sbc	r26, r1
    99da:	b1 09       	sbc	r27, r1
    99dc:	80 83       	st	Z, r24
    99de:	91 83       	std	Z+1, r25	; 0x01
    99e0:	a2 83       	std	Z+2, r26	; 0x02
    99e2:	b3 83       	std	Z+3, r27	; 0x03
    99e4:	80 81       	ld	r24, Z
    99e6:	91 81       	ldd	r25, Z+1	; 0x01
    99e8:	a2 81       	ldd	r26, Z+2	; 0x02
    99ea:	b3 81       	ldd	r27, Z+3	; 0x03
    99ec:	00 97       	sbiw	r24, 0x00	; 0
    99ee:	a1 05       	cpc	r26, r1
    99f0:	b1 05       	cpc	r27, r1
    99f2:	49 f4       	brne	.+18     	; 0x9a06 <TimersInc+0x18a>
				Timer32Flg[i/8] |=(1<<i%8);	
    99f4:	28 81       	ld	r18, Y
    99f6:	c8 01       	movw	r24, r16
    99f8:	02 c0       	rjmp	.+4      	; 0x99fe <TimersInc+0x182>
    99fa:	88 0f       	add	r24, r24
    99fc:	99 1f       	adc	r25, r25
    99fe:	6a 95       	dec	r22
    9a00:	e2 f7       	brpl	.-8      	; 0x99fa <TimersInc+0x17e>
    9a02:	28 2b       	or	r18, r24
    9a04:	28 83       	st	Y, r18
			sei();
    9a06:	78 94       	sei
    9a08:	4f 5f       	subi	r20, 0xFF	; 255
    9a0a:	5f 4f       	sbci	r21, 0xFF	; 255
			cli();
			if (!(Timer16Flg[i/8] &(1<<i%8)) && --Timer16[i]==0)
				Timer16Flg[i/8] |=(1<<i%8);
			sei();
		}
		for (i=0; i<Timer32TotNumber; i++){
    9a0c:	48 32       	cpi	r20, 0x28	; 40
    9a0e:	51 05       	cpc	r21, r1
    9a10:	09 f0       	breq	.+2      	; 0x9a14 <TimersInc+0x198>
    9a12:	c0 cf       	rjmp	.-128    	; 0x9994 <TimersInc+0x118>
			sei();
		}

		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		static uint8_t Timer10ms;
		if (++Timer10ms==100) {
    9a14:	80 91 eb 02 	lds	r24, 0x02EB
    9a18:	8f 5f       	subi	r24, 0xFF	; 255
    9a1a:	80 93 eb 02 	sts	0x02EB, r24
    9a1e:	84 36       	cpi	r24, 0x64	; 100
    9a20:	59 f0       	breq	.+22     	; 0x9a38 <TimersInc+0x1bc>
	uint8_t i, TickCounterVar;	
	cli();
	TickCounterVar = TickCounter;
	TickCounter = 0;
	sei();
	for(uint8_t j=0;j<TickCounterVar;j++){
    9a22:	f3 94       	inc	r15
    9a24:	fe 14       	cp	r15, r14
    9a26:	08 f4       	brcc	.+2      	; 0x9a2a <TimersInc+0x1ae>
    9a28:	3b cf       	rjmp	.-394    	; 0x98a0 <TimersInc+0x24>
 			ScanCount = 0;
			RT();
		}
		#endif
	}
}
    9a2a:	df 91       	pop	r29
    9a2c:	cf 91       	pop	r28
    9a2e:	1f 91       	pop	r17
    9a30:	0f 91       	pop	r16
    9a32:	ff 90       	pop	r15
    9a34:	ef 90       	pop	r14
    9a36:	08 95       	ret
		}

		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		static uint8_t Timer10ms;
		if (++Timer10ms==100) {
			Timer10ms = 0;
    9a38:	10 92 eb 02 	sts	0x02EB, r1
			ScanPerSec = ScanCount;
    9a3c:	80 91 6e 07 	lds	r24, 0x076E
    9a40:	90 91 6f 07 	lds	r25, 0x076F
    9a44:	90 93 88 07 	sts	0x0788, r25
    9a48:	80 93 87 07 	sts	0x0787, r24
 			ScanCount = 0;
    9a4c:	10 92 6f 07 	sts	0x076F, r1
    9a50:	10 92 6e 07 	sts	0x076E, r1

// ~~~~~~~~~~~~~~~
inline static void
RT(void)
{
	if (++Timer1s==60) {
    9a54:	80 91 d2 08 	lds	r24, 0x08D2
    9a58:	8f 5f       	subi	r24, 0xFF	; 255
    9a5a:	80 93 d2 08 	sts	0x08D2, r24
    9a5e:	8c 33       	cpi	r24, 0x3C	; 60
    9a60:	01 f7       	brne	.-64     	; 0x9a22 <TimersInc+0x1a6>
		Timer1s = 0;
    9a62:	10 92 d2 08 	sts	0x08D2, r1
		if (++Timer1min==60) {
    9a66:	80 91 ae 06 	lds	r24, 0x06AE
    9a6a:	8f 5f       	subi	r24, 0xFF	; 255
    9a6c:	80 93 ae 06 	sts	0x06AE, r24
    9a70:	8c 33       	cpi	r24, 0x3C	; 60
    9a72:	b9 f6       	brne	.-82     	; 0x9a22 <TimersInc+0x1a6>
			Timer1min = 0;
    9a74:	10 92 ae 06 	sts	0x06AE, r1
			++Timer1hour;
    9a78:	80 91 23 0c 	lds	r24, 0x0C23
    9a7c:	90 91 24 0c 	lds	r25, 0x0C24
    9a80:	01 96       	adiw	r24, 0x01	; 1
    9a82:	90 93 24 0c 	sts	0x0C24, r25
    9a86:	80 93 23 0c 	sts	0x0C23, r24
			OnTimeSave();
    9a8a:	0e 94 2f 4c 	call	0x985e	; 0x985e <OnTimeSave>
    9a8e:	c9 cf       	rjmp	.-110    	; 0x9a22 <TimersInc+0x1a6>

00009a90 <ewbl>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ewbl(const void *src, void *dst, size_t n)
{
	//IntOff();
	eeprom_write_block(src, dst, n);
    9a90:	0e 94 ef 81 	call	0x103de	; 0x103de <__eewr_block_m2560>
	CRC_EEPROM_upd();
    9a94:	0e 94 c7 4b 	call	0x978e	; 0x978e <CRC_EEPROM_upd>
	//IntOn();
}
    9a98:	08 95       	ret

00009a9a <ewd>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ewd(uint32_t *addr, uint32_t val)
{
	//IntOff();
	eeprom_write_dword(addr, val);
    9a9a:	0e 94 07 82 	call	0x1040e	; 0x1040e <__eewr_dword_m2560>
	CRC_EEPROM_upd();
    9a9e:	0e 94 c7 4b 	call	0x978e	; 0x978e <CRC_EEPROM_upd>
	//IntOn();
}
    9aa2:	08 95       	ret

00009aa4 <erbl>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    9aa4:	0e 94 cb 81 	call	0x10396	; 0x10396 <__eerd_block_m2560>
	//IntOn();
}
    9aa8:	08 95       	ret

00009aaa <erd>:
// ~~~~~~~~~~~~~~~~~~~~~~
uint32_t
erd(const uint32_t *addr)
{
	//IntOff();
	uint32_t word = eeprom_read_dword(addr);
    9aaa:	0e 94 e3 81 	call	0x103c6	; 0x103c6 <__eerd_dword_m2560>
	//IntOn();
	return word;
}
    9aae:	08 95       	ret

00009ab0 <erw>:
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    9ab0:	0e 94 e9 81 	call	0x103d2	; 0x103d2 <__eerd_word_m2560>
	//IntOn();
	return word;
}
    9ab4:	08 95       	ret

00009ab6 <EE_InterBrokLine>:
	uint8_t WiAbsc, uint16_t (*TblAbsc)[WiAbsc], uint8_t Absc,
	uint8_t WiOrdi, uint16_t (*TblOrdi)[WiOrdi], uint8_t Ordi,
	uint8_t Len,
	int16_t x
)
{
    9ab6:	2f 92       	push	r2
    9ab8:	3f 92       	push	r3
    9aba:	4f 92       	push	r4
    9abc:	5f 92       	push	r5
    9abe:	6f 92       	push	r6
    9ac0:	7f 92       	push	r7
    9ac2:	8f 92       	push	r8
    9ac4:	9f 92       	push	r9
    9ac6:	af 92       	push	r10
    9ac8:	bf 92       	push	r11
    9aca:	cf 92       	push	r12
    9acc:	df 92       	push	r13
    9ace:	ef 92       	push	r14
    9ad0:	ff 92       	push	r15
    9ad2:	0f 93       	push	r16
    9ad4:	1f 93       	push	r17
    9ad6:	df 93       	push	r29
    9ad8:	cf 93       	push	r28
    9ada:	cd b7       	in	r28, 0x3d	; 61
    9adc:	de b7       	in	r29, 0x3e	; 62
    9ade:	2e 97       	sbiw	r28, 0x0e	; 14
    9ae0:	0f b6       	in	r0, 0x3f	; 63
    9ae2:	f8 94       	cli
    9ae4:	de bf       	out	0x3e, r29	; 62
    9ae6:	0f be       	out	0x3f, r0	; 63
    9ae8:	cd bf       	out	0x3d, r28	; 61
    9aea:	f8 2e       	mov	r15, r24
    9aec:	2b 01       	movw	r4, r22
    9aee:	2d 87       	std	Y+13, r18	; 0x0d
    9af0:	18 01       	movw	r2, r16
    9af2:	ee 86       	std	Y+14, r14	; 0x0e
    9af4:	0c 2d       	mov	r16, r12
	LineGraph Segm;
	uint8_t i = 0;
	Segm.x2 = (int16_t)erw(TblAbsc[0]+Absc);
    9af6:	c4 2e       	mov	r12, r20
    9af8:	dd 24       	eor	r13, r13
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    9afa:	c6 01       	movw	r24, r12
    9afc:	88 0f       	add	r24, r24
    9afe:	99 1f       	adc	r25, r25
    9b00:	86 0f       	add	r24, r22
    9b02:	97 1f       	adc	r25, r23
    9b04:	0e 94 e9 81 	call	0x103d2	; 0x103d2 <__eerd_word_m2560>
    9b08:	aa 27       	eor	r26, r26
    9b0a:	97 fd       	sbrc	r25, 7
    9b0c:	a0 95       	com	r26
    9b0e:	ba 2f       	mov	r27, r26
    9b10:	8d 83       	std	Y+5, r24	; 0x05
    9b12:	9e 83       	std	Y+6, r25	; 0x06
    9b14:	af 83       	std	Y+7, r26	; 0x07
    9b16:	b8 87       	std	Y+8, r27	; 0x08
    9b18:	ef 2c       	mov	r14, r15
    9b1a:	ff 24       	eor	r15, r15
    9b1c:	35 01       	movw	r6, r10
    9b1e:	88 24       	eor	r8, r8
    9b20:	77 fc       	sbrc	r7, 7
    9b22:	80 94       	com	r8
    9b24:	98 2c       	mov	r9, r8
    9b26:	10 e0       	ldi	r17, 0x00	; 0
    9b28:	9c 01       	movw	r18, r24
    9b2a:	ad 01       	movw	r20, r26
	do {
		Segm.x1 = Segm.x2;
    9b2c:	29 83       	std	Y+1, r18	; 0x01
    9b2e:	3a 83       	std	Y+2, r19	; 0x02
    9b30:	4b 83       	std	Y+3, r20	; 0x03
    9b32:	5c 83       	std	Y+4, r21	; 0x04
		Segm.x2 = (int16_t)erw(TblAbsc[++i]+Absc);
    9b34:	1f 5f       	subi	r17, 0xFF	; 255
    9b36:	a1 2e       	mov	r10, r17
    9b38:	bb 24       	eor	r11, r11
    9b3a:	ae 9c       	mul	r10, r14
    9b3c:	c0 01       	movw	r24, r0
    9b3e:	af 9c       	mul	r10, r15
    9b40:	90 0d       	add	r25, r0
    9b42:	be 9c       	mul	r11, r14
    9b44:	90 0d       	add	r25, r0
    9b46:	11 24       	eor	r1, r1
    9b48:	8c 0d       	add	r24, r12
    9b4a:	9d 1d       	adc	r25, r13
    9b4c:	88 0f       	add	r24, r24
    9b4e:	99 1f       	adc	r25, r25
    9b50:	84 0d       	add	r24, r4
    9b52:	95 1d       	adc	r25, r5
    9b54:	0e 94 e9 81 	call	0x103d2	; 0x103d2 <__eerd_word_m2560>
    9b58:	9c 01       	movw	r18, r24
    9b5a:	44 27       	eor	r20, r20
    9b5c:	37 fd       	sbrc	r19, 7
    9b5e:	40 95       	com	r20
    9b60:	54 2f       	mov	r21, r20
    9b62:	2d 83       	std	Y+5, r18	; 0x05
    9b64:	3e 83       	std	Y+6, r19	; 0x06
    9b66:	4f 83       	std	Y+7, r20	; 0x07
    9b68:	58 87       	std	Y+8, r21	; 0x08
	} while(x>Segm.x2 && i<Len);
    9b6a:	26 15       	cp	r18, r6
    9b6c:	37 05       	cpc	r19, r7
    9b6e:	48 05       	cpc	r20, r8
    9b70:	59 05       	cpc	r21, r9
    9b72:	14 f4       	brge	.+4      	; 0x9b78 <EE_InterBrokLine+0xc2>
    9b74:	10 17       	cp	r17, r16
    9b76:	d0 f2       	brcs	.-76     	; 0x9b2c <EE_InterBrokLine+0x76>
	Segm.y1 = (int16_t)erw(TblOrdi[i-1]+Ordi);
    9b78:	8d 85       	ldd	r24, Y+13	; 0x0d
    9b7a:	08 2f       	mov	r16, r24
    9b7c:	10 e0       	ldi	r17, 0x00	; 0
    9b7e:	8e 85       	ldd	r24, Y+14	; 0x0e
    9b80:	e8 2e       	mov	r14, r24
    9b82:	ff 24       	eor	r15, r15
    9b84:	08 94       	sec
    9b86:	a1 08       	sbc	r10, r1
    9b88:	b1 08       	sbc	r11, r1
    9b8a:	a0 9e       	mul	r10, r16
    9b8c:	c0 01       	movw	r24, r0
    9b8e:	a1 9e       	mul	r10, r17
    9b90:	90 0d       	add	r25, r0
    9b92:	b0 9e       	mul	r11, r16
    9b94:	90 0d       	add	r25, r0
    9b96:	11 24       	eor	r1, r1
    9b98:	08 94       	sec
    9b9a:	a1 1c       	adc	r10, r1
    9b9c:	b1 1c       	adc	r11, r1
    9b9e:	8e 0d       	add	r24, r14
    9ba0:	9f 1d       	adc	r25, r15
    9ba2:	88 0f       	add	r24, r24
    9ba4:	99 1f       	adc	r25, r25
    9ba6:	82 0d       	add	r24, r2
    9ba8:	93 1d       	adc	r25, r3
    9baa:	0e 94 e9 81 	call	0x103d2	; 0x103d2 <__eerd_word_m2560>
    9bae:	9a 87       	std	Y+10, r25	; 0x0a
    9bb0:	89 87       	std	Y+9, r24	; 0x09
    9bb2:	a0 9e       	mul	r10, r16
    9bb4:	c0 01       	movw	r24, r0
    9bb6:	a1 9e       	mul	r10, r17
    9bb8:	90 0d       	add	r25, r0
    9bba:	b0 9e       	mul	r11, r16
    9bbc:	90 0d       	add	r25, r0
    9bbe:	11 24       	eor	r1, r1
    9bc0:	8e 0d       	add	r24, r14
    9bc2:	9f 1d       	adc	r25, r15
    9bc4:	88 0f       	add	r24, r24
    9bc6:	99 1f       	adc	r25, r25
    9bc8:	82 0d       	add	r24, r2
    9bca:	93 1d       	adc	r25, r3
    9bcc:	0e 94 e9 81 	call	0x103d2	; 0x103d2 <__eerd_word_m2560>
	Segm.y2 = (int16_t)erw(TblOrdi[i]+Ordi);
    9bd0:	9c 87       	std	Y+12, r25	; 0x0c
    9bd2:	8b 87       	std	Y+11, r24	; 0x0b
	return LineFunc(&Segm, x);
    9bd4:	ce 01       	movw	r24, r28
    9bd6:	01 96       	adiw	r24, 0x01	; 1
    9bd8:	b4 01       	movw	r22, r8
    9bda:	a3 01       	movw	r20, r6
    9bdc:	0e 94 f5 20 	call	0x41ea	; 0x41ea <LineFunc>
}
    9be0:	2e 96       	adiw	r28, 0x0e	; 14
    9be2:	0f b6       	in	r0, 0x3f	; 63
    9be4:	f8 94       	cli
    9be6:	de bf       	out	0x3e, r29	; 62
    9be8:	0f be       	out	0x3f, r0	; 63
    9bea:	cd bf       	out	0x3d, r28	; 61
    9bec:	cf 91       	pop	r28
    9bee:	df 91       	pop	r29
    9bf0:	1f 91       	pop	r17
    9bf2:	0f 91       	pop	r16
    9bf4:	ff 90       	pop	r15
    9bf6:	ef 90       	pop	r14
    9bf8:	df 90       	pop	r13
    9bfa:	cf 90       	pop	r12
    9bfc:	bf 90       	pop	r11
    9bfe:	af 90       	pop	r10
    9c00:	9f 90       	pop	r9
    9c02:	8f 90       	pop	r8
    9c04:	7f 90       	pop	r7
    9c06:	6f 90       	pop	r6
    9c08:	5f 90       	pop	r5
    9c0a:	4f 90       	pop	r4
    9c0c:	3f 90       	pop	r3
    9c0e:	2f 90       	pop	r2
    9c10:	08 95       	ret

00009c12 <MemCheck>:
}

// ~~~~~~~~~~~
uint8_t
MemCheck(void)
{
    9c12:	0f 93       	push	r16
    9c14:	1f 93       	push	r17
//	uint8_t T = Timer32Stopp(TD_Mem);
//	if (T) {
//		StartTimer32(TD_Mem, 360000);
		if (!(MemFail &(1<<MemFail_Flash)) && CRC_Flash_calc()!=erw(&MemCheck_stor.CRC_Flash_stor))
    9c16:	80 91 cf 08 	lds	r24, 0x08CF
    9c1a:	80 ff       	sbrs	r24, 0
    9c1c:	17 c0       	rjmp	.+46     	; 0x9c4c <MemCheck+0x3a>
			MemFail |=(1<<MemFail_Flash);
		if (!(MemFail &(1<<MemFail_EEPROM)) && CRC_EEPROM_calc()!=erw(&MemCheck_stor.CRC_EEPROM_stor))
    9c1e:	81 ff       	sbrs	r24, 1
    9c20:	03 c0       	rjmp	.+6      	; 0x9c28 <MemCheck+0x16>
			MemFail |=(1<<MemFail_EEPROM);
//	}
//	return T && MemFail;
	return MemFail;
}
    9c22:	1f 91       	pop	r17
    9c24:	0f 91       	pop	r16
    9c26:	08 95       	ret
//	uint8_t T = Timer32Stopp(TD_Mem);
//	if (T) {
//		StartTimer32(TD_Mem, 360000);
		if (!(MemFail &(1<<MemFail_Flash)) && CRC_Flash_calc()!=erw(&MemCheck_stor.CRC_Flash_stor))
			MemFail |=(1<<MemFail_Flash);
		if (!(MemFail &(1<<MemFail_EEPROM)) && CRC_EEPROM_calc()!=erw(&MemCheck_stor.CRC_EEPROM_stor))
    9c28:	0e 94 a5 19 	call	0x334a	; 0x334a <CRC_EEPROM_calc>
    9c2c:	8c 01       	movw	r16, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    9c2e:	8a e3       	ldi	r24, 0x3A	; 58
    9c30:	91 e0       	ldi	r25, 0x01	; 1
    9c32:	0e 94 e9 81 	call	0x103d2	; 0x103d2 <__eerd_word_m2560>
//	uint8_t T = Timer32Stopp(TD_Mem);
//	if (T) {
//		StartTimer32(TD_Mem, 360000);
		if (!(MemFail &(1<<MemFail_Flash)) && CRC_Flash_calc()!=erw(&MemCheck_stor.CRC_Flash_stor))
			MemFail |=(1<<MemFail_Flash);
		if (!(MemFail &(1<<MemFail_EEPROM)) && CRC_EEPROM_calc()!=erw(&MemCheck_stor.CRC_EEPROM_stor))
    9c36:	08 17       	cp	r16, r24
    9c38:	19 07       	cpc	r17, r25
    9c3a:	d9 f0       	breq	.+54     	; 0x9c72 <MemCheck+0x60>
			MemFail |=(1<<MemFail_EEPROM);
    9c3c:	80 91 cf 08 	lds	r24, 0x08CF
    9c40:	82 60       	ori	r24, 0x02	; 2
    9c42:	80 93 cf 08 	sts	0x08CF, r24
//	}
//	return T && MemFail;
	return MemFail;
}
    9c46:	1f 91       	pop	r17
    9c48:	0f 91       	pop	r16
    9c4a:	08 95       	ret
MemCheck(void)
{
//	uint8_t T = Timer32Stopp(TD_Mem);
//	if (T) {
//		StartTimer32(TD_Mem, 360000);
		if (!(MemFail &(1<<MemFail_Flash)) && CRC_Flash_calc()!=erw(&MemCheck_stor.CRC_Flash_stor))
    9c4c:	0e 94 8b 19 	call	0x3316	; 0x3316 <CRC_Flash_calc>
    9c50:	8c 01       	movw	r16, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    9c52:	88 e3       	ldi	r24, 0x38	; 56
    9c54:	91 e0       	ldi	r25, 0x01	; 1
    9c56:	0e 94 e9 81 	call	0x103d2	; 0x103d2 <__eerd_word_m2560>
MemCheck(void)
{
//	uint8_t T = Timer32Stopp(TD_Mem);
//	if (T) {
//		StartTimer32(TD_Mem, 360000);
		if (!(MemFail &(1<<MemFail_Flash)) && CRC_Flash_calc()!=erw(&MemCheck_stor.CRC_Flash_stor))
    9c5a:	08 17       	cp	r16, r24
    9c5c:	19 07       	cpc	r17, r25
    9c5e:	31 f0       	breq	.+12     	; 0x9c6c <MemCheck+0x5a>
			MemFail |=(1<<MemFail_Flash);
    9c60:	80 91 cf 08 	lds	r24, 0x08CF
    9c64:	81 60       	ori	r24, 0x01	; 1
    9c66:	80 93 cf 08 	sts	0x08CF, r24
    9c6a:	d9 cf       	rjmp	.-78     	; 0x9c1e <MemCheck+0xc>
    9c6c:	80 91 cf 08 	lds	r24, 0x08CF
    9c70:	d6 cf       	rjmp	.-84     	; 0x9c1e <MemCheck+0xc>
    9c72:	80 91 cf 08 	lds	r24, 0x08CF
    9c76:	d5 cf       	rjmp	.-86     	; 0x9c22 <MemCheck+0x10>

00009c78 <MemCheckMsg>:

// ~~~~~~~~~~~~~~
void
MemCheckMsg(void)
{
	if(MemCheck())
    9c78:	0e 94 09 4e 	call	0x9c12	; 0x9c12 <MemCheck>
    9c7c:	88 23       	and	r24, r24
    9c7e:	09 f4       	brne	.+2      	; 0x9c82 <MemCheckMsg+0xa>
    9c80:	08 95       	ret

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    9c82:	80 91 cf 08 	lds	r24, 0x08CF
    9c86:	e8 2f       	mov	r30, r24
    9c88:	f0 e0       	ldi	r31, 0x00	; 0
    9c8a:	ee 0f       	add	r30, r30
    9c8c:	ff 1f       	adc	r31, r31
    9c8e:	e9 5a       	subi	r30, 0xA9	; 169
    9c90:	f8 4e       	sbci	r31, 0xE8	; 232
		ShowMsg(prp(MsgErrMemo+MemFail));
    9c92:	85 91       	lpm	r24, Z+
    9c94:	94 91       	lpm	r25, Z+
    9c96:	0e 94 9c 3c 	call	0x7938	; 0x7938 <ShowMsg>
    9c9a:	08 95       	ret

00009c9c <erb>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    9c9c:	0e 94 db 81 	call	0x103b6	; 0x103b6 <__eerd_byte_m2560>
	//IntOn();
	return byte;
}
    9ca0:	08 95       	ret

00009ca2 <ThermChanWrong>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
ThermChanWrong(uint8_t ChanN)
{
    9ca2:	ff 92       	push	r15
    9ca4:	0f 93       	push	r16
    9ca6:	1f 93       	push	r17
	return ThermWrong(prb(ThermFami+ChanN), erb(ThermType+ChanN), Temperature[ChanN]);
    9ca8:	08 2f       	mov	r16, r24
    9caa:	10 e0       	ldi	r17, 0x00	; 0

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    9cac:	f8 01       	movw	r30, r16
    9cae:	e3 54       	subi	r30, 0x43	; 67
    9cb0:	f9 4f       	sbci	r31, 0xF9	; 249
    9cb2:	f4 90       	lpm	r15, Z+
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    9cb4:	c8 01       	movw	r24, r16
    9cb6:	89 5e       	subi	r24, 0xE9	; 233
    9cb8:	9e 4f       	sbci	r25, 0xFE	; 254
    9cba:	0e 94 db 81 	call	0x103b6	; 0x103b6 <__eerd_byte_m2560>
    9cbe:	68 2f       	mov	r22, r24
    9cc0:	00 0f       	add	r16, r16
    9cc2:	11 1f       	adc	r17, r17
    9cc4:	0d 5b       	subi	r16, 0xBD	; 189
    9cc6:	19 4f       	sbci	r17, 0xF9	; 249
    9cc8:	f8 01       	movw	r30, r16
    9cca:	40 81       	ld	r20, Z
    9ccc:	51 81       	ldd	r21, Z+1	; 0x01
    9cce:	8f 2d       	mov	r24, r15
    9cd0:	0e 94 bc 3f 	call	0x7f78	; 0x7f78 <ThermWrong>
}
    9cd4:	1f 91       	pop	r17
    9cd6:	0f 91       	pop	r16
    9cd8:	ff 90       	pop	r15
    9cda:	08 95       	ret

00009cdc <ThermChan>:
}

// ~~~~~~~~~~~~~~~~~~~~~
void
ThermChan(uint8_t ChanN)
{
    9cdc:	8f 92       	push	r8
    9cde:	9f 92       	push	r9
    9ce0:	af 92       	push	r10
    9ce2:	bf 92       	push	r11
    9ce4:	cf 92       	push	r12
    9ce6:	df 92       	push	r13
    9ce8:	ef 92       	push	r14
    9cea:	ff 92       	push	r15
    9cec:	0f 93       	push	r16
    9cee:	1f 93       	push	r17
    9cf0:	cf 93       	push	r28
    9cf2:	df 93       	push	r29
	if (ChanN>=TerReg)
    9cf4:	86 30       	cpi	r24, 0x06	; 6
    9cf6:	08 f0       	brcs	.+2      	; 0x9cfa <ThermChan+0x1e>
    9cf8:	4c c0       	rjmp	.+152    	; 0x9d92 <ThermChan+0xb6>
		return;
    9cfa:	e8 2e       	mov	r14, r24
    9cfc:	ff 24       	eor	r15, r15
    9cfe:	d7 01       	movw	r26, r14
    9d00:	aa 0f       	add	r26, r26
    9d02:	bb 1f       	adc	r27, r27
    9d04:	a2 95       	swap	r26
    9d06:	b2 95       	swap	r27
    9d08:	b0 7f       	andi	r27, 0xF0	; 240
    9d0a:	ba 27       	eor	r27, r26
    9d0c:	a0 7f       	andi	r26, 0xF0	; 240
    9d0e:	ba 27       	eor	r27, r26
    9d10:	fd 01       	movw	r30, r26
    9d12:	e5 5e       	subi	r30, 0xE5	; 229
    9d14:	fa 4f       	sbci	r31, 0xFA	; 250
    9d16:	2f e0       	ldi	r18, 0x0F	; 15
	for (uint8_t i=TerFiltLev*4-1; i; i--)
		TerBuf[ChanN][i] = TerBuf[ChanN][i-1];
    9d18:	80 81       	ld	r24, Z
    9d1a:	91 81       	ldd	r25, Z+1	; 0x01
    9d1c:	93 83       	std	Z+3, r25	; 0x03
    9d1e:	82 83       	std	Z+2, r24	; 0x02
void
ThermChan(uint8_t ChanN)
{
	if (ChanN>=TerReg)
		return;
	for (uint8_t i=TerFiltLev*4-1; i; i--)
    9d20:	21 50       	subi	r18, 0x01	; 1
    9d22:	32 97       	sbiw	r30, 0x02	; 2
    9d24:	22 23       	and	r18, r18
    9d26:	c1 f7       	brne	.-16     	; 0x9d18 <ThermChan+0x3c>
		TerBuf[ChanN][i] = TerBuf[ChanN][i-1];
	TerBuf[ChanN][0] = TerInput[ChanN];
    9d28:	a1 50       	subi	r26, 0x01	; 1
    9d2a:	bb 4f       	sbci	r27, 0xFB	; 251
    9d2c:	47 01       	movw	r8, r14
    9d2e:	88 0c       	add	r8, r8
    9d30:	99 1c       	adc	r9, r9
    9d32:	f4 01       	movw	r30, r8
    9d34:	ed 52       	subi	r30, 0x2D	; 45
    9d36:	f7 4f       	sbci	r31, 0xF7	; 247
    9d38:	80 81       	ld	r24, Z
    9d3a:	91 81       	ldd	r25, Z+1	; 0x01
    9d3c:	8d 93       	st	X+, r24
    9d3e:	9c 93       	st	X, r25

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    9d40:	f7 01       	movw	r30, r14
    9d42:	e3 54       	subi	r30, 0x43	; 67
    9d44:	f9 4f       	sbci	r31, 0xF9	; 249
    9d46:	c4 90       	lpm	r12, Z+
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    9d48:	c7 01       	movw	r24, r14
    9d4a:	89 5e       	subi	r24, 0xE9	; 233
    9d4c:	9e 4f       	sbci	r25, 0xFE	; 254
    9d4e:	0e 94 db 81 	call	0x103b6	; 0x103b6 <__eerd_byte_m2560>
    9d52:	18 2f       	mov	r17, r24
	int16_t Ter = Thermode(prb(ThermFami+ChanN), erb(ThermType+ChanN), DigiFilt(TerBuf[ChanN],TerFiltLev));
    9d54:	c7 01       	movw	r24, r14
    9d56:	88 0f       	add	r24, r24
    9d58:	99 1f       	adc	r25, r25
    9d5a:	82 95       	swap	r24
    9d5c:	92 95       	swap	r25
    9d5e:	90 7f       	andi	r25, 0xF0	; 240
    9d60:	98 27       	eor	r25, r24
    9d62:	80 7f       	andi	r24, 0xF0	; 240
    9d64:	98 27       	eor	r25, r24
    9d66:	81 50       	subi	r24, 0x01	; 1
    9d68:	9b 4f       	sbci	r25, 0xFB	; 251
    9d6a:	64 e0       	ldi	r22, 0x04	; 4
    9d6c:	0e 94 fa 4a 	call	0x95f4	; 0x95f4 <DigiFilt>
    9d70:	ac 01       	movw	r20, r24
    9d72:	8c 2d       	mov	r24, r12
    9d74:	61 2f       	mov	r22, r17
    9d76:	0e 94 3c 3f 	call	0x7e78	; 0x7e78 <Thermode>
    9d7a:	ec 01       	movw	r28, r24
	if (Ter!=Therm_Off_Mark)
    9d7c:	80 e8       	ldi	r24, 0x80	; 128
    9d7e:	c0 30       	cpi	r28, 0x00	; 0
    9d80:	d8 07       	cpc	r29, r24
    9d82:	a1 f4       	brne	.+40     	; 0x9dac <ThermChan+0xd0>
		Ter = (Ter+(int8_t)erb(&ThermCorr[ChanN].D))*(erw(&ThermCorr[ChanN].A)/1000.0);
	Temperature[ChanN] = Ter;
    9d84:	e3 e4       	ldi	r30, 0x43	; 67
    9d86:	f6 e0       	ldi	r31, 0x06	; 6
    9d88:	8e 0e       	add	r8, r30
    9d8a:	9f 1e       	adc	r9, r31
    9d8c:	f4 01       	movw	r30, r8
    9d8e:	d1 83       	std	Z+1, r29	; 0x01
    9d90:	c0 83       	st	Z, r28
}
    9d92:	df 91       	pop	r29
    9d94:	cf 91       	pop	r28
    9d96:	1f 91       	pop	r17
    9d98:	0f 91       	pop	r16
    9d9a:	ff 90       	pop	r15
    9d9c:	ef 90       	pop	r14
    9d9e:	df 90       	pop	r13
    9da0:	cf 90       	pop	r12
    9da2:	bf 90       	pop	r11
    9da4:	af 90       	pop	r10
    9da6:	9f 90       	pop	r9
    9da8:	8f 90       	pop	r8
    9daa:	08 95       	ret
    9dac:	64 01       	movw	r12, r8
    9dae:	ce 0c       	add	r12, r14
    9db0:	df 1c       	adc	r13, r15
    9db2:	c6 01       	movw	r24, r12
    9db4:	83 5e       	subi	r24, 0xE3	; 227
    9db6:	9e 4f       	sbci	r25, 0xFE	; 254
    9db8:	0e 94 db 81 	call	0x103b6	; 0x103b6 <__eerd_byte_m2560>
    9dbc:	e8 2e       	mov	r14, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    9dbe:	c6 01       	movw	r24, r12
    9dc0:	82 5e       	subi	r24, 0xE2	; 226
    9dc2:	9e 4f       	sbci	r25, 0xFE	; 254
    9dc4:	0e 94 e9 81 	call	0x103d2	; 0x103d2 <__eerd_word_m2560>
    9dc8:	5c 01       	movw	r10, r24
	for (uint8_t i=TerFiltLev*4-1; i; i--)
		TerBuf[ChanN][i] = TerBuf[ChanN][i-1];
	TerBuf[ChanN][0] = TerInput[ChanN];
	int16_t Ter = Thermode(prb(ThermFami+ChanN), erb(ThermType+ChanN), DigiFilt(TerBuf[ChanN],TerFiltLev));
	if (Ter!=Therm_Off_Mark)
		Ter = (Ter+(int8_t)erb(&ThermCorr[ChanN].D))*(erw(&ThermCorr[ChanN].A)/1000.0);
    9dca:	ff 24       	eor	r15, r15
    9dcc:	e7 fc       	sbrc	r14, 7
    9dce:	f0 94       	com	r15
    9dd0:	ec 0e       	add	r14, r28
    9dd2:	fd 1e       	adc	r15, r29
    9dd4:	00 27       	eor	r16, r16
    9dd6:	f7 fc       	sbrc	r15, 7
    9dd8:	00 95       	com	r16
    9dda:	10 2f       	mov	r17, r16
    9ddc:	c8 01       	movw	r24, r16
    9dde:	b7 01       	movw	r22, r14
    9de0:	0e 94 cc 7c 	call	0xf998	; 0xf998 <__floatsisf>
    9de4:	7b 01       	movw	r14, r22
    9de6:	8c 01       	movw	r16, r24
    9de8:	cc 24       	eor	r12, r12
    9dea:	dd 24       	eor	r13, r13
    9dec:	c6 01       	movw	r24, r12
    9dee:	b5 01       	movw	r22, r10
    9df0:	0e 94 ca 7c 	call	0xf994	; 0xf994 <__floatunsisf>
    9df4:	20 e0       	ldi	r18, 0x00	; 0
    9df6:	30 e0       	ldi	r19, 0x00	; 0
    9df8:	4a e7       	ldi	r20, 0x7A	; 122
    9dfa:	54 e4       	ldi	r21, 0x44	; 68
    9dfc:	0e 94 32 81 	call	0x10264	; 0x10264 <__divsf3>
    9e00:	9b 01       	movw	r18, r22
    9e02:	ac 01       	movw	r20, r24
    9e04:	c8 01       	movw	r24, r16
    9e06:	b7 01       	movw	r22, r14
    9e08:	0e 94 07 7d 	call	0xfa0e	; 0xfa0e <__mulsf3>
    9e0c:	0e 94 9a 81 	call	0x10334	; 0x10334 <__fixsfsi>
    9e10:	eb 01       	movw	r28, r22
    9e12:	b8 cf       	rjmp	.-144    	; 0x9d84 <ThermChan+0xa8>

00009e14 <ThermInit>:
}

// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
ThermInit(uint8_t ChanN)
{
    9e14:	ef 92       	push	r14
    9e16:	ff 92       	push	r15
    9e18:	0f 93       	push	r16
    9e1a:	1f 93       	push	r17
    9e1c:	cf 93       	push	r28
    9e1e:	df 93       	push	r29
    9e20:	f8 2e       	mov	r15, r24
	if (ChanN<TerReg) {
    9e22:	85 e0       	ldi	r24, 0x05	; 5
    9e24:	8f 15       	cp	r24, r15
    9e26:	68 f1       	brcs	.+90     	; 0x9e82 <ThermInit+0x6e>
    9e28:	8f 2d       	mov	r24, r15
    9e2a:	90 e0       	ldi	r25, 0x00	; 0
    9e2c:	8c 01       	movw	r16, r24
    9e2e:	00 0f       	add	r16, r16
    9e30:	11 1f       	adc	r17, r17
    9e32:	f8 01       	movw	r30, r16
    9e34:	ed 52       	subi	r30, 0x2D	; 45
    9e36:	f7 4f       	sbci	r31, 0xF7	; 247
    9e38:	c0 81       	ld	r28, Z
    9e3a:	d1 81       	ldd	r29, Z+1	; 0x01
    9e3c:	fc 01       	movw	r30, r24
    9e3e:	ee 0f       	add	r30, r30
    9e40:	ff 1f       	adc	r31, r31
    9e42:	e2 95       	swap	r30
    9e44:	f2 95       	swap	r31
    9e46:	f0 7f       	andi	r31, 0xF0	; 240
    9e48:	fe 27       	eor	r31, r30
    9e4a:	e0 7f       	andi	r30, 0xF0	; 240
    9e4c:	fe 27       	eor	r31, r30
    9e4e:	e1 50       	subi	r30, 0x01	; 1
    9e50:	fb 4f       	sbci	r31, 0xFB	; 251
    9e52:	20 e0       	ldi	r18, 0x00	; 0
		for (uint8_t i=0; i<TerFiltLev*4; TerBuf[ChanN][i++]=TerInput[ChanN]);
    9e54:	c1 93       	st	Z+, r28
    9e56:	d1 93       	st	Z+, r29
    9e58:	2f 5f       	subi	r18, 0xFF	; 255
    9e5a:	20 31       	cpi	r18, 0x10	; 16
    9e5c:	d9 f7       	brne	.-10     	; 0x9e54 <ThermInit+0x40>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    9e5e:	fc 01       	movw	r30, r24
    9e60:	e3 54       	subi	r30, 0x43	; 67
    9e62:	f9 4f       	sbci	r31, 0xF9	; 249
    9e64:	e4 90       	lpm	r14, Z+
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    9e66:	89 5e       	subi	r24, 0xE9	; 233
    9e68:	9e 4f       	sbci	r25, 0xFE	; 254
    9e6a:	0e 94 db 81 	call	0x103b6	; 0x103b6 <__eerd_byte_m2560>
    9e6e:	68 2f       	mov	r22, r24
		Temperature[ChanN] = Thermode(prb(ThermFami+ChanN), erb(ThermType+ChanN), TerInput[ChanN]);
    9e70:	8e 2d       	mov	r24, r14
    9e72:	ae 01       	movw	r20, r28
    9e74:	0e 94 3c 3f 	call	0x7e78	; 0x7e78 <Thermode>
    9e78:	0d 5b       	subi	r16, 0xBD	; 189
    9e7a:	19 4f       	sbci	r17, 0xF9	; 249
    9e7c:	f8 01       	movw	r30, r16
    9e7e:	91 83       	std	Z+1, r25	; 0x01
    9e80:	80 83       	st	Z, r24
    9e82:	80 e0       	ldi	r24, 0x00	; 0
    9e84:	f5 e0       	ldi	r31, 0x05	; 5
    9e86:	ff 12       	cpse	r15, r31
    9e88:	81 e0       	ldi	r24, 0x01	; 1
	}
	return ChanN!=TerReg-1;
}
    9e8a:	df 91       	pop	r29
    9e8c:	cf 91       	pop	r28
    9e8e:	1f 91       	pop	r17
    9e90:	0f 91       	pop	r16
    9e92:	ff 90       	pop	r15
    9e94:	ef 90       	pop	r14
    9e96:	08 95       	ret

00009e98 <DigitIn>:
}

// ~~~~~~~~~~
void
DigitIn(void)
{
    9e98:	cf 93       	push	r28
    9e9a:	df 93       	push	r29
	memcpy(DigInput.StateOld, DigInput.State, DI_Reg+DI_Reg_Ext);
    9e9c:	ef ef       	ldi	r30, 0xFF	; 255
    9e9e:	f6 e0       	ldi	r31, 0x06	; 6
    9ea0:	df 01       	movw	r26, r30
    9ea2:	13 97       	sbiw	r26, 0x03	; 3
    9ea4:	83 e0       	ldi	r24, 0x03	; 3
    9ea6:	0d 90       	ld	r0, X+
    9ea8:	01 92       	st	Z+, r0
    9eaa:	81 50       	subi	r24, 0x01	; 1
    9eac:	e1 f7       	brne	.-8      	; 0x9ea6 <DigitIn+0xe>
    9eae:	84 e1       	ldi	r24, 0x14	; 20
    9eb0:	91 e0       	ldi	r25, 0x01	; 1
    9eb2:	0e 94 db 81 	call	0x103b6	; 0x103b6 <__eerd_byte_m2560>
	for (uint8_t i=0; i<DI_Reg; i++)
		DigInput.Status[i] = DigInput.State[i]^erb(DI_Invers+i);
    9eb6:	90 91 fc 06 	lds	r25, 0x06FC
    9eba:	98 27       	eor	r25, r24
    9ebc:	90 93 02 07 	sts	0x0702, r25
    9ec0:	85 e1       	ldi	r24, 0x15	; 21
    9ec2:	91 e0       	ldi	r25, 0x01	; 1
    9ec4:	0e 94 db 81 	call	0x103b6	; 0x103b6 <__eerd_byte_m2560>
    9ec8:	90 91 fd 06 	lds	r25, 0x06FD
    9ecc:	98 27       	eor	r25, r24
    9ece:	90 93 03 07 	sts	0x0703, r25
    9ed2:	86 e1       	ldi	r24, 0x16	; 22
    9ed4:	91 e0       	ldi	r25, 0x01	; 1
    9ed6:	0e 94 db 81 	call	0x103b6	; 0x103b6 <__eerd_byte_m2560>
    9eda:	90 91 fe 06 	lds	r25, 0x06FE
    9ede:	98 27       	eor	r25, r24
    9ee0:	90 93 04 07 	sts	0x0704, r25
    9ee4:	40 e0       	ldi	r20, 0x00	; 0
    9ee6:	50 e0       	ldi	r21, 0x00	; 0
#else
	static void
	DigitIn_Hard(void)
	{
		for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
			uint8_t Byte=D_N/8, Bit=1<<D_N%8;
    9ee8:	a1 e0       	ldi	r26, 0x01	; 1
    9eea:	b0 e0       	ldi	r27, 0x00	; 0
    9eec:	1b c0       	rjmp	.+54     	; 0x9f24 <DigitIn+0x8c>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    9eee:	c9 01       	movw	r24, r18
    9ef0:	89 5b       	subi	r24, 0xB9	; 185
    9ef2:	94 4d       	sbci	r25, 0xD4	; 212
    9ef4:	fc 01       	movw	r30, r24
    9ef6:	c5 91       	lpm	r28, Z+
    9ef8:	d4 91       	lpm	r29, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    9efa:	27 5b       	subi	r18, 0xB7	; 183
    9efc:	34 4d       	sbci	r19, 0xD4	; 212
    9efe:	f9 01       	movw	r30, r18
    9f00:	84 91       	lpm	r24, Z+
			if(prb(&DI_M[D_N].Inversion)){
				if (*(uint8_t*)prp(&DI_M[D_N].PIN) & prb(&DI_M[D_N].P))
    9f02:	98 81       	ld	r25, Y
    9f04:	89 23       	and	r24, r25
    9f06:	09 f4       	brne	.+2      	; 0x9f0a <DigitIn+0x72>
    9f08:	3d c0       	rjmp	.+122    	; 0x9f84 <DigitIn+0xec>
			}
			else{
				if (*(uint8_t*)prp(&DI_M[D_N].PIN) & prb(&DI_M[D_N].P))
					DigInput.State[Byte] &=~Bit;
				else
					DigInput.State[Byte]  |=Bit;
    9f0a:	e7 2f       	mov	r30, r23
    9f0c:	f0 e0       	ldi	r31, 0x00	; 0
    9f0e:	e4 50       	subi	r30, 0x04	; 4
    9f10:	f9 4f       	sbci	r31, 0xF9	; 249
    9f12:	80 81       	ld	r24, Z
    9f14:	86 2b       	or	r24, r22
    9f16:	80 83       	st	Z, r24
    9f18:	4f 5f       	subi	r20, 0xFF	; 255
    9f1a:	5f 4f       	sbci	r21, 0xFF	; 255
	void DigitIn_Hard(void);
#else
	static void
	DigitIn_Hard(void)
	{
		for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
    9f1c:	42 31       	cpi	r20, 0x12	; 18
    9f1e:	51 05       	cpc	r21, r1
    9f20:	09 f4       	brne	.+2      	; 0x9f24 <DigitIn+0x8c>
    9f22:	3e c0       	rjmp	.+124    	; 0x9fa0 <DigitIn+0x108>
			uint8_t Byte=D_N/8, Bit=1<<D_N%8;
    9f24:	74 2f       	mov	r23, r20
    9f26:	76 95       	lsr	r23
    9f28:	76 95       	lsr	r23
    9f2a:	76 95       	lsr	r23
    9f2c:	ca 01       	movw	r24, r20
    9f2e:	87 70       	andi	r24, 0x07	; 7
    9f30:	90 70       	andi	r25, 0x00	; 0
    9f32:	9d 01       	movw	r18, r26
    9f34:	02 c0       	rjmp	.+4      	; 0x9f3a <DigitIn+0xa2>
    9f36:	22 0f       	add	r18, r18
    9f38:	33 1f       	adc	r19, r19
    9f3a:	8a 95       	dec	r24
    9f3c:	e2 f7       	brpl	.-8      	; 0x9f36 <DigitIn+0x9e>
    9f3e:	62 2f       	mov	r22, r18
    9f40:	9a 01       	movw	r18, r20
    9f42:	22 0f       	add	r18, r18
    9f44:	33 1f       	adc	r19, r19
    9f46:	22 0f       	add	r18, r18
    9f48:	33 1f       	adc	r19, r19
    9f4a:	22 0f       	add	r18, r18
    9f4c:	33 1f       	adc	r19, r19
    9f4e:	f9 01       	movw	r30, r18
    9f50:	e6 5b       	subi	r30, 0xB6	; 182
    9f52:	f4 4d       	sbci	r31, 0xD4	; 212
    9f54:	e4 91       	lpm	r30, Z+
			if(prb(&DI_M[D_N].Inversion)){
    9f56:	ee 23       	and	r30, r30
    9f58:	09 f0       	breq	.+2      	; 0x9f5c <DigitIn+0xc4>
    9f5a:	c9 cf       	rjmp	.-110    	; 0x9eee <DigitIn+0x56>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    9f5c:	ca 01       	movw	r24, r20
    9f5e:	88 0f       	add	r24, r24
    9f60:	99 1f       	adc	r25, r25
    9f62:	88 0f       	add	r24, r24
    9f64:	99 1f       	adc	r25, r25
    9f66:	88 0f       	add	r24, r24
    9f68:	99 1f       	adc	r25, r25
    9f6a:	89 5b       	subi	r24, 0xB9	; 185
    9f6c:	94 4d       	sbci	r25, 0xD4	; 212
    9f6e:	fc 01       	movw	r30, r24
    9f70:	c5 91       	lpm	r28, Z+
    9f72:	d4 91       	lpm	r29, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    9f74:	27 5b       	subi	r18, 0xB7	; 183
    9f76:	34 4d       	sbci	r19, 0xD4	; 212
    9f78:	f9 01       	movw	r30, r18
    9f7a:	84 91       	lpm	r24, Z+
					DigInput.State[Byte] |=Bit;
				else
					DigInput.State[Byte] &=~Bit;
			}
			else{
				if (*(uint8_t*)prp(&DI_M[D_N].PIN) & prb(&DI_M[D_N].P))
    9f7c:	98 81       	ld	r25, Y
    9f7e:	89 23       	and	r24, r25
    9f80:	09 f4       	brne	.+2      	; 0x9f84 <DigitIn+0xec>
    9f82:	c3 cf       	rjmp	.-122    	; 0x9f0a <DigitIn+0x72>
					DigInput.State[Byte] &=~Bit;
    9f84:	e7 2f       	mov	r30, r23
    9f86:	f0 e0       	ldi	r31, 0x00	; 0
    9f88:	e4 50       	subi	r30, 0x04	; 4
    9f8a:	f9 4f       	sbci	r31, 0xF9	; 249
    9f8c:	60 95       	com	r22
    9f8e:	80 81       	ld	r24, Z
    9f90:	68 23       	and	r22, r24
    9f92:	60 83       	st	Z, r22
				else
					DigInput.State[Byte]  |=Bit;
    9f94:	4f 5f       	subi	r20, 0xFF	; 255
    9f96:	5f 4f       	sbci	r21, 0xFF	; 255
	void DigitIn_Hard(void);
#else
	static void
	DigitIn_Hard(void)
	{
		for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
    9f98:	42 31       	cpi	r20, 0x12	; 18
    9f9a:	51 05       	cpc	r21, r1
    9f9c:	09 f0       	breq	.+2      	; 0x9fa0 <DigitIn+0x108>
    9f9e:	c2 cf       	rjmp	.-124    	; 0x9f24 <DigitIn+0x8c>
			DigInput.State[j]		= (DigInput_Ext)[i];
			DigInput.Status[j]	= (DigInput_Ext)[i+DI_Reg_Ext];
			IntOn();
		}
	#endif
}
    9fa0:	df 91       	pop	r29
    9fa2:	cf 91       	pop	r28
    9fa4:	08 95       	ret

00009fa6 <Field2Buf>:
	else return 0;
}
// ~~~~~~~~~~~~~~~~~~~~~~~
static void
Field2Buf(OutField *Field)
{
    9fa6:	6f 92       	push	r6
    9fa8:	7f 92       	push	r7
    9faa:	8f 92       	push	r8
    9fac:	9f 92       	push	r9
    9fae:	af 92       	push	r10
    9fb0:	bf 92       	push	r11
    9fb2:	cf 92       	push	r12
    9fb4:	df 92       	push	r13
    9fb6:	ef 92       	push	r14
    9fb8:	ff 92       	push	r15
    9fba:	0f 93       	push	r16
    9fbc:	1f 93       	push	r17
    9fbe:	df 93       	push	r29
    9fc0:	cf 93       	push	r28
    9fc2:	cd b7       	in	r28, 0x3d	; 61
    9fc4:	de b7       	in	r29, 0x3e	; 62
    9fc6:	6f 97       	sbiw	r28, 0x1f	; 31
    9fc8:	0f b6       	in	r0, 0x3f	; 63
    9fca:	f8 94       	cli
    9fcc:	de bf       	out	0x3e, r29	; 62
    9fce:	0f be       	out	0x3f, r0	; 63
    9fd0:	cd bf       	out	0x3d, r28	; 61
    9fd2:	7c 01       	movw	r14, r24

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    9fd4:	fc 01       	movw	r30, r24
    9fd6:	31 96       	adiw	r30, 0x01	; 1
    9fd8:	c5 90       	lpm	r12, Z+
    9fda:	d4 90       	lpm	r13, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    9fdc:	bf e0       	ldi	r27, 0x0F	; 15
    9fde:	8b 2e       	mov	r8, r27
    9fe0:	91 2c       	mov	r9, r1
    9fe2:	88 0e       	add	r8, r24
    9fe4:	99 1e       	adc	r9, r25
    9fe6:	f4 01       	movw	r30, r8
    9fe8:	24 91       	lpm	r18, Z+
	void *Var = prp(&Field->Var);
	uint8_t BitN=prb(&Field->Prec), Mask=1<<BitN%8, *BitVar=(uint8_t*)Var+BitN/8;
    9fea:	32 2f       	mov	r19, r18
    9fec:	37 70       	andi	r19, 0x07	; 7
    9fee:	81 e0       	ldi	r24, 0x01	; 1
    9ff0:	90 e0       	ldi	r25, 0x00	; 0
    9ff2:	18 2f       	mov	r17, r24
    9ff4:	01 c0       	rjmp	.+2      	; 0x9ff8 <Field2Buf+0x52>
    9ff6:	11 0f       	add	r17, r17
    9ff8:	3a 95       	dec	r19
    9ffa:	ea f7       	brpl	.-6      	; 0x9ff6 <Field2Buf+0x50>
    9ffc:	26 95       	lsr	r18
    9ffe:	26 95       	lsr	r18
    a000:	26 95       	lsr	r18
    a002:	56 01       	movw	r10, r12
    a004:	a2 0e       	add	r10, r18
    a006:	b1 1c       	adc	r11, r1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    a008:	a7 e0       	ldi	r26, 0x07	; 7
    a00a:	6a 2e       	mov	r6, r26
    a00c:	71 2c       	mov	r7, r1
    a00e:	6e 0c       	add	r6, r14
    a010:	7f 1c       	adc	r7, r15
    a012:	f3 01       	movw	r30, r6
    a014:	65 91       	lpm	r22, Z+
    a016:	75 91       	lpm	r23, Z+
    a018:	85 91       	lpm	r24, Z+
    a01a:	94 91       	lpm	r25, Z+
	uint8_t Pos=Log10(prd(&Field->Max));
    a01c:	0e 94 b8 20 	call	0x4170	; 0x4170 <Log10>
    a020:	08 2f       	mov	r16, r24

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    a022:	f7 01       	movw	r30, r14
    a024:	84 91       	lpm	r24, Z+
	uint8_t Oldstyle = 0;

	switch(prb(&Field->Type)) {
    a026:	e8 2f       	mov	r30, r24
    a028:	f0 e0       	ldi	r31, 0x00	; 0
    a02a:	e1 32       	cpi	r30, 0x21	; 33
    a02c:	f1 05       	cpc	r31, r1
    a02e:	08 f4       	brcc	.+2      	; 0xa032 <Field2Buf+0x8c>
    a030:	6e c0       	rjmp	.+220    	; 0xa10e <Field2Buf+0x168>
		F_Buf = (erb(BitVar) &Mask) > 0;
		Oldstyle = 1;
		break;
	}

	Minus=0;
    a032:	10 92 fd 04 	sts	0x04FD, r1
	if(Oldstyle) return;

	InitBufStr(Field);
    a036:	c7 01       	movw	r24, r14
    a038:	0e 94 1a 3c 	call	0x7834	; 0x7834 <InitBufStr>
	CurrFieldSize = GetCurrFieldSize();
    a03c:	0e 94 dc 3c 	call	0x79b8	; 0x79b8 <GetCurrFieldSize>
    a040:	48 2f       	mov	r20, r24
    a042:	80 93 7a 07 	sts	0x077A, r24
	CurrPos = CurrFieldSize - 1;
    a046:	41 50       	subi	r20, 0x01	; 1
    a048:	40 93 d7 02 	sts	0x02D7, r20
    a04c:	4f 5f       	subi	r20, 0xFF	; 255
	float fTemp;
	T_Param Param;
	Param.Size = CurrFieldSize;
    a04e:	48 87       	std	Y+8, r20	; 0x08
	Param.Pos = BufStr;
    a050:	81 ec       	ldi	r24, 0xC1	; 193
    a052:	95 e0       	ldi	r25, 0x05	; 5
    a054:	9e 83       	std	Y+6, r25	; 0x06
    a056:	8d 83       	std	Y+5, r24	; 0x05
    a058:	f4 01       	movw	r30, r8
    a05a:	84 91       	lpm	r24, Z+
	Param.Prec = prb(&Field->Prec);
    a05c:	8f 83       	std	Y+7, r24	; 0x07
	Param.Txt = NULL;
    a05e:	1a 86       	std	Y+10, r1	; 0x0a
    a060:	19 86       	std	Y+9, r1	; 0x09
    a062:	f7 01       	movw	r30, r14
    a064:	84 91       	lpm	r24, Z+

	switch(prb(&Field->Type)) {
    a066:	85 31       	cpi	r24, 0x15	; 21
    a068:	09 f4       	brne	.+2      	; 0xa06c <Field2Buf+0xc6>
    a06a:	74 c1       	rjmp	.+744    	; 0xa354 <Field2Buf+0x3ae>
    a06c:	86 31       	cpi	r24, 0x16	; 22
    a06e:	08 f4       	brcc	.+2      	; 0xa072 <Field2Buf+0xcc>
    a070:	56 c1       	rjmp	.+684    	; 0xa31e <Field2Buf+0x378>
    a072:	8b 31       	cpi	r24, 0x1B	; 27
    a074:	09 f4       	brne	.+2      	; 0xa078 <Field2Buf+0xd2>
    a076:	fe c1       	rjmp	.+1020   	; 0xa474 <Field2Buf+0x4ce>
    a078:	8c 31       	cpi	r24, 0x1C	; 28
    a07a:	08 f0       	brcs	.+2      	; 0xa07e <Field2Buf+0xd8>
    a07c:	b7 c1       	rjmp	.+878    	; 0xa3ec <Field2Buf+0x446>
    a07e:	89 31       	cpi	r24, 0x19	; 25
    a080:	09 f4       	brne	.+2      	; 0xa084 <Field2Buf+0xde>
    a082:	92 c1       	rjmp	.+804    	; 0xa3a8 <Field2Buf+0x402>
    a084:	8a 31       	cpi	r24, 0x1A	; 26
    a086:	09 f0       	breq	.+2      	; 0xa08a <Field2Buf+0xe4>
    a088:	5b c0       	rjmp	.+182    	; 0xa140 <Field2Buf+0x19a>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    a08a:	7e 01       	movw	r14, r28
    a08c:	08 94       	sec
    a08e:	e1 1c       	adc	r14, r1
    a090:	f1 1c       	adc	r15, r1
    a092:	c7 01       	movw	r24, r14
    a094:	b6 01       	movw	r22, r12
    a096:	44 e0       	ldi	r20, 0x04	; 4
    a098:	50 e0       	ldi	r21, 0x00	; 0
    a09a:	0e 94 cb 81 	call	0x10396	; 0x10396 <__eerd_block_m2560>
		Put_FFVal(*(float*)Var, &Param);
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
		break;
	case EE_FFloat:
		erbl(&fTemp, Var, 4);
		Put_FFVal(fTemp, &Param);
    a09e:	69 81       	ldd	r22, Y+1	; 0x01
    a0a0:	7a 81       	ldd	r23, Y+2	; 0x02
    a0a2:	8b 81       	ldd	r24, Y+3	; 0x03
    a0a4:	9c 81       	ldd	r25, Y+4	; 0x04
    a0a6:	8e 01       	movw	r16, r28
    a0a8:	0b 5f       	subi	r16, 0xFB	; 251
    a0aa:	1f 4f       	sbci	r17, 0xFF	; 255
    a0ac:	a8 01       	movw	r20, r16
    a0ae:	0e 94 c8 43 	call	0x8790	; 0x8790 <Put_FFVal>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
    a0b2:	8e ea       	ldi	r24, 0xAE	; 174
    a0b4:	96 e0       	ldi	r25, 0x06	; 6
    a0b6:	60 91 c1 05 	lds	r22, 0x05C1
    a0ba:	0e 94 91 40 	call	0x8122	; 0x8122 <GetMultiSymbol>
    a0be:	80 93 f2 04 	sts	0x04F2, r24
	case GFloat:
		Put_GFVal(*(float*)Var, &Param);
    a0c2:	f6 01       	movw	r30, r12
    a0c4:	60 81       	ld	r22, Z
    a0c6:	71 81       	ldd	r23, Z+1	; 0x01
    a0c8:	82 81       	ldd	r24, Z+2	; 0x02
    a0ca:	93 81       	ldd	r25, Z+3	; 0x03
    a0cc:	a8 01       	movw	r20, r16
    a0ce:	0e 94 4e 43 	call	0x869c	; 0x869c <Put_GFVal>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
    a0d2:	8e ea       	ldi	r24, 0xAE	; 174
    a0d4:	96 e0       	ldi	r25, 0x06	; 6
    a0d6:	60 91 c1 05 	lds	r22, 0x05C1
    a0da:	0e 94 91 40 	call	0x8122	; 0x8122 <GetMultiSymbol>
    a0de:	80 93 f2 04 	sts	0x04F2, r24
    a0e2:	c7 01       	movw	r24, r14
    a0e4:	b6 01       	movw	r22, r12
    a0e6:	44 e0       	ldi	r20, 0x04	; 4
    a0e8:	50 e0       	ldi	r21, 0x00	; 0
    a0ea:	0e 94 cb 81 	call	0x10396	; 0x10396 <__eerd_block_m2560>
	case EE_GFloat:
		erbl(&fTemp, Var, 4);
		Put_GFVal(fTemp, &Param);
    a0ee:	69 81       	ldd	r22, Y+1	; 0x01
    a0f0:	7a 81       	ldd	r23, Y+2	; 0x02
    a0f2:	8b 81       	ldd	r24, Y+3	; 0x03
    a0f4:	9c 81       	ldd	r25, Y+4	; 0x04
    a0f6:	a8 01       	movw	r20, r16
    a0f8:	0e 94 4e 43 	call	0x869c	; 0x869c <Put_GFVal>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
    a0fc:	8e ea       	ldi	r24, 0xAE	; 174
    a0fe:	96 e0       	ldi	r25, 0x06	; 6
    a100:	60 91 c1 05 	lds	r22, 0x05C1
    a104:	0e 94 91 40 	call	0x8122	; 0x8122 <GetMultiSymbol>
    a108:	80 93 f2 04 	sts	0x04F2, r24
    a10c:	19 c0       	rjmp	.+50     	; 0xa140 <Field2Buf+0x19a>
	void *Var = prp(&Field->Var);
	uint8_t BitN=prb(&Field->Prec), Mask=1<<BitN%8, *BitVar=(uint8_t*)Var+BitN/8;
	uint8_t Pos=Log10(prd(&Field->Max));
	uint8_t Oldstyle = 0;

	switch(prb(&Field->Type)) {
    a10e:	ee 58       	subi	r30, 0x8E	; 142
    a110:	ff 4f       	sbci	r31, 0xFF	; 255
    a112:	ee 0f       	add	r30, r30
    a114:	ff 1f       	adc	r31, r31
    a116:	05 90       	lpm	r0, Z+
    a118:	f4 91       	lpm	r31, Z+
    a11a:	e0 2d       	mov	r30, r0
    a11c:	19 94       	eijmp
	case Byte: case z_Byte:
		F_Buf = *(uint8_t*)Var;
    a11e:	f6 01       	movw	r30, r12
    a120:	80 81       	ld	r24, Z
    a122:	90 e0       	ldi	r25, 0x00	; 0
    a124:	a0 e0       	ldi	r26, 0x00	; 0
    a126:	b0 e0       	ldi	r27, 0x00	; 0
    a128:	80 93 f5 04 	sts	0x04F5, r24
    a12c:	90 93 f6 04 	sts	0x04F6, r25
    a130:	a0 93 f7 04 	sts	0x04F7, r26
    a134:	b0 93 f8 04 	sts	0x04F8, r27
		CurrPos = Pos;
    a138:	00 93 d7 02 	sts	0x02D7, r16
		F_Buf = (erb(BitVar) &Mask) > 0;
		Oldstyle = 1;
		break;
	}

	Minus=0;
    a13c:	10 92 fd 04 	sts	0x04FD, r1
				MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[0]);
			else MultiSymbol = GetMultiSymbol(Symbols_P, BufStr[0]);
		}
		break;
	}
}
    a140:	6f 96       	adiw	r28, 0x1f	; 31
    a142:	0f b6       	in	r0, 0x3f	; 63
    a144:	f8 94       	cli
    a146:	de bf       	out	0x3e, r29	; 62
    a148:	0f be       	out	0x3f, r0	; 63
    a14a:	cd bf       	out	0x3d, r28	; 61
    a14c:	cf 91       	pop	r28
    a14e:	df 91       	pop	r29
    a150:	1f 91       	pop	r17
    a152:	0f 91       	pop	r16
    a154:	ff 90       	pop	r15
    a156:	ef 90       	pop	r14
    a158:	df 90       	pop	r13
    a15a:	cf 90       	pop	r12
    a15c:	bf 90       	pop	r11
    a15e:	af 90       	pop	r10
    a160:	9f 90       	pop	r9
    a162:	8f 90       	pop	r8
    a164:	7f 90       	pop	r7
    a166:	6f 90       	pop	r6
    a168:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    a16a:	c6 01       	movw	r24, r12
    a16c:	0e 94 db 81 	call	0x103b6	; 0x103b6 <__eerd_byte_m2560>
		sF_Buf = *(int8_t*)Var;
		CurrPos = Pos+1;
		Oldstyle = 1;
		break;
	case EE_Byte: case z_EE_Byte:
		F_Buf = erb((uint8_t*)Var);
    a170:	90 e0       	ldi	r25, 0x00	; 0
    a172:	a0 e0       	ldi	r26, 0x00	; 0
    a174:	b0 e0       	ldi	r27, 0x00	; 0
    a176:	80 93 f5 04 	sts	0x04F5, r24
    a17a:	90 93 f6 04 	sts	0x04F6, r25
    a17e:	a0 93 f7 04 	sts	0x04F7, r26
    a182:	b0 93 f8 04 	sts	0x04F8, r27
		CurrPos = Pos;
    a186:	00 93 d7 02 	sts	0x02D7, r16
    a18a:	d8 cf       	rjmp	.-80     	; 0xa13c <Field2Buf+0x196>
		F_Buf = *(uint8_t*)Var;
		CurrPos = Pos;
		Oldstyle = 1;
		break;
	case s_Byte:
		sF_Buf = *(int8_t*)Var;
    a18c:	f6 01       	movw	r30, r12
    a18e:	80 81       	ld	r24, Z
    a190:	99 27       	eor	r25, r25
    a192:	87 fd       	sbrc	r24, 7
    a194:	90 95       	com	r25
    a196:	a9 2f       	mov	r26, r25
    a198:	b9 2f       	mov	r27, r25
    a19a:	80 93 f9 04 	sts	0x04F9, r24
    a19e:	90 93 fa 04 	sts	0x04FA, r25
    a1a2:	a0 93 fb 04 	sts	0x04FB, r26
    a1a6:	b0 93 fc 04 	sts	0x04FC, r27
		CurrPos = Pos+1;
    a1aa:	0f 5f       	subi	r16, 0xFF	; 255
    a1ac:	00 93 d7 02 	sts	0x02D7, r16
    a1b0:	c5 cf       	rjmp	.-118    	; 0xa13c <Field2Buf+0x196>
    a1b2:	c6 01       	movw	r24, r12
    a1b4:	0e 94 db 81 	call	0x103b6	; 0x103b6 <__eerd_byte_m2560>
		F_Buf = erb((uint8_t*)Var);
		CurrPos = Pos;
		Oldstyle = 1;
		break;
	case s_EE_Byte:
		sF_Buf = (int8_t)erb((uint8_t*)Var);
    a1b8:	99 27       	eor	r25, r25
    a1ba:	87 fd       	sbrc	r24, 7
    a1bc:	90 95       	com	r25
    a1be:	a9 2f       	mov	r26, r25
    a1c0:	b9 2f       	mov	r27, r25
    a1c2:	80 93 f9 04 	sts	0x04F9, r24
    a1c6:	90 93 fa 04 	sts	0x04FA, r25
    a1ca:	a0 93 fb 04 	sts	0x04FB, r26
    a1ce:	b0 93 fc 04 	sts	0x04FC, r27
		CurrPos = Pos+1;
    a1d2:	0f 5f       	subi	r16, 0xFF	; 255
    a1d4:	00 93 d7 02 	sts	0x02D7, r16
    a1d8:	b1 cf       	rjmp	.-158    	; 0xa13c <Field2Buf+0x196>
		Oldstyle = 1;
		break;

	case Word: case z_Word:
		F_Buf = *(uint16_t*)Var;
    a1da:	f6 01       	movw	r30, r12
    a1dc:	80 81       	ld	r24, Z
    a1de:	91 81       	ldd	r25, Z+1	; 0x01
    a1e0:	a0 e0       	ldi	r26, 0x00	; 0
    a1e2:	b0 e0       	ldi	r27, 0x00	; 0
    a1e4:	80 93 f5 04 	sts	0x04F5, r24
    a1e8:	90 93 f6 04 	sts	0x04F6, r25
    a1ec:	a0 93 f7 04 	sts	0x04F7, r26
    a1f0:	b0 93 f8 04 	sts	0x04F8, r27
		CurrPos = Pos;
    a1f4:	00 93 d7 02 	sts	0x02D7, r16
    a1f8:	a1 cf       	rjmp	.-190    	; 0xa13c <Field2Buf+0x196>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    a1fa:	c6 01       	movw	r24, r12
    a1fc:	0e 94 e9 81 	call	0x103d2	; 0x103d2 <__eerd_word_m2560>
		Oldstyle = 1;
		break;
	case EE_Word: case z_EE_Word:
		F_Buf = erw((uint16_t*)Var);
    a200:	a0 e0       	ldi	r26, 0x00	; 0
    a202:	b0 e0       	ldi	r27, 0x00	; 0
    a204:	80 93 f5 04 	sts	0x04F5, r24
    a208:	90 93 f6 04 	sts	0x04F6, r25
    a20c:	a0 93 f7 04 	sts	0x04F7, r26
    a210:	b0 93 f8 04 	sts	0x04F8, r27
		CurrPos = Pos;
    a214:	00 93 d7 02 	sts	0x02D7, r16
    a218:	91 cf       	rjmp	.-222    	; 0xa13c <Field2Buf+0x196>
		Oldstyle = 1;
		break;
	case s_Word:
		sF_Buf = *(int16_t*)Var;
    a21a:	f6 01       	movw	r30, r12
    a21c:	80 81       	ld	r24, Z
    a21e:	91 81       	ldd	r25, Z+1	; 0x01
    a220:	aa 27       	eor	r26, r26
    a222:	97 fd       	sbrc	r25, 7
    a224:	a0 95       	com	r26
    a226:	ba 2f       	mov	r27, r26
    a228:	80 93 f9 04 	sts	0x04F9, r24
    a22c:	90 93 fa 04 	sts	0x04FA, r25
    a230:	a0 93 fb 04 	sts	0x04FB, r26
    a234:	b0 93 fc 04 	sts	0x04FC, r27
		CurrPos = Pos+1;
    a238:	0f 5f       	subi	r16, 0xFF	; 255
    a23a:	00 93 d7 02 	sts	0x02D7, r16
    a23e:	7e cf       	rjmp	.-260    	; 0xa13c <Field2Buf+0x196>
    a240:	c6 01       	movw	r24, r12
    a242:	0e 94 e9 81 	call	0x103d2	; 0x103d2 <__eerd_word_m2560>
		Oldstyle = 1;
		break;
	case s_EE_Word:
		sF_Buf = (int16_t)erw((uint16_t*)Var);
    a246:	aa 27       	eor	r26, r26
    a248:	97 fd       	sbrc	r25, 7
    a24a:	a0 95       	com	r26
    a24c:	ba 2f       	mov	r27, r26
    a24e:	80 93 f9 04 	sts	0x04F9, r24
    a252:	90 93 fa 04 	sts	0x04FA, r25
    a256:	a0 93 fb 04 	sts	0x04FB, r26
    a25a:	b0 93 fc 04 	sts	0x04FC, r27
		CurrPos = Pos+1;
    a25e:	0f 5f       	subi	r16, 0xFF	; 255
    a260:	00 93 d7 02 	sts	0x02D7, r16
    a264:	6b cf       	rjmp	.-298    	; 0xa13c <Field2Buf+0x196>
		Oldstyle = 1;
		break;
	case c_Word: case zc_Word:
		F_Buf = *(uint16_t*)Var;
    a266:	f6 01       	movw	r30, r12
    a268:	80 81       	ld	r24, Z
    a26a:	91 81       	ldd	r25, Z+1	; 0x01
    a26c:	a0 e0       	ldi	r26, 0x00	; 0
    a26e:	b0 e0       	ldi	r27, 0x00	; 0
    a270:	80 93 f5 04 	sts	0x04F5, r24
    a274:	90 93 f6 04 	sts	0x04F6, r25
    a278:	a0 93 f7 04 	sts	0x04F7, r26
    a27c:	b0 93 f8 04 	sts	0x04F8, r27
    a280:	5d cf       	rjmp	.-326    	; 0xa13c <Field2Buf+0x196>
		Oldstyle = 1;
		break;

	case Enum:
		F_Buf = *(uint8_t*)Var;
    a282:	f6 01       	movw	r30, r12
    a284:	80 81       	ld	r24, Z
    a286:	90 e0       	ldi	r25, 0x00	; 0
    a288:	a0 e0       	ldi	r26, 0x00	; 0
    a28a:	b0 e0       	ldi	r27, 0x00	; 0
    a28c:	80 93 f5 04 	sts	0x04F5, r24
    a290:	90 93 f6 04 	sts	0x04F6, r25
    a294:	a0 93 f7 04 	sts	0x04F7, r26
    a298:	b0 93 f8 04 	sts	0x04F8, r27
    a29c:	4f cf       	rjmp	.-354    	; 0xa13c <Field2Buf+0x196>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    a29e:	c6 01       	movw	r24, r12
    a2a0:	0e 94 db 81 	call	0x103b6	; 0x103b6 <__eerd_byte_m2560>
		Oldstyle = 1;
		break;
	case EE_Enum:
		F_Buf = erb((uint8_t*)Var);
    a2a4:	90 e0       	ldi	r25, 0x00	; 0
    a2a6:	a0 e0       	ldi	r26, 0x00	; 0
    a2a8:	b0 e0       	ldi	r27, 0x00	; 0
    a2aa:	80 93 f5 04 	sts	0x04F5, r24
    a2ae:	90 93 f6 04 	sts	0x04F6, r25
    a2b2:	a0 93 f7 04 	sts	0x04F7, r26
    a2b6:	b0 93 f8 04 	sts	0x04F8, r27
    a2ba:	40 cf       	rjmp	.-384    	; 0xa13c <Field2Buf+0x196>
		Oldstyle = 1;
		break;
	case Bit:
		F_Buf = (*BitVar &Mask) > 0;
    a2bc:	20 e0       	ldi	r18, 0x00	; 0
    a2be:	30 e0       	ldi	r19, 0x00	; 0
    a2c0:	40 e0       	ldi	r20, 0x00	; 0
    a2c2:	50 e0       	ldi	r21, 0x00	; 0
    a2c4:	f5 01       	movw	r30, r10
    a2c6:	80 81       	ld	r24, Z
    a2c8:	81 23       	and	r24, r17
    a2ca:	21 f5       	brne	.+72     	; 0xa314 <Field2Buf+0x36e>
    a2cc:	20 93 f5 04 	sts	0x04F5, r18
    a2d0:	30 93 f6 04 	sts	0x04F6, r19
    a2d4:	40 93 f7 04 	sts	0x04F7, r20
    a2d8:	50 93 f8 04 	sts	0x04F8, r21
    a2dc:	2f cf       	rjmp	.-418    	; 0xa13c <Field2Buf+0x196>
    a2de:	c5 01       	movw	r24, r10
    a2e0:	0e 94 db 81 	call	0x103b6	; 0x103b6 <__eerd_byte_m2560>
		Oldstyle = 1;
		break;
	case EE_Bit:
		F_Buf = (erb(BitVar) &Mask) > 0;
    a2e4:	10 92 f5 04 	sts	0x04F5, r1
    a2e8:	10 92 f6 04 	sts	0x04F6, r1
    a2ec:	10 92 f7 04 	sts	0x04F7, r1
    a2f0:	10 92 f8 04 	sts	0x04F8, r1
    a2f4:	18 23       	and	r17, r24
    a2f6:	09 f4       	brne	.+2      	; 0xa2fa <Field2Buf+0x354>
    a2f8:	21 cf       	rjmp	.-446    	; 0xa13c <Field2Buf+0x196>
    a2fa:	81 e0       	ldi	r24, 0x01	; 1
    a2fc:	90 e0       	ldi	r25, 0x00	; 0
    a2fe:	a0 e0       	ldi	r26, 0x00	; 0
    a300:	b0 e0       	ldi	r27, 0x00	; 0
    a302:	80 93 f5 04 	sts	0x04F5, r24
    a306:	90 93 f6 04 	sts	0x04F6, r25
    a30a:	a0 93 f7 04 	sts	0x04F7, r26
    a30e:	b0 93 f8 04 	sts	0x04F8, r27
    a312:	14 cf       	rjmp	.-472    	; 0xa13c <Field2Buf+0x196>
	case EE_Enum:
		F_Buf = erb((uint8_t*)Var);
		Oldstyle = 1;
		break;
	case Bit:
		F_Buf = (*BitVar &Mask) > 0;
    a314:	21 e0       	ldi	r18, 0x01	; 1
    a316:	30 e0       	ldi	r19, 0x00	; 0
    a318:	40 e0       	ldi	r20, 0x00	; 0
    a31a:	50 e0       	ldi	r21, 0x00	; 0
    a31c:	d7 cf       	rjmp	.-82     	; 0xa2cc <Field2Buf+0x326>
	Param.Size = CurrFieldSize;
	Param.Pos = BufStr;
	Param.Prec = prb(&Field->Prec);
	Param.Txt = NULL;

	switch(prb(&Field->Type)) {
    a31e:	82 31       	cpi	r24, 0x12	; 18
    a320:	51 f1       	breq	.+84     	; 0xa376 <Field2Buf+0x3d0>
    a322:	83 31       	cpi	r24, 0x13	; 19
    a324:	08 f0       	brcs	.+2      	; 0xa328 <Field2Buf+0x382>
    a326:	53 c0       	rjmp	.+166    	; 0xa3ce <Field2Buf+0x428>
    a328:	80 31       	cpi	r24, 0x10	; 16
    a32a:	c1 f1       	breq	.+112    	; 0xa39c <Field2Buf+0x3f6>
    a32c:	81 31       	cpi	r24, 0x11	; 17
    a32e:	09 f0       	breq	.+2      	; 0xa332 <Field2Buf+0x38c>
    a330:	07 cf       	rjmp	.-498    	; 0xa140 <Field2Buf+0x19a>
// ~~~~~~~~~~~~~~~~~~~~~~
uint32_t
erd(const uint32_t *addr)
{
	//IntOff();
	uint32_t word = eeprom_read_dword(addr);
    a332:	c6 01       	movw	r24, r12
    a334:	0e 94 e3 81 	call	0x103c6	; 0x103c6 <__eerd_dword_m2560>
	case z_Longint:
		Put_zDVal(*(uint32_t*)Var, &Param);
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
		break;
	case EE_Longint: 
		PutDVal(erd((uint32_t*)Var), &Param);
    a338:	ae 01       	movw	r20, r28
    a33a:	4b 5f       	subi	r20, 0xFB	; 251
    a33c:	5f 4f       	sbci	r21, 0xFF	; 255
    a33e:	0e 94 67 46 	call	0x8cce	; 0x8cce <PutDVal>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
    a342:	8e ea       	ldi	r24, 0xAE	; 174
    a344:	96 e0       	ldi	r25, 0x06	; 6
    a346:	60 91 c1 05 	lds	r22, 0x05C1
    a34a:	0e 94 91 40 	call	0x8122	; 0x8122 <GetMultiSymbol>
    a34e:	80 93 f2 04 	sts	0x04F2, r24
    a352:	f6 ce       	rjmp	.-532    	; 0xa140 <Field2Buf+0x19a>
    a354:	c6 01       	movw	r24, r12
    a356:	0e 94 e3 81 	call	0x103c6	; 0x103c6 <__eerd_dword_m2560>
		break;
	case z_EE_Longint:
		Put_zDVal(erd((uint32_t*)Var), &Param);
    a35a:	ae 01       	movw	r20, r28
    a35c:	4b 5f       	subi	r20, 0xFB	; 251
    a35e:	5f 4f       	sbci	r21, 0xFF	; 255
    a360:	0e 94 1d 44 	call	0x883a	; 0x883a <Put_zDVal>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
    a364:	8e ea       	ldi	r24, 0xAE	; 174
    a366:	96 e0       	ldi	r25, 0x06	; 6
    a368:	60 91 c1 05 	lds	r22, 0x05C1
    a36c:	0e 94 91 40 	call	0x8122	; 0x8122 <GetMultiSymbol>
    a370:	80 93 f2 04 	sts	0x04F2, r24
    a374:	e5 ce       	rjmp	.-566    	; 0xa140 <Field2Buf+0x19a>
		break;
	case s_Longint:
		Put_sDVal(*(int32_t*)Var, &Param);
    a376:	f6 01       	movw	r30, r12
    a378:	60 81       	ld	r22, Z
    a37a:	71 81       	ldd	r23, Z+1	; 0x01
    a37c:	82 81       	ldd	r24, Z+2	; 0x02
    a37e:	93 81       	ldd	r25, Z+3	; 0x03
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
		break;
	case s_EE_Longint:
		Put_sDVal((int32_t)erd((uint32_t*)Var), &Param);
    a380:	ae 01       	movw	r20, r28
    a382:	4b 5f       	subi	r20, 0xFB	; 251
    a384:	5f 4f       	sbci	r21, 0xFF	; 255
    a386:	0e 94 3e 45 	call	0x8a7c	; 0x8a7c <Put_sDVal>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
    a38a:	8e ea       	ldi	r24, 0xAE	; 174
    a38c:	96 e0       	ldi	r25, 0x06	; 6
    a38e:	60 91 c1 05 	lds	r22, 0x05C1
    a392:	0e 94 91 40 	call	0x8122	; 0x8122 <GetMultiSymbol>
    a396:	80 93 f2 04 	sts	0x04F2, r24
    a39a:	d2 ce       	rjmp	.-604    	; 0xa140 <Field2Buf+0x19a>
	Param.Prec = prb(&Field->Prec);
	Param.Txt = NULL;

	switch(prb(&Field->Type)) {
	case Longint:
		PutDVal(*(uint32_t*)Var, &Param);
    a39c:	f6 01       	movw	r30, r12
    a39e:	60 81       	ld	r22, Z
    a3a0:	71 81       	ldd	r23, Z+1	; 0x01
    a3a2:	82 81       	ldd	r24, Z+2	; 0x02
    a3a4:	93 81       	ldd	r25, Z+3	; 0x03
    a3a6:	c8 cf       	rjmp	.-112    	; 0xa338 <Field2Buf+0x392>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
		break;


	case FFloat:
		Put_FFVal(*(float*)Var, &Param);
    a3a8:	f6 01       	movw	r30, r12
    a3aa:	60 81       	ld	r22, Z
    a3ac:	71 81       	ldd	r23, Z+1	; 0x01
    a3ae:	82 81       	ldd	r24, Z+2	; 0x02
    a3b0:	93 81       	ldd	r25, Z+3	; 0x03
    a3b2:	ae 01       	movw	r20, r28
    a3b4:	4b 5f       	subi	r20, 0xFB	; 251
    a3b6:	5f 4f       	sbci	r21, 0xFF	; 255
    a3b8:	0e 94 c8 43 	call	0x8790	; 0x8790 <Put_FFVal>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
    a3bc:	8e ea       	ldi	r24, 0xAE	; 174
    a3be:	96 e0       	ldi	r25, 0x06	; 6
    a3c0:	60 91 c1 05 	lds	r22, 0x05C1
    a3c4:	0e 94 91 40 	call	0x8122	; 0x8122 <GetMultiSymbol>
    a3c8:	80 93 f2 04 	sts	0x04F2, r24
    a3cc:	b9 ce       	rjmp	.-654    	; 0xa140 <Field2Buf+0x19a>
	Param.Size = CurrFieldSize;
	Param.Pos = BufStr;
	Param.Prec = prb(&Field->Prec);
	Param.Txt = NULL;

	switch(prb(&Field->Type)) {
    a3ce:	83 31       	cpi	r24, 0x13	; 19
    a3d0:	49 f0       	breq	.+18     	; 0xa3e4 <Field2Buf+0x43e>
    a3d2:	84 31       	cpi	r24, 0x14	; 20
    a3d4:	09 f0       	breq	.+2      	; 0xa3d8 <Field2Buf+0x432>
    a3d6:	b4 ce       	rjmp	.-664    	; 0xa140 <Field2Buf+0x19a>
	case Longint:
		PutDVal(*(uint32_t*)Var, &Param);
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
		break;
	case z_Longint:
		Put_zDVal(*(uint32_t*)Var, &Param);
    a3d8:	f6 01       	movw	r30, r12
    a3da:	60 81       	ld	r22, Z
    a3dc:	71 81       	ldd	r23, Z+1	; 0x01
    a3de:	82 81       	ldd	r24, Z+2	; 0x02
    a3e0:	93 81       	ldd	r25, Z+3	; 0x03
    a3e2:	bb cf       	rjmp	.-138    	; 0xa35a <Field2Buf+0x3b4>
    a3e4:	c6 01       	movw	r24, r12
    a3e6:	0e 94 e3 81 	call	0x103c6	; 0x103c6 <__eerd_dword_m2560>
    a3ea:	ca cf       	rjmp	.-108    	; 0xa380 <Field2Buf+0x3da>
	Param.Size = CurrFieldSize;
	Param.Pos = BufStr;
	Param.Prec = prb(&Field->Prec);
	Param.Txt = NULL;

	switch(prb(&Field->Type)) {
    a3ec:	81 32       	cpi	r24, 0x21	; 33
    a3ee:	69 f0       	breq	.+26     	; 0xa40a <Field2Buf+0x464>
    a3f0:	82 32       	cpi	r24, 0x22	; 34
    a3f2:	69 f1       	breq	.+90     	; 0xa44e <Field2Buf+0x4a8>
    a3f4:	8c 31       	cpi	r24, 0x1C	; 28
    a3f6:	09 f0       	breq	.+2      	; 0xa3fa <Field2Buf+0x454>
    a3f8:	a3 ce       	rjmp	.-698    	; 0xa140 <Field2Buf+0x19a>
    a3fa:	8e 01       	movw	r16, r28
    a3fc:	0b 5f       	subi	r16, 0xFB	; 251
    a3fe:	1f 4f       	sbci	r17, 0xFF	; 255
    a400:	7e 01       	movw	r14, r28
    a402:	08 94       	sec
    a404:	e1 1c       	adc	r14, r1
    a406:	f1 1c       	adc	r15, r1
    a408:	6c ce       	rjmp	.-808    	; 0xa0e2 <Field2Buf+0x13c>
		MultiSymbol = GetMultiSymbol(Digits_P, BufStr[0]);
		break;


	case Text:
		Put_TextValAlignLeft((char*)Var, &Param);
    a40a:	c6 01       	movw	r24, r12
		
		break;
	case EE_Text:{
			char TempStr[LCDXSz+1];
			erbl(TempStr, Var, CurrFieldSize);
			Put_TextValAlignLeft(TempStr, &Param);
    a40c:	be 01       	movw	r22, r28
    a40e:	6b 5f       	subi	r22, 0xFB	; 251
    a410:	7f 4f       	sbci	r23, 0xFF	; 255
    a412:	0e 94 96 42 	call	0x852c	; 0x852c <Put_TextValAlignLeft>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    a416:	f7 01       	movw	r30, r14
    a418:	33 96       	adiw	r30, 0x03	; 3
    a41a:	85 91       	lpm	r24, Z+
    a41c:	95 91       	lpm	r25, Z+
    a41e:	a5 91       	lpm	r26, Z+
    a420:	b4 91       	lpm	r27, Z+
			if( (prd(&Field->Min) == DIGIT) && (prd(&Field->Max) == DIGIT) )
    a422:	00 97       	sbiw	r24, 0x00	; 0
    a424:	a1 05       	cpc	r26, r1
    a426:	b1 05       	cpc	r27, r1
    a428:	49 f4       	brne	.+18     	; 0xa43c <Field2Buf+0x496>
    a42a:	f3 01       	movw	r30, r6
    a42c:	85 91       	lpm	r24, Z+
    a42e:	95 91       	lpm	r25, Z+
    a430:	a5 91       	lpm	r26, Z+
    a432:	b4 91       	lpm	r27, Z+
    a434:	00 97       	sbiw	r24, 0x00	; 0
    a436:	a1 05       	cpc	r26, r1
    a438:	b1 05       	cpc	r27, r1
    a43a:	99 f0       	breq	.+38     	; 0xa462 <Field2Buf+0x4bc>
				MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[0]);
			else MultiSymbol = GetMultiSymbol(Symbols_P, BufStr[0]);
    a43c:	85 e0       	ldi	r24, 0x05	; 5
    a43e:	96 e0       	ldi	r25, 0x06	; 6
    a440:	60 91 c1 05 	lds	r22, 0x05C1
    a444:	0e 94 91 40 	call	0x8122	; 0x8122 <GetMultiSymbol>
    a448:	80 93 f2 04 	sts	0x04F2, r24
    a44c:	79 ce       	rjmp	.-782    	; 0xa140 <Field2Buf+0x19a>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    a44e:	8e 01       	movw	r16, r28
    a450:	05 5f       	subi	r16, 0xF5	; 245
    a452:	1f 4f       	sbci	r17, 0xFF	; 255
    a454:	c8 01       	movw	r24, r16
    a456:	b6 01       	movw	r22, r12
    a458:	50 e0       	ldi	r21, 0x00	; 0
    a45a:	0e 94 cb 81 	call	0x10396	; 0x10396 <__eerd_block_m2560>
		
		break;
	case EE_Text:{
			char TempStr[LCDXSz+1];
			erbl(TempStr, Var, CurrFieldSize);
			Put_TextValAlignLeft(TempStr, &Param);
    a45e:	c8 01       	movw	r24, r16
    a460:	d5 cf       	rjmp	.-86     	; 0xa40c <Field2Buf+0x466>
			if( (prd(&Field->Min) == DIGIT) && (prd(&Field->Max) == DIGIT) )
				MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[0]);
    a462:	83 ea       	ldi	r24, 0xA3	; 163
    a464:	96 e0       	ldi	r25, 0x06	; 6
    a466:	60 91 c1 05 	lds	r22, 0x05C1
    a46a:	0e 94 91 40 	call	0x8122	; 0x8122 <GetMultiSymbol>
    a46e:	80 93 f2 04 	sts	0x04F2, r24
    a472:	66 ce       	rjmp	.-820    	; 0xa140 <Field2Buf+0x19a>
    a474:	8e 01       	movw	r16, r28
    a476:	0b 5f       	subi	r16, 0xFB	; 251
    a478:	1f 4f       	sbci	r17, 0xFF	; 255
    a47a:	7e 01       	movw	r14, r28
    a47c:	08 94       	sec
    a47e:	e1 1c       	adc	r14, r1
    a480:	f1 1c       	adc	r15, r1
    a482:	1f ce       	rjmp	.-962    	; 0xa0c2 <Field2Buf+0x11c>

0000a484 <MenuEscLeft>:
}

// ~~~~~~~~~~~~~~
void
MenuEscLeft(void)
{
    a484:	0f 93       	push	r16
    a486:	1f 93       	push	r17
    a488:	cf 93       	push	r28
    a48a:	df 93       	push	r29
//	1) Hide current Message
	if(HideMsg()||KeyFunc(&CurrPage->Esc))
    a48c:	0e 94 8a 3c 	call	0x7914	; 0x7914 <HideMsg>
    a490:	88 23       	and	r24, r24
    a492:	29 f0       	breq	.+10     	; 0xa49e <MenuEscLeft+0x1a>
		else
			CurrPage=prp(&CurrPage->OutPage);
		CurrLine=CurrLCD=GetFix();
	}
	EventFunc(&CurrPage->Load);
}
    a494:	df 91       	pop	r29
    a496:	cf 91       	pop	r28
    a498:	1f 91       	pop	r17
    a49a:	0f 91       	pop	r16
    a49c:	08 95       	ret
// ~~~~~~~~~~~~~~
void
MenuEscLeft(void)
{
//	1) Hide current Message
	if(HideMsg()||KeyFunc(&CurrPage->Esc))
    a49e:	80 91 d4 02 	lds	r24, 0x02D4
    a4a2:	90 91 d5 02 	lds	r25, 0x02D5
    a4a6:	0e 96       	adiw	r24, 0x0e	; 14
    a4a8:	0e 94 30 3c 	call	0x7860	; 0x7860 <KeyFunc>
    a4ac:	88 23       	and	r24, r24
    a4ae:	91 f7       	brne	.-28     	; 0xa494 <MenuEscLeft+0x10>
		return;

// 2) Variable
	if(CurrField!=NullPos) {
    a4b0:	30 91 d6 02 	lds	r19, 0x02D6
    a4b4:	3f 3f       	cpi	r19, 0xFF	; 255
    a4b6:	09 f4       	brne	.+2      	; 0xa4ba <MenuEscLeft+0x36>
    a4b8:	c8 c0       	rjmp	.+400    	; 0xa64a <MenuEscLeft+0x1c6>
		if(CurrPos!=NullPos) {
    a4ba:	40 91 d7 02 	lds	r20, 0x02D7
    a4be:	4f 3f       	cpi	r20, 0xFF	; 255
    a4c0:	09 f4       	brne	.+2      	; 0xa4c4 <MenuEscLeft+0x40>
    a4c2:	5a c0       	rjmp	.+180    	; 0xa578 <MenuEscLeft+0xf4>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    a4c4:	80 91 d4 02 	lds	r24, 0x02D4
    a4c8:	90 91 d5 02 	lds	r25, 0x02D5
    a4cc:	fc 01       	movw	r30, r24
    a4ce:	65 91       	lpm	r22, Z+
    a4d0:	74 91       	lpm	r23, Z+
			OutField *Field=GetField;
    a4d2:	80 91 83 07 	lds	r24, 0x0783
    a4d6:	2b e1       	ldi	r18, 0x1B	; 27
    a4d8:	82 9f       	mul	r24, r18
    a4da:	c0 01       	movw	r24, r0
    a4dc:	11 24       	eor	r1, r1
    a4de:	68 0f       	add	r22, r24
    a4e0:	79 1f       	adc	r23, r25
    a4e2:	69 5e       	subi	r22, 0xE9	; 233
    a4e4:	7f 4f       	sbci	r23, 0xFF	; 255
    a4e6:	fb 01       	movw	r30, r22
    a4e8:	c5 91       	lpm	r28, Z+
    a4ea:	d4 91       	lpm	r29, Z+
    a4ec:	83 2f       	mov	r24, r19
    a4ee:	90 e0       	ldi	r25, 0x00	; 0
    a4f0:	82 95       	swap	r24
    a4f2:	92 95       	swap	r25
    a4f4:	90 7f       	andi	r25, 0xF0	; 240
    a4f6:	98 27       	eor	r25, r24
    a4f8:	80 7f       	andi	r24, 0xF0	; 240
    a4fa:	98 27       	eor	r25, r24
    a4fc:	c8 0f       	add	r28, r24
    a4fe:	d9 1f       	adc	r29, r25

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    a500:	fe 01       	movw	r30, r28
    a502:	14 91       	lpm	r17, Z+
			uint8_t Type=prb(&Field->Type);
			uint8_t Pos;

			if( (Type == Text) || (Type == EE_Text) ||
    a504:	01 2f       	mov	r16, r17
    a506:	01 52       	subi	r16, 0x21	; 33
    a508:	02 30       	cpi	r16, 0x02	; 2
    a50a:	00 f1       	brcs	.+64     	; 0xa54c <MenuEscLeft+0xc8>
    a50c:	10 31       	cpi	r17, 0x10	; 16
    a50e:	f1 f0       	breq	.+60     	; 0xa54c <MenuEscLeft+0xc8>
    a510:	11 31       	cpi	r17, 0x11	; 17
    a512:	e1 f0       	breq	.+56     	; 0xa54c <MenuEscLeft+0xc8>
    a514:	12 31       	cpi	r17, 0x12	; 18
    a516:	d1 f0       	breq	.+52     	; 0xa54c <MenuEscLeft+0xc8>
    a518:	13 31       	cpi	r17, 0x13	; 19
    a51a:	c1 f0       	breq	.+48     	; 0xa54c <MenuEscLeft+0xc8>
    a51c:	14 31       	cpi	r17, 0x14	; 20
    a51e:	b1 f0       	breq	.+44     	; 0xa54c <MenuEscLeft+0xc8>
    a520:	15 31       	cpi	r17, 0x15	; 21
    a522:	a1 f0       	breq	.+40     	; 0xa54c <MenuEscLeft+0xc8>
    a524:	19 31       	cpi	r17, 0x19	; 25
    a526:	91 f0       	breq	.+36     	; 0xa54c <MenuEscLeft+0xc8>
    a528:	1a 31       	cpi	r17, 0x1A	; 26
    a52a:	81 f0       	breq	.+32     	; 0xa54c <MenuEscLeft+0xc8>
    a52c:	1b 31       	cpi	r17, 0x1B	; 27
    a52e:	71 f0       	breq	.+28     	; 0xa54c <MenuEscLeft+0xc8>
    a530:	1c 31       	cpi	r17, 0x1C	; 28
    a532:	61 f0       	breq	.+24     	; 0xa54c <MenuEscLeft+0xc8>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    a534:	fe 01       	movw	r30, r28
    a536:	37 96       	adiw	r30, 0x07	; 7
    a538:	65 91       	lpm	r22, Z+
    a53a:	75 91       	lpm	r23, Z+
    a53c:	85 91       	lpm	r24, Z+
    a53e:	94 91       	lpm	r25, Z+
			 (Type == Longint) || (Type == EE_Longint)|| (Type == s_Longint) || (Type == s_EE_Longint) || (Type == z_Longint) || (Type == z_EE_Longint) ||
			 (Type == FFloat) || (Type == EE_FFloat) || (Type == GFloat) || (Type == EE_GFloat) ) 
			 	Pos = CurrFieldSize-1;
			else Pos=Log10(prd(&Field->Max));
    a540:	0e 94 b8 20 	call	0x4170	; 0x4170 <Log10>
    a544:	98 2f       	mov	r25, r24
    a546:	40 91 d7 02 	lds	r20, 0x02D7
    a54a:	03 c0       	rjmp	.+6      	; 0xa552 <MenuEscLeft+0xce>
			uint8_t Pos;

			if( (Type == Text) || (Type == EE_Text) ||
			 (Type == Longint) || (Type == EE_Longint)|| (Type == s_Longint) || (Type == s_EE_Longint) || (Type == z_Longint) || (Type == z_EE_Longint) ||
			 (Type == FFloat) || (Type == EE_FFloat) || (Type == GFloat) || (Type == EE_GFloat) ) 
			 	Pos = CurrFieldSize-1;
    a54c:	90 91 7a 07 	lds	r25, 0x077A
    a550:	91 50       	subi	r25, 0x01	; 1
			else Pos=Log10(prd(&Field->Max));

			if(Type==s_Byte || Type==s_EE_Byte || Type==s_Word || Type==s_EE_Word)
    a552:	81 2f       	mov	r24, r17
    a554:	82 50       	subi	r24, 0x02	; 2
    a556:	82 30       	cpi	r24, 0x02	; 2
    a558:	b0 f1       	brcs	.+108    	; 0xa5c6 <MenuEscLeft+0x142>
    a55a:	19 30       	cpi	r17, 0x09	; 9
    a55c:	a1 f1       	breq	.+104    	; 0xa5c6 <MenuEscLeft+0x142>
    a55e:	1a 30       	cpi	r17, 0x0A	; 10
    a560:	91 f1       	breq	.+100    	; 0xa5c6 <MenuEscLeft+0x142>
				Pos++;
			if(++CurrPos>Pos)
    a562:	24 2f       	mov	r18, r20
    a564:	2f 5f       	subi	r18, 0xFF	; 255
    a566:	20 93 d7 02 	sts	0x02D7, r18
    a56a:	92 17       	cp	r25, r18
    a56c:	70 f5       	brcc	.+92     	; 0xa5ca <MenuEscLeft+0x146>
				CurrPos = NullPos;
    a56e:	8f ef       	ldi	r24, 0xFF	; 255
    a570:	80 93 d7 02 	sts	0x02D7, r24
    a574:	30 91 d6 02 	lds	r19, 0x02D6
				}
				return;
			}
		}
		//     
		if(--CurrField!=NullPos)
    a578:	31 50       	subi	r19, 0x01	; 1
    a57a:	30 93 d6 02 	sts	0x02D6, r19
    a57e:	3f 3f       	cpi	r19, 0xFF	; 255
    a580:	09 f4       	brne	.+2      	; 0xa584 <MenuEscLeft+0x100>
    a582:	88 cf       	rjmp	.-240    	; 0xa494 <MenuEscLeft+0x10>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    a584:	80 91 d4 02 	lds	r24, 0x02D4
    a588:	90 91 d5 02 	lds	r25, 0x02D5
    a58c:	fc 01       	movw	r30, r24
    a58e:	45 91       	lpm	r20, Z+
    a590:	54 91       	lpm	r21, Z+
			Field2Buf(GetField);
    a592:	80 91 83 07 	lds	r24, 0x0783
    a596:	2b e1       	ldi	r18, 0x1B	; 27
    a598:	82 9f       	mul	r24, r18
    a59a:	c0 01       	movw	r24, r0
    a59c:	11 24       	eor	r1, r1
    a59e:	48 0f       	add	r20, r24
    a5a0:	59 1f       	adc	r21, r25
    a5a2:	49 5e       	subi	r20, 0xE9	; 233
    a5a4:	5f 4f       	sbci	r21, 0xFF	; 255
    a5a6:	fa 01       	movw	r30, r20
    a5a8:	85 91       	lpm	r24, Z+
    a5aa:	94 91       	lpm	r25, Z+
    a5ac:	23 2f       	mov	r18, r19
    a5ae:	30 e0       	ldi	r19, 0x00	; 0
    a5b0:	22 95       	swap	r18
    a5b2:	32 95       	swap	r19
    a5b4:	30 7f       	andi	r19, 0xF0	; 240
    a5b6:	32 27       	eor	r19, r18
    a5b8:	20 7f       	andi	r18, 0xF0	; 240
    a5ba:	32 27       	eor	r19, r18
    a5bc:	82 0f       	add	r24, r18
    a5be:	93 1f       	adc	r25, r19
    a5c0:	0e 94 d3 4f 	call	0x9fa6	; 0x9fa6 <Field2Buf>
    a5c4:	67 cf       	rjmp	.-306    	; 0xa494 <MenuEscLeft+0x10>
			 (Type == FFloat) || (Type == EE_FFloat) || (Type == GFloat) || (Type == EE_GFloat) ) 
			 	Pos = CurrFieldSize-1;
			else Pos=Log10(prd(&Field->Max));

			if(Type==s_Byte || Type==s_EE_Byte || Type==s_Word || Type==s_EE_Word)
				Pos++;
    a5c6:	9f 5f       	subi	r25, 0xFF	; 255
    a5c8:	cc cf       	rjmp	.-104    	; 0xa562 <MenuEscLeft+0xde>
			if(++CurrPos>Pos)
				CurrPos = NullPos;
			else{
				switch(Type){
    a5ca:	1d 31       	cpi	r17, 0x1D	; 29
    a5cc:	40 f1       	brcs	.+80     	; 0xa61e <MenuEscLeft+0x19a>
    a5ce:	02 30       	cpi	r16, 0x02	; 2
    a5d0:	08 f0       	brcs	.+2      	; 0xa5d4 <MenuEscLeft+0x150>
    a5d2:	60 cf       	rjmp	.-320    	; 0xa494 <MenuEscLeft+0x10>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    a5d4:	fe 01       	movw	r30, r28
    a5d6:	33 96       	adiw	r30, 0x03	; 3
    a5d8:	85 91       	lpm	r24, Z+
    a5da:	95 91       	lpm	r25, Z+
    a5dc:	a5 91       	lpm	r26, Z+
    a5de:	b4 91       	lpm	r27, Z+
				case Text: case EE_Text:
					if( (prd(&Field->Min) == DIGIT) && (prd(&Field->Max) == DIGIT) )
    a5e0:	00 97       	sbiw	r24, 0x00	; 0
    a5e2:	a1 05       	cpc	r26, r1
    a5e4:	b1 05       	cpc	r27, r1
    a5e6:	59 f4       	brne	.+22     	; 0xa5fe <MenuEscLeft+0x17a>
    a5e8:	fe 01       	movw	r30, r28
    a5ea:	37 96       	adiw	r30, 0x07	; 7
    a5ec:	85 91       	lpm	r24, Z+
    a5ee:	95 91       	lpm	r25, Z+
    a5f0:	a5 91       	lpm	r26, Z+
    a5f2:	b4 91       	lpm	r27, Z+
    a5f4:	00 97       	sbiw	r24, 0x00	; 0
    a5f6:	a1 05       	cpc	r26, r1
    a5f8:	b1 05       	cpc	r27, r1
    a5fa:	09 f4       	brne	.+2      	; 0xa5fe <MenuEscLeft+0x17a>
    a5fc:	6f c0       	rjmp	.+222    	; 0xa6dc <MenuEscLeft+0x258>
						MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[CurrFieldSize - 1 - CurrPos]);
					else MultiSymbol = GetMultiSymbol(Symbols_P, BufStr[CurrFieldSize - 1 - CurrPos]);
    a5fe:	e0 91 7a 07 	lds	r30, 0x077A
    a602:	f0 e0       	ldi	r31, 0x00	; 0
    a604:	31 97       	sbiw	r30, 0x01	; 1
    a606:	e2 1b       	sub	r30, r18
    a608:	f1 09       	sbc	r31, r1
    a60a:	ef 53       	subi	r30, 0x3F	; 63
    a60c:	fa 4f       	sbci	r31, 0xFA	; 250
    a60e:	85 e0       	ldi	r24, 0x05	; 5
    a610:	96 e0       	ldi	r25, 0x06	; 6
    a612:	60 81       	ld	r22, Z
    a614:	0e 94 91 40 	call	0x8122	; 0x8122 <GetMultiSymbol>
    a618:	80 93 f2 04 	sts	0x04F2, r24
    a61c:	3b cf       	rjmp	.-394    	; 0xa494 <MenuEscLeft+0x10>
			if(Type==s_Byte || Type==s_EE_Byte || Type==s_Word || Type==s_EE_Word)
				Pos++;
			if(++CurrPos>Pos)
				CurrPos = NullPos;
			else{
				switch(Type){
    a61e:	19 31       	cpi	r17, 0x19	; 25
    a620:	20 f4       	brcc	.+8      	; 0xa62a <MenuEscLeft+0x1a6>
    a622:	10 51       	subi	r17, 0x10	; 16
    a624:	16 30       	cpi	r17, 0x06	; 6
    a626:	08 f0       	brcs	.+2      	; 0xa62a <MenuEscLeft+0x1a6>
    a628:	35 cf       	rjmp	.-406    	; 0xa494 <MenuEscLeft+0x10>
						MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[CurrFieldSize - 1 - CurrPos]);
					else MultiSymbol = GetMultiSymbol(Symbols_P, BufStr[CurrFieldSize - 1 - CurrPos]);
					break;
				case Longint: case z_Longint: case EE_Longint: case z_EE_Longint: case s_Longint: case s_EE_Longint:
				case FFloat: case EE_FFloat: case GFloat: case EE_GFloat:
					MultiSymbol = GetMultiSymbol(Digits_P, BufStr[CurrFieldSize - 1 - CurrPos]);
    a62a:	e0 91 7a 07 	lds	r30, 0x077A
    a62e:	f0 e0       	ldi	r31, 0x00	; 0
    a630:	31 97       	sbiw	r30, 0x01	; 1
    a632:	e2 1b       	sub	r30, r18
    a634:	f1 09       	sbc	r31, r1
    a636:	ef 53       	subi	r30, 0x3F	; 63
    a638:	fa 4f       	sbci	r31, 0xFA	; 250
    a63a:	8e ea       	ldi	r24, 0xAE	; 174
    a63c:	96 e0       	ldi	r25, 0x06	; 6
    a63e:	60 81       	ld	r22, Z
    a640:	0e 94 91 40 	call	0x8122	; 0x8122 <GetMultiSymbol>
    a644:	80 93 f2 04 	sts	0x04F2, r24
    a648:	25 cf       	rjmp	.-438    	; 0xa494 <MenuEscLeft+0x10>
			Field2Buf(GetField);
		return;
	}

// 3) Go to menu
	EventFunc(&CurrPage->Exit);
    a64a:	80 91 d4 02 	lds	r24, 0x02D4
    a64e:	90 91 d5 02 	lds	r25, 0x02D5
    a652:	0a 96       	adiw	r24, 0x0a	; 10
    a654:	0e 94 28 3c 	call	0x7850	; 0x7850 <EventFunc>
	if(MenuDepth) {
    a658:	e0 91 74 07 	lds	r30, 0x0774
    a65c:	ee 23       	and	r30, r30
    a65e:	21 f1       	breq	.+72     	; 0xa6a8 <MenuEscLeft+0x224>
		CurrPage=MenuStack[--MenuDepth].Page;
    a660:	e1 50       	subi	r30, 0x01	; 1
    a662:	e0 93 74 07 	sts	0x0774, r30
    a666:	f0 e0       	ldi	r31, 0x00	; 0
    a668:	ee 0f       	add	r30, r30
    a66a:	ff 1f       	adc	r31, r31
    a66c:	ee 0f       	add	r30, r30
    a66e:	ff 1f       	adc	r31, r31
    a670:	df 01       	movw	r26, r30
    a672:	af 55       	subi	r26, 0x5F	; 95
    a674:	b7 4f       	sbci	r27, 0xF7	; 247
    a676:	9c 91       	ld	r25, X
    a678:	11 96       	adiw	r26, 0x01	; 1
    a67a:	2c 91       	ld	r18, X
    a67c:	11 97       	sbiw	r26, 0x01	; 1
    a67e:	90 93 d4 02 	sts	0x02D4, r25
    a682:	20 93 d5 02 	sts	0x02D5, r18
		CurrLine=MenuStack[MenuDepth].Line;
    a686:	13 96       	adiw	r26, 0x03	; 3
    a688:	8c 91       	ld	r24, X
    a68a:	80 93 83 07 	sts	0x0783, r24
		CurrLCD=MenuStack[MenuDepth].LCD;
    a68e:	ed 55       	subi	r30, 0x5D	; 93
    a690:	f7 4f       	sbci	r31, 0xF7	; 247
    a692:	80 81       	ld	r24, Z
    a694:	80 93 a0 08 	sts	0x08A0, r24
    a698:	e9 2f       	mov	r30, r25
    a69a:	f2 2f       	mov	r31, r18
    a69c:	9f 01       	movw	r18, r30
		}
		else
			CurrPage=prp(&CurrPage->OutPage);
		CurrLine=CurrLCD=GetFix();
	}
	EventFunc(&CurrPage->Load);
    a69e:	c9 01       	movw	r24, r18
    a6a0:	06 96       	adiw	r24, 0x06	; 6
    a6a2:	0e 94 28 3c 	call	0x7850	; 0x7850 <EventFunc>
    a6a6:	f6 ce       	rjmp	.-532    	; 0xa494 <MenuEscLeft+0x10>
		CurrPage=MenuStack[--MenuDepth].Page;
		CurrLine=MenuStack[MenuDepth].Line;
		CurrLCD=MenuStack[MenuDepth].LCD;
	}
	else {
		if(NextPage) {
    a6a8:	e0 91 d7 05 	lds	r30, 0x05D7
    a6ac:	f0 91 d8 05 	lds	r31, 0x05D8
    a6b0:	30 97       	sbiw	r30, 0x00	; 0
    a6b2:	21 f1       	breq	.+72     	; 0xa6fc <MenuEscLeft+0x278>
			CurrPage=NextPage;
    a6b4:	f0 93 d5 02 	sts	0x02D5, r31
    a6b8:	e0 93 d4 02 	sts	0x02D4, r30
			NextPage=NULL;
    a6bc:	10 92 d8 05 	sts	0x05D8, r1
    a6c0:	10 92 d7 05 	sts	0x05D7, r1
    a6c4:	9f 01       	movw	r18, r30

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    a6c6:	2d 5f       	subi	r18, 0xFD	; 253
    a6c8:	3f 4f       	sbci	r19, 0xFF	; 255
    a6ca:	f9 01       	movw	r30, r18
    a6cc:	84 91       	lpm	r24, Z+
    a6ce:	23 50       	subi	r18, 0x03	; 3
    a6d0:	30 40       	sbci	r19, 0x00	; 0
		}
		else
			CurrPage=prp(&CurrPage->OutPage);
		CurrLine=CurrLCD=GetFix();
    a6d2:	80 93 a0 08 	sts	0x08A0, r24
    a6d6:	80 93 83 07 	sts	0x0783, r24
    a6da:	e1 cf       	rjmp	.-62     	; 0xa69e <MenuEscLeft+0x21a>
				CurrPos = NullPos;
			else{
				switch(Type){
				case Text: case EE_Text:
					if( (prd(&Field->Min) == DIGIT) && (prd(&Field->Max) == DIGIT) )
						MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[CurrFieldSize - 1 - CurrPos]);
    a6dc:	e0 91 7a 07 	lds	r30, 0x077A
    a6e0:	f0 e0       	ldi	r31, 0x00	; 0
    a6e2:	31 97       	sbiw	r30, 0x01	; 1
    a6e4:	e2 1b       	sub	r30, r18
    a6e6:	f1 09       	sbc	r31, r1
    a6e8:	ef 53       	subi	r30, 0x3F	; 63
    a6ea:	fa 4f       	sbci	r31, 0xFA	; 250
    a6ec:	83 ea       	ldi	r24, 0xA3	; 163
    a6ee:	96 e0       	ldi	r25, 0x06	; 6
    a6f0:	60 81       	ld	r22, Z
    a6f2:	0e 94 91 40 	call	0x8122	; 0x8122 <GetMultiSymbol>
    a6f6:	80 93 f2 04 	sts	0x04F2, r24
    a6fa:	cc ce       	rjmp	.-616    	; 0xa494 <MenuEscLeft+0x10>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    a6fc:	80 91 d4 02 	lds	r24, 0x02D4
    a700:	90 91 d5 02 	lds	r25, 0x02D5
    a704:	04 96       	adiw	r24, 0x04	; 4
		if(NextPage) {
			CurrPage=NextPage;
			NextPage=NULL;
		}
		else
			CurrPage=prp(&CurrPage->OutPage);
    a706:	fc 01       	movw	r30, r24
    a708:	25 91       	lpm	r18, Z+
    a70a:	34 91       	lpm	r19, Z+
    a70c:	30 93 d5 02 	sts	0x02D5, r19
    a710:	20 93 d4 02 	sts	0x02D4, r18
    a714:	d8 cf       	rjmp	.-80     	; 0xa6c6 <MenuEscLeft+0x242>

0000a716 <Buf2Field>:
// ~~~~~~~~~~~~~~~~~~~~~~~
//       
//     -
static void
Buf2Field(OutField *Field)
{
    a716:	3f 92       	push	r3
    a718:	4f 92       	push	r4
    a71a:	5f 92       	push	r5
    a71c:	6f 92       	push	r6
    a71e:	7f 92       	push	r7
    a720:	8f 92       	push	r8
    a722:	9f 92       	push	r9
    a724:	af 92       	push	r10
    a726:	bf 92       	push	r11
    a728:	cf 92       	push	r12
    a72a:	df 92       	push	r13
    a72c:	ef 92       	push	r14
    a72e:	ff 92       	push	r15
    a730:	0f 93       	push	r16
    a732:	1f 93       	push	r17
    a734:	df 93       	push	r29
    a736:	cf 93       	push	r28
    a738:	cd b7       	in	r28, 0x3d	; 61
    a73a:	de b7       	in	r29, 0x3e	; 62
    a73c:	6d 97       	sbiw	r28, 0x1d	; 29
    a73e:	0f b6       	in	r0, 0x3f	; 63
    a740:	f8 94       	cli
    a742:	de bf       	out	0x3e, r29	; 62
    a744:	0f be       	out	0x3f, r0	; 63
    a746:	cd bf       	out	0x3d, r28	; 61
    a748:	6c 01       	movw	r12, r24
    a74a:	fc 01       	movw	r30, r24
    a74c:	31 96       	adiw	r30, 0x01	; 1
    a74e:	45 90       	lpm	r4, Z+
    a750:	54 90       	lpm	r5, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    a752:	2f e0       	ldi	r18, 0x0F	; 15
    a754:	30 e0       	ldi	r19, 0x00	; 0
    a756:	c2 0e       	add	r12, r18
    a758:	d3 1e       	adc	r13, r19
    a75a:	f6 01       	movw	r30, r12
    a75c:	24 91       	lpm	r18, Z+
    a75e:	81 ef       	ldi	r24, 0xF1	; 241
    a760:	9f ef       	ldi	r25, 0xFF	; 255
    a762:	c8 0e       	add	r12, r24
    a764:	d9 1e       	adc	r13, r25
	void *Var = prp(&Field->Var);
	uint8_t BitN=prb(&Field->Prec), Mask=1<<BitN%8, *BitVar=(uint8_t*)Var+BitN/8;
    a766:	32 2f       	mov	r19, r18
    a768:	37 70       	andi	r19, 0x07	; 7
    a76a:	81 e0       	ldi	r24, 0x01	; 1
    a76c:	90 e0       	ldi	r25, 0x00	; 0
    a76e:	38 2e       	mov	r3, r24
    a770:	01 c0       	rjmp	.+2      	; 0xa774 <Buf2Field+0x5e>
    a772:	33 0c       	add	r3, r3
    a774:	3a 95       	dec	r19
    a776:	ea f7       	brpl	.-6      	; 0xa772 <Buf2Field+0x5c>
    a778:	26 95       	lsr	r18
    a77a:	26 95       	lsr	r18
    a77c:	26 95       	lsr	r18
    a77e:	32 01       	movw	r6, r4
    a780:	62 0e       	add	r6, r18
    a782:	71 1c       	adc	r7, r1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    a784:	f6 01       	movw	r30, r12
    a786:	33 96       	adiw	r30, 0x03	; 3
    a788:	85 90       	lpm	r8, Z+
    a78a:	95 90       	lpm	r9, Z+
    a78c:	a5 90       	lpm	r10, Z+
    a78e:	b4 90       	lpm	r11, Z+
	uint8_t EE_BitVar;
	uint32_t Min=prd(&Field->Min), Max=prd(&Field->Max);

	uint32_t Temp=0;
    a790:	f6 01       	movw	r30, r12
    a792:	37 96       	adiw	r30, 0x07	; 7
    a794:	e5 90       	lpm	r14, Z+
    a796:	f5 90       	lpm	r15, Z+
    a798:	05 91       	lpm	r16, Z+
    a79a:	14 91       	lpm	r17, Z+
    a79c:	19 82       	std	Y+1, r1	; 0x01
    a79e:	1a 82       	std	Y+2, r1	; 0x02
    a7a0:	1b 82       	std	Y+3, r1	; 0x03
    a7a2:	1c 82       	std	Y+4, r1	; 0x04
	float fTemp=0;
    a7a4:	80 e0       	ldi	r24, 0x00	; 0
    a7a6:	90 e0       	ldi	r25, 0x00	; 0
    a7a8:	a0 e0       	ldi	r26, 0x00	; 0
    a7aa:	b0 e0       	ldi	r27, 0x00	; 0
    a7ac:	8d 83       	std	Y+5, r24	; 0x05
    a7ae:	9e 83       	std	Y+6, r25	; 0x06
    a7b0:	af 83       	std	Y+7, r26	; 0x07
    a7b2:	b8 87       	std	Y+8, r27	; 0x08

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    a7b4:	f6 01       	movw	r30, r12
    a7b6:	84 91       	lpm	r24, Z+

	switch(prb(&Field->Type)) {
    a7b8:	e8 2f       	mov	r30, r24
    a7ba:	f0 e0       	ldi	r31, 0x00	; 0
    a7bc:	e3 32       	cpi	r30, 0x23	; 35
    a7be:	f1 05       	cpc	r31, r1
    a7c0:	08 f0       	brcs	.+2      	; 0xa7c4 <Buf2Field+0xae>
    a7c2:	3f c0       	rjmp	.+126    	; 0xa842 <Buf2Field+0x12c>
    a7c4:	ed 56       	subi	r30, 0x6D	; 109
    a7c6:	ff 4f       	sbci	r31, 0xFF	; 255
    a7c8:	ee 0f       	add	r30, r30
    a7ca:	ff 1f       	adc	r31, r31
    a7cc:	05 90       	lpm	r0, Z+
    a7ce:	f4 91       	lpm	r31, Z+
    a7d0:	e0 2d       	mov	r30, r0
    a7d2:	19 94       	eijmp
		PresicionHanler(Field);
		sscanf(BufStr,"%lud", (uint32_t*)&Temp);
		SetField32(Temp, uint32_t);
		break;
	case EE_Longint: case z_EE_Longint:
		PresicionHanler(Field);
    a7d4:	c6 01       	movw	r24, r12
    a7d6:	0e 94 57 40 	call	0x80ae	; 0x80ae <PresicionHanler>
		if(sscanf(BufStr,"%lud", (uint32_t*)&Temp) == 1){
    a7da:	00 d0       	rcall	.+0      	; 0xa7dc <Buf2Field+0xc6>
    a7dc:	00 d0       	rcall	.+0      	; 0xa7de <Buf2Field+0xc8>
    a7de:	ed b7       	in	r30, 0x3d	; 61
    a7e0:	fe b7       	in	r31, 0x3e	; 62
    a7e2:	31 96       	adiw	r30, 0x01	; 1
    a7e4:	81 ec       	ldi	r24, 0xC1	; 193
    a7e6:	95 e0       	ldi	r25, 0x05	; 5
    a7e8:	ad b7       	in	r26, 0x3d	; 61
    a7ea:	be b7       	in	r27, 0x3e	; 62
    a7ec:	12 96       	adiw	r26, 0x02	; 2
    a7ee:	9c 93       	st	X, r25
    a7f0:	8e 93       	st	-X, r24
    a7f2:	11 97       	sbiw	r26, 0x01	; 1
    a7f4:	8f e9       	ldi	r24, 0x9F	; 159
    a7f6:	92 e0       	ldi	r25, 0x02	; 2
    a7f8:	93 83       	std	Z+3, r25	; 0x03
    a7fa:	82 83       	std	Z+2, r24	; 0x02
    a7fc:	ce 01       	movw	r24, r28
    a7fe:	01 96       	adiw	r24, 0x01	; 1
    a800:	95 83       	std	Z+5, r25	; 0x05
    a802:	84 83       	std	Z+4, r24	; 0x04
    a804:	0e 94 0f 80 	call	0x1001e	; 0x1001e <sscanf>
    a808:	ed b7       	in	r30, 0x3d	; 61
    a80a:	fe b7       	in	r31, 0x3e	; 62
    a80c:	36 96       	adiw	r30, 0x06	; 6
    a80e:	0f b6       	in	r0, 0x3f	; 63
    a810:	f8 94       	cli
    a812:	fe bf       	out	0x3e, r31	; 62
    a814:	0f be       	out	0x3f, r0	; 63
    a816:	ed bf       	out	0x3d, r30	; 61
    a818:	01 97       	sbiw	r24, 0x01	; 1
    a81a:	99 f4       	brne	.+38     	; 0xa842 <Buf2Field+0x12c>
			SetEEField32(Temp, uint32_t, uint32_t, d);
    a81c:	49 81       	ldd	r20, Y+1	; 0x01
    a81e:	5a 81       	ldd	r21, Y+2	; 0x02
    a820:	6b 81       	ldd	r22, Y+3	; 0x03
    a822:	7c 81       	ldd	r23, Y+4	; 0x04
    a824:	e4 16       	cp	r14, r20
    a826:	f5 06       	cpc	r15, r21
    a828:	06 07       	cpc	r16, r22
    a82a:	17 07       	cpc	r17, r23
    a82c:	08 f4       	brcc	.+2      	; 0xa830 <Buf2Field+0x11a>
    a82e:	cc c2       	rjmp	.+1432   	; 0xadc8 <Buf2Field+0x6b2>
    a830:	48 15       	cp	r20, r8
    a832:	59 05       	cpc	r21, r9
    a834:	6a 05       	cpc	r22, r10
    a836:	7b 05       	cpc	r23, r11
    a838:	08 f4       	brcc	.+2      	; 0xa83c <Buf2Field+0x126>
    a83a:	f8 c1       	rjmp	.+1008   	; 0xac2c <Buf2Field+0x516>
		SetField32(Temp, int32_t);
		break;
	case s_EE_Longint:
		PresicionHanler(Field);
		if(sscanf(BufStr,"%ld", (int32_t*)&Temp) == 1){
			SetEEField32(Temp, int32_t, uint32_t, d);
    a83c:	c2 01       	movw	r24, r4
    a83e:	0e 94 4d 4d 	call	0x9a9a	; 0x9a9a <ewd>
			ewbl(TempStr, Var, Width);
		}
		break;

	}
	EventFunc(&Field->Act);
    a842:	c6 01       	movw	r24, r12
    a844:	0b 96       	adiw	r24, 0x0b	; 11
    a846:	0e 94 28 3c 	call	0x7850	; 0x7850 <EventFunc>
}
    a84a:	6d 96       	adiw	r28, 0x1d	; 29
    a84c:	0f b6       	in	r0, 0x3f	; 63
    a84e:	f8 94       	cli
    a850:	de bf       	out	0x3e, r29	; 62
    a852:	0f be       	out	0x3f, r0	; 63
    a854:	cd bf       	out	0x3d, r28	; 61
    a856:	cf 91       	pop	r28
    a858:	df 91       	pop	r29
    a85a:	1f 91       	pop	r17
    a85c:	0f 91       	pop	r16
    a85e:	ff 90       	pop	r15
    a860:	ef 90       	pop	r14
    a862:	df 90       	pop	r13
    a864:	cf 90       	pop	r12
    a866:	bf 90       	pop	r11
    a868:	af 90       	pop	r10
    a86a:	9f 90       	pop	r9
    a86c:	8f 90       	pop	r8
    a86e:	7f 90       	pop	r7
    a870:	6f 90       	pop	r6
    a872:	5f 90       	pop	r5
    a874:	4f 90       	pop	r4
    a876:	3f 90       	pop	r3
    a878:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    a87a:	8e 01       	movw	r16, r28
    a87c:	07 5f       	subi	r16, 0xF7	; 247
    a87e:	1f 4f       	sbci	r17, 0xFF	; 255
    a880:	c8 01       	movw	r24, r16
    a882:	b2 01       	movw	r22, r4
    a884:	45 e1       	ldi	r20, 0x15	; 21
    a886:	50 e0       	ldi	r21, 0x00	; 0
    a888:	0e 94 cb 81 	call	0x10396	; 0x10396 <__eerd_block_m2560>
		}
		break;
	case EE_Text:{
			char TempStr[LCDXSz+1];
			erbl(TempStr, Var, LCDXSz+1);
			uint8_t Width = strlen(TempStr);
    a88c:	d8 01       	movw	r26, r16
    a88e:	0d 90       	ld	r0, X+
    a890:	00 20       	and	r0, r0
    a892:	e9 f7       	brne	.-6      	; 0xa88e <Buf2Field+0x178>
    a894:	7d 01       	movw	r14, r26
    a896:	08 94       	sec
    a898:	e1 08       	sbc	r14, r1
    a89a:	f1 08       	sbc	r15, r1
    a89c:	e0 1a       	sub	r14, r16
    a89e:	f1 0a       	sbc	r15, r17
			memcpy(TempStr, BufStr, Width);
    a8a0:	21 ec       	ldi	r18, 0xC1	; 193
    a8a2:	35 e0       	ldi	r19, 0x05	; 5
    a8a4:	c8 01       	movw	r24, r16
    a8a6:	b9 01       	movw	r22, r18
    a8a8:	4e 2d       	mov	r20, r14
    a8aa:	50 e0       	ldi	r21, 0x00	; 0
    a8ac:	0e 94 fd 7e 	call	0xfdfa	; 0xfdfa <memcpy>
			ewbl(TempStr, Var, Width);
    a8b0:	c8 01       	movw	r24, r16
    a8b2:	b2 01       	movw	r22, r4
    a8b4:	4e 2d       	mov	r20, r14
    a8b6:	50 e0       	ldi	r21, 0x00	; 0
    a8b8:	0e 94 48 4d 	call	0x9a90	; 0x9a90 <ewbl>
    a8bc:	c2 cf       	rjmp	.-124    	; 0xa842 <Buf2Field+0x12c>
	uint32_t Temp=0;
	float fTemp=0;

	switch(prb(&Field->Type)) {
	case Byte: case z_Byte: case Enum:
		SetField(F_Buf, uint8_t);
    a8be:	20 91 f5 04 	lds	r18, 0x04F5
    a8c2:	30 91 f6 04 	lds	r19, 0x04F6
    a8c6:	40 91 f7 04 	lds	r20, 0x04F7
    a8ca:	50 91 f8 04 	lds	r21, 0x04F8
    a8ce:	8e 2d       	mov	r24, r14
    a8d0:	90 e0       	ldi	r25, 0x00	; 0
    a8d2:	a0 e0       	ldi	r26, 0x00	; 0
    a8d4:	b0 e0       	ldi	r27, 0x00	; 0
    a8d6:	82 17       	cp	r24, r18
    a8d8:	93 07       	cpc	r25, r19
    a8da:	a4 07       	cpc	r26, r20
    a8dc:	b5 07       	cpc	r27, r21
    a8de:	08 f4       	brcc	.+2      	; 0xa8e2 <Buf2Field+0x1cc>
    a8e0:	50 c2       	rjmp	.+1184   	; 0xad82 <Buf2Field+0x66c>
    a8e2:	88 2d       	mov	r24, r8
    a8e4:	90 e0       	ldi	r25, 0x00	; 0
    a8e6:	a0 e0       	ldi	r26, 0x00	; 0
    a8e8:	b0 e0       	ldi	r27, 0x00	; 0
    a8ea:	28 17       	cp	r18, r24
    a8ec:	39 07       	cpc	r19, r25
    a8ee:	4a 07       	cpc	r20, r26
    a8f0:	5b 07       	cpc	r21, r27
    a8f2:	08 f0       	brcs	.+2      	; 0xa8f6 <Buf2Field+0x1e0>
    a8f4:	66 c2       	rjmp	.+1228   	; 0xadc2 <Buf2Field+0x6ac>
    a8f6:	f2 01       	movw	r30, r4
    a8f8:	80 82       	st	Z, r8
    a8fa:	a3 cf       	rjmp	.-186    	; 0xa842 <Buf2Field+0x12c>
		break;
	case s_Byte:
		SetField(sF_Buf, int8_t);
		break;
	case EE_Byte: case z_EE_Byte: case EE_Enum:
		SetEEField(F_Buf, uint8_t, uint8_t, b);
    a8fc:	20 91 f5 04 	lds	r18, 0x04F5
    a900:	30 91 f6 04 	lds	r19, 0x04F6
    a904:	40 91 f7 04 	lds	r20, 0x04F7
    a908:	50 91 f8 04 	lds	r21, 0x04F8
    a90c:	8e 2d       	mov	r24, r14
    a90e:	90 e0       	ldi	r25, 0x00	; 0
    a910:	a0 e0       	ldi	r26, 0x00	; 0
    a912:	b0 e0       	ldi	r27, 0x00	; 0
    a914:	82 17       	cp	r24, r18
    a916:	93 07       	cpc	r25, r19
    a918:	a4 07       	cpc	r26, r20
    a91a:	b5 07       	cpc	r27, r21
    a91c:	08 f4       	brcc	.+2      	; 0xa920 <Buf2Field+0x20a>
    a91e:	41 c2       	rjmp	.+1154   	; 0xada2 <Buf2Field+0x68c>
    a920:	88 2d       	mov	r24, r8
    a922:	90 e0       	ldi	r25, 0x00	; 0
    a924:	a0 e0       	ldi	r26, 0x00	; 0
    a926:	b0 e0       	ldi	r27, 0x00	; 0
    a928:	28 17       	cp	r18, r24
    a92a:	39 07       	cpc	r19, r25
    a92c:	4a 07       	cpc	r20, r26
    a92e:	5b 07       	cpc	r21, r27
    a930:	08 f4       	brcc	.+2      	; 0xa934 <Buf2Field+0x21e>
    a932:	48 c0       	rjmp	.+144    	; 0xa9c4 <Buf2Field+0x2ae>
		break;
	case s_EE_Byte:
		SetEEField(sF_Buf, int8_t, uint8_t, b);
    a934:	c2 01       	movw	r24, r4
    a936:	62 2f       	mov	r22, r18
    a938:	0e 94 d3 4b 	call	0x97a6	; 0x97a6 <ewb>
    a93c:	82 cf       	rjmp	.-252    	; 0xa842 <Buf2Field+0x12c>
	switch(prb(&Field->Type)) {
	case Byte: case z_Byte: case Enum:
		SetField(F_Buf, uint8_t);
		break;
	case s_Byte:
		SetField(sF_Buf, int8_t);
    a93e:	20 91 f9 04 	lds	r18, 0x04F9
    a942:	30 91 fa 04 	lds	r19, 0x04FA
    a946:	40 91 fb 04 	lds	r20, 0x04FB
    a94a:	50 91 fc 04 	lds	r21, 0x04FC
    a94e:	8e 2d       	mov	r24, r14
    a950:	99 27       	eor	r25, r25
    a952:	87 fd       	sbrc	r24, 7
    a954:	90 95       	com	r25
    a956:	a9 2f       	mov	r26, r25
    a958:	b9 2f       	mov	r27, r25
    a95a:	82 17       	cp	r24, r18
    a95c:	93 07       	cpc	r25, r19
    a95e:	a4 07       	cpc	r26, r20
    a960:	b5 07       	cpc	r27, r21
    a962:	0c f4       	brge	.+2      	; 0xa966 <Buf2Field+0x250>
    a964:	08 c2       	rjmp	.+1040   	; 0xad76 <Buf2Field+0x660>
    a966:	88 2d       	mov	r24, r8
    a968:	99 27       	eor	r25, r25
    a96a:	87 fd       	sbrc	r24, 7
    a96c:	90 95       	com	r25
    a96e:	a9 2f       	mov	r26, r25
    a970:	b9 2f       	mov	r27, r25
    a972:	28 17       	cp	r18, r24
    a974:	39 07       	cpc	r19, r25
    a976:	4a 07       	cpc	r20, r26
    a978:	5b 07       	cpc	r21, r27
    a97a:	0c f0       	brlt	.+2      	; 0xa97e <Buf2Field+0x268>
    a97c:	17 c2       	rjmp	.+1070   	; 0xadac <Buf2Field+0x696>
    a97e:	d2 01       	movw	r26, r4
    a980:	8c 92       	st	X, r8
    a982:	5f cf       	rjmp	.-322    	; 0xa842 <Buf2Field+0x12c>
		break;
	case EE_Byte: case z_EE_Byte: case EE_Enum:
		SetEEField(F_Buf, uint8_t, uint8_t, b);
		break;
	case s_EE_Byte:
		SetEEField(sF_Buf, int8_t, uint8_t, b);
    a984:	20 91 f9 04 	lds	r18, 0x04F9
    a988:	30 91 fa 04 	lds	r19, 0x04FA
    a98c:	40 91 fb 04 	lds	r20, 0x04FB
    a990:	50 91 fc 04 	lds	r21, 0x04FC
    a994:	8e 2d       	mov	r24, r14
    a996:	99 27       	eor	r25, r25
    a998:	87 fd       	sbrc	r24, 7
    a99a:	90 95       	com	r25
    a99c:	a9 2f       	mov	r26, r25
    a99e:	b9 2f       	mov	r27, r25
    a9a0:	82 17       	cp	r24, r18
    a9a2:	93 07       	cpc	r25, r19
    a9a4:	a4 07       	cpc	r26, r20
    a9a6:	b5 07       	cpc	r27, r21
    a9a8:	0c f4       	brge	.+2      	; 0xa9ac <Buf2Field+0x296>
    a9aa:	fb c1       	rjmp	.+1014   	; 0xada2 <Buf2Field+0x68c>
    a9ac:	88 2d       	mov	r24, r8
    a9ae:	99 27       	eor	r25, r25
    a9b0:	87 fd       	sbrc	r24, 7
    a9b2:	90 95       	com	r25
    a9b4:	a9 2f       	mov	r26, r25
    a9b6:	b9 2f       	mov	r27, r25
    a9b8:	28 17       	cp	r18, r24
    a9ba:	39 07       	cpc	r19, r25
    a9bc:	4a 07       	cpc	r20, r26
    a9be:	5b 07       	cpc	r21, r27
    a9c0:	0c f0       	brlt	.+2      	; 0xa9c4 <Buf2Field+0x2ae>
    a9c2:	b8 cf       	rjmp	.-144    	; 0xa934 <Buf2Field+0x21e>
    a9c4:	c2 01       	movw	r24, r4
    a9c6:	68 2d       	mov	r22, r8
    a9c8:	0e 94 d3 4b 	call	0x97a6	; 0x97a6 <ewb>
    a9cc:	3a cf       	rjmp	.-396    	; 0xa842 <Buf2Field+0x12c>
		break;
	case Word: case z_Word:
		SetField(F_Buf, uint16_t);
    a9ce:	20 91 f5 04 	lds	r18, 0x04F5
    a9d2:	30 91 f6 04 	lds	r19, 0x04F6
    a9d6:	40 91 f7 04 	lds	r20, 0x04F7
    a9da:	50 91 f8 04 	lds	r21, 0x04F8
    a9de:	c7 01       	movw	r24, r14
    a9e0:	a0 e0       	ldi	r26, 0x00	; 0
    a9e2:	b0 e0       	ldi	r27, 0x00	; 0
    a9e4:	82 17       	cp	r24, r18
    a9e6:	93 07       	cpc	r25, r19
    a9e8:	a4 07       	cpc	r26, r20
    a9ea:	b5 07       	cpc	r27, r21
    a9ec:	08 f4       	brcc	.+2      	; 0xa9f0 <Buf2Field+0x2da>
    a9ee:	cc c1       	rjmp	.+920    	; 0xad88 <Buf2Field+0x672>
    a9f0:	c4 01       	movw	r24, r8
    a9f2:	a0 e0       	ldi	r26, 0x00	; 0
    a9f4:	b0 e0       	ldi	r27, 0x00	; 0
    a9f6:	28 17       	cp	r18, r24
    a9f8:	39 07       	cpc	r19, r25
    a9fa:	4a 07       	cpc	r20, r26
    a9fc:	5b 07       	cpc	r21, r27
    a9fe:	08 f0       	brcs	.+2      	; 0xaa02 <Buf2Field+0x2ec>
    aa00:	d8 c1       	rjmp	.+944    	; 0xadb2 <Buf2Field+0x69c>
    aa02:	f2 01       	movw	r30, r4
    aa04:	91 82       	std	Z+1, r9	; 0x01
    aa06:	80 82       	st	Z, r8
    aa08:	1c cf       	rjmp	.-456    	; 0xa842 <Buf2Field+0x12c>
		break;
	case EE_Word: case z_EE_Word:
		SetEEField(F_Buf, uint16_t, uint16_t, w);
    aa0a:	20 91 f5 04 	lds	r18, 0x04F5
    aa0e:	30 91 f6 04 	lds	r19, 0x04F6
    aa12:	40 91 f7 04 	lds	r20, 0x04F7
    aa16:	50 91 f8 04 	lds	r21, 0x04F8
    aa1a:	c7 01       	movw	r24, r14
    aa1c:	a0 e0       	ldi	r26, 0x00	; 0
    aa1e:	b0 e0       	ldi	r27, 0x00	; 0
    aa20:	82 17       	cp	r24, r18
    aa22:	93 07       	cpc	r25, r19
    aa24:	a4 07       	cpc	r26, r20
    aa26:	b5 07       	cpc	r27, r21
    aa28:	08 f4       	brcc	.+2      	; 0xaa2c <Buf2Field+0x316>
    aa2a:	b6 c1       	rjmp	.+876    	; 0xad98 <Buf2Field+0x682>
    aa2c:	c4 01       	movw	r24, r8
    aa2e:	a0 e0       	ldi	r26, 0x00	; 0
    aa30:	b0 e0       	ldi	r27, 0x00	; 0
    aa32:	28 17       	cp	r18, r24
    aa34:	39 07       	cpc	r19, r25
    aa36:	4a 07       	cpc	r20, r26
    aa38:	5b 07       	cpc	r21, r27
    aa3a:	08 f4       	brcc	.+2      	; 0xaa3e <Buf2Field+0x328>
    aa3c:	45 c0       	rjmp	.+138    	; 0xaac8 <Buf2Field+0x3b2>
		break;
	case s_Word:
		SetField(sF_Buf, int16_t);
		break;
	case s_EE_Word:
		SetEEField(sF_Buf, int16_t, uint16_t, w);
    aa3e:	c2 01       	movw	r24, r4
    aa40:	b9 01       	movw	r22, r18
    aa42:	0e 94 16 4c 	call	0x982c	; 0x982c <eww>
    aa46:	fd ce       	rjmp	.-518    	; 0xa842 <Buf2Field+0x12c>
		break;
	case EE_Word: case z_EE_Word:
		SetEEField(F_Buf, uint16_t, uint16_t, w);
		break;
	case s_Word:
		SetField(sF_Buf, int16_t);
    aa48:	20 91 f9 04 	lds	r18, 0x04F9
    aa4c:	30 91 fa 04 	lds	r19, 0x04FA
    aa50:	40 91 fb 04 	lds	r20, 0x04FB
    aa54:	50 91 fc 04 	lds	r21, 0x04FC
    aa58:	c7 01       	movw	r24, r14
    aa5a:	aa 27       	eor	r26, r26
    aa5c:	97 fd       	sbrc	r25, 7
    aa5e:	a0 95       	com	r26
    aa60:	ba 2f       	mov	r27, r26
    aa62:	82 17       	cp	r24, r18
    aa64:	93 07       	cpc	r25, r19
    aa66:	a4 07       	cpc	r26, r20
    aa68:	b5 07       	cpc	r27, r21
    aa6a:	0c f4       	brge	.+2      	; 0xaa6e <Buf2Field+0x358>
    aa6c:	91 c1       	rjmp	.+802    	; 0xad90 <Buf2Field+0x67a>
    aa6e:	c4 01       	movw	r24, r8
    aa70:	aa 27       	eor	r26, r26
    aa72:	97 fd       	sbrc	r25, 7
    aa74:	a0 95       	com	r26
    aa76:	ba 2f       	mov	r27, r26
    aa78:	28 17       	cp	r18, r24
    aa7a:	39 07       	cpc	r19, r25
    aa7c:	4a 07       	cpc	r20, r26
    aa7e:	5b 07       	cpc	r21, r27
    aa80:	0c f0       	brlt	.+2      	; 0xaa84 <Buf2Field+0x36e>
    aa82:	9b c1       	rjmp	.+822    	; 0xadba <Buf2Field+0x6a4>
    aa84:	d2 01       	movw	r26, r4
    aa86:	8d 92       	st	X+, r8
    aa88:	9c 92       	st	X, r9
    aa8a:	db ce       	rjmp	.-586    	; 0xa842 <Buf2Field+0x12c>
		break;
	case s_EE_Word:
		SetEEField(sF_Buf, int16_t, uint16_t, w);
    aa8c:	20 91 f9 04 	lds	r18, 0x04F9
    aa90:	30 91 fa 04 	lds	r19, 0x04FA
    aa94:	40 91 fb 04 	lds	r20, 0x04FB
    aa98:	50 91 fc 04 	lds	r21, 0x04FC
    aa9c:	c7 01       	movw	r24, r14
    aa9e:	aa 27       	eor	r26, r26
    aaa0:	97 fd       	sbrc	r25, 7
    aaa2:	a0 95       	com	r26
    aaa4:	ba 2f       	mov	r27, r26
    aaa6:	82 17       	cp	r24, r18
    aaa8:	93 07       	cpc	r25, r19
    aaaa:	a4 07       	cpc	r26, r20
    aaac:	b5 07       	cpc	r27, r21
    aaae:	0c f4       	brge	.+2      	; 0xaab2 <Buf2Field+0x39c>
    aab0:	73 c1       	rjmp	.+742    	; 0xad98 <Buf2Field+0x682>
    aab2:	c4 01       	movw	r24, r8
    aab4:	aa 27       	eor	r26, r26
    aab6:	97 fd       	sbrc	r25, 7
    aab8:	a0 95       	com	r26
    aaba:	ba 2f       	mov	r27, r26
    aabc:	28 17       	cp	r18, r24
    aabe:	39 07       	cpc	r19, r25
    aac0:	4a 07       	cpc	r20, r26
    aac2:	5b 07       	cpc	r21, r27
    aac4:	0c f0       	brlt	.+2      	; 0xaac8 <Buf2Field+0x3b2>
    aac6:	bb cf       	rjmp	.-138    	; 0xaa3e <Buf2Field+0x328>
    aac8:	c2 01       	movw	r24, r4
    aaca:	b4 01       	movw	r22, r8
    aacc:	0e 94 16 4c 	call	0x982c	; 0x982c <eww>
    aad0:	b8 ce       	rjmp	.-656    	; 0xa842 <Buf2Field+0x12c>
		break;
	case c_Word: case zc_Word:
		*(uint16_t*)Var = F_Buf;
    aad2:	80 91 f5 04 	lds	r24, 0x04F5
    aad6:	90 91 f6 04 	lds	r25, 0x04F6
    aada:	d2 01       	movw	r26, r4
    aadc:	8d 93       	st	X+, r24
    aade:	9c 93       	st	X, r25
    aae0:	b0 ce       	rjmp	.-672    	; 0xa842 <Buf2Field+0x12c>
		break;


	case Longint: case z_Longint:
		//if(Limit_uByteVar(Temp)) sscanf(BufStr,"%ud", (unsigned short int*)&Temp);
		PresicionHanler(Field);
    aae2:	c6 01       	movw	r24, r12
    aae4:	0e 94 57 40 	call	0x80ae	; 0x80ae <PresicionHanler>
		sscanf(BufStr,"%lud", (uint32_t*)&Temp);
    aae8:	00 d0       	rcall	.+0      	; 0xaaea <Buf2Field+0x3d4>
    aaea:	00 d0       	rcall	.+0      	; 0xaaec <Buf2Field+0x3d6>
    aaec:	ed b7       	in	r30, 0x3d	; 61
    aaee:	fe b7       	in	r31, 0x3e	; 62
    aaf0:	31 96       	adiw	r30, 0x01	; 1
    aaf2:	81 ec       	ldi	r24, 0xC1	; 193
    aaf4:	95 e0       	ldi	r25, 0x05	; 5
    aaf6:	ad b7       	in	r26, 0x3d	; 61
    aaf8:	be b7       	in	r27, 0x3e	; 62
    aafa:	12 96       	adiw	r26, 0x02	; 2
    aafc:	9c 93       	st	X, r25
    aafe:	8e 93       	st	-X, r24
    ab00:	11 97       	sbiw	r26, 0x01	; 1
    ab02:	8f e9       	ldi	r24, 0x9F	; 159
    ab04:	92 e0       	ldi	r25, 0x02	; 2
    ab06:	93 83       	std	Z+3, r25	; 0x03
    ab08:	82 83       	std	Z+2, r24	; 0x02
    ab0a:	ce 01       	movw	r24, r28
    ab0c:	01 96       	adiw	r24, 0x01	; 1
    ab0e:	95 83       	std	Z+5, r25	; 0x05
    ab10:	84 83       	std	Z+4, r24	; 0x04
    ab12:	0e 94 0f 80 	call	0x1001e	; 0x1001e <sscanf>
		SetField32(Temp, uint32_t);
    ab16:	89 81       	ldd	r24, Y+1	; 0x01
    ab18:	9a 81       	ldd	r25, Y+2	; 0x02
    ab1a:	ab 81       	ldd	r26, Y+3	; 0x03
    ab1c:	bc 81       	ldd	r27, Y+4	; 0x04
    ab1e:	ed b7       	in	r30, 0x3d	; 61
    ab20:	fe b7       	in	r31, 0x3e	; 62
    ab22:	36 96       	adiw	r30, 0x06	; 6
    ab24:	0f b6       	in	r0, 0x3f	; 63
    ab26:	f8 94       	cli
    ab28:	fe bf       	out	0x3e, r31	; 62
    ab2a:	0f be       	out	0x3f, r0	; 63
    ab2c:	ed bf       	out	0x3d, r30	; 61
    ab2e:	e8 16       	cp	r14, r24
    ab30:	f9 06       	cpc	r15, r25
    ab32:	0a 07       	cpc	r16, r26
    ab34:	1b 07       	cpc	r17, r27
    ab36:	08 f4       	brcc	.+2      	; 0xab3a <Buf2Field+0x424>
    ab38:	17 c1       	rjmp	.+558    	; 0xad68 <Buf2Field+0x652>
    ab3a:	88 15       	cp	r24, r8
    ab3c:	99 05       	cpc	r25, r9
    ab3e:	aa 05       	cpc	r26, r10
    ab40:	bb 05       	cpc	r27, r11
    ab42:	b8 f1       	brcs	.+110    	; 0xabb2 <Buf2Field+0x49c>
		break;
	case s_Longint:
		PresicionHanler(Field);
		//if(Limit_sByteVar(Temp)) sscanf(BufStr,"%hd", (short int*)&Temp);
		sscanf(BufStr,"%ld", (int32_t*)&Temp);
		SetField32(Temp, int32_t);
    ab44:	f2 01       	movw	r30, r4
    ab46:	80 83       	st	Z, r24
    ab48:	91 83       	std	Z+1, r25	; 0x01
    ab4a:	a2 83       	std	Z+2, r26	; 0x02
    ab4c:	b3 83       	std	Z+3, r27	; 0x03
    ab4e:	79 ce       	rjmp	.-782    	; 0xa842 <Buf2Field+0x12c>
		if(sscanf(BufStr,"%lud", (uint32_t*)&Temp) == 1){
			SetEEField32(Temp, uint32_t, uint32_t, d);
		}		
		break;
	case s_Longint:
		PresicionHanler(Field);
    ab50:	c6 01       	movw	r24, r12
    ab52:	0e 94 57 40 	call	0x80ae	; 0x80ae <PresicionHanler>
		//if(Limit_sByteVar(Temp)) sscanf(BufStr,"%hd", (short int*)&Temp);
		sscanf(BufStr,"%ld", (int32_t*)&Temp);
    ab56:	00 d0       	rcall	.+0      	; 0xab58 <Buf2Field+0x442>
    ab58:	00 d0       	rcall	.+0      	; 0xab5a <Buf2Field+0x444>
    ab5a:	ed b7       	in	r30, 0x3d	; 61
    ab5c:	fe b7       	in	r31, 0x3e	; 62
    ab5e:	31 96       	adiw	r30, 0x01	; 1
    ab60:	81 ec       	ldi	r24, 0xC1	; 193
    ab62:	95 e0       	ldi	r25, 0x05	; 5
    ab64:	ad b7       	in	r26, 0x3d	; 61
    ab66:	be b7       	in	r27, 0x3e	; 62
    ab68:	12 96       	adiw	r26, 0x02	; 2
    ab6a:	9c 93       	st	X, r25
    ab6c:	8e 93       	st	-X, r24
    ab6e:	11 97       	sbiw	r26, 0x01	; 1
    ab70:	84 ea       	ldi	r24, 0xA4	; 164
    ab72:	92 e0       	ldi	r25, 0x02	; 2
    ab74:	93 83       	std	Z+3, r25	; 0x03
    ab76:	82 83       	std	Z+2, r24	; 0x02
    ab78:	ce 01       	movw	r24, r28
    ab7a:	01 96       	adiw	r24, 0x01	; 1
    ab7c:	95 83       	std	Z+5, r25	; 0x05
    ab7e:	84 83       	std	Z+4, r24	; 0x04
    ab80:	0e 94 0f 80 	call	0x1001e	; 0x1001e <sscanf>
		SetField32(Temp, int32_t);
    ab84:	89 81       	ldd	r24, Y+1	; 0x01
    ab86:	9a 81       	ldd	r25, Y+2	; 0x02
    ab88:	ab 81       	ldd	r26, Y+3	; 0x03
    ab8a:	bc 81       	ldd	r27, Y+4	; 0x04
    ab8c:	ed b7       	in	r30, 0x3d	; 61
    ab8e:	fe b7       	in	r31, 0x3e	; 62
    ab90:	36 96       	adiw	r30, 0x06	; 6
    ab92:	0f b6       	in	r0, 0x3f	; 63
    ab94:	f8 94       	cli
    ab96:	fe bf       	out	0x3e, r31	; 62
    ab98:	0f be       	out	0x3f, r0	; 63
    ab9a:	ed bf       	out	0x3d, r30	; 61
    ab9c:	e8 16       	cp	r14, r24
    ab9e:	f9 06       	cpc	r15, r25
    aba0:	0a 07       	cpc	r16, r26
    aba2:	1b 07       	cpc	r17, r27
    aba4:	0c f4       	brge	.+2      	; 0xaba8 <Buf2Field+0x492>
    aba6:	e0 c0       	rjmp	.+448    	; 0xad68 <Buf2Field+0x652>
    aba8:	88 15       	cp	r24, r8
    abaa:	99 05       	cpc	r25, r9
    abac:	aa 05       	cpc	r26, r10
    abae:	bb 05       	cpc	r27, r11
    abb0:	4c f6       	brge	.-110    	; 0xab44 <Buf2Field+0x42e>
    abb2:	f2 01       	movw	r30, r4
    abb4:	80 82       	st	Z, r8
    abb6:	91 82       	std	Z+1, r9	; 0x01
    abb8:	a2 82       	std	Z+2, r10	; 0x02
    abba:	b3 82       	std	Z+3, r11	; 0x03
    abbc:	42 ce       	rjmp	.-892    	; 0xa842 <Buf2Field+0x12c>
		break;
	case s_EE_Longint:
		PresicionHanler(Field);
    abbe:	c6 01       	movw	r24, r12
    abc0:	0e 94 57 40 	call	0x80ae	; 0x80ae <PresicionHanler>
		if(sscanf(BufStr,"%ld", (int32_t*)&Temp) == 1){
    abc4:	00 d0       	rcall	.+0      	; 0xabc6 <Buf2Field+0x4b0>
    abc6:	00 d0       	rcall	.+0      	; 0xabc8 <Buf2Field+0x4b2>
    abc8:	ed b7       	in	r30, 0x3d	; 61
    abca:	fe b7       	in	r31, 0x3e	; 62
    abcc:	31 96       	adiw	r30, 0x01	; 1
    abce:	81 ec       	ldi	r24, 0xC1	; 193
    abd0:	95 e0       	ldi	r25, 0x05	; 5
    abd2:	ad b7       	in	r26, 0x3d	; 61
    abd4:	be b7       	in	r27, 0x3e	; 62
    abd6:	12 96       	adiw	r26, 0x02	; 2
    abd8:	9c 93       	st	X, r25
    abda:	8e 93       	st	-X, r24
    abdc:	11 97       	sbiw	r26, 0x01	; 1
    abde:	84 ea       	ldi	r24, 0xA4	; 164
    abe0:	92 e0       	ldi	r25, 0x02	; 2
    abe2:	93 83       	std	Z+3, r25	; 0x03
    abe4:	82 83       	std	Z+2, r24	; 0x02
    abe6:	ce 01       	movw	r24, r28
    abe8:	01 96       	adiw	r24, 0x01	; 1
    abea:	95 83       	std	Z+5, r25	; 0x05
    abec:	84 83       	std	Z+4, r24	; 0x04
    abee:	0e 94 0f 80 	call	0x1001e	; 0x1001e <sscanf>
    abf2:	ed b7       	in	r30, 0x3d	; 61
    abf4:	fe b7       	in	r31, 0x3e	; 62
    abf6:	36 96       	adiw	r30, 0x06	; 6
    abf8:	0f b6       	in	r0, 0x3f	; 63
    abfa:	f8 94       	cli
    abfc:	fe bf       	out	0x3e, r31	; 62
    abfe:	0f be       	out	0x3f, r0	; 63
    ac00:	ed bf       	out	0x3d, r30	; 61
    ac02:	01 97       	sbiw	r24, 0x01	; 1
    ac04:	09 f0       	breq	.+2      	; 0xac08 <Buf2Field+0x4f2>
    ac06:	1d ce       	rjmp	.-966    	; 0xa842 <Buf2Field+0x12c>
			SetEEField32(Temp, int32_t, uint32_t, d);
    ac08:	49 81       	ldd	r20, Y+1	; 0x01
    ac0a:	5a 81       	ldd	r21, Y+2	; 0x02
    ac0c:	6b 81       	ldd	r22, Y+3	; 0x03
    ac0e:	7c 81       	ldd	r23, Y+4	; 0x04
    ac10:	ca 01       	movw	r24, r20
    ac12:	db 01       	movw	r26, r22
    ac14:	e8 16       	cp	r14, r24
    ac16:	f9 06       	cpc	r15, r25
    ac18:	0a 07       	cpc	r16, r26
    ac1a:	1b 07       	cpc	r17, r27
    ac1c:	0c f4       	brge	.+2      	; 0xac20 <Buf2Field+0x50a>
    ac1e:	d4 c0       	rjmp	.+424    	; 0xadc8 <Buf2Field+0x6b2>
    ac20:	88 15       	cp	r24, r8
    ac22:	99 05       	cpc	r25, r9
    ac24:	aa 05       	cpc	r26, r10
    ac26:	bb 05       	cpc	r27, r11
    ac28:	0c f0       	brlt	.+2      	; 0xac2c <Buf2Field+0x516>
    ac2a:	08 ce       	rjmp	.-1008   	; 0xa83c <Buf2Field+0x126>
    ac2c:	c2 01       	movw	r24, r4
    ac2e:	b5 01       	movw	r22, r10
    ac30:	a4 01       	movw	r20, r8
    ac32:	0e 94 4d 4d 	call	0x9a9a	; 0x9a9a <ewd>
    ac36:	05 ce       	rjmp	.-1014   	; 0xa842 <Buf2Field+0x12c>
		}
		break;


	case FFloat: case GFloat:
		sscanf(BufStr,"%f", &fTemp);
    ac38:	00 d0       	rcall	.+0      	; 0xac3a <Buf2Field+0x524>
    ac3a:	00 d0       	rcall	.+0      	; 0xac3c <Buf2Field+0x526>
    ac3c:	ed b7       	in	r30, 0x3d	; 61
    ac3e:	fe b7       	in	r31, 0x3e	; 62
    ac40:	31 96       	adiw	r30, 0x01	; 1
    ac42:	81 ec       	ldi	r24, 0xC1	; 193
    ac44:	95 e0       	ldi	r25, 0x05	; 5
    ac46:	ad b7       	in	r26, 0x3d	; 61
    ac48:	be b7       	in	r27, 0x3e	; 62
    ac4a:	12 96       	adiw	r26, 0x02	; 2
    ac4c:	9c 93       	st	X, r25
    ac4e:	8e 93       	st	-X, r24
    ac50:	11 97       	sbiw	r26, 0x01	; 1
    ac52:	88 ea       	ldi	r24, 0xA8	; 168
    ac54:	92 e0       	ldi	r25, 0x02	; 2
    ac56:	93 83       	std	Z+3, r25	; 0x03
    ac58:	82 83       	std	Z+2, r24	; 0x02
    ac5a:	ce 01       	movw	r24, r28
    ac5c:	05 96       	adiw	r24, 0x05	; 5
    ac5e:	95 83       	std	Z+5, r25	; 0x05
    ac60:	84 83       	std	Z+4, r24	; 0x04
    ac62:	0e 94 0f 80 	call	0x1001e	; 0x1001e <sscanf>
		*(float*)Var = fTemp;
    ac66:	8d 81       	ldd	r24, Y+5	; 0x05
    ac68:	9e 81       	ldd	r25, Y+6	; 0x06
    ac6a:	af 81       	ldd	r26, Y+7	; 0x07
    ac6c:	b8 85       	ldd	r27, Y+8	; 0x08
    ac6e:	f2 01       	movw	r30, r4
    ac70:	80 83       	st	Z, r24
    ac72:	91 83       	std	Z+1, r25	; 0x01
    ac74:	a2 83       	std	Z+2, r26	; 0x02
    ac76:	b3 83       	std	Z+3, r27	; 0x03
    ac78:	2d b7       	in	r18, 0x3d	; 61
    ac7a:	3e b7       	in	r19, 0x3e	; 62
    ac7c:	2a 5f       	subi	r18, 0xFA	; 250
    ac7e:	3f 4f       	sbci	r19, 0xFF	; 255
    ac80:	0f b6       	in	r0, 0x3f	; 63
    ac82:	f8 94       	cli
    ac84:	3e bf       	out	0x3e, r19	; 62
    ac86:	0f be       	out	0x3f, r0	; 63
    ac88:	2d bf       	out	0x3d, r18	; 61
    ac8a:	db cd       	rjmp	.-1098   	; 0xa842 <Buf2Field+0x12c>
		break;
	case EE_FFloat: case EE_GFloat:
		if(sscanf(BufStr,"%f", &fTemp) == 1){
    ac8c:	00 d0       	rcall	.+0      	; 0xac8e <Buf2Field+0x578>
    ac8e:	00 d0       	rcall	.+0      	; 0xac90 <Buf2Field+0x57a>
    ac90:	ed b7       	in	r30, 0x3d	; 61
    ac92:	fe b7       	in	r31, 0x3e	; 62
    ac94:	31 96       	adiw	r30, 0x01	; 1
    ac96:	81 ec       	ldi	r24, 0xC1	; 193
    ac98:	95 e0       	ldi	r25, 0x05	; 5
    ac9a:	ad b7       	in	r26, 0x3d	; 61
    ac9c:	be b7       	in	r27, 0x3e	; 62
    ac9e:	12 96       	adiw	r26, 0x02	; 2
    aca0:	9c 93       	st	X, r25
    aca2:	8e 93       	st	-X, r24
    aca4:	11 97       	sbiw	r26, 0x01	; 1
    aca6:	88 ea       	ldi	r24, 0xA8	; 168
    aca8:	92 e0       	ldi	r25, 0x02	; 2
    acaa:	93 83       	std	Z+3, r25	; 0x03
    acac:	82 83       	std	Z+2, r24	; 0x02
    acae:	8e 01       	movw	r16, r28
    acb0:	0b 5f       	subi	r16, 0xFB	; 251
    acb2:	1f 4f       	sbci	r17, 0xFF	; 255
    acb4:	15 83       	std	Z+5, r17	; 0x05
    acb6:	04 83       	std	Z+4, r16	; 0x04
    acb8:	0e 94 0f 80 	call	0x1001e	; 0x1001e <sscanf>
    acbc:	ed b7       	in	r30, 0x3d	; 61
    acbe:	fe b7       	in	r31, 0x3e	; 62
    acc0:	36 96       	adiw	r30, 0x06	; 6
    acc2:	0f b6       	in	r0, 0x3f	; 63
    acc4:	f8 94       	cli
    acc6:	fe bf       	out	0x3e, r31	; 62
    acc8:	0f be       	out	0x3f, r0	; 63
    acca:	ed bf       	out	0x3d, r30	; 61
    accc:	01 97       	sbiw	r24, 0x01	; 1
    acce:	09 f0       	breq	.+2      	; 0xacd2 <Buf2Field+0x5bc>
    acd0:	b8 cd       	rjmp	.-1168   	; 0xa842 <Buf2Field+0x12c>
			ewbl(&fTemp, (float*)Var, 4);
    acd2:	c8 01       	movw	r24, r16
    acd4:	b2 01       	movw	r22, r4
    acd6:	44 e0       	ldi	r20, 0x04	; 4
    acd8:	50 e0       	ldi	r21, 0x00	; 0
    acda:	0e 94 48 4d 	call	0x9a90	; 0x9a90 <ewbl>
    acde:	b1 cd       	rjmp	.-1182   	; 0xa842 <Buf2Field+0x12c>
		}
		break;


	case Bit:
		if(F_Buf)
    ace0:	80 91 f5 04 	lds	r24, 0x04F5
    ace4:	90 91 f6 04 	lds	r25, 0x04F6
    ace8:	a0 91 f7 04 	lds	r26, 0x04F7
    acec:	b0 91 f8 04 	lds	r27, 0x04F8
    acf0:	00 97       	sbiw	r24, 0x00	; 0
    acf2:	a1 05       	cpc	r26, r1
    acf4:	b1 05       	cpc	r27, r1
    acf6:	91 f1       	breq	.+100    	; 0xad5c <Buf2Field+0x646>
			*BitVar |=Mask;
    acf8:	d3 01       	movw	r26, r6
    acfa:	8c 91       	ld	r24, X
    acfc:	83 29       	or	r24, r3
    acfe:	8c 93       	st	X, r24
    ad00:	a0 cd       	rjmp	.-1216   	; 0xa842 <Buf2Field+0x12c>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    ad02:	c3 01       	movw	r24, r6
    ad04:	0e 94 db 81 	call	0x103b6	; 0x103b6 <__eerd_byte_m2560>
    ad08:	28 2f       	mov	r18, r24
		else
			*BitVar &=~Mask;
		break;
	case EE_Bit:
		EE_BitVar=erb(BitVar);
		ewb(BitVar, F_Buf ? EE_BitVar |Mask : EE_BitVar &~Mask);
    ad0a:	80 91 f5 04 	lds	r24, 0x04F5
    ad0e:	90 91 f6 04 	lds	r25, 0x04F6
    ad12:	a0 91 f7 04 	lds	r26, 0x04F7
    ad16:	b0 91 f8 04 	lds	r27, 0x04F8
    ad1a:	00 97       	sbiw	r24, 0x00	; 0
    ad1c:	a1 05       	cpc	r26, r1
    ad1e:	b1 05       	cpc	r27, r1
    ad20:	d1 f4       	brne	.+52     	; 0xad56 <Buf2Field+0x640>
    ad22:	63 2d       	mov	r22, r3
    ad24:	60 95       	com	r22
    ad26:	62 23       	and	r22, r18
    ad28:	c3 01       	movw	r24, r6
    ad2a:	0e 94 d3 4b 	call	0x97a6	; 0x97a6 <ewb>
    ad2e:	89 cd       	rjmp	.-1262   	; 0xa842 <Buf2Field+0x12c>
		break;


	case Text:{
		//    
		uint8_t Field_width = strlen((char*)Var);
    ad30:	f2 01       	movw	r30, r4
    ad32:	01 90       	ld	r0, Z+
    ad34:	00 20       	and	r0, r0
    ad36:	e9 f7       	brne	.-6      	; 0xad32 <Buf2Field+0x61c>
    ad38:	31 97       	sbiw	r30, 0x01	; 1
    ad3a:	4e 2f       	mov	r20, r30
    ad3c:	44 19       	sub	r20, r4
		if(Field_width > LCDXSz) Field_width = LCDXSz+1;
    ad3e:	45 31       	cpi	r20, 0x15	; 21
    ad40:	e8 f0       	brcs	.+58     	; 0xad7c <Buf2Field+0x666>
    ad42:	e5 e1       	ldi	r30, 0x15	; 21
    ad44:	f0 e0       	ldi	r31, 0x00	; 0
		memcpy(Var,BufStr,Field_width);
    ad46:	21 ec       	ldi	r18, 0xC1	; 193
    ad48:	35 e0       	ldi	r19, 0x05	; 5
    ad4a:	c2 01       	movw	r24, r4
    ad4c:	b9 01       	movw	r22, r18
    ad4e:	af 01       	movw	r20, r30
    ad50:	0e 94 fd 7e 	call	0xfdfa	; 0xfdfa <memcpy>
    ad54:	76 cd       	rjmp	.-1300   	; 0xa842 <Buf2Field+0x12c>
		else
			*BitVar &=~Mask;
		break;
	case EE_Bit:
		EE_BitVar=erb(BitVar);
		ewb(BitVar, F_Buf ? EE_BitVar |Mask : EE_BitVar &~Mask);
    ad56:	63 2d       	mov	r22, r3
    ad58:	62 2b       	or	r22, r18
    ad5a:	e6 cf       	rjmp	.-52     	; 0xad28 <Buf2Field+0x612>

	case Bit:
		if(F_Buf)
			*BitVar |=Mask;
		else
			*BitVar &=~Mask;
    ad5c:	30 94       	com	r3
    ad5e:	f3 01       	movw	r30, r6
    ad60:	80 81       	ld	r24, Z
    ad62:	83 21       	and	r24, r3
    ad64:	80 83       	st	Z, r24
    ad66:	6d cd       	rjmp	.-1318   	; 0xa842 <Buf2Field+0x12c>
		break;
	case s_Longint:
		PresicionHanler(Field);
		//if(Limit_sByteVar(Temp)) sscanf(BufStr,"%hd", (short int*)&Temp);
		sscanf(BufStr,"%ld", (int32_t*)&Temp);
		SetField32(Temp, int32_t);
    ad68:	d2 01       	movw	r26, r4
    ad6a:	ed 92       	st	X+, r14
    ad6c:	fd 92       	st	X+, r15
    ad6e:	0d 93       	st	X+, r16
    ad70:	1c 93       	st	X, r17
    ad72:	13 97       	sbiw	r26, 0x03	; 3
    ad74:	66 cd       	rjmp	.-1332   	; 0xa842 <Buf2Field+0x12c>
	switch(prb(&Field->Type)) {
	case Byte: case z_Byte: case Enum:
		SetField(F_Buf, uint8_t);
		break;
	case s_Byte:
		SetField(sF_Buf, int8_t);
    ad76:	f2 01       	movw	r30, r4
    ad78:	e0 82       	st	Z, r14
    ad7a:	63 cd       	rjmp	.-1338   	; 0xa842 <Buf2Field+0x12c>


	case Text:{
		//    
		uint8_t Field_width = strlen((char*)Var);
		if(Field_width > LCDXSz) Field_width = LCDXSz+1;
    ad7c:	e4 2f       	mov	r30, r20
    ad7e:	f0 e0       	ldi	r31, 0x00	; 0
    ad80:	e2 cf       	rjmp	.-60     	; 0xad46 <Buf2Field+0x630>
	uint32_t Temp=0;
	float fTemp=0;

	switch(prb(&Field->Type)) {
	case Byte: case z_Byte: case Enum:
		SetField(F_Buf, uint8_t);
    ad82:	d2 01       	movw	r26, r4
    ad84:	ec 92       	st	X, r14
    ad86:	5d cd       	rjmp	.-1350   	; 0xa842 <Buf2Field+0x12c>
		break;
	case s_EE_Byte:
		SetEEField(sF_Buf, int8_t, uint8_t, b);
		break;
	case Word: case z_Word:
		SetField(F_Buf, uint16_t);
    ad88:	d2 01       	movw	r26, r4
    ad8a:	ed 92       	st	X+, r14
    ad8c:	fc 92       	st	X, r15
    ad8e:	59 cd       	rjmp	.-1358   	; 0xa842 <Buf2Field+0x12c>
		break;
	case EE_Word: case z_EE_Word:
		SetEEField(F_Buf, uint16_t, uint16_t, w);
		break;
	case s_Word:
		SetField(sF_Buf, int16_t);
    ad90:	f2 01       	movw	r30, r4
    ad92:	f1 82       	std	Z+1, r15	; 0x01
    ad94:	e0 82       	st	Z, r14
    ad96:	55 cd       	rjmp	.-1366   	; 0xa842 <Buf2Field+0x12c>
		break;
	case s_EE_Word:
		SetEEField(sF_Buf, int16_t, uint16_t, w);
    ad98:	c2 01       	movw	r24, r4
    ad9a:	b7 01       	movw	r22, r14
    ad9c:	0e 94 16 4c 	call	0x982c	; 0x982c <eww>
    ada0:	50 cd       	rjmp	.-1376   	; 0xa842 <Buf2Field+0x12c>
		break;
	case EE_Byte: case z_EE_Byte: case EE_Enum:
		SetEEField(F_Buf, uint8_t, uint8_t, b);
		break;
	case s_EE_Byte:
		SetEEField(sF_Buf, int8_t, uint8_t, b);
    ada2:	c2 01       	movw	r24, r4
    ada4:	6e 2d       	mov	r22, r14
    ada6:	0e 94 d3 4b 	call	0x97a6	; 0x97a6 <ewb>
    adaa:	4b cd       	rjmp	.-1386   	; 0xa842 <Buf2Field+0x12c>
	switch(prb(&Field->Type)) {
	case Byte: case z_Byte: case Enum:
		SetField(F_Buf, uint8_t);
		break;
	case s_Byte:
		SetField(sF_Buf, int8_t);
    adac:	f2 01       	movw	r30, r4
    adae:	20 83       	st	Z, r18
    adb0:	48 cd       	rjmp	.-1392   	; 0xa842 <Buf2Field+0x12c>
		break;
	case s_EE_Byte:
		SetEEField(sF_Buf, int8_t, uint8_t, b);
		break;
	case Word: case z_Word:
		SetField(F_Buf, uint16_t);
    adb2:	d2 01       	movw	r26, r4
    adb4:	2d 93       	st	X+, r18
    adb6:	3c 93       	st	X, r19
    adb8:	44 cd       	rjmp	.-1400   	; 0xa842 <Buf2Field+0x12c>
		break;
	case EE_Word: case z_EE_Word:
		SetEEField(F_Buf, uint16_t, uint16_t, w);
		break;
	case s_Word:
		SetField(sF_Buf, int16_t);
    adba:	f2 01       	movw	r30, r4
    adbc:	31 83       	std	Z+1, r19	; 0x01
    adbe:	20 83       	st	Z, r18
    adc0:	40 cd       	rjmp	.-1408   	; 0xa842 <Buf2Field+0x12c>
	uint32_t Temp=0;
	float fTemp=0;

	switch(prb(&Field->Type)) {
	case Byte: case z_Byte: case Enum:
		SetField(F_Buf, uint8_t);
    adc2:	d2 01       	movw	r26, r4
    adc4:	2c 93       	st	X, r18
    adc6:	3d cd       	rjmp	.-1414   	; 0xa842 <Buf2Field+0x12c>
		SetField32(Temp, int32_t);
		break;
	case s_EE_Longint:
		PresicionHanler(Field);
		if(sscanf(BufStr,"%ld", (int32_t*)&Temp) == 1){
			SetEEField32(Temp, int32_t, uint32_t, d);
    adc8:	c2 01       	movw	r24, r4
    adca:	b8 01       	movw	r22, r16
    adcc:	a7 01       	movw	r20, r14
    adce:	0e 94 4d 4d 	call	0x9a9a	; 0x9a9a <ewd>
    add2:	37 cd       	rjmp	.-1426   	; 0xa842 <Buf2Field+0x12c>

0000add4 <MenuEnterRight>:
}

// ~~~~~~~~~~~~~~~~~
void
MenuEnterRight(void)
{
    add4:	ef 92       	push	r14
    add6:	ff 92       	push	r15
    add8:	0f 93       	push	r16
    adda:	1f 93       	push	r17
    addc:	cf 93       	push	r28
    adde:	df 93       	push	r29
//	1) Hide current Message
	if(HideMsg()||KeyFunc(&CurrPage->Enter))
    ade0:	0e 94 8a 3c 	call	0x7914	; 0x7914 <HideMsg>
    ade4:	88 23       	and	r24, r24
    ade6:	39 f0       	breq	.+14     	; 0xadf6 <MenuEnterRight+0x22>
	if(NextPage || (NextPage=prp(&Line->InnPage))) {
		GotoMenu(NextPage);
		NextPage=NULL;
		return;
	}
}
    ade8:	df 91       	pop	r29
    adea:	cf 91       	pop	r28
    adec:	1f 91       	pop	r17
    adee:	0f 91       	pop	r16
    adf0:	ff 90       	pop	r15
    adf2:	ef 90       	pop	r14
    adf4:	08 95       	ret
// ~~~~~~~~~~~~~~~~~
void
MenuEnterRight(void)
{
//	1) Hide current Message
	if(HideMsg()||KeyFunc(&CurrPage->Enter))
    adf6:	80 91 d4 02 	lds	r24, 0x02D4
    adfa:	90 91 d5 02 	lds	r25, 0x02D5
    adfe:	0c 96       	adiw	r24, 0x0c	; 12
    ae00:	0e 94 30 3c 	call	0x7860	; 0x7860 <KeyFunc>
    ae04:	88 23       	and	r24, r24
    ae06:	81 f7       	brne	.-32     	; 0xade8 <MenuEnterRight+0x14>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    ae08:	40 91 d4 02 	lds	r20, 0x02D4
    ae0c:	50 91 d5 02 	lds	r21, 0x02D5
    ae10:	fa 01       	movw	r30, r20
    ae12:	c5 91       	lpm	r28, Z+
    ae14:	d4 91       	lpm	r29, Z+
		return;

	MenuLine *Line=GetLine+CurrLine;
    ae16:	90 91 83 07 	lds	r25, 0x0783
    ae1a:	8b e1       	ldi	r24, 0x1B	; 27
    ae1c:	98 9f       	mul	r25, r24
    ae1e:	b0 01       	movw	r22, r0
    ae20:	11 24       	eor	r1, r1
    ae22:	c6 0f       	add	r28, r22
    ae24:	d7 1f       	adc	r29, r23
    ae26:	fe 01       	movw	r30, r28
    ae28:	77 96       	adiw	r30, 0x17	; 23
    ae2a:	e5 90       	lpm	r14, Z+
    ae2c:	f4 90       	lpm	r15, Z+
	OutField *Field=prp(&Line->OF_List);

// 2) Variable
	if(Field){
    ae2e:	e1 14       	cp	r14, r1
    ae30:	f1 04       	cpc	r15, r1
    ae32:	09 f4       	brne	.+2      	; 0xae36 <MenuEnterRight+0x62>
    ae34:	93 c0       	rjmp	.+294    	; 0xaf5c <MenuEnterRight+0x188>
    ae36:	10 e0       	ldi	r17, 0x00	; 0
    ae38:	30 e0       	ldi	r19, 0x00	; 0
    ae3a:	80 e0       	ldi	r24, 0x00	; 0
    ae3c:	90 e0       	ldi	r25, 0x00	; 0
    ae3e:	05 c0       	rjmp	.+10     	; 0xae4a <MenuEnterRight+0x76>
		uint8_t i=0;
		while(i<LCDXSz) {
			Char1 = Char2;
			Char2 = prc(CurrStr+i++);
			if (Char2=='}' && Char1!='}')
				FieldNumber++;
    ae40:	01 96       	adiw	r24, 0x01	; 1
	// Define variable quantity 
		uint8_t FieldNumber = 0;
		PGM_P CurrStr=(PGM_P)(Line->Str);
		char Char1, Char2=0;
		uint8_t i=0;
		while(i<LCDXSz) {
    ae42:	84 31       	cpi	r24, 0x14	; 20
    ae44:	91 05       	cpc	r25, r1
    ae46:	71 f0       	breq	.+28     	; 0xae64 <MenuEnterRight+0x90>
    ae48:	32 2f       	mov	r19, r18

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    ae4a:	fe 01       	movw	r30, r28
    ae4c:	e8 0f       	add	r30, r24
    ae4e:	f9 1f       	adc	r31, r25
    ae50:	24 91       	lpm	r18, Z+
			Char1 = Char2;
			Char2 = prc(CurrStr+i++);
			if (Char2=='}' && Char1!='}')
    ae52:	2d 37       	cpi	r18, 0x7D	; 125
    ae54:	a9 f7       	brne	.-22     	; 0xae40 <MenuEnterRight+0x6c>
    ae56:	3d 37       	cpi	r19, 0x7D	; 125
    ae58:	99 f3       	breq	.-26     	; 0xae40 <MenuEnterRight+0x6c>
				FieldNumber++;
    ae5a:	1f 5f       	subi	r17, 0xFF	; 255
    ae5c:	01 96       	adiw	r24, 0x01	; 1
	// Define variable quantity 
		uint8_t FieldNumber = 0;
		PGM_P CurrStr=(PGM_P)(Line->Str);
		char Char1, Char2=0;
		uint8_t i=0;
		while(i<LCDXSz) {
    ae5e:	84 31       	cpi	r24, 0x14	; 20
    ae60:	91 05       	cpc	r25, r1
    ae62:	91 f7       	brne	.-28     	; 0xae48 <MenuEnterRight+0x74>
			Char2 = prc(CurrStr+i++);
			if (Char2=='}' && Char1!='}')
				FieldNumber++;
		}
		//    Bit (:)   
		if(FieldNumber==1 && prb(&Field->Type)==Bit) {
    ae64:	11 30       	cpi	r17, 0x01	; 1
    ae66:	09 f4       	brne	.+2      	; 0xae6a <MenuEnterRight+0x96>
    ae68:	b8 c0       	rjmp	.+368    	; 0xafda <MenuEnterRight+0x206>
			EventFunc(&Field->Act);
			return;
		}

	//    
		if(CurrPos!=NullPos && --CurrPos!=NullPos){
    ae6a:	80 91 d7 02 	lds	r24, 0x02D7
    ae6e:	8f 3f       	cpi	r24, 0xFF	; 255
    ae70:	09 f4       	brne	.+2      	; 0xae74 <MenuEnterRight+0xa0>
    ae72:	4a c0       	rjmp	.+148    	; 0xaf08 <MenuEnterRight+0x134>
    ae74:	08 2f       	mov	r16, r24
    ae76:	01 50       	subi	r16, 0x01	; 1
    ae78:	00 93 d7 02 	sts	0x02D7, r16
    ae7c:	0f 3f       	cpi	r16, 0xFF	; 255
    ae7e:	09 f4       	brne	.+2      	; 0xae82 <MenuEnterRight+0xae>
    ae80:	43 c0       	rjmp	.+134    	; 0xaf08 <MenuEnterRight+0x134>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    ae82:	fa 01       	movw	r30, r20
    ae84:	45 91       	lpm	r20, Z+
    ae86:	54 91       	lpm	r21, Z+
			OutField *Field1=GetField;
    ae88:	46 0f       	add	r20, r22
    ae8a:	57 1f       	adc	r21, r23
    ae8c:	49 5e       	subi	r20, 0xE9	; 233
    ae8e:	5f 4f       	sbci	r21, 0xFF	; 255
    ae90:	fa 01       	movw	r30, r20
    ae92:	25 91       	lpm	r18, Z+
    ae94:	34 91       	lpm	r19, Z+
    ae96:	80 91 d6 02 	lds	r24, 0x02D6
    ae9a:	90 e0       	ldi	r25, 0x00	; 0
    ae9c:	82 95       	swap	r24
    ae9e:	92 95       	swap	r25
    aea0:	90 7f       	andi	r25, 0xF0	; 240
    aea2:	98 27       	eor	r25, r24
    aea4:	80 7f       	andi	r24, 0xF0	; 240
    aea6:	98 27       	eor	r25, r24
    aea8:	28 0f       	add	r18, r24
    aeaa:	39 1f       	adc	r19, r25

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    aeac:	f9 01       	movw	r30, r18
    aeae:	84 91       	lpm	r24, Z+
			switch(prb(&Field1->Type)){
    aeb0:	8d 31       	cpi	r24, 0x1D	; 29
    aeb2:	08 f4       	brcc	.+2      	; 0xaeb6 <MenuEnterRight+0xe2>
    aeb4:	67 c0       	rjmp	.+206    	; 0xaf84 <MenuEnterRight+0x1b0>
    aeb6:	81 52       	subi	r24, 0x21	; 33
    aeb8:	82 30       	cpi	r24, 0x02	; 2
    aeba:	08 f0       	brcs	.+2      	; 0xaebe <MenuEnterRight+0xea>
    aebc:	95 cf       	rjmp	.-214    	; 0xade8 <MenuEnterRight+0x14>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    aebe:	f9 01       	movw	r30, r18
    aec0:	33 96       	adiw	r30, 0x03	; 3
    aec2:	85 91       	lpm	r24, Z+
    aec4:	95 91       	lpm	r25, Z+
    aec6:	a5 91       	lpm	r26, Z+
    aec8:	b4 91       	lpm	r27, Z+
			case Text: case EE_Text:
				if( (prd(&Field1->Min) == DIGIT) && (prd(&Field1->Max) == DIGIT) )
    aeca:	00 97       	sbiw	r24, 0x00	; 0
    aecc:	a1 05       	cpc	r26, r1
    aece:	b1 05       	cpc	r27, r1
    aed0:	59 f4       	brne	.+22     	; 0xaee8 <MenuEnterRight+0x114>
    aed2:	f9 01       	movw	r30, r18
    aed4:	37 96       	adiw	r30, 0x07	; 7
    aed6:	85 91       	lpm	r24, Z+
    aed8:	95 91       	lpm	r25, Z+
    aeda:	a5 91       	lpm	r26, Z+
    aedc:	b4 91       	lpm	r27, Z+
    aede:	00 97       	sbiw	r24, 0x00	; 0
    aee0:	a1 05       	cpc	r26, r1
    aee2:	b1 05       	cpc	r27, r1
    aee4:	09 f4       	brne	.+2      	; 0xaee8 <MenuEnterRight+0x114>
    aee6:	a3 c0       	rjmp	.+326    	; 0xb02e <MenuEnterRight+0x25a>
					MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[CurrFieldSize - 1 - CurrPos]);
				else MultiSymbol = GetMultiSymbol(Symbols_P, BufStr[CurrFieldSize - 1 - CurrPos]);
    aee8:	e0 91 7a 07 	lds	r30, 0x077A
    aeec:	f0 e0       	ldi	r31, 0x00	; 0
    aeee:	31 97       	sbiw	r30, 0x01	; 1
    aef0:	e0 1b       	sub	r30, r16
    aef2:	f1 09       	sbc	r31, r1
    aef4:	ef 53       	subi	r30, 0x3F	; 63
    aef6:	fa 4f       	sbci	r31, 0xFA	; 250
    aef8:	85 e0       	ldi	r24, 0x05	; 5
    aefa:	96 e0       	ldi	r25, 0x06	; 6
    aefc:	60 81       	ld	r22, Z
    aefe:	0e 94 91 40 	call	0x8122	; 0x8122 <GetMultiSymbol>
    af02:	80 93 f2 04 	sts	0x04F2, r24
    af06:	70 cf       	rjmp	.-288    	; 0xade8 <MenuEnterRight+0x14>
				break;		
			}
			return;
		}

		if(CurrField!=NullPos) {
    af08:	80 91 d6 02 	lds	r24, 0x02D6
    af0c:	8f 3f       	cpi	r24, 0xFF	; 255
    af0e:	81 f0       	breq	.+32     	; 0xaf30 <MenuEnterRight+0x15c>
			Buf2Field(Field+CurrField);
    af10:	90 e0       	ldi	r25, 0x00	; 0
    af12:	82 95       	swap	r24
    af14:	92 95       	swap	r25
    af16:	90 7f       	andi	r25, 0xF0	; 240
    af18:	98 27       	eor	r25, r24
    af1a:	80 7f       	andi	r24, 0xF0	; 240
    af1c:	98 27       	eor	r25, r24
    af1e:	8e 0d       	add	r24, r14
    af20:	9f 1d       	adc	r25, r15
    af22:	0e 94 8b 53 	call	0xa716	; 0xa716 <Buf2Field>
			if(CurrField==NullPos)
    af26:	80 91 d6 02 	lds	r24, 0x02D6
    af2a:	8f 3f       	cpi	r24, 0xFF	; 255
    af2c:	09 f4       	brne	.+2      	; 0xaf30 <MenuEnterRight+0x15c>
    af2e:	5c cf       	rjmp	.-328    	; 0xade8 <MenuEnterRight+0x14>
				return;
		}
		//     
		if(++CurrField==FieldNumber)
    af30:	8f 5f       	subi	r24, 0xFF	; 255
    af32:	80 93 d6 02 	sts	0x02D6, r24
    af36:	18 17       	cp	r17, r24
    af38:	d9 f1       	breq	.+118    	; 0xafb0 <MenuEnterRight+0x1dc>
			CurrField=NullPos;
		else
			Field2Buf(Field+CurrField);
    af3a:	90 e0       	ldi	r25, 0x00	; 0
    af3c:	82 95       	swap	r24
    af3e:	92 95       	swap	r25
    af40:	90 7f       	andi	r25, 0xF0	; 240
    af42:	98 27       	eor	r25, r24
    af44:	80 7f       	andi	r24, 0xF0	; 240
    af46:	98 27       	eor	r25, r24
    af48:	8e 0d       	add	r24, r14
    af4a:	9f 1d       	adc	r25, r15
    af4c:	0e 94 d3 4f 	call	0x9fa6	; 0x9fa6 <Field2Buf>
    af50:	40 91 d4 02 	lds	r20, 0x02D4
    af54:	50 91 d5 02 	lds	r21, 0x02D5
    af58:	90 91 83 07 	lds	r25, 0x0783

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    af5c:	4e 5f       	subi	r20, 0xFE	; 254
    af5e:	5f 4f       	sbci	r21, 0xFF	; 255
    af60:	fa 01       	movw	r30, r20
    af62:	84 91       	lpm	r24, Z+
	}

// 3) Go to menu
	if( CurrLine >= prb(&CurrPage->LineNumber) )
    af64:	98 17       	cp	r25, r24
    af66:	08 f0       	brcs	.+2      	; 0xaf6a <MenuEnterRight+0x196>
    af68:	3f cf       	rjmp	.-386    	; 0xade8 <MenuEnterRight+0x14>
		return;

	if(NextPage || (NextPage=prp(&Line->InnPage))) {
    af6a:	80 91 d7 05 	lds	r24, 0x05D7
    af6e:	90 91 d8 05 	lds	r25, 0x05D8
    af72:	00 97       	sbiw	r24, 0x00	; 0
    af74:	39 f1       	breq	.+78     	; 0xafc4 <MenuEnterRight+0x1f0>
		GotoMenu(NextPage);
    af76:	0e 94 42 3c 	call	0x7884	; 0x7884 <GotoMenu>
		NextPage=NULL;
    af7a:	10 92 d8 05 	sts	0x05D8, r1
    af7e:	10 92 d7 05 	sts	0x05D7, r1
    af82:	32 cf       	rjmp	.-412    	; 0xade8 <MenuEnterRight+0x14>
		}

	//    
		if(CurrPos!=NullPos && --CurrPos!=NullPos){
			OutField *Field1=GetField;
			switch(prb(&Field1->Type)){
    af84:	89 31       	cpi	r24, 0x19	; 25
    af86:	20 f4       	brcc	.+8      	; 0xaf90 <MenuEnterRight+0x1bc>
    af88:	80 51       	subi	r24, 0x10	; 16
    af8a:	86 30       	cpi	r24, 0x06	; 6
    af8c:	08 f0       	brcs	.+2      	; 0xaf90 <MenuEnterRight+0x1bc>
    af8e:	2c cf       	rjmp	.-424    	; 0xade8 <MenuEnterRight+0x14>
					MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[CurrFieldSize - 1 - CurrPos]);
				else MultiSymbol = GetMultiSymbol(Symbols_P, BufStr[CurrFieldSize - 1 - CurrPos]);
				break;
			case Longint: case z_Longint: case EE_Longint: case z_EE_Longint: case s_Longint: case s_EE_Longint:
			case FFloat: case EE_FFloat: case GFloat: case EE_GFloat:
				MultiSymbol = GetMultiSymbol(Digits_P, BufStr[CurrFieldSize - 1 - CurrPos]);
    af90:	e0 91 7a 07 	lds	r30, 0x077A
    af94:	f0 e0       	ldi	r31, 0x00	; 0
    af96:	31 97       	sbiw	r30, 0x01	; 1
    af98:	e0 1b       	sub	r30, r16
    af9a:	f1 09       	sbc	r31, r1
    af9c:	ef 53       	subi	r30, 0x3F	; 63
    af9e:	fa 4f       	sbci	r31, 0xFA	; 250
    afa0:	8e ea       	ldi	r24, 0xAE	; 174
    afa2:	96 e0       	ldi	r25, 0x06	; 6
    afa4:	60 81       	ld	r22, Z
    afa6:	0e 94 91 40 	call	0x8122	; 0x8122 <GetMultiSymbol>
    afaa:	80 93 f2 04 	sts	0x04F2, r24
    afae:	1c cf       	rjmp	.-456    	; 0xade8 <MenuEnterRight+0x14>
			if(CurrField==NullPos)
				return;
		}
		//     
		if(++CurrField==FieldNumber)
			CurrField=NullPos;
    afb0:	8f ef       	ldi	r24, 0xFF	; 255
    afb2:	80 93 d6 02 	sts	0x02D6, r24
    afb6:	40 91 d4 02 	lds	r20, 0x02D4
    afba:	50 91 d5 02 	lds	r21, 0x02D5
    afbe:	90 91 83 07 	lds	r25, 0x0783
    afc2:	cc cf       	rjmp	.-104    	; 0xaf5c <MenuEnterRight+0x188>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    afc4:	fe 01       	movw	r30, r28
    afc6:	79 96       	adiw	r30, 0x19	; 25
    afc8:	85 91       	lpm	r24, Z+
    afca:	94 91       	lpm	r25, Z+

// 3) Go to menu
	if( CurrLine >= prb(&CurrPage->LineNumber) )
		return;

	if(NextPage || (NextPage=prp(&Line->InnPage))) {
    afcc:	90 93 d8 05 	sts	0x05D8, r25
    afd0:	80 93 d7 05 	sts	0x05D7, r24
    afd4:	00 97       	sbiw	r24, 0x00	; 0
    afd6:	79 f6       	brne	.-98     	; 0xaf76 <MenuEnterRight+0x1a2>
    afd8:	07 cf       	rjmp	.-498    	; 0xade8 <MenuEnterRight+0x14>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    afda:	f7 01       	movw	r30, r14
    afdc:	84 91       	lpm	r24, Z+
			Char2 = prc(CurrStr+i++);
			if (Char2=='}' && Char1!='}')
				FieldNumber++;
		}
		//    Bit (:)   
		if(FieldNumber==1 && prb(&Field->Type)==Bit) {
    afde:	8f 31       	cpi	r24, 0x1F	; 31
    afe0:	09 f0       	breq	.+2      	; 0xafe4 <MenuEnterRight+0x210>
    afe2:	43 cf       	rjmp	.-378    	; 0xae6a <MenuEnterRight+0x96>
    afe4:	8f e0       	ldi	r24, 0x0F	; 15
    afe6:	90 e0       	ldi	r25, 0x00	; 0
    afe8:	e8 0e       	add	r14, r24
    afea:	f9 1e       	adc	r15, r25
    afec:	f7 01       	movw	r30, r14
    afee:	24 91       	lpm	r18, Z+
    aff0:	81 ef       	ldi	r24, 0xF1	; 241
    aff2:	9f ef       	ldi	r25, 0xFF	; 255
    aff4:	e8 0e       	add	r14, r24
    aff6:	f9 1e       	adc	r15, r25

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    aff8:	c7 01       	movw	r24, r14
    affa:	01 96       	adiw	r24, 0x01	; 1
    affc:	fc 01       	movw	r30, r24
    affe:	a5 91       	lpm	r26, Z+
    b000:	b4 91       	lpm	r27, Z+
			uint8_t BitN=prb(&Field->Prec);
			*((uint8_t*)prp(&Field->Var)+BitN/8) ^=(1<<BitN%8);
    b002:	82 2f       	mov	r24, r18
    b004:	86 95       	lsr	r24
    b006:	86 95       	lsr	r24
    b008:	86 95       	lsr	r24
    b00a:	a8 0f       	add	r26, r24
    b00c:	b1 1d       	adc	r27, r1
    b00e:	27 70       	andi	r18, 0x07	; 7
    b010:	81 e0       	ldi	r24, 0x01	; 1
    b012:	90 e0       	ldi	r25, 0x00	; 0
    b014:	02 c0       	rjmp	.+4      	; 0xb01a <MenuEnterRight+0x246>
    b016:	88 0f       	add	r24, r24
    b018:	99 1f       	adc	r25, r25
    b01a:	2a 95       	dec	r18
    b01c:	e2 f7       	brpl	.-8      	; 0xb016 <MenuEnterRight+0x242>
    b01e:	2c 91       	ld	r18, X
    b020:	28 27       	eor	r18, r24
    b022:	2c 93       	st	X, r18
			EventFunc(&Field->Act);
    b024:	c7 01       	movw	r24, r14
    b026:	0b 96       	adiw	r24, 0x0b	; 11
    b028:	0e 94 28 3c 	call	0x7850	; 0x7850 <EventFunc>
    b02c:	dd ce       	rjmp	.-582    	; 0xade8 <MenuEnterRight+0x14>
		if(CurrPos!=NullPos && --CurrPos!=NullPos){
			OutField *Field1=GetField;
			switch(prb(&Field1->Type)){
			case Text: case EE_Text:
				if( (prd(&Field1->Min) == DIGIT) && (prd(&Field1->Max) == DIGIT) )
					MultiSymbol = GetMultiSymbol(OnlyDigits_P, BufStr[CurrFieldSize - 1 - CurrPos]);
    b02e:	e0 91 7a 07 	lds	r30, 0x077A
    b032:	f0 e0       	ldi	r31, 0x00	; 0
    b034:	31 97       	sbiw	r30, 0x01	; 1
    b036:	e0 1b       	sub	r30, r16
    b038:	f1 09       	sbc	r31, r1
    b03a:	ef 53       	subi	r30, 0x3F	; 63
    b03c:	fa 4f       	sbci	r31, 0xFA	; 250
    b03e:	83 ea       	ldi	r24, 0xA3	; 163
    b040:	96 e0       	ldi	r25, 0x06	; 6
    b042:	60 81       	ld	r22, Z
    b044:	0e 94 91 40 	call	0x8122	; 0x8122 <GetMultiSymbol>
    b048:	80 93 f2 04 	sts	0x04F2, r24
    b04c:	cd ce       	rjmp	.-614    	; 0xade8 <MenuEnterRight+0x14>

0000b04e <MenuUD>:
	return Pos*Dir;
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
MenuUD(const MenuKey *Key, int8_t Dir, uint8_t LimLine, uint8_t LimLCD, uint8_t LimVar)
{
    b04e:	af 92       	push	r10
    b050:	bf 92       	push	r11
    b052:	cf 92       	push	r12
    b054:	df 92       	push	r13
    b056:	ef 92       	push	r14
    b058:	ff 92       	push	r15
    b05a:	0f 93       	push	r16
    b05c:	1f 93       	push	r17
    b05e:	cf 93       	push	r28
    b060:	df 93       	push	r29
    b062:	fc 01       	movw	r30, r24
    b064:	e6 2e       	mov	r14, r22
    b066:	14 2f       	mov	r17, r20
    b068:	f2 2e       	mov	r15, r18
	if(CurrMsg || KeyFunc(Key))
    b06a:	80 91 f3 04 	lds	r24, 0x04F3
    b06e:	90 91 f4 04 	lds	r25, 0x04F4
    b072:	89 2b       	or	r24, r25
    b074:	59 f0       	breq	.+22     	; 0xb08c <MenuUD+0x3e>
		else 		{if(--MultiSymbol == 255) MultiSymbol = strlen_P(Digits_P)-1;}
		if(CurrPos!=NullPos)
			BufStr[CurrFieldSize - 1 - CurrPos] = prc(Digits_P + MultiSymbol);
		break;
	}
}
    b076:	df 91       	pop	r29
    b078:	cf 91       	pop	r28
    b07a:	1f 91       	pop	r17
    b07c:	0f 91       	pop	r16
    b07e:	ff 90       	pop	r15
    b080:	ef 90       	pop	r14
    b082:	df 90       	pop	r13
    b084:	cf 90       	pop	r12
    b086:	bf 90       	pop	r11
    b088:	af 90       	pop	r10
    b08a:	08 95       	ret
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
MenuUD(const MenuKey *Key, int8_t Dir, uint8_t LimLine, uint8_t LimLCD, uint8_t LimVar)
{
	if(CurrMsg || KeyFunc(Key))
    b08c:	cf 01       	movw	r24, r30
    b08e:	0e 94 30 3c 	call	0x7860	; 0x7860 <KeyFunc>
    b092:	88 23       	and	r24, r24
    b094:	81 f7       	brne	.-32     	; 0xb076 <MenuUD+0x28>
		return;
	if(CurrField==NullPos) {
    b096:	30 91 d6 02 	lds	r19, 0x02D6
    b09a:	3f 3f       	cpi	r19, 0xFF	; 255
    b09c:	09 f4       	brne	.+2      	; 0xb0a0 <MenuUD+0x52>
    b09e:	48 c1       	rjmp	.+656    	; 0xb330 <MenuUD+0x2e2>
			if(LimLCD)
				CurrLCD -= Dir;
		}
		return;
	}
	Blink=0;
    b0a0:	10 92 d0 08 	sts	0x08D0, r1
    b0a4:	80 91 d4 02 	lds	r24, 0x02D4
    b0a8:	90 91 d5 02 	lds	r25, 0x02D5
    b0ac:	fc 01       	movw	r30, r24
    b0ae:	45 91       	lpm	r20, Z+
    b0b0:	54 91       	lpm	r21, Z+
	OutField *Field=GetField;
    b0b2:	80 91 83 07 	lds	r24, 0x0783
    b0b6:	2b e1       	ldi	r18, 0x1B	; 27
    b0b8:	82 9f       	mul	r24, r18
    b0ba:	c0 01       	movw	r24, r0
    b0bc:	11 24       	eor	r1, r1
    b0be:	48 0f       	add	r20, r24
    b0c0:	59 1f       	adc	r21, r25
    b0c2:	49 5e       	subi	r20, 0xE9	; 233
    b0c4:	5f 4f       	sbci	r21, 0xFF	; 255
    b0c6:	fa 01       	movw	r30, r20
    b0c8:	c5 91       	lpm	r28, Z+
    b0ca:	d4 91       	lpm	r29, Z+
    b0cc:	83 2f       	mov	r24, r19
    b0ce:	90 e0       	ldi	r25, 0x00	; 0
    b0d0:	82 95       	swap	r24
    b0d2:	92 95       	swap	r25
    b0d4:	90 7f       	andi	r25, 0xF0	; 240
    b0d6:	98 27       	eor	r25, r24
    b0d8:	80 7f       	andi	r24, 0xF0	; 240
    b0da:	98 27       	eor	r25, r24
    b0dc:	c8 0f       	add	r28, r24
    b0de:	d9 1f       	adc	r29, r25

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    b0e0:	fe 01       	movw	r30, r28
    b0e2:	84 91       	lpm	r24, Z+
	switch(prb(&Field->Type)) {
    b0e4:	e8 2f       	mov	r30, r24
    b0e6:	f0 e0       	ldi	r31, 0x00	; 0
    b0e8:	e3 32       	cpi	r30, 0x23	; 35
    b0ea:	f1 05       	cpc	r31, r1
    b0ec:	08 f0       	brcs	.+2      	; 0xb0f0 <MenuUD+0xa2>
    b0ee:	c3 cf       	rjmp	.-122    	; 0xb076 <MenuUD+0x28>
    b0f0:	ea 54       	subi	r30, 0x4A	; 74
    b0f2:	ff 4f       	sbci	r31, 0xFF	; 255
    b0f4:	ee 0f       	add	r30, r30
    b0f6:	ff 1f       	adc	r31, r31
    b0f8:	05 90       	lpm	r0, Z+
    b0fa:	f4 91       	lpm	r31, Z+
    b0fc:	e0 2d       	mov	r30, r0
    b0fe:	19 94       	eijmp

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    b100:	fe 01       	movw	r30, r28
    b102:	33 96       	adiw	r30, 0x03	; 3
    b104:	85 91       	lpm	r24, Z+
    b106:	95 91       	lpm	r25, Z+
    b108:	a5 91       	lpm	r26, Z+
    b10a:	b4 91       	lpm	r27, Z+
		break;
	case Bit: case EE_Bit:
		F_Buf = !F_Buf;
		break;
	case Text: case EE_Text:
		if( (prd(&Field->Min) == DIGIT) && (prd(&Field->Max) == DIGIT) ){
    b10c:	00 97       	sbiw	r24, 0x00	; 0
    b10e:	a1 05       	cpc	r26, r1
    b110:	b1 05       	cpc	r27, r1
    b112:	09 f0       	breq	.+2      	; 0xb116 <MenuUD+0xc8>
    b114:	1e c1       	rjmp	.+572    	; 0xb352 <MenuUD+0x304>
    b116:	fe 01       	movw	r30, r28
    b118:	37 96       	adiw	r30, 0x07	; 7
    b11a:	85 91       	lpm	r24, Z+
    b11c:	95 91       	lpm	r25, Z+
    b11e:	a5 91       	lpm	r26, Z+
    b120:	b4 91       	lpm	r27, Z+
    b122:	00 97       	sbiw	r24, 0x00	; 0
    b124:	a1 05       	cpc	r26, r1
    b126:	b1 05       	cpc	r27, r1
    b128:	09 f0       	breq	.+2      	; 0xb12c <MenuUD+0xde>
    b12a:	13 c1       	rjmp	.+550    	; 0xb352 <MenuUD+0x304>
			if(Dir==1){	if(++MultiSymbol > 9) MultiSymbol = 0;}
    b12c:	31 e0       	ldi	r19, 0x01	; 1
    b12e:	e3 16       	cp	r14, r19
    b130:	09 f4       	brne	.+2      	; 0xb134 <MenuUD+0xe6>
    b132:	92 c1       	rjmp	.+804    	; 0xb458 <MenuUD+0x40a>
			else{		if(--MultiSymbol == 255) MultiSymbol = 9;}
    b134:	80 91 f2 04 	lds	r24, 0x04F2
    b138:	81 50       	subi	r24, 0x01	; 1
    b13a:	80 93 f2 04 	sts	0x04F2, r24
    b13e:	8f 3f       	cpi	r24, 0xFF	; 255
    b140:	09 f4       	brne	.+2      	; 0xb144 <MenuUD+0xf6>
    b142:	93 c1       	rjmp	.+806    	; 0xb46a <MenuUD+0x41c>
		}
		else{
			if(Dir==1){	if(++MultiSymbol >= strlen_P(Symbols_P)) MultiSymbol = 0;}
			else{		if(--MultiSymbol == 255) MultiSymbol = strlen_P(Symbols_P)-1;}
		}
		if(CurrPos!=NullPos)
    b144:	90 91 d7 02 	lds	r25, 0x02D7
    b148:	9f 3f       	cpi	r25, 0xFF	; 255
    b14a:	09 f4       	brne	.+2      	; 0xb14e <MenuUD+0x100>
    b14c:	94 cf       	rjmp	.-216    	; 0xb076 <MenuUD+0x28>

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    b14e:	80 91 f2 04 	lds	r24, 0x04F2
    b152:	e8 2f       	mov	r30, r24
    b154:	f0 e0       	ldi	r31, 0x00	; 0
    b156:	eb 5f       	subi	r30, 0xFB	; 251
    b158:	f9 4f       	sbci	r31, 0xF9	; 249
	case Longint: case z_Longint: case EE_Longint: case z_EE_Longint: case s_Longint: case s_EE_Longint:
	case FFloat: case EE_FFloat: case GFloat: case EE_GFloat:
		if(Dir==1)	{if(++MultiSymbol >= strlen_P(Digits_P)) MultiSymbol = 0;}
		else 		{if(--MultiSymbol == 255) MultiSymbol = strlen_P(Digits_P)-1;}
		if(CurrPos!=NullPos)
			BufStr[CurrFieldSize - 1 - CurrPos] = prc(Digits_P + MultiSymbol);
    b15a:	84 91       	lpm	r24, Z+
    b15c:	e0 91 7a 07 	lds	r30, 0x077A
    b160:	f0 e0       	ldi	r31, 0x00	; 0
    b162:	31 97       	sbiw	r30, 0x01	; 1
    b164:	e9 1b       	sub	r30, r25
    b166:	f1 09       	sbc	r31, r1
    b168:	ef 53       	subi	r30, 0x3F	; 63
    b16a:	fa 4f       	sbci	r31, 0xFA	; 250
    b16c:	80 83       	st	Z, r24
    b16e:	83 cf       	rjmp	.-250    	; 0xb076 <MenuUD+0x28>
	case Enum: case EE_Enum:
		if(LimVar)
			F_Buf += Dir;
		break;
	case Bit: case EE_Bit:
		F_Buf = !F_Buf;
    b170:	20 e0       	ldi	r18, 0x00	; 0
    b172:	30 e0       	ldi	r19, 0x00	; 0
    b174:	40 e0       	ldi	r20, 0x00	; 0
    b176:	50 e0       	ldi	r21, 0x00	; 0
    b178:	80 91 f5 04 	lds	r24, 0x04F5
    b17c:	90 91 f6 04 	lds	r25, 0x04F6
    b180:	a0 91 f7 04 	lds	r26, 0x04F7
    b184:	b0 91 f8 04 	lds	r27, 0x04F8
    b188:	00 97       	sbiw	r24, 0x00	; 0
    b18a:	a1 05       	cpc	r26, r1
    b18c:	b1 05       	cpc	r27, r1
    b18e:	21 f4       	brne	.+8      	; 0xb198 <MenuUD+0x14a>
    b190:	21 e0       	ldi	r18, 0x01	; 1
    b192:	30 e0       	ldi	r19, 0x00	; 0
    b194:	40 e0       	ldi	r20, 0x00	; 0
    b196:	50 e0       	ldi	r21, 0x00	; 0
    b198:	20 93 f5 04 	sts	0x04F5, r18
    b19c:	30 93 f6 04 	sts	0x04F6, r19
    b1a0:	40 93 f7 04 	sts	0x04F7, r20
    b1a4:	50 93 f8 04 	sts	0x04F8, r21
    b1a8:	66 cf       	rjmp	.-308    	; 0xb076 <MenuUD+0x28>
			Buf2Field(Field);
			Field2Buf(Field);
		}
		break;
	case Enum: case EE_Enum:
		if(LimVar)
    b1aa:	00 23       	and	r16, r16
    b1ac:	09 f4       	brne	.+2      	; 0xb1b0 <MenuUD+0x162>
    b1ae:	63 cf       	rjmp	.-314    	; 0xb076 <MenuUD+0x28>
			F_Buf += Dir;
    b1b0:	2e 2d       	mov	r18, r14
    b1b2:	33 27       	eor	r19, r19
    b1b4:	27 fd       	sbrc	r18, 7
    b1b6:	30 95       	com	r19
    b1b8:	43 2f       	mov	r20, r19
    b1ba:	53 2f       	mov	r21, r19
    b1bc:	80 91 f5 04 	lds	r24, 0x04F5
    b1c0:	90 91 f6 04 	lds	r25, 0x04F6
    b1c4:	a0 91 f7 04 	lds	r26, 0x04F7
    b1c8:	b0 91 f8 04 	lds	r27, 0x04F8
    b1cc:	82 0f       	add	r24, r18
    b1ce:	93 1f       	adc	r25, r19
    b1d0:	a4 1f       	adc	r26, r20
    b1d2:	b5 1f       	adc	r27, r21
    b1d4:	80 93 f5 04 	sts	0x04F5, r24
    b1d8:	90 93 f6 04 	sts	0x04F6, r25
    b1dc:	a0 93 f7 04 	sts	0x04F7, r26
    b1e0:	b0 93 f8 04 	sts	0x04F8, r27
    b1e4:	48 cf       	rjmp	.-368    	; 0xb076 <MenuUD+0x28>
		if(CurrPos!=NullPos)
			BufStr[CurrFieldSize - 1 - CurrPos] = prc(Symbols_P + MultiSymbol);
		break;
	case Longint: case z_Longint: case EE_Longint: case z_EE_Longint: case s_Longint: case s_EE_Longint:
	case FFloat: case EE_FFloat: case GFloat: case EE_GFloat:
		if(Dir==1)	{if(++MultiSymbol >= strlen_P(Digits_P)) MultiSymbol = 0;}
    b1e6:	51 e0       	ldi	r21, 0x01	; 1
    b1e8:	e5 16       	cp	r14, r21
    b1ea:	09 f4       	brne	.+2      	; 0xb1ee <MenuUD+0x1a0>
    b1ec:	fb c0       	rjmp	.+502    	; 0xb3e4 <MenuUD+0x396>
		else 		{if(--MultiSymbol == 255) MultiSymbol = strlen_P(Digits_P)-1;}
    b1ee:	80 91 f2 04 	lds	r24, 0x04F2
    b1f2:	81 50       	subi	r24, 0x01	; 1
    b1f4:	80 93 f2 04 	sts	0x04F2, r24
    b1f8:	8f 3f       	cpi	r24, 0xFF	; 255
    b1fa:	09 f4       	brne	.+2      	; 0xb1fe <MenuUD+0x1b0>
    b1fc:	14 c1       	rjmp	.+552    	; 0xb426 <MenuUD+0x3d8>
		if(CurrPos!=NullPos)
    b1fe:	90 91 d7 02 	lds	r25, 0x02D7
    b202:	9f 3f       	cpi	r25, 0xFF	; 255
    b204:	09 f4       	brne	.+2      	; 0xb208 <MenuUD+0x1ba>
    b206:	37 cf       	rjmp	.-402    	; 0xb076 <MenuUD+0x28>
    b208:	80 91 f2 04 	lds	r24, 0x04F2
    b20c:	e8 2f       	mov	r30, r24
    b20e:	f0 e0       	ldi	r31, 0x00	; 0
    b210:	e2 55       	subi	r30, 0x52	; 82
    b212:	f9 4f       	sbci	r31, 0xF9	; 249
    b214:	a2 cf       	rjmp	.-188    	; 0xb15a <MenuUD+0x10c>
			sF_Buf += Inc(Dir, sF_Buf);
		else if(sF_Buf<0 || sF_Buf==0 && Minus)
			Minus = (sF_Buf-=Inc(Dir, -sF_Buf))==0;
		break;
	case c_Word: case zc_Word:
		if(LimVar) {
    b216:	00 23       	and	r16, r16
    b218:	09 f4       	brne	.+2      	; 0xb21c <MenuUD+0x1ce>
    b21a:	2d cf       	rjmp	.-422    	; 0xb076 <MenuUD+0x28>
			F_Buf += Dir;
    b21c:	2e 2d       	mov	r18, r14
    b21e:	33 27       	eor	r19, r19
    b220:	27 fd       	sbrc	r18, 7
    b222:	30 95       	com	r19
    b224:	43 2f       	mov	r20, r19
    b226:	53 2f       	mov	r21, r19
    b228:	80 91 f5 04 	lds	r24, 0x04F5
    b22c:	90 91 f6 04 	lds	r25, 0x04F6
    b230:	a0 91 f7 04 	lds	r26, 0x04F7
    b234:	b0 91 f8 04 	lds	r27, 0x04F8
    b238:	82 0f       	add	r24, r18
    b23a:	93 1f       	adc	r25, r19
    b23c:	a4 1f       	adc	r26, r20
    b23e:	b5 1f       	adc	r27, r21
    b240:	80 93 f5 04 	sts	0x04F5, r24
    b244:	90 93 f6 04 	sts	0x04F6, r25
    b248:	a0 93 f7 04 	sts	0x04F7, r26
    b24c:	b0 93 f8 04 	sts	0x04F8, r27
			Buf2Field(Field);
    b250:	ce 01       	movw	r24, r28
    b252:	0e 94 8b 53 	call	0xa716	; 0xa716 <Buf2Field>
			Field2Buf(Field);
    b256:	ce 01       	movw	r24, r28
    b258:	0e 94 d3 4f 	call	0x9fa6	; 0x9fa6 <Field2Buf>
    b25c:	0c cf       	rjmp	.-488    	; 0xb076 <MenuUD+0x28>
	case Word: case EE_Word: case z_Word: case z_EE_Word:
		F_Buf += Inc(Dir, F_Buf);
		break;
	case s_Byte: case s_EE_Byte:
	case s_Word: case s_EE_Word:
		if(CurrPos==Log10(prd(&Field->Max))+1) {
    b25e:	00 91 d7 02 	lds	r16, 0x02D7
    b262:	10 e0       	ldi	r17, 0x00	; 0

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    b264:	fe 01       	movw	r30, r28
    b266:	37 96       	adiw	r30, 0x07	; 7
    b268:	65 91       	lpm	r22, Z+
    b26a:	75 91       	lpm	r23, Z+
    b26c:	85 91       	lpm	r24, Z+
    b26e:	94 91       	lpm	r25, Z+
    b270:	0e 94 b8 20 	call	0x4170	; 0x4170 <Log10>
    b274:	90 e0       	ldi	r25, 0x00	; 0
    b276:	01 96       	adiw	r24, 0x01	; 1
    b278:	08 17       	cp	r16, r24
    b27a:	19 07       	cpc	r17, r25
    b27c:	09 f4       	brne	.+2      	; 0xb280 <MenuUD+0x232>
    b27e:	9c c0       	rjmp	.+312    	; 0xb3b8 <MenuUD+0x36a>
			if(sF_Buf==0)
				Minus = !Minus;
			else
				sF_Buf = -sF_Buf;
		}
		else if(sF_Buf>0 || sF_Buf==0 && !Minus)
    b280:	a0 90 f9 04 	lds	r10, 0x04F9
    b284:	b0 90 fa 04 	lds	r11, 0x04FA
    b288:	c0 90 fb 04 	lds	r12, 0x04FB
    b28c:	d0 90 fc 04 	lds	r13, 0x04FC
    b290:	1a 14       	cp	r1, r10
    b292:	1b 04       	cpc	r1, r11
    b294:	1c 04       	cpc	r1, r12
    b296:	1d 04       	cpc	r1, r13
    b298:	0c f4       	brge	.+2      	; 0xb29c <MenuUD+0x24e>
    b29a:	74 c0       	rjmp	.+232    	; 0xb384 <MenuUD+0x336>
    b29c:	a1 14       	cp	r10, r1
    b29e:	b1 04       	cpc	r11, r1
    b2a0:	c1 04       	cpc	r12, r1
    b2a2:	d1 04       	cpc	r13, r1
    b2a4:	09 f4       	brne	.+2      	; 0xb2a8 <MenuUD+0x25a>
    b2a6:	69 c0       	rjmp	.+210    	; 0xb37a <MenuUD+0x32c>
			sF_Buf += Inc(Dir, sF_Buf);
		else if(sF_Buf<0 || sF_Buf==0 && Minus)
			Minus = (sF_Buf-=Inc(Dir, -sF_Buf))==0;
    b2a8:	44 27       	eor	r20, r20
    b2aa:	55 27       	eor	r21, r21
    b2ac:	ba 01       	movw	r22, r20
    b2ae:	4a 19       	sub	r20, r10
    b2b0:	5b 09       	sbc	r21, r11
    b2b2:	6c 09       	sbc	r22, r12
    b2b4:	7d 09       	sbc	r23, r13
    b2b6:	8e 2d       	mov	r24, r14
    b2b8:	0e 94 07 3d 	call	0x7a0e	; 0x7a0e <Inc>
    b2bc:	a6 01       	movw	r20, r12
    b2be:	95 01       	movw	r18, r10
    b2c0:	26 1b       	sub	r18, r22
    b2c2:	37 0b       	sbc	r19, r23
    b2c4:	48 0b       	sbc	r20, r24
    b2c6:	59 0b       	sbc	r21, r25
    b2c8:	20 93 f9 04 	sts	0x04F9, r18
    b2cc:	30 93 fa 04 	sts	0x04FA, r19
    b2d0:	40 93 fb 04 	sts	0x04FB, r20
    b2d4:	50 93 fc 04 	sts	0x04FC, r21
    b2d8:	10 92 fd 04 	sts	0x04FD, r1
    b2dc:	21 15       	cp	r18, r1
    b2de:	31 05       	cpc	r19, r1
    b2e0:	41 05       	cpc	r20, r1
    b2e2:	51 05       	cpc	r21, r1
    b2e4:	09 f0       	breq	.+2      	; 0xb2e8 <MenuUD+0x29a>
    b2e6:	c7 ce       	rjmp	.-626    	; 0xb076 <MenuUD+0x28>
    b2e8:	81 e0       	ldi	r24, 0x01	; 1
    b2ea:	80 93 fd 04 	sts	0x04FD, r24
    b2ee:	c3 ce       	rjmp	.-634    	; 0xb076 <MenuUD+0x28>
	Blink=0;
	OutField *Field=GetField;
	switch(prb(&Field->Type)) {
	case Byte: case EE_Byte: case z_Byte: case z_EE_Byte:
	case Word: case EE_Word: case z_Word: case z_EE_Word:
		F_Buf += Inc(Dir, F_Buf);
    b2f0:	40 91 f5 04 	lds	r20, 0x04F5
    b2f4:	50 91 f6 04 	lds	r21, 0x04F6
    b2f8:	60 91 f7 04 	lds	r22, 0x04F7
    b2fc:	70 91 f8 04 	lds	r23, 0x04F8
    b300:	8e 2d       	mov	r24, r14
    b302:	0e 94 07 3d 	call	0x7a0e	; 0x7a0e <Inc>
    b306:	20 91 f5 04 	lds	r18, 0x04F5
    b30a:	30 91 f6 04 	lds	r19, 0x04F6
    b30e:	40 91 f7 04 	lds	r20, 0x04F7
    b312:	50 91 f8 04 	lds	r21, 0x04F8
    b316:	26 0f       	add	r18, r22
    b318:	37 1f       	adc	r19, r23
    b31a:	48 1f       	adc	r20, r24
    b31c:	59 1f       	adc	r21, r25
    b31e:	20 93 f5 04 	sts	0x04F5, r18
    b322:	30 93 f6 04 	sts	0x04F6, r19
    b326:	40 93 f7 04 	sts	0x04F7, r20
    b32a:	50 93 f8 04 	sts	0x04F8, r21
    b32e:	a3 ce       	rjmp	.-698    	; 0xb076 <MenuUD+0x28>
MenuUD(const MenuKey *Key, int8_t Dir, uint8_t LimLine, uint8_t LimLCD, uint8_t LimVar)
{
	if(CurrMsg || KeyFunc(Key))
		return;
	if(CurrField==NullPos) {
		if(LimLine) {
    b330:	11 23       	and	r17, r17
    b332:	09 f4       	brne	.+2      	; 0xb336 <MenuUD+0x2e8>
    b334:	a0 ce       	rjmp	.-704    	; 0xb076 <MenuUD+0x28>
			CurrLine -= Dir;
    b336:	80 91 83 07 	lds	r24, 0x0783
    b33a:	8e 19       	sub	r24, r14
    b33c:	80 93 83 07 	sts	0x0783, r24
			if(LimLCD)
    b340:	ff 20       	and	r15, r15
    b342:	09 f4       	brne	.+2      	; 0xb346 <MenuUD+0x2f8>
    b344:	98 ce       	rjmp	.-720    	; 0xb076 <MenuUD+0x28>
				CurrLCD -= Dir;
    b346:	80 91 a0 08 	lds	r24, 0x08A0
    b34a:	8e 19       	sub	r24, r14
    b34c:	80 93 a0 08 	sts	0x08A0, r24
    b350:	92 ce       	rjmp	.-732    	; 0xb076 <MenuUD+0x28>
		if( (prd(&Field->Min) == DIGIT) && (prd(&Field->Max) == DIGIT) ){
			if(Dir==1){	if(++MultiSymbol > 9) MultiSymbol = 0;}
			else{		if(--MultiSymbol == 255) MultiSymbol = 9;}
		}
		else{
			if(Dir==1){	if(++MultiSymbol >= strlen_P(Symbols_P)) MultiSymbol = 0;}
    b352:	41 e0       	ldi	r20, 0x01	; 1
    b354:	e4 16       	cp	r14, r20
    b356:	09 f4       	brne	.+2      	; 0xb35a <MenuUD+0x30c>
    b358:	6e c0       	rjmp	.+220    	; 0xb436 <MenuUD+0x3e8>
			else{		if(--MultiSymbol == 255) MultiSymbol = strlen_P(Symbols_P)-1;}
    b35a:	80 91 f2 04 	lds	r24, 0x04F2
    b35e:	81 50       	subi	r24, 0x01	; 1
    b360:	80 93 f2 04 	sts	0x04F2, r24
    b364:	8f 3f       	cpi	r24, 0xFF	; 255
    b366:	09 f0       	breq	.+2      	; 0xb36a <MenuUD+0x31c>
    b368:	ed ce       	rjmp	.-550    	; 0xb144 <MenuUD+0xf6>
    b36a:	85 e0       	ldi	r24, 0x05	; 5
    b36c:	96 e0       	ldi	r25, 0x06	; 6
    b36e:	0e 94 c1 7e 	call	0xfd82	; 0xfd82 <strlen_P>
    b372:	81 50       	subi	r24, 0x01	; 1
    b374:	80 93 f2 04 	sts	0x04F2, r24
    b378:	e5 ce       	rjmp	.-566    	; 0xb144 <MenuUD+0xf6>
			if(sF_Buf==0)
				Minus = !Minus;
			else
				sF_Buf = -sF_Buf;
		}
		else if(sF_Buf>0 || sF_Buf==0 && !Minus)
    b37a:	80 91 fd 04 	lds	r24, 0x04FD
    b37e:	88 23       	and	r24, r24
    b380:	09 f0       	breq	.+2      	; 0xb384 <MenuUD+0x336>
    b382:	92 cf       	rjmp	.-220    	; 0xb2a8 <MenuUD+0x25a>
			sF_Buf += Inc(Dir, sF_Buf);
    b384:	8e 2d       	mov	r24, r14
    b386:	b6 01       	movw	r22, r12
    b388:	a5 01       	movw	r20, r10
    b38a:	0e 94 07 3d 	call	0x7a0e	; 0x7a0e <Inc>
    b38e:	20 91 f9 04 	lds	r18, 0x04F9
    b392:	30 91 fa 04 	lds	r19, 0x04FA
    b396:	40 91 fb 04 	lds	r20, 0x04FB
    b39a:	50 91 fc 04 	lds	r21, 0x04FC
    b39e:	26 0f       	add	r18, r22
    b3a0:	37 1f       	adc	r19, r23
    b3a2:	48 1f       	adc	r20, r24
    b3a4:	59 1f       	adc	r21, r25
    b3a6:	20 93 f9 04 	sts	0x04F9, r18
    b3aa:	30 93 fa 04 	sts	0x04FA, r19
    b3ae:	40 93 fb 04 	sts	0x04FB, r20
    b3b2:	50 93 fc 04 	sts	0x04FC, r21
    b3b6:	5f ce       	rjmp	.-834    	; 0xb076 <MenuUD+0x28>
		F_Buf += Inc(Dir, F_Buf);
		break;
	case s_Byte: case s_EE_Byte:
	case s_Word: case s_EE_Word:
		if(CurrPos==Log10(prd(&Field->Max))+1) {
			if(sF_Buf==0)
    b3b8:	20 91 f9 04 	lds	r18, 0x04F9
    b3bc:	30 91 fa 04 	lds	r19, 0x04FA
    b3c0:	40 91 fb 04 	lds	r20, 0x04FB
    b3c4:	50 91 fc 04 	lds	r21, 0x04FC
    b3c8:	21 15       	cp	r18, r1
    b3ca:	31 05       	cpc	r19, r1
    b3cc:	41 05       	cpc	r20, r1
    b3ce:	51 05       	cpc	r21, r1
    b3d0:	d1 f4       	brne	.+52     	; 0xb406 <MenuUD+0x3b8>
				Minus = !Minus;
    b3d2:	90 e0       	ldi	r25, 0x00	; 0
    b3d4:	80 91 fd 04 	lds	r24, 0x04FD
    b3d8:	88 23       	and	r24, r24
    b3da:	09 f4       	brne	.+2      	; 0xb3de <MenuUD+0x390>
    b3dc:	91 e0       	ldi	r25, 0x01	; 1
    b3de:	90 93 fd 04 	sts	0x04FD, r25
    b3e2:	49 ce       	rjmp	.-878    	; 0xb076 <MenuUD+0x28>
		if(CurrPos!=NullPos)
			BufStr[CurrFieldSize - 1 - CurrPos] = prc(Symbols_P + MultiSymbol);
		break;
	case Longint: case z_Longint: case EE_Longint: case z_EE_Longint: case s_Longint: case s_EE_Longint:
	case FFloat: case EE_FFloat: case GFloat: case EE_GFloat:
		if(Dir==1)	{if(++MultiSymbol >= strlen_P(Digits_P)) MultiSymbol = 0;}
    b3e4:	00 91 f2 04 	lds	r16, 0x04F2
    b3e8:	0f 5f       	subi	r16, 0xFF	; 255
    b3ea:	00 93 f2 04 	sts	0x04F2, r16
    b3ee:	8e ea       	ldi	r24, 0xAE	; 174
    b3f0:	96 e0       	ldi	r25, 0x06	; 6
    b3f2:	0e 94 c1 7e 	call	0xfd82	; 0xfd82 <strlen_P>
    b3f6:	10 e0       	ldi	r17, 0x00	; 0
    b3f8:	08 17       	cp	r16, r24
    b3fa:	19 07       	cpc	r17, r25
    b3fc:	08 f4       	brcc	.+2      	; 0xb400 <MenuUD+0x3b2>
    b3fe:	ff ce       	rjmp	.-514    	; 0xb1fe <MenuUD+0x1b0>
    b400:	10 92 f2 04 	sts	0x04F2, r1
    b404:	fc ce       	rjmp	.-520    	; 0xb1fe <MenuUD+0x1b0>
	case s_Word: case s_EE_Word:
		if(CurrPos==Log10(prd(&Field->Max))+1) {
			if(sF_Buf==0)
				Minus = !Minus;
			else
				sF_Buf = -sF_Buf;
    b406:	88 27       	eor	r24, r24
    b408:	99 27       	eor	r25, r25
    b40a:	dc 01       	movw	r26, r24
    b40c:	82 1b       	sub	r24, r18
    b40e:	93 0b       	sbc	r25, r19
    b410:	a4 0b       	sbc	r26, r20
    b412:	b5 0b       	sbc	r27, r21
    b414:	80 93 f9 04 	sts	0x04F9, r24
    b418:	90 93 fa 04 	sts	0x04FA, r25
    b41c:	a0 93 fb 04 	sts	0x04FB, r26
    b420:	b0 93 fc 04 	sts	0x04FC, r27
    b424:	28 ce       	rjmp	.-944    	; 0xb076 <MenuUD+0x28>
			BufStr[CurrFieldSize - 1 - CurrPos] = prc(Symbols_P + MultiSymbol);
		break;
	case Longint: case z_Longint: case EE_Longint: case z_EE_Longint: case s_Longint: case s_EE_Longint:
	case FFloat: case EE_FFloat: case GFloat: case EE_GFloat:
		if(Dir==1)	{if(++MultiSymbol >= strlen_P(Digits_P)) MultiSymbol = 0;}
		else 		{if(--MultiSymbol == 255) MultiSymbol = strlen_P(Digits_P)-1;}
    b426:	8e ea       	ldi	r24, 0xAE	; 174
    b428:	96 e0       	ldi	r25, 0x06	; 6
    b42a:	0e 94 c1 7e 	call	0xfd82	; 0xfd82 <strlen_P>
    b42e:	81 50       	subi	r24, 0x01	; 1
    b430:	80 93 f2 04 	sts	0x04F2, r24
    b434:	e4 ce       	rjmp	.-568    	; 0xb1fe <MenuUD+0x1b0>
		if( (prd(&Field->Min) == DIGIT) && (prd(&Field->Max) == DIGIT) ){
			if(Dir==1){	if(++MultiSymbol > 9) MultiSymbol = 0;}
			else{		if(--MultiSymbol == 255) MultiSymbol = 9;}
		}
		else{
			if(Dir==1){	if(++MultiSymbol >= strlen_P(Symbols_P)) MultiSymbol = 0;}
    b436:	00 91 f2 04 	lds	r16, 0x04F2
    b43a:	0f 5f       	subi	r16, 0xFF	; 255
    b43c:	00 93 f2 04 	sts	0x04F2, r16
    b440:	85 e0       	ldi	r24, 0x05	; 5
    b442:	96 e0       	ldi	r25, 0x06	; 6
    b444:	0e 94 c1 7e 	call	0xfd82	; 0xfd82 <strlen_P>
    b448:	10 e0       	ldi	r17, 0x00	; 0
    b44a:	08 17       	cp	r16, r24
    b44c:	19 07       	cpc	r17, r25
    b44e:	08 f4       	brcc	.+2      	; 0xb452 <MenuUD+0x404>
    b450:	79 ce       	rjmp	.-782    	; 0xb144 <MenuUD+0xf6>
    b452:	10 92 f2 04 	sts	0x04F2, r1
    b456:	76 ce       	rjmp	.-788    	; 0xb144 <MenuUD+0xf6>
	case Bit: case EE_Bit:
		F_Buf = !F_Buf;
		break;
	case Text: case EE_Text:
		if( (prd(&Field->Min) == DIGIT) && (prd(&Field->Max) == DIGIT) ){
			if(Dir==1){	if(++MultiSymbol > 9) MultiSymbol = 0;}
    b458:	80 91 f2 04 	lds	r24, 0x04F2
    b45c:	8f 5f       	subi	r24, 0xFF	; 255
    b45e:	80 93 f2 04 	sts	0x04F2, r24
    b462:	8a 30       	cpi	r24, 0x0A	; 10
    b464:	08 f4       	brcc	.+2      	; 0xb468 <MenuUD+0x41a>
    b466:	6e ce       	rjmp	.-804    	; 0xb144 <MenuUD+0xf6>
    b468:	f4 cf       	rjmp	.-24     	; 0xb452 <MenuUD+0x404>
			else{		if(--MultiSymbol == 255) MultiSymbol = 9;}
    b46a:	89 e0       	ldi	r24, 0x09	; 9
    b46c:	80 93 f2 04 	sts	0x04F2, r24
    b470:	69 ce       	rjmp	.-814    	; 0xb144 <MenuUD+0xf6>

0000b472 <MenuDown>:
}

// ~~~~~~~~~~~
void
MenuDown(void)
{
    b472:	ef 92       	push	r14
    b474:	ff 92       	push	r15
    b476:	0f 93       	push	r16
    b478:	1f 93       	push	r17
    b47a:	cf 93       	push	r28
    b47c:	df 93       	push	r29
	MenuUD(&CurrPage->Down, -1, prb(&CurrPage->LineNumber)-CurrLine>1, CurrLCD<LCDYSz-1, F_Buf>prd(&GetField->Min));
    b47e:	c0 91 d4 02 	lds	r28, 0x02D4
    b482:	d0 91 d5 02 	lds	r29, 0x02D5

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    b486:	22 96       	adiw	r28, 0x02	; 2
    b488:	fe 01       	movw	r30, r28
    b48a:	24 91       	lpm	r18, Z+
    b48c:	22 97       	sbiw	r28, 0x02	; 2
    b48e:	40 91 83 07 	lds	r20, 0x0783

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    b492:	fe 01       	movw	r30, r28
    b494:	65 91       	lpm	r22, Z+
    b496:	74 91       	lpm	r23, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    b498:	8b e1       	ldi	r24, 0x1B	; 27
    b49a:	48 9f       	mul	r20, r24
    b49c:	c0 01       	movw	r24, r0
    b49e:	11 24       	eor	r1, r1
    b4a0:	68 0f       	add	r22, r24
    b4a2:	79 1f       	adc	r23, r25
    b4a4:	69 5e       	subi	r22, 0xE9	; 233
    b4a6:	7f 4f       	sbci	r23, 0xFF	; 255
    b4a8:	fb 01       	movw	r30, r22
    b4aa:	a5 91       	lpm	r26, Z+
    b4ac:	b4 91       	lpm	r27, Z+
    b4ae:	80 91 d6 02 	lds	r24, 0x02D6
    b4b2:	90 e0       	ldi	r25, 0x00	; 0
    b4b4:	82 95       	swap	r24
    b4b6:	92 95       	swap	r25
    b4b8:	90 7f       	andi	r25, 0xF0	; 240
    b4ba:	98 27       	eor	r25, r24
    b4bc:	80 7f       	andi	r24, 0xF0	; 240
    b4be:	98 27       	eor	r25, r24
    b4c0:	a8 0f       	add	r26, r24
    b4c2:	b9 1f       	adc	r27, r25
    b4c4:	13 96       	adiw	r26, 0x03	; 3
    b4c6:	fd 01       	movw	r30, r26
    b4c8:	e5 90       	lpm	r14, Z+
    b4ca:	f5 90       	lpm	r15, Z+
    b4cc:	05 91       	lpm	r16, Z+
    b4ce:	14 91       	lpm	r17, Z+
    b4d0:	fe 01       	movw	r30, r28
    b4d2:	72 96       	adiw	r30, 0x12	; 18
    b4d4:	50 e0       	ldi	r21, 0x00	; 0
    b4d6:	30 e0       	ldi	r19, 0x00	; 0
    b4d8:	24 1b       	sub	r18, r20
    b4da:	31 09       	sbc	r19, r1
    b4dc:	22 30       	cpi	r18, 0x02	; 2
    b4de:	31 05       	cpc	r19, r1
    b4e0:	0c f0       	brlt	.+2      	; 0xb4e4 <MenuDown+0x72>
    b4e2:	51 e0       	ldi	r21, 0x01	; 1
    b4e4:	20 e0       	ldi	r18, 0x00	; 0
    b4e6:	80 91 a0 08 	lds	r24, 0x08A0
    b4ea:	83 30       	cpi	r24, 0x03	; 3
    b4ec:	08 f4       	brcc	.+2      	; 0xb4f0 <MenuDown+0x7e>
    b4ee:	21 e0       	ldi	r18, 0x01	; 1
    b4f0:	30 e0       	ldi	r19, 0x00	; 0
    b4f2:	80 91 f5 04 	lds	r24, 0x04F5
    b4f6:	90 91 f6 04 	lds	r25, 0x04F6
    b4fa:	a0 91 f7 04 	lds	r26, 0x04F7
    b4fe:	b0 91 f8 04 	lds	r27, 0x04F8
    b502:	e8 16       	cp	r14, r24
    b504:	f9 06       	cpc	r15, r25
    b506:	0a 07       	cpc	r16, r26
    b508:	1b 07       	cpc	r17, r27
    b50a:	08 f4       	brcc	.+2      	; 0xb50e <MenuDown+0x9c>
    b50c:	31 e0       	ldi	r19, 0x01	; 1
    b50e:	cf 01       	movw	r24, r30
    b510:	6f ef       	ldi	r22, 0xFF	; 255
    b512:	45 2f       	mov	r20, r21
    b514:	03 2f       	mov	r16, r19
    b516:	0e 94 27 58 	call	0xb04e	; 0xb04e <MenuUD>
}
    b51a:	df 91       	pop	r29
    b51c:	cf 91       	pop	r28
    b51e:	1f 91       	pop	r17
    b520:	0f 91       	pop	r16
    b522:	ff 90       	pop	r15
    b524:	ef 90       	pop	r14
    b526:	08 95       	ret

0000b528 <MenuUp>:
}

// ~~~~~~~~~
void
MenuUp(void)
{
    b528:	ef 92       	push	r14
    b52a:	ff 92       	push	r15
    b52c:	0f 93       	push	r16
    b52e:	1f 93       	push	r17
	uint8_t Fix=GetFix();
    b530:	a0 91 d4 02 	lds	r26, 0x02D4
    b534:	b0 91 d5 02 	lds	r27, 0x02D5

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    b538:	13 96       	adiw	r26, 0x03	; 3
    b53a:	fd 01       	movw	r30, r26
    b53c:	34 91       	lpm	r19, Z+
    b53e:	13 97       	sbiw	r26, 0x03	; 3
	MenuUD(&CurrPage->Up, 1, CurrLine>Fix, CurrLCD>Fix, F_Buf<prd(&GetField->Max));
    b540:	20 91 83 07 	lds	r18, 0x0783

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    b544:	fd 01       	movw	r30, r26
    b546:	45 91       	lpm	r20, Z+
    b548:	54 91       	lpm	r21, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    b54a:	8b e1       	ldi	r24, 0x1B	; 27
    b54c:	28 9f       	mul	r18, r24
    b54e:	c0 01       	movw	r24, r0
    b550:	11 24       	eor	r1, r1
    b552:	48 0f       	add	r20, r24
    b554:	59 1f       	adc	r21, r25
    b556:	49 5e       	subi	r20, 0xE9	; 233
    b558:	5f 4f       	sbci	r21, 0xFF	; 255
    b55a:	fa 01       	movw	r30, r20
    b55c:	65 91       	lpm	r22, Z+
    b55e:	74 91       	lpm	r23, Z+
    b560:	80 91 d6 02 	lds	r24, 0x02D6
    b564:	90 e0       	ldi	r25, 0x00	; 0
    b566:	82 95       	swap	r24
    b568:	92 95       	swap	r25
    b56a:	90 7f       	andi	r25, 0xF0	; 240
    b56c:	98 27       	eor	r25, r24
    b56e:	80 7f       	andi	r24, 0xF0	; 240
    b570:	98 27       	eor	r25, r24
    b572:	68 0f       	add	r22, r24
    b574:	79 1f       	adc	r23, r25
    b576:	69 5f       	subi	r22, 0xF9	; 249
    b578:	7f 4f       	sbci	r23, 0xFF	; 255
    b57a:	fb 01       	movw	r30, r22
    b57c:	e5 90       	lpm	r14, Z+
    b57e:	f5 90       	lpm	r15, Z+
    b580:	05 91       	lpm	r16, Z+
    b582:	14 91       	lpm	r17, Z+
    b584:	fd 01       	movw	r30, r26
    b586:	70 96       	adiw	r30, 0x10	; 16
    b588:	40 e0       	ldi	r20, 0x00	; 0
    b58a:	32 17       	cp	r19, r18
    b58c:	08 f4       	brcc	.+2      	; 0xb590 <MenuUp+0x68>
    b58e:	41 e0       	ldi	r20, 0x01	; 1
    b590:	20 e0       	ldi	r18, 0x00	; 0
    b592:	80 91 a0 08 	lds	r24, 0x08A0
    b596:	38 17       	cp	r19, r24
    b598:	08 f4       	brcc	.+2      	; 0xb59c <MenuUp+0x74>
    b59a:	21 e0       	ldi	r18, 0x01	; 1
    b59c:	30 e0       	ldi	r19, 0x00	; 0
    b59e:	80 91 f5 04 	lds	r24, 0x04F5
    b5a2:	90 91 f6 04 	lds	r25, 0x04F6
    b5a6:	a0 91 f7 04 	lds	r26, 0x04F7
    b5aa:	b0 91 f8 04 	lds	r27, 0x04F8
    b5ae:	8e 15       	cp	r24, r14
    b5b0:	9f 05       	cpc	r25, r15
    b5b2:	a0 07       	cpc	r26, r16
    b5b4:	b1 07       	cpc	r27, r17
    b5b6:	08 f4       	brcc	.+2      	; 0xb5ba <MenuUp+0x92>
    b5b8:	31 e0       	ldi	r19, 0x01	; 1
    b5ba:	cf 01       	movw	r24, r30
    b5bc:	61 e0       	ldi	r22, 0x01	; 1
    b5be:	03 2f       	mov	r16, r19
    b5c0:	0e 94 27 58 	call	0xb04e	; 0xb04e <MenuUD>
}
    b5c4:	1f 91       	pop	r17
    b5c6:	0f 91       	pop	r16
    b5c8:	ff 90       	pop	r15
    b5ca:	ef 90       	pop	r14
    b5cc:	08 95       	ret

0000b5ce <PutField>:
	sprintf(Param->Pos, Format, Val);
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
PutField(uint8_t Type, void *Var, T_Param *Param)
{
    b5ce:	af 92       	push	r10
    b5d0:	bf 92       	push	r11
    b5d2:	cf 92       	push	r12
    b5d4:	df 92       	push	r13
    b5d6:	ef 92       	push	r14
    b5d8:	ff 92       	push	r15
    b5da:	0f 93       	push	r16
    b5dc:	1f 93       	push	r17
    b5de:	df 93       	push	r29
    b5e0:	cf 93       	push	r28
    b5e2:	cd b7       	in	r28, 0x3d	; 61
    b5e4:	de b7       	in	r29, 0x3e	; 62
    b5e6:	69 97       	sbiw	r28, 0x19	; 25
    b5e8:	0f b6       	in	r0, 0x3f	; 63
    b5ea:	f8 94       	cli
    b5ec:	de bf       	out	0x3e, r29	; 62
    b5ee:	0f be       	out	0x3f, r0	; 63
    b5f0:	cd bf       	out	0x3d, r28	; 61
    b5f2:	db 01       	movw	r26, r22
    b5f4:	7a 01       	movw	r14, r20
	float fTemp;

	switch(Type) {
    b5f6:	e8 2f       	mov	r30, r24
    b5f8:	f0 e0       	ldi	r31, 0x00	; 0
    b5fa:	e3 32       	cpi	r30, 0x23	; 35
    b5fc:	f1 05       	cpc	r31, r1
    b5fe:	88 f5       	brcc	.+98     	; 0xb662 <PutField+0x94>
    b600:	e7 52       	subi	r30, 0x27	; 39
    b602:	ff 4f       	sbci	r31, 0xFF	; 255
    b604:	ee 0f       	add	r30, r30
    b606:	ff 1f       	adc	r31, r31
    b608:	05 90       	lpm	r0, Z+
    b60a:	f4 91       	lpm	r31, Z+
    b60c:	e0 2d       	mov	r30, r0
    b60e:	19 94       	eijmp
		break;
	case Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((*((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
		break;
	case EE_Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((erb((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
    b610:	fa 01       	movw	r30, r20
    b612:	a0 80       	ld	r10, Z
    b614:	b1 80       	ldd	r11, Z+1	; 0x01
    b616:	c4 80       	ldd	r12, Z+4	; 0x04
    b618:	d5 80       	ldd	r13, Z+5	; 0x05
    b61a:	12 81       	ldd	r17, Z+2	; 0x02
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    b61c:	81 2f       	mov	r24, r17
    b61e:	86 95       	lsr	r24
    b620:	86 95       	lsr	r24
    b622:	86 95       	lsr	r24
    b624:	9b 01       	movw	r18, r22
    b626:	28 0f       	add	r18, r24
    b628:	31 1d       	adc	r19, r1
    b62a:	c9 01       	movw	r24, r18
    b62c:	0e 94 db 81 	call	0x103b6	; 0x103b6 <__eerd_byte_m2560>
    b630:	17 70       	andi	r17, 0x07	; 7
    b632:	21 e0       	ldi	r18, 0x01	; 1
    b634:	30 e0       	ldi	r19, 0x00	; 0
    b636:	02 c0       	rjmp	.+4      	; 0xb63c <PutField+0x6e>
    b638:	22 0f       	add	r18, r18
    b63a:	33 1f       	adc	r19, r19
    b63c:	1a 95       	dec	r17
    b63e:	e2 f7       	brpl	.-8      	; 0xb638 <PutField+0x6a>
    b640:	90 e0       	ldi	r25, 0x00	; 0
    b642:	28 23       	and	r18, r24
    b644:	39 23       	and	r19, r25
    b646:	12 16       	cp	r1, r18
    b648:	13 06       	cpc	r1, r19
    b64a:	0c f0       	brlt	.+2      	; 0xb64e <PutField+0x80>
    b64c:	3f c1       	rjmp	.+638    	; 0xb8cc <PutField+0x2fe>
    b64e:	82 e0       	ldi	r24, 0x02	; 2
    b650:	90 e0       	ldi	r25, 0x00	; 0

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    b652:	f6 01       	movw	r30, r12
    b654:	e8 0f       	add	r30, r24
    b656:	f9 1f       	adc	r31, r25
    b658:	65 91       	lpm	r22, Z+
    b65a:	74 91       	lpm	r23, Z+
    b65c:	c5 01       	movw	r24, r10
    b65e:	0e 94 ba 7e 	call	0xfd74	; 0xfd74 <strcpy_P>
			erbl(TempStr, Var, Param->Size);
			Put_TextValAlignRight(TempStr, Param);
		}
		break;
	}
}
    b662:	69 96       	adiw	r28, 0x19	; 25
    b664:	0f b6       	in	r0, 0x3f	; 63
    b666:	f8 94       	cli
    b668:	de bf       	out	0x3e, r29	; 62
    b66a:	0f be       	out	0x3f, r0	; 63
    b66c:	cd bf       	out	0x3d, r28	; 61
    b66e:	cf 91       	pop	r28
    b670:	df 91       	pop	r29
    b672:	1f 91       	pop	r17
    b674:	0f 91       	pop	r16
    b676:	ff 90       	pop	r15
    b678:	ef 90       	pop	r14
    b67a:	df 90       	pop	r13
    b67c:	cf 90       	pop	r12
    b67e:	bf 90       	pop	r11
    b680:	af 90       	pop	r10
    b682:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    b684:	8e 01       	movw	r16, r28
    b686:	0b 5f       	subi	r16, 0xFB	; 251
    b688:	1f 4f       	sbci	r17, 0xFF	; 255
    b68a:	fa 01       	movw	r30, r20
    b68c:	43 81       	ldd	r20, Z+3	; 0x03
    b68e:	c8 01       	movw	r24, r16
    b690:	50 e0       	ldi	r21, 0x00	; 0
    b692:	0e 94 cb 81 	call	0x10396	; 0x10396 <__eerd_block_m2560>
		Put_TextValAlignRight(Var, Param);
		break;
	case EE_Text:{
			char TempStr[LCDXSz+1];
			erbl(TempStr, Var, Param->Size);
			Put_TextValAlignRight(TempStr, Param);
    b696:	c8 01       	movw	r24, r16
    b698:	b7 01       	movw	r22, r14
    b69a:	0e 94 f2 42 	call	0x85e4	; 0x85e4 <Put_TextValAlignRight>
    b69e:	e1 cf       	rjmp	.-62     	; 0xb662 <PutField+0x94>
	case EE_Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((erb((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
		break;

	case Text:
		Put_TextValAlignRight(Var, Param);
    b6a0:	cb 01       	movw	r24, r22
    b6a2:	ba 01       	movw	r22, r20
    b6a4:	0e 94 f2 42 	call	0x85e4	; 0x85e4 <Put_TextValAlignRight>
    b6a8:	dc cf       	rjmp	.-72     	; 0xb662 <PutField+0x94>
	case EE_Enum:
		Param->Txt += erb((uint8_t*)Var);
		PutEnum(Param);
		break;
	case Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((*((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
    b6aa:	fa 01       	movw	r30, r20
    b6ac:	00 81       	ld	r16, Z
    b6ae:	11 81       	ldd	r17, Z+1	; 0x01
    b6b0:	64 81       	ldd	r22, Z+4	; 0x04
    b6b2:	75 81       	ldd	r23, Z+5	; 0x05
    b6b4:	42 81       	ldd	r20, Z+2	; 0x02
    b6b6:	84 2f       	mov	r24, r20
    b6b8:	86 95       	lsr	r24
    b6ba:	86 95       	lsr	r24
    b6bc:	86 95       	lsr	r24
    b6be:	a8 0f       	add	r26, r24
    b6c0:	b1 1d       	adc	r27, r1
    b6c2:	2c 91       	ld	r18, X
    b6c4:	30 e0       	ldi	r19, 0x00	; 0
    b6c6:	47 70       	andi	r20, 0x07	; 7
    b6c8:	81 e0       	ldi	r24, 0x01	; 1
    b6ca:	90 e0       	ldi	r25, 0x00	; 0
    b6cc:	02 c0       	rjmp	.+4      	; 0xb6d2 <PutField+0x104>
    b6ce:	88 0f       	add	r24, r24
    b6d0:	99 1f       	adc	r25, r25
    b6d2:	4a 95       	dec	r20
    b6d4:	e2 f7       	brpl	.-8      	; 0xb6ce <PutField+0x100>
    b6d6:	28 23       	and	r18, r24
    b6d8:	39 23       	and	r19, r25
    b6da:	12 16       	cp	r1, r18
    b6dc:	13 06       	cpc	r1, r19
    b6de:	0c f0       	brlt	.+2      	; 0xb6e2 <PutField+0x114>
    b6e0:	f8 c0       	rjmp	.+496    	; 0xb8d2 <PutField+0x304>
    b6e2:	82 e0       	ldi	r24, 0x02	; 2
    b6e4:	90 e0       	ldi	r25, 0x00	; 0

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    b6e6:	fb 01       	movw	r30, r22
    b6e8:	e8 0f       	add	r30, r24
    b6ea:	f9 1f       	adc	r31, r25
    b6ec:	65 91       	lpm	r22, Z+
    b6ee:	74 91       	lpm	r23, Z+
    b6f0:	c8 01       	movw	r24, r16
    b6f2:	0e 94 ba 7e 	call	0xfd74	; 0xfd74 <strcpy_P>
    b6f6:	b5 cf       	rjmp	.-150    	; 0xb662 <PutField+0x94>
		Put_GFVal(fTemp, Param);
		break;


	case Enum:
		Param->Txt += *(uint8_t*)Var;
    b6f8:	2c 91       	ld	r18, X
    b6fa:	30 e0       	ldi	r19, 0x00	; 0
    b6fc:	22 0f       	add	r18, r18
    b6fe:	33 1f       	adc	r19, r19
    b700:	f7 01       	movw	r30, r14
    b702:	84 81       	ldd	r24, Z+4	; 0x04
    b704:	95 81       	ldd	r25, Z+5	; 0x05
    b706:	82 0f       	add	r24, r18
    b708:	93 1f       	adc	r25, r19
    b70a:	95 83       	std	Z+5, r25	; 0x05
    b70c:	84 83       	std	Z+4, r24	; 0x04
		PutEnum(Param);
    b70e:	c7 01       	movw	r24, r14
    b710:	0e 94 9e 40 	call	0x813c	; 0x813c <PutEnum>
    b714:	a6 cf       	rjmp	.-180    	; 0xb662 <PutField+0x94>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    b716:	cb 01       	movw	r24, r22
    b718:	0e 94 db 81 	call	0x103b6	; 0x103b6 <__eerd_byte_m2560>
		break;
	case EE_Enum:
		Param->Txt += erb((uint8_t*)Var);
    b71c:	90 e0       	ldi	r25, 0x00	; 0
    b71e:	88 0f       	add	r24, r24
    b720:	99 1f       	adc	r25, r25
    b722:	f7 01       	movw	r30, r14
    b724:	24 81       	ldd	r18, Z+4	; 0x04
    b726:	35 81       	ldd	r19, Z+5	; 0x05
    b728:	28 0f       	add	r18, r24
    b72a:	39 1f       	adc	r19, r25
    b72c:	35 83       	std	Z+5, r19	; 0x05
    b72e:	24 83       	std	Z+4, r18	; 0x04
		PutEnum(Param);
    b730:	c7 01       	movw	r24, r14
    b732:	0e 94 9e 40 	call	0x813c	; 0x813c <PutEnum>
    b736:	95 cf       	rjmp	.-214    	; 0xb662 <PutField+0x94>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    b738:	ce 01       	movw	r24, r28
    b73a:	01 96       	adiw	r24, 0x01	; 1
    b73c:	44 e0       	ldi	r20, 0x04	; 4
    b73e:	50 e0       	ldi	r21, 0x00	; 0
    b740:	0e 94 cb 81 	call	0x10396	; 0x10396 <__eerd_block_m2560>
	case GFloat:
		Put_GFVal(*(float*)Var, Param);
		break;			
	case EE_GFloat:
		erbl(&fTemp, Var, 4);
		Put_GFVal(fTemp, Param);
    b744:	69 81       	ldd	r22, Y+1	; 0x01
    b746:	7a 81       	ldd	r23, Y+2	; 0x02
    b748:	8b 81       	ldd	r24, Y+3	; 0x03
    b74a:	9c 81       	ldd	r25, Y+4	; 0x04
    b74c:	a7 01       	movw	r20, r14
    b74e:	0e 94 4e 43 	call	0x869c	; 0x869c <Put_GFVal>
    b752:	87 cf       	rjmp	.-242    	; 0xb662 <PutField+0x94>
	case EE_FFloat:
		erbl(&fTemp, Var, 4);
		Put_FFVal(fTemp, Param);
		break;
	case GFloat:
		Put_GFVal(*(float*)Var, Param);
    b754:	6d 91       	ld	r22, X+
    b756:	7d 91       	ld	r23, X+
    b758:	8d 91       	ld	r24, X+
    b75a:	9c 91       	ld	r25, X
    b75c:	0e 94 4e 43 	call	0x869c	; 0x869c <Put_GFVal>
    b760:	80 cf       	rjmp	.-256    	; 0xb662 <PutField+0x94>
    b762:	ce 01       	movw	r24, r28
    b764:	01 96       	adiw	r24, 0x01	; 1
    b766:	44 e0       	ldi	r20, 0x04	; 4
    b768:	50 e0       	ldi	r21, 0x00	; 0
    b76a:	0e 94 cb 81 	call	0x10396	; 0x10396 <__eerd_block_m2560>
	case FFloat:
		Put_FFVal(*(float*)Var, Param);
		break;			
	case EE_FFloat:
		erbl(&fTemp, Var, 4);
		Put_FFVal(fTemp, Param);
    b76e:	69 81       	ldd	r22, Y+1	; 0x01
    b770:	7a 81       	ldd	r23, Y+2	; 0x02
    b772:	8b 81       	ldd	r24, Y+3	; 0x03
    b774:	9c 81       	ldd	r25, Y+4	; 0x04
    b776:	a7 01       	movw	r20, r14
    b778:	0e 94 c8 43 	call	0x8790	; 0x8790 <Put_FFVal>
    b77c:	72 cf       	rjmp	.-284    	; 0xb662 <PutField+0x94>
		Put_zDVal(erd((uint32_t*)Var), Param);
		break;

		
	case FFloat:
		Put_FFVal(*(float*)Var, Param);
    b77e:	6d 91       	ld	r22, X+
    b780:	7d 91       	ld	r23, X+
    b782:	8d 91       	ld	r24, X+
    b784:	9c 91       	ld	r25, X
    b786:	0e 94 c8 43 	call	0x8790	; 0x8790 <Put_FFVal>
    b78a:	6b cf       	rjmp	.-298    	; 0xb662 <PutField+0x94>
		break;
	case zh_Word:
		Put_zVal_h(*(uint16_t*)Var, 'w', Param);
		break;
	case zh_Longint:
		Put_zVal_h(*(uint32_t*)Var, 'l', Param);
    b78c:	6d 91       	ld	r22, X+
    b78e:	7d 91       	ld	r23, X+
    b790:	8d 91       	ld	r24, X+
    b792:	9c 91       	ld	r25, X
    b794:	4c e6       	ldi	r20, 0x6C	; 108
    b796:	97 01       	movw	r18, r14
    b798:	0e 94 88 47 	call	0x8f10	; 0x8f10 <Put_zVal_h>
    b79c:	62 cf       	rjmp	.-316    	; 0xb662 <PutField+0x94>
// ~~~~~~~~~~~~~~~~~~~~~~
uint32_t
erd(const uint32_t *addr)
{
	//IntOff();
	uint32_t word = eeprom_read_dword(addr);
    b79e:	cb 01       	movw	r24, r22
    b7a0:	0e 94 e3 81 	call	0x103c6	; 0x103c6 <__eerd_dword_m2560>
		break;
	case z_Longint: case zc_Longint:
		Put_zDVal(*(uint32_t*)Var, Param);
		break;
	case z_EE_Longint:
		Put_zDVal(erd((uint32_t*)Var), Param);
    b7a4:	a7 01       	movw	r20, r14
    b7a6:	0e 94 1d 44 	call	0x883a	; 0x883a <Put_zDVal>
    b7aa:	5b cf       	rjmp	.-330    	; 0xb662 <PutField+0x94>
		break;
	case s_EE_Longint:
		Put_sDVal((int32_t)erd((uint32_t*)Var), Param);
		break;
	case z_Longint: case zc_Longint:
		Put_zDVal(*(uint32_t*)Var, Param);
    b7ac:	6d 91       	ld	r22, X+
    b7ae:	7d 91       	ld	r23, X+
    b7b0:	8d 91       	ld	r24, X+
    b7b2:	9c 91       	ld	r25, X
    b7b4:	0e 94 1d 44 	call	0x883a	; 0x883a <Put_zDVal>
    b7b8:	54 cf       	rjmp	.-344    	; 0xb662 <PutField+0x94>
    b7ba:	cb 01       	movw	r24, r22
    b7bc:	0e 94 e3 81 	call	0x103c6	; 0x103c6 <__eerd_dword_m2560>
		break;
	case s_Longint:
		Put_sDVal(*(int32_t*)Var, Param);
		break;
	case s_EE_Longint:
		Put_sDVal((int32_t)erd((uint32_t*)Var), Param);
    b7c0:	a7 01       	movw	r20, r14
    b7c2:	0e 94 3e 45 	call	0x8a7c	; 0x8a7c <Put_sDVal>
    b7c6:	4d cf       	rjmp	.-358    	; 0xb662 <PutField+0x94>
		break;
	case EE_Longint:
		PutDVal(erd((uint32_t*)Var), Param);
		break;
	case s_Longint:
		Put_sDVal(*(int32_t*)Var, Param);
    b7c8:	6d 91       	ld	r22, X+
    b7ca:	7d 91       	ld	r23, X+
    b7cc:	8d 91       	ld	r24, X+
    b7ce:	9c 91       	ld	r25, X
    b7d0:	0e 94 3e 45 	call	0x8a7c	; 0x8a7c <Put_sDVal>
    b7d4:	46 cf       	rjmp	.-372    	; 0xb662 <PutField+0x94>
    b7d6:	cb 01       	movw	r24, r22
    b7d8:	0e 94 e3 81 	call	0x103c6	; 0x103c6 <__eerd_dword_m2560>

	case Longint: case c_Longint:
		PutDVal(*(uint32_t*)Var, Param);
		break;
	case EE_Longint:
		PutDVal(erd((uint32_t*)Var), Param);
    b7dc:	a7 01       	movw	r20, r14
    b7de:	0e 94 67 46 	call	0x8cce	; 0x8cce <PutDVal>
    b7e2:	3f cf       	rjmp	.-386    	; 0xb662 <PutField+0x94>
		Put_zVal(erw((uint16_t*)Var), 'w', Param);
		break;


	case Longint: case c_Longint:
		PutDVal(*(uint32_t*)Var, Param);
    b7e4:	6d 91       	ld	r22, X+
    b7e6:	7d 91       	ld	r23, X+
    b7e8:	8d 91       	ld	r24, X+
    b7ea:	9c 91       	ld	r25, X
    b7ec:	0e 94 67 46 	call	0x8cce	; 0x8cce <PutDVal>
    b7f0:	38 cf       	rjmp	.-400    	; 0xb662 <PutField+0x94>

	case zh_Byte:
		Put_zVal_h(*(uint8_t*)Var, 'b', Param);
		break;
	case zh_Word:
		Put_zVal_h(*(uint16_t*)Var, 'w', Param);
    b7f2:	6d 91       	ld	r22, X+
    b7f4:	7c 91       	ld	r23, X
    b7f6:	80 e0       	ldi	r24, 0x00	; 0
    b7f8:	90 e0       	ldi	r25, 0x00	; 0
    b7fa:	47 e7       	ldi	r20, 0x77	; 119
    b7fc:	97 01       	movw	r18, r14
    b7fe:	0e 94 88 47 	call	0x8f10	; 0x8f10 <Put_zVal_h>
    b802:	2f cf       	rjmp	.-418    	; 0xb662 <PutField+0x94>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    b804:	cb 01       	movw	r24, r22
    b806:	0e 94 e9 81 	call	0x103d2	; 0x103d2 <__eerd_word_m2560>
		break;
	case z_Word: case zc_Word:
		Put_zVal(*(uint16_t*)Var, 'w', Param);
		break;
	case z_EE_Word:
		Put_zVal(erw((uint16_t*)Var), 'w', Param);
    b80a:	67 e7       	ldi	r22, 0x77	; 119
    b80c:	a7 01       	movw	r20, r14
    b80e:	0e 94 fb 47 	call	0x8ff6	; 0x8ff6 <Put_zVal>
    b812:	27 cf       	rjmp	.-434    	; 0xb662 <PutField+0x94>
		break;
	case s_EE_Word:
		Put_sVal((int16_t)erw((uint16_t*)Var), 'w', Param);
		break;
	case z_Word: case zc_Word:
		Put_zVal(*(uint16_t*)Var, 'w', Param);
    b814:	8d 91       	ld	r24, X+
    b816:	9c 91       	ld	r25, X
    b818:	67 e7       	ldi	r22, 0x77	; 119
    b81a:	0e 94 fb 47 	call	0x8ff6	; 0x8ff6 <Put_zVal>
    b81e:	21 cf       	rjmp	.-446    	; 0xb662 <PutField+0x94>
    b820:	cb 01       	movw	r24, r22
    b822:	0e 94 e9 81 	call	0x103d2	; 0x103d2 <__eerd_word_m2560>
		break;
	case s_Word:
		Put_sVal(*(int16_t*)Var, 'w', Param);
		break;
	case s_EE_Word:
		Put_sVal((int16_t)erw((uint16_t*)Var), 'w', Param);
    b826:	67 e7       	ldi	r22, 0x77	; 119
    b828:	a7 01       	movw	r20, r14
    b82a:	0e 94 b8 48 	call	0x9170	; 0x9170 <Put_sVal>
    b82e:	19 cf       	rjmp	.-462    	; 0xb662 <PutField+0x94>
		break;
	case EE_Word:
		PutVal(erw((uint16_t*)Var), 'w', Param);
		break;
	case s_Word:
		Put_sVal(*(int16_t*)Var, 'w', Param);
    b830:	8d 91       	ld	r24, X+
    b832:	9c 91       	ld	r25, X
    b834:	67 e7       	ldi	r22, 0x77	; 119
    b836:	0e 94 b8 48 	call	0x9170	; 0x9170 <Put_sVal>
    b83a:	13 cf       	rjmp	.-474    	; 0xb662 <PutField+0x94>
    b83c:	cb 01       	movw	r24, r22
    b83e:	0e 94 e9 81 	call	0x103d2	; 0x103d2 <__eerd_word_m2560>

	case Word: case c_Word:
		PutVal(*(uint16_t*)Var, 'w', Param);
		break;
	case EE_Word:
		PutVal(erw((uint16_t*)Var), 'w', Param);
    b842:	67 e7       	ldi	r22, 0x77	; 119
    b844:	a7 01       	movw	r20, r14
    b846:	0e 94 9c 49 	call	0x9338	; 0x9338 <PutVal>
    b84a:	0b cf       	rjmp	.-490    	; 0xb662 <PutField+0x94>
	case zh_Longint:
		Put_zVal_h(*(uint32_t*)Var, 'l', Param);
		break;

	case Word: case c_Word:
		PutVal(*(uint16_t*)Var, 'w', Param);
    b84c:	8d 91       	ld	r24, X+
    b84e:	9c 91       	ld	r25, X
    b850:	67 e7       	ldi	r22, 0x77	; 119
    b852:	0e 94 9c 49 	call	0x9338	; 0x9338 <PutVal>
    b856:	05 cf       	rjmp	.-502    	; 0xb662 <PutField+0x94>
	case z_EE_Byte:
		Put_zVal(erb((uint8_t*)Var), 'b', Param);
		break;

	case zh_Byte:
		Put_zVal_h(*(uint8_t*)Var, 'b', Param);
    b858:	6c 91       	ld	r22, X
    b85a:	70 e0       	ldi	r23, 0x00	; 0
    b85c:	80 e0       	ldi	r24, 0x00	; 0
    b85e:	90 e0       	ldi	r25, 0x00	; 0
    b860:	42 e6       	ldi	r20, 0x62	; 98
    b862:	97 01       	movw	r18, r14
    b864:	0e 94 88 47 	call	0x8f10	; 0x8f10 <Put_zVal_h>
    b868:	fc ce       	rjmp	.-520    	; 0xb662 <PutField+0x94>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    b86a:	cb 01       	movw	r24, r22
    b86c:	0e 94 db 81 	call	0x103b6	; 0x103b6 <__eerd_byte_m2560>
		break;
	case z_Byte:
		Put_zVal(*(uint8_t*)Var, 'b', Param);
		break;
	case z_EE_Byte:
		Put_zVal(erb((uint8_t*)Var), 'b', Param);
    b870:	90 e0       	ldi	r25, 0x00	; 0
    b872:	62 e6       	ldi	r22, 0x62	; 98
    b874:	a7 01       	movw	r20, r14
    b876:	0e 94 fb 47 	call	0x8ff6	; 0x8ff6 <Put_zVal>
    b87a:	f3 ce       	rjmp	.-538    	; 0xb662 <PutField+0x94>
		break;
	case s_EE_Byte:
		Put_sVal((int8_t)erb((uint8_t*)Var), 'b', Param);
		break;
	case z_Byte:
		Put_zVal(*(uint8_t*)Var, 'b', Param);
    b87c:	8c 91       	ld	r24, X
    b87e:	90 e0       	ldi	r25, 0x00	; 0
    b880:	62 e6       	ldi	r22, 0x62	; 98
    b882:	0e 94 fb 47 	call	0x8ff6	; 0x8ff6 <Put_zVal>
    b886:	ed ce       	rjmp	.-550    	; 0xb662 <PutField+0x94>
    b888:	cb 01       	movw	r24, r22
    b88a:	0e 94 db 81 	call	0x103b6	; 0x103b6 <__eerd_byte_m2560>
		break;
	case s_Byte:
		Put_sVal(*(int8_t*)Var, 'b', Param);
		break;
	case s_EE_Byte:
		Put_sVal((int8_t)erb((uint8_t*)Var), 'b', Param);
    b88e:	99 27       	eor	r25, r25
    b890:	87 fd       	sbrc	r24, 7
    b892:	90 95       	com	r25
    b894:	62 e6       	ldi	r22, 0x62	; 98
    b896:	a7 01       	movw	r20, r14
    b898:	0e 94 b8 48 	call	0x9170	; 0x9170 <Put_sVal>
    b89c:	e2 ce       	rjmp	.-572    	; 0xb662 <PutField+0x94>
		break;
	case EE_Byte:
		PutVal(erb((uint8_t*)Var), 'b', Param);
		break;
	case s_Byte:
		Put_sVal(*(int8_t*)Var, 'b', Param);
    b89e:	8c 91       	ld	r24, X
    b8a0:	99 27       	eor	r25, r25
    b8a2:	87 fd       	sbrc	r24, 7
    b8a4:	90 95       	com	r25
    b8a6:	62 e6       	ldi	r22, 0x62	; 98
    b8a8:	0e 94 b8 48 	call	0x9170	; 0x9170 <Put_sVal>
    b8ac:	da ce       	rjmp	.-588    	; 0xb662 <PutField+0x94>
    b8ae:	cb 01       	movw	r24, r22
    b8b0:	0e 94 db 81 	call	0x103b6	; 0x103b6 <__eerd_byte_m2560>
	switch(Type) {
	case Byte:
		PutVal(*(uint8_t*)Var, 'b', Param);
		break;
	case EE_Byte:
		PutVal(erb((uint8_t*)Var), 'b', Param);
    b8b4:	90 e0       	ldi	r25, 0x00	; 0
    b8b6:	62 e6       	ldi	r22, 0x62	; 98
    b8b8:	a7 01       	movw	r20, r14
    b8ba:	0e 94 9c 49 	call	0x9338	; 0x9338 <PutVal>
    b8be:	d1 ce       	rjmp	.-606    	; 0xb662 <PutField+0x94>
{
	float fTemp;

	switch(Type) {
	case Byte:
		PutVal(*(uint8_t*)Var, 'b', Param);
    b8c0:	8c 91       	ld	r24, X
    b8c2:	90 e0       	ldi	r25, 0x00	; 0
    b8c4:	62 e6       	ldi	r22, 0x62	; 98
    b8c6:	0e 94 9c 49 	call	0x9338	; 0x9338 <PutVal>
    b8ca:	cb ce       	rjmp	.-618    	; 0xb662 <PutField+0x94>
		break;
	case Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((*((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
		break;
	case EE_Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((erb((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
    b8cc:	80 e0       	ldi	r24, 0x00	; 0
    b8ce:	90 e0       	ldi	r25, 0x00	; 0
    b8d0:	c0 ce       	rjmp	.-640    	; 0xb652 <PutField+0x84>
	case EE_Enum:
		Param->Txt += erb((uint8_t*)Var);
		PutEnum(Param);
		break;
	case Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((*((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
    b8d2:	80 e0       	ldi	r24, 0x00	; 0
    b8d4:	90 e0       	ldi	r25, 0x00	; 0
    b8d6:	07 cf       	rjmp	.-498    	; 0xb6e6 <PutField+0x118>

0000b8d8 <PutLine>:
	PosBlink(Param,'_');
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
PutLine(uint8_t LineN, uint8_t Y)
{
    b8d8:	2f 92       	push	r2
    b8da:	3f 92       	push	r3
    b8dc:	4f 92       	push	r4
    b8de:	5f 92       	push	r5
    b8e0:	6f 92       	push	r6
    b8e2:	7f 92       	push	r7
    b8e4:	8f 92       	push	r8
    b8e6:	9f 92       	push	r9
    b8e8:	af 92       	push	r10
    b8ea:	bf 92       	push	r11
    b8ec:	cf 92       	push	r12
    b8ee:	df 92       	push	r13
    b8f0:	ef 92       	push	r14
    b8f2:	ff 92       	push	r15
    b8f4:	0f 93       	push	r16
    b8f6:	1f 93       	push	r17
    b8f8:	df 93       	push	r29
    b8fa:	cf 93       	push	r28
    b8fc:	cd b7       	in	r28, 0x3d	; 61
    b8fe:	de b7       	in	r29, 0x3e	; 62
    b900:	60 97       	sbiw	r28, 0x10	; 16
    b902:	0f b6       	in	r0, 0x3f	; 63
    b904:	f8 94       	cli
    b906:	de bf       	out	0x3e, r29	; 62
    b908:	0f be       	out	0x3f, r0	; 63
    b90a:	cd bf       	out	0x3d, r28	; 61
    b90c:	8f 87       	std	Y+15, r24	; 0x0f
    b90e:	68 8b       	std	Y+16, r22	; 0x10

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    b910:	e0 91 d4 02 	lds	r30, 0x02D4
    b914:	f0 91 d5 02 	lds	r31, 0x02D5
    b918:	e5 90       	lpm	r14, Z+
    b91a:	f4 90       	lpm	r15, Z+
	MenuLine *Line=GetLine+LineN;
    b91c:	8b e1       	ldi	r24, 0x1B	; 27
    b91e:	2f 85       	ldd	r18, Y+15	; 0x0f
    b920:	28 9f       	mul	r18, r24
    b922:	c0 01       	movw	r24, r0
    b924:	11 24       	eor	r1, r1
    b926:	e8 0e       	add	r14, r24
    b928:	f9 1e       	adc	r15, r25
	PGM_P CurrStr=(PGM_P)(Line->Str);
    b92a:	be 2c       	mov	r11, r14
    b92c:	af 2c       	mov	r10, r15
    b92e:	f7 01       	movw	r30, r14
    b930:	75 96       	adiw	r30, 0x15	; 21
    b932:	c5 90       	lpm	r12, Z+
    b934:	d4 90       	lpm	r13, Z+

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    b936:	f7 01       	movw	r30, r14
    b938:	77 96       	adiw	r30, 0x17	; 23
    b93a:	85 91       	lpm	r24, Z+
    b93c:	94 91       	lpm	r25, Z+
    b93e:	9e 87       	std	Y+14, r25	; 0x0e
    b940:	8d 87       	std	Y+13, r24	; 0x0d
    b942:	87 01       	movw	r16, r14
    b944:	f7 01       	movw	r30, r14
    b946:	84 91       	lpm	r24, Z+
	uint8_t X;
	uint8_t X0=0;
	uint8_t X1=LCDXSz;
	int8_t Xs = 0;
	//--- ">>" Align right
	if(prc(CurrStr+0) == '>' && prc(CurrStr+1) == '>'){
    b948:	8e 33       	cpi	r24, 0x3E	; 62
    b94a:	09 f4       	brne	.+2      	; 0xb94e <PutLine+0x76>
    b94c:	a6 c1       	rjmp	.+844    	; 0xbc9a <PutLine+0x3c2>
		X0 = LCDXSz - strlen_P(CurrStr) + 2;
		Xs = X0-2;
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';
    b94e:	40 e0       	ldi	r20, 0x00	; 0
    b950:	50 e0       	ldi	r21, 0x00	; 0
    b952:	f8 01       	movw	r30, r16
    b954:	84 91       	lpm	r24, Z+
	}
	//--- "<<" Align left
	if(prc(CurrStr+0) == '<' && prc(CurrStr+1) == '<'){
    b956:	8c 33       	cpi	r24, 0x3C	; 60
    b958:	09 f4       	brne	.+2      	; 0xb95c <PutLine+0x84>
    b95a:	8a c1       	rjmp	.+788    	; 0xbc70 <PutLine+0x398>
		X1 = strlen_P(CurrStr) - 2;
    b95c:	84 e1       	ldi	r24, 0x14	; 20
    b95e:	98 2e       	mov	r9, r24
    b960:	f8 01       	movw	r30, r16
    b962:	84 91       	lpm	r24, Z+
		X0 = 0;
		Xs = X0-2;
	}
	//--- "<>" Align center
	if(prc(CurrStr+0) == '<' && prc(CurrStr+1) == '>'){
    b964:	8c 33       	cpi	r24, 0x3C	; 60
    b966:	09 f4       	brne	.+2      	; 0xb96a <PutLine+0x92>
    b968:	56 c1       	rjmp	.+684    	; 0xbc16 <PutLine+0x33e>
		Xs = X0-2;
		X1 = X0 + (strlen_P(CurrStr) - 2);
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';		
	}
	//---
	for(X=X0; X<X1; X++){
    b96a:	49 15       	cp	r20, r9
    b96c:	08 f0       	brcs	.+2      	; 0xb970 <PutLine+0x98>
    b96e:	ac c0       	rjmp	.+344    	; 0xbac8 <PutLine+0x1f0>
static void
PutLine(uint8_t LineN, uint8_t Y)
{
	MenuLine *Line=GetLine+LineN;
	PGM_P CurrStr=(PGM_P)(Line->Str);
	InField *IF = prp(&Line->IF_List);
    b970:	88 89       	ldd	r24, Y+16	; 0x10
    b972:	28 2f       	mov	r18, r24
    b974:	30 e0       	ldi	r19, 0x00	; 0
    b976:	c9 01       	movw	r24, r18
    b978:	88 0f       	add	r24, r24
    b97a:	99 1f       	adc	r25, r25
    b97c:	82 0f       	add	r24, r18
    b97e:	93 1f       	adc	r25, r19
    b980:	5c 01       	movw	r10, r24
    b982:	aa 0c       	add	r10, r10
    b984:	bb 1c       	adc	r11, r11
    b986:	aa 0c       	add	r10, r10
    b988:	bb 1c       	adc	r11, r11
    b98a:	aa 0c       	add	r10, r10
    b98c:	bb 1c       	adc	r11, r11
    b98e:	a8 1a       	sub	r10, r24
    b990:	b9 0a       	sbc	r11, r25
    b992:	25 2e       	mov	r2, r21
    b994:	33 24       	eor	r3, r3
    b996:	27 fc       	sbrc	r2, 7
    b998:	30 94       	com	r3
    b99a:	04 2f       	mov	r16, r20
    b99c:	88 24       	eor	r8, r8
		switch(Char=prc(CurrStr+X-Xs)) {
		case '{':
			while((Char=prc(CurrStr + X - Xs + ++Param.Size))=='{');
			Param.Prec = prb(&IF->Prec);
			Param.Txt = prp(&IF->EnumList);
			PutField(prb(&IF->Type), prp(&IF->Var), &Param);
    b99e:	3e 01       	movw	r6, r28
    b9a0:	08 94       	sec
    b9a2:	61 1c       	adc	r6, r1
    b9a4:	71 1c       	adc	r7, r1
			else
				PutField(prb(&(OF+OF_N)->Type), prp(&(OF+OF_N)->Var), &Param);
			OF_N++;
			break;
		}
		LCD_Buf[Y][X+=Param.Size] = Char;
    b9a6:	25 01       	movw	r4, r10
    b9a8:	11 c0       	rjmp	.+34     	; 0xb9cc <PutLine+0xf4>
	for(X=X0; X<X1; X++){
		char Char;
		T_Param Param;
		Param.Pos = LCD_Buf[Y]+X;
		Param.Size = 0;
		switch(Char=prc(CurrStr+X-Xs)) {
    b9aa:	1d 37       	cpi	r17, 0x7D	; 125
    b9ac:	09 f4       	brne	.+2      	; 0xb9b0 <PutLine+0xd8>
    b9ae:	4c c0       	rjmp	.+152    	; 0xba48 <PutLine+0x170>
    b9b0:	30 e0       	ldi	r19, 0x00	; 0
			else
				PutField(prb(&(OF+OF_N)->Type), prp(&(OF+OF_N)->Var), &Param);
			OF_N++;
			break;
		}
		LCD_Buf[Y][X+=Param.Size] = Char;
    b9b2:	80 2f       	mov	r24, r16
    b9b4:	83 0f       	add	r24, r19
    b9b6:	f2 01       	movw	r30, r4
    b9b8:	e8 0f       	add	r30, r24
    b9ba:	f1 1d       	adc	r31, r1
    b9bc:	ea 5a       	subi	r30, 0xAA	; 170
    b9be:	f9 4f       	sbci	r31, 0xF9	; 249
    b9c0:	10 83       	st	Z, r17
		Xs = X0-2;
		X1 = X0 + (strlen_P(CurrStr) - 2);
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';		
	}
	//---
	for(X=X0; X<X1; X++){
    b9c2:	08 2f       	mov	r16, r24
    b9c4:	0f 5f       	subi	r16, 0xFF	; 255
    b9c6:	09 15       	cp	r16, r9
    b9c8:	08 f0       	brcs	.+2      	; 0xb9cc <PutLine+0xf4>
    b9ca:	7e c0       	rjmp	.+252    	; 0xbac8 <PutLine+0x1f0>
		char Char;
		T_Param Param;
		Param.Pos = LCD_Buf[Y]+X;
    b9cc:	80 2f       	mov	r24, r16
    b9ce:	90 e0       	ldi	r25, 0x00	; 0
    b9d0:	9c 01       	movw	r18, r24
    b9d2:	2a 0d       	add	r18, r10
    b9d4:	3b 1d       	adc	r19, r11
    b9d6:	2a 5a       	subi	r18, 0xAA	; 170
    b9d8:	39 4f       	sbci	r19, 0xF9	; 249
    b9da:	3a 83       	std	Y+2, r19	; 0x02
    b9dc:	29 83       	std	Y+1, r18	; 0x01
		Param.Size = 0;
		switch(Char=prc(CurrStr+X-Xs)) {
    b9de:	82 19       	sub	r24, r2
    b9e0:	93 09       	sbc	r25, r3
    b9e2:	f7 01       	movw	r30, r14
    b9e4:	e8 0f       	add	r30, r24
    b9e6:	f9 1f       	adc	r31, r25
    b9e8:	14 91       	lpm	r17, Z+
    b9ea:	1b 37       	cpi	r17, 0x7B	; 123
    b9ec:	f1 f6       	brne	.-68     	; 0xb9aa <PutLine+0xd2>
    b9ee:	21 e0       	ldi	r18, 0x01	; 1
    b9f0:	01 c0       	rjmp	.+2      	; 0xb9f4 <PutLine+0x11c>
		case '{':
			while((Char=prc(CurrStr + X - Xs + ++Param.Size))=='{');
    b9f2:	23 2f       	mov	r18, r19
    b9f4:	fc 01       	movw	r30, r24
    b9f6:	e2 0f       	add	r30, r18
    b9f8:	f1 1d       	adc	r31, r1
    b9fa:	ee 0d       	add	r30, r14
    b9fc:	ff 1d       	adc	r31, r15
    b9fe:	14 91       	lpm	r17, Z+
    ba00:	32 2f       	mov	r19, r18
    ba02:	3f 5f       	subi	r19, 0xFF	; 255
    ba04:	1b 37       	cpi	r17, 0x7B	; 123
    ba06:	a9 f3       	breq	.-22     	; 0xb9f2 <PutLine+0x11a>
    ba08:	2c 83       	std	Y+4, r18	; 0x04

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    ba0a:	a5 e0       	ldi	r26, 0x05	; 5
    ba0c:	b0 e0       	ldi	r27, 0x00	; 0
    ba0e:	ca 0e       	add	r12, r26
    ba10:	db 1e       	adc	r13, r27
    ba12:	f6 01       	movw	r30, r12
    ba14:	84 91       	lpm	r24, Z+
    ba16:	2b ef       	ldi	r18, 0xFB	; 251
    ba18:	3f ef       	ldi	r19, 0xFF	; 255
    ba1a:	c2 0e       	add	r12, r18
    ba1c:	d3 1e       	adc	r13, r19
			Param.Prec = prb(&IF->Prec);
    ba1e:	8b 83       	std	Y+3, r24	; 0x03

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    ba20:	f6 01       	movw	r30, r12
    ba22:	33 96       	adiw	r30, 0x03	; 3
    ba24:	85 91       	lpm	r24, Z+
    ba26:	94 91       	lpm	r25, Z+
			Param.Txt = prp(&IF->EnumList);
    ba28:	9e 83       	std	Y+6, r25	; 0x06
    ba2a:	8d 83       	std	Y+5, r24	; 0x05

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    ba2c:	f6 01       	movw	r30, r12
    ba2e:	84 91       	lpm	r24, Z+

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    ba30:	31 96       	adiw	r30, 0x01	; 1
    ba32:	65 91       	lpm	r22, Z+
    ba34:	74 91       	lpm	r23, Z+
			PutField(prb(&IF->Type), prp(&IF->Var), &Param);
    ba36:	a3 01       	movw	r20, r6
    ba38:	0e 94 e7 5a 	call	0xb5ce	; 0xb5ce <PutField>
			IF++;
    ba3c:	26 e0       	ldi	r18, 0x06	; 6
    ba3e:	30 e0       	ldi	r19, 0x00	; 0
    ba40:	c2 0e       	add	r12, r18
    ba42:	d3 1e       	adc	r13, r19
    ba44:	3c 81       	ldd	r19, Y+4	; 0x04
    ba46:	b5 cf       	rjmp	.-150    	; 0xb9b2 <PutLine+0xda>
			break;
    ba48:	21 e0       	ldi	r18, 0x01	; 1
    ba4a:	01 c0       	rjmp	.+2      	; 0xba4e <PutLine+0x176>
		case '}':
			while((Char=prc(CurrStr+X - Xs + ++Param.Size))=='}');
    ba4c:	23 2f       	mov	r18, r19

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    ba4e:	fc 01       	movw	r30, r24
    ba50:	e2 0f       	add	r30, r18
    ba52:	f1 1d       	adc	r31, r1
    ba54:	ee 0d       	add	r30, r14
    ba56:	ff 1d       	adc	r31, r15
    ba58:	14 91       	lpm	r17, Z+
    ba5a:	32 2f       	mov	r19, r18
    ba5c:	3f 5f       	subi	r19, 0xFF	; 255
    ba5e:	1d 37       	cpi	r17, 0x7D	; 125
    ba60:	a9 f3       	breq	.-22     	; 0xba4c <PutLine+0x174>
    ba62:	2c 83       	std	Y+4, r18	; 0x04
			Y1=Y;
    ba64:	38 89       	ldd	r19, Y+16	; 0x10
    ba66:	30 93 fd 09 	sts	0x09FD, r19
			Param.Prec = prb(&(OF+OF_N)->Prec);
    ba6a:	48 2d       	mov	r20, r8
    ba6c:	50 e0       	ldi	r21, 0x00	; 0
    ba6e:	42 95       	swap	r20
    ba70:	52 95       	swap	r21
    ba72:	50 7f       	andi	r21, 0xF0	; 240
    ba74:	54 27       	eor	r21, r20
    ba76:	40 7f       	andi	r20, 0xF0	; 240
    ba78:	54 27       	eor	r21, r20
    ba7a:	8d 85       	ldd	r24, Y+13	; 0x0d
    ba7c:	9e 85       	ldd	r25, Y+14	; 0x0e
    ba7e:	48 0f       	add	r20, r24
    ba80:	59 1f       	adc	r21, r25

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    ba82:	41 5f       	subi	r20, 0xF1	; 241
    ba84:	5f 4f       	sbci	r21, 0xFF	; 255
    ba86:	fa 01       	movw	r30, r20
    ba88:	84 91       	lpm	r24, Z+
    ba8a:	4f 50       	subi	r20, 0x0F	; 15
    ba8c:	50 40       	sbci	r21, 0x00	; 0
    ba8e:	8b 83       	std	Y+3, r24	; 0x03

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    ba90:	ca 01       	movw	r24, r20
    ba92:	0d 96       	adiw	r24, 0x0d	; 13
    ba94:	fc 01       	movw	r30, r24
    ba96:	25 91       	lpm	r18, Z+
    ba98:	34 91       	lpm	r19, Z+
			Param.Txt = prp(&(OF+OF_N)->EnumList);
    ba9a:	3e 83       	std	Y+6, r19	; 0x06
    ba9c:	2d 83       	std	Y+5, r18	; 0x05
			if(LineN==CurrLine && OF_N==CurrField)
    ba9e:	80 91 83 07 	lds	r24, 0x0783
    baa2:	ff 85       	ldd	r31, Y+15	; 0x0f
    baa4:	f8 17       	cp	r31, r24
    baa6:	29 f4       	brne	.+10     	; 0xbab2 <PutLine+0x1da>
    baa8:	80 91 d6 02 	lds	r24, 0x02D6
    baac:	88 16       	cp	r8, r24
    baae:	09 f4       	brne	.+2      	; 0xbab2 <PutLine+0x1da>
    bab0:	43 c0       	rjmp	.+134    	; 0xbb38 <PutLine+0x260>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    bab2:	fa 01       	movw	r30, r20
    bab4:	84 91       	lpm	r24, Z+

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    bab6:	31 96       	adiw	r30, 0x01	; 1
    bab8:	65 91       	lpm	r22, Z+
    baba:	74 91       	lpm	r23, Z+
				}
				else{ 
					PutBuf(prb(&(OF+OF_N)->Type), &Param);
				}			
			else
				PutField(prb(&(OF+OF_N)->Type), prp(&(OF+OF_N)->Var), &Param);
    babc:	a3 01       	movw	r20, r6
    babe:	0e 94 e7 5a 	call	0xb5ce	; 0xb5ce <PutField>
    bac2:	3c 81       	ldd	r19, Y+4	; 0x04
			OF_N++;
    bac4:	83 94       	inc	r8
    bac6:	75 cf       	rjmp	.-278    	; 0xb9b2 <PutLine+0xda>
		}
		LCD_Buf[Y][X+=Param.Size] = Char;

	}
	X=X1;
	for(;X<LCDXSz; X++) LCD_Buf[Y][X] = ' ';
    bac8:	f3 e1       	ldi	r31, 0x13	; 19
    baca:	f9 15       	cp	r31, r9
    bacc:	e0 f0       	brcs	.+56     	; 0xbb06 <PutLine+0x22e>
    bace:	88 89       	ldd	r24, Y+16	; 0x10
    bad0:	28 2f       	mov	r18, r24
    bad2:	30 e0       	ldi	r19, 0x00	; 0
    bad4:	49 2d       	mov	r20, r9
    bad6:	c9 01       	movw	r24, r18
    bad8:	88 0f       	add	r24, r24
    bada:	99 1f       	adc	r25, r25
    badc:	82 0f       	add	r24, r18
    bade:	93 1f       	adc	r25, r19
    bae0:	9c 01       	movw	r18, r24
    bae2:	22 0f       	add	r18, r18
    bae4:	33 1f       	adc	r19, r19
    bae6:	22 0f       	add	r18, r18
    bae8:	33 1f       	adc	r19, r19
    baea:	22 0f       	add	r18, r18
    baec:	33 1f       	adc	r19, r19
    baee:	28 1b       	sub	r18, r24
    baf0:	39 0b       	sbc	r19, r25
    baf2:	80 e2       	ldi	r24, 0x20	; 32
    baf4:	f9 01       	movw	r30, r18
    baf6:	e4 0f       	add	r30, r20
    baf8:	f1 1d       	adc	r31, r1
    bafa:	ea 5a       	subi	r30, 0xAA	; 170
    bafc:	f9 4f       	sbci	r31, 0xF9	; 249
    bafe:	80 83       	st	Z, r24
    bb00:	4f 5f       	subi	r20, 0xFF	; 255
    bb02:	44 31       	cpi	r20, 0x14	; 20
    bb04:	b8 f3       	brcs	.-18     	; 0xbaf4 <PutLine+0x21c>

}
    bb06:	60 96       	adiw	r28, 0x10	; 16
    bb08:	0f b6       	in	r0, 0x3f	; 63
    bb0a:	f8 94       	cli
    bb0c:	de bf       	out	0x3e, r29	; 62
    bb0e:	0f be       	out	0x3f, r0	; 63
    bb10:	cd bf       	out	0x3d, r28	; 61
    bb12:	cf 91       	pop	r28
    bb14:	df 91       	pop	r29
    bb16:	1f 91       	pop	r17
    bb18:	0f 91       	pop	r16
    bb1a:	ff 90       	pop	r15
    bb1c:	ef 90       	pop	r14
    bb1e:	df 90       	pop	r13
    bb20:	cf 90       	pop	r12
    bb22:	bf 90       	pop	r11
    bb24:	af 90       	pop	r10
    bb26:	9f 90       	pop	r9
    bb28:	8f 90       	pop	r8
    bb2a:	7f 90       	pop	r7
    bb2c:	6f 90       	pop	r6
    bb2e:	5f 90       	pop	r5
    bb30:	4f 90       	pop	r4
    bb32:	3f 90       	pop	r3
    bb34:	2f 90       	pop	r2
    bb36:	08 95       	ret

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    bb38:	fa 01       	movw	r30, r20
    bb3a:	84 91       	lpm	r24, Z+
			Y1=Y;
			Param.Prec = prb(&(OF+OF_N)->Prec);
			Param.Txt = prp(&(OF+OF_N)->EnumList);
			if(LineN==CurrLine && OF_N==CurrField)
				//add new
				if( (prb(&(OF+OF_N)->Type) == Text) || (prb(&(OF+OF_N)->Type) == EE_Text ) ||
    bb3c:	81 32       	cpi	r24, 0x21	; 33
    bb3e:	61 f1       	breq	.+88     	; 0xbb98 <PutLine+0x2c0>
    bb40:	82 32       	cpi	r24, 0x22	; 34
    bb42:	51 f1       	breq	.+84     	; 0xbb98 <PutLine+0x2c0>
    bb44:	80 31       	cpi	r24, 0x10	; 16
    bb46:	41 f1       	breq	.+80     	; 0xbb98 <PutLine+0x2c0>
    bb48:	84 31       	cpi	r24, 0x14	; 20
    bb4a:	31 f1       	breq	.+76     	; 0xbb98 <PutLine+0x2c0>
    bb4c:	81 31       	cpi	r24, 0x11	; 17
    bb4e:	21 f1       	breq	.+72     	; 0xbb98 <PutLine+0x2c0>
    bb50:	85 31       	cpi	r24, 0x15	; 21
    bb52:	11 f1       	breq	.+68     	; 0xbb98 <PutLine+0x2c0>
    bb54:	82 31       	cpi	r24, 0x12	; 18
    bb56:	01 f1       	breq	.+64     	; 0xbb98 <PutLine+0x2c0>
    bb58:	83 31       	cpi	r24, 0x13	; 19
    bb5a:	f1 f0       	breq	.+60     	; 0xbb98 <PutLine+0x2c0>
    bb5c:	89 31       	cpi	r24, 0x19	; 25
    bb5e:	e1 f0       	breq	.+56     	; 0xbb98 <PutLine+0x2c0>
    bb60:	8b 31       	cpi	r24, 0x1B	; 27
    bb62:	d1 f0       	breq	.+52     	; 0xbb98 <PutLine+0x2c0>
    bb64:	8a 31       	cpi	r24, 0x1A	; 26
    bb66:	c1 f0       	breq	.+48     	; 0xbb98 <PutLine+0x2c0>
    bb68:	8c 31       	cpi	r24, 0x1C	; 28
    bb6a:	b1 f0       	breq	.+44     	; 0xbb98 <PutLine+0x2c0>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
PutBuf(uint8_t Type, T_Param *Param)
{
	switch(Type) {
    bb6c:	89 30       	cpi	r24, 0x09	; 9
    bb6e:	08 f0       	brcs	.+2      	; 0xbb72 <PutLine+0x29a>
    bb70:	b7 c0       	rjmp	.+366    	; 0xbce0 <PutLine+0x408>
    bb72:	87 30       	cpi	r24, 0x07	; 7
    bb74:	08 f0       	brcs	.+2      	; 0xbb78 <PutLine+0x2a0>
    bb76:	b9 c0       	rjmp	.+370    	; 0xbcea <PutLine+0x412>
    bb78:	84 30       	cpi	r24, 0x04	; 4
    bb7a:	08 f0       	brcs	.+2      	; 0xbb7e <PutLine+0x2a6>
    bb7c:	e5 c0       	rjmp	.+458    	; 0xbd48 <PutLine+0x470>
    bb7e:	82 30       	cpi	r24, 0x02	; 2
    bb80:	08 f4       	brcc	.+2      	; 0xbb84 <PutLine+0x2ac>
    bb82:	b3 c0       	rjmp	.+358    	; 0xbcea <PutLine+0x412>
		Put_bVal(Param);
		PosBlink(Param,' ');
		break;
	case s_Byte: case s_EE_Byte:
	case s_Word: case s_EE_Word:
		Put_sbVal(Param);
    bb84:	c3 01       	movw	r24, r6
    bb86:	0e 94 cf 40 	call	0x819e	; 0x819e <Put_sbVal>
		PosBlink(Param,' ');
    bb8a:	c3 01       	movw	r24, r6
    bb8c:	60 e2       	ldi	r22, 0x20	; 32
    bb8e:	0e 94 bc 3c 	call	0x7978	; 0x7978 <PosBlink>
    bb92:	3c 81       	ldd	r19, Y+4	; 0x04
				else{ 
					PutBuf(prb(&(OF+OF_N)->Type), &Param);
				}			
			else
				PutField(prb(&(OF+OF_N)->Type), prp(&(OF+OF_N)->Var), &Param);
			OF_N++;
    bb94:	83 94       	inc	r8
    bb96:	0d cf       	rjmp	.-486    	; 0xb9b2 <PutLine+0xda>
// When use BufStr for variable edit
inline static void
PutBufStr(uint8_t Type, T_Param *Param)
{	
	char Format[6];
	sprintf(Format,"%%.%us", Param->Size);
    bb98:	00 d0       	rcall	.+0      	; 0xbb9a <PutLine+0x2c2>
    bb9a:	00 d0       	rcall	.+0      	; 0xbb9c <PutLine+0x2c4>
    bb9c:	ed b7       	in	r30, 0x3d	; 61
    bb9e:	fe b7       	in	r31, 0x3e	; 62
    bba0:	31 96       	adiw	r30, 0x01	; 1
    bba2:	27 e0       	ldi	r18, 0x07	; 7
    bba4:	30 e0       	ldi	r19, 0x00	; 0
    bba6:	2c 0f       	add	r18, r28
    bba8:	3d 1f       	adc	r19, r29
    bbaa:	ad b7       	in	r26, 0x3d	; 61
    bbac:	be b7       	in	r27, 0x3e	; 62
    bbae:	12 96       	adiw	r26, 0x02	; 2
    bbb0:	3c 93       	st	X, r19
    bbb2:	2e 93       	st	-X, r18
    bbb4:	11 97       	sbiw	r26, 0x01	; 1
    bbb6:	8b ea       	ldi	r24, 0xAB	; 171
    bbb8:	92 e0       	ldi	r25, 0x02	; 2
    bbba:	93 83       	std	Z+3, r25	; 0x03
    bbbc:	82 83       	std	Z+2, r24	; 0x02
    bbbe:	8c 81       	ldd	r24, Y+4	; 0x04
    bbc0:	84 83       	std	Z+4, r24	; 0x04
    bbc2:	15 82       	std	Z+5, r1	; 0x05
    bbc4:	0e 94 ad 7f 	call	0xff5a	; 0xff5a <sprintf>
	sprintf(Param->Pos, Format, BufStr);
    bbc8:	ed b7       	in	r30, 0x3d	; 61
    bbca:	fe b7       	in	r31, 0x3e	; 62
    bbcc:	31 96       	adiw	r30, 0x01	; 1
    bbce:	89 81       	ldd	r24, Y+1	; 0x01
    bbd0:	9a 81       	ldd	r25, Y+2	; 0x02
    bbd2:	ad b7       	in	r26, 0x3d	; 61
    bbd4:	be b7       	in	r27, 0x3e	; 62
    bbd6:	12 96       	adiw	r26, 0x02	; 2
    bbd8:	9c 93       	st	X, r25
    bbda:	8e 93       	st	-X, r24
    bbdc:	11 97       	sbiw	r26, 0x01	; 1
    bbde:	27 e0       	ldi	r18, 0x07	; 7
    bbe0:	30 e0       	ldi	r19, 0x00	; 0
    bbe2:	2c 0f       	add	r18, r28
    bbe4:	3d 1f       	adc	r19, r29
    bbe6:	33 83       	std	Z+3, r19	; 0x03
    bbe8:	22 83       	std	Z+2, r18	; 0x02
    bbea:	81 ec       	ldi	r24, 0xC1	; 193
    bbec:	95 e0       	ldi	r25, 0x05	; 5
    bbee:	95 83       	std	Z+5, r25	; 0x05
    bbf0:	84 83       	std	Z+4, r24	; 0x04
    bbf2:	0e 94 ad 7f 	call	0xff5a	; 0xff5a <sprintf>
	Param->Prec = 0;
    bbf6:	1b 82       	std	Y+3, r1	; 0x03
	PosBlink(Param,'_');
    bbf8:	ad b7       	in	r26, 0x3d	; 61
    bbfa:	be b7       	in	r27, 0x3e	; 62
    bbfc:	16 96       	adiw	r26, 0x06	; 6
    bbfe:	0f b6       	in	r0, 0x3f	; 63
    bc00:	f8 94       	cli
    bc02:	be bf       	out	0x3e, r27	; 62
    bc04:	0f be       	out	0x3f, r0	; 63
    bc06:	ad bf       	out	0x3d, r26	; 61
    bc08:	c3 01       	movw	r24, r6
    bc0a:	6f e5       	ldi	r22, 0x5F	; 95
    bc0c:	0e 94 bc 3c 	call	0x7978	; 0x7978 <PosBlink>
    bc10:	3c 81       	ldd	r19, Y+4	; 0x04
				else{ 
					PutBuf(prb(&(OF+OF_N)->Type), &Param);
				}			
			else
				PutField(prb(&(OF+OF_N)->Type), prp(&(OF+OF_N)->Var), &Param);
			OF_N++;
    bc12:	83 94       	inc	r8
    bc14:	ce ce       	rjmp	.-612    	; 0xb9b2 <PutLine+0xda>

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    bc16:	08 94       	sec
    bc18:	e1 1c       	adc	r14, r1
    bc1a:	f1 1c       	adc	r15, r1
    bc1c:	f7 01       	movw	r30, r14
    bc1e:	84 91       	lpm	r24, Z+
    bc20:	08 94       	sec
    bc22:	e1 08       	sbc	r14, r1
    bc24:	f1 08       	sbc	r15, r1
		X1 = strlen_P(CurrStr) - 2;
		X0 = 0;
		Xs = X0-2;
	}
	//--- "<>" Align center
	if(prc(CurrStr+0) == '<' && prc(CurrStr+1) == '>'){
    bc26:	8e 33       	cpi	r24, 0x3E	; 62
    bc28:	09 f0       	breq	.+2      	; 0xbc2c <PutLine+0x354>
    bc2a:	9f ce       	rjmp	.-706    	; 0xb96a <PutLine+0x92>
		X0 = (LCDXSz - strlen_P(CurrStr) + 2) / 2;
    bc2c:	8b 2d       	mov	r24, r11
    bc2e:	9a 2d       	mov	r25, r10
    bc30:	0e 94 c1 7e 	call	0xfd82	; 0xfd82 <strlen_P>
    bc34:	26 e1       	ldi	r18, 0x16	; 22
    bc36:	30 e0       	ldi	r19, 0x00	; 0
    bc38:	28 1b       	sub	r18, r24
    bc3a:	39 0b       	sbc	r19, r25
    bc3c:	36 95       	lsr	r19
    bc3e:	27 95       	ror	r18
    bc40:	42 2f       	mov	r20, r18
		Xs = X0-2;
    bc42:	52 2f       	mov	r21, r18
    bc44:	52 50       	subi	r21, 0x02	; 2
		X1 = X0 + (strlen_P(CurrStr) - 2);
    bc46:	be ef       	ldi	r27, 0xFE	; 254
    bc48:	9b 2e       	mov	r9, r27
    bc4a:	98 0e       	add	r9, r24
    bc4c:	92 0e       	add	r9, r18
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';		
    bc4e:	22 23       	and	r18, r18
    bc50:	09 f4       	brne	.+2      	; 0xbc54 <PutLine+0x37c>
    bc52:	8b ce       	rjmp	.-746    	; 0xb96a <PutLine+0x92>
    bc54:	85 e1       	ldi	r24, 0x15	; 21
    bc56:	28 89       	ldd	r18, Y+16	; 0x10
    bc58:	28 9f       	mul	r18, r24
    bc5a:	f0 01       	movw	r30, r0
    bc5c:	11 24       	eor	r1, r1
    bc5e:	ea 5a       	subi	r30, 0xAA	; 170
    bc60:	f9 4f       	sbci	r31, 0xF9	; 249
    bc62:	80 e0       	ldi	r24, 0x00	; 0
    bc64:	90 e2       	ldi	r25, 0x20	; 32
    bc66:	91 93       	st	Z+, r25
    bc68:	8f 5f       	subi	r24, 0xFF	; 255
    bc6a:	84 17       	cp	r24, r20
    bc6c:	e0 f3       	brcs	.-8      	; 0xbc66 <PutLine+0x38e>
    bc6e:	7d ce       	rjmp	.-774    	; 0xb96a <PutLine+0x92>
    bc70:	08 94       	sec
    bc72:	e1 1c       	adc	r14, r1
    bc74:	f1 1c       	adc	r15, r1
    bc76:	f7 01       	movw	r30, r14
    bc78:	84 91       	lpm	r24, Z+
    bc7a:	08 94       	sec
    bc7c:	e1 08       	sbc	r14, r1
    bc7e:	f1 08       	sbc	r15, r1
		X0 = LCDXSz - strlen_P(CurrStr) + 2;
		Xs = X0-2;
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';
	}
	//--- "<<" Align left
	if(prc(CurrStr+0) == '<' && prc(CurrStr+1) == '<'){
    bc80:	8c 33       	cpi	r24, 0x3C	; 60
    bc82:	09 f0       	breq	.+2      	; 0xbc86 <PutLine+0x3ae>
    bc84:	6b ce       	rjmp	.-810    	; 0xb95c <PutLine+0x84>
		X1 = strlen_P(CurrStr) - 2;
    bc86:	8b 2d       	mov	r24, r11
    bc88:	9a 2d       	mov	r25, r10
    bc8a:	0e 94 c1 7e 	call	0xfd82	; 0xfd82 <strlen_P>
    bc8e:	9e ef       	ldi	r25, 0xFE	; 254
    bc90:	99 2e       	mov	r9, r25
    bc92:	98 0e       	add	r9, r24
    bc94:	40 e0       	ldi	r20, 0x00	; 0
    bc96:	5e ef       	ldi	r21, 0xFE	; 254
    bc98:	63 ce       	rjmp	.-826    	; 0xb960 <PutLine+0x88>
    bc9a:	08 94       	sec
    bc9c:	e1 1c       	adc	r14, r1
    bc9e:	f1 1c       	adc	r15, r1
    bca0:	f7 01       	movw	r30, r14
    bca2:	84 91       	lpm	r24, Z+
    bca4:	08 94       	sec
    bca6:	e1 08       	sbc	r14, r1
    bca8:	f1 08       	sbc	r15, r1
	uint8_t X;
	uint8_t X0=0;
	uint8_t X1=LCDXSz;
	int8_t Xs = 0;
	//--- ">>" Align right
	if(prc(CurrStr+0) == '>' && prc(CurrStr+1) == '>'){
    bcaa:	8e 33       	cpi	r24, 0x3E	; 62
    bcac:	09 f0       	breq	.+2      	; 0xbcb0 <PutLine+0x3d8>
    bcae:	4f ce       	rjmp	.-866    	; 0xb94e <PutLine+0x76>
		X0 = LCDXSz - strlen_P(CurrStr) + 2;
    bcb0:	c7 01       	movw	r24, r14
    bcb2:	0e 94 c1 7e 	call	0xfd82	; 0xfd82 <strlen_P>
    bcb6:	46 e1       	ldi	r20, 0x16	; 22
    bcb8:	48 1b       	sub	r20, r24
		Xs = X0-2;
    bcba:	54 2f       	mov	r21, r20
    bcbc:	52 50       	subi	r21, 0x02	; 2
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';
    bcbe:	44 23       	and	r20, r20
    bcc0:	09 f4       	brne	.+2      	; 0xbcc4 <PutLine+0x3ec>
    bcc2:	47 ce       	rjmp	.-882    	; 0xb952 <PutLine+0x7a>
    bcc4:	85 e1       	ldi	r24, 0x15	; 21
    bcc6:	28 89       	ldd	r18, Y+16	; 0x10
    bcc8:	28 9f       	mul	r18, r24
    bcca:	f0 01       	movw	r30, r0
    bccc:	11 24       	eor	r1, r1
    bcce:	ea 5a       	subi	r30, 0xAA	; 170
    bcd0:	f9 4f       	sbci	r31, 0xF9	; 249
    bcd2:	80 e0       	ldi	r24, 0x00	; 0
    bcd4:	90 e2       	ldi	r25, 0x20	; 32
    bcd6:	91 93       	st	Z+, r25
    bcd8:	8f 5f       	subi	r24, 0xFF	; 255
    bcda:	84 17       	cp	r24, r20
    bcdc:	e0 f3       	brcs	.-8      	; 0xbcd6 <PutLine+0x3fe>
    bcde:	39 ce       	rjmp	.-910    	; 0xb952 <PutLine+0x7a>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
PutBuf(uint8_t Type, T_Param *Param)
{
	switch(Type) {
    bce0:	8d 30       	cpi	r24, 0x0D	; 13
    bce2:	68 f4       	brcc	.+26     	; 0xbcfe <PutLine+0x426>
    bce4:	8b 30       	cpi	r24, 0x0B	; 11
    bce6:	08 f4       	brcc	.+2      	; 0xbcea <PutLine+0x412>
    bce8:	4d cf       	rjmp	.-358    	; 0xbb84 <PutLine+0x2ac>
	case Byte: case EE_Byte: case z_Byte: case z_EE_Byte:
	case Word: case EE_Word: case z_Word: case z_EE_Word:
		Put_bVal(Param);
    bcea:	c3 01       	movw	r24, r6
    bcec:	0e 94 cd 41 	call	0x839a	; 0x839a <Put_bVal>
		PosBlink(Param,' ');
    bcf0:	c3 01       	movw	r24, r6
    bcf2:	60 e2       	ldi	r22, 0x20	; 32
    bcf4:	0e 94 bc 3c 	call	0x7978	; 0x7978 <PosBlink>
    bcf8:	3c 81       	ldd	r19, Y+4	; 0x04
				else{ 
					PutBuf(prb(&(OF+OF_N)->Type), &Param);
				}			
			else
				PutField(prb(&(OF+OF_N)->Type), prp(&(OF+OF_N)->Var), &Param);
			OF_N++;
    bcfa:	83 94       	inc	r8
    bcfc:	5a ce       	rjmp	.-844    	; 0xb9b2 <PutLine+0xda>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
PutBuf(uint8_t Type, T_Param *Param)
{
	switch(Type) {
    bcfe:	8e 30       	cpi	r24, 0x0E	; 14
    bd00:	b9 f1       	breq	.+110    	; 0xbd70 <PutLine+0x498>
    bd02:	8e 30       	cpi	r24, 0x0E	; 14
    bd04:	28 f1       	brcs	.+74     	; 0xbd50 <PutLine+0x478>
    bd06:	8d 51       	subi	r24, 0x1D	; 29
    bd08:	84 30       	cpi	r24, 0x04	; 4
    bd0a:	08 f0       	brcs	.+2      	; 0xbd0e <PutLine+0x436>
    bd0c:	da ce       	rjmp	.-588    	; 0xbac2 <PutLine+0x1ea>
	case zc_Word:
		Put_zVal(F_Buf, 'w', Param);
		ValBlink(Param->Pos, Param->Size);
		break;
	case Enum: case EE_Enum: case Bit: case EE_Bit:
		Param->Txt += (uint8_t)F_Buf;
    bd0e:	80 91 f5 04 	lds	r24, 0x04F5
    bd12:	90 e0       	ldi	r25, 0x00	; 0
    bd14:	88 0f       	add	r24, r24
    bd16:	99 1f       	adc	r25, r25
    bd18:	28 0f       	add	r18, r24
    bd1a:	39 1f       	adc	r19, r25
    bd1c:	3e 83       	std	Y+6, r19	; 0x06
    bd1e:	2d 83       	std	Y+5, r18	; 0x05
		PutEnum(Param);
    bd20:	c3 01       	movw	r24, r6
    bd22:	0e 94 9e 40 	call	0x813c	; 0x813c <PutEnum>
		ValBlink(Param->Pos, Param->Size);
    bd26:	3c 81       	ldd	r19, Y+4	; 0x04

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
ValBlink(char *Pos, uint8_t Sz)
{
	CurrX=Pos-LCD_Buf[Y1];
    bd28:	80 91 fd 09 	lds	r24, 0x09FD
    bd2c:	f5 e1       	ldi	r31, 0x15	; 21
    bd2e:	8f 9f       	mul	r24, r31
    bd30:	c0 01       	movw	r24, r0
    bd32:	11 24       	eor	r1, r1
    bd34:	8a 5a       	subi	r24, 0xAA	; 170
    bd36:	99 4f       	sbci	r25, 0xF9	; 249
    bd38:	29 81       	ldd	r18, Y+1	; 0x01
    bd3a:	28 1b       	sub	r18, r24
    bd3c:	20 93 b7 06 	sts	0x06B7, r18
	StrSize=Sz; 
    bd40:	30 93 aa 06 	sts	0x06AA, r19
				else{ 
					PutBuf(prb(&(OF+OF_N)->Type), &Param);
				}			
			else
				PutField(prb(&(OF+OF_N)->Type), prp(&(OF+OF_N)->Var), &Param);
			OF_N++;
    bd44:	83 94       	inc	r8
    bd46:	35 ce       	rjmp	.-918    	; 0xb9b2 <PutLine+0xda>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
PutBuf(uint8_t Type, T_Param *Param)
{
	switch(Type) {
    bd48:	86 30       	cpi	r24, 0x06	; 6
    bd4a:	78 f2       	brcs	.-98     	; 0xbcea <PutLine+0x412>
    bd4c:	3c 81       	ldd	r19, Y+4	; 0x04
    bd4e:	ba ce       	rjmp	.-652    	; 0xbac4 <PutLine+0x1ec>
	case s_Word: case s_EE_Word:
		Put_sbVal(Param);
		PosBlink(Param,' ');
		break;
	case c_Word:
		PutVal(F_Buf, 'w', Param);
    bd50:	80 91 f5 04 	lds	r24, 0x04F5
    bd54:	90 91 f6 04 	lds	r25, 0x04F6
    bd58:	67 e7       	ldi	r22, 0x77	; 119
    bd5a:	a3 01       	movw	r20, r6
    bd5c:	0e 94 9c 49 	call	0x9338	; 0x9338 <PutVal>
		ValBlink(Param->Pos, Param->Size);
    bd60:	3c 81       	ldd	r19, Y+4	; 0x04

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
ValBlink(char *Pos, uint8_t Sz)
{
	CurrX=Pos-LCD_Buf[Y1];
    bd62:	80 91 fd 09 	lds	r24, 0x09FD
    bd66:	b5 e1       	ldi	r27, 0x15	; 21
    bd68:	8b 9f       	mul	r24, r27
    bd6a:	c0 01       	movw	r24, r0
    bd6c:	11 24       	eor	r1, r1
    bd6e:	e2 cf       	rjmp	.-60     	; 0xbd34 <PutLine+0x45c>
	case c_Word:
		PutVal(F_Buf, 'w', Param);
		ValBlink(Param->Pos, Param->Size);
		break;
	case zc_Word:
		Put_zVal(F_Buf, 'w', Param);
    bd70:	80 91 f5 04 	lds	r24, 0x04F5
    bd74:	90 91 f6 04 	lds	r25, 0x04F6
    bd78:	67 e7       	ldi	r22, 0x77	; 119
    bd7a:	a3 01       	movw	r20, r6
    bd7c:	0e 94 fb 47 	call	0x8ff6	; 0x8ff6 <Put_zVal>
		ValBlink(Param->Pos, Param->Size);
    bd80:	3c 81       	ldd	r19, Y+4	; 0x04

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
ValBlink(char *Pos, uint8_t Sz)
{
	CurrX=Pos-LCD_Buf[Y1];
    bd82:	80 91 fd 09 	lds	r24, 0x09FD
    bd86:	e5 e1       	ldi	r30, 0x15	; 21
    bd88:	8e 9f       	mul	r24, r30
    bd8a:	c0 01       	movw	r24, r0
    bd8c:	11 24       	eor	r1, r1
    bd8e:	d2 cf       	rjmp	.-92     	; 0xbd34 <PutLine+0x45c>

0000bd90 <MenuOut>:
	while(X<LCDXSz)	LCD_Buf[Y][X++] = ' ';
}
// ~~~~~~~~~~
void
MenuOut(void)
{
    bd90:	2f 92       	push	r2
    bd92:	3f 92       	push	r3
    bd94:	4f 92       	push	r4
    bd96:	5f 92       	push	r5
    bd98:	6f 92       	push	r6
    bd9a:	7f 92       	push	r7
    bd9c:	8f 92       	push	r8
    bd9e:	9f 92       	push	r9
    bda0:	af 92       	push	r10
    bda2:	bf 92       	push	r11
    bda4:	cf 92       	push	r12
    bda6:	df 92       	push	r13
    bda8:	ef 92       	push	r14
    bdaa:	ff 92       	push	r15
    bdac:	0f 93       	push	r16
    bdae:	1f 93       	push	r17
    bdb0:	df 93       	push	r29
    bdb2:	cf 93       	push	r28
    bdb4:	cd b7       	in	r28, 0x3d	; 61
    bdb6:	de b7       	in	r29, 0x3e	; 62
    bdb8:	2a 97       	sbiw	r28, 0x0a	; 10
    bdba:	0f b6       	in	r0, 0x3f	; 63
    bdbc:	f8 94       	cli
    bdbe:	de bf       	out	0x3e, r29	; 62
    bdc0:	0f be       	out	0x3f, r0	; 63
    bdc2:	cd bf       	out	0x3d, r28	; 61
	uint8_t Y;
	if(CurrMsg) {
    bdc4:	a0 90 f3 04 	lds	r10, 0x04F3
    bdc8:	b0 90 f4 04 	lds	r11, 0x04F4
    bdcc:	a1 14       	cp	r10, r1
    bdce:	b1 04       	cpc	r11, r1
    bdd0:	09 f4       	brne	.+2      	; 0xbdd4 <MenuOut+0x44>
    bdd2:	6a c1       	rjmp	.+724    	; 0xc0a8 <MenuOut+0x318>
    bdd4:	22 24       	eor	r2, r2
    bdd6:	33 24       	eor	r3, r3
    bdd8:	18 86       	std	Y+8, r1	; 0x08
    bdda:	1f 82       	std	Y+7, r1	; 0x07
	int8_t Xs = 0;
	//--- ">>" Align right
	if(prc(CurrStr+0) == '>' && prc(CurrStr+1) == '>'){
		X0 = LCDXSz - strlen_P(CurrStr) + 2;
		Xs = X0-2;
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';
    bddc:	80 e2       	ldi	r24, 0x20	; 32
    bdde:	48 2e       	mov	r4, r24
	#if TypeLCD==840
		const MsgLine *Line=(MsgLine*)prp(&CurrMsg->LineList)+Y;
	#else
		const MsgLine *Line=CurrMsg->LineList+Y;		
	#endif
	PGM_P CurrStr=(PGM_P)(Line->Str);
    bde0:	91 01       	movw	r18, r2
    bde2:	22 0f       	add	r18, r18
    bde4:	33 1f       	adc	r19, r19
    bde6:	3a 87       	std	Y+10, r19	; 0x0a
    bde8:	29 87       	std	Y+9, r18	; 0x09
    bdea:	49 01       	movw	r8, r18
    bdec:	82 0c       	add	r8, r2
    bdee:	93 1c       	adc	r9, r3
    bdf0:	64 01       	movw	r12, r8
    bdf2:	cc 0c       	add	r12, r12
    bdf4:	dd 1c       	adc	r13, r13
    bdf6:	cc 0c       	add	r12, r12
    bdf8:	dd 1c       	adc	r13, r13
    bdfa:	cc 0c       	add	r12, r12
    bdfc:	dd 1c       	adc	r13, r13
    bdfe:	96 01       	movw	r18, r12
    be00:	22 19       	sub	r18, r2
    be02:	33 09       	sbc	r19, r3
    be04:	75 01       	movw	r14, r10
    be06:	e2 0e       	add	r14, r18
    be08:	f3 1e       	adc	r15, r19

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    be0a:	2b 5e       	subi	r18, 0xEB	; 235
    be0c:	3f 4f       	sbci	r19, 0xFF	; 255
    be0e:	c5 01       	movw	r24, r10
    be10:	82 0f       	add	r24, r18
    be12:	93 1f       	adc	r25, r19
    be14:	25 51       	subi	r18, 0x15	; 21
    be16:	30 40       	sbci	r19, 0x00	; 0
    be18:	fc 01       	movw	r30, r24
    be1a:	65 90       	lpm	r6, Z+
    be1c:	74 90       	lpm	r7, Z+

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    be1e:	f7 01       	movw	r30, r14
    be20:	84 91       	lpm	r24, Z+
	uint8_t X;
	uint8_t X0=0;
	uint8_t X1=LCDXSz;
	int8_t Xs = 0;
	//--- ">>" Align right
	if(prc(CurrStr+0) == '>' && prc(CurrStr+1) == '>'){
    be22:	8e 33       	cpi	r24, 0x3E	; 62
    be24:	09 f4       	brne	.+2      	; 0xbe28 <MenuOut+0x98>
    be26:	b3 c0       	rjmp	.+358    	; 0xbf8e <MenuOut+0x1fe>
		X0 = LCDXSz - strlen_P(CurrStr) + 2;
		Xs = X0-2;
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';
    be28:	90 e0       	ldi	r25, 0x00	; 0
    be2a:	00 e0       	ldi	r16, 0x00	; 0
    be2c:	f7 01       	movw	r30, r14
    be2e:	84 91       	lpm	r24, Z+
	}
	//--- "<<" Align left
	if(prc(CurrStr+0) == '<' && prc(CurrStr+1) == '<'){
    be30:	8c 33       	cpi	r24, 0x3C	; 60
    be32:	09 f4       	brne	.+2      	; 0xbe36 <MenuOut+0xa6>
    be34:	cd c0       	rjmp	.+410    	; 0xbfd0 <MenuOut+0x240>
		X1 = strlen_P(CurrStr) - 2;
    be36:	f4 e1       	ldi	r31, 0x14	; 20
    be38:	5f 2e       	mov	r5, r31
    be3a:	f7 01       	movw	r30, r14
    be3c:	84 91       	lpm	r24, Z+
		X0 = 0;
		Xs = X0-2;
	}
	//--- "<>" Align center
	if(prc(CurrStr+0) == '<' && prc(CurrStr+1) == '>'){
    be3e:	8c 33       	cpi	r24, 0x3C	; 60
    be40:	09 f4       	brne	.+2      	; 0xbe44 <MenuOut+0xb4>
    be42:	e6 c0       	rjmp	.+460    	; 0xc010 <MenuOut+0x280>
		X1 = X0 + (strlen_P(CurrStr) - 2);
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';		
	}
	//---

	for(X=X0; X<X1; X++){
    be44:	05 15       	cp	r16, r5
    be46:	08 f0       	brcs	.+2      	; 0xbe4a <MenuOut+0xba>
    be48:	73 c0       	rjmp	.+230    	; 0xbf30 <MenuOut+0x1a0>
		const MsgLine *Line=(MsgLine*)prp(&CurrMsg->LineList)+Y;
	#else
		const MsgLine *Line=CurrMsg->LineList+Y;		
	#endif
	PGM_P CurrStr=(PGM_P)(Line->Str);
	InField *IF = prp(&Line->IF_List);
    be4a:	73 01       	movw	r14, r6
    be4c:	69 2e       	mov	r6, r25
    be4e:	77 24       	eor	r7, r7
    be50:	67 fc       	sbrc	r6, 7
    be52:	70 94       	com	r7
    be54:	29 85       	ldd	r18, Y+9	; 0x09
    be56:	3a 85       	ldd	r19, Y+10	; 0x0a
    be58:	22 0d       	add	r18, r2
    be5a:	33 1d       	adc	r19, r3
    be5c:	c9 01       	movw	r24, r18
    be5e:	88 0f       	add	r24, r24
    be60:	99 1f       	adc	r25, r25
    be62:	88 0f       	add	r24, r24
    be64:	99 1f       	adc	r25, r25
    be66:	88 0f       	add	r24, r24
    be68:	99 1f       	adc	r25, r25
    be6a:	6c 01       	movw	r12, r24
    be6c:	c2 18       	sub	r12, r2
    be6e:	d3 08       	sbc	r13, r3
			Param.Txt = prp(&IF->EnumList);
			PutField(prb(&IF->Type), prp(&IF->Var), &Param);
			IF++;
			X += Param.Size;
		}
		LCD_Buf[Y][X] = Char;
    be70:	4c 01       	movw	r8, r24
    be72:	82 1a       	sub	r8, r18
    be74:	93 0a       	sbc	r9, r19
    be76:	09 c0       	rjmp	.+18     	; 0xbe8a <MenuOut+0xfa>
    be78:	a8 0d       	add	r26, r8
    be7a:	b9 1d       	adc	r27, r9
    be7c:	aa 5a       	subi	r26, 0xAA	; 170
    be7e:	b9 4f       	sbci	r27, 0xF9	; 249
    be80:	1c 93       	st	X, r17
		X1 = X0 + (strlen_P(CurrStr) - 2);
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';		
	}
	//---

	for(X=X0; X<X1; X++){
    be82:	0f 5f       	subi	r16, 0xFF	; 255
    be84:	05 15       	cp	r16, r5
    be86:	08 f0       	brcs	.+2      	; 0xbe8a <MenuOut+0xfa>
    be88:	4f c0       	rjmp	.+158    	; 0xbf28 <MenuOut+0x198>
		char Char;
		if((Char=prc(CurrStr+X-Xs))=='{') {
    be8a:	a0 2f       	mov	r26, r16
    be8c:	b0 e0       	ldi	r27, 0x00	; 0
    be8e:	9d 01       	movw	r18, r26
    be90:	26 19       	sub	r18, r6
    be92:	37 09       	sbc	r19, r7
    be94:	f6 01       	movw	r30, r12
    be96:	e2 0f       	add	r30, r18
    be98:	f3 1f       	adc	r31, r19
    be9a:	ea 0d       	add	r30, r10
    be9c:	fb 1d       	adc	r31, r11
    be9e:	14 91       	lpm	r17, Z+
    bea0:	1b 37       	cpi	r17, 0x7B	; 123
    bea2:	51 f7       	brne	.-44     	; 0xbe78 <MenuOut+0xe8>
			T_Param Param;
			Param.Pos = LCD_Buf[Y]+X;
    bea4:	8f 81       	ldd	r24, Y+7	; 0x07
    bea6:	98 85       	ldd	r25, Y+8	; 0x08
    bea8:	a8 0f       	add	r26, r24
    beaa:	b9 1f       	adc	r27, r25
    beac:	aa 5a       	subi	r26, 0xAA	; 170
    beae:	b9 4f       	sbci	r27, 0xF9	; 249
    beb0:	ba 83       	std	Y+2, r27	; 0x02
    beb2:	a9 83       	std	Y+1, r26	; 0x01
    beb4:	81 e0       	ldi	r24, 0x01	; 1
    beb6:	f9 01       	movw	r30, r18
    beb8:	e8 0f       	add	r30, r24
    beba:	f1 1d       	adc	r31, r1
    bebc:	ec 0d       	add	r30, r12
    bebe:	fd 1d       	adc	r31, r13
    bec0:	ea 0d       	add	r30, r10
    bec2:	fb 1d       	adc	r31, r11
    bec4:	14 91       	lpm	r17, Z+
    bec6:	98 2f       	mov	r25, r24
    bec8:	8f 5f       	subi	r24, 0xFF	; 255
			Param.Size = 0;
			while((Char=prc(CurrStr+X-Xs+ ++Param.Size))=='{');
    beca:	1b 37       	cpi	r17, 0x7B	; 123
    becc:	a1 f3       	breq	.-24     	; 0xbeb6 <MenuOut+0x126>
    bece:	9c 83       	std	Y+4, r25	; 0x04

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    bed0:	e5 e0       	ldi	r30, 0x05	; 5
    bed2:	f0 e0       	ldi	r31, 0x00	; 0
    bed4:	ee 0e       	add	r14, r30
    bed6:	ff 1e       	adc	r15, r31
    bed8:	f7 01       	movw	r30, r14
    beda:	84 91       	lpm	r24, Z+
    bedc:	2b ef       	ldi	r18, 0xFB	; 251
    bede:	3f ef       	ldi	r19, 0xFF	; 255
    bee0:	e2 0e       	add	r14, r18
    bee2:	f3 1e       	adc	r15, r19
			Param.Prec = prb(&IF->Prec);
    bee4:	8b 83       	std	Y+3, r24	; 0x03

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    bee6:	f7 01       	movw	r30, r14
    bee8:	33 96       	adiw	r30, 0x03	; 3
    beea:	85 91       	lpm	r24, Z+
    beec:	94 91       	lpm	r25, Z+
			Param.Txt = prp(&IF->EnumList);
    beee:	9e 83       	std	Y+6, r25	; 0x06
    bef0:	8d 83       	std	Y+5, r24	; 0x05

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    bef2:	f7 01       	movw	r30, r14
    bef4:	84 91       	lpm	r24, Z+

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    bef6:	31 96       	adiw	r30, 0x01	; 1
    bef8:	65 91       	lpm	r22, Z+
    befa:	74 91       	lpm	r23, Z+
			PutField(prb(&IF->Type), prp(&IF->Var), &Param);
    befc:	ae 01       	movw	r20, r28
    befe:	4f 5f       	subi	r20, 0xFF	; 255
    bf00:	5f 4f       	sbci	r21, 0xFF	; 255
    bf02:	0e 94 e7 5a 	call	0xb5ce	; 0xb5ce <PutField>
			IF++;
    bf06:	26 e0       	ldi	r18, 0x06	; 6
    bf08:	30 e0       	ldi	r19, 0x00	; 0
    bf0a:	e2 0e       	add	r14, r18
    bf0c:	f3 1e       	adc	r15, r19
			X += Param.Size;
    bf0e:	8c 81       	ldd	r24, Y+4	; 0x04
    bf10:	08 0f       	add	r16, r24
    bf12:	a0 2f       	mov	r26, r16
    bf14:	b0 e0       	ldi	r27, 0x00	; 0
		}
		LCD_Buf[Y][X] = Char;
    bf16:	a8 0d       	add	r26, r8
    bf18:	b9 1d       	adc	r27, r9
    bf1a:	aa 5a       	subi	r26, 0xAA	; 170
    bf1c:	b9 4f       	sbci	r27, 0xF9	; 249
    bf1e:	1c 93       	st	X, r17
		X1 = X0 + (strlen_P(CurrStr) - 2);
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';		
	}
	//---

	for(X=X0; X<X1; X++){
    bf20:	0f 5f       	subi	r16, 0xFF	; 255
    bf22:	05 15       	cp	r16, r5
    bf24:	08 f4       	brcc	.+2      	; 0xbf28 <MenuOut+0x198>
    bf26:	b1 cf       	rjmp	.-158    	; 0xbe8a <MenuOut+0xfa>
    bf28:	a0 90 f3 04 	lds	r10, 0x04F3
    bf2c:	b0 90 f4 04 	lds	r11, 0x04F4
			X += Param.Size;
		}
		LCD_Buf[Y][X] = Char;
	}
	X=X1;
	for(;X<LCDXSz; X++) LCD_Buf[Y][X] = ' ';
    bf30:	33 e1       	ldi	r19, 0x13	; 19
    bf32:	35 15       	cp	r19, r5
    bf34:	08 f0       	brcs	.+2      	; 0xbf38 <MenuOut+0x1a8>
    bf36:	9f c0       	rjmp	.+318    	; 0xc076 <MenuOut+0x2e6>
    bf38:	08 94       	sec
    bf3a:	21 1c       	adc	r2, r1
    bf3c:	31 1c       	adc	r3, r1
    bf3e:	ef 81       	ldd	r30, Y+7	; 0x07
    bf40:	f8 85       	ldd	r31, Y+8	; 0x08
    bf42:	75 96       	adiw	r30, 0x15	; 21
    bf44:	f8 87       	std	Y+8, r31	; 0x08
    bf46:	ef 83       	std	Y+7, r30	; 0x07
void
MenuOut(void)
{
	uint8_t Y;
	if(CurrMsg) {
		for(Y=0; Y<LCDYSz; PutMsgLine(Y++));
    bf48:	f4 e0       	ldi	r31, 0x04	; 4
    bf4a:	2f 16       	cp	r2, r31
    bf4c:	31 04       	cpc	r3, r1
    bf4e:	09 f0       	breq	.+2      	; 0xbf52 <MenuOut+0x1c2>
    bf50:	47 cf       	rjmp	.-370    	; 0xbde0 <MenuOut+0x50>
		EventFunc(&CurrMsg->Run);
    bf52:	c5 01       	movw	r24, r10
    bf54:	82 5a       	subi	r24, 0xA2	; 162
    bf56:	9f 4f       	sbci	r25, 0xFF	; 255
    bf58:	0e 94 28 3c 	call	0x7850	; 0x7850 <EventFunc>
	if(prb(&CurrPage->LineNumber)>LCDYSz || Fix<LCDYSz-1 || prp(&(GetLine+CurrLine)->OF_List))
		LCD_Buf[CurrLCD][0] = CharCursor;
	if(++Blink>16)
		Blink=0;
	EventFunc(&CurrPage->Run);
}
    bf5c:	2a 96       	adiw	r28, 0x0a	; 10
    bf5e:	0f b6       	in	r0, 0x3f	; 63
    bf60:	f8 94       	cli
    bf62:	de bf       	out	0x3e, r29	; 62
    bf64:	0f be       	out	0x3f, r0	; 63
    bf66:	cd bf       	out	0x3d, r28	; 61
    bf68:	cf 91       	pop	r28
    bf6a:	df 91       	pop	r29
    bf6c:	1f 91       	pop	r17
    bf6e:	0f 91       	pop	r16
    bf70:	ff 90       	pop	r15
    bf72:	ef 90       	pop	r14
    bf74:	df 90       	pop	r13
    bf76:	cf 90       	pop	r12
    bf78:	bf 90       	pop	r11
    bf7a:	af 90       	pop	r10
    bf7c:	9f 90       	pop	r9
    bf7e:	8f 90       	pop	r8
    bf80:	7f 90       	pop	r7
    bf82:	6f 90       	pop	r6
    bf84:	5f 90       	pop	r5
    bf86:	4f 90       	pop	r4
    bf88:	3f 90       	pop	r3
    bf8a:	2f 90       	pop	r2
    bf8c:	08 95       	ret

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    bf8e:	f9 01       	movw	r30, r18
    bf90:	31 96       	adiw	r30, 0x01	; 1
    bf92:	ea 0d       	add	r30, r10
    bf94:	fb 1d       	adc	r31, r11
    bf96:	e4 91       	lpm	r30, Z+
	uint8_t X;
	uint8_t X0=0;
	uint8_t X1=LCDXSz;
	int8_t Xs = 0;
	//--- ">>" Align right
	if(prc(CurrStr+0) == '>' && prc(CurrStr+1) == '>'){
    bf98:	ee 33       	cpi	r30, 0x3E	; 62
    bf9a:	09 f0       	breq	.+2      	; 0xbf9e <MenuOut+0x20e>
    bf9c:	45 cf       	rjmp	.-374    	; 0xbe28 <MenuOut+0x98>
		X0 = LCDXSz - strlen_P(CurrStr) + 2;
    bf9e:	c7 01       	movw	r24, r14
    bfa0:	0e 94 c1 7e 	call	0xfd82	; 0xfd82 <strlen_P>
    bfa4:	06 e1       	ldi	r16, 0x16	; 22
    bfa6:	08 1b       	sub	r16, r24
		Xs = X0-2;
    bfa8:	90 2f       	mov	r25, r16
    bfaa:	92 50       	subi	r25, 0x02	; 2
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';
    bfac:	00 23       	and	r16, r16
    bfae:	09 f4       	brne	.+2      	; 0xbfb2 <MenuOut+0x222>
    bfb0:	3d cf       	rjmp	.-390    	; 0xbe2c <MenuOut+0x9c>
    bfb2:	f6 01       	movw	r30, r12
    bfb4:	e8 19       	sub	r30, r8
    bfb6:	f9 09       	sbc	r31, r9
    bfb8:	ea 5a       	subi	r30, 0xAA	; 170
    bfba:	f9 4f       	sbci	r31, 0xF9	; 249
    bfbc:	80 e0       	ldi	r24, 0x00	; 0
    bfbe:	41 92       	st	Z+, r4
    bfc0:	8f 5f       	subi	r24, 0xFF	; 255
    bfc2:	80 17       	cp	r24, r16
    bfc4:	e0 f3       	brcs	.-8      	; 0xbfbe <MenuOut+0x22e>
    bfc6:	f7 01       	movw	r30, r14
    bfc8:	84 91       	lpm	r24, Z+
	}
	//--- "<<" Align left
	if(prc(CurrStr+0) == '<' && prc(CurrStr+1) == '<'){
    bfca:	8c 33       	cpi	r24, 0x3C	; 60
    bfcc:	09 f0       	breq	.+2      	; 0xbfd0 <MenuOut+0x240>
    bfce:	33 cf       	rjmp	.-410    	; 0xbe36 <MenuOut+0xa6>
    bfd0:	e9 85       	ldd	r30, Y+9	; 0x09
    bfd2:	fa 85       	ldd	r31, Y+10	; 0x0a
    bfd4:	e2 0d       	add	r30, r2
    bfd6:	f3 1d       	adc	r31, r3
    bfd8:	ee 0f       	add	r30, r30
    bfda:	ff 1f       	adc	r31, r31
    bfdc:	ee 0f       	add	r30, r30
    bfde:	ff 1f       	adc	r31, r31
    bfe0:	ee 0f       	add	r30, r30
    bfe2:	ff 1f       	adc	r31, r31
    bfe4:	e2 19       	sub	r30, r2
    bfe6:	f3 09       	sbc	r31, r3
    bfe8:	31 96       	adiw	r30, 0x01	; 1
    bfea:	ea 0d       	add	r30, r10
    bfec:	fb 1d       	adc	r31, r11
    bfee:	e4 91       	lpm	r30, Z+
    bff0:	ec 33       	cpi	r30, 0x3C	; 60
    bff2:	09 f0       	breq	.+2      	; 0xbff6 <MenuOut+0x266>
    bff4:	20 cf       	rjmp	.-448    	; 0xbe36 <MenuOut+0xa6>
		X1 = strlen_P(CurrStr) - 2;
    bff6:	c7 01       	movw	r24, r14
    bff8:	0e 94 c1 7e 	call	0xfd82	; 0xfd82 <strlen_P>
    bffc:	ae ef       	ldi	r26, 0xFE	; 254
    bffe:	5a 2e       	mov	r5, r26
    c000:	58 0e       	add	r5, r24
    c002:	9e ef       	ldi	r25, 0xFE	; 254
    c004:	00 e0       	ldi	r16, 0x00	; 0
    c006:	f7 01       	movw	r30, r14
    c008:	84 91       	lpm	r24, Z+
		X0 = 0;
		Xs = X0-2;
	}
	//--- "<>" Align center
	if(prc(CurrStr+0) == '<' && prc(CurrStr+1) == '>'){
    c00a:	8c 33       	cpi	r24, 0x3C	; 60
    c00c:	09 f0       	breq	.+2      	; 0xc010 <MenuOut+0x280>
    c00e:	1a cf       	rjmp	.-460    	; 0xbe44 <MenuOut+0xb4>
    c010:	89 84       	ldd	r8, Y+9	; 0x09
    c012:	9a 84       	ldd	r9, Y+10	; 0x0a
    c014:	82 0c       	add	r8, r2
    c016:	93 1c       	adc	r9, r3
    c018:	64 01       	movw	r12, r8
    c01a:	cc 0c       	add	r12, r12
    c01c:	dd 1c       	adc	r13, r13
    c01e:	cc 0c       	add	r12, r12
    c020:	dd 1c       	adc	r13, r13
    c022:	cc 0c       	add	r12, r12
    c024:	dd 1c       	adc	r13, r13
    c026:	f6 01       	movw	r30, r12
    c028:	e2 19       	sub	r30, r2
    c02a:	f3 09       	sbc	r31, r3
    c02c:	31 96       	adiw	r30, 0x01	; 1
    c02e:	ea 0d       	add	r30, r10
    c030:	fb 1d       	adc	r31, r11
    c032:	e4 91       	lpm	r30, Z+
    c034:	ee 33       	cpi	r30, 0x3E	; 62
    c036:	09 f0       	breq	.+2      	; 0xc03a <MenuOut+0x2aa>
    c038:	05 cf       	rjmp	.-502    	; 0xbe44 <MenuOut+0xb4>
		X0 = (LCDXSz - strlen_P(CurrStr) + 2) / 2;
    c03a:	c7 01       	movw	r24, r14
    c03c:	0e 94 c1 7e 	call	0xfd82	; 0xfd82 <strlen_P>
    c040:	26 e1       	ldi	r18, 0x16	; 22
    c042:	30 e0       	ldi	r19, 0x00	; 0
    c044:	28 1b       	sub	r18, r24
    c046:	39 0b       	sbc	r19, r25
    c048:	36 95       	lsr	r19
    c04a:	27 95       	ror	r18
    c04c:	02 2f       	mov	r16, r18
		Xs = X0-2;
    c04e:	92 2f       	mov	r25, r18
    c050:	92 50       	subi	r25, 0x02	; 2
		X1 = X0 + (strlen_P(CurrStr) - 2);
    c052:	6e ef       	ldi	r22, 0xFE	; 254
    c054:	56 2e       	mov	r5, r22
    c056:	58 0e       	add	r5, r24
    c058:	52 0e       	add	r5, r18
		for(X=0; X<X0; X++) LCD_Buf[Y][X]=' ';		
    c05a:	22 23       	and	r18, r18
    c05c:	09 f4       	brne	.+2      	; 0xc060 <MenuOut+0x2d0>
    c05e:	f2 ce       	rjmp	.-540    	; 0xbe44 <MenuOut+0xb4>
    c060:	f6 01       	movw	r30, r12
    c062:	e8 19       	sub	r30, r8
    c064:	f9 09       	sbc	r31, r9
    c066:	ea 5a       	subi	r30, 0xAA	; 170
    c068:	f9 4f       	sbci	r31, 0xF9	; 249
    c06a:	80 e0       	ldi	r24, 0x00	; 0
    c06c:	41 92       	st	Z+, r4
    c06e:	8f 5f       	subi	r24, 0xFF	; 255
    c070:	80 17       	cp	r24, r16
    c072:	e0 f3       	brcs	.-8      	; 0xc06c <MenuOut+0x2dc>
    c074:	e7 ce       	rjmp	.-562    	; 0xbe44 <MenuOut+0xb4>
			X += Param.Size;
		}
		LCD_Buf[Y][X] = Char;
	}
	X=X1;
	for(;X<LCDXSz; X++) LCD_Buf[Y][X] = ' ';
    c076:	89 85       	ldd	r24, Y+9	; 0x09
    c078:	9a 85       	ldd	r25, Y+10	; 0x0a
    c07a:	82 0d       	add	r24, r2
    c07c:	93 1d       	adc	r25, r3
    c07e:	9c 01       	movw	r18, r24
    c080:	22 0f       	add	r18, r18
    c082:	33 1f       	adc	r19, r19
    c084:	22 0f       	add	r18, r18
    c086:	33 1f       	adc	r19, r19
    c088:	22 0f       	add	r18, r18
    c08a:	33 1f       	adc	r19, r19
    c08c:	28 1b       	sub	r18, r24
    c08e:	39 0b       	sbc	r19, r25
    c090:	f9 01       	movw	r30, r18
    c092:	e5 0d       	add	r30, r5
    c094:	f1 1d       	adc	r31, r1
    c096:	ea 5a       	subi	r30, 0xAA	; 170
    c098:	f9 4f       	sbci	r31, 0xF9	; 249
    c09a:	40 82       	st	Z, r4
    c09c:	53 94       	inc	r5
    c09e:	83 e1       	ldi	r24, 0x13	; 19
    c0a0:	85 15       	cp	r24, r5
    c0a2:	08 f4       	brcc	.+2      	; 0xc0a6 <MenuOut+0x316>
    c0a4:	49 cf       	rjmp	.-366    	; 0xbf38 <MenuOut+0x1a8>
    c0a6:	f4 cf       	rjmp	.-24     	; 0xc090 <MenuOut+0x300>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    c0a8:	40 91 d4 02 	lds	r20, 0x02D4
    c0ac:	50 91 d5 02 	lds	r21, 0x02D5
    c0b0:	4d 5f       	subi	r20, 0xFD	; 253
    c0b2:	5f 4f       	sbci	r21, 0xFF	; 255
    c0b4:	fa 01       	movw	r30, r20
    c0b6:	e4 90       	lpm	r14, Z+
    c0b8:	43 50       	subi	r20, 0x03	; 3
    c0ba:	50 40       	sbci	r21, 0x00	; 0
		for(Y=0; Y<LCDYSz; PutMsgLine(Y++));
		EventFunc(&CurrMsg->Run);
		return;
	}
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
    c0bc:	c0 90 83 07 	lds	r12, 0x0783
    c0c0:	d0 90 a0 08 	lds	r13, 0x08A0
	for(Y=0; Y<Fix; Y++)
    c0c4:	ee 20       	and	r14, r14
    c0c6:	09 f4       	brne	.+2      	; 0xc0ca <MenuOut+0x33a>
    c0c8:	a6 c0       	rjmp	.+332    	; 0xc216 <MenuOut+0x486>
    c0ca:	00 e0       	ldi	r16, 0x00	; 0
    c0cc:	10 e0       	ldi	r17, 0x00	; 0
// ~~~~~~~~~~~~~~~~~~
inline static void
PutBlankLine(uint8_t Y)
{
	uint8_t X=0;
	while(X<LCDXSz)	LCD_Buf[Y][X++] = ' ';
    c0ce:	80 e2       	ldi	r24, 0x20	; 32
    c0d0:	f8 2e       	mov	r15, r24
    c0d2:	4e 5f       	subi	r20, 0xFE	; 254
    c0d4:	5f 4f       	sbci	r21, 0xFF	; 255
    c0d6:	fa 01       	movw	r30, r20
    c0d8:	84 91       	lpm	r24, Z+
    c0da:	42 50       	subi	r20, 0x02	; 2
    c0dc:	50 40       	sbci	r21, 0x00	; 0
		return;
	}
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
    c0de:	08 17       	cp	r16, r24
    c0e0:	08 f4       	brcc	.+2      	; 0xc0e4 <MenuOut+0x354>
    c0e2:	69 c0       	rjmp	.+210    	; 0xc1b6 <MenuOut+0x426>
    c0e4:	c8 01       	movw	r24, r16
    c0e6:	88 0f       	add	r24, r24
    c0e8:	99 1f       	adc	r25, r25
    c0ea:	80 0f       	add	r24, r16
    c0ec:	91 1f       	adc	r25, r17
    c0ee:	fc 01       	movw	r30, r24
    c0f0:	ee 0f       	add	r30, r30
    c0f2:	ff 1f       	adc	r31, r31
    c0f4:	ee 0f       	add	r30, r30
    c0f6:	ff 1f       	adc	r31, r31
    c0f8:	ee 0f       	add	r30, r30
    c0fa:	ff 1f       	adc	r31, r31
    c0fc:	e8 1b       	sub	r30, r24
    c0fe:	f9 0b       	sbc	r31, r25
    c100:	ea 5a       	subi	r30, 0xAA	; 170
    c102:	f9 4f       	sbci	r31, 0xF9	; 249
    c104:	80 e0       	ldi	r24, 0x00	; 0
// ~~~~~~~~~~~~~~~~~~
inline static void
PutBlankLine(uint8_t Y)
{
	uint8_t X=0;
	while(X<LCDXSz)	LCD_Buf[Y][X++] = ' ';
    c106:	f1 92       	st	Z+, r15
    c108:	8f 5f       	subi	r24, 0xFF	; 255
    c10a:	84 31       	cpi	r24, 0x14	; 20
    c10c:	e1 f7       	brne	.-8      	; 0xc106 <MenuOut+0x376>
	}
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Y, Y);
    c10e:	0f 5f       	subi	r16, 0xFF	; 255
    c110:	1f 4f       	sbci	r17, 0xFF	; 255
		EventFunc(&CurrMsg->Run);
		return;
	}
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
    c112:	0e 15       	cp	r16, r14
    c114:	f0 f2       	brcs	.-68     	; 0xc0d2 <MenuOut+0x342>
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Y, Y);
	for(; Y<LCDYSz; Y++)
    c116:	f3 e0       	ldi	r31, 0x03	; 3
    c118:	fe 15       	cp	r31, r14
    c11a:	f0 f0       	brcs	.+60     	; 0xc158 <MenuOut+0x3c8>
    c11c:	1e 2d       	mov	r17, r14
		EventFunc(&CurrMsg->Run);
		return;
	}
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
    c11e:	fc 2c       	mov	r15, r12
    c120:	fd 18       	sub	r15, r13
    c122:	f1 0e       	add	r15, r17
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Y, Y);
	for(; Y<LCDYSz; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
    c124:	95 e1       	ldi	r25, 0x15	; 21
    c126:	d9 2e       	mov	r13, r25
// ~~~~~~~~~~~~~~~~~~
inline static void
PutBlankLine(uint8_t Y)
{
	uint8_t X=0;
	while(X<LCDXSz)	LCD_Buf[Y][X++] = ' ';
    c128:	00 e2       	ldi	r16, 0x20	; 32
    c12a:	4e 5f       	subi	r20, 0xFE	; 254
    c12c:	5f 4f       	sbci	r21, 0xFF	; 255
    c12e:	fa 01       	movw	r30, r20
    c130:	84 91       	lpm	r24, Z+
    c132:	42 50       	subi	r20, 0x02	; 2
    c134:	50 40       	sbci	r21, 0x00	; 0
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Y, Y);
	for(; Y<LCDYSz; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
    c136:	18 17       	cp	r17, r24
    c138:	08 f4       	brcc	.+2      	; 0xc13c <MenuOut+0x3ac>
    c13a:	4b c0       	rjmp	.+150    	; 0xc1d2 <MenuOut+0x442>
    c13c:	1d 9d       	mul	r17, r13
    c13e:	f0 01       	movw	r30, r0
    c140:	11 24       	eor	r1, r1
    c142:	ea 5a       	subi	r30, 0xAA	; 170
    c144:	f9 4f       	sbci	r31, 0xF9	; 249
    c146:	80 e0       	ldi	r24, 0x00	; 0
// ~~~~~~~~~~~~~~~~~~
inline static void
PutBlankLine(uint8_t Y)
{
	uint8_t X=0;
	while(X<LCDXSz)	LCD_Buf[Y][X++] = ' ';
    c148:	01 93       	st	Z+, r16
    c14a:	8f 5f       	subi	r24, 0xFF	; 255
    c14c:	84 31       	cpi	r24, 0x14	; 20
    c14e:	e1 f7       	brne	.-8      	; 0xc148 <MenuOut+0x3b8>
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Y, Y);
	for(; Y<LCDYSz; Y++)
    c150:	1f 5f       	subi	r17, 0xFF	; 255
    c152:	f3 94       	inc	r15
    c154:	14 30       	cpi	r17, 0x04	; 4
    c156:	48 f3       	brcs	.-46     	; 0xc12a <MenuOut+0x39a>
    c158:	4e 5f       	subi	r20, 0xFE	; 254
    c15a:	5f 4f       	sbci	r21, 0xFF	; 255
    c15c:	fa 01       	movw	r30, r20
    c15e:	84 91       	lpm	r24, Z+
    c160:	42 50       	subi	r20, 0x02	; 2
    c162:	50 40       	sbci	r21, 0x00	; 0
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Dist+Y, Y);
	if(prb(&CurrPage->LineNumber)>LCDYSz || Fix<LCDYSz-1 || prp(&(GetLine+CurrLine)->OF_List))
    c164:	85 30       	cpi	r24, 0x05	; 5
    c166:	20 f4       	brcc	.+8      	; 0xc170 <MenuOut+0x3e0>
    c168:	f2 e0       	ldi	r31, 0x02	; 2
    c16a:	fe 15       	cp	r31, r14
    c16c:	08 f4       	brcc	.+2      	; 0xc170 <MenuOut+0x3e0>
    c16e:	3f c0       	rjmp	.+126    	; 0xc1ee <MenuOut+0x45e>
		LCD_Buf[CurrLCD][0] = CharCursor;
    c170:	80 91 a0 08 	lds	r24, 0x08A0
    c174:	90 e0       	ldi	r25, 0x00	; 0
    c176:	9c 01       	movw	r18, r24
    c178:	22 0f       	add	r18, r18
    c17a:	33 1f       	adc	r19, r19
    c17c:	28 0f       	add	r18, r24
    c17e:	39 1f       	adc	r19, r25
    c180:	f9 01       	movw	r30, r18
    c182:	ee 0f       	add	r30, r30
    c184:	ff 1f       	adc	r31, r31
    c186:	ee 0f       	add	r30, r30
    c188:	ff 1f       	adc	r31, r31
    c18a:	ee 0f       	add	r30, r30
    c18c:	ff 1f       	adc	r31, r31
    c18e:	e2 1b       	sub	r30, r18
    c190:	f3 0b       	sbc	r31, r19
    c192:	ea 5a       	subi	r30, 0xAA	; 170
    c194:	f9 4f       	sbci	r31, 0xF9	; 249
    c196:	80 e1       	ldi	r24, 0x10	; 16
    c198:	80 83       	st	Z, r24
	if(++Blink>16)
    c19a:	80 91 d0 08 	lds	r24, 0x08D0
    c19e:	8f 5f       	subi	r24, 0xFF	; 255
    c1a0:	80 93 d0 08 	sts	0x08D0, r24
    c1a4:	81 31       	cpi	r24, 0x11	; 17
    c1a6:	10 f0       	brcs	.+4      	; 0xc1ac <MenuOut+0x41c>
		Blink=0;
    c1a8:	10 92 d0 08 	sts	0x08D0, r1
	EventFunc(&CurrPage->Run);
    c1ac:	ca 01       	movw	r24, r20
    c1ae:	08 96       	adiw	r24, 0x08	; 8
    c1b0:	0e 94 28 3c 	call	0x7850	; 0x7850 <EventFunc>
    c1b4:	d3 ce       	rjmp	.-602    	; 0xbf5c <MenuOut+0x1cc>
	}
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Y, Y);
    c1b6:	80 2f       	mov	r24, r16
    c1b8:	60 2f       	mov	r22, r16
    c1ba:	0e 94 6c 5c 	call	0xb8d8	; 0xb8d8 <PutLine>
    c1be:	40 91 d4 02 	lds	r20, 0x02D4
    c1c2:	50 91 d5 02 	lds	r21, 0x02D5
    c1c6:	0f 5f       	subi	r16, 0xFF	; 255
    c1c8:	1f 4f       	sbci	r17, 0xFF	; 255
		EventFunc(&CurrMsg->Run);
		return;
	}
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
    c1ca:	0e 15       	cp	r16, r14
    c1cc:	08 f4       	brcc	.+2      	; 0xc1d0 <MenuOut+0x440>
    c1ce:	81 cf       	rjmp	.-254    	; 0xc0d2 <MenuOut+0x342>
    c1d0:	a2 cf       	rjmp	.-188    	; 0xc116 <MenuOut+0x386>
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Y, Y);
	for(; Y<LCDYSz; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Dist+Y, Y);
    c1d2:	8f 2d       	mov	r24, r15
    c1d4:	61 2f       	mov	r22, r17
    c1d6:	0e 94 6c 5c 	call	0xb8d8	; 0xb8d8 <PutLine>
    c1da:	40 91 d4 02 	lds	r20, 0x02D4
    c1de:	50 91 d5 02 	lds	r21, 0x02D5
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Y, Y);
	for(; Y<LCDYSz; Y++)
    c1e2:	1f 5f       	subi	r17, 0xFF	; 255
    c1e4:	f3 94       	inc	r15
    c1e6:	14 30       	cpi	r17, 0x04	; 4
    c1e8:	08 f4       	brcc	.+2      	; 0xc1ec <MenuOut+0x45c>
    c1ea:	9f cf       	rjmp	.-194    	; 0xc12a <MenuOut+0x39a>
    c1ec:	b5 cf       	rjmp	.-150    	; 0xc158 <MenuOut+0x3c8>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    c1ee:	fa 01       	movw	r30, r20
    c1f0:	65 91       	lpm	r22, Z+
    c1f2:	74 91       	lpm	r23, Z+
		if(Y >= prb(&CurrPage->LineNumber))	PutBlankLine(Y);
		else PutLine(Dist+Y, Y);
	if(prb(&CurrPage->LineNumber)>LCDYSz || Fix<LCDYSz-1 || prp(&(GetLine+CurrLine)->OF_List))
    c1f4:	80 91 83 07 	lds	r24, 0x0783
    c1f8:	2b e1       	ldi	r18, 0x1B	; 27
    c1fa:	82 9f       	mul	r24, r18
    c1fc:	c0 01       	movw	r24, r0
    c1fe:	11 24       	eor	r1, r1
    c200:	68 0f       	add	r22, r24
    c202:	79 1f       	adc	r23, r25
    c204:	69 5e       	subi	r22, 0xE9	; 233
    c206:	7f 4f       	sbci	r23, 0xFF	; 255
    c208:	fb 01       	movw	r30, r22
    c20a:	85 91       	lpm	r24, Z+
    c20c:	94 91       	lpm	r25, Z+
    c20e:	89 2b       	or	r24, r25
    c210:	09 f0       	breq	.+2      	; 0xc214 <MenuOut+0x484>
    c212:	ae cf       	rjmp	.-164    	; 0xc170 <MenuOut+0x3e0>
    c214:	c2 cf       	rjmp	.-124    	; 0xc19a <MenuOut+0x40a>
		EventFunc(&CurrMsg->Run);
		return;
	}
	uint8_t Fix=GetFix();
	uint8_t Dist=CurrLine-CurrLCD;
	for(Y=0; Y<Fix; Y++)
    c216:	10 e0       	ldi	r17, 0x00	; 0
    c218:	82 cf       	rjmp	.-252    	; 0xc11e <MenuOut+0x38e>

0000c21a <LCD_Sweep>:

// ~~~~~~~~~~~~
static void
LCD_Sweep(void)
{
	if(LCD_Rdy()) {
    c21a:	0e 94 37 26 	call	0x4c6e	; 0x4c6e <LCD_Rdy>
    c21e:	88 23       	and	r24, r24
    c220:	09 f4       	brne	.+2      	; 0xc224 <LCD_Sweep+0xa>
    c222:	08 95       	ret
		MenuOut();
    c224:	0e 94 c8 5e 	call	0xbd90	; 0xbd90 <MenuOut>
		LCD_Out();
    c228:	0e 94 4d 26 	call	0x4c9a	; 0x4c9a <LCD_Out>
    c22c:	08 95       	ret

0000c22e <strcpy_EE>:
	}//while
	return GSM_RxCharN;
}
// ~~~~~~~~~~~
//    EEPROM   RAM     '\0'    EEPROM
uint8_t strcpy_EE(char* str_RAM, uint8_t* str_EE){
    c22e:	cf 92       	push	r12
    c230:	df 92       	push	r13
    c232:	ef 92       	push	r14
    c234:	ff 92       	push	r15
    c236:	1f 93       	push	r17
    c238:	cf 93       	push	r28
    c23a:	df 93       	push	r29
    c23c:	6c 01       	movw	r12, r24
    c23e:	7b 01       	movw	r14, r22
    c240:	10 e0       	ldi	r17, 0x00	; 0
    c242:	06 c0       	rjmp	.+12     	; 0xc250 <strcpy_EE+0x22>
	uint8_t i=0;
	while( (erb(&str_EE[i])!='\0') && (erb(&str_EE[i])!=' ') ){
    c244:	80 32       	cpi	r24, 0x20	; 32
    c246:	69 f0       	breq	.+26     	; 0xc262 <strcpy_EE+0x34>
		str_RAM[i] = (char)erb(&str_EE[i]);
    c248:	cc 0d       	add	r28, r12
    c24a:	dd 1d       	adc	r29, r13
    c24c:	88 83       	st	Y, r24
		i++;
    c24e:	1f 5f       	subi	r17, 0xFF	; 255
}
// ~~~~~~~~~~~
//    EEPROM   RAM     '\0'    EEPROM
uint8_t strcpy_EE(char* str_RAM, uint8_t* str_EE){
	uint8_t i=0;
	while( (erb(&str_EE[i])!='\0') && (erb(&str_EE[i])!=' ') ){
    c250:	c1 2f       	mov	r28, r17
    c252:	d0 e0       	ldi	r29, 0x00	; 0
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    c254:	c7 01       	movw	r24, r14
    c256:	8c 0f       	add	r24, r28
    c258:	9d 1f       	adc	r25, r29
    c25a:	0e 94 db 81 	call	0x103b6	; 0x103b6 <__eerd_byte_m2560>
    c25e:	88 23       	and	r24, r24
    c260:	89 f7       	brne	.-30     	; 0xc244 <strcpy_EE+0x16>
		str_RAM[i] = (char)erb(&str_EE[i]);
		i++;
	}
	return i;	
}
    c262:	81 2f       	mov	r24, r17
    c264:	df 91       	pop	r29
    c266:	cf 91       	pop	r28
    c268:	1f 91       	pop	r17
    c26a:	ff 90       	pop	r15
    c26c:	ef 90       	pop	r14
    c26e:	df 90       	pop	r13
    c270:	cf 90       	pop	r12
    c272:	08 95       	ret

0000c274 <GSM_Cycle>:
	}//switch
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
void
GSM_Cycle(void)
{
    c274:	7f 92       	push	r7
    c276:	8f 92       	push	r8
    c278:	9f 92       	push	r9
    c27a:	af 92       	push	r10
    c27c:	bf 92       	push	r11
    c27e:	cf 92       	push	r12
    c280:	df 92       	push	r13
    c282:	ef 92       	push	r14
    c284:	ff 92       	push	r15
    c286:	0f 93       	push	r16
    c288:	1f 93       	push	r17
    c28a:	df 93       	push	r29
    c28c:	cf 93       	push	r28
    c28e:	cd b7       	in	r28, 0x3d	; 61
    c290:	de b7       	in	r29, 0x3e	; 62
    c292:	65 97       	sbiw	r28, 0x15	; 21
    c294:	0f b6       	in	r0, 0x3f	; 63
    c296:	f8 94       	cli
    c298:	de bf       	out	0x3e, r29	; 62
    c29a:	0f be       	out	0x3f, r0	; 63
    c29c:	cd bf       	out	0x3d, r28	; 61
	switch(GSM_Control){
    c29e:	80 91 8a 07 	lds	r24, 0x078A
    c2a2:	88 23       	and	r24, r24
    c2a4:	d9 f4       	brne	.+54     	; 0xc2dc <GSM_Cycle+0x68>
uint8_t RequestRepeatCounter = 0;

// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Auto(){

	switch(GSM_State){
    c2a6:	80 91 b3 06 	lds	r24, 0x06B3
    c2aa:	e8 2f       	mov	r30, r24
    c2ac:	f0 e0       	ldi	r31, 0x00	; 0
    c2ae:	ea 35       	cpi	r30, 0x5A	; 90
    c2b0:	f1 05       	cpc	r31, r1
    c2b2:	68 f1       	brcs	.+90     	; 0xc30e <GSM_Cycle+0x9a>
			break;	
		case GSM_CNTL_CONFIG:
			GSM_Config();
			break;								
	}
}
    c2b4:	65 96       	adiw	r28, 0x15	; 21
    c2b6:	0f b6       	in	r0, 0x3f	; 63
    c2b8:	f8 94       	cli
    c2ba:	de bf       	out	0x3e, r29	; 62
    c2bc:	0f be       	out	0x3f, r0	; 63
    c2be:	cd bf       	out	0x3d, r28	; 61
    c2c0:	cf 91       	pop	r28
    c2c2:	df 91       	pop	r29
    c2c4:	1f 91       	pop	r17
    c2c6:	0f 91       	pop	r16
    c2c8:	ff 90       	pop	r15
    c2ca:	ef 90       	pop	r14
    c2cc:	df 90       	pop	r13
    c2ce:	cf 90       	pop	r12
    c2d0:	bf 90       	pop	r11
    c2d2:	af 90       	pop	r10
    c2d4:	9f 90       	pop	r9
    c2d6:	8f 90       	pop	r8
    c2d8:	7f 90       	pop	r7
    c2da:	08 95       	ret
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
void
GSM_Cycle(void)
{
	switch(GSM_Control){
    c2dc:	82 30       	cpi	r24, 0x02	; 2
    c2de:	51 f7       	brne	.-44     	; 0xc2b4 <GSM_Cycle+0x40>
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Manual(){}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Config(){
	switch(GSM_State){
    c2e0:	80 91 b3 06 	lds	r24, 0x06B3
    c2e4:	84 30       	cpi	r24, 0x04	; 4
    c2e6:	11 f4       	brne	.+4      	; 0xc2ec <GSM_Cycle+0x78>
    c2e8:	0c 94 c7 6a 	jmp	0xd58e	; 0xd58e <GSM_Cycle+0x131a>
    c2ec:	85 30       	cpi	r24, 0x05	; 5
    c2ee:	b8 f0       	brcs	.+46     	; 0xc31e <GSM_Cycle+0xaa>
    c2f0:	86 30       	cpi	r24, 0x06	; 6
    c2f2:	11 f4       	brne	.+4      	; 0xc2f8 <GSM_Cycle+0x84>
    c2f4:	0c 94 7f 6a 	jmp	0xd4fe	; 0xd4fe <GSM_Cycle+0x128a>
    c2f8:	86 30       	cpi	r24, 0x06	; 6
    c2fa:	48 f1       	brcs	.+82     	; 0xc34e <GSM_Cycle+0xda>
    c2fc:	87 30       	cpi	r24, 0x07	; 7
    c2fe:	11 f4       	brne	.+4      	; 0xc304 <GSM_Cycle+0x90>
    c300:	0c 94 b8 6a 	jmp	0xd570	; 0xd570 <GSM_Cycle+0x12fc>
    c304:	88 30       	cpi	r24, 0x08	; 8
    c306:	b1 f2       	breq	.-84     	; 0xc2b4 <GSM_Cycle+0x40>
			if(Timer16Stopp(TD_GSM)) GSM_State++;
			break;
		case GSM_FINISH:			
			break;
		default:
			GSM_State = GSM_CFG_START;
    c308:	10 92 b3 06 	sts	0x06B3, r1
    c30c:	d3 cf       	rjmp	.-90     	; 0xc2b4 <GSM_Cycle+0x40>
uint8_t RequestRepeatCounter = 0;

// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Auto(){

	switch(GSM_State){
    c30e:	e4 50       	subi	r30, 0x04	; 4
    c310:	ff 4f       	sbci	r31, 0xFF	; 255
    c312:	ee 0f       	add	r30, r30
    c314:	ff 1f       	adc	r31, r31
    c316:	05 90       	lpm	r0, Z+
    c318:	f4 91       	lpm	r31, Z+
    c31a:	e0 2d       	mov	r30, r0
    c31c:	19 94       	eijmp
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Manual(){}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Config(){
	switch(GSM_State){
    c31e:	81 30       	cpi	r24, 0x01	; 1
    c320:	11 f4       	brne	.+4      	; 0xc326 <GSM_Cycle+0xb2>
    c322:	0c 94 a5 6a 	jmp	0xd54a	; 0xd54a <GSM_Cycle+0x12d6>
    c326:	81 30       	cpi	r24, 0x01	; 1
    c328:	f0 f0       	brcs	.+60     	; 0xc366 <GSM_Cycle+0xf2>
    c32a:	82 30       	cpi	r24, 0x02	; 2
    c32c:	11 f4       	brne	.+4      	; 0xc332 <GSM_Cycle+0xbe>
    c32e:	0c 94 95 6a 	jmp	0xd52a	; 0xd52a <GSM_Cycle+0x12b6>
    c332:	83 30       	cpi	r24, 0x03	; 3
    c334:	49 f7       	brne	.-46     	; 0xc308 <GSM_Cycle+0x94>
			break;
		case GSM_CFG_WAIT_AT_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_CFG_SEND_AT)) GSM_State++;
			break;
		case GSM_CFG_SEND_IPR:
			GSM_Execute_Command(AT_IPR9600, 100); GSM_State++;
    c336:	80 e7       	ldi	r24, 0x70	; 112
    c338:	94 e0       	ldi	r25, 0x04	; 4
    c33a:	64 e6       	ldi	r22, 0x64	; 100
    c33c:	70 e0       	ldi	r23, 0x00	; 0
    c33e:	0e 94 b4 4a 	call	0x9568	; 0x9568 <GSM_Execute_Command>
    c342:	80 91 b3 06 	lds	r24, 0x06B3
    c346:	8f 5f       	subi	r24, 0xFF	; 255
    c348:	80 93 b3 06 	sts	0x06B3, r24
    c34c:	b3 cf       	rjmp	.-154    	; 0xc2b4 <GSM_Cycle+0x40>
				StartTimer16(TD_GSM,200);
				GSM_State++;
			}
			break;
		case GSM_CFG_SEND_ATW:
			GSM_Execute_Command(AT_W, 100); GSM_State++;
    c34e:	8c e7       	ldi	r24, 0x7C	; 124
    c350:	94 e0       	ldi	r25, 0x04	; 4
    c352:	64 e6       	ldi	r22, 0x64	; 100
    c354:	70 e0       	ldi	r23, 0x00	; 0
    c356:	0e 94 b4 4a 	call	0x9568	; 0x9568 <GSM_Execute_Command>
    c35a:	80 91 b3 06 	lds	r24, 0x06B3
    c35e:	8f 5f       	subi	r24, 0xFF	; 255
    c360:	80 93 b3 06 	sts	0x06B3, r24
    c364:	a7 cf       	rjmp	.-178    	; 0xc2b4 <GSM_Cycle+0x40>
inline static void GSM_Manual(){}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Config(){
	switch(GSM_State){
		case GSM_CFG_START:
			StartTimer16(TD_GSM,200);
    c366:	80 91 e7 04 	lds	r24, 0x04E7
    c36a:	68 ec       	ldi	r22, 0xC8	; 200
    c36c:	70 e0       	ldi	r23, 0x00	; 0
    c36e:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
		cli();
		PORTL|=(1<<PL5);
		sei();
	}
	void GSM_PWRCNTRL_ON(void){
		cli();
    c372:	f8 94       	cli
		PORTL &= ~(1<<PL5);
    c374:	80 91 0b 01 	lds	r24, 0x010B
    c378:	8f 7d       	andi	r24, 0xDF	; 223
    c37a:	80 93 0b 01 	sts	0x010B, r24
		sei();
    c37e:	78 94       	sei
			GSM_PWRCNTRL_ON();
			GSM_State++;
    c380:	80 91 b3 06 	lds	r24, 0x06B3
    c384:	8f 5f       	subi	r24, 0xFF	; 255
    c386:	80 93 b3 06 	sts	0x06B3, r24
    c38a:	94 cf       	rjmp	.-216    	; 0xc2b4 <GSM_Cycle+0x40>
			break;
		case GSM_SEND_CGMM:
			GSM_Execute_Command(AT_CGMM,5000*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CGMM_READ:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
    c38c:	80 91 e7 04 	lds	r24, 0x04E7
    c390:	0e 94 06 1c 	call	0x380c	; 0x380c <Timer16Stopp>
    c394:	88 23       	and	r24, r24
    c396:	19 f0       	breq	.+6      	; 0xc39e <GSM_Cycle+0x12a>
    c398:	8a e4       	ldi	r24, 0x4A	; 74
    c39a:	80 93 b3 06 	sts	0x06B3, r24
			if(GetStringFromFIFO()){
    c39e:	0e 94 80 38 	call	0x7100	; 0x7100 <GetStringFromFIFO>
    c3a2:	88 23       	and	r24, r24
    c3a4:	31 f1       	breq	.+76     	; 0xc3f2 <GSM_Cycle+0x17e>
				if(!strcmp_P(GSM_RxStr, GSM_SIMCOM_SIM900R)) GSM_Modem = SIMCOM_SIM900R;
    c3a6:	89 e9       	ldi	r24, 0x99	; 153
    c3a8:	97 e0       	ldi	r25, 0x07	; 7
    c3aa:	6b e5       	ldi	r22, 0x5B	; 91
    c3ac:	73 e0       	ldi	r23, 0x03	; 3
    c3ae:	0e 94 b1 7e 	call	0xfd62	; 0xfd62 <strcmp_P>
    c3b2:	89 2b       	or	r24, r25
    c3b4:	19 f4       	brne	.+6      	; 0xc3bc <GSM_Cycle+0x148>
    c3b6:	81 e0       	ldi	r24, 0x01	; 1
    c3b8:	80 93 f1 06 	sts	0x06F1, r24
				if(!strcmp_P(GSM_RxStr, GSM_SIMCOM_SIM800)) GSM_Modem = SIMCOM_SIM800;
    c3bc:	89 e9       	ldi	r24, 0x99	; 153
    c3be:	97 e0       	ldi	r25, 0x07	; 7
    c3c0:	6a e6       	ldi	r22, 0x6A	; 106
    c3c2:	73 e0       	ldi	r23, 0x03	; 3
    c3c4:	0e 94 b1 7e 	call	0xfd62	; 0xfd62 <strcmp_P>
    c3c8:	89 2b       	or	r24, r25
    c3ca:	19 f4       	brne	.+6      	; 0xc3d2 <GSM_Cycle+0x15e>
    c3cc:	82 e0       	ldi	r24, 0x02	; 2
    c3ce:	80 93 f1 06 	sts	0x06F1, r24
				if(!strcmp_P(GSM_RxStr, GSM_SIMCOM_SIM800C)) GSM_Modem = SIMCOM_SIM800;
    c3d2:	89 e9       	ldi	r24, 0x99	; 153
    c3d4:	97 e0       	ldi	r25, 0x07	; 7
    c3d6:	68 e7       	ldi	r22, 0x78	; 120
    c3d8:	73 e0       	ldi	r23, 0x03	; 3
    c3da:	0e 94 b1 7e 	call	0xfd62	; 0xfd62 <strcmp_P>
    c3de:	89 2b       	or	r24, r25
    c3e0:	11 f0       	breq	.+4      	; 0xc3e6 <GSM_Cycle+0x172>
    c3e2:	0c 94 d5 6d 	jmp	0xdbaa	; 0xdbaa <GSM_Cycle+0x1936>
    c3e6:	82 e0       	ldi	r24, 0x02	; 2
    c3e8:	80 93 f1 06 	sts	0x06F1, r24
				//Add here new model GSM-modem
				if(GSM_Modem != NOT_RECOGNIZED) GSM_State = GSM_WAIT_CALL_READY;
    c3ec:	86 e0       	ldi	r24, 0x06	; 6
    c3ee:	80 93 b3 06 	sts	0x06B3, r24
			}
		case GSM_WAIT_CFUN:
			if(GSM_Wait_Response_P(URC_CFUN, GSM_ReStart1)) GSM_State++;
    c3f2:	8b e8       	ldi	r24, 0x8B	; 139
    c3f4:	93 e0       	ldi	r25, 0x03	; 3
    c3f6:	6a e4       	ldi	r22, 0x4A	; 74
    c3f8:	0e 94 59 4a 	call	0x94b2	; 0x94b2 <GSM_Wait_Response_P>
    c3fc:	88 23       	and	r24, r24
    c3fe:	09 f4       	brne	.+2      	; 0xc402 <GSM_Cycle+0x18e>
    c400:	59 cf       	rjmp	.-334    	; 0xc2b4 <GSM_Cycle+0x40>
    c402:	80 91 b3 06 	lds	r24, 0x06B3
    c406:	8f 5f       	subi	r24, 0xFF	; 255
    c408:	80 93 b3 06 	sts	0x06B3, r24
    c40c:	53 cf       	rjmp	.-346    	; 0xc2b4 <GSM_Cycle+0x40>
		case GSM_WAIT_R2D_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;

		case GSM_WAIT_R2D_CONNECT:
			if(GSM_Wait_Response_P(RESP_CONNECT, GSM_ReStart1)){ 				
    c40e:	84 ef       	ldi	r24, 0xF4	; 244
    c410:	93 e0       	ldi	r25, 0x03	; 3
    c412:	6a e4       	ldi	r22, 0x4A	; 74
    c414:	0e 94 59 4a 	call	0x94b2	; 0x94b2 <GSM_Wait_Response_P>
    c418:	88 23       	and	r24, r24
    c41a:	09 f4       	brne	.+2      	; 0xc41e <GSM_Cycle+0x1aa>
    c41c:	4b cf       	rjmp	.-362    	; 0xc2b4 <GSM_Cycle+0x40>
				GSM_State=GSM_ProtocolMode;
    c41e:	82 e5       	ldi	r24, 0x52	; 82
    c420:	80 93 b3 06 	sts	0x06B3, r24
				StartTimer16(TD_timer_after_page_transfer,100);
    c424:	80 91 ef 04 	lds	r24, 0x04EF
    c428:	64 e6       	ldi	r22, 0x64	; 100
    c42a:	70 e0       	ldi	r23, 0x00	; 0
    c42c:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    c430:	8f ef       	ldi	r24, 0xFF	; 255
    c432:	80 93 fa 06 	sts	0x06FA, r24
	GSM_RX_FIFO_End = 255;
    c436:	80 93 51 06 	sts	0x0651, r24
	GSM_RxCharN = 0;
    c43a:	10 92 18 0b 	sts	0x0B18, r1
	GSM_RX_FIFOOverFlow = 0;
    c43e:	10 92 cb 08 	sts	0x08CB, r1
	GSM_RX_FIFOMax = 0;
    c442:	10 92 d1 08 	sts	0x08D1, r1
    c446:	36 cf       	rjmp	.-404    	; 0xc2b4 <GSM_Cycle+0x40>
			GSM_State=GSM_WAIT_R2D_CONNECT;
		
			break;

		case GSM_WAIT_R2D_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    c448:	81 ef       	ldi	r24, 0xF1	; 241
    c44a:	93 e0       	ldi	r25, 0x03	; 3
    c44c:	6a e4       	ldi	r22, 0x4A	; 74
    c44e:	0e 94 59 4a 	call	0x94b2	; 0x94b2 <GSM_Wait_Response_P>
    c452:	88 23       	and	r24, r24
    c454:	09 f4       	brne	.+2      	; 0xc458 <GSM_Cycle+0x1e4>
    c456:	2e cf       	rjmp	.-420    	; 0xc2b4 <GSM_Cycle+0x40>
    c458:	80 91 b3 06 	lds	r24, 0x06B3
    c45c:	8f 5f       	subi	r24, 0xFF	; 255
    c45e:	80 93 b3 06 	sts	0x06B3, r24
    c462:	28 cf       	rjmp	.-432    	; 0xc2b4 <GSM_Cycle+0x40>
			break;

		//----  data mode
		case GSM_Return2dataMode:

			CommandModeDestination=0;
    c464:	10 92 6b 07 	sts	0x076B, r1
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    c468:	8f ef       	ldi	r24, 0xFF	; 255
    c46a:	80 93 fa 06 	sts	0x06FA, r24
	GSM_RX_FIFO_End = 255;
    c46e:	80 93 51 06 	sts	0x0651, r24
	GSM_RxCharN = 0;
    c472:	10 92 18 0b 	sts	0x0B18, r1
	GSM_RX_FIFOOverFlow = 0;
    c476:	10 92 cb 08 	sts	0x08CB, r1
	GSM_RX_FIFOMax = 0;
    c47a:	10 92 d1 08 	sts	0x08D1, r1
    c47e:	e9 e9       	ldi	r30, 0x99	; 153
    c480:	f7 e0       	ldi	r31, 0x07	; 7

			CommandModeDestination=0;
			InitFIFO();
			for(int i=0;i<GSM_RXSTR_SIZE;i++)
			{
				GSM_RxStr[i]=0;	
    c482:	11 92       	st	Z+, r1
		//----  data mode
		case GSM_Return2dataMode:

			CommandModeDestination=0;
			InitFIFO();
			for(int i=0;i<GSM_RXSTR_SIZE;i++)
    c484:	b7 e0       	ldi	r27, 0x07	; 7
    c486:	ed 3f       	cpi	r30, 0xFD	; 253
    c488:	fb 07       	cpc	r31, r27
    c48a:	d9 f7       	brne	.-10     	; 0xc482 <GSM_Cycle+0x20e>
			{
				GSM_RxStr[i]=0;	
			}
			GSM_Execute_Command(ATO, 600*GSM_DEBUG_DELAY); //GSM_State++;
    c48c:	81 e0       	ldi	r24, 0x01	; 1
    c48e:	96 e0       	ldi	r25, 0x06	; 6
    c490:	68 e5       	ldi	r22, 0x58	; 88
    c492:	72 e0       	ldi	r23, 0x02	; 2
    c494:	0e 94 b4 4a 	call	0x9568	; 0x9568 <GSM_Execute_Command>
			GSM_State=GSM_WAIT_R2D_CONNECT;
    c498:	89 e5       	ldi	r24, 0x59	; 89
    c49a:	80 93 b3 06 	sts	0x06B3, r24
    c49e:	0a cf       	rjmp	.-492    	; 0xc2b4 <GSM_Cycle+0x40>
				StartTimer16(TD_GSM,1000);	// min 500ms after +++
				GSM_State++;
			}
			break;
		case GSM_WAIT_D2C_SWITCH_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) {
    c4a0:	81 ef       	ldi	r24, 0xF1	; 241
    c4a2:	93 e0       	ldi	r25, 0x03	; 3
    c4a4:	6a e4       	ldi	r22, 0x4A	; 74
    c4a6:	0e 94 59 4a 	call	0x94b2	; 0x94b2 <GSM_Wait_Response_P>
    c4aa:	88 23       	and	r24, r24
    c4ac:	09 f4       	brne	.+2      	; 0xc4b0 <GSM_Cycle+0x23c>
    c4ae:	02 cf       	rjmp	.-508    	; 0xc2b4 <GSM_Cycle+0x40>

				switch(CommandModeDestination){
    c4b0:	80 91 6b 07 	lds	r24, 0x076B
    c4b4:	82 30       	cpi	r24, 0x02	; 2
    c4b6:	11 f4       	brne	.+4      	; 0xc4bc <GSM_Cycle+0x248>
    c4b8:	0c 94 fe 6d 	jmp	0xdbfc	; 0xdbfc <GSM_Cycle+0x1988>
    c4bc:	83 30       	cpi	r24, 0x03	; 3
    c4be:	10 f0       	brcs	.+4      	; 0xc4c4 <GSM_Cycle+0x250>
    c4c0:	0c 94 c7 6d 	jmp	0xdb8e	; 0xdb8e <GSM_Cycle+0x191a>
    c4c4:	81 30       	cpi	r24, 0x01	; 1
    c4c6:	11 f4       	brne	.+4      	; 0xc4cc <GSM_Cycle+0x258>
    c4c8:	0c 94 f9 6d 	jmp	0xdbf2	; 0xdbf2 <GSM_Cycle+0x197e>
						break;
					case 5:	
						GSM_State = GSM_SEND_CSQ;
						counter=0;	
						break;
					default:GSM_State = GSM_Return2dataMode;
    c4cc:	87 e5       	ldi	r24, 0x57	; 87
    c4ce:	80 93 b3 06 	sts	0x06B3, r24
    c4d2:	f0 ce       	rjmp	.-544    	; 0xc2b4 <GSM_Cycle+0x40>
//IF WEB			WebClose();
			GSM_State++;

			break;
		case GSM_Swtch2CommandModePlus:
			if(Timer16Stopp(TD_GSM)){
    c4d4:	80 91 e7 04 	lds	r24, 0x04E7
    c4d8:	0e 94 06 1c 	call	0x380c	; 0x380c <Timer16Stopp>
    c4dc:	88 23       	and	r24, r24
    c4de:	09 f4       	brne	.+2      	; 0xc4e2 <GSM_Cycle+0x26e>
    c4e0:	e9 ce       	rjmp	.-558    	; 0xc2b4 <GSM_Cycle+0x40>
    c4e2:	e9 e9       	ldi	r30, 0x99	; 153
    c4e4:	f7 e0       	ldi	r31, 0x07	; 7
				for(int i=0;i<GSM_RXSTR_SIZE;i++)
				{
					GSM_RxStr[i]=0;	
    c4e6:	11 92       	st	Z+, r1
			GSM_State++;

			break;
		case GSM_Swtch2CommandModePlus:
			if(Timer16Stopp(TD_GSM)){
				for(int i=0;i<GSM_RXSTR_SIZE;i++)
    c4e8:	27 e0       	ldi	r18, 0x07	; 7
    c4ea:	ed 3f       	cpi	r30, 0xFD	; 253
    c4ec:	f2 07       	cpc	r31, r18
    c4ee:	d9 f7       	brne	.-10     	; 0xc4e6 <GSM_Cycle+0x272>
				{
					GSM_RxStr[i]=0;	
				}
				sprintf_P(GSM_TxStr, ESC_SEQ);
    c4f0:	00 d0       	rcall	.+0      	; 0xc4f2 <GSM_Cycle+0x27e>
    c4f2:	0f 92       	push	r0
    c4f4:	02 e0       	ldi	r16, 0x02	; 2
    c4f6:	1a e0       	ldi	r17, 0x0A	; 10
    c4f8:	ad b7       	in	r26, 0x3d	; 61
    c4fa:	be b7       	in	r27, 0x3e	; 62
    c4fc:	12 96       	adiw	r26, 0x02	; 2
    c4fe:	1c 93       	st	X, r17
    c500:	0e 93       	st	-X, r16
    c502:	11 97       	sbiw	r26, 0x01	; 1
    c504:	8a e5       	ldi	r24, 0x5A	; 90
    c506:	94 e0       	ldi	r25, 0x04	; 4
    c508:	14 96       	adiw	r26, 0x04	; 4
    c50a:	9c 93       	st	X, r25
    c50c:	8e 93       	st	-X, r24
    c50e:	13 97       	sbiw	r26, 0x03	; 3
    c510:	0e 94 de 7f 	call	0xffbc	; 0xffbc <sprintf_P>
				GSMTxSz = strlen(GSM_TxStr);
    c514:	f8 01       	movw	r30, r16
    c516:	01 90       	ld	r0, Z+
    c518:	00 20       	and	r0, r0
    c51a:	e9 f7       	brne	.-6      	; 0xc516 <GSM_Cycle+0x2a2>
    c51c:	8f 01       	movw	r16, r30
    c51e:	01 50       	subi	r16, 0x01	; 1
    c520:	10 40       	sbci	r17, 0x00	; 0
    c522:	02 50       	subi	r16, 0x02	; 2
    c524:	1a 40       	sbci	r17, 0x0A	; 10
    c526:	00 93 75 07 	sts	0x0775, r16
				GSM_SendFirstChar();
    c52a:	0f 90       	pop	r0
    c52c:	0f 90       	pop	r0
    c52e:	0f 90       	pop	r0
    c530:	0f 90       	pop	r0
    c532:	0e 94 aa 39 	call	0x7354	; 0x7354 <GSM_SendFirstChar>
				StartTimer16(TD_GSM,1000);	// min 500ms after +++
    c536:	80 91 e7 04 	lds	r24, 0x04E7
    c53a:	68 ee       	ldi	r22, 0xE8	; 232
    c53c:	73 e0       	ldi	r23, 0x03	; 3
    c53e:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
				GSM_State++;
    c542:	80 91 b3 06 	lds	r24, 0x06B3
    c546:	8f 5f       	subi	r24, 0xFF	; 255
    c548:	80 93 b3 06 	sts	0x06B3, r24
    c54c:	b3 ce       	rjmp	.-666    	; 0xc2b4 <GSM_Cycle+0x40>
				GSM_State =GSM_ReStart1;
				break;
			}			
			break;
		case GSM_Swtch2CommandMode:
			StartTimer16(TD_GSM,100);	// min 1000ms before +++
    c54e:	80 91 e7 04 	lds	r24, 0x04E7
    c552:	64 e6       	ldi	r22, 0x64	; 100
    c554:	70 e0       	ldi	r23, 0x00	; 0
    c556:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
//IF WEB			WebClose();
			GSM_State++;
    c55a:	80 91 b3 06 	lds	r24, 0x06B3
    c55e:	8f 5f       	subi	r24, 0xFF	; 255
    c560:	80 93 b3 06 	sts	0x06B3, r24
    c564:	a7 ce       	rjmp	.-690    	; 0xc2b4 <GSM_Cycle+0x40>
			}
			break;

		case GSM_DataMode:
			// -----    
			if(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){	// if FIFO not empty
    c566:	90 91 fa 06 	lds	r25, 0x06FA
    c56a:	80 91 51 06 	lds	r24, 0x0651
    c56e:	98 17       	cp	r25, r24
    c570:	11 f4       	brne	.+4      	; 0xc576 <GSM_Cycle+0x302>
    c572:	0c 94 6e 6d 	jmp	0xdadc	; 0xdadc <GSM_Cycle+0x1868>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    c576:	83 ec       	ldi	r24, 0xC3	; 195
    c578:	90 e0       	ldi	r25, 0x00	; 0
    c57a:	0e 94 e9 81 	call	0x103d2	; 0x103d2 <__eerd_word_m2560>
    c57e:	bc 01       	movw	r22, r24
				StartTimer16(TD_TCP_Connect, erw(&TCP_CONNECT_timeout));	//   
    c580:	80 91 e8 04 	lds	r24, 0x04E8
    c584:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
    c588:	95 ce       	rjmp	.-726    	; 0xc2b4 <GSM_Cycle+0x40>
		//------------------------

		//-----------

		case GSM_ProtocolMode:
			if( (strstr_P(GSM_RxStr, URC_CLOSED+2) != NULL) ){
    c58a:	89 e9       	ldi	r24, 0x99	; 153
    c58c:	97 e0       	ldi	r25, 0x07	; 7
    c58e:	64 ed       	ldi	r22, 0xD4	; 212
    c590:	73 e0       	ldi	r23, 0x03	; 3
    c592:	0e 94 e3 7e 	call	0xfdc6	; 0xfdc6 <strstr_P>
    c596:	89 2b       	or	r24, r25
    c598:	b1 f0       	breq	.+44     	; 0xc5c6 <GSM_Cycle+0x352>
					GSM_State =GSM_ReStart1;
    c59a:	8a e4       	ldi	r24, 0x4A	; 74
    c59c:	80 93 b3 06 	sts	0x06B3, r24
    c5a0:	89 ce       	rjmp	.-750    	; 0xc2b4 <GSM_Cycle+0x40>

			while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){	
					GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);
					if(GSM_RxCharN==2)
						{
							if(!strncmp_P(GSM_RxStr, PSTR("\r\n"), 2)) {GSM_RxCharN=0;}
    c5a2:	89 e9       	ldi	r24, 0x99	; 153
    c5a4:	97 e0       	ldi	r25, 0x07	; 7
    c5a6:	67 ee       	ldi	r22, 0xE7	; 231
    c5a8:	7b e2       	ldi	r23, 0x2B	; 43
    c5aa:	42 e0       	ldi	r20, 0x02	; 2
    c5ac:	50 e0       	ldi	r21, 0x00	; 0
    c5ae:	0e 94 ca 7e 	call	0xfd94	; 0xfd94 <strncmp_P>
    c5b2:	89 2b       	or	r24, r25
    c5b4:	11 f4       	brne	.+4      	; 0xc5ba <GSM_Cycle+0x346>
    c5b6:	10 92 18 0b 	sts	0x0B18, r1
						}
					if(GSM_RxCharN >= 4){
    c5ba:	80 91 18 0b 	lds	r24, 0x0B18
    c5be:	84 30       	cpi	r24, 0x04	; 4
    c5c0:	10 f0       	brcs	.+4      	; 0xc5c6 <GSM_Cycle+0x352>
    c5c2:	0c 94 51 6c 	jmp	0xd8a2	; 0xd8a2 <GSM_Cycle+0x162e>
					break;
			}



			while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){	
    c5c6:	90 91 fa 06 	lds	r25, 0x06FA
    c5ca:	80 91 51 06 	lds	r24, 0x0651
    c5ce:	98 17       	cp	r25, r24
    c5d0:	11 f4       	brne	.+4      	; 0xc5d6 <GSM_Cycle+0x362>
    c5d2:	0c 94 93 6c 	jmp	0xd926	; 0xd926 <GSM_Cycle+0x16b2>
					GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);
    c5d6:	89 e9       	ldi	r24, 0x99	; 153
    c5d8:	97 e0       	ldi	r25, 0x07	; 7
    c5da:	68 e1       	ldi	r22, 0x18	; 24
    c5dc:	7b e0       	ldi	r23, 0x0B	; 11
    c5de:	44 e6       	ldi	r20, 0x64	; 100
    c5e0:	0e 94 16 38 	call	0x702c	; 0x702c <GetByteFromFIFO>
					if(GSM_RxCharN==2)
    c5e4:	80 91 18 0b 	lds	r24, 0x0B18
    c5e8:	82 30       	cpi	r24, 0x02	; 2
    c5ea:	39 f7       	brne	.-50     	; 0xc5ba <GSM_Cycle+0x346>
    c5ec:	da cf       	rjmp	.-76     	; 0xc5a2 <GSM_Cycle+0x32e>
						}
					}
				}
			break;
		case GSM_WAIT_CSQ_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) {
    c5ee:	81 ef       	ldi	r24, 0xF1	; 241
    c5f0:	93 e0       	ldi	r25, 0x03	; 3
    c5f2:	6a e4       	ldi	r22, 0x4A	; 74
    c5f4:	0e 94 59 4a 	call	0x94b2	; 0x94b2 <GSM_Wait_Response_P>
    c5f8:	88 23       	and	r24, r24
    c5fa:	09 f4       	brne	.+2      	; 0xc5fe <GSM_Cycle+0x38a>
    c5fc:	5b ce       	rjmp	.-842    	; 0xc2b4 <GSM_Cycle+0x40>
				if(CommandModeDestination==5){
    c5fe:	80 91 6b 07 	lds	r24, 0x076B
    c602:	85 30       	cpi	r24, 0x05	; 5
    c604:	11 f4       	brne	.+4      	; 0xc60a <GSM_Cycle+0x396>
    c606:	0c 94 f4 6d 	jmp	0xdbe8	; 0xdbe8 <GSM_Cycle+0x1974>
					GSM_State  = GSM_Return2dataMode;
				}
				else{
					GSM_State=GSM_SEND_CIPMUX;
    c60a:	8a e2       	ldi	r24, 0x2A	; 42
    c60c:	80 93 b3 06 	sts	0x06B3, r24
    c610:	51 ce       	rjmp	.-862    	; 0xc2b4 <GSM_Cycle+0x40>
				GSM_Execute_Command(AT_CSQ, 500*GSM_DEBUG_DELAY); 
				InitFIFO();
				GSM_State++;
			break;
		case GSM_WAIT_CSQ:
				if(Timer16Stopp(TD_GSM)){
    c612:	80 91 e7 04 	lds	r24, 0x04E7
    c616:	0e 94 06 1c 	call	0x380c	; 0x380c <Timer16Stopp>
    c61a:	88 23       	and	r24, r24
    c61c:	11 f4       	brne	.+4      	; 0xc622 <GSM_Cycle+0x3ae>
    c61e:	0c 94 7d 6d 	jmp	0xdafa	; 0xdafa <GSM_Cycle+0x1886>
						GSM_State = GSM_ReStart1;
    c622:	8a e4       	ldi	r24, 0x4A	; 74
    c624:	80 93 b3 06 	sts	0x06B3, r24
    c628:	45 ce       	rjmp	.-886    	; 0xc2b4 <GSM_Cycle+0x40>
			break;
		case GSM_ShutWait_:
			if(GSM_Wait_Response_P(RESP_SHUT_OK, GSM_ReStart1)) GSM_State++;
			break;
		case GSM_SEND_CGATT0:
			GSM_Execute_Command(AT_CGATT_0, 1000*GSM_DEBUG_DELAY); GSM_State++;
    c62a:	8f ee       	ldi	r24, 0xEF	; 239
    c62c:	95 e0       	ldi	r25, 0x05	; 5
    c62e:	68 ee       	ldi	r22, 0xE8	; 232
    c630:	73 e0       	ldi	r23, 0x03	; 3
    c632:	0e 94 b4 4a 	call	0x9568	; 0x9568 <GSM_Execute_Command>
    c636:	80 91 b3 06 	lds	r24, 0x06B3
    c63a:	8f 5f       	subi	r24, 0xFF	; 255
    c63c:	80 93 b3 06 	sts	0x06B3, r24
    c640:	39 ce       	rjmp	.-910    	; 0xc2b4 <GSM_Cycle+0x40>
			break;
		//------------------------    


		case GSM_SEND_ATD_Check_Ballance:	
			if(GSM_Flag & (1<<flg_TxCStr)){
    c642:	80 91 d2 02 	lds	r24, 0x02D2
    c646:	80 ff       	sbrs	r24, 0
    c648:	4b c0       	rjmp	.+150    	; 0xc6e0 <GSM_Cycle+0x46c>
				sprintf_P(GSM_TxStr, AT_CUSD101);	
    c64a:	00 d0       	rcall	.+0      	; 0xc64c <GSM_Cycle+0x3d8>
    c64c:	0f 92       	push	r0
    c64e:	82 e0       	ldi	r24, 0x02	; 2
    c650:	9a e0       	ldi	r25, 0x0A	; 10
    c652:	ad b7       	in	r26, 0x3d	; 61
    c654:	be b7       	in	r27, 0x3e	; 62
    c656:	12 96       	adiw	r26, 0x02	; 2
    c658:	9c 93       	st	X, r25
    c65a:	8e 93       	st	-X, r24
    c65c:	11 97       	sbiw	r26, 0x01	; 1
    c65e:	07 ec       	ldi	r16, 0xC7	; 199
    c660:	14 e0       	ldi	r17, 0x04	; 4
    c662:	14 96       	adiw	r26, 0x04	; 4
    c664:	1c 93       	st	X, r17
    c666:	0e 93       	st	-X, r16
    c668:	13 97       	sbiw	r26, 0x03	; 3
    c66a:	0e 94 de 7f 	call	0xffbc	; 0xffbc <sprintf_P>
				GSMTxSz = strlen_P(AT_CUSD101);
    c66e:	0f 90       	pop	r0
    c670:	0f 90       	pop	r0
    c672:	0f 90       	pop	r0
    c674:	0f 90       	pop	r0
    c676:	c8 01       	movw	r24, r16
    c678:	0e 94 c1 7e 	call	0xfd82	; 0xfd82 <strlen_P>
    c67c:	80 93 75 07 	sts	0x0775, r24
				GSMTxSz += strcpy_EE(GSM_TxStr+GSMTxSz,GPRS_checkballancerequest);
    c680:	80 91 75 07 	lds	r24, 0x0775
    c684:	90 e0       	ldi	r25, 0x00	; 0
    c686:	8e 5f       	subi	r24, 0xFE	; 254
    c688:	95 4f       	sbci	r25, 0xF5	; 245
    c68a:	61 e3       	ldi	r22, 0x31	; 49
    c68c:	70 e0       	ldi	r23, 0x00	; 0
    c68e:	0e 94 17 61 	call	0xc22e	; 0xc22e <strcpy_EE>
    c692:	90 91 75 07 	lds	r25, 0x0775
    c696:	98 0f       	add	r25, r24
    c698:	90 93 75 07 	sts	0x0775, r25
				GSM_TxStr[GSMTxSz]='"';
    c69c:	e0 91 75 07 	lds	r30, 0x0775
    c6a0:	f0 e0       	ldi	r31, 0x00	; 0
    c6a2:	ee 5f       	subi	r30, 0xFE	; 254
    c6a4:	f5 4f       	sbci	r31, 0xF5	; 245
    c6a6:	82 e2       	ldi	r24, 0x22	; 34
    c6a8:	80 83       	st	Z, r24
				GSM_TxStr[GSMTxSz+1]='\r';
    c6aa:	e0 91 75 07 	lds	r30, 0x0775
    c6ae:	f0 e0       	ldi	r31, 0x00	; 0
    c6b0:	ee 5f       	subi	r30, 0xFE	; 254
    c6b2:	f5 4f       	sbci	r31, 0xF5	; 245
    c6b4:	8d e0       	ldi	r24, 0x0D	; 13
    c6b6:	81 83       	std	Z+1, r24	; 0x01
				GSM_TxStr[GSMTxSz+2]='\n';
    c6b8:	e0 91 75 07 	lds	r30, 0x0775
    c6bc:	f0 e0       	ldi	r31, 0x00	; 0
    c6be:	ee 5f       	subi	r30, 0xFE	; 254
    c6c0:	f5 4f       	sbci	r31, 0xF5	; 245
    c6c2:	8a e0       	ldi	r24, 0x0A	; 10
    c6c4:	82 83       	std	Z+2, r24	; 0x02
				GSMTxSz+=3;
    c6c6:	80 91 75 07 	lds	r24, 0x0775
    c6ca:	8d 5f       	subi	r24, 0xFD	; 253
    c6cc:	80 93 75 07 	sts	0x0775, r24
				GSM_SendFirstChar();
    c6d0:	0e 94 aa 39 	call	0x7354	; 0x7354 <GSM_SendFirstChar>
				StartTimer16(TD_GSM, 1000);
    c6d4:	80 91 e7 04 	lds	r24, 0x04E7
    c6d8:	68 ee       	ldi	r22, 0xE8	; 232
    c6da:	73 e0       	ldi	r23, 0x03	; 3
    c6dc:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
			}
			GSM_State++;	
    c6e0:	80 91 b3 06 	lds	r24, 0x06B3
    c6e4:	8f 5f       	subi	r24, 0xFF	; 255
    c6e6:	80 93 b3 06 	sts	0x06B3, r24
			GSM_Temp = 0;
    c6ea:	10 92 d9 05 	sts	0x05D9, r1
    c6ee:	e2 cd       	rjmp	.-1084   	; 0xc2b4 <GSM_Cycle+0x40>
			SetIP(&GSM_ClientIP,0,0,0,0);
			GSM_Flag |=(1<<flg_TxCStr);
			GSM_State++;
			break;
		case GSM_ReStart2:
			if(Timer16Stopp(TD_GSM)){
    c6f0:	80 91 e7 04 	lds	r24, 0x04E7
    c6f4:	0e 94 06 1c 	call	0x380c	; 0x380c <Timer16Stopp>
    c6f8:	88 23       	and	r24, r24
    c6fa:	09 f4       	brne	.+2      	; 0xc6fe <GSM_Cycle+0x48a>
    c6fc:	db cd       	rjmp	.-1098   	; 0xc2b4 <GSM_Cycle+0x40>
				GSM_State = GSM_PowerOn;
    c6fe:	10 92 b3 06 	sts	0x06B3, r1
    c702:	d8 cd       	rjmp	.-1104   	; 0xc2b4 <GSM_Cycle+0x40>
		//------------------------

		
		//------------------------
		case GSM_ReStart1:
			GSM_ReStartN++;
    c704:	80 91 ed 08 	lds	r24, 0x08ED
    c708:	8f 5f       	subi	r24, 0xFF	; 255
    c70a:	80 93 ed 08 	sts	0x08ED, r24
		cli();
		DDRL|=(1<<PL5);
		sei();
	}
	void GSM_PWRCNTRL_OFF(void){
		cli();
    c70e:	f8 94       	cli
		PORTL|=(1<<PL5);
    c710:	80 91 0b 01 	lds	r24, 0x010B
    c714:	80 62       	ori	r24, 0x20	; 32
    c716:	80 93 0b 01 	sts	0x010B, r24
		sei();
    c71a:	78 94       	sei
			GSM_PWRCNTRL_OFF();
			StartTimer16(TD_GSM,1000);
    c71c:	80 91 e7 04 	lds	r24, 0x04E7
    c720:	68 ee       	ldi	r22, 0xE8	; 232
    c722:	73 e0       	ldi	r23, 0x03	; 3
    c724:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
			RxBufOverFlow = 0;
    c728:	10 92 01 0b 	sts	0x0B01, r1
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    c72c:	8f ef       	ldi	r24, 0xFF	; 255
    c72e:	80 93 fa 06 	sts	0x06FA, r24
	GSM_RX_FIFO_End = 255;
    c732:	80 93 51 06 	sts	0x0651, r24
	GSM_RxCharN = 0;
    c736:	10 92 18 0b 	sts	0x0B18, r1
	GSM_RX_FIFOOverFlow = 0;
    c73a:	10 92 cb 08 	sts	0x08CB, r1
	GSM_RX_FIFOMax = 0;
    c73e:	10 92 d1 08 	sts	0x08D1, r1
    c742:	e9 e9       	ldi	r30, 0x99	; 153
    c744:	f7 e0       	ldi	r31, 0x07	; 7
			RxBufOverFlow = 0;
		//	WebSession=0;
			InitFIFO();
			for(int i=0;i<GSM_RXSTR_SIZE;i++)
			{
				GSM_RxStr[i]=0;	
    c746:	11 92       	st	Z+, r1
			GSM_PWRCNTRL_OFF();
			StartTimer16(TD_GSM,1000);
			RxBufOverFlow = 0;
		//	WebSession=0;
			InitFIFO();
			for(int i=0;i<GSM_RXSTR_SIZE;i++)
    c748:	27 e0       	ldi	r18, 0x07	; 7
    c74a:	ed 3f       	cpi	r30, 0xFD	; 253
    c74c:	f2 07       	cpc	r31, r18
    c74e:	d9 f7       	brne	.-10     	; 0xc746 <GSM_Cycle+0x4d2>
			{
				GSM_RxStr[i]=0;	
			}
			SMS_FlgSz_Out = 0;	// ..          -  
    c750:	10 92 82 07 	sts	0x0782, r1
			GSM_ActiveConnection = NO_CONNECTION;
    c754:	8f ef       	ldi	r24, 0xFF	; 255
    c756:	80 93 d3 02 	sts	0x02D3, r24
	uint8_t IP4;
} IP_Addr;

//~~~~~~~~~~~~~~
void SetIP(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	IP->IP1 = IP1;
    c75a:	10 92 02 0b 	sts	0x0B02, r1
	IP->IP2 = IP2;
    c75e:	10 92 03 0b 	sts	0x0B03, r1
	IP->IP3 = IP3;
    c762:	10 92 04 0b 	sts	0x0B04, r1
	IP->IP4 = IP4;
    c766:	10 92 05 0b 	sts	0x0B05, r1
			SetIP(&GSM_ClientIP,0,0,0,0);
			GSM_Flag |=(1<<flg_TxCStr);
    c76a:	80 91 d2 02 	lds	r24, 0x02D2
    c76e:	81 60       	ori	r24, 0x01	; 1
    c770:	80 93 d2 02 	sts	0x02D2, r24
			GSM_State++;
    c774:	80 91 b3 06 	lds	r24, 0x06B3
    c778:	8f 5f       	subi	r24, 0xFF	; 255
    c77a:	80 93 b3 06 	sts	0x06B3, r24
    c77e:	9a cd       	rjmp	.-1228   	; 0xc2b4 <GSM_Cycle+0x40>
			break;
		case GSM_SEND_CGATT0:
			GSM_Execute_Command(AT_CGATT_0, 1000*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CGATT0_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    c780:	81 ef       	ldi	r24, 0xF1	; 241
    c782:	93 e0       	ldi	r25, 0x03	; 3
    c784:	6a e4       	ldi	r22, 0x4A	; 74
    c786:	0e 94 59 4a 	call	0x94b2	; 0x94b2 <GSM_Wait_Response_P>
    c78a:	88 23       	and	r24, r24
    c78c:	09 f4       	brne	.+2      	; 0xc790 <GSM_Cycle+0x51c>
    c78e:	92 cd       	rjmp	.-1244   	; 0xc2b4 <GSM_Cycle+0x40>
				StartTimer16(TD_GSM, 1000);
    c790:	80 91 e7 04 	lds	r24, 0x04E7
    c794:	68 ee       	ldi	r22, 0xE8	; 232
    c796:	73 e0       	ldi	r23, 0x03	; 3
    c798:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
			 	GSM_State = GSM_SEND_ATD_Check_Ballance;
    c79c:	8c e4       	ldi	r24, 0x4C	; 76
    c79e:	80 93 b3 06 	sts	0x06B3, r24
    c7a2:	88 cd       	rjmp	.-1264   	; 0xc2b4 <GSM_Cycle+0x40>
			break;
		case GSM_WAIT_ATD_Check_Ballance_OK:
			if(GSM_Wait_Response_P(RESP_OK,GSM_SEND_CSQ)) GSM_State++;
			break;
		case GSM_WAIT_Ballance:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_SEND_CSQ;
    c7a4:	80 91 e7 04 	lds	r24, 0x04E7
    c7a8:	0e 94 06 1c 	call	0x380c	; 0x380c <Timer16Stopp>
    c7ac:	88 23       	and	r24, r24
    c7ae:	19 f0       	breq	.+6      	; 0xc7b6 <GSM_Cycle+0x542>
    c7b0:	8f e4       	ldi	r24, 0x4F	; 79
    c7b2:	80 93 b3 06 	sts	0x06B3, r24
			GSM_RxStr[GSM_RXSTR_SIZE-1]='\0';
    c7b6:	10 92 fc 07 	sts	0x07FC, r1
		
				GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);

				if(GSM_RxCharN >= 90){

					GSM_State = GSM_SEND_CSQ;
    c7ba:	1f e4       	ldi	r17, 0x4F	; 79
			if(GSM_Wait_Response_P(RESP_OK,GSM_SEND_CSQ)) GSM_State++;
			break;
		case GSM_WAIT_Ballance:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_SEND_CSQ;
			GSM_RxStr[GSM_RXSTR_SIZE-1]='\0';
			while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    c7bc:	90 91 fa 06 	lds	r25, 0x06FA
    c7c0:	80 91 51 06 	lds	r24, 0x0651
    c7c4:	98 17       	cp	r25, r24
    c7c6:	09 f4       	brne	.+2      	; 0xc7ca <GSM_Cycle+0x556>
    c7c8:	f8 c6       	rjmp	.+3568   	; 0xd5ba <GSM_Cycle+0x1346>
				
		
				GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);
    c7ca:	89 e9       	ldi	r24, 0x99	; 153
    c7cc:	97 e0       	ldi	r25, 0x07	; 7
    c7ce:	68 e1       	ldi	r22, 0x18	; 24
    c7d0:	7b e0       	ldi	r23, 0x0B	; 11
    c7d2:	44 e6       	ldi	r20, 0x64	; 100
    c7d4:	0e 94 16 38 	call	0x702c	; 0x702c <GetByteFromFIFO>

				if(GSM_RxCharN >= 90){
    c7d8:	80 91 18 0b 	lds	r24, 0x0B18
    c7dc:	8a 35       	cpi	r24, 0x5A	; 90
    c7de:	70 f3       	brcs	.-36     	; 0xc7bc <GSM_Cycle+0x548>

					GSM_State = GSM_SEND_CSQ;
    c7e0:	10 93 b3 06 	sts	0x06B3, r17
    c7e4:	eb cf       	rjmp	.-42     	; 0xc7bc <GSM_Cycle+0x548>
			}
			GSM_State++;	
			GSM_Temp = 0;
			break;
		case GSM_WAIT_ATD_Check_Ballance_OK:
			if(GSM_Wait_Response_P(RESP_OK,GSM_SEND_CSQ)) GSM_State++;
    c7e6:	81 ef       	ldi	r24, 0xF1	; 241
    c7e8:	93 e0       	ldi	r25, 0x03	; 3
    c7ea:	6f e4       	ldi	r22, 0x4F	; 79
    c7ec:	0e 94 59 4a 	call	0x94b2	; 0x94b2 <GSM_Wait_Response_P>
    c7f0:	88 23       	and	r24, r24
    c7f2:	09 f4       	brne	.+2      	; 0xc7f6 <GSM_Cycle+0x582>
    c7f4:	5f cd       	rjmp	.-1346   	; 0xc2b4 <GSM_Cycle+0x40>
    c7f6:	80 91 b3 06 	lds	r24, 0x06B3
    c7fa:	8f 5f       	subi	r24, 0xFF	; 255
    c7fc:	80 93 b3 06 	sts	0x06B3, r24
    c800:	59 cd       	rjmp	.-1358   	; 0xc2b4 <GSM_Cycle+0x40>
			}	
			break;

		//------------------------   GSM-
		case GSM_SEND_CSQ:
				GSM_Execute_Command(AT_CSQ, 500*GSM_DEBUG_DELAY); 
    c802:	8a ef       	ldi	r24, 0xFA	; 250
    c804:	95 e0       	ldi	r25, 0x05	; 5
    c806:	64 ef       	ldi	r22, 0xF4	; 244
    c808:	71 e0       	ldi	r23, 0x01	; 1
    c80a:	0e 94 b4 4a 	call	0x9568	; 0x9568 <GSM_Execute_Command>
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    c80e:	8f ef       	ldi	r24, 0xFF	; 255
    c810:	80 93 fa 06 	sts	0x06FA, r24
	GSM_RX_FIFO_End = 255;
    c814:	80 93 51 06 	sts	0x0651, r24
	GSM_RxCharN = 0;
    c818:	10 92 18 0b 	sts	0x0B18, r1
	GSM_RX_FIFOOverFlow = 0;
    c81c:	10 92 cb 08 	sts	0x08CB, r1
	GSM_RX_FIFOMax = 0;
    c820:	10 92 d1 08 	sts	0x08D1, r1

		//------------------------   GSM-
		case GSM_SEND_CSQ:
				GSM_Execute_Command(AT_CSQ, 500*GSM_DEBUG_DELAY); 
				InitFIFO();
				GSM_State++;
    c824:	80 91 b3 06 	lds	r24, 0x06B3
    c828:	8f 5f       	subi	r24, 0xFF	; 255
    c82a:	80 93 b3 06 	sts	0x06B3, r24
    c82e:	42 cd       	rjmp	.-1404   	; 0xc2b4 <GSM_Cycle+0x40>
			break;
		case GSM_WAIT_SMS_Inv:
			if(GSM_Wait_Char('>', GSM_ReStart1)) GSM_State++;
			break;
		case GSM_SEND_SMS_DATA:
			SMS_Data_Out[SMS_FlgSz_Out] = 0x1A;	// SMS Data end - char Ctrl-Z
    c830:	60 91 82 07 	lds	r22, 0x0782
    c834:	e6 2f       	mov	r30, r22
    c836:	f0 e0       	ldi	r31, 0x00	; 0
    c838:	ea 5f       	subi	r30, 0xFA	; 250
    c83a:	f8 4f       	sbci	r31, 0xF8	; 248
    c83c:	8a e1       	ldi	r24, 0x1A	; 26
    c83e:	80 83       	st	Z, r24
			GSM_SendData((uint8_t *)SMS_Data_Out, SMS_FlgSz_Out+1);
    c840:	6f 5f       	subi	r22, 0xFF	; 255
    c842:	86 e0       	ldi	r24, 0x06	; 6
    c844:	97 e0       	ldi	r25, 0x07	; 7
    c846:	0e 94 37 40 	call	0x806e	; 0x806e <GSM_SendData>
			GSM_State++;
    c84a:	80 91 b3 06 	lds	r24, 0x06B3
    c84e:	8f 5f       	subi	r24, 0xFF	; 255
    c850:	80 93 b3 06 	sts	0x06B3, r24
    c854:	2f cd       	rjmp	.-1442   	; 0xc2b4 <GSM_Cycle+0x40>
					}					
				}
			}
			break;
		case GSM_WAIT_SMS_Inv:
			if(GSM_Wait_Char('>', GSM_ReStart1)) GSM_State++;
    c856:	8e e3       	ldi	r24, 0x3E	; 62
    c858:	6a e4       	ldi	r22, 0x4A	; 74
    c85a:	0e 94 88 39 	call	0x7310	; 0x7310 <GSM_Wait_Char>
    c85e:	88 23       	and	r24, r24
    c860:	09 f4       	brne	.+2      	; 0xc864 <GSM_Cycle+0x5f0>
    c862:	28 cd       	rjmp	.-1456   	; 0xc2b4 <GSM_Cycle+0x40>
    c864:	80 91 b3 06 	lds	r24, 0x06B3
    c868:	8f 5f       	subi	r24, 0xFF	; 255
    c86a:	80 93 b3 06 	sts	0x06B3, r24
    c86e:	22 cd       	rjmp	.-1468   	; 0xc2b4 <GSM_Cycle+0x40>
			}
			break;

		//------------------------
		case GSM_SEND_CMGS:
			if(GSM_Flag & (1<<flg_TxCStr)){			
    c870:	80 91 d2 02 	lds	r24, 0x02D2
    c874:	80 ff       	sbrs	r24, 0
    c876:	1e cd       	rjmp	.-1476   	; 0xc2b4 <GSM_Cycle+0x40>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    c878:	42 e0       	ldi	r20, 0x02	; 2
    c87a:	e4 2e       	mov	r14, r20
    c87c:	4a e0       	ldi	r20, 0x0A	; 10
    c87e:	f4 2e       	mov	r15, r20
    c880:	60 91 da 05 	lds	r22, 0x05DA
    c884:	8d e0       	ldi	r24, 0x0D	; 13
    c886:	68 9f       	mul	r22, r24
    c888:	b0 01       	movw	r22, r0
    c88a:	11 24       	eor	r1, r1
    c88c:	6b 53       	subi	r22, 0x3B	; 59
    c88e:	7f 4f       	sbci	r23, 0xFF	; 255
    c890:	c7 01       	movw	r24, r14
    c892:	4d e0       	ldi	r20, 0x0D	; 13
    c894:	50 e0       	ldi	r21, 0x00	; 0
    c896:	0e 94 cb 81 	call	0x10396	; 0x10396 <__eerd_block_m2560>
				erbl(GSM_TxStr, SMS_Number+TempNum, MaxTelephN);
				GSMTxSz = strlen(GSM_TxStr);
    c89a:	f7 01       	movw	r30, r14
    c89c:	01 90       	ld	r0, Z+
    c89e:	00 20       	and	r0, r0
    c8a0:	e9 f7       	brne	.-6      	; 0xc89c <GSM_Cycle+0x628>
    c8a2:	31 97       	sbiw	r30, 0x01	; 1
    c8a4:	ee 19       	sub	r30, r14
    c8a6:	ff 09       	sbc	r31, r15
    c8a8:	e0 93 75 07 	sts	0x0775, r30
				uint8_t j=0;
				for(uint8_t i=0; i<GSMTxSz; i++)
    c8ac:	80 91 75 07 	lds	r24, 0x0775
    c8b0:	88 23       	and	r24, r24
    c8b2:	99 f0       	breq	.+38     	; 0xc8da <GSM_Cycle+0x666>
    c8b4:	90 e0       	ldi	r25, 0x00	; 0
    c8b6:	20 e0       	ldi	r18, 0x00	; 0
					if(GSM_TxStr[i] != '0') j++;
    c8b8:	e9 2f       	mov	r30, r25
    c8ba:	f0 e0       	ldi	r31, 0x00	; 0
    c8bc:	ee 5f       	subi	r30, 0xFE	; 254
    c8be:	f5 4f       	sbci	r31, 0xF5	; 245
    c8c0:	80 81       	ld	r24, Z
    c8c2:	80 33       	cpi	r24, 0x30	; 48
    c8c4:	09 f0       	breq	.+2      	; 0xc8c8 <GSM_Cycle+0x654>
    c8c6:	2f 5f       	subi	r18, 0xFF	; 255
		case GSM_SEND_CMGS:
			if(GSM_Flag & (1<<flg_TxCStr)){			
				erbl(GSM_TxStr, SMS_Number+TempNum, MaxTelephN);
				GSMTxSz = strlen(GSM_TxStr);
				uint8_t j=0;
				for(uint8_t i=0; i<GSMTxSz; i++)
    c8c8:	9f 5f       	subi	r25, 0xFF	; 255
    c8ca:	80 91 75 07 	lds	r24, 0x0775
    c8ce:	98 17       	cp	r25, r24
    c8d0:	98 f3       	brcs	.-26     	; 0xc8b8 <GSM_Cycle+0x644>
					if(GSM_TxStr[i] != '0') j++;
				if(j){
    c8d2:	22 23       	and	r18, r18
    c8d4:	11 f0       	breq	.+4      	; 0xc8da <GSM_Cycle+0x666>
    c8d6:	0c 94 05 6e 	jmp	0xdc0a	; 0xdc0a <GSM_Cycle+0x1996>
					GSM_SendFirstChar();
					StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
					GSM_State++;
				}
				else{
					TempNum++;
    c8da:	80 91 da 05 	lds	r24, 0x05DA
    c8de:	8f 5f       	subi	r24, 0xFF	; 255
    c8e0:	80 93 da 05 	sts	0x05DA, r24
					if(TempNum>=MaxTelephDirSz){
    c8e4:	83 30       	cpi	r24, 0x03	; 3
    c8e6:	08 f4       	brcc	.+2      	; 0xc8ea <GSM_Cycle+0x676>
    c8e8:	e5 cc       	rjmp	.-1590   	; 0xc2b4 <GSM_Cycle+0x40>
						//StartTimer16(TD_GSM,150);

						GSM_State = GSM_Return2dataMode;
    c8ea:	87 e5       	ldi	r24, 0x57	; 87
    c8ec:	80 93 b3 06 	sts	0x06B3, r24
				
						SMS_FlgSz_Out = 0;
    c8f0:	10 92 82 07 	sts	0x0782, r1
    c8f4:	df cc       	rjmp	.-1602   	; 0xc2b4 <GSM_Cycle+0x40>
			break;

		case GSM_AnalyzeURC:			//  
			
			// 
			if( (strstr_P(GSM_RxStr, URC_CLOSED+2) != NULL) ){
    c8f6:	09 e9       	ldi	r16, 0x99	; 153
    c8f8:	17 e0       	ldi	r17, 0x07	; 7
    c8fa:	c8 01       	movw	r24, r16
    c8fc:	64 ed       	ldi	r22, 0xD4	; 212
    c8fe:	73 e0       	ldi	r23, 0x03	; 3
    c900:	0e 94 e3 7e 	call	0xfdc6	; 0xfdc6 <strstr_P>
    c904:	89 2b       	or	r24, r25
    c906:	11 f4       	brne	.+4      	; 0xc90c <GSM_Cycle+0x698>
    c908:	0c 94 78 6e 	jmp	0xdcf0	; 0xdcf0 <GSM_Cycle+0x1a7c>
				GSM_State =GSM_ReStart1;
    c90c:	8a e4       	ldi	r24, 0x4A	; 74
    c90e:	80 93 b3 06 	sts	0x06B3, r24
    c912:	d0 cc       	rjmp	.-1632   	; 0xc2b4 <GSM_Cycle+0x40>
		//------------------------


		//------------------------
		case GSM_CIPSHUT_:
			GSM_Execute_Command(AT_CIPSHUT, 1000*GSM_DEBUG_DELAY); GSM_State++;
    c914:	84 ee       	ldi	r24, 0xE4	; 228
    c916:	95 e0       	ldi	r25, 0x05	; 5
    c918:	68 ee       	ldi	r22, 0xE8	; 232
    c91a:	73 e0       	ldi	r23, 0x03	; 3
    c91c:	0e 94 b4 4a 	call	0x9568	; 0x9568 <GSM_Execute_Command>
    c920:	80 91 b3 06 	lds	r24, 0x06B3
    c924:	8f 5f       	subi	r24, 0xFF	; 255
    c926:	80 93 b3 06 	sts	0x06B3, r24
    c92a:	c4 cc       	rjmp	.-1656   	; 0xc2b4 <GSM_Cycle+0x40>
			break;
		case GSM_ShutWait_:
			if(GSM_Wait_Response_P(RESP_SHUT_OK, GSM_ReStart1)) GSM_State++;
    c92c:	89 e4       	ldi	r24, 0x49	; 73
    c92e:	94 e0       	ldi	r25, 0x04	; 4
    c930:	6a e4       	ldi	r22, 0x4A	; 74
    c932:	0e 94 59 4a 	call	0x94b2	; 0x94b2 <GSM_Wait_Response_P>
    c936:	88 23       	and	r24, r24
    c938:	09 f4       	brne	.+2      	; 0xc93c <GSM_Cycle+0x6c8>
    c93a:	bc cc       	rjmp	.-1672   	; 0xc2b4 <GSM_Cycle+0x40>
    c93c:	80 91 b3 06 	lds	r24, 0x06B3
    c940:	8f 5f       	subi	r24, 0xFF	; 255
    c942:	80 93 b3 06 	sts	0x06B3, r24
    c946:	b6 cc       	rjmp	.-1684   	; 0xc2b4 <GSM_Cycle+0x40>
			SMS_Data_Out[SMS_FlgSz_Out] = 0x1A;	// SMS Data end - char Ctrl-Z
			GSM_SendData((uint8_t *)SMS_Data_Out, SMS_FlgSz_Out+1);
			GSM_State++;
			break;		
		case GSM_WAIT_CMGS_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    c948:	81 ef       	ldi	r24, 0xF1	; 241
    c94a:	93 e0       	ldi	r25, 0x03	; 3
    c94c:	6a e4       	ldi	r22, 0x4A	; 74
    c94e:	0e 94 59 4a 	call	0x94b2	; 0x94b2 <GSM_Wait_Response_P>
    c952:	88 23       	and	r24, r24
    c954:	09 f4       	brne	.+2      	; 0xc958 <GSM_Cycle+0x6e4>
    c956:	ae cc       	rjmp	.-1700   	; 0xc2b4 <GSM_Cycle+0x40>
				if(++TempNum>=MaxTelephDirSz){
    c958:	80 91 da 05 	lds	r24, 0x05DA
    c95c:	8f 5f       	subi	r24, 0xFF	; 255
    c95e:	80 93 da 05 	sts	0x05DA, r24
    c962:	83 30       	cpi	r24, 0x03	; 3
    c964:	10 f4       	brcc	.+4      	; 0xc96a <GSM_Cycle+0x6f6>
    c966:	0c 94 bd 6d 	jmp	0xdb7a	; 0xdb7a <GSM_Cycle+0x1906>
					GSM_State = GSM_Return2dataMode;
    c96a:	87 e5       	ldi	r24, 0x57	; 87
    c96c:	80 93 b3 06 	sts	0x06B3, r24
					SMS_FlgSz_Out = 0;
    c970:	10 92 82 07 	sts	0x0782, r1
    c974:	9f cc       	rjmp	.-1730   	; 0xc2b4 <GSM_Cycle+0x40>
				counter=1;

			}
			#endif	

			if(GetStringFromFIFO()){
    c976:	0e 94 80 38 	call	0x7100	; 0x7100 <GetStringFromFIFO>
    c97a:	88 23       	and	r24, r24
    c97c:	09 f4       	brne	.+2      	; 0xc980 <GSM_Cycle+0x70c>
    c97e:	9a cc       	rjmp	.-1740   	; 0xc2b4 <GSM_Cycle+0x40>
				GSM_State = GSM_AnalyzeURC;
    c980:	8f e3       	ldi	r24, 0x3F	; 63
    c982:	80 93 b3 06 	sts	0x06B3, r24
				TempNum = 0;
    c986:	10 92 da 05 	sts	0x05DA, r1
    c98a:	94 cc       	rjmp	.-1752   	; 0xc2b4 <GSM_Cycle+0x40>
			GSM_SendFirstChar();
			GSM_State = GSM_WAIT_PLAY_CONFIRM_FILE_OK;
			StartTimer16(TD_GSM, 2000);
			break;
		case GSM_WAIT_PLAY_CONFIRM_FILE_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_WAIT_PLAY_CONFIRM_FILE_OK)) 
    c98c:	81 ef       	ldi	r24, 0xF1	; 241
    c98e:	93 e0       	ldi	r25, 0x03	; 3
    c990:	6e e1       	ldi	r22, 0x1E	; 30
    c992:	0e 94 59 4a 	call	0x94b2	; 0x94b2 <GSM_Wait_Response_P>
    c996:	88 23       	and	r24, r24
    c998:	09 f4       	brne	.+2      	; 0xc99c <GSM_Cycle+0x728>
    c99a:	8c cc       	rjmp	.-1768   	; 0xc2b4 <GSM_Cycle+0x40>
				{
					GSM_State = GSM_WAIT_PLAY_CONFIRM_FILE_CREC_0;
    c99c:	8f e1       	ldi	r24, 0x1F	; 31
    c99e:	80 93 b3 06 	sts	0x06B3, r24
					StartTimer16(TD_GSM, 20000);
    c9a2:	80 91 e7 04 	lds	r24, 0x04E7
    c9a6:	60 e2       	ldi	r22, 0x20	; 32
    c9a8:	7e e4       	ldi	r23, 0x4E	; 78
    c9aa:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
    c9ae:	82 cc       	rjmp	.-1788   	; 0xc2b4 <GSM_Cycle+0x40>
			}

			break;

		case GSM_SEND_PLAY_CONFIRM_FILE: 
			ConfirmState = 1;
    c9b0:	81 e0       	ldi	r24, 0x01	; 1
    c9b2:	80 93 e1 02 	sts	0x02E1, r24
			sprintf_P(GSM_TxStr, PSTR("AT+CREC=4,\"C:\\User\\Confirm.amr\",0,100\r"));
    c9b6:	00 d0       	rcall	.+0      	; 0xc9b8 <GSM_Cycle+0x744>
    c9b8:	0f 92       	push	r0
    c9ba:	82 e0       	ldi	r24, 0x02	; 2
    c9bc:	9a e0       	ldi	r25, 0x0A	; 10
    c9be:	ed b7       	in	r30, 0x3d	; 61
    c9c0:	fe b7       	in	r31, 0x3e	; 62
    c9c2:	92 83       	std	Z+2, r25	; 0x02
    c9c4:	81 83       	std	Z+1, r24	; 0x01
    c9c6:	8e e6       	ldi	r24, 0x6E	; 110
    c9c8:	9c e2       	ldi	r25, 0x2C	; 44
    c9ca:	94 83       	std	Z+4, r25	; 0x04
    c9cc:	83 83       	std	Z+3, r24	; 0x03
    c9ce:	0e 94 de 7f 	call	0xffbc	; 0xffbc <sprintf_P>
			GSMTxSz=38;
    c9d2:	86 e2       	ldi	r24, 0x26	; 38
    c9d4:	80 93 75 07 	sts	0x0775, r24
			GSM_SendFirstChar();
    c9d8:	0f 90       	pop	r0
    c9da:	0f 90       	pop	r0
    c9dc:	0f 90       	pop	r0
    c9de:	0f 90       	pop	r0
    c9e0:	0e 94 aa 39 	call	0x7354	; 0x7354 <GSM_SendFirstChar>
			GSM_State = GSM_WAIT_PLAY_CONFIRM_FILE_OK;
    c9e4:	8e e1       	ldi	r24, 0x1E	; 30
    c9e6:	80 93 b3 06 	sts	0x06B3, r24
			StartTimer16(TD_GSM, 2000);
    c9ea:	80 91 e7 04 	lds	r24, 0x04E7
    c9ee:	60 ed       	ldi	r22, 0xD0	; 208
    c9f0:	77 e0       	ldi	r23, 0x07	; 7
    c9f2:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
    c9f6:	5e cc       	rjmp	.-1860   	; 0xc2b4 <GSM_Cycle+0x40>
			GSM_State = GSM_WAIT_CREC_0;
			StartTimer16(TD_GSM, 1000);
			GSM_SendFirstChar();
			break;
		case GSM_WAIT_CREC_0:
			if(GetStringFromFIFO()){
    c9f8:	0e 94 80 38 	call	0x7100	; 0x7100 <GetStringFromFIFO>
    c9fc:	88 23       	and	r24, r24
    c9fe:	09 f4       	brne	.+2      	; 0xca02 <GSM_Cycle+0x78e>
    ca00:	9d c6       	rjmp	.+3386   	; 0xd73c <GSM_Cycle+0x14c8>
				if((strstr_P(GSM_RxStr, PSTR("+CREC: 0")) != NULL) ){
    ca02:	89 e9       	ldi	r24, 0x99	; 153
    ca04:	97 e0       	ldi	r25, 0x07	; 7
    ca06:	65 e9       	ldi	r22, 0x95	; 149
    ca08:	7c e2       	ldi	r23, 0x2C	; 44
    ca0a:	0e 94 e3 7e 	call	0xfdc6	; 0xfdc6 <strstr_P>
    ca0e:	89 2b       	or	r24, r25
    ca10:	09 f4       	brne	.+2      	; 0xca14 <GSM_Cycle+0x7a0>
    ca12:	94 c6       	rjmp	.+3368   	; 0xd73c <GSM_Cycle+0x14c8>
					GSM_State = GSM_SEND_PLAY_CONFIRM_FILE;
    ca14:	8d e1       	ldi	r24, 0x1D	; 29
    ca16:	80 93 b3 06 	sts	0x06B3, r24
    ca1a:	4c cc       	rjmp	.-1896   	; 0xc2b4 <GSM_Cycle+0x40>
				}
			}

			break;
		case GSM_SEND_CREC_5:
			sprintf_P(GSM_TxStr, PSTR("AT+CREC=5\r"));
    ca1c:	00 d0       	rcall	.+0      	; 0xca1e <GSM_Cycle+0x7aa>
    ca1e:	0f 92       	push	r0
    ca20:	82 e0       	ldi	r24, 0x02	; 2
    ca22:	9a e0       	ldi	r25, 0x0A	; 10
    ca24:	ad b7       	in	r26, 0x3d	; 61
    ca26:	be b7       	in	r27, 0x3e	; 62
    ca28:	12 96       	adiw	r26, 0x02	; 2
    ca2a:	9c 93       	st	X, r25
    ca2c:	8e 93       	st	-X, r24
    ca2e:	11 97       	sbiw	r26, 0x01	; 1
    ca30:	8e e9       	ldi	r24, 0x9E	; 158
    ca32:	9c e2       	ldi	r25, 0x2C	; 44
    ca34:	14 96       	adiw	r26, 0x04	; 4
    ca36:	9c 93       	st	X, r25
    ca38:	8e 93       	st	-X, r24
    ca3a:	13 97       	sbiw	r26, 0x03	; 3
    ca3c:	0e 94 de 7f 	call	0xffbc	; 0xffbc <sprintf_P>
			GSMTxSz=10;
    ca40:	8a e0       	ldi	r24, 0x0A	; 10
    ca42:	80 93 75 07 	sts	0x0775, r24
			GSM_State = GSM_WAIT_CREC_0;
    ca46:	8c e1       	ldi	r24, 0x1C	; 28
    ca48:	80 93 b3 06 	sts	0x06B3, r24
			StartTimer16(TD_GSM, 1000);
    ca4c:	0f 90       	pop	r0
    ca4e:	0f 90       	pop	r0
    ca50:	0f 90       	pop	r0
    ca52:	0f 90       	pop	r0
    ca54:	80 91 e7 04 	lds	r24, 0x04E7
    ca58:	68 ee       	ldi	r22, 0xE8	; 232
    ca5a:	73 e0       	ldi	r23, 0x03	; 3
    ca5c:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
			GSM_SendFirstChar();
    ca60:	0e 94 aa 39 	call	0x7354	; 0x7354 <GSM_SendFirstChar>
    ca64:	27 cc       	rjmp	.-1970   	; 0xc2b4 <GSM_Cycle+0x40>
				GSM_State = GSM_WAIT_CONFIRMRESPONSE;
				StartTimer16(TD_GSM, 200);
			}
			break;
		case GSM_WAIT_CONFIRMRESPONSE:
			if(GetStringFromFIFO()){
    ca66:	0e 94 80 38 	call	0x7100	; 0x7100 <GetStringFromFIFO>
    ca6a:	88 23       	and	r24, r24
    ca6c:	29 f0       	breq	.+10     	; 0xca78 <GSM_Cycle+0x804>
				if(analize_DTMF()){
    ca6e:	0e 94 c7 4a 	call	0x958e	; 0x958e <analize_DTMF>
    ca72:	88 23       	and	r24, r24
    ca74:	09 f0       	breq	.+2      	; 0xca78 <GSM_Cycle+0x804>
    ca76:	1e cc       	rjmp	.-1988   	; 0xc2b4 <GSM_Cycle+0x40>
					break;
				}
			}
			if(Timer16Stopp(TD_GSM)){
    ca78:	80 91 e7 04 	lds	r24, 0x04E7
    ca7c:	0e 94 06 1c 	call	0x380c	; 0x380c <Timer16Stopp>
    ca80:	88 23       	and	r24, r24
    ca82:	09 f4       	brne	.+2      	; 0xca86 <GSM_Cycle+0x812>
    ca84:	17 cc       	rjmp	.-2002   	; 0xc2b4 <GSM_Cycle+0x40>
				if(RequestRepeatCounter<4){
    ca86:	80 91 e2 02 	lds	r24, 0x02E2
    ca8a:	84 30       	cpi	r24, 0x04	; 4
    ca8c:	10 f0       	brcs	.+4      	; 0xca92 <GSM_Cycle+0x81e>
    ca8e:	0c 94 c2 6d 	jmp	0xdb84	; 0xdb84 <GSM_Cycle+0x1910>
				GSM_State = GSM_SEND_PLAY_ALARM_FILE;
    ca92:	84 e1       	ldi	r24, 0x14	; 20
    ca94:	80 93 b3 06 	sts	0x06B3, r24
    ca98:	0d cc       	rjmp	.-2022   	; 0xc2b4 <GSM_Cycle+0x40>
					GSM_State = GSM_WAIT_PLAY_CONFIRMREQUEST_FILE_CREC_0;
					StartTimer16(TD_GSM, 20000);
				}
			break;
		case GSM_WAIT_PLAY_CONFIRMREQUEST_FILE_CREC_0:
			if(GetStringFromFIFO()){
    ca9a:	0e 94 80 38 	call	0x7100	; 0x7100 <GetStringFromFIFO>
    ca9e:	88 23       	and	r24, r24
    caa0:	09 f4       	brne	.+2      	; 0xcaa4 <GSM_Cycle+0x830>
    caa2:	5f c6       	rjmp	.+3262   	; 0xd762 <GSM_Cycle+0x14ee>
				if((strstr_P(GSM_RxStr, PSTR("+CREC: 0")) != NULL) ){
    caa4:	89 e9       	ldi	r24, 0x99	; 153
    caa6:	97 e0       	ldi	r25, 0x07	; 7
    caa8:	69 ea       	ldi	r22, 0xA9	; 169
    caaa:	7c e2       	ldi	r23, 0x2C	; 44
    caac:	0e 94 e3 7e 	call	0xfdc6	; 0xfdc6 <strstr_P>
    cab0:	89 2b       	or	r24, r25
    cab2:	09 f4       	brne	.+2      	; 0xcab6 <GSM_Cycle+0x842>
    cab4:	50 c6       	rjmp	.+3232   	; 0xd756 <GSM_Cycle+0x14e2>
					GSM_State = GSM_WAIT_CONFIRMRESPONSE;
    cab6:	8a e1       	ldi	r24, 0x1A	; 26
    cab8:	80 93 b3 06 	sts	0x06B3, r24
					StartTimer16(TD_GSM, 200);
    cabc:	80 91 e7 04 	lds	r24, 0x04E7
    cac0:	68 ec       	ldi	r22, 0xC8	; 200
    cac2:	70 e0       	ldi	r23, 0x00	; 0
    cac4:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
    cac8:	f5 cb       	rjmp	.-2070   	; 0xc2b4 <GSM_Cycle+0x40>
			GSM_SendFirstChar();
			GSM_State = GSM_WAIT_PLAY_CONFIRMREQUEST_FILE_OK;
			StartTimer16(TD_GSM, 1000);
			break;
		case GSM_WAIT_PLAY_CONFIRMREQUEST_FILE_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_WAIT_PLAY_CONFIRMREQUEST_FILE_OK)) 
    caca:	81 ef       	ldi	r24, 0xF1	; 241
    cacc:	93 e0       	ldi	r25, 0x03	; 3
    cace:	68 e1       	ldi	r22, 0x18	; 24
    cad0:	0e 94 59 4a 	call	0x94b2	; 0x94b2 <GSM_Wait_Response_P>
    cad4:	88 23       	and	r24, r24
    cad6:	09 f4       	brne	.+2      	; 0xcada <GSM_Cycle+0x866>
    cad8:	ed cb       	rjmp	.-2086   	; 0xc2b4 <GSM_Cycle+0x40>
				{
					GSM_State = GSM_WAIT_PLAY_CONFIRMREQUEST_FILE_CREC_0;
    cada:	89 e1       	ldi	r24, 0x19	; 25
    cadc:	80 93 b3 06 	sts	0x06B3, r24
					StartTimer16(TD_GSM, 20000);
    cae0:	80 91 e7 04 	lds	r24, 0x04E7
    cae4:	60 e2       	ldi	r22, 0x20	; 32
    cae6:	7e e4       	ldi	r23, 0x4E	; 78
    cae8:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
    caec:	e3 cb       	rjmp	.-2106   	; 0xc2b4 <GSM_Cycle+0x40>
			if(Timer16Stopp(TD_GSM)){
				GSM_State = GSM_WAIT_CONFIRMRESPONSE;
			}
			break;
		case GSM_SEND_PLAY_CONFIRMREQUEST_FILE: 
			sprintf_P(GSM_TxStr, PSTR("AT+CREC=4,\"C:\\User\\ConfirmRequest.amr\",0,100\r"));
    caee:	00 d0       	rcall	.+0      	; 0xcaf0 <GSM_Cycle+0x87c>
    caf0:	0f 92       	push	r0
    caf2:	82 e0       	ldi	r24, 0x02	; 2
    caf4:	9a e0       	ldi	r25, 0x0A	; 10
    caf6:	ed b7       	in	r30, 0x3d	; 61
    caf8:	fe b7       	in	r31, 0x3e	; 62
    cafa:	92 83       	std	Z+2, r25	; 0x02
    cafc:	81 83       	std	Z+1, r24	; 0x01
    cafe:	82 eb       	ldi	r24, 0xB2	; 178
    cb00:	9c e2       	ldi	r25, 0x2C	; 44
    cb02:	94 83       	std	Z+4, r25	; 0x04
    cb04:	83 83       	std	Z+3, r24	; 0x03
    cb06:	0e 94 de 7f 	call	0xffbc	; 0xffbc <sprintf_P>
			GSMTxSz=45;
    cb0a:	8d e2       	ldi	r24, 0x2D	; 45
    cb0c:	80 93 75 07 	sts	0x0775, r24
			GSM_SendFirstChar();
    cb10:	0f 90       	pop	r0
    cb12:	0f 90       	pop	r0
    cb14:	0f 90       	pop	r0
    cb16:	0f 90       	pop	r0
    cb18:	0e 94 aa 39 	call	0x7354	; 0x7354 <GSM_SendFirstChar>
			GSM_State = GSM_WAIT_PLAY_CONFIRMREQUEST_FILE_OK;
    cb1c:	88 e1       	ldi	r24, 0x18	; 24
    cb1e:	80 93 b3 06 	sts	0x06B3, r24
			StartTimer16(TD_GSM, 1000);
    cb22:	80 91 e7 04 	lds	r24, 0x04E7
    cb26:	68 ee       	ldi	r22, 0xE8	; 232
    cb28:	73 e0       	ldi	r23, 0x03	; 3
    cb2a:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
    cb2e:	c2 cb       	rjmp	.-2172   	; 0xc2b4 <GSM_Cycle+0x40>
					GSM_State = GSM_WAIT_PLAY_ALARM_FILE_CREC_0;
					StartTimer16(TD_GSM, 20000);
				}
			break;
		case GSM_WAIT_PLAY_ALARM_FILE_CREC_0:
			if(GetStringFromFIFO()){
    cb30:	0e 94 80 38 	call	0x7100	; 0x7100 <GetStringFromFIFO>
    cb34:	88 23       	and	r24, r24
    cb36:	09 f4       	brne	.+2      	; 0xcb3a <GSM_Cycle+0x8c6>
    cb38:	2d c6       	rjmp	.+3162   	; 0xd794 <GSM_Cycle+0x1520>
				if((strstr_P(GSM_RxStr, PSTR("+CREC: 0")) != NULL) ){
    cb3a:	89 e9       	ldi	r24, 0x99	; 153
    cb3c:	97 e0       	ldi	r25, 0x07	; 7
    cb3e:	60 ee       	ldi	r22, 0xE0	; 224
    cb40:	7c e2       	ldi	r23, 0x2C	; 44
    cb42:	0e 94 e3 7e 	call	0xfdc6	; 0xfdc6 <strstr_P>
    cb46:	89 2b       	or	r24, r25
    cb48:	09 f4       	brne	.+2      	; 0xcb4c <GSM_Cycle+0x8d8>
    cb4a:	1e c6       	rjmp	.+3132   	; 0xd788 <GSM_Cycle+0x1514>
					GSM_State = GSM_SEND_PLAY_CONFIRMREQUEST_FILE;
    cb4c:	87 e1       	ldi	r24, 0x17	; 23
    cb4e:	80 93 b3 06 	sts	0x06B3, r24
    cb52:	b0 cb       	rjmp	.-2208   	; 0xc2b4 <GSM_Cycle+0x40>
			GSM_SendFirstChar();
			GSM_State = GSM_WAIT_PLAY_ALARM_FILE_OK;
			StartTimer16(TD_GSM, 1000);
			break;
		case GSM_WAIT_PLAY_ALARM_FILE_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_WAIT_MESSAGE)) 
    cb54:	81 ef       	ldi	r24, 0xF1	; 241
    cb56:	93 e0       	ldi	r25, 0x03	; 3
    cb58:	6e e0       	ldi	r22, 0x0E	; 14
    cb5a:	0e 94 59 4a 	call	0x94b2	; 0x94b2 <GSM_Wait_Response_P>
    cb5e:	88 23       	and	r24, r24
    cb60:	09 f4       	brne	.+2      	; 0xcb64 <GSM_Cycle+0x8f0>
    cb62:	a8 cb       	rjmp	.-2224   	; 0xc2b4 <GSM_Cycle+0x40>
				{
					GSM_State = GSM_WAIT_PLAY_ALARM_FILE_CREC_0;
    cb64:	86 e1       	ldi	r24, 0x16	; 22
    cb66:	80 93 b3 06 	sts	0x06B3, r24
					StartTimer16(TD_GSM, 20000);
    cb6a:	80 91 e7 04 	lds	r24, 0x04E7
    cb6e:	60 e2       	ldi	r22, 0x20	; 32
    cb70:	7e e4       	ldi	r23, 0x4E	; 78
    cb72:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
    cb76:	9e cb       	rjmp	.-2244   	; 0xc2b4 <GSM_Cycle+0x40>
			if(Timer16Stopp(TD_GSM)){
				GSM_State = GSM_WAIT_MESSAGE;
			}
			break;
		case GSM_SEND_PLAY_ALARM_FILE: 
			RequestRepeatCounter++;
    cb78:	80 91 e2 02 	lds	r24, 0x02E2
    cb7c:	8f 5f       	subi	r24, 0xFF	; 255
    cb7e:	80 93 e2 02 	sts	0x02E2, r24
			sprintf_P(GSM_TxStr, PSTR("AT+CREC=4,\"C:\\User\\Alarm"));
    cb82:	00 d0       	rcall	.+0      	; 0xcb84 <GSM_Cycle+0x910>
    cb84:	0f 92       	push	r0
    cb86:	b2 e0       	ldi	r27, 0x02	; 2
    cb88:	eb 2e       	mov	r14, r27
    cb8a:	ba e0       	ldi	r27, 0x0A	; 10
    cb8c:	fb 2e       	mov	r15, r27
    cb8e:	ad b7       	in	r26, 0x3d	; 61
    cb90:	be b7       	in	r27, 0x3e	; 62
    cb92:	12 96       	adiw	r26, 0x02	; 2
    cb94:	fc 92       	st	X, r15
    cb96:	ee 92       	st	-X, r14
    cb98:	11 97       	sbiw	r26, 0x01	; 1
    cb9a:	86 ef       	ldi	r24, 0xF6	; 246
    cb9c:	9c e2       	ldi	r25, 0x2C	; 44
    cb9e:	14 96       	adiw	r26, 0x04	; 4
    cba0:	9c 93       	st	X, r25
    cba2:	8e 93       	st	-X, r24
    cba4:	13 97       	sbiw	r26, 0x03	; 3
    cba6:	0e 94 de 7f 	call	0xffbc	; 0xffbc <sprintf_P>
			GSMTxSz=24;
    cbaa:	88 e1       	ldi	r24, 0x18	; 24
    cbac:	80 93 75 07 	sts	0x0775, r24
			sprintf(GSM_TxStr+GSMTxSz,"%u",Message[2]);
    cbb0:	80 91 75 07 	lds	r24, 0x0775
    cbb4:	0f 92       	push	r0
    cbb6:	0f 92       	push	r0
    cbb8:	ed b7       	in	r30, 0x3d	; 61
    cbba:	fe b7       	in	r31, 0x3e	; 62
    cbbc:	31 96       	adiw	r30, 0x01	; 1
    cbbe:	90 e0       	ldi	r25, 0x00	; 0
    cbc0:	8e 0d       	add	r24, r14
    cbc2:	9f 1d       	adc	r25, r15
    cbc4:	ad b7       	in	r26, 0x3d	; 61
    cbc6:	be b7       	in	r27, 0x3e	; 62
    cbc8:	12 96       	adiw	r26, 0x02	; 2
    cbca:	9c 93       	st	X, r25
    cbcc:	8e 93       	st	-X, r24
    cbce:	11 97       	sbiw	r26, 0x01	; 1
    cbd0:	82 eb       	ldi	r24, 0xB2	; 178
    cbd2:	92 e0       	ldi	r25, 0x02	; 2
    cbd4:	93 83       	std	Z+3, r25	; 0x03
    cbd6:	82 83       	std	Z+2, r24	; 0x02
    cbd8:	80 91 f4 06 	lds	r24, 0x06F4
    cbdc:	84 83       	std	Z+4, r24	; 0x04
    cbde:	15 82       	std	Z+5, r1	; 0x05
    cbe0:	0e 94 ad 7f 	call	0xff5a	; 0xff5a <sprintf>
			if(Message[2]>9){
    cbe4:	ed b7       	in	r30, 0x3d	; 61
    cbe6:	fe b7       	in	r31, 0x3e	; 62
    cbe8:	36 96       	adiw	r30, 0x06	; 6
    cbea:	0f b6       	in	r0, 0x3f	; 63
    cbec:	f8 94       	cli
    cbee:	fe bf       	out	0x3e, r31	; 62
    cbf0:	0f be       	out	0x3f, r0	; 63
    cbf2:	ed bf       	out	0x3d, r30	; 61
    cbf4:	80 91 f4 06 	lds	r24, 0x06F4
    cbf8:	8a 30       	cpi	r24, 0x0A	; 10
    cbfa:	08 f4       	brcc	.+2      	; 0xcbfe <GSM_Cycle+0x98a>
    cbfc:	2d c6       	rjmp	.+3162   	; 0xd858 <GSM_Cycle+0x15e4>
				GSMTxSz+=2;
    cbfe:	80 91 75 07 	lds	r24, 0x0775
    cc02:	8e 5f       	subi	r24, 0xFE	; 254
    cc04:	80 93 75 07 	sts	0x0775, r24
			}
			else{
				GSMTxSz++;
			};
			sprintf_P(GSM_TxStr+GSMTxSz, PSTR(".amr\",0,100\r"));
    cc08:	80 91 75 07 	lds	r24, 0x0775
    cc0c:	00 d0       	rcall	.+0      	; 0xcc0e <GSM_Cycle+0x99a>
    cc0e:	0f 92       	push	r0
    cc10:	90 e0       	ldi	r25, 0x00	; 0
    cc12:	8e 5f       	subi	r24, 0xFE	; 254
    cc14:	95 4f       	sbci	r25, 0xF5	; 245
    cc16:	ad b7       	in	r26, 0x3d	; 61
    cc18:	be b7       	in	r27, 0x3e	; 62
    cc1a:	12 96       	adiw	r26, 0x02	; 2
    cc1c:	9c 93       	st	X, r25
    cc1e:	8e 93       	st	-X, r24
    cc20:	11 97       	sbiw	r26, 0x01	; 1
    cc22:	89 ee       	ldi	r24, 0xE9	; 233
    cc24:	9c e2       	ldi	r25, 0x2C	; 44
    cc26:	14 96       	adiw	r26, 0x04	; 4
    cc28:	9c 93       	st	X, r25
    cc2a:	8e 93       	st	-X, r24
    cc2c:	13 97       	sbiw	r26, 0x03	; 3
    cc2e:	0e 94 de 7f 	call	0xffbc	; 0xffbc <sprintf_P>
			GSMTxSz += 12;
    cc32:	80 91 75 07 	lds	r24, 0x0775
    cc36:	84 5f       	subi	r24, 0xF4	; 244
    cc38:	80 93 75 07 	sts	0x0775, r24
			GSM_SendFirstChar();
    cc3c:	0f 90       	pop	r0
    cc3e:	0f 90       	pop	r0
    cc40:	0f 90       	pop	r0
    cc42:	0f 90       	pop	r0
    cc44:	0e 94 aa 39 	call	0x7354	; 0x7354 <GSM_SendFirstChar>
			GSM_State = GSM_WAIT_PLAY_ALARM_FILE_OK;
    cc48:	85 e1       	ldi	r24, 0x15	; 21
    cc4a:	80 93 b3 06 	sts	0x06B3, r24
			StartTimer16(TD_GSM, 1000);
    cc4e:	80 91 e7 04 	lds	r24, 0x04E7
    cc52:	68 ee       	ldi	r22, 0xE8	; 232
    cc54:	73 e0       	ldi	r23, 0x03	; 3
    cc56:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
    cc5a:	2c cb       	rjmp	.-2472   	; 0xc2b4 <GSM_Cycle+0x40>
			if(Timer16Stopp(TD_GSM)){
				GSM_State = GSM_WAIT_MESSAGE;
			}
			break;
		case GSM_WAIT_CCLC_0:
			if(GetStringFromFIFO()){
    cc5c:	0e 94 80 38 	call	0x7100	; 0x7100 <GetStringFromFIFO>
    cc60:	88 23       	and	r24, r24
    cc62:	09 f4       	brne	.+2      	; 0xcc66 <GSM_Cycle+0x9f2>
    cc64:	ec c5       	rjmp	.+3032   	; 0xd83e <GSM_Cycle+0x15ca>
				if((strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,0,")) != NULL) ){
    cc66:	89 e9       	ldi	r24, 0x99	; 153
    cc68:	97 e0       	ldi	r25, 0x07	; 7
    cc6a:	6d e1       	ldi	r22, 0x1D	; 29
    cc6c:	7d e2       	ldi	r23, 0x2D	; 45
    cc6e:	0e 94 e3 7e 	call	0xfdc6	; 0xfdc6 <strstr_P>
    cc72:	89 2b       	or	r24, r25
    cc74:	11 f4       	brne	.+4      	; 0xcc7a <GSM_Cycle+0xa06>
    cc76:	0c 94 a3 6e 	jmp	0xdd46	; 0xdd46 <GSM_Cycle+0x1ad2>
					RequestRepeatCounter = 0;
    cc7a:	10 92 e2 02 	sts	0x02E2, r1
					GSM_State = GSM_SEND_PLAY_ALARM_FILE;
    cc7e:	84 e1       	ldi	r24, 0x14	; 20
    cc80:	80 93 b3 06 	sts	0x06B3, r24
    cc84:	17 cb       	rjmp	.-2514   	; 0xc2b4 <GSM_Cycle+0x40>
			if(Timer16Stopp(TD_GSM)){
				GSM_State = GSM_WAIT_MESSAGE;
			}
			break;
		case GSM_WAIT_CCLC_3:
			if(GetStringFromFIFO()){
    cc86:	0e 94 80 38 	call	0x7100	; 0x7100 <GetStringFromFIFO>
    cc8a:	88 23       	and	r24, r24
    cc8c:	09 f4       	brne	.+2      	; 0xcc90 <GSM_Cycle+0xa1c>
    cc8e:	8f c5       	rjmp	.+2846   	; 0xd7ae <GSM_Cycle+0x153a>
				if( (strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6,")) != NULL) ){
    cc90:	89 e9       	ldi	r24, 0x99	; 153
    cc92:	97 e0       	ldi	r25, 0x07	; 7
    cc94:	69 e3       	ldi	r22, 0x39	; 57
    cc96:	7d e2       	ldi	r23, 0x2D	; 45
    cc98:	0e 94 e3 7e 	call	0xfdc6	; 0xfdc6 <strstr_P>
    cc9c:	89 2b       	or	r24, r25
    cc9e:	11 f4       	brne	.+4      	; 0xcca4 <GSM_Cycle+0xa30>
    cca0:	0c 94 64 6e 	jmp	0xdcc8	; 0xdcc8 <GSM_Cycle+0x1a54>
					StartTimer16(TD_GSM, 6000);
    cca4:	80 91 e7 04 	lds	r24, 0x04E7
    cca8:	60 e7       	ldi	r22, 0x70	; 112
    ccaa:	77 e1       	ldi	r23, 0x17	; 23
    ccac:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
					GSM_State = GSM_WAIT_MESSAGE;
    ccb0:	8e e0       	ldi	r24, 0x0E	; 14
    ccb2:	80 93 b3 06 	sts	0x06B3, r24
    ccb6:	fe ca       	rjmp	.-2564   	; 0xc2b4 <GSM_Cycle+0x40>
		case GSM_WAIT_ATD_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_WAIT_MESSAGE)) GSM_State = GSM_WAIT_CCLC_2;
			StartTimer16(TD_GSM, 1000);
			break;
		case GSM_WAIT_CCLC_2:
			if(GetStringFromFIFO()){
    ccb8:	0e 94 80 38 	call	0x7100	; 0x7100 <GetStringFromFIFO>
    ccbc:	88 23       	and	r24, r24
    ccbe:	09 f4       	brne	.+2      	; 0xccc2 <GSM_Cycle+0xa4e>
    ccc0:	23 c5       	rjmp	.+2630   	; 0xd708 <GSM_Cycle+0x1494>
				if( (strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,2,")) != NULL) ){
    ccc2:	89 e9       	ldi	r24, 0x99	; 153
    ccc4:	97 e0       	ldi	r25, 0x07	; 7
    ccc6:	67 e4       	ldi	r22, 0x47	; 71
    ccc8:	7d e2       	ldi	r23, 0x2D	; 45
    ccca:	0e 94 e3 7e 	call	0xfdc6	; 0xfdc6 <strstr_P>
    ccce:	89 2b       	or	r24, r25
    ccd0:	09 f4       	brne	.+2      	; 0xccd4 <GSM_Cycle+0xa60>
    ccd2:	1a c5       	rjmp	.+2612   	; 0xd708 <GSM_Cycle+0x1494>
					StartTimer16(TD_GSM, 2000);
    ccd4:	80 91 e7 04 	lds	r24, 0x04E7
    ccd8:	60 ed       	ldi	r22, 0xD0	; 208
    ccda:	77 e0       	ldi	r23, 0x07	; 7
    ccdc:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
					GSM_State = GSM_WAIT_CCLC_3;
    cce0:	82 e1       	ldi	r24, 0x12	; 18
    cce2:	80 93 b3 06 	sts	0x06B3, r24
    cce6:	e6 ca       	rjmp	.-2612   	; 0xc2b4 <GSM_Cycle+0x40>
			GSM_SendFirstChar();
			GSM_State = GSM_WAIT_ATD_OK;
			StartTimer16(TD_GSM, 1000);
			break;
		case GSM_WAIT_ATD_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_WAIT_MESSAGE)) GSM_State = GSM_WAIT_CCLC_2;
    cce8:	81 ef       	ldi	r24, 0xF1	; 241
    ccea:	93 e0       	ldi	r25, 0x03	; 3
    ccec:	6e e0       	ldi	r22, 0x0E	; 14
    ccee:	0e 94 59 4a 	call	0x94b2	; 0x94b2 <GSM_Wait_Response_P>
    ccf2:	88 23       	and	r24, r24
    ccf4:	19 f0       	breq	.+6      	; 0xccfc <GSM_Cycle+0xa88>
    ccf6:	81 e1       	ldi	r24, 0x11	; 17
    ccf8:	80 93 b3 06 	sts	0x06B3, r24
			StartTimer16(TD_GSM, 1000);
    ccfc:	80 91 e7 04 	lds	r24, 0x04E7
    cd00:	68 ee       	ldi	r22, 0xE8	; 232
    cd02:	73 e0       	ldi	r23, 0x03	; 3
    cd04:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
    cd08:	d5 ca       	rjmp	.-2646   	; 0xc2b4 <GSM_Cycle+0x40>
				ConfirmState = 0;
				GSM_State = GSM_SEND_ATD;
			}
			break;
		case GSM_SEND_ATD:
			sprintf_P(GSM_TxStr, ATD_PLUS);	GSMTxSz = strlen_P(ATD_PLUS);
    cd0a:	00 d0       	rcall	.+0      	; 0xcd0c <GSM_Cycle+0xa98>
    cd0c:	0f 92       	push	r0
    cd0e:	82 e0       	ldi	r24, 0x02	; 2
    cd10:	9a e0       	ldi	r25, 0x0A	; 10
    cd12:	ad b7       	in	r26, 0x3d	; 61
    cd14:	be b7       	in	r27, 0x3e	; 62
    cd16:	12 96       	adiw	r26, 0x02	; 2
    cd18:	9c 93       	st	X, r25
    cd1a:	8e 93       	st	-X, r24
    cd1c:	11 97       	sbiw	r26, 0x01	; 1
    cd1e:	02 ec       	ldi	r16, 0xC2	; 194
    cd20:	14 e0       	ldi	r17, 0x04	; 4
    cd22:	14 96       	adiw	r26, 0x04	; 4
    cd24:	1c 93       	st	X, r17
    cd26:	0e 93       	st	-X, r16
    cd28:	13 97       	sbiw	r26, 0x03	; 3
    cd2a:	0e 94 de 7f 	call	0xffbc	; 0xffbc <sprintf_P>
    cd2e:	0f 90       	pop	r0
    cd30:	0f 90       	pop	r0
    cd32:	0f 90       	pop	r0
    cd34:	0f 90       	pop	r0
    cd36:	c8 01       	movw	r24, r16
    cd38:	0e 94 c1 7e 	call	0xfd82	; 0xfd82 <strlen_P>
    cd3c:	80 93 75 07 	sts	0x0775, r24
			erbl(GSM_TxStr+GSMTxSz, CALL_Number+Message[1], MaxTelephN);
    cd40:	80 91 75 07 	lds	r24, 0x0775
    cd44:	90 e0       	ldi	r25, 0x00	; 0
    cd46:	60 91 f3 06 	lds	r22, 0x06F3
    cd4a:	2d e0       	ldi	r18, 0x0D	; 13
    cd4c:	62 9f       	mul	r22, r18
    cd4e:	b0 01       	movw	r22, r0
    cd50:	11 24       	eor	r1, r1
    cd52:	64 51       	subi	r22, 0x14	; 20
    cd54:	7f 4f       	sbci	r23, 0xFF	; 255
    cd56:	8e 5f       	subi	r24, 0xFE	; 254
    cd58:	95 4f       	sbci	r25, 0xF5	; 245
    cd5a:	4d e0       	ldi	r20, 0x0D	; 13
    cd5c:	50 e0       	ldi	r21, 0x00	; 0
    cd5e:	0e 94 cb 81 	call	0x10396	; 0x10396 <__eerd_block_m2560>
			GSMTxSz+=MaxTelephN-1;
    cd62:	80 91 75 07 	lds	r24, 0x0775
    cd66:	84 5f       	subi	r24, 0xF4	; 244
    cd68:	80 93 75 07 	sts	0x0775, r24
			const char c=';';
    cd6c:	8b e3       	ldi	r24, 0x3B	; 59
    cd6e:	89 83       	std	Y+1, r24	; 0x01
			sprintf(GSM_TxStr+GSMTxSz,&c);GSMTxSz++;
    cd70:	80 91 75 07 	lds	r24, 0x0775
    cd74:	00 d0       	rcall	.+0      	; 0xcd76 <GSM_Cycle+0xb02>
    cd76:	0f 92       	push	r0
    cd78:	90 e0       	ldi	r25, 0x00	; 0
    cd7a:	8e 5f       	subi	r24, 0xFE	; 254
    cd7c:	95 4f       	sbci	r25, 0xF5	; 245
    cd7e:	ed b7       	in	r30, 0x3d	; 61
    cd80:	fe b7       	in	r31, 0x3e	; 62
    cd82:	92 83       	std	Z+2, r25	; 0x02
    cd84:	81 83       	std	Z+1, r24	; 0x01
    cd86:	ce 01       	movw	r24, r28
    cd88:	01 96       	adiw	r24, 0x01	; 1
    cd8a:	94 83       	std	Z+4, r25	; 0x04
    cd8c:	83 83       	std	Z+3, r24	; 0x03
    cd8e:	0e 94 ad 7f 	call	0xff5a	; 0xff5a <sprintf>
    cd92:	80 91 75 07 	lds	r24, 0x0775
    cd96:	8f 5f       	subi	r24, 0xFF	; 255
    cd98:	80 93 75 07 	sts	0x0775, r24
			sprintf(GSM_TxStr + GSMTxSz, "\r");	GSMTxSz = GSMTxSz+1;
    cd9c:	e0 91 75 07 	lds	r30, 0x0775
    cda0:	f0 e0       	ldi	r31, 0x00	; 0
    cda2:	ee 5f       	subi	r30, 0xFE	; 254
    cda4:	f5 4f       	sbci	r31, 0xF5	; 245
    cda6:	8d e0       	ldi	r24, 0x0D	; 13
    cda8:	90 e0       	ldi	r25, 0x00	; 0
    cdaa:	91 83       	std	Z+1, r25	; 0x01
    cdac:	80 83       	st	Z, r24
    cdae:	80 91 75 07 	lds	r24, 0x0775
    cdb2:	8f 5f       	subi	r24, 0xFF	; 255
    cdb4:	80 93 75 07 	sts	0x0775, r24
			GSM_SendFirstChar();
    cdb8:	0f 90       	pop	r0
    cdba:	0f 90       	pop	r0
    cdbc:	0f 90       	pop	r0
    cdbe:	0f 90       	pop	r0
    cdc0:	0e 94 aa 39 	call	0x7354	; 0x7354 <GSM_SendFirstChar>
			GSM_State = GSM_WAIT_ATD_OK;
    cdc4:	80 e1       	ldi	r24, 0x10	; 16
    cdc6:	80 93 b3 06 	sts	0x06B3, r24
			StartTimer16(TD_GSM, 1000);
    cdca:	80 91 e7 04 	lds	r24, 0x04E7
    cdce:	68 ee       	ldi	r22, 0xE8	; 232
    cdd0:	73 e0       	ldi	r23, 0x03	; 3
    cdd2:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
    cdd6:	6e ca       	rjmp	.-2852   	; 0xc2b4 <GSM_Cycle+0x40>
			break;
		case GSM_WAIT_DDET101_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;
		case GSM_WAIT_MESSAGE:
			if(Message[0]==1)
    cdd8:	80 91 f2 06 	lds	r24, 0x06F2
    cddc:	81 30       	cpi	r24, 0x01	; 1
    cdde:	09 f0       	breq	.+2      	; 0xcde2 <GSM_Cycle+0xb6e>
    cde0:	69 ca       	rjmp	.-2862   	; 0xc2b4 <GSM_Cycle+0x40>
			{
				Message[0]=0;
    cde2:	10 92 f2 06 	sts	0x06F2, r1
				ConfirmState=0;
				ConfirmState = 0;
    cde6:	10 92 e1 02 	sts	0x02E1, r1
				GSM_State = GSM_SEND_ATD;
    cdea:	8f e0       	ldi	r24, 0x0F	; 15
    cdec:	80 93 b3 06 	sts	0x06B3, r24
    cdf0:	61 ca       	rjmp	.-2878   	; 0xc2b4 <GSM_Cycle+0x40>
			break;
		case GSM_SEND_DDET101:
			GSM_Execute_Command(AT_DDET101,100*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_DDET101_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    cdf2:	81 ef       	ldi	r24, 0xF1	; 241
    cdf4:	93 e0       	ldi	r25, 0x03	; 3
    cdf6:	6a e4       	ldi	r22, 0x4A	; 74
    cdf8:	0e 94 59 4a 	call	0x94b2	; 0x94b2 <GSM_Wait_Response_P>
    cdfc:	88 23       	and	r24, r24
    cdfe:	09 f4       	brne	.+2      	; 0xce02 <GSM_Cycle+0xb8e>
    ce00:	59 ca       	rjmp	.-2894   	; 0xc2b4 <GSM_Cycle+0x40>
    ce02:	80 91 b3 06 	lds	r24, 0x06B3
    ce06:	8f 5f       	subi	r24, 0xFF	; 255
    ce08:	80 93 b3 06 	sts	0x06B3, r24
    ce0c:	53 ca       	rjmp	.-2906   	; 0xc2b4 <GSM_Cycle+0x40>
			break;
		case GSM_WAIT_CLCC_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;
		case GSM_SEND_DDET101:
			GSM_Execute_Command(AT_DDET101,100*GSM_DEBUG_DELAY); GSM_State++;
    ce0e:	80 e9       	ldi	r24, 0x90	; 144
    ce10:	94 e0       	ldi	r25, 0x04	; 4
    ce12:	64 e6       	ldi	r22, 0x64	; 100
    ce14:	70 e0       	ldi	r23, 0x00	; 0
    ce16:	0e 94 b4 4a 	call	0x9568	; 0x9568 <GSM_Execute_Command>
    ce1a:	80 91 b3 06 	lds	r24, 0x06B3
    ce1e:	8f 5f       	subi	r24, 0xFF	; 255
    ce20:	80 93 b3 06 	sts	0x06B3, r24
    ce24:	47 ca       	rjmp	.-2930   	; 0xc2b4 <GSM_Cycle+0x40>
			break;
		case GSM_SEND_CLCC1:
			GSM_Execute_Command(AT_CLCC1,100*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CLCC_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    ce26:	81 ef       	ldi	r24, 0xF1	; 241
    ce28:	93 e0       	ldi	r25, 0x03	; 3
    ce2a:	6a e4       	ldi	r22, 0x4A	; 74
    ce2c:	0e 94 59 4a 	call	0x94b2	; 0x94b2 <GSM_Wait_Response_P>
    ce30:	88 23       	and	r24, r24
    ce32:	09 f4       	brne	.+2      	; 0xce36 <GSM_Cycle+0xbc2>
    ce34:	3f ca       	rjmp	.-2946   	; 0xc2b4 <GSM_Cycle+0x40>
    ce36:	80 91 b3 06 	lds	r24, 0x06B3
    ce3a:	8f 5f       	subi	r24, 0xFF	; 255
    ce3c:	80 93 b3 06 	sts	0x06B3, r24
    ce40:	39 ca       	rjmp	.-2958   	; 0xc2b4 <GSM_Cycle+0x40>
			break;
		case GSM_WAIT_E0_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;
		case GSM_SEND_CLCC1:
			GSM_Execute_Command(AT_CLCC1,100*GSM_DEBUG_DELAY); GSM_State++;
    ce42:	86 e8       	ldi	r24, 0x86	; 134
    ce44:	94 e0       	ldi	r25, 0x04	; 4
    ce46:	64 e6       	ldi	r22, 0x64	; 100
    ce48:	70 e0       	ldi	r23, 0x00	; 0
    ce4a:	0e 94 b4 4a 	call	0x9568	; 0x9568 <GSM_Execute_Command>
    ce4e:	80 91 b3 06 	lds	r24, 0x06B3
    ce52:	8f 5f       	subi	r24, 0xFF	; 255
    ce54:	80 93 b3 06 	sts	0x06B3, r24
    ce58:	2d ca       	rjmp	.-2982   	; 0xc2b4 <GSM_Cycle+0x40>
		//------------------------
		case GSM_SEND_E0:
			GSM_Execute_Command(AT_E0,100*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_E0_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    ce5a:	81 ef       	ldi	r24, 0xF1	; 241
    ce5c:	93 e0       	ldi	r25, 0x03	; 3
    ce5e:	6a e4       	ldi	r22, 0x4A	; 74
    ce60:	0e 94 59 4a 	call	0x94b2	; 0x94b2 <GSM_Wait_Response_P>
    ce64:	88 23       	and	r24, r24
    ce66:	09 f4       	brne	.+2      	; 0xce6a <GSM_Cycle+0xbf6>
    ce68:	25 ca       	rjmp	.-2998   	; 0xc2b4 <GSM_Cycle+0x40>
    ce6a:	80 91 b3 06 	lds	r24, 0x06B3
    ce6e:	8f 5f       	subi	r24, 0xFF	; 255
    ce70:	80 93 b3 06 	sts	0x06B3, r24
    ce74:	1f ca       	rjmp	.-3010   	; 0xc2b4 <GSM_Cycle+0x40>
		case GSM_WAIT_SMS_READY:
			if(GSM_Wait_Response_P(URC_SMS_READY, GSM_ReStart1))GSM_State++;
			break;
		//------------------------
		case GSM_SEND_E0:
			GSM_Execute_Command(AT_E0,100*GSM_DEBUG_DELAY); GSM_State++;
    ce76:	81 e8       	ldi	r24, 0x81	; 129
    ce78:	94 e0       	ldi	r25, 0x04	; 4
    ce7a:	64 e6       	ldi	r22, 0x64	; 100
    ce7c:	70 e0       	ldi	r23, 0x00	; 0
    ce7e:	0e 94 b4 4a 	call	0x9568	; 0x9568 <GSM_Execute_Command>
    ce82:	80 91 b3 06 	lds	r24, 0x06B3
    ce86:	8f 5f       	subi	r24, 0xFF	; 255
    ce88:	80 93 b3 06 	sts	0x06B3, r24
    ce8c:	13 ca       	rjmp	.-3034   	; 0xc2b4 <GSM_Cycle+0x40>
				if(GSM_Modem == SIMCOM_SIM800) GSM_State = GSM_WAIT_SMS_READY;
				else GSM_State = GSM_SEND_E0;
			}
			break;
		case GSM_WAIT_SMS_READY:
			if(GSM_Wait_Response_P(URC_SMS_READY, GSM_ReStart1))GSM_State++;
    ce8e:	8c ea       	ldi	r24, 0xAC	; 172
    ce90:	93 e0       	ldi	r25, 0x03	; 3
    ce92:	6a e4       	ldi	r22, 0x4A	; 74
    ce94:	0e 94 59 4a 	call	0x94b2	; 0x94b2 <GSM_Wait_Response_P>
    ce98:	88 23       	and	r24, r24
    ce9a:	09 f4       	brne	.+2      	; 0xce9e <GSM_Cycle+0xc2a>
    ce9c:	0b ca       	rjmp	.-3050   	; 0xc2b4 <GSM_Cycle+0x40>
    ce9e:	80 91 b3 06 	lds	r24, 0x06B3
    cea2:	8f 5f       	subi	r24, 0xFF	; 255
    cea4:	80 93 b3 06 	sts	0x06B3, r24
    cea8:	05 ca       	rjmp	.-3062   	; 0xc2b4 <GSM_Cycle+0x40>

		case GSM_WAIT_RDY:
			if(GSM_Wait_Response_P(URC_RDY, GSM_ReStart1)) GSM_State++;
			break;
		case GSM_SEND_CGMM:
			GSM_Execute_Command(AT_CGMM,5000*GSM_DEBUG_DELAY); GSM_State++;
    ceaa:	8e e9       	ldi	r24, 0x9E	; 158
    ceac:	94 e0       	ldi	r25, 0x04	; 4
    ceae:	68 e8       	ldi	r22, 0x88	; 136
    ceb0:	73 e1       	ldi	r23, 0x13	; 19
    ceb2:	0e 94 b4 4a 	call	0x9568	; 0x9568 <GSM_Execute_Command>
    ceb6:	80 91 b3 06 	lds	r24, 0x06B3
    ceba:	8f 5f       	subi	r24, 0xFF	; 255
    cebc:	80 93 b3 06 	sts	0x06B3, r24
    cec0:	f9 c9       	rjmp	.-3086   	; 0xc2b4 <GSM_Cycle+0x40>
			GSM_Modem = NOT_RECOGNIZED;
			GSM_State = GSM_WAIT_RDY;
			break;

		case GSM_WAIT_RDY:
			if(GSM_Wait_Response_P(URC_RDY, GSM_ReStart1)) GSM_State++;
    cec2:	87 e8       	ldi	r24, 0x87	; 135
    cec4:	93 e0       	ldi	r25, 0x03	; 3
    cec6:	6a e4       	ldi	r22, 0x4A	; 74
    cec8:	0e 94 59 4a 	call	0x94b2	; 0x94b2 <GSM_Wait_Response_P>
    cecc:	88 23       	and	r24, r24
    cece:	09 f4       	brne	.+2      	; 0xced2 <GSM_Cycle+0xc5e>
    ced0:	f1 c9       	rjmp	.-3102   	; 0xc2b4 <GSM_Cycle+0x40>
    ced2:	80 91 b3 06 	lds	r24, 0x06B3
    ced6:	8f 5f       	subi	r24, 0xFF	; 255
    ced8:	80 93 b3 06 	sts	0x06B3, r24
    cedc:	eb c9       	rjmp	.-3114   	; 0xc2b4 <GSM_Cycle+0x40>
inline static void GSM_Auto(){

	switch(GSM_State){

		case GSM_PowerOn:
			StartTimer16(TD_GSM,1000*GSM_DEBUG_DELAY);
    cede:	80 91 e7 04 	lds	r24, 0x04E7
    cee2:	68 ee       	ldi	r22, 0xE8	; 232
    cee4:	73 e0       	ldi	r23, 0x03	; 3
    cee6:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
			StartTimer32(TD_GSM_Reset, 24UL*60UL*6000);	//    24 
    ceea:	80 91 e9 04 	lds	r24, 0x04E9
    ceee:	40 e0       	ldi	r20, 0x00	; 0
    cef0:	56 ed       	ldi	r21, 0xD6	; 214
    cef2:	63 e8       	ldi	r22, 0x83	; 131
    cef4:	70 e0       	ldi	r23, 0x00	; 0
    cef6:	0e 94 09 1b 	call	0x3612	; 0x3612 <StartTimer32>
			StartTimer32(TD_1hour_resetGPRS_timer, 360000); //     
    cefa:	80 91 eb 04 	lds	r24, 0x04EB
    cefe:	40 e4       	ldi	r20, 0x40	; 64
    cf00:	5e e7       	ldi	r21, 0x7E	; 126
    cf02:	65 e0       	ldi	r22, 0x05	; 5
    cf04:	70 e0       	ldi	r23, 0x00	; 0
    cf06:	0e 94 09 1b 	call	0x3612	; 0x3612 <StartTimer32>
			StartTimer16(TD_CheckModem,6000);//      5 	
    cf0a:	80 91 ec 04 	lds	r24, 0x04EC
    cf0e:	60 e7       	ldi	r22, 0x70	; 112
    cf10:	77 e1       	ldi	r23, 0x17	; 23
    cf12:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
	}
	void GSM_PWRCNTRL_ON(void){
		cli();
    cf16:	f8 94       	cli
		PORTL &= ~(1<<PL5);
    cf18:	80 91 0b 01 	lds	r24, 0x010B
    cf1c:	8f 7d       	andi	r24, 0xDF	; 223
    cf1e:	80 93 0b 01 	sts	0x010B, r24
		sei();
    cf22:	78 94       	sei
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    cf24:	8f ef       	ldi	r24, 0xFF	; 255
    cf26:	80 93 fa 06 	sts	0x06FA, r24
	GSM_RX_FIFO_End = 255;
    cf2a:	80 93 51 06 	sts	0x0651, r24
	GSM_RxCharN = 0;
    cf2e:	10 92 18 0b 	sts	0x0B18, r1
	GSM_RX_FIFOOverFlow = 0;
    cf32:	10 92 cb 08 	sts	0x08CB, r1
	GSM_RX_FIFOMax = 0;
    cf36:	10 92 d1 08 	sts	0x08D1, r1
			StartTimer32(TD_GSM_Reset, 24UL*60UL*6000);	//    24 
			StartTimer32(TD_1hour_resetGPRS_timer, 360000); //     
			StartTimer16(TD_CheckModem,6000);//      5 	
			GSM_PWRCNTRL_ON();
			InitFIFO();
			counter=0;
    cf3a:	10 92 e0 02 	sts	0x02E0, r1
			GSM_Modem = NOT_RECOGNIZED;
    cf3e:	10 92 f1 06 	sts	0x06F1, r1
			GSM_State = GSM_WAIT_RDY;
    cf42:	81 e0       	ldi	r24, 0x01	; 1
    cf44:	80 93 b3 06 	sts	0x06B3, r24
    cf48:	b5 c9       	rjmp	.-3222   	; 0xc2b4 <GSM_Cycle+0x40>
		case GSM_WAIT_CPIN_READY:
			if(GSM_Wait_Response_P(URC_CPIN_READY, GSM_ReStart1)) GSM_State++;
			break;

		case GSM_WAIT_CALL_READY:
			if(GSM_Wait_Response_P(URC_CALL_READY, GSM_ReStart1)){
    cf4a:	81 ea       	ldi	r24, 0xA1	; 161
    cf4c:	93 e0       	ldi	r25, 0x03	; 3
    cf4e:	6a e4       	ldi	r22, 0x4A	; 74
    cf50:	0e 94 59 4a 	call	0x94b2	; 0x94b2 <GSM_Wait_Response_P>
    cf54:	88 23       	and	r24, r24
    cf56:	09 f4       	brne	.+2      	; 0xcf5a <GSM_Cycle+0xce6>
    cf58:	ad c9       	rjmp	.-3238   	; 0xc2b4 <GSM_Cycle+0x40>
				if(GSM_Modem == SIMCOM_SIM800) GSM_State = GSM_WAIT_SMS_READY;
    cf5a:	80 91 f1 06 	lds	r24, 0x06F1
    cf5e:	82 30       	cpi	r24, 0x02	; 2
    cf60:	09 f4       	brne	.+2      	; 0xcf64 <GSM_Cycle+0xcf0>
    cf62:	3d c6       	rjmp	.+3194   	; 0xdbde <GSM_Cycle+0x196a>
				else GSM_State = GSM_SEND_E0;
    cf64:	88 e0       	ldi	r24, 0x08	; 8
    cf66:	80 93 b3 06 	sts	0x06B3, r24
    cf6a:	a4 c9       	rjmp	.-3256   	; 0xc2b4 <GSM_Cycle+0x40>
			}
		case GSM_WAIT_CFUN:
			if(GSM_Wait_Response_P(URC_CFUN, GSM_ReStart1)) GSM_State++;
			break;
		case GSM_WAIT_CPIN_READY:
			if(GSM_Wait_Response_P(URC_CPIN_READY, GSM_ReStart1)) GSM_State++;
    cf6c:	84 e9       	ldi	r24, 0x94	; 148
    cf6e:	93 e0       	ldi	r25, 0x03	; 3
    cf70:	6a e4       	ldi	r22, 0x4A	; 74
    cf72:	0e 94 59 4a 	call	0x94b2	; 0x94b2 <GSM_Wait_Response_P>
    cf76:	88 23       	and	r24, r24
    cf78:	09 f4       	brne	.+2      	; 0xcf7c <GSM_Cycle+0xd08>
    cf7a:	9c c9       	rjmp	.-3272   	; 0xc2b4 <GSM_Cycle+0x40>
    cf7c:	80 91 b3 06 	lds	r24, 0x06B3
    cf80:	8f 5f       	subi	r24, 0xFF	; 255
    cf82:	80 93 b3 06 	sts	0x06B3, r24
    cf86:	96 c9       	rjmp	.-3284   	; 0xc2b4 <GSM_Cycle+0x40>
			}
			break;

		//------------------------
		case GSM_WAIT_1:
			GetStringFromFIFO();		//     FIFO
    cf88:	0e 94 80 38 	call	0x7100	; 0x7100 <GetStringFromFIFO>
			if(Timer16Stopp(TD_GSM)){
    cf8c:	80 91 e7 04 	lds	r24, 0x04E7
    cf90:	0e 94 06 1c 	call	0x380c	; 0x380c <Timer16Stopp>
    cf94:	88 23       	and	r24, r24
    cf96:	09 f4       	brne	.+2      	; 0xcf9a <GSM_Cycle+0xd26>
    cf98:	8d c9       	rjmp	.-3302   	; 0xc2b4 <GSM_Cycle+0x40>
				GSM_State++;
    cf9a:	80 91 b3 06 	lds	r24, 0x06B3
    cf9e:	8f 5f       	subi	r24, 0xFF	; 255
    cfa0:	80 93 b3 06 	sts	0x06B3, r24
				GSM_Temp = 0;
    cfa4:	10 92 d9 05 	sts	0x05D9, r1
    cfa8:	85 c9       	rjmp	.-3318   	; 0xc2b4 <GSM_Cycle+0x40>
			if(GSM_MultiCon) GSM_Execute_Command(AT_CIPMODE_0, 100*GSM_DEBUG_DELAY);
			else GSM_Execute_Command(AT_CIPMODE_1, 100*GSM_DEBUG_DELAY);
			GSM_State++;
			break;
		case GSM_WAIT_CIPMODE_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    cfaa:	81 ef       	ldi	r24, 0xF1	; 241
    cfac:	93 e0       	ldi	r25, 0x03	; 3
    cfae:	6a e4       	ldi	r22, 0x4A	; 74
    cfb0:	0e 94 59 4a 	call	0x94b2	; 0x94b2 <GSM_Wait_Response_P>
    cfb4:	88 23       	and	r24, r24
    cfb6:	09 f4       	brne	.+2      	; 0xcfba <GSM_Cycle+0xd46>
    cfb8:	7d c9       	rjmp	.-3334   	; 0xc2b4 <GSM_Cycle+0x40>
				GSM_State++;
    cfba:	80 91 b3 06 	lds	r24, 0x06B3
    cfbe:	8f 5f       	subi	r24, 0xFF	; 255
    cfc0:	80 93 b3 06 	sts	0x06B3, r24
				// between "Call Ready" and "+CMGS"; 8 sec min needs; for kyivstar vpni only
				StartTimer16(TD_GSM, 1000);
    cfc4:	80 91 e7 04 	lds	r24, 0x04E7
    cfc8:	68 ee       	ldi	r22, 0xE8	; 232
    cfca:	73 e0       	ldi	r23, 0x03	; 3
    cfcc:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
    cfd0:	71 c9       	rjmp	.-3358   	; 0xc2b4 <GSM_Cycle+0x40>
				}
				else GSM_State++;
			}
			break;
		case GSM_SEND_CIPMODE:
			if(GSM_MultiCon) GSM_Execute_Command(AT_CIPMODE_0, 100*GSM_DEBUG_DELAY);
    cfd2:	80 91 2b 0c 	lds	r24, 0x0C2B
    cfd6:	88 23       	and	r24, r24
    cfd8:	09 f4       	brne	.+2      	; 0xcfdc <GSM_Cycle+0xd68>
    cfda:	4b c4       	rjmp	.+2198   	; 0xd872 <GSM_Cycle+0x15fe>
    cfdc:	8b ef       	ldi	r24, 0xFB	; 251
    cfde:	94 e0       	ldi	r25, 0x04	; 4
    cfe0:	64 e6       	ldi	r22, 0x64	; 100
    cfe2:	70 e0       	ldi	r23, 0x00	; 0
    cfe4:	0e 94 b4 4a 	call	0x9568	; 0x9568 <GSM_Execute_Command>
			else GSM_Execute_Command(AT_CIPMODE_1, 100*GSM_DEBUG_DELAY);
			GSM_State++;
    cfe8:	80 91 b3 06 	lds	r24, 0x06B3
    cfec:	8f 5f       	subi	r24, 0xFF	; 255
    cfee:	80 93 b3 06 	sts	0x06B3, r24
    cff2:	60 c9       	rjmp	.-3392   	; 0xc2b4 <GSM_Cycle+0x40>
			if(GSM_MultiCon) GSM_Execute_Command(AT_CIPMUX_1, 100*GSM_DEBUG_DELAY);
			else GSM_Execute_Command(AT_CIPMUX_0, 100*GSM_DEBUG_DELAY);
			GSM_State++; 
			break;
		case GSM_WAIT_CIPMUX_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    cff4:	81 ef       	ldi	r24, 0xF1	; 241
    cff6:	93 e0       	ldi	r25, 0x03	; 3
    cff8:	6a e4       	ldi	r22, 0x4A	; 74
    cffa:	0e 94 59 4a 	call	0x94b2	; 0x94b2 <GSM_Wait_Response_P>
    cffe:	88 23       	and	r24, r24
    d000:	09 f4       	brne	.+2      	; 0xd004 <GSM_Cycle+0xd90>
    d002:	58 c9       	rjmp	.-3408   	; 0xc2b4 <GSM_Cycle+0x40>
				if(GSM_MultiCon){
    d004:	80 91 2b 0c 	lds	r24, 0x0C2B
    d008:	88 23       	and	r24, r24
    d00a:	09 f0       	breq	.+2      	; 0xd00e <GSM_Cycle+0xd9a>
    d00c:	dd c5       	rjmp	.+3002   	; 0xdbc8 <GSM_Cycle+0x1954>
					GSM_State = GSM_WAIT_1;
					// between "Call Ready" and "+CMGS"; 8 sec min needs; for kyivstar vpni only
					StartTimer16(TD_GSM, 1000);
				}
				else GSM_State++;
    d00e:	80 91 b3 06 	lds	r24, 0x06B3
    d012:	8f 5f       	subi	r24, 0xFF	; 255
    d014:	80 93 b3 06 	sts	0x06B3, r24
    d018:	4d c9       	rjmp	.-3430   	; 0xc2b4 <GSM_Cycle+0x40>
		case GSM_WAIT_CSMP_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State=GSM_SEND_ATD_Check_Ballance;
			break;
		//------------------------
		case GSM_SEND_CIPMUX:
			if(GSM_MultiCon) GSM_Execute_Command(AT_CIPMUX_1, 100*GSM_DEBUG_DELAY);
    d01a:	80 91 2b 0c 	lds	r24, 0x0C2B
    d01e:	88 23       	and	r24, r24
    d020:	09 f4       	brne	.+2      	; 0xd024 <GSM_Cycle+0xdb0>
    d022:	20 c4       	rjmp	.+2112   	; 0xd864 <GSM_Cycle+0x15f0>
    d024:	81 e2       	ldi	r24, 0x21	; 33
    d026:	95 e0       	ldi	r25, 0x05	; 5
    d028:	64 e6       	ldi	r22, 0x64	; 100
    d02a:	70 e0       	ldi	r23, 0x00	; 0
    d02c:	0e 94 b4 4a 	call	0x9568	; 0x9568 <GSM_Execute_Command>
			else GSM_Execute_Command(AT_CIPMUX_0, 100*GSM_DEBUG_DELAY);
			GSM_State++; 
    d030:	80 91 b3 06 	lds	r24, 0x06B3
    d034:	8f 5f       	subi	r24, 0xFF	; 255
    d036:	80 93 b3 06 	sts	0x06B3, r24
    d03a:	3c c9       	rjmp	.-3464   	; 0xc2b4 <GSM_Cycle+0x40>
			break;
		case GSM_WAIT_CMGF_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;
		case GSM_SEND_CSMP:
			GSM_Execute_Command(AT_CSMP, 100*GSM_DEBUG_DELAY); GSM_State++;
    d03c:	8d ed       	ldi	r24, 0xDD	; 221
    d03e:	94 e0       	ldi	r25, 0x04	; 4
    d040:	64 e6       	ldi	r22, 0x64	; 100
    d042:	70 e0       	ldi	r23, 0x00	; 0
    d044:	0e 94 b4 4a 	call	0x9568	; 0x9568 <GSM_Execute_Command>
    d048:	80 91 b3 06 	lds	r24, 0x06B3
    d04c:	8f 5f       	subi	r24, 0xFF	; 255
    d04e:	80 93 b3 06 	sts	0x06B3, r24
    d052:	30 c9       	rjmp	.-3488   	; 0xc2b4 <GSM_Cycle+0x40>
			break;
		case GSM_WAIT_CSMP_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State=GSM_SEND_ATD_Check_Ballance;
    d054:	81 ef       	ldi	r24, 0xF1	; 241
    d056:	93 e0       	ldi	r25, 0x03	; 3
    d058:	6a e4       	ldi	r22, 0x4A	; 74
    d05a:	0e 94 59 4a 	call	0x94b2	; 0x94b2 <GSM_Wait_Response_P>
    d05e:	88 23       	and	r24, r24
    d060:	09 f4       	brne	.+2      	; 0xd064 <GSM_Cycle+0xdf0>
    d062:	28 c9       	rjmp	.-3504   	; 0xc2b4 <GSM_Cycle+0x40>
    d064:	8c e4       	ldi	r24, 0x4C	; 76
    d066:	80 93 b3 06 	sts	0x06B3, r24
    d06a:	24 c9       	rjmp	.-3512   	; 0xc2b4 <GSM_Cycle+0x40>
///------------------------ / (  )
		case GSM_SEND_CMGF:
			GSM_Execute_Command(AT_CMGF,100*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CMGF_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    d06c:	81 ef       	ldi	r24, 0xF1	; 241
    d06e:	93 e0       	ldi	r25, 0x03	; 3
    d070:	6a e4       	ldi	r22, 0x4A	; 74
    d072:	0e 94 59 4a 	call	0x94b2	; 0x94b2 <GSM_Wait_Response_P>
    d076:	88 23       	and	r24, r24
    d078:	09 f4       	brne	.+2      	; 0xd07c <GSM_Cycle+0xe08>
    d07a:	1c c9       	rjmp	.-3528   	; 0xc2b4 <GSM_Cycle+0x40>
    d07c:	80 91 b3 06 	lds	r24, 0x06B3
    d080:	8f 5f       	subi	r24, 0xFF	; 255
    d082:	80 93 b3 06 	sts	0x06B3, r24
    d086:	16 c9       	rjmp	.-3540   	; 0xc2b4 <GSM_Cycle+0x40>



///------------------------ / (  )
		case GSM_SEND_CMGF:
			GSM_Execute_Command(AT_CMGF,100*GSM_DEBUG_DELAY); GSM_State++;
    d088:	83 ed       	ldi	r24, 0xD3	; 211
    d08a:	94 e0       	ldi	r25, 0x04	; 4
    d08c:	64 e6       	ldi	r22, 0x64	; 100
    d08e:	70 e0       	ldi	r23, 0x00	; 0
    d090:	0e 94 b4 4a 	call	0x9568	; 0x9568 <GSM_Execute_Command>
    d094:	80 91 b3 06 	lds	r24, 0x06B3
    d098:	8f 5f       	subi	r24, 0xFF	; 255
    d09a:	80 93 b3 06 	sts	0x06B3, r24
    d09e:	0a c9       	rjmp	.-3564   	; 0xc2b4 <GSM_Cycle+0x40>
			if(Timer16Stopp(TD_GSM)){
				GSM_State = GSM_WAIT_MESSAGE;
			}
			break;
		case GSM_WAIT_DISCONNECT_CAUSE:
			if(GetStringFromFIFO()){
    d0a0:	0e 94 80 38 	call	0x7100	; 0x7100 <GetStringFromFIFO>
    d0a4:	88 23       	and	r24, r24
    d0a6:	09 f4       	brne	.+2      	; 0xd0aa <GSM_Cycle+0xe36>
    d0a8:	eb c3       	rjmp	.+2006   	; 0xd880 <GSM_Cycle+0x160c>
				if((strstr_P(GSM_RxStr, PSTR("OK")) != NULL) ){
    d0aa:	89 e9       	ldi	r24, 0x99	; 153
    d0ac:	97 e0       	ldi	r25, 0x07	; 7
    d0ae:	6e e2       	ldi	r22, 0x2E	; 46
    d0b0:	7c e2       	ldi	r23, 0x2C	; 44
    d0b2:	0e 94 e3 7e 	call	0xfdc6	; 0xfdc6 <strstr_P>
    d0b6:	89 2b       	or	r24, r25
    d0b8:	09 f4       	brne	.+2      	; 0xd0bc <GSM_Cycle+0xe48>
    d0ba:	37 c6       	rjmp	.+3182   	; 0xdd2a <GSM_Cycle+0x1ab6>
					GSM_State = GSM_WAIT_MESSAGE;
    d0bc:	8e e0       	ldi	r24, 0x0E	; 14
    d0be:	80 93 b3 06 	sts	0x06B3, r24
    d0c2:	f8 c8       	rjmp	.-3600   	; 0xc2b4 <GSM_Cycle+0x40>
			GSM_SendFirstChar();
			GSM_State = GSM_WAIT_CCLC_6;
			StartTimer16(TD_GSM, 1000);
			break;	
		case GSM_WAIT_CCLC_6:
			if(GetStringFromFIFO()){
    d0c4:	0e 94 80 38 	call	0x7100	; 0x7100 <GetStringFromFIFO>
    d0c8:	88 23       	and	r24, r24
    d0ca:	09 f4       	brne	.+2      	; 0xd0ce <GSM_Cycle+0xe5a>
    d0cc:	2a c3       	rjmp	.+1620   	; 0xd722 <GSM_Cycle+0x14ae>
				if((strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6,")) != NULL) ){
    d0ce:	89 e9       	ldi	r24, 0x99	; 153
    d0d0:	97 e0       	ldi	r25, 0x07	; 7
    d0d2:	61 e3       	ldi	r22, 0x31	; 49
    d0d4:	7c e2       	ldi	r23, 0x2C	; 44
    d0d6:	0e 94 e3 7e 	call	0xfdc6	; 0xfdc6 <strstr_P>
    d0da:	89 2b       	or	r24, r25
    d0dc:	09 f4       	brne	.+2      	; 0xd0e0 <GSM_Cycle+0xe6c>
    d0de:	21 c3       	rjmp	.+1602   	; 0xd722 <GSM_Cycle+0x14ae>
					GSM_State = GSM_WAIT_DISCONNECT_CAUSE;
    d0e0:	85 e2       	ldi	r24, 0x25	; 37
    d0e2:	80 93 b3 06 	sts	0x06B3, r24
					StartTimer16(TD_GSM, 10000);
    d0e6:	80 91 e7 04 	lds	r24, 0x04E7
    d0ea:	60 e1       	ldi	r22, 0x10	; 16
    d0ec:	77 e2       	ldi	r23, 0x27	; 39
    d0ee:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
    d0f2:	e0 c8       	rjmp	.-3648   	; 0xc2b4 <GSM_Cycle+0x40>
				GSM_State = GSM_SEND_ATH;
				StartTimer16(TD_GSM, 10000);
			}
			break;	
		case GSM_SEND_ATH:
			sprintf_P(GSM_TxStr, PSTR("ATH\r"));
    d0f4:	00 d0       	rcall	.+0      	; 0xd0f6 <GSM_Cycle+0xe82>
    d0f6:	0f 92       	push	r0
    d0f8:	82 e0       	ldi	r24, 0x02	; 2
    d0fa:	9a e0       	ldi	r25, 0x0A	; 10
    d0fc:	ed b7       	in	r30, 0x3d	; 61
    d0fe:	fe b7       	in	r31, 0x3e	; 62
    d100:	92 83       	std	Z+2, r25	; 0x02
    d102:	81 83       	std	Z+1, r24	; 0x01
    d104:	8f e3       	ldi	r24, 0x3F	; 63
    d106:	9c e2       	ldi	r25, 0x2C	; 44
    d108:	94 83       	std	Z+4, r25	; 0x04
    d10a:	83 83       	std	Z+3, r24	; 0x03
    d10c:	0e 94 de 7f 	call	0xffbc	; 0xffbc <sprintf_P>
			GSMTxSz = 4;
    d110:	84 e0       	ldi	r24, 0x04	; 4
    d112:	80 93 75 07 	sts	0x0775, r24
			GSM_SendFirstChar();
    d116:	0f 90       	pop	r0
    d118:	0f 90       	pop	r0
    d11a:	0f 90       	pop	r0
    d11c:	0f 90       	pop	r0
    d11e:	0e 94 aa 39 	call	0x7354	; 0x7354 <GSM_SendFirstChar>
			GSM_State = GSM_WAIT_CCLC_6;
    d122:	84 e2       	ldi	r24, 0x24	; 36
    d124:	80 93 b3 06 	sts	0x06B3, r24
			StartTimer16(TD_GSM, 1000);
    d128:	80 91 e7 04 	lds	r24, 0x04E7
    d12c:	68 ee       	ldi	r22, 0xE8	; 232
    d12e:	73 e0       	ldi	r23, 0x03	; 3
    d130:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
    d134:	bf c8       	rjmp	.-3714   	; 0xc2b4 <GSM_Cycle+0x40>
					GSM_State = GSM_WAIT_PLAY_NOTCONFIRM_FILE_CREC_0;
					StartTimer16(TD_GSM, 20000);
				}
			break;
		case GSM_WAIT_PLAY_NOTCONFIRM_FILE_CREC_0:
			if(GSM_Wait_Response_P(RESP_CREC_0, GSM_SEND_ATD)) 
    d136:	81 e5       	ldi	r24, 0x51	; 81
    d138:	94 e0       	ldi	r25, 0x04	; 4
    d13a:	6f e0       	ldi	r22, 0x0F	; 15
    d13c:	0e 94 59 4a 	call	0x94b2	; 0x94b2 <GSM_Wait_Response_P>
    d140:	88 23       	and	r24, r24
    d142:	09 f4       	brne	.+2      	; 0xd146 <GSM_Cycle+0xed2>
    d144:	b7 c8       	rjmp	.-3730   	; 0xc2b4 <GSM_Cycle+0x40>
			{
				GSM_State = GSM_SEND_ATH;
    d146:	83 e2       	ldi	r24, 0x23	; 35
    d148:	80 93 b3 06 	sts	0x06B3, r24
				StartTimer16(TD_GSM, 10000);
    d14c:	80 91 e7 04 	lds	r24, 0x04E7
    d150:	60 e1       	ldi	r22, 0x10	; 16
    d152:	77 e2       	ldi	r23, 0x27	; 39
    d154:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
    d158:	ad c8       	rjmp	.-3750   	; 0xc2b4 <GSM_Cycle+0x40>
			GSM_SendFirstChar();
			GSM_State = GSM_WAIT_PLAY_NOTCONFIRM_FILE_OK;
			StartTimer16(TD_GSM, 1000);
			break;
		case GSM_WAIT_PLAY_NOTCONFIRM_FILE_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_WAIT_PLAY_NOTCONFIRM_FILE_OK)) 
    d15a:	81 ef       	ldi	r24, 0xF1	; 241
    d15c:	93 e0       	ldi	r25, 0x03	; 3
    d15e:	61 e2       	ldi	r22, 0x21	; 33
    d160:	0e 94 59 4a 	call	0x94b2	; 0x94b2 <GSM_Wait_Response_P>
    d164:	88 23       	and	r24, r24
    d166:	09 f4       	brne	.+2      	; 0xd16a <GSM_Cycle+0xef6>
    d168:	a5 c8       	rjmp	.-3766   	; 0xc2b4 <GSM_Cycle+0x40>
				{
					GSM_State = GSM_WAIT_PLAY_NOTCONFIRM_FILE_CREC_0;
    d16a:	82 e2       	ldi	r24, 0x22	; 34
    d16c:	80 93 b3 06 	sts	0x06B3, r24
					StartTimer16(TD_GSM, 20000);
    d170:	80 91 e7 04 	lds	r24, 0x04E7
    d174:	60 e2       	ldi	r22, 0x20	; 32
    d176:	7e e4       	ldi	r23, 0x4E	; 78
    d178:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
    d17c:	9b c8       	rjmp	.-3786   	; 0xc2b4 <GSM_Cycle+0x40>
				GSM_State = GSM_SEND_ATH;
				StartTimer16(TD_GSM, 10000);
			}
			break;
		case GSM_SEND_PLAY_NOTCONFIRM_FILE: 
			sprintf_P(GSM_TxStr, PSTR("AT+CREC=4,\"C:\\User\\NotConfirm.amr\",0,100\r"));
    d17e:	00 d0       	rcall	.+0      	; 0xd180 <GSM_Cycle+0xf0c>
    d180:	0f 92       	push	r0
    d182:	82 e0       	ldi	r24, 0x02	; 2
    d184:	9a e0       	ldi	r25, 0x0A	; 10
    d186:	ad b7       	in	r26, 0x3d	; 61
    d188:	be b7       	in	r27, 0x3e	; 62
    d18a:	12 96       	adiw	r26, 0x02	; 2
    d18c:	9c 93       	st	X, r25
    d18e:	8e 93       	st	-X, r24
    d190:	11 97       	sbiw	r26, 0x01	; 1
    d192:	84 e4       	ldi	r24, 0x44	; 68
    d194:	9c e2       	ldi	r25, 0x2C	; 44
    d196:	14 96       	adiw	r26, 0x04	; 4
    d198:	9c 93       	st	X, r25
    d19a:	8e 93       	st	-X, r24
    d19c:	13 97       	sbiw	r26, 0x03	; 3
    d19e:	0e 94 de 7f 	call	0xffbc	; 0xffbc <sprintf_P>
			GSMTxSz = 41;
    d1a2:	89 e2       	ldi	r24, 0x29	; 41
    d1a4:	80 93 75 07 	sts	0x0775, r24
			GSM_SendFirstChar();
    d1a8:	0f 90       	pop	r0
    d1aa:	0f 90       	pop	r0
    d1ac:	0f 90       	pop	r0
    d1ae:	0f 90       	pop	r0
    d1b0:	0e 94 aa 39 	call	0x7354	; 0x7354 <GSM_SendFirstChar>
			GSM_State = GSM_WAIT_PLAY_NOTCONFIRM_FILE_OK;
    d1b4:	81 e2       	ldi	r24, 0x21	; 33
    d1b6:	80 93 b3 06 	sts	0x06B3, r24
			StartTimer16(TD_GSM, 1000);
    d1ba:	80 91 e7 04 	lds	r24, 0x04E7
    d1be:	68 ee       	ldi	r22, 0xE8	; 232
    d1c0:	73 e0       	ldi	r23, 0x03	; 3
    d1c2:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
    d1c6:	76 c8       	rjmp	.-3860   	; 0xc2b4 <GSM_Cycle+0x40>
					GSM_State = GSM_WAIT_PLAY_CONFIRM_FILE_CREC_0;
					StartTimer16(TD_GSM, 20000);
				}
			break;
		case GSM_WAIT_PLAY_CONFIRM_FILE_CREC_0:
			if(GSM_Wait_Response_P(RESP_CREC_0, GSM_SEND_ATD)) 
    d1c8:	81 e5       	ldi	r24, 0x51	; 81
    d1ca:	94 e0       	ldi	r25, 0x04	; 4
    d1cc:	6f e0       	ldi	r22, 0x0F	; 15
    d1ce:	0e 94 59 4a 	call	0x94b2	; 0x94b2 <GSM_Wait_Response_P>
    d1d2:	88 23       	and	r24, r24
    d1d4:	09 f4       	brne	.+2      	; 0xd1d8 <GSM_Cycle+0xf64>
    d1d6:	6e c8       	rjmp	.-3876   	; 0xc2b4 <GSM_Cycle+0x40>
			{
				GSM_State = GSM_SEND_ATH;
    d1d8:	83 e2       	ldi	r24, 0x23	; 35
    d1da:	80 93 b3 06 	sts	0x06B3, r24
				StartTimer16(TD_GSM, 10000);
    d1de:	80 91 e7 04 	lds	r24, 0x04E7
    d1e2:	60 e1       	ldi	r22, 0x10	; 16
    d1e4:	77 e2       	ldi	r23, 0x27	; 39
    d1e6:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
    d1ea:	64 c8       	rjmp	.-3896   	; 0xc2b4 <GSM_Cycle+0x40>

		case GSM_SEND_CSTT:
			GSM_Execute_Command(AT_CSTT, 300*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CSTT_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    d1ec:	81 ef       	ldi	r24, 0xF1	; 241
    d1ee:	93 e0       	ldi	r25, 0x03	; 3
    d1f0:	6a e4       	ldi	r22, 0x4A	; 74
    d1f2:	0e 94 59 4a 	call	0x94b2	; 0x94b2 <GSM_Wait_Response_P>
    d1f6:	88 23       	and	r24, r24
    d1f8:	09 f4       	brne	.+2      	; 0xd1fc <GSM_Cycle+0xf88>
    d1fa:	5c c8       	rjmp	.-3912   	; 0xc2b4 <GSM_Cycle+0x40>
    d1fc:	80 91 b3 06 	lds	r24, 0x06B3
    d200:	8f 5f       	subi	r24, 0xFF	; 255
    d202:	80 93 b3 06 	sts	0x06B3, r24
    d206:	56 c8       	rjmp	.-3924   	; 0xc2b4 <GSM_Cycle+0x40>
		case GSM_WAIT_CIPTKA_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;

		case GSM_SEND_CSTT:
			GSM_Execute_Command(AT_CSTT, 300*GSM_DEBUG_DELAY); GSM_State++;
    d208:	87 e4       	ldi	r24, 0x47	; 71
    d20a:	95 e0       	ldi	r25, 0x05	; 5
    d20c:	6c e2       	ldi	r22, 0x2C	; 44
    d20e:	71 e0       	ldi	r23, 0x01	; 1
    d210:	0e 94 b4 4a 	call	0x9568	; 0x9568 <GSM_Execute_Command>
    d214:	80 91 b3 06 	lds	r24, 0x06B3
    d218:	8f 5f       	subi	r24, 0xFF	; 255
    d21a:	80 93 b3 06 	sts	0x06B3, r24
    d21e:	4a c8       	rjmp	.-3948   	; 0xc2b4 <GSM_Cycle+0x40>

		case GSM_SEND_CIPTKA:
			GSM_Execute_Command(AT_CIPTKA, 1000*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CIPTKA_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    d220:	81 ef       	ldi	r24, 0xF1	; 241
    d222:	93 e0       	ldi	r25, 0x03	; 3
    d224:	6a e4       	ldi	r22, 0x4A	; 74
    d226:	0e 94 59 4a 	call	0x94b2	; 0x94b2 <GSM_Wait_Response_P>
    d22a:	88 23       	and	r24, r24
    d22c:	09 f4       	brne	.+2      	; 0xd230 <GSM_Cycle+0xfbc>
    d22e:	42 c8       	rjmp	.-3964   	; 0xc2b4 <GSM_Cycle+0x40>
    d230:	80 91 b3 06 	lds	r24, 0x06B3
    d234:	8f 5f       	subi	r24, 0xFF	; 255
    d236:	80 93 b3 06 	sts	0x06B3, r24
    d23a:	3c c8       	rjmp	.-3976   	; 0xc2b4 <GSM_Cycle+0x40>
			 else GSM_State=GSM_SEND_CSTT;
			 }
			break;

		case GSM_SEND_CIPTKA:
			GSM_Execute_Command(AT_CIPTKA, 1000*GSM_DEBUG_DELAY); GSM_State++;
    d23c:	81 e6       	ldi	r24, 0x61	; 97
    d23e:	95 e0       	ldi	r25, 0x05	; 5
    d240:	68 ee       	ldi	r22, 0xE8	; 232
    d242:	73 e0       	ldi	r23, 0x03	; 3
    d244:	0e 94 b4 4a 	call	0x9568	; 0x9568 <GSM_Execute_Command>
    d248:	80 91 b3 06 	lds	r24, 0x06B3
    d24c:	8f 5f       	subi	r24, 0xFF	; 255
    d24e:	80 93 b3 06 	sts	0x06B3, r24
    d252:	30 c8       	rjmp	.-4000   	; 0xc2b4 <GSM_Cycle+0x40>
				StartTimer16(TD_GSM, 300*GSM_DEBUG_DELAY);
			}
			GSM_State++;
			break;
		case GSM_WAIT_CIPCSGP_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    d254:	81 ef       	ldi	r24, 0xF1	; 241
    d256:	93 e0       	ldi	r25, 0x03	; 3
    d258:	6a e4       	ldi	r22, 0x4A	; 74
    d25a:	0e 94 59 4a 	call	0x94b2	; 0x94b2 <GSM_Wait_Response_P>
    d25e:	88 23       	and	r24, r24
    d260:	09 f4       	brne	.+2      	; 0xd264 <GSM_Cycle+0xff0>
    d262:	28 c8       	rjmp	.-4016   	; 0xc2b4 <GSM_Cycle+0x40>
			 if(GSM_Modem == SIMCOM_SIM800)GSM_State++;
    d264:	80 91 f1 06 	lds	r24, 0x06F1
    d268:	82 30       	cpi	r24, 0x02	; 2
    d26a:	09 f4       	brne	.+2      	; 0xd26e <GSM_Cycle+0xffa>
    d26c:	a6 c4       	rjmp	.+2380   	; 0xdbba <GSM_Cycle+0x1946>
			 else GSM_State=GSM_SEND_CSTT;
    d26e:	85 e3       	ldi	r24, 0x35	; 53
    d270:	80 93 b3 06 	sts	0x06B3, r24
    d274:	1f c8       	rjmp	.-4034   	; 0xc2b4 <GSM_Cycle+0x40>
			if(GSM_Wait_Response_P(RESP_OK, GSM_SEND_CGATT)) GSM_State++;
			break;

		case GSM_SEND_CIPCSGP:
			//GSM_Execute_Command(AT_CIPCSGP, 300*GSM_DEBUG_DELAY); GSM_State++;
			if(GSM_Flag & (1<<flg_TxCStr)){
    d276:	80 91 d2 02 	lds	r24, 0x02D2
    d27a:	80 fd       	sbrc	r24, 0
    d27c:	9e c3       	rjmp	.+1852   	; 0xd9ba <GSM_Cycle+0x1746>
				GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn_psw);
				sprintf(GSM_TxStr + GSMTxSz, "\"\r");	GSMTxSz = GSMTxSz+2;
				GSM_SendFirstChar();
				StartTimer16(TD_GSM, 300*GSM_DEBUG_DELAY);
			}
			GSM_State++;
    d27e:	80 91 b3 06 	lds	r24, 0x06B3
    d282:	8f 5f       	subi	r24, 0xFF	; 255
    d284:	80 93 b3 06 	sts	0x06B3, r24
    d288:	15 c8       	rjmp	.-4054   	; 0xc2b4 <GSM_Cycle+0x40>
			break;
		case GSM_SEND_CGATT:
			GSM_Execute_Command(AT_CGATT, 500*GSM_DEBUG_DELAY); GSM_Temp++; GSM_State++;
			break;
		case GSM_WAIT_CGATT_OK:
			if(GSM_Temp>20) GSM_State = GSM_ReStart1;
    d28a:	80 91 d9 05 	lds	r24, 0x05D9
    d28e:	85 31       	cpi	r24, 0x15	; 21
    d290:	18 f0       	brcs	.+6      	; 0xd298 <GSM_Cycle+0x1024>
    d292:	8a e4       	ldi	r24, 0x4A	; 74
    d294:	80 93 b3 06 	sts	0x06B3, r24
			if(GSM_Wait_Response_P(RESP_OK, GSM_SEND_CGATT)) GSM_State++;
    d298:	81 ef       	ldi	r24, 0xF1	; 241
    d29a:	93 e0       	ldi	r25, 0x03	; 3
    d29c:	6f e2       	ldi	r22, 0x2F	; 47
    d29e:	0e 94 59 4a 	call	0x94b2	; 0x94b2 <GSM_Wait_Response_P>
    d2a2:	88 23       	and	r24, r24
    d2a4:	11 f4       	brne	.+4      	; 0xd2aa <GSM_Cycle+0x1036>
    d2a6:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
    d2aa:	80 91 b3 06 	lds	r24, 0x06B3
    d2ae:	8f 5f       	subi	r24, 0xFF	; 255
    d2b0:	80 93 b3 06 	sts	0x06B3, r24
    d2b4:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>

		case GSM_SEND_CIFSR:
			GSM_Execute_Command(AT_CIFSR, 1000*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CIFSR_OK:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
    d2b8:	80 91 e7 04 	lds	r24, 0x04E7
    d2bc:	0e 94 06 1c 	call	0x380c	; 0x380c <Timer16Stopp>
    d2c0:	88 23       	and	r24, r24
    d2c2:	19 f0       	breq	.+6      	; 0xd2ca <GSM_Cycle+0x1056>
    d2c4:	8a e4       	ldi	r24, 0x4A	; 74
    d2c6:	80 93 b3 06 	sts	0x06B3, r24
			if(GetStringFromFIFO()){
    d2ca:	0e 94 80 38 	call	0x7100	; 0x7100 <GetStringFromFIFO>
    d2ce:	88 23       	and	r24, r24
    d2d0:	11 f4       	brne	.+4      	; 0xd2d6 <GSM_Cycle+0x1062>
    d2d2:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
	uint8_t IP4;
} IP_Addr;

//~~~~~~~~~~~~~~
void SetIP(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	IP->IP1 = IP1;
    d2d6:	49 ee       	ldi	r20, 0xE9	; 233
    d2d8:	58 e0       	ldi	r21, 0x08	; 8
    d2da:	10 92 e9 08 	sts	0x08E9, r1
	IP->IP2 = IP2;
    d2de:	ba 01       	movw	r22, r20
    d2e0:	6f 5f       	subi	r22, 0xFF	; 255
    d2e2:	7f 4f       	sbci	r23, 0xFF	; 255
    d2e4:	10 92 ea 08 	sts	0x08EA, r1
	IP->IP3 = IP3;
    d2e8:	8a 01       	movw	r16, r20
    d2ea:	0e 5f       	subi	r16, 0xFE	; 254
    d2ec:	1f 4f       	sbci	r17, 0xFF	; 255
    d2ee:	10 92 eb 08 	sts	0x08EB, r1
	IP->IP4 = IP4;
    d2f2:	e3 e0       	ldi	r30, 0x03	; 3
    d2f4:	ee 2e       	mov	r14, r30
    d2f6:	f1 2c       	mov	r15, r1
    d2f8:	e4 0e       	add	r14, r20
    d2fa:	f5 1e       	adc	r15, r21
    d2fc:	10 92 ec 08 	sts	0x08EC, r1
    d300:	20 e0       	ldi	r18, 0x00	; 0
    d302:	a9 e9       	ldi	r26, 0x99	; 153
    d304:	b7 e0       	ldi	r27, 0x07	; 7
				SetIP(&GSM_MyIP,0,0,0,0);
				for(uint8_t i=0; i<strlen(GSM_RxStr); i++)
					if(!isdigit(GSM_RxStr[i])) GSM_RxStr[i] = ' ';
    d306:	30 e2       	ldi	r19, 0x20	; 32
			break;
		case GSM_WAIT_CIFSR_OK:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
			if(GetStringFromFIFO()){
				SetIP(&GSM_MyIP,0,0,0,0);
				for(uint8_t i=0; i<strlen(GSM_RxStr); i++)
    d308:	fd 01       	movw	r30, r26
    d30a:	01 90       	ld	r0, Z+
    d30c:	00 20       	and	r0, r0
    d30e:	e9 f7       	brne	.-6      	; 0xd30a <GSM_Cycle+0x1096>
    d310:	31 97       	sbiw	r30, 0x01	; 1
    d312:	e9 59       	subi	r30, 0x99	; 153
    d314:	f7 40       	sbci	r31, 0x07	; 7
    d316:	82 2f       	mov	r24, r18
    d318:	90 e0       	ldi	r25, 0x00	; 0
    d31a:	8e 17       	cp	r24, r30
    d31c:	9f 07       	cpc	r25, r31
    d31e:	08 f0       	brcs	.+2      	; 0xd322 <GSM_Cycle+0x10ae>
    d320:	53 c2       	rjmp	.+1190   	; 0xd7c8 <GSM_Cycle+0x1554>
					if(!isdigit(GSM_RxStr[i])) GSM_RxStr[i] = ' ';
    d322:	fc 01       	movw	r30, r24
    d324:	e7 56       	subi	r30, 0x67	; 103
    d326:	f8 4f       	sbci	r31, 0xF8	; 248
    d328:	80 81       	ld	r24, Z
    d32a:	90 e0       	ldi	r25, 0x00	; 0
    d32c:	c0 97       	sbiw	r24, 0x30	; 48
    d32e:	0a 97       	sbiw	r24, 0x0a	; 10
    d330:	08 f0       	brcs	.+2      	; 0xd334 <GSM_Cycle+0x10c0>
    d332:	30 83       	st	Z, r19
			break;
		case GSM_WAIT_CIFSR_OK:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
			if(GetStringFromFIFO()){
				SetIP(&GSM_MyIP,0,0,0,0);
				for(uint8_t i=0; i<strlen(GSM_RxStr); i++)
    d334:	2f 5f       	subi	r18, 0xFF	; 255
    d336:	e8 cf       	rjmp	.-48     	; 0xd308 <GSM_Cycle+0x1094>
			break;

	

		case GSM_SEND_CIFSR:
			GSM_Execute_Command(AT_CIFSR, 1000*GSM_DEBUG_DELAY); GSM_State++;
    d338:	88 e5       	ldi	r24, 0x58	; 88
    d33a:	95 e0       	ldi	r25, 0x05	; 5
    d33c:	68 ee       	ldi	r22, 0xE8	; 232
    d33e:	73 e0       	ldi	r23, 0x03	; 3
    d340:	0e 94 b4 4a 	call	0x9568	; 0x9568 <GSM_Execute_Command>
    d344:	80 91 b3 06 	lds	r24, 0x06B3
    d348:	8f 5f       	subi	r24, 0xFF	; 255
    d34a:	80 93 b3 06 	sts	0x06B3, r24
    d34e:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>

		case GSM_SEND_CIICR:
			GSM_Execute_Command(AT_CIICR, 12000*GSM_DEBUG_DELAY); GSM_State++;
			break;
		case GSM_WAIT_CIICR_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    d352:	81 ef       	ldi	r24, 0xF1	; 241
    d354:	93 e0       	ldi	r25, 0x03	; 3
    d356:	6a e4       	ldi	r22, 0x4A	; 74
    d358:	0e 94 59 4a 	call	0x94b2	; 0x94b2 <GSM_Wait_Response_P>
    d35c:	88 23       	and	r24, r24
    d35e:	11 f4       	brne	.+4      	; 0xd364 <GSM_Cycle+0x10f0>
    d360:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
    d364:	80 91 b3 06 	lds	r24, 0x06B3
    d368:	8f 5f       	subi	r24, 0xFF	; 255
    d36a:	80 93 b3 06 	sts	0x06B3, r24
    d36e:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
		case GSM_WAIT_CSTT_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;

		case GSM_SEND_CIICR:
			GSM_Execute_Command(AT_CIICR, 12000*GSM_DEBUG_DELAY); GSM_State++;
    d372:	8f e4       	ldi	r24, 0x4F	; 79
    d374:	95 e0       	ldi	r25, 0x05	; 5
    d376:	60 ee       	ldi	r22, 0xE0	; 224
    d378:	7e e2       	ldi	r23, 0x2E	; 46
    d37a:	0e 94 b4 4a 	call	0x9568	; 0x9568 <GSM_Execute_Command>
    d37e:	80 91 b3 06 	lds	r24, 0x06B3
    d382:	8f 5f       	subi	r24, 0xFF	; 255
    d384:	80 93 b3 06 	sts	0x06B3, r24
    d388:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
				}
		
			break;

		case GSM_WAIT_CIPSTART_TCP_CLIENT_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    d38c:	81 ef       	ldi	r24, 0xF1	; 241
    d38e:	93 e0       	ldi	r25, 0x03	; 3
    d390:	6a e4       	ldi	r22, 0x4A	; 74
    d392:	0e 94 59 4a 	call	0x94b2	; 0x94b2 <GSM_Wait_Response_P>
    d396:	88 23       	and	r24, r24
    d398:	11 f4       	brne	.+4      	; 0xd39e <GSM_Cycle+0x112a>
    d39a:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
    d39e:	80 91 b3 06 	lds	r24, 0x06B3
    d3a2:	8f 5f       	subi	r24, 0xFF	; 255
    d3a4:	80 93 b3 06 	sts	0x06B3, r24
    d3a8:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
			}			
			break;
		//------------------------
		case GSM_SEND_CIPSTART_TCP_CLIENT:
	
				if(GSM_Flag & (1<<flg_TxCStr)){
    d3ac:	80 91 d2 02 	lds	r24, 0x02D2
    d3b0:	80 fd       	sbrc	r24, 0
    d3b2:	02 c0       	rjmp	.+4      	; 0xd3b8 <GSM_Cycle+0x1144>
    d3b4:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
					GSMTxSz = strlen_P(AT_CIPSTART_TCP_CLIENT);
    d3b8:	58 e8       	ldi	r21, 0x88	; 136
    d3ba:	e5 2e       	mov	r14, r21
    d3bc:	55 e0       	ldi	r21, 0x05	; 5
    d3be:	f5 2e       	mov	r15, r21
    d3c0:	c7 01       	movw	r24, r14
    d3c2:	0e 94 c1 7e 	call	0xfd82	; 0xfd82 <strlen_P>
    d3c6:	80 93 75 07 	sts	0x0775, r24
					sprintf_P(GSM_TxStr, AT_CIPSTART_TCP_CLIENT);
    d3ca:	00 d0       	rcall	.+0      	; 0xd3cc <GSM_Cycle+0x1158>
    d3cc:	0f 92       	push	r0
    d3ce:	02 e0       	ldi	r16, 0x02	; 2
    d3d0:	1a e0       	ldi	r17, 0x0A	; 10
    d3d2:	ad b7       	in	r26, 0x3d	; 61
    d3d4:	be b7       	in	r27, 0x3e	; 62
    d3d6:	12 96       	adiw	r26, 0x02	; 2
    d3d8:	1c 93       	st	X, r17
    d3da:	0e 93       	st	-X, r16
    d3dc:	11 97       	sbiw	r26, 0x01	; 1
    d3de:	14 96       	adiw	r26, 0x04	; 4
    d3e0:	fc 92       	st	X, r15
    d3e2:	ee 92       	st	-X, r14
    d3e4:	13 97       	sbiw	r26, 0x03	; 3
    d3e6:	0e 94 de 7f 	call	0xffbc	; 0xffbc <sprintf_P>
					//GSM_TxStr[12] = 0x30+TempNum;
					sprintf(GSM_TxStr + GSMTxSz, "\"%u.%u.%u.%u\",\"%u\"\r",(unsigned int)erb(&TCP_ServerIP[0].IP1), (unsigned int)erb(&TCP_ServerIP[0].IP2), 
    d3ea:	b0 90 75 07 	lds	r11, 0x0775
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    d3ee:	0f 90       	pop	r0
    d3f0:	0f 90       	pop	r0
    d3f2:	0f 90       	pop	r0
    d3f4:	0f 90       	pop	r0
    d3f6:	81 e9       	ldi	r24, 0x91	; 145
    d3f8:	90 e0       	ldi	r25, 0x00	; 0
    d3fa:	0e 94 db 81 	call	0x103b6	; 0x103b6 <__eerd_byte_m2560>
    d3fe:	f8 2e       	mov	r15, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    d400:	82 e9       	ldi	r24, 0x92	; 146
    d402:	90 e0       	ldi	r25, 0x00	; 0
    d404:	0e 94 db 81 	call	0x103b6	; 0x103b6 <__eerd_byte_m2560>
    d408:	e8 2e       	mov	r14, r24
    d40a:	83 e9       	ldi	r24, 0x93	; 147
    d40c:	90 e0       	ldi	r25, 0x00	; 0
    d40e:	0e 94 db 81 	call	0x103b6	; 0x103b6 <__eerd_byte_m2560>
    d412:	d8 2e       	mov	r13, r24
    d414:	84 e9       	ldi	r24, 0x94	; 148
    d416:	90 e0       	ldi	r25, 0x00	; 0
    d418:	0e 94 db 81 	call	0x103b6	; 0x103b6 <__eerd_byte_m2560>
    d41c:	c8 2e       	mov	r12, r24
    d41e:	89 ea       	ldi	r24, 0xA9	; 169
    d420:	90 e0       	ldi	r25, 0x00	; 0
    d422:	0e 94 e9 81 	call	0x103d2	; 0x103d2 <__eerd_word_m2560>
    d426:	ed b7       	in	r30, 0x3d	; 61
    d428:	fe b7       	in	r31, 0x3e	; 62
    d42a:	3e 97       	sbiw	r30, 0x0e	; 14
    d42c:	0f b6       	in	r0, 0x3f	; 63
    d42e:	f8 94       	cli
    d430:	fe bf       	out	0x3e, r31	; 62
    d432:	0f be       	out	0x3f, r0	; 63
    d434:	ed bf       	out	0x3d, r30	; 61
    d436:	31 96       	adiw	r30, 0x01	; 1
    d438:	2b 2d       	mov	r18, r11
    d43a:	30 e0       	ldi	r19, 0x00	; 0
    d43c:	20 0f       	add	r18, r16
    d43e:	31 1f       	adc	r19, r17
    d440:	ad b7       	in	r26, 0x3d	; 61
    d442:	be b7       	in	r27, 0x3e	; 62
    d444:	12 96       	adiw	r26, 0x02	; 2
    d446:	3c 93       	st	X, r19
    d448:	2e 93       	st	-X, r18
    d44a:	11 97       	sbiw	r26, 0x01	; 1
    d44c:	28 eb       	ldi	r18, 0xB8	; 184
    d44e:	32 e0       	ldi	r19, 0x02	; 2
    d450:	33 83       	std	Z+3, r19	; 0x03
    d452:	22 83       	std	Z+2, r18	; 0x02
    d454:	f4 82       	std	Z+4, r15	; 0x04
    d456:	15 82       	std	Z+5, r1	; 0x05
    d458:	e6 82       	std	Z+6, r14	; 0x06
    d45a:	17 82       	std	Z+7, r1	; 0x07
    d45c:	d0 86       	std	Z+8, r13	; 0x08
    d45e:	11 86       	std	Z+9, r1	; 0x09
    d460:	c2 86       	std	Z+10, r12	; 0x0a
    d462:	13 86       	std	Z+11, r1	; 0x0b
    d464:	95 87       	std	Z+13, r25	; 0x0d
    d466:	84 87       	std	Z+12, r24	; 0x0c
    d468:	0e 94 ad 7f 	call	0xff5a	; 0xff5a <sprintf>
						(unsigned int)erb(&TCP_ServerIP[0].IP3), (unsigned int)erb(&TCP_ServerIP[0].IP4), (unsigned int)erw(&TCP_ServerPort[0]));
					GSMTxSz = strlen(GSM_TxStr);
    d46c:	f8 01       	movw	r30, r16
    d46e:	01 90       	ld	r0, Z+
    d470:	00 20       	and	r0, r0
    d472:	e9 f7       	brne	.-6      	; 0xd46e <GSM_Cycle+0x11fa>
    d474:	8f 01       	movw	r16, r30
    d476:	01 50       	subi	r16, 0x01	; 1
    d478:	10 40       	sbci	r17, 0x00	; 0
    d47a:	02 50       	subi	r16, 0x02	; 2
    d47c:	1a 40       	sbci	r17, 0x0A	; 10
    d47e:	00 93 75 07 	sts	0x0775, r16
					GSM_SendFirstChar();
    d482:	2d b7       	in	r18, 0x3d	; 61
    d484:	3e b7       	in	r19, 0x3e	; 62
    d486:	22 5f       	subi	r18, 0xF2	; 242
    d488:	3f 4f       	sbci	r19, 0xFF	; 255
    d48a:	0f b6       	in	r0, 0x3f	; 63
    d48c:	f8 94       	cli
    d48e:	3e bf       	out	0x3e, r19	; 62
    d490:	0f be       	out	0x3f, r0	; 63
    d492:	2d bf       	out	0x3d, r18	; 61
    d494:	0e 94 aa 39 	call	0x7354	; 0x7354 <GSM_SendFirstChar>
					StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    d498:	80 91 e7 04 	lds	r24, 0x04E7
    d49c:	64 ef       	ldi	r22, 0xF4	; 244
    d49e:	71 e0       	ldi	r23, 0x01	; 1
    d4a0:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
					GSM_State++;
    d4a4:	80 91 b3 06 	lds	r24, 0x06B3
    d4a8:	8f 5f       	subi	r24, 0xFF	; 255
    d4aa:	80 93 b3 06 	sts	0x06B3, r24
    d4ae:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>

		case GSM_WAIT_CIPSTART_TCP_CLIENT_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;
		case GSM_WAIT_CIPSTART_TCP_CLIENT_CONNECT:
			if(GSM_Wait_Response_P(RESP_CONNECT, GSM_ReStart1)){
    d4b2:	84 ef       	ldi	r24, 0xF4	; 244
    d4b4:	93 e0       	ldi	r25, 0x03	; 3
    d4b6:	6a e4       	ldi	r22, 0x4A	; 74
    d4b8:	0e 94 59 4a 	call	0x94b2	; 0x94b2 <GSM_Wait_Response_P>
    d4bc:	88 23       	and	r24, r24
    d4be:	11 f4       	brne	.+4      	; 0xd4c4 <GSM_Cycle+0x1250>
    d4c0:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
				 GSM_State = GSM_WAIT_IDENTIFICATION;
    d4c4:	8e e3       	ldi	r24, 0x3E	; 62
    d4c6:	80 93 b3 06 	sts	0x06B3, r24
				 StartTimer16(TD_GSM, 1000*GSM_DEBUG_DELAY);
    d4ca:	80 91 e7 04 	lds	r24, 0x04E7
    d4ce:	68 ee       	ldi	r22, 0xE8	; 232
    d4d0:	73 e0       	ldi	r23, 0x03	; 3
    d4d2:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
    d4d6:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
				GSM_State++;
				GSM_Temp = 0;
			}
			break;
		case GSM_SEND_CGATT:
			GSM_Execute_Command(AT_CGATT, 500*GSM_DEBUG_DELAY); GSM_Temp++; GSM_State++;
    d4da:	8d e2       	ldi	r24, 0x2D	; 45
    d4dc:	95 e0       	ldi	r25, 0x05	; 5
    d4de:	64 ef       	ldi	r22, 0xF4	; 244
    d4e0:	71 e0       	ldi	r23, 0x01	; 1
    d4e2:	0e 94 b4 4a 	call	0x9568	; 0x9568 <GSM_Execute_Command>
    d4e6:	80 91 d9 05 	lds	r24, 0x05D9
    d4ea:	8f 5f       	subi	r24, 0xFF	; 255
    d4ec:	80 93 d9 05 	sts	0x05D9, r24
    d4f0:	80 91 b3 06 	lds	r24, 0x06B3
    d4f4:	8f 5f       	subi	r24, 0xFF	; 255
    d4f6:	80 93 b3 06 	sts	0x06B3, r24
    d4fa:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
			break;
		case GSM_CFG_SEND_ATW:
			GSM_Execute_Command(AT_W, 100); GSM_State++;
			break;
		case GSM_CFG_WAIT_ATW_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_CFG_SEND_AT)){
    d4fe:	81 ef       	ldi	r24, 0xF1	; 241
    d500:	93 e0       	ldi	r25, 0x03	; 3
    d502:	61 e0       	ldi	r22, 0x01	; 1
    d504:	0e 94 59 4a 	call	0x94b2	; 0x94b2 <GSM_Wait_Response_P>
    d508:	88 23       	and	r24, r24
    d50a:	11 f4       	brne	.+4      	; 0xd510 <GSM_Cycle+0x129c>
    d50c:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
				StartTimer16(TD_GSM,200);
    d510:	80 91 e7 04 	lds	r24, 0x04E7
    d514:	68 ec       	ldi	r22, 0xC8	; 200
    d516:	70 e0       	ldi	r23, 0x00	; 0
    d518:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
				GSM_State++;
    d51c:	80 91 b3 06 	lds	r24, 0x06B3
    d520:	8f 5f       	subi	r24, 0xFF	; 255
    d522:	80 93 b3 06 	sts	0x06B3, r24
    d526:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
			break;
		case GSM_CFG_SEND_AT:
			if(Timer16Stopp(TD_GSM)) GSM_Execute_Command(AT_AT, 100); GSM_State++;
			break;
		case GSM_CFG_WAIT_AT_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_CFG_SEND_AT)) GSM_State++;
    d52a:	81 ef       	ldi	r24, 0xF1	; 241
    d52c:	93 e0       	ldi	r25, 0x03	; 3
    d52e:	61 e0       	ldi	r22, 0x01	; 1
    d530:	0e 94 59 4a 	call	0x94b2	; 0x94b2 <GSM_Wait_Response_P>
    d534:	88 23       	and	r24, r24
    d536:	11 f4       	brne	.+4      	; 0xd53c <GSM_Cycle+0x12c8>
    d538:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
    d53c:	80 91 b3 06 	lds	r24, 0x06B3
    d540:	8f 5f       	subi	r24, 0xFF	; 255
    d542:	80 93 b3 06 	sts	0x06B3, r24
    d546:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
			StartTimer16(TD_GSM,200);
			GSM_PWRCNTRL_ON();
			GSM_State++;
			break;
		case GSM_CFG_SEND_AT:
			if(Timer16Stopp(TD_GSM)) GSM_Execute_Command(AT_AT, 100); GSM_State++;
    d54a:	80 91 e7 04 	lds	r24, 0x04E7
    d54e:	0e 94 06 1c 	call	0x380c	; 0x380c <Timer16Stopp>
    d552:	88 23       	and	r24, r24
    d554:	31 f0       	breq	.+12     	; 0xd562 <GSM_Cycle+0x12ee>
    d556:	8d e6       	ldi	r24, 0x6D	; 109
    d558:	94 e0       	ldi	r25, 0x04	; 4
    d55a:	64 e6       	ldi	r22, 0x64	; 100
    d55c:	70 e0       	ldi	r23, 0x00	; 0
    d55e:	0e 94 b4 4a 	call	0x9568	; 0x9568 <GSM_Execute_Command>
    d562:	80 91 b3 06 	lds	r24, 0x06B3
    d566:	8f 5f       	subi	r24, 0xFF	; 255
    d568:	80 93 b3 06 	sts	0x06B3, r24
    d56c:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
				StartTimer16(TD_GSM,200);
				GSM_State++;
			}
			break;
		case GSM_SAVE_IPR:
			if(Timer16Stopp(TD_GSM)) GSM_State++;
    d570:	80 91 e7 04 	lds	r24, 0x04E7
    d574:	0e 94 06 1c 	call	0x380c	; 0x380c <Timer16Stopp>
    d578:	88 23       	and	r24, r24
    d57a:	11 f4       	brne	.+4      	; 0xd580 <GSM_Cycle+0x130c>
    d57c:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
    d580:	80 91 b3 06 	lds	r24, 0x06B3
    d584:	8f 5f       	subi	r24, 0xFF	; 255
    d586:	80 93 b3 06 	sts	0x06B3, r24
    d58a:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
			break;
		case GSM_CFG_SEND_IPR:
			GSM_Execute_Command(AT_IPR9600, 100); GSM_State++;
			break;
		case GSM_CFG_WAIT_IPR_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_CFG_SEND_AT)){
    d58e:	81 ef       	ldi	r24, 0xF1	; 241
    d590:	93 e0       	ldi	r25, 0x03	; 3
    d592:	61 e0       	ldi	r22, 0x01	; 1
    d594:	0e 94 59 4a 	call	0x94b2	; 0x94b2 <GSM_Wait_Response_P>
    d598:	88 23       	and	r24, r24
    d59a:	11 f4       	brne	.+4      	; 0xd5a0 <GSM_Cycle+0x132c>
    d59c:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
				StartTimer16(TD_GSM,200);
    d5a0:	80 91 e7 04 	lds	r24, 0x04E7
    d5a4:	68 ec       	ldi	r22, 0xC8	; 200
    d5a6:	70 e0       	ldi	r23, 0x00	; 0
    d5a8:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
				GSM_State++;
    d5ac:	80 91 b3 06 	lds	r24, 0x06B3
    d5b0:	8f 5f       	subi	r24, 0xFF	; 255
    d5b2:	80 93 b3 06 	sts	0x06B3, r24
    d5b6:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
			if(GSM_Wait_Response_P(RESP_OK,GSM_SEND_CSQ)) GSM_State++;
			break;
		case GSM_WAIT_Ballance:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_SEND_CSQ;
			GSM_RxStr[GSM_RXSTR_SIZE-1]='\0';
			while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    d5ba:	00 e0       	ldi	r16, 0x00	; 0
    d5bc:	32 e0       	ldi	r19, 0x02	; 2
    d5be:	c3 2e       	mov	r12, r19
    d5c0:	d1 2c       	mov	r13, r1
    d5c2:	cc 0e       	add	r12, r28
    d5c4:	dd 1e       	adc	r13, r29
    d5c6:	09 c0       	rjmp	.+18     	; 0xd5da <GSM_Cycle+0x1366>
				}

			}//while
			char buf[20];
			uint8_t i=0;
			while( (erb(&GPRS_currency[i])!='\0') && ((erb(&GPRS_currency[i])!=' ')||i==0) ){
    d5c8:	80 32       	cpi	r24, 0x20	; 32
    d5ca:	11 f4       	brne	.+4      	; 0xd5d0 <GSM_Cycle+0x135c>
    d5cc:	00 23       	and	r16, r16
    d5ce:	71 f4       	brne	.+28     	; 0xd5ec <GSM_Cycle+0x1378>
				buf[i] = (char)erb(&GPRS_currency[i]);
    d5d0:	ec 0c       	add	r14, r12
    d5d2:	fd 1c       	adc	r15, r13
    d5d4:	f7 01       	movw	r30, r14
    d5d6:	80 83       	st	Z, r24
				i++;
    d5d8:	0f 5f       	subi	r16, 0xFF	; 255
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    d5da:	e0 2e       	mov	r14, r16
    d5dc:	ff 24       	eor	r15, r15
    d5de:	c7 01       	movw	r24, r14
    d5e0:	8b 5b       	subi	r24, 0xBB	; 187
    d5e2:	9f 4f       	sbci	r25, 0xFF	; 255
    d5e4:	0e 94 db 81 	call	0x103b6	; 0x103b6 <__eerd_byte_m2560>
				}

			}//while
			char buf[20];
			uint8_t i=0;
			while( (erb(&GPRS_currency[i])!='\0') && ((erb(&GPRS_currency[i])!=' ')||i==0) ){
    d5e8:	88 23       	and	r24, r24
    d5ea:	71 f7       	brne	.-36     	; 0xd5c8 <GSM_Cycle+0x1354>
				buf[i] = (char)erb(&GPRS_currency[i]);
				i++;
			}
			buf[i]='\0';
    d5ec:	ec 0c       	add	r14, r12
    d5ee:	fd 1c       	adc	r15, r13
    d5f0:	d7 01       	movw	r26, r14
    d5f2:	1c 92       	st	X, r1
			char *istr=strstr(GSM_RxStr, buf);
    d5f4:	89 e9       	ldi	r24, 0x99	; 153
    d5f6:	97 e0       	ldi	r25, 0x07	; 7
    d5f8:	b6 01       	movw	r22, r12
    d5fa:	0e 94 25 7f 	call	0xfe4a	; 0xfe4a <strstr>
			if(istr)
    d5fe:	00 97       	sbiw	r24, 0x00	; 0
    d600:	11 f4       	brne	.+4      	; 0xd606 <GSM_Cycle+0x1392>
    d602:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
			{
					Ballance=*(istr-1)-0x30;
    d606:	fc 01       	movw	r30, r24
    d608:	82 91       	ld	r24, -Z
    d60a:	90 e0       	ldi	r25, 0x00	; 0
    d60c:	c0 97       	sbiw	r24, 0x30	; 48
    d60e:	aa 27       	eor	r26, r26
    d610:	97 fd       	sbrc	r25, 7
    d612:	a0 95       	com	r26
    d614:	ba 2f       	mov	r27, r26
    d616:	80 93 b8 06 	sts	0x06B8, r24
    d61a:	90 93 b9 06 	sts	0x06B9, r25
    d61e:	a0 93 ba 06 	sts	0x06BA, r26
    d622:	b0 93 bb 06 	sts	0x06BB, r27
					Ballance+=(*(istr-2)-0x30)*10;
    d626:	22 91       	ld	r18, -Z
    d628:	8f 01       	movw	r16, r30
    d62a:	4a e0       	ldi	r20, 0x0A	; 10
    d62c:	24 9f       	mul	r18, r20
    d62e:	90 01       	movw	r18, r0
    d630:	11 24       	eor	r1, r1
    d632:	20 5e       	subi	r18, 0xE0	; 224
    d634:	31 40       	sbci	r19, 0x01	; 1
    d636:	49 01       	movw	r8, r18
    d638:	aa 24       	eor	r10, r10
    d63a:	97 fc       	sbrc	r9, 7
    d63c:	a0 94       	com	r10
    d63e:	ba 2c       	mov	r11, r10
    d640:	88 0e       	add	r8, r24
    d642:	99 1e       	adc	r9, r25
    d644:	aa 1e       	adc	r10, r26
    d646:	bb 1e       	adc	r11, r27
    d648:	80 92 b8 06 	sts	0x06B8, r8
    d64c:	90 92 b9 06 	sts	0x06B9, r9
    d650:	a0 92 ba 06 	sts	0x06BA, r10
    d654:	b0 92 bb 06 	sts	0x06BB, r11
					uint8_t charnum=4;
					uint32_t razr=100;
					while((*(istr-charnum)>=0x30)&&(*(istr-charnum)<=0x39)){
    d658:	02 50       	subi	r16, 0x02	; 2
    d65a:	10 40       	sbci	r17, 0x00	; 0
    d65c:	d8 01       	movw	r26, r16
    d65e:	6c 91       	ld	r22, X
    d660:	0c 5f       	subi	r16, 0xFC	; 252
    d662:	1f 4f       	sbci	r17, 0xFF	; 255
    d664:	86 2f       	mov	r24, r22
    d666:	80 53       	subi	r24, 0x30	; 48
    d668:	8a 30       	cpi	r24, 0x0A	; 10
    d66a:	88 f5       	brcc	.+98     	; 0xd6ce <GSM_Cycle+0x145a>
    d66c:	24 e0       	ldi	r18, 0x04	; 4
    d66e:	72 2e       	mov	r7, r18
    d670:	94 e6       	ldi	r25, 0x64	; 100
    d672:	c9 2e       	mov	r12, r25
    d674:	d1 2c       	mov	r13, r1
    d676:	e1 2c       	mov	r14, r1
    d678:	f1 2c       	mov	r15, r1
						Ballance+=(*(istr-charnum)-0x30)*razr;
    d67a:	70 e0       	ldi	r23, 0x00	; 0
    d67c:	60 53       	subi	r22, 0x30	; 48
    d67e:	70 40       	sbci	r23, 0x00	; 0
    d680:	88 27       	eor	r24, r24
    d682:	77 fd       	sbrc	r23, 7
    d684:	80 95       	com	r24
    d686:	98 2f       	mov	r25, r24
    d688:	a7 01       	movw	r20, r14
    d68a:	96 01       	movw	r18, r12
    d68c:	0e 94 17 82 	call	0x1042e	; 0x1042e <__mulsi3>
    d690:	86 0e       	add	r8, r22
    d692:	97 1e       	adc	r9, r23
    d694:	a8 1e       	adc	r10, r24
    d696:	b9 1e       	adc	r11, r25
    d698:	80 92 b8 06 	sts	0x06B8, r8
    d69c:	90 92 b9 06 	sts	0x06B9, r9
    d6a0:	a0 92 ba 06 	sts	0x06BA, r10
    d6a4:	b0 92 bb 06 	sts	0x06BB, r11
						razr*=10;
    d6a8:	c7 01       	movw	r24, r14
    d6aa:	b6 01       	movw	r22, r12
    d6ac:	2a e0       	ldi	r18, 0x0A	; 10
    d6ae:	30 e0       	ldi	r19, 0x00	; 0
    d6b0:	40 e0       	ldi	r20, 0x00	; 0
    d6b2:	50 e0       	ldi	r21, 0x00	; 0
    d6b4:	0e 94 17 82 	call	0x1042e	; 0x1042e <__mulsi3>
    d6b8:	6b 01       	movw	r12, r22
    d6ba:	7c 01       	movw	r14, r24
						charnum++;	
    d6bc:	73 94       	inc	r7
			{
					Ballance=*(istr-1)-0x30;
					Ballance+=(*(istr-2)-0x30)*10;
					uint8_t charnum=4;
					uint32_t razr=100;
					while((*(istr-charnum)>=0x30)&&(*(istr-charnum)<=0x39)){
    d6be:	f8 01       	movw	r30, r16
    d6c0:	e7 19       	sub	r30, r7
    d6c2:	f1 09       	sbc	r31, r1
    d6c4:	60 81       	ld	r22, Z
    d6c6:	86 2f       	mov	r24, r22
    d6c8:	80 53       	subi	r24, 0x30	; 48
    d6ca:	8a 30       	cpi	r24, 0x0A	; 10
    d6cc:	b0 f2       	brcs	.-84     	; 0xd67a <GSM_Cycle+0x1406>
						Ballance+=(*(istr-charnum)-0x30)*razr;
						razr*=10;
						charnum++;	
					}
					if(*(istr-charnum)==0x2D)
    d6ce:	6d 32       	cpi	r22, 0x2D	; 45
    d6d0:	11 f0       	breq	.+4      	; 0xd6d6 <GSM_Cycle+0x1462>
    d6d2:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
					{
						Ballance*=-1;
    d6d6:	80 91 b8 06 	lds	r24, 0x06B8
    d6da:	90 91 b9 06 	lds	r25, 0x06B9
    d6de:	a0 91 ba 06 	lds	r26, 0x06BA
    d6e2:	b0 91 bb 06 	lds	r27, 0x06BB
    d6e6:	b0 95       	com	r27
    d6e8:	a0 95       	com	r26
    d6ea:	90 95       	com	r25
    d6ec:	81 95       	neg	r24
    d6ee:	9f 4f       	sbci	r25, 0xFF	; 255
    d6f0:	af 4f       	sbci	r26, 0xFF	; 255
    d6f2:	bf 4f       	sbci	r27, 0xFF	; 255
    d6f4:	80 93 b8 06 	sts	0x06B8, r24
    d6f8:	90 93 b9 06 	sts	0x06B9, r25
    d6fc:	a0 93 ba 06 	sts	0x06BA, r26
    d700:	b0 93 bb 06 	sts	0x06BB, r27
    d704:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
					StartTimer16(TD_GSM, 2000);
					GSM_State = GSM_WAIT_CCLC_3;
					break;
				}
			}
			if(Timer16Stopp(TD_GSM)){
    d708:	80 91 e7 04 	lds	r24, 0x04E7
    d70c:	0e 94 06 1c 	call	0x380c	; 0x380c <Timer16Stopp>
    d710:	88 23       	and	r24, r24
    d712:	11 f4       	brne	.+4      	; 0xd718 <GSM_Cycle+0x14a4>
    d714:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
				GSM_State = GSM_WAIT_MESSAGE;
    d718:	8e e0       	ldi	r24, 0x0E	; 14
    d71a:	80 93 b3 06 	sts	0x06B3, r24
    d71e:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
					GSM_State = GSM_WAIT_DISCONNECT_CAUSE;
					StartTimer16(TD_GSM, 10000);
					break;
				}
			}
			if(Timer16Stopp(TD_GSM)){
    d722:	80 91 e7 04 	lds	r24, 0x04E7
    d726:	0e 94 06 1c 	call	0x380c	; 0x380c <Timer16Stopp>
    d72a:	88 23       	and	r24, r24
    d72c:	11 f4       	brne	.+4      	; 0xd732 <GSM_Cycle+0x14be>
    d72e:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
				GSM_State = GSM_WAIT_MESSAGE;
    d732:	8e e0       	ldi	r24, 0x0E	; 14
    d734:	80 93 b3 06 	sts	0x06B3, r24
    d738:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
				if((strstr_P(GSM_RxStr, PSTR("+CREC: 0")) != NULL) ){
					GSM_State = GSM_SEND_PLAY_CONFIRM_FILE;
					break;
				}
			}
			if(Timer16Stopp(TD_GSM)){
    d73c:	80 91 e7 04 	lds	r24, 0x04E7
    d740:	0e 94 06 1c 	call	0x380c	; 0x380c <Timer16Stopp>
    d744:	88 23       	and	r24, r24
    d746:	11 f4       	brne	.+4      	; 0xd74c <GSM_Cycle+0x14d8>
    d748:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
				GSM_State = GSM_SEND_PLAY_CONFIRM_FILE;
    d74c:	8d e1       	ldi	r24, 0x1D	; 29
    d74e:	80 93 b3 06 	sts	0x06B3, r24
    d752:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
				if((strstr_P(GSM_RxStr, PSTR("+CREC: 0")) != NULL) ){
					GSM_State = GSM_WAIT_CONFIRMRESPONSE;
					StartTimer16(TD_GSM, 200);
					break;
				}
				if(analize_DTMF()){
    d756:	0e 94 c7 4a 	call	0x958e	; 0x958e <analize_DTMF>
    d75a:	88 23       	and	r24, r24
    d75c:	11 f0       	breq	.+4      	; 0xd762 <GSM_Cycle+0x14ee>
    d75e:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
					break;
				}
			}
			if(Timer16Stopp(TD_GSM)){
    d762:	80 91 e7 04 	lds	r24, 0x04E7
    d766:	0e 94 06 1c 	call	0x380c	; 0x380c <Timer16Stopp>
    d76a:	88 23       	and	r24, r24
    d76c:	11 f4       	brne	.+4      	; 0xd772 <GSM_Cycle+0x14fe>
    d76e:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
				GSM_State = GSM_WAIT_CONFIRMRESPONSE;
    d772:	8a e1       	ldi	r24, 0x1A	; 26
    d774:	80 93 b3 06 	sts	0x06B3, r24
				StartTimer16(TD_GSM, 200);
    d778:	80 91 e7 04 	lds	r24, 0x04E7
    d77c:	68 ec       	ldi	r22, 0xC8	; 200
    d77e:	70 e0       	ldi	r23, 0x00	; 0
    d780:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
    d784:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
			if(GetStringFromFIFO()){
				if((strstr_P(GSM_RxStr, PSTR("+CREC: 0")) != NULL) ){
					GSM_State = GSM_SEND_PLAY_CONFIRMREQUEST_FILE;
					break;
				}
				if(analize_DTMF()){
    d788:	0e 94 c7 4a 	call	0x958e	; 0x958e <analize_DTMF>
    d78c:	88 23       	and	r24, r24
    d78e:	11 f0       	breq	.+4      	; 0xd794 <GSM_Cycle+0x1520>
    d790:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
					break;
				}
			}
			if(Timer16Stopp(TD_GSM)){
    d794:	80 91 e7 04 	lds	r24, 0x04E7
    d798:	0e 94 06 1c 	call	0x380c	; 0x380c <Timer16Stopp>
    d79c:	88 23       	and	r24, r24
    d79e:	11 f4       	brne	.+4      	; 0xd7a4 <GSM_Cycle+0x1530>
    d7a0:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
				GSM_State = GSM_WAIT_CONFIRMRESPONSE;
    d7a4:	8a e1       	ldi	r24, 0x1A	; 26
    d7a6:	80 93 b3 06 	sts	0x06B3, r24
    d7aa:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
					GSM_State = GSM_WAIT_CCLC_0;
					break;
				}

			}
			if(Timer16Stopp(TD_GSM)){
    d7ae:	80 91 e7 04 	lds	r24, 0x04E7
    d7b2:	0e 94 06 1c 	call	0x380c	; 0x380c <Timer16Stopp>
    d7b6:	88 23       	and	r24, r24
    d7b8:	11 f4       	brne	.+4      	; 0xd7be <GSM_Cycle+0x154a>
    d7ba:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
				GSM_State = GSM_WAIT_MESSAGE;
    d7be:	8e e0       	ldi	r24, 0x0E	; 14
    d7c0:	80 93 b3 06 	sts	0x06B3, r24
    d7c4:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
			if(GetStringFromFIFO()){
				SetIP(&GSM_MyIP,0,0,0,0);
				for(uint8_t i=0; i<strlen(GSM_RxStr); i++)
					if(!isdigit(GSM_RxStr[i])) GSM_RxStr[i] = ' ';
				sscanf_P(GSM_RxStr,PSTR("%hhu %hhu %hhu %hhu"), (unsigned char*)&GSM_MyIP.IP1, (unsigned char*)&GSM_MyIP.IP2, (unsigned char*)&GSM_MyIP.IP3, (unsigned char*)&GSM_MyIP.IP4);
    d7c8:	ed b7       	in	r30, 0x3d	; 61
    d7ca:	fe b7       	in	r31, 0x3e	; 62
    d7cc:	3c 97       	sbiw	r30, 0x0c	; 12
    d7ce:	0f b6       	in	r0, 0x3f	; 63
    d7d0:	f8 94       	cli
    d7d2:	fe bf       	out	0x3e, r31	; 62
    d7d4:	0f be       	out	0x3f, r0	; 63
    d7d6:	ed bf       	out	0x3d, r30	; 61
    d7d8:	31 96       	adiw	r30, 0x01	; 1
    d7da:	89 e9       	ldi	r24, 0x99	; 153
    d7dc:	97 e0       	ldi	r25, 0x07	; 7
    d7de:	ad b7       	in	r26, 0x3d	; 61
    d7e0:	be b7       	in	r27, 0x3e	; 62
    d7e2:	12 96       	adiw	r26, 0x02	; 2
    d7e4:	9c 93       	st	X, r25
    d7e6:	8e 93       	st	-X, r24
    d7e8:	11 97       	sbiw	r26, 0x01	; 1
    d7ea:	8a e0       	ldi	r24, 0x0A	; 10
    d7ec:	9c e2       	ldi	r25, 0x2C	; 44
    d7ee:	93 83       	std	Z+3, r25	; 0x03
    d7f0:	82 83       	std	Z+2, r24	; 0x02
    d7f2:	55 83       	std	Z+5, r21	; 0x05
    d7f4:	44 83       	std	Z+4, r20	; 0x04
    d7f6:	77 83       	std	Z+7, r23	; 0x07
    d7f8:	66 83       	std	Z+6, r22	; 0x06
    d7fa:	11 87       	std	Z+9, r17	; 0x09
    d7fc:	00 87       	std	Z+8, r16	; 0x08
    d7fe:	f3 86       	std	Z+11, r15	; 0x0b
    d800:	e2 86       	std	Z+10, r14	; 0x0a
    d802:	0e 94 32 80 	call	0x10064	; 0x10064 <sscanf_P>
}
uint8_t IP_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	if((IP->IP1 == IP1) && (IP->IP2 == IP2) && (IP->IP3 == IP3) && (IP->IP4 == IP4)) return 1;
    d806:	ed b7       	in	r30, 0x3d	; 61
    d808:	fe b7       	in	r31, 0x3e	; 62
    d80a:	3c 96       	adiw	r30, 0x0c	; 12
    d80c:	0f b6       	in	r0, 0x3f	; 63
    d80e:	f8 94       	cli
    d810:	fe bf       	out	0x3e, r31	; 62
    d812:	0f be       	out	0x3f, r0	; 63
    d814:	ed bf       	out	0x3d, r30	; 61
    d816:	80 91 e9 08 	lds	r24, 0x08E9
    d81a:	88 23       	and	r24, r24
    d81c:	f1 f5       	brne	.+124    	; 0xd89a <GSM_Cycle+0x1626>
    d81e:	80 91 ea 08 	lds	r24, 0x08EA
    d822:	88 23       	and	r24, r24
    d824:	d1 f5       	brne	.+116    	; 0xd89a <GSM_Cycle+0x1626>
    d826:	80 91 eb 08 	lds	r24, 0x08EB
    d82a:	88 23       	and	r24, r24
    d82c:	b1 f5       	brne	.+108    	; 0xd89a <GSM_Cycle+0x1626>
    d82e:	80 91 ec 08 	lds	r24, 0x08EC
    d832:	88 23       	and	r24, r24
    d834:	91 f5       	brne	.+100    	; 0xd89a <GSM_Cycle+0x1626>
				if(!IP_compare_Const(&GSM_MyIP,0,0,0,0)){
				  GSM_State = GSM_SEND_CIPSTART_TCP_CLIENT;
				}
				TempNum=0;	//
    d836:	10 92 da 05 	sts	0x05DA, r1
    d83a:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
					StartTimer16(TD_GSM, 6000);
					GSM_State = GSM_WAIT_DISCONNECT_CAUSE;
					break;
				}
			}
			if(Timer16Stopp(TD_GSM)){
    d83e:	80 91 e7 04 	lds	r24, 0x04E7
    d842:	0e 94 06 1c 	call	0x380c	; 0x380c <Timer16Stopp>
    d846:	88 23       	and	r24, r24
    d848:	11 f4       	brne	.+4      	; 0xd84e <GSM_Cycle+0x15da>
    d84a:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
				GSM_State = GSM_WAIT_MESSAGE;
    d84e:	8e e0       	ldi	r24, 0x0E	; 14
    d850:	80 93 b3 06 	sts	0x06B3, r24
    d854:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
			sprintf(GSM_TxStr+GSMTxSz,"%u",Message[2]);
			if(Message[2]>9){
				GSMTxSz+=2;
			}
			else{
				GSMTxSz++;
    d858:	80 91 75 07 	lds	r24, 0x0775
    d85c:	8f 5f       	subi	r24, 0xFF	; 255
    d85e:	80 93 75 07 	sts	0x0775, r24
    d862:	d2 c9       	rjmp	.-3164   	; 0xcc08 <GSM_Cycle+0x994>
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State=GSM_SEND_ATD_Check_Ballance;
			break;
		//------------------------
		case GSM_SEND_CIPMUX:
			if(GSM_MultiCon) GSM_Execute_Command(AT_CIPMUX_1, 100*GSM_DEBUG_DELAY);
			else GSM_Execute_Command(AT_CIPMUX_0, 100*GSM_DEBUG_DELAY);
    d864:	85 e1       	ldi	r24, 0x15	; 21
    d866:	95 e0       	ldi	r25, 0x05	; 5
    d868:	64 e6       	ldi	r22, 0x64	; 100
    d86a:	70 e0       	ldi	r23, 0x00	; 0
    d86c:	0e 94 b4 4a 	call	0x9568	; 0x9568 <GSM_Execute_Command>
    d870:	df cb       	rjmp	.-2114   	; 0xd030 <GSM_Cycle+0xdbc>
				else GSM_State++;
			}
			break;
		case GSM_SEND_CIPMODE:
			if(GSM_MultiCon) GSM_Execute_Command(AT_CIPMODE_0, 100*GSM_DEBUG_DELAY);
			else GSM_Execute_Command(AT_CIPMODE_1, 100*GSM_DEBUG_DELAY);
    d872:	88 e0       	ldi	r24, 0x08	; 8
    d874:	95 e0       	ldi	r25, 0x05	; 5
    d876:	64 e6       	ldi	r22, 0x64	; 100
    d878:	70 e0       	ldi	r23, 0x00	; 0
    d87a:	0e 94 b4 4a 	call	0x9568	; 0x9568 <GSM_Execute_Command>
    d87e:	b4 cb       	rjmp	.-2200   	; 0xcfe8 <GSM_Cycle+0xd74>
					break;
				}
				GSM_State = GSM_WAIT_MESSAGE;
				break;
			}
			if(Timer16Stopp(TD_GSM)){
    d880:	80 91 e7 04 	lds	r24, 0x04E7
    d884:	0e 94 06 1c 	call	0x380c	; 0x380c <Timer16Stopp>
    d888:	88 23       	and	r24, r24
    d88a:	11 f4       	brne	.+4      	; 0xd890 <GSM_Cycle+0x161c>
    d88c:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
				GSM_State = GSM_WAIT_MESSAGE;
    d890:	8e e0       	ldi	r24, 0x0E	; 14
    d892:	80 93 b3 06 	sts	0x06B3, r24
    d896:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
				SetIP(&GSM_MyIP,0,0,0,0);
				for(uint8_t i=0; i<strlen(GSM_RxStr); i++)
					if(!isdigit(GSM_RxStr[i])) GSM_RxStr[i] = ' ';
				sscanf_P(GSM_RxStr,PSTR("%hhu %hhu %hhu %hhu"), (unsigned char*)&GSM_MyIP.IP1, (unsigned char*)&GSM_MyIP.IP2, (unsigned char*)&GSM_MyIP.IP3, (unsigned char*)&GSM_MyIP.IP4);
				if(!IP_compare_Const(&GSM_MyIP,0,0,0,0)){
				  GSM_State = GSM_SEND_CIPSTART_TCP_CLIENT;
    d89a:	8b e3       	ldi	r24, 0x3B	; 59
    d89c:	80 93 b3 06 	sts	0x06B3, r24
    d8a0:	ca cf       	rjmp	.-108    	; 0xd836 <GSM_Cycle+0x15c2>
					if(GSM_RxCharN==2)
						{
							if(!strncmp_P(GSM_RxStr, PSTR("\r\n"), 2)) {GSM_RxCharN=0;}
						}
					if(GSM_RxCharN >= 4){
						AppProtocol = 0;
    d8a2:	10 92 9f 08 	sts	0x089F, r1
						if(!strncmp_P(GSM_RxStr, PSTR("GET "), 4)) {AppProtocol = _HTTP;GSM_State = GSM_DataMode;break;}//GET
    d8a6:	89 e9       	ldi	r24, 0x99	; 153
    d8a8:	97 e0       	ldi	r25, 0x07	; 7
    d8aa:	62 ee       	ldi	r22, 0xE2	; 226
    d8ac:	7b e2       	ldi	r23, 0x2B	; 43
    d8ae:	44 e0       	ldi	r20, 0x04	; 4
    d8b0:	50 e0       	ldi	r21, 0x00	; 0
    d8b2:	0e 94 ca 7e 	call	0xfd94	; 0xfd94 <strncmp_P>
    d8b6:	89 2b       	or	r24, r25
    d8b8:	09 f4       	brne	.+2      	; 0xd8bc <GSM_Cycle+0x1648>
    d8ba:	e6 c2       	rjmp	.+1484   	; 0xde88 <GSM_Cycle+0x1c14>
						if(!strncmp_P(GSM_RxStr, PSTR("POST"), 4)) {AppProtocol = _HTTP;GSM_State = GSM_DataMode;break;}//POST
    d8bc:	89 e9       	ldi	r24, 0x99	; 153
    d8be:	97 e0       	ldi	r25, 0x07	; 7
    d8c0:	6d ed       	ldi	r22, 0xDD	; 221
    d8c2:	7b e2       	ldi	r23, 0x2B	; 43
    d8c4:	44 e0       	ldi	r20, 0x04	; 4
    d8c6:	50 e0       	ldi	r21, 0x00	; 0
    d8c8:	0e 94 ca 7e 	call	0xfd94	; 0xfd94 <strncmp_P>
    d8cc:	89 2b       	or	r24, r25
    d8ce:	09 f4       	brne	.+2      	; 0xd8d2 <GSM_Cycle+0x165e>
    d8d0:	db c2       	rjmp	.+1462   	; 0xde88 <GSM_Cycle+0x1c14>
						if(!strncmp_P(GSM_RxStr, PSTR("CLOS"), 4)) {AppProtocol = _HTTP;GSM_State = GSM_ReStart1;break;}// 
    d8d2:	89 e9       	ldi	r24, 0x99	; 153
    d8d4:	97 e0       	ldi	r25, 0x07	; 7
    d8d6:	68 ed       	ldi	r22, 0xD8	; 216
    d8d8:	7b e2       	ldi	r23, 0x2B	; 43
    d8da:	44 e0       	ldi	r20, 0x04	; 4
    d8dc:	50 e0       	ldi	r21, 0x00	; 0
    d8de:	0e 94 ca 7e 	call	0xfd94	; 0xfd94 <strncmp_P>
    d8e2:	89 2b       	or	r24, r25
    d8e4:	09 f4       	brne	.+2      	; 0xd8e8 <GSM_Cycle+0x1674>
    d8e6:	c9 c2       	rjmp	.+1426   	; 0xde7a <GSM_Cycle+0x1c06>
						if(!strncmp_P(GSM_RxStr, PSTR("+PDP"), 4)) {AppProtocol = _HTTP;GSM_State = GSM_ReStart1;break;}//GPRS 
    d8e8:	89 e9       	ldi	r24, 0x99	; 153
    d8ea:	97 e0       	ldi	r25, 0x07	; 7
    d8ec:	63 ed       	ldi	r22, 0xD3	; 211
    d8ee:	7b e2       	ldi	r23, 0x2B	; 43
    d8f0:	44 e0       	ldi	r20, 0x04	; 4
    d8f2:	50 e0       	ldi	r21, 0x00	; 0
    d8f4:	0e 94 ca 7e 	call	0xfd94	; 0xfd94 <strncmp_P>
    d8f8:	89 2b       	or	r24, r25
    d8fa:	09 f4       	brne	.+2      	; 0xd8fe <GSM_Cycle+0x168a>
    d8fc:	be c2       	rjmp	.+1404   	; 0xde7a <GSM_Cycle+0x1c06>
						if( (GSM_RxStr[0]==0) && (GSM_RxStr[1]==0)){AppProtocol = _HTTP;GSM_State = GSM_ReStart1;break;}//  
    d8fe:	80 91 99 07 	lds	r24, 0x0799
    d902:	88 23       	and	r24, r24
    d904:	29 f4       	brne	.+10     	; 0xd910 <GSM_Cycle+0x169c>
    d906:	80 91 9a 07 	lds	r24, 0x079A
    d90a:	88 23       	and	r24, r24
    d90c:	09 f4       	brne	.+2      	; 0xd910 <GSM_Cycle+0x169c>
    d90e:	b5 c2       	rjmp	.+1386   	; 0xde7a <GSM_Cycle+0x1c06>
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    d910:	8f ef       	ldi	r24, 0xFF	; 255
    d912:	80 93 fa 06 	sts	0x06FA, r24
	GSM_RX_FIFO_End = 255;
    d916:	80 93 51 06 	sts	0x0651, r24
	GSM_RxCharN = 0;
    d91a:	10 92 18 0b 	sts	0x0B18, r1
	GSM_RX_FIFOOverFlow = 0;
    d91e:	10 92 cb 08 	sts	0x08CB, r1
	GSM_RX_FIFOMax = 0;
    d922:	10 92 d1 08 	sts	0x08D1, r1
						StartTimer16(TD_CleanFIFO,500);
						//break;
					}
				}//while
				//GSM_RxCharN=0;
				if(Timer16Stopp(TD_CleanFIFO)&&(GSM_RX_FIFO_Begin == GSM_RX_FIFO_End)){
    d926:	80 91 ed 04 	lds	r24, 0x04ED
    d92a:	0e 94 06 1c 	call	0x380c	; 0x380c <Timer16Stopp>
    d92e:	88 23       	and	r24, r24
    d930:	b9 f0       	breq	.+46     	; 0xd960 <GSM_Cycle+0x16ec>
    d932:	90 91 fa 06 	lds	r25, 0x06FA
    d936:	80 91 51 06 	lds	r24, 0x0651
    d93a:	98 17       	cp	r25, r24
    d93c:	89 f4       	brne	.+34     	; 0xd960 <GSM_Cycle+0x16ec>
					StartTimer16(TD_CleanFIFO,500);
    d93e:	80 91 ed 04 	lds	r24, 0x04ED
    d942:	64 ef       	ldi	r22, 0xF4	; 244
    d944:	71 e0       	ldi	r23, 0x01	; 1
    d946:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    d94a:	8f ef       	ldi	r24, 0xFF	; 255
    d94c:	80 93 fa 06 	sts	0x06FA, r24
	GSM_RX_FIFO_End = 255;
    d950:	80 93 51 06 	sts	0x0651, r24
	GSM_RxCharN = 0;
    d954:	10 92 18 0b 	sts	0x0B18, r1
	GSM_RX_FIFOOverFlow = 0;
    d958:	10 92 cb 08 	sts	0x08CB, r1
	GSM_RX_FIFOMax = 0;
    d95c:	10 92 d1 08 	sts	0x08D1, r1
				if(Timer16Stopp(TD_CleanFIFO)&&(GSM_RX_FIFO_Begin == GSM_RX_FIFO_End)){
					StartTimer16(TD_CleanFIFO,500);
					InitFIFO();
				}

				if(Timer16Stopp(TD_data_start_delay)){
    d960:	80 91 ee 04 	lds	r24, 0x04EE
    d964:	0e 94 06 1c 	call	0x380c	; 0x380c <Timer16Stopp>
    d968:	88 23       	and	r24, r24
    d96a:	11 f4       	brne	.+4      	; 0xd970 <GSM_Cycle+0x16fc>
    d96c:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
					if(GPRS_FlgSz_Out && (GPRS_FlgSz_Out <= GPRS_Out_MaxSz)&&(GSM_Flag&(1<<flg_TxCStr))&&Timer16Stopp(TD_timer_after_page_transfer)&&(!dataSendFlg)){			
    d970:	80 91 6d 07 	lds	r24, 0x076D
    d974:	88 23       	and	r24, r24
    d976:	11 f4       	brne	.+4      	; 0xd97c <GSM_Cycle+0x1708>
    d978:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
    d97c:	80 91 d2 02 	lds	r24, 0x02D2
    d980:	80 fd       	sbrc	r24, 0
    d982:	02 c0       	rjmp	.+4      	; 0xd988 <GSM_Cycle+0x1714>
    d984:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
    d988:	80 91 ef 04 	lds	r24, 0x04EF
    d98c:	0e 94 06 1c 	call	0x380c	; 0x380c <Timer16Stopp>
    d990:	88 23       	and	r24, r24
    d992:	11 f4       	brne	.+4      	; 0xd998 <GSM_Cycle+0x1724>
    d994:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
    d998:	80 91 df 02 	lds	r24, 0x02DF
    d99c:	88 23       	and	r24, r24
    d99e:	11 f0       	breq	.+4      	; 0xd9a4 <GSM_Cycle+0x1730>
    d9a0:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
							dataSendFlg=1;
    d9a4:	81 e0       	ldi	r24, 0x01	; 1
    d9a6:	80 93 df 02 	sts	0x02DF, r24
							GSM_AddHeaderSendData(GPRS_Data_Out, GPRS_FlgSz_Out);
    d9aa:	8e ef       	ldi	r24, 0xFE	; 254
    d9ac:	98 e0       	ldi	r25, 0x08	; 8
    d9ae:	60 91 6d 07 	lds	r22, 0x076D
    d9b2:	0e 94 47 40 	call	0x808e	; 0x808e <GSM_AddHeaderSendData>
    d9b6:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
			break;

		case GSM_SEND_CIPCSGP:
			//GSM_Execute_Command(AT_CIPCSGP, 300*GSM_DEBUG_DELAY); GSM_State++;
			if(GSM_Flag & (1<<flg_TxCStr)){
				sprintf_P(GSM_TxStr, AT_CIPCSGP);	GSMTxSz = strlen_P(AT_CIPCSGP);
    d9ba:	00 d0       	rcall	.+0      	; 0xd9bc <GSM_Cycle+0x1748>
    d9bc:	0f 92       	push	r0
    d9be:	82 e0       	ldi	r24, 0x02	; 2
    d9c0:	9a e0       	ldi	r25, 0x0A	; 10
    d9c2:	ad b7       	in	r26, 0x3d	; 61
    d9c4:	be b7       	in	r27, 0x3e	; 62
    d9c6:	12 96       	adiw	r26, 0x02	; 2
    d9c8:	9c 93       	st	X, r25
    d9ca:	8e 93       	st	-X, r24
    d9cc:	11 97       	sbiw	r26, 0x01	; 1
    d9ce:	08 e3       	ldi	r16, 0x38	; 56
    d9d0:	15 e0       	ldi	r17, 0x05	; 5
    d9d2:	14 96       	adiw	r26, 0x04	; 4
    d9d4:	1c 93       	st	X, r17
    d9d6:	0e 93       	st	-X, r16
    d9d8:	13 97       	sbiw	r26, 0x03	; 3
    d9da:	0e 94 de 7f 	call	0xffbc	; 0xffbc <sprintf_P>
    d9de:	0f 90       	pop	r0
    d9e0:	0f 90       	pop	r0
    d9e2:	0f 90       	pop	r0
    d9e4:	0f 90       	pop	r0
    d9e6:	c8 01       	movw	r24, r16
    d9e8:	0e 94 c1 7e 	call	0xfd82	; 0xfd82 <strlen_P>
    d9ec:	80 93 75 07 	sts	0x0775, r24
				#if LCDXSz==40
					GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn);
				#else
					GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn1);
    d9f0:	80 91 75 07 	lds	r24, 0x0775
    d9f4:	90 e0       	ldi	r25, 0x00	; 0
    d9f6:	8e 5f       	subi	r24, 0xFE	; 254
    d9f8:	95 4f       	sbci	r25, 0xF5	; 245
    d9fa:	69 e0       	ldi	r22, 0x09	; 9
    d9fc:	70 e0       	ldi	r23, 0x00	; 0
    d9fe:	0e 94 17 61 	call	0xc22e	; 0xc22e <strcpy_EE>
    da02:	90 91 75 07 	lds	r25, 0x0775
    da06:	98 0f       	add	r25, r24
    da08:	90 93 75 07 	sts	0x0775, r25
					GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn2);
    da0c:	80 91 75 07 	lds	r24, 0x0775
    da10:	90 e0       	ldi	r25, 0x00	; 0
    da12:	8e 5f       	subi	r24, 0xFE	; 254
    da14:	95 4f       	sbci	r25, 0xF5	; 245
    da16:	6d e1       	ldi	r22, 0x1D	; 29
    da18:	70 e0       	ldi	r23, 0x00	; 0
    da1a:	0e 94 17 61 	call	0xc22e	; 0xc22e <strcpy_EE>
    da1e:	90 91 75 07 	lds	r25, 0x0775
    da22:	98 0f       	add	r25, r24
    da24:	90 93 75 07 	sts	0x0775, r25
				#endif
				sprintf(GSM_TxStr + GSMTxSz, "\",\"");	GSMTxSz = GSMTxSz+3;				
    da28:	e0 91 75 07 	lds	r30, 0x0775
    da2c:	f0 e0       	ldi	r31, 0x00	; 0
    da2e:	ee 5f       	subi	r30, 0xFE	; 254
    da30:	f5 4f       	sbci	r31, 0xF5	; 245
    da32:	a2 e2       	ldi	r26, 0x22	; 34
    da34:	ea 2e       	mov	r14, r26
    da36:	ac e2       	ldi	r26, 0x2C	; 44
    da38:	fa 2e       	mov	r15, r26
    da3a:	a2 e2       	ldi	r26, 0x22	; 34
    da3c:	0a 2f       	mov	r16, r26
    da3e:	11 2d       	mov	r17, r1
    da40:	e0 82       	st	Z, r14
    da42:	f1 82       	std	Z+1, r15	; 0x01
    da44:	02 83       	std	Z+2, r16	; 0x02
    da46:	13 83       	std	Z+3, r17	; 0x03
    da48:	80 91 75 07 	lds	r24, 0x0775
    da4c:	8d 5f       	subi	r24, 0xFD	; 253
    da4e:	80 93 75 07 	sts	0x0775, r24
				GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn_user_name);
    da52:	80 91 75 07 	lds	r24, 0x0775
    da56:	90 e0       	ldi	r25, 0x00	; 0
    da58:	8e 5f       	subi	r24, 0xFE	; 254
    da5a:	95 4f       	sbci	r25, 0xF5	; 245
    da5c:	69 e5       	ldi	r22, 0x59	; 89
    da5e:	70 e0       	ldi	r23, 0x00	; 0
    da60:	0e 94 17 61 	call	0xc22e	; 0xc22e <strcpy_EE>
    da64:	90 91 75 07 	lds	r25, 0x0775
    da68:	98 0f       	add	r25, r24
    da6a:	90 93 75 07 	sts	0x0775, r25
				sprintf(GSM_TxStr + GSMTxSz, "\",\"");	GSMTxSz = GSMTxSz+3;
    da6e:	e0 91 75 07 	lds	r30, 0x0775
    da72:	f0 e0       	ldi	r31, 0x00	; 0
    da74:	ee 5f       	subi	r30, 0xFE	; 254
    da76:	f5 4f       	sbci	r31, 0xF5	; 245
    da78:	e0 82       	st	Z, r14
    da7a:	f1 82       	std	Z+1, r15	; 0x01
    da7c:	02 83       	std	Z+2, r16	; 0x02
    da7e:	13 83       	std	Z+3, r17	; 0x03
    da80:	80 91 75 07 	lds	r24, 0x0775
    da84:	8d 5f       	subi	r24, 0xFD	; 253
    da86:	80 93 75 07 	sts	0x0775, r24
				GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn_psw);
    da8a:	80 91 75 07 	lds	r24, 0x0775
    da8e:	90 e0       	ldi	r25, 0x00	; 0
    da90:	8e 5f       	subi	r24, 0xFE	; 254
    da92:	95 4f       	sbci	r25, 0xF5	; 245
    da94:	6d e6       	ldi	r22, 0x6D	; 109
    da96:	70 e0       	ldi	r23, 0x00	; 0
    da98:	0e 94 17 61 	call	0xc22e	; 0xc22e <strcpy_EE>
    da9c:	90 91 75 07 	lds	r25, 0x0775
    daa0:	98 0f       	add	r25, r24
    daa2:	90 93 75 07 	sts	0x0775, r25
				sprintf(GSM_TxStr + GSMTxSz, "\"\r");	GSMTxSz = GSMTxSz+2;
    daa6:	80 91 75 07 	lds	r24, 0x0775
    daaa:	e8 2f       	mov	r30, r24
    daac:	f0 e0       	ldi	r31, 0x00	; 0
    daae:	ee 5f       	subi	r30, 0xFE	; 254
    dab0:	f5 4f       	sbci	r31, 0xF5	; 245
    dab2:	a5 eb       	ldi	r26, 0xB5	; 181
    dab4:	b2 e0       	ldi	r27, 0x02	; 2
    dab6:	83 e0       	ldi	r24, 0x03	; 3
    dab8:	0d 90       	ld	r0, X+
    daba:	01 92       	st	Z+, r0
    dabc:	81 50       	subi	r24, 0x01	; 1
    dabe:	e1 f7       	brne	.-8      	; 0xdab8 <GSM_Cycle+0x1844>
    dac0:	80 91 75 07 	lds	r24, 0x0775
    dac4:	8e 5f       	subi	r24, 0xFE	; 254
    dac6:	80 93 75 07 	sts	0x0775, r24
				GSM_SendFirstChar();
    daca:	0e 94 aa 39 	call	0x7354	; 0x7354 <GSM_SendFirstChar>
				StartTimer16(TD_GSM, 300*GSM_DEBUG_DELAY);
    dace:	80 91 e7 04 	lds	r24, 0x04E7
    dad2:	6c e2       	ldi	r22, 0x2C	; 44
    dad4:	71 e0       	ldi	r23, 0x01	; 1
    dad6:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
    dada:	d1 cb       	rjmp	.-2142   	; 0xd27e <GSM_Cycle+0x100a>
		/*	if(Timer16Stopp(TD_TCP_Connect)){	//        CommandMode
				GSM_State = GSM_Swtch2CommandMode;
				break;
			}*/
			//StartTimer16(TD_CheckModem,1000);
			if( (strstr_P(GSM_RxStr, URC_CLOSED+2) != NULL) ){
    dadc:	89 e9       	ldi	r24, 0x99	; 153
    dade:	97 e0       	ldi	r25, 0x07	; 7
    dae0:	64 ed       	ldi	r22, 0xD4	; 212
    dae2:	73 e0       	ldi	r23, 0x03	; 3
    dae4:	0e 94 e3 7e 	call	0xfdc6	; 0xfdc6 <strstr_P>
    dae8:	89 2b       	or	r24, r25
    daea:	11 f4       	brne	.+4      	; 0xdaf0 <GSM_Cycle+0x187c>
    daec:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
				GSM_State =GSM_ReStart1;
    daf0:	8a e4       	ldi	r24, 0x4A	; 74
    daf2:	80 93 b3 06 	sts	0x06B3, r24
    daf6:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
		case GSM_WAIT_CSQ:
				if(Timer16Stopp(TD_GSM)){
						GSM_State = GSM_ReStart1;
				}
				else{				
					if(GetStringFromFIFO()){
    dafa:	0e 94 80 38 	call	0x7100	; 0x7100 <GetStringFromFIFO>
    dafe:	88 23       	and	r24, r24
    db00:	11 f4       	brne	.+4      	; 0xdb06 <GSM_Cycle+0x1892>
    db02:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
						GSM_RSSI = 255; GSM_BER = 255;
    db06:	8f ef       	ldi	r24, 0xFF	; 255
    db08:	80 93 b0 06 	sts	0x06B0, r24
    db0c:	80 93 84 07 	sts	0x0784, r24
						if(strstr_P(GSM_RxStr, RESP_CSQ) != NULL ){
    db10:	09 e9       	ldi	r16, 0x99	; 153
    db12:	17 e0       	ldi	r17, 0x07	; 7
    db14:	c8 01       	movw	r24, r16
    db16:	63 e4       	ldi	r22, 0x43	; 67
    db18:	74 e0       	ldi	r23, 0x04	; 4
    db1a:	0e 94 e3 7e 	call	0xfdc6	; 0xfdc6 <strstr_P>
    db1e:	89 2b       	or	r24, r25
    db20:	11 f4       	brne	.+4      	; 0xdb26 <GSM_Cycle+0x18b2>
    db22:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
							sscanf_P(GSM_RxStr,PSTR("+CSQ: %hhu,%hhu"), (unsigned char*)&GSM_RSSI, (unsigned char*)&GSM_BER);
    db26:	ed b7       	in	r30, 0x3d	; 61
    db28:	fe b7       	in	r31, 0x3e	; 62
    db2a:	38 97       	sbiw	r30, 0x08	; 8
    db2c:	0f b6       	in	r0, 0x3f	; 63
    db2e:	f8 94       	cli
    db30:	fe bf       	out	0x3e, r31	; 62
    db32:	0f be       	out	0x3f, r0	; 63
    db34:	ed bf       	out	0x3d, r30	; 61
    db36:	31 96       	adiw	r30, 0x01	; 1
    db38:	ad b7       	in	r26, 0x3d	; 61
    db3a:	be b7       	in	r27, 0x3e	; 62
    db3c:	12 96       	adiw	r26, 0x02	; 2
    db3e:	1c 93       	st	X, r17
    db40:	0e 93       	st	-X, r16
    db42:	11 97       	sbiw	r26, 0x01	; 1
    db44:	8a ee       	ldi	r24, 0xEA	; 234
    db46:	9b e2       	ldi	r25, 0x2B	; 43
    db48:	93 83       	std	Z+3, r25	; 0x03
    db4a:	82 83       	std	Z+2, r24	; 0x02
    db4c:	80 eb       	ldi	r24, 0xB0	; 176
    db4e:	96 e0       	ldi	r25, 0x06	; 6
    db50:	95 83       	std	Z+5, r25	; 0x05
    db52:	84 83       	std	Z+4, r24	; 0x04
    db54:	84 e8       	ldi	r24, 0x84	; 132
    db56:	97 e0       	ldi	r25, 0x07	; 7
    db58:	97 83       	std	Z+7, r25	; 0x07
    db5a:	86 83       	std	Z+6, r24	; 0x06
    db5c:	0e 94 32 80 	call	0x10064	; 0x10064 <sscanf_P>
									
								GSM_State = GSM_WAIT_CSQ_OK;
    db60:	81 e5       	ldi	r24, 0x51	; 81
    db62:	80 93 b3 06 	sts	0x06B3, r24
    db66:	ed b7       	in	r30, 0x3d	; 61
    db68:	fe b7       	in	r31, 0x3e	; 62
    db6a:	38 96       	adiw	r30, 0x08	; 8
    db6c:	0f b6       	in	r0, 0x3f	; 63
    db6e:	f8 94       	cli
    db70:	fe bf       	out	0x3e, r31	; 62
    db72:	0f be       	out	0x3f, r0	; 63
    db74:	ed bf       	out	0x3d, r30	; 61
    db76:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
				if(++TempNum>=MaxTelephDirSz){
					GSM_State = GSM_Return2dataMode;
					SMS_FlgSz_Out = 0;
					//StartTimer16(TD_GSM,150);
				}
				else GSM_State = GSM_SEND_CMGS;
    db7a:	80 e4       	ldi	r24, 0x40	; 64
    db7c:	80 93 b3 06 	sts	0x06B3, r24
    db80:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
			if(Timer16Stopp(TD_GSM)){
				if(RequestRepeatCounter<4){
				GSM_State = GSM_SEND_PLAY_ALARM_FILE;
				}
				else{
				GSM_State = GSM_SEND_PLAY_NOTCONFIRM_FILE;				
    db84:	80 e2       	ldi	r24, 0x20	; 32
    db86:	80 93 b3 06 	sts	0x06B3, r24
    db8a:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
			}
			break;
		case GSM_WAIT_D2C_SWITCH_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) {

				switch(CommandModeDestination){
    db8e:	84 30       	cpi	r24, 0x04	; 4
    db90:	09 f4       	brne	.+2      	; 0xdb94 <GSM_Cycle+0x1920>
    db92:	93 c0       	rjmp	.+294    	; 0xdcba <GSM_Cycle+0x1a46>
    db94:	85 30       	cpi	r24, 0x05	; 5
    db96:	11 f0       	breq	.+4      	; 0xdb9c <GSM_Cycle+0x1928>
    db98:	0c 94 66 62 	jmp	0xc4cc	; 0xc4cc <GSM_Cycle+0x258>
					case 4:	
						GSM_State = GSM_SEND_ATD_Check_Ballance;
						counter=0;	
						break;
					case 5:	
						GSM_State = GSM_SEND_CSQ;
    db9c:	8f e4       	ldi	r24, 0x4F	; 79
    db9e:	80 93 b3 06 	sts	0x06B3, r24
						counter=0;	
    dba2:	10 92 e0 02 	sts	0x02E0, r1
    dba6:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
			if(GetStringFromFIFO()){
				if(!strcmp_P(GSM_RxStr, GSM_SIMCOM_SIM900R)) GSM_Modem = SIMCOM_SIM900R;
				if(!strcmp_P(GSM_RxStr, GSM_SIMCOM_SIM800)) GSM_Modem = SIMCOM_SIM800;
				if(!strcmp_P(GSM_RxStr, GSM_SIMCOM_SIM800C)) GSM_Modem = SIMCOM_SIM800;
				//Add here new model GSM-modem
				if(GSM_Modem != NOT_RECOGNIZED) GSM_State = GSM_WAIT_CALL_READY;
    dbaa:	80 91 f1 06 	lds	r24, 0x06F1
    dbae:	88 23       	and	r24, r24
    dbb0:	11 f4       	brne	.+4      	; 0xdbb6 <GSM_Cycle+0x1942>
    dbb2:	0c 94 f9 61 	jmp	0xc3f2	; 0xc3f2 <GSM_Cycle+0x17e>
    dbb6:	0c 94 f6 61 	jmp	0xc3ec	; 0xc3ec <GSM_Cycle+0x178>
			}
			GSM_State++;
			break;
		case GSM_WAIT_CIPCSGP_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
			 if(GSM_Modem == SIMCOM_SIM800)GSM_State++;
    dbba:	80 91 b3 06 	lds	r24, 0x06B3
    dbbe:	8f 5f       	subi	r24, 0xFF	; 255
    dbc0:	80 93 b3 06 	sts	0x06B3, r24
    dbc4:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
			GSM_State++; 
			break;
		case GSM_WAIT_CIPMUX_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
				if(GSM_MultiCon){
					GSM_State = GSM_WAIT_1;
    dbc8:	8e e2       	ldi	r24, 0x2E	; 46
    dbca:	80 93 b3 06 	sts	0x06B3, r24
					// between "Call Ready" and "+CMGS"; 8 sec min needs; for kyivstar vpni only
					StartTimer16(TD_GSM, 1000);
    dbce:	80 91 e7 04 	lds	r24, 0x04E7
    dbd2:	68 ee       	ldi	r22, 0xE8	; 232
    dbd4:	73 e0       	ldi	r23, 0x03	; 3
    dbd6:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
    dbda:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
			if(GSM_Wait_Response_P(URC_CPIN_READY, GSM_ReStart1)) GSM_State++;
			break;

		case GSM_WAIT_CALL_READY:
			if(GSM_Wait_Response_P(URC_CALL_READY, GSM_ReStart1)){
				if(GSM_Modem == SIMCOM_SIM800) GSM_State = GSM_WAIT_SMS_READY;
    dbde:	87 e0       	ldi	r24, 0x07	; 7
    dbe0:	80 93 b3 06 	sts	0x06B3, r24
    dbe4:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
				}
			break;
		case GSM_WAIT_CSQ_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) {
				if(CommandModeDestination==5){
					GSM_State  = GSM_Return2dataMode;
    dbe8:	87 e5       	ldi	r24, 0x57	; 87
    dbea:	80 93 b3 06 	sts	0x06B3, r24
    dbee:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
			break;
		case GSM_WAIT_D2C_SWITCH_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) {

				switch(CommandModeDestination){
					case 1:	GSM_State = GSM_SEND_CMGS;
    dbf2:	80 e4       	ldi	r24, 0x40	; 64
    dbf4:	80 93 b3 06 	sts	0x06B3, r24
    dbf8:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
						break;
					case 2:	
						GSM_State = GSM_CIPSHUT_;
    dbfc:	84 e4       	ldi	r24, 0x44	; 68
    dbfe:	80 93 b3 06 	sts	0x06B3, r24
						counter=0;	
    dc02:	10 92 e0 02 	sts	0x02E0, r1
    dc06:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
				GSMTxSz = strlen(GSM_TxStr);
				uint8_t j=0;
				for(uint8_t i=0; i<GSMTxSz; i++)
					if(GSM_TxStr[i] != '0') j++;
				if(j){
					GSMTxSz = strlen_P(AT_CMGS);
    dc0a:	00 ef       	ldi	r16, 0xF0	; 240
    dc0c:	14 e0       	ldi	r17, 0x04	; 4
    dc0e:	c8 01       	movw	r24, r16
    dc10:	0e 94 c1 7e 	call	0xfd82	; 0xfd82 <strlen_P>
    dc14:	80 93 75 07 	sts	0x0775, r24
					sprintf_P(GSM_TxStr, AT_CMGS);
    dc18:	00 d0       	rcall	.+0      	; 0xdc1a <GSM_Cycle+0x19a6>
    dc1a:	0f 92       	push	r0
    dc1c:	ad b7       	in	r26, 0x3d	; 61
    dc1e:	be b7       	in	r27, 0x3e	; 62
    dc20:	12 96       	adiw	r26, 0x02	; 2
    dc22:	fc 92       	st	X, r15
    dc24:	ee 92       	st	-X, r14
    dc26:	11 97       	sbiw	r26, 0x01	; 1
    dc28:	14 96       	adiw	r26, 0x04	; 4
    dc2a:	1c 93       	st	X, r17
    dc2c:	0e 93       	st	-X, r16
    dc2e:	13 97       	sbiw	r26, 0x03	; 3
    dc30:	0e 94 de 7f 	call	0xffbc	; 0xffbc <sprintf_P>
					erbl(GSM_TxStr+GSMTxSz, SMS_Number+TempNum, MaxTelephN);
    dc34:	80 91 75 07 	lds	r24, 0x0775
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    dc38:	0f 90       	pop	r0
    dc3a:	0f 90       	pop	r0
    dc3c:	0f 90       	pop	r0
    dc3e:	0f 90       	pop	r0
    dc40:	90 e0       	ldi	r25, 0x00	; 0
    dc42:	60 91 da 05 	lds	r22, 0x05DA
    dc46:	2d e0       	ldi	r18, 0x0D	; 13
    dc48:	62 9f       	mul	r22, r18
    dc4a:	b0 01       	movw	r22, r0
    dc4c:	11 24       	eor	r1, r1
    dc4e:	6b 53       	subi	r22, 0x3B	; 59
    dc50:	7f 4f       	sbci	r23, 0xFF	; 255
    dc52:	8e 5f       	subi	r24, 0xFE	; 254
    dc54:	95 4f       	sbci	r25, 0xF5	; 245
    dc56:	4d e0       	ldi	r20, 0x0D	; 13
    dc58:	50 e0       	ldi	r21, 0x00	; 0
    dc5a:	0e 94 cb 81 	call	0x10396	; 0x10396 <__eerd_block_m2560>
					GSMTxSz = strlen(GSM_TxStr);
    dc5e:	f7 01       	movw	r30, r14
    dc60:	01 90       	ld	r0, Z+
    dc62:	00 20       	and	r0, r0
    dc64:	e9 f7       	brne	.-6      	; 0xdc60 <GSM_Cycle+0x19ec>
    dc66:	31 97       	sbiw	r30, 0x01	; 1
    dc68:	e2 50       	subi	r30, 0x02	; 2
    dc6a:	fa 40       	sbci	r31, 0x0A	; 10
    dc6c:	e0 93 75 07 	sts	0x0775, r30
					sprintf(GSM_TxStr + GSMTxSz, "\"\r");
    dc70:	80 91 75 07 	lds	r24, 0x0775
    dc74:	e8 2f       	mov	r30, r24
    dc76:	f0 e0       	ldi	r31, 0x00	; 0
    dc78:	ee 5f       	subi	r30, 0xFE	; 254
    dc7a:	f5 4f       	sbci	r31, 0xF5	; 245
    dc7c:	a5 eb       	ldi	r26, 0xB5	; 181
    dc7e:	b2 e0       	ldi	r27, 0x02	; 2
    dc80:	83 e0       	ldi	r24, 0x03	; 3
    dc82:	0d 90       	ld	r0, X+
    dc84:	01 92       	st	Z+, r0
    dc86:	81 50       	subi	r24, 0x01	; 1
    dc88:	e1 f7       	brne	.-8      	; 0xdc82 <GSM_Cycle+0x1a0e>
					GSMTxSz = strlen(GSM_TxStr);
    dc8a:	f7 01       	movw	r30, r14
    dc8c:	01 90       	ld	r0, Z+
    dc8e:	00 20       	and	r0, r0
    dc90:	e9 f7       	brne	.-6      	; 0xdc8c <GSM_Cycle+0x1a18>
    dc92:	31 97       	sbiw	r30, 0x01	; 1
    dc94:	e2 50       	subi	r30, 0x02	; 2
    dc96:	fa 40       	sbci	r31, 0x0A	; 10
    dc98:	e0 93 75 07 	sts	0x0775, r30
					GSM_SendFirstChar();
    dc9c:	0e 94 aa 39 	call	0x7354	; 0x7354 <GSM_SendFirstChar>
					StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    dca0:	80 91 e7 04 	lds	r24, 0x04E7
    dca4:	64 ef       	ldi	r22, 0xF4	; 244
    dca6:	71 e0       	ldi	r23, 0x01	; 1
    dca8:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
					GSM_State++;
    dcac:	80 91 b3 06 	lds	r24, 0x06B3
    dcb0:	8f 5f       	subi	r24, 0xFF	; 255
    dcb2:	80 93 b3 06 	sts	0x06B3, r24
    dcb6:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
					case 2:	
						GSM_State = GSM_CIPSHUT_;
						counter=0;	
						break;						
					case 4:	
						GSM_State = GSM_SEND_ATD_Check_Ballance;
    dcba:	8c e4       	ldi	r24, 0x4C	; 76
    dcbc:	80 93 b3 06 	sts	0x06B3, r24
						counter=0;	
    dcc0:	10 92 e0 02 	sts	0x02E0, r1
    dcc4:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
				if( (strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6,")) != NULL) ){
					StartTimer16(TD_GSM, 6000);
					GSM_State = GSM_WAIT_MESSAGE;
					break;
				}
				if( (strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,3,")) != NULL) ){
    dcc8:	89 e9       	ldi	r24, 0x99	; 153
    dcca:	97 e0       	ldi	r25, 0x07	; 7
    dccc:	6b e2       	ldi	r22, 0x2B	; 43
    dcce:	7d e2       	ldi	r23, 0x2D	; 45
    dcd0:	0e 94 e3 7e 	call	0xfdc6	; 0xfdc6 <strstr_P>
    dcd4:	89 2b       	or	r24, r25
    dcd6:	09 f4       	brne	.+2      	; 0xdcda <GSM_Cycle+0x1a66>
    dcd8:	6a cd       	rjmp	.-1324   	; 0xd7ae <GSM_Cycle+0x153a>
					StartTimer16(TD_GSM, 6000);
    dcda:	80 91 e7 04 	lds	r24, 0x04E7
    dcde:	60 e7       	ldi	r22, 0x70	; 112
    dce0:	77 e1       	ldi	r23, 0x17	; 23
    dce2:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
					GSM_State = GSM_WAIT_CCLC_0;
    dce6:	83 e1       	ldi	r24, 0x13	; 19
    dce8:	80 93 b3 06 	sts	0x06B3, r24
    dcec:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
				GSM_State = GSM_ProtocolMode;
				InitFIFO();
				break;
			}
*/			
			if( (strstr_P(GSM_RxStr, PSTR("OK")) != NULL) ){
    dcf0:	c8 01       	movw	r24, r16
    dcf2:	67 e0       	ldi	r22, 0x07	; 7
    dcf4:	7c e2       	ldi	r23, 0x2C	; 44
    dcf6:	0e 94 e3 7e 	call	0xfdc6	; 0xfdc6 <strstr_P>
    dcfa:	89 2b       	or	r24, r25
    dcfc:	c1 f1       	breq	.+112    	; 0xdd6e <GSM_Cycle+0x1afa>
				StartTimer16(TD_data_start_delay,100);
    dcfe:	80 91 ee 04 	lds	r24, 0x04EE
    dd02:	64 e6       	ldi	r22, 0x64	; 100
    dd04:	70 e0       	ldi	r23, 0x00	; 0
    dd06:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
				GSM_State = GSM_ProtocolMode;
    dd0a:	82 e5       	ldi	r24, 0x52	; 82
    dd0c:	80 93 b3 06 	sts	0x06B3, r24
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    dd10:	8f ef       	ldi	r24, 0xFF	; 255
    dd12:	80 93 fa 06 	sts	0x06FA, r24
	GSM_RX_FIFO_End = 255;
    dd16:	80 93 51 06 	sts	0x0651, r24
	GSM_RxCharN = 0;
    dd1a:	10 92 18 0b 	sts	0x0B18, r1
	GSM_RX_FIFOOverFlow = 0;
    dd1e:	10 92 cb 08 	sts	0x08CB, r1
	GSM_RX_FIFOMax = 0;
    dd22:	10 92 d1 08 	sts	0x08D1, r1
    dd26:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
				if((strstr_P(GSM_RxStr, PSTR("OK")) != NULL) ){
					GSM_State = GSM_WAIT_MESSAGE;

					break;
				}
				if((strstr_P(GSM_RxStr, PSTR("BUSY")) != NULL) ){
    dd2a:	89 e9       	ldi	r24, 0x99	; 153
    dd2c:	97 e0       	ldi	r25, 0x07	; 7
    dd2e:	69 e2       	ldi	r22, 0x29	; 41
    dd30:	7c e2       	ldi	r23, 0x2C	; 44
    dd32:	0e 94 e3 7e 	call	0xfdc6	; 0xfdc6 <strstr_P>
    dd36:	89 2b       	or	r24, r25
    dd38:	09 f4       	brne	.+2      	; 0xdd3c <GSM_Cycle+0x1ac8>
    dd3a:	7c c0       	rjmp	.+248    	; 0xde34 <GSM_Cycle+0x1bc0>
					GSM_State = GSM_WAIT_MESSAGE;
    dd3c:	8e e0       	ldi	r24, 0x0E	; 14
    dd3e:	80 93 b3 06 	sts	0x06B3, r24
    dd42:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
				if((strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,0,")) != NULL) ){
					RequestRepeatCounter = 0;
					GSM_State = GSM_SEND_PLAY_ALARM_FILE;
					break;
				}
				if( (strstr_P(GSM_RxStr, PSTR("+CLCC: 1,0,6,")) != NULL) ){
    dd46:	89 e9       	ldi	r24, 0x99	; 153
    dd48:	97 e0       	ldi	r25, 0x07	; 7
    dd4a:	6f e0       	ldi	r22, 0x0F	; 15
    dd4c:	7d e2       	ldi	r23, 0x2D	; 45
    dd4e:	0e 94 e3 7e 	call	0xfdc6	; 0xfdc6 <strstr_P>
    dd52:	89 2b       	or	r24, r25
    dd54:	09 f4       	brne	.+2      	; 0xdd58 <GSM_Cycle+0x1ae4>
    dd56:	73 cd       	rjmp	.-1306   	; 0xd83e <GSM_Cycle+0x15ca>
					StartTimer16(TD_GSM, 6000);
    dd58:	80 91 e7 04 	lds	r24, 0x04E7
    dd5c:	60 e7       	ldi	r22, 0x70	; 112
    dd5e:	77 e1       	ldi	r23, 0x17	; 23
    dd60:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
					GSM_State = GSM_WAIT_DISCONNECT_CAUSE;
    dd64:	85 e2       	ldi	r24, 0x25	; 37
    dd66:	80 93 b3 06 	sts	0x06B3, r24
    dd6a:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
				break;
			}


			//  
			if( (strstr_P(GSM_RxStr, URC_CONNECT) != NULL) ){
    dd6e:	c8 01       	movw	r24, r16
    dd70:	60 ec       	ldi	r22, 0xC0	; 192
    dd72:	73 e0       	ldi	r23, 0x03	; 3
    dd74:	0e 94 e3 7e 	call	0xfdc6	; 0xfdc6 <strstr_P>
    dd78:	89 2b       	or	r24, r25
    dd7a:	b1 f0       	breq	.+44     	; 0xdda8 <GSM_Cycle+0x1b34>

				GSM_State = GSM_ProtocolMode;
    dd7c:	82 e5       	ldi	r24, 0x52	; 82
    dd7e:	80 93 b3 06 	sts	0x06B3, r24
    dd82:	f8 01       	movw	r30, r16
				for(int i=0;i<GSM_RXSTR_SIZE;i++)
				{
					GSM_RxStr[i]=0;	
    dd84:	11 92       	st	Z+, r1

			//  
			if( (strstr_P(GSM_RxStr, URC_CONNECT) != NULL) ){

				GSM_State = GSM_ProtocolMode;
				for(int i=0;i<GSM_RXSTR_SIZE;i++)
    dd86:	37 e0       	ldi	r19, 0x07	; 7
    dd88:	ed 3f       	cpi	r30, 0xFD	; 253
    dd8a:	f3 07       	cpc	r31, r19
    dd8c:	d9 f7       	brne	.-10     	; 0xdd84 <GSM_Cycle+0x1b10>
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    dd8e:	8f ef       	ldi	r24, 0xFF	; 255
    dd90:	80 93 fa 06 	sts	0x06FA, r24
	GSM_RX_FIFO_End = 255;
    dd94:	80 93 51 06 	sts	0x0651, r24
	GSM_RxCharN = 0;
    dd98:	10 92 18 0b 	sts	0x0B18, r1
	GSM_RX_FIFOOverFlow = 0;
    dd9c:	10 92 cb 08 	sts	0x08CB, r1
	GSM_RX_FIFOMax = 0;
    dda0:	10 92 d1 08 	sts	0x08D1, r1
    dda4:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>

				break;
			}

			//  
			if(strstr_P(GSM_RxStr, URC_CLOSED) != NULL){
    dda8:	c8 01       	movw	r24, r16
    ddaa:	62 ed       	ldi	r22, 0xD2	; 210
    ddac:	73 e0       	ldi	r23, 0x03	; 3
    ddae:	0e 94 e3 7e 	call	0xfdc6	; 0xfdc6 <strstr_P>
    ddb2:	89 2b       	or	r24, r25
    ddb4:	99 f1       	breq	.+102    	; 0xde1c <GSM_Cycle+0x1ba8>
				//  
				sscanf_P(GSM_RxStr,PSTR("%hhu, CLOSED"),(unsigned char*)&TempNum);
    ddb6:	00 d0       	rcall	.+0      	; 0xddb8 <GSM_Cycle+0x1b44>
    ddb8:	00 d0       	rcall	.+0      	; 0xddba <GSM_Cycle+0x1b46>
    ddba:	ed b7       	in	r30, 0x3d	; 61
    ddbc:	fe b7       	in	r31, 0x3e	; 62
    ddbe:	31 96       	adiw	r30, 0x01	; 1
    ddc0:	ad b7       	in	r26, 0x3d	; 61
    ddc2:	be b7       	in	r27, 0x3e	; 62
    ddc4:	12 96       	adiw	r26, 0x02	; 2
    ddc6:	1c 93       	st	X, r17
    ddc8:	0e 93       	st	-X, r16
    ddca:	11 97       	sbiw	r26, 0x01	; 1
    ddcc:	8a ef       	ldi	r24, 0xFA	; 250
    ddce:	9b e2       	ldi	r25, 0x2B	; 43
    ddd0:	93 83       	std	Z+3, r25	; 0x03
    ddd2:	82 83       	std	Z+2, r24	; 0x02
    ddd4:	8a ed       	ldi	r24, 0xDA	; 218
    ddd6:	95 e0       	ldi	r25, 0x05	; 5
    ddd8:	95 83       	std	Z+5, r25	; 0x05
    ddda:	84 83       	std	Z+4, r24	; 0x04
    dddc:	0e 94 32 80 	call	0x10064	; 0x10064 <sscanf_P>
				if(GSM_ActiveConnection == TempNum){
    dde0:	ed b7       	in	r30, 0x3d	; 61
    dde2:	fe b7       	in	r31, 0x3e	; 62
    dde4:	36 96       	adiw	r30, 0x06	; 6
    dde6:	0f b6       	in	r0, 0x3f	; 63
    dde8:	f8 94       	cli
    ddea:	fe bf       	out	0x3e, r31	; 62
    ddec:	0f be       	out	0x3f, r0	; 63
    ddee:	ed bf       	out	0x3d, r30	; 61
    ddf0:	90 91 d3 02 	lds	r25, 0x02D3
    ddf4:	80 91 da 05 	lds	r24, 0x05DA
    ddf8:	98 17       	cp	r25, r24
    ddfa:	59 f4       	brne	.+22     	; 0xde12 <GSM_Cycle+0x1b9e>
					GSM_ActiveConnection = NO_CONNECTION;
    ddfc:	8f ef       	ldi	r24, 0xFF	; 255
    ddfe:	80 93 d3 02 	sts	0x02D3, r24
	uint8_t IP4;
} IP_Addr;

//~~~~~~~~~~~~~~
void SetIP(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	IP->IP1 = IP1;
    de02:	10 92 02 0b 	sts	0x0B02, r1
	IP->IP2 = IP2;
    de06:	10 92 03 0b 	sts	0x0B03, r1
	IP->IP3 = IP3;
    de0a:	10 92 04 0b 	sts	0x0B04, r1
	IP->IP4 = IP4;
    de0e:	10 92 05 0b 	sts	0x0B05, r1
					SetIP(&GSM_ClientIP,0,0,0,0);
				}

				GSM_State = GSM_ReStart1;
    de12:	8a e4       	ldi	r24, 0x4A	; 74
    de14:	80 93 b3 06 	sts	0x06B3, r24
    de18:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
				break;
			}

			// +PDP DEACT
			if( (strstr_P(GSM_RxStr, URC_PDPDEACT) != NULL) ){
    de1c:	c8 01       	movw	r24, r16
    de1e:	6b ed       	ldi	r22, 0xDB	; 219
    de20:	73 e0       	ldi	r23, 0x03	; 3
    de22:	0e 94 e3 7e 	call	0xfdc6	; 0xfdc6 <strstr_P>
    de26:	89 2b       	or	r24, r25
    de28:	91 f0       	breq	.+36     	; 0xde4e <GSM_Cycle+0x1bda>
				GSM_State = GSM_SEND_E0;
    de2a:	88 e0       	ldi	r24, 0x08	; 8
    de2c:	80 93 b3 06 	sts	0x06B3, r24
    de30:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
				if((strstr_P(GSM_RxStr, PSTR("BUSY")) != NULL) ){
					GSM_State = GSM_WAIT_MESSAGE;

					break;
				}
				if((strstr_P(GSM_RxStr, PSTR("NO CARRIER")) != NULL) ){
    de34:	89 e9       	ldi	r24, 0x99	; 153
    de36:	97 e0       	ldi	r25, 0x07	; 7
    de38:	6e e1       	ldi	r22, 0x1E	; 30
    de3a:	7c e2       	ldi	r23, 0x2C	; 44
    de3c:	0e 94 e3 7e 	call	0xfdc6	; 0xfdc6 <strstr_P>
    de40:	89 2b       	or	r24, r25
    de42:	89 f0       	breq	.+34     	; 0xde66 <GSM_Cycle+0x1bf2>
					GSM_State = GSM_WAIT_MESSAGE;
    de44:	8e e0       	ldi	r24, 0x0E	; 14
    de46:	80 93 b3 06 	sts	0x06B3, r24
    de4a:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
			}



			//      
			if(strstr_P(GSM_RxStr, RESP_CSQ) != NULL ){
    de4e:	c8 01       	movw	r24, r16
    de50:	63 e4       	ldi	r22, 0x43	; 67
    de52:	74 e0       	ldi	r23, 0x04	; 4
    de54:	0e 94 e3 7e 	call	0xfdc6	; 0xfdc6 <strstr_P>
    de58:	89 2b       	or	r24, r25
    de5a:	51 f0       	breq	.+20     	; 0xde70 <GSM_Cycle+0x1bfc>
				GSM_State = GSM_WAIT_CSQ;
    de5c:	80 e5       	ldi	r24, 0x50	; 80
    de5e:	80 93 b3 06 	sts	0x06B3, r24
    de62:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
				if((strstr_P(GSM_RxStr, PSTR("NO CARRIER")) != NULL) ){
					GSM_State = GSM_WAIT_MESSAGE;

					break;
				}
				GSM_State = GSM_WAIT_MESSAGE;
    de66:	8e e0       	ldi	r24, 0x0E	; 14
    de68:	80 93 b3 06 	sts	0x06B3, r24
    de6c:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
				GSM_State = GSM_WAIT_CSQ;
				break;
			}

			// 
			GSM_State = GSM_WAIT_IDENTIFICATION;
    de70:	8e e3       	ldi	r24, 0x3E	; 62
    de72:	80 93 b3 06 	sts	0x06B3, r24
    de76:	0c 94 5a 61 	jmp	0xc2b4	; 0xc2b4 <GSM_Cycle+0x40>
						AppProtocol = 0;
						if(!strncmp_P(GSM_RxStr, PSTR("GET "), 4)) {AppProtocol = _HTTP;GSM_State = GSM_DataMode;break;}//GET
						if(!strncmp_P(GSM_RxStr, PSTR("POST"), 4)) {AppProtocol = _HTTP;GSM_State = GSM_DataMode;break;}//POST
						if(!strncmp_P(GSM_RxStr, PSTR("CLOS"), 4)) {AppProtocol = _HTTP;GSM_State = GSM_ReStart1;break;}// 
						if(!strncmp_P(GSM_RxStr, PSTR("+PDP"), 4)) {AppProtocol = _HTTP;GSM_State = GSM_ReStart1;break;}//GPRS 
						if( (GSM_RxStr[0]==0) && (GSM_RxStr[1]==0)){AppProtocol = _HTTP;GSM_State = GSM_ReStart1;break;}//  
    de7a:	81 e0       	ldi	r24, 0x01	; 1
    de7c:	80 93 9f 08 	sts	0x089F, r24
    de80:	8a e4       	ldi	r24, 0x4A	; 74
    de82:	80 93 b3 06 	sts	0x06B3, r24
    de86:	4f cd       	rjmp	.-1378   	; 0xd926 <GSM_Cycle+0x16b2>
							if(!strncmp_P(GSM_RxStr, PSTR("\r\n"), 2)) {GSM_RxCharN=0;}
						}
					if(GSM_RxCharN >= 4){
						AppProtocol = 0;
						if(!strncmp_P(GSM_RxStr, PSTR("GET "), 4)) {AppProtocol = _HTTP;GSM_State = GSM_DataMode;break;}//GET
						if(!strncmp_P(GSM_RxStr, PSTR("POST"), 4)) {AppProtocol = _HTTP;GSM_State = GSM_DataMode;break;}//POST
    de88:	81 e0       	ldi	r24, 0x01	; 1
    de8a:	80 93 9f 08 	sts	0x089F, r24
    de8e:	83 e5       	ldi	r24, 0x53	; 83
    de90:	80 93 b3 06 	sts	0x06B3, r24
    de94:	48 cd       	rjmp	.-1392   	; 0xd926 <GSM_Cycle+0x16b2>

0000de96 <USART_Cycle>:

// ~~~~~~~~~~~~~~
void
USART_Cycle(void)
{
	MB_Cycle();
    de96:	0e 94 bb 37 	call	0x6f76	; 0x6f76 <MB_Cycle>
	#ifdef GSM
		GSM_Cycle();
    de9a:	0e 94 3a 61 	call	0xc274	; 0xc274 <GSM_Cycle>
	#endif
	#ifdef UDP_EASY
		UDP_RxProcess();
	#endif
}
    de9e:	08 95       	ret

0000dea0 <IP_E_compare_Const>:
}
uint8_t IP_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	if((IP->IP1 == IP1) && (IP->IP2 == IP2) && (IP->IP3 == IP3) && (IP->IP4 == IP4)) return 1;
	else return 0;
}
uint8_t IP_E_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
    dea0:	ef 92       	push	r14
    dea2:	ff 92       	push	r15
    dea4:	0f 93       	push	r16
    dea6:	1f 93       	push	r17
    dea8:	cf 93       	push	r28
    deaa:	df 93       	push	r29
    deac:	ec 01       	movw	r28, r24
    deae:	16 2f       	mov	r17, r22
    deb0:	f4 2e       	mov	r15, r20
    deb2:	e2 2e       	mov	r14, r18
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    deb4:	0e 94 db 81 	call	0x103b6	; 0x103b6 <__eerd_byte_m2560>
	if((erb(&IP->IP1) == IP1) && (erb(&IP->IP2) == IP2) && (erb(&IP->IP3) == IP3) && (erb(&IP->IP4) == IP4)) return 1;
    deb8:	18 17       	cp	r17, r24
    deba:	49 f0       	breq	.+18     	; 0xdece <IP_E_compare_Const+0x2e>
	else return 0;
}
    debc:	90 e0       	ldi	r25, 0x00	; 0
    debe:	89 2f       	mov	r24, r25
    dec0:	df 91       	pop	r29
    dec2:	cf 91       	pop	r28
    dec4:	1f 91       	pop	r17
    dec6:	0f 91       	pop	r16
    dec8:	ff 90       	pop	r15
    deca:	ef 90       	pop	r14
    decc:	08 95       	ret
    dece:	ce 01       	movw	r24, r28
    ded0:	01 96       	adiw	r24, 0x01	; 1
    ded2:	0e 94 db 81 	call	0x103b6	; 0x103b6 <__eerd_byte_m2560>
uint8_t IP_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	if((IP->IP1 == IP1) && (IP->IP2 == IP2) && (IP->IP3 == IP3) && (IP->IP4 == IP4)) return 1;
	else return 0;
}
uint8_t IP_E_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	if((erb(&IP->IP1) == IP1) && (erb(&IP->IP2) == IP2) && (erb(&IP->IP3) == IP3) && (erb(&IP->IP4) == IP4)) return 1;
    ded6:	f8 16       	cp	r15, r24
    ded8:	89 f7       	brne	.-30     	; 0xdebc <IP_E_compare_Const+0x1c>
    deda:	ce 01       	movw	r24, r28
    dedc:	02 96       	adiw	r24, 0x02	; 2
    dede:	0e 94 db 81 	call	0x103b6	; 0x103b6 <__eerd_byte_m2560>
    dee2:	e8 16       	cp	r14, r24
    dee4:	59 f7       	brne	.-42     	; 0xdebc <IP_E_compare_Const+0x1c>
    dee6:	ce 01       	movw	r24, r28
    dee8:	03 96       	adiw	r24, 0x03	; 3
    deea:	0e 94 db 81 	call	0x103b6	; 0x103b6 <__eerd_byte_m2560>
    deee:	90 e0       	ldi	r25, 0x00	; 0
    def0:	08 13       	cpse	r16, r24
    def2:	91 e0       	ldi	r25, 0x01	; 1
    def4:	81 e0       	ldi	r24, 0x01	; 1
    def6:	98 27       	eor	r25, r24
    def8:	e2 cf       	rjmp	.-60     	; 0xdebe <IP_E_compare_Const+0x1e>

0000defa <MB_M_Init>:
}

// ~~~~~~~~~~~~~~~~~~~~
void
MB_M_Init(uint8_t MB_N)
{
    defa:	cf 92       	push	r12
    defc:	df 92       	push	r13
    defe:	ef 92       	push	r14
    df00:	ff 92       	push	r15
    df02:	0f 93       	push	r16
    df04:	1f 93       	push	r17
	MB_M_Period[MB_N]		= erw(&MB_M_Param_EE[MB_N].Period);
    df06:	e8 2e       	mov	r14, r24
    df08:	ff 24       	eor	r15, r15
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    df0a:	87 01       	movw	r16, r14
    df0c:	00 0f       	add	r16, r16
    df0e:	11 1f       	adc	r17, r17
    df10:	00 0f       	add	r16, r16
    df12:	11 1f       	adc	r17, r17
    df14:	0e 0d       	add	r16, r14
    df16:	1f 1d       	adc	r17, r15
    df18:	32 e3       	ldi	r19, 0x32	; 50
    df1a:	c3 2e       	mov	r12, r19
    df1c:	31 e0       	ldi	r19, 0x01	; 1
    df1e:	d3 2e       	mov	r13, r19
    df20:	c6 01       	movw	r24, r12
    df22:	80 0f       	add	r24, r16
    df24:	91 1f       	adc	r25, r17
    df26:	0e 94 e9 81 	call	0x103d2	; 0x103d2 <__eerd_word_m2560>
    df2a:	f7 01       	movw	r30, r14
    df2c:	ee 0f       	add	r30, r30
    df2e:	ff 1f       	adc	r31, r31
    df30:	e5 55       	subi	r30, 0x55	; 85
    df32:	f9 4f       	sbci	r31, 0xF9	; 249
    df34:	91 83       	std	Z+1, r25	; 0x01
    df36:	80 83       	st	Z, r24
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    df38:	0e 5f       	subi	r16, 0xFE	; 254
    df3a:	1f 4f       	sbci	r17, 0xFF	; 255
    df3c:	c6 01       	movw	r24, r12
    df3e:	80 0f       	add	r24, r16
    df40:	91 1f       	adc	r25, r17
    df42:	0e 94 db 81 	call	0x103b6	; 0x103b6 <__eerd_byte_m2560>
	MB_M_Timeout[MB_N]	= erb(&MB_M_Param_EE[MB_N].Timeout);
    df46:	f7 01       	movw	r30, r14
    df48:	ef 51       	subi	r30, 0x1F	; 31
    df4a:	f7 4f       	sbci	r31, 0xF7	; 247
    df4c:	80 83       	st	Z, r24
    df4e:	0f 5f       	subi	r16, 0xFF	; 255
    df50:	1f 4f       	sbci	r17, 0xFF	; 255
    df52:	c6 01       	movw	r24, r12
    df54:	80 0f       	add	r24, r16
    df56:	91 1f       	adc	r25, r17
    df58:	0e 94 db 81 	call	0x103b6	; 0x103b6 <__eerd_byte_m2560>
	MB_M_Try[MB_N]			= erb(&MB_M_Param_EE[MB_N].Try);
    df5c:	f7 01       	movw	r30, r14
    df5e:	e5 50       	subi	r30, 0x05	; 5
    df60:	f9 4f       	sbci	r31, 0xF9	; 249
    df62:	80 83       	st	Z, r24
    df64:	0f 5f       	subi	r16, 0xFF	; 255
    df66:	1f 4f       	sbci	r17, 0xFF	; 255
    df68:	c6 01       	movw	r24, r12
    df6a:	80 0f       	add	r24, r16
    df6c:	91 1f       	adc	r25, r17
    df6e:	0e 94 db 81 	call	0x103b6	; 0x103b6 <__eerd_byte_m2560>
	MB_M_TimeOff[MB_N]	= erb(&MB_M_Param_EE[MB_N].TimeOff);
    df72:	2d ed       	ldi	r18, 0xDD	; 221
    df74:	35 e0       	ldi	r19, 0x05	; 5
    df76:	e2 0e       	add	r14, r18
    df78:	f3 1e       	adc	r15, r19
    df7a:	f7 01       	movw	r30, r14
    df7c:	80 83       	st	Z, r24

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    df7e:	80 91 d0 02 	lds	r24, 0x02D0
	VacantTimer16Sys += n;
    df82:	8d 5f       	subi	r24, 0xFD	; 253
    df84:	80 93 d0 02 	sts	0x02D0, r24
    df88:	83 50       	subi	r24, 0x03	; 3

	TD_MB = Timer16SysAlloc(Modbus_Qt*3);
    df8a:	80 93 e6 04 	sts	0x04E6, r24
}
    df8e:	1f 91       	pop	r17
    df90:	0f 91       	pop	r16
    df92:	ff 90       	pop	r15
    df94:	ef 90       	pop	r14
    df96:	df 90       	pop	r13
    df98:	cf 90       	pop	r12
    df9a:	08 95       	ret

0000df9c <MB_S_Init>:
}

// ~~~~~~~~~~~~~~~~~~~~
void
MB_S_Init(uint8_t MB_N)
{
    df9c:	0f 93       	push	r16
    df9e:	1f 93       	push	r17
    dfa0:	08 2f       	mov	r16, r24
    dfa2:	10 e0       	ldi	r17, 0x00	; 0
    dfa4:	c8 01       	movw	r24, r16
    dfa6:	89 5c       	subi	r24, 0xC9	; 201
    dfa8:	9e 4f       	sbci	r25, 0xFE	; 254
    dfaa:	0e 94 db 81 	call	0x103b6	; 0x103b6 <__eerd_byte_m2560>
	#ifndef MB_ADDR_DIP_SW
		MB_NativeAddr[MB_N] = erb(MB_NativeAddr_EE+MB_N);
    dfae:	02 52       	subi	r16, 0x22	; 34
    dfb0:	1a 4f       	sbci	r17, 0xFA	; 250
    dfb2:	f8 01       	movw	r30, r16
    dfb4:	80 83       	st	Z, r24
	#endif
}
    dfb6:	1f 91       	pop	r17
    dfb8:	0f 91       	pop	r16
    dfba:	08 95       	ret

0000dfbc <SetBAUD>:
}

// ~~~~~~~~~~~~~~~~~~
void
SetBAUD(uint8_t MB_N)
{
    dfbc:	ef 92       	push	r14
    dfbe:	ff 92       	push	r15
    dfc0:	0f 93       	push	r16
    dfc2:	1f 93       	push	r17
	BR_Val *ptrBR_Val = BR_Tbl + (MB_BitRate_RAM[MB_N] = erb(&MB_Param[MB_N].BitRate));
    dfc4:	08 2f       	mov	r16, r24
    dfc6:	10 e0       	ldi	r17, 0x00	; 0
    dfc8:	78 01       	movw	r14, r16
    dfca:	ee 0c       	add	r14, r14
    dfcc:	ff 1c       	adc	r15, r15
    dfce:	e0 0e       	add	r14, r16
    dfd0:	f1 1e       	adc	r15, r17
    dfd2:	c7 01       	movw	r24, r14
    dfd4:	8a 5f       	subi	r24, 0xFA	; 250
    dfd6:	9f 4f       	sbci	r25, 0xFF	; 255
    dfd8:	0e 94 db 81 	call	0x103b6	; 0x103b6 <__eerd_byte_m2560>
    dfdc:	98 2f       	mov	r25, r24
    dfde:	f8 01       	movw	r30, r16
    dfe0:	ea 57       	subi	r30, 0x7A	; 122
    dfe2:	f8 4f       	sbci	r31, 0xF8	; 248
    dfe4:	80 83       	st	Z, r24
    dfe6:	83 e0       	ldi	r24, 0x03	; 3
    dfe8:	98 9f       	mul	r25, r24
    dfea:	b0 01       	movw	r22, r0
    dfec:	11 24       	eor	r1, r1
    dfee:	60 5c       	subi	r22, 0xC0	; 192
    dff0:	7c 4f       	sbci	r23, 0xFC	; 252

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    dff2:	00 0f       	add	r16, r16
    dff4:	11 1f       	adc	r17, r17
    dff6:	00 0f       	add	r16, r16
    dff8:	11 1f       	adc	r17, r17
    dffa:	c8 01       	movw	r24, r16
    dffc:	88 0f       	add	r24, r24
    dffe:	99 1f       	adc	r25, r25
    e000:	88 0f       	add	r24, r24
    e002:	99 1f       	adc	r25, r25
    e004:	80 0f       	add	r24, r16
    e006:	91 1f       	adc	r25, r17
    e008:	0a 96       	adiw	r24, 0x0a	; 10
    e00a:	4b e6       	ldi	r20, 0x6B	; 107
    e00c:	5d e2       	ldi	r21, 0x2D	; 45
    e00e:	9a 01       	movw	r18, r20
    e010:	28 0f       	add	r18, r24
    e012:	39 1f       	adc	r19, r25
    e014:	f9 01       	movw	r30, r18
    e016:	a5 91       	lpm	r26, Z+
    e018:	b4 91       	lpm	r27, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    e01a:	fb 01       	movw	r30, r22
    e01c:	24 91       	lpm	r18, Z+
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		USART_Reg(MB_N, ubrrl) = prb((uint8_t*)&ptrBR_Val->UBRR);
    e01e:	2c 93       	st	X, r18

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    e020:	02 97       	sbiw	r24, 0x02	; 2
    e022:	84 0f       	add	r24, r20
    e024:	95 1f       	adc	r25, r21
    e026:	fc 01       	movw	r30, r24
    e028:	a5 91       	lpm	r26, Z+
    e02a:	b4 91       	lpm	r27, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    e02c:	6f 5f       	subi	r22, 0xFF	; 255
    e02e:	7f 4f       	sbci	r23, 0xFF	; 255
    e030:	fb 01       	movw	r30, r22
    e032:	84 91       	lpm	r24, Z+
		USART_Reg(MB_N, ubrrh) = prb((uint8_t*)&ptrBR_Val->UBRR+1);
    e034:	8c 93       	st	X, r24

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    e036:	c7 01       	movw	r24, r14
    e038:	88 0f       	add	r24, r24
    e03a:	99 1f       	adc	r25, r25
    e03c:	8e 57       	subi	r24, 0x7E	; 126
    e03e:	92 4d       	sbci	r25, 0xD2	; 210
    e040:	fc 01       	movw	r30, r24
    e042:	a5 91       	lpm	r26, Z+
    e044:	b4 91       	lpm	r27, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    e046:	6f 5f       	subi	r22, 0xFF	; 255
    e048:	7f 4f       	sbci	r23, 0xFF	; 255
    e04a:	fb 01       	movw	r30, r22
    e04c:	84 91       	lpm	r24, Z+

		*(uint8_t*)prp(&MB_Timer[MB_N].OCR) = prb(&ptrBR_Val->Time35);
    e04e:	8c 93       	st	X, r24
		usart->BAUDCTRLA = prb((uint8_t*)&ptrBR_Val->UBRR);
		usart->BAUDCTRLB = prb((uint8_t*)&ptrBR_Val->UBRR+1) + USART_BSCALE0_bm;

		((TC1_t*)prp(MB_Timer+MB_N))->PER = prw(&ptrBR_Val->Time35);
	#endif
}
    e050:	1f 91       	pop	r17
    e052:	0f 91       	pop	r16
    e054:	ff 90       	pop	r15
    e056:	ef 90       	pop	r14
    e058:	08 95       	ret

0000e05a <Key_MB0_BitRate>:
	{" BAUD: }}}}}bps     ", NULL, F_MB##N##_Baud}																														\
};																																																					\
MenuPage MenuModbus##N = {SetMenu(L_MB##N), 1};

#if Modbus_Qt == 1
	M_Modbus(0)
    e05a:	80 e0       	ldi	r24, 0x00	; 0
    e05c:	0e 94 de 6f 	call	0xdfbc	; 0xdfbc <SetBAUD>
    e060:	08 95       	ret

0000e062 <SetParity>:
// ~~~

// ~~~~~~~~~~~~~~~~~~~~
void
SetParity(uint8_t MB_N)
{
    e062:	ff 92       	push	r15
    e064:	0f 93       	push	r16
    e066:	1f 93       	push	r17
    e068:	cf 93       	push	r28
    e06a:	df 93       	push	r29
	uint8_t Parity = erb(&MB_Param[MB_N].Parity), S_B = erb(&MB_Param[MB_N].StopBits);
    e06c:	c8 2f       	mov	r28, r24
    e06e:	d0 e0       	ldi	r29, 0x00	; 0
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    e070:	8e 01       	movw	r16, r28
    e072:	00 0f       	add	r16, r16
    e074:	11 1f       	adc	r17, r17
    e076:	0c 0f       	add	r16, r28
    e078:	1d 1f       	adc	r17, r29
    e07a:	c8 01       	movw	r24, r16
    e07c:	8c 5f       	subi	r24, 0xFC	; 252
    e07e:	9f 4f       	sbci	r25, 0xFF	; 255
    e080:	0e 94 db 81 	call	0x103b6	; 0x103b6 <__eerd_byte_m2560>
    e084:	f8 2e       	mov	r15, r24
    e086:	0b 5f       	subi	r16, 0xFB	; 251
    e088:	1f 4f       	sbci	r17, 0xFF	; 255
    e08a:	c8 01       	movw	r24, r16
    e08c:	0e 94 db 81 	call	0x103b6	; 0x103b6 <__eerd_byte_m2560>
    e090:	48 2f       	mov	r20, r24
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		uint8_t ucsrc = (~(1<<6) |(1<<2) |(1<<1)) &~(1<<0);
		if (Parity==NoParity) {
    e092:	ff 20       	and	r15, r15
    e094:	e1 f4       	brne	.+56     	; 0xe0ce <SetParity+0x6c>
			ucsrc &=~(1<<5) &~(1<<4);
			switch (S_B) {
    e096:	81 30       	cpi	r24, 0x01	; 1
    e098:	09 f4       	brne	.+2      	; 0xe09c <SetParity+0x3a>
    e09a:	3d c0       	rjmp	.+122    	; 0xe116 <SetParity+0xb4>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    e09c:	ce 01       	movw	r24, r28
    e09e:	88 0f       	add	r24, r24
    e0a0:	99 1f       	adc	r25, r25
    e0a2:	88 0f       	add	r24, r24
    e0a4:	99 1f       	adc	r25, r25
    e0a6:	9c 01       	movw	r18, r24
    e0a8:	22 0f       	add	r18, r18
    e0aa:	33 1f       	adc	r19, r19
    e0ac:	22 0f       	add	r18, r18
    e0ae:	33 1f       	adc	r19, r19
    e0b0:	28 0f       	add	r18, r24
    e0b2:	39 1f       	adc	r19, r25
    e0b4:	2f 58       	subi	r18, 0x8F	; 143
    e0b6:	32 4d       	sbci	r19, 0xD2	; 210
    e0b8:	f9 01       	movw	r30, r18
    e0ba:	a5 91       	lpm	r26, Z+
    e0bc:	b4 91       	lpm	r27, Z+
		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
			ucsrc  |=(1<<7);
		#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
			ucsrc &=~(1<<7);
		#endif
		USART_Reg(MB_N, ucsrc) = ucsrc;
    e0be:	8e e0       	ldi	r24, 0x0E	; 14
    e0c0:	8c 93       	st	X, r24
			}
		}
	#endif
	if (Parity!=NoParity && S_B!=1)
		ewb(&MB_Param[MB_N].StopBits, 1);
}
    e0c2:	df 91       	pop	r29
    e0c4:	cf 91       	pop	r28
    e0c6:	1f 91       	pop	r17
    e0c8:	0f 91       	pop	r16
    e0ca:	ff 90       	pop	r15
    e0cc:	08 95       	ret
				break;
			}
		}
		else {
			ucsrc &=~(1<<3);
			switch (Parity) {
    e0ce:	81 e0       	ldi	r24, 0x01	; 1
    e0d0:	f8 16       	cp	r15, r24
    e0d2:	f9 f0       	breq	.+62     	; 0xe112 <SetParity+0xb0>
			}
		}
	#endif
	if (Parity!=NoParity && S_B!=1)
		ewb(&MB_Param[MB_N].StopBits, 1);
}
    e0d4:	56 e3       	ldi	r21, 0x36	; 54
    e0d6:	ce 01       	movw	r24, r28
    e0d8:	88 0f       	add	r24, r24
    e0da:	99 1f       	adc	r25, r25
    e0dc:	88 0f       	add	r24, r24
    e0de:	99 1f       	adc	r25, r25
    e0e0:	9c 01       	movw	r18, r24
    e0e2:	22 0f       	add	r18, r18
    e0e4:	33 1f       	adc	r19, r19
    e0e6:	22 0f       	add	r18, r18
    e0e8:	33 1f       	adc	r19, r19
    e0ea:	28 0f       	add	r18, r24
    e0ec:	39 1f       	adc	r19, r25
    e0ee:	2f 58       	subi	r18, 0x8F	; 143
    e0f0:	32 4d       	sbci	r19, 0xD2	; 210
    e0f2:	f9 01       	movw	r30, r18
    e0f4:	a5 91       	lpm	r26, Z+
    e0f6:	b4 91       	lpm	r27, Z+
		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
			ucsrc  |=(1<<7);
		#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
			ucsrc &=~(1<<7);
		#endif
		USART_Reg(MB_N, ucsrc) = ucsrc;
    e0f8:	5c 93       	st	X, r21
				usart->CTRLC |=USART_PMODE_ODD_gc;
				break;
			}
		}
	#endif
	if (Parity!=NoParity && S_B!=1)
    e0fa:	41 30       	cpi	r20, 0x01	; 1
    e0fc:	21 f0       	breq	.+8      	; 0xe106 <SetParity+0xa4>
		ewb(&MB_Param[MB_N].StopBits, 1);
    e0fe:	c8 01       	movw	r24, r16
    e100:	61 e0       	ldi	r22, 0x01	; 1
    e102:	0e 94 d3 4b 	call	0x97a6	; 0x97a6 <ewb>
}
    e106:	df 91       	pop	r29
    e108:	cf 91       	pop	r28
    e10a:	1f 91       	pop	r17
    e10c:	0f 91       	pop	r16
    e10e:	ff 90       	pop	r15
    e110:	08 95       	ret
				break;
			}
		}
		else {
			ucsrc &=~(1<<3);
			switch (Parity) {
    e112:	56 e2       	ldi	r21, 0x26	; 38
    e114:	e0 cf       	rjmp	.-64     	; 0xe0d6 <SetParity+0x74>
    e116:	ce 01       	movw	r24, r28
    e118:	88 0f       	add	r24, r24
    e11a:	99 1f       	adc	r25, r25
    e11c:	88 0f       	add	r24, r24
    e11e:	99 1f       	adc	r25, r25
    e120:	9c 01       	movw	r18, r24
    e122:	22 0f       	add	r18, r18
    e124:	33 1f       	adc	r19, r19
    e126:	22 0f       	add	r18, r18
    e128:	33 1f       	adc	r19, r19
    e12a:	28 0f       	add	r18, r24
    e12c:	39 1f       	adc	r19, r25
    e12e:	2f 58       	subi	r18, 0x8F	; 143
    e130:	32 4d       	sbci	r19, 0xD2	; 210
    e132:	f9 01       	movw	r30, r18
    e134:	a5 91       	lpm	r26, Z+
    e136:	b4 91       	lpm	r27, Z+
		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
			ucsrc  |=(1<<7);
		#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
			ucsrc &=~(1<<7);
		#endif
		USART_Reg(MB_N, ucsrc) = ucsrc;
    e138:	86 e0       	ldi	r24, 0x06	; 6
    e13a:	8c 93       	st	X, r24
			}
		}
	#endif
	if (Parity!=NoParity && S_B!=1)
		ewb(&MB_Param[MB_N].StopBits, 1);
}
    e13c:	df 91       	pop	r29
    e13e:	cf 91       	pop	r28
    e140:	1f 91       	pop	r17
    e142:	0f 91       	pop	r16
    e144:	ff 90       	pop	r15
    e146:	08 95       	ret

0000e148 <Key_MB0_Parity>:
    e148:	80 e0       	ldi	r24, 0x00	; 0
    e14a:	0e 94 31 70 	call	0xe062	; 0xe062 <SetParity>
    e14e:	08 95       	ret

0000e150 <MB_Init>:

// ~~~~~~~~~~
void
MB_Init(void)
{
	MB_PLC_Init();
    e150:	0e 94 f4 1d 	call	0x3be8	; 0x3be8 <MB_PLC_Init>
		PORTE.DIR |=(1<<3);
	#endif
	for (uint8_t MB_N=0; MB_N<Modbus_Qt; MB_N++) {
		void MB_S_Init(uint8_t);
		void MB_M_Init(uint8_t);
		MB_State[MB_N] = MB_Initi;
    e154:	10 92 c0 05 	sts	0x05C0, r1
    e158:	8d e6       	ldi	r24, 0x6D	; 109
    e15a:	9d e2       	ldi	r25, 0x2D	; 45
    e15c:	fc 01       	movw	r30, r24
    e15e:	a5 91       	lpm	r26, Z+
    e160:	b4 91       	lpm	r27, Z+
		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
			USART_Reg(MB_N, ucsra) = ~(1<<1) &~(1<<0);
    e162:	8c ef       	ldi	r24, 0xFC	; 252
    e164:	8c 93       	st	X, r24
    e166:	8f e6       	ldi	r24, 0x6F	; 111
    e168:	9d e2       	ldi	r25, 0x2D	; 45
    e16a:	fc 01       	movw	r30, r24
    e16c:	a5 91       	lpm	r26, Z+
    e16e:	b4 91       	lpm	r27, Z+
			USART_Reg(MB_N, ucsrb) = (((1<<7) &~(1<<6) &~(1<<5)) |(1<<4) |(1<<3)) &~(1<<2);
    e170:	88 e9       	ldi	r24, 0x98	; 152
    e172:	8c 93       	st	X, r24
			tc->CTRLD = TC_EVACT_OFF_gc;
			//tc->CTRLE = TC1_BYTEM_bm;
			tc->INTCTRLA |=TC_ERRINTLVL_OFF_gc;
			tc->INTCTRLB = 0;
		#endif
		SetParity(MB_N);
    e174:	80 e0       	ldi	r24, 0x00	; 0
    e176:	0e 94 31 70 	call	0xe062	; 0xe062 <SetParity>
		SetBAUD(MB_N);
    e17a:	80 e0       	ldi	r24, 0x00	; 0
    e17c:	0e 94 de 6f 	call	0xdfbc	; 0xdfbc <SetBAUD>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    e180:	ef e7       	ldi	r30, 0x7F	; 127
    e182:	fd e2       	ldi	r31, 0x2D	; 45
    e184:	84 91       	lpm	r24, Z+
		switch (prb(MB_Role+MB_N)) {
    e186:	88 23       	and	r24, r24
    e188:	59 f4       	brne	.+22     	; 0xe1a0 <MB_Init+0x50>
		case Role_Slave:
			MB_S_Init(MB_N);
    e18a:	80 e0       	ldi	r24, 0x00	; 0
    e18c:	0e 94 ce 6f 	call	0xdf9c	; 0xdf9c <MB_S_Init>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    e190:	84 e8       	ldi	r24, 0x84	; 132
    e192:	9d e2       	ldi	r25, 0x2D	; 45
    e194:	fc 01       	movw	r30, r24
    e196:	25 91       	lpm	r18, Z+
    e198:	34 91       	lpm	r19, Z+
			break;
		case Role_Master:
			MB_M_Init(MB_N);
			break;
		}
		MB_StartTimer(MB_N);
    e19a:	f9 01       	movw	r30, r18
    e19c:	19 95       	eicall
	}
}
    e19e:	08 95       	ret
			tc->INTCTRLA |=TC_ERRINTLVL_OFF_gc;
			tc->INTCTRLB = 0;
		#endif
		SetParity(MB_N);
		SetBAUD(MB_N);
		switch (prb(MB_Role+MB_N)) {
    e1a0:	81 30       	cpi	r24, 0x01	; 1
    e1a2:	b1 f7       	brne	.-20     	; 0xe190 <MB_Init+0x40>
		case Role_Slave:
			MB_S_Init(MB_N);
			break;
		case Role_Master:
			MB_M_Init(MB_N);
    e1a4:	80 e0       	ldi	r24, 0x00	; 0
    e1a6:	0e 94 7d 6f 	call	0xdefa	; 0xdefa <MB_M_Init>
    e1aa:	f2 cf       	rjmp	.-28     	; 0xe190 <MB_Init+0x40>

0000e1ac <USART_Init>:

// ~~~~~~~~~~~~~
void
USART_Init(void)
{
	MB_Init();
    e1ac:	0e 94 a8 70 	call	0xe150	; 0xe150 <MB_Init>
	#ifdef GSM
		GSM_Init();
    e1b0:	0e 94 12 39 	call	0x7224	; 0x7224 <GSM_Init>
	#endif
	#ifdef UDP_EASY
		UDP_Init();
	#endif
}
    e1b4:	08 95       	ret

0000e1b6 <LCDBackLightStartTimer>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    e1b6:	81 e3       	ldi	r24, 0x31	; 49
    e1b8:	91 e0       	ldi	r25, 0x01	; 1
    e1ba:	0e 94 db 81 	call	0x103b6	; 0x103b6 <__eerd_byte_m2560>
			PORT_BACKLIGHT &= ~BACKLIGHT;
		#endif
		IntOn();
	}
	void LCDBackLightStartTimer(void){
		switch(erb(&BackLightTimeEE)){
    e1be:	82 30       	cpi	r24, 0x02	; 2
    e1c0:	e9 f0       	breq	.+58     	; 0xe1fc <LCDBackLightStartTimer+0x46>
    e1c2:	83 30       	cpi	r24, 0x03	; 3
    e1c4:	58 f0       	brcs	.+22     	; 0xe1dc <LCDBackLightStartTimer+0x26>
    e1c6:	83 30       	cpi	r24, 0x03	; 3
    e1c8:	01 f1       	breq	.+64     	; 0xe20a <LCDBackLightStartTimer+0x54>
    e1ca:	84 30       	cpi	r24, 0x04	; 4
    e1cc:	81 f0       	breq	.+32     	; 0xe1ee <LCDBackLightStartTimer+0x38>
				break;	
			case BCKLT_10min:
				StartTimer16(TD_BackLight, 60000);
				break;
			default:
				StartTimer16(TD_BackLight, 3000);
    e1ce:	80 91 d6 04 	lds	r24, 0x04D6
    e1d2:	68 eb       	ldi	r22, 0xB8	; 184
    e1d4:	7b e0       	ldi	r23, 0x0B	; 11
    e1d6:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
    e1da:	08 95       	ret
			PORT_BACKLIGHT &= ~BACKLIGHT;
		#endif
		IntOn();
	}
	void LCDBackLightStartTimer(void){
		switch(erb(&BackLightTimeEE)){
    e1dc:	88 23       	and	r24, r24
    e1de:	b9 f7       	brne	.-18     	; 0xe1ce <LCDBackLightStartTimer+0x18>
			case BCKLT_10sec:
				StartTimer16(TD_BackLight, 1000);
    e1e0:	80 91 d6 04 	lds	r24, 0x04D6
    e1e4:	68 ee       	ldi	r22, 0xE8	; 232
    e1e6:	73 e0       	ldi	r23, 0x03	; 3
    e1e8:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
    e1ec:	08 95       	ret
				break;
			case BCKLT_3min:
				StartTimer16(TD_BackLight, 18000);
				break;	
			case BCKLT_10min:
				StartTimer16(TD_BackLight, 60000);
    e1ee:	80 91 d6 04 	lds	r24, 0x04D6
    e1f2:	60 e6       	ldi	r22, 0x60	; 96
    e1f4:	7a ee       	ldi	r23, 0xEA	; 234
    e1f6:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
    e1fa:	08 95       	ret
				break;
			case BCKLT_30sec:
				StartTimer16(TD_BackLight, 3000);
				break;
			case BCKLT_1min:
				StartTimer16(TD_BackLight, 6000);
    e1fc:	80 91 d6 04 	lds	r24, 0x04D6
    e200:	60 e7       	ldi	r22, 0x70	; 112
    e202:	77 e1       	ldi	r23, 0x17	; 23
    e204:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
    e208:	08 95       	ret
				break;
			case BCKLT_3min:
				StartTimer16(TD_BackLight, 18000);
    e20a:	80 91 d6 04 	lds	r24, 0x04D6
    e20e:	60 e5       	ldi	r22, 0x50	; 80
    e210:	76 e4       	ldi	r23, 0x46	; 70
    e212:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
    e216:	08 95       	ret

0000e218 <LCDBackLightInit>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    e218:	9f b7       	in	r25, 0x3f	; 63
    e21a:	90 78       	andi	r25, 0x80	; 128
    e21c:	90 93 ec 02 	sts	0x02EC, r25
	cli();
    e220:	f8 94       	cli
	enum BACKLIGHT_TIMES{ BCKLT_10sec, BCKLT_30sec, BCKLT_1min,  BCKLT_3min,  BCKLT_10min};
	static uint8_t EEMEM BackLightTimeEE = BCKLT_10sec;

	void LCDBackLightInit(void){
		IntOff();	
		DDR_BACKLIGHT |= BACKLIGHT;
    e222:	80 91 0a 01 	lds	r24, 0x010A
    e226:	80 64       	ori	r24, 0x40	; 64
    e228:	80 93 0a 01 	sts	0x010A, r24

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    e22c:	99 23       	and	r25, r25
    e22e:	09 f0       	breq	.+2      	; 0xe232 <LCDBackLightInit+0x1a>
		sei();
    e230:	78 94       	sei

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    e232:	80 91 d0 02 	lds	r24, 0x02D0
	VacantTimer16Sys += n;
    e236:	8f 5f       	subi	r24, 0xFF	; 255
    e238:	80 93 d0 02 	sts	0x02D0, r24
    e23c:	81 50       	subi	r24, 0x01	; 1
		IntOn();	
		TD_BackLight = Timer16SysAlloc(1);
    e23e:	80 93 d6 04 	sts	0x04D6, r24
		if(BackLightMode != 2){
    e242:	80 91 50 06 	lds	r24, 0x0650
    e246:	82 30       	cpi	r24, 0x02	; 2
    e248:	21 f0       	breq	.+8      	; 0xe252 <LCDBackLightInit+0x3a>
			LCDBackLightOn();
    e24a:	0e 94 d4 27 	call	0x4fa8	; 0x4fa8 <LCDBackLightOn>
			LCDBackLightStartTimer();
    e24e:	0e 94 db 70 	call	0xe1b6	; 0xe1b6 <LCDBackLightStartTimer>
    e252:	08 95       	ret

0000e254 <LCD_Init>:
}

// ~~~~~~~~~~~~
void
LCD_Init (void)
{
    e254:	ef 92       	push	r14
    e256:	ff 92       	push	r15
    e258:	1f 93       	push	r17
    e25a:	cf 93       	push	r28
    e25c:	df 93       	push	r29
	uint8_t i, j;

	// LCD pins
	#ifdef Port_LCD_RW
		Port_LCD_RW &= ~LCD_RW;
    e25e:	43 98       	cbi	0x08, 3	; 8
		DDR_LCD_RW |= LCD_RW;
    e260:	3b 9a       	sbi	0x07, 3	; 7
	#endif

	Port_LCD_RS &= ~LCD_RS;	
    e262:	44 98       	cbi	0x08, 4	; 8
	DDR_LCD_RS |=LCD_RS;
    e264:	3c 9a       	sbi	0x07, 4	; 7

	Port_LCD_E &= ~LCD_E;	
    e266:	42 98       	cbi	0x08, 2	; 8
	DDR_LCD_E |=LCD_E;
    e268:	3a 9a       	sbi	0x07, 2	; 7

	#ifdef Port_LCD_DB0	
		DDR_LCD_DB0 |=DB0;
    e26a:	39 9a       	sbi	0x07, 1	; 7
		DDR_LCD_DB1 |=DB1;
    e26c:	38 9a       	sbi	0x07, 0	; 7
		DDR_LCD_DB2 |=DB2;
    e26e:	99 9a       	sbi	0x13, 1	; 19
		DDR_LCD_DB3 |=DB3;
    e270:	98 9a       	sbi	0x13, 0	; 19
	#endif
	DDR_LCD_DB4 |=DB4;
    e272:	57 9a       	sbi	0x0a, 7	; 10
	DDR_LCD_DB5 |=DB5;
    e274:	56 9a       	sbi	0x0a, 6	; 10
	DDR_LCD_DB6 |=DB6;
    e276:	55 9a       	sbi	0x0a, 5	; 10
	DDR_LCD_DB7 |=DB7;
    e278:	80 91 0a 01 	lds	r24, 0x010A
    e27c:	80 68       	ori	r24, 0x80	; 128
    e27e:	80 93 0a 01 	sts	0x010A, r24
    e282:	21 e3       	ldi	r18, 0x31	; 49
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    e284:	40 ea       	ldi	r20, 0xA0	; 160
    e286:	5f e0       	ldi	r21, 0x0F	; 15
    e288:	ca 01       	movw	r24, r20
    e28a:	01 97       	sbiw	r24, 0x01	; 1
    e28c:	f1 f7       	brne	.-4      	; 0xe28a <LCD_Init+0x36>

// ~~~~~~~~~~~~~~~~~~~~
void
Delay_ms(uint8_t Delay)
{
	while (Delay--)
    e28e:	21 50       	subi	r18, 0x01	; 1
    e290:	d8 f7       	brcc	.-10     	; 0xe288 <LCD_Init+0x34>
#endif
// ~~~~~~~~~~~
static void
LCD_Rst0(void)
{
	cli();
    e292:	f8 94       	cli
	Port_LCD_RS &=~LCD_RS;
    e294:	44 98       	cbi	0x08, 4	; 8
	LCD_FuncSet0();
    e296:	0e 94 2e 26 	call	0x4c5c	; 0x4c5c <LCD_FuncSet0>
	sei();
    e29a:	78 94       	sei
    e29c:	80 ea       	ldi	r24, 0xA0	; 160
    e29e:	9f e0       	ldi	r25, 0x0F	; 15
    e2a0:	fc 01       	movw	r30, r24
    e2a2:	31 97       	sbiw	r30, 0x01	; 1
    e2a4:	f1 f7       	brne	.-4      	; 0xe2a2 <LCD_Init+0x4e>
    e2a6:	fc 01       	movw	r30, r24
    e2a8:	31 97       	sbiw	r30, 0x01	; 1
    e2aa:	f1 f7       	brne	.-4      	; 0xe2a8 <LCD_Init+0x54>
    e2ac:	fc 01       	movw	r30, r24
    e2ae:	31 97       	sbiw	r30, 0x01	; 1
    e2b0:	f1 f7       	brne	.-4      	; 0xe2ae <LCD_Init+0x5a>
    e2b2:	fc 01       	movw	r30, r24
    e2b4:	31 97       	sbiw	r30, 0x01	; 1
    e2b6:	f1 f7       	brne	.-4      	; 0xe2b4 <LCD_Init+0x60>
    e2b8:	01 97       	sbiw	r24, 0x01	; 1
    e2ba:	f1 f7       	brne	.-4      	; 0xe2b8 <LCD_Init+0x64>

// ~~~~~~~~~~~
static void
LCD_Rst1(void)
{
	LCD_FuncSet0();
    e2bc:	0e 94 2e 26 	call	0x4c5c	; 0x4c5c <LCD_FuncSet0>
	Delay_us(200);				// 100 us needs
    e2c0:	88 ec       	ldi	r24, 0xC8	; 200
    e2c2:	90 e0       	ldi	r25, 0x00	; 0
    e2c4:	0e 94 dc 1d 	call	0x3bb8	; 0x3bb8 <Delay_us>
	LCD_FuncSet0();
    e2c8:	0e 94 2e 26 	call	0x4c5c	; 0x4c5c <LCD_FuncSet0>
	Delay_us(LCD_Delay);
    e2cc:	82 e3       	ldi	r24, 0x32	; 50
    e2ce:	90 e0       	ldi	r25, 0x00	; 0
    e2d0:	0e 94 dc 1d 	call	0x3bb8	; 0x3bb8 <Delay_us>
	#ifdef Port_LCD_DB0	
		LCD_FuncSet0();
    e2d4:	0e 94 2e 26 	call	0x4c5c	; 0x4c5c <LCD_FuncSet0>
	#else
		LCD_FuncSet1();
	#endif
//// BF(Busy flag) can be checked follow
	Delay_us(LCD_Delay);
    e2d8:	82 e3       	ldi	r24, 0x32	; 50
    e2da:	90 e0       	ldi	r25, 0x00	; 0
    e2dc:	0e 94 dc 1d 	call	0x3bb8	; 0x3bb8 <Delay_us>
	Port_LCD_RS |=LCD_RS;
    e2e0:	44 9a       	sbi	0x08, 4	; 8

	LCD_Rst0();
	Delay_ms(5);		// 4.1 ms needs
	LCD_Rst1();

	Port_LCD_RS &=~LCD_RS;
    e2e2:	44 98       	cbi	0x08, 4	; 8

	#ifdef Port_LCD_DB0	
		Send_I(0b00111000);	//; 8-bits DL, 2 lines, 5x7 dots
    e2e4:	88 e3       	ldi	r24, 0x38	; 56
    e2e6:	0e 94 27 26 	call	0x4c4e	; 0x4c4e <Send_I>
	#else
		Send_I(0b00101000);	//; 4-bits DL, 2 lines, 5x7 dots
	#endif
	Send_I(0b00001100);	//; Display on, cursor off, blink off	
    e2ea:	8c e0       	ldi	r24, 0x0C	; 12
    e2ec:	0e 94 27 26 	call	0x4c4e	; 0x4c4e <Send_I>
	Send_I(0b00000110);	//; cursor shift right, no display shift
    e2f0:	86 e0       	ldi	r24, 0x06	; 6
    e2f2:	0e 94 27 26 	call	0x4c4e	; 0x4c4e <Send_I>


	Send_I(0b01000000);	//;    CG RAM   0.
    e2f6:	80 e4       	ldi	r24, 0x40	; 64
    e2f8:	0e 94 27 26 	call	0x4c4e	; 0x4c4e <Send_I>
	Port_LCD_RS |=LCD_RS;
    e2fc:	44 9a       	sbi	0x08, 4	; 8
    e2fe:	82 e9       	ldi	r24, 0x92	; 146
    e300:	e8 2e       	mov	r14, r24
    e302:	8d e2       	ldi	r24, 0x2D	; 45
    e304:	f8 2e       	mov	r15, r24
	for (i=0; i<8; i++)
    e306:	e7 01       	movw	r28, r14
    e308:	10 e0       	ldi	r17, 0x00	; 0

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    e30a:	fe 01       	movw	r30, r28
    e30c:	84 91       	lpm	r24, Z+
		for (j=0; j<8; j++)
			Send_I(prb(CGRAM_LCD[i]+j));
    e30e:	0e 94 27 26 	call	0x4c4e	; 0x4c4e <Send_I>


	Send_I(0b01000000);	//;    CG RAM   0.
	Port_LCD_RS |=LCD_RS;
	for (i=0; i<8; i++)
		for (j=0; j<8; j++)
    e312:	1f 5f       	subi	r17, 0xFF	; 255
    e314:	21 96       	adiw	r28, 0x01	; 1
    e316:	18 30       	cpi	r17, 0x08	; 8
    e318:	c1 f7       	brne	.-16     	; 0xe30a <LCD_Init+0xb6>
    e31a:	88 e0       	ldi	r24, 0x08	; 8
    e31c:	90 e0       	ldi	r25, 0x00	; 0
    e31e:	e8 0e       	add	r14, r24
    e320:	f9 1e       	adc	r15, r25
	Send_I(0b00000110);	//; cursor shift right, no display shift


	Send_I(0b01000000);	//;    CG RAM   0.
	Port_LCD_RS |=LCD_RS;
	for (i=0; i<8; i++)
    e322:	92 ed       	ldi	r25, 0xD2	; 210
    e324:	e9 16       	cp	r14, r25
    e326:	9d e2       	ldi	r25, 0x2D	; 45
    e328:	f9 06       	cpc	r15, r25
    e32a:	69 f7       	brne	.-38     	; 0xe306 <LCD_Init+0xb2>
		for (j=0; j<8; j++)
			Send_I(prb(CGRAM_LCD[i]+j));

	Port_LCD_RS &=~LCD_RS;
    e32c:	44 98       	cbi	0x08, 4	; 8
	Send(0b00000001);
    e32e:	81 e0       	ldi	r24, 0x01	; 1
    e330:	0e 94 e6 25 	call	0x4bcc	; 0x4bcc <Send>
    e334:	80 ea       	ldi	r24, 0xA0	; 160
    e336:	9f e0       	ldi	r25, 0x0F	; 15
    e338:	fc 01       	movw	r30, r24
    e33a:	31 97       	sbiw	r30, 0x01	; 1
    e33c:	f1 f7       	brne	.-4      	; 0xe33a <LCD_Init+0xe6>
    e33e:	fc 01       	movw	r30, r24
    e340:	31 97       	sbiw	r30, 0x01	; 1
    e342:	f1 f7       	brne	.-4      	; 0xe340 <LCD_Init+0xec>
    e344:	fc 01       	movw	r30, r24
    e346:	31 97       	sbiw	r30, 0x01	; 1
    e348:	f1 f7       	brne	.-4      	; 0xe346 <LCD_Init+0xf2>
    e34a:	fc 01       	movw	r30, r24
    e34c:	31 97       	sbiw	r30, 0x01	; 1
    e34e:	f1 f7       	brne	.-4      	; 0xe34c <LCD_Init+0xf8>
    e350:	01 97       	sbiw	r24, 0x01	; 1
    e352:	f1 f7       	brne	.-4      	; 0xe350 <LCD_Init+0xfc>
	Delay_ms(5);				// By trial
	Port_LCD_RS |=LCD_RS;
    e354:	44 9a       	sbi	0x08, 4	; 8
}

uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    e356:	80 91 cf 02 	lds	r24, 0x02CF
	VacantTimer8Sys += n;
    e35a:	8f 5f       	subi	r24, 0xFF	; 255
    e35c:	80 93 cf 02 	sts	0x02CF, r24
    e360:	81 50       	subi	r24, 0x01	; 1

	// Frame Timer
	TD_LCD = Timer8SysAlloc(1);
    e362:	80 93 d5 04 	sts	0x04D5, r24
    e366:	20 e0       	ldi	r18, 0x00	; 0
    e368:	30 e0       	ldi	r19, 0x00	; 0

	for (i=0; i<LCDYSz; i++)
		for (j=0; j<LCDXSz; j++)
			LCD_Buf[i][j] = ' ';
    e36a:	40 e2       	ldi	r20, 0x20	; 32
	Port_LCD_RS |=LCD_RS;

	// Frame Timer
	TD_LCD = Timer8SysAlloc(1);

	for (i=0; i<LCDYSz; i++)
    e36c:	c9 01       	movw	r24, r18
    e36e:	88 0f       	add	r24, r24
    e370:	99 1f       	adc	r25, r25
    e372:	82 0f       	add	r24, r18
    e374:	93 1f       	adc	r25, r19
    e376:	fc 01       	movw	r30, r24
    e378:	ee 0f       	add	r30, r30
    e37a:	ff 1f       	adc	r31, r31
    e37c:	ee 0f       	add	r30, r30
    e37e:	ff 1f       	adc	r31, r31
    e380:	ee 0f       	add	r30, r30
    e382:	ff 1f       	adc	r31, r31
    e384:	e8 1b       	sub	r30, r24
    e386:	f9 0b       	sbc	r31, r25
    e388:	ea 5a       	subi	r30, 0xAA	; 170
    e38a:	f9 4f       	sbci	r31, 0xF9	; 249
    e38c:	80 e0       	ldi	r24, 0x00	; 0
		for (j=0; j<LCDXSz; j++)
			LCD_Buf[i][j] = ' ';
    e38e:	41 93       	st	Z+, r20

	// Frame Timer
	TD_LCD = Timer8SysAlloc(1);

	for (i=0; i<LCDYSz; i++)
		for (j=0; j<LCDXSz; j++)
    e390:	8f 5f       	subi	r24, 0xFF	; 255
    e392:	84 31       	cpi	r24, 0x14	; 20
    e394:	e1 f7       	brne	.-8      	; 0xe38e <LCD_Init+0x13a>
    e396:	2f 5f       	subi	r18, 0xFF	; 255
    e398:	3f 4f       	sbci	r19, 0xFF	; 255
	Port_LCD_RS |=LCD_RS;

	// Frame Timer
	TD_LCD = Timer8SysAlloc(1);

	for (i=0; i<LCDYSz; i++)
    e39a:	24 30       	cpi	r18, 0x04	; 4
    e39c:	31 05       	cpc	r19, r1
    e39e:	31 f7       	brne	.-52     	; 0xe36c <LCD_Init+0x118>
		for (j=0; j<LCDXSz; j++)
			LCD_Buf[i][j] = ' ';

	#ifdef RTYP
		#ifndef QslRD
			*(uint8_t*)RTYP = R_PLC_Type;
    e3a0:	87 e0       	ldi	r24, 0x07	; 7
    e3a2:	80 93 49 08 	sts	0x0849, r24
		#endif	
	#endif

	#ifdef BACKLIGHT
		LCDBackLightInit();
    e3a6:	0e 94 0c 71 	call	0xe218	; 0xe218 <LCDBackLightInit>
	#endif
}
    e3aa:	df 91       	pop	r29
    e3ac:	cf 91       	pop	r28
    e3ae:	1f 91       	pop	r17
    e3b0:	ff 90       	pop	r15
    e3b2:	ef 90       	pop	r14
    e3b4:	08 95       	ret

0000e3b6 <RTC_Summer_Time>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    e3b6:	83 e0       	ldi	r24, 0x03	; 3
    e3b8:	90 e0       	ldi	r25, 0x00	; 0
    e3ba:	0e 94 db 81 	call	0x103b6	; 0x103b6 <__eerd_byte_m2560>
	
	return 0;
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void RTC_Summer_Time(void){
	if(erb(&SummerTime)){
    e3be:	88 23       	and	r24, r24
    e3c0:	31 f0       	breq	.+12     	; 0xe3ce <RTC_Summer_Time+0x18>
		//   ()  02:00:00   03:00:00    
		if( (Tm_Mon == 3) && (Tm_WDay == 0) && (Tm_MDay>=25) && (Tm_Hour == 2) ){
    e3c2:	90 91 85 07 	lds	r25, 0x0785
    e3c6:	93 30       	cpi	r25, 0x03	; 3
    e3c8:	b1 f0       	breq	.+44     	; 0xe3f6 <RTC_Summer_Time+0x40>
				Tm_Hour=3;
				SetHour();
		}

		//   ()  04:00:00   03:00:00    
		if( (Tm_Mon == 10) && (Tm_WDay == 0) && (Tm_MDay>=25) ){
    e3ca:	9a 30       	cpi	r25, 0x0A	; 10
    e3cc:	09 f0       	breq	.+2      	; 0xe3d0 <RTC_Summer_Time+0x1a>
    e3ce:	08 95       	ret
    e3d0:	80 91 55 06 	lds	r24, 0x0655
    e3d4:	88 23       	and	r24, r24
    e3d6:	d9 f7       	brne	.-10     	; 0xe3ce <RTC_Summer_Time+0x18>
    e3d8:	80 91 17 0b 	lds	r24, 0x0B17
    e3dc:	89 31       	cpi	r24, 0x19	; 25
    e3de:	b8 f3       	brcs	.-18     	; 0xe3ce <RTC_Summer_Time+0x18>
				if(Tm_Hour == 4){
    e3e0:	80 91 bf 05 	lds	r24, 0x05BF
    e3e4:	84 30       	cpi	r24, 0x04	; 4
    e3e6:	d1 f0       	breq	.+52     	; 0xe41c <RTC_Summer_Time+0x66>
						Tm_Hour=3;
						SetHour();
						NotSummerTimeFlag = 1;
					}
				}
				if(Tm_Hour < 2) NotSummerTimeFlag = 0;
    e3e8:	82 30       	cpi	r24, 0x02	; 2
    e3ea:	38 f1       	brcs	.+78     	; 0xe43a <RTC_Summer_Time+0x84>
				if(Tm_Hour >= 5) NotSummerTimeFlag = 0;
    e3ec:	85 30       	cpi	r24, 0x05	; 5
    e3ee:	78 f3       	brcs	.-34     	; 0xe3ce <RTC_Summer_Time+0x18>
    e3f0:	10 92 db 05 	sts	0x05DB, r1
    e3f4:	08 95       	ret
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void RTC_Summer_Time(void){
	if(erb(&SummerTime)){
		//   ()  02:00:00   03:00:00    
		if( (Tm_Mon == 3) && (Tm_WDay == 0) && (Tm_MDay>=25) && (Tm_Hour == 2) ){
    e3f6:	80 91 55 06 	lds	r24, 0x0655
    e3fa:	88 23       	and	r24, r24
    e3fc:	41 f7       	brne	.-48     	; 0xe3ce <RTC_Summer_Time+0x18>
    e3fe:	80 91 17 0b 	lds	r24, 0x0B17
    e402:	89 31       	cpi	r24, 0x19	; 25
    e404:	20 f3       	brcs	.-56     	; 0xe3ce <RTC_Summer_Time+0x18>
    e406:	80 91 bf 05 	lds	r24, 0x05BF
    e40a:	82 30       	cpi	r24, 0x02	; 2
    e40c:	01 f7       	brne	.-64     	; 0xe3ce <RTC_Summer_Time+0x18>
				Tm_Hour=3;
    e40e:	90 93 bf 05 	sts	0x05BF, r25
				SetHour();
    e412:	0e 94 ba 23 	call	0x4774	; 0x4774 <SetHour>
    e416:	90 91 85 07 	lds	r25, 0x0785
    e41a:	d7 cf       	rjmp	.-82     	; 0xe3ca <RTC_Summer_Time+0x14>
		}

		//   ()  04:00:00   03:00:00    
		if( (Tm_Mon == 10) && (Tm_WDay == 0) && (Tm_MDay>=25) ){
				if(Tm_Hour == 4){
					if(!NotSummerTimeFlag){
    e41c:	80 91 db 05 	lds	r24, 0x05DB
    e420:	88 23       	and	r24, r24
    e422:	a9 f6       	brne	.-86     	; 0xe3ce <RTC_Summer_Time+0x18>
						Tm_Hour=3;
    e424:	83 e0       	ldi	r24, 0x03	; 3
    e426:	80 93 bf 05 	sts	0x05BF, r24
						SetHour();
    e42a:	0e 94 ba 23 	call	0x4774	; 0x4774 <SetHour>
						NotSummerTimeFlag = 1;
    e42e:	81 e0       	ldi	r24, 0x01	; 1
    e430:	80 93 db 05 	sts	0x05DB, r24
    e434:	80 91 bf 05 	lds	r24, 0x05BF
    e438:	d7 cf       	rjmp	.-82     	; 0xe3e8 <RTC_Summer_Time+0x32>
					}
				}
				if(Tm_Hour < 2) NotSummerTimeFlag = 0;
    e43a:	10 92 db 05 	sts	0x05DB, r1
    e43e:	d6 cf       	rjmp	.-84     	; 0xe3ec <RTC_Summer_Time+0x36>

0000e440 <TWI_In>:
}

// ~~~~~~~~~
void
TWI_In(void)
{
    e440:	cf 92       	push	r12
    e442:	ef 92       	push	r14
    e444:	0f 93       	push	r16
	if(Timer8Stopp(TD_TWI_Poll)){
    e446:	00 91 d0 04 	lds	r16, 0x04D0
    e44a:	80 2f       	mov	r24, r16
    e44c:	0e 94 e3 1b 	call	0x37c6	; 0x37c6 <Timer8Stopp>
    e450:	88 23       	and	r24, r24
    e452:	e1 f0       	breq	.+56     	; 0xe48c <TWI_In+0x4c>

		if (TWI_Phase == PCF_START){
    e454:	80 91 7d 07 	lds	r24, 0x077D
    e458:	88 23       	and	r24, r24
    e45a:	99 f1       	breq	.+102    	; 0xe4c2 <TWI_In+0x82>
			StartTWI();		// Send Start
			TWI_Phase++;
			StartTimer8(TD_TWI_Timeout,40);
			return;
		}
		if(Timer8Stopp(TD_TWI_Timeout)){	// 
    e45c:	80 91 d1 04 	lds	r24, 0x04D1
    e460:	0e 94 e3 1b 	call	0x37c6	; 0x37c6 <Timer8Stopp>
    e464:	88 23       	and	r24, r24
    e466:	09 f0       	breq	.+2      	; 0xe46a <TWI_In+0x2a>
    e468:	4e c0       	rjmp	.+156    	; 0xe506 <TWI_In+0xc6>
			TWI_Error();
			return;
		}

		if (!(TWCR &(1<<TWINT))) return;
    e46a:	80 91 bc 00 	lds	r24, 0x00BC
    e46e:	87 ff       	sbrs	r24, 7
    e470:	33 c0       	rjmp	.+102    	; 0xe4d8 <TWI_In+0x98>

		switch(TWI_Phase) {
    e472:	40 91 7d 07 	lds	r20, 0x077D
    e476:	84 2f       	mov	r24, r20
    e478:	90 e0       	ldi	r25, 0x00	; 0
    e47a:	fc 01       	movw	r30, r24
    e47c:	31 97       	sbiw	r30, 0x01	; 1
    e47e:	e1 31       	cpi	r30, 0x11	; 17
    e480:	f1 05       	cpc	r31, r1
    e482:	08 f4       	brcc	.+2      	; 0xe486 <TWI_In+0x46>
    e484:	46 c0       	rjmp	.+140    	; 0xe512 <TWI_In+0xd2>
			Tm_WDay = SetWeekday(Tm_Year, Tm_Mon, Tm_MDay);
			StartTimer8(TD_TWI_Poll, 49);
			TWI_Phase = 0xFF;
			break;
		}
		TWI_Phase++;
    e486:	4f 5f       	subi	r20, 0xFF	; 255
    e488:	40 93 7d 07 	sts	0x077D, r20
	}//Timer8Stopp(TD_TWI)

	if( Timer16Stopp(TD_RTC_Check) && (TWI_Phase == PCF_START) ){
    e48c:	00 91 d2 04 	lds	r16, 0x04D2
    e490:	80 2f       	mov	r24, r16
    e492:	0e 94 06 1c 	call	0x380c	; 0x380c <Timer16Stopp>
    e496:	88 23       	and	r24, r24
    e498:	f9 f0       	breq	.+62     	; 0xe4d8 <TWI_In+0x98>
    e49a:	80 91 7d 07 	lds	r24, 0x077D
    e49e:	88 23       	and	r24, r24
    e4a0:	d9 f4       	brne	.+54     	; 0xe4d8 <TWI_In+0x98>
		StartTimer16(TD_RTC_Check, 300);
    e4a2:	80 2f       	mov	r24, r16
    e4a4:	6c e2       	ldi	r22, 0x2C	; 44
    e4a6:	71 e0       	ldi	r23, 0x01	; 1
    e4a8:	0e 94 ca 1a 	call	0x3594	; 0x3594 <StartTimer16>
		if(RTC_Check() || PFC_Stop_bit){
    e4ac:	0e 94 df 24 	call	0x49be	; 0x49be <RTC_Check>
    e4b0:	88 23       	and	r24, r24
    e4b2:	b1 f4       	brne	.+44     	; 0xe4e0 <TWI_In+0xa0>
    e4b4:	80 91 d3 04 	lds	r24, 0x04D3
    e4b8:	88 23       	and	r24, r24
    e4ba:	91 f4       	brne	.+36     	; 0xe4e0 <TWI_In+0xa0>
			// RTC
			SetDateTime(TrueTime_Year, TrueTime_Mon, TrueTime_MDay, TrueTime_WDay, TrueTime_Hour, TrueTime_Min, TrueTime_Sec);
		}
		else RTC_GetTrueTime();
    e4bc:	0e 94 96 24 	call	0x492c	; 0x492c <RTC_GetTrueTime>
    e4c0:	1f c0       	rjmp	.+62     	; 0xe500 <TWI_In+0xc0>
TWI_In(void)
{
	if(Timer8Stopp(TD_TWI_Poll)){

		if (TWI_Phase == PCF_START){
			StartTWI();		// Send Start
    e4c2:	84 ea       	ldi	r24, 0xA4	; 164
    e4c4:	80 93 bc 00 	sts	0x00BC, r24
			TWI_Phase++;
    e4c8:	81 e0       	ldi	r24, 0x01	; 1
    e4ca:	80 93 7d 07 	sts	0x077D, r24
			StartTimer8(TD_TWI_Timeout,40);
    e4ce:	80 91 d1 04 	lds	r24, 0x04D1
    e4d2:	68 e2       	ldi	r22, 0x28	; 40
    e4d4:	0e 94 8f 1a 	call	0x351e	; 0x351e <StartTimer8>
		}
		else RTC_GetTrueTime();

		RTC_Summer_Time();
	}
}
    e4d8:	0f 91       	pop	r16
    e4da:	ef 90       	pop	r14
    e4dc:	cf 90       	pop	r12
    e4de:	08 95       	ret

	if( Timer16Stopp(TD_RTC_Check) && (TWI_Phase == PCF_START) ){
		StartTimer16(TD_RTC_Check, 300);
		if(RTC_Check() || PFC_Stop_bit){
			// RTC
			SetDateTime(TrueTime_Year, TrueTime_Mon, TrueTime_MDay, TrueTime_WDay, TrueTime_Hour, TrueTime_Min, TrueTime_Sec);
    e4e0:	80 91 7b 07 	lds	r24, 0x077B
    e4e4:	60 91 cd 08 	lds	r22, 0x08CD
    e4e8:	40 91 54 06 	lds	r20, 0x0654
    e4ec:	20 91 16 0b 	lds	r18, 0x0B16
    e4f0:	00 91 d6 05 	lds	r16, 0x05D6
    e4f4:	e0 90 ce 08 	lds	r14, 0x08CE
    e4f8:	c0 90 cc 08 	lds	r12, 0x08CC
    e4fc:	0e 94 e2 23 	call	0x47c4	; 0x47c4 <SetDateTime>
		}
		else RTC_GetTrueTime();

		RTC_Summer_Time();
    e500:	0e 94 db 71 	call	0xe3b6	; 0xe3b6 <RTC_Summer_Time>
    e504:	e9 cf       	rjmp	.-46     	; 0xe4d8 <TWI_In+0x98>
			Tm_Mon = DecodBCD(TWDR & 0b00011111);
			if(Tm_Mon > 12) Tm_Mon = 0;	//
			RunTWI();		//NACK
			break;
		case PCF_Year:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_NACK){ TWI_Error(); return;}
    e506:	0e 94 17 23 	call	0x462e	; 0x462e <TWI_Error>
		}
		else RTC_GetTrueTime();

		RTC_Summer_Time();
	}
}
    e50a:	0f 91       	pop	r16
    e50c:	ef 90       	pop	r14
    e50e:	cf 90       	pop	r12
    e510:	08 95       	ret
			return;
		}

		if (!(TWCR &(1<<TWINT))) return;

		switch(TWI_Phase) {
    e512:	ea 5a       	subi	r30, 0xAA	; 170
    e514:	fe 4f       	sbci	r31, 0xFE	; 254
    e516:	ee 0f       	add	r30, r30
    e518:	ff 1f       	adc	r31, r31
    e51a:	05 90       	lpm	r0, Z+
    e51c:	f4 91       	lpm	r31, Z+
    e51e:	e0 2d       	mov	r30, r0
    e520:	19 94       	eijmp
		case PFC_ACKN:
			AcknTWI();
			break;

		case PCF_Se:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
    e522:	80 91 b9 00 	lds	r24, 0x00B9
    e526:	88 7f       	andi	r24, 0xF8	; 248
    e528:	80 35       	cpi	r24, 0x50	; 80
    e52a:	69 f7       	brne	.-38     	; 0xe506 <TWI_In+0xc6>
			Tm_Sec = DecodBCD(TWDR & 0b01111111);	// exclude ST bit
    e52c:	20 91 bb 00 	lds	r18, 0x00BB
    e530:	82 2f       	mov	r24, r18
    e532:	8f 77       	andi	r24, 0x7F	; 127
    e534:	82 95       	swap	r24
    e536:	8f 70       	andi	r24, 0x0F	; 15
    e538:	3a e0       	ldi	r19, 0x0A	; 10
    e53a:	83 9f       	mul	r24, r19
    e53c:	c0 01       	movw	r24, r0
    e53e:	11 24       	eor	r1, r1
    e540:	2f 70       	andi	r18, 0x0F	; 15
    e542:	28 0f       	add	r18, r24
    e544:	20 93 b4 06 	sts	0x06B4, r18
			PFC_Stop_bit = TWDR & 0b10000000;
    e548:	80 91 bb 00 	lds	r24, 0x00BB
    e54c:	80 78       	andi	r24, 0x80	; 128
    e54e:	80 93 d3 04 	sts	0x04D3, r24
/*			if(PFC_Stop_bit) NoTickCnt++;
			else NoTickCnt=0;*/
			AcknTWI();
    e552:	84 ec       	ldi	r24, 0xC4	; 196
    e554:	80 93 bc 00 	sts	0x00BC, r24
    e558:	96 cf       	rjmp	.-212    	; 0xe486 <TWI_In+0x46>

		case PCF_REAP_START1:
			StartTWI();
			break;
		case PCF_CHECK_REAP_START1:
			if( (TWSR & 0b11111000) != TWI_STATUS_RP_START){ TWI_Error(); return;}
    e55a:	80 91 b9 00 	lds	r24, 0x00B9
    e55e:	88 7f       	andi	r24, 0xF8	; 248
    e560:	80 31       	cpi	r24, 0x10	; 16
    e562:	89 f6       	brne	.-94     	; 0xe506 <TWI_In+0xc6>
    e564:	48 e0       	ldi	r20, 0x08	; 8
			else TWI_Phase++;

		case PCF_SLA_R:
			SLA_R(PCF_SLA);
    e566:	81 ed       	ldi	r24, 0xD1	; 209
    e568:	80 93 bb 00 	sts	0x00BB, r24
			RunTWI();
    e56c:	84 e8       	ldi	r24, 0x84	; 132
    e56e:	80 93 bc 00 	sts	0x00BC, r24
    e572:	89 cf       	rjmp	.-238    	; 0xe486 <TWI_In+0x46>
		case PCF_Addr:
			TWDR = AddrSec;
			RunTWI();
			break;
		case PCF_CHECK_Addr:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATATX_ACK){ TWI_Error(); return;}
    e574:	80 91 b9 00 	lds	r24, 0x00B9
    e578:	88 7f       	andi	r24, 0xF8	; 248
    e57a:	88 32       	cpi	r24, 0x28	; 40
    e57c:	21 f6       	brne	.-120    	; 0xe506 <TWI_In+0xc6>
    e57e:	46 e0       	ldi	r20, 0x06	; 6
			else TWI_Phase++;

		case PCF_REAP_START1:
			StartTWI();
    e580:	84 ea       	ldi	r24, 0xA4	; 164
    e582:	80 93 bc 00 	sts	0x00BC, r24
    e586:	7f cf       	rjmp	.-258    	; 0xe486 <TWI_In+0x46>
		case PCF_SLA_W:
			SLA_W(PCF_SLA);
			RunTWI();
			break;
		case PCF_CHECK_SLA_W:
			if( (TWSR & 0b11111000) != TWI_STATUS_SLAW_ACK){ TWI_Error(); return;}
    e588:	80 91 b9 00 	lds	r24, 0x00B9
    e58c:	88 7f       	andi	r24, 0xF8	; 248
    e58e:	88 31       	cpi	r24, 0x18	; 24
    e590:	09 f0       	breq	.+2      	; 0xe594 <TWI_In+0x154>
    e592:	b9 cf       	rjmp	.-142    	; 0xe506 <TWI_In+0xc6>
    e594:	44 e0       	ldi	r20, 0x04	; 4
			else TWI_Phase++;

		case PCF_Addr:
			TWDR = AddrSec;
    e596:	10 92 bb 00 	sts	0x00BB, r1
			RunTWI();
    e59a:	84 e8       	ldi	r24, 0x84	; 132
    e59c:	80 93 bc 00 	sts	0x00BC, r24
    e5a0:	72 cf       	rjmp	.-284    	; 0xe486 <TWI_In+0x46>
		if (!(TWCR &(1<<TWINT))) return;

		switch(TWI_Phase) {
		
		case PCF_CHECK_START:
			if( (TWSR & 0b11111000) != TWI_STATUS_START){ TWI_Error(); return;}
    e5a2:	80 91 b9 00 	lds	r24, 0x00B9
    e5a6:	88 7f       	andi	r24, 0xF8	; 248
    e5a8:	88 30       	cpi	r24, 0x08	; 8
    e5aa:	09 f0       	breq	.+2      	; 0xe5ae <TWI_In+0x16e>
    e5ac:	ac cf       	rjmp	.-168    	; 0xe506 <TWI_In+0xc6>
    e5ae:	42 e0       	ldi	r20, 0x02	; 2
			else TWI_Phase++;
			
		case PCF_SLA_W:
			SLA_W(PCF_SLA);
    e5b0:	80 ed       	ldi	r24, 0xD0	; 208
    e5b2:	80 93 bb 00 	sts	0x00BB, r24
			RunTWI();
    e5b6:	84 e8       	ldi	r24, 0x84	; 132
    e5b8:	80 93 bc 00 	sts	0x00BC, r24
    e5bc:	64 cf       	rjmp	.-312    	; 0xe486 <TWI_In+0x46>
		case PCF_SLA_R:
			SLA_R(PCF_SLA);
			RunTWI();
			break;
		case PCF_CHECK_SLA_R:
			if( (TWSR & 0b11111000) != TWI_STATUS_SLAR_ACK){ TWI_Error(); return;}
    e5be:	80 91 b9 00 	lds	r24, 0x00B9
    e5c2:	88 7f       	andi	r24, 0xF8	; 248
    e5c4:	80 34       	cpi	r24, 0x40	; 64
    e5c6:	09 f0       	breq	.+2      	; 0xe5ca <TWI_In+0x18a>
    e5c8:	9e cf       	rjmp	.-196    	; 0xe506 <TWI_In+0xc6>
    e5ca:	4a e0       	ldi	r20, 0x0A	; 10
    e5cc:	c2 cf       	rjmp	.-124    	; 0xe552 <TWI_In+0x112>
			Tm_Mon = DecodBCD(TWDR & 0b00011111);
			if(Tm_Mon > 12) Tm_Mon = 0;	//
			RunTWI();		//NACK
			break;
		case PCF_Year:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_NACK){ TWI_Error(); return;}
    e5ce:	80 91 b9 00 	lds	r24, 0x00B9
    e5d2:	88 7f       	andi	r24, 0xF8	; 248
    e5d4:	88 35       	cpi	r24, 0x58	; 88
    e5d6:	09 f0       	breq	.+2      	; 0xe5da <TWI_In+0x19a>
    e5d8:	96 cf       	rjmp	.-212    	; 0xe506 <TWI_In+0xc6>
			Tm_Year = DecodBCD(TWDR);
    e5da:	80 91 bb 00 	lds	r24, 0x00BB

// ~~~~~~~~~~~~~~~~~~
uint8_t
DecodBCD(uint8_t BCD)
{
	return 10*(BCD>>4)+(BCD&0x0F);
    e5de:	28 2f       	mov	r18, r24
    e5e0:	22 95       	swap	r18
    e5e2:	2f 70       	andi	r18, 0x0F	; 15
    e5e4:	9a e0       	ldi	r25, 0x0A	; 10
    e5e6:	29 9f       	mul	r18, r25
    e5e8:	90 01       	movw	r18, r0
    e5ea:	11 24       	eor	r1, r1
    e5ec:	8f 70       	andi	r24, 0x0F	; 15
    e5ee:	82 0f       	add	r24, r18
    e5f0:	80 93 dc 05 	sts	0x05DC, r24
			StopTWI();
    e5f4:	94 e9       	ldi	r25, 0x94	; 148
    e5f6:	90 93 bc 00 	sts	0x00BC, r25
			Tm_WDay = SetWeekday(Tm_Year, Tm_Mon, Tm_MDay);
    e5fa:	60 91 85 07 	lds	r22, 0x0785
    e5fe:	40 91 17 0b 	lds	r20, 0x0B17
    e602:	0e 94 7a 23 	call	0x46f4	; 0x46f4 <SetWeekday>
    e606:	80 93 55 06 	sts	0x0655, r24
			StartTimer8(TD_TWI_Poll, 49);
    e60a:	80 2f       	mov	r24, r16
    e60c:	61 e3       	ldi	r22, 0x31	; 49
    e60e:	0e 94 8f 1a 	call	0x351e	; 0x351e <StartTimer8>
    e612:	4f ef       	ldi	r20, 0xFF	; 255
    e614:	38 cf       	rjmp	.-400    	; 0xe486 <TWI_In+0x46>
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
			Tm_MDay = DecodBCD(TWDR & 0b00111111);
			AcknTWI();
			break;
		case PCF_Mo:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
    e616:	80 91 b9 00 	lds	r24, 0x00B9
    e61a:	88 7f       	andi	r24, 0xF8	; 248
    e61c:	80 35       	cpi	r24, 0x50	; 80
    e61e:	09 f0       	breq	.+2      	; 0xe622 <TWI_In+0x1e2>
    e620:	72 cf       	rjmp	.-284    	; 0xe506 <TWI_In+0xc6>
			Tm_Mon = DecodBCD(TWDR & 0b00011111);
    e622:	80 91 bb 00 	lds	r24, 0x00BB
    e626:	28 2f       	mov	r18, r24
    e628:	2f 71       	andi	r18, 0x1F	; 31
    e62a:	22 95       	swap	r18
    e62c:	2f 70       	andi	r18, 0x0F	; 15
    e62e:	9a e0       	ldi	r25, 0x0A	; 10
    e630:	29 9f       	mul	r18, r25
    e632:	90 01       	movw	r18, r0
    e634:	11 24       	eor	r1, r1
    e636:	8f 70       	andi	r24, 0x0F	; 15
    e638:	82 0f       	add	r24, r18
    e63a:	80 93 85 07 	sts	0x0785, r24
			if(Tm_Mon > 12) Tm_Mon = 0;	//
    e63e:	8d 30       	cpi	r24, 0x0D	; 13
    e640:	10 f0       	brcs	.+4      	; 0xe646 <TWI_In+0x206>
    e642:	10 92 85 07 	sts	0x0785, r1
			RunTWI();		//NACK
    e646:	84 e8       	ldi	r24, 0x84	; 132
    e648:	80 93 bc 00 	sts	0x00BC, r24
    e64c:	1c cf       	rjmp	.-456    	; 0xe486 <TWI_In+0x46>
			TWDR;
			//Tm_WDay = DecodBCD(TWDR & 0b00000111); Ignore 
			AcknTWI();
			break;
		case PCF_MDay:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
    e64e:	80 91 b9 00 	lds	r24, 0x00B9
    e652:	88 7f       	andi	r24, 0xF8	; 248
    e654:	80 35       	cpi	r24, 0x50	; 80
    e656:	09 f0       	breq	.+2      	; 0xe65a <TWI_In+0x21a>
    e658:	56 cf       	rjmp	.-340    	; 0xe506 <TWI_In+0xc6>
			Tm_MDay = DecodBCD(TWDR & 0b00111111);
    e65a:	20 91 bb 00 	lds	r18, 0x00BB
    e65e:	82 2f       	mov	r24, r18
    e660:	8f 73       	andi	r24, 0x3F	; 63
    e662:	82 95       	swap	r24
    e664:	8f 70       	andi	r24, 0x0F	; 15
    e666:	3a e0       	ldi	r19, 0x0A	; 10
    e668:	83 9f       	mul	r24, r19
    e66a:	c0 01       	movw	r24, r0
    e66c:	11 24       	eor	r1, r1
    e66e:	2f 70       	andi	r18, 0x0F	; 15
    e670:	28 0f       	add	r18, r24
    e672:	20 93 17 0b 	sts	0x0B17, r18
			AcknTWI();
    e676:	84 ec       	ldi	r24, 0xC4	; 196
    e678:	80 93 bc 00 	sts	0x00BC, r24
    e67c:	04 cf       	rjmp	.-504    	; 0xe486 <TWI_In+0x46>
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
			Tm_Hour = DecodBCD(TWDR & 0b00111111);
			AcknTWI();
			break;
		case PCF_WDay:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
    e67e:	80 91 b9 00 	lds	r24, 0x00B9
    e682:	88 7f       	andi	r24, 0xF8	; 248
    e684:	80 35       	cpi	r24, 0x50	; 80
    e686:	09 f0       	breq	.+2      	; 0xe68a <TWI_In+0x24a>
    e688:	3e cf       	rjmp	.-388    	; 0xe506 <TWI_In+0xc6>
			TWDR;
    e68a:	80 91 bb 00 	lds	r24, 0x00BB
			//Tm_WDay = DecodBCD(TWDR & 0b00000111); Ignore 
			AcknTWI();
    e68e:	84 ec       	ldi	r24, 0xC4	; 196
    e690:	80 93 bc 00 	sts	0x00BC, r24
    e694:	f8 ce       	rjmp	.-528    	; 0xe486 <TWI_In+0x46>
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
			Tm_Min = DecodBCD(TWDR & 0b01111111);
			AcknTWI();
			break;
		case PCF_Ho:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
    e696:	80 91 b9 00 	lds	r24, 0x00B9
    e69a:	88 7f       	andi	r24, 0xF8	; 248
    e69c:	80 35       	cpi	r24, 0x50	; 80
    e69e:	09 f0       	breq	.+2      	; 0xe6a2 <TWI_In+0x262>
    e6a0:	32 cf       	rjmp	.-412    	; 0xe506 <TWI_In+0xc6>
			Tm_Hour = DecodBCD(TWDR & 0b00111111);
    e6a2:	20 91 bb 00 	lds	r18, 0x00BB
    e6a6:	82 2f       	mov	r24, r18
    e6a8:	8f 73       	andi	r24, 0x3F	; 63
    e6aa:	82 95       	swap	r24
    e6ac:	8f 70       	andi	r24, 0x0F	; 15
    e6ae:	3a e0       	ldi	r19, 0x0A	; 10
    e6b0:	83 9f       	mul	r24, r19
    e6b2:	c0 01       	movw	r24, r0
    e6b4:	11 24       	eor	r1, r1
    e6b6:	2f 70       	andi	r18, 0x0F	; 15
    e6b8:	28 0f       	add	r18, r24
    e6ba:	20 93 bf 05 	sts	0x05BF, r18
			AcknTWI();
    e6be:	84 ec       	ldi	r24, 0xC4	; 196
    e6c0:	80 93 bc 00 	sts	0x00BC, r24
    e6c4:	e0 ce       	rjmp	.-576    	; 0xe486 <TWI_In+0x46>
/*			if(PFC_Stop_bit) NoTickCnt++;
			else NoTickCnt=0;*/
			AcknTWI();
			break;
		case PCF_Mi:
			if( (TWSR & 0b11111000) != TWI_STATUS_DATARX_ACK){ TWI_Error(); return;}
    e6c6:	80 91 b9 00 	lds	r24, 0x00B9
    e6ca:	88 7f       	andi	r24, 0xF8	; 248
    e6cc:	80 35       	cpi	r24, 0x50	; 80
    e6ce:	09 f0       	breq	.+2      	; 0xe6d2 <TWI_In+0x292>
    e6d0:	1a cf       	rjmp	.-460    	; 0xe506 <TWI_In+0xc6>
			Tm_Min = DecodBCD(TWDR & 0b01111111);
    e6d2:	20 91 bb 00 	lds	r18, 0x00BB
    e6d6:	82 2f       	mov	r24, r18
    e6d8:	8f 77       	andi	r24, 0x7F	; 127
    e6da:	82 95       	swap	r24
    e6dc:	8f 70       	andi	r24, 0x0F	; 15
    e6de:	3a e0       	ldi	r19, 0x0A	; 10
    e6e0:	83 9f       	mul	r24, r19
    e6e2:	c0 01       	movw	r24, r0
    e6e4:	11 24       	eor	r1, r1
    e6e6:	2f 70       	andi	r18, 0x0F	; 15
    e6e8:	28 0f       	add	r18, r24
    e6ea:	20 93 4f 06 	sts	0x064F, r18
			AcknTWI();
    e6ee:	84 ec       	ldi	r24, 0xC4	; 196
    e6f0:	80 93 bc 00 	sts	0x00BC, r24
    e6f4:	c8 ce       	rjmp	.-624    	; 0xe486 <TWI_In+0x46>

0000e6f6 <TimeInit>:

// ~~~~~~~~
void
WdtOn(void)
{
	wdt_reset();
    e6f6:	a8 95       	wdr
	wdt_enable(WDTO_2S);
    e6f8:	2f e0       	ldi	r18, 0x0F	; 15
    e6fa:	88 e1       	ldi	r24, 0x18	; 24
    e6fc:	90 e0       	ldi	r25, 0x00	; 0
    e6fe:	0f b6       	in	r0, 0x3f	; 63
    e700:	f8 94       	cli
    e702:	a8 95       	wdr
    e704:	80 93 60 00 	sts	0x0060, r24
    e708:	0f be       	out	0x3f, r0	; 63
    e70a:	20 93 60 00 	sts	0x0060, r18

	// WDT
	WdtOn();

	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TCCR1A = 0;
    e70e:	10 92 80 00 	sts	0x0080, r1
		TCCR1B = (((~(1<<WGM13) |(1<<WGM12)) &~(1<<CS12)) |(1<<CS11)) &~(1<<CS10);
    e712:	8a ee       	ldi	r24, 0xEA	; 234
    e714:	80 93 81 00 	sts	0x0081, r24
		OCR1A = 20000;
    e718:	80 e2       	ldi	r24, 0x20	; 32
    e71a:	9e e4       	ldi	r25, 0x4E	; 78
    e71c:	90 93 89 00 	sts	0x0089, r25
    e720:	80 93 88 00 	sts	0x0088, r24
		TCC0.CTRLE = ~TC0_BYTEM_bm;
	#endif
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__)
		TIMSK |=(1<<OCIE1A);
	#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TIMSK1 |=(1<<OCIE1A);
    e724:	80 91 6f 00 	lds	r24, 0x006F
    e728:	82 60       	ori	r24, 0x02	; 2
    e72a:	80 93 6f 00 	sts	0x006F, r24
    e72e:	80 e0       	ldi	r24, 0x00	; 0
    e730:	90 e0       	ldi	r25, 0x00	; 0
	#endif

	// Program timers (10 ms)
	uint8_t i;
	for (i=0; i<sizeof(Timer8Flg); i++)
		Timer8Flg[i] = 0xFF;
    e732:	2f ef       	ldi	r18, 0xFF	; 255
    e734:	fc 01       	movw	r30, r24
    e736:	e1 55       	subi	r30, 0x51	; 81
    e738:	fb 4f       	sbci	r31, 0xFB	; 251
    e73a:	20 83       	st	Z, r18
    e73c:	01 96       	adiw	r24, 0x01	; 1
		TCC0.INTCTRLB = 0;
	#endif

	// Program timers (10 ms)
	uint8_t i;
	for (i=0; i<sizeof(Timer8Flg); i++)
    e73e:	8c 30       	cpi	r24, 0x0C	; 12
    e740:	91 05       	cpc	r25, r1
    e742:	c1 f7       	brne	.-16     	; 0xe734 <TimeInit+0x3e>
    e744:	80 e0       	ldi	r24, 0x00	; 0
    e746:	90 e0       	ldi	r25, 0x00	; 0
		Timer8Flg[i] = 0xFF;
	for (i=0; i<sizeof(Timer16Flg); i++)
		Timer16Flg[i] = 0xFF;
    e748:	3f ef       	ldi	r19, 0xFF	; 255
    e74a:	fc 01       	movw	r30, r24
    e74c:	e5 54       	subi	r30, 0x45	; 69
    e74e:	fb 4f       	sbci	r31, 0xFB	; 251
    e750:	2f ef       	ldi	r18, 0xFF	; 255
    e752:	30 83       	st	Z, r19
    e754:	01 96       	adiw	r24, 0x01	; 1

	// Program timers (10 ms)
	uint8_t i;
	for (i=0; i<sizeof(Timer8Flg); i++)
		Timer8Flg[i] = 0xFF;
	for (i=0; i<sizeof(Timer16Flg); i++)
    e756:	8d 30       	cpi	r24, 0x0D	; 13
    e758:	91 05       	cpc	r25, r1
    e75a:	b9 f7       	brne	.-18     	; 0xe74a <TimeInit+0x54>
		Timer16Flg[i] = 0xFF;
	for (i=0; i<sizeof(Timer32Flg); i++)
		Timer32Flg[i] = 0xFF;
    e75c:	20 93 c8 04 	sts	0x04C8, r18
    e760:	20 93 c9 04 	sts	0x04C9, r18
    e764:	20 93 ca 04 	sts	0x04CA, r18
    e768:	20 93 cb 04 	sts	0x04CB, r18
    e76c:	20 93 cc 04 	sts	0x04CC, r18
    e770:	20 93 cd 04 	sts	0x04CD, r18
    e774:	8d e3       	ldi	r24, 0x3D	; 61
    e776:	91 e0       	ldi	r25, 0x01	; 1
    e778:	0e 94 db 81 	call	0x103b6	; 0x103b6 <__eerd_byte_m2560>

	// 1 s
	Timer1min = erb(&Timer1min_EE);
    e77c:	80 93 ae 06 	sts	0x06AE, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    e780:	8e e3       	ldi	r24, 0x3E	; 62
    e782:	91 e0       	ldi	r25, 0x01	; 1
    e784:	0e 94 e9 81 	call	0x103d2	; 0x103d2 <__eerd_word_m2560>
	Timer1hour = erw(&Timer1hour_EE);
    e788:	90 93 24 0c 	sts	0x0C24, r25
    e78c:	80 93 23 0c 	sts	0x0C23, r24

	// Application
	#ifdef InitTimer
		StartTimer16(InitTimer, InitTime);
	#endif
}
    e790:	08 95       	ret

0000e792 <MemCheckInit>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    e792:	8c e3       	ldi	r24, 0x3C	; 60
    e794:	91 e0       	ldi	r25, 0x01	; 1
    e796:	0e 94 db 81 	call	0x103b6	; 0x103b6 <__eerd_byte_m2560>
// ~~~~~~~~~~~~~~~
void
MemCheckInit(void)
{
//	TD_Mem = Timer32SysAlloc(1);
	if (!erb(&MemCheck_stor.ReprogFlg)) {
    e79a:	81 11       	cpse	r24, r1
    e79c:	08 95       	ret
		eeprom_write_word(&MemCheck_stor.CRC_Flash_stor, CRC_Flash_calc());
    e79e:	0e 94 8b 19 	call	0x3316	; 0x3316 <CRC_Flash_calc>
    e7a2:	bc 01       	movw	r22, r24
    e7a4:	88 e3       	ldi	r24, 0x38	; 56
    e7a6:	91 e0       	ldi	r25, 0x01	; 1
    e7a8:	0e 94 0f 82 	call	0x1041e	; 0x1041e <__eewr_word_m2560>
		eeprom_write_word(&MemCheck_stor.CRC_EEPROM_stor, CRC_EEPROM_calc());
    e7ac:	0e 94 a5 19 	call	0x334a	; 0x334a <CRC_EEPROM_calc>
    e7b0:	bc 01       	movw	r22, r24
    e7b2:	8a e3       	ldi	r24, 0x3A	; 58
    e7b4:	91 e0       	ldi	r25, 0x01	; 1
    e7b6:	0e 94 0f 82 	call	0x1041e	; 0x1041e <__eewr_word_m2560>
		eeprom_write_byte(&MemCheck_stor.ReprogFlg, 1);
    e7ba:	8c e3       	ldi	r24, 0x3C	; 60
    e7bc:	91 e0       	ldi	r25, 0x01	; 1
    e7be:	61 e0       	ldi	r22, 0x01	; 1
    e7c0:	0e 94 f9 81 	call	0x103f2	; 0x103f2 <__eewr_byte_m2560>
    e7c4:	08 95       	ret

0000e7c6 <main>:
}

// ~~~~~~~
int
main(void)
{
    e7c6:	cf 93       	push	r28
    e7c8:	df 93       	push	r29
	TimeInit();
    e7ca:	0e 94 7b 73 	call	0xe6f6	; 0xe6f6 <TimeInit>
	TimersInc();
    e7ce:	0e 94 3e 4c 	call	0x987c	; 0x987c <TimersInc>
	MemCheckInit();
    e7d2:	0e 94 c9 73 	call	0xe792	; 0xe792 <MemCheckInit>
	LED_Init();
    e7d6:	0e 94 b8 25 	call	0x4b70	; 0x4b70 <LED_Init>

	LCD_Init();
    e7da:	0e 94 2a 71 	call	0xe254	; 0xe254 <LCD_Init>

	KeypadInit();
    e7de:	0e 94 5f 3b 	call	0x76be	; 0x76be <KeypadInit>
	MenuInit();
    e7e2:	0e 94 ad 3c 	call	0x795a	; 0x795a <MenuInit>
InterruInit(void)
{
	#ifdef PMIC
		PMIC.CTRL = (uint8_t)(~PMIC_RREN_bm &~PMIC_IVSEL_bm) |PMIC_HILVLEN_bm |PMIC_MEDLVLEN_bm |PMIC_LOLVLEN_bm;
	#endif
	sei();
    e7e6:	78 94       	sei
	InterruInit();
	DigitInit();
    e7e8:	0e 94 d0 3d 	call	0x7ba0	; 0x7ba0 <DI_Init>
    e7ec:	0e 94 df 3e 	call	0x7dbe	; 0x7dbe <DO_Init>
	HSC_Init();

	AI_Init();
    e7f0:	0e 94 f4 3e 	call	0x7de8	; 0x7de8 <AI_Init>

	SPI_Init();
    e7f4:	0e 94 40 20 	call	0x4080	; 0x4080 <SPI_Init>

	PWM_Init();
    e7f8:	0e 94 0c 1e 	call	0x3c18	; 0x3c18 <PWM_Init>
	TWI_Init();
    e7fc:	0e 94 fb 22 	call	0x45f6	; 0x45f6 <TWI_Init>
#ifdef QslRD
	SlaveRD_Init();
#endif

	do {
		TimersInc();
    e800:	0e 94 3e 4c 	call	0x987c	; 0x987c <TimersInc>
		wdt_reset();
    e804:	a8 95       	wdr
		DigitIn();
    e806:	0e 94 4c 4f 	call	0x9e98	; 0x9e98 <DigitIn>
		TWI_In();
    e80a:	0e 94 20 72 	call	0xe440	; 0xe440 <TWI_In>
	StopTWI();
	TWI_Phase = PCF_START;
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t RTC_Ready(void){
	if(TWI_Phase == PCF_START) return 1;
    e80e:	80 91 7d 07 	lds	r24, 0x077D
    e812:	88 23       	and	r24, r24
    e814:	11 f4       	brne	.+4      	; 0xe81a <main+0x54>
		if(RTC_Ready()) RTC_GetTrueTime();
    e816:	0e 94 96 24 	call	0x492c	; 0x492c <RTC_GetTrueTime>
		LCD_Sweep();
    e81a:	0e 94 0d 61 	call	0xc21a	; 0xc21a <LCD_Sweep>
	#ifdef TerIdx
	} while(ThermInit(AnalogIn()-TerIdx) || !RTC_Ready());
	#elif !defined ADC_Miss
		AnalogIn();
    e81e:	0e 94 05 3f 	call	0x7e0a	; 0x7e0a <AnalogIn>
	} while( (ADC_OK&&ThermInit(ADC_In())) || !RTC_Ready() );
    e822:	80 91 e3 08 	lds	r24, 0x08E3
    e826:	90 91 e4 08 	lds	r25, 0x08E4
    e82a:	89 2b       	or	r24, r25
    e82c:	69 f4       	brne	.+26     	; 0xe848 <main+0x82>
    e82e:	80 91 70 07 	lds	r24, 0x0770
    e832:	90 91 71 07 	lds	r25, 0x0771
    e836:	89 2b       	or	r24, r25
    e838:	39 f4       	brne	.+14     	; 0xe848 <main+0x82>
    e83a:	80 91 b5 06 	lds	r24, 0x06B5
    e83e:	90 91 b6 06 	lds	r25, 0x06B6
    e842:	89 2b       	or	r24, r25
    e844:	09 f4       	brne	.+2      	; 0xe848 <main+0x82>
    e846:	68 c0       	rjmp	.+208    	; 0xe918 <main+0x152>
    e848:	80 91 7d 07 	lds	r24, 0x077D
    e84c:	88 23       	and	r24, r24
    e84e:	c1 f6       	brne	.-80     	; 0xe800 <main+0x3a>
	#else
	} while((AnalogIn()!=AI_Reg-1) || !RTC_Ready());
	#endif

	MemCheckMsg();
    e850:	0e 94 3c 4e 	call	0x9c78	; 0x9c78 <MemCheckMsg>

	ApplInit();

	USART_Init();
    e854:	0e 94 d6 70 	call	0xe1ac	; 0xe1ac <USART_Init>
	ScanCycleInit();
    e858:	0e 94 50 1d 	call	0x3aa0	; 0x3aa0 <ScanCycleInit>
	if(TimerAllocError()) ShowMsg(&MsgErr41);
    e85c:	0e 94 34 1d 	call	0x3a68	; 0x3a68 <TimerAllocError>
    e860:	88 23       	and	r24, r24
    e862:	09 f0       	breq	.+2      	; 0xe866 <main+0xa0>
    e864:	61 c0       	rjmp	.+194    	; 0xe928 <main+0x162>

// ~~~~~~~~~~~~~~~~
void
Therm_ADC_Off(void)
{
	for (uint8_t i=0; i<TerReg; Temperature[i++]=ADC_Off_Mark);
    e866:	c1 e0       	ldi	r28, 0x01	; 1
    e868:	d0 e8       	ldi	r29, 0x80	; 128
    e86a:	10 c0       	rjmp	.+32     	; 0xe88c <main+0xc6>
			if(ADC_Work&&ADC_Phase==ADC_OFF) {
				Therm_ADC_Off();
				ShowMsg(&MsgErr21);
				ADC_Work = 0;
			}
			ThermChan(ADC_In());
    e86c:	0e 94 97 1e 	call	0x3d2e	; 0x3d2e <ADC_In>
    e870:	0e 94 6e 4e 	call	0x9cdc	; 0x9cdc <ThermChan>
		#endif
		ThermExt();
		TWI_In();
    e874:	0e 94 20 72 	call	0xe440	; 0xe440 <TWI_In>

		USART_Cycle();
    e878:	0e 94 4b 6f 	call	0xde96	; 0xde96 <USART_Cycle>
#ifdef QslRD
		SlaveRD();
#endif
		ApplCycle();
		
		LCD_Sweep();
    e87c:	0e 94 0d 61 	call	0xc21a	; 0xc21a <LCD_Sweep>
		DigitOut();
    e880:	0e 94 90 3e 	call	0x7d20	; 0x7d20 <DigitOut>
		DAC_Out();
		PWM_Out();
    e884:	0e 94 2b 1e 	call	0x3c56	; 0x3c56 <PWM_Out>
		#ifdef BACKLIGHT
			LCDBackLightControl();
    e888:	0e 94 f0 27 	call	0x4fe0	; 0x4fe0 <LCDBackLightControl>
	USART_Init();
	ScanCycleInit();
	if(TimerAllocError()) ShowMsg(&MsgErr41);

	for(;;) {	
		TimersInc();
    e88c:	0e 94 3e 4c 	call	0x987c	; 0x987c <TimersInc>
		TimeCycle();
    e890:	0e 94 b0 1d 	call	0x3b60	; 0x3b60 <TimeCycle>
// ~~~~~~~~~~~~~~
static void
KeypadSweep(void)
{
	static T_KeyAct KeyAct[] PROGMEM = KEYS;
	T_KeyAct KA = prp(KeyAct+KeypadIn());
    e894:	0e 94 72 3b 	call	0x76e4	; 0x76e4 <KeypadIn>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    e898:	e8 2f       	mov	r30, r24
    e89a:	f0 e0       	ldi	r31, 0x00	; 0
    e89c:	ee 0f       	add	r30, r30
    e89e:	ff 1f       	adc	r31, r31
    e8a0:	e9 53       	subi	r30, 0x39	; 57
    e8a2:	f6 4d       	sbci	r31, 0xD6	; 214
    e8a4:	85 91       	lpm	r24, Z+
    e8a6:	94 91       	lpm	r25, Z+
	if(KA){
    e8a8:	00 97       	sbiw	r24, 0x00	; 0
    e8aa:	31 f0       	breq	.+12     	; 0xe8b8 <main+0xf2>
		KA();
    e8ac:	fc 01       	movw	r30, r24
    e8ae:	19 95       	eicall
		#ifdef BACKLIGHT
			if(BackLightMode == 1){
    e8b0:	80 91 50 06 	lds	r24, 0x0650
    e8b4:	81 30       	cpi	r24, 0x01	; 1
    e8b6:	59 f1       	breq	.+86     	; 0xe90e <main+0x148>
	for(;;) {	
		TimersInc();
		TimeCycle();

		KeypadSweep();
		DigitIn();
    e8b8:	0e 94 4c 4f 	call	0x9e98	; 0x9e98 <DigitIn>
		HSC_In();
		#ifdef TerIdx
			ThermChan(AnalogIn()-TerIdx);
		#else
			AnalogIn();
    e8bc:	0e 94 05 3f 	call	0x7e0a	; 0x7e0a <AnalogIn>
		#endif
		#if !defined ADC_Miss && !defined TerIdx
			static uint8_t ADC_Work = 1;
			if(ADC_Work&&ADC_Phase==ADC_OFF) {
    e8c0:	80 91 d8 02 	lds	r24, 0x02D8
    e8c4:	88 23       	and	r24, r24
    e8c6:	91 f2       	breq	.-92     	; 0xe86c <main+0xa6>
    e8c8:	80 91 22 0b 	lds	r24, 0x0B22
    e8cc:	84 30       	cpi	r24, 0x04	; 4
    e8ce:	71 f6       	brne	.-100    	; 0xe86c <main+0xa6>
    e8d0:	d0 93 44 06 	sts	0x0644, r29
    e8d4:	c0 93 43 06 	sts	0x0643, r28
    e8d8:	d0 93 46 06 	sts	0x0646, r29
    e8dc:	c0 93 45 06 	sts	0x0645, r28
    e8e0:	d0 93 48 06 	sts	0x0648, r29
    e8e4:	c0 93 47 06 	sts	0x0647, r28
    e8e8:	d0 93 4a 06 	sts	0x064A, r29
    e8ec:	c0 93 49 06 	sts	0x0649, r28
    e8f0:	d0 93 4c 06 	sts	0x064C, r29
    e8f4:	c0 93 4b 06 	sts	0x064B, r28
    e8f8:	d0 93 4e 06 	sts	0x064E, r29
    e8fc:	c0 93 4d 06 	sts	0x064D, r28
				Therm_ADC_Off();
				ShowMsg(&MsgErr21);
    e900:	8a e7       	ldi	r24, 0x7A	; 122
    e902:	98 e0       	ldi	r25, 0x08	; 8
    e904:	0e 94 9c 3c 	call	0x7938	; 0x7938 <ShowMsg>
				ADC_Work = 0;
    e908:	10 92 d8 02 	sts	0x02D8, r1
    e90c:	af cf       	rjmp	.-162    	; 0xe86c <main+0xa6>
	T_KeyAct KA = prp(KeyAct+KeypadIn());
	if(KA){
		KA();
		#ifdef BACKLIGHT
			if(BackLightMode == 1){
				LCDBackLightOn();
    e90e:	0e 94 d4 27 	call	0x4fa8	; 0x4fa8 <LCDBackLightOn>
				LCDBackLightStartTimer();
    e912:	0e 94 db 70 	call	0xe1b6	; 0xe1b6 <LCDBackLightStartTimer>
    e916:	d0 cf       	rjmp	.-96     	; 0xe8b8 <main+0xf2>
		LCD_Sweep();
	#ifdef TerIdx
	} while(ThermInit(AnalogIn()-TerIdx) || !RTC_Ready());
	#elif !defined ADC_Miss
		AnalogIn();
	} while( (ADC_OK&&ThermInit(ADC_In())) || !RTC_Ready() );
    e918:	0e 94 97 1e 	call	0x3d2e	; 0x3d2e <ADC_In>
    e91c:	0e 94 0a 4f 	call	0x9e14	; 0x9e14 <ThermInit>
    e920:	88 23       	and	r24, r24
    e922:	09 f0       	breq	.+2      	; 0xe926 <main+0x160>
    e924:	6d cf       	rjmp	.-294    	; 0xe800 <main+0x3a>
    e926:	90 cf       	rjmp	.-224    	; 0xe848 <main+0x82>

	ApplInit();

	USART_Init();
	ScanCycleInit();
	if(TimerAllocError()) ShowMsg(&MsgErr41);
    e928:	8f e2       	ldi	r24, 0x2F	; 47
    e92a:	9a e1       	ldi	r25, 0x1A	; 26
    e92c:	0e 94 9c 3c 	call	0x7938	; 0x7938 <ShowMsg>
    e930:	9a cf       	rjmp	.-204    	; 0xe866 <main+0xa0>

0000e932 <EEMEMBackUpOk>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    e932:	80 e0       	ldi	r24, 0x00	; 0
    e934:	90 e0       	ldi	r25, 0x00	; 0
    e936:	0e 94 db 81 	call	0x103b6	; 0x103b6 <__eerd_byte_m2560>
	uint8_t Month;
	uint8_t Year;
}DateBackUp EEMEM = {0xFF,0xFF,0xFF};

uint8_t EEMEMBackUpOk(void){
	if( (erb(&DateBackUp.Day)==0xFF) || (erb(&DateBackUp.Month)==0xFF) || (erb(&DateBackUp.Year)== 0xFF) ) return 0;
    e93a:	8f 3f       	cpi	r24, 0xFF	; 255
    e93c:	81 f0       	breq	.+32     	; 0xe95e <EEMEMBackUpOk+0x2c>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    e93e:	81 e0       	ldi	r24, 0x01	; 1
    e940:	90 e0       	ldi	r25, 0x00	; 0
    e942:	0e 94 db 81 	call	0x103b6	; 0x103b6 <__eerd_byte_m2560>
	uint8_t Month;
	uint8_t Year;
}DateBackUp EEMEM = {0xFF,0xFF,0xFF};

uint8_t EEMEMBackUpOk(void){
	if( (erb(&DateBackUp.Day)==0xFF) || (erb(&DateBackUp.Month)==0xFF) || (erb(&DateBackUp.Year)== 0xFF) ) return 0;
    e946:	8f 3f       	cpi	r24, 0xFF	; 255
    e948:	51 f0       	breq	.+20     	; 0xe95e <EEMEMBackUpOk+0x2c>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    e94a:	82 e0       	ldi	r24, 0x02	; 2
    e94c:	90 e0       	ldi	r25, 0x00	; 0
    e94e:	0e 94 db 81 	call	0x103b6	; 0x103b6 <__eerd_byte_m2560>
    e952:	90 e0       	ldi	r25, 0x00	; 0
    e954:	8f 3f       	cpi	r24, 0xFF	; 255
    e956:	21 f0       	breq	.+8      	; 0xe960 <EEMEMBackUpOk+0x2e>
    e958:	91 e0       	ldi	r25, 0x01	; 1
}DateBackUp EEMEM = {0xFF,0xFF,0xFF};

uint8_t EEMEMBackUpOk(void){
	if( (erb(&DateBackUp.Day)==0xFF) || (erb(&DateBackUp.Month)==0xFF) || (erb(&DateBackUp.Year)== 0xFF) ) return 0;
	else return 1;
}
    e95a:	89 2f       	mov	r24, r25
    e95c:	08 95       	ret
	uint8_t Month;
	uint8_t Year;
}DateBackUp EEMEM = {0xFF,0xFF,0xFF};

uint8_t EEMEMBackUpOk(void){
	if( (erb(&DateBackUp.Day)==0xFF) || (erb(&DateBackUp.Month)==0xFF) || (erb(&DateBackUp.Year)== 0xFF) ) return 0;
    e95e:	90 e0       	ldi	r25, 0x00	; 0
	else return 1;
}
    e960:	89 2f       	mov	r24, r25
    e962:	08 95       	ret

0000e964 <Menu_BackUp_Enter>:
			NULL, NULL, NULL, Menu_ConfirmationRest_Enter, NULL, NULL, NULL};
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	//		  
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	uint8_t Menu_BackUp_Enter(){
		switch(CurrLine){
    e964:	80 91 83 07 	lds	r24, 0x0783
    e968:	82 30       	cpi	r24, 0x02	; 2
    e96a:	11 f0       	breq	.+4      	; 0xe970 <Menu_BackUp_Enter+0xc>
			}
			NextPage = &Menu_ConfirmationRestore;
			break;
		}
		return StandartKey;
	}
    e96c:	80 e0       	ldi	r24, 0x00	; 0
    e96e:	08 95       	ret
	//		  
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	uint8_t Menu_BackUp_Enter(){
		switch(CurrLine){
		case 2:
			if(!EEMEMBackUpOk()){
    e970:	0e 94 99 74 	call	0xe932	; 0xe932 <EEMEMBackUpOk>
    e974:	88 23       	and	r24, r24
    e976:	59 f4       	brne	.+22     	; 0xe98e <Menu_BackUp_Enter+0x2a>
				//   EEPROM,   BackUp- -  
				if(MemFail & 1<<MemFail_EEPROM){
    e978:	80 91 cf 08 	lds	r24, 0x08CF
    e97c:	81 ff       	sbrs	r24, 1
    e97e:	0f c0       	rjmp	.+30     	; 0xe99e <Menu_BackUp_Enter+0x3a>
					MemFailReset();
    e980:	0e 94 ae 4b 	call	0x975c	; 0x975c <MemFailReset>
					ShowMsg(&Msg_EEWarning);
    e984:	8b e3       	ldi	r24, 0x3B	; 59
    e986:	93 e1       	ldi	r25, 0x13	; 19
    e988:	0e 94 9c 3c 	call	0x7938	; 0x7938 <ShowMsg>
    e98c:	ef cf       	rjmp	.-34     	; 0xe96c <Menu_BackUp_Enter+0x8>
				}
				else ShowMsg(&Msg_NoBackUp);
				break;
			}
			NextPage = &Menu_ConfirmationRestore;
    e98e:	8b ee       	ldi	r24, 0xEB	; 235
    e990:	94 e1       	ldi	r25, 0x14	; 20
    e992:	90 93 d8 05 	sts	0x05D8, r25
    e996:	80 93 d7 05 	sts	0x05D7, r24
			break;
		}
		return StandartKey;
	}
    e99a:	80 e0       	ldi	r24, 0x00	; 0
    e99c:	08 95       	ret
				//   EEPROM,   BackUp- -  
				if(MemFail & 1<<MemFail_EEPROM){
					MemFailReset();
					ShowMsg(&Msg_EEWarning);
				}
				else ShowMsg(&Msg_NoBackUp);
    e99e:	8d e9       	ldi	r24, 0x9D	; 157
    e9a0:	93 e1       	ldi	r25, 0x13	; 19
    e9a2:	0e 94 9c 3c 	call	0x7938	; 0x7938 <ShowMsg>
    e9a6:	e2 cf       	rjmp	.-60     	; 0xe96c <Menu_BackUp_Enter+0x8>

0000e9a8 <vfprintf>:
    e9a8:	2f 92       	push	r2
    e9aa:	3f 92       	push	r3
    e9ac:	4f 92       	push	r4
    e9ae:	5f 92       	push	r5
    e9b0:	6f 92       	push	r6
    e9b2:	7f 92       	push	r7
    e9b4:	8f 92       	push	r8
    e9b6:	9f 92       	push	r9
    e9b8:	af 92       	push	r10
    e9ba:	bf 92       	push	r11
    e9bc:	cf 92       	push	r12
    e9be:	df 92       	push	r13
    e9c0:	ef 92       	push	r14
    e9c2:	ff 92       	push	r15
    e9c4:	0f 93       	push	r16
    e9c6:	1f 93       	push	r17
    e9c8:	df 93       	push	r29
    e9ca:	cf 93       	push	r28
    e9cc:	cd b7       	in	r28, 0x3d	; 61
    e9ce:	de b7       	in	r29, 0x3e	; 62
    e9d0:	61 97       	sbiw	r28, 0x11	; 17
    e9d2:	0f b6       	in	r0, 0x3f	; 63
    e9d4:	f8 94       	cli
    e9d6:	de bf       	out	0x3e, r29	; 62
    e9d8:	0f be       	out	0x3f, r0	; 63
    e9da:	cd bf       	out	0x3d, r28	; 61
    e9dc:	3c 01       	movw	r6, r24
    e9de:	7f 87       	std	Y+15, r23	; 0x0f
    e9e0:	6e 87       	std	Y+14, r22	; 0x0e
    e9e2:	6a 01       	movw	r12, r20
    e9e4:	fc 01       	movw	r30, r24
    e9e6:	17 82       	std	Z+7, r1	; 0x07
    e9e8:	16 82       	std	Z+6, r1	; 0x06
    e9ea:	83 81       	ldd	r24, Z+3	; 0x03
    e9ec:	81 fd       	sbrc	r24, 1
    e9ee:	03 c0       	rjmp	.+6      	; 0xe9f6 <vfprintf+0x4e>
    e9f0:	6f ef       	ldi	r22, 0xFF	; 255
    e9f2:	7f ef       	ldi	r23, 0xFF	; 255
    e9f4:	6f c3       	rjmp	.+1758   	; 0xf0d4 <vfprintf+0x72c>
    e9f6:	9e 01       	movw	r18, r28
    e9f8:	2f 5f       	subi	r18, 0xFF	; 255
    e9fa:	3f 4f       	sbci	r19, 0xFF	; 255
    e9fc:	39 8b       	std	Y+17, r19	; 0x11
    e9fe:	28 8b       	std	Y+16, r18	; 0x10
    ea00:	f3 01       	movw	r30, r6
    ea02:	23 81       	ldd	r18, Z+3	; 0x03
    ea04:	ee 85       	ldd	r30, Y+14	; 0x0e
    ea06:	ff 85       	ldd	r31, Y+15	; 0x0f
    ea08:	23 fd       	sbrc	r18, 3
    ea0a:	85 91       	lpm	r24, Z+
    ea0c:	23 ff       	sbrs	r18, 3
    ea0e:	81 91       	ld	r24, Z+
    ea10:	ff 87       	std	Y+15, r31	; 0x0f
    ea12:	ee 87       	std	Y+14, r30	; 0x0e
    ea14:	88 23       	and	r24, r24
    ea16:	09 f4       	brne	.+2      	; 0xea1a <vfprintf+0x72>
    ea18:	5a c3       	rjmp	.+1716   	; 0xf0ce <vfprintf+0x726>
    ea1a:	85 32       	cpi	r24, 0x25	; 37
    ea1c:	51 f4       	brne	.+20     	; 0xea32 <vfprintf+0x8a>
    ea1e:	ee 85       	ldd	r30, Y+14	; 0x0e
    ea20:	ff 85       	ldd	r31, Y+15	; 0x0f
    ea22:	23 fd       	sbrc	r18, 3
    ea24:	85 91       	lpm	r24, Z+
    ea26:	23 ff       	sbrs	r18, 3
    ea28:	81 91       	ld	r24, Z+
    ea2a:	ff 87       	std	Y+15, r31	; 0x0f
    ea2c:	ee 87       	std	Y+14, r30	; 0x0e
    ea2e:	85 32       	cpi	r24, 0x25	; 37
    ea30:	29 f4       	brne	.+10     	; 0xea3c <vfprintf+0x94>
    ea32:	90 e0       	ldi	r25, 0x00	; 0
    ea34:	b3 01       	movw	r22, r6
    ea36:	0e 94 81 7f 	call	0xff02	; 0xff02 <fputc>
    ea3a:	e2 cf       	rjmp	.-60     	; 0xea00 <vfprintf+0x58>
    ea3c:	98 2f       	mov	r25, r24
    ea3e:	10 e0       	ldi	r17, 0x00	; 0
    ea40:	88 24       	eor	r8, r8
    ea42:	99 24       	eor	r9, r9
    ea44:	10 32       	cpi	r17, 0x20	; 32
    ea46:	b0 f4       	brcc	.+44     	; 0xea74 <vfprintf+0xcc>
    ea48:	9b 32       	cpi	r25, 0x2B	; 43
    ea4a:	69 f0       	breq	.+26     	; 0xea66 <vfprintf+0xbe>
    ea4c:	9c 32       	cpi	r25, 0x2C	; 44
    ea4e:	28 f4       	brcc	.+10     	; 0xea5a <vfprintf+0xb2>
    ea50:	90 32       	cpi	r25, 0x20	; 32
    ea52:	51 f0       	breq	.+20     	; 0xea68 <vfprintf+0xc0>
    ea54:	93 32       	cpi	r25, 0x23	; 35
    ea56:	71 f4       	brne	.+28     	; 0xea74 <vfprintf+0xcc>
    ea58:	0b c0       	rjmp	.+22     	; 0xea70 <vfprintf+0xc8>
    ea5a:	9d 32       	cpi	r25, 0x2D	; 45
    ea5c:	39 f0       	breq	.+14     	; 0xea6c <vfprintf+0xc4>
    ea5e:	90 33       	cpi	r25, 0x30	; 48
    ea60:	49 f4       	brne	.+18     	; 0xea74 <vfprintf+0xcc>
    ea62:	11 60       	ori	r17, 0x01	; 1
    ea64:	28 c0       	rjmp	.+80     	; 0xeab6 <vfprintf+0x10e>
    ea66:	12 60       	ori	r17, 0x02	; 2
    ea68:	14 60       	ori	r17, 0x04	; 4
    ea6a:	25 c0       	rjmp	.+74     	; 0xeab6 <vfprintf+0x10e>
    ea6c:	18 60       	ori	r17, 0x08	; 8
    ea6e:	23 c0       	rjmp	.+70     	; 0xeab6 <vfprintf+0x10e>
    ea70:	10 61       	ori	r17, 0x10	; 16
    ea72:	21 c0       	rjmp	.+66     	; 0xeab6 <vfprintf+0x10e>
    ea74:	17 fd       	sbrc	r17, 7
    ea76:	2a c0       	rjmp	.+84     	; 0xeacc <vfprintf+0x124>
    ea78:	89 2f       	mov	r24, r25
    ea7a:	80 53       	subi	r24, 0x30	; 48
    ea7c:	8a 30       	cpi	r24, 0x0A	; 10
    ea7e:	78 f4       	brcc	.+30     	; 0xea9e <vfprintf+0xf6>
    ea80:	16 ff       	sbrs	r17, 6
    ea82:	06 c0       	rjmp	.+12     	; 0xea90 <vfprintf+0xe8>
    ea84:	fa e0       	ldi	r31, 0x0A	; 10
    ea86:	9f 9e       	mul	r9, r31
    ea88:	90 2c       	mov	r9, r0
    ea8a:	11 24       	eor	r1, r1
    ea8c:	98 0e       	add	r9, r24
    ea8e:	13 c0       	rjmp	.+38     	; 0xeab6 <vfprintf+0x10e>
    ea90:	3a e0       	ldi	r19, 0x0A	; 10
    ea92:	83 9e       	mul	r8, r19
    ea94:	80 2c       	mov	r8, r0
    ea96:	11 24       	eor	r1, r1
    ea98:	88 0e       	add	r8, r24
    ea9a:	10 62       	ori	r17, 0x20	; 32
    ea9c:	0c c0       	rjmp	.+24     	; 0xeab6 <vfprintf+0x10e>
    ea9e:	9e 32       	cpi	r25, 0x2E	; 46
    eaa0:	21 f4       	brne	.+8      	; 0xeaaa <vfprintf+0x102>
    eaa2:	16 fd       	sbrc	r17, 6
    eaa4:	14 c3       	rjmp	.+1576   	; 0xf0ce <vfprintf+0x726>
    eaa6:	10 64       	ori	r17, 0x40	; 64
    eaa8:	06 c0       	rjmp	.+12     	; 0xeab6 <vfprintf+0x10e>
    eaaa:	9c 36       	cpi	r25, 0x6C	; 108
    eaac:	11 f4       	brne	.+4      	; 0xeab2 <vfprintf+0x10a>
    eaae:	10 68       	ori	r17, 0x80	; 128
    eab0:	02 c0       	rjmp	.+4      	; 0xeab6 <vfprintf+0x10e>
    eab2:	98 36       	cpi	r25, 0x68	; 104
    eab4:	59 f4       	brne	.+22     	; 0xeacc <vfprintf+0x124>
    eab6:	ee 85       	ldd	r30, Y+14	; 0x0e
    eab8:	ff 85       	ldd	r31, Y+15	; 0x0f
    eaba:	23 fd       	sbrc	r18, 3
    eabc:	95 91       	lpm	r25, Z+
    eabe:	23 ff       	sbrs	r18, 3
    eac0:	91 91       	ld	r25, Z+
    eac2:	ff 87       	std	Y+15, r31	; 0x0f
    eac4:	ee 87       	std	Y+14, r30	; 0x0e
    eac6:	99 23       	and	r25, r25
    eac8:	09 f0       	breq	.+2      	; 0xeacc <vfprintf+0x124>
    eaca:	bc cf       	rjmp	.-136    	; 0xea44 <vfprintf+0x9c>
    eacc:	89 2f       	mov	r24, r25
    eace:	85 54       	subi	r24, 0x45	; 69
    ead0:	83 30       	cpi	r24, 0x03	; 3
    ead2:	20 f4       	brcc	.+8      	; 0xeadc <vfprintf+0x134>
    ead4:	81 2f       	mov	r24, r17
    ead6:	80 61       	ori	r24, 0x10	; 16
    ead8:	90 5e       	subi	r25, 0xE0	; 224
    eada:	07 c0       	rjmp	.+14     	; 0xeaea <vfprintf+0x142>
    eadc:	89 2f       	mov	r24, r25
    eade:	85 56       	subi	r24, 0x65	; 101
    eae0:	83 30       	cpi	r24, 0x03	; 3
    eae2:	08 f0       	brcs	.+2      	; 0xeae6 <vfprintf+0x13e>
    eae4:	9f c1       	rjmp	.+830    	; 0xee24 <vfprintf+0x47c>
    eae6:	81 2f       	mov	r24, r17
    eae8:	8f 7e       	andi	r24, 0xEF	; 239
    eaea:	86 fd       	sbrc	r24, 6
    eaec:	02 c0       	rjmp	.+4      	; 0xeaf2 <vfprintf+0x14a>
    eaee:	76 e0       	ldi	r23, 0x06	; 6
    eaf0:	97 2e       	mov	r9, r23
    eaf2:	6f e3       	ldi	r22, 0x3F	; 63
    eaf4:	f6 2e       	mov	r15, r22
    eaf6:	f8 22       	and	r15, r24
    eaf8:	95 36       	cpi	r25, 0x65	; 101
    eafa:	19 f4       	brne	.+6      	; 0xeb02 <vfprintf+0x15a>
    eafc:	f0 e4       	ldi	r31, 0x40	; 64
    eafe:	ff 2a       	or	r15, r31
    eb00:	07 c0       	rjmp	.+14     	; 0xeb10 <vfprintf+0x168>
    eb02:	96 36       	cpi	r25, 0x66	; 102
    eb04:	19 f4       	brne	.+6      	; 0xeb0c <vfprintf+0x164>
    eb06:	20 e8       	ldi	r18, 0x80	; 128
    eb08:	f2 2a       	or	r15, r18
    eb0a:	02 c0       	rjmp	.+4      	; 0xeb10 <vfprintf+0x168>
    eb0c:	91 10       	cpse	r9, r1
    eb0e:	9a 94       	dec	r9
    eb10:	f7 fe       	sbrs	r15, 7
    eb12:	0a c0       	rjmp	.+20     	; 0xeb28 <vfprintf+0x180>
    eb14:	3b e3       	ldi	r19, 0x3B	; 59
    eb16:	39 15       	cp	r19, r9
    eb18:	18 f4       	brcc	.+6      	; 0xeb20 <vfprintf+0x178>
    eb1a:	5c e3       	ldi	r21, 0x3C	; 60
    eb1c:	b5 2e       	mov	r11, r21
    eb1e:	02 c0       	rjmp	.+4      	; 0xeb24 <vfprintf+0x17c>
    eb20:	b9 2c       	mov	r11, r9
    eb22:	b3 94       	inc	r11
    eb24:	27 e0       	ldi	r18, 0x07	; 7
    eb26:	09 c0       	rjmp	.+18     	; 0xeb3a <vfprintf+0x192>
    eb28:	47 e0       	ldi	r20, 0x07	; 7
    eb2a:	49 15       	cp	r20, r9
    eb2c:	20 f4       	brcc	.+8      	; 0xeb36 <vfprintf+0x18e>
    eb2e:	bb 24       	eor	r11, r11
    eb30:	47 e0       	ldi	r20, 0x07	; 7
    eb32:	94 2e       	mov	r9, r20
    eb34:	f7 cf       	rjmp	.-18     	; 0xeb24 <vfprintf+0x17c>
    eb36:	29 2d       	mov	r18, r9
    eb38:	bb 24       	eor	r11, r11
    eb3a:	c6 01       	movw	r24, r12
    eb3c:	04 96       	adiw	r24, 0x04	; 4
    eb3e:	9d 87       	std	Y+13, r25	; 0x0d
    eb40:	8c 87       	std	Y+12, r24	; 0x0c
    eb42:	f6 01       	movw	r30, r12
    eb44:	60 81       	ld	r22, Z
    eb46:	71 81       	ldd	r23, Z+1	; 0x01
    eb48:	82 81       	ldd	r24, Z+2	; 0x02
    eb4a:	93 81       	ldd	r25, Z+3	; 0x03
    eb4c:	ae 01       	movw	r20, r28
    eb4e:	4f 5f       	subi	r20, 0xFF	; 255
    eb50:	5f 4f       	sbci	r21, 0xFF	; 255
    eb52:	0b 2d       	mov	r16, r11
    eb54:	0e 94 be 7d 	call	0xfb7c	; 0xfb7c <__ftoa_engine>
    eb58:	6c 01       	movw	r12, r24
    eb5a:	09 81       	ldd	r16, Y+1	; 0x01
    eb5c:	20 2e       	mov	r2, r16
    eb5e:	33 24       	eor	r3, r3
    eb60:	00 ff       	sbrs	r16, 0
    eb62:	04 c0       	rjmp	.+8      	; 0xeb6c <vfprintf+0x1c4>
    eb64:	03 fd       	sbrc	r16, 3
    eb66:	02 c0       	rjmp	.+4      	; 0xeb6c <vfprintf+0x1c4>
    eb68:	1d e2       	ldi	r17, 0x2D	; 45
    eb6a:	09 c0       	rjmp	.+18     	; 0xeb7e <vfprintf+0x1d6>
    eb6c:	f1 fe       	sbrs	r15, 1
    eb6e:	02 c0       	rjmp	.+4      	; 0xeb74 <vfprintf+0x1cc>
    eb70:	1b e2       	ldi	r17, 0x2B	; 43
    eb72:	05 c0       	rjmp	.+10     	; 0xeb7e <vfprintf+0x1d6>
    eb74:	f2 fc       	sbrc	r15, 2
    eb76:	02 c0       	rjmp	.+4      	; 0xeb7c <vfprintf+0x1d4>
    eb78:	10 e0       	ldi	r17, 0x00	; 0
    eb7a:	01 c0       	rjmp	.+2      	; 0xeb7e <vfprintf+0x1d6>
    eb7c:	10 e2       	ldi	r17, 0x20	; 32
    eb7e:	c1 01       	movw	r24, r2
    eb80:	8c 70       	andi	r24, 0x0C	; 12
    eb82:	90 70       	andi	r25, 0x00	; 0
    eb84:	89 2b       	or	r24, r25
    eb86:	b9 f1       	breq	.+110    	; 0xebf6 <vfprintf+0x24e>
    eb88:	11 23       	and	r17, r17
    eb8a:	11 f4       	brne	.+4      	; 0xeb90 <vfprintf+0x1e8>
    eb8c:	83 e0       	ldi	r24, 0x03	; 3
    eb8e:	01 c0       	rjmp	.+2      	; 0xeb92 <vfprintf+0x1ea>
    eb90:	84 e0       	ldi	r24, 0x04	; 4
    eb92:	88 15       	cp	r24, r8
    eb94:	10 f0       	brcs	.+4      	; 0xeb9a <vfprintf+0x1f2>
    eb96:	88 24       	eor	r8, r8
    eb98:	0a c0       	rjmp	.+20     	; 0xebae <vfprintf+0x206>
    eb9a:	88 1a       	sub	r8, r24
    eb9c:	f3 fc       	sbrc	r15, 3
    eb9e:	07 c0       	rjmp	.+14     	; 0xebae <vfprintf+0x206>
    eba0:	80 e2       	ldi	r24, 0x20	; 32
    eba2:	90 e0       	ldi	r25, 0x00	; 0
    eba4:	b3 01       	movw	r22, r6
    eba6:	0e 94 81 7f 	call	0xff02	; 0xff02 <fputc>
    ebaa:	8a 94       	dec	r8
    ebac:	c9 f7       	brne	.-14     	; 0xeba0 <vfprintf+0x1f8>
    ebae:	11 23       	and	r17, r17
    ebb0:	29 f0       	breq	.+10     	; 0xebbc <vfprintf+0x214>
    ebb2:	81 2f       	mov	r24, r17
    ebb4:	90 e0       	ldi	r25, 0x00	; 0
    ebb6:	b3 01       	movw	r22, r6
    ebb8:	0e 94 81 7f 	call	0xff02	; 0xff02 <fputc>
    ebbc:	23 fe       	sbrs	r2, 3
    ebbe:	03 c0       	rjmp	.+6      	; 0xebc6 <vfprintf+0x21e>
    ebc0:	0e ec       	ldi	r16, 0xCE	; 206
    ebc2:	12 e0       	ldi	r17, 0x02	; 2
    ebc4:	0e c0       	rjmp	.+28     	; 0xebe2 <vfprintf+0x23a>
    ebc6:	02 ed       	ldi	r16, 0xD2	; 210
    ebc8:	12 e0       	ldi	r17, 0x02	; 2
    ebca:	0b c0       	rjmp	.+22     	; 0xebe2 <vfprintf+0x23a>
    ebcc:	e1 14       	cp	r14, r1
    ebce:	f1 04       	cpc	r15, r1
    ebd0:	09 f0       	breq	.+2      	; 0xebd4 <vfprintf+0x22c>
    ebd2:	80 52       	subi	r24, 0x20	; 32
    ebd4:	90 e0       	ldi	r25, 0x00	; 0
    ebd6:	b3 01       	movw	r22, r6
    ebd8:	0e 94 81 7f 	call	0xff02	; 0xff02 <fputc>
    ebdc:	0f 5f       	subi	r16, 0xFF	; 255
    ebde:	1f 4f       	sbci	r17, 0xFF	; 255
    ebe0:	05 c0       	rjmp	.+10     	; 0xebec <vfprintf+0x244>
    ebe2:	ef 2c       	mov	r14, r15
    ebe4:	ff 24       	eor	r15, r15
    ebe6:	f0 e1       	ldi	r31, 0x10	; 16
    ebe8:	ef 22       	and	r14, r31
    ebea:	ff 24       	eor	r15, r15
    ebec:	f8 01       	movw	r30, r16
    ebee:	84 91       	lpm	r24, Z+
    ebf0:	88 23       	and	r24, r24
    ebf2:	61 f7       	brne	.-40     	; 0xebcc <vfprintf+0x224>
    ebf4:	14 c1       	rjmp	.+552    	; 0xee1e <vfprintf+0x476>
    ebf6:	f7 fe       	sbrs	r15, 7
    ebf8:	12 c0       	rjmp	.+36     	; 0xec1e <vfprintf+0x276>
    ebfa:	bc 0c       	add	r11, r12
    ebfc:	24 fe       	sbrs	r2, 4
    ebfe:	04 c0       	rjmp	.+8      	; 0xec08 <vfprintf+0x260>
    ec00:	8a 81       	ldd	r24, Y+2	; 0x02
    ec02:	81 33       	cpi	r24, 0x31	; 49
    ec04:	09 f4       	brne	.+2      	; 0xec08 <vfprintf+0x260>
    ec06:	ba 94       	dec	r11
    ec08:	1b 14       	cp	r1, r11
    ec0a:	1c f0       	brlt	.+6      	; 0xec12 <vfprintf+0x26a>
    ec0c:	bb 24       	eor	r11, r11
    ec0e:	b3 94       	inc	r11
    ec10:	2d c0       	rjmp	.+90     	; 0xec6c <vfprintf+0x2c4>
    ec12:	f8 e0       	ldi	r31, 0x08	; 8
    ec14:	fb 15       	cp	r31, r11
    ec16:	50 f5       	brcc	.+84     	; 0xec6c <vfprintf+0x2c4>
    ec18:	38 e0       	ldi	r19, 0x08	; 8
    ec1a:	b3 2e       	mov	r11, r19
    ec1c:	27 c0       	rjmp	.+78     	; 0xec6c <vfprintf+0x2c4>
    ec1e:	f6 fc       	sbrc	r15, 6
    ec20:	25 c0       	rjmp	.+74     	; 0xec6c <vfprintf+0x2c4>
    ec22:	89 2d       	mov	r24, r9
    ec24:	90 e0       	ldi	r25, 0x00	; 0
    ec26:	8c 15       	cp	r24, r12
    ec28:	9d 05       	cpc	r25, r13
    ec2a:	4c f0       	brlt	.+18     	; 0xec3e <vfprintf+0x296>
    ec2c:	2c ef       	ldi	r18, 0xFC	; 252
    ec2e:	c2 16       	cp	r12, r18
    ec30:	2f ef       	ldi	r18, 0xFF	; 255
    ec32:	d2 06       	cpc	r13, r18
    ec34:	24 f0       	brlt	.+8      	; 0xec3e <vfprintf+0x296>
    ec36:	30 e8       	ldi	r19, 0x80	; 128
    ec38:	f3 2a       	or	r15, r19
    ec3a:	01 c0       	rjmp	.+2      	; 0xec3e <vfprintf+0x296>
    ec3c:	9a 94       	dec	r9
    ec3e:	99 20       	and	r9, r9
    ec40:	49 f0       	breq	.+18     	; 0xec54 <vfprintf+0x2ac>
    ec42:	e2 e0       	ldi	r30, 0x02	; 2
    ec44:	f0 e0       	ldi	r31, 0x00	; 0
    ec46:	ec 0f       	add	r30, r28
    ec48:	fd 1f       	adc	r31, r29
    ec4a:	e9 0d       	add	r30, r9
    ec4c:	f1 1d       	adc	r31, r1
    ec4e:	80 81       	ld	r24, Z
    ec50:	80 33       	cpi	r24, 0x30	; 48
    ec52:	a1 f3       	breq	.-24     	; 0xec3c <vfprintf+0x294>
    ec54:	f7 fe       	sbrs	r15, 7
    ec56:	0a c0       	rjmp	.+20     	; 0xec6c <vfprintf+0x2c4>
    ec58:	b9 2c       	mov	r11, r9
    ec5a:	b3 94       	inc	r11
    ec5c:	89 2d       	mov	r24, r9
    ec5e:	90 e0       	ldi	r25, 0x00	; 0
    ec60:	c8 16       	cp	r12, r24
    ec62:	d9 06       	cpc	r13, r25
    ec64:	14 f0       	brlt	.+4      	; 0xec6a <vfprintf+0x2c2>
    ec66:	99 24       	eor	r9, r9
    ec68:	01 c0       	rjmp	.+2      	; 0xec6c <vfprintf+0x2c4>
    ec6a:	9c 18       	sub	r9, r12
    ec6c:	f7 fc       	sbrc	r15, 7
    ec6e:	03 c0       	rjmp	.+6      	; 0xec76 <vfprintf+0x2ce>
    ec70:	25 e0       	ldi	r18, 0x05	; 5
    ec72:	30 e0       	ldi	r19, 0x00	; 0
    ec74:	09 c0       	rjmp	.+18     	; 0xec88 <vfprintf+0x2e0>
    ec76:	1c 14       	cp	r1, r12
    ec78:	1d 04       	cpc	r1, r13
    ec7a:	1c f0       	brlt	.+6      	; 0xec82 <vfprintf+0x2da>
    ec7c:	21 e0       	ldi	r18, 0x01	; 1
    ec7e:	30 e0       	ldi	r19, 0x00	; 0
    ec80:	03 c0       	rjmp	.+6      	; 0xec88 <vfprintf+0x2e0>
    ec82:	96 01       	movw	r18, r12
    ec84:	2f 5f       	subi	r18, 0xFF	; 255
    ec86:	3f 4f       	sbci	r19, 0xFF	; 255
    ec88:	11 23       	and	r17, r17
    ec8a:	11 f0       	breq	.+4      	; 0xec90 <vfprintf+0x2e8>
    ec8c:	2f 5f       	subi	r18, 0xFF	; 255
    ec8e:	3f 4f       	sbci	r19, 0xFF	; 255
    ec90:	99 20       	and	r9, r9
    ec92:	29 f0       	breq	.+10     	; 0xec9e <vfprintf+0x2f6>
    ec94:	89 2d       	mov	r24, r9
    ec96:	90 e0       	ldi	r25, 0x00	; 0
    ec98:	01 96       	adiw	r24, 0x01	; 1
    ec9a:	28 0f       	add	r18, r24
    ec9c:	39 1f       	adc	r19, r25
    ec9e:	88 2d       	mov	r24, r8
    eca0:	90 e0       	ldi	r25, 0x00	; 0
    eca2:	28 17       	cp	r18, r24
    eca4:	39 07       	cpc	r19, r25
    eca6:	14 f0       	brlt	.+4      	; 0xecac <vfprintf+0x304>
    eca8:	88 24       	eor	r8, r8
    ecaa:	01 c0       	rjmp	.+2      	; 0xecae <vfprintf+0x306>
    ecac:	82 1a       	sub	r8, r18
    ecae:	4f 2c       	mov	r4, r15
    ecb0:	55 24       	eor	r5, r5
    ecb2:	c2 01       	movw	r24, r4
    ecb4:	89 70       	andi	r24, 0x09	; 9
    ecb6:	90 70       	andi	r25, 0x00	; 0
    ecb8:	89 2b       	or	r24, r25
    ecba:	39 f0       	breq	.+14     	; 0xecca <vfprintf+0x322>
    ecbc:	08 c0       	rjmp	.+16     	; 0xecce <vfprintf+0x326>
    ecbe:	80 e2       	ldi	r24, 0x20	; 32
    ecc0:	90 e0       	ldi	r25, 0x00	; 0
    ecc2:	b3 01       	movw	r22, r6
    ecc4:	0e 94 81 7f 	call	0xff02	; 0xff02 <fputc>
    ecc8:	8a 94       	dec	r8
    ecca:	88 20       	and	r8, r8
    eccc:	c1 f7       	brne	.-16     	; 0xecbe <vfprintf+0x316>
    ecce:	11 23       	and	r17, r17
    ecd0:	29 f0       	breq	.+10     	; 0xecdc <vfprintf+0x334>
    ecd2:	81 2f       	mov	r24, r17
    ecd4:	90 e0       	ldi	r25, 0x00	; 0
    ecd6:	b3 01       	movw	r22, r6
    ecd8:	0e 94 81 7f 	call	0xff02	; 0xff02 <fputc>
    ecdc:	43 fe       	sbrs	r4, 3
    ecde:	07 c0       	rjmp	.+14     	; 0xecee <vfprintf+0x346>
    ece0:	08 c0       	rjmp	.+16     	; 0xecf2 <vfprintf+0x34a>
    ece2:	80 e3       	ldi	r24, 0x30	; 48
    ece4:	90 e0       	ldi	r25, 0x00	; 0
    ece6:	b3 01       	movw	r22, r6
    ece8:	0e 94 81 7f 	call	0xff02	; 0xff02 <fputc>
    ecec:	8a 94       	dec	r8
    ecee:	88 20       	and	r8, r8
    ecf0:	c1 f7       	brne	.-16     	; 0xece2 <vfprintf+0x33a>
    ecf2:	f7 fe       	sbrs	r15, 7
    ecf4:	46 c0       	rjmp	.+140    	; 0xed82 <vfprintf+0x3da>
    ecf6:	86 01       	movw	r16, r12
    ecf8:	d7 fe       	sbrs	r13, 7
    ecfa:	02 c0       	rjmp	.+4      	; 0xed00 <vfprintf+0x358>
    ecfc:	00 e0       	ldi	r16, 0x00	; 0
    ecfe:	10 e0       	ldi	r17, 0x00	; 0
    ed00:	76 01       	movw	r14, r12
    ed02:	08 94       	sec
    ed04:	e1 1c       	adc	r14, r1
    ed06:	f1 1c       	adc	r15, r1
    ed08:	e0 1a       	sub	r14, r16
    ed0a:	f1 0a       	sbc	r15, r17
    ed0c:	41 e0       	ldi	r20, 0x01	; 1
    ed0e:	50 e0       	ldi	r21, 0x00	; 0
    ed10:	4c 0f       	add	r20, r28
    ed12:	5d 1f       	adc	r21, r29
    ed14:	e4 0e       	add	r14, r20
    ed16:	f5 1e       	adc	r15, r21
    ed18:	26 01       	movw	r4, r12
    ed1a:	4b 18       	sub	r4, r11
    ed1c:	51 08       	sbc	r5, r1
    ed1e:	89 2d       	mov	r24, r9
    ed20:	90 e0       	ldi	r25, 0x00	; 0
    ed22:	aa 24       	eor	r10, r10
    ed24:	bb 24       	eor	r11, r11
    ed26:	a8 1a       	sub	r10, r24
    ed28:	b9 0a       	sbc	r11, r25
    ed2a:	5f ef       	ldi	r21, 0xFF	; 255
    ed2c:	0f 3f       	cpi	r16, 0xFF	; 255
    ed2e:	15 07       	cpc	r17, r21
    ed30:	29 f4       	brne	.+10     	; 0xed3c <vfprintf+0x394>
    ed32:	8e e2       	ldi	r24, 0x2E	; 46
    ed34:	90 e0       	ldi	r25, 0x00	; 0
    ed36:	b3 01       	movw	r22, r6
    ed38:	0e 94 81 7f 	call	0xff02	; 0xff02 <fputc>
    ed3c:	c0 16       	cp	r12, r16
    ed3e:	d1 06       	cpc	r13, r17
    ed40:	34 f0       	brlt	.+12     	; 0xed4e <vfprintf+0x3a6>
    ed42:	40 16       	cp	r4, r16
    ed44:	51 06       	cpc	r5, r17
    ed46:	1c f4       	brge	.+6      	; 0xed4e <vfprintf+0x3a6>
    ed48:	f7 01       	movw	r30, r14
    ed4a:	80 81       	ld	r24, Z
    ed4c:	01 c0       	rjmp	.+2      	; 0xed50 <vfprintf+0x3a8>
    ed4e:	80 e3       	ldi	r24, 0x30	; 48
    ed50:	01 50       	subi	r16, 0x01	; 1
    ed52:	10 40       	sbci	r17, 0x00	; 0
    ed54:	08 94       	sec
    ed56:	e1 1c       	adc	r14, r1
    ed58:	f1 1c       	adc	r15, r1
    ed5a:	0a 15       	cp	r16, r10
    ed5c:	1b 05       	cpc	r17, r11
    ed5e:	2c f0       	brlt	.+10     	; 0xed6a <vfprintf+0x3c2>
    ed60:	90 e0       	ldi	r25, 0x00	; 0
    ed62:	b3 01       	movw	r22, r6
    ed64:	0e 94 81 7f 	call	0xff02	; 0xff02 <fputc>
    ed68:	e0 cf       	rjmp	.-64     	; 0xed2a <vfprintf+0x382>
    ed6a:	0c 15       	cp	r16, r12
    ed6c:	1d 05       	cpc	r17, r13
    ed6e:	39 f4       	brne	.+14     	; 0xed7e <vfprintf+0x3d6>
    ed70:	9a 81       	ldd	r25, Y+2	; 0x02
    ed72:	96 33       	cpi	r25, 0x36	; 54
    ed74:	18 f4       	brcc	.+6      	; 0xed7c <vfprintf+0x3d4>
    ed76:	95 33       	cpi	r25, 0x35	; 53
    ed78:	11 f4       	brne	.+4      	; 0xed7e <vfprintf+0x3d6>
    ed7a:	24 fe       	sbrs	r2, 4
    ed7c:	81 e3       	ldi	r24, 0x31	; 49
    ed7e:	90 e0       	ldi	r25, 0x00	; 0
    ed80:	4b c0       	rjmp	.+150    	; 0xee18 <vfprintf+0x470>
    ed82:	8a 81       	ldd	r24, Y+2	; 0x02
    ed84:	81 33       	cpi	r24, 0x31	; 49
    ed86:	09 f0       	breq	.+2      	; 0xed8a <vfprintf+0x3e2>
    ed88:	0f 7e       	andi	r16, 0xEF	; 239
    ed8a:	90 e0       	ldi	r25, 0x00	; 0
    ed8c:	b3 01       	movw	r22, r6
    ed8e:	0e 94 81 7f 	call	0xff02	; 0xff02 <fputc>
    ed92:	99 20       	and	r9, r9
    ed94:	a1 f0       	breq	.+40     	; 0xedbe <vfprintf+0x416>
    ed96:	8e e2       	ldi	r24, 0x2E	; 46
    ed98:	90 e0       	ldi	r25, 0x00	; 0
    ed9a:	b3 01       	movw	r22, r6
    ed9c:	0e 94 81 7f 	call	0xff02	; 0xff02 <fputc>
    eda0:	12 e0       	ldi	r17, 0x02	; 2
    eda2:	e1 e0       	ldi	r30, 0x01	; 1
    eda4:	f0 e0       	ldi	r31, 0x00	; 0
    eda6:	ec 0f       	add	r30, r28
    eda8:	fd 1f       	adc	r31, r29
    edaa:	e1 0f       	add	r30, r17
    edac:	f1 1d       	adc	r31, r1
    edae:	1f 5f       	subi	r17, 0xFF	; 255
    edb0:	80 81       	ld	r24, Z
    edb2:	90 e0       	ldi	r25, 0x00	; 0
    edb4:	b3 01       	movw	r22, r6
    edb6:	0e 94 81 7f 	call	0xff02	; 0xff02 <fputc>
    edba:	9a 94       	dec	r9
    edbc:	91 f7       	brne	.-28     	; 0xeda2 <vfprintf+0x3fa>
    edbe:	44 fc       	sbrc	r4, 4
    edc0:	03 c0       	rjmp	.+6      	; 0xedc8 <vfprintf+0x420>
    edc2:	85 e6       	ldi	r24, 0x65	; 101
    edc4:	90 e0       	ldi	r25, 0x00	; 0
    edc6:	02 c0       	rjmp	.+4      	; 0xedcc <vfprintf+0x424>
    edc8:	85 e4       	ldi	r24, 0x45	; 69
    edca:	90 e0       	ldi	r25, 0x00	; 0
    edcc:	b3 01       	movw	r22, r6
    edce:	0e 94 81 7f 	call	0xff02	; 0xff02 <fputc>
    edd2:	d7 fc       	sbrc	r13, 7
    edd4:	05 c0       	rjmp	.+10     	; 0xede0 <vfprintf+0x438>
    edd6:	c1 14       	cp	r12, r1
    edd8:	d1 04       	cpc	r13, r1
    edda:	41 f4       	brne	.+16     	; 0xedec <vfprintf+0x444>
    eddc:	04 ff       	sbrs	r16, 4
    edde:	06 c0       	rjmp	.+12     	; 0xedec <vfprintf+0x444>
    ede0:	d0 94       	com	r13
    ede2:	c1 94       	neg	r12
    ede4:	d1 08       	sbc	r13, r1
    ede6:	d3 94       	inc	r13
    ede8:	8d e2       	ldi	r24, 0x2D	; 45
    edea:	01 c0       	rjmp	.+2      	; 0xedee <vfprintf+0x446>
    edec:	8b e2       	ldi	r24, 0x2B	; 43
    edee:	90 e0       	ldi	r25, 0x00	; 0
    edf0:	b3 01       	movw	r22, r6
    edf2:	0e 94 81 7f 	call	0xff02	; 0xff02 <fputc>
    edf6:	80 e3       	ldi	r24, 0x30	; 48
    edf8:	05 c0       	rjmp	.+10     	; 0xee04 <vfprintf+0x45c>
    edfa:	8f 5f       	subi	r24, 0xFF	; 255
    edfc:	26 ef       	ldi	r18, 0xF6	; 246
    edfe:	3f ef       	ldi	r19, 0xFF	; 255
    ee00:	c2 0e       	add	r12, r18
    ee02:	d3 1e       	adc	r13, r19
    ee04:	3a e0       	ldi	r19, 0x0A	; 10
    ee06:	c3 16       	cp	r12, r19
    ee08:	d1 04       	cpc	r13, r1
    ee0a:	bc f7       	brge	.-18     	; 0xedfa <vfprintf+0x452>
    ee0c:	90 e0       	ldi	r25, 0x00	; 0
    ee0e:	b3 01       	movw	r22, r6
    ee10:	0e 94 81 7f 	call	0xff02	; 0xff02 <fputc>
    ee14:	c6 01       	movw	r24, r12
    ee16:	c0 96       	adiw	r24, 0x30	; 48
    ee18:	b3 01       	movw	r22, r6
    ee1a:	0e 94 81 7f 	call	0xff02	; 0xff02 <fputc>
    ee1e:	cc 84       	ldd	r12, Y+12	; 0x0c
    ee20:	dd 84       	ldd	r13, Y+13	; 0x0d
    ee22:	52 c1       	rjmp	.+676    	; 0xf0c8 <vfprintf+0x720>
    ee24:	93 36       	cpi	r25, 0x63	; 99
    ee26:	31 f0       	breq	.+12     	; 0xee34 <vfprintf+0x48c>
    ee28:	93 37       	cpi	r25, 0x73	; 115
    ee2a:	99 f0       	breq	.+38     	; 0xee52 <vfprintf+0x4aa>
    ee2c:	93 35       	cpi	r25, 0x53	; 83
    ee2e:	09 f0       	breq	.+2      	; 0xee32 <vfprintf+0x48a>
    ee30:	59 c0       	rjmp	.+178    	; 0xeee4 <vfprintf+0x53c>
    ee32:	23 c0       	rjmp	.+70     	; 0xee7a <vfprintf+0x4d2>
    ee34:	f6 01       	movw	r30, r12
    ee36:	80 81       	ld	r24, Z
    ee38:	89 83       	std	Y+1, r24	; 0x01
    ee3a:	5e 01       	movw	r10, r28
    ee3c:	08 94       	sec
    ee3e:	a1 1c       	adc	r10, r1
    ee40:	b1 1c       	adc	r11, r1
    ee42:	22 e0       	ldi	r18, 0x02	; 2
    ee44:	30 e0       	ldi	r19, 0x00	; 0
    ee46:	c2 0e       	add	r12, r18
    ee48:	d3 1e       	adc	r13, r19
    ee4a:	21 e0       	ldi	r18, 0x01	; 1
    ee4c:	e2 2e       	mov	r14, r18
    ee4e:	f1 2c       	mov	r15, r1
    ee50:	12 c0       	rjmp	.+36     	; 0xee76 <vfprintf+0x4ce>
    ee52:	f6 01       	movw	r30, r12
    ee54:	a0 80       	ld	r10, Z
    ee56:	b1 80       	ldd	r11, Z+1	; 0x01
    ee58:	16 fd       	sbrc	r17, 6
    ee5a:	03 c0       	rjmp	.+6      	; 0xee62 <vfprintf+0x4ba>
    ee5c:	6f ef       	ldi	r22, 0xFF	; 255
    ee5e:	7f ef       	ldi	r23, 0xFF	; 255
    ee60:	02 c0       	rjmp	.+4      	; 0xee66 <vfprintf+0x4be>
    ee62:	69 2d       	mov	r22, r9
    ee64:	70 e0       	ldi	r23, 0x00	; 0
    ee66:	22 e0       	ldi	r18, 0x02	; 2
    ee68:	30 e0       	ldi	r19, 0x00	; 0
    ee6a:	c2 0e       	add	r12, r18
    ee6c:	d3 1e       	adc	r13, r19
    ee6e:	c5 01       	movw	r24, r10
    ee70:	0e 94 1a 7f 	call	0xfe34	; 0xfe34 <strnlen>
    ee74:	7c 01       	movw	r14, r24
    ee76:	1f 77       	andi	r17, 0x7F	; 127
    ee78:	13 c0       	rjmp	.+38     	; 0xeea0 <vfprintf+0x4f8>
    ee7a:	f6 01       	movw	r30, r12
    ee7c:	a0 80       	ld	r10, Z
    ee7e:	b1 80       	ldd	r11, Z+1	; 0x01
    ee80:	16 fd       	sbrc	r17, 6
    ee82:	03 c0       	rjmp	.+6      	; 0xee8a <vfprintf+0x4e2>
    ee84:	6f ef       	ldi	r22, 0xFF	; 255
    ee86:	7f ef       	ldi	r23, 0xFF	; 255
    ee88:	02 c0       	rjmp	.+4      	; 0xee8e <vfprintf+0x4e6>
    ee8a:	69 2d       	mov	r22, r9
    ee8c:	70 e0       	ldi	r23, 0x00	; 0
    ee8e:	22 e0       	ldi	r18, 0x02	; 2
    ee90:	30 e0       	ldi	r19, 0x00	; 0
    ee92:	c2 0e       	add	r12, r18
    ee94:	d3 1e       	adc	r13, r19
    ee96:	c5 01       	movw	r24, r10
    ee98:	0e 94 d8 7e 	call	0xfdb0	; 0xfdb0 <strnlen_P>
    ee9c:	7c 01       	movw	r14, r24
    ee9e:	10 68       	ori	r17, 0x80	; 128
    eea0:	13 ff       	sbrs	r17, 3
    eea2:	07 c0       	rjmp	.+14     	; 0xeeb2 <vfprintf+0x50a>
    eea4:	1b c0       	rjmp	.+54     	; 0xeedc <vfprintf+0x534>
    eea6:	80 e2       	ldi	r24, 0x20	; 32
    eea8:	90 e0       	ldi	r25, 0x00	; 0
    eeaa:	b3 01       	movw	r22, r6
    eeac:	0e 94 81 7f 	call	0xff02	; 0xff02 <fputc>
    eeb0:	8a 94       	dec	r8
    eeb2:	88 2d       	mov	r24, r8
    eeb4:	90 e0       	ldi	r25, 0x00	; 0
    eeb6:	e8 16       	cp	r14, r24
    eeb8:	f9 06       	cpc	r15, r25
    eeba:	a8 f3       	brcs	.-22     	; 0xeea6 <vfprintf+0x4fe>
    eebc:	0f c0       	rjmp	.+30     	; 0xeedc <vfprintf+0x534>
    eebe:	f5 01       	movw	r30, r10
    eec0:	17 fd       	sbrc	r17, 7
    eec2:	85 91       	lpm	r24, Z+
    eec4:	17 ff       	sbrs	r17, 7
    eec6:	81 91       	ld	r24, Z+
    eec8:	5f 01       	movw	r10, r30
    eeca:	90 e0       	ldi	r25, 0x00	; 0
    eecc:	b3 01       	movw	r22, r6
    eece:	0e 94 81 7f 	call	0xff02	; 0xff02 <fputc>
    eed2:	81 10       	cpse	r8, r1
    eed4:	8a 94       	dec	r8
    eed6:	08 94       	sec
    eed8:	e1 08       	sbc	r14, r1
    eeda:	f1 08       	sbc	r15, r1
    eedc:	e1 14       	cp	r14, r1
    eede:	f1 04       	cpc	r15, r1
    eee0:	71 f7       	brne	.-36     	; 0xeebe <vfprintf+0x516>
    eee2:	f2 c0       	rjmp	.+484    	; 0xf0c8 <vfprintf+0x720>
    eee4:	94 36       	cpi	r25, 0x64	; 100
    eee6:	11 f0       	breq	.+4      	; 0xeeec <vfprintf+0x544>
    eee8:	99 36       	cpi	r25, 0x69	; 105
    eeea:	89 f5       	brne	.+98     	; 0xef4e <vfprintf+0x5a6>
    eeec:	17 ff       	sbrs	r17, 7
    eeee:	08 c0       	rjmp	.+16     	; 0xef00 <vfprintf+0x558>
    eef0:	f6 01       	movw	r30, r12
    eef2:	20 81       	ld	r18, Z
    eef4:	31 81       	ldd	r19, Z+1	; 0x01
    eef6:	42 81       	ldd	r20, Z+2	; 0x02
    eef8:	53 81       	ldd	r21, Z+3	; 0x03
    eefa:	84 e0       	ldi	r24, 0x04	; 4
    eefc:	90 e0       	ldi	r25, 0x00	; 0
    eefe:	0a c0       	rjmp	.+20     	; 0xef14 <vfprintf+0x56c>
    ef00:	f6 01       	movw	r30, r12
    ef02:	80 81       	ld	r24, Z
    ef04:	91 81       	ldd	r25, Z+1	; 0x01
    ef06:	9c 01       	movw	r18, r24
    ef08:	44 27       	eor	r20, r20
    ef0a:	37 fd       	sbrc	r19, 7
    ef0c:	40 95       	com	r20
    ef0e:	54 2f       	mov	r21, r20
    ef10:	82 e0       	ldi	r24, 0x02	; 2
    ef12:	90 e0       	ldi	r25, 0x00	; 0
    ef14:	c8 0e       	add	r12, r24
    ef16:	d9 1e       	adc	r13, r25
    ef18:	9f e6       	ldi	r25, 0x6F	; 111
    ef1a:	f9 2e       	mov	r15, r25
    ef1c:	f1 22       	and	r15, r17
    ef1e:	57 ff       	sbrs	r21, 7
    ef20:	09 c0       	rjmp	.+18     	; 0xef34 <vfprintf+0x58c>
    ef22:	50 95       	com	r21
    ef24:	40 95       	com	r20
    ef26:	30 95       	com	r19
    ef28:	21 95       	neg	r18
    ef2a:	3f 4f       	sbci	r19, 0xFF	; 255
    ef2c:	4f 4f       	sbci	r20, 0xFF	; 255
    ef2e:	5f 4f       	sbci	r21, 0xFF	; 255
    ef30:	90 e8       	ldi	r25, 0x80	; 128
    ef32:	f9 2a       	or	r15, r25
    ef34:	ca 01       	movw	r24, r20
    ef36:	b9 01       	movw	r22, r18
    ef38:	ae 01       	movw	r20, r28
    ef3a:	4f 5f       	subi	r20, 0xFF	; 255
    ef3c:	5f 4f       	sbci	r21, 0xFF	; 255
    ef3e:	2a e0       	ldi	r18, 0x0A	; 10
    ef40:	30 e0       	ldi	r19, 0x00	; 0
    ef42:	0e 94 6f 80 	call	0x100de	; 0x100de <__ultoa_invert>
    ef46:	e8 2e       	mov	r14, r24
    ef48:	e8 89       	ldd	r30, Y+16	; 0x10
    ef4a:	ee 1a       	sub	r14, r30
    ef4c:	41 c0       	rjmp	.+130    	; 0xefd0 <vfprintf+0x628>
    ef4e:	95 37       	cpi	r25, 0x75	; 117
    ef50:	21 f4       	brne	.+8      	; 0xef5a <vfprintf+0x5b2>
    ef52:	1f 7e       	andi	r17, 0xEF	; 239
    ef54:	2a e0       	ldi	r18, 0x0A	; 10
    ef56:	30 e0       	ldi	r19, 0x00	; 0
    ef58:	1c c0       	rjmp	.+56     	; 0xef92 <vfprintf+0x5ea>
    ef5a:	19 7f       	andi	r17, 0xF9	; 249
    ef5c:	9f 36       	cpi	r25, 0x6F	; 111
    ef5e:	61 f0       	breq	.+24     	; 0xef78 <vfprintf+0x5d0>
    ef60:	90 37       	cpi	r25, 0x70	; 112
    ef62:	20 f4       	brcc	.+8      	; 0xef6c <vfprintf+0x5c4>
    ef64:	98 35       	cpi	r25, 0x58	; 88
    ef66:	09 f0       	breq	.+2      	; 0xef6a <vfprintf+0x5c2>
    ef68:	b2 c0       	rjmp	.+356    	; 0xf0ce <vfprintf+0x726>
    ef6a:	0f c0       	rjmp	.+30     	; 0xef8a <vfprintf+0x5e2>
    ef6c:	90 37       	cpi	r25, 0x70	; 112
    ef6e:	39 f0       	breq	.+14     	; 0xef7e <vfprintf+0x5d6>
    ef70:	98 37       	cpi	r25, 0x78	; 120
    ef72:	09 f0       	breq	.+2      	; 0xef76 <vfprintf+0x5ce>
    ef74:	ac c0       	rjmp	.+344    	; 0xf0ce <vfprintf+0x726>
    ef76:	04 c0       	rjmp	.+8      	; 0xef80 <vfprintf+0x5d8>
    ef78:	28 e0       	ldi	r18, 0x08	; 8
    ef7a:	30 e0       	ldi	r19, 0x00	; 0
    ef7c:	0a c0       	rjmp	.+20     	; 0xef92 <vfprintf+0x5ea>
    ef7e:	10 61       	ori	r17, 0x10	; 16
    ef80:	14 fd       	sbrc	r17, 4
    ef82:	14 60       	ori	r17, 0x04	; 4
    ef84:	20 e1       	ldi	r18, 0x10	; 16
    ef86:	30 e0       	ldi	r19, 0x00	; 0
    ef88:	04 c0       	rjmp	.+8      	; 0xef92 <vfprintf+0x5ea>
    ef8a:	14 fd       	sbrc	r17, 4
    ef8c:	16 60       	ori	r17, 0x06	; 6
    ef8e:	20 e1       	ldi	r18, 0x10	; 16
    ef90:	32 e0       	ldi	r19, 0x02	; 2
    ef92:	17 ff       	sbrs	r17, 7
    ef94:	08 c0       	rjmp	.+16     	; 0xefa6 <vfprintf+0x5fe>
    ef96:	f6 01       	movw	r30, r12
    ef98:	60 81       	ld	r22, Z
    ef9a:	71 81       	ldd	r23, Z+1	; 0x01
    ef9c:	82 81       	ldd	r24, Z+2	; 0x02
    ef9e:	93 81       	ldd	r25, Z+3	; 0x03
    efa0:	44 e0       	ldi	r20, 0x04	; 4
    efa2:	50 e0       	ldi	r21, 0x00	; 0
    efa4:	08 c0       	rjmp	.+16     	; 0xefb6 <vfprintf+0x60e>
    efa6:	f6 01       	movw	r30, r12
    efa8:	80 81       	ld	r24, Z
    efaa:	91 81       	ldd	r25, Z+1	; 0x01
    efac:	bc 01       	movw	r22, r24
    efae:	80 e0       	ldi	r24, 0x00	; 0
    efb0:	90 e0       	ldi	r25, 0x00	; 0
    efb2:	42 e0       	ldi	r20, 0x02	; 2
    efb4:	50 e0       	ldi	r21, 0x00	; 0
    efb6:	c4 0e       	add	r12, r20
    efb8:	d5 1e       	adc	r13, r21
    efba:	ae 01       	movw	r20, r28
    efbc:	4f 5f       	subi	r20, 0xFF	; 255
    efbe:	5f 4f       	sbci	r21, 0xFF	; 255
    efc0:	0e 94 6f 80 	call	0x100de	; 0x100de <__ultoa_invert>
    efc4:	e8 2e       	mov	r14, r24
    efc6:	58 89       	ldd	r21, Y+16	; 0x10
    efc8:	e5 1a       	sub	r14, r21
    efca:	8f e7       	ldi	r24, 0x7F	; 127
    efcc:	f8 2e       	mov	r15, r24
    efce:	f1 22       	and	r15, r17
    efd0:	f6 fe       	sbrs	r15, 6
    efd2:	0b c0       	rjmp	.+22     	; 0xefea <vfprintf+0x642>
    efd4:	8e ef       	ldi	r24, 0xFE	; 254
    efd6:	f8 22       	and	r15, r24
    efd8:	e9 14       	cp	r14, r9
    efda:	38 f4       	brcc	.+14     	; 0xefea <vfprintf+0x642>
    efdc:	f4 fe       	sbrs	r15, 4
    efde:	07 c0       	rjmp	.+14     	; 0xefee <vfprintf+0x646>
    efe0:	f2 fc       	sbrc	r15, 2
    efe2:	05 c0       	rjmp	.+10     	; 0xefee <vfprintf+0x646>
    efe4:	9f ee       	ldi	r25, 0xEF	; 239
    efe6:	f9 22       	and	r15, r25
    efe8:	02 c0       	rjmp	.+4      	; 0xefee <vfprintf+0x646>
    efea:	1e 2d       	mov	r17, r14
    efec:	01 c0       	rjmp	.+2      	; 0xeff0 <vfprintf+0x648>
    efee:	19 2d       	mov	r17, r9
    eff0:	f4 fe       	sbrs	r15, 4
    eff2:	0d c0       	rjmp	.+26     	; 0xf00e <vfprintf+0x666>
    eff4:	fe 01       	movw	r30, r28
    eff6:	ee 0d       	add	r30, r14
    eff8:	f1 1d       	adc	r31, r1
    effa:	80 81       	ld	r24, Z
    effc:	80 33       	cpi	r24, 0x30	; 48
    effe:	19 f4       	brne	.+6      	; 0xf006 <vfprintf+0x65e>
    f000:	e9 ee       	ldi	r30, 0xE9	; 233
    f002:	fe 22       	and	r15, r30
    f004:	08 c0       	rjmp	.+16     	; 0xf016 <vfprintf+0x66e>
    f006:	1f 5f       	subi	r17, 0xFF	; 255
    f008:	f2 fe       	sbrs	r15, 2
    f00a:	05 c0       	rjmp	.+10     	; 0xf016 <vfprintf+0x66e>
    f00c:	03 c0       	rjmp	.+6      	; 0xf014 <vfprintf+0x66c>
    f00e:	8f 2d       	mov	r24, r15
    f010:	86 78       	andi	r24, 0x86	; 134
    f012:	09 f0       	breq	.+2      	; 0xf016 <vfprintf+0x66e>
    f014:	1f 5f       	subi	r17, 0xFF	; 255
    f016:	0f 2d       	mov	r16, r15
    f018:	f3 fc       	sbrc	r15, 3
    f01a:	14 c0       	rjmp	.+40     	; 0xf044 <vfprintf+0x69c>
    f01c:	f0 fe       	sbrs	r15, 0
    f01e:	0f c0       	rjmp	.+30     	; 0xf03e <vfprintf+0x696>
    f020:	18 15       	cp	r17, r8
    f022:	10 f0       	brcs	.+4      	; 0xf028 <vfprintf+0x680>
    f024:	9e 2c       	mov	r9, r14
    f026:	0b c0       	rjmp	.+22     	; 0xf03e <vfprintf+0x696>
    f028:	9e 2c       	mov	r9, r14
    f02a:	98 0c       	add	r9, r8
    f02c:	91 1a       	sub	r9, r17
    f02e:	18 2d       	mov	r17, r8
    f030:	06 c0       	rjmp	.+12     	; 0xf03e <vfprintf+0x696>
    f032:	80 e2       	ldi	r24, 0x20	; 32
    f034:	90 e0       	ldi	r25, 0x00	; 0
    f036:	b3 01       	movw	r22, r6
    f038:	0e 94 81 7f 	call	0xff02	; 0xff02 <fputc>
    f03c:	1f 5f       	subi	r17, 0xFF	; 255
    f03e:	18 15       	cp	r17, r8
    f040:	c0 f3       	brcs	.-16     	; 0xf032 <vfprintf+0x68a>
    f042:	04 c0       	rjmp	.+8      	; 0xf04c <vfprintf+0x6a4>
    f044:	18 15       	cp	r17, r8
    f046:	10 f4       	brcc	.+4      	; 0xf04c <vfprintf+0x6a4>
    f048:	81 1a       	sub	r8, r17
    f04a:	01 c0       	rjmp	.+2      	; 0xf04e <vfprintf+0x6a6>
    f04c:	88 24       	eor	r8, r8
    f04e:	04 ff       	sbrs	r16, 4
    f050:	0f c0       	rjmp	.+30     	; 0xf070 <vfprintf+0x6c8>
    f052:	80 e3       	ldi	r24, 0x30	; 48
    f054:	90 e0       	ldi	r25, 0x00	; 0
    f056:	b3 01       	movw	r22, r6
    f058:	0e 94 81 7f 	call	0xff02	; 0xff02 <fputc>
    f05c:	02 ff       	sbrs	r16, 2
    f05e:	1d c0       	rjmp	.+58     	; 0xf09a <vfprintf+0x6f2>
    f060:	01 fd       	sbrc	r16, 1
    f062:	03 c0       	rjmp	.+6      	; 0xf06a <vfprintf+0x6c2>
    f064:	88 e7       	ldi	r24, 0x78	; 120
    f066:	90 e0       	ldi	r25, 0x00	; 0
    f068:	0e c0       	rjmp	.+28     	; 0xf086 <vfprintf+0x6de>
    f06a:	88 e5       	ldi	r24, 0x58	; 88
    f06c:	90 e0       	ldi	r25, 0x00	; 0
    f06e:	0b c0       	rjmp	.+22     	; 0xf086 <vfprintf+0x6de>
    f070:	80 2f       	mov	r24, r16
    f072:	86 78       	andi	r24, 0x86	; 134
    f074:	91 f0       	breq	.+36     	; 0xf09a <vfprintf+0x6f2>
    f076:	01 ff       	sbrs	r16, 1
    f078:	02 c0       	rjmp	.+4      	; 0xf07e <vfprintf+0x6d6>
    f07a:	8b e2       	ldi	r24, 0x2B	; 43
    f07c:	01 c0       	rjmp	.+2      	; 0xf080 <vfprintf+0x6d8>
    f07e:	80 e2       	ldi	r24, 0x20	; 32
    f080:	f7 fc       	sbrc	r15, 7
    f082:	8d e2       	ldi	r24, 0x2D	; 45
    f084:	90 e0       	ldi	r25, 0x00	; 0
    f086:	b3 01       	movw	r22, r6
    f088:	0e 94 81 7f 	call	0xff02	; 0xff02 <fputc>
    f08c:	06 c0       	rjmp	.+12     	; 0xf09a <vfprintf+0x6f2>
    f08e:	80 e3       	ldi	r24, 0x30	; 48
    f090:	90 e0       	ldi	r25, 0x00	; 0
    f092:	b3 01       	movw	r22, r6
    f094:	0e 94 81 7f 	call	0xff02	; 0xff02 <fputc>
    f098:	9a 94       	dec	r9
    f09a:	e9 14       	cp	r14, r9
    f09c:	c0 f3       	brcs	.-16     	; 0xf08e <vfprintf+0x6e6>
    f09e:	ea 94       	dec	r14
    f0a0:	e1 e0       	ldi	r30, 0x01	; 1
    f0a2:	f0 e0       	ldi	r31, 0x00	; 0
    f0a4:	ec 0f       	add	r30, r28
    f0a6:	fd 1f       	adc	r31, r29
    f0a8:	ee 0d       	add	r30, r14
    f0aa:	f1 1d       	adc	r31, r1
    f0ac:	80 81       	ld	r24, Z
    f0ae:	90 e0       	ldi	r25, 0x00	; 0
    f0b0:	b3 01       	movw	r22, r6
    f0b2:	0e 94 81 7f 	call	0xff02	; 0xff02 <fputc>
    f0b6:	ee 20       	and	r14, r14
    f0b8:	91 f7       	brne	.-28     	; 0xf09e <vfprintf+0x6f6>
    f0ba:	06 c0       	rjmp	.+12     	; 0xf0c8 <vfprintf+0x720>
    f0bc:	80 e2       	ldi	r24, 0x20	; 32
    f0be:	90 e0       	ldi	r25, 0x00	; 0
    f0c0:	b3 01       	movw	r22, r6
    f0c2:	0e 94 81 7f 	call	0xff02	; 0xff02 <fputc>
    f0c6:	8a 94       	dec	r8
    f0c8:	88 20       	and	r8, r8
    f0ca:	c1 f7       	brne	.-16     	; 0xf0bc <vfprintf+0x714>
    f0cc:	99 cc       	rjmp	.-1742   	; 0xea00 <vfprintf+0x58>
    f0ce:	f3 01       	movw	r30, r6
    f0d0:	66 81       	ldd	r22, Z+6	; 0x06
    f0d2:	77 81       	ldd	r23, Z+7	; 0x07
    f0d4:	cb 01       	movw	r24, r22
    f0d6:	61 96       	adiw	r28, 0x11	; 17
    f0d8:	0f b6       	in	r0, 0x3f	; 63
    f0da:	f8 94       	cli
    f0dc:	de bf       	out	0x3e, r29	; 62
    f0de:	0f be       	out	0x3f, r0	; 63
    f0e0:	cd bf       	out	0x3d, r28	; 61
    f0e2:	cf 91       	pop	r28
    f0e4:	df 91       	pop	r29
    f0e6:	1f 91       	pop	r17
    f0e8:	0f 91       	pop	r16
    f0ea:	ff 90       	pop	r15
    f0ec:	ef 90       	pop	r14
    f0ee:	df 90       	pop	r13
    f0f0:	cf 90       	pop	r12
    f0f2:	bf 90       	pop	r11
    f0f4:	af 90       	pop	r10
    f0f6:	9f 90       	pop	r9
    f0f8:	8f 90       	pop	r8
    f0fa:	7f 90       	pop	r7
    f0fc:	6f 90       	pop	r6
    f0fe:	5f 90       	pop	r5
    f100:	4f 90       	pop	r4
    f102:	3f 90       	pop	r3
    f104:	2f 90       	pop	r2
    f106:	08 95       	ret

0000f108 <putval>:
    f108:	fc 01       	movw	r30, r24
    f10a:	20 fd       	sbrc	r18, 0
    f10c:	08 c0       	rjmp	.+16     	; 0xf11e <putval+0x16>
    f10e:	23 fd       	sbrc	r18, 3
    f110:	05 c0       	rjmp	.+10     	; 0xf11c <putval+0x14>
    f112:	22 ff       	sbrs	r18, 2
    f114:	02 c0       	rjmp	.+4      	; 0xf11a <putval+0x12>
    f116:	73 83       	std	Z+3, r23	; 0x03
    f118:	62 83       	std	Z+2, r22	; 0x02
    f11a:	51 83       	std	Z+1, r21	; 0x01
    f11c:	40 83       	st	Z, r20
    f11e:	08 95       	ret

0000f120 <mulacc>:
    f120:	ef 92       	push	r14
    f122:	ff 92       	push	r15
    f124:	0f 93       	push	r16
    f126:	1f 93       	push	r17
    f128:	44 ff       	sbrs	r20, 4
    f12a:	02 c0       	rjmp	.+4      	; 0xf130 <mulacc+0x10>
    f12c:	33 e0       	ldi	r19, 0x03	; 3
    f12e:	11 c0       	rjmp	.+34     	; 0xf152 <mulacc+0x32>
    f130:	46 ff       	sbrs	r20, 6
    f132:	02 c0       	rjmp	.+4      	; 0xf138 <mulacc+0x18>
    f134:	34 e0       	ldi	r19, 0x04	; 4
    f136:	0d c0       	rjmp	.+26     	; 0xf152 <mulacc+0x32>
    f138:	db 01       	movw	r26, r22
    f13a:	fc 01       	movw	r30, r24
    f13c:	aa 0f       	add	r26, r26
    f13e:	bb 1f       	adc	r27, r27
    f140:	ee 1f       	adc	r30, r30
    f142:	ff 1f       	adc	r31, r31
    f144:	10 94       	com	r1
    f146:	d1 f7       	brne	.-12     	; 0xf13c <mulacc+0x1c>
    f148:	6a 0f       	add	r22, r26
    f14a:	7b 1f       	adc	r23, r27
    f14c:	8e 1f       	adc	r24, r30
    f14e:	9f 1f       	adc	r25, r31
    f150:	31 e0       	ldi	r19, 0x01	; 1
    f152:	66 0f       	add	r22, r22
    f154:	77 1f       	adc	r23, r23
    f156:	88 1f       	adc	r24, r24
    f158:	99 1f       	adc	r25, r25
    f15a:	31 50       	subi	r19, 0x01	; 1
    f15c:	d1 f7       	brne	.-12     	; 0xf152 <mulacc+0x32>
    f15e:	7b 01       	movw	r14, r22
    f160:	8c 01       	movw	r16, r24
    f162:	e2 0e       	add	r14, r18
    f164:	f1 1c       	adc	r15, r1
    f166:	01 1d       	adc	r16, r1
    f168:	11 1d       	adc	r17, r1
    f16a:	a8 01       	movw	r20, r16
    f16c:	97 01       	movw	r18, r14
    f16e:	b7 01       	movw	r22, r14
    f170:	ca 01       	movw	r24, r20
    f172:	1f 91       	pop	r17
    f174:	0f 91       	pop	r16
    f176:	ff 90       	pop	r15
    f178:	ef 90       	pop	r14
    f17a:	08 95       	ret

0000f17c <skip_spaces>:
    f17c:	0f 93       	push	r16
    f17e:	1f 93       	push	r17
    f180:	cf 93       	push	r28
    f182:	df 93       	push	r29
    f184:	8c 01       	movw	r16, r24
    f186:	c8 01       	movw	r24, r16
    f188:	0e 94 3f 7f 	call	0xfe7e	; 0xfe7e <fgetc>
    f18c:	ec 01       	movw	r28, r24
    f18e:	97 fd       	sbrc	r25, 7
    f190:	08 c0       	rjmp	.+16     	; 0xf1a2 <skip_spaces+0x26>
    f192:	0e 94 96 7e 	call	0xfd2c	; 0xfd2c <isspace>
    f196:	89 2b       	or	r24, r25
    f198:	b1 f7       	brne	.-20     	; 0xf186 <skip_spaces+0xa>
    f19a:	ce 01       	movw	r24, r28
    f19c:	b8 01       	movw	r22, r16
    f19e:	0e 94 55 80 	call	0x100aa	; 0x100aa <ungetc>
    f1a2:	ce 01       	movw	r24, r28
    f1a4:	df 91       	pop	r29
    f1a6:	cf 91       	pop	r28
    f1a8:	1f 91       	pop	r17
    f1aa:	0f 91       	pop	r16
    f1ac:	08 95       	ret

0000f1ae <conv_int>:
    f1ae:	8f 92       	push	r8
    f1b0:	9f 92       	push	r9
    f1b2:	af 92       	push	r10
    f1b4:	bf 92       	push	r11
    f1b6:	df 92       	push	r13
    f1b8:	ef 92       	push	r14
    f1ba:	ff 92       	push	r15
    f1bc:	0f 93       	push	r16
    f1be:	1f 93       	push	r17
    f1c0:	cf 93       	push	r28
    f1c2:	df 93       	push	r29
    f1c4:	5c 01       	movw	r10, r24
    f1c6:	eb 01       	movw	r28, r22
    f1c8:	4a 01       	movw	r8, r20
    f1ca:	12 2f       	mov	r17, r18
    f1cc:	0e 94 3f 7f 	call	0xfe7e	; 0xfe7e <fgetc>
    f1d0:	ac 01       	movw	r20, r24
    f1d2:	8b 32       	cpi	r24, 0x2B	; 43
    f1d4:	19 f0       	breq	.+6      	; 0xf1dc <conv_int+0x2e>
    f1d6:	8d 32       	cpi	r24, 0x2D	; 45
    f1d8:	51 f4       	brne	.+20     	; 0xf1ee <conv_int+0x40>
    f1da:	10 68       	ori	r17, 0x80	; 128
    f1dc:	21 97       	sbiw	r28, 0x01	; 1
    f1de:	09 f4       	brne	.+2      	; 0xf1e2 <conv_int+0x34>
    f1e0:	6d c0       	rjmp	.+218    	; 0xf2bc <conv_int+0x10e>
    f1e2:	c5 01       	movw	r24, r10
    f1e4:	0e 94 3f 7f 	call	0xfe7e	; 0xfe7e <fgetc>
    f1e8:	ac 01       	movw	r20, r24
    f1ea:	97 fd       	sbrc	r25, 7
    f1ec:	67 c0       	rjmp	.+206    	; 0xf2bc <conv_int+0x10e>
    f1ee:	6d ef       	ldi	r22, 0xFD	; 253
    f1f0:	d6 2e       	mov	r13, r22
    f1f2:	d1 22       	and	r13, r17
    f1f4:	8d 2d       	mov	r24, r13
    f1f6:	80 73       	andi	r24, 0x30	; 48
    f1f8:	01 f5       	brne	.+64     	; 0xf23a <conv_int+0x8c>
    f1fa:	40 33       	cpi	r20, 0x30	; 48
    f1fc:	f1 f4       	brne	.+60     	; 0xf23a <conv_int+0x8c>
    f1fe:	21 97       	sbiw	r28, 0x01	; 1
    f200:	09 f4       	brne	.+2      	; 0xf204 <conv_int+0x56>
    f202:	47 c0       	rjmp	.+142    	; 0xf292 <conv_int+0xe4>
    f204:	c5 01       	movw	r24, r10
    f206:	0e 94 3f 7f 	call	0xfe7e	; 0xfe7e <fgetc>
    f20a:	ac 01       	movw	r20, r24
    f20c:	97 fd       	sbrc	r25, 7
    f20e:	41 c0       	rjmp	.+130    	; 0xf292 <conv_int+0xe4>
    f210:	82 e0       	ldi	r24, 0x02	; 2
    f212:	d8 2a       	or	r13, r24
    f214:	48 37       	cpi	r20, 0x78	; 120
    f216:	11 f0       	breq	.+4      	; 0xf21c <conv_int+0x6e>
    f218:	48 35       	cpi	r20, 0x58	; 88
    f21a:	59 f4       	brne	.+22     	; 0xf232 <conv_int+0x84>
    f21c:	80 e4       	ldi	r24, 0x40	; 64
    f21e:	d8 2a       	or	r13, r24
    f220:	21 97       	sbiw	r28, 0x01	; 1
    f222:	b9 f1       	breq	.+110    	; 0xf292 <conv_int+0xe4>
    f224:	c5 01       	movw	r24, r10
    f226:	0e 94 3f 7f 	call	0xfe7e	; 0xfe7e <fgetc>
    f22a:	ac 01       	movw	r20, r24
    f22c:	99 23       	and	r25, r25
    f22e:	2c f4       	brge	.+10     	; 0xf23a <conv_int+0x8c>
    f230:	30 c0       	rjmp	.+96     	; 0xf292 <conv_int+0xe4>
    f232:	d6 fc       	sbrc	r13, 6
    f234:	02 c0       	rjmp	.+4      	; 0xf23a <conv_int+0x8c>
    f236:	80 e1       	ldi	r24, 0x10	; 16
    f238:	d8 2a       	or	r13, r24
    f23a:	ee 24       	eor	r14, r14
    f23c:	ff 24       	eor	r15, r15
    f23e:	87 01       	movw	r16, r14
    f240:	24 2f       	mov	r18, r20
    f242:	20 53       	subi	r18, 0x30	; 48
    f244:	28 30       	cpi	r18, 0x08	; 8
    f246:	88 f0       	brcs	.+34     	; 0xf26a <conv_int+0xbc>
    f248:	d4 fc       	sbrc	r13, 4
    f24a:	09 c0       	rjmp	.+18     	; 0xf25e <conv_int+0xb0>
    f24c:	2a 30       	cpi	r18, 0x0A	; 10
    f24e:	68 f0       	brcs	.+26     	; 0xf26a <conv_int+0xbc>
    f250:	d6 fe       	sbrs	r13, 6
    f252:	05 c0       	rjmp	.+10     	; 0xf25e <conv_int+0xb0>
    f254:	2f 7d       	andi	r18, 0xDF	; 223
    f256:	82 2f       	mov	r24, r18
    f258:	81 51       	subi	r24, 0x11	; 17
    f25a:	86 30       	cpi	r24, 0x06	; 6
    f25c:	28 f0       	brcs	.+10     	; 0xf268 <conv_int+0xba>
    f25e:	ca 01       	movw	r24, r20
    f260:	b5 01       	movw	r22, r10
    f262:	0e 94 55 80 	call	0x100aa	; 0x100aa <ungetc>
    f266:	12 c0       	rjmp	.+36     	; 0xf28c <conv_int+0xde>
    f268:	27 50       	subi	r18, 0x07	; 7
    f26a:	c8 01       	movw	r24, r16
    f26c:	b7 01       	movw	r22, r14
    f26e:	4d 2d       	mov	r20, r13
    f270:	0e 94 90 78 	call	0xf120	; 0xf120 <mulacc>
    f274:	7b 01       	movw	r14, r22
    f276:	8c 01       	movw	r16, r24
    f278:	82 e0       	ldi	r24, 0x02	; 2
    f27a:	d8 2a       	or	r13, r24
    f27c:	21 97       	sbiw	r28, 0x01	; 1
    f27e:	61 f0       	breq	.+24     	; 0xf298 <conv_int+0xea>
    f280:	c5 01       	movw	r24, r10
    f282:	0e 94 3f 7f 	call	0xfe7e	; 0xfe7e <fgetc>
    f286:	ac 01       	movw	r20, r24
    f288:	97 ff       	sbrs	r25, 7
    f28a:	da cf       	rjmp	.-76     	; 0xf240 <conv_int+0x92>
    f28c:	d1 fc       	sbrc	r13, 1
    f28e:	04 c0       	rjmp	.+8      	; 0xf298 <conv_int+0xea>
    f290:	15 c0       	rjmp	.+42     	; 0xf2bc <conv_int+0x10e>
    f292:	ee 24       	eor	r14, r14
    f294:	ff 24       	eor	r15, r15
    f296:	87 01       	movw	r16, r14
    f298:	d7 fe       	sbrs	r13, 7
    f29a:	08 c0       	rjmp	.+16     	; 0xf2ac <conv_int+0xfe>
    f29c:	10 95       	com	r17
    f29e:	00 95       	com	r16
    f2a0:	f0 94       	com	r15
    f2a2:	e0 94       	com	r14
    f2a4:	e1 1c       	adc	r14, r1
    f2a6:	f1 1c       	adc	r15, r1
    f2a8:	01 1d       	adc	r16, r1
    f2aa:	11 1d       	adc	r17, r1
    f2ac:	c4 01       	movw	r24, r8
    f2ae:	b8 01       	movw	r22, r16
    f2b0:	a7 01       	movw	r20, r14
    f2b2:	2d 2d       	mov	r18, r13
    f2b4:	0e 94 84 78 	call	0xf108	; 0xf108 <putval>
    f2b8:	81 e0       	ldi	r24, 0x01	; 1
    f2ba:	01 c0       	rjmp	.+2      	; 0xf2be <conv_int+0x110>
    f2bc:	80 e0       	ldi	r24, 0x00	; 0
    f2be:	df 91       	pop	r29
    f2c0:	cf 91       	pop	r28
    f2c2:	1f 91       	pop	r17
    f2c4:	0f 91       	pop	r16
    f2c6:	ff 90       	pop	r15
    f2c8:	ef 90       	pop	r14
    f2ca:	df 90       	pop	r13
    f2cc:	bf 90       	pop	r11
    f2ce:	af 90       	pop	r10
    f2d0:	9f 90       	pop	r9
    f2d2:	8f 90       	pop	r8
    f2d4:	08 95       	ret

0000f2d6 <conv_brk>:
    f2d6:	6f 92       	push	r6
    f2d8:	7f 92       	push	r7
    f2da:	8f 92       	push	r8
    f2dc:	9f 92       	push	r9
    f2de:	af 92       	push	r10
    f2e0:	bf 92       	push	r11
    f2e2:	cf 92       	push	r12
    f2e4:	df 92       	push	r13
    f2e6:	ef 92       	push	r14
    f2e8:	ff 92       	push	r15
    f2ea:	0f 93       	push	r16
    f2ec:	1f 93       	push	r17
    f2ee:	df 93       	push	r29
    f2f0:	cf 93       	push	r28
    f2f2:	cd b7       	in	r28, 0x3d	; 61
    f2f4:	de b7       	in	r29, 0x3e	; 62
    f2f6:	a0 97       	sbiw	r28, 0x20	; 32
    f2f8:	0f b6       	in	r0, 0x3f	; 63
    f2fa:	f8 94       	cli
    f2fc:	de bf       	out	0x3e, r29	; 62
    f2fe:	0f be       	out	0x3f, r0	; 63
    f300:	cd bf       	out	0x3d, r28	; 61
    f302:	5c 01       	movw	r10, r24
    f304:	6b 01       	movw	r12, r22
    f306:	8a 01       	movw	r16, r20
    f308:	79 01       	movw	r14, r18
    f30a:	fe 01       	movw	r30, r28
    f30c:	31 96       	adiw	r30, 0x01	; 1
    f30e:	80 e2       	ldi	r24, 0x20	; 32
    f310:	df 01       	movw	r26, r30
    f312:	1d 92       	st	X+, r1
    f314:	8a 95       	dec	r24
    f316:	e9 f7       	brne	.-6      	; 0xf312 <conv_brk+0x3c>
    f318:	70 e0       	ldi	r23, 0x00	; 0
    f31a:	30 e0       	ldi	r19, 0x00	; 0
    f31c:	60 e0       	ldi	r22, 0x00	; 0
    f31e:	40 e0       	ldi	r20, 0x00	; 0
    f320:	50 e0       	ldi	r21, 0x00	; 0
    f322:	3f 01       	movw	r6, r30
    f324:	a1 e0       	ldi	r26, 0x01	; 1
    f326:	b0 e0       	ldi	r27, 0x00	; 0
    f328:	f5 01       	movw	r30, r10
    f32a:	83 81       	ldd	r24, Z+3	; 0x03
    f32c:	f7 01       	movw	r30, r14
    f32e:	83 fd       	sbrc	r24, 3
    f330:	25 91       	lpm	r18, Z+
    f332:	83 ff       	sbrs	r24, 3
    f334:	21 91       	ld	r18, Z+
    f336:	7f 01       	movw	r14, r30
    f338:	22 23       	and	r18, r18
    f33a:	09 f4       	brne	.+2      	; 0xf33e <conv_brk+0x68>
    f33c:	81 c0       	rjmp	.+258    	; 0xf440 <conv_brk+0x16a>
    f33e:	2e 35       	cpi	r18, 0x5E	; 94
    f340:	19 f4       	brne	.+6      	; 0xf348 <conv_brk+0x72>
    f342:	41 15       	cp	r20, r1
    f344:	51 05       	cpc	r21, r1
    f346:	69 f1       	breq	.+90     	; 0xf3a2 <conv_brk+0xcc>
    f348:	87 2f       	mov	r24, r23
    f34a:	90 e0       	ldi	r25, 0x00	; 0
    f34c:	84 17       	cp	r24, r20
    f34e:	95 07       	cpc	r25, r21
    f350:	44 f4       	brge	.+16     	; 0xf362 <conv_brk+0x8c>
    f352:	2d 35       	cpi	r18, 0x5D	; 93
    f354:	51 f1       	breq	.+84     	; 0xf3aa <conv_brk+0xd4>
    f356:	2d 32       	cpi	r18, 0x2D	; 45
    f358:	21 f4       	brne	.+8      	; 0xf362 <conv_brk+0x8c>
    f35a:	33 23       	and	r19, r19
    f35c:	29 f4       	brne	.+10     	; 0xf368 <conv_brk+0x92>
    f35e:	31 e0       	ldi	r19, 0x01	; 1
    f360:	21 c0       	rjmp	.+66     	; 0xf3a4 <conv_brk+0xce>
    f362:	33 23       	and	r19, r19
    f364:	09 f4       	brne	.+2      	; 0xf368 <conv_brk+0x92>
    f366:	62 2f       	mov	r22, r18
    f368:	32 2f       	mov	r19, r18
    f36a:	83 2f       	mov	r24, r19
    f36c:	86 95       	lsr	r24
    f36e:	86 95       	lsr	r24
    f370:	86 95       	lsr	r24
    f372:	f3 01       	movw	r30, r6
    f374:	e8 0f       	add	r30, r24
    f376:	f1 1d       	adc	r31, r1
    f378:	83 2f       	mov	r24, r19
    f37a:	87 70       	andi	r24, 0x07	; 7
    f37c:	4d 01       	movw	r8, r26
    f37e:	02 c0       	rjmp	.+4      	; 0xf384 <conv_brk+0xae>
    f380:	88 0c       	add	r8, r8
    f382:	99 1c       	adc	r9, r9
    f384:	8a 95       	dec	r24
    f386:	e2 f7       	brpl	.-8      	; 0xf380 <conv_brk+0xaa>
    f388:	20 81       	ld	r18, Z
    f38a:	28 29       	or	r18, r8
    f38c:	20 83       	st	Z, r18
    f38e:	36 17       	cp	r19, r22
    f390:	11 f4       	brne	.+4      	; 0xf396 <conv_brk+0xc0>
    f392:	30 e0       	ldi	r19, 0x00	; 0
    f394:	07 c0       	rjmp	.+14     	; 0xf3a4 <conv_brk+0xce>
    f396:	36 17       	cp	r19, r22
    f398:	10 f4       	brcc	.+4      	; 0xf39e <conv_brk+0xc8>
    f39a:	3f 5f       	subi	r19, 0xFF	; 255
    f39c:	e6 cf       	rjmp	.-52     	; 0xf36a <conv_brk+0x94>
    f39e:	31 50       	subi	r19, 0x01	; 1
    f3a0:	e4 cf       	rjmp	.-56     	; 0xf36a <conv_brk+0x94>
    f3a2:	71 e0       	ldi	r23, 0x01	; 1
    f3a4:	4f 5f       	subi	r20, 0xFF	; 255
    f3a6:	5f 4f       	sbci	r21, 0xFF	; 255
    f3a8:	bf cf       	rjmp	.-130    	; 0xf328 <conv_brk+0x52>
    f3aa:	33 23       	and	r19, r19
    f3ac:	19 f0       	breq	.+6      	; 0xf3b4 <conv_brk+0xde>
    f3ae:	8e 81       	ldd	r24, Y+6	; 0x06
    f3b0:	80 62       	ori	r24, 0x20	; 32
    f3b2:	8e 83       	std	Y+6, r24	; 0x06
    f3b4:	77 23       	and	r23, r23
    f3b6:	59 f0       	breq	.+22     	; 0xf3ce <conv_brk+0xf8>
    f3b8:	fe 01       	movw	r30, r28
    f3ba:	31 96       	adiw	r30, 0x01	; 1
    f3bc:	9e 01       	movw	r18, r28
    f3be:	2f 5d       	subi	r18, 0xDF	; 223
    f3c0:	3f 4f       	sbci	r19, 0xFF	; 255
    f3c2:	80 81       	ld	r24, Z
    f3c4:	80 95       	com	r24
    f3c6:	81 93       	st	Z+, r24
    f3c8:	e2 17       	cp	r30, r18
    f3ca:	f3 07       	cpc	r31, r19
    f3cc:	d1 f7       	brne	.-12     	; 0xf3c2 <conv_brk+0xec>
    f3ce:	99 24       	eor	r9, r9
    f3d0:	93 94       	inc	r9
    f3d2:	3e 01       	movw	r6, r28
    f3d4:	08 94       	sec
    f3d6:	61 1c       	adc	r6, r1
    f3d8:	71 1c       	adc	r7, r1
    f3da:	c5 01       	movw	r24, r10
    f3dc:	0e 94 3f 7f 	call	0xfe7e	; 0xfe7e <fgetc>
    f3e0:	ac 01       	movw	r20, r24
    f3e2:	97 fd       	sbrc	r25, 7
    f3e4:	25 c0       	rjmp	.+74     	; 0xf430 <conv_brk+0x15a>
    f3e6:	86 95       	lsr	r24
    f3e8:	86 95       	lsr	r24
    f3ea:	86 95       	lsr	r24
    f3ec:	f3 01       	movw	r30, r6
    f3ee:	e8 0f       	add	r30, r24
    f3f0:	f1 1d       	adc	r31, r1
    f3f2:	80 81       	ld	r24, Z
    f3f4:	90 e0       	ldi	r25, 0x00	; 0
    f3f6:	9a 01       	movw	r18, r20
    f3f8:	27 70       	andi	r18, 0x07	; 7
    f3fa:	30 70       	andi	r19, 0x00	; 0
    f3fc:	02 c0       	rjmp	.+4      	; 0xf402 <conv_brk+0x12c>
    f3fe:	95 95       	asr	r25
    f400:	87 95       	ror	r24
    f402:	2a 95       	dec	r18
    f404:	e2 f7       	brpl	.-8      	; 0xf3fe <conv_brk+0x128>
    f406:	80 fd       	sbrc	r24, 0
    f408:	05 c0       	rjmp	.+10     	; 0xf414 <conv_brk+0x13e>
    f40a:	ca 01       	movw	r24, r20
    f40c:	b5 01       	movw	r22, r10
    f40e:	0e 94 55 80 	call	0x100aa	; 0x100aa <ungetc>
    f412:	0e c0       	rjmp	.+28     	; 0xf430 <conv_brk+0x15a>
    f414:	01 15       	cp	r16, r1
    f416:	11 05       	cpc	r17, r1
    f418:	19 f0       	breq	.+6      	; 0xf420 <conv_brk+0x14a>
    f41a:	d8 01       	movw	r26, r16
    f41c:	4d 93       	st	X+, r20
    f41e:	8d 01       	movw	r16, r26
    f420:	08 94       	sec
    f422:	c1 08       	sbc	r12, r1
    f424:	d1 08       	sbc	r13, r1
    f426:	99 24       	eor	r9, r9
    f428:	c1 14       	cp	r12, r1
    f42a:	d1 04       	cpc	r13, r1
    f42c:	b1 f6       	brne	.-84     	; 0xf3da <conv_brk+0x104>
    f42e:	02 c0       	rjmp	.+4      	; 0xf434 <conv_brk+0x15e>
    f430:	99 20       	and	r9, r9
    f432:	31 f4       	brne	.+12     	; 0xf440 <conv_brk+0x16a>
    f434:	01 15       	cp	r16, r1
    f436:	11 05       	cpc	r17, r1
    f438:	29 f0       	breq	.+10     	; 0xf444 <conv_brk+0x16e>
    f43a:	f8 01       	movw	r30, r16
    f43c:	10 82       	st	Z, r1
    f43e:	02 c0       	rjmp	.+4      	; 0xf444 <conv_brk+0x16e>
    f440:	ee 24       	eor	r14, r14
    f442:	ff 24       	eor	r15, r15
    f444:	c7 01       	movw	r24, r14
    f446:	a0 96       	adiw	r28, 0x20	; 32
    f448:	0f b6       	in	r0, 0x3f	; 63
    f44a:	f8 94       	cli
    f44c:	de bf       	out	0x3e, r29	; 62
    f44e:	0f be       	out	0x3f, r0	; 63
    f450:	cd bf       	out	0x3d, r28	; 61
    f452:	cf 91       	pop	r28
    f454:	df 91       	pop	r29
    f456:	1f 91       	pop	r17
    f458:	0f 91       	pop	r16
    f45a:	ff 90       	pop	r15
    f45c:	ef 90       	pop	r14
    f45e:	df 90       	pop	r13
    f460:	cf 90       	pop	r12
    f462:	bf 90       	pop	r11
    f464:	af 90       	pop	r10
    f466:	9f 90       	pop	r9
    f468:	8f 90       	pop	r8
    f46a:	7f 90       	pop	r7
    f46c:	6f 90       	pop	r6
    f46e:	08 95       	ret

0000f470 <conv_flt>:
    f470:	2f 92       	push	r2
    f472:	3f 92       	push	r3
    f474:	5f 92       	push	r5
    f476:	6f 92       	push	r6
    f478:	7f 92       	push	r7
    f47a:	8f 92       	push	r8
    f47c:	9f 92       	push	r9
    f47e:	af 92       	push	r10
    f480:	bf 92       	push	r11
    f482:	cf 92       	push	r12
    f484:	df 92       	push	r13
    f486:	ef 92       	push	r14
    f488:	ff 92       	push	r15
    f48a:	0f 93       	push	r16
    f48c:	1f 93       	push	r17
    f48e:	cf 93       	push	r28
    f490:	df 93       	push	r29
    f492:	3c 01       	movw	r6, r24
    f494:	7b 01       	movw	r14, r22
    f496:	1a 01       	movw	r2, r20
    f498:	0e 94 3f 7f 	call	0xfe7e	; 0xfe7e <fgetc>
    f49c:	ec 01       	movw	r28, r24
    f49e:	8b 32       	cpi	r24, 0x2B	; 43
    f4a0:	39 f0       	breq	.+14     	; 0xf4b0 <conv_flt+0x40>
    f4a2:	8d 32       	cpi	r24, 0x2D	; 45
    f4a4:	11 f0       	breq	.+4      	; 0xf4aa <conv_flt+0x3a>
    f4a6:	55 24       	eor	r5, r5
    f4a8:	11 c0       	rjmp	.+34     	; 0xf4cc <conv_flt+0x5c>
    f4aa:	b0 e8       	ldi	r27, 0x80	; 128
    f4ac:	5b 2e       	mov	r5, r27
    f4ae:	01 c0       	rjmp	.+2      	; 0xf4b2 <conv_flt+0x42>
    f4b0:	55 24       	eor	r5, r5
    f4b2:	08 94       	sec
    f4b4:	e1 08       	sbc	r14, r1
    f4b6:	f1 08       	sbc	r15, r1
    f4b8:	e1 14       	cp	r14, r1
    f4ba:	f1 04       	cpc	r15, r1
    f4bc:	09 f4       	brne	.+2      	; 0xf4c0 <conv_flt+0x50>
    f4be:	18 c1       	rjmp	.+560    	; 0xf6f0 <conv_flt+0x280>
    f4c0:	c3 01       	movw	r24, r6
    f4c2:	0e 94 3f 7f 	call	0xfe7e	; 0xfe7e <fgetc>
    f4c6:	ec 01       	movw	r28, r24
    f4c8:	97 fd       	sbrc	r25, 7
    f4ca:	12 c1       	rjmp	.+548    	; 0xf6f0 <conv_flt+0x280>
    f4cc:	ce 01       	movw	r24, r28
    f4ce:	0e 94 9e 7e 	call	0xfd3c	; 0xfd3c <tolower>
    f4d2:	89 36       	cpi	r24, 0x69	; 105
    f4d4:	91 05       	cpc	r25, r1
    f4d6:	21 f0       	breq	.+8      	; 0xf4e0 <conv_flt+0x70>
    f4d8:	8e 36       	cpi	r24, 0x6E	; 110
    f4da:	91 05       	cpc	r25, r1
    f4dc:	99 f5       	brne	.+102    	; 0xf544 <conv_flt+0xd4>
    f4de:	1d c0       	rjmp	.+58     	; 0xf51a <conv_flt+0xaa>
    f4e0:	0b ee       	ldi	r16, 0xEB	; 235
    f4e2:	12 e0       	ldi	r17, 0x02	; 2
    f4e4:	1c c0       	rjmp	.+56     	; 0xf51e <conv_flt+0xae>
    f4e6:	08 94       	sec
    f4e8:	e1 08       	sbc	r14, r1
    f4ea:	f1 08       	sbc	r15, r1
    f4ec:	e1 14       	cp	r14, r1
    f4ee:	f1 04       	cpc	r15, r1
    f4f0:	71 f0       	breq	.+28     	; 0xf50e <conv_flt+0x9e>
    f4f2:	c3 01       	movw	r24, r6
    f4f4:	0e 94 3f 7f 	call	0xfe7e	; 0xfe7e <fgetc>
    f4f8:	ec 01       	movw	r28, r24
    f4fa:	97 fd       	sbrc	r25, 7
    f4fc:	08 c0       	rjmp	.+16     	; 0xf50e <conv_flt+0x9e>
    f4fe:	0e 94 9e 7e 	call	0xfd3c	; 0xfd3c <tolower>
    f502:	d8 16       	cp	r13, r24
    f504:	61 f0       	breq	.+24     	; 0xf51e <conv_flt+0xae>
    f506:	ce 01       	movw	r24, r28
    f508:	b3 01       	movw	r22, r6
    f50a:	0e 94 55 80 	call	0x100aa	; 0x100aa <ungetc>
    f50e:	22 e0       	ldi	r18, 0x02	; 2
    f510:	0e 3e       	cpi	r16, 0xEE	; 238
    f512:	12 07       	cpc	r17, r18
    f514:	09 f0       	breq	.+2      	; 0xf518 <conv_flt+0xa8>
    f516:	ec c0       	rjmp	.+472    	; 0xf6f0 <conv_flt+0x280>
    f518:	08 c0       	rjmp	.+16     	; 0xf52a <conv_flt+0xba>
    f51a:	08 ee       	ldi	r16, 0xE8	; 232
    f51c:	12 e0       	ldi	r17, 0x02	; 2
    f51e:	f8 01       	movw	r30, r16
    f520:	0f 5f       	subi	r16, 0xFF	; 255
    f522:	1f 4f       	sbci	r17, 0xFF	; 255
    f524:	d4 90       	lpm	r13, Z+
    f526:	dd 20       	and	r13, r13
    f528:	f1 f6       	brne	.-68     	; 0xf4e6 <conv_flt+0x76>
    f52a:	0b 5e       	subi	r16, 0xEB	; 235
    f52c:	12 40       	sbci	r17, 0x02	; 2
    f52e:	29 f0       	breq	.+10     	; 0xf53a <conv_flt+0xca>
    f530:	80 e0       	ldi	r24, 0x00	; 0
    f532:	90 e0       	ldi	r25, 0x00	; 0
    f534:	a0 e8       	ldi	r26, 0x80	; 128
    f536:	bf e7       	ldi	r27, 0x7F	; 127
    f538:	cf c0       	rjmp	.+414    	; 0xf6d8 <conv_flt+0x268>
    f53a:	80 e0       	ldi	r24, 0x00	; 0
    f53c:	90 e0       	ldi	r25, 0x00	; 0
    f53e:	a0 ec       	ldi	r26, 0xC0	; 192
    f540:	bf e7       	ldi	r27, 0x7F	; 127
    f542:	ca c0       	rjmp	.+404    	; 0xf6d8 <conv_flt+0x268>
    f544:	cc 24       	eor	r12, r12
    f546:	dd 24       	eor	r13, r13
    f548:	88 24       	eor	r8, r8
    f54a:	99 24       	eor	r9, r9
    f54c:	54 01       	movw	r10, r8
    f54e:	ae 01       	movw	r20, r28
    f550:	40 53       	subi	r20, 0x30	; 48
    f552:	24 2f       	mov	r18, r20
    f554:	4a 30       	cpi	r20, 0x0A	; 10
    f556:	38 f5       	brcc	.+78     	; 0xf5a6 <conv_flt+0x136>
    f558:	52 e0       	ldi	r21, 0x02	; 2
    f55a:	55 2a       	or	r5, r21
    f55c:	85 2d       	mov	r24, r5
    f55e:	90 e0       	ldi	r25, 0x00	; 0
    f560:	ac 01       	movw	r20, r24
    f562:	48 70       	andi	r20, 0x08	; 8
    f564:	50 70       	andi	r21, 0x00	; 0
    f566:	52 fe       	sbrs	r5, 2
    f568:	06 c0       	rjmp	.+12     	; 0xf576 <conv_flt+0x106>
    f56a:	45 2b       	or	r20, r21
    f56c:	11 f5       	brne	.+68     	; 0xf5b2 <conv_flt+0x142>
    f56e:	08 94       	sec
    f570:	c1 1c       	adc	r12, r1
    f572:	d1 1c       	adc	r13, r1
    f574:	1e c0       	rjmp	.+60     	; 0xf5b2 <conv_flt+0x142>
    f576:	45 2b       	or	r20, r21
    f578:	19 f0       	breq	.+6      	; 0xf580 <conv_flt+0x110>
    f57a:	08 94       	sec
    f57c:	c1 08       	sbc	r12, r1
    f57e:	d1 08       	sbc	r13, r1
    f580:	c5 01       	movw	r24, r10
    f582:	b4 01       	movw	r22, r8
    f584:	40 e2       	ldi	r20, 0x20	; 32
    f586:	0e 94 90 78 	call	0xf120	; 0xf120 <mulacc>
    f58a:	4b 01       	movw	r8, r22
    f58c:	5c 01       	movw	r10, r24
    f58e:	88 e9       	ldi	r24, 0x98	; 152
    f590:	88 16       	cp	r8, r24
    f592:	89 e9       	ldi	r24, 0x99	; 153
    f594:	98 06       	cpc	r9, r24
    f596:	89 e9       	ldi	r24, 0x99	; 153
    f598:	a8 06       	cpc	r10, r24
    f59a:	89 e1       	ldi	r24, 0x19	; 25
    f59c:	b8 06       	cpc	r11, r24
    f59e:	48 f0       	brcs	.+18     	; 0xf5b2 <conv_flt+0x142>
    f5a0:	94 e0       	ldi	r25, 0x04	; 4
    f5a2:	59 2a       	or	r5, r25
    f5a4:	06 c0       	rjmp	.+12     	; 0xf5b2 <conv_flt+0x142>
    f5a6:	4e 3f       	cpi	r20, 0xFE	; 254
    f5a8:	81 f4       	brne	.+32     	; 0xf5ca <conv_flt+0x15a>
    f5aa:	53 fc       	sbrc	r5, 3
    f5ac:	0e c0       	rjmp	.+28     	; 0xf5ca <conv_flt+0x15a>
    f5ae:	e8 e0       	ldi	r30, 0x08	; 8
    f5b0:	5e 2a       	or	r5, r30
    f5b2:	08 94       	sec
    f5b4:	e1 08       	sbc	r14, r1
    f5b6:	f1 08       	sbc	r15, r1
    f5b8:	e1 14       	cp	r14, r1
    f5ba:	f1 04       	cpc	r15, r1
    f5bc:	31 f0       	breq	.+12     	; 0xf5ca <conv_flt+0x15a>
    f5be:	c3 01       	movw	r24, r6
    f5c0:	0e 94 3f 7f 	call	0xfe7e	; 0xfe7e <fgetc>
    f5c4:	ec 01       	movw	r28, r24
    f5c6:	97 ff       	sbrs	r25, 7
    f5c8:	c2 cf       	rjmp	.-124    	; 0xf54e <conv_flt+0xde>
    f5ca:	51 fe       	sbrs	r5, 1
    f5cc:	91 c0       	rjmp	.+290    	; 0xf6f0 <conv_flt+0x280>
    f5ce:	c5 36       	cpi	r28, 0x65	; 101
    f5d0:	19 f0       	breq	.+6      	; 0xf5d8 <conv_flt+0x168>
    f5d2:	c5 34       	cpi	r28, 0x45	; 69
    f5d4:	09 f0       	breq	.+2      	; 0xf5d8 <conv_flt+0x168>
    f5d6:	46 c0       	rjmp	.+140    	; 0xf664 <conv_flt+0x1f4>
    f5d8:	08 94       	sec
    f5da:	e1 08       	sbc	r14, r1
    f5dc:	f1 08       	sbc	r15, r1
    f5de:	e1 14       	cp	r14, r1
    f5e0:	f1 04       	cpc	r15, r1
    f5e2:	09 f4       	brne	.+2      	; 0xf5e6 <conv_flt+0x176>
    f5e4:	85 c0       	rjmp	.+266    	; 0xf6f0 <conv_flt+0x280>
    f5e6:	c3 01       	movw	r24, r6
    f5e8:	0e 94 3f 7f 	call	0xfe7e	; 0xfe7e <fgetc>
    f5ec:	ec 01       	movw	r28, r24
    f5ee:	97 fd       	sbrc	r25, 7
    f5f0:	7f c0       	rjmp	.+254    	; 0xf6f0 <conv_flt+0x280>
    f5f2:	8b 32       	cpi	r24, 0x2B	; 43
    f5f4:	21 f0       	breq	.+8      	; 0xf5fe <conv_flt+0x18e>
    f5f6:	8d 32       	cpi	r24, 0x2D	; 45
    f5f8:	69 f4       	brne	.+26     	; 0xf614 <conv_flt+0x1a4>
    f5fa:	f0 e1       	ldi	r31, 0x10	; 16
    f5fc:	5f 2a       	or	r5, r31
    f5fe:	08 94       	sec
    f600:	e1 08       	sbc	r14, r1
    f602:	f1 08       	sbc	r15, r1
    f604:	e1 14       	cp	r14, r1
    f606:	f1 04       	cpc	r15, r1
    f608:	09 f4       	brne	.+2      	; 0xf60c <conv_flt+0x19c>
    f60a:	72 c0       	rjmp	.+228    	; 0xf6f0 <conv_flt+0x280>
    f60c:	c3 01       	movw	r24, r6
    f60e:	0e 94 3f 7f 	call	0xfe7e	; 0xfe7e <fgetc>
    f612:	ec 01       	movw	r28, r24
    f614:	ce 01       	movw	r24, r28
    f616:	c0 97       	sbiw	r24, 0x30	; 48
    f618:	0a 97       	sbiw	r24, 0x0a	; 10
    f61a:	08 f0       	brcs	.+2      	; 0xf61e <conv_flt+0x1ae>
    f61c:	69 c0       	rjmp	.+210    	; 0xf6f0 <conv_flt+0x280>
    f61e:	00 e0       	ldi	r16, 0x00	; 0
    f620:	10 e0       	ldi	r17, 0x00	; 0
    f622:	b8 01       	movw	r22, r16
    f624:	88 27       	eor	r24, r24
    f626:	77 fd       	sbrc	r23, 7
    f628:	80 95       	com	r24
    f62a:	98 2f       	mov	r25, r24
    f62c:	ae 01       	movw	r20, r28
    f62e:	40 53       	subi	r20, 0x30	; 48
    f630:	24 2f       	mov	r18, r20
    f632:	40 e2       	ldi	r20, 0x20	; 32
    f634:	0e 94 90 78 	call	0xf120	; 0xf120 <mulacc>
    f638:	8b 01       	movw	r16, r22
    f63a:	08 94       	sec
    f63c:	e1 08       	sbc	r14, r1
    f63e:	f1 08       	sbc	r15, r1
    f640:	e1 14       	cp	r14, r1
    f642:	f1 04       	cpc	r15, r1
    f644:	39 f0       	breq	.+14     	; 0xf654 <conv_flt+0x1e4>
    f646:	c3 01       	movw	r24, r6
    f648:	0e 94 3f 7f 	call	0xfe7e	; 0xfe7e <fgetc>
    f64c:	ec 01       	movw	r28, r24
    f64e:	c0 97       	sbiw	r24, 0x30	; 48
    f650:	0a 97       	sbiw	r24, 0x0a	; 10
    f652:	38 f3       	brcs	.-50     	; 0xf622 <conv_flt+0x1b2>
    f654:	b8 01       	movw	r22, r16
    f656:	54 fe       	sbrs	r5, 4
    f658:	03 c0       	rjmp	.+6      	; 0xf660 <conv_flt+0x1f0>
    f65a:	70 95       	com	r23
    f65c:	61 95       	neg	r22
    f65e:	7f 4f       	sbci	r23, 0xFF	; 255
    f660:	c6 0e       	add	r12, r22
    f662:	d7 1e       	adc	r13, r23
    f664:	ef 28       	or	r14, r15
    f666:	31 f0       	breq	.+12     	; 0xf674 <conv_flt+0x204>
    f668:	d7 fd       	sbrc	r29, 7
    f66a:	04 c0       	rjmp	.+8      	; 0xf674 <conv_flt+0x204>
    f66c:	ce 01       	movw	r24, r28
    f66e:	b3 01       	movw	r22, r6
    f670:	0e 94 55 80 	call	0x100aa	; 0x100aa <ungetc>
    f674:	c5 01       	movw	r24, r10
    f676:	b4 01       	movw	r22, r8
    f678:	0e 94 ca 7c 	call	0xf994	; 0xf994 <__floatunsisf>
    f67c:	d7 fe       	sbrs	r13, 7
    f67e:	0d c0       	rjmp	.+26     	; 0xf69a <conv_flt+0x22a>
    f680:	a7 e0       	ldi	r26, 0x07	; 7
    f682:	ea 2e       	mov	r14, r26
    f684:	a3 e0       	ldi	r26, 0x03	; 3
    f686:	fa 2e       	mov	r15, r26
    f688:	d0 94       	com	r13
    f68a:	c1 94       	neg	r12
    f68c:	d1 08       	sbc	r13, r1
    f68e:	d3 94       	inc	r13
    f690:	c0 e2       	ldi	r28, 0x20	; 32
    f692:	d0 e0       	ldi	r29, 0x00	; 0
    f694:	00 e0       	ldi	r16, 0x00	; 0
    f696:	10 e0       	ldi	r17, 0x00	; 0
    f698:	0e c0       	rjmp	.+28     	; 0xf6b6 <conv_flt+0x246>
    f69a:	ff e1       	ldi	r31, 0x1F	; 31
    f69c:	ef 2e       	mov	r14, r31
    f69e:	f3 e0       	ldi	r31, 0x03	; 3
    f6a0:	ff 2e       	mov	r15, r31
    f6a2:	f6 cf       	rjmp	.-20     	; 0xf690 <conv_flt+0x220>
    f6a4:	f7 01       	movw	r30, r14
    f6a6:	25 91       	lpm	r18, Z+
    f6a8:	35 91       	lpm	r19, Z+
    f6aa:	45 91       	lpm	r20, Z+
    f6ac:	54 91       	lpm	r21, Z+
    f6ae:	0e 94 07 7d 	call	0xfa0e	; 0xfa0e <__mulsf3>
    f6b2:	cc 1a       	sub	r12, r28
    f6b4:	dd 0a       	sbc	r13, r29
    f6b6:	cc 16       	cp	r12, r28
    f6b8:	dd 06       	cpc	r13, r29
    f6ba:	a0 f7       	brcc	.-24     	; 0xf6a4 <conv_flt+0x234>
    f6bc:	d6 95       	lsr	r29
    f6be:	c7 95       	ror	r28
    f6c0:	0f 5f       	subi	r16, 0xFF	; 255
    f6c2:	1f 4f       	sbci	r17, 0xFF	; 255
    f6c4:	06 30       	cpi	r16, 0x06	; 6
    f6c6:	11 05       	cpc	r17, r1
    f6c8:	29 f0       	breq	.+10     	; 0xf6d4 <conv_flt+0x264>
    f6ca:	ec ef       	ldi	r30, 0xFC	; 252
    f6cc:	ff ef       	ldi	r31, 0xFF	; 255
    f6ce:	ee 0e       	add	r14, r30
    f6d0:	ff 1e       	adc	r15, r31
    f6d2:	f1 cf       	rjmp	.-30     	; 0xf6b6 <conv_flt+0x246>
    f6d4:	dc 01       	movw	r26, r24
    f6d6:	cb 01       	movw	r24, r22
    f6d8:	57 fc       	sbrc	r5, 7
    f6da:	b0 58       	subi	r27, 0x80	; 128
    f6dc:	21 14       	cp	r2, r1
    f6de:	31 04       	cpc	r3, r1
    f6e0:	29 f0       	breq	.+10     	; 0xf6ec <conv_flt+0x27c>
    f6e2:	f1 01       	movw	r30, r2
    f6e4:	80 83       	st	Z, r24
    f6e6:	91 83       	std	Z+1, r25	; 0x01
    f6e8:	a2 83       	std	Z+2, r26	; 0x02
    f6ea:	b3 83       	std	Z+3, r27	; 0x03
    f6ec:	81 e0       	ldi	r24, 0x01	; 1
    f6ee:	01 c0       	rjmp	.+2      	; 0xf6f2 <conv_flt+0x282>
    f6f0:	80 e0       	ldi	r24, 0x00	; 0
    f6f2:	df 91       	pop	r29
    f6f4:	cf 91       	pop	r28
    f6f6:	1f 91       	pop	r17
    f6f8:	0f 91       	pop	r16
    f6fa:	ff 90       	pop	r15
    f6fc:	ef 90       	pop	r14
    f6fe:	df 90       	pop	r13
    f700:	cf 90       	pop	r12
    f702:	bf 90       	pop	r11
    f704:	af 90       	pop	r10
    f706:	9f 90       	pop	r9
    f708:	8f 90       	pop	r8
    f70a:	7f 90       	pop	r7
    f70c:	6f 90       	pop	r6
    f70e:	5f 90       	pop	r5
    f710:	3f 90       	pop	r3
    f712:	2f 90       	pop	r2
    f714:	08 95       	ret

0000f716 <vfscanf>:
    f716:	5f 92       	push	r5
    f718:	6f 92       	push	r6
    f71a:	7f 92       	push	r7
    f71c:	8f 92       	push	r8
    f71e:	9f 92       	push	r9
    f720:	af 92       	push	r10
    f722:	bf 92       	push	r11
    f724:	cf 92       	push	r12
    f726:	df 92       	push	r13
    f728:	ef 92       	push	r14
    f72a:	ff 92       	push	r15
    f72c:	0f 93       	push	r16
    f72e:	1f 93       	push	r17
    f730:	cf 93       	push	r28
    f732:	df 93       	push	r29
    f734:	4c 01       	movw	r8, r24
    f736:	5b 01       	movw	r10, r22
    f738:	3a 01       	movw	r6, r20
    f73a:	fc 01       	movw	r30, r24
    f73c:	17 82       	std	Z+7, r1	; 0x07
    f73e:	16 82       	std	Z+6, r1	; 0x06
    f740:	55 24       	eor	r5, r5
    f742:	04 c1       	rjmp	.+520    	; 0xf94c <vfscanf+0x236>
    f744:	81 2f       	mov	r24, r17
    f746:	90 e0       	ldi	r25, 0x00	; 0
    f748:	0e 94 96 7e 	call	0xfd2c	; 0xfd2c <isspace>
    f74c:	89 2b       	or	r24, r25
    f74e:	21 f0       	breq	.+8      	; 0xf758 <vfscanf+0x42>
    f750:	c4 01       	movw	r24, r8
    f752:	0e 94 be 78 	call	0xf17c	; 0xf17c <skip_spaces>
    f756:	fa c0       	rjmp	.+500    	; 0xf94c <vfscanf+0x236>
    f758:	15 32       	cpi	r17, 0x25	; 37
    f75a:	49 f4       	brne	.+18     	; 0xf76e <vfscanf+0x58>
    f75c:	f5 01       	movw	r30, r10
    f75e:	f3 fc       	sbrc	r15, 3
    f760:	65 91       	lpm	r22, Z+
    f762:	f3 fe       	sbrs	r15, 3
    f764:	61 91       	ld	r22, Z+
    f766:	5f 01       	movw	r10, r30
    f768:	65 32       	cpi	r22, 0x25	; 37
    f76a:	69 f4       	brne	.+26     	; 0xf786 <vfscanf+0x70>
    f76c:	15 e2       	ldi	r17, 0x25	; 37
    f76e:	c4 01       	movw	r24, r8
    f770:	0e 94 3f 7f 	call	0xfe7e	; 0xfe7e <fgetc>
    f774:	97 fd       	sbrc	r25, 7
    f776:	f6 c0       	rjmp	.+492    	; 0xf964 <vfscanf+0x24e>
    f778:	18 17       	cp	r17, r24
    f77a:	09 f4       	brne	.+2      	; 0xf77e <vfscanf+0x68>
    f77c:	e7 c0       	rjmp	.+462    	; 0xf94c <vfscanf+0x236>
    f77e:	b4 01       	movw	r22, r8
    f780:	0e 94 55 80 	call	0x100aa	; 0x100aa <ungetc>
    f784:	f4 c0       	rjmp	.+488    	; 0xf96e <vfscanf+0x258>
    f786:	6a 32       	cpi	r22, 0x2A	; 42
    f788:	19 f0       	breq	.+6      	; 0xf790 <vfscanf+0x7a>
    f78a:	16 2f       	mov	r17, r22
    f78c:	00 e0       	ldi	r16, 0x00	; 0
    f78e:	06 c0       	rjmp	.+12     	; 0xf79c <vfscanf+0x86>
    f790:	f3 fc       	sbrc	r15, 3
    f792:	15 91       	lpm	r17, Z+
    f794:	f3 fe       	sbrs	r15, 3
    f796:	11 91       	ld	r17, Z+
    f798:	5f 01       	movw	r10, r30
    f79a:	01 e0       	ldi	r16, 0x01	; 1
    f79c:	cc 24       	eor	r12, r12
    f79e:	dd 24       	eor	r13, r13
    f7a0:	0e c0       	rjmp	.+28     	; 0xf7be <vfscanf+0xa8>
    f7a2:	02 60       	ori	r16, 0x02	; 2
    f7a4:	b6 01       	movw	r22, r12
    f7a6:	80 e0       	ldi	r24, 0x00	; 0
    f7a8:	90 e0       	ldi	r25, 0x00	; 0
    f7aa:	40 e2       	ldi	r20, 0x20	; 32
    f7ac:	0e 94 90 78 	call	0xf120	; 0xf120 <mulacc>
    f7b0:	6b 01       	movw	r12, r22
    f7b2:	f5 01       	movw	r30, r10
    f7b4:	f3 fc       	sbrc	r15, 3
    f7b6:	15 91       	lpm	r17, Z+
    f7b8:	f3 fe       	sbrs	r15, 3
    f7ba:	11 91       	ld	r17, Z+
    f7bc:	5f 01       	movw	r10, r30
    f7be:	21 2f       	mov	r18, r17
    f7c0:	20 53       	subi	r18, 0x30	; 48
    f7c2:	2a 30       	cpi	r18, 0x0A	; 10
    f7c4:	70 f3       	brcs	.-36     	; 0xf7a2 <vfscanf+0x8c>
    f7c6:	01 fd       	sbrc	r16, 1
    f7c8:	04 c0       	rjmp	.+8      	; 0xf7d2 <vfscanf+0xbc>
    f7ca:	cc 24       	eor	r12, r12
    f7cc:	ca 94       	dec	r12
    f7ce:	dc 2c       	mov	r13, r12
    f7d0:	04 c0       	rjmp	.+8      	; 0xf7da <vfscanf+0xc4>
    f7d2:	c1 14       	cp	r12, r1
    f7d4:	d1 04       	cpc	r13, r1
    f7d6:	09 f4       	brne	.+2      	; 0xf7da <vfscanf+0xc4>
    f7d8:	ca c0       	rjmp	.+404    	; 0xf96e <vfscanf+0x258>
    f7da:	18 36       	cpi	r17, 0x68	; 104
    f7dc:	21 f0       	breq	.+8      	; 0xf7e6 <vfscanf+0xd0>
    f7de:	1c 36       	cpi	r17, 0x6C	; 108
    f7e0:	99 f4       	brne	.+38     	; 0xf808 <vfscanf+0xf2>
    f7e2:	f5 01       	movw	r30, r10
    f7e4:	0b c0       	rjmp	.+22     	; 0xf7fc <vfscanf+0xe6>
    f7e6:	f5 01       	movw	r30, r10
    f7e8:	f3 fc       	sbrc	r15, 3
    f7ea:	65 91       	lpm	r22, Z+
    f7ec:	f3 fe       	sbrs	r15, 3
    f7ee:	61 91       	ld	r22, Z+
    f7f0:	68 36       	cpi	r22, 0x68	; 104
    f7f2:	19 f0       	breq	.+6      	; 0xf7fa <vfscanf+0xe4>
    f7f4:	5f 01       	movw	r10, r30
    f7f6:	16 2f       	mov	r17, r22
    f7f8:	07 c0       	rjmp	.+14     	; 0xf808 <vfscanf+0xf2>
    f7fa:	08 60       	ori	r16, 0x08	; 8
    f7fc:	04 60       	ori	r16, 0x04	; 4
    f7fe:	f3 fc       	sbrc	r15, 3
    f800:	15 91       	lpm	r17, Z+
    f802:	f3 fe       	sbrs	r15, 3
    f804:	11 91       	ld	r17, Z+
    f806:	5f 01       	movw	r10, r30
    f808:	11 23       	and	r17, r17
    f80a:	09 f4       	brne	.+2      	; 0xf80e <vfscanf+0xf8>
    f80c:	b0 c0       	rjmp	.+352    	; 0xf96e <vfscanf+0x258>
    f80e:	86 ed       	ldi	r24, 0xD6	; 214
    f810:	92 e0       	ldi	r25, 0x02	; 2
    f812:	61 2f       	mov	r22, r17
    f814:	70 e0       	ldi	r23, 0x00	; 0
    f816:	0e 94 a6 7e 	call	0xfd4c	; 0xfd4c <strchr_P>
    f81a:	89 2b       	or	r24, r25
    f81c:	09 f4       	brne	.+2      	; 0xf820 <vfscanf+0x10a>
    f81e:	a7 c0       	rjmp	.+334    	; 0xf96e <vfscanf+0x258>
    f820:	80 2f       	mov	r24, r16
    f822:	00 ff       	sbrs	r16, 0
    f824:	03 c0       	rjmp	.+6      	; 0xf82c <vfscanf+0x116>
    f826:	ee 24       	eor	r14, r14
    f828:	ff 24       	eor	r15, r15
    f82a:	07 c0       	rjmp	.+14     	; 0xf83a <vfscanf+0x124>
    f82c:	f3 01       	movw	r30, r6
    f82e:	e0 80       	ld	r14, Z
    f830:	f1 80       	ldd	r15, Z+1	; 0x01
    f832:	22 e0       	ldi	r18, 0x02	; 2
    f834:	30 e0       	ldi	r19, 0x00	; 0
    f836:	62 0e       	add	r6, r18
    f838:	73 1e       	adc	r7, r19
    f83a:	1e 36       	cpi	r17, 0x6E	; 110
    f83c:	51 f4       	brne	.+20     	; 0xf852 <vfscanf+0x13c>
    f83e:	f4 01       	movw	r30, r8
    f840:	46 81       	ldd	r20, Z+6	; 0x06
    f842:	57 81       	ldd	r21, Z+7	; 0x07
    f844:	60 e0       	ldi	r22, 0x00	; 0
    f846:	70 e0       	ldi	r23, 0x00	; 0
    f848:	c7 01       	movw	r24, r14
    f84a:	20 2f       	mov	r18, r16
    f84c:	0e 94 84 78 	call	0xf108	; 0xf108 <putval>
    f850:	7d c0       	rjmp	.+250    	; 0xf94c <vfscanf+0x236>
    f852:	13 36       	cpi	r17, 0x63	; 99
    f854:	b9 f4       	brne	.+46     	; 0xf884 <vfscanf+0x16e>
    f856:	81 fd       	sbrc	r24, 1
    f858:	03 c0       	rjmp	.+6      	; 0xf860 <vfscanf+0x14a>
    f85a:	11 e0       	ldi	r17, 0x01	; 1
    f85c:	c1 2e       	mov	r12, r17
    f85e:	d1 2c       	mov	r13, r1
    f860:	c4 01       	movw	r24, r8
    f862:	0e 94 3f 7f 	call	0xfe7e	; 0xfe7e <fgetc>
    f866:	97 fd       	sbrc	r25, 7
    f868:	7d c0       	rjmp	.+250    	; 0xf964 <vfscanf+0x24e>
    f86a:	e1 14       	cp	r14, r1
    f86c:	f1 04       	cpc	r15, r1
    f86e:	19 f0       	breq	.+6      	; 0xf876 <vfscanf+0x160>
    f870:	f7 01       	movw	r30, r14
    f872:	81 93       	st	Z+, r24
    f874:	7f 01       	movw	r14, r30
    f876:	08 94       	sec
    f878:	c1 08       	sbc	r12, r1
    f87a:	d1 08       	sbc	r13, r1
    f87c:	c1 14       	cp	r12, r1
    f87e:	d1 04       	cpc	r13, r1
    f880:	79 f7       	brne	.-34     	; 0xf860 <vfscanf+0x14a>
    f882:	62 c0       	rjmp	.+196    	; 0xf948 <vfscanf+0x232>
    f884:	1b 35       	cpi	r17, 0x5B	; 91
    f886:	59 f4       	brne	.+22     	; 0xf89e <vfscanf+0x188>
    f888:	c4 01       	movw	r24, r8
    f88a:	b6 01       	movw	r22, r12
    f88c:	a7 01       	movw	r20, r14
    f88e:	95 01       	movw	r18, r10
    f890:	0e 94 6b 79 	call	0xf2d6	; 0xf2d6 <conv_brk>
    f894:	5c 01       	movw	r10, r24
    f896:	00 97       	sbiw	r24, 0x00	; 0
    f898:	09 f0       	breq	.+2      	; 0xf89c <vfscanf+0x186>
    f89a:	56 c0       	rjmp	.+172    	; 0xf948 <vfscanf+0x232>
    f89c:	50 c0       	rjmp	.+160    	; 0xf93e <vfscanf+0x228>
    f89e:	c4 01       	movw	r24, r8
    f8a0:	0e 94 be 78 	call	0xf17c	; 0xf17c <skip_spaces>
    f8a4:	97 fd       	sbrc	r25, 7
    f8a6:	5e c0       	rjmp	.+188    	; 0xf964 <vfscanf+0x24e>
    f8a8:	1f 36       	cpi	r17, 0x6F	; 111
    f8aa:	d1 f1       	breq	.+116    	; 0xf920 <vfscanf+0x20a>
    f8ac:	10 37       	cpi	r17, 0x70	; 112
    f8ae:	38 f4       	brcc	.+14     	; 0xf8be <vfscanf+0x1a8>
    f8b0:	14 36       	cpi	r17, 0x64	; 100
    f8b2:	a1 f1       	breq	.+104    	; 0xf91c <vfscanf+0x206>
    f8b4:	19 36       	cpi	r17, 0x69	; 105
    f8b6:	a9 f1       	breq	.+106    	; 0xf922 <vfscanf+0x20c>
    f8b8:	18 35       	cpi	r17, 0x58	; 88
    f8ba:	d1 f5       	brne	.+116    	; 0xf930 <vfscanf+0x21a>
    f8bc:	2d c0       	rjmp	.+90     	; 0xf918 <vfscanf+0x202>
    f8be:	13 37       	cpi	r17, 0x73	; 115
    f8c0:	51 f0       	breq	.+20     	; 0xf8d6 <vfscanf+0x1c0>
    f8c2:	14 37       	cpi	r17, 0x74	; 116
    f8c4:	18 f4       	brcc	.+6      	; 0xf8cc <vfscanf+0x1b6>
    f8c6:	10 37       	cpi	r17, 0x70	; 112
    f8c8:	99 f5       	brne	.+102    	; 0xf930 <vfscanf+0x21a>
    f8ca:	26 c0       	rjmp	.+76     	; 0xf918 <vfscanf+0x202>
    f8cc:	15 37       	cpi	r17, 0x75	; 117
    f8ce:	31 f1       	breq	.+76     	; 0xf91c <vfscanf+0x206>
    f8d0:	18 37       	cpi	r17, 0x78	; 120
    f8d2:	71 f5       	brne	.+92     	; 0xf930 <vfscanf+0x21a>
    f8d4:	21 c0       	rjmp	.+66     	; 0xf918 <vfscanf+0x202>
    f8d6:	c4 01       	movw	r24, r8
    f8d8:	0e 94 3f 7f 	call	0xfe7e	; 0xfe7e <fgetc>
    f8dc:	ec 01       	movw	r28, r24
    f8de:	97 fd       	sbrc	r25, 7
    f8e0:	15 c0       	rjmp	.+42     	; 0xf90c <vfscanf+0x1f6>
    f8e2:	0e 94 96 7e 	call	0xfd2c	; 0xfd2c <isspace>
    f8e6:	89 2b       	or	r24, r25
    f8e8:	29 f0       	breq	.+10     	; 0xf8f4 <vfscanf+0x1de>
    f8ea:	ce 01       	movw	r24, r28
    f8ec:	b4 01       	movw	r22, r8
    f8ee:	0e 94 55 80 	call	0x100aa	; 0x100aa <ungetc>
    f8f2:	0c c0       	rjmp	.+24     	; 0xf90c <vfscanf+0x1f6>
    f8f4:	e1 14       	cp	r14, r1
    f8f6:	f1 04       	cpc	r15, r1
    f8f8:	19 f0       	breq	.+6      	; 0xf900 <vfscanf+0x1ea>
    f8fa:	f7 01       	movw	r30, r14
    f8fc:	c1 93       	st	Z+, r28
    f8fe:	7f 01       	movw	r14, r30
    f900:	08 94       	sec
    f902:	c1 08       	sbc	r12, r1
    f904:	d1 08       	sbc	r13, r1
    f906:	c1 14       	cp	r12, r1
    f908:	d1 04       	cpc	r13, r1
    f90a:	29 f7       	brne	.-54     	; 0xf8d6 <vfscanf+0x1c0>
    f90c:	e1 14       	cp	r14, r1
    f90e:	f1 04       	cpc	r15, r1
    f910:	d9 f0       	breq	.+54     	; 0xf948 <vfscanf+0x232>
    f912:	f7 01       	movw	r30, r14
    f914:	10 82       	st	Z, r1
    f916:	18 c0       	rjmp	.+48     	; 0xf948 <vfscanf+0x232>
    f918:	00 64       	ori	r16, 0x40	; 64
    f91a:	03 c0       	rjmp	.+6      	; 0xf922 <vfscanf+0x20c>
    f91c:	00 62       	ori	r16, 0x20	; 32
    f91e:	01 c0       	rjmp	.+2      	; 0xf922 <vfscanf+0x20c>
    f920:	00 61       	ori	r16, 0x10	; 16
    f922:	c4 01       	movw	r24, r8
    f924:	b6 01       	movw	r22, r12
    f926:	a7 01       	movw	r20, r14
    f928:	20 2f       	mov	r18, r16
    f92a:	0e 94 d7 78 	call	0xf1ae	; 0xf1ae <conv_int>
    f92e:	05 c0       	rjmp	.+10     	; 0xf93a <vfscanf+0x224>
    f930:	c4 01       	movw	r24, r8
    f932:	b6 01       	movw	r22, r12
    f934:	a7 01       	movw	r20, r14
    f936:	0e 94 38 7a 	call	0xf470	; 0xf470 <conv_flt>
    f93a:	88 23       	and	r24, r24
    f93c:	29 f4       	brne	.+10     	; 0xf948 <vfscanf+0x232>
    f93e:	f4 01       	movw	r30, r8
    f940:	83 81       	ldd	r24, Z+3	; 0x03
    f942:	80 73       	andi	r24, 0x30	; 48
    f944:	79 f4       	brne	.+30     	; 0xf964 <vfscanf+0x24e>
    f946:	13 c0       	rjmp	.+38     	; 0xf96e <vfscanf+0x258>
    f948:	00 ff       	sbrs	r16, 0
    f94a:	53 94       	inc	r5
    f94c:	f4 01       	movw	r30, r8
    f94e:	f3 80       	ldd	r15, Z+3	; 0x03
    f950:	f5 01       	movw	r30, r10
    f952:	f3 fc       	sbrc	r15, 3
    f954:	15 91       	lpm	r17, Z+
    f956:	f3 fe       	sbrs	r15, 3
    f958:	11 91       	ld	r17, Z+
    f95a:	5f 01       	movw	r10, r30
    f95c:	11 23       	and	r17, r17
    f95e:	09 f0       	breq	.+2      	; 0xf962 <vfscanf+0x24c>
    f960:	f1 ce       	rjmp	.-542    	; 0xf744 <vfscanf+0x2e>
    f962:	05 c0       	rjmp	.+10     	; 0xf96e <vfscanf+0x258>
    f964:	55 20       	and	r5, r5
    f966:	19 f4       	brne	.+6      	; 0xf96e <vfscanf+0x258>
    f968:	2f ef       	ldi	r18, 0xFF	; 255
    f96a:	3f ef       	ldi	r19, 0xFF	; 255
    f96c:	02 c0       	rjmp	.+4      	; 0xf972 <vfscanf+0x25c>
    f96e:	25 2d       	mov	r18, r5
    f970:	30 e0       	ldi	r19, 0x00	; 0
    f972:	c9 01       	movw	r24, r18
    f974:	df 91       	pop	r29
    f976:	cf 91       	pop	r28
    f978:	1f 91       	pop	r17
    f97a:	0f 91       	pop	r16
    f97c:	ff 90       	pop	r15
    f97e:	ef 90       	pop	r14
    f980:	df 90       	pop	r13
    f982:	cf 90       	pop	r12
    f984:	bf 90       	pop	r11
    f986:	af 90       	pop	r10
    f988:	9f 90       	pop	r9
    f98a:	8f 90       	pop	r8
    f98c:	7f 90       	pop	r7
    f98e:	6f 90       	pop	r6
    f990:	5f 90       	pop	r5
    f992:	08 95       	ret

0000f994 <__floatunsisf>:
    f994:	e8 94       	clt
    f996:	09 c0       	rjmp	.+18     	; 0xf9aa <__floatsisf+0x12>

0000f998 <__floatsisf>:
    f998:	97 fb       	bst	r25, 7
    f99a:	3e f4       	brtc	.+14     	; 0xf9aa <__floatsisf+0x12>
    f99c:	90 95       	com	r25
    f99e:	80 95       	com	r24
    f9a0:	70 95       	com	r23
    f9a2:	61 95       	neg	r22
    f9a4:	7f 4f       	sbci	r23, 0xFF	; 255
    f9a6:	8f 4f       	sbci	r24, 0xFF	; 255
    f9a8:	9f 4f       	sbci	r25, 0xFF	; 255
    f9aa:	99 23       	and	r25, r25
    f9ac:	a9 f0       	breq	.+42     	; 0xf9d8 <__floatsisf+0x40>
    f9ae:	f9 2f       	mov	r31, r25
    f9b0:	96 e9       	ldi	r25, 0x96	; 150
    f9b2:	bb 27       	eor	r27, r27
    f9b4:	93 95       	inc	r25
    f9b6:	f6 95       	lsr	r31
    f9b8:	87 95       	ror	r24
    f9ba:	77 95       	ror	r23
    f9bc:	67 95       	ror	r22
    f9be:	b7 95       	ror	r27
    f9c0:	f1 11       	cpse	r31, r1
    f9c2:	f8 cf       	rjmp	.-16     	; 0xf9b4 <__floatsisf+0x1c>
    f9c4:	fa f4       	brpl	.+62     	; 0xfa04 <__floatsisf+0x6c>
    f9c6:	bb 0f       	add	r27, r27
    f9c8:	11 f4       	brne	.+4      	; 0xf9ce <__floatsisf+0x36>
    f9ca:	60 ff       	sbrs	r22, 0
    f9cc:	1b c0       	rjmp	.+54     	; 0xfa04 <__floatsisf+0x6c>
    f9ce:	6f 5f       	subi	r22, 0xFF	; 255
    f9d0:	7f 4f       	sbci	r23, 0xFF	; 255
    f9d2:	8f 4f       	sbci	r24, 0xFF	; 255
    f9d4:	9f 4f       	sbci	r25, 0xFF	; 255
    f9d6:	16 c0       	rjmp	.+44     	; 0xfa04 <__floatsisf+0x6c>
    f9d8:	88 23       	and	r24, r24
    f9da:	11 f0       	breq	.+4      	; 0xf9e0 <__floatsisf+0x48>
    f9dc:	96 e9       	ldi	r25, 0x96	; 150
    f9de:	11 c0       	rjmp	.+34     	; 0xfa02 <__floatsisf+0x6a>
    f9e0:	77 23       	and	r23, r23
    f9e2:	21 f0       	breq	.+8      	; 0xf9ec <__floatsisf+0x54>
    f9e4:	9e e8       	ldi	r25, 0x8E	; 142
    f9e6:	87 2f       	mov	r24, r23
    f9e8:	76 2f       	mov	r23, r22
    f9ea:	05 c0       	rjmp	.+10     	; 0xf9f6 <__floatsisf+0x5e>
    f9ec:	66 23       	and	r22, r22
    f9ee:	71 f0       	breq	.+28     	; 0xfa0c <__floatsisf+0x74>
    f9f0:	96 e8       	ldi	r25, 0x86	; 134
    f9f2:	86 2f       	mov	r24, r22
    f9f4:	70 e0       	ldi	r23, 0x00	; 0
    f9f6:	60 e0       	ldi	r22, 0x00	; 0
    f9f8:	2a f0       	brmi	.+10     	; 0xfa04 <__floatsisf+0x6c>
    f9fa:	9a 95       	dec	r25
    f9fc:	66 0f       	add	r22, r22
    f9fe:	77 1f       	adc	r23, r23
    fa00:	88 1f       	adc	r24, r24
    fa02:	da f7       	brpl	.-10     	; 0xf9fa <__floatsisf+0x62>
    fa04:	88 0f       	add	r24, r24
    fa06:	96 95       	lsr	r25
    fa08:	87 95       	ror	r24
    fa0a:	97 f9       	bld	r25, 7
    fa0c:	08 95       	ret

0000fa0e <__mulsf3>:
    fa0e:	0b d0       	rcall	.+22     	; 0xfa26 <__mulsf3x>
    fa10:	78 c0       	rjmp	.+240    	; 0xfb02 <__fp_round>
    fa12:	69 d0       	rcall	.+210    	; 0xfae6 <__fp_pscA>
    fa14:	28 f0       	brcs	.+10     	; 0xfa20 <__mulsf3+0x12>
    fa16:	6e d0       	rcall	.+220    	; 0xfaf4 <__fp_pscB>
    fa18:	18 f0       	brcs	.+6      	; 0xfa20 <__mulsf3+0x12>
    fa1a:	95 23       	and	r25, r21
    fa1c:	09 f0       	breq	.+2      	; 0xfa20 <__mulsf3+0x12>
    fa1e:	5a c0       	rjmp	.+180    	; 0xfad4 <__fp_inf>
    fa20:	5f c0       	rjmp	.+190    	; 0xfae0 <__fp_nan>
    fa22:	11 24       	eor	r1, r1
    fa24:	a2 c0       	rjmp	.+324    	; 0xfb6a <__fp_szero>

0000fa26 <__mulsf3x>:
    fa26:	7e d0       	rcall	.+252    	; 0xfb24 <__fp_split3>
    fa28:	a0 f3       	brcs	.-24     	; 0xfa12 <__mulsf3+0x4>

0000fa2a <__mulsf3_pse>:
    fa2a:	95 9f       	mul	r25, r21
    fa2c:	d1 f3       	breq	.-12     	; 0xfa22 <__mulsf3+0x14>
    fa2e:	95 0f       	add	r25, r21
    fa30:	50 e0       	ldi	r21, 0x00	; 0
    fa32:	55 1f       	adc	r21, r21
    fa34:	62 9f       	mul	r22, r18
    fa36:	f0 01       	movw	r30, r0
    fa38:	72 9f       	mul	r23, r18
    fa3a:	bb 27       	eor	r27, r27
    fa3c:	f0 0d       	add	r31, r0
    fa3e:	b1 1d       	adc	r27, r1
    fa40:	63 9f       	mul	r22, r19
    fa42:	aa 27       	eor	r26, r26
    fa44:	f0 0d       	add	r31, r0
    fa46:	b1 1d       	adc	r27, r1
    fa48:	aa 1f       	adc	r26, r26
    fa4a:	64 9f       	mul	r22, r20
    fa4c:	66 27       	eor	r22, r22
    fa4e:	b0 0d       	add	r27, r0
    fa50:	a1 1d       	adc	r26, r1
    fa52:	66 1f       	adc	r22, r22
    fa54:	82 9f       	mul	r24, r18
    fa56:	22 27       	eor	r18, r18
    fa58:	b0 0d       	add	r27, r0
    fa5a:	a1 1d       	adc	r26, r1
    fa5c:	62 1f       	adc	r22, r18
    fa5e:	73 9f       	mul	r23, r19
    fa60:	b0 0d       	add	r27, r0
    fa62:	a1 1d       	adc	r26, r1
    fa64:	62 1f       	adc	r22, r18
    fa66:	83 9f       	mul	r24, r19
    fa68:	a0 0d       	add	r26, r0
    fa6a:	61 1d       	adc	r22, r1
    fa6c:	22 1f       	adc	r18, r18
    fa6e:	74 9f       	mul	r23, r20
    fa70:	33 27       	eor	r19, r19
    fa72:	a0 0d       	add	r26, r0
    fa74:	61 1d       	adc	r22, r1
    fa76:	23 1f       	adc	r18, r19
    fa78:	84 9f       	mul	r24, r20
    fa7a:	60 0d       	add	r22, r0
    fa7c:	21 1d       	adc	r18, r1
    fa7e:	82 2f       	mov	r24, r18
    fa80:	76 2f       	mov	r23, r22
    fa82:	6a 2f       	mov	r22, r26
    fa84:	11 24       	eor	r1, r1
    fa86:	9f 57       	subi	r25, 0x7F	; 127
    fa88:	50 40       	sbci	r21, 0x00	; 0
    fa8a:	8a f0       	brmi	.+34     	; 0xfaae <__mulsf3_pse+0x84>
    fa8c:	e1 f0       	breq	.+56     	; 0xfac6 <__mulsf3_pse+0x9c>
    fa8e:	88 23       	and	r24, r24
    fa90:	4a f0       	brmi	.+18     	; 0xfaa4 <__mulsf3_pse+0x7a>
    fa92:	ee 0f       	add	r30, r30
    fa94:	ff 1f       	adc	r31, r31
    fa96:	bb 1f       	adc	r27, r27
    fa98:	66 1f       	adc	r22, r22
    fa9a:	77 1f       	adc	r23, r23
    fa9c:	88 1f       	adc	r24, r24
    fa9e:	91 50       	subi	r25, 0x01	; 1
    faa0:	50 40       	sbci	r21, 0x00	; 0
    faa2:	a9 f7       	brne	.-22     	; 0xfa8e <__mulsf3_pse+0x64>
    faa4:	9e 3f       	cpi	r25, 0xFE	; 254
    faa6:	51 05       	cpc	r21, r1
    faa8:	70 f0       	brcs	.+28     	; 0xfac6 <__mulsf3_pse+0x9c>
    faaa:	14 c0       	rjmp	.+40     	; 0xfad4 <__fp_inf>
    faac:	5e c0       	rjmp	.+188    	; 0xfb6a <__fp_szero>
    faae:	5f 3f       	cpi	r21, 0xFF	; 255
    fab0:	ec f3       	brlt	.-6      	; 0xfaac <__mulsf3_pse+0x82>
    fab2:	98 3e       	cpi	r25, 0xE8	; 232
    fab4:	dc f3       	brlt	.-10     	; 0xfaac <__mulsf3_pse+0x82>
    fab6:	86 95       	lsr	r24
    fab8:	77 95       	ror	r23
    faba:	67 95       	ror	r22
    fabc:	b7 95       	ror	r27
    fabe:	f7 95       	ror	r31
    fac0:	e7 95       	ror	r30
    fac2:	9f 5f       	subi	r25, 0xFF	; 255
    fac4:	c1 f7       	brne	.-16     	; 0xfab6 <__mulsf3_pse+0x8c>
    fac6:	fe 2b       	or	r31, r30
    fac8:	88 0f       	add	r24, r24
    faca:	91 1d       	adc	r25, r1
    facc:	96 95       	lsr	r25
    face:	87 95       	ror	r24
    fad0:	97 f9       	bld	r25, 7
    fad2:	08 95       	ret

0000fad4 <__fp_inf>:
    fad4:	97 f9       	bld	r25, 7
    fad6:	9f 67       	ori	r25, 0x7F	; 127
    fad8:	80 e8       	ldi	r24, 0x80	; 128
    fada:	70 e0       	ldi	r23, 0x00	; 0
    fadc:	60 e0       	ldi	r22, 0x00	; 0
    fade:	08 95       	ret

0000fae0 <__fp_nan>:
    fae0:	9f ef       	ldi	r25, 0xFF	; 255
    fae2:	80 ec       	ldi	r24, 0xC0	; 192
    fae4:	08 95       	ret

0000fae6 <__fp_pscA>:
    fae6:	00 24       	eor	r0, r0
    fae8:	0a 94       	dec	r0
    faea:	16 16       	cp	r1, r22
    faec:	17 06       	cpc	r1, r23
    faee:	18 06       	cpc	r1, r24
    faf0:	09 06       	cpc	r0, r25
    faf2:	08 95       	ret

0000faf4 <__fp_pscB>:
    faf4:	00 24       	eor	r0, r0
    faf6:	0a 94       	dec	r0
    faf8:	12 16       	cp	r1, r18
    fafa:	13 06       	cpc	r1, r19
    fafc:	14 06       	cpc	r1, r20
    fafe:	05 06       	cpc	r0, r21
    fb00:	08 95       	ret

0000fb02 <__fp_round>:
    fb02:	09 2e       	mov	r0, r25
    fb04:	03 94       	inc	r0
    fb06:	00 0c       	add	r0, r0
    fb08:	11 f4       	brne	.+4      	; 0xfb0e <__fp_round+0xc>
    fb0a:	88 23       	and	r24, r24
    fb0c:	52 f0       	brmi	.+20     	; 0xfb22 <__fp_round+0x20>
    fb0e:	bb 0f       	add	r27, r27
    fb10:	40 f4       	brcc	.+16     	; 0xfb22 <__fp_round+0x20>
    fb12:	bf 2b       	or	r27, r31
    fb14:	11 f4       	brne	.+4      	; 0xfb1a <__fp_round+0x18>
    fb16:	60 ff       	sbrs	r22, 0
    fb18:	04 c0       	rjmp	.+8      	; 0xfb22 <__fp_round+0x20>
    fb1a:	6f 5f       	subi	r22, 0xFF	; 255
    fb1c:	7f 4f       	sbci	r23, 0xFF	; 255
    fb1e:	8f 4f       	sbci	r24, 0xFF	; 255
    fb20:	9f 4f       	sbci	r25, 0xFF	; 255
    fb22:	08 95       	ret

0000fb24 <__fp_split3>:
    fb24:	57 fd       	sbrc	r21, 7
    fb26:	90 58       	subi	r25, 0x80	; 128
    fb28:	44 0f       	add	r20, r20
    fb2a:	55 1f       	adc	r21, r21
    fb2c:	59 f0       	breq	.+22     	; 0xfb44 <__fp_splitA+0x10>
    fb2e:	5f 3f       	cpi	r21, 0xFF	; 255
    fb30:	71 f0       	breq	.+28     	; 0xfb4e <__fp_splitA+0x1a>
    fb32:	47 95       	ror	r20

0000fb34 <__fp_splitA>:
    fb34:	88 0f       	add	r24, r24
    fb36:	97 fb       	bst	r25, 7
    fb38:	99 1f       	adc	r25, r25
    fb3a:	61 f0       	breq	.+24     	; 0xfb54 <__fp_splitA+0x20>
    fb3c:	9f 3f       	cpi	r25, 0xFF	; 255
    fb3e:	79 f0       	breq	.+30     	; 0xfb5e <__fp_splitA+0x2a>
    fb40:	87 95       	ror	r24
    fb42:	08 95       	ret
    fb44:	12 16       	cp	r1, r18
    fb46:	13 06       	cpc	r1, r19
    fb48:	14 06       	cpc	r1, r20
    fb4a:	55 1f       	adc	r21, r21
    fb4c:	f2 cf       	rjmp	.-28     	; 0xfb32 <__fp_split3+0xe>
    fb4e:	46 95       	lsr	r20
    fb50:	f1 df       	rcall	.-30     	; 0xfb34 <__fp_splitA>
    fb52:	08 c0       	rjmp	.+16     	; 0xfb64 <__fp_splitA+0x30>
    fb54:	16 16       	cp	r1, r22
    fb56:	17 06       	cpc	r1, r23
    fb58:	18 06       	cpc	r1, r24
    fb5a:	99 1f       	adc	r25, r25
    fb5c:	f1 cf       	rjmp	.-30     	; 0xfb40 <__fp_splitA+0xc>
    fb5e:	86 95       	lsr	r24
    fb60:	71 05       	cpc	r23, r1
    fb62:	61 05       	cpc	r22, r1
    fb64:	08 94       	sec
    fb66:	08 95       	ret

0000fb68 <__fp_zero>:
    fb68:	e8 94       	clt

0000fb6a <__fp_szero>:
    fb6a:	bb 27       	eor	r27, r27
    fb6c:	66 27       	eor	r22, r22
    fb6e:	77 27       	eor	r23, r23
    fb70:	cb 01       	movw	r24, r22
    fb72:	97 f9       	bld	r25, 7
    fb74:	08 95       	ret

0000fb76 <exit>:
    fb76:	f8 94       	cli
    fb78:	0c 94 a6 82 	jmp	0x1054c	; 0x1054c <_exit>

0000fb7c <__ftoa_engine>:
    fb7c:	28 30       	cpi	r18, 0x08	; 8
    fb7e:	08 f0       	brcs	.+2      	; 0xfb82 <__ftoa_engine+0x6>
    fb80:	27 e0       	ldi	r18, 0x07	; 7
    fb82:	33 27       	eor	r19, r19
    fb84:	da 01       	movw	r26, r20
    fb86:	99 0f       	add	r25, r25
    fb88:	31 1d       	adc	r19, r1
    fb8a:	87 fd       	sbrc	r24, 7
    fb8c:	91 60       	ori	r25, 0x01	; 1
    fb8e:	00 96       	adiw	r24, 0x00	; 0
    fb90:	61 05       	cpc	r22, r1
    fb92:	71 05       	cpc	r23, r1
    fb94:	39 f4       	brne	.+14     	; 0xfba4 <__ftoa_engine+0x28>
    fb96:	32 60       	ori	r19, 0x02	; 2
    fb98:	2e 5f       	subi	r18, 0xFE	; 254
    fb9a:	3d 93       	st	X+, r19
    fb9c:	30 e3       	ldi	r19, 0x30	; 48
    fb9e:	2a 95       	dec	r18
    fba0:	e1 f7       	brne	.-8      	; 0xfb9a <__ftoa_engine+0x1e>
    fba2:	08 95       	ret
    fba4:	9f 3f       	cpi	r25, 0xFF	; 255
    fba6:	30 f0       	brcs	.+12     	; 0xfbb4 <__ftoa_engine+0x38>
    fba8:	80 38       	cpi	r24, 0x80	; 128
    fbaa:	71 05       	cpc	r23, r1
    fbac:	61 05       	cpc	r22, r1
    fbae:	09 f0       	breq	.+2      	; 0xfbb2 <__ftoa_engine+0x36>
    fbb0:	3c 5f       	subi	r19, 0xFC	; 252
    fbb2:	3c 5f       	subi	r19, 0xFC	; 252
    fbb4:	3d 93       	st	X+, r19
    fbb6:	91 30       	cpi	r25, 0x01	; 1
    fbb8:	08 f0       	brcs	.+2      	; 0xfbbc <__ftoa_engine+0x40>
    fbba:	80 68       	ori	r24, 0x80	; 128
    fbbc:	91 1d       	adc	r25, r1
    fbbe:	df 93       	push	r29
    fbc0:	cf 93       	push	r28
    fbc2:	1f 93       	push	r17
    fbc4:	0f 93       	push	r16
    fbc6:	ff 92       	push	r15
    fbc8:	ef 92       	push	r14
    fbca:	19 2f       	mov	r17, r25
    fbcc:	98 7f       	andi	r25, 0xF8	; 248
    fbce:	96 95       	lsr	r25
    fbd0:	e9 2f       	mov	r30, r25
    fbd2:	96 95       	lsr	r25
    fbd4:	96 95       	lsr	r25
    fbd6:	e9 0f       	add	r30, r25
    fbd8:	ff 27       	eor	r31, r31
    fbda:	e9 5c       	subi	r30, 0xC9	; 201
    fbdc:	fe 4c       	sbci	r31, 0xCE	; 206
    fbde:	99 27       	eor	r25, r25
    fbe0:	33 27       	eor	r19, r19
    fbe2:	ee 24       	eor	r14, r14
    fbe4:	ff 24       	eor	r15, r15
    fbe6:	a7 01       	movw	r20, r14
    fbe8:	e7 01       	movw	r28, r14
    fbea:	05 90       	lpm	r0, Z+
    fbec:	08 94       	sec
    fbee:	07 94       	ror	r0
    fbf0:	28 f4       	brcc	.+10     	; 0xfbfc <__ftoa_engine+0x80>
    fbf2:	36 0f       	add	r19, r22
    fbf4:	e7 1e       	adc	r14, r23
    fbf6:	f8 1e       	adc	r15, r24
    fbf8:	49 1f       	adc	r20, r25
    fbfa:	51 1d       	adc	r21, r1
    fbfc:	66 0f       	add	r22, r22
    fbfe:	77 1f       	adc	r23, r23
    fc00:	88 1f       	adc	r24, r24
    fc02:	99 1f       	adc	r25, r25
    fc04:	06 94       	lsr	r0
    fc06:	a1 f7       	brne	.-24     	; 0xfbf0 <__ftoa_engine+0x74>
    fc08:	05 90       	lpm	r0, Z+
    fc0a:	07 94       	ror	r0
    fc0c:	28 f4       	brcc	.+10     	; 0xfc18 <__ftoa_engine+0x9c>
    fc0e:	e7 0e       	add	r14, r23
    fc10:	f8 1e       	adc	r15, r24
    fc12:	49 1f       	adc	r20, r25
    fc14:	56 1f       	adc	r21, r22
    fc16:	c1 1d       	adc	r28, r1
    fc18:	77 0f       	add	r23, r23
    fc1a:	88 1f       	adc	r24, r24
    fc1c:	99 1f       	adc	r25, r25
    fc1e:	66 1f       	adc	r22, r22
    fc20:	06 94       	lsr	r0
    fc22:	a1 f7       	brne	.-24     	; 0xfc0c <__ftoa_engine+0x90>
    fc24:	05 90       	lpm	r0, Z+
    fc26:	07 94       	ror	r0
    fc28:	28 f4       	brcc	.+10     	; 0xfc34 <__ftoa_engine+0xb8>
    fc2a:	f8 0e       	add	r15, r24
    fc2c:	49 1f       	adc	r20, r25
    fc2e:	56 1f       	adc	r21, r22
    fc30:	c7 1f       	adc	r28, r23
    fc32:	d1 1d       	adc	r29, r1
    fc34:	88 0f       	add	r24, r24
    fc36:	99 1f       	adc	r25, r25
    fc38:	66 1f       	adc	r22, r22
    fc3a:	77 1f       	adc	r23, r23
    fc3c:	06 94       	lsr	r0
    fc3e:	a1 f7       	brne	.-24     	; 0xfc28 <__ftoa_engine+0xac>
    fc40:	05 90       	lpm	r0, Z+
    fc42:	07 94       	ror	r0
    fc44:	20 f4       	brcc	.+8      	; 0xfc4e <__ftoa_engine+0xd2>
    fc46:	49 0f       	add	r20, r25
    fc48:	56 1f       	adc	r21, r22
    fc4a:	c7 1f       	adc	r28, r23
    fc4c:	d8 1f       	adc	r29, r24
    fc4e:	99 0f       	add	r25, r25
    fc50:	66 1f       	adc	r22, r22
    fc52:	77 1f       	adc	r23, r23
    fc54:	88 1f       	adc	r24, r24
    fc56:	06 94       	lsr	r0
    fc58:	a9 f7       	brne	.-22     	; 0xfc44 <__ftoa_engine+0xc8>
    fc5a:	84 91       	lpm	r24, Z+
    fc5c:	10 95       	com	r17
    fc5e:	17 70       	andi	r17, 0x07	; 7
    fc60:	41 f0       	breq	.+16     	; 0xfc72 <__ftoa_engine+0xf6>
    fc62:	d6 95       	lsr	r29
    fc64:	c7 95       	ror	r28
    fc66:	57 95       	ror	r21
    fc68:	47 95       	ror	r20
    fc6a:	f7 94       	ror	r15
    fc6c:	e7 94       	ror	r14
    fc6e:	1a 95       	dec	r17
    fc70:	c1 f7       	brne	.-16     	; 0xfc62 <__ftoa_engine+0xe6>
    fc72:	ed ed       	ldi	r30, 0xDD	; 221
    fc74:	f0 e3       	ldi	r31, 0x30	; 48
    fc76:	68 94       	set
    fc78:	15 90       	lpm	r1, Z+
    fc7a:	15 91       	lpm	r17, Z+
    fc7c:	35 91       	lpm	r19, Z+
    fc7e:	65 91       	lpm	r22, Z+
    fc80:	95 91       	lpm	r25, Z+
    fc82:	05 90       	lpm	r0, Z+
    fc84:	7f e2       	ldi	r23, 0x2F	; 47
    fc86:	73 95       	inc	r23
    fc88:	e1 18       	sub	r14, r1
    fc8a:	f1 0a       	sbc	r15, r17
    fc8c:	43 0b       	sbc	r20, r19
    fc8e:	56 0b       	sbc	r21, r22
    fc90:	c9 0b       	sbc	r28, r25
    fc92:	d0 09       	sbc	r29, r0
    fc94:	c0 f7       	brcc	.-16     	; 0xfc86 <__ftoa_engine+0x10a>
    fc96:	e1 0c       	add	r14, r1
    fc98:	f1 1e       	adc	r15, r17
    fc9a:	43 1f       	adc	r20, r19
    fc9c:	56 1f       	adc	r21, r22
    fc9e:	c9 1f       	adc	r28, r25
    fca0:	d0 1d       	adc	r29, r0
    fca2:	7e f4       	brtc	.+30     	; 0xfcc2 <__ftoa_engine+0x146>
    fca4:	70 33       	cpi	r23, 0x30	; 48
    fca6:	11 f4       	brne	.+4      	; 0xfcac <__ftoa_engine+0x130>
    fca8:	8a 95       	dec	r24
    fcaa:	e6 cf       	rjmp	.-52     	; 0xfc78 <__ftoa_engine+0xfc>
    fcac:	e8 94       	clt
    fcae:	01 50       	subi	r16, 0x01	; 1
    fcb0:	30 f0       	brcs	.+12     	; 0xfcbe <__ftoa_engine+0x142>
    fcb2:	08 0f       	add	r16, r24
    fcb4:	0a f4       	brpl	.+2      	; 0xfcb8 <__ftoa_engine+0x13c>
    fcb6:	00 27       	eor	r16, r16
    fcb8:	02 17       	cp	r16, r18
    fcba:	08 f4       	brcc	.+2      	; 0xfcbe <__ftoa_engine+0x142>
    fcbc:	20 2f       	mov	r18, r16
    fcbe:	23 95       	inc	r18
    fcc0:	02 2f       	mov	r16, r18
    fcc2:	7a 33       	cpi	r23, 0x3A	; 58
    fcc4:	28 f0       	brcs	.+10     	; 0xfcd0 <__ftoa_engine+0x154>
    fcc6:	79 e3       	ldi	r23, 0x39	; 57
    fcc8:	7d 93       	st	X+, r23
    fcca:	2a 95       	dec	r18
    fccc:	e9 f7       	brne	.-6      	; 0xfcc8 <__ftoa_engine+0x14c>
    fcce:	10 c0       	rjmp	.+32     	; 0xfcf0 <__ftoa_engine+0x174>
    fcd0:	7d 93       	st	X+, r23
    fcd2:	2a 95       	dec	r18
    fcd4:	89 f6       	brne	.-94     	; 0xfc78 <__ftoa_engine+0xfc>
    fcd6:	06 94       	lsr	r0
    fcd8:	97 95       	ror	r25
    fcda:	67 95       	ror	r22
    fcdc:	37 95       	ror	r19
    fcde:	17 95       	ror	r17
    fce0:	17 94       	ror	r1
    fce2:	e1 18       	sub	r14, r1
    fce4:	f1 0a       	sbc	r15, r17
    fce6:	43 0b       	sbc	r20, r19
    fce8:	56 0b       	sbc	r21, r22
    fcea:	c9 0b       	sbc	r28, r25
    fcec:	d0 09       	sbc	r29, r0
    fcee:	98 f0       	brcs	.+38     	; 0xfd16 <__ftoa_engine+0x19a>
    fcf0:	23 95       	inc	r18
    fcf2:	7e 91       	ld	r23, -X
    fcf4:	73 95       	inc	r23
    fcf6:	7a 33       	cpi	r23, 0x3A	; 58
    fcf8:	08 f0       	brcs	.+2      	; 0xfcfc <__ftoa_engine+0x180>
    fcfa:	70 e3       	ldi	r23, 0x30	; 48
    fcfc:	7c 93       	st	X, r23
    fcfe:	20 13       	cpse	r18, r16
    fd00:	b8 f7       	brcc	.-18     	; 0xfcf0 <__ftoa_engine+0x174>
    fd02:	7e 91       	ld	r23, -X
    fd04:	70 61       	ori	r23, 0x10	; 16
    fd06:	7d 93       	st	X+, r23
    fd08:	30 f0       	brcs	.+12     	; 0xfd16 <__ftoa_engine+0x19a>
    fd0a:	83 95       	inc	r24
    fd0c:	71 e3       	ldi	r23, 0x31	; 49
    fd0e:	7d 93       	st	X+, r23
    fd10:	70 e3       	ldi	r23, 0x30	; 48
    fd12:	2a 95       	dec	r18
    fd14:	e1 f7       	brne	.-8      	; 0xfd0e <__ftoa_engine+0x192>
    fd16:	11 24       	eor	r1, r1
    fd18:	ef 90       	pop	r14
    fd1a:	ff 90       	pop	r15
    fd1c:	0f 91       	pop	r16
    fd1e:	1f 91       	pop	r17
    fd20:	cf 91       	pop	r28
    fd22:	df 91       	pop	r29
    fd24:	99 27       	eor	r25, r25
    fd26:	87 fd       	sbrc	r24, 7
    fd28:	90 95       	com	r25
    fd2a:	08 95       	ret

0000fd2c <isspace>:
    fd2c:	91 11       	cpse	r25, r1
    fd2e:	7c c3       	rjmp	.+1784   	; 0x10428 <__ctype_isfalse>
    fd30:	80 32       	cpi	r24, 0x20	; 32
    fd32:	19 f0       	breq	.+6      	; 0xfd3a <isspace+0xe>
    fd34:	89 50       	subi	r24, 0x09	; 9
    fd36:	85 50       	subi	r24, 0x05	; 5
    fd38:	d0 f7       	brcc	.-12     	; 0xfd2e <isspace+0x2>
    fd3a:	08 95       	ret

0000fd3c <tolower>:
    fd3c:	91 11       	cpse	r25, r1
    fd3e:	08 95       	ret
    fd40:	81 54       	subi	r24, 0x41	; 65
    fd42:	8a 51       	subi	r24, 0x1A	; 26
    fd44:	08 f4       	brcc	.+2      	; 0xfd48 <tolower+0xc>
    fd46:	80 5e       	subi	r24, 0xE0	; 224
    fd48:	85 5a       	subi	r24, 0xA5	; 165
    fd4a:	08 95       	ret

0000fd4c <strchr_P>:
    fd4c:	fc 01       	movw	r30, r24
    fd4e:	05 90       	lpm	r0, Z+
    fd50:	06 16       	cp	r0, r22
    fd52:	21 f0       	breq	.+8      	; 0xfd5c <strchr_P+0x10>
    fd54:	00 20       	and	r0, r0
    fd56:	d9 f7       	brne	.-10     	; 0xfd4e <strchr_P+0x2>
    fd58:	c0 01       	movw	r24, r0
    fd5a:	08 95       	ret
    fd5c:	31 97       	sbiw	r30, 0x01	; 1
    fd5e:	cf 01       	movw	r24, r30
    fd60:	08 95       	ret

0000fd62 <strcmp_P>:
    fd62:	fb 01       	movw	r30, r22
    fd64:	dc 01       	movw	r26, r24
    fd66:	8d 91       	ld	r24, X+
    fd68:	05 90       	lpm	r0, Z+
    fd6a:	80 19       	sub	r24, r0
    fd6c:	01 10       	cpse	r0, r1
    fd6e:	d9 f3       	breq	.-10     	; 0xfd66 <strcmp_P+0x4>
    fd70:	99 0b       	sbc	r25, r25
    fd72:	08 95       	ret

0000fd74 <strcpy_P>:
    fd74:	fb 01       	movw	r30, r22
    fd76:	dc 01       	movw	r26, r24
    fd78:	05 90       	lpm	r0, Z+
    fd7a:	0d 92       	st	X+, r0
    fd7c:	00 20       	and	r0, r0
    fd7e:	e1 f7       	brne	.-8      	; 0xfd78 <strcpy_P+0x4>
    fd80:	08 95       	ret

0000fd82 <strlen_P>:
    fd82:	fc 01       	movw	r30, r24
    fd84:	05 90       	lpm	r0, Z+
    fd86:	00 20       	and	r0, r0
    fd88:	e9 f7       	brne	.-6      	; 0xfd84 <strlen_P+0x2>
    fd8a:	80 95       	com	r24
    fd8c:	90 95       	com	r25
    fd8e:	8e 0f       	add	r24, r30
    fd90:	9f 1f       	adc	r25, r31
    fd92:	08 95       	ret

0000fd94 <strncmp_P>:
    fd94:	fb 01       	movw	r30, r22
    fd96:	dc 01       	movw	r26, r24
    fd98:	41 50       	subi	r20, 0x01	; 1
    fd9a:	50 40       	sbci	r21, 0x00	; 0
    fd9c:	30 f0       	brcs	.+12     	; 0xfdaa <strncmp_P+0x16>
    fd9e:	8d 91       	ld	r24, X+
    fda0:	05 90       	lpm	r0, Z+
    fda2:	80 19       	sub	r24, r0
    fda4:	19 f4       	brne	.+6      	; 0xfdac <strncmp_P+0x18>
    fda6:	00 20       	and	r0, r0
    fda8:	b9 f7       	brne	.-18     	; 0xfd98 <strncmp_P+0x4>
    fdaa:	88 1b       	sub	r24, r24
    fdac:	99 0b       	sbc	r25, r25
    fdae:	08 95       	ret

0000fdb0 <strnlen_P>:
    fdb0:	fc 01       	movw	r30, r24
    fdb2:	05 90       	lpm	r0, Z+
    fdb4:	61 50       	subi	r22, 0x01	; 1
    fdb6:	70 40       	sbci	r23, 0x00	; 0
    fdb8:	01 10       	cpse	r0, r1
    fdba:	d8 f7       	brcc	.-10     	; 0xfdb2 <strnlen_P+0x2>
    fdbc:	80 95       	com	r24
    fdbe:	90 95       	com	r25
    fdc0:	8e 0f       	add	r24, r30
    fdc2:	9f 1f       	adc	r25, r31
    fdc4:	08 95       	ret

0000fdc6 <strstr_P>:
    fdc6:	fb 01       	movw	r30, r22
    fdc8:	55 91       	lpm	r21, Z+
    fdca:	55 23       	and	r21, r21
    fdcc:	a9 f0       	breq	.+42     	; 0xfdf8 <strstr_P+0x32>
    fdce:	bf 01       	movw	r22, r30
    fdd0:	dc 01       	movw	r26, r24
    fdd2:	4d 91       	ld	r20, X+
    fdd4:	45 17       	cp	r20, r21
    fdd6:	41 11       	cpse	r20, r1
    fdd8:	e1 f7       	brne	.-8      	; 0xfdd2 <strstr_P+0xc>
    fdda:	59 f4       	brne	.+22     	; 0xfdf2 <strstr_P+0x2c>
    fddc:	cd 01       	movw	r24, r26
    fdde:	05 90       	lpm	r0, Z+
    fde0:	00 20       	and	r0, r0
    fde2:	49 f0       	breq	.+18     	; 0xfdf6 <strstr_P+0x30>
    fde4:	4d 91       	ld	r20, X+
    fde6:	40 15       	cp	r20, r0
    fde8:	41 11       	cpse	r20, r1
    fdea:	c9 f3       	breq	.-14     	; 0xfdde <strstr_P+0x18>
    fdec:	fb 01       	movw	r30, r22
    fdee:	41 11       	cpse	r20, r1
    fdf0:	ef cf       	rjmp	.-34     	; 0xfdd0 <strstr_P+0xa>
    fdf2:	81 e0       	ldi	r24, 0x01	; 1
    fdf4:	90 e0       	ldi	r25, 0x00	; 0
    fdf6:	01 97       	sbiw	r24, 0x01	; 1
    fdf8:	08 95       	ret

0000fdfa <memcpy>:
    fdfa:	fb 01       	movw	r30, r22
    fdfc:	dc 01       	movw	r26, r24
    fdfe:	02 c0       	rjmp	.+4      	; 0xfe04 <memcpy+0xa>
    fe00:	01 90       	ld	r0, Z+
    fe02:	0d 92       	st	X+, r0
    fe04:	41 50       	subi	r20, 0x01	; 1
    fe06:	50 40       	sbci	r21, 0x00	; 0
    fe08:	d8 f7       	brcc	.-10     	; 0xfe00 <memcpy+0x6>
    fe0a:	08 95       	ret

0000fe0c <strchr>:
    fe0c:	fc 01       	movw	r30, r24
    fe0e:	81 91       	ld	r24, Z+
    fe10:	86 17       	cp	r24, r22
    fe12:	21 f0       	breq	.+8      	; 0xfe1c <strchr+0x10>
    fe14:	88 23       	and	r24, r24
    fe16:	d9 f7       	brne	.-10     	; 0xfe0e <strchr+0x2>
    fe18:	99 27       	eor	r25, r25
    fe1a:	08 95       	ret
    fe1c:	31 97       	sbiw	r30, 0x01	; 1
    fe1e:	cf 01       	movw	r24, r30
    fe20:	08 95       	ret

0000fe22 <strcmp>:
    fe22:	fb 01       	movw	r30, r22
    fe24:	dc 01       	movw	r26, r24
    fe26:	8d 91       	ld	r24, X+
    fe28:	01 90       	ld	r0, Z+
    fe2a:	80 19       	sub	r24, r0
    fe2c:	01 10       	cpse	r0, r1
    fe2e:	d9 f3       	breq	.-10     	; 0xfe26 <strcmp+0x4>
    fe30:	99 0b       	sbc	r25, r25
    fe32:	08 95       	ret

0000fe34 <strnlen>:
    fe34:	fc 01       	movw	r30, r24
    fe36:	61 50       	subi	r22, 0x01	; 1
    fe38:	70 40       	sbci	r23, 0x00	; 0
    fe3a:	01 90       	ld	r0, Z+
    fe3c:	01 10       	cpse	r0, r1
    fe3e:	d8 f7       	brcc	.-10     	; 0xfe36 <strnlen+0x2>
    fe40:	80 95       	com	r24
    fe42:	90 95       	com	r25
    fe44:	8e 0f       	add	r24, r30
    fe46:	9f 1f       	adc	r25, r31
    fe48:	08 95       	ret

0000fe4a <strstr>:
    fe4a:	fb 01       	movw	r30, r22
    fe4c:	51 91       	ld	r21, Z+
    fe4e:	55 23       	and	r21, r21
    fe50:	a9 f0       	breq	.+42     	; 0xfe7c <strstr+0x32>
    fe52:	bf 01       	movw	r22, r30
    fe54:	dc 01       	movw	r26, r24
    fe56:	4d 91       	ld	r20, X+
    fe58:	45 17       	cp	r20, r21
    fe5a:	41 11       	cpse	r20, r1
    fe5c:	e1 f7       	brne	.-8      	; 0xfe56 <strstr+0xc>
    fe5e:	59 f4       	brne	.+22     	; 0xfe76 <strstr+0x2c>
    fe60:	cd 01       	movw	r24, r26
    fe62:	01 90       	ld	r0, Z+
    fe64:	00 20       	and	r0, r0
    fe66:	49 f0       	breq	.+18     	; 0xfe7a <strstr+0x30>
    fe68:	4d 91       	ld	r20, X+
    fe6a:	40 15       	cp	r20, r0
    fe6c:	41 11       	cpse	r20, r1
    fe6e:	c9 f3       	breq	.-14     	; 0xfe62 <strstr+0x18>
    fe70:	fb 01       	movw	r30, r22
    fe72:	41 11       	cpse	r20, r1
    fe74:	ef cf       	rjmp	.-34     	; 0xfe54 <strstr+0xa>
    fe76:	81 e0       	ldi	r24, 0x01	; 1
    fe78:	90 e0       	ldi	r25, 0x00	; 0
    fe7a:	01 97       	sbiw	r24, 0x01	; 1
    fe7c:	08 95       	ret

0000fe7e <fgetc>:
    fe7e:	cf 93       	push	r28
    fe80:	df 93       	push	r29
    fe82:	ec 01       	movw	r28, r24
    fe84:	4b 81       	ldd	r20, Y+3	; 0x03
    fe86:	40 ff       	sbrs	r20, 0
    fe88:	1a c0       	rjmp	.+52     	; 0xfebe <fgetc+0x40>
    fe8a:	46 ff       	sbrs	r20, 6
    fe8c:	0a c0       	rjmp	.+20     	; 0xfea2 <fgetc+0x24>
    fe8e:	4f 7b       	andi	r20, 0xBF	; 191
    fe90:	4b 83       	std	Y+3, r20	; 0x03
    fe92:	8e 81       	ldd	r24, Y+6	; 0x06
    fe94:	9f 81       	ldd	r25, Y+7	; 0x07
    fe96:	01 96       	adiw	r24, 0x01	; 1
    fe98:	9f 83       	std	Y+7, r25	; 0x07
    fe9a:	8e 83       	std	Y+6, r24	; 0x06
    fe9c:	8a 81       	ldd	r24, Y+2	; 0x02
    fe9e:	28 2f       	mov	r18, r24
    fea0:	2b c0       	rjmp	.+86     	; 0xfef8 <fgetc+0x7a>
    fea2:	42 ff       	sbrs	r20, 2
    fea4:	13 c0       	rjmp	.+38     	; 0xfecc <fgetc+0x4e>
    fea6:	e8 81       	ld	r30, Y
    fea8:	f9 81       	ldd	r31, Y+1	; 0x01
    feaa:	80 81       	ld	r24, Z
    feac:	28 2f       	mov	r18, r24
    feae:	33 27       	eor	r19, r19
    feb0:	27 fd       	sbrc	r18, 7
    feb2:	30 95       	com	r19
    feb4:	21 15       	cp	r18, r1
    feb6:	31 05       	cpc	r19, r1
    feb8:	29 f4       	brne	.+10     	; 0xfec4 <fgetc+0x46>
    feba:	40 62       	ori	r20, 0x20	; 32
    febc:	4b 83       	std	Y+3, r20	; 0x03
    febe:	2f ef       	ldi	r18, 0xFF	; 255
    fec0:	3f ef       	ldi	r19, 0xFF	; 255
    fec2:	1b c0       	rjmp	.+54     	; 0xfefa <fgetc+0x7c>
    fec4:	31 96       	adiw	r30, 0x01	; 1
    fec6:	f9 83       	std	Y+1, r31	; 0x01
    fec8:	e8 83       	st	Y, r30
    feca:	11 c0       	rjmp	.+34     	; 0xfeee <fgetc+0x70>
    fecc:	ea 85       	ldd	r30, Y+10	; 0x0a
    fece:	fb 85       	ldd	r31, Y+11	; 0x0b
    fed0:	ce 01       	movw	r24, r28
    fed2:	19 95       	eicall
    fed4:	9c 01       	movw	r18, r24
    fed6:	97 ff       	sbrs	r25, 7
    fed8:	0a c0       	rjmp	.+20     	; 0xfeee <fgetc+0x70>
    feda:	9b 81       	ldd	r25, Y+3	; 0x03
    fedc:	2f 5f       	subi	r18, 0xFF	; 255
    fede:	3f 4f       	sbci	r19, 0xFF	; 255
    fee0:	11 f0       	breq	.+4      	; 0xfee6 <fgetc+0x68>
    fee2:	80 e2       	ldi	r24, 0x20	; 32
    fee4:	01 c0       	rjmp	.+2      	; 0xfee8 <fgetc+0x6a>
    fee6:	80 e1       	ldi	r24, 0x10	; 16
    fee8:	89 2b       	or	r24, r25
    feea:	8b 83       	std	Y+3, r24	; 0x03
    feec:	e8 cf       	rjmp	.-48     	; 0xfebe <fgetc+0x40>
    feee:	8e 81       	ldd	r24, Y+6	; 0x06
    fef0:	9f 81       	ldd	r25, Y+7	; 0x07
    fef2:	01 96       	adiw	r24, 0x01	; 1
    fef4:	9f 83       	std	Y+7, r25	; 0x07
    fef6:	8e 83       	std	Y+6, r24	; 0x06
    fef8:	30 e0       	ldi	r19, 0x00	; 0
    fefa:	c9 01       	movw	r24, r18
    fefc:	df 91       	pop	r29
    fefe:	cf 91       	pop	r28
    ff00:	08 95       	ret

0000ff02 <fputc>:
    ff02:	0f 93       	push	r16
    ff04:	1f 93       	push	r17
    ff06:	cf 93       	push	r28
    ff08:	df 93       	push	r29
    ff0a:	8c 01       	movw	r16, r24
    ff0c:	eb 01       	movw	r28, r22
    ff0e:	8b 81       	ldd	r24, Y+3	; 0x03
    ff10:	81 ff       	sbrs	r24, 1
    ff12:	1b c0       	rjmp	.+54     	; 0xff4a <fputc+0x48>
    ff14:	82 ff       	sbrs	r24, 2
    ff16:	0d c0       	rjmp	.+26     	; 0xff32 <fputc+0x30>
    ff18:	2e 81       	ldd	r18, Y+6	; 0x06
    ff1a:	3f 81       	ldd	r19, Y+7	; 0x07
    ff1c:	8c 81       	ldd	r24, Y+4	; 0x04
    ff1e:	9d 81       	ldd	r25, Y+5	; 0x05
    ff20:	28 17       	cp	r18, r24
    ff22:	39 07       	cpc	r19, r25
    ff24:	64 f4       	brge	.+24     	; 0xff3e <fputc+0x3c>
    ff26:	e8 81       	ld	r30, Y
    ff28:	f9 81       	ldd	r31, Y+1	; 0x01
    ff2a:	01 93       	st	Z+, r16
    ff2c:	f9 83       	std	Y+1, r31	; 0x01
    ff2e:	e8 83       	st	Y, r30
    ff30:	06 c0       	rjmp	.+12     	; 0xff3e <fputc+0x3c>
    ff32:	e8 85       	ldd	r30, Y+8	; 0x08
    ff34:	f9 85       	ldd	r31, Y+9	; 0x09
    ff36:	80 2f       	mov	r24, r16
    ff38:	19 95       	eicall
    ff3a:	89 2b       	or	r24, r25
    ff3c:	31 f4       	brne	.+12     	; 0xff4a <fputc+0x48>
    ff3e:	8e 81       	ldd	r24, Y+6	; 0x06
    ff40:	9f 81       	ldd	r25, Y+7	; 0x07
    ff42:	01 96       	adiw	r24, 0x01	; 1
    ff44:	9f 83       	std	Y+7, r25	; 0x07
    ff46:	8e 83       	std	Y+6, r24	; 0x06
    ff48:	02 c0       	rjmp	.+4      	; 0xff4e <fputc+0x4c>
    ff4a:	0f ef       	ldi	r16, 0xFF	; 255
    ff4c:	1f ef       	ldi	r17, 0xFF	; 255
    ff4e:	c8 01       	movw	r24, r16
    ff50:	df 91       	pop	r29
    ff52:	cf 91       	pop	r28
    ff54:	1f 91       	pop	r17
    ff56:	0f 91       	pop	r16
    ff58:	08 95       	ret

0000ff5a <sprintf>:
    ff5a:	0f 93       	push	r16
    ff5c:	1f 93       	push	r17
    ff5e:	df 93       	push	r29
    ff60:	cf 93       	push	r28
    ff62:	cd b7       	in	r28, 0x3d	; 61
    ff64:	de b7       	in	r29, 0x3e	; 62
    ff66:	2e 97       	sbiw	r28, 0x0e	; 14
    ff68:	0f b6       	in	r0, 0x3f	; 63
    ff6a:	f8 94       	cli
    ff6c:	de bf       	out	0x3e, r29	; 62
    ff6e:	0f be       	out	0x3f, r0	; 63
    ff70:	cd bf       	out	0x3d, r28	; 61
    ff72:	0e 89       	ldd	r16, Y+22	; 0x16
    ff74:	1f 89       	ldd	r17, Y+23	; 0x17
    ff76:	86 e0       	ldi	r24, 0x06	; 6
    ff78:	8c 83       	std	Y+4, r24	; 0x04
    ff7a:	1a 83       	std	Y+2, r17	; 0x02
    ff7c:	09 83       	std	Y+1, r16	; 0x01
    ff7e:	8f ef       	ldi	r24, 0xFF	; 255
    ff80:	9f e7       	ldi	r25, 0x7F	; 127
    ff82:	9e 83       	std	Y+6, r25	; 0x06
    ff84:	8d 83       	std	Y+5, r24	; 0x05
    ff86:	9e 01       	movw	r18, r28
    ff88:	26 5e       	subi	r18, 0xE6	; 230
    ff8a:	3f 4f       	sbci	r19, 0xFF	; 255
    ff8c:	ce 01       	movw	r24, r28
    ff8e:	01 96       	adiw	r24, 0x01	; 1
    ff90:	68 8d       	ldd	r22, Y+24	; 0x18
    ff92:	79 8d       	ldd	r23, Y+25	; 0x19
    ff94:	a9 01       	movw	r20, r18
    ff96:	0e 94 d4 74 	call	0xe9a8	; 0xe9a8 <vfprintf>
    ff9a:	2f 81       	ldd	r18, Y+7	; 0x07
    ff9c:	38 85       	ldd	r19, Y+8	; 0x08
    ff9e:	02 0f       	add	r16, r18
    ffa0:	13 1f       	adc	r17, r19
    ffa2:	f8 01       	movw	r30, r16
    ffa4:	10 82       	st	Z, r1
    ffa6:	2e 96       	adiw	r28, 0x0e	; 14
    ffa8:	0f b6       	in	r0, 0x3f	; 63
    ffaa:	f8 94       	cli
    ffac:	de bf       	out	0x3e, r29	; 62
    ffae:	0f be       	out	0x3f, r0	; 63
    ffb0:	cd bf       	out	0x3d, r28	; 61
    ffb2:	cf 91       	pop	r28
    ffb4:	df 91       	pop	r29
    ffb6:	1f 91       	pop	r17
    ffb8:	0f 91       	pop	r16
    ffba:	08 95       	ret

0000ffbc <sprintf_P>:
    ffbc:	0f 93       	push	r16
    ffbe:	1f 93       	push	r17
    ffc0:	df 93       	push	r29
    ffc2:	cf 93       	push	r28
    ffc4:	cd b7       	in	r28, 0x3d	; 61
    ffc6:	de b7       	in	r29, 0x3e	; 62
    ffc8:	2e 97       	sbiw	r28, 0x0e	; 14
    ffca:	0f b6       	in	r0, 0x3f	; 63
    ffcc:	f8 94       	cli
    ffce:	de bf       	out	0x3e, r29	; 62
    ffd0:	0f be       	out	0x3f, r0	; 63
    ffd2:	cd bf       	out	0x3d, r28	; 61
    ffd4:	0e 89       	ldd	r16, Y+22	; 0x16
    ffd6:	1f 89       	ldd	r17, Y+23	; 0x17
    ffd8:	8e e0       	ldi	r24, 0x0E	; 14
    ffda:	8c 83       	std	Y+4, r24	; 0x04
    ffdc:	1a 83       	std	Y+2, r17	; 0x02
    ffde:	09 83       	std	Y+1, r16	; 0x01
    ffe0:	8f ef       	ldi	r24, 0xFF	; 255
    ffe2:	9f e7       	ldi	r25, 0x7F	; 127
    ffe4:	9e 83       	std	Y+6, r25	; 0x06
    ffe6:	8d 83       	std	Y+5, r24	; 0x05
    ffe8:	9e 01       	movw	r18, r28
    ffea:	26 5e       	subi	r18, 0xE6	; 230
    ffec:	3f 4f       	sbci	r19, 0xFF	; 255
    ffee:	ce 01       	movw	r24, r28
    fff0:	01 96       	adiw	r24, 0x01	; 1
    fff2:	68 8d       	ldd	r22, Y+24	; 0x18
    fff4:	79 8d       	ldd	r23, Y+25	; 0x19
    fff6:	a9 01       	movw	r20, r18
    fff8:	0e 94 d4 74 	call	0xe9a8	; 0xe9a8 <vfprintf>
    fffc:	2f 81       	ldd	r18, Y+7	; 0x07
    fffe:	38 85       	ldd	r19, Y+8	; 0x08
   10000:	02 0f       	add	r16, r18
   10002:	13 1f       	adc	r17, r19
   10004:	f8 01       	movw	r30, r16
   10006:	10 82       	st	Z, r1
   10008:	2e 96       	adiw	r28, 0x0e	; 14
   1000a:	0f b6       	in	r0, 0x3f	; 63
   1000c:	f8 94       	cli
   1000e:	de bf       	out	0x3e, r29	; 62
   10010:	0f be       	out	0x3f, r0	; 63
   10012:	cd bf       	out	0x3d, r28	; 61
   10014:	cf 91       	pop	r28
   10016:	df 91       	pop	r29
   10018:	1f 91       	pop	r17
   1001a:	0f 91       	pop	r16
   1001c:	08 95       	ret

0001001e <sscanf>:
   1001e:	df 93       	push	r29
   10020:	cf 93       	push	r28
   10022:	cd b7       	in	r28, 0x3d	; 61
   10024:	de b7       	in	r29, 0x3e	; 62
   10026:	2e 97       	sbiw	r28, 0x0e	; 14
   10028:	0f b6       	in	r0, 0x3f	; 63
   1002a:	f8 94       	cli
   1002c:	de bf       	out	0x3e, r29	; 62
   1002e:	0f be       	out	0x3f, r0	; 63
   10030:	cd bf       	out	0x3d, r28	; 61
   10032:	85 e0       	ldi	r24, 0x05	; 5
   10034:	8c 83       	std	Y+4, r24	; 0x04
   10036:	8c 89       	ldd	r24, Y+20	; 0x14
   10038:	9d 89       	ldd	r25, Y+21	; 0x15
   1003a:	9a 83       	std	Y+2, r25	; 0x02
   1003c:	89 83       	std	Y+1, r24	; 0x01
   1003e:	9e 01       	movw	r18, r28
   10040:	28 5e       	subi	r18, 0xE8	; 232
   10042:	3f 4f       	sbci	r19, 0xFF	; 255
   10044:	ce 01       	movw	r24, r28
   10046:	01 96       	adiw	r24, 0x01	; 1
   10048:	6e 89       	ldd	r22, Y+22	; 0x16
   1004a:	7f 89       	ldd	r23, Y+23	; 0x17
   1004c:	a9 01       	movw	r20, r18
   1004e:	0e 94 8b 7b 	call	0xf716	; 0xf716 <vfscanf>
   10052:	2e 96       	adiw	r28, 0x0e	; 14
   10054:	0f b6       	in	r0, 0x3f	; 63
   10056:	f8 94       	cli
   10058:	de bf       	out	0x3e, r29	; 62
   1005a:	0f be       	out	0x3f, r0	; 63
   1005c:	cd bf       	out	0x3d, r28	; 61
   1005e:	cf 91       	pop	r28
   10060:	df 91       	pop	r29
   10062:	08 95       	ret

00010064 <sscanf_P>:
   10064:	df 93       	push	r29
   10066:	cf 93       	push	r28
   10068:	cd b7       	in	r28, 0x3d	; 61
   1006a:	de b7       	in	r29, 0x3e	; 62
   1006c:	2e 97       	sbiw	r28, 0x0e	; 14
   1006e:	0f b6       	in	r0, 0x3f	; 63
   10070:	f8 94       	cli
   10072:	de bf       	out	0x3e, r29	; 62
   10074:	0f be       	out	0x3f, r0	; 63
   10076:	cd bf       	out	0x3d, r28	; 61
   10078:	8d e0       	ldi	r24, 0x0D	; 13
   1007a:	8c 83       	std	Y+4, r24	; 0x04
   1007c:	8c 89       	ldd	r24, Y+20	; 0x14
   1007e:	9d 89       	ldd	r25, Y+21	; 0x15
   10080:	9a 83       	std	Y+2, r25	; 0x02
   10082:	89 83       	std	Y+1, r24	; 0x01
   10084:	9e 01       	movw	r18, r28
   10086:	28 5e       	subi	r18, 0xE8	; 232
   10088:	3f 4f       	sbci	r19, 0xFF	; 255
   1008a:	ce 01       	movw	r24, r28
   1008c:	01 96       	adiw	r24, 0x01	; 1
   1008e:	6e 89       	ldd	r22, Y+22	; 0x16
   10090:	7f 89       	ldd	r23, Y+23	; 0x17
   10092:	a9 01       	movw	r20, r18
   10094:	0e 94 8b 7b 	call	0xf716	; 0xf716 <vfscanf>
   10098:	2e 96       	adiw	r28, 0x0e	; 14
   1009a:	0f b6       	in	r0, 0x3f	; 63
   1009c:	f8 94       	cli
   1009e:	de bf       	out	0x3e, r29	; 62
   100a0:	0f be       	out	0x3f, r0	; 63
   100a2:	cd bf       	out	0x3d, r28	; 61
   100a4:	cf 91       	pop	r28
   100a6:	df 91       	pop	r29
   100a8:	08 95       	ret

000100aa <ungetc>:
   100aa:	9c 01       	movw	r18, r24
   100ac:	fb 01       	movw	r30, r22
   100ae:	83 81       	ldd	r24, Z+3	; 0x03
   100b0:	80 ff       	sbrs	r24, 0
   100b2:	11 c0       	rjmp	.+34     	; 0x100d6 <ungetc+0x2c>
   100b4:	86 fd       	sbrc	r24, 6
   100b6:	0f c0       	rjmp	.+30     	; 0x100d6 <ungetc+0x2c>
   100b8:	9f ef       	ldi	r25, 0xFF	; 255
   100ba:	2f 3f       	cpi	r18, 0xFF	; 255
   100bc:	39 07       	cpc	r19, r25
   100be:	59 f0       	breq	.+22     	; 0x100d6 <ungetc+0x2c>
   100c0:	22 83       	std	Z+2, r18	; 0x02
   100c2:	80 64       	ori	r24, 0x40	; 64
   100c4:	8f 7d       	andi	r24, 0xDF	; 223
   100c6:	83 83       	std	Z+3, r24	; 0x03
   100c8:	86 81       	ldd	r24, Z+6	; 0x06
   100ca:	97 81       	ldd	r25, Z+7	; 0x07
   100cc:	01 97       	sbiw	r24, 0x01	; 1
   100ce:	97 83       	std	Z+7, r25	; 0x07
   100d0:	86 83       	std	Z+6, r24	; 0x06
   100d2:	30 e0       	ldi	r19, 0x00	; 0
   100d4:	02 c0       	rjmp	.+4      	; 0x100da <ungetc+0x30>
   100d6:	2f ef       	ldi	r18, 0xFF	; 255
   100d8:	3f ef       	ldi	r19, 0xFF	; 255
   100da:	c9 01       	movw	r24, r18
   100dc:	08 95       	ret

000100de <__ultoa_invert>:
   100de:	fa 01       	movw	r30, r20
   100e0:	aa 27       	eor	r26, r26
   100e2:	28 30       	cpi	r18, 0x08	; 8
   100e4:	51 f1       	breq	.+84     	; 0x1013a <__ultoa_invert+0x5c>
   100e6:	20 31       	cpi	r18, 0x10	; 16
   100e8:	81 f1       	breq	.+96     	; 0x1014a <__ultoa_invert+0x6c>
   100ea:	e8 94       	clt
   100ec:	6f 93       	push	r22
   100ee:	6e 7f       	andi	r22, 0xFE	; 254
   100f0:	6e 5f       	subi	r22, 0xFE	; 254
   100f2:	7f 4f       	sbci	r23, 0xFF	; 255
   100f4:	8f 4f       	sbci	r24, 0xFF	; 255
   100f6:	9f 4f       	sbci	r25, 0xFF	; 255
   100f8:	af 4f       	sbci	r26, 0xFF	; 255
   100fa:	b1 e0       	ldi	r27, 0x01	; 1
   100fc:	3e d0       	rcall	.+124    	; 0x1017a <__ultoa_invert+0x9c>
   100fe:	b4 e0       	ldi	r27, 0x04	; 4
   10100:	3c d0       	rcall	.+120    	; 0x1017a <__ultoa_invert+0x9c>
   10102:	67 0f       	add	r22, r23
   10104:	78 1f       	adc	r23, r24
   10106:	89 1f       	adc	r24, r25
   10108:	9a 1f       	adc	r25, r26
   1010a:	a1 1d       	adc	r26, r1
   1010c:	68 0f       	add	r22, r24
   1010e:	79 1f       	adc	r23, r25
   10110:	8a 1f       	adc	r24, r26
   10112:	91 1d       	adc	r25, r1
   10114:	a1 1d       	adc	r26, r1
   10116:	6a 0f       	add	r22, r26
   10118:	71 1d       	adc	r23, r1
   1011a:	81 1d       	adc	r24, r1
   1011c:	91 1d       	adc	r25, r1
   1011e:	a1 1d       	adc	r26, r1
   10120:	20 d0       	rcall	.+64     	; 0x10162 <__ultoa_invert+0x84>
   10122:	09 f4       	brne	.+2      	; 0x10126 <__ultoa_invert+0x48>
   10124:	68 94       	set
   10126:	3f 91       	pop	r19
   10128:	2a e0       	ldi	r18, 0x0A	; 10
   1012a:	26 9f       	mul	r18, r22
   1012c:	11 24       	eor	r1, r1
   1012e:	30 19       	sub	r19, r0
   10130:	30 5d       	subi	r19, 0xD0	; 208
   10132:	31 93       	st	Z+, r19
   10134:	de f6       	brtc	.-74     	; 0x100ec <__ultoa_invert+0xe>
   10136:	cf 01       	movw	r24, r30
   10138:	08 95       	ret
   1013a:	46 2f       	mov	r20, r22
   1013c:	47 70       	andi	r20, 0x07	; 7
   1013e:	40 5d       	subi	r20, 0xD0	; 208
   10140:	41 93       	st	Z+, r20
   10142:	b3 e0       	ldi	r27, 0x03	; 3
   10144:	0f d0       	rcall	.+30     	; 0x10164 <__ultoa_invert+0x86>
   10146:	c9 f7       	brne	.-14     	; 0x1013a <__ultoa_invert+0x5c>
   10148:	f6 cf       	rjmp	.-20     	; 0x10136 <__ultoa_invert+0x58>
   1014a:	46 2f       	mov	r20, r22
   1014c:	4f 70       	andi	r20, 0x0F	; 15
   1014e:	40 5d       	subi	r20, 0xD0	; 208
   10150:	4a 33       	cpi	r20, 0x3A	; 58
   10152:	18 f0       	brcs	.+6      	; 0x1015a <__ultoa_invert+0x7c>
   10154:	49 5d       	subi	r20, 0xD9	; 217
   10156:	31 fd       	sbrc	r19, 1
   10158:	40 52       	subi	r20, 0x20	; 32
   1015a:	41 93       	st	Z+, r20
   1015c:	02 d0       	rcall	.+4      	; 0x10162 <__ultoa_invert+0x84>
   1015e:	a9 f7       	brne	.-22     	; 0x1014a <__ultoa_invert+0x6c>
   10160:	ea cf       	rjmp	.-44     	; 0x10136 <__ultoa_invert+0x58>
   10162:	b4 e0       	ldi	r27, 0x04	; 4
   10164:	a6 95       	lsr	r26
   10166:	97 95       	ror	r25
   10168:	87 95       	ror	r24
   1016a:	77 95       	ror	r23
   1016c:	67 95       	ror	r22
   1016e:	ba 95       	dec	r27
   10170:	c9 f7       	brne	.-14     	; 0x10164 <__ultoa_invert+0x86>
   10172:	00 97       	sbiw	r24, 0x00	; 0
   10174:	61 05       	cpc	r22, r1
   10176:	71 05       	cpc	r23, r1
   10178:	08 95       	ret
   1017a:	9b 01       	movw	r18, r22
   1017c:	ac 01       	movw	r20, r24
   1017e:	0a 2e       	mov	r0, r26
   10180:	06 94       	lsr	r0
   10182:	57 95       	ror	r21
   10184:	47 95       	ror	r20
   10186:	37 95       	ror	r19
   10188:	27 95       	ror	r18
   1018a:	ba 95       	dec	r27
   1018c:	c9 f7       	brne	.-14     	; 0x10180 <__ultoa_invert+0xa2>
   1018e:	62 0f       	add	r22, r18
   10190:	73 1f       	adc	r23, r19
   10192:	84 1f       	adc	r24, r20
   10194:	95 1f       	adc	r25, r21
   10196:	a0 1d       	adc	r26, r0
   10198:	08 95       	ret

0001019a <__subsf3>:
   1019a:	50 58       	subi	r21, 0x80	; 128

0001019c <__addsf3>:
   1019c:	bb 27       	eor	r27, r27
   1019e:	aa 27       	eor	r26, r26
   101a0:	0e d0       	rcall	.+28     	; 0x101be <__addsf3x>
   101a2:	af cc       	rjmp	.-1698   	; 0xfb02 <__fp_round>
   101a4:	a0 dc       	rcall	.-1728   	; 0xfae6 <__fp_pscA>
   101a6:	30 f0       	brcs	.+12     	; 0x101b4 <__addsf3+0x18>
   101a8:	a5 dc       	rcall	.-1718   	; 0xfaf4 <__fp_pscB>
   101aa:	20 f0       	brcs	.+8      	; 0x101b4 <__addsf3+0x18>
   101ac:	31 f4       	brne	.+12     	; 0x101ba <__addsf3+0x1e>
   101ae:	9f 3f       	cpi	r25, 0xFF	; 255
   101b0:	11 f4       	brne	.+4      	; 0x101b6 <__addsf3+0x1a>
   101b2:	1e f4       	brtc	.+6      	; 0x101ba <__addsf3+0x1e>
   101b4:	95 cc       	rjmp	.-1750   	; 0xfae0 <__fp_nan>
   101b6:	0e f4       	brtc	.+2      	; 0x101ba <__addsf3+0x1e>
   101b8:	e0 95       	com	r30
   101ba:	e7 fb       	bst	r30, 7
   101bc:	8b cc       	rjmp	.-1770   	; 0xfad4 <__fp_inf>

000101be <__addsf3x>:
   101be:	e9 2f       	mov	r30, r25
   101c0:	b1 dc       	rcall	.-1694   	; 0xfb24 <__fp_split3>
   101c2:	80 f3       	brcs	.-32     	; 0x101a4 <__addsf3+0x8>
   101c4:	ba 17       	cp	r27, r26
   101c6:	62 07       	cpc	r22, r18
   101c8:	73 07       	cpc	r23, r19
   101ca:	84 07       	cpc	r24, r20
   101cc:	95 07       	cpc	r25, r21
   101ce:	18 f0       	brcs	.+6      	; 0x101d6 <__addsf3x+0x18>
   101d0:	71 f4       	brne	.+28     	; 0x101ee <__addsf3x+0x30>
   101d2:	9e f5       	brtc	.+102    	; 0x1023a <__addsf3x+0x7c>
   101d4:	c9 cc       	rjmp	.-1646   	; 0xfb68 <__fp_zero>
   101d6:	0e f4       	brtc	.+2      	; 0x101da <__addsf3x+0x1c>
   101d8:	e0 95       	com	r30
   101da:	0b 2e       	mov	r0, r27
   101dc:	ba 2f       	mov	r27, r26
   101de:	a0 2d       	mov	r26, r0
   101e0:	0b 01       	movw	r0, r22
   101e2:	b9 01       	movw	r22, r18
   101e4:	90 01       	movw	r18, r0
   101e6:	0c 01       	movw	r0, r24
   101e8:	ca 01       	movw	r24, r20
   101ea:	a0 01       	movw	r20, r0
   101ec:	11 24       	eor	r1, r1
   101ee:	ff 27       	eor	r31, r31
   101f0:	59 1b       	sub	r21, r25
   101f2:	99 f0       	breq	.+38     	; 0x1021a <__addsf3x+0x5c>
   101f4:	59 3f       	cpi	r21, 0xF9	; 249
   101f6:	50 f4       	brcc	.+20     	; 0x1020c <__addsf3x+0x4e>
   101f8:	50 3e       	cpi	r21, 0xE0	; 224
   101fa:	68 f1       	brcs	.+90     	; 0x10256 <__addsf3x+0x98>
   101fc:	1a 16       	cp	r1, r26
   101fe:	f0 40       	sbci	r31, 0x00	; 0
   10200:	a2 2f       	mov	r26, r18
   10202:	23 2f       	mov	r18, r19
   10204:	34 2f       	mov	r19, r20
   10206:	44 27       	eor	r20, r20
   10208:	58 5f       	subi	r21, 0xF8	; 248
   1020a:	f3 cf       	rjmp	.-26     	; 0x101f2 <__addsf3x+0x34>
   1020c:	46 95       	lsr	r20
   1020e:	37 95       	ror	r19
   10210:	27 95       	ror	r18
   10212:	a7 95       	ror	r26
   10214:	f0 40       	sbci	r31, 0x00	; 0
   10216:	53 95       	inc	r21
   10218:	c9 f7       	brne	.-14     	; 0x1020c <__addsf3x+0x4e>
   1021a:	7e f4       	brtc	.+30     	; 0x1023a <__addsf3x+0x7c>
   1021c:	1f 16       	cp	r1, r31
   1021e:	ba 0b       	sbc	r27, r26
   10220:	62 0b       	sbc	r22, r18
   10222:	73 0b       	sbc	r23, r19
   10224:	84 0b       	sbc	r24, r20
   10226:	ba f0       	brmi	.+46     	; 0x10256 <__addsf3x+0x98>
   10228:	91 50       	subi	r25, 0x01	; 1
   1022a:	a1 f0       	breq	.+40     	; 0x10254 <__addsf3x+0x96>
   1022c:	ff 0f       	add	r31, r31
   1022e:	bb 1f       	adc	r27, r27
   10230:	66 1f       	adc	r22, r22
   10232:	77 1f       	adc	r23, r23
   10234:	88 1f       	adc	r24, r24
   10236:	c2 f7       	brpl	.-16     	; 0x10228 <__addsf3x+0x6a>
   10238:	0e c0       	rjmp	.+28     	; 0x10256 <__addsf3x+0x98>
   1023a:	ba 0f       	add	r27, r26
   1023c:	62 1f       	adc	r22, r18
   1023e:	73 1f       	adc	r23, r19
   10240:	84 1f       	adc	r24, r20
   10242:	48 f4       	brcc	.+18     	; 0x10256 <__addsf3x+0x98>
   10244:	87 95       	ror	r24
   10246:	77 95       	ror	r23
   10248:	67 95       	ror	r22
   1024a:	b7 95       	ror	r27
   1024c:	f7 95       	ror	r31
   1024e:	9e 3f       	cpi	r25, 0xFE	; 254
   10250:	08 f0       	brcs	.+2      	; 0x10254 <__addsf3x+0x96>
   10252:	b3 cf       	rjmp	.-154    	; 0x101ba <__addsf3+0x1e>
   10254:	93 95       	inc	r25
   10256:	88 0f       	add	r24, r24
   10258:	08 f0       	brcs	.+2      	; 0x1025c <__addsf3x+0x9e>
   1025a:	99 27       	eor	r25, r25
   1025c:	ee 0f       	add	r30, r30
   1025e:	97 95       	ror	r25
   10260:	87 95       	ror	r24
   10262:	08 95       	ret

00010264 <__divsf3>:
   10264:	0c d0       	rcall	.+24     	; 0x1027e <__divsf3x>
   10266:	4d cc       	rjmp	.-1894   	; 0xfb02 <__fp_round>
   10268:	45 dc       	rcall	.-1910   	; 0xfaf4 <__fp_pscB>
   1026a:	40 f0       	brcs	.+16     	; 0x1027c <__divsf3+0x18>
   1026c:	3c dc       	rcall	.-1928   	; 0xfae6 <__fp_pscA>
   1026e:	30 f0       	brcs	.+12     	; 0x1027c <__divsf3+0x18>
   10270:	21 f4       	brne	.+8      	; 0x1027a <__divsf3+0x16>
   10272:	5f 3f       	cpi	r21, 0xFF	; 255
   10274:	19 f0       	breq	.+6      	; 0x1027c <__divsf3+0x18>
   10276:	2e cc       	rjmp	.-1956   	; 0xfad4 <__fp_inf>
   10278:	51 11       	cpse	r21, r1
   1027a:	77 cc       	rjmp	.-1810   	; 0xfb6a <__fp_szero>
   1027c:	31 cc       	rjmp	.-1950   	; 0xfae0 <__fp_nan>

0001027e <__divsf3x>:
   1027e:	52 dc       	rcall	.-1884   	; 0xfb24 <__fp_split3>
   10280:	98 f3       	brcs	.-26     	; 0x10268 <__divsf3+0x4>

00010282 <__divsf3_pse>:
   10282:	99 23       	and	r25, r25
   10284:	c9 f3       	breq	.-14     	; 0x10278 <__divsf3+0x14>
   10286:	55 23       	and	r21, r21
   10288:	b1 f3       	breq	.-20     	; 0x10276 <__divsf3+0x12>
   1028a:	95 1b       	sub	r25, r21
   1028c:	55 0b       	sbc	r21, r21
   1028e:	bb 27       	eor	r27, r27
   10290:	aa 27       	eor	r26, r26
   10292:	62 17       	cp	r22, r18
   10294:	73 07       	cpc	r23, r19
   10296:	84 07       	cpc	r24, r20
   10298:	38 f0       	brcs	.+14     	; 0x102a8 <__divsf3_pse+0x26>
   1029a:	9f 5f       	subi	r25, 0xFF	; 255
   1029c:	5f 4f       	sbci	r21, 0xFF	; 255
   1029e:	22 0f       	add	r18, r18
   102a0:	33 1f       	adc	r19, r19
   102a2:	44 1f       	adc	r20, r20
   102a4:	aa 1f       	adc	r26, r26
   102a6:	a9 f3       	breq	.-22     	; 0x10292 <__divsf3_pse+0x10>
   102a8:	33 d0       	rcall	.+102    	; 0x10310 <__divsf3_pse+0x8e>
   102aa:	0e 2e       	mov	r0, r30
   102ac:	3a f0       	brmi	.+14     	; 0x102bc <__divsf3_pse+0x3a>
   102ae:	e0 e8       	ldi	r30, 0x80	; 128
   102b0:	30 d0       	rcall	.+96     	; 0x10312 <__divsf3_pse+0x90>
   102b2:	91 50       	subi	r25, 0x01	; 1
   102b4:	50 40       	sbci	r21, 0x00	; 0
   102b6:	e6 95       	lsr	r30
   102b8:	00 1c       	adc	r0, r0
   102ba:	ca f7       	brpl	.-14     	; 0x102ae <__divsf3_pse+0x2c>
   102bc:	29 d0       	rcall	.+82     	; 0x10310 <__divsf3_pse+0x8e>
   102be:	fe 2f       	mov	r31, r30
   102c0:	27 d0       	rcall	.+78     	; 0x10310 <__divsf3_pse+0x8e>
   102c2:	66 0f       	add	r22, r22
   102c4:	77 1f       	adc	r23, r23
   102c6:	88 1f       	adc	r24, r24
   102c8:	bb 1f       	adc	r27, r27
   102ca:	26 17       	cp	r18, r22
   102cc:	37 07       	cpc	r19, r23
   102ce:	48 07       	cpc	r20, r24
   102d0:	ab 07       	cpc	r26, r27
   102d2:	b0 e8       	ldi	r27, 0x80	; 128
   102d4:	09 f0       	breq	.+2      	; 0x102d8 <__divsf3_pse+0x56>
   102d6:	bb 0b       	sbc	r27, r27
   102d8:	80 2d       	mov	r24, r0
   102da:	bf 01       	movw	r22, r30
   102dc:	ff 27       	eor	r31, r31
   102de:	93 58       	subi	r25, 0x83	; 131
   102e0:	5f 4f       	sbci	r21, 0xFF	; 255
   102e2:	2a f0       	brmi	.+10     	; 0x102ee <__divsf3_pse+0x6c>
   102e4:	9e 3f       	cpi	r25, 0xFE	; 254
   102e6:	51 05       	cpc	r21, r1
   102e8:	68 f0       	brcs	.+26     	; 0x10304 <__divsf3_pse+0x82>
   102ea:	f4 cb       	rjmp	.-2072   	; 0xfad4 <__fp_inf>
   102ec:	3e cc       	rjmp	.-1924   	; 0xfb6a <__fp_szero>
   102ee:	5f 3f       	cpi	r21, 0xFF	; 255
   102f0:	ec f3       	brlt	.-6      	; 0x102ec <__divsf3_pse+0x6a>
   102f2:	98 3e       	cpi	r25, 0xE8	; 232
   102f4:	dc f3       	brlt	.-10     	; 0x102ec <__divsf3_pse+0x6a>
   102f6:	86 95       	lsr	r24
   102f8:	77 95       	ror	r23
   102fa:	67 95       	ror	r22
   102fc:	b7 95       	ror	r27
   102fe:	f7 95       	ror	r31
   10300:	9f 5f       	subi	r25, 0xFF	; 255
   10302:	c9 f7       	brne	.-14     	; 0x102f6 <__divsf3_pse+0x74>
   10304:	88 0f       	add	r24, r24
   10306:	91 1d       	adc	r25, r1
   10308:	96 95       	lsr	r25
   1030a:	87 95       	ror	r24
   1030c:	97 f9       	bld	r25, 7
   1030e:	08 95       	ret
   10310:	e1 e0       	ldi	r30, 0x01	; 1
   10312:	66 0f       	add	r22, r22
   10314:	77 1f       	adc	r23, r23
   10316:	88 1f       	adc	r24, r24
   10318:	bb 1f       	adc	r27, r27
   1031a:	62 17       	cp	r22, r18
   1031c:	73 07       	cpc	r23, r19
   1031e:	84 07       	cpc	r24, r20
   10320:	ba 07       	cpc	r27, r26
   10322:	20 f0       	brcs	.+8      	; 0x1032c <__divsf3_pse+0xaa>
   10324:	62 1b       	sub	r22, r18
   10326:	73 0b       	sbc	r23, r19
   10328:	84 0b       	sbc	r24, r20
   1032a:	ba 0b       	sbc	r27, r26
   1032c:	ee 1f       	adc	r30, r30
   1032e:	88 f7       	brcc	.-30     	; 0x10312 <__divsf3_pse+0x90>
   10330:	e0 95       	com	r30
   10332:	08 95       	ret

00010334 <__fixsfsi>:
   10334:	04 d0       	rcall	.+8      	; 0x1033e <__fixunssfsi>
   10336:	68 94       	set
   10338:	b1 11       	cpse	r27, r1
   1033a:	17 cc       	rjmp	.-2002   	; 0xfb6a <__fp_szero>
   1033c:	08 95       	ret

0001033e <__fixunssfsi>:
   1033e:	fa db       	rcall	.-2060   	; 0xfb34 <__fp_splitA>
   10340:	88 f0       	brcs	.+34     	; 0x10364 <__fixunssfsi+0x26>
   10342:	9f 57       	subi	r25, 0x7F	; 127
   10344:	90 f0       	brcs	.+36     	; 0x1036a <__fixunssfsi+0x2c>
   10346:	b9 2f       	mov	r27, r25
   10348:	99 27       	eor	r25, r25
   1034a:	b7 51       	subi	r27, 0x17	; 23
   1034c:	a0 f0       	brcs	.+40     	; 0x10376 <__fixunssfsi+0x38>
   1034e:	d1 f0       	breq	.+52     	; 0x10384 <__fixunssfsi+0x46>
   10350:	66 0f       	add	r22, r22
   10352:	77 1f       	adc	r23, r23
   10354:	88 1f       	adc	r24, r24
   10356:	99 1f       	adc	r25, r25
   10358:	1a f0       	brmi	.+6      	; 0x10360 <__fixunssfsi+0x22>
   1035a:	ba 95       	dec	r27
   1035c:	c9 f7       	brne	.-14     	; 0x10350 <__fixunssfsi+0x12>
   1035e:	12 c0       	rjmp	.+36     	; 0x10384 <__fixunssfsi+0x46>
   10360:	b1 30       	cpi	r27, 0x01	; 1
   10362:	81 f0       	breq	.+32     	; 0x10384 <__fixunssfsi+0x46>
   10364:	01 dc       	rcall	.-2046   	; 0xfb68 <__fp_zero>
   10366:	b1 e0       	ldi	r27, 0x01	; 1
   10368:	08 95       	ret
   1036a:	fe cb       	rjmp	.-2052   	; 0xfb68 <__fp_zero>
   1036c:	67 2f       	mov	r22, r23
   1036e:	78 2f       	mov	r23, r24
   10370:	88 27       	eor	r24, r24
   10372:	b8 5f       	subi	r27, 0xF8	; 248
   10374:	39 f0       	breq	.+14     	; 0x10384 <__fixunssfsi+0x46>
   10376:	b9 3f       	cpi	r27, 0xF9	; 249
   10378:	cc f3       	brlt	.-14     	; 0x1036c <__fixunssfsi+0x2e>
   1037a:	86 95       	lsr	r24
   1037c:	77 95       	ror	r23
   1037e:	67 95       	ror	r22
   10380:	b3 95       	inc	r27
   10382:	d9 f7       	brne	.-10     	; 0x1037a <__fixunssfsi+0x3c>
   10384:	3e f4       	brtc	.+14     	; 0x10394 <__fixunssfsi+0x56>
   10386:	90 95       	com	r25
   10388:	80 95       	com	r24
   1038a:	70 95       	com	r23
   1038c:	61 95       	neg	r22
   1038e:	7f 4f       	sbci	r23, 0xFF	; 255
   10390:	8f 4f       	sbci	r24, 0xFF	; 255
   10392:	9f 4f       	sbci	r25, 0xFF	; 255
   10394:	08 95       	ret

00010396 <__eerd_block_m2560>:
   10396:	dc 01       	movw	r26, r24
   10398:	cb 01       	movw	r24, r22

0001039a <__eerd_blraw_m2560>:
   1039a:	fc 01       	movw	r30, r24
   1039c:	f9 99       	sbic	0x1f, 1	; 31
   1039e:	fe cf       	rjmp	.-4      	; 0x1039c <__eerd_blraw_m2560+0x2>
   103a0:	06 c0       	rjmp	.+12     	; 0x103ae <__eerd_blraw_m2560+0x14>
   103a2:	f2 bd       	out	0x22, r31	; 34
   103a4:	e1 bd       	out	0x21, r30	; 33
   103a6:	f8 9a       	sbi	0x1f, 0	; 31
   103a8:	31 96       	adiw	r30, 0x01	; 1
   103aa:	00 b4       	in	r0, 0x20	; 32
   103ac:	0d 92       	st	X+, r0
   103ae:	41 50       	subi	r20, 0x01	; 1
   103b0:	50 40       	sbci	r21, 0x00	; 0
   103b2:	b8 f7       	brcc	.-18     	; 0x103a2 <__eerd_blraw_m2560+0x8>
   103b4:	08 95       	ret

000103b6 <__eerd_byte_m2560>:
   103b6:	f9 99       	sbic	0x1f, 1	; 31
   103b8:	fe cf       	rjmp	.-4      	; 0x103b6 <__eerd_byte_m2560>
   103ba:	92 bd       	out	0x22, r25	; 34
   103bc:	81 bd       	out	0x21, r24	; 33
   103be:	f8 9a       	sbi	0x1f, 0	; 31
   103c0:	99 27       	eor	r25, r25
   103c2:	80 b5       	in	r24, 0x20	; 32
   103c4:	08 95       	ret

000103c6 <__eerd_dword_m2560>:
   103c6:	a6 e1       	ldi	r26, 0x16	; 22
   103c8:	b0 e0       	ldi	r27, 0x00	; 0
   103ca:	44 e0       	ldi	r20, 0x04	; 4
   103cc:	50 e0       	ldi	r21, 0x00	; 0
   103ce:	0c 94 cd 81 	jmp	0x1039a	; 0x1039a <__eerd_blraw_m2560>

000103d2 <__eerd_word_m2560>:
   103d2:	a8 e1       	ldi	r26, 0x18	; 24
   103d4:	b0 e0       	ldi	r27, 0x00	; 0
   103d6:	42 e0       	ldi	r20, 0x02	; 2
   103d8:	50 e0       	ldi	r21, 0x00	; 0
   103da:	0c 94 cd 81 	jmp	0x1039a	; 0x1039a <__eerd_blraw_m2560>

000103de <__eewr_block_m2560>:
   103de:	dc 01       	movw	r26, r24
   103e0:	cb 01       	movw	r24, r22
   103e2:	03 c0       	rjmp	.+6      	; 0x103ea <__eewr_block_m2560+0xc>
   103e4:	2d 91       	ld	r18, X+
   103e6:	0e 94 fa 81 	call	0x103f4	; 0x103f4 <__eewr_r18_m2560>
   103ea:	41 50       	subi	r20, 0x01	; 1
   103ec:	50 40       	sbci	r21, 0x00	; 0
   103ee:	d0 f7       	brcc	.-12     	; 0x103e4 <__eewr_block_m2560+0x6>
   103f0:	08 95       	ret

000103f2 <__eewr_byte_m2560>:
   103f2:	26 2f       	mov	r18, r22

000103f4 <__eewr_r18_m2560>:
   103f4:	f9 99       	sbic	0x1f, 1	; 31
   103f6:	fe cf       	rjmp	.-4      	; 0x103f4 <__eewr_r18_m2560>
   103f8:	1f ba       	out	0x1f, r1	; 31
   103fa:	92 bd       	out	0x22, r25	; 34
   103fc:	81 bd       	out	0x21, r24	; 33
   103fe:	20 bd       	out	0x20, r18	; 32
   10400:	0f b6       	in	r0, 0x3f	; 63
   10402:	f8 94       	cli
   10404:	fa 9a       	sbi	0x1f, 2	; 31
   10406:	f9 9a       	sbi	0x1f, 1	; 31
   10408:	0f be       	out	0x3f, r0	; 63
   1040a:	01 96       	adiw	r24, 0x01	; 1
   1040c:	08 95       	ret

0001040e <__eewr_dword_m2560>:
   1040e:	24 2f       	mov	r18, r20
   10410:	0e 94 fa 81 	call	0x103f4	; 0x103f4 <__eewr_r18_m2560>
   10414:	25 2f       	mov	r18, r21
   10416:	0e 94 fa 81 	call	0x103f4	; 0x103f4 <__eewr_r18_m2560>
   1041a:	0c 94 0f 82 	jmp	0x1041e	; 0x1041e <__eewr_word_m2560>

0001041e <__eewr_word_m2560>:
   1041e:	0e 94 f9 81 	call	0x103f2	; 0x103f2 <__eewr_byte_m2560>
   10422:	27 2f       	mov	r18, r23
   10424:	0c 94 fa 81 	jmp	0x103f4	; 0x103f4 <__eewr_r18_m2560>

00010428 <__ctype_isfalse>:
   10428:	99 27       	eor	r25, r25
   1042a:	88 27       	eor	r24, r24

0001042c <__ctype_istrue>:
   1042c:	08 95       	ret

0001042e <__mulsi3>:
   1042e:	62 9f       	mul	r22, r18
   10430:	d0 01       	movw	r26, r0
   10432:	73 9f       	mul	r23, r19
   10434:	f0 01       	movw	r30, r0
   10436:	82 9f       	mul	r24, r18
   10438:	e0 0d       	add	r30, r0
   1043a:	f1 1d       	adc	r31, r1
   1043c:	64 9f       	mul	r22, r20
   1043e:	e0 0d       	add	r30, r0
   10440:	f1 1d       	adc	r31, r1
   10442:	92 9f       	mul	r25, r18
   10444:	f0 0d       	add	r31, r0
   10446:	83 9f       	mul	r24, r19
   10448:	f0 0d       	add	r31, r0
   1044a:	74 9f       	mul	r23, r20
   1044c:	f0 0d       	add	r31, r0
   1044e:	65 9f       	mul	r22, r21
   10450:	f0 0d       	add	r31, r0
   10452:	99 27       	eor	r25, r25
   10454:	72 9f       	mul	r23, r18
   10456:	b0 0d       	add	r27, r0
   10458:	e1 1d       	adc	r30, r1
   1045a:	f9 1f       	adc	r31, r25
   1045c:	63 9f       	mul	r22, r19
   1045e:	b0 0d       	add	r27, r0
   10460:	e1 1d       	adc	r30, r1
   10462:	f9 1f       	adc	r31, r25
   10464:	bd 01       	movw	r22, r26
   10466:	cf 01       	movw	r24, r30
   10468:	11 24       	eor	r1, r1
   1046a:	08 95       	ret

0001046c <__udivmodqi4>:
   1046c:	99 1b       	sub	r25, r25
   1046e:	79 e0       	ldi	r23, 0x09	; 9
   10470:	04 c0       	rjmp	.+8      	; 0x1047a <__udivmodqi4_ep>

00010472 <__udivmodqi4_loop>:
   10472:	99 1f       	adc	r25, r25
   10474:	96 17       	cp	r25, r22
   10476:	08 f0       	brcs	.+2      	; 0x1047a <__udivmodqi4_ep>
   10478:	96 1b       	sub	r25, r22

0001047a <__udivmodqi4_ep>:
   1047a:	88 1f       	adc	r24, r24
   1047c:	7a 95       	dec	r23
   1047e:	c9 f7       	brne	.-14     	; 0x10472 <__udivmodqi4_loop>
   10480:	80 95       	com	r24
   10482:	08 95       	ret

00010484 <__udivmodhi4>:
   10484:	aa 1b       	sub	r26, r26
   10486:	bb 1b       	sub	r27, r27
   10488:	51 e1       	ldi	r21, 0x11	; 17
   1048a:	07 c0       	rjmp	.+14     	; 0x1049a <__udivmodhi4_ep>

0001048c <__udivmodhi4_loop>:
   1048c:	aa 1f       	adc	r26, r26
   1048e:	bb 1f       	adc	r27, r27
   10490:	a6 17       	cp	r26, r22
   10492:	b7 07       	cpc	r27, r23
   10494:	10 f0       	brcs	.+4      	; 0x1049a <__udivmodhi4_ep>
   10496:	a6 1b       	sub	r26, r22
   10498:	b7 0b       	sbc	r27, r23

0001049a <__udivmodhi4_ep>:
   1049a:	88 1f       	adc	r24, r24
   1049c:	99 1f       	adc	r25, r25
   1049e:	5a 95       	dec	r21
   104a0:	a9 f7       	brne	.-22     	; 0x1048c <__udivmodhi4_loop>
   104a2:	80 95       	com	r24
   104a4:	90 95       	com	r25
   104a6:	bc 01       	movw	r22, r24
   104a8:	cd 01       	movw	r24, r26
   104aa:	08 95       	ret

000104ac <__divmodhi4>:
   104ac:	97 fb       	bst	r25, 7
   104ae:	09 2e       	mov	r0, r25
   104b0:	07 26       	eor	r0, r23
   104b2:	0a d0       	rcall	.+20     	; 0x104c8 <__divmodhi4_neg1>
   104b4:	77 fd       	sbrc	r23, 7
   104b6:	04 d0       	rcall	.+8      	; 0x104c0 <__divmodhi4_neg2>
   104b8:	e5 df       	rcall	.-54     	; 0x10484 <__udivmodhi4>
   104ba:	06 d0       	rcall	.+12     	; 0x104c8 <__divmodhi4_neg1>
   104bc:	00 20       	and	r0, r0
   104be:	1a f4       	brpl	.+6      	; 0x104c6 <__divmodhi4_exit>

000104c0 <__divmodhi4_neg2>:
   104c0:	70 95       	com	r23
   104c2:	61 95       	neg	r22
   104c4:	7f 4f       	sbci	r23, 0xFF	; 255

000104c6 <__divmodhi4_exit>:
   104c6:	08 95       	ret

000104c8 <__divmodhi4_neg1>:
   104c8:	f6 f7       	brtc	.-4      	; 0x104c6 <__divmodhi4_exit>
   104ca:	90 95       	com	r25
   104cc:	81 95       	neg	r24
   104ce:	9f 4f       	sbci	r25, 0xFF	; 255
   104d0:	08 95       	ret

000104d2 <__udivmodsi4>:
   104d2:	a1 e2       	ldi	r26, 0x21	; 33
   104d4:	1a 2e       	mov	r1, r26
   104d6:	aa 1b       	sub	r26, r26
   104d8:	bb 1b       	sub	r27, r27
   104da:	fd 01       	movw	r30, r26
   104dc:	0d c0       	rjmp	.+26     	; 0x104f8 <__udivmodsi4_ep>

000104de <__udivmodsi4_loop>:
   104de:	aa 1f       	adc	r26, r26
   104e0:	bb 1f       	adc	r27, r27
   104e2:	ee 1f       	adc	r30, r30
   104e4:	ff 1f       	adc	r31, r31
   104e6:	a2 17       	cp	r26, r18
   104e8:	b3 07       	cpc	r27, r19
   104ea:	e4 07       	cpc	r30, r20
   104ec:	f5 07       	cpc	r31, r21
   104ee:	20 f0       	brcs	.+8      	; 0x104f8 <__udivmodsi4_ep>
   104f0:	a2 1b       	sub	r26, r18
   104f2:	b3 0b       	sbc	r27, r19
   104f4:	e4 0b       	sbc	r30, r20
   104f6:	f5 0b       	sbc	r31, r21

000104f8 <__udivmodsi4_ep>:
   104f8:	66 1f       	adc	r22, r22
   104fa:	77 1f       	adc	r23, r23
   104fc:	88 1f       	adc	r24, r24
   104fe:	99 1f       	adc	r25, r25
   10500:	1a 94       	dec	r1
   10502:	69 f7       	brne	.-38     	; 0x104de <__udivmodsi4_loop>
   10504:	60 95       	com	r22
   10506:	70 95       	com	r23
   10508:	80 95       	com	r24
   1050a:	90 95       	com	r25
   1050c:	9b 01       	movw	r18, r22
   1050e:	ac 01       	movw	r20, r24
   10510:	bd 01       	movw	r22, r26
   10512:	cf 01       	movw	r24, r30
   10514:	08 95       	ret

00010516 <__divmodsi4>:
   10516:	97 fb       	bst	r25, 7
   10518:	09 2e       	mov	r0, r25
   1051a:	05 26       	eor	r0, r21
   1051c:	0e d0       	rcall	.+28     	; 0x1053a <__divmodsi4_neg1>
   1051e:	57 fd       	sbrc	r21, 7
   10520:	04 d0       	rcall	.+8      	; 0x1052a <__divmodsi4_neg2>
   10522:	d7 df       	rcall	.-82     	; 0x104d2 <__udivmodsi4>
   10524:	0a d0       	rcall	.+20     	; 0x1053a <__divmodsi4_neg1>
   10526:	00 1c       	adc	r0, r0
   10528:	38 f4       	brcc	.+14     	; 0x10538 <__divmodsi4_exit>

0001052a <__divmodsi4_neg2>:
   1052a:	50 95       	com	r21
   1052c:	40 95       	com	r20
   1052e:	30 95       	com	r19
   10530:	21 95       	neg	r18
   10532:	3f 4f       	sbci	r19, 0xFF	; 255
   10534:	4f 4f       	sbci	r20, 0xFF	; 255
   10536:	5f 4f       	sbci	r21, 0xFF	; 255

00010538 <__divmodsi4_exit>:
   10538:	08 95       	ret

0001053a <__divmodsi4_neg1>:
   1053a:	f6 f7       	brtc	.-4      	; 0x10538 <__divmodsi4_exit>
   1053c:	90 95       	com	r25
   1053e:	80 95       	com	r24
   10540:	70 95       	com	r23
   10542:	61 95       	neg	r22
   10544:	7f 4f       	sbci	r23, 0xFF	; 255
   10546:	8f 4f       	sbci	r24, 0xFF	; 255
   10548:	9f 4f       	sbci	r25, 0xFF	; 255
   1054a:	08 95       	ret

0001054c <_exit>:
   1054c:	f8 94       	cli

0001054e <__stop_program>:
   1054e:	ff cf       	rjmp	.-2      	; 0x1054e <__stop_program>
